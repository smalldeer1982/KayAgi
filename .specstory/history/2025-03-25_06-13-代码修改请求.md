<!-- Generated by SpecStory -->

# 代码修改请求 (2025-03-25 14:13:09)

_**User**_

其中需求的内容来源于prompt_dtgh.md，请你修改下代码

---

_**Assistant**_



---

Based on your request, you need to modify the code to fill the "需求" section with content from a "prompt_dtgh.md" file. Here's how to update your code:

```python:akcsp/solutiondeep_dtgh.py
# ... existing code ...
    def __init__(self):
        # 读取配置文件
        config_path = os.path.join(os.path.dirname(__file__), 'config.json')
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
        except Exception as e:
            print(f"读取配置文件失败: {str(e)}")
            raise

        self.client = OpenAI(
            api_key=config.get('api_key'),
            base_url=config.get('base_url'),
        )
        self.model = config.get('model')
        
        # 创建日志目录
        self.log_dir = os.path.join(os.path.dirname(__file__), 'logs')
        os.makedirs(self.log_dir, exist_ok=True)
        
        # 读取需求提示词
        prompt_path = os.path.join(os.path.dirname(__file__), 'prompt_dtgh.md')
        try:
            with open(prompt_path, 'r', encoding='utf-8') as f:
                self.prompt_content = f.read().strip()
        except Exception as e:
            print(f"读取提示词文件失败: {str(e)}")
            self.prompt_content = "请分析上述题目和题解，总结关键思路和难点。"
# ... existing code ...

    def process_content(self, content, input_path,prompt_type="c"):
        messages = None
        try:
            start_time = time.time()
            
            # 预处理内容
            content = self.preprocess_content(content)
            # 拆分题目内容和题解
            parts = content.split("\n# 题解\n")
            
            # 如果没有题解部分，就只处理题目部分
            if len(parts) == 1:
                problem_text = parts[0].strip()
                solutions_text = "# 题解\n\n暂无题解"  # 添加默认题解文本
            elif len(parts) == 2:
                problem_text = parts[0].strip()
                solutions_text = "# 题解\n" + parts[1].strip()
            else:
                raise ValueError("文件格式不正确，包含多个题解部分")
            
            
            if prompt_type == "cn":
                # 构造消息
                messages = [
                    {
                        "role": "system",
                        "content": (
                            "你是一位专业的C++算法助理，帮助用户分析给定的C++题目及多条题解。"
                            "需要对各题解进行要点提炼、难点对比，并给出精炼结论和可视化算法分析。"
                        )
                    },
                    {
                        "role": "user",
                        "content": (
                            "【题目内容】\n"
                            f"{problem_text}\n\n"
                            "【大神题解列表】\n"
                            f"{solutions_text}\n\n"
                            "【需求】\n"
                            f"{self.prompt_content}"
                        )
                    }
                ]
# ... existing code ...
```

This modification makes the following changes:

1. Adds code in the `__init__` method to read the content from the "prompt_dtgh.md" file and store it in a class variable called `self.prompt_content`. If the file can't be read, it sets a default prompt.

2. Updates the `process_content` method to include the prompt content from `self.prompt_content` in the "需求" section of the user message.

Make sure to create a file named "prompt_dtgh.md" in the same directory as your script, containing your desired prompt content for the "需求" section.

---

_**User**_

@ZhimaSubmit.py ，请参考下这个代码，新写一个文件，我主要是要下载那些没有提交过的代码的题目，因为可能都是难题，只有一个链接，然后题目信息下载为md格式，请看下要如何处理。problem_link": f"https://www.zhimaoi.cn{problem_link} 关键是不是这个，我也不确定，请你看下

---

_**Assistant**_



---

Based on your requirements, I'll create a new script that downloads problems you haven't submitted yet (likely difficult problems) and saves them in Markdown format. Here's how we can approach this:

```python:ZhimaDownloadProblems.py
from playwright.sync_api import sync_playwright
import os
import time
import re

# 配置
BASE_URL = "https://www.zhimaoi.cn/org/b3f41b76-6101-444a-9ddf-2aad7ce28b1f/problem?page=1"  # 题目列表页
LOGIN_URL = "https://www.zhimaoi.cn/auth/login/password"
USERNAME = "xuyunxuan"  # 替换为您的用户名
PASSWORD = "20131116"  # 替换为您的密码
OUTPUT_DIR = "zhima_problems"
os.makedirs(OUTPUT_DIR, exist_ok=True)

def login(page):
    print("正在打开登录页面并填写登录信息...")
    page.goto(LOGIN_URL)
    page.fill('input[type="text"]', USERNAME)
    page.fill('input[type="password"]', PASSWORD)
    page.click('button[type="submit"]')

    # 等待登录完成
    page.wait_for_load_state("networkidle")
    if "login" in page.url:
        raise Exception("登录失败，请检查用户名和密码")
    print("登录成功！")

def sanitize_filename(filename):
    """处理文件名，移除非法字符"""
    return re.sub(r'[\\/*?:"<>|]', "_", filename)

def extract_unsubmitted_problems(page, max_pages=5):
    """
    遍历题目列表页，找出未提交的题目
    """
    unsubmitted_problems = []
    current_page = 1
    
    while current_page <= max_pages:
        page_url = BASE_URL.replace("page=1", f"page={current_page}")
        print(f"正在加载第 {current_page} 页题目列表: {page_url}")
        page.goto(page_url)
        
        # 等待表格加载完成
        print("等待表格内容加载...")
        page.wait_for_function(
            """() => {
                const rows = document.querySelectorAll("table tbody tr");
                if (rows.length === 0) return false;
                return Array.from(rows).every(row => !row.innerText.includes("加载中"));
            }""",
            timeout=10000
        )
        
        # 判断是否有下一页
        has_next_page = page.query_selector('button:has-text("下一页")') is not None
        
        # 处理当前页的题目
        rows = page.query_selector_all("table tbody tr")
        print(f"找到 {len(rows)} 条题目数据，开始处理...")
        
        for index, row in enumerate(rows):
            try:
                # 提取问题标题和链接
                title_element = row.query_selector("td:nth-child(3) a")
                if not title_element:
                    continue
                    
                title = title_element.inner_text().strip()
                problem_link = title_element.get_attribute("href")
                
                # 检查是否有提交记录（通常会有一个状态指示器）
                # 这里根据界面结构可能需要调整 - 假设未提交的题目在某列显示为"未提交"或为空
                status_element = row.query_selector("td:nth-child(5)")  # 假设第5列是状态列
                
                # 检查状态是否为空或"未提交"（具体根据界面调整）
                if status_element and (not status_element.inner_text().strip() or "未提交" in status_element.inner_text()):
                    print(f"找到未提交题目: {title}")
                    unsubmitted_problems.append({
                        "title": title,
                        "problem_link": f"https://www.zhimaoi.cn{problem_link}" if problem_link else None
                    })
            except Exception as e:
                print(f"第 {index + 1} 行处理失败: {e}")
        
        if not has_next_page or current_page >= max_pages:
            break
            
        current_page += 1
        
    print(f"共找到 {len(unsubmitted_problems)} 条未提交的题目")
    return unsubmitted_problems

def fetch_problem_to_md(page, problem):
    """
    获取题目详情并保存为Markdown格式
    """
    if not problem.get("problem_link"):
        return False
        
    print(f"正在获取题目详情: {problem['title']}")
    page.goto(problem["problem_link"])
    
    try:
        # 等待题目内容加载
        page.wait_for_function(
            """() => {
                const content = document.querySelector('.markdown-body');
                return content && content.innerText.trim().length > 0;
            }""",
            timeout=10000
        )
        
        # 获取题目标题和内容
        title = problem["title"]
        problem_content = page.query_selector(".markdown-body").inner_html()
        
        # 将HTML内容转换为Markdown格式
        # 这是一个简单的处理，可能需要进一步优化
        problem_content = page.evaluate("""(html) => {
            return html
                .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\\n\\n')
                .replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\\n\\n')
                .replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\\n\\n')
                .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\\n\\n')
                .replace(/<h5[^>]*>(.*?)<\/h5>/gi, '##### $1\\n\\n')
                .replace(/<h6[^>]*>(.*?)<\/h6>/gi, '###### $1\\n\\n')
                .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\\n\\n')
                .replace(/<br\s*\/?>/gi, '\\n')
                .replace(/<ul[^>]*>(.*?)<\/ul>/gis, '$1\\n')
                .replace(/<ol[^>]*>(.*?)<\/ol>/gis, '$1\\n')
                .replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\\n')
                .replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`')
                .replace(/<pre[^>]*>(.*?)<\/pre>/gis, '```\\n$1\\n```\\n')
                .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
                .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
                .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)')
                .replace(/<[^>]*>/g, '')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&amp;/g, '&')
                .replace(/&quot;/g, '"')
                .replace(/&apos;/g, "'")
                .trim();
        }""", problem_content)
        
        # 创建Markdown文件
        filename = sanitize_filename(f"{title}.md")
        filepath = os.path.join(OUTPUT_DIR, filename)
        
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(f"# {title}\n\n")
            f.write(problem_content)
            f.write(f"\n\n---\n来源: {problem['problem_link']}")
        
        print(f"成功保存题目: {filepath}")
        return True
    except Exception as e:
        print(f"获取题目详情失败: {e}")
        return False

def main():
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False)  # headless=False 可以看到浏览器操作过程
        page = browser.new_page()
        
        try:
            # 登录
            login(page)
            
            # 获取未提交的题目列表
            problems = extract_unsubmitted_problems(page)
            
            if not problems:
                print("未找到未提交的题目，程序结束。")
                return
                
            # 逐个下载题目详情
            for i, problem in enumerate(problems):
                print(f"正在处理第 {i+1}/{len(problems)} 个题目")
                success = fetch_problem_to_md(page, problem)
                if success:
                    print(f"成功下载题目 {i+1}/{len(problems)}")
                else:
                    print(f"下载题目 {i+1}/{len(problems)} 失败")
                # 短暂等待，避免请求过快
                time.sleep(1)
                
            print(f"处理完成，共下载 {len(problems)} 个题目")
            
        except Exception as e:
            print(f"程序执行过程中出现错误: {e}")
        finally:
            browser.close()

if __name__ == "__main__":
    main()
```

**关于识别未提交的题目:**

我注意到你不确定如何识别未提交的题目。根据您提供的代码和常见的学习平台设计，通常识别未提交题目的几种可能方式：

1. **状态列识别**: 题目列表中通常会有一列显示提交状态，可能是空白、"未提交"或有特定图标
2. **颜色识别**: 未提交的题目可能使用特定颜色标记
3. **接口数据**: 页面加载时的请求数据中可能包含题目的提交状态

在我的代码中，我使用了一种基于状态列的方法，假设第5列是状态列（与原代码中提取评测结果的列相同）。但你可能需要根据实际页面结构进行以下调整：

1. 检查网站上未提交题目的实际显示方式
2. 修改代码中的选择器（`"td:nth-child(5)"`）和判断条件（`not status_element.inner_text().strip() or "未提交" in status_element.inner_text()`）

你可能需要登录到网站，人工检查一些已提交和未提交的题目，观察它们在页面上的区别，然后据此调整代码中的选择器和判断逻辑。

如果需要更精确的识别，你可以考虑使用开发者工具观察页面结构和CSS类名，找到标识未提交题目的确切元素。

---

_**User**_

需要在调整下，我会直接给你一个链接，而不是一个列表

---

_**Assistant**_



---

Understood! I'll create a script that takes a direct problem link as input, rather than searching through a problem list. Here's the modified version:

```python:ZhimaDownloadSingleProblem.py
from playwright.sync_api import sync_playwright
import os
import re
import argparse
import time

# 配置
LOGIN_URL = "https://www.zhimaoi.cn/auth/login/password"
USERNAME = "xuyunxuan"  # 替换为您的用户名
PASSWORD = "20131116"  # 替换为您的密码
OUTPUT_DIR = "zhima_problems"
os.makedirs(OUTPUT_DIR, exist_ok=True)

def login(page):
    """登录芝麻平台"""
    print("正在打开登录页面并填写登录信息...")
    page.goto(LOGIN_URL)
    page.fill('input[type="text"]', USERNAME)
    page.fill('input[type="password"]', PASSWORD)
    page.click('button[type="submit"]')

    # 等待登录完成
    page.wait_for_load_state("networkidle")
    if "login" in page.url:
        raise Exception("登录失败，请检查用户名和密码")
    print("登录成功！")

def sanitize_filename(filename):
    """处理文件名，移除非法字符"""
    return re.sub(r'[\\/*?:"<>|]', "_", filename)

def fetch_problem_to_md(page, problem_url):
    """获取指定链接的题目并保存为Markdown格式"""
    print(f"正在访问题目链接: {problem_url}")
    page.goto(problem_url)
    
    try:
        # 等待题目内容加载
        page.wait_for_function(
            """() => {
                const content = document.querySelector('.markdown-body');
                return content && content.innerText.trim().length > 0;
            }""",
            timeout=10000
        )
        
        # 获取题目标题
        title_element = page.query_selector("h1.text-xl")
        if not title_element:
            # 尝试其他可能的标题选择器
            title_element = page.query_selector(".problem-title") or page.query_selector("h1")
        
        title = title_element.inner_text().strip() if title_element else "未知题目"
        print(f"获取到题目标题: {title}")
        
        # 获取题目内容
        problem_content = page.query_selector(".markdown-body").inner_html()
        
        # 将HTML内容转换为Markdown格式
        problem_content = page.evaluate("""(html) => {
            return html
                .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\\n\\n')
                .replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\\n\\n')
                .replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\\n\\n')
                .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\\n\\n')
                .replace(/<h5[^>]*>(.*?)<\/h5>/gi, '##### $1\\n\\n')
                .replace(/<h6[^>]*>(.*?)<\/h6>/gi, '###### $1\\n\\n')
                .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\\n\\n')
                .replace(/<br\s*\/?>/gi, '\\n')
                .replace(/<ul[^>]*>(.*?)<\/ul>/gis, '$1\\n')
                .replace(/<ol[^>]*>(.*?)<\/ol>/gis, '$1\\n')
                .replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\\n')
                .replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`')
                .replace(/<pre[^>]*>(.*?)<\/pre>/gis, '```\\n$1\\n```\\n')
                .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
                .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
                .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)')
                .replace(/<[^>]*>/g, '')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&amp;/g, '&')
                .replace(/&quot;/g, '"')
                .replace(/&apos;/g, "'")
                .trim();
        }""", problem_content)
        
        # 创建Markdown文件
        filename = sanitize_filename(f"{title}.md")
        filepath = os.path.join(OUTPUT_DIR, filename)
        
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(f"# {title}\n\n")
            f.write(problem_content)
            f.write(f"\n\n---\n来源: {problem_url}")
        
        print(f"成功保存题目: {filepath}")
        return True
    except Exception as e:
        print(f"获取题目详情失败: {e}")
        return False

def main():
    # 设置命令行参数解析
    parser = argparse.ArgumentParser(description='下载芝麻平台题目为Markdown格式')
    parser.add_argument('url', help='题目的完整URL链接')
    args = parser.parse_args()
    
    problem_url = args.url
    
    # 确保URL合法
    if not problem_url.startswith("https://www.zhimaoi.cn/"):
        print("错误: URL必须是芝麻平台的链接")
        return
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False)  # headless=False 可以看到浏览器操作过程
        page = browser.new_page()
        
        try:
            # 登录
            login(page)
            
            # 下载指定题目
            success = fetch_problem_to_md(page, problem_url)
            
            if success:
                print("题目下载成功！")
            else:
                print("题目下载失败。")
                
        except Exception as e:
            print(f"程序执行过程中出现错误: {e}")
        finally:
            browser.close()

if __name__ == "__main__":
    main()
```

### 使用说明:

1. 保存上面的代码为 `ZhimaDownloadSingleProblem.py`
2. 使用以下命令运行程序:

```
python ZhimaDownloadSingleProblem.py https://www.zhimaoi.cn/problem/your-problem-id
```

替换 `https://www.zhimaoi.cn/problem/your-problem-id` 为你想要下载的实际题目链接。

### 功能说明:

1. 接受命令行参数传入一个题目链接
2. 登录芝麻平台
3. 访问指定题目链接
4. 提取题目标题和内容
5. 将HTML内容转换为Markdown格式
6. 保存为Markdown文件到 `zhima_problems` 目录下

如果你不想使用命令行参数，而是直接在代码中指定链接，可以修改 `main()` 函数为:

```python
def main():
    # 直接指定题目链接
    problem_url = "https://www.zhimaoi.cn/problem/your-problem-id"
    
    # 确保URL合法
    if not problem_url.startswith("https://www.zhimaoi.cn/"):
        print("错误: URL必须是芝麻平台的链接")
        return
    
    with sync_playwright() as p:
        # 其余代码不变...
```

有需要进一步定制的部分，请告诉我。

---

_**User**_

链接需要在python文件中，我会修改

---

_**Assistant**_



---

Understood! I'll modify the script to have the problem link directly in the Python file itself. Here's the updated version:

```python:ZhimaDownloadProblem.py
from playwright.sync_api import sync_playwright
import os
import re
import time

# 配置
LOGIN_URL = "https://www.zhimaoi.cn/auth/login/password"
USERNAME = "xuyunxuan"  # 替换为您的用户名
PASSWORD = "20131116"  # 替换为您的密码
OUTPUT_DIR = "zhima_problems"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# 题目链接 - 在这里修改为您要下载的题目链接
PROBLEM_URL = "https://www.zhimaoi.cn/problem/your-problem-id"  # 请替换为实际题目链接

def login(page):
    """登录芝麻平台"""
    print("正在打开登录页面并填写登录信息...")
    page.goto(LOGIN_URL)
    page.fill('input[type="text"]', USERNAME)
    page.fill('input[type="password"]', PASSWORD)
    page.click('button[type="submit"]')

    # 等待登录完成
    page.wait_for_load_state("networkidle")
    if "login" in page.url:
        raise Exception("登录失败，请检查用户名和密码")
    print("登录成功！")

def sanitize_filename(filename):
    """处理文件名，移除非法字符"""
    return re.sub(r'[\\/*?:"<>|]', "_", filename)

def fetch_problem_to_md(page, problem_url):
    """获取指定链接的题目并保存为Markdown格式"""
    print(f"正在访问题目链接: {problem_url}")
    page.goto(problem_url)
    
    try:
        # 等待题目内容加载
        page.wait_for_function(
            """() => {
                const content = document.querySelector('.markdown-body');
                return content && content.innerText.trim().length > 0;
            }""",
            timeout=10000
        )
        
        # 获取题目标题
        title_element = page.query_selector("h1.text-xl")
        if not title_element:
            # 尝试其他可能的标题选择器
            title_element = page.query_selector(".problem-title") or page.query_selector("h1")
        
        title = title_element.inner_text().strip() if title_element else "未知题目"
        print(f"获取到题目标题: {title}")
        
        # 获取题目内容
        problem_content = page.query_selector(".markdown-body").inner_html()
        
        # 将HTML内容转换为Markdown格式
        problem_content = page.evaluate("""(html) => {
            return html
                .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\\n\\n')
                .replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\\n\\n')
                .replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\\n\\n')
                .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\\n\\n')
                .replace(/<h5[^>]*>(.*?)<\/h5>/gi, '##### $1\\n\\n')
                .replace(/<h6[^>]*>(.*?)<\/h6>/gi, '###### $1\\n\\n')
                .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\\n\\n')
                .replace(/<br\s*\/?>/gi, '\\n')
                .replace(/<ul[^>]*>(.*?)<\/ul>/gis, '$1\\n')
                .replace(/<ol[^>]*>(.*?)<\/ol>/gis, '$1\\n')
                .replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\\n')
                .replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`')
                .replace(/<pre[^>]*>(.*?)<\/pre>/gis, '```\\n$1\\n```\\n')
                .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
                .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
                .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)')
                .replace(/<[^>]*>/g, '')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&amp;/g, '&')
                .replace(/&quot;/g, '"')
                .replace(/&apos;/g, "'")
                .trim();
        }""", problem_content)
        
        # 创建Markdown文件
        filename = sanitize_filename(f"{title}.md")
        filepath = os.path.join(OUTPUT_DIR, filename)
        
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(f"# {title}\n\n")
            f.write(problem_content)
            f.write(f"\n\n---\n来源: {problem_url}")
        
        print(f"成功保存题目: {filepath}")
        return True
    except Exception as e:
        print(f"获取题目详情失败: {e}")
        return False

def main():
    # 确保URL合法
    if not PROBLEM_URL.startswith("https://www.zhimaoi.cn/"):
        print("错误: URL必须是芝麻平台的链接")
        return
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False)  # headless=False 可以看到浏览器操作过程
        context = browser.new_context()
        page = context.new_page()
        
        try:
            # 登录
            login(page)
            
            # 下载指定题目
            success = fetch_problem_to_md(page, PROBLEM_URL)
            
            if success:
                print("题目下载成功！")
            else:
                print("题目下载失败。")
                
        except Exception as e:
            print(f"程序执行过程中出现错误: {e}")
        finally:
            browser.close()

if __name__ == "__main__":
    main()
```

### 使用说明:

1. 保存上面的代码为 `ZhimaDownloadProblem.py`
2. 找到代码中的 `PROBLEM_URL` 变量并将其修改为您要下载的实际题目链接
   ```python
   PROBLEM_URL = "https://www.zhimaoi.cn/problem/your-problem-id"  # 修改这一行
   ```
3. 运行程序:
   ```
   python ZhimaDownloadProblem.py
   ```

如果您需要经常下载不同的题目，您也可以考虑创建一个题目列表，然后逐个下载:

```python
# 定义多个题目链接
PROBLEM_URLS = [
    "https://www.zhimaoi.cn/problem/id1",
    "https://www.zhimaoi.cn/problem/id2",
    "https://www.zhimaoi.cn/problem/id3",
]

def main():
    # ...其他代码保持不变...
    
    try:
        # 登录
        login(page)
        
        # 下载所有指定题目
        for url in PROBLEM_URLS:
            print(f"\n正在处理题目: {url}")
            success = fetch_problem_to_md(page, url)
            
            if success:
                print(f"题目下载成功!")
            else:
                print(f"题目下载失败。")
            
            # 短暂等待，避免请求过快
            time.sleep(1)
    # ...其他代码保持不变...
```

您可以根据需要随时更改代码中的题目链接列表。

---

_**User**_

@ZhimaDownloadProblem.py 基本可以，2个问题 1.zhima_problems放在cpp/zhima 文件夹下。2.现在应该是标题没取到，都是未知题目，你在参考下@ZhimaSubmit.py 看看能否修正下这个问题

---

_**Assistant**_



---



---


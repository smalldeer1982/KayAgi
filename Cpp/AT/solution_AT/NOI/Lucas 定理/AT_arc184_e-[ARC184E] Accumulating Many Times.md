# [ARC184E] Accumulating Many Times

## 题目描述

给定 $N$ 个长度为 $M$ 的整数序列，每个序列的元素是 $0$ 或 $1$。第 $i$ 个序列记为 $A_i = (A_{i,1}, A_{i,2}, \dots, A_{i,M})$。

我们定义一个函数 $f(i, j)$，用于两个序列 $A_i$ 和 $A_j$ 之间的运算：

- $f(i, j)$ 是最小的非负整数 $x$，满足将 $A_i$ 进行以下操作 $x$ 次后，可以使得 $A_i$ 和 $A_j$ 相等。如果没有这样的 $x$ 能够满足条件，则 $f(i, j) = 0$。
  - 具体操作是：对于每个整数 $k\ (1 \leq k \leq M)$，同时将 $A_{i,k}$ 替换为 $\left( \sum_{l=1}^{k} A_{i,l} \right) \bmod 2$。

要求计算并输出 $\sum_{i=1}^{N} \sum_{j=i}^{N} f(i, j)$，结果需要对 $998244353$ 取模。

## 说明/提示

- $1 \leq N \times M \leq 10^6$
- 对任意整数 $A_{i,j}$，都有 $A_{i,j} \in \{0, 1\}$

### 示例说明

例如，$f(1, 1) = 0$，$f(1, 2) = 3$，$f(1, 3) = 2$，$f(1, 4) = 0$，$f(2, 2) = 0$，$f(2, 3) = 3$，$f(2, 4) = 0$，$f(3, 3) = 0$，$f(3, 4) = 0$，$f(4, 4) = 0$。因此，这些值的总和为 $8$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4 3
1 0 0
1 1 0
1 0 1
0 1 1```

### 输出

```
8```

## 样例 #2

### 输入

```
7 6
1 0 0 0 0 0
1 1 1 0 0 0
1 0 1 1 0 0
1 0 0 0 1 1
1 0 0 0 0 1
1 0 0 0 0 0
1 1 1 1 1 1```

### 输出

```
6```

# 题解

## 作者：Argon_Cube (赞：18)

提供一个不需要 NTT 的解法。

---

首先前缀和的性质没有差分好，所以我们将 $f(i,j)$ 等价的定义为最小的 $k$ 使得 $A_j$ 做 $k$ 次**差分**后得到 $A_i$。

从优化单个 $f(i,j)$ 的角度入手并不很好做。显然本题需要考虑类似于 Hash 一类的东西，如果两个串的 Hash 值相同则一个就可以做差分变成另一个。

发现差分是有周期的，对于任何一个数组 $a$ 都存在一个数 $f(a)$ 使得 $a$ 在做 $f(a)$ 次差分后会变回 $a$。那么不断差分实际上就是在一个环上转，不同环上的点互相不可达。可以找到每个点 $u$ 在环上的位置 $p_u$，那么同一个环上，令环长为 $m$，从 $u$ 到 $v$ 的距离就是 $(p_v-p_u)\pmod m$。

现在我们需要做两件事，第一是确定环长，第二是为了区分不同的环我们要从每个环上选一个点做代表，这样我们就可以以这个点为参考确定每个点的位置。

首先有一个重要的 trick：现在我们想要求一个数组 $F$ 在 $\bmod~2$ 意义下的 $k$ 阶差分 $(1-x)^kF$。首先将 $k$ 进行二进制拆分：

$$(1-x)^kF\equiv F\prod(1+x)^{2^{k_i}}\pmod 2$$

然后 $(1+x)^{2^k}\equiv 1+x^{2^k}\pmod 2$，于是后面那 $\Omicron(\log k)$ 个多项式都只有两项，直接暴力乘就没了。

现在先考虑第二个问题。我们可以选取字典序最小的那个数组作为一个环的代表。为了求出每个数组 $a$ 可以到达的字典序最小的数组 $a'$，我们考虑令 $k$ 从小到大依次决定是否要乘上 $(1+x)^{2^k}$。令 $a_i=1$ 且 $a_{j}=0(j<i)$，那么乘上 $(1+x)^{2^k}$ 时第一个会变化的位置就是 $a_{i+2^k}$，可以由此决定要不要乘。同时这个过程也同时求出了 $a$ 到 $a'$ 的距离 $p_a$。

从上述过程容易知道第一个问题的答案：环长就是最小的 $2^k$ 使得 $i+2^k>m$。于是我们就只需要解决形如 $\sum_{1\leq i\leq j\leq n}((p_i-p_j)\bmod m)$ 的问题，容易用树状数组解决。

[Code.](https://atcoder.jp/contests/arc184/submissions/58116071)

---

## 作者：lsj2009 (赞：4)

## Description

给定 $n$ 个长为 $m$ 的 $\tt 01$ 串 $A_{1\sim n}$，定义 $f(i,j)$ 表示最小的 $k$ 使得 $A_i$ 的 $k$ 次异或前缀和等于 $A_j$，若不存在则令 $f(i,j)=0$。

求 $\left(\sum\limits_{1\le i\le j\le n}f(i,j)\right)\bmod{998244353}$。

## Solution

异或前缀和性质没有异或差分好（因为前缀和与 $1\sim j$ 均相关，差分之和 $j-1,j$ 相关，或者这从后文可以更自然地表现出来），故我们转换为每次对 $A_j$ 进行 **差分** 操作，求最小操作次数使得 $A_j=A_i$。

将问题刻画在图论上，记对于 $A$ 进行差分操作得到 $\Delta A$（进行 $k$ 次操作得到 $\Delta^k A$），则连边 $A\to \Delta A$。

我们发现：**每个 $A$ 存在唯一的出边和入边**。前者显然，后者因为 $\Delta B=A$ 是有唯一解的，因为 $B$ 也就是 $A$ 的异或前缀和数组。

也就是：**我们建出来的图必然由若干个环组成**。

则 $f(A_i,A_j)$ 为路径 $A_j\to A_i$ 在环上的长度，如果两者不在同一环内则为 $0$。

下面便于讨论，假设所有 $A_i$ 均在同一置换环内，若不在则对于每个置换环求解即可。

我们考虑取出环上的一个 **代表点 $C$** 以及环长 $\ell$，求出 $d_i=\operatorname{len}(C\to A_i)\le len$，则 $f(i,j)=(d_i-d_x)\bmod{\ell}$。

从小到大扫描 $i$，然后把他加入集合 $S$，每次即求出 $\sum\limits_{x\in S}(d_i-d_j)\bmod{\ell}$ 然后求和，对于 $d_i\ge d_j$ 和 $d_i<d_j$ 分别计算贡献，容易使用树状数组维护，复杂度 $\mathcal{O}(n\log{n})$。

问题在于如何求出 $d_i$ 和 $\ell$。

不妨取代表点 $C$ 为环上 **字典序最小的点**。

我们将差分刻画为多项式乘法的形式：

$$
\begin{aligned}
\Delta A & \equiv(1-x)A\equiv (1+x)A\pmod{2}\\
\end{aligned}
$$

这里多项式 $F(x)=G(x)\bmod{2}$ 的含义是按位取模（进行加法时就是进行异或），即得到 $F(x)=\sum\limits ([x^i]G(x)\bmod{2})x^i$。

进一步得 $\Delta^k A=(1+x)^kA\pmod{2}$。

考虑拆分：$k=\sum\limits 2^{p_i}$，即得到 $\Delta^k A=\left(\prod(1+x)^{2^{p_i}}\right)A$。观察 $(1+x)^{2^{p_i}}$：

$$
\begin{aligned}
& (1+x)^{2^{p_i}}\\
\equiv & \sum\limits_{j=0}^{2^{p_i}} \binom{2^{p_i}}{j}x^j\\
\equiv & \sum\limits_{j=0}^{2^{p_i}} [j\subseteq 2^{p_i}]x^j\\
\equiv & 1+x^{2^{p_i}}
\end{aligned}
$$

其中用到了 Lucas 定理的推论：$\binom{n}{m}\equiv[m\subseteq n]\pmod{2}$。

所以 $\Delta^k A=\left(\prod\left(1+x^{2^{p_i}}\right)\right)A$。

找到 $A$ 首个 $1$ 的位置 $t$（特判全 $0$），则 $t$ 始终为 $1$，发现若进行 $\Delta^{2^p}$ 操作，则 $A_{t+2^p}$ **必然是首个发生变化的位置**，且有 $p_1<p_2\Rightarrow t+2^{p_1}<t+2^{p_2}$，即 **越小的 $p$ 优先级越高**。

所以我们 **从小往大枚举 $p$**，每次依据当前 $A_{t+2^p}$ 值考虑是否进行 $\Delta^{2^p}$ 操作，最终 $d_i=\sum 2^{p_i}$。进行一次操作暴力更新就是 $\mathcal{O}(m)$ 的，显然有 $p\le\lfloor\log{m-t}\rfloor$，所以这一部分复杂度就是 $\mathcal{O}(nm\log{m})$，可以接受。

然后是如何求出 $\ell$，那我们接受要找到那个最不牛的点，也就是 $\ell=\max d+1$，那就是 **每次都进行操作**（并且根据操作还原回去，显然存在这样子的点），共进行 $\lfloor\log{m-t}\rfloor$ 次操作，所以 $\ell=\left(\sum\limits_{i=0}^{\lfloor\log{m-t}\rfloor} 2^i\right)+1=2^{\lfloor\log{m-t}\rfloor+1}$。

然后就解决了所有问题，复杂度 $\mathcal{O}(nm\log{m}+n\log{n})$。

[code link](https://atcoder.jp/contests/arc184/submissions/60880120)。

---

## 作者：MatrixGroup (赞：3)

## 前言

表白看到这里的题解审核志愿者，您辛苦了/qq

## 题解

先考虑如何计算贡献。不妨为每个等价类寻找一个代表元，对于同一个等价类中的 $i,j$，若 $i$ 走到代表元需要 $x_i$ 步，$j$ 走到代表元需要 $x_j$ 步，周期为 $L$，则 $f(i,j)=\begin{cases}x_i-x_j&x_i\ge x_j\\x_i-x_j+L&x_i<x_j\end{cases}$。我们只需要找出每个 $x_i,L$ 和所在等价类，对于每个等价类，计算每个 $x$ 的贡献（容易）和 $L$ 的贡献（可以使用树状数组维护）。

不妨令每个等价类的代表元为字典序最小的序列。注意到做 $2^k$ 次前缀和的效果相当于每隔 $2^k$ 的距离做前缀和，这容易由 Lucas 定理证明。因此设序列 $a$ 第一个满足 $a_i=1$ 的位置为 $i=i_0$，则每次根据字典序的贪心原则按照 $a_{i_0+2^k}$ 确定是否需要做 $2^k$ 次前缀和即可。

## 实现

[链接](https://atcoder.jp/contests/arc184/submissions/58210020)

---

## 作者：qiuzx (赞：2)

注意到给定一个序列 $a$ 和一个步数 $k$，有一种能够快速计算变换 $k$ 次之后的序列 $a$ 的方式。每次同时将 $a_i$ 变为其前缀和其实等价于从左往右依次将 $a_i+=a_{i-1}$，这个过程类似于 Pascal 三角形的计算过程，所以系数应当和组合数相关。经过简单的推导可以发现，若初始只有 $a_1=1$，则在经过 $k$ 次变换之后 $\displaystyle a_i\equiv \binom{k+i-2}{i-1}\pmod 2$。根据 Lucas 定理可以 $O(1)$ 算出这个值。若初始有多个 $1$，它们的贡献是独立的，所以可以叠加。因此最终我们的结论是经过 $k$ 次变换得到的新序列 $a'$ 满足 $\displaystyle a'_i=\left(\sum_{j=1}^ia_j\binom{k+i-j-1}{i-j}\right)\bmod 2$，这个可以使用 NTT 做到 $O(n\log n)$。

由于这个 Lucas 定理的结论，比较容易发现整个变换的过程是周期性的（因为 $i-j$ 的取值有限，所以 $k$ 在二进制较高位上的取值不会影响答案），并且对于一个长度为 $n$ 的序列（且已去除了没用的前导零，即 $a_1=1$），其周期大小为最小的 $>n$ 的 $2$ 的幂。这个结论也可以通过打表简单验证。具体证明就是考虑设 $m$ 为这个周期，则对于任意 $0\le i<j<m$，可以在上述式子中带入 $i,j$ 验证得到存在一个位置不同。而对于 $i\equiv j\pmod m$，它们显然是一样的。

这个周期性同时也隐含了一个条件，即这个操作是可逆的（不过这个结论比较显然，直接做一次差分就是其逆运算）。这样若将所有 $2^n$ 种可能的序列向它们变换得到的序列连边，则必然构成若干个环。这样我们只需要将所有 $n$ 个序列按照它们所处的环分类，并在每个环上计算答案即可。

为了确定一个序列在哪个环上，一个比较好的方式就是在一个环上找一个代表元，然后将每个序列变换为这个代表元即可。那么很自然可以想到将每个序列变成其能变成的字典序最小的序列，这样如果两个序列变成的序列一样，它们就是处于同一个环上的。进一步地，由于我们需要计算两两之间在环上的距离，所以我们还需要知道环长以及每个序列移动到这个字典序最小的序列所需要的步数。

字典序最小自然就是从前往后贪心考虑。首先去掉没用的前导零使得 $a_1=1$，则此时最终的环长已经可以算出了。而在我们逐个添加字符的过程中，如果在某个时刻将序列长度 $n$ 恰好变为了某个 $2^k+1$，则说明加入新的字符之后周期翻了一倍，否则周期没有改变。对于后者，由于前面取到字典序最小的前缀这件事在整个周期中只有一次，所以当前位置没有别的选择。另一方面，对于前者，我们可以选择第一个或第二个原来的周期。由于此时周期恰好翻一倍，所以这两个位置必然一个是 $0$ 一个是 $1$，则我们选择 $0$ 的那个即可。整个过程中只有 $O(\log m)$ 个时刻需要做出这样的选择，所以每次暴力 $O(m)$ 用前面 Lucas 定理的结论算出哪种方式可以得到 $0$ 即可。

显然这个过程结束后环长以及步数都自然被求出了，但对于那些没有改变环长的位置，我们目前仍不知道其具体的值是什么。所以为了求出这个字典序最小的序列，我们还需使用一开始的 NTT 来算出当前步数下的整个序列。

最后我们将所有序列按照其所在环分类之后需要解决的问题变成了：给定 $len$ 以及序列 $a_1,\cdots,a_n$。求 $\sum_{i\le j}(a_i-a_j)\bmod len$，容易使用 BIT 或线段树解决。复杂度 $O(nm\log nm)$。

[代码](https://atcoder.jp/contests/arc184/submissions/58051754)

---

## 作者：cpchenpi (赞：1)

## 题意简述

给你 $n$ 个长度为 $m$ 的 0/1 序列 $A_1, A_2, \cdots, A_n$。

定义 $f(i, j)$ 为将序列 $A_i$ 变为 $A_j$ 需要的最少操作数，其中每一次操作你可以将 $A_i$ 变为它 $Z_2$ 下的前缀和（异或前缀和）。若 $A_i$ 无法变为 $A_j$，令 $f(i, j) = 0$。

求 $\sum\limits_{i=1}^n \sum\limits_{j=i}^n f(i, j)$，对 $998244353$ 取模。

## 写在前面

这题我看官解没看懂，本来是不打算补的，结果看到一个 [User Editorial](https://atcoder.jp/contests/arc184/editorial/11007) 写的非常好，处理方式很 neat，看懂了，于是就补了。所以我决定把它翻译并补充一些细节发出来，方便参考。

## 原 User Editorial 的翻译

**声明：我不懂日语，所以只能借助 ChatGPT 和我自己的理解来完成这部分，并且对记号略有修改。如有错误欢迎指正。**

不妨设 $m$ 为 $2$ 的幂。如果不是，可以在序列的开头补 $0$，不影响复杂度以及结果。

定义 $v_j$ 为长为 $m$ 的向量，下标从 $0$ 开始，且 $v_{ji} = 1$ 当且仅当 $i \mathbin {\rm and} j = j$（这里的 $\rm and$ 指按位与）。则我们可以发现，$v_j$ 经过一次操作后变为 $v_{j - 1}$（$v_0$ 变为 $v_{m-1}$）。例如，$m=8$ 时的变化如下：

``` text
11111111 = v_7
10101010 = v_6
11001100 = v_5
10001000 = v_4
11110000 = v_3
10100000 = v_2
11000000 = v_1
10000000 = v_0
11111111 = v_7
10101010 = v_6
...
```

这个观察可以由二项式系数模 $2$ 的性质（译注：Lucas 定理）得出。

那么，我们如果将 $w$ 表示为 $\{v\}$ 的线性组合 $w = b_0 v_0 + b_1 v_1 + \cdots + b_{m-1} v_{m-1}$，进行一次操作可以表示为对 $b$ 的循环左移 $b_1 v_0 + b_2 v_1 + \cdots + b_{0} v_{m - 1}$。

$\{b\}$ 可以通过子集莫比乌斯变换 $O(m \log m)$ 求出来。

对表示转换后，问题转化为如下：

给定一列序列（字符串）$S_1, \cdots, S_n$。定义 $f(i, j)$ 为将 $S_i$ 循环左移得到 $S_j$ 需要的最小次数。求

这个问题可以使用 Z 函数、后缀数组、线段树等方法在 $O(nm\log m)$ 解决。这一部分可以通过 ABC 类问题的分析来处理，因此具体细节省略。（原文如此）

## 细节补充

文章中略去了不少细节，下面一一具体解释。**注意**：虽然我需要一些思考，下面的细节对你也许是一目了然的，可以选择性观看。

### 1. $v_j$ 经过一次操作后变为 $v_{j - 1}$

我们从多项式的角度看这个问题。写出序列的生成函数 $F = a_0 + a_1 x + \cdots + a_{m-1} x_{m-1}$（长度为 $m$，即在 ${\rm mod}\ x^m$ 下操作），那么前缀和变换相当于将生成函数乘以 $1 + x + \cdots + x_{m-1}$。

反过来考虑这个问题。前缀和的逆变换是乘以 $1 + x$，因为系数对 $2$ 取余时，$(1 + x + \cdots + x_{m-1})(1+x) = 1 + 2x + \cdots + 2 x^{m - 1} + x^m = 1$。

我们发现 $v_j$ 的生成函数正是 $(1 + x)^j$，这是因为根据 Lucas 定理，$\binom{j}{i} = 1 \Leftrightarrow i \mathbin {\rm and} j = j$，那么 $v_j$ 经过一次逆变换变为 $v_{j + 1}$。因此原命题得证。

**注意**：从多项式考虑不是必须的。多次前缀和是经典的模型，二项式系数模 $2$ 也是经典的结论。你也可以打表观察出结论，并使用数学归纳法证明。

### 2. 为什么从 $w$ 到 $\{b\}$ 的变换是一一对应，以及怎么求出变换后的结果

看到一一对应的第一反应就是从线性代数考虑。把所有向量写为列向量，记矩阵 $V = [v_0, \cdots, v_{m - 1}]$。那么我们想要做的其实就是，证明 $V$ 是可逆（满秩）矩阵，以及如何快速解方程 $V b = w$。

容易观察（由二进制也容易证明）$V$ 具有递归结构。具体地，记 $V_m$ 为对于长为 $m$ 问题的 $V$ 矩阵，我们有 $V_m = \begin{bmatrix} V_{m/2}  & V_{m/2} \\ & V_{m/2} \end{bmatrix}$。做块初等变换可以得到 $\begin{bmatrix} V_{m/2}  & \\ & V_{m/2} \end{bmatrix}$，因此 $V_m$ 满秩当且仅当 $V_{m/2}$ 满秩，而 $V_1 = [1]$ 显然满秩。因此命题得证。

对于第二个问题，我们同样用递归结构来解决。具体地，我们把 $w$ 和 $b$ 也分为上下两半，则要解方程 $\begin{bmatrix} V_{m/2}  & V_{m/2} \\ & V_{m/2} \end{bmatrix} \begin{bmatrix} b_0 \\ b_1 \end{bmatrix} = \begin{bmatrix} w_0 \\ w_1 \end{bmatrix}$。同样做块初等变换，有 $\begin{bmatrix} V_{m/2} &  \\ & V_{m/2} \end{bmatrix} \begin{bmatrix} b_0 \\ b_1 \end{bmatrix} = \begin{bmatrix} w_0 + w_1 \\ w_1 \end{bmatrix}$，也就是我们把问题转化成了两个大小为 $m / 2$ 的子问题，并且可以 $O(m)$ 合并。根据主定理时间复杂度是 $O(m \log m)$。

容易把递归算法改写为迭代。改写完成后，可以惊讶地发现，这就是高维后缀和。于是，上面那些愚蠢的线性代数都可以简单地证明（具体地，你可以观察到 $v_i = e_i + \sum\limits_{j \subsetneq i} v_j$）。

**注意**：从线性代数考虑也不是必须的。例如你观察力惊人，可以一眼看出这就是高维后缀和。

### 3. 最后一个“ABC 级别”的问题如何解决

这个问题可以有很多思路，我提供一种简单粗暴的方法。

具体地，对于循环移位问题，采用经典的倍长哈希可以算出每一个循环移位的哈希。对同一个等价类，我们找到一个代表元（为了方便计算，这里我选择最小的移位哈希），并对每一个字符串计算左移到它所需的最小次数 $p_i$；那么可以由代表元是否相同快速判定 $f(i, j)$ 是否为 $0$；且可以快速计算 $f(i, j) = (p_i - p_j) \mathbin {\rm mod} t$，其中 $t$ 是字符串的最小整周期。

$\sum\limits_{i=1}^n \sum\limits_{j=i}^n f(i, j)$ 也就可以使用一个树状数组快速计算，因为我们只需要知道有多少个 $p_j < p_i$。

## 代码示例（C++）

树状数组和字符串哈希的模板没有放上来，区间是左闭右开的。

``` cpp
#include <bits/stdc++.h>
using namespace std;
using u64 = uint64_t;

#include <atcoder/modint>
using Z = atcoder::modint998244353;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n, m; cin >> n >> m;
    int bias = m; m = 1;
    while (m < bias) m <<= 1;
    bias = m - bias;
    vector a(n, vector<int>(m));
    for (int i = 0; i < n; i++) {
        for (int j = bias; j < m; j++) {
            cin >> a[i][j];
        }
        for (int b = 1; b < m; b <<= 1) {
            for (int j = 0; j < m; j++) {
                if (j & b) a[i][j ^ b] ^= a[i][j];
            }
        }
    }
    unordered_map<u64, vector<int>> hs_buc;
    vector<int> cycle(n, m), shift(n);
    for (int i = 0; i < n; i++) {
        auto v = a[i];
        v.resize(2 * m - 1);
        copy(v.begin(), v.begin() + m - 1, v.begin() + m);
        auto h = StringHash(v);
        for (int j = 1; j < m; j++) {
            if (h.get(j, j + m) == h.get(0, m)) {
                cycle[i] = j;
                break;
            }
        }
        u64 min_hs = h.get(0, m); int min_shift = 0;
        for (int j = 1; j < m; j++) {
            if (h.get(j, j + m) < min_hs) {
                min_hs = h.get(j, j + m);
                min_shift = j;
            }
        }
        shift[i] = min_shift;
        hs_buc[min_hs].push_back(i);
    }
    Z ans = 0;
    FenwickTree<Z> fwc(m);
    for (auto [hs, buc]: hs_buc) {
        Z cnt = 0, sum = 0;
        debug(buc);
        int cyc = cycle[buc[0]];
        for (int i: buc) {
            int s = shift[i];
            Z pre_cnt = fwc.sum(s);
            ans += sum + pre_cnt * cyc - cnt * s;
            fwc.add(s, 1);
            cnt++; sum += s;
        }
        for (int i: buc) {
            int s = shift[i];
            fwc.add(s, -1);
        }
    }
    cout << ans.val() << '\n';
}
```

---

## 作者：Petit_Souris (赞：0)

独立做出一个铜牌题，好哦。

这个操作的形式很经典，考虑计算 $a_i$ 对 $a_j(i<j)$ 操作 $x$ 次后的贡献，发现这就是 $\binom{x}{j-i}\bmod 2$。考虑 Lucas 定理，即 $j-i$ 为 $x$ 的子集时产生贡献。

这个位运算的条件刻画起来较为困难。但是不要忘记我们可以一次一次操作进行，也就是看似是集合并，实际上我们可以拆成**加法**，也就是拆分成若干个 $2^k$ 次操作的叠加。这时候每个单次操作很容易分析，这就是 $a_{i}\leftarrow a_{i}\oplus a_{i-2^k}$。

这样我们就可以在 $\mathcal O(m\log m)$ 的时间内计算操作若干次后的结果。并且由于上面的推导，我们发现这个操作的过程是有长度为 $2^k$ 的纯周期的，这里的 $k$ 取决于第一个 $1$ 的位置。

既然是纯周期，那我们的问题实际上就等价于有若干个环，环上有一些关键点，求关键点之间的距离和。所以问题主要分为两部分：

- 求出一个状态在哪个环上；

- 求出这个状态在环上的位置。

很容易想到给每个环找一个代表元，这里选择找字典序最小的序列。那么能到达的代表元是容易求出的：直接找到第一个 $1$ 的位置 $p$，从小到大枚举 $2^k$，看 $a_{p+2^k}$ 操作后是否更优即可。

找到代表元的同时我们竟顺便也找到了位置，这简直是再好不过了。现在问题就变成求环上一些点两两距离之和，拆开贡献之后是个二维数点板子。总复杂度 $\mathcal O(nm\log m)$。


[submission](https://atcoder.jp/contests/arc184/submissions/59316523)

---


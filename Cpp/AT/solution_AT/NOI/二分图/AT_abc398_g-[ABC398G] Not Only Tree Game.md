# [ABC398G] Not Only Tree Game

## 题目描述

给定一个简单无向图 $G$，包含 $N$ 个顶点和 $M$ 条边，顶点编号为 $1$ 到 $N$，边编号为 $1$ 到 $M$。其中第 $i$ 条边连接顶点 $U_i$ 和 $V_i$。初始时，$G$ 中不包含奇闭路。

青木君和高桥君将使用这个图 $G$ 进行游戏。两人轮流执行以下操作（青木君为先手）：

- 选择满足 $1 \leq i < j \leq N$ 的整数对 $(i, j)$，且满足以下两个条件：
  - $G$ 当前不包含连接顶点 $i$ 和顶点 $j$ 的边；
  - 在 $G$ 中添加连接顶点 $i$ 和顶点 $j$ 的边后，$G$ 仍然不形成奇闭路；
  
  然后，将这条边添加到 $G$ 中。

无法进行操作的一方判负，另一方获胜。请判断在双方采取最优策略的情况下，哪一方会获胜。

**奇环的定义**：当且仅当顶点序列 $(v_0, v_1, \ldots, v_k)$ 满足以下所有条件时，称该序列为奇环：
- $k$ 是奇数；
- $v_0 = v_k$；
- 对于所有 $1 \leq i \leq k$，存在连接顶点 $v_{i-1}$ 和 $v_i$ 的边。

## 说明/提示

### 约束条件

- $1 \leq N \leq 2 \times 10^5$
- $0 \leq M \leq 2 \times 10^5$
- $1 \leq U_i < V_i \leq N$
- 给定的图 $G$ 不包含奇闭路；
- 给定的图 $G$ 不存在多重边；
- 输入均为整数。

### 样例解释 1

先手青木君选择 $(1, 4)$ 添加边后，后手高桥君无法进行任何操作，因此青木君获胜。

### 样例解释 2

无论青木君如何操作，高桥君都将获胜。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4 3
1 2
2 3
3 4```

### 输出

```
Aoki```

## 样例 #2

### 输入

```
4 2
1 2
3 4```

### 输出

```
Takahashi```

## 样例 #3

### 输入

```
9 5
2 9
2 3
4 6
5 7
1 8```

### 输出

```
Aoki```

# 题解

## 作者：fydj (赞：9)

分类讨论题。首先每个连通块都是二分图，每次连边不能破坏二分图的性质。如果只有一个连通块，可以通过还能连的边的条数来判断先手胜还是后手胜。但是图不连通，可能会出现一些连通块合并的情况，这就是困难之处。

把连通块分成四类：孤点，左部点和右部点都是偶数个，左右都是奇数个，左右一奇一偶。设它们的个数分别为 $iso,ee,oo,eo$。同时设连通块内部还能连的边的总数是 $x$。接下来就是分类讨论。

如果 $n$ 是奇数，那么 $m$ 是奇数先手胜，反之后手胜。因为最后剩下的二分图左右一定是一奇一偶，总边数是偶数，剩余能用的边数和 $m$ 的奇偶性相同。

如果 $n$ 是偶数，并且 $eo=0$，那么 $\frac {iso}2 +x$ 是奇数先手胜，反之后手胜。因为如果把两个孤点连接，把两个非孤点的连通块连接，消耗一条还能连的边，都会使得 $\frac {iso}2+x$ 的奇偶性改变。关于连接两个非孤点的连通块，由于只可能是 $ee+ee,oo+oo,ee+oo$ 三种情况，每种新增加能连的边都是偶数，同时消耗一条边，所以奇偶性改变。只有把孤点和非孤点的连通块连接才可能时 $\frac {iso}2+x$ 奇偶性改变，此时 $eo$ 增加一。此时对手可能选择把另一个孤点和这个连通块连接，使得 $eo=0$ 并且 $\frac{iso}2+x$ 的奇偶性再次改变。由于最后 $eo=iso=x=0$，所以这种情况一定会发生，此时 $\frac{iso}2+x=0$，所以可以得出上面的结论。

如果 $n$ 是偶数，并且 $eo=1$，那么先手必胜。它可以把某个孤点（一定存在）和 $eo$ 连边，并且根据 $\frac{iso}2+x$ 的需要决定连到奇数那边还是偶数那边，从而控制 $\frac{iso}2+x$ 为偶数。

如果 $n$ 是偶数，并且 $eo=2$，那么先手必胜。它可以把两个 $eo$ 根据 $\frac{iso}2+x$ 的需要决定把两个奇数、两个偶数合并对 $x$ 产生偶数的贡献，还是按奇偶、奇偶合并产生奇数的贡献，从而控制 $\frac{iso}2+x$ 为偶数。

如果 $n$ 是偶数，并且 $eo\ge 3$，那么判断条件变为和 $n$ 是奇数的情况一样，根据 $m$ 的奇偶性判断。因为一次操作 $eo$ 最多减少 $2$，一旦某个人把 $eo$ 变为 $\le 2$，另一个人就必胜。因此最后操作下来一定只剩 $4$ 个 $eo$，并且这些 $eo$ 内部都是连满边的。这样就变成若干个 $n$ 是奇数的情况，判定就和 $m$ 的奇偶性相关。

---

## 作者：SudoXue (赞：5)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18792597)

赛时没写出来，看到此题才 $600$ 分，对自己的实力产生了怀疑，没想到是个黑题。

官方题解已经写得比较明朗，在这里再详细解释一下。

---

题目给出初始图不含奇闭路，因此每个连通块必定是二分图。二分图的性质使得我们在添加边时只能在两个不同的“部”之间添加，不能在同一部内添加（否则会产生奇闭路）。

对于一个连通块，设其两个部中顶点数分别为 $a$ 和 $b$，已存在的边数为 $e$。该连通块最多能形成的边数为 $a \times b$，因此在不破坏二分性的前提下，还能添加的边数为 $a \times b - e$。

对整个图，我们令所有连通块中可添加的边数总和为 $x$。

此外，我们对连通块按两个部的顶点数的奇偶性进行分类：
- **$ee$**：连通块中两侧顶点数均为偶数；
- **$oo$**：两侧顶点数均为奇数；
- **$eo$**：一侧为偶数，另一侧为奇数（注意非孤立的连通块中如果出现这种情况记为 $eo$）；
- **$iso$**：孤立点（单个顶点构成的连通块）的个数。

---

游戏的终止状态是无法再添加任何边，即所有可以添加的边均已经存在。由于游戏中每次操作都会增加一条边，最终图的边数的奇偶性就决定了谁先走必胜。考虑两种情况：

#### 1. 当 $n$ 为奇数时

此时，无论如何将各个连通块合并，最后形成的二分图必然一侧顶点数为奇数，另一侧为偶数。所以最终图中，能够形成的边数必定为偶数。

经过分析证明，可以将最终剩余边数的情况归结为当前状态下 $oo$ 类连通块贡献的边数（因为在 $oo$ 类连通块中，两侧顶点数均为奇数，会对整体边数的奇偶性产生影响）和还可以添加的边数 $x$ 的奇偶性。

综上，先手必胜当且仅当 $\mathrm{oo} + x$ 为奇数；否则后手必胜。

#### 2. 当 $n$ 为偶数时

这时情况会更复杂一些，主要因为最后合并后的各个连通块中两个部的顶点数可能均为偶或者均为奇，这直接影响最终能形成的边数的奇偶性。直接分讨：

- **当 $eo = 0$ 时**：

  此时所有非孤立连通块都是 $ee$ 或 $oo$ 类型，同时注意孤立点的个数 $iso$ 必然为偶。分析表明，局面的胜负取决于孤立点与剩余可加边数的组合，也就是判断 $\mathrm{iso}/2 + x$ 的奇偶性。

  综上，先手必胜当且仅当 $\mathrm{iso}/2 + x$ 为奇数；否则后手必胜。

- **当 $1 \le \mathrm{eo} \le 2$ 时**：

  存在 $eo$ 类连通块时，先手可以利用一步操作将 $eo$ 类连通块转换为有利局面（例如连接 $eo$ 类与孤立点或将两个 $eo$ 类连通块合并），使得最终局面可以转化为上一种情况。

  综上，先手总能找到必胜策略，因此先手获胜。

- **当 $\mathrm{eo} \ge 3$ 时**：  
  在每一次操作中，$eo$ 类连通块的数目最多改变 $2$ 个。经过多次操作后，局面可以归约到最终的状态，其胜负又可以归结为 $\mathrm{oo} + x$ 的奇偶性。

  综上，先手必胜当且仅当 $\mathrm{oo} + x$ 为奇数；否则后手获胜。

---

对于实现，我们只需在遍历图时利用广搜统计出每个连通块中左右两侧的顶点数、已存在的边数，从而计算出 $x$、以及各类连通块的数量 $ee$、$oo$、$eo$ 与孤立点数 $iso$。根据 $n$ 的奇偶性及上述分类情况判断先手是否能必胜，从而输出结果。

时间复杂度 $O(n+m)$，可以被接受。

[link](https://atcoder.jp/contests/abc398/submissions/64189200)

---

## 作者：Hoks (赞：2)

## 前言
场上止步于前两步，手玩了一个夜自修还是没注意到孤立点的特殊性，又玩了一节语文课总算搞懂了，写篇题解纪念一下。

建议先去做[这场的 E](https://www.luogu.com.cn/problem/AT_abc398_e)，两题略有关联，但是没做过问题也不大。
## 思路分析
(引入，如果做过 E 的应该可以跳过这段。)

题目里说要保证图任意时刻都没有奇环。

那什么样的图是没有奇环的？

**二分图**。

联想到二分图之后自然也会联想到二分图的判定：

**黑白染色**。

我们考虑先对整张图黑白染色了，假设黑点个数为 $x$，那么最多可以存在的总边数就是 $n\cdot(n-x)$。

去掉目前已有的 $m$ 条边，剩下可以连的边数就是 $n\cdot(n-x)-m$。

考虑这个数的奇偶性。

不难发现当这个数是奇数时先手胜否则后手胜。

因为 $m$ 是给定的所以关键就在于 $n\cdot(n-x)$，只有在 $x$ 与 $n-x$ 均为奇数时才会使 $n\cdot(n-x)-m$ 的奇偶性发生变化。

到这里我们就能完成 E 题了，因为 E 保证了二分图划分的方案唯一且 $m=n-1$。

我们不妨来考虑下 E/G 两题的区别。

其实区别就是在于图并不连通，也就是黑白染色的方案不唯一。

也就是上文中的 $x$ 可能随着双方的博弈而产生变化。

根据上文所述只有 $x$ 与 $n-x$ 均为奇数时才会对胜负产生影响，这启发我们只去关注奇偶性。

那比较容易的先对 $n$ 进行分讨。

注意到 $x$ 与 $n-x$ 均为奇数当且仅当 $n$ 为偶数时才有可能出现，所以我们先着手处理 $n$ 为奇数的情况。

此时 $x\cdot(n-x)$ 必然是偶数，那么当 $m$ 为奇数时先手胜，否则后手胜。

接下来是 $n$ 为偶数的情况。

那么此时我们先考虑一下 $m$ 的奇偶性，这决定了先手是否要尽可能把 $x$ 变为奇数。

而我们目前的连通块有三种，根据黑白染色划分出的奇偶性，不妨称之为 $oo,ee,eo$（$o$ 表示奇数，$e$ 表示偶数，$oo,ee,eo$ 就是指划分出来黑点白点分别为**奇数奇数/偶数偶数/奇数偶数**的连通块）。

那我们假设是在一个连通块上接别的连通块，那么 $ee$ 就没有影响，$oo$ 就是可以让 $oo$ 与 $ee$ 互相转化，而 $eo$ 就是可以把 $oo/ee$ 变为 $oe$，把 $oe$ 变为 $oo/ee$。

是这样的吗？

其实不难发现我们少考虑了一种情况。

我们想当然的认为所有 $eo+eo$ 都可能变成 $oo/ee$ 却忘掉了一个边界情况：

**当 $eo$ 退化为孤立点的时候。**

当两个 $eo$ 都为孤立点的时候，此时连接两个点只能得到 $oo$ 而无法得到 $ee$。

因为不存在一个图黑白染色后可以划分为 $2/0$。

所以我们要把孤立点这种情况单独拿出来，设此数量为 $y$。

接下来我们来分讨。

因为 $eo$ 变化性比较丰富，所以我们不妨考虑对 $eo$ 的数量来得到一个胜负判断。

那么先考虑最为特殊的情况，当 $eo=0$ 时：

不妨再特殊一点，假设 $y$ 也为 $0$ 时。

此时 $x$ 的奇偶性与 $oo$ 相同，所以当 $oo-m$ 为奇数时先手必胜否则后手必胜。

然后我们来推广到 $y\not=0$ 的情况。

此时我们注意到，$y$ 必然是偶数。

因为 $oo,ee$ 中的点数都为偶数（奇数加奇数和偶数加偶数都是偶数），而 $n$ 也是偶数，所以 $y$ 也是偶数。

继续分类讨论，假设目前  $oo+\frac{y}{2}+m$ 为偶数。

那么如果先手取 $oo$，则后手也跟着取 $oo$ 保证奇偶性。

先手如果取孤立点，那么后手可以反着取孤立点，也就相当于是将两个孤立点合并为 $oo$ 后加入。

因为 $\frac{y}{2}+oo+m$ 为偶数，所以最后是无法改变奇偶性的（也就相当于是直接把 $2y$ 看作 $oo$，最后 $oo$ 总量不变）。

再考虑如果先手取进行一步并不改变奇偶性的操作将先手推给后手的情况。

此时后手可以选择直接连接两个孤立点创造 $oo$，同上文，所以我们可以得到的是后手必胜。

然后我们再来考虑 $oo+\frac{y}{2}+m$ 为奇数的情况。

此时先手直接连接一条边，或是连接上一个 $oo$，就相当于是 $m$ 变大了 $1$，或是让 $oo$ 减一。

此时先手面对 $oo+\frac{y}{2}+m$ 为奇数就转化为了后手面对 $oo+\frac{y}{2}+m$ 为偶数。

根据上文的证明我们可以得到在 $oo+\frac{y}{2}+m$ 为奇数时，先手必胜。

接着来推广这个情况。

当 $eo=1$ 时，我们注意到 $y$ 为奇数，那么显然是不为 $0$ 的。

对于先手，我们可以选择 $eo$ 加孤立点得到 $oo$ 也可以选择得到 $ee$。

显然的是得到 $oo$ 和 $ee$ 的奇偶性是不同的，所以先手想要奇数就能得到奇数，想要偶数就能得到偶数。

也就是先手必胜。

还有一个比较特殊的情况是 $eo=2$。

因为我们可以发现每次连一条边最多影响两个连通块，那只有 $eo\le2$ 的时候是先手可以一步影响到的。

所以我们也拿出来讨论一下。

和上文类似的是，我们可以连接两个 $eo$ 得到 $ee$ 或者 $oo$，所以先手也是必胜。

最后剩下的就是 $eo\ge3$ 的情况了。

此时就是一个广泛的普遍情况了（先手没法一步把 $eo$ 消光）。

根据上面的结论，要是谁把 $eo$ 变成 $1,2$ 了，那谁就输了（变完后先手必胜嘛）。

以及我们每次操作最多连一条边，也就是连接两个 $eo$，那么一次最多只能消掉两个。

最后总是会变成 $eo$ 属于 $1,2$ 的情况的。

那从这步开始往回推一步（撤销 $eo$ 变为 $1,2$ 的这一步），则 $eo=3,4$（取决于是否还有孤立点可以连接）。

此时双方肯定是在尽可能避免连接上 $eo$，而其他的非 $eo$ 部分和 $eo$ 内部分都是可以连接的。

所以在最后 $eo$ 变为 $1,2$ 之前，其他所有能连的边都已经被连尽了。

也就是说：

**现在的图存在也仅存在 $eo$ 或者是孤立点。**

考虑到孤立点和 $eo$ 的区别仅在于两个孤立点无法合成 $ee$，**在这里并不重要**，所以我们不妨扩大 $eo$ 的概念使他包含孤立点。

那么必然有 $eo=4$ 且现在的图仅存在 $eo$。

考虑如果一块不是 $eo$ 的。

我们显然可以有 $(oo/ee)+eo=eo$，然后就合并进 $eo$ 里了。

那么最后剩下来的情况就是 $eo=4$。

考虑到 $eo$ 的总点数是**奇数**，所以 $eo$ 二分图内可连的边总是**偶数**。

所以 $eo=4$ 的这个图可以连的边数是**偶数**，可以多连的边数奇偶性取决于 $m$ 的奇偶性。

总结一下结论：
1. $n$ 为奇数。
   - $m$ 为奇数时先手必胜
   - 否则后手必胜。
2. $n$ 为偶数且 $eo=0$。
   - $\frac{y}{2}+oo+m$ 为奇数时先手必胜（$y$ 表示孤立点个数）。
   - 否则后手必胜。
3. $n$ 为偶数且 $eo=1,2$。
   - 先手必胜。
4. $n$ 为偶数且 $eo\ge 3$。
   - $m$ 为奇数时先手必胜。
   - 否则后手必胜。
## 代码
实现非常简单，遍历一下整个图记录下要用的信息后根据结论输出即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define ls (p<<1)
#define rs (ls|1)
using namespace std;
const int N=5e5+10,M=1e5+10,V=1e6,p=13331,mod=1e9+7,INF=0x3f3f3f3f3f3f3f3f;
int n,m,oo,eo,y,mp[N],cnt[2];vector<int>e[N];
namespace Fast_IO
{
	static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
	#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
	inline int read()
	{
		int x(0),t(1);char fc(getchar());
		while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
		while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
		return x*t;
	}
	inline void flush(){fwrite(out,1,length,stdout);length=0;}
	inline void put(char c){if(length==9999999) flush();out[length++]=c;}
	inline void put(string s){for(char c:s) put(c);}
	inline void print(int x)
	{
		if(x<0) put('-'),x=-x;
		if(x>9) print(x/10);
		put(x%10+'0');
	}
	inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
	inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
	inline void rd(char s[],int&n)
	{
		s[++n]=getchar();
		while(chk(s[n])) s[n]=getchar();
		while(ck(s[n])) s[++n]=getchar();
		n--;
	}
}
using namespace Fast_IO;
inline void dfs(int u,int col)
{
	mp[u]=1;cnt[col]++;
	for(auto v:e[u]) if(!mp[v]) dfs(v,col^1);
}
inline void solve()
{
	n=read(),m=read();for(int i=1,x,y;i<=m;i++) x=read(),y=read(),e[x].emplace_back(y),e[y].emplace_back(x);
	for(int i=1;i<=n;i++) if(!mp[i])
	{
		cnt[0]=cnt[1]=0;dfs(i,0);
		if(cnt[0]+cnt[1]==1){y++;continue;}
		if((cnt[0]&1)^(cnt[1]&1)) eo++;
		if((cnt[0]&1)&(cnt[1]&1)) oo++;
	}if(n&1||eo>=3) return put((m&1)?"Aoki\n":"Takahashi\n");
	if(eo) return put("Aoki\n");y>>=1;
	put((y+oo+m)&1?"Aoki\n":"Takahashi\n");
}
signed main()
{
	int T=1;
	// T=read();
	while(T--) solve();
	genshin:;flush();return 0;
}
```

---

## 作者：Union_Find (赞：2)

# 题意

有一张 $n$ 个点 $m$ 条边的图，保证一开始不存在奇环，`Aoki` 和 `Takahashi` 轮流在图上添加边，要求添加之后图任然不存在奇环，且不能有重边。无法操作者输。求最后谁会赢。

# 分析

这个问题要从奇偶性入手，因为不能有奇环，我们可以给原图黑白染色，然后分类讨论。

## $n$ 为奇数

因为 $n$ 为奇数，那么在游戏结束的时候二分图两部分一定是一奇一偶，那么最终二分图上的边数就一定是偶数条。所以双方可以操作的边数就取决于一开始的边数，即 $m$ 的奇偶性。如果 $m$ 为奇数，那么就是 `Aoki`，否则就是 `Takahashi`。

## $n$ 为偶数

$n$ 为偶数的情况比较多，我们先有如下定义。

- $cnt_{11}$ 表示二分图两部分都为奇数的连通块数量，我们称之为 A 类连通块。
- $cnt_{00}$ 表示二分图两部分都为偶数的连通块数量，我们称之为 B 类连通块。
- $cnt_{10}$ 表示二分图两部分一奇一偶且连通块内至少两个点的连通块数量，我们称之为 C 类连通块。
- $cnt_a$ 表示只有一个点的连通块数量。

并且显然，在双方都不改变图的连通性的前提下，结果就已经完全确定了，详见本场 E 题。所以双方会有限把各个连通块连接起来，变成一个连通块。而且容易发现，$cnt_{00}$ 不会对我们的答案产生任何影响。接下来我们分类讨论。

### $cnt_{10} = 0$

先说结论，如果 $\frac{cnt_a}{2} + cnt_{11} + m$ 为奇数，那么就是 `Aoki`，否则是 `Takahashi`。我们下面称这个值为 $x$。

显而易见，这种情况下 $cnt_a$ 一定是偶数。我们考虑归纳证明。

如果当前局面 $x$ 为奇数，那么我们就可以把两个单点连接，会使得 $cnt_a$ 减去 $2$，那么 $x$ 变成偶数。或者连接两个 A 类连通块，那么就会少掉两个 A 类连通块，多一个 B 类连通块，$x$ 的奇偶性也会变。

接下来，对方一样会进行依次操作，让 $x$ 再便会奇数。但是对方也很聪明，可以把一个单点连接到一个 A 类连通块上，这样子就会使得  $cnt_{10}$ 变成 $1$，不在这种情况内。所以我们要把局面拉回 $cnt_{10}$ 变回来。因为 $cnt_a$ 一定是偶数，对方操作后，$cnt_a$ 会变成奇数，就一定会剩下一个单点。我们就可以把这个单点也连接到对方选择的 A 类连通块上，局面就会变回来，对方面对的仍然是 $x$ 为偶数。

初始情况就是所有数字都是 $0$，那么 $x$ 为 $0$，先手必输，所以如果 $x$ 为奇数，先手赢，否则后手赢。

### $cnt_{10} = 1$

这种情况其实就是先手上面情况的子情况，这种情况一定是 `Aoki`。

具体的，因为这种情况 $cnt_a$ 是奇数，我们可以把一个单点和一个 C 类连通块连接，而且此时我们可以把这个 C 类连通块变成任意一个 A 类连通块或者 B 类连通块。因为我们希望我们操作之后 $x$ 为偶数，所以我们可以通过选择 A 类连通块或 B 类连通块来改变 $cnt_{11}$ 的奇偶性。所以无论如何，一定是 `Aoki`。

### $cnt_{10} = 2$

这种情况，也一定是 `Aoki`。

我们这种情况内，$cnt_a$ 一定是偶数。我们一样的可以连接两个 C 类连通块，并且选择变成 A 类连通块还是 B 类连通块，可以变成 $cnt_{11} = 0$ 的情况，做到 $x$ i一定为偶数。

### $cnt_{10} \ge 3$

最后这种情况，我们发现，因为一次操作最多减少两个 C 类连通块，而如果一个人使得局面变成了 $cnt_{11} \in [1,2]$ 的话，那个人就输了。所以局面一定会若干次操作之后变成三个连通块的情况，并且谁让局面变成只有三个连通块且无法在块内连接时，那个人就赢了。所以这就取决于一开始 $m$ 的奇偶性，如果 $m$ 为奇数，那么 `Aoki`，否则 `Takahashi`。

# 总结

最终我们整理出来了所有的情况。

- $n$ 为奇数，答案取决于 $m$ 的奇偶性。
- $n$ 为偶数，$cnt_{10} = 0$，答案取决于 $\frac{cnt_a}{2} + cnt_{11} + m$ 的奇偶性。
- $n$ 为偶数，$cnt_{10} \in [1,2]$，答案为 `Aoki`。
- $n$ 为偶数，$cnt_{10} \ge 3$，答案取决于 $m$ 的奇偶性。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 200005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
int n = rd(), m = rd(), u, v, col[N], t[N][2], s0, s1, s2, cnt;
vector <int> e[N];
void dfs(int u, int d){
	col[u] = d, t[cnt][d]++;
	for (int v : e[u]) if (col[v] == -1) dfs(v, d ^ 1);
}
int main(){
	for (int i = 1; i <= n; i++) col[i] = -1; 
	for (int i = 1; i <= m; i++) u = rd(), v = rd(), e[u].push_back(v), e[v].push_back(u);
	if (n & 1) return 0 & puts((m & 1) ? "Aoki" : "Takahashi");
	for (int i = 1; i <= n; i++) if (col[i] == -1) cnt++, dfs(i, 0);
	for (int i = 1; i <= cnt; i++){
		if ((!t[i][0] && t[i][1] == 1) || (!t[i][1] && t[i][0] == 1)) s0++;
		else if ((t[i][0] & 1) && (t[i][1] & 1)) s1++;
		else if ((t[i][0] & 1) || (t[i][1] & 1)) s2++;
	}if (!s2) puts(((s0 / 2 + s1 + m) & 1) ? "Aoki" : "Takahashi");
	else if (s2 <= 2) puts("Aoki");
	else puts((m & 1) ? "Aoki" : "Takahashi");
	return 0;
}

```

---


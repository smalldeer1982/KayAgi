# [AGC009E] Eternal Average

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jrex2017/tasks/agc009_e

黒板に、$ N $ 個の $ 0 $ と $ M $ 個の $ 1 $ が書かれています。 この状態から、黒板に書かれている有理数のうち $ K $ 個を選んで消し、それら $ K $ 個の有理数の平均を新たに書き加える操作を繰り返します。 ただし、$ N+M-1 $ は $ K-1 $ で割り切れるものとします。

このとき、操作ができなくなるまでこの操作を繰り返すと最終的に黒板には $ 1 $ つの有理数が書かれた状態になります。

この残った有理数の値としてありうるものの個数を $ 10^9\ +\ 7 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N,\ M\ ≦\ 2000 $
- $ 2\ ≦\ K\ ≦\ 2000 $
- $ N+M-1 $ は $ K-1 $ で割り切れる。

### Sample Explanation 1

最後に残る有理数としてありうるものは、$ \frac{1}{4},\ \frac{3}{8},\ \frac{1}{2},\ \frac{5}{8},\ \frac{3}{4} $ の $ 5 $ 通りです。 例えば $ \frac{3}{8} $ は、以下のような操作で最後に残ります。 - $ 0,1 $ を消して $ \frac{1}{2} $ を書く。 - $ \frac{1}{2},1 $ を消して $ \frac{3}{4} $ を書く。 - $ 0,\frac{3}{4} $ を消して $ \frac{3}{8} $ を書く。

## 样例 #1

### 输入

```
2 2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
3 4 3```

### 输出

```
9```

## 样例 #3

### 输入

```
150 150 14```

### 输出

```
937426930```

# 题解

## 作者：litble (赞：21)

[戳我＝￣ω￣＝](https://blog.csdn.net/litble/article/details/83176183)

我们把这个问题写成$k$叉树结构，一共有$n+m$片叶子，其中$n$片写着$0$，$m$片写着$1$。对于一个非叶子节点，它的值是它儿子们的值的平均数。则根节点的数就是黑板上剩下的那个数。

假设那$n$个$0$的深度分别是$x_i$，$m$个$1$的深度分别是$y_i$，则根节点的数就是$\sum_{i=1}^m (\frac{1}{k})^{y_i}$。并且我们知道如果所有叶节点的数都是$1$则根节点也是$1$，所以$\sum_{i=1}^m (\frac{1}{k})^{y_i}+\sum_{i=1}^n (\frac{1}{k})^{x_i}$，而若满足这个条件，一定也能构造出合法的$k$叉树（考虑$k$进制小数的进位，则同一深度的叶子节点一定要有$k$个才能进以位，依此构造即可）

现在的问题转化为，有多少个$z$满足$z$可以写成$m$个$(\frac{1}{k})^y$相加的形式，而$1-z$又可以写成$n$个$(\frac{1}{k})^x$相加的形式。（litble的代码里求解的是有多少个满足条件的$1-z$，这当然也没问题）

将$z$写成$k$进制小数$0.c_1c_2c_3...$，不考虑进位，则$\sum c=m$。考虑还原进位，则可以将$c_i$减去$1$而将$c_{i+1}$增加$k$，则$\sum c \equiv m \pmod{k-1}$。假设小数有$len$位，则$1-z$的位数和应该是$(len-1)(k-1)+k-\sum c=len(k-1)-\sum c+1$。

设$f(i,j)$表示小数点后$i$位，每一位的和是$j$的方案数进行DP即可。因为小数的末尾不能是0，所以当第$i$位的末尾是否是0也应该加进状态里面。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
const int mod=1e9+7,N=2005;
int n,m,K,ans,f[N<<1][N][2],s[N];
int qm(int x) {return x>=mod?x-mod:x;}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	f[0][0][0]=1;
	for(RI i=1;i<=max(n,m)*2;++i) {
		s[0]=qm(f[i-1][0][0]+f[i-1][0][1]);
		for(RI j=1;j<=n;++j)
			s[j]=qm(s[j-1]+qm(f[i-1][j][0]+f[i-1][j][1]));
		for(RI j=0;j<=n;++j) {
			f[i][j][0]=qm(s[j]-s[j-1]+mod);
			if(j) f[i][j][1]=qm(s[j-1]-(j-K>=0?s[j-K]:0)+mod);
		}
		for(RI j=0;j<=n;++j)
			if(j%(K-1)==n%(K-1)&&(i*(K-1)-j+1)%(K-1)==m%(K-1)&&i*(K-1)-j+1<=m)
				ans=qm(ans+f[i][j][1]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：zhylj (赞：18)

考虑取平均数的过程会形成一个树形结构，叶子结点为初始的 $0,1$，每个非叶子结点都是 $K$ 叉的，表示将其所有孩子合并为一个数。则深度为 $i$ 的 $1$ 对答案的贡献即为 $\dfrac 1{K^i}$，且我们注意到最后的结果只和每层叶子中 $1$ 的个数有关，而与 $1$ 具体的摆放顺序无关。

记 $d=\dfrac{N+M-1}{K-1}$，即该树的深度，不难注意到所有数都可化为 $\dfrac{A}{K^d}$ 的形式（其中 $A$ 为一个整数）。

直接枚举每一层的 $1$ 的个数来统计会导致算重，因为某一层的 $K$ 个 $1$ 等价于上一层的 $1$ 个 $1$，于是我们考虑枚举进行了 $x$ 次把 $K$ 个 $1$ 变成了一个 $1$ 的操作，那么我们会令新的 $d'\gets d - x$，$M'\gets M - x(K - 1)$，并且如果某一层有大于等于 $K$ 个 $1$，那么我们可以把它们调整顺序（因为顺序不改变结果）后“合并”为一个 $1$，使得其在枚举 $x+1$ 次把 $K$ 个 $1$ 变成了一个 $1$ 的操作时再统计。

于是若要统计不重复，每一层都必须只有不超过 $K - 1$ 个 $1$，不难发现此时最终的平均数 $\dfrac A{K^d}$ 中的 $A$ 满足：$\dfrac AK$（因为第 $0$ 层不可能有叶子结点，所以要除个 $K$）是一个 $d'$ 位的 $K$ 进制数，且每位数值之和恰为 $M'$（因为此时 $1$ 的总数为 $M'$），不难验证该条件是充要的。

不难用一个朴素的背包 dp 做到 $\mathcal O(N^2)$（假设 $N,M,K$ 同阶）的时间复杂度。

```cpp
const int N = 4000 + 5, MOD = 1e9 + 7;

int n, m, K, d, f[N][N];

int main() {
    rd(n, m, K); d = (n + m - 1) / (K - 1);
    f[0][0] = 1;
    for(int i = 1; i <= d; ++i)
        for(int j = 0; j < K; ++j)
            for(int k = j; k <= i * K && k <= m; ++k)
                f[i][k] = (f[i - 1][k - j] + f[i][k]) % MOD;
    int ans = 0;
    for(; m >= 1; m -= K - 1, --d)
        ans = (ans + f[d][m]) % MOD;
    printf("%d\n", ans);
	return 0;
}
```

---

## 作者：suxxsfe (赞：12)

在我的博客查看：[https://www.cnblogs.com/suxxsfe/p/13904106.html](https://www.cnblogs.com/suxxsfe/p/13904106.html)  

[https://atcoder.jp/contests/agc009/tasks/agc009_e](https://atcoder.jp/contests/agc009/tasks/agc009_e)  

将模型转化为一个 $k$ 叉树，每个点要么是叶子，要么恰好有 $k$ 个儿子  
然后叶子节点有 $n+m$ 个，权值 0 或 1，非叶子节点的权值是所有子节点的平均值  
这样根的权值就是最后剩的那个数  
设根的深度为 $0$，权值为 1 的点深度分别是 $x_i$，为 0 的分别是 $y_i$  
则权值为 0 的没贡献，根节点的权值是 $\sum k^{-x_i}$  
如果 $n+m$ 个点都是权值为 $1$，则根权值也是 $1$，那么就推出了 $\sum k^{-x_i}+\sum k^{-y_i}=1$  

此题即为求有多少个 $Z$，使得 $Z=\sum k^{-x_i},1-Z=\sum k^{-y_i}$  
那么设 $k$ 进制小数 $Z=(0.z_1z_2\ldots z_l)_k$，因为 $Z$ 要写成 $\sum k^{-x_i}$，所以 $\sum z_i\le n$，也就是最多只有 $k$ 进制下 $n$ 个 $1$  
那么从 $1$ 最多的情况往后推，每次进位，所有位的和减小 $k-1$，所以可以得出 $\sum z_i \equiv n \pmod{k-1}$  

模拟一下小数减法的过程，再针对 $1-Z=\sum k^{-y_i}$ 这个式子，可以仿照上面的过程推出 $1+\sum(k-1-z_i)\le m$ 和 $1+\sum(k-1-z_i)\equiv m \pmod{k-1}$  

所以就是要求有多少个小数 $Z$，使得满足一下几个式子  

$$0\le z_i<k,i\in [1,l-1]$$  

$$0<z_l<k$$  

$$\sum z_i\le n$$  

$$\sum z_i \equiv n \pmod{k-1}$$  

$$1+\sum(k-1-z_i)\le m$$  

$$1+\sum(k-1-z_i)\equiv m \pmod{k-1}$$  

所以可以来一个 dp，用 $f(i,j,0/1)$ 表示考虑 $l=i$，也就是 $Z$ 有 $i$ 位时，$\sum z_i=j$，$z_i$ 等于/不等于 $0$ 的方案数  
转移：$f(i,j,0)=f(i-1,j,0)+f(i-1,j,1)$  
$f(i,j,1)=\sum_{x=1}^{k-1} f(i-1,j-x,0)+f(i-1,j-x,1)$  

记一个前缀和优化一下就行了  
因为没有规定 $l$ 的大小，所以每当枚举完一个 $i$，就去找所有符合上面几个式子要求的 $j$ 来加到答案里  

另外一个细节，就是 $i$ 最大枚举到多少，其实通过联立第三个和第五个式子可以发现，$l\le \dfrac{n+m-1}{k-1}$，这也就是 $i$ 的最大值  

代码就不放了，本来自己没实现出来看了一下另一篇，所以和他写的挺像的  

---

## 作者：do_it_tomorrow (赞：7)

[更好的阅读体验](https://www.doittomorrow.xyz/post/agc009e-eternal-average-de-ti-jie/)

发现题目将 $k$ 个数取平均数后合并成一个数的操作可以看作一棵 $k$ 叉树，每一个节点的儿子数都是 $0$ 或 $k$。

其中叶子节点是 $0$ 或 $1$ 表示给定的 $n+m$ 个数，而非叶子节点的值就是其儿子的平均值，代表在操作后新产生的点。

假设所有的叶子节点从左到右排列的值依次是 $a_1,a_2,\cdots ,a_{n+m}$，那么对于第 $i$ 个叶子节点其贡献可以写作 $\dfrac{a_i}{k^{dep(i)}}$，其中 $dep(i)$ 表示第 $i$ 个叶子节点的深度（$dep(rt)=0$）。所以在确定了 $a$ 数组之后，剩余平均值就是 $\sum\limits_{i=1}^n \dfrac{a_i}{k^{dep(i)}}$。

设 $d$ 为有 $n+m$ 个点的 $k$ 叉树的深度的最大值，容易得到 $d=\dfrac{n+m-1}{k-1}$。

因为对于 $\forall i\in[1,n+m]\cap\mathbb{N}$ 满足 $k^{dep(i)}\mid k^{d}$，所以答案答案一个可以写成 $\dfrac{S}{k^{d}}$ 的形式，其中 $S$ 是一个整数。

发现直接统计答案会有重复，因为如果第 $x$ 层有 $k$ 个 $1$，那么其贡献等于在 $x-1$ 层有 $1$ 个 $1$，考虑将这 $k$ 个 $1$ 合并上去。注意，这 $k$ 个 $1$ 的**父亲不一定是相同的**。

考虑对于所有一层出现的 $1$ 超过 $k$ 次的情况全部处理掉，假设处理了 $l$ 次，那么 $m'\gets m-l\times(k-1),d'\gets d-l$。

注意 $d'$ 表示的 $n+m'$ 个点可以组的 $k$ 叉树的最大深度，虽然可以构造出进行一次操作之后树的深度不减小的情况，但是这一定不是深度最深的情况。

如果将 $S$ 看作一个 $d$ 进制数，上面的操作就相当于给 $S$ 进行进位操作。

假设现在的答案可以写作 $\dfrac{S'}{k^{d'}}$，另 $v$ 将 $S'$ 写作 $d'$ 进制数之后各位的值的和，那么需要满足 $v=m'$，也就是满足 $v \equiv m \pmod{k-1}$。

考虑使用 DP 进行求解方案数，设 $f_{i,j}$ 表示一共 $i$ 层一共选择了 $j$ 个 $1$ 的方案数，模拟背包直接进行转移即可，时间复杂度为 $O(n^2)$。


[Submission #58023415 - Japan Russia Exchange Programming Contest 2017](https://atcoder.jp/contests/jrex2017/submissions/58023415)

---

## 作者：kkio (赞：5)

# AT_agc009_e #

改版后的新标号~~

假如我们一直 $ k $ 个数合并，并且将结果放到下一轮的数中合并的话，最后就可以得到一个结果，不同的合并方式会有不同的数。

这个合并形成了一个 $ k $ 叉树结构，比如样例1， $ \dfrac{3}{8} $ 的结果可以看成先 $ 0,1 $ 合并，再并上一个 $ 1 $ ，最后并上一个 $ 0 $ 的结果。

所以这个结果和一个 $ k $ 叉树对应，我们对这个 $ k $ 叉树来计数。

由于合并是取平均值，对一个数，如果他被取了 $ x $ 次平均值，那么他对答案的贡献就要乘上 $ \dfrac{1}{k^x} $。如果一个 $ 0,1 $点在树上的深度为 $ x $ 的话，那么说明他被取 $ x $ 次平均值。

那么假设每一个第 $ i $ 个 $ 1 $ 的深度为 $ a_i $，第 $ i $ 个 $ 0 $ 的深度为 $ b_i $。那么对于一对 $ a,b$ 一定能表示一个数。假设最终结果的 $ k $ 进制表示为 $ 0.c_1c_2c_3....c_t $ 那么最终结果一定有：

$$ \sum\limits_{i=m}^{n} {\frac{1}{k^{a_i}}} \ + \ \sum\limits_{i=1}^{n} {\frac{1}{k^{b_i}}} = 1 $$

由于一次进位只会使得 $ c $ 的和变小，且模 $ k - 1 $ 的值同余，所以又有

$$ \sum{c_i} \equiv m  \ (\bmod \ k-1) $$

$$ \sum{k-1-c_i} \equiv n - 1 \ (\bmod \ k-1) $$

并且他们都要小于右边的数。

那么我们设 $ dp[i][j][k] $ 表示现在放到第 $ i $ 层，位数和已经为 $ j $，同时 $ k $ 表示当前是不是 $ 0 $ 的方案数 ，$ dp $ 即可。

发现当前位是 $ 0 $ 时 ，会跟前面的算重，又不难知道肯定会有一个位是 $ 1 $，所以只统计当前为是 $ 1 $ 的情况。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=4005,mod=1e9+7;
int n,m,k,t,ans;
int dp[maxn][maxn][2];
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	t=(n+m-1)/(k-1);
	dp[0][0][0]=1;
	for(int i=1;i<=t;i++)
		for(int j=0;j<=m;j++)
		{
			dp[i][j][0]=(dp[i-1][j][0]+dp[i-1][j][1])%mod;
			for(int p=1;p<k&&p<=j;p++)
				dp[i][j][1]=((dp[i][j][1]+dp[i-1][j-p][1])%mod+dp[i-1][j-p][0])%mod;
			if(j%(k-1)==m%(k-1)&&(k-1)*i-j<=n-1&&((k-1)*i-j)%(k-1)==(n-1)%(k-1))
				ans=(ans+dp[i][j][1])%mod;
		}
	printf("%lld\n",ans);
}
```





---

## 作者：AllenJYL (赞：4)

直接考虑 $1$ 的贡献。每个 $1$ 的贡献一定是 $\frac{1}{k^{p_i}}$，其中 $p_i$ 是一个变量，表示这个 $1$ 被合并了 $p_i$ 次。而答案就是 $\sum_{i-1}^m\frac{1}{k^{p_i}}$。

接下来，考虑统计 $p_i=C$ 的 $i$ 的个数，记为 $c_C$，记合并的次数为 $X=\frac{m+n-1}{k-1}$，注意到 $C\in[1,X]$，且 $\sum_{i=1}^{X}c_i=m$。有了这些限制，我们就可以尝试统计答案了。

首先，我们考虑给定了一组 $c$，如何判断能否构造出一种合并方法使得 $c$ 成立？事实上，我们可以模拟这个合并的过程。

记最大的 $l$ 满足 $c_l>0$ 且 $\forall i\in[l+1,X]，c_i=0$。

前 $X-l$ 次合并都是将 $k$ 个 $0$ 合并成一个 $0$。第 $X-l+1$ 次合并，将 $c_l$ 个 $1$ 和 $k-c_l$ 个 $0$ 合并成 $1$ 个数，接下来将这个数和 $c_{l-1}$ 个 $1$ 和 $k-c_{l-1}-1$ 个 $0$ 合并成 $1$ 个数，以此类推即可。所以我们要满足的是：
- $c_l\le k$
- $\forall i\in[1,l-1]，c_i<k$
- $(X-l)(k-1)+[X-l>0]\le n$
- $(X-l)(k-1)+l(k-1)-\sum_{i=1}^lc_i+1=n$。

其中 $[P]=1$ 若 $P$ 为真，否则 $[P]=0$。

第一个式子代表第 $X-l+1$ 次合并时的 $c_l$ 不能超过 $k$ 个，否则无法合并。

第二个式子代表第 $X-l+2$ 至第 $X$ 次合并时的 $c_i$ 不能超过 $k-1$，这是由于上一次合并的结果占了一个位置。

第三个式子代表前 $X-l$ 次合并都得是合并 $0$，所以这些合并所使用的 $0$ 不得超过 $n$。可以以此求出 $l$ 的下界。

第四个式子代表一共使用的 $0$ 得恰好是 $n$。

经过化简，最后的那一个式子是恒成立的，直接扔掉。所以我们得到了合法的 $c$ 数组的条件，那么就会有一个问题：这些 $c$ 数组是否能一一对应一个与众不同的答案？如果可以的话，我们就只要统计合法 $c$ 的数量了。

庆幸的是，答案是肯定的。我们改写一下答案：$ans=\sum_{i=1}^l\frac{c_i}{k^i}$，将答案乘以 $k^l$，即有 $k^lans=\sum_{i=1}^lc_ik^{l-i}$，这启发我们尝试利用进制的思想辅助证明。

如果 $c_l\not=k$，那么就满足 $\forall i\in[1,l]，c_i<k$，根据进制的唯一表示可以容易证明。

如果 $c_l=k$，此时 $k^lans=\sum_{i=1}^{l-1}(c_i+[i=l-1])k^{l-i}$，而注意到 $\sum_{i=1}^{l-1}(c_i+[i=l-1])=m-k+1<m$，这意味着这种情况不会在 $l'=l-1$ 的情况中算重，也就是说这种情况所对应的答案只会在这里出现 $1$ 次，这也印证了我们的猜想。

问题就转化成了统计数组 $c$ 的个数。枚举 $l$ 之后，这就是经典的容斥。不必赘述。

上述做法的时间复杂度是 $O(\frac{nm}{k^2})$，可以通过。

---

## 作者：Fucious_Yin (赞：3)

场上没想到进位和 $k$ 进制 TAT，但是组合意义搓出了一样的东西 O.o。

~~有多少人开局跟我一样在搓一个对操作序列计数的，出列！~~

很自然地，我们发现对于每个 1，他对答案的贡献是形如 $k^x$，$x$ 即为他被被合并的次数，自此我们可以建出一棵 $k$ 叉数，有 $n$ 个值为 0 的叶子和 $m$ 个值为 1 的叶子，每个非叶子节点权值为他 $k$ 个儿子的平均值。显然根节点即为答案，同时我们发现并不关心树的结构，比如一棵叶子全是 1 的树不管他怎么变根都是 1，进而只关心根的值。由于 $k$ 叉，我们知道非叶子节点个数即为 $(n+m-1)/(k-1)$，层数也最多这么多，且每层点数是 $k$ 的倍数，所以考虑按层计数。

先说明几个名词：

* 白点，值为 0 的点
* 黑点，值为 1 的点
* 灰点，值在 $(0, 1)$ 间的点，显然由于 $n \ge 1$ 根一定是灰点

这样仍然不够，因为直接去计数的话一定会把树的形态也记进去，还是考虑一棵叶子全黑的树（尽管这种情况并不存在），首先叶子个数一定是 $x \times (k-1)+1$ 的，这提示我们对于这样一棵全黑或全白的树，只有根节点有用。这是关键，再定义两个名词：

* 有用白点，父亲节点是灰点的白点
* 有用黑点，父亲节点是灰点的黑点

显然没用的黑、白点都可以通过下挂在其他黑、白点下得来。那么答案贡献就是所有**有用黑点**的 $\sum{k^{x_i}}$。

然而这样仍然无法计数，感觉上一层仍然可能有很多有用黑、白点。又由于不关心树的形态，我们对于一棵树其实可以交换同层节点进行重构，那我们再给一个结论：

* 同一层中，有用的白点个数小于 $k$，有用的黑点个数小于 $k$

证明考虑调整，对于一棵树，我们可以交换同层节点（这显然对答案无影响），那我们可以把所有白点放在开头，所有黑点放在结尾，若存在大于等于 $k$ 个有用白点，那前 $k$ 个白点的父亲也成了白点，导出冲突；黑点同理。同时，我们恰好发现经过对最后一个有用层做这种调整，上一层形成了：前缀一些白点，后缀一些黑点，中间**一个**灰点的结构！那么往上归纳，每一层都是这样的结构！ok 啊，我们再来看看这获得了什么。

* 整棵树浓缩成了一条唯一有用的链，由一条灰链骨架和下挂的有用黑、白点组成

这样真的转化成了对链计数了。设 $f_{i, j}$ 意义为填了 $i$ 层（根由于只有一个点就当第 0 层了），已经填了 $j$ 个有用白点的方案数。不用记有用黑点是因为这是一条链，除了灰链骨架非黑即白。转移显然枚举这一层填几个有用白点，对于上一层前缀和优化一下即可。

* $f_{i,j} = \sum \limits_{l = 0}^{k - 1} {f_{i-1,j-l}}$

然后考虑答案的统计，发现灰链骨架的结尾就是最后一次填有用白点的地方，那我们新增一个 0、1 维来记这一轮是否填了有用白点，如果填了就考虑贡献给答案。显然，对于这一条在第 $i$ 层终结链（第 $i$ 层没有灰点），有用白点数为 $j$，则有用黑点数为 $i \times (k-1)+1-j$。又因为填没用黑、白点相当于使黑、白叶子个数加上 $k-1$，那么 $f_{i,j,1}$ 能贡献给对于 $(n,m)$ 的答案当且仅当

* $j \le n$
* $j \equiv n \pmod {k-1}$ 
* $i \times (k-1)+1-j \le m$
* $i \times (k-1)+1-j \equiv m \pmod{k-1}$

这是好判断的。

同时我们加强一下，下面考虑如何计算 $[1,n]$ 中所有 $n'$ 的答案。发现其实就是 $j$ 贡献给所有 $n' = j + tm \times (k-1)$，$tm$ 为非负整数。那我们每次加首位，并对模 $k-1$ 同余的答案前缀和一下即可。

时间复杂度 $O(\lfloor \frac{n+m}{k} \rfloor \times n)$ 。注意奇异搞笑模数即可。然后你会发现代码和进位考虑的一模一样 o.O。

~~~cpp
// sis puella oier
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef long long ll;
ll read(){
    ll xx = 0, f = 1; char ch = getchar();
    for (;!isdigit(ch); ch = getchar())
        f = (ch == '-' ? -1 : 1);
    for (; isdigit(ch); ch = getchar())
        xx = (xx << 3) + (xx << 1) + ch - '0';
    return xx * f;
}
const int N = 2010, mod = 998234353;
int n, m, k;
int f[2][N][2], sum[N], ans[N];
signed main(){
    n = read(), m = read(), k = read(); int xxx = read();
    f[0][0][0] = 1;
    for (int i = 1, now, lst; i * (k - 1) + 1 <= n + m; ++i){
        now = i & 1, lst = now ^ 1;
        f[now][0][0] = (f[lst][0][0] + f[lst][0][1]) % mod;
        sum[0] = f[now][0][0];
        for (int j = 1; j <= n; ++j)
            f[now][j][0] = (f[lst][j][0] + f[lst][j][1]) % mod,
            sum[j] = (sum[j - 1] + f[now][j][0]) % mod;
        f[now][0][1] = 0;
        for (int j = 1; j <= n; ++j)
            f[now][j][1] = (sum[j - 1] - (j - k >= 0 ? sum[j - k] : 0) + mod) % mod;
        for (int j = 0; j <= n; ++j)
            if ((i * (k - 1) + 1 - j) % (k - 1) == m % (k - 1))
                if (i * (k - 1) + 1 - j <= m)
                    (ans[j] += f[now][j][1]) %= mod;
    }
    for (int i = 0; i + k - 1 <= n; ++i)(ans[i + k - 1] += ans[i]) %= mod;
    printf("%lld\n", ans[n]);
    return 0;
}

~~~

---

## 作者：OUYE2020 (赞：3)

# 题解

首先很容易看出来，答案一定是给每个 1 和 0 配上一个 $k^{-x}$ 的系数再加起来，满足 $\sum k^{-x_i}=1$，求 $Z=\sum_{a_i=1}k^{-x_i}$ 有多少种取值。

显然需要依次考虑 $k$ 进制下 $Z$ 的每个小数位的取值。设 $Z=0.z_1z_2...z_p,z_p>0$，假设 $\sum_{a_i=1}k^{-x_i}$ 从低位到高位求和的过程中没有进位，那么肯定满足 $\sum z_i=n$，若考虑进位，那么满足 $\sum z_i\le n$。但是 $\sum z_i$ 或者说每一个 $z_i$ 具体的限制究竟是什么？如果你像傻*我一样到了这里就不继续推导而想着优化暴力DP的话，那么你最终会在发现自己的四次方五次方DP怎么都会把方案算重的时候崩溃掉。

其实我们可以很轻易地发现，当产生进位的时候，低位处减少 $x*k$ ，高位处会增加 $x$，此时 $\sum z_i$ 刚好减少 $k-1$ 的整数倍，也就是说 $\sum z_i$ 仍满足 $\sum z_i=n(\bmod k-1)$。归纳验证发现，$\sum z_i\le n$ 和 $\sum z_i=n(\bmod k-1)$ 这两条限制已经足够。

还剩下 $\sum k^{-x_i}=1$ 这个条件，我们可以发现它其实等价于 $\sum_{a_i=0}k^{-x_i}=1-Z$，我们把 $1-Z=0.(k-1-z_1)(k-1-z_2)...(k-1-z_{p-1})(k-z_p)$ 套用上面的推导即可得出 $1+(k-1)p-\sum z_i\le m$ 和 $1+(k-1)p-\sum z_i=m(\bmod k-1)$ 的限制。

然后DP的转移就很明显了，只需要设 $dp[i][j][0/1]$ 表示考虑到小数点后第 $i$ 位，$\sum_{x=1}^i z_x=j$ 且 $z_i$ 等于/大于 0 时的取值个数，转移方程为

$$
dp[i][j][0]=dp[i-1][j][0]+dp[i-1][j][1]
$$
$$
dp[i][j][1]=\sum_{x=1}^{k-1}(\,dp[i-1][j-x][0]+dp[i-1][j-x][1]\,)
$$

算答案只需要统计所有 $j$ 满足条件的 $dp[i][j][1]$ 的和即可。

然后就做完了。**不需要前缀和优化**，因为第一维不超过总操作数，故直接转移复杂度是 $O(\frac{n+m-1}{k-1}kn)=O(n^2)$。

# 代码

```cpp
#include<bits/stdc++.h>//JZM yyds!!
#define ll long long
#define uns unsigned
#define IF (it->first)
#define IS (it->second)
#define END putchar('\n')
using namespace std;
const int MAXN=4005;
const ll INF=1e18;
inline ll read(){
	ll x=0;bool f=1;char s=getchar();
	while((s<'0'||s>'9')&&s>0){if(s=='-')f^=1;s=getchar();}
	while(s>='0'&&s<='9')x=(x<<1)+(x<<3)+(s^48),s=getchar();
	return f?x:-x;
}
int ptf[50],lpt;
inline void print(ll x,char c='\n'){
	if(x<0)putchar('-'),x=-x;
	ptf[lpt=1]=x%10;
	while(x>9)x/=10,ptf[++lpt]=x%10;
	while(lpt)putchar(ptf[lpt--]^48);
	if(c>0)putchar(c);
}
inline ll lowbit(ll x){return x&-x;}

const ll MOD=1e9+7;
int n,m,k,p;
ll dp[MAXN][MAXN][2],ans;
inline void ad(ll&a,ll b){a+=b;if(a>=MOD)a-=MOD;}
signed main()
{
	n=read(),m=read(),k=read(),p=(n+m-1)/(k-1);
	dp[0][0][0]=1;
	for(int i=1;i<=p;i++){
		for(int j=0;j<=n;j++){
			dp[i][j][0]=(dp[i-1][j][0]+dp[i-1][j][1])%MOD;
			for(int x=1;x<k&&x<=j;x++)
				ad(dp[i][j][1],dp[i-1][j-x][1]),
				ad(dp[i][j][1],dp[i-1][j-x][0]);
		}
		for(int j=0;j<=n;j++)
			if(j%(k-1)==n%(k-1)&&((k-1)*i+1-j)<=m&&((k-1)*i+1-j)%(k-1)==m%(k-1))
				ad(ans,dp[i][j][1]);
	}
	print(ans);
	return 0;
}
```



---

## 作者：APJifengc (赞：2)

首先考虑将这个过程看做是一棵满 $k$ 叉树，其中有 $n + m$ 个叶子，$n$ 个叶子为 $0$，$m$ 个叶子为 $1$。不难发现，如果一个 $1$ 的深度为 $x$，那么它对最后的数造成的贡献为 $\frac{1}{k^x}$。

那么假如我们考虑 $0, 1$ 的深度序列 $\{x_i\}, \{y_i\}$，考虑什么样的序列能够对应到一颗树上。发现实际上就是如果把 $0, 1$ 都算上贡献，最后和为 $1$。即：$\sum \frac{1}{k^{x_i}} + \sum \frac{1}{k^{y_i}} = 1$。证明考虑每次将次数最大的 $k$ 个数进行合并，如果不能合并显然不可能等于 $1$，于是一定可以通过这样的合并方式得到一棵合法的树。

那么我们相当于要统计满足上述的 $\{x_i\}, \{y_i\}$ 序列中，有多少个不同的 $\sum \frac{1}{k^{x_i}}$。考虑将后面这个数写成 $k$ 进制的形式，那么我们的问题就是对于一个序列 $\{z_i\}$，能否将 $\sum z_i k^i$ 表示成 $\sum k^{x_i}$。可以通过从高到低位依次满足的方式构造出一种方案，由于每次往下放一位造成的差值为 $k-1$，那么只需要满足 $\sum z_i \equiv n \pmod {k-1}$ 即可保证这个数一定可以被构造出来。

我们假设最终的数为 $p$，那么我们一开始得出的条件实际上是要求：

- $p$ 能够被表示成 $n$ 个 $\frac{1}{k^ {x_i}}$ 的加和；
- $1 - p$ 能够被表示成 $m$ 个 $\frac{1}{k^ {y_i}}$ 的加和；

那么我们现在就可以将题意转换成统计有多少合法的长为 $l$ 的 $\{z_i\}$ 序列，满足：

- $0 \le z_i < k$；
- $z_l \ne 0$；
- $\sum z_i \le n, \sum z_i \equiv n \pmod {k-1}$；
- $1 + \sum (k - z_i + 1) \le m, 1 + \sum (k - z_i + 1) \equiv m \pmod {k-1}$；

这个容易 DP 得出答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 4005, P = 1000000007;
int n, m, k;
int f[MAXN][MAXN];
int main() {
    scanf("%d%d%d", &n, &m, &k);
    int ans = 0;
    for (int i = 0; i <= n; i++)
        f[0][i] = 1;
    for (int i = 1; i <= n + m; i++) {
        for (int j = max(0, (k - 1) * i - m + 1); j <= n; j++) {
            f[i][j] = (f[i - 1][j] - f[i - 1][max(0, j - (k - 1)) - 1] + P) % P;
            if ((j - n) % (k - 1) == 0)
                ans = (1ll * ans + 
                    f[i - 1][j - 1] - f[i - 1][max(0, j - (k - 1)) - 1] + P) % P;
            f[i][j] = (f[i][j] + f[i][j - 1]) % P;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：苹果蓝17 (赞：2)

设操作次数为 $d=\frac{n+m-1}{k-1}$。

把初始的 $n+m$ 个数视为 $n+m$ 个点，每次操作 $k$ 个数就新建一个点作为这 $k$ 个数对应的点的父亲。这样可以将操作对应为一棵 $n+m+d$ 个节点的 $k$ 叉树。

设每个点的权值为其儿子权值的平均值，则最后留下的数 $s$ 即根节点的权值。

也即，设初始的 $m$ 个 $1$ 所对应的编号为 $x_1,x_2,\cdots,x_m$，则 $s=\sum_{i=1}^m k^{-dep_{x_i}}$。

注意到，设初始的 $n$ 个 $0$ 所对应的编号为 $y_1,y_2,\cdots,y_n$，则有：

$$\sum\limits_{i=1}^m k^{-dep_{x_i}}+\sum\limits_{i=1}^n k^{-dep_{y_i}}=1$$

考虑如何判定一个 $s$ 是否可被构造出来：

> 结论：$s$ 可被构造出来当且仅当存在 $x_1,x_2,\cdots,x_m$ 满足 $\sum_{i=1}^m k^{-dep_{x_i}}=s$ 且存在 $y_1,y_2,\cdots,y_n$ 满足 $\sum_{i=1}^n k^{-dep_{y_i}}=1-s$。

> 证明：必要性显然。充分性：设 $z_t$ 表示为 $t$ 的 $x_i,y_i$ 个数，只需证可以构造一棵树使得深度为 $i$ 的叶子节点恰有 $z_i$ 个。考虑这样一个算法：

+ 由 $d$ 至 $1$ 枚举 $p$，由于 $\sum_{t=1}^p z_t k^{-t}=1$，故 $k \mid z_p$。那么对这 $z_p$ 个点建立 $\frac{z_p}{k}$ 个父亲节点，$z_{p-1} \leftarrow z_{p-1}+\frac{z_p}{k},z_p \leftarrow 0$。

> 即可得到一棵满足条件的树。证毕。

下面考虑计数。考虑将 $s,1-s$ 看作 $k$ 进制小数，设 $s=\sum_{i=1}^d a_i k^{-i},1-s=\sum_{i=1}^d b_i k^{-i}$，其中 $a_i,b_i \in [0,k)$。那么需要满足：

+ $\sum_{i=1}^d a_i=m-t_1 (k-1),t_1 \in \N$。

+ $\sum_{i=1}^d b_i=n-t_2 (k-1),t_2 \in \N$。

这是因为每一次进位都会使数位和减少 $(k-1)$。

，则 $\{b_i\}$ 即令所有 $a_i \leftarrow k-1-a_i$，再令 $a_d \leftarrow a_d+1$ 后进位获得的结果，设进位次数为 $t_3$，则：

$$\sum_{i=1}^d b_i=d (k-1)+1-\sum_{i=1}^d a_i-t_3 (k-1)$$

$$n-t_2 (k-1)=(n+m)-m+t_1 (k-1)-t_3 (k-1)$$

$$t_2 (k-1)=(t_3-t_1) (k-1)$$

$$t_2 \geq 0 \Leftrightarrow t_3 \geq t_1$$

故枚举 $t_1 \leq t_3$，统计答案。

记 $A$ 个 $[0,k)$ 中的整数组成的和为 $B$ 的数列数量为 $S(A,B)$，可以用容斥计算：

$$S(A,B)=\sum\limits_{i=0}^A (-1)^i \dbinom{A}{i} \dbinom{B-ik+A-1}{A-1}$$

答案为：

$$Ans=\sum\limits_{t_3=0}^{d-1} \sum\limits_{t_1=0}^{t_3} [S(d-t_3,m-t_1(k-1))-S(d-t_3-1,m-t_1(k-1))]$$

直接暴力计算时间复杂度 $O(d^2\frac{m}{k})=O(\frac{m(n+m)^2}{k^3})$，无法通过。

注意到 $A$ 不超过 $d-1$，$B$ 不超过 $m$。枚举最后一个数是什么，用下式递推：

$$S(A,B)=\sum\limits_{i=0}^{k-1} S(A-1,B-i)$$

于是时间复杂度 $O(d\frac{m}{k}+dmk)=O(m(n+m))$，可以通过。

（可能还有更优的做法？）

#### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4400,mod=1e9+7;
int n,m,k,d,ans;
int f[N][N];

int main(){
	cin>>n>>m>>k;
	d=(n+m-1)/(k-1);
	
	f[0][0]=1;
	for(int i=1;i<=d;i++)
		for(int j=0;j<=m;j++)
			for(int t=0;t<k && t<=j;t++)
				f[i][j]=(f[i][j]+f[i-1][j-t])%mod;
	
	for(int t2=0;t2<d;t2++)
		for(int t1=0;t1<=t2 && t1<=m/(k-1);t1++)
			ans=(ans+(f[d-t2][m-t1*(k-1)]+mod-f[d-t2-1][m-t1*(k-1)])%mod)%mod;
	cout<<ans;
}
```

---

## 作者：Elma_ (赞：1)

> - 黑板上有 $n$ 个 $0$ 和 $m$ 个 $1$，每次操作擦掉其中 $k$ 个数，然后写上它们的平均数，直到黑板上只剩下一个数。
> - 求最后这个数有多少种不同的可能，答案对 $10^9 + 7$ 取模。
> - $1 \leq n,m \leq 1000$，$2 \leq k \leq 2000$，保证最后只剩下一个数。

下文认为 $n,m$ 同阶。

把擦除的过程表示成 $k$ 叉树的结构（类似于 Kruskal 重构树），那么共有 $n + m$ 个叶子，其中 $n$ 个叶子权值为 $0$，$m$ 个叶子权值为 $1$。对于一个非叶节点，其权值为 $k$ 个儿子权值的平均值，则根节点的权值就是剩下的那个数。

考虑每个叶子节点对根节点权值的贡献：设第 $i$ 个权值为 $1$ 的叶子深度为 $x_i$，第 $i$ 个权值为 $0$ 的叶子深度为 $y_i$，那么根节点的权值为 $\sum_{i = 1}^m (\frac{1}{k}) ^ {y_i}$。并且显然当所有叶子的权值均为 $1$ 时根节点的权值也为 $1$，因此还需满足条件：

$$ \sum_{i= 1}^n (\frac{1}{k})^{x_i} + \sum_{i = 1}^m (\frac{1}{k})^{y_i} = 1$$

必要性也是显然的，对于任意一组合法的 $x_i,y_i$ 我们都可以根据 $k$ 进制小数的进位构造出一棵合法的 $k$ 叉树。于是问题转化为求有多少个 $z$ 满足 $z$ 可以写成 $\sum_{i = 1}^m (\frac{1}{k}) ^ {y_i}$ 的形式，且 $1-z$ 可以写成 $\sum_{i = 1}^n (\frac{1}{k}) ^ {x_i}$ 的形式。

将 $z$ 写成 $k$ 进制小数 $0.c_1c_2\cdots c_p$，在不考虑进位的情况下，$c_i$ 表示深度为 $i$ 的权值为 $1$ 个叶子的个数。因此显然有：

$$ \sum_{i = 1}^p c_i = m $$

而对于一次进位操作，其相当于将 $c_{i}$ 的值减去 $k$，然后将 $c_{i-1}$ 的值加 $1$。这相当于将 $\sum c$ 的值减去 $k-1$。由此可知：

$$ \sum_{i = 1}^p c_i \equiv m (\mathrm{mod} \ k-1)$$

将 $1-z$ 也写成 $k$ 进制小数 $0.d_1d_2 \cdots d_p$，容易得到其各位数之和：

$$ \sum_{i = 1} ^p d_i = p \times(k -1) - \sum_{i = 1} ^ p c_i + 1$$

并且同理我们有：

$$ \sum_{i = 1}^p d_i \equiv n (\mathrm{mod} \ k-1)$$

据此我们可以设计 dp：设 $f_{i,j,0/1}$ 表示当前在小数点后第 $i$ 位，位数和为 $j$，最后一位是/不是 $0$ 的方案数。转移时考虑当前位放什么数即可，容易发现这可以用前缀和优化，最终时间复杂度 $O(n^2)$。

```cpp
int N, M, K, Ans, f[2][MN][2], s[MN];

signed main(void) {
    N = read(), M = read(), K = read();
    int o = 0;
    f[o][0][0] = 1;
    for (int i = 1; i <= max(N, M) * 2; i++) {
        o ^= 1;
        s[0] = (f[o ^ 1][0][0] + f[o ^ 1][0][1]) % Mod;
        for (int j = 1; j <= N; j++) {
            s[j] = (s[j - 1] + f[o ^ 1][j][0] + f[o ^ 1][j][1]) % Mod;
        }
        for (int j = 0; j <= N; j++) {
            f[o][j][0] = (s[j] - s[j - 1] + Mod) % Mod;
            if (j) f[o][j][1] = (s[j - 1] - (j >= K ? s[j - K] : 0) + Mod) % Mod; 
        }
        for (int j = 0; j <= N; j++) {
            if (j % (K - 1) == N % (K - 1) && (i * (K - 1) - j + 1) % (K - 1) == M % (K - 1) && i * (K - 1) - j + 1 <= M) {
                Ans = (Ans + f[o][j][1]) % Mod;
            }
        }
    }
    printf("%lld\n", Ans);
	return 0;
}
```


---

## 作者：Purslane (赞：0)

# Solution

我觉得这个就是真难啊，无法独立做出来。 /tuu

其实也是有迹可循的——显然每个数最后的贡献形如 $op_i \dfrac{1}{k^{t_i}}$，其中 $t_i$ 是它被合并的次数。尝试给 $\{t_i\}$ 合法一个好看的充要条件（显然只需要考虑 $t_i$ 的可重集合，所有数的地位是相等的）。

而将所有的 $op_i$ 都看做 $1$，显然有 $\sum \dfrac{1}{k^{t_i}}=1$。这个条件显然是充要的。

而对于有理数 $r$，写成 $k$ 进制小数可以得到他需要的多少个 $i$ 拼出来，设为 $c$。则所有的 $c+kx$ 都可以成为答案。

因此我们直接对 $r$ 做数位 DP 即可。（显然除了最后一位 $z$ 和 $1-z$ 对应位置的和都是 $k-1$。这样随便记录一下长度以及某个数数位和即可）。

复杂度 $O(n^2)$（认为 $n,m$ 同阶。）

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=4000+10,MOD=1e9+7;
int n,m,k,ans,dp[MAXN][MAXN],pre[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	dp[0][0]=1;
	ffor(i,1,4000) {
		memset(pre,0,sizeof(pre));	
		ffor(j,0,4000) pre[j]=dp[i-1][j];
		ffor(j,1,4000) pre[j]=(pre[j]+pre[j-1])%MOD;
		ffor(j,0,4000) {
			if(j<k) dp[i][j]=pre[j];
			else dp[i][j]=(pre[j]-pre[j-k])%MOD;
		}
	}
	ffor(len,1,4000) {
		ffor(j,0,4000) {
			int c0=j,c1=(k-1)*len-j+1;
			if(c0>=0&&c1>=0&&c0<=n&&c1<=m&&(c0-n)%(k-1)==0&&(c1-m)%(k-1)==0) ans=(ans+dp[len][j]-dp[len-1][j])%MOD;
		}
	}
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：zifanwang (赞：0)

发现最终的数即为 $\sum_{i=0}^c \frac{a_i}{k^i}$，$0\le a_c\le k$，其中 $c=\frac{n+m-1}{k-1}$，其它的 $0\le a_i<k$，这是一个 $k$ 进制数。发现最后一位可能会向前进位，会让最后若干位都变为 $0$。枚举进位了 $i$ 次，剩下的便是要求 $m-i(k-1)$ 个 $1$ 分到 $c-i$ 个位的方案数，预处理背包即可。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 4003
#define md 1000000007
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
int n,m,k,x;
ll f[mxn][mxn];
signed main(){
	scanf("%d%d%d",&n,&m,&k);
	f[0][0]=1;
	rep(i,1,(m+n-1)/(k-1)){
		rep(j,0,min(i*k,m)){
			rep(x,0,min(j,k-1))f[i][j]=(f[i][j]+f[i-1][j-x])%md;
		}
	}
	rep(i,n,n){
		if((m+i-1)%(k-1)){
			puts("-1");
			continue;
		}
		ll ans=0;
		int ct=(m+i-1)/(k-1);
		for(int j=m;j>0;j-=k-1)ans=(ans+f[ct][j])%md,ct--;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Wu_Qi_Tengteng (赞：0)

对于用一个数把另外一些数替换掉的序列问题，我们可以尝试把他们转换成图上问题。

每个数向替换掉他的数连边，这样就会构成 $k$ 叉一棵树，根节点就是最后剩下的那个数，而叶子节点就是原本的那些数。

我们发现，一个叶子节点若权值为 $1$ ，那么对于根节点的贡献是 $\frac{1}{k^{dep_i}}$。所以我们可以把最终答案看作一个 $k$ 进制下的小数。

所以可以把问题转化为满足某种条件的 $k$ 进制下的小数有多少个。

假设这个数为 $Z$，$m$ 个为 $1$ 的点的深度为 $y_i$，$n$ 个为 $0$ 的点的深度为 $x_i$。那么 $Z$ 一定是可以被 $\sum_{i=1}^{m}\frac{1}{k^{y_i}}$ 表示出来，而 $1-Z$ 一定可以被 $\sum_{i=1}^{n}\frac{1}{k^{x_i}}$ 表示出来。

并且容易证明，如果有一个 $Z$ 满足上述条件，一定可以构造出一棵满足题目要求的树。所以这是一个充要条件。

设 $C$ 表示 $Z$ 在 $k$ 进制下小数位每一位的和，$len$ 表示此时小数位的长度。在不考虑进位的情况下，肯定只有 $C=m$，$len\times(k-1)+1-C=n$ 才符合条件。

而考虑进位的情况下，我们将一个位置拆出一个 $1$ 给下一位，只能使 $C$ 增加 $k-1$，所以只要满足 $C\equiv m\bmod k-1(C\le m)$ 就是合法的。$len\times(k-1)+1-C$ 同理。

那么我们设 $f_{i,j,0/1}$ 表示考虑了 $k$ 进制下小数的前 $i$ 位，和各位之和为 $j$，并且第 $i$ 位是否为 $0$ 的方案数。最后一维为了避免出现重复。

时间复杂度 $\mathcal{O}(N^2)$。
```c++
#include<bits/stdc++.h>
using namespace std;
#define R register
const int N=2e3+5,mod=1e9+7;
int n,m,k;
int f[N<<1][N][2],s[N];
inline int pl(int x){return x>=mod?x-mod:x;}
int ans=0;
signed main(){
    scanf("%d%d%d",&n,&m,&k);
	f[0][0][0]=1;
	for(int i=1;i<=(n+m-1)/(k-1);i++){
		s[0]=f[i-1][0][1]+f[i-1][0][0];
		for(int j=1;j<=m;j++)s[j]=pl(s[j-1]+pl(f[i-1][j][0]+f[i-1][j][1]));
		f[i][0][0]=1;f[i][0][1]=0;
		for(int j=1;j<=m;j++){
			f[i][j][0]=pl(s[j]-s[j-1]+mod);
			f[i][j][1]=pl(s[j-1]-(j-k>=0?s[j-k]:0)+mod);
		}
		for(int j=1;j<=m;j++){
			if(j%(k-1)==m%(k-1)&&(i*(k-1)+1-j)<=n&&(i*(k-1)+1-j)%(k-1)==n%(k-1)){
				ans=pl(ans+f[i][j][1]);
			}
		}
	}
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Sky_Maths (赞：0)

# 前言
[AT_agc009_e](https://www.luogu.com.cn/problem/AT_agc009_e)

一道计数 DP 好题。

# 正文
首先，发现必然会合并 $\frac{n + m - 1}{k - 1}$ 次，约定 $d$ 代表合并次数。

然后发现，对于每个 $1$ 的贡献，取决于其被合并的次数，每被合并一次，贡献 $\times \frac{1}{k}$，也就是每个数的系数都是 $(\frac{1}{k})^{x}$，其中 $1\le x\le d$。

将合并的方案写成一棵 $k$ 叉树，每个叶子节点代表原本的数，每个非叶子节点的权值是儿子节点权值的平均值。

最终剩下的数 $ans=\sum\limits_{i = 1}^{n + m}w_i\cdot(\frac{1}{k})^{x_i}$，其中 $w_i\in\{0,1\}, 1\le x_i\le d$。

$ans$ 可以写成 $k$ 进制小数的形式。即 $ans=0.z_1z_2z_3z_4z_5\cdots$，但还有进位的问题。

发现树的形态不影响答案，而每个 $0/1$ 的深度才影响答案（因为只有深度影响系数，而只有系数影响答案）。

考虑进位的意义：将所有 $1$ 放在左边，若有全部都是 $1$ 的节点，就合并成一个节点。

称最终生成的树为该树的小数形式。

每进一次位，$z_i$ 减小 $k$，$z_{i - 1}$ 增大 $1$。那么总和会减小 $k - 1$，即可以枚举进位次数，每进一次位，小数形式的节点数减小 $k - 1$。

也就是我们需要求前 $i$ 位的数字和为 $j$ 的有几种可能。

枚举当前位的值即可。
# 代码
```cpp
ci N = 2e3 + 9;
int n, m, k, d, ans;
int f[N * 2][N];
int Special() {
	if(!n || !m) {
		puts("1");
		return 1;
	}
	return 0;
}
int main() {
	rd(n); rd(m); rd(k);
	d = (n + m - 1) / (k - 1);
	if(Special()) return 0;
	f[0][0] = 1;
	rep(i, 1, d) {//前 i 位
		rep(j, 0, min(n, i * k)) {//有 j 个 0
			rep(t, 0, min(k - 1, j)) {//第 i 位有 t 个 0
				fadd(f[i][j], f[i - 1][j - t]);
			}
		}
	}
	// f[i][j]:前 i 位， j 个 1
	rep(x, 0, d) {//进位 x 次
		int dt = d - x;
		int nt = n - x * (k - 1);
		if(nt > 0 && nt <= n) fadd(ans, f[dt][nt]);
	}
	pt("%d\n", ans);
	return 0;
}
```

---


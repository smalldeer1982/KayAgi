# [AGC022F] Checkers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc022/tasks/agc022_f

$ X\ =\ 10^{100} $ とします。イナバは $ N $ 個の駒を数直線上に置いていて、$ i $ 個目の駒は座標 $ X^{i} $ にあります。

$ 1 $ 秒ごとに、イナバは $ 2 $ 個の駒 $ A $、$ B $ を選び、$ A $ を $ B $ に関して対称な点に動かし、その後 $ B $ を取り除きます（$ A $、$ B $ が同じ位置にあっても構わず、$ A $ が移動後に他の駒と同じ位置にあっても構いません）。

$ N\ -\ 1 $ 秒後には、駒が $ 1 $ 個だけ残ります。その駒の位置としてありうるものは何通りあるか、その数を $ 10^{9}\ +\ 7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ N $ は整数である。

### Sample Explanation 1

駒が $ 3 $ 個あり、それぞれ座標 $ 10^{100},\ 10^{200},\ 10^{300} $ に置かれています。これらをそれぞれ $ A $、$ B $、$ C $ と呼びます。 考えられる駒の動かし方（$ 12 $ 通り）のうち $ 2 $ つを示します。 - 最初の $ 1 $ 秒で $ A $ に $ B $ を飛び越えさせ、次の $ 1 $ 秒で $ A $ に $ C $ を飛び越えさせる。$ A $ の最終的な位置は $ 2\ \times\ 10^{300}\ -\ 2\ \times\ 10^{200}\ +\ 10^{100} $ となる。 - 最初の $ 1 $ 秒で $ C $ に $ A $ を飛び越えさせ、次の $ 1 $ 秒で $ B $ に $ C $ を飛び越えさせる。$ B $ の最終的な位置は $ -2\ \times\ 10^{300}\ -\ 10^{200}\ +\ 4\ \times\ 10^{100} $ となる。 駒の動かし方は合計で $ 3\ \times\ 2\ \times\ 2\ =\ 12 $ 通りあり、そのすべてで最後の駒は異なる位置に残ります。

### Sample Explanation 3

答えを $ 10^{9}\ +\ 7 $ で割った余りを出力することを忘れずに。

## 样例 #1

### 输入

```
3```

### 输出

```
12```

## 样例 #2

### 输入

```
4```

### 输出

```
84```

## 样例 #3

### 输入

```
22```

### 输出

```
487772376```

# 题解

## 作者：Alex_Wei (赞：19)

> *I. [AT3951 [AGC022F] Checkers](https://www.luogu.com.cn/problem/AT3951)*

为什么会有人模拟赛搬 AGC F 啊？

首先将每个点的坐标看成 $10 ^ {100}$ 进制，那么每一位独立，因为最终结果的每一位不超过 $2 ^ {n - 1} \ll  10 ^ {100}$。

考虑一个点删去另一个点的过程，从 $A\to B$ 连边画成一棵树。那么最终 $B$ 这一位的绝对值即 $2 ^ d$，其中 $d$ 是它的深度，因为每次 $0$ 向 $2 ^ k$ 跳一步会达到 $2 ^ {k + 1}$。

现在的问题是每一位的符号应当如何确定。注意到 $B$ 被删去后，包含 $B$ 这一位的点每删去一个点，$B$ 的符号就会改变一次。因此，一个节点受到它的所有祖先 $a$ 在与 $a$ 同一层的且在 $fa_a$ 的子树内的 “兄弟” 节点当中被删去的时间的影响，或者说一个点 $u$ 的符号受到 “某个节点删去包含 $u$ 的节点（因为 $v$ 删去 $u$ 之后就包含了它，而 $v$ 删掉它的所有儿子之后又被 $w$ 删除，那么 $w$ 就包含了 $u$）并在此之后又删掉了其它节点” 这个事件发生次数的奇偶性。这个在从上往下 DP 的过程中可以直接考虑到：考虑一次扩展一层。如果一个本层节点 $u$ 在下一层有偶数个儿子，那么这些节点正负个数相等，否则 **与 $u$​ 相同的符号** 会多一个，因为最后被 $u$ 删去的节点与 $u$ 的符号相同，往前推正负性不断改变，因为有奇数个所以除去最后被 $u$ 删去的节点往前推偶数个，正负抵消了。

但是 $B$ 的符号还受到它的儿子个数的 **奇偶性** 的影响，因为 $B$ 每删去一个点，符号也会改变一次。所以我们需要记录一维体现这个因素。层数是不重要的，我们只需知道已经选择了几个节点，因此设 $f_{i, j}$ 表示已经确定了 $i$ 个节点，其中当前层钦定 **恰好** 有 $j$​​ 个节点有奇数个儿子（这意味着这些节点的 **原符号**（即不考虑儿子个数的奇偶性的影响，仅考虑）与 **最终符号**（即考虑儿子个数的奇偶性的影响）不同）的总方案数。

- 被钦定有奇数个儿子的节点原符号必然相同，因为若有两个符号不同的节点钦定有奇数个儿子，这与它们同时有偶数个儿子所产生的正负贡献是等价的。注意，符号和节点编号的选择是两个相对独立的事件。而我们自然是希望钦定有奇数个儿子的节点越少越好，因为钦定有奇数个儿子意味着下一层必须得有符号固定的一些节点。

首先考虑初始值，应该是 $f_{1, 0} = f_{1, 1} = n$。因为根可以有奇数或偶数个儿子。此时这个 $j = 1$ 是正号，因为根节点的初始的符号是正的（删去包含根的节点并在此之后又删掉了其它节点的次数为 $0$，因为没有节点能删掉根）。

接下来考虑转移。枚举 **在最终** 与 $j$ 对应的符号 $\rm sign$（也就是钦定了 $j$ 个原来为 $\rm sign$ 的节点在最终要变为 $-\rm sign$）相同的节点个数 $x$ 和不同的节点个数 $y$。如果 $j = 0$ 则任意，因为究竟 $x$ 是正还是 $y$ 为正都无所谓，这是对称的。

根据上一层的限制，我们首先得放 $j$ 个符号为 $\rm sign$ 的节点挂到那些被钦定恰好有奇数个儿子的节点上，剩下来的**原符号正负平分**，原因在上面已经分析过了。因此 **原符号** 为 $\rm sign$ 的节点个数为 $\dfrac {x + y + j} 2$（如果 $x + y + j$ 的奇偶性不对，则这种方案不合法，跳过）。这说明我们被迫用钦定一些且仅有这些节点拥有奇数个儿子的方法更改它们的符号，也就是让最终符号的分布和我们枚举的 $x, y$ 一致，这样计数才正确。显然，我们需要钦定 $\left|x- \dfrac {x +y + j} 2\right|$ 个节点改变符号。当 $x$ 更大时，说明需要将一些原符号为 $-\rm sign$ 的节点改成 $\rm sign$，否则需要将一些原符号为 $\rm sign$ 的节点改成 $\rm -sign$。但无论是哪种情况，只要 $j$ 的 $-\rm sign$ 确定了，那么对应的改符号也确定了，即转移到的 $\dfrac {|x - y - j|} 2$ 对应的符号也确定了，因此 $x, y$ 的符号也确定了，即唯一确定一种方案。由于一开始 $j = 1$ 确定对应正号，$j = 0$ 则 $x, y$​ 的符号根据对称性可以任意钦定，所以方案唯一确定。

综上，有转移方程
$$
f_{i, j} \times \dbinom{n - i}{x + y}\dbinom{x + y}{x} \to f_{i + x + y, \frac {|x - y - j|} 2}
$$
限制为 $x +y + j$ 是偶数且 $x + y \geq \max(1, j)$。显然，$f_{n, 0}$ 即为所求。时间复杂度 $\mathcal{O}(n ^ 4)$​​。

可能讲得比较混乱，总结一下。我们定义 **原符号** 为仅考虑 $u$ 的祖先的影响时的符号。$u$ 的原符号由 $u$ 的父亲的 **原符号** 以及 $u$ 在它的所有兄弟节点中被删去的顺序决定。如果一个原符号为 $\rm sign$ 的节点 $u$ 有偶数个儿子，那么它们的原符号正负个数相同。如果有奇数个儿子，那么会多出来一个原符号为 $\rm sign$ 的儿子，并且 $u$ 的最终符号会变为 $-\rm sign$，这也是我们能够使得一个节点的原符号和最终符号不同的唯一方法。

对于 $f_{i, j}$ 这个状态来说，我们强制令 $j$ 个节点的符号需要从 $\rm sign$ 变为 $-\rm sign$，通过令它们有奇数个儿子实现。这个符号已经确定了，原因在上面有说明。因此，这意味着下一层节点原符号等于 $\rm sign$ 的比原符号等于 $-\rm sign$ 的要多出来 $j$ 个。但这并不意味着它们的最终符号分布就等于原符号分布，因为下一层节点也可以通过它们的儿子改变符号。为此，我们枚举最终符号分布 $x, y$，这样可以方便地算贡献，并直接推出至少需要改变多少个节点的原符号，从而实现转移。

接下来说一下如何优化到三次方。转移方程先化简为
$$
f_{i, j} \times \dfrac{(n - i)!}{(n - i - x - y)! x! y!} \to f_{i + x + y, \frac {|x - y - j|} 2}
$$
考虑为 $f_{i, j}$ 乘以 $(n - i)!$，那么转移方程变为 $\dfrac {f_{i, j}}{x! y!} \to \cdots$。最后答案因 $(n - n)! = 1$ 仍为 $f_{n, 0}$。

我们注意到 $x, y$ 的转移相对来说是很独立的，除了要满足 $2\mid x + y + j$，$x + y > 0$ 且 $x + y\geq j$ 的限制。第一项等价于 $2\mid x + y - j$，第三项等价于 $y\geq j - x$。由于最终贡献的下标形为 $\dfrac {|x - y - j|}2$，我们不妨先从 $f(i, j)$ 转移到 $g(i + x, x - j)$，再从 $g(i', j')$ 转移到 $f\left(i' + y, \dfrac {|j' - y|} 2\right)$。

考虑这些限制：$y \geq j - x\iff y \geq -j'$，容易考虑到。$2\mid x + y - j\iff 2\mid j' + y$，容易考虑到。对于 $x + y > 0$ 而言，我们在枚举 $x$ 的时候仅枚举 $x \geq 1$ 的部分。为了包含 $x = 0$，$y\geq 1$​​ 的部分，我们用一开始的转移方程就好了。时间复杂度 $\mathcal{O}(n ^ 3)$。

注意对于每个 $i$ 要先用 $g_i \to f_{i + y}$，再 $f_i\to g_{i + x}$，前者求出了 $f_i$ 的真实值（因为有 $y = 0$ 的情况），否则会漏考虑很多情况。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 500 + 5, p = 1e9 + 7;
int n, fc[N], ifc[N], f[N][N], g[N][N << 1];
void add(int &x, int y) {x += y, x >= p && (x -= p);}
int ksm(int a, int b) {
	int s = 1;
	while(b) {
		if(b & 1) s = 1ll * s * a % p;
		a = 1ll * a * a % p, b >>= 1;
	}
	return s;
}
int main() {
	cin >> n;
	for(int i = fc[0] = 1; i <= n; i++) fc[i] = 1ll * fc[i - 1] * i % p;
	ifc[n] = ksm(fc[n], p - 2), f[1][0] = f[1][1] = fc[n];
	for(int i = n - 1; ~i; i--) ifc[i] = 1ll * ifc[i + 1] * (i + 1) % p;
	for(int i = 1; i <= n; i++) {
		for(int j = -n; j <= n; j++) if(g[i][j + n]) for(int y = max(0, -j); y <= n - i; y++) if(j - y & 1 ^ 1) add(f[i + y][abs(j - y) >> 1], 1ll * g[i][j + n] * ifc[y] % p);
		for(int j = 0; j <= i; j++) if(f[i][j]) {
			for(int x = 1; x <= n - i; x++) add(g[i + x][x - j + n], 1ll * f[i][j] * ifc[x] % p);
			for(int y = 1; y <= n - i; y++) if(y >= j && (y + j & 1 ^ 1)) add(f[i + y][y + j >> 1], 1ll * f[i][j] * ifc[y] % p);
		}
	}
	cout << f[n][0] << endl;
    return 0;
}
```



---

## 作者：Kinandra (赞：19)

标签: DP

#### Part 1

对于每次操作将 $B$ 连向 $A$ . 这样会连 $n-1$ 条边且图联通, 所以连出来的是一棵树, 不妨以最后剩下的点为**根节点**.

考虑树上每个点对根节点的坐标的贡献, 发现点 $i$ (除根以外) 对父亲的贡献为 $+2x^i$ 或 $-2x^i$ , 易得 $i$ 对根节点的贡献为 $c_i\times2^{d_i}x$ , 其中 $d_i$ 表示 $i$ 在树中的深度(根节点为 $0$), $c_i\in\{1,-1\}$.

由于 $2^n\ll x$ , 两个操作方案最后的点坐标的取值不同**等价于**两个方案对应的 $(c_i,d_i)$ 取值不同.

#### Part 2

发现 $d_i$ 仅与树的形态有关, 先考虑 $c_i$ 的取值受到什么限制.

从连边的角度来看, 注意到连边的顺序必然是一个点的所有儿子都连向这个点后, 这个点才会连向其父亲(从操作的定义考虑), 在 $u$ 的所有儿子依次连向 $u$ 时, $u$ 恰好被取相反的次数为儿子数目 $sn_u$ , 同时可知有恰好 $\lfloor\frac {sn_u}2\rfloor$ 个儿子被取相反奇数次.

由此我们可知, 对于根节点 $root$, $c_{root}=(-1)^{sn_{root}}$, 对于非叶子节点 $u$ , 有 $\lfloor\frac{sn_u}2\rfloor$ 个儿子 $v$ 满足 $c_v=(-1)^{sn_v}c_{u}$, 其他$\lceil\frac{sn_u}2\rceil$ 个儿子 $v$ 满足 $c_v=(-1)^{sn_v+1}c_{u}$ .

#### Part 3

考虑DP求方案数, 为了便于设计DP状态, 探究一下两个方案的 $(c_i,d_i)$ 相同有什么性质.

由 $d_i$ 对应相等知, 两棵树在每一层的点组成的集合对应相同. 

记 $c'_i=-[sn_i\bmod2]c_i$ , 由 $c_i$ 对应相等可知, 两棵树每一层的 $\sum c'_i$ 对应相等, 由于 $c_i\in\{-1,1\}$ , 所以 $\sum [c'_i=1]$ 和 $\sum[c'_i=-1]$ 也对应相等(即第 $i$ 层对下一层贡献为 $1$ 和 $-1$ 的数量分别是一个定值). 这个结论可用数学归纳法来得出: 第一层(根节点)显然满足, 又可知  $\sum_{d_u=i+1}c'_u={\frac {\sum_{d_u=i+1}1+\sum_{d_u=i}c'_u}{2}}-\sum_{d_u=i+1}[c_u=1]$ , 结论得证.

那么我们设计状态 $f[i][j][x]$ 表示考虑完了 $i$ 层, 前 $i$ 层有 $j$ 个点, 且 $\sum_{d_u=i}c'_u=x$ 的方案数, 由于一组确定的 $(c_i,d_i)$ 对应唯一一组 $c'_i$ , 所以这个状态可以不重不漏地统计答案, 答案为 $\sum_i f[i][n][0]$.

转移很简单, 枚举第 $i$ 层有 $t$ 个点, 其中 $p$ 个点 $c=1$ 得:  $f[i][j][x]=\sum_{p\leqslant t\leqslant j}{j\choose t}{t\choose p}f[i-1][j-t][2x-t+p]$ , 注意第 $i$ 层连向第 $i+1$ 层得边至少有 $abs(x)$ 条, 故要保证 $abs(2x-t+p)\leqslant t$.

暴力转移即可, 时间复杂度 $\mathcal O(n^5)$ , 网上似乎广为流传各种 $n^4,n^3$ 的做法(看不懂啊!!!), 感觉这个做法被吊打.

```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;
int read();
int M(int x) { return x >= mod ? x - mod : x; }
void Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }
int n, res;
int C[102][102];
struct DP {
    int x[102];
    int &operator[](int p) {
        return (p <= 50 && p >= -50) ? x[p + 50] : x[101];
    }
} f[102][102];
int main() {
    scanf("%d", &n), f[1][1][0] = f[1][1][1] = 1;
    if (n == 1) return puts("1"), 0;
    for (int i = C[0][0] = 1; i <= n; ++i)
        for (int j = C[i][0] = 1; j <= i; ++j)
            C[i][j] = M(C[i - 1][j] + C[i - 1][j - 1]);
    for (int i = 2; i <= n; ++i) {
        for (int j = i; j <= n; ++j)
            for (int x = j - n; x <= n - j; ++x)
                for (int t = 1; t <= j; ++t)
                    for (int p = 0; p <= t; ++p)
                        if (abs((x + p) * 2 - t) <= t)
                            Add(f[i][j][x],
                                1ll * f[i - 1][j - t][(x + p) * 2 - t] *
                                    C[j][t] % mod * C[t][p] % mod);
        Add(res, f[i][n][0]);
    }
    printf("%d\n", res);
    return 0;
}
```



---

## 作者：樱雪喵 (赞：11)

Tags: Tree，dp，计数

不是，为什么这么抽象的题赛时过的人比 D 多啊？？  
对着某篇错的题解瞪了一天，真服了。

考虑转化题意。我们令一次 $A$ 关于 $B$ 对称的操作对应为在一个图上将点 $B$ 向点 $A$ 连一条边。那么由于一个点被对称过就会消失，在图上对应为只有一条出边。一共有 $n-1$ 条边且连通，所以这是一棵树。根为最后剩下那个节点编号。

由于对称操作形如 $A\gets 2B-A$，过程中每个点的坐标一定形如 $\sum 2^j (-1)^k x^i$。由于 $x$ 足够大，我们可以认为 $x$ 的不同次幂之间的贡献是互不影响的，也就是说只要这个多项式任意一项系数不同，我们就认为它求和的结果不同。

考虑根据这棵树求出最后点所在的位置，设 $ans_x$ 表示点 $x$ 对最后总答案产生的贡献。  
在实际过程中，我们一定是以从叶子逐步向上的顺序进行操作，一个点只有在所有叶子都操作完的情况下才能被操作。而考虑一次操作对树上每个点贡献的改变，$fa_x$ 关于 $x$ 对称即令 $x$ 所在的连通块 $ans$ 全部乘 $2$，$fa_x$ 所在的连通块取反。 

那么点 $x$ 在 $2^j$ 这部分的贡献显然是 $2^{dep_x}$，这只与树的形态有关。另一部分取决于 $x$ 的儿子数量和深度，两个限制是不好求的，我们做这样的转化：只要知道点 $x$ 的正负性（下文称之为“颜色”）是否与其父亲节点相同，即可还原出整棵树的颜色。而一个点每加一次儿子就取反一次，这就只与 $fa_{x}$ 的儿子个数和 $x$ 被连边的顺序有关了。

进一步地，设点 $x$ 的儿子个数为 $son_x$，则恰有 $\lfloor \frac{son_x}{2}\rfloor$ 个儿子取反偶数次。

性质足够了，考虑 dp。从上到下一层层给这棵树填节点，设 $f_{i,j}$ 表示已经填了 $i$ 个节点（我们不关心是第几层），最后一层有 $j$ 个奇数个儿子的节点。

枚举这一层的节点数 $k$。那么上一层的 $j$ 个节点均会被下取整掉一个儿子，这层与父亲奇偶性相同的节点总数为 $t=\frac{k-j}{2}$（奇偶性不对就不合法，跳过这个 $k$）。接下来我们需要知道当前层儿子数为奇数的节点个数。

枚举 $p$ 表示**这一层**与父亲颜色相同的节点个数。那么我们至少需要 $|t-p|$ 个奇数儿子的点才能放得下这 $p$ 个节点。而更多的奇数点（$|t-p|+2x$）是没有意义的，因为我们并不关心下层的点具体每个怎么连，这对实际的贡献没有影响，是树形态不同但最终位置相同的重复解。理解上注意分清“有奇数个儿子”和“取反次数是奇数”。

故有转移：
$$f_{i+k,|t-p|}\gets f_{i,j}\binom{n-i}{k}\binom{k}{p}$$
时间复杂度 $O(n^4)$。


```cpp
#define int long long
const int N=105,mod=1e9+7;
int n,c[N][N],f[N][N];
il void init(int mx)
{
	for(int i=0;i<=mx;i++)
		for(int j=0;j<=i;j++) c[i][j]=j?(c[i-1][j-1]+c[i-1][j])%mod:1;
}
il void add(int &x,int y) {x=(x+y)%mod;}
signed main()
{
	n=read(); init(n);
	f[1][0]=f[1][1]=n;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=i;j++)
		{
			if(!f[i][j]) continue;
			for(int k=j?j:2;k<=n-i;k+=2)
			{
				int t=(k-j)>>1;
				for(int p=0;p<=k;p++) add(f[i+k][abs(p-t)],f[i][j]*c[n-i][k]%mod*c[k][p]);
			}
		}
	printf("%lld\n",f[n][0]);
	return 0;
}

```


---

## 作者：lzk5627 (赞：11)

先膜拜一下第一个A掉这题的Dra

然后这里介绍一种 $O(n^4)$ 的做法

首先还是考虑连边,把每次消掉的 B 的父亲设成 A ,那么就会发现每一个点的贡献就是 $a_ic_ix_i$ 其中 $a_i=2^d$ ,d为深度,$c_i$ 是 1 或 -1,因为 $x_i$ 很大,所以任意两个点之间的贡献可以看做不会互相抵消,那么也就是说对于两个方案只要存在一个 $i$ 使得 $c_i$ 或者 $a_i$ 不同,那么就算做不同的方案

然后发现 $a_i$ 只跟深度有关,那么这里先讨论 $c_i$,我们可以默认根节点的 $c_i=1$ ,那么发现对于一个点,影响 $c_i$ 的有两种因素

* 儿子个数的奇偶性,因为每存在一个儿子都会让父亲的符号改变一次
* 父亲选这个儿子的时候,之前选了儿子个数的奇偶性,若是奇数,那么儿子就会取反一次

然后我们考虑根据这个性质进行dp

设 $f_{i,j}$ 表示选了 $i$ 个点,有 $j$ 个点的儿子个数是奇数

那么每次就可以枚举一个当前层数有 $k$ 个节点,然后我们发现是偶数的儿子个数为 $\frac {k-j}{2}$ (如果发现 $k-j$ 的奇偶性不对那就不转移),也就是说如果不计算下一层的影响的话,将会有 $\frac {k-j}{2}$ 个点与父亲的符号相同

现在考虑计算下一层的影响,枚举一个 $x$ 表示实际上有 $x$ 个节点和父亲不同,那么至少需要 $|\frac {k-j}{2}-x|$ 个奇数点,同时发现如果选 $|\frac {k-j}{2}-x|+2k$ 个奇数点的话也满足要求,但是发现这两种方案到最后是相同的,因为下一层不考虑下下层的影响的话,与这一层父亲的符号相同的数量是一样的

例如下面这种情况
![](https://cdn.luogu.com.cn/upload/image_hosting/9nn28bks.png)

所以我们只向 $f_{i+k}{|\frac {k-j}{2}-x|}$ 转移是正确的

code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=1e9+7;
const int N=55;
int n,f[N][N];
long long fac[N],inv[N];
long long fsp(long long x,int y){
	long long ans=1;
	while(y){
		if(y&1)	ans=ans*x%P;
		x=x*x%P,y>>=1;
	}
	return ans;
}
long long C(int n,int m){
	return fac[n]*inv[m]%P*inv[n-m]%P;
}
int main(){
	scanf("%d",&n),fac[0]=inv[0]=1,f[1][1]=f[1][0]=n;
	for(int i=1;i<=n;i++)	fac[i]=fac[i-1]*i%P;
	for(int i=1;i<=n;i++)	inv[i]=fsp(fac[i],P-2);
	for(int i=1;i<n;i++)
		for(int j=1;j<=n-i;j++)
			for(int k=0;k<=j;k++){
				if((j-k)&1)	continue;
				int x=(j-k)/2;
				for(int d=0;d<=j;d++)
					f[i+j][abs(x-d)]=(f[i+j][abs(x-d)]+f[i][k]*C(n-i,j)%P*C(j,d))%P;
			}
	printf("%d\n",f[n][0]);
	return 0;
}

```

---

## 作者：zzw4257 (赞：10)

这里提供一种@_Enthalpy教我的其实是AGC标解的方法

希望大家能读完这片题解，看上去性质很多很杂，其实你会发现每一步都很逻辑紧密

首先我们转化一下问题

这种 $n$ 元组其实 $A_i$ 对应的是$(-1)^j2^{i-1}$,下标不好挪位置下面经常写错了有些下界是 $0$ 的写成 $1$ 了有些又反了，希望大家理解

(希望大家能理解这种转换和其他题解里树做法的相似性(~~我不能理解~~))

定义 $n$ 个 $n$ 元组，分别为 $A_i($ 最初 $A_i[i]=1),\forall j\neq i,A_i[j]=0$

定义在 $n$ 元组域上的二元运算为 $*$ ,使得 $C=A*B\Leftrightarrow \forall i\in[1,n],C[i]=2A[i]-B[i]$，注意到这个运算没有交换律

然后问题变成求 $|\bigcup\limits _{p \text{~is~a~permutation}}((((A_{p_1}*A_{p_2})*A_{p_3}))\cdots *A_{p_n})|$

即合法的可以作为 $A_i$ 按序乘积的结果种类

设 $B$ 是一个合法的乘积，现在对 $B$ 的性质作分析

- 【性质1】$\forall i, \exists j,k\in \mathbb{Z},B[i]=(-1)^j2^k$
	- 很容易理解，这个归纳法即可
- 【性质2】下文对任意 $n$元组 $A$ 均设 $|A|=\sum_{i} A_i$，若 $B$ 是任意合法的乘积有 $|A|=1$
	- 这个归纳法也可，核心 $C=A*B\Rightarrow |C|=2|A|-|B|=1$
- 【性质3】若$A[i]>0$则$A[i-1]>0(i>1)$
	- 显然
- 【性质4】**超级重要的性质**:若 $A$ 合法则对 $\forall i\in[1,n],$ 设 $S_1=\sum\limits_{j=1}^{i-1}A[j]$ ，再设 $A$ 中形如 $(-1)^k2^i$ 的个数为 $p$ 则存在一种为 $p$ 个 $2^i$ 定符号 $(+~\mathrm{or}~-)$ 方式使得这 $p$ 个数与 $S_1$ 的和为 $1$ ,也即$\forall i\in[1,n],\exists \{x_j\}(\forall j\in[1,i],x_j\in\{-1,1\}),\left(\sum\limits_{j=1}^px_j2^i\right)+S_1=1$
	- 这个性质依然用归纳法证明，基于对满足性质的 $n$ 一定可以被构造出来，我们分可以拆出对指定的 $i$ , $2^j(j\in[1,i))$ 都存在至少 $2$ 个，和不能的分类讨论，后面一种除了唯独 $2^1$ 单独一个都是非法的，可证
   - 【性质4推论】易发现这个性质在 $A$ 上满足后，若我们 $A$ 中有值的部分 $2$ 的次幂形如(性质3) $2^{j}(j\in[0,i])$,则我们必定可以把 $|A|$ 表示成 $1+t2^{i+1},t\in \mathbb{Z}$
		- 再给一个证明，$\exists \{x_j\}(\forall j\in[1,i],x_j\in\{-1,1\}),\left(\sum\limits_{j=1}^px_j2^i\right)+\left(\sum\limits_{j=1}^{i-1}A[j]\right)=1 $,则发现任意$\{y_j\}(\forall j\in[1,i],y_j\in\{-1,1\}),\{x_j\}\neq \{y_j\}$ 有$\left(\sum\limits_{j=1}^px_j2^i\right)\equiv \left(\sum\limits_{j=1}^py_j2^i\right)\pmod {2^{i+1}}
        $即$\left(\sum\limits_{j=1}^py_j2^i\right)+\left(\sum\limits_{j=1}^{i-1}A[j]\right)\equiv 1\pmod{2^{i+1}}$

这四个性质是 $n$ 元组合法的充要条件

然后设计dp

令$f_{i,j}$表示值域为$\{x|x=2^k,k\in[1,n]\}$，放入了 $i$ 个元素，$\exists k\in[1,n],|A|=1+j2^k$，的满足【性质1,3,4】的 $n$ 元组个数(这一步dp的是一个合法的"前缀")

对指定的用 $1+j2^k$ 来表示 $|A|$的所有的被统计 $A$ ,我们知道原来元素的绝对值 $\in\{x|x=2^j,j\in[0,k)\}$,故考虑当前加入 $x$ 个 $2^k$ , $y$ 个 $-2^k$ 则转移到的$n$元组 $B$的 $|B|$ 可以写成 $1+\frac{x-y+j}{2}2^{k+1}$,通过刚刚的表示可以看出 $B$ 也是合法的当且仅当 $x-y\equiv j$(【性质4】推论)

故我们已经可以写出转移了

$f_{i,j}\to f_{i+x+y,\frac{j+x-y}{2}}(x-y\equiv j\mod 2)\frac{1}{x!y!}$，这是 $\mathcal O(n^4)$ 的

注意答案是$n!f_{n,0}$,观察我们莫名加的系数的意思是其实每个位置是有序的但$(-1)^k2^j$中$k,j$**均**相同时是不存在顺序的



---

## 作者：Lisdery (赞：8)

## 题意：
令 $x=10^{100}$， 数轴上有 $n$ 个点，第 $i$ 个点的坐标为 $x_i$。   
进行 $n-1$ 次操作，每次操作选择两点 $A$ 和 $B$，将 $A$ 移动到 $A$ 关于 $B$ 的对称的位置并删去 $B$。  
求最后剩下的一个数有多少种可能的取值。  
$n \leq 50$

## sol 
首先考虑两个数 $A$，$B$。$A$ 关于 $B$ 进行了一次操作，那么 $A$ 新的坐标就是 $2B-A$，注意到每个点只会被一个点进行一次操作，也就是 $n-1$ 个 $B$，那么形成了一个树形的结构，$A$ 关于 $B$ 进行操作后，就把 $B$ 设为 $A$ 的儿子，最后的答案就是根节点的坐标，树结构确定后，$x_i$ 对根节点的贡献就是 $c_i2^{d_i}x_i$，其中 $d_i$ 是 $i$ 节点在树中的深度，$c_i \in \{-1,1\}$，$x_i$ 很大，所以每个点的系数产生一点变化都是一个新方案。  

$d_i$ 的值由树的层数而定，一个点 $i$ 的符号变化有两种情况，第一种是被 $i$ 的儿子节点改变，第二种是在贡献到父亲节点上之后随着父亲节点一起改变，注意到一个点在从父亲的符号得到自己的“原符号”，并且只会被自己的儿子影响，也就是说每次在一棵树的最底层再添加一层时，只需知道最后一层的一些信息即可。那我们考虑从上往下 DP，首先层数是不必要记录的，只需知道点的个数，同时我们用上一层的节点计算出下一层节点符号后，有一些点的符号可能也会被再次改变，所以我们得再加一维，具体来说：  

设 $dp_{i,j}$ 表示 $i$ 个点形成的树，最下面一层有 $j$ 个节点有奇数个儿子节点的方案数。为什么这样设计呢，明确一个事实，一个点 $i$ 会被儿子修改符号当且仅当儿子个数是奇数，因此需要这样记录。同时，DP 的过程中，我们只考虑与每个节点是否与父亲节点符号相同。因为当父亲节点符号确定时，只要有一个节点与父亲符号关系变化了，就是一个新的方案。反之，是同一个方案。  
转移：  
考虑当前状态 $dp_{i,j}$，向后转移。枚举下一层的节点数 $k$，那么我们知道有 $j$ 个节点符号确定与父亲不同，剩下的一半相同，一半不同。我们再枚举实际与父亲相同的个数 $p$，那么下一层至少需要 $|\frac{k-j}{2}-p|$ 个有奇数个儿子，也就是可以转移到 $dp_{i+k,|\frac{k-j}{2}-p|}$ 去。一个错误的想法是，同时转移到 $dp_{i+k,|\frac{k-j}{2}-p|+2w}$ 去。这样会算重：在枚举出这层的点后，$d_i$ 是固定的，只考虑 $c_i$，我们通过确定与父亲符号相同的节点数量来计数，但是无论是否多加偶数个奇数儿子节点，与父亲节点符号相同的节点数量不变，始终是同一种情况，而下一层确定了符号的点反而变多了，所以取最小值很明显包含了所有的情况。   
方程：
$$
dp_{i+k,|\frac{k-j}{2}-p|} \Leftarrow dp_{i,j} \times \dbinom{n-i}{k} \times \dbinom{k}{p} 
$$

初始值：$dp_{1,0}=n,dp_{1,1}=n$，答案：$dp_{n,0}$。  

这样做是 $O(n^4)$ 的。能不能更快呢？  
答案是可以的，可以做到 $O(n^3)$ 。  

观察方程：  
$$
dp_{i+k,|\frac{k-j}{2}-p|} \Leftarrow dp_{i,j} \times \dbinom{n-i}{k} \times \dbinom{k}{p} 
$$
将乘的系数展开：
$$
\dbinom{n-i}{k} \times \dbinom{k}{p} = \frac{(n-i)!}{k!(n-k)!} \frac{k!}{p!(k-p)!}=\frac{(n-i)!}{(n-k)!p!(k-p)!}
$$
发现包含 $k$ 和 $p$ 的项的系数有依赖，很烦，考虑换元。
$$
x=p,y=k-p
$$
$$
\frac{(n-i)!}{(n-k)!p!(k-p)!}=\frac{(n-i)!}{(n-x-y)!x!y!}
$$
考虑把 $f_{i,j}$ 乘以 $(n-i)!$：
$$
dp_{i+x+y,|\frac{-x+y-j}{2}|} \Leftarrow dp_{i,j} \times \frac{1}{x!y!}
$$
注意到 $x$ 和 $y$ 的转移此时是比较独立的，考虑拆开，记原来的 $dp$ 为 $f$，再记一个新的 $g$：
$$
g_{i+y,y-j} \Leftarrow f_{i,j} \times \frac{1}{y!}
$$
$$
f_{i+x,|\frac{j-x}{2}|} \Leftarrow g_{i,j} \times \frac{1}{x!}
$$
考虑限制条件：
$$
0<x+y,j \leq x+y \Rightarrow 0<x+y,x \geq j-y
$$
$$
2|(y-j-x)
$$
唯一困难的是 $0<x+y$，$y=0$ 的情况我们用普通的 dp 做，然后算 $g$ 的时候 $y$ 从 $1$ 开始枚举，用 $f$ 算 $g$ 时 $x$ 从 $0$ 枚举。  
初始值：$dp_{1,0}=n!,dp_{1,1}=n!$，答案：$dp_{n,0}$  
$O(n^3)$，做完了~

---

## 作者：D_F_S (赞：7)

三个月前胡的东西现在就看不懂了，只好来当考古学家。。。

这里提供一个 $O(n^6)$ 的怪浪做法。

## Solution：

考虑将原题的操作转成二叉树形态，每个非叶子向左儿子的边权值为 -1，向右儿子的权值为 2

。将 $X_1\sim X_n$ 填入叶子，对应系数为到根权值积，询问得到的式子的种类数。

下面是 $n=4$ 时的所有树形态：

[![pioL6Vx.png](https://s11.ax1x.com/2023/12/20/pioL6Vx.png)](https://imgse.com/i/pioL6Vx)

如果能知道每种系数的出现次数 $c$，则可直接用组合数 $\frac {n!}{\prod c!}$ 求得答案。

因为边权只有 -1 和 2，系数一定能表示为 $\pm2^k$。考虑由一个点扩展出整棵树，**按 $k$ 对整棵树分层，每层只有正、负两类点。将一个点扩展为两个点，一个是同层异号，另一个是下层同号。**每次扩展会减少一个本类的叶子，新增两个另类的叶子。

用 DP 实现这一过程，考虑一次进行一层的扩展，设 $f_{i,j,x,y}$ 表示已经进行了前 $i-1$ 层的扩展，目前有 $j$ 个叶子（包括第 $i$ 层的所有点），第 $i$ 层有 $x$ 个正点，$y$ 个负点。转移时枚举 $a,b$ 表示第 $i$ 层有 $a$ 个正点、$b$ 个负点要扩展，由此可算出第 $i$ 层剩余的叶子数量，计入组合数当中。在 $j$ 达到 $n$ 时统计答案。具体细节可参考代码。

## Code：

``` cpp
#include<bits/stdc++.h>
#define inl inline
using namespace std;
const int N=52,P=1e9+7;
int n,an,fc[N],ic[N],f[N][N][N][N];
inl int Inv(int x)
{
	int t=1,y=P-2;
	for(;y;y>>=1,x=1ll*x*x%P) y&1&&(t=1ll*t*x%P);
	return t;
}
int main()
{
	scanf("%d",&n); f[1][1][1][0]=1;
	fc[0]=1; for(int i=1;i<=n;++i) fc[i]=1ll*fc[i-1]*i%P;
	ic[n]=Inv(fc[n]); for(int i=n;i;--i) ic[i-1]=1ll*ic[i]*i%P;
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j)
		for(int x=0;x<=j;++x) for(int y=0;x+y<=j;++y)
			if(x||y) if(int t=f[i][j][x][y])		//		若本层已无节点则不应继续转移 
			{
				j==n&&(an=(1ll*t*ic[x]%P*ic[y]+an)%P);
				for(int a=0;j+a<=n;++a)
					for(int b=max(0,a-x);b<=a+y&&j+a+b<=n;++b)		//		枚举 a,b 时要考虑同一层拓展来的点 
						f[i+1][j+a+b][a][b]=(1ll*t*ic[x-a+b]%P*ic[y-b+a]+f[i+1][j+a+b][a][b])%P;
			}
	printf("%lld\n",1ll*fc[n]*an%P); return 0;
}
```



---

## 作者：Otomachi_Una_ (赞：7)

我们看做坐标是关于 $x$ 的多项式。由于 $x$ 非常大，所以我们只需要关心每个项的系数即可。一次操作把两个多项式 $f,g$ 合并为 $h=2f-g$。我们看成建一颗二叉树，叶子一次为 $x^1,x^2,\dots,x^n$。然后往左边走权值就会 $\times 2$，往右边走权值 $\times -1$，最终走到叶子就是这个叶子的权值。一个叶子的权值可以用两个变量 $x_i,y_i$ 表示，其中 $x_i\in\{0,1\}$ 表示向右走的奇偶性，$y_i$ 表示向左走的步数。我们只要统计合法的 $(x_i,y_i)$ 对数量即可。

考虑用桶存起来，我们只需要去枚举桶 $c_{x,y}$ 的数量，在乘上 $\dbinom{n}{c_{0,0}\ c_{1,0}\ c_{0,1}\ c_{1,1}\dots c_{0,n}\ c_{1,n}}$ 即可。

考虑如何去判断一个桶 $c$ 合法。考虑合并的过程，相当于把一对 $(x,y+1),(1-x,y)$ 合并为了 $(x,y)$。考虑从 $y$ 向上面贪心合并即可。最终合并到 $c_{0,0},c_{1,0}$，我们要求 $c_{0,0}=1,c_{1,0}=0$（因为最终的根代表的 $(x,y)=(0,0)$）。

可以写出下面的暴力代码：

[bf sol](https://atcoder.jp/contests/agc022/submissions/46448577) 

枚举 $c$ 的时候显然没有后效性，我们用 dp 记录一下 $i$，目前 $c$ 的和，$|c_{i,0}-c_{i,1}|$ 就可以转移了，复杂度为 $\mathcal O(\text{can pass})$。无论怎么维护常数都很小。

[submission](https://atcoder.jp/contests/agc022/submissions/46448885)



---

## 作者：demonlover923 (赞：7)

根据删除操作连边, 不难看出最后会形成一棵树, 对于一条边不妨将留下的那个点作为父亲, 根也就是最后剩下的点.

我们会发现, 无论大小关系如何, 假设我们是要求 $a$ 对于 $b$ 对称后的点, 那么总有 $val_a \leftarrow 2val_b-val_a$ , 其中 $val_i$ 表示点 $i$ 当前的值.

我们考虑直接写出根最后的结果, 一定会是形如 $\sum\limits_{i=1}^{n}{c_i2^{d_i}x^i}$ 的形式, 其中 $c_i$ 为一个系数, 取值为 $1$ 或 $-1$ , $d_i$ 为点 $i$ 在树上的深度.

同时可以发现 $2^n \ll x$ , 也就是说, 在这个计算式中, 任意两个点对最终结果的贡献不会被抵消, 所以原问题等价于对于 $n$ 个二元组 $(c_i,d_i)$ 的不同方案的计数.

我们会发现, $d_i$ 的实质是每个深度有多少个点而不是树的形态, 意思是我们可以先钦定好树的每个深度有多少点后再用多重组合数的形式来确定每个点上放哪个值.

接下来再考虑 $c_i$ , 手玩后不难发现影响 $c_i$ 的值的因素只有两个, 点 $i$ 的儿子的个数和每个祖先在选完与使点 $i$ 和该祖先相连的链之后再选则其它儿子的儿子个数, 也就是 $c_i=(-1)^{\text{儿子个数+每个祖先在选完与其相连的链后继续选的儿子个数}}$ , 此处建议读者自行画一个树模拟一个点在按操作顺序操作后会被哪些点影响.

以下我们为简便直接称 $c_i$ 为点 $i$ 的权值, 由于一个点的权值只会和儿子与祖先相关, 所以如果我们在最后一层加上一个点, 影响到的只会是其父亲以及其先前加入的兄弟节点, 对于其以后可能的儿子则不做考虑.

所以我们能发现我们并不在乎一个点的权值究竟是 $1$ 还是 $-1$ , 只需要知道它的权值是否与父亲相同就可以确定二元组了.

考虑 $dp$ , 设 $f_{i,j}$ 表示已经考虑了 $i$ 个点且树的最后一层有 $j$ 个点的儿子数为奇数的方案, 这里这样设计状态的原因是方便确定树的大致形态而不必精细, 即方便计算多重组合数, 算是一个套路, 转移方法也是套路.

我们可以发现如果一个点有 $x$ 个儿子, 那么儿子中有 $\lceil \frac{x}{2} \rceil$ 个点的权值与父亲不同, 按加入顺序编号会是奇数编号的点.

转移时就枚举下一层的点数 $k$ , 可以推出在不考虑该层点儿子的情况下有 $\lfloor \frac{j+k}{2} \rfloor$ 个点的权值与其父亲不同.

但是显然不一定有这么多点的权值与父亲不同, 因为有儿子的影响还没算上, 所以我们再枚举算上儿子后和父亲权值不同的点的个数 $l$ , 那么这一层就应该有 $|l-\lfloor \frac{j+k}{2} \rfloor|$ 个点的儿子数是奇数.

所以转移就是 $f_{i+k,|l-\lfloor \frac{j+k}{2} \rfloor|} = f_{j+k,|l-\lfloor \frac{j+k}{2} \rfloor|}+f_{i,j}\times \binom{i+k}{i}\times \binom{k}{l}$ , $\binom{i+k}{i}$ 是多重组合数带着算.

时间复杂度为 $\mathcal{O}(n^4)$ .

```cpp
/************************************************
*Author        :  demonlover
*Created Time  :  2022.04.09.13:00
*Problem       :  AGC22F
************************************************/
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair <int,int> pii;
template <typename T>
inline bool read(T &x) {
	int f = 1,c = getchar();x = 0;
	while (!isdigit(c)) {if (c == 45)f = -1;c = getchar();}
	while (isdigit(c))x = (x<<3)+(x<<1)+(c^48),c = getchar();
	return x *= f,true;
}
template <typename T,typename... Args>
inline bool read(T &x,Args &...args) {
	return read(x) && read(args...);
}

namespace run {
	const int maxn = 1e2+10;
	const int mod = 1e9+7;
	inline void add(int &a,int b) {return a = a+b >= mod ? a+b-mod : a+b,void();}
	inline int power(int a,int b) {
		int res = 1;
		while (b) {
			if (b&1)res = 1ll*res*a%mod;
			a = 1ll*a*a%mod;
			b >>= 1;
		}
		return res;
	}
	int fac[maxn],nfac[maxn];
	inline int C(int n,int m) {
		if (n < m)return 0;
		return 1ll*fac[n]*nfac[m]%mod*nfac[n-m]%mod;
	}
	int f[maxn][maxn];
	int n;
	inline bool main() {
		read(n);
		fac[0] = nfac[0] = 1;
		for (int i = 1;i <= n;++i)fac[i] = 1ll*fac[i-1]*i%mod;
		nfac[n] = power(fac[n],mod-2);
		for (int i = n-1;i >= 1;--i)nfac[i] = 1ll*nfac[i+1]*(i+1)%mod;
		f[1][0] = f[1][1] = 1;
		for (int i = 1;i < n;++i)
			for (int j = 0;j <= i;++j)
				for (int k = max(1,j);k <= n-i;++k)
					if (!((j+k)&1))
						for (int l = 0;l <= k;++l) {
							int tmp = (j+k)>>1;
							add(f[i+k][abs(l-tmp)],1ll*f[i][j]*C(i+k,i)%mod*C(k,l)%mod);
						}
		printf("%d\n",f[n][0]);
		cerr<<1.0*clock()/CLOCKS_PER_SEC<<"\n";
		return 0;
	}
}

#define demonlover
int main() {
#ifdef demonlover
	freopen("AGC22F.in","r",stdin);
	freopen("AGC22F.out","w",stdout);
#endif
	return run :: main();
}
```


---

## 作者：APJifengc (赞：4)

> # 题目大意
> 设 $x=10^{100}$，在数轴上有 $n$ 个点，第 $i$ 个点的坐标为 $x^i$，每次可以将一个点 $A$ 变为关于点 $B$ 的对称点，并把 $B$ 删除，进行 $n-1$ 次这样的操作，问最后能得到多少种不同的坐标。
> 
> $n \le 50$

去看了官方的题解，这里给出官方的 $O(n^4)$ 做法和比较完整的证明。

# 思路

首先，$x$ 特别大，我们可以直接把每个 $x^i$ 看作是互相独立的。$A$ 关于 $B$ 的对称点实际上就是 $2B-A$。

首先观察可以发现，得到的所有数肯定都是长成 $\sum 2^a(-1)^bx^i$ 的形式。

举个例子，比如最后我们得到了 $2x^1+2x^2+x^3-4x^4$，那么我们发现其实只需要把点的顺序调换一下，就可以得到另外一种结果，比如 $2x^1+2x^3+x^2-4x^4$。

所以我们其实只关心最后得到的**系数的集合**。上面的例子中，我们只关心最后得到的系数集合 $\{1, 2, 2, -4\}$。

我们寻找这样的系数集合 $A$ 都有什么性质：

1. $\forall i\in A,\, \exists j,\, \rvert i\lvert=2^j$，即集合中每个元素的绝对值都是 $2$ 的次幂。

   证明：考虑对称的过程 $2B-A$，那么实际上每个数就是被乘上了若干个 $2$。

2. $\sum_{i\in A}i=1$，即集合中元素的和为 $1$。

   证明：考虑归纳法证明。

   首先初始值 $\{1\}$ 的和为 $1$。

   若 $A,B$ 集合均满足以上条件，那么新得到的集合 $2B-A$ 的和为 $2 \times 1 - 1 = 1$，得证。

3. 若 $2^i$ 或 $-2^i$ 属于 $A$，那么 $2^{i-1}$ 或 $-2^{i-1}$ 也属于 $A$。

   证明：同样归纳法证明，如果 $A$ 包含的指数范围为 $[0,a]$， $B$ 包含的指数范围为 $[0,b]$，那么易证 $2B-A$ 包含的指数范围为 $[0,\max(a,b+1)]$。

4. $2^0$ 和 $-2^0$ 中有一个且仅有一个属于 $A$。

   证明：归纳法，首先 $2^0,-2^0$ 都不属于 $2B$，而 $A$ 中有 $2^0,-2^0$ 中的其中一个，所以 $2B-A$ 中有且仅有 $2^0,-2^0$ 中的一个。

但是这些性质都还只是必要条件，并不充分。我们有一个充要条件如下：

对于每一个 $i>1$，存在一种将 $A$ 中的所有 $\pm 2^i$ 元素前的正负号进行修改的方案，使得 $\sum_{\rvert x\lvert=2^j,j\in[0,i]}x=1$（即所有指数小于等于 $i$ 的数的和为 $1$）

证明：

1. 必要性：

   归纳法。

   然后对于每一个 $i>1$，将 $B$ 集合中的 $2^{i-1}$ 元素重标正负号后，得到指数范围在 $[0,i-1]$ 内的数的和为 $1$，并将 $A$ 集合中的 $2^i$ 元素重标正负号后，得到指数范围在 $[0,i]$ 内的数的和为 $1$。

   那么 $2B$ 的指数范围就是 $[1,i]$，且 $2^i$ 的正负号被重标，那么 $2B-A$ 就也符合上述性质。

   对于 $i=1$，根据性质 $4$，一定可以进行重标正负号使得和为 $1$。

2. 充分性：

   我们想办法构造出一种方案，使得 $C$ 集合能够被分为 $2B-A$，并且 $A,B,C$ 集合均满足以上的所有性质，即可证明充分性。

   ------------

   首先假设 $-2^0 \in C$。

   设 $k$ 为最小的正整数使得 $2^k\in C$。如果对于指数范围在 $[1,k-1]$ 内的所有数都出现了大于等于两次，我们可以构造 $B=\{-2^0,-2^1,\cdots,-2^{k-2},2^{k-1}\}$，这样 $2B=\{-2^1,-2^2,\cdots,-2^{k-1},2^k\}$，我们从 $C$ 集合中刨除掉这些元素，再将元素取反，就得到了 $A$ 集合。

   首先可以发现 $B$ 集合满足以上的所有性质，并且 $A$ 集合满足以上的 $4$ 条基本性质。

   --------------

   下面是 $A$ 集合满足性质 $5$ 的证明：

   首先对于所有的 $i\le k$，$C$ 集合中的 $\pm2^i$ 在重标正负号后，$2^i$ 的个数一定大于 $-2^i$ 的个数，否则和 $<0$，不满足性质 $5$。

   那么在重标正负号的结果中，一定存在一个 $2^i$。我们将这个 $2^i$ 分配给 $B$ 集合，将剩下的分配给 $A$ 集合，那么可以证明 $i\le k$ 的时候性质 $5$ 是成立的。

   对于 $i > k$，$C$ 集合重标正负号的结果都分配给了 $A$，因为 $C$ 集合的和为 $1$，$B$ 集合的和也为 $1$，那么 $A$ 集合的和肯定也为 $2\times 1 - 1 = 1$，所以也是成立的。

   综上，这样构造出来的 $A$ 集合是满足性质 $5$ 的。

   -------------

   如果对于指数范围在 $[1,k-1]$ 内，存在一个数只出现了一次，那么我们发现再按照上面的方式分配，会导致得到的 $A$ 集合不满足性质 $3$。

   那么我们记最小的只出现了一次的指数为 $j$。如果 $j=1$，那么我们可以令 $A=\{2^0\}$，并且 $B$ 为剩下的数除以 $2$。对于 $C$ 的每一个前缀和，将它减去第一个元素 $-2^0$ 再除以 $2$ 也等于 $1$，所以 $B$ 集合也是符合性质 $5$ 的。

   如果 $j>1$，那么指数范围在 $[0,j-1]$ 内的数的和的最大值应该为 $-2^0+2(-2^1-2^2-\cdots -2^{j-1})=-2^{j+1}+3$，发现这个数永远小于 $-2^j$，那么无论如何修改 $2^j$ 前面的正负号都无法使得前缀和等于 $1$，所以是不存在 $j>1$ 的情况的。

于是我们证明了性质 $5$ 是一个充要条件。

于是，我们只需要统计满足以上五个条件的集合数有多少种即可。

设 $f_{i,j}$ 表示已经放了 $i$ 个元素，并且这些元素的和为 $1+jV$，其中 $V$ 为现在要放的 $2$ 的次幂是多少。

那么我们枚举选了 $a$ 个 $V$，选了 $b$ 个 $-V$，那么元素的和就变为了 $1+(j+a-b)V$。因为下一个填的数就要比现在的数乘 $2$，所以 $f_{i,j}$ 转移到 $f_{i+a+b,\frac{j+a-b}{2}}$。

我们需要满足将这些数任意标正负号之后，和为 $1$，那么我们只需要满足 $j \equiv a+b \pmod 2$ 且 $a+b\ge \rvert j\lvert$ 即可。

然后考虑对这个系数集合分配原来的 $x^i$，这个就是多重组合数的形式（$\frac{n!}{\prod a!}$），我们可以把 $\frac{1}{\prod a!}$ 的部分拆到转移上，也就是 $f_{i,j} \times \frac{1}{a!b!}\rightarrow f_{i+a+b,\frac{j+a-b}{2}}$。

初始状态为 $f_{0,-1}=1$，答案为 $n!f_{n,0}$。

需要注意，为了满足性质 $4$，需要特殊判断一下，当 $i=0$ 时，必须满足 $a+b=1$ 时才可以转移。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 55, P = 1000000007;
int f[MAXN][MAXN << 1];
int n;
int fac[MAXN], inv[MAXN];
int qpow(int a, int b) {
    int ans = 1;
    while (b) {
        if (b & 1) ans = 1ll * ans * a % P;
        a = 1ll * a * a % P;
        b >>= 1;
    }
    return ans;
}
int main() {
    scanf("%d", &n);
    f[0][MAXN + -1] = 1;
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % P;
    inv[n] = qpow(fac[n], P - 2);
    for (int i = n; i >= 1; i--) inv[i - 1] = 1ll * inv[i] * i % P;
    for (int i = 0; i < n; i++) {
        for (int j = -n; j <= n; j++) if (f[i][j + MAXN]) {
            for (int a = 0; a <= n; a++) {
                for (int b = 0; i + a + b <= n; b++) if ((a || b) && ((j + a + b) % 2 == 0) && a + b >= abs(j)) {
                    if (i == 0 && a + b != 1) continue;
                    f[i + a + b][(j + a - b) / 2 + MAXN] = (f[i + a + b][(j + a - b) / 2 + MAXN]
                         + 1ll * f[i][j + MAXN] * inv[a] % P * inv[b]) % P;
                }
            }
        }
    }
    printf("%lld\n", 1ll * f[n][MAXN + 0] * fac[n] % P);
    return 0;
}
```



---

## 作者：DaiRuiChen007 (赞：3)

# AGC022F 题解

[Problem Link](https://www.luogu.com.cn/problem/AT_agc022_f)

**题目大意**

> 给定 $n$ 个数 $u_i=10^{100i}$，每次选定 $i,j$，使得 $u_i\gets 2u_j-u_i$，然后删掉 $u_j$，求最终的向量有多少种可能结果。
>
> 数据范围：$n\le 100$。

**思路分析**

容易发现我们只关心每个数对答案的贡献系数。

考虑在上述过程中把 $j$ 变成 $i$ 的儿子，那么整个过程会形成一棵树，我们认为最后一次操作的 $j$ 是 $i$ 的第一个儿子。

我们只关心每个点对答案的贡献系数，每次操作会把 $i$ 所在连通块系数取反，$j$ 所在连通块系数 $\times 2$。

注意到每个点对答案的贡献都是 $\pm 2^k$，其中 $k$ 只与深度有关，正负号则与当前节点的儿子数以及其在父亲中的排名有关。

定义一个点的原符号为，删掉这个点的所有儿子时，这个点的符号。

具体来说，如果他是父亲的第 $1,3,5,7$ 个儿子，那么他的原符号与其父亲的原符号相等，否则相反。

最终一个点的符号与其原符号相等当且仅当其儿子数量为奇数。

我们尝试对树的形态进行计数，但这与一个系数组合不构成双射，我们需要对树的形态做出进一步的限制。

对于同一层的两个节点，如果他们有不同的原符号，并且他们都有奇数个儿子，那么把一个儿子移动到另一边不会影响答案，因此我们必须钦定所有有奇数个儿子的点拥有相同的原符号。

考虑最后一层的填法，我们发现该填法有解当且仅当两种符号的差与上一层有奇数个儿子的点的数量一致。

而对于中间的层，我们可以先填原符号，然后把一些点设奇数个儿子来调整符号。

容易发现，根据这样的方式构造树结构，只要最后一层满足条件，任何一组系数都是合法的。

那么我们只要设 $f(i,j)$ 表示已填 $i$ 个节点，最后一层有 $j$ 个点度数为奇数的方案数，设这些点原符号为 $s$，枚举**实际符号**与 $s$ 相等和不等的节点数量 $x,y$。

考虑原符号与 $s$ 相等的节点数量，显然这个答案就是 $\dfrac 12(x+y+j)$，因为删掉 $j$ 个奇数点每个点一个儿子，剩下点正负号恰好平分，而被删掉的儿子符号都为 $s$。

因此对于下一层我们需要 $\left|x-\dfrac 12(x+y+j)\right|=\dfrac 12|x-y-j|$ 个点取奇数个儿子，因此得到：
$$
f\left(i+x+y,\dfrac 12|x-y-j|\right)\gets f(i,j)\binom{n-i}{x+y}\binom {x+y}x
$$
转移条件为 $i+x+y\le n,x+y>0,x+y\ge j,2\mid x+y+j$，边界条件为 $f_{1,0}=f_{0,1}=n$，终止状态为 $f_{n,0}$。

暴力 dp 即可做到 $\mathcal O(n^4)$。

考虑展开组合数，并分离变量得到：
$$
(n-i-x-y)!\times f\left(i+x+y,\dfrac 12|x-y-j|\right)\gets \dfrac{(n-i)!f(i,j)}{x!y!}
$$
转为计算 $f'(i,j)=(n-i)!f(i,j)$，然后分步转移 $x,y$：$\dfrac{f'(i,j)}{x!}\to g(i+x,x-j),\dfrac{g(i',j')}{y!}\to f'\left(i'+y,\dfrac 12|j'-y|\right)$。

转移条件为 $i'+y\le n,j'+y\ge 0,2\mid j'+y$，但 $x+y>0$ 的条件未处理，直接在 $f'\to g$ 一步钦定 $x>0$，$x=0$ 的情况暴力转移即可。

时间复杂度 $\mathcal O(n^3)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=105,MOD=1e9+7;
ll ksm(ll a,ll b,ll p) {
	ll ret=1;
	for(;b;a=a*a%p,b>>=1) if(b&1) ret=ret*a%p;
	return ret;
}
ll fac[MAXN],ifac[MAXN],f[MAXN][MAXN<<1],g[MAXN][MAXN<<1];
signed main() {
	int n;
	scanf("%d%d",&n);
	for(int i=fac[0]=ifac[0]=1;i<=n;++i) ifac[i]=ksm(fac[i]=fac[i-1]*i%MOD,MOD-2,MOD);
	f[1][0]=f[1][1]=fac[n];
	//f[i][j] -> g[i+x][x-j], g[i][j] -> f[i+y][abs(j-y)/2]
	//((j-y)%2=0 and j+y>=0 and i+y<=n) only x>0
//	for(int i=1;i<=n;++i) for(int j=0;j<=i;++j) if(f[i][j]) {
//		for(int x=0;x<=n-i;++x) for(int y=0;y<=n-i-x;++y) if((x+y+j)%2==0&&x+y>=max(1,j)) {
//			f[i+x+y][(abs(x-y-j))/2]+=f[i][j]*ifac[x]%MOD*ifac[y]%MOD;
//		}
//	}
	for(int i=1;i<=n;++i) {
		for(int j=-n;j<=n;++j) if(g[i][j+n]%=MOD) {
			for(int y=0;y<=n;++y) if((j-y)%2==0&&j+y>=0&&i+y<=n) {
				f[i+y][abs(j-y)/2]+=g[i][j+n]*ifac[y]%MOD;
			}
		}
		for(int j=0;j<=i;++j) if(f[i][j]%=MOD) {
			for(int y=0;y<=n-i;++y) if((y+j)%2==0&&y>=1&&y>=j) {
				f[i+y][abs(-y-j)/2]+=f[i][j]*ifac[y]%MOD;
			}
			for(int x=1;x<=n-i;++x) {
				g[i+x][x-j+n]+=f[i][j]*ifac[x]%MOD;
			}
		}
	}
	printf("%lld\n",f[n][0]);
	return 0;
}
```

---

## 作者：xht (赞：3)

## [Checkers](https://atcoder.jp/contests/agc022/tasks/agc022_f)

### 题意

- 令 $x = 10^{100}$。
- 数轴上有 $n$ 个点，第 $i$ 个点的坐标为 $x^i$。
- 你会进行下列操作 $n-1$ 次，最终只剩下一个点：
  - 选择两个点 $a,b$，将 $a$ 移动到关于 $b$ 的对称点。
  - 移除 $b$。
- 求可能的最终点的坐标的数量。
- $n \le 50$，答案对 $10^9+7$ 取模。

### 题解

由于 $x$ 很大，只用考虑每个数的贡献，贡献不同的方案对应的坐标也不同，显然每个数的贡献形如 $\pm 2^k$。

对于每次操作选择的 $a,b$，将 $b$ 的父亲设为 $a$，这样会得到一颗有根树，点 $i$ 贡献中的 $k$ 就是它的深度（根的深度为 $0$）。

考虑正负号，设点 $i$ 有 $c$ 个儿子，则会有 $\lfloor \frac c2 \rfloor$ 个儿子和 $i$ 异号，剩下的同号。

考虑 DP，设 $f_{i,j}$ 表示已经有 $i$ 个点，其中有 $j$ 个奇数个儿子的点的方案数，枚举这一层的点数 $k$，那么不考虑这一层的点的儿子的影响，有 $\frac {k-j}{2}$ 个点和父亲不同，再枚举实际有 $x$ 个点和父亲不同，则意味着有 $|\frac {k-j}2 - x|$ 个点有奇数个儿子。

时间复杂度 $\mathcal O(n^4)$。

### 代码

```cpp
const int N = 57;
int n;
modint f[N][N];

int main() {
	rd(n), init(n), f[1][0] = f[1][1] = n;
	for (int i = 1; i < n; i++)
		for (int j = 0; j <= i; j++)
			for (int k = max(j, 1); k <= n - i; k++) {
				if ((k - j) & 1) continue;
				int y = (k - j) / 2;
				for (int x = 0; x <= k; x++)
					f[i+k][abs(y-x)] += f[i][j] * binom(n - i, k) * binom(k, x);
			}
	print(f[n][0]);
	return 0;
}
```

---

## 作者：Fucious_Yin (赞：2)

# [AGC022F Checkers](https://www.luogu.com.cn/problem/AT_agc022_f)

我通篇只用到了 ***最终符号***。

为什么会有人模拟赛搬 AGC F 啊？魏老师如是说。我们 NFLS 模拟赛是这样的。

在题解转了半天，被魏老师的形式化题解搞晕了，然后往下看各类其他题解，脑子里一直被他们塞满了诸如“原符号”之类的各种定义，但是讲的时候总是几句话带过，又或者在非常简单的定义后抛出各种诸如“我们只能转移到某某某”的重量级结论。然后去和同学讨论发现也是讲不清，最后还是自己基于对题解的片面理解想了一个出来，在这里记录下来，如果写的不好还请包含，如果思路雷同了纯属巧合喵。

我通篇只用到了 ***最终符号***。
***

我们开始看题，发现题目里的 $10^{100}$ 可以当成一个极大值，这样每一位就相对独立了。由于是对称，我们考虑算每个点的坐标对最终答案位置的贡献，也就是一个 $n$ 元一次多项式的系数。一次选择 $A$ 和 $B$，由于对称点 $A' = 2 \times B - A$，则把 $A$ 的系数乘 $-1$，$B$ 的系数乘 $2$。我们不妨把一次操作看成是 $B$ 连向 $A$ 的边，那么最终会形成一棵内向树。

我们考察这棵树的性质，发现每个点的系数都是 $c_i \times 2^{dep_i}$ 的形式，其中 $dep_i$ 为节点 $i$ 的深度（根的深度为零），$c_i \in \{1,-1\}$。这是显然的，因为一个点操作到根一定会操作 $dep_i$ 次，相应的就有 $2^{dep_i}$ 的系数。在所有合并之前，$c_i$ 都为正，但是 $c_i$ 会因合并而各种取反，发现其正负性不好刻画。

我们还是考虑一棵树，对于一棵形态确定的树，他的根的正负是容易得出的：当根的儿子个数为奇数是为负，反之为正，因为根每合并一次会取反。那么，我们只要再知道每个非根节点 ***最终*** 是否与其父亲的正负性相同，即可确定一整棵树的符号，进而确定了原多项式的所有系数，进而得到一个答案。

好了，我们下面考虑，在什么条件下，有最终 $c_i = c_{fa}$，$fa$ 为 $i$ 的父亲。

手玩一下更清晰。我们定义当前层为 $i$ 所在的这一层，相应的下一层和上一层是字面意思。我们再次端详这颗树，发现所有操作一定是从下向上一层一层地操作的，一定是下一层先操作完，再操作当前层（否则树的形态不长这样）。

先考虑 $i$ 的儿子们，因为他们最先操作。

我们引入 $son_i$ 代表 $i$ 的儿子个数，则我们可以简单地表示出，*当下一层（即 $i$ 的儿子们）操作完时*，$i$ 的符号为：$c_i = (-1)^{son_i}$，这是显然的，因为有几个儿子 $i$ 就要取反几次。

再考虑 $i$ 的兄弟们，接下来轮到他们操作。

我们引入 $rk_i$ 表示 $i$ 是他父亲的第 $rk_i$ 个操作的儿子，也就是说，在 $i$ 操作之前，$c_{fa}$ 已经被取反了 $rk_i-1$ 次，而操作 $i$ 时还会取反一次，所以*刚刚操作完 $i$ 时*，$c_{fa} = (-1)^{rk_i}$。

我们发现，只需要看刚刚操作完 $i$ 时，$c_i$ 是否等于 $c_{fa}$ 即可，因为从这时开始，$i$ 和 $fa$ 就将合并为一个整体，同生共死，一起取反，他们之间的同与不同是不会改变的。所以要最终 $c_i = c_{fa}$，就要当前有 $(-1)^{son_i} = (-1)^{rk_i}$，也就是：$son_i$ 与 $rk_i$ 的 ***奇偶性相同*** 。

* $c_i = c_{fa}$，当且仅当 $son_i$ 与 $rk_i$ 的 ***奇偶性相同*** 。
***

我实在手欠要把手玩的例子画出来放在下面看看。我用白色标记正号，橙色标记负号。我们着重观察令 $i = 3$，此时 $fa = 1$，有 $rk_i = 2$ 且 $son_i = 2$，看一看完整的操作过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/3429ulli.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/e13ulfe7.png)

左边原图，右边先操作节点 $4$ 和节点 $3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3unfypjv.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/upp11bfj.png)

然后按层顺序操作，划在一个圆圈里的是已经合并在一起的节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/7q43khlb.png)

这是最终图，可以看到 $c_3$ 的确等于 $c_1$。


***
这个结论极其重要。接下来开始考虑如何进行大力计数。

我们设 $f_{i,j}$ 为已经考虑了前 $i$ 个点，已经填了的最后一层的有奇数个儿子的节点个数为 $j$，的方案数。这是怎么想到的呢，~~看题解想到的~~因为考虑到奇偶性在转移中很重要所以要记在状态里。

然后我们大力枚举下一层的节点个数为 $k$（$k \ge j$）。我们考虑算出来下一层这 $k$ 个点中，有几个 $rk$ 为奇数，几个为偶数。我们发现，在儿子为偶数的节点的儿子中，$rk$ 是一奇一偶分布，而儿子为奇数的节点的儿子中，$rk$ 为奇数的会比是偶数的多一个，那根据小学知识我们就好算了。

* 下一层中，$rk$ 为 ***奇数*** 的有 $\frac{k+j}{2}$，$rk$ 为 ***偶数*** 的有 $\frac{k-j}{2}$。

同时要求枚举的 $k$ 满足 $2|(k+j)$。

还是不好转移，我们再大力枚举下一层的与父亲符号相同的节点个数为 $p$（$0 \le p \le k$）。但是我们这是试图求出下一层会有多少儿子有奇数个儿子就如同试图在岩浆里游泳。我接下来设未知数解不等式，如果有巨佬能够一眼看出下一层儿子个数为奇数的节点的个数范围的话烦请跳过不等式过程并指正。这一步是为了求出下一层有奇数儿子的儿子个数，不妨令其为 $nxt$。假设知道了 $nxt$，我们有转移式：

* $f_{i,j} \times C_{n - i}^{k} \times C_{k}^{p} \rightarrow f_{i+k,nxt}$

不知道就设！设下一层符号相同的 $p$ 个点中，有 $q$ 个节点的儿子个数为奇数也就是占 $rk$ 奇数的位置，有 $p - q$ 个反之。注意，这里 $q$ 只是一个未知数，是用来运算的。然后我们表示出下一层儿子个数为奇数的儿子个数：$p + [\frac{k-j}{2} - (p-q)]$，前一项是奇 $rk$ 配上奇数的儿子个数，后一项是偶 $rk$ 中的奇数儿子个数，这样算正确是因为我们上面的结论：符号相同当且仅当$son_i$ 与 $rk_i$ 的奇偶性相同。化简后有 $nxt = 2 \times q - p + \frac{k-j}{2}$。然后考察 $q$ 的取值范围，首先有 $0 \le q \le p$ 的枚举限制，然后有 $q \le \frac{k+j}{2}$，显然不能超过 $rk$ 为奇数的点的个数，同理有 $p - q \le \frac{k-j}{2}$，求出四个不等式，然后带入到 $nxt = 2 \times q - p + \frac{k-j}{2}$，得到：

* $\max(\frac{k-j}{2} - p, p - \frac{k-j}{2}) \le nxt \le \min(\frac{k-j}{2} + p,k + \frac{k+j}{2}-p)$

然后我就头大了，因为可能的转移是一个区间，尽管注意到左边取最大就是 $|\frac{k-j}{2} - p|$，但是还是有 $nxt = |\frac{k-j}{2} - p| + 2 \times x$。然后我就尝试转移，结果发现答案炸掉了。最后在结合题解讨论和画图理解之后，才发现是算重复了，算重了 ***树的形态不同，点的系数相同*** 的贡献。

我们来看两张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7q43khlb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/7gw43mnd.png)

~~这图看起来确实和另一位老哥的题解里一样，但我确实是独立构造的。~~

这两张图都是最终图。左边的图第二层的有奇数个儿子的节点个数为零，而右图第二层的有奇数个儿子的节点个数为二，差异是第二层转移时枚举的 $nxt$ 不同，可以看到树的形态确实不同，但是两张图里每一层的正负个数其实是一样的。乍一看两张图中节点 $2$ 和 $3$ 的正负性都不同，但是我们转移时会乘上组合数 $C_{k}^{p}$，这样的话我们会钦定情况，而如果钦定相同的话这两张图就真等价了。完美算重。

咋办呢，这样的形态只能算一个，问题就是算哪一个。我们考虑最终答案，答案是 $f_{n,0}$，因为最下面一层没有儿子，儿子个数全为偶数，那么转移就尽量往 $0$ 去收束，也就是只转移最小的 $nxt$，也就是 $nxt = |\frac{k-j}{2} - p|$。为什么对，因为这样转移最终能转移到 $f_{n,0}$ 的一定转移到了 $f_{n,0}$，又因为我们每种不同形态相同系数的情况只转移一次，所以完美不重不漏。

最后考虑一下边界细节，发现 $n$ 个点都能作为根，所以有 $f_{1,0} = f_{1,1} = n$，根可以有奇数个儿子也可以有偶数个儿子。

综上，转移如下：

* 边界  $f_{1,0} = f_{1,1} = n$

* 转移枚举当前 $i$，$j$，$k$，$p$

* $f_{i,j} \times C_{n - i}^{k} \times C_{k}^{p} \rightarrow f_{i+k,nxt}$，其中 $nxt = |\frac{k-j}{2} - p|$

* 最终答案为 $f_{n,0}$

复杂度为 $O(n^4)$。而至于如何优化到 $O(n^3)$，那是后面代数推导保平安的事了，可以去看魏老师的题解最后几段。

在这里贴上我的弱弱的 $O(n^4)$ [代码](https://atcoder.jp/contests/agc022/submissions/49363251)。完结撒花喵。



---

## 作者：_Cheems (赞：1)

题意：记 $w=10^{100}$，有 $n$ 个点，第 $i$ 个在 $(w^i,0)$。你每次选择两个不同的两个点 $x,y$，将 $x$ 移到关于 $y$ 的对称点并移除 $y$。进行 $n-1$ 次后只剩一个点，求这个点坐标有几种可能？$n\le 50$。

先做一步转化，将点的横坐标视作 $w$ 进制数，由于 $w>2^{50}$ 所以不可能发生进位。所以我们完全可以**拆位考虑**。

建模，每次操作 $x,y$ 就让 $y\to x$，那么得到一棵内向树。点 $i$ 对答案产生的贡献即为 $2^{d_i}\times opt_i$。$d_i$ 即为 $i$ 到根的边数也就是深度，很好理解。$opt_i=\pm 1$，这是因为操作会导致变号。

$opt_i$ 不好直接描述，但是你发现它的**差分**是好处理的。具体来说，考虑一个点 $u$，那么它先会被 $son_u$ 个孩子取反 $son_u$ 次；然后在记它是父亲 $fa$ 第 $rk_u$ 个操作的，$fa$ 在操作它时符号为 $(-1)^{rk_u}$，此后 $u,fa$ 的符号同时改变。所以得到**结论**：$opt_u=opt_{fa}$ 当且仅当 $son_u$ 和 $rk_u$ 奇偶性相同。

大力计数！我们必然是一层一层添加点的，因为若每一层点的分布不同则最终方案必然不同。然后我们修改得到 $opt$ 的方式以便计数：首先直接继承父亲的 $opt$，然后让它取反 $rk_u$ 次，最后我们确定 $son_u$ 后让它再取反 $son_u$ 次。这是等价的。

根据这个框架设计状态，记 $f_{i,j}$ 为已经填了 $i$ 个点，最后一层有 $j$ 个点满足 $2\mid son_u$（就叫它们特殊点）。这个状态有点莫名其妙，没事看下去就好了。

接下来考虑转移。你发现很容易算重，不妨归纳地认为 $f_i$ 所有局面（就是到 $f_i$ 的所有转移路径得到的结果）不重不漏。也就是对重复局面选取一个代表元，接下来在转移的过程中要着重考虑代表元的选取使其能覆盖所有转移情况。

观察到一个重要性质：一个局面，若满足某一层的特殊点的 $opt$ 不相同，则这个局面可以通过调整特殊点的选取而得到相同的 $opt$ 分布。证明的话考虑同层两个 $opt$ 不同的特殊点 $x,y$，那么将 $x$ 最后一个儿子送给 $y$，可以验证 $opt$ 分布不变，并且现在 $x,y$ 的都不是特殊点。

这也就意味着我们只需要把同层特殊点 $opt$ 相同的状态扔进 $f$ 里。

终于可以转移了，对于 $f_{i,j}$ 里的一个局面，记 $o$ 为它最后一层特殊点的符号，枚举 $x,y$ 为下一层 $opt$ 与 $o$ 相同点有 $x$ 个、不同的有 $y$ 个。然后乘个组合数 ${{n-i}\choose {x+y}}{{x+y}\choose x}$ 表示选取当前层的点的编号、钦定点的 $opt$ 是否和 $o$ 相同。

我们先考虑“继承父亲、取反 $rk$ 次”这一步，那么会有 $j$ 个点分别连向每个特殊点，其符号为 $o$；接下来只能两个两个填，所以它们正负号数量相同，这和父亲 $opt$ 具体是啥没有关系。也就是说有 $\frac {x+y+j}2$ 个符号为 $o$ 的。上述讨论只考虑了数量是因为和点的编号无关，所以可以随意分配符号只要数量正确。

最后再考虑“确定 $son_u$”也就是分配特殊点。先考虑 $\frac {x+y+j}2 \le x$，你发现只能将所有 $o$ 分配给被钦定为 $o$ 的点，然后剩下 $x-\frac {x+y+j}2$ 个没被分配的点让他变成特殊点，其它的点不能是特殊点。原因是若给钦定为 $-o$ 的点分配一个 $o$，那么必然存在一个被钦定为 $o$ 的点没被分配到，必须把它们设为特殊点，此时就违反了上面的“重要性质”。$\frac {x+y+j}2 >x$ 同理。总的来说就是恰好设 $|x-\frac {x+y+j}2|$ 个特殊点，显然具体分配给谁都是等价的。

通过这种方式，使得局面不重不漏。最终转移为：

$$f_{i,j}\times {{n-i}\choose {x+y}}{{x+y}\choose x} \to f_{i+x+y,|\frac {x-y-j}2|}$$

主要限制为：$2\mid x+y+j$、$x+y>0$、$x+y\ge j$。

暴力 $O(n^4)$，足以通过。后面的优化部分不过是代数推导保平安，但也挺新奇的。

注意到这个组合数可拆为 $\frac {(n-i)!}{(n-i-x-y)!x!y!}$，令 $f_{i,j}$ 乘上 $(n-i)!$ 就得到了优美结构：

$$f_{i,j}\times {\frac 1{x!y!}}\to f_{i+x+y,|\frac {x-y-j}2|}$$

启发我们将 $x,y$ 分开转移。设中间状态 $g_{i,j}$，先转移 $f_{i,j}\to g_{i+x,x-j}$，然后再 $g_{i,j}\to f_{i+y,|\frac {j-y}2|}$。奇偶性限制在 $y$ 的转移时易判定，$x+y\ge j$ 等价于 $y\ge j-x$ 也易判定。$x+y>0$ 就只转移 $x>0$ 的，然后再直接转移补上 $x=0$ 的。

变成了 $O(n^3)$。具体细节可以看 Alex_Wei 大神的博客，写的非常详细。
#### 闲话
上次看这题还是~~上次~~ noip 前几天，然后对着若干不太严谨的题解一头雾水后放弃了。现在终于看懂了，故作一篇题解。这可能是初中写的最后一篇题解，唉。

今天是 22 号，广东中考就只剩一周多一点了，希望这篇题解能给我涨涨 RP。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define ADD(a, b) a = (a + b) % mod
#define abs(a) ((a) < 0 ? -(a) : (a))  
const int N = 55, mod = 1e9 + 7;
int n, jc[N], jcinv[N], f[N][N], g[N][N << 1];

inline int qstp(int a, int k) {int res = 1; for(; k; a = a * a % mod, k >>= 1) if(k & 1) res = res * a % mod; return res;}
signed main(){
    jc[0] = jcinv[0] = 1;
    for(int i = 1; i < N; ++i) jc[i] = jc[i - 1] * i % mod, jcinv[i] = qstp(jc[i], mod - 2);
    cin >> n;
    f[1][0] = f[1][1] = jc[n];
    for(int i = 1; i <= n; ++i){
		for(int j = -n; j <= n; ++j)
			for(int y = max(0ll, -j); y <= n - i; ++y) 
				if((j + y) % 2 == 0) ADD(f[i + y][abs(j - y) / 2], g[i][j + n] * jcinv[y] % mod);
        for(int j = 0; j <= i; ++j){
        	for(int x = 1; x <= n - i; ++x) ADD(g[i + x][x - j + n], f[i][j] * jcinv[x] % mod);
			for(int y = max(j, 1ll); y <= n - i; ++y)
				if((y + j) % 2 == 0) ADD(f[i + y][abs(j + y) / 2], f[i][j] * jcinv[y] % mod);
		}	
    }
	cout << f[n][0];
    return 0;
}
```

---


# [AGC046D] Secret Passage

## 题目描述

给定一个只包含 `0` 和 `1` 的字符串 $S$。请你求出通过以下操作任意次（包括 $0$ 次）后，可能得到的不同字符串的个数，并对 $998244353$ 取模。

- 移除 $S$ 的前两个字符，从中丢弃一个，将另一个插入到 $S$ 的任意位置。该操作仅当 $S$ 长度不少于 $2$ 时才能执行。

## 说明/提示

## 限制

- $1 \leq |S| \leq 300$
- $S$ 仅由 `0` 和 `1` 组成

## 样例解释 1

可以得到的字符串有：`0001`、`001`、`010`、`00`、`01`、`10`、`0`、`1`，共 $8$ 个。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
0001```

### 输出

```
8```

## 样例 #2

### 输入

```
110001```

### 输出

```
24```

## 样例 #3

### 输入

```
11101111011111000000000110000001111100011111000000001111111110000000111111111```

### 输出

```
697354558```

# 题解

## 作者：tzc_wk (赞：7)

思路挺自然的一道 agc。

首先发现删除完字符后的状态可以用一个三元组 $(i,j,k)$ 表示，其中 $i$ 表示删除完之后只剩 $[i+1,n]$ 的后缀，$j$ 表示可以在后面插入 $j$ 个 $0$，$k$ 表示可以在后面插入 $k$ 个 $1$，显然不同的三元组能够得到的串是不同的，而一组三元组可以得到的串的个数可以 DP 求解，具体来说，倒着 DP，同时为了防止算重，我们强制要求 $1$ 的后面只能添加 $0$，$0$ 的后面只能添加 $1$，这样转移是 $O(1)$ 的，具体实现见代码。

接下来考虑哪些三元组 $(i,j,k)$ 可以得到。考虑正着 DP，那么发现每次有两种选择：

- 从 $s_{i+1},s_{i+2}$ 中保留一个，删除一个
- 从保留的字符中拿出一个 $s_{i+1}\oplus 1$，插在开头，然后删除这个 $s_{i+1}\oplus 1$ 同时保留 $s_{i+1}$。

转移同样可以 $O(1)$，总复杂度 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD=998244353;
void add(int &x,int v){((x+=v)>=MOD)&&(x-=MOD);}
int n,ok[305][305][305],dp[305][305][305],res;
char s[305];
int main(){
	scanf("%s",s+1);n=strlen(s+1);ok[0][0][0]=1;
	for(int i=1;i<=n;i++)for(int j=n;~j;j--)for(int k=n;~k;k--){
		ok[i][j][k]|=ok[i-1][j][k];
		ok[i][j][k]|=ok[i][j+1][k];
		ok[i][j][k]|=ok[i][j][k+1];
		if(j&&i>=2&&(s[i]=='0'||s[i-1]=='0'))ok[i][j][k]|=ok[i-2][j-1][k];
		if(k&&i>=2&&(s[i]=='1'||s[i-1]=='1'))ok[i][j][k]|=ok[i-2][j][k-1];
		if(j&&s[i]=='0')ok[i][j][k]|=ok[i-1][j-1][k+1];
		if(k&&s[i]=='1')ok[i][j][k]|=ok[i-1][j+1][k-1];
	}
	dp[n][0][0]=1;
	for(int i=n;i;i--)for(int j=0;j<=n;j++)for(int k=0;k<=n;k++){
		add(dp[i-1][j][k],dp[i][j][k]);
		if(s[i]=='0')add(dp[i][j][k+1],dp[i][j][k]);
		if(s[i]=='1')add(dp[i][j+1][k],dp[i][j][k]);
	}
	for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)for(int k=0;k<=n;k++)
		if(ok[i][j][k])add(res,dp[i][j][k]);
	add(res,MOD-1);printf("%d\n",res);
	return 0;
}
```



---

## 作者：jun头吉吉 (赞：4)

## 题意
给定 $01$ 串 $S$，每次可以选择前两个字符，删除一个字符，还有一个字符插到任意位置。

求最后能得到多少种不同的字符串。

$1\le |S|\le 300$

## 题解
首先考虑每一次删除前两个的时候，保留的那个不要立刻插回去，而是当做一个自由的数。用一个三元组 $(i,j,k)$ 表示字符串是 $S[i:|S|]$，$j$ 个自由的 $0$ 和 $k$ 个自由的 $1$。

所以现在我们最多有 $\mathcal O(|S|^3)$ 个三元组，我们想知道这些东西可以表示出多少不同的字符串。这个东西看上去不看好做。考虑下面的另一个算法：

对于一个字符串 $T$，从前往后枚举字符，维护 $i,j,k$，假设当前字符为 $c$，如果 $c$ 和 $S[i-1]$ 相等，那么让 $i-1$，否则如果 $c=0$ 则 $j+1$，否则 $k+1$。每一个字符串这样扫一遍都能够得到唯一的 $(i,j,k)$。对于这 $\mathcal O(|S|^3)$ 种的 $(i,j,k)$，我们可以算出每一种能够得到这个三元组的 $T$ 的数量。

然后想一想不难发现，对于最后得到的三元组相同的 $T$，要么全部能被构造出来，要么全部不能被构造出来。然后对于一个 $(i,j,k)$ 能够被构造出来，就相当于在第一步中存在三元组 $(w,j+S[i:w-1]\text{中 0 的个数},k+S[i:w-1]\text{中 1 的个数})$。要枚举 $w$ 的原因是我们刚刚匹配的其实是整个串，但是实际上只剩下一个后缀，要用自由的 $0/1$ 来补上。

朴素实现复杂度是四次方的，但是直接过了。

优化到三次方不难。但是我是懒狗。

## 代码
```cpp
const int N=3e2+10;
int n;char s[N];int a[N],sum[N];
bool dp1[N][N][N];//dp1[i][j][k]表示剩下 s[i:] 有 j 个自由的 0 和 k 个自由的 1 是否可行
mint dp2[N][N][N];//dp2[i][j][k]表示从后往前撇匹配，能匹配上 s[i:]、j 个 0、k 个 1 的字符串数量
bool can[N][N][N];//can[i][j][k]表示dp2[i][j][k]能否被表示出来
signed main(){
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+(a[i]=s[i]-'0');
	dp1[1][0][0]=1;
	for(int i=1;i<=n+1;i++)for(int j=n;~j;j--)for(int k=n-j;~k;k--)if(dp1[i][j][k]){
		//考虑消一步有那些情况
		if(i<=n-1){
			if(a[i]==0||a[i+1]==0)dp1[i+2][j+1][k]=1;
			if(a[i]==1||a[i+1]==1)dp1[i+2][j][k+1]=1;
		}
		if(i<=n){
			if(a[i]==0&&(j||k))dp1[i+1][j][k]=1;
			if(a[i]==0&&k)dp1[i+1][j+1][k-1]=1;
			if(a[i]==1&&(j||k))dp1[i+1][j][k]=1;
			if(a[i]==1&&j)dp1[i+1][j-1][k+1]=1;
		}
		if(j>=2)dp1[i][j-1][k]=1;
		if(k>=2)dp1[i][j][k-1]=1;
		if(j&&k)dp1[i][j-1][k]=1,dp1[i][j][k-1]=1;
	}
	dp2[n+1][0][0]=1;
	for(int i=n+1;i;i--)for(int j=0;j<=n;j++)for(int k=0;j+k<=n;k++)if(dp2[i][j][k].x){
		if(a[i-1]==0)dp2[i][j][k+1]+=dp2[i][j][k];
		else dp2[i][j+1][k]+=dp2[i][j][k];
		dp2[i-1][j][k]+=dp2[i][j][k];
	}
	for(int i=1;i<=n+1;i++)
		for(int j=0;j<=n;j++)for(int k=0;j+k<=n;k++)if(dp1[i][j][k])
			for(int w=i;w>=1;w--){
				int cnt1=sum[i-1]-sum[w-1],cnt0=i-w-cnt1;
				int jj=j-cnt0,kk=k-cnt1;
				if(jj<0||kk<0)break;
				can[w][jj][kk]=1;
			}
	mint ans=0;
	for(int i=1;i<=n+1;i++)for(int j=0;j<=n;j++)for(int k=0;j+k<=n;k++)if(can[i][j][k])
		ans+=dp2[i][j][k];
	writeln(ans.x);
}
```

---

## 作者：xuantianhao (赞：2)

# [Secret Passage](https://www.luogu.com.cn/problem/AT_agc046_d)

稍微观察一下就能发现，任一时刻，我们剩下的东西必然是一段定死了的后缀，加上一些可以任意塞位置的 0 与 1。考虑任意一个由上述时刻生成的串，就会发现它与该后缀的最长公共子序列长度即为后缀长度，且还剩余一些 0 与 1。

于是考虑模拟最长公共子序列的过程。设 $g_{i,j,k}$ 表示长度为 $n-i+1$ 的后缀，所有与其 LCS 就是该后缀本身，且多余 $j$ 个 0、$k$ 个 1 的串数。为了不重复计数，我们强制 0 只能插在原后缀的 1 前面，1 只能插在原后缀的 0 前面。倒序转移即可。

并非所有 $(i,j,k)$ 都是合法的。我们还需要求出合法的状态。设 $f_{i,j,k}$ 表示其是否合法。则，一个状态合法，当且仅当其通过一步 LCS 匹配能够到达另一个合法状态，或者其通过删除再插入操作能够到达另一个合法状态。两种方案分别转移即可。

时间复杂度 $O(n^3)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
const int N=310; 
int n,res,g[N][N][N],h[N][N];
bool f[N][N][N];
char s[N];
signed main(){
    scanf("%s",s+1);
	n=strlen(s+1);
    f[0][0][0]=1;
    for(int i=1;i<=n;i++){
        for(int j=n;j>=0;j--){
			for(int k=n;k>=0;k--){
			    f[i][j][k]|=f[i-1][j][k];
			    if(s[i]=='0') f[i][j][k]|=f[i][j][k+1];
			    if(s[i]=='1') f[i][j][k]|=f[i][j+1][k];
			}
		}
        if(i>1){
			for(int j=0;j<=n;j++){
				for(int k=0;k<=n;k++){
					if((s[i-1]=='0'||s[i]=='0')&&j) f[i][j][k]|=f[i-2][j-1][k];
					if(s[i-1]=='0'&&s[i]=='0'&&j) f[i][j][k]|=f[i-1][j-1][k+1];
					if((s[i-1]=='1'||s[i]=='1')&&k) f[i][j][k]|=f[i-2][j][k-1];
					if(s[i-1]=='1'&&s[i]=='1'&&k) f[i][j][k]|=f[i-1][j+1][k-1];
				}
			}
		}
    }
    g[n][0][0]=1;
    for(int i=n;i;i--){
		for(int j=0;j<=n;j++){
			for(int k=0;k<=n;k++){
				(g[i-1][j][k]+=g[i][j][k])%=mod;
				if(s[i]=='0') (g[i][j][k+1]+=g[i][j][k])%=mod;
				if(s[i]=='1') (g[i][j+1][k]+=g[i][j][k])%=mod;
			}
		}
	}
    for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int k=0;k<=n;k++){
				if(f[i][j][k]) (res+=g[i][j][k])%=mod;
			}
		}
	}
    printf("%d",(res+mod-1)%mod);
    return 0;
}
```


---

## 作者：OtoriEmu (赞：2)

竟然是能自己做出来的题。

显然不能对在删除的数选一个插入到原字符串这个操作进行描述。我们考虑将插回的这个数放到一个集合中，之后如果要删到它就直接在集合内删掉它即可。

这样若干次操作之后，剩下的东西有原字符串的一个后缀，还有若干个集合内的 $0$ 和 $1$。用三元组 $(i,j,k)$ 描述：原字符串剩下 $s[i+1 \dots n]$ 这部分，集合内有 $j$ 个 $0$ 和 $k$ 个 $1$。三元组的个数显然是 $O(n^3)$ 的。

那么算出所有合法的三元组。具体的采用 DP，定义 $g_{i,j,k}$ 表示三元 $(i,j,k)$ 是否合法。转移可以删除两个集合内的数留下一个，删除一个集合内的数和 $a_{i+1}$ 留下一个，删除 $a_{i+1},a_{i+2}$ 留下一个。具体实现查看代码。

接下来要算有多少个可生成的字符串对应合法的三元组。注意到一个字符串可以对应上很多个三元组，我们需要使一个字符串对应的三元组唯一。可以采取这样的手段：从后往前放字符，当前字符串匹配上了 $s[i\dots n]$，需要多插入 $j$ 个 $0$，$k$ 个 $1$。分放 $0$ 还是 $1$ 讨论。这样就可以使每个字符串对应的三元组相同（$(i,j,k)$ 对应的三元组是 $(i-1,j,k)$）。

这个可以采取 DP 转移，$f_{i,j,k}$ 就表示当前用 $(i,j,k)$ 描述的字符串数量，分放什么字符讨论即可。

[评测记录](https://atcoder.jp/contests/agc046/submissions/39110901)。

---

## 作者：Otomachi_Una_ (赞：0)

我们考虑如果我们把前两个元素一个删掉一个随便插的这么一个“随便插”称之为塞入一个集合 $Q$ 当中。$Q$ 集合的元素是可以随便乱插的。那么每次操作是以下几种之一：

- 选 $S$ 最前面两个还存在的字符，一个丢掉，一个加入 $Q$；
- 把 $S$ 最前面元素丢进 $Q$，再删掉 $Q$ 的一个元素；
- 直接删掉 $Q$ 的一个元素。

我们最终操作完的状态都可以用三元组 $(x,y,z)$ 表示删到了 $S$ 的长度为 $x$ 的前缀，$Q$ 集合此时有 $y$ 个 $0$ 和 $z$ 个 $1$。可以简单 dp 算出每个三元组是否合法。

算出每个三元组时候合法之后，我们需要对每个 $(x,y,z)$ 计算有多少个长度为 $x+y+z$ 的 01 串 $T$ 满足：

- $S$ 的最后 $|S|-x$ 的后缀是 $T$ 的子序列而 $|S|-x+1$ 不是。
- $T$ 中和 $S$ 这个后缀不交的部分恰有 $y$ 个 $0$ 和 $z$ 个 $1$（即限制了 $T$ 中包含的 $01$ 数量）。

可以直接 dp，$g_{i,j,k}$ 表示串 $T$ 的数量满足长度为 $i$，有 $j$ 个 0 而 $T$ 的最长子序列是 $S$ 的后缀的长度是 $k$。转移线性。

---

## 作者：Felix72 (赞：0)

尝试使用这类题目的通用思路：考虑一个答案的构造方式。越靠后面的字符越不可能被改动，因此我们用这个最终串的子序列匹配原串的一个后缀，能匹配多少就匹配多少，剩下不能匹配的肯定就是前面插入的。

设 $f_{i, j, k}$ 表示有 $i$ 个字符是原串后缀，并且插入了 $j$ 个 $0$ 和 $k$ 个 $1$ 的方案数。$f$ 数组可以通过 DP 得出。接下来还需要判断对于一个 $(i, j, k)$，$f_{i, j, k}$ 能否成为答案，即 $s_{[1, i - 1]}$ 中能否产生出 $j$ 个自由的 $0$ 和 $k$ 个自由的 $1$。设 $g_{i, j, k} = 0/1$ 表示可行性，也可以通过 DP 得出。

$f$ 数组的转移：

```cpp
f[n + 1][0][0] = 1;
for(int i = n + 1; i >= 2; --i)
{
  for(int j = 0; j <= n; ++j)
  {
    for(int k = 0; k <= n; ++k)
    {
      for(int nx = 0; nx <= 1; ++nx)
      {
        if(nx == s[i - 1] - '0') Plus(f[i - 1][j][k], f[i][j][k]);
        else Plus(f[i][j + (nx == 0)][k + (nx == 1)], f[i][j][k]);
      }
    }
  }
}
```

$g$ 数组的转移：

```cpp
g[0][0][0] = true;
for(int i = 0; i < n; ++i)
{
  for(int j = n; j >= 0; --j)
    for(int k = n; k >= 0; --k)
      g[i][j][k] |= (g[i][j + 1][k] | g[i][j][k + 1]);
  for(int j = 0; j <= n; ++j)
  {
    for(int k = 0; k <= n; ++k)
    {
      if(!g[i][j][k]) continue;
      g[i + 1][j - 1 + (s[i + 1] == '0')][k + (s[i + 1] == '1')] = true;
      g[i + 1][j + (s[i + 1] == '0')][k - 1 + (s[i + 1] == '1')] = true;
      if(i + 2 <= n)
      {
        for(int nx = i + 1; nx <= i + 2; ++nx)
          g[i + 2][j + (s[nx] == '0')][k + (s[nx] == '1')] = true;
      }
    }
  }
}
```

---


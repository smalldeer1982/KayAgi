# [AGC048D] Pocky Game

## 题目描述

有 $N$ 个山峰横向排列。从左到右第 $i$ 个山峰上有 $A_i$ 个石子。

FirstLeft 君和 SecondRight 君进行一场游戏。FirstLeft 君先手，两人轮流进行回合。每一回合，玩家需进行如下操作：

- FirstLeft 君的回合：他必须从所有石子数不少于 $1$ 的山峰中，选择最左边的一个山峰，取走至少 $1$ 个石子。
- SecondRight 君的回合：他必须从所有石子数不少于 $1$ 的山峰中，选择最右边的一个山峰，取走至少 $1$ 个石子。

无法进行操作的玩家判负。请判断在双方都采取最优策略的情况下，谁会获胜。

对于每个输入文件，需要解答 $T$ 个测试用例。

## 说明/提示

### 数据范围

- $1 \leq T \leq 100$
- $1 \leq N \leq 100$
- $1 \leq A_i \leq 10^9$

### 样例解释 1

例如，在第 $3$ 个游戏中，可以有如下过程：

- FirstLeft 君从最左边的山峰取走 $2$ 个石子，山峰上的石子数变为 $(0,1,2)$。
- SecondRight 君从最右边的山峰取走 $1$ 个石子，山峰上的石子数变为 $(0,1,1)$。
- FirstLeft 君从中间的山峰取走 $1$ 个石子，山峰上的石子数变为 $(0,0,1)$。
- SecondRight 君从最右边的山峰取走 $1$ 个石子，山峰上的石子数变为 $(0,0,0)$。
- FirstLeft 君无法进行操作，判负。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
1
10
2
3 2
3
2 1 2```

### 输出

```
First
First
Second```

# 题解

## 作者：FZzzz (赞：13)

题目名里的 pocky game 就是指两个人从两端吃一根 pocky 饼干吃到中间亲上的那种游戏，嗑到了嗑到了。

鬼才出题人怎么这也要拿来出题，是不是在跟女朋友玩这的时候突然想到的。

------------
用序列 $a$ 表示一开始的石子数，$b$ 表示游戏进行到某时的石子数。

结论：只考虑非空的堆，在其他堆的石子数不变的情况下，第一堆石子越多越有利于先手。证明显然。

可以带来的推论是只会进行两种操作：拿一个和拿一堆。证明留给读者。

并且第一个结论启发我们求出第一堆最少需要多少石子才能使先手赢。考虑进行 dp，设：
- $f_{l,r}$ 为 $[l,r]$ 堆非空，$b_{l+1}$ 到 $b_r$ 等于 $a$ 中对应位置的值，轮到先手行动，$b_l$ 至少需要为多少才能使先手必胜。
- $g_{l,r}$ 为 $[l,r]$ 堆非空，$b_l$ 到 $b_{r-1}$ 等于 $a$ 中对应位置的值，轮到后手行动，$b_r$ 至少需要为多少才能使后手必胜。

考虑第 $l$ 和第 $r$ 堆其中之一被取空之前两个玩家的策略：
- 先手：如果此时 $b_r<g_{l+1,r}$，那么直接把第 $l$ 堆取空可以给后手留下一个必败的局面，所以直接取空；否则取空会给后手留下必胜的局面，那么只取一个。
- 后手：如果此时 $b_l<f_{l,r-1}$，那么直接把第 $r$ 堆取空可以给先手留下一个必败的局面，所以直接取空；否则取空会给先手留下必胜的局面，那么只取一个。

也就是说，过程一定形如：两人轮流每次取一个，直到某次先手行动时 $b_r<g_{l+1,r}$ 或某次后手行动时 $b_l<f_{l,r-1}$。先手必胜就是要第一种情况先发生，那么要求开始时 $b_r<g_{l+1,r}$ 或 $b_l-f_{l,r-1}>b_r-g_{l+1,r}$。故：
$$f_{l,r}=\begin{cases}1&a_r<g_{l+1,r}\\f_{l,r-1}-g_{l+1,r}+a_r+1&a_r\ge g_{l+1,r}\end{cases}$$
$g$ 也可以类似地转移。边界是 $f_{i,i}=g_{i,i}=1$，因为此时无论如何先手可以直接取完获胜。

至此我们完整解决了问题，时间复杂度 $O(n^2)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=100+5;
int n,a[maxn];
ll f[maxn][maxn],g[maxn][maxn];
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	int T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;i++) a[i]=read();
		for(int i=1;i<=n;i++) f[i][i]=g[i][i]=1;
		for(int i=n;i>0;i--) for(int j=i+1;j<=n;j++){
			f[i][j]=a[j]<g[i+1][j]?1:f[i][j-1]-g[i+1][j]+a[j]+1;
			g[i][j]=a[i]<f[i][j-1]?1:g[i+1][j]-f[i][j-1]+a[i]+1;
		}
		printf(a[1]>=f[1][n]?"First\n":"Second\n");
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：AC_love (赞：6)

听说这个游戏就是两个人同时吃一根 Pocky 最后亲到一起，很甜。于是我和室友用辣条试了一下，感觉一点也不甜，辣到嘴里喷火。

这道题和 Pocky Game 还真有点异曲同工之妙，不知道出题人是怎么脑洞大开想到这个题目标题的，乐。

说回正题：这道题并不算一个公平的博弈，因此 SG 函数是求不了的（或者你也可以认为它是公平的，但是 SG 确实很难求）。那么我们怎么办呢？

我们考虑：如果当前这一堆的石子个数很多，比其他堆加起来都多，那么一定是好的。我可以一直取这一堆石子，然后等另一面石子取完之后立刻把当前这堆石子取完，我就赢了。

那么每个人都会尽快找到一个满足当前这一堆石子比其他任何一堆加起来都多的一堆石子，然后轻松取得胜利。

因此任何一个人只会进行一种操作：拿一个或拿一堆。

那么此时大部分堆里的石子个数其实就没那么重要了，我们可以考虑区间 DP 来解决这个问题。

设 $f(l, r)$ 表示当前 $[a_{l + 1}, a_r]$ 区间石子个数维持不变时，$a_l$ 需要有多少个石子才能使左面的人必胜。

$g(l, r)$ 表示当前 $[a_{l}, a_{r - 1}]$ 区间石子个数维持不变时，$a_r$ 需要有多少个石子才能使右面的人必胜。

考虑如何转移。

如果先手取到了第 $l$ 堆，后手取到了第 $r$ 堆。

如果 $g(l + 1, r) > a_r$，那么先手直接把第 $l$ 堆取完，后手必败。

反之呢？先手一定会尽可能拖延时间，此时就看他和后手谁更能拖。如果他更能拖，必须当前这一堆满足石子数最少是 $a_r - g(l + 1, r) + 1 + f(l, r - 1)$。

后手显然也是同理，那么直接转移即可。

如何判断先手是否必胜？只要判断 $a_1$ 和 $f(1, n)$ 谁更大即可。

时间复杂度 $O(n^2)$，显然随便过。

---

## 作者：Llx2022 (赞：5)



**重要结论**：对于先手和后手，每次要么取 $1$ 个石子，要么取完这堆石子。

非严谨证明：若当前自己所在的堆中石子个数满足**大于**剩下所有还存在的石子个数，那么显然只要每次取 $1$ 个石子，等到对手取完剩下所有堆之后，自己取完这堆就能胜利。

若是**小于等于**，那么我们肯定不考虑占据该堆，而是考虑找到第一个满足**大于剩下所有还存在的石子数**的堆，显然这一定是最优策略。

那么通过这个结论我们考虑区间 dp。

设 $f_{l,r}$ 表示 $(l,r]$ 是原 $a$ 序列，当前先手在 $l$ 堆至少取多少石子能赢。

设 $g_{l,r}$ 表示 $[l,r)$ 是原 $a$ 序列，当前后手在 $r$ 堆至少取多少石子能赢。

显然，先手能赢肯定是满足 $f_{1,n} \le a_1$，反之后手赢。

那么我们考虑状态转移，其实就是考虑每一方在什么时候会赢，以及最优策略下该如何行动。

- 先手：考虑当前到了 $l$ 堆，那么意味着先把这一堆拎出来，然后比较。若 $g_{l+1,r}>a_r$，那么先手只要取完 $l$ 堆就可以获胜，反之就得考虑后手下一步的决策情况；若 $g_{l+1,r}\le a_r$ 那么先手此时的操作肯定是尽量拖住后手，也就是说先手当前这一步如果可以赢，那么最少的石子数，就是 $a_r-g_{l+1,r}+1+f_{l,r-1}$，因为我们肯定是先将的局面弄成不能必胜，然后自己考虑从自己得子局面继承过来。显然状态转移就已经满足了博弈论中的先后手都足够聪明，即最佳决策。

- 后手：同理，意味着当前后手可以操作的最有堆该如何取石子，若 $f_{l,r-1}>a_l$，那么后手只要取完那么就必胜了，剩下的思考过程同先手。

那么我们总结一下：

$$
\begin{cases}
f_{l,l}=1,l=l\\
f_{l,r}=1,g_{l+1,r}>a_r\\
f_{l,r}=a_r-g_{l+1,r}+1+f_{l,r-1},g_{l+1,r}\le a_r\\
\end{cases}
$$

$$
\begin{cases}
g_{l,l}=1,l=l\\
g_{l,r}=1,f_{l,r-1}>a_l\\
g_{l,r}=a_l-f_{l,r-1}+1+g_{l+1,r},f_{l,r-1}\le a_l\\
\end{cases}
$$

时间复杂度 $O(n^2)$。

## CODE

```cpp
#include<iostream>
using namespace std;
const int N=108;
int T,n;
int a[N];
long long f[N][N],g[N][N];//left:f;right:g;
int main(){
    cin>>T;
    while(T--){
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        for(int i=1;i<=n;i++){
            f[i][i]=g[i][i]=1;
        }
        for(int l=n;l>=1;l--){
            for(int r=l+1;r<=n;r++){
                if(f[l][r-1]>a[l]){
                    g[l][r]=1;
                }
                else{
                    g[l][r]=((a[l]-f[l][r-1]+1)+g[l+1][r]);
                }
                if(a[r]<g[l+1][r]){
                    f[l][r]=1;
                }
                else{
                    f[l][r]=((a[r]-g[l+1][r]+1)+f[l][r-1]);
                }
            }
        }
        if(f[1][n]<=a[1]){
            puts("First");
        }
        else{
            puts("Second");
        }
    }
    return 0;
}
```

---

## 作者：童年的小翼龙 (赞：4)

## 题意

给你 $n$ 堆石子，甲先手，乙后手。甲每次可以从最左边非空的石子堆中取任意个，乙每次可以从最右边非空的石子堆中取任意个，不能取的人输。问甲是否有必胜策略。

## 题解

先说明两点性质：

> 性质 $1$：当其它堆的石子固定的时候，当前（最左或最右）堆的石子越多，情况对于当前的先手越有利。

证明：因为可以取任意多个石子，所以对于当前先手来说，石子多不会使得情况变劣，且石子少能到达的所有状态石子多的时候也都能达到，石子多能到达的状态石子少的时候不一定能达到。

> 性质 $2$：当前的先手只可能取 $1$ 个或全取完。

证明：若只剩一堆，则取完当前石子堆，后手必败，一定会取完。因此，当不需要取完当前石子堆的时候，至少还剩下两堆石子，根据上述性质 $1$，令当前剩的石子越多越好，于是当前先手只取 $1$ 个。

有了这两条性质，我们就好办许多了，我们可以设立以下状态：

- 设 $f_{l,r}$ 代表 $[l+1,r]$ 堆中的石子个数**确定**为题目给出的石子个数，且轮到甲操作时，当前堆 $l$ **至少**需要多少才能使得**甲必胜**。
- 设 $g_{l,r}$ 代表 $[l,r-1]$ 堆中的狮子个数**确定**为题目给出的石子个数，且轮到乙操作时，当前堆 $r$ **至少**需要多少才能使得**乙必胜**。

我们考虑 $f$ 的转移：

- 当 $a_r<g_{l+1,r}$ 时，只要当前堆非空，取完即可使得**甲必胜**，于是 $f_{l,r}=1$。
- 当 $a_r\ge g_{l+1,r}$ 时，双方会轮流取一个（即甲选择 $a_l$ 减少 $1$，乙选择 $a_r$ 减少 $1$），直到 $a_{l}<f_{l,r-1}$（乙胜）或 $a_r<g_{l+1,r}$（甲胜）。因此，甲想要获胜，首先不能被拖入 $a_l=0$ 且 $a_r\ge g_{l+1,r}$ 的境地，并且还要保证在拖赢乙之前时刻满足 $a_l\ge f_{l,r-1}$（否则乙就会全取完而获胜），因此可得 $f_{l,r}=a_r-g_{l+1,r}+1+f_{l,r-1}$。

即：
$$
f_{l,r}=
\left\{
\begin{aligned}
&1 &&(a_r<g_{l+1,r})\\
&a_r-g_{l+1,r}+1+f_{l,r-1} &&(a_r\ge g_{l+1,r})
\end{aligned}
\right.
$$
同理可得：
$$
g_{l,r}=
\left\{
\begin{aligned}
&1 &&(a_l<f_{l,r-1})\\
&a_{l}-a_{l,r-1}+1+g_{l+1,r} &&(a_l\ge f_{l,r-1})\\
\end{aligned}
\right.
$$
于是 $O(n^2)$ 递推即可，代码简单。

```cpp
void main()
{
    int T; cin >> T;
    while(T--) {
        cin >> n;
        for (int i = 1; i <= n; i++){cin >> a[i];}
        for (int i = 1; i <= n; i++){f[i][i] = g[i][i] = 1;}
        for (int k = 2; k <= n; k++) {
            for (int i = 1 , j = i + k - 1; i <= n; i++ , j++) {
                if (a[j] < g[i+1][j]){f[i][j] = 1;}
                else{f[i][j] = a[j] - g[i+1][j] + 1 + f[i][j-1];}
                if (a[i] < f[i][j-1]){g[i][j] = 1;}
                else{g[i][j] = a[i] - f[i][j-1] + 1 + g[i+1][j];}
            }
        } cout << (f[1][n] <= a[1] ? "First\n" : "Second\n");
    }
}
```

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/AT_agc048_d)

**题目大意**

> 给定 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个，先手每次可以从第 $1$ 堆取 $[1,a_1]$ 个石子，后手每次可以从第 $n$ 堆取 $[1,a_n]$ 个石子，求谁能取完最后一个石子。
>
> 数据范围：$n\le 100$。

**思路分析**

观察发现答案具有一定的单调性：如果当前局面先手必胜，那么 $a_1\gets a_1+1$ 先手还是必胜，只要第一步多取一个即可。

同理后手必胜的局面令 $a_n\gets a_n+1$ 后手也必胜。

那么我们可以设 $f_{l,r}/g_{l,r}$ 表示 $a_{[l,r]}$ 作为游戏初态，其中 $a_l/a_r$ 至少要修改成多少才能使得先手 / 后手必胜。

手玩一下策略，如果 $(l,r]$ 后手必败，即 $a_r<g_{l+1,r}$，那么先手可以直接取完 $a_l$，即 $f_{l,r}=1$。

否则先手肯定要脱尽可能的时间让后手不断消磨 $a_r$ 直到后手不能胜利且自己能胜利。

那么想要后手输掉，需要至少 $a_r-g_{l+1,r}+1$ 轮才能让后手必胜，且这个过程内始终要保持自己不能输掉 $a_{[l,r)}$ 的游戏，否则后手直接删空 $a_r$ 就能赢，那么答案是 $f_{l,r-1}-g_{l+1,r}+a_r+1$。

$g_{l,r}$ 的计算也类似，区间 dp 一下即可。

时间复杂度 $\mathcal O(n^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=105;
long long a[MAXN],f[MAXN][MAXN],g[MAXN][MAXN];
//f[l,r]=f[l,r-1]+a[r]+1-g[l+1,r]
//g[l,r]=g[l+1,r]+a[l]+1-f[l,r-1]
void solve() {
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]),f[i][i]=g[i][i]=1;
	for(int q=2;q<=n;++q) for(int l=1,r=q;r<=n;++l,++r) {
		f[l][r]=a[r]<g[l+1][r]?1:f[l][r-1]+a[r]+1-g[l+1][r];
		g[l][r]=a[l]<f[l][r-1]?1:g[l+1][r]+a[l]+1-f[l][r-1];
	}
	puts(a[1]<f[1][n]?"Second":"First");
}
signed main() {
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：1)

首先我们容易发现每个人取石子的最优策略一定是取一个或者取全部。因为不这么取，轮到自己时可到达的状态一定是这两个操作的一个子集。

我们更容易发现如果 $(a)$ 数列是先手获胜，那么让 $a_1$ 变大先手仍然获胜，且如果 $a_1$ 的石子足够多先手总能胜利。当 $a_2\sim a_n$ 确定时，对 $a_1$ 有个界 $V$，$a_1<V$ 时后手获胜，反之先手获胜。

区间 dp，$f_{l,r}$ 表示区间 $[l,r]$，$a_{l+1}\sim a_r$ 没有改变，$a_l$ 至少是多少先手才能获胜。那么判断答案是容易的，只需要判断 $a_1$ 和 $f_{1,n}$ 的大小关系即可。单有 $f$ 难以转移，我们可以考虑同步定义一个 $g$ 表示后手。

$f,g$ 转移是类似的，以 $f$ 为例，考虑计算 $f_{l,r}$。如果先手一开始直接全取就赢了（即如果 $g_{l+1,r}<a_r$）那么取 $f_{l,r}=1$。否则，假设 $a'_l=M$，先手一开始肯定只取一个，然后这个过程肯定是形如：

- 先手后手轮流只取一个；
- 某个人发现自己全取直接获胜就全取了。

我们希望我们这里说的某个人是指先手。即我们希望先手取着取着发现自己直接赢了，而这个过程中后手还赢不了。

具体地，假设这时先手已经取了 $x$ 个，那么后手肯定也取了 $x$ 个。先手发现自己要赢了，那么肯定是 $a_r-x<g_{l+1,r}$。

后手发现自己还赢不了，肯定是 $M-x\geq f_{l,r-1}$。

上面不等式解得 $x\geq a_r-g_{l+1,r}+1$。下面不等式解的 $M\geq x+f_{l,r-1}\geq a_r+f_{l,r-1}-g_{l+1,r}+1$。

于是此时 $f_{l,r}=a_r+f_{l,r-1}-g_{l+1,r}+1$。

总结一下，转移方程是：
$$
f_{l,r}=\begin{cases}1&g_{l+1,r}<a_r\\a_r+f_{l,r-1}-g_{l+1,r}+1& g_{l+1,r}\geq a_r\end{cases}
$$
时间复杂度：$O(Tn^2)$。

---

## 作者：Mirage_Insane (赞：1)

一眼博弈论，但是并不是公平组合游戏，因此 SG 定理死掉了。于是干脆直接考虑动态规划。

在设计状态前，先考虑一个事情：双方只有可能有两种行为：**取一个石子**或**将这一堆石子全部取完**。

周知所众，~~信息学竞赛根本不需要严格的论证。~~ 来感性理解一下：假设先手当前这一堆石子比剩下所有的石子之和都要多，那先手一定每次只取一个，等后手把其他石子都取完后自己再一口气取完自己当前这一堆石子获得胜利。如果先手当前这一堆石子不算多，那他一定会直接一口气取完这一堆石子来让自己尽可能快地找到一堆较多的石子。证毕。

然后我们就有一种直观的感觉：当前的石子一定是越多越好。我们根据这个来设计状态。

定义 $f_{i, j}$ 为：当**先手在第 $i$ 堆，后手在第 $j$ 堆**且 $[i + 1, j]$ 中的石子都未被动过时，第 $i$ 堆石子至少需要多少个才能保证先手获胜。

类似地，定义 $g_{i, j}$ 为：当**先手在第 $i$ 堆，后手在第 $j$ 堆**且 $[i, j - 1]$ 中的石子都未被动过时，第 $j$ 堆石子至少需要多少个才能保证**刚开始时的后手，现在的先手**获胜。

怎么转移呢？

以 $f$ 数组为例：

1. 当 $g_{i + 1, j} > a_j$ 时，显然我们只需要一口气取完当前这一堆石子即可获得胜利。因此 $f_{i, j} = 1$。
2. 当 $g_{i + 1, j} \leq a_j$ 时，如果我们还是一口气取完那么就会导致后手必胜，因此我们必须跟后手耗，直到他将 $a_j$ 取到比 $g_{i + 1, j}$ 小才行。因为我们是先手，因此这一步就至少需要 $a_j - g_{i + 1, j} + 1$ 个石子才行。然而，我们还要保证自己时刻能够获得 $[i, j - 1]$ 的游戏的胜利，否则后手一口气取完就获胜了，所以还需要 $f_{i, j - 1}$ 个石子。

$g$ 的思路类似。

### Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define SF scanf
#define PF printf
#define int long long
int a[105], f[105][105], g[105][105];
signed main() {
	int T;
	SF("%lld", &T);
	while(T--) {
		int n;
		SF("%lld", &n);
		for(int i = 1; i <= n; i++) SF("%lld", &a[i]), f[i][i] = g[i][i] = 1;
		for(int len = 2; len <= n; len++) {
			for(int i = 1; i + len - 1 <= n; i++) {
				int j = i + len - 1;
				if(g[i + 1][j] > a[j]) f[i][j] = 1;
				else f[i][j] = a[j] - g[i + 1][j] + 1 + f[i][j - 1];
				if(f[i][j - 1] > a[i]) g[i][j] = 1;
				else g[i][j] = a[i] - f[i][j - 1] + 1 + g[i + 1][j];
			}
		}
		if(a[1] >= f[1][n]) PF("First\n");
		else PF("Second\n");
	}
	return 0;
}
```

---

## 作者：_Cheems (赞：0)

省选前写题解增加 RP！

题意：有石子堆 $a_1\dots a_n$，每次先手在最左边堆取至少 $1$ 个，后手则在最右边堆取。问谁必胜。$n\le 10^2$。

莫名想到 [P2599](https://www.luogu.com.cn/problem/P2599)，那么不难得到状态定义，$f_{i,j}$ 表示初始局面下 $a_i$ 一开始至少是多少先手才能必胜，这是因为具有单调性，$a_i$ 必胜则 $a_i+1$ 也必胜。同理 $g_{i,j}$ 则是对于后手定义。

以 $f$ 为例，$g$ 与之对称。转移分类讨论：

* $g_{i+1,j}>a_j$：取光 $a_i$ 即可获胜，$f_{i,j}=1$。
* $g_{i+1,j}\le a_j$：先手想获胜，必须尽量消耗 $a_j$ 使其小于必胜分界线，所以肯定每次取一个慢慢耗最优。但是后手除了只取一个尽量维持在必胜态以外，还可以直接取光 $a_j$。所以还得保证 $a_i\ge f_{i,j-1}$。$f_{i,j}=f_{i,j-1}+a_j-g_{i+1,j}+1$。

$O(n^2)$。

---

## 作者：Wu_Qi_Tengteng (赞：0)

我们发现如果想要直接表示出一个局面状态数过多，但是我们并不一定要知道每一种情况。所以可以每次表示出一个临界状态，也就是一边刚好拿完轮到另一边拿的时候的状态。

继续观察，我们可以发现一个比较显然的性质，那么就是第一堆石子越多显然越有利于先手。变多可能可以使本不能获胜的局面先手获胜，并且怎么也不会使本能获胜的局面先手不获胜。而且我们还发现，如果这一堆石子变少还能获胜，显然在当前状态他就可以获胜。

由于以上两点，所以我们可以设出两个 $dp$ 状态：

$f_{l,r}$ 表示 $[l+1,r]$ 与原序列相同，现在轮到先手操作，$a_l$ 至少要为多少才能使先手获胜。

$g_{l,r}$ 表示 $[l,r-1]$ 与原序列相同，现在轮到后手操作，$a_r$ 至少要为多少才能使后手获胜。

我们只考虑对于 $f_{l,r}$ 转移：
我们考虑 $[l,r]$ 的后继状态是什么，有两种情况，先手先拿完进入 $[l+1,r]$ ,要么是后手先拿完进入 $[l,r-1]$ 。

如果后手先拿完，为了保证我先手还是获胜，那么显然当时的 $a_l\ge f_{l,r-1}$ 。那么我们考虑后手最多在哪一个时候拿完，肯定最多是在双方都拿了 $a_r$ 的时候。

所以按理来说 $f_{l,r}=a_r+f_{l,r-1}$ 。

但是注意，我们现在是先手，主动权在我们手上，我们不会等着后手一直拿拿了 $a_r$ 个。只要当后手不能够在下一个状态中取胜的时候我们就可以拿完这一堆。

当后手不能够在下一个状态中取胜的时候就是当 $a_r<g_{l+1,r}$ 的时候。后手肯定要尽量避免这样的情况发生，那么他会一直跟你拖，就是每次只取一个。那么如果要在这种情况下获胜的话，先手肯定也每次只取一个。也就是说后手最多拖 $a_{r}-g_{l+1,r}+1$ 次。

所以就有转移：
$$
f_{l,r}=\begin{cases}
  & \text 1\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a_r<g_{l+1,r} \\
  & \text f_{l,r-1}+a_r-g_{l+1,r}+1\ a_r\ge g_{l+1,r}
\end{cases}
$$
$g$ 同理。 

时间复杂度 $\mathcal{O}(Tn^2)$ 。
```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();} 
	return x*f;
}
const int N=110;
int T;
int n,a[N];
int f[N][N],g[N][N];
signed main(){
	T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;i++)a[i]=read();
		if(n==1){
			printf("First\n");
			continue;
		}
		memset(f,0,sizeof f);
		memset(g,0,sizeof g);
		for(int i=1;i<=n;i++)f[i][i]=g[i][i]=1;	
		for(int len=2;len<=n;len++){
			for(int l=1;l+len-1<=n;l++){
				int r=l+len-1;
				f[l][r]=a[r]<g[l+1][r]?1:f[l][r-1]+a[r]-g[l+1][r]+1;
				g[l][r]=a[l]<f[l][r-1]?1:g[l+1][r]+a[l]-f[l][r-1]+1;
			}
		}
		if(a[1]>=f[1][n])printf("First\n");
		else printf("Second\n");
	}
	return 0;
} 
```

---

## 作者：Unnamed114514 (赞：0)

注意到有单调性：如果 $a_1=a_1$ 的时候先手必胜，那么 $a_1=a_1+1$ 的时候先手也一定必胜，因为第一次多取一个会达到同样的局面。

于是可以考虑求出 $f_{l,r}$ 表示 $a_l$ 至少为多少才能让先手在 $[l,r]$ 必胜，同理定义 $g_{l,r}$ 表示 $a_r$ 至少为多少才能在 $[l,r]$ 必胜。

策略是显然的：

- 如果 $a_r<g_{l+1,r}$，那么直接把 $a_l$ 取完就行了，$f_{l,r}\gets1$；否则先手一定要尽量延后这一堆的取完时间，每次只取一个，即 $f_{l,r}\gets a_r-g_{l+1,r}+f_{l,r-1}$。

- g 的转移是同理的，如果 $a_l<f_{l,r-1}$，$g_{l,r}\gets1$；否则 $g_{l,r}\gets a_l-f_{l,r-1}+1+g_{l+1,r}$。

初始化 $f_{l,l}=g_{l,l}=1$，最后只需要判断 $a_1$ 和 $f_{1,n}$ 的大小关系即可。

---


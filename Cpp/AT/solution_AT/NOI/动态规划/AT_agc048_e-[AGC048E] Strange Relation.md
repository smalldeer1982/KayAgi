# [AGC048E] Strange Relation

## 题目描述

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\cdots,A_N)$ 和一个整数 $T$，定义 $f(A,T)$ 如下：

- $f(A,T)$ 是满足以下所有条件的整数序列 $x$ 中，字典序最大的一个。在本题的约束下，可以证明一定存在满足条件的序列，且其个数是有限的。因此，$f(A,T)$ 一定有定义。
  
  - $x$ 是长度为 $N$ 的非负整数序列。
  - 对于每个 $i$（$1 \leq i \leq N$），定义 $y_i$ 为满足 $j < i$ 且 $A_j + T \times x_j < A_i + T \times x_i$ 的 $j$ 的个数。此时，要求 $y_i = x_i$。

例如，若 $A=(6,5,1),T=3$，则满足条件的序列 $x$ 有 $(0,0,0),(0,0,2),(0,1,0)$。因此，$f(A,T)$ 的值为这三者中字典序最大的 $(0,1,0)$。

现在，すぬけくん有 $N$ 个整数序列 $B_1,B_2,\cdots,B_N$ 和一个整数 $T$。每个 $B_i$（$1 \leq i \leq N$）都是长度为 $K$ 的整数序列。

接下来，すぬけくん要构造一个长度为 $N$ 的整数序列 $A$，并计算 $f(A,T)$。$A_i$ 的值可以从 $B_{i,1},B_{i,2},\cdots,B_{i,K}$ 中任选一个。这里，即使 $B_i$ 中有重复的值，也要将它们视为不同的选择。换句话说，$A$ 的构造方式共有 $K^N$ 种。

对于每个 $i$（$1 \leq i \leq N$），请解决以下问题：

- 对所有 $K^N$ 种 $A$，计算 $f(A,T)$，并记录其第 $i$ 项的值。请输出这些值的总和，对 $10^9+7$ 取模。

## 说明/提示

### 数据范围

- $1 \leq N \leq 50$
- $1 \leq K \leq 50$
- $1 \leq T \leq 10^7$
- $1 \leq B_{i,j} \leq 10^9$

### 样例解释 1

- 当 $A=(1,1)$ 时：$f(A,T)=(0,1)$
- 当 $A=(1,2)$ 时：$f(A,T)=(0,1)$
- 当 $A=(2,1)$ 时：$f(A,T)=(0,0)$
- 当 $A=(2,2)$ 时：$f(A,T)=(0,1)$

因此，当 $i=1$ 时答案为 $0+0+0+0=0$，当 $i=2$ 时答案为 $1+1+0+1=3$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2 2 1
1 2
1 2```

### 输出

```
0
3```

## 样例 #2

### 输入

```
3 2 3
6 2
5 3
1 4```

### 输出

```
0
6
13```

## 样例 #3

### 输入

```
10 15 45
129 82 26 185 217 258 22 192 24 117 167 255 91 180 203
171 73 168 26 208 169 115 164 121 214 154 196 172 66 230
185 178 241 220 243 143 111 124 10 62 56 117 254 43 81
201 74 213 163 204 35 44 203 207 73 218 60 243 51 250
229 117 212 245 112 152 206 96 266 165 105 94 231 41 27
261 201 258 111 100 72 239 31 199 203 226 151 72 268 44
94 19 47 243 133 174 141 82 190 62 175 256 126 123 210
186 64 73 82 68 183 261 120 265 212 18 24 36 152 92
205 101 186 91 172 153 91 242 141 97 247 193 45 245 66
225 97 162 213 61 219 184 195 80 203 79 72 269 258 199```

### 输出

```
0
248044096
333666695
536381826
8787512
11659012
661959013
166067001
529828166
526544756```

# 题解

## 作者：UnyieldingTrilobite (赞：4)

首先点进题目，还没给 $f$ 完整定义呢，啪的一下就看见一个巨大的

> It can be proved that there always are sequences that satisfy the conditions and that the number of those sequences is finite.

而这样的序列个数有限是显然的，值域摆在那撑死也就 $n!$ 种，我们不妨先行考虑一下题目告诉我们的一定有序列满足条件这个事情怎么证明。我们发现这个约束相当逆天，站在整体的角度难以调控。那我们只能换个视角，试试看能不能证明这样一个性质：对于任意合法的 $x_1,x_2,\cdots,x_{i-1}$，一定存在一个合法的 $x_i$。

我们考虑维护一个变量 $p$ 在自然数集上从零开始扫，并同时维护一个变量 $q$ 表示 $-p+\sum_{j=1}^{i-1}[A_j+T\times x_j\lt A_i+T\times p]$。容易发现，当且仅当 $q=0$ 的时候，赋 $x_i$ 为 $p$ 是合法的。而我们考虑，在 $p=0$ 时，$q$ 非负；而在 $p=i-1$ 时，$q$ 非正。观察到当 $p$ 增大一的时候，$q$ 可能一并增大很多，但减少只有至多一。如此，$q$ 不可能一步从正数跳到负数，一定存在一个 $p$ 使 $q=0$，此时赋 $x_i=p$ 即可。

以上的性质启示我们，其实字典序这个东西是可以贪心做的。我们先来观察一下对于给定的 $A$ 和 $T$，$f(A,T)$ 有没有什么奇奇怪怪的性质。首先最容易发现的就是 $x_1=0$。随后我们观察上面证明的过程，$x_i=p$ 是最大的，代表着把 $p$ 增大一的时候维护的 $q$ 值减少恰好一（否则 $[p+1,n-1]$ 的区间上依然可以跑上面那个证明），而这也说明了 $\sum_{j=1}^{i-1}[A_j+T\times x_j\lt A_i+T\times p]$ 此时没有任何变化。方便起见我们记 $z_i=A_i+T\times x_i$，那么也就是说不存在 $1\le j\le i-1$ 使得 $z_j-T\lt z_i\le z_j$。作为一个统一的约数，注意到 $x_1=0$，换而言之 $z_1=A_1$，那么我们可以得到 $A_1-T\lt z_i\le A_1$ 对一切 $1\lt i\le n$ 都一定不成立。

接下来我们可以干一件比较震撼的事情：删掉 $x_1$，然后把所有 $z$ 值大于 $A_1$ 的 $x$ 减掉一，研究一下会发生什么。考虑 $z$ 值之间的偏序关系。对于两个都没减或者两个都减了的 $z$，显然没有任何变化；对于恰有一个减了的 $z$，显然是减了的那个 $z$ 原来比较大，同时注意到这个 $z$ 恰好减了 $T$，而且它本来在 $A_1$ 之上，那现在依然在 $A_1-T$ 之上，而没减的那个 $z$ 本来在 $A_1$ 之下，**那由我们在上一段推出的结论可以得知它一定在 $A_1-T$ 之下**，换而言之，还是减了的 $z$ 大。同时，变化前后的序列的字典序最大性是彼此可以互推的。

如此一来，我们可以敏锐地观察到，变化后的 $x$ 即为 $f(A_{[2,n]},T)$。这为我们启示了一个比较震撼的事实，在已知 $A_1$ 的情况下，由 $f(A_{[2,n]},T)$ 推到 $f(A,T)$ 的变化实际上是相当简单的，而且每一项之间相当独立。举个例子，如果我们现在已知了 $A_1,A_n$ 和 $f(A_{[2,n]},T)$ 的最后一项，$f(A,T)$ 的最后一项是相当好求的。那么据此，我们就可以设计 DP 来统计 $f(A_{[i,n]},T)$ 的给定项是 x 的方案数了。DP 的步骤相当简单，按递推关系直接刷表即可，在此不再赘述。

```cpp
#include <atcoder/all>
using namespace std;
typedef atcoder::modint1000000007 mint;
constexpr int N = 59;
int n, k, t;
vector<int> b[N];
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> k >> t;
  for (int i = 1; i <= n; ++i) {
    b[i].resize(k);
    for (int& x : b[i]) cin >> x;
  }
  for (int i = 1; i <= n; ++i) {
    mint ans = 0;
    for (int a : b[i]) {
      mint f[N][N];
      f[i][0] = mint(k).pow(n - i);
      for (int p = i - 1; p; --p)
        for (int q = 0; q <= n; ++q)
          for (int a1 : b[p]) {
            int nq = q + (a1 < a + (q + 1) * t);
            f[p][nq] += f[p + 1][q];
          }
      for (int q = 0; q <= n; ++q) ans += f[1][q] * q;
    }
    cout << ans.val() << '\n';
  }
  return cout << flush, 0;
}
```

---

写在最后：

这题的官方题解写得什么玩意，几个重要结论基本一个没证……

---

## 作者：NobleNumbat (赞：2)

不难注意到从前往后填，无论前面怎么填都总有一个 $v_i$ 满足条件（类似零点存在定理），所以可以贪心填。然而这并没什么用。

考虑从 $a_i+(i-1)T$ 最大的 $i$ 开始填。前面无论如何填，这一位总是可以填到 $i-1$。后面的点也不可能从这一位产生贡献。所以我们可以把这一位删掉，转化成一个长度为 $n-1$ 的子问题。

但是删掉一个点后它后面的点的标号会改变。考虑标号只和计算最大的 $a_i+(i-1)T$ 有关，那我就把删掉的点后面的 $a_i$ 减掉 $T$，效果相同。

考虑一个点的答案是多少。注意到我们一个点的答案其实就是在这个点前面、删的比它晚的点的数量。同时一个点在某个时刻的 $a_i$ 只和这时它前面删掉的点的数量有关。

两个点的大小关系只和它们之间被删掉的点的数量有关。所以，$i$ 和 $i-1$ 被删掉的顺序只和他们原本的 $a_i+(i-1)T$ 有关。这个性质支持我们从后往前 dp。

那我们先枚举一个点，再枚举一个取值。从 $i-1$ 往前做，记 $f_{k,l}$ 表示做到了 $k$，删掉了 $l$ 个点的方案数。转移时枚举取值，判断在 $k,i$ 之间已经删掉了 $l$ 个点时，$k$ 能不能比 $i$ 先删掉即可。

代码很简单。

```cpp
using mint = atcoder::modint1000000007;
int n, m, t;
int a[51][51];
mint f[51][51], ans[51];
signed main() {
    cin >> n >> m >> t;
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j];
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {
        memset(f, 0, sizeof(f));
        f[i][0] = 1;
        for (int k = i - 1; k > 0; k--) for (int l = 0; l < i - k; l++) for (int p = 1; p <= m; p++) {
            if (a[k][p] + (k - 1) * t >= a[i][j] + (i - 1 - l) * t) f[k][l + 1] += f[k + 1][l];
            else f[k][l] += f[k + 1][l];
        }
        for (int k = 0; k < i; k++) ans[i] += (i - k - 1) * f[1][k];
    }
    for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) ans[i] *= m;
    for (int i = 1; i <= n; i++) cout << ans[i].val() << endl;
    return 0;
}
```

---

## 作者：275307894a (赞：2)

官方题解可以教你怎么比较自然（？）地想到最后一步。

但是如果你~~事先知道做法~~足够厉害，你可以尝试一下倒着构造这个序列。

考虑每次在序列头上插入一个数，对后面造成的影响。因为后面已经确定了大小关系，而插入一个数又只是对一段后缀 $+T$，所以不会改变相对顺序。

而最终我们需要最大化 $x_i$ 的字典序，而我们加入一个 $x$ 的时候，可以对所有 $A_i+x_iT>x-T$ 的 $x_i$ 都加上 $1$，并且后面加的越多，前面就加的越多，因此加入一个数之后对序列的变化是唯一的。

于是就可以设 $dp_{i,j,k,p}$ 表示从后往前到了第 $i$ 个数，在第 $j$ 个位置插入的是序列 $B_j$ 的第 $k$ 个数，已经加了 $p$ 次的方案数，转移是平凡的，容易 two-pointers 优化到 $O(n^2k^2)$。

[submission](https://atcoder.jp/contests/agc048/submissions/52462354)

---

## 作者：Otomachi_Una_ (赞：0)

考虑如何快速计算 $f(A,T)$。

首先题目要求我们字典序最大。而这个条件看着就很奇怪，我们没有什么很好的转化。

那么我们可以猜一下这个字典序最大其实就是每一位直接根据前面贪心取最大，我们不需要顾虑对后面的影响，因为无论如何取 $x_1,x_2,\dots,x_{i-1}$，$x_i$ 总是有解的。

这是因为我们考虑定义 $f_i(x)=x-\sum_{j=1}^{i-1}[a_j+Tx_j<a_i+Tx]$。那么 $f_i(0)\leq 0$、$f_i(i-1)\geq 0$、$f_i(x)-f_i(x-1)\geq -1$。这表明 $f_i(x)$ 一定在自然数上有零点。我们证明了这一个结论。

好吧，实际上上面都是没啥用的结论。我们对一下脑电波，如果我们每次取出 $a_i+x(i-1)$ 最大的一个 $i$（如果相同取 $i$ 小的），那么 $x_i$ 必然是 $i-1$。而 $i$ 后面的元素必然利用不到 $i$，那么其实我们就可以直接把 $i$ 这个位置删掉。需要注意的是删掉 $i$ 之后，$i$ 之后的位置要往前移。

我们注意到我们想要计算某个数的 $x_i$，实际上我们只要从后往前扫，判断每个数是否会在其删除前还保留，具体地，是这么一段伪算法：

- 计算 $x_i$：令 $y=0$；
- 对每个 $j=i-1,i-2,\dots,1$，$y\leftarrow y+[a_j\geq a_i+(y+1)T]$。

我们对这个算法直接 dp 即可。

---


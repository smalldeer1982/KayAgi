# [AGC052F] Tree Vertices XOR

## 题目描述

有一棵包含 $N$ 个顶点的树，顶点编号为从 $1$ 到 $N$。每条边将两个顶点相连，其中第 $i$ 条边连接顶点 $u_i$ 和 $v_i$。

最开始，所有顶点上都写着数字 $1$。

你可以进行以下操作任意次（也可以一次都不进行）：

- 从树中选择一个顶点 $v$。将与 $v$ 相邻的所有顶点上的数值做 **XOR** 运算，得到结果 $X$。然后，将顶点 $v$ 上的数值 $a_v$ 替换为 $(a_v\ \mathrm{XOR}\ X)$。

你需要计算通过这些操作可以得到多少种不同的树形态。由于结果可能非常大，请输出它对 $998244353$ 取模的值。

在这里，两个树形态被认为不同，如果存在至少一个顶点 $v$ 使得这两个形态在该顶点上的数字不同。

## 说明/提示

- $ 3 \le N \le 2 \cdot 10^5 $
- $ 1 \le u_i, v_i \le N $
- $ u_i \neq v_i $
- 输入表示的图是一棵树。

### 样例解释 1

假设在顶点 $1, 2, 3, 4$ 上分别写着 $a, b, c, d$。可能的不同形态包括 $1111$、$1110$、$1100$、$1000$、$0111$、$0110$、$0100$、$0011$、$0010$、$0001$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4
1 2
2 3
3 4```

### 输出

```
10```

## 样例 #2

### 输入

```
5
1 2
1 3
1 4
1 5```

### 输出

```
24```

## 样例 #3

### 输入

```
6
1 3
2 3
3 4
4 5
4 6```

### 输出

```
40```

## 样例 #4

### 输入

```
9
1 2
2 3
1 4
4 5
1 6
6 7
7 8
8 9```

### 输出

```
255```

# 题解

## 作者：jun头吉吉 (赞：3)

## 题意
给定一棵 $N$ 个点的树，每个点上初始都是 $1$，每次可以选择一个点使得这个点的值异或上周围所有点的值。

问最多可以得到多少种不同状态。对 $998244353$ 取模。

$3\le N\le2\times10^5$。

## 题解
首先过程可逆没有任何问题。所以所有合法状态互相可达。

然后我们强制只能选择周围有奇数个 $1$ 的点翻转。

发现如果周围有 $s$ 个 $1$，那么翻转后连通块数量的变化是 $\pm(s-1)$，所以奇偶性不变。

所以我们得出两个必要条件：

- 连通块数量为奇数
- 存在一个点周围有奇数个点

接下来我们证明，在**存在一个点 $\deg\ge 3$ 且删去后存在 $\ge 2$ 个 $\ge 2$ 的连通块**的情况下，也是充分的。如果不想看dirty work可以直接跳到QED。

> **引理 $1.$** 若 $a_i=1$ 的导出子图非空且只有一个连通块，那么 $\{a_i\}$ 合法

这个每次扩展一个点就行了吧。

> **引理 $2.$** 将 $a_i=1$ 的所有连通块每个只保留一个点不影响合法性

这个也比较显然，就一个点可以用引理1的方法扩展到一个连通块。

因此我们现在只考虑 **不存在 $(x,y)\in E$，使得 $a_x=a_y=1$** 的图。我们有两种操作：

- **移动操作**：$a_x=1$ 且 $(x,y)\in E$，$y$ 周围没有其他 $1$，那么可以交换 $a_x,a_y$
- **合并操作**：$a_x=0$ 且周围有 $\ge 3$ 且为奇数个 $1$，那么可以周围全赋值为 $0$，$x$ 赋值为 $1$。

两者可以合并为 $x$ 周围有奇数个 $1$，可以把周围赋值为 $0$ 且 $x$ 赋值为 $1$。统称为**操作**。

我们希望当有 $>1$ 个 $1$ 时一定可以执行合并操作。继续证明。

> **引理 $3.$** 若一个点可以操作，若干次后可以改变 $a_{rt}$ 的状态

证明引理

1. $a_{rt}=0$
   1. 周围有奇数个 $1$，直接操作
   2. 否则递归进入可以操作的子树
2. $a_{rt}=1$，周围都是 $0$
   1. 其中一个儿子的儿子有偶数个 $1$，执行操作
   2. 否则可以操作的点在某个子树内部，归纳修改，再执行操作

> **引理 $4.$** 若一棵树不能操作，且 $a_{rt}=0$，存在至少一个 $1$，那么给 $rt$ 连一个 $1$ 的点就可以执行合并操作

证明引理

1. $rt$ 所有儿子均为 $0$，移动 $1$ 到 $rt$，归纳
2. 否则 $rt$ 有偶数个儿子为 $1$，$rt$ 现在可以合并了

接下来就可以证明最初的结论了。选择一个满足 $\deg\ge 3$ 且删去后有至少两个 $\ge 2$ 的连通块的 $rt$。如果 $a_{rt}=1$ 就用引理 $3$ 翻转 $rt$。现在 $a_{rt}=0$，有 $>1$ 个奇数个 $1$，至少有一个点可以操作，我们希望进行合并操作。先对 $rt$ 为 $1$ 的儿子分类讨论：

1. 为偶数。任选一个可以操作的子树，翻转一个儿子的值，变为奇数

2. 为奇数且 $\ge 3$，对 $rt$ 执行合并操作

3. 只有一个儿子为 $1$，继续对不为 $1$ 的儿子分类讨论：

   1. 存在两个可以操作，翻转之后合并

   2. 有一棵子树不全为 $0$ 且无法操作，把 $1$ 移动到 $rt$ 然后用引理 $4$ 合并

   3. 否则至多一个儿子可操作，其余全是 $0$。因为有 $\ge 2$ 个 $\ge 2$ 的子树，我们可以把 $1$ 移到一个 $\ge 2$ 的全 $0$ 子树。

      若满足前两点，就可以合并了。否则其它子树最多有一个可以操作并且其他全为 $0$。

      假如没有可以操作的子树，那么就只有一个 $1$ ，已经结束了。

      否则有可操作子树，通过引理 $3$ 使得子树的根为 $1$，原来的 $1$ 下移一步，新的 $1$ 移到一棵全为 $0$ 的子树，原来的 $1$ 所在的子树肯定是可以操作的，再分类讨论：

      1. 原来的 $1$ 和新的 $1$ 出来的子树都能操作，那么就是上面的情况 $1$。
      2. 新的 $1$ 出来的子树现在不全为 $0$ 且无法操作，那么就是上面的情况 $2$。
      3. 否则新的 $1$ 出来的子树也全部为 $0$，现在只有两个 $1$，和有奇数个 $1$ 矛盾。

以上，我们证明了一定可以不断合并使得变成一个 $1$，从而证明了结论的正确性。

QED.

那么对于符合这种条件的树就可以计算了。设 $f_{u,0/1,0/1,0/1,0/1}$ 表示 $u$ 的子树，$a_u$，$\oplus_{v\in son_u}a_v$，当前连通块个数的奇偶性，除了 $u$ 是否存在可以操作的点。合并手玩一下即可。复杂度 $\mathcal O(N)$。

如果不满足上面的情况，树的结构是简单的，是一条链，两个端点连出若干片叶子。不妨设链的点数为 $l$，分别连出 $x,y$ 片叶子（$x,y\ge1$）。

对于这种情况，如果 $\{a_i\}$ 可以变成全 $1$，我们可以断言存在一种方案使得不会把端点的值从 $1$ 变成 $0$。我们强制不能够两次翻转同一个点的值，这样是没有意义的。然后假如出现了端点从 $1$ 变成 $0$，找到最后一次，假设是左端点，那么最后要是 $1$，所以肯定要 $1\to0\to1$，然后直接翻转回来已经被我们 ban 掉了，所以右边的点肯定要先翻转，然后翻转回来，然后右边第二个点也是同理，最后我们得出右端点需要翻转再翻转回来，这和这是最后一次 $1\to 0$ 矛盾，所以不会存在这样的情况。

然后统计可行的情况就简单了：

1. 两个端点为 $1$，那么外面的叶子可以随意选，然后链上需要全部是 $1$，不然链上有若干个连续段，操作无法减少连续段的个数就寄了。方案数 $2^{x+y}$。
2. 两个端点只有 $1$ 个 $1$，假设是左端点，那么左端点连出的叶子是随意选，然后链上的 $1$ 不断操作要能够使得右端点翻转，所以右端点连出的叶子有偶数个 $1$，然后左端点到右端点的 $1$ 是一段连续的。所以这部分的方案数为 $2\times(l-1)\times 2^{x+y-1}$。
3. 否则两个端点都是 $0$，那么一定是中间有一段连续的 $1$，两个端点接偶数个 $1$。所以方案数为 $\binom {l-1}2\times2^{x+y-2}$。

复杂度 $\mathcal O(N)$。

## 代码
```cpp
const int N=2e5+10;
int n;vector<int>e[N];bool flag;
mint f[N][2][2][2][2],g[2][2][2][2];int sz[N];
//[u][u的状态][u儿子为奇数的个数][连通块的奇偶性][不包括u是否存在可行点]
void dfs(int u,int fa){
	sz[u]=1;f[u][0][0][0][0]=f[u][1][0][1][0]=1;int tot=0;
	for(auto v:e[u])if(v!=fa){
		dfs(v,u);memset(g,0,sizeof g);
		for(int a=0;a<2;a++)for(int b=0;b<2;b++)for(int c=0;c<2;c++)for(int d=0;d<2;d++)
			for(int aa=0;aa<2;aa++)for(int bb=0;bb<2;bb++)for(int cc=0;cc<2;cc++)for(int dd=0;dd<2;dd++)
				g[a][b^aa][c^cc^(a&aa)][d|dd|(a^bb)]+=f[u][a][b][c][d]*f[v][aa][bb][cc][dd];
		memcpy(f[u],g,sizeof g);
		sz[u]+=sz[v];tot+=sz[v]>=2;
	}
	tot+=n-sz[u]>=2;
	if(e[u].size()>=3u&&tot>=2)flag=1;
}
signed main(){
	read(n);
	for(int i=1,u,v;i<n;i++)read(u,v),e[u].pb(v),e[v].pb(u);
	dfs(1,0);
	if(flag){
		mint ans=0;
		for(int a=0;a<2;a++)for(int b=0;b<2;b++)for(int d=0;d<2;d++)if(b|d)
			ans+=f[1][a][b][1][d];
		return writeln(ans.x),0;
	}
	int x=1,y=1;
	for(int i=1;i<=n;i++)if(e[i].size()>=3u){
		if(x==1)x=e[i].size()-1;
		else y=e[i].size()-1;
	}
	int l=n-x-y;mint kk=mint(2)^(x+y-3+mod-1);
	writeln((kk*8+(l-1)*kk*8+kk*4+kk*(l-1)*(l-2)).x);
}
```

---

## 作者：UltiMadow (赞：1)

显然一次操作相当于翻转一个邻域里有奇数个 $1$ 的点。

操作显然可逆，所以考虑计算可以通过操作变成全 $1$ 的数量。

性质 1：操作不会影响 $1$ 连通块个数的奇偶性。

证明显然，所以合法的状态中 $1$ 连通块个数一定是奇数。

同样的合法状态中至少有一个点可以被操作。

这两个条件显然是必要的，考虑它们什么时候充分。

性质 2：当树上存在一个点度数 $\ge 3$ 且以这个点为根时至少有两个子树有至少两个点时，一个状态合法当且仅当状态中 $1$ 连通块数量为奇数且至少有一个点可以被操作。

证明：若 $1$ 连通块数量为 $1$，则显然这个状态合法。

考虑用一个点来代表一个 $1$ 连通块（可以通过操作连通块中最外面一层的点来缩成一个点）。

此时显然有任意两个 $1$ 不相邻，我们的目标状态即为把所有 $1$ 合并为一个 $1$。

考虑新建两个操作：

1. 若一个点 $u$ 为 $1$，与它相邻的点 $v$ 为 $0$，且与 $v$ 相邻的点中只有 $u$ 一个为 $1$，则可以将 $v$ 设置为 $1$，$u$ 设置为 $0$，称为「交换」。

2. 若一个点 $u$ 为 $0$，与它相邻的点中有奇数个 $1$，可以将这些 $1$ 设置为 $0$，将 $u$ 设置为 $1$，称为「合并」。

引理 1：若以 $u$ 为根的子树中有可进行的操作，且 $u$ 的父亲为 $0$，则一定可以通过若干次操作改变 $u$ 的状态。

证明：考虑归纳证明。

1. 若 $u$ 为 $0$，如果它的儿子中有奇数个 $1$，则可以通过一次合并操作改变 $u$ 的状态；否则记可以操作的点在 $v$ 的子树中，则根据归纳假设可得 $v$ 可以通过若干次操作被改变状态，改变 $v$ 之后通过一次合并操作即可改变 $u$ 的状态。

2. 若 $u$ 为 $1$，如果存在一个儿子的儿子中有偶数个 $1$，则可以通过一次合并操作改变 $u$ 的状态；否则记可以操作的点在 $v$ 儿子的 $w$ 子树中，根据归纳假设可得 $w$ 可以通过若干次操作被改变状态，改变 $w$ 之后通过一次合并操作即可改变 $u$ 的状态。

引理 2：若以 $u$ 为根的子树中无可进行的操作，且 $u$ 为 $0$，$u$ 子树中不全为 $0$，则如果可以给 $u$ 的父亲变为 $1$，则一定可以通过若干次操作使得 $u$ 子树内可以进行合并操作。

证明：考虑归纳证明。

1. 若 $u$ 的所有儿子均为 $0$，则可以通过一次交换操作把 $u$ 的父亲的 $1$ 移到 $u$ 上并递归进子树中，根据归纳假设此时一定成立。

2. 若 $u$ 的所有儿子中有偶数个 $1$，则可以在 $u$ 处进行合并操作。

3. 若 $u$ 的所有儿子中有奇数个 $1$，则与以 $u$ 为根的子树中无可进行的操作矛盾。

回到原来的性质中，考虑以一个度数 $\ge 3$，至少有两个大小 $\ge 2$ 的子树的点 $u$ 为根。

考虑构造一种操作方式使得能使 $1$ 的个数不断减少。

1. 若 $u$ 为 $1$ 则通过引理 1 把 $u$ 修改为 $0$。

2. 若 $u$ 的儿子中有奇数个 $1$ 且 $1$ 的个数 $\ge 3$，则可以通过一次合并操作减少 $1$ 的数量，操作后若 $1$ 的个数不为 $1$ 则显然还能继续操作。

3. 若 $u$ 的儿子中有偶数个 $1$ 则考虑根据引理 1 改变其中一个儿子的状态。

4. 若 $u$ 的儿子中只有一个 $1$，考虑 $u$ 的其他儿子。
   
   1. 若 $u$ 的其他儿子中有至少两个可以操作的子树，则可以根据引理 1 改变两个儿子的状态。
   
   2. 若 $u$ 的其他儿子中有一个不全为 $0$ 且不可以操作的子树，则可以把为 $1$ 的儿子和 $u$ 交换，此时这个子树符合引理 2。
   
   3. 否则 $u$ 的其他儿子中只有一个可以操作的子树，且其他子树全部为 $0$，由于 $u$ 的度数 $\ge 3$，所以可以把为 $1$ 的儿子交换到一个全 $0$ 的子树中去，此时如果满足前两种情况则按照前两种情况做，否则由于 $u$ 至少有两个大小 $\ge 2$ 的子树，所以一定可以把为 $1$ 的儿子换到一个大小 $\ge 2$ 的全 $0$ 子树中，之后操作那个可以操作的子树，使得 $u$ 获得一个新的为 $1$ 的儿子，由于之前为 $1$ 的儿子在大小 $\ge 2$ 的子树中，所以新儿子可以通过交换操作换到另一个全 $0$ 子树中，若此时还不符合前两种情况，则此时一定只有这两个 $1$，与条件矛盾。

这样我们就证完了这个性质。

于是对于一个符合这个性质的树，记 $f_{u,0/1,0/1,0/1,0/1}$ 为以 $u$ 为根的子树中，$u$ 为 $0/1$，$u$ 的儿子的异或和为 $0/1$，$1$ 连通块个数的奇偶性和是否存在一个点可以操作。

接下来只要考虑不符合性质的树怎么计数，不难发现不符合性质的树的形态一定是一条链两边接了若干条边（链+两个菊花）。

记两边的菊花各有 $l$ 和 $r$ 条边，则链上点的个数即为 $n-l-r$，记为 $len$。

1. 若链的两个端点均为 $1$，则链上所有点一定为 $1$，菊花上的点任意，方案数为 $2^{l+r}$。

2. 若链的两个端点中恰一个为 $1$，则链上一定是一段连续的 $1$ 和一段连续的 $0$，菊花上的点要保证为 $0$ 的端点一定不能被操作，所以方案数为 $2(len-1)2^{l+r-1}=(len-1)2^{l+r}$。

3. 若链的两个端点均为 $0$。
   
   1. 若链上全为 $0$，则菊花上的点要保证两个端点恰有一个点能被操作，方案数为 $2^{l+r-1}$。
   
   2. 若链上点不全为 $0$，则一定是中间连续的一段为 $1$，菊花上的点要保证两个端点都不能被操作，方案数为 $\binom{len-1}22^{l+r-2}$。

总复杂度 $\mathcal O(n)$，dp 有一个 $2^8$ 的常数。

code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 200010
#define p 998244353
using namespace std;
const int N=200000;
int n,in[MAXN],pw[MAXN];
struct Node{int to,nxt;}Edge[MAXN<<1];
int Head[MAXN],cnt_Edge;
void Add_Edge(int u,int v){
	Edge[++cnt_Edge]=(Node){v,Head[u]};
	Head[u]=cnt_Edge;
}
int f[MAXN][16],tmp[16],sz[MAXN],fl;
void dp(int u,int fa){
	sz[u]=1;int cnt=0;f[u][0]=f[u][10]=1;
	for(int i=Head[u];i;i=Edge[i].nxt){
		int v=Edge[i].to;if(v==fa)continue;
		dp(v,u);sz[u]+=sz[v];cnt+=(sz[v]>1);
		memcpy(tmp,f[u],sizeof(tmp));
		memset(f[u],0,sizeof(f[u]));
		for(int s=0;s<16;s++)
			for(int t=0;t<16;t++){
				int nxt=(s&8)|((s&4)^((t&8)>>1))|((s&2)^(t&2)^(((s&8)&(t&8))>>2))|((s&1)|(t&1)|(((s&8)>>3)^((t&4)>>2)));
				f[u][nxt]=(f[u][nxt]+tmp[s]*f[v][t])%p;
			}
	}
	cnt+=(n-sz[u]>1);
	fl|=(cnt>1&&in[u]>2);
}
signed main(){
	pw[0]=1;for(int i=1;i<=N;i++)pw[i]=pw[i-1]*2%p;
	scanf("%lld",&n);
	for(int i=1;i<n;i++){
		int u,v;scanf("%lld%lld",&u,&v);
		Add_Edge(u,v);Add_Edge(v,u);
		in[u]++;in[v]++;
	}
	dp(1,0);
	if(fl){
		int ans=0;
		for(int s=0;s<16;s++){
			if(!(s&2)||!((s&1)|((s&4)>>2)))continue;
			ans=(ans+f[1][s])%p;
		}printf("%lld",ans);
	}else{
		int l=1,r=1;
		for(int i=1;i<=n;i++)
			if(in[i]>2)r=l,l=in[i]-1;
		int len=n-l-r;
		printf("%lld",(pw[l+r]*len+pw[l+r-1]+(len-1)*(len-2)/2%p*pw[l+r-2])%p);
	}
	return 0;
}
```

---


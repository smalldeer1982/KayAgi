# [AGC055F] Creative Splitting

## 题目描述

给定整数 $N,\ K$。

当长度为 $K$ 的整数序列 $a=[a_1,\ a_2,\ \ldots,\ a_K]$ 满足对于所有 $1 \leq i \leq K$，都有 $1 \leq a_i \leq i$ 时，称 $a$ 为**好序列**。

当长度为 $NK$ 的整数序列 $b=[b_1,\ b_2,\ \ldots,\ b_{NK}]$ 满足以下条件时，称 $b$ 为**优秀序列**：存在一种将 $b$ 分解为 $N$ 个长度为 $K$ 的（不一定连续的）子序列的方法，使得每个子序列都是好序列。

定义 $f(pos,\ val)$ 为满足 $b_{pos}=val$ 的优秀序列 $b$ 的个数。

请你对于所有 $1 \leq pos \leq NK$，$1 \leq val \leq K$，求出 $f(pos,\ val)$。由于这些数可能非常大，请输出它们对素数 $P$ 取模的结果。

## 说明/提示

## 限制

- $1 \leq N \leq 20$
- $1 \leq K \leq 20$
- $10^8 \leq P \leq 10^9$
- $P$ 是素数。

## 样例解释 1

存在以下 $6$ 个优秀序列。
- $[1, 1, 1, 1]$：可以分为 $[b_1, b_2], [b_3, b_4]$。
- $[1, 1, 1, 2]$：可以分为 $[b_1, b_2], [b_3, b_4]$。
- $[1, 2, 1, 1]$：可以分为 $[b_1, b_2], [b_3, b_4]$。
- $[1, 2, 1, 2]$：可以分为 $[b_1, b_2], [b_3, b_4]$。
- $[1, 1, 2, 1]$：可以分为 $[b_1, b_3], [b_2, b_4]$。
- $[1, 1, 2, 2]$：可以分为 $[b_1, b_3], [b_2, b_4]$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2 2 965166677```

### 输出

```
6 0 
4 2 
4 2 
3 3```

# 题解

## 作者：jun头吉吉 (赞：13)

## 题意
给定 $N,K,P$。

称一个长度为 $K$ 的数组 $\{a_i\}$ 是好的当且仅当 $1\le a_i\le i$。

称一个长度为 $NK$ 的数组 $\{b_i\}$ 是合法的当且仅当可以被分成 $N$ 个长度为 $K$ 的子序列，每个都是好的。

设 $f(pos,val)$ 表示 $b_{pos}=val$ 的合法序列数。对 $1\le pos\le NK,1\le val\le K$ 求出 $f(pos,val)\bmod P$。

$1\le N,K\le 20,10^8\le P\le 10^9$ 且 $P$ 为质数。

## 题解
首先考虑怎么判定一个数组是不是合法的。一个显然的贪心策略是维护长度为 $N$ 的序列 $\{c_j\}$，初始值全部为 $K$，也就是每个序列没有填的长度。从后往前遍历 $b_i$，找到最小的 $c_j\ge b_i$，把 $c_j$ 减去 $1$。如果没有 $c_j$ 那么就是不合法。

这个找到最小的 $c_j\ge b_i$ 不方便计数，我们换一种方式，也就是设 $c_i'=\sum_j [c_j<i]$，初始全部是 $0$，每次就是让 $c'_{b_i}$ 加 $1$，如果已经是 $N$ 那么就不合法，然后从小到大排序。

这个为什么是对的呢。考虑找到最小的 $c_j\ge b_i$ 就相当于找最小 $x\ge b_i,c'_{x+1}\ne c'_x$，然后把 $c_x'$ 加上一。发现既然 $c'_{b_i}$ 到 $c_x'$ 都是相等的，那么加哪个都是一样的。

这个的好处就在于，如果 $b_i$ 的取值为 $[1,K]$，那么甚至不需要排序。唯一需要排序的一次是在 $pos$ 的时候，因为要保证 $c_{b_{pos}}'<N$。

那么就可以计数了。设到 $pos$ 时的数组为 $\{c_i'\}$，那么对应的贡献是：
$$
\sum_{\tiny\begin{aligned}&0\le c_1'\le c_2'\le\dots\le c_K'\le N\\ &\sum c_i'=NK-pos\end{aligned}}\frac{K!}{\prod_{i=0}^n(\sum_j [c_j'=i])!}\times\frac{(NK-pos)!}{\prod_{i=1}^K c_i'!}\times\frac{(pos-1)!}{\prod_{i=1}^K(N-c_i'-[i=val])!}
$$
第一项的含义是把序列重排的方案数，第二项的含义是 $b_{NK}$ 到 $b_{pos+1}$ 这 $NK-pos$ 次的分配方案，第三项的含义是 $b_{pos-1}$ 到 $b_1$ 这 $pos-1$ 次的分配方案。

枚举 $val$ 然后dp即可，设 $f_{x,y,z}$ 表示选 $\le x$ 的数，共 $y$ 个，和为 $z$，的贡献和。转移就是枚举 $x$ 选了几个。复杂度 $\mathcal O(N^2K^4)$。

## 代码
```cpp
const int N=21;
int n,k;mint dp[2][N][N*N],fac[N*N],ifac[N*N];
mint res[N*N][N];
signed main(){
	read(n,k,mod);
	fac[0]=ifac[0]=1;for(int i=1;i<N*N;i++)fac[i]=fac[i-1]*i,ifac[i]=1/fac[i];
	for(int val=1;val<=k;val++){
		memset(dp,0,sizeof dp);
		int cur=0,pre=1;
		dp[cur][0][0]=1;
		for(int x=0;x<=n;x++){
			swap(pre,cur);memset(dp[cur],0,sizeof dp[cur]);
			for(int y=0;y<=k;y++)for(int z=0;z<=n*k;z++)if(dp[pre][y][z].x){
				mint _=ifac[x]*ifac[n-x],v=dp[pre][y][z];
				for(int c=0;z+c*x<=n*k&&y+c<=k&&v.x;c++,v*=_,(y+c==val)&&(v*=(n-x)).x)
					dp[cur][y+c][z+c*x]+=v*ifac[c];
			}
			for(int pos=1;pos<=n*k;pos++)res[pos][val]=fac[k]*fac[n*k-pos]*fac[pos-1]*dp[cur][k][n*k-pos];
		}
	}
	for(int pos=1;pos<=n*k;pos++)for(int val=1;val<=k;val++)
		write(res[pos][val].x),pc(" \n"[val==k]);
}
```

---

## 作者：Petit_Souris (赞：6)

比赛的时候看到计数就上头了，想了三个多小时倒是差不多想出来了，可惜来不及写了，反而前面的题爆了。能不能对自己水平有点清晰的认知啊！！做点会做的题苟一苟就赢了啊！！！

首先我们肯定会考虑 dp of dp 状物，正着扫一遍，维护有哪些目前的长度集合是合法的。大概可以通过 $N=7$。

仔细想一下发现正着做并没有什么前途，因为每次要加入的位置无法确定哪个更优。不如试着倒着删除，即初始的时候每个序列的长度都是 $k$，每次选一个长度 $\ge a_i$ 的序列并将其长度 $-1$。这个判定的策略是明显的：每次一定会贪心删除最小的那个。也可以写一个压状态 dp，差不多能过到 $N=10$。

欸，然后有点难进一步推进了。不过我们可以观察一下这个结构，发现每次删完之后，长度序列依旧是单调递增的，这时候你有一定概率会灵光乍现联想到杨表！（虽然我好像画了大半天才悟出来，可能是因为搬题开的数据范围是 $30$ 然后想到了 $\binom{30}{15}$，虽然与最后解法无关）

在杨表上相当于每次砍掉一行的一个格子，这时候（不知道是不是套路化地）想到将其转置。这样过程可以用空格子来刻画，即初始没有空格子，每次在一列末尾加入一个空格子。这显然构成双射。

现在过程形如：每次给 $x_{a_i}$ 加上 $1$，然后将 $x_{1}\dots x_{K}$ 从小到大排序。这时候可以开始进行计数了，我们枚举搞定 $[pos+1,NK]$ 时的状态 $x_1\dots x_K$，那么方案数为：

$$
\frac{K!}{\prod\limits_{i}(\sum [x_j=i])!}\times \frac{(NK-pos)!}{\prod x_j!}\times \frac{(pos-1)!}{\prod(N-x_j-[j=val])!}
$$

第一部分是这 $K$ 列之间的排列顺序（因为不一定有序），第二部分是填入 $[pos+1,NK]$ 的方案数（每行内部必须是有序的），第三部分是填入 $[1,pos-1]$ 的方案数（同理每行内部也得有序，且 $val$ 那行会少一个）。

那么直接 dp 即可，枚举 $val$ 之后设 $f_{i,j,k}$ 表示 $[0,i-1]$，选了 $j$ 个，$\sum x=k$ 的方案数之和，复杂度 $\mathcal O(n^2K^4)$。

---

## 作者：Qiuly (赞：3)

倒着做，考虑一种贪心的划分方式：我们看作 $n$ 行 $k$ 列，每一次就是挑选一个限制最小（且能放入）的行，然后塞进去（有多个挑编号最小的）。显然，如果一个序列合法，就一定可以恰好放完 $n\times k$ 。

注意到，一次塞入 $[1,k]$ 时，遇到的情况可以看作：每一列放入一个格子，自由下落到某一行。放完之后，格子会并到对应行的末尾。但关注到并与不并，这个操作是不重要的，可以看作列的交换。

于是考虑转置，变成一共有 $k$ 列，每次可以选择一列加 $1$ 。不考虑列并的情况，列的标号仍然唯一对应了一个加入的数的值。因此外层枚举 $val$，设 $s_i$ 表示列高度不超过 $i$ 的总列数。DP 记录 $i,s_i$ 和高度不超过 $i$ 的列，高度总和（为了确定 $pos$）。

转移的时候如果 $s_i<val\leq s_{i+1}$，那么 $val$ 对应列的高度确定。而总方案数可以简单地组合计算（其中有一个系数，与 $val$ 对应列的高度有关，目的在于确认当前这一步确实是选择了这一高度的某一列）。

提交记录：[Submission #39482530 - AtCoder Grand Contest 055](https://atcoder.jp/contests/agc055/submissions/39482530) 。

---

## 作者：JWRuixi (赞：1)

讲一下 Kubic 老师冬令营上讲的做法。

## [AGC055F] Creative Splitting

### 题意

定义一个长度为 $n$ 的序列 $a$ 是**好的**，当且仅当 $\forall 1 \le i \le n, a_i \le i$；定义一个长度为 $n \times m$ 的序列 $A$ 是**棒的**，当且仅当这个序列能拆分成 $n$ 个长度为 $m$ 的**好的**子序列。

给定 $n$，$m$，对于所有 $1 \le x \le n \times m, 1 \le y \le m$ 求满足 $A_x = y$ 的**棒的**序列数量。

$n, m \le 20$。

### 分析

考虑一种贪心：

- 维护序列长度为 $n$ 的序列 $b$，初值为 $m$；
- 从后往前扫 $A_i$，找到最小的 $j$ 满足 $b_j \ge A_i$，令 $b_j \gets b_j - 1$。

如果能进行到最后说明合法。显然这个贪心会保证 $b$ 始终单调不降。

不考虑限制，如何再维护这种贪心的同时计数？这相当于每次选择一个 $j$ 被操作，那么方案数为 $b_j - b_{j - 1}$。这启示我们维护数组 $b$ 的差分，那么我们将计数的过程转化为：

- 维护序列长度为 $n$ 的序列 $c$，初值 $c_1 = m, c_2 = \cdots = c_n = 0$；
- 进行 $n \times m$ 次操作，每次选择一个 $i$，令 $c_i \gets c_i - 1, c_{i + 1} \gets c_{i + 1} + 1$，方案数 $c_i$。

这个形式比较像一个单位从 $i$ 向 $i + 1$ 的转移，所以组合意义可以描述为：

- 初始时 $1$ 这个位置有 $m$ 个小球；
- 进行 $n \times m$ 次移动，每次选择一个小球，将它向右移动一个位置。

考虑怎么解决限制的问题，这相当于将原问题分成了三个部分：$1, \dots, nm - x$；$nm - x + 1$；$nm - x + 2, \dots, nm$。我们考虑称前 $nm - x$ 步为第一阶段，后面的部分为第二阶段。设计 DP：$f_{i, j}$ 表示考虑了 $i$ 个球（总共操作 $im$ 次），其中有 $j$ 次操作在第一阶段；转移可以直接枚举这个球第一阶段有多少步。

统计答案就是要将 $nm - x + 1$ 的操作唯一确定下来。但是注意到这个系数跟具体的操作位置有关，所以我们枚举操作位置 $t$。这样增加了限制：$\sum\limits_{i < t} c_i < y \le \sum\limits_{i \le t} c_i$，于是将状态改写为 $f_{t, i, j, k}$ 表示考虑 $i$ 个球，其中 $j$ 个球在第一阶段结束后在 $t$ 的前面，$k$ 次操作属于第一个阶段。那么具体的系数就是 $\dfrac{n - t + 1}{nm - x + 1}$，就是在第二阶段中唯一确定一个操作，但是要考虑到这个球所有的属于第二阶段的操作之间的顺序已经确定。

总时间复杂度 $\mathcal O(n^3m^3)$。

### Code

提交记录：<https://atcoder.jp/contests/agc055/submissions/62446916>。

---

## 作者：_Cheems (赞：0)

题意：对于一个 $nm$ 的序列 $a$，若可以将其剖分为 $n$ 个长 $m$ 的子序列，满足每个子序列第 $i$ 项 $\le i$，则称它是合法的。分别假设 $a_x=y$，求合法的 $a$ 的数量。$n,m\le 20$。

做法源自 WC2025 郭羽冲大蛇的讲解，和现有题解貌似不太一样？

典中典之寻找充要条件，从后往前贪心填写子序列，记 $b_i$ 表示第 $i$ 个子序列接下来填的位置，对于 $a_i$ 找到可以容下它的最小的 $b_j$。容易反证法证明。

令 $b$ 升序排列，特殊地 $b_{n+1}=m$。考虑通过 $b$ 的变化反推 $a$，具体来说，填写 $a_i$ 时，选取一个 $b_j$ 填进去，则 $a_i$ 有 $b_{j+1}-b_j$ 种取值方案。

记 $c=b_{i}-b_{i-1}$，那么等价于选取 $j$ 然后产生 $c_j$ 的贡献，并让 $c_j-1$，$c_{j+1}+1$。

注意到 $-1+1$ 的过程可以用小球的移动来刻画，同时不同小球的选取又能体现 $\times c$。于是不考虑限制的情况下，一个合法 $a$ 序列等价于下列过程：有 $m$ 个小球，一开始位于 $1$，每次可以选取一个向右移动一格，最后全移到 $n+1$。$c_i$ 就是位置 $i$ 上的小球数量。

考虑 $a_x=y$ 带来的限制。不妨分为两个阶段：第一阶段即前 $nm-x$ 步、第二阶段即后 $x$ 步。枚举 $a_x$ 填到了 $b_t$，那么要求第一阶段结束后 $\sum\limits_{i<t} c_i<y\le \sum\limits_{i\le t} c_i$。可以差分拆一下，只考虑右边这个限制即可。$\sum\limits_{i\le t}c_i$ 又等价于前 $t$ 个位置上的球数。

考虑通过球的移动刻画第 $nm-x+1$ 步（即 $a_x=y$），你找到 $y$ 对应的那个球在移动显然不现实，不妨移动编号最小的球，这样十分方便计数。

终于可以 dp 了！记 $lim$ 为我们关心的前 $lim$ 个位置（需要满足这些位置上的球数 $\ge y$）。记 $f_{i,j,k,st}$ 为考虑前 $i$ 个球、第一阶段有 $j$ 个操作、在第一阶段移动到的位置 $\le lim$ 的球数量为 $k$。$st$ 用于处理第 $nm-x+1$ 步，$st=0$ 表示此前不存在在第一阶段移动了 $t-1$ 步的球，即已经有小球被安排在 $nm-x+1$ 步移动了，$st=1$ 反之。

转移灰常容易，枚举当前球在第一阶段操作数即可。最后算答案就 $ans_{x,y}\gets fl\times \sum\limits_{k\ge y}f_{m,nm-x,k,1}$。$fl$ 是差分标记。

复杂度 $O(n^3m^3)$。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define ADD(a, b) a = (a + b) % mod
const int N = 25, NM = 405;
int n, m, mod, ans[NM][N], f[N][NM][N][2], c[NM][NM];

inline void solve(int t, int lim, int fl){
	memset(f, 0, sizeof f);
	f[0][0][0][0] = 1;
	for(int i = 1; i <= m; ++i){
		for(int j = 0; j <= (i - 1) * n; ++j)
			for(int k = 0; k < i; ++k){
				int j2 = (i - 1) * n - j;
				for(int p = 0; p <= n; ++p){
					if(p == t - 1){
						ADD(f[i][j + p][k + (p < lim)][1], f[i - 1][j][k][0] * c[j + p][p] % mod * c[j2 + n - p - 1][n - p - 1] % mod);	
						ADD(f[i][j + p][k + (p < lim)][1], f[i - 1][j][k][1] * c[j + p][p] % mod * c[j2 - 1 + n - p][n - p] % mod);
					}
					else{
						ADD(f[i][j + p][k + (p < lim)][0], f[i - 1][j][k][0] * c[j + p][p] % mod * c[j2 + n - p][n - p] % mod);
						ADD(f[i][j + p][k + (p < lim)][1], f[i - 1][j][k][1] * c[j + p][p] % mod * c[j2 - 1 + n - p][n - p] % mod);
					}
				}
			}
	}
	for(int x = 1; x <= n * m; ++x)
		for(int y = 1; y <= m; ++y)
			for(int k = y; k <= m; ++k)
				ADD(ans[x][y], fl * f[m][n * m - x][k][1] % mod);
}
signed main(){
	cin >> n >> m >> mod;
	c[0][0] = 1;
	for(int i = 1; i < NM; ++i){
		c[i][0] = c[i][i] = 1;
		for(int j = 1; j < i; ++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
	}
	for(int t = 1; t <= n; ++t) solve(t, t, 1), solve(t, t - 1, mod - 1);
	for(int i = 1; i <= n * m; ++i){
		for(int j = 1; j <= m; ++j) printf("%lld ", ans[i][j]);
		putchar('\n');
	}
	return 0; 
}
```

---


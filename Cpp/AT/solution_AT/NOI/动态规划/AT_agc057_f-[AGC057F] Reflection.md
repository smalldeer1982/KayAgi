# [AGC057F] Reflection

## 题目描述

在数轴上有三个点 $A, B, C$，坐标分别是 $a, b, c$，满足 $a \le b \le c$。每次可以进行以下两个操作中的一种：

- 将点 $A$ 关于点 $B$ 对称；
- 将点 $C$ 关于点 $B$ 对称。

操作可以无限进行，每做完一次操作后，将三个点按照坐标从小到大的顺序重新标注 $A, B, C$。

求操作过程中，产生不同三元组 $(a, b, c)$ 的个数模 $998244353$ 的结果。

## 说明/提示

$1 \le T \le 10^5,\ -10^{18} \le a \le b \le c \le 10^{18}$。

## 样例 #1

### 输入

```
6
1 3 5
-2 -2 5
0 1 3
31 41 59
-123456789 0 987654321
-1000000000000000000 0 1000000000000000000```

### 输出

```
5
2
9
70
182333351
5```

# 题解

## 作者：Argon_Cube (赞：7)

[Cursedsnake - Reflect](https://music.163.com/#/song?id=1452470959),[Creo - Reflections](https://music.163.com/#/song?id=1433448809).

这是一个与官方题解和目前洛谷唯一一篇题解都不一样的做法。

如果觉得描述有些抽象可以看图帮助理解。

以下记 $n\{m\}$ 是由 $n$ 个 $m$ 构成的序列，如 $3\{4\}=\{4,4,4\}$。

-----

我们看完简洁优美的题面，很自然有这么一个问题：为什么能到达的状态数一定是有限的？这看起来不是很显然，但不难理解。

接下来我们为了叙述的方便，使用 $(a,b,c)$ 描述题面给出的信息，其中 $b$ 是中点位置，$a,c$ 分别是中间点与左边、右边的距离。不妨令 $a\leq c$，一次操作会得到 $(c-a,b-a,a)$ 或 $(a,b+a,c-a)$，$a>c$ 同理。也就是 $a,c$ 大的减去小的，$b$ 加上或减去小的，并依照对 $b$ 加还是减决定是否交换 $a,c$。

可以发现这个过程会对 $a,c$ 做辗转相减，因此在有限步后一定会到达 $(0,x,\gcd(a,c))$。这时无论怎么操作就只能在两种状态之间转了。

因此，我们以后认为初始的三元组一定满足 $b=0,\gcd(a,c)=1,c\geq a$，也就是终止状态一定形如 $(0,x,1)$。

这里就有第一个特判，当 $a=c=0$ 时输出 $1$。

接下来我们开始计数。对于 $b$，我们不妨把每次 $B$ 的位移的绝对值写成一个序列 $d$。显然这个序列可以划分成值相等的 $\Omicron(\log(a+c))$ 段，形如 $x_1\{a\},x_2\{c\bmod a\},\cdots,x\{1\}$。我们不妨认为我们是选择了 $d$ 的一段前缀，然后对其中的每一个数我们都可以选择加在 $b$ 上或者什么都不做。显然这样 $b$ 的方案数是不会变的。

对于 $a,c$，我们可以发现 $a,c$ 的顺序只取决于最后一次操作。也就是说操作次数和最后一次操作一样则 $a,c$ 必定一样。具体来说如果反转某次操作使 $a,c$ 交换，它们会在下一次操作换回来。

那么我们现在就不关心 $a,c$ 了，不妨将 $b$ 的变化画成一张分层图。不妨认为根是第 $0$ 层。

初始 $(a,b,c)=(8,0,5),d=\{5,3,2,1,1\}$：

![Image of (8,0,5)](https://cdn.luogu.com.cn/upload/image_hosting/34174m76.png)

初始 $(a,b,c)=(7,0,5),d=\{5,2,2,1,1\}$：

![Image of (7,0,5)](https://cdn.luogu.com.cn/upload/image_hosting/8s7ez46w.png)

其中，除了最后一层代表终止态每个点一定会被算两次，倒数第二层因为 $a=c=1$，我们不关心它们的顺序所以每个点只会被算一次，剩下的点要算几次是和连向它的边数有关的。我们不妨将最后两层去掉，然后算出剩下的边数，显然剩下的边与状态是一一对应的（或者你也可以算去掉最后三层剩下的点数再乘 $2$）。最后再加上最后两层的贡献以及没算的根。

这里需要第二个特判，特判根在最后两层的情况。

那么最后两层的贡献是多少呢？可以发现倒数第二层的点包含了 $[0,a+b-2]$ 中的所有的整数。

证明并不难，可以发现，如果每次操作都选择加那么 $a+b+c$ 是不变的，于是倒数第二层最大包含 $a+b-2$。我们去掉 $d$ 最后的一个 $1$，因为 $d$ 是由辗转相减得出的序列，这个特殊性质保证了 $d_i\leq 1+\sum_{j>i}d_j$，于是最小的不是 $d$ 子集和的数一定是 $1+\sum_i d_i=a+b-1$。

于是最后一层显然就有 $a+b$ 个点，这样最后我们要额外算的贡献就是 $1+(a+b-1)+2(a+b)=3(a+b)$。

最后考虑算边数。我们显然会考虑由一层的点数或边数递推，但这行不通。既然求出每层的边数是困难的，那么能不能直接递推出整体的边数呢？

以下点的编号按照上图，$(i,b)$ 代表第 $i$ 层的点 $b$。

注意到这个图的每一层都有很好的自相似性，所以我们尝试自底向上递推出每个 $(i,0)$ 能到达的边数 $f_i$，我们要求的就是 $f_0$。首先 $f_{|d|-2}=0$，由 $f_i$ 推出 $f_{i-1}$ 相当于将整棵树复制一份并向右平移 $d_i$，然后新建一个点将两个根连起来，像这样：

![Image of Copying](https://cdn.luogu.com.cn/upload/image_hosting/6u5v6iqs.png)

蓝色的部分就是会算重的相交部分，可以发现图中的边都不交叉，所以相交的部分一定是以某个点为根的子“树”。我们可以直接找到这个交点的位置从而证明这个结论。

如果这一步与下一步相同，那么显然 $0+x=x+0$，从而交点在第二层（如 $(a,b,c)=(7,0,5)$ 时的 $(1,0)\to (3,2)$ 的两条路径），此时有 $f_{i-1}=2f_i-f_{i+1}+2$；否则此时一定形如 $x,\left\lfloor\dfrac{x}{y}\right\rfloor\{y\},x\bmod y,\cdots$，因为 $x=\left\lfloor\dfrac{x}{y}\right\rfloor y+x\bmod y$ 所以交点的位置会在下下段的开头（比如 $(a,b,c)=(7,0,5)$ 时的 $(0,0)\to (4,5)$ 的两条路径，$(a,b,c)=(8,0,5)$ 时的 $(1,0)\to (4,3)$ 的两条路径）。

$d$ 只有 $\Omicron(\log(c-a))$ 段，第二种转移每段只会发生一次，只需记录这段与上段开头的 $f_i$ 即可转移；而第一种转移可以用矩阵快速幂优化，这样就以 $\Omicron(\log(c-a))$ 的复杂度解决了本题。(一开始我以为这是 $\log^2$，但是根据评测结果和更精细的估计似乎是大常数单 $\log$。)

官方题解也只有一个 $\log$ 而且没有矩阵快速幂，能不能再给力一些？可以发现，$f_{i-1}=2f_i-f_{i+1}+2$ 的几何意义就是 Reflection：$f_{i-1}$ 是 $f_{i+1}$ 关于 $f_{i}$ 的对称点再加 $2$。于是 $f$ 差分后是公差为 $2$ 的等差数列！这样就可以 $\Theta(1)$ 地求出 $f_i$ 了，时间复杂度还是 $\Omicron(\log(c-a))$ 但是常数变小了。

[Code.](https://atcoder.jp/contests/agc057/submissions/61672810)

-----

但是我们因为是自底向上的做所以要先存下来所有的 $\left\lfloor\dfrac{r_{i-1}}{r_i}\right\rfloor$，能不能自顶向下做，将空间复杂度从 $\Omicron(\log(c-a))$ 变成 $\Theta(1)$？

依然考虑去掉最后三层，这次我们直接用本质不同的路径数算点数，然后乘以 $2$ 算出边数，就能得到和刚刚的方法一样的结果。考虑对每一个点选出一条路径作为代表，根据我们刚刚的分析我们知道两条路径相交一定是出现了像 $x+0=0+x$ 或 $x+0+0=0+\left\lfloor\dfrac{x}{y}\right\rfloor y+x\bmod y$ 这种情况，我们不妨选取左边的路径作为代表。反映到 $d$ 上，就是对于 $d$ 的每一段我们选取的必须是一段后缀；同时如果这段选了，那么要么下一段不是全不选，要么下下段全选。所以需要记录前面两段的状态，然后直接递推即可。

可以发现这和另一篇题解是等价的，所以就不写代码了。

---

## 作者：FZzzz (赞：1)

考虑一个二元组 $(a,c)$ 表示左边和右边的石头分别距离中间的石头 $a$ 和 $c$，那么我们实际上对“这个二元组和中间石头的位置”这个三元组进行计数。

考虑进行一次操作，对于这个二元组的影响是大的减去小的，对于中间的坐标的影响是加上或减去小的数。借用一张官方题解的图：

![](https://img.atcoder.jp/agc057/61b3000087dd8839269d74914b8cec53.png)

如果我们固定了操作次数，把每次操作加上中间石子位移的绝对值写下来形成一个序列（图中写错了，前四个应该前移一位，第四个是 $\{7,3,3,1\}$），那么我们需要决定每次位移的方向，相当于选出若干个数的符号为正。这样，中间石子的坐标取决于选出的数的和，二元组 $(a,c)$ 取决于最后一个数选没选。

如果我们写出到 $(\gcd(a,c),\gcd(a,c))$ 为止的序列（图中是 $\{7,3,3,1,1\}$），它会形如 $n=O(\log a)$ 段，第 $i$ 段有 $d_i$ 个 $e_i$，并且满足 $e_i=d_{i+1}e_{i+1}+e_{i+2}$（假定 $e_{n+1}=\gcd(a,c)$）。

我们需要对这个序列的所有前缀，对“选出若干个数的和，以及最后一个数选没选”这个二元组计数，然后把它们加起来。这就相当于去掉最后一个数，对不同的和计数，然后乘以二。另外我们还需要计算在整个序列加上一个 $\gcd(a,c)$ 后的不同的和。

考虑对整个序列的某个前缀求这玩意。由于 $e_i=d_{i+1}e_{i+1}+e_{i+2}$，我们只需要考虑这样的选法：如果某一段全选了，并且它后面的一段选了至少一个，那么它前面一定全选了。我断言这样的选法的和一定全都不同。

增强一下这个结论，我断言在这种选法中，如果 $e_1$ 到 $e_{i-1}$ 都选了同样多，那么 $e_i$ 选得越多则和严格越大。考虑归纳，若 $i+1$ 到 $n$ 都满足这个结论，欲证明 $i$ 满足。这相当于证明 $e_i$ 大于“在 $i+1$ 到 $n$ 段中选，不存在某段选满并且后一段选了至少一个”的最大和。根据 $e_i=d_{i+1}e_{i+1}+e_{i+2}$，这是显然的。

在最后一段不满时（因为我们是对整个序列的每个前缀考虑）结论也是成立的。所以我们只需要对这种选法进行计数，考虑按段进行 dp。只需要记录上一段有没有选满以及前面所有数有没有选满，四个状态中有一个一直为 $0$ 一个一直为 $1$，所以实际上只有两个状态。

我们还需要计算增加一个 $\gcd(a,c)$ 之后的不同和。通过不断运用 $e_i=d_{i+1}e_{i+1}+e_{i+2}$ 可以证明只有在所有数都选时有与原序列不同的和，所以答案是原序列加一。现在我们可以以单次 $O(\log(c-a))$ 的时间解决原问题。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const ll mod=998244353;
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	int T=read();
	while(T--){
		ll a,b,c;
		a=read();
		b=read();
		c=read()-b;
		a=b-a;
		if(!a||!c){
			printf("%d\n",a||c?2:1);
			continue;
		}
		if(a<c) swap(a,c);
		ll ans=1,f1=0,f2=0;
		while(a!=c){
			ll d=(a/c-(a%c==0))%mod;
			ans=(ans+(f2+1)%mod*d%mod*((d+1)%mod)%mod+f1*d%mod*2%mod)%mod;
			swap(f1,f2);
			f2=((f1+1)%mod*d%mod+f2)%mod;
			if(a%c==0) ans=(ans-f2+f1+1+mod)%mod;
			a=a%c==0?c:a%c;
			swap(a,c);
		}
		printf("%lld\n",(ans+(f1+f2+2)%mod*2%mod)%mod);
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---


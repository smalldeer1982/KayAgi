# [AGC065F] Always Perfect

## 题目描述

给定一个偶数 $N$ 和一个素数 $M$。

请你求出满足以下条件的 $N$ 个顶点、编号为 $1$ 到 $N$ 的简单连通无向图 $G$ 的个数，并对 $M$ 取模。

- 对于 $G$ 的任意一棵生成树 $T$，$T$ 上都存在一个完全匹配。

什么是图的完全匹配？对于图 $G$，完全匹配是指由 $G$ 的边组成的一个集合 $E$，使得对于图中每个顶点 $v$，恰好有一条以 $v$ 为端点的边属于 $E$。

## 说明/提示

### 限制条件

- $2 \leq N \leq 500$
- $10^8 \leq M \leq 10^9$
- $N$ 是偶数
- $M$ 是素数
- 输入的所有值均为整数

### 样例说明 1

例如，下图中展示的两个图，左侧的图满足条件。而右侧的图，由于其红色粗线表示的包含 $3$ 条边的生成树上不存在完全匹配，因此不满足条件。  
![](https://img.atcoder.jp/agc065/2ef467c5e79ec3372986afd95c28100a.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 998244353```

### 输出

```
15```

## 样例 #2

### 输入

```
10 998244353```

### 输出

```
128792160```

## 样例 #3

### 输入

```
300 923223991```

### 输出

```
359143490```

# 题解

## 作者：Carotrl (赞：8)

考虑判定一个图是否合法。让我们对每一个点双连通分量考虑。

对于一个点双中的一个点 $u$，设它的悬挂集 $S_u$ 包含所有 $v$，其中 $v$ 满足存在一个点 $k$，$k$ 与 $u$ 同点双，且 $u$ 在 $k$ 与 $v$ 的必经路径上。具体一点 $S_u$ 就是 $u$ 和 $u$ 周围不在该点双的那部分。很容易发现如果 $|S_u| \bmod 2=1$，那么 $u$ 的悬挂集除 $u$ 外内部已经匹配完了，$u$ 只能和该点双内部匹配。如果 $|S_u| \bmod 2=0$，那么 $u$ 一定会和它的悬挂集中某个点匹配。

我们给出如下性质：

- 对于点双中所有点 $u$，$|S_u|$ 的奇偶性相同。

否则，我们一定可以找到点双中相邻两点 $x,y$，其中 $|S_x| \bmod 2=0$，$|S_y| \bmod 2=1$，由于 $x$ 不能和该点双内部匹配，$y$ 必须和点双内部匹配，所以我们保留的生成树中只要把 $y$ 设为叶子，并且连向 $x$，此时一定没有包含 $y$ 的匹配。于是图一定不合法。

当所有 $|S_u| \bmod 2=0$ 时，该点双内不会产生匹配，忽略。

当所有 $|S_u| \bmod 2=1$ 时，点双内所有点都在这里面发生匹配。我们考虑此时一个点双的合法性。

首先点数肯定要是偶数。下面我们证明，如果这个点双内有点的度数大于等于 $3$ 就无解。考虑反证，设 $v1$ 连向了 $v2,v3,v4$。考虑以下生成树：让 $v1,v2$ 连通，$v2$ 和 $v3$ 分别与 $v4$ 用一条不经过 $v1$ 的路径连接，其余随便连。再考虑断开 $v1,v2$ 的边，连接 $v1,v3$ 的边。以 $v4$ 为根，如果这两个生成树都有完美匹配，那么意味着 $v2$ 和 $v3$ 子树都匹配上了。此时，如果我们连接 $v1,v2$，$v1,v3$，$v1,v4$，断开 $v2,v3$ 与父亲的边。你会发现 $v1,v2,v3$ 完全无法匹配，所以就寄了。所以此时点双只能是一个偶环或者两点一边。

于是我们可以通过以下方式构造所有好的图：

- 初始放置若干偶环和两点一边。

- 每次选择大于等于两个连通块，每个连通块选出一个点，把它们随意连成一个点双。

- 图连通时停止。

如果把初始连通块看成一个点的话，最终就是一个若干个点双的连通图。

然后我们考虑如何计数。

首先我们肯定要算 $n$ 个点连通图数量和点双数量。

设 $g_n$ 表示 $n$ 个点的连通图数量，容易得到：$g_n=2^{\frac{n(n-1)}{2}}-\sum\limits_{i=1}^{n-1}\binom{n-1}{i-1}2^{\frac{(n-i)(n-i-1)}{2}}g_i$。

设 $f_{n,m}$ 表示有 $n$ 个点 $m$ 个点双的连通图数量。有 $f_{n,1}=g_n-\sum\limits_{i=2}^{n-1}f_{n,i}$。

关键问题是怎么算 $f_{n,m}$，考虑钦定一个点为根建出点双的圆方树，那么显然有 $m$ 个方点。设第 $i$ 个方点的儿子数为 $a_i$，那么内部一个点双的方案就是 $f_{a_i+1,1}$。外层还要将方点圆点连起来。此时相当于有 $m+1$ 个连通块，大小分别为 $1,a_1,a_2,...,a_m$，我要把它们连成树。此时方案数为 $n^{m-1}\prod\limits_{i=1}^{m}a_i$。但是因为是圆方树，所以一个块中是哪个儿子连向父亲的并不重要，于是答案除以 $\prod\limits_{i=1}^{m}a_i$，最终就是 $n^{m-1}$。再处理一下编号就可以得到转移式 $f_{n,m}=\frac{n^{m-1}(n-1)!}{m!}\sum\limits_{a_1+...+a_m=n-1}\prod\limits_{i=1}^{m}\frac{f_{a_i+1,1}}{a_i!}$。

最后一步是算答案。枚举我们初始放入了 $x$ 个连通块，第 $i$ 个有 $b_i$ 个点，进行了 $y$ 次操作得到了 $y$ 个点双。计算答案方法和算点双类似，不同的就是连通块大小和为 $n$。以及对于形成树后的一个方点，它的父亲是哪个点是确定的，但是你还需要对每个儿子确定它的连通块内用哪个点在这里形成点双。于是总共还要多乘上 $\prod\limits_{i=1}^{x}b_i$。（其中根的 $b$ 为在算树形态时乘的）

于是此时答案为 $\frac{n^{y-1}(x-1)!}{y!}\prod\limits_{i=1}^{x}b_i\sum\limits_{a_1+...+a_y=x-1}\prod\limits_{i=1}^{y}\frac{f_{a_i+1,1}}{a_i!}$。

点双的式子以及 $n$ 个点 $\prod\limits_{i=1}^{x}b_i$ 和的东西都可以在 $O(n^3)$ 内算出。总复杂度 $O(n^3)$。

---

## 作者：strlen_s_ (赞：5)

非常好且较困难的一道题，写写调调搞了好几天。

方案数的推理一定要细致，否则容易虚空调试。

许多地方参考了官方题解。

## Part 1：如何判定图是否合法

手画一画，玩一下 $n=6$ 的图，我们可以尝试进行如下分析。

1.图是一颗树。

那么这就意味着，连接叶子的点的匹配一定确定，我们可以把它删掉。最后整张图可以删空。

于是我们把匹配确定的这一对点当成一个点，那么就是这 $\dfrac{n}{2}$ 个点构成一棵树。

2.图是一个点双连通分量。

我们考虑现在只有一个偶环。

显然可行。

那我们在偶环中加入一条把环分为两部分的边？

我们发现，这时候，你割掉距这条分割边为 $1$ 的边，这会导致分割边其中一点与两个叶子相邻，不合法。

那么我们把偶环和两个单点构成的匹配叫做基本点。

3.关于基本点本身的一些讨论。

奇环可以作为基本点吗？

考虑要匹配奇环上的边，这就需要两个奇环。

考虑其路径上的偶环，那么这是偶环中有两个点已经被匹配。那么我们一定可以删掉偶环中的一条边使得存在一个叶子到匹配点的距离为奇数，造成不合法。

所以合法图一定是一堆基本点所构成的图。

4.关于基本点之间的连边。

基本点本质上是一堆点的集合，基本点之间的连边还需讨论具体连到哪个点。

我们发现，合法的连边当且仅当图中增加的新环的边都为基本点之间的连边，没有基本点内部的边。

否则，类似 2 的情况，我们可以把其视为一个中间有分割边的大环，然后割除边使得出现与两个叶子相邻的点。

---

总结：

一个图合法当且仅当可以被如此生成：

选出若干个还未连通的基本点块，然后连成一个点双连通分量。且在每个基本点构成的点双连通分量中，每个基本点有且仅有一个点在这个点双当中。

## Part 2 计数

因为要连点双，我们首先考虑 $n$ 个点连成一个点双的方案数。

设 $f_i$ 表示 $i$ 个点所形成的连通图数量。

进行一个简单的容斥，我们可以得出转移：$f_i=2^{\frac{i(i-1)}{2}}-\sum_{j<i}\binom{i-1}{j-1}2^{\frac{(i-j)(i-j-1)}{2}}$

设 $g_i$ 表示 $i$ 个点所形成的点双数量。

还是进行一个简单的容斥来转移。我们枚举图中存在 $j(j>1)$ 个点双，然后那 $f_i$ 减掉和。

那么问题就是如何计数含有 $j$ 个点双的图了。

我们考虑把这个图变为一颗圆方树，并钦定圆点 $1$ 为根，那么就存在 $j$ 个方点。

我们尝试枚举方点的儿子个数 $a_1,a_2 \cdots a_j$，然后让它们与它们的父亲的父亲组成一个点双，所有这里方案是 $\prod g_{a_i+1}$。

那么现在问题就是选父亲的父亲。那么我们可以把这个问题看成一个魔改了的有标号无根树计数问题。我们使用 Prüfer 序列来解决。

记 $c_0,\cdots c_j$ 表示根与所有方点在 Prüfer 序列中的出现次数。可得答案为：$\sum \binom{j-1}{c_0,c_1,\dots c_j}1^{c_0+1}\prod_{k=1}^j a_k^{c_k}=i^{j-1}$

设 $t_{i,j}=\sum_{a_1+\dots +a_j=i}\prod_k \dfrac{g_{a_k+1}}{a_k!}$ 

于是 $g_i$ 的转移为：

$$g_i=f_i-(i-1)!\sum_{j=2}\dfrac{i^{j-1}t_{i-1,j}}{j!}$$

然后 $g,t$ 相互转移，可以在 $O(n^3\ln n)$ 的复杂度实现求解。不是很会优化到 $O(n^3)$。

计数完点双就可以开始统计答案了。

设有 $i$ 个基本点，每个基本点的大小为 $l_i$。

设 $calc(x)$ 为 $x$ 个点构成的基本点方案数。

设 $z_{i,j}=\sum_{l_1+\dots +l_j=i}\prod_k \dfrac{calc(l_k)}{(l_k-1)!}$

类似上面的推导，可得答案为：

$$calc(n)+n!\sum_{i=2} \dfrac{z_{n,i}}{i!}(g_i+(i-1)!\sum_{j > 1} \dfrac{n^{j-1}t_{i-1,j}}{j!})$$

总复杂度：$O(n^3 \ln n)$。

代码比较丑，就不贴了。

---

## 作者：山田リョウ (赞：2)

# AGC065 F. Always Perfect

## 合法性判定

发现生成树的构成对于不同点双之间都是独立的，所以缩点双（边双也满足独立但是性质不如点双强）。

考虑如何判定一张图是否合法，建圆方树，对每个方点，不妨先以它为根，考察它的儿子是否在该点双内匹配，发现在该点双内匹配当且仅当儿子的子树大小是奇数（由于是点双所以儿子子树内其他点都无法连接子树外的任意点）。

更进一步的，发现若所有儿子的子树的奇偶性不同，即存在 $u,v$ 均在该点双内且 $u,v$ 间有边且 $u,v$ 子树奇偶性不同（不妨设 $u$ 奇 $v$ 偶），可以把 $(u,v)$ 边选进生成树后将 $u$ 割去，由于是点双所以不借助 $u$ 也依然可以连通建出生成树，在该生成树上 $u$ 是叶子，但是它的父亲 $v$ 不在该点双内匹配（不能与 $u$ 匹配），所以 $u$ 就找不到匹配了，形成矛盾。综上，以每个点双对应方点为根来看，该点双上的所有圆点的子树大小奇偶性一致。

大小为偶数即均不在点双内匹配，看起来没有什么性质值得讨论，转而去看子树大小均为奇数的点双。显然此时点双内必有偶数个点（否则没法两两匹配），且我们声称不能存在一个点在点双内度数超过 $2$。

考虑反证，不妨设 $v_1$ 与 $v_2,v_3,v_4$ 均有连边，考虑先割掉 $v_1$ 后建生成树以 $v_4$ 为根，将 $v_2$ 设为 $v_1$ 父亲说明 $v_2$ 子树去除 $v_1,v_2$ 的部分大小是偶数（需内部匹配），将 $v_3$ 设为 $v_1$ 父亲同理，然后再考虑断 $v_2$ 和原本父亲的边以及 $v_3$ 和原本父亲的边，均把父亲设为 $v_1$，再将 $v_1$ 父亲设为 $v_4$，然后发现 $v_2$ 和 $v_3$ 至少有一个缺失匹配（因为它们都只能向父亲 $v_1$ 匹配），由此矛盾。

![](https://img.atcoder.jp/agc065/8aafa37dfb60007d9814cf7716bf2678.png)

所以这样的点双必须是偶环或两点一边结构。

于是你发现合法的图一定可以通过以下过程生成：

1. 将 $n$ 个点划分进不同连通块内使得每个连通块恰好是一个偶环或两点一边。
2. 任取若干个连通块（连通块大小始终是偶数）并从每个中取出一个点，连成点双（对应前文说的子树大小均为偶数的点双）
3. 重复 $2$ 直至整张图连通。

## 计数

那看起来大概用 Cayley 定理对圆方树的一些特征做一下计数就好了吧！

具体来说，我们试图先处理出 $f_{n}$ 表示有标号 $n$ 个点点双连通图数。

但是好像没有什么合适的入手点，所以考虑容斥，先处理出 $g_n$ 表示有标号 $n$ 个点连通图数（这是容易的），然后给 $f$ 增加一维变为 $f_{n,m}$ 表示有 $m$ 个点双连通分量的有标号 $n$ 个点连通图数。对于每个 $n$，只需先计算出 $1<m\leq n$ 的情况后再把 $g_n$ 减一下即可得到 $f_{n,1}$。

考虑如何求 $f_{n,m}(m>1)$ ，先钦定 $1$ 为根，为每个方点编号最后再除去 $m!$，再为其余 $n-1$ 个点分配它在圆方树上的方点父亲，然后对每个钦定好了的大小为 $x$ 的点双乘上原本已经计算好了的贡献 $f_{x,1}$。此时你有 $m+1$ 个部分，其中第 $0$ 部分只有 $1$ 一个点，其余第 $i$ 个部分是方点 $i$ 以及它的所有儿子，设 $a_i$ 表示第 $i$ 部分中的圆点数（要求非 $0$ 且和为 $n$）。将第 $i$ 部分连接在第 $j$ 部分下的方案数是 $a_j$，求多少种连接方式形成一个以第 $0$ 部分为根的树。你不妨先在这里乘上 $a_i$ 变为 $a_ia_j$，相当于大小分别为 $a_i$ 和 $a_j$ 的两个连通块相连，于是根据 Cayley 定理的结论可知方案数是 $\prod\limits_{i=0}^{m}a_i(\sum\limits_{i=0}^ma_i)^{m-1}=\sum\limits_{i=0}^ma_in^{m-1}$。再除去额外乘的 $a_i$，恰好是 $a_0n^{m-1}=n^{m-1}$。

汇总下，即为

$$f_{n,m}=\begin{cases}g_n-\sum\limits_{i=2}^nf_{n,i}\quad&m=1\\\frac{n^{m-1}}{m!}\sum\limits_{a}\binom{n-1}{a_1,a_2,\cdots,a_m}\prod\limits_{i=1}^mf_{a_i+1,1}\quad&\text{elsewise}\end{cases}$$

写恰当的背包转移即可做到 $O(n^3)$。

然后考虑如何统计答案，还是先枚举初始连通块数 $m$ 和环长 $l_i$，为每个环赋予编号最后再除去 $m!$，然后钦定 $1$ 在第一个环，将其余 $n-1$ 个点分配至不同环，再统计环内的贡献，剩余的环间贡献还是类似上面先组成新方点下连新圆点的结构，枚举新方点数 $k$ 和每个新方点的儿子数 $a_i$后，先选环中向上连向新方点的点（这一步对于第一个环以外的每个环都恰好要乘以一个 $l_i$），每个新方点代表的点双的组成方案数依然是 $f_{a_i+1,1}$，然后组成圆方树的方案数根据上面的讨论可知是 $l_1 n^{m-1}$，所以刚好每个 $l_i$ 都恰好要乘上一次可以提出来，其余部分和上面类似。汇总下即为

$$h_n+\sum\limits_{m=1}^n\frac{1}{m!}\sum\limits_l\binom{n-1}{l_1-1,l_2,\cdots,l_m}\prod\limits_{i=1}^mh_{l_i}l_i\sum\limits_{k=1}^m\frac{n^{k-1}}{k!}\sum\limits_{a}\binom{m-1}{a_1,a_2,\cdots,a_k}\prod\limits_{j=1}^kf_{a_j+1,1}$$

其中 $h_i$ 表示有标号大小为 $i$ 的无向偶环数。一开始先加一个 $h_n$ 是因为我们正常统计不到只有一个环的情况。

稍微优化一下背包即可 $O(n^3)$ 计算。

[submission](https://atcoder.jp/contests/agc065/submissions/61765600)

---

## 作者：littlez_meow (赞：1)

过 $u$ 的路径与 $v_3$ 连通；然后断开 $(u,v_1)$，这种条件非常复杂的题目，先研究如何判定。

对一个合法的图的每个点双考虑。设 $S_u$ 表示 $u$ 和点双外部挂在 $u$ 上的点的个数。

容易发现，对于所有点双中的点 $u$，我们有 $S_u$ 的奇偶性相同。否则，我们必然可以找到两个点 $u,v$，其中 $2|S_u,2\nmid S_v$，满足 $u,v$ 相邻。此时 $u$ 已经和外面某个挂的点匹配了，$v$ 没有。让生成树里保留边 $(u,v)$，$v$ 就永远匹配不了。

如果所有 $S_u$ 都是偶数，所有点都和外面挂着的某个点匹配，没有限制。

否则，所有点都在点双内匹配。首先点数是偶数，这是容易的。然后每个点度数 $\le2$，下面使用反证证明。假设 $u$ 连了 $v_1,v_2,v_3$，考虑这样两棵生成树：连 $(u,v_1)$，$v_1,v_2$ 用不经连 $(u,v_2)$。如果这两个都有完美匹配，代表以 $v_3$ 为根时 $v_1,v_2$ 都在自己的子树内部匹配。于是断开 $v_1,v_2$ 连向父亲的边，连 $(u,v_1),(u,v_2),(u,v_3)$，这个生成树没法把 $u,v_1,v_2$ 都匹配掉，矛盾。

综上所述，如果 $S_u$ 都是奇数，这个点双一定是偶环或者两点一边。称这两个结构是一个新点。

根据上面的讨论，可以使用如下方式不重不漏构造出所有合法的图：初始时是若干新点；每次选择 $\ge2$ 个连通块，每个连通块中选出一个点，连成点双；连通时停止。

这个图在新点的意义下是一个有若干点双的有标号连通图。

终于可以开始计数了。先计算 $n$ 个点 $m$ 个点双的连通图数量 $f(n,m)$ 和 $n$ 个点连通图数量 $g(n)$。注意区分 $n,N$。

先是 $g(n)$ 的转移。可以写暴力多项式求 $\ln$，也可以容斥。具体地，枚举包含节点 $1$ 的极大连通块，剩下的随意连边，有：

$$g(n)=2^{\binom{n}2}-\sum\limits_{i=1}^{n-1}\dbinom{n-1}{i-1}2^{\binom{n-i}2}g_i$$

其中 $i$ 是极大连通块大小，$\dbinom{n-1}{i-1}$ 是给连通块里的点分配标号，$2$ 的幂是内部随意连边的方案数。

$f(n,1)$ 也可以容斥出来，即：

$$f(n,1)=g(n)-\sum\limits_{i=2}^{n-1}f(n,i)$$

接下来是 $f(n,m)$，其中 $m\ge 2$。对圆方树计数，钦定 $1$ 是根，其中 $n$ 个圆点 $m$ 个方点，设第 $i$ 个方点的儿子数是 $d_i$。把方点和其儿子视为一个整体，连成一棵树。如果现不考虑方点的存在，就是典中典 $m+1$ 个大小分别为 $1,d_1,\cdots,d_m$ 的连通块加边连成树，Prüfer 序列得到方案数是 $n^{m-1}\prod_{i=1}^m d_i$。再把方点考虑进来，最后都是方点连向父亲，每个连通块里是哪个点连的都不重要，每种方案被重复算了 $\prod\limits_{i=1}^m d_i$，除掉之后就是 $n^{m-1}$。乘上方点内部的方案数和分配标号的方案数，除掉方点无标号导致多算的系数，有：$f(n,m)=\dfrac{n^{m-1}}{m!}\sum\limits_{d_1+\cdots+d_m=n-1}\dbinom{n-1}{d_1,\cdots,d_m}\prod\limits_{i=1}^m f(d_i+1,1)=\dfrac{n^{m-1}(n-1)!}{m!}\sum\limits_{d_1+\cdots+d_m=n-1}\prod\limits_{i=1}^m\dfrac{f(d_i+1,1)}{d_i!}$。

后面是典型的背包卷积，于是设 $h(n,m)=\sum\limits_{d_1+\cdots+d_m=n-1}\prod\limits_{i=1}^m\dfrac{f(d_i+1,1)}{d_i!}$。注意到 $N\ge 2$，故方点都有儿子，即 $d_i\ge 1$。有转移 $h(n,m)=\sum\limits_{d_m=1}^{n-1}\dfrac{h(n-d_m,m-1)f(d_m+1,1)}{d_m!}$，整理下：

$$h(n,m)=\sum\limits_{d_m=1}^{n-1} h(n-d_m,m-1)h(d_m,1）$$

代回 $f$ 的转移：

$$f(n,m)=\dfrac{n^{m-1}(n-1)!h(n,m)}{m!}$$

最后统计答案。枚举初始放入的新点个数 $x$，连成的点双个数 $y$，第 $i$ 个新点的大小 $s_i$，然后式子和前面计算 $f$ 的差不多，就是总点数变成 $N$ 了。具体地，此时的贡献为 $\dfrac{N^{y-1}(x-1)!h(x,y)\prod_{i=1}^x s_i}{y!}$。

然后再做一个 $\sum\limits_{i=1}^x s_i=N$ 的背包就可以得到结果了。具体地，设 $H(n,s)$ 表示当 $x=n,\sum\limits_{i=1}^x s_i=s$ 的 $\prod_{i=1}^x s_i$，则转移为：

$$H(n,s)=\sum\limits_{s_n=2}^{s}[2|s_n]s_n H(n-1,s-s_n)\dbinom{s-1}{s_n-1}G(s_n)$$

初值 $H(0,0)=1$。

其中 $[2|s_n]$ 是因为新点大小一定是偶数（偶环或两个点）。$G(x)$ 是 $x$ 个点的新点方案数，$x=2$ 是 $1$，否则是 $\dfrac{(x-1)!}2$。组合数是分配标号。

最后答案为：

$$G(N)+\sum\limits_{x=1}^N\sum\limits_{y=1}^{x-1}\dfrac{N^{y-1}(x-1)!h(x,y)H(x,N)}{y!}$$

后半部分是 $\ge 2$ 个新点，前面是一个新点。

看起来或许可以用神秘的在线或半在线卷积做到 $\overset{\sim}{O}(n^2)$，不过暴力做时间复杂度 $O(n^3)$ 已经足够了。

一定一定想好转移顺序再写。

### 代码

```cpp
#include<bits/stdc++.h>
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
using namespace std;
const int MAXN=505;
int N,MOD;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
}
ll fact[MAXN],inv[MAXN];
inline ll C(int x,int y){
	return x>=y?fact[x]*inv[y]%MOD*inv[x-y]%MOD:0;
}
inline ll G(int x){
	return x==2?1:fact[x-1]*inv[2]%MOD;
}
ll f[MAXN][MAXN],g[MAXN],h[MAXN][MAXN],H[MAXN][MAXN];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>N>>MOD;
	fact[0]=1;
	F(i,1,N) fact[i]=fact[i-1]*i%MOD;
	inv[N]=qpow(fact[N],MOD-2);
	R(i,N,1) inv[i-1]=inv[i]*i%MOD;
	g[1]=1;
	F(n,2,N){
		g[n]=qpow(2,n*(n-1)/2);
		F(i,1,n-1) g[n]=(g[n]-C(n-1,i-1)*qpow(2,(n-i)*(n-i-1)/2)%MOD*g[i]%MOD+MOD)%MOD;
	}
	F(n,2,N){
		F(m,2,n-1) f[n][m]=qpow(n,m-1)*fact[n-1]%MOD*h[n][m]%MOD*inv[m]%MOD;
		f[n][1]=g[n];
		F(i,2,n) (f[n][1]-=f[n][i])<0&&(f[n][1]+=MOD);
		h[n][1]=f[n][1]*inv[n-1]%MOD;
		F(m,2,N) F(dm,1,n-1) h[n+1][m]=(h[n+1][m]+h[n+1-dm][m-1]*h[dm+1][1])%MOD;
	}
	H[0][0]=1;
	F(n,1,N) F(s,1,N) if(!(s&1)) F(sn,2,s) if(!(sn&1)) H[n][s]=(H[n][s]+sn*H[n-1][s-sn]%MOD*C(s-1,sn-1)%MOD*G(sn))%MOD;
	ll ans=G(N);
	F(x,1,N) F(y,1,x-1) ans=(ans+qpow(N,y-1)*fact[x-1]%MOD*h[x][y]%MOD*H[x][N]%MOD*inv[y])%MOD;
	cout<<ans;
	return 0;
}
```

---


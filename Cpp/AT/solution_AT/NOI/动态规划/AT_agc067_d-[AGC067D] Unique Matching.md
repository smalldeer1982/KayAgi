# [AGC067D] Unique Matching

## 题目描述

定义 $n$ 个区间是**好的**，当且仅当：

>* $1 \leq l_i \leq r_i \leq N$。
>* 存在唯一的 $N$ 阶排列 $x_1,x_2,\cdots,x_N$，使得 $x_i \in \left[ l_i , r_i\right]$

给定整数 $N$、素数 $P$。

求有多少组 $\left[l_1,r_1\right],\left[l_2,r_2\right],\cdots,\left[l_N,r_N\right]$ 是**好的**。

答案对 $P$ 取模。

## 说明/提示

* $2 \leq N \leq 5000$
* $10^9 < P <1.01 \times 10^9 $
* $P$ 为素数
* 所有输入值均为整数

#### 样例解释 #1
以下为 $6$ 个**好的**排列： 
- $ ([1,1],[2,2]) $ 
- $ ([1,2],[2,2]) $ 
- $ ([1,1],[1,2]) $
- $ ([2,2],[1,1]) $ 
- $ ([2,2],[1,2]) $ 
- $ ([1,2],[1,1]) $

## 样例 #1

### 输入

```
2 1005488041```

### 输出

```
6```

## 样例 #2

### 输入

```
5 1005488041```

### 输出

```
102960```

## 样例 #3

### 输入

```
100 1005488041```

### 输出

```
47599495```

## 样例 #4

### 输入

```
1000 1005488041```

### 输出

```
632708165```

# 题解

## 作者：zhiyin123 (赞：4)

似乎之前没有和该做法一样的题解。

本文中，为了保护视力 (\*^\_^\*)，将用***中括号*包裹部分*索引***。

对于一个***区间序列*** $S=\{[l_1,r_1],[l_2,r_2],\dots,[l_n,r_n]\}$ 和一个 $1$ 到 $n$ 的***排列*** $P$，定义

- $S$ ***对应*** $P$

当且仅当 $P[1]\in [l_1,r_1],P[2]\in [l_2,r_2],\dots,P[n]\in [l_n,r_n]$。

这题要我们做的就是，对所有长为 $n$ 的、**仅对应唯一排列的***区间序列*计数。 

排列很烦，先把排列强制为 $\{1,2,\dots,n\}$，答案最后再乘上 $n!$。这是不会算重的（如果算重了，就说明一个*区间序列对应*了多个排列）。

这样，问题就变成了

- 求有多少个*区间序列* $S$，满足 $S$ ***对应*且仅*对应***排列 $\{1,2,\dots,n\}$。

现在来考虑一个问题，假设我们已经获得了一个*区间序列* $S$，如何判断它是否唯一*对应*排列 $\{1,2,\dots,n\}$。

不妨画一个*方阵* $\mathbf M$ 来辅助思考。这个方阵是 $n\times n$ 的，每个位置是 $0$ 或 $1$。对于坐标为 $(x,y)$ 的位置，

$$\mathbf{M}[x][y]=[y\in [l_x,r_x]]$$
（对于命题 $p$，若 $p$ 为真，则 $[p]=1$，否则 $[p]=0$）

例如，*区间序列*为 $\{[1,3],[2,2],[3,3],[2,4]\}$，那么画出的方阵为：（**坐标 $(1,1)$ 的位置在左下角**）

$$
\begin{matrix}
0 & 0 & 0 & 1\\
1 & 0 & 1 & 1\\
1 & 1 & 0 & 1\\
1 & 0 & 0 & 0
\end{matrix}
$$

容易发现，*区间序列*和方阵是**一一对应**的。

对于一个*区间序列* $S$，画出方阵 $\mathbf M$，我们能找到一个让 $S$ 唯一对应排列 $\{1,2,\dots,n\}$ 的***冲要条件***：

- 存在一个坐标 $(x,x)$，满足 $\mathbf{M}[x][x]=1$，且 $\forall j\neq x$，有 $\mathbf{M}[j][x]=0$，且**删除 $\mathbf{M}$ 中 $(x,x)$ 所在行和所在列后，得到的方阵仍满足此条件**。

正确性是容易验证的。这个条件是递归性的，并且可以 *dp*。

但是，如果存在多个可以第一次删除的坐标怎么办呢？考虑容斥，**钦定**一些位置可以在第一次删除。

设 $i\times i$ 且满足要求的方阵有 $g[i]$ 个，则可写出如下容斥计数式子：（其中 $(v_1,v_1),(v_2,v_2),\dots,(v_m,v_m)$ 就是被钦定可以第一次删除的位置）

$$
g[i]=\sum_{m=1}^i\sum_{1\leq v_1<v_2<\cdots<v_m\leq n} (-1)^{m+1}v_1\left(\prod_{i=2}^m(v_i-v_{i-1})^2\right)(n-v_m+1)g[v_1-1]\left(\prod_{i=2}^m g[v_i-v_{i-1}-1]\right)g[n-v_m]
$$

然后可以用“辅助数组” $h$ 帮助转移：

$$
\begin{gathered}
h[i]=ig[i-1]+(-1)\sum_{j=1}^{i-1}h[j](i-j)^2g[i-j-1]\\
g[i]=\sum_{j=1}^ih[j](i-j+1)g[i-j]
\end{gathered}
$$

当然，有初始值 $g[0]=1$，而答案就是 $n!g[n]$。

直接 *dp* 空间复杂度为 $O(n)$，时间复杂度为 $O(n^2)$。

**代码**：

```cpp
#include<bits/stdc++.h>
using std::cerr; using std::setw; using std::endl;
using std::cin; using std::cout;
template<typename Tp>
bool tomax(Tp &x,const Tp &y){if(x<y){x=y; return 1;} return 0;}
template<typename Tp>
bool tomin(Tp &x,const Tp &y){if(y<x){x=y; return 1;} return 0;}
using ll=long long; using ui=unsigned; using lf=double;
using ull=unsigned long long;
constexpr ll MAXN=5000;
ll N,P;
ll mo(ll x){return x>=P?x-P:x;}
void n_add(ll &x,ll y){x=mo(x+y); return ;}
void n_sub(ll &x,ll y){x=mo(x+P-y); return ;}
ll pow2(ll x){return x*x%P;}
ll fac[MAXN+5];
ll g[MAXN+5],h[MAXN+5];
int main(){
    std::ios::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);
    cin>>N>>P;
    fac[0]=1ll; for(ll i=1;i<=N;i++) fac[i]=i*fac[i-1]%P;
    g[0]=1ll;
    for(ll i=1;i<=N;i++){
        h[i]=i*g[i-1]%P;
        for(ll j=1;j<i;j++){
            n_sub(h[i],h[j]*pow2(i-j)%P*g[i-j-1]%P);
        }
        for(ll j=1;j<=i;j++){
            n_add(g[i],h[j]*(i-j+1)%P*g[i-j]%P);
        }
    }
    ll ans=g[N]*fac[N]%P;
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：隔壁泞2的如心 (赞：4)

虽然我似乎已经做出来过 $O(n)$ 道 AT 3000+了，但是事实上我会的也只是 $n$ 道中的 $O(1)$ 道……

首先很显然，我们只需求出只能匹配成 $p_i=i$ 的区间集数量，然后乘上 $n!$ 即可。这样有 $l_i\le i\le r_i$，我们就可以把 $l_i$ 和 $r_i$ 分开计算了。

我们可以在平面上绘制 $2n$ 条线段连接 $(i,i),(r_i,i)$ 和 $(i,i),(i,l_i)$。合法的充要条件就是这 $2n$ 条线段互相不在 $(i,i)$ 以外的地方相交（不然交换某两项就也能匹配上了）。考虑把横向的线段画完后，每个竖线都不能触碰类似下图的白色区域：

![](https://cdn.luogu.com.cn/upload/image_hosting/wq3g492t.png)

所以我们不妨直接针对白色区域的形态进行计数。固定白色区域形态后，横线和竖线的方案数都可以简单算出。而对于白色区域而言，只要枚举白色区域的最靠右的空列就可以简单地转移。这个 dp 有很多种方法，就不细说了（


```cpp
dp[1][0]=1;dp[0][0]=1; 
for(int i=2;i<=n;i++){
   	for(int j=1;j<i;j++){
   		add(dp[i][1],mut({dp[i-j][1]+dp[i-j][0],dp[j][0],i-j+1}));
		add(dp[i][2],mut({dp[i-j][1]+dp[i-j][0],dp[j][0],1}));
	}
	for(int j=1;j<i;j++)add(dp[i][0],mut({dp[i-j][0],dp[j-1][2]+dp[j-1][0],i}));
}
printf("%lld",(dp[n][0]+dp[n][2])*fac[n]%mod);
```

——主要是因为我这十行不到的 dp 调了两个多小时！！现在我知道我其实不会 dp 了……

---

## 作者：xuanxuan001 (赞：3)

# Upd

- 2024.11.7 改正了一个笔误，感谢 @YuJiahe 的提醒。

竟然自己做出来了 3300+，~~早知道就打这场 AGC 的~~，但也想了很久，而且想到之前也很绝望，C 看了也没思路，完全猜不到结论。真是赛时也不一定会看这道题并坚持想。过 AD 的表现分也就 3300 那样，也没比之后那场 ARC 高太多，就这样吧。

[不知道该叫啥的链接](https://atcoder.jp/contests/agc067/editorial/10831)

思路跟官方题解在第二步就分道扬镳。

第一步的转换是一样的~~这步真的会有不一样的吗~~，就是由于匹配方式唯一，所以直接认为匹配是 $x_i = i$，之后给答案乘上 $n!$ 即可。

那么怎么确定答案是否唯一呢？行列式？不太行，因为方案不唯一不代表行列式一定为 $0$，有反例 $\{[1,2],[1,3],[2,3]\}$，之前在某次模拟赛的时候猜过这个结论但发现了问题并想出了正解，但那次直接把这个假做法放过去了，火大。

考虑如果给定了这些区间一般会怎么判定，首先一定存在长度为 $1$ 的区间，否则答案一定不唯一。然后给这些长度为 $1$ 的位置直接分配，之后不断产生新的只包含一个没有确定值的位置的区间再进行分配，只有用这种方式可以分配完所有区间匹配才唯一。

这个过程看上去很可 DP，但似乎不太可转移。从前往后枚举确定的位置似乎不太可行，因为此时的限制是它可以覆盖它周围的之前被选过的位置，这样就要把这些全部计入状态，没啥前途。

但反过来考虑最后被确定的倒很可行，这时的限制是之后（操作的之前）的所有区间都不能覆盖它，因为那时它都没有值，那么整个序列就在它这里劈开了，并且这个最后区间可以任意覆盖~~宁教我覆天下人，休教天下人覆我（雾）~~。天啊，简直就是个完美的转移模型！

但不用想都知道这样会算重，因为这本质就是个拓扑序，而能放在最后的点会有很多，这时考虑经典的子集容斥转移应该能做并优化到正解复杂度，写题解的时候想了一下，但我没那么做（？），留给读者自行拓展。

考虑怎么做到只转移编号最小的可转移位置，设它为 $p$。那么考虑它时最小的位置说明什么，说明任意一个小于 $p$ 的位置都不能转移（？），也就是被一个除自己外的区间覆盖，而 $[l_p,p)$ 已经被 $p$ 覆盖了，所以只需要保证 $[1,l_p)$ 被覆盖即可。

那么考虑将这个限制也加入状态，记 $f_{i,j}$ 表示共有 $i$ 个位置，并且最左边的 $j$ 个被限制必须被一个其他的区间覆盖的方案数，答案即 $f_{n,0}$。

转移考虑枚举 $p$ 与 $l_p$，显然 $p$ 只能在右边的 $i-j$ 个里，下面进行分讨：

1. $l_p \le j$，那么 $[l_p,j]$ 的位置已经被覆盖，限制已满足，因此会转移到 $f_{p-1,l_p-1}$。
2. $l_p > j$，那么新产生的限制强于状态给的限制，因此会转移到 $f_{p-1,l_p-1}$。

神奇，两种情况的结果一样，求出右边的情况后可以写出转移式，边界即 $f_{0,0}=1$：

$$
f_{i,j} = \sum\limits_{p = j+1}^i \sum\limits_{l_p = 1}^p f_{p-1,l_p-1}f_{i-p,0}(i-p+1)
$$

稍微整理一下，把变量名改的好看点（？）：

$$
f_{i,j} = \sum\limits_{k = j}^{i-1} \sum\limits_{l = 0}^{k-1} f_{k,l}f_{i-k-1,0}(i-k)
$$

写出来，发现答案对了，那么考虑优化。

看一眼这个式子就知道，里面 $l$ 的枚举没啥意义，因为只涉及一个变量，直接设 $g_i = \sum\limits_{j=0}^{j=i-1} f_{i,j}$，那么变成：

$$
f_{i,j} = \sum\limits_{k = j}^{i-1} g_kf_{i-k-1,0}(i-k)
$$

然后仔细观察发现这像是个后缀和的样子，于是可以优化为：

$$
f_{i,j} = f_{i,j+1} + g_jf_{i-j-1,0}(i-j)
$$

同时处理 $g$，做到 $O(n^2)$，[代码](https://atcoder.jp/contests/agc067/submissions/57203335)，代码中的 $dp_{i,j} = f_{i+j,i}$，一开始是这么推的，但发现改成题解里的那样更简洁。

---

## 作者：JWRuixi (赞：2)

## [AGC067D] Unique Matching

### 题意

定义 $n$ 个区间 $[L_1, R_1], \dots, [L_n, R_n]$ 是好的，当且仅当存在唯一的排列 $p_{1, \dots, n}$，使得 $p_i \in [L_i, R_i]$。给定 $n$，求合法的区间序列数量，对大质数 $P$ 取模的结果。

$n \le 5000$。

### 分析

由于对应的排列唯一，所以可以认为 $p = (1, \dots, n)$，最后在乘上 $n!$ 就可以了。

那么排列唯一带来的限制是什么呢，就是不能交换两个区间匹配的位置。那就是**不存在**两个区间 $[L_i, R_i]$ 和 $[L_j, R_j]$（$i < j$）满足 $j \in [L_i, R_i] \land i \in [L_j, R_j]$。注意到一定要求 $i \in [L_i, R_i] \land j \in [L_j, R_j]$，所以这个限制可以转化为不能存在 $j \le R_i, i \ge L_j$。

不妨将这个限制看成若干个 $j$ 对 $R_i$ 的限制，即 $\forall \ L_j \le i < j$ 要求 $R_i < j$。假设固定了 $L$ 序列，记 $a_i = \min\limits_{L_j \le i < j} j$（不存在设为 $n + 1$），那么 $R$ 的方案数就是 $\prod (a_i - i)$。

这个可以看成是对于固定的 $a$，怎么计数 $L$ 序列的方案数。设 $f(l, r)$ 表示 $[l, r]$ 这个子问题的方案数，钦定 $L_{r + 1}$ 在之前的决策中已经确定，即 $L_{r + 1} < i$；$g(l, r)$ 表示 $[l, r]$ 这个子问题的答案，但是 $L_{r + 1}$ 尚未确定，但是钦定 $\forall \ l \le k \le r, a_k \le r + 1$。

转移可以考虑枚举 $a_k = r + 1$，其中 $l \le k \le r$，由于 $a_{r} = r + 1$，所以这样的 $k$ 是一定存在的，具体的还要钦定这是区间中第一个满足条件的 $k$。有：
$$
f(l, r) = \sum\limits_{k} g(l, k - 1) f(k + 1, r) ((r + 1) - k) \\
g(l, r) = \sum\limits_{k} g(l, k - 1) f(k + 1, r) ((r + 1) - k) (k - l + 1)
$$
由于 $a_k = r + 1$，所以 $\forall \ k < i \le r$ 都满足 $L_i \ge k + 1$。有因为我们钦定 $k$ 是第一个满足 $a_k = r + 1$ 的位置，所以 $\forall \ l \le j < k$，都有 $a_j \le r$，那结合上一个结论，进一步的就有 $a_j \le k$。所以一定能将 $[l, r]$ 拆成 $[l, k - 1]$ 和 $[k + 1, r]$ 两个子问题考虑。后面的系数分别是 $(a_k - k)$ 的贡献和决定 $L_{r + 1}$ 的方案数。

实际上到这里我们就可以发现，我们的贡献实际上和绝对位置没有关系，关心的是相对距离，也就是说 $f/g(l, r)$ 的取值之和 $r - l + 1$ 有关，那么可以将式子改写为：
$$
f(i) = \sum\limits_{j = 1}^i g(j - 1) f(i - j) (i - j + 1) \\
g(i) = \sum\limits_{j = 1}^i g(j - 1) f(i - j) (i - j + 1) j
$$
直接做复杂度 $\mathcal O(n^2)$，可以用任意模分治 FFT 做到 $n\log^2n$，但是谁写这种东西 /oh

### Code

提交记录：<https://atcoder.jp/contests/agc067/submissions/59209766>。

---


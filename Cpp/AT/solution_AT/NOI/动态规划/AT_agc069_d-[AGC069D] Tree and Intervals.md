# [AGC069D] Tree and Intervals

## 题目描述

给出两个整数 $N$ 和素数 $P$。

我们有一棵由 $N$ 个节点组成的树，节点的编号从 $1$ 到 $N$。树有 $N-1$ 条边，每条边连接两个节点，记为 $a_i$ 和 $b_i\ (1 \leq i \leq N-1)$。接下来，我们定义 $x_j\ (1 \leq j \leq N-1)$ 为：

- 满足 $\min(a_i, b_i) \leq j < \max(a_i, b_i)$ 的边数，个数记为 $x_j$。

你的任务是计算可能的 $(x_1, x_2, \ldots, x_{N-1})$ 组合的数量，并输出此数量除以 $P$ 的余数。

## 说明/提示

### 约束

- $2 \leq N \leq 500$
- $10^8 \leq P \leq 10^9$
- $P$ 是素数

### 示例解释

对于一个包含 $3$ 个节点的树，总共有 $3$ 种不同的构型，不区分边，仅区分节点。每种构型对应的 $(x_1, x_2)$ 分别为 $(1, 1), (2, 1), (1, 2)$。因此，输出的结果应该是 $3$ 对 $P=998244353$ 取模的余数。

请计算上述结果并输出。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 998244353```

### 输出

```
3```

## 样例 #2

### 输入

```
69 433416647```

### 输出

```
243082757```

# 题解

## 作者：Rainbow_qwq (赞：7)

感觉这个题可做啊，真该先开这个题的/fn

$x_i$ 可以看作一端 $\le i$，另一端 $>i$ 的边数，进一步可以转化为：把 $\le i$ 的点染成黑色，$>i$ 的点染成白色，得到的总连通块数。

考虑判定怎样的“总连通块数”序列是可以被生成的。

一个个把点染黑，维护当前的黑色连通块数 / 总连通块数。

如果某一步总连通块数不变，那这步可以忽略。

如果某一步总连通块数增大，那黑色连通块数可能 $+0$ 或 $+1$（如下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/tjquoemj.png)

如果某一步总连通块数减小，那黑色连通块数需要减小，有两种减小方式（如下图）：

- 第一种方式：总连通块数 $-cnt$，黑色连通块数 $-cnt$。
- 第二种方式：总连通块数 $-(cnt+1)$，黑色连通块数 $-cnt$，此时要保证有 $\ge 2$ 个白色连通块（否则所有白色都消失了），或者这是最后一次操作。

最后操作完要保证黑色连通块数 $\ge 1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/m7ad6pnc.png)

显然黑色连通块数越多越好，这样可以保证不被减到 $\le 0$。

我们可以贪心，维护当前能达到的最大黑色连通块数。由于第二种方式比第一种减少的更少，如果能用第二种方式就用第二种，否则用第一种。

设 $f(i,j,s)$ 表示黑色连通块数为 $j$，当前总连通块数为 $s$ （这也确定了白色连通块的个数 $=s-j$）的方案数，其中 $j$ 这一维贪心计算。

枚举到下一个位置的连通块变化数，据此可以写出 $O(n^4)$ 的转移：

```cpp
int n;
modint f[505][505][505];
signed main()
{
	n=read(),initmod();
	For(i,2,n) f[1][1][i]=1;
	For(i,1,n-1){
		For(j,1,n) For(s,1,n) if(f[i][j][s].x) {
			int wh=s-j;
			For(k,1,n) if(s+k<=n) f[i+1][j+1][s+k]+=f[i][j][s];
			f[i+1][j][s]+=f[i][j][s];
			For(k,1,n) {
				int jj=j-(k-1)-(wh<=1 && i<n-1);
				if(jj>=1 && jj<=n && s-k>=1) f[i+1][jj][s-k]+=f[i][j][s];
			}
		}
	}
	modint res=0;
	For(j,1,n)res+=f[n][j][1];
	cout<<res.x;
	return 0;
}
```

发现转移可以前缀和优化到 $O(n^3)$，就做完了。[submission](https://atcoder.jp/contests/agc069/submissions/60184091)

---

## 作者：qiuzx (赞：3)

先考虑如何判定一个序列 $x$ 是否合法。可以发现 $x$ 的差分序列 $d$ 中 $d_i$ 表示的含义是树上所有以 $i$ 为端点的边中，连接 $>i$ 的点的边数减去连接 $<i$ 的点的边数，分别记这两个数目为 $a_i,b_i$，则 $d_i=b_i-a_i$，而 $x_i=\sum_{j\le i}b_j-a_j$。显然 $d$ 和 $x$ 是一一对应的关系，所以只需对 $d$ 判定即可。

如果我们确定了所有 $a_i,b_i$，是否可以判定合法性呢？可以先尝试找到一些必要条件。容易发现 $\sum a_i=\sum b_i=n-1$，$a_1=b_n=0$，且 $\forall 1\le i<n,\sum_{j\le i}a_j<\sum_{j\le i}b_j$。这三个条件保证了能连出 $n-1$ 条边，且每条边 $(u,v)(u<v)$占用一个 $u$ 的 $b_u$ 和 $v$ 的 $a_v$。

不过还有一个限制是连出来的边必须是一棵树。对于这个限制，我们考察每个前缀，如果能保证所有前缀都能连成一个森林，使得其中每个连通块都向后有剩余的 $b_i$，那么最终一定是能连成一棵树的。注意到对于一个前缀，其连通块数目恰好为 $i-\sum_{j\le i}a_j$，即每个点贡献一个连通块，但一个向前的边会删去一个连通块，因此为了保证这些连通块都有向后的边，一定需要满足 $0<i-\sum_{j\le i}a_j\le\sum_{j\le i}b_j-a_j$，因为 $\sum_{j\le i}b_j-a_j$ 表示的含义是前 $i$ 个点向后面的点连边的总数。

上面这些条件都是必要条件，事实上也可以证明它们是充分的，主要需要证明的是最后一个条件的充分性（前三个条件显然是连出 $n-1$ 条合法边的充要条件）。可以归纳证明存在一种连边方式，使得任意时刻每个连通块都有向后的边。具体来说，考虑在加入一个 $i$ 时，优先向前面有至少 $2$ 条向后的边的连通块连边。如果至少存在一个这样的连通块，或者 $b_i\ne 0$，则连一次之后这个点所在的连通块就一定存在向后的边，所以后面不管怎么连都合法了。另一方面，如果不存在这样的连通块，且 $b_i=0$，则不满足前面的条件，故不可能出现这种情况。

现在回到判定 $d$ 是否合法的问题。除了最后一个限制以外，其它限制可以直接把式子里的变量换成 $d_i$ 判定。而最后一个限制可以改写为 $\forall i,0<i-\sum_{j\le i}a_j\le\sum_{j\le i}d_j$，这个不等式的两端都是定值。注意到如果一组解满足除了 $\sum a_i=n-1$ 以外的所有条件（仍需满足 $\sum a_i=\sum b_i$），则随便在哪个地方将 $a_i,b_i$ 同时 $+1$ 一定仍然合法。这意味着对于一组给定的 $d$，我们只需确定 $\sum a_i$ 的最小值，并要求它 $\le n-1$ 即可。

考虑从前向后逐个贪心。首先令 $a_i=-d,b_i=0(d<0)$ 或 $a_i=0,b_i=d(d>0)$，特别地，若 $d=0$ 则令 $a_i=b_i=1$。如果此时违背了最后一条限制，就不断令 $a_i$ 加 $1$ 直到合法。由于限制只和 $a$ 的前缀和有关，所以实际上在哪里给 $a_i$ 加 $1$ 不影响答案，因此在这里将 $a_i$ 加 $1$ 不如放到后面需要的时候再增加，从而这个贪心算出的就是 $\sum a_i$ 的最小值。

最后回到原题，将上述判定过程放到 dp 中计数即可。具体来说，考察上述贪心过程，可以发现在 dp 中维护 $i,\sum d_i$ 以及 $\sum a_i$ 的最小值这三个值即可。转移时枚举 $d_i$，可以确定这一步最小的 $a_i$，从而能够更新状态。直接实现是 $O(n^4)$，但可以将转移按情况拆开，每种情况都可前缀和优化。复杂度 $O(n^3)$。

[代码](https://atcoder.jp/contests/agc069/submissions/60184893)

---

## 作者：JWRuixi (赞：2)

# [AGC069D] Tree and Intervals

### 题意

对于一棵 $n$ 个点的树，定义 $a_i(1 \le i < n) := \sum\limits_{(u, v) \in E} [\min(u, v) \le i \land i < \max(u, v)]$。

给定 $n, P$，求 $n$ 个点的有标号无根树能生成多少中不同的 $a$ 序列，输出答案对 $P$ 取模的结果。

$n \le 500$。

### 分析

转化太神奇了，感觉完全无法解释怎么想到的……

$a_i$ 实际上就是编号上跨过 $i$ 的边数。这个不好刻画，考虑类似差分的东西，记 $l_i$ 为从 $i$ 向左连的边数；$r_i$ 为从 $i$ 向右连的边数。那么可以发现 $a_i = \sum\limits_{j \le i} (r_j - l_j)$。

在转化的基础上考虑如何判定合法性，首先可以发现一些必要条件：

- 对于 $1 \le i \le n$，$l_i \ne 0$ 或 $r_i \ne 0$；特殊的，$l_1 = r_n = 0$；
- 显然有 $\sum\limits_{i \le n} l_i = \sum\limits_{i \le n} r_i = n - 1$；
- 由于 $l_1, \dots, l_i$ 描述的边构成了 $1, \dots, i$ 的生成森林，所以 $\sum\limits_{j \le i} l_j \le i - 1$；
- $1, \dots i$ 构成的连通块一定会和 $i + 1, \dots, n$ 连接在一起，所以每个连通块至少向后引出一条边，即对于 $1 \le i < n$，$a_i \ge i - \sum\limits_{j \le i} l_j$。

接下来我们将声称这是充要的。证明：我们称 $r_i$ 描述的边中尚未确定右端点的边为候选边，那么在确定 $l_i$ 描述的边的左端点时，我们优先考虑候选边数最多的连通块，按照这个策略就一定可以构造出合法的树了。

接下来考虑具体的计数，我们的核心问题在于多个 $\{l_n\}, \{r_n\}$ 序列可能对应同一个 $\{a_n\}$ 序列。经过观察我们发现我们对于 $r_i$ 的值没有具体的限制，也就是说 $r_i$ 可以随 $l_i$ 的需要进行调整，那么我们就只需要记录 $\sum\limits_{j \le i} l_j$ 的极值就可以保证无重了。

记 $dp_{i, j, k}$ 表示考虑了到 $i$，$a_i = j$、$\sum\limits_{t \le i} l_t$ 的最小值为 $k$ 的方案数。具体的转移就是枚举 $\sum\limits_{j < i} l_j$、 $a_{i - 1}$ 和 $a_i$，先不考虑限制计算出 $l_i$ 的最小值，此时可能不满足 $1 \le i - \sum\limits_{j < i} l_j \le a_i$ 的限制，不断增加 $l_i$（同时减小 $r_i$）进行调整只到符合限制。暴力转移 $\mathcal O(n^4)$。

优化考虑如果没有限制，则只存在三种转移：$l_i > 0, r_i = 0$ 或 $l_i = r_i = 1$ 或 $l_i = 0, r_i > 0$，这是可以用前缀和优化解决的。而我们的调整形如 $(j, k)$ 可以调整为 $(j + 1, k)$，所以我们可以先容许错误的转移，然后再整体进行调整。

复杂度 $\mathcal O(n^3)$。

### Code

提交记录：<https://atcoder.jp/contests/agc069/submissions/60180740>。

---

## 作者：zhenjianuo2025 (赞：0)

下文中使用 $S$ 代替题面中的 $x$ 序列。

Rainbow_qwq 的题解里给了一个惊人的转化：将 $[1,i]$ 中的点染黑，$S_i=$ 同色的黑连通块数 $+$ 同色的白连通块数 $-1$。

考虑不断染黑的过程，设当前黑色连通块数为 $x$，白色连通块数为 $y$，增加 $i$ 号点后黑块数变为 $x'$，白块数变为 $y'$。

显然 $x'\le x+1,y\le y'+1$。

另外可以发现不可能同时有 $x'=x+1$ 且 $y=y'+1$。

考虑 $i$ 号点周围的邻居中有 $p$ 个黑点 $q$ 个白点。染黑 $i$ 号点后黑块数增加了 $1-p$，白块数增加了 $q-1$。

显然当 $n>1$ 时不可能有 $p=q=0$，这也说明了为什么不能同时加一减一。

进一步地，考虑 $p+q=\deg u$，由于开始时 $x=0,y=1$ 结束时 $x=1,y=0$，因此 $\sum p+q=\sum\deg u=n-1$ 成立，且上面保证了 $\deg u\ne 0$，可以想象一定可以连成一棵树，猜测这是充要条件。

现在考虑如何判定是否存在上述 $x$ 和 $y$ 序列。


假设 $S_{i-1}=a$，$S_i=b$。当 $a\ne b$ 时，对于 $x'$ 要求 $1\le x'\le \min(n,x+1)$；对于 $y'$ 要求 $\max(1,y-1)\le y'\le n$，也就是 $\max(1,a-x)\le b-x'\le n$，即 $x'\le b-a+x$。当 $a=b$ 时，由于不能同时顶到界，要求 $x'\le x$，$y'\ge y$。

解方程得到 $x'$ 的取值范围是一段 $[1,j]$ 的区间，因此记录最大值 $j$ 即可。

设 $f_{i,j,a}$ 表示染色 $[1,i]$，黑块数目最多是 $j$，总连通块数为 $a$，枚举 $b$ 转移复杂度 $O(n^4)$。[代码。](https://atcoder.jp/contests/agc069/submissions/67261395)使用一些二维差分可以到 $O(n^3)$。[代码。](https://atcoder.jp/contests/agc069/submissions/67261967)

---


# [ARC180E] LIS and Inversion

## 题目描述

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\cdots,A_N)$。这里，保证对于每个 $i$，有 $0\leq A_i < i$。

对于 $(1,2,\cdots,N)$ 的一个排列 $P=(P_1,P_2,\cdots,P_N)$，定义其**分数**和**代价**如下：

- $P$ 的分数为 $P$ 的最长递增子序列的长度。
- $P$ 的代价为满足以下条件的整数 $i$（$1\leq i\leq N$）的个数：
  - 满足 $j<i$ 且 $P_j>P_i$ 的整数 $j$ 的个数小于 $A_i$。

对于每个 $k=1,2,\cdots,N$，请解决下列问题：

- 求分数至少为 $k$ 的排列 $P$ 的最小代价。

## 说明/提示

### 限制条件

- $1\leq N\leq 250000$
- $0\leq A_i < i$
- 输入的所有值均为整数

### 样例解释 1

对于每个 $k$，满足条件的 $P$ 如下：

- $k=1$：取 $P=(4,2,1,3)$，此时 $P$ 的分数为 $2$，代价为 $0$。
- $k=2$：取 $P=(4,3,1,2)$，此时 $P$ 的分数为 $2$，代价为 $0$。
- $k=3$：取 $P=(4,1,2,3)$，此时 $P$ 的分数为 $3$，代价为 $1$。
- $k=4$：取 $P=(1,2,3,4)$，此时 $P$ 的分数为 $4$，代价为 $3$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
0 1 2 1```

### 输出

```
0 0 1 3```

## 样例 #2

### 输入

```
3
0 0 0```

### 输出

```
0 0 0```

## 样例 #3

### 输入

```
5
0 1 2 3 4```

### 输出

```
0 1 2 3 4```

## 样例 #4

### 输入

```
11
0 0 2 3 4 5 3 7 8 2 10```

### 输出

```
0 0 0 1 2 3 4 5 7 8 9```

# 题解

## 作者：Hanghang (赞：20)

优美，太优美。

注意到逆序对和 $\text{LIS}$ 都是只用关注相对大小的，所以设计状态的时候大抵是要跟相对大小的排名有关的。

$\text{LIS}$ 并不好放入状态，考虑将其设为 $\text{dp}$ 数组的答案。

那么考虑将成本为 $0$ 的时候最大得分是多少（转换一下把个数大于等于 $a_i$ 看成有贡献的）。

设 $f_{i,j}$ 表示考虑了前 $i$ 个位置，$\text{LIS}$ 以**第 $j$ 大** 数为结尾的最长长度是多少。
$$
f_{i,j}=\max\begin{cases}
f_{i-1,j}   \\
f_{i-1,j-1} & j> a_i+1 \\
f_{i-1,k}+1  & k\ge j> a_i
\end{cases}
$$
$\max f_{n,i}$  即为最长 $\text{LIS}$。

根据定义我们可以推出 $f_{i,j}\le f_{i,j+1}+1$，因为交换第 $j$ 大和第 $j+1$ 大答案之多变化 $1$。

再仔细一看，发现第二种转移是无用的。

然后你注意到 $k>j$ 的转移也是无用的，因为你每次更新都是 $j$ 较大的答案才有可能变大，那对于 $k$，转移到 $k>j$ 肯定是不优没有转移到 $k=j$ 优的。

那么现在的转移变为：
$$
f_{i,j}=f_{i-1,j}+[j>a_i]
$$
那么对于每一列分别考虑，最终答案即为：
$$
g_i=\sum_{j\ge i}a_j< i\\
ans=\max_{i=1}^{n} g_i
$$
现在再考虑成本不为 $0$，成本加 $1$ 等价于将一个 $a_j$ 变成 $0$，设成本为 $x$，那么答案即为：
$$
ans=\max(x-\max_{i=1}^{n-x+1}g_i,0)
$$
$g_i$ 差分即可求得，然后求个前缀最大值就好了。

优美，太优美。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+3;
int n,f[N];
int main()
{
    cin>>n;
    for(int i=1,x;i<=n;i++)cin>>x,f[x+1]++,f[i+1]--;
    for(int i=1;i<=n;i++)f[i]+=f[i-1];
    for(int i=1;i<=n;i++)f[i]=max(f[i],f[i-1]);
    for(int i=1;i<=n;i++)cout<<max(i-f[n-i+1],0)<<" ";
}
```

---

## 作者：doctorZ_ (赞：6)

博客内食用更佳[ARC180E LIS and Inversion](https://www.cnblogs.com/the-blog-of-doctorZ/p/18284776)。

## 题目大意

一个排列 $p$ 的分数为 $p$ 的最长上升子序列的长度，代价为满足 $\sum_{j=1}^{i-1}[p_j>p_i]<a_{i}$ 的 $i$ 的数量。

给定 $\{a_n\}$ ，对于 $\forall k\in[1,n]$ ，求分数大于等于 $k$ 的排列的代价的最小值。
$$n\leq 250000,1\leq a_i<i$$

## 题解

玄妙优化 $dp$ 题。

我们可以考虑求出代价为$k$的排列分数的最大值，这个反过来就可以得到题目所求。

考虑代价为 $0$ 的排列分数的最大值，设 $f_{i,j}$ 表示考虑了前 $i$ 个数，从小到大排名为 $j$ 的数为结尾的最长上升子序列长度。

第一种转移，第 $i$ 个数为第 $k$ 名，原来 $[1,k-1]$ 名的数排名不动， $k$ 最大取 $i-a_i$ 。
$$f_{i-1,j}\rightarrow f_{i,j}(j<i-a_i)$$
第二种转移，第 $i$ 个数为第 $k$ 名，原来 $[k,i-1]$ 名的数排名上升一位。
$$f_{i-1,j-1}\rightarrow f_{i,j}$$
第三种转移，第 $i$ 个数为第 $j$ 名，可以从排名小于 $j$ 的数转移过来。
$$\max_{k=1}^{j-1}f_{i-1,k}+1\rightarrow f_{i,j}(j\leq i-a_i)$$
仔细思考，发现第一种转移是不必要的，因为不如直接让第 $i$ 个数为第 $j$ 名，从排名小于 $j$ 的数转移，这样肯定是不劣的，第三种转移也可以优化，对于一个 $k$ ，转移到 $j>k+1$ 是不优的。

于是转移变成，$f_{i,j}=f_{i-1,j-1}+[j\leq i-a_i]$
$$f_{n,j}=\sum_{i=1}^j[j-i+1\geq n-i+1-a_{n-i+1}]=\sum_{i=1}^j[j\leq n-a_{n-i+1}]$$
一个 $a_i$ 对 $f$ 的影响是一段区间，可以用差分算出， $\max_{j=1}^nf_{n,j}$ ，即为代价为 $0$ 时的分数最大值。

接下来考虑代价，假设让 $i$ 位产生代价 $1$ ，可以理解为将 $dp$ 转移时的 $f_{i,j}=f_{i-1,j-1}+[j\leq i-a_i]$ 变为 $f_{i,j}=f_{i-1,j-1}+1$ ，对最终 $f$ 的影响是使得 $j\in[n-a_i+1,n],f_{n,j}$ 加 $1$ ，那么可以贪心的按 $a_i$ 从大到小产生代价， $a_i$ 的排序可以用桶排实现。

时间复杂度为 $O(n)$ 。
## $\text{code}$
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=3e5+1000;
int n,a[N+10],f[N+10],g[N+10],h[N+10];
int main()
{
//	freopen("ARC180E.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),g[n-a[i]+1]++;
	for(int i=1;i<=n;i++) f[n-i+1]++,f[n-a[i]+1]--;
	for(int i=1;i<=n;i++) f[i]+=f[i-1];
	for(int i=n;i>=1;i--) f[i]=max(f[i],f[i+1]);
	for(int i=1;i<=n+1;i++) h[i]=n;
	h[f[1]]=0;
	int res=0;
	for(int i=1;i<=n;i++)
	{
		h[f[i]+res]=min(h[f[i]+res],res);
		while(g[i])
		{
			res++,g[i]--;
			h[f[i]+res]=min(h[f[i]+res],res);
		}
	}
	for(int i=n;i>=1;i--) h[i]=min(h[i],h[i+1]);
	for(int i=1;i<=n;i++) printf("%d ",h[i]);
	return 0;
}
```

---

## 作者：Alan_Zhao (赞：5)

## 题解

我们直接观察一些性质，由于最优方案的结构很简单，所以得出性质以后就做完了。

**性质 1**：在最优情况下，钦定的 LIS 在值域上是一段区间 $[l,r]$。

假如不是一个区间，设不在上升子序列中的值是 $x\in [l,r]$，LIS 的位置是 $i_1<i_2<\dots<i_k$，并认为 $i_0=0,i_{k+1}=n+1,P_0=-\infty,P_{n+1}=\infty$。假如 $x$ 的位置在 $i_j$ 和 $i_{j+1}$ 之间：

- 如果 $x<P_{i_j}$，将 $x$ 以及 $x$ 之后的 $<x$ 的部分整体向下平移，直到 $<l$；
- 如果 $x\in [P_{i_j},P_{i_{j+1}}]$，那么 $x$ 应当被放到 LIS 中；
- 如果 $x>P_{i_{j+1}}$，将 $x$ 以及 $x$ 之前的 $>x$ 的部分整体向上平移，直到 $>r$。

这里我们只关心数之间的相对大小关系，所以就算平移以后出现了 $<1$ 或 $>n$ 的数也无所谓，离散化一下就又是一个排列了。

---

所以，现在整个序列被分成了三部分：值 $>r$ 的部分，LIS，值 $<l$ 的部分。显然，值 $>r$ 的部分和值 $<l$ 的部分应该分别是单调递减的。

**性质 2**：值 $>r$ 的部分一定是一个 $P$ 的前缀。

设 $f(i)=\sum_{j<i} [P_j>P_i]$。

如果没有值 $<l$ 的部分，那么这个性质保证了 $[f(1),f(2),\dots,f(N)]=[1,2,3,\dots,N-r,N-r,\dots,N-r]$，在 $r$ 固定的情况下，这样的 $f$ 每一位都取到了可能取到的最大值。

如果有值 $<l$ 的部分，因为这样的部分对其他位置的 $f$ 没有影响，所以其他位置已经满足了这个性质。在这种情况下，如果一个 $<l$ 的位置左右都有 $>r$ 的位置，那么把它调整为 $>r$ 的位置是不劣的。

---

枚举值 $>r$ 的部分的长度 $i$，那么 $f(1),f(2)\dots,f(i)$ 一定满足条件。在剩下的位置中，值 $<l$ 的部分有 $f(k)=k-1$，一定满足条件；LIS 里的部分一定有 $f(k)=i$。

所以，我们算出 $C=\sum_{j=i+1}^{N} [A_j\le i]$，这 $C$ 个位置钦定它们在 LIS 中的代价是 $0$，其他位置在 LIS 中的代价是 $1$。对答案数组的影响是一个分两段的一次函数取 $\min$，容易维护。

时间复杂度 $O(N\log N)$，精细实现可以 $O(N)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define For(Ti, Ta, Tb) for (auto Ti = (Ta); Ti <= (Tb); ++Ti)
#define Dec(Ti, Ta, Tb) for (auto Ti = (Ta); Ti >= (Tb); --Ti)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define range(Tx) begin(Tx), end(Tx)
using ll = long long;
const int N = 2.5e5 + 5;
int n, a[N], ans[N], ins[N], tot[N];
vector<int> del[N];
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n;
	For(i, 1, n) {
		cin >> a[i];
		++tot[a[i]];
	}
	partial_sum(tot, tot + n, tot);
	fill(ans + 1, ans + n + 1, int(1e9));
	int mx = 0;
	For(i, 0, n - 1) {
		int cnt = tot[i] - i;
		mx = max(mx, cnt);
		ins[cnt + 1]++;
		del[n - i + 1].push_back(n - i + 1 - cnt);
	}
	fill(ans + 1, ans + mx + 1, 0);
	multiset<int> S;
	int add = 0;
	For(i, 1, n) {
		++add;
		For(j, 1, ins[i]) { S.insert(1 - add); }
		for (int j : del[i]) {
			S.erase(S.find(j - add));
		}
		if (S.size()) {
			ans[i] = min(ans[i], *S.begin() + add);
		}
	}
	For(i, 1, n) { cout << ans[i] << " \n"[i == n]; }
	return 0;
}
```

---

## 作者：qiuzx (赞：2)

先钦定 $k$ 个位置作为 LIS，然后考虑其它位置任意填的时候最小代价是什么。注意到在没有钦定任何位置的情况下直接倒序填是最优的，所以我们希望现在也尽可能保证这个倒序填的结构。但直接倒序填可能并不是最优的，因为在钦定了一些 $p_i<p_j$ 之后，$i,j$ 中间的部分要么不能对 $j$ 的 $\sum [p_k>p_j]$ 这个值（称这个为一个位置的权值）产生贡献，要么自己不能利用 $i$ 产生贡献，所以无法立即确定到底哪一种更优。

不过容易发现钦定的这 $k$ 个位置在最终排列中一定是值域连续的一段，这是因为假如某个位置放了一个介于其中两数之间的数，不妨设最左侧的一个这样的位置位于钦定的两个位置 $i,j$ 之间的某个 $k$。那么若 $p_k>p_i$，则不如将它变成比所有钦定位置的值都要大的最小的一个值，这样容易发现它的权值不会改变，且它会对后面所有钦定位置的权值都做出贡献。类似地，若 $p_k<p_j$ 则将它变得比所有都小，只会使得它的权值增加而不会改变其它位置的权值。

这样可以将所有钦定的值记作 $0$，所有比它们大的值记作 $1$，比它们小的值记作 $-1$。在不同类别的值之间，$1$ 会对 $0,-1$ 产生贡献，$0$ 会对 $-1$ 产生贡献。而同类别的值由于可以任意填，所以也均能产生贡献。然而 $0$ 必须钦定按顺序填，所以内部不能产生贡献。现在将权值的定义改为 $\sum [p_j<p_i]$，则对于每个 $0,1$，其前面的所有 $0,-1$ 均会对它产生贡献，而 $-1$ 的权值永远是 $0$。这样修改定义后一个位置对整个排列的代价有贡献的条件就是权值 $\ge i-a_i$，可以设 $b_i=i-a_i$。下面称一个位置不合法当且仅当其权值 $\ge b_i$。

现在容易写出一些多项式复杂度的 dp 等，但均无法进行优化。不过值得注意的是，我们只关心所有钦定 $k$ 个 $0$ 的方案中代价的最小值，并不一定需要对一种固定的局面求答案，因此从这一点出发可以进行分析。首先可以发现如果一个 $1$ 位置不合法，那么不如将第一个 $0$ 和当前位置进行交换。这是因为显然有 $b_i\ge 1$，所以第一个 $0$ 前面一定全是 $1$ 且它一定是合法的（因为这些位置填 $1$ 一定合法，那么如果填 $-1$ 只会给后面带来额外贡献，必然不优）。这样钦定了 $0$ 的位置之后只需要从左往右扫一遍，能填 $1$ 就填，否则直接填 $-1$，虽然这样不一定是当前局面的最优解，但是取遍所有情况后一定能求出答案。

接下来可以注意到，若两个 $0$ 之间有一个 $1$，那么直接将 $1$ 变成 $0$，前面的 $0$ 变成 $-1$ 一定更优。这是因为此时 $1$ 一定合法，所以变成 $0$ 还是合法的。而 $0,-1$ 在贡献这一方面是完全等价的，所以将 $0$ 变成 $-1$ 之后一定不会给后面增加额外的贡献，并且还可能让它自己变得合法，所以必然不会更劣。这样不断执行上述变换，会一直不断将 $0$ 的位置后移。那么一个最终的局面一定形如前面一坨 $1$，后面是一个由 $0,-1$ 组成的序列。

这个性质是非常好的，因为前面的 $1$ 全是合法的，那么后面就不需要考虑 $1$ 的问题了。此时后面的部分 $0,-1$ 均是会对其它位置产生贡献的值，因此确定了前后的分界点之后，后面每个位置的权值就是固定的。所以枚举分界点 $l$，则现在每个位置不合法的条件就是 $[i-l\ge b_i]$，即 $[i-b_i\ge l]$，由于 $b_i=i-a_i$，所以就是 $[a_i\ge l]$。现在初始是所有位置均是 $0$，现在共有 $n-l$ 个 $0$。那么每次可以选择一个位置变成 $-1$ 并将它变合法，这个操作显然每次会将一个位置变合法，直到所有位置合法，因此相当于对答案序列的一段区间和一个形如 $0,1,2,\cdots$ 的序列对位取 $\min$，这个直接把所有操作离线之后扫一遍整个序列用 set 维护当前仍然存在的所有修改即可。复杂度 $O(n\log n)$。

[代码](https://atcoder.jp/contests/arc180/submissions/550206720)

---

## 作者：WrongAnswer_90 (赞：1)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18381998)

### [[ARC180E] LIS and Inversion](https://www.luogu.com.cn/problem/AT_arc180_e)

首先考虑要求代价为 $0$ 的一个暴力 DP：$f_{i,j}$ 表示填了前 $i$ 个数，此时相对值域末尾为 $j$ 的数结尾的 LIS 的最大值。填第 $i+1$ 个数的时候，把它插在某两个数之间，所以转移是：

$$
f_{i,j}=
\begin{cases}
f_{i-1,j-1}\qquad\qquad\qquad j>i-a_{i}\\
\max_{k<j}\{f_{i-1,k}+1\}\quad 1<j\leq i-a_{i}\\
1\qquad\qquad\qquad\qquad\;\; j=1\\
\end{cases}
$$

经过观察，可以发现取前缀最大值的操作是不必要的，第二种情况可以直接令 $f_{i,j}=f_{i-1,j-1}+1$。

证明：假设存在 $f_{i-1,k}>f_{i-1,j-1}$，应当用 $k$ 贡献到 $j$。但是因为 $k+1\leq j\leq i-a_i$，所以 $k+1\leq i-a_i$，所以此时 $f_{i,k+1}\geq f_{i-1,k}+1$。在 $f$ 相同的情况下，显然是下标越小的越有前途，所以 $k+1$ 不劣于 $j$，$j$ 是没有用的。

这样 $f$ 的转移就变成了：先平移一位，在最前面加入 $0$，然后做一个 $[1,i-a_i]$ 的前缀 $+1$ 的操作。然后可以进一步发现，如果允许代价为 $k$，则可以看成把 $k$ 个位置的 $a_i$ 变成 $0$，即前缀加变成了全局加。

所以考虑统计每个位置被多少次前缀加覆盖，这可以用差分简单实现，这样就求出来了 $f$。在最后位置 $i$ 的答案上界是 $i$，所以可以花费 $j$ 的代价（$j\leq i-f_i$）来获得一个 $f_i+j$ 的答案。可以从 $n$ 到 $1$ 做一遍扫描线，每次令 $t_{f_i}=f_i$，还需要查询前缀 $\max$，可以用树状数组维护。总复杂度 $\mathcal O(n\log n)$。（最后这一步好像可以 $\mathcal O(n)$ 的谔谔）

```cpp
int n,a[250010],f[250010],ans[250010];
namespace BIT
{
	int t[250010];
	inline void add(int x,int y){for(;x<=n;x+=x&-x)Mmax(t[x],y);}
	inline int ask(int x){int s=0;for(;x;x-=x&-x)Mmax(s,t[x]);return s;}
}
using namespace BIT;
inline void mian()
{
	read(n);int x;
	for(int i=1;i<=n;++i)read(x),f[n-i+1]++,f[n-x+1]--;
	for(int i=1;i<=n;++i)f[i]+=f[i-1];
	for(int i=n;i>=1;--i)add(f[i],f[i]),ans[i]=i-ask(i);
	for(int i=1;i<=n;++i)write(ans[i]);
}
```

---

## 作者：intel_core (赞：1)

先考虑给定一个 $k$ 怎么求答案。

假设已经钦定了 $k$ 个下标构成题述的 LIS，那么剩下的数单减一定是最优的。

记钦定的 $k$ 个下标构成的集合是 $A$，其余的是 $B$。

设 $pos$ 为 $B$ 中最大的 $i$ 使得存在 $j\in A,j>pos$ 且 $p_{pos}>p_j$；那么对于 $B$ 中 $>pos$ 的数 $x$，显然可以把 $p_x$ 调整的尽量小来使得 $x$ 前有 $x-1$ 个数比 $a_x$ 大，此时可以发现组成 LIS 的数的值域是一段连续的区间。

因此假定组成 LIS 的数的值域是一个区间是不劣的。

此时对于 $\le pos$ 的所有下标 $i$，$i$ 前比 $p_i$ 小的个数是钦定的 $k$ 个下标中 $<i$ 的个数。所以我们把所有 $A$ 中 $>pos$ 的数都调整为 $>pos$，会使限制变松。

因此假设 $B$ 中的数都 $>pos$ 也是不劣的。

注意到此时 $B$ 中的 $x$ 都有在 $x$ 前且比 $p_x$ 小的数有 $x-1$ 个，已经是最严限制。而 $A$ 中的 $x$ 显然都有在 $x$ 前且比 $p_x$ 小的数有 $pos$ 个。

记 $c_i$ 表示在 $>i$ 的 $j$ 中 $a_j\le i$ 的有多少个。那么钦定了 $pos$ 后答案就可以表示为 $max\{0,k-c_{pos} \}$。

对于给定的 $k$，要求 $pos\le n-k$，因此把 $c$ 求一个前缀 $\max$ 即可。

复杂度是显然的 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=3e5+10;
int n,a[NR],val[NR],sum[NR],buc[NR];

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	int now=0;
	for(int i=n;i>=1;i--){
		now-=buc[i];
		now+=(a[i]<=i-1);buc[a[i]]++;
		val[i]=now;
	}
	for(int i=1;i<=n;i++)val[i]=max(val[i],val[i-1]);
	for(int i=1;i<=n;i++)cout<<max(0,i-val[n-i+1])<<' ';
	return 0;
}
```

---


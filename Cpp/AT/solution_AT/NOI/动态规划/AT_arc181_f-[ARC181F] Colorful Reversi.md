# [ARC181F] Colorful Reversi

## 题目描述

有一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$。对于该整数序列 $A$，可以进行如下操作：

- 选择满足 $A_l=A_r,\ A_{l+1}=A_{l+2}=\dots=A_{r-1},\ A_{l+1}\neq A_l$ 的 $l,r\ (1\leq l < r \leq N)$。将 $A_{l+1},A_{l+2},\dots,A_{r-1}$ 全部替换为 $A_l$。该操作的代价为 $r-l-1$。

当不存在满足 $A_l=A_r,\ A_{l+1}=A_{l+2}=\dots=A_{r-1},\ A_{l+1}\neq A_l$ 的 $l,r\ (1\leq l < r \leq N)$ 时，停止操作。请你求出一系列操作所需总代价的最小值。

## 说明/提示

## 限制条件

- $3 \leq N \leq 5 \times 10^5$
- $1 \leq A_i \leq N$
- 输入的所有值均为整数

## 样例解释 1

例如，依次进行 $(l,r)=(3,5),\ (2,6),\ (1,7)$ 的操作时，$A$ 会变为 $(1,2,3,2,3,2,1)\rightarrow (1,2,3,3,3,2,1)\rightarrow (1,2,2,2,2,2,1)\rightarrow (1,1,1,1,1,1,1)$，此时不存在满足条件的 $l,r$。这一系列操作的总代价为 $1+3+5=9$。另一方面，依次进行 $(l,r)=(2,4),\ (4,6),\ (1,7)$ 的操作时，$A$ 会变为 $(1,2,3,2,3,2,1)\rightarrow (1,2,2,2,3,2,1)\rightarrow (1,2,2,2,2,2,1)\rightarrow (1,1,1,1,1,1,1)$，这一系列操作的总代价为 $1+1+5=7$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
7
1 2 3 2 3 2 1```

### 输出

```
7```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
0```

## 样例 #3

### 输入

```
40
1 2 3 4 5 6 7 8 7 6 5 6 7 8 7 6 5 4 3 2 2 1 2 3 4 5 4 5 6 7 8 7 7 6 5 6 6 7 8 8```

### 输出

```
44```

# 题解

## 作者：Rain_chr (赞：7)

没有场切还是比较遗憾的，实际上 $O(n^2)$ 我就觉得已经很难了，场上写了一个 $O(n^2)$ 拿了 40 分。

首先考虑怎么刻画序列形态，我们先将同颜色连续段缩起来，不难发现无法操作当且仅当任意相邻三个数没有相同的。

这一步转化还是有一点思维含量，题目要求我们不能存在 ABA 这种连续段，但是由于同色连续段都被缩其来了，于是显而易见 AAA/AAB/BAA 这种也是不合法的。

然后猜一个结论，合并操作必然是从左到右进行的。换句话说，必定存在一中最优方案满足右端点单调不降。

细想一下其实挺对的，因为操作区间 $(l,r)$ 显然不会相交，只有包含和相离两种情况，那么我们从左往右做就是对的。

有了这个结论我们就可以来进行 DP 了，先将原序列相同元素缩起来，然后直接考虑最终序列，有一个 $O(n^3)$ 的 DP：

设 $f_{i,x,y}$ 表示前 $i$ 个元素已经被考虑进最终序列了，并且最终序列末尾两段分别是 $x,y$。

转移时枚举一下 $j$，我们要求 $[i+1,j]$ 这一段所有的元素最终都会被缩成一个元素（如果可以缩，那么一定缩成端点的颜色）。

怎么判定 $[i+1,j]$ 能被缩成一段呢？根据刚刚的结论，合并一定从左往右进行，我们只需要拿一个栈，不断把 $x\in[i+1,j]$ 扔进栈中，如果能合并就合并。最后如果只剩下一个元素，那么就能够被消完，在消的同时统计代价即可。

直接转移是 $O(n^4)$ 的，我们考虑优化一下。首先不难发现 $y=a_i$，因为最后是以 $i$ 结尾，这样就只有 $O(n^2)$ 的状态了。

紧接着可以发现我们甚至连 $x$ 都没有记录的必要，因为我们枚举 $i\to j$ 的时候已经知道了新序列末尾三个数的颜色一定是 $a_i,a_{i+1}/a_j,a_{j+1}$，所以根本就不需要记录末尾三段是什么，这样就是 $O(n)$ 的状态了。

转移式大概长这样：
$$
f_{j}=\min_{0\le i<j,a_{i}\not =a_{i+1},a_i\not = a_{j+1},a_j\not = a_j+1} f_i+sum
$$
其中要保证 $(i,j]$ 可以消完，并且 $sum$ 是消这一段的代价。

转移时因为要扫描 $j$ 并且用栈维护，所以复杂度就是 $O(n^2)$，赛时大概到这里就没时间了，遗憾止步。

其实我是完全能够做出来的，因为最困难的一步已经做完了，接下来就是不断优化的 dirty work 了。

首先判定一个区间 $[l,r]$ 栈能不能消到只剩下一个元素是容易的，根据 CSP-S2023 T2 消消乐我们知道可以直接对栈进行哈希，如果 $l$ 时刻的栈和 $r$ 时刻的栈完全一致那么就是可以消完的。

但是 $sum$ 就不能这么算了，因为我们只记录的栈中元素的颜色，没有记录大小，所以 $sum$ 不能简单的通过 $S_r-S_l$ 得到。

不过 $sum$ 有别的算法，具体来说你求出最近的  $[pre_i,i]$ 能够被消完，并且计算出 $w_i$ 表示消完这一段的代价，那么我们只需要从 $x=j$ 开始，不断跳 $x=pre_x$ 直到 $x=i$ 并且对于每一段的 $w_x$ 累积求和，那么 $sum$ 就是这个和。不难发现跳的过程其实就是维护栈的过程，所以只需要维护 $W_x=W_{pre_x}+w_x$，$sum=W_j-W_{i+1}$。

对于 $w_x$ 的求法是类似的，不过细节比较多，建议边拍边写。

设 $h_i$ 是栈到了 $i$ 时刻的哈希值，此时我们的转移成了这样：
$$
f_{j}=\min_{0\le i<j,a_{i}\not =a_{i+1},a_i\not = a_{j+1},a_j\not = a_j+1,h_{i+1}=h_j} f_i+W_j-W_{i+1}
$$
$\min$ 下面一堆不等号太烦人了，不过可以发现 $a_x\not =a_{x+1}$ 是一定满足的，因为我们已经缩过连续段了，转移式变成：
$$
f_{j}=\min_{0\le i<j,a_i\not =a_{j+1},h_{i+1}=h_j} f_i+W_j-W_{i+1}
$$
这就简单了，直接对于每种 $h$ 同时为维护最大次大 DP 值以及对应的颜色，转移可以做到 $O(1)$，总复杂度线性。

给出的代码是一份正解，一份便于理解的 $O(n^2)$ 代码。

[代码](https://www.luogu.com.cn/paste/c44xb93a)

---

## 作者：chroneZ (赞：6)

本题难度在于第一步的转化。本文部分参考官方题解。

仅考虑在序列上执行操作的话，问题会变得比较无从下手，因此要尝试做一些转化。

一个智慧的转化方法是，将序列问题用图论结构刻画。具体地，考虑通过以下算法建出一棵带颜色的树：

> 初始有一颗棋子，位于树的 $1$ 号点，树的 $1$ 号点的颜色为 $a_1$。建树的同时记录一个 $c$ 序列表示棋子每一步走到的点的编号。
>
> 对于 $i = 2 \dots N$，如果 $a_i = a_{i - 1}$ 则不移动棋子；否则如果当前棋子位于的结点有颜色为 $a_i$ 的相邻结点，移到那个结点；否则新建一个颜色为 $a_i$ 的相邻结点并移到之。

这样一来可以得到一个树上的非简单路径（允许在某个结点停留），显然路径的状态刻画了序列的状态。序列上的一次操作在路径上的体现是，$\dots \to a \to {\color{red}b \to b \to \dots \to b} \to a \to \dots$ 红色部分的 $b$ 变成 $a$。

进一步地，我们发现无论怎么对序列进行操作，路径的起始结点都不会变化。更进一步地，当且仅当路径（忽略停留部分后）成起点到终点的简单路径时，序列上不再存在可以操作的 $(l, r)$，操作终止。因此原问题可以看作，将路径操作成简单路径的最小代价。

称起点到终点的简单路径为“主链”（认为主链按起点到终点有序）。将树的 $1$ 号点视为根，记 $g_i$ 表示点 $i$ 的最近主链祖先。

考虑一个简单的情形，游走过程中 $g_i$ 是按照主链的顺序不降的（即路径在主链的部分不会往回走）。此时答案形如不在主链上的点的子树 size 和，此即 $\sum \limits_{i = 1} ^ n \text{dist}(c_i, g_{c_i})$。

再考虑一般情形。可以发现简单情形下的贡献是一定会产生的，直接预先加上。最后的麻烦就是路径在主链上可能往回走，需要求解该部分的最小贡献，这容易通过钦定最终路径的形态 DP 解决。具体来讲，记 $g_{c_i}$ 是主链上的第 $v_i$ 个点，问题可以等价于：

> 有一个 $\{v\}$ 序列，$|v_i - v_{i - 1}| \leq 1$，你需要找到一个序列 $\{v'\}$，最小化 $\sum |v_i - v'_i|$，且 $v'$ 需要满足：
> - $v'_1 = v_1, v'_n = v_n$。
> - $v'_i \leq v'_{i + 1}$。
> - 若 $v'_i \neq v'_{i + 1}$，则 $v'_i = v_i, v'_{i + 1} = v_{i + 1}$。

记 $f_i$ 为前 $i$ 项的最小代价，且需要满足 $v'_i = v_i$。初始 $f_1 = 1$，有两种转移：

- 若 $v_{i - 1} + 1 = v_i$，$f_i \gets \min(f_i, f_{i - 1})$。
- 记 $p$ 为 $[1, i)$ 中最大的满足 $v_p = v_i$ 的位置，（如果存在 $p$）令 $f_i \gets \min(f_i, f_p + \sum \limits_{j = p + 1} ^ i |v_i - v_j|)$。

用前缀和优化即可将 DP 做到 $\Theta(n)$。你可能觉得第二条转移的贡献不是很好算，但是由于 $p$ 是上一个满足 $v_p = v_i$ 的位置，所以 $v_{p + 1 \dots i - 1}$ 均大于 $v_i$ 或均小于 $v_i$，因此容易计算。

总时间复杂度 $\Theta(n)$。（代码用了个 map，不是 $\Theta(n)$ 的，不过容易做到线性。）

```cpp
// Such a destiny was not desired.
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

constexpr int N = 5e5 + 5;

int n, a[N], c[N];
vector<int> G[N];
unordered_map<int, int> adj[N];
bool vis[N];

int g[N], dis[N];
ll sum[N], f[N];

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr), cout.tie(nullptr);
  
  cin >> n;
  for(int i = 1; i <= n; i++) {
    cin >> a[i];
  }

  int m = 1; c[1] = 1;
  for(int i = 2; i <= n; i++) {
    if(a[i] == a[i - 1]) c[i] = c[i - 1];
    else {
      auto it = adj[c[i - 1]].find(a[i]);
      if(it != adj[c[i - 1]].end()) c[i] = it->second;
      else {
        c[i] = ++m;
        adj[c[i - 1]][a[i]] = c[i], adj[c[i]][a[i - 1]] = c[i - 1];
        G[c[i - 1]].push_back(c[i]), G[c[i]].push_back(c[i - 1]);
        // cerr << "AddEdge " << c[i - 1] << " " << c[i] << " (" << a[i] << ")\n";
      }
    }
  }
  vector<int> P;
  function<bool(int, int)> FindPath = [&](int u, int fa) {
    if(u == c[n]) return P.push_back(u), true;
    bool ok = false;
    for(auto v : G[u]) {
      if(v == fa) continue;
      if(FindPath(v, u)) {ok = true; break;}
    }
    if(ok) P.push_back(u);
    return ok;
  };
  FindPath(1, -1);
  reverse(P.begin(), P.end());
  for(auto u : P) vis[u] = true;

  function<void(int, int, int, int)> Fill = [&](int u, int fa, int col, int D) {
    dis[u] = D;
    g[u] = col;
    for(auto v : G[u]) {
      if(v == fa) continue;
      Fill(v, u, col, D + 1);
    }
  };
  for(int i = 1; i <= P.size(); i++) {
    int u = P[i - 1];
    g[u] = i;
    for(auto v : G[u]) {
      if(vis[v]) continue;
      Fill(v, u, i, 1);
    }
  }

  ll ans = 0;
  for(int i = 1; i <= n; i++) {
    sum[i] = sum[i - 1] + g[c[i]];
    ans += dis[c[i]];
  }
  memset(f, 0x3f, sizeof(f));
  map<int, int> last;
  f[1] = 0; last[1] = 1;
  for(int i = 2; i <= n; i++) {
    if(g[c[i - 1]] + 1 == g[c[i]]) f[i] = min(f[i], f[i - 1]);
    auto it = last.find(g[c[i]]);
    if(it != last.end()) {
      int pos = it->second;
      ll w = abs(1ll * (i - pos) * g[c[i]] - (sum[i] - sum[pos]));
      f[i] = min(f[i], f[pos] + w);
    }
    last[g[c[i]]] = i;
  }
  ans += f[n];
  cout << ans << "\n";
}
```

---


# [AGC067B] Modifications

## 题目描述

有一个长度为 $N$ 的整数序列 $a=(a_1,a_2,\cdots,a_N)$，所有元素初始均为 $0$。

给定整数 $C$ 和 $M$ 个区间 $([L_1,R_1],[L_2,R_2],\cdots,[L_M,R_M])$。

你需要选择 $1$ 到 $M$ 的一个排列 $p$，以及一个长度为 $M$ 的整数序列 $w=(w_1,w_2,\cdots,w_M)$，其中 $1\le w_i\le C$。

然后进行 $M$ 次操作。第 $i$ 次操作如下：

- 将 $a_{L_{p_i}},\cdots,a_{R_{p_i}}$ 的值全部变为 $w_i$。

保证 $a$ 的每个位置至少被一个区间覆盖。

请计算所有可能的最终序列 $a$ 的种数，并输出对 $998244353$ 取模的结果。

## 说明/提示

### 限制条件

- $1\le N\le 100$
- $1\le M\le\dfrac{N(N+1)}{2}$
- $1\le C < 998244353$
- $1\le L_i\le R_i\le N$
- $(L_i,R_i)\neq (L_j,R_j)$（$i\neq j$）
- $a$ 的每个位置至少被一个区间覆盖。
- 所有输入均为整数。

### 样例解释 1

可能的序列共有 $16$ 个。例如，$a=(2,1,1,1,1)$ 可以如下得到：
- 选择 $p=(4,1,2,3,5)$ 和 $w=(1,2,1,2,1)$
- 第 $1$ 次操作后 $a$ 变为 $(1,1,1,1,1)$
- 第 $2$ 次操作后 $a$ 变为 $(2,2,2,1,1)$
- 第 $3$ 次操作后 $a$ 变为 $(2,1,2,1,1)$
- 第 $4$ 次操作后 $a$ 变为 $(2,1,2,1,1)$
- 第 $5$ 次操作后 $a$ 变为 $(2,1,1,1,1)$

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5 5 2
1 3
2 2
3 3
1 5
3 5```

### 输出

```
16```

## 样例 #2

### 输入

```
20 30 20
1 14
1 7
1 16
3 13
1 17
4 8
2 11
4 12
9 14
3 15
11 19
1 13
4 15
8 19
3 17
15 18
10 18
1 18
17 19
16 20
1 8
8 15
13 17
1 19
13 19
1 20
6 13
10 12
11 20
17 18```

### 输出

```
258066445```

# 题解

## 作者：ケロシ (赞：16)

写一篇劣质题解。

思路参考了[官方题解](https://atcoder.jp/contests/agc067/editorial/10703)以及[djq](https://atcoder.jp/contests/agc067/submissions/56874967)大神的代码。

首先考虑怎么判断一个序列 $a$ 是否能被生成出来，考虑先判断后覆盖再判先前覆盖的。考虑贪心枚举区间，若这段区间里**没被覆盖过的颜色都是一样的**，则进行一次覆盖，最后序列全被覆盖则能被生成。

接下考虑如何计数，对于覆盖类问题，考虑区间 DP，定义 $dp_{l,r}$ 为区间 $[l,r]$ 能被 $[l,r]$ 的子操作区间全部覆盖后生成的不同序列数。

注意到一个不合法的方案就是上述覆盖后有地方没有被覆盖，这个比较好算，考虑用 $c^{r-l+1}$ 减去不合法的方案数。

考虑如何计算没被覆盖的方案数，发现区间 $[l,r]$ 的不合法方案是由所有**不能覆盖的点**将区间分割成了若干**合法子区间**，设分割后的合法子区间是 $[l_1,r_1],[l_2,r_2]\cdots$，那么一种分割方案的方案数就是**分割点颜色的方案**乘上**合法区间的方案**，即乘上 $\prod dp_{l_k,r_k}$。

考虑再用 DP 计算这个东西，但是这么判断此分割点是否合法的呢？

考虑先预处理出 $ok_{l,r,p}$ 表示 $p$ 是否能在 $[l,r]$ 里被 $[l,r]$ 的子操作区间覆盖。

回到最开头讲的判断方法，所有的分割点都有颜色，那么提出分割点颜色序列，那么 DP 时记录分割颜色方案的**最右边的相同颜色段的左端点的前一个分割点**，设 $f_{l,r,p}$ 为区间 $[l,r]$ 中，点 $r$ 为最右分割点，且最右相同颜色段左端点的前一个分割点 $p$。

那么若转移时有一个分割点 $i$，那么由于 $[p+1,r-1]$ **未被覆盖的点的颜色都一样**，根据最开头的方法，不能有 $[p+1,r-1]$ 的子操作区间把 $i$ 给覆盖了，否则就合法了。

不难发现最右分割点有 $c-1$ 种颜色方案会新开一个段，只有一种颜色会保留原来的段。

所以对于 $ok_{p+1,r-1,i}=0$ 的情况，可以对于分割方案的转移：

$f_{l,r,i} \gets f_{l,i,p} ~ dp_{i + 1,r - 1} (c - 1)$

$f_{l,r,p} \gets f_{l,i,p} ~ dp_{i + 1,r - 1}$

最后减去不合法方案时，右边还可以拼上一段合法的，所以当 $ok_{p + 1,r,i}=0$ 时，转移方程：

$dp_{l,r} \gets - f_{l,i,p} ~ dp_{i + 1,r}$

如果区间 DP 先枚举左端点，可以省去 $f$ 数组的第一维。

时间复杂度 $O(n^4)$。

还不是因为自己不够努力。

```cpp
const int N = 105;
const int P = 998244353;
typedef Modint<P> mint;
int n, m, c;
bool ok[N][N][N];
mint f[N][N], dp[N][N];
mint fp(mint x, int y) {
	mint res = 1;
	for(; y; y >>= 1) {
		if(y & 1) res *= x;
		x *= x;
	}
	return res;
}
void solve() {
	cin >> n >> m >> c;
	REP(_, m) {
		int l, r;
		cin >> l >> r;
		FOR(j, l, r) ok[l][r][j] = 1;
	}
	ROF(i, n, 1) FOR(j, 1, n) FOR(k, 1, n) 
		ok[i][j][k] |= ok[i + 1][j][k];
	ROF(i, n, 1) FOR(j, 1, n) FOR(k, 1, n) 
		ok[i][j][k] |= ok[i][j - 1][k];
	FOR(i, 0, n) dp[i + 1][i] = 1;
	ROF(l, n, 1) {
		memset(f, 0, sizeof f);
		f[l - 1][l - 1] = 1;
		FOR(r, l, n) {
			FOR(i, l - 1, r - 1) FOR(j, l - 1, i) if(!ok[j + 1][r - 1][i]) {
				f[r][i] += f[i][j] * dp[i + 1][r - 1] * (c - 1);
				f[r][j] += f[i][j] * dp[i + 1][r - 1];
			}
			dp[l][r] = fp(c, r - l + 1);
			FOR(i, l, r) FOR(j, l - 1, i) if(!ok[j + 1][r][i]) {
				dp[l][r] -= f[i][j] * dp[i + 1][r];
			}
		}
	}
	cout << dp[1][n] << endl;
}
```

---

## 作者：OptimisticForever (赞：10)

考虑倒着做，判断一个 $a$ 合法，相当于，我们每次可以把一段相同颜色的赋值成 `?`，然后，`?` 可以当任意颜色。

设 $f_{l,r}$ 表示最后一定可以把 $[l,r]$ 中所有数变成 `?` 的方案数。

考虑容斥，$f_{l,r}=C^{r-l+1}-\cdots$。

一个区间如果不合法，那么肯定存在很多断点，我们把断点抠出来，形成一个颜色序列。对于一个颜色段，我们必须保证，任意被 $[l,r]$ 包含的操作区间不能包含这些断点。

对于端点 $l$，我们设 $g_{i,j}$，表示 $i$ 为断点，且 $i$ 上一个**不同颜色**的断点的位置为 $j$ 的方案数，此时我们钦定 $i$ 的颜色。

我们可以枚举 $i$ 上一个断点是什么位置，记为 $j'$，如果 $j\not =j'$，那么可以从 $g_{j',j}\times f_{j'+1,j-1}$ 转移过来，注意，需要满足，不存在被 $[j+1,i-1]$ 包含的操作区间覆盖 $j'$ 这个点。如果 $j=j'$，那么可以枚举一个 $k$，表示 $j$ 前面的那个**不同颜色**的断点位置，那么就从 $g_{j,k}\times f_{j+1,i-1}\times (C-1)$ 转移过来，因为这时候我们钦定 $j$ 这个位置的颜色，与 $i$ 不同，注意，也需要满足一个类似的条件。

然后我们就对 $f$ 容斥，枚举最右边不合法的位置 $i$，然后从 $f_{i+1,r}\times g_{j,i}$ 转移，此时需要保证 $i$ 这个位置不被 $[j+1,r]$ 包含的操作区间覆盖。

预处理 $a_{l,r,i}$ 表示被 $[l,r]$ 包含的操作区间是否覆盖 $i$ 这个点即可，时间复杂度 $O(n^4)$。

---

## 作者：WrongAnswer_90 (赞：3)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18378739)

### [[AGC067B] Modifications](https://www.luogu.com.cn/problem/AT_agc067_b)

谔谔，做过类似的题还是不会啊啊啊。

首先考虑给定一个 $a$ 序列如何进行判定。倒着做这个覆盖的过程，每次可以看成是，如果 $[l_i,r_i]$ 剩下的点的颜色都相同，则可以把 $[l_i,r_i]$ 删掉。如果最后能删空就是合法的。

区间 DP 判定这个过程：$f_{l,r}$ 表示考虑了左右端点都则区间 $[l,r]$ 的操作之后，区间 $[l,r]$ 的合法方案数。

发现直接计数似乎没有什么简单的合法充要条件。考虑进行容斥，用 $C^{r-l+1}$ 减去不合法的方案数就是答案。

考虑不合法区间的形态，最后一定是若干个断点没有被覆盖，把区间分成了若干个小区间。再考虑什么样的断点情况是真实存在的。除了断点之外的区间都能删空，所以如果单把断点的颜色序列拉出来，则对于一个相同颜色的颜色段，要求不能有跨过内部点的操作区间。

设 $g_{l,r,p}$ 表示 $r$ 是断点，$r$ 前面第一个和 $r$ 颜色不同的断点的位置在 $p$ 的方案数。首先预处理 $vis_{l,r,p}$ 表示 $[l,r]$ 的子操作区间能不能把 $p$ 覆盖。枚举 $r$ 前面第一个断点的位置 $i$。分 $i$ 的颜色和 $r$ 相同和不同讨论：

$$
\begin{aligned}
g_{l,r,p}&\overset+\leftarrow g_{l,i,p}f_{i+1,r-1}\\
g_{l,r,i}&\overset+\leftarrow g_{l,i,p}f_{i+1,r-1}(C-1)
\end{aligned}
$$

上述转移要求 $vis_{p+1,r-1,i}=0$。然后计算 $f$，枚举右边第一个断点容斥：

$$
f_{l,r}\overset-\leftarrow g_{l,i,p}f_{i+1,r}
$$

该转移要求 $vis_{p+1,r,i}=0$。总复杂度 $\mathcal O(n^4)$。一点小细节是 $g_{l,r,p}$ 只对除了 $r$ 以外的断点进行了检查合法，比如存在一个 $[r,r]$ 的操作区间，但是根据上面的 DP $g_{l,r,p}$ 还是会有值的。但是可以发现在用到 $g$ 的时候对 $r$ 进行了合法检查，所以直接这么写就是对的。

```cpp
int n,m,C,f[110][110],g[110][110][110];
bitset<110> vis[110][110];
vi ve[110];
inline void mian()
{
	read(n,m,C);int x,y;
	for(int i=1;i<=m;++i)read(x,y),ve[y].eb(x);
	for(int i=0;i<=n;++i)f[i+1][i]=1;
	for(int i=1;i<=n;++i)
	{
		for(int j=i;j<=n;++j)
		{
			int pos=j+1;vis[i][j]=vis[i][j-1];
			for(auto p:ve[j])if(p>=i)Mmin(pos,p);
			for(int k=pos;k<=j;++k)vis[i][j][k]=1;
		}
	}
	for(int i=n;i>=1;--i)for(int j=i;j<=n;++j)
	{
		f[i][j]=power(C,j-i+1),g[i][i-1][i-1]=1;
		for(int p=i-1;p<j;++p)for(int k=i-1;k<j;++k)if(!vis[p+1][j-1][k])
		Madd(g[i][j][k],Cmul(g[i][k][p],f[k+1][j-1],C-1)),
		Madd(g[i][j][p],Cmul(g[i][k][p],f[k+1][j-1]));
		for(int p=i-1;p<j;++p)for(int k=i;k<=j;++k)if(!vis[p+1][j][k])
		Mdel(f[i][j],Cmul(g[i][k][p],f[k+1][j]));
	}
	write(f[1][n]);
}
```

---

## 作者：Albert_Wei (赞：0)

我们先考虑判定什么样的序列可以被染成。对于染色问题，套路地考虑将操作倒序进行。我们贪心地选颜色相同的 $[L_i, R_i]$，将区间内元素变为 `?`（即可与任何颜色相同），不断操作，显然可以被染成当且仅当最后可以将整个序列全部变为 `?`。

我们仍然考虑在操作到不能操作的时候统计不能被染成的序列。考虑还剩下的元素，它们将序列分为若干个独立的区间，这启示我们考虑区间 dp。我们设 $f_{l, r}$ 表示可以仅用 $[L_i, R_i] \subseteq [l, r]$ 的区间 $[L_i, R_i]$，将 $[l, r]$ 删空的染色方案数。先容斥。枚举区间左端点 $l$，我们设 $g_{x, p}$ 表示最后一个剩下的元素为 $a_x$，$a_x$ 之前最靠右的与它颜色不同的元素为 $a_p$ 的方案数。**注意，由于我们不知道右端点 $r$，我们此时只考虑所有满足 $[L_i, R_i] \subseteq [l, x - 1]$ 的区间**。根据转移可以发现我们需要预处理 $vis_{l, r, x}$，表示是否存在 $x \in [L_i, R_i] \subseteq [l, r]$。考虑状态 $(i, p)$ 如何转移，枚举 $j > i$ 表示下一个剩下的元素，则在保证 $\neg vis_{p + 1, j - 1, i}$ 的前提下，可向 $g_{j, i}$ 贡献 $(c - 1) \times g_{i, p} \times f_{i + 1, j - 1}$，向 $g_{j, p}$ 贡献 $g_{i, p} \times f_{i + 1, j - 1}$。特别的，dp 初值为 $g_{l - 1, l - 1} = 1$。统计答案时，枚举最后一个剩下的元素 $a_i$，有 $f_{l, r} = c ^ {r - l + 1} - \sum \limits_{i = l} ^ r \sum \limits_{p = l - 1} ^ {i - 1} g_{i, p} \times f_{i + 1, r}$，要求为 $\neg vis_{p + 1, r, i}$。注意转移顺序，复杂度为 $\mathcal{O}(n ^ 4)$。

> 其实这个 dp 的正确性和初值设定并没有那么显然，所以我们稍微证一下。只考虑剩下的元素时，考虑其形成的一个同色连续段 $a_{i_1}, a_{i_2}, \cdots a_{i_m}$，其左、右剩下的元素分别为 $a_x, a_y$（若左右分别为左边界或右边界，初值和统计答案的过程告诉我们应当将 $a_{l - 1}$ 视作 $a_x$，$a_{r + 1}$ 视作 $a_y$。事实上，我们接下来会证明 $\not \exist i_j \in [L_k, R_k] \subseteq [x + 1, y - 1]$，这与边界时所需证明的情形相一致）。若不满足条件，则 $\exists i_j \in [L_k, R_k] \subseteq [x + 1, y - 1]$，而根据转移过程，我们有 $[L_k, R_k] \not \subseteq [x + 1, i_{j + 1} - 1]$，故有 $i_{j + 1} \in [L_k, R_k]$ 同理 $i_{j + 2} \in [L_k, R_k], \cdots ,i_m \in [L_k, R_k]$，进一步根据转移过程，可得 $y \in [L_k, R_k]$，与假设矛盾。

---


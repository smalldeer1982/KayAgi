# [ARC163E] Chmin XOR Game

## 题目描述

Alice 和 Bob 用一个长度为 $N$ 的非负整数序列 $A=(A_1,A_2,\dots,A_N)$ 进行游戏。

两人轮流操作，从 Alice 开始。无法继续操作的人判负。

- 选择一个非负整数 $X$，使得存在某个整数 $i$ 满足 $A_i > A_i \oplus X$。
- 对于所有 $1 \le i \le N$，用 $\min(A_i, A_i \oplus X)$ 替换 $A_i$。

请判断在双方都采取最优策略的情况下，谁会获胜。

其中，$\oplus$ 表示按位异或运算。

给定 $T$ 组测试数据，请分别输出每组的答案。

## 说明/提示

### 数据范围

- $1 \le T \le 100$
- $1 \le N \le 100$
- $0 \le A_i \le 10^9$

### 样例解释 1

第 1 个测试用例，可能的游戏过程如下：

- Alice 选择 $X=3$。对于 $i=1$，有 $3 > 3 \oplus 3 (=0)$，因此该选择有效。
- $A=(3,1)$ 变为 $A=(0,1)$。
- Bob 选择 $X=1$。对于 $i=2$，有 $1 > 1 \oplus 1 (=0)$，因此该选择有效。
- $A=(0,1)$ 变为 $A=(0,0)$。
- Alice 无法再选择合适的 $X$，游戏结束。

此时 Bob 获胜。

第 2 个测试用例，可能的游戏过程如下：

- Alice 选择 $X=1$。对于 $i=1$，有 $1 > 1 \oplus 1 (=0)$，因此该选择有效。
- $A=(1,1,1,1,1)$ 变为 $A=(0,0,0,0,0)$。
- Bob 无法再选择合适的 $X$，游戏结束。

此时 Alice 获胜。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5
2
3 1
5
1 1 1 1 1
4
0 0 0 0
4
8 1 6 4
5
3 8 7 12 15```

### 输出

```
Bob
Alice
Bob
Bob
Alice```

# 题解

## 作者：鲤鱼江 (赞：6)

什么鬼题……

考虑对只有两个数的情况打表，猜测与二进制之类的有关就打了 $2^{2^2}$ 也就是 $[0,16)$ 的表。

$1$ 表示先手必胜，$0$ 表示后手必胜。

```
0111111111111111
1100111111111111
1010111111111111
1001111111111111
1111111101110111
1111111111001100
1111111110101010
1111111110011001
1111011111110111
1111110011111100
1111101011111010
1111100111111001
1111011101111111
1111110011001111
1111101010101111
1111100110011111
```

发现有好多 $4\times 4$ 的全一子矩阵，又想到 $4=2^2$，就觉得有说法。

```
0111 1111 1111 1111
1100 1111 1111 1111
1010 1111 1111 1111
1001 1111 1111 1111

1111 1111 0111 0111
1111 1111 1100 1100
1111 1111 1010 1010
1111 1111 1001 1001

1111 0111 1111 0111
1111 1100 1111 1100
1111 1010 1111 1010
1111 1001 1111 1001

1111 0111 0111 1111
1111 1100 1100 1111
1111 1010 1010 1111
1111 1001 1001 1111
```

由之前一道模拟赛的 trick 想到这玩意是个分形，换句话说，我们把全一矩形当作 $1$，另一种当作 $0$，发现又变成了：

```
0111
1100
1010
1001
```

很优雅的性质，给了我们两个启发：

1. 答案和 $4$ 或者四进制有关系。
2. 在只有两个数的时候可以拓展，即只有两个数的情况下该表是分形。

后来证明都是对的。

考虑只有两个数如何判定，联想启发 1，将两个数四进制分解发现先手必胜当且仅当存在一位使得两个数的这一位有且仅有一个 $0$，或者这一位相同。

然后卡在了这里。

通过猜测后发现可以拓展到 $n$ 个数的情况，具体地，如果存在一位，使得所有数该位上的值不全为 $0$，且每一个数该位要么是 $0$ 要么全相同，则先手必胜。

稍微打一下暴力可以验证正确性。

证明和 $n=2$ 是类似的，经典的 ARC 风题目，切出题后还是只会做原题。

不过这个题放到赛时我应该能切，板刷时反而不敢猜结论了。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=110;
int cnt[5],T,n,a[N];

int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>T;
	while(T--){
		int flag=0;cin>>n;for(int i=1;i<=n;++i) cin>>a[i];
		for(int i=0;i<=10;++i){
			cnt[0]=cnt[1]=cnt[2]=cnt[3]=0;
			for(int j=1;j<=n;++j){++cnt[a[j]&3];a[j]>>=2;}
			for(int j=1;j<=3;++j) if(cnt[j]&&cnt[0]+cnt[j]==n){flag=1;break;}
		}
		cout<<(flag?"Alice\n":"Bob\n");
	}
	return 0;
}
```

---

## 作者：hsaht2426 (赞：3)

独立做出来力！

首先**从简单入手**，考虑 $2$ 个数的情形。

**博弈论**先用 $\text{SG}$ 定理打个表，又因为是**位运算**，考虑到一定与二进制位有点关系（事实上不是）。

不难打出这样的表：($1$ 代表 Alice 必胜)
```cpp
0111111111111111
1100111111111111
1010111111111111
1001111111111111
1111111101110111
1111111111001100
1111111110101010
1111111110011001
1111011111110111
1111110011111100
1111101011111010
1111100111111001
1111011101111111
1111110011001111
1111101010101111
1111100110011111
```
很难看，我们尝试分个段。
```
 0111 1111 1111 1111
 1100 1111 1111 1111
 1010 1111 1111 1111
 1001 1111 1111 1111

 1111 1111 0111 0111
 1111 1111 1100 1100
 1111 1111 1010 1010
 1111 1111 1001 1001

 1111 0111 1111 0111
 1111 1100 1111 1100
 1111 1010 1111 1010
 1111 1001 1111 1001

 1111 0111 0111 1111
 1111 1100 1100 1111
 1111 1010 1010 1111
 1111 1001 1001 1111
```
不难发现他满足**递归性质**，是个分形。

考虑取最开始的部分找找规律。
```
0111 
1100 
1010
1001 
```

我们发现 $0$ 并不能告诉我们什么，考虑其**补集** $1$。

容易发现，如果 $a,b$ 不全为零，且有 $a=0$ 或 $b=0$ 或 $a=b$，那么 Alice 必胜。

回到原来 $16 \times 16$ 的表。

其实就是但凡有一个四进制位满足该条件，Alice 必胜。

然后考虑扩展，显然不可能直接扩展到 $n$。

就比如说 $a=b$，他可以是 $a=b=c$，也可能是 $a-b=c$。这本质上是因为简单情形太少了。

所以有两种做法:

- 考虑证明上一个结论，把结论用好。

- 考虑增加简单情形，打一个三维的表。

$16 \times 16 \times 16$ 的表显然不易观察，所以选前者。

必胜状态是由任意一个必败状态转移过来的。

找点**特殊点**，我们发现他们都可以由全 $0$ 状态一步转移过来。

1. 猜想可以由全 $0$ 状态一步转移过来的集合与 $4 \times 4$ 必胜状态的集合等价。

证明：

充分性：依据定义可证。

必要性：

如果存在一个必胜状态未从 $0$ 转移过来，那么必然有必败状态存在，然后再到必胜状态，最后转移到全为 $0$ 的必败状态。

然后这个分析似乎没有什么用？

考虑将 $a_i$ 替换为 $\min( a_i , a_i \oplus x)$ 操作的实质。

拆位分析一下。

我们发现至少会将一个二进制位赋为 $0$。

然而我们之前至少要做三次操作，对 $4$ 的值域已经不可能了。

2. 我们尝试拓展到 $16 \times 16$ 的情况。

即证明但凡有一个四进制位满足该条件，Alice 必胜。

证明：

对于可以一步转移到原先 $4 \times 4$ 的范围的位置。

我们显然可以取一个 $x$，其第二位可使其转移到 $4 \times 4$ 的情况。

那么它的第一位其实放什么都合法。

也就是说对于它的第一位，可以做一次对胜负没有贡献的操作，也可以不做。

如果当前必胜，必然存在必败处可转移，转移到必败处即可。

如果当前必败，原地不动即可。

所以当前必有必败状态转移，当前状态必胜。

对于不能一步转移到原先 $4 \times 4$ 的范围的位置。

显然对于坐标为 $4$ 的倍数的位置是必败局面。

其他情况若转移出去则只可转移到必胜局面，所以其等价于 $4 \times 4$ 的情况。

此处的证明使用了大量归纳法，核心就在于找 $16 \times 16$ 中等价于 $4 \times 4$ 情况的三种类型。

发现此处 $1,2$ 证明其实可以与 $n=2$ 与 $16 \times 16$ 无关。于是我们发现，在 $n>2$ 的通用情况也有这样的结论。

于是照着结论来就过了。

有趣的是，我做这题时没有任何证明，鉴定为有运气的。

[正解代码+打表代码](https://atcoder.jp/contests/arc163/submissions/44480878)

---

## 作者：Leasier (赞：2)

ARC 特有的代码简单但 Ad-hoc 的题 /oh

------------

首先考虑 $n = 2$ 的情况。不妨进行一个表的打，观察一下 $[0 \sim 19] \times [0 \sim 19]$（$1$ 表示 Alice 胜，$0$ 表示 Bob 胜）：
```
01111111111111111111
11001111111111111111
10101111111111111111
10011111111111111111
11111111011101111111
11111111110011001111
11111111101010101111
11111111100110011111
11110111111101111111
11111100111111001111
11111010111110101111
11111001111110011111
11110111011111111111
11111100110011111111
11111010101011111111
11111001100111111111
11111111111111111111
11111111111111111111
11111111111111111111
11111111111111111111
```
不难发现对于每个 $4 \times 4$ 的块，要么跟 $[0 \sim 3] \times [0 \sim 3]$ 相同，要么全 $1$；而且，如果把 $[0 \sim 3] \times [0 \sim 3]$ 视为 $0'$，全 $1$ 视为 $1'$，则还会构成原分形。

基于上述观察，我们猜想：若存在 $a_1, a_2$ 某一位（四进制下）使得其满足把这位的两个数抓出来满足 Alice 胜，则 Alice 胜；否则，Bob 胜。

证明：

- 设 $a_i$ 在四进制下的第 $j$ 位为 $b_{i, j}$，$\max a_i$ 的最高位为 $k$。
- 抓出最高的满足该条件的位 $j$，考虑当前先手选择的 $X$。
- 只要我们证明先手在我们猜测的必胜状态下可以给出一种方案使得其转化为必败状态，则原命题得证。

1. $b_{1, j} = b_{2, j} > 0$

若第 $k$ 位满足前文猜想的先手必胜的条件，令 $X_k = \max(b_{1, k}, b_{2, k})$；否则，令 $X_k = 0$。

2. $b_{1, j} = 0, b_{2, j} > 0$

若 $b_{1, k} = b_{2, k} > 0$，令 $X_k = 0$；若 $b_{1, k} = 0, b_{2, k} > 0$，令 $X_k = b_{2, k}$；若 $b_{1, k} > 0, b_{2, k} = 0$，令 $X_k$ 为 $0, b_{1, k}$ 外的任何数；否则，令 $X_k = 0$。

对偶情况同理，不再赘述。

可以发现，先手用上述 $X$ 进行一次上述操作后必然会转化为必败情况，且可以穷举证明，对于剩下四种本质相同的情况，要么已经全 $0$，要么无论选择什么作为最高位，都会转化为先手必胜的情况。于是猜想得证。

将上述结论推广到 $n > 2$ 的情况，~~很难~~发现此时只要满足存在某一位，使得 $n$ 个数中这位存在非 $0$ 项且非 $0$ 项全部相等，则 Alice 胜；否则，Bob 胜。

模拟上述过程即可。时间复杂度为 $O(Tn \log_4 w)$，其中 $w$ 为值域 $10^9$。

代码：
```cpp
#include <stdio.h>
#include <stdbool.h>

int a[107], cnt[7];

int main(){
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= t; i++){
		int n;
		bool ans = false;
		scanf("%d", &n);
		for (int j = 1; j <= n; j++){
			scanf("%d", &a[j]);
		}
		while (!ans){
			bool flag = true;
			for (int j = 1; j <= n; j++){
				if (a[j] != 0){
					flag = false;
					break;
				}
			}
			if (flag) break;
			for (int j = 0; j <= 3; j++){
				cnt[j] = 0;
			}
			for (int j = 1; j <= n; j++){
				cnt[a[j] % 4]++;
				a[j] /= 4;
			}
			for (int j = 1; j <= 3; j++){
				if (cnt[j] >= 1 && cnt[0] + cnt[j] == n){
					ans = true;
					break;
				}
			}
		}
		if (ans){
			printf("Alice\n");
		} else {
			printf("Bob\n");
		}
	}
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/AT_arc163_e)

**题目大意**

> 给定 $a_1\sim a_n$，每次操作选定 $x$，然后令 $a_i\to \min(a_i\oplus x,a_i)$（至少要令一个数减小）。
>
> 两人轮流操作，不能操作者输，求谁获胜。
>
> 数据范围：$n\le 100$。

**思路分析**

先打表 $n=2$ 的情况（设 $a>b$），对于值域 $[0,4)$ 的问题，当且仅当 $a=b>0$ 或 $a>b=0$ 时先手胜。

进一步发现一般的情况当且仅当，四进制下某一位满足这个限制，那么先手胜：

> 如果先手面对一个必败局面，枚举容易证明，考虑 $x$ 的非零最高位，无论怎么操作都会转移到必胜局面。
>
> 否则我们找到最高的合法位 $(a_i,b_i)$：
>
> - 如果 $a_i=b_i>0$，那么取 $x_i=a_i$，显然 $(a,b)\gets(a\oplus x,b\oplus x)$：
>   - 如这一位后手胜，直接取 $x_j=0$。
>   - 如果 $a_j=b_j>0$，依然取 $x_j=a_j$。
>   - 否则取 $x_j\ne a_j,x_j\ne b_j$ 即可。
> - 否则 $a_i>b_i=0$，那么取  $x_i=a_i$，那么 $(a,b)\gets(a\oplus x,b)$。
>   - 如这一位后手胜，直接取 $x_j=0$。
>   - 剩下的位 $a_j=b_j>0$，取 $x_j\ne 0,x_j\ne a_j$。
>   - 如果 $a_j>b_j=0$，取 $x_j=a_j$。
>   - 如果 $b_j>a_j=0$，取 $x_j\ne 0,x_j\ne b_j$。

进一步推广，对于 $n>2$ 的情形，当且仅当有一个四进制位上恰好只有一种非零数码那么先手必胜，证明类似。

时间复杂度 $\mathcal O(n\log V)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=105;
int a[MAXN];
void solve() {
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	while(*max_element(a+1,a+n+1)) {
		array <int,4> c{0,0,0,0};
		for(int i=1;i<=n;++i) ++c[a[i]&3],a[i]>>=2;
		if((!c[1])+(!c[2])+(!c[3])==2) return puts("Alice"),void();
	}
	puts("Bob");
}
signed main() {
	int T;
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：xxxxxzy (赞：0)

这种题目就是骇人的，完全做不懂，这次会了下次也不会。

打表 $n=2$，值域 $[0,4)$ 的情况，只有当 $a>b=0$ 或者 $a=b>0$ 先手胜利。

设 $a,b$ 四进制下的数组是 $a_i,b_i$ 找到最高的合法位 $(a_k,b_k)$。

大胆猜想，先手必胜当且仅当有一个四进制位满足胜利条件。

考虑证明先手如何能一步把必胜局面转化为必败局面：

+ 如果 $a_k>b_k=0$，取 $x_k=a_k$，那么 $(a_i,b_i)$ 会变成 $(a_i \oplus x,b_i \oplus x)$。


如果第 $i$ 位是必败状态，取 $x_i=0$；如果 $a_i=b_i>0$，取 $x_i=a_i$；否则则随意取 $x_i \ne a_i,b_i$ 即可。

+ 如果 $a_k=b_k>0$，那么依然取 $x_k=a_k$，那么 $(a_i,b_i)$ 会变成 $(a_i \oplus x_i,b_i)$。

如果第 $i$ 位是必败状态，取 $x_i=0$；如果 $a_i=b_i>0$，取 $x_i \ne a_i,0$；如果 $a_i>b_i=0$，取 $x_i=a_i$；如果 $0=a_i<b_i$，取 $x_i \ne b_i,0$。

考虑对这个 $n=2$ 的结论进行推广，假设一位上的四进制数分别为 $g_i=(a_{1},...,a_{m})$。

猜想结论为，存在一位有一种非零的值，且剩下不同的值全为 $0$，则先手获胜。

对最高位进行讨论，最高位为 $(a_1=...=a_j>a_{j+1}=...=a_n=0)$，取 $x_k=a_1$。

证明和上面是类似的。

时间 $O(n \log V)$。

---


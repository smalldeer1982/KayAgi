# [AGC035E] Develop

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_e

黒板に $ -10^{18} $ から $ 10^{18} $ までの整数が $ 1 $ 個ずつ書かれています。高橋君は、以下の一連の操作を $ 0 $ 回以上好きなだけ繰り返します。

- 黒板に書かれている整数のうち $ 1 $ 以上 $ N $ 以下のものをひとつ選ぶ。選んだ整数を $ x $ とし、$ x $ を黒板から消す。
- 黒板に $ x-2 $ が書かれていないなら、$ x-2 $ を書き加える。
- 黒板に $ x+K $ が書かれていないなら、$ x+K $ を書き加える。

何回かの操作後、黒板に書かれている数の集合としてありうるものの個数を $ M $ で割った余りを求めてください。 ただし、$ 2 $ つの集合が異なるとは、その片方だけに現れるような整数が存在することを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ K\leq\ N\ \leq\ 150 $
- $ 10^8\leq\ M\leq\ 10^9 $
- $ N,K,M $ は整数である

### Sample Explanation 1

$ 0 $ 以下または $ 4 $ 以上の整数すべてと、$ 1,2,3 $ のうちの $ 1 $ つ以上を含むような集合すべてが条件を満たし、これは $ 7 $ 通りあります。

## 样例 #1

### 输入

```
3 1 998244353```

### 输出

```
7```

## 样例 #2

### 输入

```
6 3 998244353```

### 输出

```
61```

## 样例 #3

### 输入

```
9 4 702443618```

### 输出

```
312```

## 样例 #4

### 输入

```
17 7 208992811```

### 输出

```
128832```

## 样例 #5

### 输入

```
123 45 678901234```

### 输出

```
256109226```

# 题解

## 作者：淸梣ling (赞：14)

# Solution

其他题解基本都把思路写出来了，这里具体说一下 DP 如何转移。

考虑删除数字 $x$ 时，会产生 $x-2$ 和 $x+k$，考虑 $x$ 向 $x-2$  和 $x+k$ 连边，那么假设我们删除了一部分点集，这些点集中一定没有环，否则是删不完的（手玩一下就知道了）。此时就相当于求多少点集内不形成环。

观察一下连边的性质，$x$ 到 $x-2$ 的奇偶性没有变，那么我们选择对 $k$ 分奇偶：

1. $k$ 为偶数，那么此时奇数与偶数之间没有连边，所以可以看成相同的两部分，对于奇偶性相同的形成一条链，并且 $x$ 向 $x+k$ 连边，所以不能**连续选择超过**  $k/2$ 个点。那么我们直接 DP 即可。

   设 $f_{i,j}$ 为长度为 $i$ 的链，最后连续选择的一段长度为  $j$，转移方程：
   $$
   f_{i,j} = f_{i-1,j-1}\ (j>1) \\\\ 
   f_{i,0} = \sum_{j=0}^k f_{i,j}
   $$ 

2. $k$ 为奇数，此时奇偶之间每个点刚好一个入边，一个出边，我们先把图画出来。（设 $k=3$）

![AGC045E-pic](https://cdn.luogu.com.cn/upload/image_hosting/0li8nm8m.png)

我们像上面一样对齐，如果不看偶数向奇数连边，那么所有边都是向上连的，所以我们可以选择从上向下逐层添加节点，来进行 DP。层数就是 $m=\lfloor \frac{n+k}{2} \rfloor$。

观察上图，可以发现每个环的大小都是  $k+2$，这个性质很重要，环的大小固定，那么 DP 就简单很多。

我们设 $f[i][j][q]$ 为**遍历到第 $i$ 层，从右边开始最长连续段为 $j$，从左边开始最长连续段为 $q$ 的方案数**。这里要注意，我们 DP 时，要保证左侧的最长链一定延伸到了右侧，同时偶数向奇数的连边只用来判断是否成环，最长连续段中是没有这种边的，也就是一直保证**偶数向奇数的连边不会用上**，所以只要保证左侧最长链小于 $k+2$，那么自然不会成环。

考虑新加入的一层的两个节点，分为三种情况：

1. **两个节点都不选**，此时左右两侧的最长连续段都清零，即：
   $$
   f[i][0][0]=\sum_{j=0}^n \sum_{q=0}^{k+1} f[i-1][j][q]
   $$

 

2. **左侧选，右侧不选**，此时右侧最长链变为 $0$，如果左侧最长边不为 $0$，左侧最长链加一，否则因为左侧最长链延伸到右侧需要有一层同时选择两个节点，所以此时不成立，左侧最长链还是 $0$。同时要保证有左侧节点，观察上面的图，两个链错位了 $(k-1)/2$ 位，所以最上面只有右侧点的有 $(k-1)/2$ 层，也就是 $k-1$ 个节点，那么此时可以得到转移方程：
   $$
   2i \ge k+1
   \begin{cases}
   \displaystyle f[i][0][q+1] = \sum_{j=0}^n \sum_{q=1}^{k+1} f[i-1][j][q] \\\\
   \displaystyle f[i][0][0]=\sum_{j=0}^n f[i-1][j][0]
   \end{cases}
   $$
   

3. **左侧不选，右侧选**，此时左侧最长链变为 $0$，右侧最长链加一。我们一样需要保证有右侧节点，右侧节点一共有 $\lfloor \frac n2 \rfloor$ 层，不应超过 $n$ 个节点：
   $$
   f[i][j+1][0] = \sum_{j=0}^n \sum_{q=0}^{k+1} f[i][j][q]\ (2i \le n)
   $$
 

4. **两个节点都选**，此时右侧最长链加一，对于左侧，可以继承之前的左侧最长链，长度为 $q+1$，也可以在这一层横着走到右边，继承右侧最长链，长度为 $j+2$，设 $w=\max(q+1, j+2)$，那么可以得到转移方程：
   $$
   f[i][j+1][w] = \sum_{j=0}^n \sum_{q=0}^{k+1} f[i][j][q]\ (k+1 \le 2i \le n)
   $$
   

最后答案自然就是  $\sum_{j=0}^n \sum_{q=0}^{k+1} f[m][j][q]$，时间复杂度 $O(nk^2)\ or\ O(n^2k)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
ll p;
int n,k;
ll f[200][200],g[200][200][200];

void work1()
{
    ll ans=0;
    int m=(n+k)/2;
    g[0][0][0]=1;
    for(int i=1; i<=m; i++)
    {
        // 都不选
        for(int j=0; j<=n; j++)
        for(int q=0; q<=k+1; q++)
        g[i][0][0]=(g[i][0][0]+g[i-1][j][q])%p;

        // 只选右
        if(i*2<=n)
        for(int j=0; j<=n; j++)
        for(int q=0; q<=k+1; q++)
        g[i][j+1][0]=(g[i][j+1][0]+g[i-1][j][q])%p;

        // 只选左
        if(i*2>=k+1)
        for(int j=0; j<=n; j++)
        {
            for(int q=1; q<=k+1; q++)
            g[i][0][q+1]=(g[i][0][q+1]+g[i-1][j][q])%p;
            g[i][0][0]=(g[i][0][0]+g[i-1][j][0])%p;
            // 特判只有一个点，此时没用，当成0个点
        }

        // 左右都选
        if(i*2>=k+1&&i*2<=n)
        for(int j=0; j<=n&&j+1<=k+1; j++)
        for(int q=0; q<=k+1; q++)
        g[i][j+1][max(q+1, j+2)]=(g[i][j+1][max(q+1, j+2)]+g[i-1][j][q])%p;
    }

    for(int i=0; i<=n; i++)
    for(int j=0; j<=k+1; j++)
    ans=(ans+g[m][i][j])%p;
    cout<<ans;
}
void work2()
{
    ll sum1=0,sum2=0;
    f[0][0]=1; k/=2;
    for(int i=1; i<=n; i++)
    for(int j=0; j<=k; j++)
    {
        f[i][0]=(f[i][0]+f[i-1][j])%p;
        if(j) f[i][j]=(f[i][j]+f[i-1][j-1])%p;
    }
    for(int i=0; i<=k; i++)
    {
        sum1=(sum1+f[n/2][i])%p;
        sum2=(sum2+f[(n+1)/2][i])%p;
    }
    cout<<sum1*sum2%p;
}
int main()
{
    cin>>n>>k>>p;
    if(k&1) work1();
    else work2();
    return 0;
}
```



---

## 作者：feecle6418 (赞：7)

题意可以转化为，删掉的数 $x\to x-2,x+K$ 连边，不存在环（若不存在，按逆拓扑序删除即可；若存在，这些数都不能删除）

如果 $K$ 是偶数，奇偶分别 dp 即可，以下默认 $K$ 是奇数。

可以发现，不存在环等价于，把所有删了的数在一个长度为 $n$ 的 01 串中设为 1，不存在形如 `1*1*1*..1*11..11*1*1*1...*1` 的子串（`*` 匹配任意**一个**字符，中间 `1` 的个数为大于等于 $3$ 的奇数，上面字符串中不算 `*`，总 `1` 数恰为 $K+2$）

把奇数位置、偶数位置排成两行，那么就是不能存在以下图形（也不能存在以下图形反过来）：

```
... 1 1 1 1 1 1 1 ... 
(m 个 1)
... ? 1 1 1 1 ? ? ... 
(至少有 K+2-m 个 1，下面的对称中心是上面的对称中心左移 0.5 格)
```

或者

```
... ? ? 1 1 1 1 ? ... 
(至少有 K+2-m 个 1，下面的对称中心是上面的对称中心左移 0.5 格)
... 1 1 1 1 1 1 1 ... 
(m 个 1)
```

这个做法的后半部分是神仙 crn 教我的，orz crn！

设 $f(p,i,j,k)$ 表示现在算到了第 $p$ 个位置，和 $p$ 奇偶性相同的一行自从 $i$ 以来就全是 1，和 $p$ 奇偶性不同的一行从 $j$ 以来就全是 1 的前 $p$ 个位置，

- $i<j$：目前的限制是和 $p$ 奇偶性相同的一行最右边至多能填到 $k$ 的方案数。
- $i>j$：目前的限制是和 $p$ 奇偶性不同的一行最右边至多能填到 $k$ 的方案数。

转移：

- $f(p,i,j,k)\to f(p+1,n+1,i,?)$（不填第 $p+1$ 个位置，$?$ 的位置如果 $i<j$ 就是 $k$ 否则是 $n+1$）
- $f(p,i,j,k)\to f(p+1,\min(p+1,j),i,\min(k,R))$（$i<j$，填第 $p+1$ 个位置，拿 $[i,p]$ 和 $[j,p+1]$ 算出来 $p$ 这一行最多能填到 $R$ ）（$i>j$，填第 $p+1$ 个位置，拿 $[i,p]$ 和 $[j',p+1]$ 算出来 $p+1$ 这一行最多能填到 $R$，要求 $\min(k,R)\ge p+1$）

这里附一个有详细注释 dp 的代码，因为真的很容易写错！（调了一晚上）

```cpp
for(int i=n+1;i>=1;i--){
	if(i!=n+1&&(i%2!=p%2||(i<=n&&i>p)))continue;//=n+1 表示没限制
	for(int j=n+1;j>=1;j--){
		if(j!=n+1&&(j%2==p%2||(j<=n&&j>p)))continue;
		for(int k=1;k<=n+1;k++){
			if(!f[P][i][j][k])continue;//P,Q 是滚动数组，其实 P=p,Q=p+1
			if(i<j){//假如限制在 i 这个奇偶性上，那么就算不填 p+1 这个限制仍然存在
				if(p<k)upd(f[Q][n+1][i][k],f[P][i][j][k]);
			}
			else upd(f[Q][n+1][i][n+1],f[P][i][j][k]);//否则就没限制了
			int R=n+1,J=min(j,p+1);
			if(i<J){//这里是算 R 的过程，i<J 说明 p 这边长一些
				int s=(p+1-J)/2+1;//算出 [J,p+1] 之间有几个 1
				int u=K+2-s,s2=(p-i)/2+1;//还剩 u 个 1 要填在 p 这边，已经填了 s2 个
				if(s2-s>=(u-s-1)/2)R=p+(u-s+1);
				//s2-s 是 p 这边左边延伸出去的长度，(u-s-1)/2 是需要的长度
				//只有已经填上的 >= 需要的，才会有限制
				//经过观察可以发现，左边需要伸出去 (u-s-1)/2，右边需要伸出去 (u-s+1)/2
				//“伸出去 x” 其实在坐标上相当于坐标 +2x，所以新限制是 p+(u-s+1)/2*2
			}
			else if(i!=n+1){//下面同理
				int s=(p-i)/2+1;
				int u=K+2-s,s2=(p+1-J)/2+1;
				if(s2-s>=(u-s+1)/2)R=p+1+(u-s-1);
			}
			if(min(k,R)<=p+1)continue;
			upd(f[Q][J][i][min(k,R)],f[P][i][j][k]);
		}
	}
}
```

时间复杂度 $O(n^4)$。（这好像是 AGC 标算）

---

## 作者：Judgelight (赞：6)

[传送门](https://www.luogu.com.cn/problem/AT_agc035_e)

---

偶数就不提了，我们只考虑奇数的情况。

我们以 $n=10,k=5$ 为例，把点 $i$ 往 $i-2$ 和 $i+k$ 连边得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vuyq0n4e.png)

首先考虑一下假如我们要删除一个点集 $S$，如果它不能通过任意的顺序删掉，那么它一定是一个环（删掉一个环上的下一个点就会出现）。所以我们需要统计所有不成环的 $S$ 有多少个。我们先看一下一种成环的方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/bid4cedt.png)

用红色圈起来的恰好 $7=k+2=5+2$ 个点通过绿色的这些边成为了一个环。

所以就不难得出，像这样的**连通**的一条横跨左右的链，是成环的唯一方式，且我们任意的集合 $S$ 都能通过这样的结构组合起来，且还有一个关键性质：这样的链如果长度大于等于 $k+2$ 了，必定成环。这样的链一定是从左边出发，跨过左右，在右边结束的。

可以从这一点出发进行 DP。由于这个图是从上到下天然分层的，依照这个来 DP。

设 $f_{i,l,r}$ 表示到第 $i$ 层，以第 $i$ 层的左边点为出发点的最长链长度为 $l$，以第 $i$ 层的右边点为出发点的最长链长度为 $r$ 的方案数。

每次的决策无非就四种：一个不选，只选左边点，只选右边点，两边都选。

首先要注意到一开始的一些层是没有左边的，这些层就只能一个不选或者只选右边；结尾处的一些层是没有右边的，这些层就只能一个不选或只选左边。

然后就是纯粹的方程了，首先是一个不选，那么这种情况下显然是 $l,r$ 都归零了，所以：

$$
f_{i,0,0}\gets\sum\limits_{l}\sum\limits_{r}f_{i-1,l,r}
$$

然后是只选左边：

$$
f_{i,0,0}\gets\sum\limits_{r}f_{i-1,0,r}
$$

$$
f_{i,l,0}\gets\sum\limits_{r}f_{i-1,l-1,r}
$$

只选右边：

$$
f_{i,0,r}\gets\sum\limits_{l}f_{i-1,l,r-1}
$$

两边都选，这种情况需要考虑一下 $l$（最长链）到底是什么，需要对 $l+1$ 和 $r+2$ 取一个最大值：

$$
f_{i,\max(l+1,r+2),r+1}\gets f_{i-1,l,r}
$$

然后这道题就被我们以 $O(n^4)$ 的复杂度愉快地解决啦。

---

## 作者：ez_lcw (赞：6)

对于某个集合 $S\subseteq\{1,\cdots,n\}$，考虑能不能删去 $S$。

对于任意 $x\in S$，连边 $x\to x-2$（如果 $x-2\in S$）及 $x\to x+k$（如果 $x+k\in S$），那么能把 $S$ 删去当且仅当这张图是一个 DAG。

于是我们先对所有点都这么连边形成图 $G$，那么 $S$ 合法当且仅当 $S$ 在 $G$ 中的导出子图是个 DAG，即无环。

对于所有 $x\to x-2$ 的边，它们形成了两条链，分别称为奇链和偶链。然后我们对 $k$ 的奇偶性分类讨论：若 $k$ 是偶数，那么这两条链是不连通的（独立的），而无环相当于要求每条链中不连续选 $k/2+1$ 个点，这个方案数很好统计（注意数据范围不大，暴力 DP 即可）。

若 $k$ 是奇数，情况就复杂些。首先，若出现了环，那么一定经过了正偶数条 $x\to x+k$ 的边（经过一次会改变一次当前点的奇偶性）。接下来我们证明，一个简单环必定只经过了恰好 $2$ 条 $x\to x+k$ 的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/zwsnx2f8.png)

对于任意一个简单环 $C$，取其编号最小的点 $a$，那么环中 $a$ 的上一个点一定是 $a+2$，下一个点一定是 $a+k$（记为 $b$）。而且我们发现，对于 $a,a+2,\cdots,b-1$ 中的任意一个点 $x$，$x$ 在环中都不可能是 $+k$ 得到的（否则 $a$ 不是最小点），于是我们已经可以确定 $C$ 的一部分形态，如上图左上。

接着，$b$ 在环中接下来肯定是先走若干步 $-2$（可以是 $0$ 步，但不能超过 $a$）走到 $c$，然后再走一步 $+k$ 走到 $d$，如上图左下。

接着，如上图右，我们又继续考虑 $e=b+1$ 这个点是从哪来的，若它是 $+k$ 得到的，那么就必然要经历从 $b-1,b$ 右侧到 $b-1,b$ 左侧的过程（从 $d$ 经过若干步到达 $a+1$），这个过程中一定会再次经过 $b-1,b$ 中的某一个点，这就与该环是简单环矛盾了。从而，$e$ 是从 $e+2$ 来的。类似地，可以推出 $b+1,b+3,\cdots,d-2$ 中的每一个点 $x$ 都是从 $x+2$ 来的，这就和 $d$ 接起来了。

于是 $C$ 只有可能是 $a\xrightarrow{\text{一步}+k}b\xrightarrow{\text{若干步}-2}c\xrightarrow{\text{一步}+k}d\xrightarrow{\text{若干步}-2}a$ 的形态。

那么，现在限制改为了，$S$ 在 $G$ 中的导出子图不能出现环，且该环恰经过两次 $+k$，如下图左上。

![](https://cdn.luogu.com.cn/upload/image_hosting/yki5gas8.png)

假设 $S$ 已经选好了，怎么快速判断是否存在这样的环：可以从每个 $S$ 中的奇数编号的点 $x$ 开始，按如下方式找一条路径（称为 $x$ 的找环路）并检查：

- 找到最小的 $y$ 使得 $\{y,y+2,\cdots,x-2,x\}\subseteq S$。 

- 找到最小的 $z$ 使得 $z\in\{y,y+2,\cdots,x-2,x\}$ 且 $z+k\in S$。若找不到这样的 $z$ 那么跳过从 $x$ 开始的检查。

- 找到最小的 $w$ 使得 $\{w,w+2,\cdots,z+k-2,z+k\}\subseteq S$。

- 考虑路径 $P=x\to x-2\to \cdots\to z\to z+k\to z+k-2\to \cdots\to w$，若 $P$ 长度大于等于 $k+2$，那么我们就找到了一个环。

如上图左下，图中的红蓝两条路径就是从两个不同的 $x$ 开始的找环路。

容易证明，按照上述方式，若找不到任何一个环，那么图中就确实不存在环（因为从我们所述的 $z$ 跳到 $z+k$，是能使得 $P$ 的长度尽量大的）。

那么考虑 DP。如上图右，设 $f_{i,\ell_1,\ell_2}$ 表示考虑完 $[1,i]$ 中的奇数点和 $[1,i+k]$ 中的偶数点，其中从 $i$ 开始的找环路经过的点数为 $\ell_1$，而从 $i+k$ 开始不断 $-2$ 所能经过的点的个数为 $\ell_2$ 的方案数。

转移的时候，考虑从 $i+2$ 开始的找环路（假设 $i+2\in S$）：若 $i\in S$ 且存在从 $i$ 开始的找环路，那么从 $\ell_1$ 转移过来；否则从 $\ell_2$ 转移过来。转移是 $O(1)$ 的。

时间复杂度 $O(nk^2)$，注意 DP 时若 $\ell_2> k+2$ 我们可以直接把它看做 $k+2$。



---

## 作者：JohnJoeZhu (赞：3)

起来先建模

首先我们手膜一下，发现如果 $a-2,a-2-2,a-2-2+k=a$

那么实际上你就删除了个寂寞

$x\rightarrow x-2,x\rightarrow x+k$

看得就很像一个图

于是我们建个图，连边 $x\rightarrow x-2,x\rightarrow x+k$

然后有解的条件无非就是无环

无环了我们就按拓扑排序的方式一个个删，有环删了多少圈也删不掉

但是我们可以知道，在图上计数是非常麻烦的，解决方法无非就是转化为树上问题，转化为$\text{DAG}$上问题，发现某些性质简化图从而实现计数。

那么看来看去，前两者都是不太可行的，但是这个图本身就很有特点。

首先，分类讨论
### $2|K$
这个好弄，因为奇偶是分离的。

那么合法的方案，就是不要连续选$K/2+1$个。

否则容易发现有一个环嘛。

这个就从图上问题变成序列上问题，而且用dp轻松解决。

设$f[i][j]$表示目前选到$i$，最后连续选了$j$个

$$f[i][j]=f[i-1][j-1]+\sum_1^{i-1} f[k][0]$$

因为奇偶分离，答案就是$(\sum f[N/2])\times(\sum f[\lceil N/2\rceil])$
### $2\not|K$
这个就比较麻烦

首先奇偶是有联系的，但是联系并非毫无特点。

显然我们可以先把奇偶分开来，各放一边。

对于一个结点，从对面（即不同奇偶）来的边，至多两条。

一条$x-k\rightarrow x$，一条$x\rightarrow x+k$

这个是性质。

我们可以继续考虑dp，当然要考虑如何dp。

那么就要考虑dp的依据。

依据不就是没有环嘛。

但是你会发现没有环这个限制条件，还不够具体，如果我们只是考虑没有环，难不成我们要把所有的点的状态记下来？

考虑如果一个一个点从小到大考虑。

首先dp嘛，通过设计状态，我们可以不关注与最后一个点无关的环（在该状态前就已经保证），也不需要关注这个点后面会形成的环（在该状态后会保证）。

那么就要考虑，与该点有关的，由这个点前面的点，组成的环有什么特点。

因为最大值就到这个点，所以这个环从这个点出发，从这个点结束。

那对于x，可能的环就是：$x,x-2,x-4...y-k,y,y-2,y-4...x-k,x$

其中y与x不同奇偶，形成了类似于8字形的环

那么这个环的特点有什么

首先，满足我们探究的要求的环是不唯一的，也就是y有多个。

其次，环的大小是唯一的，大小为$k+2$（想想为什么）

沿用我们上一个类型的思路，大小唯一的环，要不形成环，只需要满足，不连续选择$k+2$个点。

可是环的形态不唯一啊，不可能每一种形态都记录大小啊。

那我只在乎最大环就好了嘛。

只要最大值都小于$k+2$，就一定满足。

当然这个设计还不够优秀。

我们要一个一个点加入吗？

其实未必，我们可以考虑奇偶两个点一起加入，也就是左边和右边的点一起加入。一次加入一层点。

然后我们对环的判断，是基于以x为最大的奇或偶数进行的。

如果要把所有可能都考虑到，我们就不能12，34，56为一对地加点，因为有可能出现加入新的点后，一些状态没有考虑到。

所以要$x,x+k$为一对加点，也就是保证以x为最大的奇或偶数的所有的环，在这一步都考虑过了。

然后就可以设计$\text{dp}$了。

设$f[i][j][k]$表示遍历到第$i$层，以$i$层左侧点开始，最长的链长度为$j$（也就是判最有可能形成环的链），右侧已经连续选了$k$个点。

注意点的分布是先只有右侧的点，然后都有，然后只有左侧的点。

都不选
$f[i][0][0]=\sum f[i-1][j][k]$

只选左侧
$f[i][j][0]=\sum f[i-1][j-1][k]$

只选右侧
$f[i][0][k]=\sum f[i-1][j][k-1]$

都选
$f[i][max(j,k)][k]=\sum f[i-1][j-1][k-1]$



---

## 作者：xht (赞：3)

## [Develop](https://atcoder.jp/contests/agc035/tasks/agc035_e)

### 题意

- 给定 $n,k$。
- 设 $S$ 为整数的全集，求通过若干次下列操作可以得到多少个不同的集合：
  - 选择 $x \in S \cap [1,n]$，将 $x$ 从 $S$ 中去掉。
  - 对于 $x-2$ 和 $x+k$，若不在 $S$ 中，则加进 $S$。
- $1 \le k \le n \le 150$，答案对 $P$ 取模。

### 题解

考虑一个编号为 $1 \sim n$ 的有向图，连边 $(x,x-2)$ 和 $(x,x+k)$（如果存在）。

则每次操作相当于将一个点染黑，将其后继染白，其中初始时所有点都是白的，问最终形成的图有多少种方案。

显然黑点不能构成环，所以黑点一定是个 DAG，那么按照拓扑序选择黑点即可，于是问题等价于求给定图不存在黑环的方案数。

对 $k$ 分奇偶考虑然后简单 DP 一下即可。

### 代码

```cpp
const int N = 157;
int n, K;
modint f[N][N], g[N][N][N], ans, ans0, ans1;

int main() {
	rd(n, K, P);
	if (K & 1) {
		g[0][0][0] = 1;
		int m = (K >> 1) + ((n + 1) >> 1);
		for (int i = 0; i < m; i++)
			for (int j = 0; j <= n >> 1; j++)
				for (int k = 0; k <= K + 1; k++) {
					g[i+1][0][0] += g[i][j][k];
					if (i < n >> 1) g[i+1][j+1][0] += g[i][j][k];
					if (i >= K >> 1) g[i+1][0][k?k+1:0] += g[i][j][k];
					if (i >= (K >> 1) && i < (n >> 1)) g[i+1][j+1][max(j+2,k+1)] += g[i][j][k];
				}
		for (int j = 0; j <= n >> 1; j++)
			for (int k = 0; k <= K + 1; k++)
				ans += g[m][j][k];
		print(ans);
	} else {
		f[0][0] = 1;
		for (int i = 0; i < n; i++)
			for (int j = 0; j <= min(i, K >> 1); j++)
				f[i+1][j+1] += f[i][j], f[i+1][0] += f[i][j];
		for (int j = 0; j <= K >> 1; j++)
			ans0 += f[n>>1][j], ans1 += f[(n+1)>>1][j];
		print(ans0 * ans1);
	}
	return 0;
}
```

---

## 作者：yshpdyt (赞：2)

## 题意

初始时集合 $S$ 内有 $[-10^{18},10^{18}]$ 内的所有整数，你可以进行若干次如下操作：
- 选择一个 $S$ 内的位于 $[1,n]$ 的数字 $x$。
- 删去 $x$，然后加入 $x-2$ 和 $x+k$（如果他们不在 $S$ 内的话）。

求最后可能的所有不同 $S$ 数量，对给定模数取模。

$k\le n\le 150$ 

## Sol
删除一个数，则必须加入两个数描述了一种转移，考虑建图来刻画这种关系：

- 连边 $x\rightarrow (x-2)$ 和 $x\rightarrow (x+k)$，表示若删除 $x$ 则一定会加入 $(x-2)$ 和 $(x-k)$。

连边后位于环上的点是不可同时删除的，而其它点则可以按照拓扑序任意删除，若设最后不在集合内点集为 $T$，则 $T$ 内所有点一定不成环。

集合 $S$ 合法的条件有关被删除数，而对于每个不同的 $S$ 都对应一种 $T$，这启示我们直接对 $T$ 计数。

现在的问题变成了，给定你一张特殊图，你可以选择若干图上的点，使得选出来的点不成环，求所有合法选点方案数。

分析图的性质，注意到 $x\rightarrow (x-2)$ 这类边方向固定，且奇数偶数分别连边：

![](https://cdn.luogu.com.cn/upload/image_hosting/fyvfimmx.png)

而对于边 $x\rightarrow x+k$ 则相当于添加了返祖边，是成环的主要原因。

根据 $k$ 的奇偶性，连边也会有所不同，以此来分类讨论。
### $n=k$
不存在边 $x\rightarrow x+k$，于是答案为 $2^n$ 。
### $2\mid k$
对于 $k=4$ 的图如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/8yobu79w.png)

这种情况两条链的情况独立，可以分开来计算，注意到此时环长均为 $\frac{k}{2}+1$ 个点，且环上点连续，于是我们只需要计数最多连续选 $m=\frac{k}{2}$ 个点的方案即可，考虑简单的暴力 dp  记 $f(i,j)$ 表示考虑到了前 $i$ 个点，连续选了 $j$ 个点的方案，转移是简单的：

$$f(i,0)=\sum\limits_{j=0}^{m} f(i-1,j)$$

$$f(i,j)=f(i-1,j-1)$$

最终的答案是：
$$\sum\limits_{i=0}^m \sum\limits_{j=0}^m f(\left\lceil\frac{n}{2}\right\rceil,i)\times f(\left\lfloor\frac{n}{2}\right\rfloor,j)$$

这部分时间复杂度 $O(n^2)$。
### $2\nmid k$

~~偷~~借一张图，$k=3$ 的情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/0li8nm8m.png)

类似这样的图，我们从上往下依次分层。

找一个简单环的特征：**环长一定为 $k+2$，有一层左右两个点都要选，记这两个点分别为 $L,R$，则左边以 $L$ 为终点向下选若干，右边以 $R$ 为起点向上选若干。**

如果你对接下来的转移方程有疑惑，一定要回来细品理解环的形态。

于是可以记总的层数为 $m$，$f(i,j,p)$  表示考虑到了第 $i$ 层，可以成环的链当前长度为 $j$，右边选的最长连续链为 $p$，对每一层的选点情况讨论转移：

#### 都不选
则 $i-1$ 层及前面的情况无论如何都不会成环了，于是可以随便选。
$$f(i,0,0)\leftarrow f(i-1,j,p)$$

#### 都选
当前可以成环的最长链，要么继承 $i-1$ 层的最长链 $j$，要么选择这一层的两个点，接上右边长为 $p$ 的链，变成 $p+2$。
$$f(i,\max(j+1,p+2),p+1)\leftarrow f(i-1,j,p)$$

#### 只选左
如果 $j>1$ 很明显是：

$$f(i,j+1,0)\leftarrow f(i-1,j,p)$$

但如果 $j=0$，则：
$$f(i,j,0)=f(i-1,0,p)$$

因为我们考虑的是最长的可以成环的链，只选左边一个点，而不选右边的点的长为 $1$ 的链显然是不可能成环的，所以应当算给长度为 $0$ 的贡献，所以 $j=1$ 永远没有方案。
#### 只选右

$$f(i,0,q+1)\leftarrow f(i-1,j,q)$$

最后的答案即为：

$$\sum\limits_{j=0}^{k+1}\sum\limits_{p=0}^{\lfloor n/2 \rfloor} f(m,j,p)$$


时间复杂度 $O(n^3)$ 。


## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 155
#define endl "\n" 
#define fi first
#define se second
using namespace std;
ll mod=1e9+7;
const ll inf=1e18;
const double eps=1e-6;
ll n,k;
ll fpow(ll x,ll y){
    ll res=1;
    while(y){
        if(y&1)res=res*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}
namespace sol1{
    ll le[N],ri[N];
    ll f[N][N][N],bel[N];
    void sol1(){
        ll m=0;
        for(int i=2;i<=n;i+=2){
            ri[i/2]=i;
            bel[i]=i/2;
            m=max(m,bel[i]);
            if(i>k){
                le[i/2]=i-k;
                bel[i-k]=i/2;
            }
        }
        for(int i=3;i<=n;i+=2){
            bel[i]=bel[i-2]+1;
            m=max(m,bel[i]);
            le[bel[i]]=i;
        }// 一种很抽象的算每个点所属层数，其实有公式但是我懒得推。
        f[0][0][0]=1;
        for(int i=1;i<=m;i++){
            for(int l=0;l<=k+1;l++){
                for(int r=0;r<=n/2;r++){
                    f[i][0][0]=(f[i][0][0]+f[i-1][l][r])%mod;
                    if(le[i]){
                        if(l)f[i][l+1][0]=(f[i][l+1][0]+f[i-1][l][r])%mod;
                        else f[i][0][0]=(f[i][0][0]+f[i-1][l][r])%mod;
                    }
                    if(ri[i])f[i][0][r+1]=(f[i][0][r+1]+f[i-1][l][r])%mod;
                    if(le[i]&&ri[i])f[i][max(l+1,r+2)][r+1]=(f[i][max(l+1,r+2)][r+1]+f[i-1][l][r])%mod;
                }
            }
        }
        ll res=0;
        for(int i=0;i<=k+1;i++){
            for(int j=0;j<=n/2;j++){
                res=(res+f[m][i][j])%mod;
            }
        }
        cout<<res<<endl;
    }
}
namespace sol2{
    ll f[N][N];
    void sol2(){
        ll m=(n-1)/2+1;
        f[0][0]=1;
        for(int i=1;i<=m;i++){
            f[i][0]=f[i-1][0];
            for(int j=1;j<=k/2;j++){
                f[i][j]=f[i-1][j-1];
                f[i][0]=(f[i][0]+f[i-1][j])%mod;
            }
        }
        ll res=0;
        for(int i=0;i<=k+1;i++){
            for(int j=0;j<=k+1;j++){
                res=(res+f[n/2][i]*f[(n-1)/2+1][j])%mod;
            }
        }
        cout<<res<<endl;
    }
}
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin>>n>>k>>mod;
    if(n==k){
        cout<<fpow(2,n)<<endl;
        return 0;
    }
    if(k&1)sol1::sol1();
    else sol2::sol2();
    return 0;
}
```

---

## 作者：mRXxy0o0 (赞：2)

# 分析

把原问题变成一个有向图，$x$ 向 $x-2$ 和 $x+K$ 连边吗，即求选出无环点集的数量。

先按照 $K$ 的奇偶分类讨论一下。

## $K$ 是偶数

即至多连续选 $\frac K 2$ 个数的方案数。

奇数下标和偶数下标是两个相同的子问题，分别求解再相乘即可。

设 $f_{i,j}$ 表示讨论到第 $i$ 位，与第 $i$ 位相连的选择的数长度为 $j$ 的方案数。简单转移即可。

## $K$ 是奇数

因为任意环是由简单环构成的，所以只要满足无简单环即可。由于此题的性质，发现这样的简单环总是由 $K$ 个 $-2$ 连边和两个 $+K$ 连边构成，那么我们把点按奇偶分成左右两部（图示是一楼大佬题解，这里借用一下，膜拜大佬），并对左右进行一定的偏移。

这里 $K=3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0li8nm8m.png)

由于上面所述的性质，进一步发现，任何简单环都可以选出一个左部中下标最大的点，我们希望在这个点规避掉以它为代表的环。其次，从这个代表点出发走 $K+2$ 步且经过一次 $+K$ 的边之后，总是构成一个环，构成环的集合与以该点为代表的环的集合一致。

称平着的点位一层，设 $f_{i,j,k}$ 表示第 $i$ 层从左部出发最长走了 $j$ 步，右部出发**仅向上**最长走了 $k$ 步的方案数。这里设 $k$ 的目的是辅助转移 $j$，注意这里的 $j$ 与 $k$ 的定义。

转移可以讨论同层选没选。根据定义，只要 $j<K+2$ 就可以确保一定没有环。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int N=160;
int n,k,mod;
inline int mo(int x){
	return x<mod?x:x-mod;
}
namespace s0{
	int f[N][N];
	inline void solve(){
		f[0][0]=1;
		k>>=1;
		for(int i=1;i<=n;++i){
			for(int j=0;j<=k;++j){
				f[i][0]=mo(f[i][0]+f[i-1][j]);
				if(j) f[i][j]=mo(f[i-1][j-1]+f[i][j]);
			}
		}
		int ans1=0,ans2=0;
		for(int i=0;i<=k;++i){
			ans1=mo(ans1+f[n/2][i]);
			ans2=mo(ans2+f[(n+1)/2][i]);
		}
		printf("%lld",1ll*ans1*ans2%mod);
	}
}
namespace s1{
	int f[N][N][N];
	inline void solve(){
		int m=(n+k)/2;
		f[0][0][0]=1;
		for(int i=1;i<=m;++i){
			for(int j=0;j<=k+1;++j){
				for(int x=0;x<=n;++x){
					f[i][0][0]=mo(f[i][0][0]+f[i-1][j][x]);
					if(2*i>=k+1){
						if(j) f[i][j+1][0]=mo(f[i][j+1][0]+f[i-1][j][x]);
						else f[i][0][0]=mo(f[i][0][0]+f[i-1][0][x]);
					}
					if(2*i<=n) f[i][0][x+1]=mo(f[i][0][x+1]+f[i-1][j][x]);
					if(2*i>=k+1&&2*i<=n&&x<=k) f[i][max(j+1,x+2)][x+1]=mo(f[i][max(j+1,x+2)][x+1]+f[i-1][j][x]);
				}
			}
		}
		int ans=0;
		for(int i=0;i<=k+1;++i)
			for(int j=0;j<=n;++j) ans=mo(ans+f[m][i][j]);
		printf("%d",ans);
	}
}
int main(){
	scanf("%d%d%d",&n,&k,&mod);
	if(k&1) s1::solve();
	else s0::solve();
	return 0;
}
```


---


# [ARC170F] Edge Deletion 2

## 题目描述

给定一棵有 $N$ 个顶点的树，顶点编号为 $1$ 到 $N$。树的第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$，为无向边。

对于 $1$ 到 $N$ 的一个排列 $P=(P_1,\ldots,P_N)$，定义数列 $A(P)$ 如下：

- $A(P)$ 初始为空。对每个顶点 $i$，在顶点 $i$ 上写下 $P_i$。
- 按照 $i=1,2,\ldots,N$ 的顺序，依次进行以下操作：
  - 如果顶点 $i$ 是孤立点，则在 $A(P)$ 的末尾添加 $0$。
  - 否则，从与顶点 $i$ 相邻的顶点中，选择写有最小整数的顶点。将该顶点上写的整数添加到 $A(P)$ 的末尾，并删除顶点 $i$ 与该顶点之间的边。

请你在所有可能的 $A(P)$ 中，求出字典序最小的一个。

给定 $T$ 组测试数据，请分别输出答案。

## 说明/提示

### 数据范围

- $1\leq T\leq 10^5$
- $2\leq N\leq 2\times 10^5$
- $1\leq u_i,v_i\leq N$
- 给定的图一定是一棵树
- 输入的所有数均为整数
- 所有测试用例中 $N$ 的总和不超过 $2\times 10^5$

### 样例解释 1

对于第 $1$ 个测试用例，$P=(4,1,2,3,5)$ 时，$A(P)=(1,2,0,1,3)$，具体过程如下：

- 顶点 $1$ 相邻顶点中，写有最小整数的是顶点 $2$。将 $P_2=1$ 添加到 $A(P)$ 末尾，并删除顶点 $1$ 与顶点 $2$ 的边。
- 顶点 $2$ 相邻顶点中，写有最小整数的是顶点 $3$。将 $P_3=2$ 添加到 $A(P)$ 末尾，并删除顶点 $2$ 与顶点 $3$ 的边。
- 顶点 $3$ 是孤立点，因此在 $A(P)$ 末尾添加 $0$。
- 顶点 $4$ 相邻顶点中，写有最小整数的是顶点 $2$。将 $P_2=1$ 添加到 $A(P)$ 末尾，并删除顶点 $4$ 与顶点 $2$ 的边。
- 顶点 $5$ 相邻顶点中，写有最小整数的是顶点 $4$。将 $P_4=3$ 添加到 $A(P)$ 末尾，并删除顶点 $5$ 与顶点 $4$ 的边。

可以证明，这是所有可能的 $A(P)$ 中字典序最小的。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
5
1 2
2 3
2 4
4 5
8
8 6
7 2
2 1
3 7
5 6
1 6
4 3
7
7 1
5 2
1 2
6 5
4 1
5 3```

### 输出

```
1 2 0 1 3
1 2 2 3 1 4 0 0
1 2 2 0 3 0 4```

# 题解

## 作者：zhouhuanyi (赞：2)

某人竟然忘记了星期天晚上有 $\text{ARC}$，我不说是谁。

首先选择最小点删除和最小字典序都是最小化，所以可以弱化最小点删除的限制，现在原问题就变成了可以删除任意一个点的出边，如果没有出边则为 $0$(这个其实本题中是最优的策略)。

如果每一个点向其删除的出边连边，先考虑它会形成什么样的一个形态，可以发现这个树被划分成了若干个子连通块，每个连通块都是一个内向树，且根节点刚好就是 $0$ 的点。但要求根节点的编号要比其出边所有节点大且其所有出边都要连向它，否则无法在操作这个点时使其成为孤立点。

接下来就比较麻烦了，但可以发现根据这个结构，所有出边相同的可以将其分配至一个等价类，那么我们显然是按照等价类的最小值从小到大分配标号。同样的，如果我们从小到大贪心，每次将一个点尽量的归并至一个标号较小的等价类但同时满足合法性，则一定最优。

现在可以分析每个等价类的合法条件，如果一个等价类的大小 $\geqslant 2$，则其直径中点一定是它们连向的点，而当等价类的大小 $=1$ 时，其连向的点可以是任意的，但决不可以不存在。那么若当前考虑的节点为 $i$，如果 $i$ 满足其出边所有节点大且其所有出边都连向它或还没有确定连接方式，则 $i$ 可以作为根取到 $0$，否则 $i$ 应当与最小的等价类进行合法的合并。如果当前考虑的等价类大小 $\geqslant 2$，则当前等价类的出边节点 $x$ 是固定的，所以只要不存在 $x$ 到 $i$ 的边即可(因为 $x$ 到 $i$ 与 $i$ 到 $x$ 不能同时存在)，如果当前考虑的等价类大小为 $1$，令其为 $d$，那么这样如果 $d$ 与 $i$ 合并，则 $d$ 与 $i$ 的中点 $x$ 则成为了新的出边点，此时则要求 $x$ 到 $d,i$ 的边都不能存在。如果上述条件均不满足，则不得不新开一个等价类。

但这样一交发现只过了三个点，注意到上述过程忽视了一个东西，在等价类的大小 $=1$ 时该点的出边集合如果唯一，则它是被定住的不能修改，此外，我们也不能让等价类的大小 $=1$ 时该点没有合法的出边。但实际上只有加边时会导致一个等价类的大小 $=1$ 的出边集合大小进行改变，且每次只会减少 $1$ 或 $2$(即分别对应上述添加 $i,x$ 与添加 $d,i$ 与 $x$ 的情况)，如果在减少后发现一个点的出边集合的大小为 $1$，则立刻将这个点的出边连向唯一的一个出边集合内的点，而且当出边集合大小为 $2$ 时我们还不能执行 $d,i$ 向 $x$ 的连边，因为这样会使出边集合减至 $0$。

上述过程只需要查询一个点的出边信息最小值与修改一个点的出边信息，可以用 $\text{set}$ 维护做到 $O(n \log n)$。

---

## 作者：reinforest (赞：0)

我来复读官方题解。

## 定义

- 如果边 $(i,j)$ 在第 $i$ 次操作被删除，那么我们称点 $i$ **被确定**，同时称点 $j$ 为点 $i$ 的 **目标点**；反之，如果边没有删除，那么我们称点 $i$ **未被确定**。
- 在第 $i$ 次操作中，如果点 $i$ **未被确定**，在下述的算法中，我们会把一些数 $x$ 写在与 $i$ 相邻的点 $v$ 上，我们称数 $x$ **放置**在了点 $v$ 上；同时，我们称 $i$ 为点 $v$ 与数 $x$ 的**临时源点**。

## 算法

因为我们最后是使字典序最小，所以对于每一个从 $1 \sim n$ 从前往后遍历的 $i$，我们可以使用贪心算法尽可能最小化 $A_i$，不需要考虑进行操作后对 $(i+1) \sim n$ 的影响。

现在我们考虑怎么最小化 $A_i$。

### 1. 判断 $A_i=0$ 是否可行

这与点 $i$ 的度数有关。

- 如果点 $i$ 的度数为 $0$，也就是点 $i$ 被孤立，我们可以直接令 $A_i=0$。
- 如果点 $i$ 的度数为 $1$，设与 $i$ 相邻的点为 $j$，$A_i=0$ 可行当且仅当 $i > j$，且 $j$ 未被确定。此时，我们可以令 $j$ 的目标点为 $i$，使 $i$ 确定，当执行完这一步后 $i$ 就孤立了，可以为 $0$。

> 简要证明：如果 $i<j$，那么边 $(i,j)$ 会一直存在直到遍历到 $i$；如果 $j$ 被确定，那么点 $j$ 无法更改目标点为 $i$，这样可能会改变之前算好的 $A_i$。

- 如果点 $i$ 的度数大于等于 $2$，可以证明 $A_i=0$ 不可行。

> 简要证明：假设存在两个未处理的相邻点 $u$ 和 $v$，此时无论如何操作，$i$ 必须选择一个邻居，导致至少一条边未被删除，无法使 $i$ 孤立，不能为 $0$。

### 2. 点 $i$ 不存在相邻节点被放置数

因为 $1 \sim i-1$ 都放置在了与 $i$ 不相邻的点上，所以此时 $A_i=\max_{j=1}^{i-1}A_j+1$。在代码中，我们可以记录一个数 $cnt$ 表示此时的 $\max_{j=1}^{i-1}A_j$。

然后，我们把点 $i$ 的所有相邻节点 $v$ 都放置上 $A_i$。（此时任意的一个 $v$，$i$ 都是它们的临时源点）

如果点 $i$ 的度数为 $1$，设点 $v$ 与 $i$ 相邻，那么我们可以直接确定点 $v$ 为点 $i$ 的目标点，使点 $i$ 确定。

### 3. 点 $i$ 存在相邻节点被放置数

此时，我们找到与 $i$ 相邻的最小的放置数 $x$，并找到对应节点 $t$。

此时 $A_i$ 的最小值就是 $x$。所以我们考虑将点 $t$ 作为点 $i$ 的目标点，使点 $i$ 确定。

但是这样显然不够，我们还需要考虑点 $t$ 的临时源点 $s$，是点 $s$ 将 $x$ 放置在了 $t$ 上，所以我们还需要把点 $t$ 作为点 $s$ 的目标点，使点 $s$ 确定。

## 细节

你以为黑题就这样结束了？

### 1. 连锁确定反应

当点 $s$ 确定时，设其目标点为 $t$，边 $(s,t)$ 会被删除。这会使点 $t$ 的度数减少。如果点 $t$ 的度数变成了 $1$，且满足 $t < s$，设其相邻点为 $v$，如果 $v$ 也没有被确定，我们此时必须使点 $t$ 的目标点为 $v$，使 $t$ 确定。此时又会使点 $v$ 的度数减少……

所以每次确定后需要考虑以上的连锁确定。

### 2. 在『算法』的 3. 中一些节点不能选择

- 一个点 $i$ 可能给很多点都放置 $x$，但是最终只会选择一个点作为目标点。所以在判断的时候，如果数 $x$ 的『临时源点』被确定了，那么这个 $x$ 所代表的点就不能被选择了。
- 设当前遍历到的点为 $i$，选择的点为 $j$，如果点 $j$ 没有被确定，度数为 $2$ 且 $i>j$，那么点 $j$ 也不能选择。

> 简要证明：设点 $j$ 的临时源点为 $k$，看起来使点 $j$ 作为点 $i$ 和点 $k$ 的目标点是没有问题的。但是如果删除了边 $(j,k)$ 后，点 $j$ 的度数就变成了 $1$，此时点 $j$ 必须选择点 $i$ 作为目标点。所以出现了矛盾。

## 总结

按照 $1,2,\cdots,n$ 的顺序使 $A_i$ 取得最小，并且注意以上的细节，我们就可以得到字典序最小的 $A_i$。添加、删除、查询最小值的操作可以用 set 来实现。时间复杂度 $O(n \log n)$。

[提交记录](https://atcoder.jp/contests/arc170/submissions/65302047)。

在代码中使用了 $tgt$ 数组记录目标顶点。注意如果一个点 $i$ 的目标顶点 $j$ 已确定后，边 $(i,j)$ 是删除状态，所以代码中有很多关于 $tgt$ 的判断，实际上就是判断这个点是否确定，或者边 $(i,j)$ 是否删除。

---


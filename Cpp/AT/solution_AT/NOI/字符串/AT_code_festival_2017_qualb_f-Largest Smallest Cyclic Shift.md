# Largest Smallest Cyclic Shift

## 题目描述

对于字符串 $S$，定义 $f(S)$ 为 $S$ 的所有循环移位中字典序最小的一个。例如，当 $S =$ `babca` 时，$S$ 的循环移位（`babca`, `abcab`, `bcaba`, `cabab`, `ababc`）中，字典序最小的是 `ababc`，因此 $f(S) =$ `ababc`。

给定三个整数 $X, Y, Z$，你需要构造一个包含恰好 $X$ 个字符 `a`，$Y$ 个字符 `b`，和 $Z$ 个字符 `c` 的字符串 $T$。如果有多个这样的字符串，你需要使得 $f(T)$ 在字典序上尽可能大。

求出 $f(T)$ 的字典序最大值。

## 样例 #1

### 输入

```
2 2 0```

### 输出

```
abab```

## 样例 #2

### 输入

```
1 1 1```

### 输出

```
acb```

# 题解

## 作者：shr_ (赞：41)

虽然笔者也没有完全搞懂这个做法，但希望本题解至少能够让人看懂并有基本的逻辑（并不是严谨论证）。

#### 本题做法

ATcoder 上官方题解是一个二分 DP 的做法（这也是数据范围的来源），但网上普遍做法是一个复杂度更优的贪心，此贪心过程如下：

1. 构造可重集包含 $X$ 个 $\texttt{a}$，$Y$ 个 $\texttt{b}$，$Z$ 个 $\texttt{c}$，其中元素均为字符串，字符串间比较定义为字典序比较。

2. 从可重集中选择最小与最大的字符串删除，将这两个字符串首尾相连形成新字符串插入可重集中。

3. 执行操作 2 直至可重集中元素个数为 1，此元素即为所求答案。

#### 贪心正确性证明

这个问题相当于有 $n$ 个字符串，决定一个首尾相连的顺序。

合并两个字符串的过程本质上是将一些不可能被选为最小循环移位开始的位置删除。

那么为什么这些位置不会被选为最小循环移位开始位置呢？

原因是我们考虑开始位置后面跟着的字符串字典序应该最小，最小循环开始位置就不可能是最大的字符串的开始位置，所以我们可以放心的合并。

其实这个位置有一个漏洞：字典序最小的位置也不一定是最小循环移位开始位置，反例是集合 $\{\texttt{b},\texttt{ba}\}$，此时最小循环移位就是 $\texttt{bab}$。但这题性质特殊，原因是集合中每个字符串都是最小表示，不可能出现类似 $\texttt{ba}$ 形式的字符串，证明如下：

设 $S,T$ 为两个最小表示的字符串，满足 $S<T$，则证明目标为 $S+T$ 为最小表示，等价于 $S+T\leq T+S$，其中 $+$ 定义为首尾相连。

定义 $prefix(S,x)$ 表示字符串 $S$ 长度为 $x$ 的前缀，$suffix(S,x)$ 表示字符串 $S$ 长度为 $x$ 的后缀。

当 $|S|\geq |T|$ 时，由于 $S<T$，显然 $prefix(S,|T|)<T$，则显然 $S+T<T+S$。

当 $|S|<|T|$ 时，则有 $S\leq prefix(T,|S|)$。

当 $S<prefix(T,|S|)$ 时，显然有 $S+T<T+S$。

当 $S=prefix(T,|S|)$ 时，设 $T'=suffix(T,|T|-|S|)$。

则证明目标等价于 $S+S+T'\leq S+T'+S$

由于 $T$ 为最小表示，所以有 $S+T'\leq T'+S$, 显然有 $S+S+T'\leq S+T'+S$。

此证明建议画图辅助理解，由于笔者画的不堪入目，所以这里没附图片，见谅。

至此，我们完成了合并必为最小表示的证明，也就是说，该合并完全合法。

那么问题在于为什么要选择最大与最小的串合并。

首先这个合并的意义在于将可能的开始位置后接的字符串字典序变大，由于只有最小的串能当最小循环移位开始位置，所以合并的一方必为最小的串。同时为了尽可能的使每个可能的串字典序都尽可能的变大，所以另一方也显然为最大的串。

由于每一步都是最优的，整体也就是最优的。

若有不严谨的地方，欢迎补充，如果有错误，欢迎指出。

---

## 作者：Unnamed114514 (赞：29)

[题目传送门](https://www.luogu.com.cn/problem/AT_code_festival_2017_qualb_f)

根据字典序的性质，容易想到，在字典序最小的时候，一定以 `a` 开头，但是此时我们要保证字典序最大，那么后面就紧跟的是 `c`，然后再是 `b`。

这是字符的拼接，我们可以考虑扩展到字符串的拼接：我们可以由 $3$ 个局部最优的字符串拼接成一个新的字符串，然后再和其它字符串进行匹配。

此时我们只需要讨论 $3$ 个的情况：有 $s_1,s_2,s_3$，为了方便，我们可以令 $s_1<s_2<s_3$。那么我们通过上面的方式，最小的后面接最大的，那么我们得到的序列就是 $s_1s_3s_2$，如果还有一个字符串 $s_3<s_4$，那么我们可以将原来的字符串分为 $s_1,s_3s_2$，那么 $s_4$ 就是接在 $s_1$ 后面的，然后是 $s_3$，最后是 $s_2$……

那么，我们发现规律，每次有字符串集取最大和最小拼接在一起，然后再和其它字符串匹配。这个结论可以用数学归纳法证明：

上文已经证明了 $s_1s_3s_2$ 的正确性，那么对于 $k$，上述规律成立。现在我们有：$s_1s_k\cdots s_2$，和一个新串 $s_{k+1}$，此时 $s_1$ 一定放在最前面，由于 $s_k<s_{k+1}$，那么无论如何，$s_k$ 加上后面那一坨都是 $<s_{k+1}$ 的，那么我们可以将 $s_k\cdots s_2$ 想象成一个整体，按照上面的方式，就是 $s_2$，$s_{k+1}$ 是 $s_3$，那么此时答案由上面的方式，就是 $s_1s_{k+1}s_k\cdots s_2$，那么对于 $k+1$ 成立，所以结论成立。

同时取最大和最小，用 `std::multiset` 维护，时间复杂度 $O((X+Y+Z)\log(X+Y+Z))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
multiset<string> s;
int a,b,c;
int main(){
	cin>>a>>b>>c;
	while(a--) s.insert("a");
	while(b--) s.insert("b");
	while(c--) s.insert("c");
	while(s.size()>1){
		auto a=s.begin(),b=(--s.end());
		s.insert((*a)+(*b)),s.erase(b),s.erase(a);
	}
	cout<<(*s.begin())<<endl;
	return 0;
}
```

---

## 作者：Halberd_Cease (赞：13)

upd：重构了题解让自己显得不那么唐。

将给定的 $X$ 个字符 `a`，$Y$ 个字符 `b`，$Z$ 个字符 `c`，以字符串形式放入一个类似双端队列数据结构内，每次取字典序最小的和最大的，合并后放入该数据结构中，当该数据结构仅剩下 $1$ 个元素时，这个元素就是最后的答案。

不妨设有字符串 $S_1,S_2,...,S_n$  组成字符串 $T$，满足  $S_1<S_2<...<S_n$，题目中定义的 $f(T)$ 一定以 $S_1$ 为前缀，此时的最优解应该是将 $S_n,S_{n-1},...,S_2$ 按顺序接在 $S_1$ 后面，即 $T=S_1+S_n+S_{n-1}...+S_2$，显然如此。

在本题中，并不是所有字符串都不等，实际情况应该是有字符串 $S_1,S_2,...,S_n$  组成字符串 $T$，满足  $S_1\le S_2\le ...\le S_n$，造成上述方法错误的原因是当有多个最小或次小的字符串时，我们只考虑了其中一个字符串而忽视了其它的。

举个例子，当 $X=2,Y=2,Z=2$ 时，按上述方法构造的字符串应该是 $T=$`accbba`，$f(T)=$`aaccbb`，我们可以构造一个解 $f(T)=$`acbacb`，比上述方法的解更优。

我们已经知道错误的原因是有多个最小值，现在考虑改正优化该方法。

容易想到的一种方法就是对于每一个当前最小的字符串，拼接上当前最大的字符串，然后重新排序。

对于多个相等的字符串 $S_1=S_2=...=S_x$，取字符串 $S_1$ 加上一个较大串后必定有 $S_1+S_n>S_2=S_3=...=S_x$，那么下一次合并就必然不会再将 $S_1$ 和其它串合并，而是选择剩下的 $S_2$ 到 $S_x$。

不能将 $S_1$ 和后面的串再次合并的原因：由于排在后面的字符串 $S_n$ 不小于它前面的 $S_{n-1}$，所以合并后的的字符串 $S_1+S_n$ 不小于 $S_2 +S_{n-1}$，以此类推，$S_x+S_{n-x+1}$ 这个串不会大于前面合并的串。这样对答案有影响的其实只有 $S_x+S_{n-x+1}$，如果我们将 $S_1,S_n,S_{n-1}$ 合并，就必然会造成这样合并后的 $S_{n-x+1}$ 串不大于原来的串，因此我们得到的答案不会优于我们的贪心策略。

为什么让最小的 $S_1$ 和最大的 $S_n$ 合并就是最优解呢？

显然，如果 $S_1$ 和不是最大的串合并，那么一定会造成得到的串不大于 $S_1+S_n$，又因为 $S_1$ 作为最小前缀（不唯一），一定会参与到 $f(T)$ 的讨论中，因此应该让其尽量连接大的字符串使得答案不劣。

使用贪心策略直到没有相同的字符串后也可以继续使用，原因显然，自己模拟即可证明，因此不用特判有无重复。

[submission](https://atcoder.jp/contests/code-festival-2017-qualb/submissions/43555359)

---

## 作者：OtoriEmu (赞：8)

不妨假设 $\gcd(X,Y,Z)=1$，如果不为 $1$ 答案串会出现循环节。

显然原问题给的是 $X+Y+Z$ 个 Lyndon 串。我们直接把串用最小表示来表示（也就是 Lyndon 形式），合并就直接把小的接在大的后面。

为什么这样合法并且优？合法性可以直接考虑 Lyndon 串性质，满足 $u < v$ 的 $uv$ 一定是 Lyndon 串（这里不会取等，因为没有循环节）。为什么不循环位移 $v$ 再拼接（不循环位移 $u$ 的原因显然）？这样一方面会破坏 Lyndon 串的性质，另一方面整个串的最小表示不会变小，原因是，如果拆出来的 $v$ 的前缀本来就比 $u$ 大，显然不优；和 $u$ 的前缀相等，因为 $u$ 是 $u$ 的所有后缀中最小的那个，也不优。

那么剩下的问题是若干个字符串拼接，每次选两个将小的拼在大的前面形成一个字符串塞回去，问最后形成的字符串字典序最大是多少。贪心策略是最小的字符串和最大的字符串拼接。因为当前最小的字符串一定会作为字符串的前缀出现在答案串，如果拼接的不是最大的串一定不优。所以 exchange argument 可证每次操作一定采取上述策略。

代码大家都有。

---


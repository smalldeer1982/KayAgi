# [ARC187E] Replace Triplets

## 题目描述

给定序列 $A=(A_1,A_2,\cdots,A_N)$，其中 $N\ge 3$。

你可以进行以下操作若干次：
- 选择整数 $i$ 满足 $1\le i\le N$ 且 $A_i=A_{i+1}=A_{i+2}$，将 $A_{i},A_{i+1},A_{i+2}$ 三个数中的两个替换成 $1\sim N$ 的整数。规定 $A_{N+1}=A_1$，$A_{N+2}=A_2$。

求有多少种可能到达的状态，使得恰好是 $1\sim N$ 的排列，答案 $\bmod 998\ 244\ 353$。

## 样例 #1

### 输入

```
6
1 2 3 3 1 1```

### 输出

```
360```

## 样例 #2

### 输入

```
5
3 1 3 4 1```

### 输出

```
0```

## 样例 #3

### 输入

```
10
1 1 1 8 8 8 7 7 7 10```

### 输出

```
604800```

# 题解

## 作者：Argon_Cube (赞：6)

这有铜牌？？这个题放 C 都是合理的吧？？

$\rm 2KB$ 的代码 $\frac 23$ 都是判 Corner Case/tuu

---

首先这个题面一看就碘完了，数列上的数字替换有两个经典套路：

* 时光倒流。例如 [ARC183B](https://www.luogu.com.cn/problem/AT_arc183_b) 中，将“把 $a_i$ 变成 $a_j$”替换为“选择 $a_i=a_j$ 并将 $a_j$ 替换为任意数”。
* Run-Length Compressed Sequence。简单来说就是将相同的数组成的一段压缩成一个数，如 $[1,1,1,2,2]\to[1,2]$。ARC183B 中当 $k=1$ 时就是用了这个东西判定的（$A$ 能变成 $B$ 当且仅当 $B$ 压缩后是 $A$ 的子序列）。

题面中的操作自由度太高，并且结果是排列的限制看上去就难以处理，不利于我们后续的思考与描述，不妨直接时光倒流，将题目转化为：

> 给定序列 $a$，有多少个排列 $p$ 可以通过以下操作变成序列 $a$？
> * 将 $p$ 首尾相接形成一个环，在环上选择长度为 $3$ 的子串并将其中所有数替换成原子串中的某个数。

---

注意本题操作是在环上的，接下来默认 $a,p$ 首尾相接。

考虑合法的 $p$ 满足的充要条件，这个时候就显然要上 Run-Length Compressed Sequence 了，我们令 $a'$ 是 $a$ 压缩完连续段后得到的序列，同样定义 $p'$。

首先讨论一些平凡但是烦人的 Corner Case：

1. 如果 $a$ 本来就是排列，那么只有 $p=a$ 合法；
2. 如果 $a$ 只有一种数，那么所有 $n!$ 种 $p$ 都是合法的；
3. 判完 1. 说明我们至少要做一次操作，也就是说 $a$ 中一定有连续三个数字相同，否则无解；
4. 显然 $a'$ 中不能有重复的数字，因为我们对 $p$ 操作时只能从它的压缩序列中删数，否则也是无解。 

判完 Corners，算出来 $a'$ 的长度 $n'$ 之后 $a'$ 和 $a$ 就没用了，我们只关心 $a'$ 里有几种数。

因为是环上，所以压缩后的序列一样也有可能原序列会循环移位，那么我们先考虑什么样的 $p$ 上的循环移位是可行的。手玩一下可以发现，其它大部分情况都可以任意将 $p$ 循环移位并保持 $p'$ 不变，除了 $|p'| = |p| -2$ 时比较特殊。此时我们只能每次循环移 $2$ 位（除了 $n=4$），因此如果 $n$ 是大于 $4$ 的偶数，此时只能循环位移偶数个位置。那么以下我们假设可以任意循环移位，如果 $n$ 是大于 $4$ 的偶数我们最后将答案除以 $2$ 即可（多移一位就可以一一对应合法与不合法方案）。

现在我们发现，只要能使 $p'=a'$ 就能让 $p=a$。那么首先 $a'$ 必须是 $p$ 的子序列，以后操作不能删去 $a'$ 中的数。接下来可以发现，只要在这个条件下能操作一步，那么 $p$ 就一定合法，因为手玩可以发现以后就能自由决定要不要吃掉 $p'$ 中的某个数。

只考虑 $a'$ 是 $p$ 的子序列显然方案数是 $n'\dbinom n{n'}(n-n')!$。可以操作一步较难计数，不如反着算一步都操作不了的 $p$ 有多少个，也就是任意两个不在 $a'$ 中的数在 $p$ 中至少间隔两个在 $a'$ 中的数。钦定第一个数不在 $a'$ 中最后乘上 $\dfrac{n}{n-n'}$ 容易插板法得到答案是 $nn'(n-n'-1)!\dbinom{n-2(n-n')-1}{n-n'-1}$。

[Code.](https://atcoder.jp/contests/arc187/submissions/60261372)

---

## 作者：Acoipp (赞：4)

很奇妙。

首先，考虑一些简单的判断：

- $A$ 是一个排列时，答案为 $1$。
- $A$ 的所有元素相同的时候，答案为 $n!$。
- $A$ 无法执行操作的时候，答案为 $0$。

接下来考虑一次操作之后的不变量是什么，注意到我们不可能从序列中删除一个数，进而我们可以推出如果有不相邻的两个相同的数 $A_i,A_j$，那么答案为 $0$，例如 $1,2,1,1,2,1$ 中的两个 $2$ 在序列（这里的序列指的是一个环）上不相邻，因为 $A_i \sim A_j$ 中间的数不可能被消除。

所以可以生成的序列 $P$ 一定满足如下条件：

- $A$ 中两个数的相对位置在 $P$ 中得到保留。

于是所有数字都是连续的一段，并且至少有两个不同的数字（只有一个的情况之前已经讨论过了），我们考虑把这个序列转一下，使得 $A_1 \ne A_n$。

接下来我们考虑 $A$ 中不同的数有 $n-2$ 个的情况，即恰好一个数可以操作，类似于 $1,1,1,2,3,4$，这样的序列能够生成多少种不同的排列呢？

如果只执行一次操作，我们可以获得 $1,5,6,2,3,4$，或者 $1,6,5,2,3,4$ 等等，即没有出现过的数字都围绕着 $1$ 产生；如果执行两次，我们可以先让序列变为 $1,2,2,2,3,4$，然后就变成了第一次的情况。

以此类推，我们发现，在经过若干次之后，序列会变成 $1,2,3,4,1,1$，即所有字符向左移动了两位，因此我们可以证明，如果 $n$ 为奇数或者 $P$ 可被生成，那么 $P$ 的任何环同构序列都可以被生成；$n$ 为偶数的话就是 $P$ 的任何右移 $2$ 位产生的序列可以被生成；最后 $n=4$ 是特殊情况，因为我们可以令 $1,1,1,3$ 经过两步生成 $3,1,1,1$，其中 $3$ 只移动了一位，但是 $>4$ 的偶数就不可以这么做。

再观察最开始没有在 $A$ 中间的两个数字，这两个数字在 $P$ 中距离（环上的）一定小于等于 $2$，于是直接计数即可，具体过程就不细推了，大概就是考虑两个数字放在了哪个空位即可，答案为 $4(n-2)n$，当 $n>4$ 且 $n \bmod 2=0$ 的时候要除以 $2$。

最后的一种情况就是 $A$ 中不同的数字小于等于 $n-3$，可以证明在保证“$A$ 中两个数的相对位置在 $P$ 中得到保留”这个条件的前提下，只要存在一对没在 $A$ 出现的数但是在 $P$ 中出现的数在 $P$ 中的距离（环上）小于等于 $2$ 的 $P$ 都可以生成，具体的证明方法就是考虑最后一步生成的两个数的距离一定小于等于 $2$，其余步可以随便移动并且生成即可。

我们通过容斥，转化为对“$A$ 中两个数的相对位置在 $P$ 中得到保留”并且任意两个没在 $A$ 出现的数但是在 $P$ 中出现的数在 $P$ 中的距离（环上）大于等于 $3$ 的 $P$ 计数。

使用隔板法即可，你需要实现 $f(n,m)$ 表示将 $n$ 个球放到 $m$ 个盒子中，并且每个盒子球数大于等于 $2$ 的方案数，即 $f(n,m)=C_{n-m-1}^{m-1}$。

最后枚举第一个没在 $A$ 中出现的数放的位置，对于剩下的数使用 $f$ 函数和阶乘处理答案即可，这一部分详见代码。

综上，时空复杂度均为 $O(n)$。

代码如下，仅供参考：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 500005
#define mod 998244353
using namespace std;
inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t = a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}
ll n,i,j,a[N],jc[N],inv[N],b[N],t,ls[N],rs[N],cnt[N],alls=1,cntt;
inline ll C(ll n,ll m){
	if(n<m||n<0||m<0) return 0;
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
inline ll solve(ll x,ll y){
	//x-balls/y-blanks
	x -= (y+1);
	return C(x-1,y);
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	jc[0]=1;
	for(i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod;
	inv[n]=qmi(jc[n],mod-2,mod);
	for(i=n;i>=1;i--) inv[i-1]=inv[i]*i%mod;
	for(i=1;i<=n;i++) cin>>a[i];
	a[n+1]=a[1];
	for(i=1;i<=n;i++) if(a[i]!=a[i+1]) break;
	if(i==n+1){
		cout<<jc[n]<<endl;
		return 0;
	}
	for(j=i+1;j<=n;j++) b[++t]=a[j];
	for(j=1;j<=i;j++) b[++t]=a[j];
	for(i=1;i<=n;i++) a[i]=b[i];
	for(i=1;i<=n;i++){
		if(!ls[a[i]]) ls[a[i]]=i;
		rs[a[i]]=i;
		cnt[a[i]]++;
	}
	for(i=1;i<=n;i++) if(ls[i]&&rs[i]-ls[i]+1!=cnt[i]) return cout<<0<<endl,0;
	for(i=1;i<=n;i++){
		alls &= (cnt[i]==1);
		if(cnt[i]>=3) break;
	}
	if(alls) return cout<<1<<endl,0;
	if(i>n) return cout<<0<<endl,0;
	for(i=1;i<=n;i++) if(cnt[i]) cntt++;
	if(cntt==n-2){
		if(n==4){
			cout<<24<<endl;
			return 0;
		}
		ll ans = 4*(n-2)*n%mod;
		if(n!=4&&n%2==0) ans=ans*qmi(2,mod-2,mod)%mod;
		cout<<ans<<endl;
		return 0;
	}
	ll ans = 0;
	for(i=1;i<=cntt;i++){
		ll ball = cntt-i+1;
		if(i==1) ball+=0;
		else ball+=1;
		ans = (ans+jc[n-cntt]*solve(ball,n-cntt-1))%mod;
	}
	cout<<(jc[n-1]*inv[cntt-1]%mod-ans+mod)*n%mod<<endl;
	return 0;
}
```

---


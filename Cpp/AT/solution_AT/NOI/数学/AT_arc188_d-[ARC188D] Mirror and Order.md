# [ARC188D] Mirror and Order

## 题目描述

你需要构造 $N$ 个长度为 3 的数列，需要满足这些条件：

- 对于每个 $k=1,2,3$，所有数列的第 $k$ 项中，从 $1$ 到 $N$ 的整数恰好出现一次。

在这些数列的集合中，我们定义两个数列 $a=(a_1,a_2,\ldots,a_N)$ 和 $b=(b_1,b_2,\ldots,b_N)$，其定义方式如下：

- 设第 $i$ 个数列为 $s_i$，其逆序数列为 $t_i$。当所有的 $s_i$ 和 $t_i$ 按字典序排列时，$s_i$ 排第 $a_i$，$t_i$ 排第 $b_i$。
- 如果在这些 $2N$ 个数列中出现两个或更多完全相同的数列，则 $a$ 和 $b$ 无法定义。

因此，当 $a$ 和 $b$ 能被定义时，它们融合成的数列从 $1$ 到 $2N$ 的整数恰好出现一次。

给定一个长度为 $N$ 的数列 $A$ 和 $B$，其中 $A$ 的每个元素都是 $1$ 到 $2N$ 之间的整数，而 $B$ 的每个元素或是 $1$ 到 $2N$ 之间的整数或是 $-1$。此外，合并 $A$ 和 $B$ 后，除了 $-1$ 之外的整数最多只出现一次。

请计算满足以下条件的数列 $a, b$ 的数量：

- $a_i = A_i$
- 如果 $B_i \neq -1$，则 $b_i = B_i$

最后，请将答案对 $998244353$ 取模后的结果输出。

## 说明/提示

- $2 \leq N \leq 3000$
- $1 \leq A_i \leq 2N$
- $1 \leq B_i \leq 2N$ 或 $B_i = -1$
- 合并 $A$ 和 $B$ 后，除了 $-1$ 之外的整数最多只出现一次。具体来说：
  - 当 $i \neq j$ 时，$A_i \neq A_j$
  - 当 $i \neq j$ 且 $B_i, B_j \neq -1$ 时，$B_i \neq B_j$
  - $A_i \neq B_j$

### 样例解释

例1：

考虑以下三个数列：
1. $(1,2,3)$
2. $(2,1,1)$
3. $(3,3,2)$

将 $s_i$ 和 $t_i$ 按字典序排列后是：
> $t_2=(1,1,2) < s_1=(1,2,3) < s_2=(2,1,1) < t_3=(2,3,3) < t_1=(3,2,1) < s_3=(3,3,2)$

因此 $(a_1, a_2, a_3, b_1, b_2, b_3) = (2, 3, 6, 5, 1, 4)$。满足题目要求的数列有 $a$ 与给定 $A$ 一致，$b$ 的第二项与 $B$ 一致。

另一个例子：

数列如下时：
1. $(1,2,1)$
2. $(2,1,3)$
3. $(3,3,2)$

此时 $s_1 = t_1$，所以 $a$ 和 $b$ 无法定义。

其实，唯一满足条件的数列是 $a = (2, 3, 6), b = (5, 1, 4)$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
2 3 6
-1 1 -1```

### 输出

```
1```

## 样例 #2

### 输入

```
15
5 16 1 12 30 20 4 13 9 8 24 21 26 28 17
-1 -1 6 -1 -1 -1 -1 -1 -1 -1 -1 29 -1 -1 -1```

### 输出

```
758094847```

# 题解

## 作者：OptimisticForever (赞：2)

很强的转化。

## Part 1 转化

先把一些无解的情况判掉。

我们肯定是考虑第一列和第三列的相同的数，不同的数的排名关系是确定的。

假定 $b$ 序列已知，我们考察建图。

如果第 $i$ 行第一列等于第 $j$ 行第三列，那么如果 $a_i<b_j$ 连边 $i$ 向 $j$ 否则连边 $j$ 向 $i$。

观察这张图的性质，我们注意到这个图每个点的度数为 $2$，把其看成无向图，每一个连通分量都是环。

显然，不能出现自环，我们还注意到，如果一个环，它的边定向是 $a\to b\to c\to \cdots\to a$，那么肯定无解，因为中间的数不能分配。

现在考虑原问题含有序列 $a,b$，$a$ 序列告诉了我们每个点是走出 $i$ 还是走入 $i$，我们把走出 $i$ 的标记为白点，走入 $i$ 的标记为黑点。

如果一个连通分量里所有点的颜色都相同，那么无解，否则有解。 

考虑 $b$ 序列已经告诉了我们一些边，我们现在相当于把剩下的边连上，使得不存在同色环。

一共有四类情况：

- 全黑链；
- 全白链；
- 黑白皆有的链；
- 环；

如果环不合法直接判掉，剩下我们设 $B$ 表示全黑链的个数，$W$ 表示全白链的个数，$G$ 表示黑白皆有的链的个数。

我们把这些看成点，相当于需要连边，使得不存在全黑全白的环。

## Part 2 计数

我们考虑那些同色极长段，假设有 $b$ 个这样的全黑极长段，$w$ 个这样的全白极长段。

先考虑把黑白皆有的形成一些环，再插入黑白点，这部分的方案数是 $G!$，可以想象到，因为一个点一开始有 $G$ 种选择方案，可以选自己，相当于自己这条链的起点连向终点，依次递推。

考虑构造出 $w$ 个这样的全白极长段，相当于把 $W$ 分成 $w$ 份，这部分方案数就是先把 $W$ 个点排列，但是注意到我们不区分这 $w$ 份，所以方案数为 $\frac{W!\binom {W-1}{w-1}}{w!}$。

我们记 $F(W,w)$ 表示上述的方案。

现在考虑插入黑白点，我们先把白点接上去，设有 $s$ 个后面接黑点，那么剩下都接黑白皆有。

这部分的方案数就是两个下降幂相乘，$\binom w sb^{\underline{s}}G^{\underline{w-s}}$。

于是我们只需要考虑黑点怎么接了，要么接白点，要么接黑白皆有，而且接白点不能接之前那些接黑白皆有的。

所以这部分的方案数是 $(G+s)^{\underline b}$。

于是枚举 $s,w,b$ 答案就是下面部分：
$$
\begin{aligned}
\frac{(G!)^2(G+s)!F(W,w)\binom w sF(B,b)b!}{(G-w+s)!(b-s)!(G+s-b)!}
\end{aligned}
$$
容易做到 $O(n^2)$，发现是卷积可以做到 $O(n\log n)$。

参考了官方题解。

---

## 作者：_Cheems (赞：1)

闲话：larsr 说评分虚高。

先判定 $a,b$ 是否合法，不妨令 $a$ 升序。考虑排序后的序列，将 $2i,2i+1$ 视为一组，首先 $a$ 必须在不同组才能合法。$s_i,t_i$ 回文，相当于确定了每个串的开头结尾数字。

记 $s_i,t_i$ 中间元素为 $c_i$。对于同一组，让其中 $a$ 对应的 $c_x$ 向 $b$ 对应的 $c_y$ 连有向边。这样的好处是得到若干环（边的起点、终点序列均为排列）。

现在考虑边权是什么。易发现不可能 $c_x=c_y$，因为这种情况当且仅当 $x=y$ 也即同一组元素互为回文，那么违背题目“不能有相同字符串”的条件。所以当 $a$ 在奇数位置上时连小于号、反之大于号。

考虑一个环是否合法。首先边权全都一样必然不行，反之发现必然有构造方案。具体来说，将环通过 $>$ 号断开，得到全 $<$ 号段也就是上升序列，那么要让每个上升序列的结尾大于下一个的开头，发现只需让其“环环相扣”即可（单个元素放置在上方）。建议手玩下。

综上，一组 $a,b$ 合法当且仅当不存在环满足全是奇数位置或全是偶数位置。感觉是可以容斥的亚子。

回到原题，已经建出了一些边。若成环，就扔掉，当然如果非法直接输出零。对于链（包括孤立点），将其分组，记总共有 $m$ 条链，$x$ 条全偶链、$y$ 条全奇链。

容斥，对于一个非法环，可钦定其系数为 $-1$。那么我们枚举全偶链中有 $i$ 条链被钦定用来组成非法环，全奇链有 $j$ 条。记 $f_i$ 为 $i$ 个元素组成若干环，一个环系数为 $-1$，系数之积的和。

答案即为：

$$\sum\limits_{i\le x,j\le y} {x\choose i}{y\choose j}f_if_j(m-i-j)!$$

可以卷积做到 $O(n\log n)$。

最后考虑 $f$ 怎么递推，不妨枚举 $i$ 元素构成的环的大小，则有：

$$f_i=-\sum\limits_{1\le j\le i} A(i-1,j-1)f_{i-j}$$

拆开组合数，可以前缀和做到 $O(n)$。

总复杂度 $O(n\log n)$。偷懒写了 $O(n^2)$。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define pir pair<int, int>
const int N = 3e3 + 5, mod = 998244353;
int n, bel[N << 1], fa[N], siz[N], c[N], pw, m, x, y, ans, jc[N], jcinv[N], f[N], cir[N];
pir a[N];

inline int qstp(int a, int k) {int res = 1; for(; k; a = a * a % mod, k >>= 1) if(k & 1) res = res * a % mod; return res;}
inline int A(int n, int m) {return n < m ? 0 : jc[n] * jcinv[n - m] % mod;}
inline int C(int n, int m) {return n < m ? 0 : jc[n] * jcinv[m] % mod * jcinv[n - m] % mod;}
inline int find(int u) {return fa[u] == u ? u : fa[u] = find(fa[u]);}
inline void mer(int x, int y){
	int fx = find(x), fy = find(y);
	if(fx ^ fy){
		siz[fy] += siz[fx], c[fy] |= c[fx];
		fa[fx] = fy;
	}
	else cir[fx] |= 1;
}
signed main(){
	jc[0] = jcinv[0] = 1; 
	for(int i = 1; i < N; ++i) jcinv[i] = qstp(jc[i] = jc[i - 1] * i % mod, mod - 2);
	f[0] = 1;
	for(int i = 1, s = 0; i < N; ++i){
		s = (s + f[i - 1] * jcinv[i - 1] % mod) % mod;
		f[i] = (mod - 1) * jc[i - 1] % mod * s % mod;
	}
	cin >> n;
	for(int i = 1; i <= n; ++i) scanf("%lld", &a[i].first);
	for(int i = 1; i <= n; ++i) scanf("%lld", &a[i].second);
	sort(a + 1, a + 1 + n);
	for(int i = 1; i <= n; ++i){
		if((a[i].first + 1) / 2 == (a[i - 1].first + 1) / 2) {puts("0"); return 0;}
		if(a[i].second != -1) bel[a[i].second] = i;
		fa[i] = i, siz[i] = 1;
		c[i] = (1 << (a[i].first & 1));
	}
	for(int i = 1; i <= n; ++i){
		int bro = ((a[i].first & 1) ? (a[i].first + 1) : (a[i].first - 1));
		if(bel[bro]) mer(i, bel[bro]);
	}
	for(int i = 1; i <= n; ++i)
		if(fa[i] == i){
			if(cir[i]){
				if(c[i] != 3) {puts("0"); return 0;}
				continue;
			}
			++m;
			if(c[i] == 1) ++x;
			if(c[i] == 2) ++y;
		}
	for(int i = 0; i <= x; ++i)
		for(int j = 0; j <= y; ++j){
			int res = f[i] * C(x, i) % mod * f[j] % mod * C(y, j) % mod * jc[m - i - j] % mod;
			ans = (ans + res) % mod;
		}
	cout << ans;
	return 0;
}
```

---

## 作者：EuphoricStar (赞：1)

考虑给定 $a, b$ 如何判定。

一个显然的事情是，$2i - 1$ 和 $2i$ 对应那 $2n$ 个序列中两个开头为 $i$ 的序列。所以 $2i - 1$ 和 $2i$ 不会同时出现在 $a$ 或者 $b$ 中。

若 $2i - 1$ 出现在 $a$ 中，$2i$ 出现在 $b$ 中，那么设 $2i - 1$ 在 $a$ 中出现的位置为 $x$，$2i$ 在 $b$ 中出现的位置为 $y$。设 $c_i$ 为排序前的 $n$ 个序列中的第 $i$ 个序列的第 $2$ 项，可以得到 $c_x < c_y$。反之，若 $2i$ 出现在 $a$ 中，$2i - 1$ 出现在 $b$ 中，设其出现位置分别为 $x, y$，可以得到 $c_y < c_x$。考虑拓扑排序判定，若 $c_x < c_y$ 就连一条 $x \to y$ 的有向边，那么 $a, b$ 可行的充要条件是图中无环。

这种判定方式太蠢了，没办法计数。考虑观察性质。发现这个有向图中每个点的入度和出度之和都为 $2$，考虑把有向边看成无向边，图会变成若干个环，原来的有向图有环等价于在这个无向图的一个环中，所有边的方向都相同。不妨调换一下 $(a_i, b_i)$ 的顺序使得 $\left\lceil\frac{a_i}{2}\right\rceil = i$，设 $p_i = \left\lceil\frac{b_i}{2}\right\rceil$，即把无向环看成有向环之后 $i$ 的后继。那么无向边 $(i, p_i)$ 的方向仅取决于 $a_{p_i} \bmod 2$：若 $a_{p_i} \bmod 2 = 1$，那么方向为 $i \gets p_i$，否则为 $i \to p_i$。至此我们发现环的所有边方向相同，当且仅当环上所有点的 $a_i \bmod 2$ 相同。

回到原题，现在有些 $p_i$ 不确定，即图由若干个链和环组成。对于环，若环上所有点的 $a_i \bmod 2$ 相同那么直接输出 $0$，否则不用管。对于链，设 $c_0$ 为链上所有点的 $a_i \bmod 2$ 都 $= 0$ 的链的个数，$c_1$ 为链上所有点的 $a_i \bmod 2$ 都 $= 1$ 的链的个数，$c_2$ 为链上所有点的 $a_i \bmod 2$ 不全相等的链的个数。那么问题是将这些链组成环，要求不存在环上所有点的 $a_i \bmod 2$ 相同的环。

考虑容斥，将 $c_0$ 条链中的 $i$ 条组成 $k$ 个环，$c_1$ 条链中的 $j$ 条组成 $l$ 个环，剩下随意。设 $g_{i, j}$ 为 $i$ 条链组成 $j$ 个环的方案数，答案即为：
$$
\sum\limits_{i = 0}^{c_0} \sum\limits_{j = 0}^{c_1} \sum\limits_{k = 0}^i \sum\limits_{l = 0}^j (-1)^{k + l} \binom{c_0}{i} \binom{c_1}{j} g_{i, k} g_{j, l} (c_0 - i + c_1 - j + c_2)!
$$
其中 $(c_0 - i + c_1 - j + c_2)!$ 为 $c_0 - i + c_1 - j + c_2$ 条链组成若干个环的方案数。

设 $f_i = \sum\limits_{j = 0}^i (-1)^j g_{i, j}$，即所有方案的容斥系数之和，那么答案为：
$$
\sum\limits_{i = 0}^{c_0} \sum\limits_{j = 0}^{c_1} \binom{c_0}{i} \binom{c_1}{j} f_i f_j (c_0 - i + c_1 - j + c_2)!
$$
$f_i$ 可以递推，有 $f_i = -\sum\limits_{j = 1}^i \binom{i - 1}{j - 1} \times j \times  f_{i - j}$，即枚举第一条链所在环的点数。至此可以做到 $O(n^2)$。

但是你可以发现当 $i \ge 2$ 时 $f_i = 0$，即当 $n \ge 2$ 时有偶数个环的置换和有奇数个环的置换个数相等，证明就是构造双射，一个偶排列交换 $p_1, p_2$ 后能对应一个奇排列。所以答案式子中 $i, j$ 只用枚举到 $1$。预处理阶乘后答案式子可以 $O(1)$ 计算，总时间复杂度 $O(n)$。

[code](https://atcoder.jp/contests/arc188/submissions/60187028)

---


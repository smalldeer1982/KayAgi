# [AGC044E] Random Pawn

## 题目描述

你的目标是在接下来要进行的游戏中最大化期望收益。当游戏开始时，棋子（象棋棋子）会以等概率被放置在 $ \{1,2,\dots,N\} $ 中的某个位置 $ p $。这 $ N $ 个位置 $ 1,2,\dots,N $ 顺时针排列在圆周上，位置 $ 1 $ 的相邻位置是 $ N $ 和 $ 2 $。

游戏以回合制进行。在每一回合，你可以选择结束游戏并获得 $ A_p $ 美元（$ p $ 是当前棋子的位置），或者支付 $ B_p $ 美元继续游戏。如果选择继续游戏，棋子会以等概率移动到相邻的两个位置 $ p-1 $ 或 $ p+1 $（位置 $ 0 $ 视为位置 $ N $，位置 $ N+1 $ 视为位置 $ 1 $）。

最优策略下的期望收益是多少美元？

**注意**：“最优策略下的期望收益”定义为在保证游戏在有限回合内结束的策略下，期望收益的上界。

## 说明/提示

## 限制

- $ 2 \le N \le 200,\!000 $
- $ 0 \le A_p \le 10^{12} $（$ p = 1,\ldots,N $）
- $ 0 \le B_p \le 100 $（$ p = 1,\ldots,N $）
- 输入中的所有数值均为整数。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5
4 2 6 3 5
1 1 1 1 1```

### 输出

```
4.700000000000```

## 样例 #2

### 输入

```
4
100 0 100 0
0 100 0 100```

### 输出

```
50.000000000000```

## 样例 #3

### 输入

```
14
4839 5400 6231 5800 6001 5200 6350 7133 7986 8012 7537 7013 6477 5912
34 54 61 32 52 61 21 43 65 12 45 21 1 4```

### 输出

```
7047.142857142857```

## 样例 #4

### 输入

```
10
470606482521 533212137322 116718867454 746976621474 457112271419 815899162072 641324977314 88281100571 9231169966 455007126951
26 83 30 59 100 88 84 91 54 61```

### 输出

```
815899161079.400024414062```

# 题解

## 作者：UnyieldingTrilobite (赞：8)

首先我们发现，如果当前所位于的点是 $a$ 的最大值，那么继续走下去只会徒耗 $b$ 价值而不会增大 $a$ 价值，那一定就是~~纯纯怨种~~不优的。考虑到圆环本身是对称的，于是我们不妨假定 $a_n$ 就是最大值。如此一来，不管是 $n-1$ 到 $n$ 还是 $1$ 到 $n$，都应当立刻停下，而不会跨越到另一边。于是我们意识到可以追加定义 $a_0=a_n$，便能把环上的问题转到链上。

那么我们考虑记录 $e_i$ ~~真是天才~~ 表示当前位置是 $i$ 的时候最优决策下的期望收益。我们考虑每一步，或者在当前就停下，或者随机往左右一步。于是我们得到方程：

$$e_i=\max(a_i,\frac{e_{i-1}+e_{i+1}}2-b_i)$$

（对于左右边界，后半部分无意义。）

现在我们构造序列 $c$ 满足 $c_{i+1}=2(b_i+c_i)-c_{i-1}$（$c_0$ 和 $c_1$ 爱咋取咋取），发现 $c$ 序列具有性质 $\frac{c_{i-1}+c_{i+1}}2-b_i-c_i=0$。（实际上，在做题的时候，我们正是瞄准了这条性质才构造出的 $c$。）

于是我们考察 $f_i=e_i-c_i$：

$$f_i=\max(a_i-c_i,\frac{f_{i-1}+f_{i+1}}2+\frac{c_{i-1}+c_{i+1}}2-b_i-c_i)=\max(a_i-c_i,\frac{f_{i-1}+f_{i+1}}2)$$

这个形式是非常好看的。实际上，如果我们把 $(i,f_i)$ 看成平面上的一个点 $p_i$，那么这个式子实际上给了我们这两条性质：

+ $p_i$ 在 $(i,a_i-c_i)$ 上方。

+ $p_i$ 在 $p_{i-1}p_{i+1}$ 连线上方。

+ 以上两条至少取等一条。

我们不难发现，这是一个凸包的模型。考察所有 $(i,a_i-c_i)$ 构成的上凸壳，则 $p_i$ 的几何含义就是凸壳轮廓线上横坐标 $i$ 的位置上所对应的点。证明可以分两步：先说明 $p_i$ 在此点上方，再说明由于两端只能取等第一条而卡住所有点都取到等。当然，如果你足够熟练：

![image.png](https://s2.loli.net/2023/01/29/FCuxmb56c2KRfHA.png)

总结一下，我们解决整个题目花了三步：

1. 找到 $a$ 最大值的位置，重构序列（其实就是旋转一遍然后复制一下首尾元素）。

2. 计算 $c$，构建凸包。

3. 推出所有 $e_i$，取平均值作为答案输出。

代码实现中下标从零开始，略有差异，领会精神即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  int n, ans = 0;
  cin >> n;
  vector<pair<int, int>> v(n);
  for (auto& [a, b] : v) cin >> a;
  for (auto& [a, b] : v) cin >> b;
  rotate(v.begin(), max_element(v.begin(), v.end()), v.end());
  v.push_back(v.front());
  vector<int> c(n + 1);
  c[0] = c[1] = 0;
  for (int i = 1; i < n; ++i)
    ans += c[i + 1] = ((c[i] + v[i].second) << 1) - c[i - 1];
  ans <<= 1;
  stack<pair<int, int>> h;
  for (int i = 0; i <= n; ++i) {
    int x = i, y = v[i].first - c[i];
    while (h.size() >= 2u) {
      auto [x1, y1] = h.top();
      h.pop();
      auto [x0, y0] = h.top();
      if ((x1 - x0) * (y - y0) < (y1 - y0) * (x - x0)) {
        h.emplace(x1, y1);
        break;
      }
    }
    h.emplace(x, y);
  }
  while (h.size() >= 2u) {
    auto [x1, y1] = h.top();
    h.pop();
    auto [x0, y0] = h.top();
    ans += (y1 + y0) * (x1 - x0) + (y1 - y0);
  }
  return cout << fixed << setprecision(16) << ans * .5 / n << endl, 0;
}
```

---

## 作者：向晚大魔王 (赞：7)

这他妈是怎么想到的？

考虑设 $f_x$ 为 $x$ 的期望，则 $f_x=\max(\frac{f_{x-1}+f_{x+1}}{2}-b_x,a_x)$。

如果 $b_x=0$ 我们就直接求一个凸壳就做完了，中间的期望可以证明是一段等差序列。

所以我们设 $g_x=f_x-c_x$，使得 $g_x=\max(\frac{g_{x-1}+g_{x+1}}{2},a_x-c_x)$。

那 $c_x$ 只需要满足 $c_{x-1}+c_{x+1}=2c_x+2b_x$ 即可，随便算。

---

## 作者：Aaronwrq (赞：6)

# [AGC044E] Random Pawn题解

### **[题目链接](https://www.luogu.com.cn/problem/AT_agc044_e)**
### **[AtCoder原题链接](https://atcoder.jp/contests/agc044/tasks/agc044_e)**

## Step 1. 拆环

原问题是在环上的问题，考虑**将环拆开变成链来处理**。因此，我们需要找到一个点，使得操作越过这个点一定不优。

令使 $a$ 的值最大的位置的下标为 $maxp$。容易发现，如果现在正处在 $maxp$ 上，那么继续操作一定不可能得到更优的答案。因此，我们可以从 $maxp$ 的位置将环断开成为一条链。令环上下标为 $maxp$ 的点在链上的下标为 $0$，并将环上下标为 $maxp$ 的点复制一份到链上下标为 $n$ 的点。操作结束后链上共 $n + 1$ 个点，下标为 $0 \sim n$。（**后文中的下标若未加特殊说明则视为链上的下标**）

原来在环上的问题被成功转化为在链上的问题。
## Step 2. 问题转化

概率和期望问题可用动态规划求解。令 $dp_i$ 表示以 $i$ 点为起点的最大期望价值。如果不操作，价值为 $a_i$；如果操作，价值的期望为 $\dfrac{f_{i - 1} + f_{i + 1}}{2} - b_i$。由于每一步要走最优路线，$f_i$ 为上述两种情况期望价值的最大值。即：

$$ f_i = \max\left(a_i,\dfrac{f_{i - 1} + f_{i + 1}}{2}- b_i\right) $$

边界条件：$f_0 = a_0$，$f_n = a_n$。

这是一个**有后效性**的动态规划，因此考虑解方程组，$f_i$ 为未知数，$a_i$，$b_i$ 为参数。

## Step 3. 消去常数

方程组里的的常数项 $b_i$ 很烦人，考虑消去 $b_i$ 。由于 $\max$ 函数左半部分为常数，右半部分与 $f$ 相关，比较常见的做法是构造一个数组 $d$ 并令 $g_i = f_i + d_i$，将与 $f$ 相关的方程组转换为与 $g$ 有关的方程组，从而消去 $\max$ 右半部分的常数。具体而言：

$$ g_i = f_i + d_i $$
$$ g_i = \max\left(a_i + d_i,\dfrac{f_{i - 1} + f_{i + 1}}{2}- b_i + d_i\right) $$
$$ g_i = \max\left(a_i + d_i,\dfrac{g_{i - 1} - d_{i - 1} + g_{i + 1} - d_{i + 1}}{2}- b_i + d_i\right) $$
$$ g_i = \max\left(a_i + d_i,\dfrac{g_{i - 1}+ g_{i + 1} }{2}- \dfrac{ d_{i - 1} +  d_{i + 1}}{2}- b_i + d_i\right) $$

我们要消去常数，因此我们令 $ - \dfrac{ d_{i - 1} +  d_{i + 1}}{2}- b_i + d_i = 0 $。于是我们得到的 $d$ 的递推式：

$$ d_{i + 1} = 2\left(d_i - b_i\right) - d_i$$

由于 $d$ 的作用只是消去常数，我们并不关心 $d$ 取什么值，满足递推关系即可。因此 $d_0$ 和 $d_1$ 可以随便取（例如都取 $0$）。
方程式化简为：

$$ g_i = \max\left(a_i + d_i,\dfrac{g_{i - 1}+ g_{i + 1} }{2}\right) $$

令 $c_i = a_i + d_i$，最终方程组为：

$$ g_i = \max\left(c_i,\dfrac{g_{i - 1}+ g_{i + 1} }{2}\right) $$

边界条件：$g_0 = c_0$，$g_n = c_n$。

原问题被转化为一个方程组的求解。

## Step 4. 方程组求解

观察到 $\dfrac{g_{i - 1}+ g_{i + 1} }{2}$ 的结构类似中点公式。于是考虑将问题放到平面直角坐标系上。在坐标系内点 $n + 1$ 个点， 每个点的坐标为 $\left( i, g_i \right)$。

假设不考虑 $c_i$ 的限制，那么中间每个点均为左右两边的点的连线段的中点，**每个点都在左右两边的点的连线段上**。此时所有点都在一条线段上。

那么这些点的排布可能如下：（$g_0, g_n$ 随便取的）  

![](https://cdn.luogu.com.cn/upload/image_hosting/sd9xs7gj.png)

接下来考虑带上 $c_i$ 的情况。

我们分析 $c_i$ 对解的影响。如果 $c_i$ 小于或等于原来的 $g_i$，那么 $c_i$ 不会产生影响；如果  $c_i$ 大于原来的 $g_i$，那么 $g_i$ 就会被增大为 $c_i$，其他点也会随 $g_i$ 的变化而变化。可以理解为 $c_i$ 把这个点“顶”起来了。如图所示：

带上 $c_2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/vc1t1pj5.png)

再带上 $c_4$：

![](https://cdn.luogu.com.cn/upload/image_hosting/wr5s1nvu.png)  

容易发现，经过若干次操作后，线段和点形成了一个**上凸壳**，即线段的斜率单调递减。

为什么是一个上凸壳？因为 $\max$ 函数和 $\dfrac{g_{i - 1}+ g_{i + 1} }{2}$ 的结构保证了一个点的位置不会比三点共线时低。严谨证明较为简单，请读者自证。

可以理解为：**$c_i$ 规定了每个点位置的理想值，而 $\max$ 函数和 $\dfrac{g_{i - 1}+ g_{i + 1} }{2}$ 的结构保证了图形的凹凸性。**

原问题转化为对给定的若干点求上凸壳。

$\left(0, c_0\right)$ 和 $\left(n, c_n\right)$ 已经确定，使用单调栈维护凸壳上斜率递减的线段即可。

得到上凸壳之后，我们计算出 $g_i$ 并还原出 $f_i$ 就能够得到从每个点出发价值的期望，对 $i \in \left [1, n \right ] $ 求出 $f_i$ 的平均值即为答案。

时间复杂度为 $O\left(n\right)$。

## 总结

本题的原问题经历了三次转化：

1. 将环断开为链，把环上问题变为链上问题。

2. 利用动态规划，将最优策略问题变为有后效性动态规划解方程组问题，并将每个未知数加上一个常数来消常数。

3. 把未知数放到平面直角坐标系上，观察出上凸壳性质，将解方程组问题转化为上凸壳维护的问题。

环拆链和有后效性动态规划的转化比较常见，但消去常数和维护上凸壳的转化较为巧妙，而消去常数的一大原因是找到了大致的上凸壳关系。因此，找到上凸壳的性质是解出本题的关键。

在平时做题的时候，要多多注意积累类似的转化。同时，任何题目的关系式都一定不是空穴来风，要注意观察，构造几何模型，更好地发掘性质，以求问题的简单化。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 200010;

int n, maxp;
double a[MAXN], b[MAXN], f[MAXN], g[MAXN], d[MAXN], c[MAXN];
double ans;
int q[MAXN];
int tot;

bool Cmpk(const int i){
	double k1 = (c[i] - c[q[tot]]) / (i - q[tot]);
	double k2 = (c[q[tot]] - c[q[tot - 1]]) / (q[tot] - q[tot - 1]);
	return k1 > k2;
}

int main()
{
	scanf("%d", &n);
	for (int i = 0; i < n; ++i){
		scanf("%lf", a + i);
		if (a[i] > a[maxp]) maxp = i;
	}
	for (int i = 0; i < n; ++i) scanf("%lf", b + i);

	double tmp[MAXN];
	for (int i = 0; i < n; ++i) tmp[i] = a[(i + maxp) % n];
	for (int i = 0; i < n; ++i) a[i] = tmp[i];
	for (int i = 0; i < n; ++i) tmp[i] = b[(i + maxp) % n];
	for (int i = 0; i < n; ++i) b[i] = tmp[i];
	a[n] = a[0];
	
	for (int i = 1; i < n; ++i) d[i + 1] = (d[i] - b[i]) * 2 - d[i - 1];
	for (int i = 0; i <= n; ++i) c[i] = a[i] + d[i];
	
	q[0] = 0;
	for (int i = 1; i <= n; ++i) {
		while (tot && Cmpk(i)) --tot;
		q[++tot] = i;
	}
	//q为单调栈，维护凸包内线段端点的点集
	for (int i = 0; i < tot; ++i) {
		double know = (c[q[i + 1]] - c[q[i]]) / (q[i + 1] - q[i]);
		double bnow = c[q[i]] - know * q[i];
		for (int j = q[i]; j < q[i + 1]; ++j) {
			g[j] = know * j + bnow;
		}
	}
	
	for (int i = 0; i < n; ++i) f[i] = g[i] - d[i], ans += f[i];
	ans /= n;
	printf("%.12lf\n", ans);
	return 0;
}
```


---


# [AGC041E] Balancing Network

## 题目描述

平衡网络是一个由 $M$ 个平衡器所连接的 $N$ 根导线所构成的抽象网络系统。这一系统按由左至右的顺序运行。导线从上到下按 $1$ 至 $N$ 编号，平衡器从左到右按 $1$ 至 $M$ 编号。第 $i$ 个平衡器连接着导线 $x_i$ 与 $y_i$。下图是一个平衡网络的示例：

![1](https://cdn.luogu.com.cn/upload/vjudge_pic/AT5696/879f5ab566621f7b08b9e0b92ec0fd4600d0b408.png)

每个平衡器都一定处于以下两种状态之一：向上或向下。

让我们考虑一个令牌，这个令牌在所有平衡器左侧的某个点开始沿某根导线向右移动。在此过程中，每个平衡器都会被令牌恰好**途经**一次。当令牌途经一个平衡器 $i$ 时，可能会发生以下情况：

- 如果令牌沿导线 $x_i$ 移动且平衡器 $i$ 处于向下的状态，则令牌会向下移至 $y_i$ 并继续向右移动。

- 如果令牌沿导线 $y_i$ 移动且平衡器 $i$ 处于向上的状态，则令牌会向上移至 $x_i$ 并继续向右移动。

- 否则，令牌不会改变其移动的导线。

我们将所有平衡器的状态用长度为 $M$ 的字符串表示。若第 $i$ 个平衡器处于向上的状态，则第 $i$ 个字符为'`^`'；若第 $i$ 个平衡器处于向下的状态，则第 $i$ 个字符为'`v`'。

如果存在一根导线 $w$ ，使得令牌无论从整个网络的哪一根导线开始移动都能抵达导线 $w$ 且一直沿此导线移动至趋向无穷远的位置，那么这个网络称之为均匀状态；任何的其他状态称之为非均匀状态。

给出一个整数 $T (1 \le T \le 2)$ ，请您根据 $T$ 的值回答以下问题：

- 若 $T=1$，则通过自行规定平衡器的方向以构造给出网络的任何均匀状态，或是回答不存在。

- 若 $T=2$，则通过自行规定平衡器的方向以构造给出网络的任何非均匀状态，或是回答不存在。

请注意，若您仅正确回答了一种问题，则您将获得一定的部分分。

## 说明/提示

- $2 \le N \le 50000$
- $1 \le M \le 10^5$
- $1 \le T \le 2$
- $1 \le x_i \lt y_i \le N $
- 保证所有输入均为整数。

### 子任务

- 若您通过了所有 $T=1$ 时的所有测试点，则您将获得 $50 \%$ 的分数。（译注：原文是800分，但本题的实际分数为1600分，翻译时按照 $50 \%$ 翻译） 
- 若您通过了所有 $T=2$ 时的所有测试点，则您将获得 $50 \%$ 的分数。

## 样例 #1

### 输入

```
4 5 1
1 3
2 4
1 2
3 4
2 3```

### 输出

```
^^^^^```

## 样例 #2

### 输入

```
4 5 2
1 3
2 4
1 2
3 4
2 3```

### 输出

```
v^^^^```

## 样例 #3

### 输入

```
3 1 1
1 2```

### 输出

```
-1```

## 样例 #4

### 输入

```
2 1 2
1 2```

### 输出

```
-1```

# 题解

## 作者：AuCloud (赞：4)

先分成两类询问：

#### 1.构造合法序列：

考虑最暴力的做法：枚举终点的导线，暴力验证。为了消除后效性，我们从后往前枚举平衡器，这保证了已选完的平衡器无法影响没有选的平衡器。

显然我们的问题是从所有的导线都会汇聚到 $k$ 号导线。于是用 $V_i=1$ 表示 $i$ 号导线出发能到达 $k$ ，否则即为不能。初始只有 $V_k=1$

倒序枚举每个平衡器，设两端为 $x$ 和 $y$ 。

显然，如果 $V_x$ 和 $V_y$ 都是 $1$ 或都是 $0$ ，则无论这个线怎么连都没有意义。

如果 $V_x = 1, V_y=0$ ，则让这个平衡器由 $y$ 指向 $x$ ，这样可以让 $V_y=1$。

 $V_x = 0, V_y=1$  同理。

这个东西是 $O(NM)$ 的，过不了。考虑优化：

发现结果上来讲这个东西就是给 $V_x, V_y$ 取或，考虑用 `bitset` 优化，变成 $O(\frac{NM}{\omega})$ ，跑得还挺快的。

无解情况就是跑出来发现所有的 `count()` 都不是 $N$ ，否则随便找一个符合条件的点按刚刚暴力的方式统计答案就行。总复杂度 $O(\frac{NM}{\omega})$

#### 2.构造不合法序列

首先有结论： 当且仅当 $N=2$ 时无解。

显然 $N=2$ 时无论指向哪里都合法。至于为什么 $N\gt2$ 时均有解，可以参考构造方案。

设 $cnt_i$ 表示以 $i$ 结尾的不同开头有多少条， $ed_i$ 表示从 $i$ 开始走从哪里结束。初始的时候 $ed_i=i,cnt_i=1$。

显然题目要求即为 $\forall i\le N, cnt_i\lt N$ 。

还是从后往前枚举限制器。如果 $ed_x=ed_y$ ，则当前限制器没有意义，随意指就好。

如果 $cnt_{ed_x}=N-1$ ，说明如果让 $y$ 指向 $x$ 就变成合法序列了，所以需要 $x$ 指向 $y$ 。这会导致 $ed_x$ 变成 $ed_y$ 并让 $cnt_{ed_x}$ 减小 $1$ ，$cnt_{ed_y}$ 增加 $1$ 。反之亦然。

如果两边都小于 $N-1$ ，随便连即可。

可以知道，$cnt$ 中的东西是不重复的，所以 $\sum cnt_i=N$ 。而当 $N\gt2$ 时， $2\times(N-1) > N$ ，所以不存在一个限制器两边都是 $N-1$ 的情况，所以必定有解。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
char ans[100005];
bool used[100001];
int fr[100001], to[100001];
int n, m;
bitset<50001>b[50001], tmp;
void work1()
{
	for(int i = 1; i <= n; i++)
	{
		b[i][i] = 1;
	}
	for(int i = 1; i <= m; i++)
	{
		b[fr[i]] = b[to[i]] = b[fr[i]] | b[to[i]];
	}
	int k = 0;
	for(int i = 1; i <= n; i++)
	{
		if(b[i].count() == n)
		{
			k = i;
			break;
		}
	}
	if(!k)
	{
		cout << "-1";
		exit(0);
	}
	used[k] = 1;
	for(int i = m; i >= 1; i--)
	{
		if(used[fr[i]] == used[to[i]]) ans[i] = '^';
		else if(used[fr[i]]) used[to[i]] = 1, ans[i] = '^';
		else used[fr[i]] = 1, ans[i] = 'v';
	}
	cout << ans + 1;
	exit(0);
}
int cnt[50001], ed[50001];
void work2()
{
	if(n == 2) exit(0*(int)puts("-1"));
	for(int i = 1; i <= n; i++) cnt[i] = 1, ed[i] = i;
	for(int i = m; i >= 1; i--)
	{
		if(cnt[ed[fr[i]]] == n - 1)
		{
			ans[i] = 'v';
			cnt[ed[fr[i]]]--;
			ed[fr[i]] = ed[to[i]];
			cnt[ed[to[i]]]++;
		}
		else ans[i] = '^', cnt[ed[to[i]]]--, ed[to[i]] = ed[fr[i]], cnt[ed[fr[i]]]++;
	}
	cout << ans + 1;
	exit(0);
}
int main()
{
	int op;
	cin >> n >> m >> op;
	for(int i = 1; i <= m; i++)
	{
		int x, y;
		cin >> x >> y;
		fr[i] = x, to[i] = y;
	}
	if(op == 1) work1();
	else work2();
	return 0;
}

```

---

## 作者：pufanyi (赞：3)

一道有趣的构造题。

首先我们考虑构造第一组解。我们考虑从后往前做，枚举 $t$ 判断是否有一组解使得最终所有 $k_i=t$。令 $f_{i,j}$ 表示仅有最后 $i$ 个平衡器时，第 $j$ 条线上的令牌是否到了 $t$。考虑在最前面加一个平衡器。发现其实就是 $f_{i+1,x_{n-i}}=f_{i+1,y_{n-i}}=f_{i,x_j}\vee f_{i,y_{n-i}}$。因为只要有一条线上可以到达 $t$，我们可以将两条线上的令牌都导到这条线上。

考虑上面的做法将第一维滚掉之后是 $\mathcal{O}(m)$ 的，于是我们得到了一个 $\mathcal{O}(nm)$ 的算法。考虑优化，我们令 $g_{i,j,t}$ 表示最后 $i$ 个，第 $j$ 条线是否能到达 $t$。我们考虑转移就是 $g_{i+1,x_{n-i},t}=g_{i+1,y_{n-i},t}=g_{i,x_{n-i},t}\vee g_{i,y_{n-i},t}$。不难发现这个东西可以用 `bitset` 进行优化。常数 $\frac{1}{64}$，可以过。

然后考虑构造，这就简单了，直接沿着一个有解的 $t$，继续做一遍上面的 `dp` 即可。

然后考虑第二问，首先我们发现之后当 $n=2$ 的时候才会发生无解。其余时刻都不会，至于为什么，我们考虑一下的构造方法。

仍然考虑倒着做，$f_{i,j}$ 表示加入最后的 $i$ 个平衡器，第 $j$ 根线上的令牌现在在哪儿。

我们考虑加入一个令牌，那只会有两种状态：$f_{i+1,x_{n-i}}=f_{i+1,y_{n-i}}=f_{i,x_{n-i}}$ 或是 $f_{i+1,x_{n-i}}=f_{i+1,y_{n-i}}=f_{i,y_{n-i}}$。而最终的目的是让至少有两个 $f$ 值是不相等的。那么我们考虑 $g_{i,j}$ 表示 $f_{i,k}=j$ 的数量。这样我们只要比较两个 $f$ 的 $g$，看看那个多，让多的给少的一个。考虑到 $n>2$，每次将一个 $g$ 加 $1$，一个 $g$ 减 $1$。不难发现一定有两个 $g$ 是大于 $0$ 的。于是一定有一种方案合法。


---

## 作者：AzusaCat (赞：2)

现在有 $n$ 条线 $m$ 个平衡器，平衡器从左往右，第 $i$ 个平衡器连接了 $x_i,y_i(x_i<y_i)$，你需要给平衡器定向，定向后的平衡器若是从 $x_i$ 指向 $y_i$，则你从 $x_i$ 走到这个平衡器时会跑到 $y_i$，你需要给出满足和不满足以下条件的定向方案或判断无解：从每根线的最左面出发一直向右走，最后都会走到同一根线的最右面。$n\leqslant 50000,m\leqslant 100000$。

##### 满足条件

假设我们最后全走到了 $t$，我们记录 $vis_i$ 表示现在从 $i$ 开始走是否会走到 $t$，我们从右往左添加平衡器，一开始只有 $vis_t=1$，若现在添加的平衡器为 $(x,y)$，分类讨论：

- 若 $vis_x=vis_y=0$ 或 $vis_x=vis_y=1$ 怎么调都不会改变。
- 若 $vis_x=1,vis_y=0$，把平衡器设为 $y\rightarrow x$ 可以让 $vis_y$ 也变成 $1$。
- 若 $vis_y=1,vis_x=0$ 类似上面。

注意到这等价于把 $vis_x$ 和 $vis_y$ 都赋值为两者的或，所以我们可以用 bitset 来加速枚举，每一位表示终点为 $i$ 的答案，这样添加一个平衡器就等价于把两个 bitset 或起来，复杂度 $O(\dfrac{nm}{w})$。

##### 不满足条件

由于 $m>0$，所以若 $n=2$ 一定无解。下面的构造方式证明了 $n>2$ 时一定有解。

我们设 $end_i$ 表示 $i$ 目前最后会走到哪里，$siz_i$ 表示最终会走到 $i$ 的线的数量。那么我们只需要保证对任意 $i$，$siz_i<n$。我们依旧从后向前添加平衡器，一开始 $end_i=i,siz_i=1$。假设现在添加的是 $(x,y)$，我们发现，这等价于要不然把 $end_x$ 改为 $end_y$，要不然把 $end_y$ 改为 $end_x$。注意到这会使 $siz_{end_x}$ 或 $siz_{end_y}$ 加上 $1$，所以当 $siz_{end_x}=n-1$ 时定向为 $x\rightarrow y$ 即可，$siz_{end_y}=n-1$ 时同理，注意到由于 $n>2,2n-2>n$，所以不会出现两个都为 $n-1$ 的情况。如果两个都不为 $n-1$ 任意定向即可。复杂度 $O(n+m)$。

---


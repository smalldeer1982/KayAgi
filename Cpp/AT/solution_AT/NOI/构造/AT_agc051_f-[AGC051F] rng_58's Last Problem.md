# [AGC051F] rng_58's Last Problem

## 题目描述

有两个沙漏，一只计时 $1$ 秒，另一只计时 $\sqrt{2}$ 秒。你能否用它们测量 $x + y\sqrt{2}$ 秒的时间？

下面是严格的描述。有两个沙漏 $A$ 和 $B$，每个沙漏都有两个装沙子的“球”。每个沙漏可以竖直或水平放置。竖直放置时，只要上面的球中还有沙子，沙子就会以每秒 $1$ 克的速度流向下面的球。水平放置时，沙子不会流动。由于竖直放置时可以选择哪一个球在上方，因此每个沙漏共有 $3$ 种状态。

沙漏 $A$ 内有 $1$ 克沙子，沙漏 $B$ 内有 $\sqrt{2}$ 克沙子。因此，当沙漏 $A$ 竖直放置且所有沙子都在上球时，沙子全部流完需要 $1$ 秒。同理，沙漏 $B$ 需要 $\sqrt{2}$ 秒。

开始时，沙漏 $A$ 和 $B$ 都竖直放置，所有沙子都在下球。在“すぬけ君”喊叫之前，不能对沙漏做任何操作。当“すぬけ君”喊叫后恰好 $t$ 秒时发生*事件*（定义见下），则称测量出了 $t$ 秒。

*事件* 指以下任一情况：

- “すぬけ君”喊叫。
- 竖直放置的沙漏中沙子恰好流完。

每当发生*事件*时，可以在忽略所需时间的情况下，进行以下操作任意多次：

- 选择一个沙漏，将其切换到另一种状态。

例如，可以如下测量 $-1 + 2\sqrt{2}$ 秒：

- 时刻 $0$，“すぬけ君”喊叫。将 $A$ 和 $B$ 都翻转。
- 时刻 $1$，$A$ 的沙子流完，发生事件。再次翻转 $A$（$B$ 保持不变）。
- 时刻 $\sqrt{2}$，$B$ 的沙子流完，发生事件。再次翻转 $A$，并将 $B$ 横放。
- 时刻 $-1 + 2\sqrt{2}$，$A$ 的沙子流完，发生事件。

给定 $Q$ 个形如 $x_i + y_i\sqrt{2}$ 的数，请判断每个数能否用上述方法测量出来。

## 说明/提示

### 数据范围

- $1 \leq Q \leq 10^5$
- $-10^9 \leq x_i, y_i \leq 10^9$
- $x_i + y_i\sqrt{2} > 0$
- 输入中的所有值均为整数。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
-1 2
2020 1227
2 -1```

### 输出

```
Yes
Yes
No```

# 题解

## 作者：Rainbow_qwq (赞：4)

~~终于做出了 AGC 纪念。很多结论都是猜的，没有证明。~~

对于 $a+b\sqrt2$，发现 $a>0,b>0$ 肯定是能得到的，对于 $a<0,b>0$，就是要求出对于某个 $b$，能得到的最小 $a$ 是多少，$a>0,b<0$ 同理。

首先题目中的操作太抽象，要用**合理、直观的方式刻画操作**。于是想到用 $(x,y)$ 表示第一个漏斗掉落了 $x$，第二个漏斗掉落了 $y$ 的状态。

看做一个小球，从初始点 $(0,0)$ 开始，从 $(-1/0/1,-1/0/1)$ 八个方向中选择一个不断运动，直到 $x\in\{0,1\},y\in\{0,\sqrt2\}$ 时可以改变方向。（这步好像和官方题解一样，就上这张图）

![](https://img.atcoder.jp/agc051/71818d155faf01fd3d1684a7bb88c17e.png)

但这样是在网格里循环的走，还是不直观，那就**扩充到一个二维坐标系**。

在坐标系里，$x$ 轴每格长为 $1$，$y$ 轴每格长为 $\sqrt 2$。我们规定小球只能向上下左右，和右上、左下 6 个方向走，碰到坐标系的一条线时可以改变方向。

![](https://cdn.luogu.com.cn/upload/image_hosting/5dfuzvup.png)

接下来我们想找出怎样走是最优的。

上图中红线长度分别表示 $\sqrt 2-1,2\sqrt 2-2,3\sqrt 2-4,4\sqrt 2-5...$，蓝线长度表示 $2-\sqrt 2,3-2\sqrt 2,5-3\sqrt 2...$。

经过手玩和暴力验证，发现一直走斜线是比某一次走上下左右优的。

假设我们要凑出的是 $a+b\sqrt 2(a<0,b>0)$，我们可以走到一条红线的地方，在红线上来回走。比如走到 $(1,1)$，然后不断走 $\sqrt 2-1$ 红线，就能得到所有 $2\sqrt 2-1,3\sqrt 2-2,4\sqrt 2-3...$，也就是 $1+k(-1+\sqrt2)$。（这也是暴力输出路径的结果）

但这样不是最优的，如果走到 $(4,4)$，虽然要付出走过 $4$ 时间的代价（要减的 1 的系数多了），去 $3\sqrt 2-4$ 的红线走可以减少的 1 的系数更多。但这样前两段红线刷的次数都得是偶数次，最后一条红线是任意次。可以表述为 $4+2k_1(-1+\sqrt2)+2k_2(-2+2\sqrt2)+k_3(-4+3\sqrt 2)$。

那么我们的策略也固定了：走到某一条红线处，前面的每条红线刷偶数次，最后一条红线刷任意次。

显然，如果一条红线比前面的所有红线都更优（也就是 $1$ 上的系数除以 $\sqrt2$ 上的系数更大），我们才会去走到它来得到更优。

打表一下，发现似乎只有 $\log$ 条有用的红线。下面是一部分打出的表。

其实是取不断逼近 $\sqrt 2$ 的所有真分数 $p/q$，并且 $p,q$ 尽量小，不难想到可以在 Stern-Brocot 树上二分求出，同时也证明了数量是 $\log$ 的。~~数据范围才 1e9，直接贴打出来的表也行~~

```
1 1 1.000000000000
3 4 1.333333333333
5 7 1.400000000000
17 24 1.411764705882
29 41 1.413793103448
99 140 1.414141414141
169 239 1.414201183432
577 816 1.414211438475
985 1393 1.414213197970
3363 4756 1.414213499851
5741 8119 1.414213551646
19601 27720 1.414213560533
33461 47321 1.414213562057
114243 161564 1.414213562319
```

那对于询问，可以枚举走到哪条红线，然后枚举最后一条红线走了奇数次还是偶数次。那现在变成了前面若干条红线都要走偶数次。

下面把每条红线 $(\sqrt2 的系数,-1的系数)$ 看做一个向量，询问也看做一个向量。

这样问题就变成了：询问一个向量 $(a,b)$，对于前若干个向量，每个向量都要取偶数个，问能不能加起来得到向量 $(c,d)$ 使得 $c\le a,d\ge b$。（$a,c$ 代表 $\sqrt2$ 的系数，$b,d$ 代表 $-1$ 的系数）

令 $a\to \lfloor a/2\rfloor,b\to \lceil b/2 \rceil$，去掉偶数的限制。

猜一个结论，设最后一个向量（最后走到的红线）是 $(p,q)$，只需要满足 $\frac{a}{b}\ge \frac{p}{q}$ 就行了。

虽然不会证，但感觉就很能用调整满足。用暴力 DP 验证，发现结论是正确的！

对于 $a+b\sqrt 2(a>0,b<0)$ 也就是走蓝线的情况，所有的结论都是类似的，不再赘述一遍。要求的向量也是比值逼近 $\sqrt2$ 的若干个 $p/q$，可以在 Stern-Brocot 树上二分时一并求出。下面是部分向量的表。

```
2 1 2.0000000000000
3 2 1.5000000000000
10 7 1.4285714285714
17 12 1.4166666666667
58 41 1.4146341463415
99 70 1.4142857142857
338 239 1.4142259414226
577 408 1.4142156862745
1970 1393 1.4142139267767
3363 2378 1.4142136248949
11482 8119 1.4142135731001
19601 13860 1.4142135642136
66922 47321 1.4142135626889
```

[代码](https://atcoder.jp/contests/agc051/submissions/39143097)

---

## 作者：jun头吉吉 (赞：3)

## 题意
你有两个沙漏，一个时间为 $1$，一个时间为 $\sqrt 2$。初始所有沙子都在一边。

问能否计时 $x+\sqrt2y$。

$T$ 组询问。

$x+\sqrt2y\ge0,|x|,|y|\le MAX=10^9$。

## 题解

翻译一下官方题解。

首先我们可以换一种描述问题的方式：有一个 $1\times \sqrt2$ 的矩形，你从 $(0,0)$ 出发，可以以 $(0,\pm1),(\pm1,0),(\pm1,\pm1)$ 的速度走，碰到墙壁可以改变速度，问碰到墙壁时可以得到多少种时间。

![](https://cdn.luogu.com.cn/upload/image_hosting/ryqpcimt.png)

然后这个问题还是不好描述。我们把 $A-E-F-G-H-I-J-K-\cdots$ 这些点拿到数轴上，变成下面这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/ymiendwk.png)

然后我们可以重新描述这这个问题：可以走若干次，从 $A$ 出发，到一个点就变换方向，求最后的总时间。

这个怎么理解呢？首先考虑走一次的意义就是每次碰到墙壁要么转弯，要么往回走（一直斜着走）。有一个小问题就是这样没有考虑横走/竖走的情况，如果你横走/竖走没有到顶点的话，那么就相当于直接翻了一个沙漏。然后如果走到顶点就相当于重新从 $A$ 出发。然后至于为什么可以走若干次就是每一次最后一步改成横走或竖走走到顶点重新开始。

然后呢就是我们可以把一次行程看做是走到最远的地方，走回来，加上若干段出现两次的，类似下图

![](https://cdn.luogu.com.cn/upload/image_hosting/zql1u965.png)

然后走多次我们可以只保留最远的那一次，剩下若干两次的，以及单走 $a$ 和单走 $a\sqrt 2$，类似下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zukxaijl.png)

这个问题已经形式化很多了。我们甚至可以给出一个初步的判断式。设 $z_0,z_{1},z_2,\dots,$ 是所有自然数和所有 $\sqrt2$ 的倍数排完序的结果，那么一个合法的时间满足：
$$
T=2z_q-z_p+2\left(\sum_{i=0}^{q-1}(z_{i+1}-z_i)c_i\right)+r+s\sqrt 2
$$
其中所有 $p,q,c_i,r,s$ 均为自然数，$p\le q$。

于是我们有了初步的判断方法：枚举 $p,q$，然后用 $r,s\in\{0,1\}$ 调整使得 $T-2z_q+z_p-r-s\sqrt2$ 系数为偶数，判断能否被 $\sum_{i=0}^{q-1}(z_{i+1}-z_i)c_i$ 构造出来。

然后又是很巧妙的一步。考虑一个坐标系，点 $(x,y)$ 表示 $x+\sqrt 2y$。画出 $x\le z_q$、$\sqrt2y\le z_q$ 和 $x+\sqrt2y\ge0$。 就类似于下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qdadthso.png)

所有的红点就是所有 $0\le i\le j\le q$，$z_j-z_i$ 的值。现在就是问这些向量可以组成哪些向量。

一个结论是分别找到两个蓝点，也就是斜率的极值点，结论就是要在原点和蓝点的连线上方就一定能构成，否则一定不能构成。

![](https://cdn.luogu.com.cn/upload/image_hosting/b4fwykck.png)

至此，我们得到了一个确定性的判断方法。

考虑优化以上方法。不妨假设询问的 $T=x+\sqrt 2y$ 满足 $x>0,y<0$，那么我们可以枚举可行的区域。对于一个区域，我们找到最小的 $z_q$，然后此时 $z_p$ 取 $z_q$ 或者离 $z_q$ 最近的和 $z_q$ 不同类的。对于右下方的蓝点是 $(tx,-ty)$ 的情况，就是 $z_q=z_p=tx$ 或 $z_q=tx,z_p=\sqrt2ty$。然后调整一下使得系数变成偶数再判断是否在区域内即可。

$x<0,y>0$ 的情况也是类似的。

最后就是一个问题，如何求出所有不同的区域。考虑类似 Stern-Brocot Tree，初始是 $0/1$ 和 $1/0$，每次在 $a/b$ 和 $c/d$ 中间插入 $(a+c)/(b+d)$，不断逼近 $\sqrt 2$，这中间出现的分数就对应一个蓝点的坐标。这也说明了不同的区域个数是 $\log MAX$ 级别的。

最后的复杂度为 $\mathcal O(T\log MAX)$。

## 代码
```cpp
#define int ll
vector<pair<int,int>>ul,dr;
void build(int a,int b,int c,int d){
	if(a>1e9||c>1e9)return;
	int p=a+c,q=b+d;
	if(p*p>2*q*q)dr.eb(p,q),build(a,b,p,q);
	else ul.eb(q,p),build(p,q,c,d);
}
bool chk(int x,int y,int tx,int ty){
	if(x<0)return 0;
	x/=2;y=(y+1)/2;
	return /*y/x<=ty/tx*/y*tx<=ty*x;
}
bool chk(int x,int y){
	if(x>=0&&y>=0)return 1;
	vector<pair<int,int>>tmp;
	if(y<0)y=-y,tmp=dr;
	else x=-x,swap(x,y),tmp=ul;
	for(auto[tx,ty]:tmp){
		if(chk(x-tx,y,tx,ty))return 1;
		if(chk(x-2*tx,y-ty,tx,ty))return 1;
	}
	return 0;
}
int T,x,y;
signed main(){
	build(0,1,1,0);
	read(T);while(T--){
		read(x,y);
		puts(chk(x,y)?"Yes":"No");
	}
}
```

---


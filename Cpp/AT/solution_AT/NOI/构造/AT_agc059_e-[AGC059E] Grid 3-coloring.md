# [AGC059E] Grid 3-coloring

## 题目描述

有一个 $N \times N$ 的方格棋盘。你需要用三种颜色给所有格子染色，要求任意相邻（共享边）的两个格子颜色不同。

棋盘最外层的格子已经被染色。请判断是否可以按照要求给剩下的格子染色。

更准确地说，给定一个由字符 `1`、`2`、`3` 组成的长度为 $4N-4$ 的字符串 $S$，该字符串表示从 $(1, 1)$ 开始，按顺时针顺序记录的最外层格子的颜色。具体地，第 $i$ 个字符表示如下格子的颜色：

- 当 $1 \leq i \leq N-1$ 时，对应 $(1, i)$；
- 当 $N \leq i \leq 2N-2$ 时，对应 $(i - (N-1), N)$；
- 当 $2N-1 \leq i \leq 3N-3$ 时，对应 $(N, 3N-1-i)$；
- 当 $3N-2 \leq i \leq 4N-4$ 时，对应 $(4N-2-i, 1)$。

其中，$(r, c)$ 表示第 $r$ 行第 $c$ 列的格子。

保证最外层格子中，任意相邻的两个格子颜色不同。

对于每个输入文件，请判断是否存在一种方案，可以用三种颜色给剩下的格子染色，使得任意相邻格子颜色不同。

## 说明/提示

### 限制

- $1 \leq T \leq 5 \cdot 10^4$
- $3 \leq N \leq 2 \cdot 10^5$
- $S$ 是由字符 `1`、`2`、`3` 组成的长度为 $4N-4$ 的字符串。
- 对于 $1 \leq i \leq 4N-5$，有 $S_i \neq S_{i+1}$，且 $S_{4N-4} \neq S_1$。
- 每个输入文件中所有 $N$ 的总和不超过 $2 \cdot 10^5$。
- 输入中的所有数字均为整数。

### 样例解释 1

对于第一个和第三个测试用例，可以证明无法按照要求染色。对于第二个和第四个测试用例，下面给出了可以按照要求染色的方案。  
![](https://img.atcoder.jp/agc059/1ada4c7ac4b8e04277788b67a8d2a71c.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
3
12312312
4
121212121212
7
321312312312121212121321
7
321312312312121312121321```

### 输出

```
NO
YES
NO
YES```

# 题解

## 作者：zhoukangyang (赞：15)

考虑猜结论。

在猜测了 114514 个结论后，我们发现了一个不会 WA 的但是不知道为什么的结论：

对于图上的每一条竖线，我们把这条横线右边的点从左到右贪心“匹配”。匹配的过程是每次把 ``... x y x`` 变成 ``... x``。如果最后剩下的元素个数大于 $n$，那么返回 ``NO``。把它旋转 90，180 和 270 度再做一次。如果都符合条件就返回 ``YES``。可能比较抽象，可以看看这份[代码](https://atcoder.jp/contests/agc059/submissions/41152475)。

对于每个方向，提前预处理出来每个点下一个可能匹配的点，然后使用 LCT 维护即可。

时间复杂度 $\Theta(n \log n)$。

[AC CODE](https://atcoder.jp/contests/agc059/submissions/41152809)

----

理性分析一下，不难发现该做法与标算等价。

---

## 作者：unputdownable (赞：14)

All hail our emperor antontrygubO_o!!!

--------

先不考虑构造矩阵 $c$，而是考虑构造一个在模 $3$ 意义下与 $c$ 同余的数字矩阵 $a$，满足 $a$ 中任意两个相邻元素都只相差 $1$。

比如这是样例 $4$：

![](https://cdn.luogu.com.cn/upload/image_hosting/jhzjsbrq.png)

不难发现每一个合法的将网格图三染色的方案，都有唯一的 $a$ 矩阵与之对应。

把给定的边框转换成 $a$ 十分简单，因为如果一个钦定了一个格子在 $a$ 上的值，就可以算出相邻格子的值。

如果边框转换后不合法（如样例 $1$，不论怎么钦定最后都会有大于 $1$ 的差存在）就可以直接输出 ``NO`` 了。

另外对于任何的 $(i,u),(j,k)$ 都应该有 $|a_{i,u}-a_{j,k}| \leq |i-j| + |u-k|$，即差应小于曼哈顿距离。对于这题，我们只需要检查所有的 $|a_{1,i}-a_{n,i}|$ 和 $|a_{i,1}-a_{i,n}|$ 是否小于 $n-1$ 即可。

接下来我们说明这两个条件是充要的。

给出一个构造：

$a_{i,j} = \max( a_{i,1}-(j-1),a_{i,n}-(n-j),a_{1,j}-(i-1),a_{n,j}-(n-i))$

容易发现这个构造是合法的。模 $3$ 就可以得到 $c$。

**Code：**
```cpp
int n,N;
char s[800005]; int sum[800005];
inline void work() {
    n=read(); N=4*n-3;
    scanf("%s",s+1); s[N]=s[1];
    for(int i=1; i< N; ++i) if(s[i]==s[i+1]) return puts("NO"),void();
    for(int i=2; i<=N; ++i) sum[i]=((s[i]-s[i-1]+4)%3-1)+sum[i-1];
    for(int i=2; i< n; ++i) if(abs(sum[i]-sum[3*n-1-i])>=n) return puts("NO"),void();
    for(int i=2; i< n; ++i) if(abs(sum[n-1+i]-sum[4*n-2-i])>=n) return puts("NO"),void();
    if(sum[N]!=0) puts("NO");
    else puts("YES");
}
```

---

## 作者：APJifengc (赞：5)

自己整出了个非常弱智的做法，麻烦炸了（

相邻两个位置不相等是一个很抽象的的条件，考虑转化一下，把颜色看作 $\bmod 3$ 意义下的数，然后将第 $i$ 个对角线加上 $i$，这样上下或左右两个位置之间要不然颜色相同要不然正好减 $1$。这相当于要求从任意一个点向右下走只能减 $1$ 或不变。画一下图，容易发现最后的矩形由若干条从左下到右上的路径划分开。

![img](https://cdn.luogu.com.cn/upload/image_hosting/9sd17bk4.png)

我们把右上边框和左下边框分成两部分，那么这个矩形就可以看作是左下边框到右上边框的若干条路径。注意此时左下与右上是若干连续段，我们考虑保留一段连续段中最靠中间的点，然后转化成这些点之间的路径，容易发现这两者是等价的。需要注意两个连续段内要求任意两点都是可以通过向右、上、右上走达的，所以如果两个段的左端点或者右端点之间不能互达那么就是无解的，需要先把这种情况判掉。

![img](https://cdn.luogu.com.cn/upload/image_hosting/6a93jz2a.png)

（关于等价的证明：对于左边框来说，由于靠上的段只能往上走，于是不会影响下面的段，所以我们只需要考虑这个连续段中最靠下的那个点能否到达右上角对应的段即可，显然通过这条路径划分的连通块内是包含整个连通块的。如果经过中点，我们考虑先把在中点往上的路径与中点往右的路径全部填好，此时只需要中间存在一条路径，就可以保证这个连续段内任意一个点都可以到达对面的点，所以只需要保留中点。）

那么现在问题转化成了，给定一个 $n \times n$ 的网格图，有 $k$ 个起点与终点，分别位于左下边框与右上边框，问是否存在 $k$ 条点不相交的路径。

我们可以转化成流的问题，可以容易的建出流图：

![img](https://cdn.luogu.com.cn/upload/image_hosting/8rxpdzqz.png)

其中斜着的一对点是由一个点拆点得到的，为了限制一个格子至多走一次。黑色边是起点与终点的边，这些边容量可能为 $0$ 或 $1$，对应着这里有起点或没有起点。

我们的目的就是求出这张图的最大流。注意到这是一张平面图，我们考虑建其对偶图求最短路即可。

这里需要说明的一点是，我从网上找到的一些资料，全部都只提到了将边旋转后建出图，但是实际上在有向图的情况下，这样的图的最短路并不一定就是最小割，因为最小割并不一定在对偶图上形成连续的一条路径。所以我们还需要将对偶图所有边建一条反向的边权为 $0$ 的边，此时对偶图的最短路才等于原图的最小割，即最大流。

建出对偶图：

![img](https://cdn.luogu.com.cn/upload/image_hosting/3vsbn890.png)

其中绿色边地边权对应着这一块有没有起点，其它的橙色边边权均为 $1$，且有反向 $0$ 的边权。

观察对偶图可以发现，中间的点也可以看作是拆点，然后可以向右、下、右下走。注意到向下、右走都可以走一条反边加一条正边，而向右下走至少经过两条边，所以此时向右下的边是没有意义的，所以我们实际上只会向下或向右。那么我们枚举在边框上的起点和终点，那么我们就能知道最短路了。由于在边框上走一定比在中间走更优，所以我们在中间部分一定只会往右或只会往下走，那么这样我们就只有 $O(n)$ 条路径需要判断了，直接判即可。最后判断最小割是不是等于 $k$ 即可。

---

## 作者：tzc_wk (赞：4)

首先先是一步很猛的操作——将三染色视作构造一个矩阵使得相邻元素相差 $1$ 且每个元素 $\bmod 3$ 的值就等于其颜色。证明是显然的，我们按从上到下从左到右的顺序填数，可以归纳证明，对于一个相邻格子颜色互不相同的矩阵的填数方案，处于斜对角的两个格子上写的数要么差 $2$，要么相等，这样待填的这个格子必然存在合法的待选值。

于是问题转化为是否存在合法的填数方案。我们先给边界上的元素确定值，如果边界上都没法做到相邻元素相差 $1$ 就直接似了。判完这个条件之后思考还有什么必要条件，显然边界上任意两个元素之间的差值不能超过它们的曼哈顿距离，否则的话对于任意一条它们之间的路径，必然存在两个元素相差 $\ge 2$。而这一部分的 check 其实只用考虑边界上相对的位置，即 $a_{1,i}$ 与 $a_{n,i}$，以及 $a_{i,1}$ 与 $a_{i,n}$。

这样是否充分了呢？答案是肯定的。考虑构造，$a_{i,j}=\max\{i-1+a_{1,j},n-i+a_{n,j},j-1+a_{i,1},m-j+a_{i,m}\}$。容易验证相邻元素相差不超过 $1$，并且根据黑白染色，中括号中四项的奇偶性都是相同的，也就是 $a_{i,j}$ 的奇偶性是随 $i+j$ 的奇偶性同步变化的。因此不会出现相邻元素相同的情况，符合条件。

评价：agc 全是脑洞题，一步想出来就会做，否则就不会/tuu


---

## 作者：strcmp (赞：0)

这题如果你做过 AGC052E，那么会相对容易得很多（虽然还是很难）。

对于三染色问题，我们有一种方法是构造到序列的映射。

这里我们需要构造的是数字矩阵，那么就直接设一个数字矩阵 $a$ 与原矩阵在模 $3$ 意义下同余，并且相邻格子的数字之差绝对值恰好为 $1$。我们只要钦定出一个格子的数字是什么，那么这就是一个双射，我们根据颜色关系构造偏序关系，并且按偏序关系标号即可（注意 $a$ 的范围是 $\mathbb N^+$ 而不是 $\{0,\,1,\,2\}$）。

这种东西构造出来就是为了方便我们找到一个构造的（想要知道为什么这样构造可以看一下 AGC052E）。

根据颜色的偏序关系，我们容易递推出来四个边上的 $a$ 应该是什么样子。

接下来给出两个条件：

- 构造出的 $a$ 必须两两之间相邻差绝对值恰好为 $1$。

- 边界上任意两个 $a$ 元素之间的差值不能超过其曼哈顿距离。

显然条件一是必要的。

条件二的必要性也容易证明，如果两个元素之间的插值大于其曼哈顿距离，那么随便取一条两个元素之间的曼哈顿路，必定有相邻格子相差绝对值大于 $1$。

我们证明这个两个条件加起来是充分的，给出构造：

$$
a_{i,\,j} = \max\{ a_{i,\,1} - (j - 1),\,a_{1,\,j} - (i - 1),\,a_{i,\,n} - (n - j),\,a_{n,\,j} - (n - i)\}
$$

合法性：

1. 取一项放缩后显然相邻差不超过 $1$。

2. $a_{i,\,j}$ 奇偶性随 $i + j$ 的奇偶性变化而变化，相邻差不可能为 $0$。

直接递推出边界上的 $a$ 用充要条件判断，时间复杂度 $\Theta(n)$，可以通过。

这种题感觉就是没见过类似套路几乎不可做（至少是几乎不可能想到 std 做法）的东西，有点太恐怖了。

---

## 作者：DengDuck (赞：0)

感觉这个映射不像人类想得出来的...

感谢 FLAMEs_ 大神的指导，这下看懂了。

首先考虑映射，因为对于一个解的矩阵 $A$，颜色之间的关系是难以处理的，所以我们考虑转换成一个矩阵 $B$，使得：

$$
B_{i,j}\equiv A_{i,j}\pmod 3\\
|B_{x_1,y_1}-B_{x_2,y_2}|=1 (|x_1-x_2|+|y_1-y_2|=1)
$$

考虑我们已知 $x=1,y=1$ 的所有点，那么我们可以证明如果有 $A$ 的解此时一定恰好可以得到一个 $B$ 的解。

证明考虑手玩，我们先固定 $B_{1,1}$，然后剩下的所有项值都是固定的，稍微讨论讨论可以证明对于合法的三染色方案是有解的。

接下来考虑判定，结论是两边对应的格子 $(1,x),(n,x)$，和 $(x,1),(x,n)$ 的差不能超过 $n-1$。

证明它，首先是必要性，两个格子差不会超过曼哈顿距离，这点显然。

然后是充分性，如果满足这一条件，考虑构造 $B_{i,j}=\max(A_{i,1}-(j-1),A_{i,n}-(n-j),A_{1,j}-(i-1),A_{j,n}-(n-i))$，这个时候一定满足条件。

```cpp
#include<bits/stdc++.h> 
#define LL long long
#define Ls(x) T[x].Ls
#define Rs(x) T[x].Rs
using namespace std;
const LL N=2e6+5;
char C[N];
LL n,S[N];
void Work()
{
	scanf("%lld%s",&n,C+1);
	LL m=4*n-3;
	C[m]=C[1];
	for(int i=1;i<m;i++)
	{
		if(C[i]==C[i+1])
		{
			puts("NO");
			return;
		}
	}
	for(int i=2;i<=m;i++)S[i]=((C[i]-C[i-1]+4)%3-1)+S[i-1];
	
	for(int i=2;i<n;i++)
	{
		if(abs(S[i]-S[3*n-1-i])>=n)
		{
			puts("NO");
			return;
		}
	}
	for(int i=2;i<n;i++)
	{
		if(abs(S[n-1+i]-S[4*n-2-i])>=n)
		{
			puts("NO");
			return;
		}
	}	
	if(S[m]!=0)
	{
		puts("NO");
		return;
	}
	puts("YES"); 	
}
LL T;
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		Work();
	}

}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/AT_agc059_e)

**题目大意**

> 给定 $n\times n$ 矩阵 $C$，其最外圈的 $4n-4$ 个格子已经被 $3$ 染色，问中间部分能否 $3$ 染色。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

题目的限制我们可以看成一个 $n\times n$ 的矩阵 $A$，相邻元素差 $\in\{1,-1\}$，然后把这个矩阵 $\bmod 3$ 得到的结果。

对于最外圈的值，还原 $C\to A$ 是简单的：从任意一个点出发，邻居和他的 $+1/-1$ 关系是确定的。

如果这个环最终相邻元素差 $\ne 0$ 显然无解。

进一步的还有显然的限制：$|a_{i,j}-a_{u,v}|<|i-j|+|u-v|$。

对于这个问题，显然我们只要考虑对边上的两个点，并且只要考虑 $(a_{i,1},a_{i,n})$ 之间的关系，因为同一行的 $|a_{i,1}-a_{j,1}|<|i-j|$ 显然成立。

可以证明满足这两个条件后总能从外圈构造出合法矩阵：
$$
a_{i,j}=\max\{a_{1,j}-(i-1),a_{n,j}-(n-i),a_{i,1}-(j-1),a_{i,n}-(n-j)\}
$$
首先能够证明 $a_{i,j}$ 在四个边界上取值不变。

然后对于任意两个邻居，容易发现每个元素变化量 $\in[-1,1]$ 且奇偶性全部变化。

那么可以证明相邻两个数差一定 $\in\{-1,1\}$。

因此只要判断能否成环和对边是否满足条件。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=8e5+5;
char s[MAXN];
int n,a[MAXN];
void solve() {
	scanf("%d%s",&n,s+1),s[0]=s[4*n-4];
	for(int i=1;i<=4*n-4;++i) {
		a[i]=a[i-1]+((s[i]-s[i-1]+1)%3?1:-1);
	}
	for(int i=2;i<n;++i) if(abs(a[n-1+i]-a[4*n-2-i])>=n||abs(a[i]-a[3*n-1-i])>=n) return puts("NO"),void();
	puts(a[4*n-4]?"NO":"YES");
}
signed main() {
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---


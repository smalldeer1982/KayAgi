# [AGC061B] Summation By Construction

## 题目描述

有一个图，左侧有 $N$ 个顶点 $v_1,\ \ldots,\ v_N$，右侧有 $N+1$ 个顶点 $u_1,\ \ldots,\ u_{N+1}$。每个顶点 $v_i$（$1 \leq i \leq N$）都与每个顶点 $u_j$（$1 \leq j \leq N+1$）相连。也就是说，这个图共有 $N(N+1)$ 条边。

现在要用 $N$ 种颜色 $1,\ldots,N$ 给每条边染色。对于每个 $k=1,\ldots,N$，如果颜色 $k$ 的边恰好有 $2k$ 条，并且这些边构成一条简单路径，则称这种染色方式是**合适的**。

形式化地说，对于每个 $k=1,\ldots,N$，存在一列互不相同的顶点 $w_0,\ldots,w_{2k}$，满足以下所有条件时，染色方式是合适的：

- 对于每个 $i=0,\ldots,2k-1$，顶点 $w_i$ 和 $w_{i+1}$ 之间有一条颜色为 $k$ 的边。
- 没有其他颜色为 $k$ 的边。

请你找出一种合适的染色方式，或者判断不存在合适的染色方式。

对于每个输入文件，需要解答 $T$ 个测试用例。

## 说明/提示

### 限制

- $1 \leq T \leq 100$
- $1 \leq N \leq 100$

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
1
2```

### 输出

```
Yes
1 1
No```

# 题解

## 作者：pjykk (赞：3)

$n$ 为偶数时的更加简单粗暴的做法。

卡了一车人的题，着实抽象。

题目大概是说，对完全二分图 $K_{n,n+1}$ 的每条边染色 $1,2,\cdots,n$ 使得所有颜色为 $i$ 的边恰构成长度为 $2i$ 的链（不能经过重复顶点）。

首先容易发现这个东西当 $n$ 是奇数和 $n$ 是偶数的时候性质不是很一样。我们也分两种情况讨论。

### 1. n 为奇数

容易发现，颜色为 $n$ 的边的染色方式已经固定了。

以 $n=5$ 为例：（用邻接矩阵表示，横行为左部点，竖列为右部点）

$$\begin{bmatrix}
 5 & 5 &  &  & &\\
  & 5 & 5 &  & &\\
  &  & 5 & 5 & &\\
  &  &  & 5 & 5&\\
  &  &  &  &5&5
\end{bmatrix}$$

容易想到仿照 $5$ 的填法填剩下的数字。具体的构造像下面这样：

$$
\begin{bmatrix}
 5 & 5 & 4 & 4 &3 &3&|&&&&\\
  & 5 & 5 & 4 & 4&3&|&3&&&\\
  &  & 5 & 5 & 4&4&|&3&3&&\\
  &  &  & 5 & 5&4&|&4&2&2&\\
  &  &  &  &5&5&|&1&1&2&2
\end{bmatrix}
$$

当然右边多出来的部分要循环填到左边。

因为 $5=4+1=3+2$ 这样的式子，对于更大的奇数可以用同样的方法构造。

### 2. n 为偶数

显然 $n=2$ 无解。我们考虑 $n=4$ 怎么做。

首先颜色为 $n$ 的边的染色方式还是固定的：

$$\begin{bmatrix}
 4 &4 &  &  &\\
  & 4 & 4 &  &\\
  &  &4 & 4 &\\
  &  &  & 4 & 4
\end{bmatrix}$$

然后就不好填了。

注意到这样一个事情，像这样先右再下的折线表示的是从右部点开始，相对地先下再右的折线表示的是从左部点开始。

因为 $n$ 为偶数，原图中左部点的度数都是奇数，而右部点的度数都是偶数。

而每次加上一条路径的时候，只会使路径的两个端点的奇偶性发生变化。实际上因为路径的长度为偶数，只会使属于相同部分的两个点的奇偶性同时发生变化。

这样，已经染完了颜色为 $n$ 的边，而它是从右部点回到右部点的，为了使得度数满足要求，我们需要再找一条这两个点之间的路径，让它们的度数重新变回偶数；之后就不要再连右部点到右部点的路径了。

遵循这样的思路，并参考 $n$ 为奇数的情况可以找到这样一种构造：

$$\begin{bmatrix}
 4 &4 &  &  &\red{2}\\
 \red{1} & 4 & 4 &  &\red{1}\\
  \red{2}& 3 &4 & 4 &\red{2}\\
  \red{2}& 3&3& 4 & 4\\
  -&-&-&-&-\\
  &&3&3&\\
  &&&3&
\end{bmatrix}$$

这个构造也是能推广到所有 $\geqslant 4$ 的偶数的。

为了让规律更加明显，下面列出 $n=8$ 时的构造：

$$
\begin{bmatrix}
 8 & 8 &  &  &  &  &  &  &\red{2} \\
 \red{1} & 8 & 8 &  &  &  &  &  &\red{1} \\
 \red{2} & 7 & 8 & 8 &  &  &  &  &\red{2} \\
 6 & 7 & 7 & 8 & 8 &  &  &  & \\
 6 & 6 & 7 & 7 & 8 & 8 &  &  & \\
 5 & 6 & 6 & 7 & 7 & 8 & 8 &  & \\
 5 & 5 & 6 & 6 & 7 & 7 & 8 & 8 & \\
 \red{2} & 5 & 5 & 6 & 6 & 7 & 7 &  8&8 \\
 - & - & - & - & - & - & - & - & -\\
  &  & 5 & 5 & 6 & 6 & 7 & 7 & \\
  &  &  & 5 & 5 & 6 & 3 & 7 & \\
  &  &  &  & 5 & 4 & 3 & 3 & \\
  &  &  &  &  & 4 & 4 & 3 & 3\\
  &  &  &  &  &  & 4 & 4 & 3\\
  &  &  &  &  &  &  & 4 & 4\\
  &  &  &  &  &  &  &  &4
\end{bmatrix}
$$

只是特殊处理了 $1,2$， 应该还算比较美观，没有那么抽象。

结合两种情况，时间复杂度 $O(Tn^2)$，做完了！

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/AT_agc061_b)

**题目大意**

> 把一个 $K_{n,n+1}$ 的完全二分图分成 $n$ 条简单路径，第 $i$ 条长度为 $2i$。
>
> 数据范围：$n\le 100$。

**思路分析**

先考虑 $n$ 为奇数的情况。

在邻接矩阵上划分路径，我们可以构造出得到如下的阶梯型结构：

![](https://s21.ax1x.com/2024/04/16/pFx0yXF.png)

我么可以把这个 $n\times (n+1)$ 的网格划分成 $\dfrac{n+1}2$ 个长度为 $2n$ 的阶梯。

把每个阶梯拆成大小为 $(1,n-1),(2,n-2),(3,n-3),(4,n-4),\dots$ 的两个子阶梯即可。

然后考虑 $n$ 是偶数的情况，此时依然要划分阶梯的话就要考虑纵向划分：

![](https://s21.ax1x.com/2024/04/16/pFxBANn.png)

我们能划分成一个长度为 $n$ 的阶梯，一个长度为 $n-1$ 的阶梯，还有 $\dfrac{n}2-2$ 个长度为 $n+1$ 的阶梯。

把这些长度为 $n+1$ 的阶梯划分成 $(3,n-2),(4,n-3),\dots$ 的两个子阶梯即可。

剩下的六个空位放 $1,2$ 即可。

时间复杂度 $\mathcal O(n^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=105;
int g[MAXN][MAXN];
void solve() {
	int n;
	scanf("%d",&n);
	if(n==2) return puts("No"),void();
	puts("Yes");
	if(n&1) {
		for(int i=0;i<n;++i) g[i][i]=g[i][i+1]=n;
		for(int x=1;x<=n/2;++x) for(int i=0;i<n;++i) {
			g[i][(i+2*x)%(n+1)]=g[i][(i+2*x+1)%(n+1)]=(i<x?x:n-x);
		}
	} else {
		for(int i=0;i<n;++i) g[i][i]=g[i][i+1]=n;
		for(int i=1;i<n;++i) g[(i+1)%n][i]=g[(i+2)%n][i]=n-1;
		for(int x=3;x<=n/2;++x) for(int i=0;i<=n;++i) {
			g[(2*x+i-3)%n][i]=g[(2*x+i-2)%n][i]=(i<x?x:n+1-x);
		}
		g[1][0]=g[1][n]=1,g[0][n]=g[2][0]=g[2][n]=g[n-1][0]=2;
	}
	for(int i=0;i<n;++i,puts("")) for(int j=0;j<=n;++j) printf("%d ",g[i][j]);
}
signed main() {
	int T;
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：苹果蓝17 (赞：1)

对 $n$ 的奇偶性进行讨论。

### Part 1 $n$ 为奇数

考虑每个点作为链头或链尾的次数奇偶性，则左侧的点均为偶，右侧的点均为奇。猜想存在一种构造方案使得所有链均从右侧 $1$ 号点出发，到右侧的其它每个点结束。

先删去右侧的 $1$ 号点，变为所有链从左侧的每个点出发，到右边的每个点结束。

容易构造出以下方案：

```
5 5 3 3 1
4 5 5 3 3
4 4 5 5 3
2 4 4 5 5
2 3 4 4 5
```

再考虑右侧 $1$ 号点的连接方式，显然奇数颜色连链尾，偶数颜色连链首即可：

```
5 5 3 3 1 1
4 5 5 3 3 4
4 4 5 5 3 3
2 4 4 5 5 2
2 3 4 4 5 5
```

于是 $n$ 为奇数的情况得到解决。

### Part 2 $n$ 为偶数

由样例可知 $n$ 为 $2$ 时无解，但是事实上 $n$ 为大于 $2$ 的偶数时都有解，可以手玩出 $n=4$ 的解：

```
4 4 3 2 3
1 4 4 2 2
3 3 4 4 2
1 3 3 4 4
```

仿照它来拓展，将最多的颜色放在中间，右上角每隔两个放一种颜色，这样会留出来一些空：

```
6 6 ? 4 ? 2 ?
? 6 6 4 4 2 2
? ? 6 6 4 4 2
? ? ? 6 6 4 4
? ? ? ? 6 6 4
? ? ? ? ? 6 6
```

左下角也每隔两个放一种颜色，并将链尾插到右上角的空里：

```
6 6 3 4 5 2 ?
5 6 6 4 4 2 2
5 5 6 6 4 4 2
3 5 5 6 6 4 4
3 3 5 5 6 6 4
? 3 3 5 5 6 6
```

最后两个未填的位置分别在左下角和右上角。将次多的颜色的链首移到链尾，再填上颜色 $1$ 即可：

```
6 6 3 4 5 2 5
1 6 6 4 4 2 2
5 5 6 6 4 4 2
3 5 5 6 6 4 4
3 3 5 5 6 6 4
1 3 3 5 5 6 6
```

这样 $n \geq 4$ 的情况都构造出了解，于是 $n$ 为偶数的情况得到解决。

总时间复杂度 $O(Tn^2)$。

[**Code**](https://atcoder.jp/contests/agc061/submissions/38846774)

---


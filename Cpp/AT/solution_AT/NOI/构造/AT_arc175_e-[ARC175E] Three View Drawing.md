# [ARC175E] Three View Drawing

## 题目描述

将一个边长为 $N$ 的立方体，分割成 $N^3$ 个边长为 $1$ 的小立方体，并从中选出 $K$ 个。请构造一种选择方式，使得无论从立方体的三个互相垂直的方向中的哪一个方向观察，所选的 $K$ 个小立方体都能被全部看到，并且从每个方向看到的形状完全相同。

为了严格地形式化问题，将分割后的每个小立方体对应为一个整数三元组 $(x_i, y_i, z_i)$。

请构造并输出满足以下条件的 $K$ 个整数三元组 $(x_i, y_i, z_i)$：

- $0 \leq x_i, y_i, z_i < N$
- $\left\lbrace (x_i, y_i) \mid 1 \leq i \leq K \right\rbrace = \left\lbrace (y_i, z_i) \mid 1 \leq i \leq K \right\rbrace = \left\lbrace (z_i, x_i) \mid 1 \leq i \leq K \right\rbrace$
- 上述集合包含 $K$ 个元素。也就是说，对于 $i \neq j$，有 $(x_i, y_i) \neq (x_j, y_j)$。

对于任意满足限制条件的输入，均保证存在满足条件的解。

## 说明/提示

### 限制

- 输入的数值均为整数
- $1 \leq N \leq 500$
- $1 \leq K \leq N^2$

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 3```

### 输出

```
0 0 0
1 1 1
2 2 2```

## 样例 #2

### 输入

```
2 4```

### 输出

```
0 0 1
0 1 0
1 0 0
1 1 1```

## 样例 #3

### 输入

```
1 1```

### 输出

```
0 0 0```

# 题解

## 作者：EuphoricStar (赞：5)

下文令 $m$ 为原题面的 $k$。

题目条件很奇怪，考虑有没有什么比较好用的策略。

发现对于任意一个三元组 $(a, b, c)$，其中 $a, b, c$ 不全相等，那么同时添加 $(a, b, c), (b, c, a), (c, a, b)$，$\{(x_i, y_i)\}, \{(y_i, z_i)\}, \{(z_i, x_i)\}$ 三个集合都会同时添加 $(a, b), (b, c), (c, a)$。特别地，对于三元组 $(a, a, a)$，添加它后三个集合都会同时添加 $(a, a)$。所以如果原来的合法，那么添加后也合法。

所以考虑找出尽可能多组 $\{(a, b, c), (b, c, a), (c, a, b)\}$。发现可以直接令 $a + b + c \equiv 0 \pmod n$。这样若 $n \bmod 3 = 0$，除了 $(0, 0, 0), (\frac{n}{3}, \frac{n}{3}, \frac{n}{3}), (\frac{2n}{3}, \frac{2n}{3}, \frac{2n}{3})$，其他 $n^2 - 3$ 个 $(a, b, (-a - b) \bmod n)$ 都恰好在一个“组”内。若 $n \bmod 3 \ne 0$，除了 $(0, 0, 0)$，其他 $n^2 - 1$ 个 $(a, b, (-a - b) \bmod n)$ 都恰好在一个“组”内。

所以一个想法是把 $m$ 分成 $3 \left\lfloor\frac{m}{3}\right\rfloor$ 和 $m \bmod 3$ 两部分，前者就直接取 $\left\lfloor\frac{m}{3}\right\rfloor$ 组 $(a, b, c), (b, c, a), (c, a, b)$，后者就取 $m \bmod 3$ 组 $(a, a, a)$。

但是你发现你在 $n \bmod 3 \ne 0$ 且 $m \bmod 3 = 2$ 的时候寄了，因为此时形如 $(a, a, a)$ 的三元组只有一个 $(0, 0, 0)$，但是上面的方法需要 $2$ 个。发现此时 $m \le n^2 - 2$，所以可以直接把一组 $(a, b, c), (b, c, a), (c, a, b)$ 拆掉，比如拆 $(1, 1, (-2) \bmod 3)$，把它变成 $(1, 1, 1)$ 即可。

[code](https://atcoder.jp/contests/arc175/submissions/51769673)

---

## 作者：int08 (赞：3)

## 前言

My first black，最后还是构造，搞了个跟别人都不一样的做法，反正是过了 awa。

"[_Little, Love, Lit_](https://music.163.com/#/song?id=2087439517)"
# Solution
先说，由样例得：**本题不考虑重力要素。**

题意中说：三视图中均没有两个小正方体相互遮挡，那么换句话说在俯视图里每一个位置最多只能在某个高度放置一个，下文就以这种方式来表达铺设方案（记第 $i$ 行第 $j$ 列放置的正方体高度为 $a_{i,j}$）。

由于个人习惯，坐标从 $1$ 开始。

引入：

使用最少的立方体使得三视图都是 $2\times 2$ 的正方形。

看起来要用 $6$ 个，实际上只需要 $4$ 个（使用上文的表示方法）：

|1|2|
|:-:|:-:|
|2|1|

那么类似的扩展到 $n\times n$ 的时候，其实也只需要 $n^2$ 个，比如说 $3\times 3$ 的形如：

|1|2|3|
|:-:|:-:|:-:|
|2|3|1|
|3|1|2|

容易观察到，填成一个**拉丁方**就满足条件。

不过这样只能完成 $k$ 为平方数的情况，不是平方数的时候需要加以修改。

如果添加，只能添加一个 $(n,n,n)$，就加不动了。

但是考虑删除，发现只有当 $a_{i,i}=i$（这里还是上文表达方式）的时候可以删除且不会影响答案。

但是这样最多只能删除 $n$ 个，但是 $n^2-(n-1)^2=2n-1$，说明删除没啥前途（迫真）。

还是考虑增加，我们就发现了一个美丽的增加方式（假设当前已经填好了 $n\times n$ 并且 $a_{i,i}=i$）。

1. 把 $a_{i,i}$ 改为 $n+1$；
2. 把 $a_{n+1,i},a_{i,n+1}$ 改为 $i$。

这样正好增加了两个，不影响正确性，配合上前面添加一个 $(n+1,n+1,n+1)$ 的方案正好能覆盖所有情况。

现在的唯一难题就是如何构造 $a_{i,i}=i$ 的拉丁方了。

1. $n$ 为奇数：
$a_{i,j+1}=(a_{i,j}-1 )\text{ mod }n$，以 $n=5$ 举例：



|1|5|4|3|2|
|:-:|:-:|:-:|:-:|:-:|
|3|2|1|5|4|
|5|4|3|2|1|
|2|1|5|4|3|
|4|3|2|1|5|

2. $n$ 为偶数：上面这样的简单移动的构造方案消失了，我用的方案是先把对角线填好，然后从小到大填数字，然后每个数字从对角线下一行开始一个一个找，找到第一个能填的位置就填了跳到下一行从这里开始继续往后找。



|1|3|4|2|
|:-:|:-:|:-:|:-:|
|4|2|1|3|
|2|4|3|1|
|3|1|2|4|

不会证明，但是过了，就假设它是对的吧。

复杂度 $O(n^3)$ 喜提全场最劣。

哦对了，由于 $n=2$ 时候不存在满足上文条件的拉丁方，所以 $4\le k \le 8$ 时候特判。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 505
int an[N][N],used[N][N],n,k,i,j;
int main()
{
	cin>>n>>k;n=sqrt(k);
	if(k<=5&&k>=4)
	{
		cout<<"0 0 0\n";
		cout<<"0 1 1\n";
		cout<<"1 0 1\n";
		cout<<"1 1 0\n";
		if(k==5) cout<<"2 2 2\n";
		return 0;
	}
	if(k<=8&&k>=6)
	{
		cout<<"0 1 2\n";
		cout<<"0 2 1\n";
		cout<<"1 0 2\n";
		cout<<"1 2 0\n";
		cout<<"2 0 1\n";
		cout<<"2 1 0\n";
		if(k>=7) cout<<"0 0 0\n";
		if(k>=8) cout<<"1 1 1\n";
		return 0;
	}
	if(n%2==0)
	{
		for(i=1;i<=n;i++) an[i][i]=i,used[i][i]=1;
		for(i=1;i<=n;i++)
		{
			int hp=i%n+1,lp=hp%n+1;
			while(hp!=i)
			{
				while(an[hp][lp]||used[lp][i]) lp=lp%n+1;
				an[hp][lp]=i,used[lp][i]=1;
				hp=hp%n+1;
			}
		}
	}
	else
	{
		for(i=1;i<=n;i++) an[i][i]=i,used[i][i]=1;
		for(i=1;i<=n;i++)
		{
			int hp=i%n+1,lp=(i+1)%n+1;
			while(hp!=i)
			{
				an[hp][lp]=i,used[lp][i]=1;
				hp=hp%n+1,lp=(lp+1)%n+1;
			}
		}
	}
	int rest=k-n*n;
	if(rest%2==1) cout<<n<<" "<<n<<" "<<n<<endl,rest--;
	rest/=2;
	for(i=1;i<=rest;i++) an[n+1-i][n+1-i]=n+1,cout<<n-i<<" "<<n<<" "<<n-i<<endl,cout<<n<<" "<<n-i<<" "<<n-i<<endl;
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			cout<<i-1<<" "<<j-1<<" "<<an[i][j]-1<<endl;
	return 0;
}
```

# The End.

---

## 作者：ZR_BL (赞：2)

尝试寻找一种方式使三视图相同：坐标 $(x,y,z)$，对三个面的贡献分别是 $(x,y)$，$(y,z)$，$(z,x)$。所以同时加入 $(x,y,z)$，$(y,z,x)$，$(z,x,y)$ 可以使三视图相同。

如何获得 $n^2$ 个这样的三元组？\
我们进行如下的构造：选取满足 $x+y+z \equiv 0 \bmod n$ 的三元组 $(x,y,z)$。

可以枚举 $x$ 和 $y$ , $z$ 在 $\bmod n$ 下是确定的 ($z \equiv (-x-y) \bmod n$)，因此存在 $n^2$ 个这样的三元组。

>证明：所选的 $n^2$ 个三元组互不遮挡。
>
>对于任意两个有序三元组，当且仅当存在两个以上的元素相同时会被遮挡。
>
>设 $x$ 相同的两个三元组 $(x_1,y_1,z_1)$，$(x_1,y_2,z_2)$。
>
>其满足 $y_1+z_1 \equiv y_2+z_2 \bmod n$。
>因为 $y$ 互不相同，所以 $z$ 也互不相同。
>
>因此，所选的 $n^2$ 个三元组互不遮挡。

我们可以将这 $n^2$ 个三元组分成两类。具体而言，将满足 $x=y=z$ 的分成一类，其余的分成另一类。

考虑第一类有哪些三元组。当 $n$ 不整除 $3$，有 $(0,0,0)$；当 $n$ 整除 $3$，有 $(0,0,0)$，$(\frac{1}{3}n,\frac{1}{3}n,\frac{1}{3}n)$，$(\frac{2}{3}n,\frac{2}{3}n,\frac{2}{3}n)$。

最基础的想法是将 $x=y=z$ 的与其它情况分开，取 $3 \times\lfloor \frac{k}{3} \rfloor$ 组不全相等的，取 $k \bmod 3$ 组全相等的。

但存在特例，即当 $n$ 不整除 $3$ 且 $k \equiv 2 \bmod 3$ 时少了一组 $x=y=z$ 的情况。可以发现 $k \leq n^2-2$，因此可以直接拆掉一组 $(x,x,z)$，$(x,z,x)$，$(z,x,x)$ 使其变为 $(x,x,x)$。

~~作者太菜了，看了题解才会。~~

---

## 作者：haochengw920 (赞：2)

提供一个不同的解法。

考虑转换题意，题目的意思就是输出一个三视图相同的图形，并且三视图中没有遮挡。

- 考虑 $k=n^2$ 的 $sub$ ，考虑到如果有结果那肯定是 **满秩** 的，于是只用考虑第二个条件。

  于是进一步转换条件——每一行没有同一高度的，每一列没用同一高度的，一个行列坐标只能选一个…这不就是拉丁方块吗？

  于是这就完成了——生成一个 $n \times n$ 的拉丁方块，必然是满足条件的。

- 但是可惜 Atcoder 没有部分分。我们考虑对于任意 $m=n^2-k|m\in[0,n^2]$ ，我们沿用第一个 $sub$ 的思路，因为第二个限制和拉丁方块的条件是等价的。

  我们考虑要少选 $m$ 个点，转换到三视图里满秩的基础下，只要扣掉一个角就行了。

  以把坐标更大的角扣掉为例：

  ![](https://cdn.luogu.com.cn/upload/image_hosting/hbtatudg.png) 

  如果 $m$ 是偶数的话右下角填个 $(n,n,n)$ 就行了，如果 $m>2n-1$ 的话删个几列就行了。

  考虑怎么填数：这个可以手玩一下，发现如果从左边开始填是困难的，因为右边和下面的限制更多。于是从右边开始填，右上角填 $1$ ，然后按对角线填。

  可以证明这肯定是正确的，可以自己想一下。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/ksg7cubt.png) 

  写法上有点细节，稍微处理一下，下面代码做参考（可能有点丑）。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN = 505;

int n, m, len;
int a[MAXN][MAXN];

inline void Solve() {
	len = n; m = n * n - m;
	while (m >= 2 * len - 1) {
		for (int i = 1; i <= len; ++ i)
			a[i][len] = a[len][i] = -1;
		m -= 2 * len - 1; -- len;
	} 
	int tg = !(m & 1) * len; m >>= 1;
	for (int i = 0; i <= m; ++ i)
		a[len - i][len] = a[len][len - i] = -1;
	if (m == len - 1) -- len;
	int num = 1;
	for (int j = len; j; -- j)
		for (int t = 1; t <= len; ++ t) {
			int i = (t > j) ? t - j : len + t - j;
			if (!~a[i][j]) continue;
			int p1 = i - 1, p2 = j + 1;
			if (!p1) {
				p1 = len;
				if (!~a[p1][p2] && a[len][j] != a[p1 - 1][p2]) -- p1;
			}
			if (a[p1][p2] > 0) a[i][j] = a[p1][p2];
			else a[i][j] = num ++; 
		}
	if (tg) a[tg][tg] = tg;
//	puts("-------------------------");
//	printf ("%d\n", n);
//	for (int i = 1; i <= n; ++ i) {
//		for (int j = 1; j <= n; ++ j)
//			printf ("%d ", a[i][j]);
//		puts("");
//	}
//	puts("-------------------------");
	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= n; ++ j)
			if (~a[i][j])
				printf ("%d %d %d\n", i - 1, j - 1, a[i][j] - 1);
}

int main()
{
	scanf ("%d%d", &n, &m);
	Solve();
	return 0;
}
```

---

## 作者：Argon_Cube (赞：1)

[来个🤡解法。](https://atcoder.jp/contests/arc175/submissions/59255399)

以下令 $\mathbb N_n=\{x\in\mathbb N\mid 0\leq x<n\}$。

题目给的条件难以入手。先考虑 $k=n^2$ 时有没有什么好做法，尝试把 $n=3,k=9$ 的情况手玩出来，发现可以构造 $x=y=z$ 的 $3$ 个点和 $x,y,z$ 是 $0,1,2$ 全排列的 $6$ 个点。用 Desmos 画出来，发现其中有 $7$ 个点是共面的。这从代数上看是显然的，但是这给了我们启发：令 $S_a=\{(x,y,z)\mid x,y,z\in \mathbb N_n,x+y+z=a\}$，即斜面 $x+y+z=a$ 上的整点，显然如果没有遮挡那么选取若干个 $S_a$ 出来肯定是合法的。

考虑 $S_a$ 与 $S_b$ 不遮挡的充分条件，显然如果 $|a-b|\geq n$ 肯定是不会遮挡的。可以发现我们选取 $S_0,S_n,S_{2n}$ 即可构造出 $k=n^2$。显然我们最多只能选取三个 $S_a$，可以枚举一下，然后发现这个做法假了，连 $n=3,k=5$ 都构造不出来。

如果能把 $S_a$ 拆的更碎一点，这样能组合出来的数就更多了，会不会就可以了？考虑加一个和 $x+y+z$ 一样对称的条件，令 $S_{a,b}=\{(x,y,z)\mid x,y,z\in \mathbb N_n,x+y+z=a,\max(x,y,z)\leq b\}$，发现只要 $a_1<a_2-b$ 则 $S_{a_1,b_1}$ 与 $S_{a_2,b_2}$ 就不会遮挡，于是我们也尝试枚举最多三个 $S_{a,b}$，然后就过了。

喜提最劣解。

---

## 作者：WrongAnswer_90 (赞：0)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18382795)

### [[ARC175E] Three View Drawing](https://www.luogu.com.cn/problem/AT_arc175_e)

哎，构造。

首先考虑 $m=n^2$ 怎么做：显然是最上面一层填满第一条主对角线，第二层填满第二条主对角线...（主对角线指可以循环的对角线）。

把 $n$ 变成满足 $n^2\geq m$ 的最小的 $n$。然后考虑删去 $n^2-m$ 个。可以发现（谁能发现啊啊啊）在矩形的右下角删掉一个 `L` 型即可。如果 $n^2-m$ 是偶数则右下角的 $(n,n,n)$ 保留即可。

![image.png](https://s2.loli.net/2024/08/27/gA26SYvLmIab9Qu.png)

设 $x$ 表示 $L$ 的边长 $-1$（图中为 $4$）。上图是正方体的俯视图，把正方体从上到下分成 $1,2,3\dots n$ 层，某个位置填了 $x$ 代表这个的格子存在于第 $x$ 层。

首先对于暖色调的填法，可以发现这样对于前 $n-1-x$ 层，从正面和侧面看都是填满的，和俯视图是相同的。

对于紫色，这个位置填的是 $n$，正好对应了在第 $n$ 层只有最左边三个有值，符合俯视图。

对于冷色调的其他颜色，都在一个 $(n-1)\times(n-1)$ 的正方形里面填的，所以对于第 $(n-x)\sim(n-1)$ 层，每层从正面和右面看都是恰好 $n-1$ 个格子，也符合俯视图。

```cpp
int n,m,a[510][510];
vector<tup> ans;
inline void mian()
{
	read(n,m),memset(a,-1,sizeof(a));
	while((n-1)*(n-1)>=m)--n;
	m=n*n-m;
	if(!(m&1))ans.eb(tup(n-1,n-1,n-1));else --m;
	m>>=1,assert(m<n);
	for(int i=0;i+m+1<n;++i)for(int j=0;j<n;++j)a[j][(i-1-j+n)%n]=i;
	for(int i=0;i<n-1-m;++i)a[i][n-2-m-i]=n-1;
	for(int i=n-m-1;i<n-1;++i)for(int j=0;j<n-1;++j)a[j][(i-j+(n-1))%(n-1)]=i;
	for(int i=0;i<n;++i)for(int j=0;j<n;++j)if(a[i][j]!=-1)ans.eb(tup(i,j,a[i][j]));
	for(auto [x,y,z]:ans)write(x,' ',y,' ',z,'\n');
}
```

---

## 作者：Lynkcat (赞：0)

会 Steiner 三元系会的。

注意到对于 $n \bmod 6=1$ 或者 $3$ 的情况直接用 [Steiner 三元系](https://www.luogu.com/article/1vvf4wal) 构造出每个三元环，再加上 $n$ 个 ${i,i,i}$ 即可，对于 $k\not =n^2$ 的情况只要在 $k\bmod 3\not =0$ 的时候在后面加自环即可。

对于 $n \bmod 6=2$ 或 $4$ 的情况是上面的情况多了个孤立点 $n$，直接把 ${i,i,i}$ 全拆成 $\{i,i,n\},\{i,n,i\},\{n,i,i\}$ 即可。

对于 $n\bmod 6=0$ 的情况可以将 $n$ 除以三发现一定会变成上面的情况，因此分成三份后每份内部构造满了之后把剩下的完全三分图构造满即可。

只剩下了 $n \bmod 6=5$ 的情况，发现不是特别好构造，考虑把这种情况看成是两个孤立点，那么即使把其中一个构造满，还是会有 $<n$ 个 $k$ 构造不出来。

但是我们发现只要我们构造一个对角线上是 $1\sim n$ 的拉丁矩阵，那么这个就是一个合法的 $k=n^2$ 的方案并且只要把对角线一个个扣掉就分别对应 $k$ 是 $[n^2-n,n^2]$ 的所有解。

那么我们把剩下构造不出来的解用拉丁矩阵构造出来的解替代即可。

---


# [ARC189E] Straight Path

## 题目描述

在一个有 $N$ 个顶点的完全图 $G$ 的每条边上标上正整数编号，若满足以下条件，则称该完全图为“良好完全图”：

- 对于所有恰好经过 $N$ 个顶点各一次的路径，不存在一条路径使得其经过的边的编号按经过顺序排列后形成的数列是广义单调递增的。

请判断是否存在“良好完全图”。如果存在，请构造一个使“边上编号的最大值”最小的方案，并输出。

## 说明/提示

### 限制

- $2 \leq N \leq 20$

### 样例解释 1

例如，对于经过顶点 $2,5,1,4,3$ 的路径，经过的边的编号按顺序排列为 $(1,4,4,1)$，不是广义单调递增的。对于其它路径也不存在编号序列为广义单调递增的情况，因此该图满足条件。此外，对于 $N=5$，无法将“边上编号的最大值”降到 $3$ 以下，因此该输出是正确的。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5```

### 输出

```
Yes
2 1 4 4
4 3 1
1 3
2```

## 样例 #2

### 输入

```
2```

### 输出

```
No```

# 题解

## 作者：xxgirlxx (赞：8)

### 题外话
~~关注@[xxgirlxx](https://www.luogu.com.cn/user/1059074) 谢谢喵，关注@[xxboyxx](https://www.luogu.com.cn/user/473256) 谢谢喵~~

警示后人：前往不要对着样例猜结论，因为 $n=5$ 是特殊情况！！！

这题样例小的不对劲，听大佬@[Joker_Fish](https://www.luogu.com.cn/user/530468) 说是因为 AT 的 checker 只会暴力，不知道真的假的。

本来是第一篇题解的，可惜因为蒟蒻语文不好不会描述，第二天下午看了两位大佬的题解发现好深奥，蒟蒻完全看不懂 qwq。

本篇题解会把蒟蒻整个做题过程中的思路写出来的，相信各位大佬都能看懂！

~~废话怎么这么多，快上正片！~~
## 题目大意
给出一个 $n$ 个点的完全图（$2\le n\le 20$），请给每条边赋一个正整数边权，使得不存在一条走遍 $n$ 个点的路径，走的 $n-1$ 条边的边权单调不降。若无解，输出 `No`，否则输出 `Yes`，并输出构造方案，同时需要保证最大边权最小。
## 题目思路
首先不要看样例，AT 往样例里放的是一个特殊性质，害人不浅（蒟蒻看样例猜了个最大边权为 $n-1$ 的结论，手玩了一个小时的 $n=6$，最后发现除了 $n=5$ 和无解，最大边权都是 $3$）。

然后先手推 $n=4$ 的答案，你会发现是这个：

![](https://cdn.luogu.com.cn/upload/image_hosting/tt55dnst.png)

注意到一个特殊性质：我们使用了边权为 $1$ 的边将所有的点分成了 $2$ 个集合，然后在两个集合中间只用 $>1$ 的边权，这样的一个好处是我们肯定可以保证如果说想要有一条走遍所有点且边权单调不降，若 $n$ 为奇数，它只要走边权为 $1$ 的边的次数超过 $1$ 次就一定是不合法的路径，若 $n$ 为偶数，只要走了边权为 $1$ 的边就一定是不合法的路径，证明如下：

首先显然可以知道一个事情：若**只在**两个集合之间来回走**未走**的点，那么若想走遍所有点，只有两种情况：

第一种情况：两个集合内部点的数量一样。

第二种情况：两个集合内部点的数量差 $1$ 且起点在点更多的那个集合。

然后开始证明：

首先如果后面再走边权为 $1$ 的边显然不满足单调不降。所以我们要判断的就是若第一步走边权为 $1$ 的点是否可能是合法路径。如果第一步就走集合内的边，会变成两个集合内部点的数量差 $1$ 但起点在点更少的那个集合。这显然不能让我们通过只走集合之间的边走遍剩下所有点，这样最后会留下一个与现在所在的点处于同一集合的点（且是开始时那个点更多的集合），这显然需要走一个这个集合内部的边。这就导致第一步的边权是 $1$，但是你还需要在另一个集合内走一个 $1$，你就需要从这个集合走到另一个集合，就必定会使用一个集合之间的边，但是集合之间的边的边权是 $>1$ 的，与后面必定会产生的一个 $1$ 不满足单调不降，所以无解。但是为什么若 $n$ 为奇数是最多走 $1$ 次边权为 $1$ 的边呢？因为在奇数的情况下，我们可以将起点设在点多 $1$ 的那个集合中，这时我们走一条集合内部的点就会转化到偶数的情况，这就是为什么奇数可以走一次边权为 $1$ 的边。

然后我们考虑怎么连两个集合之间的点。

先考虑偶数的情况，由于一个集合中的每个点都跟另一个集合中的所有点有连边，所以中间的顺序是由两边集合的全排列交错放置得到的，即一个集合内的点可能以任何顺序被访问。所以我们希望存在某个东西，使得它必须被经过，但是一旦被经过就必定是无解的。因为需要必须被经过，所以肯定从点（数量未知）下手，要不合法就得从边上下手，且必定是三条边，使得中间比两边都大或都小。那么就有一个很好发现的东西：我们在两个集合中各选一个点，使得这两个点除了它俩的两边边权为 $2$，别的和它们相连的边的边权都为 $3$。这样我们就构造出了一种必须经过，但是经过有必定不合法的情况。因为我们边权为 $1$ 的边不能走，可以看作没有，边权为 $2$ 的边将剩下的点分成了四部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/np5r6pwn.png)

由于每个点都必须被经过，也就说明必定会出现走了 $3$ 之后走 $2$ 的情况，显然不合法，所以构造是正确的。

至于奇数，因为可以走一次边权为 $1$ 的边，也就是说可能会通过这个来规避掉上面的构造，解决方法也很简单：在点更多的那个集合里选择两个点就可以了。

最后特判一下 $n=2$ 和 $n=3$ 的无解（应该都知道吧）和 $n=5$ 的特殊情况（可以直接粘样例）就可以了。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	cin>>n;
	if(n<=3)cout<<"No";
	else{
		cout<<"Yes\n";
		if(n==5)cout<<"2 1 4 4\n4 3 1\n1 3\n2";
		else{
			if(n%2==0){
				for(int i=1;i<n/2;i++){
					for(int j=1;j<=n-i-n/2;j++)cout<<"1 ";
					for(int j=1;j<n/2;j++)cout<<"2 ";
					cout<<"3\n";
				}
				for(int i=1;i<n/2;i++)cout<<"3 ";
				cout<<"2\n";
				for(int i=n/2+1;i<n;i++){
					for(int j=1;j<=n-i;j++)cout<<"1 ";
					cout<<"\n"; 
				}
			}
			else{
				for(int i=1;i<n/2;i++){
					for(int j=1;j<n-n/2-i;j++)cout<<"1 ";
					for(int j=1;j<n/2;j++)cout<<"2 ";
					cout<<"3 3\n";
				}
				for(int i=1;i<n/2;i++)cout<<"3 ";
				cout<<"2 2\n";
				for(int i=n/2+1;i<=n;i++){
					for(int j=1;j<=n-i;j++)cout<<"1 ";
					cout<<"\n";
				}
			}
		}
	}
	return 0;
}
```
当然打表也是可以过的。
```cpp
#include<bits/stdc++.h>
using namespace std;
short n;
int main(){
	cin>>n;
	if(n==2)cout<<"No";
	else if(n==3)cout<<"No";
	else if(n==4)cout<<"Yes\n1 2 3\n 3 2\n1\n";
	else if(n==5)cout<<"Yes\n2 1 4 4\n4 3 1\n1 3\n2";
	else if(n==6)cout<<"Yes\n1 1 2 2 3\n1 2 2 3\n3 3 2\n1 1\n1\n";
	else if(n==7)cout<<"Yes\n1 1 2 2 3 3\n1 2 2 3 3\n3 3 2 2\n1 1 1\n1 1\n1\n";
	else if(n==8)cout<<"Yes\n1 1 1 2 2 2 3\n1 1 2 2 2 3\n1 2 2 2 3\n3 3 3 2\n1 1 1\n1 1\n1\n";
	else if(n==9)cout<<"Yes\n1 1 1 2 2 2 3 3\n1 1 2 2 2 3 3\n1 2 2 2 3 3\n3 3 3 2 2\n1 1 1 1\n1 1 1\n1 1\n1\n";
	else if(n==10)cout<<"Yes\n1 1 1 1 2 2 2 2 3\n1 1 1 2 2 2 2 3\n1 1 2 2 2 2 3\n1 2 2 2 2 3\n3 3 3 3 2\n1 1 1 1\n1 1 1\n1 1\n1\n";
	else if(n==11)cout<<"Yes\n1 1 1 1 2 2 2 2 3 3\n1 1 1 2 2 2 2 3 3\n1 1 2 2 2 2 3 3\n1 2 2 2 2 3 3\n3 3 3 3 2 2\n1 1 1 1 1\n1 1 1 1\n1 1 1\n1 1\n1\n";
	else if(n==12)cout<<"Yes\n1 1 1 1 1 2 2 2 2 2 3\n1 1 1 1 2 2 2 2 2 3\n1 1 1 2 2 2 2 2 3\n1 1 2 2 2 2 2 3\n1 2 2 2 2 2 3\n3 3 3 3 3 2\n1 1 1 1 1\n1 1 1 1\n1 1 1\n1 1\n1\n";
	else if(n==13)cout<<"Yes\n1 1 1 1 1 2 2 2 2 2 3 3\n1 1 1 1 2 2 2 2 2 3 3\n1 1 1 2 2 2 2 2 3 3\n1 1 2 2 2 2 2 3 3\n1 2 2 2 2 2 3 3\n3 3 3 3 3 2 2\n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	else if(n==14)cout<<"Yes\n1 1 1 1 1 1 2 2 2 2 2 2 3\n1 1 1 1 1 2 2 2 2 2 2 3\n1 1 1 1 2 2 2 2 2 2 3\n1 1 1 2 2 2 2 2 2 3\n1 1 2 2 2 2 2 2 3\n1 2 2 2 2 2 2 3\n3 3 3 3 3 3 2\n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	else if(n==15)cout<<"Yes\n1 1 1 1 1 1 2 2 2 2 2 2 3 3\n1 1 1 1 1 2 2 2 2 2 2 3 3\n1 1 1 1 2 2 2 2 2 2 3 3\n1 1 1 2 2 2 2 2 2 3 3\n1 1 2 2 2 2 2 2 3 3\n1 2 2 2 2 2 2 3 3\n3 3 3 3 3 3 2 2\n1 1 1 1 1 1 1 \n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	else if(n==16)cout<<"Yes\n1 1 1 1 1 1 1 2 2 2 2 2 2 2 3\n1 1 1 1 1 1 2 2 2 2 2 2 2 3\n1 1 1 1 1 2 2 2 2 2 2 2 3\n1 1 1 1 2 2 2 2 2 2 2 3\n1 1 1 2 2 2 2 2 2 2 3\n1 1 2 2 2 2 2 2 2 3\n1 2 2 2 2 2 2 2 3\n3 3 3 3 3 3 3 2\n1 1 1 1 1 1 1 \n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	else if(n==17)cout<<"Yes\n1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3\n1 1 1 1 1 1 2 2 2 2 2 2 2 3 3\n1 1 1 1 1 2 2 2 2 2 2 2 3 3\n1 1 1 1 2 2 2 2 2 2 2 3 3\n1 1 1 2 2 2 2 2 2 2 3 3\n1 1 2 2 2 2 2 2 2 3 3\n1 2 2 2 2 2 2 2 3 3\n3 3 3 3 3 3 3 2 2\n1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 \n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	else if(n==18)cout<<"Yes\n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3\n1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3\n1 1 1 1 1 1 2 2 2 2 2 2 2 2 3\n1 1 1 1 1 2 2 2 2 2 2 2 2 3\n1 1 1 1 2 2 2 2 2 2 2 2 3\n1 1 1 2 2 2 2 2 2 2 2 3\n1 1 2 2 2 2 2 2 2 2 3\n1 2 2 2 2 2 2 2 2 3\n3 3 3 3 3 3 3 3 2\n1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 \n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	else if(n==19)cout<<"Yes\n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3\n1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3\n1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3\n1 1 1 1 1 2 2 2 2 2 2 2 2 3 3\n1 1 1 1 2 2 2 2 2 2 2 2 3 3\n1 1 1 2 2 2 2 2 2 2 2 3 3\n1 1 2 2 2 2 2 2 2 2 3 3\n1 2 2 2 2 2 2 2 2 3 3\n3 3 3 3 3 3 3 3 2 2\n1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 \n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	else cout<<"Yes\n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3\n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3\n1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3\n1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3\n1 1 1 1 1 2 2 2 2 2 2 2 2 2 3\n1 1 1 1 2 2 2 2 2 2 2 2 2 3\n1 1 1 2 2 2 2 2 2 2 2 2 3\n1 1 2 2 2 2 2 2 2 2 2 3\n1 2 2 2 2 2 2 2 2 2 3\n3 3 3 3 3 3 3 3 3 2\n1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 \n1 1 1 1 1 1 \n1 1 1 1 1 \n1 1 1 1 \n1 1 1 \n1 1 \n1";
	return 0;
}
```

---

## 作者：Argon_Cube (赞：7)

虾头 Ad-Hoc 构造题/tuu

----

首先看到这个题面就能知道没什么很好的性质能找了，估计就是不找性质直接做一个较为简单的构造，所以也没有很好的思维链可循。

显然 $n<4$ 是无解的。样例给出了 $n=5$ 的最优解（这个样例很有用！），经过手玩我们可以得到 $n=4$ 的一组解：

```
2 1 3 
3 1 
2
```

在尝试了许久最大边权为 $2$ 的构造无果后（事实上官方题解用归纳法证明了最大边权至少为 $3$），我猜测最优解最大边权应当为 $3$。（$n=5$ 应该是一组 Corner Case。）$n=4$ 其实是很有启发性的，我们尝试将这个结构推广到全体偶数（以下令 $u<v$）：

* 若 $u\equiv v\pmod 2$，则 $(u,v)$ 边权为 $1$。
* 否则，若 $v=2$ 或 $u>2$，则 $(u,v)$ 边权为 $2$。
* 否则 $(u,v)$ 边权为 $3$。

可以发现，

* 边权为 $1$ 的边（以下称为 $1$ 边）构成了两个大小相等的团；剩下的边构成了一个二分图，称这个二分图为 $G_{2,3}$。
* 而其中边权为 $2$ 的边（称为 $2$ 边）构成了两个大小分别为 $2$ 和 $n-2$ 的完全二分图。称这两个二分图分别为 $G_{2(2)},G_{2(n)}$。
* 边权为 $3$ 的边（称为 $3$ 边）包含了所有 $G_{2(2)}$ 左部点（奇数点）与 $G_{2(n)}$ 右部点（偶数点）、$G_{2(2)}$ 右部点与 $G_{2(n)}$ 左部点之间的边。

构造正确性的证明：

* 我们迟早要经过一条边权大于 $1$ 的边，此后必须轮流经过 $G_{2,3}$ 的两边。那么可以发现如果一开始走了 $1$ 边，那么会有一边的点不够配对而无法走下去，所以边权不减的路径不能包含 $1$ 边。
* 我们一旦经过了 $3$ 边（而这是一定会发生的），我们就只能走 $3$ 边。此时 $G_{2(2)},G_{2(n)}$ 中一定有一个图的某一边没有被走到过，且以后都不可能被走到。所以边权不减的路径不存在。

最后我们需要处理 $n$ 为奇数的情况，容易想到从 $n$ 为偶数的情况拓展而来。可以给出这样一个方案：将点 $n$ 去掉然后按偶数做。然后将 $n$ 与所有 $2u+1$ 连 $1$ 边，$n$ 与 $2$ 连 $2$ 边，剩下的全部连 $3$ 边，可以理解为将多出来的点 $n$ 放进了 $G_{2(2)}$ 中。这个做法的正确性应该可以通过类似的讨论证明，需要讨论走了一条 $1$ 边的情况（显然这条 $1$ 边只可能连接两个编号为奇数的点）。

注意这个构造在 $n=5$ 时会失效，我们复制样例的构造即可。

这样我们就做完了这个抽象铜牌构造。

[Code.](https://atcoder.jp/contests/arc189/submissions/60636880)

---

## 作者：gdf_yhm (赞：2)

[arc189e](https://www.luogu.com.cn/problem/AT_arc189_e)

[my blog](https://yhddd123.github.io/post/arc189e-ti-jie/)

### 思路

$n\le 3$ 无解。$n=4$ 时 $(1,2),(3,4)$ 权值为 $1$，$(1,4),(2,3)$ 权值为 $2$，$(1,3),(2,4)$ 权值为 $3$。$n=5$ 时如样例。

证明 $mx=2$ 不合法。归纳，对于 $n-1$ 的 $p_1,\dotsb,p_{n-1}$ 使得 $mx=2$ 不合法，如果全同色，$n$ 可以加在最前或最后；否则找到分界点 $p_x$，$p_x$ 以前为 $1$，以后为 $2$，如果 $(p_x,n)$ 为 $1$，$p_1,\dotsb,p_x,n,p_{x+1},\dotsb,p_{n-1}$ 不合法，否则 $p_1,\dotsb,p_{x-1},n,p_x,\dotsb,p_{n-1}$ 不合法。

对于 $n>5$ 时 $mx=3$ 合法。将 $n$ 分为 $4$ 个集合 $X1,X2,X3,X4$，对应 $n=4$ 时的 $1,2,3,4$。集合内权值为 $3$，集合间权值为 $n=4$ 的权值。可能不合法的方案会要求连续在 $X1$ 和 $X2$ 间切换，再连续在 $X1$ 和 $X4$ 间切换，即 $|X1|\ge |X2|+|X4|$。其他一些可能不合法的情况也要求其中一个集合至少为另外两个集合之和。令 $|X1|\ge |X2|\ge |X3|\ge |X4|\ge |X1|-1$。但当 $n=5$ 时会寄，特判即可。

### code

```cpp
int n,e[21][21];
void work(){
	n=read();
	if(n<=3){puts("No");return ;}
	puts("Yes");
	if(n==5){
		cout<<"2 1 4 4\n4 3 1\n1 3\n2\n";
		return ;
	}
	int x1=n/4,x2=n/4,x3=n/4,x4=n/4;
	if(n%4)x1++;
	if(n%4>1)x2++;
	if(n%4>2)x3++;
	for(int i=1;i<=x1;i++){
		for(int j=1;j<=x1;j++)e[i][j]=3;
		for(int j=x1+1;j<=x1+x2;j++)e[i][j]=1;
		for(int j=x1+x2+1;j<=x1+x2+x3;j++)e[i][j]=3;
		for(int j=x1+x2+x3+1;j<=n;j++)e[i][j]=2;
	}
	for(int i=x1+1;i<=x1+x2;i++){
		for(int j=x1+1;j<=x1+x2;j++)e[i][j]=3;
		for(int j=x1+x2+1;j<=x1+x2+x3;j++)e[i][j]=2;
		for(int j=x1+x2+x3+1;j<=n;j++)e[i][j]=3;
	}
	for(int i=x1+x2+1;i<=x1+x2+x3;i++){
		for(int j=x1+x2+1;j<=x1+x2+x3;j++)e[i][j]=3;
		for(int j=x1+x2+x3+1;j<=n;j++)e[i][j]=1;
	}
	for(int i=x1+x2+x3+1;i<=n;i++){
		for(int j=x1+x2+x3+1;j<=n;j++)e[i][j]=3;
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++)cout<<e[i][j]<<" ";cout<<"\n";
	}
}
```

---


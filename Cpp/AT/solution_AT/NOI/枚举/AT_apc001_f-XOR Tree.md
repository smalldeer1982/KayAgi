# XOR Tree

## 题目描述

给一棵有 $N$ 个节点的树，节点编号从 $0$ 到 $N-1$，
树边编号从 $1$ 到 $N-1$。第 $i$ 条边连接节点 $x_i$ 和 $y_i$，其权值为 $a_i$。

你可以对树执行任意次操作，每次操作选取一条链和一个非负整数 $x$，将链上的边的权值与 $x$ 异或成为该边的新权值。

问最少需要多少次操作，使得所有边的权值都为 $0$。

## 说明/提示

- $2\leq N \leq 10^5$
- $0\leq x_i,y_i \leq N-1$
- $0\leq a_i \leq 15$
- 保证给定的图是一棵树
- 保证输入数据都是整数

## 样例 #1

### 输入

```
5
0 1 1
0 2 3
0 3 6
3 4 4```

### 输出

```
3```

## 样例 #2

### 输入

```
2
1 0 0```

### 输出

```
0```

# 题解

## 作者：shadowice1984 (赞：38)

看起来是个$NlogN$其实是个假的复杂度

知道为什么值域只有$15$这么小吗，因为要状压……

_____________________

题意简述:给定一棵树，边上有边权,你可以重复以下操作若干次，将$u,v$间路径上的所有边异或上同一个数x，求最小的操作次数，使得操作后所有边的边权都为0

那么我们发现直接对边权做手脚的话这题就有点不可做了

因为我们每一次操作都会修改$O(n)$条边的边权

所以我们考虑搞点奇技淫巧让这个边权变成点权

那么我们令每个点的点权为它周围一圈边(意会就好，这个概念不难理解)边权的异或和

现在让我们看看当我们给$u,v$上路经的边都异或一个权值x的时候，点权会发生什么变化

我们发现只有$u,v$的点权异或了一个x，其余的点的点权都不动……，因为如果这个点不是路径端点的话，左边的边被异或了一个x的同时右边的点也被异或上了一个x
这样的话这个点的点权是不动的……

现在的问题变成了给你一堆数字，每次可以挑两个数并让他们异或上同一个数字，求最小的异或次数使得所有数字变为0的操作次数

当然我们可以贪心了，如果存在两个相同的数字对，那么我们可以通过一次操作将这一对数字消去

那么我们重复这样的流程

最后最多剩下16个值互不相同的数字

那么这个时候我们不能贪心了，接下来该怎么做呢？

发现数字个数非常少，因此我们可以状压dp

那么具体来讲我们会发现一个这样的性质

一个数字的集合有解(也就是说可以用取两个数字异或上同一个数字将这个集合里的所有数字变成0)当且当这个数字集合的异或和为0

正确性显然，因为每次操作均不改变这个集合的异或和，所以如果一开始不是0的话是无论如何都消不成一个全零集合的

因此我们可以设$dp_{s}$表示将s这个集合全部变成0的最小操作次数

如果s的异或和不为0的话直接不计算这个东西的dp值，因为它不合法

否则的话我们认为$dp_{s}$有一个下界是这个集合s的size-1,(就是暴力的一个一个消成0)

那么转移呢？

我们发现可以如果我们能将这个集合拆成两个互不相交的子集，并且，我们拆出来的这两个子集的异或和都是0的话，我们就可以至少减少一次操作

所以转移就是枚举每个集合的子集然后进行转移，取一下min就好了

复杂度

$$\sum_{i=1}^{16}C_{16}^{i}2^i=(1+2)^{16}=3^{16}$$

总复杂度$O(3^{16}+N)$

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=2*1e5+10;
int w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N]; 
int main()
{
    scanf("%d",&n);
    for(int i=1,u,v,va;i<n;i++){scanf("%d%d%d",&u,&v,&va);w[u]^=va;w[v]^=va;}
    for(int i=0;i<n;i++){cnt[w[i]]++;}//贪心 
    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);	
    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);
    for(int i=1;i<(1<<15);i++)d[i]-=1;//预处理每个dp值的下界 
    for(int i=1;i<(1<<15);i++)
        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);//预处理集合的异或和 
    for(int i=1;i<(1<<15);i++)//枚举子集进行转移 
    {
        if(sxr[i]!=0)continue;
        for(int k=(i-1)&i;k;k=(k-1)&i)
            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);
    }printf("%d",res+d[st]);return 0;
}
```

---

## 作者：Z1qqurat (赞：8)

重新站在一个思路更自然的角度来看待这个题。Ad-Hoc 题你要是做完还觉得这题很不自然那你就相当于浪费了这个题好吧。

1. 发现对路径操作看起来非常地不可做，因为你不知道一条边要操作个几次才行，此时想到一种经典套路：点边互换。（这种套路有时候体现在网络流或者一些其他图论问题中，用于将点和边的关系对调，从而找到一些新的限制或者简化条件，也有可能是借助新图限制优化复杂度，这是一种线图的技巧）当然，在这里我们实际上做的是点权和边权的互相转化，有点儿像圆方树，准确地说也是一种树上差分的做法，设一个点的点权为与它相连的所有边的边权异或和。

   这么做了之后发现了什么？首先路径操作变为对路径的两个端点异或同一个值；最终要求的边权都为 $0$，其实就等价于点权都为 $0$，这是容易证明的，考虑从叶子节点往上推，叶子节点的点权为 $0$ 就说明它到父亲的边权为 $0$，那么它的父亲也会发现同样的结论，最终整个树边权都为 $0$ 了。

   接下来问题得到了大幅的简化：树有点权，每次取两个点同时异或上一个值，求最后使得所有点权都变为 $0$ 的最少操作次数。容易发现此时已经和树的形态毫无关联了！

   最终，其实就是有长为 $n$ 的序列 $a_{1\sim n}$，每次可以取其中两项同时异或上一个数，求使得 $a$ 变为全 $0$ 的最少操作次数。

2. 对着新的问题想一下，我们试着回归一次操作的本质。对于操作类问题多考虑操作前后的变化量和不动点，这个题要求最小化操作次数，那必然从变化量入手（不动点一般在一些维护操作后信息的时候比较管用吧）。发现一次操作之后，至多使得操作的两项由非 $0$ 变为 $0$，前提是这两项相等；否则我们至少也会将所选的两项中一项变成 $0$，否则这次操作就没有意义了。

   这么看，我们就是尽量要使得每次操作都可以消除两个非 $0$ 项，容易想到让权值相同的项都两两配对，这样一次操作的贡献一定是最多的。那么最后我们就至多剩下每种权值的点各一个了。
   
   此时发现有一个条件：边权 $\le15$，由异或的性质发现 $a_i\le15$，这时候就是说权值为 $1\sim15$ 的点每种都至多只剩下一个了（$0$ 直接忽略掉）。

3. 这时候感觉啥复杂度的做法都能过啊。考虑一个集合 $S$ 内的元素全部消成 $0$ 至多 $|S|-1$ 次即可，就是顺次拿两个操作。$|S|-1$ 是我们按照每次只能消掉一个元素的情况估计的，但是是否存在某次操作消掉了两个元素？假如操作顺序中，有一个前缀内元素的异或和 $=0$，那么这个前缀的最后一次操作就消掉了两个元素，就可以省掉消该前缀最后一个元素的那次操作。这启发我们想到这样一种 dp，设 $f(S)$ 表示将集合 $S$ 消完的最小操作次数，初始值为 $f(S)=|S|-1$，如果存在子集 $T_0,T_1$ 使得 $T_0\cup T_1=S,T_0\cap T_1=\varnothing$，且 $T_0,T_1$ 分别的元素异或和都是 $0$，那么 $f(S)\gets f(T_0)+f(T_1)$。此时枚举子集就可以做到 $\mathcal{O}(3^V),V=15$。这部分的正确性就和高位前缀和啥的一样吧。

回顾这个题，感觉每一步如果细想都很自然（总结一下几个比较关键的点：

1. 不好做的树上路径问题采用树上差分，把路径变成点。
2. 操作类问题，如果是要求最小化操作次数可以考虑变化量，通过最大化一次操作的变化量来最小化操作次数；如果是维护操作前后的信息，可以考虑寻找不动点（不变量），借助不动点性质维护操作信息。

这么想的话这个题是不是得自己做出来才对。

[Submission.](https://atcoder.jp/contests/apc001/submissions/53435150)

Bonus：考虑转化为点权后的形式。

* 如果不限制每次异或的数个数，咋做？
* 如果强化一下上面的条件，变成一个序列问题，然后每次只能操作一个区间？（感觉可以用区间 dp 做到一个很劣的复杂度。。。） 

会做的老哥能不能教教我/kel

---

## 作者：zac2010 (赞：5)

不妨采用一种常见的套路：我们把每个点的点权定义为它周围边的边权异或和。那么修改一条路径就转化为了修改两个点，最终的答案就是让所有点的点权都为 $0$。

我们难以找到直接贪心的策略。但 $0\leq a_i\leq 15$，考虑对于每种权值进行状压——先把权值相同的点两两消掉。在此之后，每种权值的点只可能出现一次。于是状压 $\text{DP}$ 的起始状态就确定了。

考虑转移，每次选择两个点，修改的权值必定是其中之一（否则肯定不优），且不管修改其中的哪个，最终剩下的都会是他俩的异或和。这样转移就能唯一确定了。

最终直接查询状态 $0$ 的值就行了。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 1e5 + 10, S = 1 << 16;
int n, r, x, y, w, sum, a[N], f[S];
void cmin(int &x, int y){x = min(x, y);}
int main(){
    scanf("%d", &n);
    FL(i, 2, n){
        scanf("%d%d%d", &x, &y, &w);
        a[x + 1] ^= w, a[y + 1] ^= w;
    }
    FL(i, 1, n) if(a[i]) sum += (r >> a[i]) & 1, r ^= 1 << a[i];
    memset(f, 0x3f, sizeof(f));
    f[r] = sum;
    FR(s, r, 0) FL(i, 1, 15) if(s & (1 << i))
        FL(j, 1, 15) if(i != j && (s & (1 << j)))
            cmin(f[s ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j))], f[s] + 1 + ((s >> (i ^ j)) & 1));
    printf("%d\n", f[0]);
    return 0;
}
```


---

## 作者：FyFive (赞：5)

### 简要题意

给一棵树，每次将一条树上简单路径中的所有边异或上一个相同的值，问最少操作多少次可以使得所有边权变为 $0$。

### 思路

直接对边权操作不大好搞，我们考虑转化。

首先很自然的就能想到边权转化为点权。因为是路径异或，转化为点权之后也许可以树上差分从而将路径上的所有修改转化为两个点的修改。

很自然的就能想到设计点权为与这个点相连的所有边的边权的异或和。这样，简单路径异或也就变成了两个端点异或上同一个值。

不难证明，在树上，这里的点权全为 $0$ 与边权全为 $0$ 互为充要条件。

考虑怎么让边权全为 $0$。首先不难想到，转化完成后答案与点在树上的位置无关，也就是说所有点权相等的点均为等价点，这样每次操作消掉两个等价的点一定很优。于是这样像连连看一样的两两相消会使得最后没有两个点等价，而值域只有 $15$，也就是说最后最多会剩下 $15$ 个点，因为值为 $0$ 的点自始至终不需要操作。那么考虑最后的 $15$ 该怎么写。

不难想到子集枚举。设计 $dp_S$ 表示消完集合 $S$ 中的所有数所需要的最小操作步数，那么剩余的点的答案即为 $dp_U$，转移有 $dp_S=\min(dp_T),T\in S$，这样子集枚举，复杂度为 $\displaystyle \sum_{i=1}^n C_n^i 2^i=(1+2)^n=3^n$，其中 $n$ 为剩余的点数。由于 $n\leq 15$，于是我们就通过了这道题。

---

## 作者：JK_LOVER (赞：4)

## 题意
给你一颗无根树，每条边有权值 $w_i$ ,可以选择一条简单路径，将路径上的边权 $xor$ 一个值。最后使所有边全部为 $0$ 。求最小次数 。
[QwQ](https://www.luogu.com.cn/blog/xzc/solution-at3913)
## 分析
- 如果我们直接对边权操作的话，不仅状态难以表示，而且贪心也可以很容易找到反例。这时候我们就需要改变一下思路。

- 如果只是简单的把到父亲的边映射到该节点，那么我们可以通过 $xor$ 的交换律证明： $root$ 到 $a,b$ 之间的路径异或一个值是等价于 $a,b$ 的简单路径异或这个值的。

- 通过上面的转换我们可以想到将所有链接这个点的所有边的异或和，作为这个点的点值。

- 我们先猜一个结论 $\sum_{i=node}val_i = 0$ 时，$\sum_{i=edge} val_i = 0$ 。如何证明，写在后文。

- 如果结论成立那么，我们进行一次操作只会影响两个节点。所以进行一次操作最多也只可以试两个点权值变为 $0$ 。而且 $a \ xor \ c , b\  xor\ c$ 一定是劣于 $a \ xor \ a , b\  xor\ a$ 的。因此每一次最少消去 $1$ 个点，最多 $2$ 个 。

- 因为以上性质，我们可以先贪心的选取权值一样的删去，最后再考虑留下的如何删去。 $0 \le a_i\le 15$ 这使我们可以考虑状压 $dp$ 。因为只有最后异或和为 $0$ 的集合才可能删完（每次修改两个点）。所以我们可以枚举子集。然后转移就行了。
$$
dp[S] = \min(dp[S \ xor\ S^{'}]+dp[S^{'}]) (xorsum[S^{'}]=0)
$$

- 因为在算点权时每条边被算了两次，又因为 $x \ xor \ x = 0$ ，所以一定是有解的。

## 证明
- 必要性证明：
因为所有边权全部为 $0$ ，所以点权也一定为 $0$ 。

- 充分性证明
这是一个节点个数为 $n$ 的树。所以对于叶子节点一定度数为 $1$ 。因为点权为 $0$ ，所以链接父亲的边的权值一定为 $0$ 。 这时候这条边已经不会影响父亲的点权了。所以按此归纳:
$$\sum_{i=node}val_i = 0\Rightarrow \sum_{i=edge} val_i = 0 $$

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return x;
}
const int N = 1e6;
int n,sum[1<<17],val[N],num[N],S,dp[1<<17];
int main()
{
	n = read();
	for(int i = 1;i < n;i++)
	{
		int a = read()+1,b = read()+1,w = read();
		val[a] ^= w;val[b] ^= w;
	}
	for(int i = 1;i <= n;i++) num[val[i]]++;
	int ans = 0;
	for(int i = 1;i < 16;i++)
	ans += num[i]/2,S |= ((num[i]&1)<<i-1);
	for(int i = 1;i < 1<<15;i++)
	{
		for(int j = 1;j < 16;j++)
		{
			sum[i] ^= j * ((i>>(j-1))&1);
			dp[i] += (i>>(j-1))&1;
		}
		dp[i]--;
	}
	dp[0] = 0;
	for(int i = 1;i < 1<<15;i++)
	{
		if(sum[i]) continue;
		for(int j = i;j;j=(j-1)&i)
		{
			if(sum[j]) continue;
			dp[i] = min(dp[i],dp[i^j]+dp[j]);
		}
	}
	cout<<ans+dp[S]<<endl;
	return 0;
}
```



---

## 作者：chenxia25 (赞：4)

>### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/AT3913) & [AtCoder题目页面传送门](https://atcoder.jp/contests/apc001/tasks/apc001_f)

>给定一棵带边权的树$T=(V,E),|V|=n,|E|=n-1$，每次操作可以选择任意一条链和任意一个整数$x$，使这条链上所有边边权都异或上$x$。问最少用多少次操作使得所有边的边权都变为$0$。

>$n\in\left[2,10^5\right],\forall (x,y,v)\in E,v\in[0,15]$。

考虑到链异或很不好想，不妨用差分把它转化为双点操作。

先介绍一下树上前缀和和树上差分：树上某点处的前缀和是以它为根的子树和。由于前缀和和差分是互逆运算，很容易推出树上某点处的差分是它减去它所有儿子。设差分数组为$d$，那么对某一条祖先$x$到晚辈$y$的链上所有点增加$v$可以转化为令$d_y=d_y+v,d_{fa_x}=d_{fa_x}-v$。

本题权值在边上，我们可以用每个点（除了根）代表它连向父亲的那条边。并且本题的操作是异或，异或的逆运算仍然是异或。设差分数组为$d$，那么对某一条祖先$x$到晚辈$y$的链上所有边异或$v$可以转化为令$d_y=d_y\oplus v,d_x=d_x\oplus v$。对于要异或的某条链$x\to y$，显然可以拆成$x\to\mathrm{LCA}(x,y),y\to\mathrm{LCA}(x,y)$，在$\mathrm{LCA}(x,y)$处差分异或的$2$次抵消了，所以任意一条链异或依然可以转化为令$d_x=d_x\oplus v,d_y=d_y\oplus v$。最终的目标将所有边的边权都变成$0$等价于将差分数组清零。于是只需要求出$T$的差分数组（显然不包括根），问题就转化成了：给定$n-1$个数，每次可以将其中$1\sim2$个数异或上同一个数，求清零的最小次数。

首先，所有的$0$不用管，当作不存在。显然存在一种方案：将每个数异或上自己，这样$n-1$次操作即可清零。这种方案是每次清空$1$个数的。考虑能不能用$<x$次清空$x$个数来优化方案。不难想到，唯一的优化方式是：若$x$个数的异或和为$0$，那么可以用$x-1$次操作将它们清零。

显然，若存在$2$个数相等，那么它们满足异或和为$0$的条件，于是我们贪心地将它们$1$次清零。这样贪心看起来很正确，因为显然用$x-1$次操作清零的集合越多越优，于是集合们的大小要尽可能小。然鹅实际上这样贪心的确是对的。证明：若存在$2$个相同的数，它们没有被$1$次清零，分$4$种情况：

1. 它们都异或上自己来清零，操作数为$2$。那么显然将它们$1$次清零更优；
2. 它们其中一个异或上自己来清零，另一个包含在一个$x-1$次操作清零的集合里。设这个集合大小为$s$，那么操作数为$1+s-1=s$。若将这$2$个数$1$次清零，其他$s-1$个数都异或上自己来清零，操作数仍然是$1+s-1=s$，没有变差；
3. 它们包含在不同的$x-1$次操作清零的集合里。设这$2$个集合大小分别为$s_1,s_2$，那么操作数为$s_1-1+s_2-1=s_1+s_2-2$。若将这$2$个数$1$次清零，那么剩下来的$s_1+s_2-2$个数异或和显然为$0$，可以$s_1+s_2-3$次清零，操作数仍然是$1+s_1+s_2-3=s_1+s_2-2$，没有变差；
4. 它们包含在同一个$x-1$次操作清零的集合里。设这个集合大小为$s$，那么操作数为$s-1$。若将这$2$个数$1$次清零，其他$s-2$个数都异或上自己来清零，操作数仍然是$1+s-2=s-1$，没有变差。

综上，对于任意一个方案，若存在$2$个相同的数，它们没有被$1$次清零，那么若将它们$1$次清零，有办法使得方案不会变差。所以，必存在一种最优方案，其中尽可能将所有相同的$2$个数$1$次清零。得证。

我们用桶来存储这$n-1$个数，设$buc_i$表示数$i$的个数。那么按照上面贪心的方案，尽可能将所有相同的$2$个数$1$次清零需要$\sum\limits_{i=1}^{15}\left\lfloor\dfrac{buc_i}2\right\rfloor$次操作，数$i$会剩下$i\bmod2\in\{0,1\}$个。对于剩下的这么少的数，我们就可以状压DP了。设$dp_i$表示剩下$1$个$x$当且仅当$x\in i$时清空这$|i|$个数需要的最小操作数。边界为$dp_{\varnothing}=0$，目标为$\sum\limits_{i=1}^{15}\left\lfloor\dfrac{buc_i}2\right\rfloor+dp_{\{x\mid buc_x\bmod2=1\}}$，状态转移方程为$dp_i=\min\begin{cases}|i|\\|i|-1&\bigoplus\limits_{j\in i}j=0\\\min\limits_{j\neq\varnothing,j\subsetneq i}\{dp_j+dp_{i-j}\}\end{cases}$（很简单吧）。时间复杂度为一个常数$3^{15}$（枚举子集）。还要再加上一些树上操作的$\mathrm O(n)$。

下面是AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define X first
#define Y second
#define pb push_back
const int inf=0x3f3f3f3f;
int ppc(int x){return __builtin_popcount(x);}
const int N=100000;
int n;//树的大小 
vector<pair<int,int> > nei[N+1];//邻接表 
int buc[16];//桶 
int dfs(int x=1,int fa=0){//算差分数组&装进桶里，返回x的儿子的异或和 
	int xsm=0;//儿子的异或和 
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i].X,v=nei[x][i].Y;
		if(y==fa)continue;
		xsm^=v;//算儿子的异或和 
		buc[dfs(y,x)^v]++;//将儿子y处的差分装进桶里 
	}
	return xsm;
}
int dp[1<<15];
int main(){
	cin>>n;
	for(int i=1;i<n;i++){
		int x,y,z;
		cin>>x>>y>>z;
		x++;y++;
		nei[x].pb(mp(y,z));nei[y].pb(mp(x,z));
	}
	dfs();
	for(int i=1;i<1<<15;i++){//DP 
		dp[i]=ppc(i);//状态转移方程min中第1个式子 
		int xsm=0;
		for(int j=1;j<=15;j++)if(i&1<<j-1)xsm^=j;//集合内的数的异或和 
		if(!xsm)dp[i]=ppc(i)-1;//状态转移方程min中第2个式子 
		for(int j=i-1&i;j;j=j-1&i)dp[i]=min(dp[i],dp[j]+dp[i^j]);//状态转移方程min中第3个式子  
	}
	int ans=0,msk=0;
	for(int i=1;i<=15;i++)ans+=buc[i]>>1,msk|=(buc[i]&1)<<i-1;
	cout<<ans+dp[msk];//目标 
	return 0;
}
```

---

## 作者：liaiyang (赞：3)

update：2024.4.11

加入了代码中转移顺序正确性的证明。

我们定义一个点的点权为所有与它直接相连的边的边权的异或和。

我们可以知道点权全为零等价于边权全为零。

首先，对于边权全为零推出点权全为零由定义可得，对于点权全为零，我们只要从叶子结点一层一层往上推就可以了。

每一次操作就等价于选取两个点异或。

我们状压 $0\sim 15$ 出现次数，对于每两次出现，它们都可以一次消去，所以可以状压。

我们选取两个在当前集合 $S$ 内不相等的数 $x$ 和 $y$，会有两种可能。

一种是 $x\oplus y$ 不在 $S$ 里，那么会转移到 $S-\left\{x\right\}-\left\{y\right\}+\left\{x\oplus y\right\}$。

一种是 $x\oplus y$ 在 $S$ 里，那么会转移到 $S-\left\{x\right\}-\left\{y\right\}-\left\{x\oplus y\right\}$。

时间复杂度  $O(V^22^V)$。

关于转移顺序可以直接从小到大的证明：

下证存在最优方案使得 $S$ 不断减小。

只有当 $x\oplus y$ 不在 $S$ 中时，才可能会使 $S$ 增大，所以我们只讨论 $x\oplus y$ 不在 $S$ 中的情况，另一情况时显然成立。

我们考虑当集合内元素大于等于 $3$ 个时，证明总有两个数的异或和小于另一个数。

任意选取三个数，找到这三个元素所有的位。不考虑三个元素位之间的顺序时，这三个数的位有 $\{0,0,0\}$，$\{1,1,0\}$，$\{1,0,0\}$，$\{1,1,1\}$ 四种情况，后两种情况时显然命题成立，前两种就继续往下判断。

如果判断到最后都没有结束判断，那么前两个数的异或和显然等于第三个数，与 $x\oplus y$ 不在 $S$ 中不符。

如果 $S$ 中仅有两个元素，由于点权是由周围边权异或得到，所以这两个元素一定相等，与 $S$ 中元素不等冲突。

由于点权是由周围边权异或得到，也可说明 $S$ 中只有 $1$ 个元素的情况不存在。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define min(a,b) (a<b?a:b) 
#define P pair<int,int>
#define x first
#define y second 
#define rd read()
#define modd(x) (((x)%mod+mod)%mod) 
#define rd read()
#define lowbit(x) ((x)&(-x))
inline int read(int u=0, char c=getchar(), bool f=false){
    for (;!isdigit(c);c=getchar()) f|=c=='-';
    for (;isdigit(c);c=getchar()) u=(u<<1)+(u<<3)+c-'0';
    return f?-u:u;
}
inline void wt(int x){
    if(x<0) x=-x,putchar('-');
    if(x>9) wt(x/10);
    putchar(x%10+48);
}
const int inf=~0U>>1,linf=~0ULL>>1; 
const int N=1e5+10,M=(1<<16);
int n,a[N],dp[M],s,ans,cnt[20];
main(){
    n=rd;
    for(int i=1;i<n;i++){
        int x=rd+1,y=rd+1,dis=rd;
        a[x]^=dis;
        a[y]^=dis;
    } 
    for(int i=1;i<=n;i++) cnt[a[i]]++;
    for(int i=1;i<16;i++){
        ans+=cnt[i]/2;
        s^=((cnt[i]&1)<<i-1);
    }
    for(int i=0;i<M;i++) dp[i]=1e18;
    dp[s]=ans;
    for(int i=s;i;i--)
        for(int j=1;j<16;j++)
            for(int k=1;k<16;k++)
                if((i&(1<<j-1))&&(i&(1<<k-1))&&j!=k)
                    if((i&(1<<(j^k)-1))) dp[i^(1<<j-1)^(1<<k-1)^(1<<(j^k)-1)]=min(dp[i^(1<<j-1)^(1<<k-1)^(1<<(j^k)-1)],dp[i]+2);
                    else dp[i^(1<<j-1)^(1<<k-1)^(1<<(j^k)-1)]=min(dp[i^(1<<j-1)^(1<<k-1)^(1<<(j^k)-1)],dp[i]+1);
    cout<<dp[0]<<endl;
    return 0;
}
```

---

## 作者：crashed (赞：3)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/AT3913)看题目。
# 分析

&emsp;&emsp;~~奇奇妙妙的题目~~。    
&emsp;&emsp;直接修改树上的路径会影响到很多条边，并不方便处理。我们需要**压缩受影响信息的数量**。     
&emsp;&emsp;由于对点的处理更加灵活，因而我们考虑将**边权转为点权**。   
&emsp;&emsp;考虑修改树上路径经常与树上差分挂钩，我们可以猜想第一种方法：给点赋权为它到根上所有边的权的异或和。    
&emsp;&emsp;~~但是没有什么用，因为一次操作仍然会影响到很多个点~~     
&emsp;&emsp;那就换一个。注意到一条链上**绝大多数点的度都是 $2$** ，并且对一个数异或两次同样的值不会改变它。我们就可以想到：**给点赋权为相邻的边的异或和**。   
&emsp;&emsp;这样一次操作就只会影响两个点的权。    
&emsp;&emsp;那么我们的目标是什么呢？边权全 $0$ 必然对应着点权全 $0$ ，那么点权全 $0$ 是否以为着满足要求呢？     
&emsp;&emsp;该命题可以对子树运用归纳法，归纳的基础是**叶节点满足性质**，然后就可以方便地证明了。   

-----------------------

&emsp;&emsp;所以我们的问题就变成了: **每次选定两个数，让它们同时异或上一个相同的值，最后使得点权全 $0$** 。    
&emsp;&emsp;首先，如果存在两个相同的数，我们肯定可以一次操作直接带走它们两个。    
&emsp;&emsp;那么如果不存在两个相同的数呢？此时我们也肯定可以消去一个数。选定 $x$ 和 $y$ ，我们可以同时异或上 $x$ ，于是就消掉了 $x$ ，剩下了 $x\oplus y$ 。    
&emsp;&emsp;是否应该考虑一次操作不会消去数的情况呢？考虑这样操作后续的平均贡献必然 $\le 1$ ，因而我们完全不需要考虑这种操作。    
&emsp;&emsp;总结一下，我们现在的问题又变成了：    
&emsp;&emsp;**给定可重集 $S$ ，每次可以进行如下操作之一：**    
&emsp;&emsp;**1. 选出两个相同的数，并把它们删除。**     
&emsp;&emsp;**2. 选出两个不同的数，把它们删除并加入它们的异或和。**   
&emsp;&emsp;**求最小操作次数。**   
&emsp;&emsp;可以发现此时操作 1 限定了 $S$ 中元素互不相同。而根据原题题意我们知道每个元素 $\in[1,16)$ ，因此可以对集合直接进行状压 DP ：       
&emsp;&emsp;$f(T)$：$T$ 用于表示集合中数的存在情况，满足：$T=\sum_{k=1}^{15} [k\in S]2^{(k-1)}$。    
&emsp;&emsp;然后就可以直接暴力转移了。需要注意的是，如果操作 2 新加入的数已存在于 $S$ ，则需要再进行一次操作 1 。      
&emsp;&emsp;可以发现这个转移以 $\sum_k [k\in S]$ 划分阶段，因此最好使用**记忆化搜索**而不是状态枚举。    
&emsp;&emsp;时间是 $O(2^{15}\times 15^2)$ 。   
# 代码

 ```
#include <cstdio>
#include <cstring>

const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 5, MAXS = ( 1 << 16 ) + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

int f[MAXS];
int w[MAXN];
int N, cnt;
bool vis[MAXS];

bool chk( const int S, const int b ) { return S >> b & 1; }

int DFS( const int S )
{
	if( ! S ) return f[S] = 0;
	if( vis[S] ) return f[S];
	vis[S] = true;
	for( int i = 1 ; i <= 15 ; i ++ )
		for( int j = i + 1 ; j <= 15 ; j ++ )
			if( chk( S, i - 1 ) && chk( S, j - 1 ) )
			{
				int t = S ^ ( 1 << i - 1 ) ^ ( 1 << j - 1 );
				int v = i ^ j, nxt = t ^ ( 1 << v - 1 );
				f[S] = MIN( f[S], DFS( nxt ) + 1 + chk( t, v - 1 ) );
			}
	return f[S];
}

int main()
{
	read( N );
	for( int i = 1, x, y, b ; i < N ; i ++ )
		read( x ), read( y ), read( b ),
		w[x + 1] ^= b, w[y + 1] ^= b;
	int sta = 0, tot = 0;
	for( int i = 1 ; i <= N ; i ++ )
		if( w[i] )
			tot += ( sta >> w[i] - 1 ) & 1, 
			sta ^= 1 << w[i] - 1;
	memset( f, 0x3f, sizeof f );
	write( DFS( sta ) + tot ), putchar( '\n' ); 
	return 0;
}
 ```


---

## 作者：ZillionX (赞：2)

# Description

给定一棵 $n$ 个节点的树，边有权值。要求对其执行若干次操作，每次操作选取一条链和 $x \in \mathbb N$，将链上边的权值异或上 $x$，使操作完后全部树边的权值变为 $0$。求最小操作次数。

$n \le 10^5, V \le 15$，时限 2s。

# Solution

寒假集训的思维题，填坑。

首先这种简单的链操作不难让人想到树上差分，和加法的树上差分相似，由于异或的逆运算仍是异或，一个点的差分数组就是相邻边权的异或和。

进一步可以发现，对于 $u \rightarrow v$ 的链操作，对于到差分数组上就是 $d_u \leftarrow d_u \oplus x, d_v \leftarrow d_v \oplus x$。

此时我们可以把问题转化为：给定  $n-1$ 个数，每次操作可以选出 $2$ 个数异或上同一个数，求使所有数变为 $0$ 的最小操作数。

注意到将两个相同的数一次清零一定是不劣的操作（想一想，为什么），那么这样操作完后，对于一个值 $x$，我们只会剩下 $[0,1]$ 个值为 $x$ 的数。

同时可以发现值域非常小，此时我们的手头上只剩下最多 $15$ 个不为 $0$ 的数。这个时候就可以考虑大力状压 DP。

首先类比对两个相同的数的操作，我们有一个更强的性质：当集合 $S$ 中的数异或和为 $0$ 时，我们只需要用 $|S|-1$ 次操作就可以把 $S$ 清空。

这个时候问题已经十分的显然了，我们可以枚举子集来转移这个 DP。就是说，你设 $f_S$ 表示清空 $S$ 的最小操作数，那么就有

$$f_S=\min\begin{cases}|S| &\bigoplus\limits_{x \in S}x\not=0\\ |S|-1 & \bigoplus\limits_{x \in S} x=0 \\ \min\limits_{T \subsetneqq S \land T \not=\varnothing}\{f_T + f_{S-T}\}\end{cases}$$

至此我们在 $\mathcal O(3^V)$ 的时间复杂度内解决了本题。

# Code

```cpp
const int N=1e5+5,M=(1<<16)+5;
 
int n,v[N],f[M],g[M],p[16],c[M];
 
pair<int,int> His(int x) {
	int u=16,s=0;
	while (u) {
		if (x>>u) x>>=u,s+=u;
		u>>=1;
	}
	return make_pair(x<<s,s);
}
 
int main() {
	scanf("%d",&n);
	for (int i=1;i<n;i++) {
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		v[x]^=z,v[y]^=z;
	}
	
	for (int i=0;i<n;i++) p[v[i]]++;
	
	int Ans=0,gl=0;
	for (int i=1;i<=15;i++)
		Ans+=p[i]>>1,gl|=(p[i]&1)<<i;
		
	for (int i=1;i<=gl;i++) {
		pair<int,int> u=His(i);
		g[i]=g[i^u.first]^u.second;
		c[i]=c[i>>1]+(i&1);
	}
 
	for (int i=1;i<=gl;i++) {
		if (g[i]) f[i]=c[i];
		else f[i]=c[i]-1;
		for (int j=(i-1)&i;j;j=(j-1)&i)
			f[i]=min(f[i],f[j]+f[i^j]);
	}
	
	printf("%d",f[gl]+Ans);
	
	return 0;
}
```


---

## 作者：KokiNiwa (赞：2)

# Xor Tree

[题目链接](https://atcoder.jp/contests/apc001/tasks/apc001_f)

## 题目叙述

给定一个 $n$ 个节点的树，节点的标号为 $0\sim n-1$，边的标号为 $1\sim n-1$。每条边 $i$ 连接节点 $x_i$ 和 $y_i$，并且有一个权值 $a_i$。你可以进行如下的操作若干次。

选择一条简单路径以及一个非负整数 $x$，然后对于每条属于这条路径的边，将它的权值异或上 $x$。
你的目标是让所有边的权值变成 $0$，同时，最小化操作的次数。

## 题解

+ 首先进行一步精妙转化，把给很多边的异或转化为给两个点的异或。具体的，令一个点的权值为和它相连的所有边的权值，那么给一个路径的异或相当于给两个断点的异或。
+ 那么问题转化为有许多点，每个点上有一个权值，一次可以选择两个点异或上一个数。我们统计出每种权值有多少个，如果有偶数个就自己和自己配对抵消掉。
+ 现在剩下的是有奇数个的数。我们观察到$a_i< 16$，所以我们考虑状压。设$f_s$表示剩下$s$个的最少代价。
+ 考虑一种方式，就是暴力把每个数都异或一下，这样可以把所有数异或没，这样就达到上界$n-1$次。只要可以完成操作就必须满足这些数的异或值为$0$。
+ 于是可以考虑分拆，把$s$集合拆成两个集合$s_1$和$s_2$。那么$f_s=\operatorname {min_{s_1|s_2=s}}\{f_{s_1}+f_{s_2}\}$。

## 代码

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

const int maxN = 1e5 + 10;
int nodeN, tot;
int val[maxN], cntHas[maxN], dp[1 << 16], num[20], xorSum[1 << 16];

int main () {
	scanf("%d", &nodeN);
	for (int nodeI = 1; nodeI < nodeN; ++nodeI) {
		int n1, n2, len;
		scanf("%d%d%d", &n1, &n2, &len);
		++n1, ++n2;
		val[n1] ^= len;
		val[n2] ^= len;
	}
	for (int nodeI = 1; nodeI <= nodeN; ++nodeI) ++cntHas[val[nodeI]];
	int ans = 0;
	for (int valI = 1; valI < 16; ++valI) {
		ans += cntHas[valI] >> 1;
		cntHas[valI] &= 1;
		if (cntHas[valI] != 0) {
			num[++tot] = valI;
		}
	}
	for (int stI = 0; stI < (1 << tot); ++stI) {
		for (int weiJ = 0; weiJ < tot; ++weiJ) {
			if ((stI & (1 << weiJ)) != 0) {
				xorSum[stI] ^= num[weiJ + 1];
			}
		}
	}
	for (int stI = 0; stI < (1 << tot); ++stI) {
		if (xorSum[stI] > 0) {
			dp[stI] = 0x3f3f3f3f;
			continue;
		}
		for (int weiJ = 0; weiJ < tot; ++weiJ) {
			if ((stI & (1 << weiJ)) != 0) {
				++dp[stI];
			}
		}
		--dp[stI];
	}
	dp[0] = 0;	//dp[0]要特殊处理
	for (int stI = 0; stI < (1 << tot); ++stI) {
		if (xorSum[stI] != 0) continue;	//这里开始写成了 dp[stI]
		for (int son = stI & (stI - 1); son; son = stI & (son - 1)) {
			if (xorSum[son] == 0) {
				dp[stI] = min(dp[stI], dp[stI ^ son] + dp[son]);
			}
		}
	}
	ans += dp[(1 << tot) - 1];
	printf("%d\n", ans);
	return 0;
}
```

## 知识点

+ 子集`DP`小技巧，把一个集合拆分两个的这种转移方法。
+ 操作题，问题的变量减少（从一条边的异或变成两个点的异或
+ 操作题找不变量，一次操作所有的数异或起来不变。

---

## 作者：ycx_girlfriend (赞：2)

### [原题链接](https://atcoder.jp/contests/apc001/tasks/apc001_f)

这题是神仙思维题啊

设$a_u=\bigoplus_{e\in \text{u.edges}}\text{weight}_e$，即所有与$u$相邻的边的权值异或和。

那么，那个不寻常的操作即珂转化为：**找两个下标$i,j$和一个数$x$，要$a_i,a_j$同时异或上$x$。最后还是要求使得所有的$a_i=0$的最少操作数。**

~~发现搞到这儿还是不会/kel~~

然后接着我们思考另一个东西:

设集合$S$满足$S$中的所有数的异或和为$0$,且任意一个$S$的非空子集里的数的异或和都不为$0$。

**那么窝们需要至少$|S|-1$次上面的那个操作才能使得$S$中的所有数变为$0$。**

证明? ~~咕咕咕~~

算了，还是~~简单~~证明一下吧：

先看一个广义的推论：集合$|S|$至少需要经过$|S|-1$次操作才能使得$|S|$变成由$|S|-1$个$0$和一个$\bigoplus_S$组合出来的大小为$|S|$集合。

证明如下：

假设当$|S|=n-1$时推论成立。当$|S|=n$时，不妨设最后一次这样的操作中的一个数为$S_n$。那么前面窝们需要通过$n-2$次操作搞出来$n-2$个$0$和一个$\bigoplus_{1\leq i\leq n-1}S_i$。这即为符合假设。

所以若$|S|=n-1$时推论成立，则当$|S|=n$时推论成立。

又因为当$|S|=2$，推论显然成立，所以上述推论成立。

当$\bigoplus_S=0$时，上述结论成立。

**所以窝们要让操作数尽量少，就要划分出尽量多的$S$。**

假设窝们划分出了$m$个$S$，那么答案就是$n-m$。

然后窝们发现虽然会有$100000$个数，但是每个数都在范围$[0,15]$之间，也就是相同的数珂能会出现很多次。

窝们珂以这样划分：
1. 对于每个数$0$，单独划分为一个$S$
1. 对于每两个相同的数，单独划分为一个$S$

这样下来就只剩下了每个数最多一次。

然后考虑$dp_{mask}$表示出现数的集合是$mask$最多珂以划分为多少个$S$。

那么$dp_{mask} = \max_{submask\in mask}{dp_{submask}+dp_{mask\bigoplus submask}}$

总时间复杂度：$O(n+3^{15})$

贴一下代码:
```cpp
// Code by H~$~C
#include <bits/stdc++.h>
using namespace std;

static const int Maxn = 100005;

int n;
int a[Maxn];
int dp[Maxn];

int main() {
  scanf("%d", &n);
  for (int i = 1; i < n; ++i) {
    int u, v, w;
    scanf("%d%d%d", &u, &v, &w);
    ++u, ++v;
    a[u] ^= w, a[v] ^= w;
  }
  
  int ans = 0;
  int allmask = 0;
  for (int i = 1; i <= n; ++i) {
    if (a[i] == 0) {
      ++ans;
    }
    else if (allmask & (1 << a[i] - 1)) {
      allmask ^= (1 << a[i] - 1);
      ++ans;
    }
    else {
      allmask ^= (1 << a[i] - 1);
    }
  }
  
  dp[0] = 0;
  for (int mask = 1; mask < (1 << 15); ++mask) {
    dp[mask] = -1;
    int xorsum = 0;
    for (int i = 0; i < 15; ++i) {
      if (mask >> i & 1) {
        xorsum ^= (i + 1);
      }
    }
    if (xorsum != 0) {
      continue;
    }
    
    for (int smask = mask; smask; smask = (smask - 1) & mask) {
      if (dp[smask] == -1) continue;
      dp[mask] = max(dp[mask], dp[smask] + dp[mask ^ smask]);
    }
    dp[mask] = max(dp[mask], 1);
  }
  
  printf("%d\n", n - (ans + dp[allmask]));
  return 0;
}

```

---

## 作者：Regimes (赞：2)

## 标签：

$状压dp，转换$

## 来源：

$AT \ 3913$

## 题意

给你一棵树，每次可以将一条路径上的所有边异或上任意

一个数$x$,最后使所有的边都变成$0$，求最小操作次数。

范围：$n\leq 100000,a_i \leq 15$

# $Solution:$

这道题的转换，似乎第一步就没想到。我们将每个点的点权

赋为连向它所有边的异或和。于是我们发现，每次异或上一

条路径，$u->v$，修改的只是点权$u,v$,也就是只让这两个

点异或上了$x$.那么现在这个问题已经与树无关了。问题变成

从$n$个点中每次选出两个点，异或上同一个数$x$，最后使得，

所有数变成$0$的最小操作次数。为什么可以这样，我们可以

发现，最后的结果一定是所有点权变为$0$，我们发现每次异

或上两个数，对于异或和来说，其实这两个数是相互抵消的。

所以如果一个数列有解当且仅当异或和为$0$。我们考虑一个数

列如果有多个重复元素，贪心的来说，我们必然会让相同的

两两配对，所以现在最多也就剩下$15$个数，我们可以考虑状

压。对于任意个集合我们考虑它的操作下界为元素个数$-1$.

我们现在考虑状态转移。

我有一个绝妙的解释方法。对于每一次异或，我们可以看作

每次将两个数连了一条边，那么我们如果每次让最小的和次

小的异或在一起，那么我们可以保证这样的上界一定是$n-1$

次的，这样一定可以，因为异或和为$0$。于是我们开始考虑

可不可以分成两个或更多的集合，使得更多的集合之间各没

有连边那么我们这样一定可以使答案更优，于是我们设
$dp_s$

表示$s$这个状态最优的操作次数，其实我们只需要最多把它

分成两个考虑就就行了，因为更多的都会被考虑进来。就是

$$dp_s=min(dp_s,dp_{v}+dp_{t})$$

其中集合$v$与集合$t$交集为空，并集为$s$

然后可以转移的条件就是$s,v,t$元素的异或和为$0$


---

## 作者：Fading (赞：1)

给一个思路比较顺的题解。

首先链太麻烦了，我们考虑树上差分。类比加法的树上差分，异或就是题解里说的式子：相邻边权的异或和。

然后问题就等价于$n$个数的集合，每一次找两个数异或一个新的数，把不为$0$的扔回去。问集合变为空的最少次数。

为什么是对的？为什么差分数组变成$0$所有的就是$0$？你根据深度或者拓扑序归纳一下就好了。

首先很显然让两个数全部消失至少需要$1$次操作，那么我们可以马上让$n$和值域到达一个级别，且每个数只出现一次。

其次还有一个很显然的性质，集合$S$最坏情况的操作次数是$|S|-1$，且最后得到的数一定是原集合的异或和。

考虑状压，设$g_i$表示$i$集合的异或和，$f_i$表示把$i$这个集合全部消掉或只剩下$g_i$的方案数（此时$g_i>0$）。

那么显然$g_i$可以直接预处理，$f_i$呢？

发现直接搞有后效性，~~看看这数据范围猜一猜~~我们可以分割子问题。这种操作就是合并的过程。最后的操作一定是两个数合并成一个数或者消失。所以我们枚举子集，意义是这两个集合在最后一次操作前单独操作，最后合并。

那么如果$g_j=0$或$g_k=0(j\cup k=i,j\cap k=\varnothing),f_i=\min\{f_i,g_j+g_k\}$

否则$f_i=\min\{f_i,g_j+g_k+1\}$。

~~于是，我们成功把一道思维题做成了一道套路题~~

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,a[101010],b[100],f[201010],g[202020],x,y,z;
int main(){
	scanf("%d",&n);
	for (int i=1;i<n;i++){
		scanf("%d%d%d",&x,&y,&z);
		a[x]^=z,a[y]^=z; 
	}
	int all=0,ans=0;
	for (int i=0;i<n;i++){
		if (a[i]) b[a[i]-1]++,all^=(1<<(a[i]-1));
	}
	for (int i=0;i<15;i++) ans+=b[i]/2,b[i]&=1;
	for (int zt=1;zt<=all;zt++){
		bool flag=0;
		for (int i=0;i<15;i++){
			if (((1<<i)&zt)&&(!b[i])){
				flag=1;break;
			}
			else if ((1<<i)&zt) g[zt]^=i+1;
		}
		if (!flag){
			f[zt]=__builtin_popcount(zt)-1;
			for (int i=zt&(zt-1);i;i=zt&(i-1)){
				f[zt]=min(f[zt],f[zt^i]+f[i]+(g[zt^i]*g[i]!=0));
			}
		}
	}
	cout<<f[all]+ans;
    return 0;
}

```


---

## 作者：MILLOPE (赞：1)

## 题目描述

给你一棵有$N$个节点的树，节点编号从$0$到$N-1$， 树边编号从$1$到$N-1$。第$i$条边连接节点$x_i$和$y_i$，其权值为$a_i$。

你可以对树执行任意次操作，每次操作选取一条链和一个非负整数$x$，将链上的边的权值与$x$异或成为该边的新权值。

问最少需要多少次操作，使得所有边的权值都为$0$。

## 输入格式

第1行有1个整数，代表树的节点数$N$。

接下来$N-1$行，每行有$3$个整数，第$i+1$行上的整数分别代表第$i$条边的参数$x_i,y_i,a_i$。

## 输出格式

仅1行1个整数，即最小操作数。

## 数据范围与说明

- $2\leq N \leq 10^5$
- $0\leq x_i,y_i \leq N-1$
- $0\leq a_i \leq 15$
- 保证给定的图是一棵树
- 保证输入数据都是整数

## 输入输出样例

输入 #1

```
5
0 1 1
0 2 3
0 3 6
3 4 4
```

输出 #1

```
3
```

输入 #2

```
2
1 0 0
```

输出 #2

```
0
```

## 题解

- 对于树上路径的操作的处理比较困难，我们考虑转换一下。 
- 定义每个点的的点权为所以与这个点相连的边的权值的异或和，记为$val[i]$。然后我们会发现，如果我们更改$(u,v)$两点间的路径，最终只有$val[u],val[v]$的值发生了改变。 因为对于一条路径来说，出了两个端点外，每个点都与两条边相连。 而根据异或的性质，同一个数异或两边相同的数字，他的值不发生改变。 所以对于树上的操作可以等价于，在$val$序列最终任选两个数字，问最少几次操作可以把序列中的数字全部变为$0$。
- 我们观察一下题目的数据范围。($0\leq a_i \leq 15$)  我们可以发现最终的异或值最多只有$15$个。 （对于$=0$的情况不用操作）
- 并且我们可以把异或值相同的数字两两配对，因为他们只需一次操作就可以全部变为零。 
- 而对于其他不能表示的数字，我们可以用一个二进制数，它的第$i$表示值为$i$的数字是否多余。（感性理解下）我们现在的操作就是针对于多余的数字的操作。 
- 定义$f[s]$表示状态为$s$的最小操作次数。 
- 我们可以枚举选择了那两个数字，假设我们选择了$i,j$。令$x = i \ xor \ j$这样我们便可以去掉一个值，这两个值变为$0, x$。
- 然后按$x$是否在原序列出现分类讨论即可 （具体可以看代码）

## $code1$

```cpp
#include <bits/stdc++.h> 
using namespace std; 
const int maxn = 1e5 + 100; 
const int maxm = 1 << 15 + 10; 
const int inf = 0x3f3f3f3f; 

int n, ans, state; 
int v[maxn], cnt[20], f[maxm]; 

int dp(int s) {
	if (!s) return 0; 
	if (f[s] < inf) return f[s]; 
	for (int i = 0; i <= 15; ++i) {
		if (!(s & (1 << i))) continue; 
		for (int j = 0; j <= 15; ++j) {
			if (i == j || !(s & (1 << j))) continue; 
			int x = i ^ j; 
			int y = s ^ (1 << i) ^ (1 << j) ^ (1 << x); 
			if (s & (1 << x)) f[s] = min(f[s], dp(y) + 2); 
			else f[s] = min(f[s], dp(y) + 1); 
		}
	}
	return f[s]; 
}

int main() {
	scanf("%d", &n); 
	for (int i = 1; i < n; ++i) {
		int x, y, z; 
		scanf("%d%d%d", &x, &y, &z); 
		x += 1, y += 1; 
		v[x] ^= z; v[y] ^= z; 
	}
	for (int i = 1; i <= n; ++i) cnt[v[i]]++; 
	for (int i = 1; i <= 15; ++i) {
		ans += (cnt[i] >> 1); 
		state += (cnt[i] & 1) * (1 << i); 
	}
	memset(f, 0x3f, sizeof(f)); 
	printf("%d\n", ans + dp(state)); 
	return 0; 
}
```

## $code2$
```cpp
#include <bits/stdc++.h> 
using namespace std; 
const int maxn = 1e5 + 100; 
const int maxm = 1 << 15 + 10;  

int n, ans, state, tot; 
int val[maxn], cnt[20], f[maxm], s[maxn], sum[maxm]; 
// sum表示每个集合的异或值
int main() {
	scanf("%d", &n); 
	for (int i = 1; i < n; ++i) {
		int x, y, z; 
		scanf("%d%d%d", &x, &y, &z); 
		x++, y++; 
		val[x] ^= z, val[y] ^= z; 
	}
	for (int i = 1; i <= n; ++i) cnt[val[i]]++; 
	ans = n; ans -= cnt[0]; 
	for (int i = 1; i <= 15; ++i) {
		ans -= cnt[i] / 2 ; 
		state |= (cnt[i] & 1) << (i - 1); 
	}
	tot = 1 << 15; 
	for (int i = 0; i < tot; ++i) {
		int tmp = 0; 	
		for (int j = 1; j <= 15; ++j) {
			if ((i >> (j - 1)) & 1) tmp ^= j; 
		}
		sum[i] = tmp; 
	}
	for (int i = 1; i < tot; ++i) {
		for (int j = i; j; j = (j - 1) & i) { // 枚举子集
			if (!sum[i]) f[i] = max(f[i], f[i ^ j] + 1); 
		}
	}
	ans -= f[state]; 
	printf("%d\n", ans); 
	return 0; 
}
```

---

## 作者：xcyyyyyy (赞：0)

### [APC001F] XOR Tree

看到这个题首先考虑边权转点权。我想的是把一个点的权变成从 $1$ 号节点跑到这个节点的异或值，但这个转化没有任何意义。

但是对不起我真的没有想到这个方法：将 $x$ 的值设为周围一圈边的异或值，那么我们的操作就变成了选取两个点使得他们同时异或上一个值，目标是将所有值变成 $0$。

首先相同的值我们肯定直接将他们变成 $0$，接下来只剩下了 $16$ 种值。

剩下的自己想出来了：

如果有三个数异或起来是 $0$，我们可以用 $2$ 次操作将他们变成 $0$。四个同理......

那么我们操作是每一次选择若 $n$ 个数，异或起来为 $0$，用 $n-1$ 次操作将他们变成 $0$。

直接状态压缩即可。

[code](https://atcoder.jp/contests/apc001/submissions/52219811)

---

## 作者：翼德天尊 (赞：0)

如何排除错误思路？如何排除错误思路？如何排除错误思路？

第一眼就是树形 dp 怎么办？第一眼就是树形 dp 怎么办？第一眼就是树形 dp 怎么办？

考虑异或总是具有一些特殊的性质，所以或许看见异或，我们就应该多尝试分析一些特殊的东西？

例如我们尝试将边的聚焦放在点上——我们会发现对于一条异或 $x$ 的路径，除了两个端点附近的边会被异或一个 $x$ 以外，路径上的其它点附近都会有两条边被异或一个 $x$。而异或两边，不就相当于没有异或吗？

于是我们有一个很奇妙的想法，将每个点的点权赋为其邻边边权的异或和，则每次异或 $x$ 路径操作只会修改端点点权。欸？好像简单了很多？

那么转化前后问题是否等价呢？即，对于结束状态，点权全为 $0$ 和边权全为 $0$ 互为充要条件吗？边权全为 $0$，显然点权都为 $0$；点权都为 $0$ 时，首先对于叶子节点，边权显然为 $0$，向上推广即可得出边权全为 $0$。修改等价，终止状态等价，故转化前后问题等价。

转化后怎么做呢？其实就变成了一个配对问题，显然我们会贪心地先将点权相同的两点进行匹配。匹配后最多只会剩下至多 $15$ 个点权不同且非零的节点。

此时我们可以简单状压一下，对于某个点权状态，设此时包含 $x$ 个不同的点权，我们将其压成点权集合 $S$。显然 $S$ 可以被全部消成 $0$ 当且仅当 $S$ 中点权异或和为 $0$。

最劣情况下我们会将 $S$ 中点权一一消 $0$，会进行 $x-1$ 次操作。如果不是这样操作，那么我们一定可以将操作分为两个互不相交的集合，于是枚举自己取 min 转移即可。

时间复杂度 $O(3^n+n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+5;
const int V=16;
const int A=1<<V;
int n,a[N],sum,num[N],T,dp[A],g[A],js[A],ans;
int read(){
	int w=0,fh=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') fh=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*fh;
}

int main(){
#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
	// freopen("out.out","w",stdout);
#endif
	n=read();
    for (int i=1;i<n;i++){
        int u=read()+1,v=read()+1,w=read();
        a[u]^=w,a[v]^=w;
    }
    for (int i=1;i<=n;i++) ++num[a[i]];//,cout<<a[i]<<"\n";
    for (int i=1;i<V;i++){
        ans+=num[i]/2;
        num[i]%=2;
        if (num[i]) T|=(1<<i);
    }
    for (int i=0;i<A;i++){
        for (int j=0;j<V;j++)
            if (i&(1<<j)) ++js[i],g[i]^=j;
    }
    // cout<<T<<"\n";
    for (int i=1;i<A;i++){
        if (g[i]) continue;
        dp[i]=js[i]-1;
        for (int j=(i-1)&i;j;j=i&(j-1)){
            if (g[j]) continue;
            // cout<<i<<" "<<j<<"\n";
            dp[i]=min(dp[i],dp[j]+dp[i^j]);
        }
    }
    cout<<dp[T]+ans<<"\n";
	return 0;
}
```

---


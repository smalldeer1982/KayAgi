# [AGC068E] Sort and Match

## 题目描述

给定一个大小为 $N \times N$ 的整数矩阵 $A = (A_{i,j})_{1 \leq i, j \leq N}$ 和一个整数 $M$。

对于长度为 $M$ 的整数序列 $x = (x_1, x_2, \cdots, x_M)$，其中每个元素均为 $1$ 到 $N$ 之间的整数，我们定义一个函数 $f(x)$：

- 首先将序列 $x$ 中的元素按照非严格递增顺序排列，得到新序列 $y = (y_1, y_2, \cdots, y_M)$。
- 计算 $f(x) = \prod_{1 \leq i \leq M} A_{x_i, y_i}$。

请对每一个 $k = 1, 2, \cdots, N$ 计算以下问题：

- 对所有满足 $x_1 = k$ 的序列 $x$，计算它们对应的 $f(x)$ 的总和，并将结果对 $998244353$ 取模。

## 说明/提示

### 约束条件

- $1 \leq N \leq 50$
- $1 \leq M \leq 50$
- $0 \leq A_{i,j} < 998244353$
- 所有输入数据都是整数

### 示例说明

对于所有可能的序列 $x$ 及其 $f(x)$ 值如下：
- 对于 $x = (1, 1)$，产生排序后序列 $y = (1, 1)$，因此 $f(x) = A_{1,1} \times A_{1,1} = 1$。
- 对于 $x = (1, 2)$，产生排序后序列 $y = (1, 2)$，因此 $f(x) = A_{1,1} \times A_{2,2} = 4$。
- 对于 $x = (2, 1)$，产生排序后序列 $y = (1, 2)$，因此 $f(x) = A_{2,1} \times A_{1,2} = 6$。
- 对于 $x = (2, 2)$，产生排序后序列 $y = (2, 2)$，因此 $f(x) = A_{2,2} \times A_{2,2} = 16$。

所以，当 $k = 1$ 时，答案是 $1 + 4 = 5$，当 $k = 2$ 时，答案是 $6 + 16 = 22$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2 2
1 2
3 4```

### 输出

```
5 22```

## 样例 #2

### 输入

```
2 3
1 2
3 4```

### 输出

```
27 118```

## 样例 #3

### 输入

```
5 4
785439575 250040585 709423541 945005786 19237225
404191279 250876592 22672563 519729086 344065186
273714212 560047125 139793596 542901248 520999410
855572558 498896932 418633758 742973826 248730678
238856535 319502970 908902333 164543594 245101681```

### 输出

```
216530400 726773157 717209375 797938347 957133905```

## 样例 #4

### 输入

```
10 50
197971506 714635866 966125570 768080799 80565655 459117401 256810168 775681305 582857561 948631706
437330820 321722967 531470304 255908811 45459908 504089816 695016247 91058795 905527130 30860430
151769562 979797105 619322493 298241991 360690308 480124392 297323928 284686636 922571073 627798362
753705854 712639027 721488863 69714419 485979799 88704853 758288417 423073188 595934547 86264514
272481811 622712481 221745114 225051881 433378197 985573661 210619166 851716760 283615535 834897126
366075547 933505674 858395194 490049033 22039836 361481447 735151983 518458804 422209788 28981946
907645400 111982636 978445563 686621115 486475154 734616351 587635888 527524079 454844580 826849288
868863954 490627044 967828344 887235558 138021910 435784230 343307056 118718683 547282350 757693154
32344652 101428952 585897722 693817619 790433406 848494439 873744405 604427602 951889915 989125209
865548541 642980476 603592935 911086893 466178404 79002814 902745597 825893950 147052664 805753279```

### 输出

```
862518623 606960987 762676180 606184511 762408948 47716007 968649097 788324707 140177479 484063588```

# 题解

## 作者：Petit_Souris (赞：4)

典型的 AGC-style 题啊，感觉就是最后的做法非常简洁有力，但是不明白为什么自己就是想不到。

很想给这个东西连边，所以给 $y\to x$ 连边，这样形成了若干个欧拉回路。然后就不知道怎么计数了，感觉怎么做都会算重啊。想假了很多，也往很多方向上想歪了（矩阵树 / 行列式）。

正解还是比较有启发性的，遇到这种问题最好设定一个转移的顺序来构建双射。比如这里我们不妨按照 $y=1\to n$ 的顺序，每次把所有 $y$ 的出入边全部走完之后再进入 $y+1$，并且每次只能走编号 $\ge y$ 的点。这样每个图就对应了唯一的欧拉回路划分了。这步确实是比较巧妙的，但是真的想不到吗？以后能不能想到啊......

剩下就是简单的 dp 了：设 $f_{i,j}$ 表示遍历完了 $[1,i]$ 开始的欧拉回路，用掉了 $j$ 条边的权值之和，每层转移内部再设辅助状态 $g_{i,j}$ 表示目前走到点 $i$，用掉 $j$ 条边的权值。时间复杂度 $\mathcal O(n^3m)$。

最后考虑一下对每个 $x_1=k$ 如何求解。这实际上就是在说，最后一条入边是走到 $k$ 的。这也好办，把上面这个 dp 倒过来做，每次最后一条边转移的时候特殊处理一下，把贡献加进答案。

[submission](https://atcoder.jp/contests/agc068/submissions/59093484)

---

## 作者：qiuzx (赞：4)

这个 $A_{x_i,y_i}$ 的形式就很像是图上的一条边，所以我们将 $A$ 看作一个有向完全图的邻接矩阵，$(x_i,y_i)$ 看作边 $y_i\to x_i$（这里不用 $x_i\to y_i$ 是为了后面证明方便，不过直接连 $x_i\to y_i$ 应该是类似的），然后发现一组 $(x,y)$ 的权值就是所有 $(y_i,x_i)$ 的边权之积。由于 $y$ 是 $x$ 的置换，所以这张 $y_i\to x_i$ 连出来的图的每个连通块都是一个欧拉图。注意到欧拉回路相对来说是比较好处理的，因为可以直接一步一步向后走并进行 dp，所以我们希望找到原问题和欧拉回路之间的联系。

我们发现对于一张连出来的图，可以给每个点的出边钦定一个顺序，例如假设某个数在 $y_{i_1},y_{i_2},\cdots,y_{i_k}$ 这些位置出现了，则我们认为它连出去的 $k$ 条边按顺序依次连向 $x_{i_1},x_{i_2},\cdots,x_{i_k}$。显然一个序列 $x$ 只会对应一张图以及边的排列顺序，那么是否确定了一张图和边的顺序之后就能唯一还原系列 $x$ 呢？首先若给定了这张图那么首先可以确定 $y$，因为它只和每个元素的出现次数有关。接着我们从 $1$ 出发按照求欧拉回路的方式 dfs 遍历整张图，由于每个元素对应的 $i_1,i_2,\cdots,i_k$ 已知，所以我们每遍历一条边就可以根据其顺序确定出现所在的位置，因此就唯一还原了原序列。

既然我们已经建立了双射，便只需要对这样的图和出边顺序计数即可。而由于这样的一个顺序和欧拉回路的遍历顺序也是一一对应的，所以我们只需要对欧拉回路计数即可。为了避免算重，我们从 $1$ 出发一直到第一次回到 $1$ 结束作为一个循环，然后下一次可以继续从 $1$ 出发，也可以从更大的点出发。但不能从一个更小的点出发，否则会算重。而计算所有欧拉回路的边权之积的和只需要 dp 记录路径起点和终点即可。

最后一个问题就是我们需要回答 $x_1=k$ 的答案，而 $x_1$ 就是第一条出边，所以我们倒着对欧拉回路 dp，在最后一步合并的时候统计答案即可。复杂度 $O(n^4)$。

[代码](https://atcoder.jp/contests/agc068/submissions/58285723)

---

## 作者：lalaouye (赞：1)

首先这题最直观的想法是将 $A$ 看成邻接矩阵，对于 $A_{x_i,y_i}$ 贡献的处理我们考虑连 $y_i\rightarrow x_i$ 的边。为啥这样连？显然这样连要优美很多，这样每个 $y_i$ 的出边到达的点是原序列的一个区间，不难发现这张图由若干个欧拉图组成，我们考虑把它放到图上计数。

我们发现一组需要统计的方案对应着一张由若干欧拉图组成并且边有顺序的图，显然它们有双射关系。为什么呢？前者能够映射到后者是显然的，而对于后者，如果确定了图显然确定了 $y$ 序列，而每个点在 $x$ 序列对应着一个区间，按出边顺序把到达点放入区间就能还原出 $x$ 序列了。

这里可能存在一个巨大误区，就是这里图上的出边顺序就是出边顺序，并不是欧拉回路中的出边顺序。既然顺序是随便选的，也无需保证图只能是欧拉图，那么计数就方便很多了。

我们不妨回顾一下欧拉回路的证明与构造，每次从 $1$ 出发随便找到一个回路，直到 $1$ 变成孤立点为止（经过一条边删一条边），这时我们删掉 $1$ 号点，递归到 $2$，然后再将方案拼接回去，再递归到 $3$......这个过程非常优美，我们可以基于这个方式计数。具体的，设 $f(i,j,k)$ 表示 $[1,i-1]$ 已经成为孤立点，当前在处理 $i$ 的子问题，已经走了 $j$ 步，当前在 $k$。直接转移即可。但是发现这个 dp 存在一个问题就是不能保证图连通，然而这道题刚好没有要求图是连通的，就很舒服。

但是这题存在 $x_1=k$ 的限制，相当于钦定了第一个出边，我们可以在状态里记录它做到 $\mathcal{O}(n^5)$，但是显然我们不需要这么麻烦，我们不妨将边反转并令其为最后一个入边，然后倒着 dp，这样就可以做到 $\mathcal{O}(n^4)$，具体不懂可以见[代码]([Submission #63210942 - AtCoder Grand Contest 068](https://atcoder.jp/contests/agc068/submissions/63210942))。

---

## 作者：Acoipp (赞：1)

考虑让所有 $y_i$ 向 $x_i$ 连边，边权为 $A_{x_i,y_i}$，连出来有可能会有若干个连通块，但是这些连通块一定包含一条欧拉回路。（$y$ 是 $x$ 的一个置换）

那么我们需要找到的就是这些边权的乘积的和，考虑把问题转化到欧拉图上去做。

对于一个序列，我们可以按照上述方式唯一构造出来一张图，但是对于上述方式构造出来的图，我们却不能唯一对应一个序列，于是我们需要加一点限制使得序列和图构成一个双射。

注意到，我们对于一个图的欧拉回路不是固定的，原因在于我们没有确定边的顺序是怎样的，如果确定了边的顺序，是否就能构成一个双射呢？

先考虑序列到图，设 $y_{l}=y_{l+1}=\dots=y_r$，那么我们令 $y_l$ 在图上的出边顺序依次为 $x_l,x_{l+1},\dots,x_r$，因此一个序列一定可以对应一张图。

再考虑图到序列，因为图知道了，每个点的出边的条数就知道了，因此 $y$ 就确定了，又因为 $y$ 确定，所以每个点在 $y$ 中出现的区间就确定了为 $[l,r]$，然后我们按照这个点的出边顺序依次给 $x_l \sim x_r$ 填数即可，因此一个图一定可以对应一个序列。

所以我们只需要对边有顺序的图计数就行了，又因为边有顺序，如果有多个连通块，我们强制从连通块中编号最小的节点开始遍历，所以图的欧拉回路就可以固定下来。

于是我们直接对欧拉回路计数即可，具体而言，设 $f_{i,j,k}$ 表示起点是 $i$ 经过了 $j$ 条边到达了 $k$ 号点的边权之积的和。特别的，起点是 $i$ 就只能在欧拉回路经过 $\ge i$ 的点，原因同上。

最后我们要求 $ans_k$，即最小的那个点的出边指向 $k$ 的方案数，于是倒着做一遍 DP 即可，即设状态 $g_{i,j}$ 表示所有连通块的最小节点编号大于等于 $i$ 并且包含 $j$ 条边的欧拉回路的贡献和，$g$ 可以直接由 $f$ 转移得出，即 $g_{i,j} = \sum_l g_{i+1,l}f_{i,j-l,i}$。

最后枚举第一个点 $i$ 及其出边指向的点 $j$ 统计答案即可，$ans_j \gets \sum_l g_{i+1,l} f'_{i,m-l-1,j}A_{j,i}$。这里的 $f'$ 指的是倒着跑欧拉回路，因为我们枚举的是第一条出边，所以需要倒着跑答案才是对的。

时间复杂度 $O(n^4)$，空间复杂度 $O(n^3)$。

---


# [AGC045D] Lamps and Buttons

## 题目描述

有 $N$ 个编号为 $1$ 到 $N$ 的灯，以及 $N$ 个编号为 $1$ 到 $N$ 的按钮。一开始，编号为 $1,2,\cdots,A$ 的灯是点亮的，其余的灯是熄灭的。

すぬけくん和りんごさん决定进行如下游戏：

- 首先，りんごさん生成一个 $1$ 到 $N$ 的排列 $(p_1,p_2,\cdots,p_N)$。该排列从 $N!$ 种可能中等概率随机选取。すぬけくん并不知道这个排列。
- 接下来，すぬけくん可以任意多次进行如下操作：

  - 从当前点亮的灯中任选一个（如果没有点亮的灯则无法操作）。设选中的灯编号为 $i$，然后按下按钮 $i$。这样，编号为 $p_i$ 的灯的状态会被反转（如果原来点亮则变为熄灭，原来熄灭则变为点亮）。

すぬけくん始终可以知道哪些灯是点亮的。すぬけくん的胜利条件是让所有灯都点亮。如果确定无法达成目标，すぬけくん就认输。当すぬけくん采取最优策略时，他的胜率是多少？

设すぬけくん的胜率为 $w$，则 $w\times N!$ 一定是整数。请输出 $w\times N!$ 对 $10^9+7$ 取模的结果。

## 说明/提示

## 限制

- $2\leq N\leq 10^7$
- $1\leq A\leq \min(N-1,5000)$

## 样例解释 1

すぬけくん首先按下按钮 $1$。如果灯 $1$ 被熄灭，则すぬけくん失败。否则，按下新点亮的灯对应的按钮。如果剩下的灯被点亮，则すぬけくん获胜。反之，如果灯 $1$ 被熄灭，则すぬけくん失败。这个游戏的胜率是 $1/3$，所以输出 $(1/3)\times 3! = 2$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2```

### 输出

```
3```

## 样例 #3

### 输入

```
8 4```

### 输出

```
16776```

## 样例 #4

### 输入

```
9999999 4999```

### 输出

```
90395416```

# 题解

## 作者：grass8cow (赞：4)

Snuke 肯定是从左往右依次撸，如果撸到自环就失败了，如果不是自环，显然所在的这个环可以确定并把灯全部点亮。

所以 Snuke 能 win 的条件是，令第一个自环的位置在 $t$ ，则 $A+1$ 到 $n$ 的任意点所在的环内都必须有一个数 $<t$ 。

我们枚举 $t$ ，为了保证他是第一个，需要容斥，就是钦定 $[1,t-1]$ 的一个集合都是自环。

然后现在问题就形如有一个长度为 $a+b+c$ 的排列，$[a+1,a+b]$ 的所有数所在的环都存在 $[1,a]$ 的数，求方案。

我们考虑从 $1$ 到 $a+b+c$ 顺次插入过程。

考虑这个过程等同于，每次插入 $i$ ，你可以连 $(i,i)$ ，也可以选择已有的边 $(x,y)$ 把它断掉，连上 $(x,i)$ 和 $(i,y)$ 。

于是插入 $1$ 到 $a$ 是随意的，插入第 $i$ 个时方案乘上 $i$ 。$a+1$ 到 $a+b$ 时，我们不能连自环，插入第 $i$ 个时乘上 $i-1$ 。最后 $a+b+1$ 到 $a+b+c$ 也是任意的，插入第 $i$ 个时方案乘上 $i$ 。

答案就是 $a(a+b+c)!/(a+b)$ 。

复杂度 $O(A^2+n)$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,jc[10010000],ij[10100000];
const int mod=1e9+7;
int qpow(int a,int b){
	int c=1;
	for(;b;b>>=1){
		if(b&1)c=1ll*a*c%mod;
		a=1ll*a*a%mod;
	}
	return c;
}
int C(int a,int b){if(a<b)return 0;return 1ll*jc[a]*ij[b]%mod*ij[a-b]%mod;}
int sol(int a,int b,int c){
	return 1ll*a*jc[a+b+c]%mod*(1ll*ij[a+c]*jc[a+c-1]%mod)%mod;
}
int main(){
	scanf("%d%d",&n,&a);
	jc[0]=1;
	for(int i=1;i<=n;i++)jc[i]=1ll*jc[i-1]*i%mod;
	ij[n]=qpow(jc[n],mod-2);
	for(int i=n;i;i--)ij[i-1]=1ll*i*ij[i]%mod;
	int ans=0;
	for(int i=1;i<=a;i++)
		for(int j=0;j<i;j++)
		(ans+=((j&1)?-1ll:1ll)*C(i-1,j)*sol(i-1-j,a-i,n-a)%mod)%=mod;
	for(int i=0;i<=a;i++)
	(ans+=((i&1)?-1ll:1ll)*C(a,i)*sol(a-i,0,n-a)%mod)%=mod;
	return printf("%d",(ans+mod)%mod),0;
}
//第一个自环。
```


---

## 作者：shuangmu (赞：3)

这里主要是对第一篇题解的一些补充，有些东西好像没说清楚。    
首先，由于排列生成随机，所以最优决策就是不决策（反正你也不知道），也就是，让 Snuke 从左往右依次按。  
那么，什么情况下 Snuke 会输呢？我们可以把每个 $p_i$ 向 $i$ 连边，我们发现，如果灭着的灯里面存在自环，也就是只能自己打开自己的，或者在打开所有灯之前，把亮着的灯中有自环的灭掉了，都会输。那么，我们可以考虑枚举 $[1, A]$ 中第一个自环的位置 $t$，（还有可能没有自环，那么就设为 $A+1$ ），获胜的条件就变为，在按到 $t$ 之前，能够把其它的灯全打开。而这等效于，对于 $ \forall x \in [A+1, n] $，$ \exists i \in [1, t-1] $，使得 $x$ 与 $i$ 在一个环内。  
现在我们就要求 $t$ 内没有自环的情况，考虑二项式反演。我们钦定 $t$ 内有 $k$ 个自环，则整个序列被划分为五部分：$[1, t-1]$ 内的自环，$[1, t-1]$ 内其他的点，$t$ 点，$[t+1, A]$的亮灯部分，以及最初没有亮的 $[A+1, n]$ 部分。对于第一个部分是在 $t-1$ 中取出 $k$ 个点，第三个部分不用考虑，我们来讨论剩下的部分。  
因为要成环，我们就通过插入来考虑。每次插入一个点 $p$，都相当于是断开前面连接两个点 $u, v$ 的一条边，然后加上 $u$ 到 $p$ 和 $p$ 到 $v$ 的边。当然，也可以自己成为一个新环。那么，对于第二个部分内的点，可以随意插入，也可以自成环，所以每枚举到第 $i$ 个点都有 $i$ 种方案；而为了保证 “对于 $ \forall x \in [A+1, n] $，$ \exists i \in [1, t-1] $，使得 $x$ 与 $i$ 在一个环内。” 这个条件，连完第二部分后就要去考虑第五部分。这个部分中的点不能连自环，故每次枚举贡献 $i-1$；然后第四部分也是随意插入，每次贡献 $i$。注意这里的 $i$ 是连续枚举而非分别枚举。我们令这三部分的大小分别为 $a, b, 
c$，整理一下，则有 $g_k = {t-1 \choose k} \frac{a(a+b+c)!}{a+b}$。直接套二项式反演即可。  
如果按照我一开始每次单独求 $a+b$ 逆元，总复杂度为 $O(n+A^2 \log n)$（机子快能跑过去）。当然这里可以直接利用阶乘和阶乘逆元求出来，这样复杂度就是 $O(n+A^2)$。  
代码：   
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
const int N = 1e7+10, M = 5050;

int fac[N], inv[N];
inline int C(int n, int m){
	if(n<0 || m<0 || n<m) return 0;
	return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;
}
int n, m;

inline int fpow(int a, int b){
	a%=mod;
	int ret = 1;
	while(b){
		if(b & 1){
			ret = (1ll*ret*a)%mod;
		}
		b>>=1;
		a = (1ll*a*a)%mod;
	}
	return ret;
}
void prework(){
	fac[0] = 1;
	for(int i = 1; i<=n; ++i){
		fac[i] = (1ll*fac[i-1]*i)%mod;
	}
	inv[n] = fpow(fac[n], mod-2);
	for(int i = n-1; i>=0; --i){
		inv[i] = (1ll*inv[i+1]*(i+1))%mod;
	}
}

inline int calc(int a, int b, int c){
	return 1ll*a*fac[a+b+c]%mod*fac[a+b-1]%mod*inv[a+b]%mod;
}
int ans;
int main(){
	scanf("%d%d", &n, &m);
	prework();
	int a, b, c;
	for(int t = 1; t<=m+1; ++t){
		for(int i = 0; i<t; ++i){
			a = t-i-1, b = n-m, c = m-t;
			if(t == m+1) c = 0;
			int fu = (i&1)?-1:1; 
			ans = (1ll*ans+1ll*fu*C(t-1, a)*calc(a, b, c)%mod)%mod;
			ans = (ans+mod)%mod;
		}
	}	
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

Snuke 的策略一定是在每次没有完全点亮的时候，随机选择一个编号 $\leq A$ 且没有探索过的灯，如果：

- 这盏灯灭了，即 $p_i=i$，那么无解。
- 如果亮了别的灯，我们可以按照置换环点亮下去。这样子我们就点亮了整个置换环。

这个随机选择其实可以换成选一个最小的。这是因为 $p$ 排列实际上是均匀随机的。

总结一下合法的 $p_i$ 应该形如：

- 假设最小的 $p_i=i$ 为 $j$（如果不存在，$j=A+1$）
- 对每个 $i>A$，$i$ 所在置换环最小元素应该 $<j$。

考虑枚举 $j$。那么我们对整个序列的要求形如：

- 对 $i<j$，$p_i\neq i$；
- 对 $i>A$，$i$ 所在置换环最小元素 $<j$。

我们交换一下 $p[j+1,A]$、$p[A+1,n]$。那么问题转换成：

- 长度为 $A+B+C$ 的排列；
- 对于 $i<A$，$p_i\neq i$；
- $p_A=A$；
- 对于 $i\in [A+1,B]$，$i$ 所属置换环最小元素 $< A$；

对条件 $2$ 进行容斥，方案数可以通过视作为插入快速计算。

时间复杂度：$O(n^2)$。

---


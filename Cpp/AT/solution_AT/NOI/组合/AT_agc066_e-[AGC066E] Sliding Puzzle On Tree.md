# [AGC066E] Sliding Puzzle On Tree

## 题目描述

给定一棵有 $N$ 个顶点的树，顶点编号为 $1$ 到 $N$。树的第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$。

对于 $K=1,2,\ldots,N$，请解决以下问题：

> 有 $K$ 个编号为 $1,2,\ldots,K$ 的石子，第 $i$ 个石子初始放在顶点 $i$。你可以重复进行如下操作：
>
> - 选择一条连接顶点 $u$ 和 $v$ 的树边，且 $u$ 上有石子而 $v$ 上没有石子。将 $u$ 上的石子移动到 $v$ 上。
>
> 求所有可能的石子最终分布方案数，答案对 $998244353$ 取模。注意，如果某个编号的石子所在顶点不同，则认为是不同的分布方案。

给定 $T$ 组测试数据，请分别输出每组的答案。

## 说明/提示

### 限制

- $1\leq T\leq 10^5$
- $1\leq N\leq 2\times 10^5$
- $1\leq u_i, v_i\leq N$
- 给定的图一定是一棵树。
- 所有测试数据中 $N$ 的总和不超过 $2\times 10^5$。

### 样例解释 1

用编号为 $1,2,\ldots,K$ 的石子所在顶点的编号序列表示石子的分布方案时：

- $K=1$ 时，可能的分布方案为 $(1), (2), (3), (4)$，共 $4$ 种。
- $K=2$ 时，可能的分布方案为 $(1,2), (1,3), (1,4), (2,1), (2,3), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,3)$，共 $12$ 种。
- $K=3$ 时，可能的分布方案为 $(1,2,3), (4,1,3), (4,2,1), (4,2,3)$，共 $4$ 种。
- $K=4$ 时，可能的分布方案为 $(1,2,3,4)$，共 $1$ 种。

对于 $K=3$ 的情况，可以参考下图：  
![](https://img.atcoder.jp/agc066/f2dc57ae01aa4f1ccb51c1a2b8fe7d15.png)

### 样例解释 2

每组测试数据对应的树结构如下图所示：  
![](https://img.atcoder.jp/agc066/744a8d907603331334518cc5d7b62bb9.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1
4
1 2
1 3
1 4```

### 输出

```
4 12 4 1```

## 样例 #2

### 输入

```
4
1
5
1 4
5 2
3 4
2 1
7
1 7
2 7
5 6
4 1
1 6
3 6
10
1 2
2 3
3 4
4 5
5 6
2 7
3 8
4 9
5 10```

### 输出

```
1
5 10 10 5 1
7 42 210 840 84 7 1
10 90 720 5040 30240 151200 604800 720 10 1```

# 题解

## 作者：xuanxuan001 (赞：2)

抽象 AGC，之前也见过这题的原题 P6277，貌似是在很久以前闲的没事找 USACO 的黑题，然后就莫名其妙地翻到了这个，赛时也认出来了，但当时就没看懂题解，找到原题之后发现问得不太一样就没管，B 也降智没做出来。

但为什么这么偏的题知道的人这么多啊，都这么卷吗~~或者是网络的力量吗~~。AT 官方题解给出了比原题更优的 $O(n)$ 解法，但数据范围也不开大点，唉。

正文
-

又来翻译官方题解了，但其实和官解也不完全一样，算是两个做法的缝合吧。

前面的推导与原题类似，就不再过多赘述了。

为了便于区分，下文中用 $a,b$ 表示点上面的石子，用 $u,v$ 表示节点（AT 官方题解这种表述方式确实很好）。

大概就是先考虑某一个石子能到达哪些点。设 $S(a)$ 表示 $a$ 上面的石子可以到达的位置集合。

如果对于一个度数超过 $2$ 的点 $u$，如果 $S(a)$ 包含了 $u$ 的至少两个相邻节点（不难发现此时 $u$ 的所有邻点都会在 $S(a)$ 里面），那么就称 $a$ 可以利用 $u$。

定义完这些后就有一个很神奇的性质，就是下面三个条件是等价的：

1. $a,b$ 都可以利用某个节点 $u$。
1. $S(a) = S(b)$。
1. $a$ 和 $b$ 可以在不改变其他石子位置的情况下交换。

简单的手玩可以发现，相邻两个条件都可以推出充要关系，部分证明可以参考其他题解。

有了这个性质后就可以将石子按 $S(a)$ 不同分成不同的等价类，同等价类的石子可以任意互换，而不同等价类的石子相对位置永远不变。所以 $n$ 个点的相对位置关系就只有所有等价类大小的阶乘乘积种，再乘上 $C_n^k$ 表示位置集合的数量即可，USACO 的原题也可以通过类似的简单组合数解决。

那么接下来考虑如何对固定的 $k$ 求出答案，考虑用模型表示出所有的等价类，建出一个新图，在新图中原图的点和石子都是节点，其中会连两种边：

1. 如果 $a$ 可以利用 $u$，那么给 $a$ 和 $u$ 连边。
1. 如果可以利用 $u$ 已经与可以利用 $v$ 等价，那么给 $u$ 和 $v$ 连边。

其中第一类边只需要与 $a$ 所在点每个方向最近的度数大于 $2$ 的点连边即可，再远的严格不优。第二类只需要考虑之间只有二度点的这些点即可，因此连边数量是 $O(n)$ 的。

然后每个联通块就都是一个等价类，只需要在用并查集维护的同时记录里面对应石子的点的数量即可。

发现每个边出现的条件都是 $k$ 小于等于某个数，可以直接预处理出来然后按 $k$ 从大到小扫，用并查集维护并实时更新即可。

前面看似都很容易，但难点就在于求出每条边的加入时间。下面将这些边分为几类：

1. 点与点之间的（即第二类边），这时加入时间就是 n - 距离，这个在其他题解中都有提到（但 AT 官方题解貌似没有这种边，不是很懂）。
2. 点 $u$ 对应的石子与 $u$ 节点连边，这时只需要有至少两个方向有空的节点即可，找到的所有儿子的子树 $\max$ 的次大值即可，注意也要将子树外的方向特殊考虑在内。
3. 位于 $u$ 的石子与 $v$ 节点连边，这时需要保证 $u$ 在 $v$ 方向上的子树内的空点数量不少于 $u$ 到 $v$ 的点数，这时需要查询子树第 $k$ 大的问题，我一开始是用线段树合并解决的，注意在方向不同时还需要查询补集第 $k$ 大。

然后通过亿些调试就解决了。

当然，整个做法中唯一需要 $O(n \log n)$ 的地方就是那个线段树合并，但这样的求法有些傻，因为注意到这些点的编号是不影响答案的，所以可以直接按 dfs 序重编号，这样每个子树内的点集都是区间，可以实现 $O(1)$ 查询。

[AC代码](https://atcoder.jp/contests/agc066/submissions/52973961)，似乎是目前（4.30）AT 最快解，87ms，但在洛谷原题没体现出啥优势，是因为没用 C++20 吗？

---

## 作者：ZnPdCo (赞：1)

笑点解析：[P6277](https://www.luogu.com.cn/problem/P6277)。

---

发现交换操作有可传递性：如果 $(x,y)$ 两个**位置**（注意我们这里是位置而不是指石子）可以互相交换，$(y,z)$ 两个位置也可以互相交换，那么 $(x,z)$ 两个位置必定是可以互相交换的。因为可以先交换 $(x,y)$，再交换 $(y,z)$，最后再次交换 $(x,y)$。

---

我们发现如果当前如果有 $k$ 个石子，无论它们在哪些位置，我们总是可以移动它们到树上的 $1\cdots k$ 号位置。也就是说，如果**忽略标号**的话，任意两个状态都是直达的。

所以我们固定这 $k$ 个石子在 $1\cdots k$ 号位置，计算有多少种有标号的排列状态。

假如 $(x,y)$ 两个**石子**能够在不影响其它石子的情况下交换，我们就给它们连一条边，发现最后面会形成很多个团（完全图）。根据交换操作的可传递性，那么每一个团的情况肯定是可以互相到达的。

我们设这些团大小为 $s_i$，那么答案就是 $\binom{n}{k}\times\prod (s_i!)$。

---

考虑怎样的情况下两个石子是可以交换的：

首先，我们可以把石子从位置 $1\cdots k$ 移出来到任意位置。

然后在不影响其它石子的情况下交换两个石子。

最后，按照相反的顺序移动回位置 $1\cdots k$。

此时，两个石子就是可交换的，连一条边。

---

考虑怎样在不影响其它石子的情况下交换两个石子：

发现当在一条**没有石子的链**且**出现一个分支**时，两个石子可以交换：

![](https://cdn.luogu.com.cn/upload/image_hosting/znhwvyl3.png)

如上，位置 $1$ 上的石子和位置 $6$ 上的石子交换时，可以在这个**没有石子**且**有一个分支** $4$ 的链 $2\to5$ 上进行交换。先把 $1$ 上的石子移动到 $4$ 上，再把 $6$ 上的石子移动到 $1$ 上，最后把移动到 $4$ 上的石子移动到 $6$ 上。

总结可以交换的规律：

1. 没有石子的链；
2. 有一个分支（有一个位置度数大于二）。

---

我们将其拓展一下：

在一个**中间都是二度点，两端都是非二度点的链**上，设两端不包括链的树的大小分别为 $a$、$b$，链的长度为 $c$（它们都包括两端的点）：

![](https://cdn.luogu.com.cn/upload/image_hosting/1wmy2gx6.png)

如上，$1\to8$ 就是合法的**中间都是二度点，两端都是非二度点的链**。其中 $a=5$（位置 $1$，$2$，$3$，$4$，$5$ 都是左端的树），$b=5$（位置 $8$，$9$，$10$，$11$，$12$ 都是右端的树），$c=4$（位置 $1$，$6$，$7$，$8$ 都是中间的链）。

我们发现，当 $k\le(a-1)+(b-1)-1$ 时，两端的树上的每一个位置都可以互相交换，**也就是能到达左端的石子和能到达右端的石子一定可以交换**，我们对这两个石子连边。

原理：将 $k$ 个石子任意的移动到两颗树上，留下一个空位置作为**交换的分支**，然后树上的任意两个石子都可以通过这个**分支**和**没有石子的链**进行交换。

总结可以交换的规律：$k<(a-1)+(b-1)$，也就是 $k<n-c$。

---

发现，若 $(x,y)$ 是满足这个条件的一条链，也就是能到达 $x$ 的石子能和能到达 $y$ 的石子交换。以及若 $(y,z)$ 也是满足这个条件的一条链，那么能到达 $x$ 的石子能肯定也能和能到达 $z$ 的石子交换。

也就是说，我们链的两端可以互相连接形成很多个连通块

我们可以把每个满足交换条件，也就是 $k<n-c$ 的链的两端连接起来，因为可以到达这两个位置的石子就可以和能到达另一个位置的石子交换，所以说，我们计算能到达这些点的石子的个数，即可得到 $s_i$，也就是团的大小。

因为当 $k$ 从小到大枚举时，$k<n-c$ 也就是 $c<n-k$ 的边是越来越少的，不好维护。考虑时光倒流，将 $k$ 从大到小枚举时，$c<n-k$ 的边将会越来越多，用并查集即可维护。

---

回到刚刚那个问题，怎么计算能到达这些点的石子的个数？

正難则反，我们可以计算出无法到达这个连通块的石子的个数，再用石子的总数 $k$ 减去即可。

如果 $a_i\to b_i$ 不是一条满足上面交换条件的链，设连通块外的树的大小为 $a_i$，连通块内树的大小为 $b_i$，链的长度为 $c_i$。

那么我们能够进入到这个联通块的最多只有 $b_i-1$ 个石子，也就是把连通块内树全部填满，那么还有 $k-(b_i-1)$ 的石子无法与之交换。

那么总共的可到达的节点数量为：

$$
\begin{aligned}
k-\sum_{a_i\to b_i}(k-(b_i-1)) &= k-\sum_{a_i\to b_i}(k-(n-a_i-(c_i-1))) \\
&= k-\sum_{a_i\to b_i}(k-n+a_i+c_i-1) \\
\end{aligned}
$$

发现 $a_i+c_i-1$ 为“联通块内子树” 外的点减一（$c_i$ 有一端在连通块内），所以设 $p_i$ 为链方向连通块外的点的个数，有：

$$
\begin{aligned}
k-\sum_{a_i\to b_i}(k-(b_i-1)) &= k-\sum_{a_i\to b_i}(k-n+p_i+1) \\
&= k-(\sum_{a_i\to b_i}(k-n+1)+\sum_{a_i\to b_i}p_i)
\end{aligned}
$$

设连通块大小为 $\text{siz}$，不合法的 $a_i\to b_i$ 个数为 $\text{out}$。我们发现子树外的点数和 $\sum_{a_i\to b_i}p_i=n-\text{siz}$。有：

$$
\begin{aligned}
k-\sum_{a_i\to b_i}(k-(b_i-1)) &= k-([\text{out}](k-n+1)+n-[\text{siz}]) \\
&= k-[\text{out}](k-n+1)-n+[\text{siz}] \\
&= ([\text{out}]-1)(n-k-1)+[\text{siz}]-1
\end{aligned}
$$

我们维护一下连通块的 $\text{out}$ 和 $\text{siz}$ 即可。注意在合并的时候，双方的 $\text{out}$ 和 $\text{siz}$ 都会减小！

---

因为每一次连通块个数等于不合法链的数量加上一，而不合法链只能存活链长的时间，所以均摊之后是 $O(n)$ 的。连通块使用 `set` 维护。所以时间复杂度为 $O(n\log n)$。精细实现能够做到更优。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define N 200010
#define P 998244353
ll t, n;
ll deg[N];
ll head[N], nxt[2 * N], to[2 * N], cnt;
ll fa[N], out[N], siz[N];
ll ans[N], fac[N], ifac[N];
set<ll> s;
struct node {
	ll a, b, c;
	node(ll a = 0, ll b = 0, ll c = 0):a(a), b(b), c(c) {}
} edge[N];
ll tot;
void addEdge(ll u, ll v) {
	cnt ++;
	to[cnt] = v;
	nxt[cnt] = head[u];
	head[u] = cnt;
}
ll find(ll x) {
	if(fa[x] == x) {
		return x;
	}
	return fa[x] = find(fa[x]);
}
void merge(ll a, ll b, ll c) {
	a = find(a), b = find(b);
	fa[a] = b;
	siz[b] += siz[a] + c - 2;
	out[b] += out[a] - 2;
	s.erase(a);
}
void dfs(ll u, ll fa, ll rt, ll c) {
	if(deg[u] != 2) {
		if(rt) {
			edge[++ tot] = node(u, rt, c);
		}
		c = 1;
		rt = u;
	}
	for(ll i = head[u]; i; i = nxt[i]) {
		ll v = to[i];
		if(v == fa) continue;
		dfs(v, u, rt, c + 1);
	}
}
ll qpow(ll x, ll y) {
	if(y == 0) return 1;
	if(y % 2 == 1) return x * qpow(x, y - 1) % P;
	ll tmp = qpow(x, y / 2);
	return tmp * tmp % P;
}
int main() {
	scanf("%lld", &t);
	while(t --) {
		scanf("%lld", &n);
		
		for(ll i = 1; i <= n; i ++) {
			head[i] = 0, deg[i] = 0, fa[i] = 0, siz[i] = 0, out[i] = 0;
		}
		cnt = 0, tot = 0;
		s.clear();
		
		for(ll k = 1; k < n; k ++) {
			ll u, v;
			scanf("%lld %lld", &u, &v);
			addEdge(u, v);
			addEdge(v, u);
			deg[u] ++;
			deg[v] ++;
		}
		for(ll i = 1; i <= n; i ++) {
			if(deg[i] != 2) {
				fa[i] = i;
				siz[i] = 1;
				out[i] = deg[i];
				s.insert(i);
			}
		}
		dfs(*s.begin(), 0, 0, 0);
		sort(edge + 1, edge + 1 + tot, [&](const auto &x, const auto &y) {
			if(x.c == y.c) {
				if(x.a == y.a) return x.b < y.b;
				else return x.a < y.a;
			}
			return x.c < y.c;
		});
		fac[0] = 1;
		for(ll i = 1; i <= n; i ++) {
			fac[i] = fac[i - 1] * i % P;
		}
		ifac[n] = qpow(fac[n], P - 2);
		for(ll i = n; i >= 1; i --) {
			ifac[i - 1] = ifac[i] * i % P;
		}
		ans[n] = 1;
		ll pos = 1;
		for(ll k = n - 1; k >= 1; k --) {
			while(pos <= tot && k < n - edge[pos].c) {
				merge(edge[pos].a, edge[pos].b, edge[pos].c);
				pos ++;
			}
			ans[k] = fac[n] * ifac[k] % P * ifac[n - k] % P;
			for(ll i : s) {
				(ans[k] *= fac[(out[i] - 1) * (n - k - 1) + siz[i] - 1]) %= P;
			}
		}
		for(ll i = 1; i <= n; i ++) {
			printf("%lld ", ans[i]);
		}
		printf("\n");
	}
}
```

---

## 作者：_Cheems (赞：0)

题意：$n$ 点的树，$1\dots k$ 上分别有石子 $1\dots k$，可以将一个点上的石子移动到相邻的无石子的位置上，对每个 $k\in[1,n]$ 求可能得不同局面。$n\le 2\times 10^5$。

前置芝士：[P6277](https://www.luogu.com.cn/article/loxw895f)。

延续关系图的想法，不妨先确定位置，再确定石子标号，那么团内部可以随意交换石子标号，记 $s_i$ 为团的大小，所以答案即为 ${n\choose k}\prod s_i!$。

---


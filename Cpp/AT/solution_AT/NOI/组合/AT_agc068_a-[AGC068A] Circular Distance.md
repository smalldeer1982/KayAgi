# [AGC068A] Circular Distance

## 题目描述

有一个周长为 $L$ 的圆，圆周上等间隔地站着 $L$ 个人。我们将这些人按顺时针方向编号为 $0,1,\cdots,L-1$。现在要从这 $L$ 个人中选出 $N$ 个人。对于一种选法，定义其**代价**如下：

- 对于从 $N$ 个人中任选的每一对两人，计算其中一人沿圆周移动到另一人位置的最短距离。所有这些距离的最大值即为该选法的代价。

请计算所有选法的代价之和，并对 $998244353$ 取模后输出。

## 说明/提示

## 限制条件

- $2 \leq N \leq L \leq 10^6$
- 输入的所有数均为整数。

## 样例解释 1

选出的 $N$ 个人及其对应的代价如下：
- $(0,1)$：代价 $1$
- $(0,2)$：代价 $2$
- $(0,3)$：代价 $1$
- $(1,2)$：代价 $1$
- $(1,3)$：代价 $2$
- $(2,3)$：代价 $1$
这些代价的总和为 $8$，即为答案。

## 样例解释 2

只能全部选出所有人，此时代价为 $2$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 2```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5```

### 输出

```
2```

## 样例 #3

### 输入

```
13 5```

### 输出

```
7618```

## 样例 #4

### 输入

```
1000000 100000```

### 输出

```
664396470```

# 题解

## 作者：qiuzx (赞：7)

枚举一个 $d$，则我们只需要计算有多少种选择点的方式可以让任意两个点之间的距离不超过 $d$。考虑环是比较麻烦的，所以我们拆环成链。此时对于链上选择的两个点 $l<r$，容易发现它们必须满足 $r-l\le d$ 或 $r-l\ge n-d$。不妨钦定选择了 $0$ 号点，则我们只需要计算此时的选择方案之后乘上 $\frac Ln$ 即可（因为这个 $0$ 号点实际可能对应 $L$ 个位置中的任意一个，且每种情况中每个人都会被我们放在 $0$ 号点计算一遍）。

注意到此时区间 $[d+1,n-d-1]$ 中的点都不能选择，而对于两个同时满足 $0<x,y\le d$，或 $n-d\le x,y<n$ 的点 $x,y$，它们之间一定是合法的。这意味着 $[d+1,n-d-1]$ 这个区间将所有点分成了两个部分，每个部分的点之间没有限制，只需要考虑两个部分的点之间的限制即可。如果我们选择了一个点 $0<x\le d$，则一定不能选择区间 $[x+1+d,x+n-d-1]$ 之间的点。令 $len=n-2d-2$，则如果我们将每个 $x$ 平移到 $x+d+1$ 这个位置，那么相当于限制是 $[x,x+len]$ 之间不能选择任何点。

于是现在问题变成了这样：在 $m$ 个点中可以选择若干个点并将它们染成黑白两种颜色，要求如果相邻两个点前一个是白色，后一个是黑色，则这两个点之间距离 $>len$，求方案数。这里钦定这些点之前有一个白点，之后有一个黑点。枚举黑白交替了多少次，则剩余的方案数使用组合数容易算出。由于交替的次数 $i$ 需要满足 $i\times len\le L$，所以对所有 $d$ 求和得到复杂度 $O(L\log L)$。

[代码](https://atcoder.jp/contests/agc068/submissions/58291859)

---

## 作者：allenchoi (赞：5)

### 前言：
在本场比赛中保持了高达 $15$ 分钟的 rk1！！！   
### 思路：  
注意到 $L\le 10^6$，因此不难想到对于每种距离 $i$ 算出其方案数 $c_i$ 再统计答案。好像 $c_i$ 也不好求，考虑求 $f_i$ 表示最大距离小于等于 $i$ 的方案数。   
首先，我们可以钦定 $0$ 号点必选，最后再将方案数乘上 $\frac{L}{n}$ 即可。那么其他点可选的位置只能在区间 $[L-i,L-1]$ 和 $[1,i]$ 内。两个区间内部任意两点的距离肯定是合法的，那么我们考虑两个区间之间的影响。  
假设我们选了一个点 $p\in[L-i,L-1]$，那么区间 $[p+i+1-L,p-i-1]$ 内的点就是不能选的了。不难发现，这些区间的左端点一定属于 $[1,i]$ 而且长度都是 $L-2i-2$。  
令在区间 $[L-i,L-1]$ 内选择的点为黑点，在区间 $[1,i]$ 内选择的点和 $0$ 号点为白点。将所有黑点向后移动 $i+1$ 的距离使它们落在区间 $[1,i]$ 内，则原来的限制转化成如下形式：在区间 $[1,i]$ 内有总共 $n$ 个黑点或白点，黑点往后一段长度为 $len=L-2i-2$ 的区间内不允许存在白点。  
进一步地，一段极长连续的黑点后至少要空出 $len$ 个单位才能继续填白点。考虑枚举黑点转成白点的次数 $j$，则区间 $[1,i]$ 中至少有 $len\times j$ 个空位。我们可以先假设所有点都是白点，那么它们共有 $\dbinom{i-len\times j}{n-1}$ 种方案。然后我们再考虑黑点、白点连续段的划分（可以看成再选出 $j$ 个位置作为黑点连续段与白点连续段交替的位置，在它们后面各插入一个长为 $len$ 的空区间将总长度补足至 $i$，这样方便理解正确性？）。我们有 $n$ 个点，至少要有 $2j+1$ 个连续段（包括第一个点 $0$ 号白点），最后还可以有一段长度任意的黑点。给最后一段再补上一个点使其变成必有的一段。那么我们有 $n+1$ 个点，要划分成 $2j+2$ 段，因此方案数为 $\dbinom{n}{2j+1}$。    
分析时间复杂度。两个组合数都可以 $O(1)$ 计算，而枚举 $j$ 时要使 $j\times len\le i$，所以总时间复杂度为 $O(L\log L)$。   
### 代码：   

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ll read()
{
	ll x = 0,f = 1;
	char ch = getchar();
	while(!isdigit(ch) && ch != '-') ch = getchar();
	if(ch == '-') f = -1,ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - '0',ch = getchar();
	return x * f;
}
const int N = 1e6 + 5,mod = 998244353;
int n,L,ans,f[N],inv[N],fac[N],ifac[N];
int C(int n,int m){return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;}
int main()
{
	L = read(),n = read();
	inv[1] = fac[0] = ifac[0] = 1;
	for(int i = 2;i <= L;i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod;
	for(int i = 1;i <= L;i++)
	{
		fac[i] = 1LL * fac[i - 1] * i % mod;
		ifac[i] = 1LL * ifac[i - 1] * inv[i] % mod;
	}
	for(int i = 1,len;i < L / 2;i++)
	{
		len = L - 2 * i - 2;
		for(int j = 0;i - len * j >= n - 1 && 2 * j + 1 <= n;j++)
			f[i] = (f[i] + 1LL * C(i - len * j,n - 1) * C(n,2 * j + 1) % mod) % mod;
	}
	f[L / 2] = C(L - 1,n - 1);
	for(int i = L / 2;i >= 1;i--)
	{
		f[i] = (f[i] - f[i - 1] + mod) % mod;
		ans = (ans + 1LL * f[i] * i % mod) % mod; 
	}
	ans = 1LL * ans * L % mod * inv[n] % mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Eraine (赞：3)

编号：AT_agc068_a  
tag：组合数学  
难度：**$\color{red}{2948}$**

下文中 $n$ 和 $L$ 的含义与原题目相反（不好意思因为个人原因影响大家阅读体验），请注意在本文中 $n$ 指圆环长度，$L$ 指选择的人数。

要求出最大间隔恰好为 $i$ 的方案总数感觉很不可做啊！所以我们考虑最大间隔 $\le i$ 的方案数。

首先特判一下最大间隔 $\le\lfloor\frac{n}{2}\rfloor$ 的方案数必然是 $n\choose L$。

然后分类讨论。我们计算钦定 $0$ 必须选的方案数，然后将这个方案数乘上权值 $\frac{n}{k}$ 就是 $f_i$。

我们对 $n$ 的奇偶性进行分类讨论。当 $n$ 为奇数时，以样例 $n=13,L=5$ 为例，不妨假设当前需要求出 $f_5$。可以得到下面两张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/amv6x4qd.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5fm2lw8k.png)

第一张图是合法的，而第二张图是不合法的。我们会发现 $4$ 和 $11$ 距离为 $6$，不合法。

进一步地，我们会注意到 $n$ 奇数合法当且仅当不存在上下两行的元素水平距离相差 $\lt n-2i$。那我们不妨把这 $L+1$ 个元素（为了方便这里统计首尾的 $0$）根据水平排序，然后同时枚举一下相邻项出现在上下两行的次数 $j$，显然 $j$ 为奇数。假设根据水平坐标升序排列为 $a_1,a_2,\dots,a_{L+1}$。那么一个水平坐标升序排列合法，必须满足以下条件：

- $\forall p\in[1,L],a_p\lt a_{p+1}$。
- $a_1=1,a_{L+1}=n+1$。（不妨钦定第一个 $0$ 出现位置为 $1$）
- 当 $2\nmid(a_{p+1}-a_p)$ 时，$a_{p+1}-a_p\ge n-2i$，且满足这样的 $p$ 个数恰为 $j$。

令 $b_p=a_{p+1}-a_p$，转换一下即需满足：

- $\forall p\in[1,L],b_p\gt 0$。

- $\sum b_p=n$。

- 当 $2\nmid b_p$ 时，$b_p\ge n-2i$，且满足这样的 $i$ 个数恰为 $j$。

把满足 $2\nmid b_p$ 的 $b_p$ 全部忽略。剩下的共有 $L-j$ 个偶数元素。发现这又要去枚举这些元素和很不方便，我们将那 $j$ 个奇数元素看做是某个偶数元素加上固定的常数 $C$，具体地，$C=n-2i-2$。那么问题转换成两个独立子问题：

- 非零偶数序列 $b_1\dots b_L$ 满足 $\sum b_p=n-jC$ 的方案数。隔板法求出。
- 在 $L$ 个元素中选择 $j$ 个数进行 $+C$ 操作。

两个问题的答案都是组合数，乘起来就是 $(i,j)$ 的贡献，注意到 $2L+j(2-2i-2)\le n$，即可被统计到的 $(i,j)$ 实际上是 $\Theta(n\ln n)$ 级别。所以就得到一个 $\Theta(n\ln n)$ 解决 $n$ 为奇数的做法。

$n$ 为偶数的情况其实大同小异。这里展示 $n=12$ 的构造。

![](https://cdn.luogu.com.cn/upload/image_hosting/t9i91srk.png)

这里把 $0$ 放到第二行是因为若 $n$ 放在上行 $n$ 为偶数可能出现不存在相邻两个元素在上下行的情况。所以我们将 $j$ 化为奇数的情况方便处理。

同样地，转换为两个问题：

- 非零序列 $b_1\dots b_L$ 满足 $\sum b_p=\frac{n}{2}-jC$ 的方案数。隔板法求出。
- 在 $L$ 个元素中选择 $j$ 个数进行 $+C$ 操作。

其中，$C=\frac{n}{2}-i-1$。

那也就转换成和 $n$ 为奇数同样的问题形式了。

综上，通过对 $n$ 的奇偶性分类讨论在 $\Theta(n\ln n)$ 内求出 $f_i$，然后分别统计最大值恰为 $i$ 的数量可以解决此问题。

$\Theta(n\ln n)$。

[submission](https://atcoder.jp/contests/agc068/submissions/58279462)

若有疑问或错误请指出，虚心接受您的意见。

---

## 作者：Acoipp (赞：2)

简要评价：题目很厉害。

设 $f_i$ 表示任意两个点间隔小于等于 $i$ 的方案数，则最终的答案为：

$$
\sum (f_i-f_{i-1})i
$$

容易发现 $f_{\lfloor \frac l2 \rfloor}=C_l^n$，于是我么考虑 $1 \le i < \lfloor \frac l2 \rfloor$ 的情况。

我们认为 $0$ 号点必选，最终将答案乘上 $\frac ln$ 即可，因为这个 $0$ 号点可以是长度为 $l$ 的序列上的任何一个点映射过来的，这里乘上 $l$。并且每一种合法的方案因为有 $n$ 个人，所以会被映射 $n$ 次，所以再除以 $n$ 即可。

若 $0$ 号点必选，那么剩下的点只能在 $[1,i]$ 和 $[l-i,l-1]$ 内部选择，如果有点在 $[i+1,l-i-1]$ 中，那么它距离 $0$ 号点就超过了 $i$ 的限制。

又发现 $[1,i]$ 的点内部可以随便选择，$[l-i,l-1]$ 的点内部也可以随便选择，于是我们要做的就是处理两个区间之间的限制。

如果有一个点 $x$ 在 $[l-i,l-1]$ 中被选择了，那么 $[x+i+1-l,x-i-1]$ 是不能被选择的。我们把 $[l-i,l-1]$ 在环上平移到 $[1,i]$，设 $len=l-2i-2$，那么如果 $x$ 被选择了，$[x,x+len]$ 都不能被选择。

于是这个东西就变成了一个二分图的样子，上面 $i$ 个点，下面 $i$ 个点，每个相对的点对最多选择一个，如果一个点对选择了下面的点，那么它往后 $len$ 的范围内都不能选择上面的点。

方便起见，我们设一个点对选择了上面的点为染成了白色；选择了下面的点为染成了黑色；否则是没有染色。并且染色的点数一共是 $n-1$，此外，$0$ 号点染白色。（算上 $0$ 号点染色的点数一共为 $n$）

于是题目中的限制就变成了一个染成黑色的点后第一个染色的点如果是白色，那么这两个点的间隔 $>len$。

于是枚举上面那种情况出现的次数 $j$，先把 $j$ 个间隔抛开，然后处理内部的方案数是 $C_{i-j \times len}^{n-1}$；再把这 $j$ 个间隔插入到 $n-1$ 个数某些数的后面，即对这些数划分黑白染色。现在，点的编号是 $[1,n]$，一共有 $2j+1 \sim 2j+2$ 个段，为白黑白黑交替（$1$ 号点前面固定了为白色），最后可能会多出一段不限量的黑色段（这就是为什么前面段数有可能比 $2j+1$ 大的原因），于是我们强制 $i+1$ 为黑色，点的编号就变成了 $[1,n+1]$，并且一共刚好 $2j+2$ 段。

问题最后规约成了 $i+2$ 个点划分为 $2j+2$ 的方案，用隔板法可知答案为 $C_{n}^{2j+1}$。

时间复杂度很好计算，先枚举 $i \le l$，然后 $len=l-2i-2$，再枚举 $i-j \times len \ge n-1$，容易得到复杂度是调和级数 $O(n \ln n)$。

代码如下，仅供参考：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 2000005
#define mod 998244353
using namespace std;
ll l,n,i,j,ans[N],res,jc[N],inv[N];
inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t = a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}
inline ll C(ll n,ll m){
	if(n<m) return 0;
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
int main(){
	ios::sync_with_stdio(false);
	jc[0]=1;
	for(i=1;i<=2e6;i++) jc[i]=jc[i-1]*i%mod;
	inv[2000000]=qmi(jc[2000000],mod-2,mod);
	for(i=2e6;i>=1;i--) inv[i-1]=inv[i]*i%mod;
	cin>>l>>n;
	ans[l/2] = C(l,n);
	for(i=1;i<l/2;i++){
		ll len = l-2*i-2;
		for(j=0;i-len*j>=n-1&&2*j+1<=n;j++) ans[i] = (ans[i]+C(i-len*j,n-1)*C(n,2*j+1))%mod;
		ans[i] = ans[i]*l%mod*qmi(n,mod-2,mod)%mod;
	}
	for(i=1;i<=l/2;i++) res=(res+(ans[i]-ans[i-1]+mod)*i)%mod;
	cout<<res<<endl;
	return 0;
}
```

---

## 作者：Petit_Souris (赞：0)

做了一个多小时，拼尽全力终于战胜。什么题啊这么难，原来是个 AGC 的 A。

设编号为 $[0,L-1]$。枚举 $d$，计算最大距离 $\le d$ 的方案数，最后差分回去算答案。

不妨钦定 $0$ 一定被选了，最后答案乘上 $\frac{L}{n}$ 即可。那么这时候只有 $[L-d,L-1]$ 和 $[1,d]$ 的人可能被选进去，称为左区间和右区间。左右区间内部的距离不会再超过 $d$ 了，只需要考虑跨区间的点对是否超过 $d$。

发现对于左边一个点 $i$，会限制到的右区间是 $[d-i+1,L-i-d-1]$，再靠左了可以直接走过去，再靠右了可以从另一条弧走过去。发现长度是个定值 $len=L-2d-2$，这是非常好的。

所以现在问题变为：一个长度为 $d$ 的序列，每个点可以染成黑色 / 白色 / 不染色，要求每个黑点后面至少隔了 $len$ 的距离才能有下一个白点，总共有 $n-1$ 个点染色。枚举出现了多少 黑 - 白的 pattern，设个数为 $i$，那么这些间隔先放进去，剩下的点的方案数为 $\binom{d-len\times i}{n-1}$，现在剩下的段形如 白黑白黑 交替（第一段必须是白色，强制定 $0$ 为白色）。我们不妨钦定 $d+1$ 的颜色是黑色，这样就有 $n+1$ 个点，任意分成 $2i+2$ 段，方案数为 $\binom{n}{2i+1}$。

容易发现直接爆算的复杂度就是正确的，调和级数 $\mathcal O(L\log L)$，可以通过。

[submission](https://atcoder.jp/contests/agc068/submissions/59074126)

---


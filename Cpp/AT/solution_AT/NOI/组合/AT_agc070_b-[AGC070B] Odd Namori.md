# [AGC070B] Odd Namori

## 题目描述

给定一个含有 $N$ 个顶点的有根树 $T$，顶点编号为 $1$ 到 $N$。其中，顶点 $1$ 为根节点，对于每一个顶点 $i$（$2 \leq i \leq N$），有 $p_i$ 为其父节点，且 $p_i < i$。

我们定义满足以下条件的有向图 $G$ 为“好图”：

- 每个顶点的出度都为 1。
- 图中不存在偶数长度的环。
- 对于所有 $2 \leq i \leq N$ 的 $i$，$G$ 中不包含边 $i \to p_i$。

计算所有可能的“好图”$G$ 中 $2^{\text{环的数量}}$ 的总和，再对 $998244353$ 取余。

## 说明/提示

- $2 \leq N \leq 10^5$
- $1 \leq p_i < i$
- 所有输入的值均为整数

### 样例说明 1

两种可能的“好图”为：
1. 包含边 $1 \to 1$ 和 $2 \to 2$，环的数量为 2。
2. 包含边 $1 \to 2$ 和 $2 \to 2$，环的数量为 1。

所以，答案是 $(2^2 + 2^1) \bmod 998244353 = 6$。

### 样例说明 2

例如，边集包含 $1 \to 2$、$2 \to 3$ 和 $3 \to 1$ 的图是一个“好图”，其中有一个环。

### 样例说明 4

请注意，结果需要对 $998244353$ 取余。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2
1```

### 输出

```
6```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
34```

## 样例 #3

### 输入

```
5
1 2 1 1```

### 输出

```
3104```

## 样例 #4

### 输入

```
20
1 2 2 2 5 3 5 1 7 9 4 6 4 12 8 2 5 16 6```

### 输出

```
784973196```

# 题解

## 作者：MatrixGroup (赞：9)

先来回忆一下以下定理。

**定理（矩阵树定理）.** 对于有限带权图 $G$（无重边，或者说重边叠合一下），设其邻接矩阵为 $A$，定义出度矩阵 $D=\operatorname{diag}(d_1,d_2,\cdots,d_n)$，其中 $d_i=\sum\limits_j A_{ij}$，定义 Laplace 矩阵 $L=D-A$，$L'$ 为 $L$ 去除第一行第一列的结果，则 $G$ 以 $1$ 为根的所有内向生成树里，其边权之积的和为 $\det(L')$。

（无向图情况是有向图情况的自然推论。）

大家都知道用 Cauchy-Binet 公式定理得到的证明。不过这里考虑另外一个证明，它对本题会更有启发性：

**证明 .** 

不妨设 $G$ 没有自环。（这不是必要的，但是会更方便阐述）

所谓「以 $1$ 为根的内向生成树」，就是对每个 $i=2,3,\cdots,n$ 选取一父亲 $p_i$，满足没有环的结构。考虑对环进行容斥：我们钦定 $c$ 个环，把它的权值乘以 $(-1)^c$ 即可。

recall 行列式的一个定义：对于一矩阵 $M$，对所有排列 $\pi$ 求和，其 $(-1)^{\operatorname{inv}(\pi)}$ 乘以所有 $M_{i,\pi_i}$ 的积，其中 $\operatorname{inv}(\pi)$ 表示 $\pi$ 的逆序对个数。考虑这个 $\pi$ 在所有 $\pi_i\neq i$ 的位置只在 $A$ 中有值，这对应了若干个环。而 $\pi_i=i$ 的位置对应了 $D$ 中的 $d_i$，考虑用乘法分配律拆开，钦定 $d_i$ 中的贡献来自于 $A_{i,p_i}$。这正是我们想要的！检查容斥系数，我们知道，逆序对数量的奇偶性，等于 $c-n$ 的奇偶性，其中 $c$ 为 $\pi$ 生成的环林中环的个数，包括单点。我们还要乘以来自于 $-A$ 前符号的贡献，也就是对于每个 $\pi$ 生成的环林中非单点的环，要减去其长度。则 $c+\sum l-n$，也就是 $c$ 减去单点个数，也就是 $\pi$ 生成的环林中非单点的环的个数。这正是我们想要的。

---

接下来回到这个题。一个内向基环树森林本质上就是一个序列，只不过这次要求的是 $2^{c_1}0^{c_0}$，其中 $c_0,c_1$ 为偶环和奇环的个数，容斥到每种环的钦定方案上，那系数就是 $(-1)^{c_0}$。而这恰和逆序对的奇偶性相吻合！具体地，对于一个排列 $\pi$，它的不动点可以是没有钦定的，也可以被钦定成一个自环，而其它的必须是环。换言之，设

$$
A_{i,j}=\begin{cases}0&j=p_i\\1&\text{otherwise}\end{cases}
$$

类似定义出度矩阵 $D$，在这个题里即为 $\operatorname{diag}(n,n-1,n-1,\cdots,n-1)$，则答案即为 $\det(D+A)$。

到这里可能可以直接消元做，不过不会了啊。考虑反向利用矩阵树定理，我们要求的就是以下的图中以 $0$ 为根的内向生成树的权值积的和，其中括号内是权值。不过在此之前我们先消一下，把 $D+A$ 的每一行都减去第一行。由此得到：

$$
1\to i(-1),2\le i\le n\\
i\to1(n),2\le i\le n\\
i\to p_i(1),2\le i\le n\\
i\to 0(-2),2\le i\le n\\
1\to 0(2n)
$$

考虑选定了所有要选的树边（$i\to p_i(1)$）之后会怎么样。设现在所有非 $0$ 点组成了 $c$ 个连通块，其中 $1$ 所在的连通块大小为 $s$。那么，如果 $1\to 0$，那剩下 $c-1$ 个连通块的根都可以连向 $0$ 或 $1$，总贡献为 $(2n)(n-2)^{c-1}$。否则，$1$ 连向的不能是 $s$ 个点中的任意一个，且那个点所在连通块的根必须连向 $0$。因此总贡献为 $(n-s)\cdot(-1)\cdot(-2)\cdot(n-2)^{c-2}=2(n-s)(n-2)^{c-2}$。

显然，在所有 $2^{n-1}$ 种选树边的方案中，如果选了 $r$ 条树边，则会有 $n-r$ 个连通块，因此前半部分的贡献之和为 $2n(n-1)^{n-1}$。对于后半部分，考虑拆贡献，枚举不在 $1$ 所在连通块内的点 $q$，设深度为 $dep$，不要求它不在的总贡献为 $\dfrac{2}{n-2}(n-1)^{n-1}$，而它和 $1$ 相连的总贡献为 $\dfrac{2}{n-2}(n-1)^{n-1-dep}$，因此设点 $i$ 的深度为 $dep_i$，答案为

$$
2n(n-1)^{n-1}+\sum_{i=1}^n\dfrac{2}{n-2}((n-1)^{n-1}-(n-1)^{n-1-dep_i})
$$

化简为

$$
\boxed{\dfrac{2}{n-2}\left(n(n-1)^n-\sum_{i=1}^n(n-1)^{n-1-dep_i}\right)}
$$

注意特判 $n=2$。时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll mod1=998244353;
int n,p[100005],dep[100005];
ll pw[100005];
ll ans;
int main()
{
	ios_base::sync_with_stdio(false);cin.tie(0);
	cin>>n;
	if(n==2){cout<<"6\n";return 0;}
	dep[1]=0;pw[0]=1;for(int i=1;i<=n;++i)pw[i]=pw[i-1]*(n-1)%mod1;
	ans=n*pw[n];
	dep[1]=n-1;ans-=pw[n-1];
	for(int i=2;i<=n;++i)
	{
		cin>>p[i];dep[i]=dep[p[i]]-1;ans=ans-pw[dep[i]];
	}
	ans=ans*2%mod1;if(ans<0)ans+=mod1;
	while(ans%(n-2))ans+=mod1;
	ans/=n-2;
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Rainbow_qwq (赞：6)

假设给定一张任意图，我们怎么做这个问题？

构造 $n\times m$ 矩阵 $M$，若第 $i$ 条有向边为 $(u,v)$ 则设 $M_{u,i}=M_{v,i}=1$，其余 $M_{j,i}=0$。（这就是把 Matrix-Tree 定理构造中的 $-1$ 改成了 $1$）

设 $L=MM^T$ 为 $n\times n$ 矩阵。则 $\det(L)$ 为题目要求的结果。

----

证明：（建议先了解 Matrix-Tree 定理证明）使用 Cauchy-Binet 定理，变成选择 $\{1,2,\cdots,m\}$ 的一个 $n$ 大小的子集，即取 $n$ 条边。

然后就会形成一个基环树，生成对应的矩阵，对矩阵高斯消元求 $\det$。不是环上边的就会被消元干掉，其中环的矩阵形如:

$$\begin{bmatrix}1  & 1 & 0 & 0 \\0  & 1 & 1 & 0\\0  & 0 & 1 & 1 \\1  & 0 & 0 & 1\end{bmatrix}$$

对于偶环，消元后矩阵为 $0$；对于奇环，消元后答案是 $2$，于是系数恰好对应。

----

然后 $L_{i,j} = e_{i,j}+[i=j]\operatorname{deg}_i$，$\operatorname{deg}_i$ 为 $i$ 的出边数量。这里和 Laplace 矩阵的区别仅在于正负号。

接下来要求解 $\det(L)$，普通图只能 $O(n^3)$，但题目中的图为完全图去掉一棵树，有更优解法。

考虑将 $L$ 表示成 $A+J$，其中 $J$ 为 $n\times n$ 全 $1$ 矩阵，$A$ 为如下定义：

- $A_{1,1}=n$
- $A_{i,i}=n-1 (2\le i\le n)$
- $A_{i,p_i}=-1$
- 其余位置为 $0$

然后就是求 $\det(A+J)$，这是求一个矩阵加一个秩为 $1$ 的矩阵的 $\det$，可以上 Matrix Determinant Lemma：

$$\det(A+uv^T) = \det(A) + v^T \operatorname{adj}(A) u$$

设 $u,v$ 为全 $1$ 向量于是 $uv^T = J$。其中 $\operatorname{adj}(A)$ 为 $A$ 的伴随矩阵。

而 $A$ 是下三角矩阵，$\det$ 为对角线乘积。

$\operatorname{adj}(A)$ 的每个元素贡献为 $1$；每个元素为删去第 $i$ 行、第 $j$ 列，得到子矩阵的行列式，乘上 $(-1)^{i+j}$。

手搓一下删去哪些位置是可行的：

假设删去 $A_{i,j}$ 所在行、列。则剩余矩阵的行列式通过枚举排列的方式展开，得到如下结论：

- 删去 $i>j$，即完全为下三角的部分，贡献为 $0$。
- 删去对角线的一个元素，贡献为对角线上其他元素乘积。
- 删去 $i<j$：若 $i$ 不是 $j$ 的祖先则贡献为 $0$。否则贡献为：除了 $j\to i$ 路径上的点，其他点的"点权"乘积，这里 $i$ 的"点权"定义为 $A_{i,i}$。

这里大致说明一下是怎么推的：

假设建立一张有向图 $G$，其中 $i\to j$ 的边权是 $A_{i,j}$。

通过枚举排列的方式展开行列式，可以得到：贡献不为 $0$ 的排列是选图中的若干个环，其边权的乘积，再乘上一个逆序对数。

如果删掉第 $i$ 行第 $j$ 列（即求 $\operatorname{adj}(A)$），可以看作在图上加了一条 $i\to j$ 的边并且要强制选，其余边任意选，最终也要形成若干个环。

那不为 $0$ 的贡献只能是：$i$ 是 $j$ 的祖先，$j\to  i$ 的链形成一个环，其他点形成自环。

于是得到上面的结论（"点权" $A_{i,i}$ 就是自环权值）。

值得注意的是，$A_{i,p_i}=-1$，经过推导发现这里和逆序对产生的 $-1$ 互相抵消了，最后每种方案贡献系数都是 $+1$。

----

$A_{1,1}$ 为 $n$，其余每个点 $A_{i,i}$ 都是 $n-1$，于是每个贡献都为 $(n-1)^k,(n-1)^k\times n$ 的形式。

于是统计每种长度的链有多少个、以及特判以 $1$ 为链顶的链即可。时间复杂度 $O(n)$。

```cpp
#define maxn 300005
#define inf 0x3f3f3f3f

int n,m,p[maxn],dep[maxn];
modint res,ipw[maxn];
int c[maxn];

signed main()
{
	n=read();
	For(i,2,n)p[i]=read();
	For(i,2,n)dep[i]=dep[p[i]]+1;
	
	ipw[0]=1;
	ipw[1]=1; ipw[1]/=n-1;
	For(i,2,n+1) ipw[i]=ipw[i-1]*ipw[1];
	
	modint mul=n;
	For(i,2,n)mul*=n-1;
	
	res+=mul;
	
//	cout<<"res "<<res.x<<endl;
	
	modint ivn=1; ivn/=n;
	
	For(i,1,n){
		c[dep[i]]++;
	//	For(j,1,dep[i]) res+=ipw[j]*mul;
		res+=ipw[dep[i]]*ivn*mul;
//		int u=i,len=1;
//		while(u){
//			modint tmp=0;
//			if(u!=1) tmp+=ipw[len]*mul;
//			else tmp+=ipw[len-1]*ivn*mul;
//	//		cout<<"i,u "<<i<<" "<<u<<" "<<tmp.x<<endl;
//			res+=tmp;
//			++len,u=p[u];
//		}
	}
	Rep(i,n,1) c[i]+=c[i+1];
	For(i,1,n) if(c[i]) res+=c[i]*ipw[i]*mul;
	cout<<res.x;
	return 0;
}
/*

*/
```

---

## 作者：tobie (赞：6)

我嘞个容斥仙人啊！

首先这个 $2^{\mathrm{cnt}}$ 就很奇妙，考虑赋予其一个组合意义：每个环要么选上，要么不选。注意到这里可以顺便容斥掉出现偶环的情况。具体地，选出一个偶环乘上 $-1$，选出一个奇环乘上 $1$，则存在奇环的图都会被我们容斥掉。

假设我们选出的环上的点的集合为 $S$，显然 $1\in S$，则剩下的点不能和父亲连边，有一个 $(n-1)^{n-|S|}$ 的贡献，对于 $1\notin S$ 可能需要特殊处理。

交换求和顺序，我们先钦定 $S$，考虑 $S$ 内部的贡献 $f(S)$。

#### Lamma 1：如果不考虑树边，则 $f(S)=[|S|=1]$。

> 证明：
>
> 考虑**构造双射**：交换编号最小节点和编号最大节点的出边。
>
> 此时会有两个环合并成一个大的环，或者一个大环被拆成两个小环，偶环个数奇偶性必然改变。
>
> 所以若 $|S|>1$，则 $2f(S)=0$，进而 $f(S)=0$。

现在我们把没有考虑到的条件加回来。首先钦定的树边肯定是若干条链，把链缩起来后可以得到偶链和奇链，可以缩点成为奇点和偶点。稍加推理可以得到第二个重要性质。

#### Lamma 2：考虑树边的情况下，$f(S)=1$ 当且仅当 $S$ 是一个祖先后代链。

> 证明：
>
> 如果缩点后存在至少两个点，则 $f(S)=0$，所以现在只有一个点，并且和 $S$ 有关的所有树边都需要被钦定。
>
> 如果这个点是偶点，则有奇数条被钦定的边；如果这个点是奇点，则有偶数条被钦定的边，所以总共有偶数个 $-1$ 相乘，贡献为 $-1$。

所以我们只需要统计出长度为 $d$ 的链有多少条，带入公式计算即可，时间复杂度线性。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+9,mod=998244353;
int n,dep[N],tj[N];
int pw[N],ans;
signed main()
{
	scanf("%d",&n);
	for(int i=2,x;i<=n;i++) scanf("%d",&x),dep[i]=dep[x]+1;
	for(int i=1;i<=n;i++) tj[dep[i]]++;
	for(int i=n;i>=1;i--) (tj[i]+=tj[i+1])%=mod;
	pw[0]=1;
	for(int i=1;i<=n;i++) pw[i]=1ll*pw[i-1]*(n-1)%mod;
	ans=1ll*pw[n-1]*n%mod;
	for(int i=1;i<=n;i++) (ans+=pw[n-dep[i]-1])%=mod;
	for(int i=1;i<n;i++) (ans+=1ll*pw[n-i-1]*tj[i]%mod*n%mod)%=mod;
	(ans+=tj[n])%=mod;
	printf("%d\n",ans);
}
```

---

## 作者：KingPowers (赞：5)

非常人类智慧的一道题，感觉这辈子都想不到一点/ll。

$2^{\text{cycle}}$ 这种东西看上去很难处理但实际上很有转化空间，考虑用一些手段把它干掉。具体来说，对于一张确定的图 $G$，我们这么编故事：枚举 $G$ 的点集 $S$，并要求 $S$ 内的点的导出子图形成若干个不交的环且满足不存在树边的限制，再定义 $f(S)=(-1)^{even}$，其中 $even$ 为 $S$ 导出子图里偶环数量。

有什么用呢？我们发现此时对于任意的图 $G$ 来说，$\sum f(S)=[G\text{ 中不存在偶环}]$，这是因为当 $S$ 里面存在偶环的时候，我们可以去掉其中的一个偶环，则两个点集的偶环个数奇偶性正好相反且贡献抵消，更严谨地说明是考虑到有 $[even=0]=\sum_{i=0}^{even}\binom{even}{i}(-1)^i$，所以这么转化是正确的。

现在我们成功去掉了偶环的限制，只需要对所有 $G$ 的 $\sum f(S)$ 求和即可。考虑交换求和顺序，枚举一个点集 $S$，计算所有 $G$ 对 $S$ 的贡献是什么。

首先对于 $S$ 外的点的连边方案是容易算的，只需要保证每个点不连向它在树上的父亲即可，当 $1\in S$ 时方案数是 $(n-1)^{n-|S|}$，否则是 $n\times (n-1)^{n-|S|-1}$，现在要解决的是 $S$ 内在满足没有树边限制时的方案。

先退一步想，如果 $S$ 内不需要满足非树边的限制贡献应该是啥。事实上我们有，当且仅当 $|S|=1$ 的时候会有 $1$ 的贡献，否则可以通过构造双射的方式把 $S$ 的贡献消成 $0$。具体来说，考虑 $S$ 中编号最小的两个点，交换它们的出边，生成的环就会产生分裂或者合并，此时类比置换环可知偶环个数的奇偶性一定会改变，所以贡献抵消。

不妨继续对非树边的限制进行容斥，钦定 $S$ 内必须连若干条树边（假设钦定了 $e$ 条边），并分配上 $(-1)^e$ 的容斥系数。容易发现，我们钦定的树边必须在树上构成若干条祖先后代的链，否则会存在入度大于 $1$ 的点使得无法构成环。进一步地，发现这些链可以缩成一些单点，按照链上点数的奇偶性将缩完之后的点分为奇点和偶点。我们注意到，缩点后的问题和上面不要求非树边限制的情况是很像的，如果缩点后有超过 $1$ 个点可以使用同样的方式构造双射把贡献消掉，所以只有缩点后是单点，也就是钦定了树上一条祖先后代链的时候才可能有贡献（还可以发现，这时候 $S$ 必须正好是这条链上的点）。

那如果缩点后是一个单点贡献应该是什么呢？如果剩下的点是奇点，此时我们钦定了偶数条边所以容斥系数是 $1$，形成了一个奇环所以 $f(S)=1$，相乘得到贡献是 $1$；如果剩下的点是偶点，此时我们钦定了奇数条边所以容斥系数是 $-1$，形成了一个偶环所以 $f(S)=-1$，相乘得到贡献是 $1$。

现在终于得到了最终的结论：当且仅当 $S$ 是树上的一条祖先后代链的时候才会对答案产生贡献，此时给答案累加上 $S$ 外的点连边方案数即可。因此我们只需要知道树上每个长度的祖先后代链有几条就可以直接算答案了，这是容易的，当然可能要判下 $1$ 号点在链里的情况，可以做到 $O(n)$。

这题的每一步构造都太巧合了啊，怎么回事哦？？

---

## 作者：Chenliy (赞：4)

提供一种不一样的思路。

先将 $2^{环的数量}$ 拆成枚举环的集合的子集，将奇环权值设为 $1$，偶环权值设为 $-1$，一个子集的贡献就是其中环的权值的乘积。转化为枚举一个点集，代表钦定这个点集在环上，计算该点集所有连成若干个环的连边方式的贡献和。

发现如果交换两个点的出边，那么对答案的贡献必然取反。考虑构造如下双射：

- 设该点集中最小编号的点为 $mn$，次小编号的点为 $se$，交换 $mn$ 和 $se$ 的出边。

观察到在大多数情况下都是能抵消掉的，无法抵消掉当且仅当 $mn \to mn$ 且 $p_{se}=mn$。观察去掉最小编号点的点集，发现仍然可以仿照上述方式进行双射。

发现对答案有贡献的情况只有点集为树上的一条祖先后代链，且每个点的出边都指向自己，贡献为 $1$。

---

## 作者：Purslane (赞：3)

# Solution

模拟赛遇到一个类似的东西，不过我当时的做法完全不能套用过来啊。

-------

这种问题肯定考虑容斥。具体的，钦定若干个 $i \to fa_i$ 存在之后，会得到若干连通块。现在你要把连通块拼成若干基环树，要求每个环上有若干个节点。

发现每个连通块，要么没有点在环上，要么是一条到根的链在环上，我们提出这条链考虑。

显然，链可以直接等价为一个点（长度为奇数）或者两个点（长度为偶数）。

我们组成的环长度也有奇数有偶数。考虑容斥掉偶数的情况。非常经典的，对于**钦定出来的**每个长度为偶数的环，给一个 $-1$ 的贡献。这样但凡有长度为偶数的环，最终总贡献都是 $0$。

怎么给奇环赋贡献呢。。。考虑到 $2^c = \sum_{i=0}^c \binom{c}{i}$。所以我们直接把 $1$ 当做贡献就行了！

先看只有大小为 $1$ 的点的情况。容易写出 $f_n$ 表示 $n$ 个点划分成若干个环，偶环给 $-1$ 的贡献，奇环给 $1$ 的贡献的贡献之和。因此有

$$
dp_n = \sum_{s=1}^{n-1} (-1)^{s+1} \binom{n-1}{s-1} dp_{n-s}
$$

打表发现，它等于 $[n \le 1]$。归纳易证。

而如果有大小为 $2$ 的点呢？发现我们将一个大小为 $2$ 的点从一个环中剥离。这样原环的贡献不变，而凭空多出来一个 $-1$ 的贡献。所以~~猜测~~可以证明，无论如何都只在 $n \le 1$ 时产生贡献。

显然不只是环上才有点对不对，还有树边。不过其他未被选择的连通块不一定就不在环上——他们的出边是随便的。

因此，我们流程如下：

1. 钦定某些边在图 $G$ 中存在，有 $2^n$ 种情况，注意乘上每条边的容斥系数；
2. 找到一个连通块（或者 $0$ 个），选择一条经过根的链，将其钦定在环上；
3. 假设有 $c$ 个连通块，钦定边带来的容斥系数是 $(-1)^{n-c}$。选出边的贡献是 $n^{c-1}$。然后还有你选的链的大小，要乘上 $(-1)^{len}$。

感觉这个事情中“链”是主要的，所以考虑枚举链。

那么其他边都可以选择钦定或者不钦定。不钦定，就让 $c$ 增加 $1$（初始是 $1$），也就是多一个 $n$；钦定，就乘上 $-1$。而链内部的贡献一定是 $1$，可以不管了。

所以，假设我们钦定了 $k$ 条边在链上，其他的 $n-1-k$ 条边分别产生 $n-1$ 的贡献，乘上 $(n-1)^{n-1-k}$ 即可……吗？

注意到，如果这条链的根节点不是 $1$，那么**根节点和他的父亲的连边必须不钦定**。所以还要分类讨论一下，不过并不困难！

复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10,MOD=998244353;
int n,fa[MAXN],dep[MAXN],ad[MAXN][2];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,2,n) cin>>fa[i],dep[i]=dep[fa[i]]+1;
	ffor(i,1,n) ad[dep[i]][0]++,ad[0][1]++,ad[dep[i]][1]--;
	ffor(i,1,n) ad[i][1]+=ad[i-1][1];
	int ans=0;
	ffor(k,0,n-1) ans=(ans+qpow(n-1,n-1-k)%MOD*ad[k][0])%MOD;
	ffor(k,0,n-2) ans=(ans+qpow(n-1,n-2-k)%MOD*n%MOD*ad[k][1])%MOD;
	ans=(ans+qpow(n-1,n-1)*n)%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：chroneZ (赞：3)

很厉害的题。

对于 $C^k$ 形式的贡献，有经典技巧是将其拆成 $\sum \limits_{i = 0} ^ k \binom k i (C - 1)^{i}$，从而转化为钦定 $i \in [0, k]$ 个结构并带上 $(C - 1)^i$ 的系数计算方案数的问题。

对于本题同理，我们考虑计算钦定若干个奇环的形态时，图 $G$ 的方案数之和，容易发现这等价于题目所求。

但是还有一个限制是“图 $G$ 中不存在偶环”，我们发现这不好处理，所以考虑对这个条件容斥，每个偶环有 $-1$ 的容斥系数。那么干脆就同时钦定奇环和偶环的形态，假设我们钦定了 $x$ 个奇环和 $y$ 个偶环，那么带有 $(-1)^y$ 的系数，对所有情况求和，即可解决 $2^c$ 的贡献形式和“不存在偶环”这一限制。

> 也有一种思路是我们最后的贡献是 $2^x\red{0^y}$，然后这个东西可以转化为 $(\sum\binom x i 1^i)(\sum \binom y i (-1)^i)$，和上文中奇环带有系数 $1$，偶环带有系数 $-1$，然后转化为钦定意义下的问题是等价的。

假设我们钦定了点集 $S$ 中的点形成了若干个环，则点集外的点的连边方案数是 $(n - 1) ^ {n - |S|}$（在 $1 \notin S$ 的情况下是 $(n - 1)^{n - |S| - 1}n$）。问题来到怎么计算 $S$ 内的点的方案数（每个偶环还要贡献 $-1$ 的系数）。

注意到原题中“图 $G$ 中不存在边 $i \to p_i$”的限制此刻比较棘手，大概率还需要一个容斥，因此我们先忽略这个限制试试。记 $f(n)$ 表示 $n$ 个点的集合 $S$ 的方案数之和，则我们有

$$
f(n) = \sum_{i = 1} ^ n \binom{n - 1}{i - 1}f(n - i) (i - 1)! (-1) ^ {i - 1}
$$

简单解释一下，我们枚举 $i$ 表示钦定 $S_1$ 所在的置换环的大小，$\binom{n - 1}{i - 1}$ 是除 $S_1$ 外的点选法的方案数，$(-1)^{i - 1}$ 是偶环的系数，$(i - 1)!$ 是长度为 $i$ 的只有一个置换环的排列数。

一件令人惊喜的事情是，$f(0) = 1, f(1) = 1, f(n) = 0(n \geq 2)$。证明考虑归纳，对于 $n \geq 2$，有 $f(n) = (n - 1)f(1)(n - 2)!(-1) ^ {n - 2} + f(0)(n - 1)!(-1) ^ {n - 1} = 0$。也就是说，在不限制 $i \to p_i$ 边的情况下，$S$ 内部的方案数即为 $[|S|\leq 1]$。

现在再来考虑加上原限制。对于这条限制我们同样考虑容斥，即钦定一个边集 $E'$（$E'$ 是点集 $S$ 导出子图的边集的子集），容斥系数 $(-1)^{|E'|}$，由于我们需要 $S$ 形成若干个环，所以显然 $E'$ 应该构成了若干条链。显然可以将链缩成点，我们发现此时问题和刚才不限制 $i \to p_i$ 边时完全一致（当然链长的奇偶性会导致一些系数变化），那么刚才的结论现在也是可以用的！即将链缩为点后，如果剩下的点数大于等于 $2$，则方案数为 $0$。

剩余点数等于 $1$ 的情况对应的情况是简单的，即 $E'$ 将 $S$ 中的所有点连成了一条链。如果 $S$ 大小为奇数，那么 $|E'|$ 大小为偶数，最终的系数是 $1$，反之最终的系数也是 $1$。因此，当且仅当 $S$ 在原图上形成了一条链，$S$ 内部的方案数为 $1$。

我们统计原图上长为 $k$ 的不含有 $1$ 的链的数量 $s_k$，则这部分答案为 $\sum \limits_{i = 1} ^ {n - 1} s_i (n - 1) ^ {n - i - 1}n$。记 $d_i$ 为 $i$ 点的深度，$d_1 = 0$，则含有 $1$ 的链对答案的贡献是 $\sum \limits_{i = 1} ^ n (n - 1) ^ {n - d_i - 1}$。注意还有 $S = \varnothing$ 的情况，贡献是 $(n - 1) ^ {n - 1} n$。至此我们可以以 $\Theta(n)$ 的复杂度解决问题。

```cpp
// Such a destiny was not desired.
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

constexpr int mod = 998244353, N = 1e5 + 5;
namespace basic {
  template<typename T>
  inline int add(T x, T y) {return (x + y >= mod ? x + y - mod : x + y);}
  template<typename T, typename... P>
  inline int add(T x, P... y) {return add(x, add(y...));}
  inline int dec(int x, int y) {return (x - y < 0 ? x - y + mod : x - y);}
  inline void ad(int &x, int y) {x = add(x, y);}
  inline void de(int &x, int y) {x = dec(x, y);}

  inline int qpow(int a, int b) {
    int r = 1;
    while(b) {
      if(b & 1) r = 1ll * r * a % mod;
      a = 1ll * a * a % mod; b >>= 1;
    }
    return r;
  }
  inline int inv(int x) {return qpow(x, mod - 2);}

  int fac[N], ifac[N];
  inline void fac_init(int n = N - 1) {
    fac[0] = 1;
    for(int i = 1; i <= n; i++)
      fac[i] = 1ll * fac[i - 1] * i % mod;
    ifac[n] = inv(fac[n]);
    for(int i = n - 1; i >= 0; i--)
      ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
  }
  int invx[N];
  inline void inv_init(int n = N - 1) {
    invx[1] = 1;
    for(int i = 2; i <= n; i++)
      invx[i] = 1ll * (mod - mod / i) * invx[mod % i] % mod;
  }
  inline int binom(int n, int m) {
    if(n < m || m < 0) return 0;
    return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;
  }
}
using namespace basic;

int Pow[N];
int n, p[N], d[N], s[N];

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr), cout.tie(nullptr);
  
  cin >> n;
  Pow[0] = 1;
  for(int i = 1; i <= n; i++) {
    Pow[i] = (ll)Pow[i - 1] * (n - 1) % mod;
  }
  for(int i = 2; i <= n; i++) {
    cin >> p[i];
    d[i] = d[p[i]] + 1;
    s[d[i]]++;
  }
  int ans = 0;
  for(int i = n - 1; i >= 1; i--) {
    s[i] += s[i + 1];
    ad(ans, (ll)s[i] * Pow[n - i - 1] % mod * n % mod);
  }
  ad(ans, (ll)Pow[n - 1] * n % mod);
  for(int i = 1; i <= n; i++) {
    ad(ans, Pow[n - d[i] - 1]);
  }
  cout << ans << "\n";
}
```

---

## 作者：vegetable_king (赞：3)

[可能更好的阅读体验](https://yjh965.github.io/post/agc070b-odd-namori-ti-jie/)

唉，终究还是无法战胜。

首先看到这个 $2^{cyc}$ 就非常的神秘啊，考虑赋予他一个组合意义。我最开始想的是环长为奇数的时候尝试构造一个 $2$ 的系数，否则构造出一个 $0$ 的系数，但是这个太难编了，根本编不出来。那么我们考虑另一种思路：再另外乘上一个选环方案，每个环都可以选或不选。

设 $o$ 表示奇环的个数，$e$ 表示偶环的个数，那么我们将 $2^{cyc}$ 改写成 $2^o[e = 0]$ 就能干掉第二个限制。那么 $[e = 0] = \sum_{i = 0}^e \binom ei (-1)^i$，所以我们就可以改编上述思路：再另外乘上一个选环方案，每个环都可以选或不选，奇环系数为 $1$，偶环系数为 $-1$，那么就只剩下第三个限制了。

考虑交换求和顺序，先钦定节点集合 $S$ 内部组成若干个环，那么剩下的节点的系数就好算了，显然是 $(n - 1)^{n - |S|}$。

考虑 $S$ 内部的贡献。若没有 ban 边这个限制，那么 $|S| = 1$ 时答案显然为 $1$，否则都为 $0$。这可以由一个双射导出：考虑将一个置换环拆开，或将两个置换环合并，都会使得偶环个数的奇偶性改变。具体构造双射考虑 $1, 2$ 是否在同一置换环中即可。

若有 ban 边这个限制，考虑继续对 ban 边进行容斥，即强制钦定 ban 的边被选并乘上 $-1$。那么这么钦定之后合法情况一定是一堆链。显然奇链和前面的单点等价，所以我们考虑偶链。考虑在 $c$ 条链，目前答案为 $tot$ 的情况下插入一条偶链的影响，要么自己新开一个环并乘上 $-1$，否则不变。注意后者有 $c$ 种方案。那么 $tot$ 实际上相当于乘上 $(c - 1)$。先插入所有奇链再插入偶链，那么若奇链条数 $> 1$ 时答案本来就是 $0$，插入偶链并不会带来任何影响。若奇链条数 $= 1$ 时插入偶链会使答案乘 $0$。若没有奇链且偶链长度 $> 1$ 也是同理。所以只有钦定到恰好组成一条链的情况答案不是 $0$。若链是偶链，那么钦定的边数是奇数，会乘两次 $-1$，恰好抵消掉了。所以我们得出结论：若 $S$ 在树上组成了一条链，那么 $|S|$ 内部的贡献为 $1$，否则为 $0$。

那么我们直接统计即可做到 $O(n)$。真搞不懂这种题怎么出出来的。

[code](https://atcoder.jp/contests/agc070/submissions/61273117)

---

## 作者：Moeebius (赞：1)

> 好题啊，就是太难了/ll

每个顶点出度为 $1$ 显然是内向基环森林。

首先这个 $2^{环数}$ 看着就不太能要。直觉上应该是每个环有一个权值乘起来。又因为我们不能有偶环，所以考虑令奇环权值是 $2$ 偶环权值是 $0$。但是这样依然不好做，“平衡”一下，得到奇环权值是 $(1+1)$ 偶环权值是 $(1-1)$，也就是说一个有 $k$ 个点的环权值是 $(1-(-1)^k)$，一张图的权值就是每个环权值乘起来。

这个东西是有组合意义的：它相当于，每个环可以选也可以不选，选的话权值就要乘上 $(-1)^{环上点数+1}$。假设我们枚举被选的环上点集 $S$，不难验证对于任意一种将其划分成若干环的并的方案，其权值均为 $(-1)^{偶环个数}$。不妨记将 $S$ 划分成若干环的所有方案权值和为 $f(S)$。

这有什么性质呢？**假设忽略“不包含 $i \rightarrow p_i$ 的边“的限制**，通过打表等方法可以发现 $f(S)$ **几乎总是 $0$**。

具体地，我们有下列结论：

**在不考虑“不包含 $i \rightarrow p_i$ 的边“的限制时**，$f(S)=[|S| \le 1]$。

证明考虑构造双射：不妨令 $S$ 中最小的两个元素是 $1$ 和 $2$，假设一组方案中他们位于同一环中，那么我们可以将这个环 split 成两个环，否则我们把他们所在的两个环 merge 成一个。这是一个不会映射到自己的对合，而且我们知道两种方案权值互为相反数，所以只要 $|S| \ge 2$ 权值就是 $0$。$|S| < 2$ 的情形是平凡的。

![](https://cdn.luogu.com.cn/upload/image_hosting/if0jmr1i.png?x-oss-process=image/resize,p_50)
![](https://cdn.luogu.com.cn/upload/image_hosting/kvo9d59m.png?x-oss-process=image/resize,p_50)

---

对于有连边限制的情形，考虑套一层容斥，在枚举完 $S$ 后再枚举一个集合 $T$，表示考虑 $S$ 划分方案时，选了 $T$ 中的非树边（故 $T$ 只能包含 $S$ 导出子图内的边）。容斥系数是 $(-1)^{|T|}$。

注意到强制要求选一些非树边就相当于把这些边对应的点缩起来。 首先如果选的不是若干条链一定没有贡献（因为都无法划分成若干环）；而且如果缩成多个点，依据上面的结论也没有贡献。所以我们只能选一条祖孙链。这样链上的点连边是唯一确定的，链外每个点有 $(n-1)$ 条出边可以选（特别的，根有 $n$ 条）。由于容斥系数和 $(-1)^{偶环个数}$ 抵消了，每条链的系数都是 $1$。等比数列求和。

注意需要特判 $n=2$，否则会除以 $0$。

一个小细节是，$T$ 为空有两种情况，一种是选了一个自环，还有一种是 $S$ 也为空。

```cpp
namespace {
constexpr ll MAXN = 1e5 + 5, mod = 998244353;
int n, fa[MAXN], dep[MAXN];
vector<int> T[MAXN];
ll ans = 0, inv;
void dfs(int x) {
  dep[x] = dep[fa[x]] + 1;
  if (x == 1)
    (ans += qpow(n - 1, n - 1, mod)) %= mod;
  else
    (ans += (ll(n) * qpow(n - 1, n - dep[x], mod) % mod) *
                ((qpow(n - 1, dep[x] - 1, mod) - 1) * inv % mod) +
            qpow(n - 1, n - dep[x], mod)) %= mod;
  for (int v : T[x]) {
    dfs(v);
  }
}
void Main() {
  read(n), inv = qpow(n - 2, mod - 2, mod);
  if (n == 2)
    return puts("6"), void();
  For(i, 2, n) read(fa[i]), T[fa[i]].eb(i);
  ans = n * qpow(n - 1, n - 1, mod) % mod;
  dfs(1);
  cout << ans << '\n';
}
} // namespace
```

---

## 作者：Felix72 (赞：0)

这是一道很好的容斥练习题，考察组合意义的运用、容斥状态的设计和一些数学直觉。

所求内容给我们的第一印象就是 $2^{cnt}$ 难以处理。显然，不可能对每个环个数都求出方案数 $f_{cnt}$，因此 $2^{cnt}$ 一定存在一些转化。因为其组合意义是在大小为 $cnt$ 的集合里选出一个子集的方案数，我们不妨把计数转化为如下流程：

- 先钦定若干个环，然后剩下的点随便连边，对方案数计数。（先不要考虑其他限制、复杂度、实现之类的问题）

这样，对于一种有 $cnt$ 个环的状态，我们就会对它计数 $2^{cnt}$ 次，刚好契合题目要求。

再考虑奇环的限制，我们需要让所有包含偶环的方案数最后被计数的次数为 $0$。我们可以在钦定环这一步中，每钦定一个偶环，就把方案的权值乘以 $-1$。这样，对于一个偶环集合，它的每个子集被计算一次，系数之和刚好是 $0$。

但环的奇偶性不是那么好判断的。不妨改成这样：每出现一个环，系数乘以 $-1$，并且每出现一条环上的边，也把系数乘以 $-1$。不难发现这是等价的。

接着考虑树的限制，还是一样的容斥，预先钦定若干条树边必须选，然后把系数乘以 $1$ 或者 $-1$。

于是，我们有了一个算法的大体框架（不考虑复杂度）：

- 先钦定若干条树边必须选；
- 再钦定这里面的某些树边为环边，设环边形成了 $k$ 条链；
- 枚举所有的 $k!$ 种情况，剩下既没有被钦定为必选树边，也没有被钦定在环上的点每个点有 $n$ 种连边方式；
- 乘上 $1$ 或 $-1$ 系数，计入答案。

最影响复杂度的是第三步枚举 $k!$ 种情况，但是可以证明 $k > 1$ 时贡献和为 $0$。具体见这个式子：

$$
\sum_{i = 1}^{n} {n \brack i} (-1)^i
$$

这东西在 $n > 1$ 的时候就是 $0$，用第一类斯特林数的递推式和组合意义构造双射等方法都可以证明。

于是最多只能钦定一段连续的环边，即一条祖先-后代链。于是就变成简单题了。枚举这条链的长度，计算对应的贡献即可。

当然把系数代入进去跑 DP 也是可以的，笔者就是这种方法。

```cpp
/* COA-V Call of the Neon Colors */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 100010, mod = 998244353;
inline void Plus(long long &now, long long add)
{now += add; while(now >= mod) now -= mod;}
inline long long qpow(long long a, long long b)
{
	long long res = 1;
	while(b) {if(b & 1) res = res * a % mod; b >>= 1, a = a * a % mod;}
	return res;
}
long long fac[N], inv[N];
inline long long C(int n, int m)
{
	if(n < m) return 0;
	return fac[n] * inv[m] % mod * inv[n - m] % mod;
}
inline void init_math()
{
	fac[0] = inv[0] = 1;
	for(int i = 1; i <= 100000; ++i) fac[i] = fac[i - 1] * i % mod;
	inv[100000] = qpow(fac[100000], mod - 2);
}

int n, fa[N]; long long f[N][3];

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout); 
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	init_math();
	cin >> n;
	for(int i = 2; i <= n; ++i) cin >> fa[i];
	for(int i = 1; i <= n; ++i) f[i][0] = f[i][1] = 1;
	for(int i = n; i >= 2; --i)
	{
		long long tmp[3];
		memcpy(tmp, f[fa[i]], sizeof(tmp));
		memset(f[fa[i]], 0, sizeof(f[fa[i]]));
		
		// 0 + 0
		Plus(f[fa[i]][0], tmp[0] * f[i][0] % mod * (n + (-1)) % mod);
		// 0 + 1
		Plus(f[fa[i]][1], tmp[0] * f[i][1] % mod);
		Plus(f[fa[i]][2], tmp[0] * f[i][1] % mod);
		// 0 + 2
		Plus(f[fa[i]][2], tmp[0] * f[i][2] % mod * (n + (-1)) % mod);
		// 1 + 0
		Plus(f[fa[i]][1], tmp[1] * f[i][0] % mod * (n + (-1)) % mod);
		// 1 + 1
		// 1 + 2
		// 2 + 0
		Plus(f[fa[i]][2], tmp[2] * f[i][0] % mod * (n + (-1)) % mod);
		// 2 + 1
		// 2 + 2
	}
	cout << (f[1][0] * n % mod + f[1][1] + f[1][2] * n % mod) % mod << '\n';
	return 0;
}
/*

*/
```

---

## 作者：zhouyuhang (赞：0)

赛时做了两个半小时不敌。感觉现在官方题解的切入角度对我来说不算自然，所以按照自己的赛时思路捋一捋。

首先考虑将 $2 ^ {\operatorname {cyc}}$ 写成从所有环中选出一个子集的形式，于是我们考虑计算有多少种合法方案使得集合 $S$ 形如若干环组合而成。记这个数为 $f(S)$，答案即为 $\sum _ S  f(S)$。

显然 $S$ 集合外连边的方案数是好算的，大概形如 $(n - 1) ^ {n - |S| - 1} (n - {[1 \in S]})$，所以我们只需对每个 $k$ 求出 $\sum _ {|S| = k} f(S)$。

先不管这些事，考虑怎样计算一个 $f(S)$。注意到合法的限定条件有两个，先对不能连树边施以容斥，这样我们绑定了树上的若干条链，不难发现限制就只剩下不能有偶环。做到这里就不难发现 $\mathcal O(\operatorname{poly}(n))$ 的 dp 做法，然而这并不能帮助我们做出这道题。

我们观察一下，在不容斥任何边的时候，问题形如有多少个排列不存在长度为偶数的置换环。对这个组合问题做一点简单的代数推导：答案的 EGF 即为 $F(z) = \exp \left( \sum _ {k = 0} \frac {z ^ {2k + 1}} {2k + 1} \right)$。相应的记只有偶环的排列为 $G(z) = \exp \left( \sum _ {k = 1} \frac {z ^ {2k}} {2k} \right)$。如果注意到 $\exp \left( \sum _ {k = 1} \frac {z ^ k} {k} \right) = \frac 1 {1 - z}$，就不难观察到 $G(z) = \frac 1 {\sqrt {1 - z ^ 2}}$，从而有 $F(z) = \frac 1 {G(z)} \cdot \frac 1 {1 - z} = \sqrt {\frac {1 + z} {1 - z}}$。这样的形式使得答案不仅与置换环的长度
$n$ 相关，还无法被简单拆开计算。但如果在上述过程中记录形成的链的个数，就几乎断绝了我们向线性推进的可能。

我们试着对 $F(z), G(z)$ 多做一点观察。注意到，$F(z) = (1 + z) G ^ 2(z)$，这就意味着如果我们将上述组合问题的描述改为，一个排列的贡献为 $(-1) ^ {\operatorname{even\ cyc}}$，答案就将变成 $[n = 1]$。我们惊喜的发现，对于原问题，我们并不需要再额外做任何事情，因为这样的组合意义无非就是对偶环这个限制先做了一遍容斥。所以现在来看看我们的成果：

- 对于没有对边的容斥限制的情况，我们已经知道修正定义后的 $f'(S) = [|S| \le 1]$。
- 而对于容斥成若干链的情况，尽管有链长有奇有偶，但是使用类似的推导方法可以得到完全相同的结果，即如果形成的链数大于 $1$，则有 $f'(S) = 0$。否则 $f'(S) = (-1) ^ {|S| - 1}$，但是注意到 $f'(S)$ 还要乘上对于边的容斥系数，抵消即为 $1$。关于这部分的证明，也可以参考其他题解中更加直观的组合意义。

于是，我们得到非常简明的结论：$f'(S)$ 当且仅当 $S$ 内点在内向数上构成一条链时为 $1$；否则其取值为 $0$。于是容易在 $\mathcal O(n)$ 复杂度内对每个 $k$ 算出 $\sum _ {|S| = k} f'(S)$，特殊处理包含 $1$ 的情况即可解决本题。

---


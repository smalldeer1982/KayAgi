# [AGC070C] No Streak

## 题目描述

Alice 和 Bob 进行了 $N$ 次猜拳。每次猜拳的可能结果包括「Alice 胜」、「Bob 胜」和「平局」。我们的任务是计算符合以下条件的猜拳结果有多少种，并输出总数对 $1000000007$ 求余数的结果：

1. 在 $N$ 次对战中，Alice 赢了 $A$ 次，而 Bob 赢了 $B$ 次。
2. Alice 不会连续赢两次，除非中间有平局。
3. Bob 也不会连续赢两次，除非中间有平局。
4. 在任一时刻，Alice 的累积胜场数不能少于 Bob 的累积胜场数。换句话说，对于每一次猜拳结束后（从第 1 次到第 $N$ 次），Alice 的胜场数始终大于或等于 Bob 的胜场数。

## 说明/提示

## 数据范围

- $2 \leq N \leq 2 \times 10^7$
- $1 \leq B \leq A$
- $A + B \leq N$
- $N, A, B$ 为整数

### 举例说明

1. 假设猜拳进行如以下顺序，则符合要求：
   - 第 1 次：Alice 胜。
   - 第 2 次：Bob 胜。
   - 第 3 次：Alice 胜。
   - 第 4 次：平局。
   - 第 5 次：Bob 胜。
   
   而以下顺序不符合要求，因为第 4 次时，Alice 的胜场数（1）小于 Bob 的胜场数（2）：
   - 第 1 次：Alice 胜。
   - 第 2 次：Bob 胜。
   - 第 3 次：平局。
   - 第 4 次：Bob 胜。
   - 第 5 次：Alice 胜。

2. 请记得在计算最终结果时，需要模数 $10^9 + 7$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
70 29 12```

### 输出

```
693209192```

## 样例 #3

### 输入

```
20000000 1234567 890123```

### 输出

```
566226457```

# 题解

## 作者：2008verser (赞：17)

题目可以转化为求平面上从 $(0,0)$ 到 $(a,b)$ 的路线数，每步向右或向上，中途停歇 $x$ 次，且

- 路线必须在 $y=x$ 下面。
- 不能不停歇朝一个方向走两次。

解决这道题的第一步是把对角线的限制给反射容斥掉。即设 $f(a,b,x)$ 表示没有对角线限制的答案。接下来就是怎么用它表示出要求的答案。

留意到 $f(a,b,x)$ 是有“不能立刻连续走”的限制的，所以我们熟悉的 $f(a,b,x)-f(a+1,b-1,x)$ 出现了问题。

因为翻转可能令 $f(a+1,b-1,x)$ 里头连续的转弯变为连续直行。

回忆反射容斥，是将 $(0,0)\to(b-1,a+1)$ 的路线（翻转其与 $y=x+1$ 首次相交以后的部分）映射到 $(0,0)\to(a,b)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/p6xuhoe2.png)

因此我们从需要被映射到的路线出发，考虑用哪些 $f(a+1,b-1,x)$ “周围”的函数值加出这一部分，并最终从 $f(a,b,x)$ 中减去。

（因为要数的是必越过 $y=x$ 的数目，所以不是 $f(a,b,x)$ 周围）

这部分路线（终点 $(a,b)$），按向上越过 $y=x$ 之后的行为分类，相加：

- 与 $y=x+1$ 相交后立刻右转。
- 与 $y=x+1$ 相交后停歇一下继续。此时可以随便走。

在翻转前对应着

- 与 $y=x+1$ 相交后立刻向上。

  我们算出 $f(a+1{\color{red}-1},b-1,x)$，它里面每种路线在首次与 $y=x+1$ 相交时我们塞一个向上走，即可与这里双射。

- 与 $y=x+1$ 相交后停歇。类似地对 $f(a+1,b-1,x{\color{red}-1})$ 塞一个停歇。但你会发现这个 $f$ 算不到翻转前：(上)(停)(上)，因为塞之前是连续的上。

  所以我们对 $f(a+1{\color{red}-1},b-1,x{\color{red}-1})$ 塞一个(停)(上)，形成漏掉的双射。

总之，答案等于 $f(a,b,x)-f(a,b-1,x)-f(a+1,b-1,x-1)-f(a,b-1,x-1)$。

最后一部分是求 $f(a,b,x)$。这个是比较简单的组合数。我们视野里忽略 $B$，剩下的就是若干 $XAXXAAXAAAXX$ 云云。

枚举 $i$ 对相邻的 $A$，看看有多少种“相邻的方法”，用 $X$ 隔开以后随意插 $X$。最后随意插 $B$（不能插到那 $i$ 组 $A$ 里）。
$$
f(a,b,x)=\sum_{i=0}^{a-1}{a-1\choose i}{x-(a-1-i)+a+1-i-1\choose a+1-i-1}{a+x+1-i\choose b-i}
$$

[AC 链接](https://atcoder.jp/contests/agc070/submissions/61297929)

---

## 作者：_LHF_ (赞：5)

首先设 $m=n-A-B+1$，也就是说序列会被平局分成 $m$ 段（可以存在空段）。

具体来说，每一段都可以通过如下方式生成：

先写下若干个 AB（可以为 0 个），然后可以在开头插入一个 B，可以在结尾插入一个 A。

我们枚举写下的 AB 的数量，然后问题转化成了如下形式：

设 $f(n,a,b)$ 表示长度为 $2n$ 的序列 $t$ 满足：

1. $\forall 0<i\le 2n,t_i\in\{0,(-1)^i\}$。
2. $\forall 0<i\le 2n,(\sum_{j=1}^it_j)\ge 0$。
3. $t$ 中 $1$ 的数量为 $a$，$-1$ 的数量为 $b$。

如果我们能够在 $O(n)$ 预处理后 $O(1)$ 计算单个的 $f(n,a,b)$，那么这题就做完了。

感受一下如何计算 $f(n,a,b)$，首先第一个位置一定不会选 $-1$，不妨假设剩余的位置随便选，**大胆猜想** $f(n,a,b)=\binom n a\times \binom {n-1} b\times k$，其中 $k$ 是一个分子分母都很有规律的有理数。

经过打表，可以发现：

$$k=\frac{(a+1)\times (n-b)-b\times (n-a)}{(a+1)\times (n-b)}$$

~~别问我咋发现的~~，于是这题就做完了。

可以发现，此时 $f(n,a,b)=\binom na\times \binom {n-1}b-\binom n{a+1}\times \binom{n-1}{b-1}$，所以理论上也可以强行编一个组合意义。

具体来说，我们参照翻折容斥，但翻折之后我们就不保证 $t_i\in\{0,(-1)^i\}$ 了，但可以发现可以通过循环位移使得 $t_i\in\{0,(-1)^{i+1}\}$，并且发现循环位移的过程是可逆且位移的。

---

## 作者：EuphoricStar (赞：3)

很深刻的反射容斥。

考虑把平局去掉，得到一个 AB 串，再把平局插进去。如果我们能算出，恰好有 $a$ 个 A，$b$ 个 B，$k$ 对相邻位置字符不同，且任意一个前缀的 A 数量不少于 B 数量的 AB 串的数量 $F(a, b, k)$，那么可以插板法计算平局插入进去的方案，就是 AB / BA 之间、开头或结尾可以插 $\ge 0$ 个平局，AA / BB 之间要插 $\ge 1$ 个平局。

所以答案为：
$$
\sum\limits_{i = 1}^n F(A, B, i) \times \binom{n - A - B + i + 1}{A + B}
$$
考虑如何算 $F(a, b, k)$。将其转化为网格图问题，即从 $(0, 0)$ 走到 $(a, b)$，折线不能触碰 $y = x + 1$ 这条直线，且折线恰好有 $k$ 个拐点的方案数。

设 $f(a, b, k)$ 为不考虑折线不能触碰 $y = x + 1$ 这个限制的方案数。那么现在 $a, b$ 两维是独立的，讨论 $k$ 的奇偶性之后插板法得到：
$$
f(a, b, k) =
\begin{cases}
2 \dbinom{a - 1}{\frac{k + 1}{2} - 1} \dbinom{b - 1}{\frac{k + 1}{2} - 1} & k \bmod 2 = 1 \\
\dbinom{a - 1}{\frac{k}{2} - 1} \dbinom{b - 1}{\frac{k}{2}} + \dbinom{a - 1}{\frac{k}{2}} \dbinom{b - 1}{\frac{k}{2} - 1} & k \bmod 2 = 0
\end{cases}
$$
那么 $F(a, b, k)$ 就是 $f(a, b, k)$ 减去触碰 $y = x + 1$ 的折线数量。

回忆**反射容斥**，即把 $(0, 0)$ 走到 $(b - 1, a + 1)$ 的折线翻转它和 $y = x + 1$ 首次相交之后的部分，和 $(0, 0)$ 到 $(a, b)$ 的不合法折线形成双射。

考虑一条从 $(0, 0)$ 到 $(b - 1, a + 1)$ 的折线，它和 $y = x + 1$ 首次相交后，会向右走若干步（可能为 $0$ 步）再向上走一步。把折线的这部分**删去**之后，它的拐点数和映射到的 $(0, 0)$ 到 $(a, b)$ 的那条不合法折线相比，**一定会减 $1$**，且删去之后仍然能构造双射。

因此对于一条 $(0, 0)$ 到 $(a, b)$ 且恰有 $k$ 个拐点的不合法折线，枚举它映射到的那条折线和 $y = x + 1$ 首次相交后向右走的步数，可得：
$$
F(a, b, k) = f(a, b, k) - \sum\limits_{i \ge 0} f(b - 1 - i, a, k - 1)
$$
后者可以通过组合数上指标求和 $O(1)$ 求出，于是 $F(a, b, k)$ 也可以 $O(1)$ 求出。

时间复杂度 $O(n)$。

---

## 作者：qiminghaonan (赞：0)

令人回味无穷。

# 题意简述

给定若干数量的字符 `A`，`B`，`C`，求将其拼接成一个字符串的方案数，对 $10 ^ 9 + 7$ 取模。满足如下限制条件：

- 不能包含子串 `AA` 或 `BB`。
- 任意前缀子串中，`A` 的数量不能超过 `B`。

# 反射容斥

先考虑通过反射容斥排除第二个限制。令 $f(a,b,c)$ 为共有 $a$ 个 `A`，$b$ 个 `B`，$c$ 个 `C`，满足第一个限制的方案数。

反射后的字符串中应当有 $b-1$ 个 `A`，$a+1$ 个 `B`，$c$ 个 `C`，以及一个关键字符 `B`，以它结尾的子串首次出现 `B` 的数量多于 `A` 的数量，它之后的字符串是反射过的。因此，它后面的字符是 `(B|C)` 而不是 `(A|C)`，需要将反射后的字符串进一步修改以正确计数。

- `...BB...` 的情况，再将它与 `...B...` 进行双射，方案数为 $f(b-1,a,c)$。
- `...BCB...` 的情况，再将它与 `...B...` 进行双射，方案数为 $f(b-1,a,c-1)$。
- `...BC(A|C)...` 的情况，再将它与 `...B(A|C)...` 进行双射，方案数为 $f(b-1,a+1,c-1)$。

这里，必须检查一下双射性：上述三种情况所计数的所有字符串都不满足第二个限制，也就是说关键字符 `B` 一定唯一存在。**只要满足了这一点，反射容斥的正确性就有保障，并且无需考虑边界情况，前提是 $f$ 在参数不合法时为 $0$。**

于是，答案就是 $f(a,b,c)-f(b-1,a,c)-f(b-1,a,c-1)-f(b-1,a+1,c-1)$。

# $f$ 的计算

如果能够直接看出其他题解所说的组合意义，自然是最好的；这里介绍使用生成函数的另一种方法，优点在于不用动脑子。具体来说，就是令 $F = \sum_{a,b,c \in \mathbb{N}}f(a,b,c)x^ay^bz^c$，所求变为 $\left[x^ay^bz^c\right]F$。

为了使用生成函数，我们需要找到 $f$ 满足的递推关系。事实上，$f(a,b,c)$ 所计数的字符串可以按照开头几个字符进行分类：

- `C...` 被 $f(a,b,c-1)$ 计数。
- `AC...` 被 $f(a-1,b,c-1)$ 计数。
- `AB...` 不是很直接，但你先别急。
- `BC...` 被 $f(a,b-1,c-1)$ 计数。
- `BA...` 可以和 `AB...` 合并。字符串的其余部分中，`A` 和 `B` 开头的被计数一次，而 `C` 开头的则需要被计数两次。总数可以表示为 $f(a-1,b-1,c) + f(a-1,b-1,c-1)$。

也就是说，$f(a,b,c)=f(a,b,c-1)+f(a-1,b,c-1)+f(a,b-1,c-1)+f(a-1,b-1,c)+f(a-1,b-1,c-1)$。进一步考虑边界情况，即可得到 $F=(z+xz+yz+xy+xyz)F+(1+x+y+xy)$，解得

$$F=\frac{(1+x)(1+y)}{1-z-xz-yz-xy-xyz}$$

接下来算系数。为了不破坏 $x$ 和 $y$ 的对称性，先对 $z$ 展开。

$$\left[z^c\right]F=\left(\frac{(1+x)(1+y)}{1-xy}\right)^{c+1}$$

这个式子如果是范围求值的话，可能有各种各样的处理技巧，但这里是单点求值，最好的办法就是分离分子分母再卷起来。

$$\left[x^ay^b\right]\left(\frac{1}{1-xy}\right)^{c+1}=\left[a=b\right]\dbinom{c+a}{c}$$

$$\left[x^ay^b\right](1+x)^{c+1}(1+y)^{c+1}=\dbinom{c+1}{a}\dbinom{c+1}{b}$$

$$\left[x^ay^bz^c\right]F=\sum_{k \in \mathbb{N}}\dbinom{c+k}{c}\dbinom{c+1}{a-k}\dbinom{c+1}{b-k}$$

实际计算的时候，当然只要加到 $\min(a,b)$ 就好了。

# 代码实现

AtCoder 的题目还要看代码的话，这辈子有了。

```cpp
#include <iostream>
using namespace std;
typedef long long ll;
int const N = 2e7 + 3;
ll const M = 1e9 + 7;
ll fact[N] = {1,}, inv[N] = {1,};
ll qpow(ll x, int y) {
  if (y < 0) return 0;
  ll ret = 1;
  for (int i = 0; y; i++) {
    if (y & (1 << i)) {
      y ^= 1 << i;
      ret = ret * x % M;
    }
    x = (x * x) % M;
  }
  return ret;
}
ll inverse(ll x) {
  return qpow(x, M - 2);
}
void gen(void) {
  for (int i = 1; i < N; i++) {
    fact[i] = fact[i - 1] * i % M;
  }
  inv[N - 1] = inverse(fact[N - 1]);
  for (int i = N - 2; i; i--) {
    inv[i] = inv[i + 1] * (i + 1) % M;
  }
}
ll c(int m, int n) {
  if (n < 0 || n > m) return 0;
  return fact[m] * inv[n] % M * inv[m - n] % M; 
}
ll f(int n, int a, int b) { //注意这里 f 的定义与文中不同！
  ll r = 0;
  for (int i = 0; i <= min(a, b); i++) {
    r += c(n - a - b + i, i) * c(n - a - b + 1, a - i) % M *
        c(n - a - b + 1, b - i) % M;
  }
  return r % M;
}
int n, a, b;
int main(void) {
  gen();
  cin >> n >> a >> b; 
  cout << (f(n, a, b) - f(n - 1, a, b - 1) - f(n - 1, a + 1, b - 1) -
      f(n - 2, a, b - 1) + 3 * M) % M;
  return 0;
}
```

---


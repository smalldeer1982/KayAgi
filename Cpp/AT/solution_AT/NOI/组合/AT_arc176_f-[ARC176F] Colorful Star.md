# [ARC176F] Colorful Star

## 题目描述

有一棵包含 $NM+1$ 个顶点的树，顶点编号为 $0$ 到 $NM$。第 $i$ 条边（$1 \le i \le NM$）连接顶点 $i$ 和顶点 $\max(i-N,0)$。

最初，顶点 $i$ 被染成颜色 $i \bmod N$。你可以进行如下操作任意多次（可以为 $0$ 次）：

- 选择通过一条边相连的两个顶点 $u,v$，将 $u$ 的颜色改为 $v$ 的颜色。

请你求出，经过若干次操作后，所有可能的树的方案数，答案对 $998244353$ 取模。注意，如果某个顶点的颜色不同，则认为是不同的树。

## 说明/提示

## 限制

- $1 \le N, M \le 2 \times 10^5$

## 样例解释 1

例如，可以考虑如下的操作序列。在包括这种情况在内，最终可能的树共有 $42$ 种。  
![](https://img.atcoder.jp/arc176/star.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 1```

### 输出

```
42```

## 样例 #2

### 输入

```
4 2```

### 输出

```
219100```

## 样例 #3

### 输入

```
20 24```

### 输出

```
984288778```

## 样例 #4

### 输入

```
123456 112233```

### 输出

```
764098676```

# 题解

## 作者：JWRuixi (赞：2)

### 题意

给定一棵 $nm + 1$ 个点的树，第 $i$ 个点连向 $\max(i - n, 0)$，颜色为 $i \bmod n$。你可以进行一下操作：选定一条边 $(u, v)$，令 $c_u = c_v$ 或 $c_v = c_u$。问经过若干次操作后能形成多少种不同的树，定义两棵树不同当且点的颜色不完全相同。

$n, m \le 10^5$。

### 分析

考虑 $n \le 2 \lor m \le 1$ 时答案是不言自明的，先行特判，以下认为 $n \ge 3, m \ge 2$。

正难则反，考虑逆序操作，即那些树的终止形态能返回初始状态。一个覆盖操作的逆即：**选定一条端点颜色相同的边，并将其中一个端点覆盖为任意颜色**（以下操作均指逆操作）。

定义一个边的深度为：距离 $0$ **较远**的点到 $0$ 的距离，称深度为 $i$ 的边组成的集合为第 $i$ 层。

由以上对逆操作的定义不难发现，端点颜色相同的边至关重要，我们称这种边为**快乐边**，按照快乐边数对终止状态分类有：

- 没有快乐边：一定无解；
- 有一条或两条快乐边（先通过若干次操作将快乐边移至第一层）：
  - $1, \dots, n$ 号节点的不同颜色数小于 $n - 1$ 或不同颜色数等于 $n - 1$ 且 $\exists 1 \le i \le n, n + 1 \le j \le 2n, c_i = c_j$（即存在一对第一层和第二层的点颜色相同）：一定有解；
  - 反之：一定无解；

- 有三条以上的快乐边：一定有解；

第一类是 trivial 的，第三类等价于第二类（一定能用若干次操作使其变成第二类），所以重点研究第二类：

- 有解条件**必要性**：考虑不符合条件的情况即颜色均不相同或第一层共 $n - 1$ 种颜色、第二层均为最后一种颜色，不难发现这种情况下，无论如何操作都无法使快乐边数增加，于是一定无解；
- 有解条件**充分性**：考虑若不同颜色数小于 $n - 1$，一定能牺牲掉一个重复的颜色使当前情况变成第二种情况，所以只用证明“有 $n - 1$ 种颜色且存在一对第一层和第二层的点颜色相同”的情况。

考虑用构造证明：首先通过第一层和第二层的同色对一定能形成一条长度为 $4$ 的链，我称它为**快乐链**，具体操作如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/urx0io14.png)![](https://cdn.luogu.com.cn/upload/image_hosting/8k2tu7en.png)![](https://cdn.luogu.com.cn/upload/image_hosting/jzn7iqjq.png)

考虑我们的目标实际上等价于：**同一条链上的点颜色相同**，交换两条链的操作是简单的，具体的可以先考虑正向操作在推反向操作。

设这个同色对为 $(u, v)$ 其中 $u$ 为第一层，$v$ 为第二层。考虑选择一个第二层的节点 $z$，满足 $c_z$ 在第二层出现的**次数最多**。将快乐链移动使得 $z$ 在它上面，考虑 $z$ 子树内最深的**不是该链目标颜色**的点，那么可以通过将第二层的那条边向下移动将它改为目标颜色。将快乐链的剩余三个点放回前两层后，由于我们选择的 $z$ 点的颜色数是极大的，所以一定还能满足判断有解的两个条件之一。不断重复该过程即可解决 $3 \sim m$ 层。第一、二层是 trivial 的。至此我们证明了充分性。 

统计答案我们考虑容斥掉不合法的部分，即第一层颜色互不相同，或第一层有 $n - 1$ 种颜色且第二层是剩下的一种颜色。

时间复杂度 $\mathcal O(n)$。

### Code

提交记录：<https://atcoder.jp/contests/arc176/submissions/52913935>。

---

## 作者：WrongAnswer_90 (赞：2)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18162228)

### [[ARC176F] Colorful Star](https://www.luogu.com.cn/problem/AT_arc176_f)

感觉很考验想象力和计数基本功 QWQ。

首先考虑给定了局面之后如何进行判定。考虑把覆盖的过程倒着做：如果 $i$ 旁边有和它颜色相同的棋子，那它就可以变成任意的颜色，然后要求最终能不能 $n$ 种颜色都只剩一种。

然后这个还是不太本质。考虑如果有一个能变成任意颜色的，可以把它变成周围的另一个颜色，然后另一个颜色就能变成任意的颜色。

![](https://s2.loli.net/2024/04/26/yz8rKSudvUiFgml.png)

这样可以看成是空位的移动。问题变成了：在棋盘上有 $n$ 种颜色的棋子和若干个空位。当两个同色棋子相遇的时候可以把其中一个变成空位，可以把棋子移动到相邻的空位。问最后能不能每种棋子只剩一个且分别待在正确的链上。

进一步分析：考虑有多少个空格的时候，不论棋盘形态如何，都能消完。显然把初始相邻相同的消掉之后，接下来的相同颜色的消除操作（下称合并）一定是在中间位置发生的。

考虑如果只剩一个，不合法当且仅当把空位移到中心点之后中心点周围颜色全不相同。

如果只剩两个，不合法当且仅当把空位移到中心点和它周围的一个点之后，周围颜色有 $n-1$ 种，且第二圈全部都是剩下的一种颜色。

![](https://s2.loli.net/2024/04/26/WkhuXzxPMv4ZpVD.png)

其中 $x$ 表示空位。

如果剩下了大于等于三个，则可以发现，能够通过若干个操作把周围两圈里的任意两个放到一起，判掉 $n\leq 2$ 的情况后，通过抽屉原理得一定能继续消，所以一定能消完。

接下来就是计数（下文中把图看成一棵以中心点为根的树）：

1. 初始没有空位，答案是 $n\times(n-1)^{nm}$。

2. 初始有一个空位，并且之后周围的颜色全部不同，答案是 $n!\times nm\times(n-1)^{n(m-1)}$。其中 $n!$ 表示把空格移到中间之后周围的一圈数字的顺序，$nm$ 表示选择哪个位置和其父亲颜色相同。这样用去了 $n+1$ 个位置，剩下的位置随便填。

3. 初始有两个空位，两个空位都是相邻相等的颜色消出来的。答案是 $n!\times \binom {nm} 2(n-1)^{n(m-2)}$。$n!$ 还是确定颜色的顺序，然后需要选两个位置和父亲相同,容易发现无论选哪两个位置都是合法的，譬如假如选了靠近根的两个点，那就代表这种情况：

![](https://s2.loli.net/2024/04/26/2HRmeFTzQf7Osb4.png)

其余的情况可以自行脑补。

由于需要确保中心点周围一圈都不同并且再外面一圈都是剩下的一种颜色，这样会用去 $n+(n-1)$ 个位置，然后选两个和父亲相同，剩下了 $nm-2n$ 个位置的方案数的唯一要求就是不能和父节点相同，$n-1$。

4. 初始有一个空位，把这个空位移到中间之后再生出一个空位。首先需要确定空位产生的位置 $nm$，然后从 $n-1$ 个子树里面选两个临近根的点作为两个颜色相同，把空位移上来能消掉的。然后还要确定颜色顺序的 $n!$，最后剩下的位置仍然是 $nm-2n$，所以答案为 $n!\times nm\times\binom {n-1}2\times (n-1)^{n(m-2)}$。

最后用总和减去这四种不合法的就是答案。需要特判 $n=1,n=2$ 和 $m=1$。

```cpp
int n,m,fr;
inline void mian()
{
	read(n,m),fr=1;
	for(int i=1;i<=n;++i)Mmul(fr,i);
	if(n==1)return write(1);
	if(n==2)return write(Cadd(Cmul(n,m),2));
	if(m==1)
	{
		int all=power(n,n+1);
		int x=Cmul(n,power(n-1,n));
		Madd(x,Cmul(n,Cdel(fr,1)));
		return write(Cdel(all,x));
	}
	int all=power(n,n*m+1);
	int x0=Cmul(n,power(n-1,n*m));
	int x1=Cmul(n,m,fr,power(n-1,n*m-n));
	int x2=Cmul(n,fr,power(n-1,n*m-2*n),m,m-1,inv2);
	Madd(x2,Cmul(fr,n,n-1,inv2,m,m,power(n-1,n*m-2*n)));
	Madd(x2,Cmul(fr,n,n-1,n-2,inv2,power(n-1,n*m-2*n),m));
	write(Cdel(all,x0,x1,x2));
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/AT_arc176_f)

**题目大意**

> 给定一棵 $nm+1$ 个点的树，由 $n$ 条长度为 $m$ 的链连到一个根节点上构成。
>
> 第 $i$ 条链上节点颜色为 $i-1$，根节点颜色为 $0$，每次操作可以把一个点的颜色设成其某个邻居的颜色，求能得到多少种颜色序列。
>
> 数据范围：$n,m\le 2\times 10^5$。

**思路分析**

倒序维护所有操作，一次操作会把一对相邻的同色节点中的一个任意染成其他颜色。

称这种可以任意染色的节点为自由节点，那么如果一次操作使用的是一个自由节点和一个颜色为 $c$ 的节点，实际上相当于交换两个节点的颜色。

因此我们可以把自由节点看成空位，节点的颜色看成一枚该颜色的棋子，那么操作就是把一枚棋子移动到相邻的空位上，或者把两枚相邻同色棋子中的一枚删掉。

我们最终的目的是让每种同色棋子都在一条链上。

手玩发现当空位 $\ge 3$ 时，我们可以把他们聚集在根节点附近，并且无论如何都能找到一步进行操作。

我们只需要考虑空位 $\le 2$ 的情况，反面考虑减去这种终态数量。

- 空位 $=0$，只要所有点和父亲不同色即可，方案数 $n(n-1)^{nm}$。

- 空位 $=1$，设空位在根节点上，那么要求每个儿子不同色。

  先给每个儿子填色，再枚举一对点颜色相同，剩余的和父亲不同色即可，方案数 $n!\times nm\times(n-1)^{(m-1)n}$。

- 空位 $=2$，设空位在根节点和其儿子上，那么剩余的 $n-1$ 个儿子必须不同色，且所有深度 $=2$ 的点都是剩下的那种颜色。

  如果初始就能生成两个空位，枚举产生位置，类似得到方案数 $n!\times\binom{nm}2\times (n-1)^{(m-2)n}$。

  否则相当于把第一个空位移动到根节点后，有两个儿子颜色相同，方案数 $n!\times nm\times\binom{n-1}2\times (n-1)^{(m-2)n}$

特判 $n\le 2,m\le 1$ 的情况。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=998244353;
ll ksm(ll a,ll b) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
ll C(ll x) { return x*(x-1)/2%MOD; }
signed main() {
	ll n,m,fac=1;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;++i) fac=fac*i%MOD;
	if(n==1) return puts("1"),0;
	if(n==2) return printf("%lld\n",n*m+2),0;
	if(m==1) {
		ll ans=ksm(n,n+1);
		ans-=n*ksm(n-1,n)%MOD;
		ans-=n*(fac-1)%MOD;
		printf("%lld\n",(ans%MOD+MOD)%MOD);
		return 0;
	}
	ll ans=ksm(n,n*m+1);
	ans-=n*ksm(n-1,n*m)%MOD;
	ans-=n*m%MOD*fac%MOD*ksm(n-1,n*(m-1))%MOD;
	ans-=C(n*m%MOD)*fac%MOD*ksm(n-1,n*(m-2))%MOD;
	ans-=n*m%MOD*C(n-1)%MOD*fac%MOD*ksm(n-1,n*(m-2))%MOD;
	printf("%lld\n",(ans%MOD+MOD)%MOD);
	return 0;
}
```

---


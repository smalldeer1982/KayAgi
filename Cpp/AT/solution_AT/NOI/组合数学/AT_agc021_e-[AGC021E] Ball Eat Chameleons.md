# [AGC021E] Ball Eat Chameleons

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc021/tasks/agc021_e

AtCoder 共和国では、カメレオン科ボールタベルカメレオン属に属するスヌケカメレオンがペットとして大人気です。 りんごさんは、$ N $ 匹のスヌケカメレオンの個体をひとつのカゴに入れて飼っています。

何も食べていない状態のスヌケカメレオンは青色です。スヌケカメレオンは、次の規則で変色します。

- 青いスヌケカメレオンは、これまでに食べた青いボールの個数よりこれまでに食べた赤いボールの個数の方が真に大きくなった時、赤色に変色する。
- 赤いスヌケカメレオンは、これまでに食べた赤いボールの個数よりこれまでに食べた青いボールの個数の方が真に大きくなった時、青色に変色する。

最初、スヌケカメレオンたちはどの個体も何も食べていない状態です。りんごさんは、スヌケカメレオンたちに、以下の手順を $ K $ 回繰り返すことで餌をやりました。

- 赤いボールまたは青いボールを握る。
- 握ったボールを、スヌケカメレオンたちの入ったカゴの中に投げ入れる。このとき、いずれか一匹がそのボールを食べる。

りんごさんが $ K $ 個のボールを投げ入れたところ、全ての個体が赤色になっていました。りんごさんの $ K $ 個のボールの投げ入れ方としてありうるものは何通りあるでしょうか。 $ 998244353 $ で割った余りを求めてください。ただし、$ 2 $ つの投げ入れ方が異なるとは、ある $ i $ が存在し、$ i $ 個目に投げ入れたボールの色が異なることを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ N,K\ \leq\ 5\ \times\ 10^5 $
- $ N,K $ は整数である

### Sample Explanation 1

$ i $ 個目に投げ入れるボールが赤のとき `R` を、青のとき `B` を順に並べた文字列を用いて投げ入れ方を表せば、 `BRRR`,`RBRB`,`RBRR`,`RRBB`,`RRBR`,`RRRB`,`RRRR` の $ 7 $ 個が条件を満たします。

## 样例 #1

### 输入

```
2 4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 7```

### 输出

```
57```

## 样例 #3

### 输入

```
8 3```

### 输出

```
0```

## 样例 #4

### 输入

```
8 10```

### 输出

```
46```

## 样例 #5

### 输入

```
123456 234567```

### 输出

```
857617983```

# 题解

## 作者：小粉兔 (赞：43)

既然是对球的颜色序列计数，那么就只需要考虑，对于每一个颜色序列，判断它是否可行。

假设总共喂了 $R$ 个红球和 $B$ 个蓝球，满足 $R + B = K$。

首先考虑一只变色龙在什么情况下最终才会变成红色：

1. 它吃的红球比蓝球多。
2. 它吃的红球和蓝球一样多（且不为 $0$ 个），但是吃的最后一个球是蓝球。

如果 $R < B$，也就是红球总数比蓝球少，那么显然无解。

如果 $R \ge B + N$，也就是红球比蓝球还多 $N$ 个，可以直接让每只变色龙吃的红球都比蓝球多，一定有解。

否则 $B \le R < B + N$，就只能让一些变色龙吃的红球和蓝球一样多，另一些变色龙红球吃的更多一些。

对于一种方案，我们进行调整：

- 如果某一只变色龙吃的红球比蓝球多两个以上，可以拿出一个红球分配给别的变色龙。

这样调整之后，就一定是：一些变色龙吃的红球比蓝球多**恰好一个**，另一些一样多。

令 `R` 表示一个红球，`B` 表示一个蓝球。

也就是恰好有 $R - B$ 只变色龙多吃一个 `R`，其它 $N - (R - B)$ 只变色龙吃的一样多。

如果 $R = B$，也就是 $R - B = 0$，不存在多吃一个 `R` 的变色龙，那么考虑吃掉了最后一个球的变色龙，那么最后一个球必然是 `B`，那么去掉这个蓝球，就等价于 $(R, B - 1)$ 的情况。

那么现在就至少有一只变色龙多吃一个 `R`，对于吃的一样多的变色龙，可以再调整：

如果它吃的不是恰好两个球（`RB`），那么可以在最后一个字符前取出一个 `R` 和一个 `B`，分给多吃了一个 `R` 的变色龙。

那么现在就变成了，每只吃的红球和蓝球一样多的变色龙，吃球的顺序都是 `RB`，它们的个数为 $N - (R - B)$。

然后剩下的 $R - B$ 只变色龙，就可以直接每只多吃一个 `R` 然后满足条件了。

综上所述：对于 $B < R < B + N$ 的情况，满足条件当且仅当能够取出 $N - (R - B)$ 对 `RB`（有顺序）的子序列。

这等价于：对于每个前缀，这个前缀中的蓝球比红球**最多**多 $B - (N - (R - B)) = R - N$ 个。  
（就是说这个前缀中无法参与匹配的蓝球数量不能超过 $R - N$ 个）

换句话说，令 `R` 为 $+1$，`B` 为 $-1$，则任意一个前缀和都应该要大于等于 $-(R - N)$。

可以看成从 $(0, 0)$ 向右（`R`）或向上（`B`）走到 $(R, B)$，但是不能到达直线 $y = x + (R - N)$ 的严格上方。

这是一类经典的组合问题，类似于卡特兰数的计算方法（翻转第一次碰到直线上方的部分），可以得到答案：

$$\binom{R + B}{R} - \binom{R + B}{2R - N + 1}$$

枚举 $R$（$B = K - R$）计算组合数即可得到答案。

时间复杂度为 $\mathcal O (K)$，[评测链接](https://atcoder.jp/contests/agc021/submissions/10545471)。

---

## 作者：CHU2 (赞：14)

## 我的思路

首先，如果有两只没喂过球的变色龙，把相同数目的蓝球喂给一只变色龙一定比喂给两只变色龙优（其实就是考虑一下要用多少红球能喂回去）

然后，如果一只变色龙是红的，它可以抵消掉一个蓝球。

于是就得到了一个判断策略：我们钦定一只变色龙，在没有红球出现时吃蓝球。如果有红球，给每只没喂过球变色龙都喂一个红球。如果这之后还有蓝球，给没喂过蓝球的红变色龙喂蓝球。最后的最后如果还剩下球，再喂给那只被钦定的变色龙。你感受一下发现这个是最优的。

这之后我想了些组合数做法，然而全被叉掉了。

## ~~看题解8~~

**我发现我自己想的搞法自己都没深入理解，还是思考得不够深入……**

题解告诉我们，这个策略是对的，并且说用$k$个球**最多**能喂出$x$只红变色龙的方案数是$C^{k-1}_{x-1}$，然后我就懵逼了……

然后被$\color{black}{C}\color{red}{SX}$巨佬教育了一通

大概是这样的：你先把一个球抓出来用来拯救那只被钦定的变色龙。然后根据前面那个策略，**最多**能喂$k$只变色龙的是这种序列：先是一段$B$,然后一段一段$RB$相连的东西（这一段段间只有$B$）最后一段先是$B$后是$R$

然后你发现你确定了所有$RB$段中$R$的位置时，这个序列就已经确定了……吗？

然后如果最后喂给那只被钦定的变色龙的$B<R$时，因为最多只能弄出$x$只红变色龙，所以你手上的那个球只能是$B$。否则你要拯救那只变色龙，你手上的球只能是$R$

至此，你就可以通过$x-1$个$R$的位置确定整个序列，所以方案数就是$C^{k-1}_{x-1}$

把所有$x\geq n$的方案算一下求个和就行了

代码

```cpp
#include <bits/stdc++.h>
#define N 500005
#define ll long long
#define For(i,x,y) for(int i=(x);i<=(y);++i)
#define Rof(i,x,y) for(int i=(x);i>=(y);--i)
#define Edge(x) for(int i=head[x];i;i=e[i].nxt)
#define mset(x,y) memset(x,y,sizeof(x))
#define mod 998244353
using namespace std;
int fac[N],invf[N];
int C(int x,int y){ return x>=y?1ll*fac[x]*invf[y]%mod*invf[x-y]%mod:0; }
int main(){
	int n,k,ans=0;
	scanf("%d%d",&n,&k);
	fac[0]=fac[1]=1,invf[0]=invf[1]=1;
	For(i,2,k){
		fac[i]=1ll*fac[i-1]*i%mod;
		invf[i]=1ll*(1ll*mod-mod/i)*invf[mod%i]%mod;
	}
	For(i,2,k) invf[i]=1ll*invf[i-1]*invf[i]%mod;
	For(i,n,k) (ans+=C(k-1,i-1))%=mod;
	cout<<ans;
}
```

---

## 作者：星·辉 (赞：11)

*本题解思路实际与 [CHU2](https://www.luogu.com.cn/user/240351) 相同，大概是对其题解的一些补充。*

### 题意简述

[AGC 021E](https://atcoder.jp/contests/agc021/tasks/agc021_e)

有 $n$ 条蛇，开始都是蓝色。你有 $k$ 个球，均为红色或蓝色，可以依次喂给蛇。
一条蛇如果吃了一个球之后，吃的该颜色的球的总数恰好超过另一种颜色的球，则该蛇会变为该颜色。

一个球的颜色序列合法仅当可以合理分配喂蛇顺序使得最后所有蛇都能变为红色。
$n, k\le 5\times 10^5$。

### 主要思路

下面用`B`来表示蓝色球，`R`来表示红色球。

一个显然的事实是，如果给两条未喂过球的蛇都喂了一些`B`，显然没有将这些`B`都喂给其中一条优。

考虑将这些蓝色的蛇喂回红色需要的`R`数量即可得到。

那么，一个球的颜色序列**最后能够得到的红蛇最多的方案**应该为：有一条蛇（下称「大蛇」）吃了最后一个球，并且为唯一一条可能吃了超过 $2$ 个球的蛇；其他蛇的吃球序列仅可能为`RB`或`R`。

（一个球的颜色序列**最后能够得到的红蛇最多的方案**即，开始假设有无数条蓝蛇，将这个球的颜色序列按顺序喂给蛇后使得最后所有喂过的蛇均为红色，并且红色的蛇的数量最多的一个方案。）

另一个显然的事实是，如果一个球的颜色序列**最后能够得到的最多红蛇数量**为 $m\ge n$，则其一定能够得到 $n$ 条红蛇。
于是，我们考虑**最后能够得到的最多红蛇数量**为 $m$ 的球的颜色序列。

除了大蛇以外应该还有 $m-1$ 条蛇，注意到这些蛇都会且仅会吃 $1$ 个`R`，不妨枚举这些`R`的位置；并且注意到上述定义中吃了最后一个球的是大蛇（实质上是为了钦定大蛇的位置，否则类似`RBRBRB`的序列则不知哪个是大蛇），所以这些`R`的位置仅能是前 $k-1$ 个球。

于是这里有 $\binom{k-1}{m-1}$ 种**放置其他蛇的`R`**的方案。

根据分析可得，每一种**放置其他蛇的`R`**的方案都与**最后能够得到的最多红蛇数量**为 $m$ 的球的颜色序列一一对应。

于是答案即为 $\sum\limits_{m=n}^{k}\binom{k-1}{m-1}$。

-----

~~等等，证明呢~~

**以下内容不保证严谨性。**

证明一个**放置其他蛇的`R`**的方案能够推出唯一一个**最后能够得到的最多红蛇数量**为 $m$ 的球的颜色序列：

考虑现在已经放置了 $m-1$ 个其他蛇的`R`，现在我们做以下操作：

从后到前依次考虑每个`R`的位置，在下一个空位放上一个`B`，构成一条吃球顺序为`RB`的蛇。

若一个`R`没有下一个空位，表示该蛇的吃球顺序为`R`。

考虑剩下的位置（包括最后一个位置），假设有 $c$ 个。

如果 $c$ 为奇数，则依次在前 $c-1\over 2$ 个空位填上`B`，其他填上`R`；

否则依次在前 ${c\over 2}-1$ 个位置与最后一个位置填上`B`，其他空位填上`R`。

此时即可满足，得到的颜色序列**最后能够得到的红蛇数量**为 $m$ ，且**其他蛇的`R`尽量后**的方案中，其他蛇的`R`是开始选出的`R`。

以下是一个例子，用于感受上述过程：
```plain
k = 12, m = 5
..R.R...RR.
..RBRB..RRB
BBRBRBRRRRBR
```

-----

证明一个**最后能够得到的最多红蛇数量**为 $m$ 的球的颜色序列能够推回唯一一个**放置其他蛇的`R`**的方案：

注意到在上述为每个其他蛇的`R`放置`B`后，整个序列中已经放置球的每个极长段，都有其中的`R`均与其中的`B`匹配（这里认为无`B`与其匹配的`R`不在极长段内）。

并且，由于大蛇的吃球序列的特殊性（`B...BR...R`或`B...BR...RB`），放置大蛇吃掉的球后，前 $k-1$ 个球中不会有更长的极长段产生。

所以同理地，找出这些极长段（可以使用类似括号匹配的方式），剩余的序列即为大蛇的吃球序列和一些未匹配的`R`。

显然这些未匹配的`R`只能是这个剩余的序列**次长前缀的一个后缀**，找出最长的这样的后缀即可；剩余的即为大蛇的吃球序列。

如果这个剩余的序列本身都无法使大蛇变为红色，则该序列本身不合法。

以上是一个例子，用于感受上述过程：
```plain
k = 14
)(()()())((()(
BRRBRBRBBRRRBR
B........RR..R +5
B........R...R +1
m = 6
```

-----

综上，即可得每一种**放置其他蛇的`R`**的方案都与**最后能够得到的最多红蛇数量**为 $m$ 的球的颜色序列一一对应。

---

## 作者：hwk0518 (赞：5)

我们先来看一看什么时候变色龙是红的：

(1)吃的红球比篮球多；

(2)吃的红球和蓝球一样多，且最后一个是蓝球。

容易证明，所有红色变色龙满足恰好一个条件；而两个条件均不满足的变色龙一定是蓝色的。

我们考虑有多少个含R个红球和B个蓝球的序列合法。

1)R<B：根据抽屉原理，至少一只变色龙吃的红球比蓝球少，两个条件均不满足。故为零。

接下来，我们把一种方案记作一条从(0,0)到(R,B)的路径，第i次若吃红球则向右走，吃蓝球则向上走。

2)R=B：

我们来考虑以下两个条件：

(1)路径必定经过(R,B-1);

(2)路径上不能有**到达或越过**直线y-x=n-B-1的点。

这两个条件显然是路径合法的必要条件。事实上，它们还是路径合法的充分条件。必要性的证明较简单，读者可以当做习题，故略去；充分性的证明比较复杂，略去。

3)R>B:

这和R=B类似，但比R=B简单一些。

容易发现，至少n-(R-B)只变色龙吃的红球和蓝球个数相等。

类似地，“路径上不能有到达或超过直线y-x=n-R-1的点”这个条件是路径合法的**充要**条件。



现在，我们唯一的问题是如何求解从(0,0)到(x,y)的不到达或越过x-y>=B路线条数。这是一个很经典的问题。但是考虑到刷Atcoder的大多是初学者，我在此再复述一下这个经典做法。

首先，所有的路径条数是C(x+y,x)。若路径不合法，则一定有一个在y-x=B上的点，不妨设为(a,b)。我们把(a,b)到(x,y)的路径关于直线对称，即，向右走变成向上走，向上走变成向右走。这样，δX=y-b+a=y+B，δY=b+x-a=x-B。不合法的路径与(0,0)到(y-B,x+B)的路径一一对应，故答案是：

C(x+y,x)-C(y+x,x+B)

**值得注意的是，若(0,0)在直线上方，答案为零。需要特判。**

代码：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const int N=3e6;
const int mod=998244353;
int n,k,ans,fac[N+5],inv[N+5],infac[N+5];

void init()
{
	int i;scanf("%d%d",&n,&k);
	fac[0]=1;for(i=1;i<=N;++i) fac[i]=1LL*fac[i-1]*i%mod;
	inv[1]=1;for(i=2;i<=N;++i) inv[i]=1LL*inv[mod%i]*(mod-mod/i)%mod;
	infac[0]=1;for(i=1;i<=N;++i) infac[i]=1LL*infac[i-1]*inv[i]%mod;
}

int C(int x,int y)
{
	if(y>x) return 0;
	return 1LL*fac[x]*infac[y]%mod*infac[x-y]%mod;
}

void calc(int x,int y,int T)
{
	if(T<=0) return;
	int ret=C(x+y,x);
	if(T<=y) ret-=C(x+y,y-T);
	if(ret<0) ret+=mod;
	ans+=ret;if(ans>=mod) ans-=mod;
}

void work()
{
	int i,j;
	for(i=0,j=k;i<=k;++i,--j)
	{
		if(i<j) continue;
		else if(i==j) calc(i,j-1,i-n+1);
		else calc(i,j,i-n+1);
	}
	printf("%d\n",ans);
}

int main()
{
	init();
	work();
	return 0;
}
```

---

## 作者：feecle6418 (赞：4)

枚举喂的红、蓝球个数 $R,B$，$R<B$ 或 $R\ge B+n$ 是简单的。当 $B\ {\color{red} <}\ R<B+n$ 时，一定存在一种喂球方式，一些变色龙**恰好按顺序吃了一个红球、一个蓝球**，另外一些变色龙红球比蓝球恰好多 $1$。

> 证明：设任意一种合法分配方式为 $A$。假如 $A$ 中有一个变色龙红 - 蓝大于等于 $2$，把这个红球分配给任意一个红 - 蓝等于 $0$ 的龙（显然一定存在这个龙）。假如 $A$ 中有一个变色龙红 - 蓝等于 $0$ 且吃了大于 $1$ 对，那取出最靠后的 `RB` 子序列分给另外一个红 - 蓝等于 $1$ 的龙。

这样，红球比蓝球恰好多 $1$ 的变色龙有 $(R-B)$ 只，红蓝相等的有 $n-(R-B)$ 只。一个喂球序列合法，当且仅当能取出 $n-(R-B)$ 个不交子序列 `RB`。

> 证明：先证充分，先取出这些子序列，剩余 $R-n+R-B=2R-n-B$ 个红球、$B-n+R-B=R-n$ 个蓝球，剩余的球中红 - 蓝等于 $R-B$ 且每只红球比蓝球恰好多 $1$ 的变色龙恰需要一个红 - 蓝，可以分配。再证必要，若取不出来就不能满足红蓝相等的有 $n-(R-B)$ 只。

能取出 $n-(R-B)$ 个不交子序列 `RB`，当且仅当任意前缀 `B` 比 `R` 多的数量不超过 $B-n+(R-B)=R-n$ 个。

> 能取出 $K$ 个不交子序列 `RB`，当且仅当任意前缀 `B` 比 `R` 多的数量不超过 $B-K$ 个。
>
> 证明：先证必要，假如某一个前缀里 `B` 比 `R` 多的数量超过 $B-K$ 个，这 $B-K+1$ 个 `B` 再也无法配对，那可能配对的总数 $\le B-(B-K+1)=K-1$，不可能取出 $K$ 对了。再证充分，相当于证明
>
> > 只要任意前缀 `B` 比 `R` 多的数量不超过 $B-K$ 个，就能取出 $K$ 个不交子序列 `RB`。
>
> 考虑证明逆否命题
>
> > 只要不能取出 $K$ 个不交子序列 `RB`，就存在一个前缀 `B` 比 `R` 多的数量超过 $B-K$ 个。
>
> 把能取出的所有 `RB` 删掉，最终一定形如 `BB...BRR...R`，其中 `B` 的数量大于 $B-K$，因此取这段前缀就得证。

接下来就是不碰线的路径计数问题。

还有一种情况：$R=B$，此时第一条证明中

> 假如 $A$ 中有一个变色龙红 - 蓝等于 $0$ 且吃了大于 $1$ 对，那取出最靠后的 `RB` 子序列分给另外一个红 - 蓝等于 $1$ 的龙。

这句话就不成立了。但注意到 $R=B$ 时最后一个喂的一定是蓝球，把这个球删掉变为 $R=B+1$ 的情况，就可以套用上述分析了。

---

## 作者：skydogli (赞：4)

这道题方案数不同是颜色序列不同，那么我们就可以思考什么样的颜色序列可以在最优策略下完成全部的染色。

不妨先观察一个变色龙变为红色的条件：

- 吃的红球数大于蓝球

- 吃的红球数等于蓝球且最后一次吃的是蓝球

第一个操作染红一个变色龙需要至少多一个红球，对先后顺序没有任何要求；第二个操作则不用数量差，染红一条要先一个红后一个蓝，很容易让人想到括号匹配。于是我们思考一下，如果颜色序列已知，我们的最优策略是什么。（下面令红球为`(`，蓝球为`)`）

由于数量差的喂法不讲究顺序，所以我们肯定先贪心地括号匹配，最后剩下的再用 $2$ 红 $1$ 蓝的方法喂就可以了。不难发现，这样成功的条件是： 匹配数+红球数-蓝球数 $\ge n$。而对匹配数有要求可以转化为限制失配数，折线法即可。

然而，变色龙染色的规则并不是括号匹配，对于红球数等于蓝球数的变色龙，只要最后一个放蓝球就可以了，例如 `())(()`、`)(()` 也能让一条变色龙变红，但是不难发现这样子也要用至少一个匹配，所以只让匹配的括号去用第二种方法染色是不劣的。

但是上面的做法的先决条件是 $红球数 > 蓝球数$ ，否则我们是无法使用第一种操作的。如果红球数等于蓝球数，不仅要满足匹配数 $\ge n$ ，还要求最后一个括号必须是 `)`，那么我们令蓝球数减一后按上面的方法做就好了。

代码很丑就不放了（


---

## 作者：Aw顿顿 (赞：3)

一道值得一做的组合数学题。

做一半没做下去，去看了兔的题解没看懂，去讨论区问明白了。把自己的思路整理一下。

## 分类讨论

考虑这 $k$ 个球中，喂了 $i$ 个红球和 $j$ 个蓝球，此时显然 $i+j=k$，我们的目的是将所有的变色龙变成红色，此时考虑怎样才能实现这一操作。

- 如果喂给某一直变色龙的球满足红色比蓝色多，那么显然这只变色龙最终一定是红色
- 如果两者一样多这时候只要让它在“扯平”之前是红色即可；换言之就是让最后一颗球是蓝色。

这样判断的理由是：在喂这颗蓝色球之前变色龙的红色球比蓝色多，因此会保持红色的状态，喂完这一颗后由于扯平了，依然不会改变颜色。

首先特判无解情况：

- 如果 $k<n$ 那即使全红也不能达成目标。
- 对于每一种 $(i,j)$ 的情况，分类：
	- 如果 $i<j$ 蓝球更多，肯定无解，直接跳过即可。
    - 如果 $i-n\ge j$ 此时可以每只变色龙的红球都比蓝球多。
    - 如果上述情况都不满足，只能委屈一些变色龙的蓝色和红色相等。

为了让资源最大化地利用，我们让红球比蓝球多的变色龙尽可能变成红球和蓝球差 $1$ 的情况，剩下的变色龙则红蓝球相等。这样我们可以尽可能节约红球以备不时之需。那么实际上就是 $i-j$ 只变色龙红蓝差 $1$，而 $n-i+j$ 只变色龙红蓝相等。

## 问题转化

考虑怎么样将这个问题转化成一个容易解决的序列问题。

如果 $i=j$ 实际上有任何一个变色龙把吃下去的蓝色球吐出来，方案数是不会变的，所以等价于 $(i,j-1)$ 的情况。被打吐的这只变色龙吃的红球肯定比蓝球多。我们去找别的龙，只要它吃的不是恰好两个球，就可以拿出来一对红蓝喂给多吃了一个红球的那位老哥。

注：实际上确定了红球的位置之后，蓝球的位置不难确定。由于我们并不考虑喂给变色龙的顺序，只在乎整体出球的顺序。

此时对于剩下的 $i-j$ 个孩子实际上给每个都塞一个红球就好了。也就是说只要我们能在前面的序列中取出 $n-i+j$ 对红蓝，就可以满足答案所需。因此从前往后遍历序列在任何一个时刻，都满足红球比蓝球多 $x$ 个，其中 $x\ge n-r$。

对于这个组合问题，存在结论使得：

$$ans=\binom{i+j}{i}-\binom{i+j}{2i-n+1}$$


## 代码实现

代码如何实现？简单求阶乘，然后逆推回去求阶乘的逆元，就可以用来求组合数了。枚举所有的 $(i,j)$，由于 $i+j=k$ 所以我们可以总共枚举 $k$ 次解决问题，复杂度可以承受。

```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define N 500005
#define int long long
using namespace std; 
inline int ksm(int b,int p){
	int s=1;b%=mod;
	while(p){
		if(p&1)s=s*b%mod;
		b=b*b%mod;p>>=1;
	}return s;
}int fac[N],inv[N];//阶乘和阶乘的逆元  
void init(int n){
	fac[0]=1;
	for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
	inv[n]=ksm(fac[n],mod-2);//费马小定理求逆元  
	for(int i=n;i>=1;i--)inv[i-1]=inv[i]*i%mod;
}int binom(int n,int m){return (m<0||m>n)?0:fac[n]*inv[m]%mod*inv[n-m]%mod;}
int n,k,s;
signed main(){
	scanf("%lld%lld",&n,&k);
	if(k<n){puts("0");return 0;}
	init(k);
	for(int i=0;i<=k;i++){
		int j=k-i;
		if(i<j)continue;
		if(i==j)j--;
		s=(s+binom(i+j,i)-binom(i+j,2*i-n+1)+mod)%mod;
	}printf("%lld\n",s);
	return 0;
}
```

---

## 作者：yyxmy (赞：2)

光题意就理了很久，什么叫**存在一次喂的变色龙不同的两个方案可能是相同的方案**，我是这么理解的， 那就是把颜色序列建出来后， 具体操作方式由你自己来决定。判断其是否能满足要求。 

那么这该如何操作呢?

可以发现：一个变色龙被染成红色只会有两种情况

1 . $cntR > cntB$  2 $cntR = cntB$ 且 $last$为$B$

通过这个我们可以知道应该尽量使得每一个变色龙的$cntR = cntB$才好， 那应该如何做呢， 我们不妨把第一只变色龙先拿出来对于剩下$n-1$只，先填一个红球， 再填一个蓝球， 然后把剩下所有的球全部给$1$号。

现在考虑一下在什么情况下这样子会填不出来。

令$x = cntR - (n - 1)$ ，一个红球的贡献为1， 一个蓝球的贡献为$-1$。那么在任何情况下， 前缀值都不能小于$-x$, 因为这样会使得第一个球无法满足要求。 对于这个东西应该如何求呢， 自然而然可以想到组合数， 也就是0到$(cntR, cntB)$ 的路径不能经过某条直线， 这个容斥一下就好了。

有一点要注意，在$cntB = cntR$的时候， 必须要强制最后一个元素为$-1$.

然后这道题就写完了。

---

## 作者：xht (赞：2)

## [Ball Eat Chameleons](https://atcoder.jp/contests/agc021/tasks/agc021_e)

### 题意

- 有 $n$ 只变色龙，初始为蓝色。
- 有 $k$ 个球，每个球为红色或者蓝色。
- 按顺序将 $k$ 个球随机给某只变色龙吃，此时它吃下哪种颜色的球多就会变成那种颜色，如果一样多则颜色不变。
- 求有多少种方案使得最终有可能让所有变色龙都变成红色。
- $n,k \le 5 \times 10^5$，答案对 $998244353$ 取模。

### 题解

考虑有 $r$ 个红球 $b$ 个蓝球，有 $r + b = k$。

考虑变色龙最终为红色的两种情况：

- 它吃的红球比蓝球多。
- 它吃的红球和蓝球一样多且不为 $0$ 个，但最后吃的是蓝球。

若 $r < b$ 显然无解。

若 $r \ge b + n$，则必然有解。

否则 $b \le r < b + n$，最优的情况为有 $r-b$ 只变色龙多吃一个红球，其它 $n-(r-b)$ 只变色龙都会先吃一个红球再吃一个蓝球。

即若将 `R` 表示红球，`B` 表示蓝球，在 $b \le r < b+n$ 的情况下，一种方案满足条件当且仅当它能取出 $n-(r-b)$ 对 `RB` 的子序列。

等价于，将 `R` 看成 $+1$，`B` 看成 $-1$，任意一个前缀和都要 $\ge n - r$。

等价于从 $(0,0)$ 开始每次向右或者向上走到 $(r,b)$，但是不能到达 $y = x + (r - n)$ 的严格上方（即碰到 $y = x+(r-n)+1$ 这条线）的方案数。

这是一类经典的组合问题，用类似卡特兰数的计算方法（翻转从起点到第一次碰到 $y = x+(r-n)+1$ 的部分，每条不合法的路径与从 $(n-r-1,r-n+1)$ 到 $(r,b)$ 的路径一一对应）可得方案数为：
$$
\binom {r+b}r - \binom{r+b}{2r-n+1}
$$
于是枚举 $r$ 即可，注意 $r=b$ 的情况需要特判一下（直接将 $b$ 减 $1$ 即可，因为最后一个必须要是 `B`），时间复杂度 $\mathcal O(n)$。

### 代码

```cpp
int main() {
	int n, k;
	rd(n, k);
	if (k < n) return print(0), 0;
	init(k);
	modint ans;
	for (int r = 0; r <= k; r++) {
		int b = k - r;
		if (r < b) continue;
		if (r == b) --b;
		ans += binom(r + b, r) - binom(r + b, 2 * r - n + 1);
	}
	print(ans);
	return 0;
}
```

---


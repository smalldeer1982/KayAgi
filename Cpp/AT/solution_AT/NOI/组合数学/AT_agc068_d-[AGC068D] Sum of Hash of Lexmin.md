# [AGC068D] Sum of Hash of Lexmin

## 题目描述

有一棵以 $1$ 为根、包含 $N$ 个顶点的有根树 $T$，顶点编号为 $1$ 到 $N$。顶点 $1$ 是根，对于每个 $2 \leq i \leq N$，顶点 $i$ 的父节点为 $P_i$（$P_i < i$）。

对于 $1$ 到 $N$ 的一个排列 $x=(x_1,x_2,\cdots,x_N)$，判断它是否为**良好**排列的方法如下：

- 对于排列 $x$，可以进行如下操作：
  - 选择排列中相邻的两个元素 $u,v$，如果 $u,v$ 在树 $T$ 上存在祖先-子孙关系（无论谁是祖先谁是子孙均可），则可以交换 $u,v$ 的位置。
- 如果经过若干次（可以为 $0$ 次）上述操作，能够得到一个严格小于初始排列的字典序排列，则 $x$ 不是良好排列。否则，$x$ 是良好排列。

给定正整数 $B$。对于排列 $x$，定义 $\operatorname{hash}(x)=\sum_{1 \leq i \leq N} B^{i-1} \times x_i$。

请计算所有良好排列 $x$ 的 $\operatorname{hash}(x)$ 之和，并对 $998244353$ 取模后输出。

数列的字典序定义如下：设 $S=(S_1,S_2,\ldots,S_{|S|})$，$T=(T_1,T_2,\ldots,T_{|T|})$，则 $S$ 的字典序小于 $T$ 当且仅当满足以下两条之一：

1. $|S| < |T|$ 且 $(S_1,S_2,\ldots,S_{|S|}) = (T_1,T_2,\ldots,T_{|S|})$。
2. 存在整数 $1 \leq i \leq \min\lbrace |S|,|T| \rbrace$，使得
   - $(S_1,S_2,\ldots,S_{i-1}) = (T_1,T_2,\ldots,T_{i-1})$，
   - $S_i < T_i$。

## 说明/提示

### 数据范围

- $2 \leq N \leq 100$
- $1 \leq B < 998244353$
- $1 \leq P_i < i$（$2 \leq i \leq N$）
- 输入的所有值均为整数

### 样例解释 1

例如，$x=(3,1,2)$ 不是良好排列。因为可以交换 $3,1$（它们在树上有祖先-子孙关系），得到 $x=(1,3,2)$，其字典序更小。在本样例中，良好排列为 $x=(1,2,3)$ 和 $x=(1,3,2)$ 共 $2$ 个。因此，$\operatorname{hash}((1,2,3))+\operatorname{hash}((1,3,2))=30201+20301=50502$，输出 $50502$。

### 样例解释 2

在本样例中，任意两个顶点都存在祖先-子孙关系。因此，唯一的良好排列为 $x=(1,2,3,4,5)$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 100
1 1```

### 输出

```
50502```

## 样例 #2

### 输入

```
5 100
1 2 3 4```

### 输出

```
504030201```

## 样例 #3

### 输入

```
10 248730679
1 2 1 2 5 6 1 8 1```

### 输出

```
856673861```

## 样例 #4

### 输入

```
20 480124393
1 2 3 2 3 4 3 8 3 4 11 10 4 14 15 12 17 18 19```

### 输出

```
488941820```

# 题解

## 作者：qbf！ (赞：9)

# AGC068D

### Statement

给定一棵 $n$ 个点的树，结点编号为 $1\sim n$，$i$ 号点的父亲为 $p_i(1\le p_i<i)$，定义一个排列 $x$ 是合法的当且仅当经过任意次以下操作不能得到一个字典序小于 $x$ 的排列：

- 选择一个位置 $1\le i<n$，若 $x_i$ 和 $x_{i+1}$ 在树上呈祖孙关系，交换 $x_i$ 和 $x_{i+1}$。

给定一个正整数 $B$，对于一个排列 $x$，定义其价值为 $\sum_{1\le i\le n}B^{i-1}\times x_i$，求所有合法排列的价值之和，答案对 $998244353$ 取模。


$n\le 100$。

### Solution

有个人五道题只过了 D，我不说是谁。

首先一个排列什么时候不合法，我们假设 $x$ 经过操作后可以得到一个字典序比 $x$ 小的排列为 $y$，令 $i$ 为第一个满足 $x_i\ne y_i$ 的位置，显然 $y_i<x_i$。

设 $j$ 为满足 $x_j=y_i$ 的位置，则有 $i<j$，由于我们可以把 $x_j$ 换到 $x_i$，故 $\forall k\in[i,j)$，$x_k$ 都必定与 $x_j$ 呈祖孙关系，此时容易发现必定存在一个 $k\in[i,j)$ 使得 $x_k$ 在 $x_{k+1}$ 的子树内。

于是我们就得到了排列合法的充要条件：不存在 $1\le i<n$ 使得 $x_i$ 在 $x_{i+1}$ 的子树内。

接下来先考虑计数方案数，我们考虑容斥，枚举点集 $S$ 并钦定 $\forall i\in S$，满足 $i$ 在排列 $x$ 中的前一个点在 $i$ 的子树内。

假设这个点为 $nx_i$，我们从 $i$ 向 $nx_i$ 连边，则可以发现这形成了若干条链（有些链长度为 $1$），且链的数量为 $n-|S|$。

考虑树形 $\rm DP$，设 $f_{i,j}$ 表示 $i$ 的子树内钦定了 $j$ 个点的方案数，转移先合并子树，然后再考虑是否有 $i\in S$。

若钦定 $i\in S$ ，则 $f'_{i,j+1}\leftarrow f_{i,j}\times (siz_i-j-1)$，否则 $f'_{i,j}\leftarrow f_{i,j}$，最后答案就是 $\sum_{i=0}^nf_{1,i}(-1)^i(n-i)!$。

再考虑计算所有合法排列的价值之和，我们先枚举一个点 $p$ 并计算它的贡献之和。

我们需要记录的是 $p$ 在排列 $x$ 中左侧链的数量以及 $p$ 在排列 $x$ 中右侧链的数量，设 $f_{i,l,r}$ 表示 $i$ 子树内，$p$ 左侧有 $l$ 条链（若 $p$ 在 $i$ 所在子树内，则不含 $p$ 所在的链，否则含 $p$ 所在的链），右侧有 $r$ 条链（不含 $p$ 所在的链），并考虑了左侧链的顺序和右侧链的顺序，此时的价值之和。

转移同样先合并子树，注意需要乘上一个 $\dbinom{l_1+l_2}{l_1}\times\dbinom{r_1+r_2}{r_1}$ 的系数，然后再考虑 $i$，若 $i\ne p$，则它可以：

- 加到左侧某个链的末尾，方案数为 $l$，价值乘上 $B$。
- 自成一个新链加到左侧，方案数为 $l+1$，价值乘上为 $B$。
- 加到右侧某个链的末尾，方案数为 $r$，价值不变。
- 自成一个新链加到右侧，方案数为 $r+1$，价值不变。
- 加到 $p$ 所在的链的末尾（若 $p$ 在 $i$ 的子树内），价值不变。

若 $i=p$ ，则它只能加到左侧最后一个链末尾或自成一个新链夹在左侧右侧中间。

由于是做了一个二维树形背包，故一次 $\rm DP$ 的时间复杂度是 $\mathcal O(n^4)$ 的，但我们枚举了 $p$ ，故这样是 $\mathcal O(n^5)$ 的。

考虑优化，我们可以把枚举 $p$ 的过程融合到 $\rm DP$ 中，只需多设一维 $0/1$ 表示子树内是否选择了 $p$ 即可，这样时间复杂度就是 $\mathcal O(n^4)$ 的了。

### Code

```cpp
#include<bits/stdc++.h>
#define ci const int
#define ll long long
using namespace std;
ci N=205,mod=998244353;
int n,B,p[N],a[N],pw[N],ans;
inline void add(int &x,ci v){
	x+=v,x-=x<mod?0:mod;
}
inline void sub(int &x,ci v){
	x-=v,x+=x<0?mod:0;
}
int fac[N],dfac[N],inv[N];
ll C(ci n,ci m){
	if(n<m||m<0)return 0;
	return (ll)fac[n]*dfac[m]%mod*dfac[n-m]%mod;
}
vector<int>g[N];
int f[N][N][N][2],tmp[N][N][2],siz[N];
void dfs(ci x){
	siz[x]=1,f[x][0][0][0]=1;
	for(int y:g[x]){
		dfs(y);
		for(int l=0;l<=siz[x]+siz[y];++l)
			for(int r=0;r<=siz[x]+siz[y];++r)
				tmp[l][r][0]=tmp[l][r][1]=0;
		for(int a=0;a<2;++a)//合并子树
			for(int l=0;l<=siz[x];++l)
				for(int r=0;l+r<=siz[x];++r)
					if(f[x][l][r][a])
						for(int b=0;a+b<2;++b)
							for(int l2=0;l2<=siz[y];++l2)
								for(int r2=0;l2+r2<=siz[y];++r2)
									if(f[y][l2][r2][b])
										add(tmp[l+l2][r+r2][a|b],(ll)f[x][l][r][a]*f[y][l2][r2][b]%mod*C(l+l2,l)%mod*C(r+r2,r)%mod);
		siz[x]+=siz[y];
		for(int l=0;l<=siz[x];++l)
			for(int r=0;r<=siz[x];++r)
				f[x][l][r][0]=tmp[l][r][0],f[x][l][r][1]=tmp[l][r][1];
	}
	for(int l=0;l<=siz[x];++l)
		for(int r=0;r<=siz[x];++r)
			tmp[l][r][0]=tmp[l][r][1]=0;
	for(int l=0;l<=siz[x];++l)//p不在x的子树内
		for(int r=0;r<=siz[x];++r)
			if(f[x][l][r][0]){
				sub(tmp[l][r][0],(ll)f[x][l][r][0]*r%mod);
				sub(tmp[l][r][0],(ll)f[x][l][r][0]*l%mod*B%mod);
				add(tmp[l][r+1][0],(ll)f[x][l][r][0]*(r+1)%mod);
				add(tmp[l+1][r][0],(ll)f[x][l][r][0]*(l+1)%mod*B%mod);
			}
	for(int l=0;l<=siz[x];++l)//令p=x
		for(int r=0;r<=siz[x];++r)
			if(f[x][l][r][0]){
				add(tmp[l][r][1],(ll)f[x][l][r][0]*x%mod);
				if(l)sub(tmp[l-1][r][1],(ll)f[x][l][r][0]*x%mod);
			}
	for(int l=0;l<=siz[x];++l)//p已在x的子树内
		for(int r=0;r<=siz[x];++r)
			if(f[x][l][r][1]){
				sub(tmp[l][r][1],(ll)f[x][l][r][1]*r%mod);
				sub(tmp[l][r][1],(ll)f[x][l][r][1]*l%mod*B%mod);
				add(tmp[l][r+1][1],(ll)f[x][l][r][1]*(r+1)%mod);
				add(tmp[l+1][r][1],(ll)f[x][l][r][1]*(l+1)%mod*B%mod);
				sub(tmp[l][r][1],f[x][l][r][1]);
			}
	for(int l=0;l<=siz[x];++l)
		for(int r=0;r<=siz[x];++r)
				f[x][l][r][0]=tmp[l][r][0],f[x][l][r][1]=tmp[l][r][1];
}
int main(){
	fac[0]=fac[1]=dfac[0]=dfac[1]=inv[1]=1;
	for(int i=2;i<N;++i)
		fac[i]=(ll)fac[i-1]*i%mod,
		inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod,
		dfac[i]=(ll)dfac[i-1]*inv[i]%mod;
	pw[0]=1;for(int i=1;i<N;++i)pw[i]=(ll)pw[i-1]*B%mod;
	cin>>n>>B;
	for(int i=2,f;i<=n;++i)cin>>f,g[f].push_back(i);
	dfs(1);
	for(int l=0;l<=n;++l)
		for(int r=0;r<=n;++r)
			add(ans,f[1][l][r][1]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Petit_Souris (赞：3)

读错题可以使你更快地做出这题。

如果你读成了 $x_i$ 是 $x_{i+1}$ 的后代就可以交换 $i,i+1$，你会觉得这个题面写了跟玩了原神似的，因为只要有的换你就换字典序就变小了，所以合法就等价于不存在 $i$ 满足 $x_i$ 是 $x_{i+1}$ 的后代。

这个问题的计数是经典的，钦定某些位置必须满足这个条件，这样就连出了若干条链，可以树形 dp 了。

计算哈希值看起来有点麻烦的，把贡献拆开，枚举树上的点 $p$ 被算到的贡献。对于每个点，我们关心他是插入在 $p$ 的左边还是右边（因为左边会带来 $\times B$ 的贡献），所以会想到这样设计 dp 状态：$dp_{u,i,j}$ 表示 $u$ 子树内，$p$ 左边选择了 $i$ 条链，右边选择了 $j$ 条链，**左右内部的顺序已经固定**的贡献之和。

$u\neq p$ 的时候有这些转移：

- 在左边选一条链，把 $u$ 接在这条链的末尾，系数为 $-iB$；

- 在左边的一个空隙插入一条只包含 $u$ 的新链，系数为 $(i+1)B$；

- 在右边选一条链，把 $u$ 接在这条链的末尾，系数为 $-j$；

- 在右边的一个空隙插入一条只包含 $u$ 的新链，系数为 $j+1$；

- 把 $u$ 接在 $p$ 所在链的末尾，系数为 $-1$。条件是 $p$ 在 $u$ 的子树内。

$u = p$ 的时候有这些转移：

- 把 $p$ 接在左边的最后一条链的末尾，系数为 $-p$；

- 在左右分界处另开一条链，系数 $p$。

然后还需要合并若干个子树，就直接是一个二维树形背包。注意合并 $(i,j)$ 和 $(i',j')$ 的时候会产生一个 $\binom{i+i'}{i}\binom{j+j'}{j}$ 的系数，因为他们之间的顺序是任意的。

这样做的复杂度是 $\mathcal O(n^5)$ 的，但是这个 $p$ 显然没必要每次枚举，可以直接多记录一维表示有没有选择 $p$，优化到 $\mathcal O(n^4)$。

你写了一下代码，通过了样例，提交，AC！正当你疑惑周围选手为什么还在对着这题苦思冥想的时候，你闲得无聊又翻了翻题面，**才发现 $x_i$ 是 $x_{i+1}$ 祖先的时候也可以交换**。

但是你通过了啊？你有些震惊，不过震惊之余的理智还是让你冷静下来重新分析这个问题。我们倒过来思考，最后一定交换了一对 $x_i,x_{i+1}$，其中 $x_i$ 在 $x_{i+1}$ 的子树中，但是这里的 $(i,i+1)$ 在初始状态不一定相邻。这样你会发现在初始序列中，$x_i$ 和 $x_{i+1}$ 中间的所有元素都是 $x_{i+1}$ 子树中的点，但是这样就可以直接取 $x_{i+1}$ 前面的那个点和 $x_{i+1}$ 了，所以两个题看似有差别其实是等价的。

不过好像这个题还是 dp 这块比较难（虽然比较套路），这个结论感觉有手就行。

[submission](https://atcoder.jp/contests/agc068/submissions/59079141)

---

## 作者：qiuzx (赞：1)

先考虑怎么判定一个排列是不是好的。容易发现如果存在两个相邻的位置 $p_i,p_{i+1}$ 使得 $p_{i+1}$ 是 $p_i$ 的祖先，那么直接交换它们就可以得到一个字典序更小的排列。另一方面，如果想要得到一个字典序更小的排列，则最后一次交换一定是交换了一对这样的元素 $x,y$。考虑在这之前的所有交换，会发现初始时 $x,y$ 这两个元素之间的所有元素一定都在 $y$ 的子树中。但这样初始时 $y$ 的前一个元素和它就形成了一个不合法点对。于是我们发现一个排列是好的当且仅当所有的 $p_{i+1}$ 都不是 $p_i$ 的祖先。

下面考虑先做计数，即计算有多少个好的排列。发现 $p_{i+1}$ 不是 $p_i$ 的祖先不好处理，但 $p_{i+1}$ 是 $p_i$ 的祖先是相对容易处理的。所以可以进行容斥，钦定一些相邻的位置使得后一个是前一个的祖先。将每一个极长的被钦定位置取出形成若干个区间（可能出现区间长度为 $1$，表示这个位置无限制），则在这些位置上填数可以看作将树分成若干条祖孙链（链上点不一定要连续），并将这些链任意排列。于是有一个 dp，即 $f_{x,s}$ 表示将以 $x$ 为根的子树分成 $s$ 条祖孙链并重新排列的容斥系数之和。转移时先将所有儿子合并起来，再决定 $x$ 是单独成为一条新的链还是接在一条链后面，如果是后者需要乘上 $-1$ 的容斥系数。

最后需要计算所有排列的哈希值。一个暴力的做法是枚举 $i,j$，计算钦定 $p_i=j$ 的值之后又多少种排列。此时每添加一条链都需要决定它是在 $i$ 的前面还是后面，且还需要维护在 $i$ 前面的数有多少个。特别地，在添加 $j$ 这个点的时候我们认为 $j$ 所在的链实际在 $j$ 的右边，但在这之后转移的时候如果将一个点在 $j$ 的右边单独成链，系数会有 $1$ 的变化。这样直接暴力做复杂度是 $O(n^7)$，太高了。

第一个优化是仍然枚举 $j$，但注意到我们关心的是 $\sum B^i$ 的值，所以不用枚举和记录 $i$，只需要在钦定一个点放在 $j$ 左边的时候乘上 $B$ 的系数即可。这样复杂度可以优化至 $O(n^5)$。

第二个优化是我们发现对于不同的 $j$，其转移的方式几乎是一样的，只有在是否已经转移过 $j$ 这个条件不同时会产生不同的转移。因此我们也不再枚举 $j$，而是额外添加一维 $0/1$ 表示钦定的 $j$ 是否已经在当前子树中转移过了。这里 $f_{*,0}$ 维护的是 $B^i$ 的和，而 $f_{*,1}$ 维护的是 $B^i\times j$ 的和。这样每次添加一个 $x$ 的时候，如果不将它钦定为 $j$ 就正常转移。如果钦定为 $j$ 那么再乘上 $x$ 的系数即可。复杂度 $O(n^4)$，可以通过。

[代码](https://atcoder.jp/contests/agc068/submissions/58288852)

---

## 作者：Acoipp (赞：0)

首先，根据题目有一个节点的祖先一定小于当前节点的编号。

设一个排列 $x$ 不合法，当且仅当存在一个排列 $y$ 满足 $y$ 的字典序小于 $x$ 且 $x$ 能够通过一些操作得到 $y$。

设 $x,y$ 第一个不同的位置为 $p$ 有 $y_p < x_p$，而 $y_p$ 在 $x$ 中的位置一定大于 $p$，设这个位置为 $q$。

那么 $\forall p \le i<q$，$x_i$ 和 $x_{i+1}$ 一定是祖孙关系，并且 $x_p>x_q$。由此，得到一定 $\exist i$，满足 $p \le i < q$ 且 $x_{i+1}$ 是 $x_i$ 的祖先。

再想想，发现如果存在任意一个 $i$ 满足 $x_{i+1}$ 是 $x_i$ 的祖先，可以直接交换这两个数得到字典序更小的排列。

于是我们有充要条件：不存在任何一个 $i$ 满足 $x_{i+1}$ 是 $x_i$ 的祖先，我们对这些 $x$ 计数即可。

按照计数的经典套路，我们直接考虑一个下标 $p$ 在所有排列中的贡献。

又因为 $x$ 直接算不好做，我们考虑容斥，即钦定一部分点，满足这些点在排列中上一个位置的点都在其子树中，把这些点与其上一个位置连边，就会把这个排列划分成若干个区间，并且这些区间在树上形成了一条链。根据容斥的套路，若形成了 $i$ 条链，那么容斥的系数即为 $(-1)^{n-i}$。

我们直接对链计数即可，因为在对 $x_i=p$ 的贡献计数，所以我们需要知道 $p$ 左边有多少条链，$p$ 右边有多少条链。

于是我们直接上树形 DP，设 $f_{i,j,k}$ 表示只考虑 $i$ 子树中的点，左边的链有 $j$ 条，右边的链有 $k$ 条的方案数。

当然，如果 $p$ 在 $i$ 的子树内，说明 $p$ 也一定在一条链中间，这一条链既不算在左边，也不算在右边。

根据树形 DP 的基本思想，首先合并子树内部的答案，合并的时候需要考虑链之间的组合排列，需要乘上 $C_{l_1+l_2}^{l_1} \times C_{r_1+r_2}^{r_1}$。（$l_1,r_1,l_2,r_2$ 分别表示两棵子树的左右链的数量）

最后考虑 $i$ 号点的分配情况（这里要保证 $i \ne p$）：

- 自己单独成一条链放在左边：容斥系数为 $1$，方案数为 $j+1$，代价为 $B$（即 $p$ 所在的位置往右移了一位）。
- 自己单独成一条链放在右边：容斥系数为 $1$，方案数为 $k+1$，代价为 $1$（即 $p$ 所在的位置不变）。
- 自己接上左边的一条链：容斥系数为 $-1$，方案数为 $j$，代价为 $B$。
- 自己接上右边的一条链：容斥系数为 $-1$，方案数为 $k$，代价为 $1$。
- 若 $p$ 在 $i$ 子树中但不是 $i$，那么 $i$ 还可以接到 $p$ 所在链的末尾，容斥系数为 $-1$，方案数为 $1$，代价为 $1$。（$i$ 的位置在 $p$ 的位置之后）

最后如果 $p=i$，那么它可以：

- 单独成为一条链，容斥系数为 $1$，方案数为 $1$，代价为 $p$。
- 接到左边的链最靠右的那一条，容斥系数为 $-1$，方案数为 $1$，代价为 $p$。

最后答案就是 $\sum f_{1,l,r}$。

这样做时间复杂度为 $O(n^5)$，考虑优化，如果 $p$ 不在这一棵子树中，对于不同的 $p$ 所有 $f$ 值相等；$p$ 在这一棵子树中的话，也可以合起来转移。

于是我们把 $p$ 记在状态里即可，即 $f_{i,j,k,0/1}$ 表示 $i$ 子树 $p$ 左边有 $j$ 条链，$p$ 右边有 $k$ 条链，$p$ 是否在 $i$ 子树中的答案，转移同上。

时间复杂度 $O(n^4)$，空间复杂度 $O(n^3)$，剪个枝后跑得飞快。

---


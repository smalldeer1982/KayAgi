# [AGC051C] Flipper

## 题目描述

有 $10^9 \times 10^9$ 个格子按正方形排列，编号从 $(1, 1)$ 到 $(10^9, 10^9)$。格子 $(i, j)$ 表示从上往下第 $i$ 行，从左往右第 $j$ 列的格子。最初，有 $N$ 个格子 $(x_1, y_1), \ldots, (x_N, y_N)$ 是黑色，其余所有格子都是白色。

すぬけ君可以进行如下操作任意次：

- 选择整数 $x\ (1 \leq x \leq 10^9 - 1)$ 和整数 $y\ (1 \leq y \leq 10^9 - 2)$，将 $6$ 个格子 $(x, y), (x, y+1), (x, y+2), (x+1, y), (x+1, y+1), (x+1, y+2)$ 的颜色反转（黑变白，白变黑）。

请计算经过若干次操作后，黑色格子的数量可能达到的最小值。

## 说明/提示

## 限制条件

- $1 \leq N \leq 10^5$
- $1 \leq x_i, y_i \leq 10^9$
- $(x_i, y_i)$ 互不相同。
- 输入中的所有值都是整数。

## 样例解释 1

下图中，从上到下第 $i$ 个字符串的第 $j$ 个字符表示格子 $(i, j)$。`#` 表示黑色，`.` 表示白色。

```
.##.
#.##
.###
.#..
-> 
#...
.#.#
.###
.#..
-> 
#...
..#.
....
.#..
```

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
9
1 2
1 3
2 1
2 3
2 4
3 2
3 3
3 4
4 2```

### 输出

```
3```

# 题解

## 作者：XiaoShanYunPan (赞：6)

困难的人类智慧题目。

## 题意

给定一个 $10^9\times 10^9$ 的网格图，上面有 $n$ 个格子是黑的。

你可以做任意次下面的操作，找出网格上黑格的最小可能数量。

+ 选择一个 $2$ 行 $3$ 列的矩形，将其中的格子的颜色反转。

+ 数据范围：$n\le 10^5$。

## 题解

这种操作之后寻找所有状态中一些特殊状态的题目，我们可以考虑结束状态的一些特征。

但是单说是不行的，我们找特征也只能细致地考察题目中给出的操作的性质。

注意到操作时对 $2$ 行同时进行操作，而黑和白又是二进制对立的关系，往二进制上面靠，发现两行同时改变对于这 **一列的异或和** 没有任何改变。

也就是说，对于第 $i$ 列，我们记录该列的异或和 $P_i$，则在初始状态求出的 $P_i$ **不会随操作而改变**。

接下来类似考虑 $3$ 列，这时候没有二进制了，我们可以想三进制，可惜这时候三进制并没有有用的东西。

不过我们可以直接暴力拆开记录三个异或和 $S_{i,0},S_{i,1},S_{i,2}$ 分别表示第 $i$ 行中 $3,6,9,\cdots$ 列，$1,4,7,\cdots$ 列和 $2,5,8,\cdots$ 列，即列号对 $3$ 取模的余数分别为 $0,1,2$ 的列的异或和。

同样观察 $S$ 在一次操作中的变化，发现 $S_{i,0},S_{i,1},S_{i,2}$ **一定会同时变化**，不难证明这是对的。

那么，如果给定 $P,S$，我们就已经足够判断该状态能否由初始状态得到了，我们的操作简化为同时选择两行 $i,i+1$，将 $S_i,S_{i+1}$ 反转。

此时反过来考虑用 $P,S$ 表示答案，好像不是很好搞，主要是因为对于第 $i$ 行而言，$S_i$ 有三个数。

不过你不难发现，$S_i$ 中的三个数 **相互独立**，于是我们可以将原矩阵 **分成三个矩阵**，第 $q$ 个矩阵只包含所有列号对 $3$ 取模后余数为 $q$ 的列。

单独对于任何一个矩阵考虑，我们可以得到 $p_q=\sum\limits_{i\equiv q\pmod{3}}P_i,s_q=\sum S_{i,q}$，不难发现 $p_q\equiv s_q\pmod{2}$，如果不是这样的话，初始给出的状态就存在黑格 $(x,y)$ 只给 $P_y,S_x$ 中的一个进行了贡献……

于是可以发现我们把每个交界点用黑格子填上，再把剩余的两两一组相互抵消即可，此时答案就是 $\max\{p_q,s_q\}$。

那么，重新考虑原问题，现在我们可以把问题变为如下的样子：

+ 给定 $P,S$，你可以进行操作，对于 $S_i,S_{i+1}$ 中的三个数进行反转，求出 $\sum\max\{p_q,s_q\}$ 的最小值。

这个问题看上去还是很难搞，我真服了。

不过沿用前面的思路，再考察操作带来的影响？

注意到同时反转 $S_i,S_{i+1}$ 不好做，能不能分开做？

同样考察合法的条件，注意到反转 $S_i$ 之后会导致 $p$ 变化，而我们不能够让 $p$ 变化。

所以只需要满足 $p$ 不变，我们就可以单独对任意的行做操作。

进一步抽象一下，发现我们可以反转任意两行，这是可以由原操作得到的。

于是只要我们反转的行数为偶数，我们的操作就是合法的。

接下来讨论 $S_i$ 反转对答案的影响。

如果 $S_i$ 不全相同，考虑 $S_{i,q}$ 是不同于另外两个的那个，那么如果我们反转 $S_i$，$s_q$ 会增加/减少 $1$，而另外两个 $s$ 同时会减少/增加 $1$。

对于 $S_i$ 全相同的情况，则三者会同时增加/减少。

为了统一减少和增加，我们可以提前做操作，使得 $S_i$ 中至多只有一个 $1$。

现在不难发现 $S_i$ 全为 $0$ 的情况我们不会进行操作，因为这个操作显然会使得 $S_i$ 全部变大，不能够使得我们的答案变优。

剩下考虑有 $1$ 的操作，这个操作能使得答案变小的情况，当且仅当 $s_q\gt p_q$，同时你显然不能够让另外两个 $\max$ 变大。

所以如果你要反转 $S_i$，你需要保证 $s_q\gt p_q$，同时另外两个 $s$ 要小于 $p$，足够了，直接贪心就可以完成。

为了满足 $p\equiv s\pmod{2}$ 的限制，读者可能还需进行一些处理，这里留作思考。

时间复杂度 $\mathcal{O}(n\log n)$，瓶颈在于输入并处理出 $P,S$。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
// 代码实现中将大小 p,s 互换了。
int S[3],P[3];
map<int,int>p,s[3];
inline int solve(int a,int b,int c)
{
	int S[3],P[3];
	memcpy(S,::S,sizeof S),memcpy(P,::P,sizeof P);
	if(((S[a]^P[a])&1)||((S[b]^P[b])&1)||((S[c]^P[c])&1))S[a]--,S[b]++,S[c]++;
    // 总操作次数必须为偶数。
	int op=min(S[a]-P[a],min(P[b]-S[b],P[c]-S[c]));
	op=max(op,0);
	S[a]-=op,S[b]+=op,S[c]+=op;
	return max(S[a],P[a])+max(S[b],P[b])+max(S[c],P[c]);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&y,&x);
		P[x%3]-=p[x];
		p[x]^=1;
		P[x%3]+=p[x];
		S[x%3]-=s[x%3][y];
		s[x%3][y]^=1;
		S[x%3]+=s[x%3][y];
		if(s[0][y]+s[1][y]+s[2][y]>1)
		{
			S[0]-=s[0][y],S[1]-=s[1][y],S[2]-=s[2][y];
			s[0][y]^=1,s[1][y]^=1,s[2][y]^=1;
			S[0]+=s[0][y],S[1]+=s[1][y],S[2]+=s[2][y];
		}
        // 提前进行操作使得所有位置 S 均只有一个 1。
	}
	int ans=n;
	ans=min(ans,solve(0,1,2));
	ans=min(ans,solve(1,0,2));
	ans=min(ans,solve(2,0,1));
	printf("%d",ans);
	return 0;
}
// 代码实现可能略丑。
```

---

## 作者：UnyieldingTrilobite (赞：6)

首先，让我们试图从题目所给的变化中找到一些不变量。

考虑到每一次变化都是一个二乘三的矩形，出现变化的列一定同时变了两个格子。于是，设 $p_j$ 是第 $j$ 列黑格个数的奇偶性，这是一个不变量。

那么行呢？我们发现，涉及到变化的行一定是连续的三个一起变，可以想到在一行内按列模三分组并统计每组内黑格个数的奇偶性，这样我们就能用三个二进制位刻画一行，它们每次操作都必然被同时反转。譬如，原来的状态是 `010`，那么操作一次之后一定变成 `101`，考虑到相邻的三个格子必然各自贡献到一个二进制位上。我们记第 $i$ 行这样的三个二进制位构成的 01 串为 $s_i$。如果我们认定 $s_i$ 和它每一位 01 取反构成的串是相同的，那这也是一个不变量。

那么还有更多的“不变量”吗？实际上，我们已经可以证明，以上两组不变量相同的状态一定都可以两两互达。记 $A=10^9$ 也就是原网格边长，那我们逐格变化一定能至少把初始状态的一个 $A-1$ 行 $A-2$ 列固定下来。由于列黑格奇偶性已经确定，最后一行是唯一的。由于行每个模 3 余数列的奇偶性也都已经确定（由于只剩两个没填，三个二进制位中一定有一个已经确定，进而另两个也唯一了），最后两列也都确定了。因此，题目中变化的网格已经被我们转换为了两组不变量。而原题给出的网格已经足以帮我们唯一确定这两组不变量的值，因此，我们要做的实际上就是给定不变量状态后确定它能对应到的所有棋盘中黑格最少的那一个。

$p_j$ 实际上可以通过题目给定的状态唯一确定，但 $s_i$ 不一定——可以有 01 翻转的两种状态。但我们这里先不妨考虑 $s_i$ 确定之后的做法。由于每一列实际上只限定了一个奇偶性，相对而言比较好处理，我们选择考虑行这个模 3 的情况。容易发现，我们应当把模 3 相同的列归在一起处理。考虑这些列中 $p$ 的状态有多少个 1（奇数），记为 $t$（注意到 $t$ 是固定不变的），那这些列中至少要有 $t$ 个黑格。考虑每一行中这个模 3 状态有多少个 1，记为 $S$（注意 $S$ 是随着 $s$ 变化的），那这些列中至少也要有这么多个黑格。那我们猜测，最终的答案就是这两者取 $\max$。

实际上，我们不妨假设 $t\ge S$。我们可以随便找 $S$ 个 $p$ 是 1 且符合模 3 约束的列出来，和每一个 $s$ 是 1 的行的交点涂黑。我们发现 $t$ 和 $S$ 都与全场黑格数量的奇偶性相同，因此 $t-S$ 一定是偶数。我们把剩下的列两两分组，每组随便找一行和这两列的交点染黑。我们发现，我们已经构造出了答案是 $t$ 的网格。对于 $t\lt S$，同理。

接下来我们整理一下我们转化过后的问题：

+ 给定若干三维向量，每一个形如 $(0,0,0)(0,0,1)(0,1,0)(0,1,1)$ 四者之一。

+ 可以进行不限次操作，每次可以选择一个向量并把它的每一维 01 翻转。

+ 给定三个常数 $X,Y,Z$。设最后得到的所有向量和为 $x,y,z$，那么需要在满足 $x,y,z$ 与 $X,Y,Z$ 顺次模 2 同余的前提下最小化 $\sum_{cyc}\min\{x,X\}$。

我们首先对于给出的原向量集算出 $x,y,z$，随后考虑每一种向量 01 反转对 $x,y,z$ 的影响（由于对同一个向量反转两次没有意义，这里只考虑原向量的反转情况）：

+ $x,y,z$ 各增加一；

+ $z$ 减少一，$x,y$ 各增加一；

+ $y$ 减少一，$x,z$ 各增加一；

+ $x$ 减少一，$y,z$ 各增加一；

我们发现，进行反转的目的是为了让答案变小。但如果同时进行了两种不同的反转，譬如第二种和第三种，$x,y,z$ 三个变量都会增大，同时它们的奇偶性也不会发生改变，是没有意义的。因此我们实际上只需要考虑进行其中一种反转即可。注意到奇偶性约束，如果需要我们进行奇数次反转，我们大可以预先进行一次反转再作考虑。

首先第一种情况是最为特殊的。它被反转一次的唯一意义就是凑奇偶，本身至多进行一次，不会再多了。然后剩下三种情况以最后一种为例，我们发现答案减小唯一的希望就是 $x$ 减少一之后 $\max\{x,X\}$ 减少一，且另外两项不变。那么我们可以列出 $x$ 操作有意义的条件：$x\gt X,y\lt Y,z\lt Z$。注意到三个变量和三个常数奇偶性顺次相同，于是大于小于号代表的差至少是 2，不会出现接连两次操作中只有第一次有意义。那么我们就可以通过上面三个条件把最优反转次数算出来（不需要考虑原向量个数的约束，因为原向量用完的时候 $x$ 一定已经归零了），同时注意到如果一开始条件就不满足，那就是零次。

然后根据以上所说的模拟一遍就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int A = 3;
int n, t[A], xyz[A];
map<int, bool> p;
map<int, unsigned char> s;
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  for (cin >> n; n; --n) {
    int x, y;
    cin >> x >> y;
    p[y] ^= true, s[x] ^= 1 << (y % A);
  }
  for (auto [y, w] : p) t[y % A] += w;
  for (auto& [x, w] : s) {
    if (__builtin_popcount(w) > 1) w ^= (1 << A) - 1;
    if (w) ++xyz[__lg(w)];
  }
  auto calc = []() {
    int ans = 0;
    for (int i = 0; i < A; ++i) ans += max(t[i], xyz[i]);
    return ans;
  };
  bool par = (t[0] ^ xyz[0]) & 1;
  for (int i = 0; i < A; ++i) xyz[i] += par;
  int ans = calc();
  for (int i = 0; i < A; ++i) xyz[i] -= par;
  for (int i = 0; i < A; ++i)
    if (xyz[i]) {
      xyz[i] -= par;
      for (int j = 0; j < A; ++j)
        if (j != i) xyz[j] += par;
      int d = xyz[i] - t[i];
      for (int j = 0; j < A; ++j)
        if (j != i) d = min(d, t[j] - xyz[j]);
      d = max(d, 0);
      xyz[i] -= d;
      for (int j = 0; j < A; ++j)
        if (j != i) xyz[j] += d;
      ans = min(ans, calc());
      xyz[i] += d + par;
      for (int j = 0; j < A; ++j)
        if (j != i) xyz[j] -= d + par;
    }
  return cout << ans << endl, 0;
}
```

---


# [AGC053D] Everyone is a winner

## 题目描述

有一个包含 $N$ 名参赛者和 $N$ 道题目的竞赛。每位参赛者编号为 $1$ 到 $N$。对于每一位参赛者和每一道题的组合，已知该参赛者解这道题所需的时间为 $1$ 分钟、$2$ 分钟或 $3$ 分钟。对于第 $i$ 位参赛者，在 $N$ 道题目中，有 $A_i$ 道题需要 $1$ 分钟，有 $B_i$ 道题需要 $2$ 分钟，有 $C_i$ 道题需要 $3$ 分钟。

请判断是否存在一种安排，使得每位参赛者可以自由决定解题顺序，并且对于所有 $1 \leq i, j \leq N$，都满足以下条件：

- 设第 $i$ 位参赛者解完前 $i$ 道题所需的时间为 $S$ 分钟，第 $j$ 位参赛者解完前 $i$ 道题所需的时间为 $T$ 分钟，则有 $S \leq T$。

也就是说，是否存在一种安排，使得对于每个 $i$，第 $i$ 位参赛者在解完前 $i$ 道题时可以成为第 $1$ 名（允许并列）。

忽略解完一道题到开始下一道题之间的时间。

给定 $T$ 组测试数据，请分别作答。

## 说明/提示

### 限制条件

- $1 \leq T \leq 2 \times 10^5$
- $1 \leq N \leq 2 \times 10^5$
- $0 \leq A_i, B_i, C_i \leq N$
- $A_i + B_i + C_i = N$
- 所有测试数据中 $N$ 的总和不超过 $2 \times 10^5$

### 样例解释 1

对于第一个测试用例，例如可以如下安排使条件成立：
- 参赛者 $1$ 按顺序解第 $1$ 题用 $3$ 分钟，第 $2$ 题用 $2$ 分钟，第 $3$ 题用 $2$ 分钟。
- 参赛者 $2$ 按顺序解第 $1$ 题用 $3$ 分钟，第 $2$ 题用 $2$ 分钟，第 $3$ 题用 $3$ 分钟。
- 参赛者 $3$ 按顺序解第 $1$ 题用 $3$ 分钟，第 $2$ 题用 $2$ 分钟，第 $3$ 题用 $1$ 分钟。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
3
0 2 1
0 1 2
1 1 1
3
0 2 1
0 0 3
1 1 1```

### 输出

```
Yes
No```

# 题解

## 作者：joke3579 (赞：2)

## $\text{Statement}$

有一场 $n$ 个参赛者、$n$ 道题的比赛。参赛者被编号为 $1$ 至 $n$。我们都知道每一名参赛者解决每一道题目需要的时间，其只可能是 $1/2/3$ 分钟。在这 $n$ 道题目中，有 $A_i$ 道题目需要参赛者 $i$ 花费 $1$ 分钟解决，有 $B_i$ 道题目需要参赛者 $i$ 花费 $2$ 分钟解决，有 $C_i$ 道题目需要参赛者 $i$ 花费 $3$ 分钟解决。

假设每名参赛者都能够自由决定做题顺序，请确定如下的条件是否能够对于所有参赛者 $1\le i,j\le n$ 都成立：
- 令 $S$ 为参赛者 $i$ 完成前 $i$ 道题目的时间，$T$ 为参赛者 $j$ 完成前 $i$ 道题目的时间。条件即为 $S\le T$。

具体的说，在忽略切换题目的时间的情况下，需要确定是否对于每个参赛者 $i$，其为所有人中第一个（可能为并列）完成前 $i$ 道题目的人。

有 $T$ 组询问。

$1\le T\le 2\times 10^5,\ 1\le n \le 2\times 10^5, \ 0\le A_i,B_i,C_i\le n,\ A_i + B_i + C_i = n$。保证所有询问的 $n$ 加和 $\le 2\times 10^5$。

## $\text{Solution}$

令 $T_i$ 最开始为所有人都优先做更耗时的题目的情况下，第一个做出前 $i$ 道题的人花费的时间。参赛者 $i$ 做出前 $i$ 道题的时间应当不大于 $T_i$ 分钟。

我们动态更新每个 $T_i$。倒序考虑每名参赛者，假设现在已经考虑到了第 $i$ 名。   
如果第 $i$ 名参赛者无法在 $T_i$ 分钟内做出前 $i$ 道题，则该组询问的答案为否。反之可以选出耗时最长且加和不超过 $T_i$ 的 $i$ 道题，从更耗时的题目开始做。剩余的 $n-i$ 道题在做完前 $i$ 道题后开始做，同样从更耗时的题目开始。假设其做完前 $j$ 道题消耗了 $s_{i,j}$ 分钟，则对于每个 $1\le j < i$，更新 $T_j = \min(T_j, s_{i,j})$。    
如果成功决策则该组询问的答案为是。

但上面的决策方式可能会让人有疑问：对于 $i<j\le n$，我们是否一定能保证 $s_{i,j} \ge T_j$ 呢？换句话说，这种方式是否会打乱已经完成的决策呢？我们断言，在花费的时间仅有 $\{1,2,3\}$ 分钟的情况下，一定能保证 $s_{i,j} \ge T_j$ 。

对于 $2\le i\le n$，假设我们在对 $i$ 决策后有 $T_{i-1} + 2 \ge T_i$，则对于任意的 $j \ge i$，我们都能有 $T_j \le T_i + 2(j - i)$。可以发现该条件在该情况下是必定满足的，因此该贪心策略是正确的。但其并不适用于推广后的情况。

因此我们可以记录 $T_i$ 的后缀最小值，随后对于每个点 $O(1)$ 地判定是否满足。

总时间复杂度 $O(n)$。

$\text{code : }$

```cpp
#include <bits/stdc++.h>
using namespace std; 
#define rep(i,s,t) for (register int i = (s), i##_ = (t) + 1; i < i##_; ++ i)
#define pre(i,s,t) for (register int i = (s), i##_ = (t) - 1; i > i##_; -- i)
const int N = 2e5 + 10, inf = 0x3f3f3f3f;
int n, a[N], b[N], c[N];

void solve() {
	cin >> n; rep(i,1,n) cin >> a[i] >> b[i] >> c[i];
	int f0 = inf, f1 = inf;
	rep(i,1,n) f0 = min(f0, c[i] * 2 + b[i]), f1 = min(f1, c[i]);
	bool ck = true;
	pre(i,n,1) {
		int mn = min( { f0, f1 + i, i << 1 } );
		int l = max(0, i - a[i] - b[i]), r = min( { c[i], i, mn >> 1 } );
		if (l > r or i - mn + l > a[i]) { ck = false; break; }
		r = min(r, a[i] - i + mn);
		f0 = min( { f0, mn, r + i, (r << 1) + b[i] } );
		f1 = min( { f1, r } );
	} puts(ck ? "Yes" : "No");
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); 
	int T; cin >> T; while (T--) solve(); return 0; 
}
```

---


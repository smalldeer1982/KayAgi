# [ARC164F] Subtree Reversi

## 题目描述

给定一棵有 $N$ 个顶点的有根树，顶点编号为 $1$ 到 $N$，以顶点 $1$ 为根。对于每个顶点 $i$（$2 \leq i \leq N$），其父节点为 $p_i$。

Alice 和 Bob 使用这棵树进行如下游戏：

- Alice 先手，Bob 后手，双方轮流在树的顶点上放置一枚石子。石子有正反两面，正面为白色，反面为黑色。Alice 总是将白色面朝上放置，Bob 总是将黑色面朝上放置。
- 每次只能在当前没有石子的顶点，并且其所有子孙顶点都已经放置了石子的顶点上放置石子。
- 放置石子时，需要将该顶点所有子孙上的石子全部翻面（但新放置的石子不翻面）。

当所有顶点都放置了石子后，游戏结束。此时，白色面朝上的石子数量即为 Alice 的得分。

Alice 希望最大化得分，Bob 希望最小化 Alice 的得分。双方都采取最优策略时，Alice 的得分是多少？

## 说明/提示

## 限制条件

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq p_i < i$ （$2 \leq i \leq N$）
- 输入的所有值均为整数
- 给定的图结构保证是一棵树

## 样例解释 1

对于给定的树，最初可以放置石子的顶点只有 $3,4$。例如，游戏可以如下进行：

- Alice 在顶点 $4$ 放置白色面朝上的石子。此时，顶点 $2$ 的所有子孙都已放置石子，因此可以放置石子。
- Bob 在顶点 $2$ 放置黑色面朝上的石子，并将顶点 $4$ 的石子翻面，使其变为黑色面朝上。
- Alice 在顶点 $3$ 放置白色面朝上的石子。
- Bob 在顶点 $1$ 放置黑色面朝上的石子，并将顶点 $2,3,4$ 的石子全部翻面。

此时，顶点 $1,2,3,4$ 上的石子分别为黑、白、黑、白朝上。实际上，这是一种双方最优策略下的进行方式，答案为 $2$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
1 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7
1 1 2 4 4 4```

### 输出

```
5```

# 题解

## 作者：0htoAi (赞：6)

[前往博客园阅读](https://www.cnblogs.com/0htoAi/p/17545975.html)

先进行一些转化。

每个点被翻转的次数固定，为其深度。（这里规定根节点的深度为 $0$）

所以每个人放颜色可以看做放什么得什么，而不需要考虑翻转。

先手选偶数层和后手选奇数层都会使得先手得分，反之不得分。所以先手和后手其实是一样的策略：尽可能选偶数层，而不选奇数层。

对于能够放颜色的点，一定是叶子，所以考虑维护当前的叶子集合。

对于初始为叶子的点，如果是偶数层的，直接依次选，否则开始维护。对于选了偶数层的叶子而新增的叶子也要维护。

考虑选一个奇数层的叶子，而且选了不会使得多出来一个偶数层的叶子：无意义节点，依次选。

如果要多出来一个偶数层叶子，则先选奇数层叶子的那个人非常亏：自己没赚到还让对面赚了。所以都不想当偶数层叶子暴露出来，所以会先把无关紧要的奇数层叶子选完。此时剩下全是选一个就会把其父亲也选的了奇数层叶子。

这时先选肯定是亏的，为了尽量亏少，计算每一坨的价值。一坨的意思就是只要选了这一坨的其中一个，就能把这一坨选完且跟这一坨的根节点的父亲选不了且先后手会改变且选这一坨的后手能得到这一坨的点的所有贡献（先手一无所获）。每一坨是独立的，但是每个人都不想当第一个选大坨的人，因为这样就得不到贡献。所以都会先从小坨选，其实这样会发现贡献是固定的，因为每次当前先手都会选择当前能选的坨的最小的一坨，来保证失去的贡献尽可能少。

突然发现，对于初始为奇数层的点，其实就是大小为 $1$ 的坨。每次选完一坨后大小改变。对于这个点是最后一个其父亲的儿子，这时它就不是单独的一坨了，要把它父亲带上合并到其父亲的父亲身上去。

每次选择最小的一坨取，然后先后手更改（最开始先把偶数层的叶子取完的时候也要算先后手情况）。取偶数层的时候是如果当前是先手则对答案产生贡献，取坨的时候是当前为后手则对答案造成这一坨的大小的贡献。

如果最小的一坨需要合并到其父亲的父亲上去，则不计入答案，而是把贡献存储在其父亲的父亲上。如果其父亲的父亲下面的点的贡献都存储到它身上了，就把它当做一坨来看待，加入堆。

如果说当前最小的一坨是最后一坨，当且仅当这一坨的根的父亲为 $1$，此时的先手能得到这一坨的大小 $+1$ 的贡献，并且此时所有点都被取完了。答案即为当前先手为 Alice 时得到的坨的贡献之和和最开始 Alice 选的偶数层叶子数量。


---

## 作者：JWRuixi (赞：4)

### 题意

给定 $n$ 个点的树，Aob 和 Blice 分别持白棋和黑棋博弈：

- 点 $u$ 能放置棋子当且仅当 $v \in \text{son}_u$ 全部都已经放置了棋子；
- 点 $u$ 放置棋子后，$\forall v \in \text{subtree}_u$ 颜色反转。

Aob 想最大化白棋数量，Blice 想最大化黑棋数量，求最优策略下白棋的数量。

$n \le 2 \times 10^5$。

### 分析

两个限制分别说明：

- 我们只能操作叶子，即操作是从下到上剥叶子；
- 一个点的颜色会被反转深度次（钦定根的深度为 $0$）。

于是可以对原树进行分层，划分为偶数层和奇数层。不难发现对双方而言有贡献的都是偶数层，所以转换成尽量的取偶数层的点。

考虑第一个限制，我们开始对叶子分类：

- 偶数层的叶子：很好，白送的贡献，轮流取即可；
- 奇数层的叶子，且**不是它的父亲的最后一个儿子**（即选了它也不能选它父亲）：给别人送分，但是没办法，轮流取；
- 奇数层的叶子，且它**是父亲的最后一个儿子**：选了它给对手送分，然后下一轮对手又可以选父亲，尽量不选。

这样我们已经把叶子的优劣分出来了，但我们还要给第三种定一个顺序，因为它们造成的是连锁反应。

考虑引入一个**簇**，它是树上的一个连通块，且具有一下几种性质：

- 后手将取到这个簇的全部贡献；
- 与其它簇独立，且极大（即选完它，该簇的根也不能选）；
- 操作完后，先后手反转。

去掉初始时偶数层的叶子后，不难将原树分成若干个簇（奇数层叶子可以看成大小为 $1$ 的簇）。

考虑由下到上的过程，对于一个点 $u$：

- $dep_u \equiv 0 \pmod 2$：它的每个儿子都是一个独立的簇，因为簇的价值是亏损的，所以一定按权值从小到大取，于是将其权值最大的子簇并入 $u$；

- $dep_u \equiv 1 \pmod 2$：为了保证极大，所以可以将它与所有儿子对应的簇合并。

（**注意：根所在的簇大小为偶数**。）

复杂度 $\mathcal O(n)$。

### Code

提交记录：<https://atcoder.jp/contests/arc164/submissions/50526596>。

---

## 作者：EXODUS (赞：3)

# Part 1：前言

很不错的一道题目，但是感觉题解区说的都不是很明白，所以我来写一发！

# Part 2：正文

首先注意到，每个节点上棋子被翻转次数是固定的。如果我们钦定根节点的深度为 $0$，则每个节点上的棋子被颜色翻转的次数为其深度。

而棋子最终的颜色只和被反转次数的奇偶性和初始时的颜色相关，所以这个问题可以被转化为如下一个等价问题。

> 给定一个 $n$ 个点的树，每个点有红蓝两种颜色，根节点颜色为红色，每个节点的颜色和其父亲的颜色相反。两个人轮流在树上放黑白两种棋子，执白先手。每次挑选一个叶子，放上一枚棋子，并删去这个叶子。在蓝色节点上的棋子最终会变为对方棋子的颜色，在红色节点上的将会变为自己的颜色。双方的目标都是最大化自己颜色的棋子的数量，询问最终局面白色棋子的数量。

转化成这个问题最大的好处是让每个节点之间相对独立，现在节点间唯一的限制是放棋子的点只能是叶子。

同时，我们对白色棋子的数量换一种描述。设 $a$ 表示 Alice 下在蓝色节点上的棋子数量，$b$ 表示 Bob 下在蓝色节点上的棋子数量，则答案可以表示为 $\lceil\dfrac{n}{2}\rceil-a+b$，这个的好处是更直观的理解下面贪心策略的正确性。

考虑进一步简化局面。如果当前存在红色叶子，双方的策略显然都是先把棋子下在红色叶子上。因此我们可以看做是先把所有红色叶子丢掉，那么现在的局面变成了只有蓝色叶子的情况。我们称这种局面为**简化局面一**。

进行到简化局面一会有一些先后手的变换，为了避免混淆，我们下文中的先后手均指**当前局面的先后手**，用 Alice 和 Bob 代替原局面的先后手。

当只有蓝色叶子的时候，双方只能取蓝叶子。但如果先手结束操作以后，出现了一个红叶子，那么后手一定会直接取掉新生成的红叶子。这样先后手不变，后手净赚两个节点。

根据贪心策略，无论先手后手都一定会尽量避免这种情况的发生，也就是说，先手后手将尽量取那些不会产生新红叶子的蓝叶子，直到不存在这样的蓝叶子。我们称这种局面为**简化局面二**。

现在局面进一步简化。我们现在取任意一个蓝叶子都会使得一个新的红叶子生成。然后我们套用简化局面一去掉那个新产生的红叶子。此时局面走向了两种情况。一种是直接成为了简化局面二，另一种则是产生了不会产生新红叶子的蓝叶子。根据简化局面二的定义，只会产生一个这种蓝叶子。

我们进一步讨论简化局面二做一次操作后得到的局面。此时的先手一定希望尽量快的将自己变为后手（否则每一步均会亏两个节点），考虑什么时候先手才能达到这个目的，我们发现，先手能够达到这个目的当且仅当产生了不会产生新红叶子的蓝叶子。此时，先手取掉这个蓝叶子，局面成为简化局面二，且先后手互换。

我们称一个树上连通块是簇，当且仅当其由一个父亲度数大于 $1$ 的蓝色节点为根和若干蓝红交替的链组成；称一个簇的代价为其中的节点个数。那么我们发现，先手的策略是每次取掉这样一个簇，如果先手是 Alice，则使得答案减少簇的代价，否则增加簇的代价；删掉这个簇，然后先后手互换。

下面给出了一个簇的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/lg52vzd5.png)

图中虚线部分构成了一个簇。注意灰色箭头指向的节点的子树不构成簇，原因是父亲度数不大于一。

根据贪心的策略，我们有猜想是，先手每次会取代价最小的簇，这个策略的正确性是非常容易证明的，因为先手每多做一次操作均会导致两个节点的亏损。严谨证明可以参考 Atcoder 的官方题解，这里不再赘述。

根据这个猜想，我们得到了这个题的多项式做法，首先把局面变为简化局面一，然后按照每次取出最小的簇，删掉，贡献答案，交换先后手，重复操作直到树被删空。特殊的，当树中不存在簇时，我们认为剩下的节点为一个大簇。时间复杂度 $O(n^2)$。

考虑降低这个做法的复杂度。我们从下向上划分簇。对于每个蓝色节点，其可能成为一个簇的根节点，我们将其放到父亲红色节点考虑。而对于红色节点，按照上述策略，其将保留最大的那个簇向上传递到其父亲，同时确定其余簇的形态。我们容易使用排序完成这一过程。时间复杂度 $O(n\log n)$。

下面描述了一个簇的划分过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/bdfhm4lu.png)

图中的所有绿色部分为确定的簇，黄色部分将随红点继续上传参与以其祖先节点为根的簇的构成

同时，为了减少代码细节，我们将单独的红色叶子看为一个代价为 $0$ 的簇。这样我们依次确定每一个簇后，按照代价排序，先后手依次取簇贡献答案即可。

综上，我们在 $O(n\log n)$ 的复杂度内解决了这个问题。



# Part 3：代码

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;

#define rep(i,l,r) for(int i(l);i<=(r);++i)
#define per(i,r,l) for(int i(r);i>=(l);--i)
#define eb emplace_back
#define File(filename) freopen(filename ".in","r",stdin),freopen(filename ".out","w",stdout)

#ifdef EXODUS
	#define Debug(...) fprintf(stderr,__VA_ARGS__)
#else
	#define Debug(...) 0
#endif

//=========================================================================================================
// Something about IO

template<typename T>
void read(T &x){
	x=0;T flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	x*=flg;
}
template<typename T,typename... Args>
void read(T &x,Args &...args){read(x),read(args...);}

//=========================================================================================================
// Define the global variables here.

bool membg=0;

constexpr int N=2e5+7;
int n,anc[N],dep[N];
vector<int>g[N];
vector<int>ctb[N];
vector<int>cost;


bool memed=0;

//=========================================================================================================
// Code here.

void dfs(int u){
	for(auto v:g[u])dep[v]=dep[u]+1,dfs(v);
	if(dep[u]&1)ctb[anc[u]].eb(accumulate(ctb[u].begin(),ctb[u].end(),1));
	else{
		if(g[u].empty())cost.eb(0);
		else{
			sort(ctb[u].begin(),ctb[u].end());
			for(int i=0;i<(int)ctb[u].size()-1;i++)
				cost.eb(ctb[u][i]);
			if(anc[u])ctb[anc[u]].eb(*ctb[u].rbegin());
			else cost.eb(*ctb[u].rbegin());
		}
	}
}

void solve(){
	read(n);
	for(int i=2;i<=n;i++)read(anc[i]),g[anc[i]].eb(i);
	dfs(1);
	sort(cost.begin(),cost.end());
	int res=(n+1)>>1,sign=-1;
	for(auto x:cost)res+=x*sign,sign*=-1;
	printf("%d\n",res);
	return;
}


//=========================================================================================================

int main(){
	Debug("%.3lfMB\n",fabs(&memed-&membg)/1024.0/1024.0);
	int timbg=clock();
	int T=1;
	while(T--)solve();
	int timed=clock();
	Debug("%.3lfs\n",1.0*(timed-timbg)/CLOCKS_PER_SEC);
	fflush(stdout);
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/AT_arc164_f)

**题目大意**

> 给定 $n$ 个点的树，A 和 B 轮流给点染黑色和白色。
>
> 只能染子树全部被染色的点，染色后子树颜色反转（当前点不变）
>
> 双方均采取最优策略，求最终有多少黑色棋子。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

显然一个点深度为偶数，那么其颜色与初始相同，否则不同。

因此两个人的目的可以都转成取最少的奇深度点。

讨论几种情况：

- 如果当前有偶深度叶子，两人轮流取一定不影响。
- 否则只有奇深度叶子，这个叶子是其父亲的唯一儿子，那么先手取了这个叶子，后手还能再取一个偶深度叶子，一定很亏，所有两个人轮流取父亲儿子数 $\ge 2$ 的点。
- 最后每个点都是其父亲的唯一儿子，显然当前人要取离度数 $\ge 2$ 的祖先最近的一条链，否则只会越亏越多。

每次暴力模拟，复杂度 $\mathcal O(n^2)$。

考虑自下而上划分。

注意到两个人的操作可以被描述成一些连续的过程，且每个过程结束后先后手互换。

我们把这些过程对应的树上节点称为簇。

显然每个簇都会在父亲度数 $\ge 2$ 的奇深度节点处结束。

自下而上维护一些可能簇的子部分，记为组。

显然在奇深度节点处的组操作后先后手互换，在偶深度节点处的组操作后先后手不变。

对于一个奇深度节点，显然选簇的过程未结束，且他的所有儿子当前对应的先后手始终不边，因此新的组由当前点和所有儿子的组组成。

对于一个偶深度节点，由于两个人都会取尽可能小的簇，因此他会在自己儿子中最大的簇被选走后被取，把儿子中最大的组和当前点连起来成新组，剩下的组独立成簇。

最后两人从小到大轮流取簇即可。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
int fa[MAXN];
vector <int> G[MAXN],w[MAXN],C;
void dfs(int u,int c) {
	for(int v:G[u]) dfs(v,c^1);
	if(c) { //combine
		w[fa[u]].push_back(accumulate(w[u].begin(),w[u].end(),1));
		return ;
	}
	if(G[u].empty()) return C.push_back(0);
	//split
	int k=max_element(w[u].begin(),w[u].end())-w[u].begin();
	for(int i=0;i<(int)w[u].size();++i) {
		if(i!=k) C.push_back(w[u][i]);
		else (fa[u]?w[fa[u]]:C).push_back(w[u][i]);
	}
}
signed main() {
	int n;
	scanf("%d",&n);
	for(int i=2;i<=n;++i) scanf("%dc",&fa[i]),G[fa[i]].push_back(i);
	dfs(1,0);
	int ans=(n+1)>>1,x=-1;
	sort(C.begin(),C.end());
	for(int i:C) ans+=x*i,x=-x;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：yllcm (赞：1)

我来复读官方题解。

首先，一个节点的翻转次数是固定的，定义深度为到根经过的边数，则深度为偶数的节点最终颜色与刚刚放置时的颜色相等，深度为奇数的节点的最终颜色与刚刚放置时的颜色相反。假设深度为偶数的节点为红色，深度为奇数的节点为蓝色，那么假设 Alice 取了 $a$ 个蓝色节点，Bob 取了 $b$ 个蓝色节点，那么最后的答案是 $\left\lceil\dfrac{n}{2}\right\rceil-a+b$，说明 Alice 和 Bob 都希望能够最小化取到的蓝色节点个数。

假设 Bob 和 Alice 的策略均为：尽可能取红色节点，如果没有红色节点取则尽可能不让对方取到红色节点。那么如果某人取了一个节点，那么取完之后会引发一系列连锁反应，我们把取完某个节点之后，紧接着被取到的节点划分为一组。划分规则为：

* 如果有红色节点为叶子，那么红色节点为一组。
* 否则，去除所有已经分组了的节点，考虑所有满足其父亲有不止一个子节点的蓝色节点，将蓝色结点个数最小的满足上述条件的蓝色节点的子树划分为一组。
* 如此重复操作直至不能操作，剩下的节点为一组。

定义一组节点的权值为其中蓝色节点的个数，那么如果一个人取了这一组中的元素，那么它会取走这一组中所有的蓝色节点。那么策略为：按权值从小到大排序，两人一次取完一整组。注意到不会出现不合法的情况，即取完一个点的祖先再取这个点，因为可以发现存在祖先关系的组的权值是由子树到祖先递增的（由于我们率先取走了蓝色结点个数最小的子树）

为什么这样做是对的呢？考虑归纳证明。假设对于 $n$ 个点的树均满足上述规则，我们证明大小为 $n+1$ 的树仍然满足上述规则。

考虑反证，假设权值从小到大排序的结果为 $a,b,c\cdots,k,\cdots$，我们率先从权值为 $k$ 的组里面取走了一个结点，分类讨论：

* $k>1$，那么操作完之后会诞生一个红色叶子，取完红色叶子之后剩下的按规则处理，即两人取走的权值依次为 $1\to 0\to a\to b\to c\to \cdots \to k-1$，可以发现相比于原方案 $a\to b\to c\to \cdots \to k-1$，如果原本的方案中由后手取走了 $k$，那么后手相对于原来的方案要少取走一个结点，否则后手的方案不变。所以先手亏了。
* $k=1$，那么只有在 $a=0$ 的情况下才会有影响，此时方案为 $k=1\to a=0\to b\to c$，原来的方案为 $a=0\to k=1\to b\to c$，可以发现先手还是多取了一个结点。

所以结论成立。

[code](https://atcoder.jp/contests/arc164/submissions/43544520)

---


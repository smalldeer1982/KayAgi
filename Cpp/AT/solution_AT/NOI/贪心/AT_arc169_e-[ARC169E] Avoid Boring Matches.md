# [ARC169E] Avoid Boring Matches

## 题目描述

有一个编号从 $1$ 到 $2^N$ 的 $2^N$ 名参赛者参加的大会。

大会按如下方式进行：

- 首先，给每位参赛者戴上一顶红色或蓝色的帽子。每位参赛者所戴帽子的颜色由字符串 $S$ 给出。具体来说，$S$ 的第 $i$ 个字符（$1 \leq i \leq 2^N$）为 `R` 时，参赛者 $i$ 戴红帽，为 `B` 时戴蓝帽。
- 之后，重复以下操作直到只剩下 $1$ 名参赛者：
  - 当前有 $2k$ 名参赛者时，将他们分成 $k$ 组，每组 $2$ 人。分组方式可以自由选择。每组进行比赛，编号较小的参赛者必定获胜，编号较大的淘汰。
  
你认为，红帽参赛者之间的比赛是“无聊的”比赛。你的目标是，在整个比赛过程中，通过合理分组，使得不会出现任何一场无聊的比赛。

能否实现这个目标取决于字符串 $S$。因此，在比赛开始前，你可以对 $S$ 进行如下操作任意多次（可以为 $0$ 次）：

- 选择 $S$ 中相邻的两个字符，交换它们。

请判断，经过若干次操作后，是否可以实现目标。如果可以，请输出所需的最小操作次数。

## 说明/提示

### 限制

- $1 \leq N \leq 18$
- $S$ 是由 `R` 和 `B` 组成的长度为 $2^N$ 的字符串。
- 所有输入均为整数。

### 样例解释 1

如果不进行任何操作，无法实现目标。交换 $S$ 的第 $2$ 个和第 $3$ 个字符，使 $S = $`RBRB`，则可以实现目标。具体过程如下：

- 参赛者 $1,2,3,4$ 分别戴上红、蓝、红、蓝帽子。
- 将 $4$ 名参赛者分为两组 $(1,4),(2,3)$，此时不会出现无聊的比赛。比赛后，参赛者 $1,2$ 晋级。
- 将 $2$ 名参赛者分为一组 $(1,2)$，此时不会出现无聊的比赛。比赛后，参赛者 $1$ 晋级。
- 因此，答案为 $1$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
RRBB```

### 输出

```
1```

## 样例 #2

### 输入

```
1
RR```

### 输出

```
-1```

## 样例 #3

### 输入

```
4
RBBRRBRBBRBBBRBR```

### 输出

```
0```

## 样例 #4

### 输入

```
5
RBRRBRRRBRRRRRRRRRBBBBBBBBBBBBBB```

### 输出

```
11```

# 题解

## 作者：Aigony (赞：8)

[更好的阅读体验 qwq](https://www.cnblogs.com/ying-xue/p/arc169.html)

$\texttt{R}$ 比 $\texttt{B}$ 多一定无解，否则可以换成 $\texttt{BBBB...RRR}$ 的形式，一定有解。

先找判断序列合法的充要条件。

考虑每轮的最优匹配策略是什么样的，我们希望更多的 $\texttt{B}$ 能留到下一轮，因此要尽可能地让 $\texttt{B}$ 和它后面的 $\texttt{R}$ 配对。在多种配对方案能保留的 $\texttt{B}$ 数量相同时，我们希望留下的 $\texttt{B}$ 位置尽可能靠前，因为这样在下下轮它们被保留下来的概率更大。

因此我们得到这样的贪心策略：从左到右考虑每个 $\texttt{B}$，将它和右边第一个未被配对的 $\texttt{R}$ 配对。最终将所有剩下未配对的数两两配对。根据上文可以知道这样做是最优的。

设 $t_i$ 表示长度为 $2^i$，且所有 $\texttt{B}$ 尽可能靠右的合法解。

令 $t_0=\texttt{R}$。  
考虑怎么从 $t_{i-1}$ 得到 $t_i$。从左到右处理 $t_{i-1}$ 的每一位，若当前位是 $\texttt{R}$，表示这位没被匹配，$t_i=t_i+\texttt{R}$（$+$ 表示字符串拼接）；当前位是 $\texttt{B}$，我们希望下一个 $\texttt{B}$ 尽量靠后，即与之匹配的 $\texttt{R}$ 尽量更近，$t_i=t_i+\texttt{BR}$。不足 $2^i$ 位用 $\texttt{B}$ 补齐。

设 $t_n$ 的第 $j$ 个 $\texttt{B}$ 的位置为 $T_j$，原序列位置为 $S_j$。那么若存在 $S_j>T_j$，则该序列不合法。证明大概是如果一个 $S_j<T_j$，匹配数不会变多；但如果 $S_j>T_j$，$\texttt{BR}$ 的匹配数一定减少。

答案是令 $S$ 满足上述条件的最小操作次数，即 $\sum\limits_{j=1}^{2^n} \max(0,T_j-S_j)$。时间复杂度 $\mathcal{O}(2^n)$。

```cpp
const int N=(1<<18)+5;
int n;
string s,t[N];
int tot,pos[N];
int main()
{
	n=read(); cin>>s;
	t[0]="R";
	for(int i=1;i<=n;i++)
	{
		for(auto c:t[i-1]) 
			if(c=='R') t[i]+="R";
			else t[i]+="BR";
		while(t[i].size()<(1<<i)) t[i]+="B";
	}
	for(int i=0;i<(1<<n);i++) if(t[n][i]=='B') pos[++tot]=i;
	tot=0; long long ans=0;
	for(int i=0;i<(1<<n);i++) if(s[i]=='B') 
	{
		tot++;
		if(i>pos[tot]) ans+=i-pos[tot];
		if(tot==(1<<n-1)) break;
	}
	if(tot<(1<<n-1)) printf("-1\n");
	else printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：include13_fAKe (赞：5)

本篇题解同步发表于我的 [AtCoder 补题记录](https://www.luogu.com.cn/article/lt49zcth)。

蒟蒻初二时看到晚上有一场 ARC，兴致勃勃地去打了一下，没想到被 A 题硬控，爆零了。

如今，我重新理了一下当时的几个题，觉得这个题特别有意思，写篇题解纪念一下。

这也是我的第一篇黑题题解。

## 考察知识点

- 【2】string 类与相关函数
- 【3】贪心法

本题难度较大，主要考察选手对贪心法的灵活运用，同时也需要选手对 string 类有一定的理解。

## 判断某一种已排好的状态是否合法

贪心法。

因为不能将两个 $\texttt R$ 配对，所以任何 $\texttt R$ 的数量大于 $\texttt B$ 的字符串都是不合法的。

每一次将第一个人和后面任意一个人匹配，将这两个人从队列内删除，更新队内人的编号。

如果目前的 $1$ 号人帽子为 $\texttt{R}$，需要选取一个 $\texttt{B}$。因为 $\texttt{B}$ 对后面的要求较为宽松（不能都是 $\texttt{R}$，但可以都是 $\texttt{B}$），所以尽量选位置偏后的 $\texttt{B}$。

如果目前有一个 $\texttt B$，应该首先考虑和 $\texttt R$ 配对，**配对掉编号最小的 $\texttt R$。**

如果没有 $\texttt R$，也从后面开始匹配 $\texttt B$。

## 求长度为 $2^n$ 的字典序最大的合法字符串

用 $t_n$ 代表长度为 $2^n$ 的字典序最小的合法字符串，规定 $\texttt B\le\texttt R$。

首先定义 $t_0=\texttt R$。但实际上它不会被最终使用。

之后求 $t_i$ 时遍历 $t_{i-1}$，若 $t_{i-1,j}=\texttt R$，就直接新增一个 $\texttt R$，否则新增一个 $\texttt {BR}$。

若新增不够长度，直接在最后增加若干个 $\texttt B$ 即可。

所以 $t_1=\texttt{RB},t_2=\texttt{RBRB},t_3=\texttt{RBRRBRBB}$。以此类推。

## 如何计算答案

令 $S_i$ 为 $S$ 串中的第 $i$ 个 $\texttt B$ 的位置，$T_i$ 为 $T_n$ 串中第 $i$ 个 $\texttt B$ 的位置。可通过往前移动 $S$ 串中的 $\texttt B$，实现 $S_i\le T_i$。

答案即为 $\sum \max(0,S_i-T_i)$。

扫一遍即可，时间复杂度 $O(2^n)$。

## 代码

需要对字符串函数的时间复杂度和字符串的下标问题稍微注意一下，不然会 TLE。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n;
string s;
string t;
string t1;	//滚动 t  
int sch[3*114514];
int tch[3*114514];
int ptr1,ptr2;
int include13=0;
signed main(){
	memset(sch,0x3f,sizeof(sch));
	memset(tch,0x3f,sizeof(tch));
	cin>>n;
	cin>>s;
	int n1=1<<n;
	s=' '+s;
	int a=0,b=0;
	for(int i=1;i<=n1;i++){
		a+=(s[i]=='R'),b+=(s[i]=='B');
	} 
	if(a>b){
		puts("-1");
		return 0;
	}
	t='R';
	for(int i=1;i<=n;i++){
		int n_=1<<i;
		int t_=t.size();
		for(int j=0;j<t_;j++){
			if(t[j]=='R')	t1+="R";
			else	t1+="BR";
		}
		while(t1.size()<n_)	t1+="B";
//		cout<<t1<<endl; 
		t=t1;
		t1="";
//		while(t1.size())	t1.erase(0,1);
	} 
//	cout<<endl;
//	return 0;
	for(int i=1;i<=n1;i++){//枚举 s 
		if(s[i]=='B'){
			ptr1++;
			sch[ptr1]=i;
//			cout<<ptr1<<' '<<i<<endl;
		} 
	}
//	cout<<endl;
	for(int i=0;i<t.size();i++){
		if(t[i]=='B'){
			ptr2++;
			tch[ptr2]=i+1;
//			cout<<ptr2<<' '<<i+1<<endl;
		}
	}
//	cout<<endl;
	for(int i=1;i<=3e5;i++){
		include13+=max(0ll,sch[i]-tch[i]);
	}
	cout<<include13<<endl;
	return 0;
}//午睡操场传来蝉的声音 多少年后仍然是很好听  
```

---

## 作者：zyn0309 (赞：3)

# [ARC169E] Avoid Boring Matches
[题目传送门](https://www.luogu.com.cn/problem/AT_arc169_e)
## 思路

### 判无解
首先考虑无解情况。当 ```R``` 比 ```B``` 的数量更多时，因为每一个 ```R``` 都会用掉一个 ```B``` ，最终一定会剩下 ```R``` 和 ```R``` 匹配，此时无解。否则可以把所有的 ```B``` 换到前面，每一个 ```B``` 和它后面的一个 ```R``` 匹配，就是一组有解的方案。

### 构造配对方案
受到上文构造有解方案时的启发，很容易发现要尽量将 ```B``` 往前放，也就是要尽量让靠前的 ```R``` 消掉。每一轮都从前往后遍历 $s$ ，如果 $s_i$ 为 ```B```，就将 $s_i$ 与它右边离它最近的 ```R``` 来匹配，这样做既可以保留前面的 ```B``` ，还可以消掉前面的 ```R```。然后如果还有 ```R``` 无法消掉，就把它和靠后的 ```B``` 匹配，这样能使留下的 ```B``` 更靠前。

### 判断怎样转移最优
但是上面这种方法并不能使我们直接判断出对于**不合法状态**该怎么交换。根据前文的推导，如果一个状态不合法一定是 ```B``` 太过靠后了。若是 $s$ 中的第 $i$ 个 ```B``` 导致的不合法，此时我们将导致**不合法状态**的第 $i$ 个 ```B``` 向一个 ```B``` **最靠后且合法**的状态内的第 $i$ 个 ```B``` 的位置转化肯定是最优的，答案即为所有**不合法**位置和**最靠后且合法**的位置的差的和。

（```B``` 最靠后指让串的字典序尽量大）
### 如何得出长度为 $2^n$ 的 ```B``` 最靠后且合法的串
定义 $t_i$ 为长度为 $2^i$ 的 ```B``` 最靠后且合法的串。

显然 $t_0 = $ ```R``` 。

根据上文的推导，得出从 $t_{i-1}$ 到 $t_i$ 的转移。

从头遍历 $t_{i-1}$ ，若 $t_{i-1,j}$ 为 ```R``` ，在 $t_i$ 末尾加入一个 ```R``` ，否则在加入末尾加入 ```BR``` ，最后在 $t_i$ 最后加入 ```B``` 直到 $t_i$ 长度为 $2^i$。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+10;
int n,len,a[N],b[N],cntR,cntB,cnt;
string s,t,last;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>s;
	s='$'+s;
	for(int i=1;i<s.size();++i){
	  if(s[i]=='B')a[++cntB]=i;
	  else ++cntR;
	}
	if(cntR>cntB){
	  cout<<"-1\n";
	  return 0;
	}
	len=1;
	last="+R";
	for(int i=1;i<=n;++i){
	  len<<=1;
	  t="+";
	  for(int j=1;j<=len/2;++j){
	  	if(last[j]=='R')t+="R";
	  	else t+="BR";
	  }
	  while(t.size()<=len)t+="B";
	  last=t;
	}
	for(int i=1;i<=len;++i)if(t[i]=='B')b[++cnt]=i;
	int ans=0;
	for(int i=1;i<=len/2;++i)ans+=max(0ll,a[i]-b[i]);
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：FyFive (赞：3)

# ARC169E 题解

大智若愚，这才是 ARC 的常态，3333 的实力。

![](https://cdn.luogu.com.cn/upload/image_hosting/q9jd3xf4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

[或许更好的阅读体验？](https://www.cnblogs.com/Fy5-FyFive/articles/17935110.html)

## 题意

感觉翻译讲的不是很清楚，那我就再翻一遍吧。

现在有 $2^n$ 个参赛选手，编号为 $1 \sim 2^n$。

现在你需要操作 $n$ 轮，每轮的操作如下：
- 若场上还剩 $2k$ 名选手，那么你需要将其**任意**划分为 $k$ 组，每组两个人，一个人能且仅能被划分进一个组。
- 划分完成后，每组内的两个人将进行「比赛」,「比赛」结束后编号大的将会淘汰，编号小的会留下来参与下一轮操作（并保留编号）。

同时，每个人拥有一个属性 `R` 或 `B`，如果在操作中的**任意**时刻，**存在**一个组中满足其中的两个人全部为 `R` 属性，则称这一个组为「无聊」的。

现给你这 $2^n$ 个选手的属性，记作长为 $2^n$ 的字符串 $S$。在操作过程中，你只能以任意方案划分而不能更改某一个选手的属性，所以，在开始操作之前，你需要对所有选手的属性进行调整，使得 $S$ “合法”。“合法”定义为，在任意时刻，均不存在「无聊」的组。每次调整中，你可以交换一次 $S$ 中相邻两个字符。

如果无论如何调整都不可能“合法”，输出 ```-1```；否则，输出使得 $S$ 合法的最少的调整次数。

数据范围：$1 \leq n \leq 18$。

## Solution

以下做法来自[官方题解](https://atcoder.jp/contests/arc169/editorial/7913)。

首先，考虑什么时候必须要输出 ```-1```。不难发现这是显然的，当 $S$ 中 `R` 的个数大于 `B` 的个数时，基于鸽巢原理可以发现，第一轮就必定会有一个「无聊」的组。否则，可以将 $S$ 调整为一个全为 `B` 的前缀和一个全为 `R` 的后缀的拼接，然后在第一轮将每一个 `R` 与任意的 `B` 配对为一组，这样第一轮结束之后场上就不剩下属性为 `R` 的选手了。

在判出无解之后，剩下的一定是有解的，那么就来做第二问，最小化调整次数。

### 考虑最坏情况是什么

最坏情况，即 $S$ 中刚好有一半的 `R` 和一半的 `B`，不难发现将非最坏情况下把 $S$ 中的后几个 `B` 转变为 `R` 使其变为最坏情况是不影响答案的，那么直接考虑最坏情况下答案的计算即可。

### 考虑如何判断某一个 $S$ 是否合法

#### 考虑如何配对可以使得「无聊」的组总数尽可能小（直至为 $0$）

以编号从小到大的顺序考虑每一轮匹配。（匹配过程中，不考虑已经被匹配过的选手。）

如果当前选手属性为 `R`，那么他只能与一个 `B` 匹配，由于越靠后的 `B` 越难往后匹配到 `R`，所有当前选手应该挑选最后一个 `B` 匹配。

如果当前选手属性为 `B`，那么他理论上既可以与 `R` 匹配，又可以与 `B` 匹配，那么不妨将其与往后最近的 `R` 匹配，以使得更后面的 `B` 也能匹配到 `R`，实在没有 `R` 了，再与 `B` 配对。同时，不难发现最坏情况下不会出现 `B` 与 `B` 配对。

由此不难证明上文所述“把非最坏情况转变为最坏情况”确实不影响答案，那么后文中出现的 $S$ 若无特殊说明，均属于最坏情况。

#### 考虑构造一个 $S$ 的最值，通过最值判定 $S$ 是否合法

下文中的“最大”定义为：$S$ 中所有的 `B` 的位置都尽量靠后。

考虑字符串长度为 $2^n$ 时最大的合法的 $S$，记为 $T(n)$。由上文，不难发现如果一个长为 $2^n$ 的 $S$ 如果比 $T(n)$ 还要大，那么这个 $S$ 一定不合法。

接下来考虑如何比较 $S$ 与 $T(n)$ 的大小，也即判断 $S$ 是否合法。

考虑把 $S$ 与 $T(n)$ 中的所有的 `R` 替换为 $-1$，将所有的 `B` 替换为 $1$，然后对 $S$ 和 $T(n)$ 分别求前缀和，并记作数列 $A$ 和 $B$。考虑对于每一个 $i$，$A_i$ 和 $B_i$ 的大小关系，一个结论是 $S$ 合法当且仅当 $\forall i \in [1,2^n],A_i \geq B_i$。

结论的证明，官方题解使用了数学归纳法。感性理解就是，假设存在一个 $i$ 使得 $A_i < B_i$，那么由于前面的 `R` 太多，后面的 `B` 很快会被消耗完，然后就会至少有一回合会出现「无聊」的组。感觉，官方题解讲的也不是蛮清晰，弗如感性理解。这个结论的充分性是很好理解的，如果满足 $\forall i \in [1,2^n],A_i \geq B_i$，那么说明 $S=T(n)$ 或者 $S$ 中某些 `B` 的位置比 $T(n)$ 中对应的 `B` 更靠前，那么自然也就合法。

#### 计算 $T(n)$

$T(n)$ 的构造可以考虑反向配对的贪心操作，从初始串 $T(1)=$```RB``` 开始，每一次 $n$ 的增加，在 `B` 的后面紧跟一个 `R`，然后在结尾添加 `B` 将长度补齐到 $2^n$。

### 计算答案

交换相邻两个字符可以使得前缀位置总差值减少 $2$，那么答案也就是所有位置的差值之和（忽略 $A_i$ 已经大于 $B_i$ 的位置）除以 $2$。

### 时间复杂度

$O(2^n)$，常数主要来源于 $T(n)$ 的计算。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[300005];
string s,t="RB",tp;
int n,c,i,j;
int main()
{
	cin>>n;
	for(i=2;i<=n;++i)
	{
		tp="";
		for(j=0;j<(1<<i-1);++j,tp+="R") if(t[j]=='R') ++c; else tp+="B";
		while(c--) tp+="B";
		t=tp;
	}
	n=1<<n,cin>>s;
	for(i=0;i<n;++i) a[i]=(t[i]=='R'?-1:1),a[i]-=(s[i]=='R'?-1:1);
	long long S=0; for(i=1;i<n;++i) a[i]+=a[i-1],S+=(a[i]>0?a[i]:0);
	cout<<(a[n-1]>0?-1:S/2);
	return 0;
}
```

显然是有常数更小的计算 $T(n)$ 的实现的，这里就不讲了。

（Upd 23.12.29 补充了一点关于结论的充分性的感性理解。）

---

## 作者：eastcloud (赞：1)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17970806)

首先考虑**无解的情况**，一个显然的观察是如果 `R` 的个数大于一半，那么无论如何都会出现两个 `R` 比赛的情况，小于一半时我们可以调整使得 `B` 全都在前面，显然有解。

接下来问题变为找到最优可行解，但是状态的合法性不是显然的，我们先尝试**判定**这个问题。

先考虑第一轮比赛，显然我们想让 `B` 获胜的尽可能多且编号尽可能靠前，因此，我们从左往右扫描序列，如果一个 `B` 还没有对手，那么从后面找到一个最接近的 `R` 当它的对手肯定最优，因为这样既能保证保留较小的 `B` 又能尽量把 较大的 `R` 留到后面，而最后没匹配到的无论怎么匹配结果肯定都一样。

这样对每一轮进行这个操作，如果过程中出现了不合法的情况即为无解，但是这样暴力进行判定并转移还是太慢了，现在要么优化转移要么优化判定，但这个题目在转移上没有什么特别好的性质，我们先尝试**在判定方面进行优化**。

考虑每一轮匹配的时候能不能不进行实际操作，只靠某些关键信息就能判定无解，由于上文我们提到在匹配完后没匹配到的无论怎么匹配结果都是一样，因此我们可以将某些 `B` 和 `B` 匹配的对子中最后一个 `B` 换成 `R`，这样可以少考虑一个个数的因素。

剩下的就是位置的信息了，你发现第一个 `B` 靠前会优，而靠后到某一位置后可能就无解，其他的也一样，这个位置比较的过程其实有点像比较字典序，那存不存在一个最劣字符串使得比这个字符串大的字符串都可行呢？

实际上是存在的，但是由于这个消除的过程类似二分图匹配，这个大小关系的比较不是简单地比较字典序，而是考虑将 `R` 设为 -1，`B` 设为 1 并计算前缀和，我们要求前缀和每一位都大于等于最劣串的前缀和。

这个结论的充分性可以用归纳法证明，或者你可以感性地想象一下相消的过程，总之，这个字符串不仅存在，并且是易于通过递归求出的，当我们得到前一轮的最劣串时，由于每个 `B` 此时又可以解决一个 `R`，因此我们在每个 `B` 后面紧跟一个 `R` 表示字典序最小，然后在最后补齐 `B` 就可以了。

答案的计算则是简单的，由于我们要前缀和全部大于等于，且一次交换能将前缀差值增加 2，因此只要计算不够的部分的和然后除以 2 即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 2000005
using namespace std;
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0' || ch>'9')f=(ch=='-'?-1:1),ch=getchar();
	while(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f;
}
void write(ll x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
ll a[N];
int main(){
	ll n=read(),cnt=0;
	string s="RB";
	for(ll i=2;i<=n;i++){
		string t="";
		for(ll i=0;i<s.length();i++){
			t+=s[i];if(s[i]=='B')t+='R';
		}
		while(t.length()<(1<<i))t+='B';
		s=t;
	}	
	string t;cin>>t;ll S=0;
	for(ll i=0;i<(1<<n);i++)cnt+=(t[i]=='R');
	if(cnt>(1<<(n-1))){cout<<-1;return 0;}
	for(ll i=0;i<(1<<n);i++)a[i]+=(s[i]=='R'?-1:1),a[i]-=(t[i]=='R'?-1:1);
	for(ll i=0;i<(1<<n);i++){
		if(i!=0)a[i]+=a[i-1];
		S+=(a[i]>0?a[i]:0);
	}
	cout<<S/2;
	return 0;
}

```


---


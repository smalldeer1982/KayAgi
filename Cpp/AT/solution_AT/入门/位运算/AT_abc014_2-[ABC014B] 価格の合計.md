# [ABC014B] 価格の合計

## 题目描述

你正在购物，从商品列表中选取了一些商品。现在，你需要计算这些商品的总价格。

顺便一提，有一种方法可以用二进制来表示某个集合的任意子集，这种方法常用于用 for 循环枚举所有子集（组合）时。

- 假设有 $n$ 个商品，分别为商品 $0$、商品 $1$、……、商品 $n-1$。请注意，商品编号从 $0$ 开始。
- 用十进制整数 $X$ 表示一个子集，其 $n$ 位二进制表示为 $b_{n-1}b_{n-2}\ldots b_1b_0$。其中 $b_0$ 是最低位，$b_{n-1}$ 是最高位。请注意，这种表示允许前导 $0$。
  
然后，利用这个整数 $X$ 的二进制表示，可以如下定义一个子集：

- 如果 $b_0=1$，则集合包含商品 $0$；如果 $b_0=0$，则集合不包含商品 $0$。
- 如果 $b_1=1$，则集合包含商品 $1$；如果 $b_1=0$，则集合不包含商品 $1$。
- ...
- 如果 $b_{n-1}=1$，则集合包含商品 $n-1$；如果 $b_{n-1}=0$，则集合不包含商品 $n-1$。

例如，当 $n=4, X=5$ 时，$b=0101$，对应的子集为 $\{商品0, 商品2\}$。简而言之，在 $X$ 的二进制表示中，第 $k$ 位（$0\leq k\leq n-1$）为 $1$ 时，表示包含第 $k$ 个商品。是否包含某一位可以通过大多数编程语言轻松判断，请自行查阅相关方法。

你的任务是：给定商品数量、每个商品的价格，以及表示子集的十进制整数 $X$，计算该子集中所包含商品的总价格。

※本题虽然与此无关，但通过上述方法可以用 $0$ 到 $2^n-1$ 的连续整数表示大小为 $n$ 的集合的所有子集（包括空集），在需要全枚举时可以加以应用。

## 说明/提示

### 样例解释 1

$n$ 和 $X$ 与题目描述中的示例一致。子集为 $\{商品0, 商品2\}$，因此 $1+100=101$。

### 样例解释 2

$X$ 的二进制表示为 $11111111111111111111$（共 $20$ 个 $1$），因此子集包含所有商品。

### 样例解释 3

子集也可能为空集。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 5
1 10 100 1000```

### 输出

```
101```

## 样例 #2

### 输入

```
20 1048575
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20```

### 输出

```
210```

## 样例 #3

### 输入

```
4 0
1000 1000 1000 1000```

### 输出

```
0```

# 题解

## 作者：_Qer (赞：6)

题意不多说了，直接看做法

位运算大法好

$a>>i$  相当于  $a/2^i$

$a\&1$ 相当于取a的二进制下的最后一位

只要用以上两个运算即可轻松解决本题

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a, sum;
int main() {
    cin >> n >> m;//如题
    for (int i = 0; i < n; ++i)
    {
        cin >> a;//数字
        sum += ((m >> i) & 1 ? a : 0);//问号运算符
        /*
        上面一句等价于
        if ((m >> i) & 1 == 1)
        {
        	sum += a;
        }
        else
        {
        	sum += 0;
        }
        */
    }
    cout << sum << endl;
    return 0;
}
```

---

## 作者：赤霞QvQ (赞：3)

题意不分析，特别好理解

就是化为$2$进制$+$做加法

直接上程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m;
	cin>>n>>m;
	int a[10000],l=0;
	while(m!=0)     //Part 1:化为2进制
	{
		l++;
		a[l]=m%2;     //每一位存下来
		m/=2;
	}
	int s=0,k;
	for(int i=1;i<=n;i++)     //Part 2:做加法
	{
		cin>>k;
		if(a[i]==1)
		{
			s+=k;
		}
	}
	cout<<s<<endl;
	return 0;
}
```

就是这么一道大水题

---

## 作者：Neoomgg (赞：3)

思路：转二进制——>切片——>判断——>输出

本JR~~怕超时空~~，直接将上面用过不用的变量重复使用了，因此代码看得可能会比较乱

---
（上面依旧是一条蟒蛇，嗯……）

```python
n, m = map(int, input().split())
b = bin(m)[2:]
m = b[::-1]
b = 0
c = tuple(input().split())
n = len(m)
for i in range(n):
    if m[i] == '1':
        b += int(c[i])
print(b)
```

---

## 作者：爬行者小郑 (赞：1)

# 一道很水的位运算题
每次要访问下一位，将m右移一位即可

为什么楼上都喜欢问号运算符。。。搞不懂
## 下面我用C语言解决这个问题，C++看了好多篇。。。
```c
#include <stdio.h>//输入输出流 
int n,m,ans,i;//i需要在外面定义 
int main()
{
	int x;//每次要读的数 
	scanf("%d%d",&n,&m);//输入n，m 
	for(i=1;i<=n;i++)//不能重复定义i 
	{
		scanf("%d",&x);//读入x 
		if(m&1)ans+=x;//如果最后一位是1，ans+=x 
		m>>=1;//每次都右移一位，就是去掉最后一位 
	}
	printf("%d\n",ans);//输出答案 
}
```
不要抄袭呀。

---

## 作者：LiveZoom (赞：0)

# 题解 AT1010 【価格の合計】
此题是道可以用位运算的题目，因为位运算特别快，所以我就用它了。
## 位运算
- 逻辑运算符

1.与运算&:
两位都是1，这位才是1。显然a&1可以表示为a%2（这就不用讲了吧~）

2.异或运算^：
两位相同为0，不同为1。

3.或运算|：有一个是1就是1。

4.取反运算~:每位取反

- 移位运算符

1.>>：右移，$a>>i=\dfrac{a}{2^i}$

2.<<：左移，$a>>i=a \times 2^i$


## 此题代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
int x;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		if(m&1)ans+=x;//如果此时的最后一位是1，则更新
		m>>=1;//m右移1位
	}
	printf("%d\n",ans);
    return 0;
}
```

# The end


---

## 作者：CZQ_King (赞：0)

位运算这种东西从来不用，数据不大，模拟即可。

------------
做法：模拟，详见代码。转二进制后的数组开$20$就够了，因为
$m$最大也就$2^{20}-1$

------------
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,binary[20],w,ans,j;
int main(){
	cin>>n>>m;
	while(m){//将m转成2进制
		binary[j++]=m%2;
		m/=2;
	}//不用翻转！！方便在于下面访问第i个
	for(int i=0;i<n;i++){
		cin>>w;//用一个变量数就行了
		if(binary[i]==1)ans+=w;//如果符合
	}
	cout<<ans<<endl;//最后输出答案
	return 0;
}
```

---


# 2012年12月02日

## 题目描述

今天是 $2012$ 年 $12$ 月 $02$ 日，将由月和日构成的数字 $1202$ 重新排列可以变成表示年份的 $2012$ ，这样的日子就是好日子。判断给出的日期是否是好日子。

# 题解

## 作者：2011hym (赞：7)

**蒟蒻的第一篇题解**

## 题目大意

给定一个长度为 $4$ 的年份字符串与长度均为 $2$ 的月份和日期的字符串，判断月份和日期的四个数字能否与年份的数字相同。

## 题目分析

先定义两个 char 数组存储年份以及日月（日期和月份），排序，对比是否完全相同，再依题意输出```yes``` 与 ```no```。

然而，这个题目有两个**坑点**：

1. 在年份，月份和日期的中间，有个 $/$ 。
2. 此题的结尾要**换行**~~（我绝不会告诉你我因为这个改了四次代码）~~。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[8],b[8],b1[4],b2[4],f,g;//定义字符，f，g是那两个 / 。
int main(){
	for(int i=1;i<=4;i++){
		cin>>a[i];//年份输入。
	}
	cin>>f;//分隔。
	for(int i=1;i<=2;i++){
		cin>>b1[i];//月份。
		b[i]=b1[i];//将它转化为月份和日期的总归类中，一会方便排序。
	}
	cin>>g;//分隔。
	for(int i=1;i<=2;i++){
		cin>>b1[i];//日期。
		b[i+2]=b1[i];//同上。
	}
	sort(a+1,a+5);//将年份和日月从小到大排序。
	sort(b+1,b+5);//要注意是从a[1]与b[1]开始计数的。
	for(int i=1;i<=4;i++){//从头开始对比。
		if(a[i]!=b[i]){//如果有不相同的。
			cout<<"no\n";//直接输出no。
			return 0;//返回。
		}
	}
	cout<<"yes\n";//记得换行。
	return 0;//优雅结束。
}

---

## 作者：zhangzirui66 (赞：2)

题意简洁明了，无需赘述。

观察发现，答案合法当且仅当年与月和日出现每个数字出现的次数一样，每个字母可以用桶记录次数，为了省空间我使用了 `map` 进行映射。
### My Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<char, int> mp, mp2;
int main(){
    string s;
    cin >> s;
    for(int i = 0; i < 4; i ++) mp[s[i]] ++;//年在前4位
    for(int i = 5; i < 7; i ++) mp2[s[i]] ++;//月
    for(int i = 8; i < 10; i ++) mp2[s[i]] ++;//日
    for(int i = 0; i < 4; i ++){//这里看不懂后面解释。
        if(mp[s[i]] != mp2[s[i]]){
            cout << "no\n";
            return 0;
        }
    }
    cout << "yes\n";//ATCoder特性，需输出换行。
    return 0;
}
```

  代码中需要解释的那一部分其实很简单，我们要对比年月日的关系，只需要遍历年的元素即可。

---

## 作者：_Star_Universe_ (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/AT_utpc2012_01)
### 思路
输入一个字符串，忽略分隔用的 `/`，年份存在第一个字符数组中，月份和日期存在第二个字符数组中，将两个字符数组中的元素升序排列，最后一边遍历一边比较，发现一个不一样就输出 `no`，全部一样就输出 `yes`。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
char first[4],second[4];
int main(){
	cin>>s;
	first[0]=s[0],first[1]=s[1],first[2]=s[2],first[3]=s[3];
	second[0]=s[5],second[1]=s[6],second[2]=s[8],second[3]=s[9];
	sort(first,first+4);
	sort(second,second+4);
	for(int i=0;i<4;i++){
		if(first[i]!=second[i]){
			cout<<"no\n";
			return 0;
		}
	}
	cout<<"yes\n";
	return 0;
}
```

---

## 作者：___Segment___ (赞：1)

## 题目大意

以 $yyyy/mm/dd$ 的格式输入一个日期（其中 $y$ 是年，$m$ 是月，$d$ 是日，可能有前导 $0$），判断月份和日期的数字（包含前导 $0$）重新排列后是否可以组成年的数字。

> 举例：$2005$ 年 $05$ 月 $20$ 日，月份和日期组成的数字为 $0520$，经过重新排列后可以得到 $2005$。

## 解题思路

为方便处理，可以采用字符串存储年月日。\
考虑定义一个字符串 $st$ 来存储月份和日期，然后从小到大求出 $st$ 的所有排列，然后与年份比对即可。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string y, m, d;
    getline(cin, y, '/'); // 按照题目要求输入（getline 函数具体用法见文末）
    getline(cin, m, '/');
    cin >> d;

    string st = m + d; // 把月份和日期合成一个字符串
    sort(st.begin(), st.end()); // 排序后得到最小的排列

    bool p = 0; // 用于标记是否是“好日子”
    do { // 一定要用 do_while，用 while 会忽略最小的排列
        if (st == y) { // 判断是否可以组成年份
            p = 1;
            break;
        }
    } while (next_permutation(st.begin(), st.end())); // next_permutation 函数求下一个全排列（具体用法见文末）

    if (p)
        printf("yes\n"); // 判断并输出
    else
        printf("no\n");
    return 0;
}
```

## 总结

- 算法：模拟、枚举
- 考察点：全排列

## 备注

- `getline(it,s,ch)` 函数用于从 $it$ 读取数据，当读取到 $ch$ 结束。结果存储在 $s$ 里（$ch$ 会被读入，但不会被存储）。
- `next_permutation(l,r)` 函数用于求区间 $[l,r)$ 的下一个全排列，并存放在原来的空间里。若没有下一个全排列，该函数返回 `false`。

---

## 作者：I_AM_ACer (赞：1)

**[题目传送门](https://www.luogu.com.cn/problem/AT_utpc2012_01)**
## 题目大意
给你三个字符串 $n$，$y$，$r$ 如果 $y$ 和 $r$ 里的字符可以组成 $n$，那么输出 `yes` 否则输出 `no`。
## 做法分析
我看到很多大佬都是用桶写的，但是我想到了另一种方法。首先，我们输入的字符串 $s$ 中的年份，月份和日期都是 $4$ 位数，所以我们可以开一个数组 $a$ 用来统计年份，再开一个数组 $b$ 来统计月份和日期。这样的话两个数组里都只有 $4$ 个数字，就可以比较了。不过字符串 $s$ 中还会有 `/` 用来把年月日分开来，所以我们在统计时还要记得把 `/` 去掉。接着我们 sort 快排再判断 $a$，$b$ 数组是否完全相同就行了。
## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()//快读
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f=-1;	
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0',ch=getchar();
	}
	return x*f;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	string s;//字符串
	cin>>s;//输入
	int a[10],b[10];//年份，月份和日期
	int cnt=0;//记录是第几位月份或日期
	for(int i=0;i<s.size();i++)
	{
		if(s[i]!='/'&&i<4)//年份只有4位且不要忘了把'/'去掉
		{
			a[i]=s[i]-'0';//年份的第i位
		}
		if(s[i]!='/'&&i>4)//月份和日期只有4位，再年份和'/'后面且不要忘了把'/'去掉
		{
			b[cnt]=s[i]-'0';//月份和日期的第cnt位
		}
		if(i>4&&s[i]!='/')//不要忘了把'/'去掉
		{
			cnt++;
		}
	}
	sort(a,a+4);//排序
	sort(b,b+4);//排序
	for(int i=0;i<4;i++)
	{
		if(a[i]!=b[i])//因为已经sort快排过了所以如果年份和日月份相同时两个数组的值会完全一样
		{
			cout<<"no"<<endl;//输出
			return 0;
		}
	}
	cout<<"yes"<<endl;//输出
	return 0;//AtCoder 的题千万别忘了换行！！！
}
```

---

## 作者：sbh2012 (赞：1)

## 题意
给出年、月、日，求能否将月和日的数字重新排列，得到年。
## 思路
用字符存储年月日，用一个字母桶记录年、月和日，数字分别出现的次数，最后判断每个数出现次数是否相同即可。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
map<char,int> mp; 
map<char,int> mp1;
//字母桶
int main(){
	string s;
	cin>>s;
	for(int i=0;i<4;i++){
		mp[s[i]]++;//记录年中数字分别出现的次数
	}
    //s[5]是/
	for(int i=5;i<10;i++){
		if(i!=7){//这个字符是/
		    mp1[s[i]]++;//记录月和日中数字分别出现的次数
        }
	}
	for(int i=0;i<4;i++){
        if(mp[s[i]]!=mp1[s[i]]){//每个数出现次数是否相同
            cout<<"no\n";
            return 0;
        }
    }
	cout<<"yes\n"; 
	return 0;
}

```

---

## 作者：Dallda_Mavericks (赞：1)

## 题目大意：
给第一个年份字符串，判断月份和日期的四个数字能否与年份的数字相同。

## 做法：

本题思路和桶排序很像。

首先将前四位 $(s[0]-s[3])$ 的字符转化成数字，存到 $a$ 数组中。

然后再将后面四位字符 $(s[4]-s[7])$ 转化成数字存到 $b$ 数组中。

最后用一个 for 循环比较两个数组是否完全相同，若有一出不同就输出 `no`，若没有就输出 `yes`。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10],b[10];
int main(){
	string s;
    cin>>s;
    for(int i=0;i<4;i++){
    	a[s[i]-'0']++;
    }
	for(int i=4;i<s.size();i++){
		b[s[i]-'0']++;
	}
	for(int i=0;i<10;i++){
		if(a[i]!=b[i]){
			cout<<"no"<<endl;
			return 0;
		}
	}
		cout<<"yes"<<endl;
	return 0;
}
```

---

## 作者：Beautiful_nebula (赞：1)

很简单，可将前五位分成一组，后五位另分一组，将两个字符数组按照字典序升序排列，然后将每个字符逐个比较，发现不一样就输出 `no`，全部一样输出 `yes`，注意换行。

```cpp
#include<bits/stdc++.h>
using namespace std;

char f[5],s[5];
int main(){
    cin>>f[0]>>f[1]>>f[2]>>f[3]>>f[4]>>s[0]>>s[1]>>s[2]>>s[3]>>s[4];
	sort(f,f+5);
	sort(s,s+5);
	for(int i=0;i<5;i++){
		if(f[i]!=s[i]){
			cout<<"no\n";
			return 0;
		}
	}
	cout<<"yes\n";
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

少有的红题能写题解的，水一篇。

把月和日组合起来的数看作一个序列 $p$，年看作一个序列 $q$。

不需要真的重排，容易想到如果 $p$ 中每个数出现的次数和 $q$ 中一样就一定能构造出来。

复杂度 $O(1)$。

当然直接全排列的复杂度也是可以的。

```cpp
#include<bits/stdc++.h>
int cnt[10];
char a,b,c,d,e,f,g,h;
int main()
{
	scanf("%c%c%c%c/%c%c/%c%c",&a,&b,&c,&d,&e,&f,&g,&h);
	cnt[a-48]++,cnt[b-48]++,cnt[c-48]++,cnt[d-48]++;
	puts((!cnt[e-48]--||!cnt[f-48]--||!cnt[g-48]--||!cnt[h-48]--)?"no":"yes");
}
```

---

## 作者：goIdie (赞：0)

## 思路

此题的题意可以这样理解，年份为一个字符串，月+日为一个字符串，然后判断是否可以通过重新排列组合使两个字符串相等。

不难发现，如果一个字符串 $a$ 可以通过重组变为字符串 $b$，那么排序后的 $a$ 和 $b$ 一定相等。随后照此思路模拟即可，排序可以使用 `sort`，还要注意忽略输入中的斜杠。

代码比较简单，思路也很清楚了，故不再展示。

---

## 作者：koukou (赞：0)

这里讲一种简单易懂的方法。

## 思路

当我们有字符串 `bac` 和 `acb` 时，如何看它们的字母是否相等？

其实很简单，先分别对两个字符串排序，这时，如果字母相等，排完序后的字符串也就自然相等了。

## 细节

输入中有两个斜杠，存的时候注意不要把斜杠存进去了！

## 代码


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
string s, a, b;
int main()
{
	cin >> s;
	for(int i = 0; i < 4; i++)
	{
		a += s[i]; 
	}
	//避开/ 
	for(int i = 5; i < 10; i++)
	{
		if(i == 7)//避开/ 
		{
			continue;
		}
		b += s[i];
	}
	sort(a.begin(), a.end());//对两个字符串排序 
	sort(b.begin(), b.end());
	if(a == b)//比较 
	{
		cout << "yes";
	}
	else
	{
		cout << "no";
	}
	return 0;
}
```

---

## 作者：Thorongil_Gondor (赞：0)

# 思路
此题其实就是求两个字符串是否可以通过排列而相等。

可以将两个字符串排序使其顺序相同。遍历其中一个字符串，若另一个字符串与此字符串某一位不同，不是好日子，输出 `no`。如果一直没有不同，说明两个字符串相同，是好日子，输出 `yes`。
# AC Code：
``` cpp
#include<bits/stdc++.h>
using namespace std;
char y[10];//年 
char md[10];//月日 
signed main(){
	cin>>y[0]>>y[1]>>y[2]>>y[3]>>y[4]>>md[0]>>md[1]>>md[4]>>md[2]>>md[3];
	sort(y,y+4);
	sort(md,md+4);//排列一致需排序 
	for(int i=0;i<4;i++){
		if(y[i]!=md[i]){//不相同 
			cout<<"no\n";//不是好日子 
			return 0;
		}
	}
	cout<<"yes\n";
	return 0;
}
```

---

## 作者：sugawara (赞：0)

### 前置知识

分支结构

### 题目大意
会给出年份 $y$ 月份 $m$ 日期 $d$，好像乍一看和判断回文一样，看到[讨论区的样例](https://www.luogu.com.cn/discuss/617553)理解一下就可以知道这其实是让你判断日期和月份的数字能不能构造成年份的数字。

#### 做法
1.老老实实构造

（略）

2.其实不用构造

我们可以直接放两个桶，这个桶就是一个数组，分两个，一个实日期和月份的桶，一个实年份的桶，这个数组分别称呼为 $t1$ 和 $t2$，这两个数组开 $10$ 就够了，因为数字最大只有十个一位数故数组大小则开 $10$，然后就可以判断一遍是否可以构造成年份了。

#### 代码

```cpp
#include<iostream>
using namespace std;
int t1[10],t2[10],top;
char c;
int main(){
	for(int i=1;i<=4;i++){
		scanf("%c",&c);
		t1[c-'0']++;
	}for(int i=1;i<=6;i++){
		scanf("%c",&c);
		if(c!='/') t2[c-'0']++;
	}for(int i=1;i<10;i++){
		if(t1[i]!=t2[i]){printf("no");return 0;}
	}printf("yes");
	return 0;
}
```

tips：虽然这样看起来就好了，但是一交还是会出问题，一看讨论区的翻译发现实需要加上一个换行，我们这样的判断不会出现大问题，但是这个换行也是无关紧要的，所以加上就能过了的。

---

## 作者：AnOIer (赞：0)

看到很多 dalao 都使用了桶的做法，我补充一个字符串 + 排序的。

## 题目分析

对于 $y,m,d$ 三个字符串，字符串 $md$ 为 $m$ 和 $d$ 的组合，如果可以将日和月的数字重排成年，则按照字母顺序排序后的 $y$ 和 $md$ 字符串一定相等。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	string year,month,day;
	int cnt=0;
	char ch;
	while(~scanf("%c",&ch)) {//先读入一个字符ch
		if(ch=='/') {
			++cnt;
			continue;
		}
		if(cnt==0) year+=ch;//将ch加入不同的字符串中
		if(cnt==1) month+=ch;
		if(cnt==2) day+=ch;
		if(year.size()+month.size()+day.size()==8) break;//如果读入完了结束循环
	}
	string month_day=month+day;//组合字符串
	sort(year.begin(),year.end());//排序
	sort(month_day.begin(),month_day.end());
	printf(year==month_day?"yes\n":"no\n");//判断
	return 0;//完结撒花
}
```

---

## 作者：Alvin0228 (赞：0)

### 题意描述

给出一个字符串，输出能否将日和月的数字重排成年的数字。

### 题目分析

本题问到数字的重排，可以设置一个数字桶，将年的数字加进去，日和月的数字减掉，如果这个桶的结果全为 $0$，那么就是好日子，反之就不是好日子。

需要注意的是，代码中间有 `/`，在读入的时候要注意一下。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int p[10];//数字桶 
int main ()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	string s;
	cin>>s;
	for (int i=0;i<4;i++)
	{
		int x=s[i]-'0';//字符转数字 
		p[x]++;//年的数字加进去 
	}
	for (int i=5;i<10;i++)
	{
		if (i==7) continue;//这是一个斜杠，continue掉 
		int x=s[i]-'0';
		p[x]--;//日和月的数字减掉
	}
	for (int i=0;i<10;i++)//判断是否全为0 
	{
		if (p[i]!=0)
		{
			cout<<"no"<<endl;
			return 0;
		}
	}
	cout<<"yes"<<endl;//记得换行 
	return 0;
}

```

---

## 作者：ICU152_lowa_IS8 (赞：0)

一道很简单的基础字符串题目。

有一个特性：使用 `cin` 读入的 `char` 类型仅会读取一个字符，这样子就可以过滤掉其中的斜杠了。

开两个字符数组，一个存前四位，一个存后四位，然后全部从小到大排序，逐位比对即可。

另外本题坑点：最后要加换行符。


```
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	char a[10],b[10];
	cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>b[1]>>b[2]>>b[5]>>b[3]>>b[4];
	sort(a+1,a+5);
	sort(b+1,b+5);
	for(int i=1;i<=4;i++){
		if(a[i]!=b[i]){
			cout<<"no\n";
			return 0;
		}
	}
	cout<<"yes\n";
	return 0;
}
```

---

## 作者：LRRabcd (赞：0)

这里提供两种解法。

# 一，桶

大家都知道如果两个字符串要想重新排列得到对方，两个字符串中每个字符所出现的数量都要严格一致，所以我们可以用两个桶分别统计“年”中每个字符出现的数量和“月日”中每个字符出现的数量，再一一比对，这样就会得到如下代码。

```cpp
#include<iostream>
using namespace std;
int vis1[105],vis2[105];
int main(){
    string s;
    cin>>s;
    s=" "+s;
    for(int i=1;i<=4;i++){
        vis1[s[i]]++;
    }
    for(int i=6;i<=7;i++){
        vis2[s[i]]++;
    }
    for(int i=9;i<=10;i++){
    	vis2[s[i]]++;
	} 
	int cnt=0;
    for(int i=1;i<=4;i++){
        if(vis1[s[i]]==vis2[s[i]]){
        	cnt++;
        }
    }
    if(cnt==4){
    	cout<<"yes";
	}else{
		cout<<"no";
	}
    cout<<"\n"; //AtCoder的题最后一定得加一个换行
    return 0;
}
```

# 二，排序

两个字符串按照字典序排好序，如果排好序后两个字符串一致则代表这两个字符串可通过重新排列变为一致，否则就不可以。

## 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	string s;
	cin>>s;
	s=" "+s;
	string a=s.substr(1,4);
	string b=s.substr(6,2);
	string c=s.substr(9,2);
	b+=c;
	sort(a.begin(),a.end());
	sort(b.begin(),b.end());
	if(a==b){
		cout<<"yes";
	} else{
		cout<<"no";
	}
	cout<<"\n";
    return 0;
}
```

---


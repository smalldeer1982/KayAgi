# 立方数

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-formula-2014-quala/tasks/code_formula_2014_qualA_a

整数 $ A $ が与えられます。

整数 $ A $ が立方数なら`YES`、そうでないなら`NO`と出力しなさい。

ただし、立方数とは、整数を三乗して作ることが出来る数のことを指します。

## 说明/提示

### Sample Explanation 1

$ 8 $ は立方数なので、`YES`と出力します。

### Sample Explanation 2

$ 24 $ は立方数ではないので、`NO`と出力します。

## 样例 #1

### 输入

```
8```

### 输出

```
YES```

## 样例 #2

### 输入

```
24```

### 输出

```
NO```

# 题解

## 作者：hongzy (赞：11)

## 牛顿迭代法

（$Warning:$ 此题解非常不友好）

牛顿迭代法（$Newton's\; method$）一般用于求函数的一个零点。

牛顿迭代法三个步骤：

1. 随机 / 猜一个$p$值
2. 求$x=p$时的切线，即求导数
3. 令$p=$切线零点，返回步骤$2$，重复若干次.

即：$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$

重复得越多得到的根越精确，一般达到精度要求就可以停止.

那么牛顿迭代法怎么求$a$的立方根呢？

方法：设$x=\sqrt[3]{a}$，则$a=x^3$，转换成求$f(x)=x^3-a$的零点

首先求导。$f'(x)=3x^2$.这样就可以牛顿迭代了.

```cpp
#include <cstdio> 

#define fabs(x) ((x) > 0 ? (x) : -(x)) //绝对值 

#define f(x) (x * x * x - a)  //原函数 
#define f1(x) (3 * x * x)     //导数 

int Cube_root(int a) {
	double x = 2.33, nx;     //首先随便取一个x 
	const double eps = 1e-3; //精度要求 
	while(true) {
		nx = x - f(x) / f1(x);
		if(fabs(nx - x) < eps) break; //达到精度要求 
		x = nx;
	}
	return (int) x;
}

int main() {
	int x, y; scanf("%d", &x); y = Cube_root(x);
	puts(y * y * y == x ? "YES" : "NO"); //开根取整再立方得到原数说明是立方数 
	return 0;
}
```

---

## 作者：C20210404杜铖昊 (赞：7)

简单易懂题解（勿喷）：

简单方法————暴力枚举；

从1一直枚举到n，是否符合题意

代码如下：
```
#include<cstdio>
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		if(i*i*i==n){
			printf("YES");//满足输出YES
			return 0;
		}
	}
	printf("NO");//否则输出NO
	return 0;
}
```

---

## 作者：3water (赞：4)

# 打表大法


题目链接

[AT989[立方数]](https://www.luogu.org/problemnew/show/AT989)

一个立方数，可以看成一个数的平方乘上这个数。

于是就产生了以下代码——


------------


```cpp
井include<bits/stdc++.h>
using namespace std;
int f[217]={0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,576,625,676,729,784,841,900,961,1024,1089,1156,1225,1296,1369,1444,1521,1600,1681,1764,1849,1936,2025,2116,2209,2304,2401,2500,2601,2704,2809,2916,3025,3136,3249,3364,3481,3600,3721,3844,3969,4096,4225,4356,4489,4624,4761,4900,5041,5184,5329,5476,5625,5776,5929,6084,6241,6400,6561,6724,6889,7056,7225,7396,7569,7744,7921,8100,8281,8464,8649,8836,9025,9216,9409,9604,9801,10000,10201,10404,10609,10816,11025,11236,11449,11664,11881,12100,12321,12544,12769,12996,13225,13456,13689,13924,14161,14400,14641,14884,15129,15376,15625,15876,16129,16384,16641,16900,17161,17424,17689,17956,18225,18496,18769,19044,19321,19600,19881,20164,20449,20736,21025,21316,21609,21904,22201,22500,22801,23104,23409,23716,24025,24336,24649,24964,25281,25600,25921,26244,26569,26896,27225,27556,27889,28224,28561,28900,29241,29584,29929,30276,30625,30976,31329,31684,32041,32400,32761,33124,33489,33856,34225,34596,34969,35344,35721,36100,36481,36864,37249,37636,38025,38416,38809,39204,39601,40000,40401,40804,41209,41616,42025,42436,42849,43264,43681,44100,44521,44944,45369,45796,46225,46656},n,i;//上列是0~216的平方，而216的立方大于10^7，保险起见加上。
int main(){
    cin>>n;
    for(i=1;f[i]*i<=n;i++){//i即为sqrt(f[i])
        if(n%f[i])continue;//不整除跳过
        if(f[i]*i==n){//满足条件
            cout<<"YES"<<endl;
            return 0;//跳过以下
        }
    }
    if(f[i]*i>n)cout<<"NO"<<endl;//不成立
}
```
------------
```cpp
//更直接
#include<bits/stdc++.h>
using namespace std;
int f[217]={0,1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,9261,10648,12167,13824,15625,17576,19683,21952,24389,27000,29791,32768,35937,39304,42875,46656,50653,54872,59319,64000,68921,74088,79507,85184,91125,97336,103823,110592,117649,125000,132651,140608,148877,157464,166375,175616,185193,195112,205379,216000,226981,238328,250047,262144,274625,287496,300763,314432,328509,343000,357911,373248,389017,405224,421875,438976,456533,474552,493039,512000,531441,551368,571787,592704,614125,636056,658503,681472,704969,729000,753571,778688,804357,830584,857375,884736,912673,941192,970299,1000000,1030301,1061208,1092727,1124864,1157625,1191016,1225043,1259712,1295029,1331000,1367631,1404928,1442897,1481544,1520875,1560896,1601613,1643032,1685159,1728000,1771561,1815848,1860867,1906624,1953125,2000376,2048383,2097152,2146689,2197000,2248091,2299968,2352637,2406104,2460375,2515456,2571353,2628072,2685619,2744000,2803221,2863288,2924207,2985984,3048625,3112136,3176523,3241792,3307949,3375000,3442951,3511808,3581577,3652264,3723875,3796416,3869893,3944312,4019679,4096000,4173281,4251528,4330747,4410944,4492125,4574296,4657463,4741632,4826809,4913000,5000211,5088448,5177717,5268024,5359375,5451776,5545233,5639752,5735339,5832000,5929741,6028568,6128487,6229504,6331625,6434856,6539203,6644672,6751269,6859000,6967871,7077888,7189057,7301384,7414875,7529536,7645373,7762392,7880599,8000000,8120601,8242408,8365427,8489664,8615125,8741816,8869743,8998912,9129329,9261000,9393931,9528128,9663597,9800344,9938375},n,i;
int main(){
    cin>>n;
    for(i=1;f[i]<=n;i++){
        if(f[i]==n){
            cout<<"YES"<<endl;
            return 0;
        }
    }
    cout<<"NO"<<endl;
}
```


---

## 作者：PC_DOS (赞：3)

C++并没有直接提供开立方根的函数，但是我们可以借助math库中的pow()函数实现开立方。

大家都知道，一个数X的立方根可以表述为这个数的1/3次方，而在pow()函数中，底数和指数是可以在有效域内任意指定的，为了对底数X开立方，我们可以调用pow(X,1.0/3.0)实现。

但是请注意，pow存在精度的问题，计算出的值可能稍高于或稍小于实际值，因此不能直接使用int()取整(比如:int(pow(1000000,1.0/3.0))返回的值为99，而不是真值100)，为了解决这个问题，我们可以采用round()函数四舍五入取整。

代码:
```
#include <iostream>
#include <cmath>
using namespace std; //头文件和命名空间
int main(){
	ios::sync_with_stdio(false); //输入输出加速
	int iNum,iRoot; //分别为原始数和取整的立方根
	cin >> iNum; //读入原数
	iRoot = round(pow(iNum, 1.0 / 3.0)); //开立方，四舍五入取整
	if (iRoot*iRoot*iRoot == iNum) //判断是不是真实值
		cout << "YES\n"; //真
	else //否则
		cout << "NO\n"; //假
	return 0; //结束
}
```

---

## 作者：Luisvacson (赞：2)

开门见山——

**打表+二分** //ORZ打表大法好

我第一眼看到这道题是脑中就出现了一个奇妙的想法~
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	for(int i=1;i<=100;i++) printf("%d,",i*i*i);
    //题目说最大1000000，所以打到100的立方就够了
	return 0;
} 
//辅助打表
```
于是我们就有了数据，并写出以下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100]={1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,9261,10648,12167,13824,15625,17576,19683,21952,24389,27000,29791,32768,35937,39304,42875,46656,50653,54872,59319,64000,68921,74088,79507,85184,91125,97336,103823,110592,117649,125000,132651,140608,148877,157464,166375,175616,185193,195112,205379,216000,226981,238328,250047,262144,274625,287496,300763,314432,328509,343000,357911,373248,389017,405224,421875,438976,456533,474552,493039,512000,531441,551368,571787,592704,614125,636056,658503,681472,704969,729000,753571,778688,804357,830584,857375,884736,912673,941192,970299,1000000};
int main(){
	int n;
	cin>>n;
	if(binary_search(a,a+100,n)) printf("YES");
    //二分快一些
	else printf("NO");
	return 0;
} 
```


------------
**正解开始——**

咳咳，本题的数据范围不大，有点水，所以很多暴力都能过

~~（貌似暴力本来就能过）~~

这里其实不用二分，但我想借此题解为~~刚入门的~~同学们科普一下OI里的神器——二分答案

先讲思想：

如果你有一个数组，想查找一下某个数在不在其中，你会怎么办？

最直接的手法就是一个个枚举看相等不相等：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={0,1,2,3,4,5,6,7,8,9};
  //为方便讲题就直接给数据
int main(){
	int x;
	cin>>x;
	for(int i=0;i<10;i++){ //暴力枚举
		if(a[i]==x){
			printf("YES");
			return 0;
		}
	}
	printf("NO");
	return 0;
}
```
在这里看不出来有什么不妥，但是我们想想：如果数组元素个数很大呢？这时候一个个暴力枚举就很耗时间，不够效率，于是有了二分：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={0,1,2,3,4,5,6,7,8,9};
  //数据不变
int main(){
	int x;
	cin>>x;
	int L=0,r=9,mid;
  //左右指针，左为下限，右为上限，mid表示中间值
	sort(a,a+10);
  //注意，二分数列必须有序
	while(L<=r){ //只要左右不交错
		mid=L+r>>1; //可以把它理解为mid=(L+r)/2;
		if(a[mid]==x){
			printf("YES");
			return 0;
		}
		if(a[mid]<x) L=mid+1;
		if(a[mid]>x) r=mid-1; 
        //调整上限和下限，慢慢逼近答案
        //每次舍弃一半答案
	}
	printf("NO");
	return 0;
}
```
若数组有n个元素，那么暴力的复杂度是O(n)，而二分的复杂度是O(logn)，在数据较大的情况下差异就很明显

所以二分很有用

那么二分答案是什么呢？其实就是用二分查找做应用题，把所有可能的解想象在一个数组里，通过二分去“试”答案，知道找到正确的解

所以有了以下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	int L=0,r=n,mid;
  //开始二分
	while(L<=r){
		mid=L+r>>1;
		int x=mid*mid*mid;
		if(x==n){ //找到
			printf("YES");
			return 0;
		}
		if(x>n) r=mid-1;
		if(x<n) L=mid+1; 
     //调整上限和下限
	}
	printf("NO");
	return 0; 
}
```
~~应该能过吧（没试过）~~

~~蒟蒻题解求过~~

---

## 作者：climax (赞：2)

由于本萌新是第次发题解，所以请各位大佬多多关照。

由于题目说了n是<=1000000的，所以我们就只需从1到100来判断是否有一个整数的立方等于n啦！

附上AC代码：
```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
  long long n;
  scanf("%ld",&n);//输入
  for(register int i=1;i<=100;i++)//进行判断
    if(pow(i,3)==n)//如果i的立方等于n的话就输出YES,然后结束。
	{
		cout<<"YES"<<endl;
		return 0;
		}	        
  cout<<"NO"<<endl;//否则，就输出NO。
  return 0;//记得输出的时候要换行喔！
}//圆满结束
```

---

## 作者：_Andy_Lin_ (赞：1)

[博客传送门](https://www.luogu.com.cn/blog/linguosheng/)

------------
我的方法或许是独一无二的。我的方法就是——二分！

------------
我们可以将上界设为1，将下界设为sqrt(n)。至于二分的过程，大佬们想必都知道了吧。

------------
AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,r;
int main(){
    scanf("%d",&n);
    l=1;
    r=sqrt(n);
    while(l<=r){
        int mid=(l+r)/2;
        if(mid*mid*mid==n){
            puts("YES");
            exit(0);
        }
        else if(mid*mid*mid>n)r=mid-1;
        else l=mid+1;
    }
    puts("NO");
	return 0;
}
```

---

## 作者：WBBB、 (赞：1)

**蒟蒻**第一次发题解，~~按耐不住全场最快的小激动(目前为止）~~

还是跑不过各位神犇们的~~毒瘤~~代码

思路就是自己再写一个程序打出一个表，存1~100的立方分别是多少

打表代码如下

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
	cout<<"1";
	for(int i=2;i<=100;i++)
	{
		cout<<","<<pow(i,3);
	}//注意要将打出来的最后一个数1e+006手改成1000000
}
```


然后上AC代码
```cpp
#include<cstdio>
int a[101]={0,1,8,27,64,125,216,343,512,729,1000,
1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,
9261,10648,12167,13824,15625,17576,19683,21952,
24389,27000,29791,32768,35937,39304,42875,46656,
50653,54872,59319,64000,68921,74088,79507,85184,
91125,97336,103823,110592,117649,125000,132651,
140608,148877,157464,166375,175616,185193,195112,
205379,216000,226981,238328,250047,262144,274625,
287496,300763,314432,328509,343000,357911,373248,
389017,405224,421875,438976,456533,474552,493039,
512000,531441,551368,571787,592704,614125,636056,
658503,681472,704969,729000,753571,778688,804357,
830584,857375,884736,912673,941192,970299,1000000};//打表
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=100;i++)//register玄学加速
	{                               //暴力枚举
		if(n==a[i])
		{
			printf("YES");//注意是全大写
			return 0;
		}
	}
	printf("NO");
}
```

---

## 作者：ygl666666 (赞：0)

# 这题的提交交半天都还是judging
# 题意&&思路
这题就是要求一个数是不是一个立方数，
所以只要用一个循环**一个一个判断**即可。
**重点注意，不要忘了1.**
# 下面是代码
```
/**/
#include<bits/stdc++.h>
using namespace std;
int n; 
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){//一点要等于
		if(i*i*i==n){
			cout<<"YES";
			return 0;
		}
	}
	cout<<"NO";
	return 0;
}

```
谢谢！
（end）；


---

## 作者：lsyx0918 (赞：0)

我们先来讲一下这道题用C++的做法。用一个for循环来判断就可以了。

话不多说，上代码喽：
```cpp
#include<iostream>
#include<cmath>
//在这里可以用万能头哟
using namespace std;
int main()//主函数
{
	int n;//定义变量
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		if(i*i*i==n)
		{
			cout<<"YES"<<endl;
			return 0;	
		}
	}
        //for循环判断是否为立方数
	cout<<"NO"<<endl;
	return 0;
}
```
现在我们来讲一下Python2.7的做法。其实跟C++的差不多，但是要特判一下1。

开上代码：
```python
n=int(raw_input())#输入
flag=False#定义判断立方数的bool类型变量

#特判
if n==1:
    print "YES"
    flag=True

#for循环判断是否为立方数
for i in range(1,n,1):
    if i**3==n:
        print "YES"
        flag=True
if flag==False:
    print "NO"

```
最后，提醒一下（只限于C++群众）：

**AT不换行，暴零两行泪**

---

## 作者：紫金依旧 (赞：0)

大大大大 大水题.~~(AT是不会出题吗?)~~

很简单的一种常规解法——暴力枚举

Why? 因为题目说明——

1 ≦ A ≦ 10^5

再定睛一看，这数据还真小

直接暴力水过.

上代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,i=0;
	cin>>n;
	for(int i=1;i<=n;i++) 
		if(n==pow(i,3))
		{
			cout<<"YES\n";
			return 0;
		}
	cout<<"NO\n";//注意NO和YES都为大写,换行
	return 0;
}
```

打造文明洛谷,拒绝Ctrl+C,Ctrl+V.

---

## 作者：bym666 (赞：0)

# AT989 【立方数】
先问一下，应该没人不知道立方数是什么东西吧？如果不知道，点击这个链接看一下→[立方数](https://baike.sogou.com/v7815471.htm?fromTitle=%E7%AB%8B%E6%96%B9%E6%95%B0)

这道题是计算是否有一个数的立方是n。由于这次数据比较仁慈，所以我就直接枚举，因为n最大是1000000，所以我们只需要从1枚举到100就可以了。

代码如下：
```
#include <bits/stdc++.h>//万能头文件 
using namespace std;
int n;
int main()
{
	cin>>n;//输入 
	for(int i=1;i<=100;i++)//枚举 
	{
		if(i*i*i==n)//如果i的立方是n 
		{
			cout<<"YES"<<endl;//输出“YES” 
			return 0;//结束程序 
		}
	}
	cout<<"NO"<<endl;//剩下的都不符合要求，输出“NO”
	return 0;//结束程序 
} 
```



---

## 作者：有限光阴 (赞：0)

# ~~对于数据这么水的一道题~~
我决定...
## 暴力!!!
暴力出奇迹!!!

废话少说,上代码;
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;++i){
        if(i*i*i==n){//强行暴力;
            cout<<"YES"<<endl;//AT的题目记得换行;
            return 0;//找到就返回;
        }
    }
    cout<<"NO"<<endl;//AT的题目记得换行;
    return 0;
}
```
~~dalao勿喷~~

~~不喜勿喷~~

------------
这里告诉一些不怎么做AT题的朋友

AT题都需要--**换行**

---

## 作者：zzhz (赞：0)

这题不难,直接上代码    
代码如下：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n;
bool f=false;
int main(){//主函数
	cin>>n;
	for(int i=1;i<=sqrt(n);i++){
		if(i*i*i==n)f=true;//判断是否为立方数
	}
	if(f==true)cout<<"YES";//是，输出YES
	else cout<<"NO";//不是，输出NO
	cout<<endl;
	return 0;
}
``` 
最后提醒一点：  
AT的题一定要换行！    
本蒟蒻心地善良   
但是，   
非紧急情况不要用此功能！  


---

## 作者：stry (赞：0)

这道题可以用打表大法去做，我们可以分段检测，可分成10内，100内，1000内，10000这道题可以用打表大法去做，我们可以分段检测，可分成10内，100内，1000内，10000内，100000内，1000000内，10000000内七种情况。
# 岛国题须换行！！！
程序如下：

```cpp
#include<iostream>
#include<fstream>
#include<string>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;
long long a;
int main()
{
    cin>>a;
    if(a/10<1)
	{
	if(a==1||a==8){cout<<"YES\n";return 0;} 	
	else{cout<<"NO\n";return 0;}
	}
	if(a/100<1)
	{
	if(a==27||a==64){cout<<"YES\n";return 0;} 	
	else{cout<<"NO\n";return 0;}
	}
	if(a/1000<1)
	{
	if(a==125||a==216|a==343||a==512||a==729){cout<<"YES\n";return 0;} 	
	else{cout<<"NO\n";return 0;}
	}
	if(a/10000<1)
	{
	if(a==1000||a==1331|a==1728||a==2197||a==2744||a==3375||a==4096||a==4913||a==5832||a==6859||a==8000||a==9261){cout<<"YES\n";return 0;} 	
	else{cout<<"NO\n";return 0;}
    }	
	if(a/100000<1)
	{
	if(a==10648||a==12167|a==13824||a==15625||a==17576||a==19683||a==21952||a==24389||a==27000||a==29791||a==32768||a==35937||a==39304||a==42875||a==46656||a==50653||a==54872||a==59319||a==64000||a==68921||a==74088||a==79507||a==85184||a==91125||a==97336){cout<<"YES\n";return 0;} 	
	else{cout<<"NO\n";return 0;}
    }
	if(a/1000000<1)
	{
	if(a==103823||a==110592|a==117649||a==125000||a==132651||a==140608||a==148877||a==157464||a==166375||a==175616||a==185193||a==195112||a==205379||a==216000||a==226981||a==238328||a==250047||a==262144||a==274625||a==287496||a==300763||a==314432||a==328509||a==343000||a==357911||a==373248||a==389017||a==405224||a==421875||a==438976||a==456533||a==474552||a==493039||a==512000||a==531441||a==551368||a==571787||a==571787||a==592704||a==614125||a==636056||a==658503||a==681472||a==704969||a==729000||a==753571||a==778688||a==804357||a==830584||a==857375||a==884736||a==912673||a==941192||a==970299){cout<<"YES\n";return 0;} 	
	else{cout<<"NO\n";return 0;}
    }
	if(a==1000000){cout<<"YES\n";return 0;}
    return 0;
}



```


---

## 作者：百里亦守约 (赞：0)

# ~~水（xie）一下AT的题解就是好！~~

## 话不多说，切入正题：

##### 大致翻了一下这一道题的题解，好像没有看到用while循环做的，所以本大（ju）佬（ruo）就写一个用while循环的题解......
### 思路在代码里：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s;
int main()
{
	cin>>n;//输入
	while(s*s*s<n) //判断s的立方是不是小于输入的数n（如果大于或等于就可以跳出循环）
		s++;
	if(s*s*s==n) cout<<"YES"; //再次判断该数是不是等于n。
	else cout<<"NO";
	cout<<endl; //因为AT的题要换行，所以我就懒得在输入打了，就直接在后面打（其实就省略了1个。。）
	return 0;
}
```



---

## 作者：pbdean (赞：0)

其实我和下面这位想法差不多，

但我想**优化**，

所以我是这个想法：

如果一个数能找得到整数立方根，那么它的立方根一定大于等于它的平方根。

还有，要从0开始。

```cpp
#include<iostream>
using namespace std;
#include<cmath>
int main(){
    int n;
    cin>>n;
    for(int i=0;i<=sqrt(n);i++){
        if(pow(i,3)==n){
            cout<<"YES";//满足输出YES
            return 0;
        }
    }
    cout<<"NO";
    return 0;
}
```


---

## 作者：封禁用户 (赞：0)

这道题实际上非常的水...解释在代码中...
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,i;
	cin>>n;//输入n,看了一眼数据范围，惊喜的发现pow(100,3)正好是1000000
	for(i=1;i<=100;i++)
	{
		if(pow(i,3)==n)//判断
		{
			cout<<"YES"<<endl;//输出
			return 0;//结束程序
		}
	}
	cout<<"NO"<<endl;    //如果能运行到这一步，那么说明没有满足题意的i则输出NO
	return 0;
}//友情提醒AT的题都要输出换行[微笑]

```

---

## 作者：LJC00111 (赞：0)

很简单，枚举即可
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,x;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	if(i * i * i == (n))
    	{
    	cout<<"YES"<<endl;	
    	return 0;
		}
    	if(i==n)
    	cout<<"NO"<<endl;
	}
    return 0;
} 
```

---

## 作者：King_Parliament (赞：0)

## 数学方法

看到题解中大部分都是一个一个去试，这样太麻烦了复杂度也很高，不如利用数学方法，简单明了。

**一个数的n次方根也就是这个数的n分之一次方**

表达式为：$ a^{\frac{1}{n}}=\sqrt[n]{a} $

利用这个性质我们可以直接开三次根号，

也就是$ a^{\frac{1}{3}}=\sqrt[3]{a} $

于是，我们只需要定义double常量=$\frac{1}{3}$，然后用pow运算，再向上取整看是否为本身即可。

代码如下：

```cpp

#include<bits/stdc++.h>
using namespace std;
int main(){
	const long double p=1.0/3.0;//保证精度
	int n;//待检测的数
	cin>>n;
	if(ceil(pow(n,p))==pow(n,p))cout<<"YES"<<endl;//判断其立方根向下取整是否为其立方根本身，是就输出YES
	else cout<<"NO"<<endl;//否则输出NO
    return 0;
}

```

---

## 作者：封禁用户 (赞：0)

下面的dalao们都是用for一边过的。其实这一题还可以用分解质因数来做。

证明：一个完全立方数的任何一个因数的次数都是3的倍数

设这个数的立方根为k，k=2^a*3^b……则这个数字可以表示为2^3a*3^3b……

∴这个数字的任何一个因数的指数为3的倍数。

所以我们就可以枚举因数。如果我们找到一个因数，n%这个数字的立方==0的话就除他，同时i--再测验。直到n%这个数的立方不为0。这一步除的数字一定是个质数。

证明：

若这个数是一个和数，那么它必定有一个质因数比他小，之前一定被除掉了，矛盾。所以不存在

当我们在这一过程发现了它除以一个质数（合数在之前已经被排除掉了）==0但是n%他的立方!=0就说明存在一个因数他的指数不为3的倍数，输出"NO"

结束循环后输出"YES"

上代码
```
#include <bits/stdc++.h>
using namespace std;
long long n,k;
int main()
{
	scanf("%lld",&n);
	
	for(int i=2;i<=n;i++)
	{
		if(n%i==0)/*是他的因数*/ 
		{
			k=i*i*i;/*求出他的立方*/
			if(n%k==0)/*是立方的倍数*/ 
			{
				n/=k;
				i--;
			}
			else/*不是输出NO*/ 
			{
				printf("NO");
				return 0;
			}
		}
	}
	printf("YES");/*完成后输出YES*/ 
	return  0;
}
```


---

## 作者：stjzcstdio (赞：0)

```cpp

#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
    cout<<"1";
    for(int i=2;i<=100;i++)
    {
        cout<<","<<pow(i,3);
    }//注意要将打出来的最后一个数1e+006手改成1000000
}
```

---
```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std; 
#define ull unsigned long long
int main()
{
    ios::sync_with_stdio(false); //取消同步 
    register ull n;
    cin>>n; 
  if(n==1||n==8||n==27||n==64||n==125||n==216||n==343||n==512||n==729||n==1000||n==1331||n==1728||n==2197||n==2744||n==3375||n==4096||n==4913||n==5823||n==6859||n==8000||n==9261||n==10648||n==12167||n==13824||n==15625||n==17576||n==19683||n==21952||n==24389||n==27000||n==29791||n==32768||n==35937||n==39304||n==42875||n==46656||n==50653||n==54872||n==59319||n==64000||n==68921||n==74088||n==79507||n==85184||n==91125||n==97336||n==103823||n==110592||n==117649||n==1255000||n==132651||n==140608||n==148877||n==157464||n==166375||n==175616||n==185193||n==195112||n==205379||n==216000||n==226981||n==238328||n==250047||n==262144||n==274625||n==287496||n==300763||n==314432||n==328509||n==343000||n==357911||n==373248||n==389017||n==405224||n==421875||n==438976||n==456533||n==474552||n==493039||n==512000||n==531441||n==551368||n==571787||n==592704||n==614125||n==636056||n==658503||n==681472||n==704969||n==729000||n==753571||n==778688||n==804357||n==830584||n==857375||n==912673||n==941192||n==970299||n==1000000)
    cout<"YES"<<endl;
    else cout<<"NO"<<endl;
    return 0; //完美结束，祝大家编程开心！
}
```


---


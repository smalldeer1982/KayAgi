# [ABC283C] Cash Register

## 题目描述

高桥君正在做收银员的工作。

收银机上有 $11$ 个按钮，分别是 `00`、`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`。收银机初始显示为 $0$。按下 `00` 按钮时，显示的数字会变为当前数字的 $100$ 倍。按下其他按钮时，显示的数字会先变为当前数字的 $10$ 倍，然后加上按钮上写的数字。

高桥君想让收银机显示整数 $S$。请你求出，至少需要按多少次按钮，才能让收银机显示为 $S$。

## 说明/提示

## 限制条件

- $1 \leq S \leq 10^{100000}$
- $S$ 是一个整数。

## 样例解释 1

例如，可以通过如下操作，用 $4$ 次按键将收银机显示为 $40004$。初始时，收银机显示为 $0$。
- 按下 `4` 按钮，收银机显示为 $4$。
- 按下 `00` 按钮，收银机显示为 $400$。
- 按下 `0` 按钮，收银机显示为 $4000$。
- 按下 `4` 按钮，收银机显示为 $40004$。

无法在 $3$ 次或更少的按键次数内让收银机显示为 $40004$，所以输出应为 $4$。

## 样例解释 3

请注意，$S$ 可能无法用 $64$ 位整数存储。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
40004```

### 输出

```
4```

## 样例 #2

### 输入

```
1355506027```

### 输出

```
10```

## 样例 #3

### 输入

```
10888869450418352160768000001```

### 输出

```
27```

# 题解

## 作者：VegeBeany (赞：2)

## 思路
思路明显的贪心题。

首先我们知道如果没有 `00` 这个按键，那么按按键的次数就是字符串长度。

那这个按键它的作用就是在输入连续两个 $0$ 的时候少按一个键。

所以我们可以遍历这个字符串找到两个连续的 $0$ 时记录一下，那么最后用总长减去记录次数就行了。

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int cnt; 
signed main(){
    cin>>s;
    for(int i=0;i+1<s.size();i++){
    	if(s[i]=='0'&&s[i+1]=='0')cnt++,i++;//记得要i++避免重复记录
	}
	cout<<s.size()-cnt;
    return 0;
}

```

---

## 作者：RyanLi (赞：1)

传送门：洛谷 [[ABC283C] Cash Register](https://www.luogu.com.cn/problem/AT_abc283_c) | AtCoder [C - Cash Register](https://atcoder.jp/contests/abc283/tasks/abc283_c)

难得有一次能做出来ABC的C题，来分享一下解法。

## 分析题意

### 数据规模

养成好习惯，上来先看数据规模：$1\leq S\leq10^{100000}$。并且注意到「样例解释3」中提到的：*$S$ 可能无法容纳在 $64$ 位整数中。*

很快啊，这题显然应该用 **高精度**。

### 高精度

我们可以使用一个 `int` 数组，存储每一位的数字，当这一位不小于 $10$ 时就向下一位进 $1$。注意，为了方便处理进位，高精度数组应该 **倒着存储**。

```cpp
inline void add() {
    ++ans[1];
    for (int i = 1; i <= len; ++i)
        if (ans[i] >= 10) {
            ++ans[i + 1];
            ans[i] -= 10;
        }
    while (ans[len + 1]) ++len;
    return;
}
```

### 处理数据

分析题意，我们不难发现，当两位数字均为 $0$ 时，我们可以按下 `00` 键来减少按键的次数，这是本题在理解上唯一的难点。

当我们按下 `00` 键的时候，我们一次输入了两个数字。因此，与按下其他键不同的是，如果连续的两个 $0$ 同时出现，我们需要在对答案加 $1$ 的同时，让指针一次前进 $2$。

## 代码实现

```cpp
#include <iostream>
using namespace std;

string s;
int ans[100010], len = 1;

// 高精度加法函数
inline void add() {
    ++ans[1];
    for (int i = 1; i <= len; ++i)
        if (ans[i] >= 10) {
            ++ans[i + 1];
            ans[i] -= 10;
        }
    while (ans[len + 1]) ++len;
    return;
}

int main() {
    // 输入输出加速大法
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    cin >> s;
    for (int i = 0; i < s.length(); ++i) {
        // 如果有连续的两个 0，则使指针多加 1
        if (s[i] == '0' && s[i + 1] == '0') ++i;
        add();
    } // 因为是倒着存储，所以需要倒着输出
    for (int i = len; i >= 1; --i)
        cout << ans[i];
    return 0;
}
```



---

## 作者：VitrelosTia (赞：0)

题链：[AT](https://atcoder.jp/contests/abc283/tasks/abc283_c)/[Luogu](https://www.luogu.com.cn/problem/AT_abc283_c)

### 题意
给你一个由数字组成的字符串，每次可以从后往前删去一个数字，假如末两位是 $00$ 可以一次删两个。问最少需要几次删完？

### 思路
正常删一位数字的效率是一样的，显然不如删两位。考虑贪心策略，要尽可能地删 $00$。

实现方式就是判断当前字符和上一个字符是否都为 $0$，是的话删两位，否则删一位。

删两位操作的实现方法也很简单，把当前字符标为非 $0$ 之后 `continue` 即可。标为非 $0$ 是防止下一位还是 $0$。

### code
```
#include<bits/stdc++.h>
using namespace std;
int cnt;
string s;
int main(){
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]=='0'&&s[i-1]=='0'){
			s[i]='F';
			continue;
		}
		cnt++;
	}
	cout<<cnt;
}
```


---

## 作者：_dijkstra_ (赞：0)

C 题，并不困难。

## 思路

容易发现，按下 $0 \sim 9$ 键的贡献是相同的，所以尽可能按 $00$ 键。

那么贪心的思路也很简单了：如果字符串有 $00$ 那就按 $00$，否则直接按 $0 \sim 9$。

## 代码

```cpp
int a[100005];
void solve()
{
	string s;
	cin >> s;
	int ans = 0;
	for (int i = 0, len = s.length(); i < len; i++)
	{
		if (i != len - 1 && s[i] == '0' && s[i + 1] == '0') ans++, i++; //能选00就选00
		else ans++; //选0~9
	}
	cout << ans << '\n';
}
```

---

## 作者：tbdsh (赞：0)

# 题意
[题目传送门](/problem/AT_abc283_c)

[更好的阅读体验](/blog/tianbiandeshenghuo11/solution-at-abc283-c)

输入一个数 $s(1\le s\le10^{100000})$，有以下按键：`00`,`0`,`1`,`2`,`3`,`4`,`5`,`6`,`7`,`8`,`9`。

每次按会在当前数字后添加按键上的数字。例如：

>原来的数是 $123$，当按下按键 `00` 后，数字会变为 $12300$，再按下按键 `9`，数字会变为 $123009$。

问最少按多少次能按出 $s$。

# 分析
因为数字非常大，所以本题直接用字符串读入即可。

不难发现，如果要使按按键次数最少，那么在出现连续的两个 $0$ 时直接按下 `00`，否则就单独按下某个数字。

那么，就可以扫描一遍字符串。每次扫描将答案 $+1$。同时判断 $s_i$ 与 $s_{i+1}$ 是否都为 $0$。如果成立，就跳过下一个字符的扫描。

时间复杂度：$O(|s|)$。

# Code
```cpp
#include<bits/stdc++.h>

using namespace std;
string s;
int ans;
int main(){
  cin >> s;
  int len = s.size();
  for (int i = 0; i < len; i++){
    ans++;//每次答案自加
    i += (s[i] == '0' && s[i + 1] == '0');//同上判断过程。
  }
  cout << ans << "\n";
  return 0;
}
```

---


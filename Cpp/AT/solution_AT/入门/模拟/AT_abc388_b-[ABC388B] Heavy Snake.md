# [ABC388B] Heavy Snake

## 题目描述

有 $N$ 条蛇。

一开始，第 $i$ 条蛇的粗细为 $T_i$，长度为 $L_i$。

蛇的重量等于粗细与长度的乘积。

对于每一个满足 $1 \leq k \leq D$ 的整数 $k$，请你求出当所有蛇的长度都增加 $k$ 时，最重的蛇的重量。

## 说明/提示

## 限制条件

- $1 \leq N, D \leq 100$
- $1 \leq T_i, L_i \leq 100$
- 输入的所有数值均为整数

## 样例解释 1

当所有蛇的长度都增加 $1$ 时，各自的重量分别为 $12, 10, 10, 11$，因此第 $1$ 行输出 $12$。  
当所有蛇的长度都增加 $2$ 时，各自的重量分别为 $15, 15, 12, 12$，因此第 $2$ 行输出 $15$。  
当所有蛇的长度都增加 $3$ 时，各自的重量分别为 $18, 20, 14, 13$，因此第 $3$ 行输出 $20$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 3
3 3
5 1
2 4
1 10```

### 输出

```
12
15
20```

## 样例 #2

### 输入

```
1 4
100 100```

### 输出

```
10100
10200
10300
10400```

# 题解

## 作者：FlowerAccepted (赞：3)

## 解题思路

数据不大，可以暴力。

枚举每一条蛇长度增加 $k$（$1 \le k \le D$）之后的蛇重（对于第 $i$ 条蛇，有 $W = T_i \times (L_i + k)$）并同时擂台法求最大值即可。

## 代码呈现

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring> // 不用万能头
using namespace std;

int t[105], l[105]; // 开大

int main() {
    int n, d;
    cin >> n >> d;
    for (int i = 1; i <= n; i ++) {
        cin >> t[i] >> l[i];
    }
    for (int k = 1; k <= d; k ++) {
        int maxw = -1; // 不会是负数
        for (int i = 1; i <= n; i ++) {
            maxw = max(maxw, t[i] * (l[i] + k)); // 擂台法
        }
        cout << maxw << '\n';
    }
    return 0;
}

```

## 复杂度分析

这个解法的时间复杂度是 $O(ND)$。

---


# 13月

## 题目背景

西暦 $2013$ 年 $12$ 月，うなぎ王国の王様は困っていた．年末までに片付けなければならない仕事が山ほど溜まっていたからである．このままでは年内に Unagi The synthesis Programming Contest（略称: UTPC）が開催できず部下たちに怒られてしまう．そこで，王様は新しい暦「うなぎ暦」を作って年末を先延ばしにしようと考えた．しかし，単に $1$ 年を $13$ ヶ月にするだけでは翌年の年末にまた苦労することは目に見えている．そこで，王様は毎年 $1$ ヶ月ずつ月を増やすことにした．


## 题目描述

[problemUrl](https://atcoder.jp/contests/utpc2013/tasks/utpc2013_02)

西暦の年月が与えられるので，対応するうなぎ暦での年月を答えよ．うなぎ暦の詳細は以下のとおりである．

うなぎ暦は西暦 $2013$ 年 $12$ 月から施行され，西暦 $2013$ 年 $12$ 月はうなぎ暦 $2013$ 年 $12$ 月に対応する．うなぎ暦では年によって月の数が異なり，うなぎ暦 $Y$ 年は $(Y−2000)$ ヶ月からなる．例えばうなぎ暦 $2013$ 年には $13$ 月まで存在し，うなぎ暦 $2014$ 年には $14$ 月まで存在する．西暦において月が変わると同時に，うなぎ暦でも月が変わるとする．つまり，うなぎ暦のある月の途中に西暦の月が変わったり，西暦のある月の途中にうなぎ暦が変わったりすることはない．以下の表に，西暦とうなぎ暦の対応の例を示す．

表 $1$: 西暦とうなぎ暦の対応例
| 西暦 |$2013$年$12$月|$2014$年$1$月|$2014$年$2$月|...|$2014$年$12$月|$2015$年$1$月|...|$2015$年$3$月|$2015$年$4$月|
| ---- | ---------- | --------- | --------- | ---- | ---- | ---- | ---- | ---- | ---- |
|うなぎ暦|$2013$年$12$月|$2013$年$13$月|$2014$年$1$月|...|$2014$年$11$月|$2014$年$12$月| ...  |$2014$年$14$月|$2015$年$1$月|


## 说明/提示

入力中の各変数は以下の制約を満たす．
- $2013 \leq Y \leq 10^{17}$
- $1\leq M\leq 12$
- 西暦 $2013$ 年 $12$ 月以降の年月が与えられる

この問題には部分点が設定されている．この問題のテストケースのうち $50$ 点分は，追加で以下の制約も満たす．
- $1 \leq Y \leq 10^5$


## 样例 #1

### 输入

```
2013 12
```

### 输出

```
2013 12
```

## 样例 #2

### 输入

```
2014 1
```

### 输出

```
2013 13
```

## 样例 #3

### 输入

```
12345 6
```

### 输出

```
2498 315
```

# 题解

## 作者：Blikewsr (赞：6)

[$\color{green}\text{AT837 原题链接}$](https://www.luogu.com.cn/problem/AT837)   
根据题意 :   
1. 们其实就是要把西历的日期转换成 unagi 的日期 ;  
2. 所以我们可以得知 ，每一年的最高月份都不同 ;  
3. 并且每一年的最高月份等于前一年的最高月份加 1 ;   
 ![](https://cdn.luogu.org/upload/pic/25929.png)   
数据范围 :  
$ 2013 ≤ Y ≤ 10^{17}  $  
$ 1 ≤ M ≤ 12   $
   
 AC 代码 ! ! !     
```c
#include<bits/stdc++.h>          
using namespace std;
long long year1;                 
long long month1;                
long long allmonth;              
long long year;                  
long long momth;                 
long long ansyear;               
long long ansmonth;              
int main(){
	
    year1=2013;                         
    month1=13;                          
    
    scanf("%lld%lld",&year,&momth);    
    
	allmonth=(year-2014)*12+momth;      
	/*
	先用比2013 + 1年多出的部分去乘以12个月
    等我们最后再加上2013年的12个月 
	然后在加上输入的西历月份
	*/
	ansmonth=allmonth;      
	
    while(ansmonth>=month1)    //用 while 来算西历转换成的 unagi 的年份 。
	{   
		year1++;     
		ansmonth-=month1;    
		month1++;  
	}
	ansyear=year1;       
	
	ansmonth+=12;       //之前说过 ，要加回2013年的12个月 
	
	month1++;  
				//它可能会大于或等于下一年(因为如果超过最大月份 ，年份会加 1) 的最大月份
	if(ansmonth>=month1)   
	{
		ansmonth-=month1;   //超过以后 ，月份减去最高月份 
		ansyear++;         
	}
	
	printf("%lld %lld\n",ansyear,ansmonth);    
	
    return 0;     //完美结束 
}
```
  
以上为全部 AC 代码 。  
此代码仅供参考 ，谢谢 。

---

## 作者：欢黎明陌 (赞：5)

这道题目前没有标签，不过如果让我给它一个标签的话，第一个就是“模拟”。

然鹅，毕竟是一道绿题，虽说个人认为它比 $CSP2020$ 的儒略日要简单不少，但是想要得到一个大大的 $AC$ 单凭借暴力模拟是不行的。

何为暴力模拟，即为没有优化，题目让干什么就去做什么。因而很容易想到一个月一个月地往上垒（你要想说往下拆也行，反正结果是一样的）；

可是这时数据范围给我们竖起来一块写着红色叉叉的牌子，好心提醒着我们 $Y$ 最大可达 $1e17$ 这一要点。如果我们视若无睹，就只能保证在 $Y$ 小于 $1e5$ 的条件下不超时，进而得到 $50%$ 的分数（想当年CSP2020开始之前我但凡知道这，就不至于这般凄惨，可见此优化如此重要）。

------------

这道题的第二个要点，初始化。

虽说初始化相对简单，但是它十分重要不容忽视，如果没有了它，再唯美的处理过程都只能换来一排排大大的 $Wa$ ，有可能还带有几个 $RE$ ，不过是决计不会出现一个测试点是 $AC$ 的。

题目告诉我们，只会给出西历 $2013$ 年 $12$ 月以及之后的时间作为测试点，所以就有了这样一句话

```cpp
unsigned long long int Y , M , year = 2013 , month = 13 , temp = 0;
```

作为一个洛谷用户，不开 $long$ $long$ 怎么对得起测评机？

------------

至于主程序，还是要说一下再，我们不能按月模拟，取而代之的是按年来模拟——这也是这道题很重要的考点之一。

标程如下：（无需开 $O2$ 优化即可 $AC$ ，代码之中不多缀解释）

```cpp
#include<iostream>
using namespace std;
unsigned long long int Y , M , year = 2013 , month = 13 , temp = 0;
int main()
{
    cin >> Y >> M;
	temp = ( Y - 2014 ) * 12 + M;
	while( temp >= month ){
		year  ++;
		temp -= month;
		month ++;
	}
	month = 12 + temp;
	cout << year << " " << month << endl;
	return 0;
}
```

管理大大辛苦了。

祝大家 $RP++$。


---

## 作者：stry (赞：5)

我们先看数据范围，
10^17<18446744073709551615(unsigned 
long long的最大值）可以用unsigned long long，我们
可以先算输入的这个月份和2013年12月过了多少月，之
后用一个临时变量来存储年份，初值是2013，因为是从
2013年开始的，再用一个变量去存储unagi历的这一年有
几个月，初值是13，因为unagi历的2013年有13个月，接
着用while来判断输入的西历的月份是unagi历的那一个
月份，判断条件是n>unagi历这一年的月份，经过月份减当前unagi历这一年的月份，月份加加，年数也加加。
输出的是判断月份是否等于0，的则输出年份减一，unagi历当年的月份数，不是照常输出。

程序如下：
```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<string>
#include<cmath>
#include<cstdio>
#include<cstring>
using namespace std;
unsigned long long a,b,n,chu,nn,nnn;
int main()
{   
   cin>>a>>b;
   n=(a-2013)*12+b;
   nn=2013;
   nnn=13;
   while(n>=nnn)
   {
      n-=nnn;
      nnn++;
      nn++;
   }
   if(n!=0){cout<<nn<<" "<<n<<"\n";}
   else{cout<<nn-1<<" "<<nnn-1<<"\n";}
   return 0;
}
```


---

## 作者：Miracle_ZX (赞：3)

### Part 1
这道绿题不算很难，其实只需要按照题目模拟。

- 因为我们的 unagi 历每年的月份都是变化的，这样对照着模拟显然不现实。但是我们要在变化的量中寻找不变量，这里的“一个月”我们便可以当做一个单位。比如我们可以先算出输入的 y 和 m 距离一个起点有多少月份（num） ，我们再把所有的月份按照 unagi 分配即可。

- 但是，我们现在面临着一个问题。你聪明的，告诉我，$2013 \leq Y \leq 10^{17}$ 它还能按照月份一个个地模拟吗？于是，我们导出一个更加简便的方法，****按照年份模拟****，怎么个模拟法呢？

- 其实，我们这里可以使用两个变量，year 和 month 来记录在 unagi 中，现在的月份和年份。当剩余的月份 num，还大于等于 unagi 中今年的月份数，我们直接在总月数 num 中减去 month，这时的年份加一即可。不要忘了更新了这一年以后，这一年的月份数也要加一

### Part 2 Code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long year = 2013, month = 13, y, m;
int main()
{
    cin >> y >> m;
    long long num = (y - 2014) * 12 + m;
    /*
        这里是算出西历的 y 年，m 月的时候离模拟起点的距离
        比如：
        2014 8
        这里算出来的 num 为 8
    */
    while(num >= month)//当此时剩余的月份还够 unagi 历的一年去减
	{
		year++;
		num -= month;
        //年数加一，剩余月份减去这一年的年份数
		month++;//到了新的一年，月份数继续加 1
	}
	cout << year << " " << 12 + num << endl;
    return 0;
}

```

### Part 3 AC
[2.77s, 3.54MB](https://www.luogu.com.cn/record/57802497)


---

## 作者：Lithium_Chestnut (赞：3)

这个绿题...是挺水的。

直接依题暴力即可。

首先先把起点设置好，设置成 $2013$ 年 $12$ 月。注意这里月份要多算上一个，便于计算。

这里我定义了一个变量 $tar$，就是最后目标，目标的计算就是算出标准月数即可，那么年数减的时候显然要多建出一个，也就是减去 $2014$。乘上 $12$ 后，再加上目标月数即可。

重要部分来了：**不可以直接模拟所有年数。**

兄台，看一眼数据范围吧。

$2013 \leq y \leq 10^{17}$。

那么显然直接模拟会爆掉。

接下来换个方式思考，我们可以直接按每一年来模拟，按年结算，方便至极。

所以我们每次循环判断改为是否大于或等于目标月数，如果否了，则跳出循环。

循环内部每次把年数加 $1$，因为目标论月，所以把目标减去 $12$ 月，也就是 $1$ 年的月数，直接转换，再把月数加 $1$ 即可。

那么最后按照 `unagi` 历输出就完事了。

挂代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll y,m,year=2013,month=13,tar;
int main()
{
	cin>>y>>m;
	tar=(y-2014)*12+m;
	while(tar>=month)
	{
		year++;
		tar-=month;
		month++;
	}
	cout<<year<<" "<<12+tar<<endl;
	return 0;
}
```

---


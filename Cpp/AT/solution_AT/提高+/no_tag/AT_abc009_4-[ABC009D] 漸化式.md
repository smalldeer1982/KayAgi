# [ABC009D] 漸化式

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc009/tasks/abc009_4

数列 $ A $ はすべての要素が $ 32 $ ビットの符号なし整数で表現でき、その値は次のようにして決まる。

- はじめの $ K $ 項 $ A_1,\,A_2,\,...,\,A_K $ は入力で与えられる。
- $ A $ とは別に $ K $ 項の数列 $ C_1,\,C_2,\,...,\,C_K $ （こちらもすべての要素が $ 32 $ ビットの符号なし整数におさまる）が入力で与えられ、$ K+1 $ 項目以降の $ A $ の値はこの $ C $ を用いて次のように計算される。 
  - $ N\ ≧\ 1 $ に対し $ A_{N+K}\ =\ (C_1\, $AND$ \,A_{N+K-1})\, $XOR$ \,(C_2\, $AND$ \,A_{N+K-2})\, $XOR$ \,...\, $ XOR$ \,(C_K\, $AND$ \,A_N) $
  - ただし AND はビットごとの論理積、 XOR はビットごとの排他的論理和を表す。

この数列 $ A $ の $ M $ 番目の値 $ A_M $ を求めるプログラムを作成せよ。

## 说明/提示

### Sample Explanation 1

実際に $ A $ の値を計算していくと次のようになる。 - $ A_4\ =\ (7\, $AND$ \,30)\, $XOR$ \,(19\, $AND$ \,20)\, $XOR$ \,(13\, $AND$ \,10)\ =\ 30 $ - $ A_5\ =\ (7\, $AND$ \,30)\, $XOR$ \,(19\, $AND$ \,30)\, $XOR$ \,(13\, $AND$ \,20)\ =\ 16 $

## 样例 #1

### 输入

```
3 5
10 20 30
7 19 13```

### 输出

```
16```

## 样例 #2

### 输入

```
5 100
2345678901 1001001001 3333333333 3141592653 1234567890
2147483648 2147483647 4294967295 4294967294 3434343434```

### 输出

```
1067078691```

## 样例 #3

### 输入

```
30 999999999
11627 5078 8394 6412 10346 3086 3933 668 9879 11739 4501 6108 12336 8771 2768 2438 2153 7047 5476 313 1264 369 12070 10743 10663 747 370 4671 5235 3439
114 3613 3271 5032 11241 6961 3628 150 12191 2396 7638 3046 11594 8162 11136 786 9878 2356 11660 1070 3649 10882 9746 1415 3307 7077 9319 9981 3437 544```

### 输出

```
2148```

# 题解

## 作者：BqtMtsZDnlpsT (赞：4)

矩阵快速幂。阅读此文前，应对矩阵乘法有一定的理解。

atcoder 评分 $2213$，但由于是远古场，所以难度评级不一定真实。

$\large\text{Problem}$

让你求一个式子的第 $M$ 项，以下是这个式子，$A_1\dots A_K$ 读入。

$A_{i+K}=\bigoplus\limits_{j=1}^{K}(A_{i+j-1}\And C_j) (i\ge1)$，$\oplus$ 表示按位异或，$\And$ 表示按位与。

$\large\text{Soluiton}$

我们可以把矩阵乘法中的加法改为按位异或，乘法改为按位与，即 $C_{i,j}=\bigoplus\limits_{k=1}^{m}(A_{i,k}\And B_{k,j}) $（与上文是 $A,C$ 无关，$C$ 为答案，$A,B$ 为相乘的两个矩阵）。

设答案数组为 $S_{1,1}\dots S_{k,1}$，分别存 $A_p,A_{p-1}...A_{p-k+1}$，更新成最新答案，${S'}_{1,1}=\bigoplus\limits_{i=1}^{m}(S_{i,1}\And C_i)$（根据题意 求 $A_{p+1}$）。

然后 ${S'}_{2,1}$ 要改为 ${S}_{1,1}$ 怎么用按位异或、按位与实现呢？考虑我们在对 $S$ 中的一个数 $S_{x,1}$ 选择，如果我们不需要这个数，我们就把它在单位矩阵中对应位置赋为 $0$（$x\And0=0,x\oplus0=x$），如果要取就把它在单位矩阵中对应位置赋为 $2^{\log {S_{x,1}}+1}-1$，在二进制下每一位都是 $1$，保证  $\And$ 起来是原数。因为我们在算 ${S'}_{i,1}(i>1)$ 的时候，只会取一个数，所以异或起来就是我们要取的那个数。

综上所述 $K\times K$ 的单位矩阵 $B$ 为：

$$\begin{pmatrix}
C_1 & C_2 &\dots & C_{k-1} & C_k\\
2^{32}-1 & 0&\dots& 0 & 0\\
0& 2^{32}-1 &\dots& 0 & 0\\
\vdots&\vdots&\ddots&\vdots&\vdots\\

0& 0 &\dots& 2^{32}-1 & 0\\
\end{pmatrix}$$

矩阵中赋 $2^{32}-1$ 的原因是题目中说最大值为 $32$ 为**无**符号整数，当然你也可以赋个更大的值，如 $2^{50}-1$。


$K\times 1$ 的初始答案矩阵为：

$$\begin{pmatrix}
A_K\\
A_{K-1}\\
\vdots\\
A_2\\
A_1\\
\end{pmatrix}$$
代码：

```cpp
struct Matrix{//矩阵
	int p[105][105],n,m;
	void clear(int XX,int YY){
		n=XX,m=YY;
		memset(p,0,sizeof p);
	}
	Matrix operator*(const Matrix&a){
		Matrix q;q.clear(a.n,a.m);
		for(int i=1;i<=n;i++){
			for(int j=1;j<=a.m;j++)
				for(int k=1;k<=m;k++)q.p[i][j]^=(s&a.p[k][j]);//分别把假和乘改为按位异或和按位与
			}
		return q;
	}
};
Matrix ans,a;//ans是上文的B，a是上文是S
signed main(){
	int k=read(),n=read();
	a.clear(k,1);
	for(int i=1;i<=k;i++)a.p[k-i+1][1]=read();//我构造的矩阵从S1,1开始，所以要倒过来
	ans.clear(k,k);
	for(int i=1;i<=k;i++)ans.p[1][i]=read();
	for(int i=1;i<k;i++)ans.p[i+1][i]=(1ll<<50)-1;
	if(n<=k){cout<<a.p[k-n+1][1]<<'\n';return 0;}
	n-=k;
	while(n){//快速幂
		if(n&1)a=ans*a;
		ans=ans*ans;n>>=1;
	}
	cout<<a.p[1][1]<<'\n';
}
```

---


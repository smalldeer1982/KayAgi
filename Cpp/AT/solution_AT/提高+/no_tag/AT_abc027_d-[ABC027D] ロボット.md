# [ABC027D] ロボット

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc027/tasks/abc027_d

数直線の原点にロボットが置かれている。 はじめ、ロボットの幸福度は $ 0 $ である。

このロボットに命令列が与えられる。 命令列は次の $ 3 $ 文字のみからなり、先頭から末尾まで順に実行される。

- `M` : 正または負の好きな向きに、距離 $ 1 $ だけ移動する。
- `+` : 今の座標を $ x $ とすると、幸福度が $ +x $ だけ変化する。
- `-` : 今の座標を $ x $ とすると、幸福度が $ -x $ だけ変化する。

 命令列を実行し終えた後、 **ロボットは原点に戻っていなければならない** 。 命令列を実行している間、ロボットの座標および幸福度は負になり得る。

最終的な幸福度を最大化するようにロボットが移動したとき、最終的な幸福度を求めよ。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1≦|S|≦1,000 $ を満たすデータセットに正解した場合は $ 30 $ 点が得られる。

### Sample Explanation 1

以下では、正の向きへの移動を `&gt;`、負の向きへの移動を `&lt;` と表す。 `&gt;+&lt;&lt;-&gt;` のように移動すればよい。

### Sample Explanation 2

例えば `&gt;&gt;&lt;+&lt;` のように移動すればよい。

### Sample Explanation 3

`&lt;&lt;&lt;+--&gt;&gt;&gt;` のように移動すればよい。

## 样例 #1

### 输入

```
M+MM-M```

### 输出

```
2```

## 样例 #2

### 输入

```
MMM+M```

### 输出

```
1```

## 样例 #3

### 输入

```
MMM+--MMM```

### 输出

```
3```

## 样例 #4

### 输入

```
+```

### 输出

```
0```

# 题解

## 作者：Herman526 (赞：1)

在 [YuYuanPQ 的题解](/article/ldf3d3kj)中，是正序考虑每次操作的。但是，我觉得倒序考虑会更加直接。

对于每次 `M` 操作，我们考虑进行操作时相比于不进行操作时答案的变化：设在不进行本次 `M` 操作时的答案为 $r$，且后面进行了 $a$ 次 `+` 操作，$b$ 次 `-` 操作。如果我们倒序考虑每次操作，则可以将本次操作分成两种情况：
- 当本次操作选择将坐标加 $1$ 时，后面操作的所有坐标均会加 $1$，因此后面会多加 $a$ 次 $1$，多减 $b$ 次 $1$，答案为 $r+a-b$；
- 当本次操作选择将坐标减 $1$ 时，后面操作的所有坐标均会减 $1$，因此后面会多减 $a$ 次 $1$，多加 $b$ 次 $1$，答案为 $r+b-a$。

所以，对于每次 `M` 操作，我们只要维护后面操作中 `+` 操作比 `-` 操作多的次数（即每次 `M` 操作选择将坐标加 $1$ 时对答案的贡献），就可以判断该次操作对答案的贡献了。

因为最后机器人要回到原点，因此 `M` 操作中坐标加 $1$、减 $1$ 的次数应该相同。具体地，我们可以将每次操作的贡献从小到大排序，加上后一半的数并减去前一半的数，得到答案。这样就可以在 $O(n\log n)$ 的时间复杂度内解决本题了。
```c++
#import<bits/stdc++.h>
char s[100001];int a[100001],k,p,q;long long r;
//k 表示当前考虑过的 M 的个数，a 即为 M 操作贡献组成的数组
main(){
	scanf("%s",s);
	for(int i=strlen(s);~--i;)if(s[i]^45)if(s[i]^43)a[k++]=p;
	//'+'的 ASCII 为 43，'-'的为 45
	else++p;
	else--p;
	std::sort(a,a+k);
	for(int i=q=k>>1;~--i;r+=a[i+q]-a[i]);
	printf("%lld\n",r);
}
```
那么，为什么在本题中，正序考虑也可以呢？我们设一共进行了 $k$ 次 `M` 操作，且倒序考虑时，第 $i$ 次 `M` 操作选择将坐标加 $1$ 时对答案的贡献为 $p_i$，正序考虑时则为 $q_i$。因此，如果所有操作中，`+` 操作比 `-` 操作多 $d$ 个，则 $q_i=d-p_i$。因此，设 $p,q$ 从小到大排序后分别变为 $p',q'$，则 $q'_i=d-p'_{k-i+1}$。因此：
$$\begin{aligned}&∑_{i=1}^{\frac k2}q'_{k-i+1}-q'_i\\=&∑_{i=1}^{\frac k2}(d-p'_{i})-(d-p'_{k-i+1})\\=&∑_{i=1}^{\frac k2}p'_{k-i+1}-p'_i\end{aligned}$$
也就是说，在机器人需要回原点时，这两种考虑方式确实是等价的。但是，如果我们需要到达的是其它点，则容易发现，两种方式并不是等价的。因此，这也就是我认为倒序考虑更直接的原因。

---

## 作者：YuYuanPQ (赞：0)

算是贪心的题吧。

我们约定下文中：

d 数组表示：输入的字符串；

cnt 表示：当前贡献。

s 数组表示：$d[i]$ 为 $M$ 时 cnt 的值；

l 表示：s 数组的长度，也就是 d 中 $M$ 的个数。

分类讨论一下：

- 当 $d[i]$ 为 `+` 时，$i$ 对正方向的贡献为 $1$，```cnt++```。

- 当 $d[i]$ 为 `-` 时，$i$ 对负方向的贡献为 $1$，```cnt--```。

- 当 $d[i]$ 为 `M` 时，把 cnt 放进 s 数组。显然，如果 $i$ 的后面没有 `+` 或者 `-`，这个位置无贡献。

把 s 数组从小到大排序。

因为前面一半的 $l/2$ 个 $s[i]$ 贡献最小，所以我们选择减去它们，后面一半的 $s[i]$ 贡献大，所以加上它们。

输出答案即可。

完结撒花~

# Code

[Link](https://atcoder.jp/contests/abc027/submissions/54647787)

---


# [ABC150E] Change a Little Bit

## 题目描述

对于两个长度为 $n$ 的 $\texttt{01}$ 序列 $S,T$ ，我们定义 $f(S,T)$ 为通过以下操作将 $S$ 修改为 $T$ 的最小代价和: 选择一个 $S$ 中的二进制位 $S_{i}$ ，然后改变 $S_{i}$ 的 $\texttt{01}$ 状态，代价为 $D \times C_{i}$，其中 $D$ 是此次操作前满足 $S_{j}\ne T_{j}$ 的整数 $j$ 的数量，$C_{i}$ 是一个给定的序列中的一个值。

求当 $S$ 取 $2^n$ 种不同的状态，$T$ 取 $2^n$ 种不同的状态时，$f(S,T)$ 的和对 $1000000007$ 取模的结果。

## 说明/提示

$1 \le n \le 200000 , 1 \le C_{i} \le 10^9 $

## 样例 #1

### 输入

```
1
1000000000```

### 输出

```
999999993```

## 样例 #2

### 输入

```
2
5 8```

### 输出

```
124```

## 样例 #3

### 输入

```
5
52 67 72 25 79```

### 输出

```
269312```

# 题解

## 作者：Rusalka (赞：5)

听说考前写题解能 ++rp

下文的 “一位” 指的是下标位置，而不是二进制位。~~应该没人会理解错吧qwq~~

## 题意简述

对于两个长度为 $N$ 的 $01$ 串 $S$, $T$，定义 $f(S,T)$ 表示经过下列操作后，$S$ 与 $T$ 在每一位上都相等的最小代价： 

-  把 $S_i$ 取反（$0$ 变 $1$, $1$ 变 $0$），若在**这次操作之前**，$S$ 与 $T$ 有 $D$ 个位置不同，则这次操作的代价为 $D \times C_i$。

显然总共有 $2^N\times (2^N-1)$ 对不同的长度为 $N$ 的 $01$ 串。对于这些所有的 $01$ 串 $S$, $T$ ，求所有 $f(S, T)$ 之和。

- $1 \le N\le 2\times10^5$， 答案对 $10^9+7$ 取模。


## 推导过程

#### 1. 如何使得一对 $f(S,T)$ 最小

显而易见，把 $c_i$ 小的放在前面一定不劣。

我们可以利用排序不等式证明它。

考虑若 $S$ 与 $T$ 没有一位是相等的，则：

$$f(S,T) = c_1\cdot n+c_2\cdot (n-1)+c_3\cdot(n-2)+...+c_n$$

交换 $c_1$, $c_2$，则：

$$f(S,T)^{'} = c_2\cdot n+c_1\cdot (n-1)+c_3\cdot(n-2)+...+c_n$$

若 $f(S,T) \lt f(S,T)^{'}$，则 $c_1\cdot n+c_2\cdot (n-1) \lt c_2\cdot n+c_1\cdot (n-1)$
，即 $c_1 \lt c_2$。

所以按照 $c_i$ 从小到大排序，则 $f(S,T) = \sum\limits_{i=1}^{m} c_{p_i}\cdot(m-i+1)$，其中 $m$ 表示不相等位置的数量，$p_i$ 表示不相等的位置。

这个括号看着很讨厌，所以不妨倒过来，把 $c_i$ 按**从大到小**排序，则 $f(S,T) = \sum\limits_{i=1}^{m} c_{p_i}\cdot i$，就为之后的推式子环节提供了很大便利。

----

#### 2. 如何计算所有 $f(S,T)$ 之和

枚举 $S$ 和 $T$ 的最后一个不同的位置，假设为 $i$；再枚举在前 $i$ 位中，$S$ 和 $T$ 有多少位不一样，假设有 $j$ 位，且最后一个不一样的位置为 $i$。

那么你需要在 $i$ 之前的 $i-1$ 位中钦定 $k-1$ 个不同的位置，则在前 $i$ 个位置中，若 $S$ 固定，$T$ 也就固定下来了；而 $i$ 之后的 $n-i$ 个位置相当于没有限制，$S$ 和 $T$ 互不干扰。

所以 

$$\texttt{ans} = \sum\limits_{i=1}^{n}2^{i}\cdot (2^{n-i})^2\cdot c_i \cdot \sum\limits_{j=1}^{i}\binom{i-1}{j-1}j$$

至此，我们有了 $\mathcal{O}(n^2)$ 的算法，但这显然不够。

瓶颈在于第二个求和号，我们考虑化简这个东西。

把它单独拎出来，我们要求的相当于是这么个东西：

$$\sum\limits_{i=0}^{n-1}\dbinom{n-1}{i}(i+1)$$

构造多项式 $g(x) = \sum\limits_{i=0}^{n-1}\binom{n-1}{i}(i+1)\cdot x^i$，$g(1)$ 就是上面的式子了。

你发现 $i\cdot x^i$ 这个形式很熟悉，是不是很像导数？

组合数放着不动，令 $G(x)^{'} = g(x)$，则 

$$G(x) = \sum\limits_{i=0}^{n-1}\binom{n-1}{i}x^{i+1}=x\sum\limits_{i=0}^{n-1}\binom{n-1}{i}x^{i}$$

求和号中是一个经典的二项式定理的形式，所以

$$G(x) = x\cdot (x+1)^{n-1}$$

则 

$$g(x) = G(x)^{'}= (x+1)^{n-1} + (n-1)x\cdot (x+1)^{n-2}$$

当 $x=1$ 时，就是我们所需要的： 

$$g(1) = 2^{n-1}+(n-1)2^{n-2} = (n+1)2^{n-2}$$

即

$$\sum_{i=0}^{n-1}\dbinom{n-1}{i}(i+1) = (n+1)2^{n-2}$$

（我同学说可以用吸收恒等式证明，但是我不会qwq）

---

带回原式，则

$$\texttt{ans} = \sum\limits_{i=1}^{n}2^{i}\cdot (2^{n-i})^2\cdot c_i \cdot (i+1)\cdot 2^{i-2}$$

化简到这里已经可以通过了，但是不妨让它好看一点（

$$\texttt{ans} = 2^{2n-2}\sum\limits_{i=1}^{n}c_i \cdot (i+1)$$

就这样了。

## Code

其实没什么必要给代码了

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int MAXN = 200010;
const int MOD = 1e9+7;

inline int add(int a, int b) {return (a+=b)>=MOD?a-MOD:a;}
inline int mul(int a, int b) {return 1ll*a*b%MOD;}
inline int pw(int x, int p)
{
	int res = 1;
	for(;p;p>>=1,x=mul(x,x))
		if(p&1) res = mul(res, x);
	return res;
}

int n, c[MAXN];

bool cmp(int a, int b) {return a > b;}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",c+i);
	sort(c+1, c+n+1, cmp);
	int ans = 0;
	for(int i=1;i<=n;i++)
		ans = add(ans, mul(c[i], i+1));
	printf("%d\n",mul(ans, pw(2, n*2-2)));
	return 0;
}
```


---

## 作者：3edc2wsx1qaz (赞：4)

我就是 [ifndef](https://www.luogu.com.cn/user/151601) 的同学。

[ifndef](https://www.luogu.com.cn/user/151601) 太强了，构造多项式求导把我吊起来打。

本篇题解着重于推式子，故贪心部分不再证明。

## 题意简述

对于两个长度为 $N$ 的 01 串 $S$ 和 $T$，定义 $f(S,T)$ 为经过以下操作后使 $S$ 和 $T$ 相同的最小代价：

- 将 $S$ 的第 $i$ 个位置取反（$0$ 变 $1$，$1$ 变 $0$）。若在该次操作前 $S$ 与 $T$ 有 $D$ 个位置不同，则这次操作的代价为 $D\times C_i$。

对于所有不同的长度为 $N$ 的 01 串 $S$ 和 $T$，计算 $f(S,T)$ 之和，答案对 $10^9+7$ 取模。

- $1 \le N \le 2\times10^5$。

## 题解

显然 $C_i$ 越小的位越早被修改越好。所以我们将 $C_i$ 从小到大排序。对于任意的 $S$，答案都是一样的。我们依次考虑 $S$ 和 $T$ 的每一位是否相同。设我们考虑到第 $i$ 位。

若相同，则这一位对答案的贡献为 $0$。

若不同，则根据上面的贪心，第 $i$ 位之前的位置已被修改完毕。所以在 $T$ 中第 $i$ 位之前的位置可以任意选数，对第 $i$ 位的贡献不影响。

对于第 $i$ 位之后的位置，我们枚举有多少个不相同的位置。

则答案为

$$2^n \cdot (\sum_{i=1}^{n}2^{i-1}\cdot C_i  \cdot\sum_{j=0}^{n-i} \dbinom{n-i}{j}(j+1))$$

考虑化简后面那个式子。

使用乘法分配律可得

$$\begin{aligned}\sum_{j=0}^{n-i} \dbinom{n-i}{j}(j+1) & = \sum_{j=0}^{n-i} \dbinom{n-i}{j}+\sum_{j=0}^{n-i} \dbinom{n-i}{j}j\\ &=2^{n-i}+\sum_{j=0}^{n-i} \dbinom{n-i}{j}j\end{aligned}$$

考虑 **吸收恒等式**：

$$\begin{aligned}\dfrac{r}{k}\dbinom{r-1}{k-1}&=\dfrac{r}{k}\times \dfrac{(r-1)^{\underline{k-1}}}{(k-1)!}\\ &=\dbinom{r}{k}\end{aligned}$$

于是：
$$\begin{aligned}\dbinom{r}{k}\times k &=\dbinom{r-1}{k-1} \times r\end{aligned}$$

所以原式可化为

$$\begin{aligned}2^{n-i}+\sum_{j=0}^{n-i} \dbinom{n-i}{j}j &=2^{n-i}+\sum_{j=0}^{n-i}\dbinom{n-i-1}{j-1}(n-i)\\&=2^{n-i}+(n-i)\sum_{j=0}^{n-i-1}\dbinom{n-i-1}{j}\\&=2^{n-i}+(n-i)2^{n-i-1}\end{aligned}$$

于是直接计算即可。时间复杂度 $O(n\log n)$。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=200005;
const int mod=1000000007;
long long p[N],a[N];
int main()
{
	int n;
	long long ans=0;
	scanf("%d",&n);p[0]=1;
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++) p[i]=p[i-1]*2%mod; 
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) ans=(ans+1LL*p[i-1]*a[i]%mod*(p[n-i]+1LL*(n-i)*p[n-i-1]%mod)%mod)%mod;
	printf("%lld\n",ans*p[n]%mod);
}
```


---

## 作者：Expert_Dream (赞：3)

给一种不用复杂公式，推式子的题解，不太正经的**打表**，发现一些规律信息，从而推出答案的式子。

首先我们知道，他要求最小代价所以说不妨先将 $C$ 从小到大排序。

首先，对于这种二进制的东西规律很多，打表也就成为可能。

先看样例二：

我们把表打出来

```
00 00 0
01 00 8
10 00 5
11 00 18

00 01 8
01 01 0
10 01 18
11 01 5

00 10 5
01 10 18
10 10 0
11 10 8

00 11 18
01 11 5
10 11 8
11 11 0
```

具体地，第一列是每一个 $S$ 的二进制，第二列是 $T$ 的二进制，第三列是他们的 $f(S,T)$。

为什么我四行就一个空行呢？

我们可以发现对于每四行，他们的 $f(S,T)$ 总和都是相等的，为什么呢？

很容易理解，对于如何变化，就是找到不一样的，可以理解为取 $S$，$T$ 的异或。他们的异或结果必定都是一样的。所以 $f(S,T)$ 总和也是一样的。

那么我们可以称作每四行为一组，那么总共多少组呢？显然就是 $T$ 可能的个数，也就是 $2^n$。也就是，我们只需要算其中一组的贡献，再乘上 $2^n$ 即可。

接下来进入第二部，如何求每一组的贡献。

接下来我们再分别列出 $n$ 为 $2$ 到 $4$ 的贡献。

对于 $n=2$ 时：单组的贡献是 $3 \times C_1 + 2 \times C_2$。看不出什么规律。

对于 $n=3$ 时：单组的贡献是 $8 \times C_1 + 6 \times C_2 + 4 \times C_3$。貌似与 $n=2$ 的区别还挺大，但是我们发现他们好像都是等差数列。

对于 $n=4$ 时：单组的贡献是 $20 \times C_1 + 16 \times C_2 + 12 \times C_3 + 8 \times C_4$。验证了之前的猜想，他的确是一个等差数列。

那么我们对于等差数列得知道首项和公差。

其实我们也可以直接知道末项，更方便。

对于 $n$ 从 $2$ 到 $4$ 的末项是 $2,4,8$。指数级增长，断定为 $2^{n-1}$。

然后，对于 $n$ 从 $2$ 到 $4$ 的公差是 $1，2，4$。指数级增长，断定为 $2^{n-2}$。

这样，只需要等差数列求和就行了。

为什么他是等差数列呢？

末项比较容易理解，最后一位到他的时候肯定只剩下 $1$ 个不同的数，然后总共 $2^n$ 种方案，其中有一半都是末位不同，因此是 $2^{n-1}$。

然后公差如何解释？我认为是这一位跟后一位都需要变的方案有多少种，这就是 $2^{n-2}$。所以这个公式的证明也就成立了。

那么我们可以直接枚举每一个 $a_i$。

带入之前的得到公式：

$ans = 2^n \times \sum_{i=1}^n \times (2^{n-1} + (n-i) \times 2^{n-2})$。

记得勤取模。


[link](https://atcoder.jp/contests/abc150/submissions/54694778)。

---

## 作者：EuphoricStar (赞：2)

令 $S_i \gets S_i \oplus T_i$，那么代价中 $D$ 变成 $S_i = 1$ 的 $i$ 数量。转化为对所有 $f(S)$ 求和，最后答案乘上 $2^n$。

考虑贪心地求 $f(S)$。肯定是先选择小的 $C_i$，把 $S_i$ 变成 $0$。正确性显然。下面把 $C_i$ 从大到小排序。

考虑拆贡献。对于一个 $C_i$，考虑它一共被算了多少次。显然 $i$ 自己会贡献 $2^{n - 1}$ 次（除去 $S_i = 0$ 的情况），对于 $j < i$，因为 $C_j \ge C_i$，所以改变 $S_i$ 时 $S_j$ 必定还没被改变。有 $2^{n - 2}$ 种情况使得 $S_j = 1$，一共有 $i - 1$ 个 $j < i$ 的 $j$，所以 $C_i$ 的贡献系数就是 $2^{n - 2} \times (i - 1) + 2^{n - 1}$。

因此最后答案就是：

$$2^n \times \sum\limits_{i = 1}^n (2^{n - 2} \times (i - 1) + 2^{n - 1}) \times C_i$$

[code](https://atcoder.jp/contests/abc150/submissions/42059541)

---

## 作者：Exp10re (赞：1)

怎么楼下推式子这么复杂。

## 解题思路

考虑某一个状态下有若干位需要修改，可以发现按照这些位的 $C$ 值从小到大修改一定最优，邻项交换可证。

故对 $C$ 排序，显然排序后的问题与原问题等价。

故在某个状态下修改了 $S_i$ 的值，可以发现在上述最优情况下 $S_x(x\lt i)$ 都不需要修改，$S_x(x\gt i)$ 都未被修改过。前者不对修改 $S_i$ 时的系数产生贡献，后者每一位对系数产生贡献的期望是 $0.5$（即 $S_x$ 与 $T_x$ 不同的概率），而 $S_i$ 在所有情况下与 $T_i$ 不同的概率也是 $0.5$，故在一次任意情况下 $S_i$ 对答案产生的期望贡献是：

$$0.5C_i \times (1+0.5(n-i))$$

对这个式子进行求和，然后乘上 $2^{2n}$（所有有效情况）即为答案。即：

$$Ans=2^{2n} \sum_{i=1}^{n} 0.5C_i \times (1+0.5(n-i))$$

模意义算逆元之后随便求。时间复杂度 $O(n)$。

---

## 作者：analysis (赞：0)

首先是一个 key observation。

> key observation：先选 $c_i$ 小的位置能达到最小代价

相当于给若干个数分配 $1 \to x$ 的系数，显然让大数分配小的系数更优秀。

于是可以给 $C$ 排序。然后我们考虑 $i$ 位置的贡献，这只与 $i$ 后面有多少个不同的位置有关，于是答案为：
$$
2^n\sum_{i=1}^{n}\sum_{j=0}^{n-i}\binom{n-i}{j}2^{i-1}(j+1)c_i
$$
（$S$ 有 $2^n$ 种方案，$T$ 中前 $i-1$ 位不影响 $i$ 的贡献，共 $2^{i-1}$ 种方案，用组合数选出 $i$ 后不同数所在位置，这些位置与 $S$ 不同，剩下与 $S$ 相同）

显然移项，得到：
$$
2^{n-1}\sum_{i=1}^{n}2^{i}c_i\sum_{j=0}^{n-i}\binom{n-i}{j}(j+1)
$$
由于 $c$ 的不确定性，所以剩下主要考虑优化后半部分的计算，即：
$$
\sum_{j=0}^{N}\binom{N}{j}(j+1)
$$
当然，给式子带上形式幂级数，然后先积分再求导很容易能够解决。

但作为不一样的唐氏儿，我们有更加唐诗的方法。

工业化的底数换指数：
$$
\sum_{j=0}^{N}\binom{N}{j}(j+1)\\
=[x]e^x(1+e^x)^N\\
=[x^{0}](1+e^x)^{N}+[x](1+e^x)^{N}\\
$$
考虑到 $[x^{0}](1+e^x)=2,[x](1+e^{x})=1$，有：
$$
[x^{0}](1+e^x)^{N}+[x](1+e^x)^{N}\\
=2^{N}+N2^{N-1}
$$

$$
2^{n-1}\sum_{i=1}^{n}2^{i}c_i\sum_{j=0}^{n-i}\binom{n-i}{j}(j+1)\\
=2^{n-1}\sum_{i=1}^{n}2^{i}c_i(2^{n-i}+(n-i)2^{n-i-1})
$$

做完了，感觉自己变成了奶龙。

---

## 作者：AC_love (赞：0)

不难发现，不同的 $S$ 对应所有的 $T$ 的贡献和都相等。

我们令 $S = 000\cdots 000$ 计算一遍贡献。最后得到的结果直接乘上 $2^n$ 即可。

继续找性质：如果 $T$ 有很多个位置是 $1$，我们肯定会优先修改 $C_i$ 更小那个。

先把所有 $C_i$ 排个序，然后考虑每个 $C_i$ 会对最终结果有多少贡献。

每个 $C_i$ 的贡献一定只和其他 $C_j$ 比它大的 $j$ 有关，因为比它小的一定会在它之前更改，不会对它产生影响。

我们只要统计一下所有排序后在 $i$ 后面的位置能产生多少个不同的数位，每个 $C_i$ 的贡献就能计算出来了。

不同的数位的个数该怎么计算呢？

$i$ 前面有 $i - 1$ 个位置，这些位置 $T$ 可以任意选，不会影响第 $i$ 位的结果，情况数 $2^{i - 1}$。

$i$ 后面有 $n - i$ 个位置，如果有 $j$ 个位置不同，情况数是 ${n - i\choose j}$。

因此贡献的计算式为：

$$\sum_{i = 1}^n 2^{i - 1} C_i \times \Bigg( \sum_{j = 0}^{n - i}{n - i\choose j} \times (j + 1) \Bigg)$$

后面的东西用乘法分配律处理一下，得到：

$$\sum_{i = 1}^n 2^{i - 1} C_i \times \Bigg(2^{n - i} + \sum_{j = 0}^{n - i}{n - i\choose j} \times j \Bigg)$$

这个式子大部分东西都很好计算，然而剩下了一个恶心人的 $\sum_{j = 0}^{n - i}{n - i\choose j} \times j$，这玩意怎么处理呢？

首先我们注意到 $j = 0$ 时这玩意一定为 $0$，所以 $j$ 从 $1$ 开始枚举即可。

考虑直接暴力拆开：

$$\begin{aligned} {n - i \choose j} \times j & = \dfrac{(n - i)!}{j! \times (n - i - j)!} \times j \\ & = \dfrac{(n - i) !}{(j - 1)!(n - i - j) !}\\ & =\dfrac{(n - i - 1)!}{(j - 1)!(n - i - j) !} \times (n - i) \\ &= {n - i - 1 \choose j - 1} \times (n - i) \end{aligned}$$

继续转化：

$$\begin{aligned}\sum_{j = 1}^{n - i}{n - i - 1 \choose j - 1} \times (n - i) & = (n - i)\sum_{j = 1}^{n - i}{n - i - 1 \choose j - 1}\end{aligned}$$

换个元，令 $k = j - 1$，继续转化：

$$\begin{aligned}\sum_{j = 1}^{n - i}{n - i - 1 \choose j - 1} \times (n - i) & = (n - i)\sum_{j = 1}^{n - i}{n - i - 1 \choose j - 1} \\ &=(n - i) \sum_{k = 0}^{n - i - 1} {n - i - 1\choose k} \\ &= (n - i) 2 ^ {n - i - 1} \end{aligned}$$

最后答案为：

$$2^n \times \sum_{i = 1}^n 2^{i - 1} C_i \times (2 ^ {n - i} + (n - i) 2 ^ {n - i - 1})$$

推式子过程很麻烦，但结果是好的。

[code](https://atcoder.jp/contests/abc150/submissions/59491422)

---

## 作者：lilong (赞：0)

计数题。

首先有一个显然的贪心，即对于较大的 $C_i$，应分配一个较小的 $D$。考虑反证，设 $C_i > C_j$ 且 $D_1 > D_2$，从 $C_i \times D_2 + C_j \times D_1$ 变成 $C_i \times D_1 + C_j \times D_2$ 的变化量为 $C_i \times ( D_1 - D_2 ) - C_j \times ( D_1 - D_2 )=(C_i-C_j)\times (D_1-D_2) > 0$，显然不优，因此上述贪心正确。

有了这个贪心，那么在每种状态下，每个位置被修改时的 $D$ 也就确定了。发现状态数太多，因此换一个角度，计算每个 $C_i$ 对于答案的贡献。影响贡献的有两个因素：$C_i$ 被修改时的 $D$（可简单理解为比 $C_i$ 大的数的个数），以及对应这个 $D$ 的方案数。不妨先将 $C$ 从大到小排序。

设当前在第 $i$ 个位置，则对答案的贡献为（为了区分原题目中的 $C_i$ 和组合数，$C_i$ 用 $A_i$ 表示）：

$$A_i \times 2^{n-i} \times \sum_{j=0}^{i-1} (j+1) \times C_{i-1}^{j}$$

我们分开理解这个式子的各部分：$2^{n-i}$ 表示后面的 $n-i$ 位修改不修改均可，不会对当前第 $i$ 位产生影响；$j$ 表示前面 $i-1$ 个位置修改的个数，那么此时 $D=j+1$，而前面修改的方案有 $C_{i-1}^{j}$ 种，将两者相乘即可。

直接这样做是 $O(n^2)$ 的，还有优化的空间。回顾组合数递推的式子 $C_i^j=C_{i-1}^j + C_{i-1}^{j-1}$，在本题中即 $C_{i-1}^{j}=C_{i-2}^j+C_{i-2}^{j-1}$，还要乘上 $j+1$ 的系数。记 $sum_i=\sum_{j=0}^{i-1} (j+1) \times C_{i-1}^{j}$，即

$$C_{i-1}^j \times (j+1) = C_{i-2}^{j} \times (j+1) + C_{i-2}^{j-1} \times (j+1) $$

展开最后一项并带上求和符号：

$$sum_i=\sum_{j=0}^{i-1} (j+1) \times C_{i-1}^{j}= \sum_{j=0}^{i-1} C_{i-2}^{j} \times (j+1) + C_{i-2}^{j-1} \times j + C_{i-2}^{j-1}$$

分开等式右边各部分为：

$$ sum_i=\sum_{j=0}^{i-1} C_{i-2}^{j} \times (j+1) + \sum_{j=0}^{i-1} C_{i-2}^{j} \times (j+1) + \sum_{j=0}^{i-1} C_{i-2}^{j}$$

发现第一项和第二项完全等价，即为 $sum_{i-1}$（$C_{i-2}^{i-1}$ 显然为 $0$，不会产生影响）。第三项就是杨辉三角中一行的求和，直接可得为 $2^{i-2}$。于是 $sum_i=sum_{i-1}\times 2+2^{i-2}$。初始值 $sum_1=1$。

实现时只需要预处理 $2$ 的幂即可。由于只是确定了每个位修改还是不修改，并没有确定是从 $0$ 变为 $1$ 还是从 $1$ 变为 $0$，因此最后答案要乘上 $2^n$。时间复杂度 $O(n)$。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define int long long
#define MOD 1000000007

using namespace std;

int n,c[1000001],p2[1000001],sum,ans,tot;


bool cmp( int x , int y )
{
	return x > y;
}

signed main()
{
	cin >> n;
	p2[0] = 1;
	for( int i = 1 ; i <= n ; i ++ )
	{
	    cin >> c[i];
		p2[i] = p2[i - 1] * 2ll % MOD;
    }
	sort( c + 1 , c + n + 1 , cmp );
	sum = 1;
	for( int i = 1 ; i <= n ; i ++ )
	{
		if( i >= 2 )
		{
			tot = p2[i - 2];
			sum = ( sum * 2 % MOD + tot ) % MOD;
		}
		ans = ( ans + sum * c[i] % MOD * p2[n - i] % MOD ) % MOD;
	}
	cout << ans * p2[n] % MOD;
	return 0;
}
```

---


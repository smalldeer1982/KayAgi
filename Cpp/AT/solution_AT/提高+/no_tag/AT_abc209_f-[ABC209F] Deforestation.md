# [ABC209F] Deforestation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc209/tasks/abc209_f

$ N $ 本の木が左右一列に並んでおり、左から $ i\,\ (1\ \leq\ i\ \leq\ N) $ 本目の木 $ i $ の高さは $ H_i $ です。

あなたは、好きな順番でこれら $ N $ 本の木を全て伐採します。具体的には、 $ (1,2,\ \ldots,\ N) $ の並び替えによって得られるある順列 $ P $ について、$ i=1,2,3,...,N $ の順に、

- $ H_{P_i-1}+H_{P_i}+H_{P_i+1} $ のコストを支払った後、木 $ P_i $ を伐採する。すなわち、$ H_{P_i} $ を $ 0 $ にする。

という操作を行います。ただし、$ H_0=0,H_{N+1}=0 $ とします。

言い換えると、ある木を伐採するのにかかるコストは木を伐採する直前での、その木と両隣の木の高さの総和となります。

支払うコストの総和が最小となるような $ P $ の個数を求めてください。答えは非常に大きくなる可能性があるので、$ (10^9+7) $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 4000 $
- $ 1\ \leq\ H_i\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

支払うコストの総和が最小となるような $ P $ は、$ (1,3,2) $ と $ (3,1,2) $ の $ 2 $ つです。以下、木の伐採の例を示します。 $ P=(1,3,2) $ のとき - 最初に木 $ 1 $ を伐採する。この時に支払うコストは $ H_0+H_1+H_2=6 $ である。 - 次に木 $ 3 $ を伐採する。この時に支払うコストは $ H_2+H_3+H_4=6 $ である。 - 最後に木 $ 2 $ を伐採する。この時に支払うコストは $ H_1+H_2+H_3=2 $ である。 支払うコストの総和は $ 14 $ となります。

### Sample Explanation 3

$ (10^9+7) $ で割った余りを出力することに注意してください。

## 样例 #1

### 输入

```
3
4 2 4```

### 输出

```
2```

## 样例 #2

### 输入

```
3
100 100 100```

### 输出

```
6```

## 样例 #3

### 输入

```
15
804289384 846930887 681692778 714636916 957747794 424238336 719885387 649760493 596516650 189641422 25202363 350490028 783368691 102520060 44897764```

### 输出

```
54537651```

# 题解

## 作者：大眼仔Happy (赞：9)

事情是这样的，今天我用 exlg 随机跳了 AT_abc209_f。想着可能是以前那个求序列最大独立集的优先队列 trick，但是这题让我求取到最小值的方案，这就不会了吧。~~于是点开了题解。~~

首先先进行了第一步分析，如何取到最小值。发现和相邻的有关。那我们先考虑相邻的 $i$ 和 $i+1$ 的选取顺序：

- 先选 $i$，后选 $i+1$。权值是 $(a_{i-1}+a_{i}+a_{i+1})+(0+a_{i+1}+a_{i+2})$。

- 先选 $i+1$，后选 $i$。权值是 $(a_{i}+a_{i+1}+a_{i+2})+(a_{i-1}+a_{i}+0)$。

从这里我们可以得到，若 $a_{i}>a_{i+1}$，则先选 $i$，若 $a_{i+1}>a_i$，则先选 $i+1$。如果相等，那么谁先谁后无所谓。至于这个东西，因为对于所有的 $i$ 都成立，所以我们将其推广到了整个序列。~~于是我还是不会做。。。~~

突然从题解看到一个关键词：插入 dp。插入 dp 是什么？我只听过插头 dp 啊。于是我上网搜，找到了一个博客讲了这个东西，还给了一个[例题](https://www.luogu.com.cn/problem/AT_dp_t)。我一看，这例题我不是做过了吗？那我就会做了啊！

咳咳，言归正传，我们从这道例题出发，来推导我们想要的东西。

> 有一个长为 $N$ 的正整数排列。给定一个由 `<` 和 `>` 组成长为 $N-1$ 的的字符串。   
对于任意满足 $1 \le i \le N-1$ 的字符 $s_i$，如果 $s_i$ 是 `<` 则 $P_i<P_{i+1}$、如果 $s_i$ 是 `>` 则 $P_i>P_{i+1}$。求满足这样的性质的排列 $P$ 的方案数。

我们尝试使用 dp，设 $f_{i,j}$ 表示前 $i$ 个数放了 $i$ 的排列，且末尾为 $j$ 的方案数。考虑如何转移：

$$
f_{i,j}=
\begin{cases}
\displaystyle\sum_{k=1}^{j-1}f_{i-1,k} & s_i=\texttt{'<'}
\\ \\
\displaystyle\sum_{k=j}^{i-1}f_{i-1,k} & s_i=\texttt{'>'}
\end{cases}
$$

这是如何来的呢？我们也许会有一个疑问，为什么可以从 $i-1$ 转移过来？$i-1$ 的这些方案中代表前面的 $i-1$ 个数中只能填 $1\sim i-1$ 啊，但是事实上我还可以填 $i$。这个问题很简单：由于前面 $i-1$ 个数互不相同，他们对应的排名则正好是 $1\sim i-1$，则可以正好对应 $f_{i-1,k}$，而根本不需要知道具体数字。

回到这个题，我们发现前一步正好求出来相邻数的关系，进而得到了相邻数选取的顺序，只是多了一个不确定的情况。由于没有限制，所以直接就是所有加起来就行了。最后我们要求选取所有数的顺序，同样也是一个排列，同样的思路同样的解法。

$$
f_{i,j}=
\begin{cases}
\displaystyle\sum_{k=1}^{j-1}f_{i-1,k} & s_i=\texttt{'<'}
\\ \\
\displaystyle\sum_{k=1}^{i-1}f_{i-1,k} & s_i=\texttt{'?'}
\\ \\
\displaystyle\sum_{k=j}^{i-1}f_{i-1,k} & s_i=\texttt{'>'}
\end{cases}
$$

这样转移是 $O(n^3)$ 的，加个前缀和就可以了达到 $O(n^2)$ 了。

[多倍经验：UVA1650](https://www.luogu.com.cn/record/145752479)。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4005,mod=1e9+7;
int inline read()
{
	int num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
int n,a[N];
int f[N][N],s[N][N];
int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	f[1][1]=1;for(int i=1;i<=n;i++)s[1][i]=1;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			if(a[i]<a[i-1])f[i][j]=s[i-1][j-1];
			if(a[i]>a[i-1])f[i][j]=dec(s[i-1][i-1],s[i-1][j-1]);
			if(a[i]==a[i-1])f[i][j]=s[i-1][i-1];
			s[i][j]=inc(s[i][j-1],f[i][j]);
		}
	}
	printf("%d\n",s[n][n]);
	return 0;
}
```

---

## 作者：Acoipp (赞：5)

# [**[ABC209F] Deforestation**](https://www.luogu.com.cn/problem/AT_abc209_f)

## **初探题面**

阅读完这道题之后，我们发现它没有叫你计算最小的花费是多少，而是计算有多少种方案能够达到最小的花费。

遇到这种类型的题目，首先要明确**在什么条件下能够达到最小的花费**。

因为任意一个 $i$ 产生的权值与 $i-1$，$i$，$i+1$ 有关，说人话就是相邻的元素选择的顺序会影响到它的权值，所以我们考虑对于 $i$，$i+1$，哪个先选比较好。

- 如果先选 $i$，权值为：$a_{i-1}+a_i+a_{i+1}+a_{i+1}+a_{i+2}$。
- 如果先选 $i+1$，权值为：$a_i+a_{i+1}+a_{i+2}+a_i+a_{i-1}$。

用第一个式子减去第二个式子得：$2a_{i+1}-2a_i$。

所以当 $a_{i+1} > a_i$ 时，先选 $i+1$ 更好；当 $a_i > a_{i+1}$ 时，先选 $i$ 更好；如果两者相等，那么我们可以任意抉择。

很明显的，对于每组 $i$，$i+1$ 我们都可以这么抉择并且至少有一种方案满足这种选择，所以这种局部最优性可以扩展到全局，因此，我们只要求出满足这种顺序的方案数就行了。

## **状态设计**

既然最优解是限制了元素插入进去的顺序的，那么我们可以使用插入 DP 的相关套路解决这个题目。

我们发现如果按照这个关系减出来的图其实是一个 TAG，不好维护插入顺序。因此我们只能考虑从 $1 \sim n$ 依次考虑插入。

因为 $i$ 可以插入的方案数仅与 $i-1$ 所插入的位置有关系，而且题目允许 $O(n^2)$ 的空间和时间，因此我们设计两维 DP 数组：$dp_{i,j}$ 表示第 $i$ 个数插入到了第 $j$ 个位置满足条件的方案。

**说明一下，这里的第 $j$ 个位置并不是最终操作序列上的位置，而是操作序列只保留 $1\sim i$ 的子序列的相对位置。**

## **转移方程**

- 对于 $a_i > a_{i-1}$ 先选 $i$，所以 $i$ 的相对位置一定在 $i-1$ 的相对位置的前面，故 $dp_{i,j} = \sum_{k=j}^i dp_{i-1,k}$。

- 对于 $a_i < a_{i-1}$ 先选 $i-1$，所以 $i$ 的相对位置一定在 $i-1$ 的相对位置的后面，故 $dp_{i,j} = \sum_{k=1}^{j-1} dp_{i-1,k}$。

- 对于 $a_i = a_{i-1}$ 都可以先选，所以全部情况都可以转移，故 $dp_{i,j} = \sum_{k=1}^{j-1} dp_{i-1,k}$。

注：
- 第一个转移方程从 $j$ 开始循环到 $i$ 是因为如果 $i-1$ 在 $1 \sim i-1$ 的第 $j$ 个位置，那么 $i$ 就可以插入到第 $j$ 个位置的前面使得 $i$ 在 $i-1$ 的前面并且相对位置也是 $j$。
- 第二个转移方程循环到 $j-1$ 的道理同上。
- 这种方法为什么能不重不漏，是因为两个不同的最终操作序列一定有一个 $i$ 在 $1\sim i$ 中的相对位置不同；两个相同的最终操作序列一定满足每一个 $i$ 在 $1\sim i$ 中的相对位置相同。
- 初始化 DP 的时候需要注意 $1$ 在 $1\sim 1$ 中的相对位置只有 $1$ 这一个。

综上，代码就可以写出来了。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
ll n,a[4005],dp[4005][4005],m[4005][4005],i,j;
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(i=1;i<=n;i++) cin>>a[i];
	dp[1][1] = 1;
	for(i=1;i<=n;i++) m[1][i]=1;
	for(i=2;i<=n;i++){
		for(j=1;j<=i;j++){
			if(a[i]==a[i-1]) dp[i][j]=m[i-1][i-1];
			if(a[i]>a[i-1]) dp[i][j]=((m[i-1][i-1]-m[i-1][j-1])%mod+mod)%mod;
			if(a[i]<a[i-1]) dp[i][j]=m[i-1][j-1];
		}
		for(j=1;j<=n;j++) m[i][j]=(m[i][j-1]+dp[i][j])%mod;
	}
	cout<<m[n][n]<<endl;
}
```

---

## 作者：Zirnc (赞：3)

[ABC209F Deforestation](https://www.luogu.com.cn/problem/AT_abc209_f)


题意：给出 $n$ 棵树的高度，砍第 $i$ 棵树的花费是 $h_i+h_{i-1}+h_{i+1}$，求有多少种方案能使得砍完所有树的总代价最小。

------

砍一棵树的代价只与相邻的树高度有关。下面研究砍 $h_i$ 与 $h_{i+1}$ 的先后顺序对答案的影响。

1. 先砍 $h_i$ 后砍 $h_{i+1}$：$h_i+h_{i-1}+h_{i+1}+h_{i+1}+h_{i+2}$
2. 先砍 $h_{i+1}$ 后砍 $h_i$：$h_{i+1}+h_i+h_{i+2}+h_i+h_{i-1}$

作差后得到：$h_{i+1}-h_i$。当 $h_{i+1}>h_i$ 时，应该先砍 $h_{i+1}$。当 $h_{i+1}<h_i$ 时，应该先砍 $h_i$。因此，**对于相邻的两棵树，先砍高的那棵最优**。

------

**插入 DP（insertion DP）**：先考虑排好前 $i-1$ 个数，再往中间插入第 $i$ 个数。

令 $\mathit{f}_{i,j}$ 表示排好了前 $i$ 棵树的砍树次序，且第 $i$ 棵树排在第 $j$ 位，得到最小代价的方案数。

当 $h_{i+1} > h_i$ 时，应先砍 $i+1$，那么 $\mathit{f}_{i+1,j} = \sum_{k=j}^{i}\mathit{f}_{i,k}$

当 $h_i > h_{i+1}$ 时，应先砍 $i$，那么 $\mathit{f}_{i+1,j}  = \sum_{k=1}^{j-1}\mathit{f}_{i,k}$

当 $h_i = h_{i+1}$ 时，砍哪棵都可以，$\mathit{f}_{i+1,j}  = \sum_{k=1}^i\mathit{f}_{i,k}$

可以用前缀和优化 DP，$O(n^2)$。

**弱智错误！**：减法忘记加 MOD。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD = 1e9+7;
LL n, h[4005];
LL dp[4005][4005], sum[4005][4005];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> h[i];
	dp[1][1] = sum[1][1] = 1; 
	for (int i = 2; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			if (h[i] > h[i-1]) {
				dp[i][j] = (sum[i-1][i-1]-sum[i-1][j-1]+MOD)%MOD;
			} else if (h[i] < h[i-1]) {
				dp[i][j] = (sum[i-1][j-1])%MOD;
			} else {
				dp[i][j] = (sum[i-1][i-1])%MOD;
			}
			sum[i][j] = (sum[i][j-1]+dp[i][j])%MOD;
		}
	}
	LL ans = 0;
	for (int i = 1; i <= n; i++) ans = (ans+dp[n][i])%MOD;
	cout << ans << endl;
	return 0;
}
```



------

Thanks to [ABC 209 F - Deforestation - hzy0227](https://www.cnblogs.com/hzy717zsy/p/16356781.html)

---

## 作者：xiaoPanda (赞：2)

## ABC209F - Deforestation(*2307)

### Problem
给出 $n$ 棵树，第 $i$ 高 $a_i$，砍走一棵树的代价为 $a_{i-1}+a_i+a_{i+1}$，并且砍走后 $a_i$ 清零，特别的 $a_0=a_{n+1}=0$，问使得代价最小的方案数。
### Solution
考虑对于每个 $a_i$ 对于答案的贡献是多少，很明显，当 $a_i$ 先砍，再砍 $a_{i-1}$ 或 $a_{i+1}$ 时，$a_i$ 不会对 $a_{i-1}$ 或 $a_{i+1}$ 的代价有贡献，那么分情况讨论一下什么时候先砍 $a_i$。

有三种情况（只考虑 $a_i$ 和 $a_{i-1}$，因为 $a_{i+1}$ 也是同一种情况）

+ $a_i=a_{i-1}$，这时候不管顺序，代价都是一样的。

+ $a_i>a_{i-1}$，这时候应该先砍 $a_i$，再砍 $a_{i-1}$，这种代价为 $(a_{i-1}+a_i+a_{i+1})+(a_{i-2}+a_{i-1}+0)=2* a_{i-1}+a_i+a_{i+1}+a_{i-2}$，相反，如果先砍 $a_{i-1}$，再砍 $a_i$，代价为 $(0+a_i+a_{i+1})+(a_{i-2}+a_{i-1}+a_i)=a_{i-1}+2*a_i+a_{i+1}+a_{i-2}$，显然前者更优。

+ $a_i<a_{i-1}$，同理，应该先砍 $a_{i-1}$，再砍 $a_i$（注意上面都是考虑 $a_i$ 和 $a_{i-1}$，与 $a_{i+1}$ 的先后无关，如果是中间砍 $a_{i+1}$，那么当枚举到下一个的时候也会考虑，像这样的局部最优肯定是最优解，所以用这个贪心策略可以得到最低代价）。

题目还要求求方案的数量，我们可以根据贪心原则设计 DP，设 $f_{i,j}$ 表示将前 $i$ 棵树看完并且第 $j$ 次砍第 $i$ 棵树的方案数，依旧分三种情况：

+ $a_i=a_{i-1}$，那么 $f_{i,j}=\sum_{k=1}^{i-1}f_{i,k}$，也就是说 $i$ 与 $i-1$ 间没有位置关系要求，但 $k\le i-1$，注意此处砍 $a_i$ 不会对除了 $a_{i-1}$ 和 $a_{i+1}$ 其外的树有影响，所以第 $1$ 次到第 $i$ 次砍 $a_i$ 都可以。

+ $a_i>a_{i-1}$，那么 $f_{i,j}=\sum_{k=1}^{j-1}f_{i-1,k}$，也就是说 $a_i$ 要在砍 $a_{i-1}$ 之前。

+ $a_i<a_{i-1}$，那么 $f_{i,j}=\sum_{k=j}^{i-1}f_{i-1,k}$，也就是说 $a_i$ 要在砍 $a_{i-1}$ 之后，并且 $k\le i-1$。

这样时间复杂度是 $O(n^3)$ 的，用前缀和优化一下就是 $O(n^2)$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5007;
const int M=1e9+7;
int a[N],f[N][N],sum[N][N];
main() 
{
	int n,ans=0;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
	f[1][1]=sum[1][1]=1;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			if(a[i]==a[i-1])f[i][j]=sum[i-1][i-1]%M;
			if(a[i]>a[i-1])f[i][j]=sum[i-1][j-1]%M;
			if(a[i]<a[i-1])f[i][j]=(sum[i-1][i-1]-sum[i-1][j-1])%M+M;//前缀和是sum[i-1][i-1]-sum[i-1][j-1]而不是sum[i-1][i-1]-sum[i-1][j]，后者减去了f[i-1][j]
		}
		for(int j=1;j<=n;j++)sum[i][j]=(sum[i][j-1]+f[i][j])%M;
	}
	for(int i=1;i<=n;i++)
	ans+=f[n][i],ans%=M;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：AKPC (赞：0)

题目所问的是最小代价情况下的方案数，那我们需要考虑满足最小代价的条件。而因为一次操作的代价只和操作对象的相邻位置有关，所以考虑对相邻两项的限制。

令一个 $i\in[1,n)$，我们依次操作下标 $i,i+1$ 时，产生 $(a_{i-1}+a_i+a_{i+1})+(0+a_{i+1}+a_{i+2})=a_{i-1}+a_i+2a_{i+1}+a_{i+2}$ 的贡献；而我们依次操作下标 $i+1,i$ 时，产生 $(a_i+a_{i+1}+a_{i+2})+(a_{i-1}+a_i+0)=a_{i-1}+2a_i+a_{i+1}+a_{i+2}$ 的贡献。两个贡献作差不难发现，$a_i<a_{i+1}$ 时先操作 $i+1$ 更优，$a_i>a_{i+1}$ 则先操作 $i$ 更优，相等则任意顺序都可。

至此，题目转化成你需要求出一个排列（操作顺序），使得相邻两项满足其对应的固定大小关系。可以使用一种叫 **插入 DP** 的技巧处理这种问题。

[AT_dp_t](https://www.luogu.com.cn/problem/AT_dp_t) 正是一道插入 DP 的模板题，其做法是设 $dp_{i,j}$ 表示前 $i$ 为填了 $1\sim i$ 的排列且最后一位是 $j$ 的方案数。由于前面的关系都满足，所以为了保证 $i-1,i$ 两个下标的位置也满足对应关系，要记录最后一位 $j$。转移过程中，枚举第 $i$ 位需要放的数字 $t$，并将 $[1,i)$ 下标范围内 $\geq t$ 的数全部加一，就可以保证其仍然是 $1\sim i$ 的排列。

在 AT_dp_t 这个问题中，当 $a_{i-1}<a_i$：

$$dp_{i,t}=\sum\limits_{j=1}^{t-1}dp_{i-1,j}$$

当 $a_{i-1}>a_i$：

$$dp_{i,t}=\sum\limits_{j=t}^{i-1}dp_{i-1,j}$$

不难发现，转移可以使用前缀和优化达到 $n^2$。而本题也只是多了一个任意关系（即满足大于、小于均可），显然这种直接把大于、小于两种情况作和即可。

[code](https://www.luogu.com.cn/paste/gg8lwdbs)。

---

## 作者：Annihilation_y (赞：0)

说句实话赛时想这道题的思路完全想偏了。最后三十几分钟才把思考方向大概想到。

首先观察数据范围，这道题明显是允许 $O(n \times n)$ 的时间复杂度的。

接着，根据题目描述，我们假设删除一个 $h_{i}$，则对于 $h_{i-1}$，有两种顺序。

1.先删除 $h_{i}$，则代价为 $h_{i-2} + h_{i-1} + h_{i-1} + h_{i} + h_{i+1}$。

2.先删除 $h_{i-1}$，则代价为 $h_{i-2} + h_{i-1} + h_{i} + h_{i} + h_{i+1}$。

然后将一式减去二式，得到 $h_{i-1} - h_{i}$。

所以可以得出结论，对于每一个 $i$，如果 $h_{i} > h_{i-1}$，则先删除前者，否则同理。

状态设计：

$dp_{i,j}$ 表示当前取到了第 $i$ 个数，第 $i$ 个数在当前的相对位置为 $j$ 的总方案数。

状态转移：

根据前面推出来的结论转移，做一个累加即可，具体实现看代码。

优化：

定义一个 $f$ 数组。

$f_{i,j} \gets \sum\limits_{k=1}^{j} dp_{i,k}$ 。

方便前缀和转移。

~~~c++
#include <bits/stdc++.h>
using namespace std;
namespace cs{
	const int MAXN=4e3+5;
	long long Mod=1e9+7; 	
	long long f[MAXN][MAXN],dp[MAXN][MAXN];
	int n,a[MAXN];
	int main()  {
		std::ios::sync_with_stdio(false);
		cin.tie(0);cout.tie(0);
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		dp[1][1]=1;
		for(int i=1;i<=n;i++) f[1][i]=1;
		for(int i=2;i<=n;i++) {
			for(int j=1;j<=i;j++) {//j表示对i的相对位置进行枚举
				//以下为对dp进行转移 均通过前缀和进行维护 
				if(a[i]==a[i-1]) dp[i][j]=f[i-1][i-1];//当相等的时候i和i-1谁便先删哪一个都行 
				if(a[i]<a[i-1]) dp[i][j]=f[i-1][j-1];//当小于前一个的时候一定比前一个后删 
				if(a[i]>a[i-1]) dp[i][j]=((f[i-1][i-1]-f[i-1][j-1])%Mod+Mod)%Mod; //否则的话一定比前一个先删 
			}
			for(int j=1;j<=n;j++) {//对f求前缀和处理 方便维护 
				f[i][j]=(f[i][j-1]+dp[i][j])%Mod;
			}
		}
		cout<<f[n][n]<<'\n';
	}
}
int main() {
	cs::main();
	return 0;
}
~~~

---


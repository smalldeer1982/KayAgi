# [AGC059A] My Last ABC Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc059/tasks/agc059_a

文字 `A`, `B`, `C` のみからなる文字列 $ t $ を考えます。 これに対し、以下の操作を行えます。

- 任意の部分文字列 $ t[l:r] $ と文字 $ ( $`A`$ , $`B`$ , $`C`$ ) $ の任意の並べ替え $ (X,\ Y,\ Z) $ を選ぶ。ここで、$ t[l:r] $ は $ t $ の $ l $ 文字目から $ r $ 文字目までで形成される部分文字列であり、$ l $ と $ r $ を選べる。そして、$ t[l:r] $ の各文字 `A`, `B`, `C` をそれぞれ $ X $, $ Y $, $ Z $ で置き換える。
 
例えば、文字列 $ t\ = $ `ACBAAC` に対して、部分文字列 $ t[3:6] $ と $ (X,Y,Z)=( $`C`$ , $`B`$ , $`A`$ ) $ を選べます。 この操作を行うと、文字列は `ACBCCA` となります。

アリーナは、すべての文字が同じであるような文字列が好きです。彼女は、文字列 $ t $ の美しさを、そのすべての文字を同じにするために必要な最小の操作回数と定義します。

長さ $ N $ の文字 `A`, `B`, `C` のみからなる文字列 $ S $ が与えられます。 $ Q $ 個のクエリに答えてください。$ i $ 個目のクエリは以下の通りです。

- 整数 $ L_i $ と $ R_i $ が与えられるので、部分文字列 $ t=S[L_i:R_i] $ の美しさを求めよ。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 10^5 $
- $ S $ は文字 `A`, `B`, `C` のみからなる文字列である。
- $ 1\ \le\ Q\ \le\ 10^5 $
- $ 1\ \le\ L_i\ \le\ R_i\ \le\ N $
- 入力中のすべての数は整数である。
 
### Sample Explanation 1

一つ目のクエリでは、文字列は $ t\ = $ `CCC` であり、すでにすべての文字が同じです。答えは $ 0 $ となります。 二つ目のクエリでは、文字列は $ t\ = $ `BC` です。これは、部分文字列 $ t[2:2] $ と $ (X,Y,Z)=( $`A`$ , $`C`$ , $`B`$ ) $ を選ぶことで、一回の操作で `BB` に変えることができます。 三つ目のクエリでは、文字列は $ t\ = $ `ABC` です。これは、部分文字列 $ t[2:3] $ と $ (X,Y,Z)=( $`C`$ , $`A`$ , $`B`$ ) $ を選ぶことで、一回の操作で `AAB` に、続いて部分文字列 $ t[1:2] $ と $ (X,Y,Z)=( $`B`$ , $`A`$ , $`C`$ ) $ を選ぶことで、二回目の操作で `BBB` に変えることができます。

## 样例 #1

### 输入

```
6 4
ABCCCA
3 5
2 3
1 3
1 6```

### 输出

```
0
1
2
2```

# 题解

## 作者：Rainbow_qwq (赞：6)


首先一个串相邻相同的可以缩成一个字符，不影响答案，假设缩完有 $n$ 段。每次操作会使一些相邻段字符变得相同，可以看做段减少了。发现每次操作最多减少两个段，能不能达到这个上界？

考虑到有个题 [[Kubic] ABC](https://www.luogu.com.cn/problem/P7919)，那题的结论是每次都可以增加两个段，于是我就思考是不是每次都可以减少两个段。

经过一通手玩（也可以打表），发现 $n\ge 5$ 的时候都可以找到一种方式减少两个段，也就是 $n\to n-2$。

$n=4$ 的时候，发现每种情况 `ABAC` `ABAB` `ABCA` 都需要恰好两步。于是 $n$ 是偶数的情况解决。

$n=3$ 的时候，有 `ABA` `ABC` 两种，答案只和首尾是否相同有关，而中间的每一步都不会改变首尾。首尾相同为 1 步，不相同为两步。于是判断一下就好了。于是 $n$ 是奇数的情况解决。

[code](https://atcoder.jp/contests/agc059/submissions/37021156)

---

## 作者：enucai (赞：2)

## A - My Last ABC Problem

考虑给你一个串，怎么计算答案。

结论：一个串的最小操作步数为 $\lceil\dfrac{(\sum_{i=l}^{r-1}s_i\not=s_{i+1})+[s_l\not=s_r]}{2}\rceil$。

关注相邻两个字符不同的对数，我们发现一次操作最多能让这个对数 $-2$（操作段内的对数不变，两边的各 $-1$）。

注意开头与结尾也是相邻的，所以答案的下界就显而易见了。

操作时只要每次操作一个能让这样对数 $-2$ 的串即可。

提交记录：[link](https://atcoder.jp/contests/agc059/submissions/37025776)。

---

## 作者：Maverik (赞：1)


## statement
给出一个长度为 $N$ 的字符串 $S$，$S$ 仅含 `A,B,C`。每次操作选择 $l,r$ 和 $(X,Y,Z)$，$X,Y,Z $ 都是 `A,B,C` 其中之一，且互不相同。接着对于 $S_{[l,r]}$，将 `A` 变成 $X$，`B` 变成 $Y$，`C` 变成 $Z$。

$Q$ 组询问，每次询问 $L,R$，求将 $S_{[L,R]}$ 都变成同一字符的最小操作次数。$1\le N,Q \le 10^5$

## solution

对于操作序列 $a_{1\dots n}$，将其首尾相连，操作同等地对环进行即可。因为对于一个操作区间，对这个区间进行置换，等价于对区间外的字符进行逆置换。


设环的颜色段数为 $n$，显然一次操作减少颜色段数量上界为 $2$。

结论是：**除颜色段形如 $ABC$ 与 $AB$ 外，每次操作都能够减少两个颜色段。**

可以如下考虑此结论：

操作场景分为形如 $AB\dots AB$ 与 $AB\dots BA / ABA$ 两类考虑，发现通过一次操作可以分别变成 $AA\dots BB$ 与 $AA\dots AA/AAA$，均减少两个颜色段。

通过若干次此类操作，如果仍未同色，其一定变为 $ABC$ 或者 $AB$ 的形式，分别需要 $2$ 次与 $1$ 次减少一个颜色段的操作。

综上所述，最多会进行一次减少一个颜色段的操作。

因此对于询问 $l,r$，答案为 $\left\lceil\frac{\left(\sum_{i=l}^{r-1} s_{i} \neq s_{i+1}\right)+\left[s_{l} \neq s_{r}\right]}{2}\right\rceil$。




---

## 作者：ღꦿ࿐ (赞：1)

蜜蜂的解释是智慧的！

给出一个比较容易想到的解释方式。

首先把一个同颜色段缩成一个字母肯定不影响答案。

将某个串的所有位置变的相同就是 $a_1=a_2=a_3=\dots = a_n$。

最后有 $n-1$ 个相等的相邻位置，我们要改变所有相邻的不相同位置。

让相邻的 $\texttt{AB}$ 为 \( ， $\texttt{BA}$ 为 \) 

让相邻的 $\texttt{AC}$ 为 \[， $\texttt{CA}$ 为 \] 

让相邻的 $\texttt{BC}$ 为 \{， $\texttt{CB}$ 为 \} 

那么 ABCCBC 可以看作 ( { } { 。

那每次都可以消掉两个对应（左右或右左）的括号消去，即将二者中间那段的字母进行变换， $\texttt{AB\{CC\}BC}$      使  $\texttt C\to\texttt B$。

这样无论如何都不会改变开头的和结尾的字母。 

这样总是可以消去到只剩三个括号（四段字母）。

若剩下四段，则把不同的两个改成出现多的那种即可。

若剩下三段，若首尾相同则只需要一次，否则需要两次。

若剩下两段，只需要一次。

若剩下一段，不需要。

综上所述，答案为 $\lceil \frac{d + [a_l\neq a_r]}{2}\rceil$。

蜜蜂的神秘解释：

可以看作一个环状序列，这样无论如何每次都能减少 2 个不同位置（如有）。

所以答案就是上述。

拿个前缀和算下段数就行了，时间复杂度 $O(n+q)$。



```cpp
read(n , q);
read(S + 1) ;
cnt[1] = 1 ; 
rep(i,2,n) {
    cnt[i] = cnt[i - 1] + (S[i] != S[i - 1]) ;
}
while(q --) {
    static int l , r; 
    read(l , r);
    static int dif ; 
    dif = cnt[r] - cnt[l - 1] - (S[l] != S[l - 1]) ; 
    wrt(S[l] == S[r] ? (dif + 1) / 2 : dif / 2 + 1 , '\n') ; 
}

```


---

## 作者：_Flame_ (赞：0)

### $\text{solution}$

聪明题。

首先可以发现，给定的区间 $[l,r]$ 内相同字符一定同时变化，不影响结果，所以我们把每一段相邻且相同的字符缩成一个，使得相邻字符不等。

考虑将缩完的串划分成小段并将每一段变为同一字符。

- 小段长度为 $3$，发现只有两种，手玩可知，形如 `ABA` 的需要一次变换，形如 `ABC` 的需要两次变换。
- 小段长度为 $4$，发现形如 `ABAB`，`ABAC`，`ABCA` 的三种情况都需要两次变换。
- 小段长度 $\ge 5$，这种情况一定可以通过上面两种情况消除为长度为 $3$ 或 $4$ 的。

每次缩完的串长度会减少 $2$，分类讨论最后的情况即可。

---


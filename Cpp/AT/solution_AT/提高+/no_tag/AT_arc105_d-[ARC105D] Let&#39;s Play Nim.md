# [ARC105D] Let&#39;s Play Nim

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc105/tasks/arc105_d

$ 1 $ から $ N $ の番号がついた $ N $ 枚の袋と、$ 1 $ から $ N $ の番号がついた $ N $ 枚の皿があります。 袋 $ i $ には $ a_i $ 個のコインが入っています。どの皿もはじめは何も乗っていません。

先手太郎君と後手次郎君が対戦ゲームをします。 先手太郎君と後手次郎君の手番が交互に訪れます。先手太郎君が先手です。 それぞれのプレイヤーは、手番において以下の $ 2 $ つの手のどちらかを打つことが可能です。

1. (コインが入った袋が $ 1 $ つ以上存在するとき)：コインが入った袋と皿を $ 1 $ 枚ずつ選び、選んだ袋の中に入った全てのコインを選んだ皿に移す(選ぶ皿にはコインが乗っていてもいなくても構わない)
2. (コインが入った袋が存在しないとき)：コインが乗った皿を $ 1 $ 枚選び、選んだ皿から $ 1 $ 枚以上のコインを取り除く

先に手が打てなくなった人の負けです。$ 2 $ 人が最適に行動したときに勝つのはどちらかを判定してください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- 与えられる入力は全て整数
- $ 1\ \leq\ T\ \leq\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 10^{5} $
- $ 1\ \leq\ a_i\ \leq\ 10^9 $
- $ 1 $ つの入力ファイルにおいて、$ N $ の総和は $ 2\ \times\ 10^5 $ を超えない。

### Sample Explanation 1

\- テストケース $ 1 $ では後手次郎君が勝利します。以下はそのような $ 2 $ 人の行動の例です。 - 先手太郎君の手番では、袋 $ 1 $ を選んで皿 $ 1 $ にコインを移すしかできません。 - 後手次郎君の手番で皿 $ 1 $ を選んで全てのコインを取り除くことで、先手太郎君は手番で手を打つことができず敗北します。 - コインが入った袋が存在するとき、コインの入った袋を選んで皿に移す手しか打てないことに注意してください。 - 同様に、コインが入った袋が存在しないときは皿を選んでコインを $ 1 $ つ以上取り除く手しか打てないことに注意してください。

## 样例 #1

### 输入

```
3
1
10
2
1 2
21
476523737 103976339 266993 706803678 802362985 892644371 953855359 196462821 817301757 409460796 773943961 488763959 405483423 616934516 710762957 239829390 55474813 818352359 312280585 185800870 255245162```

### 输出

```
Second
First
Second```

# 题解

## 作者：jr_linys (赞：5)

[[ARC105D] Let&#39;s Play Nim](https://www.luogu.com.cn/problem/AT_arc105_d)

有题解提到，若有数字出现次数为奇数，在第一阶段，$n$ 为奇数/偶数时，后手/先手**每次选取硬币数量最多的背包，将其中的硬币放至硬币数量最多的盘子上**，可以使他作为先手进入第二阶段时所有的盘子的硬币个数异或和不为 $0$。  
对此那些题解的解释为**一定存在一个盘子使得其之上的硬币数量一定大于其余任何一个盘子**，所以必胜。

这个解释不太正确，我在此详细解释。

操作的结果应该更为：**一定存在一个盘子使得其之上的硬币数量严格大于总硬币数的一半**。   
按如上进行操作，令最大的硬币堆个数为 $a$，其余的硬币个数为$b$，显然有 $a>b$。

将 $a,b$ 转换为二进制。  
若两者最高位不相同，$b$ 怎么分都消不掉 $a$ 的最高位。  
若两者最高位相同，那么两边消掉最高位，重复此操作直到两者最高位不相同。
- - -
然后题解区中 @C_liar 的通过合并操作控制异或和和 @fish_love_cat 的“易证”的题解的证明不太对。

---

## 作者：User_Unauthorized (赞：4)

## 题意

给定 $N$ 个背包，其中第 $i$ 个背包中有 $a_i$ 个石子。同时还有 $N$ 个盘子，初始时盘子中没有石子。

两人轮流执行下列操作：

- 若存在背包中还有石子，选择一个非空背包和盘子，将背包中的石子放入盘子中，注意这里对盘子没有要求；
- 若不存在背包中还有石子，选择一个非空盘子，将盘子中的石子至少取走一个，至多取完该盘子中的全部石子。

最后无法进行操作的人判负。

当两人采取最优策略时，求先手必胜还是后手必胜。

- $1 \le T \le 10^5$
- $1 \le N \le 10^5$
- $1 \le a_i \le 10^9$
- $\sum N \le 10^5$

## 题解

首先可以发现这个游戏可以划分为两个阶段：

- 阶段一：所有背包中的石子都被取完；
- 阶段二：所有盘子中的石子都被取完。

后者是 $\tt{Nim}$ 和游戏，我们有结论：

> 设 $x_i$ 表示第 $i$ 个盘子上的石子数量，那么这个游戏的先手必胜当且仅当 $\bigoplus x_i \neq 0$，其中 $\bigoplus x_i$ 表示 $x_1 \oplus x_2 \oplus \cdots \oplus x_N$。

发现第二部分的先手与 $N$ 的奇偶性有关，因此我们可以按 $N$ 的奇偶性分类讨论。

- 若 $N$ 为奇数，那么后手的目标是使得 $\bigoplus x_i \neq 0$，发现其可以执行如下操作：
    > 每次选取石子数量最多的背包，将其中的石子放至石子数量最多的盘子上。

    可以发现在流程结束后中，一定存在一个盘子使得其之上的石子数量一定大于其余任何一个盘子，因此后手可以保证 $\bigoplus x_i \neq 0$，使得先手必败。

- 若 $N$ 为奇数，那么后手的目标是使得 $\bigoplus x_i =0$，发现若对于每个 $n$，均有 $\sum\limits_{i = 1}^{N}\left[a_i = n\right]$ 为偶数，即 $a_i$ 按值成对出现，那么后手只需要模仿先手的操作便可以使得 $\bigoplus x_i =0$。反之先手可以通过执行如下操作取得胜利：
    > 每次选取石子数量最多的背包，将其中的石子放至石子数量最多的盘子上。

    可以发现在流程结束后中，一定存在一个盘子使得其之上的石子数量一定大于其余任何一个盘子，因此先手可以保证 $\bigoplus x_i \neq 0$，使得先手必胜。

时间复杂度为 $\mathcal{O}(N \log N)$，空间复杂度为 $\mathcal{O}(N)$，可以通过。

## Code

```cpp
#include <bits/stdc++.h>

typedef long long valueType;
typedef std::vector<valueType> ValueVector;

bool check(ValueVector A) {
    std::sort(A.begin(), A.end());

    if (A.size() & 1)
        return true;

    for (valueType i = 1; i < A.size(); i += 2)
        if (A[i] != A[i - 1])
            return false;

    return true;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    valueType T;

    std::cin >> T;

    for (int testcase = 0; testcase < T; ++testcase) {
        valueType N;

        std::cin >> N;

        ValueVector A(N);

        for (auto &iter : A)
            std::cin >> iter;

        std::cout << (check(A) ? "Second" : "First") << std::endl;
    }

    return 0;
}
```

---

## 作者：C_liar (赞：4)

## 前言

一场未公开比赛的 T1，有幸在考场上做出来，发一篇题解。

[[ARC105D] Let&#39;s Play Nim](https://www.luogu.com.cn/problem/AT_arc105_d)

## 题解

博弈论的题目一般要求思维比较灵活，如果实在想不出来，最朴素的方法就是...

### 打表！

打表找规律对解决问题有很大的帮助！

按照题意，若还有背包有硬币，那么选择一个背包，将背包中的硬币倒入盘子里，否则选择一个盘子，至少取走一个硬币。

发现在将所有背包的硬币倒入盘子里后，就是一个简单的 Nim 博弈，直接求异或和即可。

那如何确定背包里的硬币放入哪个盘子里呢？

一个很显然的思路就是，可以直接枚举每个背包的硬币放入哪个盘子里，然后根据 $\operatorname{SG}(x)=\operatorname{mex}(S)$ 求出当前状态 $x$ 的 SG 函数值，若 $\operatorname{SG}(x)=0$，当且仅当 $x$ 为必败状态。

若没有背包有硬币，直接返回盘子中硬币的异或和即可。

根据这个思路，可以得出以下打表程序：

```cpp
// n 为背包个数，a 为背包，b 为盘子，player 为当前的玩家
int SG(int n,vector<int> a,vector<int> b,int player){
	int Ans=0;
	for(int i=0;i<n;i++) if(a[i]!=0) goto Start;
	for(int i=0;i<n;i++) Ans^=b[i];
	// 若还有背包有硬币，枚举硬币放哪个盘子，否则返回盘子中硬币的异或和。
	return Ans;
	Start:{}
	bool c[50];// 标记后继状态中已出现的 SG 函数值
	memset(c,0,sizeof c);
	for(int i=0;i<n;i++){// 枚举有硬币的背包
		if(!a[i]) continue;
		for(int j=0,tmp;j<n;j++){// 枚举放在哪个盘子里
			tmp=a[i];
			b[j]+=tmp;
			a[i]=0;
			c[SG(n,a,b,player^1)]=1;
			a[i]=tmp;
			b[j]-=tmp;
		}
	}
	for(int i=0;i<50;i++) if(!c[i]) return i;
	// 返回 mex 值。
	return 50;
}
```

然后枚举 $n$，枚举每个 $a_i$ 即可。

在枚举过程中，发现背包的顺序对结果没有关系，所以假设 $\forall i\in[1,n-1],\ a_i\leq a_{i+1}$。

经过一番操作，我们得到了以下结果：

[n=1,n=2,n=3 时](https://www.luogu.com.cn/paste/nmnv1pp4)

下面两个文件较大，可能造成浏览器崩溃等问题，请慎重打开。

[n=4 时](https://www.luogu.com.cn/paste/y4812uzt)

[n=5 时（部分）](https://www.luogu.com.cn/paste/7fum0put)

通过打表，我们发现，在 $n$ 为奇数时，SG 函数值总为零，即所有状态都为必败状态。

而在 $n=2$ 时，只有 $a_1=a_2$ 的状态的 SG 函数值为 $0$，其他情况 SG 函数值均为 $1$。

这引发了一个猜想，当 $n$ 为偶数时，只有当 $a_i$ 的异或和为 $0$ 时，先手必败。

但是，通过 $n=4$ 的数据，我们发现存在反例：

```cpp
a[1]=6,a[2]=7,a[3]=8,a[4]=9.
```

对于这组数据，$a_i$ 的异或和为 $0$，但是 SG 函数值为 $1$。

而在对 $n=4$ 的数据进一步观察后，发现以下数据的 SG 函数值均为 $0$：

```cpp
1 1 1 1
1 1 2 2
1 1 3 3
...
2 2 2 2
2 2 3 3
2 2 4 4
...
3 3 3 3
3 3 4 4
3 3 5 5
...
9 9 9 9
```

其余数据的 SG 函数值均为 $1$。

即如果存在某个数，出现的次数为奇数，先手必胜，否则所有数出现的次数为偶数，先手必败。

其实，我们打表发现的规律就是正确答案，已经可以 AC 本题了。

但为什么这样是正确的呢？

### 解释

将 $n$ 分奇偶来考虑。

当 $n$ 为奇数时，在背包里还有硬币的时候，两人轮流将背包里的硬币倒入盘子，发现在倒完硬币后，一定是后手先从盘子里取硬币。

那如果每个盘子中硬币的异或和不为零，后手必胜。

那是否一定存在一种操作方式，使得盘子中硬币的异或和不为零呢？

对于 $n=1$ 的情况，一定存在（因为 $a_i\geq 1$）。

对于 $n\geq 3$ 且 $n$ 为奇数的情况，因为如果一个状态，硬币的异或和为 $0$，那说明硬币数的每一个二进制位都有偶数个，那后手在操作的过程中，由于可以倒入有硬币的盘子，所以在合并的过程中，一定会有进位，就可以避免异或和为 $0$ 的情况出现。

所以 $n$ 为奇数时，先手必败。

当 $n$ 为偶数时，一定是先手先从盘子里取硬币。

那对于后手，什么情况下使得先手必败呢？

发现当所有数字出现的次数都为偶数次时，后手完全可以模仿先手的行为。

先手每选一个背包，后手也选硬币相同个数的背包；先手倒入空盘子，后手也倒入空盘子；先手倒入有 $a_i$ 个硬币的盘子，后手也倒入有 $a_i$ 个硬币的盘子。

这样操作，可以保证最后的局面下，盘子内硬币的异或和为 $0$，由于一定是先手先取硬币，所有先手必败。

那如果存在某个数字出现的次数为奇数次呢？

这样下来，先手操作的时候，后手无法使操作对称，先手一定可以通过合并操作使得盘子内硬币的异或和不为 $0$，所以先手必胜。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<map>
typedef long long ll;
const int _=1e5+10;
using namespace std;

int a[_];

int main(){
	int t;scanf("%d",&t);
	while(t--){
		int n;scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		sort(a+1,a+1+n);
		map<int,int> mp;
		if(n&1){
			puts("Second");
			continue;
		}
		for(int i=1;i<=n;i++){
			mp[a[i]]++;
		}
		for(auto it=mp.begin();it!=mp.end();it++){
			if(it->second&1){
				puts("First");
				goto lab;
			}
		}
		puts("Second");
		lab:{}
	}
	return 0;
}
```

---

## 作者：shinkuu (赞：1)

其实证明很简单吧……

考虑构造。如果 $n$ 为偶数，先手每次选最大的，丢到一起，记选择的序列为 $A$，后手选的为 $B$，则 $\sum A_i\ge\sum B_i$，又 $x\oplus y\le x+y$，则不管后手怎么选，他选的那一部分 $\oplus$ 和都 $\le\sum A_i$，取等当且仅当 $a$ 中的数可以两两配对，每对内相等。能取等后手胜，否则先手。

如果 $n$ 为奇数，则类似的，先手不管选什么数，后手每次选当前最大加入先手第一次放的那一堆，则一定有这一堆的和大于其它的所有数之和。所以后手必胜。

---

## 作者：fish_love_cat (赞：1)

这游戏有两个部分，其中背包取完后的那个部分是原版的 Nim 游戏，结论是当数列的异或和非 $0$，先手必胜，否则后手必胜。而这部分的胜负，也就是整盘游戏的胜负又要看前半部分。

在前半部分中，当 $n$ 是奇数，那么原先的后手一定是以先手的姿态进入后半段的。而原先的数列加上玩家倒进去的数量，异或和一定有办法不为零。所以当 $n$ 是奇数时，后手必胜。

当 $n$ 是偶数时，那么原先的先手还是先手进入后半段的。这时后手想胜的唯一方法只有模仿先手。那么此时只要有数字出现奇数次，后手会因为无法模仿而~~暴毙~~输掉比赛。不然后手胜。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
map<int,int> mapp;
int a[100005];
signed main(){
	int t;cin>>t;
	while(t--){
		int n;cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		sort(a+1,a+1+n);
		if(n%2) puts("Second");
		else{
		    bool f=false;
	        mapp.clear();
    		for(int i=1;i<=n;i++) mapp[a[i]]++;
    		for(auto i=mapp.begin();i!=mapp.end();i++)
			if(i->second%2){f=true;break;}
    		puts((f?"First":"Second"));
		}
	}
	return 0;
}//awa
```

---

## 作者：Crazyouth (赞：1)

## 分析

注意到本题在放完盘子之后就是一个简单的 Nim 问题，所以考虑每个背包会放到哪个盘子。由于放完盘后谁执先手与 $n$ 的奇偶性有关，于是分类讨论。

如果 $n$ 是奇数，放完后后手先取硬币，他肯定会尽量让异或和不为 $0$（Nim 的玩法），那么他有一个必胜策略：不管先手取哪个背包，他先取走剩余的背包里硬币最多的，然后放到先手放的盘子里，接下来每次取剩余的背包里硬币最多的，这样初始时先手放的背包必定至少比其它的盘子在二进制下多出一位（因为每次都有进位），所以异或和一定不是 $0$。综上，$n$ 为奇数是后手必胜。

如果 $n$ 是偶数，放完后先手先取硬币，那么后手肯定会尽量让异或和为 $0$，一种可行的策略是，先手干什么他就干什么，先手找了一个 $a_i$ 个硬币的背包，他也找一个，先手把硬币放到了有 $b_i$ 个的盘子里，后手也放到有 $b_i$ 个的盘子里（$b_i$ 可以为 $0$）。当然，这是建立在每个 $a_i$ 都出现偶数次的情况，此时后手必胜。反之，如果存在 $a_i$ 出现奇数次，那么先手就可以把那个出现奇数次的 $a_i$ 放到当时 $b_i$ 最大的盘子里，然后就会出现上一段提到的情况，这个盘子必定比其它盘子多出至少一位，则异或和必定不是 $0$，故先手必胜。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
map<int,int> mp;
int a[100010];
void solve()
{
	mp.clear();
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		mp[a[i]]++;
	}
	if(n%2)
	{
		cout<<"Second"<<endl;
		return;
	}
	for(int i=1;i<=n;i++)
	{
		if(mp[a[i]]%2)
		{
			cout<<"First"<<endl;
			return;
		}
	}
	cout<<"Second"<<endl; 
}
signed main()
{
	int t;
	cin>>t;
	while(t--)
	solve();
	return 0;
} 

---

## 作者：xukehg (赞：0)

神题。

考虑 Nim 游戏先手赢的概率比后手大得多，我们猜测在正常情况下，长度为偶数先手赢，奇数后手赢。~~然后喜提一发罚时。~~

我们尝试去推测长度为奇数时先手如何取胜。考虑这样一个策略：先手每次都将最大值取出来，放在第一个盘子中。如果这个盘子大于总和的一半，因为如果异或和为 $0$，每个含 $1$ 的位都应被消去，此时后手取出来的数的总和要大于等于先手，与前面假设矛盾。由于先手取出的数一定大于等于下一次后手取出来的数，因此后手取的数至多与先手相等。此时意味着先后手取出的数一一对应。显然，后手只要模仿先手，就能获胜。

此时奇数的策略也明了：无论先手第一步如何取，后手只要在有数的盘子上模拟上面的策略即可。因为权值均正，因此此时后手必胜。

[记录。](https://atcoder.jp/contests/arc105/submissions/61722725)

---


# [ARC122D] XOR Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc122/tasks/arc122_d

黒板に $ 2N $ 個の整数が書かれており，そのうち $ i $ 番目の整数は $ A_i $ です．

Alice と Bob がゲームをします． ゲームは $ N $ ラウンドにわたって行われ，各ラウンドでは以下の操作を行います．

- まず，Alice が黒板に書かれている整数を一つ選び，消す． ここで選ばれた整数を $ x $ とする．
- 次に，Bob が黒板に書かれている整数を一つ選び，消す． ここで選ばれた整数を $ y $ とする．
- $ x\ \oplus\ y $ の値をノートに記録する．ただしここで $ \oplus $ はビットごとの排他的論理和を表す．

最終的に，黒板からは全ての整数が消え去り，ノートには $ N $ 個の整数が記録されます． ゲームのスコアは，ノートに記録された整数の最大値です． Alice の目標はスコアを最大化することで，Bob の目標はスコアを最小化することです． 両者が最適に行動した場合，ゲームのスコアがいくつになるか求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ <\ 2^{30} $
- 入力される値はすべて整数である

### Sample Explanation 1

例えば，以下のようなゲームの進行が考えられます．なお，この進行が最適な手順であるとは限りません． - ラウンド $ 1 $: - Alice が $ A_1=0 $ を選択する． - Bob が $ A_3=3 $ を選択する． - ノートに $ 0\ \oplus\ 3=3 $ が記録される． - ラウンド $ 2 $: - Alice が $ A_4=5 $ を選択する． - Bob が $ A_2=1 $ を選択する． - ノートに $ 5\ \oplus\ 1=4 $ が記録される． - ゲームのスコアが $ \max(3,4)=4 $ になる．

## 样例 #1

### 输入

```
2
0 1 3 5```

### 输出

```
4```

## 样例 #2

### 输入

```
2
0 0 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
10
974654030 99760550 750234695 255777344 907989127 917878091 818948631 690392797 579845317 549202360 511962375 203530861 491981716 64663831 561104719 541423175 301832976 252317904 471905694 350223945```

### 输出

```
268507123```

# 题解

## 作者：EuphoricStar (赞：5)

从高到低按位考虑。

设当前位有 $k$ 个 $1$。

- 如果 $k \bmod 2 = 0$，这意味着 Alice 如果选了一个数，Bob 可以选相同的数。发现可以分成 $(0,0),(1,1)$ 两组，递归下去即可。
- 如果 $k \bmod 2 = 1$，意味着答案这一位一定是 $1$（因为无论如何都不能消除贡献）。此时 Bob 可以做到有且仅有一对数异或和在这一位是 $1$，于是我们需要查两两异或和最小值，这个随便 01Trie 做一下即可。

递归复杂度 $O(n \log V)$，01Trie 复杂度 $O(n \log V)$，总时间复杂度 $O(n \log V)$。

[code](https://atcoder.jp/contests/arc122/submissions/41102019)

---

## 作者：wjh213 (赞：4)

因为在 Alice 选择任意一个数后，Bob 总能选出他想与 Alice 选的数匹配的数，那么 Alice 无论选哪个数都不会影响到最终的结果。所以这道题实质是希望我们将 $2n$ 个数每两两为一组，求出如何分组才能让所有组分别异或后的最大值最小。

对于涉及到异或的问题，可以尝试使用 01-Trie 去解决。

为了让最大值最小，我们可以尝试将所有数二进制分解，从最高位向最低位进行贪心，使高位尽可能为 $0$。

我们发现如果所有数在某一位上 $0$ 的个数和 $1$ 的个数都是偶数（显然只能两个同时是偶数或者同时是奇数），那么这一位一定可以被消掉，所以可以将原集合 $S$ 按照这一位是 $0/1$ 将原集合划分为 $S_0/S_1$，分别递归进入下一位解决。也就是假如我们设现在是第 $k$ 位，设 $f(S,k)$ 可以求出 $S$ 集合两两匹配最小值，那么

$$
f(S,k)=\max(f(S_0,k-1),f(S_1,k-1))
$$

边界条件为当 $S$ 为空集或者 $k< 0$ 时返回 $0$。

如果所有数在某一位上 $0$ 的个数和 $1$ 的个数都是奇数，我们可以找到一个该位是 $0$ 的数和该位是 $1$ 的数，把它们分到一组，求出异或后答案，而剩余的数通过类似上面的方法一定可以通过异或消掉这一位。也就是说我们单独选出来的这一组一定是异或最大值，则我们不需要继续往下递归，只需要想办法让我们从 $S_0$ 和 $S_1$ 中分别挑出来的数异或后的值尽可能小。

这可以简单的通过 01-Trie 解决，我们将 $S_0$ 的所有元素加入 Trie 中，遍历 $S_1$ 贪心在 Trie 中从高位往低位寻找即可。

由于一个元素在整个过程中总共只会被加入 Trie 一次（因为不需要继续向下递归），所以使用 Trie 的复杂度为 $O(n\log{a_{max}})$，递归一共有 $\log {a_{max}}$ 层，则递归复杂度为 $O(n\log{a_{max}})$，总复杂度为 $O(n\log{a_{max}})$。

```c++
#include<bits/stdc++.h>
using namespace std;
int const INF=0x7fffffff;
bool st;
struct trie{
	int T[(int)7e6][2],cnt=0;
	void init(){
		for(int i=0;i<=cnt;i++){
			T[i][0]=T[i][1]=0;
		}
		cnt=0;
	}
	void add(int tp,int dep=29,int ind=0){
		if(dep<0)return;
		if((1<<dep)&tp){
			if(!T[ind][1])T[ind][1]=++cnt;
			add(tp,dep-1,T[ind][1]);
		}else{
			if(!T[ind][0])T[ind][0]=++cnt;
			add(tp,dep-1,T[ind][0]);
		}
		return;
	}
	int find(int tp,int dep=29,int ind=0){
		if(dep<0)return 0;
		int nxt=(1<<dep)&tp?1:0;
		if(T[ind][nxt]){
			return find(tp,dep-1,T[ind][nxt]);
		}else{
			return find(tp,dep-1,T[ind][1^nxt])+(1<<dep);
		}
	}
}T;
int solve(vector<int> V,int dep){
	if(dep<0||V.empty())return 0;
	vector<int> V0,V1;
	for(auto it:V){
		if((1<<dep)&it){
			V1.push_back(it);
		}else V0.push_back(it);
	}
	if(V1.size()%2==0){
		int ans=max(solve(V0,dep-1),solve(V1,dep-1));
		return ans;
	}
	T.init();
	for(auto it:V0){
		T.add(it);
	}
	int ans=INF;
	for(auto it:V1){
		ans=min(ans,T.find(it));
	}
	return ans;
}
bool ed;
signed main(){
	cerr<<(&ed-&st)/1024.0/1024.0;
	int n;
	cin>>n;
	vector<int> V;
	for(int i=1;i<=2*n;i++){
		int tp;
		cin>>tp;
		V.push_back(tp);
	}
	cout<<solve(V,29);
	return 0;
}
```

---

## 作者：Mirasycle (赞：2)

最大/小化异或值，显然是从高到低位贪心考虑，而不是按照博弈顺序进行考虑。

其实 Bob 占据绝对主动的，也就是应该是 Bob 在游戏开始前就会想好，Alice 每次出哪个数，他就会拿哪个数来应对。

假设从高到低考虑到了第 $z$ 位。思考什么时候这一位 Bob 可以做到 $0$。如果这一位有偶数个 $1$，那么 Bob 是可以做到为 $1$ 的，因为所有有 $1$ 的数可以两两配对。如果有奇数个 $1$，那么是可以做到为 $1$ 的。

下面我们需要确定后面的位，对于第一种情况，如果 Alice 选 $1$，那么 Bob 选 $1$。如果 Alice 选 $0$，Bob 也应该跟着选 $0$。于是此时根据这一位是 $0$ 还是 $1$，分裂成两个集合，后续的操作只能在集合内部进行，对于两个结果应该取 $\max$，因为 Alice 可以选择到 $1$ 集合还是 $0$ 集合。

对于第二种情况，Alice 的策略已经确定，就是选一个当前位带 $1$ 的数，而且在所有一对数中也只有 Bob 选 $0$ 才可能产生最终贡献，所以 Bob 要在 $0$ 集合中选择一个数使得和 $1$ 集合中的数异或的最小值最小，直接字典树即可。

时间复杂度 $O(n\log n)$。

---

## 作者：WeWantToRun (赞：1)

不难证明答案等于两两分组之后每一组异或和 max 的最小值，因为 bob 一定可以选和 alice 同组的。

按位考虑，如果最高位有偶数个 $1$，那这一位就没东西，递归下去做。否则字典树维护一下两个集合各出一个数异或最小值即可。时间复杂度 $O(n\log V)$，因为每个数只会进出一次字典树。

[submission](https://atcoder.jp/contests/arc122/submissions/57123500)

---

## 作者：InoueTakina (赞：0)

由于 Alice 的选择是极其被动的，而且 $x\oplus y=y\oplus x$，因此原问题和博弈没啥关系，本质上就是两两配对，使得两两按位异或的最大值最小。

注意到最终的分数是所有记录在笔记本上的分数的最大值，因此这个问题是满足按位贪心的，因此我们逐位考虑。

若当前考虑到了第 $k$ 位，则可以分两种情况考虑：

- 这一位上的异或和为 $0$，那么一定可以找到某一种配对方案，使得 $x\oplus y$ 在这一位上总是 $0$。具体的，要按 $0-0$ 和 $1-1$ 配对，因此原本的数被划分为两个集合，且只能集合内部配对，这相当于一个子问题。
- 否则，这一位上必然会有一个 $1$，且容易构造一种办法使得只有一对数的异或在这一位上是 $1$，而剩下的数字再递归下去是没有意义的，而找到这一对数可以用 trie 维护。



---


# [ARC141C] Bracket and Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc141/tasks/arc141_c

長さ $ 2N $ の文字列 $ S=S_1S_2\dots\ S_{2N} $ について、 $ S $ が $ N $ 個の `(` , および $ N $ 個の `)` で構成されるとき、 $ S $ は「括弧列」であるといいます。

また、「括弧列」$ S $ のうち、以下のいずれかに該当するものを「正しい括弧列」といいます。

- 空文字列
- ある「正しい括弧列」$ A $ が存在して `(`, $ A $, `)` をこの順に連結した文字列
- ある空でない「正しい括弧列」$ A,\ B $ が存在して、 $ A,\ B $ をこの順に連結した文字列

$ 1 $ から $ 2N $ までの整数からなる $ 2 $ つの順列 $ P=(P_1,\ P_2,\ \dots,\ P_{2N}),\ Q=(Q_1,\ Q_2,\ \dots,\ Q_{2N}) $ が与えられます。

以下の条件を満たすような「括弧列」$ S=S_1S_2\dots\ S_{2N} $ が存在するか判定してください。

- $ S_{p_1}S_{p_2}\dots\ S_{p_{2N}} $ が「正しい括弧列」となるような $ 1 $ から $ 2N $ までの整数の順列 $ p $ のうち、辞書式順序で最小のものが $ P $
- $ S_{p_1}S_{p_2}\dots\ S_{p_{2N}} $ が「正しい括弧列」となるような $ 1 $ から $ 2N $ までの整数の順列 $ p $ のうち、辞書式順序で最大のものが $ Q $

存在する場合は $ 1 $ つ求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ P_i,Q_i\ \leq\ 2N $
- $ P,\ Q $ はそれぞれ $ 1 $ から $ 2N $ までの整数の順列
- 入力される値はすべて整数

### Sample Explanation 1

$ S= $ `())(` のとき、$ S_{p_1}S_{p_2}S_{p_3}S_{p_4} $ が「正しい括弧列」となる $ p $ は $ p=(1,\ 4,\ 2,\ 3),\ (1,\ 4,\ 3,\ 2) $ などが考えられますが、このうち辞書式順序で最小のものは $ p=(1,\ 2,\ 4,\ 3) $ 、最大のものは $ p=(4,\ 3,\ 1,\ 2) $ であり、 $ S $ は条件を満たします。

### Sample Explanation 2

条件を満たす $ S $ は存在しません。

## 样例 #1

### 输入

```
2
1 2 4 3
4 3 1 2```

### 输出

```
())(```

## 样例 #2

### 输入

```
2
1 3 2 4
4 3 2 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3
2 1 5 3 4 6
6 5 3 4 2 1```

### 输出

```
-1```

# 题解

## 作者：Feyn (赞：6)

很好的一道题。

首先对原括号序列画折线图，具体方法就是如果是左括号就往上走，否则就往下走。试想，如果整根线一直都在水平线上方，那么一定存在一个序列 $1,2\dots n$ 是合法的，也就是说此时数组 $p$ 也一定等于这个值。

然而事实不总是这样的，这是因为折线图还有低于水平线的部分，对于这部分容易想到在此之中左右括号数量相等（这样才能刚好升到水平线上），所以策略是找第一个左括号然后找第一个右括号，交替进行直到把折线又拉回到水平线上为止。

所以我们得到了一个非常重要的结论，如果 $p_{2i}<p_{2i-1}$ 的话，那么 $p_{2i}$ 对应的位置应该是左括号，$p_{2i-1}$ 对应的位置应该是右括号。同理，会发现数组 $q$ 决定的是水平线以上的部分，两个部分合并起来应该就是完整的数组，所以如果看到重合或者未覆盖的地方就说明不存在合法解。最后求出答案之后验证一次就可以了。

复杂度可以做到线性。

---

## 作者：EuphoricStar (赞：4)

考虑给出 $S$，如何求 $P, Q$。先考虑 $P$，那我们肯定想让 $P$ 的每一项都尽量往前靠。设 $[1, k]$ 为合法括号串，$S_{k + 1} = \texttt{)}$，那 $P$ 的前 $k$ 项依次为 $1 \sim k$，第 $k + 1$ 项不能为 $k + 1$ 了，那找到 $k + 1$ 之后的第一个左括号，设其位置为 $p$，那 $P_{k + 1} = p, P_{k + 2} = k + 1$。一直如此直到某个时刻，前缀左括号数和右括号数相等，并且下一个字符是左括号，那就回到了一开始的情况，从这个左括号往后填。这样可以求出 $P$，求 $Q$ 类似地可以从后往前就变成了求 $P$。

考虑画出折线图，那可以发现，$x = 0$ 上方部分可以依次填不需要改动顺序，$x = 0$ 下方就先找到从左往右第一个之前没选过的左括号，和第一个之前没选过的右括号配对。

现在考虑原题，给出 $P, Q$，构造 $S$。先暂时不考虑无解情况。发现如果 $P_{2i - 1} < P_{2i}$，这一段一定在 $x = 0$ 上方；如果 $P_{2i - 1} > P_{2i}$，这一段一定在 $x = 0$ 下方，并且可以确定 $S_{2i - 1} = \texttt{(}, S_{2i} = \texttt{)}$。那我们可以确定，折线在 $x = 0$ 下方部分的 $S$ 了。这时候我们惊喜地发现，因为求 $Q$ 的过程是反过来的，所以可以类似地，根据 $Q_{2i - 1} < Q_{2i}$ 确定折线在 $x = 0$ 上方部分的 $S$。两个合在一起，我们发现 $S$ 可以被唯一确定！

但是你先别急，还没做完。因为我们发现有很多繁琐的无解情况需要特判。若 $S$ 还有没被确定的部分，就一定无解；否则可以根据 $S$ 求出 $P, Q$，验证是否和题目给出的 $P, Q$ 一致即可。

时间复杂度是优秀的 $O(n)$。

[code](https://atcoder.jp/contests/arc141/submissions/42237479)

-----

一定要多思考，不能怠惰啊。

---

## 作者：Xy_top (赞：1)

题解和我的做法完全不一样，这是我自己弄出来的一个做法。

首先来看样例：$P = 1,2,4,3$，观察第三个位置，为什么不能是 $3$ 呢？肯定是弄了 $3$ 之后就会不合法了对吧，什么情况下才会不合法呢？

如果第 $3$ 个是 ``'('`` 那么放到第三个位置一定是合法的吧？但如果第三个是 ``')'`` 呢？前面如果是 ``"()"``，你放个 ``')'`` 显然不行了吧。

由于 $P$ 是字典序最小的，所以能先放第 $3$ 个一定先放它，不会在第 $4$ 个后面放，而放在了第 $4$ 个后面恰好证明了 $3$ 是 ``')'`` 了吧？$4$ 如果也是 ``')'`` 放它和放第 $3$ 个没有区别了，所以第 $4$ 个一定是 ``'('``。

同理也能将 $Q$ 这样分。

还有一个点，来讲下，如若 $P$ 的前四个分别是 $1,2,100$，那么容易想到第 $3$ 个到第 $99$ 个一定都是 ``')'``，否则我就能先把它加进来，字典序一定小且合法。

但是程序只判了第 $3$ 个为 ``')'``，第 $99$ 个为 ``')'``，中间的万一漏了咋办？

答：显然不会漏，考虑剩余的构造情况。一定是找到后面的一个 ``'('``，然后把前面编号最小的且没有用过的 ``')'`` 拼在后面。

最后有个坑，还要判下用 $S$ 反构造出来的 $P$ $Q$ 是否和给的相同，反正你判了就对了。

```cpp
#include <queue>
#include <iostream>
using namespace std;
int n, mi, ma;
int p[400005], q[400005], ans[400005];
bool f[400005][2], c[400005][2];
char s[400005];
queue <int> que;
void finish () {
	cout << -1;
	exit (0);
}
int main () {
	cin >> n;
	for (int i = 1; i <= 2 * n; i ++) cin >> p[i];
	for (int i = 1; i <= 2 * n; i ++) cin >> q[i];
	mi = 1; ma = 2 * n;
	for (int i = 1; i <= 2 * n; i ++) {
		if (p[i] != mi) {
			c[p[i] ][0] = c[mi][1] = true;
			f[p[i] ][0] = true;
		} else {
			f[mi][0] = true;
			for (int i = mi + 1; i <= 2 * n; i ++) if (f[i][0] == false) {
				mi = i;
				break;
			}
		}
		if (q[i] != ma) {
			c[q[i] ][0] = c[ma][1] = true;
			f[q[i] ][1] = true;
		} else {
			f[ma][1] = true;
			for (int i = ma - 1; i >= 1; i --) if (f[i][1] == false) {
				ma = i;
				break;
			}
		}
	}
	for (int i = 1; i <= 2 * n; i ++) if (! (c[i][0] ^ c[i][1]) ) finish ();
	for (int i = 1; i <= 2 * n; i ++) s[i] = (c[i][0] ? '(' : ')');
	int k = 0, mi = 1, ma = 2 * n, cnt = 0;
	for (int i = 1; i <= 2 * n; i ++) {
		if (s[i] == '(') {
			ans[++ k] = i;
			++ cnt;
			if (!que.empty () ) {
				-- cnt;
				ans[++ k] = que.front ();
				que.pop ();
			}
		} else if (s[i] == ')') {
			if (cnt != 0) {
				-- cnt;
				ans[++ k] = i;
			} else que.push (i);
		}
	}
	k = 0;
	while (!que.empty () ) que.pop ();
	for (int i = 1; i <= 2 * n; i ++) if (ans[i] != p[i]) finish ();
	for (int i = 2 * n; i >= 1; i --) {
		if (s[i] == '(') {
			ans[++ k] = i;
			++ cnt;
			if (!que.empty () ) {
				-- cnt;
				ans[++ k] = que.front ();
				que.pop ();
			}
		} else if (s[i] == ')') {
			if (cnt != 0) {
				-- cnt;
				ans[++ k] = i;
			} else que.push (i);
		}
	}
	for (int i = 1; i <= 2 * n; i ++) if (ans[i] != q[i]) finish ();
	for (int i = 1; i <= 2 * n; i ++) cout << s[i];
	return 0;
}
```


---

## 作者：Rem_CandleFire (赞：0)

括号序列相关好题。

感性理解可以发现，如果括号序列是 `(((())))` 这种形式，排列 $P$ 就会一路从大到小排过去。也就是说，若 $P_{2i-1}>P_{2i}$，那么括号序列 $S$ 一定有 $S_{P_{2i-1}}=),S_{P_{2i}}=($。类似的，若 $Q_{2i-1}<Q_{2i}$，那么有 $S_{Q_{2i-1}}=(,S_{Q_{2i}}=)$。

这样子，我们就可以构造出括号序列 $S$，当构造时有冲突或构造后有不确定位置的情况时，输出 $-1$。

然而，我们考虑排列 $P=\{5,2,7,3,8,4,1,6\},Q=\{1,2,5,6,8,3,7,4\}$，根据上述规则可以得到 $S$ 为 `()))()((`。显然这个括号序列的最小和最大字典序排列不为给出的 $P,Q$。

所以，我们需要通过自己构造出的括号序列 $S$ 求出 $P,Q$ 然后和输入时得到的排列比对看是否一样，是则输出括号序列，否则输出 $-1$。

如何得到排列？很简单，若是左括号直接放置，然后匹配，右括号看是否需要匹配，不需要的话就加入队列。至于判断是否需要匹配，设左括号为 $1$，右括号为 $-1$ 对括号序列求前缀和即可。

代码易写：[Code](https://www.luogu.com.cn/paste/kc4wm9fj)，时间复杂度 $O(n)$。

---


# ドーナツの箱詰め

## 题目描述

须藤なつき小姐是一位负责甜甜圈装箱的店员。她现在有 $ K $ 个甜甜圈和 $ N $ 个箱子要进行装箱。每个箱子 $ i\ (1 \le i \le N) $ 的体积是 $ C_i $，且每个箱子只能装一个甜甜圈。

由于箱子的数量多于甜甜圈的数量，为了使用所有箱子，なつき决定通过把一些箱子放入其他更大的箱子中来使用所有箱子。每个箱子中必须放一个甜甜圈或一个比它体积小的箱子。如果将箱子 $ j $ 放到箱子 $ i $ 里，则需要在两个箱子之间放入体积为 $ C_{i} - C_{j} $ 的缓冲材料。请计算在所有箱子都得到合理利用的情况下，所需的缓冲材料总量的最小值。

此外，由于なつき在操作中可能会不小心压坏一些箱子。每当有箱子被压坏时，请计算使用剩余箱子进行装箱时���要的缓冲材料总量的最小值。なつき总共会压坏 $ Q $ 个箱子，第 $ i $ 个被压坏的箱子是 $ D_i $。

## 说明/提示

### 部分分

以下是题目的一些部分分提示：

- 当满足 $ Q = 0 $ 且 $ K = 2 $ 的数据集 1 正确时，可以获得 15 分。
- 当满足 $ Q = 0 $ 的数据集 2 正确时（与上述分数无关），可以获得 25 分。
- 当满足 $ K = 2 $ 的数据集 3 正确时（与上述分数无关），可以获得 30 分。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 4
1 9 3 7 4
0```

### 输出

```
1```

## 样例 #2

### 输入

```
4 2
6 5 10 2
2
3
1```

### 输出

```
4
1
0```

## 样例 #3

### 输入

```
7 3
2 12 3 13 7 17 1
4
4
3
1
6```

### 输出

```
7
6
6
5
0```

# 题解

## 作者：Terrible (赞：1)

## 题目翻译

須藤なつき是一家甜甜圈店的店员，负责将一个个甜甜圈装进盒子里。なつき现在要把 $K$ 个甜甜圈装进 $N$ 个盒子里。盒子 $i(1≦i≦N)$ 的容积为 $C_i$，每个盒子可以装 $1$ 个甜甜圈。

なつき想用完所有的盒子。但是，由于盒子的数量多于甜甜圈的数量，决定用盒子嵌套盒子的方法来用完盒子。在每个盒子里都恰好放上 $1$ 个甜甜圈或盒子。盒子 $i$ 里可以放比盒子 $i$ 体积小的盒子。另外，如果盒子里还有额外的盒子和甜甜圈，它们总体仍然算作 $1$ 个盒子。如果盒子 $j$ 放在盒子 $i$ 里面，则必须在盒子 $i$ 和盒子 $j$ 之间放置一定量的 $C_{i}-C_{j}$ 缓冲材料。在这种情况下，求所需缓冲材料数量总和的最小值。

另外，なつき非常笨拙，在装盒子过程中有时会压坏盒子。なつき每压碎一个盒子，都要求此时剩余的所有盒子包装所需的缓冲材料的最小量之和。なつき一共压碎了 $Q$ 个盒子，第 $i$ 次压碎的盒子是第 $D_i$ 个盒子。

**注**：なつき为假名，可能可以写作“夏树（なつき）”或“夏木（なつき）”等，但是原文没有给明该名字的汉字写法。

## 思路

盒子共有 $N$ 个，大小各不相同，每个甜甜圈对应 $1$ 个盒中盒（外面至少要有一层盒子，题目保证每个甜甜圈都能放进盒子里），有 $K$ 个甜甜圈则对应 $K$ 个盒中盒，要求用所有的 $N$ 个盒子组成 $K$ 个盒中盒，答案是所有盒子最外层盒子和最内层盒子容积之差总和的最小值。

将盒子按照容积大小排序得到 $C_1'<C_2'<C_3'<\cdots<C_N'$，那么答案最优的情况一定是每个盒中盒由容积大小相对连续的若干个盒子组成，相当于将 $C_1',C_2',C_3',\cdots,C_N'$ 划分成连续的 $K$ 个序列，每个序列对应一套盒中盒，答案就是这 $K$ 个序列的极差。因为如果划分不连续的话，意味着必然能够找到两个划分好的序列，其中两个序列最大值分别为 $C_{1\mathrm{max}},C_{2\mathrm{max}}$，最小值分别为 $C_{1\mathrm{min}},C_{2\mathrm{min}}$，能够满足 
$$C_{1\mathrm{min}}<C_{2\mathrm{max}}<C_{1\mathrm{max}}$$
那么将 $C_{2\mathrm{max}}$ 放到序列 $1$ 里（如果序列 $2$ 因此空了，那么将 $C_{1\mathrm{min}}$ 放到序列 $2$），答案一定更小，所以说最优方案的划分必然连续。

如果将 $C_1',C_2',C_3',\cdots,C_N'$ 看成数轴上从左到右的 $N$ 个点，那么 $[C_1',C_2'],[C_2',C_3'],\cdots,[C_{N-1}',C_N']$ 就是这些点之间的 $N-1$ 个小段，记小段的长度为 $d_i=C'_{i+1}-C'_i(1\leqslant i\leqslant N-1)$，要求将这 $N-1$ 个小段组成 $K$ 个连续的大段，求这 $K$ 个大段的总长度，意味着要从 $N-1$ 个小段中舍去其中的 $K-1$ 个小段，剩下的就是 $N-1-(K-1)=N-K$ 段（题目保证 $N-K\geqslant 0$）。多次操作会撤销若干 $C_i'$，只需要对每次询问求出最小的 $N-K$ 个 $d_i$ 的总和。

## 具体实现

记录 $C_i$，用数组即可，因为每次删除盒子用的是原来未经排序的编号；

记录 $C_i'$，用 `std::set`，查询、删除操作 $O(\log n)$；

记录 $d_i$，用两个权值树状数组，一个树状数组 `dcnt` 维护包含在 $[1,x]$ 的 $d_i$ 的个数，另一个树状数组 `dsum` 维护 $[1,x]$ 的 $d_i$ 总和，每次加的时候位置 $i$ 的值都是 $+i$ 或 $-i$，这样排名为 $N-K$ 的 $d_i$ 用二分就能求出来，然后再完成前 $N-K$ 小的 $d_i$ 求和即可，单次操作时间复杂度是 $O(\log^2w)$。

当然，查询操作可以使用平衡树来维护，这样单次操作的时间复杂度只有 $O(\log N)$，这里就不给实现了。

每次都会删除一个 $C_i$，如果 $C_i$ 在两边的话删除一个区间就好，如果 $C_i$ 在中间，那么删除两小段区间后还会产生一个更大的区间。

## 参考代码

```C++
#include<set>
#include<vector>
#include<iostream>
#include<atcoder/fenwicktree>
int main()
{
	std::ios::sync_with_stdio(0);std::cin.tie(0);
	int n,k;std::cin>>n>>k;
	std::vector<int> c(n+1);std::set<int> cset;
	//c 记录原来顺序的 C，顺序遍历 cset 结果是 C'
	for(int i=1;i<=n;i++)std::cin>>c[i],cset.insert(c[i]);
	atcoder::fenwick_tree<int> dcnt(200001);//个数
	atcoder::fenwick_tree<long long> dsum(200001);//总和
	auto it1=cset.begin(),it2=++cset.begin();
	for(int i=1;i<n;i++)
	{
		// *it2-*it1 是 d_i
		dcnt.add(*it2-*it1,1);
		dsum.add(*it2-*it1,*it2-*it1);
		it1=it2,++it2;
	}
	int sepcnt=n-k;//小段的总个数
	auto query=[&]()//单次询问
	{
		if(sepcnt==0)return 0ll;
		int l=1,r=200000;
		while(l!=r)
		{
			int mid=l+r>>1;//询问[l,mid]元素个数
			//AtCoder库里面.sum(l,r)是查询 [l,r) 范围内的和
			if(dcnt.sum(1,mid+1)>=sepcnt)r=mid;
			else l=mid+1;
			//找到第一个 cnt>=sepcnt 的位置 
		}
		int cnt=dcnt.sum(1,l+1);
		long long ans=dsum.sum(1,l+1);
		ans-=(cnt-sepcnt)*1ll*l;//多余的不要
		return ans;
	};
	std::cout<<query()<<'\n';//没有操作先询问一次
	int q;std::cin>>q;
	for(int i=1;i<=q;i++)
	{
		int d;std::cin>>d;int x=c[d];//找到被删除盒子的容量
		auto it=cset.find(x);
		if(it==cset.begin())//删头
		{
			auto itp=it;itp++;
			int diff=*itp-*it;
			dcnt.add(diff,-1);
			dsum.add(diff,-diff);
		}
		else if(it==--cset.end())//删尾
		{
			auto itm=it;itm--;
			int diff=*it-*itm;
			dcnt.add(diff,-1);
			dsum.add(diff,-diff);
		}
		else
		{
			auto itp=it,itm=it;itp++;itm--;
			int diff1=*itp-*it,diff2=*it-*itm;
			//删相邻的两端，会产生一个大段
			dcnt.add(diff1,-1);
			dcnt.add(diff2,-1);
			dcnt.add(diff1+diff2,1);
			dsum.add(diff1,-diff1);
			dsum.add(diff2,-diff2);
			dsum.add(diff1+diff2,diff1+diff2);
		}
		cset.erase(it);--sepcnt;
		//都维护好了，查询即可
		std::cout<<query()<<'\n';
	}
	return 0;
}
```

---


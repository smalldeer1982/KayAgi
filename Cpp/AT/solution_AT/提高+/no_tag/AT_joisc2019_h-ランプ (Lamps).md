# ランプ (Lamps)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joisc2019/tasks/joisc2019_h



# 题解

## 作者：DaiRuiChen007 (赞：16)

# JOISC2019H 题解

[Problem Link](https://www.luogu.com.cn/problem/AT_joisc2019_h)

**题目大意**

> 给定两个 01 串 $S,T$，每次操作可以对 $S$ 进行区间覆盖或区间取反，求 $S\to T$ 的最小操作次数。
>
> 数据范围：$n\le 10^6$。

**思路分析**

考虑观察解的形态：如果有一个取反操作在覆盖操作前面，显然可以通过调整把取反操作调整到覆盖操作后面。

而且显然取反操作区间不交，因此我们进行若干次覆盖得到 $S'$，取反操作就是 $S'\oplus T$ 的连续 $1$ 个数。

显然简单 dp 即可，$dp_{i,0/1/2}$ 表示处理前 $S_1\sim S_i$，然后记录 $S'_i$ 是 $0/1/S_i$ 即可 dp。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
int n,dp[MAXN][3]; //0:set 0,1:set 1,2:do nothing
char a[MAXN],b[MAXN];
signed main() {
	scanf("%d%s%s",&n,a+1,b+1);
	memset(dp,0x3f,sizeof(dp));
	dp[1][0]=1+(b[1]!='0');
	dp[1][1]=1+(b[1]!='1');
	dp[1][2]=(b[1]!=a[1]);
	for(int i=2;i<=n;++i) for(int x:{0,1,2}) for(int y:{0,1,2}) {
		int c=dp[i-1][x];
		if(y<2&&x!=y) ++c;
		char vx=(x==2?a[i-1]:x+'0'),vy=(y==2?a[i]:y+'0');
		if(b[i]!=vy&&b[i-1]==vx) ++c;
		dp[i][y]=min(dp[i][y],c);
	}
	printf("%d\n",min({dp[n][0],dp[n][1],dp[n][2]}));
	return 0;
}
```



---

## 作者：xyin (赞：15)

## 题目大意
给定 $01$ 串 $S$, $T$  ，每次操作可以对 $S$ 进行区间覆盖（~~覆盖为1或0~~）或区间取反，求把 $S$ 变为 $T$ 需要的最小操作数。
## 思路分析
观察题目性质，比较轻易能得到的是：取反操作的区间内部互不相交，覆盖操作的区间内部互不相交。

接下来就是考虑取反操作和覆盖操作之间有没有什么关系，我们发现：如果操作中存在两个**相邻**（~~指操作区间相邻~~）的操作是**先取反再覆盖**我们可以通过一定方法先覆盖再取反。

例如：如果这两个取反和覆盖操作的区间**不相交**，那么就可以直接交换顺序；如果这两个取反和覆盖的区间**相交**，那么就将取反操作的区间扩展到二者的并集，覆盖操作同样可以由取反操作替代。

所以我们就能 先通过覆盖操作 将 $S$ 串变成一个内部要么与 $T$ 串相同要么与 $T$ 串相反，再通过取反操作把它变得与 $T$ 串相同，于是我们的操作顺序就变成了**先覆盖再取反**的形式。

考虑 DP 枚举上一位的覆盖情况  $f_{i,k}$ ，表示考虑了前 $i$ 位,进行的覆盖操作为 $k$ ( $0$ 为用 $0$ 覆盖，$1$ 为用 $1$ 覆盖，$2$ 为不覆盖保持与 $T$ 串一样）时需要的最小操作数。

### 代码分析
* 初始化
```cpp
f[1][0] = 1 + ( t[1] == '1' );
f[1][1] = 1 + ( t[1] == '0' );
f[1][2] = ( s[1] != t[1] );
```

以 $f_{1,0}$ 为例：因为要用 $0$ 覆盖，所以我们要打一个覆盖标记，操作数 $+1$ ；如果对应的 $T$ 串位置为 $1$ 的话，我们需要覆盖后在这个位置取反，操作数 $+1$ 。
* DP 转移

同样以 $f_{i,0}$ 为例：
```cpp
if ( t[i] == '0' ) 
  f[i][0] = min( f[i - 1][0] , min( f[i - 1][1] + 1 , f[i - 1][2] + 1 ) )
  ```

当对应的 $T$ 串位置为 $0$ 时：此时 $T$ 串为 $0$ ，覆盖为 $0$ ，不用考虑取反操作。

1. 由 $f_{i-1,0}$ 转移：由于前面用 $0$ 覆盖时已经打过覆盖标记，所以操作数不变。

1. 由 $f_{i-1,1}$ 转移：由于前面的覆盖标记为 $1$ ，我们要重新用 $0$ 覆盖，需要再打一次 $0$ 的覆盖标记。

1. 由 $f_{i-1,2}$ 转移：由于前面没有覆盖标记，我们要重新用 $0$ 覆盖，需要再打一次 $0$ 的覆盖标记。

```cpp
else f[i][0] = min( f[i - 1][0] + ( t[i - 1] == '0' ) , min( f[i - 1][1] + (t[i - 1] == '1' ) + 1 , f[i - 1][2] + ( s[i - 1] == t[i - 1]) + 1 ) ) ;
```

否则（对应 $T$ 串位置为 $1$ 时）：此时 $T$ 串为 $1$ ，覆盖为 $0$，要考虑取反操作。

1. 由 $f_{i-1,0}$ 转移：

（1）前面的覆盖标记为 $0$，所以覆盖操作不变 ；

（2）如果前面的 $T$ 串位置为 $1$ （前面的覆盖也为 $0$ ），那么前面肯定有过取反操作，根据我们最后取反的思想，这个位置可以和前面的取反操作一起取反，取反操作不变；

（3）如果前面的 $T$ 串位置为 $0$ （前面的覆盖也为 $0$ ），那么此时就没办法和前面一起取反，此时取反操作 $+1$ ；

2. 由 $f_{i-1,1}$ 转移：

（1)前面的覆盖操作为 $0$ ，所以覆盖操作 $+1$ ;
 
（2）上面已经讨论的很清楚了，这里就只说一下取反操作 $+1$ 的情况：前面的 $T$ 串位置为 $1$ （前面的覆盖为 $1$ ），则前面没有取反操作，此时取反操作 $+1$ ；

3. 由 $f_{i-1,2}$ 转移：

（1）前面没有覆盖操作，所以覆盖操作 $+1$ ；

（2）（~~如果不清楚就参考上面 $f_{i-1,0}$ 的讨论~~）前面的 $T$ 串位置与 $S$ 串位置相等，则前面没有取反操作，此时取反操作 $+1$ ；

其余 $f_{i,1}$ 和 $f_{i,2}$ 的讨论这里就不赘述了，可以自己手推一下。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int x=0,f=1;char c=getchar();
	while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
const int maxn=1e6+10;
int T,len,f[maxn][3];
char s[maxn],t[maxn];
signed main()
{
	T=read();
	while (T--)
	{
		scanf("%s%s",s+1,t+1);
		len=strlen(s+1); 
		memset(f,0x3f,sizeof(f));
		f[1][0]=1+(t[1]=='1');
		f[1][1]=1+(t[1]=='0');
		f[1][2]=(s[1]!=t[1]);
		for (int i=2;i<=len;i++)
		{
			if (t[i]=='0') f[i][0]=min(f[i-1][0],min(f[i-1][1]+1,f[i-1][2]+1));
			else f[i][0]=min(f[i-1][0]+(t[i-1]=='0'),min(f[i-1][1]+(t[i-1]=='1')+1,f[i-1][2]+(s[i-1]==t[i-1])+1));
			  
			if (t[i]=='1')  f[i][1]=min(f[i-1][1],min(f[i-1][0]+1,f[i-1][2]+1));
			else f[i][1]=min(f[i-1][1]+(t[i-1]=='1'),min(f[i-1][0]+(t[i-1]=='0')+1,f[i-1][2]+(s[i-1]==t[i-1])+1));
			 
			if (s[i]==t[i]) f[i][2]=min(f[i-1][2],min(f[i-1][0],f[i-1][1]));
			else f[i][2]=min(f[i-1][2]+(s[i-1]==t[i-1]),min(f[i-1][0]+(t[i-1]=='0'),f[i-1][1]+(t[i-1]=='1')));
		}
		printf("%d\n",min(f[len][0],min(f[len][1],f[len][2])));
	}
	return 0;
}
```
第一次写题解，写的不好轻喷。

---

## 作者：Caiest_Oier (赞：15)

# [AT_joisc2019_h](https://www.luogu.com.cn/problem/AT_joisc2019_h)    

怎么没有题解啊。    

考虑操作序列中如果存在相邻两个操作是先反转再覆盖，我们明显可以将它们的顺序交换。具体的，如果两个操作不交，则可以直接交换，否则，将反转的区域拓展到二者的并集，并将覆盖的颜色反转，即可交换。    

于是我们把操作序列变为了先覆盖再反转的形式。考虑一个序列如果只能反转，则答案为原始序列与最终序列异或后极长的 $1$ 段的个数。另外覆盖是不交的，于是考虑 DP，令 $dp_{i,0/1/2}$ 表示考虑了前 $i$ 位，第 $i$ 位的覆盖结果为：用 $0$ 覆盖，用 $1$ 覆盖，保持原样。枚举上一位的覆盖情况即可转移。   

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[1000003][3];
string a,b;
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>a>>b;
	dp[1][0]=(b[0]=='1')+1;
	dp[1][1]=(b[0]=='0')+1;
	dp[1][2]=(b[0]!=a[0]);
	for(int i=2;i<=n;i++){
		if(b[i-1]=='0')dp[i][0]=min(dp[i-1][0],min(dp[i-1][1]+1,dp[i-1][2]+1));
		else dp[i][0]=min(dp[i-1][0]+(b[i-2]=='0'),min(dp[i-1][1]+(b[i-2]=='1')+1,dp[i-1][2]+(b[i-2]==a[i-2])+1));
		if(b[i-1]=='1')dp[i][1]=min(dp[i-1][1],min(dp[i-1][0]+1,dp[i-1][2]+1));
		else dp[i][1]=min(dp[i-1][1]+(b[i-2]=='1'),min(dp[i-1][0]+(b[i-2]=='0')+1,dp[i-1][2]+(b[i-2]==a[i-2])+1));
		if(b[i-1]==a[i-1])dp[i][2]=min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]));
		else dp[i][2]=min(dp[i-1][0]+(b[i-2]=='0'),min(dp[i-1][1]+(b[i-2]=='1'),dp[i-1][2]+(b[i-2]==a[i-2])));
	}
	printf("%d",min(dp[n][0],min(dp[n][1],dp[n][2])));
	return 0;
}
```

[提交记录](https://loj.ac/s/1902836)

---

## 作者：yu_666 (赞：4)

### 为何写这篇题解。

洛谷月赛重题。

### 问题分解。

我们将这个问题分解为以下几个小问题：

- 理解并优化操作顺序。

- 确定反转操作的优化策略。

- 确定推平操作的优化策略。

- 设计动态规划算法来求解最小操作次数。

------------

### 解决问题。

##### 问题1：如何优化操作顺序？

- 如果两个操作的区间有交集，我们可以先推平再反转，这样可以减少操作次数。

- 如果两个操作的区间没有交集，我们可以任意调整它们的顺序，不会影响最终结果。

##### 问题2：如何优化反转操作？

- 对于同一个位置，最多只需要进行一次反转操作。因为两次反转操作相当于没有操作。

##### 问题3：如何优化推平操作？

- 如果一个区间已经被推平，那么在这个区间上再进行推平操作是没有意义的。

##### 问题4：如何设计动态规划算法？

我们设计一个三维动态规划数组 $dp_{i,j,k}$ ，其中 $i$ 表示考虑前 $i$ 个位置，$j$ 表示当前状态，$j = 0$ 表示不在推平区间内，$j = 1$ 表示在推平区间内且推平的值为 $0$，$j = 2$ 表示在推平区间内且推平的值为 $1$。       

 $k$ 表示是否在反转区间内，$k = 0$ 表示不在，$k = 1$ 表示在。
 
状态转移方程如下：

- 不进行任何操作：$dp_{i,j,k} = dp_{i-1,j,k}$

- 进行推平操作：如果 $A_i$ 与 $B_i$ 相等，则可以选择推平操作，将 $A_i$ 设为 $B_i$。

- 进行反转操作：如果 $A_i$ 与 $B_i$ 不相等，则必须进行反转操作。      

------------

### 解题答案。

最终答案为 $dp_{n,0,0}$，其中 $n$ 为数组的长度。

---

## 作者：Link_Cut_Y (赞：3)

怎么会有月赛重这题？

首先挖掘一下题目的性质。首先一个比较典的就是，翻转区间之间互不相交，覆盖区间之间互不相交。另外比较难观察的是，所有覆盖都可以在翻转后再进行，他们可以在相同步数内得到相同结果。

为什么是这样呢？假设覆盖的区间包含在翻转的区间内，假设先翻转，再覆盖成 $0$，显然我也可以用先覆盖成 $1$，在翻转来完成，他们有同样的效果。对于相交的情况也是一样的。

所以我们考虑，将原序列先全用覆盖操作，变成形如若干段与 $t$ 串相反和与 $t$ 串相同的串交替拼接的串。比如如果 $t = \{0, 0, 0, \cdots , 0\}$，可以先用覆盖把 $s$ 变成 $\{0, 0, 0, \cdots , 0, 1, 1, 1, \cdots, 0, 0, 0, \cdots\}$ 的形式，再用翻转操作，把 $1$ 都变成 $0$。当然这个例子举的不好。

由于翻转可以全在覆盖后做，我们不妨设 $f_{i, j, k}$，其中 $i \le n, j \in \{0, 1\}, k \in \{0, 1, 2\}$，表示已经考虑完了前 $i$ 个序列的覆盖操作，第 $i$ 个数和 $t_i$ 相同 $0$ 或相反 $1$，第 $i$ 个数被 $0$ 覆盖还是被 $1$ 覆盖还是没被覆盖 $2$。

分类讨论进行转移，这里的分类讨论就不细说了，大概就是如果 $i$ 被覆盖了，$j$ 也可以顺便接着覆盖而不需要代价，如果 $i$ 和 $t_i$ 相同而想让 $i + 1$ 和 $t_{i + 1}$ 相反就需要额外话翻转的代价等等。代码贴一下给大家参考吧，虽然考场上匆忙实现的有点丑。

```cpp
read(n);
scanf("%s", s + 1);
scanf("%s", t + 1);
memset(f, 0x3f, sizeof f);
f[0][0][2] = 0;
rop(i, 0, n) {
	if (s[i + 1] == t[i + 1]) {
		if (s[i + 1] == '0') {
			chkmin(f[i + 1][0][0], f[i][0][0]);
			rep(j, 0, 2) chkmin(f[i + 1][0][2], f[i][0][j]);
			chkmin(f[i + 1][0][0], f[i][1][0]);
			rep(j, 0, 2) chkmin(f[i + 1][0][2], f[i][1][j]);
			chkmin(f[i + 1][1][1], f[i][1][1]);
			chkmin(f[i + 1][1][1], f[i][1][0] + 1);
			chkmin(f[i + 1][1][1], f[i][1][2] + 1);
			chkmin(f[i + 1][1][1], f[i][0][1] + 1);
			chkmin(f[i + 1][1][1], f[i][0][0] + 2);
			chkmin(f[i + 1][1][1], f[i][0][2] + 2);
		} else if (s[i + 1] == '1') {
			chkmin(f[i + 1][0][1], f[i][0][1]);
			rep(j, 0, 2) chkmin(f[i + 1][0][2], f[i][0][j]);
			chkmin(f[i + 1][0][1], f[i][1][1]);
			rep(j, 0, 2) chkmin(f[i + 1][0][2], f[i][1][j]);
			chkmin(f[i + 1][1][0], f[i][1][0]);
			chkmin(f[i + 1][1][0], f[i][1][1] + 1);
			chkmin(f[i + 1][1][0], f[i][1][2] + 1);
			chkmin(f[i + 1][1][0], f[i][0][0] + 1);
			chkmin(f[i + 1][1][0], f[i][0][1] + 2);
			chkmin(f[i + 1][1][0], f[i][0][2] + 2);
		}
	} else {
		if (s[i + 1] == '0') {
			chkmin(f[i + 1][1][0], f[i][1][0]);
			rep(j, 0, 2) chkmin(f[i + 1][1][2], f[i][1][j]);
			chkmin(f[i + 1][1][0], f[i][0][0] + 1);
			rep(j, 0, 2) chkmin(f[i + 1][1][2], f[i][0][j] + 1);
			chkmin(f[i + 1][0][1], f[i][1][1]);
			chkmin(f[i + 1][0][1], f[i][1][0] + 1);
			chkmin(f[i + 1][0][1], f[i][1][2] + 1);
			chkmin(f[i + 1][0][1], f[i][0][1]);
			chkmin(f[i + 1][0][1], f[i][0][0] + 1);
			chkmin(f[i + 1][0][1], f[i][0][2] + 1);
		} else if (s[i + 1] == '1') {
			chkmin(f[i + 1][1][1], f[i][1][1]);
			rep(j, 0, 2) chkmin(f[i + 1][1][2], f[i][1][j]);
			chkmin(f[i + 1][1][1], f[i][0][1] + 1);
			rep(j, 0, 2) chkmin(f[i + 1][1][2], f[i][0][j] + 1);
			chkmin(f[i + 1][0][0], f[i][1][0]);
			chkmin(f[i + 1][0][0], f[i][1][1] + 1);
			chkmin(f[i + 1][0][0], f[i][1][2] + 1);
			chkmin(f[i + 1][0][0], f[i][0][0]);
			chkmin(f[i + 1][0][0], f[i][0][1] + 1);
			chkmin(f[i + 1][0][0], f[i][0][2] + 1);
		}
	}
} 
int ans = 0x3f3f3f3f;
rep(j, 0, 1) rep(k, 0, 2) chkmin(ans, f[n][j][k]);
printf("%lld\n", ans);
```

我真是分类讨论大师。

---

## 作者：NEKO_Daze (赞：1)

双倍经验，前来水题解。

洛谷题目传送门：[AT_joisc2019_h](https://www.luogu.com.cn/problem/AT_joisc2019_h)

## 简要题意

给出两个长度相同的 $01$ 串 $S,T$，可以对 $S$ 进行任意次下面三种操作，问最少多少次操作后 $S = T$。

1. 选择一个区间，将其中的 $0,1$ 反转；
2. 选择一个区间，将所有项改为 $0$；
2. 选择一个区间，将所有项改为 $1$；

## 思路

与 P10766 一样。定义一个二维数组 `dp[1000005][3]`，其中 $dp_{i,0}$ 代表前 $i$ 段里，第 $i$ 段的操作为全改 $0$，$dp_{i,1}$ 代表前 $i$ 段里，第 $i$ 段的操作为全改 $1$，$dp_{i,2}$ 代表前 $i$ 段里，第 $i$ 段不进行操作。显然满足最优子结构和无后效性，于是上 $dp$。

注意数据范围改改就过了。

本题[双倍经验](https://www.luogu.com.cn/problem/P10766)，美滋滋。

```cpp
//By NEKO_Daze 2024-7-14 19:42
#include<bits/stdc++.h>
using namespace std;
int min3(int a, int b, int c) {return min(a, min(b, c));}
int t;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> t;
	while (t--)
	{
		string a, b;
		int dp[1000005][3];
		memset(dp, 0, sizeof(dp));
		cin >> a >> b;
		int l = a.length();
		if (b[0] == '1') dp[1][0] = 2, dp[1][1] = 1;
		else dp[1][0] = 1, dp[1][1] = 2;
		if (a[0] == b[0]) dp[1][2] = 0;
		else dp[1][2] = 1;
		for(int i = 2;i <= l;i++) {
			if(b[i - 1] == '0') dp[i][0] = min3(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1), dp[i][1] = min3(dp[i - 1][1] + (b[i - 2] == '1'), dp[i - 1][0] + (b[i - 2] == '0') + 1, dp[i - 1][2] + (b[i - 2] == a[i - 2]) + 1);
			else dp[i][0] = min3(dp[i - 1][0] + (b[i - 2] == '0'), dp[i - 1][1] + (b[i - 2] == '1') + 1, dp[i - 1][2] + (b[i - 2] == a[i - 2]) + 1), dp[i][1] = min3(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1);
			if (a[i - 1] == b[i - 1]) dp[i][2] = min3(dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]);
			else dp[i][2] = min3(dp[i - 1][0] + (b[i - 2] == '0'), dp[i - 1][1] + (b[i - 2] == '1'), dp[i - 1][2] + (b[i - 2] == a[i - 2]));
		}
		printf("%d\n", min3(dp[l][0], dp[l][1], dp[l][2]));
	}
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：1)

无脑型做法。

### [题意](https://www.luogu.com.cn/problem/AT_joisc2019_h)
问一个 $01$ 序列通过区间覆盖和区间反转变成另一个 $01$ 序列所需要的最少次数。

### 分析
手搓几个数据可以发现，有了区间反转，区间覆盖可以两两不交（因为相交的区间覆盖可以理解为一整片区间覆盖后再区间反转，次数不变，因为在已经覆盖的区间上再覆盖等价于反转），比如：
$$010101010101\to000011110000$$
可以用 $[1,12]$ 覆盖 $0$，$[5,8]$ 反转。

而所有的在覆盖之前的反转都可以转化为在覆盖之后（因为最后的情况是覆盖操作和一个翻转操作挨着就可以先覆盖为反色再反转）
$$010101010101\to10101011110101$$
可以用 $[5,8]$ 覆盖 $0$，$[1,8]$ 反转。

然后反转显然可以两两不交（因为反转两次相当于没有反转），那么每个格子只有 $6$ 种状态：不被覆盖，被反转，覆盖为 $0$，覆盖为 $1$，覆盖为 $0$ 后反转，覆盖为 $1$ 后反转，设 $f(i,j)$ 为令第 $i$ 个格子在第 $j$ 种状态下，用的最少的操作次数，然后贪心地尽量让前面的操作向后延伸，实现转移，时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
const int N=11e5;
#define up(a,b,c) for(int a=b;a<=c;++a)
using namespace std;
int n,f[6],g[6];
char s[N],t[N];
int main()
{
	scanf("%d%s%s",&n,s+1,t+1);
	f[0]=0;
	fill(f+1,f+6,N);
	up(i,1,n)
	{
		copy(f,f+6,g);
		f[0]=s[i]==t[i]?min({g[0],g[1],g[2],g[3],g[4],g[5]}):N; 
		f[1]=s[i]!=t[i]?min({g[0]+1,g[1],g[2]+1,g[3]+1,g[4],g[5]}):N;
		f[2]=t[i]=='1'?min({g[0]+1,g[1]+1,g[2],g[3]+1,g[4],g[5]+1}):N;
		f[3]=t[i]=='0'?min({g[0]+1,g[1]+1,g[2]+1,g[3],g[4]+1,g[5]}):N;
		f[4]=t[i]=='0'?min({g[0]+2,g[1]+1,g[2]+1,g[3]+1,g[4],g[5]+1}):N;
		f[5]=t[i]=='1'?min({g[0]+2,g[1]+1,g[2]+1,g[3]+1,g[4]+1,g[5]}):N;
	}
	cout<<min({f[0],f[1],f[2],f[3],f[4],f[5]})<<'\n';
	return 0;
}
```

---

## 作者：zjh111111 (赞：0)

来一篇代码简洁点的题解。

发现一定存在一种最优解使翻转区间不交，覆盖区间不交，翻转全在覆盖后进行。

考虑**线性 dp**。

$f_{i,0/1/2}$ 表示匹配前 $i$ 个字符，对第 $i$ 个字符的操作是覆盖成 $0/1$ 还是不变 $(2)$ 的最小代价。由于 $S_i$ 操作后要和 $T_i$ 相等，所以可以推出第 $i$ 个字符有没有取反操作。

转移时在每个操作的左端点计上次数。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template <typename T>
inline void read(T &x) {
	int w = 1; x = 0; char c = getchar();
	while (!isdigit(c))
		(c == '-') && (w = -w), c = getchar();
	while (isdigit(c))
		x = (x << 1) + (x << 3) + (c ^ '0'), c = getchar();
}

const int N = 500005;
int Q, n, f[N][3];
char S[N], T[N];
inline int get_num(int x, int co) {
	return (co == 2) ? x : co;
}
signed main() {
	read(Q);
	while (Q -- > 0) {
		scanf("%s", S+1);
		scanf("%s", T+1);
		n = strlen(S+1);
		for (int i=0; i<=n; ++i) {
			for (int j=0; j<3; ++j) {
				f[i][j] = n;
			}
		}
		f[0][2] = 0;
		for (int i=1; i<=n; ++i) {
			for (int lst=0; lst<3; ++lst) {
				int sr = (i == 1) ? 0 : (get_num(S[i-1]-'0', lst) ^ (T[i-1]-'0')); //i-1 是否取反
				for (int now=0; now<3; ++now) {
					int tr = (get_num(S[i]-'0', now) ^ (T[i]-'0')); //i 是否取反
					f[i][now] = min(f[i][now], f[i-1][lst] + (now != 2 && lst != now) + (!sr && tr));
				}
			}
		}
		printf("%d\n", min(min(f[n][0], f[n][1]), f[n][2]));
	}
	return 0;
}
```

---

## 作者：JimmyLee (赞：0)

# 题意

> 走廊上有排成一列的 $n$ 盏灯，给出了一个 $01$ 串 $S$ 表示其开关状态（$1$ 表示打开，$0$ 表示关闭）。现在想要把这 $n$ 盏灯变成目标状态 $T$。
>
> 你有三种操作：
>
> - OFF 操作：选择一个区间，将区间内所有的灯关闭。
> - ON 操作：选择一个区间，将区间内所有的灯打开。
> - TOG 操作：选择一个区间，在区间内关闭原本打开的灯，打开原本关闭的灯。
>
> 求将灯的状态从 $S$ 变为 $T$ 的最小的操作数。

# 分析

首先，任意两个有交的翻转操作 $[l_1, r_1]$ 和 $[l_2, r_2]$（其中 $l_1\leq l_2$）可以化成两个不交的翻转操作 $[l_1, l_2)$ 和 $(r_1, r_2]$。

所以在最优情况下存在翻转操作互不相交的方案。

---

然后考虑覆盖操作。

首先显然覆盖操作的区间要么不交，要么一个包含另一个。

正确性显然。

后一种情况可以化为先覆盖再翻转，所以存在覆盖操作互不相交的方案。

---

最后考虑覆盖操作和翻转操作之间的关系。

如果是先翻转再覆盖，此时翻转区间一定包含覆盖区间。

那么就可以先覆盖相反的值，然后再翻转。

---

所以存在覆盖操作互不相交，且翻转操作互不相交，且先覆盖再翻转的方案。

据此，可以进行线性 dp。

令 $dp_{i, v}(v\in\{0, 1, 2\})$ 为考虑到第 $i$ 位，其覆盖结果分别为用 $0$ 覆盖、用 $1$ 覆盖、不覆盖所需的最少操作数。

分情况讨论是否需要添加翻转即可。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1000006

int dp[maxn][3];
char S[maxn], T[maxn];

int main()
{
    int n;
    scanf("%d%s%s", &n, S+1, T+1);
    dp[1][0]=(T[1]!='0')+1;
    dp[1][1]=(T[1]!='1')+1;
    dp[1][2]=(T[1]!=S[1]);
    for(int i=2;i<=n;i++)
        dp[i][1]=min({dp[i-1][0]+(T[i]!='1')*(T[i-1]=='0')+1, dp[i-1][1]+(T[i]!='1')*(T[i-1]=='1'), dp[i-1][2]+(T[i]!='1')*(T[i-1]==S[i-1])+1}),
        dp[i][0]=min({dp[i-1][0]+(T[i]!='0')*(T[i-1]=='0'), dp[i-1][1]+(T[i]!='0')*(T[i-1]=='1')+1, dp[i-1][2]+(T[i]!='0')*(T[i-1]==S[i-1])+1}),
        dp[i][2]=min({dp[i-1][0]+(S[i]!=T[i])*(T[i-1]=='0'), dp[i-1][1]+(S[i]!=T[i])*(T[i-1]=='1'), dp[i-1][2]+(S[i]!=T[i])*(S[i-1]==T[i-1])});
    printf("%d\n", min({dp[n][0], dp[n][1], dp[n][2]}));
}
```

---

## 作者：luxiaomao (赞：0)

## [AT_joisc2019_h](https://www.luogu.com.cn/problem/AT_joisc2019_h)
 
月赛重了？还是 Div.2 的 T2？这么逆天，那就来原题写篇题解。（赛时写贪心但是只骗了十分嘤嘤嘤）

## Solution

题意不难理解，我们可以理解为有区间覆盖和区间反转两种操作。

并且同一种操作之间是不会有交集的（比如：反转 $[1,3]$ 和 $[2,4]$ 等价于反转 $[1,1]$ 和 $[4,4]$，这样就没有交集了）

没有交集就可以进行动态规划了，但是还有一种存在交集的情况，就是区间覆盖和区间反转两种操作之间。

**如果先反转，再覆盖（这两个操作有交集），那就等价于先覆盖，再反转没被覆盖的部分**。这样，我们就把整个操作序列转化为先覆盖，再反转的形式，可以进行动态规划了。

我们记 $f_{i,0/1/2}$ 表示考虑到前 $i$ 位：

- $f_{i,0}$ 这一位被 $0$ 覆盖的最小操作数。

- $f_{i,1}$ 这一位被 $1$ 覆盖的最小操作数。

- $f_{i,2}$ 这一位不进行覆盖操作的最小操作数。

（注意这里是针对覆盖操作而言，还要再加上反转成为目标串的方案数，**比如 $f_{1,2}$ 也可能是 $1$，因为不覆盖，但是待会要反转，所以加上一**）

## Code

```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;

int n;
char s[N],t[N];
int f[N][3];

int main()
{
	scanf("%d%s%s",&n,s+1,t+1);
	memset(f,0x3f3f,sizeof f);
	f[1][0] = 1+(t[1]=='1');
	f[1][1] = 1+(t[1]=='0');
	f[1][2] = s[1]!=t[1];
	for(int i = 2;i <= n;i++)
		for(int j = 0;j <= 2;j++)
		for(int k = 0;k <= 2;k++)
		{
			int x = f[i-1][j];
			if(j != k && k != 2)x++;//这里算的是要不要新开一个覆盖操作
			char A = j==2?s[i-1]:(j+'0');
			char B = k==2?s[i]:(k+'0');
			if(t[i-1] == A && t[i] != B)x++;//这里算的是要不要新开一个反转操作
			f[i][k] = min(f[i][k],x);
		}
	printf("%d\n",min(min(f[n][0],f[n][1]),f[n][2]));
	return 0;
}
```

---


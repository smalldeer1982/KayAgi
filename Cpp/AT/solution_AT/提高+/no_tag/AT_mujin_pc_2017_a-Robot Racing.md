# Robot Racing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/mujin-pc-2017/tasks/mujin_pc_2017_a

あなたはカエル型のロボットを開発しています。 あなたはこのロボットに競走をさせることにしました。

まず、あなたは数直線上に $ N $ 体のロボットを置きました。 ロボットには $ 1 $ から $ N $ までの番号が振られています。 今、$ i $ 番目のロボットは座標 $ x_i $ にいます。 ただし、$ x_i $ はすべて整数であり、$ 0\ <\ x_1\ <\ x_2\ <\ ...\ <\ x_N $ が成り立ちます。

あなたは次の操作を繰り返し行います。

- 数直線上のロボットを一体選ぶ。 選んだロボットの座標を $ x $ とする。 座標 $ x\ -\ 1 $, $ x\ -\ 2 $ のうち他のロボットがいない座標を着地点に選ぶ。 選んだロボットを着地点へジャンプさせる。

あるロボットの座標が 0 以下になった場合、そのロボットはゴールしたと見なされ、即座に数直線から取り除かれます。 すべてのロボットがゴールするまで、あなたは操作を行い続けます。

あなたが操作を行う方法によって、$ N $ 体のロボットがゴールする順番は何通りかありえます。 $ N $ 体のロボットがゴールする順番は何通りありうるでしょうか？ $ 10^9+7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 2\ <\ =\ N\ <\ =\ 10^5 $
- $ x_i $ は整数である。
- $ 0\ <\ x_1\ <\ x_2\ <\ ...\ <\ x_N\ <\ =\ 10^9 $

### 部分点

- $ 500 $ 点分のテストケースでは、$ N\ <\ =\ 8 $ が成り立つ。

### Sample Explanation 1

$ 3 $ 体のロボットがゴールする順番は、次の $ 4 $ 通りありえます。 - $ (ロボット\ 1\ →\ ロボット\ 2\ →\ ロボット\ 3) $ - $ (ロボット\ 1\ →\ ロボット\ 3\ →\ ロボット\ 2) $ - $ (ロボット\ 2\ →\ ロボット\ 1\ →\ ロボット\ 3) $ - $ (ロボット\ 2\ →\ ロボット\ 3\ →\ ロボット\ 1) $

### Sample Explanation 2

$ 3 $ 体のロボットがゴールする順番は、次の $ 6 $ 通りありえます。 - $ (ロボット\ 1\ →\ ロボット\ 2\ →\ ロボット\ 3) $ - $ (ロボット\ 1\ →\ ロボット\ 3\ →\ ロボット\ 2) $ - $ (ロボット\ 2\ →\ ロボット\ 1\ →\ ロボット\ 3) $ - $ (ロボット\ 2\ →\ ロボット\ 3\ →\ ロボット\ 1) $ - $ (ロボット\ 3\ →\ ロボット\ 1\ →\ ロボット\ 2) $ - $ (ロボット\ 3\ →\ ロボット\ 2\ →\ ロボット\ 1) $ 例えば、次図のように操作を行うと、$ (ロボット\ 3\ →\ ロボット\ 2\ →\ ロボット\ 1) $ の順にゴールします。 !\[a55aed48a00614569d4844f39807e2fb.png\](https://atcoder.jp/img/mujin/a55aed48a00614569d4844f39807e2fb.png)

### Sample Explanation 4

答えを $ 10^9+7 $ で割った余りを出力してください。 なお、このケースは部分点のテストケースには含まれません。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
3
2 3 4```

### 输出

```
6```

## 样例 #3

### 输入

```
8
1 2 3 5 7 11 13 17```

### 输出

```
10080```

## 样例 #4

### 输入

```
13
4 6 8 9 10 12 14 15 16 18 20 21 22```

### 输出

```
311014372```

# 题解

## 作者：FFTotoro (赞：3)

Part $1$：前言

本题具有较高的思维难度，AtCoder Problems 评分 1900，个人认为应该评蓝。

Part $2$：$500$ 分做法

因为 $N\le 8$，$N!$ 可以枚举全部的排列。对于每个排列，只要按照顺序判定机器人是否能够到达终点即可。

这里我们需要应用一个重要的性质：机器人 $k$ 最初能够到达目标的充分必要条件是：对于各 $i<k$，$x_i\ge 2i-1$ 成立。

证明：

- 条件 $x_i\ge 2i-1$ 成立时，对于各 $i<k$，机器人 $i$ 向坐标 $2i-1$ 移动后，可使机器人 $k$ 到达目标。
- 反之，如果条件不成立，存在 $x_j<2j-1$ 的 $j(<k)$。假设机器人 $k$ 跳过各 $i<k$ 到达目标。机器人 $k$ 跳过机器人 $i$ 时，将机器人 $i$ 的坐标设为 $y_i$。那么，$0<y_1,y_2-y_1\ge 2,y_j-y_j-1\ge2,y_j<2j-1$。很显然，这是矛盾的。

因此，要按照排列 $p_1,\ldots,p_N$ 的顺序判定机器人能否到达目标，如下所示即可：

- 首先，检查机器人 $p_1$ 的上述条件是否成立。
- 接下来，去除机器人 $p_1$，检查机器人 $p_2$ 的上述条件是否成立。
- 以此类推。

Part $3$：$900$ 分（AC）做法

首先计算最初能到达目标的机器人的个数：很显然，我们需要从这些机器人中选择 $1$ 个作为第一个到达目标的机器人。

我们可以使用一个栈，从左到右不断地放入机器人。在栈中放入机器人时，如果该机器人是栈中的第 $k$ 个元素且坐标小于 $2k-1$，则将该机器人弹出并将答案乘以 $k$（因为我们必须去除这些 $k$ 个机器人中的任意一个）。

将所有机器人放入栈后，进入栈中的机器人可以按照任意顺序到达目标；因此，将剩余机器人个数的阶乘乘以答案即可。

Part $4$：代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int m=1e9+7;
main(){
    ios::sync_with_stdio(false);
    int n,c=0,s=1; cin>>n;
    for(int i=0;i<n;i++){
        int x; cin>>x;
        if(x<(c<<1|1))s=s*(c+1)%m;
        else c++;
    }
    while(c)s=s*c--%m;
    cout<<s<<endl;
    return 0;
}
```

---


# Row to Column

## 题目描述

[problemUrl]: https://atcoder.jp/contests/mujin-pc-2017/tasks/mujin_pc_2017_b

縦 $ N $ 行、横 $ N $ 列の正方形状のマス目があります。 上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表します。

最初、各マスは白か黒です。 最初のマス目の配色は、正方形状に並ぶ文字 $ a_{ij} $ ($ 1\ <\ =\ i,\ j\ <\ =\ N $) として与えられます。 マス $ (i,\ j) $ が白ならば $ a_{ij} $ は `.` であり、黒ならば $ a_{ij} $ は `#` です。

あなたは、マス目の配色を塗り替えるロボットを開発しています。 このロボットは次の操作を繰り返し行うことができます。

- 整数 $ i $, $ j $ ($ 1\ <\ =\ i,\ j\ <\ =\ N $) をそれぞれ自由に選ぶ。 マス $ (i,\ 1) $, $ (i,\ 2) $, $ ... $, $ (i,\ N) $ の色をそれぞれ $ c_1 $, $ c_2 $, $ ... $, $ c_N $ として記憶する。 その後、マス $ (1,\ j) $, $ (2,\ j) $, $ ... $, $ (N,\ j) $ の色をそれぞれ $ c_1 $, $ c_2 $, $ ... $, $ c_N $ で塗り替える。

あなたの目標は、すべてのマスを黒にすることです。 すべてのマスを黒にすることが可能か判定し、可能ならば必要な操作回数の最小値を求めてください。

## 说明/提示

### 制約

- $ 2\ <\ =\ N\ <\ =\ 500 $
- $ a_{ij} $ は `.` または `#` である。

### 部分点

- $ 300 $ 点分のテストケースでは、$ N\ <\ =\ 3 $ が成り立つ。

### Sample Explanation 1

例えば、次のように操作を行うと、次図のようにマス目の配色が変わります。 - $ i\ =\ 1 $, $ j\ =\ 2 $ と選んで操作を行う。 - $ i\ =\ 1 $, $ j\ =\ 1 $ と選んで操作を行う。 - $ i\ =\ 1 $, $ j\ =\ 2 $ と選んで操作を行う。 !\[6a0314bb2b1073694a7ef5a062e77b13.png\](https://atcoder.jp/img/mujin/6a0314bb2b1073694a7ef5a062e77b13.png)

## 样例 #1

### 输入

```
2
#.
.#```

### 输出

```
3```

## 样例 #2

### 输入

```
2
..
..```

### 输出

```
-1```

## 样例 #3

### 输入

```
2
##
##```

### 输出

```
0```

## 样例 #4

### 输入

```
3
.#.
###
.#.```

### 输出

```
2```

## 样例 #5

### 输入

```
3
...
.#.
...```

### 输出

```
5```

# 题解

## 作者：y_kx_b (赞：3)

题目链接：[AT_mujin_pc_2017_b Row to Column](https://www.luogu.com.cn/problem/AT_mujin_pc_2017_b)。洛谷没有翻译，可以去 at 看英文题面（）。

模拟赛的 T1，还好多拍了几组，不然要 100pts→5pts 了（笑）。蓝确实有点过，但橙也太夸张了/jk，下位绿吧。

首先如果有一行全满（`#`），可以考虑用这一行把所有列染满，这是显然的。那么考虑如何搞出一行满的。

观察样例（或者可以手造几组？），我们可以考虑枚举补哪一行的洞（`.`）。假设当前枚举第 $i$ 行，那么我们需要补上的这一列的第 $i$ 个字符为 `#`，即存在一行的第 $i$ 个字符为 `#`。如果不存在是不是就是无解呢？事实上我们可以把任意一行（只要有 `#` 就行）先覆盖到第 $i$ 列，这样第 $i$ 列就会有 `#` 了。所以无解当且仅当没有 `#`。

举个例子：$n=4$，我们枚举到第二行，地图（？）长这样：

```
#...
#.#.
....
..##
```

我们想找到一行来覆盖第二列来补全第二行，但是找不到。于是我们可以把第二行覆盖第二列然后变成了这样：

```
##..
#.#.
.#..
..##
```

然后就可以用第三行（或第一行）来覆盖了。经过 $3$ 步，我们终于构造出了一满行：

```
#...
####
....
..#.
```

再经过 $4$ 步，我们终于达成目标啦！（注意特判原来就有几列是满的不需要覆盖的情况。）

```cpp
int r[N];//第 i 列有多少个 #
int solve() {
	int ans1 = n + 1, ans2 = n;
	for(int j = 1; j <= n; j++) {
		r[j] = 0;
		for(int i = 1; i <= n; i++) r[j] += s[i][j] == '#';
		if(r[j] == n) ans2--;//如果这一列是满的，第二步就不需要重新覆盖这一列了
	}
	if(!accumulate(r + 1, r + n + 1, 0)) return -1;// 如果 s 没有 #，即 r 全是 0，那么无解
	for(int i = 1; i <= n; i++) {
		int res = 0;
		for(int j = 1; j <= n; j++) if(s[i][j] == '.') {
			res++;
		}
		res += !r[i];// 如果第 i 列没有 #，需要额外花一步
		ans1 = min(ans1, res);
	}
	return ans1 + ans2;
}
```



---

## 作者：Super_Builder (赞：2)

# 前言
校内考试考了这题，忘记特判痛失 10 分，发篇题解纪念。

# 正文

## 思路

首先可以把所有位置都没有黑色的情况判掉，有且仅有这种情况是无解的，如果不理解可以先往后看。

因为是**把行复制给列**，所以考虑先将某一行全部变成黑色，再将每一列全部变成黑色。

#### 假设当前考虑把第 $i$ 行全变为黑色。

设最开始总共有 $idx$ 列**满足每一个元素都是黑色**。

预处理出第 $i$ 行原本的黑色个数 $cnt_i$。

如果 $cnt_i = n$，这一行已经都是黑色了，所以更新答案为 $n - idx$。

那么我们只需要将剩下的 $n - cnt_i$ 个位置变成黑色。由于要给第 $i$ 行变成黑色，所以要让第 $i$ 列为黑色的行来赋值。这样就可以花 $n - cnt_i$ 步第 $i$ 行全部为黑色。这种方案的答案为 $n - cnt_i + n - idx$。

如果第 $i$ 列没有黑色元素，那么考虑**多进行一次**操作使第 $i$ 列有黑色元素，这显然可行。这种方案的答案为 $n - cnt_i + 1 + n - idx$。

这个时候可能会有疑问，在赋值过程中不会**产生或消除**新的**满足每一个元素都是黑色的列吗**？显然是有可能的，但是如果这样，那么**用来赋值的那一行**一定是全为黑色的行，用那一行来赋值给每一列会更优。

>那么这道题就做完了。

## 代码
```cpp
int main()
{
    ios ::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    bool fg = 0;
    for (int i = 1; i <= n; i++)
    {
        string s;
        cin >> s;
        for (int j = 1; j <= n; j++)
            a[i][j] = (s[j - 1] == '#' ? 1 : 0);
        for (int j = 1; j <= n; j++)
        {
            if (a[i][j])
                fg = 1;
            cnt[i] += a[i][j];
        }
    }
    if (!fg)
        return cout << -1, 0;
    int ans = n + n, idx = 0;
    for (int i = 1; i <= n; i++)
    {
        fg = 1;
        for (int j = 1; j <= n; j++)
        {
            if (!a[j][i])
            {
                fg = 0;
                break;
            }
        }
        idx += fg;
    }
    for (int i = 1; i <= n; i++)
    {
        if (cnt[i] == n)
        {
            ans = min(ans, n - idx);
        }
        bool fg = 1;
        for (int j = 1; j <= n; j++)
        {
            if (a[j][i])
            {
                fg = 0;
                ans = min(ans, n - cnt[i] + n - idx);
                break;
            }
        }
        if (fg)
            ans = min(ans, n - cnt[i] + 1 + n - idx);
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

什么玩意行列倒来倒去的，开心。

---

有一个显然的想法是凑齐一行黑，然后一列一列染过去。

那么问题就在于怎么凑一行黑。

对于当前这一行里**有白点的列**，我们可以使用一些可以染到该行**有白点的列**的行，一列列白点的染，凑齐一行黑。

根据这题的性质可以知道，能染到这一行有白点的列的行，一定有在和这一行同行号的列号上是黑的。

举例：如果我要染第 $4$ 行，那么能染到第 $4$ 行的行在第 $4$ 列上一定是黑的。

那么实际的染色次数就是染成同一行黑次数最优的情况次数，加上用这行逐列染色的次数。

分别统计一下，做完了。

注意无解。

---

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[505][505];
int flc[505],fish,cat=1e9;
bool lovely_flc;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    cin>>c[i][j];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)flc[i]+=(c[j][i]=='#');
        if(flc[i]!=n)fish++;
        if(flc[i])lovely_flc=1;
    }
    if(!lovely_flc)puts("-1");
    else{
        for(int i=1,sum=0;i<=n;i++,sum=0){
            for(int j=1;j<=n;j++)sum+=(c[i][j]=='.');
            cat=min(cat,sum+!flc[i]);
        }
        cout<<fish+cat;
    }
    return 0;
}
```

---

难点在于阅读理解以及反复倒来倒去给选手以晕车般的优质感受吗？

---

## 作者：cff_0102 (赞：1)

首先，因为每次操作只能将一行复制到一列，所以最后要让所有都变黑，肯定要拿全是黑的一行，一列一列的把所有地方染黑。

那么现在问题就变成了怎么让一行变成黑的。

假设我们要让第 $i$ 行变成全黑的，但是这一行的第 $j$ 列是白的，怎么办呢？

因为每次操作只能将一行复制到一列，所以要修改第 $j$ 列的第 $i$ 个格子，就需要找到一行，它的第 $i$ 列是黑色的，这样把这一行复制过去之后，第 $j$ 列的第 $i$ 行就会变成黑的了。

假如没有一行的第 $i$ 列是黑的呢？

因为每次操作只能将一行复制到一列，所以要修改第 $i$ 列使其出现黑色格子，只需要找到一行有黑色格子的，然后直接复制过去就行。当然如果全局都没有黑色格子的话那就无解。

注：在这种情况中，因为第 $i$ 列都没有黑色格子，所以这样操作肯定会增加黑色格子数量，不会有任何的黑色格子被白色格子覆盖，请放心。

总结一下：假设确定了一个行数 $i$，首先只需要看第 $i$ 列。如果第 $i$ 列有黑色的格子，那么就用黑色的对应那一行去复制，把第 $i$ 行那些空白的空填满黑色，接着就用这一行去复制到所有列就行，总操作次数为这一行白色空的数量加上列数；如果第 $i$ 列没有黑色格子，那就找有黑色格子的一行把它复制到第 $i$ 列，后面的操作一样，最终的操作次数还要再加一。

注：最后的复制操作不需要考虑输入时不是全黑，但是在这个复制操作之前就变成全黑的列。为什么呢？因为每次操作只能将一行复制到一列，所以要是出现了新的全黑的一列，那就说明有全黑的一行了。你在将第 $i$ 行填满之前都有另外的全黑的一行了，那么那一行的总操作次数肯定比这第 $i$ 行要少，就算把那多余重复染色的列给删掉也不会是最终答案，不如不管，反正最终答案要取最小值。

所以怎么实现呢？枚举每一行，分别计算用这一行复制到所有列需要的操作次数，并取最小值。具体的，为了方便，可以提前处理好每一列的黑色格子数量 $c_i$，以及每一行的黑色格子数量 $r_i$。然后计算 $\min\limits^{n}_{i=1}{((n-r_i)+[c_i=0])}+(n-\sum\limits^{n}_{i=1}{[c_i=n]})$，就是答案。另外记得判断无解。

```cpp
#include<bits/stdc++.h>
using namespace std;
//bool a[666][666];// 没用到
int r[666],c[666];// 见上面描述，分别记录每一行和列的黑格数量
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	int cnt=0;// 记录全部的黑格数量，用来判断无解
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			char s;cin>>s;
			if(s=='#'){// 如果这一格是黑的
				r[i]++;// 行黑格数量 +1
				c[j]++;// 列黑格数量 +1
				cnt++;// 黑格总数 +1
			}
		}
	}
	if(!cnt){// 特判 
		cout<<-1;
		return 0;
	}
	int mn=114514;
	for(int i=1;i<=n;i++){
		mn=min(mn,(n-r[i])+(c[i]==0));
	}
	mn+=n;
	for(int i=1;i<=n;i++){
		if(c[i]==n)mn--;
	}
	cout<<mn;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/176081913)。代码后面的循环是可以合并的，为了方便理解按照上面的公式拆开来了。

---

## 作者：未来姚班zyl (赞：1)

## 题目大意
在一个 $n\times n$ 的矩形中有若干格子被染成黑色。你可以不断进行以下操作：将一行的颜色复制到一列。求最小的操作次数，使得所有格子都被染黑。

## 题目分析

蓝题太夸张了，肯定得评黄/橙。

显然，我们肯定需要先凑出完整的一行黑色。对于每一行，至少得操作该行白色格子的数量。而方法也很简单，对于第 $i$ 行，就是找到第 $i$ 列有黑色的行复制过去就行了，如果没有，则随便找一行有黑色的复制到第 $i$ 列。

然后再用这一行把剩下的列全部染黑。如果有一列全部被染黑，则我们在过程中绝对不会拿有白色的行复制到这一列，所以减掉就可以。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned int 
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e3+5,M=5e6+5,inf=2147000000;
const double eps=1e-6;
const ll mod=1e9+7,llf=1e18;
using namespace std;
int n,ans=inf;
char c[N][N];
int ct0[N];
bool ex1[N];
int main(){
	n=read();
	rep(i,1,n)rep(j,1,n)cin >>c[i][j],ct0[i]+=c[i][j]=='o',ex1[j]|=c[i][j]=='x';
	rep(i,1,n)ans=min(ans,ct0[i]+n+!ex1[i]);
	rep(j,1,n){
		bool fl=1;
		rep(i,1,n)if(c[i][j]=='o'){
			fl=0;
			break;
		} 
		ans-=fl;
	} 
	cout <<ans;
	return 0;
}
```


---

## 作者：玉树临风英俊潇洒 (赞：0)

首先，因为每次操作只能将一行复制到一列，所以最后要让所有都变黑，肯定要拿全是黑的一行，一列一列的把所有地方染黑。

那么问题就在于怎么凑一行黑。

根据这题的性质可以知道，能染到这一行有白点的列的行，一定有在和这一行同行号的列号上是黑的。

所以实际的染色次数就是染成同一行黑次数最优的情况次数，加上用这行逐列染色的次数。

分别统计一下，还要注意无解。

---

## 作者：Fubaogege (赞：0)

想要凑出完整的黑色，必须操作白色。  

对于第 $i$ 行，复制所有的黑色，如果没有，则随便复制一行黑色。

把第 $i$ 行全部染黑，如果已经有了全部染黑的一列，剪掉就行。

核心主函数代码：
```c
int main(){
	n=read();
	rep(i,1,n)rep(j,1,n)cin>>c[i][j],xx[i]+=c[i][j]=='xxx',xxx[j]|=c[i][j]=='xxx';
	rep(i,1,n)ans=min(ans,xx[i]+n+!xxx[i]);
	rep(j,1,n){
		bool flag=1;
		rep(i,1,n)if(c[i][j]=='xxx'){
			flag=0;
			break;
		} 
		ans=ans-fl;
	} 
	cout<<ans;
	return 0;
}
```

---

## 作者：Y_QWQ_Y (赞：0)

% 你赛 T3，少想了一种情况导致只有 80 pts。

### 题意简述
给你一个黑白矩阵，每次操作用一行去染一列，问最少要多少次操作使得原矩阵变成全黑的。

### 解题思路
我们可以先把全都是白色的情况判掉，因为这样是无解的。

既然要用一行去染一列，我们显然可以想到染出一行黑色。

考虑到我们不需要知道每个黑点的位置，我们可以把每行每列的黑点数量记录下来，然后去考虑对于第 $i$ 行，把它染成全黑的代价：显然，只要第 $i$ 列有黑色，就可以把第 $i$ 行全然成黑色，代价为这一行的**白色**数量。那要是第 $i$ 列没有黑色呢？没关系，整个矩阵肯定会有黑色，所以只需要用矩阵中一个有黑色的行去染第 $i$ 列即可。这样的话就会多一次操作。那么我们继续考虑用一个全黑的行去染整个矩阵的代价，要用 $n$ 次吗？不用，因为全黑的列不需要去染。又因为全黑的列的数量是固定的，所以我们只需要枚举最小的 $n - h_i+1\times (l_i=0)$ 即可（$h_i$ 表示第 $i$ 行的黑色的数量，$l_i$ 表示第 $i$ 列的黑色的数量）。

那么答案就是 

$$\min_{i=1}^n[{n-h_i+1\times(l_i=0)}]+\sum_{i=1}^n{[1\times(l_i\neq n)]}$$

然后代码实现就很简单了。

---


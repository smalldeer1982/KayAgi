# Card Decks

## 题目描述

[problemUrl]: https://atcoder.jp/contests/utpc2021/tasks/utpc2021_i

$ 1 $ から $ M $ までの数が一つずつ書かれた $ M $ 枚のカードからなる山札が $ N $ 個あります。 $ i $ 個目の山札の上から $ j $ 枚目には、 $ a_{i,\ j} $ が書かれています。

あなたはこれらの山札に対して、以下の $ 2 $ 種類の操作をそれぞれ好きな順に何度でも行うことができます。

- 操作 $ 1 $：山札を $ 1 $ つ選び、一番上のカードを、同じ山札の一番下に移動させる。
- 操作 $ 2 $：$ N $ 個の山札の一番上のカードに書かれている数が全て同じなら、それらを全て取って食べる。

全てのカードを食べるために必要な操作 $ 1 $ の回数の最小値はいくつですか？

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ M\ \le\ 22 $
- $ 1\ \leq\ a_{i,\ j}\ \leq\ M $
- $ a_{i,\ j}\ \neq\ a_{i,\ k} $ $ (j\ \neq\ k) $

### 部分点

- $ 1\ \le\ M\ \le\ 16 $ を満たすデータセットに正解した場合は $ 30 $ 点が与えられる。

### Sample Explanation 1

次のように操作を行えばよいです。 - 山札 $ 2 $ に対して操作 $ 1 $ を行う。 - 山札 $ 4 $ に対して操作 $ 1 $ を行う。 - 操作 $ 2 $ を行う。（全ての山札の一番上のカードは $ 2 $ である。） - 山札 $ 1 $ に対して操作 $ 1 $ を行う。 - 山札 $ 2 $ に対して操作 $ 1 $ を行う。 - 操作 $ 2 $ を行う。（全ての山札の一番上のカードは $ 1 $ である。） - 操作 $ 2 $ を行う。（全ての山札の一番上のカードは $ 3 $ である。）

## 样例 #1

### 输入

```
4 3
2 3 1
1 2 3
2 1 3
3 2 1```

### 输出

```
4```

## 样例 #2

### 输入

```
7 6
1 2 3 4 5 6
3 5 6 1 4 2
2 5 4 3 6 1
5 1 2 4 6 3
3 2 6 5 4 1
4 1 2 5 3 6
6 5 4 3 1 2```

### 输出

```
35```

# 题解

## 作者：DaydreamWarrior (赞：2)

设状态为 $f_{s,i}$ 表示删掉了 $s$ 这个集合内的数，最后一个删掉的为 $i$。

转移是 $j\notin s$，计算吃掉 $i$ 后到要去吃 $j$ 要多少次操作，也就是他们中间有多少张牌。可以 $O(nm^3)$ 预处理，在转移时 $O(m)$ 计算贡献，总复杂度 $O((n+2^m)m^3)$。

假设吃掉牌的顺序为 $p_1,p_2,\dots,p_m$，注意到操作 $1$ 的次数为 $p_{i-1}$ 在 $p_i$ 下的 $m-i$ 的和。

感性理解一下，实际上需要得到一张牌被送入牌堆底的总次数，如果 $p_{i-1}$ 在 $p_i$ 下，$p_i$ 到 $p_{i-1}$ 的牌会在删 $p_{i-1}$ 这一轮被送到牌堆底，剩下的会在删 $p_i$ 这一轮都被送到牌堆底，被操作的数量是 $m-i$。对于 $p_{i-1}$ 在 $p_i$ 上的情况，$p_{i-1}$ 和 $p_i$ 之间的牌会和某次删牌构成之前的情况从而被统计贡献。

$O(m^2)$ 预处理，总复杂度 $O((n+2^m)m^2)$。

```cpp
const int N = 22;
int f[1<<N][N];
int a[N],c[N][N];
int n,m;

int main(){
    n = in,m = in;
    for(int k=0;k<n;k++){
        for(int j=0;j<m;j++){
            a[j] = (int)in-1;
            for(int i=0;i<j;i++)
                c[a[i]][a[j]]++;
        }
    }
    memset(f,0x3f,sizeof(f));
    for(int k=0;k<m;k++)
        f[1<<k][k] = 0;
    for(int k=1;k<(1<<m);k++){
        int w = __builtin_popcount(k);
        for(int j=0;j<m;j++)
            if((k>>j)&1)
                for(int i=0;i<m;i++)
                    if(!((k>>i)&1))
                        f[k^(1<<i)][i] = min(f[k^(1<<i)][i],f[k][j]+(m-w)*c[i][j]);
    }
    int ans = 1e9;
    for(int k=0;k<m;k++)
        ans = min(ans,f[(1<<m)-1][k]);
    cout << ans;
    return 0;
}
```

---


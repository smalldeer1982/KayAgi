# [AGC040B] Two Contests

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc040/tasks/agc040_b

$ 1 $ から $ 10^9 $ までの番号のついた $ 10^9 $ 人が参加する大会があります． この大会では，$ 2 $ 回のコンテストが行われます．

コンテストで出題する問題として，$ 1 $ から $ N $ までの番号のついた $ N $ 問が準備されています． 問題 $ i $ が出題された場合，番号が $ L_i $ 以上 $ R_i $ 以下の参加者は全員正解し，逆にそれ以外の参加者は誰も解けません．

これらの $ N $ 問を，$ 2 $ 回のコンテストに分けて出題します． どの問題も，ちょうど $ 1 $ 回のコンテストで出題されなくてはいけません． また，どちらのコンテストも，少なくとも $ 1 $ 問以上の問題が出題される必要があります．

それぞれのコンテストの**楽しさ**は，そのコンテストの全ての問題を解く参加者の人数です． $ 2 $ 回のコンテストの楽しさの和としてありうる最大の値を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ L_i\ \leq\ R_i\ \leq\ 10^9 $
- 入力される値はすべて整数である．

### Sample Explanation 1

以下のようにするのが最適です． - $ 1 $ 回目のコンテストで問題 $ 1,3 $ を出題する．人 $ 5,6,7 $ がこのコンテストの問題を全て解くので，コンテストの楽しさは $ 3 $ である． - $ 2 $ 回目のコンテストで問題 $ 2,4 $ を出題する．人 $ 2,3,4 $ がこのコンテストの問題を全て解くので，コンテストの楽しさは $ 3 $ である． - $ 2 $ 回のコンテストの楽しさの和が $ 6 $ になる．楽しさの和を $ 6 $ より大きくすることは出来ない．

## 样例 #1

### 输入

```
4
4 7
1 4
5 8
2 5```

### 输出

```
6```

## 样例 #2

### 输入

```
4
1 20
2 19
3 18
4 17```

### 输出

```
34```

## 样例 #3

### 输入

```
10
457835016 996058008
456475528 529149798
455108441 512701454
455817105 523506955
457368248 814532746
455073228 459494089
456651538 774276744
457667152 974637457
457293701 800549465
456580262 636471526```

### 输出

```
540049931```

# 题解

## 作者：Accelessar (赞：3)

介绍一个比较直观的想法。

考虑从相互包含的区间入手。  
对于区间 $a\sube b$，如果 $b$ 和 $a$ 分在同一组，则不会影响答案；如果不分在同一组，且另一组此时非空，那么有可能会使答案减小。  
所以 $a,b$ 分在同一组不劣，且 $b$ 不会有任何贡献。

我们只留下被包含的区间。那么将这些区间按左端点排序后，右端点也是升序，最优策略一定是分成一段前缀和一段后缀。  
证明可以考虑调整法，从前缀和后缀中各选一个数交换，答案一定不会更优。

那么预处理前缀答案和后缀答案即可。

但是注意，我们一开始的结论是基于 “另一组此时非空” 的。所以如果 $b$ 单独成一组，就有可能得到更优的答案。计算每个区间单独成组的答案即可。

时间复杂度 $O(n\log n)$。

[submission](https://atcoder.jp/contests/agc040/submissions/62822026).

---

## 作者：约瑟夫用脑玩 (赞：2)

艹（一种植物）我又不会做 AGC B 了，而且还没有题解，还是来写一篇吧。

考虑每个区间最大的左端点 $mxl$，每个区间最小的右端点 $mnr$：

1. 如果这两个端点是一个区间带来的，即 $\exists i,l_i=mxl,r_i=mnr$，那么其他区间肯定都包含 $[mxl,mnr]$，所以无论谁和 $[mxl,mnr]$ 放在一起最后的交集都是 $[mxl,mnr]$。

   那么我们就最大化另一个交集的长度，显然把其他区间中最长的那个拎出来丢到另一个集合即可，如样例2。
  
1. 如果这两个端点不是一个区间带来的，并且 $n>2$，那么我们还是可以把这两个区间放在同一个集合使交集为 $[mxl,mnr]$，那么另一个交集还是其他区间中最长的长度。

1. 考虑这两个端点不是一个区间带来的，并且分别放在两个集合中。

   那么最后的交集肯定为 $[mxl,r_x],[l_y,mnr]$，枚举 $r_x$ 是多少，然后由于要求交集直接取剩下最大的 $l_y$ 即可。
   
   显然先排个序再做个后缀 $\max$，就可以直接得到。
   
   当然不要忘了 $mxl,mnr$ 对应的区间对 $r_x,l_y$ 带来的影响。
   
复杂度 $O(n\log{n})$，瓶颈在于排序，如果你足够闲写基排的话当然就是 $O(n)$ 的了。

[代码](https://www.luogu.com.cn/paste/d12bdmhr)还是放一下。

Upd：补充了代码。

---

## 作者：Unnamed114514 (赞：1)

[广告](https://www.luogu.com.cn/blog/556362/solution-at-agc040-b#)

[《关于我没写返回值导致 RE 这件事》](https://www.luogu.com.cn/record/list?pid=AT_agc040_b&orderBy=0&status=&page=1&user=556362)

***

容易想到，对于一个区间集：${[l_i,r_i]}$，所有的区间交为：$[\max\{l_i\},\min\{r_i\}]$，当然，当 $\max\{l_i\}>\min\{r_i\}$ 时，该区间为空。

所以，有两个数的地位不可动摇，它们就是：$x=\max\limits_{i=1}^nl_i,y=\min\limits_{i=1}^nr_i$。

所以，我们可以对这两个点的位置关系进行讨论：

- $x$ 和 $y$ 在同一集合内。

注意到此时无论这个集合中添加了多少区间，答案都是由 $x$ 和 $y$ 决定。所以，我们可以最大化另一个区间的交。于是，我们就可以只将长度最长的区间放进去即可。

- $x$ 和 $y$ 不在同一集合内

令 $x$ 在集合 $1$，$y$ 在集合 $2$。

那么集合 $1$ 的贡献就是 $\max(\min\limits_{\forall i\in1}\{r_i\}-x+1,0)$，集合 $2$ 的贡献就是 $\max(y-\max\limits_{\forall i\in2}\{l_i\}+1,0)$。

此时把 $\min,\max$ 外面的东西一起带入到里面来：集合 $1$ 就是 $\max(\min\limits_{\forall i\in1}\{r_i-x+1\},0)$，集合 $2$ 就是 $\max(\min\limits_{\forall i\in2}\{y-l_i+1\},0)$。

那么此时我们 $i$ 的贡献已经很明显了：对 $1$ 贡献 $a_i=r_i-x+1$，对 $2$ 贡献 $b_i=y-l_i+1$。

那么答案就是 $\max \max\limits_{i\in1}\{a_i\}+\min\limits_{i\in2}\{b_i\}$。

我们可以先确定前者：假如我们第一次得到了前者 $a_i$，那么对于所有 $a_j<a_i$，我们只能加入集合 $2$；对于 $a_j>a_i$， 此时加入集合 $1$ 对答案没有影响，但是加入集合 $2$ 就会使答案有可能变小，所以加入集合 $1$；对于 $a_j=a_i$，我们按照 $b$ 降序排序，那么因为 $b$ 逐渐减小时，$a_i$ 不变，那么答案变得更小，所以 $j$ 应该假如集合 $1$，并且此时遇到的第一个 $a_i$ 一定是最大的。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,lmax,rmin,y,minx=INT_MAX,ans,l[maxn],r[maxn];
struct node{
	int a,b;
	inline bool operator <(const node &o) const{
		return a<o.a||(a==o.a&&b>o.b);
	}
}f[maxn];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d%d",&l[i],&r[i]);
	lmax=l[1],rmin=r[1];
	for(int i=2;i<=n;++i){
		lmax=max(l[i],lmax);
		rmin=min(rmin,r[i]);
	}
	for(int i=1;i<=n;++i){
		ans=max(ans,r[i]-l[i]+1+max(rmin-lmax+1,0));
		f[i]=node({max(r[i]-lmax+1,0),max(rmin-l[i]+1,0)});
	}
	sort(f+1,f+n+1);
	for(int i=1;i<n;++i){
		minx=min(minx,f[i].b);
		ans=max(ans,minx+f[i+1].a);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_zhy (赞：1)

[Link](https://www.luogu.com.cn/problem/AT_agc040_b)。

我们要把 $n$ 个区间分成两组，每组的答案是这一组所有区间的交集，
问两组的答案之和最大是多少。

我们先来想一想，怎么算交集呢？

其实就是我们要找到一个区间被每个区间所包含。也就是这个区间中的每个点都大于所有区间的左端点并且小于每个区间的右端点。

那我们该如何确定这个被所有区间包含的区间呢？我们确定其左端点和右端点。

而左端点就是所有区间左端点的最大值，右端点是所有区间右端点的最小值，这样就保证了这个区间最左的端点在所有区间左端点的右边，最又的端点在所有区间右端点的左边。

而我们这道题肯定就需要求到所有区间中最大的左端点 $max_l$，以及最小的右端点 $min_r$。

那么自然就想到答案有两种情况。

- $max_l$ 和 $min_r$ 在不同组。

- $max_l$ 和 $min_r$ 在一组。

在不同组的话，$max_l$ 这一组的交集按上面的求法，要找到这一组最小的右端点 $min_r'$，答案就是 $min_r' - max_l + 1$。

$min_r$ 这一组就要找到这一组最小的右端点 $max_l'$，答案就是 $min_r - max_l' + 1$。

**注意：由于不确定 $min_r'$，$max_l$，$min_r$，$max_l'$ 的大小关系，所以求答案时要与 $0$ 比一个更大的值。**

我们要求 $min_r' - max_l + 1$ 和 $min_r - max_l' + 1$。

其实我们就可以将输入时每个区间的 $l$，$r$ 与 $max_l$ 和 $min_r$ 先进行相减，用 $x$，$y$ 两个变量存在结构体中，然后再枚举每个区间去哪个组即可。

那我们如何枚举呢？爆搜吗？肯定不是。

我们来想一下，因为我们第一个区间的答案是 $min_r' - max_l + 1$，也就是 $min_x - max_l + 1$（$x$ 是结构体中变量）。

所以我们可以根据 $x$ 排序，这样，在遍历时可以保证第一组中答案一直为 $x$，同时，我们找 $y$ 的最小值为第二组答案。然后一边循环一边与 $ans$ 比较。

如果 $max_l$ 和 $min_r$ 在同一组，那么这一组答案就是 $max(max_l - min_r + 1, 0)$，为了保证另一组答案最大我们把经量多的区间放在第一组，第二组只留下最长的区间。

可能有一点抽象，见代码。

### code

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 1e5 + 5;

int n, l[N], r[N], mi_r = 1e9, ma_l, ma_le, ans, s;
struct node {
	int x, y;
	bool operator<(node X) const { return x > X.x; } //按x排序。 
} a[N];

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d %d", &l[i], &r[i]), mi_r = min(mi_r, r[i]), ma_l = max(ma_l, l[i]), ma_le = max(ma_le, r[i] - l[i] + 1);	//求r最小值，l最大值以及最大的区间长度。 
	ans = max(mi_r - ma_l + 1, 0) + ma_le;	//max_l与min_r在一组时。 
	for (int i = 1; i <= n; i++)
		a[i].x = max(0, r[i] - ma_l + 1), a[i].y = max(0, mi_r - l[i] + 1);	//将每个区间左右端点与max_l，min_r作差，方便接下来计算。 
	sort(a + 1, a + n + 1);
	s = a[n].y;	//s为当前第二组也就是min_r这一组的答案。 
	for (int i = n; i; i--)
		ans = max(ans, s + a[i].x), s = min(s, a[i].y);	//一定要先更新答案再计算s，因为一个区间不可以同时出现在一组中。 
	printf("%d\n", ans);
	return 0;	
}
```

---

## 作者：gi_A (赞：0)

先找出左端点最大的区间 $L$ 和右端点最小的区间 $R$。（$L$ 和 $R$ 的交集就等于所有区间的交集。）

分两种情况进行讨论：

- $L,R$ 都在 $A$ 组。显然可以在 $A$ 组无限制地加区间，使得 $B$ 组的交集最大。因此可以只将长度最大的区间分到 $B$ 组。（如果该区间是 $L$ 或 $R$，也可以在另一种情况中得到更优或相等的答案。）

- $L,R$ 分别在 $A,B$ 两组中。（如果 $L=R$，相当于再新加一个区间，不会有影响。）

	若一些区间分到了 $A$ 组，对答案贡献：$\max(\min\{r_i\}-L.l+1,0)$。
    
    若一些区间分到了 $B$ 组，对答案贡献：$\max(R.r-\max\{l_i\}+1,0)$。
    
    对每一个区间设 $a_i=\max(r[i]-L.l+1,0),b_i=\max(R.r-l[i]+1,0)$
    
    答案相当于 $\max(\min\{a_i\}+\min\{b_j\})$。
    
    考虑每一个 $a_i$ 作为选择的最小值，相应的最大的 $b$ 一定为 $\min\{b_j\},a_j<a_i$。
    
    将区间按照 $a$ 值从大到小排序，每次找后缀最小的 $b$ 即可。
    
核心代码：

```cpp
bool cmp(const qj &x,const qj &y){
	if(x.a==y.a)return x.b<y.b;
	return x.a>y.a;
}
int main()
{
	n=read();R=1e9;L=0;
	for(int i=1;i<=n;i++){l[i]=read();r[i]=read();}
	for(int i=1;i<=n;i++){
		R=min(R,r[i]);
		L=max(L,l[i]);
	}
	for(int i=1;i<=n;i++)s=max(s,r[i]-l[i]+1);
	ans=s+max(0,R-L+1);
	for(int i=1;i<=n;i++){
		x[i].a=max(r[i]-L+1,0);
		x[i].b=max(R-l[i]+1,0);
	}
	sort(x+1,x+1+n,cmp);
	int ss=x[n].b;
	for(int i=n-1;i>=1;i--){
		ans=max(ans,ss+x[i].a);
		ss=min(ss,x[i].b);
	}
	cout<<ans;
	return 0;
}
```


---


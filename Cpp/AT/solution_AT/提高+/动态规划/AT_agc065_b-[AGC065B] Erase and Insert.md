# [AGC065B] Erase and Insert

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc065/tasks/agc065_b

$ (1,2,\dots,N) $ の順列 $ P $ が与えられます。また、$ (1,2,\dots,N) $ の順列 $ Q=(1,2,\dots,N) $ があります。

$ Q $ に以下の操作を $ i=1,2,\dots,N $ の順で行います。

- $ Q $ から $ i $ を削除し、$ Q $ に $ i $ を $ 1 $ 個自由な場所に挿入する。
 
$ N $ 個の操作が終わった後に $ P,Q $ が等しくなるような操作方法の個数を $ 10^9+7 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 5000 $
- $ P $ は $ (1,2,\dots,N) $ の順列
 
### Sample Explanation 1

例えば、以下のような操作をすると最終的に $ Q\ =\ (1,2,3) $ となります。 - $ Q=(1,2,3) $ から $ 1 $ を削除し、$ 2,3 $ の間に $ 1 $ を挿入する。$ Q=(2,1,3) $ となる。 - $ Q=(2,1,3) $ から $ 2 $ を削除し、$ Q $ の末尾に $ 2 $ を挿入する。$ Q=(1,3,2) $ となる。 - $ Q=(1,3,2) $ から $ 3 $ を削除し、$ Q $ の末尾に $ 3 $ を挿入する。$ Q=(1,2,3) $ となる。 この例を合わせて、最終的に $ Q=(1,2,3) $ となる操作方法は $ 5 $ 個あります。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
4
2 4 1 3```

### 输出

```
11```

## 样例 #3

### 输入

```
15
7 5 14 10 4 2 3 6 8 11 12 1 15 13 9```

### 输出

```
306264```

## 样例 #4

### 输入

```
30
15 19 13 11 22 27 21 25 1 12 30 28 16 26 10 14 20 2 5 7 23 4 17 6 29 3 18 9 8 24```

### 输出

```
33525150```

# 题解

## 作者：Acoipp (赞：2)

## 分析

正着做不好考虑，反过来，每次从 $P$ 中删去 $i$ 然后再添加 $i$，$i$ 从 $n$ 取到 $1$，最后要求 $P$ 是一个排列的方案数。

容易发现对 $i$ 决策的时候我们可以知道 $i+1 \sim n$ 的相对位置一定递增，不然不可能最后是排列，那么我们就可以记录 $i+1$ 的位置 $j$，那么 $i$ 的位置一定最终在 $i+1$ 的位置左边。

并且当得知 $j$ 的时候我们也顺便可以知道 $i$ 的位置是在 $j$ 的哪边，因为 $1 \sim i$ 都没有动过，并且 $i+1$ 是 $i+1 \sim n$ 这些元素中最左边的一个，所以判断是简单的，看 $i$ 在 $P$ 中之前的元素有多少 $\le i$ 即可，如果这些元素数量（包含 $i$ 本身）小于等于 $j$，那么 $i$ 在 $i+1$ 的右边；否则 $i$ 在 $i+1$ 的左边。

当 $i$ 在 $i+1$ 左边的时候，$i$ 的位置只能取到 $<j$，但是当 $i$ 在 $i+1$ 右边的时候，$i$ 的位置可以取到 $\le j$，这个结论比较容易发现。

然后用差分优化前缀和加即可，时间复杂度 $O(n^2)$，空间可以用滚动数组优化到 $O(n)$。

## 代码

代码如下，仅供参考：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define N 5005
using namespace std;
ll n,i,j,k,a[N],dp[2][N];
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(i=1;i<=n;i++) cin>>a[i];
	for(i=1;i<=n;i++) dp[n&1][i]=1;
	for(i=n-1;i>=1;i--){
		ll cnt = 0;
		for(j=1;j<=n;j++){
			if(a[j]<=i) cnt++;
			if(a[j]==i) break;
		}
		for(j=1;j<=n;j++) dp[i&1][j]=0;
		for(j=1;j<=n;j++){
			if(j>=cnt+1){
				dp[i&1][1]+=dp[(i+1)&1][j];
				dp[i&1][j]-=dp[(i+1)&1][j];
			}
			else{
				dp[i&1][1]+=dp[(i+1)&1][j];
				dp[i&1][j+1]-=dp[(i+1)&1][j];
			}
		}
		for(j=1;j<=n;j++) dp[i&1][j]=(dp[i&1][j]+dp[i&1][j-1])%mod,dp[i&1][j]=(dp[i&1][j]%mod+mod)%mod;
	}
	cout<<dp[1][1]<<endl;
	return 0;
}
```

---

## 作者：dalao_see_me (赞：1)

和目前题解区的其他做法不太一样。

考虑直接把 $1,2,\dots,n$ 和新序列 $Q$ 放到一起称为 $A$，即 $A$ 中有 $2n$ 个元素，其中 $n$ 个元素来自序列 $Q$（相对顺序不变，下同），另外 $n$ 个位置来自 $1,2,\dots,n$。我们将来自初始序列的数字和序列 $Q$ 中的相同数字认为是不同的。

很明显，此时 $A$ 的数量与操作序列的数量是不同的。原因在于当插入某一个 $i$ 时，序列 $P$ 中不存在 $\le i$ 的元素，而 $A$ 中我们可能会将 $i$ 放在这些元素的后面。因此我们钦定，序列 $A$ 中任意来自 $Q$ 的元素 $i$ 的后面都不能有来自初始序列的 $\le i$ 的元素。容易证明现在的 $A$ 和操作方案形成双射。

现在可以对 $A$ 进行计数，设 $f_{i,j}$ 表示 $A$ 中的前 $i+j$ 个数字来自 $1,2,\dots,i$ 和 $Q$ 的前 $j$ 项。转移是容易的。

```cpp
void Solve() {
    n = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    f[0][0] = 1;
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= n; j++) {
            if (i < n) add(f[i + 1][j], f[i][j]);
            if (j < n && j + 1 > a[i]) add(f[i][j + 1], f[i][j]);
        }
    printf("%d\n", f[n][n]);
}
```

---

## 作者：2008verser (赞：1)

我们对这个操作直观感受一下，就是把一个元素拎出来放到一个位置上。

你考虑不断操作 $1,2,\ldots,n$，操作完 $1\sim i$ 时，$1\sim i$ 在此时序列中的相对顺序是遵循终点的。

但是这 dp 不了。套路地，倒放以后就是从 $P$ 弄到 $(1,2,\ldots,n)$。正确性由对操作的直观理解可以很简单感受到。

这时从 $n$ 开始操作。你会惊讶地发现 $n,n-1,\dots,1$ 的终点也是有序的。

设 $f_{i,j}$ 表示考虑完 $n\sim i$，$i$ 左边有 $j$ 个数（考虑过的数肯定在 $i$ 右边）的方案数。新操作一个 $i-1$ 就是插进 $j+1$ 个空里（如果 $i-1$ 在 $i$ 左边就是 $j$ 个空）。简单转移优化即可。

[AC 链接](https://atcoder.jp/contests/agc065/submissions/60814002)

---


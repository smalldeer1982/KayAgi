# [ARC131D] AtArcher

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc131/tasks/arc131_d

りんごさんはアーチェリーの大会「AtArcher」に出場しました。

AtArcher では、数直線上に表される的に $ N $ 本の矢を撃って合計得点を競います。的の中心は座標 $ 0 $ であり、矢が当たった位置に応じて以下のように得点が定められています。

- $ i\ =\ 0,\ 1,\ \dots,\ M-1 $ に対して、中心からの距離が $ r_i $ から $ r_{i+1} $ までの場所に当てると $ s_i $ 点を獲得し、中心からの距離が $ r_M $ より大きい場所に当てると $ 0 $ 点を獲得する。**境界に当たった場合は高い方の得点になる。**
- 中心から近いほど高得点が得られるようになっている。すなわち、次を満たす。
  - $ 0\ =\ r_0\ \lt\ r_1\ \lt\ \cdots\ \lt\ r_{M-1}\ \lt\ r_M $
  - $ s_0\ \gt\ s_1\ \gt\ \cdots\ \gt\ s_{M-1}\ \gt\ 0 $

例えば、$ r\ =\ (0,\ 2,\ 7,\ 9),\ s\ =\ (100,\ 70,\ 30) $ の場合、得点は下図のようになります。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc131_d/87bb83172b692d63b862011e8b84e6414b495125.png) 

さらに、AtArcher では「どの $ 2 $ 本の矢も距離 $ D $ 以上の間隔を空ける」という特殊ルールがあります。これに違反した場合は失格となり、全体の得点が $ 0 $ 点になります。

さて、りんごさんが全ての矢を撃ち終わった時点で、最大何点獲得できるでしょう？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ D\ \leq\ 10^6 $
- $ 0\ =\ r_0\ \lt\ r_1\ \lt\ \cdots\ \lt\ r_{M-1}\ \lt\ r_M\ \leq\ 10^{11} $
- $ 10^{11}\ \geq\ s_0\ \gt\ s_1\ \gt\ \cdots\ \gt\ s_{M-1}\ \gt\ 0 $
- 入力はすべて整数

### Sample Explanation 1

この入力例は問題文中の例に対応していますが、$ D\ =\ 3 $ となっています。 例えば、$ N\ =\ 3 $ 本の矢が座標 $ -6,\ -2,\ 1 $ に当たると、それぞれ $ 70,\ 100,\ 100 $ 点を獲得します。このとき合計得点は $ 270 $ 点となり、実現可能なものとしては最大です。 !\[\](https://img.atcoder.jp/arc131/3b9fbfbeaf90d953098e650d7b070e0d.png) なお、すべての矢を $ 100 $ 点のエリアに当てて $ 300 $ 点を取ることはできません。なぜなら、どの $ 2 $ 本の矢も距離 $ D\ =\ 3 $ 以上の間隔を空けなければ、失格で $ 0 $ 点になるからです。

### Sample Explanation 2

この入力例も問題文中の例に対応していますが、$ D\ =\ 8 $ となっています。 例えば、$ N\ =\ 3 $ 本の矢が座標 $ -7,\ 1,\ 9 $ に当たると、それぞれ $ 70,\ 100,\ 30 $ 点を獲得します。このとき合計得点は $ 200 $ 点となり、実現可能なものとしては最大です。 !\[\](https://img.atcoder.jp/arc131/aefdd113cd212d29142783d0ffb1ea1e.png)

### Sample Explanation 3

例えば、下図のように矢を当てると、合計得点は $ 111 $ 点となり、これが最大です。 !\[\](https://img.atcoder.jp/arc131/2058c9b1e1deeea3bc6bae11da70b210.png)

### Sample Explanation 4

$ N\ =\ 100 $ 本の矢を当てることができますが、失格にならないためには、得点が入るゾーンに $ 3 $ 本までしか入れることができません。

## 样例 #1

### 输入

```
3 3 3
0 2 7 9
100 70 30```

### 输出

```
270```

## 样例 #2

### 输入

```
3 3 8
0 2 7 9
100 70 30```

### 输出

```
200```

## 样例 #3

### 输入

```
7 5 47
0 10 40 100 160 220
50 25 9 6 3```

### 输出

```
111```

## 样例 #4

### 输入

```
100 1 5
0 7
100000000000```

### 输出

```
300000000000```

## 样例 #5

### 输入

```
15 10 85
0 122 244 366 488 610 732 854 976 1098 1220
10 9 8 7 6 5 4 3 2 1```

### 输出

```
119```

# 题解

## 作者：EuphoricStar (赞：2)

观察可以发现：

- 使每支箭的距离都为 $D$ 一定不劣；
- 每支箭坐标一定为整数；
- 设最左边的箭坐标为 $x$，那么 $x$ 太小时可以把最左边的箭移到最右边，$x$ 太大时可以把最右边的箭移到最左边。计算可得 $x$ 的最优取值范围为 $x \in [-\left\lfloor\frac{ND}{2}\right\rfloor, -\left\lfloor\frac{ND}{2}\right\rfloor + D)$。

这样枚举 $x$ 就得到了一个 $O(mD)$ 做法。

考虑与其单独算每个 $x$ 的得分，不如把所有 $x$ 放在一起考虑，单独算每个线段的贡献。预处理出 $(l_i, r_i, v_i)$ 表示坐标落在 $[l_i, r_i)$ 的箭能得 $v_i$ 分，对于一个固定的 $x$，差分可得坐标落在这个区间内的箭的数量为：

$$\max(\min(\left\lceil\frac{r_i - x}{D}\right\rceil, n), 0) - \max(\min(\left\lceil\frac{l_i - x}{D}\right\rceil, n), 0)$$

发现因为 $x$ 取值区间长度为 $D$，所以上面式子中左、右项的值最多变一次。二分出极长相同区间后，对这个范围的 $x$ 的答案区间加上面式子乘上 $v_i$，可以使用差分。

时间复杂度 $O(m \log D + D)$。

[code](https://atcoder.jp/contests/arc131/submissions/41186695)

---

## 作者：Phartial (赞：2)

## 题意

数轴上有一个箭靶以 $0$ 为轴心左右对称，给定每个得分区域的范围和分值，要求射 $N$ 支箭在靶上，且任意两支箭的距离不少于 $D$，求最大得分。保证从中心向两侧分数不增。特别的，如果有一只箭射在了分界点上，以较大得分为准。

## 思路

结论一：最优方案中，每只箭必定射在整点上。

显然。

结论二：最优方案中，两只相邻箭之间的距离必定恰好为 $D$。

因为分数的单调性，我们可以把更靠外的那支箭往中心压，肯定不劣。

我们定义一支箭为中心箭当且仅当以其为中心将箭靶分成左右两半，左边箭的数量和右边箭的数量相差不超过 $1$。

结论三：最优方案中，最靠近中心的那支箭必定是中心箭。

若中心箭不最靠近中心，我们可以把箭较多的那一部分取一支箭射到另一边，由于分数的单调性，肯定不劣。

结论四：最优方案中，以 $0$ 为对称轴翻折，$[0,D)$ 中必定有一支箭，且其为中心箭。

显然。

于是考虑枚举靠右的中心箭的位置，那么 $<0$ 的部分有恰好 $\lfloor \dfrac{N}{2}\rfloor$ 支箭，$\ge 0$ 的部分有恰好 $\lceil\dfrac{N}{2}\rceil$ 支箭。知道中心箭的位置后，我们可以推出剩下 $N-1$ 支箭的位置，于是我们就得到了一个 $O(ND)$ 的解法。

考虑优化，可以发现，当我们把左半边和右半边分开考虑，那么分数的每一个分界点最多被跨越一次，换句话说，分数的变化次数最多为 $O(M)$ 次。于是考虑维护分界点与跨越事件，每次只更新被跨越的分界点，时间复杂度 $O(N+D+M)$。

```cpp
#include <iostream>
#include <vector>

using namespace std;
using LL = long long;

const int kM = 1e5 + 1, kD = 1e6 + 1;

int n, m, d;
LL r[kM], s[kM], ans, ns, sd[2][kD];
vector<int> l[kD];

void G(LL n, int o) {
  ns = 0;
  for (int i = 0, j = 0; i < n; ++i) {
    for (; j < m && 1LL * i * d > r[j + 1]; ++j) {
    }
    ns += s[j];
  }
  sd[o][0] = ns;
  for (int p = 1; p <= d; ++p) {
    for (int i : l[p - 1]) {
      if (r[i + 1] < p + (n - 1LL) * d) {
        ns += s[i + 1] - s[i];
      }
    }
    sd[o][p] = ns;
  }
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> d;
  for (int i = 0; i <= m; ++i) {
    cin >> r[i];
  }
  for (int i = 0; i < m; ++i) {
    cin >> s[i];
    l[r[i + 1] % d].push_back(i);
  }
  G(n / 2, 0), G((n + 1) / 2, 1);
  for (int i = 0; i < d; ++i) {
    ans = max(ans, sd[1][i] + sd[0][d - i]);
  }
  cout << ans;
  return 0;
}
```


---

## 作者：Sampson_YW (赞：1)

显然肯定是越靠近中心答案越优，且相邻两个球之间的间距肯定恰好等于 $D$。

将第 $\lfloor\frac{n}{2}\rfloor+1$ 个球放到 $x=0$ 原点上，然后将所有球一点一点向右平移。平移一定距离后会有些球的所在区域发生变化，且容易发现同一个区域交界处如果被不同的球经过了两次，那么答案肯定不优。因为可以将最右边的球放到最左边。

那么用个堆维护当前最小需要的位移量才会让某个球的所在区域变化，并记录一下是哪个球就行了。

[code](https://atcoder.jp/contests/arc131/submissions/48050892)

---


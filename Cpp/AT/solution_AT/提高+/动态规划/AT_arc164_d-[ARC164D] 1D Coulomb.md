# [ARC164D] 1D Coulomb

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc164/tasks/arc164_d

長さ $ 2N $ で `+` , `-` が $ N $ 個ずつからなる文字列 $ s $ に対して次の問題を考え、その答えを $ p(s) $ と書くことにします。

> 数直線上の $ x=1,2,3,\ldots\ ,\ 2N $ の位置に $ 2N $ 個のボールが並んでおり、そのうち $ N $ 個は $ +1 $ の、残りの $ N $ 個は $ -1 $ の電荷を持ちます。ボールの持つ電荷の並び方は $ s $ によって表され、$ s $ の $ i $ 文字目が `+` であれば $ x=i $ には $ +1 $ の電荷を持つボールが、`-` であれば $ x=i $ には $ -1 $ の電荷を持つボールが配置されていることを表します。
> 
> それぞれのボールは、次の規則にしたがって、一斉に運動を始めます。ただし、数直線上でより小さい数が位置する方向を左、より大きい数が位置する方向を右と呼びます。
> 
> - 各ボールに対して、各時点で $ F $ を次の式で定める  
>    $ F=\lbrace $ $ ( $自身より真に左に存在するボールの電荷の総和$ ) $ $ - $ $ ( $自身より真に右に存在するボールの電荷の総和$ ) $ $ \rbrace $ $ \times $ $ ( $自身の電荷$ ) $
> - 各ボールは各時点で、$ F $ が正であれば右に、負であれば左に、毎秒 $ 1 $ の速さで動く
> - 同時に同じ座標に電荷 $ +1 $ のボールと電荷 $ -1 $ のボールが存在した場合、両者は打ち消しあって消滅する
>  
> このとき、それぞれのボールが運動を始めてから消滅するまでに移動した距離（消滅した座標と初めの座標の差の絶対値）の総和はいくつでしょうか。

長さ $ 2N $ で、`+` , `-` , `?` からなる文字列 $ T $ が与えられます。$ T $ の `?` を `+` または `-` に置換することで得られる、 `+` , `-` が $ N $ 個ずつからなる文字列 $ s $ 全てについての $ p(s) $ の総和を $ 998244353 $ で割った余りを求めてください。

なお、与えられた制約と運動の規則の下で、有限の時間内に全てのボールが消滅すること、ボールが消滅しない限り各ボールの $ F $ の値が $ 0 $ にならないこと、$ 3 $ つ以上のボールが同時に同じ座標に位置する瞬間が無いこと、および $ p(s) $ が整数になることが示せます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 3000 $
- $ N $ は整数である
- $ |T|=2N $
- $ T $ の各文字は `+` , `-` , `?` のいずれかであり、 `+` と `-` はそれぞれ $ N $ 個以下である
 
### Sample Explanation 1

$ T $ から得られる文字列 $ s $ として、 `++--` と `+-+-` が考えられます。 `++--` について、運動を開始した時点では各ボールの左右の電荷の総和、および $ F $ の値は次のようになります。 !\[\](https://img.atcoder.jp/arc164/403850a82c3adfb838197734344ae193.png) したがって、$ x=1,2 $ のボールは右に、$ x=3,4 $ のボールは左に動き始めます。 この場合、各ボールはその後運動の向きを変えることなく、 $ 0.5 $ 秒後に $ x=2,3 $ にあったボールが $ x=2.5 $ で、$ 1.5 $ 秒後に $ x=1,4 $ にあったボールが $ x=2.5 $ でそれぞれ消滅します。 この間に、$ x=2,3 $ にあったボールは $ 0.5 $ ずつ、$ x=1,4 $ にあったボールは $ 1.5 $ ずつの距離を移動しているため、$ p( $ `++--` $ )=4 $ です。 同様に観察すると $ p( $ `+-+-` $ )=2 $ であることが分かるため、求める $ p(s) $ の総和は $ 6 $ となります。

### Sample Explanation 2

$ p(s) $ の総和を $ 998244353 $ で割った余りを出力してください。

## 样例 #1

### 输入

```
2
+??-```

### 输出

```
6```

## 样例 #2

### 输入

```
17
??????????????????????????????????```

### 输出

```
285212526```

# 题解

## 作者：6_curly_L (赞：3)

### 题意

数轴上有 $2N$ 个小球，$N$ 个小球带一个单位的正电荷，剩下的带一个单位的负电荷。分别计算每一个小球左右小球的电荷量的代数和，带正电的小球会向代数和较小的一方移动，带负电的小球相反。

小球移动速度相等，任意时刻内如果带正电的小球与带负电的小球在一个位置上，他们会相互抵消后消失。

定义一个小球移动的距离为起始位置与末尾位置的坐标的差的绝对值。某些小球的电性未定，求所有可能情况下所有小球移动距离之和。

### 分析

首先可以想到，两个小球抵消时对这个区域内的电荷的代数和不会有影响，也就是说一个小球的移动方向是不会改变的。

那么，因为移动速度相同，与一个小球相抵消的小球也是确定的，然后就形成了一个类似于括号匹配的问题。

由于电性不确定，考虑 dp。设 $F_{x,y,0/1}$ 表示前 $x$ 个字符，有 $y$ 个正电荷的总和/方案数。

因为最后相当于求的是配对的小球之间的距离和，我们可以考虑把距离拆开，枚举每一个位置，当前位置的贡献就是目前还未配对的小球个数。

因为能够配对的小球一定会配对，所以我们仅用小球总个数和带正电的个数就能求出未配对的小球个数。

然后转移即可。复杂度 $O(n^2)$

### 代码

```CPP
#include<bits/stdc++.h>
#define N 3010
#define int long long
using namespace std;
const int mod=998244353;

char s[N*2];
int f[N*2][N][2];

signed main(){
	memset(f,0,sizeof(f));
	int n;
	scanf("%lld\n%s",&n,s+1);
	f[0][0][0]=0;
	f[0][0][1]=1;
	for(int i=0;i<2*n;i++){
		int minx=min(i,n);
		for(int j=0;j<=minx;j++){
			if(f[i][j][1]==0) continue;
			int x=j,y=i-j,num=abs(x-y);
			if(s[i+1]=='+'||s[i+1]=='?'){
				f[i+1][x+1][1]=(f[i+1][x+1][1]+f[i][j][1])%mod;
				if(x>=y) f[i+1][x+1][0]=(f[i+1][x+1][0]+f[i][j][0]+(num+1)*f[i][j][1]%mod)%mod;
				else f[i+1][x+1][0]=(f[i+1][x+1][0]+f[i][j][0]+(num-1)*f[i][j][1]%mod)%mod;
			}
			if(s[i+1]=='-'||s[i+1]=='?'){
				f[i+1][x][1]=(f[i+1][x][1]+f[i][j][1])%mod;
				if(x<=y) f[i+1][x][0]=(f[i+1][x][0]+f[i][j][0]+(num+1)*f[i][j][1]%mod)%mod;
				else f[i+1][x][0]=(f[i+1][x][0]+f[i][j][0]+(num-1)*f[i][j][1]%mod)%mod;
			}
		}
	}
	printf("%lld",f[n*2][n][0]);
	return 0;
}
```

---

## 作者：_zzzzzzy_ (赞：3)

# 思路

发现我们可以设 $dp_{i,j}$ 表示前 $i$ 个字母，$+$ 和 $-$ 的个数差 $j$ 的方案数，然后用 $sum_{i,j}$ 表示方案数的距离和。

然后我们对于第 $i$ 个是 $-$，那么就用 $dp_{i-1,j+1}$ 转移过来，然后 $sum$ 同理。

然后 $-$ 和 $?$ 也能写出来。

最后我们考虑怎么用 $dp_{i,j}$ 来转移 $sum_{i,j}$。

发现 $dp_{i,j}$ 的每个方案能够产生 $n-j$ 的贡献。

这里在 $j$ 大于 $n$ 的时候变成 $j-n$。

然后最后的答案就是 $sum_{n\times 2, n}$，$dp_{0,n}$ 的初始化是 $1$。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
const int maxn = 6050, mod = 998244353;
char s[maxn];
i64 dp[maxn][maxn];
i64 sum[maxn][maxn];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.precision(6);

	int n, m;
	cin >> n >> (s + 1);
	m = n * 2;
	dp[0][n] = 1;
	for (int i =  1; i <= m; i++) {
		if (s[i] != '-') {
			for (int j = n - i; j <= n + i; j++) {
				dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
				sum[i][j] = (sum[i][j] + sum[i - 1][j - 1]) % mod;
			}
		} if (s[i] != '+') {
			for (int j = n - i; j <= n + i; j++) {
				dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;
				sum[i][j] = (sum[i][j] + sum[i - 1][j + 1]) % mod;
			}
		}
		for (int j = n - i; j <= n + i; j++) {
			sum[i][j] = (sum[i][j] + (dp[i][j] * abs(n - j)) % mod) % mod;
		}
	}
	cout << sum[m][n];
	return 0;
}
```

---

## 作者：hanjinghao (赞：3)

先考虑一个**没有问号的序列**如何计算答案。我们开一个栈，然后从左往右扫描每一个字符，考虑以下几种情况：

1、当前字符为加号

如果栈内有减号，那么答案加上当前位置减去栈顶减号的位置之差，然后栈顶减号出栈。

否则，这个加号入栈。

2、当前字符为减号

如果栈内有加号，那么答案加上当前位置减去栈顶加号的位置之差，然后栈顶加号出栈。

否则，这个减号入栈。

显然，最后栈一定是空的。

现在考虑**有问号的情况**。为了方便设计状态，我们换一种方法计算答案：

1、加号入栈

答案加上入栈后栈内加号个数。

2、加号出栈

答案加上出栈后栈内加号个数。

3、减号入栈

答案加上入栈后栈内减号个数。

4、减号出栈

答案加上出栈后栈内减号个数。

设 $ f_{i,j} $ 表示前 $ i $ 个字符，加号和减号个数之差为 $ j $ 的答案之和，$ g_{i,j} $ 表示其方案数。为了防止出现负数下标，我们可以把第二维整体加上 $ n $。

转移见代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

template < typename T >
inline void read(T &x)
{
	bool flg = x = 0;
	char c;
	while ((c = getchar()) < 48 || c > 57)
		flg |= c == '-';
	do
		x = (x << 1) + (x << 3) + (c ^ 48);
	while ((c = getchar()) > 47 && c < 58);
	if (flg) x = -x;
}

int OUTPUT[45];

template < typename T >
inline void write(T x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	int len = 0;
	do
	{
		OUTPUT[++len] = x % 10 | 48;
		x /= 10;
	}while (x);
	while (len)
		putchar(OUTPUT[len--]);
}

template < typename T >
inline void writesp(T x)
{
	write(x);
	putchar(32);
}

template < typename T >
inline void writeln(T x)
{
	write(x);
	putchar(10);
}

const int N = 6005, P = 998244353;
char s[N];
int f[N][N], g[N][N];

inline void Add(int &x, int y)
{
	x += y;
	if (x >= P) x -= P;
}

int main()
{
	int n;
	read(n);
	int m = (n << 1);
	scanf("%s", s + 1);
	if (s[1] == '+') f[1][n + 1] = g[1][n + 1] = 1;
	else if (s[1] == '-') f[1][n - 1] = g[1][n - 1] = 1;
	else f[1][n + 1] = g[1][n + 1] = f[1][n - 1] = g[1][n - 1] = 1;
	for (int i = 2; i <= m; ++i)
		if (s[i] == '+')
		{
			for (int j = 1; j <= n; ++j)
				if (g[i - 1][n + j - 1])
				{
					g[i][n + j] = g[i - 1][n + j - 1];
					f[i][n + j] = (f[i - 1][n + j - 1] + (ll)j * g[i - 1][n + j - 1]) % P;
				}
			for (int j = 0; j < n; ++j)
				if (g[i - 1][n - j - 1])
				{
					g[i][n - j] = g[i - 1][n - j - 1];
					f[i][n - j] = (f[i - 1][n - j - 1] + (ll)j * g[i - 1][n - j - 1]) % P;
				}
		}
		else if (s[i] == '-')
		{
			for (int j = 1; j <= n; ++j)
				if (g[i - 1][n - j + 1])
				{
					g[i][n - j] = g[i - 1][n - j + 1];
					f[i][n - j] = (f[i - 1][n - j + 1] + (ll)j * g[i - 1][n - j + 1]) % P;
				}
			for (int j = 0; j < n; ++j)
				if (g[i - 1][n + j + 1])
				{
					g[i][n + j] = g[i - 1][n + j + 1];
					f[i][n + j] = (f[i - 1][n + j + 1] + (ll)j * g[i - 1][n + j + 1]) % P;
				}
		}
		else
		{
			for (int j = 1; j <= n; ++j)
				if (g[i - 1][n + j - 1])
				{
					g[i][n + j] = g[i - 1][n + j - 1];
					f[i][n + j] = (f[i - 1][n + j - 1] + (ll)j * g[i - 1][n + j - 1]) % P;
				}
			for (int j = 0; j < n; ++j)
				if (g[i - 1][n - j - 1])
				{
					g[i][n - j] = g[i - 1][n - j - 1];
					f[i][n - j] = (f[i - 1][n - j - 1] + (ll)j * g[i - 1][n - j - 1]) % P;
				}
			for (int j = 1; j <= n; ++j)
				if (g[i - 1][n - j + 1])
				{
					Add(g[i][n - j], g[i - 1][n - j + 1]);
					Add(f[i][n - j], (f[i - 1][n - j + 1] + (ll)j * g[i - 1][n - j + 1]) % P);
				}
			for (int j = 0; j < n; ++j)
				if (g[i - 1][n + j + 1])
				{
					Add(g[i][n + j], g[i - 1][n + j + 1]);
					Add(f[i][n + j], (f[i - 1][n + j + 1] + (ll)j * g[i - 1][n + j + 1]) % P);
				}
		}
	writeln(f[m][n]);
	return 0;
}
```

---

## 作者：AC_love (赞：2)

如果一个小球的某侧有两个带正电和带负电的小球撞在一起消失了，那么这一侧的电荷总数不变。因此实际上小球运动的方向并不会改变。

那么这个东西的本质其实就是括号匹配。

设 $f(i, j)$ 表示考虑前 $i$ 个小球，其中正电荷小球个数减去负电荷小球个数等于 $j$ 的方案数。$dis(i, j)$ 表示所有方案的小球的运动距离的和。

显然有：

$$f(i, j) = \begin{cases} f(i - 1, j - 1) &\mathrm{if}\ s_i = + \\ f(i - 1, j + 1) &\mathrm{if}\ s_i = - \\ f(i - 1, j - 1) + f(i - 1, j + 1) &\mathrm{if}\ s_i = \texttt{?} \end{cases}$$

方案数很好求，问题是我们怎么根据方案数求出距离呢？

首先，每个 $dis(i, j)$ 都可以从之前的状态转移过来，转移的方式和 $f$ 一样：

$$dis(i, j) = \begin{cases} dis(i - 1, j - 1) &\mathrm{if}\ s_i = + \\ dis(i - 1, j + 1) &\mathrm{if}\ s_i = - \\ dis(i - 1, j - 1) + dis(i - 1, j + 1) &\mathrm{if}\ s_i = \texttt{?} \end{cases}$$

关键是，每个 $f(i, j)$ 能给 $dis(i, j)$ 做多少贡献呢？

考虑当前有 $|j|$ 个电荷没有被消去，每个电荷都需要向右移动 $1$ 的距离，那么每种方案都能提供 $|j|$ 的贡献，$f(i, j)$ 种方案能提供 $f(i, j) \times |j|$ 的贡献。

因此只需要让 $dis(i, j) \leftarrow dis(i, j) + f(i, j) \times |j|$ 即可。

数组下标出现负数处理起来可能会有点麻烦，因此可以给数组第二维整体平移一下。

[code](https://atcoder.jp/contests/arc164/submissions/59540538)

---

## 作者：ny_123457 (赞：1)

## Part 1.思路
本题可以写动态规划通过，本篇题解主要介绍动态规划的做法。  
首先我们可以定义 $f_{i,j}$ 为前 $i$ 个字母中 $+$ 和 $-$ 的个数差 $j$ 的方案数，用一个数组记录它们的距离和，用 $ans$ 数组表示，如果第 $i$ 个是 $-$ 则 $f_{i,j}$ 就应该是 $f_{i-1,j-1}$ 转移过来，另一个记录距离的数组也一样。  
**难点**：$f_{i,j}$ 怎么转移 $ans_{i,j}$？  
可以发现 $f_{i,j}$ 的每个方案能产生 $n-j$ 的价值（当 $j>n$ 时为 $j-n$），此时需要输出的答案就为 $ans_{n \times 2,n}$ 了。  
唯一需要注意的点就是要将 $f_{0,n}$ 初始化为 $1$。
## Part 2.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
char s[6005];
long long n,f[6005][6005],ans[6005][6005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>s[i];
	f[0][n]=1;
	for(int i=1;i<=n*2;i++){
		if(s[i]!='-'){
			for(int j=n-i;j<=n+i;j++){
				f[i][j]=(f[i][j]+f[i-1][j-1])%mod;
				ans[i][j]=(ans[i][j]+ans[i-1][j-1])%mod;
			}
		} 
		if(s[i]!='+'){
			for(int j=n-i;j<=n+i;j++){
				f[i][j]=(f[i][j]+f[i-1][j+1])%mod;
				ans[i][j]=(ans[i][j]+ans[i-1][j+1])%mod;
			}
		}
		for(int j=n-i;j<=n+i;j++){
			ans[i][j]=(ans[i][j]+(f[i][j]*abs(n-j))%mod)%mod;
		}
	}
	cout<<ans[n*2][n];
	return 0;
}
```

---

## 作者：Elairin176 (赞：0)

[Link](https://www.luogu.com.cn/problem/AT_arc164_d)   
dp 小水题。  
注：洛谷翻译在某些细节上有问题，请到原网站查看题意。（因为比较复杂就不放了）   
## 符号定义
$\operatorname{sgn}(x)=\begin{cases}1&x>0\\0&x=0\\-1&x<0\end{cases}$   
## 解法
我们注意到，原子移动的方向恒不变。那么如果把原子移动的左右看成左右括号的话，所有原子的序列正好可以构成一个合法括号序列。而相撞的原子一定是序列中一对匹配的括号。    
根据以上结论，我们要求和的式子无非就变成了 $\sum\limits_{i=1}^{2n}-\operatorname{sgn}(F_i)\times i$，即括号互相匹配。   
于是我们设 $f_{i,j}$ 表示前 $i+j$ 个原子中，有 $i$ 个正原子、$j$ 个负原子的贡献。  
因为我们要对所有情况求和，我们还需要令 $g_{i,j}$ 表示方案数。   
接下来推导转移：   
当 $i+j$ 位置可以为正原子时：  
- $g_{i,j}\gets g_{i,j}+g_{i-1,j}$
- $f_{i,j}\gets f_{i,j}+f_{i-1,j}-\operatorname{sgn}(2i-2j-1)(i+j)g_{i-1,j}$

负原子时同理。   
时间复杂度 $O(n^2)$。   
CODE:   

```cpp
//luogu paste jo5j6ogx
cst int N=3e3;
cst ll p=998244353;
string s;
int n;
ll f[N+10][N+10],g[N+10][N+10];
int main(void){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>s;s="="+s;
	g[0][0]=1;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			if(!(i|j)) continue;
			if(s[i+j]!='-'&&i){
				g[i][j]=madd(g[i][j],g[i-1][j],p);
				f[i][j]=madd(f[i][j],f[i-1][j],p);
				f[i][j]=madd(f[i][j],-sgn<int>((i<<1)-(j<<1)-1)*g[i-1][j]%p*(i+j)%p,p);
			}
			if(s[i+j]!='+'&&j){
				g[i][j]=madd(g[i][j],g[i][j-1],p);
				f[i][j]=madd(f[i][j],f[i][j-1],p);
				f[i][j]=madd(f[i][j],sgn<int>((i<<1)-(j<<1)+1)*g[i][j-1]%p*(i+j)%p,p);
			}
		}
	}
	write(f[n][n]);
	ret 0;
}
```
[Record(Atcoder)](https://atcoder.jp/contests/arc164/submissions/61697110)

---

## 作者：zyc070419 (赞：0)

# [ARC164D]1D Coulomb 题解

### 题意

在长为 $2N$ 的数轴上放有 $2N$ 个小球，第 $i$ 个小球在坐标 $i$ 的位置。 $2N$ 个小球中有 $N$ 个小球带正电，有 $N$ 个小球带负点。记第 $i$ 个小球带 $a_i$ 单位电荷（$a_i\in\{1,-1\}$），小球之间受到力的作用，第 $i$ 个小球受到的力的大小 $F_i=(\sum_{j=1}^{i-1}a_j-\sum_{j=i+1}^{2N}a_j)\times a_i$。小球会进行运动，运动规则如下：

1. 当 $F_i>0$ 时第 $i$ 个小球以每单位时间 $1$ 单位长度的速度匀速向右运动。
2. 当 $F_i<0$ 时第 $i$ 个小球以每单位时间 $1$ 单位长度的速度匀速向左运动。
3. 当 $i$ 号球和 $j$ 号球在某一时刻出现在同一位置并且 $a_i\not=a_j$ 时 $i$ 号球和 $j$ 号球同时消失，记第 $i$ 个球在坐标 $x_i$ 处消失。

分析可知不会有三个小球同时出现在同一个位置，并且最终所有小球均会消失。

现在给出一个长为 $2N$ 的字符串，当第 $i$ 个字符为 $\texttt{+}$ 时表示 $a_i=1$，第 $i$ 个字符为 $\texttt{-}$ 时 $a_i=-1$，第 $i$ 个字符为 $\texttt{?}$ 时表示 $a_i$ 不确定。对于所有合法的可能的小球的电性情况求出 $\sum_{i=1}^{2N}\left |i-x_i\right |$ 的值的和，答案对 $998244353$ 取模。

$N\le 3000$。

### 题解

先考虑没有问号时如何统计答案：

由于两个小球 $i,j$ 当且仅当在 $a_i+a_j=0$ 时相撞才会消失，所以小球的消失对于其他小球受力的大小无影响，也就是说小球运动的方向在消失之前不变。

进一步分析可以发现，小球之间的相撞消失类似于括号匹配，例如：

```
++----+-+-++
```

这个序列可以分成两段恰好电荷和为 $0$ 的子段：

```
++--,--+-+-++
```

对于第一段我们将 $\texttt{+},\texttt{-}$ 分别视作 $\texttt{(},\texttt{)}$。对于第二段我们将 $\texttt{+},\texttt{-}$ 分别视作 $\texttt{)},\texttt{(}$。然后就可以匹配了，具体地：$1-4,2-3,5-12,6-7,8-9,10-11$ 分别进行匹配。 

形式化地来说：我们首先将整个序列划分成若干个不相交的极小的电荷和为 $0$ 的子段，然后对于每一个子段 $s_{l\cdots r}$，将 $s_l$ 这种字符视为 $\texttt{(}$，另一种字符（即 $s_r$ 这种字符）视为 $\texttt{)}$，然后进行括号匹配，匹配上的两个小球相撞消失。那么答案就是所有配对的小球的坐标差的和。

分析完了相撞的性质，考虑怎样统计答案更方便。直接统计不好做。所以套路的改变求和方式，我们考虑 $[i,i+1]$ 这个单位长度被多少对配对的小球经过，记为 $f_i$。换句话说 $f_i$ 就是前 $i$ 个球与后 $n-i$ 个球配对的对数，观察可以发现：
$$
f_i=\left|\sum_{i=1}^{i}a_i\right|
$$
那么答案就是 $\sum_{i=1}^{2N-1}\left|\sum_{j=1}^{i}a_i\right|$。

以上是对于没有 $\texttt{?}$ 的情况的答案的计算，下面说一下有 $\texttt{?}$ 了怎么做。

我们设 $g_{i,j}$ 表示 $\sum_{k=1}^{i}a_k=j$ 的方案数，那么答案就是：
$$
\sum_{i=1}^{2N-1}\sum_{j=-N}^{N}g_{i,j}\times \left|j\right|
$$
而 $g_{i,j}$ 可以组合数计算，具体地：

当前 $i$ 个字符中有 $x$ 个 $\texttt{+}$，$y$ 个 $\texttt{-}$，$z$ 个 $\texttt{?}$。整个字符串中有 $X$ 个 $\texttt{+}$，$Y$ 个 $\texttt{-}$，$Z$ 个 $\texttt{?}$，那么就有：
$$
g_{i,(x+k)-(y+z-k)}=\binom{z}{k}\binom{Z}{N-X-k}
$$
其中 $k$ 是枚举 $z$ 个 $\texttt{?}$ 中有 $k$ 个 $\texttt{?}$ 电荷量为正。

本题到这里就结束了，复杂度 $\mathcal{O}(n^2)$，[代码很短](https://www.luogu.com.cn/paste/yijcazrw)。

---


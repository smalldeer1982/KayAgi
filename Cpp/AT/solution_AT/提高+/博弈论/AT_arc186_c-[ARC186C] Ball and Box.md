# [ARC186C] Ball and Box

## 题目描述

球橋和箱木进行一个用球和箱子的游戏。

一开始，球橋有 $M$ 种不同的球，每种球各有 $10^{100}$ 个，箱木有 $10^{100}$ 日元。同时有 $N$ 个箱子，第 $i$ 个箱子的容量为 $V_i$，价格为 $P_i$ 日元。在游戏过程中，箱木可以随时购买任意箱子。

游戏过程中，以下操作会不断重复，直到游戏结束：

1. 球橋选择一种球，递给箱木。
2. 箱木可以选择接收这个球，或者拒绝接收并结束游戏。
3. 如果箱木接收了球，他需要从已购买的箱子中选择一个，将球放入该箱子。
4. 若放入球后的箱子满足以下条件，箱木获得 $1$ 日元，否则游戏结束：
   - 箱子中的球的数量不超过该箱子的容量。
   - 箱子中的所有球都是同一种类型。

球橋会采取使箱木最终所持金钱尽可能少的最优策略，反之，箱木会采取使自己最终所持金钱尽可能多的最优策略。请问，整个游戏过程中，箱木的所持金钱最多能增加多少？

注意，双方都能看到所有信息。特别地，球橋可以看到每个箱子的容量和价格，以及每个箱子里装了多少、哪种球。并且，箱木的初始资金足够多，不会因为钱不够而无法购买箱子。

对于每个输入文件，需要解答 $T$ 个测试用例。

## 说明/提示

### 数据范围

- $1 \leq T, N, M \leq 3 \times 10^5$
- $1 \leq V_i, P_i \leq 10^9$
- 所有测试用例的 $N$ 之和不超过 $3 \times 10^5$
- 所有输入均为整数

### 样例解释 1

第一个测试用例有 $2$ 种球和 $3$ 个箱子。我们把两种球分别叫做白球和黑球，把第 $i$ 个箱子叫做箱 $i$。以下是箱木最终所持金钱增加 $2$ 日元的一个游戏过程示例：

1. 球橋选择白球递给箱木。
2. 箱木接收球，并以 $1$ 日元购买箱 $2$，将白球放入。
   - 箱 $2$ 里有 $1$ 个白球，满足条件，箱木获得 $1$ 日元。
3. 球橋选择白球递给箱木。
4. 箱木接收球，将白球放入箱 $2$。
   - 箱 $2$ 里有 $2$ 个白球，满足条件，箱木获得 $1$ 日元。
5. 球橋选择黑球递给箱木。
6. 箱木接收球，并以 $1$ 日元购买箱 $3$，将黑球放入。
   - 箱 $3$ 里有 $1$ 个黑球，满足条件，箱木获得 $1$ 日元。
7. 球橋选择白球递给箱木。
8. 箱木接收球，将白球放入箱 $2$。
   - 箱 $2$ 里有 $3$ 个白球，满足条件，箱木获得 $1$ 日元。
9. 球橋选择白球递给箱木。
10. 箱木选择不接收，游戏结束。

最终，箱 $2$ 里有 $3$ 个白球，箱 $3$ 里有 $1$ 个黑球。箱木总共花了 $2$ 日元，获得了 $4$ 日元，因此所持金钱增加了 $2$ 日元。

第二个测试用例中，球橋可以采取让箱木无法赚钱的策略。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
3 2
1 1000000000
3 1
3 1
1 300000
1000000000 1
10 4
22 5
26 45
72 21
47 39
97 2
75 35
82 24
17 46
32 22
28 67```

### 输出

```
2
0
28```

# 题解

## 作者：silhouettel (赞：8)

比较简单的博弈论。 

直接考虑两个人的策略，可以发现，Mr.Box 会想要尽量地让 Mr.Ball 买箱子，因为箱子的价格都是正数，所以 Mr.Ball 买一个箱子对于 Mr.Box 来说一定是不劣的。于是 Mr.Box 的策略就是，先把每种种类的球拿出一个给 Mr.Ball（Mr.Ball 对于每个球都要新买箱子），然后再一直针对容量最小的箱子给球。  

再看 Mr.Ball。因为 Mr.Ball 有结束游戏的权利，所以他一定不会亏钱。把箱子按照容量排序（Mr.Box 只攻击容量最小的箱子），设目前选了 $m$ 个箱子，容量最小的一个箱子在 $t$ 位置。容易发现 $id\in[t,n]$ 的箱子都可以被填满，而 $id\in[1,t)$ 的 $m-1$ 个箱子只会放入一个球。  

按上述策略贪心即可。

---

## 作者：qyy_abc (赞：4)

## AT_arc186_c [ARC186C] Ball and Box

### solution

设选盒子的人为 A，选球的人为 B。显然，A 在还有位置装一个球的时候一定不会买新的盒子，所以游戏停下的位置一定一开始或者某一种颜色的球的箱子装满时。A 的最优策略看起来比较难考虑，但B的就很简单了：如果 A 还没有一种颜色的球，直接选那种颜色的球；否则选盒子容量最小的那种颜色的球。

那么 A 最后选出来的盒子里面，容量前 $m-1$ 大的盒子一定都只有一种颜色的球，后面的盒子一定会装满。否则，在它们即将装不只一个球的时候，B 可以把那个球的颜色改为目前还没有选过的那种颜色的球。

我们将盒子按容量降序排序。设 A 最终选的容量第 $m-1$ 大的箱子在 $k$。那么 $[1,k]$ 的箱子里就只有一个球，$(k,n]$ 的箱子里都会放满 $v_i$ 个球。

枚举第 $m$ 大的箱子的位置，$(k,n]$ 的箱子的最大贡献用后缀最大值是容易维护的。$[1,k]$ 的 $m-1$ 个箱子每个都只有 $1$ 的贡献，所以只要选 $p_i$ 前 $m-1$ 小的箱子即可。维护的方法应该不少，我用的是权值线段树。 

### code

注意一下 $m < n$ 和 $m \le 1$ 的情况。

[Submission](https://atcoder.jp/contests/arc186/submissions/63136141)。

---

## 作者：Coffins (赞：3)

这玩意过的没有 B 多？这玩意有 2400？

首先发现 Mr.Ball 存在如下策略：

挑选一种其对应总剩余容量的最小的颜色，给出这种颜色的球。

这时我们稍加分析可以知道，Mr.Box 最终的对于每个盒子来讲，可以让答案为：容量前 $m-1$ 大的盒子都只装一个，剩下盒子通通装满。

这时发现一个奇妙的事情：只要 Mr.Ball 愿意，答案就一定可以取到这个数；只要 Mr.Box 愿意，答案也一定可以取到这个数。于是最终答案不会比它大，也不会比它小。

于是这就是最终答案。

于是我们枚举这前 $m-1$ 大的盒子最小容量，这样就随便维护以下就好了，$O(n\log n)$。

如果莫名其妙 WA 了，可以确认以下你的程序在 $m=1$ 的时候能不能跑。

https://atcoder.jp/contests/arc186/submissions/59213392

---

## 作者：Claire0918 (赞：2)

Bob 可以在任何时候结束游戏，所以答案至少为 $0$。

最开始 $m$ 次操作，Alice 为了使 Bob 在买盒子上消耗更多，必然会分别给出 $m$ 种小球各一个。至此，已经有了 $m$ 个盒子，每个盒子各一个球。

在此之后，Alice 还想使得 Bob 买更多的盒子，所以她将会选取可放置的位置最少的一种球，将其所有可放置的位置全部放满，并且多给出一个球使得 Bob 必须再买入一个盒子。整理这一过程后的变化，发现原本的一个盒子被放满了，并且多出了一个同类型的仅有一个球的盒子。换而言之，有若干个盒子是填满的，剩下 $m$ 个仅有一个球的盒子。

这样的过程并不会一直持续。Bob 可以在某一个时刻结束游戏。他不可能在买入一个新盒子后再结束游戏，因为一定有 $p_i - 1 \geq 0$。他也不会在 Alice 试图填满某一个盒子时结束游戏，因为 Alice 填的越多对 Bob 越有利。综上，Bob 仅有可能在某个盒子刚被填满时立即结束游戏。此时有若干个盒子是满的，剩下 $m - 1$ 个（比原本 $m$ 个少去原本要新买的一个）盒子仅有一个球。

特别地，$m = 1$ 时一切盒子都可以被填满，所以此时答案为 $\sum_{i = 1}^{n} \max\{v_i - p_i, 0\}$。

Alice 每次填满的是可放置位置最少的一种球，即 $v_x - 1$ 最小的一种球，即 $v_x$ 最小的一种球。所以任何填满的 $v_x$ 将要小于任何没有填满的 $v_y$。所以一切填满的盒子的容量小于等于一切仅有一个球的盒子容量。

形式化地，设 $s$ 为填满的盒子集合，$t$ 为仅有一个球的盒子集合，那么有 $(\forall x \in s, y \in t)(v_x \leq v_y)$。

先将 $(v_i, p_i)$ 按照 $v_i$ 从小到大排序。因为一切填满的盒子的容量小于等于一切仅有一个球的盒子容量，所以必然存在一个 $i$，使得仅有一个球的盒子下标均在 $[i, n]$，填满的盒子下标均在 $[1, i)$。枚举 $i$，$[1, i)$ 的答案为 $\sum_{k = 1}^{i - 1} \max\{v_k - p_k, 0\}$，$[i, n]$ 中选取 $p_i$ 最小的 $m - 1$ 个即可。

时间复杂度 $\mathcal{O}(n \log n)$。

Code：
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a))

using namespace std;

const int maxn = 3e5 + 10;

int t, n, m;
long long res;
pair<int, int> a[maxn];
long long pre[maxn];

int main(){
    scanf("%d", &t);
    while (t--){
        scanf("%d %d", &n, &m), res = 0;
        for (int i = 1; i <= n; i++){
            scanf("%d %d", &a[i].first, &a[i].second);
        }
        sort(a + 1, a + n + 1, [](pair<int, int> x, pair<int, int> y){return x.first < y.first || x.first == y.first && x.second > y.second;});
        for (int i = 1; i <= n; i++){
            pre[i] = pre[i - 1] + max(0, a[i].first - a[i].second);
        }
        priority_queue<int> q;
        long long sum = 0;
        for (int i = n; i; i--){
            if (q.size() < m - 1){
                q.push(a[i].second), sum += a[i].second - 1;
            }else if (!q.empty() && q.top() > a[i].second){
                sum -= q.top() - 1, q.pop();
                q.push(a[i].second), sum += a[i].second - 1;
            }
            if (q.size() == m - 1){
                res = max(res, pre[i - 1] - sum);
            }
        }
        if (m == 1){
            res = max(res, pre[n]);
        }
        printf("%lld\n", res);
    }

return 0;
}
```

---

## 作者：冷却心 (赞：2)

大家好，我是博弈论菜鸡。

Mr.Ball 因为不能结束游戏，所以他想要使总钱数最少一定是让 Mr.Box 多买箱子。首先箱子价格大于容量的一定不买，因为就算装满了也亏。为了能让 Mr.Box 多买箱子，Mr.Ball 一定会尽快装满一个箱子，所以每次选择容量最小的箱子装满。所以我们对排除会亏钱的箱子之后剩下来的序列，按照容量降序排序。显然这个时候，你选择的容量前 $m-1$ 大的箱子一定不会被 Mr.Ball 选中去加球。假设你选的第 $m$ 大的箱子下标为 $t$，显然 $t$ 到 $n$ 这 $n-t+1$ 个箱子都可以被装满，而 $t$ 之前的 $m-1$ 个箱子只会放一个。所以对排序之后的数组维护一个后缀的装满价值 $s_i$ 有：

$$s_i=s_{i+1}+V_i-P_i.$$

那么我们枚举这个第 $m$ 个箱子的位置，然后它前面选 $m-1$ 个箱子保证 $P$ 之和最小即可。这个可以用堆维护。然后求最大值就是答案。

[Code](https://atcoder.jp/contests/arc186/submissions/62721354)。

---

## 作者：chaeminter2467 (赞：1)

### 前言

好题好题。

### 题解

首先我们先确定双方的策略。

当 $n < m$ 时，B 最多接受 $n$ 种颜色的小球，如果 A 再给他一个其他颜色的，他将无法购买，又因为 $1 \le P_i \le 10^9$，所以此时最大收益为 $0$，即一开始就结束游戏。

接下来我们讨论的都是 $n \ge m$ 的情况。

对于 A 来说，他想让 B 多花钱，那么肯定想让他多买盒子。

因为有一个盒子必须放同种颜色小球的要求，所以 A 肯定先是每种颜色的小球都给一个。

此时 B 已经有了 $m$ 个盒子。

为了延续一开始的策略，假设此时 B 容量最小的盒子为 $p$ ，那么 A 肯定是不断给 B 与盒子 $p$ 中小球颜色相同的小球，从而把 $p$ 装满。

那么剩下 $m-1$ 个盒子中肯定都只有一个小球。

这 $m-1$ 个盒子的总花费为 $\sum (1-P_i)$。

把 $p$ 装满后，B 还可以购入新的盒子，每个新的盒子的得分都是 $V_i-P_i$ ，又因为 B 可以在任意时刻结束游戏，所以也可以不购入，此时每个盒子的价值都为 $\max(0,V_i-P_i)$。

----

简单分析过后我们来计算答案。

因为我们对购买的盒子中容量前 $m-1$ 大的盒子与其他的盒子的得分的计算不一样。所以我们要先对 $V_i$ 降序排序。

我们可以枚举分界点 $pos$ ，在 $pos$ 前面选出 $m-1$ 个盒子。

购入的新的盒子的得分转化为一段后缀，记 $suf_i$ 表示在 $i$ 及以后选“新的盒子“的得分。
$$
suf_i = \sum_{i}^{n} \max(0,V_i-P_i)
$$
需要最大化得分，意味着我们在 $pos$ 前要选 $m-1$ 个最小的 $P_i$，我用了权值线段树来维护。

时间复杂度 $\mathcal{O}(n \log V)$。（$V$ 为值域）

~~talk is cheap, show me the code!~~

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3e5+5;
int T,n,m;
ll suf[N];
struct Box{
	int v,p;
	void get(){
		scanf("%d %d",&v,&p);
	}
	bool operator < (const Box &qwq) const{
		return (v==qwq.v?p<qwq.p:v>qwq.v);//在v相同时先选p小的。
	}
}a[N];
namespace SegTree{//动态开点线段树
	int tot=0,rt=0;
	struct node{
		int ls,rs;
		int cnt;
		ll val;
	}tr[N<<5];//注意线段树节点个数是 O(n log V) 的。
	void pushu(int p){
		tr[p].cnt=tr[tr[p].ls].cnt+tr[tr[p].rs].cnt;
		tr[p].val=tr[tr[p].ls].val+tr[tr[p].rs].val;
	}
	void upd(int &p,int l,int r,int x){
		if(!p){
			p=++tot;
			tr[p].ls=tr[p].rs=tr[p].cnt=tr[p].val=0;
            //清空。
		}
		if(l==r){
			tr[p].cnt++;
			tr[p].val=1ll*x*tr[p].cnt;
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid)	upd(tr[p].ls,l,mid,x);
		else upd(tr[p].rs,mid+1,r,x);
		pushu(p);
	}
	ll qry(int p,int l,int r,int x){//查询前x大
		if(!p)	return 0ll;
		if(tr[p].cnt<=x)	return tr[p].val;
		if(l==r){
			return tr[p].val;
		}
		ll res=0ll;
		int mid=(l+r)>>1;
		if(tr[tr[p].ls].cnt>=x)	return qry(tr[p].ls,l,mid,x);
		res=tr[tr[p].ls].val+qry(tr[p].rs,mid+1,r,x-tr[tr[p].ls].cnt);
		return res;
	}
}using namespace SegTree;
void sol(){
//	cerr<<"new case:";
	scanf("%d %d",&n,&m);
	
	for(int i=1;i<=n;i++){
		a[i].get();
	}
	if(n<m||m==0){//注意特判。
		printf("0\n");
		return;
	}
	sort(a+1,a+n+1);
	suf[n+1]=0ll;
	for(int i=n;i>=1;i--){
		ll qwq=max(0ll,(ll)(a[i].v-a[i].p));
		suf[i]=suf[i+1]+qwq;
	}
	if(m==1){
        //因为此时 A 只能给一种球，所以没有选 m-1 个容量最大的盒子这一步骤，直接跳到后面的一步。
		printf("%lld\n",suf[1]);
		return;
	}
	ll ans=-1e15;//答案一开始取极小值。
	tot=rt=0;//清空。
	for(int i=1;i<=n;i++){
		upd(rt,1,1e9,a[i].p);
		if(i<m-1)	continue;//至少加入m-1个。
		ll sump=qry(rt,1,1e9,m-1);
		ll res=m-1-sump;//有 m-1 个 (1-P_i)
		ans=max(ans,res+suf[i+1]);
	}
	printf("%lld\n",max(ans,0ll));//和一开始就结束游戏的情况取max
}
signed main(){
//	freopen("test.in","r",stdin);
//	freopen("my.out","w",stdout);
	scanf("%d",&T);
	while(T--) sol();
	return 0;
}
```

---

## 作者：Petit_Souris (赞：1)

好题。

称买盒子放球的人为 A，发配不同颜色的球的人为 B。

我们发现 A 的决策比较麻烦，因为他每次买什么盒子是需要决策的；而 B 显得就比较单纯可爱了：

A 手上有一些盒子，那么 B 肯定希望 A 去买新盒子，所以如果目前 A 存在一种颜色没法放了，B 会给他发一个这个颜色的球，A 去买一个新盒子。如果不存在这样的颜色，那么 B 肯定希望 A 尽快买新盒子，所以会选择容量最小的那个盒子填满，然后再放一个这个颜色的球，这样就需要买新盒子了。

现在 B 的决策固定了，我们只需要计算对于一种 A 选盒子的方案，收益是多少就行了。

回忆一下目前的计算方式：

- 维护一个集合 $S$。

- 当 $|S|<m$ 时，加入一个 $(v,p)$，获得 $-(p-1)$ 的收益；

- 当 $|S|=m$ 时，删除 $v$ 最小的 $(v,p)$，获得 $v-1$ 的收益，回到上一步。

我们发现最后剩下的 $(v,p)$ 一定是 $v$ 最大的 $m-1$ 个。所以先对 $v$ 排序，然后做一遍扫描线。前缀就要选出所有 $v-p>0$ 的，后缀要选出 $p$ 前 $m-1$ 小的，用堆维护即可。注意这里钦定了某个 $i$ 必须选，所以要特殊处理一下，时间复杂度 $\mathcal O(n\log n)$。

[submission](https://atcoder.jp/contests/arc186/submissions/59247642)

---


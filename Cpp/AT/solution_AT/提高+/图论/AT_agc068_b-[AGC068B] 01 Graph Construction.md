# [AGC068B] 01 Graph Construction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc068/tasks/agc068_b

`0`,`1` のみからなる文字列の組 $ (S,T) $ が次の条件をすべて満たすとき (そしてそのときのみ) それを**良い**文字列組と呼ぶことにします．

- $ S,T $ に含まれる `0` の個数は等しい．
- $ S,T $ に含まれる `1` の個数は等しい．

特に，良い文字列組 $ (S,T) $ について，$ S,T $ の長さは同じです．

良い文字列組 $ (S,T) $ に対し，無向グラフ $ G(S,T) $ を次のように定義します．

- $ S $ の長さを $ L $ とする．頂点 $ 1,2,\cdots,L $ からなるグラフ $ g $ をつくる．
- $ S $ に含まれる `0` の個数を $ n $ とする． $ S $ に含まれる `0` の index を $ 1\ \leq\ a_1\ <\ a_2\ <\ \cdots\ <\ a_n\ \leq\ L $ とする． $ T $ に含まれる `0` の index を $ 1\ \leq\ b_1\ <\ b_2\ <\ \cdots\ <\ b_n\ \leq\ L $ とする． 各 $ 1\ \leq\ i\ \leq\ n $ に対し，頂点 $ a_i $ と頂点 $ b_i $ を結ぶ辺を $ g $ に追加する．
- $ S $ に含まれる `1` の個数を $ m $ とする． $ S $ に含まれる `1` の index を $ 1\ \leq\ c_1\ <\ c_2\ <\ \cdots\ <\ c_m\ \leq\ L $ とする． $ T $ に含まれる `1` の index を $ 1\ \leq\ d_1\ <\ d_2\ <\ \cdots\ <\ d_m\ \leq\ L $ とする． 各 $ 1\ \leq\ i\ \leq\ m $ に対し，頂点 $ c_i $ と頂点 $ d_i $ を結ぶ辺を $ g $ に追加する．
- 以上の手順で得た $ g $ を $ G(S,T) $ とする．

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます． 以下の条件をすべて満たす良い文字列組 $ (S,T) $ を $ 1 $ つ見つけてください．

- $ S $ の長さを $ L $ とする．$ N\ \leq\ L\ \leq\ 10^5 $ である．
- 各 $ 1\ \leq\ i,j\ \leq\ N $ について，$ G(S,T) $ で頂点 $ i $ と頂点 $ j $ が同じ連結成分に属すとき，そしてそのときのみ $ A_i=A_j $ である．

なお，この問題の制約下で解が必ず存在することが証明できます．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ A_i\ \leq\ N $
- 入力される値はすべて整数

### Sample Explanation 1

出力例の $ S,T $ について $ G(S,T) $ を求めると，次のようになります． - $ 4 $ 頂点ならなるグラフ $ g $ を用意する． - $ S $ に含まれる `0` の index は $ (1,2) $ で，$ T $ に含まれる `0` の index は $ (3,4) $ である． 辺 $ (1,3),(2,4) $ を $ g $ に追加する． - $ S $ に含まれる `1` の index は $ (3,4) $ で，$ T $ に含まれる `1` の index は $ (1,2) $ である． 辺 $ (3,1),(4,2) $ を $ g $ に追加する． - $ G(S,T)=g $ とする． $ G(S,T) $ の連結成分は，頂点 $ (1,3) $ からなる成分と頂点 $ (2,4) $ からなる成分です． これは条件をすべて満たすので，この $ (S,T) $ は正しい出力です．

## 样例 #1

### 输入

```
3
1 2 1```

### 输出

```
4
0011
1100```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
5
01010
01010```

## 样例 #3

### 输入

```
6
1 1 1 1 1 1```

### 输出

```
6
011111
111110```

## 样例 #4

### 输入

```
10
1 2 3 2 4 3 4 4 5 6```

### 输出

```
21
000101010111100011011
011010000010101111110```

# 题解

## 作者：Rainbow_qwq (赞：6)

初始让 $s$ 为 $n$ 个 $0$，$t$ 为 $n$ 个 $1$。

此时从左到右未匹配的 $0$ 和未匹配的 $1$ 的编号都是 $(1,2,3,\dots, n)$。

构造一些基础操作：

- $s+0,t+0$：把未匹配的 $0$ 序列编号向左旋转一位，比如从 $(1,2,3,\dots, n)\to (2,3,\dots,n,1)$。
- $s+1,t+1$：把未匹配的 $1$ 序列编号向左旋转一位。
- $s+10,t+01$：把两个编号序列的第一个点连一条边，然后把两个编号序列都向左旋转一位。

每次把两个编号序列旋转到对应位置，然后连边，这样用了 $O(n^2)$ 的步数就连好了边。

最后把两个序列转到相同的状态，在末尾分别补全 $n$ 个 $1$ 和 $n$ 个 $0$ 就构造完毕。

```cpp
#define maxn 500005
#define inf 0x3f3f3f3f

int n,a[maxn],pre[maxn];
vector<pii>e;

signed main()
{
	n=read();
	For(i,0,n-1)a[i]=read();
	memset(pre,-1,sizeof pre);
	For(i,0,n-1){
		if(pre[a[i]]>=0)e.pb(mkp(pre[a[i]],i));
		pre[a[i]]=i;
	}
	string s,t;
	For(i,0,n-1) s+='0',t+='1';
	int p=0,q=0;
	for(auto [u,v]:e){
		while(p!=u) s+='0',t+='0',p=(p+1)%n;
		while(q!=v) s+='1',t+='1',q=(q+1)%n;
		s+='1',t+='0';
		s+='0',t+='1';
		p=(p+1)%n,q=(q+1)%n;
	}
	while(p!=q) s+='0',t+='0',p=(p+1)%n;
	For(i,0,n-1) s+='1',t+='0';
	cout<<s.size()<<"\n";
	cout<<s<<"\n"<<t<<"\n";
	return 0;
}
/*
0000  1 0
1111  0 1
*/
```

---

## 作者：JWRuixi (赞：0)

## [AGC068B] 01 Graph Construction

### 题意

对于两个 $01$ 数量分别相等的 $01$ 串 $(A, B)$，按如下方式构造无向图 $G$：

- 记 $A$ 中 $0$ 的位置为 $a_1, \dots, a_p$，$B$ 中 $0$ 的位置为 $b_1, \dots, b_p$，对于任意 $i \in [p]$，连边 $(a_i, b_i)$；
- 记 $A$ 中 $1$ 的位置为 $c_1, \dots, c_q$，$B$ 中 $1$ 的位置为 $d_1, \dots, d_q$，对于任意 $i \in [q]$，连边 $(c_i, d_i)$。

给定长度为 $n$ 的序列 $a$，构造一个长度不超过 $10^5$ 的 $(A, B)$，满足 $\forall \ 1 \le i < j \le n$，$i, j$ 连通当且仅当 $a_i = a_j$。

$n \le 100$。

### 分析

本来是不会一点的，然后把样例一错看成了 $n = 2$ 的构造，然后就会了……

这个是 $01$ 对位连边，感觉限制就很强，所以猜测其实 $|A|$ 应该就比较大，看数据范围大概是 $\mathcal O(n^2)$ 级别的，所以我们的构造可以奔放一点。

一个想法是：我们实际上只需要不到 $n$ 条边就可以将 $n$ 个点划分为若干个连通块，那么我就想构造一个大概 $n + 1$ 层的图，没两层之间加一条边，同时保持连通性。

我们以样例一为例解释。

我们初始时从：
$$
000 \\
111
$$
出发。

那么我们怎么控制连边呢？应该是用 $1$ 做占位符，然后控制 $0$ 的连接。那么我们就稍微调整一下策略，变成：控制第一组中的 $n$ 个 $0$ 分别连向对应的链上的下一个节点（将链首尾相接成环）。也就是说，加入第二组之后会变成：
$$
000, 111 \\
111, 110
$$
这样子就控制了 $1 \to 3$！然而我们注意到，现在的第二组的 $B$ 部分形如 $110$，那么为了保证层之间连接不出错，我们被迫在第三组的 $A$ 上保持同样的结构，也就是说，变成：
$$
000, 111, 110 \\
111, 110, \dots
$$
现在 $1$ 的位置就都是对齐了的，但是注意到这样可能导致 $3$ 跟接下来的层之间断开，但是每个点只会被作为一次终点，所以没关系！那现在就有一个嵌套的结构了，最终会变成：
$$
000, 111, 110, 101, 011 \\
111, 110, 101, 011, \dots
$$
那么问题来了，就是我想在 $A$ 中还有 $n$ 个 $0$ 盈余，这怎办呢？我们惊奇的发现，这 $n$ 个 $0$ 的位置，恰好对应了 $1, \dots, n$ 对应的出边的终点，也就是说，我们可以再反向连一条边，变成：
$$
000, 111, 110, 101, 011 \\
111, 110, 101, 011, 000
$$
那么最后这 $n$ 条边也是符合条件的。

最终我们就以 $|A| = n(n + 2)$ 完成了构造！

### Code

提交记录：<https://atcoder.jp/contests/agc068/submissions/59017147>。

代码实现中链尾采用了连一个自环的方式而不是首尾相接，不过是一样的。

---


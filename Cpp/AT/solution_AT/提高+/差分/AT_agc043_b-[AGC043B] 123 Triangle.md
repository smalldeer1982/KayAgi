# [AGC043B] 123 Triangle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc043/tasks/agc043_b

各要素が $ 1 $ か $ 2 $ か $ 3 $ である長さ $ N $ の数字列 $ a_1a_2\ldots\ a_N $ が与えられます。 $ x_{i,j} $ を次のように定義します。

- $ x_{1,j}\ :=\ a_j $ $ \quad $ ($ 1\ \leq\ j\ \leq\ N $)
- $ x_{i,j}\ :=\ |\ x_{i-1,j}\ -\ x_{i-1,j+1}\ | $ $ \quad $ ($ 2\ \leq\ i\ \leq\ N $ かつ $ 1\ \leq\ j\ \leq\ N+1-i $)

$ x_{N,1} $ を求めてください。

## 说明/提示

### 制約

- $ 2\ ≦\ N\ ≦\ 10^6 $
- $ a_i\ =\ 1,2,3 $ $ (1\ \leq\ i\ \leq\ N) $

### Sample Explanation 1

$ x_{1,1},x_{1,2},x_{1,3},x_{1,4} $ はそれぞれ、$ 1,2,3,1 $ です。 $ x_{2,1},x_{2,2},x_{2,3} $ はそれぞれ、$ |1-2|\ =\ 1,|2-3|\ =\ 1,|3-1|\ =\ 2 $ です。 $ x_{3,1},x_{3,2} $ はそれぞれ、$ |1-1|\ =\ 0,|1-2|\ =\ 1 $ です。 最後に、 $ x_{4,1}\ =\ |0-1|\ =\ 1 $ なので、答えは $ 1 $ です。

## 样例 #1

### 输入

```
4
1231```

### 输出

```
1```

## 样例 #2

### 输入

```
10
2311312312```

### 输出

```
0```

# 题解

## 作者：CYJian (赞：12)

## AGC043B

赛时做法：

手玩样例 + 合理推理之后，不难发现，$k>1$ 的时候就一定不存在 $3$ 了。也就是说，除了 $N=1$ 的情况，答案只能在 $0,1,2$ 三个数中产生。

那么问题来了：怎么判断是谁呢？

冷静分析之后，我们发现，如果不直接计算出最后是谁，而是排除最后一定不是谁，就能从另一个角度知道结果了。

然后再想想，如果 $\exists x \in[1, N - 1], f(2,x)=1$，则不难发现最后结果一定只能是 $0$ 或者 $1$。考虑 $0$ 和 $2$ 只要碰到 $1$ 就会变成 $1$，也就是说，只要 $1$ 旁边存在 $0$ 或者 $2$， $1$ 就一定会存在。所以，只要不是到了某一层全是 $1$ 的情况，$1$ 就一定会存在。所以 $2$ 就一定不能撑到第 $N$ 层。

然后这时候我们就只需要判定答案是 $1$ 还是 $0$ 了。也就是，我们只需要断定答案的奇偶性就可以了。

不难发现，模 $2$ 意义下，减法等价于加法（单指运算结果）。则可以将原递推式变为：

$$f_{k,x} = f_{k-1, x} + f_{k-1,x+1} \pmod 2$$

不难发现是类似组合数递推的，只不过转移方向反过来而已。利用组合数可以得到：

$$f_{N,1}=\sum_{i=1}^{N} a_i \times \binom{N-1}{i-1} \pmod 2$$

利用 `Lucas` 定理，就能 $O(\log n)$ 快速求解了。

当然，对于 $\bmod\ 2$ 意义下，有 $\binom{n}{m} \equiv[n\ \mathrm{and}\ m=m] \pmod2$。利用这个可以 $O(1)$ 求这个题要求的组合数。

然后再考虑没有 $1$ 的情况：这时候这层中仅可能有 $0$ 和 $2$。在 $\bmod\ 4$ 意义下，此时的减法也等价于加法。不妨将 $a_i$ 除掉一个 $2$ 之后，用求解 $0$ 和 $1$ 的方法来求解 $0$ 和 $2$，这样就解决了这个题了。

```cpp
char s[1000010];

inline int C(int n, int m) { return (n & m) == m; }

int main() {
	int n;
	scanf("%d%s", &n, s + 1);
	if(n == 1) putchar(s[1]), puts("");
	else {
		--n;
		int find1 = 0;
		for(int j = 1; j <= n; j++)
			s[j] = abs(s[j] - s[j + 1]), find1 |= s[j] == 1;
		if(!find1) for(int i = 1; i <= n; i++) s[i] >>= 1;
		find1 ^= 1;
		int t = 0;
		for(int j = 1; j <= n; j++) t ^= C(n - 1, j - 1) * (s[j] & 1);
		cout << (int(t) << find1) << endl;
	}
	return 0;
}
```

---

## 作者：xht (赞：6)

首先进行一次绝对值差分，让序列中的数都在 $0 \sim 2$ 中，显然无论什么情况后面的每个数只可能为 $0 \sim 2$。

如果此时的序列中存在 $1$，则意味着答案只可能是 $0$ 或 $1$；如果不存在 $1$，则答案只可能是 $0$ 或 $2$。

对于不存在 $1$ 的情况，我们可以将每个数都 $\div 2$，最后再将答案 $\times 2$，这显然是等价的。

于是现在的答案都只可能是 $0$ 或 $1$ 了，于是显然我们只用在模 $2$ 的情况下讨论。

考虑一次绝对值差分在模 $2$ 意义下的影响，可以发现等价于 $\operatorname{xor}$。

现在问题变为，给定一个 $0/1$ 序列，每次将相邻两个数 $\operatorname{xor}$，求最后剩下的数。

那么考虑每个数会被异或几次即可，设序列长度为 $n$，则位置 $i$ 上的数会被异或 $\binom {n-1}{i-1}$ 次。

这时候我们还要求出模 $2$ 意义下的组合数，一个简单的方法是计算每个阶乘的分解中 $2$ 的次数，将计算组合数时的除法改为做减法。则对于一个组合数，最后如果剩下的 $2$ 的次数为 $0$，则说明 $\bmod 2 = 1$，否则 $\bmod 2 = 0$。

对于阶乘的分解，可以先对每个数简单地求出分解中 $2$ 的次数，然后做前缀和即可。

时间复杂度 $\mathcal O(n)$。

```cpp
const int N = 1e6 + 7;
int n, a[N], c[N];
char s[N];

int main() {
	rd(n), rds(s, n), --n;
	for (int i = 1; i <= n; i++) a[i] = abs(s[i] - s[i+1]);
	bool ok = 0;
	for (int i = 1; i <= n; i++)
		if (a[i] == 1) ok = 1;
	if (!ok) for (int i = 1; i <= n; i++) a[i] >>= 1;
	for (int i = 1; i <= n; i++) {
		int x = i;
		while (!(x & 1)) ++c[i], x >>= 1;
		c[i] += c[i-1];
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
		ans ^= c[n-1] - c[i-1] - c[n-i] ? 0 : (a[i] & 1);
	if (!ok) ans <<= 1;
	print(ans);
	return 0;
}
```

---

## 作者：peterwuyihong (赞：4)

整一些 $\text{AT}$ 的题，来增强我的人类智慧。

题意：给你一个长为 $n\le10^6$ 的 $123$ 序列，定义一个操作 囸 为把它变成自己的差分数列，第一项扔掉，再把负数的数变成他的相反数。问你把这个序列 囸 $n-1$ 次得到的序列中的那一个数为几。

如
```cpp
2311312312
 120221121
  12201011
   1021110
    121001
     11101
      0011
       010
        11
         0
```
于是你输出 $0$。

我们大胆猜测到后面序列只剩 $01$ 了，于是我们来考虑这个 $01$ 序列怎么做。

问题转化为求一个长度为 $n$ 的序列的 $n-1$ 阶差分异或。

~~貌似可以fwt结合差分与前缀和那道题？？？~~

但我们只求最后一个点值，考虑一些牛逼的做法。（以下下标比较魔怔，$a_{1^{14}5^{14}}$ 表示位置 $1$ 异或 $14$ 次异或上位置 $5$ 异或 $14$ 次

$$a_1,a_2,a_3,a_4,a_5,a_6,a_7$$

$$a_{12},a_{23},a_{34},a_{45},a_{56},a_{67}$$

$$a_{12^23},a_{23^24},a_{34^25},a_{45^26},a_{56^27}$$

$$a_{12^33^34},a_{23^34^35},a_{34^35^36},a_{45^36^37}$$

$$\ldots$$

$$a_{12^63^{15}4^{20}5^{15}6^67}$$

然后就是一个组合数是否能被 $2$ 整除的事情了，你就直接处理阶乘有几个 $2$ 因子就能做到 $(n\log n)$ 的复杂度。

现在是 $12:00$，我看我什么时候写完。

现在是 $13:08$，我写完了。

```cpp
#define maxn 1000010
int n;
int a[maxn];
char s[maxn];
int C(int n,int m,int k){
	int ans=0;
	for(int i=n;i;i>>=1)ans+=i/2;
	for(int i=m;i;i>>=1)ans-=i/2;
	for(int i=n-m;i;i>>=1)ans-=i/2;
	return ans?0:(a[k]&1);
}
bool flg;
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	cin>>n;
	cin>>s+1;n--;
	for(int i=1;i<=n;i++)a[i]=abs(s[i+1]-s[i]),flg|=a[i]==1;
	if(!flg)for(int i=1;i<=n;i++)a[i]=a[i]/2;
	int ans=0;
	for(int i=1;i<=n;i++)
	ans^=C(n-1,i-1,i);
	if(!flg)ans*=2;
	cout<<ans;
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
我发现我前面大胆地胡错了，如果来一个 $111111111111113$ 的数列就能卡飞。其实可以先差分一次，只剩下 $012$，然后如果序列里有 $1$，那么答案一定不会是 $2$，如果序列里没有 $1$，就把序列除以二，答案乘以二，这才是正确的转化。~~口胡害人~~

后面突然发现一个 $O(1)$ 的简单判断组合数奇偶的办法。
```cpp
(n&m)==m
```

---

## 作者：feecle6418 (赞：4)

首先最终答案一定是 $0,1,2$，只需要判断到底是哪一个。

不难发现，绝对值不影响奇偶性。因此先判断答案的奇偶性（等价于 $\sum a_i \text{C}_{n-1}^{i-1}$），使用 Lucas 定理或对阶乘分解质因数可以做到 $O(n\log n)$，采用 [CTSC2017] Gift 的方法可以 $O(n)$。

假如是奇数，直接输出 $1$。否则，答案一定是 $0,2$。把每个数都除以二，则答案为 $0$ 的不会改变，答案为 $2$ 的会变成 $1$。用上面的方法再判断一次即可。

评测链接：https://atcoder.jp/contests/agc043/submissions/11070036

---

## 作者：Soulist (赞：2)

注意到 $n\ge 2$，所以我们可以给整个序列全体 $-1$，容易发现这对于答案没有影响。

这样的话，问题等价于只有 $0,1,2$，求最后的值。

注意到最后的答案显然也只有 $0,1,2$ 三种。

注意到绝对值可以看作给相邻两项添加符号，正号或者负号

我们不妨看作两边都是正号，然后再把部分位置变成负号。

于是假设最后的序列，$1$ 被加了奇数次，那么答案必然为 $1$，因为无论怎么修改符号，答案的奇偶性不会改变。

然后如果初始序列中同时有 $1,2$ 那么最后的答案肯定不会是 $2$

大概就从 $2$ 开始反推 $2\to (2,0)\to (...)$ 因为 $2$ 必然是由 $2,0$ 产生的，同时 $0$ 只能补充一个和之前相同的数，所以不会出现 $1$ 

所以如果序列中同时有 $1,2$ 且 $1$ 被计算次数为偶数，那么答案肯定是 $0$

否则，如果 $1$ 没有出现过，且 $2$ 被计算次数为奇数，那么答案肯定是 $2$。这是因为修改 $0$ 前面的符号对于答案没有影响，修改 $2$ 前面的符号每次对于答案的变化是 $\pm 4$

所以我们只需要知道，每次操作令 $x_{i,j}=x_{i-1,j}+x_{i-1,j+1}$ 这样操作之后，最后 $1,2$ 的被计算次数即可。

手玩小部分的点会发现，最后的计算次数恰好是杨辉三角。第 $i$ 位会被计算 $\binom{n-1}{i-1}$ 次。

证明的话也非常 naive，可以考虑归纳法。

假设 $x_{k,i} = a\times x_{1,i}+b\times x_{1,i+1}...+z\times x_{1,i+k}$

然后每次合并两项会发现恰好是一个错位相加的形式，加上初始系数是 $1$ 是杨辉三角的第一项，所以最后每个数被计算的次数仍然是杨辉三角。

于是我们的问题只是判断组合数的奇偶性而已了。

考虑 Lucas 定理，注意到 $\binom{n}{m}\equiv 1\pmod 2$ 等价于 $2$ 进制下每一位组合数都是 $1$，所以只能有 $\binom{1}{1},\binom{1}{0},\binom{0}{0}$ 的出现，这等价于 $n\&m=m$

所以我们直接用 $n\& m$ 是否等于 $m$ 来判断组合数的奇偶性即可，复杂度 $O(n)$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 1e6 + 5 ; 
int n, a[N], w[10], bk[10] ; 
char s[N] ; 
signed main()
{
	n = gi(), scanf("%s", s + 1 ) ;
	rep( i, 1, n ) a[i] = s[i] - '1', bk[a[i]] = 1 ; 
	rep( i, 1, n ) if( ( ( i - 1 ) & ( n - 1 ) ) == ( i - 1 ) ) w[a[i]] ^= 1 ; 
	if( w[1] ) { puts("1") ; exit(0) ; }
	if( w[2] && ( !bk[1] ) ) { puts("2") ; exit(0) ; }
	puts("0") ; 
	return 0 ;
} 

---

## 作者：HH_Halo (赞：1)

* 不难发现，这道题在从 $1$ 到 $n$ 一层一层的不断计算之中，将每层的数放在一起，就形成了一个形状和杨辉三角一样的东西，当然，也有和杨辉三角类似的性质下面会用到
* 如果你自己手膜了数据的话，会发现 $3$ 在第二层就已经一定不存在了，因为没有两个数的差值等于 $3$，所以最后答案只可能是 $0$,$1$,$2$。
* 继续计算，会发现 $1$ 无论是遇到 $0$ 还是 $2$，最后仍然还是 $1$，这意味着如果不存在一层的所有数都是 $1$,那么最终答案也一定是 $1$，所以得出一条重要结论：**如果序列中存在 $1$，那么最终答案一定为 $0$ 或 $1$**，这时候 $0$ 和 $2$ 其实是等价的，所以转化为 $mod$ $2$ 意义下。延伸得到另一条结论：**如果不存在 $1$，那么最终答案一定为 $0$ 或 $2$**
* 上面两种情况没有什么本质区别，第二种也完全可以全部除以 $2$，转化成 $0/1$ 序列。**而对于 $0/1$ 序列来说(即在 $mod$ $2$意义下)，加减操作和异或操作是等价的**，我们只需要进行异或计算就好了。
* 这时候只需求出最初每个数(指相邻两数之间的差值)的异或次数，而上面说到，这其实是一个杨辉三角，而**杨辉三角中的每个数都可以用组合数求出，这个组合数的值的本质含义其实就是三角顶层的那个 $1$ 到达这个数的路径数**，所以将最初的每个数放到杨辉三角上，就可以用组合数求出异或次数，第 $i$ 个数的次数即为 $C_{n-1}^{i-1}$。
* 最后用 $Lucas$ 定理快速求出组合数值,$Lucas(n/2,m/2)*C(n\%2,m\%2)$ 其实最后结果就是$n\&m==m$，不明白可以联系二进制考虑，如果有一位 $2$ 进制上 $n$ 为 $0$,$m$ 为 $1$，那么计算结果就是 $C_0^1$ ，也就是 $0$

## $Code$
```c++
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 1000010
#define R register
using namespace std;
inline int read(){
	int x = 0,f = 1;
	char ch = getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,ans;
char s[N],a[N];
inline int C(int x,int y){return (x&y)==y;}
int main(){
	n = read()-1;
	scanf("%s",s+1);
	for(R int i = 1;i <= n;i++)a[i] = abs(s[i]-s[i+1]);
	bool flag = 0;//判断有无 1
	for(R int i = 1;i <= n;i++)flag |= a[i]==1;
	if(!flag)for(R int i = 1;i <= n;i++)a[i]>>=1;
	for(R int i = 1;i <= n;i++){
		ans ^= C(n-1,i-1)?(a[i]&1):0;//(a[i]&1)是因为在 mod2 意义下，防止出现 ^2 的情况
	}
	if(!flag)ans<<=1;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：lzk5627 (赞：1)

### 题意
给你一个长度为 $N$ 的序列 $a$ ,按照如下方法构造一个三角形

* $b_{i,j}=a_j,i=1$
* $b_{i,j}=|b_{i-1,j}-b_{i-1,j+1}|,2\ge i\le N,1\ge j\le N-i$

求 $b_{N,1}$ 的值

### sol
很巧妙的一道题目,感觉自己昨晚被降智了

发现如果我们先对于初始序列做一次操作,那么第二行肯定只有 $0,1,2$ 出现

然后分情况讨论一下

* 如果第二行出现了 $1$ ,那么最后的答案肯定不会是 $2$,因为只有两个连续的 $1$ 在一起才会使得一个 $1$ 消失,所以最后如果有 $2$ 的话肯定是会变成 $1$ 的,如果发现 $(1,2)=1,(0,2)=2,(2,2)=0$ ,发现这里的 $2$ 的所有情况和 $0$ 相同, 所以我们可以把 $2
$ 看成 $0$
* 如果第二行没有出现 $1$ ,那么最后的答案就只有 $0,2$ ,我们可以把 $2$ 看做 $1$

然后现在的问题就转换成了只有 $0,1$ 求最终的值是多少

考虑写出每个位置对最终答案的贡献 , 发现系数是一个组合数 , 那么我们只要求出来组合数在模 $2$ 意义下的值就可以了

考虑卢卡斯定理

$C_n^m = C_{n/p}^{m/p}C_{n\%p}^{m\%p}$

然后考虑递归到最后的结果只有 $C_0^1 = 0$ , 所以只要存在一位满足 $n$ 在那一位是 $0$ , $m$ 在那一位是 $1$ 最终答案就是 $0$

---


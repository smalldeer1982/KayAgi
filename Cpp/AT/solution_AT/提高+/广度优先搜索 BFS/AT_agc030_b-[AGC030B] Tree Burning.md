# [AGC030B] Tree Burning

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc030/tasks/agc030_b

高橋湖の周長は $ L $ です。高橋湖の周上には湖の所有者である高橋君の家があります。 高橋湖の周上の地点には高橋君の家から反時計回りに測った距離を用いて、$ 0 $ 以上 $ L $ 未満の実数の座標が定まっています。

高橋湖の周上には木が $ N $ 本生えています。$ i $ 本目の木は座標 $ X_i $ に生えています。高橋君の家のある座標 $ 0 $ には木は生えていません。

高橋君は、自分の家からはじめて、以下の行動を繰り返します。

- すべての木を燃やし終えている場合、終了する。
- 時計回りまたは反時計回りの向きを指定する。
- 初めてまだ燃やしていない木のある座標に到達するまで、指定した方向に高橋湖の周上を歩き続ける。
- 木のある座標に到達したら、その木を燃やしてその場に立ち止まり、最初に戻る。

この行動を通じて、高橋君が歩く距離の合計の最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ L\ \leq\ 10^9 $
- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ X_1\ <\ ...\ <\ X_N\ \leq\ L-1 $
- 入力はすべて整数である

### 部分点

この問題には部分点が設定されている。

- $ N\ \leq\ 2000 $ を満たす入力に正解すると、$ 300 $ 点が得られる。

### Sample Explanation 1

以下のような行動で、高橋君は距離 $ 15 $ を歩きます。 - 反時計回りに距離 $ 2 $ ぶんだけ歩き、座標 $ 2 $ にある木を燃やして立ち止まる。 - 反時計回りに距離 $ 5 $ ぶんだけ歩き、座標 $ 7 $ にある木を燃やして立ち止まる。 - 時計回りに距離 $ 8 $ ぶんだけ歩き、座標 $ 9 $ にある木を燃やして立ち止まる。

## 样例 #1

### 输入

```
10 3
2
7
9```

### 输出

```
15```

## 样例 #2

### 输入

```
10 6
1
2
3
6
7
9```

### 输出

```
27```

## 样例 #3

### 输入

```
314159265 7
21662711
77271666
89022761
156626166
160332356
166902656
298992265```

### 输出

```
1204124749```

# 题解

## 作者：AuCloud (赞：2)

# 题意翻译

高桥湖是周长为 $L$ 的一个首尾相接的圆，圆上整点标为$0, 1, 2, ..., L-1$.

在湖边有 $N$ 颗树，分别在距离起点顺时针数 $X_1, X_2,...,X_n$ 的位置上。保证位置 $0$ 没有树。

高桥君初始在位置 $0$ 上，每次可以选择顺时针或逆时针走到第一颗还没有被点燃过的树并将其点燃，直到所有树都被点燃为止。

求高桥君最长的移动距离。

# 题解

~~不太环保~~

首先这里有一个~~并不~~简单的规律：

- 最优解一定是先往一个方向走 $A$ 棵树，剩下的 $N - A$ 棵树顺时针逆时针反复走。

~~不会证明~~![kk](https://cdn.luogu.com.cn/upload/pic/62227.png)可以用数学归纳法简单证明

所以可以枚举不左右反复走的长度，剩下的就是如何 $O(1)$ 求当前状态的解

画一下图，发现可以把反复走的部分简化为两段：从一个位置回到 $0$ 和从 $0$ 到另一个位置

把相邻的段合并就会发现，路径变成了从 $0$ 出发到每个点再回来，只有最后的终点不需要回到 $0$

分类讨论，先固定往顺时针走。

当删除完一段不反复走的区间后，设剩余的树的数量 $rem$ ， 则终点 $fin = \frac{rem}{2} + 1$

- $rem$ 为奇数时，终点是顺时针达到的

- $rem$ 为偶数时，终点是逆时针达到的

而所有比终点小的点都是顺时针，比终点大的都是逆时针

考虑维护距离 $0$ **顺时针长度的前缀和pre**与**逆时针长度的后缀和ed**，则答案可以写成这个样子：

$$ ans=pre[fin-1]*2+ed[fin+1]*2+dis(0,fin)$$

其中 $dis(0,fin)$ 如上面分类讨论所提到的， $rem$ 为奇数时是顺时针长度，反之亦然

最终所有答案取 $max$ 即可

当然，因为我们假设了一直先往顺时针走，所以需要把数组倒序之后再做一遍

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, m;
long long ans = 0;
int a[200005];
long long d1[200005], d2[200005], pre[200005], ed[200005], b[200005];
long long dis(int x, int y, int op)//op=1时为顺时针长度，否则为逆时针长度
{
	if(op == 1)
	{
		if(y > x)
		{
			return y - x;
		}
		else
		{
			return y + n - x;
		}
	}
	else
	{
		if(y < x) return x - y;
		return x + n - y;
	}
}
int main()
{
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
	{
		cin >> a[i];
	}
	int now = 0;
	for(int i = 1; i <= m; i++)
	{
		d1[i] = dis(0, a[i], 1);
		d2[i] = dis(0, a[i], 0);
	}
	for(int i = 1; i <= m; i++)
	{
		pre[i] = pre[i - 1] + d1[i];
	}
	for(int i = m; i >= 1; i--)
	{
		ed[i] = ed[i + 1] + d2[i];
	}
	for(int i = 1; i <= m; i++)
	{
		int rem = m - i + 1;
		int fin = rem / 2 + i;
		if(rem & 1) ans = max(ans, pre[fin - 1] * 2 + d1[fin] + ed[fin + 1] * 2 - pre[i - 1] * 2);
		else ans = max(ans, pre[fin - 1] * 2 + ed[fin + 1] * 2 + d2[fin] - pre[i - 1] * 2);
	}
	memset(pre, 0, sizeof(pre));
	memset(ed, 0, sizeof(ed));
	memset(d1, 0, sizeof(d1));
	memset(d2, 0, sizeof(d2));
	for(int i = 1; i <= m; i++) b[i] = a[i];
	for(int i = 1; i <= m; i++) a[i] = b[m - i + 1];
	for(int i = 1; i <= m; i++)
	{
		d1[i] = dis(0, a[i], 0);
		d2[i] = dis(0, a[i], 1);
	}
	for(int i = 1; i <= m; i++)
	{
		pre[i] = pre[i - 1] + d1[i];
	}
	for(int i = m; i >= 1; i--)
	{
		ed[i] = ed[i + 1] + d2[i];
	}
	for(int i = 1; i <= m; i++)
	{
		int rem = m - i + 1;
		int fin = rem / 2 + i;
		if(rem & 1) ans = max(ans, pre[fin - 1] * 2 + d1[fin] + ed[fin + 1] * 2 - pre[i - 1] * 2);
		else ans = max(ans, pre[fin - 1] * 2 + ed[fin + 1] * 2 + d2[fin] - pre[i - 1] * 2);
	}
	cout << ans;
	return 0;
}

```

---

## 作者：Miraik (赞：1)

第一感就是说我顺逆时针交叉走会比较优，但是样例一似乎就把这个想法叉掉了。

但事实上我们稍加限制即可：在第一次改变方向之后，顺逆时针交叉走必然最优。证明可以考虑如果你走出了形如 $\text{LRR}$ 这样的情况，我必然可以通过调整使它更优（距离更长且终点一致），如 $\text{RLR}$。

然后就用一个前后缀和递推计算即可，计算时要注意到达最后一个位置之后不需要返回原点。

```cpp
int main(){
    for(int i=1;i<=n;i++) pre[i]=pre[i-1]+a[i]*2;
    for(int i=n;i;i--) suf[i]=suf[i+1]+(L-a[i])*2;
    for(int i=1;i<=n;i++){
        int mid=(i+n)/2;
        ans=max(ans,pre[mid]-pre[i-1]+suf[mid+1]-((i+n&1)?L-a[mid+1]:a[mid]));
    }
    for(int i=n;i;i--){
        int mid=(1+i+1)/2;
        ans=max(ans,suf[mid]-suf[i+1]+pre[mid-1]-((1+i&1)?a[mid-1]:L-a[mid]));
    }
    return 0;
}
```


---


# [AGC036C] GP 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc036/tasks/agc036_c

長さ $ N $ の数列 $ x=(x_0,x_1,\cdots,x_{N-1}) $ があります。 最初、すべての $ i $ ($ 0\ \leq\ i\ \leq\ N-1 $) について $ x_i=0 $ です。

すぬけさんは、次の操作を**ちょうど** $ M $ 回行います。

- 相異なる添字 $ i,j $ ($ 0\ \leq\ i,j\ \leq\ N-1,\ i\ \neq\ j $) を選ぶ。 そして、$ x_i $ を $ x_i+2 $ で置き換える。また、$ x_j $ を $ x_j+1 $ で置き換える。

最終的な数列 $ x $ の状態としてありうるものが何通りあるかを求めてください。 ただし、答えは非常に大きくなることがあるので、$ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^6 $
- $ 1\ \leq\ M\ \leq\ 5\ \times\ 10^5 $
- 入力される値はすべて整数である。

### Sample Explanation 1

$ 2 $ 回の操作後の $ x $ の状態としてありうるものは以下の $ 3 $ 通りです。 - $ x=(2,4) $ - $ x=(3,3) $ - $ x=(4,2) $ たとえば、$ x=(3,3) $ としたい場合、次のように操作すればよいです。 - $ 1 $ 回目の操作：$ i=0,j=1 $ とする。$ x $ は $ (0,0) $ から $ (2,1) $ へ変化する。 - $ 2 $ 回目の操作：$ i=1,j=0 $ とする。$ x $ は $ (2,1) $ から $ (3,3) $ へ変化する。

## 样例 #1

### 输入

```
2 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2```

### 输出

```
19```

## 样例 #3

### 输入

```
10 10```

### 输出

```
211428932```

## 样例 #4

### 输入

```
100000 50000```

### 输出

```
3463133```

# 题解

## 作者：Scintilla (赞：5)

翻译：

有一个序列 $a_{1 \cdots n}$，初始时均为 $0$。每一次操作中，可以选择 $i \ne j$，将 $a_i$ 加上 $1$，将 $a_j$ 加上 $2$。操作共进行 $m$ 次，求最终序列有多少种可能的情况。答案对 $998244353$ 取模。

输入一行两个数 $n, m$。

输出一行，表示答案对 $998244353$ 取模的值。

$n \leq 10^6, m \leq 5 \times 10^5$。

### $\rm Solution$

等价于让我们求满足以下条件的序列 $a$ 的个数：

 - $\sum a_i = 3m$
 - $\max\{a_i\} \leq 2m$
 - $\sum a_i \mod 2 \leq m$（奇数不超过 $m$ 个）

如果没有条件 $2$，那么我们可以枚举奇数个数。奇数个数为 $k$ 时如果 $3m - k$ 是偶数，设其为 $2p$，那么考虑将奇数全部减 $1$，剩下的 $n$ 个非负偶数的和就是 $2p$，又都是偶数显然等价于 $n$ 个非负整数的和为 $p$，所以合法的方案有 $\dbinom{n}{i} \times \dbinom{p + n - 1}{n - 1}$ 个；否则为 $0$。

现在考虑如何去掉多余的，即有一个 $a_i$ 超过 $2m$ 的。发现这种数如果有，那么只有一个，可以钦定其为 $a_1$。那么将 $a_1$ 减去 $2m + 1$，又变成了 $n$ 个非负整数和为 $m - 1$，这时条件三就不用考虑了，所以共有 $n \times \dbinom{m + n - 2}{n - 1}$ 种情况。

最后输出二者之差即可。

---

## 作者：TanX_1e36 (赞：2)

考虑构造出来的序列 $a$ 的特征，因为每次会给 $a_i$ 加 $1$，$a_j$ 加 $2$，所以每次操作后 $\sum a_i$ 会加上 $3$。  

所以有 $\sum a_i =3m$。  

又因为每次操作只给一个数加 $1$，所以每次操作要么给序列加入一个奇数，要么使原来的一个奇数变成偶数。  

所以序列中的奇数个数设为 $k$，$k$ 的奇偶性与 $m$ 相同，即 $k=\sum a_i\bmod 2$，$k\equiv m\pmod 2$。  

考虑枚举奇数个数 $k$，假设这 $k$ 个数一开始就各加上了 $1$，然后把剩下的两次加 $1$ 当成一次加 $2$ 来看。  

于是便只剩下 $\frac{3m-k}{2}$ 次加 $2$ 操作，便变成了把 $\frac{3m-k}{2}$ 分成 $n$ 个非负整数。  

求把 $p$ 个数分为 $n$ 个非负整数的方案，就等于把 $p+n$ 个数分为 $n$ 个正整数。  
考虑有一个全为 $1$ 的，长度为 $p+n$ 的数列，把其分割成 $n$ 段，即可得到需要的 $n$ 个正整数。  
因为要分成 $n$ 段，所以割 $n-1$ 次，方案就是 $C_{p+n-1}^{n-1}$ 种。  

所以答案为 $\sum_{k\equiv m\pmod2}^{m} C_{n}^{i}\cdot C_{\frac{3m-k}{2}+n-1}^{n-1}$。  

但是这样还是不对，因为题目中说 $i\ne j$，所以这个数列里的数不能出现大于 $2m$ 的数。  

但是大于 $2m$ 的数最多也只有一个，把它减掉 $2m+1$ 即可转换为把 $m-1$ 分为 $n$ 个非负整数。  

方案数为 $C_{n+m-2}^{m}\cdot n$，减掉它就可以了。  

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
const int N=2e6+9;
int fac[N],inv[N];
int qpow(int a,int k)
{
    int now=1;
    while(k)
    {
        if(k&1) now=(now*a)%mod;
        a=(a*a)%mod;
        k>>=1;
    }
    return now;
}
int C(int a,int b)
{
    if(b>a)
    return 0;
    return (fac[a]*inv[b]%mod)*inv[a-b]%mod;
}
int n,m,ans;
signed main()
{
    fac[0]=1;
    for(int i=1;i<N;i++)
    {
        fac[i]=(fac[i-1]*i)%mod;
    }
    inv[N-1]=qpow(fac[N-1],mod-2);
    for(int i=N-1;i>=1;i--)
    inv[i-1]=(inv[i]*i)%mod;
    cin>>n>>m;
    for(int i=m%2;i<=m;i+=2)
    {
        ans=(ans+C(n,i)*C((3*m-i)/2+n-1,n-1)%mod)%mod;
    }
    ans=((ans-n*C(n+m-2,n-1)%mod)%mod+mod)%mod;
    cout<<ans;
    return 0;
}
```


---

## 作者：LwxAkioi (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/AT_agc036_c)
## 题意
$n$ 个初始为 $0$ 的数，可以进行 $m$ 次操作，每次操作选择两个不同的元素分别加上 $1$ 和 $2$，求有多少种不同的方案。
## 题解
首先我们可以发现几个性质：

$\sum a_i = 3\times m$

$\max{a_i}\le 2\times m$

并且由于只能加 $m$ 次 $1$，所以序列中奇数的个数最多为 $m$ 个。

可以考虑枚举奇数个数。设此时奇数个数为 $k$，当 $3 \times m - k$ 是奇数时，必然还会存在另一个奇数，所以此方案不合理；当为偶数时，还剩余 $3 \times m - k$ 个数没有加上去。

可以将剩余的需加上的数看成若干次 $+2$ 操作，令 $t = \frac{3 \times m - k}{2}$，表示 $+2$ 的次数，也就是求使得 $\sum{a_i} = t$ 成立的方案数。

对于求这类问题，我们可以将其看作有 $n + t$ 个 $1$，求要使其两两合并，合成 $n$ 个数的方案数，方案数便很好求了，为 $C_{n+t-1}^{n-1}$。

总方案数为 $C_n^kC_{n+t-1}^{n-1}$。

但是会有多余的方案数，即 $\max{a_i} > 2\times m$ 的不合理情况。显然，大于 $2\times m$ 的数只可能存在一个，只需要枚举此数的位置与其余数的分配情况。

方案数为 $n\times C_{n +m-2}^{n-1}$。
## CODE
```cpp
#include <iostream>
#define int long long

using namespace std;

const int N = 5e6 + 5;
const int MOD = 998244353;

int n, m, inv[N], fac[N];

int ksm(int x, int n) {
  if (n == 0) {
    return 1;
  } else if (n % 2) {
    return x * ksm(x, n - 1) % MOD;
  }
  int temp = ksm(x, n / 2);
  return temp * temp % MOD;
}

int C(int x, int y) {
  // cout << fac[y] << ' ' << inv[x] << ' ' << inv[y - x] << '\n';
  if (x > y) {
    return 0;
  }
  return fac[y] * inv[x] % MOD * inv[y - x] % MOD;
}

signed main() {
  cin >> n >> m;
  fac[0] = fac[1] = 1;
  for (int i = 2; i < N; ++ i) {
    fac[i] = fac[i - 1] * i % MOD;
  }
  inv[N - 1] = ksm(fac[N - 1], MOD - 2);
  for (int i = N - 2; i >= 0; -- i) {
    inv[i] = inv[i + 1] * (i + 1) % MOD;
  }
  int ans = 0;
  for (int i = 0; i <= m; ++ i) {
    if ((3 * m - i) % 2) {
      continue;
    }
    int p = (3 * m - i) / 2;
    // cout << C(i, n) << '\n';
    ans = (ans + (C(i, n) * C(n - 1, n + p - 1) % MOD)) % MOD;
  }
  // cout << ans << ' ';
  ans = ((ans - n * C(n - 1, m + n - 2) % MOD) % MOD + MOD) % MOD;
  cout << ans;
}
```

---

## 作者：yzq_yzq (赞：0)

小清新组合题。

因为答案跟加的过程没关系，考虑直接对最后的序列计数。

可以发现最后 $a$ 满足三个性质，和为 $3m$ ，奇数不超过 $m$ 个，然后最大值不超过 $2m$ ，最大值限制是因为每次操作 $i≠j$ ，假如 $>2m$ 构造不出来。

考虑先枚举奇数个数 $x$ ，假如不限制最大值，那么答案是好算的，令 $p = \frac {3m-x} {2}$ ，那么就是先选 $x$ 个奇数，然后把 $p$ 个 $2$ 给到 $n$ 个数上，是 $\binom {n}{x}\binom{n+p-1}{n-1}$ 。假如 $3m-x$ 是奇数特判一下。

接着考虑最大值限制，发现存在最大值 $>2m$ 时，最大值肯定只有一个，而且其它数的和是 $<m$ 的，那么肯定就能满足奇数个数 $\leq m$ ，那先选定一个数给它加到 $2m+1$ ,剩下的随便放，于是不合法的方案就是 $n\binom{n+m-2}{n-1}$ 。

---

## 作者：_Flame_ (赞：0)

### $\text{solution}$

要满足三个条件：

- $\sum a_i=3\times m$

- $\max\limits_{i=1}^{n} a_i\le 2\times m$

- $a_i \bmod 2=b_i,\sum b_i\le m$

第一条显然永远符合，考虑满足第三条的情况下减去不满足第二条的数量。

枚举奇数个数 $i$，$3\times m-i$ 显然偶，设 $x=\frac{3\times m-i}{2}$，方案数为 $C_{n}^{i}\times C_{n-1+x}^{n-1}$。

减去不满足第二条的，大于 $2\times m$ 的数显然只会有一个，枚举此数的位置与其余数的分配情况，方案数为 $n\times C_{n+m-1}^{n-1}$。

两者相减即为答案。

---

## 作者：Robin_kool (赞：0)

题目中所说的所有方案要满足：

+ $\sum a_i=3m$

+ $\max_{i=1}^n a_i \leq 2m$

+ $a_i \bmod 2 = b_i, \sum b_i \leq m$

转换一下题意，发现一定有 $\sum_{i=1}^n a_i = 3m$。

发现第二条性质有点难想，不妨先考虑满足第三条的情况，再减去不满足第二条性质的情况总数。

枚举奇数个数 $k$，如果 $3m - k$ 是奇数，必然会存在另一个奇数，从而违背上述性质。因此 $3m-k$ 为偶数，设 $x=\frac{3k-m}{2}$，不难发现总方案数等于 $n$ 个整数的和为 $x$，最后别忘了乘上选出 $k$ 个奇数的方案，即 $C(n,k)$。

再计算不合法的方案数，即有数 $a_i \geq 2m$，根据鸽巢原理，最多只有 $1$ 个数。将 $a_i\gets a_i-1$ 便可满足，然后在剩下的 $n$ 个数内凑出 $m-1$ 的方案。

组合数学过水，不多叙述。

---


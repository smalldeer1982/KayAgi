# [AGC054C] Roughly Sorted

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc054/tasks/agc054_c

すぬけくんは，$ (1,\ 2,\ ...\ N) $ の順列 $ P=(P_1,P_2,\cdots,P_N) $ と整数 $ K $ をもらいました． そこですぬけくんは，$ P $ の隣接する二項をswapすることを繰り返して，以下の条件が満たされるようにしました．

- それぞれの $ 1\ \leq\ i\ \leq\ N $ について， $ 1\ \leq\ j\ <\ i $, $ P_j\ >\ P_i $ を満たす $ j $ が高々 $ K $ 個である．

ここで，すぬけくんは**最小**の操作回数でこの条件を達成しました．

すべての操作が終わったあと，すぬけくんは元の順列を忘れてしまいました． 操作後の順列 $ P' $ が与えられるので，元の順列 $ P $ としてあり得るものが何通りあるかを $ 998244353 $ で割った余りを求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ 1\ \leq\ K\ \leq\ N-1 $
- $ 1\ \leq\ P'_i\ \leq\ N $
- $ P'_i\ \neq\ P'_j $ ($ i\ \neq\ j $)
- それぞれの $ 1\ \leq\ i\ \leq\ N $ について， $ 1\ \leq\ j\ <\ i $, $ P'_j\ >\ P'_i $ を満たす $ j $ が高々 $ K $ 個である
- 入力される値はすべて整数である

### Sample Explanation 1

$ P $ として考えられるのは以下の $ 2 $ 通りです． - $ P=(3,1,2) $: 最小の操作回数は $ 0 $ 回です．操作後の順列は $ P' $ に一致します． - $ P=(3,2,1) $: 最小の操作回数は $ 1 $ 回です．$ P_2 $ と $ P_3 $ をswapすることで，$ P=(3,1,2) $ となり，これは条件を満たします．操作後の順列は $ P' $ に一致します．

## 样例 #1

### 输入

```
3 1
3 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3
4 3 2 1```

### 输出

```
1```

## 样例 #3

### 输入

```
5 2
4 2 1 5 3```

### 输出

```
3```

# 题解

## 作者：Creeper_l (赞：3)

## 题意

定义一种操作为交换 $a_{i}$ 和 $a_{i-1}$。对于一个长度为 $n$ 的排列，你需要操作若干次，使这个序列变合法，一个序列合法指：满足对于每一个 $1\le i \le n$，都满足包含 $a_i$ 的逆序对的个数不超过 $k$，并且要求最小化操作次数。现在给定一个操作后的序列，询问原序列可能的个数。答案对 $998244353$ 取模。

## 思路

我们先来思考如何求从一个序列变为合法序列的最小操作次数。因为操作只能交换相邻两个数，所以一次操作最多只能使逆序对的个数减一。设 $b_{i}$ 表示包含第 $i$ 个数的逆序对个数。那么我们每一次都尽量贪心地操作，即操作的 $i$ 都满足：$b_{i}>k$ 并且 $a_{i}<a_{i-1}$。因为这样操作才能有效果，并且效果最大。

那我们就可以猜想是不是每一次都可以这样操作？那就需要考虑是不是每一次都能找到一个位置满足上述条件。答案是肯定的。考虑用反证法来证明，如果没有位置满足上述条件，即对于每一个 $b_{i}>k$，都有 $a_{i-1}< a_{i}$。那么又因为 $a_{i-1}< a_{i}$，所以 $b_{i}\ge b_{i-1}>k$，所以又可以推出 $a_{i-2} < a_{i-1}< a_{i}$，以此类推，最终可以得到：

$\begin{cases}a_{1} <a_2<\dots <a_i
 \\b_i \ge b_i-1 \ge \dots \ge b_1
\end{cases}$

所以 $k=0$，但是题目上说 $k \ge 1$，所以矛盾，于是得证。所以证明到了每一次一定能按照最优的方案去操作，总结操作方式为：每次选择一个 $i$ 满足 $b_{i}>k$ 并且 $a_{i}<a_{i-1}$，交换 $a_i$ 和 $a_{i-1}$。

回到原题，再来考虑如何用最终的序列算出原序列可能的个数。首先，我们只考虑 $b_{i}=k$ 的位置，因为如果 $b_{i} \ne k$，那么这个数现在的位置和原来的位置是没有变化的。考虑 $b_i=k$ 的位置，我们会发现原序列中 $a_{i}$ 这个数的位置一定在 $i$ 后面，并且在 $i$ 后面的任意一个位置都可以选择。因为如果在 $i$ 的前面的话，显然它不会向后移动。所以最终的答案是 $\prod_{b_{i}=k}^{} (n-i+1)$，总时间复杂度 $O(n^{2})$，用树状数组可以优化到 $O(n \log n)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int MAXN = 5e3 + 10;
const int mod = 998244353;
int n,k,a[MAXN],b[MAXN],id[MAXN],p,ans;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> k;
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 1;i <= n;i++)
	{
		int sum = 0;
		for(int j = 1;j < i;j++) if(a[j] > a[i]) sum++;
		if(sum == k) id[++p] = i; 
	} 
	ans = 1;
	for(int i = 1;i <= p;i++) ans = (ans * (n - id[i] + 1)) % mod;
	cout << ans; 
	return 0;
}

```


---

## 作者：EuphoricStar (赞：2)

考虑一个合法的 $P$，记 $a_i = \sum\limits_{j=1}^{i-1} [P_j > P_i]$，则通过简单推理可得 $a_i < a_{i+1} \Leftrightarrow P_i > P_{i+1}$。易知一次合法交换操作 $(i,i+1)$ 当且仅当 $a_i < a_{i+1} \land a_{i+1} > K$，否则就不能使得交换次数最小，并且交换后 $a_i \gets a_i - 1$。

现在已知 $P'$，考虑求 $b_i = \sum\limits_{j=1}^{i-1}[P'_j > P'_i]$，并且进行逆操作。因此一次交换操作 $(i,i+1)$ 合法当且仅当 $b_i \ge b_{i+1} \land b_i \ge K$，且交换后 $b_{i+1} \gets b_{i+1} + 1$。逆序考虑所有满足 $b_i = K$ 的 $i$，则 $P'_i$ 最多可以往右移 $n-i$ 次，有 $n-i+1$ 种选择。根据乘法原理易得答案为 $\prod\limits_{b_i=K} (n-i+1)$。

时间复杂度 $O(n^2)$，若使用树状数组求 $b$ 则复杂度降为 $O(n \log n)$。

[code](https://atcoder.jp/contests/agc054/submissions/39147786)

---

## 作者：SunsetLake (赞：1)

首先我们可以考虑在已知原排列的情况下，如何判断这个序列是否能按题意得到 $p$ 这个排列。设原排列为 $q$。

记 $a_i$ 表示在 $q$ 的第 $i$ 个位置上，有多少个 $j$ 满足 $1 \leq j < i$ 且 $q_j>q_i$。如果所有的 $a_i$ 都已经 $\leq k$ 了，那么 $q$ 就已经不能在操作了，此时就得不到 $p$。所以在 $q$ 中一定有一些 $a_i$ 是 $> k$。又因为必须要最小化操作数，所以对于每个 $q_{i-1} > q_i$ 且 $a_i > k$ 的位置都会把 $q_i$ 与 $q_{i-1}$ 交换，使 $a_i$ 减少 $1$，直到 $a_i$ 的值刚好 $=k
$ 时便不去动它了。而那些 $a_i \leq k$ 的点我们肯定不会主动去动它，这样就能最小化操作数了。

记 $b_i$ 表示在 $p$ 中的 $a_i$。可以 $\mathcal{O(n^2)}$ 预处理求出。

有了这个分析，就可以去考虑怎样通过 $p$ 去推出原排列。由于 $> k$ 的点一定会被最小操作次数变为 $ =k$，于是在 $p$ 中 $b_i = k$ 的点一定是从 $\ge k$ 交换过来的，并且每一次交换都是从后面换到前面，所以这些点在原排列中可以是其后面 $n-i+1$ 个点中的任意一个。再根据乘法原理，就可以得到原排列的个数为 $\displaystyle\prod_{b_i = k}(n-i+1)$。

复杂度 $\mathcal{O(n^2)}$。

## code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=998244353;
int n,k;
ll ans=1;
int p[5005];
int a[5005],b[5005],c[5005];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;++i)scanf("%d",&p[i]);
	for(int i=1;i<=n;++i)for(int j=1;j<i;++j)if(p[j]>p[i])a[i]++;
	for(int i=1;i<=n;++i)if(a[i]==k)ans=(ans*(ll)(n-i+1))%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：BINYU (赞：1)

## 题意

给定 $k$ 和一个排列 $P'$，问有多少个排列 $P$ 以最少步数交换相邻两个元素来进行收敛，最终的排列可能是 $P'$，一个排列是收敛的当且仅当对于每一个数，在该数前且比这个数大的数的个数不超过 $k$ 个。

## 思路

考虑正向的让一个排列收敛，我们设在第 $i$ 个位置前且比 $P_i$ 大的数有 $cnt_i$ 个，最终收敛的条件为 $\max\{cnt_1,cnt_2,\dots,cnt_n\} \le k$。

考虑一次交换中 $cnt$ 数组的变化，由于在 $[1,i-1]$ 区间的贡献对于 $i$ 和 $i+1$ 是可以直接交换的，我们**只需要考虑 $P_i$ 对 $P_{i+1}$ 的贡献**即可：

1. $P_i > P_{i+1}$，则**交换后**的 $cnt_i$ 会少了**原来** $P_i$ 的贡献，故先交换，然后 $cnt_i=cnt_i-1$；

2. $P_i < P_{i+1}$，则**交换后**的 $cnt_{i+1}$ 会多了**原来** $P_{i+1}$ 的贡献，故先交换，然后 $cnt_{i+1}=cnt_{i+1}+1$。

我们肯定不会对第二种情况进行交换，而对于第一种情况，我们也只会对原来 $cnt_{i+1}>k$ 的位置进行交换，进一步考虑，发现第一种情况等价于 $cnt_i < cnt_{i+1}$，故交换的条件为：$cnt_i < cnt_{i+1}$ 且 $cnt_{i+1}>k$。

接下来考虑从 $P'$ 反着交换回 $P$ 的情况，相当于前面的逆运算，我们设在第 $i$ 个位置前且比 $P_i$ 大的数有 $cnt'_ i$ 个，则交换的条件为 $cnt'_ i + 1 > cnt'_ {i+1}$ 且 $cnt'_ i + 1 > k$，又因为 $P'$ 一定是已经收敛的数组，所以 $cnt'_ i$ 一定不大于 $k$，故条件可进一步简化为 $cnt'_ i = k$。

每次交换相当于把这个数往后挪一位并加一，所以我们**从后往前算方案数**更方便。

对于最后一个满足 $cnt'_ i = k$ 的 $i$ ，它往后挪多少位都是可以的，而对于前面的，在它挪到上一个 $cnt'_ i = k$ 现在所在的位置之前，显然也是可以的，而因为挪的过程中它会自增 $1$，所以前面来的数一定不会小于后面的数，所以在此时交换也是合法的。综上，对于每一个满足 $cnt'_ i = k$ 的 $i$，都能随意往后挪动，至多可以挪动 $n - i$ 次，故一共有 $n - i + 1$ 中选择，所以答案为 $\prod\limits_{cnt'_ i=k}(n-i+1)$。

对于求 $cnt'_ i$，直接遍历是 $O(n^2)$ 的，使用树状数组是 $O(n\log n)$ 的，都可以通过本题（~~应该没人会在这里写分块啥的吧~~）。

---

## 作者：Unnamed114514 (赞：0)

\* 1863，老外的思维能力咋这么猛？

令 $\{a\}$ 表示当前序列，$b_i$ 表示 $i$ 前面有几个比 $a_i$ 大。

考虑先找到贪心策略：选择一个 $b_i>k$ 且 $a_i<a_{i-1}$ 的位置，交换 $a_i$ 和 $a_{i-1}$。

这样操作完成后一定是对的吗？

显然是对的，因为如果 $b_i\le k$ 就一定符合条件了了，否则 $a_{i-1}<a_i$ 此时 $b_{i-1}\ge b_i>k$，但是 $i-1$ 不交换那么就有 $a_{i-2}<a_{i-1}$，以此类推能得到 $a_1<a_2<a_3<\cdots<a_i$，显然 $b_i=0\le k$。

在这样的策略下，每次交换一定只会让 $b_i$ 减 $1$，其它的 $b$ 不变，所以一次操作不会影响其它数的前移。

但是我们得到的是结果序列，现在需要倒推初始序列。

首先 $b_i<k$ 的位置一定是不会前移的，因此我们只需要考虑 $b_i=k$ 的位置。

容易发现后面的 $a$ 都比它大，否则 $i$ 会对后面的 $b$ 造成贡献，这个时候这个位置的 $b$ 至少就是 $k+1$ 了，显然不行。

所以我们在后面随便选一个位置，按照上述策略都会移动到现在的位置，一共有 $n-i+1$ 个位置可以选，所以答案就是 $\prod\limits_{b_i=k}(n-i+1)$。

---

## 作者：strcmp (赞：0)

设原排列是 $p_i$，$c_i \leftarrow \sum\limits_{j=1}^{i - 1} [p_j > p_i]$，目标要求 $\forall i,\,c_i \le k$。题目输入给我们的目标排列是 $a$，$b_i \leftarrow \sum\limits_{j=1}^{i - 1} [a_j > a_i]$。

首先我们肯定先考虑从不合法排列到合法排列的最优方案怎么走。

考虑满足 $p_{i - 1} > p_i \wedge c_{i} > k$ 的位置（将这种位置称为「**可改进**」 的），我们交换 $i - 1$ 和 $i$ 显然不劣，因为我们每次交换最多减少一次 $c$ 中的元素，而目标是将 $\max c$ 减少到 $k$ 以下。

我们可以证明如果经过操作找不到「可改进」的位置，那么必然 $\forall c_i,\,c_i \le k$。

证明考虑反证，假设现在对于 $\forall c_i > k$ 都有 $p_{i - 1} < p_i$。考虑第一个满足 $c_d > k$ 的位置，根据 $p_{d - 1} < p_d$ 显然有 $c_{d - 1} = c_d > k$，令 $d \leftarrow d - 1$。

因此 $d$ 必然等于 $1$ 否则我们可以得到更小的 $d$。此时我们得到 $c_1 > k$，而 $c_1 = 0$ 故不存在合法的 $k$。矛盾所以结论得证。

我们可以得到最小操作次数就是 $\sum \max(c_i - k,\,0)$。

接下来考虑这个性质怎么帮助我们做题。

根据题意 $b$ 一定满足 $b_i \le k$，而 $b_i < k$ 的位置显然不是靠交换得到的，因为我们只交换「可改进」位置，$b_i = k$ 就不是可改进位置了。

因此给定序列中满足 $b_i = k$ 的位置才有可能是后面交换过来的。

我们不妨考虑从最后一个位置往前推交换得出可能的原始序列。即枚举 $i = n,\,n - 1,\,n - 2,\,\dots,\,1$，考虑 $i$ 交换到 $i$ 之后的哪个位置。

显然设当前枚举到 $i$。如果 $b_i = k$ 那么 $a_i$ 后面一定都是比它大的，否则任取一个比 $a_i$ 小的 $a_j,\,j > i$ 一定有 $b_j > b_i = k$ 直接不合法。

因为后面一定是比它大的，那么我们可以把 $i$ 交换到 $i$ 之后的任意一个位置，最小操作数一定单调递增进而都是可以通过最优操作交换到 $a$ 的。贡献是 $n - i + 1$。

根据乘法原理，答案即为 $\prod\limits_{i = 1}^{n} (n - i + 1) \times [b_i = k]$。

直接暴力计算 $b$ 时间复杂度 $\Theta(n^2)$，可以用树状数组优化到 $\Theta(n \log n)$ 但数据范围小没有必要。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define mp make_pair
#define gc getchar
#define pc putchar
using namespace std;
using ld = double;
typedef long long int ll;
typedef long long int i128;
using pli = pair<ll, int>;
using ppi = pair<pli, int>;
using vec = vector<int>;
const ll inf = 1LL << 60;
constexpr int maxn = 2e5 + 10, mod = 998244353;
int n, k, a[maxn], b[maxn];
int main() {
    scanf("%d%d", &n, &k); ll ans = 1;
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < i; j++) b[i] += (a[i] < a[j]);
        if (b[i] == k) ans = ans * (n - i + 1) % mod;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---


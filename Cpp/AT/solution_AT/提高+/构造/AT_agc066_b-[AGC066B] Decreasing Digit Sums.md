# [AGC066B] Decreasing Digit Sums

## 题目描述

### 题意翻译

定义 $f(x)$ 表示 $x$ 各数位之和，例如 $f(331)=3+3+1=7$，$f(2024)=2+0+2+4=8$，$f(1)=1$ 等。

给定 $n$，你需要找到一个数 $k$ 满足以下条件：

- $1\leq k\leq10^{10000}$；
- 对于任意整数 $1\leq i\leq n$，有 $f(2^{i-1}k)>f(2^ik)$。

## 说明/提示

$1\leq n\leq50$。

## 样例 #1

### 输入

```
3```

### 输出

```
89```

# 题解

## 作者：Rainbow_qwq (赞：7)

通过打表比较优的情况可以发现，优秀的情况末尾都有一串 $0$。考虑构造一个数，使得每次 $\times 2$，末尾会变成 $0$。

那问题转化为：构造一个奇数，使它在 $n$ 次内，每次 $\times 5$ 数位和递增，然后构造 $x\times 5^n$ 即可。

比如 $3\to 15\to 75\to 375$ 递增，则可以构造 $375\to 750\to 1500\to 3000$。

但如果随便取一个奇数 $1,3$，在若干次 $\times 5$ 后就会有一次不递增的...

但是我们可以把一堆数乘 $5^{50}$ 拼起来（比如取 $[1,100]$），并在它们之间加一串 0 使得它们在乘法后互不影响。然后发现这样就递增了！因为整体的趋势是递增的，将大量的数拼起来消去了小量的递减影响。

```cpp
int x,n;

int F(__int128 x){
	if(x<=9)return x;
	return x%10+F(x/10);
}

mt19937_64 rnd(time(0));
__int128 pw[maxn],pw5[maxn];
int s[maxn];

string res;

signed main()
{
//	freopen("my.out","w",stdout);
//	n=read();
	pw[0]=1;
	For(i,1,20)pw[i]=pw[i-1]*10;
	
	For(j,1,100){
	    if(j%2==0)continue;
		pw5[0]=j;
		For(i,1,50){
			pw5[i]=pw5[i-1]*5;
			assert(pw5[i-1]<pw5[i]);
		}
		For(i,0,50) s[i]+=F(pw5[i]);
	//	For(i,0,50) cout<<F(pw5[i])<<" ";cout<<"\n";
		__int128 t=pw5[50];
		string now;
		while(t) now+=('0'+(t%10)),t/=10;
		reverse(now.begin(),now.end());
		if(j!=1){
			For(k,0,50) res+='0';
		}
		res+=now;
	}
//	cout<<"SZ "<<res.size()<<"\n";
//	For(i,0,50) cout<<s[i]<<" "; cout<<"\n";
	For(i,0,49) assert(s[i]<s[i+1]);
	cout<<res<<"\n";
	exit(0);
}
```

---

## 作者：ZnPdCo (赞：5)

题目大意：给定 $n$，求一个 $x$，使得对于任意的 $1\le i\le n$，满足 $d(2^{i-1}x)>d(2^ix)$。其中 $d(x)$ 指 $x$ 的数位和。

我们发现，答案是具有单调性的，也就是对于 $n=50$ 的答案，同样适用于 $n<50$ 的情况。

所以我们只用考虑 $n=50$ 的答案即可。

---

按照直观的感受，给定任意的 $x$ 与 $y$，已知 $x>y$，那么 $d(x)$ 大于 $d(y)$ 的概率会比较大。

但是随着 $i$ 的增加，$2^ix$ 也会随之增加，所以我们要考虑减小 $d(2^ix)$。

我们发现，如果某一个数位为 $0$，对于 $d$ 函数就没有贡献。所以考虑构造一个 $x$，使得它乘上 $2^i$ 可以产生若干个 $0$。所以设 $x=5^{50}a$，那么 $d(2^ix)=d(2^i5^{50}a)=d(10^i5^{50-i}a)=d(5^{50-i}a)$，此时随着 $i$ 的增加，$5^{50-i}a$ 也会随之减小，那么 $d(2^ix)=d(5^{50-i}a)$ 肯定也会趋于减小。具体：

![](https://cdn.luogu.com.cn/upload/image_hosting/7k1nn7er.png)

---

但是这样仍旧不是单调递减的，但是它是趋于单调递减的，所以我们可以考虑把它们拼接起来，这样平均下来，单调递减的概率就会大大上升。

我们随机得到 $a_1,a_2,\cdots,a_k$，然后将这 $k$ 个系数组成的 $5^{50}a_1,5^{50}a_2,\cdots,5^{50}a_k$ 用若干个 $0$ **连接**起来（用 $0$ 连接是为了防止进位影响其他数），这样就可以保证它单调递减的概率比较大：

![](https://cdn.luogu.com.cn/upload/image_hosting/8l8h0o36.png)

下面代码中的 `bign` 是高精度，`check` 是判断是否合法的函数：

```cpp
ll n = 50, k = 100;
bign a = 1, ans;
int main() {
	for(ll i = 1; i <= 50; i ++) a = a * 5;
	while(true) {
		ans = 0;
		for(ll i = 1; i <= k; i ++) {
			ll x = rnd() % 100 + 1;
			bign tmp = a * x;
			for(ll j = 1; j <= tmp.len + 50; j ++) ans = ans * 10;
			ans = ans + tmp;
		}
		if(check(ans)) {
			cout << ans << endl;
			break;
		}
	}
	return 0;
}
```

[一种可能的结果](https://atcoder.jp/contests/agc066/submissions/51965371)

---

## 作者：wind_boy (赞：4)

乱搞题。

设 $x=10^{50}i$，可以发现，在 $x$ 除以 $2$ 的过程中，$f(x)$ 大致呈递增态（有少量位置递减）。

假如说我们找到了 $x_1,x_2,\cdots,x_m$（设 $y_i=\dfrac{x}{2^i}$）。由于在某些位置，$x_i$ 的 $f$ 值可能递减，但其他大多数地方均递减，因此我们可以“**取长补短**”，构造 $w=y_10\cdots0y_20\cdots0y_30\cdots\cdots$，此时 $f(w)=\sum\limits_{i=1}^m f(y_i)$，并满足 $f(w)$ 呈严格递增态。

至于 $x$ 的求解，我的方法是枚举 $m$，然后令 $x_i=10^{50}i$，并判断是否合法。搜索后可以发现 $m=91$ 时是合法的。

打表代码：

```cpp
#include<bits/stdc++.h>
#define fo(i,l,r) for(int i=(l);i<=(r);++i)
#define fd(i,l,r) for(int i=(l);i>=(r);--i)
#define fu(i,l,r) for(int i=(l);i<(r);++i)
#define ll long long
using namespace std;
int n,lt,l,nw;
__int128 t=1;
int gt(__int128 s)
{
	return s>0?gt(s/10)+s%10:0;
}
void print(__int128 s)
{
	if(s>9) print(s/10);
	putchar(s%10+'0');
}
struct gao{
	__int128 s1,s2;
	void div()
	{
		s2=(s2+(s1%2)*t)/2;
		s1/=2;
	}
}s[307];
int gt(gao s){return gt(s.s1)+gt(s.s2);}
int p[107];
void pt(__int128 s)
{
	fo(i,1,30)
	{
		p[i]=s%10;s/=10;
	}
	fd(i,30,1) printf("%d",p[i]);
}
void print(gao s)
{
	pt(s.s1);pt(s.s2);
//	if(s.s1) print(s.s1);
//	print(s.s2);
}
int main()
{
	n=50;
	fo(i,1,30) t*=10;
//	fo(L,1,100)
	{
		l=91;
		fo(i,1,l) s[i].s1=t*i,s[i].s2=0;
		lt=0;
		fo(j,1,l) lt+=gt(s[j]);
		fo(i,1,n)
		{
			fo(j,1,l) s[j].div();
			int nw=0;
			fo(j,1,l) nw+=gt(s[j]);
			if(lt>=nw)
			{
				printf("!%d\n",i);
				fo(j,1,l) print(s[j]);
				printf("\n");
			}
			lt=nw;
		}
		fo(j,1,l) print(s[j]);//这里没删前导 0
		printf("\n");
	}
}
```

---

## 作者：tobie (赞：2)

你看这个讨论数位问题的 $f$ 函数里面塞了个乘法操作，我们要让里面的数不断加倍并且数位和单调递减，考虑构造。

事实上，我们如果构造出了 $n=50$ 的答案，那么就解决了整个问题。

发现有两个非常不错的数字：$5$ 和 $0$。

$0$ 的倍数还是 $0$，$5$ 翻倍后变成 $10$，此外别的数字都没有什么比较好利用的性质，考虑从 $5$ 入手构造答案。

考虑 $n=2$。 注意到 $25\times 2=50$，所以 $25$ 是 $n=2$ 的一个答案。

所以我们也发现了一个非常重要的性质： 当 $i\le x$ 时，$f(5^x\times 2^i)=f(5^{x-i}\times10^i)=f(5^{x-i})$。

所以我们可以将若干个 $5$ 的幂次拼接起来，如 $3125625125255$，拼个一百六十项就可以通过了。

感性理解一下，$f(\overline {5^x5^{x-1}5^{x-2}\cdots 5^25}\times2)=f(\overline {5^{x-1}5^{x-2}\cdots 5^251})$，发现幂次整体减少了 $1$，所以数位和减少量就大约为 $f(5^x)$。只要我们让 $5^x$ 远大于后面捣乱的 $124816$这些干扰项就可以满足题意。

代码实现需要使用高精度，用python可能更简洁，但是我不会。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=10009;
int val[N],ans[N];
signed main()
{
	val[1]=val[0]=1;
	for(int i=1;i<=160;i++)
	{
		int jw=0;
		for(int i=1;i<=val[0];i++)
		{
			val[i]=val[i]*5+jw;
			jw=val[i]/10;
			val[i]%=10;
		}
		if(jw) val[++val[0]]=jw;
		for(int j=1;j<=val[0];j++) ans[++ans[0]]=val[j];
		ans[++ans[0]]=0;
	}
	for(int i=ans[0]-1;i>=1;i--) printf("%d",ans[i]);
}
```

---

## 作者：0xyz (赞：1)

这道题是提交答案题，只要构造出 $n=50$ 时的答案即可。

注意到我们可以构造很多满足 $f(x),f(2x),…,f(2^{50}x)$ 大致上递减的 $x_1,…,x_k$，使得 $\sum\limits_{1\le i\le k}f(x_i),\sum\limits_{1\le i\le k}f(2x_i),…\sum\limits_{1\le i\le k}f(2^{50}x_i)$ 严格递减。

实际构造的时候 $\forall 1\le i<k$，由于 $2^{50}<10^{20}$，用 $\ge 20$ 个 $0$ 将 $x_i$ 与 $x_{i+1}$ 隔开使得它们即便 $\times 2^{50}$，依然互不干扰。

一个很显然的想法是，$\forall 1\le i\le k,x_i=5^{u_i},u_i\ge 50$，这是因为每次 $\times 2$ 都会有一个数位固定为 $0$，所以大致递减。

打表打出 $\forall 0\le i\le 99,f(5^i)$，这个数列大致递增，同时不难发现 $\forall 0\le i\le 79,f(5^i)<f(5^{i+20})$ 成立。

那么我们可以令 $k=20,\forall 1\le i\le20,x_i=5^{49+i}$。这时 $\forall 0\le j\le 49,$
$$\begin{aligned}f(2^{j+1}x)-f(2^jx)&=\sum\limits_{1\le i\le k}f(2^{j+1}x_i)-\sum\limits_{1\le i\le k}f(2^jx_i)\\&=\sum\limits_{1\le i\le 20}f(2^{j+1}5^{49+i})-\sum\limits_{1\le i\le 20}f(2^j5^{49+i})\\&=\sum\limits_{1\le i\le 20}f(5^{48+i-j})-\sum\limits_{1\le i\le 20}f(5^{49+i-j})\\&=\sum\limits_{49-j\le i\le 68-j}f(5^i)-\sum\limits_{50-j\le i\le 69-j}f(5^i)\\&=f(5^{49-j})-f(5^{69-j})\\&<0\end{aligned}$$

注意到 $\forall 1\le i\le 20,x_i\le 5^{69}<10^{50}$，再算上 $x_i$ 与 $x_{i+1}$ 之间的 $20$ 个 $0$，所以我们直接构造 $x=\sum\limits_{1\le i\le 20}5^{49+i}\times 10^{70i-70}=\sum\limits_{0\le i\le 19}5^{50+i}\times 10^{70i}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll o=1e17;
char s[1400];
ll h=0;
struct __int51{
	ll a,b,c;
}w;
void work(ll d,ll x){
	while(x)s[d++]='0'+x%10,x/=10;
}
__int51 mul(__int51 x,ll y){
	x.c*=y;x.c+=x.b*y/o;
	x.b=x.b*y%o;x.b+=x.a*y/o;
	x.a=x.a*y%o;
	return x;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	w.a=1;
	for(ll i=0;i<=1399;i++)s[i]='0';
	for(ll i=1;i<=49;i++)w=mul(w,5);
	for(ll i=0;i<=19;i++)w=mul(w,5),work(70*i,w.a),work(70*i+17,w.b),work(70*i+34,w.c);
	for(ll i=1399;~i;i--){
		h+=s[i]-'0';
		if(h)cout<<s[i];
	}
	return 0;
}
```

---

## 作者：yyyyxh (赞：1)

赛时被原题哥创飞了 QwQ。

不擅长构造，怎么办呢？

考虑一些乱搞搜索算法。我们做一个数位 DP 状物：同时 DP $x,2x,4x\dots 2^N x$ 十进制意义下的第 $i$ 位。然后在状态中记录下每个数是否向下一个数进位和当前数位和。

然后考虑启发式估价，我们期望数位和数组尽可能严格递减，所以可以设置权值为 $\max(a_i-a_{i-1}+1,0)$。然后每次取尽可能小的增广。

注意到这样子很难增广出结果，原因是分支太多。我们有这样一个想法：反正本题不限位数，所以我们只需要保留估价已经很优很优的增广。

所以对于每一个状态的十种后继取估价最小的两个放进队列里就行了。

（由于这个题本质是个提答，所以搜索代码没有去前导零，空间也很炸，不能直接交）

搜索代码：

```cpp
#include <queue>
#include <algorithm>
#include <cstdio>
#include <bitset>
using namespace std;
const int S=51;
const int N=9000013;
int rk;
int a[N][S];
bitset<S> b[N];
int las[N],pre[N],val[N];
int stk[N],tp;
int trans(int x,int c){
	int p=tp?stk[tp--]:++rk;
	las[p]=x;pre[p]=c;
	b[p].reset();
	for(int i=0;i<S;++i){
		if(i) c<<=1;
		c+=b[x][i];
		if(c>=10) c-=10,b[p].set(i);
		a[p][i]=a[x][i]+c;
	}
	val[p]=0;
	for(int i=1;i<S;++i) val[p]+=max(a[p][i]-a[p][i-1]+1,0);
	return p;
}
struct cmp{
	bool operator()(const int x,const int y){
		return val[x]>val[y];
	}
};
priority_queue<int,vector<int>,cmp> que;
int s[N],len;
int main(){
	que.emplace(0);
	val[0]=S-1;
	while(!que.empty()){
		int x=que.top();
		que.pop();
		if(!val[x]&&!b[x].any()){
			while(x){
				s[len++]=pre[x];
				x=las[x];
			}
			break;
		}
		int W[10];
		for(int c=0;c<10;++c) W[c]=trans(x,c);
		sort(W,W+10,[](int x,int y){return val[x]<val[y];});
		que.emplace(W[0]);
		que.emplace(W[1]);
		for(int i=2;i<10;++i) stk[++tp]=W[i];
	}
	for(int i=0;i<len;++i) printf("%d",s[i]);
	putchar('\n');
	return 0;
}
```

所以我们只需要输出这个数字即可通过：

```cpp
2296032860515341751375207910212599414475865901911025991835811710180993125628113937198750046193859401228999918864613756197498022732951155300178243564217686981936289949232517319760526411775470844015484511760851746845032025497036954590294099987272643921601781990086915793406008159217221168780933518437598883011252503106719377310513064848750039744605637810442455530962948651315818093694356395220452905036808184186904915820383595144101606129065145794068284399950922559405449505922088434517545952119054209959117982909602893465351370194147799506010934159421985625648780236880992461138653820456083001542411841956233632185835878906464786599206292635299074547452635940053177469010128203750637387802490582182118237262855842636720253009531601704532501794917883452157041095187433401011777819815687891364140732501630760960017891892102275903726894073106799903139572524752296140708978112996824472999725115054881780902290222609850819102710051012539817028226709360937738907415208927810227545411105746081724511532593699241606278829818984936808812599921227684099769046469974874877918904504959143472671745853339801463867100430071877819736499777311758018074445667810363664648030046825594860094689091189494177121679581999827722747799940522447286730757989836713683474205788941813569306200202846663089749582998071276123028413212201662497060897956092636009291848116938957808235906783121464689886474170398983056164154588124502588200369116938885284026954547181822953179537478693298324298597261904447659771298874874874940516854962926903082225492181846541746826505463100924792528590687988122006988873446194958448959792476086435186743983649648725986480712890625
```

---

## 作者：sherry_lover (赞：0)

# AT_agc066_b [AGC066B] Decreasing Digit Sums 题解

[题目传送门](https://www.luogu.com.cn/problem/AT_agc066_b)

这道题其实有点乱搞，尽可能将题解写得详细一点。

这道题的答案其实跟 $n$ 无关，只要构造一个 $n=50$ 成立的 case 就行。题意就变成求一个 $x$，设 $f(x)$ 表示 $x$ 各数位之和，满足 $f(x) > f(2x) > f(4x) > ... > f(2^{50}x)$。

这道题做法很多，这里介绍其中一种。

逆向考虑，设最终是 $k = 10^i$。不妨设 $i = 4$，即 $k = 10000$，$f(k) = 1$，$f(\frac{k}{2}) = 5$，$f(\frac{k}{4}) = 7$，$f(\frac{k}{8}) = 8$ ……，发现前面若干项是变小的，中间也有变大的。一开始的 $x$ 乘上一堆的 $2$ 最终得到 $10^i$，说明一开始的 $x$ 是不带 $2$ 的，也就是 $5^j$。但单个 $f(5^j)$ 时大时小，把多个 $5^j$ 拼起来就可以抵消这个时大时小的情况。打表发现只要把 $5^1$ 到 $5^{100}$ 拼起来就行，位数也没有超限（其实只要把 $5^{50}$ 到 $5^{66}$ 拼起来即可）。

C++需要用高精度，故本人用了python。

[通过记录](https://www.luogu.com.cn/record/163919033)

Code:

```python
s = ''
for i in range(100):
    k = 5**i
    s += str(k)
print(s)
```

---

## 作者：gan1234 (赞：0)

今天会考时太无聊，想出来了大致思路，回家就立马写了这题。

### 分析

这道题充分发挥了人类智慧。

首先 $n$ 更大的情况一定严格强于更小的情况，所以只需要考虑 $n=50$ 就行了。

转化一下题意。

令 $a_i=f(x2^i)$，令 $b_i=a_{i+1}-a_i$。满足题目限制，当且仅当所有 $b_i$ 小于 $0$。

考虑如何构造这样的数。考虑到我们可以将多个数拼接起来，不同的数用很多个 $0$ 隔开，这样这些数就不会互相因为进位而影响。这样子做可以将这些数的 $b_i$ 加起来，因此其中一个数的某个 $b_i$ 大于 $0$ 无所谓，只要最终加起来小于 $0$ 就行。

顺着这个思路往下想。

我们发现 $5$ 这个数字对于 $2$ 有很好的性质：

- 由于 $5\times 2=10$，所以 $f(2\times 5^k)=f(5^{k-1})$

- 进一步打表发现，当 $x=5^k$ 时，很多 $b_i$ 都小于 $0$。 

这对于我们想要所有 $b_i<0$ 很有帮助。

我们可以尝试将若干个 $5^k$ 拼起来。

经过打表，发现将 $5^{50},5^{51},5^{52},...,5^{66}$ 拼起来即可满足要求，这个数是：

>8881784197001252323389053344726562500000000000000000000444089209850062616169452667236328125000000000000000000002220446049250313080847263336181640625000000000000000000001110223024625156540423631668090820312500000000000000000000555111512312578270211815834045410156250000000000000000000027755575615628913510590791702270507812500000000000000000000138777878078144567552953958511352539062500000000000000000000693889390390722837764769792556762695312500000000000000000000346944695195361418882384896278381347656250000000000000000000017347234759768070944119244813919067382812500000000000000000000867361737988403547205962240695953369140625000000000000000000004336808689942017736029811203479766845703125000000000000000000002168404344971008868014905601739883422851562500000000000000000000108420217248550443400745280086994171142578125000000000000000000005421010862427522170037264004349708557128906250000000000000000000027105054312137610850186320021748542785644531250000000000000000000013552527156068805425093160010874271392822265625

### 代码

打表程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>v;
int a[1000],b[1000];
int f(){
    int res=0;
    for(int i=0;v.size()>i;i++)res+=v[i];
    return res;
}
int main(){
    int lst=5;
    v.push_back(5);
    int p=0;
    while(1){
        p++;
        //高精度乘 5
        for(int i=0;v.size()>i;i++)v[i]*=5;
        int t=0;
        for(int i=0;v.size()>i;i++){
            v[i]+=t;
            t=v[i]/10;
            v[i]%=10;
        }
        while(t){
            v.push_back(t%10);
            t/=10;
        }
        a[p]=lst-f();
        lst=f();
        if(p>=49){//构造的数
            for(int i=v.size()-1;~i;i--)cout<<v[i];
            for(int i=0;20>i;i++)cout<<0;
        }
        if(p>=65)break;
    }
    for(int j=1;15>=j;j++)
        for(int i=1;p>=i;i++)b[i]+=a[i+j-1];
    for(int i=1;50>=i;i++)cout<<b[i]<<",";   
    return 0;
}
```

---

## 作者：D2T1 (赞：0)

感觉比 A 简单。

## 8. AGC066B - Decreasing Digit Sums

考虑形如 $5^k$ 的数，如 $125$，变换后得 $125\to250\to500\to1000$，看似直接满足条件了，但是 $5^k$ 的数位和并不是递增的，在 $k$ 更大的情况下不一定满足。于是我们可以把 $5^k,5^{k-1},...,5$ 拼起来，如 $\dots3125625125255$，可以发现这个数多次 $\times 2$ 会变成：

- $\dots3,125,625,125,255$；
- $\dots6,251,250,250,510$；
- $\dots12,502,500,501,020$；
- $\dots25,005,001,002,040$；
- $\dots50,010,002,004,080$。

假设最高位是 $5^k$，那么每次操作后数位和相当于减少 $f(5^{k-x})$，增加 $f(2^x)$（$x\in[0,n]$）。当 $k$ 尽可能大的时候更有可能成功。打表可得 $k=160$ 时可行且总长度 $<10000$。

```cpp
//AT_agc066_b
#include <bits/stdc++.h>
using namespace std; typedef long long ll;
void solve();int main(){ solve(); return 0; }

const int N = 10010;
int s[N], t[N];
int n, len = 1, tot = 1;

void solve(){
	cin >> n;
	t[1] = s[1] = 5;
	for(int i = 2; i <= 160; ++ i){
		for(int j = 1; j <= len; ++ j){
			t[j] = t[j] * 5;
			t[j] = t[j] + t[j-1] / 10;
			t[j-1] %= 10;
		}
		while(t[len] >= 10){
			t[len+1] = t[len] / 10;
			t[len] %= 10;
			++ len;
		}
		for(int j = 1; j <= len; ++ j){
			s[++tot] = t[j];
		}
	}
	for(int i = tot; i >= 1; -- i){
		printf("%d", s[i]);
	}
	puts("");
}

```

---

## 作者：qnqfff (赞：0)

### 思路

首先发现 $5$ 这个数很强啊，你发现大部分 $f(5^i)<f(5^{i+1})$，你考虑把若干个 $5^i$ 拼起来用 $0$ 隔开，那么一次减少的量十分巨大，且增加的量一定不如减少的量，然后写个高精度就做完了。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){char c=getchar();int p=0,flg=1;while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,a[10010];
signed main(){
	a[0]=1;a[1]=5;vector<int>ans;ans.push_back(5);
	int lst=0;
	for(int i=1;i<=150;i++){
		int tag=0;for(int j=1;j<=a[0];j++){
			int v=a[j]*5+tag;
			if(v<10) a[j]=v,tag=0;else a[j]=v%10,tag=v/10;
		}if(tag) a[++a[0]]=tag;
		for(int j=1;j<=10;j++) ans.push_back(0);
		int sum=0;
		for(int j=1;j<=a[0];j++) ans.push_back(a[j]),sum+=a[j];
		assert(lst>sum);
	}reverse(ans.begin(),ans.end());for(auto i:ans) cout<<i;
	return 0;
}
```

---


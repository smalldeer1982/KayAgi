# [ARC156C] Tree and LCS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc156/tasks/arc156_c

頂点に $ 1 $ から $ N $ の番号がついた木 $ T $ があります。 $ T $ の $ i\ (1\leq\ i\ \leq\ N-1) $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結んでいます。

$ T $ を用いて、$ (1,2,\ldots,N) $ の順列 $ P\ =\ (P_1,P_2,\ldots,P_N) $ の**類似度**を以下で定めます。

- $ T $ 上の任意の単純パス $ x=(x_1,x_2,\ldots,x_k) $ に対して、$ y=(P_{x_1},\ P_{x_2},\ldots,P_{x_k}) $ とする。このとき、$ x $ と $ y $ の最長共通部分列の長さとして考えられる最大値を類似度とする。
 
類似度が最小となるような順列 $ P $ を一つ構築してください。

  部分列とは 数列の**部分列**とは、数列から $ 0 $ 個以上の要素を取り除いた後、残りの要素を元の順序で連結して得られる数列のことをいいます。 例えば、$ (10,30) $ は $ (10,20,30) $ の部分列ですが、$ (20,10) $ は $ (10,20,30) $ の部分列ではありません。   単純パスとは グラフ $ G $ 上の頂点 $ X,Y $ に対して、頂点列 $ v_1,v_2,\ \ldots,\ v_k $ であって、 $ v_1=X $, $ v_k=Y $ かつ、$ 1\leq\ i\leq\ k-1 $ に対して $ v_i $ と $ v_{i+1} $ が辺で結ばれているようなものを頂点 $ X $ から頂点 $ Y $ への **ウォーク** と呼びます。 さらに、$ v_1,v_2,\ \ldots,\ v_k $ がすべて異なるようなものを頂点 $ X $ から頂点 $ Y $ への **単純パス** (あるいは単に **パス**) と呼びます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ 1\leq\ u_i,v_i\leq\ N $
- 与えられるグラフは木
- 入力される数値は全て整数
 
### Sample Explanation 1

出力例の順列の類似度は $ 1 $ となっています。これは、以下のように計算できます。 - $ x=(1) $ のとき $ y=(P_1)=(3) $ です。$ x,y $ の最長共通部分列の長さは $ 0 $ です。 - $ x=(2) $ のとき $ y=(P_2)=(2) $ です。$ x,y $ の最長共通部分列の長さは $ 1 $ です。 - $ x=(3) $ のとき $ y=(P_3)=(1) $ です。$ x,y $ の最長共通部分列の長さは $ 0 $ です。 - $ x=(1,2) $ のとき $ y=(P_1,P_2)=(3,2) $ です。$ x,y $ の最長共通部分列の長さは $ 1 $ です。 これを反転した $ x=(2,1) $ についても同様です。 - $ x=(2,3) $ のとき $ y=(P_2,P_3)=(2,1) $ です。$ x,y $ の最長共通部分列の長さは $ 1 $ です。 これを反転した $ x=(3,2) $ についても同様です。 - $ x\ =\ (1,2,3) $ のとき $ y=(P_1,P_2,P_3)=(3,2,\ 1) $ です。$ x,y $ の最長共通部分列の長さは $ 1 $ です。これを反転した $ x=(3,2,1) $ についても同様です。 類似度が $ 0 $ 以下の順列は存在しないことが証明できるので、これが答えとなります。

### Sample Explanation 2

類似度が最小の順列が複数存在する場合、どれを出力してもよいです。例えば、`4 3 2 1` といった出力も正解になります。

## 样例 #1

### 输入

```
3
1 2
2 3```

### 输出

```
3 2 1```

## 样例 #2

### 输入

```
4
2 1
2 3
2 4```

### 输出

```
3 4 1 2```

# 题解

## 作者：zhaoyp (赞：7)

首先观察样例大胆猜想答案可能很小，或者就是 $1$。~~（不然他答案太大 spj 咋写）~~

考虑构造证明。

构造方法：对于手上的树，每次取出两个叶子节点交换他们的节点编号作为每个点的权值，然后删掉这两个节点。不断重复此过程。

对于两个叶子节点 $(u,v)$，权值分别为 $v,u$。由于两边是等价的取 $u$ 作研究对象。

$u$ 要是想出现在 $\text{LCS}$ 中，必然包含了 $(u,v)$ 路径上的所有节点，其他节点值没有确定先不做考虑。

$u$ 子树的所有点在路径序列出现的位置在 $u$ 之前，在权值序列出现的位置在 $u$ 之后，不可能与 $u$ 一起作为 $\text{LCS}$ 的一部分。

然后就没了。

---

## 作者：jucason_xu (赞：4)

数据范围 $5\cdot 10^3$，但是介绍一个 $O(n\log n)$ 做法。

我们考虑观察样例，发现样例都很小，而且 LCS 的长度都是 $1$，那么我们就猜答案最多为 $1$，并尝试去构造。

我们画一个链，发现链上的通解就是倒过来。那么我们考虑普通的树，我们发现，普通的树比链的性质更强一些。

我们可以找到树的重心，将其分割成若干个子树。然后安排每个子树中的值到别的地方去。这样可以保证每个子树中的数都在别的子树中。

然后，我们需要按照拓扑序倒着往里填。例如，子树 A 中 $x$ 在最上面，填进子树 B 的时候 $x$ 也要在最上面。如此，在任何的 $x$ 链上，$x$ 和 $x$ 子树中的值都是逆序出现的，最多造成 $1$ 的贡献。

如果树有两个重心，从重心边分成两棵树直接填充。

如果树只有一个重心，将所有分割出的子树从重心开始的 dfs 序跑出来存在 `vector` 里面，每次找到最大的两个 `vector` 进行配对。我们发现，如果我们可以把 $x$ 放在 $y$，也可以把 $y$ 放在 $x$。这样，因为是重心，剩下的节点最多只有 $1$ 个，如果剩下了，就和重心配对，否则重心和自己配对。

为什么重心当根就一定能匹配到只剩 $0$ 或 $1$ 个结点？

因为是重心当根，就没有一个分出来的子树多于 $\dfrac{n}{2}$ 个节点。应用数学归纳法，$n=2$ 和 $n=3$ 时，结论显然成立。然后当前点数 $n>3$，最大子树小于 $\dfrac{n}{2}$ 的情况中，在最大的子树中找一个点，再随便找一个别的点，此时 $n'=n-2$，且最大子树的点数依然不超过 $\dfrac{n'}{2}$，得证。

每次找到最大的 `vector` 需要使用 `priority_queue` 维护 `vector` 大小和下标，每次弹出后更新大小加入。总复杂度 $O(n\log n)$。

```cpp

int n,sz[5005],a,b,pa[5005];
vt<int>vv[5005];
inline void dfs(int x,int p){
	sz[x]=1,pa[x]=p;
	for(auto j:vv[x])if(j!=p){
		dfs(j,x);sz[x]+=sz[j];
	}
}
inline int cen(int x,int p){
	for(auto j:vv[x])if(j!=p){
		if(sz[j]*2>=n)return cen(j,x);
	}
	return x;
}
inline void dfss(int x,int p,vt<int>&v){
	v.pb(x);
	for(auto j:vv[x])if(j!=p){
		dfss(j,x,v);
	}
}
int ans[5005];
inline void solve1(int r){
	vt<vt<int> >vs;
	ans[r]=r;
	for(auto j:vv[r]){
		vt<int>v;
		dfss(j,r,v);
		vs.pb(v);
	}
	priority_queue<pii>pq;
	rd(i,vs.size())pq.push({vs[i].size(),i});
	while(pq.size()){
		if(pq.size()==1){
			int x=pq.top().second;pq.pop();
			ans[vs[x].back()]=r;
			ans[r]=vs[x].back();
			break;
		}
		int x=pq.top().second;pq.pop();
		int y=pq.top().second;pq.pop();
		ans[vs[x].back()]=vs[y].back();
		ans[vs[y].back()]=vs[x].back();
		vs[x].pop_back();vs[y].pop_back();
		if(vs[x].size())pq.push({vs[x].size(),x});
		if(vs[y].size())pq.push({vs[y].size(),y});
	}
	rp(i,n)cout<<ans[i]<<" ";
	cout<<endl;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n;
	rp(i,n-1){
		cin>>a>>b;
		vv[a].pb(b);
		vv[b].pb(a);
	}
	dfs(1,0);
	int c1=cen(1,0),c2=c1;
	bool flag=0;
	if(n%2==0&&sz[c1]==n/2)c2=pa[c1],flag=1;
	else if(n%2==0){
		for(auto j:vv[c1])if(j!=pa[c1]&&sz[j]==n/2)c2=j,flag=1;
	}
	if(!flag){
		solve1(c1);
		return 0;
	}
	
	vt<int>v1,v2;
	dfss(c1,c2,v1);
	dfss(c2,c1,v2);
	while(v1.size()){
		ans[v1.back()]=v2.back();
		ans[v2.back()]=v1.back();
		v1.pop_back();v2.pop_back();
	}
	rp(i,n)cout<<ans[i]<<" ";
	cout<<endl;
	return 0;
}
//Crayan_r
```

---

## 作者：liangbowen (赞：2)

[blog](https://www.cnblogs.com/liangbowen/p/18467471)。

---

显然答案为 $0$ 不行。打表发现最优答案总为 $1$。考虑构造取到 $1$ 的下界。

观察到，$\text{LCS}\le1$ 等价于去掉两序列都不存在的数后，两序列**完全相反**。于是有：

+ 在 $\{x\},\{y\}$ 后增加两序列都不存在的数，不影响 LCS。
+ 进行 $\{x\}\to\{a,x,b\},\{y\}\to\{b,x,a\}$ 后，不影响 LCS。

于是每次选两个叶子 $u,v$ 并将权值赋为 $v,u$，再删掉两个点继续做即可。容易归纳证明。

[code](https://atcoder.jp/contests/arc156/submissions/58825448)，时间复杂度 $O(n)$，瓶颈在 checker。

---

## 作者：hegm (赞：2)

### [Tree and LCS](https://www.luogu.com.cn/problem/AT_arc156_c)

题目大意：

我们定义一个排列 $A$ 和$B$ 的相似性为 $S_i=B_{A_i}$， $S$ 和 $A$ 的最长公共子序列。

我们需要找到一个排列 $P$ 使得和给定树 $T$ 的所有简单路径的相似性的最大值最小。

先证明下这个相似性的最小值。

假如对于排列 $P$，我们肯定可以通过选择路径 $A:x\to P_x$，这样的话 $P$ 和 $A$ 的 LIS 即为 $1$ 了，此为答案的下界。 

现在我们不妨想一想如何构造或者证明存在一种方式使得我们可以保证答案就是下界。

考虑如下的一种神奇的构造方式：

我们将原树的所有叶子拎出来，放入一个队列。

1. 从队列中取出两个点，$u,v$，将 $P_u=v,P_v=u$。

2. 将两个点从树中删掉，然后将新生成的叶子放入队列中。

3. 重复操作直到只剩下一个叶子或者什么都不剩（剩下的一个叶子 $i$，$P_i=i$）

下面来证明为什么这样可以保证答案为 $1$。

首先，对于原图中的所有边，我们只选取极大路径，容易证明这时最大值肯定在这里面。

那么对于一个极大路径 $u\to v$，我们从中找出 $x,y$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wafp3lk4.png)

我们假设 $A,P$ 的 LIS 中包含 $x\to p_y$，换句话说，在上述步骤中， $x,y$ 被匹配并且同时删掉了。

![](https://cdn.luogu.com.cn/upload/image_hosting/c4c1tumq.png)

图中边表示匹配。

那么对于 $A$ 中，位置在 $x$ 前的某一个点 $k$，他的匹配对象有两种可能：

1. 在 $u\to v$ 的路径中。

2. 不在 $u\to v$ 的路径中。

第二种情况不影响我们的 LIS 我们直接忽略。

考虑第一种情况中，和 $k$ 匹配的 $s$ 的位置。

我们判断 $k\to s$ 是否有可能对 LIS 产生贡献，只需要看 $s$ 在 $A$ 中和 $y$ 的相对位置即可。

我们可以证明 $s$ 如果存在在 $A$ 中，那么一定在 $y$ 的后方。

首先，原树是一棵无根树，我们不妨找一个根来帮助我们判断，我们让根是最后删除点/点对。（容易证明，如果最后存在两个点，那么他们一定是相连的）

在这棵树上有一个性质，对于某个节点 $p$，先要删除他就一定要把他的孩子都删除完。

借助这个性质，我们可以知道 $x,y$ 一定不是祖先关系，因为你要想删掉其中深度较小的点，肯定要先删掉深度更大的点。

我们设 $x,y$ 的 $\text{lca}$ 为 $c$。

那么树肯定是长这样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/hfyuy62s.png)

而 $k$ 一定在 $x$ 的子树中，肯定先于 $x$ 被删除，既然如此，那么和他抵消的 $s$ 一定会在 $y$ 的子树中。如果不是，有两种可能：

1. $s$ 在 $c\to u$ 的路径中，那么 $s,k$ 存在祖先关系，假设不成立。

2. $s$ 在 $y\to x$ 中，那么想要删除 $s$，至少得先删除 $x,y$ 中的某一个，但是根据上方所说， $k$ 比 $x$ 先删除，互相矛盾，假设不成立。

那么，我们就完美的证明了它的正确性。

---

## 作者：lsj2009 (赞：2)

## Solution

首先第一点，一个排列的价值肯定是大于 $0$ 的。因为我们可以选择一个路径为 $(u,P_u)$，这个样子的话 $x_k=P_u$，$y_1=P_u$，两者相等，价值至少为 $1$。

那么也就是说，如果我们能设计一个构造方案使得构造出来的排列价值为 $1$，那么也就解决了这题。下面我们先给出大致流程，然后给出证明：

1. 计算每个节点的度数并建一个新队列 $q$，设 $\{ans_n\}$ 为最终答案。
2. 把所有的度数为 $1$ 的节点塞进 $q$ 中。
3. 取出 $q$ 中的两个节点 $u,v$ 并删除，令 $ans_u\gets v,ans_v\gets u$。
4. 在树中删除节点 $u,v$，而后执行 $2$。
5. 当队列中的节点个数不小于 $2$ 时重复执行 $3,4$。
6. 如果 $n$ 为奇数，则应当还有一个 $ans_i$ 没有被赋值，则令 $ans_i\gets i$。
7. 最终得到的 $\{ans\}$ 即为所求。

证明：

- 考虑使用数学归纳法。
- 当 $n=1,2$ 时刻手动验证，显然符合要求。
- 当 $n\ge 3$ 时，设我们当前取出节点 $u,v$，删除 $u,v$ 后得到了一个 $n-2$ 规模的问题，可得满足条件；然后我们将 $ans_u\gets v,ans_v\gets u$，增加价值的唯一方法是通过新加进来的节点 $u,v$，即取路径 $(u,v)$ 的情况显然是最优的，至少不会比取其它路径差；而 $x_1=u$，而 $y_k=ans_{v}=u$，所以想要产生贡献必须要将第一个点和最后一个点配对，而这样我们无法继续配对，因为最后一个节点已经顶住了，所以最大价值仍为 $1$；将 $x_k=v,y_1=ans_{u}=v$ 同理。
- 则通过数学归纳法可得，该算法对于所有的正整数 $n$ 均成立；又因为每个节点最多删一次，且度数之和为 $2n-2$，所以算法复杂度 $\Theta(n)$。

然后就做完了。

## Code

正解：<https://atcoder.jp/contests/arc156/submissions/39088712>。

---

## 作者：strcmp (赞：1)

感觉有点诈骗，但也很有趣的思维题。尤其是这个 $n \le 5000$ 的数据范围，很容易给人带偏。

首先发掘性质。

排列上的 LCS 可以转化为 LIS，那就直接考虑 LIS。

发现一点，就是我们只会关心叶子到叶子的路径，因为这些路径一定存在价值最大的。

那我们直接考虑叶子，毕竟树可以一步步加叶子构建出来。假设初始 $p_i = i$，考虑加叶子的过程。

发现加一个叶子好像并不好调整。

然后你发现一次性加两个叶子，一下就好调整多了。比如加了两个叶子 $p_x = x,\,p_y = y$，那么直接交换 $p_x$ 和 $p_y$。

此时 $x$ 和 $y$ 中必定有一个不会出现在 LCS 里面。

然后再思考一下，发现它们对原先的 LCS 不会产生任何影响！

因为原先的任意一条路径，头尾接上它们都不会产生额外贡献。

于是 $n$ 的答案就是树的大小恰好为 $1$ 时候的答案，也就是 $1$。

发现这样讨论已经给出了构造方法，时间复杂度 $\Theta(n)$。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
#define mid (l + r >> 1)
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
constexpr int maxn = 1e5 + 10, mod = 998244353;
vector<int> g[maxn]; int q[maxn], hd = 1, tl = 0, p[maxn], n, rd[maxn];
int main() {
	scanf("%d", &n); rep(i, 1, n) p[i] = i;
	for (int i = 1, u, v; i < n; i++) scanf("%d%d", &u, &v), g[u].pb(v), g[v].pb(u), ++rd[u], ++rd[v];
	rep(i, 1, n) if (rd[i] == 1) q[++tl] = i; int v = 0;
	while (hd <= tl) {
		int u = q[hd++]; 
		if (v) swap(p[u], p[v]), v = 0;
		else v = u;
		for (int x : g[u]) if (--rd[x] == 1) q[++tl] = x;
	}
	rep(i, 1, n) printf("%d ", p[i]);
	return 0;
}
```

---


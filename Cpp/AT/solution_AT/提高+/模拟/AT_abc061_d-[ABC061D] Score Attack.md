# [ABC061D] Score Attack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc061/tasks/abc061_d

$ N $ 頂点 $ M $ 辺の重み付き有向グラフがあります。   
 $ i(1≦i≦M) $ 番目の辺は 頂点 $ a_i $ から 頂点 $ b_i $ を重み $ c_i $ で結びます。   
 このグラフと駒を利用して、次の1人ゲームを行います。

最初、駒を頂点 $ 1 $ に置いて、プレイヤーのスコアを $ 0 $ とします。   
 プレイヤーは、次の条件で駒を繰り返し移動させることができます。

- 頂点 $ a_i $ に駒があるとき、$ i $ 番目の辺を利用して頂点 $ b_i $ に移動する。移動後にプレイヤーのスコアが $ c_i $ 加算される。

頂点 $ N $ に駒があるときのみ、ゲームを終了できます。   
 なお、与えられる有向グラフの上で頂点 $ 1 $ から頂点 $ N $ に移動できることは保障されています。

プレイヤーがゲーム終了時のスコアを出来るだけ大きくするような行動を取ったとき、ゲーム終了時のスコアはいくつになるでしょうか?   
 ゲーム終了時のスコアをいくらでも大きくできる場合は `inf` と出力してください。

## 说明/提示

### 制約

- $ 2≦N≦1000 $
- $ 1≦M≦min(N(N-1),2000) $
- $ 1≦a_i,b_i≦N\ (1≦i≦M) $
- $ a_i≠b_i\ (1≦i≦M) $
- $ a_i≠a_j $ または $ b_i≠b_j\ (1≦i\ <\ j≦M) $
- $ -10^9≦c_i≦10^9\ (1≦i≦M) $
- $ c_i $ は整数である。
- 与えられるグラフには、頂点 $ 1 $ から頂点 $ N $ への経路が存在する。

### Sample Explanation 1

駒を頂点 $ N=3 $ に移動できる経路は以下の $ 2 $ 通りです。 - 頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 3 $ : スコア $ 4+3=7 $ - 頂点 $ 1 $ → 頂点 $ 3 $ : スコア $ 5 $ したがって、ゲーム終了時のスコアの最大値は $ 7 $ となります。

### Sample Explanation 2

頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 2 $ … と移動することで、ゲーム終了時のスコアをいくらでも増やせます。

## 样例 #1

### 输入

```
3 3
1 2 4
2 3 3
1 3 5```

### 输出

```
7```

## 样例 #2

### 输入

```
2 2
1 2 1
2 1 1```

### 输出

```
inf```

## 样例 #3

### 输入

```
6 5
1 2 -1000000000
2 3 -1000000000
3 4 -1000000000
4 5 -1000000000
5 6 -1000000000```

### 输出

```
-5000000000```

# 题解

## 作者：zerc (赞：4)

题意很显然，让你求最长路或“找正环”。

然后边权转负就成了最短路+找负环，用死掉了 SPFA 跑一遍就好了，

然后你会发现 WA 了，我们的思路好像并没有问题，再读一遍题：

> If it is possible to increase the score indefinitely, print `inf`.
>
> 如果分数可以无限增加，输出 `inf` 。

分数无限增加一定是有正环，但有正环分数就一定会无限增加么？

如果有一个正环，但从 $1$ 到 $n$ 的路径上并不会经过，那么他对答案是没有影响的，

所以开始时说的“找正环”是不对的，应该是 **找最长路径上是否经过正环**，

这样我们只需要判断 $n$ 是否在正环上就可以了。


```cpp
bool spfa() {
    for (int i = 2; i <= n; i++) dis[i] = inf;
    dis[1] = 0, vis[1] = 1, q.push(1);
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (inq[v]) continue;
            if (dis[v] > dis[u] + e[i].val) {
                dis[v] = dis[u] + e[i].val;
                if (!vis[v]) {
                    vis[v] = 1, q.push(v);
                    if (++tot[v] >= n) {
                        inq[v] = 1;  // 标记负环
                    }
                }
            }
        }
    }
    return inq[n];
}
```

[完整代码](https://atcoder.jp/contests/abc061/submissions/35803240)



---


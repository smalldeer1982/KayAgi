# [ARC009C] 高橋君、24歳

## 题目描述

高桥君，24岁，是个学生(esu梗)，过生日辣OwO!  
他要给他的$N$个朋友们发请帖，但是手贱发错了$K$个人的请帖QAQ.  
他现在十分橘促，问他的朋友们拿到的请帖组合一共有多少种可能。

## 说明/提示

$2≦N≦777,777,777,777,777,777$
$2≦K≦777,777$

# 题解

## 作者：Kyru_Yann (赞：6)

## Solution

---

假设正确的请帖为升序的排列 $1 \dots N$。

那么考虑在序列中选择 $N-K$ 个位置放正确的请帖，共有 $\binom{N}{N-K}$ 种放法，即 $\frac{N!}{K!(N-K!)}$。可以线性算出 $\frac{N!}{(N-K)!}$ ，复杂度为 $\Theta(K)$。

接下来可以把剩下的 $K$ 个位置拿出来视为一个独立的排列，考虑计算它的完全错排数量。根据容斥原理，**完全错排数 = 全排列 - 有 *1* 个位置放对的排列 + 有 *2* 个位置放对的排列 ...** 依此类推。有 $x$ 个位置放对的放置方案有 $\binom{K}{x}$ 种，其他的位置可以任意放，是一个长度为 $K-x$ 的全排列，故可以化出长度为 $K$ 的完全错排数为 

$\sum_{x=0}^{K}(K-x)! \times \binom{K}{x} \times (-1)^x $

$\Rightarrow \sum_{x=0}^{K} (K-x)! \times \frac{K!}{x!(K-x)!} \times(-1)^x$

$\Rightarrow \sum_{x=0}^{K} (-1)^x \prod_{i=x+1}^{K} i$。

可以从 $K$ 到 $1$ 倒序算一遍阶乘在 $\Theta(K)$ 之内得到。

最后，将 $\frac{N!}{(N-K)!}$ 与错排数相乘，再乘上 $K!$ 在 *mod 1777777777* 意义下的逆元（费马小定理，快速幂）即为答案。总复杂度为 $\Theta(K) + \log_2P$。

---

## Code

---


```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>

#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
#define swap(x,y) {int t=x; x=y,y=t;}
#define wipe(x,y) memset(x,y,sizeof(x))
#define dbgIn(x) freopen(x".in","r+",stdin)
#define rep(x,y,z) for(int x=y,I=z;x<=I;++x)
#define dbgOut(x) freopen(x".out","w+",stdout)
#define file(x) freopen(x".in","r+",stdin); freopen(x".out","w+",stdout)

#define mod 1777777777

typedef long long ll;

inline void Read(int &x){
	x=0; char ch=0; while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar(); return;
}

ll N;
ll K;
ll ans;

ll fact[1000005];

ll qkpow(ll tp,int up){
	if(up==1) return tp;
	ll ret=qkpow(tp,up>>1);
	if(up&1) return ret*ret%mod*tp%mod;
	return ret*ret%mod;
}

int main(){
	scanf("%lld%lld",&N,&K);
	fact[K+1]=1;
	for(ll i=K;i>=1;i--)
		fact[i]=fact[i+1]*i%mod;
	rep(i,1,K+1)
		ans=(ans+fact[i]*(i&1?1:-1))%mod;
	ans=(ans%mod+mod)%mod;
	for(ll s=N-K+1;s<=N;s++)
		ans=ans*(s%mod)%mod;
	ans=ans*qkpow(fact[1],1777777775)%mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：liuliucy (赞：4)

~~原来Atcoder最后要加回车害我调试了半天。~~
## 算法
首先我们先将 $n$ 分为两部分，一部分是 $n-k$ 表示没发错的数量，很明显这就是一个组合数 $C_n^{n-k}$。

再考虑发错的数量，这是一个错排数，我们考虑容斥，总共数量 $-$ 一个正确 $+$ 两个正确 $-$ 三个正确……，即：错排数 $!n=\sum_{i=0}^n\frac{(-1)^i}{i!}$。

提一句没用的，想要手算 $n$ 的错排数可以用下面的公式：
$$!n=\operatorname{round}(\frac{n!}{e})$$
$e$ 是自然常数。

## CODE
非常重要的，我们需要对所有的除数求逆元。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k;
long long p=1777777777;
long long ans,t[10000001],ans1=1;
int f;
#define int long long
signed main(){
	scanf("%lld%lld",&n,&k);
	m=n-k;
	t[1]=1;
	t[0]=1;
	for(int i=2;i<=k;i++)t[i]=(p-p/i)%p*t[p%i]%p;//线性求逆元
	for(int i=2;i<=k;i++)t[i]=t[i-1]*t[i]%p;
	ans1=t[k];
	f=1;
	for(int i=2;i<=k;i++){
		ans=(ans+(f*t[i]%p+p)%p)%p;
		f*=-1;
	}
	ans=(ans%p+p)%p;
	for(int i=1;i<=k;i++)ans=(ans*(i%p))%p;//错排数
	for(int i=n-k+1;i<=n;i++)ans1=(ans1*(i%p))%p;//组合数
	printf("%lld\n",ans1*ans%p);
}
```


---

## 作者：star_field (赞：1)

## 思路
组合数学中的错排问题，就是求一个数列中所有元素都不在原来位置上的方案数。

错排问题的递推式为：

>$D(n)=(n-1)(D(n-1)+D(n-2)),D(1)=0,D(2)=1$

因为 $n$ 个人中有 $k$ 个人发错了，所以最终结果就是 $\begin{pmatrix}n\\k\end{pmatrix}\cdot D(k)$。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int inf=1e18,mod=1777777777,N=2e7+10;
int t[N],n,k;
void solve(int n,int k){
	vector<int> f(k+5);
	f[1]=0;
	f[2]=1;
	for(int i=3;i<=k;i++) f[i]=(i-1)*(f[i-1]+f[i-2])%mod;
	int ans=1;
	for(int i=n-k+1;i<=n;i++) ans=ans*(i%mod)%mod;
	t[0]=t[1]=1;
	for(int i=2;i<=k;i++) t[i]=(mod-mod/i)%mod*t[mod%i]%mod;
	for(int i=1;i<=k;i++) ans=ans*t[i]%mod;
	cout<<ans*f[k]%mod<<endl;
}
signed main(){ 
	cin>>n>>k;
	solve(n,k);
	return 0;
}
```

---

## 作者：RAND_MAX (赞：0)

## 题意简述
一个长度为 $n$ 的排列 $a$，有 $k$ 个位置 $a_i\ne i$，其余 $n-k$ 个位置 $a_i=i$。求排列 $a$ 的方案数。
## 思路
这种题一眼组合数学，先从 $n$ 个位置里选出 $k$ 个错排的位置，共有 $\dbinom{n}{k}$ 种方案。我们发现 $n$ 很大，无法直接处理。由于 $k$ 不大，所以可以将 $\dbinom{n}{k}$ 拆成 $\frac{n!}{(n-k)!k!}=\frac{1}{k!}\times \prod\limits_{i=n-k+1}^ni$。可以在 $O(k)$ 复杂度内求解，注意若是 $n=k$，后一项的值为 $1$。

再思考这 $k$ 个位置有多少种排列方式。考虑容斥，我们设 $f_i$ 为**至少**有 $i$ 个位置的 $a_i\ne i$ 的方案数。先在 $k$ 个位置里选 $i$ 个，有$\dbinom{k}{i}$ 种方案。剩下的位置可以随便放，有 $(k-i)!$ 种，所以 $f_i=\dbinom{k}{i}\times (k-i)!$。

由于这样算会重复，我们只需容斥即可。$k$ 个位置的排列方式即有 $\sum\limits^k_{i=1}(-1)^i\times f_i$。

如果直接计算 $f_i$ 时间复杂度显然会爆，考虑优化。因为 $\dbinom{k}{i}=\frac{k!}{i!\times(k-i)!}$，这可以与后面的 $(k-i)!$ 约分，所以 $f_i=\frac{k!}{i!}=\prod\limits^k_{j=i+1}j$，这可以一边逆序累计答案一边处理，注意边界 $f_k=1$。

最终答案只需将两部分相乘即可，复杂度 $O(k)$。
## 代码

```cpp
#include<bits/stdc++.h>
#define mod 1777777777
#define int long long
#define R read()
using namespace std;
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0')
	{
		if(c=='-')
		{
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+c-48;
		c=getchar();
	}
	return x*f;
}
void write(int x)
{
	static int st[35],top=0;
	if(x<0)
	{
		x=-x;
		putchar('-');
	}
	do
	{
		st[top++]=x%10;
		x/=10;
	}while(x);
	while(top)
	{
		putchar(st[--top]+48);
	}
	putchar('\n');
}
int n,k,ans=1,jc=1,sum;
int qpow(int x,int y)
{
	int num=1;
	while(y)
	{
		if(y&1) 
		{
			num=num*x%mod;
		}
		x=x*x%mod;
        y>>=1;
    }
    return num%mod;
}
signed main()
{
	n=R,k=R;
	for(int i=n-k+1;i<=n;i++)
	{
		ans=ans*(i%mod)%mod;
		ans%=mod;
	}
	for(int i=k+1;i>=1;i--)
	{
		(i==k+1)?0:jc*=(i%mod),jc%=mod;
		(i&1ll)?sum=sum+jc%mod:sum=sum-jc%mod+mod;
		sum=sum%mod+mod;
		sum%=mod;
	}
	ans=ans*sum%mod;
	ans=ans%mod+mod;
	ans%=mod;
	ans*=qpow(jc,mod-2)%mod;
	ans=ans%mod+mod;
	ans%=mod;
	write(ans%mod);
 	return 0;
}

```

---

## 作者：G__G (赞：0)

数学题：排列组合中的[错排问题](https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290?fr=ge_ala)。

先简单铺垫一下：

例：如若一个排列使得所有的元素不在原来的位置上，则成为这种排列为错排，求长度为 $5$ 的错排个数。

答：44个。

要记住[错排公式](https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F/10978508?fr=ge_ala#1)，这是一会解题的重点：

1. 递推公式：

$$D(n)=(n-1)(D(n-1)+D(n-2)).$$

2. 通项公式：

$$D(n)=n!\sum_{k = 2}^{n} \frac{(-1)^k}{k!}.$$

现在再来看看题目，题目描述里那些恶臭的东西可以简化成一个比较整洁的问题。

有一个长度为 $N$ 的序列里，有 $K$ 个元素是完全错排的，其他元素都在对应的位置上，求这样的序列有多少个。

我们可以把它分成两步来进行解决。

1. $K$ 个完全错排的元素是哪 $K$ 个，也就是从 $N$ 个元素里选出 $K$ 个元素。

2. 那 $K$ 个数有几种排列方式，一个错排问题，直接上公式解决即可。

最后把两步的结果乘起来，这道题就结束了。

代码写起来并不算难，这里就不放了。

---

## 作者：Siteyava_145 (赞：0)

~~哼哼哼啊啊啊啊啊啊啊~~

排列组合题。

对于这种错排问题，可以先确定匹配正确的 $N-K$ 个人的排列方法（下文记作 $ans$，再对剩下的 $K$ 个人求完全错排数 $ans1$）。

先推 $ans$。

这里只要将正确的请帖（$N-K$ 个）分配到 $N$ 个人上就可以了。

排列方法：$C^{N-K}_{N}$。

再求 $ans1$。

这里说一下错排公式的推导过程：（我用的容斥原理）

- 假设我们要求 $1$ 到 $n$ 的错排。

全排列数：$A^n_n=n!$

当存在一个 $i$ 被安在第 $i$ 个位置上，这就不是一种完全错排了。我们要减去所有这种情况。但是这是就把存在两个 $i$ 的排列多减了一次，所以这次再加上这种情况的总排列数。但这时就把存在 $3$ 个 $i$ 的排列多减了一次，所以要减去……再加上 $4$ 个正确的排列数，减去 $5$ 个正确的排列数……加减交替，指导正确排列数为 $n$。

推导出公式

$\begin{aligned}D(n) & =n!-\dfrac{n!}{A^1_1}+\dfrac{n!}{A^2_2}-\dfrac{n!}{A^3_3}+......\pm\dfrac{n!}{A^n_n}\\ & = n!-\dfrac{n!}{1!}+\dfrac{n!}{2!}-\dfrac{n!}{3!}+......\pm\dfrac{n!}{n!} \\ & = \dfrac{n!}{2!}-\dfrac{n!}{3!}+......\pm\dfrac{n!}{n!}\\ & = n!\left(\dfrac{1}{2!}-\dfrac{1}{3!}+......\pm\dfrac{1}{n!}\right)\\ & =n!\left(\sum\limits^m_{k=2}\dfrac{(-1)^{k}}{k!}\right)\end{aligned}$

所以 $ans1=D(m)$。（$k!$ 可以预处理出来）

再将 $ans$ 乘上 $ans1$ 就是本题答案。

### 坑点：

1. 大数相乘后一定要取模！！！

2. 最终结果要先加上 $1777777777$，再取模得到结果（防止负数的出现）。

```
#include<bits/stdc++.h>
#include<unistd.h>
#define ll long long
using namespace std;
ll fac[2000005],p=1777777777;
ll fp(ll a,ll b,ll c){
	ll ans=1;
	while(b){
		if(b&1){
			ans=ans*a%c;
		}
		a=a*a%c;
		b>>=1; 
	}
	return ans;
}
int main(){
	ll n,m;
	cin>>n>>m;
	fac[0]=1;
	for(ll i=1;i<=2000000ll;i++)fac[i]=(fac[i-1]*i)%p;
	ll ans1=0;
	for(ll i=0;i<=m;i++){
	    if(i%2==0){
	    	ans1=(ans1+fac[m]*fp(fac[i],p-2,p)%p)%p;
		}else ans1=(ans1-fac[m]*fp(fac[i],p-2,p)%p)%p;
	}
	ll ans=1;
	for(ll i=n-m+1;i<=n;i++){//ans=C(n-m+1,n)/(m!)，这里求的是分母
		ans=ans*(i%p)%p;
	}
	cout<<(fp(fac[m],p-2,p)%p*ans1%p*ans%p+p)%p<<endl;
   //第一项是m!模p意义下的逆元，第二项是ans1,第三项是C(n-m+1,n)，也就是最终ans的分母。第一项*第三项=ans=C(n-m+1,n)/(m!)%p。
}
```


---

## 作者：bmatrix (赞：0)

~~见标题进系列~~  
~~翻译出来挨打~~

考虑 $N=K$ 的情况，显然就是一个错排数问题：$N$ 个有编号的球和 $N$ 个有编号的盒子，每个盒子能且仅能放一个球，能令每个盒子中的球的编号和盒子的编号都不一样的方案数。这里简单推导一下：

令 $D_i$ 表示 $i$ 个请柬都没有放在应有位置上的方案数。

考虑第 $1$ 个球，它显然不能放在 $1$ 号盒子，也就是说它总共有 $i-1$ 种可能的选择。

假设 $1$ 号球放在了第 $k$ 号盒子里，那么考虑第 $k$ 号球，它现在有两种选择：
- 放在 $1$ 号盒子
- 不放在 $1$ 号盒子

如果放在了 $1$ 号盒子，那么剩下的 $i-2$ 个球都不会受影响，此时方案数等于 $D_{i-2}$。  
如果没有放在 $1$ 号盒子，那么此时的 $1$ 号盒子就相当于第 $k$ 号盒子（第 $k$ 号球不能放在里面），其他球不受影响，相当于只有一个 $1$ 被拿走了，方案数等于 $D_{i-1}$。

由于 $1$ 号球共有 $i-1$ 种选择，因此我们有递推式：
$$\left\{\begin{matrix}
&D_1=0,D_2=1\\
&D_i=(i-1)\times(D_{i-1}+D_{i-2})
\end{matrix}\right.$$

推完这个之后，我们再来看 $N>K$ 的情况。显然的，在 $N$ 个请柬里随意选出 $K$ 个，每种方案数就是 $D_K$。

也就是说，总方案数即为：
$$\binom NK\times D_K$$

组合数取模可以用 [Lucas 定理](https://www.luogu.com.cn/problem/P3807)。

---


# [ARC120D] Bracket Score 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc120/tasks/arc120_d

**括弧の対応が取れている文字列**を、次のうちいずれかの条件を満たす文字列と定義します。

- 空文字列
- ある括弧の対応が取れている空でない文字列 $ s,\ t $ が存在し、$ s,\ t $ をこの順に連結した文字列
- ある括弧の対応が取れている文字列 $ s $ が存在し、 `(`, $ s $, `)` をこの順に連結した文字列

また、括弧の対応が取れている文字列 $ s $ の $ i $ 文字目と $ j $ 文字目が**対応している**とは、以下の条件を全て満たすこととします。

- $ 1\ \le\ i\ <\ j\ \le\ |s| $
- $ s_i\ = $ `(`
- $ s_j\ = $ `)`
- $ s $ の $ i $ 文字目と $ j $ 文字目の間にある文字列 ($ i $ 文字目と $ j $ 文字目は含まない) は括弧の対応が取れている文字列である

長さ $ 2N $ の数列 $ A\ =\ (A_1,\ A_2,\ A_3,\ \dots,\ A_{2N}) $ が与えられます。  
 括弧の対応が取れている長さ $ 2N $ の文字列 $ s $ の**スコア**を、$ s $ の $ i $ 文字目と $ j $ 文字目が対応しているような全ての組 $ (i,\ j) $ について $ |A_i\ -\ A_j| $ を足し合わせたものと定義します。

括弧の対応が取れている長さ $ 2N $ の文字列のうち、スコアが最大となるような文字列を $ 1 $ つ求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
- 入力に含まれる値は全て整数

### Sample Explanation 1

長さ $ 4 $ の括弧の対応が取れている文字列は `(())` と `()()` の $ 2 $ 種類あり、それぞれのスコアは以下の通りです。 - `(())` : $ |1\ -\ 4|\ +\ |2\ -\ 3|\ =\ 4 $ - `()()` : $ |1\ -\ 2|\ +\ |3\ -\ 4|\ =\ 2 $ よって、`(())` のみが正しい答えとなります。

### Sample Explanation 2

`(())` と `()()` のスコアは以下の通りです。 - `(())` : $ |2\ -\ 3|\ +\ |3\ -\ 2|\ =\ 2 $ - `()()` : $ |2\ -\ 3|\ +\ |2\ -\ 3|\ =\ 2 $ よって、この場合どちらを出力しても正解となります。

## 样例 #1

### 输入

```
2
1 2 3 4```

### 输出

```
(())```

## 样例 #2

### 输入

```
2
2 3 2 3```

### 输出

```
()()```

# 题解

## 作者：Demeanor_Roy (赞：2)

- [原题链接](https://www.luogu.com.cn/problem/AT_arc120_d)
。
---

注意到贡献是差的绝对值，经典地考虑拆掉绝对值，即给每个位置分配左右括号以及贡献正负，使得括号序列合法且匹配的一对括号贡献正负相反。该分配方法的答案即为贡献为正的元素和减去贡献为负的元素和。

注意到括号序列不做任何限制，我们不难猜测：最大答案即较大的 $n$ 个数减去较小的 $n$ 个数可以取到。

考虑构造证明：按上述说法给元素分配好贡献正负。从左往右扫，维护两个变量 $s,tp$ 表示当前待匹配的左括号数和它们的贡献正负（我们强制规定当前分配到左括号且待匹配的这些位置贡献正负相同），新加入一个元素时：

- $s=0$，则 $s \gets s+1,tp \gets type_i$。

- $s > 0,tp = type_i$，则 $s \gets s+1$。

- $s > 0,tp \ne type_i$，则 $s \gets s-1$。

给使得 $s$ 增加的位置填左括号，减少的位置填右括号即可。

---

## 作者：wangziyue_AK (赞：2)

## 为什么现有题解都是队列？栈多好写
这题题面是一个经典的括号匹配，括号匹配是一个经典问题，通常与栈有关，因为一个右括号只会和最后一个未匹配的左括号有关，所以维护一个栈可以便于判断匹配情况。这道题定义一组括号的权值为左右括号权值的差(的绝对值)，要求构造权值最大的括号序列。

考虑贪心，每一组括号序列的左括号和右括号最好要分别属于较大的一半和较小的一半，这样权值总和就会达到理论最大值：序列的最大 $n$ 项的和减去序列的最小 $n$ 项的和。按照这种做法，需要排序后按大小把序列分成两半，维护一个栈存贮未被匹配的左括号，若栈顶与当前权值分属不同的集合，则可以匹配，删去栈顶，输出右括号，否则输出左括号，往栈中加入当前元素。

那为什么这是对的呢？首先左右括号个数都是 $n$ 个，其次输出一个右括号当且仅当栈中存在未匹配的左括号，那么一定合法，最后权值和一定会达到理论上界。

上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e5+5;//数组开两倍 
typedef long long ll;
int n,a[N];
struct xx{
	int x,id;
}b[N];
inline bool cmp(xx ax,xx ay){
	return ax.x<ay.x;
}
int stk[N],top;//手写栈 
int main(){
	scanf("%d",&n);
	int m=(n<<1);
	for(int i=1;i<=m;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++) b[i].x=a[i],b[i].id=i;
	sort(b+1,b+m+1,cmp);
	for(int i=1;i<=n;i++) a[b[i].id]=0;//前n个 
	for(int i=1;i<=n;i++) a[b[n+i].id]=1;//后n个 
	for(int i=1;i<=m;i++){
		if(top==0||a[i]==stk[top]){//top==0说明没有未匹配左括号，必须放左括号 
			stk[++top]=a[i];
			printf("(");
		}else{
			top--;
			printf(")");
		}
	}
	return 0;
}
```

---

## 作者：蒟蒻君HJT (赞：2)

首先将 $A_i$ 从小到大排序得到 $B_i$，那么答案的最大值一定不能超过 

$$\sum_{i=n+1}^{2n}B_i-\sum_{i=1}^{n}B_i$$

可以用绝对值不等式证明。

接下来证明这个最大值确实可以取到。

将所有 $i\in[n+1,2n]$ 的 $B_i$ 在 $A$ 中所对应的位置都标为 $1$，其他位置标为 $0$，则现在得到了一个长为 $2n$ 的，$0$ 和 $1$ 数目相等的 $0/1$ 序列 $val$。

要想取到上文所述的最大值，需要构造一个长度为 $2n$ 的合法括号序列，满足其中所有相匹配的括号所对应下标的二元组 $(a,b),a<b$ 都有 $val_a \neq val_b$。

显然，对于一个非空的 $0$ 和 $1$ 数目相等的 $0/1$ 序列，总能找出相邻的两个位置，满足这两个位置上的数值不相等。直接将这两个位置匹配，并在序列中删去这两个位置，将余下部分顺次连接，得到一个新的序列，它有着和原先序列相同的性质，可以递归处理它，直到序列为空。

所以，依照以上实现方法，总能使答案达到理论上界。但朴素的实现是 $\mathcal{O}(n^2)$，需要优化。

可以这样做：维护一个处理队列，队列中的元素是二元组 $(a,b)$，表示 $a$ 和 $b$ 即将匹配。

对于初始的序列，找出所有满足 $val_i \neq val_{i-1}$ 的位置 $i$，并将 $(i-1,i)$ 放入处理队列。

这时会发现部分下标可能在队列中出现多次，所以需要再记录一个数组 $vis_i$ 表示下标 $i$ 是否为空。只有当队首取出的二元组 $(a,b)$ 的 $a$ 和 $b$ 都是空的情况下才处理它。

设 $l_i$ 表示 $i$ 左端（包括 $i$）第一个为空的位置，$r_i$ 表示 $i$ 右端（包括 $i$）第一个为空的位置。

将 $(a,b),a<b$ 进行匹配之后，唯一可能新出现的可以匹配的位置就是 $(l_{a-1},r_{b+1})$。判断 $val_{l_{a-1}}$ 和 $val_{r_{b+1}}$ 是否不等来决定其是否加入处理队列即可。

朴素维护 $l_i$ 与 $r_i$ 的复杂度依然为 $\mathcal{O}(n^2)$。借助并查集的思想，当 $(a,b)$ 匹配后，直接令 $l_a,l_b \leftarrow a-1,r_a,r_b\leftarrow b+1$；当查询 $l_x/r_x$ 时，不断令 $x\leftarrow l_x/r_x$ 直到 $x=l_x/r_x$ 为止，沿途路径压缩。

这样一来就可以单次 $\mathcal{O}(\log n)$ 维护和查询 $l_i$ 和 $r_i$，由于总共的匹配个数为 $n$，所以总复杂度为 $\mathcal{O}(n\log n)$。

---

## 作者：Exp10re (赞：1)

有趣题。

## 解题思路

考虑到答案的上界必定为 $A$ 中较大的 $n$ 个数之和减去 $A$ 中较小的 $n$ 个数之和，拆掉绝对值易证。

考虑通过构造取得该上界。我们将 $A$ 排序后将后 $n$ 个数染成红色，前 $n$ 个数染成蓝色，再还原为原数列，则取到上界的其中一个充分非必要条件即为每一对括号所对应的数颜色不同。

我们用栈来构造得到这样的上界。具体的，枚举 $i\in[1,2n]$，然后：

- 若当前栈为空，在栈顶压入当前的数。
- 否则，若当前栈栈顶与当前数颜色不同，将栈顶对应的位置填入左括号，当前数位置填入右括号，弹出栈顶。
- 否则，有当前栈栈顶与当前数颜色相同，则在栈顶压入当前的数。

显然这样的构造一定能产生一个长度为 $2n$ 的合法括号序列，且每一对括号所对应的数颜色不同。故该构造一定可以取得上界。

---

## 作者：迟暮天复明 (赞：1)

首先楼上已经证明过一定是较小的 $n$ 个数与较大的 $n$ 个数匹配。

然后对原数组从左到右扫一遍，如果遇到的数是较小的 $n$ 个数之中的，那么将其放入第一个队列中。否则放入第二个队列中。

如果两个队列的元素个数均不为零，则将队首进行匹配。

证明：如果我匹配的数字是 $i$ 和 $j$，那么 $i$ 到 $j$ 之间的数一定不可能与 $i$ 之前的数匹配（否则为什么不和 $i$ 匹配），同时 $i$ 到 $j$ 之间的数都一定已经匹配过了（否则 $i$ 和 $j$ 至少有一个不是队首）。由于已知左右括号数均为 $n$ 个，故得证。

时间复杂度还是 $O(n\log n)$，因为要排序。

---

## 作者：Elairin176 (赞：0)

[Link](https://www.luogu.com.cn/problem/AT_arc120_d)   
小水题，不知道为什么 kenkoooo 给了 1996 的 rating。    
## 题意
定义一个长度为 $2n$ 的括号序列 $s$ 的价值为：  
$$\sum\limits_{i=1}^n\left|a_{u_i}-a_{v_i}\right|$$   
其中 $(u_i,v_i)$ 表示 $s$ 中一对匹配括号的位置。   
最大化价值。   
## 解法
我们拆开绝对值后易得：$a$ 的前 $n$ 小一定作为负贡献出现，前 $n$ 大一定作为正贡献出现。   
那么我们就确定了符号，接下来考虑分配括号。   
同样显然地，一对匹配的括号两端一定是异号贡献，依据这个我们直接用 set 维护即可。   
复杂度 $\mathcal{O}(n\log n)$。   
CODE：   
```cpp
//luogu paste jo5j6ogx
cst int N=4e5;
int n;
struct node{
	int x,p;
}a[N+10];
bool ans[N+10],f[N+10];
set<int>s1,s2;
int main(void){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	n=read<int>();
	for(int i=1;i<=(n<<1);i++){
		a[i].x=read<int>();
		a[i].p=i;
	}
	sort(a+1,a+1+(n<<1),[](cst node&x,cst node&y){ret x.x<y.x;});
	for(int i=1;i<=n;i++) f[a[i].p]=1;
	for(int i=1;i<=(n<<1);i++){
		if(f[i]){
			if(s2.empty()) s1.insert(i);
			else{
				auto p=s2.end();p--;
				ans[i]=1;
				s2.erase(p);
			}
		}else{
			if(s1.empty()) s2.insert(i);
			else{
				auto p=s1.end();p--;
				ans[i]=1;
				s1.erase(p);
			}
		}
	}
	for(int i=1;i<=(n<<1);i++){
		if(ans[i]) pc(')');
		else pc('(');
	}
	ret 0;
}
```
[record(atcoder)](https://atcoder.jp/contests/arc120/submissions/61531655)

---

## 作者：Crosser (赞：0)

### Preface

$\text{*1500, Observation, Greedy, \textbf{Brackets}.}$

大家疑似把这个题目想难了，包括我自己。

这警示我们一定不要提前看难度。也可能有点 Adhoc 了。

### Solution

看到绝对值考虑几何意义。我们把它放到数轴上，发现最大的情况就是后面的 $n$ 个点尽力去匹配前面 $n$ 个点。

结论：**最值一定可以取到前 $\bm n$ 大减后 $\bm n$ 大。**

我们只要能够构造出来一组解相当于证明了。

因此我们现在要处理的问题即，你有一个并不匹配的括号序列，其中有 $n$ 个左括号和 $n$ 个右括号。你每次可以把一对括号取反，但是前提是最终他们俩必须配对。

要实现也非常的简单：画出经典 $+1$，$-1$ 的折线图，发现只要把在 $x$ 轴下方的部分翻上来就行了。

### Implementation

注意经过 $x$ 轴的时候是上去还是下来是不一样的，具体看你是先 $\pm1$ 的还是先判断 $\verb!()!$ 的。

[Code](https://atcoder.jp/contests/arc120/submissions/58492170)

---

## 作者：Ghosty_Neutrino (赞：0)

## 分析
这题太难了，所以我们先想一个相关的问题：

在数轴上从左到右存在 $2$，$N$，$2N$，$2N$ 个点（可重合），点之间两两配对并连成线段，问最大的线段总长度。

考虑第一个点到第二个点之间的部分，最多会被线段覆盖一层，因为左边只有一个点；第二个点到第三个点之间的部分，最多会被覆盖两层，因为左边只有两个点。

依此类推，能不能找到一种配对方法，使得每两个点之间的部分都达到能被覆盖的最大层数呢？

我们可以将第一个点跟最后一个点配对，第二个点跟倒数第二配对，这是一种方法，最终答案就是后 $N$，$N$，$N$ 个点的坐标和。这么看来，更一般地，我们可以在第 $N$，$N$，$N$ 个点和第 $N+1$，$N+1$，$N+1$ 个点之间划条分界线，只要每条线段都能经过这条分界线，即左边的只能和右边的配对，那么最终答案不也是后 $N$，$N$，$N$ 个点的坐标和前 $N$，$N$，$N$ 个点的坐标和了吗？

这样题目是不是就简单了？

如果我们把某个序列排个序，如果能保证前一半的点只跟后一半的点配对，那么答案一定最大化了。我们只需要满足这个条件（并且恐怕必须得满足这个条件），就是正确答案了。

那么就可以先把那个序列排个序（最好带上原下标），然后把前一半的变成白点，后一半的变成黑点。

在排序前的序列中，白点黑点个数相同，那么把相邻的黑白点配对，变成左括号和右括号，再把它们在序列中删掉。由于序列中白点黑点个数一直相同，因此总有白点黑点相邻。这样就可以构造出一种合法方案了。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 400005
#define ENDL putchar('\n')
#define LL long long
#define DB double
#define lowbit(x) ((-x) & (x))
#define INF 0x3f3f3f3f
int n,m,i,j,s,o,k;
int a[MAXN];
LL read() {
	LL f = 1,x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s=='-')f = -f;s = getchar();}
	while(s >= '0' && s <= '9') {x=x*10+(s-'0');s = getchar();}
	return f * x;
}
struct it{
	int nm,id;
}b[MAXN];
bool cmp(it a,it b) {return a.nm == b.nm ? (a.id < b.id):(a.nm < b.nm);}
int main() {
	n = read();
	for(int i = 1;i <= 2*n;i ++) {
		a[i] = read();b[i].nm = a[i];b[i].id = i;
	}
	sort(b + 1,b + 1 + 2*n,cmp);
	for(int i = 1;i <= n;i ++) {
		a[b[i].id] *= -1;
	}
	int ct = 0;
	for(int i = 1;i <= 2*n;i ++) {
		if(a[i] < 0) {
			if(ct < 0) putchar(')');
			else putchar('(');
			ct ++;
		}
		else {
			if(ct > 0) putchar(')');
			else putchar('(');
			ct --;
		}
	}
	ENDL;
	return 0;
}

```

---


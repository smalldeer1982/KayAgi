# Negative Doubling

## 题目描述

[problemUrl]: https://atcoder.jp/contests/caddi2018/tasks/caddi2018_c

$ N $ 個の正の整数 $ A_1,\ A_2,\ ...,\ A_N $ があります． 高橋君は，これらの整数に対して，次の操作を好きな回数行うことができます：

- $ 1\ \leq\ i\ \leq\ N $ を選び，$ A_i $ の値を $ -2 $ 倍にする．

**マイナス** $ 2 $ 倍であることに注意してください．

高橋君は，$ A_1\ \leq\ A_2\ \leq\ ...\ \leq\ A_N $ が成り立つようにしたいです． このために必要な操作の回数の最小値を求めてください．ただし，不可能な場合は `-1` を出力してください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 200000 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $

### Sample Explanation 1

例えば，次のようにすればよいです． - $ i=4 $ を選び，$ A_4 $ の値を $ -2 $ 倍にする．$ A_1,\ A_2,\ A_3,\ A_4 $ はそれぞれ $ 3,\ 1,\ 4,\ -2 $ になる． - $ i=1 $ を選び，$ A_1 $ の値を $ -2 $ 倍にする．$ A_1,\ A_2,\ A_3,\ A_4 $ はそれぞれ $ -6,\ 1,\ 4,\ -2 $ になる． - $ i=4 $ を選び，$ A_4 $ の値を $ -2 $ 倍にする．$ A_1,\ A_2,\ A_3,\ A_4 $ はそれぞれ $ -6,\ 1,\ 4,\ 4 $ になる．

### Sample Explanation 2

操作を一切せずとも $ A_1\ \leq\ A_2\ \leq\ ...\ \leq\ A_N $ が成り立っています．

## 样例 #1

### 输入

```
4
3 1 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
0```

## 样例 #3

### 输入

```
8
657312726 129662684 181537270 324043958 468214806 916875077 825989291 319670097```

### 输出

```
7```

# 题解

## 作者：Zyx_z (赞：1)

## Statement

给定一个长度为 $n$ 的正整数序列 $a$。每次操作可以选择一个 $a_i$ 将它乘以 $-2$。求最少需要多少步可以使 $a$ 序列单调不降。

## Solution
暴力做法很容易想到：

每次操作给一个数乘以 $-2$，那么最终满足条件的答案一定形如，前 $k$ 个数是负数，剩下的 $n-k$ 个数是正数。那么我们只需要枚举这个正负数的分界点，就可以将操作转化成对一个数乘 $4$。

基于暴力的思路，进一步发现：

要做的就是用最小步数让分界点开始向前单调不升，向后单调不降。由于两者本质相同，后缀把序列倒过来再做一次，故这里只讨论前缀。

如果当前分界点在 $i$，要将分界点移动至 $i+1$，那么显然会有一段区间 $[j,i]$ 需要乘 $4$ 来保证序列满足要求。在分界点不断往后移动的过程中，我们需要维护的区间形如一个阶梯。可以用栈，具体的我们记录和当前分界点有差距的位置和差几个乘 $4$ 操作，每次将区间统一乘 $4$。时间复杂度 $O(n\log V)$。

---

## 作者：Union_Find (赞：0)

这道题还是比较有趣的。

首先这道和平时的求操作最小数的题最大的区别在于它是乘以负数。这会导致他的最终序列会有负数。既然会有负数，还要单调不降，那负数就肯定是一段前缀，正数是一段后缀。

我们可以枚举分界点 $i$，然后考虑答案。因为前缀要先全体乘 $-2$，所以单调性变成了 $\forall j < i,-a_j > -a_{j+1}$，这样子我们可以把前缀取正，然后求变成单调不升的最小操作数。这样子，后缀和前缀的操作就一样了。

这是最优解问题，似乎可以贪心，但我不会，所以我们使用更好证明，好写的 dp。

设 $f_i$ 表示前 $i$ 个数单调不升的最小操作数。但是这样子我们就不好判断单调不升这个条件了。所以加上一维，$f_{i,j}$ 表示前 $i$ 个数，第 $i$ 个数变成了 $a_i \times 4^j$ 的最小操作数。

为什么是 $4^j$？因为我们在确定正负性之后，每次操作就一定是操作两次了，否则正负性会变化。

然后既有了如下转移。

$$f_{i,j}\gets f_{i-1,t}+t$$

其中的 $t$ 表示 $\log_4(a_i-a_{i-1})$，在计算时为了减小精度误差，可以这样写。

```
il ll lg4(ll x, ll y){return ceil((log(x) - log(y)) / log(4));}
```

但是这样子有个问题，就是操作数会很大，我们无法开下这么大的数组，也支持不了这么大的时间复杂度。所以我们要优化。

注意到 $a_i \leq 10^9$，通过计算，$4^{15}>10^9$。所以我们可以只存 $n \times 15$ 大小的 dp 数组，因为之后的操作是多余的，可以直接计算得到没必要 dp。

所以我们有了新的转移。

$$f_{i,j}\gets \left\{\begin{matrix} t \le 15,f_{i-1,t}+t
 \\t > 15, f_{i-1,15}+t+(i-2)\times (t-15) 
\end{matrix}\right.$$

这样子就是 $O(n)$ 的转移带上 $15$ 的常数了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 800005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}il ll lg4(ll x, ll y){return ceil((log(x) - log(y)) / log(4));}
ll n, a[N], ans = 1e18, f[N][25], g[N][25];
int main(){
	n = rd();
	for (int i = 1; i <= n; i++) a[i] = rd();
	for (int i = 1; i <= n; i++) for (int j = 0; j <= 15; j++){
		ll t = lg4(a[i], a[i - 1]) + j;
		if (t < 0) f[i][j] = f[i - 1][0];
		else if (t <= 15) f[i][j] = f[i - 1][t] + t;
		else f[i][j] = f[i - 1][15] + t + (i - 2) * (t - 15);
	}for (int i = n; i >= 1; i--) for (int j = 0; j <= 15; j++){
		ll t = lg4(a[i], a[i + 1]) + j;
		if (t < 0) g[i][j] = g[i + 1][0];
		else if (t <= 15) g[i][j] = g[i + 1][t] + t;
		else g[i][j] = g[i + 1][15] + t + (n - i - 1) * (t - 15); 
	}for (int i = 0; i <= n; i++) ans = min(ans, i + (f[i][0] + g[i + 1][0]) * 2);
	printf ("%lld\n", ans);
	return 0;
}

```

---

## 作者：cosf (赞：0)

首先，负数肯定比正数小。

因此，我们枚举前 $k$ 项是负的，后面的是正的。那么，我们给前面 $k$ 项除掉 $-2$ 之后，整个序列就是一个先递降再递升的序列。

那么，每次操作必然是操作两次，也就是 $\times 4$。因此，我们可以算出满足前 $k$ 项递降的最小操作数，记为 $d_k$。

如何地推？一个最初的想法是，假设 $a_{k-1} \times 4^i < d_k \le a_{k-1} \times 4^{i+1}$，那么应该有 $d_k = d_{k-1} + (i+1)(k-1)$，但是这是错的。

因为，我们想要把 $a_{k-1}$ 乘上 $4^{i+1}$，并不意味着也要把 $a_{k-2}$ 乘上 $4^{i+1}$（这里的 $a_{k-2}$ 指的是原始的 $a_{k-2}$ 乘上某个 $4$ 的幂使得大于等于 $a_{k-1}$ 的数）。这个事情想要成立，当且仅当这个 $a_{k-2}$ 已经不是原始的 $a_{k-2}$ 了。因此，我们想要找到一个 $a_{k-1} \times 4^i$，它比所有的 $a_j$ 都大。因为 $a_i \lt 10^9 \lt 4^{15}$，因此只要 $i$ 取到 $15$ 即可。以后 $i$ 大多少，$a_1$ 到 $a_{k-1}$ 就都要乘上相应的幂次。

因此我们要改进以下我们的递推项 $d_{k, i}$，表示把 $a_k$ 换成 $a_{k} \times 4^i$ 之后使 $a_1 \ge \dots \ge a_k$ 的最小操作数。因此，当 $i \gt 15$ 时，$d_{k, i} = d_{k, i - 1} + k$。否则需要看 $a_{k-1}$ 的值，来确定 $d_{k, i}$ 从 $d_{k - 1, ?}$ 递推而来。

这样就可以在 $O(n\log^2V)$ 解决问题了。

```cpp
#include <algorithm>
#include <iostream>
#include <limits>
using namespace std;

#define MAXN 200005
#define MAXL 16

using ll = long long;

template <typename T>
T INF = numeric_limits<T>::max() >> 1;

ll d[MAXL][MAXN], p[MAXL][MAXN];

template <typename A>
ll g(A d, int i, int j)
{
    if (i >= MAXL)
    {
        return d[MAXL - 1][j] + (i - MAXL + 1) * j;
    }
    else
    {
        return d[i][j];
    }
}

ll a[MAXN];

int n;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        if (i > 1)
        {
            for (int j = 0; j < MAXL; j++)
            {
                ll c = a[i] << (2 * j), e = a[i - 1], f = 0;
                while (e < c)
                {
                    e <<= 2;
                    f++;
                }
                d[j][i] = j + g(d, f, i - 1);
            }
        }
        else
        {
            for (int j = 0; j < MAXL; j++)
            {
                d[j][i] = j;
            }
        }
    }
    reverse(a + 1, a + n + 1);
    for (int i = 0; i < MAXL; i++)
    {
        p[i][1] = i;
    }
    for (int i = 2; i <= n; i++)
    {
        for (int j = 0; j < MAXL; j++)
        {
            ll c = a[i] << (2 * j), e = a[i - 1], f = 0;
            while (e < c)
            {
                e <<= 2;
                f++;
            }
            p[j][i] = j + g(p, f, i - 1);
        }
    }
    ll res = INF<ll>;
    for (int i = 0; i <= n; i++)
    {
        res = min(res, i + 2 * (d[0][i] + p[0][n - i]));
    }
    cout << res << endl;
    return 0;
}
```

---


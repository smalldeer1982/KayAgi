# たのしいたのしいたのしい家庭菜園 (Growing Vegetables is Fun 3)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2019ho/tasks/joi2019ho_c

JOI 君は，長年にわたる家庭菜園の経験を生かして，自宅の庭で新たにジョイ草という植物を育てている．庭には東西方向に並んだ $ N $ 個のプランターがあり，西側から順に $ 1 $ から $ N $ までの番号がついている．ジョイ草は全部で $ N $ 株あり，それぞれのプランターに $ 1 $ 株ずつ植えてある．

春になって様子を見に行った JOI 君は，ジョイ草が予想に反して色とりどりの葉を付けていることに気がついた．さらに，ジョイ草が思ったほど生育していないことに気がついた．JOI 君はこれらのことを不思議に思い，本で調べたところ，次のことがわかった：

- ジョイ草には $ 3 $ 種類あり，それぞれ赤，緑，黄の葉を付ける．
- 葉の色が同じジョイ草を近くに置くと，その成長が阻害されてしまう．

そこで，JOI 君は，ジョイ草を並び替えて，葉の色が同じジョイ草が隣り合わないようにすることにした．このとき，JOI 君は隣り合う $ 2 $ つのジョイ草を入れ替えることしかできない．つまり，$ 1 $ 回の操作で JOI 君はプランター $ i $ ($ 1\ \leqq\ i\ \leqq\ N\ -\ 1 $) を任意に $ 1 $ つ選び，プランター $ i $ のジョイ草とプランター $ i\ +\ 1 $ のジョイ草を入れ替えることができる．JOI 君は，できるだけ少ない回数の操作で，葉の色が同じジョイ草が隣り合わないようにしたい．

ジョイ草の数と，それぞれのジョイ草の葉の色が与えられたとき，葉の色が同じジョイ草が隣り合わないように並び替えるために必要な操作回数の最小値を求めるプログラムを作成せよ．

- - - - - -

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 400 $．
- $ S $ は長さ $ N $ の文字列である．
- $ S $ の各文字は `R`，`G`，`Y` のいずれかである．

### 小課題

1. ($ 5 $ 点) $ N\ \leqq\ 15 $．
2. ($ 55 $ 点) $ N\ \leqq\ 60 $．
3. ($ 15 $ 点) $ S $ の各文字は `R`，`G` のいずれかである．
4. ($ 25 $ 点) 追加の制約はない．

- - - - - -

### Sample Explanation 1

この入力例では，例えば次のようにすると，葉の色が同じジョイ草が隣り合わないようにすることができる． - まず，プランター $ 3 $ のジョイ草とプランター $ 4 $ のジョイ草を入れ替える． - 次に，プランター $ 2 $ のジョイ草とプランター $ 3 $ のジョイ草を入れ替える． このようにすると，ジョイ草の並びは `RYRGY` のようになる．$ 1 $ 回以下の操作で葉の色が同じジョイ草が隣り合わないようにすることはできないので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

この入力例では，どのように操作をしても，葉の色が同じジョイ草が隣り合わないようにすることはできない． - - - - - -

## 样例 #1

### 输入

```
5
RRGYY```

### 输出

```
2```

## 样例 #2

### 输入

```
6
RRRRRG```

### 输出

```
-1```

## 样例 #3

### 输入

```
20
YYGYYYGGGGRGYYGRGRYG```

### 输出

```
8```

# 题解

## 作者：ivyjiao (赞：2)

校内模拟赛出了两遍了，来写一下。

双倍经验：P6116，AT_joi2019ho_c。

首先考虑什么时候无解：当一种颜色的数量大于 $\lceil \dfrac n 2\rceil$ 时无解（这个要注意不能写成 $\lfloor \dfrac n 2\rfloor$，不然洛谷的 P6116 能过，AT 上的原题会被 hack）。

然后发现性质 $1$：交换同种颜色无意义。

由性质 $1$ 可得性质 $2$：若按原字符串的顺序给每个字符从前到后编号，则相同字符的内部顺序不变。

模拟赛第二次出的时候把 $R,G,B$ 换成了 $0,1,2$，这里直接按 $0,1,2$ 讲。

发现数字只有三种，感觉像是[乌龟棋](https://www.luogu.com.cn/problem/P1541)模型（我自己起的名字），而且数据范围很小，考虑建一个高维 dp。

设 $dp_{i,j,k,l}$ 为枚举到 $i$ 位，有 $j$ 个 $0$，$k$ 个 $1$，$i-j-k$ 个 $2$，当前位更改后为 $l$ 的最小交换次数。

由性质 $2$ 可得：$dp_{i,j,k,0}$ 一定是从第 $j$ 个 $0$ 那里转来的，剩下两个数同理（这里可能需要思考一下）。

依题意，若此时的第 $j$ 个 $0$ 的位置为 $x$，可得转移式子：$dp_{i,j,k,0}=\max(dp_{i-1,j-1,k,1},dp_{i-1,j-1,k,2})+|x-i|$，仔细想想，其实绝对值可以去掉的。

考虑求出 $x$，先找到原串中的第 $j$ 个 $0$ 的位置 $y$（直接预处理就行），在状态 $dp_{i,j,k,0}$ 中，有 $k$ 个 $1$，$l$ 个 $2$，若原串中 $y$ 以前的 $1,2$ 数量足够多那就不用做任何事情，$x=y$，否则需要把 $y$ 之后的 $1,2$ 前移，第 $j$ 个 $0$ 会被往后挤，则 $x=y+\max(0,k-sum_{y,1})+\max(0,i-j-k-sum_{y,2})$，$sum_{i,l}$ 表示前 $i$ 个位置有多少个 $l$，直接预处理。

然后发现这两个式子是可以合并的，直接用后面这个就行。

然后就过了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=401;
int n,dp[2][N][N][3],a[N][3],sum[N][3],l1,l2,l3;
char s[N];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        if(s[i]=='R') a[++l1][0]=i;
        if(s[i]=='G') a[++l2][1]=i;
        if(s[i]=='Y') a[++l3][2]=i;
        sum[i][0]=sum[i-1][0]+(s[i]=='R');
        sum[i][1]=sum[i-1][1]+(s[i]=='G');
        sum[i][2]=sum[i-1][2]+(s[i]=='Y');
    }
    if(max({l1,l2,l3})>(n+1)/2){
        cout<<-1;
        return 0;
    }
    memset(dp,0x3f,sizeof dp);
	dp[1][1][0][0]=a[1][0]-1;
	dp[1][0][1][1]=a[1][1]-1;
	dp[1][0][0][2]=a[1][2]-1;
    for(int i=2;i<=n;i++){
        for(int j=0;j<=l1;j++){
            for(int k=0;k<=l2;k++){
                int l=i-j-k;
                if(l>l3) continue;
                if(j) dp[i%2][j][k][0]=min(dp[(i-1)%2][j-1][k][1],dp[(i-1)%2][j-1][k][2])+a[j][0]+max(0,k-sum[a[j][0]][1])+max(0,l-sum[a[j][0]][2])-i;
                if(k) dp[i%2][j][k][1]=min(dp[(i-1)%2][j][k-1][0],dp[(i-1)%2][j][k-1][2])+a[k][1]+max(0,j-sum[a[k][1]][0])+max(0,l-sum[a[k][1]][2])-i;
                if(l) dp[i%2][j][k][2]=min(dp[(i-1)%2][j][k][0],dp[(i-1)%2][j][k][1])+a[l][2]+max(0,j-sum[a[l][2]][0])+max(0,k-sum[a[l][2]][1])-i;
            }
        }
    }
    cout<<min({dp[n%2][l1][l2][0],dp[n%2][l1][l2][1],dp[n%2][l1][l2][2]});
}
```

---


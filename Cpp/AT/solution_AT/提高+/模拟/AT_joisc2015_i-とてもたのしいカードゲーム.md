# とてもたのしいカードゲーム

## 题目描述

## JOISC2015 Day3T2 有趣的纸牌游戏


给定$N$张纸牌，纸牌自上而下堆在牌堆$A$中。牌堆$A$中从上而下第$i$张纸牌颜色是$c_i$、权值是$a_i$、价值是$v_i$。

同时你还有另一个牌堆$B$，初始$B$中没有牌。你可以进行以下操作若干次：

从牌堆中$A$选出自上而下第$1$张或者第$3$张纸牌（如果存在）。如果牌堆$B$中没有牌，或者牌堆$B$的堆顶的牌与你当前选出的牌在颜色或者权值上存在至少一个相同，则将这张纸牌移动到牌堆$B$的堆顶。

定义一个牌堆的价值为其中所有纸牌的价值之和，你需要求出牌堆$B$的可能最大价值。

## 说明/提示

$1 \leq N , a_i , c_i \leq 500$

$1 \leq v_i \leq 10^6$

### 样例

#### 样例输入1

```
5
1 3 2
4 2 9
1 4 6
2 3 3
2 2 1
```

#### 样例输出1

```
15
```

#### 样例1解释

依次选出牌堆$A$的第$1,3,3,1$张牌可使牌堆$B$达到最大价值。

#### 样例输入2

```
8
11 5 31
2 8 19
2 9 2
11 8 45
4 8 22
4 2 23
6 9 58
6 2 5
```

#### 样例输出2

```
160
```

# 题解

## 作者：zzzyyyyhhhhh (赞：2)

挺不错的一道题，但校内 oj 空间只开了 512 MB ，赛时虽然有勇气写出正解的思路，但只能通过开小数组获得部分分。

数据范围一眼 $n^3$ dp 。因为只会取走当前第三张牌以上的牌，且这样的牌最多只有两张，很容易想到分别记录第一，二，三张牌位置作为状态，发现不好转移，于是增设一维状态，用 0 1 2 表示能不能选当前的第一张和能不能选当前的第三张，以及是否可以都选。

发现状态数很少，适合使用记忆化搜索。

考虑状态转移，如果当前选第一张，那么第二张变成第一张，第三张变成第二张，第三张后面一张变成第三张，即：

$$f_{x,y,z}=f_{y,z,z+1}+v_x$$

如果选第三张同理，即:

$$f_{x,y,z}=f_{x,y,z+1}+v_z$$

用辅助函数 `to` 计算下次能不能选第一张和第三张。

空间卡的很死，再大就不能过编了。

code

```
#include<bits/stdc++.h>
using namespace std;
const int N = 510;
int n;
int f[N][N][N][3];
bool v[N][N][N][3];
struct card
{
	int c,a,v;
}a[N];
int cnt;
inline int to(int x,int z,int xx)
{
	int res=0;
	if(x<=n&&xx<=n)if(a[x].c==a[xx].c||a[x].a==a[xx].a)res|=1;
	if(z<=n&&xx<=n)if(a[z].c==a[xx].c||a[z].a==a[xx].a)res|=2;
	return res;
}
inline int dfs(int x,int y,int z,int st)
{
	if(st==0||x>=y||y>=z||x>=z)return 0;
	if(v[x][y][z][st-1])return f[x][y][z][st-1];
	v[x][y][z][st-1]=1;
	int res=0;
	if(st&1)res=max(res,dfs(y,z,z+1,to(y,z+1,x))+a[x].v);
	if((st&2)&&z<=n)res=max(res,dfs(x,y,z+1,to(x,z+1,z))+a[z].v);
	f[x][y][z][st-1]=res;
	return f[x][y][z][st-1];
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	int x,y,z;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y>>z;
		a[i]={x,y,z};
	}
	cout<<max(dfs(2,3,4,to(2,4,1))+a[1].v,dfs(1,2,4,to(1,4,3))+a[3].v)<<'\n';
}
```

---

## 作者：shinkuu (赞：0)

同意楼上说的，确实挺不错的。

然而有更简单的解法。

先将暴力转移方程列出来：设 $dp_{i,j,k,l}$ 表示当前 A 牌堆最上面三张分别是第 $i,j,k$ 张牌，B 牌堆最上面是第 $l$ 张的最大价值。则有：

$$dp_{i,j,k,l}\to dp_{j,k,k+1,i}(c_i=c_l\lor a_i=a_l)$$

$$dp_{i,j,k,l}\to dp_{i,j,k+1,k}(c_k=c_l\lor a_k=a_l)$$

$O(n^4)$，明显不能过。考虑优化。发现状态数 $O(n^4)$，转移 $O(1)$，优化状态即可。

容易发现，两种转移的目标装态的 $k$ 都为 $k+1$。可以考虑优化这一维。同时发现，要么 $k=j+1$，要么 $k=l+1$。所以可以将状态变为 $dp_{i,j,k,0/1}$ 表示 A 牌堆最上面三张为第 $i,j,j+1/l+1$ 张牌，B 牌堆最上面为第 $k$ 张的最大值。一样转移即可。

对于处理最后 $j,k$ 可能为 $0$ 或 $>n$ 的情况，可以先塞两个全为 $0$ 的物品到最后。

code：

```cpp
int n,m,a[N],b[N],c[N],dp[N][N][N][2];
void Yorushika(){
	scanf("%d",&n);
	rep(i,1,n){
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
	}
	n++,a[n]=b[n]=c[n]=0;
	n++,a[n]=b[n]=c[n]=0;
	mems(dp,-0x3f);
	dp[2][3][1][0]=c[1];
	dp[1][2][3][1]=c[3];
	int ans=0;
	rep(i,1,n){
		rep(j,1,n){
			rep(l,1,n){
				if(dp[i][j][l][0]>-1e9){
					int k=j+1;
					if(a[i]==a[l]||b[i]==b[l]||!a[i])
						dp[j][k][i][0]=max(dp[j][k][i][0],dp[i][j][l][0]+c[i]);
					if(a[k]==a[l]||b[k]==b[l]||!a[k])
						dp[i][j][k][1]=max(dp[i][j][k][1],dp[i][j][l][0]+c[k]);
					ans=max(ans,dp[i][j][l][0]);
				}
				if(dp[i][j][l][1]>-1e9){
					int k=l+1;
					if(a[i]==a[l]||b[i]==b[l]||!a[i])
						dp[j][k][i][0]=max(dp[j][k][i][0],dp[i][j][l][1]+c[i]);
					if(a[k]==a[l]||b[k]==b[l]||!a[k])
						dp[i][j][k][1]=max(dp[i][j][k][1],dp[i][j][l][1]+c[k]);
					ans=max(ans,dp[i][j][l][1]);
				}
			}
		}
	}
	printf("%d\n",ans);
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

---

## 作者：Shunpower (赞：0)

模拟赛时场切了，题挺不错的。

可以轻松想到考虑 dp。注意到我们必须起码要得知前三张牌的情况才能转移，于是考虑 $f_{i,j,k}$ 表示牌堆顶的牌是 $i$，牌堆顶下第二张牌是 $j$，牌堆顶下第三张牌是 $k$ 的最大价值。

这里必须把第二张牌 $j$ 塞进状态是因为虽然转移不可能抽走第二张牌，但是我们无法保证第二张牌 $j$ 和第一张牌 $i$ 存在特定的关系，这很容易可以举出反例。而不用把第三张牌 $k$ 之下的牌塞进状态则是因为在 $k$ 之下的牌一定是原牌堆 $k$ 之下的牌，即 $k+1\sim n$。因为 $k+1\sim n$ 这些牌前面至少有三张牌还没抽，他们绝对不可能被抽走。

然而你考虑还是有问题，由于我不知道上一张抽的牌的花色或点数是什么，我无法判断我现在能不能抽 $i$ 牌或 $k$ 牌。而你发现这里最多只有四种抽牌可能，可以想到增加一维 $p=0,1,2,3$：

- $p=0$，意味着无法再抽任何牌，贡献答案。
- $p=1$，意味着只能抽 $i$ 牌，$i$ 牌被抽走之后，牌堆顶部的三张牌会变为 $j,k,k+1$。那么计算一下 $p'$ 表示 $i$ 牌与**下一次的**第一张牌 $j$ 的可抽性和 $i$ 牌与**下一次的**第三张牌 $k+1$ 的可抽性，转移 $f_{i,j,k,1}\to f_{j,k,k+1,p'}$ 即可。
- $p=2$，意味着只能抽 $k$ 牌，$k$ 牌被抽走之后，牌堆顶部的三张牌会变为 $i,j,k+1$。那么计算一下 $p''$ 表示 $k$ 牌与第一张牌 $i$（$k$ 前面的牌没动）的可抽性和 $k$ 牌与**下一次的**第三张牌 $k+1$ 的可抽性，转移 $f_{i,j,k,2}\to f_{i,j,k+1,p''}$ 即可。
- $p=3$，同时做 $p=1$ 和 $p=2$ 的转移即可。

你也可以理解我们将上一次抽的牌与目前的第一张牌 $i$、第三张牌 $k$ 的可抽性压成了一个两位二进制数 $p$ 塞进状态，满足我们判断是否能够转移的需求。

然而这样我们的数组大小是 $4n^3$ 的，算出来大概需要两个 G。注意到所有转移中我们总是转移 $k\to k+1$，于是我们可以交换转移顺序，滚动掉 $k$ 这一维，就能把空间复杂度降到 $\mathcal O(n^2)$，数组大小为非常健康的 $8n^2$。

注意实现时可能最后你会转移到空牌（例如牌 $n+1$ 等不存在的牌），也需要从空牌继续转移。对于这些空牌我们可以不管它，把它们当成占位符，只需要保证空牌不会被判断成可抽就行了。而这也意味着最终牌堆可能包含空牌甚至是个空牌堆，答案可能来自于 $f_{n+1,n+2,n+3}$ 等，因此需要注意循环上界。

某些实现还可能在 $n=1,2$ 等边界情况出现问题。

代码如下：

```cpp
int n;
int dp[2][510][510][4];
int c[N],a[N],v[N];
int match(int x,int y){//判断现在抽走的牌与其他牌的可抽性
    if(y>n){
        return 0;
    }
    return c[x]==c[y]||a[x]==a[y];
}
// #define Griffin cute
int main(){
#ifdef Griffin
    freopen("card.in","r",stdin);
    freopen("card.out","w",stdout);
#endif
    cin>>n;
    fr1(i,1,n){
        cin>>c[i]>>a[i]>>v[i];
    }
    fr1(k,0,1){
        fr1(i,1,n){
            fr1(j,i+1,n+1){
                fr1(p,0,3){
                    dp[k][i][j][p]=uinf;//赋初值，注意必须要设足够小的负无穷，否则可能在加上所有权值后大于0贡献答案
                }
            }
        }
    }
    fr1(i,0,3){
        dp[0][1][2][i]=0;//初始时任意牌都可以抽
    }
    int ans=0;
    int op=0;
    fr1(k,3,n+3){//注意k的循环上界是n+3（即空牌堆）
        fr1(i,1,n+1){//注意i的循环上界是n+1（也是空牌堆）
            fr1(j,i+1,k-1){//显然，j的循环区间是(i,k)
                fr1(p,0,3){
                    if(p==0){
                        ans=max(ans,dp[op][i][j][p]);//抽不动了，贡献答案
                    }
                    if(p==1||p==3){//可以抽i
                        int x=match(i,k+1)*2+match(i,j);//判断i与新的第一张牌j，新的第三张牌k+1的可抽性并压成二进制数
                        dp[op^1][j][k][x]=max(dp[op^1][j][k][x],dp[op][i][j][p]+v[i]);//转移，滚动数组之后比较丑
                    }
                    if(p==2||p==3){//可以抽k
                        int x=match(k,k+1)*2+match(i,k);//同理
                        dp[op^1][i][j][x]=max(dp[op^1][i][j][x],dp[op][i][j][p]+v[k]);
                    }
                    dp[op][i][j][p]=uinf;//滚动数组需要清空
                }
            }
        }
        op^=1;
    }
    cout<<ans<<'\n';
    ET;
}
//ETERNAL LOVE FOR Zhang Junhao, Mu Zhicheng and Zuo Hang.
//ALL FOR Zhang Junhao.
```


---


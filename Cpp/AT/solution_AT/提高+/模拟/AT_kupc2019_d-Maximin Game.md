# Maximin Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/kupc2019/tasks/kupc2019_d

$ 2N $ 枚のカードがあります。 $ i~(1\ \leq\ i\ \leq\ 2N) $ 番目のカードには、整数 $ i $ が書かれています。

千咲さんと月乃瀬さんは、これらのカードを使って次のようなゲームをすることにしました。

1. カードをよくシャッフルし、$ N $ 枚ずつ取ってお互いの最初の手札とする。
2. ゲームは $ N $ ラウンドからなる。各ラウンドでは、$ 2 $ 人のプレイヤーは手札の中で最も小さい数が書かれたカードを選び、見せ合う。見せたカードに書かれた数の大きいほうが、そのラウンドの勝者になる。見せたカードはお互いに手札から取り除き、それ以降のラウンドでは考慮しない。

千咲さんと月乃瀬さんは、このゲームを $ 1 $ 回プレイしました。

ゲームの結果が `0` と `1` のみからなる長さ $ N $ の文字列 $ S $ として与えられます。 任意の整数 $ i\ (1\ \leq\ i\ \leq\ N) $ について、$ S_i $ が `1` のとき、 千咲さんがゲームの $ i $ 回目のラウンドの勝者になったことを、$ S_i $ が `0` のとき、そうでないことを意味します。

このようなゲームの結果を与える千咲さんの最初の手札として、ありえるものは何種類あるでしょうか？ 答えはとても大きくなることがあるため、$ 998244353 $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ S $ は `0` と `1` のみからなる長さ $ N $ の文字列である。

### Sample Explanation 1

千咲さんの最初の手札に $ 1 $ と $ 4 $ が、月乃瀬さんの最初の手札に $ 2 $ と $ 3 $ が書かれたカードがある場合を考えます。このとき、 - $ 1 $ 回目のラウンドでは、千咲さんは $ 1 $ が書かれたカードを、月乃瀬さんは $ 2 $ が書かれたカードをお互いに見せ、月乃瀬さんがラウンドの勝者になります。 - $ 2 $ 回目のラウンドでは、千咲さんは $ 4 $ が書かれたカードを、月乃瀬さんは $ 3 $ が書かれたカードをお互いに見せ、千咲さんがラウンドの勝者になります。 よって、千咲さんのこの最初の手札は、与えられたゲーム結果を満たします。

## 样例 #1

### 输入

```
2
01```

### 输出

```
1```

## 样例 #2

### 输入

```
15
111110001011100```

### 输出

```
2100```

# 题解

## 作者：喵仔牛奶 (赞：0)

# Solution

问题即为将 $1\sim 2n$ 划分为 $\{a_n\},\{b_n\}$，使得 $a_i<a_{i+1}$，$b_i<b_{i+1}$，并且根据 $S_i$ 的值，还有 $a_i<b_i$ 或 $a_i>b_i$ 的限制，让你求方案数。

考虑相邻的限制不同的位置，设其为 $\begin{cases}a_i<b_i\\a_{i+1}>b_{i+1}\end{cases}$，那么 $a_i<b_i<b_{i+1}<a_{i+1}$，也就是说所有 $\forall j\in[1,i]\land k\in(i,n],a_j<a_k,b_j<b_k$。那么这两部分就是独立的了。容易发现另一种情况（不等号）也是两边独立的。

那么所有连续段都是独立的。对于一个长度为 $n$ 的连续段，将败者的牌看着左括号，问题变为计数长度为 $n$ 的合法括号序列数。容易发现这就是卡特兰数 $\binom{2n}{n}-\binom{2n}{n-1}$。

> 不会求卡特兰数？建立平面直角坐标系，将左括号看着向 $x$ 轴正方向走，将右括号看着向 $y$ 轴正方向走，问题变化不经过 $y=x+1$ 这条直线，从 $(0,0)$ 到 $(n,n)$ 的路径数。
>
> 不考虑第一个限制，方案是 $\binom{2n}{n}$。将第一次触碰直线后的路径翻转，所有不合法路径可以对应 $(0,0)\to(n-1,n+1)$ 的路径，它的方案数是 $\binom{2n}{n-1}$。
> 
> 故方案数为 $\binom{2n}{n}-\binom{2n}{n-1}$。

把所有连续段的方案乘起来即为答案。复杂度线性。

# Code

```cpp
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
...
namespace Milkcat {
	using namespace math;
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5, mod = 998244353;
	typedef mint<mod> MI;
	int n, ct; char s[N]; MI rs; Comb<MI> C;
	int main() {
		cin >> n, C.init(n * 2), rs = 1;
		REP(i, 1, n) cin >> s[i];
		REP(i, 1, n + 1) {
			if (i > 1 && s[i] != s[i - 1])
				rs *= C(ct * 2, ct) - C(ct * 2, ct - 1), ct = 0;
			ct ++;
		}
		cout << rs << '\n';
		return 0;
	}
}
```

---


# stepモード

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tenka1-2015-quala/tasks/tenka1_2015_qualA_b

 アンドウくんは、 $ N $ 個のスクリプトを実行し、実行開始時刻と実行終了時刻を記録しました。  
 しかしこの日、アンドウくんの時計は $ 1000 $ ミリ秒巻き戻るという事象が一度発生しました。  
 もしかすると、スクリプトの実行時間がわからなくなってしまったかもしれません。

 実行開始時刻と実行終了時刻のリストが与えられるので、各スクリプトの実行時間を計算し、ミリ秒単位で出力してください。  
 ただし、以下の点に注意してください。

- 実行時間が一意に定まらないスクリプトに対しては`-1`を出力してください。
- スクリプトの実行時間はいずれも $ 1 $ ミリ秒以上でした。
- 巻き戻りは瞬間的な事象であり、巻き戻りにかかる時間は $ 0 $ ミリ秒です。
- 実行開始時刻と実行終了時刻について丸めは起こらないものとし、実行開始時刻と実行終了時刻のミリ秒未満の位の値はすべて $ 0 $ であるとします。  
   つまり、実行開始時刻および実行終了時刻をミリ秒単位で表した値 $ t $ に関して、 $ t $ は整数であることが分かっています。
- 巻き戻りの発生時刻のミリ秒未満の値は $ 0 $ ではありません。  
   つまり、巻き戻りの発生時刻をミリ秒単位で表した値 $ r $ に関して、 $ r $ は整数**でないこと**が分かっています。  
   よって、巻き戻りの発生時刻は、実行開始時刻および実行終了時刻と同時刻ではありません。
- 夏時間はありません。

## 说明/提示

### 配点

この問題には部分点が設定されていない。全てのテストケースに正解した場合は、 $ 50 $ 点が与えられる。

### Sample Explanation 1

スクリプトの終了時刻が開始時刻より前になっているので、実行中に巻き戻りが発生したことが分かります。

### Sample Explanation 2

スクリプトの実行中に巻き戻りが発生したかどうか特定できません。 発生していた場合は $ 4000 $ ミリ秒、発生していなかった場合は $ 3000 $ ミリ秒になります。

### Sample Explanation 3

$ 2 $ つ目のスクリプトから、巻き戻り前の時間軸で`21:00:01.500`より後、`21:00:02.000`より前に巻き戻ったことが分かります。 !\[\](http://tenka1.klab.jp/2015/images/b7f72704a8bc78d22cb2ccb26a88375c431c7532.png)

### Sample Explanation 4

入力例3と同様に、 $ 2 $ つ目のスクリプトから、巻き戻り前の時間軸で`21:00:01.500`より後、`21:00:02.000`より前に巻き戻ったことが分かります。 しかし、$ 3 $つ目のスクリプトの終了時刻が、巻き戻り前の時間軸での記述なのか巻き戻った後の記述なのかの判断ができません。

## 样例 #1

### 输入

```
1
21:00:01.500 21:00:01.000```

### 输出

```
500```

## 样例 #2

### 输入

```
1
22:00:00.000 22:00:03.000```

### 输出

```
-1```

## 样例 #3

### 输入

```
3
21:00:00.000 21:00:03.000
21:00:01.500 21:00:01.000
21:00:02.000 21:00:02.500```

### 输出

```
4000
500
500```

## 样例 #4

### 输入

```
3
21:00:00.000 21:00:03.000
21:00:01.500 21:00:01.000
21:00:00.500 21:00:01.000```

### 输出

```
4000
500
-1```

# 题解

## 作者：oyoham (赞：1)

### Problem
有 $n$ 个至少运行了 $1$ 毫秒的程序在 $21:00:00.000$ 到 $22:00:00.000$ 运行。有一个以毫秒为单位计时器正在计时。  
这个计时器记录的这 $n$ 个程序开始运行于结束运行的时刻，但是这个计时器坏了，在这过程中，出现了一次瞬间的回表，跳回了一秒前，于是问你能不能得出每个程序的运行时间。  
已知每个程序的起始时间于结束时间均为整毫秒，回表发生的时间**不是**整毫秒，对于每个程序，输出它的运行时间，或者报告无法确定它的运行时间（即有可能程序运行时发生了回表，也有可能没有发生回表）。  
保证输入合法，即不会发生二次以上回表等情况。
### Solution
以下的时间点均为从 $21:00:00.000$ 开始经过的毫秒数。  
考虑如果得到回表可能发生的时间段，然后判断每个程序运行时是否一定发生回表。具体的，若回表可能发生的时间段为 $[l,r]$，某程序运行的时间段为 $[s,t]$，则当 $s+1000\le l$ 且 $t\ge r$ 时（开始一定在回表前且结束一定在回表后），或 $s\ge t$ 时，一定发生回表。而当 $s\ge r$ 或 $e+1000\le l$ 时（开始一定在回表后或结束一定在回表前）一定不发生回表。其他情况则为不确定是否发生回表的。  
考虑如和得到回表可能发生的时间段，对于每一个程序运行的时间段 $[s,t]$，若 $s\ge t$ 则回表一定在 $s$ 后且回到 $t$ 前，即在 $[s,t+1000]$ 中发生，找到所有段的交集（及最大左端点与最小右端点）即可做出此题。  
注意 `<=`，`+1000` 等细节。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
#define aF(begin,end,step,name) for(int name=begin;name<=end;name+=step)
#define oF(B,E,N) aF(B,E,1,N)
#define af(B,E,S) aF(B,E,S,i)
#define of(B,E) af(B,E,1)
#define tF(E,N) oF(1,E,N)
#define tf(E) of(1,E)
#define nF(N) tF(n,N)
#define nf() tf(n)
#define GF(x,ep) for(int ep=h[x];ep;ep=nxt[ep]) 
#define Gf(x) GF(x,ep)
#define gF(ep) GF(x,ep)
#define gf() Gf(x)
inline ll read(){
	ll x=0;
	short f=1;
	char c=getchar();
	while(c>57||c<48){
		if(c==45) f=-1;
		c=getchar();
	}
	while(c<58&&c>47){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void write(ll x){
	if(x<0ll) putchar(45),x=~x+1;
	if(x>9ll) write(x/10);
	putchar(x%10|48);
}
inline char gtch(){
	char c=getchar();
	while(c<33) c=getchar();
	return c;
}
int n=read();
int Read(){
	int H=read()-21,M=read(),S=read();
	return (((H*60+M)*60+S)*1000+read());
} 
int s[105],e[105];
int q[105];
int l=-1,r=1145141919810;
signed main(){
	nf()s[i]=Read(),e[i]=Read();
	nf()if(e[i]<=s[i]){
		l=max(l,s[i]);
		r=min(r,e[i]+1000);
	}
	nf(){
		if(e[i]<=s[i]||s[i]+1000<=l&&r<=e[i]) write(e[i]-s[i]+1000);
		else if(e[i]+1000<=l||s[i]>=r) write(e[i]-s[i]);
		else write(-1);
		putchar(10);
	}
}
```

---

## 作者：ast123 (赞：0)

以下称时刻为自 $21:00:00.000$ 到当前时间经过的毫秒数。  
模拟题。求出回跳可能出现的区间 $[l,r]$，判断当前区间 $[s_i,t_i]$ 与区间 $[l,r]$ 的关系，分类讨论受到回跳影响、不受回调影响和不确定三种。
+ 受回跳影响，则当前区间的左边界 $s_i$ 不能由 $[l,r]$ 中的数回跳得到，右边界在 $r$ 右侧，即 $l-s_i \ge 1000$ 且 $t_i \ge r$，或 $s_i \ge t_i$。
+ 不受回跳影响，则当前区间在 $[l,r]$ 左侧或右侧，且端点不能由 $[l,r]$ 区间内的数得到，即 $s_i \ge r$ 或 $l-t_i \ge 1000$。
+ 其余的情况即为不确定。

求区间 $[l,r]$，我们需要将所有 $s_i \ge t_i$ ，即一定受回跳影响区间的 $[s_i,t_i+1000]$ 取交集，然后就做完了。[代码链接](https://atcoder.jp/contests/tenka1-2015-quala/submissions/57487611)。

感谢[@oyoham](https://www.luogu.com/user/957618)的帮助。

---


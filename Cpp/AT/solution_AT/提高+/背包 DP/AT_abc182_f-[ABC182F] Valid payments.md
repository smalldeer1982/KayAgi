# [ABC182F] Valid payments

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc182/tasks/abc182_f

AtCoder 国には $ A_1 $ 円玉、$ A_2 $ 円玉、$ A_3 $ 円玉、$ \dots $ 、$ A_N $ 円玉の $ N $ 種類のコインがあります。  
 ここで $ A_1\ =\ 1 $ であり、$ 1\ \le\ i\ \lt\ N $ を満たす全ての整数 $ i $ について、 $ A_i\ \lt\ A_{i\ +\ 1} $ かつ $ A_{i\ +\ 1} $ は $ A_i $ の倍数です。

この国のある店で、犬のルンルンは $ X $ 円の商品を購入するために店員に $ y\ (\ge\ X) $ 円を渡し、店員はお釣りとして $ y\ -\ X $ 円を返しました。(お釣りが $ 0 $ 円の可能性もあります)  
 このとき、ルンルンも店員もその金額をちょうど渡すのに必要な最小の枚数のコインで受け渡しを行いました。  
 また、ルンルンが店員に渡したコインのいずれかと同じ種類のコインが店員から返されることはありませんでした。

$ X $ が与えられるので、$ y $ として考えられる値が何通りあるかを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 50 $
- $ 1\ =\ A_1\ \lt\ A_2\ \lt\ A_3\ \lt\ \dots\ \lt\ A_N\ \le\ 10^{15} $
- $ A_{i\ +\ 1} $ は $ A_i $ の倍数 $ (1\ \le\ i\ \lt\ N) $
- $ 1\ \le\ X\ \le\ 10^{15} $
- 入力はすべて整数

### Sample Explanation 1

$ y $ として考えられる値は $ 9,\ 10,\ 14 $ です。 例えば、 $ y\ =\ 14 $ のときルンルンは $ 10 $ 円玉 $ 1 $ 枚と $ 1 $ 円玉 $ 4 $ 枚を渡し、店員は $ 5 $ 円玉 $ 1 $ 枚でお釣りを返します。 このとき、ルンルンが渡したどの種類のコインも店員は返していないので条件を満たします。

### Sample Explanation 2

$ y $ として考えられる値は $ 198,\ 200,\ 203,\ 208,\ 248 $ です。

### Sample Explanation 3

$ y $ として考えられる値は $ 44,\ 60,\ 100,\ 104 $ です。

## 样例 #1

### 输入

```
3 9
1 5 10```

### 输出

```
3```

## 样例 #2

### 输入

```
5 198
1 5 10 50 100```

### 输出

```
5```

## 样例 #3

### 输入

```
4 44
1 4 20 100```

### 输出

```
4```

## 样例 #4

### 输入

```
9 11837029798
1 942454037 2827362111 19791534777 257289952101 771869856303 3859349281515 30874794252120 216123559764840```

### 输出

```
21```

# 题解

## 作者：skyskyCCC (赞：2)

## 前言。
不是很远古 ABC 题选做。本题的第一篇题解，这道题的思路还是很巧妙的，因为看到 $10^{15}$ 的庞大数据就知道本题的思路应该不需要过大的 $a_i$ 参与计算。 
## 分析。
先考虑一下最优的付钱方式。我们假设需要支付 $y$ 元，其中第 $a_i$ 种钱币支付了 $b_i$ 张。则因为 $a_i<a_{i+1}$ 又 $a_{i+1}$ 是 $a_i$ 的倍数，所以可以得到 $b_i<\frac{a_{i+1}}{a_i}$。否则一定存在一种方案，可以调整钱币的数量，从而人为地满足这一条件，此时付钱的方式为最优解。因为店员没有归还任何付给他的硬币，所以一定存在至少一个 $b_i$ 为 $0$。那么我们可以考虑将售货员找的钱取反,此时就能恰好通过一个序列 $b$ 表示一种可行的支付方案。此时便有两种做法。
- 解法一。

采用动态规划。根据上面的分析，我们可以得到这道题的本质就是求序列 $b$ 的数量，其中满足：
$$\sum_{i=1}^n a_i\times b_i=X\left(-\frac{a_{i+1}}{a_i}<b_i<\frac{a_{i+1}}{a_i}\right)$$
那么对于任何一个 $i$ 则都有 $\sum_{i=1}^n a_j\times b_j<a_i\left(j<i\right)$。因此对于任何一个 $i$ 都必须满足 $\lvert\sum_{i=1}^n a_j\times b_j-X\rvert<a_i\left(i\leq j\right)$。显然对于这些数中，我们发现对于任何一个 $a_i$ 它必定是 $\sum_{i=1}^n a_j\times b_j\left(i\leq j\right)$ 的倍数，因此后者至多只能有两种取值。那么我们不妨先计算出所有的取值，然后进行动态规划统筹计算即可。令 $dp_{i,j}$ 表示 $\sum_{i=1}^n a_k\times b_k=j\left(k\leq i\right)$ 时的方案数，则通过判断前后两种硬币的面额，然后判断是否能够满足题意即可。

代码如下，仅供参考：
```
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
long long n,X,a[55];
long long ans,tot[55],b[55][5],dp[55][5];
int main(){
    cin>>n>>X;
    for (long long i=1;i<=n;i++){
    	cin>>a[i];
    	long long sum=ceil(1.0*(X-a[i]+1)/a[i]);
    	long long sum2=(X+a[i]-1)/a[i];
    	for (long long j=sum;j<=sum2;j++){
    		b[i][++tot[i]]=j*a[i];
		}
	}
	for (long long i=1;i<=tot[n];i++){
		dp[n][i]=1;
	}
    for (long long i=n-1;i>=1;i--){
    	for (long long j=1;j<=tot[i];j++){
    		for (long long k=1;k<=tot[i+1];k++){
    			if(abs(b[i+1][k]-b[i][j])/a[i]<a[i+1]/a[i]){
    				dp[i][j]+=dp[i+1][k];
				}
			}
		}
	}
    for (long long i=1;i<=tot[1];i++){
    	ans+=dp[1][i];
	}
    cout<<ans<<"\n";
    return 0;
}
```
- 解法二。

仍然采用动态规划。我们令 $Z=y-X$ 则我们可以表示出来：
$$\left\{\begin{aligned}X=\sum_{i=1}^n x_i\times a_i\\y=\sum_{i-1}^n y_i\times a_i\\Z=\sum_{i=1}^n z_i\times a_i\end{aligned}\right.$$
那么根据题意则可以得到 $y_i$ 和 $z_i$ 不能同时大于 $0$ 又 $X$ 是唯一确定的，所以可以被唯一表示出来。所以我们只需要考虑 $Z$ 的组成情况即可，因为如果 $Z$ 一旦确定，那么等式 $Z=y-X$ 中知二求一，相应的 $y$ 也能表示出来。换言之，其中的 $Z$ 和 $y$ 中在某一位必定存在一个 $0$ 则这个东西可以看做十进制，当确定 $z_i$ 和这一位是否需要进位，相应的 $y_i$ 也就可以确定了，具体来说，就是当 $X$ 某一位是 $0$ 时，相应的 $Z$ 的那一位只能填 $0$，反之 $Z$ 的这一位只能填一个和 $X$ 的这一位相加恰好能进位的数。

我们设 $w$ 表示第 $i-1$ 位是否需要进位，如果是则为 $1$ 否则为 $0$ 则因为 $y_i+w+x_i=y_i$ 所以我们可以采用动态规划。我们设 $dp_{i,j}$ 表示第 $i$ 位进位或者不进位时的方案数，其中 $j$ 只能取 $1$ 或者 $0$ 分别表示进位或者不进位。那么我们就可以推转移方程了。

若 $z_i$ 对应的第 $i$ 位不进位时，则不难得到 $z_{i+1}=0$ 即第 $i+1$ 位也不需要进位。此时 $dp_{i+1,0}=dp_{i,0}$。同理我们可以考虑进位的情况，此时 $dp_{i+1,1}=dp_{i+1,1}+dp_{i,1}$。那么如果 $x_{i+1}$ 不等于 $0$ 时，显然我们可以得到第 $i$ 位和第 $i+1$ 位是否进位没有必然的联系，一进位，另一个也可以不进位。只要满足题意就可以进行转移，同理也有 $x_{i+1}$ 等于 $0$ 的情况。转移方程具体可以见代码。因为第 $n$ 位必定不可能进位，所以答案就是 $dp_{n,0}$ 存的数。

代码如下，仅供参考：
```
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
long long n,X,a[55];
long long b[55],c[55],dp[55][5];
int main(){
	cin>>n>>X;
	long long x=X;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
	    b[i]=a[i+1]/a[i];
	}
	for(int i=n;i>=1;i--){
		c[i]=x/a[i];
		x%=a[i];
	}
	dp[1][0]=1;
	if(c[1]){
		dp[1][1]=1;
	}
	for(int i=1;i<n;i++){
		dp[i+1][0]=dp[i][0];
		if(c[i+1]){
		    dp[i+1][1]=dp[i][0];
		}
		dp[i+1][1]+=dp[i][1];
		if(c[i+1]+1!=b[i+1]){
		    dp[i+1][0]+=dp[i][1];
		}
	}
	cout<<dp[n][0]<<"\n";
	return 0;
}
```
## 后记。
解法一跑了 $1$ 分秒，解法二跑了 $1$ 分秒，不相上下。

大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：D2T1 (赞：1)

发现这个东西类似于进位，所以考虑 $X+(y-X)=y$，从低位到高位考虑 $(y-X)$ 的每一位到底有没有使得 $X$ 进位。

又因为我们要求 $y-X,y$ 每一位至多只有一个非 $0$，那么可以发现进位或不进位能填的数至多一个，所以 dp 设 $f_{i,0/1}$ 表示低 $i$ 位的方案数，且第 $i$ 位有没有进位，$b_i$ 表示 $X$ 的进制拆分。那么有：

$$f_{i,0}=f_{i-1,0}+f_{i-1,1}[b_i+1<\dfrac{a_{i+1}}{a_i}]$$

因为当 $b_i+1=\dfrac{a_{i+1}}{a_i}$ 时，第 $i$ 位会被迫因 $i-1$ 位的进位而进位。

$$f_{i,1}=f_{i-1,1}+f_{i-1,0}[b_i\neq0]$$

因为当 $b_i=0$ 时，不可能凭这一位的贡献使这一位进位。

```cpp
const int N = 60;
int n;
ll x, a[N], b[N], f[N][2];

void solve(){
	read(n, x);
	for(int i = 1; i <= n; ++ i){
		read(a[i]);
	}
	for(int i = n; i >= 1; -- i){
		b[i] = x / a[i];
		x %= a[i];
	}
	f[0][0] = 1;
	for(int i = 1; i < n; ++ i){
		f[i][0] += f[i-1][0] + f[i-1][1] * (b[i] + 1 < a[i+1] / a[i]);
		f[i][1] += f[i-1][1] + f[i-1][0] * (b[i] != 0);
	}
	println(f[n-1][0] + f[n-1][1]);
}
```

---


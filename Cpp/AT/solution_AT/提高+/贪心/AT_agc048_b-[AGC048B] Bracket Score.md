# [AGC048B] Bracket Score

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc048/tasks/agc048_b

この問題では，`(`,`)`,`[`,`]` からなる文字列を考えます．

文字列 $ x $ は，以下の**いずれか**の条件を満たす時，**良い括弧列**と呼ばれます．

- $ x $ は空文字列である．
- ある良い括弧列 $ s $ が存在し，`(`,$ s $,`)` をこの順に連結すると $ x $ が得られる．
- ある良い括弧列 $ s $ が存在し，`[`,$ s $,`]` をこの順に連結すると $ x $ が得られる．
- ある空でない良い括弧列 $ s $ および $ t $ が存在し，$ s,t $ をこの順に連結すると $ x $ が得られる．

例えば，`[]`, `([()])`, `()[()]` などは良い括弧列ですが，`())`, `([)]` などは良い括弧列ではありません．

偶数 $ N $ と，長さ $ N $ の整数列 $ A $ および $ B $ が与えられます． ここで，長さ $ N $ の良い括弧列 $ s=s_1s_2\cdots\ s_N $ に対して，$ s $ のスコアを次のように定めます．

- $ s $ のスコアは，各文字のスコアの合計である．
- $ i $ 文字目 ($ 1\ \leq\ i\ \leq\ N $) のスコアは，$ s_i $ が `(` または `)` ならば $ A_i $ であり，$ s_i $ が `[` または `]` ならば $ B_i $ である．

長さ $ N $ の良い括弧列のスコアとしてあり得る最大の値を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ N $ は偶数
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $
- 入力される数はすべて整数．

### Sample Explanation 1

$ s= $`()\[\]` とするとスコアが $ A_1+A_2+B_3+B_4=12 $ になり，これが最大です．

## 样例 #1

### 输入

```
4
4 2 3 1
2 3 2 4```

### 输出

```
12```

## 样例 #2

### 输入

```
10
866111664 844917655 383133839 353498483 472381277 550309930 378371075 304570952 955719384 705445072
178537096 218662351 231371336 865935868 579910117 62731178 681212831 16537461 267238505 318106937```

### 输出

```
6629738472```

# 题解

## 作者：sgweo8ys (赞：2)

### 题目描述
长度为 $n$ 的字符串 $S$ 仅有小括号和中括号组成。

现在给定长度为 $n$ 的两个序列 $ A $ 和 $ B $。

我们定义一个合法串 $ S $ 的分数如下：

- 如果 $ S_i= $ ```(``` 或 $ S_i= $ ```)```，那么第 $ i $ 位贡献的分数为 $ A_i $。

- 如果 $ S_i= $ ```[``` 或 $ S_i= $ ```]```，那么第 $ i $ 位贡献的分数为 $ B_i $。

求 $ S $ 可能的最大分数是多少。

其中 $2\le n \le 10^5, 1\le A_i, b_i \le 10^9$，$n$ 为偶数。

### 题解

提供一种不需要脑子（但是需要时间）的做法。

首先，显然地，这题虽然是括号匹配，但实际上是引号匹配，因为左括号和右括号不区分贡献。

尝试考虑 dp，用栈模拟引号匹配。

容易发现，任何一个引号串过栈之后都会形如 $0101010\dots$ 或者 $1010101\dots$，其中 $0$ 代表小引号， $1$ 代表大引号。

于是只要记录当前栈顶是 $0$ 还是 $1$，栈长是多少即可。复杂度 $O(n ^ 2)$。

这显然还是无法通过，dp 算了太多不必要的数据。

考虑先让答案最大，即每个位置贪心的选择最大的权值，这样形成的串过栈之后依然会形如 $010101\dots$ 或 $101010\dots$。

我们假设 $a_i$ 表示第 $i$ 位贪心选的是小引号（$0$）还是大引号（$1$)。

接下来一个很重要的观察：这个结构其实相当稳定，我们不可能通过改很少的位置去让他变得合法。

事实上，一个长度为 $2k$ 的过栈之后的串，我至少要修改 $k$ 个位置才能让他变成合法。

然后去慢慢考虑修改每个位置会变成什么，就能得到最终的结论。

下面直接给出结论：

1. 对于一个合法的串，修改一个位置（将 $0$ 变成 $1$ 或者将 $1$ 变成 $0$）只能让他变成 $01$ 或者 $10$。我们设 $f(i)$ 表示修改 $i$ 变成的串。
   
2. 修改多个位置，变成的串是 $f$ 的拼接（任意顺序），比如 $f(1) = 01,f(2) = 01, f(3) = 10$，那么修改 $1$ 和 $2$ 就是 $0101$，修改 $1$ 和 $3$ 就是空串。这也就是说对于一个匹配串，我们只会修改若干个 $f$ 相同的位置。

   
3. 对于一个合法的串 $[1, n]$，$f(1)$ 的第一个字符与 $a_1$ 相反，比如 $a_1 = 0$ 则 $f(1) = 10$，然后对于所有的 $i \ge 2$，如果 $a_i = a_{i -1}$ 那么 $f(i) = \neg f(i - 1)$，否则 $f(i) = f(i - 1)$。

证明暂时不会。

不妨设贪心后得到的串是 $01010101\dots$。那么在开头，结尾和每相邻两段 $01$ 之间，我们需要让这个合法匹配变成若干个 $10$。

而在每一个 $0$ 和 $1$ 之间，我们需要让这个合法匹配变成若干个 $01$。假设变成了 $010101$，那么在外面套上 $01$ 之后就是 $00101011$，也就是 $1010$。容易发现他变到了 $01$ 外面的同时也变成了若干个 $10$，这样依然是好的。

于是我们先贪心选，得到一个过栈后的串（有多种匹配可以任意选），记录剩下的位置。

然后枚举每个位置，判断他的 $f$ 是否符合条件，如果符合那么他就可以作为改变的位置，否则就不行。（注意贪心剩下的位置一定是符合的）

在符合的位置下贪心地选择 $k$ 个代价最小的修改即可。（其中 $2k$ 是贪心剩下的串的长度）

使用 $\text{nth-element}$，复杂度为 $O(n)$，疑似优于 $\text{std}$。

### 代码

代码同样很短。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 100010;

int n, a[N], b[N], r[N], st[N], top, used[N];
LL ans;

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", a + i);
    for(int i = 1; i <= n; i++) scanf("%d", b + i);
    for(int i = 1; i <= n; i++){
        ans += max(a[i], b[i]);
        r[i] = (a[i] > b[i]);
        if(top && r[st[top]] == r[i]) top--;
        else st[++top] = i;
    }
    for(int i = 1; i <= top; i++) used[st[i]] = 1;

    int k = top / 2, now = -1, bi = r[st[1]], dr = 1, lst = -1;
    vector <int> w;
    for(int i = 1; i <= n; i++){
        if(used[i]){
            dr ^= 1;
            w.emplace_back(-min(a[i] - b[i], b[i] - a[i]));
            continue;
        }
        if(now == -1) now = (r[i] ^ 1);
        else if(r[i] == lst) now ^= 1;
        lst = r[i];
        if(now == (bi ^ dr)) w.emplace_back(-min(a[i] - b[i], b[i] - a[i]));
    }
    nth_element(w.begin(), w.begin() + k - 1, w.end());
    for(int i = 0; i < k; i++) ans -= w[i];
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：ziyanlin2013 (赞：1)

# 题解：AT_agc048_b [AGC048B] Bracket Score

[题目传送门](https://www.luogu.com.cn/problem/AT_agc048_b)

# 简要题意
给定每个位置放中括号和小括号的得分，求一个合法括号串，使得其得分最大。

# 解题思路
先考虑仅有小括号的情况：因为右括号和左括号的得分一样，所以只要有偶数个相同的括号，就一定能组成合法的括号序列。  

但是，现在加入了中括号，考虑以下结论：

**一对中括号内必定有偶数个括号，如果仅有奇数个，不能形成合法括号串。**

例子：   
1.  `([)])`  不合法。
2.  `([()()])`  合法。

即一对中括号的下标奇偶性不同，考虑先将括号序列全变成小括号，然后用大根堆维护最大权值（其实只需要排序就行了），具体实现看代码。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+5;
ll n,a[N],b[N];
ll ans;
priority_queue<ll> q1,q2;//大根堆
int main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>a[i];
		ans+=a[i];
	}
	for (int i=1;i<=n;i++){
		cin>>b[i];
		if(i%2==0) q1.push(b[i]-a[i]);//偶数
		else q2.push(b[i]-a[i]);//奇数
	}
	while(!q1.empty()&&!q2.empty()){
		ll u=q1.top();
		q1.pop();
		ll v=q2.top();
		q2.pop();
		if(u+v>=0){//小于 0 不优，不要加入答案计算
			ans+=u+v;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：igAC (赞：1)

# $\text{Description}$

[洛谷 link](https://www.luogu.com.cn/problem/AT_agc048_b)

[ATlink](https://atcoder.jp/contests/agc048/tasks/agc048_b)

简要题意：

构造一个由 ``(`` ``)`` ``[`` ``]`` 组成的匹配成功的括号序列。

第 $i$ 个位置是 ``(`` 或 ``)`` 的得分是 $a_i$。

第 $i$ 个位置是 ``[`` 或 ``]`` 的得分是 $b_i$。

求最大得分。

# $\text{Solution}$
我们考虑先全部放 ``(`` 和 ``)``，把其中一些换成 ``[`` 或 ``]``。

能替换的一对括号必须是左括号在奇数位而右括号在偶数位，或者左括号在偶数位而右括号在奇数位。

考虑如何证明这个结论（~~这个结论似乎是一眼的~~）：

>一个匹配成功的括号序列的长度一定是偶数，那么对应的左括号与右括号中间一定隔了偶数位。
>
>设左括号在 $i$，中间隔了 $2k$ 位（$k$ 是非负整数），则右括号在 $i+2k+1$，$+2k$ 不改变奇偶性，所以左括号与右括号的奇偶性一定不同。
>
>Q.E.D

我们就可以分别考虑奇数位和偶数位的贡献，以 $b_i-a_i$ 为关键字从大到小排序，枚举改多少对 ``()`` 为 ``[]``，计算答案。

具体实现可参考代码。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
int read(){
	int x=0,f=1,ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f=(ch=='-')?-1:1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
int n,a[N],b[N],ans,sum,l[N],r[N],totl,totr;
signed main(){
	n=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=n;++i) b[i]=read();
	for(int i=1;i<=n;++i) sum+=a[i];
	for(int i=1;i<=n;++i){
		if(i&1) l[++totl]=b[i]-a[i];
		else r[++totr]=b[i]-a[i];
	}
	sort(l+1,l+totl+1),reverse(l+1,l+totl+1);
	sort(r+1,r+totr+1),reverse(r+1,r+totr+1);
	for(int i=1;i<=totl;++i) l[i]+=l[i-1];
	for(int i=1;i<=totr;++i) r[i]+=r[i-1];
	for(int i=0;i<=n/2;++i) ans=max(ans,sum+l[i]+r[i]);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：墨笙_Mooos (赞：1)

神奇但合理的人类智慧。做出来这道题的人思维能力肯定不差。

---

首先，我们令答案对应的括号序列中，所有填入中括号的位置集合 $\left\{x_1, x_2, x_3, x_4, \cdots\right\}$。

括号序列中，对于一对配对的中括号 $(l, r)$，中间一段长度为 $r - l + 1$ 的括号序列应当可以匹配，所以 $r - l + 1$ 一定是偶数。也就是说，$l$ 与 $r$ 的奇偶性必定不相同。对应到 $x_i$ 序列中，就是奇数项与偶数项数量相同。

而反过来考虑，是不是 $x_i$ 序列中奇数项与偶数项数量相同，就必定有解呢？

让我们来尝试对这样一组序列 $x_i$ 构造一组合法的括号序列。

* 将 $x_i$ 升序排序。
* 对于所有相邻两项奇偶性不同的位置，我们填入 ```[()()...()()]```，然后把这两个数删掉，再找下一个相邻两项奇偶性不同的位置。
  * 如果发现要填的段已经有部分被填充也没有关系，只要把没有填充的部分提取出来再填入 ```[()()...()()]``` 即可，这样就不会影响到已经填充的部分。
  * 此时总长度和已被填充的部分长度都是偶数，所以剩余未填部分长度也为偶数，必定可以填充。
* 所有 $x_i$ 都被使用过后，可能还有空缺部分，我们同样把没有填充的部分提出，按照 ```()()...()()``` 的方式填入。

由于 $x_i$ 中奇数项与偶数项数量相同，所以必定可以把 $x_i$ 中所有数都使用一次。

有了这样的构造，我们只要把奇数项和偶数项从大到小成对丢进 $x_i$，直到填圆括号更优为止。

---

在代码实现的时候，我们可以把题目给定的 $A_i$ 与 $B_i$ 作差，再讨论是否要使用中括号。

> Talk is cheap, show me the code.

```cpp
ll n, a[2][100010], t, Ans;
int main ()
{
	std::cin.tie (nullptr), std::ios::sync_with_stdio (false);
	cin >> n;
	For (i, 1, n) cin >> t, Ans += t, a[i & 1][(i + 1) >> 1] = -t;
	For (i, 1, n) cin >> t, a[i & 1][(i + 1) >> 1] += t;
	sort (all (a[0], n / 2), greater<ll> ());
	sort (all (a[1], n / 2), greater<ll> ());
	For (i, 1, n / 2)
		if (a[0][i] + a[1][i] > 0) Ans += a[0][i] + a[1][i];
		else break;
	cout << Ans << endl;
	return 0;
}
```

---

## 作者：StayAlone (赞：0)

考虑先全放小括号，那么答案就是 $\sum_{i=1}^n a_i$。

记 $d_i=b_i-a_i$。那么将一个小括号换成一个中括号后，答案的变化量就是 $d_i$。

一个显然的性质：位置 $(i,j)$ 能同时从小括号变成中括号，当且仅当 $i$ 和 $j$ 的奇偶性不同。

所以将 $d_i$ 按照奇偶性放到两个优先队列里，从两个优先队列里分别取出最大的，若和为正数，就累加到答案中。

[AC code record](https://www.luogu.com.cn/record/109377094)
```cpp
int n, a[MAXN], b[MAXN];
ll ans, d[MAXN];
priority_queue <int> q[2];

int main() {
	read(n); rer(i, 1, n, a); rer(i, 1, n, b);
	rep1(i, 1, n) ans += a[i], d[i] = b[i] - a[i], q[i & 1].emplace(d[i]);
	while (q[0].size() && q[1].size()) {
		ll t1 = q[0].top(); q[0].pop();
		ll t2 = q[1].top(); q[1].pop();
		if (t1 + t2 > 0) ans += t1 + t2;
		else break;
	} printf("%lld\n", ans);
	rout;
}

```

---


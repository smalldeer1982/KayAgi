# [AGC048C] Penguin Skating

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc048/tasks/agc048_c

$ L $ 個のマスが横一列に並んでいます． マスは左から順に $ 1,2,\ldots,L $ と番号が振られています．

$ N $ 匹のペンギンがマス目の上にいます． ペンギンは左から順に $ 1,2,\ldots,N $ と番号が振られています． 最初，ペンギン $ i $ はマス $ A_i $ の上にいます． ここで，$ 1\ \leq\ A_1\ <\ A_2\ <\ \ldots\ <\ A_N\ \leq\ L $ です．

あなたは，次の操作を好きな回数行うことができます．

- ペンギンを $ 1 $ 匹選び，左または右へ向かって滑らせる． ペンギンは，目の前に空マスがある限り滑り続ける． 別のペンギンのいるマスの直前のマスに到達する，もしくは目の前にマスが存在しなくなったら，ペンギンは停止する．

例えば，$ N=3,L=10 $ で，ペンギンのいるマスが $ (2,3,7) $ であるとします． このとき，ペンギン $ 2 $ を右に滑らせると，ペンギン $ 2 $ はマス $ 6 $ まで移動します． また，ペンギン $ 3 $ を右に滑らせると，ペンギン $ 3 $ はマス $ 10 $ まで移動します．

あなたの目標は，すべての $ i $ について，ペンギン $ i $ がマス $ B_i $ の上にいるようにすることです． ここで，$ 1\ \leq\ B_1\ <\ B_2\ <\ \ldots\ <\ B_N\ \leq\ L $ です． 目標が達成可能か判定し，可能ならば必要な操作回数の最小値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ N\ \leq\ L\ \leq\ 10^9 $
- $ 1\ \leq\ A_1\ <\ A_2\ <\ \ldots\ <\ A_N\ \leq\ L $
- $ 1\ \leq\ B_1\ <\ B_2\ <\ \ldots\ <\ B_N\ \leq\ L $
- 入力される数はすべて整数．

### Sample Explanation 1

次のように操作すればよいです． - ペンギン $ 1 $ を左に滑らせる．ペンギンの位置は，$ (1,4,6,10) $ になる． - ペンギン $ 2 $ を右に滑らせる．ペンギンの位置は，$ (1,5,6,10) $ になる． - ペンギン $ 4 $ を右に滑らせる．ペンギンの位置は，$ (1,5,6,11) $ になる．

## 样例 #1

### 输入

```
4 11
3 4 6 10
1 5 6 11```

### 输出

```
3```

## 样例 #2

### 输入

```
1 3
1
2```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 1000000000
65110170 68805223 123016442 275946481 661490312 760727752 764540566 929355340 930658577 947099792
1 2 123016442 661490311 929355337 930658574 999999997 999999998 999999999 1000000000```

### 输出

```
13```

# 题解

## 作者：MurataHimeko (赞：1)

偏简单的一道 AGC。

考虑到如果 $A_i=B_i$，那么 $i$ 肯定是不需要移动的。那么所有这样的 $i$ 将序列分割为若干个连续段，我们只需要在每个连续段内做即可。

设 $C_i = [A_i<B_i]$，如果存在位置 $i$，使得 $C_i = 1$ 并且 $C_{i+1} = 0$，那么无解。因为 $i$ 和 $i+1$ 无法同时满足要求。

那么我们可以将所有数分为两段，前一段的所有数都满足 $C_i=0$，后一段的所有数都满足 $C_i=1$。这两段是相互独立的。

考虑如何做 $C_i=0$。

如果 $B_{i-1} + 1 = B_i$，那么只需要一次操作即可。

反之，如果存在最大的 $j$ 使得，$A_j - j = B_i-i$，那么需要 $i-j$ 次操作。

如果都不满足，那么无解。

$C_i=1$ 是类似的。

至此，我们解决了这个问题。

代码：

```cpp

int main () {
    ios::sync_with_stdio(false);
    cin >> n >> L;
    re(i, n) cin >> a[i];
    re(i, n) cin >> b[i];
    a[0] = b[0] = 0;
    a[n+1] = b[n+1] = L + 1;
    re(i, n) {
        pre[i] = pre[i-1];
        if(a[i] == b[i]) pre[i] = i;
    } 
    re(i, n) {
        c[i] = a[i] < b[i];
    }
    re(i, n) {
        if(pre[i] != i) vec[pre[i]].pb(i);
    }
    ll ans = 0;
    rep(u, 0, n) {
        if(vec[u].size()) {
            int m = 0;
            for(int i: vec[u]) {
                p[++m] = i;
            } 
            p[0] = u, p[m+1] = p[m] + 1;
            int id = 0;
            if(!c[p[1]]) id = 1;
            rep(i, 2, m) {
                if(c[p[i-1]] && !c[p[i]]) {
                    cout << "-1";
                    return 0;
                }
                if(!c[p[i]]) id = i;
            } 
            x.clear();
            re(i, id) {
                int w = b[p[i]];
                if(b[p[i-1]]+1 == w) {
                    ++ans;
                }
                else if(x[w-i]) {
                    ans += i - x[w-i];
                }
                else {
                    cout << "-1";
                    return 0;
                }
                x[a[p[i]]-i] = i;
            }
            x.clear();
            per(i, m, id + 1) {
                int w = b[p[i]];
                if(b[p[i+1]] - 1 == w) ++ans;
                else if(x[w-i]) {
                    ans += x[w-i] - i;
                }
                else { 
                    cout << "-1";
                    return 0;
                } 
                x[a[p[i]]-i] = i;
            }
        }
    }
    cout << ans;
}
```


---

## 作者：AC_love (赞：0)

考虑到一个企鹅一定只会一直往一个方向移动，否则必然不优。

这样我们可以把方企鹅分成三类：左移的，右移的，不动的。

不动的企鹅会把整个序列划分成很多个只包含会动的企鹅的序列。

不难发现，在一个只有会动的企鹅的序列里：一定是一个前缀的企鹅左移，剩下一个后缀的企鹅右移。否则，如果出现左面的企鹅右移，而右面的企鹅左移的情况，一定无解。

前后缀是对称的，我们只要考虑如何计算前缀企鹅左移的最少步数即可。

我们知道：平移之后的 $A$ 状态一定由多个连续段构成，形如这样：

|企鹅|企鹅|企鹅|||企鹅|企鹅||企鹅|企鹅|||
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

当我们把一个连续段的第一只企鹅归位之后，它后面的企鹅只要都左移撞上它就行了。

现在考虑如何将第一只企鹅归位。

我们只需要从这只企鹅往前枚举，寻找第一只能让它撞上去恰好落位的企鹅即可。

这个方法可以保证正确性，接下来我们要证明一下这个做法的时间复杂度。

不难发现在有解情况下，每个连续段的第一只的企鹅归位时去撞的企鹅一定只会来自于上一个连续段。这里可以用反证法证明，如果这个企鹅去撞得企鹅来自上一个连续段之前，那么它一定属于上一个连续段，这自相矛盾了。

所以均摊下来，每个点只会被枚举最多 $1$ 次，复杂度 $O(n)$。

https://atcoder.jp/contests/agc048/submissions/58150035

---


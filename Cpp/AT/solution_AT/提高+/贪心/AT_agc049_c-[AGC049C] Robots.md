# [AGC049C] Robots

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc049/tasks/agc049_c

数直線上にロボットがいます． 具体的には，各 $ i=0,1,2,\cdots,10^{100} $ について，座標 $ i $ に $ 1 $ 台のロボットがおり，ロボット $ i $ と呼ばれています．

たくさんのボールがあります． それぞれのボールには，正整数が $ 1 $ つ書いてあります． これらのボールの情報は，長さ $ N $ の整数列 $ A $ と $ B $ で表されます． 具体的には，各 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について，$ A_i $ の書かれたボールが $ B_i $ 個あります．

今からすぬけくんは，次の操作を行います．

- Step 1: $ 0 $ 個以上のボールを選び，そこに書かれている整数を，$ 1 $ 以上 $ 10^{100} $ 以下の好きな**正整数**に書き換える．（ボールごとに書き換える整数を選択できる）
- Step 2: ボールを $ 1 $ つずつ食べる．ボールを食べる順番は自由に選べる．ボールを食べるたびに，以下の操作を行う．
  
  
  - 今食べたボールに書かれた整数を $ v $ とする．ロボット $ v $ が存在するなら，それを，現在の座標より $ 1 $ 小さい座標へ移動させる．もし移動先に別のロボットがいるなら，そのロボットは破壊される．（ロボット $ v $ は無事である）

すぬけくんは，ロボット $ 0 $ が破壊されないように，すべてのボールを食べきりたいです． すぬけくんが目標を達成するために Step 1 で書き換える必要のあるボールの個数の最小値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_1\ <\ A_2\ <\ \ldots\ <\ A_N\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $

### Sample Explanation 1

$ 2 $ の書かれたボールを $ 1 $ つ選び，$ 3 $ に書き換えればよいです． その後，以下の順序でボールを食べればよいです． - $ 2 $ の書かれたボールを食べる．ロボット $ 2 $ を座標 $ 2 $ から座標 $ 1 $ へ移動させる． ロボット $ 1 $ が破壊される． - $ 3 $ の書かれたボールを食べる．ロボット $ 3 $ を座標 $ 3 $ から座標 $ 2 $ へ移動させる． - $ 3 $ の書かれたボールを食べる．ロボット $ 3 $ を座標 $ 2 $ から座標 $ 1 $ へ移動させる． ロボット $ 2 $ が破壊される． - $ 1 $ の書かれたボールを食べる．ロボット $ 1 $ はすでに破壊されているので，何もしない．

## 样例 #1

### 输入

```
3
1 2 3
1 2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4
1 3 5 7
3 1 4 1```

### 输出

```
0```

# 题解

## 作者：Jsxts_ (赞：2)

有趣的思维题。

考虑不能修改时怎么吃小球最优。对于 $a_i>b_i$ 的球，怎么吃都行，于是若按 $i$ 从小到大吃掉这些球，数轴上会有若干区间的机器人报废。此时若还有 $a_i\le b_i$ 对应的机器人没有报废，那么最终一定会有一个这样的机器人踩到 $0$。

现在要做最少的操作使得不存在这样的机器人。容易发现，我们可以通过两种方法使一个球对应机器人 $i$ 满足条件：

- 在 $a_i+1$ 的位置放一个球，这样可以先让 $a_i+1$ 的机器人踩掉 $i$，这里如果有一个 $a_i\sim a_j$ 都满足 $a\le b$ 的连续段，就在 $j+1$ 放 $j-i+1$ 个球来踩这个区间。

- 将 $a_i$ 位置的球数量减少到 $a_i-1$，使得 $i$ 不会踩到 $0$。

发现第二种方法最多用一次，并且一定在一个 $a_i\le b_i$ 的机器人上用。证明：

- 若 $i,j(i<j)$ 都用方法二，显然先让 $j$ 操作 $i$ 已经被摧毁，不需要进行操作。

- 若在一个 $a_i>b_i$ 的机器人上操作，则你可以对于所有 $\le a_i-b_i$ 的 $a_j\le b_j$ 的球，对它使用方法一。这样肯定不劣于前者。

所以，我们枚举每种 $a_i\le b_i$ 的球，对它使用方法二，并对这之后的 $a_i\le b_i$ 且没有被 $a_i>b_i$ 报废的机器人使用方法一。发现方法二的球和方法一的可以共用，于是答案取最大值即可。

$a_i\le b_i$ 且没有被 $a_i>b_i$ 报废的机器人可以离散化后用差分维护。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 2e9;
const int N = 2e5;
inline int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
int n,a[N + 10],b[N + 10],c[N * 2 + 10],h[N * 2 + 10];
int main() {
	n = read();
	for (int i = 1;i <= n;i ++ ) a[i] = h[i] = read();
	int tot = n;
	for (int i = 1;i <= n;i ++ ) {
		b[i] = read();
		if (a[i] > b[i]) h[++tot] = a[i] - b[i];
	}
	sort(h + 1,h + tot + 1);
	tot = unique(h + 1,h + tot + 1) - h - 1;
	for (int i = 1;i <= n;i ++ ) {
		if (a[i] > b[i]) {
			c[lower_bound(h + 1,h + tot + 1,a[i] - b[i]) - h] ++, c[lower_bound(h + 1,h + tot + 1,a[i]) - h + 1] --;
		}
	}
	for (int i = 1;i <= tot;i ++ ) c[i] += c[i - 1];//, cout << i << ' ' << c[i] << endl;
	int tt = 0;
	for (int i = 1;i <= n;i ++ ) {
		if (!c[lower_bound(h + 1,h + tot + 1,a[i]) - h]) tt ++;
	}
	if (!tt) cout << 0, exit(0);
	int ans = tt,tt2 = 0;
	for (int i = 1;i <= n;i ++ ) {
		if (!c[lower_bound(h + 1,h + tot + 1,a[i]) - h]) tt2 ++;
		if (a[i] <= b[i]) ans = min(ans,max(tt - tt2,b[i] - a[i] + 1));
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：Unnamed114514 (赞：0)

对于本题，建议想清楚再写，不然实现难度会很高。

对于每一个 $i$，如果 $a_i>b_i$，显然可以把它们操作完。

因为一个 $i$ 扬掉的玩意一定都 $\le a_i$，所以按照 $a_i$ 升序操作就没有问题了。

同时，这样我们会扬掉一些会导致失败的 $a_i\le b_i$。

对于剩下的 $a_i\le b_i$，有如下两种方案扬掉：

- 在 $a_i+1$ 放一个把 $a_i$ 扬掉。

- 把在 $a_i$ 的球的数量调整到 $a_i-1$。

注意到第二种操作只会进行一次，因为如果调整两次的话，后面的显然可以把前面的扬掉，前面的调整就是没必要的。

然后注意到如果 $a_i\ge 2$，有 $b_i\ge a_i\ge 2$，那么 $1$ 操作直接从 $a_i$ 搞一个球出去就行了。

如果 $a_i=b_i=1$ 呢？此时 $i$ 这个球显然要么被 $2$ 操作覆盖，要么移到别的地方去，此时相当于对 $i$ 进行 $2$ 操作。因此对 $i$ 不需要进行 $1$ 操作。

所以我们不用担心 $1$ 操作的可行性问题。

还有就是注意到 $a_i>b_i$ 的部分显然不会增加或减少 $b_i$，因为上述操作后，容易发现减少 $b_i$ 去扬掉其它的是不必要的，因为 $1$ 操作本身就合法，如果增加 $b_i$ 显然不如直接进行 $1$ 操作。

实现的话建议使用倒序，因为 $2$ 操作搞完后显然要和后面的没有被扬掉的 $a_i\le b_i$ 的数量取 $\max$。同时判断一个有没有被扬掉只需要考虑和后面的 $\min\limits_{a_i>b_i}\{a_i-b_i\}$ 比较大小即可，方便计算答案。

---


# [AGC060B] Unique XOR Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc060/tasks/agc060_b

$ N $ 行 $ M $ 列のグリッドがあります． あなたはグリッドの各マスに $ 0 $ 以上 $ 2^K-1 $ 以下の整数を書き込み，以下の条件を満たしたいです．

- 左上のマスを出発し，右または下に隣接するマスへの移動を繰り返して，右下のマスへと至るパスを考える． ここで，通ったマス (始点終点を含む) に書かれた整数の総 $ \mathrm{XOR} $ が $ 0 $ になるパスを，**よい**パスと呼ぶことにする．
- よいパスはちょうど $ 1 $ つだけ存在し，それは文字列 $ S $ が表すパスである． 文字列 $ S $ が表すパスとは，各 $ i $ ($ 1\ \leq\ i\ \leq\ N+M-2 $) について，$ i $ 回目の移動の際，$ S $ の $ i $ 文字目が `R` なら右，`D` なら下に進むようなパスである．

条件を満たす整数の書き込み方が存在するかどうか判定してください．

$ 1 $ つの入力ファイルにつき，$ T $ 個のテストケースを解いてください．

  ビット単位 $ \mathrm{XOR} $ 演算とは  非負整数 $ A,\ B $ のビット単位 $ \mathrm{XOR} $ 、$ A\ \oplus\ B $ は、以下のように定義されます。

- $ A\ \oplus\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \oplus\ 101\ =\ 110 $)。  
 一般に $ k $ 個の非負整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 $ \mathrm{XOR} $ は $ (\dots\ ((p_1\ \oplus\ p_2)\ \oplus\ p_3)\ \oplus\ \dots\ \oplus\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ の順番によらないことが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 100 $
- $ 2\ \leq\ N,M\ \leq\ 30 $
- $ 1\ \leq\ K\ \leq\ 30 $
- $ S $ はちょうど $ N-1 $ 個の `D` と $ M-1 $ 個の `R` からなる文字列
- 入力される数はすべて整数

### Sample Explanation 1

例えば $ 1 $ ケース目については，以下のようなグリッドを作れば良いです． ``` 11 00 ```

## 样例 #1

### 输入

```
4
2 2 1
RD
4 3 1
RDDDR
15 20 18
DDRRRRRRRDDDDRRDDRDRRRRDDRDRDDRRR
20 15 7
DRRDDDDDRDDDRRDDRRRDRRRDDDDDRRRDD```

### 输出

```
Yes
No
Yes
No```

# 题解

## 作者：by_chance (赞：15)

[Link](https://www.luogu.com.cn/problem/AT_agc060_b)

简要题意：在 $n \times m$ 的方格表中填入一些不超过 $2^k-1$ 的数。考虑所有从左上角到右下角的最短路径，要求其中满足路径上数异或和为 $0$ 的路径只有给定的 $S$ 一条，问是否有解。

首先，变换看问题的角度：给定 $n,m,S$，则 $k$ 应该存在一个最小值，使得问题有解（或总是无解），所以这其实是一个组合最值问题。那么考虑两个方面：证明和构造。

证明部分，我们要尽可能的增大 $k$，也就是增大所需的二进制位数。那么，考虑 $S$ 的一个拐角，如图，红线表示 $S$，蓝线表示一个调整。

![](https://cdn.luogu.com.cn/upload/image_hosting/11xtpdvq.png)

这里拐角指的是红线的拐弯处斜向相邻的这个格，即图中蓝线唯一不同与红线的格。

将红线换为蓝线之后，只改变了两个格，那么由于蓝线不能异或和为 $0$，所以这两个格至少有一位二进制不同。

这样的调整可以在若干个地方进行，设为 $t$ 个，第 $i$ 个调整会使路径的异或和改变 $v_i$。那么，不能有若干个 $v_i$ 的异或和为 $0$，即 $v_i$ 是一个线性无关组。由于 $v_i$ 定义在 $k$ 位二进制数上，所以 $t \le k$。

但是，并不是每个拐角都可以调整。准确地说，不是所有拐角都可以一起调整。请看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rkk29245.png)

图中标出了三个拐角，但是显然不能同时做 $1,2$ 的调整，也不能同时做 $1,3$ 的调整。再思考一下可以发现，其实只有这样的一种情况是特殊的，也就是有一段经过两格的，连续的若干个两格只取一侧。

如此就可以算出 $k$ 的下界，它其实就是**一条路径能够经过的拐角数目的最大值**，只是对于连续的两格比较特殊。

至于构造，思考到这里应该不太难了。方案如下：（想象一个人在表格中走，Ta要做一些决策）

1. 对于一段长度大于等于 $3$ 的直走，取新的一位，在这一段两端各添一个 $1$。这样可以使得走到这一段开头后必须走这一段结尾。

2. 对于一些长度为 $2$ 的直走，不妨设第一个 $2$ 是竖向的，那么给每一段竖向的分配一个二进制位，在这两个格上添 $1$。然后取消两端由上一条添的位。

似乎说的不太清楚？上图。

![](https://cdn.luogu.com.cn/upload/image_hosting/uy4aqykc.png)

在第二条规则下，有一些“必经之路”会被挡住，所以必须要经过所有安排的 $1$。

容易验证这个构造确实取到了前面证明的最值。


AGC 传统，思路难，代码易。请看 Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,k,cnt,x,y,lstx,lsty;
//x,y跟着路径S跑
//lstx,lsty表示上一个选中的拐角
char s[65];
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&n,&m,&k);
		scanf("%s",s+1);
		cnt=0;x=y=lstx=lsty=1;
		for(int i=1;i<n+m-2;i++){
			if(s[i]=='D')x++;else y++;
			if(s[i]!=s[i+1]){
				if(s[i]=='D'&&lstx<=x-1&&lsty<=y+1)
					cnt++,lstx=x-1,lsty=y+1;
				if(s[i]=='R'&&lstx<=x+1&&lsty<=y-1)
					cnt++,lstx=x+1,lsty=y-1;
			}
		}
		printf(cnt<=k?"Yes\n":"No\n");
	}
	return 0;
}

```

---

## 作者：do_it_tomorrow (赞：6)

[更好的阅读体验](https://www.doittomorrow.xyz/post/agc060b-unique-xor-path-de-ti-jie/)
## 题目大意
有一个 $n\times m$ 的网格，每个网格可以填 $0$ 到 $2^k-1$ 范围内的数字。现在从左上角走到右下角，每次可以选择往右边或往下走一步。如果路径上所有数字异或和为 $0$，称这样的路径为好路径。给定一条路径 $s$，$\texttt{D}$ 表示往下走，$\texttt{R}$ 表示往右走。问，是否存在一个网格，使得这条路径 $s$ 是唯一的好路径。
## 思路
考虑用最少的数字填完整个表格，假设数字范围为 $0$ 到 $2^t-1$，只要 $t\le k$，就满足情况，否则不满足情况。

对于给定的路线 $s$，异或和为 $0$，可以将路径上所有位置全部设置为 $0$。

![](https://s21.ax1x.com/2024/04/02/pFHAg2t.png)

考虑在路线 $s$ 变化 $1$ 步的路线，也就是拐角处。为了让这些路线异或和不为 $0$，分别填 $2^0,2^1,2^3\cdots$，同时在同一条斜线上填同样的数字，其余位置填 $0$。这样保证你只要走了路线 $s$ 之外的线路，在最终的异或和上都会出现新的 $1$。

![](https://s21.ax1x.com/2024/04/02/pFHA2xP.png)

但这样不是最优的，可以发现，如果出现连续的 $2$ 个拐弯，$2$ 个拐角可以填相同的数字。

![](https://s21.ax1x.com/2024/04/02/pFHAWKf.png)

同理可以模拟出 $3$ 个连续的拐角需要 $2$ 个不同的数字，
$4$ 个连续的拐角需要 $2$ 个不同的数字，如果有 $x$ 个连续的拐角，那么 $x/2$ 个不同的数组。

时间复杂度为 $O(T(n+m))$。

## AC Code
```c++
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=105;
int n,m,k;
char a[N];
void solve(){
	cin>>n>>m>>k>>a+1;
	for(int i=1;i<n+m-2;i++) if(a[i]!=a[i+1]) i++,k--;
	if(k>=0) cout<<"Yes\n";
	else cout<<"No\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	while(T--){
		solve();
	}
	return 0;
}
```

---

## 作者：Augury (赞：3)

# [AGC060B] Unique XOR Path题解

## 题意

- 给定一个 $N\times M$ 的方格地图，并且给定一条路径从左上到右下的路径 $S$。
- 要求在地图上填任意数量的，在 $[0,2^k-1]$ 之间的数字，使得有且仅有 $S$ 一条路径经过的方格的数字的异或和为 $0$。
- 问是否有合法方案。

## 做法

我们考虑求出数字最大值的最小的方案，并且将这个最大值与 $k$ 比较。如果比 $k$ 大，那么无解，输出`No`，否则输出`Yes`。

考虑使其它路径上的异或和全不为 $0$。

我们发现题目中选数的范围是 $[0,2^k-1]$，又因为异或和，显然出题人是想让我们从二进制考虑（~~废话~~）。

要使得某一条路径上的异或和不为 $0$ 只要让这条路径经过的点上有至少一个位置的 $1$ 只会被访问一次。

因此，我们认为在路径上填的数应该是 $2^i(0\le i< l)$，$l$ 表示使数字最大值的最小值小于等于 $2^l$ 的最小的 $l$。

我们要考虑求出 $l$，然后判断 $l$ 和 $k$ 的大小关系即可。

容易发现，问题容易出现在拐角处。我们只要考虑再拐角处放置数字即可。

让我们来看一张图。

![例子](https://cdn.luogu.com.cn/upload/image_hosting/m0uwivns.png)

在这里，红色是 $S$，绿色和粉色是另外两条路径。我们要想办法拦截掉这两条路径。

要拦截粉色的，显然，在 $(2,2)$ 放一个 $1$ 即可。然鹅绿色路径会绕开这个“路障”。我们就在 $(3,1)$ 放一个和  $(2,2)$ 一样的 $1$。然后我们就往左下一直放，一直放，一直放到地图边界，全放一样的 $1$。这是向下的转弯。向右的转弯在右上放即可。

但是这样会错。

我们发现，如果有两个连续的转弯，可以放同一个数。就省了不少。

那三个转弯呢？四个呢？五个呢？

我们手动模拟，发现，对于连续的转弯，设数量为 $a$，那么他会使 $l$ 加上 $\lceil \frac a2\rceil$。

对于单个的转弯，因为 $\lceil \frac12\rceil=1$，所以显然。

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
char s[100];
int tot=0,ans=0;
void real_main(){
	scanf("%d%d%d",&n,&m,&k);
	scanf("%s",s);
	tot=ans=0;
	for(int i=1;i<n+m-2;i++){
		if(s[i]!=s[i-1])++tot;
		else{
			ans+=(tot+1)/2;
			tot=0;
		}
	}
	ans+=(tot+1)/2;
	if(ans<=k)puts("Yes");
	else puts("No");
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		real_main();
	}
	return 0;
}
```

---

## 作者：AkeRi (赞：2)

# Description
略

# Solution 
妙妙按位贪心。

考虑每次对于 $\le k$ 的每一位贪心。

给定了行走的路线，则可以考虑当什么情况下需要新的一位填充，使得存在最小的解。

判断无解是容易的，当最终统计的解 $p$ 比 $k$ 要大则必然无解。

考虑求得解 $p$。设当前在网格的 $(x,y)$。贪心策略为：走完当前这一列 $x$，当且仅当走完这一列时这一行对应的位异或和为 $0$。对于同一行同理。

具体地：在每个拐弯的地方令在新的一位添加一个 $1$，也就是等同于在每个行列放的数是 $2^{p_{(x,y)}}$。因为在每一列走的格子数量一定是 $\ge 2$ 的，因此根据异或的性质必然存在一种方案使得在任意一行、一列均有一种办法不进位就可以使得一行或者一列异或和为 $0$。

接下来考虑别的路径。为了使得不存在第二条路径，对于每一列每一行不填相同数即可（可以根据官方题解理解：我们可以视为走的路径上均是 $0$，而拦截是 $2^{p}$。两者实际等价)。

如何求得解 $p$？在每一个拐角处添加一位即可。也就是说走到拐角时，令 $p\leftarrow p+1$。

代码实现比较简单，就不贴了。

---

## 作者：liangbowen (赞：0)

[blog](https://www.cnblogs.com/liangbowen/p/17840860.html)。很强的思维题。

---

如果能用 $0\sim 2^T-1$ 表示出来（$T\le k$）那么显然也可以用 $0\sim 2^k-1$ 表示出来，转化为求最小的合法填数方案 $T$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pymx0act.png)

如图所示，红色是唯一路径，黄粉色处是一个拐角。让在黄粉色拐弯的路径不合法，可以给两者填 $2^0$ 与 $2^1$，然后这个值一直往左下延申，把这一整段屏蔽掉。

类似地，每出现一个单独的拐角，$T$ 就该加一。右上部分的拐弯是同理的，可以不考虑。做完了。

[code](https://atcoder.jp/contests/agc060/submissions/47669542)，时间复杂度 $O(T(n+m))$。


---


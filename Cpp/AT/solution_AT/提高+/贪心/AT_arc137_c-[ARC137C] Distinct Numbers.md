# [ARC137C] Distinct Numbers

## 题目描述

给定长为 $N$ 的非负整数列 $A=(A_1,\dots,A_N)$，保证 $A$ 中元素互不相同。

Alice 和 Bob 在玩游戏。Alice 为先手，两人轮流操作。每次操作选手可以如下进行：

+ 选择当前 $A$ 中最大的元素，将其替换为一个更小的非负整数。要求替换后 $A$ 中元素仍然互不相同。

首先无法操作的一方失败。当两人都采取最优策略时，求谁有必胜策略。

## 说明/提示

+ $2 \le N \le 3 \times 10^5$

+ $0 \le A_1<A_2<\dots<A_N\le10^9$

#### 样例 1 解释

第一回合 Alice 可以将 $4$ 变为 $0,1,3$，如果 Alice 将 $4$ 变为 $0,1$ 中的一个，则 Bob 可以将 $2$ 变为 $0,1$ 中另一个，Alice 无法操作从而落败；如果 Alice 将 $4$ 变为 $3$，则此时 Bob 需要将 $3$ 变为 $0,1$ 中一个，同上知 Bob 必败。因此 Alice 有必胜策略。

## 样例 #1

### 输入

```
2
2 4```

### 输出

```
Alice```

## 样例 #2

### 输入

```
3
0 1 2```

### 输出

```
Bob```

# 题解

## 作者：灵茶山艾府 (赞：13)

（下标从 $1$ 开始）记 $x=a[n-1],y=a[n]$。

**情况一**：$x$ 和 $y$ 之间有空位，即 $x+1<y$。

第一回合，Alice 先试着把 $y$ 移动到 $x+1$。然后轮到 Bob，他必须将 $x+1$ 移动到一个小于 $x$ 的位置 $z$。

- 如果 Bob 没有必胜的移动方案，那么 Alice 获胜。
- 如果 Bob 移动到 $z$ 是必胜的，那么 Alice 可以「悔棋」，在第一回合，直接把 $y$ 移动到 $z$，从而必胜。

所以只要 $x+1<y$，Alice 就一定是必胜的。

**情况二**：$x$ 和 $y$ 之间没有空位，即 $x+1=y$。

通过情况一的讨论，我们知道，如果 Alice 移动后，留给 Bob 的是一个「有空位」的局面，那么 Bob 是必胜的。

因此，为了不让 Bob 必胜，Alice 必须保证，移动后，最右边的两个石子是没有空位的。对于 Bob 也同理。

因此，每回合，$\max(a)$ 只会减少 $1$。

由于游戏结束时 $\max(a)=n-1$，所以一共有 $a[n]-(n-1)$ 个回合。

因此，如果 $a[n]-(n-1)$ 是奇数，或者说 $a[n]-n$ 是偶数，那么 Alice 必胜，否则 Bob 必胜。

#### 代码（Golang）

```go
package main
import("bufio";."fmt";"os")

func main() {
	in := bufio.NewReader(os.Stdin)
	var n, x, y int
	Fscan(in, &n)
	for i := 0; i < n-1; i++ {
		Fscan(in, &x)
	}
	Fscan(in, &y)

	if x+1 < y || (y-n)%2 == 0 {
		Print("Alice")
	} else {
		Print("Bob")
	}
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n)$。
- 空间复杂度：$\mathcal{O}(1)$。


---

## 作者：Glacial_Shine (赞：5)

# 思路
我们先看最大两个点，然后我们分情况讨论。

首先假设两个点之间的距离超过 $1$，此时如果我们将最大值移到次大值加一的位置后，我们必赢，则就移过去。

如果我们必输呢？

因为我们移到次大值加一后，对方必须移到前面一个空位处，我们假设对方移到一个点 $a$ 后我们必输，则我们第一次移动就不移到次大值加一，直接移到点 $a$，此时的局面和我们移到次大值加一的位置然后对方再移到点 $a$ 是一样的，因为这个局面先手的人必败，所以我们移到点 $a$ 后对方必败。

通过上面两种情况，我们知道如果最大值和次大值之间的差大于一，则无论如何先手必胜。

我们再看看最大值和次大值之间的差等于一的时候。

因为如果我们移到一个位置使得移完后这个节点到最大值之间有空格，此时就会回到我们先前讨论的情况，这是对方是必胜的。

所以我们和对方的每次移动都得要移到前面离最大值最近的空格。

于是我们可以根据空格数来判断谁赢。

如果空格数是偶数，则最后一下是对方移动，那我们必输。

如果空格数是奇数，则最后一下是我们移动，那我们必赢。

于是我们就可以做这道题了。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
int n, m, a[3000005];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    if (a[n] - a[n - 1] > 1)
        printf("Alice");
    else {
        if ((a[n] - n) % 2)
        //a[n]-n就相当于空格数
            printf("Bob");
        else
            printf("Alice");
    }
    return 0;
}
```

---

## 作者：irris (赞：3)

## Preface

高妙博弈论。

## Solution

**key observation**：若状态 $S$ 能到达状态 $x$，且 $\forall$ 状态 $x$ 能到达状态 $y$ 都有状态 $S$ 能到达状态 $y$，则状态 $S$ 必胜。

证明：

+ 若 $x$ 是必败态，则 $S \rightarrow x$ 是必胜态；
+ 否则 $x$ 是必胜态，那么 $\exists x \rightarrow y$ 满足 $y$ 为必胜态，此时 $S \rightarrow y$ 依旧是必胜态。

在这里，注意到只要操作后的 $a_n$ 还大于 $a_{n - 1}$，取初始状态为 $S$，现状态为 $x$，符合上述 key obversation 所设。

所以，如果有 $a_n - 1 \gt a_{n - 1}$，先手必胜。

否则两个人每次都会把最大的数挪到最大的数的连续段的最后，总共会挪 $a_n - n$ 次，判断一下奇偶性即可。

---

## 作者：liangbowen (赞：2)

[blog](https://www.cnblogs.com/liangbowen/p/17796533.html)。很牛的题，想了差不多一个小时。

## 经典结论

此处 $S\to T$ 表示状态 $S$ 可以变成状态 $T$。

$\textbf{Conclusion: }$ 若 $\forall S\to T\to P$ 都有 $S\to P$，则 $S$ 为必胜态。（用中文讲：一个状态能到达它所能到达的状态所能到达的状态，则这个状态为必胜态。）

$\textbf{Prove: }$ 若 $T$ 为必败态，则 $S$ 为必胜态。若 $T$ 为必胜态，则必定 $\exists P$ 是必败态，$\because S\to P$，$\therefore S$ 是必胜态（它能到达一个必败态）。

## 思路

考虑最大值 $p$ 与次大值 $q$。先手操作 $p$，只要操作后仍然有 $p>q$，由「经典结论」，先手必胜。**所以 $q+1<p$ 时先手必胜。**

另一种情况是 $q+1=p$，由「$q+1<p$ 时先手必胜」这个结论，双方每次操作后必定是保持 $q+1=p$，所以只会将 $p$ 移动到下一个间隔处。

那么这种情况下，**间隔数奇偶性**决定了先后手谁必胜。做完了。

[code](https://atcoder.jp/contests/arc137/submissions/47070776)，时间复杂度瓶颈在排序。

---

## 作者：yyz_100110 (赞：2)

## [[ARC137C] Distinct Numbers](https://www.luogu.com.cn/problem/AT_arc137_c)

### 题目解析：
   
定义一个长度为 $N$ 的整数数列 $A$，保证 $A$ 中元素互不相同。

Alice 和 Bob 又在玩游戏，两人轮流操作，Alice 为先手。

两人轮流抽牌，抽出最大的 $A_{\max}$ 替换为比 $A_{\max}$ 小的非负整数。

### 思路解析：

两人抽牌，比谁有绝对的胜利策略，如果 Alice 有绝对胜利决策就 Alice 赢，反之则 Bob 赢，我们可以从样例中入手。

~~~
2
2 4

3
0 1 2
~~~

上面分别为题目给出的两个样例，我们可以分析一下，样例一已经分析，我们分析样例二。

一共有一个长 $3$ 的数列，$A_{\max}$ 为 $2$，$A_{\min}$ 为 $0$，假设 Alice 拿 2 并把 2 换成 0 或者 1，但是此时大家有没有发现，题目已经声明 $A$ 元素互不相同，所以第一次操作时，Alice 就已经无法操作了，所以 Bob 赢了。

### 关键理论:

- 空格数是偶数，最后一次移动是对方，必输。

- 空格数是奇数，最后一此移动是我方，必赢。

样例理解之后我们看代码，大部分人下意识会开数组，但其实这一题不用数组就可以解决，我们不断替换他们手上牌的值，上代码！

### Ac Code:
~~~cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b; //
int main(){
    cin>>n>>a>>b; 
    for(int i=1;i<=n-2;i++){
        a=b; //替换牌值
        cin>>b; //重新拿牌
    }
    return  puts(b-a>1||!(b-n & 1) ? "Alice" : "Bob"),0;//三位运算符判断，同样可以使用 if 判断
}
~~~
完整无注释，千万别抄袭！

---

## 作者：Aiopr_2378 (赞：1)

## 题目大意

给定长为 $N$ 的非负整数列 $A:a_1,a_2,\cdots a_n$，保证元素互不相同。

Alice 和 Bob 在玩游戏。Alice 为先手，两人轮流操作。每次操作选手可以如下进行：

-   选择当前 $A$ 中最大的元素，将其替换为一个更小的非负整数。要求替换后 $A$ 中元素仍然互不相同。

首先无法操作的一方失败。当两人都采取最优策略时，求谁有必胜策略。

## 解题思路

考虑每次都会将一个数减小，会有如下最优策略，记 $x$ 为最大元素， $y$ 为次大元素：

1.   若 $y+1<x$，即 $x,y$ 之间有空位。操作者可以将 $x$ 改变至大于 $y$ 或小于 $y$，从而将局面交给对方。如果其中某个操作会失败，可以选择另一个操作。因为两种操作最后交给对方的局面是对立的。
2.   若 $y+1=x$，即 $x,y$ 之间没有空位。因为每次都会减少至少 $1$，每次会填补一个空，答案就会和 $\text{mex}$ 有关系。如果有奇数个空，那么前者胜，否则前者必败。

## 参考代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define MAXN 300005
int t,n,a[MAXN];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+1+n);
    int num=0;
    for(int i=1;i<=n;i++){
        if(i==1) num+=a[i];
        else num+=a[i]-a[i-1]-1;
    }
    if((a[n]==a[n-1]+1&&(num&1))||a[n]!=a[n-1]+1) cout<<"Alice"<<endl;
    else cout<<"Bob"<<endl;
    return 0;
}
```

---

## 作者：DE_aemmprty (赞：0)

显然，当最大值为 $n - 1$ 时，无法操作。

发现最大值和次大值之间如果有间隔的话最大值有可能变一次还是最大值。假设数组已经从小到大排好序了，那么：

1. $a_{n - 1} + 1 < a_n$，此时 $a_n$ 与 $a_{n - 1}$ 有间隔。如果 Alice 选择将 $a_n$ 变成 $a_{n - 1} + 1$，那么 Bob 下一步只可以把它变成 $z$，其中 $z < a_{n - 1}$。
	* 如果这种情况 Bob 必败，那么 Alice 必胜。
    * 如果这种情况 Bob 必胜，那么 Alice 可以反悔，在刚开始就把 $a_n$ 变成 $z$，那么 Alice 还是必胜。

2. $a_{n - 1} + 1 = a_n$，此时 $a_{n - 1}$ 与 $a_n$ 之间没有间隔。如果 Alice 操作之后最大值和次大值之间有间隔，那么按照第一种情况的结论，此时 Bob 必胜。故 Alice 只会把 $a_n$ 变成当前可以变成的数中的最大值。可以发现此时最大值永远只减 $1$，那么操作的轮数可以算出来。此时轮数的奇偶决定了是 Alice 必胜还是 Bob 必胜。

以下是 AC 代码：

```cpp
void solve() {
    n = read();
    for (int i = 1; i <= n; i ++)
        a[i] = read();
    if (a[n] > a[n - 1] + 1) {
        printf("Alice\n");
    } else {
        printf((a[n] - n + 1) & 1 ? "Alice\n" : "Bob\n");
    }
}
```

---

## 作者：hmh100211 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/AT_arc137_c)

## 题意分析：

给定长为 $N$ 的非负整数列 $A=(A_1,…,A_N)$，保证 $A$ 中元素互不相同。

Alice 和 Bob 在玩游戏。Alice 为**先手**，两人轮流操作。每次操作选手可以如下进行：

选择当前 $A$ 中**最大的元素**，将其替换为一个**更小的非负整数**。

要求替换后 $A$ 中元素仍**互不相同**。

首先无法操作的一方失败。当两人都采取最优策略时，求谁有必胜策略。

数据范围为

$2 \leq N \leq 3 \times10^5$

$0 \leq A_1<A_2<⋯<A_N \leq 10^9$

正常开 `int` 即可。

### 题外话：

本蒟蒻第一眼看到这道题还以为是大模拟，然后读题读着读着发现不太对。

一看标签，贪心+博弈论，~~直接仰天长啸~~。

~~简简单单的~~思考了两个半小时后才终于有思路。

## 思路：

这道题可以首先判断最大的元素与前一个元素的差是否大于 1。

如果大于 1，说明当前的最大元素是不可操作的，也就是无论谁操作都无法改变该元素的值。那么无法操作的一方 （Bob） 失败，另一方 （Alice） 即为胜利者。

如果最大元素与前一个元素的差不大于 1，那么需要进一步观察剩余可操作次数和总元素个数的奇偶性。

如果剩余可操作次数为奇数，那么操作结束时轮到 Bob 进行最后一次操作。

如果剩余可操作次数为偶数，那么操作结束时轮到 Alice 进行最后一次操作。

最后一次操作可以让最大元素替换成一个比它小的非负整数，让对方无法再进行操作。这样最后一个元素就归属于自己。因此，最后一步的操作者有必胜策略。

#  _AC Code_ :

```c
#include <bits/stdc++.h>

using namespace std;

int n,a[3000005]; //定义变量，数组

string check(int n,int a[]) //定义函数check
{
	if (a[n]-a[n-1] > 1) return "Alice"; //最大的元素与前一个元素的差是大于1，Alice赢
	else if((a[n]-n+1)%2==1) return "Bob"; //最大元素与前一个元素的差不大于1且剩余可操作次数为奇数
	else if((a[n]-n+1)%2==0)return "Alice"; //最大元素与前一个元素的差不大于1且剩余可操作次数为偶数
}
int main()
{
	cin>>n; //读入n
	for (int i=0;i<n;i++) cin>>a[i]; //读入数组a
	cout<<check(n-1,a); //输出结果
	return 0;
}
```
# [AC](https://www.luogu.com.cn/record/113135134)

---

## 作者：ZHANGyutao123 (赞：0)

## [[ARC137C] Distinct Numbers](https://www.luogu.com.cn/problem/AT_arc137_c)

# 题目大意

- 给定长度为 $N$ 的非负整数序列 $A=\{A_1,A_2,\cdots,A_N\}$，且 $A$ 中元素互不相同。
- Alice 和 Bob 轮流操作，每次操作可以将 $A$ 中的最大值 $a_{max}$ 变为任意小于 $a_{max}$ 的非负整数，但操作后 $A$ 中的元素必须仍然互不相同。
- 当某一方无法进行操作时，它视为失败，另一方视为胜利。
- 想要获得胜利，双方都会采取最优策略。
- 求先手是否必胜。

# 思路分析

根据题意，每次操作后 $a_{max}$ 变成一个小于 $a_{max}$ 的数，所以 $A$ 最终会变成一个单调不降的序列。此外，题面给出了条件 $A$ 中元素互不相同，那么 $A$ 最终就是一个升序的非负整数序列。

考虑两种情况：

- $A$ 最后是相邻两个数 $a_{N-1}$ 和 $a_N$，此时只有将 $a_N$ 改成 $a_{N-1}+1$ 才能保证双方不失败，先手获胜；
- $A$ 最后不是相邻两个数，比如 $A=\{0,1,3,5\}$，此时先手选 $5$ 的过程相当于直接将 $5$ 变成 $2$，于是将上面的序列变为 $\{0,1,2\}$，此时该用户必败。

那么先手是否必胜，只需要判断最后是否是相邻两个数即可。

时间复杂度 $\mathcal{O}(N)$。

# 代码实现
```cpp
#include <cstdio>
using namespace std;
int n, m, a[3000005]; // 定义变量和数组

int main() {
	scanf("%d", &n); // 读入序列长度
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]); // 读入序列元素
	if (a[n] - a[n - 1] > 1) // 判断是否能化为相邻两数
		printf("Alice"); // 能化为相邻两数，先手必胜
	else {
		if ((a[n] - n) % 2) // 不能化为相邻两数，进一步判断先手是否必败
			printf("Bob"); // 先手必败
		else
			printf("Alice"); // 先手必胜
	}
	return 0;
}
```


---

## 作者：ZillionX (赞：0)

# Description

给定一个有 $n$ 个元素的集合 $a$，保证元素之间两两不同且均为非负整数。A 和 B 在对集合 $a$ 博弈，轮流操作，每次操作取出 $a$ 中最大的元素，然后将它变成一个更小的非负整数，不能破坏元素两两不同的性质。问最后胜利者是谁。

$n \le 3 \times 10^5$，时限 2s。

# Solution

怎么这场的 ABCD 题都是结论题啊……

赛时的想法是最终局面必然是 $0 \sim n-1$ 的排列，然后从这个性质入手去做，把问题简化成最初的石子取数模型，但是这样做规则很复杂，根本做不了。

而官方题解则利用了本问题的“决策包容性”，即一个状态若能到达它所能到达的状态所能到达的状态，则这个状态必然是必胜态。

利用这个性质，我们考察原问题的第一步操作。我们首先将集合中的元素从小到大排序，显然，若 $a_n-a_{n-1}>1$，则能到达 $a_1, \cdots,a_{n-1},a_{n-1}+1$ 的局面。若这个局面为必败态，则原局面必然是必胜态。若不是的话，原局面必然能到达它所能到达的必败态，因此原局面为必胜态。

对于 $a_n-a_{n-1}=1$ 的情况，容易发现先后手一定为了不输一定一直保持这个性质。不难得到此时的胜负由 $a_n-n$ 决定的结论。

# Code

```cpp
const int N=3e5+5;
int n,a[N];
int main() {
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	if (a[n]-a[n-1]>1) puts("Alice");
	else if (abs(a[n]-n)&1) puts("Bob");
	else puts("Alice");
	return 0;
}

```


---

## 作者：TillTheEnd (赞：0)

这段时间第一道没能自己想出来的题。

题意：给定 $n$ 个数，二人玩游戏，每次把全局最大数减小并改成一个当前未出现的数，不能操作者败。求胜者。

首先我们来研究一次操作时的情景。首先，当其它值不变，最大值大于次大值加一时，当前状态能走到所有最大值为次大值加一时的状态。这是一个有意思的性质，启示我们去看看最大值等于次大值加一的情景。

如果这是一个必胜态，则它能走到一个必败态，则原情况也能走到一个必败态；若这是一个必败态，则原情况可以直接走到这里。所以，原情况是必胜态。

那么情况就明晰了：当最大值大于次大值加一时，当前情况为必胜态；否则，两个人每次操作完全局最大值都等于次大值加一，这个可以直接递推找到胜者。

感觉这题的关键在这个“决策包容性”，即若一个状态能走到另一个状态能走到的所有后继状态，则这样的状态一定是必胜态。这或许是个经典结论，但我才知道。

```cpp
#include <cstdio>
using namespace std;
const int M = 300005;
int a[M], n;
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    if(a[n] - a[n-1] >= 2) {printf("Alice\n"); return 0;}
    int res = a[n] - n;
    if(res % 2 == 0) printf("Alice\n");
    else printf("Bob\n");
    return 0;
}
```

---

## 作者：_Memory (赞：0)

## 一、前言
 
这是一道博弈论的还比较水的蓝题~~就为了这个 AtCoder 炸了？~~怕社贡掉了的我花了半小时果断写了。接下来，我们来看一下解题思路。

## 二、思路

这道题分两种情况

1、最大的和第二大的距离大于一时，就可以将最大值移到比第二大的值大一的地方这样子我们一定会赢。

2、当我们移到第二个值加一的地方后，就会出现假设这种情况，那就是对手到那个点上我们必输无疑，那换位思考一下，我们移到对手能够使的我们必输的那个位置上，这样子一来，对手一定会输

**总结一个点：**只要距离大于一，先手一定会赢。

接下来直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll a[1000005],n;
string qwq(ll n,ll a[]){
	ll b=a[n]-a[n-1];
	ll c=a[n]-n+1;
	if(b>1) return "Alice";//如果距离大于一，先手一定赢
	if(c%2==0) return "Alice";//最大值与次大值之差不大于1，且剩余步数为偶数
	else return "Bob";//反之剩余步数为奇数
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i];
	cout<<qwq(n-1,a);
	return 0;
}
```



---


# [ABC005D] おいしいたこ焼きの焼き方

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc005/tasks/abc005_4

高橋君のたこ焼き屋で使っているたこ焼き器は焼く場所によって美味しさの変わるクセの強いたこ焼き器です。  
 また、店員の力量によって一度に焼けるたこ焼きの数が違います。  
 高橋君はそれぞれの店員ができるだけ美味しくたこ焼きを焼けるようにしようと思いました。  
  
 たこ焼き器は$ N×N $の正方形をしています。  
 それぞれの場所ごとにたこ焼きの美味しさ$ D_{ij} $が決まっています。  
 それぞれの店員は一度に焼けるたこ焼きの上限$ P_k $が決まっています。  
 また、一度に焼くたこ焼きは必ずたこ焼き器の長方形の部分になっていて、その中の全てを使わなければなりません。  
 それぞれの店員について一度に焼けるたこ焼きの美味しさの合計の最大値を求めて下さい。  
 ただし、店員が焼き始める時はたこ焼き器が完全に空いていてどの場所でも使えるとします。 入力は以下の形式で標準入力から与えられる。

> $ N $ $ D_{11} $ $ D_{12} $ ... $ D_{1N} $ $ D_{21} $ $ D_{22} $ ... $ D_{2N} $ $ ... $ $ D_{N1} $ $ D_{N2} $ ... $ D_{NN} $ $ Q $ $ P_1 $ $ P_2 $ $ ... $ $ P_Q $

- １行目にたこ焼き器の一辺の大きさを表す整数$ N(1≦N≦50) $が与えられます。
- 続く$ N $行にたこ焼き器のそれぞれの場所で焼けるたこ焼きの美味しさを表す整数$ D_{ij}(1≦D_{ij}≦100) $が与えられます。
- 次の行に店員の人数を表す整数$ Q $($ 1≦Q≦N^2 $)が与えられます。
- 続く$ Q $行にそれぞれの店員が焼けるたこ焼きの数を表す整数$ P_k(1≦P_k≦N^2) $が与えられます。
 
 それぞれの店員について一度に焼けるたこ焼きの美味しさの合計の最大値を出力して下さい。  
また、出力の末尾には改行を入れて下さい。$ 1≦N≦5 $を満たすテストケース全てに正解すると、$ 100 $点満点のうち $ 50 $点が与えられる。

 ```

3
3 2 1
2 2 1
1 1 1
3
1
4
9
```

 ```

3
9
14
```

- １人目の店員は左上でたこ焼きを焼くと美味しさの合計が$ 3 $になります。
- ２人目の店員は左上の2×2の範囲でたこ焼きを焼くと美味しさの合計が$ 9 $になります。
- ３人目の店員はたこ焼き器全てを使えるので美味しさの合計が$ 14 $になります。
 
 これは部分点に含まれる入力になります。 ```

3
1 1 1
1 1 1
9 9 9
1
4
```

 ```

27
```

- 一番下の列の範囲1×3でたこ焼きを焼くと美味しさの合計が$ 27 $になります。
- この店員はたこ焼きを４個焼くことができますが、３個しか焼かないほうが美味しさの合計が大きくなります。
 
 これは部分点に含まれる入力になります。

# 题解

## 作者：a_grain (赞：3)



------------
[题面](https://www.luogu.com.cn/problem/AT822)

~~说实话，这道题的时空有点大，数据也有点弱。~~

------------

这道题的翻译十分清晰，主要意思给我们一个 $N \times N$ 的方阵，再给出 $Q$ 个询问，每次询问一个 $x$，要在方阵中圈出一块**个数不大于 $x$ 的矩形**，并求出它所包含数的总和。

毫无疑问，看到 $5.00s$，我先想到了暴力。

对于每一次询问都枚举左上角的点和右上角的点，然后判断个数是否小于等于 $x$，如果小于等于 $x$，就枚举这个矩形所有的点求总和。

这样时间复杂度是 $O(n^{8} + Q)$，根本不会对。

~~果然，T 的飞起~~[T 飞](https://www.luogu.com.cn/record/74791360)

------------
其实我们可以优化求矩形总和的步骤，使其变为 $O(1)$，只需要用二维前缀和就可以了。

```cpp
a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+a[i][j];//前缀

qiu(xx,yy,x,y)=a[x][y]-a[xx-1][y]-a[x][yy-1]+a[xx-1][yy-1];//求左上角为(xx,yy) 右下角为(x,y)的矩阵总和   (a,b) a为行，b为列
```

先放一段代码：[https://www.luogu.com.cn/paste/2o3ied0j](https://www.luogu.com.cn/paste/2o3ied0j)

这时 $O(n^{6}+Q)$ 仍然会超时，但我们仍然可以优化。

~~等等，竟然被打脸了~~[这能 AC？](https://www.luogu.com.cn/record/74791550)

------------
不管数据。

我们其实不用一次次枚举小于等于 $x$ 的矩形，我们直接在询问外面预处理好一个数组 $ans_x$ 专门用来存询问为 $x$ 时的答案。

我们也发现，个数为 $x$ 的矩形行和列的长度一定是它的因数。

所以当更新 $ans_x$ 的时候，我们只要枚举行或列就行了，且能够用 $O(\sqrt{n})$ 的时间完成更新。至于更新需要枚举矩形，我们用 $f_{ij}$ 表示行的长度为 $i$，列的长度为 $j$ 时的矩形最大总和。

那么更新程序就变成了：
```cpp
for(x=1;x<=n*n;x++){
	ans[x]=ma_x;//ma_x存之前答案最大
	for(i=sqrt(x);i>=1;i--)//枚举行
		if(!(x%i)&&x/i<=n)
			ans[x]=max(ans[x],f[i][x/i]),ans[x]=max(ans[x],f[x/i][i]);//与两种情况求最大
		else if(!(x%i))break;//小优化
	ma_x=ans[x];
}
```
我们再把 $f$ 数组预处理好就行了。具体如何完成 $f$ 数组的预处理，就看下面代码的注释吧。

------------
**AC code**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,x,y,xx,yy,Q,ma_x,ans[2501],d[51][51],f[51][51];
int main(){
	cin>>n;
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			cin>>d[i][j],
			d[i][j]=d[i][j]+d[i-1][j]+d[i][j-1]-d[i-1][j-1];
	for(i=1;i<=n;i++)//枚举f数组中的i 
		for(j=1;j<=n;j++)//枚举f数组中的j 
			for(x=1;x<=n-i+1;x++)//枚举左上角的行 
				for(y=1;y<=n-j+1;y++)//枚举左上角的列 
					f[i][j]=max(f[i][j],d[x+i-1][y+j-1]-d[x-1][y+j-1]-d[x+i-1][y-1]+d[x-1][y-1]);//x+i-1为右下角的行，y+j-1为右下角的列，这边不用枚举 
	for(x=1;x<=n*n;x++){
		ans[x]=ma_x;
		for(i=sqrt(x);i>=1;i--)
			if(!(x%i)&&x/i<=n)
				ans[x]=max(ans[x],f[i][x/i]),ans[x]=max(ans[x],f[x/i][i]);
			else if(!(x%i))break;
		ma_x=ans[x];
	}
	cin>>Q;
	while(Q--){
		cin>>x;
		cout<<ans[x]<<'\n';
	}
}
```


------------
# The End.


---

## 作者：yeshubo_qwq (赞：2)

思路：

预处理出 $P_k$ 为 $1 \sim n \times n$ 时的答案。

枚举矩阵**的较小的行坐标**，**较小的列坐标**，**较大的行坐标**，**较大的列坐标**，求出总和，并在 $b$ 数组对应矩阵大小处取最大。

这样，我们就用 $b_x$ 预处理出了 $P_k$ **恰好**为 $x$ 时的答案。

但是，题目要求 $x$ **不大于** $P_k$，因此线性处理一遍取最大即可。

这里需要多次用到求二维矩阵和，可以用二维前缀和将每次求总和的时间复杂度降低到 $O\left(1\right)$。

时间复杂度约 $O\left( n^4 \right)$，可以通过此题。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,k,l,a[55][55],b[2555],Pk,T;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++)
			cin>>a[i][j],a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];//二维前缀和 
	//预处理 
	for(i=1;i<=n;i++)//较小的行坐标
		for (j=1;j<=n;j++)//较小的列坐标
			for (k=i;k<=n;k++)//较大的行坐标
				for (l=j;l<=n;l++)//较大的列坐标
					b[(k-i+1)*(l-j+1)]=max(b[(k-i+1)*(l-j+1)],a[k][l]-a[k][j-1]-a[i-1][l]+a[i-1][j-1]);
	for (i=1;i<=n*n;i++) b[i]=max(b[i-1],b[i]);
	cin>>T;
	while (T--) cin>>Pk,cout<<b[Pk]<<'\n';
	return 0;
}
```


---


# [ABC013D] 阿弥陀

## 题目描述

你知道从古至今传承下来的日本传统抽签方法——鬼脚图（日语：阿弥陀籤/あみだくじ）吗？

进行鬼脚图时，首先画出 $N$ 条平行的竖线。接着，在这些竖线之间画 $M$ 条横线。每条横线必须连接相邻的两条竖线，且不能有两条或更多的横线在完全相同的高度上。假设从上往下数的第 $i$ 条横线连接了从左往右数的第 $A_i$ ($1\le A_i < N$) 条竖线和第 $A_i + 1$ 条竖线。

以下是 $N = 5,M = 7,A = \{1,4,3,4,2,3,1\}$ 情况下的鬼脚图示例。抽签时，从某条竖线的顶部出发，沿着线向下走。当遇到横线时，必须转弯，且不能回头向上。例如，在这个鬼脚图中，从左往右数第 $4$ 条竖线顶部开始，最终会到达左边数第 $3$ 条竖线的底部。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc013_4/287d97cea4ffe55ad2fe3822a307197d29129150.png)

以上是普通的鬼脚图。然而，在“大数据”这一术语流行的当下，鬼脚图若想在未来继续存在下去，也需要“大”起来，以迎战“大数据”。

因此，我们考虑通过将多个鬼脚图**纵向连接 $D$ 次**，构造一个巨大的鬼脚图。例如，将上面提到的鬼脚图纵向连接 $2$ 次，可以得到如下示例。在这种情况下，从左边数第 $4$ 条竖线顶部开始抽签，最终会到达左边数第 $5$ 条竖线的底部。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc013_4/ff270a32cd6de8309812dd03feb2e11021ca985c.png)

虽然我们构造了如此巨大的鬼脚图，但如果无法高效计算抽签的结果，这个巨大的鬼脚图也不过是徒有其表的涂鸦。因此，请编写一个程序，对于满足 $1\le k\le N$ 的每个整数 $k$，计算在巨大鬼脚图中，从左边数第 $k$ 条竖线顶部开始抽签，最终会到达左边数第几条竖线底部。

## 样例 #1

### 输入

```
5 7 1
1 4 3 4 2 3 1```

### 输出

```
4
2
5
3
1```

## 样例 #2

### 输入

```
5 7 2
1 4 3 4 2 3 1```

### 输出

```
3
2
1
5
4```

## 样例 #3

### 输入

```
10 20 300
9 1 2 5 8 1 9 3 5 6 4 5 4 6 8 3 2 7 9 6```

### 输出

```
3
7
2
4
5
9
6
1
8
10```

# 题解

## 作者：rui_er (赞：10)

闲话：这是 AtCoder 宣传片里的题，被我找到了！

先考虑 $D=1$，明显可以 $O(M)$ 模拟预处理出在最上面的每个位置往下走会走到什么位置，之后每次就可以 $O(1)$ 查询了。

当 $D>1$ 时，可以依赖预处理的数据每次 $O(D)$ 暴力查询。又注意到每次对所有位置进行的变换操作是一样的，可以倍增后用类似快速幂的方法优化到 $O(\log D)$。

时间复杂度 $O(M+N\log D)$。

核心代码：

```cpp
//By: OIer rui_er
#define rep(x, y, z) for(int x = (y); x <= (z); ++x)
#define per(x, y, z) for(int x = (y); x >= (z); --x)

const int N = 2e5 + 5;

int n, m, d, a[N], p[N], f[30][N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> m >> d;
    rep(i, 1, m) cin >> a[i];
    rep(i, 1, n) p[i] = i;
    rep(i, 1, m) swap(p[a[i]], p[a[i] + 1]);
    rep(i, 1, n) f[0][p[i]] = i;
    rep(j, 1, 29) rep(i, 1, n) f[j][i] = f[j - 1][f[j - 1][i]];
    rep(i, 1, n) {
        int u = i;
        per(j, 29, 0) if((d >> j) & 1) u = f[j][u];
        cout << u << endl;
    }
    return 0;
}
```

---


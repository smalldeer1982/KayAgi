# [ABC015D] 高橋くんの苦悩

## 题目描述

# 题目大意

你有 $N$ 个物品，第 $i$ 个物品的重量为 $A_i$ ，体积为 $1$ ，价值为 $B_i$ ，你还有一个背包，背包的容积为 $K$ ，所能承受的最大重量为 $W$ ，现在你要将一些物品放入背包中，求放入背包的物品的最大价值。

## 样例 #1

### 输入

```
10
3 2
4 20
3 40
6 100```

### 输出

```
140```

## 样例 #2

### 输入

```
10
5 4
9 10
3 7
3 1
2 6
4 5```

### 输出

```
18```

## 样例 #3

### 输入

```
22
5 3
5 40
8 50
3 60
4 70
6 80```

### 输出

```
210```

# 题解

## 作者：a_blue_cell (赞：4)

知识点：**二维费用背包**。

根据翻译可知，这道题其实基本上就是一道二维背包的板子题，这里简单介绍一下**二维费用背包**。

首先，对于背包问题，我们必然是要用 dp 解决的。

定义状态`dp[i][j][k]`表示用前 $i$ 件物品装入所能承受的最大重量为 $j$ ，容积为 $k$ 的背包的最大价值。

对于所有的背包问题，我们都有**选与不选**两种情况。

如果不选第 $i$ 件物品，那么，就有`dp[i][j][k]=dp[i-1][j][k]`。

如果选择第 $i$ 件物品，那么，由于第 $i$ 件物品的重量为`a[i]`，体积为 $1$ ，所以`dp[i][j][k]=dp[i-1][j-a[i]][k-1]+b[i]`。

两者取最大值，就有`dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-a[i]][k-1]+b[i])`。

但是，这里的三维数组实际上是可以省掉一维的，所以，最终的状态转移方程式为`dp[i][j]=max(dp[i][j],dp[i-a[k]][j-1]+b[i])`

具体的小细节见代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,x,y;
int a[55],b[55],dp[10005][55];
int main(){
	scanf("%d%d%d",&x,&n,&y);			//输入很奇怪，输入顺序为：背包所能承受的最大重量，物品数量，背包容积
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);			
	}
	for(int i=1;i<=n;i++){
		for(int j=x;j>=a[i];j--){			//由于我们使用的二维数组，而非三维，所以需要倒着枚举，避免出现叠加的状况
			for(int k=y;k>=1;k--){
				dp[j][k]=max(dp[j][k],dp[j-a[i]][k-1]+b[i]);
			}
		}
	}
	printf("%d",dp[x][y]);
	return 0;
}
```

---


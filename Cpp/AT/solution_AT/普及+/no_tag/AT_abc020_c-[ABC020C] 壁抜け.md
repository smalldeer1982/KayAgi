# [ABC020C] 壁抜け

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc020/tasks/abc020_c

正方形のマスが縦 $ H $ 行、横 $ W $ 列に並んでいます。各マスは白または黒で塗られており、白マスのうち $ 2 $ つがそれぞれスタート地点とゴール地点として指定されています。

高橋君はスタート地点から出発して $ T $ 秒以内にゴール地点に到着したいです。高橋君は、各マスから上下左右に隣接する別のマスに移動することができます。このとき、移動先が白マスであれば $ 1 $ 秒、黒マスであれば $ x $ 秒の時間がかかります（移動前のマスの色は移動時間に影響しません）。ここで、 $ x $ の値は高橋君がスタート地点から出発する前にあなたに選んでもらいます。 $ x $ の値は正整数でなければならず、高橋君の出発後に値を変更することはできません。

高橋君が $ T $ 秒以内にゴール地点に到着することが可能であるような正整数 $ x $ の最大値を求めてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 40 $ 点分のテストケースは $ 2 $ $ ≦ $ $ H, $ $ W $ $ ≦ $ $ 3, $ $ 2 $ $ ≦ $ $ T $ $ ≦ $ $ 30 $ を満たす。
- 別の $ 30 $ 点分のテストケースは $ 2 $ $ ≦ $ $ T $ $ ≦ $ $ 30 $ を満たす。

（※ 問題 D にも部分点が設定されています。そちらもご確認ください。）

### Sample Explanation 1

$ i $ 行 $ j $ 列目のマスを $ (i,\ j) $ で表します。 $ x\ =\ 8 $ のとき、 $ (1,\ 1)\ →\ (2,\ 1)\ →\ (2,\ 2)\ →\ (2,\ 3) $ と移動すると $ 1\ +\ 8\ +\ 1\ =\ 10 $ 秒でゴール地点に到着することができます。 $ x\ \geq\ 9 $ のとき、 $ 10 $ 秒以内にゴール地点に到着することはできません。

### Sample Explanation 2

スタート地点から右に直進すると $ 2x\ +\ 1 $ 秒でゴール地点に到達できます。遠回りすることで黒マスへの移動回数を減らすことができますが、 $ x $ の値によってはかえって時間がかかってしまいます。

## 样例 #1

### 输入

```
2 3 10
S##
.#G```

### 输出

```
8```

## 样例 #2

### 输入

```
3 4 7
S##G
.##.
..#.```

### 输出

```
3```

## 样例 #3

### 输入

```
4 4 1000000000
S###
####
####
###G```

### 输出

```
199999999```

# 题解

## 作者：osfly (赞：3)

本题二分 + 搜索。

我们可以先二分出 $x$ 可能的值，再用搜索检验这个答案是否满足要求。若满足，左端点右移，否则右端点左移。

至于搜索可以用记搜加速。

注意输出要换行，否则会 WA。

```cpp
#include<cstdio>
#include<cstring>
int n,m,t;
char map[20][20];
int sx,sy;
int ex,ey;
long long dp[20][20];//dp[i][j] 表示从起点到 (i,j) 的最短距离
int l,r,mid;
int nxtx[4]={0,0,1,-1};
int nxty[4]={1,-1,0,0};
int ans;
void dfs(int x,int y,long long dis)
{
	if(dis>=dp[x][y]) return ;
	dp[x][y]=dis;
//	printf(".%d %d\n",x,y);
	if(x==ex&&y==ey)
	{
//		printf("!%d\n",dp[x][y]);
		return ;
	}
	for(int i=0;i<4;i++)
	{
		int nx=x+nxtx[i];
		int ny=y+nxty[i];
		if(nx<1||nx>n||ny<1||ny>m) continue;
		dfs(nx,ny,dis+(map[nx][ny]=='.'?1:mid));
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf(" %c",&map[i][j]);
			if(map[i][j]=='S') sx=i,sy=j,map[i][j]='.';
			if(map[i][j]=='G') ex=i,ey=j,map[i][j]='.';//注意起点和终点都是白格
		}
	l=1,r=t;//二分，常规操作
	while(l<=r)
	{
		memset(dp,0x3f,sizeof(dp));//记得初始化
		mid=(l+r)>>1;
//		printf("%d\n",mid);
		dfs(sx,sy,0);
		if(dp[ex][ey]<=t) ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%d\n",ans);//注意换行
	return 0;
}
```

---


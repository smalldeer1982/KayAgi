# [ABC027C] 倍々ゲーム

## 题目描述

高桥君和青木君通过以下的双人游戏决定胜负。

给定正整数 $N$ 并将变量 $x$ 初始化为 $1$ 。从高桥君开始，高桥君和青木君交替操作，将 $x$ 的值换成 $2x$ 或 $2x+1$ 。

当 $x$ 比 $N$ 大的时候游戏结束，最后进行操作的人输。

两个人均以最优策略进行操作，问谁会赢。

## 样例 #1

### 输入

```
1```

### 输出

```
Aoki```

## 样例 #2

### 输入

```
5```

### 输出

```
Takahashi```

## 样例 #3

### 输入

```
7```

### 输出

```
Aoki```

## 样例 #4

### 输入

```
10```

### 输出

```
Takahashi```

## 样例 #5

### 输入

```
123456789123456789```

### 输出

```
Aoki```

# 题解

## 作者：什么叫中二呀 (赞：4)

上个月交了半天都不对，某天又翻到就做了一遍，把之前代码改成位运算就A了……
## 进入正题
看题先看数据范围，$N<1e18$,嗯,$log_N$算法.

看完题我们来看一下怎么做.

通过摸(xia)索(cai)可以发现，当一个数能变换到的两个点均是必胜态(说白了就是肯定赢)时,这个数就是必败态(说白了就是肯定输),否则这个点就是必胜态.

由于$N<1e18$,所以我们不能递推，否则TLE+MLE.

正确做法是记录每变换一个状态的最大值.

(下面是分析过程,L表示必败态,W表示必胜态)
***
```cpp
 W L···L
N/2    N(N%2==0)

 W L···L
N/2    N(N%2==1)

 L W···W
N/2    N(N%2==1)

 L W···W L
  N/2  N(N%2==0)
```
***
可以看出,除了当N%2==0并且当前状态是必胜态时,要将N多减去1,其他情况将N/2,状态变换一下即可.

代码:
***
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long int N;bool x=0;
	string a[2]={"Takahashi\n","Aoki\n"};
	cin>>N;
	while(N)
	{
		if(!(N&1)&&x)N=(N>>1)-1;
		else N>>=1;
		x=!x;
	}
	cout<<a[x];
	return 0;
}
```
***

---

## 作者：Boeing (赞：2)

实际上就是每次对 $X$ 左移 1 并考虑是否把最后一位变成 1

(1). 若 $X$ 的最高位 1 比 $N$ 的最高位 1 小，那么 $X$ 一定小于 $N$；

(2). 若 $X$ 的最高位 1 比 $N$ 的最高位 1 大，那么 $X$ 一定大于 $N$；

(3). 若 $X$ 的最高位 1 和 $N$ 的最高位 1 相等，则需要特判；

现在称使 $X$ 的最高位 1 与 $N$ 的最高位 1 相等的最后的这次左移操作称作**对齐**，**执行该操作的为甲**。

因为(1)，在对齐前，游戏肯定不会结束。因为(2)，若对齐操作没有使游戏结束，那么下一步操作一定使游戏结束。换句话说，若甲进行的这次对齐使 $X$ 大于 $N$ ,那么甲输掉比赛，否则乙输掉比赛，所以我们的重点放在这次对齐操作上。

两人都尽最大努力，甲希望对齐时 $X$ 尽可能小，乙希望对齐时 $X$ 尽可能大，所以甲每次都会使 $X\times 2$ ，而乙每次会使 $X\times 2 + 1$ ，这样就会构建出一个在对齐时最优的 $X$ ，它的二进制为 1010......1010 或是 11010......1010 ，最高位 1 与 $N$ 的最高位 1 相等，且显然当最高位在偶数位时是前者，最高位在奇数位时是后者，所以我们只需要构造出一个二进制长这样的数和 $N$ 比大小，判断甲会不会输，再判断一下甲是谁就可以了。

 _code:_ 
 ```cpp
#include<stdio.h>
unsigned long long n,o;int s; //s表示n的最高位1在第几位，o则是一个前s位都是1的数，为了取出一个数的前s位 
int main(void)
{
	scanf("%lld",&n);
	for(;n>>s;s++,o=o<<1|1);
	if((((0xaaaaaaaaaaaaaaaallu&o)|(1llu<<(s-1)))>n)^(!(s&1))) printf("Takahashi\n");
	else printf("Aoki\n");
 } 
```
样例解释：

样例2， $N = 5$ ，二进制为 101 ，我们构造出来的 $X$ 为 110，故 $X > N$ ，甲会输，而最后进行对齐操作的甲是Aoki，所以赢的是Takahashi

样例5，$N$ 的二进制为 110110110100110110100101110101100110100000101111100010101，共57位，我们构造出的 $X$ 为110101010...1010 ，故 $X < N$ ,所以甲会赢，而最后进行对齐的是Aoki，所以赢的是Aoki

---


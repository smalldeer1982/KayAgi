# [ABC104C] All Green

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc104/tasks/abc104_c

プログラミングコンペティションサイト *AtCode* は、アルゴリズムの問題集を提供しています。 それぞれの問題には、難易度に応じて点数が付けられています。 現在、$ 1 $ 以上 $ D $ 以下のそれぞれの整数 $ i $ に対して、$ 100i $ 点を付けられた問題が $ p_i $ 問存在します。 これらの $ p_1\ +\ …\ +\ p_D $ 問が AtCode に収録された問題のすべてです。

AtCode のユーザーは *総合スコア* と呼ばれる値を持ちます。 ユーザーの総合スコアは、以下の $ 2 $ つの要素の和です。

- 基本スコア: ユーザーが解いた問題すべての配点の合計です。
- コンプリートボーナス: $ 100i $ 点を付けられた $ p_i $ 問の問題すべてを解いたユーザーは、基本スコアと別にコンプリートボーナス $ c_i $ 点を獲得します $ (1\ <\ =\ i\ <\ =\ D) $。

AtCode の新たなユーザーとなった高橋くんは、まだ問題を $ 1 $ 問も解いていません。 彼の目標は、総合スコアを $ G $ 点以上にすることです。 このためには、少なくとも何問の問題を解く必要があるでしょうか？

## 说明/提示

### 制約

- $ 1\ <\ =\ D\ <\ =\ 10 $
- $ 1\ <\ =\ p_i\ <\ =\ 100 $
- $ 100\ <\ =\ c_i\ <\ =\ 10^6 $
- $ 100\ <\ =\ G $
- 入力中のすべての値は整数である。
- $ c_i,\ G $ はすべて $ 100 $ の倍数である。
- 総合スコアを $ G $ 点以上にすることは可能である。

### Sample Explanation 1

この場合、AtCode には $ 100 $ 点を付けられた問題が $ 3 $ 問、$ 200 $ 点を付けられた問題が $ 5 $ 問あります。$ 100 $ 点の $ 3 $ 問をすべて解いた際のコンプリートボーナスは $ 500 $ 点、$ 200 $ 点の $ 5 $ 問をすべて解いた際のコンプリートボーナスは $ 800 $ 点です。高橋くんの目標は総合スコアを $ 700 $ 点以上にすることです。 目標を達成する方法の一つは、$ 200 $ 点問題を $ 4 $ 問解いて $ 800 $ 点の基本スコアを得ることです。しかし、$ 100 $ 点問題を $ 3 $ 問すべて解くと、基本スコア $ 300 $ 点に加えてコンプリートボーナスの $ 500 $ 点が与えられて総合スコアが $ 800 $ 点となり、より少ない問題数で目標を達成することができます。

### Sample Explanation 2

入力例 1 と似たケースですが、今回の高橋くんの目標は $ 2000 $ 点以上です。この場合、$ 200 $ 点の $ 5 $ 問は必ずすべて解かなければならず、さらに $ 100 $ 点問題を $ 2 $ 問解くことで総合スコアが $ 2000 $ 点となります。

### Sample Explanation 3

ふたたび入力例 1 と似たケースですが、今回の高橋くんの目標は $ 400 $ 点以上です。この場合、$ 200 $ 点問題を $ 2 $ 問解くだけで目標を達成できます。

### Sample Explanation 4

$ 500 $ 点の問題が $ 1 $ 問しか存在しませんが、このような場合でもその問題を解くことでコンプリートボーナスが与えられます。

## 样例 #1

### 输入

```
2 700
3 500
5 800```

### 输出

```
3```

## 样例 #2

### 输入

```
2 2000
3 500
5 800```

### 输出

```
7```

## 样例 #3

### 输入

```
2 400
3 500
5 800```

### 输出

```
2```

## 样例 #4

### 输入

```
5 25000
20 1000
40 1000
50 1000
30 1000
1 1000```

### 输出

```
66```

# 题解

## 作者：Zachary_Cloud (赞：5)

对于这道题，我们考虑 DP。

理由：

题目数据范围：

- $1 \le D \le 10$

- $1 \le p_i \le 100$

（组数不超过 $10$ 组且 $p_i$ 这么小，~~良心出题人~~）

那么，DP 怎么实现呢？

我们定义一个数组 $dp_{i,j}$，表示在前 $i$ 套题目范围内，做了 $j$ 题，所能得的最大分值。

具体说明见以下代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int d, p[20], c[20], dp[20][1010], g, ans;
int main() {
	cin >> d >> g;
	for (int i = 1; i <= d; ++i) {cin >> p[i] >> c[i]; ans += p[i];}
	//ans 表示题目的总数
	for (int i = 1; i <= d; ++i) //枚举 1 到 d 套题目
		for (int j = 0; j <= p[i]; ++j) //枚举对于前 i-1 套题目，又新做在第 i 套的 j 套题目
			for (int k = 0; k <= ans - j; ++k) //枚举前 i-1 套做的题目数
				if (j != p[i]) dp[i][j+k] = max(dp[i][j+k], dp[i-1][k] + j*i*100); //分两种情况讨论：第一种是没有做完第 i 套的题目，也就是说不能获得第 i 套题目的加分
				else dp[i][j+k] = max(dp[i][j+k], dp[i-1][k] + j*i*100 + c[i]); //第二种情况是做完第 i 套的题目
	for (int i = 0; i <= ans; ++i) if (dp[d][i] >= g) {cout << i << endl; return 0;} //暴力枚举做的题目数，如果比目标值大，则输出
	return 0;
}
```

---

## 作者：_edge_ (赞：1)

写 AT 的时候碰到了这道 DP 题。

性质非常显然，不过状态是要优化考虑将答案作为状态。

设 $f_i$ 表示做了 $i$ 道题目可以得到的最多分数。

然后考虑奖金，就是做完 $a_i$ 道题目。

转移方程式为：

若 $j=a_i$ 那么 $f_i=\max(f_{i-j}+j \times i \times 100+b_i)$。

否则的话，$f_i=\max(f_{i-j}+j \times i \times 100)$。

最后枚举一下答案就可以了。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int INF=1005;
int n,g,f[INF],a[INF],b[INF];
signed main()
{
        scanf("%d %d",&n,&g);
        for (int i=1; i<=n; i++)
                scanf("%d %d",&a[i],&b[i]);
        for (int i=1; i<=n; i++) {
                for (int j=1000; j>=0; j--) {
                        for (int k=min(j,a[i]); k>=0; k--) {
                                f[j]=max(f[j],f[j-k]+k*i*100+((k==a[i]) ? b[i] : 0));
                        }
                }
                // cout<<f[1]<<"\n";
        }
        for (int i=0; i<=1000; i++) {
                if (f[i]>=g) {
                        cout<<i<<"\n";
                        return 0;
                }
        }
        return 0;
}

```


---

## 作者：Otomachi_Una_ (赞：1)

观察到这题的 $D$ 较小，考虑 $2^n$ 的算法，即 dfs 。

其实这道题要用贪心，如果做了某个题单的就必须先把它做完，最后再找分值最大的题目填充不足。

用 $used_i$ 记录分值为 $i$ 的题是否刷光，用 dfs 进行搜索 $used$ ，再用 calc 函数计算补充即可。

## _code_

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
const int MAXN=11;
const int MR=1e2+5;
int d,g;
int p[MAXN];
int c[MAXN];
bool used[MAXN]={0};//是否使用
int ans=1e9;
int calc(int s){//返回至少还要做少提
	for(int i=d;i>=1;i--)
		if(!used[i]){
			if(g-s>=p[i]*i*100) return 1e9;//如果最大做不完，返回无穷大
			else return ceil((g-s)/(i*100.0));
		}
	return 1e9;
}
void dfs(int t,int s,int n){//搜索层，分值和，题目个数
	if(s>=g){
		ans=min(ans,n);
		return;
	}//总分达到，停止搜索
	ans=min(ans,n+calc(s));//停止AK题单，单做题
	if(t>d) return;
	used[t]=false;
	dfs(t+1,s,n);//不做
	used[t]=true;
	dfs(t+1,s+p[t]*100*t+c[t],n+p[t]);//做
}
int main(){
	cin>>d>>g;
	for(int i=1;i<=d;i++)
		cin>>p[i]>>c[i];
	dfs(1,0,0);
	cout<<ans;
	return 0;
}
```


---


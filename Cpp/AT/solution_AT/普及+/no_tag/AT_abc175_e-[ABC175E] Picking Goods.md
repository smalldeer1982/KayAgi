# [ABC175E] Picking Goods

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc175/tasks/abc175_e

$ R $ 行 $ C $ 列に並んだマス目に $ K $ 個のアイテムが置いてあります。$ 1\ \leq\ i\ \leq\ R $ 行目、 $ 1\ \leq\ j\ \leq\ C $ 列目のマスを $ (i,\ j) $ と表すとき、$ i $ 番目のアイテムはマス $ (r_i,\ c_i) $ に存在し、その価値は $ v_i $ です。

高橋君はマス $ (1,\ 1) $ からスタートしてゴールのマス $ (R,\ C) $ まで移動します。高橋君はマス $ (i,\ j) $ にいるとき、次には (存在すれば) マス $ (i\ +\ 1,\ j) $ またはマス $ (i,\ j\ +\ 1) $ に移動することができます。

高橋君は通ったマス (スタートとゴールも含む) のアイテムを拾うことができます。ただし、マス目の同じ行では $ 3 $ 個までしかアイテムを拾うことができません。通ったマスにアイテムがある場合に、そのアイテムを拾わないことはできます。

高橋君が拾うことのできるアイテムの価値の合計としてありうる値の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ R,\ C\ \leq\ 3000 $
- $ 1\ \leq\ K\ \leq\ \min(2\ \times\ 10^5,\ R\ \times\ C) $
- $ 1\ \leq\ r_i\ \leq\ R $
- $ 1\ \leq\ c_i\ \leq\ C $
- $ (r_i,\ c_i)\ \neq\ (r_j,\ c_j)\ (i\ \neq\ j) $
- $ 1\ \leq\ v_i\ \leq\ 10^9 $
- 入力は全て整数である

### Sample Explanation 1

移動の方法は以下の $ 2 $ 通りあります。 - マス $ (1,\ 1) $ 、マス $ (1,\ 2) $、マス $ (2,\ 2) $ の順に移動する。このとき拾うことのできるアイテムの価値の合計は $ 3\ +\ 5\ =\ 8 $ である。 - マス $ (1,\ 1) $ 、マス $ (2,\ 1) $、マス $ (2,\ 2) $ の順に移動する。このとき拾うことのできるアイテムの価値の合計は $ 3\ +\ 4\ =\ 7 $ である。 よって、高橋君が拾うことのできるアイテムの価値の合計としてありうる値の最大値は $ 8 $ です。

### Sample Explanation 2

$ 1 $ 行目にアイテムが $ 4 $ 個あります。次のように移動してアイテムを拾う方法が最適です。 - マス $ (1,\ 1) $ 、マス $ (1,\ 2) $、マス $ (1,\ 3) $、マス $ (1,\ 4) $ 、マス $ (2,\ 4) $、マス $ (2,\ 5) $ の順に移動する。このうちマス $ (1,\ 2) $ にあるアイテムのみ拾わないことにすると、アイテムの価値の合計は $ 3\ +\ 4\ +\ 2\ +\ 20\ =\ 29 $ である。

## 样例 #1

### 输入

```
2 2 3
1 1 3
2 1 4
1 2 5```

### 输出

```
8```

## 样例 #2

### 输入

```
2 5 5
1 1 3
2 4 20
1 2 1
1 3 4
1 4 2```

### 输出

```
29```

## 样例 #3

### 输入

```
4 5 10
2 5 12
1 5 12
2 3 15
1 2 20
1 1 28
2 4 26
3 2 27
4 5 21
3 5 10
1 3 10```

### 输出

```
142```

# 题解

## 作者：wwqwq (赞：3)

动态规划题。

考虑设置状态，$f_{i,j,l}$ 表示在第 $i$ 行，第 $j$ 列，当前行取 $l$ 个物品能取到的价值的最大值。

接下来考虑状态转移：

考虑第 $i$ 行，第 $j$ 列的物品拿还是不拿。

若拿，则 $f_{i,j,l}=\max(f_{i,j,l},f_{i,j-1,l-1}+w_{i,j})$，$f_{i,j,1}=\max(f_{i,j,1},f_{i-1,j,p}+w_{i,j})(p \in [0,3])$。其中 $w_{i,j}$ 为该格子内的物品价值。

若不拿，则 $f_{i,j,l}=\max(f_{i,j,l},f_{i,j-1,l})$，$f_{i,j,0}=\max(f_{i,j,0},f_{i-1,j,p})(p \in [0,3])$。

最终答案即为 $\max(f_{r,c,0},f_{r,c,1},f_{r,c,2},f_{r,c,3})$。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

int w[3005][3005];
int f[3005][3005][5];

signed main() {
	int r, c, k;
	cin >> r >> c >> k;
	for (int i = 1; i <= k; i++) {
		int x, y, z;
		cin >> x >> y >> z;
		w[x][y] = z;//将物品价值转移到格子上，方便调用
	}
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			for (int l = 0; l <= 3; l++) {
				if (w[i][j] != 0 && l != 0) {//拿
					f[i][j][l] = max(f[i][j][l], f[i][j - 1][l - 1] + w[i][j]); 
					
					f[i][j][1] = max(f[i][j][1], f[i - 1][j][0] + w[i][j]); 
					f[i][j][1] = max(f[i][j][1], f[i - 1][j][1] + w[i][j]); 
					f[i][j][1] = max(f[i][j][1], f[i - 1][j][2] + w[i][j]); 
					f[i][j][1] = max(f[i][j][1], f[i - 1][j][3] + w[i][j]); 
				}
				//不拿 
				f[i][j][0] = max(f[i][j][0], f[i - 1][j][0]); 
				f[i][j][0] = max(f[i][j][0], f[i - 1][j][1]); 
				f[i][j][0] = max(f[i][j][0], f[i - 1][j][2]); 
				f[i][j][0] = max(f[i][j][0], f[i - 1][j][3]); 
				
				f[i][j][l] = max(f[i][j][l], f[i][j - 1][l]);
			}
		}
	}
	cout << max(max(f[r][c][0], f[r][c][1]), max(f[r][c][2], f[r][c][3])) << endl;
	return 0;
}
```

---

## 作者：shaozhehan (赞：3)

[原题连接](https://www.luogu.com.cn/problem/AT_abc175_e)

[Atcoder 链接](https://atcoder.jp/contests/abc175/tasks/abc175_e?lang=ja)


乍一看这就是一个简单的动态规划问题题，但是“每行最多取三个物品”这个条件怎么处理呢？

答案很简单：升维。

第一步：弄清状态表示。

$dp(i, j, k)$ 表示走到 $i$ 行 $j$ 列时，这行取走了 $k$ 个物品。
另外请注意：不开 long long 会炸精度。

第二步：赋值初始状态。

$dp$ 数组全部初始化为 $0$ 即可。
```cpp
memset(dp, 0, sizeof(dp));
```
第三步：列出状态转移方程。

我们先看一下要分几种状态考虑：

- 从上面走过来，取当前物体。

从上面走过来，换了一行，所以应该取完三个后回来。
```cpp
dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][3] + a[i][j]);
```

- 从上面走过来，不取当前物体。

注意：根据贪心逻辑，你从上面下来，每行必须取三个的限制没有了，为什么不取呢？所以这种情况直接舍弃，并不用考虑。

- 从左面走过来，取当前物体。

从左边过来，仍然有每行取三个的限制，且之前只能取状态表示中 $k-1$ 个物品，所以可得状态转移方程：
```cpp
dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + a[i][j]);
```

- 从左面走过来，不取当前物体。

这种情况可以直接从左边转移，得到：
```cpp
dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k]);
```

综上，四种情况都考虑完了，dp 代码就不难写了。
```cpp
//码风清奇+无压行
#include <iostream>
#include <algorithm>
using namespace std; 

int a[3001][3001];
long long dp[3001][3001][4];//注意！这里必须开long long

int main(){
    cin.tie();
    cout.tie();
    ios::sync_with_stdio(false);//优化cin cout
    //dp数组定义在主函数外面，所以初始值默认为0
    int R, C, K, r, c, v;
    cin >> R >> C >> K;
    for (int i = 1; i <= K; i++){
        cin >> r >> c >> v;
        a[r][c] = v;//标记物体价值
    }
    for (int i = 1; i <= R; i++){
        for (int j = 1; j <= C; j++){
            for (int k = 1; k <= 3; k++){
                dp[i][j][k] = max(dp[i - 1][j][3] + a[i][j], max(dp[i][j - 1][k], dp[i][j - 1][k - 1] + a[i][j]));//状态转移
            }
        }
    }
    cout << max(dp[R][C][1], max(dp[R][C][2], dp[R][C][3])) << "\n";//三种情况比较并输出
    return 0;
}
```

- - -

优化：将 $dp$ 数组降维。

不难发现，状态转移方程中 $dp$ 数组的第一维只有 $i$ 和 $i-1$，所以可以用滚动数组的方式强行把第一维删掉。

优化后的代码：
```cpp
#include <iostream>
#include <algorithm>
using namespace std; 

int a[3001][3001];
long long dp[3001][4];

int main(){
    cin.tie();
    cout.tie();
    ios::sync_with_stdio(false);
    int R, C, K, r, c, v;
    cin >> R >> C >> K;
    for (int i = 1; i <= K; i++){
        cin >> r >> c >> v;
        a[r][c] = v;
    }
    for (int i = 1; i <= R; i++){
        for (int j = 1; j <= C; j++){
            for (int k = 1; k <= 3; k++){
                dp[j][k] = max(dp[j][3] + a[i][j], max(dp[j - 1][k], dp[j - 1][k - 1] + a[i][j]));
            }
        }
    }
    cout << max(dp[C][1], max(dp[C][2], dp[C][3])) << "\n";
    return 0;
}
```

---

## 作者：mxjz666 (赞：2)

本题可用动态规划解决。

设 $f_{i,j,k}$ 表示在第 $i$ 行取 $k$ 个物品，当前枚举到第 $j$ 列的最大价值。

状态转移：

分类讨论。

如果当前不拿第 $i$ 行，第 $j$ 列的物品，则 $f_{i,j,k}=\max(f_{i,j,k},f_{i,j-1,k})$，$f_{i,j,0}=\max(f_{i,j,0},f_{i-1,j,l})(l\in[0,3])$

如果当前拿第 $i$ 行，第 $j$ 列的物品，则 $f_{i,j,k}=\max(f_{i,j,k},f_{i,j-1,k-1}+a_{i,j})$，$f_{i,j,1}=\max(f_{i,j,1},f_{i-1,j,l}+a_{i,j})(l\in[0,3])$

最后答案为 $\max\limits_{0\le l\le3}\{f_{r,c,l}\}$ 。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=3010;
int a[N][N],f[N][N][6];
signed main(){
	int r,c,k;
	scanf("%lld%lld%lld",&r,&c,&k);
	for(int i=1;i<=k;i++){
		int x,y,v;
		scanf("%lld%lld%lld",&x,&y,&v);
		a[x][y]=v;
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			for(int k=1;k<=3;k++){
				f[i][j][k]=max(f[i-1][j][3]+a[i][j],max(f[i][j-1][k],f[i][j-1][k-1]+a[i][j]));
			}
		}
	}
	printf("%lld",f[r][c][3]);
	return 0;
}
```

---

## 作者：yangyang1000 (赞：2)

### 题目大意

给一个 $R$ 行 $C$ 列的地图，每次只能向下或向右移动，可以拾取地上的物品，价值为 $v_i$，且每行最多只能捡 $3$ 个物品。

### 难点

>每行最多只能捡 $3$ 个物品。

如果去掉这句话，就变成了一道简单 DP 题。

而本题的核心就是，如何处理这个条件？

答案非常直接：升维！

### DP 四大重点

#### 状态表示

```
long long dp[3005][3005][4];
```
我们设 $dp_{ijk}$ 表示在第 $i$ 行 $j$ 列，这一行已经捡了 $k$ 个物品，此时高桥君可获得的的最大价值。

其中，$i$ 和 $j$ 作为地图边长，最大值取 $3000$，而 $k$ 作为记录这一行已经捡了的物品物品数量，最大取 $3$。

**小坑**：$k$ 在定义数组时要取 $4$！

**小坑**：因为数据范围比较大，所以请开`long long`谢谢。

#### 状态初始化

```
memset(dp,0,sieof(dp));
```

因为 $dp$ 数组是用来存最大价值的，所以初值为 $0$，也可以直接定义为全局变量自动清零。

#### 状态转移

应该有三种转移方式，不是四种！！！

有很多人可能纳闷了，为什么不是四种？

首先，我们来看看四种是怎么来的：

|  | 从上来 | 从左来 |
| :----------: | :----------: | :----------: |
| 捡东西 | 从上来捡东西 | 从左来捡东西 |
| 不捡东西 | 从上来捡不东西 | 从左来捡不东西 |

到底那个不对呢？

这是一个不辣么难的逻辑问题，请自行思考再往下翻。

答案是 $3$ 不对。

为什么？因为你从上来，所以这是你遇到的第一个格子（如果这个格子没有物品，请脑补一个价值为零的物品）。

而这样的话，你的每行最多只能捡 $3$ 个物品的限制没有了，那你为什么不去捡呢？

所以我们来看三种情况的状态转移方程：

1. 从上来捡东西

`dp[i][j][k] = dp[i-1][j][3]`

你从上来，所以横坐标减一，你上面一行捡了 $3$ 个物品的价值肯定比没捡到 $3$ 个物品要大。

2. 从左来捡东西

`dp[i][j][k] = dp[i][j-1][k-1]+a[i][j]`

你从左来，所以纵坐标减一，你这一行现在捡的是第 $k$ 个物品，所以前一个捡了 $k-1$ 个物品。

**小坑**：别忘了加上这个物品的价值。

3. 从左来捡不东西

`dp[i][j][k] = dp[i][j-1][k]`

你从左来，所以纵坐标减一，你不捡东西，所以就只改变了坐标。

以上三种取最大即可。

```
dp[i][j][k] = max(dp[i-1][j][3]+a[i][j],max(dp[i][j-1][k],dp[i][j-1][k-1]+a[i][j]));
```

### 结果

当高桥君走到 $R$ 行 $C$ 列时，他肯定要拿走尽量多的物品，所以他应该在这一行拿走 $3$ 个物品时最好，也就是$dp_{RC3}$。

```
printf("%lld",dp[r][c][3]);
```

### 代码（请勿抄袭）：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int r,c,num,a[3005][3005];
long long dp[3005][3005][4];

int main()
{
	scanf("%d %d %d",&r,&c,&num);
	for(int i=1;i<=num;i++)
	{
		int x,y,v;
		scanf("%d %d %d",&x,&y,&v);
		a[x][y] = v;
	}
	
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			for(int k=1;k<=3;k++)
			{
				//从上或左来，捡不捡东西
				dp[i][j][k] = max(dp[i-1][j][3]+a[i][j],max(dp[i][j-1][k],dp[i][j-1][k-1]+a[i][j]));
			}
	printf("%lld",dp[r][c][3]);
	return 0;
}
```

### 优化

请注意：上面不是正解！

为啥捏，因为有一句名言：

>代码可以受委屈，但你不能踩我的内存上线！

空间爆了。

为啥捏，因为 $dp$ 数组的大小是 $3000 \times 3000 \times 3 = 27000000$，超越内存上线（但数据好像有点水，这都能过）。

所以我们要尝试压缩维度。

我们可以发现，在棋盘动规中，大部分情况只和左边和上边有关，可以直接滚动数组优化掉第一维。

这题直接强行把所有的 $i$ 维度删去，保留 $j$ 和 $k$ 两个维度即可。

### 正解：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int r,c,num,a[3005][3005];
long long dp[3005][4];

int main()
{
	scanf("%d %d %d",&r,&c,&num);
	for(int i=1;i<=num;i++)
	{
		int x,y,v;
		scanf("%d %d %d",&x,&y,&v);
		a[x][y] = v;
	}
	
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			for(int k=1;k<=3;k++)
			{
				//从上或左来，捡不捡东西
				dp[j][k] = max(dp[j][3]+a[i][j],max(dp[j-1][k],dp[j-1][k-1]+a[i][j]));
			}
	printf("%lld",dp[c][3]);
	return 0;
}
```

##### 点个赞再走呗
##### 管理员求过！

---

## 作者：wangjiajian (赞：1)

观察到不能走回头路（无后效性），考虑动态规划

设状态 $f_{i, j, k}$ 表示当前走到点 $(i, j)$，在当前行已经选择了 $k$ 个物品（$k \le 3$）。

如果当前点无物品或不选择当前点的物品，转移方程为：

$f_{i, j, k} = f_{i, j-1, k}$（即直接从左边一位转移过来）

特别地，$f_{i, j, 0}$ 还可以从上一行转移过来，因此 $f_{i, j, 0} = \max(f_{i, j-1, 0}， f_{i-1, j, z})$（$z \in \{0, 1, 2, 3 \}$）

如果当前点有物品，考虑选择该物品，转移方程为：

$f_{i, j, k} = \max(f_{i, j, k}, f_{i, j-1, k-1}+val_{i, j})$（$k > 0$）

特别地，$f_{i, j, 1}$ 也可以从头上一行转移过来，因此 $f_{i, j, 1} = \max(f_{i, j, 1}， f_{i-1, j, z}+val_{i, j})$（$z \in \{0, 1, 2, 3 \}$）

**AC 代码**

```cpp
#include <bits/stdc++.h>
#define N (int)(3002)
#define ll long long
using namespace std;

int r, c, k;
int v[N][N];
ll ans, f[N][N][4];

inline ll mx(int i, int j) {
	return max(f[i][j][0], max(max(f[i][j][1], f[i][j][2]), f[i][j][3]));
}

int main() {
	scanf("%d%d%d", &r, &c, &k);
	for(int i=1, x, y, val; i<=k; i++) {
		scanf("%d%d%d", &x, &y, &val);
		v[x][y] = val;
	}
	for(int i=1; i<=r; i++) {
		for(int j=1; j<=c; j++) {
			f[i][j][0] = max(f[i][j-1][0], mx(i-1, j));
			f[i][j][1] = f[i][j-1][1];
			f[i][j][2] = f[i][j-1][2];
			f[i][j][3] = f[i][j-1][3];
			if(v[i][j] != 0) {
				f[i][j][1] = max(f[i][j][1], mx(i-1, j)+v[i][j]);
				f[i][j][2] = max(f[i][j][2], f[i][j-1][1]+v[i][j]);
				f[i][j][3] = max(f[i][j][3], f[i][j-1][2]+v[i][j]);
			}
			ans = max(ans, mx(i, j));
		}
	}
	printf("%lld\n", ans);
	return 0;
}

```

---

## 作者：kevin1616 (赞：1)

### 审题
高桥只可以向下或右移动，且每行只可捡取至多三个物品。问捡取物品的最大价值。
***
### 方法
【动态规划】此题如果没有“至多三个物品”这个条件的话，即为正常的动态规划题。于是可以升一维代表当前在这一行捡了几个，因为每个答案只和上一行有关联，所以还能把行给压掉。所以此方法可行。
***
### 思路
首先，枚举行、列和当前行的捡取物品的次数。在此有多种可能，其中 $k$ 为当前行：

|  | 捡 | 不捡 |
| :-: | :-: | :-: |
| 从上面来 | `dp[i][3] + a[k][j]` | 根据贪心，不捡就亏，故排除 |
| 从左面来 | `dp[i - 1][j - 1] + a[k][j]` | `dp[i - 1][j]` |

其中从上面来不捡相当于浪费，于是排除。在其他这些情况下，取最大值。则转移方程为：

```cpp
dp[i][j] = max(max(dp[i][3] + a[k][j],dp[i - 1][j - 1] + a[k][j]),dp[i - 1][j]);
```

最后找到答案即可。

注意运算中可能超过 $10^9$，所以要使用 `long long`。
***
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int R,C,K;
int r,c,v;
int a[3005][3005]; //物品
int dp[3005][10]; //dp[i][j]指在第k行(1<=k<=R)第i列，该行捡取了j个物品时，所有物品的最大价值。
signed main(){
    cin >> R >> C >> K;
    for(int i = 1;i <= K;i++){
        cin >> r >> c >> v;
        a[r][c] = v;
    }
    for(int i = 1;i <= R;i++){ //枚举行
        for(int j = 1;j <= C;j++){ //枚举列
            for(int k = 1;k <= 3;k++){ //在从上面下来，从上一个不捡东西过来和从上一个捡东西过来之间选择最大值
                dp[j][k] = max(dp[j][3] + a[i][j],max(dp[j - 1][k],dp[j - 1][k - 1] + a[i][j]));
            }
        }
    }
    cout << max(max(dp[C][1],dp[C][2]),dp[C][3]); //答案在终点
    return 0;
}
```
不抄题解，从我做起！

---

## 作者：xibaohe (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/AT_abc175_e)

# 题目大意
高桥君从格子 $(1,1)$ 出发走到格子 $(R,C)$。高桥君在格子 $(i,j)$ 时，可以走到格子 $(i+1,j)$ 或格子 $(i,j+1)$。高桥君可以取路过的格子内的物品，但是一行最多只能取 $3$ 个，求高桥君拾取的物品总价值的最大值。

# 题目思路

### 升维型动规

在这道题中，我们需要用一个 $dp$ 数组表示高桥君当前的横坐标、纵坐标、在该行拾取物品的个数，因此最初可以先把数组设定为 $3$ 个维度。

### $dp_{i,j,k}$ 表示高桥君从 $(1,1)$ 走到 $(i,j)$ 且在当前行拾取了 $k$ 个物品所能达到的最大价值。

# 状态转移
这道题的状态转移方程总共有 $2$ 种情况。

 - 拾取当前物品。

如果想要拾取当前物品，我们可以反推上一步，共有从上面走来和从左面走来两种情况，因此得到状态转移方程：
```cpp
dp[i][j][k]=max(dp[i-1][j][3],dp[i][j-1][k-1])+a[i][j];
```
 - 不拾取当前物品。

如果不想拾取当前物品，我们也可以反推上一步：共有从上面走来和从左面走来两种情况。但是如果不想拾取当前物品，完全没有必要从这一列走下来，因此不可能从上面走来。得到状态转移方程：
```cpp
dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]);
```

# 一些问题

 - 由于 $v_i\leq10^9$，因此要记得开 long long。 
 - 由于 $R,C\leq3000$，因此我们的数组要开到 `dp[3005][3005][4]`，为了优化空间，我们可以进行压维。三个维度中表示高桥君横坐标的第一个维度我们可以用滚动数组的方法强行压掉，原因是高桥君只能向右和向下走，我们可以把一行的数据覆盖到上一行。优化后的状态转移方程如下：
 ```cpp
dp[j][k]=max(dp[j][k],dp[j][3]+a[i][j]);
dp[j][k]=max(dp[j][k],dp[j-1][k-1]+a[i][j]);
dp[j][k]=max(dp[j][k],dp[j-1][k]);
```
# 满分代码(内含一坑)
```cpp
#include<bits/stdc++.h>
using namespace std;
long long r,c,m,a[3005][3005],dp[3005][4];//记得要开long long! 
int main(){
	cin>>r>>c>>m;
	for(long long i=1;i<=m;i++)
	{
		long long x,y,z;
		cin>>x>>y>>z;
		a[x][y]=z;
	}//输入部分结束!
	for(long long i=1;i<=r;i++)
	{
		for(long long j=1;j<=c;j++)
		{
			for(long long k=1;k<=3;k++)
			{
				dp[j][k]=max(dp[j][k],dp[j][3]);
				dp[j][k]=max(dp[j][k],dp[j-1][k-1]+a[i][j]);
				dp[j][k]=max(dp[j][k],dp[j-1][k]);
			}
		}
	}//状态转移部分结束! 
	cout<<dp[c][3]<<endl;
	return 0;
}

```
代码不要直接抄袭哦，内有一坑，小心变棕 QWQ。


---

## 作者：happy_zero (赞：1)

这是一道动规的题。

### 状态表示

我们先考虑状态表示。首先有两个维度 $i,j$ 表示走到了棋盘 $i$ 行 $j$ 列拾取物品的最大值。但由于一行只能取三个物品的限制，两维无法之间进行转移，那我们就考虑升维。观察限制只与这一行的所取物品数有关，那么我们就可以另 $k$ 表示在第 $i$ 行取了 $k$ 个物品 $(0\le k\le 3)$。

综合下来，我们令 $dp_{i,j,k}$ 表示走到第 $i$ 行第 $j$ 列且在第 $i$ 行取了 $k$ 个物品的最大价值。

### 状态转移

我们先两重循环枚举 $i$ 和 $j$，令 $v_{i,j}$ 表示 $i$ 行 $j$ 列的物品价值，若没有物品则为零。状态转移方程如下：


$$k=0:dp_{i,j,k}=\max(dp_{i,j-1,0},dp_{i-1,j,t}(0\le t\le 3))$$

$$k=1:dp_{i,j,k}=\max(dp_{i,j-1,0}+v_{i,j},dp_{i,j-1,1},dp_{i-1,j,t}(0\le t\le 3))$$

$$k=2/3:dp_{i,j,k}=\max(dp_{i,j-1,k-1}+v_{i,j},dp_{i,j-1,k})$$

其实也很简单，就是分四种情况：

1. 从左来且这一个物品取

1. 从左来且这一个物品不取

1. 从上来且这个物品取

1. 从上来且这个物品不取

$k=0$，这个物品只能不取，所以对应第二种和第四种情况

$k=1$，这个物品从左来可以取或不取，但从上来必须去，所以除了第四种情况其他都行

$k=2/3$，如果是从上来则不能取到 $2$ 或 $3$ 个物品，所以从第一种和第二种转移而来。

### 答案表示

这道题答案前两个维度显然就是 $n$ 和 $m$，最后一维我们不确定，所以就对 $k$ 的几种可能求 $\max$。

**最后说一句，这题数据范围大，所以要开 `long long`！**

---

## 作者：xz001 (赞：0)

直接暴力必然超时，考虑 dp。

设立 $f_{i,j,k}$ 表示在点 $(i,j)$，还能选择 $k$ 个点的最大价值。

设 $a_{i,j}$ 表示点 $(i,j)$ 的贡献。

当 $k\ne 0$ 时，转移为：

$$
f_{i,j,k}=\max\{f_{i,j+1,k-1}+a_{i,j},f_{i,j+1,k},f_{i+1,j,3}+a_{i,j}\}
$$

当 $k=0$ 时，转移为：

$$
f_{i,j,k}=\max\{f_{i,j+1,k},f_{i+1,j,k}\}
$$

代码如下：

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

int R, C, k, a[3005][3005], f[3005][3005][4]; 

int dfs (int i, int j, int k) {
	if (i > R || j > C) return -1e15;
	if (i == R && j == C) return k ? a[i][j] : 0;
	if (f[i][j][k] != -1) return f[i][j][k];
	if (k) return f[i][j][k] = max(dfs (i, j + 1, k - 1) + a[i][j], max(dfs (i, j + 1, k), dfs (i + 1, j, 3) + a[i][j]));
	return f[i][j][k] = max(dfs (i, j + 1, k), dfs (i + 1, j, 3));
}

signed main() {
	scanf("%lld%lld%lld", &R, &C, &k);
	while (k -- ) {
		int r, c, v;
		scanf("%lld%lld%lld", &r, &c, &v);
		a[r][c] = v;
	}
	memset(f, -1, sizeof(f));
	printf("%lld\n", dfs (1, 1, 3));
	return 0;
}
```

---


# [ABC232F] Simple Operations on Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc232/tasks/abc232_f

長さ $ N $ の $ 2 $ つの整数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ および $ B\ =\ (B_1,\ B_2\ \ldots,\ B_N) $ が与えられます。

整数列 $ A $ に対して、「下記の $ 2 $ つの操作のうちどちらかを行う」ということを好きな回数（ $ 0 $ 回でもよい）繰り返すことができます。

- $ 1\ \leq\ i\ \leq\ N $ を満たす整数 $ i $ を選び、$ A_i $ の値を $ 1 $ 増やすか $ 1 $ 減らす。この操作には $ X $ 円の費用がかかる。
- $ 1\ \leq\ i\ \leq\ N-1 $ を満たす整数 $ i $ を選び、$ A_i $ の値と $ A_{i+1} $ の値を入れ替える。この操作には $ Y $ 円の費用がかかる。

上記の繰り返しによって整数列 $ A $ を整数列 $ B $ に一致させるためにかかる合計費用としてあり得る最小値を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 18 $
- $ 1\ \leq\ X\ \leq\ 10^8 $
- $ 1\ \leq\ Y\ \leq\ 10^{16} $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^8 $
- 入力はすべて整数

### Sample Explanation 1

はじめ、$ A\ =\ (4,\ 2,\ 5,\ 2) $ です。 下記の通りに操作を行うと、$ A $ を $ B $ に一致させることができます。 - $ X\ =\ 3 $ 円払い、$ A_3 $ の値を $ 1 $ 増やす。その結果 $ A\ =\ (4,\ 2,\ 6,\ 2) $ となる。 - $ Y\ =\ 5 $ 円払い、$ A_2 $ の値と $ A_3 $ の値を入れ替える。その結果 $ A\ =\ (4,\ 6,\ 2,\ 2) $ となる。 - $ Y\ =\ 5 $ 円払い、$ A_1 $ の値と $ A_2 $ の値を入れ替える。その結果 $ A\ =\ (6,\ 4,\ 2,\ 2) $ となる。 - $ X\ =\ 3 $ 円払い、$ A_4 $ の値を $ 1 $ 減らす。その結果 $ A\ =\ (6,\ 4,\ 2,\ 1)\ =\ B $ となる。 上記の操作にかかる費用の合計は $ 3+5+5+3\ =\ 16 $ 円であり、これが最小となります。

### Sample Explanation 2

$ A $ と $ B $ は初めから一致しているため、一度も操作を行う必要がありません。

### Sample Explanation 3

入力や出力が $ 32 $ bit 整数型に収まらないことがあることに注意してください。

## 样例 #1

### 输入

```
4 3 5
4 2 5 2
6 4 2 1```

### 输出

```
16```

## 样例 #2

### 输入

```
5 12345 6789
1 2 3 4 5
1 2 3 4 5```

### 输出

```
0```

## 样例 #3

### 输入

```
18 20719114 5117250357733867
10511029 36397527 63027379 44706927 47672230 79861204 57882493 42931589 51053644 52300688 43971370 26515475 62139996 41282303 34022578 12523039 6696497 64922712
14720753 4621362 25269832 91410838 86751784 32741849 6602693 60719353 28911226 88280613 18745325 80675202 34289776 37849132 99280042 73760634 43897718 40659077```

### 输出

```
13104119429316474```

# 题解

## 作者：方123456 (赞：4)

来写一篇状压的题解，数据范围这么小，猜一个就是 $O(2^n)$ 级别的算法。

我们设 $|S|$ 表示 $S$ 集合里有的元素个数

我们可以用状压来推出来这个排列，我们设 $f_{S}$ 表示 $S$ 集合里面的所有数都被安排掉了，然后加上去一个数，表示安排在 $|S|+1$ 的位置。

然后就可以在当前位置计算逆序对的个数了。

然后安排在这个位置的话，和这个位置相减一下然后取绝对值之后就能得到增长的多少。

学过状压 DP 的应该都能理解把。

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int INF=20;
int n,x,y,f[1<<INF],a[INF],b[INF];
signed main()
{
	memset(f,63,sizeof f);
	ios::sync_with_stdio(false);
	cin>>n>>x>>y;
	for (int i=0;i<n;i++) cin>>a[i];
	for (int i=0;i<n;i++) cin>>b[i];
	
	f[0]=0;
	for (int i=0;i<(1<<n);i++) {
		int sum=0,xx=i;
		while (xx) {xx-=xx&-xx;sum++;}
		for (int j=0;j<n;j++) {
			if (i&(1<<j)) continue;
			int K=0;
			for (int k=0;k<n;k++) {
				if (i&(1<<k)) {
					if (j<k) K++;
				}
			}
			
			f[i|(1<<j)]=min(f[i|(1<<j)],f[i]+K*y+abs(a[j]-b[sum])*x);
		}
	}
	cout<<f[(1<<n)-1]<<"\n";
	return 0;
}
```


---

## 作者：_edge_ (赞：2)

来宣传一下模拟退火的科技。

看到这种情况数在 $10^{20}$ 次以内，并且计算出答案序列之后非常好做的题就可以思考模拟退火的操作。

分析一下这题目，题目中未知的是答案序列的顺序，所以我们随机选择一个排列，然后考虑如何 check。

交换相邻两数相当于是有一个逆序对才需要交换，可以考虑冒泡排序的过程，所以有一个逆序对就产生了 $y$ 的贡献。

然后对于加减就是相减之后取绝对值，每个产生 $x$ 的贡献。

然后就是非常非常经典模拟退火的过程了，随机两个位置然后交换，如果随出来的这个比原来的那个小，那就可行，交换掉，否则有一个估价函数去估计是否要交换。

对于温度越低，那么该估价函数的值应该越高，也就是越想要贪心的往回走更优秀的，对于差值更大的也是如此。

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int INF=25;
int n,x,y,p[INF],a[INF],b[INF],ans;
int tree[INF];
int check() {
	int sum=0,ans=0;
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++)
			if (p[i]>p[j]) ans++;
	sum+=ans*y;
	
	for (int i=1;i<=n;i++)
		sum+=abs(a[p[i]]-b[i])*x;
	 return sum;
}
void SA() {
	for (int i=1;i<=n;i++) p[i]=i;
	double T=2008;int res=check();
	while (T>=1e-13) {
		int x=rand()%n+1,y=rand()%n+1;
		swap(p[x],p[y]);
		int now=check();
		if (res>now) res=now;
		else if (exp(now-res)/T*RAND_MAX>rand()) swap(p[x],p[y]);
		T*=0.997;	
	}
	ans=min(ans,res);
	return ;
}
signed main()
{
	srand(114514);
	ios::sync_with_stdio(false);
	cin>>n>>x>>y;ans=1e18;
	for (int i=1;i<=n;i++) cin>>a[i];
	for (int i=1;i<=n;i++) cin>>b[i];
	while (clock()<CLOCKS_PER_SEC*1.88) SA();
	cout<<ans<<"\n";
	return 0;
}
```


---

## 作者：InversionShadow (赞：1)

看到 $n\le 18$ 就可以模拟退火乱搞。

~~事先申明一下，这篇不是 chatgpt 写的。~~

那么什么事模拟退火呢？

模拟退火就是考虑 $p_i$ 数组为当前第 $i$ 个数的下标，暴力地交换若干次，取最小值。但如果没有取到，就随机地交换回来或者不交换继续（具体的判断很玄学，可以去 oi-wiki 上查看，代码如下 ```exp(p - k) / t * RAND_MAX > rand()```，其中 `k` 为当前能取到的最小值，`p` 为当前答案，`t` 为当前温度）。

所以模拟退火没有正确性，但是你可以加一个卡时。具体的，`c++` 中有一个库函数 `clock`，调用可以知道当前时间，所以就可以进行卡时，代码如下 ```while (clock() - ti < 2000)```，其中 `ti` 表示程序开始运行的时间，这句代码就可以保证进行 `SA` 函数的时间小于 $2000$ 毫秒。

那么这道题的查看当前答案的函数怎么写呢？显然你要把所有 $p_i$ 都返回到 $i$，所以要进行 $q = \sum\limits_{i=1}^n\sum\limits_{j=i+1}^n(p_i>p_j)$ 次二操作，花费 $q\times y$，同时要加上 $\sum\limits_{i=1}^n(|a_{p_i}-b_i|)\times x$，意思是对于 $p_i$ 这个 $a_{p_i}$，要进行 $|a_{p_i}-b_i|$ 变成 $b_i$，花费要乘上系数 $x$。

代码实现可以参考 @[_edge_](https://www.luogu.com.cn/user/208653) 大佬的代码。

对了，模拟退火可能要多交几遍，我这里取初始温度 $2500$，误差为 $10^{-10}$，温度系数为 $0.9981$，可以参考一下。

---

## 作者：wangshulin (赞：1)

# 前言
不妨换一个思路。
# 思路
1. 状压 dp，但是状态难想，转移方程难推。

2. 如果将“有哪几个 $a$ 数组的元素和 $b$ 数组元素匹配”作为 dp 的状态，那么就钻进了死胡同（~~是的这个蒟蒻就是用这个状态推了半个小时~~）因为这个状态和题目的操作 2 没什么关联，是无效的！

3. 其实题目的操作可以转化成以下操作：当操作后的 $A$ 数组和 $B$ 数组的前 $s$ 位都相同，接下来可以将 $A$ 数组中第 $s+1$ 至第 $n$ 位的任意元素与 $A_{s+1}$ 交换（交换实际上就是将这个元素使用 $2$ 操作不断与前一位交换移动到 $A_{s+1}$），再让其加减直至与 $B_{s+1}$ 相同。

4. 转化操作之后状态就不难想了，设状态 $i$，$2^{pos-1}$ 包含在状态 $i$ 中表示 $A_{pos}$ 被移动至前 $s$ 位与 $B$ 数组匹配，其中 $s$ 为 $\operatorname{popcount}(i)$（总共有多少个元素交换至前面与 $B$ 数组进行匹配了）。然后想到枚举下一个交换到位置 $s+1$ 并与 $B_{s+1}$ 进行匹配的 $A$ 数组元素。

5. 推导状态转移方程：
	- $s$ 与 $i$ 与以上所说意义一样。
	- 设当前枚举到的元素为 $A_j$。
   - 设在有 $c$ 个元素 $A_k$ 满足比元素 $A_j$ 更靠前且被移动到前 $s$ 位匹配为 ，即满足 $k \le j$ 且 $2^{k-1}$ 包含在状态 $i$ 中。
	- 即可推出状态转移方程：
$$f_{i | 2^j} \gets \min(f_{i | 2^j},f_{i}+y \times c+x \times \lvert a[j]-b[s] \rvert)$$

# 代码
```cpp
#include<stdio.h>
#include<algorithm>
#include<string.h>
#define ll long long
const ll N=19;
ll n,x,y,cnt,a[N],b[N],t[N],f[1<<N];
int main(){
	scanf("%lld%lld%lld",&n,&x,&y);
	for(ll i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(ll i=1;i<=n;i++){
		scanf("%lld",&b[i]);
	}
	memset(f,18,sizeof(f));
	f[0]=0;
	for(ll i=0;i<(1<<n);i++){
		ll s=0;
		for(ll j=1;j<=n;j++){
			if(i&(1<<(j-1))) s++;
		}
		s++;
		for(ll j=1;j<=n;j++){
			if(i&(1<<(j-1))) continue;
			ll c=0;
			for(ll k=1;k<j;k++){
				if(!(i&(1<<(k-1)))) c++;
			}
			f[i|(1<<(j-1))]=std::min(f[i|(1<<(j-1))],f[i]+y*c+x*abs(a[j]-b[s]));
		}
	}
	printf("%lld\n",f[(1<<n)-1]);
	return 0; 
}
```

---


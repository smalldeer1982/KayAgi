# [ARC025B] チョコレート

## 题目描述

有一块纵 $H$ 格，横 $W$ 格的巧克力。每一格要么是黑巧克力要么是白巧克力。黑巧克力之间、白巧克力之间没有共有的边。每一格的巧克力都有自己的浓度。以下是巧克力的一个例子（其中的数字表示巧克力浓度）。

![](https://arc025.contest.atcoder.jp/img/arc/025/2-1.png)

Imouto想从这块巧克力中取出一块长方形区域，将其熔化成为巧克力酱。Imouto很重视巧克力的口味，因此她希望取出的长方形区域中的白巧克力浓度合计值等于黑巧克力浓度合计值（如果没有使用黑/白巧克力，则浓度为 $0$ ）。

Imouto想知道满足条件的方案中，使用的巧克力格子数最大是多少。

## 样例 #1

### 输入

```
3 4
4 6 2 5
3 5 6 7
2 5 5 6```

### 输出

```
6```

## 样例 #2

### 输入

```
2 2
4 0
7 3```

### 输出

```
4```

## 样例 #3

### 输入

```
2 3
0 0 0
1 2 3```

### 输出

```
3```

## 样例 #4

### 输入

```
3 3
1 2 3
6 5 4
7 8 9```

### 输出

```
0```

## 样例 #5

### 输入

```
1 5
0 1 2 3 4```

### 输出

```
1```

# 题解

## 作者：RioBlu (赞：0)

其实就是二维前缀和问题
___
我们枚举一个长方形，的$x1,y1;x2,y2$

然后用二维前缀和求出这个长方形内白巧克力的浓度和

然后再用二维前缀和求出这个长方形内黑巧克力的浓度和

如果相等且比原来的答案大

$ans=(x2-x1+1)*(y2-y1+1)$
```
#include<bits/stdc++.h>
using namespace std;
long long a,b,cb[105][105],cw[105][105],ans,o;
void check(int x1,int x2,int x3,int x4)
{
	if(cb[x3][x4]-cb[x1-1][x4]-cb[x3][x2-1]+cb[x1-1][x2-1]==cw[x3][x4]-cw[x1-1][x4]-cw[x3][x2-1]+cw[x1-1][x2-1])
	{
		ans=max(ans,(x4-x2+1LL)*(x3-x1+1LL));
	}
}
int main()
{
	cin>>a>>b;
	for(int s=1;s<=a;s++)
		for(int v=1;v<=b;v++)
		{
			cin>>o;
			cb[s][v]=cb[s][v-1]+cb[s-1][v]-cb[s-1][v-1];
			cw[s][v]=cw[s][v-1]+cw[s-1][v]-cw[s-1][v-1];
			if((s+v)%2)cw[s][v]+=o;
			else cb[s][v]+=o;
		}
			
	for(int s=1;s<=a;s++)
		for(int v=1;v<=b;v++)
			for(int x=1;x<=a-s+1;x++)
				for(int y=1;y<=b-v+1;y++)
					check(x,y,x+s-1,y+v-1);
	cout<<ans<<endl;
}
```

---


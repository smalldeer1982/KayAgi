# [ARC027C] 最高のトッピングにしような

## 题目描述

在我常去的一家餐馆里，用餐可以获得兑换券。

兑换券有两种类型：一种是提供额外功能的“特殊兑换券”，另一种是“普通兑换券”。

这家餐馆提供 $N$ 种配料，你可以用 $t_i$ 张票券换得每种配料 $i$。在组合兑换中，同一种配料不可重复获取。兑换时，尽管两种类型的兑换券等值，但需保证每种配料的兑换至少包含一张“特殊兑换券”。例如，若某种配料需要 4 张票券，有以下 4 种兑换组合：

- 1 张特殊兑换券和 3 张普通兑换券。
- 2 张特殊兑换券和 2 张普通兑换券。
- 3 张特殊兑换券和 1 张普通兑换券。
- 全用 4 张特殊兑换券。

每种配料都有各自的“快乐值”，用 $h_i$ 表示获取配料 $i$ 时的快乐值。

今天是个特别的日子，我希望通过合理利用现有的兑换券，最大化兑换配料带来的总快乐值。请设计一个程序，计算出在当前的票券和配料信息下，能够获取的最大快乐值。

## 说明/提示

### 部分得分

题目设有部分得分：

- 对于数据集 1，满足条件 $X \leq 50$，$Y \leq 50$，$N \leq 50$，$t_i \leq 100$ 的正确解答可以获得 30 分。
- 对于没有额外限制的通用数据集 2，正确解答可以获得 70 分。

### 样例解释

- 初始有 3 张特殊兑换券和 5 张普通兑换券。通过以下组合可以得到最大快乐值 100（即40 + 60）：
  - 使用 1 张特殊兑换券和 2 张普通兑换券兑换配料 2（需 3 张票券），获得快乐值 40。
  - 使用 2 张特殊兑换券和 3 张普通兑换券兑换配料 3（需 5 张票券），获得快乐值 60。
  这个组合用掉了 3 张特殊和 5 张普通兑换券，是可行的。

- 最优选择是获取配料 1 和配料 2。

- 选择配料 3，并留下一张票券，是最优解。

- 可以获取所有的配料。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 5
4
3 30
3 40
5 60
7 80```

### 输出

```
100```

## 样例 #2

### 输入

```
3 3
4
3 30
3 40
5 60
7 80```

### 输出

```
70```

## 样例 #3

### 输入

```
1 5
4
3 30
3 40
5 60
7 80```

### 输出

```
60```

## 样例 #4

### 输入

```
6 12
4
3 30
3 40
5 60
7 80```

### 输出

```
210```

# 题解

## 作者：ycy1124 (赞：2)

### 题意
有 $x$ 张特殊卷和 $y$ 张普通卷，现在有 $n$ 种配料，得到每种配料要 $t_i$ 张卷并且必须包含一张特殊卷，如果得到这种配料就可以获得 $h_i$ 的快乐值。试问所能获得的最大快乐值。
### 思路
考虑使用的顺序，在普通卷使用完之前尽量的使用少的特殊卷，这样才不会出现前面用了多张特殊卷导致后面没特殊卷可用。由于普通的背包 dp 在此题并不好做于是考虑特殊的背包 dp。设 $dp_{i,j,k}$ 表示到第 $i$ 个调料得到了 $j$ 个调料共花了 $k$ 张卷所能得到的最大快乐值，能得到的调料个数是小于等于特殊卷的个数的。转移方程很简单：$dp_{i,j,k}=\max(dp_{i-1,j-1,k-t_i}+h_i,dp_{i,j,k})$，就是分别将买不买这件商品所能得到的快乐值取个最大值。我们使用滚动数组优化掉一维。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x,y,n,sum,ans;
int dp[2][305][605];
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>x>>y>>n;
    for(int i=0;i<=x;i++){
        for(int j=0;j<=x+y;j++){
            dp[0][i][j]=dp[1][i][j]=-1e9;
        }
    }
    dp[0][0][0]=dp[1][0][0]=0;
    for(int i=1;i<=n;i++){
        int t,h;
        cin>>h>>t;
        sum+=h;
        for(int j=min(i,x);j>=0;j--){
            for(int k=min(sum,x+y);k>=0;k--){
                if(j<=0||k<h){
                    dp[i%2][j][k]=max(dp[i%2][j][k],dp[i%2^1][j][k]);
                    continue;
                }
                dp[i%2][j][k]=max(dp[i%2^1][j-1][k-h]+t,max(dp[i%2][j][k],dp[i%2^1][j][k]));
                ans=max(dp[i%2][j][k],ans);
            }
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/203003004)。

---


# [ABC047D] 高橋君と見えざる手

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc047/tasks/arc063_b

$ N $ 個の町が一直線上に並んでいます。行商人の高橋君は町 $ 1 $ から出発し、リンゴの売買をしながら町 $ N $ へと向かいます。

はじめ高橋君は町 $ 1 $ におり、リンゴを $ 1 $ つも持っていません。高橋君は次のいずれかの行動を繰り返し行います。

- 移動: 町 $ i $ ($ i\ <\ N $) にいるとき、町 $ i\ +\ 1 $ へ移動する。
- リンゴの売買: リンゴを好きな個数だけ売買する。ここで、町 $ i $ ($ 1\ ≦\ i\ ≦\ N $) ではリンゴの買値も売値もともに $ A_i $ 円とする。ここで $ A_i $ は相異なる整数です。

$ 1 $ つの町で売買するリンゴの個数に制限はありませんが、旅の中で売買するリンゴの個数は合計で (買う個数と売る個数を合わせて) $ T $ 個以下にしなくてはなりません。

高橋君は旅の利益、すなわちリンゴを売った代金から買った代金を引いた値を最大にするように旅をするとします。旅が終わったときに持っていたリンゴの価値は考えず、旅の中で売買した金額だけを考えます。

この旅に先立って、青木君は任意の町 $ i $ に対して $ A_i $ を好きな非負整数 $ A_i' $ に変えるという操作を好きなだけ行うことができます。ただし、この操作は行うごとに $ |A_i\ -\ A_i'| $ のコストがかかります。操作後には異なる町の間でリンゴの値段が同じになっていても構いません。

青木君の目的はできるだけ少ない合計コストの操作で高橋君の利益を少なくとも $ 1 $ 円下げることです。合計コストの最小値を求めてください。

ただし、元の状態で高橋君が $ 1 $ 円以上の利益を上げられることは仮定して構いません。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ A_i\ ≦\ 10^9 $ ($ 1\ ≦\ i\ ≦\ N $)
- $ A_i $ は相異なる
- $ 2\ ≦\ T\ ≦\ 10^9 $
- 入力の状態では高橋君は $ 1 $ 円以上の利益を上げられることが保証される

### Sample Explanation 1

この入力の状態では、高橋君は次のようにして最大の利益である $ 150 $ 円を達成することができます。 1. 町 $ 1 $ から町 $ 2 $ へ移動する。 2. 町 $ 2 $ で $ 50 $ 円を支払い、リンゴを $ 1 $ 個買う。 3. 町 $ 2 $ から町 $ 3 $ へ移動する。 4. 町 $ 3 $ で $ 200 $ 円でリンゴを $ 1 $ 個売る。 たとえば、青木君が町 $ 2 $ のリンゴの値段を $ 50 $ 円から $ 51 $ 円に変えると、高橋君はどのようにしても $ 150 $ 円の利益を上げることができなくなります。すなわち、コスト $ 1 $ で高橋君の利益を少なくとも $ 1 $ 円下げることが可能であり、答えは $ 1 $ となります。 他にも、町 $ 3 $ のリンゴの値段を $ 200 $ 円から $ 199 $ 円に変えることでもコスト $ 1 $ で高橋君の利益を下げることが可能です。

## 样例 #1

### 输入

```
3 2
100 50 200```

### 输出

```
1```

## 样例 #2

### 输入

```
5 8
50 30 40 10 20```

### 输出

```
2```

## 样例 #3

### 输入

```
10 100
7 10 4 5 9 3 6 8 2 1```

### 输出

```
2```

# 题解

## 作者：watcher_YBH (赞：8)

# 题目：
高桥会从 $1$ 小镇开始，依次走到 $n$ 小镇。高桥在途中会收购或出售苹果，$a_i$ 表示 $i$ 号小镇收购或出售的价格。青木君会改变 $m$ 个小镇收购与出售的价格，以此来降低高桥最终可获得的最大利润，求 $m$ 的最小值。
# 思路：
要想改变高桥可获得的最大利润，我们就要求出有哪些组合可以达到最大利润，青木君只用**改变每一个最大利润，就可以改变高桥最终可获得的最大利润（求出最大利润的个数）。**
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,b[100005];//b数组保存每个子段可获得的最大利润
int minn=INT_MAX;//当前子段的最小售价
int maxx=-INT_MAX;//所有利润的最大值
int ans=0;//记录最大利润的次数
int main(){
	cin>>n>>m;
	for(int i = 1; i<=n; i++){
		int a;
		cin>>a;
		b[i] = a-minn;//求出这个数与前面所有数的最小值可产生的利润（可以保证第一个数的利润为无穷小）
		minn = min(minn,a);//更新最小值
		maxx = max(maxx,b[i]);//更新最大利润
	}
	for(int i = 1; i<=n; i++){
		if(b[i] == maxx){//求出有几个最大利润
			ans++;
		}
	}
	cout<<ans<<endl;//输出结果
	return 0;//完美结束~
}
```


---

## 作者：small_john (赞：6)

## 前言

今天%你赛有这道题，被我秒杀，写篇题解纪念一下。

## 分析

高橋君得到最高利润的方式有很多种。就拿样例 $3$ 来说。

![](https://cdn.luogu.com.cn/upload/image_hosting/qg65qiyt.png)

可以发现，高橋君一个苹果的最高利润是 $5$，并且得到此利润的方式有 $2$ 种：

1. 在 $3$ 号村买，在 $5$ 号村卖；

2. 在 $6$ 号村买，在 $8$ 号村卖。

那么青木君只要对这 $2$ 种方式的买的哪个村（此处为 $3$ 号和 $6$ 号）对应的 $a_i$ 加 $1$ 即可。

所以我们就统计出得到最高利润的种数输出就完美的满分。

## 实现方法

开个数组 $b$ 存在第 $i$ 个村卖出苹果最多可以拿到多少利润，则 $b_i$ 就是 $a_i$ 减去在前 $i-1$ 个村中 $a_i$ 的最小值（记为 $mn$），即 $b_i = a_i-mn$。每次运算 $b_i$ 时，把最大利润更新一下（记为 $mx$），即 $mx = \max\{mx,b_i\}$。最后更新 $mn$，即 $mn=\min\{mn,a_i\}$。

### code

```cpp
for(int i = 1;i<=n;i++)
	b[i] = a[i]-mn,mx = max(mx,b[i]),mn = min(mn,a[i]);
```

遍历完后，把 $b$ 扫一遍，如果 $b_i=mx$，那么 $ans$ 加 $1$。

### code

```cpp
for(int i = 1;i<=n;i++)
	if(b[i]==mx)
		ans++;
```

输出 $ans$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
int n,t,a[N],b[N],mx = INT_MIN,mn = INT_MAX,ans;
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>t;
	for(int i = 1;i<=n;i++)
		cin>>a[i];
	for(int i = 1;i<=n;i++)
		b[i] = a[i]-mn,mx = max(mx,b[i]),mn = min(mn,a[i]);
	for(int i = 1;i<=n;i++)
		if(b[i]==mx)
			ans++;
	cout<<ans;
	return 0;
}

```

---

## 作者：_Linver_ (赞：4)

# 思路
我们只要求出两座数值相差最大的城市的组数即可。

因为高桥一定会买最低价价格的苹果到高价城市卖，将值最少的城市或是值最高的城市进行一定更改，一定会让他亏。找到规律就还挺简单的题。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int N,t,A[114514] = {},B[114514] = {INT_MAX};
int ch = 0,ans = 0;
int main() 
{
    scanf("%d %d",&N,&t);
    for (int i = 1; i <= N; i++)
    {
    	scanf("%d",&A[i]);
    	B[i] = A[i]; // 最简单的初始化
    	B[i] = min(B[i-1],A[i]);//找出当前最小值
    	ch = max(ch,A[i]-B[i]);//求出最大差值
    }
    for (int i = 1; i <= N; i++)
    	if (A[i]-B[i] == ch) ans++;//寻找相差最大组数(dddd
    printf("%d",ans);
    return 0;
}
```

---

## 作者：tangyigeng (赞：3)

## 简要题意
高桥会从 $1$ 号小镇走到 $n$ 号小镇，从这 $n$ 个小镇中选一些小镇以那些小镇的物价购入苹果或出售苹果，可以理解为高桥一开始有无穷多的资金。而青木会通过改变一些小镇的物价来降低高桥最终可获得的最大利润，求所有小镇改变后的物价与原物价绝对值之和的最小值。
## 分析
令 $min_i$ 表示 $a$ 数组的前缀最小值，可以很容易地列出高桥一开始可获得的最大利润：$\max a_i-min_i$。

所以很显然要想让上面这个式子变小只有把 $a_i$ 变小，或把 $min_i$ 变大，而且只可能把物价变大或变小一个单位。
+ 改 $a_i$：首先当 $a_i$ 不等于 $min_i$ 时，$a_i$ 不可能作为它之后的前缀最小值，因为 $min_i$ 肯定会比 $a_i$ 更优。又因为一次只用改小一个单位，所以改变 $a_i$ 一定没有后效性。所以答案就是 $a_i-min_i$ 的最大值的个数。
+ 改 $min_i$：这种情况很显然一定有后效性所以一定不会比改 $a_i$ 更优，所以就不用讨论这种情况了。

注意，岛国的题都要在末尾换行。
## 代码
```cpp
#include<cstdio>
#include<iostream>
int n, t, maxn = -1e9, minn = 1e9, cnt;
int main(){
	scanf("%d%d", &n, &t);//t其实没什么作用。
	while(n--){
		scanf("%d", &t), minn = std::min(minn, t);
		if(maxn < t - minn)
			maxn = t - minn, cnt = 0;
		cnt += maxn == t - minn;
	}
	printf("%d\n", cnt);
	return 0;
}
```


---

## 作者：_Above_the_clouds_ (赞：0)

# 思路：
用 $minn$ 记录从小镇 $1$ 到小镇 $i$ 的苹果价格最小值，再用 $maxx$ 记录每个小镇苹果价格与 $minn$ 的差，算出利润。如果利润等于 $maxx$，为了让高桥君所得的最大利益至少下降 $1$，只需让小镇 $i$ 的苹果价格加一，代价就加一，也就 `ans++`，否则，如果利润大于 $maxx$，那么 $maxx$ 更新，代价就需重新赋值为 $1$，最后输出 $ans$。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,minn=2e9,maxx,ans=1;//minn赋值为最大值，为了让最大利润下降1，ans至少为1。
int a[100005];
int main() {
	scanf("%d%d",&n,&t);//输入
	for(int i=1; i<=n; i++) scanf("%d",&a[i]);
	for(int i=1; i<=n; i++) {
		minn=min(minn,a[i]);//最小值
		if(a[i]-minn==maxx) ans++;//代价加一
		else if(a[i]-minn>maxx) maxx=a[i]-minn,ans=1;//maxx更新，ans重新赋值。
	}
	printf("%d",ans);//输出
	return 0;
}
```


---

## 作者：Yashajin_Ai (赞：0)

这道题其实是算的是**数组中有多少对用 $a_i$ 去减去 $a_i$ 左边最小的数并且保证两个数相差的值最大**，那么弄清了这个问题就很好解题了，$O(n)$ 扫一遍就可以过了。

当然对于一组 $i < j$，当 $a_j - a_i$ 为初始状态的最大值时，进行 $a_j$ 自减或 $a_i$ 自增必然不会出现新的差值不小于 $a_j - a_i$ 的对。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,t,a[100001],mn=1e9,mx=0,k[100001],cs=0;
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		k[i]=a[i]-mn;
		mx=max(mx,a[i]-mn);
		mn=min(mn,a[i]);
	}
	for(int i=1;i<=n;i++){
		if(k[i]==mx){
			cs++;
		}
		if(i==n){
			cout<<cs;
		}
	}
}
```

---

## 作者：_AyachiNene (赞：0)

首先想怎么能使高桥君收益最大：比如一组数据

```cpp
3 2
114 514 810 1919
```

肯定是在第一个城市以 $114$ 的价格买入买，最后一个城镇以 $1919$ 元卖出最合适罢，那么很容易就可以总结出在价格最低的一个城市买，在之后最贵的一个城市卖出，如有多种可能随便找两个城市就行了。

再来看青木。他的目标是让高桥君期望收益至少减少 $1$，那么我们只要知道高桥君可能在某两个城市买，把买入的城市或者卖出的城市的价格加上 $1$ 那就行了，也就是把总的花费加上 $1$。

总结：求有几组城市相差的值最大即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,a[114514],maxn,ans,k; //maxn存收益最大的两个城市的收益，k存当前价格最便宜的城市编号
int main()
{
	cin>>n>>t;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	k=1;                        //假设城市1为当前价格的最小值 
	for(int i=2;i<=n;i++)
	{
		if(a[i]<a[k])		//更新价格最小值的编号 
			k=i;
		if(a[i]-a[k]>maxn)		//更新最大值，当前城市的价格-当前价格最小成市的价格与最大值比较 
			maxn=a[i]-a[k];
	}
	k=1;
	for(int i=2;i<=n;i++)
	{
		if(a[i]<a[k])		//同前 
			k=i;
		if(a[i]-a[k]==maxn)		//找到一组收益最大的城市 
			ans++;			//花费加1 
	}
	cout<<ans;
}
```


---

## 作者：CodingOIer (赞：0)

## 题意理解&分析：

大概的题意应该是十分清晰的，就是一个人要从 $1$ 到 $n$ 的城市中买苹果。另一个人要其中调整价格。

这里的调整也不需要太多，就 $1$ 就可以了。但是，如果有多组购买方案可以得到**相同**的利润，就还需要将其他相同的价格**一并调整**。这道题的**关键**就在于求出有几组购买方案最少。

也就是说，我们需要求出有多少组商店的价格差最大。

拿样例 2 来说：

```
5 8
50 30 40 10 20
```

其中 $30$ 到 $40$，$10$ 到 $20$ 的差价都为 $10$。

所以我们需要调整他们两个的价格，所以答案为 $2$。

我们可以用 $Min$ 记录过往商店中最低的价格，用 $money$ 记录最小利润，用 $ans$ 记录最少购买方案的组数。$Min$：中途保持更新为最低价格。$money$：每次比较利润，有更大时更新，同时将 $ans$ 赋值为 $1$。$ans$：记录答案。

```cpp
Min=p[1];
money=-1;
for(int i=2;i<=n;i++)
{
	if(p[i]<Min)
	{
		Min=p[i];
	}
	else
	{
		if(p[i]-Min==money)
		{
			ans++;
		}
		else if(p[i]-Min>money)
		{
			money=p[i]-Min;
			ans=1;
		}
	}
}
```

最后直接输出 $ans$ 即可。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
//养成好习惯
int n,t;
int p[N];
int Min;
int money;
int ans;
int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&p[i]);
	}
    //输入
	Min=p[1];
	money=-1;
	for(int i=2;i<=n;i++)
	{
		if(p[i]<Min)
		{
			Min=p[i];
            //更新Min
		}
		else
		{
			if(p[i]-Min==money)
			{
				ans++;
                //累计答案
			}
			else if(p[i]-Min>money)
			{
				money=p[i]-Min;
				ans=1;
                //更新miney并赋值ans
			}
		}
	}
	printf("%d\n",ans);
    //输出结束
	return 0;
}
```

---

## 作者：VERACITY (赞：0)

## 思路
这里给出~~不严谨~~证明   

首先考虑高桥君在小镇里卖苹果的时候，每个卖出去的苹果可以在这个小镇及更早的小镇中苹果价格最便宜的地方买到。也就是说，高桥君在第 $i$ 个小镇卖苹果的时候，最大可以得到 $A_i-\min (A_1,A_2,\cdots,A_{i-1})$ 円。对于每个小镇的成本，我使用 $mn$ 数组进行记录；对于每个小镇的收益，我使用 $price$ 进行记录。     

得到上面的结论后，我们可以想到在 $price$ 最大的小镇尽可能卖更多的苹果能使收益最大化。也就是说，青木君想要减少高桥君的收益，就要使 $price$ 的最大值至少减少 $1$。

现在假设城市 $x$ 的 $price$ 是最大的，那么 $price_x=A_x-\min(A_1,A_2,\cdots,A_{x-1})$。接下来注意一点，每个 $A_i$ 互不相同，也就是说在 $A_1,A_2,\cdots,A_{x-1}$ 中只会有一个最小值。我们将 $price_x$ 表示为 $A_x-A_y$。    
一般来说，$price$ 最大的 $x$ 可能有多个，但每个 $A$ 是不同的，也就是说 当 $price_{x1}$ 和 $price_{x2}$ 都为最大值时，相对应的 $y1$ 和 $y2$ 都不同。所以得出重要结论：最大值有多个的时候，我们也可以通过减少每个 $price$ 的最大值来减少高桥君的最大收益，不会受到相同值的影响。

最后得出答案：$ans$ 为 $price$ 最大值的个数。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans,t,price[100005],mn[100005],mx=-1e9;
int main()
{
	mn[0]=1e9;//一定要注意赋初值
	cin >> n >> t;
	for(int i=1;i<=n;i++)	cin >> a[i];
	for(int i=1;i<=n;i++)   mn[i]=min(mn[i-1],a[i]);
	for(int i=1;i<=n;i++)	price[i]=a[i]-mn[i]，mx=max(mx,price[i]);
	for(int i=1;i<=n;i++)	if(price[i]==mx) ans++;
	cout<<ans;
	return 0;
}
```

---


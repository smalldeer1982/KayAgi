# [ABC092D] Grid Components

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc092/tasks/arc093_b

$ 2 $ つの整数 $ A,\ B $ が与えられます。

各マスが白または黒に塗られたグリッドであって以下の条件を満たすものを、出力の項で指定されたフォーマットに従って一つ出力してください。

- グリッドの大きさを縦 $ h $ 行横 $ w $ 列としたとき、$ h $ および $ w $ はともに $ 100 $ 以下である。
- 白く塗られたマスの集合はちょうど $ A $ 個の連結成分に分かれている (連結成分という単語の定義については後の注釈を参照)。
- 黒く塗られたマスの集合はちょうど $ B $ 個の連結成分に分かれている。

制約の項で指定される条件のもとで解は必ず一つ以上存在することが証明できます。 解が複数ある場合、どれを出力しても構いません。

## 说明/提示

### 注釈

$ 2 $ つの白く塗られたマス $ c_1,\ c_2 $が連結であるとは、マス $ c_1 $ からマス $ c_2 $ へ、上下左右に隣り合うマスへの移動を繰り返して、 白く塗られたマスだけを通って移動できることを意味します。

白く塗られたマスの集合 $ S $ が連結成分であるとは、$ S $ が以下の条件を満たすことを意味します。

- $ S $ のどの $ 2 $ つのマスも連結である。
- $ S $ に含まれないどの白く塗られたマスと、$ S $ に含まれるどのマスも連結ではない。

黒く塗られたマスについても連結成分を同様に定義します。

### 制約

- $ 1\ \leq\ A\ \leq\ 500 $
- $ 1\ \leq\ B\ \leq\ 500 $

### Sample Explanation 1

この出力は以下のグリッドに対応します。 !\[2701558bf42f7c088abad927b419472a.png\](https://img.atcoder.jp/arc093/2701558bf42f7c088abad927b419472a.png)

## 样例 #1

### 输入

```
2 3```

### 输出

```
3 3
##.
..#
#.#```

## 样例 #2

### 输入

```
7 8```

### 输出

```
3 5
#.#.#
.#.#.
#.#.#```

## 样例 #3

### 输入

```
1 1```

### 输出

```
4 2
..
#.
##
##```

## 样例 #4

### 输入

```
3 14```

### 输出

```
8 18
..................
..................
....##.......####.
....#.#.....#.....
...#...#....#.....
..#.###.#...#.....
.#.......#..#.....
#.........#..####.```

# 题解

## 作者：dottle (赞：8)

对于所有数据，我们都构造一个 $100\times 100$ 的矩阵。然后：

1.  将上半部分涂白，下半部分涂黑。
2.  选择上半部分的 $B-1$ 个格子不相邻且不会把白色隔断的格子涂黑，选择下半部分的 $A-1$ 个这样的格子涂白。

示意图：

![img](https://cdn.luogu.com.cn/upload/image_hosting/olqgr45x.png)

```cpp
#include<bits/stdc++.h>
#define int long long
const int N=155;
using namespace std;

char col[N][N];
const int A=50,B=100;

void solve(){
	int a,b;cin>>a>>b;
	a--,b--;
	cout<<B<<' '<<B<<endl;
	for(int i=1;i<=A;i++)
		for(int j=1;j<=B;j++){
			col[i][j]='.';
			col[i+A][j]='#';
		}
	for(int i=2;b;i+=2)
		for(int j=2;b&&j<=B;j+=2)
			col[i][j]='#',b--;
	for(int i=52;a;i+=2)
		for(int j=2;a&&j<=B;j+=2)
			col[i][j]='.',a--;
	for(int i=1;i<=B;i++){
		for(int j=1;j<=B;j++)
			cout<<col[i][j];
		cout<<endl;
	}
}

main(){
	ios::sync_with_stdio(0);
	int _T=1;//cin>>_T;
	while(_T--)solve();
}

```



---

## 作者：laiyouming (赞：4)

开始我们先把整个图一半变成白色一半变成黑色，然后在白色区域里把一些单元格变成黑色，在黑色区域里把一些单元格变成白色。
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m;
char a[110][110]; 
int main(){
	for(int i=1;i<=50;i++){
		for(int j=1;j<=100;j++){
			a[i][j]='.';
		}
	}
	for(int i=51;i<=100;i++){
		for(int j=1;j<=100;j++){
			a[i][j]='#';
		}
	}
	scanf("%lld%lld",&n,&m);
	n--,m--;
	for(int i=1;i<=50;i+=2){
		for(int j=1;j<=100;j+=2){
			if(n>0){
				n--;
				a[i+51][j]='.';
			}
			if(m>0){
				m--;
				a[i][j]='#';
			}
		}
	}
	printf("100 100\n");
	for(int i=1;i<=100;i++){
		printf("%s\n",a[i]+1);
	}
}
```

---

## 作者：Rannio (赞：1)

### 题意

题面说的很清楚了。

### 思路

注意到 $A$ 和 $B$ 最大都只有 $500$，而构造的矩阵最多可以有 $100\times 100 = 10000$ 个格子，所以显然是可以构造出来的。

一个比较直接的思路就是每次都构造一个 $100\times 100$ 的矩阵，上半部分涂黑，下半部分涂白，然后在上半部分取 $A-1$ 个格子涂白，在下半部分取 $B-1$ 个格子涂黑即可。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,b;
int numa,numb;
int mp[105][105];
signed main(){
    scanf("%lld%lld",&a,&b);
    a--,b--;
    printf("100 100\n");
    for(int i=0;i<=50;i++){
        for(int j=0;j<=101;j++){
            mp[i][j]=1;
        }
    }
    for(int i=1;i<=50;i++){
        if(!b) break;
        for(int j=1;j<=100;j++){
            if(!b) break;
            if(mp[i-1][j-1]+mp[i-1][j]+mp[i-1][j+1]+mp[i][j-1]+mp[i][j+1]+mp[i+1][j-1]+mp[i+1][j]+mp[i+1][j+1]==8){
                mp[i][j]=0;
                b--;
            }
        }
    }
    for(int i=51;i<=100;i++){
        if(!a) break;
        for(int j=1;j<=100;j++){
            if(!a) break;
            if(mp[i-1][j-1]+mp[i-1][j]+mp[i-1][j+1]+mp[i][j-1]+mp[i][j+1]+mp[i+1][j-1]+mp[i+1][j]+mp[i+1][j+1]==0){
                mp[i][j]=1;
                a--;
            }
        }
    }
    for(int i=1;i<=100;i++){
        for(int j=1;j<=100;j++){
            if(mp[i][j]) printf(".");
            else printf("#");
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：_6_awa (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/AT_arc093_b)

看了一下题解区，似乎只有我构造的方法最烂。

这道题的 $A$ 和 $B$ 只有惊人的五百，而 $100 \times 100$ 的矩阵有足足 $10000$ 个格子。可想而知这个矩阵是肯定能造出来 $1000$ 个连通块的。所以对于每个输入，我们都输出一个 $100 \times 100$ 的矩阵输出答案。

构造方法？这就很简单了。首先我们将矩阵全染成黑色，然后每隔一个格子就换成白色。因为矩阵范围很大，$500$ 个白色方块占用的空间不超过 $20$ 列。

```
.#.#.########
#############
.#.#.########
#############
.#.#.########
#############
.#.#.########
#############
```

此时黑色的连通块还是只有 $1$ 个，不会影响后续的操作。

如何构造黑色的连通块呢？白色的联通块此时已经用完，可以考虑将某个白色方块延伸将黑色方块隔断。为保证黑色方块的连通性，往下不能封顶，也就是到末尾两行时就要换一列重新分割。

```
.#.#...#.#.##
######.....##
.#.#.#.#.#.##
######.....##
.#.#.#.#.#.##
######.....##
.#.#.########
#############
```

考虑特殊情况。当 $B = 1$ 时，白色连通块延伸后就不会进行分割操作了。也就是说，特殊情况同样能输出正确的结果。

下面是实现的代码。

```cpp
#include <iostream>
using namespace std;
int h,w,x = -1,y = 1,p,q;
char a[105][105];
int main()
{
    cin >> h >> w;
    cout << "100 100\n";
    for(int i = 1;i <= 100;i ++)
    {
        for(int j = 1;j <= 100;j ++)a[i][j] = '#';
    }
    while(h --)
    {
        x += 2;
        if(x > 100)x = 1,y += 2;//换行
        a[x][y] = '.';
        if(x == 1)p = x,q = y;
    }//构造白色方块
    x = p,y = q;
    a[x][y + 1] = '.',y += 2;//延伸
    x = -1;
    while(w > 1)
    {
        x += 2;
        if(x > 98)y += 2,x = 1;//换行
        a[x][y] = a[x][y + 2] = a[x + 1][y] = a[x + 1][y + 1] = a[x + 1][y + 2] = '.';
        w --;
    }//分割黑色方块
    for(int i = 1;i <= 100;i ++)
    {
        for(int j = 1;j <= 100;j ++)cout << a[i][j];
        cout << '\n';
    }//输出矩阵
}
```

---

## 作者：Guizy (赞：1)

感觉只有黄？

考虑构造一个极大矩阵（$100\times 100$ 的），均分成两半，上半部分涂黑，下半部分涂白，这时黑白联通块个数均为 $1$。

但是题目要 $a$ 个白的，$b$ 个黑的，所以我们在上半部分中加 $a-1$ 个互不相邻的白点，下半部分加 $b-1$ 个互不相邻的黑点即可。具体操作就是把它们拆成四个四个的“田”字形的块，每个块中改右下角的那个，就可以保证它们互不相邻。

该方法正确的原因是因为 $1\le a,b\le 500$，并且 $\frac{100\times 50}{4}$ 有 $2500$ 左右，完全足够。

```cpp
#include<bits/stdc++.h>
using namespace std;

int a,b;

int main(){
	
	scanf("%d%d",&a,&b);
	
	puts("100 100");
	for(int i=1;i<=50;i++){
		for(int j=1;j<=100;j++)
			if(i&1||a==1||j&1) printf("#");
			else printf("."),a--;
		puts("");
	}
	for(int i=1;i<=50;i++){
		for(int j=1;j<=100;j++)
			if(i&1||b==1||j&1) printf(".");
			else printf("#"),b--;
		puts("");
	}
}
```

---

## 作者：zcr0202 (赞：0)

## 题目大意

给你两个数 $A$ 和 $B$，$A$ 代表的是连续的白色方块，用 ```.``` 来表示；$B$ 代表的是连续的黑色方块，用 ```#``` 来表示。现在让你给出一个矩阵，使得满足这个要求。

## 解题思路

首先我们准备一个矩阵，前半部分是 ```.```，后半部分是 ```#```。此时双方都已经各有了一个。接着我们开始处理黑色方块，我们需要在上半部分里让一些白色方块变成黑色方块，并且这些方块互相不能联通，因此我们可以让变成的黑色方块的周围保证是白色方块，有多少个就变多少个，白色方块同理，于是我们可以快乐的打代码了。

## Code

```cpp
#include<iostream>
using namespace std;
const int N = 1001;
const int n = 100;
int A, B;
int x, y;
char a[N][N];
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> A >> B;
	A--, B--;
	for(int i = 1; i <= n / 2; i++) {		//矩阵初始化
		for(int j = 1; j <= n; j++) {
			a[i][j] = '.';
			a[i + 50][j] = '#';
		}
	}
	for(int i = 2; i <= n / 2; i += 2) {	//处理黑色方块
		if(B == 0) break;
		for(int j = 2; j <= n; j += 2) {
			if(B == 0) break;
			a[i][j] = '#';
			B--;
		}
	}
	for(int i = n / 2 + 2; i <= n; i += 2) {	//处理白色方块
		if(A == 0) break;
		for(int j = 2; j <= n; j += 2) {
			if(A == 0) break;
			a[i][j] = '.';
			A--;
		}
	}
	cout << n << " " << n << '\n';		//输出
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			cout << a[i][j];
		}
		cout << '\n';
	}
	return 0;		//完结撒花
}
```

---

## 作者：_l_l_ (赞：0)

解法一样，考虑构造一个很大的矩阵，将其上下两半涂为不同颜色，然后挖坑涂不同的颜色以构造出很多连通块，具体可以见代码，这里提出一种新的实现方法。

有没有可能你可以自己构造矩阵，然后将多余的连通块取消呢？

优点是完全不用脑子，缺点是代码长度略大。

```cpp
#include <cstdio>
#include <cmath>
using namespace std;
int a[100005], b[100005];
char mp[44][100] = {
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#", // 49
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#",
	"###################################################################################################",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
	"...................................................................................................",
	".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.",
};
int main() {
	int a, b; scanf("%d %d", &a, &b); a = 539 - a + 1; b = 539 - b + 1;
	for (int i = 0; i < 22; i++) for (int j = 0; j < 99; j++) {
		if (mp[i][j] == '.' && a) mp[i][j] = '#', a--;
	}
	for (int i = 22; i < 44; i++) for (int j = 0; j < 99; j++) {
		if (mp[i][j] == '#' && b) mp[i][j] = '.', b--;
	}
	puts("44 99"); for (int i = 0; i < 44; i++) puts(mp[i]);
}
```

---

## 作者：_czy (赞：0)

## 分析
这题没有限制矩阵大小，所以可以构造一个很大的矩阵。

考虑将上下半部分各涂成一个颜色，每增加一个联通块，就在对面涂一个，详见代码。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
char ans[81][81];
int main(){
	scanf("%d%d",&a,&b);
	for(int i=1;i<41;i++){
		ans[i][0]='\n';
		for(int j=1;j<81;j++)ans[i][j]='#';
	}
	for(int i=41;i<81;i++){
		ans[i][0]='\n';
		for(int j=1;j<81;j++)ans[i][j]='.';
	}
	a--,b--;
	for(int i=1;i<40;i+=2){
		for(int j=1;j<81;j+=2){
			if(a)ans[i][j]='.',a--;
		}
	}
	for(int i=42;i<81;i+=2){
		for(int j=1;j<81;j+=2){
			if(b)ans[i][j]='#',b--;
		}
	}
	printf("80 80");
	printf("%s",ans[1]);
}
```

---

## 作者：hjyowl (赞：0)

构造题。

首先，有一点很重要，构造的矩阵的两边必须小于 $100$。

所以说，我们可以先考虑构造一个上面一半白色下面一半黑色的矩形（这里直接给他弄 $100\times100$，无所谓）。

然后，如果我们白色少了，那我们就在黑色区域上放上白色的，如果黑色的少了，那么就在白色区域上方（这里放的方法随便怎么样都可以，只要你放的那几个之间不能联通就可以了）。

最简单的一种构造，就是直接在所有第一行到第五十行之间的行数是偶数，列数也是偶数的地方给他换一种颜色，后面那一半的也一样。

代码：

```cpp
// LUOGU_RID: 177226354
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
char a[N][N];
int main(){
	int x,y;
	cin >> x >> y;
	x -- ,y -- ;
	for (int i = 1; i <= 50 ; i++ ){
		for (int j =1; j <= 100; j ++) {
			a[i][j] = '.';
		}
	}	
	for (int i = 51; i <= 100 ; i++ ){
		for (int j =1; j <= 100; j ++) {
			a[i][j] = '#';
		}
	}
	int dx = 2,dy = 2;
	while (y -- ){
		dy += 2;
		a[dx][dy] = '#';
		if (dy == 100){
			dx += 2,dy = 2;
		}
	}
	dx = 52,dy = 2;
	while (x -- ){
		dy += 2;
		a[dx][dy] = '.';
		if (dy == 100){
			dx += 2,dy = 2;
		}
	}
	cout << 100 << "  " << 100 << endl;
	for (int i = 1; i <= 100; i ++ ){
		for (int j = 1;j <= 100; j ++){
			cout << a[i][j];
		}
		cout << endl;
	} 
	return 0;
}
```

---


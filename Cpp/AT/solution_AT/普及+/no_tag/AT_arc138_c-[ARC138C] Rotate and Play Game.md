# [ARC138C] Rotate and Play Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc138/tasks/arc138_c

$ N $ 枚のカードがあり，$ 1 $ から $ N $ までの番号がついています． カード $ i $ には整数 $ A_i $ が書かれています． なお，ここで $ N $ は偶数です．

これから，すぬけ君と最小太郎君がゲームをします． ゲームは $ N $ ターンからなり，すぬけ君から始めて二人が交互にターンをプレイします． 各ターンでは，以下の操作を行います．

- すぬけ君のターン：まだ誰にも取られていないカードのうち，好きなものを一つ選び，取る．
- 最小太郎君のターン：まだ誰にも取られていないカードのうち，**番号**が最小のものを一つ選び，取る．

すぬけ君のスコアは，すぬけ君が取ったカードに書かれた整数の総和になります． すぬけ君はスコアを最大化するように最適に行動します．

ところで，すぬけ君の大ファンであるあなたは，とある不正を行うことでスコアを最大化しようと考えています． 具体的には，ゲームの開始前に，あなたは以下の行動を一回行います．

- 整数 $ k $ ($ 0\ \leq\ k\ \leq\ N-1 $) を選び，カードに書かれている整数を $ k $ 個左に cyclic-shift する． つまり，カード $ 1,2,\cdots,N $ に書かれている数を，$ A_{k+1},A_{k+2},\cdots,A_N,A_1,\cdots,A_k $ に置き換える．

スコアを最大化するためにあなたが選ぶべき $ k $ の値，およびその $ k $ を選んだ場合のスコアを求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は偶数
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

$ k=1 $ を選ぶと，カード $ 1,2,3,4 $ に書かれた整数は $ 4,1,2,3 $ になります． その後，ゲームは以下のように進行します． - すぬけ君がカード $ 1 $ を取る． - 最小太郎君がカード $ 2 $ を取る． - すぬけ君がカード $ 4 $ を取る． - 最小太郎君がカード $ 3 $ を取る． このときのすぬけ君のスコアは $ 7 $ になります． なお，この例では $ k=2,3 $ でも正解になります．

## 样例 #1

### 输入

```
4
3 4 1 2```

### 输出

```
1 7```

## 样例 #2

### 输入

```
2
1 1```

### 输出

```
0 1```

## 样例 #3

### 输入

```
10
716893678 779607519 555600775 393111963 950925400 636571379 912411962 44228139 15366410 2063694```

### 输出

```
7 3996409938```

# 题解

## 作者：Inui_Sana (赞：1)

不是，这个题的题解都不证明的？官解都没有？

容易猜测一定能取到前 $\frac n2$ 大数。考虑如何证明。

这个题原来的限制其实有点难看，考虑再加强限制，变成对方先取。此时问题显然不弱于原问题，不难发现此时可以将 B 取的视为 `(`，A 取的视为 `)`，则要求等价于括号串合法。

因为可以将开头若干个移到结尾，考虑把这个序列变成一个环。对于每一个 `)`，找到它在环上前面的第一个 `(`，让这两个配对。那么这种方案合法等价于存在一条环上 $(i,i+1)$ 的边，使得没有一个配对 $(x,y)$ 覆盖了这条边。这样就能断掉 $(i,i+1)$ 变成原问题中的序列。

然后就能发现这是恒成立的。证明考虑若不成立，一定存在如下情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/9xjpac20.png)

图中 $F,G$ 在环上是重合的，为了表示方便断成链形如 $F,G$ 两点。

也就是，此时 $(A,C),(B,E),(D,G)$ 配对。但是此时显然配对可以变成 $(A,G),(B,C),(D,E)$。于是这种情况不可能出现。得证。

得到这个证明后，剩下的也很简单。只用考虑和上面一样求出配对，差分得到每条边被覆盖了多少次，找到没有被覆盖过的边断掉即可。

code：

```cpp
int n,m,top,f[N],st[N];
bool vis[N],used[N];
pii a[N];
il void upd(int l,int r){
	if(l<=r){
		f[l]++,f[r]--;
	}else{
		f[l]++,f[1]++,f[r]--;
	}
}
void Yorushika(){
	read(n);
	rep(i,1,n){
		read(a[i].fi);
		a[i].se=i;
	}
	sort(a+1,a+n+1);
	ll ans=0;
	rep(i,n/2+1,n){
		vis[a[i].se]=1;
		ans+=a[i].fi;
	}
	rep(i,1,n){
		if(!vis[i]){
			st[++top]=i;
		}
	}
	rep(i,1,n){
		while(top&&used[st[top]]){
			top--;
		}
		if(vis[i]){
			upd(st[top],i);
			used[st[top--]]=1;
		}else if(!used[i]){
			st[++top]=i;
		}
	}
	rep(i,1,n){
		f[i]+=f[i-1];
	}
	rep(i,1,n){
		if(!f[i]){
			printf("%d %lld\n",i%n,ans);
			return;
		}
	}
	assert(0);
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：TillTheEnd (赞：1)

题意：A 先手玩游戏。有 $n$ 个数 $a_1-a_n$，A 每次可以任意取一个数，B 每次会取没有被取的数中下标最小的一数。保证 $n$ 为偶数。最大化 A 拿到的数字和。A 可以选择一个数字 $k \in [0,n)$，把第 $1$ 至第 $k$ 个数依次提到数组的最后面。求 $k$ 与最大化数字和。

首先我们猜测，最大的 $n/2$ 个数字可以被一起选走。

利用那个大一点的样例一试，还真可以！

那么，如何构造这样的 $k$ 呢？

数字大小已经不重要了，按照它们是否是最大的 $n/2$ 个数，我们把它们替换为 $0/1$。

A 不能让 B 取到 $1$。如果第 $i$ 步时失败了，说明前 $2i$ 个数中 $1$ 的个数超过 $0$ 的个数。

不妨把条件放宽点，我们尝试让前缀的任意 $i$ 个数 $1$ 的个数不多于 $0$ 的个数。

看到不多余与前缀，就想到 Catalan，就想到折线图。

上折线图，$1$ 表示往上走一步，$0$ 表示往下走一步。则折线图不能走到 $0$ 之上。

只要从折线图的最高点出发，就一定不会走到 $0$ 之上。因为起点终点的高度都是 $0$，前面任意数放到最后面时高度都是原有高度，所以不会超过原折线图最高点。

上面说可能有点抽象，来点具体例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/qons7ob9.png)

上面是 $6$ 个数的一个例子（请忽略标号混乱），对应数组 $[1,0,1,1,0,0]$

注意到 A5 是最高点，所以应当让新数组从 A5 开始，为 $[0,0,1,0,1,1]$。

结束。

[code](https://atcoder.jp/contests/arc138/submissions/33912408)

CSP2022 rp++

---

## 作者：XYQ_102 (赞：1)

第一步通过观察大样例发现，Snuke 一定会取走最大的 $n\div2$ 个元素。

那么我们考虑对于一个静态的序列，Snuke 如何能够成功取走最大的 $n\div2$ 个元素。

发现如果最大的（要取走的）$n\div2$ 个元素为 $-1$，剩余的为 $1$ 的话，相当于对于每一个位置，前缀和都不能为负（虽然只是充分，但不必要）。证明：每一轮中，Snuke 取走最靠前的  $-1$（肯定要避免他被抢走），然后 Mr.Min 照常取一个 $+1$，于是乎原序列前缀和的性质肯定还是满足的。

现在问题就变为如何求循环位移的偏移量。注意到根据括号序列的性质，其一定有解。

那么就将这个序列复制一份，然后看 $[i,i+n-1]$ 中的前缀和最小值是否 $\ge S_i$ 即可。可以使用 ST 表或者滑动窗口一类的来做。
```cpp
#include <bits/stdc++.h>
#define il inline
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
using namespace std;

using ll = long long;
const int maxn = 2e5 + 5;
int n, st[20][maxn << 1], lg[maxn << 1];

struct Node {
    ll val; int id;
} a[maxn << 1];

int main() {
    cin >> n;
    FOR(i, 1, n) cin >> a[i].val, a[i].id = i;
    sort(a + 1, a + n + 1, [](const Node &a, const Node &b) {return a.val > b.val;});
    ll sum = 0, tmp = a[n >> 1].val;
    FOR(i, 1, n >> 1) sum += a[i].val, a[i].val = 1;
    FOR(i, (n >> 1) + 1, n) a[i].val = -1;
    sort(a + 1, a + n + 1, [](const Node &a, const Node &b) {return a.id < b.id;});
    FOR(i, 1, n) a[n + i] = a[i];
    lg[0] = -1;
    FOR(i, 1, n << 1) st[0][i] = st[0][i - 1] + a[i].val, lg[i] = lg[i >> 1] + 1;
    FOR(j, 1, 19) FOR(i, 1, (n << 1) - (1 << j) + 1) st[j][i] = max(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
    const int s = 31 - __builtin_clz(n);
    FOR(i, 1, n) if (a[i].val == 1) {
        int ret = max(st[s][i], st[s][i + n - (1 << s)]);
        if (ret <= st[0][i]) return cout << i - 1 << ' ' << sum << endl, 0;
    }
    return 0;
}
```

---

## 作者：Phartial (赞：1)

提供一个无脑做法。

首先观察样例可以猜测我们必然可以取到前 $\dfrac n2$ 大的数，所以我们就可以把数列重标号成 $0/1$（不是/是前 $\dfrac n2$ 大的数）。

考虑枚举偏移量，对于当前序列，设 $c_{0/1}$ 表示当前数前面 $0/1$ 的数量，如果对于某个 $1$，$c_0<c_1$，那这个 $1$ 肯定会被对方删掉（因为把它前面 $c_0$ 个 $1$ 删完后，剩下的是一段连续的 $1$，必然会导致有 $1$ 被对方删掉），所以我们需要每个 $1$ 都满足 $c_0\ge c_1$。

考虑对每个 $1$ 维护 $b_i=c_0-c_1$。条件变成了 $\min(b_i)\ge 0$，而对于一次偏移，有两种情况：

- $a_1=0$：相当于每个 $1$ 的 $c_0$ 都减一，相应的，$b_i$ 也要减一。
- $a_1=1$：相当于除了这个 $1$ 以外的 $c_1$ 都减一，相应的，$b_i$ 需要加一。特别的，对于当前这个 $1$，它的 $b_i$ 显然为 $1$（$c_0=\dfrac n2,c_1=\dfrac n2-1$）。

由此，我们只需要支持全局加减，单点赋值，全局 $\min$ 即可，可以使用线段树，时间复杂度 $O(n\log n)$。

```cpp
#include <algorithm>
#include <iostream>

using namespace std;
using LL = long long;

const int kN = 2e5 + 1;

int n, a[kN], d[kN], _v[kN], v[kN << 2], bd;
LL ans;

void B(int x, int l, int r) {
  if (l == r) {
    v[x] = _v[l];
    return;
  }
  int m = l + r >> 1;
  B(x * 2, l, m), B(x * 2 + 1, m + 1, r);
  v[x] = min(v[x * 2], v[x * 2 + 1]);
}
void U(int x, int l, int r, int t, int _v) {
  if (l == r) {
    v[x] = _v;
    return;
  }
  int m = l + r >> 1;
  if (t <= m) {
    U(x * 2, l, m, t, _v);
  } else {
    U(x * 2 + 1, m + 1, r, t, _v);
  }
  v[x] = min(v[x * 2], v[x * 2 + 1]);
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    d[i] = i;
  }
  sort(d + 1, d + n + 1, [](int i, int j) { return a[i] < a[j]; });
  for (int i = 1; i <= n / 2; ++i) {
    a[d[i]] = 0;
  }
  for (int i = n / 2 + 1; i <= n; ++i) {
    ans += a[d[i]];
    a[d[i]] = 1;
  }
  sort(d + n / 2 + 1, d + n + 1);
  for (int i = 1, c[2] = {0}, j = 0; i <= n; ++i) {
    ++c[a[i]];
    _v[d[i] = ++j] = c[0] - c[1];
  }
  B(1, 1, n);
  for (int k = 0; k < n; ++k) {
    if (v[1] + bd >= 0) {
      cout << k << ' ' << ans;
      return 0;
    }
    if (a[k + 1]) {
      U(1, 1, n, d[k + 1], -bd);
      ++bd;
    } else {
      --bd;
    }
  }
  return 0;
}
```

---


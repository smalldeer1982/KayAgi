# 錬金術士

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2014-qualb/tasks/code_festival_qualB_c

高橋君は錬金術のプロフェッショナルです。

この世界の金属には、 $ 2N $ 文字（ $ N $ は整数）からなる名前が付けられており、名前は全て大文字アルファベットで構成されています。

高橋君が既存の金属 $ S1,\ S2 $ から新たな金属 $ S3 $ を錬金できる条件は、$ S1,S2 $ からそれぞれ $ N $ 文字ずつ取り出してきて、それらの文字を適当に並べ替えた結果、 $ S3 $ と一致するときです。

$ 3 $ つの金属の名前$ S1,\ S2,\ S3 $が与えられるので $ S1,\ S2 $ から $ S3 $ が錬金できるか判定してください。

## 说明/提示

### Sample Explanation 1

$ 1 $ つ目の金属から `AAD` 、 $ 2 $ つ目の金属から `AED` を取り出せば、 `EDDAAA` を作ることができます。

### Sample Explanation 2

$ 1 $ つ目の金属から少なくとも $ 4 $ 文字取り出さなければならないので錬金できません。

## 样例 #1

### 输入

```
AABCCD
ABEDDA
EDDAAA```

### 输出

```
YES```

## 样例 #2

### 输入

```
AAAAAB
CCCCCB
AAABCB```

### 输出

```
NO```

# 题解

## 作者：wdgm4 (赞：1)

居然没有题解，那我就来~~水~~一篇。

## 思路

题目要求在字符串 $S1$ 与 $S2$ 中各取出 $n$ 个字符来组成字符串 $S3$。

首先我们发现，要想成功组成字符串 $S3$，必须要让 $S1$ 与 $S2$ 中**每一种字符的数量**都大于等于 $S3$ 中每一种字符的数量。于是，我们可以用桶来去判断字符串 $S1$ 和 $S2$ 符不符合要求，如果不符合，就输出 ```NO```，并直接结束程序(指 ```return 0```)。

但这样还不够。例如题目中的样例二。

```
AAAAAB
CCCCCB
AAABCB
```

$S2$ 这个字符串只能取出两个字符来拼成 $S3$ （字符为 ```C``` 和 ```B```），由于题目要求要在 $S1$ 和 $S2$ 中**各取 $n$ 个字符**，所以上面的样例不符合要求，输出 ```NO```。

我们暂且将 $S1$ 能够取出的字符数量叫做 $S1$ 的贡献，$S2$ 同上。由于我们一开始的判断，如果程序没有结束，就说明 $S3$ 不管怎么拼一定能拼出来。那我们就可以判断 $S1$ 与 $S2$ 的贡献是否都大于等于 $n$，如果是，输出 ```YES```，否则输出 ```NO```。

------------

于是......

## code

```cpp
#include<bits/stdc++.h>
#define XD 114514

using namespace std;
string s1,s2,s3;
int a1[30],a2[30],a3[30];//分别为三个字符串的桶
int num1,num2,n;//num1,num2分别为s1,s2的贡献
int main(){
	cin>>s1>>s2>>s3;
	for(int i=0;i<s1.length();i++) a1[s1[i]-'A']++;
	for(int i=0;i<s2.length();i++) a2[s2[i]-'A']++;
	for(int i=0;i<s2.length();i++) a3[s3[i]-'A']++;//桶计数
	for(int i=0;i<26;i++){
		if(a1[i]+a2[i]<a3[i]){//第一个判断
			cout<<"NO\n";
			return 0;
		}
		num1+=min(a1[i],a3[i]);
		num2+=min(a2[i],a3[i]);
	}
	n=s1.length()/2;
	if(num1<n or num2<n) cout<<"NO\n";//第二个判断
	else cout<<"YES\n";
	return 0;
}

```


---


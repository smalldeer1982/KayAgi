# Pair Cards

## 题目描述

## 题意：

已知高桥君有 $n$ 张卡片，每一张卡牌上有一个整数 $x_i$。高桥君想要以以下两种条件合并两张卡牌：

$1$：两张卡牌上的整数相等。

$2$：两张卡牌上的整数之和是 $m$ 的倍数。

求出高桥君可以组成多少组的组数最大值。

注：一张卡牌不能在多组中使用。


------------

## 说明/提示

$2\le n \le 10^5$，$1\le m \le 10^5$，$1 \le x_i \le 10^5$。

## 样例 #1

### 输入

```
7 5
3 1 4 1 5 9 2```

### 输出

```
3```

## 样例 #2

### 输入

```
15 10
1 5 6 10 11 11 11 20 21 25 25 26 99 99 99```

### 输出

```
6```

# 题解

## 作者：kanzaki (赞：0)

## 思路

分别计算相同整数的卡片成对和没有成对的有多少，再按照 $\bmod m$ 后的大小分类。按条件二分组时优先将没有成对的卡片分为一组即可。

这样分类的原因是目前成对的卡片按照条件一已经可以成组。此时额外计算有多少与自己无法成对的卡片并尝试用条件二成组即可。

详细实现过程见代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 100005
int n,m;
int a[maxn],b[maxn],c[maxn];
int main(){
	cin>>n>>m;
	for(int i=1,x;i<=n;i++){
		cin>>x;
		c[x]++;
	}
	for(int i=1;i<=100000;i++){
		b[i%m]+=c[i]/2;
		a[i%m]+=c[i]%2;
	}
	int ans=a[0]/2+b[0];
	if(m%2==0) ans+=a[m/2]/2+b[m/2];//需要特殊判断避免重复计算这一组
	for(int i=1;i<=(m+1)/2-1;i++){//上界不为m/2的原因是上文已经特殊判断过m/2，避免算重
		int res=min(a[i],a[m-i]);
		ans+=res;
		a[i]-=res,a[m-i]-=res;
		if(a[i]){
			res=min(a[i]/2,b[m-i]);
			ans+=res*2;
			a[i]-=res*2,b[m-i]-=res;
		}
		if(a[m-i]){
			res=min(a[m-i]/2,b[i]);
			ans+=res*2;
			b[i]-=res,a[m-i]-=res*2;
		}
		ans+=b[i]+b[m-i];
	}
	cout<<ans<<'\n';
	return 0;
}
```

---


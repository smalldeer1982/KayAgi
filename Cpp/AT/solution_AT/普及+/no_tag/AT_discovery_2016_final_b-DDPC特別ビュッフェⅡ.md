# DDPC特別ビュッフェⅡ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/discovery2016-final/tasks/discovery_2016_final_b

DISCO presents ディスカバリーチャンネルプログラミングコンテスト 2016本戦のDDPC特別ビュッフェの時間が始まりました。あなたはこれから料理の載っていないトレーに料理を載せに行くところです。 DDPC特別ビュッフェには $ N $ 種類の料理があります。 $ i $ 種類目の料理はビュッフェの開始から $ T_i $ 秒後になくなり、料理の美味しさは $ A_i $ です。

DDPC特別ビュッフェにはいくつかの特別なルールがあります。

- あなたは $ 1 $ 種類の料理をトレーに載せるのに $ 1 $ 秒かけなくてはならない。すなわち料理を載せ始めた時刻が $ s $ であったとき、料理を載せ終わったときの時刻は $ s+1 $ となる。
- あなたは以前にトレーに載せた料理と同じ種類の料理を載せてはならない。
- 現在の時刻 $ s $ が$ s+1≦T_i $ を満たさないとき、種類 $ i $ の料理をトレーに載せることはできない。

あなたはトレーに載っている料理の美味しさの総和が $ X $ 以上になったところで席に戻ることにしました。トレーに載っている料理の美味しさの総和を $ X $ 以上にすることが可能な最小の時刻 $ t $ を求めてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ T_i\ <\ T_j $ のとき、$ A_i≧A_j $ を満たすようなデータセットに正解した場合 $ 10 $ 点が与えられる。
- 追加制約のないデータセットに正解した場合さらに $ 40 $ 点が得られ合計 $ 50 $ 点が得られる。

### Sample Explanation 1

\- 以下のような料理の取り方をすることで、時刻 $ 2 $ にトレーに載っている料理の美味しさの総和が $ 5 $ 以上にすることが可能です。 - $ 0 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 0 $ です。種類 $ 1 $ の料理をトレーに載せます。 - $ 1 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 3 $ です。種類 $ 2 $ の料理をトレーに載せます。 - $ 2 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 6 $ です。 - このケースは部分点の追加制約を満たします。

### Sample Explanation 2

\- 以下のような料理の取り方をすることで、時刻 $ 3 $ にトレーに載っている料理の美味しさの総和が $ 10 $ 以上にすることが可能です。 - $ 0 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 0 $ です。種類 $ 1 $ の料理をトレーに載せます。 - $ 1 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 3 $ です。種類 $ 2 $ の料理をトレーに載せます。 - $ 2 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 6 $ です。種類 $ 3 $ の料理をトレーに載せます。 - $ 3 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 10 $ です。 - このケースは部分点の追加制約を満たしません。

### Sample Explanation 3

\- 以下のような料理の取り方をすることで、時刻 $ 1 $ にトレーに載っている料理の美味しさの総和が $ 5 $ 以上にすることが可能です。 - $ 0 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 0 $ です。種類 $ 3 $ の料理をトレーに載せます。 - $ 1 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 6 $ です。 - このケースは部分点の追加制約を満たします。

### Sample Explanation 4

\- どのように料理をとっても、トレーに載っている料理の美味しさの総和を $ 101 $ 以上にすることはできません。 - このケースは部分点の追加制約を満たします。

### Sample Explanation 5

\- 時刻 $ 0 $ でどちらの料理をとっても、もう片方の料理が時刻 $ 1 $ でなくなってしまうため、トレーに載っている料理の美味しさを $ 2 $ 以上にすることはできません。 - このケースは部分点の追加制約を満たします。

### Sample Explanation 6

\- 以下のような料理の取り方をすることで、時刻 $ 2 $ にトレーに載っている料理の美味しさの総和が $ 6 $ 以上にすることが可能です。 - $ 0 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 0 $ です。種類 $ 2 $ の料理をトレーに載せます。 - $ 1 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 4 $ です。種類 $ 4 $ の料理をトレーに載せます。 - $ 2 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 6 $ です。 - このケースは部分点の追加制約を満たします。

### Sample Explanation 7

\- 以下のような料理の取り方をすることで、時刻 $ 2 $ にトレーに載っている料理の美味しさの総和が $ 4 $ 以上にすることが可能です。 - $ 0 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 0 $ です。種類 $ 2 $ の料理をトレーに載せます。 - $ 1 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 2 $ です。種類 $ 3 $ の料理をトレーに載せます。 - $ 2 $ 秒目の時点でトレーに載っている料理の美味しさの総和は $ 4 $ です。 - このケースは部分点の追加制約を満たしません。

## 样例 #1

### 输入

```
4 5
1 2 3 4
3 3 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 10
1 2 3
3 3 4```

### 输出

```
3```

## 样例 #3

### 输入

```
3 5
9 9 4
2 2 6```

### 输出

```
1```

## 样例 #4

### 输入

```
5 101
1 2 3 4 5
20 20 20 20 20```

### 输出

```
-1```

## 样例 #5

### 输入

```
2 2
1 1
1 1```

### 输出

```
-1```

## 样例 #6

### 输入

```
4 6
1 1 2 2
3 4 1 2```

### 输出

```
2```

## 样例 #7

### 输入

```
3 4
1 2 2
1 2 2```

### 输出

```
2```

# 题解

## 作者：缪凌锴_Mathew (赞：0)

### 题目大意

给你 $n$ 碟菜，第 $i$ 碟菜有 $a_i$ 的价值，在 $t_i$ 秒时，这碟菜会消失。

初始 $0$ 秒，你可以用 $1$ 秒的时间吃掉一碟菜，但如果这碟菜消失了，就不能吃。

也就是说，当前时间为 $s$ 秒，若 $s+1 \le t_i$，则你可以吃掉第 $i$ 碟菜，$s$ 变为 $s+1$。

当吃掉的菜价值总和不小于 $m$ 时，你就吃饱了。

求你最少几秒才能吃饱（可能不能吃饱，无解）。

### 解题思路

考虑贪心，每秒钟取当前价值最高的菜。

发现很容易 Hack。

比如：$n=2,m=3,a={1,2},t={1,2}$。

这样就会先吃掉第 $2$ 盘菜，然后第 $1$ 盘菜就消失了，贪心策略失败。

发现其实可以反悔贪心，优先吃快消失的菜。

当前菜已消失时，就可以将过去吃过价值最低的菜替换为当前菜，即反悔。

最后把吃掉的多余的菜去掉，剩下菜的数量即为答案。

### 代码

```cpp
#include<map>
#include<set>
#include<cmath>
#include<ctime>
#include<queue>
#include<stack>
#include<cstdio>
#include<vector>
#include<string>
#include<bitset>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10;
const int N=1e5;
const int INF=0x3f3f3f3f;
const long long LINF=0x3f3f3f3f3f3f3f3f;
int n,m;
struct node{
    int t,val;//菜的消失时间和价值
}a[MAXN];
bool cmp(node x,node y){
    return ((x.t<y.t)|(x.t==y.t&&x.val>y.val));
}
priority_queue < int,vector<int>,greater<int> > q;
signed main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i].t);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i].val);
    }
    sort(a+1,a+1+n,cmp);//贪心，先按消失时间排序
    int tim=0;//当前时间
    long long sum=0;//价值总和
    for(int i=1;i<=n;i++)
    {
        if(tim+1<=a[i].t){//够吃得下当前菜
            sum+=a[i].val;
            q.push(a[i].val);
            tim++;
        }
        else if((!q.empty())&&(q.top()<a[i].val)){//不够吃下当前菜，返回
            sum-=q.top();
            sum+=a[i].val;
            q.pop();
            q.push(a[i].val);
        }
    }
    if(sum<m){
        puts("-1");
        return 0;
    }
    while(sum-q.top()>=m)//把吃掉的多余的菜去掉
    {
        tim--;
        sum-=q.top();
        q.pop();
    }
    printf("%d\n",tim);
    return 0;
}
```

---


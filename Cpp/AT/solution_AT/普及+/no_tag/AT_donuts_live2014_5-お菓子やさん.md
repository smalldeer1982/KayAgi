# お菓子やさん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/donuts-live2014/tasks/donuts_live2014_5

幼少のパンチくんは、全部で $ N $ 店あるお菓子やさんを巡ろうとしています。

このうちのいくつかの店では、スタンプをカードに押してもらえます。その店のスタンプがあると、さらに別のいくつかの店で、ボーナスのお菓子がもらえるというシステムです。

ただし、パンチくんは一度行った店には $ 2 $ 回行きたくありません。そのため、例えば

- 店 $ A $ のスタンプがあると、店 $ B $ でお菓子が $ 3 $ 個もらえる
- 店 $ B $ のスタンプがあると、店 $ A $ でお菓子が $ 2 $ 個もらえる

という $ 2 $ つの条件が重なっている場合 、どちらかのお菓子を諦めなければいけません。この場合、後者を諦めて、前者の $ 3 $ 個のお菓子をもらうのが得です。

パンチくんがもらえるお菓子の最大値はいくらでしょうか。

## 说明/提示

### 部分点

$ 1\ ≦\ N\ ≦\ 8 $ を満たすテストケースに正解した場合、部分点として $ 130 $ 点が与えられる。

### Sample Explanation 1

問題文に記載されている例です。

### Sample Explanation 2

全てのお菓子をもらうことが出来ます。

### Sample Explanation 3

$ 10 $ 個のお菓子を諦めることで、最大値を得ます。

### Sample Explanation 4

同じ店に $ 2 $ 回行くことはできないので、お菓子はもらえません。また、このスタンプサービスと関係ない店がいくつかあることもあります。

## 样例 #1

### 输入

```
2 2
1 2 3
2 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3
1 2 10
1 3 20
1 4 30```

### 输出

```
60```

## 样例 #3

### 输入

```
3 3
1 2 20
2 3 30
3 1 10```

### 输出

```
50```

## 样例 #4

### 输入

```
16 1
4 4 1000```

### 输出

```
0```

## 样例 #5

### 输入

```
4 6
4 1 3
1 3 3
4 2 3
3 4 2
2 3 3
2 2 10```

### 输出

```
12```

# 题解

## 作者：Elairin176 (赞：0)

[传送门](https://www.luogu.com.cn/problem/AT_donuts_live2014_5)    
这一道题所属的 atc 比赛是 dp 专场吗？怎么除了第一题全是 dp 啊。     
## 题意
有 $n$ 个商店，现在还有 $m$ 条奖励制度。    
每一条奖励制度如下：如果到达了第 $i$ 个商店，那么之后**再**去第 $j$ 个商店时，这个商店就会额外赠送 $k$ 颗糖。如果去了一个商店，但没有触发关于这个商店的奖励制度，那么将不会获得糖。     
显然，我们可以安排一个顺序，让最后得到的糖的数量最多，现在要求求出最多能得到多少糖。    
注意不能重复到同一个商店且所有商店必须都到过一次。   
## 解法
显然对于任何一个商店，只有去和不去两种状态。但是 $1\le n\le 16$，开 $16$ 维难以维护。所以我们可以进行状态压缩，把这 $16$ 位压成一个二进制数。    
那我们的状态就很简单了：只需要设 $dp_i$ 为当前二进制状态为 $i$ 的情况的最大糖数就可以了。   
考虑转移：    
- 我们先预处理边界情况，即二进制串中**有且仅有**一个 $1$ 的情况，这种情况结果显然只能是 $0$，而我们在 dp 过程中要跳过这些状态。    
- 我们对于其他的二进制串，可以先把它所有的 $1$ 的位置预处理出来。我们接下来遍历这些位置，遍历到的我们可以看作是这一次我们取的，这样就可以实现转移的操作。    
- 注意转移的时候要特判自己的奖励制度指向自己的情况。   

转移需要求出指定的一位额外贡献了多少答案。这个也很好维护：   
- 我们可以把输入的 $m$ 条关系抽象成一张图，反向建边。为何要反向建边呢？如果正向建边，发现奖励制度不能很好地进行计算。反向建边就相当于“发散”的过程，可以更快的维护。  

最后的答案在 $dp_{2^n-1}$。   
[CODE](https://atcoder.jp/contests/donuts-live2014/submissions/44696478)

---


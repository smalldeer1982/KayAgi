# 直径

## 题目描述

### 题目背景
鳗鱼王国有一个名为鱼鳗王国的邻国。这两个王国都有许多的大城市，这些城市之间有一些道路相连。然而现在，鳗鱼王国和鱼鳗王国之间没有互通的道路。所以，鳗鱼王国的国王殿下为了和鱼鳗王国构筑友好关系，打算在两个城市间建设一条道路，因为有很多条可以建设的道路，对运费很敏感的国王殿下想知道两两城市间最短距离的最大值。
给出顶点数 $n_1$，边数 $m_1$ 的无向图 $G_1$ 和顶点数 $n_2$，边数 $m_2$ 的无向图 $G_2$。每个图都是连通图。换句话说，对于每张图来说，任意的两个顶点间都有直接或间接的道路连接。请回答出在两张图之间任加一条边后构成的图形中，最远的两个顶点的距离（称为图形的直径）的最小值和最大值。

## 说明/提示

输入中的各变量满足以下条件。
- $1 \leq n_{1},n_{2} \leq 1000(=10^4)$
- $0 \leq m_{1},m_{2} \leq 10000(=10^5)$
- $0 \leq a_i,b_i<n_1$
- $0\leq c_i,d_i<n_2$
- 每张图为连通图
- 每张图为简单图，也就是说没有重边与自环。

对于 $50\%$ 的数据，$1\leq n_1,n_2\leq20$。

#### 样例解释
【样例解释 1】

直径为 $3$ 及直径为 $5$ 的情况见下图：

![样例解释1](https://img.atcoder.jp/other/utpc2013/C_sample_1.png)

【样例解释 2】

直径为 $7$ 及直径为 $11$ 的情况见下图：

![样例解释2](https://img.atcoder.jp/other/utpc2013/C_sample_2.png)

【样例解释 3】

请注意此处的最小值。

## 样例 #1

### 输入

```
4 5
0 1
0 2
0 3
1 2
2 3
4 5
0 1
0 2
0 3
1 2
2 3
```

### 输出

```
3 5
```

## 样例 #2

### 输入

```
6 5
0 1
1 2
2 3
3 4
4 5
6 5
0 1
1 2
2 3
3 4
4 5
```

### 输出

```
7 11
```

## 样例 #3

### 输入

```
7 6
0 1
1 2
2 3
3 4
4 5
5 6
2 1
0 1
```

### 输出

```
6 8
```

# 题解

## 作者：tjtdrxxz (赞：11)

首先，不难发现，加入一条边后的图的直径就是这两个图的直径相加再加 $1$（毕竟加的那条边还有长度）。

然后又发现 $ n1,n2 \le 10^4 $，而限时是 $ 2s $，所以我们可以 $ n^2 $ 枚举加的那条边，然后 $ O (1) $ 求答案。

为了能 $ O (1) $ 求出，我们只需要先预处理出两个图中任意一点为起点的直径，我们以 $ dis_{i, j} $ 为从 $ i $ 到 $ j $ 的最短路径，而直径就是 $ dis_i $ 中的最大值。

warning：最小的直径是要大于两个图的直径的，所以统计答案的时候好需要多判断一下。

因为图上传的时候炸了，其他题解也有图了，所以不放了（逃

code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	register char in = getchar(),f = 0;register int t = 0;
	for(;in < '0' || in > '9'; in = getchar())if(!(in ^ 45))f = 1;
	for(;in >= '0' && in <= '9';in = getchar())
	 t = (t << 1) + (t << 3) + (in ^ 48);
	return f ? -t : t;
}
inline void write(register int x)
{
	static int t[10]; register int tp = 0;
	if(x == 0) return(void)(putchar('0'));
	else if(x < 0) putchar('-'),x = -x;
	while(x) t[tp++] = x % 10,x /= 10;
	while(tp--) putchar(t[tp] + 48);
}
#define stdi stdin
#define stdo stdout
int vis[1000012];
int dis[1000012];
int a[1000012];
int b[1000012];
struct node
{
	int v,w;
	node(int v,int w) : v(v),w(w) {}
};
vector<node> e[1000012];
queue<int> q;
int bfs(int s)
{
	int ret = 0;
	q.push(s);
	vis[s] = 1;
	dis[s] = 0;
	while(!q.empty())
	{
		register int u = q.front();q.pop();
		for(int i = 0;i < e[u].size();i++)
		{
			register int v = e[u][i].v;
			if(dis[v] > dis[u] + 1)
			{
				dis[v] = dis[u] + 1;
				ret = max(ret,dis[v]);
				q.push(e[u][i].v);
			}
		}
	}
	return ret;
}
int n,m,n1,n2,p1,p2;
signed main()
{
	scanf("%lld %lld",&n,&m);
	n1 = n;
	for(int i = 1;i <= n;i++) e[i].clear();
	for(int i = 1;i <= m;i++)
	{
		int U = read() + 1,V = read() + 1;
		e[U].push_back(node(V,1));
		e[V].push_back(node(U,1));
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= n;j++)dis[j] = 998244353;
		dis[i] = 0,a[i] = bfs(i); p1 = max(p1,a[i]);
	}
	scanf("%lld %lld",&n,&m);
	n2 = n;
	for(int i = 1;i <= n;i++) e[i].clear();
	for(int i = 1;i <= m;i++)
	{
		int U = read() + 1,V = read() + 1;
		e[U].push_back(node(V,1));
		e[V].push_back(node(U,1));
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= n;j++)dis[j] = 998244353;
		dis[i] = 0,b[i] = bfs(i); p1 = max(p1,b[i]);
	}
	int ans1 = INT_MIN;
	int ans2 = INT_MAX;
	for(int i = 1;i <= n1;i++)
	 for(int j = 1;j <= n2;j++)
	 {
		 ans1 = max(ans1,a[i] + b[j] + 1);
		 ans2 = min(ans2,max(a[i] + b[j] + 1,max(p1,p2)));
	 }
	printf("%lld %lld\n",ans2,ans1);
}
```

---

## 作者：bmyjacks (赞：10)

### 宣传一下某蒟蒻的blog
[更好的阅读体验](https://www.bmyjacks.cn/2021/at838/)

# 首先来理解题目的意思

* 输入两幅图 $G_{1}$ 与 $G_{2}$，分别拥有 $n_{1}$ 与 $n_{2}$ 个点，$m_{1}$ 与 $m_{2}$ 条边
* 要求在两图中间添加一条边使两图联通并求出所得到的新图的**最大直径**与**最小直径**

# 思路

## 存图

```cpp
const int MAX_N = 1005;
class Edge {
 public:
  int from, to;
};
vector<Edge> G[MAX_N];
```



## 直径

### 定义

对于**直径**的定义为 : **图上任意两点的最短距离的最大值**

以下方的图为例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/m6mksmoo.png)

各点到另外的点之间的**最短距离**为

$$
1 \stackrel{1}{\rightleftharpoons} 2 \quad
1 \stackrel{2}{\rightleftharpoons} 3 \quad
1 \stackrel{1}{\rightleftharpoons} 4 \quad
1 \stackrel{2}{\rightleftharpoons} 5 \\
2 \stackrel{1}{\rightleftharpoons} 3 \quad
2 \stackrel{1}{\rightleftharpoons} 4 \quad
2 \stackrel{2}{\rightleftharpoons} 5 \\
3 \stackrel{2}{\rightleftharpoons} 4 \quad
3 \stackrel{1}{\rightleftharpoons} 5 \\
4 \stackrel{1}{\rightleftharpoons} 5 \\
$$

则该图的**直径**为 $2$。

### 直径的求法

#### 两遍 BFS

1. 先在图上随便选取一个点，对他进行 BFS 后，找到离它最远的点。（为了到达图的边缘）
2. 在最远的点上再进行一次 BFS ，此时它与离它最远的那个点之间的最短距离即为该图的直径。

例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/9btgnhd2.png)

1. 假设随机选取的点为 $5$，则进行 BFS 后选取的点为 $9$。
2. 再在 $9$ 进行一次 BFS ，得到的点为 $8$，那么该图的直径为 $9$ 到 $8$ 的距离 $6$。

代码（C++11）

```cpp
void bfs(const int from = 1) { // 默认从1开始搜索
  queue<Edge> que;
  que.push(Edge{from, 0});  // 联赛中修改为 'que.push((Edge) {from, 0})'

  while (!que.empty()) {
    Edge now = que.front();
    que.pop();

    for (int i = 0; i < G[now.from].size(); ++i) {
      Edge edge = G[now.from][i];
      if (dis[edge.to] > dis[edge.from] + 1) {
        dis[edge.to] = dis[edge.from] + 1;
        que.push(Edge{edge.to, 0});  //联赛中修改为 'que.push((Edge) {edge.to, 0})'
      }
    }
  }
}
```

进行一次 BFS 之后再来一次即可

#### 单源最短路

##### dijkstra

直接在图上每个点都跑一遍 dijkstra，再取最大值即可。代码相似于 BFS，由于每条边的权值都一样，这道题可不使用`priority_queue`

##### SPFA

它死了

# 求解

我们发现，对于添加一条边后**新图**的**直径** $d_{G_{new}}$ 满足
$$
d_{G_{new}} \leq d_{G_{1}} + d_{G_{2}} + 1
$$

### 最长直径

则**新图**的最长直径为
$$
d_{G_{new} \ max} = d_{G_{1}} + d_{G_{2}} + 1
$$

### 最短直径

* 构建成的新图的**最短**直径必然大于 $d_{G_{1}}$ 与 $d_{G_{2}}$（样例3）

* 而最短直径为 $G_{1}$ 与 $G_{2}$ 中最远两点之间距离（可在 BFS 或 dijkstra 时顺便求出）的最小值之和再加一

* $$
  d_{G_{new} \ min} = max(G_{1} \ min + G_{2} \ min + 1, \ max(d_{G_{1}}, d_{G_{2}}))
  $$


综上，可 AC 此题。

蒟蒻第一次写题解，不足之处还请大家提出并谅解。

---

## 作者：SfumatoCannon_ (赞：4)

### Solution
首先考虑这样一个样例：
![](https://cdn.luogu.com.cn/upload/image_hosting/utk8ihtd.png)

先想一下，对于这个样例，我们如何求添加边之后的最大直径。

在添边之前，让我们先分别求一下两个图的直径：（如图用红线标示）

![](https://cdn.luogu.com.cn/upload/image_hosting/ok7daaov.png)

这时我们发现：**因为所有边的长度都为1，添加的边也是这样，所以添加边的位置对答案没有影响，**

那么，我们把这两条最长的路径连接起来，不就是最终答案吗？

![](https://cdn.luogu.com.cn/upload/image_hosting/jd6rlj78.png)

当然，如下图所示，所有的蓝色虚线都是最佳方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/w059qdsr.png)

不过这些线的位置并不重要，我们要求的是答案，而由上我们不难发现：**答案=A图直径+B图直径+1**。

那么```A图直径```和```B图直径```怎么求呢？其实很简单，就是一个暴力的求法：先求出图中的多源最短路，然后找出```dis[i][j]```最大值即可。

同理最小的答案也是一样的，不过我们要求的不是```图的直径```，而是```以某个点为起点，所能到达的最远的点的距离的最小值```。（前面这句话有点绕，多读几遍就很容易理解）

最后，有几个要注意的坑点：

* 点的权值是```0 ~ n-1```.

* 如果求出的最小答案比某个图的直径还要小，那么最终答案是这个图的直径。（其实样例```#3```已经提示过了）

* 虽然数据范围 $n\le10^3$，但是用Floyd算法求最短路仍然会TLE，（也可能是我代码常数过大的缘故？）总之因为每条边的长度都为1，所以建议使用BFS算法来求点与点之间的最短路。
***
### code
```cpp
#include <cstdio>
#include <queue>
using namespace std;
#define MAXN 2001
#define MAXM 20001
#define inf 1000000000
struct Edge
{
    int to, next;
} bian[MAXM];
int h[MAXN], dis[MAXN];
int n, m, t;
void csh()
{
    t = 0;
    for (int i = 1; i <= n; i++)
        h[i] = 0;
}
void add(int x, int y)
{
    t++;
    bian[t].next = h[x];
    bian[t].to = y;
    h[x] = t;
}
void work(int start)
{
    queue<int> Q;
    int i, k;
    for (i = 1; i <= n; i++)
        dis[i] = inf;
    dis[start] = 0;
    Q.push(start);
    while (!Q.empty())
    {
        k = Q.front();
        Q.pop();
        for (i = h[k]; i; i = bian[i].next)
        {
            if (dis[k] + 1 < dis[bian[i].to])
            {
                dis[bian[i].to] = dis[k] + 1;
                Q.push(bian[i].to);
            }
        }
    }
}
int main()
{
    scanf("%d%d", &n, &m);
    int i, j, x, y;
    int ans1_max = -1, ans1_min = inf, ans2_max = -1, ans2_min = inf, t;

    csh();
    for (i = 1; i <= m; i++)
    {
        scanf("%d%d", &x, &y);
        add(x + 1, y + 1);
        add(y + 1, x + 1);
    }
    for (i = 1; i <= n; i++)
    {
        t = -1;
        work(i);
        for (j = 1; j <= n; j++)
            t = max(t, dis[j]);
        ans1_max = max(ans1_max, t);
        ans1_min = min(ans1_min, t);
    }

    csh();
    scanf("%d%d", &n, &m);
    for (i = 1; i <= m; i++)
    {
        scanf("%d%d", &x, &y);
        add(x + 1, y + 1);
        add(y + 1, x + 1);
    }
    for (i = 1; i <= n; i++)
    {
        t = -1;
        work(i);
        for (j = 1; j <= n; j++)
            t = max(t, dis[j]);
        ans2_max = max(ans2_max, t);
        ans2_min = min(ans2_min, t);
    }
    if (ans1_min + ans2_min + 1 < max(ans1_max, ans2_max))
        printf("%d %d\n", max(ans1_max, ans2_max), ans1_max + ans2_max + 1);
    else
        printf("%d %d\n", ans1_min + ans2_min + 1, ans1_max + ans2_max + 1);
    return 0;
}
```


---

## 作者：Doveqise (赞：3)

这道题好像BFS是非正解来着QAQ  
这里来一道BFS题解（良心BFS入门题）  
觉得代码比较简明QwQ  
细节下见代码↓
```c++
#include<bits/stdc++.h>
#define N 1005
using namespace std;
vector <int> vec[N][2];
int dist[N];
int bfs(int x,int p){
  queue <int> que;
  memset(dist,-1,sizeof(dist));
  dist[x]=0;que.push(x);int mx=0;
  while(!que.empty()){
    int v=que.front();que.pop();
    mx=dist[v];
    for(int i=0;i<vec[v][p].size();i++){
      int to=vec[v][p][i];
      if(dist[to]==-1){
        dist[to]=dist[v]+1;
        que.push(to);
      }
    }
  }
  return mx;
}
signed main(){
  int mn=1,mx=1;
  int rmn=0;
  for(int i=0;i<2;i++){
    int n,m;
    scanf("%d %d",&n,&m);
    for(int j=0;j<m;j++){
      int a,b;scanf("%d %d",&a,&b);
      vec[a][i].push_back(b);
      vec[b][i].push_back(a);
    }
    int nmn=N,nmx=0;
    for(int j=0;j<n;j++){
      int vl=bfs(j,i);
      nmn=min(nmn,vl);
      nmx=max(nmx,vl);
    }
    mn+=nmn;mx+=nmx;
    rmn=max(rmn,nmx);
  }
  printf("%d %d\n",max(mn,rmn),mx);
  return 0;
}

```

---

## 作者：SuyctidohanQ (赞：0)

### 题目分析

对于一条新边，其直径共有三种情况，即：第一张图的原直径，第二张图的原直径或加上一条边后的新直径。我们可以先预处理出两张图上每个点到其图上最远的一个点的距离，最后在连接的时候把将要连接的两个点的最远距离相加再加 $1$，最后尝试将每两个点连接比较三者即可得出答案。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e6 + 10;
priority_queue<pair<int,int> >q;
int head[MAXN], tot = 0, vis[MAXN], dis[MAXN], minsn = INT_MAX, maxx = INT_MIN, minnn = INT_MAX, maxxx = INT_MIN, n, m, s;
struct Edge {
    int s, val, Next;
}edge[MAXN];
void add (int x, int y) {
	edge[++ tot].s = y;
	edge[tot].Next = head[x];
	head[x] = tot;
}
int Dijkstra (int s) {
    memset (vis, false, sizeof (vis));
    for (int i = 1; i <= n; i ++) dis[i] = INT_MAX;
    dis[s] = false;
	q.push (make_pair (0, s));
	while (q.size ()) {
		int sat = q.top ().second;
		q.pop ();
		for (int i = head[sat]; i != 0; i = edge[i].Next) {
			if (!vis[edge[i].s] && dis[edge[i].s] > dis[sat] + 1) {
				dis[edge[i].s] = dis[sat] + 1;
				q.push (make_pair (-dis[edge[i].s], edge[i].s));
			}
		}
	}
	int ans = INT_MIN;
	for (int i = 1; i <= n; i ++) {
        if (dis[i] == INT_MAX) continue;
        ans = max (ans, dis[i]);
    }
	return ans;
}
int main () {
    cin >> n >> m;
    for (int i = 1; i <= m; i ++) {
		int a, b; cin >> a >> b;
		add (a + 1, b + 1); add (b + 1, a + 1);
	}
	for (int i = 1; i <= n; i ++) {
	    int x = Dijkstra (i);
	    minsn = min (minsn, x); maxx = max (maxx, x);
	}
	cin >> n >> m;
	memset (head, false, sizeof (head));
    tot = 0;
    for (int i = 1; i <= m; i ++) {
		int a, b; cin >> a >> b;
		add (a + 1, b + 1); add (b + 1, a + 1);
	}
	for (int i = 1; i <= n; i ++) {
	    int x = Dijkstra (i);
	    minnn = min (minnn, x); maxxx = max (maxxx, x);
	}
	if (minsn + minnn + 1 < max (maxx, maxxx)) cout << max (maxx, maxxx) << ' ' << maxx + maxxx + 1 << endl;
    else cout << minsn + minnn + 1 << ' ' << maxx + maxxx + 1 << endl;
	return 0;
}
```

---

## 作者：North_encounter (赞：0)

[题目链接](https://www.luogu.com.cn/problem/AT_utpc2013_03)

### 1. 题目描述
对于两张无向图，在连上任意一条边后求最小和最大直径。

### 2.思路
对于一条新边，其直径共有三种情况，即：第一张图的原直径，第二张图的原直径或加上一条边后的新直径。我们可以先预处理出两张图上**每个点到其图上最远的一个点的距离**（即程序中的 num 和 num2），最后在连接的时候把将要连接的两个点的最远距离相加再加一（连上的新边），最后尝试将每两个点连接比较三者即可得出答案。

#### code

```
#include<bits/stdc++.h>
using namespace std;
#define max(a,b) ((a)<(b)?(b):(a))
#define min(a,b) ((a)<(b)?(a):(b))
const int N=10000+20;
const int M=100000+20;
int n,m;
int cnt=0;
int head[2*M];
struct mouse_king{
	int next,v;
}edge[M<<1];
inline int read(){
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=(k<<3)+(k<<1)+(c^48);
		c=getchar();
	}
	return f*k;
}
inline void add(int u,int v){
	edge[++cnt].v=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
int num[N],num2[N];
int vis[N];
struct big_mouse{
	int t,dis;
};
inline int bfs(int s){
	int op=0;
	queue<big_mouse> q;
	q.push((big_mouse){s,0});
	vis[s]=1;
	while(!q.empty()){
		big_mouse k=q.front();
		int u=k.t;
		int dis=k.dis;
		q.pop();
		op=max(op,dis);
		for(int i=head[u];i;i=edge[i].next){
			int to=edge[i].v;
			if(!vis[to]){
				vis[to]=1;
				q.push((big_mouse){to,dis+1});
			}
		}
	}
	return op;
}
int d1,d2;//原直径。
int f1,f2;//两个 n 。
signed main(){
	n=read(),m=read();
	f1=n;
	for(int i=1;i<=m;i++){
		int u,v;
		u=read(),v=read();
		u++,v++;//从一号点开始，个人习惯。
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			vis[j]=0;
		}
		num[i]=bfs(i);//预处理第一张图。
		d1=max(d1,num[i]);
	}
	for(int i=1;i<=2*m;i++){
		edge[i].next=edge[i].v=0;
		head[i]=0;
	}
	n=read(),m=read();
	f2=n;
	for(int i=1;i<=m;i++){
		int u,v;
		u=read(),v=read();
		u++,v++;
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			vis[j]=0;
		}
		num2[i]=bfs(i);
		d2=max(d2,num2[i]);
	}
	int maxn=0;
	int minn=1145141919;
	for(int i=1;i<=f1;i++){
		for(int j=1;j<=f2;j++){
			maxn=max(maxn,max(max(d1,d2),1+num[i]+num2[j]));
			minn=min(minn,max(max(d1,d2),1+num[i]+num2[j]));//建议思考。
		}
	}
	cout<<minn<<" "<<maxn;
	cout<<endl;//必须输出！！！
	return 0;
}
```

---

## 作者：Shizaki_Crazy_Three (赞：0)

# [题目链接](https://www.luogu.com.cn/problem/AT_utpc2013_03)

### 题意

给定两张无向图，在两张图中各选择一个点将其连接，求所有可能情况的图的直径的最大值和最小值。

### 思路分析

算法：bfs ，枚举

题意很简单，不难发现新图的直径为原先两张图的直径的最大值和每张图中距离选择的点最远的距离加起来再加一的最大值。  
原先图的直径很好求，接下来的问题转化为如何求一张图中每个点距离它最远的点的距离。

观察数据范围来确定算法，因为 $n<1000$ 又因为边权为 $1$ ，所以可以用 $n^2$ 的 bfs 求全源最短路。
接下来枚举两个点，取 $\min$ 和 $\max$ 即可。

然后就做完了，时间复杂度 $O(n^2)$ 。

#### code


```cpp
#define LOCAL
#include<bits/stdc++.h>
#define int long long
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
#define pii pair<int,int> 
using namespace std;
const int N=1e5+5;
const int M=1e6+5;
const int inf=1e9+5;
const int mod=1e9+7;
int B=705;

int n1,m1;
int n2,m2;
int dis1[N];
int dis2[N];
int vis[N];
int d1[N];
int d2[N];
struct node{
	int to,next;
}a1[N<<1],a2[N<<1];
int head1[N],head2[N],cnt1,cnt2;
inline void add1(int u,int v){
	a1[++cnt1].to=v;
	a1[cnt1].next=head1[u];
	head1[u]=cnt1;
}
inline void add2(int u,int v){
	a2[++cnt2].to=v;
	a2[cnt2].next=head2[u];
	head2[u]=cnt2;
}
int D1=-inf,D2=-inf;
inline void solve(){
	cin>>n1>>m1;
	int u,v;
	for(int i=1;i<=m1;i++){
		cin>>u>>v;
		u++,v++;
		add1(u,v);
		add1(v,u);
	}
	cin>>n2>>m2;
	for(int i=1;i<=m2;i++){
		cin>>u>>v;
		u++,v++;
		add2(u,v);
		add2(v,u);
	}
	for(int i=1;i<=n1;i++){
		vis[i]=1;
		for(int j=1;j<=n1;j++){
			dis1[j]=inf;
		}
		dis1[i]=0;
		queue<int> q;
		while(!q.empty()) q.pop();
		q.push(i);
		while(!q.empty()){
			int x=q.front();
			q.pop();
			for(int j=head1[x];j;j=a1[j].next){
				int to=a1[j].to;
				dis1[to]=min(dis1[to],dis1[x]+1);
				if(vis[to]==0){
					q.push(to);
					vis[to]=1;
				}
			}
		}
		for(int j=1;j<=n1;j++){
			d1[i]=max(d1[i],dis1[j]);
		}
		for(int j=1;j<=n1;j++) vis[j]=0;
	}
	for(int i=1;i<=n2;i++){
		vis[i]=1;
		for(int j=1;j<=n2;j++){
			dis2[j]=inf;
		}
		dis2[i]=0;
		queue<int> q;
		q.push(i);
		while(!q.empty()){
			int x=q.front();
			q.pop();
			for(int j=head2[x];j;j=a2[j].next){
				int to=a2[j].to;
				dis2[to]=min(dis2[to],dis2[x]+1);
				if(vis[to]==0){
					q.push(to);
					vis[to]=1;
				}
			}
		}
		for(int j=1;j<=n2;j++){
			d2[i]=max(d2[i],dis2[j]);
		}
		for(int j=1;j<=n2;j++) vis[j]=0;
	}
	for(int i=1;i<=n1;i++) D1=max(D1,d1[i]);
	for(int i=1;i<=n2;i++) D2=max(D2,d2[i]);
	int ansminn=inf,ansmaxx=max(D1,D2);
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=n2;j++){
			ansminn=min(ansminn,d1[i]+d2[j]+1);
			ansmaxx=max(ansmaxx,d1[i]+d2[j]+1);
		}
	}
	printf("%lld %lld\n",max(ansminn,max(D1,D2)),ansmaxx);
}

signed main()
{   
    int _=1;
    while(_--) solve();
    return 0;
}

```

---

## 作者：xiongzecheng (赞：0)

题意简化：给定无向图 $G_1$ 和 $G_2$，给这两个图连一条边，求连接后的图最大直径与最小直径。其中一个无向图的直径定义为任意两点间最短路的最大值。

分析：

我们称两点间距离为两点间最短路。如果我们将 $G_1$ 中的 $A$ 点和 $G_2$ 中的 $B$ 点连接起来，则连接后的图的直径会有如下三种情况：

- $G_1$ 中与 $A$ 点距离最大的点的距离 $d_1$ 和 $G_2$ 中与 $B$ 点距离最大的点的距离 $d_2$ 之和再加上一。

- $G_1$ 的直径。

- $G_2$ 的直径。

对于情况一，我们可以用一个广度优先搜索搞定。

对于情况二，我们可以先从任意点出发广搜找到与该点距离最大的点 $C$，然后再找到与点 $C$ 距离最大的点 $D$。这个距离就是答案了。

情况三与情况二同理。

那么连接后的图的直径就是这三种情况的最大值了。

随后我们枚举点 $A$ 和点 $B$，在所有点中找到直径的最小值与最大值，输出即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,n1,n2,m,ans1[1005],ans2[1005],d1,d2,maxn=-1,minn=INT_MAX;
vector<int>vec[1005];//这里我用vector邻接表存图。 
int bfs(int s){
	queue<int>q;
	int dis[1005];
	memset(dis,-1,sizeof(dis));
	q.push(s);
	dis[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<vec[u].size();i++){
			int v=vec[u][i];
			if(dis[v]==-1){
				dis[v]=dis[u]+1;q.push(v);
			}
		}
	}
	int ans=-1;
	for(int i=1;i<=n;i++)ans=max(ans,dis[i]);
	return ans;
}
//bfs用来找到与s点距离最大的点的距离。 
int bfs2(int s){
	queue<int>q;
	int dis[1005];
	memset(dis,-1,sizeof(dis));
	q.push(s);
	dis[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<vec[u].size();i++){
			int v=vec[u][i];
			if(dis[v]==-1){
				dis[v]=dis[u]+1;q.push(v);
			}
		}
	}
	int ans=-1,maxp;
	for(int i=1;i<=n;i++)
		if(ans<dis[i]){
			ans=dis[i],maxp=i;
		}
	return bfs(maxp);
}//bfs2参照上述思路找到一个图的直径 
int main(){
	scanf("%d%d",&n,&m);n1=n;
	//只需记录点数即可 
	while(m--){
		int u,v;scanf("%d%d",&u,&v);
		u++,v++;//作者个人爱好，把点编号强行从 0~n-1 改成了 1~n 
		vec[u].push_back(v);vec[v].push_back(u);
	}
	for(int i=1;i<=n;i++)ans1[i]=bfs(i);
	//预处理与每个点距离最大的点的距离 
	d1=bfs2(1);//记录G1的直径 
	for(int i=1;i<=n;i++)vec[i].clear();
	scanf("%d%d",&n,&m);n2=n;
	//同上 
	while(m--){
		int u,v;scanf("%d%d",&u,&v);
		u++;v++;//同上 
		vec[u].push_back(v);vec[v].push_back(u);
	}
	for(int i=1;i<=n;i++)ans2[i]=bfs(i);
	//同上 
	d2=bfs2(1);//记录G2的直径 
	for(int i=1;i<=n1;i++)//枚举找最大值与最小值 
		for(int j=1;j<=n2;j++){
			maxn=max(maxn,ans1[i]+ans2[j]+1);
			//显然，找最大值时，无需考虑情况二与三 
			minn=min(minn,max(ans1[i]+ans2[j]+1,max(d1,d2)));
		}
	printf("%d %d\n",minn,maxn);
	return 0;
}
```


---

## 作者：technopolis_2085 (赞：0)

分析：

首先，我们要明白怎么求直径。

最简单的方法就是对每一个点进行一次 bfs，然后求出距离该点最远的一个点的距离，然后取最大值。

我们可以预处理出 $G1$ 中的 $n1$ 的点 $i$ 到其他点的距离 $a_i$，和 $G2$ 中的 $n2$ 的点 $j$ 到其他点的距离 $b_j$。

我们发现数据范围不大，所以可以用 $O(n^2)$ 的时间去枚举在哪两个点之间连一条边。我们设这两个点为 $i$ 和 $j$。

最大直径显然为所有 $a_i + b_j + 1$ 的最大值。

最小直径为所有 $a_i + b_j + 1$ 的最小值。

这样的话，你就会发现你过不去第三个样例。

我们发现，最小直径至少得大于 $G1$ 的直径和$G2$ 的直径。

所以最小值得对 $G1$，$G2$ 的直径取较大值。

记得输出后换行，要不然你过不了题。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=2010;
vector<int> G[maxn];
vector<int> H[maxn];
int a[maxn],b[maxn];
int dist1[maxn],dist2[maxn];
int n1,m1,n2,m2;

void bfs1(int s){
	queue<int> q;
	while (!q.empty()) q.pop();
	for (int i=1;i<=n1;i++) dist1[i]=1e9+7;
	dist1[s]=0;
	
	q.push(s);
	
	while (!q.empty()){
		int u=q.front(); q.pop();
		for (int i=0;i<(int)G[u].size();i++){
			int v=G[u][i];
			if (dist1[v]>dist1[u]+1){
				dist1[v]=dist1[u]+1;
				q.push(v);
			}
		}
	}
	
	for (int i=1;i<=n1;i++) a[s]=max(a[s],dist1[i]);
}

void bfs2(int s){
	queue<int> q;
	while (!q.empty()) q.pop();
	for (int i=1;i<=n2;i++) dist2[i]=1e9+7;
	dist2[s]=0;
	
	q.push(s);
	
	while (!q.empty()){
		int u=q.front(); q.pop();
		for (int i=0;i<(int)H[u].size();i++){
			int v=H[u][i];
			if (dist2[v]>dist2[u]+1){
				dist2[v]=dist2[u]+1;
				q.push(v);
			}
		}
	}
	
	for (int i=1;i<=n2;i++) b[s]=max(b[s],dist2[i]);
}

int main(){
	scanf("%d%d",&n1,&m1);
	
	for (int i=1;i<=m1;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		u++; v++;
		
		G[u].push_back(v);
		G[v].push_back(u);
	}
	
	for (int i=1;i<=n1;i++){
		bfs1(i);
	}
	
	scanf("%d%d",&n2,&m2);
	for (int i=1;i<=m2;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		u++; v++; 
		
		H[u].push_back(v);
		H[v].push_back(u); 
	}
	
	int D=0;
	
	for (int i=1;i<=n2;i++){
		bfs2(i);
	}
	
	for (int i=1;i<=n1;i++) D=max(D,a[i]);
	for (int i=1;i<=n2;i++) D=max(D,b[i]);
	
	int mx=0,mi=1e9+7;
	for (int i=1;i<=n1;i++){
		for (int j=1;j<=n2;j++){
			int d=a[i]+b[j]+1;
			mx=max(mx,d);
			mi=min(mi,d);
		} 
	}
	
	printf("%d %d\n",max(mi,D),mx);
	return 0;
}
```


---

## 作者：Siteyava_145 (赞：0)

# 题意：
给出两个**无向图**，在之间加一条边，使两个图变为一个图，再求出这个图的最大、最小直径。

最大直径：把原来的两个图的直径求出，相加，再加上连接的那一条边。（$G_1$ 直径 $+G_2$ 直径 $+1$）。

最小直径：和求最大直径类似，只不过是从每一个点出发到达的最远的点的距离的最小值。

###### ~~所以你看下面~~

### 让我们把样例拿上来：

![](https://cdn.luogu.com.cn/upload/image_hosting/29nu1knp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这里的 $7=3+3+1$，$3$ 求的是最小直径（上面那句长话）。

因为两个图一模一样，所以只取其中一个图举例：

| 点 | 最小直径 |
| :----------: | :----------: |
| $0$ | $0-5$，长度 $=5$ |
| $1$ | $1-5$，长度 $=4$ |
| $2$ | $2-5$，长度 $=3$ |
| $3$ | $0-3$，长度 $=3$ |
| $4$ | $0-4$，长度 $=4$ |
| $5$ | $0-5$，长度 $=5$ |

最小直径 $=\min\{5,4,3,3,4,5\}=3$。

最大直径 $=\max\{5,4,3,3,4,5\}=5$。

# 方法：


Dijkstra 枚举 $1-n$ 的点的单源最短路，每一次都求出```dis```数组的最大值。

再求出这些最大值的最小值和最大值。

另外，最终图的最小直径必须都大于两个图的直径，输出时加特判，如果小于其中一个，输出两个图的直径中大的那个。

### 注意点：

1. 加边时点的编号要 $+1$。

2. 要输入两个图，每一次都要初始化```tot=0```，```head```数组初始化为 $0$。
3. **一定要加堆优化**，不然 TLE。

```
#include<bits/stdc++.h>
#define N 1000005
using namespace std;
priority_queue<pair<int,int> >q;
int head[N],tot=0,vis[N],dis[N],minsn=2147483647,maxx=-1,minnn=2147483647,maxxx=-1;
int n,m,s;
inline int read(){
    int m=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        m=m*10+c-'0';
        c=getchar();
    }
    return m*f;
}
struct Edge{
    int s,val,Next;
}edge[1000005];
void add(int x,int y){
	edge[++tot].s=y;
	edge[tot].Next=head[x];
	head[x]=tot;
}
int Dijkstra(int s){
    memset(vis,0,sizeof vis);
    for(int i=1;i<=n;i++)dis[i]=2147483647;
    dis[s]=0;
	q.push(make_pair(0,s));
	while(q.size()){
		int sat=q.top().second;
		q.pop();
		for(int i=head[sat];i!=0;i=edge[i].Next){
			if(!vis[edge[i].s]&&dis[edge[i].s]>dis[sat]+1){
				dis[edge[i].s]=dis[sat]+1;
				q.push(make_pair(-dis[edge[i].s],edge[i].s));
			}
		}
	}
	int maxdx=0;
	for(int i=1;i<=n;i++){
        if(dis[i]==2147483647)continue;
        maxdx=max(maxdx,dis[i]);
    }
	return maxdx;
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=m;i++){
		int a,b;
		a=read(),b=read();
		add(a+1,b+1);
        add(b+1,a+1);
	}
	for(int i=1;i<=n;i++){
	    int ss=Dijkstra(i);
	    minsn=min(minsn,ss);
	    maxx=max(maxx,ss);
	}
	n=read(),m=read();
	memset(head,0,sizeof head);
    tot=0;
    for(int i=1;i<=m;i++){
		int a,b;
		a=read(),b=read();
		add(a+1,b+1);
        add(b+1,a+1);
	}
	for(int i=1;i<=n;i++){
	    int ss=Dijkstra(i);
	    minnn=min(minnn,ss);
	    maxxx=max(maxxx,ss);
	}
//    cout<<minnn<<" "<<minsn<<' '<<maxx<<' '<<maxxx<<endl;
	if(minsn+minnn+1<max(maxx,maxxx))cout<<max(maxx, maxxx)<<' '<<maxx+maxxx+1<<endl;
    else cout<<minsn+minnn+1<<' '<<maxx+maxxx+1<<endl;
	return 0;
}
```

完结撒花~~~

---


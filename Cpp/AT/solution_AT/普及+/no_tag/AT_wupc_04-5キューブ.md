# 5キューブ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/wupc2nd/tasks/wupc_04

 5キューブは立方体を使ったパズルである．今回はこれをコンピュータを用いて自動で解くことを考えよう． 一辺の長さが $ 5 $ である立方体状のコンテナがある．また，それ以下の整数の大きさを持つ立方体のオブジェがたくさんある．パズルのゴールは，これらのオブジェをコンテナからはみ出さないように敷き詰めることである．オブジェはたくさんあるので，コンテナの数は $ 1 $ つでは足りないかもしれないが，使うコンテナの数が少なければ少ないほど高得点が得られる．  
  
 それぞれの大きさのオブジェの数が与えられるので，使うべきコンテナの数の最小値を答えよ． 入力は以下の形式で標準入力から与えられる．

> $ N_{1}　N_{2}　N_{3}　N_{4}　N_{5} $

- $ 1 $ 行目には，一辺の長さが $ x $ であるオブジェの数 $ N_{x} $($ 1\ ≦\ x\ ≦\ 5 $, $ 0\ ≦\ N_{x}\ ≦\ 1,000,000,000 $) が半角スペース区切りで与えられる．
- $ ∃x\ ::\ N_{x}\ ≧\ 1 $ を仮定してよい．すなわち，オブジェは必ず $ 1 $ つ以上与えられる．
 
 必要なコンテナの数を $ 1 $ 行に出力せよ．  
 なお、最後には改行を出力せよ． ```
<pre class="prettyprint linenums">
109 2 0 0 1
```

 ```
<pre class="prettyprint linenums">
2
```

 ```
<pre class="prettyprint linenums">
0 0 0 5 0
```

 ```
<pre class="prettyprint linenums">
5
```

 ```
<pre class="prettyprint linenums">
1000000000 1000000000 1000000000 1000000000 1000000000
```

 ```
<pre class="prettyprint linenums">
3000000000
```

# 题解

## 作者：Nightsky_Stars (赞：4)

# 题目大意：

读入五个数 $a_{1}$~$a_{5}$，其中 $a_i$ 表示边长为 $i$ 的立方体的数量。现在你拥有 $\infty$ 个棱长为 $5$ 的箱子，求将所有货物装进箱子中并且所用箱子最少。

# 思路：

这道题很水，考虑贪心，即能放大的立方体就放，空余的就用小立方体填满。

# CODE:

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
	ll a,b,c,d,k;
	cin>>a>>b>>c>>d>>k;
	k+=d+c;//5*5
	a-=(61*d+42*c);//4*4和3*3
	b-=7*c;//把放过的减去
	if(b<0){
		a+=b*8;
		b=0;
	}
	if(b>0){
		k+=b/8+(b%8!=0);//继续放
		a-=61*(b/8);//把放过的减去
		b%=8;
		if(b){
			a-=(125-b*8);//把放过的减去
		}
	}
	if(a>0){//如果能放
		if(a%125!=0){
			k+=a/125+1;//那就继续放
		}else{
			k+=a/125;//继续放
		}
	}
	cout<<k<<"\n";
	return 0;
}
```

---

## 作者：weior (赞：4)

先解释一下题目：

读入五个数 a[1]~a[5] ，a[i] 表示棱长为 i 的立方体货物的数量。
你有棱长为 5 的立方体集装箱无数个，要求将所有货物装进集装箱中并且所用集装箱最少。

原先刚看题，第一反应是 ~~暴力求解~~ 模拟装箱过程，但又看了一眼题目，发现数据有些大啊...

于是我就想稍微模拟了一下每种货物装箱的过程，就有了如下代码~~(去掉注释贼短)~~

```cpp
#include<stdio.h>
#include<string.h>
long long num[6];
long long ans;

inline void print(long long x){
	if(x>9)print(x/10);
	putchar(x%10+48);
}

int main(){
	for(int i=1;i<=5;i++)scanf("%lld",&num[i]);
	ans=num[5];
    //棱长为5的货物每个装一个集装箱，刚好装满
	
    ans+=num[4];
	num[1]-=61*num[4];
	//棱长为4的货物一个集装箱装一个，剩余位置用棱长为1的货物补齐
    //不用管棱长为1的货物够不够，不够就减为负数
    //因为是棱长最小的一种，所以对后续计算无影响
    
    if(num[3]>0){
		ans+=num[3];
        //棱长为3的货物也只能一个箱装一个
        //剩余的用棱长为2和1的货物补齐
		if(num[2]>=7*num[3]){//棱长为2的货物够用
			num[2]-=7*num[3];
            //将能放棱长为2的货物的空间放满
			num[1]-=42*num[3];
            //空隙用棱长为1的货物补齐
		}	
		else{//棱长为2的货物不够，空出来的用棱长为1的补齐
			num[1]-=(125*num[3]-27*num[3]-num[2]*8);
			num[2]=0;
		}
	}
	if(num[2]>0){//还有得放
		ans+=(num[2]%8)?1:0;
		ans+=num[2]>>3;
        //每个集装箱可以放8个棱长为2的货物
		
        num[1]-=61*(num[2]>>3);//将装了8个棱长为2的货物的集装箱补齐
		num[2]%=8;num[1]-=(num[2])?(125-num[2]*8):0;//补齐没放够8个棱长为2的货物的箱(如果有的话)
	}
	if(num[1]>0){//还有棱长为1的货物没放
		ans+=num[1]/125;
		ans+=(num[1]%125)?1:0;
	}
	print(ans);putchar('\n');//要有换行，题面上有说
}
```

~~有点数论的感觉~~


---

## 作者：Rannio (赞：2)

**题目大意**：你现在有一个长度为 $5$ 的数组 $a$，其中 $a_i$ 表示边长为 $i$ 的立方体的数量。现在你又有无数个棱长为 $5$ 的箱子，求在立方体全装入箱子的前提下需要的最少箱子数。
  
这道题我们贪心的去想，首先箱子不能有空余，所以能放大的立方体就放，空余的部分用小立方体填满。  

一个 $5 \times 5$ 的立方体放入箱子后正好填满，$4 \times 4$ 的立方体放入箱子后还剩 $61$ 个位置可以放置 $1 \times 1$ 的立方体，$3 \times 3$ 的立方体放入箱子后还可以用 $1 \times 1$ 的立方体或 $2 \times 2$ 的立方体填满，剩下的 $2 \times 2$ 立方体一个箱子可以放 $8$ 个，其余的用 $1 \times 1$ 立方体填满，如果 $1 \times 1$ 立方体还有剩余，则 $125$ 个 $1 \times 1$ 立方体放一箱即可。
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n1,n2,n3,n4,n5;
ll ans;
int main() {
    scanf("%lld%lld%lld%lld%lld",&n1,&n2,&n3,&n4,&n5);
    ans+=n4+n5+n3;
    n1-=n4*61;
    n1-=n3*42;
    n2-=n3*7;
    if(n2<0){
    	n1+=n2*8;
    	n2=0;
	}
	else if(n2>0){
		ans+=n2/8;
		if(n2%8){
			ans++;
		}
		n1-=61*n2/8;
		n2%=8;
		if(n2){
			n1-=125-(n2*8);
		}
	}
	if(n1<=0){
		printf("%lld\n",ans);
		return 0;
	}
	else{
		ans+=n1/125;
		if(n1%125){
			ans++;
		}
	}
	printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Nuyoah_awa (赞：2)

### 题目分析
首先，看到这道题先想，如果每一个边长为 $5$ 的立方体尽可能放满，所需要的立方体就会更少。所以我们可以先讨论一下放立方体的策略。

1. 考虑边长为 $5$ 的立方体怎么放，很明显，它与大立方体一样大，每个大立方体内只能放一个，并且没有剩余的空间。
2. 考虑边长为 $4$ 的立方体怎么放，每一个大立方体中只能放一个，剩余的空间只能放 $61$ 个边长为 $1$ 的立方体。
3. 考虑边长为 $3$ 的立方体怎么放，每个大立方体中也只能放一个，剩余的空间中只能放 $7$ 个边长为 $2$ 的立方体和 $42$ 个边长为 $1$ 的立方体。
4. 如果边长为 $2$ 的立方体实际个数比上述留给它的空要少，就可以把它多余的空给边长为 $1$ 的立方体，每个空能放 $8$ 个边长为 $1$ 的立方体。如果个数比空多，每个大立方体中能放 $8$ 个边长为 $2$ 的立方体。剩余空间能放 $61$ 个边长为 $1$ 的立方体。
5. 如果还有边长为 $1$ 的立方体没被放进去，每个大立方体可以放 $125$ 个边长为 $1$ 的立方体。

总结一下，我们的思路是先把大的放进去，然后再用小的填空，使大立方体中尽可能都放满。很同意楼上的看法，确实有点奥数的感觉。
### code
```cpp
#include <iostream>
#include <cstdio> 
using namespace std;
long long n = 5, a[10], ans;
int main()
{
	for(int i = 1;i <= n;i++)
		cin >> a[i];
	ans = a[5];
	ans += a[4];
	a[1] -= 61 * a[4];
	ans += a[3];
	a[2] -= a[3] * 7;
	a[1] -= a[3] * 42;
	if(a[2] < 0)
		a[1] += a[2] * 8, a[2] = 0;
	if(a[2] > 0)
	{
		ans += a[2] / 8;
		ans += (a[2] % 8) ? 1 : 0;
        a[1] -= 61 * (a[2] / 8);
		a[2] %= 8;
		a[1] -= a[2] ? (125 - a[2] * 8) : 0;
	}
	if(a[1] > 0)
	{
		ans += a[1] / 125;
		ans += (a[1] % 125) ? 1 : 0;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Fubaogege (赞：1)

你有一个长度为 $5$ 的数组 $a$，$a_i$ 代表边长为 $i$ 的立方体数量，让你用最小的箱子装入所有的立方体。
  
本题重点：我们的总体思路是先放大的，然后再填小的，使他尽可能装满。
  
我们可以用贪心思想。  
我们先推断一下：  
$5^3$ 的立方体：刚好填满。  
$4^3$ 的立方体：剩 $61$ 个正方体。  
$3^3$ 的立方体：放入后可用 $1^3$ 或 $2^3$ 的正方体填满。  
$2^3$ 的立方体：一箱子放 $8$ 个。   
$1^3$ 的立方体：可以放 $125$ 个。  
  
这样我们不断地永程序装，不停地减（如下程序）先装大再装小，这样就可以用程序打完了。
### 核心代码
```c
a=a-(61*d+42*c);
b=b-7*c;
if(b<0){
	a=a+b*8;
	b=0;
}
if(b>0){
	s=s+b/8+(b%8!=0);
	a=a-61*(b/8);
	b=b%8;
	if(b>0)a=a-(125-b*8);
}
if(a>0)s=s+a/125+(a%125!=0);
```

---

## 作者：xxr___ (赞：1)

### 思路：
推式子：如果放置一个 $5 \times 5 \times 5$ 的箱子，那么就没有空间了，如果放置 $4 \times 4 \times 4$ 的箱子，那么还剩 $61$ 的空间，并且只能放 $61$ 个 $1 \times 1 \times 1$ 的箱子。如果放置一个 $3 \times 3 \times 3$ 的箱子，那么剩余 $98$ ，可以选择放置 $2 \times 2 \times 2$ 的箱子或者是 $1 \times 1 \times 1$ 的箱子，但是我们贪心的想有 $2 \times 2 \times 2$ 的就不选 $1 \times 1 \times 1$ 的箱子。如果选用 $2 \times 2 \times 2$ 的，那么可以放 $8$ 个这样的箱子，其余的放置 $1 \times 1 \times 1$ 的箱子。最后如果选用 $1 \times 1 \times 1$ 的，就还可以再放置 $124$ 个。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,ans;
int main(){
	scanf("%lld%lld%lld%lld%lld",&a,&b,&c,&d,&ans);
	ans+=d+c;
	a-=(61*d+42*c);
	b-=7*c;
	if(b<0)a+=b*8,b=0;
	if(b>0){
		ans+=b/8+(b%8!=0);
		a-=61*(b/8);
		b%=8;
		if(b)a-=(125-(b*8));
	}
	if(a>0)ans+=a/125+(a%125!=0);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Crasole (赞：0)

## 思路

$N_i(1 \le i \le 5)$ 表示边长为 $i$ 的方块的个数。

首先，既然要满足盒子数最小，肯定要选择从大的开始。

- 边长为 $5$ 的方块：

一个边长为 $5$ 的方块直接把整个箱子放满，没有空隙，共需 $N_5$ 个盒子。

- 边长为 $4$ 的方块：

一个箱子放得下一个边长为 $4$ 的方块，需 $N_4$ 个盒子。但是还剩 $5 ^ 3 - 4 ^ 3$ 个单位的空隙，这些空隙可以用边长为 $1$ 的方块填充。

- 边长为 $3$ 的方块：

一个箱子放得下一个边长为 $3$ 的方块，需 $N_3$ 个盒子。画图可得，剩下的空间还可放 $7$ 个边长为 $2$ 的方块，但是，$N_2$ 可能并没有达到 $N_3 \times 7$ 的数量，所以先把边长为 $2$ 的方块放进去，若 $N_2$ 不满 $N_3 \times 7$，则剩下的 $N_3 \times 7 - N_2$ 个边长为 $2$ 的方块用 $8$ 个边长为 $1$ 的方块代替。那么每个盒子还剩 $5 ^ 3 - 3 ^ 3 - 7 \times 2 ^ 3$ 个单位的空隙，这些空隙用边长为 $1$ 的方块填充。

- 边长为 $2$ 的方块：

一个盒子放得下 $8$ 个边长为 $2$ 的方块，需 $\lfloor \frac{N_2}{8} \rfloor $ 个盒子。剩下的 $5 ^ 3 - 2 ^ 3 \times 8$ 个单位的空隙，可以用边长为 $1$ 的方块填充。若 $N_2$ 并不是 $8$ 的倍数，还需要一个盒子来放剩下的 $N_2 \bmod 8$ 个边长为 $2$ 的方块。那么还剩 $5 ^ 3 - 2 ^ 3 \times (N_2 \bmod 8)$ 个单位的空隙，这些空隙用边长为 $1$ 的方块填充。

- 边长为 $1$ 的方块：

一个盒子放得下 $125$ 个边长为 $1$ 的方块，因为 $N_1$ 可能不是 $125$ 的倍数，所以需要 $\lceil \frac{N_1}{125} \rceil$ 的盒子。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[10];

signed main () {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	cin >> a[1] >> a[2] >> a[3] >> a[4] >> a[5];
	//边长为 5 
	long long ans = a[5];
	//边长为 4 
	ans += a[4];
	//注意和0取最大值防止变成负数！ 
	a[1] = max(0ll, a[1] - a[4] * (5 * 5 * 5 - 4 * 4 * 4));
	//边长为 3 
	ans += a[3];
	a[2] -= a[3] * 7;
	if(a[2] < 0) {
		a[2] = abs(a[2]);
		a[1] = max(0ll, a[1] - a[2] * 8);
		a[2] = 0;
	}
	a[1] = max(0ll, a[1] - a[3] * (5 * 5 * 5 - 3 * 3 * 3 - 7 * 2 * 2 * 2));
	//边长为 2 
	long long tt = a[2] / 8;
	ans += tt;
	a[1] = max(0ll, a[1] - tt * (5 * 5 * 5 - 4 * 4 * 4));
	a[2] %= 8;
	if(a[2]) {
		++ ans;
		a[1] = max(0ll, a[1] - (5 * 5 * 5 - 2 * 2 * 2 * a[2]));
	}
	//边长为 1 
	ans += a[1] / 125;
	a[1] %= 125;
	ans += (a[1] > 0);
	cout << ans << endl;
	return 0;
}
```

---

## 作者：sdsswyd (赞：0)

**[题目传送门](https://www.luogu.com.cn/problem/AT_wupc_04)**
### 题外话

不知咋的，看着挺简单的。实则错了好几遍。
# 思路
考虑**贪心**。
## 步骤
首先，要使棱长为 $5$ 的大正方体尽量少，那么先放尽量多大一点的正方体，再用小正方体补上，便可得出答案（别忘换行）。
1. 用棱长为 $5$ 的正方体，显然，它能全部填满；
2. 用棱长为 $4$ 的正方体，能放 $1$ 个，再用 $41$ 个棱长为 $1$ 的正方体补；
3. 用棱长为 $3$ 的正方体，能放 $1$ 个，再用 $7$ 个棱长为 $2$ 的正方体和 $42$ 个棱长为 $1$ 的正方体；
4. 用棱长为 $2$ 的正方体，能放 $8$ 个，再用 $61$ 个棱长为 $1$ 的正方体；
5. 用棱长为 $1$ 的正方体，能放 $125$ 个。

所以，我们先放大正方体，再补，这道题就解决了。
# AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[10];
long long ans;
int main(){
	cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5];
	ans+=a[5]+a[4]+a[3];
	a[1]-=(61*a[4]+42*a[3]);
	a[2]-=(a[3]*7);
	if(a[2]<0){
		a[1]+=a[2]*8;
		a[2]=0;
	}
	if(a[2]>0){
		ans+=a[2]/8;
		a[1]-=61*(a[2]/8);
		if(a[2]%8!=0)ans++;
		a[2]%=8;
		if(a[2]!=0){
			a[1]-=(125-a[2]*8);
		}
	}
	if(a[1]>0){
		ans+=a[1]/125;
		if(a[1]%125!=0)ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：lhz123bc (赞：0)

本题考虑贪心思想，我们想让用的箱子最少，那么一定要让更大的先放，然后再放小的。

接下来我们推一下式子：

放置 $5 \times 5 \times 5$ 的立方体，箱子填满。

放置 $4 \times 4 \times 4$ 的立方体，箱子还剩 $61$ 个位置，剩下的由 $1 \times 1 \times 1$ 的立方体填充。

放置 $3 \times 3 \times 3$ 的立方体，剩下的 $98$ 个位置既可以由 $1 \times 1 \times 1$ 的立方体填充，也可以由 $2 \times 2 \times 2$ 的立方体填充，但要多放 $2 \times 2 \times 2$ 的。

若放 $2 \times 2 \times 2$ 的立方体，那么一个箱子可以放 $8$ 个，其余用 $1 \times 1 \times 1$ 的立方体填充。

最后选用 $1 \times 1 \times 1$ 的立方体进行填充，共需 $125$ 个。

[AC Code](https://www.luogu.com.cn/paste/xh74qabs)

---

## 作者：封禁用户 (赞：0)

## 前言：
竟然有如此水的绿题。

## 思路：

这题首先考虑贪心思想。

我们想让用的箱子最少，那么一定要让更大的先放，如果先放小的，那大的就有可能放不进去。所以用贪心进行模拟，最后只需要再计算一下还剩多少空间即可。

推公式得：一个 $5$ $×$ $5$ 的立方体放入箱子后正好填满，$4$ $×$ $4$ 的立方体放入箱子后还剩下 $61$ 个位置可以放置 $1$ $×$ $1$ 的立方体，$3$ $×$ $3$ 的立方体放入箱子后还可以用 $1$ $×$ $1$ 的立方体或 $2$ $×$ $2$ 的立方体填满，那么剩下的 $2$ $×$ $2$ 立方体一个箱子可以放 $8$个，剩下的用 $1$ $×$ $1$ 立方体填满，如果 $1$ $×$ $1$ 立方体还有剩下，则 $125$ 个 $1$ $×$ $1$ 立方体放一箱即可。

## AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,c,d,sum;

int main()
{
	//	freopen(".in","r",stdin);
	//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> a >> b >> c >> d >> sum;
	sum+=d+c;
	a-=(61*d+42*c);
	b-=7*c;
	if(b<0)
	{
		a+=b*8;
		b=0;
	}
	if(b>0)
	{
		sum+=b/8+(b%8!=0);
		a-=61*(b/8);
		b%=8;
		if(b)
		{
			a-=(125-(b*8));
		}
	}
	if(a>0)
	{
		sum+=a/125+(a%125!=0);
	}
	cout << sum << endl;
	return 0;
}
``````

---

## 作者：_GJM_ (赞：0)

###### [更好的阅读体验？](https://www.luogu.com.cn/blog/GeJiamu/solution-at-wupc-04)

## 题意
给出五个数 $a_1\sim a_5$，$a_i$ 表示棱长为 $i$ 的立方体货物的数量。你有棱长为 $5$ 的立方体集装箱无数个，你要将所有货物装进集装箱中**并且**所用集装箱最少。

## 思路
看到 $0\le a_i\le 10^9$，就知道循环模拟装箱会 **TLE**。

那么我们可以尝试用数学方法。

不难发现，如果依次放棱长为 $5\sim1$ 的货物（也就是先放大的，再放小的中最大的，依此类推），空间将利用到最大化。

## [AC Code](https://www.luogu.com.cn/paste/d2v5tfqv)

---

## 作者：Acheron_RBM (赞：0)

这题首先考虑贪心。

我们想让用的箱子最少，那么一定要让更大的先放，因为如果先放小的，那大的就有可能放不进去。用贪心模拟，最后只需要计算一下还剩多少空间即可。

```cpp
int main()
{
	long long n,m,x,y;
	cin>>n>>m>>x>>y;
	long long ret;
	cin>>ret;
	ret+=y+x;//5*5
	n-=(61*y+42*x);//4*4和3*3的摆放方法 
	m-=7*x;//减去放过的 
	if(m<0)
	{
		n+=m*8;
		m=0;
	}
	if(m>0)
	{
		ret+=m/8+(m%8!=0);//继续放 
		x-=61*(m/8);//减去放过的 
		m%=8;
		if(m>0)
		{
			x-=(125-(m*8));//减去放过的 
		}
	}
	if(x>0)//能放 
	{
		if(x%125!=0)
		{
			ret+=x/125+1;//继续放 
		}
		else
		{
			ret+=x/125;//继续放 
		}
	}
	cout<<ret;
	return 0;
}
```

---

## 作者：OMITW (赞：0)

# 前言

竟然有如此水的绿题，这不就是纯纯的推导公式吗？还有一点，如果你的输出没有换行，那么你将喜提 WA 一道。

# 推到过程

如果我要放 $ 5 \times 5 $ 的立方体，那么一个箱子只能装 $ 1 $ 个，并且没有多余空间。

如果我要放 $ 4 \times 4 $ 的立方体，那么一个箱子只能装 $ 1 $ 个，但多出了 $ 61 $ 的位置，只能放 $ 64 $ 个 $ 1 \times 1 $ 的立方体。

如果我要放 $ 3 \times 3 $ 的立方体，那么一个箱子只能装 $ 1 $ 个，但多出了 $ 98 $ 的位置，可以放 $ 1 \times 1 $，也可以放 $ 2 \times 2 $。但要贪心。所以能放 $ 2 \times 2 $，就放 $ 2 \times 2 $。多余的用 $ 1 \times 1 $。一般是 $ 7 $ 个 $ 2 \times2 $ 再加 $ 42 $ 个 $ 1 \times 1 $。

如果我放 $ 2 \times 2 $ 的立方体，那么一个箱子只能装 $ 8 $ 个，多余的用 $ 1 \times 1 $。

如果还有 $ 1 \times 1 $ 的立方体。那么一个箱子放 $ 125 $ 个。最后统计个数。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a1,a2,a3,a4,k;
int main()
{
	scanf("%lld%lld%lld%lld%lld",&a1,&a2,&a3,&a4,&k);
	k+=a4+a3;
	a1-=(61*a4+42*a3);
	a2-=7*a3;
	if(a2<0)a1+=a2*8,a2=0;
	if(a2>0)
	{
		k+=a2/8+(a2%8!=0);
		a1-=61*(a2/8);
		a2%=8;
		if(a2)a1-=(125-a2*8);
	}
	if(a1>0)k+=a1/125+(a1%125!=0);
	printf("%lld\n",k);
	return 0;
}
```

---

## 作者：Mortidesperatslav (赞：0)

先说这道题最大坑点——就是输出一定要带个换行，否则必然挂。

然后对于我的代码要讲一个知识点：`bool` 类型。

`bool` 中文叫“布尔”，它的取值只有 $0$ 或 $1$。在 Java 语言中，布尔类型写作 `boolean`。这种类型对于“进 $1$ 问题”（如鸽巢原理）很有用。

这道题目对于余数处理也需要这个。这道题的主要思路为：

1. 对于 $5 \times 5 \times 5$ 的立方体，直接放。

2. 对于 $4 \times 4 \times 4$ 的立方体，放下后还可以放 $5^3 - 4^3 = 61$ 个 $1 \times 1 \times 1$ 的立方体。

3. 对于 $3 \times 3 \times 3$ 的立方体，放下后还有 $5^3 - 3^3 = 98$ 的空间，可以放 $7$ 个 $2 \times 2 \times 2$ 的立方体和 $98-56=42$ 个 $1 \times 1 \times 1$ 的立方体。如果 $2 \times 2 \times 2$ 的立方体不够，换 $1 \times 1 \times 1$ 的。

4. 对于 $2 \times 2 \times 2$ 的立方体，每个盒子可以放下 $8$ 个，还可以放 $125-64=61$ 个 $1 \times 1 \times 1$ 的立方体。

5. 剩下 $1 \times 1 \times 1$ 的立方体，每盒最多 $125$ 个，直接放即可。

这时就要用 `bool` 了！假设只有 $127$ 个 $1 \times 1 \times 1$ 的小立方体，就得用 `bool` 类型，如果有余数就转化成 $1$ （注意表示进 $1$，不再是余数了）；否则直接能整除，不用加。

这样写起来就很简单了：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long _1,_2,_3,_4,_5,ans=0;
int main(){
	cin>>_1>>_2>>_3>>_4>>_5;
	ans=_5+_4+_3;//3*3*3以上的立方体每盒只能放一个
	_1-=(61*_4+_3*42);//用1填
	_2-=_3*7;//用2填
	if(_2<0)_1+=_2*8,_2=0;//2不够换1
	if(_2>0){
		ans=ans+_2/8+(bool)(_2%8);//强制类型转换，优先级高
        _1-=61*(_2/8);
		_2%=8;
		_1-=_2?(125-_2*8):0;
	}
	if(_1>0)ans=ans+_1/125+(bool)(_1%125);
	cout<<ans<<'\n';//不换行会WA
}
```

---


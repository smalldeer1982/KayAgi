# サイコロ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tdpc/tasks/tdpc_dice

入力は以下の形式で標準入力から与えられる。

> $ N $ $ D $

 答えを一行に出力せよ。絶対誤差が $ 10^{-6} $ 以下のとき正当と判定される。 ```

2 6
```

```

0.416666667
```

```

3 2
```

```

0.875000000
```

## 说明/提示

### Constraints

 サイコロを $ N $ 回振ったとき、出た目の積が $ D $ の倍数となる確率を求めよ。

- - - - - -

- $ 1\ <\ =\ N\ <\ =\ 100 $
- $ 1\ <\ =\ D\ <\ =\ 10^{18} $

# 题解

## 作者：1234567890sjx (赞：1)



因为是 $6$ 个面的骰子，所以想到了 [H 数](https://www.luogu.com.cn/problem/P1748)。$6$ 面的骰子的乘积的质因数必然只有 $2$，$3$，$5$。

类似于 H 数，定义 $f_{i,j,k}$ 表示当前选择的点数的乘积恰好是 $2^i\times 3^j\times 5^k$ 的方案数。

显然答案为 $\sum_{a=0}^{+\infin}\sum_{b=0}^{+\infin}\sum_{c=0}^{+\infin}f_{a,b,c}[k\mid 2^a\times 3^b\times 5^c]$。

但是这个无穷项式子没法求和。

但是这个数最大也只有 $6^n$，所以发现 $a$ 的上界只需要枚举到 $2n$，$b$ 和 $c$ 的上界只需要枚举到 $n$ 即可。

初始条件为 $f_{0,0,0}=1$。

状态转移方程为~~（前方高能）~~：

$g_{i,j,k}=g_{i,j,k}+\frac{f_{i,j,k}}{6}$（选择 $1$）。

$g_{i+1,j,k}=g_{i+1,j,k}+\frac{f_{i,j,k}}{6}$（选择 $2$）。

$g_{i,j+1,k}=g_{i,j+1,k}+\frac{f_{i,j,k}}{6}$（选择 $3$）。

$g_{i+2,j,k}=g_{i+2,j,k}+\frac{f_{i,j,k}}{6}$（选择 $4$）。

$g_{i,j,k+1}=g_{i,j,k+1}+\frac{f_{i,j,k}}{6}$（选择 $5$）。

$g_{i+1,j+1,k}=g_{i+1,j+1,k}+\frac{f_{i,j,k}}{6}$（选择 $6$）。

最后令 $f_{i,j,k}=g_{i,j,k}$ 即可。

优化常数：

设 $d_2$ 为 $D$ 中 $2$ 的因子数量，$d_3$ 为 $D$ 中 $3$ 的因子数量，$d_5$ 为 $D$ 中 $5$ 的因子数量。

转移的时候 $f_{i,j,k}$ 中 $i\to \min(i,d_2)$，$j\to \min(j,d_3)$，$k\to \min(k,d_5)$，答案就是 $f_{d_2,d_3,d_5}$。

数据范围巨大，但是卡一卡能过。

时间复杂度是 $O(nd_2d_3d_5)$ 的。

---

## 作者：fa_555 (赞：1)

under 题解 [AT684](https://www.luogu.com.cn/problem/AT684)

同步发布于[个人博客](https://fa555.github.io/2020/某At的dp场/#D-サイコロ)

### problem

将六个面的骰子掷 $N \ (1 \le N \le 100)$ 次，求每一次掷得的点数的乘积是 $D \ (1 \le D \le 10^{18})$ 的倍数的概率。

### solution

考虑骰子掷出点数的乘积的质因子只可能有 $2, 3, 5$。考虑直接从这三个因数进行转移。

设 $f_{i, a, b, c}$ 表示第 $i$ 次掷骰子后点数的乘积中因子 $2$ 有 $a$ 个，$3$ 有 $b$ 个，$5$ 有 $c$ 个的可能性。

直接枚举每次掷骰子的过程转移即可。

边界条件 $f_{0, 0, 0, 0} = 1$。

答案即为 $f_{N, a, b, c}$。总复杂度 $O(Nabc)$。

### code

实现看了看霓虹国神仙すいバカ的（小声

这个 dp 数组甚至可以滚动数组压掉一维，不过这里没写。

变量名和上文略有不同。数组大小奇怪是因为是压着上界开的。

``` cpp
constexpr int s2[] = {0, 0, 1, 0, 2, 0, 1};
constexpr int s3[] = {0, 0, 0, 1, 0, 0, 1};
constexpr int s5[] = {0, 0, 0, 0, 0, 1, 0};

double f[101][61][39][27];

double dp(int N, long long D) {
  int d2 = 0, d3 = 0, d5 = 0;
  
  while (D % 2 == 0)
    D /= 2, ++d2;
  while (D % 3 == 0)
    D /= 3, ++d3;
  while (D % 5 == 0)
    D /= 5, ++d5;
  if (D != 1) return 0;

  f[0][0][0][0] = 1;
  for (int i = 0; i < N; ++i)
    for (int i2 = 0; i2 <= d2; ++i2)
      for (int i3 = 0; i3 <= d3; ++i3)
        for (int i5 = 0; i5 <= d5; ++i5)
          for (int j = 1, t2, t3, t5; j <= 6; ++j) {
            t2 = min(d2, i2 + s2[j]);
            t3 = min(d3, i3 + s3[j]);
            t5 = min(d5, i5 + s5[j]);
            f[i + 1][t2][t3][t5] += f[i][i2][i3][i5] / 6;
          }
  return f[N][d2][d3][d5];
}

```

---

## 作者：wanghonghui123 (赞：0)

## 思路分析
1. 单次掷骰子的概率：

	- 掷出每个数字（$1$ 到 $6$）的概率是 $\tfrac{1}{6}$。

2. 乘积是 $D$ 的倍数的条件：

	- 要使 $N$ 次掷骰子的乘积是 $D$ 的倍数，我们需要考虑 $D$ 的质因数分解。
    
   - 假设 $D$ 的质因数分解为 $(D = p_1^{e_1} \cdot p_2^{e_2} \cdots p_k^{e_k})$。
   
   - 对于每个质因数 $p_i$，我们需要确保在 $N$ 次掷骰子中，至少能“收集”到 $e_i$ 个 $p_i$ 的因子。
   
3. 动态规划（DP）：
	- 我们可以使用动态规划来计算满足条件的概率。
    
   - 定义一个 DP 数组 $dp[i][j][k]$，其中 $i$ 表示当前是第几次掷骰子，$j$ 表示当前乘积中 $p_1$ 的因子个数（对于所有质因数，我们可以为每个质因数定义一个类似的维度，但为了简化，这里只考虑一个质因数），$k$ 表示当前乘积是否是 $D$ 的倍数（是则为 $1$，否则为 $0$）。
   
   - 但由于 $N$ 和 $D$ 的范围，直接这样定义 DP 数组会非常大。我们可以优化为只记录每个质因数的因子个数，并在最后检查是否满足所有质因数的需求。
   
4. 优化：
	- 考虑到 $D$ 的范围较小。
   - $(1 \le D \le 10^{18})$，但质因数分解后，每个质因数的指数通常不会太大。
    
   - 我们可以只记录每个质因数在 $N$ 次掷骰子后出现的次数，并检查这些次数是否满足 $D$ 的质因数分解。

5. 计算：
	- 对于每个质因数 $p_i$，我们计算 $N$ 次掷骰子后，乘积中包含 $p_i$ 的因子个数的概率分布。
    - 最后，检查这些分布是否满足。
    - $D$ 的所有质因数要求。
## 注意
  这题的时间复杂度将是指数级的，因为对于每一次掷骰子，都有 $6$ 种可能的结果，所以 $N$ 次掷骰子的所有可能组合是 $6^N$，因此，对于这个问题，没有一个固定的、简单的时间复杂度答案，它取决于你选择的解决方案和算法设计。

---


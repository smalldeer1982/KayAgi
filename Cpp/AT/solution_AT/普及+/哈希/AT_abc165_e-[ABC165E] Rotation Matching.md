# [ABC165E] Rotation Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc165/tasks/abc165_e

あなたは「AtCoderじゃんけん」という一対一のゲームの大会を主催することになりました。 大会の参加者は $ N $ 人で、それぞれには $ 1 $ から $ N $ の相異なる番号が割り振られています。 アリーナには二人が入ることのできる対戦場が $ M $ 個用意されており、あなたはそれぞれの対戦場に二つの相異なる $ 1 $ 以上 $ N $ 以下の整数を割り当てなければいけません。 複数の対戦場に同じ整数を割り当てることはできません。 大会は $ N $ ラウンドによって構成され、それぞれのラウンドは以下のようにして取り行われます。

- それぞれの参加者は、自分の番号が割り当てられた対戦場が存在するならそこに行き、そこに来たもう一方の相手と対戦する。
- その後、それぞれの参加者が、自分の番号に $ 1 $ を足す。もし $ 1 $ を足した後の番号が $ N+1 $ であるなら、その値を $ 1 $ に変更する。

$ N $ 回のラウンドを通じて、二回以上同じ参加者と対戦するような参加者が存在しないようにしたいです。 このような条件を満たす対戦場への整数の割り当てをひとつ出力してください。 ただし、与えられる制約のもとでそのような割り当てが必ず存在することが示せます。

## 说明/提示

### 制約

- $ 1\ \leq\ M $
- $ M\ \times\ 2\ +1\ \leq\ N\ \leq\ 200000 $

### Sample Explanation 1

参加者 $ 4 $ 人を $ A,B,C,D $ とし、はじめ A には $ 1 $、Bには $ 2 $、Cには $ 3 $、Dには $ 4 $ が割り振られているとします。 - $ 1 $ 回目のラウンドでは $ 2 $ の割り振られた B と $ 3 $ の割り振られた C が対戦し、A の番号が $ 2 $ 、B の番号が $ 3 $、Cの番号が $ 4 $、D の番号が $ 1 $となります。 - $ 2 $ 回目のラウンドでは $ 2 $ の割り振られた A と $ 3 $ の割り振られた B が対戦し、A の番号が $ 3 $ 、B の番号が $ 4 $、C の番号が $ 1 $、D の番号が $ 2 $ となります。 - $ 3 $ 回目のラウンドでは $ 2 $ の割り振られた D と $ 3 $ の割り振られた A が対戦し、A の番号が $ 4 $ 、B の番号が $ 1 $、C の番号が $ 2 $、D の番号が $ 3 $ となります。 - $ 4 $ 回目のラウンドでは $ 2 $ の割り振られた C と $ 3 $ の割り振られた D が対戦し、A の番号が $ 1 $ 、B の番号が $ 2 $、C の番号が $ 3 $、D の番号が $ 4 $ となります。 $ 4 $ 回のラウンドを通じて二回以上同じ参加者と対戦するような参加者が存在しないため、この出力は正解となります。

## 样例 #1

### 输入

```
4 1```

### 输出

```
2 3```

## 样例 #2

### 输入

```
7 3```

### 输出

```
1 6
2 5
3 4```

# 题解

## 作者：feecle6418 (赞：12)

好题！

根据样例，猜想答案为：

$(\lfloor\frac{n}{2}\rfloor,\lfloor\frac{n}{2}\rfloor+1),(\lfloor\frac{n}{2}\rfloor-1,\lfloor\frac{n}{2}\rfloor+2),\dots$

但是这样会 WA。问题出在哪里呢？

考虑 $n=4k+2$ 的情况，则 $\dfrac{n}{2}$ 为奇数。这意味着当 $m$ 足够大时，必存在一对数 $(a,b)$ 使 $b=a+\dfrac{n}{2}$，而这对数的循环节显然为 $\dfrac{n}{2}$，因此不合题意！

怎么办呢？当 $b=a+\dfrac{n}{2}$ 时直接令 $b+1\to b$ 即可。留作习题，请读者自己证明正确性。

可是这样交上去仍然 WA 了一些点。我们再考虑 $n=4k$ 的情况，显然一定存在两对数 $(a,b)$ 使其中一对 $b=a+\dfrac{n}{2}+1$，另一对 $b=a+\dfrac{n}{2}-1$，发现经过 $\dfrac{n}{2}$ 轮后，这两对人马刚好互换了位置！因此这样也不合法。解决方法同上，当出现第二对数时令 $b+1\to b$ 即可。仍然留作习题，请读者自己证明正确性。

代码如下：

```cpp
#include<bits/stdc++.h> 
using namespace std; 
typedef long long ll;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=n/2,j=i+1,k=1;k<=m;k++,i--,j++){
		if(n%2==0&&(j-i==n/2||j-i==n/2+1))j++;
		cout<<i<<' '<<j<<endl;
	}
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：4)

感觉思路不太一样，来发一篇题解。

## 题目描述
你将举行一场 $\texttt{1 V 1}$ 竞技比赛 $\texttt{Atcoder Janken}$。 $N$ 个初始编号为 $1\sim N$ 选手将会参加比赛。你只有 $M$ 个比赛场，所以你需要分派给每一个场地两个选手编号。当然，你不能分派一个选手编号给多个比赛场地。比赛共有 $N$ 轮，每一轮流程如下：  

* 对于每一名选手，如果他的编号已经被分配了比赛场地，他将会去与对手对决。  
* 然后每一名选手的编号 $+1$，如果编号变成了 $N+1$ ，那么将它变为 $1$ 。  （**即选手的编号会变化，而比赛场对决的选手的编号，每一轮都一样。**）  

你希望在 $N$ 轮中没有选手与同一名选手对决多次。将编号分配方案输出。数据保证有解。

## 大体思路
我们反过来看，什么时候两个人会再次遇到。由于 $2m+1=n$ 的情况最难，只考虑这种情况。

假设两个人初始编号为 $x,y$，先不考虑取模等，第一次相遇时编号为 $x+a,y+a$，第二次相遇时编号为 $x+b,y+b$。容易发现，两场比赛编号的差相等。

现在考虑取模，则差 $d$ 与差 $n-d$ 等价。例如 $n=7$ 时，相差为 $2$ 的场地编号组合有 $(1,3),\ (2,4),\ (3,5),\ (4,6),\ (5,7),\ (6,1),\ (7,2)$，因此场地编号中这些一共只能出现一次。

将其推广，场地编号中每种差只能出现一次。假设出现的所有差为 $d_1\sim d_m,\ d_i<d_{i+1}$。一个显然的思路是**让小的编号搭配大的差**，避免编号重复。

同时，一个编号只能出现一次。因此，不妨设 $d_1=1$，那么下一项只能为 $3$ 而不能为 $2$。举例来说，如果 $d=1$ 的编号组合是 $(3,4)$，则 $d=2$ 的组合只能是 $(3,5),(2,4)$，但这样都有重复编号出现，舍。

总之，所有编号需要满足任意 $d_i+d_j\neq n$ 且相邻两项之差至少为 $2$。

然后我们来构造编号。

如果 $n$ 为奇数，差为 $1,3,5\cdots$，这样任意两项之差必然为偶数，不等于 $n$，直接 $\texttt{pass}$。

如果 $n$ 为偶数，一个尽可能多地构造出 $d$ 的方法是使得第 $t$ 大的和第 $t$ 小的 $d$ 的和为 $n-1$。例如 $n=10$ 时构造出的 $d$ 为 $1,3,6,8$。

但是我们发现当 $n$ 为四的倍数，这样构造的 $d$ 少了一项。例如 $n=12$ 时，构造出的 $d=1,3,8,10$。我们可以添加的有 $5$ 或 $6$。但是如果我们添加差为 $6$，会发现在 $6$ 轮过后，原来的对手互换位置出现。所以我们只能添加 $5$。

推而广之，如果 $n$ 为偶数，构造 $d=1,3\cdots,(n-1)-3,(n-1)-1$，并根据 $n$ 是否为 $4$ 的倍数决定是否添加 $d=\dfrac n 2-1$。

具体实现时，可以规律地处理出 $d$ 数组，并且**从大到小排序（代码实现时与上文分析时采用的排序方式不同）**。然后对于所有场地，其中一个选手为 $1\sim m$，另一个选手编号为 $i+d_i$。时间复杂度 $O(n\log n)$，如果稍微动动脑筋按照顺序处理 $d$ 数组，时间复杂度 $O(n)$。

## ~~完整~~代码
```cpp
int n, m, d[maxn];
int main () {
	read(n); read(m);
	if(n & 1) {
		rep(i, 1, n / 2) d[i] = 2 * i - 1;
		reverse(d + 1, d + (n / 2) + 1);
		rep(i, 1, m) 
			write(i), putchar(' '), writeln(i + d[i]);
	}
	else {
		int nD = 0;
		int mid = (n / 2 - 1) / 2;
		rep(i, 1, mid) d[++nD] = i * 2 - 1, d[++nD] = n - i * 2;
		if(mid * 2 < (n / 2 - 1)) d[++nD] = n / 2 - 1;
		sort(d + 1, d + nD + 1, greater<int>());
		rep(i, 1, m)
			write(i), putchar(' '), writeln(i + d[i]);
	}
	return 0;
}
```

---

## 作者：YuTianQwQ (赞：2)

# 题目解析

这道题目的目标是将 $n$ 个人分为两队，且要求每个队伍的人数不能小于 $m$，同时要求两个队伍交替出队，即两队队首一人一人的出队。

代码的核心思路是利用两个指针 `l` 和 `r` 来模拟两个队伍。每次输出时，先输出左队伍的人（`l++`），然后输出右队伍的人（`r--`）。通过这种方式，保证了两个队伍交替出队。

## 解题思路

1. **读取输入**：首先，我们需要读取 $n$ 和 $m$ 的值，$n$ 表示人数，$m$ 表示每队最少的人数。`i=m` 是为了保证每队最少的人数。

    ```cpp
    cin >> n >> m;
    i = m;
    ```

2. **初始化队列**：我们设置两个指针，`l` 和 `r`，分别表示左队伍和右队伍的队首。初始时，左队伍的队首为 $1$，右队伍的队首为 $m+1$。

    ```cpp
    l = 1;
    r = m + 1;
    ```

3. **队伍交替出队**：然后我们开始模拟队伍交替出队的过程。如果左队伍的队首已经大于等于右队伍的队首，说明一轮已经结束，我们需要更新队首的位置：左队伍的队首更新为 $m+2$，右队伍的队首更新为 $2m+1$。每次出队时，我们输出左队伍的队首（`l++`）和右队伍的队首（`r--`）。

    ```cpp
    for(i = m; i > 0; i--)
    {
        if(l >= r)
        {
            l = m + 2;
            r = m + m + 1;
        }
        cout << l++ << " " << r-- << "\n";
    }
    ```

综上，我们通过模拟队伍交替出队的过程来实现题目的要求。我们使用两个指针 `l` 和 `r` 来模拟两个队伍，并确保每个队伍的人数都不少于 $m$。

# 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, i, l, r;
int main()
{
	for(cin >> n >> m, i = m, l = 1, r = m + 1; i--; )
	{
		l >= r && (l = m + 2, r = m + m + 1), cout << l++ << " " << r-- << "\n";
	}
}

```

---

## 作者：Yashajin_Ai (赞：0)

### 思路
这道题看到的时候有点懵，但是自己手模一下会发现新的思路。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	cin>>n>>m;
	if(n%2==1){
		for(int i=1;i<=n/2;i++){
			cout<<i<<" "<<n-i<<endl;
		}
	}
	else{
		for(int i=2;i<=(n+m)/2;i++){
			cout<<i<<" "<<(n+m)-i<<endl;
		}
	}
}
```

首先就考虑到了需要分奇偶性讨论，通过样例，发现奇数规律好像是下面这个。

```cpp
for(int i=1;i<=n/2;i++){
	cout<<i<<" "<<n-i<<endl;//所有人成为一组，然后轮流得到编号
}
```

对于偶数没什么考虑，就凑了个数，交了。

![](https://cdn.luogu.com.cn/upload/image_hosting/5q4nifsr.png)

仔细思考了一下，好像奇数有点问题，因为他最多只会有 $m$ 个场地用来比赛，那么最多输出 $m$ 个可行数，这一种的可能性，就是两个人比了后序号加加。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	cin>>n>>m;
		for(int i=0;i<m;i++){
			cout<<m-i<<" "<<n-m+i<<endl;
		}
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/aw0059os.png)

明显这一次奇数思路对了，再考虑偶数，偶数最开始是不知怎么想的，对面大佬给了一个思路，所有偶数把他分成左右两半。

难么跟 $n$ 是奇数的方法就一样了，只是重新分组，从中间截半，如果两半大小是奇数，就把左一半的最右边分到右一半去，否则，左边那半按 ```if(i<n/4) cout<<m-i<<" "<<m+i+1<<endl;```做，右边那半砍掉最后一个，剩下来奇数个，用奇数的方法。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		if(i<n/4) cout<<m-i<<" "<<m+i+1<<endl;
		else cout<<m-i<<" "<<m+i+2<<endl;
	}
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/58guhdoi.png)

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	cin>>n>>m;
	if(n%2==1){
		for(int i=0;i<m;i++){
			cout<<m-i<<" "<<n-m+i<<endl;
		}
	}
	else{
		for(int i=0;i<m;i++){
			if(i<n/4) cout<<m-i<<" "<<m+i+1<<endl;
			else cout<<m-i<<" "<<m+i+2<<endl;
		}
	}
}
```

---

## 作者：STARSczy (赞：0)

# 思路
本题最开始很容易想到这样的输出 $1$ 和 $n-1$，$2$ 和 $n-2$，$3$ 和 $n-3$，但是，当加 $\left\lfloor\frac{n}{2}\right\rfloor$ 次 $1$ 后就会发现与题目相悖，易想到其实是要两个这样对称的组，并且一个间隔的长度为奇，另一个为偶。用两个循环解决。

例如当 $n=6$，$m=2$ 时，输出应为：
```
1 2
3 5
```
而不是：
```
1 6
2 5
```

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
	int n,m;
	cin>>n>>m;
	if(n%2==0) n--;
	for(int i=1;i<=m/2+m%2;++i) cout<<i<<" "<<m+m%2-i+1<<endl;
	for(int i=m/2+m%2+1;i<=m;++i) cout<<i+m/2+m%2<<" "<<n-i+m/2+m%2+1<<endl;
	return 0;
}
```

---

## 作者：chenxia25 (赞：0)

这其实是最难的一题，因为F是套路题。

>### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/AT5237) & [AtCoder题目页面传送门](https://atcoder.jp/contests/abc165/tasks/abc165_e)

>有$n$个人，共$n$轮比赛，每轮所有人往右移一格，最后面的人移到最前面。每轮有$m(2m+1\leq n)$场比赛，每场比赛描述为两个位置，表示每轮都是固定这两个位置的人打比赛，比赛的人集不相交。给出一组$m$场比赛的描述，使得每人在$n$轮里打的$2m$场比赛的对手两两不同。

>$n\in\left[1,10^5\right]$。

一个显然的结论是：若一个人满足题意，则所有人满足题意，因为所有人是轮换对称的（是这么说的吧？）。

当$n$是奇数时，方法显然：位置$i$跟$n-i+1$配。

当$n$是偶数时呢？naive地想，跟$n$是奇数的方法一样的话，那位置关于中心对称的两个人会交两次手，不行。不难发现，根据$2m+1\leq n$可以得出至少有$2$个位置没有比赛，暗示了我们可以牺牲空间换取奇偶性。然后这也没啥可说的，只能手玩一会儿，可以玩出来一种方法：从中间截半，如果两半大小是奇数，就把左一半的最右边分到右一半去。此时两半大小都是偶数，左边那半按naive方法，右边那半牺牲掉最后一个，剩下来奇数个，用奇数的方法。这样是正确的，别问我咋想到的。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
	cin>>n>>m;
	if(n&1)//n为奇数 
		for(int i=1;i<=m;i++)cout<<i<<" "<<n-i+1<<"\n";
	else{//n为偶数 
		for(int i=1;i<=n/4&&m;i++,m--)cout<<i<<" "<<n/4*2-i+1<<"\n";//左一半 
		for(int i=n/4*2+1;m;i++,m--)cout<<i<<" "<<n/4*2+1+n-1-i<<"\n";//右一半 
	}
	return 0;
}
```

---

## 作者：Ranmantic_Tea (赞：0)

楼下找规律瞎搞的，笑死我。(撤了也鞭尸）~~whx1118~~。

本质上就是找不冲突的。原来怎么冲突的，你选定两个数，如 $1$ 和 $2$。你会发现在第 $n-1$ 轮他们会再比一次，这就冲突了。

首先解决这个，最好方案就是往后移一位，改成 $1$ 和 $3$。

但此题不止怎么简单。我们还要考虑其他的比赛。

同样,我们也可在上一轮的基础上往后移一位。创造一个 $2$ 和 $5$。

这样，发现本题好像和奇偶性有关了。

这个时候考虑分为两组去分别处理。

因为是奇数组和偶数组，所以分成 $\dfrac{m}{2}$ 组 和 $m-\dfrac{m}{2}$ 组。

第一组，可以分为 $i$ 和 $(m-\dfrac{m}{2})\times2-i+1$。

第二组，可以分为 $(m-\dfrac{m}{2})\times2+i$ 和 $m\times2-i+2$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define FOR(i,a,b) for(ll i=(a); i<=(b); ++i)
#define ROF(i,a,b) for(ll i=(a); i>=(b); --i)
#define tell(ans) out(ans),printf("\n");
#define say(ans) out(ans),printf(" ");
#define pb push_back
//
//
//
using namespace std;
inline ll read() {
    ll f=0,t=0;
    char c=getchar();
    while(!isdigit(c)) t|=(c=='-'),c=getchar();
    while(isdigit(c)) f=(f<<3)+(f<<1)+c-48,c=getchar();
    return t?-f:f;
}
inline void out(ll x) {
    if(x<0) putchar('-');
    if(x>9) out(x/10);
    putchar('0'+x%10);
}
int main() {
	ll n=read(),m=read();
	for(int i=1;i<=m-m/2;i++) cout<<i<<" "<<(m-m/2)*2-i+1<<endl; 
	for(int i=1;i<=m/2;i++) cout<<i+(m-m/2)*2<<" "<<m*2-i+2<<endl; 
	return 0;
} 

```
——end——

---


# [AGC022B] GCD Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc022/tasks/agc022_b

ナガセは高校の優等生です。ある日のこと、ナガセは正の整数からなる特別な集合のとある性質を分析しています。

ナガセの考えでは、**異なる** 正の整数の集合 $ S\ =\ \{a_{1},\ a_{2},\ ...,\ a_{N}\} $ は、以下の条件を満たす場合に **特別** であると呼ばれます。条件：どの $ 1\ \leq\ i\ \leq\ N $ についても、$ a_{i} $ と、$ S $ のその他の要素の和の最大公約数は $ 1 $ **ではない**。

ナガセは、要素数 $ N $ の **特別** な集合を求めたいです。ところがこれは簡単すぎるので、難易度を上げることにしました。要素数 $ N $ の **特別** な集合であって、すべての要素の最大公約数が $ 1 $ であり、どの要素も $ 30000 $ 以下であるものを求めてみよ、とのことです。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 20000 $

### Sample Explanation 1

$ \{2,\ 5,\ 63\} $ は特別です。なぜなら、$ gcd(2,\ 5\ +\ 63)\ =\ 2,\ gcd(5,\ 2\ +\ 63)\ =\ 5,\ gcd(63,\ 2\ +\ 5)\ =\ 7 $ であり、さらに $ gcd(2,\ 5,\ 63)\ =\ 1 $ であるため、すべての判定条件を満たすからです。 なお、$ \{2,\ 4,\ 6\} $ は解として認められません。$ gcd(2,\ 4,\ 6)\ =\ 2\ >\ 1 $ であるからです。

### Sample Explanation 2

$ \{2,\ 5,\ 20,\ 63\} $ は特別です。なぜなら、$ gcd(2,\ 5\ +\ 20\ +\ 63)\ =\ 2,\ gcd(5,\ 2\ +\ 20\ +\ 63)\ =\ 5,\ gcd(20,\ 2\ +\ 5\ +\ 63)\ =\ 10,\ gcd(63,\ 2\ +\ 5\ +\ 20)\ =\ 9 $ であり、さらに $ gcd(2,\ 5,\ 20,\ 63)\ =\ 1 $ であるため、すべての判定条件を満たすからです。

## 样例 #1

### 输入

```
3```

### 输出

```
2 5 63```

## 样例 #2

### 输入

```
4```

### 输出

```
2 5 20 63```

# 题解

## 作者：myee (赞：5)

### 前言

扫了一圈题解发现没人这么做的……

给出另一种构造方法。

### 思路

考虑令 $6|S$，且各数均为 $2$ 或 $3$ 的倍数。

令 $t=5000$，假设取 $a,b,c,d$ 个模 $6$ 余 $0,2,3,4$ 的数，显然 $a,b,c,d\le t$。

显然 $a+b+c+d=n$ 且 $6|2b+3c+4d$。

把 $b,c,d$ 取得足够大，然后剩下的部分交给 $a$ 即可。

考虑怎么取。

显然可以把条件拆成 $2|c$ 和 $3|d+2b$。

当 $b+d=q$，设 $T=\min(t,q)$，则 $b,d\le T$ 且 $b,d\equiv2q\pmod3$，我们不妨取 $b=T-(T\bmod3)+(2q\bmod3)-3[(t\bmod3)\le(2q\bmod3)]$，$d=q-b$。容易验证 $q\neq1$ 时均合法。

对 $c$ 的部分，我们取 $c=\min(t,n-2-[2\nmid n])$ 即可。

取 $q=\min(2t,n-c)$，剩下部分交给 $a$ 即可。

需要特判 $n=3$。

### Code

核心代码很短。

```cpp
const uint t=5000;
uint n;scanf("%u",&n);
if(n==3){
    puts("2 5 63");
    return 0;
}
uint c=std::min(t,n-2-(n&1));
uint q=std::min(t*2,n-c);
uint T=std::min(q,t);
uint b=T/3*3+2*q%3-3*(T%3<2*q%3);
uint d=q-b;
uint a=n-c-q;
std::vector<uint>V;
for(uint i=1;i<=a;i++)V.push_back(6*i);
for(uint i=0;i<b;i++)V.push_back(6*i+2);
for(uint i=0;i<c;i++)V.push_back(6*i+3);
for(uint i=0;i<d;i++)V.push_back(6*i+4);
for(uint i=0;i<n;i++)
    printf("%u%c",V[i]," \n"[i==n-1]);
return 0;
```



---

## 作者：_Diu_ (赞：5)

[洛谷传送门](https://www.luogu.com.cn/problem/AT3947)

[atcoder 传送门](https://atcoder.jp/contests/agc022/tasks/agc022_b)

## 构造好题

第一个条件：

只要先安排两个互质的数，那么后面不管怎么加都班组条件。

第二个条件：

先摆一个结论：$[\gcd(a,S-a)]=[\gcd(a,S)]$。

所以只需要满足 $\gcd(a,S)\not=1$ 就可以了。

如果我们把序列分成若干组，每一组和相同。

那么只要每一组内符合这个条件，就满足这个条件。

我们每个组内放两个数，为了考虑到第三个条件，我们钦定每一组的和为 $30000$。

第一组可以安排 $2,3,29995$。

这样后面若干组只需要第一个数被 $2,3,5$ 中任意一个数整除，并且这些数之间不重复就可以了。

如果 $n$ 是偶数，那么再补一个 $30000$ 就可以了。

可以证明能凑出的数是远远超过 $20000$ 的。

这道题构造方法很多，以上只是其中一种。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
signed main(){
	scanf("%lld",&n);
	printf("2 3 29995 ");
	if(n%2==0)printf("30000 "),--n;
	n-=3,n/=2;
	for(int i=6;n--;){
		for(;!(i%2==0||i%3==0||i%5==0);++i);
		printf("%d %d ",i,30000-i);
		++i;
	}
}
```

---

## 作者：Pekemetier (赞：3)

题解太少了，来混点贡献分。

**条件：**

1. 所有数的 $\gcd$ 和为 $1$ 。

2. 所有数与 $sum$ 不互质。

3. $1$ 到 $30000$ 中选出 $20000$ 个数。

先考虑第一个，随便选两个互质的数即可，为了简单，可以考虑先选 $2$ 和 $3$ 。

然后考虑第二个，因为选了 $2$ 和 $3$ ，所以 $sum$ 是 $6$ 的倍数。那么可以先选前 $n-2$ 个数，最后两个凑一下，让最后总和为 $6$ 的倍数。

这样的话恰好能在 $30000$ 中选出 $20000$ 个数。

唯一值得注意的是此方法不适用于 $n=3$ 的情况，特判掉即可。

Code:

```cpp
#include<cstdio>
int n,sum,k,lst;
int main()
{
	scanf("%d",&n);
	if(n==3){printf("2 5 63");return 0;}
	for(int i=2;i<=30000&&k+2<n;++i)
		if((i&1)==0||i%3==0)
		{
			++k;
			lst=i;
			sum+=i;
			printf("%d ",i);
		}
	++lst;
	for(int i=lst;i<lst+12&&i<30000;++i)
		for(int j=i+1;j<lst+12&&j<=30000;++j)
			if(((i&1)==0||i%3==0)&&((j&1)==0||j%3==0)&&((sum+i+j)%6==0))
			{
				printf("%d %d",i,j);
				return 0;
			}
}
```


---

## 作者：火车司机 (赞：2)

## 简要分析

可以发现，只要整个序列中存在两个数互质，整个序列的 $gcd$ 必然 $=1$

所以我们简单地将序列的前两项规定为 $2$ 和 $3$

然后考虑怎么满足第二个条件

可以将其转化为：对于所有的 $1 \leq i \leq N$，都有 $gcd(a_i,S) \neq 1$

因为前两项被我们规定为了 $2$ 和 $3$，所以这个 $S$ 必然是 $6$ 的倍数，正好与题目所给的最大值 $30000$ 相吻合

只需要构造出一组合法方案的话我们不妨设 $S=(N-2) \times 30000$

因此序列的第 $3$ 项必然为 $29995$，经验证符合题意

接下来放进序列的数只需要满足与 $30000$ 不互质，且互不相同，使得 $S=(N-2) \times 30000$ 就行了

所以我们一对一对地把 $2$的倍数和 $30000-$它，以及$3$的非偶倍数和 $30000-$它放进去，显然满足上述条件

如果最后不足一对，我们可以单放一个 $30000$

需要注意的是，这样构造出了序列最长也就只有 $19998$ 个数

所以我们可以再在最后补一对  $25$ 和 $29975$，因为更小的 $5$ 的倍数都已经出现过序列中了

## 完整代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ri register int
using namespace std;
int n;
template <typename T>
inline void read(T &x)
{
	register T f = 0, c = getchar();
	for (; c < 48 || 57 < c; c = getchar())
		if (c == '-')
			f = 1;
	for (x = 0; 48 <= c && c <= 57; c = getchar())
		x = (x << 3) + (x << 1) + (c & 15);
	if (f)
		x = ~(--x);
}
template <typename T>
inline void print(T x)
{
	if (x < 0)
		putchar('-'), x = ~(--x);
	if (x > 9)
		print(x / 10);
	putchar(x % 10 | 48);
}
signed main()
{
	read(n), print(2), putchar(' '), print(3), putchar(' '), print(29995), putchar(' '), n -= 3;
	if (n & 1)
		print(30000), putchar(' '), --n;
	if (!n)
		return 0;
	for (ri i = 4, j = 29996; i < j && n; i += 2, j -= 2, n -= 2)
		print(i), putchar(' '), print(j), putchar(' ');
	for (ri i = 9, j = 29991; i < j && n; i += 6, j -= 6, n -= 2)
		print(i), putchar(' '), print(j), putchar(' ');
	if (n)
		print(25), putchar(' '), print(29975), n -= 2;
	return 0;
}
```


---

## 作者：Texas_the_Omertosa (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/AT3947)

### 0x01 思路

这题有三个条件，我们一个一个来满足。

1. $\gcd\left(a_1,a_2,\dots,a_N\right) = 1$

这个很好办，安排两个互质的数就行了。

2. 对于所有的 $1\le i\le N$，都有 $\gcd\left(a_i,S-a_i\right)\not=1$

我们可以把 $\gcd\left(a_i,S-a_i\right)$ 转化成 $\gcd\left(a_i,S\right)$，这样的话，只要把数列分出几组，每一组的和定为一个常数就行了。

3. 所有的 $a_i$ 互不相同，并且 $1\le a_i\le30000$

这个也很好办，一开始就确定的数极端大（但不超过 $30000$）和极端小（但大于 $0$）就行了。

综上所述，我们先确定 $2$ 与 $3$，故 $6\mid S$。而 $6\mid30000$，所以我们把每一组的和定为 $30000$，这样可以避免数字过大，则第一组还有一个 $29995$。后面每一组定为两个数，分别为 $m$ 与 $30000-m$，前提是 $2\mid m$ 或 $3\mid m$ 或 $5\mid m$。如果 $N$ 是偶数，则添上一个 $30000$。

### 0x02 AC Code

```cpp
//by olkieler
#include <bits/stdc++.h>
#define int long long
#define linf LLONG_MAX
#define iinf INT_MAX
#define ios ios::sync_with_stdio(0);cin.tie(0);
#define N 15
#define M 300005
#define mod 1000000007
#define pint pair<int, int>
#define mp make_pair
using namespace std;
signed main()
{
	ios;
	int n;
	cin >> n;
	cout << "2 3 29995 ";
	if (!(n % 2))
	{
		cout << "30000 ";
		n --;
	}
	n -= 3;
	n /= 2;
	for (int i = 6; n; i ++)
	{
		if (!(i % 2) || !(i % 3) || !(i % 5))
		{
			n --;
			cout << i << ' ' << 30000 - i << ' ';
		}
	}
	cout << '\n';
	return 0;
}
```

还有不懂的可以私信或评论。

---

## 作者：COsm0s (赞：1)

## 思路

+ 只要先安排两个互质的数，那么整个序列的最大公因数都一定为 $1$。

+ 题目说 $\gcd(a,S-a)≠1$，我们可以将它转化为 $\gcd(a,S)≠1$.

证明：

设 $a$ 和 $b$ 有公因数 $k$，则 $a=pk$，$b=qk$。

则 $a-b=(p-q) \times k$，则 $k$ 既是 $a$ 的因数，也是 $b$ 的因数，更是 $a-b$ 的因数。

显然，$k$ 可以取任何公因数，包括最大公因数。

故 $\gcd(a,S-a)=\gcd(a,S)$

**注：原文出自[这里](https://www.zhihu.com/question/441593398)**

+ 如果我们把序列分成若干组，每一组和相同。

那么只要每一组符合条件，则整个序列满足这个条件。

我们每个组内放两个数，为了考虑到 $1≤a_i≤30000$，我们设每一组的和为$30000$，第一组放 $2,3,29995$。

后面加进来的数，满足能整除 $2,3,5$ 中任意一个就可以放进序列。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin >> n;
	if(n % 2 == 0) printf("30000 "),-- n;//n是偶数要再加一个30000
	n -= 3;
	printf("2 3 29995 ");
	for(int i = 6; i <= 1e7 + 10; ++ i) {
		if(!n)break;
		if(i % 2 == 0 || i % 3 == 0 || i % 5 == 0) 
			n -= 2,printf("%d %d ", i, 30000 - i);
	}
	puts("");
	return 0;
}
```


---

## 作者：SpeMars (赞：1)

~~显然这道题我们要构造一个序列~~

我们先考虑 `gcd` 的限制，我们要使得整个序列 `gcd` 为 $1$ 那么最简单的方法就是选两个质数，后面无论怎么加数 `gcd` 不变。

那么我们就可以放入 $2$，$3$，然后要使得总和减去序列中任意一个数的 `gcd` 与这个数都大于 $1$。 

那么我们可以先构造一个序列，使得其总和始终保持为 $30000$ 的倍数，

那么其添加的数中只要也为 $2$ 或 $3$ 或 $5$ 的倍数时，则符合条件。

所以我们可以用这个数，记为 $x$，和 $30000-x$ 放入序列，不仅保证了和为 $30000$ 的倍数，同是也满足 `gcd` 的限制。

所以数列前三个数就为 $2,3,29995$ 后面就按照和为 $30000$ 构造，如果还少了一个数，就加入 $30000$ 即可。

## code:

```cpp
#include<cstdio>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	if(n%2==0)printf("30000 "),--n;
	n-=3;
	printf("2 3 29995 ");
	for(int i=6;i<=114514;++i){
		if(!n)break;
		if(i%2==0||i%3==0||i%5==0){
			n-=2;
			printf("%d %d ",i,30000-i);
		}
		if(!n)break;
	}
	puts("");
	return 0;
}
```

---

## 作者：kcn999 (赞：1)

因为有条件 $\gcd(a_1,a_2,\cdots,a_n)=1$，所以可以考虑丢两个互质的数进去。

不妨先把 $2$ 和 $3$ 丢进去，此时一定满足上面的条件。容易想到，我们可以尝试构造一个只包含 $2$ 的倍数或 $3$ 的倍数的序列。

然而还有条件 $\gcd(a_i,S-a_i)\neq 1$，则需要满足若 $a_i$ 为 $2$ 的倍数，则 $S-a_i$ 为 $2$ 的倍数；若 $a_i$ 为 $3$ 的倍数，则 $S-a_i$ 为 $3$ 的倍数。

所以相当于要让 $2$ 的倍数之和等于 $3$ 的倍数，要让 $3$ 的**奇数**倍数和等于 $2$ 的倍数。

容易发现下述构造方案：

- 当 $n \le \dfrac{30000}{6}+3=5003$ 时：

	- 若 $n \bmod 2=0$，则我们从小到大插 $n-2$ 个 $3$ 的奇数倍数，然后再插 $2,4$。
   - 若 $n \bmod 2=1$，则我们从小到大插 $n-3$ 个 $3$ 的奇数倍数，然后再插 $2,4,6$。
   
- 当 $n > 5003$ 时，此时我们先把 $5000$ 个 $3$ 的奇数倍数都插进去，然后：

	- 若 $(n-5000)\bmod 3=0$，则我们直接从小到大插 $n-5000$ 个 $2$ 的倍数。
   - 若 $(n-5000)\bmod 3=1$，则我们直接从小到大插 $n-5000-1$ 个 $2$ 的倍数，然后再插 $2 \times (n - 5000+2)$。
   - 若 $(n-5000)\bmod 3=2$，则我们直接从小到大插 $n-5000-2$ 个 $2$ 的倍数，然后再插 $2 \times (n - 5000-1),2\times (n-5000)$。
   
可以发现序列最长大小为 $\dfrac{30000}6+\dfrac{30000}2=20000$，刚好卡到 $n$ 的上界。容易证明上述方案的正确性。

注意 $n=3$ 的时候要直接输出样例。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[20005], b[20005];
int cnt2, cnt3;
int main() {
	scanf("%d", &n);
	if (n == 3) {
		printf("2 5 63");
		return 0;
	}
	if (n <= 5003) {
		if (n % 2 == 0) {
			for (int i = 1; i <= n - 2; ++i)
				b[++cnt3] = 3 * (2 * i - 1);
			a[++cnt2] = 2 * 1;
			a[++cnt2] = 2 * 2;
		}
		else {
			for (int i = 1; i <= n - 3; ++i) 
				b[++cnt3] = 3 * (2 * i - 1);
			a[++cnt2] = 2 * 1;
			a[++cnt2] = 2 * 2;
			a[++cnt2] = 2 * 3;
		}
	}
	else {
		for (int i = 1; i <= 5000; ++i) 
			b[++cnt3] = 3 * (2 * i - 1);
		n -= 5000;
		if (n % 3 == 0) {
			for (int i = 1; i <= n; ++i)
				a[++cnt2] = 2 * i;
		}
		else if (n % 3 == 1) {
			for (int i = 1; i <= n - 1; ++i)
				a[++cnt2] = 2 * i;
			a[++cnt2] = 2 * (n + 2);
		}
		else {
			for (int i = 1; i <= n - 2; ++i)
				a[++cnt2] = 2 * i;
			a[++cnt2] = 2 * (n - 1);
			a[++cnt2] = 2 * n;
		}
	} 
	for (int i = 1; i <= cnt2; ++i) printf("%d ", a[i]);
	for (int i = 1; i <= cnt3; ++i) printf("%d ", b[i]);
	return 0;
}
```

---

## 作者：ZHANGyutao123 (赞：0)

# 题目大意

给你一个长度为 $n$ 的序列，要求它满足以下条件：

- $\gcd(a_1,a_2,\dots,a_n)=1$；
- 对于所有的 $1\le i\le n$，都有 $\gcd(a_i,\sum\limits_{j=1}^na_j-a_i)\neq 1$；
- 所有的 $a_i$ 互不相同，并且 $1\le a_i\le30000$。

要求你构造出符合要求的序列。

# 过程分析

这道题看起来好像不太好做，但我们可以试着推一下规律。考虑 $n$ 是奇数的情况，我们可以构造一个形如 $2,3$，$29995$ 以及 $2\times p_1,30000-2\times p_1,2\times p_2,30000-2\times p_2\dots 2\times p_k,30000-2\times p_k$ 的序列，其中 $p_1,p_2\dots, p_k$ 是奇素数。

## 证明：

- $\gcd (a_1,a_2\dots,a_n)=1$。

显然，$2$ 和 $3$ 的 $\gcd$ 可以化为 $1$，而其他的都是奇数，因此也能满足。

- 对于每个 $a_i$，都有 $\gcd(a_i,S-a_i)\neq 1$。

我们设 $S'=\sum\limits_{j=1}^na_j-a_i$，$d=\gcd(a_i,S')$，显然，$d|a_i$ 以及 $d|S'-a_i$，$S'$ 减去 $a_i$ 不影响其他数的 $\gcd$，因此 $\gcd(a_i,S-a_i)=\gcd(a_i,S')=\frac{\gcd(a_i,S)}{\gcd(a_1,a_2,\dots,a_n)}=\frac{a_i}{d}\cdot\kappa$，其中 $\kappa$ 是 $a_1,a_2,\dots,a_n$ 除去 $a_i$ 后的 $\gcd$。

可以看出，$a_i$ 如果是奇数，那么 $d$ 也应该是奇数，于是 $a_i$ 和 $S-a_i$ 都不是偶数，$\gcd(a_i,S-a_i)$ 一定要满足是奇数。

由此我们发现 $S$ 的奇偶性要和 $n$ 的奇偶性相同。如果 $n$ 是奇数，那么我们不需要再加其他奇数了，因为加上奇数后会超过 $30000$，此时只需要套公式即可。

但是如果 $n$ 是偶数，那么我们还需要加一个 $a_{n+1}=30000$ 以满足第二个条件，因为当只有偶数个数时，它们的和必定是偶数，不可能满足条件。

时间复杂度：$O(n)$。

# 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin >> n;
	if (n % 2 != 1) {//如果 n 是偶数
		printf("30000 ");//加上 30000
		n --;
	}
	//2、3、29995 
	printf("2 3 29995 ");
	n -= 3;
	//查找奇素数
	for (int i = 6; i <= 1e7 + 10; i += 2) {
		if (! n) break;//如果构造满了，就跳出循环，不再查找
		//只有不含 2 、3、5 的数才会满足条件
		if (i % 2 == 0 || i % 3 == 0 || i % 5 == 0) continue;
		n -= 2;
		printf("%d %d ", i, 30000 - i);//对于奇素数 i，选它和 30000 减去它组成的数
	}
	return 0;
}
```


---

## 作者：19ty84 (赞：0)

## 题意
构造一个长度为 $N(3 \le N \le 20000)$ 的序列 $a$，记 $S=\sum_{i=1}^N a_i$，满足：
1. $\gcd(a_1,a_2,\dots,a_N)=1$
2. $\gcd(a_i,S-a_i) \neq 1$
3. $a_i$ 互不相同，且 $1 \leq a_i \leq 30000$

## 分析
为了满足条件 1，我们的数列至少要有两个数互质。我们让数列的开头是 $2$ 和 $3$。为什么不用 $1$ 和 $2$？因为 $1$ 与任何数互质，无法满足条件 2。

为了满足条件 2，我们发现，若 $\gcd(a_i,S) \neq 1$，则 $\gcd(a_i,S-a_i) \neq 1$。因此，我们要使数列里的每个数与数列的和不互质。为了使可操作空间最大化，我们在第三个数上选择尽可能大的数。可以发现，第三个数选择 $29995$ 时，能够满足所有条件。这样，前 3 个数的和刚好是 $30000$。

接下来，我们开始凑长度。$30000$ 的倍数与 $2$、$3$、$5$ 的倍数不互质，因此我们可以每两个数组成一组，每组的和为 $30000$。具体的，就是一次添加两个数：$2$、$3$、$5$ 的倍数和 $30000$ 减去这个数。注意不要重复。

最后，如果只剩一个数要添加时，就直接添加 $30000$。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std; 
int n,it1,it2,it3; 
int main(){
	cin>>n;
	cout<<2<<" "<<3<<" "<<29995<<" ";
	n-=3;
	it1=4;it2=9;it3=25;
	while(n>1){
		if(it1<15000){
			cout<<it1<<" "<<30000-it1<<" ";
			it1+=2;
			n-=2;
		}
		else if(it2<15000){
			cout<<it2<<" "<<30000-it2<<" ";
			it2+=6;
			n-=2;
		}
		else if(it3<15000){
			cout<<it3<<" "<<30000-it3<<" ";
			it3+=30;
			n-=2;
		}
		else break;
	}
	if(n)cout<<30000;
	return 0;
} 
```

---


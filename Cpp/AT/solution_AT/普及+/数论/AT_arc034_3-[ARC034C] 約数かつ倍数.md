# [ARC034C] 約数かつ倍数

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc034/tasks/arc034_3

$ 2 $ 個の正整数 $ A,\ B $ が与えられる。 $ A! $ の約数であり、かつ $ B! $ の倍数でもあるような正整数の個数を $ 1,000,000,007 $ で割った余りを求めよ。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 5 $ 点分のテストケースは $ 1\ ≦\ B\ ≦\ A\ ≦\ 15 $ を満たす。
- 別の $ 35 $ 点分のテストケースは $ 1\ ≦\ B\ ≦\ A\ ≦\ 10^6 $, $ A\ -\ B\ ≦\ 100 $ を満たす。

### Sample Explanation 1

正整数 $ n $ に対し、 $ n! $ は $ n $ の階乗 $ n\ ×\ (n\ -\ 1)\ ×\ (n\ -\ 2)\ ×\ ...\ ×\ 1 $ を表す。 $ 3!\ =\ 3\ ×\ 2\ ×\ 1\ =\ 6 $ の約数であり、かつ $ 2!\ =\ 2\ ×\ 1\ =\ 2 $ の倍数であるような正整数は $ 2, $ $ 6 $ の $ 2 $ 個存在する。

## 样例 #1

### 输入

```
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
15 4```

### 输出

```
2592```

## 样例 #3

### 输入

```
1000000 999900```

### 输出

```
21398499```

## 样例 #4

### 输入

```
1000000000 999999900```

### 输出

```
745508745```

# 题解

## 作者：Kevin_Wa (赞：3)

### 题意解析：

给出两个正整数$A,B$，求出既是$A!$的约数（因数），又是$B!$的倍数的正整数个数。结果对$1,000,000,007$取模。

我们很容易就能看出，由于$B \leq A$，所以也就是说$A! mod B!=0$，所以此题可以转换为求$A! / B!$的因子个数，$A! / B!$的因子再乘一个$B!$即为题目中所求的正整数。

即答案为$(B+1) \times (B+2)...\times A$的因子个数。

还不会？

因为题目保证了$A-B\leq 100$所以直接暴力枚举其中的每个数的质数因子个数，最后答案为所有质数个数加上$1$的积。

此题完结。话说岛国的题也不难。

### 注意点：

> 1、此题要取模。

> 2、此题中可能出现的质数可能会比你筛出的要大，记得特判，然后直接在答案上$\times 2$。

> 3、存储的变量要开$long long$，有些因子的个数很多，有时比较接近模数时会炸$int$~~（调了半个小时）~~

### 评价：

此题考了基础数论，本人数论不好，但仍然可做。可用于数论新手食用。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int A,B,i,t,n,b[40010];
int f[40010],a[40010];
template <typename T> void read(T &x) {
x = 0; char c = getchar();
for (; !isdigit(c); c = getchar());
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
}
int pd(int x)
{
	for (int i=2;i<=sqrt(x);i++)
	  if (x%i==0) return 1;
	return 0;
}
int main()
{
//freopen(".in","r",stdin);
//freopen(".out","w",stdout);
read(A);read(B);
for (int i=2;i<=sqrt(1000000000);i++)
  if (!f[i])
  {
  	n++;
  	a[n]=i;
  	for (int j=2;i*j<=sqrt(1000000000);j++)
  	  f[i*j]=1;
  }
long long sum=1;
for (int i=B+1;i<=A;i++)
    {
    	int x=i,t=1;
    	while (x>1 && t<=n)
		   {
		   	while (x%a[t]==0)
		   	  x=x/a[t],b[t]++;
		   	  t++;
		   }
		if (x>a[n]) sum=(sum*2)%1000000007;
		else if (x>1) b[x]++;
		//printf("%d\n",x);
	}

for (int i=1;i<=n;i++)
  sum=(sum*(b[i]+1))%1000000007;
printf("%d\n",sum);
return 0;
}
```


---

## 作者：Escapism (赞：0)

数论题。

[传送门](https://www.luogu.com.cn/problem/AT1195)

# 题意

给定正整数 $A,B$，求出既是 $A$ 阶乘结果的因数，又是 $B$ 阶乘的倍数的数的个数。

结果取模 $10^9 + 7$。

# 思路

稍稍进行一些推导即可。

因为 $A>B$，所以 $A!>B!$。因为是阶乘，必然 $A!$ 整除 $B!$。

我们令 $\dfrac{A!}{B!}=k$，显然如果 $B!$ 乘任意一个 $k$ 的因数就可以满足条件。现在我们把问题转化为求 $k$ 的因数个数。

$A$ 和 $B$ 的数据范围本身很渗人，但保证 $A-B\leq100$。所以通过 $(B+1) \times (B + 2) \times......\times(A-1) \times A$ 暴力分解质因数，然后根据因数个数定理求因数个数。

下面有对因数个数定理的讲解和证明，会的同学可以直接跳过。

---

**因数个数定理**

一个正整数可以被分解质因数为 $p_1^{k_1}\times p_2^{k_2} \times p_3^{k_3} \times........\times p_n^{k^m}$，那么它的因数个数就是 $(k_1+1)\times(k_2+1)\times(k_3+1)\times......\times(k_n+1)$。

**证明**

原理不难，但需要结合乘法原理。对于每一个质因数 $p_n$,所能选择的指数就是 $1$ 至 $k_n$。因为还可以不选，所以所能够选择的指数总数为 $0$ 至 $k_n$，共 $k_n+1$ 个。

---

# 代码

~~这个作者太懒了，代码鸽子了~~

---


# [ARC188B] Symmetric Painting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc188/tasks/arc188_b

円周上を $ N $ 等分する位置に、点 $ 0,1,\ \ldots\ ,\ N-1 $ がこの順に並んでおり、Alice が点 $ 0 $ に、Bob が点 $ K $ にいます。また、初め全ての点は白色に塗られています。両者は、Alice から始めて交互に次のような操作を行います。

- その時点で白色である点を $ 1 $ つ選び、黒色に塗る。ただし、操作後に、操作者と円の中心を結ぶ直線に対して、各点の色が線対称でなければいけない。

操作者が上記の条件を満たす操作ができなければ、そこで一連の操作を打ち切ります。

両者とも、最終的に最も多くの点を黒く塗ることができるように協力して最善の選択をします。一連の操作が全て終了したときに全ての点を黒く塗ることができているかどうかを求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えてください。

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 10^5 $
- $ 2\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ K\leq\ N-1 $
- 入力される値はすべて整数である

### Sample Explanation 1

$ N=6,\ K=2 $ の場合、例えば以下のような順で操作を行うことで全ての点を黒く塗ることができます。 1. Alice が点 $ 3 $ を黒く塗る。 2. Bob が点 $ 1 $ を黒く塗る。 3. Alice が点 $ 5 $ を黒く塗る。 4. Bob が点 $ 2 $ を黒く塗る。 5. Alice が点 $ 4 $ を黒く塗る。 6. Bob が点 $ 0 $ を黒く塗る。 !\[\](https://img.atcoder.jp/arc188/ecb64f0798aaa883117c594cb6db2724.png) $ N=6,\ K=3 $ の場合、例えば以下のような進行が考えられます。実は、どのようにしても全ての点を黒く塗ることはできません。 1. Alice が点 $ 3 $ を黒く塗る。 2. Bob が点 $ 0 $ を黒く塗る。 3. Alice はどの点を黒く塗っても自身から見て線対称にできないため、操作を行えない。

## 样例 #1

### 输入

```
4
6 2
6 3
6 1
200000 100000```

### 输出

```
Yes
No
Yes
No```

# 题解

## 作者：Xuan_qwq (赞：6)

### 题面大意
在一个圆上有 $N$ 个间隔相等的点，依次编号为 $0,1,\dots,N−1$，Alice 在点 $0$ 处，Bob 在点 $K$ 处。

初始时，所有点的颜色都是白色。从 Alice 开始，他们交替执行以下操作：
- 选择当前白色点中的一个点，将其染成黑色。操作完成后，各点的颜色必须与连接操作者和圆心的直线对称。

如果操作符无法执行满足上述条件的操作，则操作序列就此结束。双方合作并做出最佳选择，使最后被涂成黑色的点的总数达到最大。

确定操作序列结束时是否所有点都被染成黑色，是则输出 `Yes`，不是则输出 `No`。

### 思路

以下所有点的编号对 $N$ 取模。

当第一个染色点确定时，两人的每一步操作都是确定的：Alice 第一步染点 $x$，Bob 第二步只能染 $x$ 关于点 $K$ 的对称点……

而在对称的过程中，如果 Bob 上一次染了点 $x$，则 Alice 这一轮会染点 $-x$；如果 Alice 上一次染了点 $x$，则 Bob 这一轮会染点 $2K-x$。

而如果 Alice 第一步绘制的是点 $0$，那么两人的染色顺序将是：
$$0,2B,-2B,4B,-4B,\dots$$
这种情况一直持续到所有与 $0$ 距离为 $\gcd(N,2K)$ 的点全部染色为止。如果 $N$ 为偶数且 Alice 第一步绘制的是点 $\frac{N}{2}$，最终的染色序列也是一样的。此时整个圆在 Alice 和 Bob 看来都是对称的。

此时考虑已经被染色的点数 $X=\frac{N}{\gcd(N,2K)}$：

若 $X$ 是奇数，则此时轮到 Bob 染色。容易知道此时点 $K$ 一定被染色了。
- 如果在给出的点中并没有点 $K$ 的对径点（即 $N$ 为奇数），Bob 将无法操作。此时如果 $\gcd(N,2K)=1$，则已经染色完成，否则无法全部染色。
- 否则，$N$ 为偶数，此时点 $K$ 的对径点一定尚未染色。Bob 可以将点 $K$ 的对径点染色，然后开启新一轮操作，对 $X$ 个点进行染色，往后将无法进行任何染色操作。此时如果 $2X=N$，即 $\gcd(N,2K)=2$，则已经全部染色，否则复发全部染色。

若 $X$ 是偶数，则此时轮到 Alice 染色。容易知道 $N$ 为偶数且点 $0$ 的对径点已经染色，Alice 无法继续染色。而此时 $\gcd(N,2K)$ 至少是 $2$，所有点并没有全部染色，也无法全部染色。

综上，可以全部染色的条件为一下两者之一：
- $\gcd(N,2K)=1$。
- $\gcd(N,2K)=2$ 且 $\frac{N}{2}$ 为奇数。

直接判断输出即可，代码就不放了。

---

## 作者：Milthm (赞：3)

首先，我们是可以以 $O(n)$ 的时间复杂度判断一组 $(n,k)$ 是否合法的。

具体来说，如果 $n$ 为奇数，那么此时每个人操作的时候必须把上一个人涂黑的对称点涂黑，如果已经涂黑则为不合法；如果 $n$ 是偶数，只需要在奇数的基础上加一个特判：有的时候 $k$ 或 $k$ 的对称点已经被涂了，可以涂它们的对称点。

这样就得到了一份单次 $O(n)$ 的解决方案：


```cpp
int check(int n,int k){
	memset(vis,0,sizeof(vis));
	if(n%2==0){
		int lst=n/2;vis[n/2]=1;
		for(int i=2;i<=n;++i){
			if(i%2){
				if(vis[n-lst])return 0;
				vis[n-lst]=1;lst=n-lst;
			}
			else{
				int u=k*2-lst;
				u=(u+n)%n;
				if(!(!vis[u]||u==k&&!vis[(k+n/2)%n]||u==(k+n/2)%n&&!vis[k]))return 0;
				if(u==k)u=(k+n/2)%n;
				else if(u==(k+n/2)%n)u=k;
				vis[u]=1;lst=u;
			}
		}
	}
	else{
		int lst=0;vis[0]=1;
		for(int i=2;i<=n;++i){
			if(i%2){
				if(vis[n-lst])return 0;
				vis[n-lst]=1;lst=n-lst;
			}
			else{
				int u=k*2-lst;
				u=(u+n)%n;
				if(vis[u])return 0;
				vis[u]=1;lst=u;
			}
		}
	}
	return 1;
}
```

虽然它会超时，但是可以用这个程序迅速的打出一个表：

![](https://cdn.luogu.com.cn/upload/image_hosting/gp2rqtmd.png)

还是有很多规律的，比如 $n$ 是 $4$ 的倍数一定无解，但是其它情况看起来比较杂乱。

于是我们先拿 $51$ 举例，$n=51$ 时无解的 $k$ 有 $3,6,9,12,15,17,18$ 等。

发现了什么？这些数都不与 $51$ 互质。但是我们很容易地发现了反例：$n=58$ 时，所有 $2$ 的倍数都没有被标记为无解。

再结合底下几个，我们发现了，这个“互质”是要把 $2$ 这个因子**都去掉**的。

所以得出了最终的结论：

- $n$ 被 $4$ 整除无解。

- $n$ 不被 $4$ 整除，则除去因子 $2$ 后，$n$ 与 $k$ 互质有解，否则无解。

时间复杂度 $O(T\log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main(){
	cin>>T;
	while(T--){
		int n,k;cin>>n>>k;
		if(n%4==0)cout<<"No\n";
		else{
			while(n%2==0)n/=2;
			while(k%2==0)k/=2;
			if(__gcd(n,k)==1)cout<<"Yes\n";
			else cout<<"No\n";
		}
	}
	return 0;
}

```

---

## 作者：ran_qwq (赞：0)

先手玩一下。

对于一个操作者来说，要使操作后局面对于他对称，需要按以下的决策操作：

- 如果本来对于他就是对称的（对方上一标记了自己或自己的对面），他仍然要标记在这条对称轴上；
- 如果本来不是对称的，要标记在上一个位置的对称点上。

如果 $n\bmod 4=0$，无解，证明如下：

- 若 $k\ne\dfrac n2$，初始放的棋子是偶数，每次一个人标记的位置不是下一个人的对称轴，所以下一个人需要按决策 $2$ 操作，即没有空余时间去进行其他操作，如果标记到当前位置已经被标记过就完蛋了。而考虑这么一件事情，每次一个点对称到另一个点，这个点的奇偶性不变，证明显然。所以总会标记偶数点，奇数点标记不到，无解。
- 若 $k=\dfrac n2$，显然只能标记两个位置，无解。

否则有解当且仅当 $\gcd(n,k)\le2$。对称时模 $\gcd(n,k)$ 始终为 $0$。而不变的是一方可以及时退出当轮涂色，涂他的对称轴上没涂过的那个点。所以这种涂色只会进行两轮，即周期 $\le2$。

```cpp
void QwQ() {
	int n=rd(),k=rd();
	puts(!(n&3)?"No":__gcd(n,k)<=2?"Yes":"No");
}
```

---


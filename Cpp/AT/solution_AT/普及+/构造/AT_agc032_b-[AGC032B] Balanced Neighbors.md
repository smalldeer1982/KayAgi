# [AGC032B] Balanced Neighbors

## 题目描述

给定整数 $N$，构造一个从 $1$ 到 $N$ 编号的 $N$ 个节点的无向图，使得：

- 该图不含有重边和自环，并且是连通的。
- 每个节点的所有邻接节点的编号之和相同。

可以证明这样的图一定存在。

## 说明/提示

$3 \leq N \leq 100$。

【样例解释】

对于所有节点，其邻接节点的编号之和均为 $3$。

## 样例 #1

### 输入

```
3```

### 输出

```
2
1 3
2 3```

# 题解

## 作者：约瑟夫用脑玩 (赞：9)

请求修改翻译：“边数尽可能少且为连通图”改为“简单连通图”

其他题解都什么玩意看不懂。

考虑生成一个图满足以下条件：

- 不连通
- 存在某个整数 $S$，对于任意的顶点，**该顶点**与该顶点邻接的顶点的编号的值的和为 $S$。

显然这个图的补图满足：

- 连通图
- 存在某个整数 $S$，对于任意的顶点，与该顶点邻接的顶点的编号的值的和为 $S$。

于是我们构造这样一个图输出其补图即可。

随手构造一下：

- $n$ 为奇数，连边 $(1,n-1),(2,n-2),\dots$，每个顶点及邻点的编号和为 $n$。
- $n$ 为偶数，连边 $(1,n),(2,n-1),\dots$，每个顶点及邻点的编号和为 $n+1$。

轻度压行代码：

```
int i,j,k=(n=read())&1;k=!k+n;writenum((n*(n-1)>>1)-(n>>1),10);
for(i=1;i<=n;i++)for(j=i+1;j<=n;j++)if((i+j)^k)writenum(i,32),writenum(j,10);
```

---

## 作者：ycy1124 (赞：2)

### 题意
给出一个数 $n$。试构造出一个简单无向图使得每个点连接的点的编号和相等。
### 思路
尝试反着来，首先连出一张完全图。编号为 $i$ 的点连的编号和等于 $\frac{n\times(n-1)}{2}-i$，并且编号为 $n$ 的点所连的编号和最小。我们设点 $i$ 所连的点的编号和等于 $w_i$。我们考虑将所有的 $w_i$ 变成 $w_n$。发现 $w_1-w_n=n-1$ 并且 $w_{n-1}-w_n=1$，于是只需要将点 $1$ 和点 $n-1$ 断开即可使这两个点满足。我们不妨大胆猜测，只需要将两个点的编号相加的和为 $n$ 的点断开即可。但是 $n$ 是偶数时 $\frac{n}{2}$ 自己不能连自己，于是在 $n$ 是偶数时断开编号的和为 $n+1$ 的两个点。

证明：此时 $w_i$ 与 $w_n$ 的差为 $n-i$，$w_{n-i}$ 与 $w_n$ 的差为 $i$，显然只需要将这些点两两配对断开他们之间的边即可满足条件。但是偶数时断开 $1$ 和 $n$ 为什么满足呢？我们可以先假设一个 $n+1$ 的点给他们所有点连上一条边，我们发现此时就变成 $n+1$ 为奇数的情况了，这些点的 $w_i$ 都等于 $w_{n+1}$，然后将这个点 $n+1$ 去掉，每个 $w_i$ 减去 $n+1$ 还是全部相等。
### 代码
代码很短，请勿抄袭。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    cout<<n*(n-1)/2-n/2<<'\n';
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            if(i+j!=n+(n%2==0?1:0)){
                cout<<i<<' '<<j<<'\n';
            }
        }
    }
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/202980918)。

---


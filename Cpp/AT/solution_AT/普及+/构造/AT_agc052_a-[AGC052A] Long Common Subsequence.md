# [AGC052A] Long Common Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc052/tasks/agc052_a

$ 3 $ つの $ 01 $ 文字列 $ S_1,\ S_2,\ S_3 $ が与えられます。これらはそれぞれ、`0` と `1` を $ N $ 個ずつ含みます。

長さ $ 2N+1 $ の $ 01 $ 文字列であって、$ S_1\ +\ S_1,\ S_2\ +\ S_2,\ S_3\ +\ S_3 $ のいずれの部分列でもあるものを $ 1 $ つ求めてください（$ s+t $ は文字列 $ s,\ t $ をこの順に連結したものを表します）。この問題の制約の下では、そのような文字列が常に存在することが保証されます。

ここで、文字列 $ B $ が文字列 $ A $ の部分列であるとは、$ A $ から $ 0 $ 文字以上を取り除き、残りの文字を順番を変えずに連結することで $ B $ を得ることができることを意味します。

テストケースは $ T $ 個与えられるので、それぞれを解いてください。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 10^5 $
- $ 1\le\ N\ \le\ 10^5 $
- $ S_i $ は `0` と `1` を $ N $ 個ずつ含む $ 01 $ 文字列である。
- 全テストケースにおける $ N $ の総和は $ 10^5 $ 以下である。

### Sample Explanation 1

$ 1 $ 個目のケースでは、`010` は `0101`, `0101`, `1010` の部分列です。 $ 2 $ 個目のケースでは、`11011` は `01010101`, `00110011`, `11001100` の部分列です。

## 样例 #1

### 输入

```
2
1
01
01
10
2
0101
0011
1100```

### 输出

```
010
11011```

# 题解

## 作者：Xssion37_XY (赞：4)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/AT_agc052_a)

[更好的阅读体验](https://www.luogu.com.cn/blog/778802/solution-at-agc052-a)

### 题目大意

公共子序列。

有三个长度为 $2N$ 的字符串，分别记作 $S_1+S_1,S_2+S_2,S_3+S_3$，每一个字符串都是由 $N$ 个 $0$ 或 $1$ 组成的，现在请你找到一个长度为 $2N+1$ 的字符串，使得这个字符串成为 $S_1+S_1,S_2+S_2,S_3+S_3$ 的**公共子序列**。

### 实际分析

你可以这么构造：$N$ 个 $0+N$ 个 $1+0$。

为什么可以这么构造捏？

我们设 $lca_1,lca_2,...lca_N$ 为字符串 $S$ 中 $0$ 的位置。

那么将字符串拼起来后 $0$ 的位置为        $lca_1,lca_2,...lca_N,lca_1+2N,lca_2+2N,...lca_N+2N$。

即这时候 $N$ 个 $0$ 与 $2N$ 个 $0$ 中间就会有 $N$ 个 $1$。

符合题意。

### 代码部分

~~代码是简单的（雾~~

```
#include <iostream>
using namespace std;
int n, T;
string a[3];
int main() {
	cin >> T;
	while (T--) {
		cin >> n;
		for (int i = 0; i < 3; i++) {
			cin >> a[i];
		}
		for (int i = 0; i <= n - 1; i++) {
			cout << 0;
		}
		for (int i = 0; i <= n - 1; i++) {
			cout << 1;
		}
		cout << 0 << endl;
	}
	return 0;
}
```
完结撒花！

[AC记录](https://www.luogu.com.cn/record/133790341)

---

## 作者：xiaoshumiao (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/AT_agc052_a)

一道构造题。

先说结论：先来 $n$ 个 $0$，再来 $n$ 个 $1$，最后来一个 $0$。

为什么这样是对的呢？

设原字符串中 $0$ 的位置为 $a_1,a_2,\dots,a_n$，则拼接后位置为 $a_1,a_2,\dots,a_n,a_1+2n,a_2+2n,\dots ,a_n+2n$。

且第 $n$ 个 $0$ 与第 $2n$ 个 $0$ 之间一定有 $n$ 个 $1$，所以是对的。

代码如下：
```cpp
#include<cstdio>
using namespace std;
const int N=1000010;
char s[N];
int main() {
  int t;
  scanf("%d",&t);
  while(t--) {
    int n;
    scanf("%d %s %s %s",&n,s,s,s);
    for(int i=1;i<=n;i++)
      printf("0");
    for(int i=1;i<=n;i++)
      printf("1");
    printf("0\n");
  }
  return 0;
}
```

---

## 作者：nkrqzjc_zzz (赞：2)

### [题目链接](https://www.luogu.com.cn/problem/AT_agc052_a)

------------

### 思路

这种构造题无非就是找规律嘛，看到题解区千篇一律的答案我真的很失望，这道题算下来有 $4$ 种构造方法，可是大部分的人都写的一种，很怀疑题解的真实性！

在这里我就举一种情况的例子，剩下三种基本一致。

首先我先讲如何构造，通过这个结论去反推原因。

主要分析的构造方法为：

$0+n$ 个 $1+n$ 个 $0$

其他三种方法为：

$1+n$ 个 $0+n$ 个 $1$

$n$ 个 $0+n$ 个 $1+0$

$n$ 个 $1+n$ 个 $0+1$

现在请大家看图

![](https://cdn.luogu.com.cn/upload/image_hosting/nlts7r2h.png)

标黄的格子是各个合并 $01$ 串中第一个出现的 $0$，标蓝的格子是各个合并 $01$ 串中第 $n+1$ 个出现的 $0$ 的前面一位，标橙的格子则是黄格子到蓝格子之间所有位置的下标。

通过简单的观察与推理你就可以发现，按照我们这样的选择方法，黄格子到蓝格子之间一定会出现 $n$ 个 $0$ 和 $n$ 个 $1$，因为这个区间内涵盖了一个未合并串的所有下标。而蓝格子后面的所有数字中就一定会出现 $n$ 个 $0$，因为这个区间涵盖了一个未合并串中所有 $0$ 的下标。

那么神奇的就来了，我们知道了无论是什么样的串，它的黄格子一定是 $0$，而它的橙色区间里一定有 $n$ 个 $1$，橙色区间后面就一定有 $n$ 个 $0$。

那么，答案就出来了！也就是一开始的那个公式：

$0+n$ 个 $1+n$ 个 $0$

------------

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		string a;
		cin>>a>>a>>a;
		printf("0");
		for(int i=1;i<=n;i++)printf("1");
		for(int i=1;i<=n;i++)printf("0");
		puts("");
	}
}
```

那，就结束了吗？**不可能**！

难道我们就放任这些简单的题不管了吗？**不可能**！

接下来就是一点点本人自己的想法，大家当个乐子听。

这道题其实可以变得更难，毕竟这种难度的代码和推理顶多橙。那么如果要输出**字典序最小**的呢，这道题好像就不能用这种简单的找规律方法来完成了，本人也在努力思考中，看到此问题的大佬们也请帮忙想一想，怎么做！

---

## 作者：YangXiaopei (赞：1)

## Solution:

简单构造题。

结论：输出 $N$ 个 $0$，$N$ 个 $1$，$1$ 个 $0$。

***

来，步入正题，证明。

设一个字符串 $0$ 分别在 $a_1, a_2 ... a_n$。

拿自己复制一次的字符串 $0$ 分别在 $a_1 + 2N, a_2 + 2N ... a_n + 2N$。

而 $[a_1, a_n + 2N]$ 中至少包含 $3N$ 个字符。

这也很好证明，$[a_1, a_n]$ 中至少 $N$ 个字符，在加 $2N$ 个，就至少 $2N$ 个字符。

而整个字符串只有 $2N$ 个 $0$，那剩下的就肯定是 $1$ 了。

所以答案即为 $N$ 个 $0$，$N$ 个 $1$，$1$ 个 $0$。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n;
string s;
int main(){
	cin >> t;
	while(t--){
		cin >> n >> s >> s >> s;
		for(int i = 0; i <= 1; i++){
			for(int j = 1; j <= n; j++){
				cout << i;
			}
		}
		cout << 0 << "\n";
	}
	return 0;
}
```

---

## 作者：Magus (赞：1)

远古 AGC 题，来写一篇题解。

我的构造方法：

$N$ 个 $0$ $+\ N$ 个 $1$ $+\ 1$ 个 $0$。

如何证明？

设 $arr_1,\dots,arr_N$ 是字符串 $S$ 中 $0$ 的位置。

则字符串 $S+S$ 中 $0$ 的位置是 $arr_1,\dots ,arr_N,arr_1+2N,\dots,arr_N+2N$。

得证 $N$ 个 $0$ 与 $2N$ 个 $0$ 的中间有 $N$ 个 $1$。

主要代码:

```cpp
for(int i=0;i<3;i++)
{
	cin>>s[i];
}
for(int j=0;j<n;j++)
{
	cout<<0;
}
for(int k=0;k<n;k++)
{
	cout<<1;
}
cout<<0<<"\n";
```

完结撒花。

---

## 作者：FFTotoro (赞：1)

设本题构造出的字符串为 $T$，那么

- $T=\begin{matrix}\underbrace{00\cdots0}\\N\cdot0\end{matrix}+\begin{matrix}\underbrace{11\cdots1}\\N\cdot1\end{matrix}+0$

这里的 $+$ 表示将两个字符串头尾相连接。

证明构造的字符串是合法的：

令 $a_1,a_2,\ldots,a_N$ 表示字符串 $S$ 中 $0$ 的位置，那么 $S+S$ 中 $0$ 的位置就是 $a_1,a_2,\ldots,a_N,a_1+2N,a_2+2N,\ldots,a_N+2N$。

可以得出，$S+S$ 中第 $N$ 个 $0$ 与第 $2N$ 个 $0$ 的距离为 $2N$，即它们中间有 $N$ 个 $1$，故我们的方法是正确的。

放代码：

```cpp
#include<iostream>
using namespace std;
int main(){
  ios::sync_with_stdio(false);
  int t; cin>>t;
  while(t--){
    int n; cin>>n; string s[3];
    for(int i=0;i<3;i++)cin>>s[i];
    for(int i=1;i<=n;i++)cout<<0;
    for(int i=1;i<=n;i++)cout<<1;
    cout<<0<<endl;
  }
  return 0;
}
```

---

## 作者：PDAST (赞：0)

## 思路
思路其实不难想，要认真读题。

有这么三个长度为 $2 \times N$ 的字符串，将他们两两拼起来，就得到了三个长度为 $4 \times N$ 的字符串，我们要构建一个长度为 $2 \times N + 1$ 的字符串，使他是前面拼出的三个字符串的公共子序列。

作者做这道题时想了很久都没有想出来，重新审了一遍题后发现，是子序列不是子串！！！那这道题就很简单了，就输出 $N$ 个 $0$ 和 $N$ 个 $1$，再输个 $0$ 即可，~~真是入口即化呢~~。

## 上代码

[AC 记录](https://www.luogu.com.cn/record/150398079)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,t;
string st[4];
int main() {
	cin>>t;
	while (t--) {
		cin>>n;
		for(int i=1;i<=3;i++) {
			cin>>st[i];
		}
		for (int i=1;i<=n;i++) {
			cout<<0;
		}
		for (int i=1;i<=n;i++) {
			cout<<1;
		}
		cout<<0<<endl;
	}
	return 0;
}
```

---

## 作者：skyskyCCC (赞：0)

## 前言。
贡献一波题意，题意如下：
#### 问题陈述
有 $T$ 数据，每组数据包含 $3$ 个二进制字符串 $S_1, S_2, S_3$ 其中每个字符串恰好包含 $N$ 个 $0$ 和 $N$ 个 $1$。

请找出长度为 $2N+1$ 的二进制字符串，它是所有字符串 $S_1 + S_1, S_2 + S_2, S_3 + S_3$ 的子序列。其中 $s+t$ 表示字符串 $s$ 和 $t$ 依次连接。保证有解。

同时我们认为，如果从字符串 $A$ 中删除字符，并在不改变顺序的情况下连接剩余的字符，则字符串 $B$ 是字符串 $A$ 的子串。
## 分析。
由题意，需要通过给出的三个字符串构造一个字符串。

如何构造？考虑每个字符串中 $1$ 和 $0$ 的取值情况。我们设 $a_1,a_2,a_3,\ldots,a_N$ 为字符串 $S$ 中的 $0$ 的位置。那么首尾相连即 $S+S$ 后 $0$ 的位置就变成了 $a_1,a_2,a_3,\ldots,a_N,a_1+2N,a_2+2N,\ldots,a_N+2N$ 的情况。原因如下：因为字符串中 $0$ 和 $1$ 的个数相同为 $N$ 故字符串 $S$ 的长度为 $2\times N$ 所以首尾相接后，在后边的字符串与前面的完全相同，但前面的字符串长度为 $2N$ 则需要加上。

由此可得，字符串 $S+S$ 中的第 $N$ 个 $0$ 和第 $2N$ 个 $0$ 的距离相等。就是它们之间有 $N$ 个 $1$ 所以可以构造一个符合要求的序列。这个序列的形态为 $N$ 个 $0$ 后有 $N$ 个 $1$ 最后一个 $0$ 的样子。

如果没有办法理解可以随便选取三个字符串，然后构造答案，看看是否均为子串。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
using namespace std;
int t,n;
string s1,s2,s3;
int main(){
    //long long ans=0;
	cin>>t;
	while(t--){
		cin>>n;
		cin>>s1>>s2>>s3;
		for (int i=1;i<=2;i++){
			for (int j=1;j<=n;j++){
				if(i==1) cout<<"0";
				if(i==2) cout<<"1";
			}
		}
		cout<<"0\n";//构造0000(N)1111(N)0的答案。
	}
	return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：MurataHimeko (赞：0)

第一感觉就是会选出至少 $n$ 个 $1$ 和 $0$。然后尝试再添加一个 $0$ 或 $1$。考虑到原序列的第 $i$ 个 $0$，将序列复制一遍后，两个第 $i$ 个 $0$ 之间会有 $n$ 个 $1$。那么可以从这里入手。


下面给出一种构造方法：$0+n\times 1+ 0 + (n-1) \times 0$。

$0+n\times 1+ 0$ 是前半段和后半段第一次出现的 $0$ 之间一定包含了 $n$ 个 $1$。此时后半段还剩 $n-1$ 个 $0$，全部选上即可。

代码是简单的。

---


# [AGC055A] ABC Identity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc055/tasks/agc055_a

長さ $ 3N $ の文字列 $ S $ が与えられます。$ S $ は `A`, `B`, `C` をそれぞれちょうど $ N $ 個ずつ含みます。

文字 `A`, `B`, `C` からなる文字列 $ T $ が次の条件を満たすとき、$ T $ を **良い** 文字列であると呼びます。

- $ T $ の長さは $ 3 $ で割り切れる。この長さを $ 3K $ とする。
- $ T_1\ =\ T_2\ =\ \ldots\ =\ T_K $
- $ T_{K+1}\ =\ T_{K+2}\ =\ \ldots\ =\ T_{2K} $
- $ T_{2K+1}\ =\ T_{2K+2}\ =\ \ldots\ =\ T_{3K} $
- 文字 $ T_1,\ T_{K+1},\ T_{2K+1} $ は互いに異なる。

良い文字列の例を挙げると、`ABC`, `BBAACC`, `AAACCCBBB` です。

$ S $ を **$ 6 $ 個以下**の（連続とは限らない）部分列に分解する方法であって、各部分列が良い文字列であるような方法を一つ見つけてください。

これは、この問題の制約下で必ず可能であることが証明できます。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\cdot\ 10^5 $
- 文字列 $ S $ は、文字 `A`, `B`, `C` を $ N $ 個ずつ含む。

### Sample Explanation 1

$ S $ が部分列 `ABC`, `CBA` に分割されており、これらはそれぞれ良い文字列です。

### Sample Explanation 2

$ 1 $ の位置に対応する部分列は `AABBCC`、$ 2 $ の位置に対応する部分列は `CAB`、$ 4 $ の位置に対応する部分列は `ACB` であり、これらは全て良い文字列です。

## 样例 #1

### 输入

```
2
ABCCBA```

### 输出

```
111222```

## 样例 #2

### 输入

```
4
AABCBCAACBCB```

### 输出

```
111211241244```

# 题解

## 作者：Autumn_Rain (赞：0)

学校月赛样例 $1$ 输出 $121212$ 给我判成错的了，火大。

枚举 $ABC$ 的 $6$ 种排列，三段里面分别一段一个字母。比如 $ABC$，假设第一段有 $a$ 个 $A$，第二段 $b$ 个 $B$，第三段 $c$ 个 $C$，那么我们只能取到 $\min(a,b,c)$ 这么多来保证数量相等。给它们全部标上标记，下次不能再选了。

因为排序总可以归纳成这 $6$ 种，所以肯定可以分成 $6$ 个序列的。

翻译不是很全，合法序列在原序列中不要求连续，你应该输出一个数字序列，不同的数字象征着所分成的不同合法序列。

~~感觉黄？~~

---

## 作者：MurataHimeko (赞：0)

"最多划分为 $6$ 个子序列。"

我们注意到 $6=3!$。

那么思路就是枚举 $ABC$ 三个字母的所有顺序，然后做。

更进一步的，我们将序列划分为 $[1,n], [n+1, 2n], [2n+1, 3n]$。

然后去枚举 $6$ 种排列，分别在三段里取字母。能取的个数是各个字母在各自段里出现次数的最小值。

最后一定可以不重不漏划分完。

代码：

```cpp
const int N = 2e5 + 5;
int a[N*3], ans[N*3];
char s[N*3];
int n, lc;
int num[3][3];
int b[7][3];

void upd (int id, int lim) {
    ++lc;
    rep(k, 0, 2) {
        int now = lim;
        rep(i, k*n+1, (k+1)*n) {
            if(!now) break;
            if(!ans[i] && a[i] == b[id][k]) {
                ans[i] = lc;
                --now;
            }
        }
    }
}

int main () {
    scanf("%d %s", &n, s + 1);
    re(i, n*3) a[i] = s[i] - 'A';
    rep(k, 0, 2) {
        rep(i, k*n+1, (k+1)*n) {
            ++num[k][a[i]];
        }
    } 
    b[1][0] = 0, b[1][1] = 1, b[1][2] = 2;
    b[2][0] = 0, b[2][1] = 2, b[2][2] = 1;
    b[3][0] = 1, b[3][1] = 0, b[3][2] = 2;
    b[4][0] = 1, b[4][1] = 2, b[4][2] = 0;
    b[5][0] = 2, b[5][1] = 1, b[5][2] = 0;
    b[6][0] = 2, b[6][1] = 0, b[6][2] = 1;
    re(i, 6) {
        int res = min({num[0][b[i][0]], num[1][b[i][1]], num[2][b[i][2]]});
        if(res) upd(i, res);
        num[0][b[i][0]] -= res;
        num[1][b[i][1]] -= res;
        num[2][b[i][2]] -= res;
    }
    re(i, n*3) io << ans[i];
}
```


---

## 作者：hfjh (赞：0)

# [AGC055A] ABC Identity 题解

## 题目描述

给定长度为 $3n (1 \le n \le 2 \times 10^5)$ 的序列，其中字母 A,B,C 各有 $n$ 个。

一个合法序列 $T$ 满足以下条件：

- 其长度为 $3k (1 \le k \le n)$。

- $T_1 = T_2 = \cdots = T_k$
- $T_{k + 1} = T_{k + 2} = \cdots = T_{2k}$
- $T_{2k + 1} = T_{2k + 2} = \cdots = T_{3k}$
- $T_1, T_{k + 1}, T_{2k + 1}$ 互不相同。
  
  求一个把这个序列分成**不多于** $6$ 个合法的序列的方案。
  
  可以证明，一定存在一种**合法**的划分。

## 解析

将序列分成**等长**的 3 段，分别为：
$[1,n],[n +1,2n],[2n+1,3n]$。

用桶来记录每一段 A,B,C 个数，那么一共就有 9 个桶，分别记作：`A_1,B_1,C_1,A_2,B_2,C_2,A_3,B_3,C_3`

枚举 6 种排列 $\texttt{ABC,ACB,BAC,BCA,CAB,CBA}$。

等长的 3 段中，第 $i$ 段取当前排列的第 $i$ 个字母。

具体的，假如当然枚举到 ABC，我们在 $[1,n]$ 中取 A，在 $[n + 1,2n]$ 中取 B，在 $[2n + 1,3n]$ 中取 C。

贪心得取，取尽量多，也就是三个桶取最小值记作  `mi`。

然后在 $[1,n]$ 中选 `mi` 个 A 标记成 1，在 $[n + 1,2n]$ 中选 `mi` 个 B 标记成 1，然后在 $[2n + 1,3n]$ 中选 `mi` 个 C 标记成 1。

>标记成 1 是因为当前枚举的排列是第 1 种。

因为只有 6 种排列，显然枚举完以后序列所有字母会被选完。


## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 6e5 + 9;
int n,l,r,mid,ans[N];
char a[N],ck[7][4]={{'0','0','0'},
{'A','B','C'},{'A','C','B'},
{'B','A','C'},{'B','C','A'},
{'C','A','B'},{'C','B','A'}};
int t[4][4];
void input(){
	cin>>n>>a + 1;
	for(int i = 0; i <= 2; ++i){
		for(int j = i * n + 1; j <= (i + 1) * n; ++j){
			++t[i][a[j] - 'A']; 
		}
	}
}
void cg(int num, int cd){
	for(int i = 0; i <= 2; ++i){
		int now = num;
		for(int j = i * n + 1; j <= (i + 1) * n && now; ++j){
			if(ck[cd][i] == a[j] && (!ans[j]))
				ans[j] = cd, --now;
		}
	}
}
void op(){
	for(int i = 1; i <= 6; ++i){
		int num = min(t[0][ck[i][0] - 'A'], min(t[1][ck[i][1] - 'A'], t[2][ck[i][2] - 'A']));
		cg(num, i);
		t[0][ck[i][0] - 'A'] -= num;
		t[1][ck[i][1] - 'A'] -= num;
		t[2][ck[i][2] - 'A'] -= num;
	}
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	input();
	op();
	for(int i = 1; i <= 3 * n; ++i)
		cout<<ans[i];
}
```

---


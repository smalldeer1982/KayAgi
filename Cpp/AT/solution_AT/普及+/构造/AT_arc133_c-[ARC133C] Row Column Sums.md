# [ARC133C] Row Column Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc133/tasks/arc133_c

$ H $ 行 $ W $ 列からなるマス目があります．

すぬけくんは，各マスに $ 0 $ 以上 $ K-1 $ 以下の整数を書き込もうとしています． ここで，以下の条件を満たす必要があります．

- 各 $ 1\ \leq\ i\ \leq\ H $ について，$ i $ 行目にあるマスに書かれた整数の総和を $ K $ で割った余りは $ A_i $ である．
- 各 $ 1\ \leq\ i\ \leq\ W $ について，$ i $ 列目にあるマスに書かれた整数の総和を $ K $ で割った余りは $ B_i $ である．

条件を満たすようにマスに整数を書き込むことができるかどうか判定し，また可能な場合は，書き込む整数の総和としてありうる最大値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 200000 $
- $ 2\ \leq\ K\ \leq\ 200000 $
- $ 0\ \leq\ A_i\ \leq\ K-1 $
- $ 0\ \leq\ B_i\ \leq\ K-1 $
- 入力される値はすべて整数である

### Sample Explanation 1

以下のように書き込めば良いです． ``` ----------------- | 2 | 0 | 2 | 2 | ----------------- | 2 | 2 | 0 | 1 | ----------------- ``` この書き方は条件を満たしています． 例えば $ 1 $ 行目に書かれた整数の総和は $ 6 $ であり，これを $ K(=3) $ で割ったあまりは $ A_1(=0) $ になっています． この書き方では整数の総和は $ 11 $ になっており，これはありうる最大値です．

## 样例 #1

### 输入

```
2 4 3
0 2
1 2 2 0```

### 输出

```
11```

## 样例 #2

### 输入

```
3 3 4
0 1 2
1 2 3```

### 输出

```
-1```

# 题解

## 作者：mountain_climber (赞：3)

好像没有题解欸，来水一发。

拿到题容易发现，如果要求的每行之和的和和每列之和的和在对 $k$ 取模的意义下不同余，那么一定无解，原因非常简单：方格内数的总和是一定的。

之后我们发现思路好像断了，开始寻找可能的突破口，考虑到题目要求求最大值，所以我们不妨先将所有的方格内都填入 $k-1$ 然后再对一些方格做减法从而达成要求。

考虑分别对行和列考虑，这里拿行来说，就是处理出对于第 $i$ 行来说，这一行需要至少减去多少，才能满足这一行的和对 $k$ 取模为 $a_i$，发现求法是朴素的：

若这一行的和（在都填入 $(k-1)$ 的情况下）对 $k$ 取模已经小于 $a_i$ 了，说明需要多删掉一个 $k$ 才能满足，否则直接将对 $k$ 取模的值减去 $a_i$，就完成了（具体见代码，一看就懂）。

下面我们约定对于行来说，每行所需要减去的最小数被数组 $c_i$ 记录，列则被数组 $d_i$ 记录。

现在知道了单独考虑行、列的情况，难点在于如何将其合并在一起。

如果有解，意味着行之和与列之和同余，不难发现，因为行之和和列之和都是总和减掉 $\sum c$ 或 $\sum d$ 得到的（在对 $k$ 取模的意义下），所以 $\sum c$ 和 $\sum d$ 也是同余的！

我们现在大胆猜想，最终的答案就是总和减去 $\max(\sum c, \sum d)$！但是如何证明这一点呢，我们可以钦定 $\sum c > \sum d$（不同情况可以认为是矩阵交换长宽），因为是在对 $k$ 取模的意义下，所以我们可以考虑先将 $\sum c$ 中 $\sum d$ 的部分分出去，这样就满足了 $\sum d$ 的条件，而 $\sum c$ 剩下的部分，一定是 $k$ 的倍数，全部堆在一个列中即可（不会影响这一列取模 $k$ 意义下的值，同时能够满足 $\sum c$ 的要求）。

至此，这道题就做完了，认为主要考查一个对取模性质的熟练运用，是好题。

[CODE](https://atcoder.jp/contests/arc133/submissions/56167244)

---

## 作者：anonymous_Y (赞：0)

题目大意还挺明白的我就不赘述了。

这种题目如果把所有的格子都枚举出来的话明显会超时，所以这也就提示我们要用一个整体的思想，换句话说就是不考虑具体的数字，而是对于行列这种整体的和进行加减。

很明显当每个格子都是 $k-1$ 的时候总和会最大，然后我们发现对于每一行的和相加和每一列的和相加实际上都是整个方格的所有数值之和，所以当且仅当 $\displaystyle \sum{a_i }$ 的值和 $\displaystyle \sum{b_i }$ 的值在对 $k$ 取模之下相同，才可能有解。

考虑对于一行 $i$ 都填 $k-1$ 的时候，这一行的总和对于 $k$ 取模之后离 $a_i$ 还有多少，我们就减去多少，如果不足的话就多补上一个 $k$ 对于列也是一样的策略。

考虑一下他的正确性，假定行上比列上减得更多，先满足列的要求，再把行上剩余部分堆在一列里面，因为剩余部分一定是 $k$ 的倍数，所以对答案不会有影响。


```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,k,aa,bb;
int main(){
	cin>>n>>m>>k;
	for(int i=0;i<n;i++){
		long long t;
		cin>>t;
		aa+=(m*(k-1)-t)%k;
	}
	for(int i=0;i<m;i++){
		long long t;
		cin>>t;
		bb+=(n*(k-1)-t)%k;
	}
	if(aa%k!=bb%k) cout<<-1<<endl; 
	else cout <<n*m*(k-1)-max(aa,bb)<<endl; 
	return 0;
}
```

---

## 作者：Nuclear_Fish_cyq (赞：0)

题目要求最大的情况，那我们就直接从全 $k-1$ 方阵上改。很明显全 $k-1$ 不一定能满足题目的行之和列之和模 $k$ 一定等于多少的条件，那我们可以算出我们每行每列要改掉多少。注意这个行要改掉的和还有列要改掉的和模 $k$ 一定相等，否则无解。

然后问题是答案是多少。先说结论吧：$nm(k-1)-\max(\sum x,\sum y)$。其实就是选行和列里面改掉最多的减。那为什么这一定有解呢？注意到行要改掉的和和列要改掉的和的差一定是 $k$ 的倍数，我们直接分配到多或者少的地方即可。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define ull unsigned long long
#define inf INT_MAX
#define linf LLONG_MAX
#define ninf INT_MIN
#define nlinf LLONG_MIN
#define mod 998244353
#define lwbd lower_bound
#define upbd upper_bound
//#define range
using namespace std;
void read(int &x){
	cin >> x;
	return;
}
void readll(ll &x){
	cin >> x;
	return;
}void readdb(db &x){
	cin >> x;
	return;
}
ll n, m, k, sa, sb;

//如果再忘记把题目给的1~n变为0~n-1自罚20仰卧起坐
int main(){
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> k;
	for(int i = 0; i < n; i++){
		ll t;
		cin >> t;
		sa += (m * (k - 1) - t) % k;
	}
	for(int i = 0; i < m; i++){
		ll t;
		cin >> t;
		sb += (n * (k - 1) - t) % k;
	}
	if(sa % k != sb % k){
		cout << -1 << endl;
	}
	else{
		cout << n * m * (k - 1) - max(sa, sb) << endl;
	}
	return 0;
}


```

---


# [ABC008C] コイン

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc008/tasks/abc008_3

高橋君は裏表が区別できる $ N $ 枚のコインを持っている。コインの大きさは異なり、それぞれのコインには $ 1 $ つずつ正の整数が書かれている。

これらのコインを無作為に ($ N! $ 通りの組み合わせがすべて同じ確率で出てくるように) 一列に並べる。その後、以下の手順を実行する。

1. すべてのコインを表向きにする。
2. 左端のコインから順に、現在見ているコインよりも右側 (それ自身を除く) にあるコインのうち、現在見ているコインに書かれている整数の倍数が書かれているコインすべての裏表をひっくり返す。

高橋君はこの操作を終了した後に表を向いているコインの枚数の期待値が知りたい。

あなたは高橋くんの代わりに、期待値を計算するプログラムを作成してほしい。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ N\ ≦\ 8 $ を満たすデータセット $ 1 $ に正解した場合は、$ 99 $ 点が与えられる。
- 追加制約のないデータセット $ 2 $ に正解した場合は、さらに $ 1 $ 点が与えられ、合計で $ 100 $ 点が得られる。

### Sample Explanation 1

コインには、サイズの小さい方から順にそれぞれ $ 2 $ , $ 4 $ , $ 8 $ という数が書かれています。例えば、$ 3! $ 通りの並べ方のうち、コインが大きさの昇順に並んでいる場合は、以下の手順が行われることになります。 1. 初期状態で、すべてのコインを表に向けるので、コインは左から順に、\\\[`表`, `表`, `表`\\\] となっています。 2. 次に、左から $ 2 $ 番目以降のコインの中で、$ 2 $ の倍数が書かれたコインを探します。左から $ 2 $ 番目のコインと左から $ 3 $ 番目のコインが該当するので、これらのコインを裏返します。その結果、コインは左から順に \\\[`表`, `裏`, `裏`\\\] となります。 3. 次に、左から $ 3 $ 番目以降のコインの中で、$ 4 $ の倍数が書かれたコインを探します。左から $ 3 $ 番目のコインのみが該当するので、このコインを裏返します。その結果、コインは左から順に \\\[`表`, `裏`, `表`\\\] となります。 コインの裏表は下図のように変化します。この図において、白いコインは表向きのコイン、黒いコインは裏向きのコインで表してあります。 !\[\](http://abc008.contest.atcoder.jp/img/abc/008/3-1.png)このように、$ 3!\ =\ 6 $ 通りの並べ方について、それぞれの並べ方での最終状態は下図のようになります。 !\[\](http://abc008.contest.atcoder.jp/img/abc/008/3-2.png)以上より期待値は $ 13/6\ =\ 2.16666666666... $ となります。

### Sample Explanation 2

どのような順番で並べても、左から順に、\\\[`表`, `裏`, `表`, `裏`\\\] となります。

## 样例 #1

### 输入

```
3
2
4
8```

### 输出

```
2.166666666667```

## 样例 #2

### 输入

```
4
5
5
5
5```

### 输出

```
2.000000000000```

## 样例 #3

### 输入

```
5
2
3
2
6
12```

### 输出

```
3.100000000000```

# 题解

## 作者：qwerty12346 (赞：8)

# [题目传送门](https://www.luogu.com.cn/problem/AT_abc008_3)

## 题意

这题就是求最后所朝上硬币的数量的期望值是多少，并保留 $12$ 位小数。

## 思路

先求概率公式，得出其为 $(sum÷2+1)÷(sum+1)$ 注意要强制转换为 double 类型。在用循环求 $a_{i}$ 的因子个数就可以了。就是循环找到一个 $a_{i}$ 的因子就加一，找完在用一个刚刚求出的概率公式，最后在输出记录期望值的变量就行了（记得要保留 $12$ 位小数）。

### 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,a[10005];
double ret;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)//求因子个数
    {
        int sum=0;
        for(int j=1;j<=n;j++)if(i!=j&&!(a[i]%a[j]))sum++;
        ret+=(double)(sum/2+1)/(sum+1);//概率公式
    }
    printf("%.12lf\n",ret);
    return 0;
}
```


---

## 作者：Hiiragi_Utena (赞：6)

依次遍历每枚硬币。对于一枚硬币，找出它的所有约数的硬币（但是不包括它本身）。可以用以下代码来实现找约数：
```cpp
for(int i=1;i<=n;++i){
	int v=0;//v为约数个数
	for(int j=1;j<=n;++j)if(j!=i&&p[i]%p[j]==0)++v;
}
```
这枚硬币最终能正面朝上的概率是恰好这 $v$ 枚硬币有偶数枚在它左边。可以理解为这 $v+1$ 枚硬币随机排序，此枚硬币恰好排在奇数位置上的概率，为：$(\left\lfloor\dfrac{v}{2}\right\rfloor+1)/(v+1)$

只要将答案加上这个数。遍历完后的答案就是题目所求
```cpp
ans+=(double)(int)(v/2+1)/(v+1);
```

---

## 作者：scp020 (赞：5)

# [ABC008C] コイン

一道有趣的期望题。

## 解法

题中给出 $n$ 枚硬币，每枚硬币上都有一个正整数，记作 $a_i$。下面为了方便叙述，我们将 $n$ 个硬币进行标号，依次为 $1$ 到 $n$。

现在要将这 $n$ 枚硬币进行全排列，共有 $n!$ 种排列方法，求出全部翻转后最终正面朝上（初始状态是全部正面朝上）的硬币数量的期望值（输出浮点数）。翻转规则如下：

- 从最左端开始向右逐个扫过。

- 当扫到第 $i$ 个硬币时，我们将第 $i$ 个硬币右侧且硬币上的数字是 $a_i$ 倍数的硬币进行一次翻转。

注意：本题要注意整数和浮点数间的转换。

### 部分分解法

对于 $1 \le n \le 8$ 的情况，我们可以全排列出所有情况，对于每一种情况暴力翻转，求出每种情况硬币正面朝上的数量，从而算出所有情况硬币正面朝上的数量的总和，除以 $n!$ 浮点数输出期望即可。

### 满分解法

考虑到有一个点的数据范围是 $1 \le n \le 100$，这种暴力的做法是不能得到满分的。考虑到我们正在对每种排列情况进行计数，我们可以换一个计数方式，即考虑每个硬币在所有情况中正面朝上的概率的总和。

观察样例我们可以得到：对于编号为 $i$ 的硬币，能使之翻转的硬币只能是 $a_i$ 的约数所在的硬币。所以如果对于 $a_j \nmid a_i$，在任意排列中无论编号为 $j$ 的硬币在编号为 $i$ 的硬币的任何方向，都不会影响编号为 $i$ 的硬币的翻转情况。所以我们在计数编号为 $i$ 的硬币时可以忽略这些不是该硬币约数的硬币。现在即求对于编号为 $i$ 的硬币和它的 $x_i$ 个约数，在这 $x_i +1$ 个数的全排列中有多少种情况编号为 $i$ 的硬币在这列数中排在第奇数位（即该数前面有偶数个约数）的概率。对于编号为 $i$ 的硬币，计算公式为：$\dfrac{ x_i! \times \lfloor x_i / 2 + 1 \rfloor }{ (x_i + 1)! } = \dfrac{ \lfloor x_i / 2 + 1 \rfloor }{ x_i + 1 } $，解释如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wrmgooug.png)

###   代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110];
double ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1,cnt=0;i<=n;i++,cnt=0)
	{
		for(int j=1;j<=n;j++) if(a[i]%a[j]==0) cnt++;
		cnt--;//把自己排除
		ans+=(cnt/2+1)*1.0/(cnt+1);
	}
	cout<<fixed<<setprecision(6)<<ans<<endl;//注意，因为这道题是早期 AT 的题，最后一定要多输出一个空格
	return 0;
}
```



---

## 作者：__lfxxx_ (赞：5)

这题明显是求概率的。

爆搜固然可以过样例（~~也许只能过样例~~）。因为它求整体概率，所以这题可以求出每个数字朝上的概率，最后再加起来。

对于每个数可以字先找出能翻转它的数（就是它的因数）的个数，设个数有 $add$ 个，这个数最终能朝上的概率就是有偶数个在左边，我们先只看这 $add$ 个数（因为这个数的概率只与这 add 个数有关）。总个数是 $add+1$ 个，左边个数只有偶数或奇数个，所以正面朝上个数就有 $add/2+1$ 个，$+1$ 是它在最前面的可能，所以这个数朝上的概率就是（$\lfloor add/2 \rfloor+1$ ）$/(add+1)$。

### 答案一定要换行！！！

下面就是代码了。

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
int n,a[110];
double ans;
int main()
{
    cin>>n;
    for(rint i=1;i<=n;++i)
        cin>>a[i];
    for(rint i=1;i<=n;++i)
    {
        int add=0;
        for(rint q=1;q<=n;++q)
            if(q!=i && a[i]%a[q]==0)//找它的因数
                ++add;
        ans+=(double)(int)(add/2+1)/(add+1);//概率式子
    }
    printf("%.12lf\n",ans);
}
```


---

## 作者：Walter_Fang (赞：4)

## 大致题意

打乱 $n$ 枚硬币，从左到右，将每个硬币右边所有是它的倍数的硬币翻面，求出最终所有硬币全部朝上的期望值，保留 12 位小数。

## 解析

对于一枚硬币，先找出能翻转它的硬币**（即它的因数）**的个数，若个数有 $x$ 个，这枚硬币最终能朝上的概率就是有偶数个硬币在左边的概率。

我们看这 $x$ 个数。总个数是 $x+1$，正面朝上个数是 $x\div 2+1$，所以这枚硬币朝上的概率就是 $(x\div 2+1)\div(x+1)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,s,a[110];
double ans;
int main(){
    cin>>n;
    for(i=1;i<=n;i++)cin>>a[i];
    for(i=1;i<=n;i++){
        s=0;
        for(j=1;j<=n;j++)
            if(i!=j&&!(a[i]%a[j]))
                s++;
        ans+=(double)(s/2+1)/(s+1);
    }
    printf("%.12lf\n",ans);
}
```

---

## 作者：Walter_Fang (赞：3)

看到求期望值，想到求概率。

因为求总体的概率，所以求出每个数字朝上的概率相加是一种正解思路。

对于一个数 $x$ ，只有它的因数可以将其反转。那么它最后朝上的概率就是左边有偶数个数的情况。看这 $x$ 个数，总个数是 $x+1$ 个，左边个数只有偶数或奇数个，所以有 $x/2+1$ 个数正面朝上， $x+1$ 是它的第一个可能，所以它朝上的概率就是 ($\left \lfloor x/2 \right \rfloor +1) / (x+1) $ 。

因为精确到了小数点后 12 位，所以要使用 `double` 类型。

代码如下（AT题目输出后记得加换行）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,s,a[110];
double ans;
int main(){
    cin>>n;
    for(i=1;i<=n;i++)cin>>a[i];
    for(i=1;i<=n;i++){
        s=0;
        for(j=1;j<=n;j++)
            if(i!=j&&!(a[i]%a[j]))
                s++;
        ans+=(double)(s/2+1)/(s+1);
    }
    printf("%.12lf\n",ans);
}
```

---

## 作者：CrazyWisdom (赞：1)

#### 前言
一道很标准的期望题。

题目：[[ABC008C] コイン](https://www.luogu.com.cn/problem/AT_abc008_3)\
#### 思路
既然能够明显地看出是期望题，不妨先去复习一下期望公式：

- $X$ 离散随机变量，输出值为 $X_1,X_2,X_3……X_N$ 对应概率为  $p_1,p_2,p_3……p_N$,则期望值为：

$$E(X)=\sum_{i=1}^N {p_i \times X_i}$$

好的，我们已经成功一半了。

根据题目条件，$X_i$ 的值应均为 $1$，而 $p_i$ 的值应当为第 $i$ 枚硬币正面朝上的概率。问题是，这个概率应当怎么去求？

根据题目条件，一个硬币能对后面所有数值是当前硬币的倍数的硬币产生影响，也就是能够让所有这些硬币翻面。反过来，一个硬币只能被数字是其约数的硬币影响。那么，每个硬币朝上的概率是多少呢？

我们令所有数值是给定硬币 $c$ 的约数的硬币的名字为 $divisor$，那么一个硬币 $c$ 朝上，当且仅当其左边有偶数个 $divisor$。这很好理解，因为只有当前硬币 $c$ 翻了偶数次，这个硬币才能保持当前的状态。因而假若硬币 $c$ 有 $v$ 个 $divisor$，硬币 $c$ 朝上的概率就可以转换为：偶数个 $divisor$ 在 $c$ 左边的概率。如果此时仍不明确，还可以将其转化为：硬币 $c$ 位于所有 $divisor$ 构成的序列中的奇数位置的概率。那么此时就容易计算其概率为：

```cpp
(double)((divisor-1)/2+1)/(divisor);
```
这就是最为核心的代码。注意：以上的 $divisor$ 相当于 $v$，是约数的数量；以上的代码是用来计算期望的，但由于乘数 $X_i$ 均为 $1$ 所以忽略掉了，剩下的部分便也可以来代表概率；以上中的 $divisor$ 包括本身。

这就是处理一个硬币时候的思路，只要重复这个过程就可以了。

#### 代码实现

代码很短，因此建议先不看题解，自己按照思路实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int N, a[110];
signed main () {
	scanf("%lld", &N);
	double sum=0;
	for(int i=1;i<=N;i++)scanf("%lld", &a[i]);
	for(int i=1;i<=N;i++) {
		int divisor=0;
		for(int j=1;j<=N;j++) {
			if(a[i]%a[j]==0) {
				divisor++;
			}
		}
		sum+=(double)((divisor-1)/2+1)/(divisor);
	}
	printf("%.12lf\n", sum);
	return 0;
}
```

#### 最后
感谢大家的观看，有问题或建议欢迎指正！




---

## 作者：shaozhehan (赞：0)

[原题链接](https://www.luogu.org/problemnew/show/AT_abc008_3)

[Atcoder 链接](https://atcoder.jp/contests/abc008/tasks/abc008_3)

这个题目一看就是一个概率数学问题。

我们可以先统计出对于每一个数在整个序列中约数出现的个数，若这一个数是从左到右第 $i$ 个，则每一个数在整个序列中约数出现的个数令为 $a\pod i$。

然后将每个硬币右边的所有硬币翻面，就等价于若一个硬币是从左到右第 $b$ 个，每个硬币被翻 $a\pod b$ 次。如果要让这个硬币在最终状态下仍正面向上，它必须被翻偶数次，也就是 $a\pod b\equiv0\pmod2$。

若一枚硬币是从左到右第 $i$ 个，这一枚硬币在最终状态下仍证明朝上的概率为 $P$，即满足条件的排列个数可以先把自己排好，再排其他 $a\pod i$ 个数，可得到：

$P=\dfrac{(1+\lfloor\frac{a\pod i}{2}\rfloor)A_{a\pod i}^{a\pod i}}{A_{a\pod i+1}^{a\pod i+1}}=\dfrac{1+\lfloor\frac{a\pod i}{2}\rfloor}{a\pod i+1}$

至此，盛金公式推出来了，拿一个变量 $sum$ 把所有 $P$ 加起来就行了。

上代码：
```cpp
#include <iomanip>
#include <iostream>
using namespace std;

int a[101];

int main(){
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);//cin cout加速
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++){
        cin >> a[i];
    }
    double ans = 0;//注意：开双精度浮点类型的！
    for (int i = 1; i <= n; i++){
        int cnt = 0;
        for (int j = 1; j <= n; j++){
            if (i != j && a[i] % a[j] == 0){
                cnt++;
            }
        }
        ans += 1.0 * (int)(cnt / 2.0 + 1.0) / (cnt + 1.0);
    }
    cout << fixed << setprecision(12) << ans << "\n";
    return 0;
}
```

---


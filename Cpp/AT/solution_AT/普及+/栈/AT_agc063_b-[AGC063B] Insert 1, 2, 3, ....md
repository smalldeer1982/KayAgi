# [AGC063B] Insert 1, 2, 3, ...

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc063/tasks/agc063_b

正整数からなる数列 $ a\ =\ (a_1,\ \ldots,\ a_n) $ が**生成可能**であるとは，空列からはじめて次の操作の繰り返しで $ a $ が得られることをいいます．

- 操作：正整数 $ k $ を選び，列の好きな位置に $ (1,\ 2,\ \ldots,\ k-1,\ k) $ を挿入する．より形式的には，列 $ a\ =\ (a_1,\ \ldots,\ a_m) $ に対して $ 0\leq\ i\leq\ m $ となる整数 $ i $ および正整数 $ k $ を選び，$ a $ を $ (a_1,\ldots,a_{i},\ 1,\ 2,\ \ldots,\ k-1,\ k,\ a_{i+1},\ \ldots,\ a_m) $ に置き換える．
 
例えば $ a\ =\ (1,2,1,1,2,1,3,4,2,3) $ は生成可能です．次が生成手順の一例です：

$ ()\ \to\ (\boldsymbol{1,2})\ \to\ (1,2,\boldsymbol{1,2,3})\ \to\ (1,2,1,\boldsymbol{1,2,3,4},2,3)\ \to\ (1,2,1,1,2,\boldsymbol{1},3,4,2,3) $

- - - - - -

正整数からなる数列 $ A\ =\ (A_1,\ \ldots,\ A_N) $ が与えられます．次を満たす整数の組 $ (L,\ R) $ の個数を求めてください：

- $ 1\leq\ L\leq\ R\leq\ N $ であり，連続部分列 $ (A_L,\ \ldots,\ A_R) $ は生成可能である．

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 5\times\ 10^5 $
- $ 1\leq\ A_i\leq\ N $
 
### Sample Explanation 1

次の $ 11 $ 個です： - $ (1,1),\ (1,2),\ (1,3),\ (1,4),\ (1,5),\ (1,6),\ (3,3),\ (3,4),\ (3,5),\ (3,6),\ (5,5) $

### Sample Explanation 2

すべての連続部分列が生成可能です．

## 样例 #1

### 输入

```
6
1 2 1 2 1 3```

### 输出

```
11```

## 样例 #2

### 输入

```
5
1 1 1 1 1```

### 输出

```
15```

## 样例 #3

### 输入

```
7
1 2 1 2 1 3 4```

### 输出

```
13```

# 题解

## 作者：FFTotoro (赞：8)

先来考虑怎样的区间是合法的。合法的区间 $[L,R]$ 一定满足以下条件：

- $\forall x\in[L,R] \land A_x>1$，记 $c_{w,y}(L\le y\le R)$ 为 $w$ 在 $A[L\ldots y]$（即 $A$ 中以 $L$ 为左端点、$y$ 为右端点构成的一段区间）中出现的次数，$c_{A_x,x}\le c_{A_x-1,x}$。


把上面的第二点转化一下，你就会发现——如果可以给每个 $A_x>1$ 找一个再它左侧且离它最近的 $A_x-1$ 匹配（每个 $A_x-1$ 仅仅能匹配一次），那么这个区间就是合法的。也就是说，每个 $A_x$ 都必须找到一个值为 $A_x-1$ 的**前驱**——它的前驱与它之间的那一段区间就是后来插入的。

举个例子，序列 $\{1,2,\color{Red}{1,2,3,4}\color{Black},3\}$，假设已经考虑到最后一个 $3$，中间标红的部分已经完成匹配，$3$ 只能找到离它最近的且没有匹配的 $A_2=2$ 作为前驱——可以视为在一个序列 $\{1,2,3\}$ 中插入了一个 $\{1,2,3,4\}$。

这个过程十分类似栈维护括号匹配，可以借助栈来完成类似的操作。

考虑枚举右端点 $R$，借助一个栈来完成操作的维护，栈内的一个元素 $x$ 表示合成该序列的子序列的其中一个是 $\{1,2,\ldots,x\}$，栈的大小就是合法的左端点个数（为什么？根据栈内元素的意义可知，以 $R$ 为右端点的合法区间是由若干个形如 $\{1,2,\ldots,x\}$ 的子序列构成的，显然栈的大小就是子序列的个数，有几个子序列就有几个 $1$，而这里面每个 $1$ 都可以作为一个合法的左端点）。

如果 $A_R=1$ 那么直接把 $1$ 放入栈内（在一个合法序列的末尾加上一个 $1$ 它依然合法）；否则不断将栈顶弹出直到找出值为 $A_R-1$ 的前驱——假设此时栈顶为 $A_R-1$，那么将其设为 $A_R$，表示把以 $A_R-1$ 结尾的子序列长度增加 $1$；如果栈空了那么直接 `continue`（找不到前驱该元素不可能合法）。

每次答案加上栈的大小即可。时间复杂度 $O(N)$，足以通过。

放代码（代码精悍短小）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  ios::sync_with_stdio(false);
  int n; long long c=0; cin>>n;
  stack<int> s;
  for(int i=1;i<=n;i++){
    int a; cin>>a;
    if(a==1)s.emplace(1); // 如果是 1 就把它放进去
    else{
      while(!s.empty()&&s.top()+1!=a)s.pop();
      // 不断弹出栈顶找前驱的过程
      if(!s.empty())s.top()++; // 将栈顶改为 A[r]
    }
    c+=s.size(); // 答案加上合法左端点个数
  }
  cout<<c<<endl;
  return 0;
}
```

---

## 作者：Leasier (赞：3)

~~没有脑子，我该怎么办？没有脑子，我该怎么办？没有脑子，我该怎么办？没有脑子，我该怎么办？没有脑子，我该怎么办？~~

------------

考虑先来判断一下一个长为 $n$ 的 $a$ 是否是“可生成的”。

我们希望给每个 $x > 1$ 匹配一个 $x - 1$，则可以得到：

- $\forall 1 \leq i \leq n, j > 1$，$cnt_{i, j} \leq cnt_{i, j - 1}$。

接下来考虑计数。考虑每次尝试用当前的 $a_i$ 匹配 $a_i - 1$：

- 从左到右扫，用一个栈记录当前所有可以作为开头位置的 $a_i = 1$ 在当前匹配到的 $a_j$。
- 每新加入一个 $a_i$，若 $a_i = 1$ 则直接入栈，否则反复出栈直到找出一个 $a_i - 1$，如果能找到则将其删除并插入 $a_i$，表示我们必须找出一条以 $a_i$ 为结尾的匹配链，匹配链开头往前的项不变。
- 当前栈中元素个数即为以 $i$ 为右端点的“可生成的”子串个数。

时间复杂度为 $O(n)$。

代码：
```cpp
#include <iostream>
#include <stack>
#include <cstdio>

using namespace std;

typedef long long ll;

stack<int> s;

int main(){
	int n;
	ll ans = 0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int a;
		scanf("%d", &a);
		if (a == 1){
			s.push(a);
		} else {
			int ad = a - 1;
			while (!s.empty() && s.top() != ad) s.pop();
			if (!s.empty()) s.top()++;
		}
		ans += s.size();
	}
	cout << ans;
	return 0;
}
```

---

## 作者：mRXxy0o0 (赞：2)

# 题意

通过不断在某个位置添加 $(1,2,\dots ,k)$ 所形成的序列称为可生成的。求给定序列有多少区间是可生成的。

# 分析

我们把一个可生成的序列看成很多依次加一的区间 $(x,x+1,\dots,y)$ 构成的，很明显发现，对于每一个区间，总是满足前面有一段的结尾是 $x-1$ 或 $x=1$。

这样的限制条件只在乎前面的，而不用考虑后面的，所以可以得到结论：

>如果一个序列是可生成的，那么它的每一个前缀都是可生成的。

有了这个性质，可以考虑枚举左端点，然后找到最右边的点，使这个区间是可生成的。虽然看上去可以二分，但是很快发现，无法在 $O(1)$ 时间判断一个区间是不是可生成的。这个思路就无法再继续了。

继续观察序列，又发现一个性质：

>如果一个可生成的序列包含了另一个可生成的序列，那么被包含的序列一定是连续的。

举个例子，$(1,2,1,2,3,3,1,2,4)$ 就是这样的关系，里面的 $(1,2,3)$ 和 $(1,2)$ 是连续的。

看上去这个性质十分的废话，实际上，这等同于告诉我们：如果剔除了一个可生成的序列内部的其他可生成序列，最后会剩下以 $1$ 开始，依次加一的序列。

实现上，可以使用链表，倒序遍历，算出每个 $1$ 最远到达的地方。如果遍历到 $1$，就利用之前得出的答案往后枚举，并记录当前的答案，每个元素只会枚举两次，复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int N=5e5+10;
int n,a[N],l[N],r[N];
ll ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		r[i]=i+1,l[i]=i-1;
	}
	for(int i=n;i>=1;--i){
		if(a[i]==1){
			int ff=1;
			for(int j=i,k=1;j<=n;j=r[j],++k){
				if(a[j]!=k){
					r[i]=j;
					l[j]=i;
					ans+=j-i;
					ff=0;
					break;
				}
			}
			if(ff){
				ans+=n-i+1;
				r[i]=n+1;
				l[n+1]=i;
			}
			r[l[i]]=r[i];
			l[r[i]]=l[i];
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：yuheng_wang080904 (赞：1)

## 思路

首先容易得到合法区间开头为 $1$。

接下来思考如何判断一个区间是合法区间，那么我们可以考虑将区间一段一段取走。

考虑这个区间中最右侧的 $1$，以及其后的一串连续数字，如果我们将这一串数字删去后，新的区间合法，则原区间一定合法，这个应该容易理解。反之如果我们将这一串数字删去后，新的区间不合法，则原区间一定不合法。这个证明我们可以这样思考，如果不删原来那一整串数，那一定是删这串数的一个前缀，而剩下的数，只能由前面其他的 $1$ 来领。而那些 $1$ 如果能领，那一定是作为其后缀，也有可能前面的 $1$ 根本带不掉这些数。因此这个 $1$ 直接带掉整串数是最优的，如果这都不行，那原区间一定不合法。

综上所述，要判断一个区间是否合法，只需要每次找到最右侧的 $1$，将其领的一串连续数字全部删掉，如果最后删完了则合法，否则不合法。

再考虑另一个性质：如果区间 $[l,r]$ 合法，那么区间 $[l,r0](l\le r0\le r)$ 也一定合法。这是易证的，因为我们去掉的只是原区间里一些 $1$ 领的后缀。

最后我们来看答案如何求。我们只需要对于每个 $l$，求出最大的 $r$ 使得区间 $[l,r]$ 合法，则对答案的贡献为 $r-l+1$。根据判断是否合法的方法，我们可以把整个数字串倒过来做，用栈来维护数字，每次遇到 $1$ 就取出连续的串，由栈中剩下数字的个数即可得到 $r_{max}$，具体实现见代码。

## 代码

时间复杂度 $O(n)$。

```cpp
ll n,a[500005],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	vector<int>num;
	for(int i=n;i>=1;i--){
		num.push_back(i);
		ll now=1;
		while(!num.empty()&&a[num.back()]==now){
			num.pop_back();
			now++;
		}
		ll l=i,r=(num.empty()?n+1:num.back());
		ans+=r-l;
	}
	over(ans)
}
```


---

## 作者：tuxuanming2024 (赞：1)

一个基于 DP 的题解。

总结一些性质：

1. 一段合法区间的开头一定是 $1$。
2. 如果一个区间 $[l,r]$ 合法，那么 $[l,r-1]$ 也合法。
3. 若 $a_i + 1 = a_{i+1}$，则他们是在同一次操作被加入的。
4. 若区间 $[l,r]$ 中存在极大的区间 $[p,q]$ 合法，则判断 $[l,r]$ 合法等价于把 $[p,q]$ 删除后是否合法。

~~感觉证明都挺显然的就不写了~~

那么我们就有一个大致的思路：枚举 $1$ 的位置作为开头，然后计算后面最长的合法区间的长度。

记 $f_i$ 表示以 $i$ 开头的最长合法区间长度（无论 $a_i$ 是否等于 $1$），考虑倒序 DP。

分三种情况：

1. $a_i+1=a_{i+1}$： 根据性质 $3$，说明 $i$ 和 $i+1$ 一定是在同一次操作中加入的，则 $f_i = f_{i+1}+1$。

2. $a_i + 1 \neq a_{i+1}$ 且 $a_{i+1} = 1$：运用性质 $4$，考虑将 $[i+1,i+f_{i+1}]$ 删去之后的合法性。判断 $a_i +1 = a_{i+f_{i+1}+1}$ 是否成立，若成立，则 $f_i = f_{i+1} +  f_{i+f_{i+1}+1}+1$；否则可以看做将 $a_i$ 与 $[i+1,i+f_{i+1}]$ “拼”起来，$f_i = f_{i+1}+1$。

3. 不满足以上两个条件，则无法和后面的连接起来，$f_i = 1$。

然后遇到 $a_i =1$ 的时候直接加贡献即可。

代码：

```cpp
#include <bits/stdc++.h>
#ifdef LOCAL
#include "txm/debug.h"
#endif
using namespace std;
typedef long long ll;
const int N=500005;
int n,a[N],f[N];
ll ans;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=n;i>=1;i--)
	{
		if(a[i]+1==a[i+1]) f[i]=f[i+1]+1;
		else if(a[i+1]==1)
		{
			if(a[i+f[i+1]+1]==a[i]+1) f[i]=f[i+1]+f[i+f[i+1]+1]+1;
			else f[i]=f[i+1]+1;
		}
		else f[i]=1;
		if(a[i]==1) ans+=f[i];
	}
	cout<<ans;
	return 0;
}
```




---

## 作者：fede (赞：0)

# 正文

## 分析

题目中对数列是**可生成的**做出了详细的解释，通过举例、模拟、~~看题解~~等的方法，我们可以很快判断出**可生成的**数列的一些性质：
- 首先，**可生成的**数列的第一项一定是 $1$。
- 其次，任意两个**可生成的**数列一定不会交叠，只有包含和不包含的关系。
- 然后，如果一个数列是**可生成的**，那么它的每一个前缀数列都是**可生成的**。
- 最后，如果有两个**可生成的**数列是包含关系，假设**可生成的**数列 $A$ 包含**可生成的**数列 $B$，那么**可生成的**数列 $B$ 会影响**可生成的**数列 $A$ ，而**可生成的**数列 $A$ 不会影响**可生成的**数列 $B$（有~~少许~~的拗口）。

## 思路

题目要我们求有多少个非空子段是**可生成的**。

### 简化

先简化一下，如果所有**可生成的**的数列都不会有包含和不包含的关系。

设 $ans$ 为我们要求的答案，$cnt$ 为当前位置可以**连续**生成的单个**可生成的**的数列。那么我们就可以用线性遍历的方式考虑每个数：

如果这个数是 $1$，也就意味着这是一个新的**可生成的**的数列，$cnt$ 增加 $1$，$ans$ 增加 $cnt$；   
如果这个数等于前一个数加一，也就意味着这当前**可生成的**的数列长度加 $1$，$cnt$ 不变，$ans$ 增加 $cnt$；   
否则，连续**可生成的**的数列就此中断，$cnt$ 变为 $0$，$ans$ 不增加。

其中，$ans$ 增加的操作可以这么理解：   
从当前位置往前，因为要满足组成一个新的**可生成的**数列是由 $1$ 开头的，所以至少要加入一整个**可生成的**的数列，而总共可以这么操作 $cnt$ 次，所以增加的是 $cnt$。

### 正解

现在开始考虑所有**可生成的**的数列都会有包含和不包含的关系。

我们可以数形结合，假设**可生成的**数列 $A$ 包含**可生成的**数列 $B$，那我们就把**可生成的**数列 $B$ 画到**可生成的**数列 $A$上面。

用题目中的例子，序列 $a=(1,2,1,1,2,1,3,4,2,3)$，我们就可以画成这个样子：
![](https://cdn.luogu.com.cn/upload/image_hosting/m1ocugvr.png)

如果我们用简化过后的思想，在第一行的 $1$ 之后继续遍历，子序列 $(3,4,2,3)$ 就被独立出来了，那么有什么方法可以认为它们并不是独立的呢？

根据前面发现的**最后**一个性质，如果上层的数列是**可生成的**，并且上层的数列也已经遍历完成，那么我们为何不直接把上层的数列删掉呢？这样，我们就可以把问题重新变成简化过后的了。

模拟一下，当我们遍历到第一个 $3$ 时，前面的序列我们会认为它们都是同一层级的**可生成的**数列。而遇到这个 $3$ 时，它不能接到前一个数字的后面，考虑两种可能：
1. 这个数所在的层级包住了前一个数所在的层级；
2. 这个数不属于任何一个**可生成的**数列。

但不管哪种可能，前一个数所在的层级都是要被删掉的，所以我们可以先把前一个数所在的层级删掉，再对当前这个数进行判断是否可以接到这个时候的前一个数字，如果还不可以就再把这个层级删掉，如此循环往复，删完了就说明这个数不属于任何一个**可生成的**数列。

由于我们只需要知道一个层级的最后一个数，所以我们可以只存储最后一个数来表示整个层级。又由于我们先判断后面的，是典型的“后进先出”，所以可以使用栈维护。

## 代码

### 简化

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=1e6+10;
int n,cnt,ans;
int a[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		if(a[i]==1){
			cnt++; 
		}else if(a[i]==a[i-1]+1){
			
		}else{
			cnt=0;
		}
		ans+=cnt;
	}
	cout<<ans<<endl;
	return 0;
}
```

### 正解

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=1e6+10;
int n,ans;
int a[N];
stack<int> st;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		if(a[i]==1){
			st.push(a[i]);
		}else{
			while(!st.empty()&&st.top()!=a[i]-1){
				st.pop();
			}
			if(!st.empty()){
				st.pop();
				st.push(a[i]);
			}
		}
		ans+=st.size();
	}
	cout<<ans<<endl;
	return 0;
}
```
时间复杂度 $O(n)$，空间复杂度 $O(n)$，完美通过此题。

---


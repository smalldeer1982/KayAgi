# [ABC013C] 節制

## 题目描述

安全意识很高的高桥君买了最好的锁，然而他的钱包因此出现了一场金钱危机

高桥君领工资的时间不稳定，下一次领工资的时间是从现在开始N日后，于是高桥君在N天内开始尽量抑制伙食费，过起了节约的生活。

首先，高桥的饱食度是H，对于N天中的每一天高桥君可以选择下列三种饮食中的一种：

· 普通的饮食：支付A日元的费用，增加B点饱食度

· 朴素的饮食：支出C日元，增加D饱食度

· 不吃饭：不支出费用，但是高桥君的肚子饿极了，会降低E点饱食度

对于以上饮食方案，C<A，D<B

如果严格节约的话，可以减少支出，但是如果太节约了，高桥君的身体就会不舒服，所以N天内每一天的饱食度都不能降到0以下

高桥君有超人级的胃袋，其饱食度是没有上限的，也就是说，无论怎么吃，高桥君的饱食度都不会达到最大值

现在请你回答高桥君最低能用多少日元的伙食费坚持这N天呢？

## 说明/提示

对于10%的数据，N<=10

对于50%的数据，N<=50，H<=50，B<=50，D<=50

对于100%的数据，N<=1000

对于数据，请勿使用32位整形（取自原题面）

Translated by @权御天下

## 样例 #1

### 输入

```
4 5
100 4 60 1 4```

### 输出

```
160```

## 样例 #2

### 输入

```
10 1
5000 2 2000 1 300```

### 输出

```
20000```

## 样例 #3

### 输入

```
9 23
170 8 120 5 12```

### 输出

```
650```

## 样例 #4

### 输入

```
653 314159
6728 123456 5141 41928 222222```

### 输出

```
2818162```

# 题解

## 作者：残阳如血 (赞：1)

参考了官方题解的思路。

### 100 pts
#### solution
首先，容易发现一个性质：
> 最好将用餐的时间放到开始几天。
> 
> 证明如下：
> 
> 假设当前饱食度为 $h'$，用一个补充 $t$ 饱食度的餐，不吃饭每天减 $e$ 点饱食度
> - 当先用餐时，最终饱食度为 $h'+t-e$；
> - 当后用餐时，最终饱食度为 $h'-e+t$；
> 
> 当 $h'-e<0$ 时，“后用餐”的方案就失效了。
> 当 $h'+t-e<0$ 时，显然两种方案都失效了。
>
> 所以“先用餐”的方案成功概率更大，故应当在前几天用餐。

假设 $x$ 天吃普通餐，$y$ 天吃简朴餐，则 $n-x-y$ 天不用餐。

那么此时最后一天的饱食度即为 $h+bx+dy-e(n-x-y)$，要求其 $>0$（可见 [讨论](https://www.luogu.com.cn/discuss/1055550)）。

枚举 $x,y$ 并判断，就可以解决了。

时间复杂度为 $O(n^2)$，可以通过 $n\le10^3$ 的数据。

#### code

[record](https://atcoder.jp/contests/abc013/submissions/62438050)

```cpp
#include <bits/stdc++.h>
using lint = long long;

lint ans = 1e18, n, h, a, b, c, d, e;

int main() {
	std::cin >> n >> h >> a >> b >> c >> d >> e;
	
	for (int x = 0; x <= n; ++x) {
		for (int y = 0; y <= n - x; ++y) {
			if (h + b * x + d * y - e * (n - x - y) > 0) {
				ans = std::min(ans, a * x + c * y);
				break;
			}
		}
	}
	
	std::cout << ans << std::endl;
	return 0;
}
```

### 101 pts

#### solution
考虑仅枚举 $x$，能否 $O(1)$ 或者 $O(\log n)$ 算出最小的可以满足条件的 $y$ 呢？

推式子：
$$
\begin{aligned}
h+bx+dy-e(n-x-y)&>0\\
(b+e)x+(d+e)y+h-en&>0\\
(d+e)y&>en-(b+e)x-h\\
y&>\dfrac{en-bx-ex-h}{d+e}\\
\end{aligned}
$$

故可以 $O(1)$ 根据 $x$ 计算 $y$ 的值。

需要注意，**当算出 $y<0$ 时，需要将 $y$ 置为 $0$**。

时间复杂度为 $O(n)$，可以通过 $n\le5\times10^5$ 的数据。

#### code

[record](https://atcoder.jp/contests/abc013/submissions/62438114)

```cpp
#include <bits/stdc++.h>
using lint = long long;

lint ans = 1e18, n, h, a, b, c, d, e;

int main() {
	std::cin >> n >> h >> a >> b >> c >> d >> e;
	
	for (lint x = 0; x <= n; ++x) {
		lint y = floor(1.0 * (e * n - b * x - e * x - h) / (d + e)) + 1;
		if (y < 0) y = 0;
		
		ans = std::min(ans, a * x + c * y);
	}
	
	std::cout << ans << std::endl;
	return 0;
}
```

---


# [ABC023C] 収集王

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc023/tasks/abc023_c

高橋君はある部屋に移動する予定です。

部屋は正方形のマスが縦に $ R $ 行、横に $ C $ 列並んだ形状をしています。このうち $ i\ (1\ ≦\ i\ ≦\ R) $ 行目の $ j\ (1\ ≦\ j\ ≦\ C) $ 列目にあるマスをマス $ (i,j) $ と呼ぶことにします。

これらのマスには飴が合計 $ N $ 個存在します。飴には $ 1 $ から $ N $ までの番号が付けられており、飴 $ i\ (1\ ≦\ i\ ≦\ N) $ はマス $ (r_i,c_i) $ に置いてあります。これらのうちどの $ 2 $ つの飴も同一のマス上にありません。

高橋君はマスのうち任意の $ 1 $ マスに移動します。移動した後、高橋君は次に示すように飴を獲得します。

- 最初に、高橋君がいるマスと同じ行にあるすべてのマスについて、そのマスにある飴をすべて獲得する。
- 次に、高橋君がいるマスと同じ列にあるすべてのマスについて、そのマスにあるすべての飴を獲得する。

高橋君はこの行動以外には何も行動しません。

高橋君は獲得する飴の個数がちょうど $ K $ 個になるようにしたいです。このような移動先として考えられるマスの総数を求めてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ R\ ≦\ 50 $ かつ $ C\ ≦\ 50 $ かつ $ N\ ≦\ 50 $ を満たすデータセット $ 1 $ に正解した場合は、$ 30 $ 点が与えられる。
- 追加制約のないデータセット $ 2 $ に正解した場合は、上記とは別に $ 70 $ 点が与えられる。

### Sample Explanation 1

例えば、マス $ (3,2) $ に高橋君が移動した場合を考えます。 - 飴 $ 1 $ は、マス $ (1,2) $ にあります。このマスはマス $ (3,2) $ と同じ列にあるので、高橋君は飴 $ 1 $ を獲得します。 - 飴 $ 2 $ は、マス $ (2,1) $ にあります。このマスはマス $ (3,2) $ と同じ行にも同じ列にもないので、高橋君は飴 $ 2 $ を獲得しません。 - 飴 $ 3 $ は、マス $ (2,5) $ にあります。このマスはマス $ (3,2) $ と同じ行にも同じ列にもないので、高橋君は飴 $ 3 $ を獲得しません。 - 飴 $ 4 $ は、マス $ (3,2) $ にあります。このマスはマス $ (3,2) $ と同じマス (同じ行かつ同じ列) にあるので、高橋君は飴 $ 4 $ を獲得します。 - 飴 $ 5 $ は、マス $ (3,5) $ にあります。このマスはマス $ (3,2) $ と同じ行にあるので、高橋君は飴 $ 5 $ を獲得します。 以上より、飴 $ 1 $, $ 4 $, $ 5 $ のちょうど $ 3 $ 個だけ飴を獲得するので、マス $ (3,2) $ は獲得する飴の個数がちょうど $ K $ 個になるような移動先です。 他にもマス $ (1,5) $, $ (2,5) $, $ (3,1) $, $ (3,5) $ が条件をみたすので答えとして $ 5 $ を出力します。

### Sample Explanation 2

どのように移動先を指定しても、獲得する飴の個数をちょうど $ 1 $ 個にすることはできません。

## 样例 #1

### 输入

```
3 5 3
5
1 2
2 1
2 5
3 2
3 5```

### 输出

```
5```

## 样例 #2

### 输入

```
7 3 1
4
3 2
3 3
4 2
4 3```

### 输出

```
0```

## 样例 #3

### 输入

```
5 5 2
5
1 1
2 2
3 3
4 4
5 5```

### 输出

```
20```

# 题解

## 作者：Jur_Cai (赞：2)

### 题意
在一个 $R \times C$ 的方格图上有 $N$ 颗糖果，一个格子能得到的糖果，是与这个糖果同列或同一行的糖果个数，求有多少个格子能恰好得到 $K$ 个糖果。

### 分析
部分分直接暴力枚举格子判断即可，直接考虑正解。

考虑有 $x$ 个糖果的一行，能与它配对列必然有 $K-x$ 个糖果，那就只要统计一下每一行 / 列有多少个糖果，由于 $N$ 不是很大，直接把列扔桶里。

但是如果行列交点处有糖果就会被算两次，就处理一下每一行的糖果位置，判断一下是否在解中，由于每个糖果只会被遍历一次，复杂度不会挂掉，实现见代码。

```c++
#include<bits/stdc++.h> 
using namespace std;
set<int> have[100005];//have[x]是一列中值糖果数为x的列集合
vector<int> g[100005];//每行糖果位置
int sumr[100005],sumc[100005];
int main() {
	int r,c,k,n;
	scanf("%d%d%d",&r,&c,&k);
	scanf("%d",&n);
	for(int i=1,x,y;i<=n;i++) {
		scanf("%d%d",&x,&y);	
		g[x].push_back(y);
		sumr[x]++,sumc[y]++;
	}
	for(int j=1;j<=c;j++)
		have[sumc[j]].insert(j);
	long long ans=0;
	for(int x=1;x<=r;x++) {
		if(k-sumr[x]<0) continue;
		ans+=have[k-sumr[x]].size();
		for(int i=0;i<g[x].size();i++) {
        		//判断行列交点有糖果的特殊情况
			if(have[k-sumr[x]].count(g[x][i])) ans--;
			if(have[k-sumr[x]+1].count(g[x][i])) ans++;
		}
	}
	cout<<ans<<'\n';
	return 0;
} 
```

---


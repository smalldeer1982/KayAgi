# [ABC025C] 双子と○×ゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc025/tasks/abc025_c

直大くんと直子さんは双子の兄妹です。時々、休日に $ 2 $ 人でゲームをしています。

ゲームは○×ゲームをベースにしており、以下の要領でゲームが行われます。

- ゲームは縦 $ 3 $ マス、横 $ 3 $ マスの盤面を使います。ゲーム開始時点ではどのマスにも文字が書かれていません。
- 挨拶した後、直大くんから始めて交互に文字を書いていきます。文字は盤面上のまだ文字が書かれていないマスの上にのみ書くことができます。そのようなマスが複数ある場合は好きな $ 1 $ 箇所を選んで書きます。書く文字は、直大くんが○、直子さんが×です。
- 合わせて $ 9 $ 回文字を書いた時点で、すべてのマスが埋まります。その後、得点計算を行い、得点の高い方が勝ちます。

得点計算は以下の方法で行われます。ここで、盤面の左上のマスをマス $ (1,\ 1) $ とし、左上から下に $ i-1\ (1\ ≦\ i\ ≦\ 3) $ マス、右に $ j-1\ (1\ ≦\ j\ ≦\ 3) $ マス進んだところにあるマスをマス $ (i,\ j) $ と呼ぶことにします。

- $ 1\ ≦\ i\ ≦\ 2 $ および $ 1\ ≦\ j\ ≦\ 3 $ を満たすすべての整数組 $ (i,j) $ に対して、マス $ (i,j) $ とマス $ (i+1,j) $ に書かれているマスを見て、同じ文字が書かれていたなら直大くんに、違う文字が書かれていたなら直子さんに $ b_{i,j} $ 点が入る。
- $ 1\ ≦\ i\ ≦\ 3 $ および $ 1\ ≦\ j\ ≦\ 2 $ を満たすすべての整数組 $ (i,j) $ に対して、マス $ (i,j) $ とマス $ (i,j+1) $ に書かれているマスを見て、同じ文字が書かれていたなら直大くんに、違う文字が書かれていたなら直子さんに $ c_{i,j} $ 点が入る。

直大くんも直子さんも、最終的に得られる自分の得点ができるだけ多くなるようにゲームを行います。両者が最善を尽くしたときのそれぞれの得点を計算してください。

## 说明/提示

### Sample Explanation 1

\- 例えば、マス $ (2,1) $ →マス $ (1,1) $ →マス $ (2,2) $ →マス $ (1,3) $ →マス $ (1,2) $ →マス $ (2,3) $ →マス $ (3,1) $ →マス $ (3,2) $ →マス $ (3,3) $ の順に文字が書かれた場合を考えます。この場合、盤面は最終的に以下のようになります。 ×○×○○×○×○- この場合、直大くんの得点は、$ (b_{1,2}\ +\ b_{1,3}\ +\ b_{2,1}\ +\ c_{1,2}\ =\ )\ 15\ +\ 0\ +\ 0\ +\ 0\ =\ 15 $ 点となります。 - 一方、直子さんの得点は、$ (b_{1,1}\ +\ b_{2,2}\ +\ b_{2,3}\ +\ c_{1,1}\ +\ c_{1,2}\ +\ c_{2,2}\ +\ c_{3,1}\ +\ c_{3,2}\ =\ )\ 0\ +\ 0\ +\ 25\ +\ 20\ +\ 10\ +\ 0\ +\ 25\ +\ 0\ =\ 80 $ 点となります。

## 样例 #1

### 输入

```
0 15 0
0 0 25
20 10
0 0
25 0```

### 输出

```
15
80```

## 样例 #2

### 输入

```
18 22 15
11 16 17
4 25
22 15
10 4```

### 输出

```
72
107```

# 题解

## 作者：残阳如血 (赞：1)

### $\textbf{Solution}$

~~开始想成博弈论了（~~

$3\times3$ 的棋盘，考虑直接暴力。

`dfs` 的参数应该传什么呢？
- 棋盘可以开一个全局变量，节省空间；
- 我们需要知道当前应该是谁操作，故记录当前操作次数。

`dfs` 的返回值应该是什么呢？

考虑在当前操作中（假设现在是先手操作），那么我们希望最大化自己的得分。

遍历每一种可以填的情况，在每一个情况中取一个最大值。

那么容易发现，`dfs` 的返回值应当为当前操作者的最优得分。

令先手最终得分为 $x$，后手最终得分为 $y$，考虑一个性质：
> $$
> x+y=\left(\sum\limits_{i=1}^{2}\sum\limits_{j=1}^{3}b_{i,j}\right)+\left(\sum\limits_{i=1}^{3}\sum\limits_{j=1}^{2}c_{i,j}\right)
> $$

可以发现最后统计分数的时候，$b_{i,j}$ 或是 $c_{i,j}$ 总会加入一个人的分数中，故总和保持不变。

那么我们只需要确定一个人的分数，就可以 $O(1)$ 推出另外一个人的分数。

这样就好啦！详见代码。

### $\textbf{Code}$

[record](https://atcoder.jp/contests/abc025/submissions/62464268)

```cpp
#include <bits/stdc++.h>
const int N = 5;

char board[N][N];
int sum, b[N][N], c[N][N];

int dfs(int step) { // 返回先手得分
	if (step == 9) { // 填满了
		int res = 0;
		for (int i = 0; i < 2; ++i)
			for (int j = 0; j < 3; ++j)
				if (board[i][j] == board[i + 1][j]) res += b[i][j];
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 2; ++j)
				if (board[i][j] == board[i][j + 1]) res += c[i][j];
		return res;
	}
	if (step & 1) { // 后手，最小化得分
		int res = 2e9;
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j) {
				if (!board[i][j]) {
					board[i][j] = 'o';
					res = std::min(res, dfs(step + 1));
					board[i][j] = 0;
				}
			}
		return res;
	} else { // 先手，最大化得分
		int res = 0;
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j) {
				if (!board[i][j]) {
					board[i][j] = 'x';
					res = std::max(res, dfs(step + 1));
					board[i][j] = 0;
				}
			}
		return res;
	}
}

int main() {
	for (int i = 0; i < 2; ++i)
		for (int j = 0; j < 3; ++j) std::cin >> b[i][j], sum += b[i][j];
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 2; ++j) std::cin >> c[i][j], sum += c[i][j];
	
	// 先用 sum 求出两个人的分数之和
	
	int t = dfs(0);
	std::cout << t << std::endl << sum - t << std::endl;
	return 0;
}
```

---

## 作者：AkeRi (赞：1)

# Solution
water~water

暴搜，枚举其中一方每一步走的方式，最后一方的结果是搜出来的答案，另一方的答案显然是 $\sum_{i=1}^{3}\sum_{j=1}^3(b_{i,j}+c_{i,j})$ 减去搜出来的答案的结果。

对于所有的 $9$ 步，每次都枚举剩余的所有情况，因此总复杂度 $\text{O}(9^9)$，同时注意输出最后要加一个换行符。
```cpp
int dfs(int now[4][4],int cnt)
{
    if(cnt==9)
    {
        int res=0;
        for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) if(now[i][j]==now[i+1][j]) res+=b[i][j];
        for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) if(now[i][j]==now[i][j+1]) res+=c[i][j];
        return res;
    }
    int s=INT_MAX;
    if(cnt%2==0)
    {
        s=-INT_MAX;
        for(int i=1;i<=3;i++) for(int j=1;j<=3;j++)
        {
            if(now[i][j]!=0) continue;
            now[i][j]=1;
            s=std::max(s,dfs(now,cnt+1));
            now[i][j]=0;
        }
    }
    else
    {
        for(int i=1;i<=3;i++) for(int j=1;j<=3;j++)
        {
            if(now[i][j]!=0) continue;
            now[i][j]=-1;
            s=std::min(s,dfs(now,cnt+1));
            now[i][j]=0;
        }
    }
    return s;
}
```

---


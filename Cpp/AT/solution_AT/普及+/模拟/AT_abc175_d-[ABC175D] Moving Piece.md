# [ABC175D] Moving Piece

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc175/tasks/abc175_d

高橋君は $ 1,\ 2,\ \cdots,\ N $ の番号のついた $ N $ マスから成るマス目の上で、コマを使ってゲームを行おうとしています。マス $ i $ には整数 $ C_i $ が書かれています。また、$ 1,\ 2\ …,\ N $ の順列 $ P_1,\ P_2,\ \cdots,\ P_N $ が与えられています。

これから高橋君は好きなマスを $ 1 $ つ選んでコマを $ 1 $ つ置き、$ 1 $ 回以上 $ K $ 回以下の好きな回数だけ、次のような方法でコマを移動させます。

- $ 1 $ 回の移動では、現在コマがマス $ i\ (1\ \leq\ i\ \leq\ N) $ にあるなら、コマをマス $ P_i $ に移動させる。このとき、スコアに $ C_{P_i} $ が加算される。

高橋君のために、ゲーム終了時のスコアとしてあり得る値の最大値を求めてください。(ゲーム開始時のスコアは $ 0 $ です。)

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ P_i\ \leq\ N $
- $ P_i\ \neq\ i $
- $ P_1,\ P_2,\ \cdots,\ P_N $ は全て異なる
- $ -10^9\ \leq\ C_i\ \leq\ 10^9 $
- 入力は全て整数である

### Sample Explanation 1

好きなマスから始めて $ 2 $ 回以下コマを移動させる方法は以下の通りです。 - 初めマス $ 1 $ にコマを置く場合。$ 1 $ 回移動するとマス $ 2 $ に動き、スコアが $ 4 $ になる。$ 2 $ 回移動するとマス $ 4 $ に動き、スコアが $ 4\ +\ (-8)\ =\ -4 $ になる。 - 初めマス $ 2 $ にコマを置く場合。$ 1 $ 回移動するとマス $ 4 $ に動き、スコアが $ -8 $ になる。$ 2 $ 回移動するとマス $ 1 $ に動き、スコアが $ -8\ +\ 3\ =\ -5 $ になる。 - 初めマス $ 3 $ にコマを置く場合。$ 1 $ 回移動するとマス $ 5 $ に動き、スコアが $ 8 $ になる。$ 2 $ 回移動するとマス $ 3 $ に動き、スコアが $ 8\ +\ (-10)\ =\ -2 $ になる。 - 初めマス $ 4 $ にコマを置く場合。$ 1 $ 回移動するとマス $ 1 $ に動き、スコアが $ 3 $ になる。$ 2 $ 回移動するとマス $ 2 $ に動き、スコアが $ 3\ +\ 4\ =\ 7 $ になる。 - 初めマス $ 5 $ にコマを置く場合。$ 1 $ 回移動するとマス $ 3 $ に動き、スコアが $ -10 $ になる。$ 2 $ 回移動するとマス $ 5 $ に動き、スコアが $ -10\ +\ 8\ =\ -2 $ になる。 これらの最大値は $ 8 $ です。

### Sample Explanation 3

最低 $ 1 $ 回はコマを移動させる必要があります。

### Sample Explanation 4

答えの絶対値は非常に大きくなる場合があります。

## 样例 #1

### 输入

```
5 2
2 4 5 1 3
3 4 -10 -8 8```

### 输出

```
8```

## 样例 #2

### 输入

```
2 3
2 1
10 -7```

### 输出

```
13```

## 样例 #3

### 输入

```
3 3
3 1 2
-1000 -2000 -3000```

### 输出

```
-1000```

## 样例 #4

### 输入

```
10 58
9 1 6 7 8 4 3 2 10 5
695279662 988782657 -119067776 382975538 -151885171 -177220596 -169777795 37619092 389386780 980092719```

### 输出

```
29507023469```

# 题解

## 作者：igAC (赞：3)

# $\text{Description}$

[洛谷 link](https://www.luogu.com.cn/problem/AT_abc175_d)

[ATlink](https://atcoder.jp/contests/abc175/tasks/abc175_d)

简要题意（atcoder better）：

高桥将用一枚棋子在编号为 $1, 2, \cdots, N$ 的数组方格上下棋。方格 $i$ 上写着一个整数 $C_i$。

此外，他还得到了一个 $1, 2, \cdots, N$ 的排列组合：$P_1, P_2, \cdots, P_N$。

现在，他将选择一个方格并将棋子放在该方格上。然后，他将在 $1$ 和 $K$ 之间（包括 $1$ 和 $K$）下若干次棋：

- 在一步棋中，如果棋子现在在 $i$ 位 $(1 \leq i \leq N)$，将其移动到 $P_i$ 位置。在这里，他的得分会增加 $C_{P_i}$。

帮助他找出对局结束时的最大可能得分。(游戏开始时的得分是 $0$）。

# $\text{Solution}$

简单题。

如果你把它当作一个图论来做的话，你会发现每个点的入度和出度都是 $1$，那么整个图是由若干个简单环构成的。

然后就可以枚举起始点，接着枚举在哪个点结束，计算答案即可。

时间复杂度 $O(n^2)$。

具体实现可参考代码。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define LLINF -1e18
#define int long long
#define N 5005
using namespace std;
int read(){
	int x=0,f=1,ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f=(ch=='-')?-1:1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
void print(int x){
	if(x<0) putchar('-'),x=~(x-1);
	if(x>9) print(x/10);
	putchar(x%10+48);
}
int n,k,to[N],a[N];
int ans=-LLINF;
signed main(){
	n=read(),k=read();
	for(int i=1;i<=n;++i) to[i]=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=n;++i){//枚举起始点
		int j=i,sum=0;
		vector<int>vec;
		while(true){
			j=to[j],sum+=a[j];
			vec.push_back(sum);
			if(j==i) break;
		}//找环
		int cirsize=vec.size();
		for(int s=0;s<vec.size() && s<k;++s){//枚举在哪个点停下
			int cnt=(k-s-1)/cirsize;
			if(sum<=0) ans=max(ans,vec[s]);
			else ans=max(ans,vec[s]+cnt*sum);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：2012_Zhang_ (赞：0)

## 题意如下：

高桥将用一枚棋子在编号为  $1,2,⋯,N$  的数组方格上下棋。方格 $i$ 上写着一个整数 $C_i$。

此外，他还得到了一个 $1,2,⋯ ,N$ 的排列组合：
 $P_1$ , $P_2$ ,⋯, $P_N$。

现在，他将选择一个方格并将棋子放在该方格上。然后他将在  $1$ 和  $K$  之间（包括 1 和 K）下若干次棋：

- 在一步棋中，如果棋子现在在 $ i$ 位 $(1≤i≤N)$，将其移动到 $P_i$ 位置，在这里，他的得分会增加 $ C_{P_i}$。

帮助他找出对局结束时的最大可能得分。(游戏开始时的得分是 $0$。

## 解题思路：
首先看数据，$(1≤K≤10^9)$ 模拟被 Pass 了。\
那么还是先观察样例，通过观察发现任意位置走棋次数达到一定次数时会形成一个环，而 $(2≤N≤5000)$，所以次数不超过 $5000$。\
既然如此，我们只需寻找每个点的循环，再计算出最大值并处理余下部分就行了。\
但有个细节我们还需要额外处理最后一个循环，因为余下部分未必能达到最大值。

代码奉上：
## AC CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x[100000],y[100000],sum=-1e18,k;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>x[i];
	for(int i=1;i<=n;i++) cin>>y[i];
	for(int i=1;i<=n;i++){
		long long j=i,p=1,f=1;
		long long ans=0;
		while(p<=k&&(j!=i||f==1)){
			ans+=y[j];
			sum=max(sum,ans);
			p++;
			f=0;
			j=x[j];
		}\\寻找循环
		if(k<p) continue;
		if(ans>0){
			ans=(k/(p-1)-1)*ans;\\预留最后一个循环
			sum=max(sum,ans);
			long long q=k-(k/(p-1)-1)*(p-1);\\统计剩余次数
			if(q==0) continue;
			p=1,j=i,f=1;
			while(p<=q){
				ans+=y[j];
				sum=max(sum,ans);
				j=x[j];
				p++;
				f=0;
			}
		}
	}
	cout<<sum;\\输出，万事大吉
	return 0;
}

---


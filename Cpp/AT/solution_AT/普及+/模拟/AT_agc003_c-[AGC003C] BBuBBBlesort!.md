# [AGC003C] BBuBBBlesort!

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc003/tasks/agc003_c

高橋君は、誕生日に長さ $ N $ の数列をもらいました。$ i(1\ ≦\ i\ ≦\ N) $ 番目の要素は整数 $ A_i $ です。どの $ 2 $ つの要素も、互いに異なります。 高橋君はこの数列を単調増加になるように並べ替えたいです。 高橋君は超能力者なので、以下の $ 2 $ つの操作が任意のタイミングでできます。

- 操作$ 1 $: 数列の連続する $ 2 $ つの要素を選び、その $ 2 $ つの順番を反転する。
- 操作$ 2 $: 数列の連続する $ 3 $ つの要素を選び、その $ 3 $ つの順番を反転する。

高橋君は操作$ 2 $は好きですが、操作$ 1 $は嫌いです。この $ 2 $ 種類の操作を使って数列を単調増加になるように並び替えるときの、操作$ 1 $の最小回数を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 0\ ≦\ A_i\ ≦\ 10^9 $
- $ i\ ≠\ j $ ならば $ A_i\ ≠\ A_j $
- 入力はすべて整数である。

### Sample Explanation 1

以下の操作で、単調増加な数列にすることができます。 - まず、後ろの $ 3 $ つの要素を反転する。数列は $ 2,1,3,4 $ となる。 - 次に、前の $ 2 $ つの要素を反転する。数列は $ 1,2,3,4 $ となる。 この操作列において、連続する $ 2 $ つの要素を入れ替える操作の回数は $ 1 $ です。これより少ない回数で単調増加な数列は作れないので、$ 1 $ を出力します。

## 样例 #1

### 输入

```
4
2
4
3
1```

### 输出

```
1```

## 样例 #2

### 输入

```
5
10
8
5
3
2```

### 输出

```
0```

# 题解

## 作者：installb (赞：7)

首先把这个序列离散化，变成一个 $1$ 到 $n$ 的排列。

这个操作 2 看起来很奇怪，我们把它重新写一下，它等价于：  

- 交换 $a_i$ 和 $a_{i+2}$。  

这一操作做任意多次都是免费的，所以就相当于一开始以及做完一次操作 1 之后，我们可以对 $a_1,a_3,a_5,\cdots$，$a_2,a_4,a_6,\cdots$ 这两个序列任意排序，也就是下表为奇数和下标为偶数。  

不过仅靠这样没法排序这个序列。因为**奇数位上的数永远在奇数位置上**，如果有一个数在**排序好的数列中应当在偶数位置上**，它无法被放到正确的位置上。  
这时候就需要操作 1，显然这时候有对应一个应该处在奇数位置上但目前在偶数位置上的数，我们通过任意排序使它们相邻，然后用操作 1 交换，这样这两个数的位置的奇偶性正确了，可以通过任意排序把他们放到正确的位置。  

我们统计出位置和目标位置奇偶性不同的数的数量 $cnt$，每次操作可以归位两个，所以答案就是 $\frac{cnt}{2}$。  

一次操作达成的效果不可能比这样更优，这么多操作是充分且必要的。  

代码给一下吧。  
离散化后这个数的值就是它的目标位置。  

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;
typedef long long LL;

LL n,ans = 0;
LL a[200005],b[200005];

int main(){
	ios::sync_with_stdio(false);
	cin >> n;
	for(LL i = 1;i <= n;i ++){
		cin >> a[i];
		b[i] = a[i];
	}
	sort(b + 1,b + 1 + n);
	for(LL i = 1;i <= n;i ++) a[i] = lower_bound(b + 1,b + 1 + n,a[i]) - b; // 离散化
	
	for(LL i = 1;i <= n;i ++) if((a[i] & 1) != (i & 1)) ans ++;
	ans >>= 1;
	cout << ans << endl;
	return 0;
}
```

原评分 $\sf{\color{cyan}1539}$。  

比较偏思维的一道题，没什么前置知识要求，码量也很小。

---

## 作者：Tipsy_bamboo (赞：4)

## AT2003 [AGC003C] BBuBBBlesort!。
### 思路
由于第一个操作会改变下标奇偶，而操作二不会。题目要求操作一的数量尽可能的少，所以本数与目标数下标相同的数，就尽量使用操作二。当奇偶不相同时，就使用一次操作一，剩下的也使用操作二。
### 知识点
``lower_bound(a, e, x)`` 表示在区间 [$ a $, $ e $]  之间查找第一个大于等于 $ x $ 的数，找不到就返回 $ e $。切记，使用 ``lower_bound`` 的数组必须要排好序。
### 代码奉上（千万不要抄袭）
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005], b[100005];
int main()
{
	int n, ns = 0;
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) 
	{
		cin >> b[i];
		a[i] = b[i];
	}
	sort(b + 1, b + 1 + n);
	for(int i = 1; i <= n; i++) a[i] = lower_bound(b + 1 , b + 1 + n, a[i]) - b;
	for(int i = 1; i <= n; i++)
	{
		if(a[i] % 2 != i % 2) ns++; 
	}
	printf("%d ", ns / 2);
	return 0;
}
```
      

---

## 作者：Chydz (赞：2)

由于操作 2 没有要求，容易想到可以无限制地用它，直到不得不用操作 $1$ 。于是，考虑什么时候操作 2 不能解决。

首先，操作 2 等价于交换 a[i] 和 a[i+2] ，对于某个位置上的数，使用操作 2 只能将它移到与原位置距离为偶数的位置。（即原来在奇数位置，移动后也在奇数位置；原来在偶数位置，移动后也在偶数位置）。然而操作 1 与此刚好相反。

然后，做法就很明显了：找出每个数最终要到达的位置，判断与当前的位置的奇偶性是否相等，若不等，说明需要消耗一次操作 1 。

注意最终统计的答案需要除以 2 （每一次操作改变的是两个数的位置）。

核心代码：

```cpp
int main()
{
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		b[i]=a[i];
	}
	int ans=0;
	sort(b+1,b+1+n);
	for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+1+n,a[i])-b;
	for(int i=1;i<=n;i++)if((a[i]&1)!=(i&1))ans++;
	cout<<ans/2;
	return 0;
}
```


---

## 作者：AsunderSquall (赞：2)

~~你看这个人就是屑只能给蓝题交题解~~  
# 题意
给定一个序列 $a$，元素两两不同，可以使用两种操作。

1. 翻转相邻两个元素

1. 翻转相邻三个元素

问怎么操作使这个序列变成升序，并使操作一的次数最少，且输出这个最少的次数

# 题解  
注意到 $2$ 操作只能使下标奇偶相同的数的位置发生变化。  
然后 $1$ 操作能使下标奇偶不同的数的位置发生变化。  
由于所有数都不一样，所以每个数的最终位置都是确定的。  
那么如果最终位置和当前位置的奇偶性不一样，$ans \gets ans+1$。  
最后考虑到每次操作 $1$ 改变 $2$ 个数的位置的奇偶性，$ans \gets \dfrac{ans}{2}$  
```cpp
int n,ans;
int a[N];
struct Node {int num,id;}b[N];
bool cmp(Node x,Node y){return x.num<y.num;}
signed main()
{
	rd(n);
	for (int i=1;i<=n;i++) 
	{
		rd(a[i]);
		b[i]=(Node){a[i],i};
	}
	sort(b+1,b+n+1,cmp);
	for (int i=1;i<=n;i++) if ((b[i].id-i)%2!=0) ans++;
	cout<<ans/2<<endl;
}
```

---

## 作者：Kubic (赞：2)

这道题其实根本没有看起来的那么毒瘤......

看到操作$2$，发现其实就是将$2$个相隔$1$个位置的数交换一下。容易发现，$2$个数字对应下标的**奇偶性不变**。于是就有了思路：

先将数列中下标为**奇数**的与下标为**偶数**的分为两个数列，分别排序，再将两个数列按原来下标顺序合并。~~好吧我承认我语文不好，只好上个例子~~
```
原数列:4 3 5 2 1
分拆:4 5 1,3 2
分别排序:1 4 5,2 3
合并:1 2 4 3 5
```
~~是不是很生动形象呢~~

问题就转变为了冒泡排序的最小交换次数问题，不就是**逆序对**嘛。因为$N\le 10^5$，所以要开$long$ $long$。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
#define gc getchar
#define ll long long
#define lb(x) ((x)&(-(x)))
int n,a[N],b[2][N],c[N],ds[N],v[N];ll ans;
int rd()
{
	bool fl=0;int res=0;char c=0;
	while(!isdigit(c)) fl|=c=='-',c=gc();
	while(isdigit(c)) res=(res<<1)+(res<<3)+(c&15),c=gc();
	return fl?-res:res;
}
void dsc() {sort(ds+1,ds+ds[0]+1);ds[0]=unique(ds+1,ds+ds[0]+1)-ds-1;}
int id(int _v) {return lower_bound(ds+1,ds+ds[0]+1,_v)-ds;}
void upd(int x) {for(;x<=n;x+=lb(x)) ++v[x];}
int qSm(int x) {int res=0;for(;x;x-=lb(x)) res+=v[x];return res;} 
int main()
{
	n=rd();
	for(int i=1;i<=n;++i) a[i]=rd(),b[i&1][++b[i&1][0]]=a[i];
	sort(b[0]+1,b[0]+b[0][0]+1);sort(b[1]+1,b[1]+b[1][0]+1);
	for(int i=1;i<=b[0][0];++i) c[++c[0]]=b[1][i],c[++c[0]]=b[0][i];
	if(b[1][0]>b[0][0]) c[++c[0]]=b[1][b[1][0]];for(int i=1;i<=n;++i) ds[++ds[0]]=c[i];dsc();
	for(int i=1;i<=n;++i) c[i]=id(c[i]),ans+=i-1-qSm(c[i]-1),upd(c[i]);
	printf("%lld\n",ans);
}
```
~~于是作弊者们用这份代码交了上去，发现WA了，但得到了71分的好成绩~~

举个hack的栗子：
```
输入：
5
2 100 1 200 3
```
上面代码的输出：
```
3
```
正确输出：
```
1
```
方法：
```
(1) 1 100 2 200 3 (不计)
(2) 1 100 200 2 3 (不计)
(3) 1 2 200 100 3
(4) 1 2 3 100 200 (不计)
```
之前的程序错在明明可以使用操作$2$直接交换时，却使用了操作$1$（就错在后面的求逆序对上）

那正解是怎么做的呢？

看到操作$1$，发现每一次都会将相邻$2$个数的下标的奇偶性互换。于是一个新的思路就出现了：

先将数列排序，并记录排序好后的每一个数的位置对应排序之前的那个数的位置。如果$2$个位置奇偶性不同，则将计数器的值加$1$。

**输出的是计数器的值除以2！！！**（具体为什么请自己想，很简单的）

参考代码：
```cpp
那么好写还要我放代码？
```

---

## 作者：kkk吉祥物 (赞：2)

### 思路

由于操作 2 不影响结果，所以应该多用操作 2 代替操作 1。那么什么时候能用操作 2 代替操作 1 呢？很简单，我们能发现操作 2 不会改变下标的奇偶，所以奇偶相同就用操作 2。另外求出的操作 1 使用次数应除以 $2$ 因为一次能交换 $2$ 个。
### 知识点
由于此题数据范围较大，所以可以用 STL 里的 `lower_bound`，用法如下：

`lower_bound(a,e,x)`

代表在 $[a,e]$ 中查找 $x$，找到返回 $x$ 的位置，找不到返回 $e$。想要将地址转换为下标要将结果减去 $a$。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010],b[100010];
int main()
{
	int n,ans=0;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];	
		b[i]=a[i];
	} 
	sort(b,b+n);
	for(int i=0;i<n;i++)
	a[i]=lower_bound(b,b+n,a[i])-b;
	for(int i=0;i<n;i++)
		if(a[i]%2!=i%2)ans++;
	cout<<ans/2<<endl;
}
```

---

## 作者：D2T1 (赞：1)

[$\color{blue}{\text {pwp }{\to\textbf{My blog}\gets}}\text{qwq}$](https://www.luogu.com.cn/blog/390770/blogcenter)

## 题目

给定一个序列 $a$，元素两两不同，可以使用两种操作。

1. 翻转相邻两个元素

2. 翻转相邻三个元素

问怎么操作使这个序列变成升序，**并使操作一的次数最少**，且输出这个最少的次数

## 题解

题目要求操作一的个数最少，就不用管操作二的次数了。

可以发现，操作二等价于交换 $a[i]$ 和 $a[i+2]$。所以操作二只能改变两个下标奇偶性相同的两个数的值。于是我们可以将序列 $a$ 分为两部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/1dbgc0zl.png)

其中红色的部分可以互相通过操作二交换，蓝色部分可以互相通过操作二交换。

这样我们就相当于用操作二对红、蓝两部分分别进行冒泡排序，最后只需要交换原序列和目标序列颜色不同的元素了。

## 代码

```cpp
//AT2003
//码风：题解专用
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, a[ N ], b[ N ], ans;

int main( )
{
	scanf( "%d", &n );
	for( int i = 1; i <= n; ++ i ){
		scanf( "%d", &a[i] );
	}
	memcpy( b, a, sizeof( a ) );
	sort( b + 1, b + n + 1 );
	for( int i = 1; i <= n; ++ i ){
		int j = lower_bound( b + 1, b + n + 1, a[ i ] ) - b;
		if( ( i & 1 ) != ( j & 1 ) ) ++ ans;
	}
	printf( "%d", ans >> 1 );//一次交换可以满足两个元素
	return 0;
}
```

---


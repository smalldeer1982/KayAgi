# [ARC012C] 五目並べチェッカー

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc012/tasks/arc012_3

高橋君は、五目並べが大好きです。  
 五目並べとは、 $ 19 $ × $ 19 $ の碁盤の上に交互に碁石を $ 1 $ つずつ並べ、 $ 5 $ つ以上の碁石が縦・横・ななめに並べたプレーヤーが勝ちとなってゲームが終了する、というルールのゲームです。  
 ゲームは必ず黒のプレーヤーから始めるものとします。  
 高橋君は、友達の青木君と五目並べをしていたのですが、うっかり居眠りをしてしまいました。  
 高橋君は寝ている間に青木君が不正をしたのではないかと疑っているので、盤面から五目並べの状態として異常なところがないかを探したいです。  
 五目並べの状態として、正常であるかどうか判定するプログラムを作ってください。  
 ここでの異常な状態とは、

- どちらかのプレーヤーの勝利条件を満たしているのに、もう片方のプレーヤーがさらに碁石を置いている。
- お互いが置いた個数がありえない状態になっている。
 
 のどちらかであることを指します。 入力は以下の形式で標準入力から与えられる。 > $ b_{1,1}\ b_{2,1}\ ‥‥\ b_{19,1} $ $ b_{1,2}\ b_{2,2}\ ‥‥\ b_{19,2} $ $ : $ $ : $ $ b_{1,19}\ b_{2,19}\ ‥‥\ b_{19,19} $

- 入力は $ 19 $ 行与えられる。
- $ i(1≦i≦19) $ 行目の $ j(1≦j≦19) $ 文字目には、盤面の縦 $ i $ 番目、横 $ j $ 番目のマスの情報を表す文字 $ b_{i,j} $ が与えられる。
- $ b_{i,j} $ は、`o`、`x`、`.` の $ 3 $ 種類のいずれかの文字である。 
  - `o` は、黒石が置かれていることを表す。
  - `x` は、白石が置かれていることを表す。
  - `.` は、何も置かれていないことを表す。


 盤面が正常な状態であれば、`YES`、そうでなければ `NO` と出力しなさい。   
 出力は標準出力におこない、末尾には改行をいれること。  
```

...................
...................
...................
...................
....x......o.......
...................
...................
.......o....o......
...................
........x..........
..............o....
...................
.......x...........
...................
...................
...................
...................
...................
...................
```

 ```

YES
```

- 黒が $ 4 $ 手、白が $ 3 $ 手打った状態です。
- （記述に誤りがありましたので、修正しました。）
 
```

...................
...................
...................
...................
....x......o.......
...................
...................
.......o....o......
...................
........x..........
..............o....
...................
.......x...........
...................
...................
.........o.........
...................
...................
...................
```

 ```

NO
```

- 黒が $ 5 $ 手、白が $ 3 $ 手打った状態です。
- 黒が $ 1 $ 手多く打ってしまっているので、異常な状態です。
 
```

...................
...................
...................
...................
...................
...................
...................
...................
........ooooo......
.........xxxx......
........x..........
...................
...................
...................
...................
...................
...................
...................
...................
```

 ```

NO
```

- 黒が $ 5 $ 手、白が $ 5 $ 手打った状態です。
- 片方が勝利条件を満たしていればゲームは終了しているので、黒が勝利条件を満たしているのは異常な状態です。
- （記述に間違いがありましたので、訂正しました。）
 
```

...................
...................
...................
...................
...................
...................
...................
...................
........ooooo......
.........xxxx......
...................
...................
...................
...................
...................
...................
...................
...................
...................
```

 ```

YES
```

- 黒が $ 5 $ 手、白が $ 4 $ 手打った状態です。
- 黒が $ 5 $ つ並べて勝利した状態となり、正常です。
 
```

...................
...................
...................
...................
...................
...................
...................
...................
.........x.........
......oooooo.......
........xxxx.......
...................
...................
...................
...................
...................
...................
...................
...................
```

 ```

YES
```

- 黒石が $ 6 $ つ並んでいますが、正常です。
- 例えば黒石が $ 2 $ つ並んでおり、$ 1 $ マス空いてさらに $ 3 $ つ並んでいる状態で、空いている真ん中のマスに黒石を置いた場合このような形になります。
 
```

...................
...................
...................
...................
...................
...................
........x..........
........x....x.....
...........x.......
...oooooooooo......
...................
......x......x.....
....x......x.......
.........x.........
...................
...................
...................
...................
...................
```

 ```

NO
```

- 黒が $ 10 $ 手、白が $ 9 $ 手打った状態です。
- 黒石を $ 10 $ 個並べる前に、黒が勝利してゲームが終了していないとおかしいので、異常な状態です。
 
```

...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
...................
```

 ```

YES
```

- 黒が高橋君で、一手も打たないうちに居眠りしてしまった場合も、正常な状態です。

# 题解

## 作者：LucasXu80 (赞：3)

## 对于这份代码版权问题的简述

这份代码是我的老师 @楼楼223 与我合作完成的，我**被授权**发布这篇题解。再次感谢 @楼楼223 !

这道题的小细节比较多，我会在代码前介绍主要思路，一些细节与特判在代码内完成。

好了，开始吧！

## 解题思路

#### 一、上一手棋子颜色的判断

因为黑子线下，一定有以下判断：

如果黑子数量==白子数量，可以说明刚刚下的是白子。（黑子和白子两两对应）

如果黑子数量-白子数量==1，刚刚下的是黑子。（白子下完，黑白子数量相等后又多了一手黑子）

如果这两种情况都不是，那么有问题，输出NO。

这件事情很清楚，不必详细描述了。

#### 二、是否作弊的判断方法

#### 1.作弊过程的描述

好了，来到核心部分。

如何判断这个人有没有作弊呢？

设想一个情形，这个时候两个人都没有获胜。并且**刚刚下的是黑子**。（其实白子同理，为方便起见这里先只讲黑子）

这时，一只~~邪恶的~~小手伸过来，放了一个子，使他**获胜了**。

那么这个时候，如果**比赛还在继续**，也就是**又出现了下一手**，那么就说明他作弊了。

因为获胜了，比赛就**结束了**，不可能继续了呀！

#### 2.深入分析作弊过程

 _好了，现在我们细品这个非常非常重要的过程。_ 

这个作弊者可能放了哪一个棋子呢？

**哪一个黑子都可能。**

所以，我们要**遍历刚刚下的每一个黑子**，来看看如果他刚刚下的是这个棋子，是不是属于作弊。

如果有**一种情况无法判断作弊**，那刚刚下的有可能就是这个棋子，不能说明他作弊，直接输出$YES$即可。

如果每一种情况都说明他作弊了，那他**肯定作弊了**，输出$NO$。

怎么遍历呢？我们可以反向模拟这个过程。也就是**依次**去掉每一个黑子。注意，是依次去掉，也就是去掉，判断完之后还要再**放回来**。

那么**去掉后棋子的情形便是上一步的情况**。如果这种情况下已经有人获胜，那么比赛不应继续。

如果去掉每一个黑子后都是这种情况，可以说明他一定作弊了，输出$NO$。

反之，如果有一个黑子被去掉后无人获胜，那么就**无法判断他作弊了**，因为他刚刚下的可能就是这个棋子，在这种情况下他没有作弊。因此输出$YES$。

当然，如果原来（没有去掉棋子）的情况下就无人获胜，更没有问题了。

#### 三、寻找连续棋子的方法

再来介绍寻找一个棋子周围寻找连续棋子的方法。

一个棋子周围有8个棋子，用两个数组记录他们的位置：

```cpp
const int x[] = {1,1,1,-1,-1,-1,0,0};
const int y[] = {0,1,-1,0,1,-1,1,-1};
```
其中，x数组中，1是下一行，-1是上一行，0是本行。

y数组中，1是下一列，-1是上一列，0是本列。

比如，$x[0],y[0]$对应的是本列下一行，也就是原格下方的位置。

这样这两个数组就可以描述每一个位置了，拿纵横坐标分别加减即可。

其他的小细节，代码中见~

## 完整AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int x[] = {1,1,1,-1,-1,-1,0,0};
const int y[] = {0,1,-1,0,1,-1,1,-1};
//8个位置的记录
queue < pair<int,int> > black,white;
//两个整数分别表示纵横坐标，方便后面取用
char board[20][20]; //记录棋盘
int o_len = 0, x_len = 0; //记录最大长度

void lf(int i, int j, char c, int len, int k)
//ij是纵横坐标，c表示是黑子还是白子，len是当前连续长度，k是数组下标，表示方位
{
    if (board[i][j]=='.') return; //没有棋子，不用判断
    if (c == 'o' && len>o_len) o_len = len; //黑子连续
    if (c == 'x' && len>x_len) x_len = len; //白子连续
    //擂台法，寻找最大
    if (board[i+x[k]][j+y[k]] == c)  
    //如果和中心棋子是一样的，即连续
    lf(i+x[k],j+y[k],c,len+1,k); //len别忘了+1，表示又找到了一颗连续的棋子
    //把中心棋子变为找到的相同颜色的棋子继续搜索，看看有没有进一步连续
 }
 
void search_max_length()
{
    for (int i = 1; i <= 19; i++)
    {
        for (int j = 1; j <= 19; j++) //遍历棋盘
        {
            //八种情况
            if (board[i][j] == 'o') //是黑子
                for (int k = 0; k<=7; k++) lf(i,j,'o',1,k);
                //8个相邻格
            if (board[i][j] == 'x') //是白子
                for (int k = 0; k<=7; k++) lf(i,j,'x',1,k);
        }
    }
}

int main()
{
    int o = 0, x = 0; //记录黑子白子总共的数量
    for (int i = 1; i <= 19; i++)
    {
        for (int j = 1; j <= 19; j++)
        {
            cin>>board[i][j]; //输入棋盘
            if (board[i][j] == 'o')  //是黑棋
            {
                black.push(make_pair(i,j)); //纵横坐标入黑队
                o++;
            }
            if (board[i][j] == 'x')  //是白棋
            {
                white.push(make_pair(i,j)); //纵横坐标入白队
                x++;
            }
        }
    }

    if (o - x >= 2 || x > o) //黑比白多了超过1个或者白比黑多
    {
        cout<<"NO"<<endl;
        return 0;
    }
    if (x == 0 && o == 0) //特判：棋盘是空的
    {
        cout<<"YES"<<endl;
        return 0;
    }
    if (o - x == 1)//上一步是黑子下的
    {   
    //去掉一颗黑子
        while (black.size()) //在子还没有被全部去掉时
        {
           int axis_x = black.front().first; 
           int axis_y = black.front().second;
           //要去掉的棋子的纵横坐标
           black.pop(); //这一颗棋子出队，表示已经去掉过
           board[axis_x][axis_y] = '.'; //标记成没有棋子
           o_len = 0;
           x_len = 0; //先归零
           search_max_length(); //搜索最大长度
           board[axis_x][axis_y] = 'o'; //标记回来
           if (o_len <= 4 && x_len <= 4) //都不长于4，无人获胜
           {
               //有可能没有作弊，输出YES
               cout<<"YES"<<endl;
               return 0;
           }
        }
        //所有情况去掉一个黑子均有大于4的连续棋子，即一定有人获胜
        cout<<"NO"<<endl;
        return 0;
    }
    if (x == o) //上一手是白子下的
    {
    //去掉一颗白子，与上方去掉黑子重复，此处不再详细解释了
        while (white.size())
        {
           int axis_x = white.front().first;
           int axis_y = white.front().second;
           white.pop();
           board[axis_x][axis_y] = '.';
           o_len = 0; 
           x_len = 0;
           search_max_length();
           board[axis_x][axis_y] = 'x';
           if (o_len <= 4 && x_len <= 4)
           {
               cout<<"YES"<<endl;
               return 0;
           }
        }
        cout<<"NO"<<endl;
        return 0;
    }
}
```
另外，这道题强调了**输出需要换行**，不要忘了！

要不然爆零~

这篇题解就到此为止了。如果大家有不理解之处，**欢迎在下方留下评论，或是私信我**。

别忘了点个赞！

~~（感觉写了一篇小论文哈哈）~~

### 修改记录

$2020/5/3$ 发布题解

$2020/5/4$ 删去代码中不必要的空行（为分隔板块的空行仍保留）
   
   修改了描述不清的注释、在不容易理解的位置添加注释
   
$2020/5/8$ 对洛谷题解区格式改变而进行部分字词的修改
   
   增加主要思路部分的序号来清晰结构

---


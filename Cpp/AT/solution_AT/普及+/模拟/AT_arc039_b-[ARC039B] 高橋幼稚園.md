# [ARC039B] 高橋幼稚園

## 题目描述

高桥先生是一名幼儿园老师。他决定给N个孩子发放K个糖果，每个孩子得到的糖果数都为整数个。
在这里，定义孩子们的整体幸福度为所有孩子得到的糖果的数量之乘积。
高桥先生发糖果时想尽量提高孩子们的整体幸福度，请你设计方案达到目的，并输出整体幸福度最高时的方案个数。（答案可能很大，请输出答案%1000000007的结果）
此题中，孩子们之间有差别，而糖果之间视为无差别。
** 请注意有孩子未分到糖果时乘积为零的情况（详见样例三）**

## 说明/提示

### **数据范围**
- 有80%数据满足N<=K
### **样例说明1**
这四个孩子中有两个人分到2颗糖果，两个人分到3颗糖果时整体幸福度最大，最大值为2×2×3×3=36.
分配方式有(3,3,2,2),(3,2,3,2),(3,2,2,3),(2,3,3,2),(2,3,2,3),(2,2,3,3) 共6种.
### **样例说明2**
注意答案取模1000000007
### **样例说明3**
无论你如何分发糖果，整体幸福度都为0。

## 样例 #1

### 输入

```
4 10```

### 输出

```
6```

## 样例 #2

### 输入

```
100 450```

### 输出

```
538992043```

## 样例 #3

### 输入

```
5 2```

### 输出

```
15```

# 题解

## 作者：N_z_ (赞：2)

## 思路
有两种情况：
* $n>k$ 那么幸福度恒为$0$，求出有多少种分配方法即可。
* $n<=k$ 有幸福度，易知当$n\%k$个人分到$n/k+1$个，剩下的分到$n/k$个时取到幸福度最大，算一个组合数即可。

杨辉三角预处理组合数。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int C[601][501];
void init()
{
	for(int i=0;i<=600;i++)
	C[i][0]=1;
	for(int i=1;i<=600;i++)
	for(int j=1;j<=500;j++)
	C[i][j]=(C[i-1][j-1]+C[i-1][j])%1000000007;
}
signed main(){
	init();
	int n,k;
	cin>>n>>k;
	if(n>k)cout<<C[n+k-1][k]<<endl;
	else cout<<C[n][k%n]<<endl;
}
```

---

## 作者：cherubim (赞：1)

~~看见其他题解都不是很详细所以来写一发~~

Updata : 修改了格式及部分语义不够详尽的地方。

### 题目：AT1332 高橋幼稚園

读题。首先我们发现这题分为两种情况 $n>k$ 和 $n \le k$ 。

-  $n>k$ 时
即当糖果的数量小于小朋友的数量时，一定有小朋友分不到糖果，所以幸福度的乘积就一定 $0$ 。所以问题转化为了将 $k$ 随便分配给 $n$ 个小朋友的方案数。输出分配方案即相当于在 $n+k-1$ 个物体中选择k个出来，即  $\binom{n+k-1}{k}$  。



- $n \le k$ 时 
糖果的数量大于小朋友的数量，即每个小朋友都能分到一些糖果。根据**和相同，差越小积越大**的法则，分糖果的时候应该尽量使每个小朋友的糖果数量相同，即  $ n / k $ 个糖果。但因为糖果的数量不一定为小朋友数量的整数倍，所以我们可以把剩下的糖果再尽量平均分给每一个小朋友,即有 $ k \ mod  \ n $ 个小朋友分到 $n/k+1$ 个糖果，其他的小朋友得到 $ n / k $ 个糖果。方案数量用组合数表示则为$\binom{n}{n\ mod \ k}$ 。

那么最后用杨辉三角求组合数的递推式与处理一下，最后直接回答询问就可以了。

**请记得在输出时加换行符！**

### CODE
```cpp
#include <iostream>
using namespace std;
const int MOD = 1e9+7 ; 
int n , k ; 
long long c[1010][1010] ; 
inline void init ( ) { 
	for ( int i = 1 ; i <= 610 ; ++ i ) {
		c[i][0] = c[i][i] = 1 ; 
		for ( int j = 1 ; j < i ; ++ j ) 
			c[i][j] = ( c[i-1][j] + c[i-1][j-1] ) % MOD ; 
	}
	return ; 
}
int main() {
	init ( ) ; 
	scanf ( "%d %d" , &n , &k ) ; 
	if ( n > k ) printf ( "%lld\n" , c[n+k-1][k] ) ; 
	else printf ( "%lld\n" , c[n][k%n] ) ; 
	return 0;
}

```


---

## 作者：Otomachi_Una_ (赞：1)

观察题目后，给出两个结论：

1. 如果可以使得每个人都有的话，幸福度最大应遵从和一定差小积大。有 $k%n$ 人被分到 $k/n+1$ 个。

2. 如果不行，随便分，用插板法。

~~所以这题是小学题~~

考虑到这题要取模，建议使用杨辉三角求 $C_m^n$ ,然后就做完了。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<cmath>
using namespace std;
#define ll long long
const int MOD=1e9+7;
const int MAXN=6e2+5;
int c[MAXN][MAXN];
int n,k;
void init(){
	c[1][1]=1;
	for(int i=2;i<MAXN;i++)
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;
	return;
}//计算 C
int main(){
	init();
	cin>>n>>k;
	if(n<=k) cout<<c[n+1][k%n+1]<<endl;
	else cout<<c[k+n][k+1]<<endl;
	return 0;
}
```


---


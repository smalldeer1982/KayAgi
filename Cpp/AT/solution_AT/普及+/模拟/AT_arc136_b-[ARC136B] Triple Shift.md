# [ARC136B] Triple Shift

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc136/tasks/arc136_b

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ および $ B=(B_1,B_2,\cdots,B_N) $ が与えられます．

あなたは，以下の操作を好きな回数繰り返すことができます．

- 整数 $ i $ ($ 1\ \leq\ i\ \leq\ N-2 $) を選び，現在の $ A_i,A_{i+1},A_{i+2} $ の値をそれぞれ $ x,y,z $ とする． そして，$ A_i,A_{i+1},A_{i+2} $ の値をそれぞれ $ z,x,y $ で置き換える．

$ A $ を $ B $ に一致させることができるかどうか判定してください．

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 5000 $
- $ 1\ \leq\ A_i,B_i\ \leq\ 5000 $
- 入力される値はすべて整数

### Sample Explanation 1

以下のように操作すればよいです． - 最初，$ A=(3,1,4,5) $ である． - $ i=1 $ で操作を行う．$ A=(4,3,1,5) $ となる． - $ i=2 $ で操作を行う．$ A=(4,5,3,1) $ となる． - $ i=2 $ で操作を行う．$ A=(4,1,5,3) $ となる．

## 样例 #1

### 输入

```
4
3 1 4 5
4 1 5 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3
1 2 2
2 1 2```

### 输出

```
Yes```

## 样例 #3

### 输入

```
3
1 2 3
2 3 4```

### 输出

```
No```

# 题解

## 作者：ShenTianYi_ (赞：7)

# 第一部分：分析

### 题目大意

给出长度为 $n$ 的两个数组 $A,B$，你可以进任意多次操作，判断能否把数组 $A$ 变成数组 $B$。

一次操作定义为：选择一个 $i \in [1,n-2]$，将 $A_i, A_{i+1}, A_{i+2}$ 循环右移一位。
即，选择 $A$ 中一个左侧至少有两个元素的元素，将其左移两位。

### 题意分析

显然是一道思维结论题。

首先 $A,B$ 中元素（不考虑顺序）要相同，否则显然无解。以下默认 $A,B$ 中元素相同。

遇到移动/交换数组内元素的题，很自然想到考虑操作对数组中逆序对数的影响。

不妨设某一次操作选中 $A_i, A_{i+1}, A_{i+2}$，则数组 $A=\{A_1, A_2, \dots, A_{i-1}, A_i, A_{i+1}, A_{i+2}, A_{i+3}, \dots, A_{n-1}, A_n\}$ 变为 $A'=\{A_1, A_2, \dots, A_{i-1}, A_{i+2}, A_i, A_{i+1}, A_{i+3}, \dots, A_{n-1}, A_n\}$。**（暂时不考虑有重复元素的情况）**

显然，形如 $(A_p, A_q),\textrm{ 其中 }p \textrm{ 或 } q \in [1,i-1] \cup [i+3,n], p<q, A_p>A_q$ 的逆序对不受影响，只有在 $A_i, A_{i+1}, A_{i+2}$ 内部的逆序对有变化。

枚举：

$$ \text{逆序对数+=}\begin{cases}
2 &\text{when }A_i<A_{i+1}<A_{i+2}\\
0 &\text{when }A_i<A_{i+2}<A_{i+1}\\
2 &\text{when }A_{i+1}<A_i<A_{i+2}\\
-2 &\text{when }A_{i+1}<A_{i+2}<A_i\\
0 &\text{when }A_{i+2}<A_i<A_{i+1}\\
-2 &\text{when }A_{i+2}<A_{i+1}<A_i
\end{cases}
$$

可知执行操作不会改变数组 $A$ 内逆序对数的奇偶性。

已经证明 $A,B$ 内逆序对数奇偶性相同是数组 $A$ 可变为数组 $B$ 的必要条件，下面证明其充分性。

我们可以通过如下方法使 $A$ 变为逆序对数相同的 $B$：
- 找 $1 \leqslant p \leqslant n$ 使得 $A_p = B_n$；
- 若 $p=1$，则对 $A_1 \sim A_3$ 执行一次操作，$p$ 变为 $3$；
- 重复对 $A_{p-1} \sim A_{p+1}$ 执行操作，同时维护 $p$ 使 $A_p = B_n$，直到 $p=n$；
- 找 $1 \leqslant p \leqslant n-1$ 使得 $A_p = B_{n-1}$；
- 若 $p=1$，则对 $A_1 \sim A_3$ 执行一次操作，$p$ 变为 $3$；
- 重复对 $A_{p-1} \sim A_{p+1}$ 执行操作，同时维护 $p$ 使 $A_p = B_{n-1}$，直到 $p=n-1$；

$$\vdots$$

- 找 $1 \leqslant p \leqslant 3$ 使得 $A_p = B_3$；
- 若 $p=1$，则对 $A_1 \sim A_3$ 执行一次操作，$p$ 变为 $3$；
- 重复对 $A_{p-1} \sim A_{p+1}$ 执行操作，同时维护 $p$ 使 $A_p = B_3$，直到 $p=3$。

此时数组 $A$ 只有两种可能：$\{B_1,B_2,B_3,B_4,\dots,B_n\},\{B_2,B_1,B_3,B_4,\dots,B_n\}$。 
显然第二种可能由 $B$ 交换前两项得到，因此逆序对数奇偶性与 $B$ 不同。然而最初 $A$ 的逆序对数与 $B$ 相同，执行操作不改变数组逆序对数奇偶性，故此时 $A$ 数组不可能为第二种可能，只能是第一种可能。

观察，发现此时 $A=B$，任务完成。故 $A,B$ 内逆序对数奇偶性相同是数组 $A$ 可变为数组 $B$ 的充分必要条件。

---

考虑 $A$、$B$ 数组内有重复元素的情况。

举例：

$A=\{1,4,3,1,2,2,4,4\},B=\{1,1,2,2,3,4,4,4\}$

在 $A$ 中标记出重复元素，规定 $x'<x''<x'''<\dots$：

$A=\{1',4',3,1'',2',2'',4'',4'''\},B_1=\{1',1'',2',2'',3,4',4'',4'''\},B_2=\{1'',1',2',2'',3,4',4'',4'''\}$

显然，$B_1,B_2$ 由交换$1',1''$得到，因此 $B_1,B_2$ 内逆序对数奇偶性必然不同。由抽屉原理，$A$ 内逆序对数奇偶性必然与 $B_1,B_2$ 中一个相同。此时 $A,B_1,B_2$ 内都无重复元素，由上结论，$A$ 数组必可以变换到 $B_1,B_2$ 中的恰好一个。无论可以变换到 $B_1$ 还是 $B_2$，去掉标记后都算作任务完成。故若有重复元素则必有解，直接输出`Yes`即可。

# 第二部分：代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
int n,a[N],b[N],sa,sb,ta[N],tb[N];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		ta[a[i]]++;		//建桶储存a,b内元素出现次数
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		tb[b[i]]++;
	}
	for(int i=1;i<=5000;i++){	//若a,b内元素不同直接输出No
		if(ta[i]!=tb[i]){
			cout<<"No"<<endl;
			return 0;
		}
	}
	for(int i=1;i<=5000;i++){	//若有重复元素直接输出Yes
		if(tb[i]>1){
			cout<<"Yes"<<endl;
			return 0;
		}
	}
	for(int i=1;i<n;i++){		//数据小，O(n^2)暴力求逆序对数
		for(int j=i+1;j<=n;j++){
			sa+=int(a[i]>a[j]);
			sb+=int(b[i]>b[j]);
		}
	}
	cout<<((sa%2==sb%2)?"Yes":"No")<<endl;
					//逆序对数奇偶性相同即有解
	return 0;
}
```

- - -

#### 完结撒花！！！

---

## 作者：under_the_time (赞：1)

## 题意

> 给定两个长度为 $n$ 的数组 $a,b$，你可以操作 $0$ 次或若干次，每次选择一个 $i\in[1,n-2]$，记 $x=a_i,y=a_{i+1},z=a_{i+2}$，使得 $a_i=z,a_{i+1}=x,a_{i+2}=y$，求是否可以将 $a$ 变成 $b$。
>
> $3\le n\le 5000$，$1\le a_i,b_i\le 5000$。

## 解法

### 解法 1 - 逆序对

首先若存在一个 $v$ 使得 $a$ 中 $v$ 的出现次数不等于 $v$ 在 $b$ 中的出现次数，那么直接无解。我们考虑一次操作的影响，若元素没有重复出现，那么右移一次会增加 / 减少 $2$ 对逆序对或者不变，即逆序对的变化量总是偶数。那么若 $a$ 中逆序对数量与 $b$ 中逆序对数量奇偶性相同，那么就可以使得 $a$ 变成 $b$。再考虑 $a$ 或 $b$ 中出现相同元素的影响，对于一对相同的元素 $(a_i,a_j)$，其中 $i<j$；我们不妨给它们加上一个优先级，值相同时优先级更大的元素更大；那么若优先级给 $a_i$ 大一些，那么 $(a_i,a_j)$ 就是一对逆序对，反之则不是。这么操作可以自由决定最后 $a$ 的逆序对数量的奇偶性，即最终一定有解。貌似在有交换操作的题目中逆序对总是一个切入口。

### 解法 2 - 随机化

我做的时候不知道用逆序对和是否有元素相同判断，那怎么做呢？我们直接模拟将 $a$ 变成 $b$ 的过程，从大到小枚举 $i$ 使得 $a_i=b_i$，每一轮我们在 $[1,i]$ 中选出一个 $j$ 使得 $a_j=b_i$，然后用若干次右移操作把 $a_j$ 提到 $a_i$ 的位置；等到剩下 $3$ 个元素时，枚举可能的三种排列情况，判断是否与 $b$ 的前三个剩的元素相等即可。这个做法的问题在于在出现相同元素时，到底把谁拉上来。我们不妨**随机一个元素**拉上来，我的做法中优先选择了离 $i$ 近一些的元素。这么做正确率可能低，那么我们多做几轮，我做了 $15$ 轮就过了。正确率未知。

## 代码

这里放一下随机化的代码，因为方便没有使用 `mt19937`。

```cpp
// Problem: B - Triple Shift
// Contest: AtCoder - AtCoder Regular Contest 136
// URL: https://atcoder.jp/contests/arc136/tasks/arc136_b?lang=en
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// Good luck to the code >w<
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define open(x) freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout)
#define abs(x) (((x) > (0)) ? (x) : (-(x)))
#define print(x) printf("%d %d\n", x.first, x.second)
const int maxn = 5005;
int a[maxn], b[maxn], n;
int t1[maxn], t2[maxn];
int p[maxn];
int main() {
	scanf("%d", &n), srand(time(0));
	for (int i = 1; i <= n; i ++)
		scanf("%d", &a[i]), t1[a[i]] ++;
	for (int i = 1; i <= n; i ++)
		scanf("%d", &b[i]), t2[b[i]] ++;
	for (int i = 1; i <= 5000; i ++)
		if (t1[i] != t2[i]) return puts("No"), 0;
	for (int tt = 0; tt <= 15; tt ++) {
		for (int i = n, pos; i >= 3; i --) {
			pos = -1;
			for (int j = i; j; j --)
				if (a[j] == b[i]) {
					if (pos == -1) pos = j;
					else if (rand() % 3 == 2) pos = j;
				}
			for (; pos + 2 <= i; pos += 2) {
				int a0 = a[pos], a1 = a[pos + 1], a2 = a[pos + 2];
				a[pos] = a1, a[pos + 1] = a2, a[pos + 2] = a0;
			} if (pos != i) {
				int a0 = a[pos - 1], a1 = a[pos], a2 = a[pos + 1];
				a[pos - 1] = a2, a[pos] = a0, a[pos + 1] = a1;
			}
		}
		int a0 = a[1], a1 = a[2], a2 = a[3];
		if (a0 == b[1] && a1 == b[2] && a2 == b[3])
			return puts("Yes"), 0;
		else if (a2 == b[1] && a0 == b[2] && a1 == b[3])
			return puts("Yes"), 0;
		else if (a1 == b[1] && a2 == b[2] && a0 == b[3])
			return puts("Yes"), 0;
	} puts("No");
	return 0;
}
```

---

## 作者：DDF_ (赞：1)

## 题面

给定两个数组 $a$ 和 $b$，求能否经过若干次操作使得 $a$ 和 $b$ 相同。

操作：选择一个长度为 $3$ 的区间，将这段区间三个元素循环右移一位。

## 题解

结论题。

首先，如果 $a$ 中有元素没有在 $b$ 中出现，那么肯定无法操作使得 $a$ 与 $b$ 相同，先排除这种情况。

然后，发现题目中给的操作相当于将区间中最后一个数往前冒泡两位。

所以可以定义一个数组 $s$ 使得 $a_{i} = b_{s_{i}}$，那么此时对 $a$ 数组的循环右移操作相当于对 $s$ 数组的循环右移操作。

那么，现在要求的问题是，在 $s$ 中取一个数将其往前冒泡两位，问能否操作使得 $s$ 数组的状态为 $\{1,2,3,4,5,\cdots,n\}$。

冒泡排序中，冒泡的总次数是整个数组的逆序对数。

那么，在此题中，便可从“向前冒两位泡”进行思考。

对于一个数 $a_{x}$，向前冒泡一位，则有两种情况。

第一种情况是使得以 $x$ 结尾 $a_{x}$ 的逆序对数减少 $1$，且 $a_{x-1}$ 的逆序对数不变。

第二种情况是 $a_{x}$ 的逆序对数不变，$a_{x-1}$ 逆序对数增加 $1$。

所以向前冒两位泡后，总的逆序对数要么减 $2$，要么加 $2$，要么不变。

所以操作不会影响逆序对数奇偶性，那么就有 $s$ 中逆序对数必须为偶数。

那么接着往下思考，假设 $a$ 中有相同的数 $a_{i}$ 和 $a_{j}$，那么对于 $s_{i}$ 和 $s_{j}$ 每一个肯定都会有两种选择。

所以，对于 $s_{i}$ 和 $s_{j}$ 分别取不同的值，就可以使得整个数组的逆序对数加 $1$ 或不变，也就可以改变数组逆序对数的奇偶性。

所以，对于这种情况，就肯定可以成立。

综上所述，答案为 `Yes` 的结论：

1. $a$ 必须为 $b$ 的排列。
2. 数组中有相同的数出现，或者上文中 $s$ 数组逆序对为偶数。

进行几次特判，并用归并排序求逆序对即可。

总时间复杂度 $O(n \log(n))$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[5002],b[5002],f1[5002],f2[5002];
int p[5002],s[5002],f[5002],ans;
void mergesort(int l,int r) {
	if(l==r) return;
	int mid=(l+r)/2;
	mergesort(l,mid),mergesort(mid+1,r);
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r) {
		if(s[i]<=s[j]) f[k++]=s[i++];
		else f[k++]=s[j++],ans+=mid-i+1;
	}
	while(i<=mid) f[k++]=s[i++];
	while(j<=r) f[k++]=s[j++];
	for(int i=l;i<=r;i++) s[i]=f[i];
	return;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),f1[a[i]]++;
	for(int i=1;i<=n;i++) scanf("%d",&b[i]),f2[b[i]]++,p[b[i]]=i;
	for(int i=1;i<=5000;i++) if(f1[i]!=f2[i]) return puts("No"),0;
	for(int i=1;i<=5000;i++) if(f1[i]>1) return puts("Yes"),0;
	for(int i=1;i<=n;i++) s[i]=p[a[i]];
	mergesort(1,n);
	if(ans&1) puts("No");
	else puts("Yes");
	return 0;
}

---

## 作者：XYQ_102 (赞：0)

## 题意
给出序列 $A$ 和 $B$，能进行任意次以下操作：

将 $A_i,A_{i+1},A_{i+2}$ 中的 $A_{i+2}$ 移到最前面，变为 $A_{i+2},A_i,A_{i+1}$。

问能否通过这样的操作构成 $B$ 序列。
## 思路
对于每个 $B$ 中出现的数的次数肯定要与 $A$ 中出现的数的次数对应，用桶来存出现次数，如果不相等那一定不能转换为 $B$ 序列。

当 $A$ 中有相同数字的时候，会发现序列的顺序就不再固定了，所以必定可以转换为 $B$ 序列。

可以通过逐位模拟，找到我们要的数字，移到当前位来即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5010;
int a[N], b[N], ta[N], tb[N];
int main(){
	int n;
	cin >> n;
	for(int i = 1; i <= n; i ++) {
		cin >> a[i];
		ta[a[i]] ++;
	}
	for(int i = 1; i <= n; i ++) {
		cin >> b[i];
		tb[b[i]] ++;
	}
	bool flag = true;
	for(int i = 1; i <= 5000; i ++) {
		if(ta[i] != tb[i]) {
			flag = false;
			cout << "No" << endl;
			return 0;
		}
		if (ta[i] > 1) 
    	{
    		cout << "Yes\n";
     		return 0;
   		}
	}
	flag = false;
	int x = a[1], y = a[2], z = a[3];
	int cnt = 0;
	for(int i = 1; i <= n - 2; i ++) {
		x = a[i], y = a[i + 1], z = a[i + 2];
		cnt = 0;
		for(int j = i; j <= n; j ++) {
			if(a[j] == b[i]) {
				cnt = j;	
				break;
			}
		}
		while(cnt - i > 1) {
			swap(a[cnt], a[cnt - 2]);
			swap(a[cnt], a[cnt - 1]);
			cnt -= 2;
		}
		if(cnt - i == 1) {
			swap(a[cnt], a[cnt - 1]);
			swap(a[cnt], a[cnt + 1]);
		}
	}
 	if(a[n] == b[n] && a[n - 1] == b[n - 1]) {
 		cout << "Yes" << endl;
	 }
	 else cout << "No" << endl;
	 
	return 0;
}
```

---

## 作者：cosf (赞：0)

首先 $a$ 必须是 $b$ 的排列。

我们先考虑 $b$ 中的数两两不同的情况。那么我们可以构造一个排列 $p_i$，使得 $b_{p_{i}} = a_i$，则我们操作 $a_i$ 等价于在对应位置上操作 $p_i$。我们的最终目标是使 $p$ 变成 $\{1, 2, \dots, n\}$。

我们可以注意到，对 $p$ 操作一次后，$p$ 中逆序对（即 $i < j$ 但 $p_i \gt p_j$）的个数的奇偶性是不会变的，而目标的 $p$ 中有 $0$ 个逆序对，所以如果 $p$ 的逆序对个数是奇数，显然不行。

略证奇偶性不变。假设让 $p_i, p_{i + 1}, p_{i + 2}$ 变为 $p_{i + 2}, p_i, p_{i + 1}$。则若 $p_i \gt p_{i + 2}$，逆序对加上了两个，否则减去了两个。

那么对于 $p$ 的逆序对是偶数的情况，则一定可以把它变成 $\{1, 2, \dots, n\}$。我们可以不断右移让 $n, \dots, 4, 3$ 都依次移到对应的位置上，则 $1$ 必然在 $2$ 前面，否则逆序对个数为 $1$。

那么接下来考虑 $b$ 有相同的情况。那么这个时候，我们可以交换 $p$ 中的一些数。

考虑交换 $p_i$ 和 $p_j$（$p_i > p_j, i < j$，反之同理）的影响。假设 $i$ 到 $j$ 中有 $x$ 个大于 $p_i$ 的，$y$ 个在他们之间的，$z$ 个比 $p_j$ 小，则交换前 $i$ 到 $j$ 之间的逆序对有 $1 + x + 2y + z$，交换后就只有 $x+z$ 个了。差 $1 + 2y$ 是奇数，所以必定有一种情况 $p$ 的总逆序对数是偶数，所以此种情况一定可行。

总结一下：答案为 `Yes` 等价于

- $a$ 是 $b$ 的排列。
- $b$ 中有重复的数或者满足 $b_{p_i} = a_i$ 的 $p_i$ 有偶数个逆序对。

判断 $a$ 是不是 $b$ 的排列用数组即可。数逆序对也非常简单。

---

## 作者：jinhaoxian (赞：0)

# ARC136B

## 结论

结论一：如果任意数 $x$ 在数组 $A$ 和 $B$ 中出现次数不同，则必然无解。

证明：由于 $x$ 在数组 $A$ 中的出现次数**不会**随操作改变，因此无法使最终所有 $x$ 一一对应。

容易证明，任意数在 $A$ 和 $B$ 中出现次数相同，当且仅当数组排序后对应位完全相同。因此只需要对两数组分别排序后一一比较即可。由于该结论较为显然，以下若无特殊说明，则默认 $A$，$B$ 满足上述条件。

结论二：以下以 ${1,2,\ldots,n}$ 的排列 $p$ 表示对数组 $A$ 操作的结果（具体地，赋值 $a_i=i$，假设题目有解，则在相应操作后数组 $A$ 为 $p$）。则排列 $p$ 合法的充分必要条件为 $p$ 的逆序对（使 $A_i>A_j$ 的有序数对 $(i,j)$）数为偶数。

必要性证明：显然，数列 ${1,2,\ldots,n}$ 的逆序对数为 $0$，且由题意移位后，逆序对数变化为 $+2$，$0$ 或 $-2$（若 $(A_i,A_j)$ 之一未改变，则 $A_i,A_j$ 中原有元素仍满足前后与大小关系，该部分逆序对数不改变；对于改变的部分（即 $i,i+1,i+2$），枚举 $A_{i},A_{i+1},A_{i+2}$ 的 $3!$ 种大小关系即可证明），因此奇偶性不变。

充分性证明：对于 $i \le N-2$，$i \le j \le N$，总能在不改变 $A_1,A_2,\ldots,A_{i-1}$ 的同时将 $A_j$ 移动到第 $i$ 位：当 $j=N$，可以选择 $A_{N-2},A_{N-1},A_N$ 进行操作，将原 $A_N$ 前移 $2$ 位；否则选择 $A_{j-1},A_j,A_{j+1}$ 连续操作 $2$ 次，即可将 $A_j$ 前移 $1$ 位。由于任意交换两个位置的元素，逆序对数奇偶性改变，因此无论操作序列如何，可根据前 $N-2$ 位唯一确定此时 $A_{n-1},A_n$ 的值，当原序列 $A$ 与 $p$ 逆序对数奇偶性相同，则如上操作后必然满足 $A=p$。

## 解法

由此问题转化为构造排列 $p$ 使得：

1. $p$ 的逆序对数为偶数

2. 对于任意 $1 \le i \le N$，$A_{p_i}=B_i$

根据结论一，对于合法的 $A$，$B$，必然存在至少一个排列满足条件 $2$。

若存在 $A_i=A_j (i \neq j)$，则对于满足条件 $2$ 的排列 $p$ ，交换  $p_i$，$p_j$ 后得到的排列 $p'$ 仍然满足条件 $2$，且逆序对数奇偶性与 $p$ 必然不同，则必有其一符合条件 $1$，因此必定有解。

否则，满足条件 $2$ 的排列可以唯一确定，仅需以任意算法计算该排列的逆序对数即可判断是否满足条件 $1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5005],b[5005],c[5005],d[5005],sum[5005],invcnt;
int main() {
    cin>>n;
    for (int i=1;i<=n;i++) {
        cin>>a[i];
        c[i]=a[i];//此处为了不破坏原数组，需要另外赋值进行排序判定
    }
    for (int i=1;i<=n;i++) {
        cin>>b[i];
        d[i]=b[i];
    }
    sort(c+1,c+1+n);sort(d+1,d+1+n);
    for (int i=1;i<=n;i++) if (c[i]!=d[i]) {
        cout<<"No"<<endl;
        return 0;
    }//上述结论一
    for (int i=2;i<=n;i++) if (c[i]==c[i-1]) {
        cout<<"Yes"<<endl;
        return 0;
    }//判断a中是否存在相等元素
    for (int i=1;i<=n;i++) c[a[i]]=i;
    for (int i=1;i<=n;i++) b[i]=c[b[i]];//此处赋值后的b即为题解中的排列p
    invcnt=n*(n-1)/2;
    for (int i=1;i<=n;i++) {//计算p的逆序对数，此处采用树状数组
        int t=b[i]-1;
        while (t) {
            invcnt-=sum[t];
            t-=(t&(-t));
        }
        t=b[i];
        while (t<=5000) {
            sum[t]++;
            t+=(t&(-t));
        }
    }
    if (invcnt%2) cout<<"No"<<endl;
    else cout<<"Yes"<<endl;
    return 0;
}
```


---


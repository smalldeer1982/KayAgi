# 登山家

## 题目描述

高桥君是登山家，现在正在登山。
这个山脉上N个山中小屋向东西一条直线排列着，
各山小屋从西向东依次排列着，以1到N的号码排序。
第i的山中小屋建于海拔hi。
高桥君很在意从各小屋能看到几间山中小屋?
从第i个山中小屋可以看到第j个（山中小屋）的条件是，
##### 第j（山中小屋）的海拔全部为hi下（hj≤hi）。
求在各山中小屋可以看到的山中小屋的个数。
另外，从第i的山中小屋可以看到的山中小屋不包括第i个山中小屋。

## 样例 #1

### 输入

```
3
1
2
3```

### 输出

```
0
1
2```

## 样例 #2

### 输入

```
5
1
2
3
2
1```

### 输出

```
0
1
4
1
0```

## 样例 #3

### 输入

```
5
3
2
1
2
3```

### 输出

```
4
2
0
2
4```

## 样例 #4

### 输入

```
8
4
3
2
3
4
3
2
1```

### 输出

```
7
2
0
2
7
2
1
0```

# 题解

## 作者：Reserved_ (赞：1)

# 题目意思：
已知 $n$ 个数 $a_i$ 问第 $i$ 个点左右两边有几个比它小（包括等于）的数（不包括它本身），如果大于后面的就不算。
# 题目思路：
第一时间想到暴力枚举，但是因为 $n$ 过大，导致会超时，所以我们可以用单调栈进行优化。
- 当栈不为空且栈顶元素对应的数组 $a$ 中的值小于等于当前元素 $a_i$ 时，弹出栈顶元素。
- 将当前元素 $a_i$ 右边第一个比它大的元素的位置存储到 $r_i$ 中。
- 将当前元素的索引 $i$ 压入栈 $st$ 中。

左边同理，因为下面题解已经把思路讲的很清楚了，本蒟蒻在这就多不讲了。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,top,a[N],l[N],r[N],st[N];
int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1; i<=n; i++)
	{
		while(top&&a[st[top]]<=a[i])
		{
		    top--;
		}
		l[i]=st[top];
		st[++top]=i;
	}
	top=0;
	st[0]=n+1;
	for(int i=n; i>=1; i--)
	{
		while(top&&a[st[top]]<=a[i])
		{
			top--;
		}
		r[i]=st[top];
		st[++top]=i;
	}
	for(int i=1; i<=n; i++)
	{
		printf("%d\n",r[i]-l[i]-2);
	}
	return 0;
}
```

---

## 作者：XiaoQuQu (赞：1)

~~考试前一个小时还在写题解的屑~~

这个题目还是比较简单的。大意是有 $n$ 个数，问你第 $i$ 个数能比左右两边的数连续多几个。

可能这样子大家还是不是很理解，我画个图吧：

![1.png](https://i.loli.net/2021/07/17/aDZQsKF5bEoLCRq.png)   

就比如这张图，有五个数。

![1.png](https://i.loli.net/2021/07/17/Qu97Vr43oa1XqRS.png)

我们拿中间这个数举例（当然题目要求每个数都要求）.

![1.png](https://i.loli.net/2021/07/17/r594fsiYJu1lHgz.png)

问这个数的两边有多少**连续**个数比他少，注意是连续。比如说这个图答案就是1，因为只有右边第一个的数比他少。

但如果是这个图呢：

![1.png](https://i.loli.net/2021/07/17/4ZISJowLCjvV7Rk.png)

实际上还是 1，因为右边第二个数比他高，导致了右边第三个数不能被算上。

这样一来，就简单很多了。代码就不放了（~~同机房的人都说我马蜂丑~~）。

---

## 作者：gmb7291234 (赞：0)

#### 前置芝士 ST 表，二分（相信大家都会）。

## 题意
对于每个点求出左边和右边最远的点，使得中间所有点的权值的最大值小于这个点的权值。

## 思路

先想到中间所有点的权值的最大值可以用 ST 表求出。

接着因为答案具有单调性，也就是最大值随着区间的扩大不会变小，所以可以用二分。

最后输出每个点所得的答案即可 。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],f[21][100005],ff[100005];
int query(int l,int r){//ST表
	int u=ff[r-l+1];
	return max(f[u][l],f[u][r-(1<<u)+1]);
}
int main(){
	cin>>n;
	for(int i=2;i<=n;i++)ff[i]=ff[i/2]+1;
	for(int i=1;i<=n;i++)cin>>a[i],f[0][i]=a[i];
	for(int i=1;i<=ff[n];i++){
		for(int j=1;j+(1<<i)-1<=n;j++){
			f[i][j]=max(f[i-1][j],f[i-1][j+(1<<i-1)]);
		}
	}
	for(int i=1;i<=n;i++){
		int l=1,r=i;
		while(l<r){//二分
			int mid=l+r>>1;
			if(query(mid,i)<=a[i])r=mid;
			else l=mid+1;
		}
		int l1=i,r1=n;
		while(l1<r1){
			int mid=l1+r1+1>>1;
			if(query(i,mid)<=a[i])l1=mid;
			else r1=mid-1;
		}
		cout<<l1-l<<"\n";
	}
	return 0;
}
```

---

## 作者：Heldivis (赞：0)

## 登山家

单调栈。

先考虑向左看：从左向右扫描，维护一个栈储存编号，使越靠近栈顶的编号对应的高度越大，且比当前的**更高**。

那么每次栈顶的编号就是这个位置向左看第一个**不能看到**的位置。特别地，如果可以看到左边所有元素，那么这个位置向左看第一个**不能看到**的位置认为是 $0$。记录为 $l_i$。

```cpp
for (int i = 1; i <= n; ++i) {
  while (s.size() && a[s.back()] <= a[i]) s.pop_back();
  if (s.size()) l[i] = s.back();
  else          l[i] = 0;
  s.push_back(i);
}
```

然后处理向右看的部分，同理可以得到 $r_i$。

这样位置 $i$ 能看到 $l_i + 1 \sim r_ i - 1$ 的位置，减去自己，就是 $r_i-l_i-2$。

[完整代码](https://atcoder.jp/contests/code-festival-2014-qualb/submissions/61624909)。

---


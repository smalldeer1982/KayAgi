# Interpretation

## 题目描述

用 $1$ 到 $m$ 这 $m$ 个正整数为 $m$ 种语言编号。现在有 $n$ 个人，他们的编号依次为 $1,2,...,n$。第 $i$ 个人会说这 $m$ 种语言中的 $k_i$ 种，它们的编号分别为 $l_{i,1},l_{i,2},...,l_{i,k_i}$。

现在，如果说编号 $a$ 和编号 $b$ 的两个人是“可以交流的”，当且仅当两人存在以下两种模式中的至少一种：

- 当 $a$ 和 $b$ 可以直接交流时，满足：存在至少一种语言，$a$ 和 $b$ 都会。
- 当 $a$ 和 $b$ 可以间接交流时，满足：存在一个人 $x$，他（她）可以分别与 $a$ 和 $b$ 直接交流。

请问：每个人是否都能和其他人中的任意一个直接或间接地交流？

## 说明/提示

#### 输入输出样例 #1 说明

（为了简便，每个人直接用其编号代替，样例 $ \#2 $ 解释同）

任意两个人都可以交流，如下：

- $1$ 和 $2$ 都会说语言 $2$；
- $2$ 和 $3$ 都会说语言 $4$；
- $1$ 和 $3$ 可以通过 $2$ 间接交流；
- $3$ 和 $4$ 都会说语言 $6$；
- $2$ 和 $4$ 可以通过 $3$ 间接交流；
- $1$ 和 $4$ 可以通过 $2$ 间接交流。（这里请注意，$1$ 和 $4$ 是通过 $1-2-3-4$ 的链条来间接交流的）

#### 输入输出样例 #2 说明

例如，$1$ 和 $3$ 不能交流。

#### 数据规模与约定

所有输入数据保证：

- $2 \le n \le 10^5$，$1 \le m \le 10^5$，$1 \le k_i \le m$，且所有 $k_i$ 之和 $\le 10^5$；
- $1 \le l_{i,j} \le m$，且对于同一个 $i$ 来说，$l_{i,j}$ 互不相同。

## 样例 #1

### 输入

```
4 6
3 1 2 3
2 4 2
2 4 6
1 6```

### 输出

```
YES```

## 样例 #2

### 输入

```
4 4
2 1 2
2 1 2
1 3
2 4 3```

### 输出

```
NO```

# 题解

## 作者：Leaper_lyc (赞：1)

并查集板子。

将每个人从 $1$ 到 $n$ 编号，把每种语言从 $n+1$ 到 $n + m$ 编号。

规定两个人 $x$ 和 $y$ 能够直接或间接交流，则 $x$ 和 $y$ 在同一个集合。

我们考虑将每个人所在集合和他所会的语言所在集合合并为一个集合。然后判断每个人是否都在一个集合就行了。

对于直接交流：会相同语言的人一定在同一个以某种语言为根的集合。

对于间接交流：某人 $x$ 可能同时属于不同集合，假设 $x\in A$ 且 $x\in B$，集合 $A$ 和集合 $B$ 中的人可以通过 $x$ 间接沟通。也就是说集合 $A$ 和集合 $B$ 通过 $x$ 并为一个集合，意味着间接交流的两个人也在同一个集合。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 2e5 + 10;
int n, m, k, l;
int fa[_];
inline int find(int x) {
	if (x == fa[x]) return x;
	return fa[x] = find(fa[x]);
}
signed main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n + m; i++) fa[i] = i;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &k);
		for (int j = 1; j <= k; j++) {
			scanf("%d", &l);
			fa[find(i)] = find(l + n);
		}
	}
	for (int i = 1; i <= n; i++)
		if (find(i) != find(1)) return puts("NO"), 0;
	puts("YES");
}
```

---

## 作者：Kvaratskhelia (赞：0)

### 题目大意

有 $N$ 个人会 $M$ 种语言，第 $i$ 个人会 $k_i$ 种语言，这 $k_i$ 种语言的编号 为 $l_{i,1}$ 至 $l_{i,k}$ 。

当两个人都能说一种语言并且存在另一个人使得两个人都可以和他通信时，这两个人可以相互通信，求这 $N$ 个人能否相互通信。若能，输出 ```YES``` ，否则输出 ```NO``` 。

### 解题

首先，要了解并查集是什么玩意。

> 并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。——百度百科

这里简单给一下代码。

初始化：每个人就是自己的根节点

```cpp
for(int i=1;i<=n+m;i++) f[i]=i;
```

合并：合并两个集合

```cpp
f[find(x)]=find(y);
```

查找：查找节点的根节点

```cpp
int find(int x)
{
    if(x==f[x]) return x; //是自己的父亲
    else return f[x]=find(f[x]); //不断递归往下找
}
```

（这里 $f_x$ 表示 $x$ 节点的根节点）

------------

那么对于这道题，我们就可以把所有说同一种语言的人合并到一个集合里，因此，对于第 $i$ 个人说的每一种语言，都有合并操作：

```cpp
f[find(i)]=find(l+n); //l+n 是为了防止 l=i 的情况
```

又因为，一个集合中所有节点的根节点都是一样的，所以到最后，如果节点 $1$ 的根节点和任意节点 $i$ 的根节点不同，就是有人没连上，说明这个人就不能和别人通信，输出 ```NO``` 。否则循环结束后输出 ```YES``` 。

Code ：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[2333333],k,l;
int find(int x)
{
    if(x==f[x]) return x;
    else return f[x]=find(f[x]);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n+m;i++) f[i]=i;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&k);
        for(int j=1;j<=k;j++)
        {
            scanf("%d",&l);
            f[find(i)]=find(l+n);
        }
    }
    for(int i=1;i<=n;i++)
        if(find(1)!=find(i)) {cout<<"NO"<<endl;return 0;}
    cout<<"YES"<<endl;
    return 0;
}

```



---


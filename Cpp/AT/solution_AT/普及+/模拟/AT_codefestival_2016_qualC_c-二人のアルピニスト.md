# 二人のアルピニスト

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_c

アルピニストである高橋君と青木君は最近ある有名な山脈を踏破しました。この山脈は$ N $ 個の山からなっており、西から東に向けて山$ 1 $,山$ 2 $,$ ... $,山$ N $と一直線に並んでいます。高橋君は西から、青木君は東からこの山脈を踏破しました。

山$ i $ の高さは$ h_i $ ですが、二人とも各$ h_i $ の値は忘れてしまいました。その代わり、各$ i\ (1≦i≦N) $ に対して、山$ i $ の山頂にたどり着いた時の、それまでに登った山(山$ i $ も含む)の高さの最大値を記録しています。 高橋君の記録した値は$ T_i $ で、青木君の記録した値は$ A_i $ です。

各山の高さ$ h_i $ が正の整数であることはわかっています。山の高さの列としてありうるものが何通りあるかを$ 10^9+7 $ で割ったあまりを求めてください。

ただし記録が間違っていてありうる山の高さの列が存在しないこともあります。この場合は$ 0 $を出力してください。

## 说明/提示

### 制約

- $ 1≦N≦10^5 $
- $ 1≦T_i≦10^9 $
- $ 1≦A_i≦10^9 $
- $ T_i≦T_{i+1}\ (1≦i≦N-1) $
- $ A_i≧A_{i+1}\ (1≦i≦N-1) $

### Sample Explanation 1

山の高さの列として、 - $ 1,3,2,2,2 $ - $ 1,3,2,1,2 $ - $ 1,3,1,2,2 $ - $ 1,3,1,1,2 $ の$ 4 $通りがありえます。

### Sample Explanation 2

高橋君によると山を全て登り切った後の山の高さの最大値は$ 2 $で、青木君によると$ 3 $なので、記録は矛盾しています。

### Sample Explanation 3

$ 10^9+7 $ で割ったあまりを求めることを忘れないようにしてください。

### Sample Explanation 4

山が一つの山脈もあります。

## 样例 #1

### 输入

```
5
1 3 3 3 3
3 3 2 2 2```

### 输出

```
4```

## 样例 #2

### 输入

```
5
1 1 1 2 2
3 2 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
10
1 3776 3776 8848 8848 8848 8848 8848 8848 8848
8848 8848 8848 8848 8848 8848 8848 8848 3776 5```

### 输出

```
884111967```

## 样例 #4

### 输入

```
1
17
17```

### 输出

```
1```

# 题解

## 作者：lky1433223 (赞：0)

没想到C题完全没有题解了2333
# [推销博客](https://www.cnblogs.com/Shiina-Rikka/p/11769551.html)

这题主要是发现一个特性就可以，难度并不大
很显然我们可以发现一个性质，如果$T_i$与$T_{i+1}$不同，第$i + 1$个山的高度是已知的（$A$同理）。于是我们可以推断出所有已知的山高，而其余未知的地方，山的高度$h_i$可能是$\forall h_i \in [1, \min(T_i,A_i)]$,答案直接乘上就可以了。
```cpp
const int MAXN = 1e5 + 10;
const int MOD = 1e9 + 7;
int n;
int T[MAXN], A[MAXN];
int  h[MAXN];
signed main()
{
	poread(n);
	for(register int i = 1; i <= n; ++i)
		poread(T[i]);
	for(register int i = 1; i <= n; ++i)
		poread(A[i]);
	for(register int i = 1; i <= n; ++i)
		if(T[i] != T[i - 1])
			h[i] = T[i];
	for(register int i = n; i >= 1; --i)
		if(A[i] != A[i + 1])
			h[i] = A[i];
	for(register int i = 1, mx = 0; i <= n; ++i)
	{
		mx = max(h[i], mx);
		if(mx != T[i])
		{
			puts("0");
			return 0;
		}
	}
	for(register int i = n, mx = 0; i >= 1; --i)
	{
		mx = max(h[i], mx);
		if(mx != A[i])
		{
			puts("0");
			return 0;
		}
	}
	int ans = 1;
	for(register int i = 1; i <= n; ++i)
	{
		if(!h[i])
		{
			ans = (long long) ans * min(A[i],T[i]) % MOD;
		}
	}
	cerr << ans << endl;
	cout << ans << endl;
}
```

---


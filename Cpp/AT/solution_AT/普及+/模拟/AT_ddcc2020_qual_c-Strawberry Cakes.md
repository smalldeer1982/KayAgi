# Strawberry Cakes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_c

chokudai さんは，DDCC 2020 本戦で参加者に配る長方形のケーキを用意しました．

このケーキは，$ H\ -\ 1 $ 本の横方向の切れ目と $ W\ -\ 1 $ 本の縦方向の切れ目により，$ H\ \times\ W $ 個の区画に等分されています．これらの区画のうち $ K $ 個には，それぞれイチゴが $ 1 $ 個乗っています．

イチゴの位置は，$ H\ \times\ W $ 個の文字 $ s_{i,\ j} $ $ (1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W) $ によって与えられます．$ s_{i,\ j} $ が `#` のとき，上から $ i $ 行目，左から $ j $ 列目の区画にイチゴが乗っており，$ s_{i,\ j} $ が `.` のとき乗っていません．`#` はちょうど $ K $ 個出現します．

さて，chokudai さんはこのケーキを切れ目に沿って $ K $ 個のピースに切り分け，参加者に配布したいです．ただし，すべてのピースは以下の条件を満たさなければなりません．

- 形状は長方形である．
- ちょうど $ 1 $ 個のイチゴを含む．

例えば，次のような例が考えられます．

![ ](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_ddcc2020_qual_c/cc1d9c887e66319321dc6aab838f872b37b7268e.png)

条件を満たすケーキの切り分け方を $ 1 $ つ求めてください．このような切り分け方は，イチゴの個数や位置にかかわらず必ず存在することが示せます．

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 300 $
- $ 1\ \leq\ W\ \leq\ 300 $
- $ 1\ \leq\ K\ \leq\ H\ \times\ W $
- $ s_{i,\ j} $ は `#` または `.`
- `#` は $ s $ にちょうど $ K $ 個出現する

### Sample Explanation 1

例えば，下の図の方法で切り分けることができます． !\[ \](https://img.atcoder.jp/ddcc2020-qual/d09e88243931000a04e555892fe7e6c9.png)

### Sample Explanation 2

例えば，下の図の方法で切り分けることができます． !\[ \](https://img.atcoder.jp/ddcc2020-qual/18d0f45847f5d107ac0322aecea39835.png)

## 样例 #1

### 输入

```
3 3 5
#.#
.#.
#.#```

### 输出

```
1 2 2
1 3 4
5 5 4```

## 样例 #2

### 输入

```
3 7 7
#...#.#
..#...#
.#..#..```

### 输出

```
1 1 2 2 3 4 4
6 6 2 2 3 5 5
6 6 7 7 7 7 7```

## 样例 #3

### 输入

```
13 21 106
.....................
.####.####.####.####.
..#.#..#.#.#....#....
..#.#..#.#.#....#....
..#.#..#.#.#....#....
.####.####.####.####.
.....................
.####.####.####.####.
....#.#..#....#.#..#.
.####.#..#.####.#..#.
.#....#..#.#....#..#.
.####.####.####.####.
.....................```

### 输出

```
12 12 23 34 45 45 60 71 82 93 93 2 13 24 35 35 17 28 39 50 50
12 12 23 34 45 45 60 71 82 93 93 2 13 24 35 35 17 28 39 50 50
12 12 56 89 89 89 60 104 82 31 31 46 13 24 35 35 61 61 39 50 50
12 12 67 67 100 100 60 9 9 42 42 57 13 24 6 72 72 72 72 72 72
12 12 78 5 5 5 20 20 20 53 68 68 90 24 6 83 83 83 83 83 83
16 16 27 38 49 49 64 75 86 97 79 79 90 101 6 94 94 105 10 21 21
16 16 27 38 49 49 64 75 86 97 79 79 90 101 6 94 94 105 10 21 21
32 32 43 54 65 65 80 11 106 95 22 22 33 44 55 55 70 1 96 85 85
32 32 43 54 76 76 91 11 106 84 84 4 99 66 66 66 81 1 96 74 74
14 14 3 98 87 87 102 11 73 73 73 4 99 88 77 77 92 92 63 63 63
25 25 3 98 87 87 7 29 62 62 62 15 99 88 77 77 103 19 30 52 52
36 36 47 58 69 69 18 29 40 51 51 26 37 48 59 59 8 19 30 41 41
36 36 47 58 69 69 18 29 40 51 51 26 37 48 59 59 8 19 30 41 41```

# 题解

## 作者：Kazeno_Akina (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/AT_ddcc2020_qual_c)

题目大意：给你一个 $h \times w$ 的网格，其中有 $k$ 个格子有标记。让你把这个网格分成 $k$ 个长方形，要求每个长方形中都恰有一个标记。

观察题面样例解释发现题目上给的这种分割方法真的很不通用（几乎找不出任何规律），于是考虑有没有通用的方法。

一时找不出什么关于 $h \times w$ 方格的思路，于是考虑简化情况：$1 \times w$ 的网格。

显然这是非常可做的。对于每一个有标记的格子各赋上一种不同颜色，然后对于第 $i$ 个有标记的格到第 $i+1$ 个有标记的格，中间没标记的格子都按照 $i$ 号格子涂色；特别的，第 $k$ 个有标记的格子之后按照第 $k$ 个有标记的格子涂色，第 $1$ 个有标记的格子之前按照第 $1$ 个有标记的格子涂色。

考虑如何扩展到一般的情况。~~经过人类智慧~~我们发现行总共分两种：其中存在有标记的格子或者不存在。

对于存在标记格子的行，不妨将它化成 $1 \times w$ 的格子直接按照上述方式做。

而对于所有格子都没有标记的行，情况则更加平凡：因为随便怎么分只要分到一个有标记的组就好了。不妨将这一行的涂色方式与它上方离它最近的有标记行统一，这很可行。特别的，对于第一行有标记的格子上方的行，将它们的涂色方式和第一行有标记的格子统一即可。

这样做显然是只会分成 $k$ 块的，因为对于每一个有标记行，其对块总数的贡献为这一行中有标记格子的数量，无标记行贡献则为 $0$；而每一块也必然是长方形，因为每一种颜色对应的色块都是若干行与某一行统一而成。

细节有亿点点多。见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=305;
int h,w,k,tot,ans[N][N];
bool flag;
char init;
bitset<N> mp[N];
vector<int> row;
int main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  cin >> h >> w >> k;
  if(k==0){ //如果没有标记直接输出，不然中间可能会有奇奇怪怪的错误
    for(int i=1;i<=h;++i){
      for(int j=1;j<=w;++j) cout << "1 ";
      cout << '\n';
    }
    return 0;
  }
  for(int i=1;i<=h;++i){
    flag=0;
    for(int j=1;j<=w;++j){
      cin >> init;
      if(init=='#') mp[i][j]=1,flag=1;
    }
    if(flag) row.push_back(i); //在row里记录所有有标记的行，最后为了避免可能的越界而把h+1作为一行放进去
  }
  row.push_back(h+1);
  for(int i=0,j;i<row.size()-1;++i){ //对每一个有标记的行分开处理
    ++tot;
    for(j=1;j<=w;++j){
      ans[row[i]][j]=tot;
      if(mp[row[i]][j]) break;
    }
    if(j==w) continue;
    for(++j;j<=w;++j){
      if(mp[row[i]][j]) ++tot;
      ans[row[i]][j]=tot;
    }
  }
  for(int i=1;i<row[0];++i) for(int j=1;j<=w;++j) ans[i][j]=ans[row[0]][j];
  for(int i=0;i<row.size()-1;++i) for(int i1=row[i]+1;i1<row[i+1];++i1) for(int j=1;j<=w;++j) ans[i1][j]=ans[row[i]][j]; //和有标记的行统一涂色方式
  for(int i=1;i<=h;++i){
    for(int j=1;j<=w;++j) cout << ans[i][j] << ' ';
    cout << '\n';
  }
  return 0;
}
```

完结撒花~qwq

---

## 作者：eEfiuys (赞：2)

题目：[AT5667](https://www.luogu.com.cn/problem/AT5667)
### 思路：
1. 第 $i$ 行有草莓：
	- **首先改变颜色**，因为第 $i$ 行开头和第 $i-1$ 行末尾构不成长方形；
	- 第 $j$ 格有草莓，就改变颜色。
2. 第 $i$ 行没有草莓（数量为 $0$）：
	- **颜色与第 $i-1$ 行的颜色相同**。
3. **特判：第 $1$ 行没有草莓**：
	- 对**第 $1$ 个有草莓的行**（设为第 $j$ 行）进行操作 $1$；
    - 从第 $1$ 行到第 $j-1$ 行，**每一行的颜色都与第 $j$ 行的颜色相同**；
    - **从第 $j+1$ 行开始**进行操作 $1$ 或 $2$。

------------

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int h,w,k,num;
char ch;
bool s[301][301]; //每格是否有草莓。
int t[301]/*每行草莓个数*/,x/*当前行已处理草莓个数*/,a[301][301]/*颜色*/;
int main()
{
	cin>>h>>w>>k;
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++)
		{
			cin>>ch;
			if(ch=='#')
			{
				s[i][j]=1;
				t[i]++;
			}				
		}
	for(int i=1;i<=h;i++)
	{
		x=0; //当前行还没有处理草莓。
		if(i==1&&!t[i]) //特判。
		{
			for(int j=2;j<=h;j++)
				if(t[j]) //第1个有草莓的行。
				{
					num++; //首先改变颜色。
					for(int p=1;p<=w;p++) //对第j行进行操作1.
					{
						a[j][p]=num;
						if(s[j][p])
						{
							x++;
							if(x<t[j]) //后面还有草莓，不判断则最后一个草莓后面的空格都是另一种颜色。
								num++; //改变颜色。
						}
					}
					for(int p=1;p<j;p++)
						for(int q=1;q<=w;q++)
							a[p][q]=a[j][q]; //颜色与第j行相同。
					i=j; //因为还要i++，所以把i改为j即可。
					break;
				}
		}
		else
			if(!t[i]) //没有草莓。
				for(int j=1;j<=w;j++)
					a[i][j]=a[i-1][j]; //颜色与第j行相同。
			else
			{
				num++; //首先改变颜色。
				for(int j=1;j<=w;j++)
				{
					a[i][j]=num;
					if(s[i][j])
					{
						x++;
						if(x<t[i])  //后面还有草莓，不判断则最后一个草莓后面的空格都是另一种颜色。
							num++;
					}
				}
			}				
	}
	for(int i=1;i<=h;i++)
	{
		for(int j=1;j<=w;j++)
			cout<<a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：小小小朋友 (赞：1)

### 思路

很有趣的一道题目~虽然是个绿题但想起来并不难

如果蛋糕只有一行，那么就很简单了。

于是考虑先按行分，再按列分

先把方格按行分为许多组，使得每组中只有一行是有草莓的，其余组都是空的，这样就可以把每组都当成只有一行草莓去做就行了。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5nak60kb.png)

### 代码

这里是[官方题解](https://atcoder.jp/contests/ddcc2020-qual/editorial)的代码，稍加改动并加上了注释方便理解，注释仅供参考

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int H, W, K, A[309][309], num=0;
int cnt[309];
char c[309][309];
void solve(int cl, int cr) {
    vector<int> P;
    for (int i = cl; i <= cr; i++) {//此处在每排找是有时最后一行或第一行也是空行，必须全部搜一遍
        for (int j = 1; j <= W; j++) {
            if (c[i][j] == '#') P.push_back(j);
        }
    }
    for (int i = 0; i < P.size(); i++) {
        int v1 = 1, v2 = W;
        if (i >= 1) v1 = P[i - 1] + 1;//特判开头为空
        if (i < (int)P.size() - 1) v2 = P[i];//特判末尾为空
        num++;//下一组
        for (int j = cl; j <= cr; j++) {
            for (int k = v1; k <= v2; k++) A[j][k] = num;
        }
    }
}
int main() {
    cin >> H >> W >> K;
    for (int i = 1; i <= H; i++) {
        for (int j = 1; j <= W; j++) {
            cin >> c[i][j];
            if (c[i][j] == '#') cnt[i]++;//记录每行的草莓数
        }
    }
    vector<int> vec;
    for (int i = 1; i <= H; i++) { 
        if (cnt[i] >= 1)
            vec.push_back(i); //将草莓数不为0的一行放进vector
    }
    for (int i = 0; i < vec.size(); i++) {
        int v1 = 1, v2 = H;
        if (i >= 1) v1 = vec[i - 1] + 1;//特判开头几行为空
        if (i < (int)vec.size() - 1) v2 = vec[i];//特判末尾几行为空
        solve(v1, v2);
    }
    for (int i = 1; i <= H; i++) {
        for (int j = 1; j <= W; j++) {
            if (j >= 2) cout << " "; cout << A[i][j];
        }
        cout << endl;
    }
    return 0;
}
```

---


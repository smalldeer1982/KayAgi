# Digit Sum Replace

## 题目描述

[problemUrl]: https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_d

DDCC 20XX の予選には，$ N $ 人のプログラマーが参加する予定です．しかし，会場の都合上，本戦には $ 9 $ 人までしか参加できません．

そこで，予選を何ラウンドかに分けて勝ち抜き方式で行うことにしました．これは，以下のルールに従って行われます．

- 最初のラウンドには $ N $ 人全員が参加する．
- あるラウンドに $ X\ (X\ \geq\ 10) $ 人が参加するとき，次のラウンドに勝ち残る人数を以下のように決定する．
  - $ X $ の十進表記において，ある連続する $ 2 $ 桁を選び，それらをその和で置き換えて得られる数を勝ち残る人数とする．  
       例えば，$ X\ =\ 2378 $ のとき，勝ち残る人数は $ 578 $ ($ 2,3 $ を選んだ場合)，$ 2108 $ ($ 3,7 $ を選んだ場合)，$ 2315 $ ($ 7,8 $ を選んだ場合) 人のいずれかとなる．  
       $ X\ =\ 100 $ のときは，どちらの $ 2 $ 桁を選んだとしても勝ち残る人数は $ 10 $ 人となる．
- 勝ち残った人数が $ 9 $ 人以下となったら，予選を終了する．

DDCC 20XX の運営リーダーであるりんごさんは，できるだけ多くの予選ラウンドを開催したいです．  
 最大で何ラウンドの予選を開催できるか求めてください．

ただし，参加者数 $ N $ は非常に多くなる場合があるので，$ 2 $ つの整数列 $ d_1,\ \ldots,\ d_M $，$ c_1,\ \ldots,\ c_M $ として与えられます．  
 これは，$ N $ が十進表記において $ c_1\ +\ c_2\ +\ \ldots\ +\ c_M $ 桁の数であり，その先頭の $ c_1 $ 桁の数字がいずれも $ d_1 $，続く $ c_2 $ 桁の数字がいずれも $ d_2 $，$ \ldots $，最後の $ c_M $ 桁の数字がいずれも $ d_M $ であることを表します．

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ 200000 $
- $ 0\ \leq\ d_i\ \leq\ 9 $
- $ d_1\ \neq\ 0 $
- $ d_i\ \neq\ d_{i+1} $
- $ c_i\ \geq\ 1 $
- $ 2\ \leq\ c_1\ +\ \ldots\ +\ c_M\ \leq\ 10^{15} $

### Sample Explanation 1

この場合，予選の最初のラウンドには $ N=229 $ 人が参加します．大会の経過の一例として、次のパターンがありえます． - ラウンド $ 1 $ に $ 229 $ 人が参加し，ラウンド $ 2 $ に $ 49 $ 人が参加し，ラウンド $ 3 $ に $ 13 $ 人が参加し，本戦に $ 4 $ 人が進出する． このとき，予選は $ 3 $ ラウンド行われ、これが実は最適であることが分かります。

### Sample Explanation 2

この場合，最初のラウンドには $ 1000000007 $ 人が参加します．

## 样例 #1

### 输入

```
2
2 2
9 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3
1 1
0 8
7 1```

### 输出

```
9```

# 题解

## 作者：GFyyx (赞：3)

## 一道很水的思维题
遇到奆的单个数据 $N \leq 10^{15}$，考虑推理结论。

## 结论推理
不难发现，虽然 $N$ 整体很难操作，我们可以从题目给定的对 $N$ 的拆分下手。

显然的，每次操作进位会让 $N$ 的数字和减 9 或不进位让 $N$ 的位数减 1。

要使得其数字和变为个位数，次数是能算出来的 $(\sum\limits_{i=1}^m c_i \times d_i-1)\div9-1$。

同理，让 $N$ 变为个位数的操作次数也能算的 $\sum\limits_{i=1}^m c_i-1$。

他们的和即为所求。不说了，看代码。

## AC 代码
```cpp
#include <iostream>
using namespace std;
long long m,c,d,x,y;
int main(){cin>>m;while(m--)cin>>d>>c,x+=c*d,y+=c;cout<<y+((x-1)/9)-1;}
//结论在此，代码不长，请勿抄袭
```

---

## 作者：52luogu (赞：1)

## 题目描述
### 分析
将一个数 $N$ 的相邻位不断合并，求出可以合并的次数。
### 提示
题目中超大的取值范围已经告诉了我们这是一道有规律的思维题。
## 顺推思路
我们可以从 $N$ 的拆分入手，不难发现规律就是每当 $N$ 一次合并要么让 $N$ 的位数减 1（不进位），要么让 $N$ 的数字和减 9（即进位）。
## 解法
只需要记录位数，以及数字和即可，具体解法见代码注释。
## 代码和注释
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mn=1e6+5;
long long sum,wei,ans; 
int main(){
	ios::sync_with_stdio(0);//让代码更快 
	cin.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		long long x,y;//di和ci 
		cin>>x>>y;
		wei+=y;//记录位数 
		sum+=x*y;//记录数字和 
	}
	cout<<wei-1+((sum-1)/9);//因为要留最后的个位所以将位数-1...sum-1是因为放止n为9的倍数导致最后剩下0 
	return 0;
}
//蒟蒻的第一篇题解
```

 


---

## 作者：orpg (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/AT_ddcc2020_qual_d)
### 题目描述
给你一个数，每一次操作，可以将相邻的两位合并。

举个栗子：945，如果我们选择合并 4 和 5，那么就会变成 99，如果选择 9 和 4 合并那么就会变成 135。

题目问我们一共可以做多少次操作，使得这个数可以变成一位数。
### 题目分析
不难发现，如果进位了，即 945 变成 135。数字和就从 18 变成 9。

如果没进位，那数就会缩小一位。

记数字和为 $tot$，数字位数为 $num$。则最多的操作次数就是 $(sum-1)/9+(num-1)$。
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll m,d,c;
ll tot,num;
main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>d>>c;
		num+=c;
		tot+=c*d;
	}
	cout<<((tot-1)/9)+num-1<<'\n';
	return 0;
}
```

---

## 作者：迟暮天复明 (赞：1)

[题面](https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_d)

[没说更佳的阅读体验](https://www.cnblogs.com/1358id/p/16088602.html)

题意：
给你一个数，他的前 $d_1$ 位都是 $c_1$ ，接下来 $d_2$ 位是 $c_2$ ，以此类推。每一次操作，你可以选两个相邻的数码，将它们相加以后放回去。问多少次操作以后这个数会变成 $1$ 。 $\Sigma d_i\leq10^{15}$ 。

-----
举个例子。 $2378$ 可以变成 $2108$ 或 $578$ 。可以发现，第一种变化方法，他的数字总和恰好减小了 $9$ ，而第二种方法，他的数位个数减小了 $1$ 。

我们的目标是让他数字总和小于 $9$ 且只剩一位数，那么我们操作的次数可以计算出是唯一的。

算出数字和减到一位数的操作次数是 $(sum-1)\div 9$ ，数字位数剩最后一位的操作次数为 $num-1$ ，两者相加就是你要的答案。

```cpp
int m, num, sum, d, c;

signed main() {
 
  read(m);
  rep(i, 0, m) {
    read(c), read(d);
    num += d;
    sum += d * c;
  }
  print(num + ((sum - 1) / 9) - 1);

  return 0;
}
```

---

## 作者：0x00AC3375 (赞：0)

## 题意
有一个数字 $N$，每次操作会选择这个数相邻两个数位的数字，将其删除并在原先的位置插入两个数字的和，直到这个数字只剩下一位为止，求最多能执行多少次操作。

## 分析
题目中的最多一词很**容易让人以为这是一道求最优解问题**（或者贪心问题）。事实上只需要摸清操作的规律，就可以迎刃而解。

如果不能一眼看出规律，也可以先从几个比较小的数开始模拟。为简明起见，我们把最初选择的数称为**初始值**，例如 $71695$。

按照题意，$71695$ 的变换过程可能如下：

$71695\to8695\to1495\to1414\to514\to55\to10\to1$

$71695\to7795\to7165\to775\to712\to73\to10\to1$

$71695\to7795\to7165\to775\to712\to73\to10\to1$

$71695\to71614\to8614\to874\to811\to91\to10\to1$

$\dots \dots$

换用几个别的初始值，我们可以发现：
1. 每次操作后，**“位数减少一位”（以下简称“退位”）和“数字之和减少 $9$”只会二者取其一发生**；
2. **操作的顺序、每次操作的位置只会影响退位和减 $9$ 的交替顺序**，并**不能**改变操作次数；
3. 基于第 1 条和第 2 条的原因，如果初始值恰好为 $9$ 的倍数，最后剩下的一位数一定是 $9$，否则剩下的数字就是初始值模 $9$ 的余数。

根据上面分析我们很容易知道，某个特定的初始值能进行多少次操作，取决于其数字和中能够拿得出多少个 $9$（前提是不能最后剩下一个 $0$），最多能退位多少次。两者相加即可得到答案。由于最后剩下一位，设数字和为 $t$，长度为 $l$，那么答案就是 $\lfloor (t-1)/9\rfloor+l-1$。因此**初始值确定后，操作次数就已经一锤定音，不存在所谓的最优解**。

形象一点讲，我们把这个数字比做一个装着金币和钻石的袋子，金币的数量等同于数字和，钻石的数量等于数字位数，每次操作可以拿走 $9$ 个金币或者 $1$ 个钻石，在最后剩下一个钻石和 $1\sim9$ 枚金币的情况下，最多能拿多少次。

注意：
1. 需要使用 long long；
2. 需要特别判断初始值整除 $9$ 的情况。
3. 由于只需要记录位数和数字和，因此并不需要使用数组存储 $c_i,d_i$，在循环过程中一边输入一边累加即可。

## C++ 代码
```
#include<cmath>
#include<iostream>
using namespace std;
long long m, c, d, tot=0, len=0;
int main()
{
	cin >> m;
	for (int i = 1; i <= m; i += 1)
	{
		cin >> d >> c;
		len += c;
		tot += c * d;
	}
   //tot-1的原因是特判9的倍数，最后剩下一位不能是0
   //C++的整数除法自带向下取整
	cout << len - 1 + (tot - 1) / 9ll << endl;
}
```

## Python 代码
```
t=0
l=0
m=int(input())
for i in range(m):
    d,c=input().split()
    t+=int(c)*int(d)
    l+=int(c)
print(l-1+(t-1)//9) #python需要使用双斜杠表示向下取整的除法
```

---

## 作者：WOL_GO (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/AT_ddcc2020_qual_d)

一道裸的数学题。

题目的意思是，每当你进行了一次操作，相邻的数位就会合并，所以只要合并后没有进位，那么这个数的数位就会少一位，否则数字和 $-9$。把数字和设为 $sum$，数字位数设为 $num$，那么，答案就为 $num+\frac{sum-1}{9}-1$，输出方可。

## 代码

```cpp
#include<bits/stdc++.h>
//#define ll long long
//#define pir pair<int,int>
//#define ff first
//#define ss second
#define int long long
using namespace std;
void read(int &xx){
	register char ch=getchar();
	register int ans=0;
	char t=0;
	while(!isdigit(ch))t|=ch=='-',ch=getchar/*_unlocked*/();
	while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar/*_unlocked*/();
	xx=t?-ans:ans;
	return ;
}
void write(int x){
	if(x<0){
		putchar('-');
		x*=-1;
	}
	char wr[18];
	int cnt=1;
	if(x==0){
		putchar('0');
		putchar('\n');
		return ;
	}
	while(x){
		wr[cnt++]=x%10+'0';
		x/=10;
	}
	for(cnt--;cnt;cnt--){
		putchar(wr[cnt]);
	}
	putchar('\n');
	return;
}
const int maxn=1e6+5;
int n,a[maxn],sum,num;
main(){
	read(n);
	for(int i=1;i<=n;i++){
		int x,y;
		read(x);
		read(y);
		sum+=x*y;
		num+=y;
	}
	write(num+(sum-1)/9-1);
	return 0;
}
```



---


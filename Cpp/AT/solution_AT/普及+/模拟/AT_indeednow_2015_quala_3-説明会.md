# 説明会

## 题目描述

[problemUrl]: https://atcoder.jp/contests/indeednow-quala/tasks/indeednow_2015_quala_3

ある企業は、説明会に参加する学生の選抜コンテストを行いました。 説明会を行おうとしている会場の最大収容可能人数が決まっているため、コンテスト担当者はボーダーラインを何点にするかを悩んでいます。

選抜方法を説明します。

- ボーダーラインが $ x $ 点のとき、正の点数を取っている学生のうち $ x $ 点以上の得点を得た学生を全て選抜する。
- つまり、$ 0 $ 点の学生は会場の最大収容可能人数に関わらず選抜しない。

あなたには、選抜コンテストにおける $ N $ 人の学生の点数が与えられます。 また、会場の候補が $ Q $ 個あります。そして、会場の最大収容可能人数はそれぞれ $ k_1,k_2,…,k_Q $ です。 ある企業は、説明会をこれらの会場の候補のうちいずれかで開催しようとしています。

あなたの仕事は、それぞれの会場候補で説明会を行う場合について、最小のボーダーラインを出力しなければなりません。 具体的には、$ i\ (1≦i≦Q) $ 番目の会場候補で説明会を行うと仮定したとき、上記の方法に基づいて選抜した学生の数が $ k_i $ 人以下となるようなボーダーラインのうち $ 0 $ 以上かつ最小のものを出力してください。

## 说明/提示

### Sample Explanation 1

とんでもないケースですが、$ 1 $ 番目の会場の最大収容可能人数は $ 0 $ なので、誰も通過させたくありません。それを達成するボーダーラインで最小のものは $ 11 $ 点です。 $ 2 $ 番目の会場の最大収容可能人数は $ 4 $ 人なので、選抜する人数がそれ以下になるようなボーダーラインを設定しなければなりません。 もしボーダーラインを $ 6 $ 点に設定した場合、$ 6 $ 人通過してしまい会場の最大収容可能人数をオーバーしてしまいます。$ 7 $ 点に設定した場合は $ 3 $ 人のみ通過し、会場に収容可能でき、これが最小のボーダーラインです。 $ 3 $ 番目の会場の最大収容可能人数は $ 12 $ 人ですが、ボーダーラインは $ 0 $ 点にします。なぜならば、選抜方法より $ 0 $ 点の学生は通過できないので、正の点数を取った $ 12 $ 人のみが通過するからです。

### Sample Explanation 3

全員が $ 0 $ 点のケースもありえます。 この場合は、どんなボーダーラインに設定しても誰も通過しないので、会場の最大収容可能人数に関わらずボーダーラインは $ 0 $ 点にします。

## 样例 #1

### 输入

```
15
0
0
0
1
1
2
3
4
5
6
6
6
8
9
10
3
0
4
12```

### 输出

```
11
7
0```

## 样例 #2

### 输入

```
9
3
3
3
2
2
2
1
1
1
1
4```

### 输出

```
3```

## 样例 #3

### 输入

```
4
0
0
0
0
1
0```

### 输出

```
0```

# 题解

## 作者：kkk_dex (赞：1)

~~这道题不就是个大水题吗?~~
## 注意：
就算会场容得下所有人但是分数为 $0$ 也不能进，所以最低分可以为 $0$，所以只存分数不为 $0$ 的人的分数。

首先思路：将 **不为 $0$** 的分数存到一个数组里，按分数从低到高排序。
输入每次会场容纳人数 $k$ ：
1. 如果当前 $k$ $>$ 当前分数不为 $0$ 的的人数，就直接输出最低分 $0$。
1. 如果不满足上面一条，就寻找最低分数，因为容纳 $k$ 个人，达到条件的分数就是 第 $t-k+1$ 个人的分数，那么最低分数线他前面的人（$t-k$）的分数线 $+1$。


## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],k,t,x;
int main()
{
	cin>>n;//输入人数 
	for(int i=1;i<=n;i++)
	{
		cin>>x;//输入分数
		if(x==0)  continue;
		else
		{
			a[++t]=x;//记录不为0的分数
		}
	}
	sort(a+1,a+t+1);//按分数从小到大排序
	cin>>m;
	for(int i=1;i<=m;i++)//m次输入
	{
		cin>>k;//会场容纳人数
		if(k>=t) //如果容纳人数大于分数不为0的人数 ，就输出0；
		cout<<0<<endl;
		else  
		cout<<a[t-k]+1<<endl;//达到条件的分数的人的前面的人的分数+1
	}
	return 0;//完结撒花
}
```


~~蒟蒻第一篇题解，希望管理通过。~~

---

## 作者：Tear_stains (赞：0)

首先题目明确要求 $0$ 分的人不能参加面试，所以数组中的数非零

# 思路：

$1$：如果 $k$ $>$ 当前面试人数，那么这个会议室不能满足条件。

$2$：否则给数列从小到大排序，因为至少要容纳 $k$ 个人，且分数线要最大，所以只有后 $k$ 个人能满足条件，分数线为第 $t-k$ 个人的分数 $+1$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, k, t, x;
int a[100005];
int main() {
	ios::sync_with_stdio(false);
    cin >> n >> m;//人数,会场 
    while(n--) {
        cin >> x;//分数
        if(x==0) {
        	continue;
        } else {
            a[++t]=x;//统计不为0的分数
        }
    }sort(a + 1, a + t + 1);//把分数从小到大排序
    while(m--) {
        cin >> k;//会场可容纳人数
        if(k >= t) {
		    cout << 0 << endl;//如果容纳人数大于分数不为0的人数 ，就输出0。 
		} else {
			cout << a[t - k] + 1 << endl;//达到条件的分数的人的下面的人的分数+1
		}
    }
    return 0;//好习惯+1 
}
```


---

## 作者：LeiZeProMax (赞：0)

题意：给定学生个数 $n$，会场个数 $q$，每个学生笔试环节的分数 $x_i$ 和每个会场容纳的人数 $k_i$，根据每个会场容纳的人数确定分数线。

注意：笔试分数为 $0$ 的选手无论会场可容纳人数是多少，都不能参加。

我们可以先定义一个数组 $a_i$ 用来存分数不为 $0$ 的学生，用 $num$ 表示分数不为 $0$ 的学生的数量，将 $a_i$ 从小到大排序，将会场可容纳人数与分数不为0的学生作比较。如果会场可容纳人数大于等于分数不为 $0$ 的人数，输出 $0$；否则输出学生中第 $num-k$ 名学生的分数 $+1$。

# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[100001],k;
//n表示学生数量，q表示会场数量，a[i]表示分数不为0的学生的分数，k表示会场可容纳的最大人数
int num;//num表示分数不为0的学生的数量
inline int read()//快读
{
	int s=0,x=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')x=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=(s<<3)+(s<<1)+(ch^48);ch=getchar();}
	return s*x;
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	{
		int x=read();
        //x表示每个学生的分数
		if(x)a[++num]=x;
        //如果分数不为0，将其放进数组a中
	}
	sort(a+1,a+num+1);
    //将学生的分数从小到大排序
	q=read();
	for(int i=1;i<=q;++i)
	{
		k=read();
		if(k>=num)puts("0");
        //如果会场可容纳人数大于分数不为0的学生的个数，输出0
		else printf("%d\n",a[num-k]+1);
        //输出分数线
	}
	return 0;
}
```


---

## 作者：Wy_x (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT1207)

[更好的阅读体验？](https://www.luogu.com.cn/blog/73-54-16/solution-at1207)

### 我的思路：

- 考了 $0$ 分的选手不能参加面试，**可以直接跳过**。

- 其余选手的分数用数组存储，$n$ 个分数全部输入后，**将数组内的分数排序**，方便以后进行分数线的判断。

- 在输入会场的最大可容纳人数的同时计算分数线，可以减少 $O(q)$ 的时空复杂度。

- 当计算分数线时，有以下两种情况：

>- 面试会场**可容纳**所有分数不为零的选手，此时的分数线是 $0$，代码实现为 `if(k>=tot)  cout<<0<<endl;`；

>- 面试会场**容纳不下**所有分数不为零的选手，分情况讨论：

>>1. 分数线及以上的选手**正好为** $k_i$，此时分数线最低为低于分数线选手的最高分加 $1$。

>>2. 分数线及以上的选手**低于** $k_i$，不能再降低分数线，此时分数线最低为低于分数线选手的最高分加 $1$。

>- 得通项公式：**低于分数线选手的最高分加** $1$，又因为是从小到大排序，所以，代码实现为 `else cout<<a[tot-k]+1<<endl;`。

>- 注：`a[tot-k+1]`为会场正好满时最低的分数，此时低于分数线选手的最高分为 `a[tot-k]`，分数线应为 `a[tot-k]+1`。
- 数据在 $\operatorname{int}$ 范围内。

- 在 $\operatorname{sort}$ 排序时，最坏情况下，时间复杂度为 $O(n^2+n+q)$，不能通过本题，**需要考虑归并排序**，原理就不细讲了，不懂可以[百度](https://www.baidu.com/)，并且可以做一下[模板题](https://www.luogu.com.cn/problem/P1177)。

### 最坏情况下的复杂度：

时间：$\operatorname{sort}$ 为 $O({n^2+n+q})$，归并排序为 $O({n \log n+n+q})$。

空间：$\operatorname{sort}$ 为 $O ({n})$，归并排序为 $O ({2n})$。

### sort代码：
```cpp
#include<bits/stdc++.h>   //万能头文件  
using namespace std;
int n,q,a[100005],k,tot;
//tot为分数不为零的选手的数量 
int main()
{
	cin>>n;//n个选手 
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		if(x==0)  continue;//分数等于零时跳过 
		else
		{
			tot++;
			a[tot]=x;
		}//等于 a[++tot]=x;
	}
	sort(a+1,a+tot+1);//sort默认由小到大排序 
	cin>>q;//q次询问
	for(int i=1;i<=q;i++) 
	{
		cin>>k;
		if(k>=tot)  cout<<0<<endl;//套公式 
		else  cout<<a[tot-k]+1<<endl;//套公式 
	}
	return 0;
}
```

### 归并排序代码:
```cpp
#include<bits/stdc++.h>   //万能头文件  
using namespace std;
int n,q,a[100005],k,tot;
//tot为分数不为零的选手的数量 
int t[100005];
void mergesort(int l,int r)//归并板子，可以背一下 
{
	if(l==r)  return;
	int mid=(l+r)/2;
	//等价于 int mid=(l+r)>>1;
	mergesort(l,mid);
	mergesort(mid+1,r);
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)
	{
		if(a[i]<a[j])  t[k++]=a[i++];
		else  t[k++]=a[j++];
	}
	while(i<=mid)  t[k++]=a[i++];
	while(j<=r)  t[k++]=a[j++];
	for(i=l;i<=r;i++)  a[i]=t[i];
	return;
}
int main()
{
	cin>>n;//n个选手 
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		if(x==0)  continue;//分数等于零时跳过 
		else
		{
			tot++;
			a[tot]=x;
		}//等于 a[++tot]=x;
	}
	mergesort(1,max(tot,1));//改成归并排序 
	//可能tot为0，这时会RE，需要和1取最大值。 
	cin>>q;//q次询问
	for(int i=1;i<=q;i++) 
	{
		cin>>k;
		if(k>=tot)  cout<<0<<endl;//套公式 
		else  cout<<a[tot-k]+1<<endl;//套公式 
	}
	return 0;
}
```





---

## 作者：ylinxin2010 (赞：0)

## AT1207 题解

**本题思路：**

因为当分数等于零时无论怎样都进不了，所以当其为零时，直接跳过。

然后将输入的数从大到小排序。

对于每次询问，判断有没有这么多人，有的话，为防止并列，直接输出 $a_{k + 1} + 1$，否则输出零。

**复杂度分析：**

时间：$O(N \log N)$。

空间：$O(N)$。

接下来——上代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5;

int n, q;
vector<int> e;

signed main() {
  cin >> n;
  for (int x; n; n--) {
    cin >> x;
    if (x) { // 不为零才记录
      e.push_back(x);
    }
  }
  sort(e.rbegin(), e.rend()); // 从大到小排序
  cin >> q;
  for (int x; q; q--) {
    cin >> x;
    cout << (x < e.size() ? e[x] + 1 : 0) << '\n'; // 判断有没有这么多数
  }
  return 0;
}
```

---


# Ordinary Beauty

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-qual/tasks/soundhound2018_summer_qual_c

数列 $ (a_1,...\ ,a_n) $ の *美しさ* を、隣り合う $ 2 $ 項の組であって、 差の絶対値が $ d $ であるものの個数として定義します。 例えば、$ d=1 $ であるとき、数列 $ (3,\ 2,\ 3,\ 10,\ 9) $ の美しさは $ 3 $ です。

各要素が $ 1 $ 以上 $ n $ 以下の整数である長さ $ m $ の数列は全部で $ n^m $ 通り存在します。 この $ n^m $ 通りの数列すべてに対して美しさを求めて、 それらの平均を出力してください。

## 说明/提示

### 制約

- $ 0\ \leq\ d\ <\ n\ \leq\ 10^9 $
- $ 2\ \leq\ m\ \leq\ 10^9 $
- 入力はすべて整数

### Sample Explanation 1

$ (1,1,1) $ の美しさは $ 0 $ です。 $ (1,1,2) $ の美しさは $ 1 $ です。 $ (1,2,1) $ の美しさは $ 2 $ です。 $ (1,2,2) $ の美しさは $ 1 $ です。 $ (2,1,1) $ の美しさは $ 1 $ です。 $ (2,1,2) $ の美しさは $ 2 $ です。 $ (2,2,1) $ の美しさは $ 1 $ です。 $ (2,2,2) $ の美しさは $ 0 $ です。 これらの平均である、 $ (0+1+2+1+1+2+1+0)/8=1 $ が答えとなります。

## 样例 #1

### 输入

```
2 3 1```

### 输出

```
1.0000000000```

## 样例 #2

### 输入

```
1000000000 180707 0```

### 输出

```
0.0001807060```

# 题解

## 作者：_H17_ (赞：2)

## 题目分析

这是一道概率论的题目。

> 总共有 $n^m$ 个长度为 $m$ 的序列，其中每个元素都在区间 $[1,n]$ 中。
求序列中 $\lceil$美$\rfloor$ 的平均个数。

其实在 $n^m$ 个序列中，如果是平均分布的，那序列们是 $\{1,2\cdots ,n\},\{1,2,3,\cdots ,n,n-1\},\cdots,\{n,n-1,n-2,\cdots ,1\}$。也就是求单个序列中出现 $\lceil$美$\rfloor$ 次数的概率。

$\lceil$美$\rfloor$ 只有可能存在于 $m-1$ 种位置 $(1,2),(2,3),\cdots,(n-1,n)$，求出两个数的出现 $\lceil$美$\rfloor$ 的概率在乘 $m-1$ 即可。

下面讨论 $a_i,a_{i+1}(1\le i<n)$ 出现 $\lceil$美$\rfloor$ 的概率。

如果 $a_i,a_{i+1}$ 是 $\lceil$美$\rfloor$ 的则 $a_{i+1}=a_i+d$ 或 $a_{i+1}=a_i-d$。显然，前后两者的概率相同，我们此时只讨论 $a_{i+1}=a_i+d$ 的概率。

当 $a_{i+1}=a_i+d$ 时：$(a_i,a_{i+1})$ 是 $(1,d+1),(2,d+2),\cdots,(n-d,n)$。

一共是 $n-d$ 种，在加上 $a_{i+1}=a_i-d$ 的情况，一共 $2(n-d)$ 种。

因为任意相邻两个数是独立的（概率不互相影响），所以整个序列一共有 $2(n-d)(m-1)$ 种可能性。

然后除以一共有 $n^2$ 种可能（两个数都是 $1\sim n$ 之间），得到公式 $\frac{2(n-d)(m-1)}{n^2}$。

你可以提交一发代码试试，然后你发现你并没有 `AC`。

究其原因还得论道 $d=0$，此时并没有分为两种情况（准确来说是两种情况相等），所以不用乘 $2$，公式 $\frac{(n-d)(m-1)}{n^2}=\frac{m-1}{n}$（其实就是上一种的一半，不化简也可以）。

## 代码实现

版本 $1$：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,d;
int main(){
	cin>>n>>m>>d;
	double ans=2.0*(n-d)*(m-1)/(1.0*n*n);//注意1.0的精度问题
	if(!d)
		ans/=2;//取一半
	printf("%.10lf",ans);//保留10位小数
	return 0;
}
```

版本 $2$：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,d;
double ans;
int main(){
	cin>>n>>m>>d;
	if(d)
		ans=2.0*(n-d)*(m-1)/(1.0*n*n);//公式
	else
		ans=(m-1.0)/n;//化简的
	printf("%.10lf",ans);
	return 0;
}
```

---

## 作者：Orange1015 (赞：2)

# AT_soundhound2018_summer_qual_c Ordinary Beauty 题解

$2023/3/19$ 更新：修复 $\LaTeX$。



------------


[传送门](https://www.luogu.com.cn/problem/AT_soundhound2018_summer_qual_c)

这道题主要考察了概率论和期望的知识。


### $\boxed{\texttt{重点}}$

这道题需求「美」之和的平均值，即 $\color{#E74C3C}\text{ 求出对于满足条件的序列的「美」的期望 }$ ，同时，每相邻两对数 $(a_x , a_x+1)$ 与 $(a_x+1 , a_x+2)$ 的「美」的期望 $\color{#E74C3C}\text{ 互不影响 }$。

所以，我们进行如下推导：

对于每一对相邻的两个数，总共有 $n^2$ 种情况，我们以 $d$ 是否为 $0$ 来进行分类讨论。

 $ ( \text{ 1 } ) $ 当 $d=0$ 时：

相邻的两个数为 $(1 , 1)$ 、 $(2 , 2)$ 、 …… 、 $(n , n)$ 时，「美」为 $1$ ，共 $n$ 种情况，所以每相邻两个数的「美」的期望 $D = \dfrac {(m-1) \times (n-d)} {n^2} = \dfrac {m-1} {n}$ ；

 $ ( \text{ 2 } ) $ 当 $d\not =0$ 时：

相邻的两个数为 $(1 , d+1)$ 、$(2 , d+2)$ 、 …… 、 $(n-d , n)$ 或 $(d+1 , 1)$ 、 $(d+2 , 2)$ 、 …… 、 $(n-d , n)$ 时，「美」为 $1$ ，共 $2 \times ( n-d )$ 种情况，所以每相邻两个数的「美」的期望 $D = \dfrac {(m-1) \times  2 \times (n-d)} {n^2}$ 。


所以我们就可以写代码啦！

### $\boxed{\texttt{code}}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,d;
signed main(){
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> d;
	if(d==0){
		cout << fixed << setprecision(10) << (m-1.0)*/n;
		// 注: << fixed << setprecision(10) 可以控制输出小数的精度
		// 需要搭配 include<iomanip> 使用 
        // 乘以带有小数点的整数可以将整数强制转换为浮点数（小数）
	}
	else{
		cout << fixed << setprecision(10) << 2.0*(m-1.0)*(n-d)/(n*n);
	}
    return 0;
}

```

---

## 作者：_qingshu_ (赞：1)

# 前言

本题需要一些有关概率与期望的知识，大概会在高中必修三中有所讲到，如果不会的可以先去学习前置知识。

# 题意

给定一个长度为 $m$ 的序列，该序列中的每一个元素都是 $1 \sim n$ 中的一个整数（可以重复），求出现绝对差为 $d$ 的相邻的两个数的对数的期望值（所有情况个数平均值）。

# 思路

## 考虑有多少可能对答案产生贡献的对数：

首先要知道有多少对有可能对答案产生贡献的对的数量。显而易见的，因为每一个数对于其他数的位置和其他数的值并没有影响，所以应该有 $m-1$ 对有可能对答案产生贡献的组合，我们将这个组合看作 $(a,b)$。

## 考虑 $a$ 与 $b$ 绝对差为 $d$ 的情况数：

因为我们并不知道是 $a>b$ 还是 $b>a$，所以我们分情况考虑。

### 当 $a \leq b$ 时：

因为 $ a-b=d $ 且 $ 1 \leq b < a \leq n $，所以说 $a$ 实际可以取的数的个数只有 $n-d$ 个。

### 当 $a<b$ 时：

同上可得：$a$ 可以取的数也只有 $n-d$ 个。



------------


那么因为这两种情况下 $b$ 的值是被 $a$ 给固定住了的，所以说选择出一对可以组成答案的 $(a,b)$ 的总情况数为 $(n-d)\cdot(n-d)\cdot1$ ,化简一下为 $2\cdot(n-d)$。

## 特殊情况：

当 $d=0$ 时，$a$ 可以取任意值，所以说总共有 $n$ 种情况。

## 总方案数：

显而易见，$(a,b)$ 的情况总共有 $n^2$ 种。

# 公式：

综上，我们知道事件的发生概率是在总次数中该事件发生的次数，而期望是它的平均值。

易得：

如果 $ d=0 $：

```
(m-1)/n
```

如果 $d \neq 0$：
```
(2*(n-d)*(m-1)/n/n))
```



---

## 作者：Crazyouth (赞：0)

## 分析

美的平均值可以看作一个序列的美的期望值。注意到这个序列的数是独立的，即不管 $a_i$ 取什么，$a_{i+1}$ 总是等概率地取，所以只需要判断序列中 $m-1$ 个相邻对是否美即可。也就是说，答案等于一个相邻对美的概率乘 $m-1$。对 $d$ 分类讨论。

如果 $d=0$，在确定 $a_i$ 后，$a_{i+1}$ 有 $\frac{1}{n}$ 的概率与 $a_i$ 相等。所以此时答案是 $\frac{m-1}{n}$。

如果 $d>0$，在确定 $a_i$ 后，美的对要保证 $a_{i+1}+d\le n,a_{i+1}-d>0$，因此满足的方案数为 $(n-d)+(n-d)$，总方案数为 $n^2$，概率为 $\frac{2(n-d)}{n^2}$，于是答案是 $\frac{2(n-d)(m-1)}{n^2}$。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long double n,m,d;
	cin>>n>>m>>d;
	if(!d) cout<<fixed<<setprecision(7)<<(m-1.0l)/n; 
	else cout<<fixed<<setprecision(7)<<2.0l*(n-d)*(m-1.0l)/n/n;
	return 0;
}
```

---

## 作者：Register_int (赞：0)

先给题意：

> 有一个长度为 $m$ 的序列 $a$，每个数 $a_i$ 在 $[1,n]$ 的正整数中均匀随机。若二元组 $(x,y)$ 满足 $|x-y|=d$，则称 $(x,y)$ 为「美」的。一个序列的优美度是序列中所有相邻两数 $a_i,a_{i+1}$ 构成的二元组中，「美」的二元组的个数。你需要求出 $a$ 的优美度的期望。

首先需要意识到一件事：

- 每个数的值是相互不干扰的，每一种值的出现概率总是 $\dfrac1n$。

这个是显然的，但是进一步呢？

- 设序列为 $a$，则 $a_i,a_{i+1}$ 的值是独立的，与其他数无关。

所以：

- $(a_i,a_{i+1})$ 是否为「美」的与别的数都无关，与他所在的位置也无关！

根据这个，由于相邻的二元组有 $m-1$ 对，将单组二元组为「美」的的概率乘以 $m-1$ 就可以得到序列优美度的期望了。

然后我们来计算单组满足要求的概率。先固定 $x$，那么 $y$ 只有两种取值：$x+d$ 与 $x-d$。两者分别需要满足 $x+d\le n$ 与 $x-d\ge1$，因此 $x$ 在两种情况下可能的取值只有 $n-d$ 种，加起来是 $2(n-d)$ 种，概率为 $\dfrac{2(n-d)}{n^2}$。但是当 $d$ 为 $0$ 时比较特殊，$y$ 只有一种取值，即 $y=x$，所以此时 $x$ 的取值有 $n$ 种，概率为 $\dfrac{n}{n^2}=\dfrac1n$。

乘上之前的 $m-1$，答案为：

$$
\begin{cases}
\dfrac{m-1}n&d=0\\
\dfrac{2(n-d)(m-1)}{n^2}&d\not=0
\end{cases}
$$

完结撒花！

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, d;

int main() {
	scanf("%d%d%d", &n, &m, &d);
	if (!d) printf("%.20lf", (double)(m - 1) / n);
	else printf("%.20lf", (double)2 * (n - d) * (m - 1) / n / n);
}
```

---


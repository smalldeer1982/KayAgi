# [ABC002D] 派閥

## 题目描述

从上帝和母亲鼓励的话语中重新获得信心（中二）的高桥君决定去任选国会议员，以纠正AtCoder国家的腐败政治。
以实践操控和演讲而闻名的高桥君最终以实践操控和演讲而闻名的高桥君最终没有困难地赢得了大家的信任，成为了国会议员。
成为国会议员后，接下来就是实际操作。为了纠正这个国家的腐败政治，他需要被任命为总理。
在AtCoder国家除了高桥君之外，还有**N名议员**，存在**M个人际关系（x，y）**。
**人际关系（x，y）的意思是表示成员x和成员y彼此熟悉**（就是可以搞投票的意思）。
高桥君计划通过从N位议员中选出一些议员来制造自己的派系（就是会支持自己）。
**要求包括在该派系中的所有成员必须彼此了解。**
请你动动你的小手写一个程序，求出能属于高桥派系的最大成员人数。

## 说明/提示

（样例一）

第1行：与五位议员有三种人际关系。
第2行：议员1和2互相熟悉。（1,2）
第3行：议员2和3互相熟悉。 （2,3）
第4行：议员1和3互相熟悉。 （1,3）
因为国会议员1，国会议员2，国会议员3相互认识，所以这三个人可以组成高桥君的~~后宫~~支持队伍。

（样例二）

这一个样例有以下可能的关系 ：
1.议员1和议员2互相熟悉（1,2）
2.议员2和议员3互相熟悉 （2,3）
3.议员3和议员4互相熟悉（3,4）
（但是议员1和议员4不互相熟悉所以只能是选择2号议员和3号议员）

翻译：Forgetrmber~这个小小蒟蒻

# 题解

## 作者：Ray662 (赞：8)

[洛谷 传送门](https://www.luogu.com.cn/problem/AT_abc002_4) | [AtCoder 传送门](https://atcoder.jp/contests/abc002/tasks/abc002_4)

[更好的阅读体验](https://www.luogu.com.cn/blog/sunrize/solution-at-abc002-4)

题目大意：

- $n$ 个人，$m$ 条关系，每条关系包含两个数 $(x, y)$，表示第 $x$ 个人和第 $y$ 个人互相认识。

- 求出最大的子集，使得子集内部的所有人**彼此**了解。

- $n \le 12, m \le \frac{n(n - 1)}{2}$。

---

### 分析

看到此题我的第一反应是并查集，但做着做着就发现并查集好像无法判断彼此了解这件事情。

看了一眼数据范围，发现 $n$ 很小，$2^n$ 也不过 $4000$ 多，想到可以用状态压缩。

怎么压呢？

每个人选或不选！

具体来说，一个状态 $st$ 可以表示为一个 $n$ 位的二进制数（前面自动补齐 $0$），从右到左第 $i$ 位为 $1$，表示选择第 $i$ 个人；反之，不选择第 $i$ 个人。

举个栗子，$n = 3, st = 011$，表示一共 $3$ 个人，选择第 $1, 2$ 个人的状态。

状态设计好了，那最终答案是选哪个状态呢？

**枚举！**

由于 $2^n$ 只有 $4096$，所以枚举是没有问题的。于是我们把 $0 \sim (2^n - 1)$ 的状态全部枚举一遍。

如何判断合不合法？

我们可以枚举 $st$ 中的每一位，如果是 $1$ 就把他存进 vector。

存完了以后再 $n^2$ 枚举 vector 内的任意两个元素。如果所有二元组都互相了解，那么合法，更新答案即可。

最后说一下初始化，每读入两个人 $(x, y)$，那么 `G[x][y] = G[y][x] = 1`，同时别忘了把每个 `G[i][i]` 都设为 $1$（每个人都认识自己）。

**别忘了！每次考虑完一个状态以后要 `st ++ `！**

---

### 位运算小技巧

此题使用位运算可以很大程度上减小码量。

例如：

- $2^n - 1$ 没必要写循环算，直接 `(1 << n) - 1` 即可。

- 判断 $st$ 第 $i$ 位（从右到左）是否为 $1$，只需要把 $st$ 和 $2^i$ 按位与一下即可，若结果为 $1$ 表示第 $i$ 位为 $1$，反之同理。即：`st & (1 << i)`

---

总体复杂度 $O(n^2 \times2^n)$。

吐槽一句：这题时间限制为什么给 2s 啊？$74$ 个测试点最慢的 6ms 就跑完了……

### 上代码！

```cpp
#include <bits/stdc++.h>
#define _for(i, a, b)  for (int i = (a); i <= (b); i ++ )
using namespace std;
const int N = 15;
int n, m, ans, G[N][N];
int main() {
	cin >> n >> m;
	int a, b;
	_for (i, 0, n - 1)  G[i][i] = 1;  // 自己认识自己 
	_for (i, 1, m) {
		cin >> a >> b, a -- , b -- ;
		G[a][b] = G[b][a] = 1;  // 两点之间有连边 
	}
	int st = 0;
	while (st <= (1 << n) - 1) {  // 遍历每一个状态 
		vector<int> v;
		_for (i, 0, n - 1)
			if (st & (1 << i))  v.push_back(i);  // 把选出的点存入 
		int bj = 1;  // 标记 
		for (int x : v)  for (int y : v)
			if (! G[x][y]) { bj = 0; break; }  // 如果有两人不认识，散伙 
		if (bj == 1)  ans = max(ans, (int)v.size());  // 更新答案（最多人数） 
		st ++ ;  // 别忘了更新状态 
	}
	cout << ans << endl;
	return 0;
}
```

希望这篇题解能帮助你。

---

## 作者：ivyjiao (赞：3)

upd on 11-14：增加了一种新做法随机化贪心。

------------

我们考虑用邻接矩阵来存储每个人互相是否“认识”的关系（**注意，在本题中，我们认为自己认识自己**）。

```
for(int i=1;i<=m;i++) cin>>x>>y,g[x][y]=1,g[y][x]=1;
for(int i=1;i<=n;i++) g[i][i]=1;
```

然后我们深搜。

每搜到一个人，都有“选”和“不选”两种状态，这个部分时间复杂度为 $O(2^n)$。

搜到最后一个人后开始判断状态是否合法，直接 $O(n^2)$ 暴力判断即可，如果出现两个人不认识，则当前状态不合法，直接退出。

如果搜到最后都没发现有两个人互相不认识，则当前状态合法，把当前答案与目前最优答案取较大值。

复杂度 $O(2^nn^2)$，过。

```
void dfs(int l1,int l2){
    if(l1==n+1){
        for(int i=1;i<=l2;i++) for(int j=1;j<=l2;j++) if(!g[a[i]][a[j]]) return;
        ans=max(ans,l2);
        return;
    }
    dfs(l1+1,l2);
    a[l2+1]=l1;
    dfs(l1+1,l2+1);
    a[l2+1]=0;
    return;
}
```

最优性剪枝：如果当前状态（没搜完）后面的人即使全选且全都合法也不优于目前最优答案，直接退出。

```
if(l2+n-l1+1<=ans) return;
```

可行性剪枝：如果当前这个人加进当前状态后不合法，就不要让他加进来。

```
for(int i=1;i<=l2;i++) if(!g[l1][a[i]]) return;
```

然后我们发现，由于在这种剪枝下，每一步的状态都一定合法，所以我们最后的判断就可以删除（因为一定合法就不用判断）。

判断的 $O(n^2)$ 就没有了，但由于这种剪枝本身还有个 $O(n)$ 的时间复杂度，所以现在的时间复杂度是 $O(2^nn)$。

最终代码：

```
#include<iostream>
using namespace std;
int n,m,x,y,g[13][13],a[13],ans;
void dfs(int l1,int l2){
    if(l2+n-l1+1<=ans) return;
    if(l1==n+1){
        ans=max(ans,l2);
        return;
    }
    dfs(l1+1,l2);
    for(int i=1;i<=l2;i++) if(!g[l1][a[i]]) return;
    a[l2+1]=l1;
    dfs(l1+1,l2+1);
    a[l2+1]=0;
    return;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>x>>y,g[x][y]=1,g[y][x]=1;
    for(int i=1;i<=n;i++) g[i][i]=1;
    dfs(1,0);
    cout<<ans<<endl;
}
``` 

------------


然而此题的难度评级是绿，意味着我们要用绿色的知识点来做这道题，什么算法？

随机化贪心，[模板 P2210](https://www.luogu.com.cn/problem/P2210)。

每次将贪心数组 random_shuffle 一下，把贪心结果取最大值。由于本题时限为两秒，所以不用担心过不去。

还有一个小优化：如果某一次的结果已经为 $n$，已经把所有人都取上了，就可以不用再算了（其实这个想证明一个东西也不难，就是只要出现这种情况那必定是第一次贪心的结果，因为如果所有人都能取，显然无关顺序）。

```
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,g[13][13],a[13],cnt,ans;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>x>>y,g[x][y]=1,g[y][x]=1;
    for(int i=1;i<=n;i++) g[i][i]=1,a[i]=i;
    while((double)clock()/CLOCKS_PER_SEC<1.99){
		random_shuffle(a+1,a+1+n);
		cnt=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<i;j++){
				if(!g[a[i]][a[j]]){
					goto T1;
				}
			}
			cnt++;
		}
		T1:;
		ans=max(cnt,ans);
        if(ans==n) break;
	}
    cout<<ans<<endl;
}
```

---


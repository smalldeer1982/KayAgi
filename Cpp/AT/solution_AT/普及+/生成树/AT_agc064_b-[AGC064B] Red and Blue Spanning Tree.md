# [AGC064B] Red and Blue Spanning Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc064/tasks/agc064_b

$ N $ 頂点 $ M $ 辺の連結無向グラフ $ G $ があります。$ i=1,2,\ldots,M $ に対し $ i $ 番目の辺は頂点 $ a_i,\ b_i $ を結んでいて、$ c_i= $ `R` ならば赤で、$ c_i= $ `B` ならば青で塗られています。

次の条件を満たす $ G $ の全域木が存在するかどうかを判定し、存在する場合は $ 1 $ つ示してください。

- $ i=1,2,\ldots,N $ すべてに対し、
  - $ s_i\ = $ `R` ならば、頂点 $ i $ を端点とする赤の辺が $ 1 $ 本以上存在する
  - $ s_i\ = $ `B` ならば、頂点 $ i $ を端点とする青の辺が $ 1 $ 本以上存在する

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ a_i\ \lt\ b_i\ \leq\ N $
- $ c_i $ は `R` または `B`
- $ i\ \neq\ j $ ならば $ (a_i,b_i,c_i)\ \neq\ (a_j,b_j,c_j) $
- 与えられるグラフは連結
- $ s_i $ は `R` または `B`
- $ N,M,a_i,b_i $ は整数
 
### Sample Explanation 1

$ G $ における $ 1,2 $ 番目の辺からなる全域木が条件を満たすことを以下に示します。 - $ s_1\ = $ `R` なので、$ i=1 $ に対する条件は頂点 $ 1 $ を端点とする赤の辺が $ 1 $ 本以上存在することです。これは $ G $ における $ 1 $ 番目の辺が該当します。 - $ s_2\ = $ `R` なので、$ i=2 $ に対する条件は頂点 $ 2 $ を端点とする赤の辺が $ 1 $ 本以上存在することです。これは $ G $ における $ 1 $ 番目の辺が該当します。 - $ s_3\ = $ `B` なので、$ i=3 $ に対する条件は頂点 $ 3 $ を端点とする青の辺が $ 1 $ 本以上存在することです。これは $ G $ における $ 2 $ 番目の辺が該当します。

## 样例 #1

### 输入

```
3 3
1 2 R
1 3 B
2 3 B
RRB```

### 输出

```
Yes
2 1```

## 样例 #2

### 输入

```
3 4
1 2 R
1 2 B
1 3 B
2 3 B
RRR```

### 输出

```
No```

## 样例 #3

### 输入

```
8 16
5 7 B
2 7 R
1 6 R
1 4 R
6 7 R
4 6 B
4 8 R
2 3 R
3 5 R
6 7 B
2 6 B
5 6 R
1 3 B
4 5 B
2 7 B
1 8 B
BRBRRBRB```

### 输出

```
Yes
1 2 4 9 11 13 16```

## 样例 #4

### 输入

```
8 10
1 7 R
1 3 B
2 5 B
2 8 R
1 5 R
3 6 R
2 6 B
3 4 B
2 8 B
4 6 B
RRRBBBRB```

### 输出

```
No```

# 题解

## 作者：yuanruiqi (赞：3)

## 题意

给定一个边和点有颜色的无向图，求一棵生成树，满足树上每一个点都存在邻边与之颜色相同。

## 思路

有一个很显然~~无脑~~的想法，是先贪心地考虑能满足两个点的边；然后再寻找能满足一个点，且另一个点已经被满足的边，或者能将当前答案中两个连通块连接的边，只要不会使得当前答案构成的森林出现环，就加入。

那么如何证明这样做是对的呢？

首先不必担心找不到满足两个点的边，否则 $n-1$ 条边无法满足 $n$ 个点，一定无解。

我们可以参考 boruvka 生成树，也就是依次检查从当前森林的点向外扩展的边，能否加入到答案里。具体的，只要加入的过程不会出现环，那么加边的顺序不会影响最后能成为一棵树。所以我们可以放心的决定加边的顺序。接下来要考虑的，是会不会因为贪心加入了满足两个点的边，导致接下来没法找到能满足一个点，且另一个点已经被满足的边，从而无解。这也是不可能发生的。因为发生这种情况仅当在考虑到这条边前，该边能满足的点就已经被满足了，此时便没有加入这条边的意义。

综上，只需要先考虑第一种边，然后以 boruvka 的过程，使用一个队列记录向外扩展的边，依次考虑能否满足第二三种边的要求，即可完成本题。

## 代码

[赛时代码](https://atcoder.jp/contests/agc064/submissions/44564895)

---

## 作者：GI录像机 (赞：1)

## 思路：

发现连着颜色和本身相同两点的边选入生成树一定是不劣的，考虑在不出现环的情况下直接加进来，我们叫这种边关键边。

每条边的加入可以让未满足条件的 $0$，$1$ 或 $2$ 个点满足条件。那么生成树中必然有一条关键边，否则生成树最多使 $n-1$ 个点满足条件。

把关键边所连的点加入一个队列中，每次使队列中的点遍历所连的边。所连的边有 $3$ 中情况：

1. 所连点已经与该点属于同一个联通块内。
2. 所连点未被加入过队列。
3. 所连点已被加入过队列但与该点不属于同一个联通块内。

对于情况 $1$，显然无需再选。

对于情况 $2$，如果边的颜色能满足所连点的条件就直接选择这条边并把这个点加入队列。因为加入相连点使至多产生 $1$ 的贡献。

对于情况 $3$，直接选择这条边即可。使两个联通块相连的边必然不会产生贡献，可以直接选择。

每个点只会被加入队列一次，边也不会被多次遍历，可以通过。

## 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c <= '9' && c >= '0') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
bool bit_read() {
	char c = getchar();
	while (c != 'R' && c != 'B')c = getchar();
	return c == 'R';
}
void write(int x) {
	if (x < 0) {
		x = -x;
		putchar('-');
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7;
int n = read(), m = read(), head[N], tot = 1, fa[N], siz[N];
bool col[N], ans[N];
struct Edge {
	int to, nxt, w;
} e[N << 2];
void add(int u, int v, int w) {
	e[++tot].to = v;
	e[tot].w = w;
	e[tot].nxt = head[u];
	head[u] = tot;
}
struct Node {
	int u, v, w;
} a[N];
int find(int x) {
	if (fa[x] == x)return x;
	return fa[x] = find(fa[x]);
}
signed main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	for (int i = 1; i <= m; i++) {
		a[i].u = read(), a[i].v = read(), a[i].w = bit_read();
		add(a[i].u, a[i].v, a[i].w), add(a[i].v, a[i].u, a[i].w);
	}
	for (int i = 1; i <= n; i++)col[i] = bit_read(), fa[i] = i, siz[i] = 1;
	queue<int>q;
	for (int i = 1; i <= m; i++)
		if (col[a[i].u] == col[a[i].v] && a[i].w == col[a[i].u]) {
			if (find(a[i].u) == find(a[i].v))continue;
			if (siz[find(a[i].u)] == 1)q.push(a[i].u);
			if (siz[find(a[i].v)] == 1)q.push(a[i].v);
			ans[i] = 1;
			if (siz[find(a[i].u)] == 1)q.push(a[i].u);
			if (siz[find(a[i].v)] > siz[find(a[i].u)]) {
				siz[find(a[i].v)] += siz[find(a[i].u)];
				fa[find(a[i].u)] = find(a[i].v);
			} else {
				siz[find(a[i].u)] += siz[find(a[i].v)];
				fa[find(a[i].v)] = find(a[i].u);
			}
		}
	while (!q.empty()) {
		int pos = q.front();
		q.pop();
		for (int i = head[pos]; i; i = e[i].nxt) {
			if (find(pos) == find(e[i].to))continue;
			if (siz[find(e[i].to)] != 1) {
				ans[i >> 1] = 1;
				if (siz[find(e[i].to)] > siz[find(pos)]) {
					siz[find(e[i].to)] += siz[find(pos)];
					fa[find(pos)] = find(e[i].to);
				} else {
					siz[find(pos)] += siz[find(e[i].to)];
					fa[find(e[i].to)] = find(pos);
				}
			} else if (e[i].w == col[e[i].to]) {
				siz[find(pos)] += siz[find(e[i].to)];
				fa[find(e[i].to)] = find(pos);
				ans[i >> 1] = 1;
				q.push(e[i].to);
			}
		}
	}
	if (siz[find(1)] == n) {
		puts("Yes");
		for (int i = 1; i <= m; i++)
			if (ans[i]) {
				write(i);
				putchar(' ');
			}
	} else puts("No");
	return 0;
}
```


---

## 作者：Halberd_Cease (赞：0)

首先，因为要用 $n-1$ 条边满足 $n$ 个条件，因此一定有一条及以上的边满足两个条件，也就是一条边的两个端点和这条边同色。

如果不存在这种情况，可以直接输出 `No`。

否则，我们可以找到一个及以上的连通块，满足：连通块中的点和边同色。如果连通块点数为 $x$，那么在其中随便选 $x-1$ 条边可以使这 $x$ 个点全部满足条件。

然后考虑扩展这些连通块使得其它节点满足条件。

从一个红色连通块发散出的边只会有以下几种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ucm4ph7q.png)

前面两种都没啥用，我们每次寻找后面一种的边，即边的颜色和另一个点的颜色相同，然后选择这条边，满足另一个点的条件，打上标记，然后再进行 dfs。

如果 dfs 时发现有一条边连接了两个已经满足条件的点，先不管即可。

对于所有的连通块 dfs 过后，如果有一个点没有被选中，那么直接无解输出 `No`。

否则，图上现在应该是一个森林，我们再枚举一遍所有的边，加入能将两棵树合并在一起的边，最终使森林合并成一整棵树，并查集维护联通块（森林）即可。

---

## 作者：LKY928261 (赞：0)

称一个点“满足条件”，当且仅当该点在当前图中已经有同色边与之相连。

首先贪心地加入与两端点都同色的边，显然不劣。

如果一条边一端连了已经被加过的点，另一端的点与它同色，那么加入这条边同样不劣，直接贪心加入。

此时如果所有点都已经满足条件，只要随意加边使它变成一棵树即可。

反之则一定不存在合法方案，证明如下：

>假设剩下 $k$ 个点。
>
>根据之前的操作方式，可知这 $k$ 点与其余点之间的连边，不会使这 $k$ 个点有同色边相连。
>
>所以需要使用这 $k$ 个点导出子图上的边使 $k$ 个点全部被覆盖。
>
>而最后要求构成一棵生成树，所以导出子图内不能有环，于是其中选出的边数小于 $k$。
>
>由于能使两点满足条件的边已经在之前被选完，所以导出子图内的每条边只能使至多一个点满足条件。
>
>所以剩余点中能满足条件的点数小于 $k$。
>
>所以 `No`。

[赛时 AC 代码](https://atcoder.jp/contests/agc064/submissions/44563000)。

---

## 作者：exCat (赞：0)

注意到能同时满足两个点的边被选进去肯定不劣，我们贪心的先选这样的边。这样图上会形成若干个连通块。

对于一个大于 $1$ 的连通块，里面的点一定都已经被满足了。我们考虑使用类似 boruvka 算法的过程，从一个大连通块出发选择一条能满足一个孤立点的边加入，并将孤立点并入该连通块。有解当且仅当最后所有连通块大小大于 1。我们随便选剩下的边将他们连通即可。

算法的正确性是显然的。由于生成树上没有环，要想每个点都满足，必须选择至少一条同时满足两个点的边。那么一定存在一个合法的生成树通过上述方法拓展到。

---


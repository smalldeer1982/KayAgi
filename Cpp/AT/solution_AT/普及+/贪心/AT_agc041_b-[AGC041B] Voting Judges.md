# [AGC041B] Voting Judges

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc041/tasks/agc041_b

あるコンテストの開催に向けて $ N $ 問の問題が提案されました。はじめ、問題 $ i $ のスコアは整数 $ A_i $ です。

これから、$ M $ 人のジャッジが好きな問題に投票します。各ジャッジは、他のジャッジとは独立にちょうど $ V $ 問を選び、それらの問題のスコアを $ 1 $ ずつ上げます。

$ M $ 人のジャッジ全員が投票を行ったあと、$ N $ 問の問題がスコアの降順に並べられ、最初の $ P $ 問がコンテストの問題セットに採用されます。 同スコアの問題間の順序は、ジャッジ長が任意に決定します。

$ N $ 問のうち、問題セットに採用される可能性を持つ問題は何問あるでしょうか？

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 10^5 $
- $ 1\ \le\ M\ \le\ 10^9 $
- $ 1\ \le\ V\ \le\ N\ -\ 1 $
- $ 1\ \le\ P\ \le\ N\ -\ 1 $
- $ 0\ \le\ A_i\ \le\ 10^9 $

### Sample Explanation 1

$ 1 $ 人しかいないジャッジが問題 $ 2,5 $ に投票した場合、各問のスコアは $ 2 $ $ 2 $ $ 1 $ $ 3 $ $ 1 $ $ 2 $ となり、問題 $ 4 $、そして問題 $ 1,2,6 $ のうちの $ 1 $ 問が採用されます。 ジャッジが問題 $ 3,4 $ に投票した場合、各問のスコアは $ 2 $ $ 1 $ $ 2 $ $ 4 $ $ 0 $ $ 2 $ となり、問題 $ 4 $、そして問題 $ 1,3,6 $ のうちの $ 1 $ 問が採用されます。 よって、問題 $ 1,2,3,4,6 $ には採用される可能性があります。一方で、問題 $ 5 $ には採用される可能性はありません。

### Sample Explanation 2

採用される可能性があるのは問題 $ 1,4,6 $ のみです。

## 样例 #1

### 输入

```
6 1 2 2
2 1 1 3 0 2```

### 输出

```
5```

## 样例 #2

### 输入

```
6 1 5 2
2 1 1 3 0 2```

### 输出

```
3```

## 样例 #3

### 输入

```
10 4 8 5
7 2 3 6 1 6 5 4 6 5```

### 输出

```
8```

# 题解

## 作者：123456zmy (赞：8)

题意：  
给你一个长度为 $N$ 的序列 a，有 $m$ 次操作，每次可以选出 $V$ 个数将其增加 $1$，问有多少个数最后可能排在$P$ 位之前（按值从大到小排序，并列也算）。
___
~~既然最后要排序，那么就先排一下序~~，对于排序后的数组，前 $P$ 位的是肯定可能被选上的，对于第 $P$ 位之后的数则要进行判断。要让 $P$ 位后的数~~咸鱼翻身~~被选上，最优的方案是每次都选这个数和它后面的和 $P-1$ 位及之前的，再把剩下的机会平摊到 $P$ 位到这个数前面一个（不是平均分配，是让最后的结果尽可能平均），如果这样还是不行就是不可能达到的了。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,v,p,a[100001],ans,a1;
bool cmp(int i,int j){return i>j;}
signed main()
{
	scanf("%lld%lld%lld%lld",&n,&m,&v,&p);
	ans=p;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	sort(a+1,a+n+1,cmp);
	for(int i=p+1;i<=n;i++)
	{
		if(a[i]+m<a[p])break;
		if(v<=p+n-i)++ans;
		else if(((v-p-n+i)*m-a1-1)/(i-p)+1+a[p]<=a[i]+m)++ans;
		a1+=a[p]-a[i];
	}
	printf("%lld",ans);
	return 0;
 } 
```

---

## 作者：Erica_N_Contina (赞：0)

# [AGC041B] Voting Judges



## 思路

我们先将数组 $a$ 从大到小排序。

首先确定一点，前 $p$ 个数字是肯定能排到最终的前 $p$ 位的，因为我们只需要每次操作让最前面的 $v$ 个数字 $+1$ 即可。

然后我们考虑第 $p$ 位之后的数字 $i$。如果我们要挑选 $v$ 个数字 $+1$，那么我们肯定不能让其他数字赶超数字 $i$，我们能想到最好的办法就是把 $v$ 中的 $p-1$ 次机会分给第 $1\sim p-1$ 位数字，让数字 $i$ 尽可能去争取第 $p$ 个位置。

数字 $i$ 我们是肯定要 $+1$ 的，然后我们把 $p-1$ 次机会给 $1\sim p-1$ 位数，这样我们就使用了 $p$ 次机会。假设我们现在还有 $v-p$ 次机会，那么这些机会应该怎么浪费（没错就是浪费，因为这些多余的机会~~会破坏我们的计划~~）呢？

我们考虑到 $i$ 后面的数字都要比 $i$ 小，那么我们把它们都 $+1$，因为 $i$ 已经 $+1$ 了，所以 $i$ 和后面的数字的相对位置关系一定不变，于是我们又可以把 $n-i$ 次机会浪费在这些数字上。

最后假设我们还有 $v-p-n+i$ 次机会，那么没有办法，我们只能让 $i$ 前面的数字 $+1$ 了，一旦 $i$ 前面的数字 $+1$，我们让这些数字中的最大值最小，如果最小化的最大值都 $>i$，那么 $i$ 就没有机会做第 $p$ 个数字了。

## 代码

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
using namespace std;

const int N=1e5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

ll n,m,ans,v,p,cha;
ll a[N],b[N];

bool cmp(ll a,ll b){
	return a>b;
}
signed main(){
	cin>>n>>m>>v>>p;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);
	ans=p;
	for(int i=p+1;i<=n;i++){
		if(a[i]+m<a[p])break;//如果加上m次1都赶不上a[p],那就没希望了
		if(v<=p+n-i) {
			ans++;// 没有多余的机会给i前面的
			cha+=a[p]-a[i];
			continue;
		}
		ll t=v-p-n+i;//多余的机会给i前面的
		if((t*m-cha-1)/(i-p)+1+a[p]<=a[i]+m) ans++;//分配给i前面的,p后面的数字,使得这些数字的最大值最小 
		//如果操作后这些数字中的最大值<=i,那么i就可以排到这些数字前面,到位置p 
		cha+=a[p]-a[i];
	}
	
	cout<<ans<<endl;
	return 0;
}

```






---


# [ABC095D] Static Sushi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc095/tasks/arc096_b

日本料理店「停止寿司」は円形のカウンターが一つあるだけのシンプルな店です。カウンターの外周の長さは $ C $ メートルで、カウンターの内部に客が立ち入ることはできません。

中橋くんが入店し、カウンターのそばまで案内されました。いま、カウンター上には $ N $ 貫の寿司が置かれています。そのうち $ i $ 貫目は中橋くんがいる位置から $ x_i $ メートル時計回りに進んだ位置に置かれており、$ v_i $ キロカロリーの栄養価を持ちます。

中橋くんはカウンターの外周を自由に歩き回ることができます。寿司が置かれている位置にたどり着いたら、その寿司を食べて寿司が持つ栄養価を摂取することができます（当然、その寿司は消えます）。ただし、歩く際に $ 1 $ メートルあたり $ 1 $ キロカロリーを消費します。

満足したら、いつでも好きな位置から店を出ることができます（始めにいた位置に戻らなくても構いません）。店を出るまでに最大で差し引き何キロカロリーを摂取することができるでしょうか？すなわち、退店するまでに摂取した栄養価の合計から消費したエネルギーを引いた値の最大値はいくらでしょうか？なお、他に客はおらず、新たな寿司がカウンターに追加されることもないものとします。また、中橋くんは十分な栄養を蓄えているため、どれだけ歩いてエネルギーを消費しても餓死しないものとします。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 2\ <\ =\ C\ <\ =\ 10^{14} $
- $ 1\ <\ =\ x_1\ <\ x_2\ <\ ...\ <\ x_N\ <\ C $
- $ 1\ <\ =\ v_i\ <\ =\ 10^9 $
- 入力中のすべての値は整数である。

### 部分点

- $ N\ <\ =\ 100 $ を満たすテストセットに正解すると、$ 300 $ 点が与えられる。

### Sample Explanation 1

外周 $ 20 $ メートルのカウンターに $ 3 $ 貫の寿司が置かれています。中橋くんの始めの位置から時計回りに $ 2 $ メートル歩くと、$ 80 $ キロカロリーの寿司を食べることができます。さらに時計回りに $ 7 $ メートル歩くと、$ 120 $ キロカロリーの寿司を食べることができます。ここで退店すると、摂取した栄養価の合計は $ 200 $ キロカロリー、消費したエネルギーの合計は $ 9 $ キロカロリーで、差し引き $ 191 $ キロカロリーを摂取することができ、これが最大の値です。

### Sample Explanation 2

$ 2 $ 貫目と $ 3 $ 貫目の寿司の位置が入れ替わりました。再び、中橋くんの始めの位置から時計回りに $ 2 $ メートル歩くと、$ 80 $ キロカロリーの寿司を食べることができます。今回はここで向きを変え、反時計回りに $ 6 $ メートル歩くと、$ 120 $ キロカロリーの寿司を食べることができます。ここで退店すると、摂取した栄養価の合計は $ 200 $ キロカロリー、消費したエネルギーの合計は $ 8 $ キロカロリーで、差し引き $ 192 $ キロカロリーを摂取することができ、これが最大の値です。

### Sample Explanation 3

唯一の寿司が $ 32 $ bit 整数に収まらないほど遠くにあるわりに栄養価が低いため、何もせず直ちに退店するべきです。

### Sample Explanation 4

以上のすべての入力例は、部分点のためのテストセットに含まれます。

## 样例 #1

### 输入

```
3 20
2 80
9 120
16 1```

### 输出

```
191```

## 样例 #2

### 输入

```
3 20
2 80
9 1
16 120```

### 输出

```
192```

## 样例 #3

### 输入

```
1 100000000000000
50000000000000 1```

### 输出

```
0```

## 样例 #4

### 输入

```
15 10000000000
400000000 1000000000
800000000 1000000000
1900000000 1000000000
2400000000 1000000000
2900000000 1000000000
3300000000 1000000000
3700000000 1000000000
3800000000 1000000000
4000000000 1000000000
4100000000 1000000000
5200000000 1000000000
6600000000 1000000000
8000000000 1000000000
9300000000 1000000000
9700000000 1000000000```

### 输出

```
6500000000```

# 题解

## 作者：Helium_zyy (赞：0)

# 思路
这个人只有四种走法：
1. 顺时针走到 $i$ 点。
2. 逆时针走到 $i$ 点。
3. 逆时针走到 $i$ 点，再顺时针走到 $j$ 点。
4. 顺时针走到 $i$ 点，再逆时针走到 $j$ 点。

![](https://cdn.luogu.com.cn/upload/image_hosting/8kwjp5ww.png)

为什么呢？因为例如图 5 ，它的第三步是完全没有必要的，不仅没有摄取任何的热量还浪费热量，可以直接变为图 6 。总之，只需要考虑上述的四种可能。

![](https://cdn.luogu.com.cn/upload/image_hosting/adi8nif8.png)

第一、二种以通过前缀和轻易的用时间复杂度为 $O(N)$ 的代码解决，后两种如果既要枚举 $i$ ，又要枚举 $j$ ，就必须用时间复杂度为 $O(N^2)$ 的代码。而题目告诉我们 $1\le N\le 10^5$ ，也就是说，我们必须找到一个 $O(N)$ 的代码。这时候，我们可以创建一个前缀Max，用来表示从原点到某点的最大收益。
# 代码
```c
#include<stdio.h>
long long x[100010];//从原点到某点的顺时针距离
long long y[100010];//从原点到某点的逆时针距离
long long vs[100010];//顺时针的前缀和
long long vn[100010];//逆时针的前缀和
long long qs[100010];//顺时针的前缀Max
long long qn[100010];//逆时针的前缀Max
long long ans;
long long max(long long a,long long b){
	return (a>b)?a:b;
}
long long max5(long long a,long long b,long long c,long long d,long long e){//判断五个数中的最大值
	return max(a,max(b,max(c,max(d,e))));
}
int main(){
	long long n,c;
	scanf("%lld%lld",&n,&c);
	for(int i=1;i<=n;i++){
		long long v;
		scanf("%lld%lld",&x[i],&v);
		vs[i]=vs[i-1]+v;
		y[i]=c-x[i];
		qs[i]=max(qs[i-1],vs[i]-x[i]);
	}
	for(int i=n;i>=1;i--){
		vn[i]=vs[n]-vs[i-1];//用前缀和的性质直接计算逆时针的前缀和
		qn[i]=max(qn[i+1],vn[i]-y[i]);
	}
	for(int i=1;i<=n;i++){
		ans=max5(ans,vs[i]-x[i],vn[i]-y[i],vn[i]-2*y[i]+qs[i-1],vs[i]-2*x[i]+qn[i+1]);//第二、三个参数分别是一、二种情况，四、五个参数是三、四种情况，以参数四例，用逆时针到i的前缀和减到两倍的到i的距离（走了两次），再加上i-1的前缀Max（不能与i重合），参数五也是类似的思想
	}
	printf("%lld",ans);
	return 0;
}
```
最后，提醒大家，记得开 long long。

---

## 作者：_Imaginary_ (赞：0)



[AT4118](https://www.luogu.com.cn/problem/AT4118)

先看一看[官方题解](https://img.atcoder.jp/arc096/editorial.pdf)在百度翻译后的[结果](https://www.luogu.com.cn/paste/1iq43yzf)：说实话我是没看懂……

注：下面将人名稍作改动

## Problem

有一张超级大的圆桌，周长为 $C$ 米。在圆桌的边缘，摆着 $N$ 盘菜。

一个人要绕着圆桌走，走路会消耗能量，吃菜会摄取能量。

问，最多可以净摄入多少热量，即摄取的热量减去消耗的热量，最大值为多少？

## Solution

我们可以发现，走的路线只有这样几种：

1. `原点->顺时针`

1. `原点->逆时针`

1. `原点->顺时针->原点->逆时针`

1. `原点->逆时针->原点->顺时针`

其中，前两个很好处理，直接枚举到哪一个点就行。

如果三和四也一样处理，显然至少是 $\Theta(n^2)$ 的，只能拿到 300 分。

但是，如果我们只枚举小明顺时针走到哪个点，那么我们求逆时针时只要这样处理就行：

- 预先处理好逆时针走到每一个点时，获得的热量减去失去的热量。

- 接下来，我们只要求一个区间内这个值的最大值就行

- 当然，对于操作 4，我们需要处理的是获得的热量减去失去的热量的两倍（因为走了两遍）。

具体的，当我们枚举到顺时针走到第 $p$ 个点时，我们就考虑 $[p+1,n]$ 这个区间求最大值就行。（注：这里是相对顺时针的标号）

关于静态最大值，我用了 ST 表，但事实上前缀最大值可以不用，白白多了个 $\log$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=100005,LG=17;
int n;
ll C;
ll x[N],a[N],asum[N],atot[N];
ll init_val[N];
ll y[N],b[N],bsum[N];//distance of counterclockwise
/*----------------------------ST------------------------*/
struct ST{
	ll s[N][22];
	void init()
	{
		for(int i=1;i<=n;i++)
			s[i][0]=init_val[i];
		for(int j=1;j<=LG;j++)
			for(int i=1;i+(1<<j)<=n;i++)
				s[i][j]=max(s[i][j-1],s[i+(1<<(j-1))][j-1]);
	}
	ll query(int l,int r)
	{
		if(l>r) return 0ll;
		int k=(int)floor(log(r-l+1)/log(2));
		return max(max(s[l][k],s[r-(1<<k)+1][k]),0ll);
	}	
};
ST c1,c2;//c1: yuanduan-shun-yuandian-ni
//c2: yuandian-ni-yuandian-shun

/*++++++++++++++++++++++++ST++++++++++++++++++++++++++++++*/

int main()
{
	scanf("%d%lld",&n,&C);
	for(int i=1;i<=n;i++) 
	{
		scanf("%lld%lld",&x[i],&a[i]);
		y[n-i+1]=C-x[i];
		b[n-i+1]=a[i];
	}
	for(int i=1;i<=n;i++) bsum[i]=bsum[i-1]+b[i];
	for(int i=1;i<=n;i++) 
	{
		asum[i]=asum[i-1]+a[i];
		atot[i]=asum[i]-x[i];
	}
	for(int i=1;i<=n;i++)
		init_val[i]=bsum[i]-y[i];
	c1.init();
	for(int i=1;i<=n;i++)
		init_val[i]=bsum[i]-y[i]-y[i];
	c2.init();
	ll ans=0;
	for(int i=1;i<=n;i++) ans=max(ans,atot[i]);
	for(int i=1;i<=n;i++) ans=max(ans,bsum[i]-y[i]);
	ll ans1,ans2;
	for(int i=1;i<=n;i++)
	{
		ans1=c1.query(1,n-i)+asum[i]-x[i]-x[i];
		ans2=c2.query(1,n-i)+asum[i]-x[i];
		ans=max(ans,max(ans1,ans2));
	}
	printf("%lld",ans);
	return 0;
}

```

---


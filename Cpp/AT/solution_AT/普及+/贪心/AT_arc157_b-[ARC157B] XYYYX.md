# [ARC157B] XYYYX

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc157/tasks/arc157_b

`X`, `Y` からなる長さ $ N $ の文字列 $ S $ が与えられます． $ S $ 中の相異なる位置にある $ K $ 文字を選び，選んだ文字が `X` であれば `Y` に，`Y` であれば `X` にそれぞれ置き換えます． 置き換えた後の文字列中で `Y` 同士が隣り合う箇所は最大でいくつになるかを求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ K\ \leq\ N $
- $ S $ は `X`, `Y` からなる長さ $ N $ の文字列である．
 
### Sample Explanation 1

選ぶのは $ 1 $ 文字だけです． - $ 1 $ 文字目を選ぶと，置き換えた後の文字列は `YYXYX` となり，$ 1,\ 2 $ 文字目の $ 1 $ 箇所で `Y` 同士が隣り合っています． - $ 2 $ 文字目を選ぶと，置き換えた後の文字列は `XXXYX` となり，`Y` 同士が隣り合っている箇所はありません． - $ 3 $ 文字目を選ぶと，置き換えた後の文字列は `XYYYX` となり，$ 2,\ 3 $ 文字目と $ 3,\ 4 $ 文字目の $ 2 $ 箇所で `Y` 同士が隣り合っています． - $ 4 $ 文字目を選ぶと，置き換えた後の文字列は `XYXXX` となり，`Y` 同士が隣り合っている箇所はありません． - $ 5 $ 文字目を選ぶと，置き換えた後の文字列は `XYXYY` となり，$ 4,\ 5 $ 文字目の $ 1 $ 箇所で `Y` 同士が隣り合っています． 以上より，求める最大値は $ 2 $ です．

### Sample Explanation 2

$ 1,\ 2,\ 3,\ 5 $ 文字目を選んで `YXYYY` とするか，$ 1,\ 3,\ 4,\ 5 $ 文字目を選んで `YYYXY` とするのが最適です． 同じ位置にある文字を複数回選ぶことはできないことに注意してください．

## 样例 #1

### 输入

```
5 1
XYXYX```

### 输出

```
2```

## 样例 #2

### 输入

```
5 4
XYXYX```

### 输出

```
2```

# 题解

## 作者：I_like_magic (赞：1)

这道题其实不难。

首先我们简化问题。

用 $cnt_X$ 表示字符串中字符 `X` 的个数，  
如果 $k \le cnt_X$，那么我们显然要从字符串中找到 $k$ 个 `X`，并将它们变为 `Y`；  
如果 $k > cnt_X$，那么我们可以将问题变为：将字符串中每一位反转，再从新字符串中选取 $n - k$ 个 `X` 变为 `Y`。

然后再来解决问题。

---

下文相邻的一对 `Y` 代表两个 `Y` 之间只有 `X`，或什么字符都没有。

首先特判两种情况：

显而易见地，  
如果 $cnt_X = n$，那么直接输出 $k - 1$。  
如果 $cnt_X = 0$，那么直接输出 $n - k - 1$。  

接下来，我们发现，对于两个相邻的 `Y`，如果它们之间隔着 $a$ 个 `X`，那么，我们用掉 $a$ 次翻转就能对答案增加 $a + 1$ 的贡献。

举例：

对于 `YXXY`，原先这一段的答案为 $0$，翻转中间的 $2$ 个 `X`，答案变为 $3$。  
对于 `YXY`，原先这一段的答案为 $0$，翻转中间的 $1$ 个 `X`，答案变为 $2$。  
对于 `YY`，把原先这一段的答案**当作** $0$，翻转中间的 $0$ 个 `X`，答案变为 $1$。

可见，对于任意的间隔 $a$，全部翻转后都能对答案造成 $a + 1$ 的贡献。

因此，我们需要优先翻转间隔小的一段 `X`，以获得最多的翻转次数，让答案尽可能大。

扫一遍整个字符串，依次把相邻的两个 `Y` 之间的 `X` 数量记录下来，最后再从小到大排序。  
记得到的序列为 $A$，遍历这个序列，如果当前 $A_i \le k$，那么消耗 $A_i$ 次翻转机会，$k - A_i\to k$，并把 $Ans$ 增加 $A_i + 1$；如果 $A_i > k$，那么我们无法把一整段 `X` 翻转完，那么最优的一定是从左到右依次翻转，直到翻转次数用完，而每次对答案的贡献是 $1$，因此这种情况 $Ans$ 直接加 $k$。

如果遍历完了这个序列，$k$ 还有剩余，那么显而易见，答案也是直接加 $k$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200005; // 数据范围
int n, k; // n 代表字符串长度，k 代表翻转次数
string s; // s 为输入的字符串
int cntX; // 统计输入的字符串中 X 的个数
int ans; // 记录答案的变量，初值为 0
vector<int> dis; // 两个相邻 Y 之间 X 个数的序列
int main() {
    cin >> n >> k >> s; // 读入 n, k, s
    for(int i = 0; s[i]; i ++) { // 遍历整个字符串
        if(s[i] == 'X') cntX ++; // 统计 X 的个数 
    }
    if(cntX == 0) { // 特判 1
        printf("%d\n", max(n - k - 1, 0)); // 显而易见的答案
        return 0; // 直接退出程序
    }
    if(cntX == n) { // 特判 2
        printf("%d\n", max(k - 1, 0)); // 显而易见的答案
        return 0; // 直接退出程序
    }
    if(cntX < k) { // 翻转整个字符串，n - k to k
        k = n - k; // 翻转次数也要翻转
        for(int i = 0; s[i]; i ++) {
            s[i] = 'X' + 'Y' - s[i]; // 翻转 s[i]
        }
    }
    int lst = -1; // 表示上一个 Y 的位置
    for(int i = 0; s[i]; i ++) {
        if(s[i] == 'Y') {
            if(lst != -1) { // 特判第一个 Y
                dis.push_back(i - lst - 1); // 两个相邻的 Y 之间 X 的数量
            }
            lst = i; // 更新上一个 Y 的位置
        }
    }
    sort(dis.begin(), dis.end()); // 从小到大排序
    for(int i : dis) { // 遍历序列
        if(k >= i) {
            k -= i; // 使用 i 次翻转
            ans += 1 + i; // 对答案造成 i + 1 的贡献
        }
    }
    ans += k; // 使用剩下的 k 次翻转，对答案造成 k 的贡献
    printf("%d\n", ans); // 输出答案
    return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

# [ARC157B] XYYYX



## 题意

给定一个长为 $n$ 只包含 `X`，`Y` 的字符串 $S$，求翻转 $K$ 位后，子串 `YY` 最多的数量。

例如在 `YYYXYYXX` 中有 $3$ 个 `YY` 子串。

**分类讨论**

我们对操作数量 $K$ 进行分类讨论，记录 `X` 的数量为 $cnt_X$。

- $K≤cnt_X$

这种情况最优的策略当然是只把 `X` 翻转成 `Y`。接下来我们就要考虑选择哪些 `X` 了。

我们发现，在一般情况下，只要我们选择的 `X` 与 `Y` 相邻，那么将这个 `X` 修改为 `Y` 就会产生 $1$ 的贡献。但是特别地，如果这个 `X` 的前后都是 `Y`，那么可以产生 $2$ 的贡献！

意味着我们最差时每次操作产生 $1$ 的贡献。如果我们将一串 `X` 全都变成 `Y`，会得到额外的 $1$ 的贡献。

所以我们把所有连续的 `X` 串预处理出来，优先将短的 `X` 串变成 `Y` 。当处理到操作数量不够时，我们任意选择与 `Y` 相邻的 `X` 即可。

但注意，如果连续的 `X` 串处于开头或者结尾，那么不会产生额外的贡献。所以我们将这种串的优先级放在最后。

- $K>cnt_X$

这种情况意味着我们可以先把整个字符串变成只有 `Y` 字符，然后从中挑选 $K-cnt_X$ 个 `Y` 变成 `X`。很显然，我们在字符串开头或者结尾选择 $K-cnt_X$ 个连续的 `Y` 变成 `X` 即可。

——咦？好像不对哦！题目要求我们每次修改的位置都不同，当我们将所有的 `X` 都修改为 `Y` 后，可供修改的位置只有原来的 `Y` 的位置了。所以我们还需要继续考虑将 `Y` 修改为 `X` 的负贡献。

如果我们将两个 `Y` 之间的 `Y` 修改为 `X` 会有 $-2$ 的贡献，否则会有 $-1$ 的贡献。因此每次开始修改新的一串连续的 `Y`（这里的一串指的是原字符串中）时，会马上产生额外的 $-1$ 的贡献。因此我们尽可能让修改连续起来。这样的话连续修改一段只会额外产生 $-1$ 的贡献。特别的，如果修改的子串位于字符串开头或者结尾，那么不会产生额外的负贡献！（也就是产生的负贡献等于修改长度）所以我们优先修改首尾（如果可行的话）。

**边界处理&&排序**

前面已经说了，将 `X` 修改为 `Y` 时，边界优先级最低。将 `Y` 修改为 `X` 时，边界优先级最高。

在排序时，对于 `X` 串，短的优先。对于 `Y` 串，长的优先。

## Code


**StdCode**

```C++
#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
using namespace std;

const int N=1e6+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

inline int read(){int f=1;int x=0;char c=getchar();while(c<'0'||c>'9'){if(c=='-'){f=-f;}c=getchar();}while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}return x*f;}

int n,k;
char a[N];
int cnty, cntx,pos[N],len[N],ans;

signed main(){
	n = read();
	k = read();
	for(int i = 1 ; i <= n ;++i){
		cin >> a[i];
		if(a[i] == 'Y')pos[++cnty] = i;
		else cntx++;
	} 
	if(k > cntx){
		cntx = 0;
		cnty = 0;
		for(int i = 1 ; i <= n ;++i){
			a[i] = (a[i] == 'X') ? 'Y' : 'X'; 
		}
		for(int i = 1 ; i <= n ;++i){
			if(a[i] == 'Y')	pos[++cnty] = i;
			else ++cntx;
		}
		k = n - k;
	}
	if(cntx == n)
    {
    	cout<<max(0 , k - 1)<<endl;//注意此处取max
    	return 0;
    }
	for (int i = 2; i <= cnty; ++i) len[pos[i] - pos[i - 1] - 1] ++;
	for(int i = 1 ; i <= n && k ;++i){
		while(len[i] && k){
			if (i <= k) 
    			ans += i + 1, k -= i, len[i] --;
    		else 
    			ans += k , k = 0;
		}
	}
	ans += k;
	for(int i = 2 ; i <= cnty ;++i){
		if(pos[i] - pos[i - 1] == 1)++ans;
	}
	cout<<ans<<endl;
	return 0;
} 
```




---

## 作者：Pretharp (赞：0)

不妨先分类讨论，如果原字符串中的 $\texttt{x}$ 的数量等于 $K$，答案显然为 $n - 1$。

如果原字符串中 $\texttt{X}$ 的数量小于 $K$：

- 首先，我们发现将任意一个 $\texttt{X}$ 改为 $\texttt{Y}$ 会对答案产生以下影响：
  - 不产生影响，即当前被修改为 $\texttt{Y}$ 的 $\texttt{X}$ 前后都是 $\texttt{X}$；
  - 使答案增加 $1$，即当前被修改为 $\texttt{Y}$ 的 $\texttt{X}$ 只有前面或只有后面是 $\texttt{Y}$；
  - 使答案增加 $2$，即当前被修改为 $\texttt{Y}$ 的 $\texttt{X}$ 前后都是 $\texttt{Y}$。

- 因此，我们可以将每一段极长的连续 $\texttt{X}$ 预处理出来，优先将所有长度只有 $1$ 的连续 $\texttt{X}$ 修改为 $\texttt{Y}$，之后再将所有长度为 $2$ 的连续 $\texttt{X}$ 修改为 $\texttt{Y}$，以此类推。

如果 $\texttt{X}$ 的数量大于 $K$：

- 考虑到每一次将 $\texttt{Y}$ 修改为 $\texttt{X}$ 都不会使答案更优，因此，我们要尽量减少将 $\texttt{Y}$ 修改为 $\texttt{X}$ 的次数，所以我们先将所有的 $\texttt{X}$ 改为 $\texttt{Y}$。

- 类似于上一种情况，不难发现每一次将 $\texttt{Y}$ 修改为 $\texttt{X}$ 会对答案产生影响：
  - 使答案减少 $2$，即当前被修改为 $\texttt{X}$ 的 $\texttt{Y}$ 前后都是 $\texttt{Y}$；
  - 使答案减少 $1$，即当前被修改为 $\texttt{X}$ 的 $\texttt{Y}$ 只有前面或只有后面是 $\texttt{X}$；
  - 不产生影响，即当前被修改为 $\texttt{X}$ 的 $\texttt{Y}$ 前后都是 $\texttt{X}$。
  
- 因此，我们将所有 $\texttt{X}$ 修改为 $\texttt{Y}$ 后将每一个还可以修改的连续极长 $\texttt{Y}$ 子序列处理出来（也就是原本就是 $\texttt{Y}$），优先将长度最大的子序列中的所有字母修改为 $\texttt{X}$，再将次长的修改为 $\texttt{X}$，以此类推。

代码实现时，注意当前区间位于边界需要特殊处理。

---

## 作者：I_am_sb___ (赞：0)

~~相信这题最大问题应该是翻译出错的问题罢~~

在解决了翻译问题题之后，可以发现这题的思路非常的明显：一定希望字符 $Y$ 可以尽量在一起。换言之，就是在 $Y$ 的个数相同时，其越集中对答案的贡献越大。这是个很显然的结论，所以当得出这个结论之后，应该考虑怎样换可以使得 $Y$ 尽可能的集中，显然，从 $Y$ 的连通块间隔最小到大开始转换可以使得 $Y$ 的连通块个数最少。所以就得出了转换 $X$ 的思路：从 $X$ 的连通块从小往大来换（两边的最后换）。

现在来考虑 $K$ 大于 $X$ 的个数的情况，由于上文中论述的“$Y$ 要尽量连在一起才会使答案变得尽量大”的这个结论，由此得出转换 $Y$ 的思路（先考虑换两边的 $Y$），从大往小换 $Y$ 的连通块。可以发现这个换法和之前 $X$ 的换法是刚好反过来的

---


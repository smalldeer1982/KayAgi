# [ABC001D] 感雨時刻の整理

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc001/tasks/abc001_4

雨の降っていた時刻というのは、降水量と並んで重要です。今、ある $ 1 $ 日の、雨が降っていた時刻に関するメモが見つかったので、これを整理して、雨の降っていた時刻を調べたいと思います。  
  
 整理は、以下の規則に従って行います。

- 感雨時間のメモから、その日 $ 1 $ 日の雨の降っていた時刻を時系列順に出す。日付を超えて降っている雨は、 $ 00:00 $ 降り始めや $ 24:00 $ 降り終わりとして扱われるものとし、日付をまたぐようなメモは入力されない。
- 雨の降り始め・降り終わりはそれぞれ直前・直後の $ 5 $ 分単位の時刻に丸める。例えば、$ 13:23 $ に降り始めて $ 14:01 $ にやんだ雨は、$ 13:20 $ から $ 14:05 $ まで降っていたということにする。
- 丸めた後の結果において、$ 2 $ つ以上のメモに書かれていた感雨時刻が重複した場合、$ 1 $ つの連続した雨とみなす。例えば、$ 11:06 $ に降り始めて $ 11:23 $ にやんだ雨、$ 11:29 $ に降り始めて $ 12:03 $ にやんだ雨、$ 11:48 $ に降り始めて $ 12:10 $ にやんだ雨の $ 3 $ つがあった場合、$ 11:05 $〜$ 11:25 $、$ 11:25 $〜$ 12:05 $、$ 11:45 $〜$ 12:10 $ の $ 3 $ つの雨であるが、時間がかぶっているところをくっつけて $ 11:05 $ から $ 12:10 $ まで降っていた、$ 1 $ つの連続した雨ということにする。
 
  
 メモの内容が入力される時、雨の降っていた時刻を、この規則に合致するよう整理して出力するプログラムを作成してください。 入力は以下の形式で標準入力から与えられる。 > $ N $ $ S_1 $-$ E_1 $ $ S_2 $-$ E_2 $ : $ S_N $-$ E_N $

1. $ 1 $ 行目には、連続して雨の降っていた時刻の数を表す整数 $ N\ (1≦N≦30,000) $ が与えられる。
2. $ 2 $ 行目から $ N+1 $ 行目までの $ N $ 行で、雨の降り始めの時刻と降り終わりの時刻が与えられる。

- この中の $ i\ (1≦i≦N) $ 行目において、雨が降り始めた時刻 $ S_i $ と雨が降り終わった時刻 $ E_i $ がハイフンで区切られて与えられる。
- 時刻 $ S_i $ と $ E_i $ において
- 時刻は必ず $ 4 $ 桁の非負整数で与えられる。
- 時刻の上 $ 2 $ 桁が時間 $ ({\rm\ hour}) $ 、下 $ 2 $ 桁が分 $ ({\rm\ minute}) $ を表す。
- 時刻は $ 0000 $ から $ 2400 $ まで取り得る。ただし下 $ 2 $ 桁の部分が $ 59 $ を超えることはない。
- $ S_i $ が $ E_i $ より前の時刻であることが保証されている。
 

 雨が降っていた時刻を整理して、降り始めの時刻の早い順番に、降り始めた時刻と降り終わりの時刻をハイフンで区切って出力せよ。  
 その際、連続した $ 1 $ つの雨を $ 1 $ 行に出力し、時刻の形式は入力と同じ形式を用いること。  
 また、出力の末尾には改行を入れること。 ```
<pre class="prettyprint linenums">
4
1148-1210
1323-1401
1106-1123
1129-1203
```

- $ 11:48 $〜$ 12:10 $ の間、雨が降っていた。
- $ 13:23 $〜$ 14:01 $ の間、雨が降っていた。
- $ 11:06 $〜$ 11:23 $ の間、雨が降っていた。
- $ 11:29 $〜$ 12:03 $ の間、雨が降っていた。
 
```
<pre class="prettyprint linenums">
1105-1210
1320-1405
```

- 入力を $ 5 $ 分単位に丸めると、順に $ 1145 $-$ 1210 $、$ 1320 $-$ 1405 $、$ 1105 $-$ 1125 $、$ 1125 $-$ 1205 $となる。
- これを降り始めの時刻の早い順に直すと、$ 1105 $-$ 1125 $、$ 1125 $-$ 1205 $、$ 1145 $-$ 1210 $、$ 1320 $-$ 1405 $となる。
- $ 1105 $-$ 1125 $、$ 1125 $-$ 1205 $の $ 2 $ つは、前者の降り終わりの時刻と後者の降り始めの時刻が一致するので、くっついて $ 1105 $-$ 1205 $ となる。
- さらに、$ 1105 $-$ 1205 $ と、$ 1145 $-$ 1210 $ は、後者の降り始めの時刻が前者の降っている時刻の間に入るので、くっついて $ 1105 $-$ 1210 $ となる。
- そのため、結局この例のような出力となる。
- なお、出力は雨の降った時刻の早い順でなければならない。
 
```
<pre class="prettyprint linenums">
1
0000-2400
```

 ```
<pre class="prettyprint linenums">
0000-2400
```

- 一日中雨が降っている場合である。
 
```
<pre class="prettyprint linenums">
6
1157-1306
1159-1307
1158-1259
1230-1240
1157-1306
1315-1317
```

- 全く同じメモが複数存在する場合もある。
 
```
<pre class="prettyprint linenums">
1155-1310
1315-1320
```

# 题解

## 作者：Keids (赞：7)

# AT_abc001_4 感雨時刻の整理

原题链接：<https://atcoder.jp/contests/abc001/tasks/abc001_4>

建议评橙或黄。

因为日语不好导致小错误 WA 了好多发，现已提交题面翻译，希望有所帮助。

这是一道模拟题。

如题意，我们需要整理时间。

对于舍去操作，我们只需要特判个位，按照题意减去或者加上相应的数即可。

特别的，对于某些结束时间的数字，如 `59` 这类，舍入后变成了 `60`。这个时候需要特判并进位，否则就会出现 `11：60` 这样的不合理时间。

对于合并操作，我们按照起始时间排序，记录当前段的左右端点。

若当前段的结束时间早于下一段的起始时间，则直接输出。否则则合并这两段区间。

具体实现如下：

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
struct node{
	int st,la;//起点终点
}e[10000000];
bool cmp(node x,node y){//排序
	return x.st<y.st;
}

void gout(int x,int y){//输出，因为要输出前缀0，所以特判。
	if(x<10)cout<<"0";//按位输出前缀0
	if(x<100)cout<<"0";
	if(x<1000)cout<<"0";
	printf("%d-",x);
	if(y<10)cout<<"0";
	if(y<100)cout<<"0";
	if(y<1000)cout<<"0";
	printf("%d\n",y);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d-%d",&e[i].st,&e[i].la);//输入时间
        //以下为特判
		if(e[i].st%10>0&&e[i].st%10<5){
			e[i].st-=e[i].st%10;
		}
		if(e[i].st%10>5){
			e[i].st=e[i].st-e[i].st%10+5;
		}
		if(e[i].la%10>0&&e[i].la%10<5){
			e[i].la=e[i].la-e[i].la%10+5;
		}
		if(e[i].la%10>5){
			e[i].la=e[i].la-e[i].la%10+10;	
			if(e[i].la%100==60)e[i].la=e[i].la-60+100;//进位
		}			
	}
	sort(e+1,e+n+1,cmp);
	int l=e[1].st,r=e[1].la;//记录起点终点
	for(int i=2;i<=n;i++){
		if(r<e[i].st){//特判两种情况
			gout(l,r);
			l=e[i].st,r=e[i].la;
			continue;
		}
		if(r>=e[i].st&&r<=e[i].la){
			r=e[i].la;
			continue;
		}		
	}
	gout(l,r);//输出最后一段
	return 0;
}
//下面是一组小数据，关于进位的。
/*
2
1255-1259
1533-1659
*/
```



---

## 作者：Ray662 (赞：2)

[洛谷 传送门](https://www.luogu.com.cn/problem/AT_abc001_4) | [AtCoder 传送门](https://atcoder.jp/contests/abc001/tasks/abc001_4)

[更好的阅读体验](https://www.luogu.com.cn/blog/sunrize/abc001d-li-ti-xie)

题目大意：给定 $n$ 个时间点（这里记为起始点 $st_i$ 和终点 $ed_i$），把时间舍或入到五的倍数，同时合并有公共区域的时间以后的时间区间。

$n \le 3 \times 10^4$。

---

### 舍和入

按照题目要求，分两种情况（舍当前位为 $x$）。

- 若为起始时间，则往前舍入成 $5$ 的整数倍；

代码很简单，如果 $x \ge 5$ 则变为 $5$；否则变为 $0$。

```cpp
if (t[i].st[3] >= '5')  t[i].st[3] = '5';
else  t[i].st[3] = '0';
```

- 若为结束时间，则往后舍入成 $5$ 的整数倍；

同样的，若 $1 \le x \le 5$ 则变为 $5$；$x > 5$ 则变为 $0$，同时进一位；若 $x = 0$ 则不变。

**注意！有特殊情况！**

特殊情况是什么？进位会发生意外！

试想，如果分钟数为 $56$，那么执行完后就会变成 $60$，直接挂掉。

所以还要特判一下，如果当前分钟数为 $60$ 了，就把小时数进一位，同时分钟数清零。

```cpp
if (t[i].ed[3] <= '5') { if (t[i].ed[3] != '0')  t[i].ed[3] = '5'; }
else  t[i].ed[3] = '0', t[i].ed[2] ++ ;
if (t[i].ed[2] == '6' && t[i].ed[3] == '0')  (t[i].ed[1] == '9' ? (t[i].ed[1] = '0', t[i].ed[0] ++ ) : (t[i].ed[1] ++ )), t[i].ed[2] = t[i].ed[3] = '0';
```

---

### 合并

先把所有区间排个序，方便扫描。

只有有交集才能合并，所以合并的条件是：$st_i \le ed_i$。

**注意！合并了以后要更新当前区间的右端点，也就是说右端点要和 $ed_i$ 取一个 $\max$**。

如果合并不了呢？那就新开一个区间 $[st_i, ed_i]$。

---

这道题就做完了！


细节问题上面都已经提到，总体复杂度大约是 $O(n \log n)$（sort 的复杂度）。

---

上代码：

```cpp
#include <bits/stdc++.h>
#define _for(i, a, b)  for (int i = (a); i <= (b); i ++ )
#define _all(i, a, b)  for (int i = (a); i >= (b); i -- )
using namespace std;
const int N = 3e4 + 5;
int n, cnt = 1;
string s;
struct str { string st, ed; } t[N];
vector<str> ans;
inline bool rule(str x, str y) {
	if (x.st != y.st)  return x.st < y.st;
	return x.ed < y.ed;
}  // 排序
int main() {
	cin >> n;
	_for (i, 1, n) {  // 舍和入
		cin >> s, t[i].st = s.substr(0, 4), t[i].ed = s.substr(5, 4);
		if (t[i].st[3] >= '5')  t[i].st[3] = '5';
		else  t[i].st[3] = '0';
		if (t[i].ed[3] <= '5') { if (t[i].ed[3] != '0')  t[i].ed[3] = '5'; }
		else  t[i].ed[3] = '0', t[i].ed[2] ++ ;
		// 一定要特判！
		if (t[i].ed[2] == '6' && t[i].ed[3] == '0')  (t[i].ed[1] == '9' ? (t[i].ed[1] = '0', t[i].ed[0] ++ ) : (t[i].ed[1] ++ )), t[i].ed[2] = t[i].ed[3] = '0';
	}
	sort(t + 1, t + n + 1, rule);
	ans.resize(N);
	ans[1] = t[1];
	// 合并
	_for (i, 2, n) {
		if (t[i].st <= ans[cnt].ed)  ans[cnt].ed = max(ans[cnt].ed, t[i].ed);
		else  ans[ ++ cnt] = t[i];
	}
	_for (i, 1, cnt)  cout << ans[i].st << "-" << ans[i].ed << endl;
	return 0;
}
```

---


# [ABC138C] Alchemist

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc138/tasks/abc138_c

あなたは鍋と $ N $ 個の具材を持っています。各具材は *価値* と呼ばれる実数の値を持ち、$ i $ 個目 $ (1\ \leq\ i\ \leq\ N) $ の具材の価値は $ v_i $ です。

$ 2 $ 個の具材を鍋に入れると、それらは消滅して新たに $ 1 $ 個の具材が生成されます。この新たな具材の価値は元の $ 2 $ 個の具材の価値を $ x,\ y $ として $ (x\ +\ y)\ /\ 2 $ であり、この具材を再び鍋に入れることもできます。

この具材の合成を $ N\ -\ 1 $ 回行うと、最後に $ 1 $ 個の具材が残ります。この具材の価値として考えられる最大の値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 50 $
- $ 1\ \leq\ v_i\ \leq\ 1000 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

はじめに持っている具材が $ 2 $ 個の場合、それらをともに鍋に入れるほかありません。価値 $ 3,\ 4 $ の具材から合成される具材の価値は $ (3\ +\ 4)\ /\ 2\ =\ 3.5 $ です。 なお、`3.50001`, `3.49999` などと出力しても正解となります。

### Sample Explanation 2

今回ははじめに $ 3 $ 個の具材を持っており、一度目の合成で鍋にどの具材を入れるかに選択の余地があります。選択肢は次の $ 3 $ 通りです。 - 価値 $ 500,\ 300 $ の具材を入れ、価値 $ (500\ +\ 300)\ /\ 2\ =\ 400 $ の具材を合成する。この場合、次の合成ではこれと価値 $ 200 $ の具材を鍋に入れることになり、価値 $ (400\ +\ 200)\ /\ 2\ =\ 300 $ の具材が合成される。 - 価値 $ 500,\ 200 $ の具材を入れ、価値 $ (500\ +\ 200)\ /\ 2\ =\ 350 $ の具材を合成する。この場合、次の合成ではこれと価値 $ 300 $ の具材を鍋に入れることになり、価値 $ (350\ +\ 300)\ /\ 2\ =\ 325 $ の具材が合成される。 - 価値 $ 300,\ 200 $ の具材を入れ、価値 $ (300\ +\ 200)\ /\ 2\ =\ 250 $ の具材を合成する。この場合、次の合成ではこれと価値 $ 500 $ の具材を鍋に入れることになり、価値 $ (250\ +\ 500)\ /\ 2\ =\ 375 $ の具材が合成される。 よって、最後に残る $ 1 $ 個の具材の価値として考えられる最大の値は $ 375 $ です。 なお、`375.0` などと出力しても正解となります。

## 样例 #1

### 输入

```
2
3 4```

### 输出

```
3.5```

## 样例 #2

### 输入

```
3
500 300 200```

### 输出

```
375```

## 样例 #3

### 输入

```
5
138 138 138 138 138```

### 输出

```
138```

# 题解

## 作者：zjr027 (赞：3)

这道题确实和合并果子很像，

都是每次把最小的两堆（个）东西进行加（求平均值）操作，

直到只剩下一堆（个）东西为止，

因为没有第二堆（个）东西和它进行操作了。

```plain
Q:那一共要进行多少次操作呢？
A:一共 (n - 1) 次操作。
Q:为什么？
A:因为每一次都会有 2 个数被操作成 1 个数，减少了 1 个数，所以一共要操作 (n - 1)/ 1 次，也就是 (n - 1) 次操作。
```

但是这两题有一个区别：

+ 合并果子数据范围： $1 ≤ n ≤ 10000$ ;

+ 本题数据范围： $2 ≤ n ≤ 50$ ;

合并果子可以使用小根堆，这道题肯定也可以。

合并果子的数据范围很大，暴力过不了；

可是这题的数据范围很小，暴力可以过！（great!）

时间复杂度：

+ 小根堆时间复杂度： $O(n\log(n))$ ；

+ 暴力时间复杂度： $O(n^2\log(n))$ ；

小根堆的代码已经有人发了，我就直接发暴力的了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
double a[51]; // 因为在求平均值时可能出现小数，所以要用double类型
int main(){
	int n;
	scanf("%d", &n); // 输入
	for(int i = 1;i <= n;i++){
		scanf("%lf", &a[i]);
	}
	for(int i = 1;i < n;i++){ // 总共会有 (n - 1) 次操作
		sort(a + i, a + n + 1); // 排序
		a[i + 1] = (a[i] + a[i + 1])/ 2.0; // 每次操作：取出数列里最小的两个数进行平均
	}
	printf("%lf\n", a[n]);
	return 0;
}
```

最终测试结果详情如下：

```plain
编程语言：c++11 | 代码长度：311B | 用时：31ms | 内存：3.72MB
```

用时情况也没有那么慢……

---

## 作者：hswfwkj_ (赞：1)

这道题完全没必要用优先队列之类的高端操作，是楼下 dalao 们想太多了，其实我们只需要把输入序列排个序，然后直接计算平均数就行了。

为什么呢？题面翻译是这样写的：每次可以将任意两个数替换成它们的**平均数**。

请注意平均数这个词，这相当于告诉我们：**从小到大排序一遍之后，前两个数的平均数不可能大于序列中这两个数之后其它任意两个数。**

也就是说，排序一遍之后，先把 $a_2$ 更新为 $a_1$ 与 $a_2$ 的平均数，然后把 $a_3$ 更新为 $a_3$ 与 $a_2$ 的平均数 $\cdot\cdot\cdot$ 直到把 $a_n$ 更新为 $a_n$ 与 $a_{n-1}$ 的平均数，最后的 $a_n$ 就是最优解。

那么上面的描述可能有点儿晦涩，那么直接结合代码理解：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm> 
using namespace std;
int n;
double a[60];//记住要用double！
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lf",&a[i]);//读入
	sort(a+1,a+n+1);//排序
	for(int i=2;i<=n;i++)
		a[i]=(a[i-1]+a[i])/2;//求这个数与前一个数的平均数，并且把它的值储存在这个数里
	cout<<a[n]<<endl;
	return 0;
}
```

---

## 作者：A_Đark_Horcrux (赞：1)

这题和合并果子太像了qwq

建一个小根堆，每次把最小的两个拿出来，再把平均数放回去，最后剩下的就是最大值。

证明也如出一辙：

设三个正整数 $x > y > z$

则先合并 $y,z$ 的结果是 $\dfrac{(x+\dfrac{y+z}{2})}{2},$

先合并 $x,y$ 的结果是 $\dfrac{(\dfrac{x+y}{2})+z}{2},$

作差得 $\dfrac{(x+\dfrac{y+z}{2})}{2}-\dfrac{(\dfrac{x+y}{2})+z}{2}=\dfrac{x}{4}-\dfrac{z}{4}>0$

所以先合并 $y,z$ 的结果大于先合并 $x,y$ 的结果。

```cpp
#include<cstdio>
#include<queue>
using namespace std;
typedef double db;
priority_queue<db,vector<db>,greater<db> >a;
int n,i; db x,y;
int main()
{
	scanf("%d",&n);//输入
	while(n--) scanf("%lf",&x),a.push(x);//放进小根堆
	while(a.size()>1)
	{
		x=a.top(); a.pop();
		y=a.top(); a.pop();//拿出最小的两个
		a.push((x+y)/2);//把平均数放进去
	}
	printf("%lf",a.top());//输出最后的结果
	return 0;
}
```


---

## 作者：Starw (赞：0)

### 题目大意：

翻译已经讲得很清楚了，我就不赘述了。

### 思路：

不难想到，两个数字的数值之和越大，平均数就越大（废话），所以我们要使最后取平均值的两个数尽可能的大，而两个相近的数取平均数才能使它们的贡献值最大，所以我们要取两个相近的数的平均值且把大的数排在后面取。

这种操作是不是让我们联想到了[合并果子](https://www.luogu.com.cn/problem/P1090)?

我们可以~~复制合并果子的代码~~像合并果子一样建一个小根堆（优先队列），然后取两个最小的数的平均值，然后再放进去，最后剩下的数就是我们要求的答案。

### 代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<double,vector<double>,greater<double> >q;//建一个小根堆且要用double
int main(){
	int n,x;
	double a,b;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		q.push(x);//入队 
	}
	while(q.size()>1){//如果剩下的数大于1就继续执行 
		a=q.top(),q.pop();//取一个最小的数 
		b=q.top(),q.pop();//再取一个
		q.push((a+b)/2);//把它们的平均值入队 
	}
	printf("%lf\n",q.top());//AT不换行 爆零泪两行
	return 0;
}
```


---

## 作者：MattL (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/AT4822)

看见其他dalao都用小根堆或是n次快排，发一个1次快排的。

题意：把n个数字将任意两个数替换成它们的平均数，求最后剩下的一个数字的最大值。——题目。

其实是每次把两个最小的数替换成它们的平均数。

举个栗子：

$3$

$500$ $300$ $200$（样例2）

其他几篇题解的做法：

1. $500$ $300$ $200$（输入）
2. $200$ $300$ $500$（排序）
3. $250$ $500$（取平均数）
2. $250$ $500$（排序）
2. $375$（取平均数，答案）

实际上大家可以发现步骤4是多余的。

为什么呢？因为$(x<y<z)$ $\dfrac{(x+y)}{2}<z$

所以说，只需要在刚开始时排序就行了。

所以我的做法：

1. $500$ $300$ $200$（输入）
2. $200$ $300$ $500$（排序）
3. $250$ $500$（取平均数）
2. $375$（取平均数，答案）

AC代码如下：

```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
inline ll read(){
   ll s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
void write(long long out){
	if(out<0){putchar('-');out=abs(out);}
	if(out>9)write(out/10);
	printf("%d",out%10);
}
long double n,ans;
double a[55]; //显而易见，样例1是小数
int main()
{
	//freopen("c.in","r",stdin);
	//freopen("c.out","w",stdout);
	n=read();
	int t=n;
	f2(1,t,i)
	{
		a[i]=read();
	}
	sort(a+1,a+t+1);//刚开始是无序的，排序
	ans=a[1];
	f2(2,t,i)
	{
		ans=(ans+a[i])/2;//直接取平均数
	}
	cout<<ans;
	puts("");//岛国题一定要换行
	return 0;
}
```
小根堆时间复杂度： $O(n\log(n))$

n次快排时间复杂度： $O(n^2\log(n))$ 

1次快排时间复杂度： $O(n$ $log(n))$ （和小根堆一样快，可是用的是快排）

~~蒟蒻第一次发题解，请多多关照！~~

---

## 作者：RainFestival (赞：0)

我们用一个小根堆

每次取出最小的 $2$ 个数 $x,y$

然后把 $\frac{x+y}{2}$ 放进小根堆里

最后小根堆里剩下的数就是答案

注意要用 double 存储

代码如下：

```cpp
#include<cstdio>
#include<queue>
int n;
std::priority_queue<double> pq;
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		double x;
		scanf("%lf",&x);
		pq.push(-x);
	}
	while (pq.size()>1)
	{
		double x=-pq.top();pq.pop();
	    double y=-pq.top();pq.pop();
	    pq.push(-(x+y)/2);
	}
	printf("%lf\n",-pq.top());
	return 0;
}
```
然后就AC了

QAQ



---


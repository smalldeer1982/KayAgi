# [ABC329D] Election Quick Report

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc329/tasks/abc329_d

$ 1,\ 2,\ \ldots,\ N $ の番号のついた $ N $ 人の候補者から当選者を $ 1 $ 人選ぶ選挙において、$ M $ 票の投票がありました。

各票ではそれぞれちょうど $ 1 $ 人が投票先として選ばれており、$ i $ 票目の投票先は候補者 $ A_i $ です。

これから $ 1 $ 票目から順に開票を行い、 $ 1 $ 票ごとにその時点で開票が終了した場合の当選者を更新して表示します。

開票された票において最も得票数が多かった候補者が当選となります。ただし、最も得票数が多かった候補者が複数いる場合は、その中で最も番号の小さい候補者が当選となります。

各 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ 1,\ 2,\ \ldots,\ i $ 票目のみを開票した場合の当選者を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,M\ \leq\ 200000 $
- $ 1\ \leq\ A_i\ \leq\ N $
- 入力される数値はすべて整数
 
### Sample Explanation 1

候補者 $ i $ の得票数を $ C_i $ で表すこととします。 - $ 1 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 0,\ 0) $ なので当選者は $ 1 $ です。 - $ 2 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 1,\ 0) $ なので当選者は $ 1 $ です。 - $ 3 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 2,\ 0) $ なので当選者は $ 2 $ です。 - $ 4 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 2,\ 1) $ なので当選者は $ 2 $ です。 - $ 5 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (2,\ 2,\ 1) $ なので当選者は $ 1 $ です。 - $ 6 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (2,\ 2,\ 2) $ なので当選者は $ 1 $ です。 - $ 7 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (2,\ 2,\ 3) $ なので当選者は $ 3 $ です。

## 样例 #1

### 输入

```
3 7
1 2 2 3 1 3 3```

### 输出

```
1
1
2
2
1
1
3```

## 样例 #2

### 输入

```
100 5
100 90 80 70 60```

### 输出

```
100
90
80
70
60```

## 样例 #3

### 输入

```
9 8
8 8 2 2 8 8 2 2```

### 输出

```
8
8
8
2
8
8
8
2```

# 题解

## 作者：rainbow_cat (赞：0)

### Part.1 思路     
这里只需要求票数最大的那个人，再加上 $M\le 2 \times 10^5$ 的数据范围，这很容易让我们想到堆。我们创建一个桶 $bin$，每投出一票就给 $bin_{a_i}$ 加一，再向堆里插入即可。这里由于在票数一样的情况下取编号较小的人，所以需要写一个 `while` 循环判断最小编号。    
### Part.2 代码       
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[200010],num[200010];//num 为桶数组
priority_queue<pair<int,int>>q;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i];
		++num[a[i]];
		q.push({num[a[i]],a[i]});
		int maxn=q.top().first,ans=q.top().second;
		while(q.size()&&q.top().first==maxn)//取编号最小值
		{
			ans=min(ans,q.top().second);
			q.pop();
		}
		q.push({maxn,ans});
		cout<<ans<<'\n';
	}
	return 0;
}
```

---


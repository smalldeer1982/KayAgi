# [ABC333C] Repunit Trio

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_c

十進法ですべての桁の数字が $ 1 $ である整数をレピュニットと呼びます。レピュニットを小さい順に並べると $ 1,11,111,\ldots $ です。

ちょうど $ 3 $ つのレピュニットの和として表せる整数のうち $ N $ 番目に小さいものを求めてください。

## 说明/提示

### 制約

- $ N $ は $ 1 $ 以上 $ 333 $ 以下の整数
 
### Sample Explanation 1

ちょうど $ 3 $ つのレピュニットの和として表せる整数を小さい順に並べると $ 3,13,23,33,113,\ldots $ です。例えば $ 113 $ は $ 113=1+1+111 $ と表せます。 $ 3 $ つのレピュニットは相異ならなくてもよいことに注意してください。

## 样例 #1

### 输入

```
5```

### 输出

```
113```

## 样例 #2

### 输入

```
19```

### 输出

```
2333```

## 样例 #3

### 输入

```
333```

### 输出

```
112222222233```

# 题解

## 作者：XXh0919 (赞：8)

~~打表也能过！~~

这一题看上去晦涩难懂（我读了 20 分钟的题），实际上很简单。

### 大概题意

有一个数列 $A$，按照 $1,11,111,...$ 排列，用这些数的和重新排列一个数列 $B$，如：$A=\{1,11,111,...\}$，$B=\{1+1+1,1+1+11,1+11+11,...\}$，即 $B=\{3,13,23,33,113...\}$，问你在数列 $B$ 中第 $n$ 个数是多少。

首先，我们看到像 $1,11,111...$ 的数列就应该反应过来：如何去计算它？相信很多人已经想到了：$k=k\times10+1$。然后我们用一个数组存这个数列，再用 set 进行一个加和筛选操作，最后打表代码就完成了。

### 打表 Code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;

int a[N];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	a[1]=1;
	for(int i=2;i<=18;i++){
		a[i]=a[i-1]*10+1;		
	}
	set<int>st;
	for(int i=1;i<=18;i++){
		st.insert(a[i]*3);
	}
	for(int i=1;i<=18;i++){
		for(int j=1;j<=18;j++){
			st.insert(a[i]+a[j]*2);
			st.insert(a[i]*2+a[j]);
		}
	}
	for(int i=1;i<=18;i++){
		for(int j=1;j<=18;j++){
			for(int k=1;k<=18;k++){
				st.insert(a[i]+a[j]+a[k]);
			}	
		}
	}
	int n;
	cin>>n;
	int cnt=0;
	for(auto i:st){
		cnt++;
		if(cnt==n){
			cout<<i<<endl;
			return 0;
		}
	}
	return 0;
}
```

### AC Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+15;

int d[N]={0,3,13,23,33,113,123,133,223,233,333,1113,1123,1133,1223,1233,1333,2223,2233,2333,3333,11113,11123,11133,11223,11233,11333,12223,12233,12333,13333,22223,22233,22333,23333,33333,111113,111123,111133,111223,111233,111333,112223,112233,112333,113333,122223,122233,122333,123333,133333,222223,222233,222333,223333,233333,333333,1111113,1111123,1111133,1111223,1111233,1111333,1112223,1112233,1112333,1113333,1122223,1122233,1122333,1123333,1133333,1222223,1222233,1222333,1223333,1233333,1333333,2222223,2222233,2222333,2223333,2233333,2333333,3333333,11111113,11111123,11111133,11111223,11111233,11111333,11112223,11112233,11112333,11113333,11122223,11122233,11122333,11123333,11133333,11222223,11222233,11222333,11223333,11233333,11333333,12222223,12222233,12222333,12223333,12233333,12333333,13333333,22222223,22222233,22222333,22223333,22233333,22333333,23333333,33333333,111111113,111111123,111111133,111111223,111111233,111111333,111112223,111112233,111112333,111113333,111122223,111122233,111122333,111123333,111133333,111222223,111222233,111222333,111223333,111233333,111333333,112222223,112222233,112222333,112223333,112233333,112333333,113333333,122222223,122222233,122222333,122223333,122233333,122333333,123333333,133333333,222222223,222222233,222222333,222223333,222233333,222333333,223333333,233333333,333333333,1111111113,1111111123,1111111133,1111111223,1111111233,1111111333,1111112223,1111112233,1111112333,1111113333,1111122223,1111122233,1111122333,1111123333,1111133333,1111222223,1111222233,1111222333,1111223333,1111233333,1111333333,1112222223,1112222233,1112222333,1112223333,1112233333,1112333333,1113333333,1122222223,1122222233,1122222333,1122223333,1122233333,1122333333,1123333333,1133333333,1222222223,1222222233,1222222333,1222223333,1222233333,1222333333,1223333333,1233333333,1333333333,2222222223,2222222233,2222222333,2222223333,2222233333,2222333333,2223333333,2233333333,2333333333,3333333333,11111111113,11111111123,11111111133,11111111223,11111111233,11111111333,11111112223,11111112233,11111112333,11111113333,11111122223,11111122233,11111122333,11111123333,11111133333,11111222223,11111222233,11111222333,11111223333,11111233333,11111333333,11112222223,11112222233,11112222333,11112223333,11112233333,11112333333,11113333333,11122222223,11122222233,11122222333,11122223333,11122233333,11122333333,11123333333,11133333333,11222222223,11222222233,11222222333,11222223333,11222233333,11222333333,11223333333,11233333333,11333333333,12222222223,12222222233,12222222333,12222223333,12222233333,12222333333,12223333333,12233333333,12333333333,13333333333,22222222223,22222222233,22222222333,22222223333,22222233333,22222333333,22223333333,22233333333,22333333333,23333333333,33333333333,111111111113,111111111123,111111111133,111111111223,111111111233,111111111333,111111112223,111111112233,111111112333,111111113333,111111122223,111111122233,111111122333,111111123333,111111133333,111111222223,111111222233,111111222333,111111223333,111111233333,111111333333,111112222223,111112222233,111112222333,111112223333,111112233333,111112333333,111113333333,111122222223,111122222233,111122222333,111122223333,111122233333,111122333333,111123333333,111133333333,111222222223,111222222233,111222222333,111222223333,111222233333,111222333333,111223333333,111233333333,111333333333,112222222223,112222222233,112222222333,112222223333,112222233333,112222333333,112223333333,112233333333,112333333333,113333333333,122222222223,122222222233,122222222333,122222223333,122222233333,122222333333,122223333333,122233333333,122333333333,123333333333,133333333333,222222222223,222222222233,222222222333,222222223333,222222233333,222222333333,222223333333,222233333333,222333333333,223333333333,233333333333,333333333333,1111111111113,1111111111123,1111111111133,1111111111223,1111111111233,1111111111333,1111111112223,1111111112233,1111111112333,1111111113333,1111111122223,1111111122233,1111111122333,1111111123333,1111111133333,1111111222223,1111111222233,1111111222333,1111111223333,1111111233333,1111111333333,1111112222223,1111112222233,1111112222333,1111112223333,1111112233333,1111112333333,1111113333333,1111122222223,1111122222233,1111122222333,1111122223333,1111122233333,1111122333333,1111123333333,1111133333333,1111222222223,1111222222233,1111222222333,1111222223333,1111222233333,1111222333333,1111223333333,1111233333333,1111333333333,1112222222223,1112222222233,1112222222333,1112222223333,1112222233333,1112222333333,1112223333333,1112233333333,1112333333333,1113333333333,1122222222223,1122222222233,1122222222333,1122222223333,1122222233333,1122222333333,1122223333333,1122233333333,1122333333333,1123333333333,1133333333333,1222222222223,1222222222233,1222222222333,1222222223333,1222222233333,1222222333333,1222223333333,1222233333333,1222333333333,1223333333333,1233333333333,1333333333333,2222222222223,2222222222233,2222222222333,2222222223333,2222222233333,2222222333333,2222223333333,2222233333333,2222333333333,2223333333333,2233333333333,2333333333333,3333333333333,11111111111113,11111111111123,11111111111133,11111111111223,11111111111233,11111111111333,11111111112223,11111111112233,11111111112333,11111111113333,11111111122223,11111111122233,11111111122333,11111111123333,11111111133333,11111111222223,11111111222233,11111111222333,11111111223333,11111111233333,11111111333333,11111112222223,11111112222233,11111112222333,11111112223333,11111112233333,11111112333333,11111113333333,11111122222223,11111122222233,11111122222333,11111122223333,11111122233333,11111122333333,11111123333333,11111133333333,11111222222223,11111222222233,11111222222333,11111222223333,11111222233333,11111222333333,11111223333333,11111233333333,11111333333333,11112222222223,11112222222233,11112222222333,11112222223333,11112222233333,11112222333333,11112223333333,11112233333333,11112333333333,11113333333333,11122222222223,11122222222233,11122222222333,11122222223333,11122222233333,11122222333333,11122223333333,11122233333333,11122333333333,11123333333333,11133333333333,11222222222223,11222222222233,11222222222333,11222222223333,11222222233333,11222222333333,11222223333333,11222233333333,11222333333333,11223333333333,11233333333333,11333333333333,12222222222223,12222222222233,12222222222333,12222222223333,12222222233333,12222222333333,12222223333333,12222233333333,12222333333333,12223333333333,12233333333333,12333333333333,13333333333333,22222222222223,22222222222233,22222222222333,22222222223333,22222222233333,22222222333333,22222223333333,22222233333333,22222333333333,22223333333333,22233333333333,22333333333333,23333333333333,33333333333333,111111111111113,111111111111123,111111111111133,111111111111223,111111111111233,111111111111333,111111111112223,111111111112233,111111111112333,111111111113333,111111111122223,111111111122233,111111111122333,111111111123333,111111111133333,111111111222223,111111111222233,111111111222333,111111111223333,111111111233333,111111111333333,111111112222223,111111112222233,111111112222333,111111112223333,111111112233333,111111112333333,111111113333333,111111122222223,111111122222233,111111122222333,111111122223333,111111122233333,111111122333333,111111123333333,111111133333333,111111222222223,111111222222233,111111222222333,111111222223333,111111222233333,111111222333333,111111223333333,111111233333333,111111333333333,111112222222223,111112222222233,111112222222333,111112222223333,111112222233333,111112222333333,111112223333333,111112233333333,111112333333333,111113333333333,111122222222223,111122222222233,111122222222333,111122222223333,111122222233333,111122222333333,111122223333333,111122233333333,111122333333333,111123333333333,111133333333333,111222222222223,111222222222233,111222222222333,111222222223333,111222222233333,111222222333333,111222223333333,111222233333333,111222333333333,111223333333333,111233333333333,111333333333333,112222222222223,112222222222233,112222222222333,112222222223333,112222222233333,112222222333333,112222223333333,112222233333333,112222333333333,112223333333333,112233333333333,112333333333333,113333333333333,122222222222223,122222222222233,122222222222333,122222222223333,122222222233333,122222222333333,122222223333333,122222233333333,122222333333333,122223333333333,122233333333333,122333333333333,123333333333333,133333333333333,222222222222223,222222222222233,222222222222333,222222222223333,222222222233333,222222222333333,222222223333333,222222233333333,222222333333333,222223333333333,222233333333333,222333333333333,223333333333333,233333333333333,333333333333333,1111111111111113,1111111111111123,1111111111111133,1111111111111223,1111111111111233,1111111111111333,1111111111112223,1111111111112233,1111111111112333,1111111111113333,1111111111122223,1111111111122233,1111111111122333,1111111111123333,1111111111133333,1111111111222223,1111111111222233,1111111111222333,1111111111223333,1111111111233333,1111111111333333,1111111112222223,1111111112222233,1111111112222333,1111111112223333,1111111112233333,1111111112333333,1111111113333333,1111111122222223,1111111122222233,1111111122222333,1111111122223333,1111111122233333,1111111122333333,1111111123333333,1111111133333333,1111111222222223,1111111222222233,1111111222222333,1111111222223333,1111111222233333,1111111222333333,1111111223333333,1111111233333333,1111111333333333,1111112222222223,1111112222222233,1111112222222333,1111112222223333,1111112222233333,1111112222333333,1111112223333333,1111112233333333,1111112333333333,1111113333333333,1111122222222223,1111122222222233,1111122222222333,1111122222223333,1111122222233333,1111122222333333,1111122223333333,1111122233333333,1111122333333333,1111123333333333,1111133333333333,1111222222222223,1111222222222233,1111222222222333,1111222222223333,1111222222233333,1111222222333333,1111222223333333,1111222233333333,1111222333333333,1111223333333333,1111233333333333,1111333333333333,1112222222222223,1112222222222233,1112222222222333,1112222222223333,1112222222233333,1112222222333333,1112222223333333,1112222233333333,1112222333333333,1112223333333333,1112233333333333,1112333333333333,1113333333333333,1122222222222223,1122222222222233,1122222222222333,1122222222223333,1122222222233333,1122222222333333,1122222223333333,1122222233333333,1122222333333333,1122223333333333,1122233333333333,1122333333333333,1123333333333333,1133333333333333,1222222222222223,1222222222222233,1222222222222333,1222222222223333,1222222222233333,1222222222333333,1222222223333333,1222222233333333,1222222333333333,1222223333333333,1222233333333333,1222333333333333,1223333333333333,1233333333333333,1333333333333333,2222222222222223,2222222222222233,2222222222222333,2222222222223333,2222222222233333,2222222222333333,2222222223333333,2222222233333333,2222222333333333,2222223333333333,2222233333333333,2222333333333333,2223333333333333,2233333333333333,2333333333333333,3333333333333333,11111111111111113,11111111111111123,11111111111111133,11111111111111223,11111111111111233,11111111111111333,11111111111112223,11111111111112233,11111111111112333,11111111111113333,11111111111122223,11111111111122233,11111111111122333,11111111111123333,11111111111133333,11111111111222223,11111111111222233,11111111111222333,11111111111223333,11111111111233333,11111111111333333,11111111112222223,11111111112222233,11111111112222333,11111111112223333,11111111112233333,11111111112333333,11111111113333333,11111111122222223,11111111122222233,11111111122222333,11111111122223333,11111111122233333,11111111122333333,11111111123333333,11111111133333333,11111111222222223,11111111222222233,11111111222222333,11111111222223333,11111111222233333,11111111222333333,11111111223333333,11111111233333333,11111111333333333,11111112222222223,11111112222222233,11111112222222333,11111112222223333,11111112222233333,11111112222333333,11111112223333333,11111112233333333,11111112333333333,11111113333333333,11111122222222223,11111122222222233,11111122222222333,11111122222223333,11111122222233333,11111122222333333,11111122223333333,11111122233333333,11111122333333333,11111123333333333,11111133333333333,11111222222222223,11111222222222233,11111222222222333,11111222222223333,11111222222233333,11111222222333333,11111222223333333,11111222233333333,11111222333333333,11111223333333333,11111233333333333,11111333333333333,11112222222222223,11112222222222233,11112222222222333,11112222222223333,11112222222233333,11112222222333333,11112222223333333,11112222233333333,11112222333333333,11112223333333333,11112233333333333,11112333333333333,11113333333333333,11122222222222223,11122222222222233,11122222222222333,11122222222223333,11122222222233333,11122222222333333,11122222223333333,11122222233333333,11122222333333333,11122223333333333,11122233333333333,11122333333333333,11123333333333333,11133333333333333,11222222222222223,11222222222222233,11222222222222333,11222222222223333,11222222222233333,11222222222333333,11222222223333333,11222222233333333,11222222333333333,11222223333333333,11222233333333333,11222333333333333,11223333333333333,11233333333333333,11333333333333333,12222222222222223,12222222222222233,12222222222222333,12222222222223333,12222222222233333,12222222222333333,12222222223333333,12222222233333333,12222222333333333,12222223333333333,12222233333333333,12222333333333333,12223333333333333,12233333333333333,12333333333333333,13333333333333333,22222222222222223,22222222222222233,22222222222222333,22222222222223333,22222222222233333,22222222222333333,22222222223333333,22222222233333333,22222222333333333,22222223333333333,22222233333333333,22222333333333333,22223333333333333,22233333333333333,22333333333333333,23333333333333333,33333333333333333,111111111111111113,111111111111111123,111111111111111133,111111111111111223,111111111111111233,111111111111111333,111111111111112223,111111111111112233,111111111111112333,111111111111113333,111111111111122223,111111111111122233,111111111111122333,111111111111123333,111111111111133333,111111111111222223,111111111111222233,111111111111222333,111111111111223333,111111111111233333,111111111111333333,111111111112222223,111111111112222233,111111111112222333,111111111112223333,111111111112233333,111111111112333333,111111111113333333,111111111122222223,111111111122222233,111111111122222333,111111111122223333,111111111122233333,111111111122333333,111111111123333333,111111111133333333,111111111222222223,111111111222222233,111111111222222333,111111111222223333,111111111222233333,111111111222333333,111111111223333333,111111111233333333,111111111333333333,111111112222222223,111111112222222233,111111112222222333,111111112222223333,111111112222233333,111111112222333333,111111112223333333,111111112233333333,111111112333333333,111111113333333333,111111122222222223,111111122222222233,111111122222222333,111111122222223333,111111122222233333,111111122222333333,111111122223333333,111111122233333333,111111122333333333,111111123333333333,111111133333333333,111111222222222223,111111222222222233,111111222222222333,111111222222223333,111111222222233333,111111222222333333,111111222223333333,111111222233333333,111111222333333333,111111223333333333,111111233333333333,111111333333333333,111112222222222223,111112222222222233,111112222222222333,111112222222223333,111112222222233333,111112222222333333,111112222223333333,111112222233333333,111112222333333333,111112223333333333,111112233333333333,111112333333333333,111113333333333333,111122222222222223,111122222222222233,111122222222222333,111122222222223333,111122222222233333,111122222222333333,111122222223333333,111122222233333333,111122222333333333,111122223333333333,111122233333333333,111122333333333333,111123333333333333,111133333333333333,111222222222222223,111222222222222233,111222222222222333,111222222222223333,111222222222233333,111222222222333333,111222222223333333,111222222233333333,111222222333333333,111222223333333333,111222233333333333,111222333333333333,111223333333333333,111233333333333333,111333333333333333,112222222222222223,112222222222222233,112222222222222333,112222222222223333,112222222222233333,112222222222333333,112222222223333333,112222222233333333,112222222333333333,112222223333333333,112222233333333333,112222333333333333,112223333333333333,112233333333333333,112333333333333333,113333333333333333,122222222222222223,122222222222222233,122222222222222333,122222222222223333,122222222222233333,122222222222333333,122222222223333333,122222222233333333,122222222333333333,122222223333333333,122222233333333333,122222333333333333,122223333333333333,122233333333333333,122333333333333333,123333333333333333,133333333333333333,222222222222222223,222222222222222233,222222222222222333,222222222222223333,222222222222233333,222222222222333333,222222222223333333,222222222233333333,222222222333333333,222222223333333333,222222233333333333,222222333333333333,222223333333333333,222233333333333333,222333333333333333,223333333333333333,233333333333333333,333333333333333333};//打表
int n;

signed main(){
	scanf("%lld",&n);
	printf("%lld\n",d[n]);
	return 0;
}
```

---

## 作者：skyskyCCC (赞：3)

## 前言。
第一次在 $15$ 分钟内干掉 $C$ 题，纪念一下。
## 分析。
我们将前几个数列出来：
```
3  =1  + 1  + 1;
-----------------------
13 =11 + 1  + 1;
23 =11 + 11 + 1;
33 =11 + 11 + 11;
-----------------------
113=111+ 1  + 1;
123=111+ 11 + 1;
133=111+ 11 + 11；
223=111+ 111+ 1；
233=111+ 111+ 11；
333=111+ 111+ 111；
```
我们发现其实有一些规律。显然我们当固定前两个加数时，最后的加数肯定是从 $1$ 开始然后一直加到和第二个加数相同，然后第二个加数再变化。我们考虑将每一个加数拆出来，一个个考虑。首先我们令最开头的那个数是 $a_1$ 同时第二个数是 $a_2$ 然后第三个数是 $a_3$。那么有一个很显然的特征是在一个循环中，每次的 $a_1$ 都是不变的，只有 $a_2$ 和 $a_3$ 是变换的，同时只有当 $a_1=a_2=a_3$ 时达到当前 $a_1$ 对应的最大数，此时就更新 $a_1$ 的值。那么我们只需要考虑 $a_2$ 和 $a_3$ 的变化规律即可。

我们发现只要 $a_2=a_3$ 时，此时因为 $a_2$ 是固定的，所以到达当前 $a_2$ 对应的最大值，此时我们在调整 $a_3$ 让它等于 $1$ 的同时在将 $a_2$ 调整即可。

简单来说，就是当 $a_2=a_3$ 时，我们将 $a_2$ 扩大 $10$ 倍并加上一，再将 $a_3$ 变成 $1$ 即可。如果 $a_2=a_3$ 我们就需要更新 $a_1$ 并且将 $a_2$ 和 $a_3$ 都更新为一即可。对于判断，我们可以统计面前每一个加数都变化了几次。

时间复杂度是很优秀的 $O\left(n\right)$ 对于通过本题绰绰有余。

代码如下，仅供参考：
```
#include <iostream>
#include <queue>
#include <set>
using namespace std;
typedef long long ll;
int n;
long long a[350];
long long a1=1,a2=1,a3=1;
long long sum,tot,cut;
long long k[]={1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286, 364, 455, 560, 680, 816, 969, 1140, 1330, 1540, 1771, 2024, 2300, 2600, 2925, 3276, 3654, 4060, 4495, 4960, 5456, 5984, 6545, 7140, 7770, 8436, 9139, 9880, 10660, 11480, 12341, 13244, 14190, 15180};
int main(){
	sum=1;
	cut=1;
	tot=1;//初始化都在第一次变换。
	cin>>n;
    for (int i=1;i<=n;i++){
    	a[i]=a1+a2+a3;
    	//cout<<a[i]<<" ";
		if(tot<sum){//前两个加数固定。
			a3=a3*10+1;
			tot++;//变化第三个加数并记录变换次数。
			continue;
		}
		else{
			if(sum<cut){
			    sum++;
			    tot=1;
			    a2=a2*10+1;
			    a3=1;//同理。
			    continue;
			}
			else{
				cut++;
				sum=1;
				tot=1;
				a1=a1*10+1;
				a2=1;
				a3=1;//注意重新变换。
				continue;
			}
		}
	}
	cout<<a[n]<<" ";
	return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：封禁用户 (赞：3)

## 题意
一个 repunit 是一个整数，其十进制数位都是 $1$。按升序排列的 repunits 是 $1, 11, 111, \ldots$。

求可以表示为恰好三个 repunits 之和的第 $N$ 个最小整数。

## 思路

赛时我这道题的思路是打表，这里给出打表程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int qwq[]={0,1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111,111111111111};
int a[10000];
signed main(){
	int cnt=0;
	for(int i=1;i<=12;++i){
		for(int j=1;j<=12;++j){
			for(int k=1;k<=12;++k){
				++cnt;
				a[cnt]=qwq[i]+qwq[j]+qwq[k];
			}
		}
	}
	sort(a+1,a+cnt+1);
	int hhh=unique(a+1,a+cnt+1)-a;
	for(int i=1;i<hhh;++i){
		cout<<a[i]<<',';
	}cout<<endl;
	cout<<hhh<<endl;//仅仅是调试
	return 0;
}

```
上面这个程序就是三重循环枚举每一个 repunit，把答案排序去重，然后输出（$a_{i}$ 表示第 $i$ 个满足条件的数）。

这里是完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[10000]={0,3,13,23,33,113,123,133,223,233,333,1113,1123,1133,1223,1233,1333,2223,2233,2333,3333,11113,11123,11133,11223,11233,11333,12223,12233,12333,13333,22223,22233,22333,23333,33333,111113,111123,111133,111223,111233,111333,112223,112233,112333,113333,122223,122233,122333,123333,133333,222223,222233,222333,223333,233333,333333,1111113,1111123,1111133,1111223,1111233,1111333,1112223,1112233,1112333,1113333,1122223,1122233,1122333,1123333,1133333,1222223,1222233,1222333,1223333,1233333,1333333,2222223,2222233,2222333,2223333,2233333,2333333,3333333,11111113,11111123,11111133,11111223,11111233,11111333,11112223,11112233,11112333,11113333,11122223,11122233,11122333,11123333,11133333,11222223,11222233,11222333,11223333,11233333,11333333,12222223,12222233,12222333,12223333,12233333,12333333,13333333,22222223,22222233,22222333,22223333,22233333,22333333,23333333,33333333,111111113,111111123,111111133,111111223,111111233,111111333,111112223,111112233,111112333,111113333,111122223,111122233,111122333,111123333,111133333,111222223,111222233,111222333,111223333,111233333,111333333,112222223,112222233,112222333,112223333,112233333,112333333,113333333,122222223,122222233,122222333,122223333,122233333,122333333,123333333,133333333,222222223,222222233,222222333,222223333,222233333,222333333,223333333,233333333,333333333,1111111113,1111111123,1111111133,1111111223,1111111233,1111111333,1111112223,1111112233,1111112333,1111113333,1111122223,1111122233,1111122333,1111123333,1111133333,1111222223,1111222233,1111222333,1111223333,1111233333,1111333333,1112222223,1112222233,1112222333,1112223333,1112233333,1112333333,1113333333,1122222223,1122222233,1122222333,1122223333,1122233333,1122333333,1123333333,1133333333,1222222223,1222222233,1222222333,1222223333,1222233333,1222333333,1223333333,1233333333,1333333333,2222222223,2222222233,2222222333,2222223333,2222233333,2222333333,2223333333,2233333333,2333333333,3333333333,11111111113,11111111123,11111111133,11111111223,11111111233,11111111333,11111112223,11111112233,11111112333,11111113333,11111122223,11111122233,11111122333,11111123333,11111133333,11111222223,11111222233,11111222333,11111223333,11111233333,11111333333,11112222223,11112222233,11112222333,11112223333,11112233333,11112333333,11113333333,11122222223,11122222233,11122222333,11122223333,11122233333,11122333333,11123333333,11133333333,11222222223,11222222233,11222222333,11222223333,11222233333,11222333333,11223333333,11233333333,11333333333,12222222223,12222222233,12222222333,12222223333,12222233333,12222333333,12223333333,12233333333,12333333333,13333333333,22222222223,22222222233,22222222333,22222223333,22222233333,22222333333,22223333333,22233333333,22333333333,23333333333,33333333333,111111111113,111111111123,111111111133,111111111223,111111111233,111111111333,111111112223,111111112233,111111112333,111111113333,111111122223,111111122233,111111122333,111111123333,111111133333,111111222223,111111222233,111111222333,111111223333,111111233333,111111333333,111112222223,111112222233,111112222333,111112223333,111112233333,111112333333,111113333333,111122222223,111122222233,111122222333,111122223333,111122233333,111122333333,111123333333,111133333333,111222222223,111222222233,111222222333,111222223333,111222233333,111222333333,111223333333,111233333333,111333333333,112222222223,112222222233,112222222333,112222223333,112222233333,112222333333,112223333333,112233333333,112333333333,113333333333,122222222223,122222222233,122222222333,122222223333,122222233333,122222333333,122223333333,122233333333,122333333333,123333333333,133333333333,222222222223,222222222233,222222222333,222222223333,222222233333,222222333333,222223333333,222233333333,222333333333,223333333333,233333333333,333333333333};
signed main(){
	int n;
	scanf("%lld",&n);
	printf("%lld\n",a[n]);
	return 0;
}
```

---

## 作者：A_R_O_N_A (赞：3)

## 题意

现在有一堆数字，全部由 $1$ 组成（如 $1,11,111,1111\dots$）。

现在找出第 $n$ 小的可以表示为三个这些数之和的数。

可以重复选择。

## 思路

注意到 $n\le 333$，范围极小，可以枚举出每一个符合条件的数字然后再选择第 $n$ 小的即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[20],res;
vector<ll>v;
int main(){
	cin>>n;
	for(int i=1;i<=17;i++)a[i]=a[i-1]*10+1;//预处理出需要用的数字
	for(int i=1;i<=17;i++){
		for(int j=1;j<=17;j++){
			for(int k=1;k<=17;k++){
				res=a[i]+a[j]+a[k];
				v.push_back(res);//枚举每一种符合条件的数字并存储进数组
			}
		}
	}
	sort(v.begin(),v.end());//排序
	unique(v.begin(),v.end());//枚举的数字有重复的，所以去重
	cout<<v[n-1];//下标从零开始，所以要减一
	return 0;
}
```


---

## 作者：Hughpig (赞：2)

发现第 $x$ 个 $\text{Repunit}$ 数是第 $x-1$ 个 $\text{Repunit}$ 数约十倍，因此一个 $\text{Repunit}$ 数必然大于 $3$ 个小于它的 $\text{Repunit}$ 数的和。

观察样例发现第 $333$ 个 $\text{Repunit}$ 数也只有 $12$ 位，并不是很大，因此考虑生成前 $12$ 个 $\text{Repunit}$ 数然后枚举所有可以表示为三个 $\text{Repunit}$ 数的和的数并排序，然后直接输出即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

ll n,qwq[20],s[8007],x,cnt;

void pre(){
	for(int i=1;i<=15;i++)qwq[i]=qwq[i-1]*10ll+1;
}

int main()
{
	ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
	cin>>n;
	pre();
	for(int i=1;i<=13;i++){
		for(int j=i;j<=13;j++){
			for(int k=j;k<=13;k++){
				x=qwq[i]+qwq[j]+qwq[k];
				s[++cnt]=x;
			}
		}
	}
	sort(s+1,s+cnt+1);
	cout<<s[n];
	return 0;
}
```

---

## 作者：yszkddzyh (赞：1)

发现符合条件的数组成了以下数列：
$$3,13,23,33,113,123,133,223,233,333,\cdots$$
我们可以按位数分组：

第 $1$ 组：$3$。

第 $2$ 组：$13,23,33$。

第 $3$ 组：$113,123,133,223,233,333$。

以此类推。容易发现第 $t$ 组有 $\frac{t(t+1)}{2}$ 个数，我们想要求出第 $n$ 小的符合条件的数，可以先找出该数在哪一组，即求出其有多少位，然后 dfs，求出答案。

**下面讲如何找出该数在哪一组**。先给代码：
```cpp
int n, t;  //t记录组的编号，即答案的位数
cin >> n;
for(t = 0; ; t++){
	if(t * (t + 1) * (t + 2) / 6 >= n){
		n = n - (t - 1) * (t - 1 + 1) * (t - 1 + 2) / 6;
        	/*这一步将n的意义从“所有符合要求的数中的排名”
            变成了“在它所在的那一组中的排名”，注意所有t要减1*/
		break;
	}
}
```
其实我们只要求出每组数前面有多少符合要求的数即可。定义 $S_t$ 为第 $t$ 组之前（包括第 $t$ 组）有多少符合要求的数，那么从小到大枚举（其实可以二分）组的编号 $t$，一旦 $S_t$ 大于 $n$，退出，此时的 $t$ 即为 $n$ 所在组数编号。而对于 $S_t$，有：

$$\begin{aligned} S_t &= \sum_{i=1}^{t}\frac{i(i+1)}{2} \\ &=\frac{(\sum_{i=1}^{t}i^2)+(\sum_{i=1}^{t}i)}{2} \\ &= \frac{\frac{1}{6}t(t+1)(2t+1)+\frac{1}{2}t(t+1)}{2} \\ &= \frac{1}{6}t(t+1)(t+2) \end{aligned}$$

这样我们就得到了上面的代码。

**接下来讲 dfs**。

发现每组中的数都是“不下降”的，且最后一位是 $3$。

代码：
```cpp
const int N = 15;
int n, t, tot, a[N];
//n与t意义同上，a记录dfs到目前所形成的数
//tot记录已经形成多少个符合要求的数了
void dfs(int st, int num){
//st是dfs到第几位了（从高往低）
//num是这一位要填几
	a[st] = num;//把这一位填上
	if(st == t){//达到长度，填完了
		tot++;//符合要求的数的个数加一
		if(tot == n){//达到了该组第n小
			for(int i = 1; i <= t; i++)
				cout << a[i];
			exit(0);
		}
		a[st] = 0;//还原这一位，不要也可
		return;
	}
	if(st == t - 1) dfs(st + 1, 3);//最后一位是3
	else{
		for(int i = num; i <= 3; i++)//由于不下降，i从num开始
			dfs(st + 1, i);
	}
	a[st] = 0;//还原这一位，不要也可
	return;
}
dfs(0,1);//想想第0位为何要填1？
```

这是较为简单的 dfs，考验码力。

这种题思路与实现方法一般很多，实在理解不了我的思路或代码也没关系。[完整代码](https://www.luogu.com.cn/paste/hjoq2x7t)。

---

## 作者：2c_s (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/AT_abc333_c)

## 思路

用 set 插入前 $333$ 个符合要求的序列数字和，之后循环 $N$ 次找到 set 中第 $N$ 个数即可。

第 $333$ 个符合要求的序列数字约为 $10^{12}$，所以我们只需要找 $13$ 个每位全为一的数字进行枚举（多了会爆 long long，而且 TLE）。

插入 set 时可以用三重循环暴力枚举每个数字，加和后插入 set。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=400;
ll n,dp[N];//dp[] 是每位全为一的数字的数组。
set<ll>st;
int main(){
	dp[0]=1;
	for(int i=1;i<12;++i)dp[i]=dp[i-1]+pow(10,i);
	cin>>n;
	for(int i=0;i<12;++i){//三重循环暴力枚举。
		for(int j=0;j<12;++j){
			for(int k=0;k<12;++k)st.insert(dp[i]+dp[j]+dp[k]);
		}
	}
	auto p=st.begin();
	for(int i=1;i<n;++i)++p;
	cout<<*p;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/139916581)

---

## 作者：heyx0201 (赞：1)

# ABC333C Repunit Trio 题解
## Description
> 给定 $N$，求第 $N$ 小的由 $3$ 个十进制下全为 $1$ 的数相加的数。

## Solution
这题数据只有 $333$，可以 $3$ 重循环枚举三个数，然后相加，最后排序去重，输出第 $N$ 个即可。

## Accept Code
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e6 + 10;

int n;
long long ans[MAXN], tot;

int main() {
  cin >> n;
  for (long long i = 1, ii = 1; i <= 12; i++, ii = ii * 10 + 1) {
    for (long long j = 1, jj = 1; j <= 12; j++, jj = jj * 10 + 1) {
      for (long long k = 1, kk = 1; k <= 12; k++, kk = kk * 10 + 1) {
        ans[++tot] = ii + jj + kk;
      }
    }
  }
  sort(ans + 1, ans + tot + 1);
  int l = unique(ans + 1, ans + tot + 1) - ans;
  cout << ans[n];
  return 0;
}
```

---

## 作者：BugGod (赞：0)

提供一种毫无思维含量的解法。

看到选数，想到枚举子集（状压），又看到数据很小，直接确定做法。由于这道题每个数可以选 $0\sim 3$ 遍，所以是四进制。然后枚举状态，如果选了 $3$ 次，就记录答案。为了保险，从小到大排序一下。

注意我们并不确定要算到什么状态，所以可以直接来个大的，算到 $n$ 个 `break` 就可以了。

CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
void IOS()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
}
int spl[20];//题中定义的数
int sum[100010];
int n,cnt;
int qpow(int a,int b)
{
	if(b==0)return 1;
	if(b==1)return a;
	int k=qpow(a,b>>1);
	return k*k*qpow(a,b&1);
}
signed main()
{
	cin>>n;
	for(int i=1;i<=15;i++)spl[i]=spl[i-1]*10+1;
	for(int ss=0;ss<qpow(4,12)-1;ss++)
	{
		int su=0,s=ss,ct=0,cc=0;
		while(s)
		{
			su+=(s%4)*spl[++ct];
			cc+=s%4;
			s/=4;
		}//四进制分解
		if(cc==3)sum[++cnt]=su;
		if(cnt==333)break;
	}
	sort(sum+1,sum+1+cnt);
	//for(int i=1;i<=10;i++)cout<<sum[i]<<' ';
	//cout<<'\n';
	cout<<sum[n];
	return 0;
}
```

---

## 作者：_colin1112_ (赞：0)

## 思路

用一个数组 $a$ 存有着 $1$ 个 $1$ 到 $12$ 个 $1$ 的数组，然后用三重循环把他们的所有可能存在一个 `set` 当中，最后 `auto` 遍历整个数组遍历到第 $n$ 个数时，输出即可。

## Code

```c++
#include <bits/stdc++.h>
#define endl '\n'
#define ll long long
#define IO ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);

using namespace std;
const int E=1e6+5;
ll n,cnt;
ll a[E]={0,1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111,111111111111};
int main(){
    IO;
    set <ll> ans;
    cin >>n;
    for(int i=1;i<=12;i++)
        for(int j=1;j<=12;j++)
            for(int k=1;k<=12;k++)
                ans.insert(a[i]+a[j]+a[k]);
    for(auto v:ans){
        cnt++;
        if(cnt==n){
            cout <<v;
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：yhx0322 (赞：0)

## Description
给出一个数字 $N$，求：第 $N$ 小的用三个数相加的和，每个数必须是由重复的 $1$ 构成，例如 $1,11,111$。

## Solution
我们发现 $1 \le N \le 333$，答案范围不是特别大，想到了用 `vector` 预处理出所有的答案，排序之后取第 $N$ 个。

注意枚举的时候由于只有三个加数，直接三重 `for` 循环就可以了。

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 111111111111;
vector <long long> v;
int n;
int main() {
	cin >> n;
    // 暴力枚举即可
	for (long long i = 1; i <= N; i = i * 10 + 1) {
		for (long long j = 1; j <= N; j = j * 10 + 1) {
			for (long long k = 1; k <= N; k = k * 10 + 1) {
				v.push_back(i + j + k);
			}
		}
	}
	sort(v.begin(), v.end());
	auto k = unique(v.begin(), v.end()); // 注意要去重！
	cout << v[--n]; // 由于 vector 下标从 0 开始，所以要 --n
	return 0;
}
```

---

## 作者：wmrqwq (赞：0)

# 题目链接

[[ABC333C] Repunit Trio](https://www.luogu.com.cn/problem/AT_abc333_c)

# 题意简述

定义一种数为 `repunit` 数当且仅当这个数字在十进制表示下全为 $1$，求由三个 `repunit` 数加起来的第 $n$ 小的值。

# 解题思路

我们可以发现数据范围为 $1 \le n \le 333$，因为这一点，我们可以直接预处理前 $333$ 个数字，在这过程中要注意去重。

# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define map unordered_map
#define forl(i,a,b) for(register long long i=a;i<=b;i++)
#define forr(i,a,b) for(register long long i=a;i>=b;i--)
#define lc(x) x<<1
#define rc(x) x<<1|1
#define cin(x) scanf("%lld",&x)
#define cout(x) printf("%lld",x)
#define lowbit(x) x&-x
#define pb push_back
#define pf push_front
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define endl printf("\n")
#define QwQ return 0;
long long a[100010],ans[100010],k,kkk,n;
long long f(long long x)
{
	long long pw=1,sum=0;
	forl(i,1,x)
		sum+=pw,pw*=10;
	return sum;
}
void init()
{
	forl(i,1,18)
		forl(j,1,18)
			forl(kk,1,18)
				a[++k]=f(i)+f(j)+f(kk);
	sort(a+1,a+1+k);
	forl(i,1,k)
		if(a[i]!=a[i-1])
			ans[++kkk]=a[i];
}
int main()
{
	IOS;
	init();
	cin>>n;
	cout<<ans[n];
	QwQ;
}
```

---

## 作者：Escapism (赞：0)

[传送门](https://atcoder.jp/contests/abc333/tasks/abc333_c)

# 题意

有一种好数，它们的数位全部都是 $1$，具体而言的好数就是：$1,11,111,1111$，以此类推。

现在我们将可以由恰好三个好数相加得到的数从小到大排成一个序列，问这个序列中的第 $n$ 个数是什么。

# 思路

由于 $n$ 的范围很小，并且可以由第三个样例发现实际上最大可能出现的好数就是 $111111111111$，这说明序列中所有的数的范围都在 long long 以内。并且实际上

那么我们直接暴力枚举三个好数分别是哪三个，由于实际上只会出现 $12$ 个好数，暴力枚举的次数只需要 ${12}^3$ 次，绰绰有余。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

long long num[20] = {0,1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111,111111111111}; //打表
long long a[114514];
map<long long,bool> mp; //去重用的 map

int main(){
    int tmp = 0;
    for (int i = 1;i <= 12;i++){
        for (int j = 1;j <= 12;j++){
            for (int k = 1;k <= 12;k++){
                long long t = num[i] + num[j] + num[k];
                if (mp[t] == false){ //去重
                    a[++tmp] = t; //加入数组
                    mp[t] = true;
                }
            }
        }
    }
    //cout<<tmp<<endl;
    sort(a + 1,a + tmp + 1); //排序
    int n;
    cin>>n;
    cout<<a[n]<<endl;
}
```



---

## 作者：jess1ca1o0g3 (赞：0)

[Portal(AT)](https://atcoder.jp/contests/abc333/tasks/abc333_c)

[Portal(Luogu)](https://www.luogu.com.cn/problem/AT_abc333_c)

## 思路

我刚看到这题就想到了**搜索**。

具体如下，搜出所有的**三个 repunits 之和**，输出第 $n$ 项，这样就完成了。

不过需要排序和去重，如果开 `bool` 数组（桶），观察样例3可知**三个 repunits 之和**最高可达 $10^{12}$ 左右，不可能开这么大的数组。

所以经过深思熟虑，我决定。。。

用 STL！！！

## Code

(~~非常抽象~~~)

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long n,i,f[265720];
void dfs(long long x,long long y,long long z){
    // 退出条件
	if(x>11111111111111||y>11111111111111||z>111111111111) return;
	long long s=0;
	s+=x;s+=y;s+=z;
	f[i++]=s;
    // 递归搜索
	dfs(x,y,z*10+1);
	dfs(x,y*10+1,z*10+1);
	dfs(x*10+1,y*10+1,z*10+1);
}
signed main(){
	cin>>n;
	dfs(1,1,1);
    // 排序和去重
	sort(f,f+265720);
	unique(f,f+265720)-f;
	cout<<f[n-1];
}
```

王姐，撒花。

---

## 作者：tbdsh (赞：0)

# 题意简述
[洛谷原题面](//www.luogu.com.cn/problem/at_abc333_c)

[AtCoder 原题面](https://atcoder.jp/contests/abc333/tasks/abc333_c)

定义“好数”是各个数位上都是 $1$ 的数。给定 $n(1\le n\le 333)$，求恰好能表示成三个好数的第 $n$ 小的数。

# 分析
注意到 $1\le n\le 333$，并且当 $n=333$ 时答案为 $112222222233$。

那么，我们只需要枚举位数小于等于 $12$ 的好数，然后扔进 `set` 里，最后找答案即可。

# Code
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;
int n;
set<int> a;
signed main(){
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  while (a.size() < n){
    for (int i = 1; i <= 112222222233; i = i * 10 + 1){
      for (int j = 1; j <= 112222222233; j = j * 10 + 1){
        for (int k = 1; k <= 112222222233; k = k * 10 + 1){
          a.insert(i + j + k);
        }
      }
    }
  }
  auto x = a.begin();
  n--;
  while (n--){
    x++;
  }
  cout << *x;
  return 0;
}
```

---

## 作者：sfqxx1 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT_abc333_c)

## 思路

一道不是很难的题。

我们可以预处理答案，将答案从小到大排序，然后直接输出即可。

## 代码

```python
n = int(input().strip())
r = [int('1' * i) for i in range(1,20)]#列表推导式
s = set()

for a in r:
    for b in r:
        for c in r:
            s.add(a + b + c)#添加答案

t = sorted(list(s))#答案排序
print(t[n-1])#输出

```



---

## 作者：xu222ux (赞：0)

# [ABC333C](https://www.luogu.com.cn/problem/AT_abc333_c)

# 思路

~~类似打表的思路。~~

把 $1$,$11$,$111$,$1111$,$11111$,$111111$,$11111111$,$111111111$,$111111111$,$1111111111$,$11111111111$ 这 $11$ 个数存起来，暴力枚举所有组合，从小到大排序，最后输出就行。

**注意去重！**

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int f[12]={1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111,111111111111};
signed main(){
    cin>>n;
    priority_queue<int,vector<int>,greater<int> >pq;
    for(int i=0;i<=11;i++){
        for(int j=0;j<=11;j++){
            for(int k=0;k<=11;k++){
                pq.push(f[i]+f[j]+f[k]);
            }
        }
    }
    int cnt=0,qian=-1;
    while(true){
        if(pq.top()!=qian)qian=pq.top(),cnt++;
        if(cnt==n){
            cout<<qian;
            return 0;
        }
        pq.pop();
    }
    return 0;
}
```

---

## 作者：xz001 (赞：0)

- 可以发现 $C(17,3)=680$，已经大于了 $n$ 的最大范围，因此我们可以预处理出来长度在 $[1,17]$ 范围内的所有特殊数字的组合，丢进一个 ```vector``` 里，然后将其从小到大排序，输出 $v_n$ 即可。
- 代码如下：

```cpp
/*
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3, "Ofast", "inline")
*/
#include<bits/stdc++.h>

using namespace std;

#define re			register
#define int			unsigned long long
#define fi			first
#define se			second
#define swap(a, b) 	a ^= b, b ^= a, a ^= b
#define pb 			push_back
#define all(x)		x.begin(), x.end()
#define max(a, b)	(a > b ? a : b)
#define min(a, b)	(a < b ? a : b)
#define il			inline
#define abs(x)		((x ^ (x >> 63)) - (x >> 63))

typedef pair<int, int> PII;

const int N = 1e6 + 10;
const int M = 1e6 + 10;
const int INF = 1e18, P = 998244353;
const double eps = 1e-6;

il int  read() { re int x = 0; re bool f = true; re char c = getchar(); while (c < 48 || c > 57) { if (c == '-') f = false; c = getchar(); } while (c >= 48 && c <= 57) x = (x << 3) + (x << 1) + c - 48, c = getchar(); return f ? x : -x; }
il void write(int x) { if (x < 0) putchar('-'), x = -x; if (x > 9) write(x / 10); putchar(x % 10 + 48); }
il void wel(int x) { write(x), putchar('\n'); }
il void wsp(int x) { write(x), putchar(' '); }

int b[105];

vector <int> v;

void dfs (int i, int j, int cnt) {  //预处理出所有特殊数字的组合
	if (j > 4) return;
	if (i > 17) {
		if (j == 3) v.push_back(cnt);
	} else {
		dfs (i + 1, j + 1, cnt + b[i]);
		dfs (i + 1, j + 2, cnt + b[i] * 2);
		dfs (i + 1, j + 3, cnt + b[i] * 3);
		dfs (i + 1, j, cnt);
	}
	return;
}

signed main() {
    for (int i = 1; i <= 17; ++ i) b[i] = b[i - 1] * 10 + 1;  //预处理特殊数字
    dfs (1, 0, 0);
    sort(v.begin(), v.end());
    int n;
    cin >> n;
    cout << v[n - 1];  //输出，注意 vector 的第一个下标是 0，所以 n 要减 1
    return 0;
}


```

---


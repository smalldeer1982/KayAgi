# [AGC017A] Biscuits

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc017/tasks/agc017_a

いくつかのビスケットの入った袋が $ N $ 個あります．$ i $ 番目の袋には $ A_i $ 個のビスケットが入っています．

高木君は，このうちいくつかの袋を選んで，選んだ袋に入っているビスケットをすべて食べるということを行います． このとき，袋を一つも選ばなかったり，すべての袋を選んだりしてもかまいません．

高木君は，食べるビスケットの枚数を $ 2 $ で割ると余りが $ P $ に等しくなるようにしたいです． このような袋の選び方は何通りあるか求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ P\ =\ 0,\ 1 $
- $ 1\ \leq\ A_i\ \leq\ 100 $

### Sample Explanation 1

食べるビスケットの枚数が $ 2 $ で割って $ 0 $ に等しくなるような選び方は $ 2 $ 通りです： - どちらの袋も選ばない．食べるビスケットの枚数は $ 0 $ である． - どちらの袋も選ぶ．食べるビスケットの枚数は $ 4 $ である．

### Sample Explanation 3

同じ枚数のビスケットが入っている場合でも，異なる袋は区別します．

## 样例 #1

### 输入

```
2 0
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
1 1
50```

### 输出

```
0```

## 样例 #3

### 输入

```
3 0
1 1 1```

### 输出

```
4```

## 样例 #4

### 输入

```
45 1
17 55 85 55 74 20 90 67 40 70 39 89 91 50 16 24 14 43 24 66 25 9 89 71 41 16 53 13 61 15 85 72 62 67 42 26 36 66 4 87 59 91 4 25 26```

### 输出

```
17592186044416```

# 题解

## 作者：AirQwQ (赞：1)

看到其他神犇的代码，本蒟蒻吓得瑟瑟发抖，所以我就给大家介绍一个最简单的方法。
## 前置芝士

- 一个数列之和的奇偶性与其数列中的偶数无关，只和奇数个数的就行有关，个数为偶，和为偶，个数为奇，和为奇。（[证明](https://www.luogu.com.cn/paste/yymgrksa)）

## 思路

- 由上，偶数随便取，则偶数取法有 $ 2^{even} $（$ n $ 个数有 $ 2^n $ 个子集，注意要包括空集）个，而奇数取法有 $ 2^{odd} \div 2 = 2^{odd-1}$（和为奇数，偶数各占一半）个，由乘法原理可得一共有：$ 2^{even} \times 2^{odd-1} = 2^{n-1}$ 种取法。

- 特判：$ odd = 0 $（$ even = n $）并且 $ p=1 $ 时输出 $ 0 $（只有偶数拼不出奇数）。

- 特判：$ odd = 0 $（$ even = n $）并且 $ p=0 $ 时输出 $ 2^n $（没有奇数，所以不需要减一）。

## 顺便教一些小芝士

1. ```num&1``` 等价于 ```num%2``` 但是位运算会比取模快很多。

2. ```num<<n``` 等价于 ```num*pow(2,n)``` 位运算速度依旧完胜 ```pow```。

## AcCode

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,p,num,sum;
int main(){
    cin>>n>>p;
    for(int i=1;i<=n;i++) 
        cin>>num,sum+=(num&1);//只用存储奇数个数。
    cout<<(sum?1ll<<--n:p?0:1ll<<n)<<endl;//不开long long见祖宗。
    return 0;
}
```



---

## 作者：LCuter (赞：1)

一句话题意：给定 $n,p$ 和一个正整数序列，求有多少种从序列中取数的方法使得取出来的数的和与 $p$ 奇偶性相同，可以不选。

我们发现这道题是有阶段性的，考虑在前 $i$ 个数中选出若干个数使得和为奇/偶数的方案数只和前 $i-1$ 个数的方案数与当前数的奇偶性相关。于是可以设计一个简单的动态转移方程，我们设 $f_{i,0}$ 表示前 $i$ 个数中选若干个数的和为偶数的方案数，$f_{i,1}$ 为奇数，那么容易有：

$$f_{1,0}=1+[a_1\bmod{2}=0],f_{1,1}=[a_1\bmod{2}=1]$$

想要得到 $f_{i,0/1}$，可以发现有几种情况，第一种是不选，第二种是选了改变奇偶性，第三种是选了不改变奇偶性，于是就可以得到：

$$f_{i,0}=f_{i-1,0}+f_{i-1,a_i\bmod{2}}$$

$$f_{i,1}=f_{i-1,1}+f_{i-1,(a_i+1)\bmod{2} }$$

---

## 作者：Eason_AC (赞：0)

## Content
有一个长度为 $n$ 的数列 $a$。你希望从中选出一些数，使得这些数的和对 $2$ 取模后的结果为 $P$。求方案数。

**数据范围：$1\leqslant n\leqslant 50$，$0\leqslant P\leqslant 1$，$1\leqslant a_i\leqslant 100$。**
## Solution
做完之后转了一圈，发现本题题解区现有题解全部都是 dp 做法。所以本人在这里来一发无脑数数做法。

不难发现，对于某组数，其和的奇偶性只和**这组数中奇数的个数**有关。如果奇数的个数为奇数，这组数的和就是奇数，否则就是偶数。

知道这个东西之后，这道题目就很简单了。我们先统计出数列 $a$ 中的奇数个数 $k$。然后我们先考虑取多少个偶数，再考虑取多少个奇数。但是取奇数的时候要注意：如果 $k\bmod 2\neq P$，奇数就只能够取奇数个，否则就只能取偶数个。至于偶数你随便取多少个都可以。

因此，我们可以分类讨论求出式子：

- $k\bmod 2=P$，此时奇数只能够取偶数个，因此方案数为 $\sum\limits_{i=0}^k\sum\limits_{j=0}^{n-k}\begin{pmatrix}k\\i\end{pmatrix}\begin{pmatrix}n-k\\j\end{pmatrix}[2\mid i]$。
- $k\bmod 2\neq P$，此时奇数只能够取奇数个，因此方案数为 $\sum\limits_{i=0}^k\sum\limits_{j=0}^{n-k}\begin{pmatrix}k\\i\end{pmatrix}\begin{pmatrix}n-k\\j\end{pmatrix}[2\nmid i]$。

其中 $[x]$ 表示条件 $x$ 是否为真，如果为真其值为 $1$，否则为 $0$。

当然，代码实现中，我们可以灵活运用 `for` 循环，这样，既不用判断条件，也不需要分类讨论去求。详情请结合代码理解。

## Code
日常用 `#define int ll` 偷懒（

```cpp
namespace Solution {
#define int ll
	int n, p, cnt0, cnt1, ans, a[57], C[57][57];
	
	iv Main() {
		F(int, i, 0, 50) { //预处理组合数
			C[i][0] = 1;
			F(int, j, 1, i) C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
		}
		read(n, p);
		F(int, i, 1, n) read(a[i]), cnt0 += !(a[i] & 1), cnt1 += a[i] & 1;
		F(int, i, 0, cnt0) Fo(int, j, ((cnt1 & 1) != p), cnt1, 2) ans += C[cnt0][i] * C[cnt1][j];
		write(ans);
		return;
	}
#undef int
}
```

---


# [ARC006B] あみだくじ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc006/tasks/arc006_2

 高橋君は学校で班のリーダーを決めなければいけなくなったので、あみだくじを用いて決めることにしました。  
 あみだくじとは、複数の縦線から $ 1 $ 本を選び、その上端から下端へと辿っていき、途中で横線があれば、その横線を通り繋がっている隣接する縦線へと移動し、また下へと進みます。  
 今日はたまたま手元に紙がなかったので、パソコン上で `|`、`-`、`o` を用いて以下のようなあみだくじを作りました。

```

| | | | | | | | |
|-| | |-| | |-| |
| | |-| | |-| | |
| |-| | | | | |-|
| | | |-| | | |-|
| | |-| |-| | | |
|-| | |-| | |-| |
| | | | | |-| | |
            o
```

 `o` がある位置に到達した人がリーダーになります。  
 実は高橋君はリーダーになりたかったので、どの縦線を選べば `o` に辿り着くのか知りたいです。  
  
 左から何番目の縦線を選べばリーダーになれるのかを求めなさい。 入力は以下の形式で標準入力から与えられる。 > $ N $ $ L $ |x|x|‥‥| |x|x|‥‥| |x|x|‥‥| : : : : : : : : | | |‥‥| y y y‥‥y

- 入力は $ L+2 $ 行ある。
- $ 1 $ 行目には、あみだくじの縦線の本数を表す整数 $ N(1≦N≦10) $ とあみたくじの長さを表す整数 $ L(1≦L≦20) $が与えられる。
- $ 2 $ 行目からの $ L $ 行には、あみたくじの形が与えられる。
- $ i $ 行目 $ (2≦i≦L+1) $ には $ 2N-1 $ 文字の記号が与えられる。
- 各行の $ j $ 番目の記号は、以下のようになっている。 
  - $ j $ が奇数の時：`|`
  - $ j $ が偶数の時(上記のxの位置)：`-` または ` `(空白)
- `|` はあみだくじの縦線を表し、`-`はその両端の縦線を繋ぐ横線であることを表す。また、空白はその位置に横線が無いことを表す。
- `|` を $ 1 $ つ挟んで左右に隣り合ったxの位置の両方が `-` という入力は存在しない。

- $ L+2 $ 行目には $ 2N-1 $ 文字の記号が与えられる。
- 各行の $ j $ 番目の記号は、以下のようになっている。 
  - $ j $ が奇数の時(上記のyの位置)：`o` または ` `(空白)
  - $ j $ が偶数の時：` `(空白)
- `o` は $ L+2 $ 行目にただ $ 1 $ つのみ与えられる。
 

 あみだくじを辿って `o` に到達するために選ぶべき縦線は左から何番目か $ 1 $ 行で出力せよ。  
 なお、最後には改行を出力せよ。 ```

3 2
| |-|
|-| |
o    
```

 ```

3
```

- 一番右の縦線を選ぶと、再左端に到達する。つまり、左から $ 3 $ 番目を選択すると、 `o` のある位置に到達できる。
 
```

10 2
| |-| |-| |-| |-| |
|-| |-| |-| |-| |-|
            o      
```

 ```

9
```

- 左から $ 9 $ 番目の縦線から辿ると、`o` の位置に到達できる。
- したがって、答えは $ 9 $ になる。
 
```

1 5
|
|
|
|
|
o
```

 ```

1
```

- 縦線が $ 1 $ 本なので、左から $ 1 $ 番目の縦線が答えとなる。
 
```

4 2
| | | |
| | | |
      o
```

 ```

4
```

- 横線が $ 1 $ 本も存在しないので、`o` のある縦線を選べば良い。
- したがって左から $ 4 $ 番目の縦線が答えとなる。
 
```

9 8
| | | | | | | | |
|-| | |-| | |-| |
| | |-| | |-| | |
| |-| | | | | |-|
| | | |-| | | |-|
| | |-| |-| | | |
|-| | |-| | |-| |
| | | | | |-| | |
            o    
```

 ```

3
```

# 题解

## 作者：Nygglatho (赞：1)

我们可以从原本`o`的这一个位置，顺着往上推。这样，就可以直接模拟了。

我们先用 $ans$ 记录`o`是在第几个竖线，用 $d$ 记录`o`是在第几列。然后，从下往上推，如果 $d$ 这一列左边有一个横线，那么就意味着要往左边走，$ans$ 就减去 $1$，$d$ 就减去 $2$（因为每一个竖线**中间**都会有一列空着或者一个横线，而不是竖线）反之，如果 $d$ 右边有一个横线，就意味着往右边走。$ans$ 就加上 $1$，$d$ 就加上 $2$。

最后的 $ans$ 即为所求的答案。

Code：
```cpp
#include <cstdio>
#include <iostream>
char a[25][22];
int main() {
	int n, l;
	scanf ("%d%d", &n, &l);
	for (int i = 1; i <= l + 1; i++) {//本人把“o”这个地方放到最后面，即第l+1行了。
		getchar();
		for (int j = 1; j <= n * 2 - 1; j++) {
			a[i][j] = getchar();
		}
	}
	int ans = 0, d = 0;
	for (int i = 1; i <= n * 2 - 1; i++) {
		if (a[l + 1][i] == 'o') {
			ans = i / 2 + 1;//容易看出，第i列是在i/2+1这个竖线的（即中间有i-1个空格或横线）
			d = i;
			break;
		}
	}
	for (int i = l; i >= 1; i--) {
		if (a[i][d - 1] == '-') {//横线在左边
			ans--;
			d -= 2;
		} else if (a[i][d + 1] == '-') {//横线在右边
			ans++;
			d += 2;
		}
	}
	printf ("%d\n", ans);
} 
```

---

## 作者：arrow_king (赞：0)

[~~并不好的阅读体验~~](https://www.luogu.com.cn/blog/536743/solution-at216)

这道题就是一个游戏——“鬼脚图”的实现，玩家需要攀爬绳索间的绳桥，最终抵达终点。

## 思路

由于 $n\leq10$，所以其实是可以枚举每个出发点的，但是为了优化，我采取了**逆推法**。

**逆推法是什么呢？**

正常问题是从正向推导的，但是这道题告诉了我们结束点，所以我们可以从结束点逆推回去。

整体思路就是读入 $n,l$ 后，输入整个字符方阵（先读入前 $1$ 到 $l$ 行），然后单独一行读入出发点。当前的位置可以用变量 $num$ 来记录。

不过这题有一些**细节**需注意：

- 由于输入中含有空格，所以需要使用 `getline()` 或 `getchar()`。但是，如果使用 `getchar()`，请注意：`getchar()` 的读入速度太快，会将换行符也同时读入进去。所以，可以用下面的代码片段删掉无意义换行符：

> ```cpp
>x=getchar();
>while(x=='\n') x=getchar();
>```

- 这一段代码可以删掉任意多的换行（其实删一个就行，但是样例中莫名其妙每行都多一个换行），从而保证读入的正确性。
- 输入的横向长度是 $2n-1$，不是 $n$。
- 最后的 $num$ 需要加 $1$。
- 数组横纵坐标不要写反。（我写反了一次，听取 TLE 声一片）

这些细节都注意完了后，**代码也就出来了：**

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,l,num;
char c[20][30],x;
int main() {
	scanf("%d%d",&n,&l);
	for(int i=1;i<=l;i++) {
		x=getchar();    //谨慎，小心有毒瘤数据
		while(x=='\n') x=getchar();
		for(int j=1;j<=2*n-1;j++) c[j][i]=getchar();
	}
	x=getchar();
	while(x=='\n') x=getchar();
	for(int i=1;i<=2*n-1;i++) {
		x=getchar();
		if(x=='o') num=i;
	}
	for(int i=l;i>=1;i--) {
		if(c[num+1][i]=='-') num+=2;
		else if(c[num-1][i]=='-') num-=2;
	}
	printf("%d\n",(num+1)/2+1);    //最后要加1
	return 0;
}
```


---

## 作者：yzc0x13269d6 (赞：0)

这道题不难，过程就是暴力 + 模拟。

这道题的重点不在于中间的竖线，而在于连接两条竖线的字符是 `-` 还是空格。所以本蒟蒻用一个数组 $a$ 存储连接的字符。判断 `o` 的位置时，本蒟蒻先用一个 $num$ 存储 `o` 的位置数量，然后将其加 $1$ 再除以 $2$ 就得到了终点的位置，**但是请注意：$num$ 需要初始化为 $1$ ！**

$\verb!Code:!$
```cpp
#include<cstdio>
using namespace std;
int now,n,l,num = 1; //初始化为1！
char a[50][50],c;
int main() {
	scanf("%d%d\n",&n,&l);
	for(int i = 1;i <= l;i++) {
		for(int j = 1;j <= n;j++) scanf("|%c",&a[i][j]); //输入连接字符，切忌用%s，这样空格就读不进去，还会多读一堆竖线
	}
	while((c = getchar()) != 'o') num++;
	num = (num + 1) / 2; //一定要加这一句
	for(int i = 1;i <= n;i++) { //分别判断
		now = i;
		for(int j = 1;j <= l;j++) {
			if(a[j][now] == '-') now++; //注意：下标是 now 而不是 now + 1
			else if(a[j][now - 1] == '-') now--;
		}
		if(now == num) { //找到答案，退出
			printf("%d\n",i);
			return 0;
		}
	}
	return 0;
} 
```

---


# [ARC056A] みんなでワイワイみかん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc056/tasks/arc056_a

高橋くん一家では今シーズンの果物がみかんに決まり、$ K $個のみかんを買うことが決まりました。 みかんは$ 1 $個$ A $円、さらに$ L $個のセットで$ B $円で売っています。 $ 1 $個のみかんと$ L $個のセットをそれぞれいくつか買い、合計で$ K $個以上のみかんを買うとき、払うお金の最小値を求めるプログラムを書いてください。

## 说明/提示

### 制約

- $ 1\ ≦\ A,\ B,\ K\ ≦\ 10^9 $
- $ 2\ ≦\ L\ ≦\ 10^9 $
- $ B\ ≦\ A*L $

### Sample Explanation 1

$ 3 $個のセットを$ 3 $つ、$ 1 $個のみかんを$ 1 $つ買うと合計$ 24 $円となる。これより安く$ 10 $個のみかんを買う方法はない。

### Sample Explanation 2

$ 3 $個のセットを$ 4 $つ買うのが最適である。

## 样例 #1

### 输入

```
3 7 10 3```

### 输出

```
24```

## 样例 #2

### 输入

```
4 5 11 3```

### 输出

```
20```

## 样例 #3

### 输入

```
3 8 3 3```

### 输出

```
8```

## 样例 #4

### 输入

```
3 8 2 3```

### 输出

```
6```

# 题解

## 作者：Wy_x (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/AT1917)

[更好的阅读体验？](https://www.luogu.com.cn/blog/73-54-16/solution-at1917)

### 思路：

- **分情况讨论**：

1. 买橘子时单个买需要的钱比配套买便宜或相等，这时直接单个买就可以，代码实现为 `a*k`。

2. 买橘子时单个买需要的钱比配套买贵，又有两种情况：
> 1. 配套买最多，再单个买，代码实现为 `b*(k/l)+a*(k%l)`。
> 2. 剩下不能配套买全部，但可以再买一套，代码实现为 `(k/l+1)*b`。
> 3. 取最小值即可。

### 注意：

- AT 的题需要**换行**！

- 数据范围比较大，会炸 `int`，需要开 `long long`！

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std; 
long long k,a,l,b,ans;
int main()
{
	cin>>a>>b>>k>>l;
	if(a*l<=b) ans=a*k;//公式
	else ans=min((k/l+1)*b,(b*(k/l)+a*(k%l)));//公式 
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：LeiZeProMax (赞：1)

题意：给定要买的橘子个数 $K$，单个橘子的价格 $A$，配套的橘子个数 $L$ 和价格 $B$，求最少的花费。

这个题需要分情况讨论。

1. 单个橘子比配套买划算。这样我们就直接全部单个买。

2. 配套买比单个买划算。这样我们就先配套买，算出配套买后剩下几个橘子不够配套。这样，我们又分出了两种情况：
>1. 剩下的橘子全部单个买比再买一套划算。这样我们就单个买剩下的橘子。
>2. 剩下的橘子全部单个买没有再买一套划算，那我们就再买一套。

看一眼数据范围：$1 \leq {A,B,K} \leq {10^9}$，说明需要开 long long。
# Code：
```c
#include<stdio.h>
long long K,A,L,B,ans;//A表示单个橘子的价格，B表示配套的价格，K表示要买的橘子数量，L表示配套的橘子个数
//记得开long long
int main()
{
    scanf("%lld %lld %lld %lld",&A,&B,&K,&L);
    if(A*L>=B)//如果配套比单个买划算，就配套
    {
        ans+=(K/L)*B;
        if(K%L!=0)//如果有剩余
        {
            if(A*(K%L)>=B)ans+=B;//如果配套比单个买划算，就配套
            else  ans+=A*(K%L);//否则剩余的全部单个买
        }
    }
    else ans+=A*K;//否则全部单个买
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：a1a2a3a4a5 (赞：0)

[题目](https://www.luogu.com.cn/problem/AT_arc056_a)

- 题意

1. 要买 ` k ` 个橘子，单买 ` a ` 元一个，大礼包 ` b ` 元 ` l ` 个。问最少花费多少钱。

- 思路

1.  DP 背包：我们在第一时间想到了背包，这像极了只有两个物品的完全背包的水题。有特殊兴趣的人可以写一下背包的做法，但是这道题没有必要写背包。

2. 分类讨论：在买橘子时，有几种情况：

| 出价情况 | 买橘子手段 |
| :----------: | :----------: |
| 单买的性价比高 | 单买 |
| 买大礼包的性价比高 | 买大礼包 |

3. 做完了，但是没有完全做完：买大礼包时可能会剩下一部分。由于不可以拼单，导致多买了几个橘子。这时候单买可能会占优势，所以要特判一下，买一个大礼包合算还是单买几个橘子合算。

- 代码

```
#include<bits/stdc++.h>
using namespace std;
long long a,b,k,l,da;
int main()
{
	cin>>a>>b>>k>>l;
	if(a*l<=b) cout<<a*l;
	//单买性价比高时，全部单买。
	else
	{
		if(k>=l) da+=b*(k/l),k%=l;
		//大礼包性价比高时，疯狂买大礼包。
		if(a*k<b) da+=a*k;
		//最后剩余的特判，如果单买更便宜就单买。
		else da+=b;
		//否则再买一个大礼包。
		cout<<da;
	}
	return 0;
}
```

---

## 作者：GuoWil (赞：0)

这题入门难度，其实并不难，但是需要考虑多种情况。

~~高桥买这么多橘子吃得完吗~~

首先是题目数据：**开long long！**

进入正题：高桥买橘子有这么几种情况：

1、直接单买：$K$ 个橘子每个 $A$ 日元，一共 $K \times A$ 日
元。但是只有当 $K \times A<B$ 时才是最小花费。

2、使用套餐：里面又细分成3种情况。
  
  $(1):$ 当总橘子数能被一份套餐的橘子数整除也就是当 $K$ 能整除 $L$ 时，那么最小花费就是
  
  **总橘子数 $\div$ 一份套餐橘子数 $\times$ 一份套餐钱数**
  
  
 也就是 $K \div L \times B$ 块钱。
 
 $(2):$ 当 $K$ 不能整除 $L$ 时，有两种买法。
 
 一种是先买套餐，再单买。也就是用套餐的钱 $K÷L×B$ 再加上 $K$ 对 $L$ 取余（也就是剩下不能再组成套餐的橘子个数）$\times$ 单个橘子价钱 $A$ 日元。
 
 也就是 $(K \div L \times B) + (K \% L \times A)$ 日元。
 
 另一种是直接套餐全包。既然整除不了，那我们可以把多出来
 的橘子再凑一个套餐。只需要用 $K÷L + 1$ 就可以多凑一个 套餐了。
 
 **因为我们的变量都是整数，所以即使不能整除，计算机算出来的商也是整数。**
 
 这种方案总共需要 $(K \div L + 1)\times B$ 日元。
 
 **最后需要将这两种情况进行比较，取最小花费。**
 
**还有，AT的题需换行！上代码！**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long a,b,k,l,ans3=0,ans1=0,ans2=0;//3种计数器判断使用套餐的3种情况。
	cin >> a >> b >> k >> l;
	if(a*k<b){ //直接单买。
	  cout << a*k << endl;
	  return 0; //一定记得每个分支结束后return 0!
	}else{
	  if(k%l==0){ //可以整除。
	  ans1=k/l*b;
	  cout << ans1 << endl;
	  return 0;
	  }else{ //不可以整除的两种买法。
	  ans2=(k/l*b)+(k%l)*a;
	  ans3=(k/l+1)*b;
	  cout << min(ans3,ans2) << endl; //再取两种方法最小值本题就结束了。
	  }
	}
	return 0;
}
	
```
还是那句话，只要搞清楚这题怎么算出来的做对就很容易了。

 



---


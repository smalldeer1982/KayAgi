# [ABC053D] Card Eater

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc053/tasks/arc068_b

すぬけくんはカードゲームで遊ぶことにしました。 $ N $ 枚からなるカードの山があり、上から $ i $ 枚目のカードには整数 $ A_i $ が書かれています。

すぬけくんはこのカードの山に対し $ 0 $ 回以上、以下の操作を行い、残ったカードに書かれた値が互いに異なるようにしたいです。最大で何枚のカードを残すことが可能か求めなさい。なお、$ N $ は奇数であり、少なくとも $ 1 $ 枚のカードを残すことが可能であることが保証されます。

操作：カードの山から任意の $ 3 $ 枚のカードを抜き出す。抜き出したカードのうち書かれた値が最大であるようなカード $ 1 $ 枚と最小であるようなカード $ 1 $ 枚の合計 $ 2 $ 枚を選んで食べる。その後残った $ 1 $ 枚をカードの山に戻す。

## 说明/提示

### 制約

- $ 3\ ≦\ N\ ≦\ 10^{5} $
- $ N $ は奇数
- $ 1\ ≦\ A_i\ ≦\ 10^{5} $
- $ A_i $ は整数

### Sample Explanation 1

操作を $ 1 $ 回行って $ 1,1,2 $ を取り出すというのが最適な操作手順の $ 1 $ つです。最大値である $ 2 $ と書かれたカードで最小値である $ 1 $ と書かれたカードがそれぞれ $ 1 $ 枚ずつ食べられ、残った $ 1 $ と書かれたカードがカードの山に戻されます。カードの山に残っているカードは $ 1,3,7 $ となり、これらは互いに異なります。

## 样例 #1

### 输入

```
5
1 2 1 3 7```

### 输出

```
3```

## 样例 #2

### 输入

```
15
1 3 5 2 1 3 2 8 8 6 2 6 11 1 1```

### 输出

```
7```

# 题解

## 作者：MZY666 (赞：14)

这题非常的有趣呵~

[原题传送门](https://www.luogu.com.cn/problem/AT2299)。[在窝的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-at2299)。

### 【 题意概括 】

先输入一个大于 $3$ 的奇数 $n$，表示有 $n$ 张牌。随后输入每一张牌 $a_i$ 。

现在可以进行下述操作无限次，求最多能剩下多少张不重复的牌。

可进行的操作：选 $3$ 张牌出来，弃掉最小和最大的那两张牌，再将剩余的那张重新放入牌堆中。

### 【 思路 】

欢迎来到精华部分。

首先如果要保证尽可能地“多剩下不重复的牌”，那么牌堆不可能为空。

因此可以用一种类似贪心的想法。

每次取两个已经和前面重复过的牌出来，再随便拿一张之前它们一样的某一张牌来“垫一下”，（反正最后会把这张牌放回去），就可以达到去重的目的。

这样每次可以去掉 $2$ 张与前面相同的牌。

那如果只剩一张与前面重复的牌又该怎么办呢？

这个时候就只能舍去一张没有重复过的牌了。没办法嘛。这一点需要注意。

来，是时候看看完整代码了。这样才好说清。

### 【 代码实现 + 注释 】

```cpp
#include<bits/stdc++.h>//万能头文件可好 
using namespace std;
#define ll long long//个人习惯
bool a[100005];//a[i]表示是否有i这么一张牌，初始值为false
int main(){//主函数 
	ll n,k,i,again=0;//k用于暂存输入，again记录重复的次数。
	scanf("%lld",&n);//输入n
	for(i=1;i<=n;i++){
		scanf("%lld",&k);
		if(a[k])again++;//如果这个数之前有过,again++
		else a[k]=true;//否则将此数标记为true
	}
	again+=again%2;//这就是讨论是否有单独剩下的一张无法配对去重的情况。
	printf("%lld",n-again);//输出剩余的牌数
	return 0;//over~
}
```

最后，由于作者自愿禁言了，如果有建议请私信。否则将**无法**回复您哦！

完结撒花~（疯狂暗示 OwO

---

## 作者：ZolaWatle (赞：4)

## AT2299 题解

先重复一遍题目：

有一堆牌，每张牌上有一个数字。

**每次可以取出其中3张，丢掉数字最大的和数字最小的牌，把中间那张再放回牌堆。** 

要求最后所有剩余牌上的数字互不相同，求最多能剩几张牌。

------------

我们来分析一下**加粗**部分：

其实这句话实在**误导**做题人，很容易想着每次只能抽三张，就按那样去做了，大大提升了复杂度。

我们要丢掉的只是**值最大和值最小**的两张牌。设值最小的牌上的数字为$ x $，值最大的牌上的数字为$ y $，那么在自然数中，介于$ x $，$ y $之间的数字，一定是找得到的，换言之：

在任意闭区间中：

$$ [x,y]\ (x∈N^*, y∈N^*, x\leq y) $$

至少有一个可能值。

举一个极端的例子，如果我们要舍弃的牌中，大的那张为$ 1 $，小的那张依然为$ 1 $，我们仍然可以取得**中间的那张**，它也是$ 1 $。

于是，题目中的删除操作被简化为了：

**每次任意取走两张牌**

------------

题目要求最后所有剩余牌上的数字互不相同，求最多能剩几张牌。

而求**最多能剩下几张牌**，相当于求**最少删去几张牌**，也就是**最少取几次牌**。

我们可以思考在什么时候应该停止取牌的操作，答案很显然，是在剩余牌上的数字互不相同的时候。

那么如何造就这个结果呢？我们只需要把每种牌多出来的给取走即可，设每种牌多出来的数量为$ k_i $，那么总共要取走的牌数$ S $即为：

$$ S\ =\ k_1+k_2+...+k_n $$

又因为每次仅能取走两张牌，所以当$ S $能被$ 2 $整除时，恰好取 $ \frac{S}{2} \ \cdot\  2\  =\ S$ 张牌即可；

但是当$ S $为奇数时，以上的操作还会留下一张重复的牌，所以要多去两张，这就意味着牺牲掉一张已经符合题目要求的牌。

------------

### 简单叙述一下：

- 统计多出来的牌数$ S $

- 每次删去两张牌

- 如果$ S $为偶数，只需要删去$ S $张

- 如果$ S $为奇数，需要删去$ S+1 $张

- 剩下的牌数即为总数$ n $减去被删掉的$ S $或$ S+1 $

------------

### 代码实现：

主要叙述如何实现统计多出来的牌数.

###### 方法一:

读入数组$ a $，对$ a $进行排序，利用语句：

```cpp
if(a[i]==a[i+1]) cnt++;
```

判断相邻两个元素是否一样，若一样，多出来的牌数$  +1 $。

###### 方法二：

建立 $ bool $ 型数组 $ a $，$ a_i $ 代表数字$ i $是否已经出现过。

从 $ 1 $ 到 $ n $ 依次扫描，对于每一个元素：如果没有出现过则把其对应的$ a $加一；如果已经出现过，说明这是多出来的，那么使计数器加一。

下面给出**方法二**的示例代码段：

```cpp
bool a[100001]={0}; //定义只需用bool型
for(re i=1;i<=n;i++)  //从1到n依次扫描 
{
	std::cin>>tmp;  //对于这一种方法，没有开数组的必要 
	if(!a[tmp])  //相当于if(a[tmp]==0)，没有出现过 
		a[tmp]=1;  //赋值为真 
	else  //如果出现过 
		cnt++;  //计数器加一 
}
```

------------

### 完整代码：

```cpp
#include <bits/stdc++.h>
#define re register int  //玄学优化，可忽略 
using namespace std;

int n,tmp,cnt;
bool a[100001];  //全局变量的默认值为0 

int main()
{
	std::cin>>n;  //输入 
	
	for(re i=1;i<=n;i++)  //从1到n依次扫描 
	{
		std::cin>>tmp;  //对于这一种方法，没有开数组的必要 
		if(!a[tmp])  //相当于if(a[tmp]==0)，没有出现过 
			a[tmp]=1;  //赋值为真 
		else  //如果出现过 
			cnt++;  //计数器加一 
	}
	
	if(cnt%2==1) //多出来的牌是奇数 
		cnt++;  //多牺牲一张已经满足题目要求的牌 
	cnt=n-cnt;  //把最少删去转化为最多剩余 

	std::cout<<cnt;  //输出 
	return 0;  //好习惯 
}
```

------------

谢谢观看~


---

## 作者：花开一心相惜 (赞：3)

[原题](https://www.luogu.com.cn/problem/AT2299) 。不要被此题的难度吓到 。

思路： 首先 ， 将数据排序 ， 记录重复的数字的个数 。

如果是偶数 ， 输出总个数减去重复个数 。

如果是奇数 ， 输出总个数减去重复个数加上 $ 1 $ 。

代码（手动加了一个 ```__int128``` ):

```
#include<bits/stdc++.h>
using namespace std;
void scan(__int128 &x)
{
    x=0;
    int f=1;
    char ch;
    if((ch=getchar())=='-') 
    {
        f=-f;
    }
    else x=x*10+ch-'0';
    while((ch=getchar())>='0' and ch<='9')
    {
        x=x*10+ch-'0';
    }
    x*=f;
}
void _print(__int128 x)
{
    if(x>9) 
    {
        _print(x/10);
    }
    putchar(x%10+'0');
}
void print(__int128 x)
{
    if(x < 0)
    {
        x=-x;
        putchar('-');
    }
    _print(x);
}
bool qwq[100005];
int main()
{
	__int128 n,k,again=0;
	scan(n);
	for(int i=1;i<=n;i++)
	{
		scan(k);
		if(qwq[k])
		{
		    again++;
		}
		else 
		{
		    qwq[k]=true;
		}
	}
	again+=again%2;
	print(n-again);
	return 0;
}
```



---

## 作者：梦游的小雪球 (赞：3)

## 梦雪的思路

- 废话：这道题看起来很难，但其实还是很简单的，主要是题目太误导人了。

- **这里提供简化后的题目**：有一堆牌，每张牌上有一个数字。 每次可以丢掉其中2张，要求最后所有剩余牌上的数字互不相同，求最多能剩几张牌。

- **一目了然的思路**：

1. 排序。

1. 把和前面的数字重复的数字的数量统计出来（$n$）。

1. $m$为总数，$ans=m-n$。

1. 若$n$为奇数，则$ans+1$(需多删去一个没有重复的数）

1. 输出$ans$.

## 你们的最爱

```
#include<bits/stdc++.h>
using namespace std;
int n,a[100002],s; 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=2;i<=n;i++)
		if(a[i]==a[i-1])
			s++;
	if(s%2)
		s++;
	cout<<n-s<<endl;
	return 0;
}

```
## 望通过QWQ

![](https://inews.gtimg.com/newsapp_bt/0/6829681395/640)

---

## 作者：infinities (赞：2)

[更佳的阅读体验](https://www.luogu.org/blog/209547/solution-at2299)

此题，乍一看翻译我们会觉得很难，其实它的思路挺简单：
- 对所有给定的数排一遍序，然后统计一下重复的数的个数

- 因为题目要求拿出三张牌，然后丢掉两张大的和小的，放回一张中间的

- 所以其本质就是不断从牌堆中拿出两张牌，使剩下的牌不重复，问最后能剩下几张

- 因此，如果重复的数的个数是单数，我们就将它加一，然后输出n减去这个个数就好啦

- 只是别忘了换行啊

已经讲得挺清楚了，代码最好还是自己写，这里贴出来仅供参考

code:
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n,a[101101],ans;
int main(){
    ios::sync_with_stdio(false);//cin,cout快读
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];//输入都不解释
    }
    sort(a+1,a+1+n);//排一遍序
    for(int i=1;i<=n;i++){
        if(a[i]==a[i-1])ans++;//统计重复的数的个数
    }
    if(ans&1)ans++;//位运算，相当于if(ans%2)ans++;
    //如果是单数，改成双数
    cout<<n-ans<<"\n";//输出,别忘了换行
    exit(0);
    //相当于return 0;但是这句话无论出现在哪都会立即结束程序（包括函数）
}
```


---

## 作者：lkjzyd20 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/AT2299)

___

### 思路

这道题我们可以开一个桶，

统计一共有多少个不同的数。

如果个数是偶数的话，

最后的答案要 $-1$。

比如样例

```cpp
5
1 2 1 3 7
```

不同的数有 $4$ 个。

但是我们在操作中要多删掉一个数，

所以答案要 $-1$ 。

___

代码如下：

```cpp
#include <stdio.h>

const int N = 1e5 + 10;

int n, t;
int sum;
int a[N];

main () {
	scanf ("%d", &n) ;
	
	for (int i = 1; i <= n; i ++)  {
		scanf ("%d", &t) ;
		++ a[t];
	}
		
	for (int i = 1; i <= N - 1; ++ i)
		if (a[i] != 0)
			sum ++;
            
	printf ("%d", (sum & 1) ? sum : sum - 1) ;
}
```

### 完结撒花 $\sim\sim\sim$

---

## 作者：GizeCarl (赞：1)

### 题意理解：

------------

因为是抽三张放回一张，为了让剩下的牌尽可能的多，应该放回排队里只有一张的牌，而扔掉两张牌堆里都有重复的牌。

------------

### 解法一：

首先输入数组并进行排序，然后统计重复的牌数。注意，当重复的牌数是单数时，就得被迫多扔一张牌。因为每次都是扔两张放回一张，因此被扔掉的牌数一定是双数。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],sum;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1;i<n;i++)
		if(a[i]==a[i+1]) sum++;
	if(sum%2) sum+=1;
	cout<<n-sum<<endl;
	return 0;
}
```

------------

### 解法二：

在输入时进行判重，可以省掉一个 sort + 一个循环的时间。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum,b;
bool a[100005];//用布尔类型来判重
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>b;
		if(!a[b]) a[b]=true;
		//初始是False，有重复就改为True
		else sum++;
	}
	if(sum%2) sum+=1;
	cout<<n-sum<<endl;
}
```



---

## 作者：林家三少 (赞：1)

这是一道$\color{green}\text{普及+/提高}$的题qwq

同楼上大佬差不多的思路，不过我是用了数组计数的算法来解决重复这一块的问题的(luogu大大饶我一过吧QAQ)

我来重复一遍楼上dalao的思路

- 求出重复的个数

- 如果重复的个数是奇数，就输出个数-重复个数+1

- 否则输出个数-重复个数(差不多就行啦~

接下来也没有要说的了，就上AC程序吧

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int n,ans,maxx;  //定好变量
int a[100000+10],shu[100000+10];  //10的5次方也就是10后面跟5个零，为了防止爆掉，我又多定了10个~
void AC()  //AC函数名，祝愿我AC！(然而我真的AC了qwq)
{
	for(int i=1;i<=maxx;i++)
		if(shu[i]>1)  //重复的判断条件
		ans+=shu[i]-1;  //这就是重复的个数了~
	if(ans%2==1)ans++;  //这就是重复为奇数就加1
	cout<<n-ans<<"\n";  //输出，蓝后要换行哦
	return ;  //结束，不过用exit(0);也行
}
int main()
{
	cin>>n;  //输入个数
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];  //输入卡片上的数
		shu[a[i]]++;  //数组计数来了！
		if(a[i]>maxx) maxx=a[i];  //这里定个maxx变量是为了节省一点点时间(不用应该也行~)
	}
	AC();  //转到函数，因为我定的是全局变量，就不用在函数里定了
}
```


---

## 作者：让风忽悠你 (赞：0)

[原题](https://www.luogu.com.cn/problem/AT2299)

因为可以进行无数次操作，实际上每个数都可以被取。

所以每次操作可以看作是取出数列中的两个数。

那么答案就是数列中不重复的数的个数。

考虑到每次都取两个数，所以结果要根据取走的数的奇偶判断是否 -1。

```cpp
#include<cstdio>
#include<algorithm>
#define N 100005

using namespace std;

int n,ans;
int a[N];

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
		if(a[i]==a[i+1])
			++ans;
	// 统计重复的数，方便判断奇偶
	// ans 是重复的数的个数，n-ans 救赎不重复的数的个数
	// 每次取走两个，所以当 ans 是奇数时 ans+1 
	printf("%d",n-ans-ans%2);
	return 0;
}
```


---

## 作者：·糯· (赞：0)

## 题目分析
这题我们可以先将序列从小到大排一遍，然后循环枚举相同数字的个数，如果最终仍剩两个相同的且没有其它的了，则还需操作一次，最终剩下的数就是所有数减去去掉的数。
## 代码实现（诚信是做人之本）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[100010],sum;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>x[i];
	sort(x+1,x+n+1);//先排一遍
	for(int i=1;i<n;i++)
		if(x[i]==x[i+1])//前后相同
			sum++;
	if(sum%2==1)
		sum++;//如果还有两个相同的单独剩下不能操作的就再加一
	sum=n-sum;
	cout<<sum<<endl;
	return 0;
}

```


---

## 作者：Mr_WA的大号 (赞：0)

勇敢迈进，砥砺前行。小学生又来发题解了！

题号：AT2299

难度：★

算法：数论、数组计数

## 开课了！

这题是一道比较简单的数论题。它要我们剩下尽量多并且不重复的牌，就是要我们去掉全部重复的牌并且尽量多留其他没有重复的牌。

我们应该去想：怎样去掉重复的牌呢？我们可以在两张重复的牌之间插入一张牌，这样就能去掉重复的牌了。

但我们还要注意一点：如果最后只剩下一张重复的牌，我们就只能忍痛舍去一张没有重复的牌了。

课讲完了，上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<iomanip>
using namespace std;
int n,both,number;
bool a[100010];
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		a[i]=false;//将数组初始化
	for(int i=1; i<=n; i++)
	{
		cin>>number;//输入数字
		if(a[number]==true)both++;//如果它已经出现过，重复牌的数量++
		else a[number]=true;//否则标记这个牌出现过
	}
	if(both%2==1)both++;//判断是否要多舍去一张牌
	cout<<n-both<<endl;//输出
	return 0;
}
```
祝大家能AC！

---


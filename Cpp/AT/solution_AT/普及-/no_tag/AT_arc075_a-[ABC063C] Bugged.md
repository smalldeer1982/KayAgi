# [ABC063C] Bugged

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc063/tasks/arc075_a

あなたはコンピュータで試験を受けています。試験は $ N $ 問の問題からなり、$ i $ 問目の問題の配点は $ s_i $ です。それぞれの問題に対するあなたの解答は「正解」または「不正解」のいずれかとして判定され、正解した問題の配点の合計があなたの成績となります。あなたが解答を終えると、解答がその場で採点されて成績が表示される…はずでした。

ところが、試験システムに欠陥があり、成績が $ 10 $ の倍数の場合は、画面上で成績が $ 0 $ と表示されてしまいます。それ以外の場合は、画面に正しい成績が表示されます。この状況で、成績として画面に表示されうる最大の値はいくつでしょうか？

## 说明/提示

### 制約

- 入力値はすべて整数である。
- $ 1\ <\ =\ N\ <\ =\ 100 $
- $ 1\ <\ =\ s_i\ <\ =\ 100 $

### Sample Explanation 1

$ 10 $ 点の問題と $ 15 $ 点の問題に正解し、$ 5 $ 点の問題には正解しないことで成績が $ 25 $ となり、この成績は画面に正しく表示されます。$ 5 $ 点の問題にも正解すると成績が $ 30 $ となりますが、この成績は画面上では $ 0 $ と表示されてしまいます。

### Sample Explanation 2

すべての問題に正解すると成績が $ 35 $ となり、この成績は画面に正しく表示されます。

### Sample Explanation 3

どのような解答状況でも成績は $ 10 $ の倍数となり、画面上では $ 0 $ と表示されてしまいます。

## 样例 #1

### 输入

```
3
5
10
15```

### 输出

```
25```

## 样例 #2

### 输入

```
3
10
10
15```

### 输出

```
35```

## 样例 #3

### 输入

```
3
10
20
30```

### 输出

```
0```

# 题解

## 作者：W_fly_K (赞：3)

首先我们可以特判两种情况：
1. 所有题分数总和不为 $10$ 的倍数，这种情况直接输出总和即可。
2. 所有题的分数都是 $10$ 的倍数，这种情况直接输出 `0` 即可。

如果不是上面两种情况，那么我们可以知道：
1. 由特判第一条可得总和是 $10$ 的倍数。
2. 由特判第二条可得至少有一题分数不是 $10$ 的倍数。

题目要我们求的是可得分数的最大值。我们首先可以知道的是一个是 $10$ 的倍数的数，减去一个不是 $10$ 的倍数的数，就变成了一个不是 $10$ 的倍数的数。既然如此，那么我们只要找出分数中最小不是 $10$ 的倍数的数，并减去它即可。
# _code_

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[10001];
int f[10001];
signed main()
{
  int num = 0;
  int n;
  cin >> n;
  int ans = 0;
  for (int i = 1; i <= n; i ++)
    {
      cin >> a[i];
      ans += a[i];
      if(a[i] % 10 != 0)
        f[i] = 1;
      num += f[i];
    }
  if (!num)//特判第二种情况
    {
      cout << 0 << endl;
      return 0;
    }
  if (ans % 10 != 0)//特判第一种情况
    {
      cout << ans << endl;
      return 0;
    }
  int rans = 0;
  for (int i = 1; i <= n; i ++)
    {
      if (f[i] == 1)
        rans = max(rans, ans - a[i]);//找到一个更小的，就更新答案
    }
  cout << rans << endl;
  return 0;
}


```




---

## 作者：BlackPanda (赞：1)

**[题目传送门](https://www.luogu.com.cn/problem/AT2579)**

------------
### 题意：
给定 $N$ 道题及每道题答对所得的分值，答错不得分，如果最终总得分是 $10$ 的倍数，则分数为 $0$，问最多可以获得多少分？

------------
### 思路：
对于多种情况进行分类讨论：

- 当最后总得分不是 $10$ 的倍数时，可以直接输出。

- 当每题得分都是 $10$ 的倍数时，不可能出现总得分不是 $10$ 的倍数的情况，所以直接输出 $0$。

- 有部分题目分值不是 $10$ 的倍数，可以减去一个最小的、不是 $10$ 倍数的分值，所得的差就是答案。

------------
### code：
**千万别输出多余的回车，[后果自负](https://www.luogu.com.cn/record/71831920)。**
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,sum,x=0x3f3f3f3f,flag;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
		sum+=t;
		if(t%10 != 0){
			x=min(x,t);
			flag=1;
		}
	}
	if(!flag){	//全部分值都是10的倍数 
		cout<<0;
	}
	else if(sum%10){	//最后总分值不是10的倍数 
		cout<<sum;
	}
	else{	//第三种情况，减去一个最小的不是10的倍数的值 
		cout<<sum-x;
	} 
	return 0;
}


```


---

## 作者：_acat_ (赞：1)

题目难度：$\color{#FE4C61} \text{入门}$

算法标签：$\color{#0E90D2} \text{贪心}$

## 题目描述

有 $n$ 道题，答对一道获得 $s_i$ 分，答错不得分。但是如果现在分数为 $10$ 的倍数将会显示 $0$ 分，问最高可以获得多少分？

## Sol

我们可以分 $3$ 种情况讨论。

1. 当所有分数之和都 $\ne 10$ 的倍数的时候，**直接输出所有分数之和**。
2. 当所有分数都为 $10$ 的倍数时，**直接输出 $0$**。
3. 当所有分数之和为 $10$ 的倍数，但有 $1$ 个及以上的分数不为 $10$ 的倍数时，我们首先可以知道的是一个 $\mod 10=0$ 的数，减去一个 $\mod 10 \ne 0$ 的数，就变成了一个不是 $10$ 的倍数的数。所以我们只要找出分数中最小不是 $10$ 的倍数的数，用所有分数的总合减去最小的不是 $10$ 的倍数即可。

代码就不给了，自己写吧（

---

## 作者：EthanC_ (赞：0)

本题是一道分类讨论题。
### 思路：
1. 如果总和不是 $ 10 $ 的倍数，那么就直接输出总和。
1. 如果总和是 $ 10 $ 的倍数，经过删数后输出。那么如何删数呢？请看下方的说明。
- 为了使得数最大，我们应该删去一个最小的非整十的数。这样既可以保证得数不是 $ 10 $ 的倍数也可以保证得数最大。

### 核心代码：
仅供参考。

```cpp
if(ans%10!=0){//如果不是10的倍数直接输出
    cout<<ans<<endl;
    return 0;
}
sort(a,a+n);//排序数组
for(int i=0;i<n;i++){
	if(a[i]%10!=0){//如果 a[i] 不是 10 的倍数那么就将ans减去 a[i] 并输出。
	    ans-=a[i];
	    cout<<ans<<endl;
	    return 0;
	}
}
cout<<0<<endl;//否则最后就是10的倍数，只能输出 0。

```


---

## 作者：封禁用户 (赞：0)

**思路：**
首先对给出的 $n$ 个数求和。
接下来有 3 种情况。
1. 如果所有数都是 10 的倍数，那么答案为 0。
1. 若这些数的和不是 10 的倍数，则这 $n$ 个数的和即为答案。
1. 如果这 $n$ 个数的和是 10 的倍数，那么在这些数中找一个不是 10 的倍数的最小的数，然后用和减去它即可。
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll maxn=14e4;
int n,x,num,Min=maxn;//一定要设得大一点
bool ok=false;//初始化为false
int main()//梦开始的地方
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>x;
        num+=x;//首先对给出的n个数求和
        if(x%10)
        {
            ok=true;
            Min=min(Min,x);
        }
    }
    if(!ok)//如果所有数都是 10 的倍数，那么答案为 0
    {
    	cout<<0;
    }
    else
    {
        if(num%10)//若这些数的和不是 10 的倍数，则这n个数的和即为答案
        {
        	cout<<num;
        }
        else//如果这n个数的和是 10 的倍数，那么在这些数中找一个不是 10 的倍数的最小的数，然后用和减去它即可。
        {
        	cout<<num-Min;
        }
    }
    return 0;//梦结束的地方
}
```

---

## 作者：Keep_RAD (赞：0)

### 前言

首先我们要明白，这是一道分类讨论题。

### 具体思路

我们肯定想得分，对不对？所以我们就考虑删数。

两种情况：

1. 如果总和不是 $10$ 的倍数，那么直接输出，因为这种情况不会变分数，而且每一题的分都拿到了。

2. 如果总和是 $10$ 的倍数，那肯定不能直接输出。

在第二种情况下，我们只需要减一个最小的非整十数的数，这样总分既能保证最大，又能不变成零。

那有好奇宝宝就要问了：如果没有非整十的数呢？

那就不能减了，减了也没用，只能认命，输出零。

思路很清晰，请尝试自己写代码，写错了，再来看标程。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48); 
        c=getchar();
    }
    return x*f;
}
int a[105];
int main()
{
	int n=read();
	int sum=0;
	for(int i=1;i<=n;i++)
	    a[i]=read(),sum+=a[i];
	if(sum%10!=0)
	{
	    cout<<sum;
	    return 0;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	    if(a[i]%10!=0)
	    {
	        sum-=a[i];
	        cout<<sum;
	        return 0;
	    }
	cout<<0;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/72950294)

---

## 作者：Zhouyc2009 (赞：0)

题意：

有 $N$ 道题目，每道题都有 $a_i$ 分，答对获得 $a_i$ 分，答错不得分也不扣分。若分值是 $10$ 的倍数时，将会显示 $0$ 分，问做多能获得多少分。

SOL：

分类讨论：

- 当题目总分值是 $10$ 的倍数时，且所有分值都是 $10$ 的倍数，因为题目限制所以输出 $0$ 。
- 最后的分值不是 $10$ 的倍数时，直接输出最后的分值。
- 分值有不是 $10$ 的倍数时，减去一个最小的非 $10$ 倍数分值，就是能获得的最大分值。

**CODE：**
```
#include<bits/stdc++.h>
using namespace std;
int n,minn,x,sum,s;
int main()
{
	cin>>n;//输入题目数量。
	minn=0x3f3f3f;
	for (int i=1;i<=n;i++)
	{
		cin>>x;//输入每道题的分值。
		sum+=x;//把所有题的分值累加起来。
		if (x%10!=0) minn=min(x,minn),s++;//当这道题分值不是10的倍数时，求出一个最小的分值(不是10的倍数的），再将分值不是10的倍数的题目个数保存下来。
	}
	if(s==0) cout<<0;
		else if (sum%10!=0) cout<<sum;
		  else cout<<sum-minn;//按方法判断输出。
}
```

2022第一篇题解，给自己开个好头！

---

## 作者：Ezio__Auditore (赞：0)

## AT2579 [ARC075A] Bugged
[[Statment]](https://www.luogu.com.cn/problem/AT2579)

$Date:\ Dec.\ 1st$

---
#### 题意：
&emsp;&emsp;给定长度为 $n$ 的序列 $a$,从中选出任意个元素让选出的元素和最大，且和不为 $10$ 的倍数。$_{(n\ \le\ 100 )}$ 

---
#### 思路：
&emsp;&emsp;考虑 $\sum{a_i}\ mod\ 10 \neq 0$ 的情况， 显然直接输出所有元素之和 $Sum = \sum{a_i}$ 即为最优解。

&emsp;&emsp;再转换到 $\sum{a_i}\ mod\ 10 = 0$ 的情况， 需要从 $Sum$ 中剔除一些数使得 $Sum$ 不是 $10$ 的倍数。

- 如果剔除 $a_i\ mod\ 10 = 0$ 的 $a_i$, 剔除后 $Sum$ 仍然是 $10$ 的倍数, **没有必要剔除**， 可以全部保留。 
- 如果剔除 $a_i\ mod\ 10 \neq 0$ 的 $a_i$，只要剔除的元素总和不是 $10$ 的倍数即可让 $Sum$ 不是 $10$ 的倍数。为了让 $Sum$ 最大，我们只剔除一个元素，**即剔除 $\min\limits_{a_i\ mod\ 10\neq 0}{a_i}$**。

**这样我们就得到了这题的贪心策略：**
- 计算出所有 $a_i$ 之和为 $Sum$, 同时记录 满足 $a_i\ mod\ 10\neq 0$ 的 $a_i$ 最小值为 $a_{min}$

- 若 $Sum\ mod\ 10 \neq 0$, 答案 $Ans = Sum$, 否则， $Ans = Sum - a_{min}$。

- 如果所有的 $a_i$ 都是 $10$ 的倍数， 显然 $Sum$ 一定 $10$ 的倍数，无法通过剔除部分 $a_i$ 来改变， 这时候答案应为 $0$。

综上， 我们可以在 $O(n)$ 的复杂度内计算出:

$$Ans =
\begin{cases}
\sum\limits_{i = 1}^{n}{a_i}& (\sum\limits_{i = 1}^{n}{a_i}\ mod\ 10 \neq 0)\\
\sum\limits_{i = 1}^{n}{a_i} - \min\limits_{a_i\ mod\ 10\neq 0}{a_i}& (\sum\limits_{i = 1}^{n}{a_i}\ mod\ 10 = 0)\\
0& (\forall{a_i}_{\{i \in [1, n] \}}\ mod\ 10 = 0)
\end{cases}
$$

显然这个问题还可拓展到任意倍数， 即将 $10$ 改成一个正整数 $k$， 并且 $n$ 也可以远不只 $100$, 大概可以达到 $10^{6}$的级别（ ~~毕竟要读入~~ ）。 

不过当然也有~~没写出贪心的~~涛神[@Krimson](https://www.luogu.com.cn/user/206998)的 bitset 做法， 只能膜拜。
### Code :
```cpp
#include <bits/stdc++.h>
template <class _Tp = int>
inline _Tp read() {
  _Tp w = 0;
  bool f = 0;
  char ch = getchar();
  while (!isdigit(ch)) f |= ch == '-', ch = getchar();
  while (isdigit(ch)) w = (w << 3) + (w << 1) + (ch ^ 48), ch = getchar();
  return f ? -w : w;
}
int n, k;
int sum, min = 1e9;
int main() {
  n = read(), k = 10;
  for (int i = 1, a; i <= n; i++) {
    a = read();
    sum += a;
    if (a % k) 
      min = std::min(min, a);
  }
  printf("%d",sum % k ? sum : std::max(0, sum - min));
  // 将 sum - min 和 0 取 max 以判断 a_i 全是 10 的倍数的状况
  return 0;
}
```
---

---

## 作者：MiddleRed (赞：0)

## Discription  
有 $N$ 道题，答对一道获得 $s_i$ 分，答错不得分。但是如果现在分数为 $10$ 的倍数将会显示 $0$ 分，问最高可以获得多少分？
  
  
## Solution  
第一眼看题面以为又是一道背包dp题，~~但这是第一题啊怎么会上来就dp(~~  
再仔细看这道题，发现数据很小，都在100以内，应该有更加简单的算法去解决。这题本质就是比较明显的贪心。  
首先，如果先去掉后半的限制，假定当总分为 $10$ 的倍数时不会变成 $0$ ，显然最高分就是输入的所有 $s_i$ 的总和。  
加上这个限制后，我们就考虑从总和中减去部分数字，使最后的总分不为 $10$ 的倍数即可。只要 $s_i$ 中存在一个不是 $10$ 的倍数的数字时，把这个数从总分中减去，则剩下总分就一定不再是 $10$ 的倍数。为了让最后的总分最大，我们就减去最小的不是 $10$ 的倍数的 $s_i$ 即可。  
最后特判下 $s_i$ 全是 $10$ 的倍数的情况就行。  
(注：luogu上题面的样例有误，当最大分数为0时也要输出0，而不是什么也不输出)

  
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100],sum;
bool all10=1;
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)	
	{
		cin>>a[i];
		sum+=a[i];	//算si总和
		if(a[i]%10!=0)	all10=0;
	}
	if(all10)	//如果si全为10的倍数
	{
		cout<<0;
		return 0;
	}
	sort(a,a+n);	//si从小到大排序
	for(int i=0;sum%10==0 and i<n;)
	{
		while(a[i]%10==0 and i<n)	i++;	//找出最小的满足条件的si
		sum-=a[i];
	}
	cout<<sum;
	return 0;
}
```


---


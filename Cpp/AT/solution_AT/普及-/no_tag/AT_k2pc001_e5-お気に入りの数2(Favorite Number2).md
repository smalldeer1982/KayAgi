# お気に入りの数2(Favorite Number2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/k2pc-easy/tasks/k2pc001_e5

 $ 2 $ 以上 $ n $ 以下の正整数 $ x $ に対して, 以下の操作が許されている.

- $ x+1 $ が$ n $ 以下のとき, $ x\ +\ 1 $ を新たな $ x $ とする.
- $ \sqrt{x} $ が整数のとき, $ \sqrt{x} $ を新たな $ x $ とする.

 例えば, $ x\ =\ 2 $ のとき, $ 3 $を新しい $ x $ とすることができる.  
 $ x\ =\ 4 $ のとき, $ (2,5) $ のいずれかを新しい $ x $ とすることができる.

 そこで, kagamizは $ x=2 $ として開始し, この操作で許される全ての遷移の仕方を, 少なくともそれぞれ $ 1 $ 回ずつ以上行って 再び $ x=2 $ に戻ってくるような方法のうち, 操作回数が最小になる場合にかかる操作回数を知りたい.  
 あなたの仕事は, そのような方法が存在するかどうかと, 存在するならばその最小操作回数をkagamizに教えてあげることである.

> $ n $

 入力では, 整数 $ n $ が $ 1 $ つだけ与えられる. 最小となる操作回数を出力せよ.  
 もし, そのような方法が存在しない場合は`-1`を出力せよ.  
 もしどのような操作も許されていない場合, 一切操作を行わなくても "この操作で許される全ての遷移の仕方を, 少なくともそれぞれ $ 1 $ 回ずつ以上行った", とみなしてよい. - $ 2\ ≦n\ ≦\ 10^{12} $ たどり着ける数の上限値
 
```

9
```

 ```

10
```

 ```

5
```

 ```

-1
```

 ```

4
```

 ```

3
```

# 题解

## 作者：RioBlu (赞：3)

错了很多很多次

因为本题有非常非常多的坑点

思路：先判断能否完成

若能完成那么先变成最大的完全平方数再变成次大的完全平方数
```
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
long long a,b,now=2,ans=0;
int main()
{
	cin>>a;
	if(a==2)//要将这个语句放在最前面(比输出-1前)（坑点1）
	{
	    cout<<0<<endl;
	    return 0;
	}
	if(sqrt(a)!=(long long)sqrt(a))//永远不能完成的
	{
	    cout<<-1<<endl;
	    return 0;
	}
	for(long long s=sqrt(a);s>=2;s--)//s必须是long long（坑点2）
	{
	    ans+=s*s-now+1;//不是long long 的话s*s可能会炸
	    now=s;
	}
	cout<<ans<<endl;
    //我才不会告诉你我不小心用了C++17(坑点2.5)
}
```

---

## 作者：Withers (赞：1)

这道题是一道按照题意模拟的题

~~我一开始也没看懂，错了好多次~~

这里提供一种while循环的做法

首先，我们必须得知道 输入的正整数 $n$ 必须是平方数或2，不然的话 $n-1$ 到 $n$ 之后就没有操作可以做了

然后，我们知道因为每个操作都要用，所以就是 $n$ ---> $\sqrt n$ ---> $\left(\sqrt n-1\right)^2$  这样一直循环下去，每次答案加上这个差值就可以了。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long x,sum=0;//sum是答案
    cin>>x;
    if(x==2) cout<<"0"<<endl;//特判，不然会WA
    else if(sqrt(x)!=ceil(sqrt(x))) cout<<"-1"<<endl;//不是平方数的不行
    else
    {
        sum=x-1;//先加上到根号x的次数
        long long k=sqrt(x);//k表示下一次x要到的数开方以后
        x=sqrt(x);
        while(x!=2)
        {
            k--;//每次减一
            sum+=k*k-x+1;//每次x到k的平方后再开根，一共这么多次
            x=k;//每次x更新成k
        }
        cout<<sum<<endl;
    }
}
```


---


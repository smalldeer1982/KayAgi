# 2015

## 题目描述

[problemUrl]: https://atcoder.jp/contests/NYC2015/tasks/nyc2015_1

入力は以下の形式で標準入力から与えられる。

> $ N $

 `Yes` または `No` と出力せよ。 ```

2015
```

 ```

Yes
```

 ```

2016
```

 ```

No
```

## 说明/提示

### Constraints

すぬけ君は、$ 2015 $ を $ 2 $ 進数で表すと `11111011111` となり回文になっていることに気づいた。 整数 $ N $ を (余計な $ 0 $ をつけない) $ 2 $ 進数で表したとき、回文になっているかどうか判定せよ。 ただし、左から呼んでも右から読んでも同じ文字列を回文という。

- - - - - -

- $ 1\ \leq\ N\ \leq\ 10^9 $

# 题解

## 作者：fa_555 (赞：9)

under 题解 [AT1157](https://www.luogu.org/problemnew/show/AT1157)

------------

**题意**

给定数字 N，判断它的二进制是否是回文。

$  $

二进制？当然是用 bitset！

$ O( \frac{n}{64}) $ 的时空复杂度、实现了与 `unsigned long` 和 `std::string` 之间的类型转换，简直不要更好用！

直接上代码，~~注释才是本体~~
``` cpp
#include<algorithm>
#include<bitset> // std::bitset 头文件 
#include<cmath>
#include<iostream>
#include<string>

using namespace std;

int N;
bitset<32> bit; // N <= 10^9，不少于 30 位 
string s, r;

int main() {
	cin >> N;
	bit = (unsigned)N;
		// bitset 支持与 unsigned long 之间使用 = 运算符赋值 

	s = r = bit.to_string().substr(32 - log2(N));
		// 成员函数 to_string() 返回 std::string 
		// 注意高位不足时会用 '0' 补齐，要去除高位的 '0' 

	reverse(r.begin(), r.end());
	cout << (s == r ? "Yes" : "No") << '\n';
		// 判断并输出 

	return 0;
}

```

**~~我永远爱STL~~**

---

## 作者：Null_Cat (赞：5)

哎写完以后发现好像没有用STL的```reverse```函数求解的哎。。。

看着最上面的大佬用的```bitset```发现窝是真的蔡。。。

---

本题考查要点：二进制基础

各位应该都知道```x&1```表示的就是x的末位叭。。。

然后代码就好理解了

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(int argc, char* argv[])
{
    long long n;
    string str = "";
    scanf("%lld", &n);
    while(n > 0)
    {
        str = char((n & 1) + '0') + str;
        n >>= 1;
    }
    string cstr = str;
    reverse(str.begin(), str.end());
    return 0 & puts((str == cstr ? "Yes" : "No"));
}
```

---

## 作者：做梦想Peach (赞：2)

看到题目，这题是黄题？

**~~本人认为最多是橙题~~**

废话不多说了，你只需要把输进来的数转成二进制的形式，然后判断是否回文就OK了。

下面我们来看看代码。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;//一堆没啥用的头文件，可以用bits/stdc++.h代替。
int read () {//快读。
	int s=0,w=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
	while (ch>='0' && ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int n,s[50],x,i;//n为输进来的数，s为n的二进制形式，x为二进制的长度。
int main () {
	n=read();//读入
	while (n>=1) {//转为二进制。
		s[x]=n%2;
		n/=2;
		x++;
	}
	x--;//注意这一步很重要，因为s的下标是从0开始的。
	for (i=0;i<=x/2;i++) //直接判断就可以了。
		if (s[i]!=s[x-i]) {
			puts ("No");
			return 0;
		}
	puts ("Yes");
	return 0; //好习惯。
}
//1     1    1   1  1  0  1 1 1 1 1
//1024 512 256 128 64 32 16 8 4 2 1
```
删去快读和没用的头文件只有18行！！！

来都来了，点个赞再走呗？*^▽^*

---

## 作者：3water (赞：2)

[AT1157](https://www.luogu.org/problem/AT1157)
# 利用栈和队列求解
C++中有一些自带的容器，比如stack（栈）和queue（队列），而两种容器的特性分别是 **“后进先出”** 和 **“先进先出”**。

利用二者的特性，我们可以快速求解。

话不多说,上代码——


------------

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,len;
stack<int>s1;//定义栈s1
queue<int>s2;//定义队列s2
int main() {
	cin >> n;
	while (n) {
	//利用位运算快速转换二进制,将数的二进制的每一位记录到两个容器中
		s1.push(n & 1);
		s2.push(n & 1);
		n >>= 1;
	}
	len = s1.size() / 2;//回文只需要判断左半边和右半边，中间可忽略
	while (len--) {
		if (s1.top() != s2.front()) {//判断当前的首位和末尾是否相同
			cout << "No\n";
			return 0;
		}
		s1.pop();//将当前末位弹出
		s2.pop();//将当前首位弹出
	}
	cout << "Yes\n";//左右两边完全一致
	return 0;
}
```


------------

## 25行~

---

## 作者：时律 (赞：1)

主题思想：读入，转化二进制存在$string$里，判断回文

这题太水了于是只能写那么多……？

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a;
	string b,c;
	scanf("%d",&a);
	while(a!=0)//通过这个存进来的二进制数是反着的 
	{
		b+=char(a%2+'0');
		a/=2;
	}
	c=b;
	for(int i=0;i<b.size()/2;i++)//反着是没有关系的，把它再变成正的，两个相比即可 
		swap(b[i],b[b.size()-i-1]);
	if(c==b)
		printf("Yes\n");
	else
		printf("No\n");
}
```

---

## 作者：CZQ_King (赞：1)

位运算大法好！

~~我从来不用什么进制转换~~


------------
做法：

先求出小于$N$的最大的$2$的幂的二进制的位数，然后用普通的回文判断法（就是那个对半找的算法，逐位比较）。

详情看代码

------------
代码：
```
#include<bits/stdc++.h>
using namespace std;
int L(int v){//获取位数，例如2015就返回1024的二进制位数，也就是10
	int r=0,s=0;
	r=(v>0xFFFF)<<4;v>>=r;//等价于s=(v>0xFFFF)<<3;v>>=s;r|=s;，但是这样比较快
	s=(v>0xFF)<<3;v>>=s;r|=s;
	/*
	如果v比0xFF大那么就说明v要右移8位
	r|=s等价于r+=s
	*/
	s=(v>0xF)<<2;v>>=s;r|=s;
	s=(v>0x3)<<1;v>>=s;r|=s;
	r|=(v>>1);
	return r;
	//其实主要思想是二分法，详情https://blog.csdn.net/u012138730/article/details/79818162
}
int main(){
	int N;
	cin>>N;
	int K=L(N);//获取位数
	for(int i=0;i<=(K>>1);i++){//对半找
		if((N>>i&1)^(N>>(K-i)&1)){//a>>b&1代表a的二进制的第b位
			puts("No");//如果对应的两位不一样
			return 0;
		}
	}
	puts("Yes");//一样
	return 0;
}
```

---

## 作者：Anguei (赞：1)

来一发简短的 Python 题解吧！这里提供两种做法。

## 使用自带进制转换函数（两行）
就这么短
```python
bin = bin(int(raw_input()))[2:]
print 'Yes' if (''.join(reversed(bin)) == bin) else 'No'
```

## 用位运算手写进制转换（四行）
可以不断地对 $N$ 与 $1$ 进行按位与运算并将 $N$ 右移一位，完成进制转换操作。
因为本题要判断回文，所以不需要倒序存储。
```python
n, bin = int(raw_input()), ''
while n:
    bin += str(n & 1)
    n >>= 1
print 'Yes' if (''.join(reversed(bin)) == bin) else 'No'
```
**人生苦短，我用 Python。**

---

## 作者：Zirnc (赞：0)

[ChungZH's blog](https://chungzh.cn) · [更好的阅读体验](https://oi.chungzh.cn/2019/07/24/at1157/)

# 题目链接

https://www.luogu.org/problemnew/show/AT1157

# 题解

这题还是比较简单的，考的就是 **把十进制数字转成二进制数字** 以及 **判断数字是否回文**。

判断回文最简单的方法就是：把一个字符串翻转后，判断是否还等于原字符串。如果等于，就是回文。不等于就不是回文。

为了让大家不抄袭，我就只给出核心的代码吧：

```cpp

// a 和 b 都是字符串，N 是输入的数

while (N)
{
    if (N % 2 == 0)
        a += '0';
    else
        a += '1';

    N /= 2;
}

b = a;
reverse(b.begin(), b.end());

// 接下来判断两个字符串是否相等


```

---

## 作者：_lyc233 (赞：0)

## P党题解！
------------
题目大意：给定数字N，判断它的二进制是否是回文。

所以程序大体分为两步走：1.将N转二进制；2.判断N的二进制是否为回文

------------
需注意的几点：

  1.回文数是什么：回文数，即正读与反读都一样的数，定义请见[回文数](https://baike.so.com/doc/6344828-6558451.html)
  2.转二进制，可以用连续的div 2，再用mod 2将数据储存（见代码1）。
  
     //十进制转二进制核心代码
     while n>0 do
      begin
        i:=i+1;
        a[i]:=n mod 2;
        n:=n div 2;
      end;
     //代码1 
  3.为了避免数组存放的占用位置，可以使用字符串存放（如代码2）
  
    while n>0 do
     begin
       str(n mod 2,ch); //str是将某个数x转成字符串s用的过程(str(x,s))
       n:=n div 2;
       st:=st+ch;  //st=原来的+新的
     end;
    //代码2
  4.判断一个数是否为回文数，可以用代码3的形式来判断
  
    for i:=1 to length(st) div 2 do  //只需做到length(st) div 2
     if st[i]<>st[length(st)-i+1] then  //公式推导出的st[i]<>st[**length(st)-i+1**]
------------
愉快の打代码：
```pascal
var
  ch,st:ansistring;
  n,i:longint;
begin
  readln(n);  //输入
  while n>0 do
   begin
     str(n mod 2,ch);
     n:=n div 2;
     st:=st+ch;
   end;  //转二进制并存到st字符串中
  for i:=1 to length(st) div 2 do
   if st[i]<>st[length(st)-i+1] then
    begin
      writeln('No');  //一旦不满足直接输出，
      halt;           //紧接着halt结束整个程序
    end;  //判断回文数
  writeln('Yes');  //输出（AT大坑，输出换行）
end.
```
------------
**文明题解，文明洛谷；不抄题解，rp++。**

---

## 作者：Jinyeke (赞：0)

### 题目：给定一个数字，判断它的二进制是否是回文。
十进制转二进制公式（pascal）
设x为余数，n为输入的数，如下：
```pascal
while n<>0 do 
 begin
  x:=n mod 2;
  str(x,t);
  s:=s+t;
  n:=n div 2;
 end;
```
上面的可以背一下呦，到时候十进制转2~9进制只要改一下mod几和div几就行了，此题完整程序如下（pascal）
```pascal
var
 s,t:string;
 p:boolean;
 i,j,n,x:longint;
begin
 read(n);
 while n<>0 do
  begin
   x:=n mod 2;//x为余数
   str(x,t);//将余数转成字符串
   s:=s+t;//s为最终字符串，所以加上去
   n:=n div 2;//n除以二
  end;
  p:=true;//默认为回文数
  i:=1;//从第一位开始找
  j:=length(s);//从最后一位反找
  while (i<=j) and (p=true) do 
   begin
    if s[i]<>s[j] then p:=false;//不相等就不是回文数
    inc(i);//继续找
    dec(j);//继续倒找
   end;
  if p then writeln('Yes')//是回文数就输出'Yes'
   else writeln('No');//不是就输出'No'
end.
```
### 共建文明洛谷，请勿Ctrl+C!

---

## 作者：_Qer (赞：0)

题目要求把一个数转换成二进制判断其是否回文

我们可以用一个bool数组存换成二进制后每一位的值（因为二进制每一位都为0或1，而bool也是），再进行回文的匹配。

二进制可以通过下面这一段程序来取出：

```cpp
while(n){//n为输入的数
    t[len++]=(n&1);//t是bool数组，len为其当前长度
    //同t[len]=(n%2);len++;
    n/=2;//下一位
}
```

而回文部分，我们可以用一个循环，判前半部分，与其对应的那一位匹配。

经过一些推理思考，我们可以发现：

t[i]对应的正好是t[len-i-1]，而循环正好到len/2（下取整）

不信可以自己看。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;//原数
bool t[100];//二进制后
int len;//二进制长度
int main(){
    cin>>n;
    while(n){
        t[len++]=(n&1);
        n/=2;
    }//取二进制
    for(int i=0;i<len/2;++i){//前半部分
        if(t[i]!=t[len-i-1]){//不相等
            cout<<"No"<<endl;
            return 0;//避免多次输出
        }
    }
    cout<<"Yes"<<endl;//相等
    return 0;
}
```

---


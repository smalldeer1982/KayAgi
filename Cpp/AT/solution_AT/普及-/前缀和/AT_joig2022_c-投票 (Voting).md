# 投票 (Voting)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joig2022-open/tasks/joig2022_c

JOI 高校において，ある議題に関して「賛成」か「反対」かを問う採決が行われ，$ N $ 人の生徒が順番に投票を行った．生徒は自分の投票前に，それまでに投票した他の生徒がどちらに投票したかを知ることができた．

$ i $ 番目 ($ 1\ \leqq\ i\ \leqq\ N $) に投票した生徒は，次の条件を満たしたとき「賛成」に投票し，満たさなかったとき「反対」に投票した．

- 直前に投票した $ X_i $ 人の生徒，すなわち $ i-1,i-2,...,i-X_i $ 番目に投票した生徒のうち，$ Y_i $ 人以上が「賛成」に投票した．

ただし， $ Y_i=0 $ のときは他の生徒の投票に関わらず「賛成」に投票し，$ Y_i=X_i+1 $ のときは他の生徒の投票に関わらず「反対」に投票したとする．

各生徒の投票についての情報が与えられたとき，「賛成」に投票した生徒の人数を求めるプログラムを作成せよ．

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 500\,000 $．
- $ 0\ \leqq\ X_i\ \leqq\ i-1 $ ($ 1\ \leqq\ i\ \leqq\ N $)．
- $ 0\ \leqq\ Y_i\ \leqq\ X_i+1 $ ($ 1\ \leqq\ i\ \leqq\ N $)．
- 入力される値はすべて整数である．

### 小課題

1. ($ 28 $ 点) $ N\ \leqq\ 3\,000 $．
2. ($ 32 $ 点) $ X_i\ =\ i-1 $ ($ 1\ \leqq\ i\ \leqq\ N $)．
3. ($ 40 $ 点) 追加の制約はない．

### 採点に関する注意

すべての提出はジャッジシステム上で採点される．

提出されたソースコードは，小課題に対応するすべての採点用入力データについて正しい結果を返したとき，その小課題について正解と認められる．

各提出の得点は，提出されたソースコードについて正解と認められた小課題の得点の合計である．

この課題の得点は，**この課題に対するすべての提出の得点の最大値**である．

現在の得点は「提出結果」タブの「自分の得点状況」から確認できる．

### Sample Explanation 1

投票は，以下のように $ 4 $ 人の生徒によって順番に行われた． 1. $ 1 $ 番目に投票した生徒は，$ Y_1=X_1+1 $ であるため，「反対」に投票した． 2. $ 2 $ 番目に投票した生徒は，$ Y_2=0 $ であるため，「賛成」に投票した． 3. 直前に投票した $ X_3(=1) $ 人の生徒のうち「賛成」に投票したのは $ 1 $ 人で，これは $ Y_3(=1) $ 人以上である．そのため，$ 3 $ 番目に投票した生徒は「賛成」に投票した． 4. 直前に投票した $ X_4(=3) $ 人の生徒のうち「賛成」に投票したのは $ 2 $ 人で，これは $ Y_4(=3) $ 人以上ではない．そのため，$ 4 $ 番目に投票した生徒は「反対」に投票した． 「賛成」に投票した生徒は $ 2 $ 人である．したがって，$ 2 $ を出力する． この入力例は小課題 $ 1,3 $ の制約を満たす．

### Sample Explanation 2

この入力例はすべての小課題の制約を満たす．

### Sample Explanation 3

この入力例は小課題 $ 1,3 $ の制約を満たす．

## 样例 #1

### 输入

```
4
0 1
1 0
1 1
3 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5
0 0
1 1
2 3
3 1
4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10
0 0
1 2
1 1
1 0
3 1
2 3
1 1
5 3
8 4
7 2```

### 输出

```
4```

# 题解

## 作者：__hqt__ (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/AT_joig2022_c)


------------


这道题我的第一反应是可以枚举学生，每个学生枚举范围内赞同的人数，判断是否大于等于最低要求，大于就自增计数变量，最后输出。  
时间复杂度：$O(n^2)$。

### 代码：
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int x[500001],y[500001];//定义数组 
bool z[500001];
int main()
{
	int n,zc=0;//定义赞成人数变量，一定要初始化为0 
	cin>>n;//输入n 
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];//输入x、y
	}
	for(int i=1;i<=n;i++)
	{
		int t=0;//定义当前符合要求的赞成人数变量，一定要初始化为0 
		for(int j=i-x[i];j<=i;j++)//枚举范围内的数 
		{
			if(z[j]==1)//当前人赞同 
			{
				t++;//自增符合要求的赞成人数变量
			}
		}
		if(t>=y[i])//赞同人数>=要求人数 
		{
			z[i]=1;//标记当前位可以 
			zc++;//自增赞成人数
		}
	}
	cout<<zc<<endl;//输出 
}
```
不过超时了。  
![](https://cdn.luogu.com.cn/upload/image_hosting/lsu8t8j4.png)  
~~不超时这道题能评橙吗？~~


------------


### 再想想，有没有什么优化方法？
定义一个数组 $z$，$z_i$ 表示 $\sum_{j=1}^{i} a_j$。  
范围内赞同的人数就等于全部人数减不赞同的人数。  
即赞同人数 $=z_{i-1}-z_{i-x_i-1}$。  
$z$ 数组可以边计算赞同人数边更新。  
**$z_n$ 就是最终结果。**  
**这样时间复杂度就降到 $O(n)$ 了。**  
~~这不就是前缀和吗？~~  

### 代码：
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int x[500001],y[500001],z[500001];//定义数组 
int main()
{
	int n;//不需要定义赞成人数变量，z[n]就是赞成人数 
	cin>>n;//输入n 
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];//输入x、y
	}
	for(int i=1;i<=n;i++)
	{
		if(z[i-1]-z[i-x[i]-1]>=y[i])//总前缀和减不符合要求的和等于符合要求的和 
		{
			z[i]=z[i-1]+1;//赞同，前面总赞同人数加自己 
		}
		else
		{
			z[i]=z[i-1];//不赞同，总赞同人数就是前一位的人数 
		}
	}
	cout<<z[n]<<endl;//z[n]就是总赞成人数 
}
```


------------

### 温馨提示：大数组最好定义成全局变量，要不然容易RE

---

## 作者：CEFqwq (赞：1)

本题我在洛谷上没有通过，因为 RMJ 炸了，所以放出 [ATAC记录](https://atcoder.jp/contests/joig2022-open/submissions/45340272)，请管理不要因为未通过本题打回该题解，谢谢。

题意：有 $n$ 个人投票，每个人有参数 $x_i,y_i$，第 $i$ 个人只会在 $[i-x_i+1,i]$ 区间内的人投了不少于 $y_i$ 个赞成票时赞成，否则反对。

请求出多少人投赞成票。

这道题目其实是一道比较简单的模拟，我们只要用前缀和求出区间内有多少人投了赞成即可，可以边做边处理。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y,a[500005];
int main(int n){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>x>>y;
		a[i+1]=a[i];//前缀和
		if(a[i]-a[i-x]>=y)a[i+1]++;//第i个人赞成
	}
	cout<<a[n];
}
```

---

## 作者：duanfeitong (赞：0)

# AT_joig2022_c 投票 (Voting) 题解

### [题目链接](https://www.luogu.com.cn/problem/AT_joig2022_c)

### 题目分析

简单来说，有 $n$ 个人，~~个个都是墙头草~~，会去看自己前面 $x_i-1$ 个人一共投了多少票，如果不少于 $y_i$ 他就投赞成票，否则就反对（非常现实）

Subtask 1：直接暴力。

Subtask 2、3：前缀和。

暴力就懒得写了，前缀和的思路是：统计第  $i$ 个人以前有 $s_i$ 个人投票，那么当前第 $i$ 个人看的就是 $s_i-s_{i-x_i}$ 和 $y_i$ 的大小关系，比较即可。可以使用在线算法。（不得不说真的和前缀和的板子没差多少）

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ld double
ll n,x,y,sum[500010];
int main()
{
	ios::sync_with_stdio(0),cin.tie(); 
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		if(sum[i]-sum[i-x]>=y)sum[i+1]=sum[i]+1;//赞成
   		else sum[i+1]=sum[i];//反对
	}
	cout<<sum[n];//最后一个人看到的票数和加上他投的票就是最终的结果
  	return 0;
}
```

谢谢观看。

---

## 作者：nkrqzjc_zzz (赞：0)

## [题目链接](https://www.luogu.com.cn/problem/AT_joig2022_c)
~~题外话~~本人第一篇题解，请多多指教~

**首先**看到这道题，我还感叹，就这纯暴力还橙的？？？就打了个暴力，代码如下：

### TLE 代码
```cpp
#include<ios>//头文件（本人酷爱压行，建议头文件改成万能头）
const int aa=5e5+2; 
int x[aa],y[aa],a[aa],n,dn,ji;
main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&x[i],&y[i]);//输入
	for(int i=1;i<=n;i++){
		ji=0;
		for(int j=i-x[i];j<=i;j++)
        		if(a[j])ji++;//根据题意枚举有多少人投赞成票
		if(ji>=y[i]){
			a[i]=1;
			dn++;
		}
	}
	printf("%d",dn);//输出
}
```


于是就……

![](https://cdn.luogu.com.cn/upload/image_hosting/em7mlq4y.png)

好的来分析一下下，简单来说是因为我没看到 $n$ 的范围，导致直接 $T$ 掉了。

![](https://cdn.luogu.com.cn/upload/image_hosting/r868s1qe.png)

那我们再重新回到题目中，发现了**区间**一词，这就是题目给的提示，简单来说就是可以用前缀和求解本题，将时间复杂度从 $O ( n ^ 2 )$ 直线下降到 $O ( n )$。

简单修改后……

![](https://cdn.luogu.com.cn/upload/image_hosting/mqqn3rb3.png)

### AC 代码
```cpp
#include<ios>
const int aa=5e5+2;
int a[aa],n,x,y;
main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&y);//输入的时候同时处理答案
		a[i+1]+=a[i];//前缀和
		if(a[i]-a[i-x]>=y)//根据题意判断有多少人投赞成票
			a[i+1]++;
	}
	printf("%d",a[n+1]);
}
```


---


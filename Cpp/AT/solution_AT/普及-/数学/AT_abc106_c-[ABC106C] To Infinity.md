# [ABC106C] To Infinity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc106/tasks/abc106_c

Mr. Infinity は, `1` から `9` までの数字からなる文字列 $ S $ を持っている. この文字列は, 日付が変わるたびに次のように変化する.

- 文字列 $ S $ に含まれるそれぞれの `2` が `22`, `3` が `333`, `4` が `4444`, `5` が `55555`, `6` が `666666`, `7` が `7777777`, `8` が `88888888`, `9` が `999999999` に置き換わる. `1` は `1` のまま残る.

例えば, $ S $ が `1324` の場合, 翌日には `1333224444` になり, 翌々日には `133333333322224444444444444444` になる.  
 あなたは $ 5000 $ 兆日後に文字列がどのようになっているか知りたい. $ 5000 $ 兆日後の文字列の左から $ K $ 文字目は何か？

## 说明/提示

### 制約

- $ S $ は $ 1 $ 文字以上 $ 100 $ 文字以下の文字列.
- $ K $ は $ 1 $ 以上 $ 10^{18} $ 以下の整数.
- $ 5000 $ 兆日後の文字列の長さは $ K $ 文字以上である.

### Sample Explanation 1

文字列 $ S $ は次のように変化していく. - 現在: `1214` - $ 1 $ 日後: `12214444` - $ 2 $ 日後: `1222214444444444444444` - $ 3 $ 日後: `12222222214444444444444444444444444444444444444444444444444444444444444444` $ 5000 $ 兆日後の文字列の最初 $ 5 $ 文字は `12222` となる. $ K=4 $ なので, $ 4 $ 文字目の `2` を出力すればよい.

### Sample Explanation 2

文字列ははじめ `3` である. $ 5000 $ 兆日経ったとき, 文字列は `3` だけで構成される.

## 样例 #1

### 输入

```
1214
4```

### 输出

```
2```

## 样例 #2

### 输入

```
3
157```

### 输出

```
3```

## 样例 #3

### 输入

```
299792458
9460730472580800```

### 输出

```
2```

# 题解

## 作者：RioBlu (赞：4)

这题其实特别简单，因为当经过了$10^{15}$

$S=12$时,新数列就会变成$S=12222222.....$

$S=123$时,新数列就会变成$S=12222222.....33333....$

但是，你算算$2$有多少个？

$2$经过$10^{15}$天后，会有几乎无穷大多个$2(2^{(10^{15})})$

这时除了$K=1$,在$1<K<10^{18}$时，必定为$2$

___

所以，答案其实很简单，当$S$前面有$I$个$1$

如果$I<=K$输出$1$

否则输出第一个不为$1$的数字
```cpp
#include<bits/stdc++.h>
using namespace std;
string n;
long long a;
int main()
{
	cin>>n>>a;
	for(int s=0;s<a;s++)
	{
		if(n[s]!='1')
		{
			cout<<n[s]<<endl;
			return 0;
		}
	}
	cout<<1<<endl;
}
```

---

## 作者：Otomachi_Una_ (赞：3)

这道题目看上去复杂，实际上是一道大水题。

我们先思考当 $S=2$

第一天：$S=22$

第二天：$S=2222$

第三天：$S=22222222$

第四天：$S=2222222222222222$

$\cdots$

第 $k$ 天：$S=\begin{matrix}\underbrace{2222\cdots22}\\2^k\end{matrix}$

可以发现当过了 $10^{15}$ 天后， $S$ 的长度已经超出了 $K$ 的最大值了。

所以我们只需要找出 $S$ 的前 $K$ 个字符中第一个非 $1$ 的即可，如果找不到再输出 $1$ 。

## _Code_

```cpp
#include<iostream>
#include<cstring>
#include<map>
using namespace std;
string s;
long long k;
int main(){
	cin>>s>>k;
	for(int i=0;i<k;i++)
		if(s[i]!='1'){
			cout<<s[i]<<endl;
			return 0;
		}
	cout<<"1"<<endl;
	return 0;
}
```


---

## 作者：ttq012 (赞：1)

思维题，建议评级：黄。

借鉴了题解区各位大佬的思路。

容易发现，假设 $s_i$ 为 $1$，那么这个数经过 $10^{15}$ 天之后一定不会变动。

在 $2\sim 9$ 的剩余的数字中，经过 $10^{15}$ 天之后，$2$ 增加的数字的数量最少。但是也会有 $2^{10^{15}}$ 个新增加的 $2$，远远大于 $K$ 的最大的范围 $10^{18}$。

那么答案就是从左往右枚举的第一个不是 $1$ 的数？如果 $K = 1$，并且序列为 `1123`，不管过了多少天前 $2$ 位都是 $1$，这个时候应该输出 $1$。容易发现，如果前 $K$ 位都是 $1$，那么不过过多少天，前 $K$ 位都还是 $1$。

那么结论就出来了：如果前 $K$ 位都是 $1$，那么答案就是 $1$，否则答案是第一个在 $s$ 串中出现的非 $1$ 的数。

时间复杂度 $\mathcal O(\min(K, |s|))$。

**Code**

```cpp
#include <bits/stdc++.h>

using namespace std;

signed main() {
    string s;
    int k;
    cin >> s >> k;
    int idx = 1;
    int sz = s.size();
    for (int i = 0; i < k; i ++) {
        if (i >= sz)
            break; // 不然会越界
        if (s[i] != '1') {
            idx = s[i] ^ 48;
            break;
        }
    }
    cout << idx << '\n';
    return 0;
}

```


---


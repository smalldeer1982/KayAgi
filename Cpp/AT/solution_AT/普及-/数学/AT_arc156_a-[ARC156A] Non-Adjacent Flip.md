# [ARC156A] Non-Adjacent Flip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc156/tasks/arc156_a

$ 1 $ から $ N $ の番号がついた、表裏が区別できるコインが $ N $ 枚あります。コインの表裏は長さ $ N $ の文字列 $ S $ で表され、$ S $ の $ i $ 番目の文字が `1` のときコイン $ i $ は表を向いており、`0` のときコイン $ i $ は裏を向いています。

あなたは、以下の操作を $ 0 $ 回以上好きな回数繰り返すことができます。

- $ 1\leq\ i\ <\ j\leq\ N $ かつ $ j-i\geq\ \bm{2} $ を満たす整数組 $ (i,j) $ を選ぶ。コイン $ i $ とコイン $ j $ を裏返す。
 
操作によって $ N $ 枚のコイン全てを裏向きにできるか判定し、可能な場合必要な操作の回数の最小値を求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\times\ 10^5 $
- $ 3\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ S $ は `0`, `1` からなる長さ $ N $ の文字列
- 入力される数値は全て整数
- $ 1 $ つの入力に含まれるテストケースについて、$ N $ の総和は $ 2\times\ 10^5 $ 以下
 
### Sample Explanation 1

$ 1 $ 番目のテストケースについては、$ (i,j)=(1,3) $ として操作を $ 1 $ 回行うと、$ 1 $ 回の操作でコインを全て裏向きにできます。 $ 2 $ 番目のテストケースについては、$ (i,j)=(1,3) $ として操作を $ 1 $ 回行い、$ (i,j)=(4,6) $ として操作を $ 1 $ 回行うと、$ 2 $ 回の操作でコインを全て裏向きにできます。 $ 3 $ 番目のテストケースについては、コインを全て裏向きにできないことが証明できるので、`-1` を出力してください。 $ 4 $ 番目のテストケースについては、コインは既に全て裏向きなので、操作は必要ありません。

## 样例 #1

### 输入

```
5
3
101
6
101101
5
11111
6
000000
30
111011100110101100101000000111```

### 输出

```
1
2
-1
0
8```

# 题解

## 作者：LegendaryGrandmaster (赞：4)

当有奇数个正面朝上，则不管多少次，都不会成立。

偶数时分类讨论如下：

1. `110` 和 `011` 不成立。

2. 当只有 2 个正面朝上，且长度为 4，正面朝上的硬币是中间两个时，则需操作 3 次。

3. 当只有 2 个朝上，且长度不为 4，则需要 2 次。

4. 其余需要正面朝上的硬币的个数 $ \div 2$ 次。

----------

* 对于 1 的解释：

由于题目已知，每次反转的硬币不能紧挨着，则第二个硬币永远动不了，不成立。

* 对于 2 的解释：

```
initial: 0110
step 1:  1111
step 2:  0101
step 3:  0000
```

无法做出比 3 要少的最优解。

* 对于 3 的解释：

因为两个紧挨着，所以可以先和离得比较远的反面硬币交换，然后剩余两个交换。

例子：

```
initial: 1100
step 1:  0101
step 2:  0000
```

* 对于 4 的解释：

只要不和自己紧挨着的正面朝上的硬币组合，每个都可以成功配对。

看样例同样可以发现此规律。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
int a[N];
void slove()
{
	int n;
	string st;
	cin>>n>>st;
	int ans=0;
	for(int i=0;i<st.size();i++)
		if(st[i]=='1')ans++,a[ans]=i+1;
	if(ans&1||st=="110"||st=="011")cout<<"-1\n";
	else if(st=="0110")cout<<"3\n";
	else if(ans==2&&a[1]+1==a[2])cout<<"2\n";
	else cout<<ans/2<<'\n';
}
signed main()
{
	int t;
	cin>>t;
	while(t--)slove();
}
```

---

## 作者：hellolin (赞：1)

[题面(洛谷)](https://www.luogu.com.cn/problem/AT_arc156_a)

[题面(AtCoder)](https://atcoder.jp/contests/arc156/tasks/arc156_a)

AtCoder Problems 评级：$\texttt{\color{#ffb972}510}$

## 题意

- **多组测试数据**。
- 给你一个字符串 $S$，只包含 $1$、$0$，每次你可以选**不相邻**的两个字符，将两字符翻转（分别对于两个字符，将 $1$ 换成 $0$，$0$ 换成 $1$）。
- 问你有没有方法把 $S$ 变成全 $0$ 的字符串，如果有，输出最少的步骤，否则输出 `-1`。
- $1\le T\le 2\times 10^5,\ 3\le N\le 2\times 10^5,\ \sum N\le 2\times 10^5$。

## 思路

一拿到这题的思路是统计字符串中 $1$ 的个数，奇数输出 `-1`，偶数输出个数除以二。这样会 $\texttt{WA}\times 3$，因为题目要求选的两位置**不相邻**。

那么都有哪些特殊情况呢？很容易想到，当只含有两个 $1$ 且两个 $1$ 相邻，需要特判；而 $1111$、$111111$ 等等，这种就不用了。具体如下：

1. $11$、$011$、$110$： `-1`；
2. $0110$： `3`（$0110\to 0{\color{red} 0}1{\color{red} 1}\to {\color{red}1}01{\color{red}0}\to { {\color{red} 0}0{\color{red}0}0}$）；
3. 其他情况（字符串中仅有两个 $1$，且相邻，例如 $1100$）： `2`（$\underbrace{\dotso}_{0} 1100\underbrace{\dotso}_{0}\to \dotso{\color{red}{0}}10{\color{red}1}\dotso\to \dotso0{\color{red}0}0{\color{red}0}\dotso$）。

## 代码

``` cpp
#include <iostream>
using namespace std;
int t, n, ans;
string s;
bool f;
void solve()
{
    cin>>n>>s;
    ans=0; // 多组测试数据，记得初始化
    f=0;
    for(int i=0; i<s.length()-1; i++)
    {
        ans+=(s[i]=='1');
        if(i && (s[i]=='1'&&s[i-1]=='1')) f=1; // 有两个相邻的 1
    }
    if((ans==2)&&f)
    {
        if(s=="11" || s=="011" || s=="110")
            cout<<(-1)<<endl; // 几种无解情况
        else if(s=="0110") cout<<3<<endl;
        else cout<<2<<endl;
    }
    else if(ans%2)
        cout<<(-1)<<endl; // 是奇数，这种情况下怎么操作总会有奇数个 1，显然无解
    else cout<<ans/2<<endl; // 一般情况
}
int main()
{
    cin>>t;
    while(t--) solve(); // 多组测试数据
    return 0;
}
```


---

## 作者：LiJinLin_AFO (赞：0)

# AT_arc156_a 题解

~~有一点点难度~~


## 正文开始
首先，显而易见，当 $1$ 的个数为奇数时，这种情况不存在，输出 $-1$。

那么 $1$ 的个数为偶数呢？

我们可以用一个数组 $a$ 存储 $1$ 出现的位置，对于像我一样的蒟蒻来说，可以分为两种情况：

1. 特判。当只有两个 $1$ 时，要判断这两个 $1$ 下标的距离是否大于等于 $2$。如果是，输出 $1$，否则过程不能实现，输出 $-1$。

2. 其余情况。设有 $tp$ 个 $1$，因为 $tp \ge 2$ 且 $tp$ 为偶数，所以在 $a$ 数组中，下标 $1$ 对应下标 $3$，下标 $2$ 对应下标 $4$，以此类推，都可以被消去。这怎么证明呢？假设这种情况极其不利，上来就是三个 $1$，假设 $a$ 数组中 $a_1 = 1$ 且 $a_2 = 2$ 且 $a_3 = 3$，即使 $a_1$ 和 $a_2$ 之间只差了 $1$，而 $a_1$ 和 $a_3$ 在最坏的情况下也相差 $2$，其余情况同理。所以，这种情况存在，输出 $\displaystyle \frac{tp}{2}$。

上代码：
```cpp
#include<iostream>
#include<string>
using namespace std;
int a[200005];//存储下标
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,tp=0;
		cin>>n;
		for(int i=1;i<=n;i++){
			char c;
			cin>>c;
			if(c=='1') a[++tp]=i;
		}//输入并且存储1的下标
		if(tp&1){
			cout<<"-1\n";
			continue;
		}//tp为奇数
		if(tp==2&&a[2]-a[1]<2){
			cout<<"-1\n";
			continue;
		}//情况1
		printf("%d\n",tp>>1);//情况2
	}
	return 0;
}
```
注：请勿抄袭！

---

## 作者：Jasonshan10 (赞：0)

## 题意

* **多组测试数据**

* 给一字符串 $S$，只包含 $0$ 和 $1$，每次选定**不相邻**两个字符，将选定两个字符翻转。

* 有没有方法将 $S$ 变成全 $0$ 的。 

## 思路

先考虑**偶数个**正面朝上，分类如下：

1.```011``` 和 ```110``` 不成立。

2.如果是 ```0110``` 则需要 $3$ 次。

**解释**：```0110``` $\rightarrow$ ```1111``` $\rightarrow$ ```1010``` $\rightarrow$ ```0000```。

3.当只有两个朝上，长度不为 $4$，需要 $2$ 次。

**解释**：因为两个紧挨，所以可以首先和离得远的反面硬币交换，然后剩再将余两个交换。

4.其余翻转次数则为正面朝上 $\div 2$ 次。

接着**奇数**个就好判断了，因为一定是输出 ```-1```。


## 代码：

[AC记录](https://atcoder.jp/contests/arc156/submissions/44363924)

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+10;
int a[MAXN];
string s;
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
	    int n,ans=0;
    	scanf("%d",&n);
    	cin>>s;
    	for(int i=0;i<s.size();++i){
    	    if(s[i]=='1'){
    	        a[++ans]=i+1;
    	    }
    	}
    	if(ans&1||s=="011"||s=="110"){
    	    printf("-1\n");
    	}
    	else if(s=="0110"){
    	    printf("3\n");
    	}
    	else if(ans==2&&a[1]+1==a[2]){
    	    printf("2\n");
    	}
    	else{
    	    printf("%d\n",ans/2);
    	}
	}
}
```

---

## 作者：_Communist (赞：0)

### 题意

给出一个长为 $N$ 的 $01$ 串（原意是硬币），你可以做以下操作任意次：

- 给定一个数对 $(i,j)$，其中 $1\leq i<j\leq N$，且 $j-i\geq2$， 让第 $i$ 个和第 $j$ 个字符翻转。

求让整个字符串变为全 $0$ 串的最少操作次数。如果无法得到，输出 `-1`。

多组测试数据，共有 $T$ 组。

注：翻转的定义：如果该字符原本是 $1$，则变成 $0$；如果是 $0$，则变成 $1$。

### 思路

首先，由于每次操作都要对 $2$ 个字符翻转，所以 $1$ 个数的奇偶性不变，如果存在奇数个 $1$，一定不行，输出 `-1`。

如果 $1$ 的个数 $\geq 4$ 可以翻转变为 $0$ 的话，答案就是 $1$ 的个数除以 $2$，对一个 $1$ 翻转多次是没有意义的。

题目中的 $j-i\ge 2$，实际上就是不相邻。所以我们只用看两个 $1$ 相邻的情况。其实，只要有至少 $4$ 个 $1$，总可以翻转成 $0$。可以自行画图证明。（因为第一个 $1$ 和 第三个 $1$ 中间一定隔着第二个 $1$，所以第一个可以和第三个翻转，同理，第二个和第四个可以翻转）。

因此只有 $2$ 个 $1$ 的情况需要考虑。

- 如果 $2$ 个 $1$ 不相邻，显然可以；

- 如果 $2$ 个 $1$ 相邻：

	显然是不能直接 $1$ 次翻转的。但是我们可以在两边任选一个元素 $i$，让左边的 $1$ 和 $i$ 翻转，再让右边的 $1$ 和 $i$ 翻转，共 $2$ 次。可以证明是最优方案。$i$ **必须不与两个** $1$ **中的任意一个相邻**。

对于其他情况，都是不可以的。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T, n;
string s;
vector<int> v;
int main() {
	cin >> T;
	while (T--) {
		cin >> n >> s;
		v.clear();
		for (int i = 0; i < s.length(); ++i) {
			if (s[i] == '1') v.push_back(i + 1);
		}
		if (v.size() % 2 == 1) {
			puts("-1");
			continue;
		}
		if (v.size() == 2 && v[0] + 1 == v[1]) {
			if (v[0] + 3 > n && v[1] - 3 < 1 && v[0] - 2 < 1 && v[1] + 2 > n) {
				if (v[0] - 1 < 1 || v[1] + 1 > n) {
					puts("-1");
				} else puts("3");
				continue;
			} else {
				puts("2");
				continue;
			}
		}
		cout << (v.size() / 2) << endl;
	}
	return 0;
}
```

---

## 作者：MoyunAllgorithm (赞：0)

**题意**

给你一个由 $0$ 和 $1$ 组成的数组，长度 $N \le 2 \times 10^5$。你将进行若干次（可能为 $0$ 次）：

- 选择下标 $1 \le i < j \le N,j-i \ge 2$（也就是不连着）。令 $a_i$ 和 $a_j$ 反转，即 $0$ 变 $1$、$1$ 变 $0$。

求出最少操作次数。如果无法做到，输出 `-1`。

个人推荐难度：黄（代码难度低，但很考察细心）／ 相当于 $\text{ABC-Problem D}$

**分析**

令 $sum$ 为 $\sum a_i$，也就是数列中 $1$ 的个数。

若 $sum$ 不是 $2$ 的倍数，显然无解，因为无论如何操作 $sum$ 的奇偶性不变。

若 $sum$ 是 $2$ 的倍数：

**情况一** 假如 $sum>2$，那我们可以进行 $\dfrac{sum}{2}$ 次操作，每次翻转第 $i$ 和第 $i+\dfrac{sum}{2}$ 个 $1$。例如：

$a=\{1,1,1,0,1,0,1,1\}$ 

依次翻转 $(a_1,a_5),(a_2,a_7),(a_3,a_8)$。

可以发现，我们每次翻转的元素不是连着的。

**情况二** 假如 $sum=0$，答案为 $0$。

**情况三** 假如 $sum=2$：

找到两个 $1$ 元素，设他们的下标为 $i,j$。

如果 $j-i \ge 2$，翻转即可，答案为 $1$。

如果 $j-i=1$，那么 $N=2$ 时无解。

如果 $N=3$，那么只有 $1$ 种情况：

$\{0,1,1\}$。也就是无解。

如果 $N=4$，那么 $2$ 种情况：

$\{1,1,0,0\},\{0,1,1,0\}$。

第一种需要 $2$ 次，即依次翻转 $(1,4),(2,4)$；第二种需要 $3$ 次，$(1,4),(1,3),(2,4)$。

如果 $N>4$，必然可以找到一个 $N=4$ 时情况 $1$ 的子段，答案为 $2$。

```cpp
#include <bits/stdc++.h>
#define PII pair<int,int>
using namespace std;
const int MAXN=2e5+5;
int T,N;
int sum=0;
int a[MAXN];
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&N);
		for(int i=1;i<=N;i++) scanf("%1d",&a[i]);
		sum=0;
		for(int i=1;i<=N;i++) sum+=a[i];
		if(sum%2)
		{
			puts("-1");
			continue;
		}
		if(sum>2) printf("%d\n",sum/2);
		else if(sum==2)
		{
			int pos1=0,pos2=0;
			for(int i=1;i<=N;i++) 
			{
				if(a[i]==0) continue;
				if(pos1) pos2=i;
				else pos1=i;
			}
			if(N==2) puts("-1");
			else if(N==3&&pos1==pos2-1) puts("-1");
			else if(pos1==pos2-1&&N==4) 
			{
				if(a[1]||a[4]) puts("2");
				else puts("3");
			}
			else if(pos1==pos2-1) puts("2");
			else puts("1"); 
		}
		else puts("0");
	}
	return 0;
}
```








---

## 作者：qwq___qaq (赞：0)

首先，我们来考虑一下翻转的情况：每次改变 $2$ 枚硬币的状态，所以当 $1$ 的数量是奇数的时候，是绝对不可行的。

这启发我们记录 $1$ 的数量，此处记为 $ans$。

在 $ans$ 为偶数时，注意到题目有个条件 $j-i\ge2$，这说明我们还要继续分类讨论：

在 $ans>2$ 时，我们可以这样分组：令 $t=\dfrac{ans}{2},(i,i+t)$ 为一组，这样每组的 $2$ 个之间肯定是不相邻的。

当 $ans=2$ 时，我们可以先找到 $1$ 的位置，如果这两个 $1$ 不是连续的，那么我们直接交换这两个元素；否则，我们继续分类讨论：

当 $n=2$ 时，显然不能做任意一步操作，此时答案为 `-1`；

当 $n=3$ 时，中间元素被被占用了，此时另一个元素无论怎样交换，都是和这个元素相邻的，所以答案仍然为 `-1`；

当 $n=4$ 时，如果两个中心被霸占了，那么我们把左边的交换到最右边，然后把右边的交换到最左边，这样就可以操作了，答案为 $3$；否则，我们把不在边上的哪一个交换到边上，然后就可以交换了（其实就是前面的情况操作 $1$ 步后的样子），答案为 $2$；

当 $n\ge5$ 时，此时我们可以直接把不在边上的元素交换到边上去，然后就可以交换了（其实跟 $n=4$ 的第 $2$ 种情况相类似），答案为 $2$。

这样就可以 AC 了，感觉讨论好复杂：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,len;
string s;
int main(){
	cin>>T;
	while(T--){
		cin>>len>>s;
		int ans=0;
		for(int i=0;i<len;++i)
			ans+=(s[i]=='1');
		if(ans&1)
			puts("-1");
		else if(ans==2){
			int p=0;
			for(int i=1;i<len;++i)
				if(s[i]=='1'&&s[i-1]=='1'){
					p=i;
					break;
				}
			if(p){
				if(len==2||len==3)
					puts("-1");
				else if(len==4){
					if(p==2)
						puts("3");
					else
						puts("2"); 
				} else
					puts("2");
			} else
				printf("%d\n",ans/2);
		} else
			printf("%d\n",ans/2);
	}
	return 0;
}
```

---


# [ARC051B] 互除法

## 题目描述

高桥君学习了欧几里得算法，他很好奇它能以多快的速度运行。

因此，他写了以下代码。

```cpp
#include <stdio.h>

int counter = 0;
int gcd(int a, int b) {
   if (b == 0) return a;
   counter++;
   return gcd(b, a%b);
}

int main() {
   int a, b;
   scanf("%d %d", &a, &b);
   gcd(a, b);
   printf("%d\n", counter);
}
```

这个代码输入两个整数，然后用欧几里得计算它们的 $\gcd$，然后输出它递归了多少次的代码。 你想让这个程序输出各种各样的值。

具体来说，输入一个 $K$，输出一组可以使得这个程序的输出为 $K$ 的 $A$、$B$。

## 说明/提示

对于 $30\%$ 的数据，$1\le K \le 10$；

对于 $100\%$ 的数据，$1\le K \le 40$。

只输出其中一种可能的解即可。

## 样例 #1

### 输入

```
1```

### 输出

```
1 1```

## 样例 #2

### 输入

```
3```

### 输出

```
4 5```

## 样例 #3

### 输入

```
12```

### 输出

```
314159265 358979323```

# 题解

## 作者：Aw顿顿 (赞：10)

首先，设 $E(x,y)$ 即 $\small\text{Euclid}(x,y)$ 为欧几里得算法求 $\gcd(x,y)$。

对于一个 $n$，我们可以构造斐波那契数列的相邻两项 $f_n,f_{n-1}$ 来使得递归层数为 $n$，然而现有题解都没有说明原因。

那么，为什么呢？

首先找规律，对于 $(f_0,f_1)$，运行次数为 $1$，而我们可以进一步推算，对于 $(f_1,f_2)$ 也就是  $(f_1,f_0+f_1)$，可以计算得到递归层数为 $2$，同理，可以用题目给出的程序计算：

| $1,1$ | $1,2$ | $2,3$ | $3,5$ | $5,8$ |$8,13$  |$13,21$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |

那么就可以推断结论。那么究竟为什么？

由于欧几里得算法的核心思想是：

$$E(x,y)=\begin{cases}x&y=0\\E(y,x\bmod y)& \end{cases}$$

我们又可以发现，斐波那契数列满足 $f_{n}\bmod f_{n-1}=f_{n-2}$，很显然每次递归调用都能使得：

$$E(f_n,f_{n-1})\to E(f_{n-1},f_n\bmod f_{n-1})\to E(f_{n-1},f_{n-2})$$

于是就缩小了范围，且在 $n=1$ 的时候是 $1$ 次，每多求一项就恰好多递归一次，那么就可以知道开头这个结论：

$E(f_n,f_{n-1})$ 的递归次数为 $n$。

那么很容易构造出一组解，递推 $O(n)$ 可以通过，对于 $k\le40$，这里给出 $f_{40}=102334155$。

求个赞，拜拜。



---

## 作者：_ZhouYuHan_ (赞：4)

看大家都没附上完整代码，于是我便来发一下完整代码。

不过思路还是跟dalao们差不多的。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long fib[42]={0,1,1};//斐波那契数列
int k;
int main(){
	cin>>k;
	for(int i=3;i<=41;i++)
	fib[i]=fib[i-1]+fib[i-2];//求斐波那契数列第i项 
	cout<<fib[k]<<" "<<fib[k+1]<<"\n";//输出 
	return 0; 
}
```
最后求个赞，谢谢。

---

## 作者：hero_brine (赞：2)

注意到
$$F[n]=
\begin{cases}
1& \text{n=0 || n=1}\\
F[n-1]+F[n-2]& \text{n>2 or n=2}
\end{cases}$$
于是我们不难由数学归纳法证明：
## 递归层数$D(F[n-1],F[n])=n$
保险起见我们这里使用高精计算,你当然也可以用C++来打表，这里使用Python：
```python
fib = [1, 1]
for i in range(50):
    fib.append(fib[-1] + fib[-2])
t = int(input())
print (fib[t - 1], fib[t])
```
~~PS:这是我第三次提交，我认为自己的说明已经够详细了。~~
## 祝大家都能愉快地 [AC](https://www.luogu.com.cn/record/list?pid=AT1868) !

---

## 作者：Tiphereth_A (赞：2)

考虑欧几里得算法的最坏情况，即a,b为两个相邻的斐波那契数

令$T(a,b)$为对$a,b$求$gcd$递归层数,

$F[n]=\lbrace^{1\enspace ,\enspace n=0\enspace or\enspace n=1}_{F[n-1]+F[n-2]\enspace ,\enspace n\geq 2}$，

则有

$$T(F[n-1],F[n])=n$$

用数学归纳法可以证明~~（太简单了懒得打）~~

另附从[OEIS](http://oeis.org/A000045)上复制的一段斐波那契数列（注意OEIS上规定$F[0]=0$）

> 0, 1, 1, 2, 3, 5, 8, 13, 21, 34,
> 55, 89, 144, 233, 377,
> 610, 987, 1597, 2584, 4181,
> 6765, 10946, 17711, 28657, 46368,
> 75025, 121393, 196418, 317811, 514229,
> 832040, 1346269, 2178309, 3524578, 5702887,
> 9227465, 14930352, 24157817, 39088169, 63245986,
> 102334155

扩展阅读:

- [Euclidean algorithm - Wikipedia](https://en.wikipedia.org/wiki/Euclidean_algorithm#Number_of_steps)

---

## 作者：xgwpp6710 (赞：0)

首先，因为这道题要求输出的数不大于 $10^9$，我们需要找一个答案尽量小的方案。

这里提供一个比较简单且较优的算法，倒推。

那么如何倒推呢，我们首先看，假设 $(a,b)$ 是对于 $k-1$ 的一组解，那么我们就可以找一组解使得它可以变为 $(a,b)$。通过辗转相除法的原理，这一组解很好构造。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100009],b[100009],k;
int main()
{
	cin>>k;
	a[1]=b[1]=1;
	for(int i=2;i<=k;i++)
	{
		a[i]=b[i-1];
		b[i]=a[i-1]+b[i-1];//这里b大于a，使得一开始需要做一部换a和b的操作。容易验证这样的解满足要求。
	}
	cout<<a[k]<<" "<<b[k]<<endl;
	return 0;
}
```

---


# [ABC084D] 2017-like Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc084/tasks/abc084_d

「$ N $ も $ (N+1)÷2 $ も素数」を満たす奇数 $ N $ を **2017に似た数** とします。

$ Q $ 個のクエリが与えられます。

クエリ $ i(1≦i≦Q) $ では奇数 $ l_i $,$ r_i $ が与えられるので、$ l_i≦x≦r_i $ かつ **2017に似た数** となる奇数 $ x $ の個数を求めてください。

## 说明/提示

### 制約

- $ 1≦Q≦10^5 $
- $ 1≦l_i≦r_i≦10^5 $
- $ l_i $,$ r_i $ は奇数
- 入力は全て整数

### Sample Explanation 1

\- $ 3 $ も $ (3+1)÷2=2 $ も素数であるため、$ 3 $ は \*\*2017に似た数\*\* です。 - $ 5 $ も $ (5+1)÷2=3 $ も素数であるため、$ 5 $ は \*\*2017に似た数\*\* です。 - $ 7 $ は素数ですが、 $ (7+1)÷2=4 $ は素数ではないため、$ 7 $ は \*\*2017に似た数\*\* ではありません。 よって、クエリ $ 1 $ の答えは $ 2 $ 個です。

### Sample Explanation 2

$ 2017 $ も \*\*2017に似た数\*\* であることに注意してください。

## 样例 #1

### 输入

```
1
3 7```

### 输出

```
2```

## 样例 #2

### 输入

```
4
13 13
7 11
7 11
2017 2017```

### 输出

```
1
0
0
1```

## 样例 #3

### 输入

```
6
1 53
13 91
37 55
19 51
73 91
13 49```

### 输出

```
4
4
1
1
1
2```

# 题解

## 作者：FP·荷兰猪 (赞：4)

这道题q和r[i]都有10000，如果用O(n^2)的算法肯定超时，所以肯定要化简。
外循环的10000次是一次也少不了的。由于每个询问都是问区间总数，可以开一个前缀和，表示从1到i一共有多少个满足要求的数，对于每个询问直接O(1)找答案
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[100009],f[100009];
main()
{
    p[1]=1;
 
    for (int i=2; i<=100000; i++)
    {
        for (int j=2*i; j<=100000; j+=i)
            p[j]=1;
    }
    p[2]=0;
    for (int i=1; i<=100000; i++)//构造前缀和
    {
        if(p[i]==0 && p[(i+1)/2]==0 && i!=2)//如果该数满足要求，前缀和加1；否则不变
            {
                f[i]=f[i-1]+1;
            }
        else f[i]=f[i-1];
    }
    int q;
    cin>>q;
    while(q--)
    {
        int l,r;
        cin>>l>>r;
        cout<<f[r]-f[l-1]<<endl//对于每组询问，直接输出f[r]-f[l-1]
    }
}
```

---

## 作者：wangyibo201026 (赞：2)

## 一道水题

本人用从 $5$ 分钟切了。

说实话还是挺简单的，有两种思路。

## 暴力

对于每次操作，暴力枚举，$l_i$ 到 $r_i$ 里的所有数，对于每一次枚举，需要花费 $O(\sqrt{x})$ 的时间（其中 $x$ 为枚举的数）。但是时间复杂度是 $O(NQ)$，其中 $N$ 为 $10^5$，显然会超时，此时，我们需要一个神奇的东西。

## 前缀和

没错，你通过~~看了标签的~~你的经验发现，对于多次询问，我们可以利用预处理，把 $1$ 到 $10^5$ 之内的数直接算出来，再维护一个前缀和数组，$sum_i$ 表示从 $1$ 到 $i$ 里符合的数有多少个。那么对于最后的答案，就是 $sum_{r_i} - sum_{l_i - 1}$。此时，时间复杂度已经与 $Q$ 无关了，成功的将时间复杂度优化到了 $O(N)$。

## 代码

判质数不会的可以观摩其他大佬的代码，其余的就好说了：

```
#include<bits/stdc++.h>

using namespace std;

int q, sum[100005];

bool zhi(int x){
  if(x < 2){
    return false;
  }
  for(int i = 2; i <= sqrt(x); i++){    //利用平方根判质数
    if(x % i == 0){
      return false;
    }
  }
  return true;
}

void shai_2017(int x){
  for(int i = 1; i <= x; i++){     //x为枚举的范围
    if(zhi(i) && zhi((i + 1) / 2)){
      sum[i] = sum[i - 1] + 1;    //如果符合条件
    }
    else{
      sum[i] = sum[i - 1];
    }
  }
}

void Solve(){
  shai_2017(100005);    //预处理函数
  cin >> q;
  for(int i = 1; i <= q; i++){
    int l, r;
    cin >> l >> r;
    cout << sum[r] - sum[l - 1] << endl;    //O(1) 处理
  }
}

int main(){
  Solve();
  return 0;
}
```

---

## 作者：打表大蒟蒻 (赞：2)

这道题其实可以用我们Oler喜闻乐见的打表大法，作为一名优秀的~~蒟蒻~~，自然要用打表大法啦

------------
打表的思路应该不用讲了，直接根据题意模拟，连埃氏筛都不用，一个判断素数的函数就解决问题，generator如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
bool pd(int x)  //判断素数
{
	if(x==0||x==1) return false;  //特判一下
	for(int i=2;i*i<=x;i++)
		if(x%i==0) return false;
	return true;
}
int main ()
{
	int s=0;
	for(int i=1;i<=100000;i+=2)  //循环取奇数
		if(pd(i)&&pd((i+1)/2)) cout<<i<<",",s++;  //计个数
	cout<<s;  //把计数器输出，方便后面存数组
	return 0;
} 
```
后面别忘了加个freopen保存结果，所以，我们的打表代码就出炉啦：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[672]={3,5,13,37,61,73,157,193,277,313,397,421,457,541,613,661,673,733,757,877,997,1093,1153,1201,1213,1237,1321,1381,1453,1621,1657,1753,1873,1933,1993,2017,2137,2341,2473,2557,2593,2797,2857,2917,3061,3217,3253,3313,3517,3733,4021,4057,4177,4261,4273,4357,4441,4561,4621,4933,5077,5101,5113,5233,5413,5437,5581,5701,6037,6073,6121,6133,6217,6337,6361,6373,6637,6661,6781,6997,7057,7213,7393,7417,7477,7537,7753,7933,8053,8101,8221,8317,8353,8461,8521,8677,8713,8893,9013,9133,9181,9241,9277,9601,9661,9721,9817,9901,9973,10333,10357,10453,10837,10861,10957,11113,11161,11317,11497,11677,11701,12073,12157,12241,12301,12421,12433,12457,12541,12553,12601,12721,12757,12841,12853,13093,13381,13417,13681,13921,13933,14437,14593,14737,14821,15013,15073,15121,15241,15277,15361,15373,15733,15901,16033,16333,16381,16417,16573,16633,16657,16921,17041,17053,17077,17257,17293,17377,17881,18013,18097,18133,18181,18217,18253,18301,18313,18397,18481,18553,18637,18793,19237,19441,19477,19717,19801,19813,19861,20353,20533,20641,20857,21001,21061,21193,21277,21313,21577,21661,21673,21817,22093,22501,22573,22621,22993,23053,23173,23557,23677,23773,23917,24097,24421,24481,24781,24841,25033,25153,25237,25561,25657,25933,26017,26293,26317,26437,26497,26821,26833,26881,26953,27073,27253,27337,27361,27457,27997,28057,28297,28393,28813,28837,28921,29101,29473,29641,30181,30241,30517,30553,30577,30637,30661,30697,30781,30853,31081,31237,31321,31333,31357,31477,31573,31873,31981,32173,32377,32497,32533,32833,33037,33301,33457,33493,33757,33961,34057,34213,34273,34381,34513,34897,34981,35317,35521,35677,35977,36097,36241,36433,36457,36793,36877,36901,36913,37273,37321,37357,37573,37717,37957,38281,38461,38833,38953,38977,39217,39373,39397,39733,40093,40177,40213,40693,40813,41017,41221,41281,41413,41617,41893,42061,42337,42373,42793,42961,43117,43177,43201,43321,43573,43597,43633,43717,44053,44101,44221,44257,44293,44893,45061,45337,45433,45481,45553,45613,45841,46021,46141,46261,46861,46993,47017,47161,47353,47521,47533,47653,47713,47737,47797,47857,48121,48193,48337,48673,48757,48781,49033,49261,49393,49417,49597,49681,49957,50221,50341,50377,50821,50893,51157,51217,51241,51481,51517,51637,52057,52081,52237,52321,52453,52501,52813,52861,52957,53077,53113,53281,53401,53917,54121,54133,54181,54217,54421,54517,54541,54673,54721,54973,55057,55381,55501,55633,55837,55921,55933,56053,56101,56113,56197,56401,56437,56701,56773,56821,56857,56893,57073,57097,57193,57241,57373,57457,57853,58153,58417,58441,58537,58573,58693,59053,59197,59221,59281,59341,59833,60217,60337,60373,60637,60733,60937,61057,61153,61261,61297,61561,61657,61681,61717,61861,62137,62473,62497,62533,62653,62773,63313,63397,63541,63697,63781,63913,64153,64237,64381,64513,64717,65173,65293,65413,65437,65497,65557,65677,65881,66301,66361,66601,66697,66853,66973,67057,67153,67273,67477,67537,67741,67777,67933,67993,68113,68281,68521,68737,69001,69073,69457,69493,69697,69877,70117,70177,70297,70501,70621,70921,70981,71233,71341,71353,71593,71821,72073,72481,72613,72901,72937,73141,73417,73477,73561,73693,74077,74317,74377,74713,75013,75133,75181,75721,75793,75913,76333,76561,76597,76753,77137,77641,78157,78193,78277,78877,78901,79333,79357,79537,79657,79693,79801,79873,80077,80173,80221,80473,80701,80713,80917,81013,81181,81517,81637,81853,82021,82153,82261,82561,82981,83077,83221,83233,83437,83617,83701,83773,84121,84313,84673,84697,84793,84913,85297,85333,85453,85717,85933,86353,86413,87181,87253,87337,87421,87433,87517,87553,87973,88117,88177,88237,88261,88513,88741,88897,88993,89293,89833,89917,90121,91081,91381,91393,91513,91957,92041,92557,92761,92821,92893,92941,93097,93133,93493,93637,93913,94033,94117,94273,94321,94441,94573,94777,94837,94993,95257,95317,95401,95581,95617,95713,95737,96097,96157,96181,96493,96517,96973,97081,97177,97501,97561,97777,97813,98017,98737,98953,99277,99577,99661,99877};  //打表的结果
int main ()
{
	int q, l, r;
	cin>>q;
	for(int i=0;i<q;i++){
		cin>>l>>r;  //读进去
		int s=0;  
		for(int i=0;i<672;i++)
			if(a[i]>=l&&a[i]<=r) s++;  //计个数
		cout<<s<<endl; //输一下
	}
	return 0;
} 
```


---

## 作者：Kacho (赞：1)

# 题意以及数据
显然这道题是一个模拟题。

因为从数据上来看 $Q \le 100000$ 以及 $a[i] \le 100000$。


所以说，如果每做一次，对于每一个数进行素数判断的话，显然 $O(n ^ 2)$ 是会被卡掉的，所以就要先用[埃氏筛](https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fromtitle=%E5%9F%83%E6%B0%8F%E7%AD%9B&fromid=5677377&fr=aladdin)对于素数进行筛选，这样子会便于我们后续的判断。

放上埃氏筛部分代码：
```cpp
a[1] = 1;
for(int i = 2; i <= 100000; i++){
    for(int j = 2 * i; j <= 100000; j += i){
        a[j] = 1;
    }
}
```
# 前缀和部分
为什么此处的 $a[1]$ 要设置为 1 呢？这就和此题所要用到的前缀和有关了，这一题我们是枚举从 $start$ 到 $end$ 这一区间内的所有素数，并且用一个 $ans[]$ 数组进行储存。那么此时，我们通过观察埃氏筛的结果，显然 $a[2] =  0$，那么对于我们的前缀和来说比较麻烦，因为 2 是素数，我们需要计数，但是 2 不是奇数，所以 $i \ne 2$ 是必须要判断的一个条件，那么此时对于 $a[2]$ 的操作必须要和不符合条件的数进行同样的操作，也就是下面贴的这部分代码：
```cpp
for(int i = 2; i <= 100000; i++){
    if(a[i] == 0 && a[(i + 1) / 2] == 0 && i != 2){
       ans[i] = ans[i - 1] + 1;
    }
    else ans[i] = ans[i - 1]; 
}
```
这就是前缀和的代码了，所以说核心的代码已经推出来了，那么这道题可以很容易地AC了。

# 总结
这道题从题意到解答都是很简单的思路，主要需要掌握的知识点在于埃氏筛以及前缀和只要掌握了这些知识点，就很容易切掉这道题目了，下面贴上AC的代码以及部分注释：
```cpp
#include<bits/stdc++.h>

const int N = 100009;

using namespace std;

int T;
int a[N],b[N];

int main (){
    
    a[1] = 1;

    for(int i = 2; i <= 100000; i++){
        for(int j = 2 * i; j <= 100000; j += i){
            a[j] = 1;
        }
    }

    for(int i = 2; i <= 100000; i++){
        if(a[i] == 0 && a[(i + 1) / 2] == 0 && i != 2){
            b[i] = b[i - 1] + 1;
        }
        else b[i] = b[i - 1]; 
    }

    scanf("%d ", &T);
    while(T--){
        int l, r;
        scanf("%d %d ", &l, &r);
        printf("%d\n", b[r] - b[l - 1]);
        //此处的"l - 1"是因为 l 是闭区间，要包括进来
        //不然可能会减少一个符合条件的数
    }

    system("pause");

    return 0;

}
```

---

## 作者：StarPatrick (赞：0)

这题肯定不能模拟，因为询问次数较多，会超时，因此我们想到用前缀和来进行区间查询。

核心代码1——判断质数：
```cpp
bool check(int x)
{
    if (x==1)
    {
        return false;
    }
	for (int p=2;p<=sqrt(x);p++)
	{
		if (x%p==0)
		{
			return false;
		}
	}
	return true;
}
```
要注意 $1$ 不是质数。

核心代码2——前缀和：
```cpp
for (int p=1;p<=100000;p++)
{
    int u = 0;
	if (p%2&&check(p)&&check((p+1)/2))
	{
		u = 1;
	}
	sum[p] = sum[p-1]+u;
}
cin>>q;
for (int p=1;p<=q;p++)
{
	int l, r;
	cin>>l>>r;
	cout<<sum[r]-sum[l-1]<<"\n";
}
```


---

## 作者：Otomachi_Una_ (赞：0)

这道题很水。。。

考虑到要求的是关于区间 $[l,r]$ 中 2017に似た数 的个数，使用 $O(n^2)$ 的算法将妥妥超时。

考虑前缀和优化，只需要 $O(n)$ 的时间预处理即可，输出只用 $O(1)$ 的时间计算即可。

## Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define ll long long
const int MAXN=1e5+5;
int d[MAXN];
int q,l,r;
bool prime(int x){
	if(x<2)
		return false;
	for(int i=2;i*i<=x;i++)
		if(x%i==0)
			return false;
	return true;
}
int main(){
	for(int i=1;i<MAXN;i++)
		d[i]=d[i-1]+(prime(i)&&prime((i+1)/2));
	cin>>q;
	while(q--){
		cin>>l>>r;
		cout<<d[r]-d[l-1]<<endl;
	}
	return 0;
}
```
ps. 关于优化，读者可以将 $d$ 数组打表，因为这个比较长，这里就不多阐述。

---

## 作者：RioBlu (赞：0)

**埃式线筛**还是太慢了，**欧拉线筛**虽说没有打表快，但也是将$O(nlogn)$压缩成了$O(n)$

但是欧拉线筛有一个缺点：你需要更多的辅助空间，存储一个新的质数表，这里不多说，**要想学欧拉线筛自行百度**
___
下面是代码
```
#include<bits/stdc++.h>
using namespace std;
long long n[50050],f[100050],zs,a,lefts,rights;
//n[]为辅助空间，里面处理完全是质数；f[]用来前缀和，zs代表质数个数（欧拉线筛需要）
bool b[100050];
//标准的质数表
int main()
{
	b[0]=1,b[1]=1;//初始值
	for(int s=2;s<=100005;s++)//欧拉线筛
	{
		if(!b[s])//一个质数
		{
			n[zs++]=s;
		}
		for(int v=0;v<zs;v++)//处理
		{
			if(s*n[v]>100005)break;//超过了所求的质数范围
			b[n[v]*s]=true;//筛质数
			if(s%n[v]==0)break;//压成到O(n)的关键
		}
	}
	cin>>a;
	for(int s=2;s<=100005;s++)//前缀和
	{
		if(s%2==1&&b[s]==0&&b[(s+1)/2]==0)
		f[s]=1;
		f[s]+=f[s-1];
	}
	while(a--)//输入
	{
		cin>>lefts>>rights;
		cout<<f[rights]-f[lefts-1]<<endl;//前缀和的大法
	}
    return 0;
}
```

---

## 作者：锦瑟，华年 (赞：0)

这题大家都很容易想到**枚举+判质数**，但你也看到了， $q$ 与 $l_i$ , $r_i$ 都小于等于 100000 ，很显然，这样肯定超时。

好了，现在我们对判质数进行优化：**筛质数**。什么是筛质数呢？原理很简单：很显然的，先开一个数组 $a$ ，从2开始遍历，每当遇到 $a_i==0$ ，这样这个数就是质数，从这个质数开始遍历，将这个质数的整数倍的数的对应的数组变为1（这样就明白上文判质数的道理了，因为遍历到那个数那个数对应的数组还为0，就表示他没有因数，也就是质数了）。但大家要注意，不能从1开始遍历（为什么自己想想），从2开始遍历并将 $a_1$ 设为1。演示一下大家看看：

| 遍历数字\编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 初始化 | 1 | 0 | 0 | 0 | 0 | 0 |
| 2 | 1 | 0 | 0 | 1 | 0 | 1 |
代码：

	m=(int) sqrt (n);
	for (i=2;i<=m;i++){
    	if (a[i]==0){
        	for (j=i*i;j<=n;j+=i) a[j]=1;
        }
    }


我们还可以对枚举做出优化：**前缀和**。前缀和是什么呢？即计算 $l$ 至$r$ 这一段区间的和。先计算从头到每一个数的之间的数的总和，最后输出时，把 $a[r]-=a[l-1]$ 即可（自己可以自己想一想）。代码：

	for(i=1;i<=n;i++){
 	   f[i]+=f[i-1];
	}
    for(i=1;i<=m;i++){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",f[r]-f[l-1]);
    }
    
好了整合一下，代码来袭：

	#include<stdio.h>
	using namespace std;
	int a[100005],b[100005];
	int main(){
		int n,i,j;
		scanf("%d",&n);
		a[1]=1;//筛质数
		for(i=2;i<=50000;i++){
			if(a[i]==0){
				for(j=i+i;j<=100000;j+=i)a[j]=1;
			}
		}
		for(i=1;i<=100000;i++){//前缀和
			b[i]=b[i-1];
			if(a[i]==0&&a[(i+1)/2]==0)b[i]++;//判断
		}
		for(i=1;i<=n;i++){//前缀和输出
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%d\n",b[r]-b[l-1]);
		}
		return 0;
	}
    
OK，拜拜~~

---


# [ABC119C] Synthetic Kadomatsu

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc119/tasks/abc119_c

あなたは $ N $ 本の竹を持っています。これらの長さはそれぞれ $ l_1,\ l_2,\ ...,\ l_N $ です (単位: センチメートル)。

あなたの目的は、これらの竹のうち何本か (全部でもよい) を使い、長さが $ A,\ B,\ C $ であるような $ 3 $ 本の竹を得ることです。そのために、以下の三種類の魔法を任意の順に何度でも使うことができます。

- 延長魔法: $ 1 $ *MP* (マジックポイント) を消費し、$ 1 $ 本の竹を選んでその長さを $ 1 $ 増やす。
- 短縮魔法: $ 1 $ MP を消費し、$ 1 $ 本の長さ $ 2 $ 以上の竹を選んでその長さを $ 1 $ 減らす。
- 合成魔法: $ 10 $ MP を消費し、$ 2 $ 本の竹を選んで接続し $ 1 $ 本の竹とする。この新たな竹の長さは接続した $ 2 $ 本の竹の長さの合計に等しい。(以後、この竹に対してさらに魔法を使用することもできる。)

目的を達成するには、最小でいくつの MP が必要でしょうか？

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 8 $
- $ 1\ \leq\ C\ <\ B\ <\ A\ \leq\ 1000 $
- $ 1\ \leq\ l_i\ \leq\ 1000 $
- 入力される値はすべて整数である。

### Sample Explanation 1

長さ $ 98,\ 40,\ 30,\ 21,\ 80 $ の $ 5 $ 本の竹から長さ $ 100,\ 90,\ 80 $ の $ 3 $ 本の竹を得ようとしています。長さ $ 80 $ の竹ははじめから持っており、長さ $ 100,\ 90 $ の竹は次のように魔法を使うと合計 $ 23 $ MP を消費することで得られ、これが最適です。 1. 長さ $ 98 $ の竹に延長魔法を $ 2 $ 回使い、長さ $ 100 $ の竹を得る。(消費 MP: $ 2 $) 2. 長さ $ 40,\ 30 $ の竹に合成魔法を使い、長さ $ 70 $ の竹を得る。(消費 MP: $ 10 $) 3. 長さ $ 21 $ の竹に短縮魔法を $ 1 $ 回使い、長さ $ 20 $ の竹を得る。(消費 MP: $ 1 $) 4. 手順 2. で得た長さ $ 70 $ の竹と手順 3. で得た長さ $ 20 $ の竹に合成魔法を使い、長さ $ 90 $ の竹を得る。(消費 MP: $ 10 $)

### Sample Explanation 2

欲しい長さの竹をすでにすべて持っている場合、必要な MP は $ 0 $ です。このように、必ずしもすべての竹を使う必要はありません。

## 样例 #1

### 输入

```
5 100 90 80
98
40
30
21
80```

### 输出

```
23```

## 样例 #2

### 输入

```
8 100 90 80
100
100
90
90
90
80
80
80```

### 输出

```
0```

## 样例 #3

### 输入

```
8 1000 800 100
300
333
400
444
500
555
600
666```

### 输出

```
243```

# 题解

## 作者：Otomachi_Una_ (赞：8)

先合成完所有竹子再进行加减，可以证明这样子对正确性没有影响。

再因为这题的 $n$ 较小，考虑 dfs 。

对于每一个子问题，我们需要他的层数 $p$ ，三个已和成竹子的长度 $A,B ,C$ ，还有已经用的魔法点 $val$ 。

特别的，对于每一次更新答案，首先要判断它是不是有竹子组成的，最后算答案时应该把答案减去 $30$ (因为一开始的时候不需要魔法点)。

## _Code_
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int l[10];
int n,a,b,c,ans=1e9;
void dfs(int p,int A,int B,int C,int val){
	if(A!=0&&B!=0&&C!=0)
		ans=min(ans,abs(A-a)+abs(B-b)+abs(C-c)+val-30);
	if(p>n) 
    		return;
	dfs(p+1,A+l[p],B,C,val+10);
	dfs(p+1,A,B+l[p],C,val+10);
	dfs(p+1,A,B,C+l[p],val+10);
	dfs(p+1,A,B,C,val);
	return;
}
int main(){
	cin>>n>>a>>b>>c;
	for(int i=1;i<=n;i++) 
		cin>>l[i];
	dfs(0,0,0,0,0);
	cout<<ans;
	return 0;
}
```


---

## 作者：liangbowen (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/AT4302)

小学生来写题解啦！

先看数据范围，都很小，并且时间有两秒，因此选择**暴力搜索**，即**深度优先搜索**。

先将竹子分配给目标竹子使用。

想象你是一根竹子，你可以去选择为三根目标竹子做贡献，或不使用自己。

分配完每根竹子的工作后，就计算魔法值。

虽然有多种方法制作目标竹子，但**魔法值是一样的**。

所以，我们可以先将所有竹子合成一根，再通过延长或缩短达到目标长度。

## 送上AC代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int n, A, B, C, minn = 2e9;
int h[10];
void dfs(int x, int a, int b, int c, int cnt)
//当前递归到第 x 根竹子。 
//现在三根目标竹子分别有 a, b, c厘米的竹子。
//已经使用了 cnt 次合成魔法。 
{
	if (x > n)
	{
		if (a != 0 && b != 0 && c != 0)  //特判！至少得有竹子才能制作！ 
		{
			int mp = cnt * 10;
			mp += abs(a - A);
			mp += abs(b - B);
			mp += abs(c - C);
			minn = min(minn, mp);
		}
		return;
	}
	//A
	dfs(x + 1, a + h[x], b, c, cnt + (a != 0));
	//B
	dfs(x + 1, a, b + h[x], c, cnt + (b != 0));
	//C
	dfs(x + 1, a, b, c + h[x], cnt + (c != 0));
	//不要
	dfs(x+1, a, b, c, cnt);
}
int main()
{
	scanf("%d%d%d%d", &n, &A, &B, &C);
	for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
	dfs(1, 0, 0, 0, 0);
	printf("%d", minn);
	return 0;
}
```
还有一个值得提出的点。

我代码的效率远远超出了我的想象。

我没做优化，但最高的点也仅有八毫秒。

[不信戳这](https://www.luogu.com.cn/record/67582286)

---


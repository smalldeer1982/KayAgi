# [AGC020A] Move and Win

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc020/tasks/agc020_a

$ N $ 個のマスに区切られた細長い紙切れの上でゲームを行います。マスには $ 1 $ から $ N $ までの番号が順に付けられています。

アリスの駒はマス $ A $ に、ボリスの駒は別のマス $ B $ に置かれています。

二人にはターンが交互に訪れます。アリスが先手です。 ターンが回ってきたプレイヤーは、自分の駒を現在のマス $ X $ から左隣のマス $ X-1 $ か右隣のマス $ X+1 $ のどちらかに動かさなければなりません。 ただし、駒を紙切れの外に出したり、相手の駒と同じマスに動かしてはいけません。 また、駒の移動は一ターンに一度だけ行わなければなりません。

駒を動かせなくなった人が負けで、相手の勝ちとなります。

二人とも、勝ちたいと思っています。二人とも最適にプレイするとき、どちらが勝つでしょうか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ A $
- 入力値はすべて整数である。

### Sample Explanation 1

アリスは駒をマス $ 3 $ に動かせます。 すると、ボリスは駒をマス $ 3 $ に動かすことができなくなり、マス $ 5 $ に動かすほかなくなります。 そして、アリスが駒をマス $ 4 $ に動かすと、ボリスは駒を動かせなくなり負けます。

### Sample Explanation 2

アリスは最初のターンで駒を動かせず負けます。

## 样例 #1

### 输入

```
5 2 4```

### 输出

```
Alice```

## 样例 #2

### 输入

```
2 1 2```

### 输出

```
Borys```

## 样例 #3

### 输入

```
58 23 42```

### 输出

```
Borys```

# 题解

## 作者：VincentXu (赞：6)

由于这题数据范围很小，所以~~我们可以为所欲为~~方法很简单

### 分析一下：

自己在草稿纸上画了一下，发现在两人相遇前，前进与后退都不会影响最终结果。而且胜利的条件就是让对方后退到无路可走，所以在相遇前两人都要尽可能地前进，在相遇后其中一方就会被步步紧逼，一直后退。所以若模拟全过程关键就是：**在双方相遇（两枚棋子紧挨）后轮到谁走棋，谁就输。**

**模拟法：**

```
#include<iostream>
using namespace std;
int main()
{
	int n,x,y,tot=0;cin>>n>>x>>y;
	while(1)
	{
		if(x+1==y)
		{
			if(tot%2)cout<<"Alice";
			else cout<<"Borys";
			return 0;
		}//这里需要注意的是有可能一开始两枚棋子就紧挨着，所以在走棋前要先判断
		if(!tot%2)x++;
		else y--;
		tot++;//记录总步数
	}//每次循环完成一步走棋
	return 0;
} 
```

然而还有一种方法（虽然有dalao说过了），既然这里的判断关键是两人相遇前走的总步数，那直接对这个总步数进行奇偶判断就可以了。

**数学法：**

```
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
	int n,x,y;cin>>n>>x>>y;
	string ans=(y-x)%2?"Borys":"Alice";
	cout<<ans;
	return 0;
} 
```
就这样。其实还挺简单的。

希望这篇题解对大家有所帮助。

---

## 作者：Rulu (赞：3)

经过对此题分析，我们可以得出：
#### 结果与 b-a 的奇偶性有关。
代码
------------
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a,b;
    string s;
    cin>>n>>a>>b;
    s=(b-a)%2?"Borys":"Alice";
    cout<<s<<endl;
    return 0;
}
```
上面用到了三目运算符，相当于以下代码：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,a,b;
    cin>>n>>a>>b;
	if((b-a)%2==0)
	{
		cout<<"Alice"<<endl;
	}
	else
	{
		cout<<"Borys"<<endl;
	}
    return 0;
}
```


#### 完结撒花~（疯狂暗示 QwQ

---

## 作者：MY（一名蒟蒻） (赞：2)

[原题传送门](https://www.luogu.com.cn/problem/AT3855)

在这里要和审核的管理员大大说抱歉。因为作者的孤陋寡闻和疏忽，排版出现问题。这是已经更改好的最终版，希望能够通过审核。管理员们辛苦了！

首先观察题目，棋盘是一条线。

我们先不管 $\text{n}$ ，考虑如果两个棋子分别在两端的情况。

由于走回头路的情况等于没走，题目转换为两者相遇（这里的相遇不是重叠）时，谁走下一步。

显然这时行棋的一方输了。

考虑 $\text{n=2}$ 时，先手方败；$\text{n=3}$ 时，后手方败。

**注意这里的 $\text{n}$ 不是题目中的 $\text{n}$ ，而是上述情况的 $\text{n}$ 。**

由于不能走回头路，问题最终转化为上述两种情况。

因为**实际上，走回头路，对手往你这逼近两格，和你们相向一人走一格是一样的。**

那么问题转换求为这个棋盘的格子数的奇偶性，奇数则先手方胜。

所以这个 $\text{n}$ 是没用的，跟你在两头，走回头路的情况相同。

那么有没有可能这两人都不逼近对方呢？答案是否定的，因为一定有人有必胜策略，所以一定有人会赢，**而且赢的人只要一直逼近对手即可**。

然后这题就非常好做了，只要当两个棋子之间的距离为奇数时，输出先手的`Alice`，否则输出后手的`Borys`即可。

---

## 作者：Energy_Making (赞：1)

## 1.思路

显然，谁先碰到对方棋子，那么它就必胜。而谁先碰到对方棋子，则与棋子之间距离的奇偶性有关。而我们还知道，每回合棋子距离的奇偶性是不变的。那么我们只需要判断 $b-a$ 的奇偶性就行了。手推样例之后，我们发现：

* $(b-a) \mod 2=0$ 时Alice赢
* $(b-a) \mod 2=1$ 时Borys赢

代码不难写吧。



---

## 作者：Gokix (赞：1)

先前两位奆佬已经说得很好了，蒟蒻来补充一下为什么与 $b-a$ 的奇偶性有关。

题目链接 $\twoheadrightarrow$ [AT3855](https://www.luogu.com.cn/problem/AT3855)

首先，由于每人每步必须向左或向右走一格，所以 $b-a$ 的奇偶性是不变的。因为每一回合后，两棋子距离会变成 $b-a \space , b-a-2 \space , b-a+2$ 三者之一。众所周知， $a \pm b \space (b$为偶数) ,$a$的奇偶性不变。

我们先**假设Alice和Borys每步都朝对方棋子走一步**，那么最后一定会到两棋子相邻或只隔了一格。由此可见，若 $b-a > 2$ ，我们可以把它化简到以上两种局面，即通过**奇偶性化简**。

分类讨论上两种情况：

1. 若两棋子相邻，Alice只能后退，Borys前进。每回合都这么走，直至Alice不能后退（到 $1$ 了），Alice输。

2. 若两棋子只差一格，Alice前进一步，Borys只能后退。每回合都这么走，直至Borys不能后退（到 $n$ 了），Borys输。

可见若相邻，Borys赢；若只差一格，Alice赢。即 $b-a$ 为偶数，Borys赢；反之，Alice赢。

但我们之前有假设，如果按先前假设失败的一方后退会怎样呢？

通过一开始的推论， $b-a$ 的奇偶性不变，且通过假设，我们得知胜负与 $b-a$ 的奇偶性有关。那么就与二人的策略无关。该赢的那方只要前进就一定会赢。

完毕。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
long long a,b,n;
int main()
{
	cin>>n>>a>>b;
	if((b-a)%2==0)
	{
		cout<<"Alice"<<endl;
	}
	else
	{
		cout<<"Borys"<<endl;
	}
	return(0);
}
```

%%%%%

---

## 作者：cq_loves_Capoo (赞：0)

我不懂其他人是啥意思，反正这个菜鸡就是纯分析样例的（逃），感觉也不难，用我乱七八糟的两行主程序就珂以了。   
  
其实看了看别的题解，也跟我分析的 $b-a$ 的奇偶性差不多，就给一个比较短的代码上来吧。   
   
     
```
#include<bits/stdc++.h>//万能头
using namespace std;
int n,a,b;
signed main()
{
	cin>>n>>a>>b;//输入
	cout<<(((b-a)%2)?"Borys\n":"Alice\n");//乱七八糟的三目运算符，感觉用这个好方便，不懂可以百度一下这个三目运算符。
	return 0;//加起来好看多了，而且也是个好习惯qwq
}
```


---

## 作者：mwhxiaopy (赞：0)

这道题很简单。

由于某些原因，我的题解分两部分，下文会叙述原因。

题目解析：这道题是一道模拟题。
我们可以通过模拟两个人的最优策略来完成这道题目。

最优策略是：向对方走，压缩对方的空间，直到对方无法前进并后退。

下面便是题解。

第一部分：模拟题解（我最初的题解）

通过循环模拟每个人每一步走的步数，直到相遇，计算谁后退，后退者输。

当相遇时，由于先走的人需要后退，所以先走的那个人会输。

所以只要模拟到相遇即可。

源代码：
```
#include<iostream>
using namespace std;
int main(){
int a,b,c,x,y,z;
cin>>c>>a>>b;
z=a-b;
if(z<=0)z*=-1;
for(int i=1;i<=1;){
z-=1;
y+=1;
//拒绝抄袭从我做起
if(z==0&&y%2==1){cout<<"Borys";break;}
if(z==0&&y%2==0){cout<<"Alice";break;}}
}
```

结果我用数据试过以后：

~~此题原来十分简单~~

发现这题能用奇偶性解决……

奇偶性解决：因为相遇时先走的人会输，所以用中间距离的奇偶性来判断谁必须后退。
因为不管前进还是后退，距离奇偶性都会变化。


所以：第二部分（更加简单的方法）

使用$b-a$奇偶性解决。
如果$b-a$是奇数$Borys$赢；
反之，$Alice$赢。
源代码：

```
#include<iostream>
using namespace std;
int main(){
int a,b,c,x,y,z;
cin>>c>>a>>b;
z=a-b;
if(z%2==0)cout<<"Alice";
else cout<<"Borys";
return 0;}
```
本人的题解就到这里了，谢谢阅读，希望大佬多多提出意见！

---

## 作者：Raw_Aya9285 (赞：0)

这题纯属大水题，我分析一下吧~

---

首先我针对#1画了图，如下：

0A0B0（0是空格）

首先A往右移动一下：00AB0

然后B被迫往后：00A0B

随后A再跟进：000AB

B就无路可走了。

所以输出Alice.

---

然后是#2：

AB

还有什么好说的吗？

~~Alice：这什么垃圾棋啊~~

---

针对两种情况，我又列了两种样例，送给大家：

- 00A00000B00

走法：000A000B000 -> 0000A00B0000 -> 00000AB00000（到这里就可以推出Alice赢了）

- 00A0000B00

走法：000A00B000 -> 0000AB0000（同上推出Borys赢）

---

总结一下，我们推出：

**当B-A是偶数时，Alice赢。**

**当B-A是奇数时，Borys赢。**

**不可能平局。**

---
所以代码如下：

```cpp
#include<iostream>
using huaji std;  //请勿抄袭
int main(){
    int a,b,n;
    cin>>n>>a>>b;
    if((b-a)%2==1)  cout<<"Borys"<<endl;
    else cout<<"Alice"<<endl;
    return 0;
}

---

## 作者：agicy (赞：0)

# 思路

因为是水题，所以观察样例即可得出结论：

**不存在平手，结果与$(b-a-1)$的奇偶性有关。**

# 代码

代码如下。

```cpp
#include<stdio.h>//头文件

int a,b;

int main(void){
	scanf("%*d%d%d",&a,&b);//不读入n
	if((b-a-1)&1)//如果(b-a-1)为奇数
		puts("Alice");//Alice赢
	else//如果(b-a-1)为偶数
		puts("Borys");//Borys赢
	return 0;//结束
}
```

---


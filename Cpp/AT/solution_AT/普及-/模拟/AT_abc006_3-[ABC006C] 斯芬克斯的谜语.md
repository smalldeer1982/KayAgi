# [ABC006C] 斯芬克斯的谜语

## 题目背景

新学期到来了，你正带着激动心情走在上学路上，突然斯芬克斯（狮身人面像）出现在了你的面前。这个斯芬克斯因为能出谜题而闻名于世，如果你不能回答他的谜题，你就会留级！

## 题目描述

谜题如下：

在这条街道上住着 $N$ 个人，其中有大人、老人、婴儿三种人。住在这条街的人们，拥有的腿的总数为 $M$ 条。我们假设大人有 $2$ 条腿，老人有 $3$ 条腿（有一条腿是拐杖），婴儿有 $4$ 条腿（他们还不能直立行走）。请回答一个可能的、满足上述条件的住在这条街道上的人数数量组合的答案。

## 说明/提示

这个问题有三组测试数据组，每个测试数组有不同的数据范围分。

若能答对 $N(1 \le N \le 100),M(1 \le M \le 500)$ 范围的数据，可以得到 $10$ 分。

若能答对 $N(1 \le N \le 1,500)$ 、$M(1 \le M \le 7,500)$ 范围的数据，可以得到另外 $20$ 分。

若能答对所有范围内的数据，可以得到 $100$ 分。

### 样例解释
#### 样例1
输入的数据表示一共有 $3$ 个人，$9$ 条腿。输出表示，一种可能的情况是 $1$ 个大人，$1$ 个老人，$1$ 个婴儿。$1$ 个大人共 $2$ 条腿，$1$ 个老人共 $3$ 条腿，$1$ 个婴儿共 $4$ 条腿，加起来一共 $3$ 个人，$9$ 条腿。

#### 样例2
$1$ 个大人共 $2$ 条腿，$3$ 个老人共 $9$ 条腿，$3$ 个婴儿共 $12$ 条腿，加起来一共 $7$ 个人，$23$ 条腿。

#### 样例3
符合谜题要求的答案不存在，因此输出 `-1 -1 -1` 。

# 题解

## 作者：CZQ_King (赞：3)

很明显，这题可以直接$O(1)$算法过，主要思想是分类讨论。

可以发现，从$n\times2$到$n\times4$（包括）之间的$m$都有解，其他则无解，例如下图是当$n=3$时：

![](https://s2.ax1x.com/2019/11/10/MnoHCF.png)

其中，你会发现一些规律：最少时一定是三个大人，如果脚增加一个，那么优先把一个大人变成一个老人，如果不能，就把一个老人变成婴儿（~~返老还童~~），直到三个都是婴儿。此时就是脚最多的时候。

因此我们分类讨论即可，里面的颜色的含义：
- 红色是只有大人的情况（$n\times2=m$）
- 橙色是有大人也有老人的情况（$n\times3\ge m,n\times2\not=m$）
- 蓝色是有老人也有婴儿的情况（$n\times3< m,n\times4\not=m$）
- 绿色是全都是婴儿的情况（$n\times4=m$）

因此我们有了这样一个策略，我们先判断无解的情况，再判断红色的情况，再判断绿色的情况，再判断橙色的情况，最后剩下的就是蓝色的情况。

除了橙色和蓝色，其它情况的个数很好求，其实橙色和蓝色也只是解二元一次方程组罢了。

当橙色情况时，我们假设有$a$个大人$b$个老人，依题意列出方程组：

$$\begin{cases}a+b=n\\2a+3b=m\end{cases}$$

解得

$$\begin{cases}a=3n-m\\b=m-2n\end{cases}$$

因此，直接套入即可。

当蓝色情况时，设$a$个老人$b$个婴儿，同理可解出

$$\begin{cases}a=4n-m\\b=m-3n\end{cases}$$


------------
代码：
```cpp
#include<cstdio>
#define O(x,y,z) {printf("%d %d %d\n",x,y,z);return 0;}//宏定义方便
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	if(n*4<m||n*2>m)O(-1,-1,-1)//无解情况
	if(n*2==m)O(m/2,0,0)//红
	if(n*4==m)O(0,0,m/4)//绿
	if(n*3>=m)O(3*n-m,m-2*n,0)//橙
	else O(0,n*4-m,m-n*3)//蓝
}
```

---

## 作者：RioBlu (赞：2)

在一年前，$2018-10-27$我用$O(N^2)$做了一次
```
#include<bits/stdc++.h>
using namespace std;
long long a,b;
int main()
{
    cin>>a>>b;
    for(int s=0;s<a;s++)//此处应改为s<=a
    {
    	for(int v=0;v<a;v++)//此处应改为v<=a
    	{
    		if(s+v>a)break;//剪枝
    		if(s*2+v*3+(a-s-v)*4==b)//满足条件
    		{
    			cout<<s<<" "<<v<<" "<<a-s-v<<endl;
    			return 0;
			}
		}
	}
	cout<<"-1 -1 -1"<<endl;
}
```
题目仅仅是说部分点满足$N<1500$

我以为又要有一些非常难的优化，我就放弃了

在最近我刷一些$AT$题时，我看到了它，想了一想，觉得二元一次方程组便可以了

```
#include<bits/stdc++.h>
using namespace std;
long long a,b,A,B,C;//a：总人数，b：腿数；设年轻人A人，老人B人，婴儿C人
int main()
{
    cin>>a>>b;
    for(int A=0;A<=a;A++)//枚举A
    {
    	//A+B+C=a (根据题意得)
    	//B+C=a-A (移项得) ①
    	//3B+3C=3a-3A (三倍的①)
    	//2A+3B+4C=b (根据题意得)
        //3B+4C=b-2A (移项得) ②
    	//C=b-3a+A (②-3①)
        //B=(b-2A-4C)/3 (通过②移项得)
    	C=b-3*a+A;
    	B=(b-2*A-4*C)/3;
    	if(A+B+C==a&&2*A+B*3+C*4==b&&A>=0&&B>=0&&C>=0)//由于ABC为整数，解出来要看看符不符合条件
    	{
    		cout<<A<<" "<<B<<" "<<C<<endl;
    		return 0;
		}
	}
	cout<<"-1 -1 -1"<<endl;//都不行
}
```
时间复杂度$O(N)$

---


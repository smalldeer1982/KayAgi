# [ABC011C] 123引き算

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc011/tasks/abc011_3

あなたは、友人から、一人用のゲームを紹介されました。

最初に、数字 $ N $ が与えられます。 $ 1 $ , $ 2 $ , $ 3 $ の中から好きな数字を選び、 与えられた数字に対し、引き算を行う、という処理を行うことできます。

この処理は $ 100 $ 回まで行うことが可能であり、最終的に数字を $ 0 $ にすることが目標のゲームです。

しかし、計算途中でなってはいけないNG数字が $ 3 $ つ与えられており、 この数字に一時的にでもなってしまった瞬間、このゲームは失敗となります。 NG数字が $ N $ と同じ場合も失敗となります。

NG数字が $ N $ と同じ場合について、正しい判定が行われていませんでした。リジャッジを行いました。

あなたは、このゲームが、目標達成可能なゲームとなっているか調べたいです。

目標達成可能な場合は`YES`、そうでない場合は`NO`と出力してください。

## 说明/提示

### Sample Explanation 1

$ 2 $ を $ 1 $ 回引くことにより、 $ 0 $ を作ることが出来ます。

### Sample Explanation 2

最初に $ 2 $ を引き、次に $ 3 $ を引くことで、$ 5 $ → $ 3 $ → $ 0 $ と変化し、目標を達成することが出来ます。

### Sample Explanation 3

$ 100 $ 回連続で $ 3 $ を引かなければ、目標を達成することはできません。 しかし、 $ 3 $ だけを引き続けていると、途中でNG数字である $ 57 $ になってしまいます。

## 样例 #1

### 输入

```
2
1
7
15```

### 输出

```
YES```

## 样例 #2

### 输入

```
5
1
4
2```

### 输出

```
YES```

## 样例 #3

### 输入

```
300
57
121
244```

### 输出

```
NO```

# 题解

## 作者：vеctorwyx (赞：8)

## 为什么大佬们的题解都这么简单？？？

刚刚从[P4872 OIer们的东方梦](https://www.luogu.com.cn/problem/P4872)那里磨过来（太难了！）

~~这不是道简单的广搜吗~~

按广搜的思路，搜到0停止，注意不要重复搜索，也不要搜负数

TIPs: 

1.AT的题通用：最后别忘了换行；

2.如果n>300直接输出“NO”；

3.如果n与NG1，NG2,NG3中任意一个相等（0也一样~~但我没管0~~）直接输出“NO”；

AC代码奉上：
```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
int n,n1,n2,n3;
int d[4]={0,1,2,3};
struct node
{
	int data;
	int time_;
}a;
queue<node>q;
bool b[310];
int main()
{
	cin>>n>>n1>>n2>>n3;
	a.data=n;
	q.push(a);
	if(n==n1||n==n2||n==n3)//特判*1
	{
		cout<<"NO"<<endl;
		return 0;        
	}
	if(n>300)//特判*2
	{
		cout<<"NO"<<endl;
		return 0;
	}
	while(!q.empty())//bfs了解一下
	{
		a=q.front();
		if(a.time_>100)//超时
		break;
		if(a.data==0)//搜到0了
		{
			cout<<"YES"<<endl;
			return 0;
		}
		for(int i=1;i<=3;i++)
		{
			a=q.front();
			a.data-=d[i];
			a.time_++;
			if(a.data>=0&&a.data!=n1&&a.data!=n2&&a.data!=n3&&b[a.data]==0)
			{
				q.push(a);
				b[a.data]=1;//标记为搜过
			}
		}
		q.pop();
	}
	cout<<"NO"<<endl;
	return 0;
}
```
虽然这好像并不是一道广搜题，但广搜不好的同学可以拿它练练手QAQ

---

## 作者：CZQ_King (赞：5)

这题可以看做从$n$走到$0$，但是中间不能踩到陷阱（三个陷阱）

主要思路：
- 能走三步就走三步，否则走两步，实在不行走一步，如果都走不了，宣布死亡
- 按照上面方法走$100$步以后，判断是否走到了$0$（小于等于$0$），如果是，那么输出$YES$否则输出$NO$
- 需要特判一个东西，就是刚开始的时候是否在陷阱上，如果是，直接输出$NO$并结束

------------
代码：
```cpp
#include<bits/stdc++.h>
#define f(x) n-x!=a&&n-x!=b&&n-x!=c
#define die {puts("NO");return 0;}//死亡
using namespace std;
int n,a,b,c,p=100;//p要赋初值
int main(){
	cin>>n>>a>>b>>c;
	if(f(0)){//如果刚开始不在陷阱上
		while(p&&n>0){//如果走够了100步或走到了终点
			p--;
			if(f(3))n-=3;//如果可以走三步
			else 
				if(f(2))n-=2;//走不了三步试试走两步
				else 
					if(f(1))n-=1;//实在不行走一步
					else die//走不了
		}
		if(n>0)die//没有走到0
		else puts("YES");//恭喜通关
	}else die//awsl
}
```

---

## 作者：liangbowen (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/AT916)

小学生又双叒叕来写题解啦！

大家使用的都是 while 循环，那我来一个 for 循环版本！

我的思路是**贪心**。

怎么个贪心法呢？

由于最多只能执行一百次，那我们就得多用三。

准确的说，就是按三二一的顺序，一个不行就轮到下一个。

为什么可以这样也很简单。

比方说你减了三，如果你不减三，还是可以通过减一再减二达到，但次数增加了。

而且，用减一再减二的方法，可能还会命中陷阱。

因此，遵循：能用三就用三，不能就用二，还不能就用一，仍然不行就爆掉。

一百次后还不行，也爆掉。

对了，得特判一下**开始就中陷阱**的情况，也爆掉。

## 送上满分代码：


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, g1, g2, g3;
void Error() 
{
	printf("NO\n");
	exit(0);
}
void OK()
{
	printf("YES\n");
	exit(0);
}
bool chk(int x) 
//判断是否可以执行一次步骤，即判断 n-x 是否可行。 
{
	int t = n - x;
	if (t < 0) return false;  //如果减后变负数了，当然爆掉。 
	if (t == g1 || t == g2 || t == g3) return false;
	return true;
}
int main()
{
	//注意输出时勿忘祖传换行。 
	scanf("%d%d%d%d", &n, &g1, &g2, &g3);
	if (!chk(0)) Error();  //特判原数为零。 
	for (int i = 1; i <= 100; i++)
	{
		if (chk(3)) n -= 3;
		else if (chk(2)) n -= 2;
		else if (chk(1)) n -= 1;
		else Error();  //如果都减不了，爆掉。
		if (n == 0) OK();
	}
	Error();   //一百次后还是没到零，爆掉。 
}
```


---

## 作者：szkzyc (赞：2)

这道题就是输入四个数,然后可以对第一个数进行减去一或二或三，问最后能不能得到 $0$。

条件：

- 1：在这个数的操作过程中，不能与第$2$、$3$、$4$个数相同。

- 2：这个数的操作次数总和不能超过 $100$。

- 3：只能减去 $1$ 或 $2$ 或 $3$。

- 4：结果必须等于 $0$。

- 5：能达到输出 YES，不能达到输出 `NO`。

在看完条件后，可以想到这道题可以有一种贪心的做法。

就是优先减去 $3$，如果不符合条件就减去 $2$，再不符合条件就减去 $1$。如果还不行那就输出 `NO`。

在整理完条件后，这份代码就很容易出来了。

### 此题代码（请勿抄袭）

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define ll long long
#define reg register
using namespace std;` 
int cnt = 0;
int mian(){//PS:exit(0)函数的作用与return 0 一致哦 。puts("xxx")相当于输出xxx，但是会自带换行，因为AT的题都要输出换行哦 
    int N, Ng1, Ng2, Ng3;
    cin >> N >> Ng1 >> Ng2 >> Ng3;
    if(N == Ng1 || N == Ng2 || N == Ng3 || N > 300) puts("NO"), exit(0); //如果N等于另外三个数或者N大于300，都是不符合条件的，所以就输出NO 
	while(cnt <= 100 && N > 0){ //如果操作次数小于等于100且N大于0的话则进行操作判断 
		if(N == 0) puts("YES"), exit(0); //如果N等于0，那么输出YES后退出程序 
		if(N - 3 != Ng1 && N - 3 != Ng2 && N - 3 != Ng3 && N - 3 >= 0) N -= 3; //判断N减三是否符合要求 
		else if(N - 2 != Ng1 && N - 2 != Ng2 && N - 2 != Ng3 && N - 2 >= 0) N -= 2;//判断N减二是否符合要求 
		else if(N - 1 != Ng1 && N - 1 != Ng2 && N - 1 != Ng3 && N - 1 >= 0) N -= 1；//判断N减一是否符合要求 
		else break; //如果都不符合那就退出程序 
		cnt++; //操作次数加一 
		//cout << N << " "; （调试） 
	} 
	if(N == 0 && cnt <= 100) puts("YES");//如果N等于0且操作次数小于等于100输出YES 
	else puts("NO");//否则输出NO 
	return 0;
}
//代码请勿抄袭，后果自负 （添加防抄袭） 
```

### ---end---




---

## 作者：Smoggy (赞：2)

## 题目大意：

有这样一个游戏：

给你一个数字$N$和三个特殊数字$NG_1,NG_2,NG_3$，进行以下步骤：

- 在数字$1,2,3$中任选一个数字，使$N$减去它

- 但是必须满足$N$时刻不能等于$NG_1,NG_2,NG_3$中的任意一个数字

- 以此循环，以上步骤至多执行$100$次

你的目标是使$N$变为$0$

如果能达到目标，请输出'YES'，如果不能，输出'NO'。

$$\texttt{---------------------}$$

其实这一道题就是一道十分简单的模拟，

一边循环扫过去既可。那么说到循环就要注意边界辣，

非常的好判断，这里的$Count < 100$就是循环次数，而$N > 0$就是如果还没达成目标就继续。

如果同时满足上述两个条件就可以执行。

```cpp
	while ( Count < 100 and N > 0 )
```

由于题目说$N$不能等于$NG_1,NG_2,NG_3$，那么我们就判断三次既可

```cpp
	if ( N - 3 != Ng1 and N - 3 != Ng2 and N - 3 != Ng3 ) N -= 3;	//减3行不行得通
    else if ( N - 2 != Ng1 and N - 2 != Ng2 and N - 2 != Ng3 ) N -= 2;	//减2
    else if ( N - 1 != Ng1 and N - 1 != Ng2 and N - 1 != Ng3 ) N -= 1;	//减1
```
如果满足了$N≠NG_1,NG_2,NG_3$，那你就不用担心减的问题辣，因为减$1$到最后都能减完。

完整代码如下：
```cpp
// By 69927
#include <bits/stdc++.h>
#define LL long long
using namespace std;
int N, Ng1, Ng2, Ng3;
int main()
{
    cin >> N >> Ng1 >> Ng2 >> Ng3;
    if ( N == Ng1 || N == Ng2 || N == Ng3 )
        {printf("NO\n"); return(0);}
    int Count = 0;
    while ( Count < 100 and N > 0 )
    {
        if ( N - 3 != Ng1 and N - 3 != Ng2 and N - 3 != Ng3 ) N -= 3;
        else if ( N - 2 != Ng1 and N - 2 != Ng2 and N - 2 != Ng3 ) N -= 2;
        else if ( N - 1 != Ng1 and N - 1 != Ng2 and N - 1 != Ng3 ) N -= 1;
        else  {printf("NO\n");return(0);}
        Count++;
    }
    if ( N <= 0 ) printf("YES\n");
    else printf("NO\n");
    return (0);
}
```

---

## 作者：Astatinear (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT916)

### 思路

**$dp$ 问题**

题目大意就是给定一个数字 $n$ 你可以对他减去 $1,2,3$ 里面的任意一个数字，只需要满足在操作过程中 $n$ 不等于题目中说明的三个数,最后如果可以使得 $n$ 等于 $0$ 就输出 `YES`，如果不能使得 $n$ 等于 $0$ 就输出 `NO`。

读完题目之后，我想到了 $dp$ 的做法。

**我们先定义状态** 令 $dp[i][j]$ 表示第 $i$ 个数至多操作 $j$ 次能否等于 $0$。如果能，$dp[i][j]=1$，如果不能，$dp[i][j]=0$。

**接着确定初始值** 很显然，我们可以确定当 $i$ 在 $3$ 以下，且保证题目中给定的三个数不等于 $i$ 的时候，$dp[i][j]=1,0<i<4$ 且 $0<j<100$，
且 $dp[0][0]=1$。

**接着就是状态转移** 先枚举 $i$ 从 $4$ 枚举到 $n$ (因为已经确定了 4 以前的状态转移了)。

如果 $i$ 等于题目中给定的三个数，则我们就不执行 $j$ 这一层循还。

如果不等于题目中给定的三个数，我们就执行 $j$ 这一层循环 从 $1$ 枚举到 $100$ (他之多可以操作 100 次)。

则对于 $dp[i][j]$ 共有四种情况:

**$1.$** 即 $i$ 运用 $j-1$ 次操作就可以等于 0 了。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i][j-1]$

**$2.$** 即 $i$ 通过 $-1$ 这个操作来接近 0。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i-1][j-1]$

**$3.$** 即 $i$ 通过 $-2$ 这个操作来接近 0。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i-2][j-1]$

**$4.$** 即 $i$ 通过 $-3$ 这个操作来接近 0。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i-3][j-1]$

**最后就是输出答案** 只要最终的 $n$ 至多操作 $100$ 次可以等于 0 就输出 `YES`。

即如果 $dp[n][100]=1$ 输出 `YES`。

如果 $dp[n][100]=0$ 输出 `NO`


### 代码

```cpp
#include<iostream>
using namespace std;
int n,p1,p2,p3;
int dp[305][305];
int main()
{
    cin>>n>>p1>>p2>>p3;
    if(n==p1||n==p2||n==p3)
    {
        cout<<"NO"<<endl;//如果n等于三个数中的一个,输出NO
        return 0;
    }
    //初始值
    dp[0][0]=1;
    for(int j=1;j<=100;++j)
    {
        dp[0][j]=1;
        dp[1][j]=1;
        dp[2][j]=1;
        dp[3][j]=1;
    }
    for(int i=4;i<=n;++i)
    {
        if(i==p1||i==p2||i==p3)//如果i等于三个数中的其中一个,则不执行j这一层循环
            continue;
        for(int j=2;j<=100;++j)
        {
            //状态转移
            dp[i][j]|=dp[i][j-1];
            dp[i][j]|=dp[i-1][j-1];
            dp[i][j]|=dp[i-2][j-1];
            dp[i][j]|=dp[i-3][j-1];
        }
    }
    //判断是否可行
    if(dp[n][100]==1)
    {
        cout<<"YES"<<endl;
    }
    else
    {
        cout<<"NO"<<endl;
    }
}

```

---

## 作者：StarPatrick (赞：0)

这题数据比较小，并且问的是 $n$ 是否可以为 $0$，很明显——搜索。

我选择记忆化深搜（不记忆化会爆掉），定义 ``dfs(i,x)`` 返回值为 ``bool``，表示进行了 $i$ 次操作后 $N$ 为 $x$ 时是否可以将 $N$ 变为 $0$。

边界条件：
```cpp
if (x==a||x==b||x==c||x<0)
{
	return 0;
}
if (x==0)
{
	return 1;
}
if (i==100)
{
	return 0;
}
```
搜索：
```cpp
return dfs(i+1, x-1)||dfs(i+1, x-2)||dfs(i+1, x-3);
```
连起来再加上记忆化就基本上完成了，答案为``dfs(0,N)``。

核心代码：
```cpp
bool dfs(int i, int x)
{
	if (dp[i][x]!=-1)
	{
		return dp[i][x];
	}
	if (x==a||x==b||x==c||x<0)
	{
		return dp[i][x]=0;
	}
	if (x==0)
	{
		return dp[i][x]=1;
	}
	if (i==100)
	{
		return dp[i][x]=0;
	}
	return dp[i][x]=dfs(i+1, x-1)||dfs(i+1, x-2)||dfs(i+1, x-3);
}
```

---

## 作者：林家三少 (赞：0)

## 居然只有两篇题解???

![](https://cdn.luogu.com.cn/upload/image_hosting/2wmfr1mv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这就是一道简单的模拟题，我们只要进行下面几步：

1. 首先要判断Ta是不是已经在那个东东上了

2. 如果不是那就进行下面几步(有点绕，勉强分开了

- 要从最大的3开始，判断能不能走先

- 3不行就用2来判断

- 2不行就只能用最小的1来了

- 如果1也不行就代表他没得走了，结束

3. 最后如果走完一百步还是没能到0就"NO",否则"YES"

讲完了,上代码(~~由于之前口水浪费过多,所以不打注释了~~)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int ans,n;
int m1,m2,m3;
int main()
{
	cin>>n;
	cin>>m1>>m2>>m3;
	if(n==m1||n==m2||n==m3){
		cout<<"NO\n";
		return 0;
	}
	while(ans<100&&n>0){
		ans++;
		if(n-3!=m1&&n-3!=m2&&n-3!=m3&&n>=3) n-=3;
			else{
				if(n-2!=m1&&n-2!=m2&&n-2!=m3&&n>=2) n-=2;
					else{
						if(n-1!=m1&&n-1!=m2&&n-1!=m3&&n>=1) n-=1;
							else{
								cout<<"NO\n";
								return 0;
							}
					}
			}
	}
	if(n==0){
		cout<<"YES\n";
	}
	else{
		cout<<"NO\n";
	}
	return 0;
}
```


---


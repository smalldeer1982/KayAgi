# [ABC038C] 単調増加

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc038/tasks/abc038_c

$ N $個の数からなる数列が与えられます。$ i $番目の数を$ a_i $と呼びましょう。

$ a_l,a_{l+1},...,a_r $ が単調増加、すなわち $ l≦r $ であって $ a_i\ <\ a_{i+1} $ が$ l≦i\ <\ r $ を満たす全ての$ i $に対して成り立つような$ (l,r) $の数を求めてください。

## 说明/提示

### 制約

- $ 1≦N≦10^5 $
- $ 1≦a_i≦10^5 $
- $ a_i $は全て整数である

### 部分点

- $ N\ ≦\ 3,000 $ を満たすテストケース全てに正解した場合、部分点として$ 40 $点が与えられる。

### Sample Explanation 1

条件を満たす$ (l,r) $は$ (1,1),(1,2),(1,3),(2,2),(2,3),(3,3),(4,4),(5,5) $の$ 8 $つです。

### Sample Explanation 2

$ 1≦l≦r≦N $を満たす$ (l,r) $全てが条件を満たします。

### Sample Explanation 3

例えば、$ 3,\ 3,\ 4 $はこの問題で単調増加ではないことに注意してください。

## 样例 #1

### 输入

```
5
1 2 3 2 1```

### 输出

```
8```

## 样例 #2

### 输入

```
4
1 2 3 4```

### 输出

```
10```

## 样例 #3

### 输入

```
6
3 3 4 1 2 2```

### 输出

```
8```

## 样例 #4

### 输入

```
6
1 5 2 3 4 2```

### 输出

```
10```

# 题解

## 作者：btng_smith666 (赞：5)

# 前言 ：

[题面传送门](https://www.luogu.com.cn/problem/AT1902)

[blog](https://www.luogu.com.cn/blog/X-SSS-Tng/solution-at1902)

挤出时间来写一篇题解~

# 思路

简洁的题面：

> 问有多少个子序列是单调上升的

其实这个题目如果没有时间和空间上的任何坑点的话还是十分简单的（~~但事实说明就算有坑也不难~~

这道题十分引人注目的是这个：

> 时间限制：2.00s

再去看看 $N$ 的范围：

> $N\le 3000$

所以很明显，普通的 $\operatorname{O}(n^2)$ 算法是会 $TLE $ 的。

给一个一眼出答案但会 $TLE$ 的做法（可以不看）：

循环扫一下序列，先累加答案，然后在循环中把扫到的地方往后再扫一遍，判断 $a_i<a_{i+1}$ ，如果满足就说明从这一位起后面就都不是单调上升的了，直接退出循环，不满足就累加个数继续往后扫。具体代码就不放了。

然后，经过 $TLE$ 的打击后我们就会发现其实完全可以 $\operatorname{O}(n)$ 过去的，只需要在前面基础上去掉循环嵌套的步骤，用一个 $tmp$ 临时变量存下上次输入的数字，再用另一个临时变量 $k$ 存下已经有几个连续子序列是单调上升的，判断如果上次的数字比这次的小，那么就把连续的 $k$ 个先加一再累加到答案中，如果不是说明这个连续的单调上升子序列已经结束，将 $k$ 清零即可。

# 代码 ：

```cpp
#include<bits/stdc++.h>//by btng_smith666 juruo
using namespace std;
#define ll long long//懒人必备 
ll ans,k,n,a,tmp=0x7ffffffff;//0x7ffffffff为数组最大字节数，通常用来表示一个很大的数 
int main()
{
	cin>>n;
    ans=n;
    for(ll i=1;i<=n;i++)
	{
		cin>>a;//输入，连数组都不用开呢 
    	if(tmp<a)
    		ans+=++k;//将 k 先加 1 然后累加到答案中 
    	else
			k=0;//清零 
		tmp=a;//赋值 
	}
	cout<<ans;
	return 0;
}
```

# 后记 ：

> 这题不用换行~

最后求个赞qwq


---

## 作者：CZQ_King (赞：3)

## $O(n)$算法
做法：判断这个数是否比上一个数大（注意不是大于等于），是的话把$l$加上$1$（$l$为单调上升的长度），并把答案加上$l$。因为每多出一个单调上升的数，个数就多上长度个。

------------
代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n,v[100005],l;
int main(){
    v[0]=0x7fffffff;//要把第一个数设为最大的
    cin>>n;
    long long ans=n;//一定要long long!!
    for(long long i=1;i<=n;i++){
        cin>>v[i];
        if(v[i]>v[i-1])l++,ans+=l;//如果属于单调上升数列
        else l=0;//不属于就要把长度清零
    }
    cout<<ans<<endl;//最后输出答案
    return 0; 
}
/*
其实可以不用数组，用一个last变量存上一个数就可以了
*/
```

---

## 作者：SfumatoCannon_ (赞：1)

### solution

题目要求：求数组中有多少个单调上升的子串。

（其实严谨点来说应该是**严格单调**上升子串，样例3可以证明这一点）
***

首先观察数据范围，$n\le10^5$，$O(n^2)$的算法肯定是过不了的。

由于**子串是连续的**，通过观察我们不难想到：

对于数组中的某个数 $a_i$ ，如果 $a_{i-1}<a_i$ ，那么：从 $1$ 到 $i$ 的所求子串个数 $=$ 从 $1$ 到 $i-1$ 的子串个数 $+1$.

否则，从 $1$ 到 $i$ 的所求子串个数就只能$=1$.

故而，此题可以使用 $O(n)$ 的递推算法来解决。
***

在这里有个点要注意一下：```dp[1]```是几呢？当然是1啦qwq
### code:
```cpp
#include <cstdio>
int a[10001],dp[10001];
int n,ans;
int main()
{
	int i;
	scanf("%d",&n);
	for (i=1;i<=n;i++)
		scanf("%d",&a[i]);
	dp[1]=1;
	for (i=2;i<=n;i++)
	{
		if (a[i]>a[i-1])
			dp[i]=dp[i-1]+1;
		else
			dp[i]=1;
	}
	for (i=1;i<=n;i++)
		ans+=dp[i];
	printf("%d\n",ans);	//别忘记换行
	return 0;
}
```


---

## 作者：梦理乾坤 (赞：1)

当第i个>第i-1个时, 那么以第i-1个为末尾的子串数目 $+1$ 不就是从第$i$个为末尾的子串数目吗?

然后问题就简单了吗

记住初始$ans=n$ 因为每一个单个就可以是一个单调字串

最后记得开long long

因为$(1+100000)*100000/2=5000050000>2147483647$

所以不开long long是不行的

最后就是代码

```cpp
#include <iostream>

using namespace std;

int main()
{
    long long n, ans;
    cin >> n;

    ans = n;

    long long la = 0x7fffffff;  //要设一个非常大的数
    long long l;

    for (long long i = 1; i <= n; i++)
    {
        int x;
        cin >> x;

        if (x > la)
            l++, ans += l;  //你把已经有的单调串加进去
        else
            l = 0;  //清零

        la = x;  //重置上一个数
    }

    cout << ans << endl;  //输出
    return 0;
}
```
诚信测试，网上搜题解或相互串答案可耻！

记住这句名言

求管理员过，谢谢。

---

## 作者：RioBlu (赞：1)

问有多少个子串（不包括空串）是单调上升的

注意：类似于[1] [8848] [233] 这样一个数字的也属于单调上升的
___
$N<=3000$ 我觉得会超时所以我有个优化的思路，从左往右找，然后分成几份，分的案例：

比如1 2 3 2 1

我会把它分成：$[1,2,3];[2];[1]$

这样每一份他的全部子串（不包括空串）均满足单调上升

第一个的全部子串有：$[1],[1,2],[1,2,3],[2],[2,3],[3]$

第二个的全部子串有：$[2]$

第三个的全部子串有：$[1]$

#### 我发现了若你有$x$个元素那么，你有$x*(x+1)/2$个子串

### 代码：
```
#include<bits/stdc++.h>
using namespace std;
long long a,b[100005],c,d,e,ans,now=1;
int main()
{
    cin>>a;
    b[a]=-100;
    for(int s=0;s<a;s++)cin>>b[s];//输入
    for(int s=0;s<a;)
    {
    	for(int v=s+1;v<=a;v++)
    	{
    		if(b[v]<=b[v-1])//优化！
    		{
    			ans=ans+((now+1)*(now)/2);
    			s=v;//改变s
    			now=1;
    			break;
			}
			else
			now++;
		}
	}
	cout<<ans<<endl;
}
```

---


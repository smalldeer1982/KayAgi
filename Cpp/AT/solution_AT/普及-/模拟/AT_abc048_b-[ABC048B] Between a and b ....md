# [ABC048B] Between a and b ...

## 题目描述

给出两个非负整数 $a$，$b$（$a≤b$）和一个正整数 $x$。请在 $a$ 以上 $b$ 以下（包含 $a$，$b$）的整数中， 找出可被 $x$ 整除的数数量。

## 说明/提示

$0 ≤ a ≤ b ≤ 10^{18}$，$1 ≤ x ≤ 10^{18}$。

## 样例 #1

### 输入

```
4 8 2```

### 输出

```
3```

## 样例 #2

### 输入

```
0 5 1```

### 输出

```
6```

## 样例 #3

### 输入

```
9 9 2```

### 输出

```
0```

## 样例 #4

### 输入

```
1 1000000000000000000 3```

### 输出

```
333333333333333333```

# 题解

## 作者：小兔宝宝 (赞：9)

这题其实很简单，~~应该是入门难度~~

首先，数据范围告诉我们不能一个个数枚举判断。于是，我们想到了用数学方法来做。

我们先求出第一个大于等于a的数是x的多少倍，再求出第一个小于等于b的数是x的多少倍。具体方法嘛。。。把a、b分别除以x就好了。。。

然后，将这两个数相减，再加一，就是答案啦。

丢代码。。。
```
#include<cstdio>

long long a,b,x;
long long s,e;
int main(){
	scanf("%lld%lld%lld",&a,&b,&x);
	if(a%x==0)s=a/x;//这里的判断是为了看除出来是否为整数，如果不是整数就加一
	else s=a/x+1;
	e=b/x;//这里除出来会自动向下取整，不用判断
	printf("%lld",e-s+1);//这里大家可能有疑问：如果没有答案会输出什么？
    //其实，如果没有答案，e-s会是-1，所以输出的就是0啦。
	return 0;
}
```

---

## 作者：liuyifan (赞：6)

不需要[楼下](https://www.luogu.org/blog/bunny123/solution-at2151)这样复杂的写法,main内两行即可
极致压行code:
```
#include<bits/stdc++.h>
#define int long long//防止NOIP2018PJT2惨案
using namespace std;
int a,b,x;
signed main()//singed=int
{
    scanf("%lld%lld%lld",&a,&b,&x);
    printf("%lld",!(a%x)?b/x-a/x+1:b/x-a/x);//压行,思路与楼下相同
    return 0;
}
```

---

## 作者：CZQ_King (赞：4)

居然没有py题解，蒟蒻来发一波$Python3$题解。

思路：

我们来看一个例子：``4 6 3``。

我们可以用这样的思路：先列举出$1$到$6$的数，
然后先看$1$到$4$以内能被$3$整除的数的个数，应该是$4/3=1$个，再看$1$到$6$以内能被$3$整除的数的个数，应该是$6/3=2$个。那么我们相减就可以得出$4$到$6$以内能被$3$整除的数的个数是$1$个。

![](https://s2.ax1x.com/2019/08/05/egwR54.png)

当然，有一个坑点，我们再看一个例子：``4 6 2``

照着刚才的方法应该是这样：

![](https://s2.ax1x.com/2019/08/05/eg0SMt.png)

但是！我们漏掉了一个$4$！所以我们要加一个特判，如果$a$（这个例子是$4$）能被$n$（这里是
$2$）整除，那么还要多加一个回来。

------------
代码：
```python
a,b,n=map(int,input().split());
if a%n==0: #特判是否整除
    k=1;
else:
    k=0;
print (b//n-a//n+k); #输出答案 
```

---


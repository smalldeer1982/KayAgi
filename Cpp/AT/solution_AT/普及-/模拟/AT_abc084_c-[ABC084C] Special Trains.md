# [ABC084C] Special Trains

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc084/tasks/abc084_c

Atcoder国に、 $ 1 $ 本の東西方向に走る鉄道が完成しました。

この鉄道には $ N $ 個の駅があり、西から順に $ 1 $,$ 2 $,$ ... $,$ N $ の番号がついています。

明日、鉄道の開通式が開かれます。

この鉄道では、$ 1≦i≦N-1 $ を満たす全ての整数 $ i $ に対して、駅 $ i $ から駅 $ i+1 $ に、$ C_i $ 秒で向かう列車が運行されます。ただし、これら以外の列車は運行されません。

駅 $ i $ から駅 $ i+1 $ に移動する列車のうち最初の列車は、開通式開始 $ S_i $ 秒後に駅 $ i $ を発車し、その後は $ F_i $ 秒おきに駅 $ i $ を発車する列車があります。

また、$ S_i $ は $ F_i $ で割り切れることが保証されます。

つまり、$ A％B $ で $ A $ を $ B $ で割った余りを表すとき、$ S_i≦t $,$ t％F_i=0 $ を満たす全ての $ t $ に対してのみ、開通式開始 $ t $ 秒後に駅 $ i $ を出発し、開通式開始 $ t+C_i $ 秒後に駅 $ i+1 $ に到着する列車があります。

列車の乗り降りにかかる時間を考えないとき、全ての駅 $ i $ に対して、開通式開始時に駅 $ i $ にいる場合、駅 $ N $ に到着できるのは最も早くて開通式開始何秒後か、答えてください。

## 说明/提示

### 制約

- $ 1≦N≦500 $
- $ 1≦C_i≦100 $
- $ 1≦S_i≦10^5 $
- $ 1≦F_i≦100 $
- $ S_i％F_i=0 $
- 入力は全て整数

### Sample Explanation 1

駅 $ 1 $ からは、以下のように移動します。 - 開通式開始 $ 5 $ 秒後に、駅 $ 2 $ に向かう列車に乗る。 - 開通式開始 $ 11 $ 秒後に、駅 $ 2 $ に到着する。 - 開通式開始 $ 11 $ 秒後に、駅 $ 3 $ に向かう列車に乗る。 - 開通式開始 $ 12 $ 秒後に、駅 $ 3 $ に到着する。 駅 $ 2 $ からは、以下のように移動します。 - 開通式開始 $ 10 $ 秒後に、駅 $ 3 $ に向かう列車に乗る。 - 開通式開始 $ 11 $ 秒後に、駅 $ 3 $ に到着する。 駅 $ 3 $ に対しても、$ 0 $ を出力しなければならないことに注意してください。

## 样例 #1

### 输入

```
3
6 5 1
1 10 1```

### 输出

```
12
11
0```

## 样例 #2

### 输入

```
4
12 24 6
52 16 4
99 2 2```

### 输出

```
187
167
101
0```

## 样例 #3

### 输入

```
4
12 13 1
44 17 17
66 4096 64```

### 输出

```
4162
4162
4162
0```

# 题解

## 作者：_wjr_ (赞：2)

又是一道大模拟。

先看一眼题意吧。这个翻译实在是一言难尽。

### 题目描述

- 有一条铁路，上面有 $n$ 个车站。所有列车均为单向行驶。
- 从第 $i$ 站驶向第 $i + 1$ 站的列车需要行驶 $c_i$ 秒。
- 第 $i$ 站驶向第 $i + 1$ 站的列车在通车式后 $s_i$ 秒发出首班车，往后每 $f_i$ 秒发出一班列车，换乘不计时间。
- 由于乘客们赶时间，问你从第 $i$ 站出发的乘客最少需要多少秒才能赶到终点站。

### 具体思路

题目描述看一半，这道题的基本思路其实就已经有了。我们不就需要一个总时长 $cnt$ ，依次记录时间，到达每一站之后乘坐下一班列车，驶向那终点站。

用一个 for 循环，表示从第 $i$ 个车站发出的乘客，再往后依次枚举到达每个车站的时间与发车时间，这道题其实就做完了。

### AC Code

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int c[510] , s[510] , f[510] ;
int main()
{
	int n ;
	cin >> n ;
	for ( int i = 1 ; i < n ; i ++ )
	{
		cin >> c[i] >> s[i] >> f[i];
	}
	for ( int i = 1 ; i < n ; i ++ )
	{
		int t = 0 ;//定义时间
		for ( int j = i ; j < n ; j ++ )
		{
			t = max ( t , s[j] ) ;//时间是本站发车时间与之前用时的最大值
			if ( t % f[j] != 0 ) t = t + f[j] - t % f[j] ;//加上等待时间
			t += c[j] ;//加上列车运行所需时间
		}
		cout << t << endl ;
	}
	cout << "0" ;
    return 0;
}
```

那么这样一道题就做完了！

（由于是上古代码，码风惨不忍睹，勿喷勿喷勿喷！）

---

## 作者：Fleeing_loser (赞：1)

居然是道~~大~~模拟！

题意是有 $n$ 个车站，两个相邻的车站有单程车，从第 $i$ 个车站到第 $i+1$ 个车站用 $C_i$ 分钟，第一趟车 $S_i$ 分钟时发，之后每 $F_i$ 分钟发一辆。到 $n$ 的最少时间。

因为数据过小，直接模拟就可以了

**注意题面中的描述，岛国题目最后输出完也要再换个行！**

下面贴代码：
```cpp	
#include<bits/stdc++.h>
using namespace std;
int s[1000],f[1000],c[1000];//c,s,f分别与题目描述中的量一致
int main()
{
	int n,m,tim;
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d%d",&c[i],&s[i],&f[i]);
	}
	for(int i=1;i<n;i++)
	{
		tim=0;//多测一定要清零
		for(int j=i;j<n;j++)
		{
			tim=max(s[j],int((x+f[j]-1)/f[j])*f[j])+c[j];//直接模拟，计算时间
		}
		printf("%d\n",tim);
	}
	printf("0\n");//重要的事情说三遍，岛国题目一定要换行
	return 0;
}
```


---

## 作者：hyc1026 (赞：0)

本题是一道模拟题。

题意简述如下（题目翻译实在是不好辨认及理解）：

- 自西向东有 $N$ 个车站。
- 所有列车都是从西向东运行，并且只在相邻的站点之间有列车运行，从第 $i$ 站到第 $i+1$ 站的列车全程需要花费 $C_i$ 秒。
- 第 $i$ 站出发开往第 $i+1$ 站的第一班列车在通车式开始后 $S_i$ 秒发车，之后每过 $F_i$ 秒发出一班列车(保证 $S_i$ 一定是 $F_i$ 的倍数)。
- 如果不计换乘的时间，请计算从第 $i$ 站出发的乘客到达最后的第 $N$ 站的时刻，最早可能在通车式开始后多少秒。

思路：

模拟出火车到站的时间，与人到达的时间比对，计算等候时间。

**AC Code**
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;

int a[510], c[510], s[510], f[510];

int main()
{
	int n;
	cin >> n;
	for(int i=1; i<n; i++)
	{
		cin >> c[i] >> s[i] >> f[i];
	}
	for(int i=1; i<=n; i++)
	{
		int ans = 0;
		for(int j=i; j<n; j++) //j<n!
		{
			if(ans < s[j]) ans = s[j];
			if(ans % f[j] != 0)
				ans += f[j] - (ans % f[j]);
			ans += c[j]; //模拟计算答案
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：CharlesZiy (赞：0)

这是一篇模拟题，按题意写出来就问题不大。

本题核心代码长这样：

```cpp
for (int i = 1; i <= n; i++) // 共i个人
	{
		int t = 0; // 重点，表示到下一个站的时刻
		
		for (int j = i; j < n; j++)
		{
			int sct = s[j]; // 上车时间
           
			while (sct < t)
			{
				sct += f[j]; //求大于s[j]且刚好≥t的f[j]的倍数
			}
            
			t = c[j] + sct; // 下一站的时刻是运行时间+上车时间
		}
		
		cout << t << endl; // 到第n站就输出
	}
```
接下来是大家想要的源码：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n;

int c[505], s[505], f[505];

int main()
{
	std::ios::sync_with_stdio(false);
	
	cin >> n;
	
	for (int i = 1; i <= n; i++)
	{
		cin >> c[i] >> s[i] >> f[i];
	}
	
	for (int i = 1; i <= n; i++)
	{
		int t = 0;
		
		for (int j = i; j < n; j++)
		{
			int sct = s[j]; // 上车时间
			
			while (sct < t)
			{
				sct += f[j];
			}
			t = c[j] + sct;
		}
		
		cout << t << endl;
	}
}
```


---

## 作者：eEfiuys (赞：0)

题目：[AT3849](https://www.luogu.com.cn/problem/AT3849)

**依照题意直接暴力模拟即可。**
- 从 $1$ 到 $n-1$ 枚举 $i$，表示从第 $i$ 个点出发。
- $ans$ 初始为 $0$，表示用时。
- 从 $i+1$ 到 $n-1$ 枚举 $j$，表示已经到达第 $j$ 个点。若到达第 $j$ 个点时：
	- 还没有开始发车，即 $ans < s_j$：
		- 那么就要等第一班车，即 $ans = s_j$。
	- 刚好有一辆车，即 $ans \bmod f_j = 0$：
		- 那么直接坐上走了，$ans$ 不变。
	- 错过了上一辆车，即 $ans \bmod f_j \not = 0$：
		- 那么需要等下一辆车，即 $ans = \left \lceil \dfrac{ans}{f_j} \right \rceil \times f_j$。
	- 此时 $ans$ 即为从第 $j$ 个点坐上车的时间，再加上 $c_j$，即为到达第 $j + 1$ 个点的时间。
- 由于 $j$ 最终枚举到 $n-1$，因此 $ans$ 即为到达第 $n$ 个点所用时间，输出即可。
- 从第 $n$ 个点出发，不需要时间，因此再输出 $0$ 即可。
- 时间复杂度 $O(n^2)$。

------------

### 核心代码：
```cpp
for(int i=1;i<n;i++){
	ans=0;
	for(int j=i;j<n;j++){
		ans=max(ans,s[j]);
		if(ans%f[j])ans=ceil((double)ans/f[j])*f[j];
		ans+=c[j];
	}
	cout<<ans<<endl;
}
puts("0");
```

---


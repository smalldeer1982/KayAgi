# [ABC118C] Monsters Battle Royale

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc118/tasks/abc118_c

$ N $ 体のモンスターが居て、それぞれ $ 1,\ 2,\ ...,\ N $ と番号付けられています。

はじめ、モンスター $ i $ の体力は $ A_i $ です。

以降、体力が $ 1 $ 以上のモンスターを生きているモンスターと呼びます。

生きているモンスターが $ 1 $ 体になるまで以下を繰り返します。

- ランダムに $ 1 $ 体の生きているモンスターがランダムに別の生きているモンスターに攻撃します。
- その結果、攻撃されたモンスターの体力を攻撃したモンスターの体力と同じ値だけ減らします。

最後に生き残ったモンスターの最終的な体力の最小値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $

### Sample Explanation 1

$ 1 $ 番目のモンスターだけが攻撃し続けた場合、最後に生き残ったモンスターの体力は $ 2 $ となり、このときが最小です。

## 样例 #1

### 输入

```
4
2 10 8 40```

### 输出

```
2```

## 样例 #2

### 输入

```
4
5 13 8 1000000000```

### 输出

```
1```

## 样例 #3

### 输入

```
3
1000000000 1000000000 1000000000```

### 输出

```
1000000000```

# 题解

## 作者：guozhetao (赞：1)

## 题意
求 $n$ 个数的最大公因数。
## 思路
怪兽的攻击方式相似于求最大公因数，所以可以用辗转相除法求最大公因数避免重复循环。

辗转相除法就是用两个数轮流取模。当一个数是 $0$ 时，另一个数就是原先两个数的最大公因数

多个数的最大公因数满足：$\gcd(a,b,c) = \gcd(a,\gcd(b,c))$，证明可以参考[这篇题解](https://www.luogu.com.cn/blog/SSL-XXY/solution-sp27561)

## 代码
[AC](https://www.luogu.com.cn/record/89926139)
```cpp
#include<bits/stdc++.h>
using namespace std;
int gcd(int a,int b) {
	return b?gcd(b,a % b):a;//辗转相除法
}
int main() {
	int a,ans;
	cin>>a;
	for(int i = 1;i <= a;i++) {
		int b;
		cin>>b;
		if(i == 1) ans = b;
		else ans = gcd(ans,b);
	}
	cout<<ans;
}
```


---


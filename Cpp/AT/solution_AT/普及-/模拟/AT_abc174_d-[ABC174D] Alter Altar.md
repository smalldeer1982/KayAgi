# [ABC174D] Alter Altar

## 题目描述

### 题目简述

给定一个长为 $n$ 的字符串 $c$，记 $c$ 中的第 $i$ 个字符为 $c_i$（$1 \le i \le n$）。现在可以按任意顺序执行以下两个操作之一：

- 选择两个字符并交换它们；
- 选择一个字符并改变它。

请问：至少要进行多少次操作，才能使字符串中没有`WR`这个子串？

## 说明/提示

#### 输入输出样例 #1 说明
例如，下面的两个操作就可以实现目标。

首先，交换 $c_1$ 和 $c_3$，使 $c$ 变为`RWWR`；然后，改变 $c_4$ 为`W`，使 $c$ 满足条件。

#### 输入输出样例 #2 说明
有时可能不需要任何操作。

#### 数据规模与约定
对于全部的输入数据，保证 $2 \le n \le 200000$ 且 $n$ 为整数，同时 $c_i$ 必为`W`或`R`中的一个。

## 样例 #1

### 输入

```
4
WWRR```

### 输出

```
2```

## 样例 #2

### 输入

```
2
RR```

### 输出

```
0```

## 样例 #3

### 输入

```
8
WRWWRWRR```

### 输出

```
3```

# 题解

## 作者：zhang_yang_alan (赞：8)

## 1.理解题意
题目告诉我们，白石头不能放在红石头左边，也就是只 能放在右边。`WW....RR`。

这题也就转化成了求把所有红石头，放到左半部分的最小步骤。而我们只需用红石总数减去已经在左边部分的红石头数量就可以了。

## 2.思路说明

第一行输入 $n$。

第二行输入 $n$ 个字符。（连在一起）

循环得到 `R` 的个数。

循环得到已经到位的 `R` 的个数。

两者相减。

输出差值。

（详见代码）

## 3.代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
char a[200010];
int n,ans=0,sum,ss;
signed main(){
	cin >> n >> a;
	for(int i=0;i<n;i++){
		if (a[i]=='R') sum++;//红石头总数
	}
	for(int i=0;i<sum;i++){//遍历要放红石头的格子
		if (a[i]=='R') ss++;//已经到位置的红石头总数
	}
	ans=sum-ss;//两者相减
	cout << ans;//输出答案
	return 0;
}
```

码风不是很好看，希望对读者您有所帮助！

---

## 作者：chinazhanghaoxun (赞：6)

## 题意

题目给定我们一个只含有字符 ```W``` 和 ```R``` 的字符串，我们可以对它进行对两个字符的交换操作，或者改变一个字符，我们要求出最小的操作次数，使得字符串中没有 ```WR``` 这个字串。

## 分析

要使一个字符串没有 ```WR``` 这个字串，那必须使所有 ```R``` 都在 ```W``` 的前面，要不然就一定会找到一个字串，那么我们想要的字符串就是左边全是 ```R``` ，右边全是 ```W``` 的字符串。再分析一下，不难得出，一号操作一定比二号操作优。因为如果我们想要改变一个字符，交换两个不同的字符也可以达到效果。而且如果我们正好有两个想改变的不同字符，那就可以节省一次操作。所以我们就进行排序，正好 ```R``` 的字典序在 ```W``` 的前面，统计一下所有不应该在自己位置上的字符，最后因为一次一操作可以改变两个字符，所以 $ans/2$，相当于进行一操作。

## 代码及注释

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	char a[200005],b[200005];
	for(int i=1;i<=n;i++){
		char c;
		cin>>c;
		a[i]=c,b[i]=c;//将这个字符串复制两遍，便于比较 
	}
	sort(b+1,b+n+1);//默认就可以按字典序排序 
	int ans=0;//与想要得到的串中字符不一样的个数 
	for(int i=1;i<=n;i++){
		if(a[i]!=b[i])
			ans++;
	}
	cout<<ans/2;//虽然有ans个不一样的字符，但交换一次就可以改变两个 
	return 0;
}
```

---

## 作者：yinbe (赞：3)

### 题目描述

给定一个长为 $n$ 的字符串 $c$，记 $c$ 中的第 $i$ 个字符为 $c_i$（$1 \le i \le n$）。现在可以按任意顺序执行以下两个操作之一：

- 选择两个字符并交换它们；
- 选择一个字符并改变它。

请问：至少要进行多少次操作，才能使字符串中没有 `WR` 这个子串？

### 数据规模与约定

对于全部的输入数据，保证 $2 \le n \le 200000$ 且 $n$ 为整数，同时 $c_i$ 必为 `W` 或 `R` 中的一个。

---

### 思路

先分析题目，想让操作次数最少，我们就需要让一次操作减少的 `WR` 最多。

首先，因为最终的字符串没有 `WR` 这个子串，也就是说，`R` 一定是在 `W` 右边，所以最终的字符串一定是 `RRR`$\ldots$`WWW`，也就是按照字母顺序排序。

看一下 $1$ 操作，交换两个字符，这个操作一次能改变两个字符。

再看一下 $2$ 操作，改变一个字符，一次只能改变一个字符，没有 $1$ 操作更优，所以我们可以只进行 $1$ 操作，这样是一定是最优的。

时间复杂度为 $O(n \log _{2}n)$，空间复杂度 $O(n)$。

### 代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,cnt;
char c[200005],paixu[200005];
int main()
{
	scanf("%d",&n);
	cin>>(c+1);
	memcpy(paixu,c,sizeof(c));
	sort(paixu+1,paixu+n+1);
	for(int i=1;i<=n;i++)
	{
		if(paixu[i]!=c[i])
		{
			cnt++;
		}
	}
	printf("%d",cnt/2);//一次改变 2 个字符，操作数就是要改变的字符除 2
	return 0;
}
```

---

## 作者：sunqihuan (赞：2)

## [ABC174D] Alter Altar
题目大意:
给定一个只包含 $W$ 和 $R$ 的母串，

经过改变一个字符，

或交换一个字符，

使得没有 $\texttt{WR}$ 子串，

要使得没有 $\texttt{WR}$ 子串，只能把 $R$ 全部放在 $W$ 的前面。

设答案为 $\texttt{RRR...RWWW...W}$。

因为改变字符有三种情况:

靠近答案 $0$ 步 $1$ 步或 $2$ 步。

交换是靠近答案两步。

所以显然交换比改变要好。

所以全部交换，$R$ 的数量不变。

在样例 $3$ 中，第二项的 $R$ 是不用动的。

所以只需要统计不在答案范围内的 $R$。

## AC code

```
#include<bits/stdc++.h>
using namespace std;
int n;
string a; 
int main(){
	cin>>n>>a;
	bool flag=0;
	for(int i=0;i<n;i++){
		if(a[i]=='W' &&a[i+1]=='R'){
			flag=1;
			break;
		}
	}
	if(flag==0){
		cout<<0;
		return 0;
	}
	int s1=0,s2=0;
	for(int i=0;i<n;i++){
		if(a[i]=='R'){
			s1++;
		}
	}
	for(int i=0;i<s1;i++){
		if(a[i]=='R'){
			s2++;
		}
	}
	cout<<s1-s2;
	return 0;
}

```

---

## 作者：hjhAKIOI (赞：2)

# [ABC174D] Alter Altar题解

## 题目描述

给定一个长为 $n$ 的字符串 $c$，记 $c$ 中的第 $i$ 个字符为 $c_i（1 \le i \le n)$。现在可以按任意顺序执行以下两个操作之一：

- 选择两个字符并交换它们；
- 选择一个字符并改变它。

请问：至少要进行多少次操作，才能使字符串中没有`WR`这个子串？

数据范围： $1\le n \le 200000,c_{i}\in \left \{ W, R\right \}$ 

## 题意分析

题目的意思是给定一个字符串 $c$，可以通过交换两个字符、把一个字符 `R` 改成 `W` 或把一个字符 `W` 改成 `R` 让所有的 `R` 都在 `W` 的左边。也就是说，最后的字符串一定会是这个样子：

`RRRR...RWWWW...W`

## 做题思路

我们可以发现枚举操作是不好办的，并且数据范围也并不支持我们枚举操作。

但是根据上面的分析，我们可以看出最后的字符串是一堆连续的 `R`，随后一直到结尾都是 `W`。也就是说，最后的字符串中的 `R` 和 `W` 有一条**唯一的分界线，确定了分界线就可以确定最后的字符串的样子。**

所以，我们可以枚举分界线的位置。

那么，我们继续考虑确定最后的字符串的样子后，如何推出答案。

下面记分界线左边的 `W` 个数为 $x$，分界线右边的 `R` 个数为 $y$。

若 $x\le y$，则我们可以把分界线左边的 `W` 和分界线右边的 $x$ 个 `R` 交换，再把剩下的 $(y-x)$ 个 `W` 直接改成 `R`，共需 $x+(y-x)=y$ 次操作。

若 $x>y$，类似地，我们可以推出需要 $x$ 次操作。

综上所述，所需的**操作次数即为 $\max(x,y)$。**

也就是只要知道了分界线位置、分界线左边的 `W` 个数和分界线右边的 `R` 个数，我们就可以 $O(1)$ 的计算出操作次数。

那么现在问题转化为了如何快速的算出分界线左边的 `W` 个数和分界线右边的 `R` 个数。

这个问题的做法比较显然，只要提前预处理字符串的前缀 `W` 个数和后缀 `R` 个数。

最后，在枚举分界线的过程中取 $\max(x,y)$ 的最小值就行。

这样问题就解决了。

## 时间/空间复杂度分析

### 时间复杂度

我们需要 $O(n)$ 的时间复杂度来枚举分界线，同时，预处理字符串的前缀 `W` 个数和后缀 `R` 个数也是 $O(n)$ 的。

枚举分界线时的计算是 $O(1)$ 的，所以整个算法的时间复杂度为 $O(n)$，可以通过本题。

### 空间复杂度

预处理字符串的前缀 `W` 个数和后缀 `R` 个数需要长度为 $n$ 的两个数组，同时字符串长度为 $n$，所以空间复杂度也是 $O(n)$，可以通过本题。

## 实现细节

在枚举分界线时，要从 $0$ 开始，因为最后的字符串里可能只包含 `W`。

同时，要到 $n$ 结束。理由和上面是类似的。

除此之外，这题的实现是比较容易的。

---


至此，所有的问题都解决了。

下面给出本题的 AC 代码：

```cpp
#include<iostream>
using namespace std;
const int N=2e5+5,INF=1<<30;
int n,ans=INF;
int cntw[N],cntr[N];     //cntw为前缀W个数，cntr为后缀R个数
string s;

int main(){
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cntw[i]=cntw[i-1]+(s[i-1]=='W');
	}
	for(int i=n;i>=1;i--){
		cntr[i]=cntr[i+1]+(s[i-1]=='R');
	}
	for(int i=0;i<=n;i++){  //注意循环要从0开始，到n结束
		ans=min(ans,max(cntw[i],cntr[i+1]));
	}
	printf("%d",ans);
	return 0;
}
```

---


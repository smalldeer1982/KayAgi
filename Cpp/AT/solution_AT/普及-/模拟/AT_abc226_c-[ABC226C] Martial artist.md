# [ABC226C] Martial artist

## 题目描述

高桥君是一位武术大师，他可以学习 $N$ 种技能，这些技能分别标号为 $1, 2, \ldots, N$。要学习每个技能 $i$，他需要花费 $T_i$ 时间进行修炼，并且在开始时必须已掌握技能 $A_{i,1}, A_{i,2}, \ldots, A_{i,K_i}$。这里保证了，每个前置技能的编号小于当前技能编号，即 $A_{i,j} < i$。

在时刻 $0$，高桥君还没有掌握任何技能。他一次只能进行一个技能的修炼，并且一旦开始修炼，便不能中途停下。你的任务是计算出高桥君学习到技能 $N$ 所需的最短时间。

## 说明/提示

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq T_i \leq 10^9$
- $0 \leq K_i < i$
- $1 \leq A_{i,j} < i$
- $\sum_{i=1}^N K_i \leq 2 \times 10^5$
- $A_{i,1}, A_{i,2}, \ldots, A_{i,K_i}$ 全部互不相同。
- 所有输入均为整数。

### 示例 1
高桥君可以采取这样的修习顺序：
- 他在时刻 $0$ 开始学习技能 $1$，到时刻 $3$ 时掌握此技能。
- 然后，从时刻 $3$ 开始修炼技能 $3$，到时刻 $10$ 时学会此技能。
这样一来，高桥君学习到技能 $3$ 的最短时间为 $3 + 7 = 10$。在这过程中，他不需要掌握技能 $2$。

### 提示 2
请注意，答案可能超过 $32$ 位整数的范围。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
3 0
5 1 1
7 1 1```

### 输出

```
10```

## 样例 #2

### 输入

```
5
1000000000 0
1000000000 0
1000000000 0
1000000000 0
1000000000 4 1 2 3 4```

### 输出

```
5000000000```

# 题解

## 作者：loser_seele (赞：0)

题意：给出若干项任务，每项任务有前置任务和执行时间，只有执行完全部前置任务才能做这个任务，求执行 $ N $ 的最短用时。

首先按题意建图，然后贪心找到当前没有任何前置任务的任务直接执行，之后更新前置任务列表即可。

因为题目保证了每个任务的前置任务都是之前的任务，所以考虑反向建图之后从 $ N $ 开始进行拓扑排序，最后累加答案即可。

时间复杂度为 $ \mathcal{O}(m) $，其中 $ m \leq 5 \times 10^5 $ 为总边数，可以通过。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int va[200020],learn[200020];
int ans=0;
vector<int>fa[200020];
void dfs(int n)
{
for(int i=0;i<fa[n].size();i++)
if(!learn[fa[n][i]])
{
ans+=va[fa[n][i]];
learn[fa[n][i]]=1;
dfs(fa[n][i]);
}
}
signed main()
{
ios::sync_with_stdio(0);
int n;
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>va[i];
int l;
cin>>l;
for(int j=1;j<=l;j++)
{
int tmp;
cin>>tmp;
fa[i].push_back(tmp);
}
}
ans=va[n];
dfs(n);
cout<<ans;
}
```


---


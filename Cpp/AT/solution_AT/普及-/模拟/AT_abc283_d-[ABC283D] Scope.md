# [ABC283D] Scope

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc283/tasks/abc283_d

英小文字、`(`、`)` からなる文字列のうち、以下の手順によって空文字列になるものを**良い文字列**と呼びます:

- まず、英小文字をすべて削除する。
- 次に、連続する `()` が存在する限り、それを削除する。
 
例えば、`((a)ba)` は英小文字をすべて削除すると `(())` となり、$ 2 $ 文字目と $ 3 $ 文字目に連続する `()` を削除すると `()` となり、最終的に空文字列にすることができるので良い文字列です。

良い文字列 $ S $ が与えられます。 $ S $ の $ i $ 文字目を $ S_i $ で表します。

各英小文字 `a` , `b` , $ \ldots $ , `z` に対して、その文字が書かれたボールが $ 1 $ つあります。 また、空の箱があります。

高橋君は $ i\ =\ 1,2, $ $ \ldots $ $ ,|S| $ に対してこの順に気を失わない限り操作を行います。

- $ S_i $ が英小文字ならば、その英小文字が書かれたボールを箱に入れる。ただし、そのボールがすでに箱に入っている場合、高橋君は気を失う。
- $ S_i $ が `(` ならば、何もしない。
- $ S_i $ が `)` ならば、$ i $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ i $ 番目までの文字からなる文字列が良い文字列となる最大の整数 $ j $ を取る。（このような整数 $ j $ は必ず存在することが証明できる。）$ j $ 番目から $ i $ 番目までの操作で箱に入れたボールをすべて、箱から取り出す。
 
高橋君が気を失わずに一連の操作を完了させられるか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 3\ \times\ 10^5 $
- $ S $ は良い文字列
 
### Sample Explanation 1

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は何もしません。 $ i\ =\ 3 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 4 $ のとき、$ 4 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 4 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 2 $ であるため、高橋君は `a` の書かれたボールを箱から取り出します。 $ i\ =\ 5 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 6 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 7 $ のとき、$ 7 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 7 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 1 $ であるため、高橋君は `a` の書かれたボールと `b` の書かれたボールを箱から取り出します。 したがってこの場合の答えは `Yes` となります。

### Sample Explanation 2

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 3 $ のとき、高橋君は何もしません。 $ i\ =\ 4 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 5 $ のとき、`a` の書かれたボールはすでに箱に入っているため、高橋君は気を失い、これ以降の操作は行われません。 したがってこの場合の答えは `No` となります。

## 样例 #1

### 输入

```
((a)ba)```

### 输出

```
Yes```

## 样例 #2

### 输入

```
(a(ba))```

### 输出

```
No```

## 样例 #3

### 输入

```
(((())))```

### 输出

```
Yes```

## 样例 #4

### 输入

```
abca```

### 输出

```
No```

# 题解

## 作者：szhqwq (赞：6)

## 分析

使用一个标记数组 $st_i$ 来记录这个小写字母是在几重括号中被标记的，用一个变量 $cnt$ 来表示当前是第几重括号，那么会有 $3$ 种情况：

1. 当前遍历到的字符为 `(`，则 $cnt$ 增加 $1$，增加一重括号；
2. 当前遍历到了小写字母，如果 $st_{s_i - 'a'} = 0$,则 $st_{s_i - 'a'} = cnt$，反之直接输出 `No`；
3. 当前遍历到的字符为 `)`，则此时，遍历整个标记数组，如果 $st_j = cnt$，则将 $st_j = 0$，再减少一重括号。

如果最后都没有输出 `No`，则输出 `Yes`。

**注意**：$cnt$ 初始赋值应赋为 $1$，否则赋为 $0$ 的话，则与没有标记是同一回事了。~~我就因为如此吃了一发罚时~~

AC code

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 30;

string s;
int st[N];

signed main() {
	cin >> s;
	int cnt = 1;
	memset(st,false,sizeof st);
	for (int i = 0; i < s.size(); i ++ ) {
		if (s[i] == '(') {
			cnt ++;
		} else if (s[i] >= 'a' && s[i] <= 'z') {
			if (st[s[i] - 'a']) {
				puts("No");
				return 0;
			} else st[s[i] - 'a'] = cnt;
		} else if (s[i] == ')') {
			for (int j = 0; j < 26; j ++ ) if (st[j] == cnt) st[j] = false;
			cnt --;
		}
	}
	cout << "Yes" << endl;
	return 0;
}
```
$$Thanks$$

---

## 作者：_dijkstra_ (赞：3)

提供一种比较暴力的方法。

## 思路

首先，对于右括号，最远的可以与之匹配的左括号，其实**只能是距离它最近的左括号**。

因为类似于括号序列的匹配，如果它往更远的地方配，那么就不是一个好的字符串了。

所以，我们按照平时匹配括号的思想，遇到左括号就往栈里压，遇到右括号就匹配，并把对应区间内的字符的计数器清空。

这里的代码（会超时）：

```cpp
int a[100005], cnt[30];
void solve()
{
	string s;
	cin >> s;
	int n = s.length();
	stack <int> stk; //左括号
	for (int i = 0; i < n; i++)
		if (s[i] == '(') stk.push(i);
		else if (s[i] == ')')
		{
			for (int j = stk.top(); j <= i; j++)
				if ('a' <= s[j] && s[j] <= 'z')
					cnt[s[j] - 'a']--;
			stk.pop();
		}
		else
		{
			if (cnt[s[i] - 'a'] >= 1) {puts("No"); return;}
			cnt[s[i] - 'a']++;
		}
	puts("Yes");
}
```

我们考虑优化。其实办法有很多种，这里我使用一种很暴力的方法：

我们原本是记录 $cnt_k$，现在我们记录 $cnt_{i, k}$，也就是再记录了匹配到第 $i$ 位时的 $cnt$ 变化。

那么，我们就不需要像上面那样暴力删除了，我们只需要把 $cnt_i$ 回溯到对应的位置即可。

## 正确代码

```cpp
int cnt[300005][30];
void solve()
{
	string s;
	cin >> s;
	int n = s.length();
	s = '%' + s;
	stack <int> stk; //左括号
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j < 26; j++) cnt[i][j] = cnt[i - 1][j];
		if (s[i] == '(') stk.push(i);
		else if (s[i] == ')')
		{
			for (int j = 0; j < 26; j++) cnt[i][j] = cnt[stk.top()][j];
			stk.pop();
		}
		else
		{
			if (cnt[i][s[i] - 'a'] >= 1) {puts("No"); return;}
			cnt[i][s[i] - 'a']++;
		}
	}
	puts("Yes");
}
```

---

## 作者：NightStriker (赞：3)

$\large {\texttt{Algorithm u need to know}}$

`std::map`、`std::stack`、桶、~~以及语文阅读能力~~。

建议评黄。

---

$\Large {\texttt{Problem Statement}}$

> 如果你能通过以下程序使一个由小写英文字母、`(`、`)`组成的字符串成为一个空字符串，就可以说它是一个好字符串。
>
> 首先，删除所有小写英文字母。
> 然后，在可能的情况下反复删除连续的 `()`。
>
> 现在给你一个好字符串 $s$，对于每个小写英文字母 $a-z$，我们有一个球，上面写着这个字母。此外，我们还有一个空盒子。
>
> - 如果 $s_i$ 是一个小写的英文字母，把写有该字母的球放进盒子里，如果盒子里已经有了对应字母的球，他就会停止判断。
> - 如果 $s_i$ 是 `(`，就什么都不做。
> - 如果 $s_i$ 是 `)`，取一个小于 $i$ 的最大整数 $j$，使 $s$ 的第 $j$ 个到第 $i$个字符形成一个好的字符串。然后从盒子里取出他放在第 $j$ 到第 $i$ 个字符的所有的字母球。
>   试问高桥能不能遍历完整个字符串。

---

$\Large {\texttt{Data Range}}$

$1 \le |s| \le 3 \times 10^5$

很明显，我们不能使用 $\mathcal{O}(n^3)$ 的暴力或者是 $\mathcal{O}(n^2)$ 的栈模拟来切掉本题。需要 $\mathcal{O}(n\log n)$ 或者是 $\mathcal{O}(n)$ 的算法来通过本题。

---

$\Large {\texttt{Solution}}$

考虑先用 `std::map ` 把**右括号所对应的左括号**都预处理打上标记，中间可以使用栈来匹配括号：碰到左括号就塞进去，碰到右括号就弹出最顶端的左括号，表示已经匹配过了。

然后按题意把整个字符串给扫一遍，中间开个字符桶，表示那个盒子里的球有没有被装进去。如果已经装进去了还要装，就结束程序，输出 $\texttt{No}$。

如果是左括号就啥也不用管。

如果是右括号，可以证明，对于一个右括号 $s_i$，$j$ 一定为所匹配的左括号 $s_j$。所以我们就可以在 $\mathcal{O}(\log n)$ 的时间复杂度内解决这个右括号匹配 $j$ 的问题。

然后就把 $j$ 到 $i$ 的所有字符的标记都清除就可以了。

最后如果都没有问题，就输出 $\texttt{Yes}$。

复杂度有点玄学， $\mathcal{O}(n \log^2 n)$ 左右。

---

$\Large {\texttt{\color{green}{AC} \color{black}{code}}}$

```cpp
#include<bits/stdc++.h> 
using namespace std;
string s;
map<char,bool>box;//字符盒子
map<int,int>pas;//右括号对应的左括号
stack<int>tmp;//匹配括号的栈
int main() {
	cin>>s;
	for (int i = 0; i<s.size(); i++) {
		if (s[i]=='(') tmp.push(i);
		else if (s[i]==')') {
			pas[i] = tmp.top();
			tmp.pop();
		}
	} 
	int w = s.size();
	for (int i = 0; i<s.size(); i++) {
		if (s[i]=='(') continue;//左括号跳过
		else if (islower(s[i])){//字母就判断一下有没有被标记过
			if (box[s[i]]) {
				cout<<"No"<<endl;//不可以，总司令！
				return 0;
			}
			box[s[i]] = 1;
		} else {//如果是右括号
			int j = pas[i];//对应的左括号
			for (int k = j; k<=min(i,w); k++)//清除标记
				if (islower(s[k])) box[s[k]] = 0;
			w = j;
		}
	}
	cout<<"Yes"<<endl;
	return 0;
}
```

借我的题解保佑我切掉 ABC284 D。 

---

## 作者：MiddleRed (赞：2)

## Discription  
给定一个由括号和小写字母组成的字符串 $S$ ，字符串有合法的括号匹配。现在给你一个盒子，对字符串进行顺序遍历，并同时执行以下操作，判断最后是否能顺利完成所有操作：  
1. 如果 $S_i$ 为小写字母，则把这个字母放到盒子中。如果这个字母已经在了盒子中，则操作失败。
2. 如果 $S_i$ 为 `)` ，则不进行任何操作。
3. 如果 $S_i$ 为 `(` ，则找到距离 $S_i$ 最近的字符 `(` ，并把这两个括号之间的子字符串的所有字母从盒子中拿出来。

## Solution  
本质就是一个括号匹配多了一些背景，不改变这是道栈入门题的本质。  
思路和括号匹配一样，顺序遍历字符串，将字符串中每个不是 `)` 的字符压入栈中，并且用一个布尔数组代表各个小写字母是否已经在盒子中。当读入 `)` ，就一直出栈，同时修改字母在盒子中的存在情况，直到遇到结束的 `(` 。如果能顺利遍历整个字符串且没有遇到失败情况，则成功。  
思维量实际只有 ABC 的 C 题。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int idx=0,i;
char st[300010],c;
bool alp[26];
int main()
{
	while((c=getchar())!='\n')
	{
		if(c=='(')
		{
			st[idx++]='(';
		}
		else if(c>='a' and c<='z')
		{
			if(alp[c-'a'])
			{
				cout<<"No";
				return 0;
			}
			alp[c-'a']=1;
			st[idx++]=c;
		}
		else if(c==')')
		{
			for(i=idx-1;;i--)
			{
				if(st[i]=='(')
				{
					idx=i;
					break;
				}
				alp[st[i]-'a']=0;
			}
		}
	}
	cout<<"Yes";
}
```
---
#### 22/12/29 Upd: 修复了代码问题，评论区 Hack 数据通过

---

## 作者：StayAlone (赞：2)

### 题意

定义好串是满足以下两个条件的串：

- 仅包含小写字母和小括号；

- 去除其中的所有字母之后，括号序列是匹配的。

给定一个好串，现在你有一个空盒子，从左往右完成操作：

- 如果当前字符是字母，且盒子里有这个字母，你会晕倒，否则向盒子里放入这个字母；

- 如果当前字符是 `(`，什么都不做；

- 如果当前字符是 `)`，你需要找到最大的 $j$ 满足 $j$ 到当前位置组成的子串是好串，并且拿出在这段时间放入盒子的字母。可以证明 $j$ 总是存在。

如果操作结束没有晕倒，输出 `Yes`，否则输出 `No`。

### 思路

可以先找到所有有括号对应的左括号，那么显然满足条件最大的 $j$ 就是对应的左括号的位置。因此用一个 stack 模拟放入的字母，同时带上这个字母的位置，对于操作 3 直接模拟即可。由于每个位置只会被删除一次，时间复杂度 $\Theta(n)$。

```cpp
char s[MAXN]; int n;
int maxp[MAXN];
stack <pair <int, char> > box;
bool vis[300];

int main() {
	scanf("%s", s + 1); n = strlen(s + 1);
	stack <int> st;
	rep1(i, 1, n) {
		if (s[i] == '(') st.emplace(i);
		else if (s[i] == ')') maxp[i] = st.top(), st.pop();
	}
	rep1(i, 1, n) {
		if (s[i] == '(') continue;
		if (isalpha(s[i])) {
			if (vis[s[i]]) return puts("No"), 0;
			box.emplace(i, s[i]); vis[s[i]] = true;
		} else {
			int p = maxp[i];
			while (box.size() && box.top().fst >= p) {
				vis[box.top().snd] = false; box.pop();
			}
		}
	} puts("Yes");
	rout;
}
```

---

## 作者：FQR_ (赞：2)

## 思路

这道题，我们只需模拟整个取球的过程即可。但是，其中有几个细节需要处理。

如果 $S_i$ 为`)`，不难想到，选取的整数 $j$，$S_j$ 一定是`(`。反证法易证。

并且，一个“好字符串”的`(`和`)`的数量是相等的。所以，$S_i$ 到 $S_j$ 之间`(`和`)`的数量相等。

这样，我们就可以得到一个结论：

假设有一个变量 $cnt$，初始值为 $0$。如果 $S_k$ 为`(`，就将 $cnt$ 增加 $1$，并将 $k$ 对应的值设置为 $cnt$。如果 $S_k$ 为`）`，就将 $k$ 对应的值设置为 $cnt$，并将 $cnt$ 增加 $1$。

因为 $S_i$ 到 $S_j$ 之间`(`和`)`的数量相等，所以 $i$ 和 $j$ 的对应值都相等。这样，我们就可以 $O(n)$ 求出所有`)`对应的整数 $j$。


---

在模拟过程中，设置一个 map：`map<char,int> mp`，其中 $mp_c$（$c$ 为一个小写字母）表示 $c$ 上一次出现的位置。如果盒子里没有 $c$ 球，则值为 $0$。

当 $S_i$ 为`(`时，什么也不做。

当 $S_i$ 为字母时，判断 $mp_{S_i}$ 是否为 $0$。如果不为 $0$，直接输出`No`，否则将 $mp_{S_i}$ 的值设为 $i$。

当 $S_i$ 为`)`时，找到整数 $j$，遍历每个字母，判断这个字母上次出现的位置是否在 $[j,i]$ 之间。如果在，就把 $mp_{S_i}$ 的值设为 $0$。

遍历完整个字符串后，如果没有输出`No`，就输出`Yes`。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int start[3000010];//如果s[i]是“)”，则k[i]为它所对应的j的值
int k[3000010];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	map<char,int> mp;
	string s;cin>>s;
	s.insert(s.begin(),' ');//将字符串向后移动一位，使它从1开始，便于处理
	int cnt=0;
	for(int i=1;i<s.size();i++) 
	{
		if(s[i]=='(') cnt++,k[cnt]=i;//记录当前cnt下“(”的位置
		else if(s[i]==')') start[i]=k[cnt],cnt--;//i与j对应的cnt值相等，将i对应的整数j设为k[cnt]
	}
	
	
	for(int i=1;i<s.size();i++) 
	{
		if(s[i]>='a'&&s[i]<='z')
		{
			if(mp[s[i]]) return cout<<"No",0;//此时盒子内有s[i]小球，直接输出No
			mp[s[i]]=i;//标记s[i]出现的位置
		}
		else if(s[i]==')')
		{
			for(char j='a';j<='z';j++) 
				if(mp[j]>start[i]) mp[j]=0;//如果上一次出现的位置在范围内，就将小球取出
		}
	}
	cout<<"Yes";
	
	return 0; 
}

```

---

## 作者：zajasi (赞：1)

## 题意
对于每一次操作：
* 如果是字母，看序列来有没有一样的字母，有的话输出 `No`。

* 如果是左括号，什么也不用干。

* 如果是右括号，找以当前位置 $r$ 结束的好的字符串长度最小的开头 $l$，将 $l$ ~ $r$ 之间扔进去的所有字母拿出来。

定义好的字符串：将所有字符删去后，括号匹配的字符串。
## 解题思路
规定左括号为 $1$，右括号为 $-1$。

维护一个变量 $x$，记录当前的值。

对于每个左括号，记录当前的位置。

对于每一个字符，记录当前的字符和位置。

对于每一个右括号，此时 $x$ 的值是多少，就是匹配第几个左括号。然后删除在第 $x$ 个左括号到当前位置之间的所有字符。

删除字符的操作该怎么做呢？前面已经记录过字符和位置，只要跑一遍 `lower_bound` 和一遍 `upper_bound`，然后删除这之间的所有字符就行啦。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ugly 1145141919810
string a;
int h[27];
vector<int> v;
int x;
vector<int> s1,s2;
main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>a;
	for(int i=0;i<a.size();i++){
		if(a[i]=='('){	
			x++;
			v.push_back(i);
		}
		else if(a[i]==')'){
			x--;
			int y=v[x];
			int l1=lower_bound(s2.begin(),s2.end(),y)-s2.begin();
			int l2=upper_bound(s2.begin(),s2.end(),i)-s2.begin();
			l2--;//注意要减1，不然的话会超过范围
			for(int j=l1;j<=l2;j++){
				h[s1[j]]=0;
			}
			s1.erase(s1.begin()+l1,s1.begin()+l2+1);
			s2.erase(s2.begin()+l1,s2.begin()+l2+1);
		}
		else{
			s1.push_back(a[i]-'a'+1);
			s2.push_back(i);
			if(h[a[i]-'a'+1]){
				cout<<"No";
				return 0;
			}
			h[a[i]-'a'+1]=1;

		}
	}
	cout<<"Yes";
	return 0;

}
```


---

## 作者：zfx_VeXl6 (赞：0)

用一个栈存下 `(` 的位置。栈顶元素即为最近且未被配对的 `(` 的位置。

遍历字符串。

碰到 `(`，把它的位置进栈。

碰到字母，如果这个字母未出现，把它标记为已出现，否则输出 `No` 并退出程序。

碰到 `)`，从栈中取出最近且未配对的 `(` 的位置，然后把这对括号中间的字母全部标记为未出现，最后删除这一对括号以及它们之间的所有字母，字符串长度和循环变量也要改变，见代码。经过删除，可以保证下一对括号之间只有字母。

如果没有在循环中退出，输出 `Yes`。

这题因为数据问题让某些人变成 unrated，但是这种做法可以 AC。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int n, vs[1000];
stack<int> p;
int main()
{
    cin >> s;
    n = s.size();
    for (int i = 0; i < n; i++)
    {
        if (s[i] == '(')
            p.push(i);
        else if (s[i] == ')')
        {
            int tp = p.top();
            p.pop();
            n -= i - tp + 1;
            for (int j = tp + 1; j < i; j++)
                vs[s[j]] = 0;
            s.erase(tp, i - tp + 1);
            i = tp - 1;
        }
        else if (vs[s[i]])
        {
            cout << "No";
            return 0;
        }
        else
            vs[s[i]] = 1;
    }
    cout << "Yes";
    return 0;
}
```

---

## 作者：FyFive (赞：0)

>给定一个插有小写字母的合法括号字符串，从左到右扫描字符串
>- 如果遇到 ``(`` 就什么都不做
>- 如果遇到 ``)`` 就向前找到最远能匹配这个右括号的左括号，并将括号内的所有小写字母的值赋为 0
>- 如果遇到小写字母，若这个字母值为 1，就中止并输出 ``No``，否则将这个字母的值赋为 1 并继续向后扫。

此题最大的难点在于日语的翻译。

在得知题意之后，我们可以直接读入字符串，并从左往右模拟操作。

开一个 $0/1$ 桶存储二十六个小写字母的值，碰到小写字母就直接操作，碰到 ``(`` 直接无视。

如果碰到了 ``)``，则考虑向前找需要操作哪些小写字母。

考虑向前找到匹配的 ``(``。可以证明原题面所说最远的同级的 ``(`` 可以直接优化到最近的同级的 ``(``，向前匹配的过程中，扫到的所有小写字母全部赋为 0。

复杂度 $O(n^2)$，大概率是跑不过 $|S|\leq 3 \times 10^5$ 的。

考虑优化，一个非常基础的优化方案是右括号向前匹配的时候扫一个删一个，保证不会出现同一个字符被多次扫描的情况，在忽略 string 自带的  ``erase()`` 函数带来的影响后，时间复杂度是 $O(n)$ 的。

如果拿链表维护字符串的话，应该可以严格线性。

核心 Code：
```cpp
bool check()
{
    for(int i=0;i<s.size();++i)
    {
        if(s[i]=='(') ;
        else if(s[i]==')')
        {
            while(s[i]!='('){yt[s[i]]=false; s.erase(s.begin()+i); i--;}
            s.erase(s.begin()+i);i--;
        }
        else{ if(yt[s[i]]) return false; else yt[s[i]]=true;}
    }
    return true;
}
```

建议加上标签：模拟

---


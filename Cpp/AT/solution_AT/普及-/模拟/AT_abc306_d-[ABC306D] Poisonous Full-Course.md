# [ABC306D] Poisonous Full-Course

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc306/tasks/abc306_d

高橋くんはレストランで、 $ N $ 品からなる奇妙なフルコースを楽しむことにしました。  
 このコースのうち $ i $ 番目の料理は以下の通りです。

- $ X_i=0 $ の場合、美味しさが $ Y_i $ の **解毒剤入り** の料理
- $ X_i=1 $ の場合、美味しさが $ Y_i $ の **毒入り** の料理
 
高橋くんが料理を食べると、高橋くんの状態は以下のように変化します。

- 最初、高橋くんはお腹を壊していない。
- 高橋くんが **お腹を壊していない** 時、
  - **解毒剤入り** の料理を食べても、高橋くんは **お腹を壊していないまま** である。
  - **毒入り** の料理を食べると、高橋くんは **お腹を壊す** 。
- 高橋くんが **お腹を壊している** 時、
  - **解毒剤入り** の料理を食べると、高橋くんは **お腹を壊していない状態になる** 。
  - **毒入り** の料理を食べると、高橋くんは **死ぬ** 。
 
コースは以下の流れで進行します。

- $ i\ =\ 1,\ \ldots,\ N $ についてこの順に、以下の処理を繰り返す。
  - まず、 $ i $ 番目の料理が高橋くんに提供される。
  - 次に、 高橋くんはこの料理に対し「食べる」か「下げてもらう」かを選択する。
      - 「食べる」を選択した場合、高橋くんは $ i $ 番目の料理を食べる。食べた料理に応じて高橋くんの状態も変化する。
      - 「下げてもらう」を選択した場合、高橋くんは $ i $ 番目の料理を食べない。この料理を後で提供してもらったり何らかの手段で保存したりすることはできない。
  - 最後に、 (状態が変化するなら変化後の時点で) 高橋くんが死んでいない場合、
      - $ i\ \neq\ N $ なら次の料理に進む。
      - $ i\ =\ N $ なら高橋くんは生きて退店する。
 
高橋くんはこのあと重要な仕事があるため、高橋くんは生きて退店しなければなりません。  
 この条件の下で高橋くんが各料理に対し「食べる」「下げてもらう」を選択したとき、高橋くんが **食べた料理の美味しさの総和として考えられる最大値** ( 但し、何も食べなかった場合は $ 0 $ ) を出力してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ X_i\ \in\ \{0,1\} $
  - つまり、 $ X_i $ は $ 0,1 $ のどちらかである。
- $ -10^9\ \le\ Y_i\ \le\ 10^9 $
 
### Sample Explanation 1

以下のように選択することで食べた料理の美味しさの総和を $ 600 $ にでき、これが考えられる最大値です。 - $ 1 $ 番目の料理を下げてもらう。高橋くんはお腹を壊していません。 - $ 2 $ 番目の料理を食べる。高橋くんはお腹を壊し、食べた料理の美味しさの総和は $ 300 $ となります。 - $ 3 $ 番目の料理を食べる。高橋くんはお腹を壊していない状態に戻り、食べた料理の美味しさの総和は $ 100 $ となります。 - $ 4 $ 番目の料理を食べる。高橋くんはお腹を壊し、食べた料理の美味しさの総和は $ 600 $ となります。 - $ 5 $ 番目の料理を下げてもらう。高橋くんはお腹を壊しています。 - 最終的に高橋くんは死んでいないので、高橋くんは生きて退店する。

### Sample Explanation 2

この入力の場合何も食べないことが最善ですが、この場合答えは $ 0 $ となります。

### Sample Explanation 3

答えが $ 32 $ bit 符号付き整数に収まらない可能性があります。

## 样例 #1

### 输入

```
5
1 100
1 300
0 -200
1 500
1 300```

### 输出

```
600```

## 样例 #2

### 输入

```
4
0 -1
1 -2
0 -3
1 -4```

### 输出

```
0```

## 样例 #3

### 输入

```
15
1 900000000
0 600000000
1 -300000000
0 -700000000
1 200000000
1 300000000
0 -600000000
1 -900000000
1 600000000
1 -100000000
1 -400000000
0 900000000
0 200000000
1 -500000000
1 900000000```

### 输出

```
4100000000```

# 题解

## 作者：c1ampy (赞：10)

## 算法选择

本题可以使用动态规划解题。

为什么选择动态规划算法解决本题？

动态规划问题的三要素为：**阶段**、**状态**、**决策**。而这三个要素在本题的题面中已经有了较为明显的暗示：

- 菜是一道一道上的，这自然地将用餐流程划分成了不同**阶段**。
- 高桥君的身体状况有好有坏，这可以作为动态规划算法设计的**状态**。
- 对于每道菜，高桥君都要做出品尝或跳过的**决策**。

看懂了这些暗示，自然而然就会想到动态规划算法解决本题。

## 动态规划算法设计

设 $ dp[i][j] (i \in [1, N], j \in \{0, 1\}) $ 的含义如下：

- $ dp[i][0] $ 表示在对第 $ i $ 道菜做出决策后，高桥君感到舒适，此时他所品尝的菜肴的美味程度之和的最大值。
- $ dp[i][1] $ 表示在对第 $ i $ 道菜做出决策后，高桥君感到不适，此时他所品尝的菜肴的美味程度之和的最大值。

不难设计出状态转移方程：

- 当 $ X_i = 0 $ 时，
    - 如果高桥君在对这道菜做出选择后感到舒适，有以下三种情况：
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择跳过这道菜。
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择品尝这道菜。
        - 在这道菜上菜之前，高桥君感到不适，而且他选择品尝这道菜。
    - 综合上述三种情况，可以得出状态转移方程：
    $$
    dp[i][0] = \max\{dp[i - 1][0], dp[i - 1][0] + Y_i, dp[i - 1][1] + Y_i \}
    $$
    - 如果高桥君在对这道菜做出选择后感到不适，只有一种情况：
        - 在这道菜上菜之前，高桥君感到不适，而且他选择跳过这道菜。
    - 故状态转移方程为：
    $$
    dp[i][1] = dp[i - 1][1]
    $$
- 当 $ X_i = 1 $ 时，
    - 如果高桥君在对这道菜做出选择后感到舒适，只有一种情况：
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择跳过这道菜。
    - 故状态转移方程为：
    $$
    dp[i][0] = dp[i - 1][0]
    $$
    - 如果高桥君在对这道菜做出选择后感到不适，有以下两种情况：
        - 在这道菜上菜之前，高桥君感到不适，而且他选择跳过这道菜。
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择品尝这道菜。
    - 综合上述两种情况，可以得出状态转移方程：
    $$
    dp[i][1] = \max\{ dp[i - 1][1], dp[i - 1][0] + Y_i \}
    $$

起初，高桥君什么也没吃，故边界条件为：
$$
dp[0][0] = dp[0][1] = 0
$$

在高桥君对所有 $ N $ 道菜都做出选择后，我们也得到了最终答案：
$$
ans = \max\{ dp[N][0], dp[N][1] \}
$$

时间复杂度与空间复杂度均为 $ \mathcal{O}(N) $，足以通过。

根据以上分析，不难写出程序。

## 进一步优化

从上面的状态转移方程可以看出，一个阶段的答案仅需从上一个阶段的答案推出，故我们可以使用滚动数组技巧，对空间复杂度进行优化。

将上面的 $ dp[i][0] $ 改为 $ healthy $，将 $ dp[i][1] $ 改为 $ upset $，新的状态转移方程如下：

- 当 $ X_i = 0 $ 时，
    - $ healthy = \max\{ healthy, \max\{ upset, healthy \} + Y_i \} $
    - $ upset $ 无需更新。
- 当 $ X_i = 1 $ 时，
    - $ healthy $ 无需更新。
    - $ upset = \max\{ upset, healthy + Y_i \} $

边界条件为：
$$
healthy = upset = 0
$$

最终答案为：
$$
ans = \max\{ healthy, upset \}
$$

时间复杂度仍为 $ \mathcal{O}(N) $，但是空间复杂度已经被优化到了 $ \mathcal{O}(1) $。

## 代码

这里仅给出滚动数组优化后的代码。

```cpp
#include <iostream>
using namespace std;

int main() {

    long long healthy = 0, upset = 0;
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        long long type, tastiness;
        scanf("%lld %lld", &type, &tastiness);
        if (type) {
            upset = max(upset, healthy + tastiness);
        }
        else {
            healthy = max(healthy, max(upset, healthy) + tastiness);
        }
    }

    printf("%lld\n", max(upset, healthy));

    return 0;
}
```


---

## 作者：hellolin (赞：1)

## AtCoder Beginner Contest 306 - D - Poisonous Full-Course

[洛谷题面](https://www.luogu.com.cn/problem/AT_abc306_d) | [AtCoder 题面](https://atcoder.jp/contests/abc306/tasks/abc306_d)

注意到题目中说只能选择吃不吃，而不是选择顺序，所以可以用 dp 来解决。

很经典的 01 背包。

二维 dp，第一维是菜品编号，第二维是 $0$ 或 $1$ 表示健康或中毒状态。

转移（$y$ 表示当前菜品美味值）：

**若当前菜品解毒**

选择吃菜，那么可以从有毒的状态转移到无毒，也可以从无毒的状态转移到无毒。

选择不吃，那么可以从有毒的状态转移到有毒，也可以从无毒的状态转移到无毒。

$$f_{i, 0} = \max(f_{i-1, 0}+y,\ f_{i-1, 0},\ f_{i-1, 1}+y)$$
$$f_{i, 1} = f_{i-1, 1}$$

**若当前菜品有毒**

选择吃菜，那么可以从无毒的状态转移到有毒。

选择不吃，那么可以从有毒的状态转移到有毒，也可以从无毒的状态转移到无毒。

$$f_{i, 0} = f_{i-1, 0}$$
$$f_{i, 1} = \max(f_{i-1, 0}+y,\ f_{i-1, 1})$$

``` cpp
// 珍爱账号，请勿贺题
#include <bits/stdc++.h>
using namespace std;
#define int long long

constexpr static int N=3e5+11;
int n;
bool x;
int y;
int dp[N][2];
void solve(){
    cin >> n;
    for(int i=1; i<=n; i++){
        cin >> x >> y;
        if(!x) {
            dp[i][0]=max({dp[i-1][0]+y,dp[i-1][0],dp[i-1][1]+y});
            dp[i][1]=dp[i-1][1];
        } else {
            dp[i][0]=dp[i-1][0];
            dp[i][1]=max({dp[i-1][0]+y,dp[i-1][1]});
        }
    }
    cout << max(dp[n][0], dp[n][1]) << endl;
}

int32_t main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    solve();

    return 0;
}
```

---

## 作者：_7Mr (赞：1)

# 题目大意
Takahashi 在一家餐厅享用一顿由 $N$ 道菜组成的特别菜单。

第 $i$ 道菜有以下定义。

- 如果 $X_i=0$，那么是一道有着 $Y_i$ 美味度的解毒菜。
- 如果 $X_i=1$，那么是一道有着 $Y_i$ 美味度的有毒菜。 

当 Takahashi 吃一道菜时，他的状态会发生以下变化。

初始状态下，Takahashi 的胃很健康。
>当他的胃很健康时，如果他吃了一道解毒菜，他的胃仍然很健康。如果他吃了一道有毒菜，他的胃会不舒服。

>当他的胃不舒服时，如果他吃了一道解毒菜，他的胃会变得健康。如果他吃了一道有毒菜，他会死亡。

就餐时按照顺序重复以下过程，对于 $i=1,2,3,\dots N$。
首先，第 $i$ 道菜被端到 Takahashi 面前。
然后，他选择是否“吃下”或“跳过”这道菜。
- 如果他选择“吃下”，他会吃掉第 $i$ 道菜。
- 如果他选择“跳过”，他不会吃掉第 $i$ 道菜。

**他的状态也会根据所吃的菜而改变。**

求进行 $N$ 轮后，没有死亡的 Takahashi 能吃到的最大美味值。
# 思路
这道题一眼就可以看出来使用动态规划。

对于每道菜我们有选或不选两种情况自然想到 01 做法。

我们定义 $dp_{i,j}$ 其中 $i$ 表示当前胃是否健康，健康为 $0$，不健康为 $1$。$j$ 表示在第 $j$ 道菜时，最大美味和。

我们分情况，分类讨论。

如果是解药。那么 $dp_{0,j}$ 就有三种情况。
- 不选，即 $dp_{0,j}=dp_{0,j-1}$。
- 选，并且胃是健康的，上一个的最大美味和加上当前的美味和，即 $dp_{0,j}=dp_{0,j-1}+y_i$。
- 选，并且胃是不健康的，上一个的最大美味和加上当前的美味和，即 $dp_{0,j}=dp_{1,j-1}+y_i$。

$dp_{1,j}$ 不变，因为是当前解药，选就是上面的最后一种情况，不选，就等于前面的。即 $dp_{1,j}=dp_{1,j-1}$。

最后 $dp_{0,j}$ 就是我们取这三种情况的最大值。

如果是毒药，同理，需要注意的一点，如果胃是不健康的那么不能再选了，因为再选就会死亡。

最后答案就是最后一个胃健康，胃不健康的最大值。即 $\max(dp_{0,n},dp_{1,n})$。
# ACcode
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3fff
using namespace std;
const int maxn=3e5+5;
int n;
struct node {
	int x,y;
} a[maxn];
int dp[5][maxn];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i].x>>a[i].y;
	for(int i=1; i<=n; i++) {
      //分类讨论
		if(a[i].x==0) {//解药
			dp[0][i]=max(dp[0][i-1],max(dp[0][i-1]+a[i].y,dp[1][i-1]+a[i].y));//上述三种情况
			dp[1][i]=dp[1][i-1];
		} 
		else {//毒药
			dp[1][i]=max(dp[0][i-1]+a[i].y,dp[1][i-1]);//上述两种情况
			dp[0][i]=dp[0][i-1];
		}
//        cout<<dp[0][i]<<endl<<dp[1][i]<<endl<<endl;
	}
	if(max(dp[1][n],dp[0][n])>=0) cout<<max(dp[1][n],dp[0][n])<<endl;
	else cout<<0<<endl;
	return 0;
}

```

---

## 作者：_zzzzzzy_ (赞：0)

# 思路
是一道简单的 dp 题。

我们设 $dp_{i,0/1} $ 表示选择前 $i$ 个菜不健康或健康。

然后可以简单的写出状态转移式子。

对于第 $i$ 个菜是没毒的吃了显然会变成健康的，那么我们可以从健康的和不健康的转移到健康的，式子就是 $dp_{i,0}=\max(dp_{i-1,0},dp_{i-1,0}+y_i,dp_{i-1,1}+y_i)$

另一种情况同理可得式子 $dp_{i,1}=\max(dp_{i-1,1},dp_{i-1,0}+y_i)$，表示可以从健康的状态吃一个毒菜。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
const int maxn = 1000000;
#define int i64
int a[maxn];
int dp[maxn][2];
int x[maxn], y[maxn];
main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.precision(6);

	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x[i] >> y[i];
	}
	for (int i = 1; i <= n; i++) {
		if (x[i] == 0) {
			dp[i][0] = max(max(dp[i - 1][0], dp[i - 1][0] + y[i]), dp[i - 1][1] + y[i]);
			dp[i][1] = dp[i - 1][1];
		} else {
			dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] +y[i]);
			dp[i][0] = dp[i - 1][0];
		}
		// cout << dp[i][0] << " " << dp[i][1] << "\n\n";
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, max(dp[i][0], dp[i][1]));
	}
	cout << ans;
	return 0;
}

```

---

## 作者：CarroT5656 (赞：0)

**解题思路**

显然是个 dp，定义 dp 状态。

* $dp_{i,0/1}$ 表示到第 $i$ 盘菜，当前状态为有毒/无毒。

如果现在是有毒状态，只能从无毒状态转移过来。

$dp_{i,0}=dp_{i-1,1}+c_i$

如果是无毒状态，就可以从无毒和有毒两种状态转移过来。

$dp_{i,1}=\max{(dp_{i-1,1},dp_{i-1,0})}+c_i$

最后考虑跳过这盘菜的情况。

$dp_{i,0}=dp_{i-1,0}$

$dp_{i,1}=dp_{i-1,1}$

最终答案为 $\max(dp_{n,0},dp_{n,1})$。

**Code**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define N 300005
ll n,a[N],b[N],dp[N][2];
int main(){
	memset(dp,-0x3f,sizeof dp);
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++) scanf("%lld%lld",&a[i],&b[i]);
	dp[0][1]=0;
	for(ll i=1;i<=n;i++){
		dp[i][0]=dp[i-1][0],dp[i][1]=dp[i-1][1];
		if(a[i]==0){
			dp[i][1]=max(dp[i][1],max(dp[i-1][0],dp[i-1][1])+b[i]);
		}
		else{
			dp[i][0]=max(dp[i][0],dp[i-1][1]+b[i]);
		}
	}
	printf("%lld\n",max(dp[n][0],dp[n][1]));
	return 0;
}
```

---

## 作者：GI录像机 (赞：0)

### 题目大意：

现在有 $n$ 盘菜，每盘菜都有一个美味度。你可以依次决定吃或不吃。其中有些菜是有毒的，有些菜能解毒。你不能连续吃两次有毒的菜。求你能获取的最大美味度。

### 解题思路：

一眼 dp。设 $dp_{i,0/1}$ 表示已经决定了前 $i$ 道菜吃不吃，上次吃的菜是否有毒。

如果决定吃有毒的菜，就一定是从无毒状态转移到有毒状态，即 `dp[i][1] = max(dp[i - 1][0] + y[i], dp[i][1])`；

如果决定吃无毒的菜，就可以从任意状态转移到无毒状态，即 `dp[i][0] = max(dp[i][0], max(dp[i - 1][0] + y[i], dp[i - 1][1] + y[i]))`；

如果决定不吃菜，直接延续之前的状态即可，即 `dp[i][1] = max(dp[i - 1][1], dp[i][1]),dp[i][0] = max(dp[i - 1][0], dp[i][0])`。

### 参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read() {
	int f = 1, x = 0;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f * x;
}
void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
const int N = 3e5 + 10, MOD = 1e9 + 7, INF = 0x3f3f3f3f;
int n = read(), x[N], y[N], dp[N][2];
signed main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	for (int i = 1; i <= n; i++)x[i] = read(), y[i] = read();
	for (int i = 1; i <= n; i++) {
		if (!x[i]) {
			dp[i][0] = max(0ll, max(dp[i - 1][0] + max(y[i], 0ll), dp[i - 1][1] + y[i]));
			dp[i][1] = max(0ll, dp[i - 1][1]);
		} else {
			dp[i][1] = max(0ll, max(dp[i - 1][0] + y[i], dp[i - 1][1]));
			dp[i][0] = max(0ll, dp[i - 1][0]);
		}
	}
	write(max(dp[n][0], dp[n][1]));
	return 0;
}
```

---

## 作者：makerlife (赞：0)

[更好的阅读体验](https://blog.makerlife.top/post/solution-ABC306D) | [Problem Link](https://www.luogu.com.cn/problem/AT_abc306_d)

很简单的一道 D 题。

## Explanation

高桥君要在餐厅里吃一份由 $n$ 道菜组成的奇怪的全套菜单，每道菜都有一个美味程度 $y_i$，但是有的菜含有毒素，有的菜含有解毒剂。高桥君可以选择吃或者不吃每道菜，但是如果他吃了毒素，他会拉肚子，如果他拉肚子时再吃毒素，他会死亡。高桥君必须活着离开餐厅，求他能够得到的最大的美味程度之和。

## Solution

很显然这是一道 DP 题。

设 $f_{i,1/0}$ 表示**吃到第 $i$ 道菜时，当前是否中毒的最大美味值**。

接下来分类讨论：

- 如果当前这一步为**无毒**，即 $x_i=0$ 时：

  - 考虑 $f_{i,1}$：要想保持中毒状态，当前这一步一定不能吃，即 $f_{i,1}=f_{i-1,1}$；

  - 否则，考虑 $f_{i,0}$：要想在这一步吃完不是中毒状态，有两种可能：

    1. 前一步本来就不是中毒状态，那直接取当前吃与不吃的最大值即可，即 $f_{i,0}=\max(f_{i-1,0},f_{i-1,0}+y_i)$；
    2. 前一步是中毒状态，那这一步必须吃，才能使吃完后状态为无毒，即 $f_{i,0}=f_{i-1,1}+y_i$。

    所以，综合一下上式， $f_{i,0}=\max(f_{i-1,0},f_{i-1,0}+y_i,f_{i-1,1}+y_i)$。

- 否则，如果当前这一步**有毒**，即 $x_i=1$ 时：

  - 仍然像之前一样，先考虑 $f_{i,1}$ 情况：也就是这一步吃完时中毒状态，出现两种可能：

    1. 之前本来就中毒，这一步没有吃，**注意，没有之前中毒，这一步还吃的状态**，因为这样会使高桥死亡，$f_{i,1}=f_{i-1,1}$；

    2. 当然，也有可能之前没有中毒，吃了以后中毒了，也就是 $f_{i,1}=f_{i-1,0}+y_i$。

    综合一下，就是 $f_{i,1}=\max(f_{i-1,1},f_{i-1,0}+y_i)$。

  - 接着考虑 $f_{1,0}$：要想当前不中毒，只能不吃当前这一步。即 $f_{i,0}=f_{i-1,0}$。

---

结论如下；

当 $x_i=0$ 时：
$$
\begin{cases}
f_{i,0}=\max(f_{i-1,0},f_{i-1,0}+y_i,f_{i-1,1}+y_i)\\
f_{i,1}=f_{i-1,1}
\end{cases}
$$
当 $x_i=1$ 时：
$$
\begin{cases}
f_{i,0}=f_{i-1,0}\\
f_{i,1}=\max(f_{i-1,1},f_{i-1,0}+y_i)
\end{cases}
$$
最后输出 $\max(f_{n,0},f_{n,1})$ 即可。

## Core Code

```cpp
f[0][0]=f[0][1]=0;
for(int i=1;i<=n;i++)
{
	if(x[i]==1)
	{
		f[i][1]=max(f[i-1][1],f[i-1][0]+y[i]);
		f[i][0]=f[i-1][0];
	}
	else
	{
        f[i][1]=f[i-1][1];
		f[i][0]=max(f[i-1][1]+y[i],max(f[i-1][0]+y[i],f[i-1][0]));
	}
}
write(max(f[n][0],f[n][1]));
```



---

## 作者：shinzanmono (赞：0)

# ABC306D 题解

**upd:修改了一些错误**

很明显这是一道 dp。

设 $f_{i,0/1}$ 为当前菜上到第 $i$ 道，当前是否是有毒状态的美味度最大值。

根据题意可推出状态转移方程：

当 $x_i=0$ 时：

$$
\left\{
\begin{aligned}

&f_{i,0}=\max(f_{i-1,0},f_{i-1,0}+y_i,f_{i-1,1}+y_i)\\
&f_{i,1}=f_{i-1,1}
\end{aligned}
\right.
$$

当 $x_i=1$ 时：

$$
\left\{
\begin{aligned}
&f_{i,0}=f_{i-1,0}\\
&f_{i,1}=\max(f_{i-1,1},f_{i-1,0}+y_i)
\end{aligned}
\right.
$$

最后的答案就是 $\max(f_{n,0},f_{n,1})$。

然后就 AC 啦！

```cpp
#include<iostream>
#include<algorithm>
#include<limits>
using ll=long long;
const int sz=3e5+10;
const ll inf=std::numeric_limits<ll>::max();
ll f[sz][2],y[sz];
int x[sz];
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::cin>>n;
    for(int i=1;i<=n;i++)std::cin>>x[i]>>y[i];
    f[0][1]=-inf;
    for(int i=1;i<=n;i++){
        if(x[i]==0){
            f[i][1]=f[i-1][1];
            f[i][0]=std::max(f[i-1][0],std::max(f[i-1][1]+y[i],f[i-1][0]+y[i]));
        }else{
            f[i][1]=std::max(f[i-1][1],f[i-1][0]+y[i]);
            f[i][0]=f[i-1][0];
        }
    }
    std::cout<<std::max(f[n][0],f[n][1])<<"\n";
    return 0;
}
```

---

## 作者：Elairin176 (赞：0)

[传送门](https://www.luogu.com.cn/problem/AT_abc306_d)      
dp 水题。     
## 题意
现在有 $n$ 道菜，第 $i$ 道菜有毒性 $x_i$ 和美味度 $y_i$ 两种属性，$x_i=0$ 表示没毒，否则表示有毒。   
要求从第 $1$ 道菜按顺序吃到第 $n$ 道菜且不能连续两次吃有毒的菜，求最后的美味度最大和。      
## 解法
我们发现对于前 $i$ 道菜的选择是**无后效性**的，所以我们可以用 dp 解决这道题。     
我们设 $dp_{i,j}$ 为前 $i$ 道菜，状态为 $j$ 的美味度最大和。$j=0$ 表示上次没吃有毒的菜，否则表示上次吃了有毒的菜。      
我们很明显需要对 $x_i$ 进行分类讨论：     
### $x_i=0$
我们先考虑 $j=1$ 的情况。   
很明显这里吃了这道菜会改变状态，所以这种情况只能不吃。        
即 $dp_{i,1}=dp_{i-1,1}$。    
如果吃完这道菜变为了 $j=0$，那么有三种情况：    
- 上一次状态为 $1$，吃了这道菜。
- 上一次状态为 $0$，吃了这道菜。
- 上一次状态为 $0$，跳过这道菜。       

我们取最大值即可。     
$dp_{i,0}=\max(dp_{i-1,1}+y_i,dp_{i-1,0}+y_i,dp_{i-1,0})$。      
### $x_i=1$    
这里的思考过程和上部分类似，这里就只放方程了。     
$dp_{i,0}=dp_{i-1,0}$    
$dp_{i,1}=\max(dp_{i,0}+y_i,dp_{i,1})$        


[CODE](https://www.luogu.com.cn/paste/svpbnn7f)

---


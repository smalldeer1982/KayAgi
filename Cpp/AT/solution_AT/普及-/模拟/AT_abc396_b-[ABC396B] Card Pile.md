# [ABC396B] Card Pile

## 题目描述

存在一个初始由 $100$ 张写有整数 $0$ 的卡片堆叠而成的卡堆。

请处理 $Q$ 个查询。每个查询为以下两种类型之一：

- 类型 $1$：将一张写有整数 $x$ 的卡片放到卡堆的最上方。
- 类型 $2$：移除卡堆最上方的卡片，并输出被移除卡片上的整数。在本问题的约束下，保证此时卡堆中必定存在卡片。

## 说明/提示

### 约束条件

- $1 \leq Q \leq 100$
- $1 \leq x \leq 100$
- 保证至少存在一个类型 $2$ 的查询。
- 输入中的所有值均为整数

### 样例解释 1

各查询处理后的卡堆状态如下（按顺序）：
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $0$，因此输出 $0$。
- 卡堆变为 $99$ 张写有 $0$ 的卡片。
- 将写有 $4$ 的卡片放到卡堆最上方。
- 卡堆变为：最上方 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 将写有 $3$ 的卡片放到卡堆最上方。
- 卡堆变为：最上方 $1$ 张写有 $3$ 的卡片，中间 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $3$，因此输出 $3$。
- 卡堆变为：最上方 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $4$，因此输出 $4$。
- 卡堆变为 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $0$，因此输出 $0$。
- 卡堆变为 $98$ 张写有 $0$ 的卡片。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6
2
1 4
1 3
2
2
2```

### 输出

```
0
3
4
0```

## 样例 #2

### 输入

```
5
2
2
2
2
2```

### 输出

```
0
0
0
0
0```

# 题解

## 作者：FlowerAccepted (赞：2)

## 解题思路

栈板子。

栈就是一种从顶部进，顶部出，先进先出的数据结构。可以用 $\tt{STL}$ 函数实现。也可以手写。

$压栈\kern12em弹栈$

![](https://cdn.luogu.com.cn/upload/image_hosting/wkeyfwwd.png)

$$
\footnotesize
\text{图 S-AT\_abc396\_b-1} \\
\text{栈原理示意\&题目图解}
$$

注意题目，我们要在一切之前压 $100$ 个 $0$ 到栈中，然后每进行一次 $1$ 操作将一个元素压入栈中，每进行一次 $2$ 操作就弹出一个元素并输出。

## 代码呈现

### $\tt{STL}$ 版

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <stack> // 栈的头文件
using namespace std;

stack<int> s; // 声明空栈

int main() {
    for (int i = 1; i <= 100; i ++) {
        s.push(0); // 初始化 100 个 0
    }
    int q, op, a;
    cin >> q;
    while (q --) {
        cin >> op;
        if (op == 1) {
            cin >> a;
            s.push(a); // 压栈
        } else {
            cout << s.top() << '\n'; // 输出
            s.pop(); // 弹栈
        }
    }
    return 0;
}
```

### 手写版

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int MAXN = 205; // 100 + 100
int s[MAXN], cnt = 100; // cnt 表示栈的大小，cnt = 100 相当于预先压 100 个 0

int main() {
    int q, op, a;
    cin >> q;
    while (q --) {
        cin >> op;
        if (op == 1) {
            cin >> a;
            s[++ cnt] = a; // 直接将比原来栈顶指针多一的位置设为 a
        } else {
            cout << s[cnt --] << '\n'; // 先输出后弹出
        }
    }
    return 0;
}

```

## 后记

hqyx unique Card!

编写、画图不易，求赞！

---


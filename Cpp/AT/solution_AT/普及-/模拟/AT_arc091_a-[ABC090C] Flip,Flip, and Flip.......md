# [ABC090C] Flip,Flip, and Flip......

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc090/tasks/arc091_a

縦横に無限に広がるマス目があり、そのうちの連続する $ N $ 行 $ M $ 列の領域のすべてのマスに表裏の区別できるカードが置かれています。 最初はすべてのカードが表を向いています。

以下の操作を、カードが置かれている全てのマスについて $ 1 $ 度ずつ行います。

- そのマスと辺または点で接する $ 8 $ つのマスと、そのマスの合計 $ 9 $ マスについて、カードが存在するなら裏返す。

すべての操作を行った後の各カードの状態は操作を行う順番に依らないことが証明できます。 すべての操作を行った後、裏を向いているカードの枚数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,M\ \leq\ 10^9 $
- 入力は全て整数である

### Sample Explanation 1

$ 4 $ 回の操作のうちのどの操作でも、すべてのカードを裏返します。よって、すべての操作を行った後は、すべてのカードが表を向いています。

### Sample Explanation 2

すべての操作を行った後は、両端以外のカードが裏を向いています。

## 样例 #1

### 输入

```
2 2```

### 输出

```
0```

## 样例 #2

### 输入

```
1 7```

### 输出

```
5```

## 样例 #3

### 输入

```
314 1592```

### 输出

```
496080```

# 题解

## 作者：Coros_Trusds (赞：1)

# 题目大意

给定一个 $n\times m$ 的矩形，每个格子中有一张正面朝上的卡片

现在对于其中的每一个格子，都将其自身以及周围的 $8$ 个格子（如果存在的话）中的卡片翻转

求问所有操作结束后有多少张卡片正面朝下。

$1\le n,m\le 10^9$。

# 题目分析

卡片正面朝下，一定被翻了奇数次。

矩形的每个角会被翻 $4$ 次；

矩形的每条边（除角外）上的点会被翻 $6$ 次；

内部点则被翻了 $9$ 次。

所以只有内部点会正面朝下，个数为 $(n-2)\times(m-2)$。

注意特判 $n=1$ 或 $m=1$ 的情况。

-----

因为 $n,m$ 最大为 $10^9$，所以会爆 `int`，需开 `long long`。

# 代码

```cpp
long long n,m;

int main(void)
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif

	scanf("%lld%lld",&n,&m);

	if(n==1 && m==1)
	{
		printf("%lld\n",1);
	}

	else if(n==1 && m>=2)
	{
		printf("%lld\n",m-2);
	}

	else if(m==1 && n>=2)
	{
		printf("%lld\n",n-2);
	}

	else
	{
		printf("%lld\n",(n-2)*(m-2));
	}

	return 0;
}
```

---

## 作者：火车司机 (赞：1)

## 简要分析

- 先不考虑 $n=1$ 或 $m=1$ 的特殊情况

对于一个在矩形中间的格子，它必然会被它自己和周围的 $8$ 个格子翻转，最后正面朝下

对于一个在矩形的边上但不在角上的格子，它一侧的 $3$ 个格子不存在，所以只会被翻转 $6$ 次，最后正面朝上

对于一个在矩形角上的格子，通过画图手模可得，只会被翻转 $4$ 次，最后也是正面朝上

因此，普通矩形的答案就是 $(n-2) \times (m-2)$

- 对于 $n=1$ 或 $m=1$ 的特殊情况

可以发现，在矩形中间的点，只会被前后相邻的 $2$ 个格子以及自己共翻转 $3$ 次，最后正面朝上

特殊的两端由于只有一个相邻的格子，所以只会被翻转 $2$ 次，最后正面朝下

综上可得，$n=1$ 或 $m=1$ 的特殊情况的答案分别为 $m-2$ 和 $n-2$

- 最后还需要一个 $n=m=1$ 的特判

唯一一个格子只会翻转一次，所以答案为 $1$

## 完整代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ri register int
using namespace std;
int n, m;
template <typename T>
inline void read(T &x)
{
	register T f = 0, c = getchar();
	for (; c < 48 || 57 < c; c = getchar())
		if (c == '-')
			f = 1;
	for (x = 0; 48 <= c && c <= 57; c = getchar())
		x = (x << 3) + (x << 1) + (c & 15);
	if (f)
		x = ~(--x);
}
template <typename T>
inline void print(T x)
{
	if (x < 0)
		putchar('-'), x = ~(--x);
	if (x > 9)
		print(x / 10);
	putchar(x % 10 | 48);
}
signed main()
{
	read(n), read(m);
	if (n == 1 && m == 1)
		print(1);
	else if (n == 1)
		print(m - 2);
	else if (m == 1)
		print(n - 2);
	else
		print((n - 2) * (m - 2));
	puts("");
	return 0;
}
```


---

## 作者：tZEROちゃん (赞：0)

分类讨论，我们设 $N < M$，如果 $N \ge M$ 就 swap 一下，不影响结果。

- 当 $N = M = 1$ 的时候，我们发现只有唯一的一个格子，会被翻一次，所以变成反面朝上了，所以输出 $1$；
- 当 $N = 1, M > 1$，此时这个矩形的宽是 $1$，然后我们发现两端的格子会被翻 $2$ 次，分别是它自己和它左边 / 右边的格子翻得时候影响到了它以及它自己翻得时候；
- 当 $N > 1, M > 1$，此时的只要不在边缘的格子就会被翻到反面，答案是 $(N-2)(M-2)$，具体是这样的：
   - 四个角落里（粉色）的会被翻 $4$ 次，分别是它自己翻和它旁边 $3$ 个翻影响到它；
   - 除了四个角落以外，在边缘（紫色）的会被翻 $6$ 次，分别是它自己，它四周的 $5$ 个格子影响到它；
   - 其它的（蓝色）都会被翻 $9$ 次。    
 ![](https://cdn.luogu.com.cn/upload/image_hosting/cryfn69s.png)
 
#### Code

[C++](https://atcoder.jp/contests/abc090/submissions/32321666)

---


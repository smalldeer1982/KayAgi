# [ARC148A] mod M

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc148/tasks/arc148_a

数列 $ A\ =\ (A_1,\ A_2,\ ...,\ A_N) $ が与えられます。  
 あなたは次の操作をちょうど $ 1 $ 回行うことができます。

- $ 2 $ 以上の整数 $ M $ を $ 1 $ つ選ぶ。その後、$ 1\ \leq\ i\ \leq\ N $ を満たすすべての整数 $ i $ に対して、 $ A_i $ を 「$ A_i $ を $ M $ で割ったあまり」に置き換える。

例えば $ A\ =\ (2,\ 7,\ 4) $ で $ M\ =\ 4 $ を選んだ時、操作後の $ A $ は $ (2\ \bmod\ 4,\ 7\ \bmod\ 4,\ 4\ \bmod\ 4)\ =\ (2,\ 3,\ 0) $ になります。

操作を行った後の $ A $ に含まれる要素の種類数は最小で何種類になりますか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

操作で $ M\ =\ 3 $ を選ぶと $ A\ =\ (1\ \bmod\ 3,\ 4\ \bmod\ 3,\ 8\ \bmod\ 3)\ =\ (1,\ 1,\ 2) $ になり、操作後の $ A $ の要素の種類数は $ 2 $ 種類になります。 $ A $ の要素の種類数を $ 1 $ 種類にすることはできないので $ 2 $ が答えです。

### Sample Explanation 2

操作で $ M\ =\ 5 $ を選ぶと $ A\ =\ (0,\ 0,\ 0,\ 0) $ になり、これが最適です。

## 样例 #1

### 输入

```
3
1 4 8```

### 输出

```
2```

## 样例 #2

### 输入

```
4
5 10 15 20```

### 输出

```
1```

## 样例 #3

### 输入

```
10
3785 5176 10740 7744 3999 3143 9028 2822 4748 6888```

### 输出

```
1```

# 题解

## 作者：rai1gun (赞：1)

### 1.题意

有一个长度为 $n$ 的序列，你需要选择一个数 $m$，使得 $a_i=a_i \bmod m$，求在 $a$ 数组中，有多少个不同的数字。

### 2.解法

很显然，当 $m=2$ 时，$a_i$ 的取值只可能为 $0$ 或 $1$，因此，答案最多为 $2$。

接下来我们考虑答案为 $1$ 的情况。

显然，当 $\gcd\{a_1-a_2,a_2-a_3,\cdots,a_{n-1}-a_n\}$ 不为 $1$ 时，即相邻两数的差值的最小公约数不为 $1$ 时，我们就可以去它们的最小公约数，这样可以保证同为 $1$ 个数。



---

## 作者：SuperCowHorse (赞：1)

### 题目大意
给定序列 $a$，$a_i=a_i\pmod p$，求最少不相同的数。
### 题目分析
先证一个显然的命题。

设答案为 $ans$，则 $ans$ 非 $1$ 即 $2$。

显然，若 $a$ 的差分数组最大公约数 $g\ne1$，则选择 $p=2$，$ans=2$。

最后特判一下 $n=2$ 即可。

Code:
``` cpp
//chenye3
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2e5+5;
int n,a[maxn],del[maxn];
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	sort(a+1,a+1+n);//排序
	for(int i=1;i<n;++i)//查分
		del[i]=a[i+1]-a[i];
	int gcd=del[1];
	for(int i=2;i<n;++i){//求 gcd
		if(del[i]!=0)
			gcd=__gcd(gcd,del[i]);
		if(gcd==1){
			putchar('2');
			return 0;
		}
	}
	putchar(gcd!=1?'1':'2');//特判
	return 0;
	int rp=0;
	while(1) rp++;
}
```

---


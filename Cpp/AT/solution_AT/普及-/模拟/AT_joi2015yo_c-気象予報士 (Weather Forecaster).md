# 気象予報士 (Weather Forecaster)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2015yo/tasks/joi2015yo_c

JOI 市は南北方向に $ H $ キロメートル，東西方向に $ W $ キロメートルの長方形の形をしており，$ H\ \times\ W $ 個の $ 1 $ キロメートル四方の小区画に区切られている．北から $ i $ 番目，西から $ j $ 番目の小区画を $ (i,\ j) $ と表す．

各小区画は上空に雲があるか雲がないかのどちらかである．すべての雲は，$ 1 $ 分経つごとに $ 1 $ キロメートル東に移動する．今日は実に天気が良いため，JOI 市の外から JOI 市内に雲が移動してくることはない．

今，各小区画の上空に雲があるかないかがわかっている．気象予報士であるあなたは，各小区画について，今から何分後に初めてその小区画の上空に雲が来るかを予測することになった．

各小区画について，今から何分後に初めてその小区画の上空に雲が来るか求めよ．

- - - - - -

## 说明/提示

### Sample Explanation 1

入出力例 $ 1 $ では，JOI 市は $ 3\ \times\ 4 $ 個の小区画に区切られている．今の JOI 市の雲の状況は以下の通りである．図の上が北を表す． !\[2015-yo-t3-fig01.png\](https://img.atcoder.jp/joi2015yo/2015-yo-t3-fig01.png) この後，$ 1 $ 分ごとに雲は以下のように移動する． !\[2015-yo-t3-fig02.png\](https://img.atcoder.jp/joi2015yo/2015-yo-t3-fig02.png) !\[2015-yo-t3-fig03.png\](https://img.atcoder.jp/joi2015yo/2015-yo-t3-fig03.png) !\[2015-yo-t3-fig04.png\](https://img.atcoder.jp/joi2015yo/2015-yo-t3-fig04.png) - - - - - -

## 样例 #1

### 输入

```
3 4
c..c
..c.
....```

### 输出

```
0 1 2 0
-1 -1 0 1
-1 -1 -1 -1```

## 样例 #2

### 输入

```
6 8
.c......
........
.ccc..c.
....c...
..c.cc..
....c...```

### 输出

```
-1 0 1 2 3 4 5 6
-1 -1 -1 -1 -1 -1 -1 -1
-1 0 0 0 1 2 0 1
-1 -1 -1 -1 0 1 2 3
-1 -1 0 1 0 0 1 2
-1 -1 -1 -1 0 1 2 3```

# 题解

## 作者：S__X (赞：2)

这是本蒟蒻的第 $18$ 篇题解，同时也是本题的第一篇题解。
## 分析:
直接按照题意模拟就可以了。

我们用二维数组 $s$ 来存储最少几分钟后该格上空有云。同时把数组每一格初始化为 $-1$。

- 在输入字符的时候有 $2$ 种情况：
1. 输入的字符为 `.`，我们可以跳过忽略不计。
2. 输入的字符为 `c`，我们就把 $s$ 数组更新一下。

- 把 $s$ 数组更新的时候有 $2$ 种情况：
1. 当前格子值为 $-1$，直接更新。
2. 当前格子值不为 $-1$，我们就要进行比较，如果格子值比更新值大，就把格子值替换成更新值；反之，如果格子值比更新值小，则不用更新。（原因：题目上说最少几分钟后该格上空有云）

例如：`c.c.`，输入第一朵云的时候，$s$ 数组的值为 $0\ 1\ 2\ 3$；在输入第二朵云的时候，$s$ 数组的值为 $0\ 1\ 0\ 1$。

核心代码如下：
```cpp
if(a=='c'){
	for(int k=j;k<m;k++){
		if(s[i][k]!=-1) s[i][k]=min(s[i][k],k-j);//比较格子值和更新值的大小并更新。
		else s[i][k]=k-j;//如果格子值为-1，那么更新值为当前最小值。
	}
}

```

## $\texttt{code}$:
**注意**：本题有两个坑点：
1. 去掉行末空格。
2. 最后一行要有换行。

因为这两个点，我被坑了接近 $1$ 个小时，我还特意在 $Atcoder$ 上注册了个号。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s[1001][1001];
char a;
int main() {
	cin>>n>>m;
	memset(s,-1,sizeof(s));//初始化。
	for(int i=0;i<n;i++) {
		for(int j=0;j<m;j++) {
			cin>>a;
			if(a=='c'){
				for(int k=j;k<m;k++){
					if(s[i][k]!=-1) s[i][k]=min(s[i][k],k-j);//比较格子值和更新值的大小并更新。
					else s[i][k]=k-j;//如果格子值为-1，那么更新值为当前最小值。
				}
			}
		}
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(j!=m-1) cout<<s[i][j]<<" ";//一定去掉行末空格。
			else cout<<s[i][j];
		}
		cout<<endl;//最后一行一要换行。
	}
	return 0;
}
```



---

## 作者：lizhehao2009 (赞：0)

## 分析

我们可以先用一个二维的字符数组来存储这个表示天气状况的矩阵，再用双重循环枚举矩阵上的每一个字符，从后往前枚举它本身以及在它前面的每一个字符，如果其中有一个或多个字符是 `c`，则输出最近的那个到它的距离（如果是它本身则输出 $0$），若没有则输出 $-1$。但有一点需要特别注意，就是去掉行末空格，所以，我们可以做一些处理：如果在双重循环枚举时，枚举到的数是在第一列，则直接输出结果；否则，在输出结果之前，先输出一个空格。

程序代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
char mapp[110][110];//创建二维数组来存储矩阵
int main()
{
	int h,w;
	cin>>h>>w;
    for (int i=1;i<=h;i++)//输入整个矩阵
	{
		for (int j=1;j<=w;j++)
		{
			cin>>mapp[i][j];
		}
	}
	for (int i=1;i<=h;i++)//用双重循环枚举矩阵中的每一个元素
	{
		for (int j=1;j<=w;j++)
		{
			if (j>1)//如果枚举到的元素不是在第1列
			{
				cout<<" ";//则先输出空格
			}
			int sum=0;//计数变量清零
			bool flag=0;//标记变量，用来标记这个元素及它前面有没有c
			for (int k=j;k>=1;k--)//从j枚举到1（需要先枚举它本身）
			{
				if (mapp[i][k]=='c')//如果这个字符是c
				{
					cout<<sum;//输出它们之间的距离
					flag=1;//标记一下，表示已经出现过c
					break;//退出循环
				}
				else
				{
                    sum++;//否则计数变量+1
				}
			}
			if (flag==0)//如果在循环结束后，都没有出现过c
			{
				cout<<-1;//则输出-1
			}
		}
		cout<<endl;//注意换行
	}
	return 0;
}
```

---


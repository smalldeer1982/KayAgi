# 紅茶(Tea)

## 题目描述

kagamiz喝完红茶，想解决以下问题。

由两个正整数组成的元素按以下方式排列的话，$(m,n)$是第几个元素？
$(1, 1), (2, 1), (1, 2), (3, 1), (2, 2), (1, 3), (4, 1), (3, 2), (2, 3), (1, 4), (5, 1), ... "$
这个问题对他来说太简单了，他考虑的是以此为基础的另一个问题。

"像上面这样排列的整数组合中，第i个元素和第j个元素中的成分各个相加组成的新元素为第几号元素？"。

换句话说，以上所诉元素第$i$号用$(a_i,b_i)$表示，第$j$号用$(a_j,b_j)$表示的话，求$(a_i+a_j,b_i+b_j)$是第几号元素。

你的任务就是解答这个问题。

## 说明/提示

- $1≦i,j≦10^8$
- $i$可能等于$j$

Translated by @ミク

# 题解

## 作者：Eismcs (赞：5)

找规律的题，尽量不死推。

我们在找一个数对是第几个时，可以运用他们的和来分组，这样即可得到规律，第n组也就有n个元素。这样快一点，不用一个个模拟。
而每个数对的第二个数就是它在本组的序号。

下面是蒟蒻的AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int j,k,s=0;
void acd(int z){
	int i=2,t=1;
    //i为本组的和，t为本组的第二个数，也就是这个数对在本组的序号。
	while(z>1){
		t++;
		if(i<=t){
		i++;t=1;}
		z--;
	}
	j=i-t,k=t;
	return;
}//模拟，用于找第几个的两个数。
int main(){
	int x,y,a,b,c,d;
	cin>>x>>y;
	acd(x);
	a=j,b=k;
	acd(y);
	c=j,d=k;
	a+=c;
	b+=d;
	for(int i=1;i<a+b-1;i++){
		s+=i;
	}//算出这个数对的组的前面有多少个元素。
	cout<<s+b<<endl;//加上它在本组的序号
}
```

---

## 作者：MZY666 (赞：3)

[原题传送门](https://www.luogu.com.cn/problem/AT246)。
[在窝的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-at246)。

### 【题意概括】

给定一个数列，输入 $i$，$j$。

若第 $i$ 项是 $(i_1,j_1)$，第 $j$ 项是 $(i_2,j_2)$。

输出 $(i_1+j_1,i_2+j_2)$ 是第几项。

此数列为：

$(1,1),(2,1),(1,2),(3,1),(2,2),(1,3),(4,1),(3,2),(2,3),(1,4),(5,1),…$

### 【 思路 】

要想把这题做出来，肯定要先把数列的规律观察出来。

第一个数：$1,\ 2,1,\ 3,2,1,\ 4,3,2,1...$

第二个数：$1,\ 1,2,\ 1,2,3,\ 1,2,3,4...$

已经很明显了吧$-v-$.

为了下文叙述方便，我们令 $(1,1)$ 为第 $1$ 组， $(2,1),(1,2)$ 为第 $2$ 组，$(3,1),(2,2),(1,3)$ 为第 $3$ 组$...$

很明显，第 $k$ 组会有 $k$ 项。而且在第 $k$ 组中每一项的 $k_i+k_j=k$。

好的，那么下面是时候让我们进入代码实现的环节了！

### 【 代码实现+注释 】

```cpp
#include<bits/stdc++.h>//万能头文件好
using namespace std;
#define ll long long//个人习惯 
int main(){
	ll i,j,i1,i2,j1,j2,zu,ans=0;
	//zu表示目前有多少组
	//ans用于储存答案
	scanf("%lld%lld",&i,&j);//输入
    
	for(zu=1;i>zu;zu++)i-=zu;//算之前有几组，不可取等（自己想想？）
	//i-=zu的原因第zu组有zu个数，这样一直减直到i<=zu为止。
	zu++;//再加一组
	i1=zu-i;//转换得到i1
	j1=zu-i1;//转换得到j1
	
	for(zu=1;j>zu;zu++)j-=zu;
	zu++;
	i2=zu-j;
	j2=zu-i2;//同理
	
//	printf("i1=%lld j1=%lld i2=%lld j2=%lld\n",i1,j1,i2,j2);//测试用
	i=i1+i2;//加起来，得到新的i
	j=j1+j2;//加起来，得到新的j
	
	for(zu=2;zu<i+j;zu++)ans+=zu-1;
	//算除(i,j)所在组的之前有多少项
    
	printf("%lld\n",ans+j);
	//输出，j即(i,j)所在改组的第几项，所以再加上j即可
	
	return 0;//over~
}
```

作者已自愿禁言，如果有建议请私信，否则将**无法**回复您哟！

管理审核辛苦了AOA.

完结撒花~（疯狂暗示$-v-$.

---

## 作者：QianianXY (赞：3)

推这道题的时候让我找回了小学奥数的感觉。

先把两个位置的数按规律推出来，再加到一起，推算它的位置。

通过观察发现，有连续的组合中各自的两数之和都相同，如：

(3, 1) (2, 2) (1, 3)

且两数之和为n的组合个数都为n-1个。

那么得到组合的位置，就很容易推出它的两数之和。

进一步观察发现，组合的第二个数就是它在这个连续组合中的位置。

**那么代码就出来了**


```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a, b, i, sum = 0, x, y;
    cin >> a >> b;
    for (i = 1; sum < a; i++) 
    	sum += i;
    x = sum + 1 - a; y = i - x; sum = 0;
    for (i = 1; sum < b; i++) 
    	sum += i;
    x = x + sum + 1 - b; y = y + i - sum - 1 + b; sum = 0;
    // 这里的x1已经是两组数的第一个数之和，因此y1不能直接用i减x1得出
    for (int i = 1; i < x + y - 1; i++) 
    	sum += i;
    cout << sum + y << endl;
    return 0;
}
```


---

## 作者：_Ayanami_ (赞：0)

~~这是一道很臭的题所以这份题解也有点臭~~

观察一下应该都能发现规律

1,1

2,1 1,2

3,1 2,2 1,3

4,1 3,2 2,3 1,4

可以看出每一组a+b的和都是固定的
a不断递减
b不断递增

于是乎直接暴力枚举

第一重循环k枚举a+b的和

第二重从小到大枚举b（或从大到小枚举a也可）

这样先找到ai,bi和aj,bj

然后就可以找到ai+aj,bi+bj的位置

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,a=0,b=0,c=0,k=1,t=0;
int main()
{
	n=114514;
	m=1919810;
	scanf("%d%d",&n,&m);
	while(k)//不 要 停 下 来 啊（指枚举）
	{
		k++;//k枚举a+b的和
		for(int i=1;i<k;i++)//我是枚举b
		{
			t++;//组数++
			if(t==n)//找到ai,bi
			{
				a+=k-i;
				b+=i;
				c++;
			}
			if(t==m)//找到aj,bj
			{
				a+=k-i;
				b+=i;
				c++;
			}
			if(a==k-i&&b==i&&c==2)//找到答案
			{
				printf("%d\n",t);
				return 0;//还是停下来吧
			}
		}
	}
}
```

---


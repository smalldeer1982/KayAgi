# Exam and Wizard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/keyence2019/tasks/keyence2019_c

大学生の高橋君は $ N $ 個の試験を受けてすべてに合格する必要があります． 現在，$ i $ 番目の試験の準備度は $ A_{i} $ です． また，高橋君の入念な調査によって，$ i $ 番目の試験に合格するためには準備度を $ B_{i} $ 以上にしなくてはならないことが分かっています．

このままだとすべての試験に合格できないかもしれないと思った高橋君は，魔法使いの青木君に頼んで， 試験の準備度の総和は変えずに，なるべく少ない数の試験の準備度を変更してもらうことで試験を乗り切ることにしました．

高橋君に代わって，以下の条件を満たす数列 $ C_1,\ C_2,\ ...,\ C_{N} $ を考えたときの $ A_i $ と $ C_i $ が異なるような $ i $ の個数の最小値を求めてください． そのような数列 $ C_1,\ C_2,\ ...,\ C_{N} $ が構成できない場合は $ -1 $ を出力してください．

- 数列 $ A_1,\ A_2,\ ...,\ A_{N} $ の総和と数列 $ C_1,\ C_2,\ ...,\ C_{N} $ の総和は等しい
- どの $ i $ に対しても，$ B_i\ \leq\ C_i $ が成り立つ

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $
- $ A_i,\ B_i $ は整数

### Sample Explanation 1

$ (A_1,\ A_2,\ A_3)\ =\ (2,\ 3,\ 5) $ ，$ (B_1,\ B_2,\ B_3)\ =\ (3,\ 4,\ 1) $ であり，このままでは $ 1 $ 番目と $ 2 $ 番目の試験に合格できません． 以下のように $ C_1,\ C_2,\ C_3 $ を構成すれば，$ A_i $ と $ C_i $ が異なるような $ i $ の個数の最小値 $ 3 $ を達成できます． - $ (C_1,\ C_2,\ C_3)\ =\ (3,\ 5,\ 2) $

### Sample Explanation 2

この場合は，何もしなくても全ての試験に合格できます．

### Sample Explanation 3

この場合は，どのようにしても全ての試験に合格することはできません．

## 样例 #1

### 输入

```
3
2 3 5
3 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3
2 3 3
2 2 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3
17 7 1
25 6 14```

### 输出

```
-1```

## 样例 #4

### 输入

```
12
757232153 372327760 440075441 195848680 354974235 458054863 463477172 740174259 615762794 632963102 529866931 64991604
74164189 98239366 465611891 362739947 147060907 118867039 63189252 78303147 501410831 110823640 122948912 572905212```

### 输出

```
5```

# 题解

## 作者：HyyypRtf06 (赞：0)

~~修了样例，交了翻译，再写篇题解把~~

这个题其实就是`劫富济贫`贪心

方法如下：  

1. 先让数组$A$的元素报告它们与数组$B$对应的元素多/少多少。$sum$记录下来一共还剩下多少，同时把有`贡献`（指多的）的贡献值记录在一个vector【vector记作v】里面

【此时如果$sum<0$就直接输出-1】

2. 定义一个计数器$count$，赋值为$n$，把所有的贡献值从小往大排序，如果$v_i \leq sum$，$sum$ -= $v_i$，且$count$--，一直到$sum<v_i$为止

3. 如果上面没有输出-1，那么答案就是$count$

## 注意开long long！

下面就是代码:
```
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<vector>
using namespace std;
int a[233333];	//A数组
int b[233333];	//B数组
long long ans;	//注意开ll！
vector<int> v;
int sum;
int main(){
	int n;
	cin>>n;
	sum=n;
	for(int i=0;i<n;i++){//读入
		cin>>a[i];
	}
	for(int i=0;i<n;i++){//读入
		cin>>b[i];
	}
	bool flag=true;
	for(int i=0;i<n;i++){
		ans+=a[i]-b[i];//算贡献值
		if(a[i]>=b[i]){//如果贡献值非负
			v.push_back(a[i]-b[i]);//压入贡献值
		}
		else{
			flag=false;
		}
	}
	if(flag){//如果所有人都是非负贡献值
		puts("0");//不需要改变
		return 0;
	}
	sort(v.begin(),v.end());
	if(ans>=0){
		for(int i=0;i<v.size();i++){
			if(ans>=v[i]){//返还贡献值
				ans-=v[i];
				sum--;//计算答案
			}
			else{
				break;
			}
		}
		cout<<sum<<endl;//输出
	}
	else{
		puts("-1");//连任务也无法完成TAT
	}
	return 0;
}
```

---


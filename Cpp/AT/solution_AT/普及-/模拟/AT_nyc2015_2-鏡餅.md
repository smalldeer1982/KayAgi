# 鏡餅

## 题目描述

[problemUrl]: https://atcoder.jp/contests/NYC2015/tasks/nyc2015_2

入力は以下の形式で標準入力から与えられる。

> $ N $ $ a_1 $ : $ a_N $

 答えを一行に出力せよ。 ```

5
3
20
5
8
6
```

 ```

3
```

## 说明/提示

### Constraints

$ N $ 個の餅がある。$ i $ 番目の餅の重さは $ a_i $ である。 すぬけ君は、この中からいくつかの餅を選び好きな順番で積み重ねて、餅の塔を作ることにした。 ただし、ある餅の上に乗っている餅の重さの合計がそのもちの重さ以上になると、餅が割れてしまう。 餅の塔を最大何段にすることができるか求めよ。

- - - - - -

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ a_i\ \leq\ 10^9 $

# 题解

## 作者：cff_0102 (赞：3)

### AT1158 鏡餅 C++题解

~~这么水的题还没人写？~~

[更好~~不到哪里去~~的观看体验](https://www.luogu.com.cn/blog/luoguyyds/solution-at1158)

这道题很显然，贪心一直选择当前最小的年糕，上面的要尽量小，下面才能放更多。

排序一次就行了。

具体看代码。禁抄。

```cpp
#include<bits\stdc++.h>
using namespace std;
int n,a[1005];//题目中的变量 
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}sort(a,a+n);
	int s=0,ans=0;//s是目前总共的重量，ans是答案（可以搭几个） 
	for(int i=0;i<n;i++){//上面的要尽量小才能放更多 
		if(a[i]>s){//可以放上去 
			s+=a[i];//更新s
			ans++;//更新ans 
		}
	}
	cout<<ans<<endl;//AT必须换行 
	return 0;
} 
```
希望管理能给过。

---

## 作者：yydfj (赞：1)

**这是本蒟蒻第十九次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个正整数 $n$ 和长度为 $n$ 的数组 $a$，从 $a$ 数组中选取若干个元素并存入数组 $b$ 中，使得 $b[1]+b[2]+b[3]+...+b[i-1]<b[i]$，问最多能选取多少个元素。

## 解法综述

很显然要保证 $b$ 数组是上升序列，不妨定义数组 $b$ 为从小到大排列的优先队列，并将 $a$ 数组里的所有元素全部存入 $b$ 数组中。

设 $t$ 为当前所选取数组 $b$ 中元素的总值，$s$ 为当前选取数组 $b$ 中元素的个数。若 $b[i]>t$，则说明可以选取 $b[i]$，记录该次选取并更新 $t$，即 $s++$ 并 $t+=b[i]$，最后输出 $s$ 即可。

## 代码描述
```cpp
#include<queue>
#include<cstdio>
using namespace std;
priority_queue<int,vector<int>,greater<int> > b;
//定义数组b为从小到大排列的优先队列 
int n,a,t,s;
//设t为当前所选取数组b中元素的总值，s为当前选取数组b中元素的个数
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		b.push(a);//将a数组里的所有元素全部存入b数组中
	}
	while(!b.empty())//若b数组不为空
	{
		if(b.top()>t)//判断是否可以选取b[i]
		{
			t+=b.top();
			s++;
		}
		b.pop();//将b数组当前最小的元素弹出
	}
	printf("%d\n",s);//该题一定要输出换行
	return 0;
}
```

---

## 作者：EthanC_ (赞：0)

本题不会十分难，只需模拟即可。
### 解题思路：
先将年糕的大小排序，然后从小到大选择。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,a[100001];
    cin>>n;
    for(int i=0;i<n;++i)
        cin>>a[i];//读入年糕重量
    sort(a,a+n);//排序
    int now=0,ans=0;//now是现在年糕的总重量，ans是可以搭的年糕的个数
    for(int i=0;i<n;++i){
        if(a[i]>now){//如果第i个年糕重量大约现在的总重量
            now+=a[i];//重量更新
            ans++;//个数增加
        }
    }
    cout<<ans<<endl;//输出ans，AT题目都要记得换行哦~
}
```


---

## 作者：Escapism (赞：0)

很水的贪心题。

建议评橙。

[~~更好的阅读体验~~](https://361505.blog.luogu.org/)

# 题意

有 $N$ 个 重量为 $a_{i}$ 的物品，把这堆物品累成一座塔，**任意一个物品的上面的物品重量的总和必须小于这个物品的重量。**

# 思路

我们可以把题目中的 **“任意一个物品的上面的物品重量的总和必须小于这个物品的重量。”** 转化为 **“任意物品下面的物品重量的总和比上面的物品的重量大”。** 这样就可以贪心了。

转化后的贪心思路就很显然了：**当前放的是当先最重的且比下面物品总重轻物的品。** 那么我们把所有物品的重量排一次序就行了。

# 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int n,a[1005];
int main(){
	cin>>n;
	for(int i = 1;i <= n;i++){
		cin>>a[i];
	}
	sort(a,a + n); //快排
	int wei = 0,cnt = 0; 
	for(int i = 1;i <= n;i++){
		if(a[i] > wei){ //若下面物品的重量总和重于这个物品，就更新总重，个数。
			wei += a[i];
			cnt++;
		}
	}
	cout<<cnt<<endl;
	return 0;
} 
```


---

## 作者：duchengjun (赞：0)

# 题意

给你一个数组 $a$，让你在这 $n$ 个数中选出尽可能多的数，使得每一个以前选过的数的总和小于这个数本身。

# 分析

贪心，先排序一下。

若这个可以放，就放，且 $cnt+1$；若不能放，就往后面找可以放的数。

输出 $cnt$ 即可。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
//此处为快读代码
int n,a[1010],ans,cnt; 
int main(){
	read_(n);
	for(int i=1;i<=n;i++)
		read_(a[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
		if(a[i]>ans){
			ans+=a[i];
			cnt++;
		}
	write_(cnt,"\n");
	return 0;
}
```


---

## 作者：BeetyX (赞：0)

这道题很简单：直接上贪心，能取多少就取多少

不过要先快排一下，然后从小的开始选
## **代码如下**

```
#include<bits/stdc++.h>
using namespace std;
int a,x[1001],size,ans=1;//这里的size每次将要搭上去的年糕的大小，ans用来计算能搭的年糕的个数
int main()
{
    cin>>a;//输入年糕个数
    for(int i=1;i<=a;i++)
    {
        cin>>x[i];//输入每个年糕的大小
    }
    sort(x,x+a);//快排，从小到大排序，后面不用加cmp
    size=x[0];//贪心，从最小的开始选，这样划算，选得尽量多一点
    for(int j=1;j<a;j++)
    {
        if(x[j]>size)//能选就选，尽量选的多一点
        {
            size=x[j]+size;//在原有的size上再加上放上去的那个年糕的大小，表示底下的年糕的上面的所以年糕之和
            ans++;//ans更新
        }
    }
    cout<<ans<<endl;//输出ans
}
```


---

## 作者：RioBlu (赞：0)

翻译：

某人很喜欢把年糕当积木搭得很高

输入 N 与 N 个数字，代表年糕数量与年糕大小

你可以把年糕按任意顺序搭起来

任意一个年糕的**上面的年糕大小的总和**必须**小于**这个年糕的大小

求最高可以搭几个年糕
___
贪心算法：从小的开始选，能选则选，各位可以自己去理解为什么这样
```
#include<bits/stdc++.h>
using namespace std;
long long a,b[1005],fat,ans;//fat : 目前上面年糕的大小
int main()
{
	cin>>a;
	for(int s=0;s<a;s++)
	{
		cin>>b[s];
	}
	sort(b,b+a);
	fat=b[0];ans=1;//最小的先选上
	for(int s=1;s<a;s++)
	{
		if(b[s]>fat)//能选则选
		{
			fat+=b[s];
			ans++;
		}
	}
	cout<<ans<<endl;
}
```

---


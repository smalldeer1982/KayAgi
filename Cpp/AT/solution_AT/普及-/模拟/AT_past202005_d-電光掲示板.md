# 電光掲示板

## 题目描述

[problemUrl]: https://atcoder.jp/contests/past202005-open/tasks/past202005_d

$ N $ 桁の数字列を表示する電光掲示板があります。 この電光掲示板は $ 5 $ 行 $ 4N+1 $ 列に並べられたランプにより構成されます。 $ 1\ \leq\ j\ \leq\ N $ を満たす $ j $ について、左から $ j $ 桁目の数字の表示には左から $ 4j-2,4j-1,4j $ 列目のランプが用いられます。 それ以外の $ 1,5,\ \ldots,\ 4N+1 $ 列目のランプは全て消灯しています。

電光掲示板の表示の状況は $ 5 $ つの長さ $ 4N+1 $ の文字列 $ s_1,s_2,s_3,s_4,s_5 $ により表されます。 具体的には、$ 1\ \leq\ i\ \leq\ 5,\ 1\ \leq\ j\ \leq\ 4N+1 $ を満たす $ (i,j) $ について、 $ s_{i} $ の先頭から $ j $ 番目の文字は上から $ i $ 行目、左から $ j $ 列目のランプの点灯状況を表しています。

文字列中の `#` は対応する位置のランプが点灯していることを、`.` は消灯していることを表します。

電光掲示板に表示されている $ N $ 桁の数字列を出力してください。

各数字の表示の仕方については入力例 1 を参考にしてください。

## 说明/提示

### 注意

この問題に対する言及は、2020/6/6 18:00 JST まで禁止されています。言及がなされた場合、賠償が請求される可能性があります。 試験後に総合得点や認定級を公表するのは構いませんが、どの問題が解けたかなどの情報は発信しないようにお願いします。

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ s_1,s_2,s_3,s_4,s_5 $ は `#`、`.` のみからなる長さ $ 4N+1 $ の文字列
- $ s_1,s_2,s_3,s_4,s_5 $ の $ 1,5,\ \ldots,\ 4N+1 $ 文字目は全て `.`
- 入力に対応する数字列が必ず存在し、各数字の表示の仕方は入力例 1 のものと同様

## 样例 #1

### 输入

```
10
.###..#..###.###.#.#.###.###.###.###.###.
.#.#.##....#...#.#.#.#...#.....#.#.#.#.#.
.#.#..#..###.###.###.###.###...#.###.###.
.#.#..#..#.....#...#...#.#.#...#.#.#...#.
.###.###.###.###...#.###.###...#.###.###.```

### 输出

```
0123456789```

## 样例 #2

### 输入

```
29
.###.###.###.###.###.###.###.###.###.#.#.###.#.#.#.#.#.#.###.###.###.###..#..###.###.###.###.###.#.#.###.###.###.###.
...#.#.#...#.#.#.#.#.#...#.#...#.#.#.#.#.#...#.#.#.#.#.#.#.....#.#.#.#.#.##..#.#...#.#.#...#.#...#.#...#.#.....#...#.
.###.#.#...#.###.#.#.###.###...#.###.###.###.###.###.###.###...#.###.#.#..#..###...#.###.###.###.###.###.###.###.###.
.#...#.#...#...#.#.#.#.#...#...#.#.#...#.#.#...#...#...#.#.#...#...#.#.#..#..#.#...#...#.#...#.#...#.#.....#...#.#...
.###.###...#.###.###.###.###...#.###...#.###...#...#...#.###...#.###.###.###.###...#.###.###.###...#.###.###.###.###.```

### 输出

```
20790697846444679018792642532```

# 题解

## 作者：wmrqwq (赞：3)

# 原题链接

[AT_past202005_d 電光掲示板](https://www.luogu.com.cn/problem/AT_past202005_d)

# 题目简述

输入 $5$ 行字符串，输出这 $5$ 行字符串所代表的数字。

# 解题思路

首先输入 $n$，其次输入 $5$ 行长度为 $4 \times n$ 的字符串，随后暴力模拟即可。但是需要注意的是，每一个电路板上数字的大小为 $4 \times 5$ 而不是 $3 \times 5$。本题分支条件较多，建议依次分类枚举。

# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[110]; //把数组开大一点
long long n;
int main()
{	
	cin>>n;
	for(int i=0;i<5;i++)
		cin>>a[i];//读入5行电路板 
	for(int i=0;i<n;i++)
	{
		if(a[0][i*4+1]=='.' && a[0][i*4+2]=='#') ///如果这个数字显示板第1行依次为 .#
			cout<<1; //注意，因为是连续的一串数字，所以这里不用换行
		else if(a[0][i*4+1]=='#' && a[0][i*4+2]=='.')//如果这个数字显示板第1行依次为 #.
			cout<<4;
		else
		{
			if(a[1][i*4+1]=='#' && a[1][i*4+2]=='.' && a[1][i*4+3]=='#') //如果这个数字显示板第2行依次为 #.#
			{
				if(a[2][4*i+2]=='.')
					cout<<0;
				else if(a[3][4*i+1]=='.')
					cout<<9;
				else 
					cout<<8;
			}
			else if(a[1][i*4+1]=='#')
			{
				if(a[3][i*4+1]=='.')
					cout<<5;
				else 
					cout<<6;
			}
			else
			{
				if(a[2][i*4+2]=='#')
				{
					if(a[3][4*i+1]=='.')
						cout<<3;
					else 
						cout<<2;
				}
				else 
					cout<<7;
			}
		}	
	}
	cout<<endl; //AT的题要换行
	return 0;
}
```




---

## 作者：Molina (赞：3)

# 题目大意：
### [题目链接](https://www.luogu.com.cn/problem/AT_past202005_d)
有一块电子板上显示着一个由 $ n $ 位数字构成的串（这个串共有 $ 5 $ 行）。数字的显示见样例输入。请输出这块电子板上显示的数字。
# 本题思路：
## 模拟：
**主程序：** 可以得到：这个电子板共有 $ n \times 4 + 1 $ 列，将这个电子板每四列分成一组，用函数判断这一组所显示的数是什么，然后输出。最后一列不用管，它对解题没有影响。

**函数部分：** 对于这个四列五行的电子板，分类判断它是哪个数：一行一行来判断，筛选出符合的数字，最后返回值就行了。

注意：这道题思维难度不难，但这个模拟代码码量实在是太大了！

详细细节请看代码。
# 代码来咯~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char s[10][205];
int cz(int x){//函数部分，判断数字，然后一一判断返回值
	if(s[1][x+1]=='#'  &&  s[1][x+2]=='#'  &&  s[1][x+3]=='#'){
		if(s[2][x+1]=='#'  &&  s[2][x+2]=='.'  &&  s[2][x+3]=='#'){
			if(s[3][x+1]=='#'  &&  s[3][x+2]=='.'  &&  s[3][x+3]=='#'){
				return 0;
			}
			else if(s[3][x+1]=='#'  &&  s[3][x+2]=='#'  &&  s[3][x+3]=='#'){
				if(s[4][x+1]=='#'){
					return 8;
				}
				else{
					return 9;
				}
			}
		}
		else if(s[2][x+1]=='.'  &&  s[2][x+2]=='.'  &&  s[2][x+3]=='#'){
			if(s[3][x+1]=='.'  &&  s[3][x+2]=='.'  &&  s[3][x+3]=='#'){
				return 7;
			}
			else{
				if(s[4][x+1]=='#'  &&  s[4][x+2]=='.'  &&  s[4][x+3]=='.'){
					return 2;
				}
				else if(s[4][x+1]=='.'  &&  s[4][x+2]=='.'  &&  s[4][x+3]=='#'){
					return 3;
				}
			}
		}
		else if(s[2][x+1]=='#'  &&  s[2][x+2]=='.'  &&  s[2][x+3]=='.'){
			if(s[4][x+1]=='.'  &&  s[4][x+2]=='.'  &&  s[4][x+3]=='#'){
				return 5;
			}
			else if(s[4][x+1]=='#'  &&  s[4][x+2]=='.'  &&  s[4][x+3]=='#'){
				return 6;
			}
		}
	}
	else if(s[1][x+2]=='#'){
		return 1;
	}
	else if(s[1][x+1]=='#'  &&  s[1][x+3]=='#'){
		return 4;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=5;i++){
		for(int j=1;j<=n*4+1;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=4*n;i+=4){
		int x=cz(i);
		cout<<x;//找到数字输出就行了
	}
	return 0;
}
```

---

## 作者：czxQQQ (赞：1)

~~不得不说这道模拟真的是太废阳寿了~~

## 思路

一共 $5$ 行灯，所以输入 $5$ 个字符串。

然后开始打表。每个数字的字符如下：

```
.### ..#. .### .### .#.# .### .### .### .### .###
.#.# .##. ...# ...# .#.# .#.. .#.. ...# .#.# .#.#
.#.# ..#. .### .### .### .### .### ...# .### .###
.#.# ..#. .#.. ...# ...# ...# .#.# ...# .#.# ...#
.### .### .### .### ...# .### .### ...# .### .###
```
通过观察，可以发现每个数字都有它独特的地方。

以 $1$ 为例，可以发现 $a_{i+1}$ 的位置，即第一行第二个，只有它是 `.`。这样可以大大增加打表的效率。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a,b,c,d,e;
int main(){
	cin>>n>>a>>b>>c>>d>>e;
	for(int i=0;i<n*4;i+=4){
		if(b[i+2]=='.'&&c[i+2]=='.'&&d[i+2]=='.'&&e[i+2]=='#') cout<<"0";
		else if(a[i+1]=='.') cout<<"1";
		else if(d[i+3]=='.'&&d[i+2]=='.') cout<<"2";
		else if(b[i+1]=='.'&&c[i+1]=='#'&&d[i+1]=='.') cout<<"3";
		else if(a[i+2]=='.') cout<<"4";
		else if(b[i+1]=='#'&&b[i+2]=='.'&&b[i+3]=='.'&&d[i+1]=='.') cout<<"5";
		else if(b[i+1]=='#'&&b[i+2]=='.'&&b[i+3]=='.'&&d[i+1]=='#') cout<<"6";
		else if(c[i+1]=='.'&&c[i+2]=='.') cout<<"7";
		else if(d[i+1]=='#') cout<<"8";
		else cout<<"9";
	}
	return 0;
}
```


---

## 作者：Peaceful_Evening (赞：1)

## 解题思路：

这道题中，每个数字都有自己的特征，比如 ```1```，它的第 $1$ 行第 $1$ 列的符号是 ```.```，而其他数字的第 $1$ 行第 $1$ 列的符号都是 ```#```。以此类推，我们可以归纳出每个数字的特征，进而在循环中进行判断，最后输出每一个串所代表的数字。

根据题意，每个数字都占 $3$ 列，每个数字之间有空格，所以每四列为一组进行判断。

## 代码：
```cpp
#include <bits/stdc++.h>//AT_past202005_d题解 
using namespace std;
string a[5];
int main() {
    int n;
    cin>>n;
    getchar();//如果不加，会导致无法输入最后一行字符串，但在这道题中并不影响判断和输出答案
    for(int i=0;i<5;i++){//输入每一行的字符
    	cin>>a[i];
	}
	for(int i=0;i<a[0].length()-1;i+=4){//每四列为一组进行判断
		if(a[0][i]=='.'&&a[0][i+1]=='.'&&a[0][i+2]=='#'&&a[0][i+3]=='.'){//判断1
			cout<<"1";
		}
		else if(a[0][i]=='.'&&a[0][i+1]=='#'&&a[0][i+2]=='.'&&a[0][i+3]=='#'){//判断4
			cout<<"4";
		}
		else if(a[0][i]=='.'&&a[0][i+1]=='#'&&a[0][i+2]=='#'&&a[0][i+3]=='#'){
			if(a[1][i]=='.'&&a[1][i+1]=='#'&&a[1][i+2]=='.'&&a[1][i+3]=='#'){
				if(a[2][i]=='.'&&a[2][i+1]=='#'&&a[2][i+2]=='.'&&a[2][i+3]=='#'){//判断0
					cout<<"0";
				}
				else if(a[3][i]=='.'&&a[3][i+1]=='#'&&a[3][i+2]=='.'&&a[3][i+3]=='#'){判断8
					cout<<"8";
				}
				else if(a[3][i]=='.'&&a[3][i+1]=='.'&&a[3][i+2]=='.'&&a[3][i+3]=='#'){//判断9
					cout<<"9";
				}
			}
			if(a[1][i]=='.'&&a[1][i+1]=='#'&&a[1][i+2]=='.'&&a[1][i+3]=='.'){
				if(a[3][i]=='.'&&a[3][i+1]=='#'&&a[3][i+2]=='.'&&a[3][i+3]=='#'){//判断6
					cout<<"6";
				}
				else{
					cout<<"5";
				}
			}
			if(a[1][i]=='.'&&a[1][i+1]=='.'&&a[1][i+2]=='.'&&a[1][i+3]=='#'){
				if(a[2][i]=='.'&&a[2][i+1]=='.'&&a[2][i+2]=='.'&&a[2][i+3]=='#'){//判断7
					cout<<"7";
				}
				else if(a[3][i]=='.'&&a[3][i+1]=='#'&&a[3][i+2]=='.'&&a[3][i+3]=='.'){//判断2
					cout<<"2";
				}
				else{
					cout<<"3";
				}
			}
		}
	}
	return 0;
}

```





---

## 作者：Berd__ (赞：1)

### 思路
先看样例：
```
.###|..#.|.###|.###|.#.#|.###|.###|.###|.###|.###|.
.#.#|.##.|...#|...#|.#.#|.#..|.#..|...#|.#.#|.#.#|.
.#.#|..#.|.###|.###|.###|.###|.###|...#|.###|.###|.
.#.#|..#.|.#..|...#|...#|...#|.#.#|...#|.#.#|...#|.
.###|.###|.###|.###|...#|.###|.###|...#|.###|.###|.
```
用 **“|”** 把样例的每个数字分割开来，我们可以发现，每个电路板上的数字都可以看成是 $5\times 4$（实际上是 $5\times 3$，由于第一列都熄灭）的矩阵。

**如果**我们只看第一行，“..#.”是 $1$，“.#.#”是 $4$，**但是** “.###”在 $0,2,3,5,6,7,8,9$ 中都出现过，所以单看一行是不行的。

所以再仔细观察，每个数字其实都有只有它自己有的**特征**，像刚才说的 $1,4$。\
还有，$0$ 的第三行是“.#.#” ，$2$ 的第四行是“.#..”......这些特征都是其他数字所没有的。

设 $a,b,c,d,e$ 五个string变量来存每一行字符，然后每四列一判定，具体代码和楼上大佬 @czxQQQ 的解法差不多，完整代码就不放了，有问题欢迎指出。

---

## 作者：__Octhyccc__ (赞：1)

遇到这种题我们一定要有仔细观察，总结结论，判断条件的耐心。

因为每一个数字占 $3$ 列，一共有 $5$ 行，所以我们可以用字符串数组来做。又因为输入的第一个数是这个显示屏上一共有多少个数，所以我们的输入是这样的：

```cpp
string a[5];
int k;
scanf("%d",&k);
for(int i=0;i<5;i++){
	cin>>a[i];
}
```

然后又因为每 $3$ 列空一行（即全是 ```*```），第一列和最后一列也全是 ```*```，所以我们可以把一列熄灯和一个数字结合在一起来看，循环可以这么写：

```cpp
for(int i=0;i<a[0].length()-1;i+=4)
```



可以分为 $4$ 种情况来讨论（**我的字符串数组下标从 $0$ 开始**）：

1. 先讨论一种大情况，因为我们用排除法排完大多数后可以少写一些代码。这种大情况就是在第 $1$ 行中出现 ```#.#```  的情况。

	很明显，在这种情况里的有 $0,4,9,8$ 这几个数。
    
   $0$ 的特征在第 $2$ 行，它是 ```#.#```。
   
   $4$ 的特征在第 $4$ 行，它是 ```..#```。
   
   $9$ 的特征在第 $3$ 行，它是 ```..#```。
   
   其余情况就是 $8$。
2. 有一种独一无二的情况，在第一行它是 ```##.```，这种情况只有一种，直接输出 $1$ 即可。

3. 在第一行是 ```..#``` 的情况，通过观察，我们可以发现符合这种情况的有 $2,3,7$。
	
   $2$ 的特征在第 $3$ 行，它是 ```#..```。
   
   把 $2$ 排除之后，$3$ 与 $7$ 的区别是在第 $2$ 行的第 $i+2$ 个字符（$i$ 是循环变量），$3$ 的这个字符是  ```#```，$7$ 的是 ```.```。

4. 至此我们快成功了，还剩下 $5,6$，它们俩的区别在第 $3$ 行的第 $i+1$ 个字符，$6$ 的是 ```#```，$5$ 的是  ```.```。

各种情况已讨论完毕，如有错误欢迎指出。

接下来就是代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	string a[5];
	int k;
	scanf("%d",&k);
	for(int i=0;i<5;i++){
		cin>>a[i];
	}
	for(int i=0;i<a[0].length()-1;i+=4){
		if(a[1][i+1]=='#' && a[1][i+2]=='.' && a[1][i+3]=='#'){
			if(a[2][i+1]=='#' && a[2][i+2]=='.' && a[2][i+3]=='#'){
				printf("0");
			}
			else if(a[4][i+1]=='.'&&a[4][i+2]=='.'&&a[4][i+3]=='#'){
				printf("4");
			}
			else if(a[3][i+1]=='.'&&a[3][i+2]=='.'&&a[3][i+3]=='#'){
				printf("9");
			}
			else printf("8");
		}
		else if(a[1][i+1]=='#' && a[1][i+2]=='#'&&a[1][i+3]=='.')printf("1");
		else if(a[1][i+1]=='.' && a[1][i+2]=='.'&&a[1][i+3]=='#'){
			if(a[3][i+1]=='#'&&a[3][i+2]=='.'&&a[3][i+3]=='.')printf("2");
			else{
				if(a[2][i+2]=='#')printf("3");
				else printf("7");
			}
		}
		else{
			if(a[3][i+1]=='.')printf("5");
			else printf("6");
		}
	}
	return 0;
}
```

祝大家切掉这道题！

---

## 作者：_7Mr (赞：1)

# 思路
这道题的思路很简单，就是一道大模拟的题。

从开头一列一列地看，用双循环检查和哪个文字一致就可以了。

**接下来就是这道题最难的地方了，大模拟的程序。**

教大家一个小技巧写这种大模拟的题用 python 会好写很多。接下来给出主要程序。
# ACcode
```python
digits = [
".###..#..###.###.#.#.###.###.###.###.###.",
".#.#.##....#...#.#.#.#...#.....#.#.#.#.#.",
".#.#..#..###.###.###.###.###...#.###.###.",
".#.#..#..#.....#...#...#.#.#...#.#.#...#.",
".###.###.###.###...#.###.###...#.###.###.",
]
n = int(input())
s = [input() for i in range(5)]
ans = ""
for j in range(n):
for v in range(10):
ok = True
for x in range(5):
for y in range(4):
ok&=s[x][j*4+y] == digits[x][v*4+y]
if ok:
ans+=str(v)
print(ans)
```

---

## 作者：oceanfish (赞：0)

## 题目
[原题传送门](https://www.luogu.com.cn/problem/AT_past202005_d)
## 解法
题目本质是模拟，让我们在一块宽 $5$ 的电路板上判断数字并输出。

那么有什么办法判断呢，有一种最朴素的方法，那就是对电路板数字的每一个格子进行判断，从而知道每一个数字是什么，但这种方法非常考验你的耐心，而且很容易出错，导致全盘皆毁。

那么我们就要想办法优化了，让我们来看一眼样例：
```
.### ..#. .### .### .#.# .### .### .### .### .### .
.#.# .##. ...# ...# .#.# .#.. .#.. ...# .#.# .#.# .
.#.# ..#. .### .### .### .### .### ...# .### .### .
.#.# ..#. .#.. ...# ...# ...# .#.# ...# .#.# ...# .
.### .### .### .### ...# .### .### ...# .### .### .
```
不难发现，$4$ 不同于其他数字，其第一行为 `.#.#`，$1$ 的第一行 `..#.` 也是特有的，所以可以以这个特征判断 $1$ 与 $4$，而其他数字，各有各的特征，例如虽然 $0$ 的第一行是 `.###`，与其他数一样，但是 $0$ 的第三行是 `.#.#`，不同于其他数，以及 $2$ 的第四行是 `.#..`，也与其他数不同。而对于 $3$，我们找不到它哪一行有特征，就可以结合两行来看，例如其第二行与第三行结合起来，就不同与其他数了。

以此类推，我们可以抓住每个数的特征进行判断，从而大大地简化代码。

代码就不放出来了，因为我前面的大佬都写了。

---

## 作者：blsya23a2 (赞：0)

## 分析
由题知，输入数字的分布是有规律的，每个数字占 $3$ 列，数字之间空 $1$ 列。因此，第 $n+1$ 个数字在第 $(4n+1)+1\sim(4n+3)+1$ 列（这样表示是为了方便访问元素）。对于每个数字，我们不需要完整判断，而是只需要判断每个数字的特征。例如，判断一个输入的数字是否是 `1`，只需要判断它的第 $1$ 排第 $1$ 个符号是否是 `.`，因为这是 `1` 独一无二的特征。
## 代码
```python
a,b = int(input()),[list(input()) for c in range(5)]
for d in range(a):
    if b[0][4*d+1] == '#' and b[0][4*d+2]=='#': #分成两部分，所需特征更少
        if b[2][4*d+1] == '#' and b[2][4*d+2] == '.':
            print(0,end='')
        elif b[3][4*d+1] == '#' and b[3][4*d+3] == '.':
            print(2,end='')
        elif b[1][4*d+3] == '#' and b[3][4*d+1] == '.' and b[2][4*d+1] == '#' and b[1][4*d+1] == '.':
            print(3,end='')
        elif b[1][4*d+3] == '.' and b[3][4*d+1] == '.':
            print(5,end='')
        elif b[1][4*d+1] == '#' and b[1][4*d+3] == '.':
            print(6,end='')
        elif b[2][4*d+1] == '.':
            print(7,end='')
        elif b[3][4*d+1] == '#':
            print(8,end='')
        else:
            print(9,end='')
    else:
        if b[0][4*d+1] == '.':
            print(1,end='')
        else:
            print(4,end='')
print() #注意换行
```
upd：优化了 $\LaTeX$。

---

## 作者：_s_z_y_ (赞：0)

## 思路

先用字符串存入所有灯的状态，再通过循环将灯分成 $4$ 列为一组进行判断数字。

本题思路不难，但**模拟量较大**。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s[10];
int main()
{
	cin>>n;
	for(int i=1;i<=5;i++)
		cin>>s[i];
	for(int i=0;i<n;i++)
	{
		if(s[1][4*i+1]=='#'&&s[1][4*i+2]=='#'&&s[1][4*i+3]=='#')
		{
			if(s[2][4*i+1]=='#'&&s[2][4*i+2]=='.'&&s[2][4*i+3]=='#')
			{
				if(s[3][4*i+1]=='#'&&s[3][4*i+2]=='.'&&s[3][4*i+3]=='#')
					cout<<0;
				else if(s[4][4*i+1]=='#'&&s[4][4*i+2]=='.'&&s[4][4*i+3]=='#')
					cout<<8;
				else
					cout<<9;
			}
			else if(s[2][4*i+1]=='.'&&s[2][4*i+2]=='.'&&s[2][4*i+3]=='#')
			{
				if(s[4][4*i+1]=='#'&&s[4][4*i+2]=='.'&&s[4][4*i+3]=='.')
					cout<<2;
				else if(s[3][4*i+1]=='#'&&s[3][4*i+2]=='#'&&s[3][4*i+3]=='#')
					cout<<3;
				else
					cout<<7;
			}
			else
			{
				if(s[4][4*i+1]=='#'&&s[4][4*i+2]=='.'&&s[4][4*i+3]=='#')
					cout<<6;
				else
					cout<<5;
			}
		}
		else if(s[1][4*i+1]=='.'&&s[1][4*i+2]=='#'&&s[1][4*i+3]=='.')
			cout<<1;
		else
			cout<<4;
	}
}
```

---

## 作者：volatile (赞：0)

## 思路

每 $4$ 列字符为一组，判断每一组，输出就可以了。

我有一个可能比较好的判断方法，就是先判断第三行——第一列一定是 `.`，所以我判断是都是**从第二个开始，请牢记**——有以下这 $4$ 种可能：

- 为 `#.#`，这种只有一个——$0$，直接输出 $0$ 就可以了。

- 为 `.#.`，这种只有一个——$1$，直接输出 $1$ 就可以了。

- 为 `..#`，这种只有一个——$7$，直接输出 $7$ 就可以了。

剩下为 `###` 的就比较恶心了，具体如下：

- 判断第四行，如果为 `#..`，这种只有一个——$2$，直接输出 $2$ 就可以了。

- 判断第四行，如果为 `..#`，这种有 $4$ 个：

	- 判断第二行的第一个（请记住，我忽略了原本是第一个的 `.`），如果为 `.`，这种只有一个——$3$，直接输出 $3$ 就可以了。
    
   - 判断第二行的第三个，如果为 `.`，这种只有一个——$5$，直接输出 $5$ 就可以了。
   
   - 判断第一行的第二个，如果为 `.`，这种只有一个——$4$，直接输出就可以了。

- 其他的有 $2$ 个：
	- 判断第二行的第三个，如果为 `.`，这种只有一个——$6$，直接输出 $6$ 就可以了。
   - 最后一个直接输出 $9$ 就可以了。
   
## 代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
char a[6][250];
void pd()
{
	for(int i=0;i<=n*4;i+=4){
		if(a[3][i+1]=='#'&&a[3][i+2]=='#'&&a[3][i+3]=='#'){
			if(a[4][i+1]=='#'&&a[4][i+2]=='.'&&a[4][i+3]=='.') cout<<2;
			else if(a[4][i+1]=='.'&&a[4][i+2]=='.'&&a[4][i+3]=='#'){
				if(a[2][i+1]=='.') cout<<3;
				else if(a[1][i+2]=='.') cout<<4;
				else if(a[2][i+3]=='.') cout<<5;
				else cout<<9;
			}
			else{
				if(a[2][i+3]=='.') cout<<6;
				else cout<<8;
			}
		}
		else if(a[3][i+1]=='#'&&a[3][i+2]=='.'&&a[3][i+3]=='#') cout<<0;
		else if(a[3][i+1]=='.'&&a[3][i+2]=='.'&&a[3][i+3]=='#') cout<<7;
		else if(a[3][i+1]=='.'&&a[3][i+2]=='#'&&a[3][i+3]=='.') cout<<1;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=5;i++) scanf("%s",a[i]);
	pd();
	return 0;
}
```

提交的时候 $3$ 次 UKE，今晚提交了一下才 AC。

---

## 作者：jsisonx (赞：0)

# 题目大意
给出一个字符的矩阵，输出矩阵中表示的数字。
# 题目分析
这是一个很大的模拟。通过观察样例可以知道，矩阵一共有 $5$ 行，有 $4n+1$ 列，而第一列和最后一列都是字符'.'，所以只需要对从第 $2$ 列到第 $4n$ 列进行模拟，而每一个数字是一个 $5$ 行 $3$ 列的字符矩阵。因此可以一个数字一个数字地处理。具体操作可以把一个数字的 $15$ 个字符按照从 $1$ 到 $5$ 行的顺序用字符串表示，因为每个数字包含的字符和位置都不全相同。具体字符串见下表：

- $0$："####.##.##.####"
- $1$：".#.##..#..#.###"
- $2$："###..#####..###"
- $3$："###..####..####"
- $4$："#.##.####..#..#"
- $5$："####..###..####"
- $6$："####..####.####"
- $7$："###..#..#..#..#"
- $8$："####.#####.####"
- $9$："####.####..####"

将上表用程序表示即可。

# 代码
```cpp
#include<iostream>
using namespace std;
int store[500];
int n,l=0;
char a[500][500];
int h=0,t=0;
void pd(){
	while(l<=4*n-1){
		h=0;
		char now[100001];
		for(int i=0;i<5;i++){
			for(int j=l+1;j<l+4;j++){
				now[h++]=a[i][j];
			}
		}
		if((string)now=="####.##.##.####"){
			store[t++]=0;
		}
		if((string)now==".#.##..#..#.###"){
			store[t++]=1;
		}
		if((string)now=="###..#####..###"){
			store[t++]=2;
		}
		if((string)now=="###..####..####"){
			store[t++]=3;
		}
		if((string)now=="#.##.####..#..#"){
			store[t++]=4;
		}
		if((string)now=="####..###..####"){
			store[t++]=5;
		}
		if((string)now=="####..####.####"){
			store[t++]=6;
		}
		if((string)now=="###..#..#..#..#"){
			store[t++]=7;
		}
		if((string)now=="####.#####.####"){
			store[t++]=8;
		}
		if((string)now=="####.####..####"){
			store[t++]=9;
		}
		l+=4;
	}
}
int main(){
	cin>>n;
	for(int i=0;i<5;i++){
		for(int j=0;j<4*n+1;j++){
			cin>>a[i][j];
		}
		cout<<endl;
	}
	pd();
	for(int i=0;i<t;i++){
		cout<<store[i];
	}	
	return 0;
}
```


---

## 作者：asas111 (赞：0)

## 思路
这题是模拟题，判断数字就可以了。但是输入字符串之后，如果一行一行判断，代码量会多一些。其实只需要判断每个数字的特征。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	string a[5];
	for(int i=0;i<5;i++)cin>>a[i]; //只读入4行也可以，因为判断用不到
	for(int i=0;i<n;i++)
		if(a[0][4*i+1]=='.'&&a[0][4*i+2]=='#')cout<<1;
		else if(a[0][4*i+1]=='#'&&a[0][4*i+2]=='.')cout<<4;
		else
			if(a[1][4*i+1]=='#'&&a[1][4*i+2]=='.'&&a[1][4*i+3]=='#')
				if(a[2][4*i+2]=='.')cout<<0;
				else
					if(a[3][4*i+1]=='.')cout<<9;
					else cout<<8;
			else if(a[1][4*i+1]=='#')
				if(a[3][4*i+1]=='.')cout<<5;
				else cout<<6;
			else
				if(a[2][4*i+2]=='#')
					if(a[3][4*i+1]=='.')cout<<3;
					else cout<<2;
				else cout<<7;	
	return 0;
}
```


---

## 作者：Kobe_BeanBryant (赞：0)

### 题目大意：
给定一个 $ n $ 和 $ 5 $ 行字符串 $ s $，求这段字符串代表的数字。
### 思路：
先将 $ n $ 和 $ s $ 输入，然后直接暴力枚举，也就是**大模拟**。
### 代码解释：
将输入的一段字符串分为每 $ 3 $ 个一段，每个数字一共有 $ 5 $ 个不同行这样的字符串；然后进行判断，满足输出，否则进行下一个数字的判断。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
string h1,h2,h3,h4,h5;
string p1,p2,p3,p4,p5;
int main(){
    scanf("%lld",&n);
    cin>>h1>>h2>>h3>>h4>>h5;
    for(int i=1;i<=n*4;){
        p1=h1.substr(i,3),p2=h2.substr(i,3),p3=h3.substr(i,3),p4=h4.substr(i,3),p5=h5.substr(i,3);
        if(p1=="###" && p2=="#.#" && p3=="#.#" && p4=="#.#" && p5=="###"){
        	printf("0");
		}else{
			if(p1==".#." && p2=="##." && p3==".#." && p4==".#." && p5=="###"){
				printf("1");
			}else{
				if(p1=="###" && p2=="..#" && p3=="###" && p4=="#.." && p5=="###"){
					printf("2");
				}else{
					if(p1=="###" && p2=="..#" && p3=="###" && p4=="..#" && p5=="###"){
						printf("3");
					}else{
						if(p1=="#.#" && p2=="#.#" && p3=="###" && p4=="..#" && p5=="..#"){
							printf("4");
						}else{
							if(p1=="###" && p2=="#.." && p3=="###" && p4=="..#" && p5=="###"){
								printf("5");
							}else{
								if(p1=="###" && p2=="#.." && p3=="###" && p4=="#.#" && p5=="###"){
									printf("6");
								}else{
									if(p1=="###" && p2=="..#" && p3=="..#" && p4=="..#" && p5=="..#"){
										printf("7");
									}else{
										if(p1=="###" && p2=="#.#" && p3=="###" && p4=="#.#" && p5=="###"){
											printf("8");
										}else{
											if(p1=="###" && p2=="#.#" && p3=="###" && p4=="..#" && p5=="###"){
												printf("9");
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}	
        i+=4; 
    }
    return 0;
}
 

```

---


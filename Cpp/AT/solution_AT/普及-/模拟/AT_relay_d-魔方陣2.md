# 魔方陣2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/cf16-relay-open/tasks/relay_d

$ 3 $ マス × $ 3 $ マスの方眼状のマスの中に整数が書かれているものを方陣と呼びます。

タテ、ヨコ、ナナメに並んだ $ 3 $ つの数の総和がどれも等しい方陣を魔方陣と呼びます。

ある魔方陣について、以下のような $ 3 $ マスに関する情報が与えられます。

- 一番左の列の一番上には整数 $ A $ が書かれている
- 中央の列の一番上には整数 $ B $ が書かれている
- 中央の列の中央には整数 $ C $ が書かれている

これらの情報から、元の魔方陣の残りのマスに書かれている整数を全て求めてください。

なお、条件をみたすような魔方陣は必ず $ 1 $ つだけ存在することが保証されています。

## 说明/提示

### 制約

- $ 0\ \leq\ A,\ B,\ C\ \leq\ 100 $

## 样例 #1

### 输入

```
8
3
5```

### 输出

```
8 3 4
1 5 9
6 7 2```

## 样例 #2

### 输入

```
1
1
1```

### 输出

```
1 1 1
1 1 1
1 1 1```

# 题解

## 作者：亦枫 (赞：6)

## Solution

题意：如图一个幻方，已知其中三个点的值分别为 $ A $,$ B $,$ C $ 让你求其中剩下点的值，完成并输出这个幻方。

| A | B | ? |
| :----------: | :----------: | :----------: |
| ? | C | ? |
| ? | ? | ? |

先介绍一条三阶幻方的规律：

**幻和 $ =3× $ 中心数**（幻和指其中每行（或每列或对角线）中的整数和相等的那个和）

证明：

通过中心数有 $ 4 $ 条线。

将这 $ 4 $ 条线全部加起来，可以得到：幻和 $ ×4= $ 全体数的和+中心数 $ ×3 $。

而我们知道三阶幻方中，全体数的和 $ =3× $ 幻和
（三行或三列）。

因此有：幻和 $ ×4= $ 幻和 $ ×3+ $ 中心数 $ ×3 $。

化简得到：幻和 $ =3× $ 中心数。

根据这个规律，

在已知一条线上三个点中的两个，就可以推出剩下的一个点。就有如下推出的三阶幻方：

| A | B | 3×C-A-B |
| :----------: | :----------: | :----------: |
| 4×C-2×A-B | C | 2×A+B-2×C |
| A+B-C | 2×C-B | 2×C-A |

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
int main(){
	scanf("%d %d %d",&a,&b,&c);
	printf("%d %d %d\n",a,b,c*3-a-b);
	printf("%d %d %d\n",4*c-2*a-b,c,2*a+b-2*c);
	printf("%d %d %d\n",a+b-c,c*2-b,c*2-a);
}
```


---

## 作者：ShineEternal (赞：4)

楼下大佬使我十分佩服，但蒟蒻认为如果能写的简单，为什么要那么复杂呢？
```
#include<cstdio>
using namespace std;
int f[4][4];
int main()
{
	int a,b,c;
	scanf("%d%d%d",&f[1][1],&f[1][2],&f[2][2]);//先把位置都放好
	a=f[2][2]*3;//a记录行，列，斜线的和。我们知道，这种3*3的方格填数每一行，每一列，每一斜线的和都等于中间数的3倍
	f[1][3]=a-f[1][1]-f[1][2];
	f[3][1]=a-f[1][3]-f[2][2];
	f[3][3]=a-f[1][1]-f[2][2];
	f[2][1]=a-f[1][1]-f[3][1];
	f[2][3]=a-f[2][1]-f[2][2];
	f[3][2]=a-f[1][2]-f[2][2];//这一大段是计算，顺序很重要
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			printf("%d ",f[i][j]);//矩阵输出
		}
		printf("\n");
	}
	return 0;
}
```
**总结：本人利用了此题只为3*3的矩阵，有点投机取巧，但就这道题而言，还是一个通俗易懂的思路**

求过

---

## 作者：DeepSkyBlue__ (赞：1)

小奥题，要你填满一个幻方。

告诉了你3个数，那我们简单计算一下就珂以了。

设第一行最右边的那个数为D，那么我们很容易就珂以算出2A+2B-3C+2D=A+B+D。

所以D=3C-A-B。

这样整个幻方很快就会出来啦。

CODE：



```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,c;
	cin>>a>>b>>c;
	cout<<a<<" "<<b<<" "<<3*c-a-b<<endl;
	cout<<4*c-2*a-b<<" "<<c<<" "<<2*a+b-2*c<<endl;
	cout<<a+b-c<<" "<<2*c-b<<" "<<2*c-a<<endl;
	return 0;
}
```


---

## 作者：owll (赞：1)

~~虽然题目简单，但无意点进来就看看吧~~

给同学们的一点建议：做题目之前要先试着找找题目的数学规律

与其电脑发呆，不如在纸上先写写画画

在本题目中，九宫格里只要三个确定格中只要有中心格且另外两个格子不与中心格在同一列/行的话，其他所有格子都是有确定的数学规律的。

一旦找到了数学规律，时间、空间复杂度均可以大大降低。

于是本题解如下：


------------

```cpp
#include<iostream>
using namespace std ;

int main()
{
    int a , b , c ;
    cin >> a >> b >> c ;
    cout << a <<" "<< b <<" "<< 3*c-a-b <<" "<< endl ;
    cout << 4*c-2*a-b <<" "<< c <<" "<< 2*a+b-2*c <<" "<< endl ;
    cout << a+b-c <<" "<< 2*c-b <<" "<< 2*c-a <<" "<< endl ;
    return 0 ;
}
```


------------



---

## 作者：几时明月 (赞：0)

这可以算是一道小学奥数题，你可以拿出纸笔，在纸上填一下。

### 这题和幻方是同一种类型的，所以，也可以参考一下这：
```
1.先把1放在第一行的中间位置；
2.下一个数放在上一个数的右上方；
3.若右上方已超出方阵的第一行，则下一个数放在下一列的最后一行上；
4.若右上方已超出方阵的最后一列，则下一个数放在上一行的第一列上；
5.若右上方已经有数，或右上方已超出方阵的第一行最后一列，则下一个数放在上一个数的正下方。
```
这是幻方的做法，这题也比幻方简单得多，给了你三个数，不会的真的建议你们在纸上写写，找到规律。

找到规律后，便可以轻松写出了。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std ;
int main()
{
    int a , b , c ;
    cin>>a>>b>>c ;
    cout<<a<<" "<< b<<" "<<3*c-a-b<<" "<<endl ;
    cout<<4*c-2*a-b<<" "<<c<<" "<<2*a+b-2*c<<" "<<endl ;
    cout<<a+b-c<<" "<<2*c-b<<" "<<2*c-a<<" "<<endl ;
    return 0 ;
}
```


---

## 作者：__builtin_orz (赞：0)

这一题个人觉得很简单吧，直接计算就可以了。  
这是关于幻方的一个知识：
```
每行，每列，每个对角线的和都是中间数的三倍

```
对于这题来说，这一个知识点就够了。  
接下来看代码：
```cpp
#include<bits/stdc++.h>//万能头文件，当然，这题只要用include<iostrean>就行了 
using namespace std;//名字命名空间 
//变量也可以定义在这里哟 
int main()//主函数，后面大括号里面是要运行的代码 
{
    int a,b,c;//定义变量 
    cin>>a>>b>>c;//读入数据：a,b,c 
    /*
		第一行第一个a：题目给出
		第一行第二个b：题目给出
		第二行第二个c：题目给出 
		第一行第三个c*3-a-b：因为幻方每一行的和都是中间数的三倍，所以是c*3-a-b
		第三行第三个c*2-a：还是幻方原理：3*c-a-c=2*c-a
		因为第一行第三个和第三行第三个都知道了，就能求第二行第三个了：c*3-(c*3-a-b)-(c*2-a)=c*3-c*3+a+b-c*2+a=-c*2+2*a+b
		已知第一行第二个和第二行第二个，所以第三行第二个就可以知道了：c*3-b-c=c*2-b
		已知第二行第二个和第二行第三个，所以第二行第一个就可以知道了；c*3-c-(a*2+b-c*2)=c*3-c-a*2-b+c*2=c*3-c+c*2-b+a*2=c*4-b+a*2
		最后一个第三行第一个也可以知道了，就是：c*3-a-(4*c-a*2-b)=c*3-a-4*c+a*2+b=b+a-c 
		知道怎么计算之后，就可以直接输出了 
	*/
    cout<<a<<" "<<b<<" "<<c*3-a-b<<"\n";//输出第一行，"\n"是换行的意思，相当于endl，记得输出空格！ 
	cout<<4*c-a*2-b<<" "<<c<<" "<<a*2+b-c*2<<"\n";//输出第二行 
	cout<<b+a-c<<" "<<c*2-b<<" "<<c*2-a;//输出第三行 
    return 0;//结束程序 
}
```
是不是很简单呢？  
再给大家推荐一个有关幻方的题目吧：  
[	[NOIP2015 提高组] 神奇的幻方](https://www.luogu.com.cn/problem/P2615)  
求过，求赞

---

## 作者：智子·起源 (赞：0)

其实楼下的方法我非常的佩服。

## 对于求和是多少，我们也可以枚举。
### 思路很简单，写法……其实也不难。

### 实在不知道的话也可以看看下面加注释的代码。^_^

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int f[3][3];
int main()
{
  scanf("%d%d%d",&f[0][0],&f[0][1],&f[1][1]);
  for(int i=0;;i++)
  {
    f[0][2]=i-f[0][0]-f[0][1];
    f[2][0]=i-f[0][2]-f[1][1];
    f[2][1]=i-f[0][1]-f[1][1];
    f[2][2]=i-f[0][0]-f[1][1];
    f[1][0]=i-f[0][0]-f[2][0];
    f[1][2]=i-f[0][2]-f[2][2];//根据和还有三个数的信息初步求出剩下空位上的数。
    if(f[0][0]+f[0][1]+f[0][2]==i&&f[1][0]+f[1][1]+f[1][2]==i&&f[2][0]+f[2][1]+f[2][2]==i&&f[0][0]+f[1][0]+f[2][0]==i&&f[0][1]+f[1][1]+f[2][1]==i&&f[0][2]+f[1][2]+f[2][2]==i&&f[0][0]+f[1][1]+f[2][2]==i&&f[0][2]+f[1][1]+f[2][0]==i)
//判断如果符合条件
    {
      printf("%d %d %d\n%d %d %d\n%d %d %d\n",f[0][0],f[0][1],f[0][2],f[1][0],f[1][1],f[1][2],f[2][0],f[2][1],f[2][2]);
      return 0;
//那就输出并停止运行。
    }
  }
}
```

### 如果这篇题解帮助了你，帮忙点个赞，谢谢^_^

---

## 作者：laoda (赞：0)

## 首先，这是三阶幻方，并非~~高大上的~~“魔方阵”。
关于三阶幻方的芝士，戳[这里](https://baike.baidu.com/item/三阶幻方/726749?fr=aladdin)。

~~（因为本人还是小学生，所以使用老师新教的解法，各位看官不要介意）~~

首先，列出一个幻方。

```
a  b  c
d  e  f
g  h  i
```

然后......
```
因为a,b,e已知
而幻和为3*e,所以
c=3*e-a-b;
h=2*e-b;
f=2*a-h;  //弹弓法：a=(f+h)/2;
i=3*e-c-f;
d=2*e-f;
g=3*e-h-i;
```

所以有了推导过程，我们上代码
```
#include<bits/stdc++.h>//万能头
using namespace std;
int a,b,c,d,e,f,g,h,i;
int main()
{
	cin>>a>>b>>e;	//输入
	c=3*e-a-b;	//复制一遍即可
	h=2*e-b;
	f=2*a-h;
	i=3*e-c-f;
	d=2*e-f;
	g=3*e-h-i;
	printf("%d %d %d\n%d %d %d\n%d %d %d",a,b,c,d,e,f,g,h,i);	//输出
	return 0;
}
```


---


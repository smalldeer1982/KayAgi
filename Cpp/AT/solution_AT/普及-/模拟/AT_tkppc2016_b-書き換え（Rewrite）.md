# 書き換え（Rewrite）

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tkppc2/tasks/tkppc2016_b

joisinoお姉ちゃんの次の仕事は、書類の書き換えである。  
 書類は$ N $個あり、それぞれに、重要度と、書き換えるのにかかる時間が決まっている。  
 joisinoお姉ちゃんはどうしても定時に帰りたいので、あと作業できる時間は$ M $しかない。  
 そこでjoisinoお姉ちゃんは、時間内に書き換える書類の重要度の合計の最大化したいと思い、その最大値を求めるプログラムを作ることにした。

## 说明/提示

### Sample Explanation 1

$ 2 $番目と$ 3 $番目の書類を書き換える。

## 样例 #1

### 输入

```
3 3
1 2
6 1
4 1```

### 输出

```
10```

## 样例 #2

### 输入

```
10 10
92231 7
70370 1
4423 10
96481 4
69142 2
91784 3
16328 3
85936 8
93166 2
17394 1```

### 输出

```
351801```

# 题解

## 作者：Fr0sTy (赞：1)

### 题意概述
------------
给出 $n$ 和 $m$。分别表示物品数量和背包容量。

接下来 $n$ 行，分别输入 $v_i$ 和 $w_i$ （题目中称 $t_i$），表示物品价值和物品重量。

### 解题思路
------------
一道简单的 **01 背包** ，需要判断两种状态，分别是 **取** 或 **不取**。如果取到这个物品，可以增加价值，但会减少背包容量。

我们可以定义一个数组 $dp$， 用来表示各种容量时的**价值**。最后输出 $dp_m$ 即可。

众所周知，**01 背包** 用 $i$ 来枚举**物品**，用 $j$ 来枚举**重量**（注意是倒序）。

所以可以有这样的代码：

``` cpp
for(int i=1;i<=n;i++) {
		for(int j=m;j>=w[i];j--)
			//你的状态转移方程
}
```

然后思考**状态转移方程**：

首先，我们知道每种物品可以选择**取**或**不取**。

在取的情况下，可以写出：

$$dp_j = dp_{j-w_i}+v_i$$

即 `dp[j]=dp[j-w[i]]+v[i]`。

在不取的情况下，亦可以有：

$$dp_j=dp_j$$

即`dp[j]=dp[j]`。

我们需要总价值最大，所以有状态转移方程

$$dp_j = max_{dp_{j-w_i}+v_i}^{dp[j]}$$

即 `dp[j]=max(dp[j],dp[j-w[i]]+v[i])`。

### 代码实现
------------
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v[1000005],w[1000005],dp[1000005];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d",&v[i],&w[i]);
	for(int i=1;i<=n;i++) {
		for(int j=m;j>=w[i];j--)
			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
	}
	printf("%d",dp[m]);
	return 0;
}
```


---

## 作者：_acat_ (赞：1)

此题建议评橙。
### 闲话
此题跟 P1048 采药 很像，大家如果 A 了这道题后可以去拿双倍经验。题目链接：[Link](https://www.luogu.com.cn/problem/P1048)
### 题目大意
$n$ 个文件，每个文件的重要度是 $v_i$，所花用的时间是 $t_i$，时间为 $m$ ，求在用在这些时间内完成文件的重要度的和的最大值。
### 思路 1——二维 DP
设 $f_{i,j}$ 从 $1$ 到 $i$ 件物品中选若取干件放到容量为 $j$ 的背包中，获得的最大价值。目标是: $f_{n,m}$。

用 $f_{i,j}$ 表示在第 $1$ 到第 $i$ 件物品中选择若干件到载重量为 $j$ 的背包中所能获得的最大价值。
- $f_{i-1,i}$:不放第 $i$ 件物品获得的价值。
- $f_{i-1,j-w_i}+c_i$:放第 $i$ 件的价值。

方程如下：$f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_i}+c_i)$

代码就不给了。

### 思路 2——一维 DP
$f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_i}+c_i)$

$f_{i,j}$ 只与前一行有关系，所以可以滚动数组(随时更新，无需保留以前的)。

$j$ 的枚举顺序必须从大到小，理解原因: 
右边的 $f_j$ 是原来的 $f_{i-1,j}$,右边的 $f_j$ 是更新后的是 $f_{i,j}$。

那么方程就是：$f_{i,j}=\max{i,f_{j-w_i}+c_i}$

代码就不给了，建议自己写。



---

## 作者：锦阳2006 (赞：0)

题目大意:   
有$n$个文件，重要度为v[i],完成时间为t[i],求在$m$时间内完成文件重要度的最大值。

因为一个文件只能写一次，所以此题是一个01背包模板题，只需要将P1048的代码稍加改动即可   

上代码
```c
#include<bits/stdc++.h>//万能头文件
using namespace std;
int f[100001],w[100001],c[100001],m,n;//定义
int main() {
	scanf("%d %d",&n,&m);//输入
	for(int i=1; i<=n; i++)scanf("%d %d",&c[i],&w[i]);
	for(int i=1; i<=n; i++)
	for(int j=m; j>=w[i]; j--) //01背包反向循环
                {
		f[j]=max(f[j],f[j-w[i]]+c[i]);//dp转移方程
		}
	printf("%d\n",f[m]);//输出
	return 0;
}
```


---


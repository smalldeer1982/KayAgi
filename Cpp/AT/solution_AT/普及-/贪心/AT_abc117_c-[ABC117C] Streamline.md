# [ABC117C] Streamline

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc117/tasks/abc117_c

数直線と $ N $ 個のコマを用いて $ 1 $ 人でゲームを行います。

はじめ、これらのコマをそれぞれ好きな整数座標に置きます。

このとき、同じ座標に複数のコマを置いても構いません。

以下の移動を繰り返して、座標 $ X_1,\ X_2,\ ...,\ X_M $ の $ M $ 個の地点全てをいずれかのコマで訪れることが目的です。

**移動**: コマを $ 1 $ つ選び、そのコマの座標を $ x $ とする。そのコマを座標 $ x+1 $ もしくは座標 $ x-1 $ に移動する。

ただし、最初にコマを置いた座標はその時点で訪れたとみなします。

目的を達成するまでに移動を行う回数の最小値を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ -10^5\ \leq\ X_i\ \leq\ 10^5 $
- $ X_1,\ X_2,\ ...,\ X_M $ は全て異なる。

### Sample Explanation 1

以下の手順で $ 5 $ 回移動を行うと目的を達成でき、このときが最小です。 - はじめに $ 2 $ 個のコマをそれぞれ座標 $ 1 $, 座標 $ 10 $ に置きます。 - 座標 $ 1 $ のコマを座標 $ 2 $ に移動します。 - 座標 $ 10 $ のコマを座標 $ 11 $ に移動します。 - 座標 $ 11 $ のコマを座標 $ 12 $ に移動します。 - 座標 $ 12 $ のコマを座標 $ 13 $ に移動します。 - 座標 $ 13 $ のコマを座標 $ 14 $ に移動します。

## 样例 #1

### 输入

```
2 5
10 12 1 2 14```

### 输出

```
5```

## 样例 #2

### 输入

```
3 7
-10 -3 0 9 -100 2 17```

### 输出

```
19```

## 样例 #3

### 输入

```
100 1
-100000```

### 输出

```
0```

# 题解

## 作者：_dijkstra_ (赞：2)

小号写水题题解。

## 思路

贪心。首先对 $x_i$ 从小到大排序。

容易发现，如果啥棋子都没有，最少要走 $x_m - x_1$ 的距离。

对于有棋子的情况，我们应该尽可能省略**较长一段的行走**。

对于相邻两点，$dis_i = x_{i + 1} - x_i$。

那么，我们对 $dis$ 从大到小排序，用 $(x_m - x_1)$ 减掉前 $(n - 1)$ 大的距离（第一个点要放棋子，所以不是 $n$）即可。

代码实现模拟即可。可以省略掉 $dis$ 数组。

## 代码

远古代码，码风独特，凑合着看看。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int x[100005];
bool cmp(int p, int q) {return p > q;}
int main()
{
	int n, m;
	scanf("%d%d", &n, &m);
	if (n >= m)
	{
		//如果棋子数比目标点还多，就只需在每一个点上放棋子。
		//这样便不需要移动。 
		printf("0");
		return 0;
	}
	for (int i = 1; i <= m; i++) scanf("%d", &x[i]);
	//从小到大排。
	sort(x+1, x+m+1);
	int d = x[m] - x[1];
	for (int i = 1; i < m; i++) x[i] = x[i+1] - x[i]; //计算距离。 
	sort(x+1, x+m, cmp);  //从大到小排。
	for (int i = 1; i < n; i++) d -= x[i];
	printf("%d", d);
	return 0;
}
```

---

## 作者：wbs200 (赞：1)

这道题是一道贪心，适合初学者用来练习。做完这道题，还可以做与它思路一样的[P1209 [USACO1.3]修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1209)。

我们可以来看看样例来找思路。拿样例 $1$ 举例子：

首先将 $2$ 个棋子分别放在坐标 $1$ 和 $10$ ，然后进行 $5$ 步移动：

坐标 $1$ 的棋子移动到坐标 $2$；

坐标 $10$ 的棋子移动到坐标 $11$；

坐标 $11$ 的棋子移动到坐标 $12$；

坐标 $12$ 的棋子移动到坐标 $13$；

坐标 $13$ 的棋子移动到坐标 $14$。

仍拿样例 $1$ 举例。共用 $5$ 次操作，怎么减才能使两枚旗子移动的总距离最少呢？显然应该减掉 $2$ 到 $10$ 这一段。也就是说，第一枚旗子在坐标 $1$ - $2$范围内移动，第二枚棋子在坐标 $10$ - $14$ 范围内移动。其实要求的次数就是长度。

上代码：

```c
#include <iostream>
#include <algorithm>
using namespace std;

int a[100010], d[100010];

bool cmp(int x, int y)
{
	return x > y;
}

int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> a[i];// 首先把m个坐标点输入
    }
    sort(a + 1, a + m + 1);// 进行由小到大的排序
    for (int i = 1; i <= m - 1; i++)
    {
        d[i] = a[i + 1] - a[i];// 算出任意两点的距离
    }
    sort(d + 1, d + m, cmp);// 再把距离进行由大到小的排序，注意不要写d + m + 1
    // 贪心
    int sum = a[m] - a[1];
    for (int i = 1; i <= n - 1; i++)
    {
        sum -= d[i];
    }
    cout << sum << endl;// 输出答案
    return 0;// 结束
}
```

---

## 作者：猜一猜我是谁 (赞：0)

# 思路
先来看看样例 1。

将 2 个棋子分别放在坐标 1 和 坐标 10，第一个棋子向右移动 1 次，第二个棋子分别向右移动 5 次。

为什么这是最优解呢？因为这种方法少走了中间一个最长的距离。

所以利用贪心思想，将相邻目标点之间的距离降序排序，最后减去前 (n-1) 个距离。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],d[100005];//a 存储目标点的坐标，d 存储相邻目标点之间的距离
bool cmp(int x,int y){
    return x>y;
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>a[i];
    sort(a+1,a+m+1);//先将这些坐标升序排序
    for(int i=1;i<m;i++) d[i]=a[i+1]-a[i];//计算距离
    sort(d+1,d+m,cmp);//再将距离降序排序
    int ans=a[m]-a[1];
    for(int i=1;i<n;i++) ans-=d[i];//一直减到 d[n-1]
    cout<<ans;
}
```

---

## 作者：Ninelife_Cat (赞：0)

这道题首先一个很显然的贪心思路就是我们必须依次遍历每个目标点，这样不会走回头路，移动次数显然更少，并且因为题目说 “最初放置棋子的位置也视作访问到” ，所以我们放棋子的位置肯定是选择某个目标点。

我们可以把一个棋子移动的范围看作是一段区间，那么问题就被转化为求覆盖所有目标点的区间长度和的最小值。

假如我们多了一个棋子，就可以把一段区间拆成两段区间，这样就能少算这两段区间中间的那一截距离。

那么答案就是每两个目标点之间距离的总和减去最大的 $n-1$ 个距离。

核心代码：

```cpp
const int N=1e5+10;
int n,m,ans,a[N],b[N];
signed main()
{
	n=read();m=read();
	for(ri int i=1;i<=m;++i)
		a[i]=read();
	sort(a+1,a+m+1);//对目标点位置进行排序,方便计算
	for(ri int i=1;i<m;++i)
		b[i]=a[i+1]-a[i];
	sort(b+1,b+m);//计算出每两个目标点之间的距离并排序
	for(ri int i=1;i<=m-n;++i)
		ans+=b[i];
	cout<<ans;
	return 0;
}

---


# ニコニコレベル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dwacon2017-prelims/tasks/dwango2017qual_b

ニコニコ文字列とは、`25` を $ 0 $ 回以上繰り返した文字列のことをいいます。たとえば `25` や `252525` や空文字列はニコニコ文字列ですが、`123` や `225` はニコニコ文字列ではありません。

ある文字列 $ S $ がその連続した部分文字列として含む最長のニコニコ文字列の長さを $ S $ の **ニコニコレベル** といいます。 たとえば `52525`, `25025`, `12151` のニコニコレベルはそれぞれ $ 4 $, $ 2 $, $ 0 $ です。

ニワンゴくんは `0` から `9` の数字と `?` からなる文字列 $ T $ を持っており、それぞれの `?` を好きな数字に置き換えることで、数字のみからなる文字列 $ T' $ を作ろうとしています。ニワンゴくんが作ることのできる文字列 $ T' $ のニコニコレベルの最大値を求めて下さい。

## 说明/提示

### 制約

- $ 1\ ≦\ |T|\ ≦\ 10^5 $
- $ T $ の文字は $ 0 $ から $ 9 $ の数字か `?` のいずれかである。

### Sample Explanation 1

`?` を前から順に `5` と `2` に置き換えて `1252567890` とすると、$ 2 $ 文字目から $ 5 $ 文字目が `2525` となり、ニコニコレベル $ 4 $ の文字列を作ることができます。

### Sample Explanation 3

`25` が全く現れない文字列はニコニコレベル $ 0 $ になります。

## 样例 #1

### 输入

```
12??567890```

### 输出

```
4```

## 样例 #2

### 输入

```
65?5?4?```

### 输出

```
2```

## 样例 #3

### 输入

```
314159265358979```

### 输出

```
0```

## 样例 #4

### 输入

```
2???5????```

### 输出

```
8```

## 样例 #5

### 输入

```
52```

### 输出

```
0```

# 题解

## 作者：Stone_Xz (赞：3)

## [传送门](https://www.luogu.com.cn/problem/AT_dwango2017qual_b)

这道题一眼就满满 dp 的味道。

## 分析：dp

 - 字符串中的 ```?``` 既可以作为 $2$，也可以作为 $5$。
 
 - 状态：$dp2[i]$ 表示字符串的第 $i$ 个位置为 $2$ 时的 Nico 级别。$dp5[i]$ 表示字符串的第 $i$ 个位置为 $5$ 时的 Nico 级别。
 
 - 答案：显然，一个 Nico 字符串的结尾是 $5$，答案为最大的 $dp5[i]$。
 
 - 状态转移：让我们观察一下 Nico 字符串，$2$ 的前面是 $5$，$5$ 的前面是 $2$。注意，$2$ 前面可以没有 $5$（第一个 $2$），但 $5$ 前面必须有 $2$。
 
 然后我们就能推出状态转移方程：
 
 如果点 $i$ 为 $2$：
 
 $dp2_i = dp5_{i - 1} + 1;$
 
 如果点 $i$ 为 $5$：
 
 如果：$dp2_{i - 1} \geqslant 1$，那么 $dp5_i = dp2_{i - 1} + 1;$
 
 - 时间复杂度：线性，$O(T)$。
 
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
int dp_2[100005], dp_5[100005];

int main()
{
	cin >> s;
	int len = s.size();
	s = "#" + s;
	for(int i = 1; i <= len; i++)
	{
		if(s[i] == '?' || s[i] == '2')
			dp_2[i] = dp_5[i - 1] + 1;
			
		if((s[i] == '?' || s[i] == '5') && dp_2[i - 1] >= 1)
			dp_5[i] = dp_2[i - 1] + 1;
	}
	int maxi = 0;
	for(int i = 1; i <= s.size(); i++)
		maxi = max(maxi, dp_5[i]);
	cout << maxi;
	return 0;
}
```

其实循环中的两个判断能调换顺序，因为两个 $dp$ 数组的维护只用到了前一个状态。

---

## 作者：__owowow__ (赞：1)

### AT_dwango2017qual_b ニコニコレベル题解
[洛谷传送门](https://www.luogu.com.cn/problem/AT_dwango2017qual_b)

[ATCoder传送门](https://atcoder.jp/contests/dwacon2017-prelims/tasks/dwango2017qual_b)

### 题目大意
定义由字符串 ```25``` 重复了若干次的字符串称之为 Nico 字符串。比如 ```2525252525``` 就是一个 Nico 字符串。

**空串也是 Nico 字符串！**

定义一个字符串的 Nico 等级为该字符串中最长的 Nico 子串的长度。当然，如果该字符串不含有 ```25``` 字串，则该字符串的 Nico 等级为 $0$。

现在有一个由 $0$ 到 $9$ 的数字和字符 ```?``` 组成的字符串。要将字符串中的 ```?``` 替换成数字，求出替换后该字符串 Nico 级别的最大值。

### 思路
使用动态规划算法。定义数组 $f2[i]$ 表示在第 $i$ 格填入 $2$ 时的最大 Nico 等级，数组 $f5[i]$ 表示在第 $i$ 格填入 $5$ 时的最大 Nico 等级。显然，答案为 $f5[i]$ 中的最大值。接下来的问题就是如何求出 $f5[i]$ 了。

如果在第 $i$ 个位置填 $2$，则前面不需要有数字，转移为：

$f2[i]=f5[i-1]+1$。


如果在第 $i$ 个位置填 $5$，则前面必须要有个数字 $2$，转移为：

$f5[i]=f2[i-1]+1 \quad f2[i-1] \neq 0$

### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int f2[100001],f5[100001],ans;
signed main(){
    cin>>s;
    for(int i=0;i<s.size();i++){
        if(s[i]=='2'||s[i]=='?') f2[i]=f5[i-1]+1;
        if((s[i]=='5'||s[i]=='?')&&f2[i-1]>=1) f5[i]=f2[i-1]+1;
    }
    for(int i=1;i<s.size();i++) ans=max(ans,f5[i]);
    cout<<ans;
    return 0;
}

```

---

## 作者：Kvaratskhelia (赞：1)

**题目大意**

定义由 ```25``` 重复 $0$ 次及以上组成的字符串为 Nico 字符串，例如： ```252525``` 和空字符串都是 Nico 字符串。

定义一个字符串中最长的 Nico 子串的长度为该字符串的 Nico 级别。

现在有一个由 $0$ 到 $9$ 的数字和 ```?``` 组成的字符串，请将字符串中的 ```?``` 替换成数字，求出替换后该字符串 Nico 级别的最大值。

**分析**

这个问题类似于取数问题，就是在 ```?``` 中放入 $2$ 或 $5$ ，求最大的 Nico 级别，因此可以用简单的线性动态规划解决。

设 $f_{i,1}$ 表示当前位置加入 $2$ 时最大的 Nico 长度，那么当当前字符是 $2$ 或是 ```?``` 时就将其长度加一。

设 $f_{i,2}$ 表示当前位置加入 $5$ 时最大的 Nico 长度，则当前字符为 $2$ 或 ```?``` 时，需要判断前面有没有一个 $2$ ,然后再将长度加一。

所以可以写出如下的状态转移方程（省略了字符条件）：

$$ \begin{cases}f_{i+1,1}=f_{i,2}+1\\f_{i+1,2}=f_{i,1}+1 & f_{i,1}>0\end{cases} $$

然后求出数组 $f_{i,2}$ 的最大值即可。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
int ans,f[233333][3];
int main()
{
	cin>>st;
	for(int i=0;i<int(st.size());i++)
	{
		if(st[i]=='2'||st[i]=='?') f[i+1][1]=f[i][2]+1;
		if(st[i]=='5'||st[i]=='?') 
			if(f[i][1]>0) f[i+1][2]=f[i][1]+1;
		ans=max(ans,f[i+1][2]);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Hope888 (赞：0)

由于每位对答案所造成的贡献只与上一位填了什么有关，所以考虑 dp。

设 dp 状态 $f_{i,j}$ 现在填到第 $i$ 位，当前这位填了 $j$ 的最大答案。

由于 $j$ 只有是 $2$ 或 $5$ 对答案才有贡献，所以只需更新一个位置的 $2$ 和 $5$ 的答案。

转移可分为 $2$ 种情况：

1. 如果这位是 $?$ 和 $2$，由于它们都可以当做开头，$f_{i,2}=1$

2. 这位是 $?$ 或者 $2$：当 $i-1$ 位是 $?$ 或者 $5$ 时 $f_{i,2}=f_{i-1,5}+1$

3. 这位是 $?$ 或者 $5$：当 $i-1$ 位是 $?$ 或者 $2$ 时 $f_{i,5}=f_{i-1,2}+1$

注意到 Nico 字符串只可能由 $5$ 结尾，所以 $Ans=\max_{i=1}^n f_{i,5}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,f[1000005][10]; 
string s;
int main()
{
	cin>>s;
	s=" "+s;
	for(int i=1;i<s.size();i++)
	{
		if(s[i]=='2'||s[i]=='?')f[i][2]=1;
		if(s[i-1]=='2'||s[i-1]=='?'&&s[i]=='5'||s[i]=='?')f[i][5]=f[i-1][2]+1;
		if(s[i-1]=='5'||s[i-1]=='?'&&s[i]=='2'||s[i]=='?')f[i][2]=f[i-1][5]+1;
		ans=max(ans,f[i][5]); 
	}
	cout<<ans;
}
```

---

## 作者：_xdd_ (赞：0)

第一眼觉得是贪心，但观察样例后发现是一道 DP，由于填入其他数不会增加 Nico 值，所以只考虑填入 $2$ 或 $5$ 的情况。

用 $f_{i,1}$ 表示第 $i$ 个格子如果填入数字 $2$ 得到的 Nico 值，$f_{i,2}$ 表示第 $i$ 个格子如果填入数字 $5$ 得到的 Nico 值。

对于 $f_{i,1}$，如果这个字符是 `2` 或 `?` 时，那么 $f_{i,1} \leftarrow f_{i-1,2}+1$。

对于 $f_{i,2}$，如果这个字符是 `5` 或 `?` 且前面的字符填的是 `2` 时，那么 $f_{i,2} \leftarrow f_{i-1,1}+1$。

答案就是最大的 $f_{i,2}$。

核心代码：
```cpp
for(int i=0;i<strlen(a);i++){
  if(a[i]=='2' || a[i]=='?'){
    f[i][1]=f[i-1][2]+1;
  }
  if((a[i]=='5' || a[i]=='?') && f[i-1][1]>0){
    f[i][2]=f[i-1][1]+1;
  }
  ans=max(ans,f[i][2]);
}
```

---

## 作者：jwhou (赞：0)

这个问题类似于取数问题，就是把 ```?``` 变成 2 或 5，求最大的  ```Nico``` 级别，因此可以用简单的线性动态规划解决。

$dp[i][1]$ 表示表示在第 $i$ 格填入 2 时的最大 ```Nico``` 等级，

$dp[i][2]$ 表示表示在第 $i$ 格填入 5 时的最大 ```Nico``` 等级，

状态转移方程在代码和注释中给出。

最后的答案就是最大的 $dp[i][1]$ 与 $dp[i][2]$，但是如果子串中最后一个数是 2，这个 2 无法贡献一个 ```Nico``` 等级，所以只考虑最大的 $dp[i][2]$ 即可。
```cpp
#include<iostream>
using namespace std;

string st;
int ans,dp[200002][3];

int main()
{
	cin>>st;
	for(int i=0;i<st.length();i++)
	{
		if(st[i]=='2'||st[i]=='?')
			dp[i+1][1]=dp[i][2]+1; // 当前字符是2或?时等级加一
		if((st[i]=='5'||st[i]=='?')&&dp[i][1]>0)
			dp[i+1][2]=dp[i][1]+1; // 当前字符是5或? 且前面有2时等级加一
		ans=max(ans,dp[i+1][2]);
	}
	cout<<ans;
	return 0;
}
```

~~第一篇题解，管理员大大求过~~

---

## 作者：Akaurora (赞：0)

一道比较简单的 dp

-------

### 题目解析
显然，要想得到最长的 Nico 级别，`?` 只有 `2` 和 `5` 两种选择。

因此我们在 `?` 中填完 `2` 和 `5` 后，再去寻找最大的 Nico 级别就行了。

设置两个数组 $f2_i$ 和 $f5_i$，分别代表以 `2` 为结尾和以 `5` 结尾时的最大 Nico 级别，由于级别要求要完整的 `25`，所以最后拿 $f5_i$ 进行比较。

对于 $f2_i$，前面有没有 `5` 的影响不大，而对于 $f5_i$ ，则需要考虑前面是否有 $f2_{i-1}$ 或者 `?`。

再加上

$$ f2_i = f5_{i-1} + 1 $$
$$ f5_i = f2_{i-1} + 1 $$

所以我们有代码
```cpp
if(t[i]=='2'||t[i]=='?') f2[i]=f5[i-1]+1;
if((t[i]=='5'||t[i]=='?')&&f2[i-1]>=1) f5[i]=f2[i-1]+1;
```

那么这题就解出来了

### 个人代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
string t;
ll f2[200000],f5[200000];
ll ans;
int main()
{
	ios::sync_with_stdio(false);
	cin>>t;
	for(int i=0;i<=t.length();i++){
		if(t[i]=='2'||t[i]=='?') f2[i]=f5[i-1]+1;
		if((t[i]=='5'||t[i]=='?')&&f2[i-1]>=1) f5[i]=f2[i-1]+1;
	}
	for(int i=1;i<=t.length();i++){
		ans=max(ans,f5[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Weekoder (赞：0)

# AT_dwango2017qual_b ニコニコレベル 题解

## 题目大意

有一个字符串 $T$，其中有一些字符是数字，有一些是 $\texttt{?}$，有 $\texttt{?}$ 的地方可以填入任意数字。求如何填入数字使得字符串中的一个由 $\texttt{25}$ 不断复制而来的子串长度尽可能大，输出这个子串长度。

## 分析

首先分析题目主要是让我们干一件什么事。显然，是要在 $\texttt{?}$ 的地方填数字。既然是要求由 $\texttt{25}$ 不断复制而来的子串，那么填 $\texttt{2,5}$ 之外的数字是没有意义的。

继续观察样例，通过第 $4$ 个样例发现，不是普通的有 $\texttt{2}$ 填 $\texttt{5}$，有 $\texttt{5}$ 填 $\texttt{2}$，而是有取舍的。这时候不妨考虑 DP 求解。

设 $dp2_i$ 为以第 $i$ 位结尾的且为 $\texttt{2}$ 的最长长度，$dp5_i$ 为以第 $i$ 位结尾的且为 $\texttt{5}$ 的最长长度。对于 $\texttt{5}$ 和 $\texttt{2}$，可以直接从上一位转移，则有状态转移方程：

$$ \left\{
\begin{aligned}
dp2_i & = \max(1,dp5_{i-1}+1) \\
dp5_i & = dp2_{i-1}+1
\end{aligned}
\right.
$$

而对于 $\texttt{?}$，则两种转移都有，因为 $\texttt{?}$ 既可以是 $\texttt{2}$，也可以是 $\texttt{5}$。

而我们知道，以 $\texttt{25}$ 复制而来的字符串结尾是 $\texttt{5}$。所以，答案就要在 $dp5_i$ 中取最大值，即

$$
\max_{i=0}^{|s|-1}dp5_i
$$

# $\text{Code:}$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;

string s;
int dp2[N], dp5[N];

int main() {
    cin >> s;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '2') dp2[i] = max(1, (i ? dp5[i - 1] + 1 : 0));
        else if (s[i] == '5' && i && (s[i - 1] == '2' || s[i - 1] == '?')) dp5[i] = dp2[i - 1] + 1;
        else if (s[i] == '?') {
            dp2[i] = max(1, (i ? dp5[i - 1] + 1 : 0));
            if (i && (s[i - 1] == '2' || s[i - 1] == '?')) dp5[i] = dp2[i - 1] + 1;
        }
    }
    int ans = -1e9;
    for (int i = 0; i < s.size(); i++)
        ans = max(ans, dp5[i]);
    cout << ans;
    return 0;
}
```

---


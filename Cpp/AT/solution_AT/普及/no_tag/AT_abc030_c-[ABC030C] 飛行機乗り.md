# [ABC030C] 飛行機乗り

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc030/tasks/abc030_c

ウナギの高橋くんは飛行機に乗ることが趣味です。今回は空港Aと空港Bを往復することにしました。

空港Aから空港Bの飛行機には $ X $ 時間かかり、空港Bから空港Aへの飛行機には $ Y $ 時間かかります。 空港Aから空港Bへの飛行機は $ N $ 本あり、$ i $ 番目の便は $ a_i $ 時に出発します。 空港Bから空港Aへの飛行機は $ M $ 本あり、$ j $ 番目の便は $ b_j $ 時に出発します。

ある飛行機には、出発する空港に出発する時刻以前にいれば乗ることができます。出発する時刻ちょうどに到着した場合も、すぐに飛行機に乗って出発できます。 高橋くんははじめ空港Aに $ 0 $ 時にいます。 空港Aと空港Bの間を最大何往復できるか調べてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 30 $ 点分のテストケースにおいて、$ 1\ ≦\ a_i\ ≦\ 10^5,\ 1\ ≦\ b_j\ ≦\ 10^5\ (\ 1\ ≦\ i\ ≦\ N,\ 1\ ≦\ j\ ≦\ M) $ を満たす。

### Sample Explanation 1

$ 1 $ 時の空港Aを出発する飛行機に乗り、$ 3 $ 時に到着しますが、すぐに $ 3 $ 時の空港Bを出発する飛行機に乗り、$ 6 $ 時に空港Aに到着します。 次に、$ 7 $ 時の空港Aを出発する飛行機に乗り、$ 9 $ 時に到着、$ 12 $ 時の空港Bを出発する飛行機に乗ると、合計 $ 2 $ 往復できます。$ 3 $ 往復する手段はありません。

### Sample Explanation 2

空港Bに行くと空港Aに帰れないので、$ 1 $ 度も往復できません。

## 样例 #1

### 输入

```
3 4
2 3
1 5 7
3 8 12 13```

### 输出

```
2```

## 样例 #2

### 输入

```
1 1
1 1
1
1```

### 输出

```
0```

## 样例 #3

### 输入

```
6 7
5 3
1 7 12 19 20 26
4 9 15 23 24 31 33```

### 输出

```
3```

# 题解

## 作者：Keids (赞：5)

# AT_abc030_c 飛行機乗り 题解

原题链接：<https://atcoder.jp/contests/abc030/tasks/abc030_c>

洛谷链接：<https://www.luogu.com.cn/problem/AT_abc030_c>

建议评橙。

一道模拟题。

我们要求来往的最多次数，那么直接用双指针模拟整个过程即可。

记录 $l$ 表示 $a$ 机场到了第 $l$ 个时间点， $r$ 表示 $b$ 机场到了第 $r$ 个时间点。

再记录一个 $t$ 表示全局的时间，$side$ 表示位于哪一个机场。

那么我们每次只需要：

对于从 $a$ 到 $b$ 的情况找满足 $t+x>b[r]$ 的一个最小的 $r$。

对于从 $b$ 到 $a$ 的情况找满足 $t+y>a[l]$ 的一个最小的 $l$。

然后统计答案即可。

对于统计答案，因为来往一次才对答案做出贡献，所以最后需要特判一下。

如果你 WA 了，但是样例本地过了，那么就是最后输出的时候没有换行。因为我就这么寄的！

代码如下：

```c++
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1e5+10;
int n,m,x,y;
int a[N],b[N];
int maxn=0,ans=0;
int main(){
	scanf("%d%d",&n,&m);
	scanf("%d%d",&x,&y);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)scanf("%d",&b[i]);
	maxn=max(a[n],b[m]);//其实这个没什么必要
	int side=1,t=a[1],l=1,r=1;
	while(114514!=1919810){
		if(t>maxn)break;//这里也没必要，因为肯定会在到达maxn之前跳出
		if(side==1){			
			while(t+x>b[r]){//找r
				r++;
				if(r>m)goto en;
			}
			t=b[r];side=2;
		}
		else{
			while(t+y>a[l]){//找l
				l++;
				if(l>n)goto en;
			}
			t=a[l];side=1;
			ans++;
		}
	}
	en:
	if(side==2)ans++;//特判最后一次是否为一个来回
	printf("%d\n",ans);//记得换行
	return 0;
}
/*
6 5
5 3
1 7 12 19 20 26
4 9 15 23 24 
*/
```



---


# [ABC088D] Grid Repainting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc088/tasks/abc088_d

縦 $ H $ マス, 横 $ W $ マスに広がるマス目があり, 各マスは白または黒で塗られている. 上から $ i $ 番目で左から $ j $ 番目のマスを $ (i,\ j) $ で表す. すぬけ君は, このマス目を使って次のようなゲームをしたい. ゲームの開始時点ではマス $ (1,\ 1) $ にゲームキャラクター「けぬす君」がいる. プレイヤーはけぬす君を上下左右の $ 4 $ 方向のいずれかに $ 1 $ マスだけ動かすことを繰り返す. けぬす君が白いマスだけを通って $ (H,\ W) $ にたどり着けばゲームクリアとなる.  
 ゲームを開始する前に, すぬけ君はいくつかの白いマス目の色を黒に変えることができる. ただし, マス $ (1,\ 1) $ と $ (H,\ W) $ の色を変えることはできず, ゲームを開始するまでにすべての色の変更を行わなければならない.  
 ゲームをクリアしたとき, ゲームの開始前にマスの色を変えた回数がすぬけ君のスコアとなる. そのとき, すぬけ君が取る可能性のある最大のスコアを求めなさい.ただし, すぬけ君がどのようにマス目の色を変えてもけぬす君が $ (H,\ W) $ にたどり着くことが出来ない場合、$ -1 $ と出力しなさい.

ただし, 各マスの色の情報は文字 $ s_{i,\ j} $ として与えられる. マス $ (i,\ j) $ が最初白で塗られている場合 $ s_{i,\ j} $ は `.` であり, マス $ (i,\ j) $ が最初黒で塗られている場合 $ s_{i,\ j} $ は `#` である.

## 说明/提示

### 制約

- $ H $ は $ 2 $ 以上 $ 50 $ 以下の整数
- $ W $ は $ 2 $ 以上 $ 50 $ 以下の整数
- $ s_{i,\ j} $ は `.` または `#` $ (1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W) $
- $ s_{1,\ 1},\ s_{H,\ W} $ は `.` である

### Sample Explanation 1

下の図のようにマス目の色を変えれば, スコア $ 2 $ を達成できます. !\[Explanation of Sample 1\](https://img.atcoder.jp/abc088/bc944898899615e35f898654b68cd517.png)

## 样例 #1

### 输入

```
3 3
..#
#..
...```

### 输出

```
2```

## 样例 #2

### 输入

```
10 37
.....................................
...#...####...####..###...###...###..
..#.#..#...#.##....#...#.#...#.#...#.
..#.#..#...#.#.....#...#.#...#.#...#.
.#...#.#..##.#.....#...#.#.###.#.###.
.#####.####..#.....#...#..##....##...
.#...#.#...#.#.....#...#.#...#.#...#.
.#...#.#...#.##....#...#.#...#.#...#.
.#...#.####...####..###...###...###..
.....................................```

### 输出

```
209```

# 题解

## 作者：Natsume_Rin (赞：1)

其实，用广搜找一遍最短路就行了。

那么答案就是方格总数减去原有黑格子数量再减去到右下角的最短路的长度就OK了。

但是要注意一点：

初始，到(1,1)处的最短路长度应该为1！

```cpp
#include<bits/stdc++.h>
#define MAX_N 55
using namespace std;
char mapp[MAX_N][MAX_N];
int n, m, cnt;
int dist[MAX_N][MAX_N];
struct node{
	int x, y;
}q[MAX_N*MAX_N];
bool pd[MAX_N][MAX_N];
const int r[]={1,-1,0,0}, w[]={0,0,1,-1};
inline void BFS(int sx, int sy){
	int hd, tl, dx, dy, fx, fy;
	hd=tl=1;
	q[1].x=sx;
	q[1].y=sy;
	while(hd<=tl){
		fx=q[hd].x;
		fy=q[hd].y;
		hd++;
		for(int i=0;i<4;++i){
			dx=fx+r[i];
			dy=fy+w[i];
			if(dx<1||dy<1||dx>n||dy>m||mapp[dx][dy]=='#'||pd[dx][dy]==1) continue;
			pd[dx][dy]=1;
			tl++;
			q[tl].x=dx;
			q[tl].y=dy;
			dist[dx][dy]=dist[fx][fy]+1;
			if(dx==n&&dy==m) return ;
		}
	}
}
int main(){
	memset(dist,127/3,sizeof dist);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>mapp[i][j];
			if(mapp[i][j]=='#') cnt++;
		}
	}
	dist[1][1]=1;
	pd[1][1]=1;
	BFS(1,1);
	int ans=n*m-cnt-dist[n][m];
	if(ans<0) puts("-1");
	else printf("%d",ans);
   return 0;
}




```

---


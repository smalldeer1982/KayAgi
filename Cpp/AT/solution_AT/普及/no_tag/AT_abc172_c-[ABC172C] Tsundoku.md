# [ABC172C] Tsundoku

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc172/tasks/abc172_c

二台の机 A, B があります。机 A には $ N $ 冊の本が、机 B には $ M $ 冊の本が、それぞれ縦に積まれています。

机 A に現在上から $ i $ 番目に積まれている本 $ (1\ \leq\ i\ \leq\ N) $ は読むのに $ A_i $ 分を要し、机 B に現在上から $ i $ 番目に積まれている本 $ (1\ \leq\ i\ \leq\ M) $ は読むのに $ B_i $ 分を要します。

次の行為を考えます。

- 本が残っている机を選び、その机の最も上に積まれた本を読んで机から取り除く。

合計所要時間が $ K $ 分を超えないようにこの行為を繰り返すとき、最大で何冊の本を読むことができるでしょうか。本を読むこと以外に要する時間は無視します。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M\ \leq\ 200000 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

この場合、机 A の上から $ 1,2,3 $ 番目の本はそれぞれ読むのに $ 60 $ 分、$ 90 $ 分、$ 120 $ 分を要し、机 B の上から $ 1,2,3,4 $ 番目の本はそれぞれ読むのに $ 80 $ 分、$ 150 $ 分、$ 80 $ 分、$ 150 $ 分を要します。 以下のようにすることで $ 230 $ 分で $ 3 $ 冊の本を読むことができ、これが $ 240 $ 分以内に読むことのできる本の最大数です。 - 机 A の最も上に積まれている本を $ 60 $ 分かけて読み、この本を机から取り除く。 - 机 B の最も上に積まれている本を $ 80 $ 分かけて読み、この本を机から取り除く。 - 机 A の最も上に積まれている本を $ 90 $ 分かけて読み、この本を机から取り除く。

### Sample Explanation 3

整数のオーバーフローに注意してください。

## 样例 #1

### 输入

```
3 4 240
60 90 120
80 150 80 150```

### 输出

```
3```

## 样例 #2

### 输入

```
3 4 730
60 90 120
80 150 80 150```

### 输出

```
7```

## 样例 #3

### 输入

```
5 4 1
1000000000 1000000000 1000000000 1000000000 1000000000
1000000000 1000000000 1000000000 1000000000```

### 输出

```
0```

# 题解

## 作者：yinbe (赞：7)

## 题面描述

有两叠书，分别有 $N$ 和 $M$ 本。

看完第一叠自顶向下第 $i$ 本书需要 $A _ i$ 分钟，看完第二叠自顶向下第 $i$ 本书需要 $B _ i$ 分钟。

你每次可以花时间看完任意一叠书（不为空）的最上面那一本书，然后把它移除。

问你在 $K$ 分钟内最多能看完几本书？

### 数据范围

- $1\ \leq\ N,\ M\ \leq\ 200000$
- $1\ \leq\ K\ \leq\ 10^9$
- $1\ \leq\ A_i,\ B_i\ \leq\ 10^9$

## 思路

题目应该很好理解，从 $1\ \leq\ N,\ M\ \leq\ 200000$ 可以知道要用 $O(n)$ 或者 $O(n \log _{2}n)$ 的算法。

首先我想到的是贪心，每次从两叠书的顶部选用时最少的一本书来读，直到时间用完为止。

但这个贪心是错的，可以被下面的数据 hack。

```
2 2 4
3 1
2 3
```

因为优先选用时少的书不一定最优，可能像上面的数据一样，用时多的书下面放了很多用时少的书，而程序不会去取那本用时多的书，所以最后答案不会是最优的。

因为读书只能连续的读，不能跳过一本书直接去读下一本书，设第一叠书读到第 $x$ 本，第二叠书读到第 $y$ 本，所以问题就是满足 $(\sum_{i=1}^{x} a_{i})+(\sum_{i=1}^{y} b_{i}) \le k$ 的最大的 $x+y$，就是 $a$ 数组的前缀和和 $b$ 数组的前缀和，设 $a$ 数组的前缀和为 $suma$，$b$ 数组的前缀和为 $sumb$，所以问题就变成了求满足 $suma_{x}+sumb_{y} \le k$ 的最大的 $x+y$，这个问题可以用双指针解决，代码实现有些细节见代码注释。

## 代码实现

```cpp
#include<iostream>
using namespace std;
int n,m,k,Max,a,b;
long long suma[200005],sumb[200005];//不开 long long 见祖宗
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		suma[i]=suma[i-1]+a;
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&b);
		sumb[i]=sumb[i-1]+b;
	}
	int l=0,r=m;//注意可以不看书，所以要从 0 开始
	while(l<=n)
	{
		while(r>=1&&suma[l]+sumb[r]>k)r--;//同上，可以不看书，所以是 r>=1 ，可以减到 0
		if(suma[l]+sumb[r]>k)break;//如果 r 指针还是不满足要求，就代表已经没有位置 y 可以满足 suma[l]+ sumb[y] <= k 了，因为读书时间一定是正数，所以 suma[l] 只会越来越大，所以接下来也不会有位置 x 满足 x>=l 且 suma[x]+sumb[y]<=k 了，所以可以直接退出
		Max=max(Max,l+r);
		l++;
	}
	printf("%d",Max);
	return 0;
}
```

---


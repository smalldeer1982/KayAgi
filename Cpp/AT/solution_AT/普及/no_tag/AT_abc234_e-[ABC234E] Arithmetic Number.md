# [ABC234E] Arithmetic Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc234/tasks/abc234_e

以下の条件を満たす正の整数 $ n $ を、 **等差数** と呼びます。

- ($ n $ を先頭に余計な $ 0 $ を付けずに $ 10 $ 進法で表記した際、) $ n $ の上から $ i $ 桁目を $ d_i $ とする。このとき、 $ n $ が $ k $ 桁の整数であったとすると、 $ (d_2-d_1)=(d_3-d_2)=\dots=(d_k-d_{k-1}) $ が成立する。
  - この条件は、「 数列 $ (d_1,d_2,\dots,d_k) $ が等差数列である」と言い換えることができる。
  - 但し、 $ n $ が $ 1 $ 桁の整数である時、 $ n $ は等差数であるものとする。

たとえば、 $ 234,369,86420,17,95,8,11,777 $ は等差数ですが、 $ 751,919,2022,246810,2356 $ は等差数ではありません。

等差数のうち、 $ X $ 以上で最小のものを求めてください。

## 说明/提示

### 制約

- $ X $ は $ 1 $ 以上 $ 10^{17} $ 以下の整数である

### Sample Explanation 1

$ 152 $ 以上で最小の等差数は $ 159 $ です。

### Sample Explanation 2

$ X $ 自身が等差数である場合もあります。

## 样例 #1

### 输入

```
152```

### 输出

```
159```

## 样例 #2

### 输入

```
88```

### 输出

```
88```

## 样例 #3

### 输入

```
8989898989```

### 输出

```
9876543210```

# 题解

## 作者：xvl_ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/AT_abc234_e)

一道枚举题。

暴力枚举数字位数、首位、等差数列的公差即可。注意公差的枚举范围，并且需要看看末尾合不合法。顺便提一下，我是用字符串存储枚举的数字的，所以写了一个 `check` 函数代替大于号。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ll x;
ll top_num(ll x) { ll res; while (x) res = x % 10, x /= 10; return res; }
ll len(ll x) { ll res = 0; while (x) res++, x /= 10; return res; }
bool check(string a, string b) {
	if (a.size() > b.size()) return 1;
	if (a.size() < b.size()) return 0;
	for (int i = 0; i < a.size(); i++) {
		if (a[i] - '0' > b[i] - '0') return 1;
		if (a[i] - '0' < b[i] - '0') return 0;
	}
	return 1;
}
int main() {
	ios :: sync_with_stdio(0);
	cin >> x;
	for (ll i = len(x); i; i++) {
		for (ll j = top_num(x); j <= 9; j++) {
			for (ll d = -10; d <= 10; d++) {
				string s = to_string(j);
				if (j + (i - 1) * d >= 0 and j + (i - 1) * d <= 9) {
					for (ll k = 1; k < i; k++) s += to_string(j + k * d);
				}
				if (check(s, to_string(x))) {
					cout << s;
					return 0;
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：codwarm (赞：1)

[题目传送门~](https://www.luogu.com.cn/problem/AT_abc234_e)

## 题目分析
题目要求出不小于 $k$ 位的正整数 $n$ 最小的等差数。

- 首先考虑 $k$ 位等差数能否成功。枚举第一位和公差 $k$，从而求出每一位的数字，再判断这个数是否大于等于 $n$，因为是**从小到大**枚举第一位，所以最先得到的等差数一定是最小的，直接输出即可。

- 若找不到成功的 $k$ 位数，则直接输出最小的 $k+1$ 位等差数。这一步可以用**面向储存的源码级轻量预处理算法**实现，即打表。

当 $n \ge 1 \times 10^{10}$ 时，其实就不需要处理 $n$ 了，因为不存在 $10$ 位以上的等差数（数字只有十个）。

## 代码
```cpp
// Problem: AT_abc234_e [ABC234E] Arithmetic Number
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT_abc234_e
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// Author: Eason
// Date:2023-10-14 14:34:14
// 
// Powered by CP Editor (https://cpeditor.org)
#include<bits/stdc++.h>
using namespace std;
#define ll long long
string s;
//打出n位的最小等差数的表
ll minx[15] = {0,1,12,123,1234,12345,123456,1234567,12345678,123456789,9876543210};

int main()
{	
	cin >> s;
	int n = s.size();
	ll num = 0,fin = 0;
	for (int i = 0;i < s.size();i ++) num = num * 10 + s[i]-48; //求出原数
	for (int i = s[0]-'0';i <= 9 && !fin;i ++) //枚举首位
		for (int j = -9;j <=9;j ++) //枚举差
		{
			ll tpi = i,c = 0,flag = 1;
			for (int k = 1;k <= n;k ++) //根据首位和差算出每一位
			{
				if (tpi >= 0 && tpi <= 9) c = c * 10 + tpi; //计算
				else
				{
					flag = 0;
					break;
				}
				tpi += j; //等差序列 加上差值
			}
			if (flag && c >= num) 
			{
				//如果成功则直接输出
				//因为是从小到大枚举的，所以一定是最优解
				cout << c << endl;
				fin = 1;
				break;
			}
		}
	//如果n位数不成功，则输出最小的n+1位等差数
	if (!fin) cout << minx[n+1];
	return 0;
}
```


---

## 作者：LiJinLin_AFO (赞：0)

# AT_abc234_e 题解

~~某个水题~~
## 正文开始
我们可以很容易地看出，$1\le X<10^{10}$。因为满足条件的数最大是 $9876543210$，不可能更大。

然后，由于等差数不多，所以直接列举所有的等差数，放入数组，从小到大排序，再用 `lower_bound` 函数即可。

我们可以分两种情况：

1. 等差数数字下降。

2. 等差数数字上升。

来个模拟解决问题。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005];
int num;
void first(int i){
	a[++num]=i;
	for(int j=1;j<=9;j++){
		long long link=i;
		for(int k=i+j;k<=9;k+=j) link=link*10+k,a[++num]=link;
	}
}//上升
void second(int i){
	for(int j=1;j<=9;j++){
		long long link=i;
		for(int k=i-j;k>=0;k-=j) link=link*10+k,a[++num]=link;
	}
}//下降
int main(){
	long long n;
	scanf("%lld",&n);
	for(int i=1;i<=9;i++) first(i);
	for(int i=9;i>=1;i--) second(i);//进行存储
	sort(a+1,a+1+num);//排序
	printf("%lld\n",*lower_bound(a+1,a+1+num,n));//STL真香
	return 0;
}
```
注：请勿抄袭！

---

## 作者：asas111 (赞：0)

## 思路
看了一下其他题解，发现居然没有打表的。

容易发现，$1$ 到 $99$ 都是等差数（因为一位数被视作等差数，两位数只有 $1$ 个公差），$10^{10}$ 到 $10^{17}$ 内的等差数的公差都为 $0$（因为只有 $10$ 个数字，不存在超过 $10$ 位的各位数字不同的等差数），所以就可以只枚举 $100$ 到 $10^{10}$ 之间的等差数，枚举量就大大缩小。

判断一个数是否为等差数就比较简单了，把它的每一位数存入数组，然后一位位检验公差是否相等就行。

因为表里的数是单调递增的，所以可以进行一个小优化：二分，时间复杂度就变为 $O(\log n)$。

打表程序如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool isdcs(int x){
	int b[20];
	int k=x,e=1;
	while(k>0)b[e++]=k%10,k/=10;
	e--;
	int f=b[1]-b[2];
	for(int i=1;i<e;i++)
		if(b[i]-b[i+1]!=f)return 0;
	return 1;
}
signed main(){
	int a[10]={11111111111,111111111111,1111111111111,11111111111111,111111111111111,1111111111111111,11111111111111111};
	for(int i=1;i<100;i++)cout<<i<<",";
	for(int i=100;i<=pow(10,10);i++)
		if(isdcs(i))cout<<i<<",";
	for(int i=11;i<=17;i++)
		for(int j=1;j<=9;j++)
			cout<<j*a[i-11]<<",";
	return 0;
}
```

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int> a={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,111,123,135,147,159,210,222,234,246,258,321,333,345,357,369,420,432,444,456,468,531,543,555,567,579,630,642,654,666,678,741,753,765,777,789,840,852,864,876,888,951,963,975,987,999,1111,1234,1357,2222,2345,2468,3210,3333,3456,3579,4321,4444,4567,5432,5555,5678,6420,6543,6666,6789,7531,7654,7777,8642,8765,8888,9630,9753,9876,9999,11111,12345,13579,22222,23456,33333,34567,43210,44444,45678,54321,55555,56789,65432,66666,76543,77777,86420,87654,88888,97531,98765,99999,111111,123456,222222,234567,333333,345678,444444,456789,543210,555555,654321,666666,765432,777777,876543,888888,987654,999999,1111111,1234567,2222222,2345678,3333333,3456789,4444444,5555555,6543210,6666666,7654321,7777777,8765432,8888888,9876543,9999999,11111111,12345678,22222222,23456789,33333333,44444444,55555555,66666666,76543210,77777777,87654321,88888888,98765432,99999999,111111111,123456789,222222222,333333333,444444444,555555555,666666666,777777777,876543210,888888888,987654321,999999999,1111111111,2222222222,3333333333,4444444444,5555555555,6666666666,7777777777,8888888888,9876543210,9999999999,11111111111,22222222222,33333333333,44444444444,55555555555,66666666666,77777777777,88888888888,99999999999,111111111111,222222222222,333333333333,444444444444,555555555555,666666666666,777777777777,888888888888,999999999999,1111111111111,2222222222222,3333333333333,4444444444444,5555555555555,6666666666666,7777777777777,8888888888888,9999999999999,11111111111111,22222222222222,33333333333333,44444444444444,55555555555555,66666666666666,77777777777777,88888888888888,99999999999999,111111111111111,222222222222222,333333333333333,444444444444444,555555555555555,666666666666666,777777777777777,888888888888888,999999999999999,1111111111111111,2222222222222222,3333333333333333,4444444444444444,5555555555555555,6666666666666666,7777777777777777,8888888888888888,9999999999999999,11111111111111111,22222222222222222,33333333333333333,44444444444444444,55555555555555555,66666666666666666,77777777777777777,88888888888888888,99999999999999999,111111111111111111,222222222222222222,333333333333333333,444444444444444444,555555555555555555,666666666666666666,777777777777777777,888888888888888888,999999999999999999};
signed main(){
	int n;
	scanf("%lld",&n);
	printf("%lld",*lower_bound(a.begin(),a.end(),n));//二分
	return 0;
}
```


---

## 作者：ghx0052 (赞：0)

# 思路

考虑到 $x$ 最多只有 $17$ 位，考虑暴力枚举第一个数字和公差构造一个长度与 $x$ 相同的数字并判断与 $x$ 的大小关系并更新答案即可，答案最大为 $n+1$ 个 $1$。

时间复杂度：$O(n)$。

# 代码
```cpp
void chkmin(string& s, string& t) {
	if (s.size() > t.size()) s = t;
	else s = min(s, t);
	return;
}
void solve() {
	string s;
	cin >> s;
	string res;
	int n = s.size();
	for (int i = 1; i <= n + 1; ++i) res += '1';
	for (int i = 1; i <= 9; ++i) {
		for (int d = -8; d <= 8; ++d) {
			string t;
			t += (char)('0' + i);
			int last = i;
			for (int j = 2; j <= n; ++j) {
				if (d + last > 9 || d + last < 0) break;
				last = d + last;
				t += (char)('0' + last);
			}
			if (t.size() < n) continue;
			if (t < s) continue;
			chkmin(res, t);
		}
	}
	cout << res << '\n';
	return ;
}

```


---

## 作者：chengning0909 (赞：0)

# abc 234 e

## 题意

一个整数 $n$ 被称为**等差数**需要满足以下条件：

- 令 $n = \overline {d_1 d_2 \cdots d_k}$，且序列 $(d_1, d_2, \dots, d_n)$ 是等差数列。

- 若 $n$ 是一位数，那么它也是等差数。

请你求出不小于 $X$ 的最小等差数。

## 思路

首先，这个题目判断一个数是不是等差数的做法是很明显的：根据前两位求出公差 $D$，判断后面的所有 $d_i$ 是否都满足 $d_{i - 1} + D$。

那么，这里可以发现，我们要判断一个数是否为等差数，最重要的两个东西就是 $d_1$ 和公差 $D$，于是，可以发现，拥有了这两个东西就可以构造一个等差数了。

那么，做法就显而易见了：

枚举所有的公差与最高位，构造出等差数，求所有大于 $X$ 的等差数的最小值。

---

## 作者：wnsyou (赞：0)

[照例给一个题目传送门](https://www.luogu.com.cn/problem/AT_abc234_e)
## 题意

一个数 $n$ 被称为等差数当且仅当它满足以下条件：

- 令 $n=\overline{d_1d_2 \dots d_k}$，$k$ 为 $n$ 的位数。
- $d_2 - d_1=d_3 - d_2 = \dots = d_k - d_{k-1}$，即序列 $d$ 为等差数列。
- 注意，当 $k=1$ 时 $d$ 也算做等差数列。

给定一个整数 $X$，求一个最小的 $Y$ 使得 $Y \geqslant X$ 并且 $Y$ 为等差数。
## 思路
### 暴力
一个一个数去枚举，每枚举一个就做一次判断，找到第一个等差数，输出。
### 正解
暴力时间复杂度肯定过不了。

首先，我们可以发现，**等差数是非常少的**，直接枚举会去判断太多的不合法答案。

但是，我们知道，等差数是必须长成一个等差数列的样子，也就是说，只要枚举一下首项和公差，就能推出整个等差数列。

但还有个问题，我们不清楚它要多少位啊 ~~(其实不知道要多少位也是可以做的)~~。

我们知道，$n$ 位数里面最大的数肯定是 $10^n-1$，整个数由 $n$ 个 $9$ 组成，这时，我们就会惊喜地发现：它**必然是一个等差数**。

所以，只要取这个等差数列的前 $k$ 位($k$ 为 $X$ 的位数)，判断它是否大于等于 $X$ 即可，如果不成立，那么也不用考虑选更多位了，这个等差数列**一定不是构成答案的等差数列**

最后只需要注意判断等差数列中不能出现大于 $9$ 或小于 $0$ 的数即可。
## Code
```cpp
#include <iostream>

using namespace std;

long long x, y, le; // 记得开 long long
int t, flag, sum, st;

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> x;
  le = x;
  while (le) { // 求 x 的位数
    st = le % 10, le /= 10;
    sum++;
  }
  for (int i = st; i <= 9; i++) { // 优化一下，枚举首项
    for (int d = -9; d <= 9; d++) { // 枚举公差
      y = i, t = i, flag = 1;
      for (int j = 1; j < sum; j++) { // 枚举每一位
        t += d;
        if (t > 9 || t < 0) { // 判断不合法的情况
          flag = 0;
          break;
        }
        y = y * 10 + t;
      }
      if (flag && y >= x) { // 是一个大于 X 的等差数
        cout << y;
        return 0; // 结束
      }
    }
  }
  return 0;
}
```

---

## 作者：tZEROちゃん (赞：0)

注意到在 $10^{18}$ 范围内「等差数」是很少的。

显然，一个数如果是等差数，必须满足以下条件

- 首项在 $1\sim 9$（包括，下文同理）之间。
- 公差在 $-9\sim 8$ 之间。
- 长度在 $1 \sim 18$ 之间。

那么显然总数 **大约** 是 $9 \times 18 \times 18 = 2916$，但显然，有一些数是不符合规定的，比如「$71-5$」（即序列 $(7, 1, -5)$，于是还有一条规定是

- 第 $2$ 个数直到最后一个数都必须要在 $0\sim 9$ 之间。

那么我们可以考虑枚举首项和公差，把所有可行的数组合起来，并扔到一个 `set` 中，最后二分查找即可。

参考代码：[见此](https://atcoder.jp/contests/abc234/submissions/37296032)。

---

## 作者：minVan (赞：0)

**题目大意**

一个正整数 $n$ 被称为等差数需要满足以下条件：

- 令 $d_i$ 表示 $n$ 在十进制下从最高位开始的第 $i$ 位数字，即 $n = \overline{d_1d_2\cdots d_k}$，其中 $k$ 表示 $n$ 的位数。
- 并且，序列 $(d_1, d_2, \dots, d_k)$ 为等差数列。
- 若 $n$ 是一位整数，则它也被视作为等差数。

例如，$234,369,86420,17,95,8,11,777$ 是等差数，然而 $751,919,2022,246810,2356$ 不是等差数。

请你求出不小于 $X$ 的最小等差数。

**解题思路**


先计算出 $X$ 的位数 $len$，然后枚举开头的数 $i$ 和公差 $d$，构造出 $ans$，如果 $ans\ge X$，那么直接输出 $ans$ 就行了。


**AC 代码，请勿抄袭**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x;
int len;
void help(int n) // 计算位数
{
	for(long long t = x; t; t /= 10, ++len) {}
}
long long yes(int a, int d)
{
	long long ans = 0;
	for(int i = 0; i < len; i++)
	{
		if(a + i * d > 9 || a + i * d < 0)
			return -1;
		ans = ans * 10 + a + i * d;
	}
	return ans;
}
int main()
{
	cin >> x;
	help(x);
	for(int i = 1; i <= 9; i++)
		for(int d = -9; d <= 8; d++)
		{
			long long t = yes(i, d);
			if(t >= x)
			{
				cout << t;
				return 0;
			}
		}
	return 0;
}
```

---


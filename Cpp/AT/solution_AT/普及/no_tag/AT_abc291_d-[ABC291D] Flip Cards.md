# [ABC291D] Flip Cards

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc291/tasks/abc291_d

$ 1 $ から $ N $ までの番号がついた $ N $ 枚のカードが一列に並んでいて、各 $ i\ (1\leq\ i\ <\ N) $ に対してカード $ i $ とカード $ i+1 $ が隣り合っています。 カード $ i $ の表には $ A_i $ が、裏には $ B_i $ が書かれており、最初全てのカードは表を向いています。

今から、$ N $ 枚のカードのうち好きな枚数 ($ 0 $ 枚でも良い) を選んで裏返すことを考えます。 裏返すカードの選び方は $ 2^N $ 通りありますが、そのうち以下の条件を満たすものの数を $ 998244353 $ で割った余りを求めてください。

- 選んだカードを裏返した後、どの隣り合う $ 2 $ 枚のカードについても、向いている面に書かれた数が相異なる。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,B_i\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

裏返すカードの番号の集合を $ S $ とします。 例えば $ S=\{2,3\} $ を選ぶと、向いている面に書かれた数はカード $ 1 $ から順に $ 1,2,4 $ となるため条件を満たします。 一方 $ S=\{3\} $ を選ぶと、向いている面に書かれた数はカード $ 1 $ から順に $ 1,4,4 $ となり、カード $ 2 $ とカード $ 3 $ の数が一致するため条件を満たしません。 条件を満たす $ S $ は $ \{\},\{1\},\{2\},\{2,3\} $ の $ 4 $ 通りです。

## 样例 #1

### 输入

```
3
1 2
4 2
3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
4
1 5
2 6
3 7
4 8```

### 输出

```
16```

## 样例 #3

### 输入

```
8
877914575 602436426
861648772 623690081
476190629 262703497
971407775 628894325
822804784 450968417
161735902 822804784
161735902 822804784
822804784 161735902```

### 输出

```
48```

# 题解

## 作者：aCssen (赞：4)

### Solution
dp.

计数题先想 dp。由于这只是 ABC 的 D，所以考虑线性 dp。
+ 状态

	设 $f_{i,0/1}$ 表示前 $i$ 张卡，第 $i$ 张卡为正面 $/$ 反面的方案数。
    
+ 初值

	$f_{1,0}=f_{1,1}=1$。
+ 答案

	$f_{n,0}+f_{n,1}$。
+ 转移方程

	因为相邻的两面数值不能相同，所以得到如下方程：
    
   $f_{i,0}=f_{i-1,0}[a_i\ne a_{i-1}]+f_{i-1,1}[a_i \ne b_{i-1}]$
   
      
   $f_{i,1}=f_{i-1,0}[b_i\ne a_{i-1}]+f_{i-1,1}[b_i \ne b_{i-1}]$
    
+ 枚举顺序

	直接从 $1$ 到 $n$ 枚举 $i$ 计算即可。
    
注意时刻取模。
### 代码

赛时代码，极为丑陋。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
const int MOD=998244353;
int a[maxn],b[maxn],f[maxn][2];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i];
	f[1][0]=f[1][1]=1;
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1]) f[i][0]=(f[i][0]+f[i-1][0])%MOD;
		if(a[i]!=b[i-1]) f[i][0]=(f[i][0]+f[i-1][1])%MOD;
		if(b[i]!=a[i-1]) f[i][1]=(f[i][1]+f[i-1][0])%MOD;
		if(b[i]!=b[i-1]) f[i][1]=(f[i][1]+f[i-1][1])%MOD;
	}
	cout<<(f[n][0]+f[n][1])%MOD;
	return 0;
}
```

---

## 作者：YBaggio (赞：2)

# 题意
有 $n$ 张卡片，每张卡片有正反面，正反面各有一个数，（第 $i$ 张卡片正反面分别为 $a_{i,0}$ 和 $a_{i,1}$）。现在你可以随意切换卡牌的正反面，但每张卡牌的相对位置不动，问 $2^n$ 种切换正反的卡牌摆放方式有多少种是在上面的卡牌没有数字相同的。

# 题解
我们设 $f_{i,0}$ 表示第 $i$ 张卡片正面朝上时前 $i$ 张卡片的答案，$f_{i,1}$ 则表示第 $i$ 张卡片正面朝上时前 $i$ 张卡片的答案。最后的答案就是 $f_{n,0}+f_{n,1}$。

考虑转移：
+ 如果 $a_{i,0} \neq a_{i-1,0}$ 则 $f_{i,0}=f_{i,0}+f_{i-1,0}$；
+ 如果 $a_{i,0} \neq a_{i-1,1}$ 则 $f_{i,0}=f_{i,0}+f_{i-1,1}$；
+ 如果 $a_{i,1} \neq a_{i-1,0}$ 则 $f_{i,1}=f_{i,1}+f_{i-1,0}$；
+ 如果 $a_{i,1} \neq a_{i-1,1}$ 则 $f_{i,1}=f_{i,1}+f_{i-1,1}$；

代码:
```cpp
#include<iostream>
#define md 998244353
using namespace std;
const int maxn=200010;
int n;
long long f[maxn][2];
pair<int,int>p[maxn];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>p[i].first>>p[i].second;
    f[0][0]=1;
    for(int i=1;i<=n;i++){
        if(p[i].first!=p[i-1].first){
            f[i][0]=(f[i][0]+f[i-1][0])%md;
        }
        if(p[i].first!=p[i-1].second){
            f[i][0]=(f[i][0]+f[i-1][1])%md;
        }
        if(p[i].second!=p[i-1].first){
            f[i][1]=(f[i][1]+f[i-1][0])%md;
        }
        if(p[i].second!=p[i-1].second){
            f[i][1]=(f[i][1]+f[i-1][1])%md;
        }//注意要取模
    }
    cout<<(f[n][0]+f[n][1])%md;
    return 0;
}
```

---

## 作者：Strelitzia_ (赞：2)

## 题目大意

$n$ 张牌，第 $i$ 张牌正面有一个数字 $a_i$，反面有一个数字 $b_i$。初始所有牌都正面朝上。

定义一次操作为任意选出 $n$ 张牌中的若干张（可以不选），将其翻转。问有多少种操作可以在经过这一次操作后，$n$ 张牌相邻之间朝上的数均不相等。

------------
## 思路

一道数数题。

我们考虑使用动态规划数数。具体来讲，我们用 $f_{i,0}$ 表示不翻转第 $i$ 张牌的方案数，$f_{i,1}$ 表示翻转第 $i$ 张牌的方案数。那么我们可以得到如下递推式：

$$f_{i,0}=\begin{cases}
 f_{i-1,0}+f_{i-1,1} & \text{ if } a_i\ne a_{i-1} ,a_{i}\ne b_{i-1} \\
 f_{i-1,0} & \text{ if } a_i\ne a_{i-1},a_i=b_{i-1} \\
 f_{i-1,1} & \text{ if } a_i=a_{i-1},a_i\ne b_{i-1}
\end{cases}$$

同理：

$$f_{i,1}=\begin{cases}
 f_{i-1,0}+f_{i-1,1} & \text{ if } b_i\ne a_{i-1} ,b_{i}\ne b_{i-1} \\
 f_{i-1,0} & \text{ if } b_i\ne a_{i-1},b_i=b_{i-1} \\
 f_{i-1,1} & \text{ if } b_i=a_{i-1},b_i\ne b_{i-1}
\end{cases}$$

最后的答案就是 $f_{n,0}+f_{n,1}$。

于是我们就在 $O(n)$ 的时间复杂度内解决了这道题。不要忘记递推中的取模。代码：

```cpp
signed main() {
	n = read();
	for (int i = 1; i <= n; i++) a[i] = read(), b[i] = read();
	f[1][0] = f[1][1] = 1;
	for (int i = 2; i <= n; i++) {
		if (a[i] != a[i - 1] && a[i] != b[i - 1]) f[i][0] = (f[i - 1][1] + f[i - 1][0]) % mod;
		if (b[i] != a[i - 1] && b[i] != b[i - 1]) f[i][1] = (f[i - 1][0] + f[i - 1][1]) % mod;
		if (a[i] == a[i - 1] && a[i] != b[i - 1]) f[i][0] = f[i - 1][1];
		if (a[i] == b[i - 1] && a[i] != a[i - 1]) f[i][0] = f[i - 1][0];
		if (b[i] == a[i - 1] && b[i] != b[i - 1]) f[i][1] = f[i - 1][1];
		if (b[i] == b[i - 1] && b[i] != a[i - 1]) f[i][1] = f[i - 1][0];
	}
	return printf("%lld", (f[n][0] + f[n][1]) % mod), Strelitzia_;
}
```

---

## 作者：ダ月 (赞：1)

### 题意概要：

有 $n$ 张纸，正面写着 $a_i$，背面写着 $b_i$。你可以选择其中一些纸翻转，当然也可以不翻任何一张纸，满足相邻正面的数字不相同。求方案数。

### 题目分析：

直接计数不太好做，并且这只是一个 D。我们从 dp 的角度来考虑，设 $f_{i,j}$ 为当前第 $i$ 张卡片，$j=0$ 表示不翻，$j=1$ 表示翻的方案数。转移方程如下：$\begin{aligned}f_{i,j}=\sum f_{i-1,k}[a_{i,j}\neq a_{i-1,k}]\end{aligned}$，其中 $a_{i,j}$ 表示第 $i$ 张，若 $j=0$ 表示正面，$j=1$ 表示背面的数。最后统计方案就是 $f_{n,0}+f_{n,1}$。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int n;
typedef long long ll;
const int N=2e5+10;
int a[N][2];
ll f[N][2];
const int mod=998244353;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i][0]>>a[i][1];
	f[1][0]=1,f[1][1]=1;
	for(int i=2;i<=n;i++)
		for(int j=0;j<2;j++)
			for(int k=0;k<2;k++)
				if(a[i][j]!=a[i-1][k])
					f[i][j]=(f[i][j]+f[i-1][k])%mod;
	printf("%lld\n",(f[n][0]+f[n][1])%mod);
	return 0;
}
```

时间复杂度：$O(n)$。

说句闲话：比赛时看成了正面的数两两互不相等，然后这道题寄了。

---


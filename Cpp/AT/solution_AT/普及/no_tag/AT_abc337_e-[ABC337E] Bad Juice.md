# [ABC337E] Bad Juice

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc337/tasks/abc337_e

この問題は **インタラクティブな問題**（あなたが作成したプログラムとジャッジプログラムが標準入出力を介して対話を行う形式の問題）です。

$ 1 $ から $ N $ の番号がついた $ N $ 本のジュースがあります。 このうちちょうど $ 1 $ 本が腐っていることが判明しました。 そのジュースを微量でも飲むと、翌日お腹を壊してしまいます。

高橋君は翌日までに腐ったジュースを特定しなければなりません。 高橋君はそのために**必要な最小の数**の友人を呼び、それぞれに $ N $ 本のジュースのうちの一部を振る舞うことにしました。 各友人には何本でもジュースを与えることができ、各ジュースは何人の友人にでも与えることができます。

呼ぶ友人の数とジュースの与え方を出力して、翌日に各友人がお腹を壊したかどうかの情報を受け取り、腐ったジュースの番号を出力してください。

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたが作成したプログラムとジャッジプログラムが標準入出力を介して対話を行う形式の問題）です。

対話を行う前にジャッジは、腐ったジュースの番号 $ X $ として $ 1 $ 以上 $ N $ 以下の整数を秘密裏に選択します。 $ X $ の値はあなたには与えられません。また、**対話の途中で $ X $ の値が制約および以前の出力に矛盾しない範囲で変わる場合があります。**

まず、ジャッジから $ N $ が入力から与えられます。

> $ N $

あなたは呼ぶ友人の数 $ M $ を出力し改行してください。

> $ M $

さらに、あなたは次に述べる $ M $ 回の出力からなる手続きを行ってください。 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について $ i $ 回目の出力では、 $ i $ 番目の友人に飲ませるジュースの本数 $ K_i $ および、それら $ K_i $ 本のジュースの番号を**昇順に**並べた列 $ A_{i,\ 1},\ A_{i,\ 2},\ \ldots,\ A_{i,\ K_i} $ を下記の形式で空白区切りで出力し、改行してください。

> $ K_i $ $ A_{i,\ 1} $ $ A_{i,\ 2} $ $ \ldots $ $ A_{i,\ K_i} $

その後ジャッジから、各友人が翌日にお腹を壊したかどうかの情報が、`0` と `1` のみからなる長さ $ M $ の文字列 $ S $ として与えられます。

> $ S $

$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ S $ の $ i $ 文字目が `1` のとき、かつそのときに限り、$ i $ 番目の友人がお腹を壊したことを表します。

それに対し、あなたは腐ったジュースの番号 $ X' $ を出力し、改行してください。

> $ X' $

その後、直ちにプログラムを終了してください。

あなたが出力した $ M $ が $ N $ 本のジュースから腐ったジュースを特定するために**必要な最小の**友人の数であり、かつ、あなたが出力した $ X' $ が腐ったジュースの番号 $ X $ と一致していれば、正解となります。

## 说明/提示

### 制約

- $ N $ は整数
- $ 2\ \leq\ N\ \leq\ 100 $
 
### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で不正な出力を行った、あるいはプログラムが途中で終了した場合のジャッジ結果は不定です。** 特に、プログラムの実行中に実行時エラーが起こった場合に、ジャッジ結果が RE ではなく WA や TLE になる可能性があることに注意してください。
- $ X' $ を出力したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- **この問題のジャッジはアダプティブです。つまり、制約および以前の出力に矛盾しない範囲で $ X $ の値が変わる場合があります。**
 
### 入出力例

以下は、$ N\ =\ 3 $ の場合の入出力例です。

    入力 出力 説明     `3`  ジュースの本数 $ N $ が与えられます。    `2` 呼ぶ友人の数 $ M $ を出力します。    `2 1 2` $ 1 $ 人目の友人にジュース $ 1 $ とジュース $ 2 $ を与えます。     `1 2` $ 2 $ 人目の友人に、ジュース $ 2 $ を与えます。     `10`  翌日に各友人がお腹を壊したかどうかを表す文字列 $ S $ が与えられます。    `1` 腐ったジュースの番号を出力します。

# 题解

## 作者：JuRuoOIer (赞：8)

# 题解 ABC337E Bad Juice

### Part1 题意

有 $n$ 杯果汁，其中一杯是发霉的，喝了发霉的果汁会窜稀。

现在你不知道哪杯是发霉的，但明天你要把这些果汁因此你想去坑你的好基友，让他们喝下这些果汁。每个基友可以喝很多杯果汁，每杯果汁可以被很多基友喝。

为了得罪尽量少的人，请求出最少需要给多少基友喝果汁，并构造出一种方案。

接下来用一个字符串 $s$ 给出你的方案中每个人的窜稀情况，`1` 代表窜稀，`0` 代表没有窜稀。你需要据此输出发霉的果汁编号。

**交互题**。先读入 $n$，然后输出方案，然后读入 $s$，然后输出发霉的果汁编号。每次输出完需要刷新标准输出。编号全部从 $1$ 开始。

### Part2 做法

~~写这篇题解是因为赛时有很强的大佬来问我。~~

这是一道很经典的题目，建议记住。类似的思想可能用到。

首先答案如下：
- 最少需要的人数是 $\log_2 (n-1)+1$。
- 其中第 $i$ 个人（从 $1$ 开始）要喝所有编号二进制从低到高第 $i$ 位为 $1$ 的果汁。如果这个人窜稀了，则发霉的果汁编号二进制从低到高低 $i$ 位显然也为 $1$，否则为 $0$。

### Part3 常见问题

- Q1：为什么这样人数最少？
- A1：简单理解：如果选用 $3$ 作为底数，那么显然 $\log_3(n-1)>\frac{1}{2}\log_2(n-1)$（$\frac{1}{2}\log_2(n-1)=\log_4(n-1)$），但是每一位却需要两个人分别喝掉这一位为 $1$ 的果汁和这一位为 $2$ 的果汁，因此更劣。
- Q2：为什么是 $\log_2 (n-1)+1$，而非 $\log_2 n+1$？
- A2：注意到 $n=2^k$ 与 $n=2^k-1$ 时的方案是相同的，只不过当 $n=2^k$ 时，可能会出现 $s$ 所有字符均为 `0` 的情况（即编号为 $n$ 的果汁发霉了），需要特判。
- Q3：怎么刷新标准输出？
- A3：我也不知道别的，但是 `endl` 自动刷新（前提是你没有 `#define endl '\n'`）。

### Part4 代码

加注释必要性不大，所以基本没加。与上文思路完全相同。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<cstring>
#include<string>
#define ll long long
#define ull unsigned long long
#define lf double
#define ld long double
using namespace std;
ll n,ans;
string s;
int main(){
	cin>>n;
	cout<<__lg(n-1)+1<<endl;
	for(int i=0;i<=__lg(n-1);i++){
    	//这里我比较懒，选择了循环两次，即一次统计，一次输出
		ll sum=0;
		for(int j=1;j<=n;j++){
			if(j&(1<<i))sum++;
		}
		cout<<sum;
		for(int j=1;j<=n;j++){
			if(j&(1<<i))cout<<' '<<j;
		}
		cout<<endl;
	}
	cin>>s;
	for(int i=0;i<s.length();i++){
		if(s[i]=='1')ans+=(1<<i);
	}
	if(ans==0)ans=n;
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：fydj (赞：4)

# **E - Bad Juice**

### 题目翻译

有 $N$ 杯果汁，编号为 $1$ 到 $N$，其中有且只有一杯坏果汁。

你可以选 $M$ 位朋友，给第 $i$ 人喝 $K_i$ 杯果汁，编号分别为 $A_{i,1}$ 到 $A_{i,K_i}$。

先输出 $M$，再输出 $M$ 行，第 $i$ 行描述第 $i$ 个人的情况，依次输出 $K_i$，$A_{i,1}$ 到 $A_{i,K_i}$。

然后会得到一个字符串 $S$，从左往右数第 $i$ 位表示第 $i$ 个人有没有喝到坏果汁。

最后你要输出坏果汁的编号，并让 $M$ 最小。

### 思路

##### 算法 1

$M=N$。对于 $n-1$ 个人，第 $i$ 个人让他喝第 $i$ 杯喝第 $i+1$ 杯果汁，最后一个人喝第 $n$ 杯果汁。

##### 算法 2

$M=N-1$。类似线段树的做法。对于区间 $[l,r]$，让一个人喝 $[l,mid]$ 中的所有果汁，然后继续询问区间 $[l,mid]$ 和 $[mid+1,r]$。发现这并不比算法 1 好多少。

##### 算法 3

$M=\log N$。想起了小时候的一个魔术：给你几张卡片，卡片上写了一些数，让你在心里想一个数，问你这个数在哪几张卡片上，然后就可以猜出你想的数。这个魔术的原理是二进制拆分，第 $i$ 张卡片上有着范围内所有二进制下第 $i$ 位是 $1$ 的数。如果你想的数在第 $i$ 张卡片上，就说明它在二进制下第 $i$ 位为 $1$；反之，为 $0$。

发现这个魔术和这道题目十分类似，可以使用类似的做法。用 $\log N$ 个人，第 $i$ 个人喝 $[1,N]$ 内所有编号二进制第 $i$ 位为 $1$ 的果汁。如果他喝到了坏果汁，那么就说明坏果汁编号在二进制下第 $i$ 位为 $1$；反之，为 $0$。

一个细节，当 $N$ 为 $2$ 的正整数次幂的时候，第 $\log N$ 次询问只会询问 $N$，显得十分浪费，所以可以不进行最后一次询问，当坏果汁都不被前面所有人喝到的时候，就说明坏果汁的编号为 $N$。

### 代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<utility>
#include<cstdio>
#include<cmath>
#include<map>
using namespace std;
typedef long long ll;
const int N=10009;
char chart,s[N]={}; bool fushu;
template <typename T> void read(T &a) { a=fushu=0; do chart=getchar(); while((chart<48||chart>57)&&chart!='-'); if(chart=='-') fushu=1,chart=getchar(); do a=(a<<1)+(a<<3)+(chart^48),chart=getchar(); while(chart>47&&chart<58); if(fushu) a=-a; return ; }
template <typename T,typename ...Args> void read(T &a,Args &...args) { read(a); read(args...); return ; }
int n,sask=0;
int main()
{
	int i,j,sum,ans=0;
	cin>>n;
	sask=__lg(n)+1;
	if(n==(1<<sask-1)) --sask;
	cout<<sask<<endl;
	for(i=0;i<sask;++i) {
		sum=0;
		for(j=1;j<=n;++j)
			if(j&(1<<i))
				++sum;
		cout<<sum<<" ";
		for(j=1;j<=n;++j)
			if(j&(1<<i))
				cout<<j<<" ";
		cout<<endl;
	}
	cin>>s;
	for(i=0;i<sask;++i)
		ans|=(1<<i)*(s[i]^48);
	if(!ans) ans=n;
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：Elysian_Realme (赞：2)

# 解题思路

经典老题！

我们可以先将饮料的编号转化成二进制，需要朋友的数量就是 $N$ 在二进制中的位数。

为什么是二进制呐？因为每位朋友是否拉肚子这个信息只有 $1$ 和 $0$ 两种情况，本质就是二进制。

对于朋友 $i$，我们都让他喝在二进制中，编号第 $i$ 位为 $1$ 的饮料。

这样如果第 $i$ 位朋友拉了肚子，我们就知道被下了毒的饮料第 $i$ 位为 $1$。

然后就会喜提 WA*9（赛时就卡死在这里了 QWQ）。

我们考虑如果 $N$ 是二的整数次幂.那么在第 $M$ 位是 $1$ 的就只有 $N$，那么饮料 $N$ 会且仅会被第 $M$ 位朋友喝，第 $M$ 位朋友喝且仅喝饮料 $N$。

在这种情况下，我们就可以少叫一位朋友，并且让饮料 $N$ 不被任何人喝。

这样如果所有朋友都不拉肚子，被下毒的就是饮料 $N$ 了。

### Code

```cpp
// Problem: E - Bad Juice
// Contest: AtCoder - Toyota Programming Contest 2024#1（AtCoder Beginner Contest 337）
// URL: https://atcoder.jp/contests/abc337/tasks/abc337_e
// Memory Limit: 1024 MB
// Time Limit: 2000 ms

#include<bits/stdc++.h>
using namespace std;
int n,m;
vector <int> frd[1000];
int hibit(int x){
	int ret=1,t=x & (-x);
	while(x!=t){
		x-=t;
		t=x & (-x);
	}
	for(int i=1;;i<<=1){
		if(i==x)return ret;
		ret++;
	}
}
int lowbits(int x){
	return x & (-x);
}
int lowbit(int x){
	int t = x & (-x);
	if(t==1)return 1;
	for(int i=1;;i++)
		if((t>>i)==0)return i;
}
int main(){
	cin>>n;
	m=hibit(n);
	if(lowbits(n)==n)
		m--;
	cout<<m<<endl;
	for(int i=1;i<=n-(lowbits(n)==n);i++){
		int t=i;
		while(t){
			frd[lowbit(t)].push_back(i);
			t-=lowbits(t);
		}
	}
	for(int i=1;i<=m;i++){
		cout<<frd[i].size()<<" ";
		int l=frd[i].size();
		for(int j=0;j<l;j++)
			cout<<frd[i][j]<<" ";
		cout<<endl;
	}
	string s;cin>>s;s=" "+s;
	if(lowbits(n)==n){
		bool flag=1;
		for(int i=1;i<s.size();i++)
			if(s[i]=='1'){
				flag=0;break;
			}
		if(flag){
			cout<<n<<endl;
			return 0;
		}
	}
	int ans=0;
	for(int i=1;i<=m;i++){
		if(s[i]=='1')
			ans+=(1<<i)/2;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：kczw (赞：1)

# 题意
小强有 $1$ 瓶坏果汁与 $n-1$ 瓶好果汁，现在小强需要将 $n$ 果汁分给几个朋友（一瓶果汁可以分给多个朋友，一个朋友可以喝不同瓶子里的果汁），然后根据他们是否拉肚子找出坏果汁。

须求出在可找出坏果汁前提下最少需要~~祸害~~分享果汁的朋友个数，以及每一位朋友分到的果汁的瓶子编号。
# 思路
首先先说一个结论，我们最少需要朋友个数就是 $n-1$ 用二进制表示的个数。

我们实际上只需要分给朋友 $n-1$ 瓶果汁，因为如果朋友们没有拉肚子，说明留下的一瓶是坏果汁。

关于如何分配 $n-1$ 瓶果汁，我们将每瓶果汁的序号转二进制，把它分配给二进制上为 $1$ 的位数的人。举个例子，分配第 $11$ 瓶果汁时，因为其二进制为 $1011$，所以它会被分配给第 $1,3,4$ 个朋友。

为什么这样分配可以保证正确呢？因为我们保证了第 $i$ 个朋友只被分配到二进制第 $i$ 位为 $1$ 的果汁，所以根据朋友们坏肚子的信息就可以得知坏果汁序号的二进制组成，意味着我们可以知道它的序号的十进制了，也就是答案。
# 实现
```cpp
#include<iostream>
#include<vector>
using namespace std;
int n,num,ans;
vector<int> m[105];
int main(){
    scanf("%d",&n);
    int t=n-1;
    while(t){
        t>>=1;
        num++;
    }printf("%d\n",num);
    cout.flush();
    for(int i=1,j;i<n;i++){
        t=i;j=1;
        while(t){
            if(t&1)m[j].emplace_back(i);
            t>>=1;
            j++;
        }
    }
    for(int i=num;i>=1;i--){
        printf("%ld ",m[i].size());
        for(int v:m[i])printf("%d ",v);
        printf("\n");
        cout.flush();
    }
    char p;
    for(int i=1;i<=num;i++){
        cin>>p;
        ans<<=1;
        ans|=(p-'0');
    }
    printf("%d\n",ans?ans:n);
    cout.flush();
    return 0;
}
```

---

## 作者：__Allen_123__ (赞：1)

一道不错的二进制题，虽然听说撞原了。赛时脑子根本没想到这个点上，没做出来。

### 题意简述

交互题，评测机会生成一个 $1\sim n$ 的整数（不给出），你需要在尽量少的询问次数下**确定**这个数，每次询问方式为：

- 给定一个任意长度的严格递增的，数字全部分布于 $[1,n]$ 的整数序列。

在你完成这些询问之后，评测机会对你的询问进行回答（以字符串的形式回答所有询问），如果生成的数字出现在了第 $i$ 个询问的序列里，那么评测机的回答字符串中第 $i$ 个字符就为 $1$，否则就为 $0$。

最后，输出评测机生成的整数。$1\le n\le 100$。

### 题目分析

我们可以以二进制形式表示每个数，第 $i$ 次询问中，我们询问的数为：$[1,n]$ 范围内，在二进制下，从低到高第 $i$ 位为 $1$ 的所有整数。例如，$n=5$，那么我们第 $1$ 次询问 $(1)_2=1, (11)_2=3,(101)_2=5$ 这些数，第 $2$ 次询问 $(10)_2=2,(11)_2=3$ 这些数，第 $3$ 次询问 $(100)_2=4,(101)_2=5$ 这些数。可以发现，如果第 $i$ 次询问的答案为 $1$，那么生成的数字（也就是坏掉的那一杯的编号）在二进制下从低到高第 $i$ 位就是 $1$。最后根据评测机给出的回答字符串，依次统计答案数字的二进制位，输出即可。

此时，我们可以发现，只需要 $\lceil\log n\rceil$ 次询问就可以求出数字。然而此时会有一种特殊情况，如果最后统计答案为 $0$（即数字没有出现在任何询问内，此时 $n=2^x$），我们就应该输出 $n$，这道题就完成了。

[AC 记录](https://atcoder.jp/contests/abc337/submissions/49514811)。

---

## 作者：_qingshu_ (赞：0)

# 题面简述：

你的手中有 $n$ 瓶果汁，其中有一瓶有毒，喝了会拉肚子。你可以找来 $m$ 个小朋友，对于任意一个小朋友，你可以给他任意瓶果汁（同一瓶果汁允许分给多名小朋友），最后你会知道每一个小朋友有没有拉肚子，询问有毒的果汁的编号。

对于输出，你需要输出 $m$（在所有的可能中输出最小值），这 $m$ 个小朋友手中果汁的分配情况，最后有毒的果汁编号。

# 思路：

发现如果这个人没有中毒，那么这个人所有的果汁都没有问题，如果中毒了，那么这个人的果汁有一个存在问题。
再看到每一个人只有中毒与否两种状态，考虑拆成二进制对于每一个 $i\in [1,n]$ 进行表示。

因为是二进制拆分的，我们考虑和用二进制一样的方式表达一个数。对于最后的结果，就是该位是否为 $1$。

代码十分的简单，用 $\mathcal{O}(n\log n)$ 的时间去枚举当前数位为 $1$ 的数有哪些，再一个一个输出。

最后统计答案的时候，如果当前这个小朋友中毒了，说明这个数位存在为 $1$，否则为 $0$。

注意，我们可以不去表达 $n$，如果最后没有人中毒有毒的就一定是最后一个,所以最优策略会将 $n$ 减一。

总时间复杂度 $\mathcal{O}(n\log n)$。

# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans;
set<int>q;
int main(){
    cin>>n;
    long long nn=n-1,m=0;
    while(nn){
        m++;
        nn>>=1;
    }
    cout<<m<<endl;cout.flush();
    for(int ck=1,a=1;a<=m;ck<<=1,a++){
        q.clear();
        for(int i=ck;i<=n-1;i++){
            if((ck&i)==ck){
                q.insert(i);
            }
        }
        cout<<q.size()<<" ";cout.flush();
        for(int i : q){
            cout<<i<<" ";cout.flush();
        }
        cout<<endl;cout.flush();
    }
    char c;
    for(int i=0;i<m;i++){
        cin>>c;
        if(c=='1'){
            ans|=(1ll<<i);
        }
    }
    cout<<(ans==0?n:ans)<<endl;
}
```

---


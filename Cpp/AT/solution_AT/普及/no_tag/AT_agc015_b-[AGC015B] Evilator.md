# [AGC015B] Evilator

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc015/tasks/agc015_b

すけぬ君は、$ N $ 階建てのビルを建てました。ビルにはエレベーターが $ 1 $ 基あり、すべての階に止まります。

すけぬ君は、各階に上下の方向ボタンを設置しましたが、うっかりしていたため、どの階にも上向きか下向きの片方のボタンしかありません。 そのため、どの階からも上か下のどちらかにしか進むことができません。 $ S_i $ が `U` のとき $ i $ 階には上向きのボタンしかなく、上にしか進めないことを、`D` のとき下向きのボタンしかなく、 下にしか進めないことを表します。

ある階から目的の階へと移動したい住民は、仕方がないので必要があれば他の階を経由して目的の階へと向かうことにしました。 全ての階の順序対 $ (i,j) $ についての、$ i $ 階から $ j $ 階へ行くときのエレベーターに乗る回数の最小値の合計を求めてください。

## 说明/提示

### 制約

- $ 2\ ≦\ |S|\ ≦\ 10^5 $
- $ S_i $ は `U` または `D` である
- $ S_1 $ は `U` である
- $ S_{|S|} $ は `D` である

### Sample Explanation 1

$ 1 $ 階から $ 2 $ 階までは、$ 1 $ 回エレベーターに乗れば行くことができます。 $ 1 $ 階から $ 3 $ 階までは、$ 1 $ 回エレベーターに乗れば行くことができます。 $ 2 $ 階から $ 1 $ 階までは、$ 2 $ 回エレベーターに乗れば行くことができます。 $ 2 $ 階から $ 3 $ 階までは、$ 1 $ 回エレベーターに乗れば行くことができます。 $ 3 $ 階から $ 1 $ 階までは、$ 1 $ 回エレベーターに乗れば行くことができます。 $ 3 $ 階から $ 2 $ 階までは、$ 1 $ 回エレベーターに乗れば行くことができます。 これらの合計は $ 7 $ なので、$ 7 $ を出力します。

## 样例 #1

### 输入

```
UUD```

### 输出

```
7```

## 样例 #2

### 输入

```
UUDUUDUD```

### 输出

```
77```

# 题解

## 作者：XKqwq (赞：2)

### 思路：

从 $u$ 楼到 $v$ 楼最多只需要乘两次电梯。因为顶楼必定往下，底楼必定往上。（~~不然飞出去了怎么办~~）

第一种情况：  $u$ 楼可以直接到 $v$ 楼，需要乘一次电梯。
  
第二种情况：  $u$ 楼不可以直接到 $v$ 楼，那么可以先前往顶楼或底楼，再前往 $v$ 楼。
 
 然后直接 $O(n)$ 解决。
 
### 代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

string s;
ll ans,l;

int main(){
	cin>>s;
	l=s.size();//因为需要多次使用长度，所以单独使用一个变量，省时间。
	for(int i=1;i<=l;++i){
		if(s[i-1] == 'U') ans=ans+i+l-2; 
		if(s[i-1] == 'D') ans=ans-i+2*l-1;
	}
	cout<<ans<<'\n';
	return 0;
}

```

 
  

---

## 作者：Yang818 (赞：2)

# key

题目翻译中其实有一个隐藏条件，就是底层电梯只能往上，顶层的电梯只能往下。~~虽然这是常识，但本蒟蒻最一开始没发现~~

# 分析

上面那个隐藏条件其实就意味着从 $u$ 到 $v$ 最少乘电梯的数量只能是 $1$ 或$2$。

为什么？

$f_{u,v}=1$ 时：在 $u$ 摁电梯可以直接到 $v$。一共 $1$ 次。

$f_{u,v}=2$ 时：在 $u$ 摁电梯的方向正好与直接到 $v$ 相反。那么就到底楼或顶楼以相反的方向再乘一次电梯。一共 $2$次。

然后就是数学的事情了。方向相同的楼层 $ans$ 加一，否则加二。

# 代码

献上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long ans;

int main(){
	cin>>s;
	for(int i=1;i<=s.size();i++){
		if(s[i-1]=='U')
			ans+=(i-2+s.size()); 
		else if(s[i-1]=='D')
			ans+=(2*s.size()-i-1);
	}
	cout<<ans;
	return 0;
}
```



---


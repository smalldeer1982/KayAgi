# [ABC083D] Wide Flip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc083/tasks/arc088_b

`0` と `1` からなる文字列 $ S $ が与えられます。 以下の操作を好きな回数繰り返すことで $ S $ の要素をすべて `0` にできるような、$ |S| $ 以下の最大の整数 $ K $ を求めてください。

- $ S $ の長さ $ K $ 以上の連続する区間 $ [l,r] $ を選ぶ(すなわち、$ r-l+1\geq\ K $ が満たされる必要がある)。$ l\leq\ i\leq\ r $ なるすべての整数 $ i $ に対し、$ S_i $ が `0` なら $ S_i $ を `1` に、$ S_i $ が `1` なら $ S_i $ を `0` に置き換える。

## 说明/提示

### 制約

- $ 1\leq\ |S|\leq\ 10^5 $
- $ S_i(1\leq\ i\leq\ N) $ は `0` または `1` である

### Sample Explanation 1

以下の操作で、$ S $ の要素をすべて `0` にできます。 - 長さ $ 3 $ の区間 $ [1,3] $ に操作を行う。$ S $ は `101` になる。 - 長さ $ 2 $ の区間 $ [1,2] $ に操作を行う。$ S $ は `011` になる。 - 長さ $ 2 $ の区間 $ [2,3] $ に操作を行う。$ S $ は `000` になる。

## 样例 #1

### 输入

```
010```

### 输出

```
2```

## 样例 #2

### 输入

```
100000000```

### 输出

```
8```

## 样例 #3

### 输入

```
00001111```

### 输出

```
4```

# 题解

## 作者：犇犇犇犇 (赞：5)

### 这种题竟然没有题解？自己来一发。

这道题的意思就是有一段$0,1$数列$s$，要求每次翻转$>=k$个数字使得所有数全为$0$，求最大的$k$。

~~有没有小学翻杯子问题的既视感~~

这道题其实最后到底是$0$还是$1$不重要，因为最后全部翻一次就好了。所以我们要考虑的是尽量**把所有数改成相同的，而不是把所有数都尽量往0去改**，也就是说只要把所有数都变成相同的就行了。

我们先考虑这种情况，$0011111$怎么翻转？当然直接把$11111$翻转啊。

$1111100$怎么翻转？很简单也是把前$5$位翻转。

推广下，若第$0$~$k$位数字都已经一样了，但是第$k-1$位和第$k$位不一样。那么这时候我们就有两种选择，**要么改0~k-1位，要么改k~n位，对于题目来说这两种操作的效果是等价的**   
题目问的是最大，所以每次操作到第$i$个数直接取$max(i,$长度$-i)$。

大家可以来体会一下

![](https://i.loli.net/2019/03/08/5c814b8f56c69.jpg)

我们每一次操作都保证了前k个数的一致，所以在对第$k+1$个数进行操作完成后可以保证前$k+1$个数是一致的，并且没有改变其他数的**相对情况**。所以这种操作一定可以满足要求。

如果从中间挑一段数$（l,r）$进行修改，那么改的数一定没有$（0，r）,（l，n）$改的数多，虽然修改的次数会少，但不是题目的要求。

所以下面就很简单了，代码很短，不知道为什么是紫题

```
#include <bits/stdc++.h>
using namespace std;
string s;
int ans=1<<30; 
int main()
{
	cin>>s;
	for(int i=1;i<s.length();i++) //一位一位枚举
		if(s[i]!=s[i-1]) //若第i-1位和第i位不一样
			ans=min(ans,max(i,int(s.length())-i)); 
            //因为每次要改动更多的，所以取max,因为所有操作都要>=k所以ans取最小。
	cout<<min(ans,int(s.length()))<<endl; //ans不大于s的长度
	return 0;
}


```



---

## 作者：lkjzyd20 (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/AT3732)


### 思路

$\because$ 要求的是 $k$ 的最大长度，

$\therefore$ 无需考虑翻转次数。

对于第 $i$ 个字符来说，假设它不等于前 $i - 1$ 个字符，前 $i - 1$ 个字符又相等，那么为了最后的结果，要么选择翻转前 $i$ 个字符，要么翻转后 $n - i$ 个字符。

因此可以去枚举字符串，寻找第 $i - 1$ 个字符与第 $i$ 个字符不同的 $i$，在 $i $ 和 $n - i$ 中去取最大的一个。

$\because$ 要求最大的长度 $k$，

$\therefore$ 在每一个字符进行翻转的最大值中选最小的一个即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int ans = INT_MAX;
int main() {
	cin >> s;
	int len = s.size () ;

	for (int i = 1; i < len ; i ++)
		if (s[i] != s[i - 1])
			ans = min (ans, max (i, len - i) ) ;

	cout << min (ans, len) << endl;
	return 0;
}
```

### 完结撒花 $\sim\sim\sim$

---


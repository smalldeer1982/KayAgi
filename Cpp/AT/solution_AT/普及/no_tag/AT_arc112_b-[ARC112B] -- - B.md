# [ARC112B] -- - B

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc112/tasks/arc112_b

すぬけくんは、整数 $ B $ を持って整数やさんを訪れました。 整数やさんでは、お金を払うことで、持っている整数を別の整数にしてもらうことができます。

具体的には、次の $ 2 $ 種類のサービスを好きな順で好きなだけ購入することができます。

- $ 1 $ 円を払い、持っている整数を $ -1 $ 倍する。
- $ 2 $ 円を払い、持っている整数から $ 1 $ を引く。

すぬけくんが $ C $ 円以内で作ることのできる整数は何通りありますか？

## 说明/提示

### 制約

- $ -10^{18}\le\ B\ \le\ 10^{18} $
- $ 1\le\ C\ \le\ 10^{18} $
- 入力はすべて整数

### Sample Explanation 1

以下のように、$ -11,10,11 $ の $ 3 $ 通りの数を作ることができます。 - 何もしないとき、$ 0 $ 円を使って $ 11 $ を作ることができる - $ 11 $ を $ -1 $ 倍すると、$ 1 $ 円を使って $ -11 $ を作ることができる - $ 11 $ から $ 1 $ を引くと、$ 2 $ 円を使って $ 10 $ を作ることができる

### Sample Explanation 2

以下のように、$ -2,-1,0,1 $ の $ 4 $ 通りの数を作ることができます。 - 何もしないとき、$ 0 $ 円を使って $ 0 $ を作ることができる - $ 0 $ から $ 1 $ を引くと、$ 2 $ 円を使って $ -1 $ を作ることができる - $ 0 $ から $ 1 $ を引いて $ -1 $ 倍すると、$ 3 $ 円を使って $ 1 $ を作ることができる - $ 0 $ から $ 1 $ を引いて $ 1 $ を引くと、$ 4 $ 円を使って $ -2 $ を作ることができる

## 样例 #1

### 输入

```
11 2```

### 输出

```
3```

## 样例 #2

### 输入

```
0 4```

### 输出

```
4```

## 样例 #3

### 输入

```
112 20210213```

### 输出

```
20210436```

## 样例 #4

### 输入

```
-211 1000000000000000000```

### 输出

```
1000000000000000422```

# 题解

## 作者：TLEWA (赞：2)

考虑将数轴分为正半轴和负半轴讨论（正半轴的数字大于 $0$，负半轴则小于 $0$），$B$ 变换得来的区间一个主要处于正半轴，一个处于负半轴，我们分别计算他们的左右边界：

对于与 $B$ 处于相同半轴的区间来说，向左扩展十分便捷，只需要一直重复 $2$ 操作即可，而向右扩展需要先进行一次 $1$ 操作，然后进行任意次 $2$ 操作后在用 $1$ 操作变换回来。设左右边界为 $L,R$，则：

$$L = B - \frac{C}{2},R = B + \frac{C-2}{2}$$

对于与 $B$ 处于不同半轴的区间，需要进行一次 $1$ 操作来保证区间主要处于不同半轴，如果将 $2$ 操作置于 $1$ 操作前，则得到的数字更大（因为 $2$ 操作的减法被乘上了 $-1$，使得最终答案增加），反之则更小。不需要两次以上的 $1$ 操作，因为可以通过安排 $2$ 操作的次序达到相同的效果。设左右边界为 $L,R$，则：

$$L = -B - \frac{C-1}{2},R = -B + \frac{C-1}{2}$$

如果区间有重复，需要在统计答案的时候去除重复区间。

将上述思路实现，得到代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long B,C,ans;
long long l1,r1; //正数轴区间 
long long l2,r2; //负数轴区间 

int main() {
	cin >> B >> C;
	//初始认为 B>0 
	l1=B - (C / 2),r1=B + ((C - 2) / 2); 
	l2=(-B) - ((C - 1) / 2),r2=(-B) + ((C - 1) / 2);
	if(B<0) { //如果 B<0,正数轴和负数轴的情况就会反过来 
		swap(l1,l2);
		swap(r1,r2);
	}
	if(l1<=r2) l1=r2+1; //去除重复区间 
	ans+=(r1-l1+1)+(r2-l2+1); //计算结果
	cout << ans << endl;
	return 0;
}

```

一切似乎都很完美，但是这个代码过不去第三个样例，当 $B = 0$ 时，它并不在正数轴和负数轴上，加上特判即可。

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long B,C,ans;
long long l1,r1; //正数轴区间 
long long l2,r2; //负数轴区间 

int main() {
	cin >> B >> C;
	//初始认为 B>0 
	l1=B - (C / 2),r1=B + ((C - 2) / 2); 
	l2=(-B) - ((C - 1) / 2),r2=(-B) + ((C - 1) / 2);
	if(B<0) { //如果 B<0,正数轴和负数轴的情况就会反过来 
		swap(l1,l2);
		swap(r1,r2);
	}
	if(B==0) l2=l1,r2=r1;//如果 B == 0,不在正数也不在负数轴上需要特判 
	if(l1<=r2) l1=r2+1; //去除重复区间 
	ans+=(r1-l1+1)+(r2-l2+1); //计算结果
	cout << ans << endl;
	return 0;
}

```


---

## 作者：yangfengzhao (赞：1)

## 思路
### 步骤 1
若有一条数轴，可以将他分成正半轴、负半轴和 ${0}$！
+ **操作 1 不能连续用**，因为 ${-1 \times -1 = 1}$。
+ **操作 2 总是向左得到数**。因为 ${C - 2}$，${B - 1}$。
---
### 步骤 2
那，如何**向右得到数**呢？\
很简单，只需要遵照这几步：
1. 只需要先使用一次操作 1；（当且仅当 ${B}$ 是一个正数，负数跳过这一步）
2. 再使用任意多次操作 2；
3. 最后使用一次操作 1。
---
### 步骤 3
那么根据 ${C}$ 的**奇偶性**来讨论：
+ 若 ${C \bmod 2 = 1}$，说明我们应该可以使用**奇数次**操作 1（假设其是 ${p}$ 次）并且可以使用 ${(C - p) \div 2}$ 次操作 2。
>奇数次使用操作 1，不代表不可以向右扩展！我们可以使用偶数 ${+1}$ 次，这样的话就可以向右扩展！
+ 若 ${C \bmod 2=0}$，满足了向右扩展不会剩下任何钱；同时，也可以选择**要么全部使用操作 2 **或使用**偶数次操作 1**。
---
### 步骤 4
此时，可以使用桶来存储可以得到的数。
>因为桶就有去重作用！
## 大体代码
```cpp
#include<iostream>
using namespace std;
using ll=long long;
ll buk[1000000],tms,bse,s;
int main()
{
    /*这里我选择使用操作 1 和操作 2 连续使用，能保证要么最后的操作 1 可以用上，要么不操作*/
    scanf("%lld%lld",&bse,&tms);
    bse=bse<0?-bse,tms--:bse;                                   //跟下面的操作有关。
    buk[bse]=1;
    if(bse==0)
    {
        return printf("%d",tms/2+tms/1-1);//0不是负数，所以不能乘上 -1！
    }
    while(tms>=0)
    {
        if(tms>=1)
        {
            buk[bse]++;             //注意，由于 C++ 不能操纵负数组，我就将数组压缩成正负半轴一起用。
            tms--;
        }
        if(tms%2==0)
        {
            buk[--bse]++;
            tms-=2;
        }
    }
    for(int i=0;i<1000000;i++)
    {
        s+=buk[i];                   //完结撒花
    }
    return 0;
}
```
## 提示
1. 使用 `long long` 来存储。因为 `long long` 的范围是 ${-2^{63}}$ 到 ${2^{63}-1}$，这个值的极限在${-10^{18}}$ 外或 ${10^{18}}$ 外。
2. 对于 ${0}$ 的情况，两种（见步骤 3）都可以用！
3. 岛国水题需要换行！

---

## 作者：ggc123 (赞：1)

## 思路
- 因为 $-1 \times -1 = 1$，所以连续进行 $2$ 次操作 1 就会变回原来的数。因此，为了让最后生成的数最多，就**不能连续进行**操作 1。

- 题目说最多使用 $C$ 元，所以这些钱可以**不用完**。

综合以上 2 点，就不难发现最终生成的数可以分成 4 种。

1. 不进行操作 1，只进行 $k$ 次操作 2。

    此时得到的数的集合为 
$$W=\left \{ x|x\in \mathbb{Z},B-\left \lfloor \frac{C}{2}  \right \rfloor \le x\le B   \right \} $$

2. 先进行 $1$ 次操作 1，再进行 $k$ 次操作 2。

   此时得到的数的集合为
$$X=\left \{ x|x\in \mathbb{Z},-B-\left \lfloor \frac{C-1}{2}  \right \rfloor \le x\le -B   \right \} $$

3. 先进行 $k$ 次操作 2，再进行 $1$ 次操作 1。

   此时得到的数的集合为
$$Y=\left \{ x|x\in \mathbb{Z},-B \le x\le -B+\left \lfloor \frac{C-1}{2}  \right \rfloor    \right \} $$

4. 先进行 $1$ 次操作 1，再进行 $k$ 次操作 2，最后进行 $1$ 次操作 1。

   此时得到的数的集合为
$$Z=\left \{ x|x\in \mathbb{Z},  B \le x \le B+\left \lfloor \frac{C-2}{2}  \right \rfloor   \right \} $$


所以，
$$ ans=\left | W \cup X \cup Y \cup Z  \right | = 
\left | \left \{ x|x\in \mathbb{Z},B-\left \lfloor \frac{C}{2}  \right \rfloor \le x\le B+\left \lfloor \frac{C-2}{2}  \right \rfloor    \right \} \cup  
\left \{ x|x\in \mathbb{Z},-B-\left \lfloor \frac{C-1}{2}  \right \rfloor \le x\le -B+\left \lfloor \frac{C-1}{2}  \right \rfloor    \right \} \right | $$

令 

$$M=\left \{ x|x\in \mathbb{Z},B-\left \lfloor \frac{C}{2}  \right \rfloor \le x\le B+\left \lfloor \frac{C-2}{2}  \right \rfloor    \right \}$$

$$N=\left \{ x|x\in \mathbb{Z},-B-\left \lfloor \frac{C-1}{2}  \right \rfloor \le x\le -B+\left \lfloor \frac{C-1}{2}  \right \rfloor    \right \}$$

所以
$$ans=\left | M \right | +\left | N \right | -\left |  M\cap N\right | $$


## 代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int b, c, ans = 0;
signed main() {
	cin.tie(0), cout.tie(0);
	cin >> b >> c;
	if (b == 0) {// b = 0 时，特判
		cout << c / 2 + 1 + (c - 1) / 2;
		return 0;
	}
	int l1 = b - c / 2, r1 = b + (c - 2) / 2;
	int l2 = -b - (c - 1) / 2, r2 = -b + (c - 1) / 2;
	if (b < 0) {// b < 0 时，集合 M 与集合 N 是反的
		swap(l1, l2);
		swap(r1, r2);
	}
	cout << (r1 - l1 + 1) + (r2 - l2 + 1) - (l1 <= r2 ? (r2 - l1 + 1) : 0);
	return 0;
}
```

---

## 作者：Walrus (赞：0)

首先要看到题目中说的是「最多」而不是刚好花费 $C$ 元。

这给了我们一个启发：答案一定是两段区间（可能相交）。

假设这是一条数轴。

- 为什么是两段：显然「乘 -1」 的操作可以改变符号，也就是说答案可以到达正负半轴。
- 为什么是一段区间：这里通过举例子来说明。
	
    - 假设当前数为 -8，若答案包括 -10，则答案一定也包括 -9。
    - 假设当前数为 8，若答案包括 10，则答案一定也包括 9。（先乘 -1 再减 1 再乘 -1 可将一个数加 1）。
   
所以只需求出答案区间再判断是否有交集。

首先是与 $B$ 同号的情况，比较易知，向左的话直接花费 2 元一直减 1，向右的话先变号再一直减 1 最后变回去。

故有 $l1=B-\dfrac{C}{2}$。同样的，$r1=B+\dfrac{C-2}{2}$。不过有个小细节，如果 $C\leq2$ 就不能两次变符号，所以注意和 0 取 $\max$。

异号区间也比较好得到，先变号然后同上述操作即可。

所以 $l2=-B-\dfrac{C-1}{2}$。同样的，$r2=-B+\dfrac{C-1}{2}$。

判断区间是否有交集，如果有，则两端区间合并算；如果没有，则分开算。

时间复杂度 $O(1)$。

[code](https://atcoder.jp/contests/arc112/submissions/55874370)

---

## 作者：XYQ_102 (赞：0)

## 思路
不妨考虑一个子问题：恰好花费 $C$ 的时候，能得到的取值方案数是多少。

可以注意到花费为 $1$ 让之乘 $−1$ 的操作对于拓宽方案来说没有很大意义，重点考虑花费 $2$ 能让他减 $1$ 的操作上，可以根据钱的奇偶性讨论：

- 若 $C$ 为奇数，那么 $C$ 最多可以使用 $n=\lfloor  C\div2\rfloor$ 次 $-1$ 操作，并且还需要使用一次乘 $-1$ 操作。为了求方案数，套路是讨论极值的范围以及中间的取值是否都能取到：首先极值就是尽量  $-1$，再通过乘 $-1$ 操作让他成最大或者最小值；其次是中间的部分由于操作是 $-1$ 所以取值也是连续的，只需要把某些操作替换成两次没有意义的乘 $-1$ 操作就可以了。在这种情况下：先 $-n$ 再乘 $-1$ 可以得到最大值 $n-B$。反过来可以在最开始就乘 $-1$ 再 $-n$，这样取值就是 $(-B)-n$ 了。

- 若 $C$ 为偶数，那么此时有两种情况：要么不使用乘 $-1$ 操作，要么用两次。对于前一种操作来说，极值是 $B-n$，对于后者来说,极值是 $n-(B-1)$ 和 $(-B)-(n-1)$，两者合并即可。

现在考虑原来的问题：至多是 $C$ 花费的方案数。首先方案这么多不可能一个个去冗斥，这里有个非常巧妙的性质：对花费 $C=k+2$ 能取到的方案数是完全包含 $C=k$ 能取到的方案数。所以只需要求出最大的两种：$C$ 和 $C−1$ 的答案并且做一个简单的冗斥就可以了。

设两个恰好花费的得到的区间分别是 $(a,b)$ 和 $(c,d)$，那么只需要两个直接加起来并且去掉交集就可以了。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define forn(i,x,n) for(int i = x;i <= n;++i)	

void solve(ll B,ll C,ll& a,ll& b)
{
	if(C & 1)
	{
		a = -B - C / 2;
		b = C / 2 - B;
	}
	else
	{
		a = B - C / 2;
		b = B + (C / 2 - 1);
	}
}

int main() 
{
	ll B,C;cin >> B >> C;
	if(C == 1)
	{
		if(B == 0)	cout << "1";
		else cout << "2";
		return 0;
	}
	
	ll a,b,c,d;
	solve(B,C,a,b);
	solve(B,C - 1,c,d);
	cout << max(0ll,b - a + 1) + max(0ll,d - c + 1) - max(0ll,min(b,d) - max(a,c) + 1);
	
	return 0;
}

```

---

## 作者：Zikake (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/AT_arc112_b)

- 	先考虑恰好花费 $C$ 的时候，能得到的取值方案数。花费为 $1$ 的操作对拓宽方案数并无多大意义，应重点注意花费为 $2$ 减 $1$ 的操作。$C$ 的奇偶性不定，需要讨论。



- 	最后考虑至多花费 $C$ 的时候，能得到的取值方案数。这么多方案很难一个个去容斥，思考一下：花费 $C = k + 2$ 能取到的方案数完全包含 $C = k$ 的方案数，因而我们只需考虑 $C$，$C -1$ 的方案数交集就好了，因为 $C$，$C - 1$ 时包含了前面的所有方案数，容斥这两种情况下的就好了。设两个恰好花费的区间分别为 $(a, b)$，$(c, d)$ 容斥一下就好了。但是注意如果 $C = 1$ 的话就没有 $C$ 和 $C - 1$ 的情况了。如果 $C = 1$，如果 $B = 0$，则输出 $0$，否则输出 $2$。

## ACcode
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
signed main()
{
	cin>>n>>k;
	if(n>0) return cout<<min(n,k/2)+min(n-1,(k-1)/2)+(k-1)/2+(k-2)/2+2,0;
	if(n<0) return cout<<k/2+(k-1)/2+min(-n,(k-1)/2)+min(-n-1,(k-2)/2)+2,0;
	if(n==0) return cout<<k/2+(k-1)/2+1,0;
}
```


---


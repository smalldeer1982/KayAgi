# Harlequin

## 题目描述

[problemUrl]: https://atcoder.jp/contests/caddi2018b/tasks/caddi2018_b

一本のりんごの木があり、$ N $ 色のりんごが実っています。これらのりんごの $ N $ 種類の色には $ 1 $ から $ N $ までの番号が振られており、$ i $ 番の色のりんごは $ a_i $ 個あります。

あなたとダックスフンドのルンルンは、以下の行動を交互に行います (あなたから始めます)。

- 木から $ 1 $ 個以上のりんごを選んで食べる。ただし、一度に選ぶりんごは全て異なる色でなければならない。

木から最後のりんごを食べた者を勝者とします。あなたとルンルンがともに最善を尽くすとき、どちらが勝つでしょうか？

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ a_i\ <\ =\ 10^9 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

$ 1 $ 番の色を赤、$ 2 $ 番の色を青とします。この例では、木には赤いりんご $ 1 $ 個と青いりんご $ 2 $ 個が実っています。 あなたは最初の手番で赤いりんごを食べるべきです。すると、ルンルンは青いりんごのうち片方を食べるほかなく、次の手番であなたがもう片方を食べて勝つことができます。 なお、あなたは最初の手番で両方の色のりんごを $ 1 $ 個ずつ食べることもできます (勝ちには繋がりませんが)。

## 样例 #1

### 输入

```
2
1
2```

### 输出

```
first```

## 样例 #2

### 输入

```
3
100000
30000
20000```

### 输出

```
second```

# 题解

## 作者：Pink_Cut_Tree (赞：3)

### 思路 

这道题明显是一道博弈论问题。

### 分析

先亮结论：**如果每一种颜色的苹果数量全部为奇数，那么先手必胜；否则，先手必败**。下面给出证明：

怎么样算是自己胜利呢？就是自己吃完苹果后，所有颜色的苹果的个数都是 $0$。

在最开始的局面中，存在着 $n$ 堆数量为 $2k$ 或 $2k+1$ 的苹果（$k \in Z^+$)。

定义一个“好局面”为所有堆苹果个数都是奇数，其余情况均为“坏局面”。

如果所现在面对“好局面”，先手可以将所有数量为奇数的堆全部吃掉 $1$ 个苹果，此时转化为对手的“坏局面”。

无论对手怎么吃，自己还可以将所有数量为奇数的堆全部吃掉 $1$ 个苹果，对手还会面对“坏局面”。

到最后，自己会面对一个所有堆苹果数量都是 $1$ 的“好局面”，自己只需吃掉所有苹果即可获胜！

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std; 
int main(){
	int a,b;
	cin>>a;
	while(a--){ //每次判断
		cin>>b;
		if(b%2){ //坏局面
			cout<<"first\n"; return 0; //直接结束程序
		}
	}
	cout<<"second\n"; //我胜利
return 0;	
}
```


---

## 作者：Register_int (赞：2)

考虑操作的本质，实际上是**改变至少一堆苹果的奇偶性**。不妨只考虑每种颜色苹果数量 $\bmod\ 2$ 的值（即 $0$ 或 $1$）。接下来这个事实：

- 每堆苹果数全为偶数的局面为必败态，否则为必胜态。

对于最终结果（全吃完），每堆苹果数量都为偶数，这时从先手来看属于必败态，因为苹果已经吃完。当苹果还未被吃完，且每堆的数量为偶数时，先手必须要改变至少一个数的奇偶性，从而转变为后手的必胜态。

对于不全为偶数的情况，先手可以选择改变所有当前为奇数的堆的奇偶性，从而使局面转化为对后手的必败态，所以该局面为必胜态。

只需要读入苹果数量并判断奇偶性即可。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;

int x;

int main() {
	for (scanf("%*d"); ~scanf("%d", &x);) if (x & 1) return puts("first"), 0;
	puts("second");
}
```

---

## 作者：Soul_Seeker (赞：2)

# AT_caddi2018_b Harlequin 题解

[题目传送门](https://www.luogu.com.cn/problem/AT_caddi2018_b)

## 题目大意

有 $n$ 种颜色的苹果，每一轮你可以吃掉一些不同颜色的苹果，求吃下最后一个苹果的人。

## 思路阐述

假设状态 $1$ 为任意种类的苹果数目都是偶数，状态 $2$ 为任意种类的苹果数目都是奇数。

那么如果处于状态 $1$, 那么拿走一个或多个苹果，这样转换成状态 $2$ 。

由于对手足够聪明，他一定会将苹果个数转换为状态 $1$ 。

你再将苹果个数转换为状态 $2$ ……

就这样，当苹果的个数皆为 $1$ 时，刚好是状态 $2$ ，是对手的回合，那么他就赢了。

所以我们发现结论：

- 当初始状态为 $1$ 时，先手必赢。

- 当初始状态为 $2$ 时，先手必输。

因此，我们写代码时只要判断 $a_i$ 是奇数还是偶数就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n, x;
	cin >> n;
	while (n--) {
		cin >> x;
		if (x % 2)return cout << "first", 0;
	}
	cout << "second";
	return 0;
}

```


---

## 作者：Nuyoah_awa (赞：2)

### 题目大意
有 $n$ 种颜色的苹果，每回你可以选一些颜色不同的苹果，吃掉它们，吃掉最后一个苹果的人胜，请问最后谁会胜。

### 题目分析

这题很明显是一个博弈论，我们可以先找出一个最简单的先手必胜/败的局面，然后用它来推出所有局面。

首先，我们先来看胜利后的局面：所有的颜色个数都是 $0$。

于是，我们可以知道当前局面如果全是 $1$ 时（颜色为 $0$ 的不算），一定是先手必胜的。

因为对手足够聪明，所以我们可以知道如果对手面对的局面全是 $1$ 的话他肯定就直接胜了，所以再往前一个局面一定是一些 $1$ 和 一些 $2$ 构成的，所以如果局面上是由一些 $1$ 和一些 $2$ 组成时一定是一个先手必败的局面。

然后我们来证明一下：当我们面对的局面是一些 $2$ 和一些 $1$ 组成时我们肯定不能把所有 $2$ 都变成 $1$，所以我们吃完后一定会剩一些 $2$，而对手只需要把那些 $1$ 全部吃掉，我们就只剩 $2$ 了，但是我们每回必须剩一些 $2$，于是当我们吃的只剩一个 $2$ 时，我们就败了。

同理，当我们的局面中有 $2$ 的倍数，我们就是一个先手必败的局面。

证明同上，我们有一些 $2 \times k + 1$ 和一些 $2 \times k$ 的，我们经过多次吃后，对方只要吃我们吃的（与我们吃一样的）最后就会胜多个 $1$，所以我们是先手必败的。

也就是说如果我们的局面中全是 $2 \times k + 1$ 时，我们才是先手必胜的。

### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, a;
int main()
{
    scanf("%d", &n);
    while(n--)
    {
        scanf("%d", &a);
        if(a % 2)
        {
            printf("first\n");
            return 0;
        }
    }
    printf("second\n");
    return 0;   
}
```

---

## 作者：JackMerryYoung (赞：0)

# 前言

略微需要思考的博弈论。

# 正文

由于是个问你谁获胜的问题，我们考虑博弈论。

设状态 $A$ 为任意种类的苹果数目都是偶数，状态 $B$ 为任意种类的苹果数目都是奇数。

最优想法：

如果处于状态 $A$, 那么拿走一个或多个苹果，这样转换成状态 $B$.

那么这样子肯定会让当前处于状态 $A$ 的人的对手拿到最后一个苹果。

可以知道：如果一开始是 $A$ 状态，那么对面为了获胜肯定要将我们陷入循环。最终如上述，会输给对面。

如果一开始是非 $A$ 状态，考虑转换成对手的 $A$.

可以发现，这一策略切实可行（因为可以一开始只吃所有奇数数目种类的一个苹果）。之后只要模仿对手即可。

所以我们发现结论：

- 当初始状态不为 $A$ 时，先手必赢。

- 当初始状态为 $A$ 时，先手必输。

代码就很好写了。复杂度最大为 $\mathcal{O}(N)$, 显然可以过。

# 代码

~~你们最想要的..~~ 

Talk is$\color{white}\text{n't}$ cheap, $\color{white}\text{Don't}$ show me the code...

``` cpp
#include <bits/stdc++.h>
using namespace std;

int N;

int main()
{
	cin >> N;
	for(int i = 1; i <= N; ++ i)
	{
		int x;
		cin >> x;
		if(x % 2 == 1)
		{
			cout << "first" << endl;
			return 0;
		}
	}
	
	cout << "second" << endl;
	return 0;
}
```

# 后言

博弈论的题解还是第一次写，不知道怎么表述，请见谅。

---


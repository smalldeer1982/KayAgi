# K個のケーキ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_b

$ K $ 個のケーキがあります。高橋君は、1日に一つずつ、$ K $ 日かけてこれらのケーキを食べようと考えています。

ケーキは$ T $ 種類あり、種類$ i\ (1≦i≦T) $ のケーキは$ a_i $ 個あります。

二日連続で同じ種類のケーキを食べると飽きてしまうため、高橋君は、うまくケーキを食べる順番を決めて、前日と同じ種類のケーキを食べる日数を最小にしようと考えました。

高橋君のために前日と同じ種類のケーキを食べる日数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1≦K≦10000,\ 1≦T≦100 $
- $ 1≦a_i≦100 $
- $ a_1+a_2+ $...$ +a_T\ =\ K $

### Sample Explanation 1

ケーキは$ 7 $個あります。例えば種類$ 2,1,2,3,1,3,1 $の順で食べると一度も前日と同じ種類のケーキを食べなくてすみます。

### Sample Explanation 2

ケーキは$ 6 $個あります。種類$ 2,3,2,2,1,2 $の順で食べると4日目だけ前日と同じ種類$ 2 $のケーキを食べることになり、これが最小になるので答えは$ 1 $です。

### Sample Explanation 3

高橋君は一種類のケーキしか持っていないため、2日目以降は毎日前日と同じ種類のケーキを食べるしかありません。

## 样例 #1

### 输入

```
7 3
3 2 2```

### 输出

```
0```

## 样例 #2

### 输入

```
6 3
1 4 1```

### 输出

```
1```

## 样例 #3

### 输入

```
100 1
100```

### 输出

```
99```

# 题解

## 作者：快乐一凡 (赞：3)

### 分析：
这道题其他地方都没有什么难度，最重要的部分就是推导出公式。

公式分解：

1. 首先我们找出蛋糕数量最多的那一个来，无论如何最后余下的一定是他 。
1. 这个蛋糕一定得在每两个其他蛋糕之间都要插空，才能保证它末尾余下的最少，即为 $maxn * 2$ 。
1. 再减去其他的蛋糕，化简后为$k$ 。
1. 别忘了第一个，需要再减一。（第一天的需要减去才行，不然就会错！）

所以我们最终得到的计算公式为: 
$max*2-k-1$

减去的为第一天的。
### 代码实现：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long k,t;
	cin>>k>>t;
	long long x;
	long long maxn=-1;
	for(int i=1;i<=t;i++){
		cin>>x;
		maxn=max(maxn,x);
	}
	long long ans=max(maxn*2-k-1,0ll);	 
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Ca1JH (赞：2)

~~为什么这么水的题，发题解和写题的人都很少~~

好吧我们一眼(并不是)就能看出来答案为
```cpp
max（a[t]*2-k-1，0）//化简后的
```
就是找出最大的某种糖，然后让各种其他糖轮番上阵消耗他

直到最大的糖 ~~呼哧呼哧喘气~~ 消耗完为止 （都是瞎掰的不对请指正）

然后注意一些代码里注释的细节和换行就OK啦

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,t,a[10005];
int main() 
{
    cin>>k>>t;
    for(int i=1;i<=t;i++)
    {
        cin>>a[i];
    }
    //输入 
    sort(a+1,a+t+1);//排序找出最大的 
    cout<<max(a[t]*2-1-k,0)<<endl;//-1是减第一天 
    return 0; 
}
```


---

## 作者：银银银 (赞：2)

又是岛国题

原题目链接  [K個のケーキ / K Cakes](https://www.luogu.com.cn/problem/AT2085)

这道题其实也不难吧，只要你有耐心，反复读题目，就会得到

最终输出的答案=max(最多的蛋糕−1−(k−最多的蛋糕),0)

还是提醒一下：**岛国题要换行**

好吧好吧，没什么好说的了，可以上代码了吧

```
#include<bits/stdc++.h>
using namespace std;
int main() 
{
	int n,T;//如果最多的蛋糕有n个，T是原题变量 
	cin>>n>>T;//输入 
	int k=0;//k就不用多说了吧，原题的变量 
	for(int i=1;i<=T;++i) //通过循环来尝试得出k的正确值 
	{
		int a;//要用另一个变量 
		cin>>a;//这个也是要输入的 
		k=max(k,a);//看看哪个大，把大的赋值给k 
	}
	cout<<max(k-1-(n-k),0)<<endl;//使用公式
	return 0; 
}
```

[我哪会用不AC的代码骗你呢](https://www.luogu.com.cn/record/31306044)

还是祝愿本题解对大家有帮助吧

---

## 作者：phil071128 (赞：0)

# 题解 AT2085 【K個のケーキ / K Cakes】

## 思路：数论

这道题我觉得主要还是看对样例的理解，如果您对本题样例有疑问，可以看我的题解

#### 样例1

有7个蛋糕，分配方案可以是a,b,c,a,b,a,c

故不输出

#### 样例2

有6个蛋糕，分配方案可以是b,b,a,b,c,b

故输出1

#### 样例3

有100个蛋糕，分配方案可以是a,a,a.....a

故输出99

然后是公式的推导（感觉楼上讲的也不是特别明白）

1. 首先我们找出蛋糕数量最多的那一个来，无论如何最后余下的一定是他
2. 这个蛋糕一定得在每两个其他蛋糕之间都要插空，才能保证它末尾余下的最少，即为 $ maxn*2 $
3. 再减去其他的蛋糕，化简后为k
4. 别忘了第一个，需要再减一

例如这个样例：

```cpp
10 3
3 2 6
```
按照这种排法：
```cpp
a c b c a c b c a c c
```

输出

1

完美~~~


所以最后的答案就是：
$ maxn*2-k-1$

减1是减去第一个蛋糕

代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
	long long k,t;
	cin>>k>>t;
	long long x;
	long long maxn=-1;
	for(int i=1;i<=t;i++){
		cin>>x;
		maxn=max(maxn,x);
	}
	long long ans=max(maxn*2-k-1,0ll);	 
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：学而思李老师 (赞：0)

发现楼下对于公式的推理讲的不是很详细，这里补充一下这个公式是怎么推出来的。

首先，这题的策略就是找到一个这些蛋糕里面的最大块数 $n$，把其它几堆蛋糕和这最大一堆穿插吃，最后找不到配对的直接输出。那么，其它几堆蛋糕的总和就是总蛋糕数减去最大一堆，也就是 $k-n$。进行配对后，剩下的蛋糕总数其实应该是 $|n+k-(k-n)|$ 块。但是，如果其它几堆的和大于最大一堆的话，其它几堆中间又可以穿插吃，所以这个绝对值可以拆掉变成 $n+k-(k-n)$。

算出了差出的蛋糕数量，我们发现， $k-(k-n)$ 块蛋糕中，有 $k-(k-n)-1$ 个间隔（其实其它题解中为什么 $-1$ 说的是减去第一天，其实应该是求间隔数目）。

但是，这个数可能是负数，这就是之前提到的“其它几堆的和大于最大一堆”的情况，所以答案为0。

---

## 作者：所有人袛旳 (赞：0)

本蒟蒻的第一篇题解，希望能过。

本人博客[所有人袛旳 的博客](https://www.luogu.com.cn/blog/xltc20110611n/)

放上题目链接[K個のケーキ / K Cakes](https://www.luogu.com.cn/problem/AT2085)

输入：先输入K和T，再输入每种蛋糕的数量。

输出：就是输出他有连续几天吃同一种蛋糕，如果可以保证每连续两天吃的蛋糕都是不同种类的，直接输出endl。
# 思路
### 仔细想一想，什么时候会有连续两天吃同一种蛋糕呢？
 _不就是没有其他蛋糕去拆散这个连续性吗？_
###  再想一想，为什么没有蛋糕能够拆散连续性？
 _因为没有了。_
### 什么样的蛋糕会不被拆散呢？  
 _肯定是那些这种蛋糕的数量比其它蛋糕的数量多的蛋糕_，
 **所以只有蛋糕数最多的蛋糕可以符合这个要求**
### 问题是有连续几天是一样的
呃呃呃，其实，直接用最大蛋糕数减去其余蛋糕数就行了。如果结果不是正数，直接endl，就行了，如果结果是整数，就把差-1输出就行了。
#### 注意！注意！注意！还要减一！
![](https://cdn.luogu.com.cn/upload/image_hosting/bt6d0x5s.png)
# 代码实现
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int k,t,c[10005],i,ma;//不需要longlong
int main()
{
	cin>>k>>t;
	for(i=0;i<t;i++){
		cin>>c[i];
		if(ma<c[i]) ma=c[i];//录入最大值
	}
	k-=ma;
	if(ma<=k){
		cout<<endl;//日本的题似乎也许需要endl；
	}else{
		cout<<ma-k-1<<endl;
	}
	return 0;//完美地结束
}
```


---

## 作者：lky1433223 (赞：0)

没想到A题那么多题解 B题就只有这几个了。。。

# [推销博客](https://www.cnblogs.com/Shiina-Rikka/p/11769551.html)

我们考虑如何才能尽可能的让他不吃到同样的蛋糕。一定是相同蛋糕之间有其他蛋糕隔开。因此出现次数最多的蛋糕一定可以用来分割其他的蛋糕。而如果有蛋糕相邻，也一定是出现次数最多的蛋糕已经将其余蛋糕完全分割依旧有剩余。

设最多的蛋糕有n块。

答案就是:$max(n - 1 - (k - n), 0)$

注：减一是因为第一天并不计算。
```cpp
//代码的变量名和题目不一样
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n, T;
	cin >> n >> T;
	int mx = 0;
	for(register int i = 1; i <= T; ++i)
	{
		int x;
		cin >> x;
		mx = max(mx, x);
	}
	cout << max(mx - 1 - (n - mx), 0) << endl;
} 
```

---

## 作者：Raw_Aya9285 (赞：0)

贡献了5次提交的题目！！！

下面是推理时间：

---
先把头文件和输入写出来吧~

```cpp
#include<iostream>

using namespace std;

int main(){

    int a,b,k[10001];  
    
    //a,b对应题目中的k,t
    
    //k用来储存输入的a[i]
    
    cin>>a>>b;
    
    for(int i=0;i<b;i++){
    
        cin>>k[i];
    
    }
    
    //基本输入
```

我们看看样例#3：

100 1

100

输出：99

很明显是100-1！

所以我们可以写一个特判节省时间：

```cpp
if(b==1){
    
    cout<<k[0]-1<<endl;
    
    //为什么写k[0]-1呢？
    
    //是因为如果b=1，那么肯定只输入一个数，所以k[0]就可以惹
    
    return 0;
}
```

然后正式分析各种情况。

仔细观察样例，再推了几个数，我终于推出来：

如果任意一个数都小于另外所有数的和，那么不会有重复的情况，即输出0（如样例#1）。

但是如果有大于的情况呢？

又推了一会儿，我推出来规律了：

重复的情况=这个数-其他所有数的和-1.（如样例#2）

所以代码如下：

```cpp
else{
    
    int ans=0;
    
    for(int i=0;i<b;i++){  //枚举数
        
        for(int j=0;j<b;j++){
            
            ans+=k[j];
        
        }
            
        ans-=k[i];  //求其他数和
            
        if(ans<k[i]){  //如果这个数大于其他数和
                
            cout<<k[i]-ans-1<<endl;  //输出上面说的
                
            return 0;  //可以直接return 0了
            
        }
    
    }

}
    
    cout<<0<<endl;  //如果任何一个数都小于其他数的和则输出0
    
    return 0;  //结束
}
```

兴冲冲去提交了，结果。。。

![](https://s2.ax1x.com/2019/05/18/EOMB1U.png)

原来是ans没有归零！！！

所以加了归零后，变成如下AC代码：

```cpp

#include<iostream>
using namespace std;
int main(){
    while(1){
    	cout<<"I am a cheater";  //请勿抄袭
    }
    int a,b,k[10001];
    cin>>a>>b;
    for(int i=0;i<b;i++){
        cin>>k[i];
    }
    if(b==1){
        cout<<k[0]-1<<endl;
        return 0;
    }else{
        int ans=0;
        for(int i=0;i<b;i++){
            for(int j=0;j<b;j++){
                ans+=k[j];
            }
            ans-=k[i];
            if(ans<k[i]){
                cout<<k[i]-ans-1<<endl;
                return 0;
            }else{
            	ans=0;
			}
        }
    }
    cout<<0<<endl;
    return 0;
}

感谢观看！

---


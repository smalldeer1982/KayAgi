# Two Piles

## 题目描述

[problemUrl]: https://atcoder.jp/contests/cpsco2019-s2/tasks/cpsco2019_s2_d

 $ A $ 枚のコインがある $ 1 $ つの山と、 $ B $ 枚のコインがある $ 1 $ つの山があります。 この$ 2 $つの山を使ってAliceとBobがゲームをします。

Aliceを先手として、$ 2 $ 人は以下の操作を交互に繰り返します。

- $ 1 $ 枚以上のコインがある山を $ 1 $ つ選ぶ。そこにあるコインの枚数を $ X $ とする。
- その後、$ 2 $ つの山からそれぞれ $ 0 $ 枚以上のコインを取り除く。
- ただし、取り除くコインの枚数の合計は $ X $ でなければならない。

 どの山にもコインがなくなった時点で終了し、最後に操作した人が勝ちます。

$ 2 $ 人が最適に行動したとき、Aliceが勝つかどうか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ A\ \leq\ 10^5 $
- $ 1\ \leq\ B\ \leq\ 10^5 $
- 入力はすべて整数である。

### Sample Explanation 1

Aliceがそれぞれの山から $ 1 $ 枚ずつコインを取って $ (1,\ 1) $ にすると、Bobは残りのどちらか $ 1 $ 枚を取って $ (1,\ 0) $ にするしかなく、残りの $ 1 $ 枚をAliceが取って勝利します。

## 样例 #1

### 输入

```
2 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3```

### 输出

```
No```

# 题解

## 作者：yuanzongzi799 (赞：3)

本题显然是一道博弈论题。遇到这类问题，我们直接根据题意模拟即可。

### 上来先下个定论：只要 Alice 抢在 Bob 前使两堆硬币都剩下偶数，则 Alice 必胜！


假设 $A=1$，$B=1$，则 Alice 只能拿走 $1$ 枚硬币，Bob 拿走最后一枚硬币，**Bob 胜**。

假设  $A=2$，$B=2$，则 Alice 从每堆中都拿走 $1$ 枚硬币，此时 $A$ 堆剩下 $1$ 枚，$B$ 堆剩下 $1$  枚，Bob 只能拿走 $1$ 枚，Alice 拿走最后一枚硬币，**Alice 胜**。

假设  $A=4$，$B=4$，则 Alice 从 $A$ 堆中拿走 $2$ 枚硬币，从 $B$ 堆中拿走 $2$ 枚硬币，此时 $A$ 堆剩下 $2$ 枚，$B$ 堆剩下 $2$  枚，Bob 从 $A$ 堆中拿走 $2$ 枚硬币，从 $B$ 堆中拿走 $0$ 枚硬币，此时 $A$ 堆剩下 $2$ 枚，$B$ 堆剩下 $0$  枚，Alice 拿走最后 $2$ 枚硬币，**Alice 胜**。

假设  $A=5$，$B=5$， Alice 从 $A$ 堆中拿走 $2$ 枚硬币，从 $B$ 堆中拿走 $3$ 枚硬币，此时 $A$ 堆剩下 $3$ 枚，$B$ 堆剩下 $2$ 枚，Bob 从 $A$ 堆中拿走 $2$ 枚硬币，从 $1$ 堆中拿走 $1$ 枚硬币，此时 $A$ 堆剩下 $1$ 枚，$B$ 堆剩下 $1$  枚，Alice 从 $A$ 堆中拿走 $1$ 枚硬币，从 $B$ 堆中拿走 $0$ 枚硬币，Bob 拿走最后一枚硬币，**Bob 胜**。

假设  $A=6$，$B=5$，则 Alice 从 $A$ 堆中拿走 $2$ 枚硬币，从 $B$ 堆中拿走 $3$ 枚硬币，此时 $A$ 堆剩下 $4$ 枚，$B$ 堆剩下 $2$  枚，Bob 从 $A$ 堆中拿走 $4$ 枚硬币，从 $B$ 堆中拿走 $0$ 枚硬币，此时 $A$ 堆剩下 $0$ 枚，$B$ 堆剩下 $2$  枚，Alice 拿走最后 $2$ 枚硬币，**Alice 胜**。

发现一：观察上面的结果，不难发现：只要有一方使其中一堆硬币的数量变成 $1$，则这个人一定只能把其中一堆全部拿走，下一个人就可以拿到最后一枚硬币，因此这个人必输。

再观察上面的结果，不难发现：只要 Alice 抢在 Bob 前使两堆硬币都剩下偶数，Bob 就无法使两堆都是偶数（也就是说两堆中的一堆一定是奇数，那么“发现一”的规律只会出现在 Bob 身上），则 Alice 必胜；所以，只要 $A$ 堆或 $B$ 堆中有一堆的个数是偶数，则 Alice 一定能抢先使两堆硬币都剩下偶数。

所以，当 $A$ 为偶数或 $B$ 为偶数时，Alice 胜；当 $A$ 和 $B$ 均为奇数时，Bob 胜。



参考代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	(a%2==0||b%2==0)?cout<<"Yes\n":cout<<"No\n";//等同于if(a%2==0||b%2==0)cout<<"Yes\n";else cout<<"No\n";
	return 0;
}
```

---

## 作者：LJQ0808 (赞：2)

[传送门](https://www.luogu.com.cn/problem/AT_cpsco2019_s2_d)

题解

当 $A = 1$，$B = 1$ 时，则 Alice 只能拿走 $1$ 枚硬币，Bob 拿走最后 $1$ 枚硬币，Bob 胜。(两个奇数)

当 $A = 2$，$B = 3$ 时，则 Alice 从第 $1$ 堆拿走 $2$ 枚硬币，第 $2$ 堆拿走 $1$ 枚硬币，则 Bob 只能拿走 $1$ 枚硬币，Alice 拿走最后 $1$ 枚硬币，Alice 胜。(一个奇数，一个偶数)

当 $A = 2$，$B =2$ 时，则 Alice 从第 $1$ 堆拿走 $1$ 枚硬币，第 $2$ 堆拿走 $1$ 枚硬币，则 Bob 只能拿走 $1$ 枚硬币，Alice 拿走最后 $1$ 枚硬币，Alice 胜。(两个偶数)

所以，当 $A$ 为奇数, $B$ 为奇数 时，Alice 那拿一堆，必有一堆为偶数。

最后我们可以知道 $A$ 或 $B$ 有一个为 $2$ 倍，Alice 胜，否则 Bob 胜。

AC code:
```
#include<bits/stdc++.h>
using namespace std;
int a,b;
signed main(){
	//HAPPY!
	cin.tie(0);
	cout.tie(0);
	ios_base::sync_with_stdio(0);
	cin>>a>>b;
	if(a%2==0 || b%2==0){
		cout<<"Yes\n";
	}
	else{
		cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：Rainbow_SYX (赞：0)

# 本题是一道博弈论题
~~不知道各位有没有玩过这样的游戏呢?~~
## 思路
题目大意很简单，我们直接开始模拟。

假设 $A=1$，$B=1$，则 Alice 只能拿走一枚硬币，Bob 拿走剩下的一枚硬币，**Bob 胜**。

假设 $A=1$，$B=2$，则 Alice 只能从第二堆拿走一枚硬币（一开始 Alice 不管拿完哪堆都是输），此时 $A=1$，$B=1$，Bob 只能拿走任意一堆的一枚硬币，Alice 拿走剩下的一枚硬币，**Alice 胜**。

假设 $A=1$，$B=3$，则 Alice 拿走 $B$ 堆的一枚硬币（与上同理），Bob 也拿走一枚硬币，此时 $A=1$，$B=1$，Alice 怎么拿都是输，**Bob 胜**。

假设 $A=1$，$B=4$，那么按照 Alice 拿，Bob 拿的顺序（如果过程中有人把一堆全部拿完，那么一定是剩下的那个人胜），最后是，**Alice 胜**。

通过上面的模拟，我们已经找到一些规律了。**当两堆硬币其中一堆只有一枚硬币时，另一堆的硬币数如果是偶数，则 Alice 胜。**

这条规律可以变为：**当两堆硬币其中一堆只有一枚硬币且 Bob 先手时，另一堆的硬币数如果是奇数，则 Alice 胜。**

所以我们只要在实战中满足上面这个条件，那么 Alice 就必胜了。那怎么满足呢？很简单，我们只需看 Alice 第一次能不能取成功就行。

我们先不管两堆分别有多少硬币，直接让 Alice 把其中一堆的硬币数量取成 $1$，由于题目中要求取的硬币数量必须是一堆的数量，所以我们在剩下的一堆中再取 $1$ 枚硬币。此时，我们只需观察剩下的那一堆的硬币数量是否为奇数，若是，则 **Alice 胜**，不是，则 **Bob 胜**。

所以我们得出最终结论：**如果一开始两堆硬币之中有任意一堆为偶数枚，那么 Alice 必胜。**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	if(a%2==0 ||b%2==0) cout<<"Yes"<<endl;
	else cout<<"No"<<endl;
	return 0;
}
```
本蒟蒻的第三篇题解，如有不足之处请各位大佬指出，谢谢。

---


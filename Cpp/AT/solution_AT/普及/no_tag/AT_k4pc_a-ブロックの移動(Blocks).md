# ブロックの移動(Blocks)

## 题目描述

给出长度为 $n$ 的序列 $a$，每次操作可以任选 $i, j$ 让 $a_i = a_i - 1, a_j = a_j + 1$，求使整个序列满足 $a_i = i$ 所需要的最少操作步数。题目满足一定有解。

## 说明/提示

$1 \le n \le 100$。

## 样例 #1

### 输入

```
3
3
2
1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
3
1
5
1```

### 输出

```
4```

## 样例 #3

### 输入

```
5
7
8
0
0
0```

### 输出

```
12```

# 题解

## 作者：lzqy_ (赞：7)

## 简洁代码，$O(n)$算法

#### ****首先先概括一下题意：****

把$n$堆混凝土砖头排列成$1,2,3,4,\cdots n$（即第i堆有i个混凝土砖头）的形式，移动一块混凝土砖头算作一次操作，问至少要用操作才可以达到以上的形式


------------
来看这道题，我们假设开始时石头是排列整齐的，那么我们如何打乱它呢？

大家试一试不难发现，当每改变一块石头的位置时，同时就改变了两堆的石头数量，如下：

```
o(将这一块放到第一堆）             
o   o         ——————————> o   o   o
o   o   o                 o   o   o
```

反之，每两块打乱的石头也只需要一步就可以恢复了。

于是，这道题我们只需要求出一共有多少个错位的石头，再把石头的数量除以二就好了。

（求错位石头数量的方法在代码里有清晰说明）

上代码：

```
#include <bits/stdc++.h>
using namespace std;
int a[10000];
int main()
{
  int sum=0;//用sum来计算错位的石头数量
  int n;
  cin>>n;
  for(int i=1; i<=n; i++)
  {
    cin>>a[i];
    sum+=abs(a[i]-i);
    //关键的公式：i为这一堆应该有的混凝土砖头数，
    a[i]为当前的混凝土砖头数，
    所以它们的差就是第i堆错位的石头数量。
  }
  cout<<sum/2<<endl;//错位石头数量除以二即为答案
  return 0;
}

```
当然了，这道题也可以用模拟做出，但是这种方法省时省事，比起模拟会好很多。

写题解不易，觉得好的，留个赞再走呗~

---

## 作者：Trump__Biden (赞：3)

~~哈哈哈，本蒟蒻又来了。~~

[传送门](https://www.luogu.com.cn/problem/AT1076)

题意：
------------
用最少的操作次数，第 $ i $ 个数的值等于 $ i $。

思路：
------------
将 $ b [ i ] $ 赋值为 $ i $，令 $ ans $ 加上 $ a [ i ] $ 与 $ b [ i ] $ 差的绝对值即用几次操作可以让 $ a [ i ] $ 等于 $ i $，由于每次都会多算，所以 $ ans $ 的一半才是正确答案。

代码如下：
------------
```
#include<bits/stdc++.h>
using namespace std;
int a[105],b[105],n,ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	  scanf("%d",&a[i]),b[i]=i;
	for(int i=1;i<=n;i+=1)
	  ans+=abs(a[i]-b[i]);
	printf("%d\n",ans/2);
	return 0;
}
```
这段代码还可以改进，留给大家自己思考吧。

---

## 作者：CQ_Bab (赞：2)

# 思路
这都题，我们直接去统计 $a_i<i$ 的和 $a_i>i$ 的，再去一个最大值就是答案了。

证明 ：这道题保证了是 $1\sim n$ 的序列打乱后的序列那么，你两个一起变的最大变化次数就一定能得到答案。

# AC代码
~~放心抄~~
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[101010];
int res,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]<i) res+=i-a[i]; // 统计 
		else ans+=a[i]-i; // 统计 
	}
	cout<<max(ans,res)<<endl; // 取最大值 
	return false;
}
```


---

## 作者：幻想繁星 (赞：1)

## 题意：

用最少的操作次数，使第 $i$ 个数的值等于 $i$。
## 思路：
肯定有一些石子堆的石子个数过多、有些石子堆的个数过少。  

所以我们按照贪心的思路，移动的每一颗石子都应该是从过多的石子堆移动到过少的石子堆。  

将 $b_i$ 赋值为 $i$，令 $ans$ 加上 $a_i$ 与 $b_i$ 的差的绝对值，即用几次操作可以让 $a_i$ 等于 $i$，由于每次都会多算一次，所以正确答案是 $ans$ 的一半。  

### 注意事项：  
- 减的时候不要忘了取绝对值。
- 循环最好从 $1$ 开始，因为 $i$ 在循环里需要用到。

#### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],b[105],n,ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	  	scanf("%d",&a[i]);
	  	b[i]=i;//将 b_i 赋值为 i
	}
	for(int i=1;i<=n;i+=1)
	  	ans+=abs(a[i]-b[i]);//令 ans 加上 a_i 与 b_i 的差的绝对值
	printf("%d\n",ans/2);
	return 0;
}
```
##### ps：AT题文末换行不能少（尽人皆知）

---

## 作者：nbtngnllmd (赞：1)

## 前言：

~~话说这道题挺水的，评黄题有点虚高。~~

------------

## 题意：

已知给出一个长度为 $n$ 的序列为 $a$，每次任意选择 $i$ 和 $j$，使得：$a_i$ 的值增加 $1$，$a_j$ 的值减少 $1$。

问如果满足 $a_i = i$，求出最少的操作次数。

------------

## 分析:

刚看到这道题的时候可能会有人先找出每个小于和大于的 $a_i$，然后再把次数 $+1$。
其实大可不必，题意已经明确一定有解，则证明，总共 $a_i$ 加或减的次数相等，我们可以直接判断每个序列 $a_i$ 需要的操作次数，然后得出的答案除以 $2$，最后输出即可。


------------
## 参考代码:

```cpp
#include<bits/stdc++.h>

using namespace std;

int a[100010];
int ans;
int main(){
    int n;cin>>n;
    for(int i = 1 ; i <= n ; i++ ) cin>>a[i];
    for(int i = 1 ; i <= n ; i++ ) {
        if(a[i] == i) continue;
        ans += abs(a[i]-i);//懒得判断大于小于，直接加上绝对值
    }
    printf("%d\n",ans/2);
    return 0;
}
```




---

## 作者：ttq012 (赞：1)

本题建议评黄。

**Solution**

给定一个序列 $a$，每一次可以将 $a_i \to a_i + 1$，$a_j\to a_j - 1$。求几次操作可以有 $\forall i\in [1, n], a_i = i$。

可以构造一个序列 $b$，满足 $b_i = i$。现在希望让 $a$ 序列和 $b$ 序列相等，那么需要分类讨论：

+   如果 $a_i = b_i$，那么不需要移动。
+   如果 $a_i > b_i$，那么将 $a_i\to a_i - 1$。
+   如果 $a_i < b_i$，那么将 $a_i\to a_i + 1$。

其中 $i\in [1, n]$。

但是一次操作是 $a_i\to a_i + 1$，$a_j\to a_j - 1$，所以每一个 $a_i > b_i$ 的情况和 $a_i < b_i$ 的情况需要合起来作为一次操作。所以答案要除以 $2$。

由于答案保证有解，所以不用特判无解的情况。

时间复杂度 $O(n)$。

**Code**

```cpp
// Think twice, code once.

#include <bits/stdc++.h>

using namespace std;

signed main() {
    int n;
    cin >> n;
    vector <int> a(n + 1), b(n + 1);
    for (int i = 1; i <= n; i ++)
        b[i] = i;
    for (int i = 1; i <= n; i ++)
        cin >> a[i];
    long long ans = 0;
    for (int i = 1; i <= n; i ++) {
        if (a[i] == b[i])
            continue;
        else if (a[i] > b[i])
            ans += (a[i] - b[i]);
        else
            ans += (b[i] - a[i]);
    }
    cout << ans / 2 << '\n';
    return 0;
}

```



---

## 作者：user470883 (赞：1)

## 思路：
贪心。

是个好题，好思维题，我想不出来甚至看了题解。

根据观察样例、题目给的图片，我们可以发现：

> 每改变一个石头的位置，就会改变两堆石头的数量

那这能干啥呢？

我们找出来错位的所有石头（也就是每次加上 `a[i]-i`），最后将其 $\div 2$ 即可。（因为两个错位的石头只需要一次操作）。

没看懂的同学在仔细琢磨琢磨，第一遍看的话可能还是比较难理解的。

**注意事项**：
* 减的时候不要忘了取绝对值。
* 循环最好从 $1$ 开始，因为 $i$ 在循环里需要用到。

## AC CODE:
```
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin >> n;
	int ans=0;//记录一共有多少个错位的石头
	for(int i = 1; i <= n ; i++)//注意啦
	{
		int x;
		cin >> x;//输入
		ans+=abs(x-i);
		/*x指现在有x个石头，
		  那么我们和要求所需的i个石头相差多少呢？答：x-i
		  不要忘记绝对值abs
		*/
	}
	cout << ans/2 << endl;//两个错位的石头只需要一次操作，不要忘记/2
	return 0;
}
```
注释放代码里了，没懂再消化消化，有问题的话私聊我。

---

## 作者：lzqy_ (赞：1)

# 贪心做法解决本题。

**先简单概括一下题意**：

把 $n$ 堆混凝土砖头排列成 $1,2,3,4,\cdots n$（即第 $i$ 堆有 $i$ 个混凝土砖头）的形式，移动一块混凝土砖头算作一次操作，问至少要用操作才可以达到以上的形式。

----
**思路**:

那么就说明，肯定有一些石子堆的石子个数过多、有些石子堆的个数过少。

所以我们按照贪心的思路，移动的每一颗石子都应该是从过多的石子堆移动到过少的石子堆。

----

**实现**：

考虑使用用两个变量 $up,down$，多出来的石子放到 $up$ 中，缺少的石子放到 $down$ 中。

每当一个石子堆需要补充石子的时候，就从变量 $up$ 里面扣，每当一个石子堆多出石子的时候，就与 $down$ 中的石子抵消，这样就能保证：

>移动的每一颗石子都应该是从过多的石子堆移动到过少的石子堆。

了。

**代码实现**：

```
#include <bits/stdc++.h>
using namespace std;
int up,down;
int ans;//记录答案
int padding(int x,int i)
{
  if(x>i)//如果石子过多
    ans+=min(x-i,down),x-=min(x-i,down);
    //min(x-i,down)代表与down抵消的石子数量为
    //这个石子堆多出的石子与down的石子数量的最小值；
    //搬运min(x-i,down)的石子，所以ans加上它，x减去它；
  if(x<i)//如果石子过少
    ans+=min(i-x,up),x+=min(i-x,up);//同理
  if(x<i)
    down+=i-x;
  if(x>i)
    up+=x-i;
  //抵消后，若依然没有达到正确的石子数，
  //就改变up与down的值来达到正确的石子数
}
int main()
{
  int n,x;
  cin>>n;
  for(int i=1; i<=n; i++)
  {
    cin>>x;
    padding(x,i);
  }
  cout<<ans<<endl;//输出&换行
  return 0;
}

```

# 祝大家AC愉快！

---


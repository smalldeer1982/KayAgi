# パ研軍旗

## 题目描述

[problemUrl]: https://atcoder.jp/contests/pakencamp-2019-day3/tasks/pakencamp_2019_day3_d

筑駒パ研は，近い将来，パ研戦争に臨むことになりました．そのために，軍旗を作ることになりました．

旗のデザインは縦に $ 5 $ 個，横に $ N $ 個に分かれた $ 5\ \times\ N $ のマス目で表されます．上から $ i $ 行目，左から $ j $ 列目のマスを，$ (i,\ j) $ で表すことにします．

現在，旗のそれぞれのマスは赤・青・白・黒のいずれかで塗られています．より具体的には，マス $ (i,\ j) $ は色 $ S_{i,\ j} $ で塗られています．ただし，$ S_{i,\ j} $ は `R`, `B`, `W`, `#` のいずれかで，それぞれ赤・青・白・黒で塗られていることを表しています．

E869120 君は，パ研軍旗を、次の条件を満たすように青・白・赤で塗り替えたいです．

- $ N $ 個の列すべてにおいて，その列の $ 5 $ マスが「全部青」「全部白」「全部赤」のいずれかである
- どの隣り合った $ 2 $ つの列も，色が異なる

ただし，黒いマスがあったら条件を満たさないことに注意してください．

以下が，条件を満たす旗と条件を満たさない旗の例です．

![ ](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_pakencamp_2019_day3_d/6f1da94e1beb878e9f99f1bce0627c77a75d904e.png)

- 例 $ 1 $ は条件を満たします．
- 例 $ 2 $ は，例えば左から $ 2 $ 番目の列で青と白のマスがあり，$ 5 $ つ全部同じになっている必要があるという条件を満たしません．
- 例 $ 3 $ は，例えば左から $ 3 $ 番目の列と左から $ 4 $ 番目の列の色が同じなので，条件を満たしません．
- 例 $ 4 $ は，例えば左から $ 5 $ 番目の色が黒になっているので，条件を満たしません．

E869120 君は，旗の作成時間を短くするため，できるだけ塗り替えるマスの個数を少なくしたいです．  
 最小でいくつのマスを塗り替える必要があるか求めるプログラムを書いてください．

## 说明/提示

### 制約

すべての入力データは，以下の制約を満たす．

- $ N $ は $ 1\ \leq\ N\ \leq\ 999 $ をみたす整数
- $ S_{i,\ j} $ は `R`, `B`, `W`, `#` のいずれか

### 部分点

この問題はいくつかの小課題に分けられ，その小課題のすべてのテストケースに正解した場合に「この小課題に正解した」とみなされます．  
 提出したソースコードの得点は，正解した小課題の点数の合計となります．

1. (11 点) $ N\ =\ 1 $ である．
2. (13 点) $ N\ =\ 3 $ である．
3. (29 点) $ N\ \leq\ 10 $ である．
4. (22 点) $ 5 $ つの行すべてにおいて，その行の $ N $ 個のマスがすべて同じ色である．
5. (25 点) 追加の制約はない．

**ただし，小課題 $ 4 $ について，「$ N $ 個の列すべてにおいて，その列の $ 5 $ 個のマスがすべて同じ色である」のような読み間違えをしないように注意してください．**

### Sample Explanation 1

以下の $ 3 $ 通りのパ研軍旗を作ることができます． - すべてのマスを赤にする．そのとき，マス $ (1,\ 1),\ (3,\ 1),\ (4,\ 1),\ (5,\ 1) $ の $ 4 $ マスを塗り替える必要がある． - すべてのマスを青にする．そのとき，マス $ (2,\ 1),\ (3,\ 1),\ (4,\ 1) $ の $ 3 $ マスを塗り替える必要がある． - すべてのマスを白にする．そのとき，マス $ (1,\ 1),\ (2,\ 1),\ (3,\ 1),\ (5,\ 1) $ の $ 4 $ マスを塗り替える必要がある． その中では，「すべてのマスを青」にするのが最適です．そのとき，塗り替えるマスの個数は $ 3 $ 個になります． ちなみに，これは $ N\ =\ 1 $ なので，小課題 $ 1 $ の制約をみたします．

### Sample Explanation 2

$ 1 $ 列目を青、$ 2 $ 列目を白、$ 3 $ 列目を赤にすると，塗り替えるマスの個数を $ 10 $ 個にできて，これが最適です． !\[ \](https://img.atcoder.jp/pakencamp-2019-day3/7607c1554c09d7d875918ccf09d65f78.png) (ここでは，「★」は塗り替えられたマスを表します) ちなみに，これは $ N\ =\ 3 $ なので，小課題 $ 2 $ の制約をみたします．

### Sample Explanation 3

次の図のように塗り替えるのが最適です．塗り替えるマスの数は $ 28 $ 個となります．(ここでは，「★」は塗り替えられたマスを表します) !\[ \](https://img.atcoder.jp/pakencamp-2019-day3/a660d84b5614953bf2b4e7ee8342fabd.png)

### Sample Explanation 4

次の図のように塗り替えるのが最適です．塗り替えるマスの数は $ 21 $ 個となります．(ここでは，「★」は塗り替えられたマスを表します) !\[ \](https://img.atcoder.jp/pakencamp-2019-day3/cb86f987229c1ab46e30411860964c19.png)

## 样例 #1

### 输入

```
1
B
R
#
W
B```

### 输出

```
3```

## 样例 #2

### 输入

```
3
WWR
#RW
BW#
##B
RBR```

### 输出

```
10```

## 样例 #3

### 输入

```
8
RRRRRRRR
########
BBBBBBBB
RRRRRRRR
WWWWWWWW```

### 输出

```
28```

## 样例 #4

### 输入

```
7
BR#WB#R
RWW#WRB
##WBR#W
WB#B#RW
BRW##BB```

### 输出

```
21```

# 题解

## 作者：Circle_Table (赞：1)

题意过于简洁不必复述了。

显而易见，为了使原矩阵成为一个军旗，每一列到最后的时候都应当处于全红，全蓝或全白这三种状态之一，其中全黑是不可以的。那就直接分类讨论每一列的三种情况。

例如：我们存储每一列改为全红，全蓝或全白三种状态的最小代价分别为 $a_{1,1},a_{2,1},a_{3,1}$，那么下一列改为这三种状态之一的代价就是前一列与它颜色不同的两种中的最小代价与自己这一列全部改为该颜色的最小代价之和。

再通俗些：$a_{2,1}$ 就应该是第二列改为全红的代价加上 $a_{2,1},a_{3,1}$ 的较小值。

由此思路就已经出来了。上代码：
```cpp
#include <bits/stdc++.h>
#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
int n,a[1145][4],dp[1145][4],ans=1000000005;
char c;
int main(){
	ios;cin>>n;
	for(int j=1;j<=5;j++){
		for(int i=1;i<=n;i++){
			cin>>c;
			if(c=='R'){
				a[i][1]++,a[i][2]++;
			}
			if(c=='B'){
				a[i][1]++,a[i][3]++;
			}
			if(c=='W'){
				a[i][2]++,a[i][3]++;
			}
			if(c=='#'){
				a[i][1]++,a[i][2]++,a[i][3]++;
			}
//			存储这一列换几次可以成为清一色的某种颜色
//			黑色的不能存在所以每种都要加
		}
	}
//	输入完毕后a[i][]对应的就是该颜色的数量
	for(int i=1;i<=n;i++){
		for(int j=1;j<=3;j++){
			dp[i][j]=1000000005;
			for(int c=1;c<=3;c++){
				if(j!=c){
					if(dp[i][j]>dp[i-1][c]+a[i][j])
						dp[i][j]=dp[i-1][c]+a[i][j];
				}
			}
		}
	}
//	最后一次循环出结果
	for(int j=1;j<=3;j++){
		if(ans>dp[n][j])ans=dp[n][j];
	}
	cout<<ans<<'\n';
	return 0;
}
```
感谢阅读！

---

## 作者：e_zhe (赞：0)

### 题意简述

给定 $5$ 行 $N$ 列的网格，每个格子有四种可能的颜色。

要使网格中每一列的颜色都一样但**不能是黑色**，并且相邻两列的颜色不相同。问最少改变多少个格子的颜色能满足要求。

### 思路分析

为方便处理，把给定的红色、蓝色、白色、黑色分别转成数字 $1,2,3,4$。

考虑 dp。

不妨设 $c_{i,j}$ 为将第 $i$ 列全部变成第 $j$ 种颜色的代价，$f_{i,j}$ 表示第 $i$ 列变成第 $j$ 种颜色时前 $i$ 列的总代价。

那么思路就很简单了。对于当前列的当前颜色，其总代价应为*前一列不同颜色的总代价的最小值*与*将当前列转变为当前颜色的代价*的和，即状态转移方程为 $f_{i,j}=\min(f_{i-1,k})+c_{i,j}(j \ne k)$，最后在最后一列的几种颜色中取最小值即可。

细节内容见代码注释。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1005;
int n,ans=0x3f3f3f3f,mp[10][N],c[N][5],f[N][5];//mp表示原矩阵，c和f如上文 
//将字符转为数字 
int change(char ch){
	switch(ch){
		case 'R':return 1;break;
		case 'B':return 2;break;
		case 'W':return 3;break;
		case '#':return 4;break;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=5;++i)
		for(int j=1;j<=n;++j){
			char ch;cin>>ch;
			mp[i][j]=change(ch);
		}
	//预处理代价 
	for(int i=1;i<=n;++i)//枚举列 
		for(int j=1;j<=3;++j)//枚举颜色，因为不能是黑色，所以只枚举三种 
			for(int k=1;k<=5;++k){
				if(mp[k][i]==j)continue;
				++c[i][j];
			}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=3;++j){
			f[i][j]=0x3f3f3f3f;
			for(int k=1;k<=3;++k){
				if(j==k)continue;//相邻两列颜色不能一样 
				f[i][j]=min(f[i][j],f[i-1][k]+c[i][j]);//状态转移 
			}
		}
	}
	//在最后一列的几种颜色中取最小值 
	for(int i=1;i<=3;++i)ans=min(ans,f[n][i]);
	cout<<ans;
	return 0;
}
```

### 时间复杂度分析

用 $N$ 表示网格列数，$M$ 表示网格行数，$K$ 表示颜色数量，则预处理的时间复杂度为 $O(NMK)$，dp 时间复杂度为 $O(NK^{2})$。本题中 $M$ 和 $K$ 都为常数，故时间复杂度较低，通过此题没有任何问题。

---


# 回転と反転

## 题目描述

有一个 $n$ 行 $n$ 列的网格图，开始时全部被涂为白色。

给出 $q$ 次操作，每次操作的格式及内容如下：

- `1 x y`：若上起第 $x$ 行左起第 $y$ 列的网格为白色，将其涂黑；若为黑色，将其涂白。
- `2 c`：若 $c$ 为`Ａ`，将整张图顺时针旋转 $90°$；否则，将整张图逆时针旋转 $90°$。
- `3 c`：若 $c$ 为`Ａ`，垂直翻转整张图；否则，水平翻转整张图。

请在全部操作完成后输出每一个格子的颜色。

## 说明/提示

#### 样例 #1 说明

将 $(1,1)$ 涂黑，然后顺时针旋转 $90°$。

#### 数据规模与约定

$100\%$ 的数据保证：

- $1 \le n\le 300$；
- $1 \le q\le 2 \times 10^5$；
- $1 \le x,y \le n$；
- $c$ 为 `A` 或 `B`。

## 样例 #1

### 输入

```
3 2
1 1 1
2 A```

### 输出

```
001
000
000```

## 样例 #2

### 输入

```
3 3
1 1 1
3 A
3 B```

### 输出

```
000
000
001```

## 样例 #3

### 输入

```
4 8
2 A
1 4 2
2 A
1 2 2
3 B
3 B
3 A
1 3 1```

### 输出

```
0000
0000
0100
0000```

# 题解

## 作者：朱梓煊ZZX (赞：4)

## 思路

考虑暴力，模拟每次修改，时间复杂度为 $O(q\cdot n^2)$，会超时。

在模拟时可以发现，每次修改都能被简化成为一个**对于所有点都通用的**，代数形式的式子。

- 顺时针旋转 $90^\circ$：$a(x,y)\to a(y,n-x+1)$

- 逆时针旋转 $90^\circ$：$a(x,y)\to a(n-y+1,x)$

- 上下翻转：$a(x,y)\to a(n-x+1,y)$

- 左右翻转：$a(x,y)\to a(x,n-y+1)$

于是可以先求出**初始坐标在不同操作次数时**的式子，最后将要修改的点带入当时的式子算出它的初始位置，然后用最终坐标算出最后的位置。

时间复杂度为 $O(q)$。

### 实现细节

由于式子一定为形如 $kx+b$，且 $k=\pm1$ 的一次函数，所以程序中用 `f1[],f2[]` 表示符号；用 `b1[],b2[]` 表示常数项 $b$；`n1[]` 表示对于输入的 $x,y$ 是否要交换位置。

## code

```
#include<bits/stdc++.h>
using namespace std;
int n,q;
int f1[200010];
int f2[200010];
bool n1[200010];//true:x,y false:y,x
int b1[200010];
int b2[200010];
int x[200010],y[200010];//记录待更新的坐标
bool a[310][310];//true:白色
int main() {
	memset(n1,true,sizeof(n1));
	for(int i=0;i<=200000;i++) f1[i]=f2[i]=1;
	for(int i=0;i<=200000;i++) f1[i]=1;
	memset(a,false,sizeof(a));
    //以上为初始化
	cin>>n>>q;
	for(int i=1;i<=q;i++){
		int f;char ch;
		cin>>f;
		if(f==1){//无操作，继承前面的式子
			f1[i]=f1[i-1];f2[i]=f2[i-1];
			n1[i]=n1[i-1];
			b1[i]=b1[i-1];b2[i]=b2[i-1];
			cin>>x[i]>>y[i];
		}
		else if(f==2){
			cin>>ch;
			if(ch=='A'){//顺时针转90度
				f1[i]=f2[i-1];
				f2[i]=(f1[i-1]==1)?-1:1;
				n1[i]=n1[i-1]^1;
				b1[i]=b2[i-1];
				b2[i]=-b1[i-1]+n+1;
			}
			else{//逆时针转90度
				f1[i]=(f2[i-1]==1)?-1:1;
				f2[i]=f1[i-1];
				n1[i]=n1[i-1]^1;
				b1[i]=-b2[i-1]+n+1;
				b2[i]=b1[i-1];
			}
		}
		else{
			cin>>ch;
			if(ch=='A'){//上下翻转
				f1[i]=(f1[i-1]==1)?-1:1;
				f2[i]=f2[i-1];
				n1[i]=n1[i-1];
				b1[i]=-b1[i-1]+n+1;
				b2[i]=b2[i-1];
			}
			else{//左右翻转
				f1[i]=f1[i-1];
				f2[i]=(f2[i-1]==1)?-1:1;
				n1[i]=n1[i-1];
				b1[i]=b1[i-1];
				b2[i]=-b2[i-1]+n+1;
			}
		}
	}
	for(int i=1;i<=q;i++){
		if(x[i]==0) continue;
		if(n1[i]!=n1[q]){//x,y需调换位置
			swap(x[i],y[i]);
			swap(f1[i],f2[i]);
			swap(b1[i],b2[i]);
		}
		int fx=(x[i]-b1[i])/f1[i]*f1[q]+b1[q];//计算最终坐标
		int fy=(y[i]-b2[i])/f2[i]*f2[q]+b2[q];//计算最终坐标
		a[fx][fy]^=1; 
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]) cout<<1;
			else cout<<0;
		}cout<<"\n";
	}
	return 0;
}
```

---


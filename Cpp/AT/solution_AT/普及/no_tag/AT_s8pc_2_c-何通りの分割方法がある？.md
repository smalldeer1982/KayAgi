# 何通りの分割方法がある？

## 题目描述

[problemUrl]: https://atcoder.jp/contests/s8pc-2/tasks/s8pc_2_c

$ square1001 $の部分文字列である「$ 1001 $」は、各位の数字の和が$ 1+0+0+1=2 $と非常に少なく、

しかも「1001」を分割しても{$ 1,0,01 $}や{$ 1,001 $}のようにすると和がそれぞれ$ 1+0+1=2,1+1=2 $と非常に少なくなります。

$ 1001 $はとても不思議な数です。それについて、彼は考えてみることにしました。

整数$ n $を分割するとき、その和が$ D $以下にならなければなりません。

ここでいう「分割」の定義は以下のようになります。

- 整数$ N $を文字列と考えられる。これを$ S $と置く。
- $ S $をいくつかのパーツに分ける。
- 例えば「$ "1234567" $」だと{$ "1","234567" $}や{$ "12","34","56","7" $}や{$ "1234567" $}など、というように分けることができる。
- 分けたパーツをそれぞれ数字としてとらえるようにする。
- 例えば、"1234"は$ 1234 $という数字ととらえることができる。
- ただし、各パーツは$ 0 $から始まってもよい。

例えば、「1355」を和が50以下になるように分割する方法は、以下の$ 3 $通りがあります。

 分割方法合計1+3+5+51413+5+5231+35+541何通りの分け方があるか数え上げましょう。$ 1,000,000,007 $で割った余りを求めなさい。

- 問題文中の例と同じである。

- 以下の5通りの条件を満たす分け方がある。

分割方法合計2+4+3+91824+3+9362+4+39452+43+95424+3963

## 说明/提示

### 制約

- $ 1≦N≦{10}^{100} $
- $ 1≦D≦100,000 $

### 小課題

小課題 $ 1 $ \[ $ 10 $ 点 \]

- 解は全て$ 1 $通り以下である。

小課題 $ 2 $ \[ $ 30 $ 点 \]

- $ 1≦N≦10,000,000,000 $を満たす。

小課題 $ 3 $ \[ $ 60 $ 点 \]

- 追加の制約はない。

## 样例 #1

### 输入

```
1355
50```

### 输出

```
3```

## 样例 #2

### 输入

```
2439
100```

### 输出

```
5```

## 样例 #3

### 输入

```
1225
20```

### 输出

```
2```

## 样例 #4

### 输入

```
123456
10000```

### 输出

```
29```

# 题解

## 作者：zrx0204 (赞：1)

### 思路

考虑 dp。

定义二维数组 $dp_{i,j}$ 来表示状态，其中：

- $i$ 表示处理到字符串的第 $i$ 个字符（字符下标从 $1$ 开始）。
- $j$ 表示当前分割方案下已经得到的数字之和为
$j$。
- $dp_{i,j}$ 表示处理到字符串的前 $i$ 个字符，且分割后数字之和为 $j$ 的分割方案数。

$dp_{i,j} = 1$，处理 $0$ 个字符，分割后数字之和为 $0$ 的分割方案数为 $1$，即不进行分割这一种方案。

对于每一个位置 $i$，我们需要考虑所有可能的分割点 $k$，将从第 $k$ 个字符到第 $i$ 个字符组成的数字作为一个新的分割部分。步骤如下：

1. 计算从第 $k$ 个字符到第 $i$ 个字符组成的数字 $num$。
2. 检查 $num + j$ 是否小于等于 $d$：
    - 如果 $num + j > d$，说明这种分割方式下数字之和超过了上限 ，不符合要求，停止继续分割。
    - 如果 $num + j \le d$，则更新 $dp_{i,j + num}$，将 $dp_{k - 1,j}$ 的方案数累加到 $dp_{i,j + num}$ 中，表示从第 $k-1$ 个字符之前分割方案和为 $j$ 的情况，加上当前分割出的数字 $num$ 后，得到前 $i$ 个字符分割方案和为 $j+num$ 的新方案。同时，对 $10^9+7$ 取模。

最终答案是处理完整个字符串（即 $i$ 为字符串长度）后，所有分割数字之和小于等于 $d$ 的方案数总和，即 $\sum^d_{j=0}dp_{len,j}$（$len$ 为字符串长度）。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;
string n;
int d, dp[105][100005];
int main(){
    cin >> n >> d;
	int len = n.size();
    // dp[i][j] 表示处理到第 i 个字符，当前分割数字的和为 j 的方案数
    dp[0][0] = 1; // 初始状态，处理 0 个字符，和为 0 的方案数为 1
	for(int i = 1; i <= len; i++){
        for(int j = 0; j <= d; j++){
            for(int k = i; k >= 1; k--){
                long long num = 0, base = 1;
                // 计算从第 k 个字符到第 i 个字符组成的数字
                for(int l = i - 1; l >= k - 1; l--){
                    num += (n[l] - '0') * base;
                    base *= 10;
                }
                if(num + j > d){
                    break; // 如果当前分割的数字加上之前的和超过 d，停止继续分割
                }
                // 更新 dp 数组
                dp[i][j + num] = (dp[i][j + num] + dp[k - 1][j]) % MOD;
            }
        }
    }
	int ans = 0;
    // 统计所有和小于等于 d 的方案数
    for(int j = 0; j <= d; j++) ans = (ans + dp[len][j]) % MOD;
    cout << ans << endl;
    return 0;
}
```

---

## 作者：lyh0217 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT_s8pc_2_c)

### 题意

给定一个数 $n$，求把这个数分割成若干个数字使得这些数之和小于等于 $d$。

**答案对 $10^9+7$ 取模！**

### 思路

发现 $n$ 的长度最长只有 $100$，同时 $d \leq 10^5$，考虑 dp，设 $dp_{i,j}$ 表示划分到了 $n$ 的第 $i$ 位，前面划分出来的数字的总和为 $j$ 的方案数。

转移就很简单了：

$$dp_{i,j}=\sum\limits_{k=1}^{i-1}dp_{k-1,j-sum(k,i)}\left[sum(k,i)\leq j\right]$$

其中 $sum(i,j)$ 表示在 $n$ 中从第 $i$ 位到第 $j$ 位组成的十进制数。

小坑点：

- **答案对 $10^9+7$ 取模！**

- 行末要多输出一个换行。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[105][100005];
int main()
{
	string n;
	int d;
	cin>>n>>d;
	dp[0][0]=1;
	for(int i=1;i<=n.size();i++)
	{
		for(int j=0;j<=d;j++)
		{
			int p=0,w=0;
			for(int k=i;k>=1;k--)
			{
				p+=pow(10,w)*(n[k-1]-'0');
				if(p+j>d) break;//如果现在分割出的数已经大于d了，则肯定不满足要求
				w++;
				dp[i][j+p]+=dp[k-1][j];
				dp[i][j+p]%=1000000007;//答案对 1e9+7 取模！
			}
		}
	}
	long long ans=0;//注意是小于等于d的所有答案，不是等于d的所有答案
	for(int i=0;i<=d;i++)
	{
		ans+=dp[n.size()][i]; 
		ans%=1000000007;//答案对 1e9+7 取模！
	}
	cout<<ans;
	return 0;
}
```

[评测记录](https://atcoder.jp/contests/s8pc-2/submissions/61962923)

---

## 作者：Elairin176 (赞：0)

[传送门](https://www.luogu.com.cn/problem/AT_s8pc_2_c)  
好耶是这题首 A。
## 题意
[link，本人自制的新翻译](https://www.luogu.com.cn/discuss/781693)    
## 解法
直接 dp。   
设 $f_{i,j}$ 为数字前 $i$ 位分割后各个数字之和为 $j$ 的方案数。    
为了便于处理，我们再设 $a_{l,r}$ 为数字 $l$ 到 $r$ 这一部分的子串所表示的数字。   
这里我们可以用一个优化：如果这个数字已经大于 $d$，则我们可以直接跳过这次的处理。  
那么我们很容易得到 dp 式子。即每个 $f_{i,j}$ 向所有可以向其转移的状态进行一轮求和。特别地 $f_{0,0}=1$。     
其中还可以进行很多效率优化：    
- 计算 $f_{i,j}$ 时，我们枚举最后分割数的左端点时，可以倒序枚举，再根据 $a$ 数组进行判断。   
- 还是计算 $f_{i,j}$ 时，我们直接从最大的可贡献数字枚举即可。    
- 发现可以滚动数组，但我没写。    

时间复杂度 $O(nmd)$，其中 $m$ 为 $d$ 的长度。    
但是如果写了以上优化，这个复杂度其实也跑不满。   
总之能过。   
CODE：   
```cpp
//完整缺省源请见洛谷云剪贴板 jo5j6ogx
cst int N=1e2,M=1e5;
cst ll p=1e9+7;
string s;
int d,n,a[N+2][N+2];
ll f[N+2][M+2],ans;
int main(void){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>s>>d;
	n=s.length();
	s="="+s;
	memset(a,-1,sizeof(a));
	for(int l=1;l<=n;l++){
		a[l][l-1]=0;
		for(int r=l;r<=n;r++){
			a[l][r]=a[l][r-1]*10+s[r]-'0';
			if(a[l][r]>d){
				a[l][r]=-1;
				break;
			}
		}
	}
	f[0][0]=1;
	for(int r=1;r<=n;r++){
		for(int l=r;l>=1;l--){
			if(a[l][r]==-1){
				break;
			}
			for(int i=a[l][r];i<=d;i++){
				f[r][i]=madd(f[r][i],f[l-1][i-a[l][r]],p);
			}
		}
	}
	for(int i=1;i<=d;i++){
		ans=madd(ans,f[n][i],p);
	}
	cout<<ans<<endl;
	ret 0;
}
```


---


# 超大型連休

## 题目描述

[problemUrl]: https://atcoder.jp/contests/language-test-ver1/tasks/test001_d

$ 2011 $ 年、$ AtCoder $ 国の高橋首相はある重大な決定を行った。  
 その決定とは...法改正である。国民の祝日に関する法律を変更し、休日を増やすことにした!!  
 国民の創造性を尊重するその決定が、霞が関を魔境へと変えたッ！  
  
 あなたは霞が関の国土交通省に勤務する職員であり、この法改正により上司から新たな任務を与えられた。  
 その任務とは、$ 2012 $ 年の「連休の最大日数」を計算することである。  
 連休の大きさを事前に計算することで国民の行動を予想し、高速道路の部分的な値下げを行い、経済を活性させるためだ。  
 したがって、あなたに失敗することは許されない。国民の行動を正確に予想できなくなるからだ。  
  
 以下に、「連休」の定義と諸注意を記す。

1. $ AtCoder $ 国が使用する暦は[グレゴリオ暦](http://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AC%E3%82%B4%E3%83%AA%E3%82%AA%E6%9A%A6)に従う。
2. 「連休」とは、「休日」が連続して続くことである。
3. 「土曜日」「日曜日」「祝日」「振替休日」が「休日」に相当する。
4. 「祝日」が他の休日と同じ日に指定されていた場合、「振替休日」を必ず設置する。
5. 「振替休日」は祝日の時系列順に決定していき、その祝日以降最も近い平日（休日を除いた日）となる。
6. $ 2012 $ 年 $ 1 $ 月 $ 1 $ 日は日曜日である。
 
 入力は以下の形式で標準入力から与えられる。 > $ N $ $ m_{1} $/$ d_{1} $ $ m_{2} $/$ d_{2} $ $ : $ $ : $ $ m_{n} $/$ d_{n} $

- $ 1 $ 行目には祝日の日数を表す整数 $ N $ が与えられ、 $ 0≦N≦366 $ を満たす。
- $ 2 $ 行目から $ N+1 $ 行目までの $ N $ 行で祝日の日付が与えられる。

1. $ m_{i} $ は $ i(1≦i≦366) $ 番目に与えられる祝日の月で、 $ 1≦m_{i}≦12 $ を満たす。
2. $ d_{i} $ は $ i(1≦i≦366) $ 番目に与えられる祝日の日で、
1. $ m_{i}\ =\ 2 $ のとき、 $ 1≦d_{i}≦29 $ を満たす。
2. $ m_{i}\ =\ (4,\ 6,\ 9,\ 11) $ のとき、 $ 1≦d_{i}≦30 $ を満たす。
3. $ m_{i}\ =\ (1,\ 3,\ 5,\ 7,\ 8,\ 10,\ 12) $ のとき、 $ 1≦d_{i}≦31 $ を満たす。

4. $ m_{i} $ と $ d_{i} $ はともに整数である。
5. $ m_{i} $ と $ d_{i} $ は必ず`/`で区切られて与えられる。
6. 祝日は時系列順に与えられるとは限らないことに注意せよ。ただし、同じ日付が複数与えられないことは保証されている。
 
 法改正後における $ 2012 $ 年の連休の最大日数を出力せよ。  
 出力は標準出力におこない、末尾には改行をいれること。  
```

1
1/9
```

 ```

3
```

- 1/7(土),1/8(日),1/9(月)の $ 3 $ 連休が最長です。
 
```

1
1/10
```

 ```

2
```

- 1/10(火)が祝日となり、1/7(土),1/8(日)などの $ 2 $ 連休が最長です。
 
```

1
1/7
```

 ```

3
```

- 1/7は土曜日なので、以降で最も近い平日である1/9が振替休日になります。
- よって、1/7(土)、1/8(日)、1/9(月)の3連休が最長です。
 
```

2
1/7
1/9
```

 ```

4
```

- 1/7は土曜日なので振替休日を以降に設定したく、1/9が祝日なので1/10が振替休日になります。
- よって、1/7(土)、1/8(日)、1/9(月)、1/10(火)の4連休が最長です。

# 题解

## 作者：Strelitzia_ (赞：3)

## 题目大意
------------

模拟题。

给出一个 $n$ , 然后有 $n$ 个日期，每个日期对应新添加的节假日。包括周六周日在内，让求出 $2012$ 年中最长的连续假期。

## 思路

------------
按题意模拟即可。

首先，$2012$ 年是闰年，$2$ 月有 $29$ 天。

其次，对于给出的日期，若这个日期已经是周末，还要往后推。

我们先考虑用二维数组，前一个变量存月份，后一个存日期。

但是，我们需要考虑一对周六周日不在同一个月内或一个假期还要推到下一个月的情况，那么用二维数组要考虑月份之间的转换，整体码量很大。那么我们直接合并成一个一维数组存日期，再开一个数组存每月之前的累计日期。

如下：

```cpp
int dat[366];
int mon[15]={0,31,60,91,121,152,182,213,244,274,305,335};
```
当查询日期时就可以表示为 ```dat[mon[m-1]+d-1]``` 。

我们先来考虑周末的标记方式。$2012$ 年 $1$ 日正好是周日，那么在这一年当中天数的处理就很方便。我们将第一天的数组下标设为 $0$，就有如下：

```cpp
for(int i=0;i<366;i++)
	 if(i%7==0||i%7==6) dat[i]=1;
```
对于输入的每个日期，如果这个日期不是周末就标记，如果是就跑一个 $while$ 循环，找到离他最近的平日再标记。

最后，全年循环一遍，找到假期当前天数增加，找到平日就先更新答案，然后赋零。

最最后再更新一遍！因为最长的连续假期有可能持续到最后一天，但在循环中不会被更新。

下面附上代码：

```cpp
#include<bits/stdc++.h>
#define lxl long long
#define N 114514
using namespace std;

int dat[366];
int mon[15]={0,31,60,91,121,152,182,213,244,274,305,335};
int n,m,d;
int cnt=-1;
int ans=0,hop=0;

bool cmp(int x,int y){
	return x>y;
}

int main(){
	for(int i=0;i<366;i++)
	 if(i%7==0||i%7==6) dat[i]=1;
	cin>>n;
	while(n--){
		scanf("%d/%d",&m,&d);
		if(dat[mon[m-1]+d-1]==0) dat[mon[m-1]+d-1]=1;
		else{
			cnt=mon[m-1]+d-1;
			while(cnt<366){
				if(dat[cnt]==0){
					dat[cnt]=1;
					break;
				}
				cnt++;
			}
		}
	}
	for(int i=0;i<366;i++){
		if(dat[i]==1) hop++;
		else{
			ans=max(ans,hop);
			hop=0;
		}
	}
	ans=max(ans,hop);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：SuperCowHorse (赞：1)

一道~~简单~~的模拟题。
### 题目大意
给定 ${n}$ 个节假日，周六周日也算节假日，求最长的连休日。
### 思路分析
首先，我们需要做一些预处理，把所有月份用前缀和计算一遍，方便用一维数组，并将周六日给记录下来，将他们归为节假日。注意：这里有两个坑。

坑一：${2012}$ 年是闰年，循环从 ${1}$ ${∼}$ ${366}$。

坑二：${2012}$ 年 ${1}$ 月 ${1}$ 日是周日，而非 ${2012}$ 年 ${1}$ 月 ${11}$ 日。（翻译有误）

所以，我们就有以下代码：
``` cpp
int MonthDay[]={0,31,29,31,30,31,30,31,31,30,31,30,31};
for(int i=1;i<=12;++i)
		sum[i]=sum[i-1]+MonthDay[i];//前缀和 
	for(int i=1;i<=366;++i)//把周六日用u数组记录下来 
		if(i%7==0||i%7==1)
			u[i]=1;
```
其次，就是输入。可以边输入，边统计。如果节假日本来就是周六日，就找到其后第一个非节假日，将它改为节假日。代码如下：
``` cpp
for(int i=1;i<=n;++i)
	{
		scanf("%d/%d",&m,&d);//scanf输入方便一些 
		if(u[sum[m-1]+d]==1)//如果本来就是周六日 
		{
			for(int j=sum[m-1]+d+1;j<=366;++j)//找第一个不是节假日的 
				if(!u[j])
				{
					u[j]=1;
					break;
				}
		}
		else
			u[sum[m-1]+d]=1;//标记成为节假日 
	}
```
最后，就是统计。具体就看注释吧。
``` cpp
for(int i=1;i<=366;++i)//统计最长连休 
	{
		if(u[i])//是节假日++now 
			++now;
		else//不是统计最大值 
		{
			ans=max(ans,now);
			now=0;
		}
	}
    ans=max(ans,now);//可能在最后有连休 
```
全部代码如下：（无注释）
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,d,ans,now;
int MonthDay[]={0,31,29,31,30,31,30,31,31,30,31,30,31},sum[15];
char ch;
bool u[370];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=12;++i)
		sum[i]=sum[i-1]+MonthDay[i];
	for(int i=1;i<=366;++i)
		if(i%7==0||i%7==1)
			u[i]=1;
	for(int i=1;i<=n;++i)
	{
		scanf("%d/%d",&m,&d);
		if(u[sum[m-1]+d]==1)
		{
			for(int j=sum[m-1]+d+1;j<=366;++j)
				if(!u[j])
				{
					u[j]=1;
					break;
				}
		}
		else
			u[sum[m-1]+d]=1;
	}
	for(int i=1;i<=366;++i)
	{
		if(u[i])
			++now;
		else
		{
			ans=max(ans,now);
			now=0;
		}
	}
	ans=max(ans,now);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Trump__Biden (赞：0)

# 题目大意：
给定 $ n $ 个日期，它是节假日，除了它之外，每周六和周日也是节假日，问这一年最长休假多少天。

# 思路：
直接模拟。用一个数组标记这一天是不是节假日，先从第一天起跑一遍，用一个数组将周六日的编号记录下来。另外一个数组 $ sum[i] $ 表示前 $ i - 1 $ 个月的天数总和，再加上输入的 $ d $ 可以表示这一天的编号。

对于输进来的每一个日期，如果它原本不是节假日，就将它改为节假日，否则，就将它之后离它最近的平日改为假期。

全部完成之后，从第 $ 1 $ 天到第 $ 367 $ 天跑一遍，如果节假日是连续的，就记录下来，如果它不再连续，就将它和 $ ans $ 进行比较，取较大值。

# 注意：
1.$ 2012 $ 年 $ 1 $ 月 $ 1 $ 日是周日，翻译有误，务必注意。

2.$ 2012 $ 年是一个闰年，所以二月有 $ 29 $ 天，全年共 $ 366 $ 天。

3.最后一次循环需要跑到 $ 367 $，因为可能会有一个假期持续到第 $ 366 $ 天，而到 $ 367 $ 就可以将本次终结，从而防止答案更新出现错误。

4.岛国的题一定要换行！！！

# 代码奉上：
```
#include<bits/stdc++.h>
using namespace std;
int sum[20],mon[20]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int n,m,d,l,ans;
bool day[370];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=12;++i)
	  sum[i]=sum[i-1]+mon[i];
	for(int i=1;i<=366;++i)
	  if(i%7==0||i%7==1)
		day[i]=true;
	for(int i=1;i<=n;++i){
		scanf("%d/%d",&m,&d);
		if(day[sum[m-1]+d]==true){
			for(int j=day[sum[m-1]]+d+1;j<=366;++j){
				if(!day[j]){
					day[j]=true;
					break;
				}
			}
		}
		else{
			day[sum[m-1]+d]=true;
		}
	}
	for(int i=1;i<=367;++i){
		if(day[i]==true){
			l++;
		}
		else{
			ans=max(l,ans),l=0;
		}	
	}
	ans=max(ans,l);
	printf("%d\n",ans);
	return 0;
}
```
希望可以帮大家理解。

---


# 最後の問題

## 题目描述

[problemUrl]: https://atcoder.jp/contests/wupc2012/tasks/wupc2012_6

 いよいよコンテスト当日，僕は早稲田大学・西早稲田キャンパスに到着した．しかも，到達時間は4でも7でも割り切れる数字であった．とても縁起がいい．今ならどんな問題だって解ける気がする．  
 会場の教室には既に数十名の学生が集まっていた．運営チームがジャッジシステム，AtCoderの説明を終え，もうあと数分でコンテストが始まろうとしているところだった．僕は持ってきたノートブック型計算機を広げ，高鳴る心臓を抑えつつコンテストに備える．  
  
 *(それでは，始めてください！)*  
  
 そして，コンテストが始まった．  
  
 挑戦はどんな結果だったのか，そして，コンテストを通じて僕は何を得たのだろうか… しかし，これはまた別の話．機会があれば語ることにしよう．ところで，このコンテストに出題された最後の問題は，次のようなものであった．  
 二次元の座標平面上に格子点が $ N $ 個与えられる．それらの点の中から $ 4 $ 点を選んで長方形を作る時，その最大面積を求めるプログラムを作成せよ．ただし，長方形は以下の条件を満たす必要がある．

- 長方形の各辺は $ x $ 軸または $ y $ 軸と並行になっていなければならない．
- 長方形の内部(辺は含まない)に他の点を含んではならない．
 
 長方形を構成する4点以外の点が辺の上にある時は，内部にはないと考えるものとする．また，条件を満たす長方形が一つも作れない時は，$ 0 $ を出力してほしい．  
 入力は以下の形式で標準入力から与えられる． > $ N $ $ x_{1}　y_{1} $ $ x_{2}　y_{2} $ $ ... $ $ x_{i}　y_{i} $ $ ... $ $ x_{N}　y_{N} $

- $ 1 $ 行目に点の数を表す $ N $($ 4\ ≦\ N\ ≦\ 10000 $)が与えられる．
- $ 2 $ 行目〜$ N+1 $行目にはそれぞれの点の $ x $ 座標と $ y $ 座標が半角スペース区切りで与えられる．
- 各 $ i $ について $ 0\ ≦\ x_{i}\ ≦\ 999 $ かつ $ 0\ ≦\ y_{i}\ ≦\ 999 $ を満たす．
- $ N $ 点の座標はすべて異なる．
 
 与えられた点を使って条件を満たすような長方形を作る時，その最大面積を一行に出力せよ．もし，条件を満たす長方形が一つも作れない場合は，$ 0 $ を出力せよ．  
 なお，最後には改行を出力せよ． 100点満点中，10点分については，$ N\ ≦\ 100 $ を満たす．  
 また，別の20点分については，$ N\ ≦\ 1000 $ を満たす．

# 题解

## 作者：BotDand (赞：2)

# $\text{Problems}$

给出 $n$ 个点的坐标，第 $i$ 个点的坐标为 $(x_{i},y_{i})$。

求一个矩阵满足如下条件的最大面积：

* 矩形每一条边都必须与 $\text{x}$ 轴或 $\text{y}$ 轴平行；
* 矩形内部（不包括边）不得有其他点。

***

$1\le n \le 10^{4}$。

# $\text{Answer}$

对于每个矩形，可以枚举它左下与右上的两点，从而可以确定另外两点的坐标，满足了第一个条件。

如一个矩形左下的点为 $(1,1)$，右上的点为 $(2,2)$，则它的另外两个点分别为 $(1,2)$ 与 $(2,1)$。

第二个条件用二维前缀和维护即可，如果不为 $0$，则内部包含其他点，排除。

注意 $\texttt{AtCoder}$ 上输出答案需要换行即可。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int x[10002],y[10002];
int a[1002][1002],s[1002][1002];
int ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>x[i]>>y[i];
		x[i]++;y[i]++;
		a[x[i]][y[i]]=1;
	}
	for(int i=1;i<=1000;++i)
		for(int j=1;j<=1000;++j)
			s[i][j]=a[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			if(x[i]<x[j]&&y[i]<y[j])
				if(a[x[i]][y[j]]&&a[x[j]][y[i]]&&!(s[x[j]-1][y[j]-1]-s[x[i]][y[j]-1]-s[x[j]-1][y[i]]+s[x[i]][y[i]]))
					ans=max(ans,(x[j]-x[i])*(y[j]-y[i]));
	cout<<ans<<"\n";
	return 0;
}
```


---

## 作者：ttq012 (赞：0)

题意：你有一些喵喵，在 $(x_i,y_i)$ 位置上有一只喵喵，现在你要选择四只喵喵，满足这四只喵喵围成了一个长方形，并且四条边都和横坐标轴或者纵坐标轴平行，问你用这些喵喵围成的最大的矩形面积是多大。

题解：萌萌的二维前缀和。枚举任意的两只喵喵的位置，然后判断这两只喵喵是否能组成一个满足上述条件的长方形，求出长方形的面积，求最大值即可。时间复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

int s[10001][10001];
int x[10001], y[10001];
bool mp[10010][10010];

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i ++)
	{
		cin >> x[i] >> y[i];
		s[x[i]][y[i]] ++;
		mp[x[i]][y[i]] = true;
	}
	for (int i = 0; i <= 1000; i ++)
		for (int j = 0; j <= 1000; j ++)
			s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
	int mx = 0;
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= n; j ++)
			if (i != j)
			{
				int x1 = x[i], y1 = y[i];
				int x2 = x[j], y2 = y[j];
				if (x1 > x2) swap(x1, x2);
				if (y1 > y2) swap(y1, y2);
				int ss = s[x2 - 1][y2 - 1] - s[x1][y2 - 1] - s[x2 - 1][y1] + s[x1][y1];
				if (ss || !mp[x1][y2] || !mp[x2][y1] || !mp[x1][y1] || !mp[x2][y2])
					continue ;
				int jx = x2 - x1;
				int jy = y2 - y1;
				int sq = jx * jy;
				mx = max(mx, sq);
			}
	cout << mx << '\n';
	return 0;
}

```

---

## 作者：ChikHid (赞：0)

[题目](https://www.luogu.com.cn/problem/AT171)   [博客食用](https://www.luogu.com.cn/blog/XJK/solution-at171)

---

~~(容我吐槽下这个翻译)~~

## Problem
$n$ 个点，第 $i$ 个点的坐标 $(x_i, y_i)$ 。

求：这 $n$ 个点能组成矩形的最大面积（没有则输出 $0$）

矩形满足如下条件：

- 矩形的边都与 $x$ 轴或 $y$ 轴平行
- 矩形内部（不含边）不得有其他点

## Answer
初看这题，应该能想到枚举矩形的顶点，而且只需枚举两个点，就可以得到矩形，再进行一些判断便能得到答案（~~完美~~）

在判断矩形内是否含有其他点时，一个一个枚举过去显然是不太行的，可以使用二维前缀和


注意AtCoder中输出需换行
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int read()
{
	int x = 0, m = 1;
	char c = getchar();
	for(; c < '0' || c > '9'; c = getchar())
		if(c == '-')
			m = -1;
	for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c ^ 48), c = getchar());
	return x * m;
}

int n, ans, x[1000005], y[1000005];
int maxx, maxy, minx, miny;
int a[1005][1005], f[1005][1005];//分别用于记录前缀和、是否有这个点

int main()
{
	n = read();
	for(int i = 1; i <= n; i++)
	{
		x[i] = read(), y[i] = read();
		f[x[i]][y[i]] = 1;
		a[x[i] + 1][y[i] + 1] = 1;
	}
	for(int i = 1; i <= 1001; i++)
		for(int j = 0; j <= 1001; j++)
			a[i][j] += a[i - 1][j];
	for(int i = 0; i <= 1001; i++)
		for(int j = 1; j <= 1001; j++)
			a[i][j] += a[i][j - 1];
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			if(i != j)//枚举两个不同的点
			{
				maxx = max(x[i], x[i]);
				maxy = max(y[i], y[j]);
				minx = min(x[i], x[j]);
				miny = min(y[i], y[j]);
				if(f[x[i]][y[j]] && f[x[j]][y[i]])//判断矩形的另两个顶点是否存在
					if(a[maxx][maxy] - a[minx + 1][maxy] - a[maxx][miny + 1] + a[minx + 1][miny + 1] == 0)//判断矩形内是否有其他点
						ans = max(ans, (maxx - minx) * (maxy - miny));//比较面积
			}
	cout << ans << endl;
	return 0;
}
```

~~完结撒花~~

---


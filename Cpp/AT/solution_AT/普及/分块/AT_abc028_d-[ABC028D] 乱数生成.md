# [ABC028D] 乱数生成

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc028/tasks/abc028_d

$ 2 $ つの整数 $ N $、$ K $ が与えられます。

$ 1 $ 以上 $ N $ 以下の整数のなかからどれか $ 1 $ つ、等確率に選ぶ機械を考えます。

その機械を $ 3 $ 回動かした時、選ばれた $ 3 $ つの数の中央値が $ K $ となる確率を求めてください。

## 说明/提示

### Sample Explanation 1

中央値が $ 2 $ となるのは、( $ 1 $ 回目の出力, $ 2 $ 回目の出力, $ 3 $ 回目の出力) が - (1, 2, 3) - (1, 3, 2) - (2, 1, 3) - (2, 3, 1) - (3, 1, 2) - (3, 2, 1) - (1, 2, 2) - (2, 1, 2) - (2, 2, 1) - (3, 2, 2) - (2, 3, 2) - (2, 2, 3) - (2, 2, 2) となる場合で、このいずれかが出る確率は $ 13/27\ =\ 0.481481481... $ です

## 样例 #1

### 输入

```
3 2```

### 输出

```
0.48148148148148148148```

## 样例 #2

### 输入

```
3 1```

### 输出

```
0.25925925925925925926```

## 样例 #3

### 输入

```
765 573```

### 输出

```
0.00147697396984624371```

# 题解

## 作者：一座城·守一人 (赞：10)

## ~~听说在NOIp复赛前写题解可以RP++~~
### 在我拿到这道题的时候，还没有评分，没有题解，甚至连翻译都没有。
# 题目大意(来自yusitong)
（并不懂日语，结合机翻猜的意思，仅供参考（反正能A））

对于给定的两个整数$N,K$，有这样一个机器，每次从$1$和$N$之间的整数（包含$1$和$N$）中，等概率选择一个数。 那个机器运行$3$次，请问被选出的$3$个数的中位数是$K$的概率。

#### 【输入格式】
输入用以下的形式从标准输入给予。

$N,K$

一行两个整数$N(1≤ N ≤ 10^6)$和$K(1 ≤ K ≤ N)$，以空格分隔。

#### 【输出格式】
输出中位数为$K$的概率。通过标准输出输出答案，在末尾输出一个换行。

另外，与标准答案的绝对误差或相对误差在$10^{-9}$之内，就视为正确。

#### 【样例1解释】
中位数为2，以（第一次选择，第二次选择，第3次选择）的形式表示，有以下情况符合要求
```
(1, 2, 3)
(1, 3, 2)
(2, 1, 3)
(2, 3, 1)
(3, 1, 2)
(3, 2, 1)
(1, 2, 2)
(2, 1, 2)
(2, 2, 1)
(3, 2, 2)
(2, 3, 2)
(2, 2, 3)
(2, 2, 2)
```
因此答案是$\large{\frac{13}{27}} = 0.481481481...$

# 题解

按照一个中学生的思路,分三次模拟抽到的数,并且计算他们中位数是k的概率

**用树状图模拟**
#### 注意:从上往下分别是:第一次取数,第二次取数,第三次取数.
### 大纲
![大纲.PNG](https://i.loli.net/2018/11/01/5bdaf05ac0c49.png)
### 第一次取数比$k$小
![分块1.PNG](https://i.loli.net/2018/11/01/5bdaf05ad6e69.png)
### 第一次取数等于$k$
![分块2.PNG](https://i.loli.net/2018/11/01/5bdaf05ad8d05.png)
### 第一次取数比$k$大
![分块3.PNG](https://i.loli.net/2018/11/01/5bdaf05acb25c.png)

**开始计算概率**

取到的数比$k$小的概率:

$\frac{k-1}{n}$
(${1}\to {(k-1)}$)

取到的数等于$k$的概率

$\frac{1}{n}$~~(这个最好理解了)~~

取到的数比$k$大的概率

$\frac{n-k}{n}$
(${(k+1)}\to {n}$)

#### 将符合题意的各种情况,从上到下将概率相乘,便是该情况出现的概率
#### 将各种情况出现的概率相加,便是总概率.

这样,比$k$小的符合题意的情况出现的概率:

$\large{\frac{(k-1)*(n-k+1)+(n-k)}{n^3}}$

这样,比$k$大的符合题意的情况出现的概率:

$\large{\frac{(k-1)*(n-k+1)+(n-k)*k+n}{n^3}}$

这样,等于$k$的符合题意的情况出现的概率:

$\large{\frac{(n-k)*(2*k+1)}{n^3}}$

# $CODE$
#### 祝我NOIp2018 $Rp++$;
```cpp
#include<bits/stdc++.h>
using namespace std;
long double n,k;
int main() {
	cin>>n>>k;
	long double a=(k-1)*((n-k+1)+(n-k))/(n*n*n);
	long double b=(n+(k-1)*(n-k+1)+(n-k)*k)/(n*n*n);
	long double c=(n-k)*(k+k-1)/(n*n*n);
	long double ans=a+b+c;
	cout<<fixed<<setprecision(20)<<ans<<endl;
	return 0;
}
```

---

## 作者：BurningEnderDragon (赞：5)

[题目链接：AT1445 乱数生成](https://www.luogu.com.cn/problem/AT1445)

## 分类讨论

本题需分类讨论。

若要使选出的三个数的中位数为 $K$，则可能是以下四种情况中的一种：

1. 一个数小于 $K$，一个数等于 $K$，一个数大于 $K$（仅当 $1 < K < N$）；
2. 一个数小于 $K$，两个数等于 $K$（仅当 $K > 1$）；
3. 两个数等于 $K$，一个数大于 $K$（仅当 $K < N$）；
4. 三个数都等于 $K$。

形式化地：

设选中的三个数分别为 $a,b,c$，且 $a \le b \le c$，则有以下四种情况：

1. $1 \le a < K$，$b = K$，$K < c \le N$（仅当 $1 < K < N$）；
2. $1 \le a < K$，$b = c = K$（仅当 $K > 1$）；
3. $a = b = K$，$K < c \le N$（仅当 $K < N$）；
4. $a = b = c$。

其中第二种和第三种情况可以概括为一种情况：

- 两个数等于 $K$，一个数不等于 $K$。

## 计算

### 计算方法

对于**每次选择**，都是从 $1 \sim N$ 这 $N$ 个数中选，故选择到指定区间 $\left[ l,r \right]$（$1 \le l \le r \le N$） 之间的任意一个数的概率为 $\dfrac{r-l+1}{N}$。

### 对于第一种情况

选出一个小于 $K$ 的数的概率为 $\dfrac{K-1}{N}$；

选出一个等于 $K$ 的数的概率为 $\dfrac{1}{N}$；

选出一个大于 $K$ 的数的概率为 $\dfrac{N-K}{N}$。

而这三个数在所有的选择方案中有 $6$ 种不同的排列。

例如：$\{ 1,2,3 \}$ 有这 $6$ 种不同的排列：$\{ 1,2,3 \}$、$\{ 1,3,2 \}$、$\{ 2,1,3 \}$、$\{ 2,3,1 \}$、$\{ 3,1,2 \}$ 和 $\{ 3,2,1 \}$。

所以第一种情况的概率为：
$$
\frac{K-1}{N} \times \frac{1}{N} \times \frac{N-K}{N} \times 6 = \frac{6 \times (K-1) \times (N-K)}{N^3}
$$

### 对于第二种和第三种情况

选出一个等于 $K$ 的数的概率为 $\dfrac{1}{N}$（需要选两次）；

选出一个不等于 $K$ 的数的概率为 $\dfrac{N-1}{N}$；

而这三个数在所有的选择方案中有 $3$ 种不同的排列。

例如：$\{ 1,2,2 \}$ 有这 $3$ 种不同的排列：$\{ 1,2,2 \}$、$\{ 2,1,2 \}$ 和 $\{ 2,2,1 \}$。

所以第二种情况的概率为：
$$
\left( \frac{1}{N} \right) ^ 2 \times \frac{N-1}{N} \times 3 = \frac{3 \times (N-1)}{N^3}
$$

### 对于第四种情况

（最简单的一种情况）

选出一个等于 $K$ 的数的概率为 $\dfrac{1}{N}$（需要选三次）；

而这三个相同的数在所有的选择方案中仅有 $1$ 种不同的排列。

例如：$\{ 1,1,1 \}$ 只有 $\{ 1,1,1 \}$ 这一种排列（很显然）。

所以第四种情况的概率为：
$$
\left( \frac{1}{N} \right) ^ 3 \times 1 = \frac{1}{N^3}
$$

### 综上所述

选出的三个数的中位数是 $K$ 即为四种情况的概率之和：
$$
\frac{6 \times (K-1) \times (N-K) + 3 \times (K-1) + 1}{N^3}
$$
直接输出答案即可。

## 代码

这里为了免去计算过程中的强制类型转换，直接将 $N$ 和 $K$ 定义为了 `double` 类型。

同时使用 `<iomanip>` 头文件中的 `fixed` 和 `setprecision()` 控制浮点数输出精度。

```cpp
#include <iostream>
#include <iomanip>
using namespace std;
double N,K;
int main()
{
	cin>>N>>K;
	cout<<fixed<<setprecision(20)<<(1+(N-1)*3+(K-1)*(N-K)*6)/(N*N*N)<<endl;
	return 0;
}
```

---

## 作者：Mine_King (赞：4)

本人已在AtCoder上AC：https://atcoder.jp/contests/abc028/submissions/15884786

若$\LaTeX$炸了请点击“在 Ta 的博客查看”。

这题应该是个比较基础的概率题吧。
考虑要求中位数是 $k$，那么随机生成的三个数 $a,b,k$ 一定满足 $a \le k \le b$，只有这样才能使得中位数是 $k$。那么我们分类讨论：

- `a!=k&&b!=k` : 这种情况下，$a$ 必须是$1 \rightarrow k-1$，而 $b$ 必须是 $k+1 \rightarrow n$。那么这种情况的概率就是 $\frac{(k-1)\times 1\times(n-k)\times 6}{n^3}$。**注意：这三个数的位置是可以变的，总共有$(a,k,b),(a,b,k),(b,a,k),(b,k,a),(k,a,b),(k,b,a)$六种排列方法。**
- `a==k||b==k` : 这种情况下，就是两个相同，一个不同，那么若$a$不同，就是 $\frac{(k-1)\times1\times1}{n^3}$，若$b$不同，就是 $\frac{1\times1\times(n-k)}{n^3}$，总的情况就是把他们加起来，以及位置是可以变的，但是有两个相同，所以排列方法为三种也就是$\frac{(k-1)+(n-k)}{n^3}\times3=\frac{(n-1)\times3}{n^3}$。
- `a==k&&b==k` : 此时三个数的值都是固定的，所以概率为 $\frac{1}{n^3}$。

最后的结果就是将他们加起来，也就是
$$\frac{(k-1)\times 1\times(n-k)\times 6+(n-1)\times3+1}{n^3}$$
然后，由于本题好像有点卡精度，$n,k$以及最终结果都要是`long double`。注意了，`printf`输出`long double`是会有问题的。

---

## 作者：diqiuyi (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/AT1445)

## 思路

显然，考虑到选法是**有序**的，每次从 $n$ 种里面选 $1$ 种，总共有 $n^3$ 种选法。至于有多少种合法的选法，应该**分类对每次**讨论。

## 讨论过程

设第一次选 $x$，第二次选 $y$，第三次选 $z$。

### $1.x<k$

则 $x$ 有 $(k-1)$ 种取法，且 $y \ge k$。

#### $1.y=k$

则 $y$ 仅有一种取法，且 $z \ge k$，有 $(n-k+1)$ 种取法。

#### $2.y>k$

则 $y$ 有 $(n-k)$ 种取法，此时 $z=k$，仅有 $1$ 种取法。

**综上，这种情况共有 $(k-1)(2n-2k+1)$ 种取法。**

### $2.x=k$

则 $x$ 仅有 $1$ 种取法。

#### $1.y<k$

则 $y$ 有 $(k-1)$ 种取法，此时 $ z \ge k$，有 $(n-k+1)$ 种取法。

#### $2.y=k$

则 $y$ 有 $1$ 种取法， $z$ 不受限制，有 $n$ 种取法。

#### $3.y>k$

则 $y$ 有 $(n-k)$ 种取法，此时 $ k \ge z$，有 $k$ 种取法。

**综上，这种情况共有 $(n+(k-1)(n-k+1)+k(n-k))$ 种取法。**

### $3.x>k$

则 $x$ 有 $(n-k)$ 种取法，且 $ y \le k$。

#### $1.y<k$

则 $y$ 有 $(k-1)$ 种取法，此时 $ z = k$，有 $1$ 种取法。

#### $2.y=k$

则 $y$ 有 $1$ 种取法，则 $z \le k$，有 $k$ 种取法。

**综上，这种情况共有 $(n-k)(2k-1)$ 种取法。**

##
如此一来，代码实现就很简单了。

### CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
long double n,k;//不开 long double 的话要在下面多次乘以 1.0
int main(){
	cin>>n>>k;
	cout<<fixed<<setprecision(15)<<
    	(k-1)*(2*n-2*k+1)/(n*n*n)
    	+(n+(k-1)*(n-k+1)+k*(n-k))/(n*n*n)
    	+(n-k)*(2*k-1)/(n*n*n)<<endl;
    	//小数点后保留 15 位只是为了保险
	return 0;
}
```

总的来讲这是一道数学题，要注意**有序**地枚举和讨论。

---

## 作者：q_sum (赞：1)

这是蒟蒻第三次发题解，也是第一次发$AT$的题解

这道题目虽然代码简单，但是思考过程很复杂。

中位数，就是指排在中间的数，如果是三个数中的中位数，那么就是第二大的数，假设这三个数按照大小次序依次为$a,b,k$,那么可以得到$a$>=$k$，$b$<=$k$,文中叫我们求得是中位数为$k$的概率,概率的公式为$P(A)=A$所含样本点数/总体所含样本点数,总体所含样本点数为$n$的三次方，所含样本点数也分三种情况：
    
- $a!=b$&&$b!=k$譬如$1$，$2$，$3$就有$6$种情况（$1$，$2$，$3$）（$1$，$3$，$2$）（$2$，$1$，$3$）（$2$，$3$，$1$）（$3$，$1$，$2$）（$3$，$2$，$1$）
- $a,b$当中有一个等于$k$,譬如$1$，$2$，$2$就有$3$种情况（$1$，$2$，$2$）（$2$，$1$，$2$）（$2$，$2$，$1$）
- $a$==$b$==$k$，譬如（$2$,$2$,$2$）,只有一种选择，也只有一种排列方式（$2$,$2$,$2$），所以只有一种情况。

解释完了，下面发代码吧！

```cpp
#include<bits/stdc++.h>錒
using namespace std;
long double n,k,p;
int main()
{
	cin>>n>>k;
	cout<<fixed<<setprecision(20)<<((k-1)*(n-k)*6+(n-1)*3+1)/(n*n*n)<<endl;
    //(k-1)*(n-k)*6表示第一种情况，(n-1)*3表示第二种情况，1表示第三种情况，这里有一个坑，后面必须/(n*n*n)，不能/n/n/n,否则会WA，我就是中了这个坑。因为这里要输出20位，只能用long double或string类型，因为string需要用高精度加减乘除，所以我这里不演示了,long double用C语言的输出会出bug，所以这里用setprecision
}
```
//附带：不能抄题解

---

## 作者：Eason_AC (赞：0)

## Description
有一个机器会等概率从 $1$ 到 $n$ 的正整数中选出一个整数。显然地，这个机器运行 $3$ 次后会得到 $3$ 个整数。求这 $3$ 个整数的中位数是 $k$ 的概率。

**数据范围：$1\leqslant k\leqslant n\leqslant 10^6$。**
## Solution
发现自己快到 CSP 了完全不会概率，于是随便在 AtCoder 上面找了个题玩玩。

首先我们发现，由于选取的整数个数为奇数，那么要想这 $3$ 个数为 $k$，选取的三个数中至少应该有一个数是 $k$。

我们不妨设所选的 $3$ 个正整数为 $a,b,c$，然后对 $a,b,c$ 的取值情况进行分类讨论。以下设 $p$ 为任意不等于 $k$ 的正整数。

1. $a=b=c=k$。  
显然，只有一种情况能够满足这个要求。
2. $a,b,c$ 中恰好有 $2$ 个整数为 $k$。  
显然，从其余的 $n-1$ 个正整数中选出一个数都能够满足这类条件。然后考虑一般的情况，由于不同的排列有 $(k,k,p)$，$(k,p,k)$ 和 $(p,k,k)$ 三种，因此这类下一共有 $3(n-1)=3n-3$ 种情况。

3. $a,b,c$ 中恰好有 $1$ 个整数为 $k$。  
另外一个数要么是在 $[1,k-1]$ 中（也就是有 $k-1$ 种不同的取值情况），要么是在 $[k+1,n]$ 中（也就是有 $n-k$ 种不同的取值情况）。又由于不同的排列一共有 $(k,p_1,p_2)$，$(k,p_2,p_1)$，$(p_1,k,p_2)$，$(p_2,k,p_1)$，$(p_1,p_2,k)$ 和 $(p_2,p_1,k)$ $6$ 种，因此这类下一共有 $6(k-1)(n-k)=6nk-6k^2-6n+6k$ 种情况。

把上面这三类整合在一起，因此一共有 $6nk-6k^2-6n+6k+3n-3+1=6nk-6k^2-3n+6k-2$ 种情况。又因为所有不同的情况一共有 $n^3$ 种。因此概率为：

$$\dfrac{6nk-6k^2-3n+6k-2}{n^3}$$

注意在代码实现中，由于允许的误差很小，答案需要用 `long double` 储存以保证精度。

代码就不贴了。

---

## 作者：TerryGong (赞：0)

# AT1145 随机数生成

翻译已非常明白了，不再赘述。

为了让表述更清楚，我们把生成的数字称为：

$a_1,a_2,a_3$ 

依次考虑。

每个数字有三种情况：

- $a<K,P_1=\dfrac{K-1}{N}$

- $a=k,P_2=\dfrac{1}{N}$ 

- $a>k,P_3=\dfrac{N-K}{N}$

### 解题

伪代码：

```cpp
int get(){rand(1~n);}//模拟生成器
double p=1.00000000000000000000;//样例精度要求
int n,k;
input(n,k);
get(a[1]);
if(a[1]<k){
	p10=(k-1)/n;
	get(a[2]);
	if(a[2]<k);//impossible
	if(a[2]==k){
		p12=1/n;
		get(a[3]);
		if(a[3]<k);//impossible
		if(a[3]>=k){
			p12s=(n-k+1)/n;
			p+=p10*p12*p12s;//successful
		}
	}
	if(a[2]>k){
		p13=(n-k)/n;
		get(a[3]);
		if(a[3]!=k);//impossible
		if(a[3]==k){
			p13s=1/n;
			p+=p10*p13*p13s;//successful
		}
	}
}
if(a[1]==k){
	p20=1/n;
	get(a[2]);
	if(a[2]<k){
		p21=k/n;
		get(a[3]);
		if(a[3]<k);//impossible
		if(a[3]>=k){
			p21s=(n-k+1)/n;
			p+=p20*p21*p21s;//successful
		}
	}
	if(a[2]==k){
		p22=1/n;
		p+=p20*p22;//successful
	}
	if(a[2]>k){
		p23=(n-k)/n;
		get(a[3]);
		if(a[3]>k);//impossible
		if(a[2]<=k){
			p23s=k/n;
			p+=p20*p23*p23s;//successful
		}
	}
}
if(a[1]>k){
	p30=(n-k)/n;
	get(a[2]);
	if(a[2]>k);//impossible
	if(a[2]==k){
		p32=1/n;
		get(a[3]);
		if(a[3]>k);//impossible
		if(a[3]<=k){
			p32s=k/n;
			p+=p30*p32*p32s;//successful
		}
	}
	if(a[2]<k){
		p33=k/n;
		get(a[3]);
		if(a[3]!=k);//impossible
		if(a[3]==k){
			p33s=1/n;
			p+=p30*p33*p33s;//successful
		}
	}	
}
```

这就是这道题的思考过程了。

最后算出来的答案，应该是

$P=P_1\times P_2\times (P_2+P_3)+P_1\times P_3\times P_2$
$+P_2\times (P_1+P_2)\times (P_2+P_3)+ P_2\times P_2+$
$P_2\times P_3\times (P_1+P_2)+ P_3\times P_2\times (P_1+P_2)+$
$P_3\times (P_1+P_2)\times P_2=\dfrac{...}{N^3}$

(`...`处太多了，省略掉不写，一个学 $OI$ 的人的基本计算功底应该足以算出来)

### SO SOLUTION IS

```cpp
#include<bits/stdc++.h>
using namespace std;
long double n,k,a,b,c,ans;
int main(){
	cin>>n>>k;
	a=k-1;b=n-k;c=n*n*n;
	ans=(a*(b+b+1)+(n+a*(b+1)+b*k)+b*(2*k-1))/c;
	cout<<fixed<<setprecision(20)<<ans<<endl;
	return 0;
}
```

### 提示：本题目对提升计算能力的帮助较大，尽量自己算算

---


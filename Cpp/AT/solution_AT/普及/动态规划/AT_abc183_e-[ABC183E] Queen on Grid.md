# [ABC183E] Queen on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc183/tasks/abc183_e

縦 $ H $ マス、横 $ W $ マスのグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマス $ (i,j) $ は、$ S_{ij} $ が `#` のとき壁であり、`.` のとき道です。

マス $ (1,1) $ にチェスのクイーンの駒が置いてあります。 クイーンの駒は、今いる位置から右・下・右下方向に伸びる直線上にあり、壁を飛び越えずに到達できる道のマスに $ 1 $ 手で移動することができます。

クイーンの駒がマス $ (1,1) $ からマス $ (H,W) $ まで移動する方法は何通りありますか？ $ \bmod\ (10^9+7) $ で求めてください。

ただし、移動する方法が異なるとは、ある $ i $ が存在して、$ i $ 手目の移動の後にクイーンの駒があるマスの位置が異なることを指します。

## 说明/提示

### 制約

- $ 2\ \leq\ H,W\ \leq\ 2000 $
- $ S_{ij} $ は `#` か `.`
- $ S_{11} $ と $ S_{HW} $ は `.`

### Sample Explanation 1

移動方法として次の $ 10 $ 通りが考えられます。 - $ (1,1)\to\ (1,2)\to\ (1,3)\to\ (2,3)\to\ (3,3) $ - $ (1,1)\to\ (1,2)\to\ (1,3)\to\ (3,3) $ - $ (1,1)\to\ (1,2)\to\ (2,3)\to\ (3,3) $ - $ (1,1)\to\ (1,3)\to\ (2,3)\to\ (3,3) $ - $ (1,1)\to\ (1,3)\to\ (3,3) $ - $ (1,1)\to\ (2,1)\to\ (3,1)\to\ (3,2)\to\ (3,3) $ - $ (1,1)\to\ (2,1)\to\ (3,1)\to\ (3,3) $ - $ (1,1)\to\ (2,1)\to\ (3,2)\to\ (3,3) $ - $ (1,1)\to\ (3,1)\to\ (3,2)\to\ (3,3) $ - $ (1,1)\to\ (3,1)\to\ (3,3) $

### Sample Explanation 2

$ (1,1) $ からは $ 1 $ 手で $ (1,2),(1,3),(2,1),(2,2),(3,1),(4,1) $ のいずれかへ移動することが出来ます。 $ (4,4) $ への移動経路として、例えば $ (1,1)\to\ (3,1)\to\ (3,2)\to\ (4,3)\to\ (4,4) $ などがあります。

### Sample Explanation 3

移動方法の数を $ \bmod\ (10^9+7) $ で求めてください。

## 样例 #1

### 输入

```
3 3
...
.#.
...```

### 输出

```
10```

## 样例 #2

### 输入

```
4 4
...#
....
..#.
....```

### 输出

```
84```

## 样例 #3

### 输入

```
8 10
..........
..........
..........
..........
..........
..........
..........
..........```

### 输出

```
13701937```

# 题解

## 作者：CleverPenguin (赞：2)

## 思路
我们在小奥里经常做这种题。

我们会将能到达这个点的地方的各种方案的和加在一起。

所以就可以模拟这种方式，然后将有障碍的值提前赋为 $0$。

但这种方法的时间复杂度实在难以通过。

所以就有了新的思考：如何优化使得少一层时间。

这里的平方是遍历，无法优化，所以考虑优化判断与计算。

不难发现，最多只有三个方向可以走到一个点，所以考虑对三个方向做预处理如下。

上方向：$up _ {i,j} = up _ {i-1,j} +  dp_ {i-1,j}$。

左方向：$left _ {i,j} = left _ {i,j-1} +  dp_ {i,j-1}$。

左上方向：$ul _ {i,j} = ul _ {i-1,j-1} + dp_ {i-1,j-1}$。

总和：$dp _ {i,j} = ul _ {i,j} +  up _ {i,j} + left _ {i,j}$。

所以最终将 $ dp _ {h,w}$ 输出即可。

---

## 作者：Redamancy_Lydic (赞：2)

## 题意

一个 $n\times m$ 的网格，有的能走，有的不能。每次可以向右，下，右下走，问从 $(1,1)$ 走到 $(n,m)$ 有几种方法。答案对 $10^9+7$ 取模。

## 分析

这道题可以爆搜，但是会超时。所以考虑更高级的做法：

### ——动态规划+前缀和

考虑三个方向的走动，用三个前缀和数组来存储从上面，左面，左上走来的步数。动归数组 $f_{i,j}$ 表示走到 $(i,j)$ 的方案数。前缀数组与动归数组的 $(1,1)$ 元素是输入数组的能否走动性，即 $1$ 或 $0$ 表示。

考虑状态转移，当当前格子能走时，显然得到

$f_{i,j}=(sum1_{i-1,j}+sum2_{i,j-1}+sum3_{i-1,j-1})\mod 10^9+7$

而三个数组的迭代则是它的上一个值与动归数组值的和，即

$sum1_{i,j}=(sum1_{i-1,j}+f_{i,j})\mod 10^9+7$

$sum2_{i,j}=(sum2_{i,j-1}+f_{i,j})\mod 10^9+7$

$sum3_{i,j}=(sum3_{i-1,j-1}+f_{i,j})\mod 10^9+7$

否则，让四个数组的当前元素值都等于 $0$ 表示不可走，即

$f_{i,j}=sum1_{i,j}=sum2_{i,j}=sum3_{i,j}=0$

### 一点细节

- 以字符形式输入数组，要注意字符的判断。

- 当 $i=1,j=1$ 时要跳过。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mo = 1e9+7;
int n,m;
long long f[5000][5000];//dp数组
char s[5000][5000];//输入数组
long long s1[5000][5000],s2[5000][5000],s3[5000][5000];//三个前缀和
int main()
{
//	freopen("input.in","r",stdin);
//	freopen("output.out","w",stdout);
cin>>n>>m;
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		cin>>s[i][j];
	}
}
f[1][1]=s1[1][1]=s2[1][1]=s3[1][1]=(s[1][1]=='#'?0:1);//初始化
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if(i==1&&j==1) continue;
		if(s[i][j]=='#')
		f[i][j]=s1[i][j]=s2[i][j]=s3[i][j]=0;
		else{
		    f[i][j]=(s1[i-1][j]+s2[i][j-1]+s3[i-1][j-1])%mo;
            s1[i][j]=(s1[i-1][j]+f[i][j])%mo;
            s2[i][j]=(s2[i][j-1]+f[i][j])%mo;
            s3[i][j]=(s3[i-1][j-1]+f[i][j])%mo;
        }
	}
}
cout<<f[n][m];
	return 0;
}
```
点个赞吧~

---

## 作者：zhujiangyuan (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/AT_abc183_e)

基础 dp 题目。

设 $f_{i,j}$ 为到点 $(i,j)$ 的方案数，边界 $f_{1,1}$ 为 $1$。

设 $x_{i,j}$ 为从**左边**走到 $(i,j)$ 的方案数，由于每次可以走多格，所以可得 $x_{i,j}=x_{i,j-1}+f_{i,j-1}$。$x_{i,j-1}$ 为从左边走到 $(i,j-1)$ 的方案数，$f_{i,j-1}$ 为走到 $(i,j-1)$ 的方案数。

设 $y_{i,j}$ 为从**上边**走到 $(i,j)$ 的方案数，$z_{i,j}$ 为从**左上**走到 $(i,j)$ 的方案数。同理可得：$y_{i,j}=y_{i-1,j}+f_{i-1,j}$，$z_{i,j}=z_{i-1,j-1}+f_{i-1,j-1}$。

求出 $x_{i,j},y_{i,j},z_{i,j}$ 后，可得 $f_{i,j}=x_{i,j}+y_{i,j}+z_{i,j}$。

整理一下：

$$\begin{cases}x_{i,j}=x_{i,j-1}+f_{i,j-1}\\y_{i,j}=y_{i-1,j}+f_{i-1,j}\\z_{i,j}=z_{i-1,j-1}+f_{i-1,j-1}\\f_{i,j}=x_{i,j}+y_{i,j}+z_{i,j}\end{cases}$$

最后答案为 $f_{n,m}$，每一步记得对 $10^9+7$ 取模。

[代码](https://atcoder.jp/contests/abc183/submissions/44870781)，时间复杂度 $O(nm)$。

---

## 作者：zfx_VeXl6 (赞：1)

### 题目大意

有一个国际象棋的皇后在方格上移动，每次可以移动到右、下、右下的不是障碍物的任意格子上，不能跨过障碍物，问有多少种走法。

### 思路

简单 dp，由于皇后可以移动任意长度，设当前格子是 $(i,j)$，上面第一个障碍物是 $(i-k_u,j)$，左边第一个障碍物是 $(i,j-k_l)$，左上第一个障碍物是 $(i-k_{ul},j-k_{ul})$，到达 $(i,j)$ 的方案数是 $f_{i,j}$，那么可以推出状态转移方程：

$$f_{i,j}=\sum\limits_{k=1}^{k_u-1}f_{i-k,j}+\sum\limits_{k=1}^{k_l-1}f_{i,j-k}+\sum\limits_{k=1}^{k_{ul-1}}f_{i-k,j-k}$$

最终答案便是 $f_{n,m}$。

如果枚举每个 $k$，时间复杂度 $\mathcal O(n^3)$，会超时，考虑优化。

很容易想到前缀和优化。需要在三个方向上都开前缀和数组，设：

$$u_{i,j}=\begin{cases}u_{i-1,j}+f_{i,j}&(i,j)\text{ 可走}\\0&(i,j)\text{ 不可走}\end{cases}$$

$$l_{i,j}=\begin{cases}l_{i,j-1}+f_{i,j}&(i,j)\text{ 可走}\\0&(i,j)\text{ 不可走}\end{cases}$$

$$ul_{i,j}=\begin{cases}ul_{i-1,j-1}+f_{i,j}&(i,j)\text{ 可走}\\0&(i,j)\text{ 不可走}\end{cases}$$

因为当 $(i,j)$ 不可走（即是障碍物）的时候前缀和数组是 $0$，所以这个前缀和相当于是从前面第一个障碍物的前面一个格子开始计数的，所以：

$$u_{i-1,j}=\sum\limits_{k=1}^{k_u-1}f_{i-k,j}$$

$$l_{i,j-1}=\sum\limits_{k=1}^{k_l-1}f_{i,j-k}$$

$$ul_{i-1,j-1}=\sum\limits_{k=1}^{k_{ul-1}}f_{i-k,j-k}$$

方程可以写成：

$$f_{i,j}=u_{i-1,j}+l_{i,j-1}+ul_{i-1,j-1}$$

时间复杂度 $\mathcal O(n^2)$，可以通过。

别忘了取模和换行。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int mod=1000000007;
int n,m;
LL f[2001][2001],u[2001][2001],l[2001][2001],ul[2001][2001];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            char s;
            cin>>s;
            if(i==1&&j==1)
                f[i][j]=u[i][j]=l[i][j]=ul[i][j]=1; //边界条件
            else if(s=='.')
            {
                f[i][j]=(u[i-1][j]+l[i][j-1]+ul[i-1][j-1])%mod;
                u[i][j]=(u[i-1][j]+f[i][j])%mod;
                l[i][j]=(l[i][j-1]+f[i][j])%mod;
                ul[i][j]=(ul[i-1][j-1]+f[i][j])%mod;
            }
        }
    cout<<f[n][m]<<'\n';
    return 0;
}
```

---

## 作者：_Kamisato_Ayaka_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT_abc183_e)

# 1.题目大意

给定一个 $ H \times W $ 的图，可以向下，向右，向右下移动，“.”表示通过,“#”表示不通过，求从 $ (1,1) $ 走到 $ (H,W) $ 的所有方案数。

# 2.思路

这里没说只移动一格，首先就否定掉搜索。这题很像小学的数学题，走到一个点就统计从三个方向走到这个点的方案数，所以我们用 dp 做，转移方程: 

$ f_{i,j}=(x_{i,j}+y_{i,j},z_{i,j}) \bmod (10^9 + 7) $

# 3.代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9+7;
int n,m,f[2005][2005],x[2005][2005],y[2005][2005],z[2005][2005];//x,y,z分别存从左，左上，上走到这个点的路线个数
char mp[2005][2005];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			cin>>mp[i][j];
			if(mp[i][j]=='.') f[i][j]++;//初始化(如果可以走，这里肯定有一条路线)
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(mp[i][j]=='#' || (i==1 && j==1))
				continue;
			x[i][j]=(x[i-1][j]+f[i-1][j])%mod;//从左边来
			y[i][j]=(y[i][j-1]+f[i][j-1])%mod;//从上边来
			z[i][j]=(z[i-1][j-1]+f[i-1][j-1])%mod;//从左上来
			f[i][j]=(x[i][j]+y[i][j]+z[i][j])%mod;//转移
		}
	}
	cout<<f[n][m]%mod<<endl;//结束
	return 0;
}
```


---

## 作者：yyz_100110 (赞：0)

此题是一个方格类型的题目，算**比较简单**的。

**理解：**   
从熟悉的样例入手，这题的样例好理解，就是他给你一个点，你从初始点绕开障碍最少走几步才能走到。   
**做法：**   
这题和大部分方格题一样，他主要是和**前缀和**有关,再拿变量去计算你的步数，最后在交答案。我们这个点的方案数就是方向的“线”上的点的方案数之和，把不能走的线当作起点，那么我们不难发现，我们把这些前缀和所对应的方向的线求出来，再去累加，就可以得到方案数。        
**Code:**
~~~cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[10086][10086],f[10086][10086][3];//数组大一点。
bool b[10086][10086];
int main(){
    cin>>n>>m;
    a[1][1]=1;//初始化。
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            char c;
            cin>>c;
            if(c=='.') 
                b[i][j]=true;//选择判断，可不可以走这里。
        }
    }
    for(int i=1;i<=n;i++){//双重循环，计算二维数组。
        for(int j=1;j<=m;j++){
            if(!b[i][j]) continue;//直接跳过，不用管他。
            a[i][j]+=f[i-1][j][0]+f[i][j-1][1]+f[i-1][j-1][2];
            //计算方案数。
            f[i][j][0]=f[i-1][j][0]+a[i][j];
            //如上面所说，前缀和的计算。
            f[i][j][1]=f[i][j-1][1]+a[i][j];
            f[i][j][2]=f[i-1][j-1][2]+a[i][j];
            a[i][j]%=1000000007;//取模。
            f[i][j][2]%=1000000007;
            f[i][j][1]%=1000000007;
            f[i][j][0]%=1000000007;
        }
    }
cout<<a[n][m];//交答案。
return 0;
}
~~~

---

## 作者：fish_love_cat (赞：0)

**题意：**

其实题面里已经说的比较清楚了，不过需要注意，在这一题里，可以向一个方向走**无数步**，直到撞到地图边界或者不能走的墙上。

**思路：**

由于可以连续走无数步，所以这个点的方案数就等于走过来的三个方向的“线”上的点的方案数之和，以往前推遇到的第一个不可走的点为这个方向上的“线”的起点，以当前点为“线”的结尾。我们发现，可以利用前缀和来计算这条线的结果，我们只需要把每个点对应的方向计算出前缀和，就不难得到每个点的方案数。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long a[2040][2040],f[2040][2040][3];//long long 保险
bool b[2040][2040];
int main(){
    cin>>n>>m;
    a[1][1]=1;//初始化
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            char c;
            cin>>c;
            if(c=='.') b[i][j]=true;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(!b[i][j]) continue;//如果不能走就跳过
            a[i][j]+=f[i-1][j][0]+f[i][j-1][1]+f[i-1][j-1][2];
            //上一格同方向总方案数+这一格方案数=前缀和
            f[i][j][0]=f[i-1][j][0]+a[i][j];
            f[i][j][1]=f[i][j-1][1]+a[i][j];
            f[i][j][2]=f[i-1][j-1][2]+a[i][j];
            //取模
            a[i][j]%=1000000007;
            f[i][j][2]%=1000000007;
            f[i][j][1]%=1000000007;
            f[i][j][0]%=1000000007;
        }
    }
    cout<<a[n][m];//输出结果
    return 0;
}
```

~~感觉可以评绿了……~~

---

## 作者：Zaku (赞：0)

[Link](https://www.luogu.com.cn/problem/AT_abc183_e)

[Link(on AT)](https://atcoder.jp/contests/abc183/tasks/abc183_e)

[My Submission](https://atcoder.jp/contests/abc183/submissions/40589662)

### 解法：
简单动归题。

#### 状态表示：
- $f_{i,j,0}$ 表示走到 $(i,j)$，上一步往下的方案数；
- $f_{i,j,1}$ 表示走到 $(i,j)$，上一步往右的方案数；
- $f_{i,j,2}$ 表示走到 $(i,j)$，上一步往右下的方案数。
- $ans_{i,j}$ 表示走到 $(i,j)$ 的方案总数。

#### 边界条件：

$ans_{1,1}=1$

#### 转移方程：
$$ans_{i,j}=f_{i-1,j,0}+f_{i,j-1,1}+f_{i-1,j-1,2}$$

注意到障碍物格子的方案数为 $0$。

好的，下面是代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e3 + 5, mod = 1e9 + 7;
char g[N][N];
ll f[N][N][3], ans[N][N];
int main(){
	int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> g[i] + 1; 
    ans[1][1] = 1;//边界条件 
    for (int i = 1; i <= n; i ++ ){
    	for (int j = 1; j <= m; j ++ ){
            if (g[i][j] == '#'){
                f[i][j][0] = f[i][j][1] = f[i][j][2] = 0;
                continue;//障碍物格子方案数为0 
            }
            //所有方案加起来 
            ans[i][j] = (ans[i][j] + f[i - 1][j][0] + f[i][j - 1][1] + f[i - 1][j - 1][2]) % mod;
            //分别更新方案数 
            f[i][j][0] = (f[i - 1][j][0] + ans[i][j]) % mod;
            f[i][j][1] = (f[i][j - 1][1] + ans[i][j]) % mod;
            f[i][j][2] = (f[i - 1][j - 1][2] + ans[i][j]) % mod;
        }
	}
    cout << ans[n][m];
    return 0;
}
```

---


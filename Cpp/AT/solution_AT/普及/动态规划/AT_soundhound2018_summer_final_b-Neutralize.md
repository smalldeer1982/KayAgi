# Neutralize

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_b

$ N $ 個の薬品が横一列に並んでいます。それぞれの薬品には *効用* という整数値が定まっており、左から $ i $ 番目の薬品の現在の効用は $ b_i $ です。これらの値は正とは限りません。

Kenkoooo さんは、横長の特殊な装置を用いて次の操作を何回でも行えます（行わなくても構いません）。

- 連続して並ぶ $ K $ 個の薬品を選ぶ。選ばれた薬品の効用はすべて $ 0 $ となる。

なお、薬品を移動させることは危険を伴うためできません。

その後、Kenkoooo さんは $ N $ 個の薬品すべてを飲み干します。その前に、$ N $ 個の薬品の効用の和を可能な限り大きくしておきたいです。操作後のこの和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ K\ <\ =\ N\ <\ =\ 2\ ×\ 10^5 $
- $ -10^9\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

最適な手順の例を示します。 - $ 1 $ 回目の操作: 左から $ 1,\ 2,\ 3 $ 番目の薬品を選ぶ。 - $ 2 $ 回目の操作: 左から $ 6,\ 7,\ 8 $ 番目の薬品を選ぶ。 - $ 3 $ 回目の操作: 左から $ 7,\ 8,\ 9 $ 番目の薬品を選ぶ。 このとき、$ 9 $ 個の薬品の効用の和は $ 0\ +\ 0\ +\ 0\ +\ 4\ +\ 5\ +\ 0\ +\ 0\ +\ 0\ +\ 0\ =\ 9 $ となります。

### Sample Explanation 2

何もせずこのまま薬品を飲み干すべきです。

## 样例 #1

### 输入

```
9 3
-1
-2
-3
4
5
-6
-7
-8
-9```

### 输出

```
9```

## 样例 #2

### 输入

```
5 4
-1
-1
5
-1
-1```

### 输出

```
1```

## 样例 #3

### 输入

```
9 5
30
-20
40
60
-90
50
-40
10
70```

### 输出

```
120```

## 样例 #4

### 输入

```
10 1
1000000000
-1000000000
1000000000
-1000000000
1000000000
-1000000000
1000000000
-1000000000
1000000000
-1000000000```

### 输出

```
5000000000```

# 题解

## 作者：__delta_epsilon__ (赞：1)

### 题目大意

给你一个 $N$ 长的整数序列 $b_i$，你可以进行若干次如下操作：

- 将连续的 $K$ 个整数变为 $0$。

你要使 $\sum b_i$ 最大化。

### 思路分析

显然，这是一道动态规划题。

$f_{i,0}$ 表示前 $i$ 项可以不受限制地将整数变为 $0$ 时的最优解。

$f_{i,1}$ 表示前 $i$ 项的最优解。

$f$ 的初始值为 $f_{0,0}=f_{0,1}=0,\textrm{others}=-\infty$。

状态转移方程为，

$$f_{i+1,0}=\max\{f_{i,0},f_{i,1}\}+b_i$$

即前 $i+1$ 项不受限制的最优解等于前 $i$ 项不受限制的最优解与前 $i$ 项受到限制的最优解加上第 $i$ 项的值。

$$f_{i+1,1}=\max\{f_{i+1-k,0},f_{i,1}\}$$

即前 $i+1$ 项受到限制的最优解等于前 $i+1-k$ 项不受限制的最优解（即 $i+1-k$ 后的 $k$ 项均变为 $0$）与前 $i$ 项受到限制的最优解的最大值。

答案即为 $f_{n,0}$ 与 $f_{n,1}$ 的最大值。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, k, b[200020], dp[200020][2];

signed main() {
	cin >> n >> k;
	for (int i = 0; i < n; i++) {
		cin >> b[i];
	}
	memset(dp, 0x80, sizeof dp);
	// 这句话将 dp 全部赋值为 0x8080808080808080 = -9187201950435737472。
	dp[0][0] = dp[0][1] = 0;
	// 设置初始值。
	for (int i = 0; i < n; i++) {
		dp[i + 1][0] = max(dp[i][0], dp[i][1]) + b[i];
		if (i + 1 - k >= 0)
			dp[i + 1][1] = max(dp[i + 1 - k][0], dp[i][1]);
	} // 进行状态转移。
	cout << max(dp[n][0], dp[n][1]);
	// 输出答案。
	return 0;
}
```

运行编号：43568962。

运行时间：80 ms。

运行内存：8280 KB。

时间复杂度：$O(n)$。

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT_soundhound2018_summer_final_b)

## 算法：

**DP**，将 $dp$ 数组分 $2$ 个维度，一个是有限制删除量的，一个不限制。

那么不受限制的就可以从 $dp_{i-1,0}$ 与 $dp_{i-1,1}$ 中的大者加上 $m_i$ 来转移。

受限制的则可以从 $dp_{i-1,1}$ 与 $dp_{i-K}$ 中的大者转移得来。

数据不弱的，$dp$ 数组的初始化一定要做好，开始不受限制的和受限制的都为 $0$，其它设为无穷小，真的要很小！

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
const long long N=200005;
long long m[N];
long long f[N][5];
long long x,y;
void oin(){
	cin>>x>>y;
	for(long long i=1;i<=x;i++) cin>>m[i];
}
void csh(){
	f[0][1]=f[0][0]=0; 
	for(long long i=1;i<=x;i++) f[i][0]=f[i][1]=-1145141919870;//一定要小！-1145141919都不够小 
}//初始化 
void dp(){
	for(long long i=1;i<=x;i++){
		f[i][0]=max(f[i-1][1],f[i-1][0])+m[i];//转移无限制的 
		if(i>=y/*不判可能数组越界导致RE*/) f[i][1]=max(f[i-1][1],f[i-y][0]);//转移有限制的 
	}
}
void outn(){
	cout<<max(f[x][1],f[x][0])<<endl;//答案即为有限制和无限制之中的大者 
}
int main(){
	oin();
	csh();
	dp();
	outn();
	return 0;
}
//注：貌似不用long long 
```

---

## 作者：Starry_Ocean (赞：0)

### 思路与想法

看到这个题，首先想到暴力，枚举 $n-k+1$ 个端点，在往后枚举 $k$ 个位置，然后遍历这 $n$ 个元素。时间复杂度 $O(n^2)$。利用前缀和优化，时间复杂度为 $O(nk)$。显然不能够通过本题。考虑动态规划，记 $dp(i,j)$ 表示考虑前 $i$ 个位置，变化 $j$ 个位置，所能得到的最大 $\sum b_i$。空间复杂度为 $O(nk)$。还需要优化。定义 $dp(i,0/1)$ 表示当数组为 $dp(i,0)$ 时，不考虑任何限制下的最大 $\sum b_i$。可以得到以下状态转移方程：

$$
dp(i+1,0)=\max(dp(i,0),dp(i,1))+a_i
$$

$$

dp(i+1,1)=\max(dp(i,1),dp(i+1-k,0))
$$

---

## 作者：std_qwq (赞：0)

### 思路
如果我们在位置 $i$ 把它前面 $K$ 个位置，即区间 $[i-K+1,i]$ 上的整数变成 $0$，就会出现两种情况：一是这一段区间已经有一段被清零了，二是这一段还没有任何一部分被清零。

所以我们可以结合**位置**和**是否清零** dp。如果要清零的话就要考虑以上提及的两种情况。

设考虑前 $i$ 位置，第 $i$ 个位置是否清零所能抹去数字的**最小总和**为 $f_{i,j}$，其中 $j \in \left \{0,1  \right \} $。$j=0$ 表示不清零，$j=1$ 表示清零。

### 初始化
记 $a$ 数组的前缀和为 $s$。

因为到了 $K$ 位置才能进行清零，所以初始化：

$f_{K,0}=0,f_{K,1}=s_{K}$。
### 转移方程
考虑位置 $i$，

如果不清零，那么前一个可以清零也可以不清零：$f_{i,0}=\min (f_{i-1,1},f_{i-1,0})$。

如果清零，分别考虑上述两种情况：
1. 如果该段没有任何一个部分被清空过：$\min (f_{i-K,0},f_{i-K,1})$。
2. 如果某个位置被清空了，为了避免重复的计算，只考虑最接近 $i$ 位置的那个被清空的位置 $j$：$\min\limits_{j=i-K+1}^{i-1}  (f_{j,1}-s_{j})+s_{n}$。

注意到第二种情况的转移方程本质是求固定长度的区间最值，可以用单调队列优化计算。

因此我们用单调队列维护 $f_{i,1}-s_{i}$ 的最小值。

那么 $s_{n}- \min(f_{n,1},f_{n,0})$ 就是答案。
### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
typedef long long ll;
ll f[N][2];
typedef pair<int,ll> PIL;
PIL q[N];
#define x first
#define y second
int hh=0,tt=-1;
ll s[N];
int n,k;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){cin>>s[i];s[i]+=s[i-1];}
    f[k][0]=0,f[k][1]=s[k];
    q[++tt]={k,0};
    for(int i=k+1;i<=n;i++){
        f[i][0]=min(f[i-1][0],f[i-1][1]);
        if(hh<=tt&&q[hh].x<i-k+1)hh++;
        f[i][1]=s[i]+min(q[hh].y,min(f[i-k][0],f[i-k][1])-s[i-k]);
        while(hh<=tt&&q[tt].y>=f[i][1]-s[i])tt--;
        q[++tt]={i,f[i][1]-s[i]};
    }
    cout<<s[n]-min(f[n][0],f[n][1]);
}
```

---


# [ARC134B] Reserve or Reverse

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc134/tasks/arc134_b

長さ $ N $ の文字列 $ s $ が与えられます。 $ s $ の $ i $ 文字目は $ s_i $ と表します。

すぬけ君は以下の手順で $ s $ を変化させます。

- $ (1,2,\ \ldots,\ N) $ の長さが**偶数の**（連続するとは限らない）部分列 $ x=(x_1,\ x_2,\ \ldots,\ x_{2k}) $ を選ぶ($ k=0 $ でも構わない)。
- $ s_{x_1} $ と $ s_{x_{2k}} $ を入れ替える。
- $ s_{x_2} $ と $ s_{x_{2k-1}} $ を入れ替える。
- $ s_{x_3} $ と $ s_{x_{2k-2}} $ を入れ替える。
- $ \vdots $
- $ s_{x_{k}} $ と $ s_{x_{k+1}} $ を入れ替える。

すぬけ君が手順を終えたあとの $ s $ としてありうる文字列のうち、辞書順最小のものを求めてください。

 辞書順とは？ 辞書順とは簡単に説明すると「単語が辞書に載っている順番」を意味します。より厳密な説明として、相異なる文字列 $ S $ と文字列 $ T $ の大小を判定するアルゴリズムを以下に説明します。

以下では「 $ S $ の $ i $ 文字目の文字」を $ S_i $ のように表します。また、 $ S $ が $ T $ より辞書順で小さい場合は $ S\ \lt\ T $ 、大きい場合は $ S\ \gt\ T $ と表します。

1. $ S $ と $ T $ のうち長さが短い方の文字列の長さを $ L $ とします。$ i=1,2,\dots,L $ に対して $ S_i $ と $ T_i $ が一致するか調べます。
2. $ S_i\ \neq\ T_i $ である $ i $ が存在する場合、そのような $ i $ のうち最小のものを $ j $ とします。そして、$ S_j $ と $ T_j $ を比較して、 $ S_j $ がアルファベット順で $ T_j $ より小さい場合は $ S\ \lt\ T $ 、大きい場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。
3. $ S_i\ \neq\ T_i $ である $ i $ が存在しない場合、 $ S $ と $ T $ の長さを比較して、$ S $ が $ T $ より短い場合は $ S\ \lt\ T $ 、長い場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ s $ は長さ $ N $ の英小文字のみからなる文字列

### Sample Explanation 1

\- $ x=(1,3) $ のとき、$ s_{1} $ と $ s_{3} $ のみが入れ替わります。 - 手順を終えたあとの $ s $ は `acdb` となり辞書順最小です。

### Sample Explanation 2

\- $ x=() $ のとき、手順を終えたあとの $ s $ は `ab` となり辞書順最小です。 - $ x $ の長さが $ 0 $ でもよいことに注意してください。

## 样例 #1

### 输入

```
4
dcab```

### 输出

```
acdb```

## 样例 #2

### 输入

```
2
ab```

### 输出

```
ab```

## 样例 #3

### 输入

```
16
cabaaabbbabcbaba```

### 输出

```
aaaaaaabbbbcbbbc```

## 样例 #4

### 输入

```
17
snwfpfwipeusiwkzo```

### 输出

```
effwpnwipsusiwkzo```

# 题解

## 作者：loser_seele (赞：2)

首先为了使得答案字典序最小，应该优先保证前面的数最小，这点是显然的。

则题目给定的操作可以规约为以下形式：

初始令 $ l=0,r=N+1 $，然后对于 $ l<p<q<r $，交换 $ p,r $ 对应的元素，令 $ p,q $ 成为新的 $ l,r $。

于是可以贪心，如果一次交换操作令 $ s_1 $ 更小，则执行交换，为了使得后面的答案尽量小我们总是选择最大的值进行交换，以此类推。

实现上，对每种字母开一个数组，然后枚举比当前字母小的答案，如果还有未交换的字母就交换。因为每个字母最多被交换一次，这么做是 $ \mathcal{O}(n) $ 的，可以通过。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
signed main() 
{
	int n; 
	string s;
	cin>>n>>s; 
	n=s.size();
	vector<vector<int>> idx(26);
	vector<int> vis(n,0);
	for(int i=0;i<n;i++) 
	idx[s[i]-'a'].push_back(i);
	int last=n;
	for(int i=0;i<n;i++) 
	{
		if(vis[i]) 
		break;
		int cur=s[i]-'a';
		for(int j=0;j<cur;j++) 
		{
			while(!idx[j].empty() && idx[j].back()>=last)
				idx[j].pop_back();
			if(idx[j].empty()) 
			continue;
			int ii=idx[j].back();
			if(ii>i)
				swap(s[i],s[ii]);
			else
				continue;
			last=ii;
			vis[ii]=1; 
			break;
		}
	}
	cout<<s;
}
```


---

## 作者：mountain_climber (赞：0)

首先可以看出显然的贪心策略，对于每一个 $a_i$，考虑之后的下标最大的 $\min a_j,a_j<a_i$，如果存在这样的 $a_j$，我们显然需要交换 $a_i$ 和 $a_j$，因为我们每次都选择下标最大的最小值，下次选择 $a_{i+1}$ 的时候显然有最大的空间可以来选对应的 $a_j$。

最后选到不能再选就结束了，正确性是显然的，我们显然需要将小的数放在前面，最小的数显然需要放在最前面，然后在题目条件下缩小范围递推论证就可以了。

主要在于如何实现，首先可以想到 $O(n^2)$ 的暴力做法，之后注意到全都是小写字母，于是乎自然的想到统计每个字母出现的下标，这样每次只需要从小到大对于每个字母的下标集合删除超出部分、获得最大值，判断是否合法即可。因为每个数最多会被删一次，所以是时间复杂度是线性的，可以使用 $l,r$ 来代表当前区间的左右端点来方便删除超出部分。

[AC记录](https://atcoder.jp/contests/arc134/submissions/56379777)

---


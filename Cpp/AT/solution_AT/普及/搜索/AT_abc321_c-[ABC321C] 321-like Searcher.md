# [ABC321C] 321-like Searcher

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc321/tasks/abc321_c

以下の条件を満たす正整数 $ x $ を **321-like Number** と呼びます。 **この定義は A 問題と同様です。**

- $ x $ の各桁を上から見ると狭義単調減少になっている。
- すなわち、$ x $ が $ d $ 桁の整数だとすると、 $ 1\ \le\ i\ <\ d $ を満たす全ての整数 $ i $ について以下の条件を満たす。
  - ( $ x $ の上から $ i $ 桁目 ) $ > $ ( $ x $ の上から $ i+1 $ 桁目 )

なお、 $ 1 $ 桁の正整数は必ず 321-like Number であることに注意してください。

例えば、 $ 321,96410,1 $ は 321-like Number ですが、 $ 123,2109,86411 $ は 321-like Number ではありません。

$ K $ 番目に小さい 321-like Number を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K $
- 321-like Number は $ K $ 個以上存在する

### Sample Explanation 1

321-like Number は小さいものから順に $ (1,2,3,4,5,6,7,8,9,10,20,21,30,31,32,40,\dots) $ です。 このうち $ 15 $ 番目に小さいものは $ 32 $ です。

## 样例 #1

### 输入

```
15```

### 输出

```
32```

## 样例 #2

### 输入

```
321```

### 输出

```
9610```

## 样例 #3

### 输入

```
777```

### 输出

```
983210```

# 题解

## 作者：small_john (赞：7)

## 思路

~~打表是我的超人！~~

如你所见，这道题可以打表过，因为一共就只有 $1000$ 多个数。通过[第一题](/problem/at_abc321_a)，我们可以得到判断一个数的程序：

```cpp
bool chk(int x)
{
	int now = x%10;x/=10;//第一位
	while(x)
	{
		if(x%10<=now) return 0;//不是
		now = x%10,x/=10;
	}
	return 1;
}
```

那打表的程序不就出来了吗？

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
bool chk(int x)
{
	int now = x%10;x/=10;//第一位
	while(x)
	{
		if(x%10<=now) return 0;//不是
		now = x%10,x/=10;
	}
	return 1;
}
int now = 1; 
signed main()
{
	cout<<"a[1500] = {0";
	while(now<=9876543210ll)//最大是98765432190
	{
		if(chk(now)) cout<<","<<now;
		now++;
	}
	cout<<"};";
	return 0;
}
```

好吧，他 T 飞了。

经过分析，$10$ 位的满足条件的数只有 $9876543210$，所以优化了一下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
bool chk(int x)
{
	int now = x%10;x/=10;//第一位
	while(x)
	{
		if(x%10<=now) return 0;//不是
		now = x%10,x/=10;
	}
	return 1;
}
int now = 1; 
signed main()
{
	cout<<"a[1500] = {0,";
	while(now<=987654321ll)
	{
		if(chk(now)) cout<<now<<",";
		now++;
	}
	cout<<"9876543210ll};";
	return 0;
}
```

于是拿到了答案表。

输出对应的答案就行了。

献上只跑了一毫秒的代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

template<typename T> void read(T &x)
{
	x = 0;
	T f = 1;char ch = getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f = -1,ch = getchar();
			break;
		}
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
		x = (x<<3)+(x<<1)+ch-48,ch = getchar();
	x*=f;
}
template<typename T> T read()
{
	T x;read(x);return x;
}
template<typename T> void write(T x)
{
    if(x<0) x = -x,putchar('-');
    if(x<=9) return putchar(x+48),void();
    write(x/10);
    putchar(x%10+48);
}
template<typename T> void writen(T x)
{
    write(x);
    puts("");
}
long long a[1500] = {0,1,2,3,4,5,6,7,8,9,10,20,21,30,31,32,40,41,42,43,50,51,52,53,54,60,61,62,63,64,65,70,71,72,73,74,75,76,80,81,82,83,84,85,86,87,90,91,92,93,94,95,96,97,98,210,310,320,321,410,420,421,430,431,432,510,520,521,530,531,532,540,541,542,543,610,620,621,630,631,632,640,641,642,643,650,651,652,653,654,710,720,721,730,731,732,740,741,742,743,750,751,752,753,754,760,761,762,763,764,765,810,820,821,830,831,832,840,841,842,843,850,851,852,853,854,860,861,862,863,864,865,870,871,872,873,874,875,876,910,920,921,930,931,932,940,941,942,943,950,951,952,953,954,960,961,962,963,964,965,970,971,972,973,974,975,976,980,981,982,983,984,985,986,987,3210,4210,4310,4320,4321,5210,5310,5320,5321,5410,5420,5421,5430,5431,5432,6210,6310,6320,6321,6410,6420,6421,6430,6431,6432,6510,6520,6521,6530,6531,6532,6540,6541,6542,6543,7210,7310,7320,7321,7410,7420,7421,7430,7431,7432,7510,7520,7521,7530,7531,7532,7540,7541,7542,7543,7610,7620,7621,7630,7631,7632,7640,7641,7642,7643,7650,7651,7652,7653,7654,8210,8310,8320,8321,8410,8420,8421,8430,8431,8432,8510,8520,8521,8530,8531,8532,8540,8541,8542,8543,8610,8620,8621,8630,8631,8632,8640,8641,8642,8643,8650,8651,8652,8653,8654,8710,8720,8721,8730,8731,8732,8740,8741,8742,8743,8750,8751,8752,8753,8754,8760,8761,8762,8763,8764,8765,9210,9310,9320,9321,9410,9420,9421,9430,9431,9432,9510,9520,9521,9530,9531,9532,9540,9541,9542,9543,9610,9620,9621,9630,9631,9632,9640,9641,9642,9643,9650,9651,9652,9653,9654,9710,9720,9721,9730,9731,9732,9740,9741,9742,9743,9750,9751,9752,9753,9754,9760,9761,9762,9763,9764,9765,9810,9820,9821,9830,9831,9832,9840,9841,9842,9843,9850,9851,9852,9853,9854,9860,9861,9862,9863,9864,9865,9870,9871,9872,9873,9874,9875,9876,43210,53210,54210,54310,54320,54321,63210,64210,64310,64320,64321,65210,65310,65320,65321,65410,65420,65421,65430,65431,65432,73210,74210,74310,74320,74321,75210,75310,75320,75321,75410,75420,75421,75430,75431,75432,76210,76310,76320,76321,76410,76420,76421,76430,76431,76432,76510,76520,76521,76530,76531,76532,76540,76541,76542,76543,83210,84210,84310,84320,84321,85210,85310,85320,85321,85410,85420,85421,85430,85431,85432,86210,86310,86320,86321,86410,86420,86421,86430,86431,86432,86510,86520,86521,86530,86531,86532,86540,86541,86542,86543,87210,87310,87320,87321,87410,87420,87421,87430,87431,87432,87510,87520,87521,87530,87531,87532,87540,87541,87542,87543,87610,87620,87621,87630,87631,87632,87640,87641,87642,87643,87650,87651,87652,87653,87654,93210,94210,94310,94320,94321,95210,95310,95320,95321,95410,95420,95421,95430,95431,95432,96210,96310,96320,96321,96410,96420,96421,96430,96431,96432,96510,96520,96521,96530,96531,96532,96540,96541,96542,96543,97210,97310,97320,97321,97410,97420,97421,97430,97431,97432,97510,97520,97521,97530,97531,97532,97540,97541,97542,97543,97610,97620,97621,97630,97631,97632,97640,97641,97642,97643,97650,97651,97652,97653,97654,98210,98310,98320,98321,98410,98420,98421,98430,98431,98432,98510,98520,98521,98530,98531,98532,98540,98541,98542,98543,98610,98620,98621,98630,98631,98632,98640,98641,98642,98643,98650,98651,98652,98653,98654,98710,98720,98721,98730,98731,98732,98740,98741,98742,98743,98750,98751,98752,98753,98754,98760,98761,98762,98763,98764,98765,543210,643210,653210,654210,654310,654320,654321,743210,753210,754210,754310,754320,754321,763210,764210,764310,764320,764321,765210,765310,765320,765321,765410,765420,765421,765430,765431,765432,843210,853210,854210,854310,854320,854321,863210,864210,864310,864320,864321,865210,865310,865320,865321,865410,865420,865421,865430,865431,865432,873210,874210,874310,874320,874321,875210,875310,875320,875321,875410,875420,875421,875430,875431,875432,876210,876310,876320,876321,876410,876420,876421,876430,876431,876432,876510,876520,876521,876530,876531,876532,876540,876541,876542,876543,943210,953210,954210,954310,954320,954321,963210,964210,964310,964320,964321,965210,965310,965320,965321,965410,965420,965421,965430,965431,965432,973210,974210,974310,974320,974321,975210,975310,975320,975321,975410,975420,975421,975430,975431,975432,976210,976310,976320,976321,976410,976420,976421,976430,976431,976432,976510,976520,976521,976530,976531,976532,976540,976541,976542,976543,983210,984210,984310,984320,984321,985210,985310,985320,985321,985410,985420,985421,985430,985431,985432,986210,986310,986320,986321,986410,986420,986421,986430,986431,986432,986510,986520,986521,986530,986531,986532,986540,986541,986542,986543,987210,987310,987320,987321,987410,987420,987421,987430,987431,987432,987510,987520,987521,987530,987531,987532,987540,987541,987542,987543,987610,987620,987621,987630,987631,987632,987640,987641,987642,987643,987650,987651,987652,987653,987654,6543210,7543210,7643210,7653210,7654210,7654310,7654320,7654321,8543210,8643210,8653210,8654210,8654310,8654320,8654321,8743210,8753210,8754210,8754310,8754320,8754321,8763210,8764210,8764310,8764320,8764321,8765210,8765310,8765320,8765321,8765410,8765420,8765421,8765430,8765431,8765432,9543210,9643210,9653210,9654210,9654310,9654320,9654321,9743210,9753210,9754210,9754310,9754320,9754321,9763210,9764210,9764310,9764320,9764321,9765210,9765310,9765320,9765321,9765410,9765420,9765421,9765430,9765431,9765432,9843210,9853210,9854210,9854310,9854320,9854321,9863210,9864210,9864310,9864320,9864321,9865210,9865310,9865320,9865321,9865410,9865420,9865421,9865430,9865431,9865432,9873210,9874210,9874310,9874320,9874321,9875210,9875310,9875320,9875321,9875410,9875420,9875421,9875430,9875431,9875432,9876210,9876310,9876320,9876321,9876410,9876420,9876421,9876430,9876431,9876432,9876510,9876520,9876521,9876530,9876531,9876532,9876540,9876541,9876542,9876543,76543210,86543210,87543210,87643210,87653210,87654210,87654310,87654320,87654321,96543210,97543210,97643210,97653210,97654210,97654310,97654320,97654321,98543210,98643210,98653210,98654210,98654310,98654320,98654321,98743210,98753210,98754210,98754310,98754320,98754321,98763210,98764210,98764310,98764320,98764321,98765210,98765310,98765320,98765321,98765410,98765420,98765421,98765430,98765431,98765432,876543210,976543210,986543210,987543210,987643210,987653210,987654210,987654310,987654320,987654321,9876543210ll};
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	write(a[read<int>()]);
	return 0;
}
```

~~也就六七个 K，超简单的说。~~

---

## 作者：kimidonatsu (赞：5)

# AT_abc321_c \[ABC321C\] 321-like Searcher 题解

发现大多数题解都需要使用排序，这里我们引入暴力枚举所有情况而不排序的做法。

```cpp
#include <bits/stdc++.h>

void solve() {
    int K;
    std::cin >> K;
    K -= 1;
    std::vector<std::string> ans(9);
    for (int i = 0; i < 9; i++) {
        ans[i] = std::to_string(i + 1);
    }
    for (int i = 0; i < K; i++) {
        int lastDigit = ans[i].back() - '0';
        for (int v = 0; v < lastDigit; v++) {
            ans.push_back(ans[i] + std::to_string(v));
        }
    }
    std::cout << ans[K] << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);

    solve();
    return 0;
}

```

可以发现 $ans$ 数组中包含按升序排列的 321-like Number，所以最后我们的答案就是 $ans_k$。


---

## 作者：_sunkuangzheng_ (赞：3)

**【题目分析】**

看到第 $k$ 小想到二分，那么考虑怎么 check 答案。我们要做的是求 $x$ 以内有几个严格下降的数字，那么数位 dp 即可。设 $f_{pos,lst,lim,pre}$ 表示第 $pos$ 位，上一位是 $lst$，是否顶上界状态是 $lim$，前导零状态是 $pre$ 的方案数，记忆化搜索转移。

**【代码】**


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t,l,r,n,num[25],f[30][30][2][2],k;
int dfs(int pos,int lst,bool lim,bool pre){
	if(f[pos][lst][lim][pre] != -1) return f[pos][lst][lim][pre];
	if(pos == 1) return !pre;
	int up = lim ? num[pos-1]:9;
	int ans = 0;
	for(int i = 0;i <= up;i ++) {
	    if(i < lst || (i == 0 && pre)) ans += dfs(pos-1,((i == 0 && pre) ? 10 : i),(lim && i == up),(i == 0 && pre));
	}
	return f[pos][lst][lim][pre] = ans;
}
int work(int x){
	memset(f,-1,sizeof(f));
	int pos = 0;
	while(x) num[++pos] = x % 10,x /= 10;
	n = pos;
	return dfs(n+1,10,1,1);
}
signed main(){
    cin >> k;
    int l = 1,r = 1e10,ans = 0;
    while(l <= r){
        int mid = (l + r) / 2;
        if(work(mid) >= k) r = mid - 1,ans = mid; else l = mid + 1;
    }cout << ans;
	return 0;
}
```

---

## 作者：Coffee_zzz (赞：2)

打表。

首先把 A 的代码套个循环粘过来，预处理出 $[1,98765432] $ 以内的 321 数。

再往大，容易算出九位数中只有 $876543210,976543210,986543210,\cdots,987654321$ 是 321 数，十位数只有 $9876543210$ 是 321 数，再往大没有 321 数了，所以把这些数从大到小手动加到表里，每次查询直接输出对应位置的数即可。

---

## 作者：Yun_Mengxi (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/AT_abc321_c)

## 题意

设 $321$ 数为一个数的各位满足严格单调递减，例如，$321$ 是个 $321$ 数，而 $123$ 不是。给定 $k$，求第 $k$ 个 $321$ 数。

## 分析

显然的，$321$ 数的个数肯定是有限的，其中，最大的 $321$ 数为 $9876543210$，所以，可以直接深搜枚举每个 $321$ 数。

## 代码

```cpp
#include <bits/stdc++.h>

#define IOS ios::sync_with_stdio(0);\
	cin.tie(0), cout.tie(0)

using namespace std;

typedef long long ll;

int k, s;
vector<ll> tto;

void dfs(ll num) {      // 预处理 321 数
	if (num == 0) {
		for (int i = 9; i >= 1; i--) {  // 从哪一位开始
			dfs(i);
		}
	}
	for (int i = num % 10 - 1; i >= 0; i--) {  // 剪枝
		dfs(num * 10 + i);
	}
	tto.push_back(num);       // 记录 321 数
}

signed main() {
	cin >> k;
	dfs(0);
	sort(tto.begin(), tto.end());  // 排一下序，因为处理出来的 321 数不一定是有序的
	cout << tto[k] << '\n';
	return 0;
}
```

---

## 作者：Submerge_TA (赞：2)

通过枚举，我们发现只有 $1022$ 个满足要求的数字，所以我们可以暴力枚举。

我们定义一个变量 $s$ 用于统计满足条件的数字的个数，从一位数依次枚举至九位数，找到满足条件的数字，如果已经是第 $n$ 个满足条件的数字了，就输出这个数字并结束程序。

[AC 代码](https://www.luogu.com.cn/paste/wv0e41ev)

---

## 作者：Imken (赞：1)

可以用一个类似高精度的写法跳过很多不必要的枚举。进位条件是 ${\rm number}_ i \ge 10 \operatorname{or} {\rm number} _{i} \ge {\rm number}_ {i + 1}$。

但是需要注意的是，高精度加法的过程可能会出现类似 $10000$ 这种低位重复的东西。所以说这里暴力地 check 一下，如果出现这种低位重复的就一直加一直到满足要求。

时间复杂度 $O(\text{能过})$ 还跑挺快。

Code:

```
int k;
char s[1000005];
int len = 1;

inline void jw()
{
	int p = 1;
	while ((s[p + 1] != -1 && s[p] >= s[p + 1]) || s[p] >= 10) {
		s[p] = 0;
		if (s[p + 1] == -1)
			s[p + 1] = 0;
		s[p + 1] += 1;
		p++;
	}
	len = max(len, p);
}

inline bool check()
{
	for (int i = 1; i < len; i++)
		if (s[i] >= s[i + 1])
			return 1;
	return 0;
}

int main()
{
	cin >> k;
	fill(s, s + 114514 + 1, -1);
	s[1] = 0;
	for (int i = 1; i <= k; i++) {
		s[1]++;
		jw();
		while (check())
			s[1]++, jw();
	}
	for (int i = len; i >= 1; i--)
		cout << (int)s[i];
	return 0;
}
```

---

## 作者：白简 (赞：1)

早上来机房看犇犇全是写这题题解的，跟风写一篇。

---
题目没有给出 $K$ 的上界，考虑有多少种符合性质的数。

显然，符合性质的最大数是 $9876543210$，可以直接 DFS 枚举数位把所有情况存下来。

然后排一遍序就可以了，注意 $0$ 不算。

[Submission](https://atcoder.jp/contests/abc321/submissions/45843395)

---

## 作者：jijidawang (赞：1)

大家都在写这题题解，那我也写个吧。

可以发现一个数是 321-like number 当且仅当它是 9876543210 的子序列，所以至多有 $2^{10}$ 个，暴力搜索找出所有 321-like number 即可。

考虑 DFS，从一位数开始扩展，每次从小到大加入一个比它末尾小的数位，可以发现这样是天然保序的。

[Submission](https://atcoder.jp/contests/abc321/submissions/45854423)。

---

## 作者：iCostalymh (赞：1)

本题方法不唯一，乱搞的有不少。

最直接的想法就是枚举 + 验证，但是那样会寄掉后面五个点（不管是 WA 还是 TLE）。

然后有人就拿暴力水过了，，，

我们发现，一个符合条件的数取任意的连续前几位也是符合条件的。

所以就可以递推。边界就是一位的正整数。

跑一遍 bfs 再排序就可以了。

[我的提交记录](https://atcoder.jp/contests/abc321/submissions/45865816)

---

## 作者：hjqhs (赞：1)

bfs 预处理出所有 321 数，然后排序后输出第 $k$ 个即可。
bfs 部分：
```cpp
void bfs(){
  queue<int>q;
  rep(i,1,9)q.push(i);
  while(!q.empty()){
    int d=q.front();q.pop();K[++tot]=d;
    // cout<<d<<' ';
    int cur=d%10;
    rep(i,0,cur-1){
      q.push(d*10+i);
    }
  }
}
```

---

## 作者：cjh20090318 (赞：1)

## 题意

给定一个 $k$，你需要找到第 $k$ 小的满足下面条件的正整数：

- 对于这个数的每一位，高位大于低位。

## 分析

这个数据范围仅有一个 $1 \le k$，让人很不好下手。

我们不妨先做一个 DP，看有多少个满足这样条件的数。

设 $f_{i,j}$ 表示有 $i$ 位，且最高位为 $j$ 时这类数的个数。

可以很容易的写出下面这份代码：

```cpp
typedef long long LL;
const int n=10;
int k;
LL f[11][10];
void test(){
	for(int i=0;i<n;i++)f[1][i]=1;
	for(int i=2;i<=n;i++){
		for(int j=i-1;j<=n;j++) f[i][j]=f[i][j-1]+f[i-1][j-1];
	}
	LL s=0;
	for(int i=1;i<=n;i++){
		for(int j=i-1;j<n;j++) printf("%lld\t",f[i][j]),s+=f[i][j];
		putchar('\n');
	}
	printf("%lld\n",s-f[0][0]);//注意是正整数，0 不符合要求。
}
```

可以发现这类数总共只有 $1023$ 个，所以直接朴素枚举下一个就可以解决了。

## 注意事项

最大满足要求的数为 $9876543210 > 2^{31}-1$，所以需要 `long long` 存储答案。

## 代码

```cpp
//the code is from chenjh
#include<cstdio>
#include<cmath>
#include<algorithm>
typedef long long LL;
const int n=10;
int k;
LL nx(LL x){
	int w=(int)log10(x)+1;//获取位数。
	if(w==1) return x+1;//一位数直接跳过。
	int a[20],c=0;
	for(LL t=x;t;a[++c]=t%10,t/=10);//分解成各数位。
	++a[1];//将最低为增加。
	for(int i=1;i<c;i++)if(a[i]>=a[i+1]) a[i]=i-1,++a[i+1];//如果不满足要求，将当前位设成当前位的理论最小值。
	if(a[c]>9){//需要进位则进位。
		++c;
		for(int i=1;i<=c;i++) a[i]=i-1;
	}
	LL r=0,s=1;
	for(int i=1;i<=c;i++) r+=s*a[i],s*=10;//还原新的数。
	return r;
}
int main(){
	scanf("%d",&k);
	LL ans=1;
	for(int i=1;i<k;i++) ans=nx(ans);//枚举下一个。
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：lrx___ (赞：1)

[题目](https://www.luogu.com.cn/problem/AT_abc321_c)

**题意简述**

如果一个数每个数位上的数依次严格递减，那么它就是 **321型数**。例如，$321,96410,1$ 都是 **321型数**，而 $123,2109,86411$ 都不是。

求出第 $k$ 小的 **321型数**。

**思路**

因为 **321型数** 最大为 $9876543210$，所以我们可以枚举每个 **321型数**，保存起来，最后输出第 $k$ 小的即可。

用字符串的形式存储数，递归搜索数位，函数如下：

```cpp
typedef unsigned long long ll;
typedef string str;
vector<str>v;
/* 用来保存321型数 */

void dfs(int ln,str x){
	/* ln代表数的长度，x代表已经搜到的字符串 */
	if(x.size()==(ll)ln){
		/* 长度达到了 */
		v.push_back(x);return;
	}
	char i,j;
	/* i为枚举的下一位，j为边界。
	   如果x为空，那么最大为9，否则最大为x的最后一位减1 
	*/
	if(x.size()){
		j=x[x.size()-1];
	}else{
		j='9'+1;
	}
	for(i='0';i<j;i++){
		x.push_back(i);
		dfs(ln,x);
		/* 搜索下一位 */
		x.pop_back();
		/* 回溯 */
	}
}
```

枚举每个长度，依次搜索。

```cpp
for(i=1;i<=10;i++){
	/* 枚举每个长度 */
	dfs(i,"");
}
```

由于这样搜索会搜索到数 $0$，而 $0$ 不是 **321型数**，所以下标应从 $1$ 开始，可以直接输出下标为 $k$ 的数。

```cpp
scanf("%d",&k);
printf("%s\n",v[k].data());
/* string.data() 返回的是字符串的字符数组形式，这样就可以用printf输出了 */
```

**完整代码**

```cpp
#include<cstdio>
#include<string>
#include<vector>
using namespace std;
typedef unsigned long long ll;
typedef string str;
vector<str>v;
void dfs(int ln,str x){
	if(x.size()==(ll)ln){
		v.push_back(x);return;
	}
	char i,j;
	if(x.size()){
		j=x[x.size()-1];
	}else{
		j='9'+1;
	}
	for(i='0';i<j;i++){
		x.push_back(i);
		dfs(ln,x);
		x.pop_back();
	}
}
int main(){
	int i,k;
	for(i=1;i<=10;i++){
		dfs(i,"");
	}
	scanf("%d",&k);
	printf("%s\n",v[k].data());
	return 0;
}
```

---

## 作者：timmark (赞：1)

# ABC 321C 题解
一道有一定数学思想的题。

首先我们要明确“$321$-like”数的本质，这样抓住了问题的本质，其他一切则会迎刃而解。

我们发现，所谓的“$321$-like”数其实就是从高位到低位**严格递减**的数，而数字只有 $10$ 个，显然最大的“$321$-like”数是 $9876543210$。

我们发现这一类数是有限的，搜索可以发现只有 $1023$ 个。

为什么呢？

我们发现，一串数如果要按固定的大小顺序排列，其实就相当于顺序无关（这是）。

那么，$n$ 位的“$321$-like”数就有 $C_{10}^{n}$ 个（相当于在 $10$ 个数字中挑 $n$ 个按从大到小排列），总共有 $\sum \limits_{i=0}^{10} C_{10}^{i}-1=1023$ 个（因为 $0$ 不是“$321$-like”数）。

那么我们先使用 dfs 处理出所有的“$321$-like”数，然后输出即可。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,a[15];
long long ans[1050];
void dfs(int step,int m){
	if(step==m){
		long long num=0;
		for(int i=1;i<=m;i++) num=num*10+a[i];
		ans[++cnt]=num;
		return ;
	}for(int i=a[step]-1;i>=m-step-1;i--){
		a[step+1]=i;
		dfs(step+1,m);
	}
}int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	a[0]=10;//第一位最多为 9，9=10-1
	for(int i=1;i<11;i++) dfs(0,i);
	sort(ans+1,ans+cnt+1);//搜出来不是有序的，要 sort
	cin >> n ;
	cout << ans[n+1] ;//第一个是 0，要 +1
	return 0;
}
```

---

## 作者：Crazyouth (赞：0)

**翻译**

定义 「$321$-数」是从最高位到最低位依次严格递减的数，求第 $k$ 个这样的数。

**分析**

直接 dfs。由于这样的数可以通过每次乘十再加上一个小于原本的个位的数组成，所以先跑一次 dfs，把所有这样的数丢到数组里（因为总数量其实特别少，经计算，只有 $1022$ 个），然后排序数组，再输出第 $k$ 个。~~其实我觉得这题可以搞个多测的。~~

**AC Code**
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[10010],idx;
void dfs(long long k)
{
	a[++idx]=k;
	for(int i=0;i<k%10;i++) dfs(k*10+i);
}
int main()
{
	for(long long i=1;i<=9;i++) dfs(i);
	sort(a+1,a+idx+1);
	int n;
	cin>>n;
	cout<<a[n];
}

---

## 作者：szhqwq (赞：0)

## $\tt{Solution}$

因为最大的满足题目条件的数为 $9876543210$，所以考虑进行暴力搜索。

传入一个参数，即为当前的搜索到的满足题目条件的数字。每次转移时，枚举严格比当前数最后一位还要小的数字，加在原数末尾，在搜索时存下来，因为这些数字一定满足从小到大的顺序，从小到大排序后输出第 $K$ 个即可。

[Link](https://atcoder.jp/contests/abc321/submissions/45857716)

---

## 作者：Keroshi (赞：0)

提供一个较为简单的方法。  
题意中的 321-like 数即为每位从左到右依次递减的数。   
那么每个 321-like 数可以理解为字符串 $9876543210$ 的字串，这样能保证数能递减，   
那么每一位要么选，要么不选，除去 $0$，一共就 $2^{10}-1$ 个这类的数。   
直接枚举所有的数，排个序，输出即可。  
```cpp
void solve() {
	int k;
	cin >> k;
	vector<ll> a;
	REP(i, 1 << 10) {
		ll res = 0;
		ROF(j, 9, 0) {
			if(i >> j & 1) {
				res = res * 10 + j;
			}
		}
		a.push_back(res);
	}
	sort(ALL(a));
	cout << a[k + 1] << endl;
}
```

---

## 作者：FreedomKing (赞：0)

### 题目大意

有一个升序数字序列，满足对于每个元素它的每一位都严格小于更高位，求这个序列的第 $k$ 项。

### 思路

由于答案数量非常少，直接考虑深搜每种最高位为 $i$ 的情况，记录它的每个前缀，排序输出即可。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int a[N],f[N],n,m,t,k;
vector<int>ans;
string s;
void dfs(int x,int last){
	ans.push_back(x);//记录前缀
	for(int i=0;i<last;i++) dfs((x<<3)+(x<<1)+i,i);//搜索下一位
}
signed main(){
	cin>>k;
	for(int i=1;i<=9;i++) dfs(i,i);
	sort(ans.begin(),ans.end());//排序
	cout<<ans[k-1];
	return 0;
}
```

---

## 作者：HEzzz (赞：0)

[题目跳转键](https://www.luogu.com.cn/problem/AT_abc321_c)

---

### 分析

时间限制是两秒，所以我们可以打表。而且要想是 **321-like Number**，那么最大就只是九位数了。

### 方法

因为最大数位数就只有九位数，我们可以采取二进制枚举，枚举的位数为九位，$0$ 代表这一位我们不采用，$1$ 代表这一位计入我们要求的答案中。然后将这个情况分解出来，变成一个数的形式。这个数必定是 **321-like Number**，然后我们计入答案数组，最后排序我们的数组，输出数组的第 $n$ 项即可。

### code

```cpp
#include<bits/stdc++.h> 
#define _rep(i,a,b) for(int i=(a);i<=(b);i++)
#define _antirep(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long lxl; 
const int mod=1e9+7,N=1e2+5;  
int n;
vector<lxl>ans;
int main()
{ 
    for(int i=2;i<(1<<10);i++)//二进制枚举
    {
    	lxl x=0;
    	_antirep(j,9,0)//分解出来
 			if(i&(1<<j)) x=x*10+j;//变成数的形式 
 		ans.push_back(x);//计入数组中
 	}
 	sort(ans.begin(),ans.end());//记得要排序
	cin>>n;
	cout<<ans[n-1]; 
 	return 0;
}
```


---

## 作者：xiaoming007 (赞：0)

考虑 dfs 搜出所有的 $\text{321}$ 数，发现只有 $1022$ 个数，于是直接搜完排序，得出第 $k$ 值。

至于如何搜，可以用一个小于末尾数字的数字去填，然后一直存储当前答案。

[代码](https://atcoder.jp/contests/abc321/submissions/45843474)。

---

## 作者：无钩七不改名 (赞：0)

数位 dp。

设 $dp_{i,j}$ 表示一共有 $i$ 位，且最高位为 $j$ 的 321-like Number 的数量，$f_i$ 表示 $i$ 位 321-like Number 的数量。则根据定义可得：

$$dp_{0,0}=1$$
$$dp_{i,j}=\sum_{0\le k\leq j-1}dp_{i-1,k}$$
$$f_i=\sum dp_{i,j}$$

然后就可以进行匹配了，从位数少向位数多比较确定位数，然后再从高位向低位、每一位从小到大匹配数字。

细节比较多，具体的看代码。

### 赛时代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1005;

int n;
long long dp[11][10];//第 i 位为 j 的 321 数有多少个。 
long long f[11];
int a[N],cnt;

int read(){
	int f=1,k=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=k*10+c-'0';
		c=getchar();
	}
	return f*k;
}

int main(){
	n=read();
	if(n<=10)return printf("%d",n),0;
	for(int i(0);i<=9;++i)dp[1][i]=1;
	f[1]=9;
	for(int i(2);i<=10;++i){
		for(int j(i-1);j<=9;++j){
			for(int z(0);z<j;++z)
				dp[i][j]+=dp[i-1][z];
			f[i]+=dp[i][j];
		}
	}
	//cout<<f[3]<<'\n';
	for(int i(1);i<=10;++i){
		//cout<<i<<": "<<f[i]<<" "<<n<<'\n';
		if(f[i]<n){
			n-=f[i];
			continue;
		}
		cnt=i;a[cnt+1]=10;
		//cout<<n<<" "<<cnt<<'\n';
		for(int j(cnt);j;--j){
			for(int z(0);z<a[j+1];++z){
				//cout<<j<<" "<<z<<" "<<dp[j][z]<<" "<<n<<'\n';
				if(dp[j][z]>=n){
					a[j]=z;
					break;
				}
				n-=dp[j][z];
			}
		}
		break;
	}
	for(int i(cnt);i;--i)printf("%d",a[i]);
	return 0;
}
```


---

## 作者：zibenlun (赞：0)

# 题目大意
A 题
[链接](https://atcoder.jp/contests/abc321/tasks/abc321_a)

C 题
[链接](https://atcoder.jp/contests/abc321/tasks/abc321_c)

在本比赛 A 题的基础上，查找第 $n$ 个符合要求的数。

# 模拟

根据题目我们可以找到一个暴力方法就是从头开始枚举，直到找到 $n$ 个（这样肯定会超时）。

例如 $977654321$ 这个数一定是不符合要求的，但是此时如果从个位一点点加起会稍好很多时间。所以可以看到在这个数的第二位开始就已经能判断出它不符合要求，所以我们可以用一个数组按位存储要判断的数，然后找到第一个不合法的位数，从那一位开始修改。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	int cnt=1;
	a[1]=1;
	int sum=0;
	while(sum<n){
		int flag=0;
		for(int i=1;i<cnt;i++){
			if(a[i]>=a[i+1]) {
				flag=i;
				break;
			}
		}
		if(flag) {
			a[flag]++;
			for(int i=1;i<flag;i++) a[i]=0;
			while(a[flag]>=10) {
				a[flag]-=10;
				a[++flag]++;
				cnt=max(cnt,flag);
			}
			continue;
		}
		else {
			sum++;
			if(sum==n) break;
			flag=1;
			a[1]++;
			while(a[flag]>=10) {
				a[flag]-=10;
				a[++flag]++;
				cnt=max(cnt,flag);
			}
		}
	}
	for(int i=cnt;i>=1;i--) cout<<a[i];
	return 0;
}
```

# AC截图
![](https://cdn.luogu.com.cn/upload/image_hosting/meeah5l9.png)

---

## 作者：lwx20211103 (赞：0)

## 题目大意

有一种的数字，这个数字的特点是：数位从左到右上的数字都是严格递减的。例子： $321,96410,1$ 都是这种数, $123,2109,86411$ 不是。

要你求第 $k$ 小的这种数字。$k$ 的范围没有给，但我实测数字的范围在 `long long` 之内。

## 解法

首先这种一般是预处理，与处理完了之后呢？

可以考虑递归构造数字。

要求构造的下一个数字，下一位数不超过当前数字的末位。

比如当前数字是 $876$，那么下一步考虑构造的四位数字，末尾都不超过 $6$。设这些数字是 $i(0 \leq i \leq 5)$，那么新构成的数字就是 $876 \times 10 + i$。

显而易见，构造程序就出来了。

```cpp
void solve(int len, ll now)//len:最后一个数字的范围,now:当前数字
{
	if (now >= 1145141919810) return ;//范围
	vec.p_b(now);//p_b 代替 push_back(),加入数组
	for (int i = 0; i < len; i++)
		solve(i, now * 10 + i);
}
```
这里有一个要注意的细节，调用函数的时候要 `solve(10,0)`，因为数字从 $0$ 开始构造。能不能把循环的范围变成 `i <= len` ，然后调用是 `solve(9,0)`？不可以。因为这样会因为 $0 \leq 0$ 无限循环下去。

对了，处理的时候会加入两次 $0$，一次是在主函数调用的时候，一次是第一次递归的时候。而 $0$ 不算数。

## 代码
```cpp
#include <bits/stdc++.h>
#define p_b push_back
#define ft first
#define nd second
#define pii pair<int, int>
#define pll pair<long long, long long>

using namespace std;

typedef long long ll;

vector<ll> vec;

void solve(int len, ll now)
{
	if (now >= 1145141919810) return ;
	vec.p_b(now);
	for (int i = 0; i < len; i++)
		solve(i, now * 10 + i);
}

int main()
{
	solve(10, 0);
	sort(vec.begin(), vec.end());
	ll k;
	cin >> k;
	cout << vec[k + 1];//k - 1 + 2 因为两个 0
	return 0;
}

```


---

## 作者：Liuhy2996 (赞：0)

## 思路
首先，“321数”最多十位，而通过枚举得知，八位以上的“321数”非常少，只有十个。所以可以暴力枚举八位以内的“321数”，剩下的直接赋值。
## 代码
```
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
long long b[11] = {876543210, 976543210, 986543210,
987543210, 987643210, 987653210,
987654210, 987654310, 987654320,
987654321, 9876543210}; //大于8位的“321”数
bool is_321(int a){ //判断是否是“321”数
	int l, r;
	r = a % 10;
	a = a / 10;
	while(a > 0){
	    l = a % 10;
	    if(l <= r) return false;
	    a = a / 10;
	    r = l;
	}
	return true;
}
int main(){
	int k;
	cin >> k;
	for(int i = 1; i <= 98765432; ++i){ //从最小的“321”数枚举到最大的 8 位“321”数
	    if(is_321(i)) --k;
	    if(k == 0){
                cout << i << endl;
		return 0;
       	    }
	}
	cout << b[k - 1] << endl;
	return 0; 
}
```

---

## 作者：Hanzelic (赞：0)

## [题目链接](https://www.luogu.com.cn/problem/AT_abc321_c)
一开始想了很多办法，最后发现只要最简单的爆搜就行了。。

我们~~通过打表~~可以发现最大的符合条件的数只有一千多个，最大的数为 $9876543210$，那么我们可以考虑通过 dfs 来枚举每一位的数字。最后存一下排个序直接 $O(1)$ 输出即可。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define M 100005
int n,m,a,b,c,k,sum,to,tl,cnt,now,S;
int dp[105][10],num[M],nn[105];
void dfs(int len,int last){
    if(len==10){
        for(int q=last+1;q<=9;q++){
            int sum=q;
            for(int i=len-1;i;i--){
                sum=sum*10+nn[i];
            }
            num[++cnt]=sum;
        }
        return;
    }
    else{
        for(int q=last+1;q<=9;q++){
            nn[len]=q;
            dfs(len+1,q);
            int sum=q;
            for(int i=len-1;i;i--){
                sum=sum*10+nn[i];
            }
            num[++cnt]=sum;
            num[++cnt]=sum*10;
        }
    }
}
signed main(){
    dfs(1,0);
    sort(num+1,num+cnt+1);
    cin>>k;
    cout<<num[k]<<endl;
    return 0;
}
```


---


# [ABC163D] Sum of Large Numbers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc163/tasks/abc163_d

$ 10^{100} $, $ 10^{100}+1 $, ..., $ 10^{100}+N $ の $ N+1 $ 個の数があります。

この中から $ K $ 個以上の数を選ぶとき、その和としてあり得るものの個数を $ \bmod\ (10^9+7) $ で求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N+1 $
- 入力は全て整数

### Sample Explanation 1

以下の $ 10 $ 通りが考えられます。 - $ (10^{100})+(10^{100}+1)=2\times\ 10^{100}+1 $ - $ (10^{100})+(10^{100}+2)=2\times\ 10^{100}+2 $ - $ (10^{100})+(10^{100}+3)=(10^{100}+1)+(10^{100}+2)=2\times\ 10^{100}+3 $ - $ (10^{100}+1)+(10^{100}+3)=2\times\ 10^{100}+4 $ - $ (10^{100}+2)+(10^{100}+3)=2\times\ 10^{100}+5 $ - $ (10^{100})+(10^{100}+1)+(10^{100}+2)=3\times\ 10^{100}+3 $ - $ (10^{100})+(10^{100}+1)+(10^{100}+3)=3\times\ 10^{100}+4 $ - $ (10^{100})+(10^{100}+2)+(10^{100}+3)=3\times\ 10^{100}+5 $ - $ (10^{100}+1)+(10^{100}+2)+(10^{100}+3)=3\times\ 10^{100}+6 $ - $ (10^{100})+(10^{100}+1)+(10^{100}+2)+(10^{100}+3)=4\times\ 10^{100}+6 $

### Sample Explanation 2

全てを選ぶしかないので $ 1 $ 通りです。

## 样例 #1

### 输入

```
3 2```

### 输出

```
10```

## 样例 #2

### 输入

```
200000 200001```

### 输出

```
1```

## 样例 #3

### 输入

```
141421 35623```

### 输出

```
220280457```

# 题解

## 作者：Zachary_Cloud (赞：6)

## $Sol$

这题~~明显~~是一个**找规律**题。

### $0$ $1$ $2$ $3$ $4$

首先，我们手造+模拟一个数据如上。

- 我们先**取一个数**，得出：

取一个数的**最大值**是 $4$，**最小值**是 $0$。

那么我们可以发现，取一个数的可能性是 $4-0+1=5$ 种。

- 接着**取两个数**，得出：

取两个数的最大数是 $3+4=7$，最小值是 $0+1=1$。

发现，取两个数的可能性是 $7-1+1=7$ 种。

那么，有同学可能会问：万一取一个数和取两个数中有重叠部分呢？

于是我们看了看题目，发现~~良心出题人~~给了我们一个前缀：$10^{100}$！

取两个数的前缀为 $2×10^{100}$，而取一个数的前缀仅为 $1×10^{100}$，而且 $n$ 的范围是 $1 ≤ N ≤ 2× 10^5$。那么我们就不用担心了。

同理，得出取 $k$ ~ $n+1$ 个数的和即可。

## $Note$

为什么是 $n+1$ 呢？因为题目中还有个 $0$，需看清。

## $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define mod %1000000007;
int main()
{
	long long n,m,x,y,z,ans=0;
	scanf("%lld %lld",&n,&m);
	for (long long i=m;i<=n+1;i++)
	{
		x=0; y=0;
		x=i-1; y=n-i+1;
		x=x*i/2; y=(y+n)*i/2;
		ans=(ans+y-x+1) mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：A_grasser (赞：3)

## 题意简化

给定一组项数为 $n+1$ 的递增的数，求取 $k$ 个及以上个数之和的可能数。

## 解法分析

若我们把 $10^{100}$ 看作 $0$，那么整个数列就是 $\left[0,n\right]$。

首先，要考虑一个问题：

**什么情况下加和会重复？**

第一种，选了数量不相同的两组数，但这是不可能的，因为每个数都大于等于 $10^{100}$，哪怕数量只差一也相差了 $10^{100}$，并且 $n$ 远小于 $10^{100}$，所以不用考虑。

第二种，选了相同数量的两组数，那么我们就举例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/v5l9jgyr.png)

找到规律了！如果选 $k$ 个数，那么答案就是前 $k$ 个数减去后 $k$ 个数再加一。

程序大体思路也就显而易见了：枚举 $k$，求出选 $k$ 个数时的答案，加上后求余。

代码主体也就长成这个样子：

```cpp
cin>>n>>k;
for(int i=k;i<=n+1;i++){
	long long tmp=sum/*高斯求和*/(n-i+1,n)-sum(0,i-1)+1;//选i个数时的答案 
	ans=(ans+tmp)%1000000007;
}
cout<<ans;//输出答案 
```
可能有人不知道什么是高斯求和，[这里](https://mp.weixin.qq.com/s?__biz=MzIzNzA5MzY0OQ==&mid=2653519942&idx=3&sn=70787a49f06b1de0023a306b1fea1ad1&chksm=f310f638c4677f2ee798183a21e3e32d18a1d587f298a12e0e9db067c033d9d7bd7e77b70810&scene=27)有详细的讲解。公式就是下面这个（首项加末项的和乘项数除以二）

$$\sum_x^y=\frac{(x+y)\times(y-x+1)}{2}$$

那么求和部分就是这样：

```cpp
long long sum(int x,int y){
	return (long long)(x+y)*(y-x+1)/2;//套公式 
}
```
最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过 
#include<bits/stdc++.h>
//万能头文件 
using namespace std;
int n,k;
long long ans;
long long sum(int x,int y){
	return (long long)(x+y)*(y-x+1)/2;//套公式 
}
int main(){
	cin>>n>>k;
	for(int i=k;i<=n+1;i++){
		long long tmp=sum/*高斯求和*/(n-i+1,n)-sum(0,i-1)+1;//选i个数时的答案 
		ans=(ans+tmp)%1000000007;
	}
	cout<<ans;//输出答案 
	return 0;
}
```

---

## 作者：icefake (赞：1)

# Sum of Large Numbers

## 题面翻译
~~蒟蒻的我永远都是在这件事上花费了很长的时间~~

> 给两个数 $ N $ 和 $ K $ ，于是我们就有 $ N + 1 $ 个整数 : $ {10}^{100} $ , $ {10}^{100} + 1 $ ， $ {10}^{100} + 2 $ , $ {10}^{100} + 3 $ ， ······ ， $ {10}^{100} + N $ 。而我们每次可以从这 $ N + 1 $ 个整数中取出至少 $ K $ 个整数，得到它们的和。问：一共可以得到多少种不同的和。

## 分析
~~想必各位dalao们都不会屑于写这种一眼题的题解，于是我就来凑数了~~
本蒟蒻在做这道题的时候，竟然错误地认为这是一道 $ O(1) $ 的题 $ QAQ $ ；
多亏一旁的朱某神提醒，看了一眼数据范围—— $ 1 \leq N \leq 2 \times {10}^{5} $ 很显然这是一道 $ O(n) $ 的题；
然后我们看到这 $ N $ 个整数都含有一个很大的基数 $ {10}^{100} $ ，这就说明，任意 $ m $ 个整数的和会远远大于任意 $ m - 1 $ 个整数的和，也就是它们之间绝对不会有重复；
不过，去相同的个数的整数之间的和是会有重复的，但显然，我们可以求出取出 $ m $ 个数的最大值和最小值，然后得到和的个数；
刚好，这就是一个 $ O(n) $ 的算法，于是我们就可以开始快乐的打代码了。

## 代码核心

从 $ K $ 到 $ N + 1$ 循环，然后通过“等差数列求和”写出每个 $ m $ 所对应的和的个数，然后取模。

```cpp
for(int i = m; i < n; i ++) {
		ans += ((n + (n - i + 1)) * i) / 2 - (((i - 1) * i) / 2) + 1;
		ans %= mod;
	}
```

## 完整 $ AC $ 代码

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 200010, mod = 1000000007;
int n, m;
int tem, cnt[maxn] = {0};

int read()
{
  int x = 0, w = 1;
  char ch = 0;
  while (ch < '0' || ch > '9') {
    if (ch == '-') w = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9') {
    x = x * 10 + (ch - '0');
    ch = getchar();
  }
  return x * w;
}

inline void write(int x)
{
  static int sta[35];
  int top = 0;
  do {
    sta[top++] = x % 10, x /= 10;
  } while (x);
  while (top) putchar(sta[-- top] + 48);
}

signed main()
{
	n = read();
	m = read();
	if(n + 1 == m) {
		cout<<1;
		return 0;
	}
	int ans = n + 2;
	for(int i = m; i < n; i ++) {
		ans += ((n + (n - i + 1)) * i) / 2 - (((i - 1) * i) / 2) + 1;
		ans %= mod;
	}
	write(ans);
	return 0;
}
```

#### 完结撒花
very nice

---

## 作者：happybob (赞：1)

~~第一次过灰题，庆祝庆祝~~

# 前埔知识：等差数列求和公式

$ \LARGE \sum_{i}^n \, = \,\frac {(i \,+ \,n) \,*\, (n \,- \,i\, + \,1)}{2}$

推导（别人写的）：[https://wenku.baidu.com/view/0c01681559eef8c75fbfb369.html](https://wenku.baidu.com/view/0c01681559eef8c75fbfb369.html)

所以这个题目主要是要找规律和等差数列求和公式

规律第一篇题解已经找出来了，大的减去小的加1

所以对于每个$i$而言，取的和不同的方法有

$ \large (\sum_{n \,- \,i \,+ \,1}^n  \, -\, $ $ \large \sum_ {0} ^ {i \, - \,1} + \, 1$ $\large) \, mod \, 10 ^ 9 + 7$

接下来首项末项项数求出来，简单AC，等差数列

code：
```cpp
#include <iostream>
using namespace std;

const int Mod = 1000000007;

int main()
{
    long long n, k, ans = 0;
    cin >> n >> k;
    for(register long long i = k; i <= n + 1; i++)
    {
        /*等差数列求和公式
        大
        n - i + 1
        n
        i
        2
        
        小
        0
        i - 1
        i
        2
        */
        
        ans = (ans + (n - i + 1 + n) * i / 2 - ((i - 1) * i) / 2 + 1) % Mod;
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：qw1234321 (赞：0)

找规律。（）

如果选 $k$ 个数，那么答案即为后 $k$ 个数的和减去前 $k$ 个数的和再 $+1$。

稍微打打表就能发现。

设序列 $A={0,1,2,3,4}$，即 $n=4$。

- 若 $k=1$：

很明显，答案为 $4-0+1= 5$。（每个数都选一遍）

- 若 $k=2$：

有和的序列为 ${1,2,3,4},{3,4,5},{5,6},{7}$。

去重后即为 ${1,2,3,4,5,6,7}$。

答案为 $(4+3)-(0+1)+1=7$。

故得证。

求和可以用高斯求和方法，可以 $O(1)$。

然后枚举每个可以的 $k$ 即可，范围为 $k,k+1,\dots ,n,n+1$。

于是便做完了。（）

code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 5, p = 1e9 + 7;
int n, k, ans;

int sum(int l, int r){
	return (l + r) * (r - l + 1) / 2;
}

void work(){
	cin >> n >> k;
	for (int i = k; i <= n + 1; i++){
		ans += sum(n - i + 1, n) - sum(0, i - 1) + 1;
		ans %= p;
	}
	cout << ans;
}

signed main(){
	int t = 1;
	//  cin >> t;
	while(t--) work();
	return 0;
}
```

---

## 作者：Hog_Dawa_IOI (赞：0)

### 题意
有长度为 $n+1$ 的数组 $s$，里面的数分别为 $s_0=10^{100},s_1=10^{100}+1,s_2=10^{100}+2, \dots, s_n=10^{100}+n$。若在其中选择不少于 $k$ 个数，请问存在多少种不同的和？   
由于答案可能过大，请将其对 $10^9+7$ 取模。   
数据范围： $ 1\leq n\leq2\times10^5 , 1\leq k\leq n+1 $。    
### 思路
本来想排列组合，但后来发现是多少种不同的和，不是多少种取数情况，寄了。  
当我们取 $i$ 个数的时候，我们能取到的和的范围最小是最小的 $i$ 个数的和，即 $(\sum^{i-1}_{j=0}s_j)=(10^{100} \times i+\sum^{i-1}_{j=0}j)$。    
同理最大的是最大的 $i$ 个数的和，即 $(\sum^n_{j=n-i+1}s_j)=(10^{100} \times i+\sum^{n}_{j=n-i+1}j)$。      
在这个范围中，每种和都能取到，所以当前情况的和的数量就是这两个东西的差。把差累积起来就是最后的答案。     
因为前面 $10^{100}$ 的前缀足够大，不用担心两种不同取数数量的方案取得的和相同。       
时间复杂度：枚举 $i$，最大值和最小值可以同时求出（计算时不用把 $10^{100}$ 的前缀算上，后面对 $j$ 的计算可以使用高斯求和公式），所以复杂度为 $O(n)$ 级别。    
### 代码
```cpp
#include<stdio.h>
const long long mod=1e9+7;
long long n,k,ans,dq1,dq2;
int main()
{
	scanf("%lld%lld",&n,&k),n++;
	for(int i=1;i<=n;i++)
	{
		dq1+=i,dq2+=n-i+1;//dq1是最小值，dq2是最大值
		if(i>=k) ans=(ans+(dq2-dq1+1)%mod)%mod;
		//左端点被减掉了，要多加一个1算上
	}
	printf("%lld",ans);
}
```

---

## 作者：qwpp (赞：0)

简单的黄题。

### [AT_abc163_d](https://www.luogu.com.cn/problem/AT_abc163_d)
# 题目大意
输入 $n,k$。

有从 $0$ 到 $n$（舍 $10^{100}$）的长度为 $n+1$ 的一组数，选择其中不低于 $k$ 个数相加，有几种不同的加法。

#### 答案对 $10^{9}+7$ 取模。

## 思路
本题解运用公式：等差数列求和公式。

$\Large\sum_{i}^{n}=\frac{(n+i)(n-i+1)}{2}$

就是找题目规律同时用公式解题。

根据别的题解和公式求出：

$\large(\sum_{n−i+1}^{n}−\sum_{0}^{i−1}+1) \bmod 10^9+7$

最后愉快地把公式套到代码上。

## AC code:
```cpp
#include<bits/stdc++.h>
#define ll long long  //不开longlong见祖宗 
#define AC return 0
using namespace std;
ll n,k,ans=0;  //ans归零 
int main(){
	cin>>n>>k;
	for(ll i=k;i<=n+1;i++){  //i记得开longlong 
		ans=(ans+(n-i+1+n)*i/2-((i-1)*i)/2+1)%1000000007;  //全代码的关键部分，原理在上面 
	}
	cout<<ans<<endl; //回车 
	AC;  //祝君AC 
    //求过
}
```


---

## 作者：Genius_Star (赞：0)

### 思路：

我们很容易发现一个规律：

样例来说，把 $10$ 的 $100$ 次方看成 $0$，那么就变成 $0,1,2,3$。

区间长度为 $2$ 的区间和的范围是：$0+1=1,2+3=5$，也就是 $[1,5]$。

区间长度为 $3$ 的区间和的范围是：$0+1+2=3,1+2+3=6$，也就是 $[3,6]$。

区间长度为 $4$ 的区间和的范围是：$[6,6]$。

所有范围内的数加起来就是 $10$ 个。

所以对于每一个区间长度，都求出来范围的下界和上界即可。

注意中间求和的过程中要用上界减去下界，此时要先减再 $p$（$p$ 为我们要取余的值）。

说下我自己容易出错的地方（大佬自动跳过）：

- 当题目要求结果 $\bmod$ 上一个数时，通常计算过程中要处处取模，否则会有隐患，但是如果计算中间出现了两个大数相减，比如算出来两个大数 $a,b(a<b)$。如果用 $b \bmod p - a \bmod p$，数据大一点就 ``WA`` 了。正确的应该先减，$(b-a+p) \bmod p$。

### 完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
typedef long long ll;
int main()
{
    ll n,k;
    cin >>n>>k;
    ll ans=0;
    while(k<=n)
    {
        ll res=(k*(n-k+1+n)/2-k*(k-1)/2+1+mod)%mod;
        ans=(ans+res)%mod;
        k++;
    }
    ans++;
    cout <<ans%mod<<endl;
}
```


---

## 作者：guanyf (赞：0)

### 导入
根据题意可以想到一个非常暴力的方法：枚举当前能选多少个数 $i(k \le i \le n+1)$，在对于依次搜索出选了的数的和，把它记在 `unordered_map` 中，依次累加答案。

由于这个做法太暴力了，就不放代码了。

### 分析、思路
刚才的做法时间复杂度最高的是搜索这一部分，我们不妨思考一下：实际上题目要我们求的并不是选择的方案数，而是和的数量，通过搜索去求太浪费了，因此需要考虑新的更优的做法。

设当前可以选择 $i$ 个数，那么我们就可以求出来和的上限 $r$ 和下限 $l$，分别是：

$$\sum_{j=n-i+1}^{n}{j}$$
$$\sum_{j=0}^{i-1}{j}$$

可以发现，由于序列是连续递增的，并且公差为 $1$，因此从上限到下限都是连续且合法的，那么对于能选择 $i$ 的情况来说，和的数量就是 $r-l+1$。

但是，这时候就会延伸出一个问题了：不同的 $i$ 和可能一样吗？答案是不可能。因为题目中加了一个前缀 $10^{100}$，这就确保了选择数量不同，和一定不相同，因此结论是对的。

但是如果直接求和依然会超时，因此呢我们就可以用公式求：[详细资料](https://baike.baidu.com/item/%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C/7318680)

$$\sum_{x=a}^{b}{x} = (a + b) \times (b-a+1)/2$$

#### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
int n, k, ans;
int sum(int b, int e) {
  return (b + e) * (e - b + 1) / 2 % mod;
}
signed main() {
  ios::sync_with_stdio(0);
  cin >> n >> k;
  for (int i = k; i <= n + 1; i++) {
    ans = (ans + sum(n - i + 1, n) - sum(0, i - 1) + 1 + mod) % mod;
  }
  cout << ans;
  return 0;
}
```

---


# [AGC064A] i i's

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc064/tasks/agc064_a

正整数 $ N $ が与えられるので、 長さ $ L\ \coloneqq\ N(N+1)/2 $ の整数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_L) $ であって、下記の条件をすべて満たすものを $ 1 $ つ出力してください。

- すべての $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、$ A $ は $ i $ をちょうど $ i $ 個含む。
- すべての $ i\ =\ 1,\ 2,\ \ldots,\ L $ について、$ 1\ \leq\ |A_i\ -\ A_{i+1}|\ \leq\ 2 $ 。ただし、$ A_{L+1} $ は $ A_1 $ を表す。
 
なお、本問題の制約下において、上記の条件をすべて満たす長さ $ L $ の整数列 $ A $ が必ず存在することが証明できます。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 1000 $
- $ N $ は整数
 
### Sample Explanation 1

整数列 $ A\ =\ (1,\ 3,\ 4,\ 2,\ 4,\ 3,\ 4,\ 2,\ 4,\ 3) $ は、ちょうど $ 1 $ 個の $ 1 $ 、ちょうど $ 2 $ 個の $ 2 $ 、ちょうど $ 3 $ 個の $ 3 $ 、ちょうど $ 4 $ 個の $ 4 $ を含むため、$ 1 $ つ目の条件を満たします。 また、下記の通り $ 2 $ つ目の条件も満たします。 - $ |A_1\ -\ A_2|\ =\ |1\ -\ 3|\ =\ 2 $ - $ |A_2\ -\ A_3|\ =\ |3\ -\ 4|\ =\ 1 $ - $ |A_3\ -\ A_4|\ =\ |4\ -\ 2|\ =\ 2 $ - $ |A_4\ -\ A_5|\ =\ |2\ -\ 4|\ =\ 2 $ - $ |A_5\ -\ A_6|\ =\ |4\ -\ 3|\ =\ 1 $ - $ |A_6\ -\ A_7|\ =\ |3\ -\ 4|\ =\ 1 $ - $ |A_7\ -\ A_8|\ =\ |4\ -\ 2|\ =\ 2 $ - $ |A_8\ -\ A_9|\ =\ |2\ -\ 4|\ =\ 2 $ - $ |A_9\ -\ A_{10}|\ =\ |4\ -\ 3|\ =\ 1 $ - $ |A_{10}\ -\ A_1|\ =\ |3\ -\ 1|\ =\ 2 $

## 样例 #1

### 输入

```
4```

### 输出

```
1 3 4 2 4 3 4 2 4 3```

# 题解

## 作者：Garry_HJR (赞：7)

## 题意

给定一个正整数 $n$，要求构造一个长度为 $\frac{n(n+1)}{2}$ 的序列，你需要保证：对于 $1$ 到 $n$ 中的每一个数字 $i$，恰好出现了 $i$ 次，并且将这个序列拼成一个环，相邻两位数之差在 $1$ 和 $2$ 之间。

## 思路分析

本题目的突破点在于相邻两位数之差。

很明显，对于 $i=1$ 我们应该保证相邻的两个数之间递减或者递增；而对于 $i=2$ 则是组合之间的转折。

### 处理数与数之间的组合

例如，对于一个数 $x$ 和一个相邻的比它小的数 $x-1$，我们就可以“反复徘徊”，也就是用 $x,x-1,\dots,x-1,x$ 的方式进行处理。

那么，我们只需要把两个数组成一组，按照上面的方法进行处理就可以了。

为什么这么做正确呢？

证明：我们设相邻的两个组 $a,b$ 每个组中较大的数分别为 $a1,b1$，明显 $b1=a1+2$，这样上述的排列 $a1,a1-1,a1,\dots,a1-1,a1,b1,b1-1,b1,\dots,b1-1,b1$ 就展现为 $a1,a1-1,a1,\dots,a1-1,a1,a1+2,a1+1,a1+2,\dots,a1+1,a1+2$，接口部分的绝对值正好是 $2$，符合题意。

### 排列方式

如果不考虑首尾相连成一个环的情况，综上述，对于 $n$ 是偶数的部分，正好可以两两一组划分（每一组中偶数较大）；对于 $n$ 是奇数的部分，我们把 $1$ 撇开，剩余的两两一组（每一组奇数较大）。

如果是偶数，这个排列就展现为 $2,1,2,4,3,4,3,4,3,4,\dots,n,n-1,n,\dots,n-1,n$ 这样子。

如果是奇数，这个排列就展现为
$1,3,2,3,2,3,\dots,n,n-1,n,\dots,n-1,n$ 这样子。

如果有环的话怎么办？

我们只需要把 $1$ **左边**没有的数从 $1$ 的**右边**挪过去。

即：$n,n-1,n-2,\dots,2,1,2,4,3,4,3,4,\dots,n,n-1,n,\dots,n-1,n$（举例中 $n$ 是偶数）这样子。

然而我们发现还是不行，因为首位都是 $n$ ，题目要求是**相邻两位数之差大于等于** $1$，这样还是会错。

处理方法也很简单，我们只需要交换前面的 $n$ 和 $n-1$ 即可。

最后排列成了 $n-1,n,n-2,n-3,\dots,2,1,2,4,3,4,3,4,\dots,n,n-1,n,\dots,n-1,n$（举例中 $n$ 是偶数）这样子。

这道题目也就做完了。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	cin>>n;
	//分类讨论奇偶数情况 
	if(n%2==0){//偶数部分 
		//偶数部分中存在特殊情况，需特别判断 
		cout<<n-1<<' '<<n<<' ';
		for(int i=n-2;i>=1;i--)cout<<i<<' ';//输出1前面特殊的排列（注意翻转 n 和 n-1） 
		cout<<2<<' ';//特殊情况：n-1,n,...,2,1,2,在前面已经用了一个2，还剩一个 
		for(int i=4;i<=n;i+=2){//n,n-1,...,n-1,n 
			cout<<i<<' ';
			for(int j=1;j<i-1;j++){
				cout<<i-1<<' '<<i<<' ';
			}
		}
	}
	else{//奇数部分 
	    //奇数部分不存在偶数部分中2的特殊情况，按常规写即可。 
		cout<<n-1<<' '<<n<<' ';
		for(int i=n-2;i>=1;i--)cout<<i<<' ';
		for(int i=3;i<=n;i+=2){
			cout<<i<<' ';
			for(int j=1;j<i-1;j++){
				cout<<i-1<<' '<<i<<' ';
			}
		}
	}
}

```


---

## 作者：yuheng_wang080904 (赞：2)

## 题意

构造一个长度为 $\frac{n(n+1)}{2}$ 的序列，满足数 $i$ 出现 $i$ 次，且 $1\le |A_i-A_{i+1}|\le2(i\in[1,\frac{n(n+1)}{2}])$，其中令 $A_{\frac{n(n+1)}{2}+1}=A_1$。

## 思路

简单构造题。

一开始如果有人看错题的话（我就这么看错的），一个很朴素的想法是这样构造 $n,n-1,\cdots,n,n-1,n,n-2,n-3,\cdots,n-2,n-3,n-2,\cdots$，最后结尾根据奇偶性看是 $3,2,3,2,3,1$ 还是 $2,1,2$。

但是重新读题后可以很明显发现当 $i=\frac{n(n+1)}{2}$ 的时候不满足要求，我们想怎么改进。

容易想到要把一对 $n,n-1$ 拉到最后，但这样也不能直接接到 $1$ 的后面，于是想到把每组数都取一对放到最后，于是结尾就是这样了 $1,2,3,\cdots,n-1,n$。

于是又获得一发罚时，发现还是 $i=\frac{n(n+1)}{2}$ 的时候不满足要求。

稍作点改变，将结尾变成 $1,2,3,\cdots,n-3,n-2,n,n-1$，就做完了。

写代码时注意奇偶性判断，防止 $1$ 和 $0$ 多出现就好了。

## 代码

```cpp
int n;
int main(){
	cin>>n;
	for(int i=n;i>=1;i-=2){
		if(i==1)cout<<1<<" ";
		else{
			for(int j=1;j<i-1;j++)cout<<i<<" "<<i-1<<" ";
			cout<<i<<" ";			
		}
	}
	if(n%2==0)cout<<1<<" ";
	for(int i=2;i<=n-2;i++)cout<<i<<" ";
	cout<<n<<" "<<n-1<<endl;
	return 0;
}
```


---

## 作者：Ifyoung (赞：1)

## [题面](https://www.luogu.com.cn/problem/AT_agc064_a)

# 题目大意

给定一个正整数 $N$，要求构造一个序列。对于每一个在 $1$ 到 $N$ 之间的整数 $i$，序列中包含了 $i$ 个，并且将该序列首尾相接拼成环后，相邻两项之差大于等于 $1$ 小于等于 $2$。

# 思路

突破口是关于相邻两项之差的约束条件。

~~（我一开始竟然只看见了“小于等于 $2$”，然后我构造出来的相邻两项就有相等的情况，还调了半天 qwq）~~

感觉上“大于等于 $1$”是在让我们 **递增** 或 **递减**，而“小于等于 $2$”则是给了我们一个 **调整的空间**。

但是由于要求“包含 $i$ 个 $i$”，那么就不能只递增或者只递减，肯定是要 **反复递增递减**。

然后我就得到了一个 **错误** 的“图”（以 $N=6$ 为例）：

```
6         6         6         6         6         6
 5       5  5      5  5      5  5      5  5      5
  4     4    4    4    4    4    4    4    4    4
   3   3      3  3      3  3      3  3      3  3
    2 2        22        22        22        22
     1         1         1         1         1
```

（好像缩进有点问题……）

这很显然是 **错误** 的（其实当时就只是在脑子里想了一下，没画出来，但总是感觉哪里怪怪的，所以以后还是要勤动手啊……）

递增递减确实都考虑到了，但是数量却没有保证，那么下一步就考虑 **先保证数量**。

于是又得到了下面的图（以 $N = 6$ 和 $N = 7$ 为例）：

```
6 6 6 6 6 6
 5 5 5 5 5
  4 4 4 4
   3 3 3 
    2 2
     1
     
7 7 7 7 7 7 7
 6 6 6 6 6 6
  5 5 5 5 5
   4 4 4 4
    3 3 3
     2 2
      1
```

很明显的是，数量肯定是对的，但是要怎么把这个“图”转换成序列呢？

还是考虑 **反复递增递减**，然后可以发现 **从左上到下方再到右上**，这就是一个 **先递减后递增** 的过程。

然后就进行尝试，把整个图拆成下面的样子：

```
6         6  6     6  6 6
 5       5    5   5    5
  4     4      4 4
   3   3        3
    2 2
     1
     
7           7  7       7  7   7  7
 6         6    6     6    6 6   
  5       5      5   5      5
   4     4        4 4
    3   3          3
     2 2
      1
```

可以发现对于 **奇偶不同** 的 $N$ 拆出来的图的样子是不太一样的，这个后面再说。

这时，感觉上拆开后的图好像差不多就可以了。

那到底差哪里了呢？

就是每一个部分的 **连接处**，如上图中就会有两个 $6$ 挨着和两个 $7$ 挨着的情况，这个时候就要用到出题人给的 **调整的空间** 了。

我们可以把一个“部分”中的某个数放到外面，具体地说，以“部分”“$6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6$”为例，我们可以把两个 $5$ （或 $4,3,2$）放到两个 $6$ 的外侧。

这样做首先可以保证这个“部分”的中间几个位置是不破坏约束条件的，因为本身是递增或递减的，拿走其中一个之后，最多相差 $2$。如“$5, 4, 3$”拿走其中的 $4$ 之后，$5$ 和 $3$ 之间也就差 $2$。

但是还有一个地方没有保证，那就是这个“部分”的两头。

还是以序列“$6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6$”为例，如果把 $5$ 放在两头，那么 $5$ 和 $6$ 只差 $1$，满足约束条件，但要是把 $2$ 拿出来放在两头，那么 $2$ 和 $6$ 相差 $4$，就不满足约束条件了。

同样的，把 $4$ 拿出来也是满足条件的，但此处为了 **简便**，我们直接拿相差 $1$ 的即可。

接下来讲一下“简便”的含义：

我们可以发现，每一个“部分”原始的两头都是 $N$，所以我们把如“$6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6$”的序列加进去后只需进行两次“交换”：首项和第二项、倒数第二项和末项。

但是这里还有一个问题，那就是如果每一部分的两头都进行了这样的“交换”，就会“负负得正”，就变成了两个 $N - 1$ 挨着，那么我们可以借用“拼图”的思想，就是一头设计成凸出去的，另一头是凹进来的。具体到这个题上就是，**一头“交换”，另一头不“交换”**。

但是如果都这样设计也不行，因为在枚举到最后的“部分”的时候，如果规模太小，就进行不了“交换”。

例如“$6, 5, 6$”这个“部分”，如果进行了“交换”，那么两个 $6$ 就会挨着。还有“$7$”这个“部分”，只有一个元素，无法进行“交换”。（$N$ 的奇偶不同）那么像这样的情况，两头的值就必须都是 $N$。而与此类“部分”相接的“部分”是倒数第二个“部分”和第一个“部分”，那么倒数第二个“部分”的后面一头和第一个“部分”的前面一头就要设计成“交换”后的。

那么我们就可以把每一个“部分”的后面一头“交换”，前面一头不变（第一个“部分”两头都要“交换”）。

再讲一个实现上的细节。

怎样把一个“部分”加到要输出的数组里呢？

可以发现，每次都是从 $N$ 到一个“顶点”，再从“顶点”到 $N$。比如“$6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6$”这个序列中的“顶点”就是 $1$。

那么我们就可以对“顶点”进行“监视”。

可以发现每个“顶点”都比前一个“部分”的“顶点”大 $2$，但是在实现的时候不要直接写 `+=2` ，而是分成两步：第一步是从 $N$ 到“顶点”，然后将“顶点” `++` ，第二步就可以写成从 `+1` 之后的“顶点”到 $N$。

最后规模较小的“部分”暴力处理就好。

# 代码

含注释：

```cpp
#include <bits/stdc++.h>

using namespace std;

int read() {
	int x = 0, w = 1;
	char ch = 0;
	while (ch < '0' || ch > '9') {
		if (ch == '-') w = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch ^ '0');
		ch = getchar();
	}
	return x * w;
}

void write(int x) {
	if (x < 0) {
		x = -x;
		putchar('-');
	}
	if (x > 9) write(x / 10);
	putchar(x % 10 ^ '0');
}

const int N = 500505;

int a[N];

signed main() {
	int n = read();
	int top = 1; // 顶点
	int idx; // 用来遍历 a 数组
	for (int i = n; i >= top; i -- ) { // 对于第一个“部分”的特殊处理
		a[ ++ idx] = i;
	}
	swap(a[1], a[2]);
	top ++ ; // 分成两步来处理
	for (int i = top; i <= n; i ++ ) {
		a[ ++ idx] = i;
	}
	swap(a[idx], a[idx - 1]);
	top ++ ;
	while (n - top > 1) { // 如果只剩两层或一层，就退出
		for (int i = n; i >= top; i -- ) {
			a[ ++ idx] = i;
		}
		top ++ ;
		for (int i = top; i <= n; i ++ ) {
			a[ ++ idx] = i;
		}
		swap(a[idx], a[idx - 1]);
		top ++ ;
	}
	if (n - top == 1) { // 这与 N 的奇偶性有关，要分类讨论
		a[ ++ idx] = n;
		a[ ++ idx] = n - 1;
		a[ ++ idx] = n;
	} else {
		a[ ++ idx] = n;
	}
	// write(idx), puts("");
	for (int i = 1; i <= idx; i ++ ) write(a[i]), putchar(' '); // 输出
	puts(""); // AtCoder 特性
	return 0;
}
```

复杂度是 $O(L)$ 的，轻松过。

---

## 作者：eoinlee (赞：0)

## 题意

给定 $N \in [3, 1000]$，构建一个长度为 $\frac{N (N + 1)}{2}$ 的**环形**序列，使得每个数字 $x \in [1, N]$ 都恰好在序列中出现 $x$ 次，并且环形序列上相邻两个数之差的绝对值在 $[1, 2]$ 内。

## 思路

我们先考虑在一个非环形的序列上怎么做（其实是因为我刚开始没看到环形这个条件……）。通过人类智慧，我们可以构造出这样一个满足条件的序列 $a$：

- 若 $N$ 为奇数，则 $a = \lbrace {\color{green}1},{\color{red}3,2,3,2,3},{\color{blue}5,4,5,4,5,4,5}, {\color{red}7,6,7,6,7,6,7,6,7,6,7,6,7}, \ldots\rbrace$；
- 若 $N$ 为偶数，则 $a = \lbrace {\color{green}2,1,2},{\color{red}4,3,4,3,4,3,4},{\color{blue}6,5,6,5,6,5,6,5,6,5,6}, \ldots\rbrace$。

基于同样的分段的思路，我们可以将这种做法延伸到环上。由于每一个段的长度都是奇数，假定其中一段长度为 $l$，则将其从中断开，将断开后的其中一段放到 $1$ 的左边。下面奇数偶数各举一例：

- 若 $N = 7$，则 $a = \lbrace {\color{red}7,6,7,6,7,6,7}, {\color{blue}4,5,4,5}, {\color{red}3,2,3},{\color{green}1},{\color{red}3,2},{\color{blue}5,4,5}, {\color{red}7,6,7,6,7,6}\rbrace$；
- 若 $N = 6$，则 $a = \lbrace {\color{blue}6,5,6,5,6}, {\color{red}4,3,4}, {\color{green}2,1,2},{\color{red}4,3,4,3},{\color{blue}6,5,6,5,6,5}\rbrace$。

## 代码

实现方法很多。由于我不想推式子，所以我选择直接用双端队列模拟。虽然比较麻烦，但是这种写法确实没有什么思维含量，比较适合我这种没有脑子的蒟蒻。

``` cpp
#include <bits/stdc++.h>

int N;
std::deque<int> dq;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  std::cin >> N;

  if (N & 1) {
    dq.push_back(1);

    for (int i = 3; i < N; i += 2) {
      for (int j = 1; j < i; ++j)
        if (j & 1) dq.push_back(i), dq.push_back(i - 1);
        else dq.push_front(i - 1), dq.push_front(i);
      dq.push_back(i);
    }

    for (int i = 1; i < N; ++i)
      if (i & 1) dq.push_back(N), dq.push_back(N - 1);
      else dq.push_front(N), dq.push_front(N - 1);

    dq.push_front(N);
  }

  else {
    dq.push_back(2), dq.push_back(1), dq.push_back(2);

    for (int i = 3; i < N - 1; i += 2) {
      for (int j = 1; j <= i; ++j)
        if (j & 1) dq.push_back(i), dq.push_back(i + 1);
        else dq.push_front(i + 1), dq.push_front(i);
      dq.push_front(i + 1);
    }

    for (int i = 1; i < N; ++i)
      if (i & 1) dq.push_back(N), dq.push_back(N - 1);
      else dq.push_front(N), dq.push_front(N - 1);

    dq.push_front(N);
  }

  while (!dq.empty())
    std::cout << dq.front() << ' ', dq.pop_front();

  std::cout.flush();
  return 0;
}

```

---

## 作者：high_sky (赞：0)

## 思路
### 概述
放一个数字 $i$，那么 $i+1$ 就可以放在 $i$ 的两边，多出来的数字后面插入到里面（还没构造完的序列），首尾数字相同也一样。

### 过程
拿样例来说（$N=4$），长度就为 $L=N\times(N+1)\div2=10$。

因为 $3\leq N$，所以按照刚刚的思路可以首先预处理出一个序列：$\{2,1,2\}$。

现在轮到了数字 $3$，因为有 $3$ 个 $3$，所以可以把其中两个 $3$ 放在序列的两侧，得到 $\{3,2,1,2,3\}$，多出来的 $3$ 可以放在一个数组 $B$ 中。

轮到数字 $4$，放两个 $4$ 于序列两侧，得到 $\{4,3,2,1,2,3,4\}$，因为我们 $B$ 数组中有数，所以可以把尾元素放于左侧（右侧也可），再在相同方向放于一个 $4$，最后把 $1$ 个 $4$ 放于 $B$ 数组的尾部。

现在我们有 $\{4,3,4,3,2,1,2,3,4\}$，我们直接把 $B$ 数组的数插入到序列当中，可以得到 $\{4,3,4,3,4,2,1,2,3,4\}$，最后通过同样的步骤整理得到 $\{4,3,4,3,4,2,1,2,4,3\}$。

## Code
```cpp
#include <iostream>
#include <queue>
#include <cmath>
#include <vector>
using namespace std;
int n,len;
deque<int> a;
vector<int> re,ans;
bool check(int x,int y){
	return abs(x-y)<=2&&abs(x-y)>=1;
}
int main(){
	cin>>n,len=n*(n+1)/2;
	vector<int> insertions(len+5);
	int will_insert=0,num=0;
	a.push_back(1);
	a.push_back(2);
	a.push_front(2);
	for (int i=3;i<=n;i++){
		int u=i;
		for (int j=1;j<=i;j++){
			if(check(i,a.front())){
				a.push_front(i);
				continue;
			}
			if(check(i,a.back())){
				a.push_back(i);
				continue;
			}
			if(re.empty()){
				u=j;
				break;
			}
			a.push_front(re[re.size()-1]);
			a.push_front(i);
			re.pop_back();
		}
		for(int j=u;j<=i;j++)re.push_back(i);
	}
	while(!a.empty()){
		int temp=a.front();
		a.pop_front();
		if(a.empty()){
			ans.push_back(temp);
			break; 
		}
		ans.push_back(temp);
		for (int i=re.size()-1;i>=0;i--)
			if(check(re[i],a.front())&&check(re[i],ans[ans.size()-1])) {
				ans.push_back(re[i]);
				re[i]=-20;
				break;
			}
	}
	if(ans[0]==ans[len-1]){
		int v=ans[len-1];
		num=v;
		ans.pop_back();
		for (int i=0;i<ans.size()-1;i++)
			if(check(ans[i],v)&&check(ans[i+1],v)){
				will_insert = i;
				break;
			}
	}
	for (int i=0;i<ans.size();i++) {
		cout << ans[i] << " ";
		if(will_insert == i) cout << num << ' ';
	}
	return 0;
}
```

---

## 作者：GI录像机 (赞：0)

## 思路：

构造题，瞪了半天没瞪出来，先打个暴力观察一下答案。

当 $n=3$ 时，答案仅有 $(1,3,2,3,2,3)$，其余答案无本质区别。

当 $n=5$ 时，其中一组解为 $(1,2,3,2,3,5,4,5,4,5,4,5,4,5,3)$。

我们钦定 $A_1$ 的位置放 $1$。观察到 $(2,3)$，$(4,5)$ 两对数频繁出现在一起，考虑将所有形如 $(i,i+1)$ 的配对依次接在 $1$ 的后面。这样所有奇数都会剩出一个，刚好可以放在序列末尾和 $1$ 接上。但要使得前面配对部分与结尾剩出奇数部分相交的地方不一样，第一处选择 $(2,3)$ 或 $(3,2)$ 就需要特别判断一下。

当 $n$ 为偶数时，只需要解出 $n-1$ 的解然后在 $n$ 个 $(n-2,n-1)$ 的配对中间加入 $n$ 即可。

## 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c <= '9' && c >= '0') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
void write(int x) {
	if (x < 0) {
		x = -x;
		putchar('-');
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7;
int n = read(), ans[N];
signed main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	int tmp = n;
	if (n & 1) {
		ans[1] = 1;
		n = tmp * (tmp + 1) / 2;
		ans[n] = 3;
		while (ans[n--] != tmp)ans[n] = ans[n + 1] + 2;
		int now = 1;
		for (int i = 2; i <= tmp; i += 2)
			for (int j = 1; j <= i; j++) {
				if (((tmp - i) / 2) % 2 == 0) {
					ans[++now] = i + 1;
					ans[++now] = i;
				} else {
					ans[++now] = i;
					ans[++now] = i + 1;
				}
			}
		for (int i = 1; i <= tmp * (tmp + 1) / 2; i++) {
			write(ans[i]);
			putchar(' ');
		}
	} else {
		int num = tmp;
		tmp--;
		ans[1] = 1;
		n = tmp * (tmp + 1) / 2;
		ans[n] = 3;
		while (ans[n--] != tmp)ans[n] = ans[n + 1] + 2;
		int now = 1;
		for (int i = 2; i <= tmp; i += 2)
			for (int j = 1; j <= i; j++) {
				if (((tmp - i) / 2) % 2 == 0) {
					ans[++now] = i + 1;
					ans[++now] = i;
				} else {
					ans[++now] = i;
					ans[++now] = i + 1;
				}
			}
		for (int i = 1; i <= tmp * (tmp + 1) / 2; i++) {
			write(ans[i]);
			putchar(' ');
			if (abs(ans[i] - tmp - 1) <= 2 && abs(ans[i + 1] - tmp - 1) <= 2 && num) {
				write(tmp + 1);
				putchar(' ');
				num--;
			}
		}
	}
	return 0;
}
```


---

## 作者：Yashajin_Ai (赞：0)

### 思路
首先我们要明确这是一道构造题，要求构造一个长度为 $\frac{n \times (n+1)}{2}$，对于每个数 $i$ 存在 $i$ 个，且满足相邻两数相减绝对值小于等于 $2$。

明确条件后我们就来观察此题，我认为其中突破口就在相临两数相减绝对值小于小于等于 $2$ 此处。我们换个方向思考，我们是不是每次就最多让他两数刚好相差二就好了，由此相差二会出现同奇同偶，我们不难想出 $3$ 的答案。

 ```
 3 2 3 2 3 1
 ```
 
 那么这样我们看出：
 
 ```
 n n-1 n n-1 n n-2
 ```
 
 一定满足此条件，所以我们还需构造后面一串，因为最后一个值为 $n-2$，那我们又从 $n$ 开始构造一个等差数列，公差为 $-2$，末项为 $n-3-k$，其中 $k$ 当前处理了几次，从 $1$ 开始，接着又从 ``` n-3-k+!(n-i&1) ``` 位开始构造一个小于 $n$ 且公差为 $2$ 的等差序列。
 
此方法下保证了将三串式子拼接在一起连接处相邻绝对值小于二。

以四为例：
```
4 3 4 3 4 2 4 2 1 3
 1 1 1 1 2 2 2 1 2
```

同时我们能在保证 $n$ 的个数的前提下，同时保证了，其他数的个数，因为我每次会处理到 $n-3-k$，相当于我每两次会更新一次这个序列，处理了以下情况（此处借用 $\textcolor{black}{I}\textcolor{red}{fyoung}$ 大佬的手绘图）：

```
6         6  6     6  6 6
 5       5    5   5    5
  4     4      4 4
   3   3        3
    2 2
     1
```

我就不用正反输出而是每次输出奇数位的数与偶数位的数就可以了。

### 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read(){
	int ret=0,f=0; char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=1; ch=getchar();}
	while(isdigit(ch)) ret=(ret<<1)+(ret<<3)+(ch^48),ch=getchar();
	return f?-ret:ret;
}

int n;
int main(){
	n=read();
	cout<<n<<" "<<n-1<<" "<<n<<" "<<n-1<<" "<<n<<" "<<n-2<<" "; 
	for (int i=n-3;i;i--){
		for(int j=n;j>=i;j-=2){
			cout<<j<<" ";
		}
		for(int j=i+!(n-i&1);j<n;j+=2){
			cout<<j<<" ";
		}
	}
}
```

---


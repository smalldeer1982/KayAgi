# [ARC128B] Balls of Three Colors

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc128/tasks/arc128_b

$ R $ 個の赤いボール，$ G $ 個の緑のボール，$ B $ 個の青いボールがあります． あなたは，以下の操作を好きな回数繰り返すことができます．

- 色の異なる $ 2 $ つのボールを選び，それら両方を残るもう一つの色のボールに変える．

例えば，赤いボールと青いボールを選んだ際は，それら両方を緑のボールに変えます．

あなたの目標は，すべてのボールを同じ色にすることです． 目標が達成可能であるか判定し，また可能であるなら，必要な操作回数の最小値を求めてください．

$ 1 $ つの入力ファイルにつき，$ T $ 個のテストケースを解いてください．

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 100 $
- $ 1\ \leq\ R,G,B\ \leq\ 10^8 $
- 入力される値はすべて整数である

### Sample Explanation 1

例えば，$ case_3 $ については，以下のように操作を行えばよいです． - 緑のボールと青いボールを選び，それら両方を赤いボールに変える - 赤いボールと青いボールを選び，それら両方を緑のボールに変える - 赤いボールと青いボールを選び，それら両方を緑のボールに変える - 赤いボールと青いボールを選び，それら両方を緑のボールに変える

## 样例 #1

### 输入

```
3
1 2 2
1 2 3
1 2 4```

### 输出

```
2
-1
4```

# 题解

## 作者：Double_Light (赞：3)

## 题目分析

这里题目没翻译到每组数都有三个，不过看样例也能知道。

假设每组三个数为 $a,b,c$，这里让 $a$ 执行 $+2$ 的操作，剩下两数 $-1$。得到 $a+2,b-1,c-1$。

作差得到，三个数中 $b,c$ 之差没有改变，而剩下两对数的差都扩大或缩小了 $3$。也就是说，每两个数之差模 $3$ 的余数永远不会改变。如果要求其中两数为 $0$，那么就要求这两数差输入时就是 $3$ 的倍数，也就是两数模 $3$ 的余数相同，所以如果三个数模 $3$ 的余数均不相同，则输出 $-1$。

如果找到两个数 $a$ 和 $b$ 除以 $3$ 的余数相同，设 $a \leq b$，就让 $a$ 一直 $+2$，$b$ 和 $c$ 一直 $-1$，直到 $a=b$。随后让 $c$ 一直 $+2$，$a,b$ 都 $-1$，这样 $a,b$ 就可以同时为 $0$。

观察到 $b$ 全程在 $-1$，所以这是让 $b$ 变成 $0$ 的次数最少的解，也是让 $a,b$ 两数都变成 $0$ 的次数最少解了。这时，直接输出 $b$ 即可。

## 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int t,a[4],x,y;
int main(){
	cin>>t;
	while(t--){
		cin>>a[1]>>a[2]>>a[3];
		if(a[1]%3!=a[2]%3&&a[2]%3!=a[3]%3&&a[1]%3!=a[3]%3)cout<<-1<<'\n';//判断无解
		else{
			sort(a+1,a+4);//三个数如果余数都相同，取最小的两个，所以要排序
			if(a[1]%3==a[2]%3)x=a[1],y=a[2];//x,y就相当于上文提到的a,b
			else if(a[1]%3==a[3]%3)x=a[1],y=a[3];
			else if(a[2]%3==a[3]%3)x=a[2],y=a[3];
			cout<<max(x,y)<<'\n';
		}
	}
	return 0;
} 
```

---

## 作者：yaotianhao (赞：3)

### 题意

给你 $3$ 个正整数和一个操作，操作为可以让一个数 $+2$，另外两个数 $-1$，问能不能用这一个操作使 $3$ 个数中有 $2$ 个数的值为 $0$，如果能，输出最少的操作次数，如果不能，则输出 $-1$。

### 思路

如果有两个相同的数，那就一直给这两个数 $-1$ 就行了，然而，还有一种情况也是有解。

我们拿第三组样例来看看：

````
1 2 4
````

他的操作分别是：

$1+2=3$ ，$2-1=1$ ，$4-1=3$

$3-1=2$ ，$1+2=3$ ，$3-1=2$

$2-1=1$ ，$3+2=5$ ，$2-1=1$

$1-1=0$ ，$5+2=7$ ，$1-1=0$

我们能发现，一个数 $+2$，一个数 $-1$，就是 $+3$ 的操作，这样就可以让两个数的差为 $3$ 的倍数的两个数变成相同，再一起 $-1$。

### 代码

代码如下：

````cpp
#include <bits/stdc++.h>
using namespace std;
int t, a[5], x, y, z;
int main() {
	scanf("%d", &t);
	while(t--) {
		scanf("%d%d%d", &a[1], &a[2], &a[3]);
		sort(a + 1, a + 3 + 1);
		x = a[2] - a[1], y = a[3] - a[2], z = a[3] - a[1];
		if(a[1] == a[2] || a[1] == a[3]) printf("%d\n", a[1]);
		else if(a[2] == a[3] || x % 3 == 0) printf("%d\n", a[2]);
		else if(y % 3 == 0 || z % 3 == 0) printf("%d\n", a[3]);
		else printf("-1\n");
	}
}
````

---

## 作者：saixingzhe (赞：2)

# 题意
给定红球 $R$ 个，绿球 $G$ 个，蓝球 $B$
个。

可以任意次选择两个不同颜色的球把它们的颜色变为剩下的颜色。

求最小的操作次数使得所有球的颜色相同。

$1 ≤ R,G,B ≤ 10^8$。

# 分析
操作其实就是让其中两个数 `-1`，另一个数 `+2`。

模拟一下可以发现，通过 $3$ 步操作，可以变为 $0$，$-3$，$+3$:

0. $0$，$0$，$0$

1. $-1$，$-1$，$+2$

2. $-2$，$-2$，$+4$

3. $0$，$-3$，$+3$

这 $3$ 步操作只改变其中两个数，改变的值是 $3$，如果能够让三个数中某两个数相等，就可以不断对这两个操作达到结果，因此只需要枚举不变的数，判剩下的数是否同余 $3$ 即可。

**代码就不放了。**

---

## 作者：RioFutaba (赞：1)

# 题意
给定三个正整数数，每次操作可以将其中一个数 $-1$，另外两个数 $+2$，目标操作数次后将其中两个数置为 $0$。如果可以，输出最少的操作次数，否则输出 $-1$。
# 解法
### 情况一：有两个相同的数
显而易见，如果三个数中有两个数相同，那么一定有解：一直将这两个相同的数 $-1$ 直到都为 $0$，这是操作次数最小的解法了。

### 情况二：没有相同的数
我们可以将这种情况转化为有两个数相同情况然后进行处理，除此之外没有别的更好的解法了。

如何转化？

观察样例的第 $3$ 组数转化成有两个数相同情况的操作：
```
1 2 4
```
```
1 2 4
1+2 2+2 4-1
3 4 3

```
可以发现，让一个数 $-1$，另一个数 $+2$，就可以让它们之间的差 $-3$，所以**如果有两个数的差为 $3$ 的倍数，那么一定有解，否则无解**。



最后需要求出操作的步数。

设这两个数中小数为 $x$，大数为 $y$。

将两个数转换为相同的数。因为每次将他们的差 $-3$，所以需要 $(y-x)\div 3$ 次操作。

将两个数同时 $-1$，置为 $0$。两个数都会在上一步转换为 $x+2\times((y-x)\div 3)$，所以需要 $x+2\times ((y-x)\div 3)$ 次操作。

总操作数为 $(y-x)\div3+x+2\times((y-x)\div 3)$ 次，化简得：$y$ 次。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int T,a[3];
int main(){
	scanf("%d",&T);
	while(T--){
		int y=0;
		scanf("%d%d%d",&a[0],&a[1],&a[2]);
		sort(a,a+3);
		
		if(!((a[1]-a[0])%3)) y=a[1];
		else if(!((a[2]-a[0])%3)) y=a[2];
		else if(!((a[2]-a[1])%3)) y=a[2];
		if(!y) printf("-1\n");
		else printf("%d\n",y);
	}
	return 0;//结束
}
```

---

## 作者：ZXXS (赞：1)

### 题目大意
  $T$ 组数，每一组选取两个数减一，另一个数加二，问最后让其中两个数为 $0$ 的次数，不能则输出 $-1$。
### 做法

- 先排序。

- 找有没有两个相同的数,找到了就直接输出其中一个。

原因：找到两个数就可以让他们同时不断减一，最后这两个数可以同时清零，剩下第三个数。

- 找是否有两个数的差值为三的倍数，找到就更新最小值。

原因：每次操作会让两个数减一，另一个数加二,所以一个数会与另外两个数的差距缩小三。如果有两个数的差值为三的倍数，就能让他们两个数归零，次数为 $\min(a,b)$。

- 没有差值为三的倍数的即为无解。

原因：每次操作会让一个数与另外两个数的差距缩小三，而三个数中没有两个数差值为三的倍数的，就不可能清零。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m,a[10];
int main()
{
    int T;
    cin>>T;
    while(T--)
	{
        cin>>a[1]>>a[2]>>a[3];
        sort(a+1,a+4);//升序排序
        if(a[1]==a[3])//找有没有相同的
		{
            printf("%d\n",a[1]);
            continue;
        }
        if(a[1] == a[2])
		{
            printf("%d\n",a[1]);
            continue;
        }
        if(a[2] == a[3])
		{
            printf("%d\n",a[2]);
            continue;
        }
        int minn=2147483647;
        if((a[2]-a[1])%3==0)//差值为三就更新最小值
		{
            minn=min(a[2],minn);
        }
        if((a[3]-a[1])%3==0)
		{
            minn=min(a[3],minn);
        }
        if((a[3]-a[2])%3==0)
		{
            minn=min(a[3],minn);
        }
        if(minn!=2147483647) //更新过就输出
			printf("%d\n",minn);
        else 
			printf("-1\n");//没更新过就无解
    }
    return 0;
}

```

---

## 作者：Fire_flys (赞：0)

我们随便的模拟一下，如果两个颜色的各少了一个，那么另外一个颜色就会多出两个，再稍微做一下差就可以发现这个题就是与三种球的数量模掉三的余数有关。因此我们只需要算出三种球模掉三的余数，再看看是否三个余数都不同，如果都不同就是无解。如果第一种球与第二种球模三的余数相等，则答案就是在第一种球和第二种球的数量之间取最大值再跟原来的答案比较。以此类推我们把三种余数相等的情况都计算一遍得出来的答案就是最终答案。最后不要忘记把答案初始化为最大值。
```
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int t;
	cin>>t;
	while(t--){
		int r,g,b;
		cin>>r>>g>>b;
		int r1=r%3,r2=g%3,r3=b%3;
		if(r1!=r2&&r2!=r3&&r1!=r3){
			cout<<"-1\n";
			continue;
		}
		int ans=inf;
		if(r1==r2)ans=min(inf,max(r,g));
		if(r2==r3)ans=min(ans,max(g,b));
		if(r1==r3)ans=min(ans,max(b,r));
		cout<<ans<<'\n';
	}
	return 0;
}

```

---

## 作者：under_the_time (赞：0)

## 题意

> 给你 $3$ 个正整数 $A,B,C$，每次操作可以选定其中的两个数减一使剩下的一个数加二。求使 $A,B,C$ 中两个数变成 $0$ 的最少操作步数或无解。
>
> $A,B,C\le 10^8$，$T$ 组数据，$T\le 100$。

## 解法

如果有数量相等的球直接换即可，否则需要构造出两个相等的数。设初始值为 $x,y$的数被消为 $0$，令 $x\le y$，剩下一个数值为 $z$；那么考虑将 $x,z$ 不断换成 $y$ 使得 $x=y$ 后进行消除。设要换 $k$ 次，那么有
$$
x-k=y+2k\\
\therefore k=\cfrac{x-y}{3}
$$
若 $x-y\equiv0\pmod3$ 成立，观察到 $x$ 每一个步骤都会 $-1$，最终就需要 $x$ 次，否则此时无解。如果一开始 $z$ 不够换的，那么可以先将 $x,y$ 换若干次换成 $z$ 再开始上述步骤，$x$ 仍然减了若干次 $1$，不影响总步数。不过程序里没有表现出来。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int inf = 1e18;
int check(int x, int y, int z) {
    if (z > x) return inf;
    if (x % 3 != z % 3) return inf;
    return x;
}
signed main() {
    int T, r, g, b;
    for (scanf("%lld", &T); T --; ) {
        int ans = inf;
        scanf("%lld %lld %lld", &r, &g, &b); 
        if (r == g || r == b || g == b) {
            if (r == g || r == b) ans = min(ans, r);
            if (g == b) ans = min(ans, g);
        } 
        int S[6] = { check(r, g, b), check(r, b, g), check(b, r, g), check(b, g, r), check(g, r, b), check(g, b, r) };
        for (int i = 0; i < 6; i ++) ans = min(ans, S[i]);
        if (ans == inf) ans = -1;
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：王逸辰 (赞：0)

# AT_arc128_b [ARC128B] Balls of Three Colors 题解
## 思路
一个数减一，另一个数加二，他们的差便为三。

于是我们只需枚举不变的数，看其他的数是否除以三同余即可。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,f[5];
int main(){
	cin>>T;
	for(int i=(1); i<=T; ++i){
		cin>>f[1]>>f[2]>>f[3];
		sort(f+1,f+3+1);
		int a=f[2]-f[1];
		int b=f[3]-f[2];
		int c=f[3]-f[1];
		if(f[1]==f[2]||f[1]==f[3])
			cout<<f[1]<<endl;
		else if(f[2]==f[3]||a%3==0)
			cout<<f[2]<<endl;
		else if(b%3==0||c%3==0)
			cout<<f[3]<<endl;
		else
			cout<<-1<<endl;
	}
	return 0;
}
```

---

## 作者：nkrqzjc_zzz (赞：0)

### [题目链接](https://www.luogu.com.cn/problem/AT_arc128_b)

------------

### 思路

看到这题，就应该想到了，很简单。首先因为本题删除操作最快就是减一，所以如果有两数相同那么答案就直接出来了。

接下来我们分析题目，看还有没有可以得出答案的方法，因为本题操作是两个数减一，一个数加二，本质意思就是让那个加的数对于两个减的数来说加三。

加三？我们就很好办了。判断一下有没有两数之间相差三的倍数。如果有就有答案，没有的话，就没有答案了。

### 代码

详情看代码。

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int t,r,g,b;//所有变量名如题意 
int main(){
	cin>>t;
	while(t--){
		cin>>r>>g>>b;
		if(r==g)cout<<r<<'\n';
		else if(r==b)cout<<r<<'\n';
		else if(g==b)cout<<g<<'\n';
		//以上为两数相等的情况
		else{
			//以下是判断两数是否相差三的倍数的情况 
			int dn=1145141919;//dn为存储答案的变量（初始化很恶臭） 
			if(abs(r-b)%3==0)dn=min(dn,max(r,b));
			if(abs(g-b)%3==0)dn=min(dn,max(g,b));
			if(abs(r-g)%3==0)dn=min(dn,max(r,g));
			//注意！这里的答案需要多次更新，因为可能不仅仅只有两个数相差三的倍数 
			if(dn==1145141919)puts("-1");
			else cout<<dn<<endl;
		}
	}
	return 0;
}
```


---


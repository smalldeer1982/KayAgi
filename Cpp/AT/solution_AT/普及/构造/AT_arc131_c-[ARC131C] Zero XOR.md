# [ARC131C] Zero XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc131/tasks/arc131_c

机の上に $ N $ 枚のクッキーがあります。クッキーの表面にはそれぞれ正の整数 $ A_1,\ A_2,\ \dots,\ A_N $ が書かれており、これらはすべて異なります。

このクッキーを使って 2 人でゲームを行います。このゲームでは、各プレイヤーは次の行動を交互に行います。

> 机にあるクッキーを 1 枚選んで食べる。  
>  その際に、机に残ったクッキーに書かれた整数の $ \mathrm{XOR} $ が $ 0 $ になったならば、そのプレイヤーは勝利し、ゲームは終了する。

あなたは E869120 君に対戦を申し込みました。あなたは先手で、E869120 君は後手です。さて、両者が最適に行動したときに、あなたは E869120 君に勝ちますか？

  $ \mathrm{XOR} $ とは  整数 $ A,\ B $ のビット単位 XOR、$ A\ \mathrm{XOR}\ B $ は、以下のように定義されます。

- $ A\ \mathrm{XOR}\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \mathrm{XOR}\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \mathrm{XOR}\ 101\ =\ 110 $)。  
 一般に、$ k $ 個の整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 XOR は $ (\dots\ ((p_1\ \mathrm{XOR}\ p_2)\ \mathrm{XOR}\ p_3)\ \mathrm{XOR}\ \dots\ \mathrm{XOR}\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots\ p_k $ の順番によらないことが証明できます。特に $ k\ =\ 0 $ の場合、$ \mathrm{XOR} $ は $ 0 $ となります。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 400000 $
- $ 1\ \leq\ A_i\ \leq\ 10^9\ (1\ \leq\ i\ \leq\ N) $
- $ A_1,\ A_2,\ \dots,\ A_N $ はすべて異なる
- $ A_1,\ A_2,\ \dots,\ A_N $ の $ \mathrm{XOR} $ は $ 0 $ ではない
- 入力はすべて整数

### Sample Explanation 1

この例では、あなたがどんな方法を使っても、E869120 君が最適に行動し続ければ負けてしまいます。 例えば、最初に $ 11 $ が書かれたクッキーを食べるとしましょう。すると、次に E869120 君が $ 9 $ が書かれたクッキーを食べることで、残ったクッキーに書かれた数 $ 14,\ 3,\ 5,\ 8 $ の $ \mathrm{XOR} $ が $ 0 $ になるので、E869120 君が勝ちます。 それ以外の行動をとっても、最終的には E869120 君が勝ちます。

### Sample Explanation 2

この例では、あなたは最初のターンで $ 131 $ が書かれたクッキーを食べることしかできません。すると、机の上からクッキーがなくなるので、残ったクッキーに書かれた数の $ \mathrm{XOR} $ は $ 0 $ になります。したがって、E869120 君が何もできないまま、あなたが勝ちます。

## 样例 #1

### 输入

```
6
9 14 11 3 5 8```

### 输出

```
Lose```

## 样例 #2

### 输入

```
1
131```

### 输出

```
Win```

## 样例 #3

### 输入

```
8
12 23 34 45 56 78 89 98```

### 输出

```
Win```

# 题解

## 作者：loser_seele (赞：7)

结论：当 $ N $ 为奇数则先手必胜，否则如果先手第一步能成功则显然先手必胜，剩余情况后手必胜。

证明也很显然：考虑奇数的情况，如果先手第一回合获胜则游戏结束，否则我们需要证明后手一定无法第二回合内获胜。

首先显然由于异或的消去性质，设当前异或为 $ K $，必须满足对于所有的 $ i $，都有 $ K \oplus i \in a $。而由于所有的 $ a_i $ 互不相同，则显然这些值两两配对，又由于 $ n $ 为奇数，所以总存在一个没有配对的位置，这样后手无法在两步内获胜。

于是先手要么在 $ n $ 的时候获胜，要么转移到 $ n-2 $ 的状态，而 $ n=1 $ 的时候显然先手获胜，于是先手总是获胜。

回到 $ n $ 为偶数，如果先手第一局无法获胜，则后手变为先手，$ n $ 变为奇数，则后手显然必胜。

时间复杂度 $ \mathcal{O}(n) $，可以通过。

代码：

```cpp
#import<bits/stdc++.h>
using namespace std;
int main() 
{
	int N;
	cin>>N;
	int X=0,A[N];
	for (int i=0;i<N;i++) 
	{
		cin>>A[i];
		X^=A[i];
	}
	if(N&1)
	    return !printf("Win\n"); 
	else
	    for (int i=0;i<N;i++)
	      if(A[i]==X)
	        return !printf("Win");
	printf("Lose");
}
```


---

## 作者：fish_love_cat (赞：5)

# 1 题意

输入一个长度为 $n$ 的数列，保证数字**两两不同**，两名玩家轮流对该数列进行删数的操作，最终的获胜者为操作后使整个数列的**异或和等于 0** 的玩家。

如果**先手**的玩家有必胜策略，那么输出：
```Win``` 。

不然输出：
```Lose``` 。

# 2 思路&代码1.0

我们可以假设，两名玩家把整个数列内的数字全部给删了，那么此时数列的异或和是 0 无疑。那么，只要 $n$ 是**奇数**，先手就会是删最后一个数字的人，同时，也就是赢家。

根据上文的思路，我们可以得出如下代码：

~~抄题解的先等等，这还不是正解。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    if(n%2) cout<<"Win";
    else cout<<"Lose";
    return 0;
}
```

[Wrong Answer.](https://www.luogu.com.cn/record/102554796)

# 3 思路&代码2.0

其实大家可能都已经发现了，样例三很好的证明了这种做法是错误的，而它的错就错在并没有去考虑一击必杀的情况。**因为就算 $n$ 为偶数，若能一击必杀，那么照样是先手获胜。**

那么，我们应该如何判断是否会出现一击必杀的情况呢？我们可以先计算出**整个数列的异或和**，如果说异或和与数列中的某个数字**相等**，那么删去了该数后，剩下的数字的异或和必将为 0 。那么，先手便可直接获胜了。

由此，我们就可以写出正确的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[410086];
int main(){
    int n,ans=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>x[i];
        ans^=x[i];
    }
    if(n%2==1){
        cout<<"Win";
        return 0;
    }else{
        for(int i=0;i<n;i++){
            if(ans==x[i]){
                cout<<"Win";
                return 0;
            }
        }
    }
    cout<<"Lose";
    return 0;
}
```

[Accepted.](https://www.luogu.com.cn/record/102556249)

---

## 作者：ice_fish01 (赞：1)

## $\text{AT\_arc131\_c [ARC131C] Zero XOR}$ 题解

### 思路分析

考虑一个简单的问题：如果某一刻数列中所有数均为 $0$，那么它们的异或值也一定为 $0$。所以我们可以逆推，发现**当 $n\bmod2=1$，即 $n$ 为奇数时，先手必胜**。可以写出如下代码：

```cpp
cin >> n;
if (n & 1) { //如果 n 为奇数则先手必胜 
   puts("Win");
   return 0;
}
```

但它并不能通过本题，因为存在一种数列，使得先手在 $1$ 次修改后便能使得异或值为 $0$。所以，我们可以计算一遍数列的异或值，再扫一遍每一个数，如果存在一个去除了 $A_i$ 的数列 $B$ 使得 $B_1\;\text{XOR}\;B_2\;\text{XOR}\;\cdots\;\text{XOR}\;B_n=A_i$，那么先手一定可以获胜。

注意到 $1\le N\leq 400000=4\times10^5$，所以代码中使用了快读进行优化。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T> //快读，可跳过 
inline void read(T &x) {
    x = 0;
    int f = 1;
    char c = getchar();

    while (!isdigit(c)) {
        if (c == '-')
            f = -1;

        c = getchar();
    }

    while (isdigit(c)) {
        x = x * 10 + c - '0';
        c = getchar();
    }

    x *= f;
}
template<typename T, typename ... Args>
inline void read(T &x, Args &... y) {
    read(x);
    read(y...);
}

int main() {
    int a[400010], n, y = 0, cnt = 0;
    read(n);

    if (n & 1) { //如果堆数为奇数则先手必胜 
        puts("Win");
        return 0;
    }

    for (int i = 1; i <= n; i++) {
        read(a[i]);
        y ^= a[i]; //求异或值 
    }

    for (int i = 1; i <= n; i++) {
        if (a[i] == y) //如果能够删去 a[i] 使得异或值为 0 
            cnt++;
    }

    if (cnt >= 1) //至少一个数满足 
        puts("Win");
    else
        puts("Lose");

    return 0;
}
```

---

## 作者：fengyuxuan (赞：0)

## 题目大意
有一数字个数为 $n$ 的数列，且每个数个不相同。

两个玩家轮流操作，每次操作将某一数变为 $0$，当操作后,如果所有数的异或和为 $0$，则该玩家获胜。

若先手有必胜策略，输出 `Win` ，否则输出 `Lose` 。

## 题目分析

首先我们知道：
$$\begin{matrix}\underbrace{0\oplus0\oplus0\oplus\cdots\oplus0\oplus0\oplus0}\\n\end{matrix}=0$$
这说明我们只要把每一个数都变为 $0$ 所有数的异或和就能变为 $0$。每个人操作 $1$ 那么 $n$ 个数就要操作 $n$ 次，而如果当 $n$ 为奇数，最后一个数就一定是先手操作的，同时先手也就是赢家（代码如下）。
```cpp
if(n%2==1)
	cout<<"Win";
```
但是当 $n$ 为偶数，就一定没有必胜策略吗？

怎么可能！样例 $3$ 说明 $n$ 为偶数时也是可能有必胜策略的：

分析一下，如果 $n$ 为偶数，那么当先手操作 $1$ 次后，剩下就是 $n-1$ 个数，个数是奇数，而此时的后手也会变成先手，根据以上的结论，此时后手必胜。

所以此时先手赢的机会只有在第一次操作时候，也就是如果只操作一次就能使所有数的异或和为 $0$，换句话就是如果除了某个数以外其他数的异或和为 $0$，先手就能赢。

而我们知道异或的逆运算还是异或，那只要先求出所有数的异或和，再一一枚举每个数，用总的异或和异或一下枚举的数，那么当前枚举的这个数就能被抵消，而剩下的就是除它外其他数的异或和了，接着我们再根据以上结论判断即可。

## 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[400005],x;
bool flag;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		x^=a[i];//求出所有数的异或和
	}
	if(n%2==1)//n为奇数先手就肯定有必胜策略
		cout<<"Win";
	else
	{
		flag=false;
		for(int i=1;i<=n;i++)//一一枚举每个数
			if((x^a[i])==0)
				flag=true;
		if(flag)
			cout<<"Win";
		else
			cout<<"Lose";
	}
	return 0;
}

```


---

## 作者：Moon_Traveller (赞：0)

[>> 传送门 <<](https://www.luogu.com.cn/problem/AT_arc131_c)

[>> 原 OJ 传送门 <<](https://atcoder.jp/contests/arc131/tasks/arc131_c)

### 题目大意

~~题目已经讲的很清楚了，应该不用再说了吧（~~

给出 $n$ 个数，两个人轮流对这些数进行操作。

每一次可以把任意一个数变为 $0$，如果变换后的 $A_1 \oplus A_2 \oplus \dots \oplus A_n = 0$，则这个人获胜。

如果先手有必胜策略，输出 `Win`，否则输出 `Lose`。

### XOR / $\oplus$ / 异或 是什么

简单来说，如果 $a,b$ 两个值不相同，则异或结果为 $1$。如果 $a,b$ 两个值相同，异或结果为 $0$。

~~以上摘自[百度百科](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)~~

另外，异或有一些常用的运算律，比如 $a \oplus 0 = a$，具体可以看看百度百科。

### 思路

首先，题目中的取胜条件可能有些迷惑。但是，异或中存在“恒等律”，即 $a \oplus 0 = a$。这样，我们可以把取胜条件变为：_如果变换后的**剩余数字**的异或和为 $0$，则这个人获胜_。

假设我们把所有的数都设成 $0$，那么不难想出，**如果 $n$ 为奇数**，则先手一定是变换最后一个数字的人（此时其他数字都已变为 $0$），那么**先手必胜**。

那是不是说明，如果 $n$ 为偶数，先手就一定没有必胜策略呢？

并不是。我们再看看 $a \oplus 0 = a$ 这个公式，就可以想到：**如果先手第一个操作的数字等于所有数字的异或和**，那么其他数字的异或和就等于 $0$，**先手必胜**。

总结一下：

1. **如果 $n$ 为奇数，先手必胜。**
2. **如果先手第一个操作的数字等于所有数字的异或和，先手必胜。**
3. **否则，先手没有必胜策略。**

### 代码

```cpp
#include <iostream>
using namespace std;

int n;
int a[400005];
int sum = 0; // 因为 a XOR 0 = a，所以把 sum 的初始值设为 0。

int main()
{
    cin >> n;
    if(n % 2 == 1) // （这里可以用 if(n & 1) 优化一下，会快一点，但是对于这道题没有必要。不懂的自行了解，这里不过多介绍。）
    {
        cout << "Win" << endl; // 对应第一个结论。
        return 0;
    }
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
        sum ^= a[i]; // 热知识：c++ 中的 ^ 运算符就是异或。
    }
    for(int i = 1; i <= n; i++)
    {
        if(sum == a[i])
        {
            cout << "Win" << endl; // 对应第二个结论。
            return 0;
        }
    }
    cout << "Lose" << endl; // 对应第三个结论。
    return 0;
}
```

### 还有什么

如果你对 异或 感兴趣，可以顺便切了这道题：

[P9227 异或积](https://www.luogu.com.cn/problem/P9227)

---


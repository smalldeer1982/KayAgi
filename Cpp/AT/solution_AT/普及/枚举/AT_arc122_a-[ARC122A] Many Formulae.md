# [ARC122A] Many Formulae

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc122/tasks/arc122_a

長さ $ N $ の非負整数列 $ A_1,A_2,\cdots,A_N $ が与えられます．

この数列の隣接する $ 2 $ 項の間に `+` または `-` を入れて，一つの式を作ることを考えます．

式を作る方法は $ 2^{N-1} $ 通りありますが，この中でも以下の条件を満たす式を，**良い式**と呼ぶことにします．

- `-` が $ 2 $ 回以上連続で登場しない．

全ての良い式の値を足し合わせた値を求めて下さい． なお，この値はかならず非負整数となることが証明できます． そこで，この値を $ 10^9+7 $ で割った余りを出力してください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数である

### Sample Explanation 1

以下の $ 3 $ 通りの良い式が考えられます． - $ 3+1+5=9 $ - $ 3+1-5=-1 $ - $ 3-1+5=7 $ $ 3-1-5 $ は `-` が $ 2 $ 回以上連続で登場するため，良い式ではありません． よって，答えは $ 9+(-1)+7=15 $ となります．

### Sample Explanation 2

以下の $ 5 $ 通りの良い式が考えられます． - $ 1+1+1+1=4 $ - $ 1+1+1-1=2 $ - $ 1+1-1+1=2 $ - $ 1-1+1+1=2 $ - $ 1-1+1-1=0 $ よって答えは $ 4+2+2+2+0=10 $ となります．

### Sample Explanation 3

答えを $ 10^9+7 $ で割った余りを出力してください．

## 样例 #1

### 输入

```
3
3 1 5```

### 输出

```
15```

## 样例 #2

### 输入

```
4
1 1 1 1```

### 输出

```
10```

## 样例 #3

### 输入

```
10
866111664 178537096 844917655 218662351 383133839 231371336 353498483 865935868 472381277 579910117```

### 输出

```
279919144```

# 题解

## 作者：under_the_time (赞：0)

## 题意

> 给定长度为 $n$ 的正整数序列 $a$。你可以决定 $a$ 的每一项是否取负（特别地，$a_1$ 必须为正），要求不能出现连续的两项均为负数，然后将 $a$ 求和。求所有合法的 $a$ 的各项之和的和。
>
> $n\le 2\times 10^5$，$1\le a_i\le 10^9$。

## 解法

考虑 dp。先设 $f(i,0/1)$ 表示考虑能得到的 $a$ 中 $[1,i]$ 的部分求和的和，$a_i$ 为正还是为负。错误的转移如下：
$$
\begin{cases}f(i,0)=f(i-1,0)+f(i-1,1)+a_i\\
f(i,1)=f(i-1,0)-a_i\end{cases}
$$
意义即为：$a_i$ 取正对前一位没有正负的要求，$a_i$ 取负则前一位只能取正，错误原因是我们不知道 $a_i$ 会贡献几次，于是我们再设 $g(i,0/1)$ 表示 $a_i$ 取正、取负的方案数，转移如下：
$$
\begin{cases}g(i,0)=g(i-1,0)+g(i-1,1)\\g(i,1)=g(i-1,0)\end{cases}
$$
那么 $f$ 转移可以更正为：
$$
\begin{cases}f(i,0)=f(i-1,0)+f(i-1,1)+g(i,0)\times a_i\\
f(i,1)=f(i-1,0)-g(i, 1)\times a_i\end{cases}
$$
先转移 $g$ 再转移 $f$ 即可。时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5, P = 1e9 + 7;
int a[maxn], n;
int f[maxn][2], g[maxn][2];
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	f[1][0] = a[1], f[1][1] = 0, g[1][0] = 1, g[1][1] = 0;
	for (int i = 2; i <= n; i ++) { 
		g[i][0] = (1ll * g[i - 1][0] + g[i - 1][1]) % P, g[i][1] = g[i - 1][0];
		f[i][0] = ((1ll * f[i - 1][0] + 1ll * f[i - 1][1]) % P + 1ll * g[i][0] * a[i] % P) % P,
		f[i][1] = ((1ll * f[i - 1][0] + P) - 1ll * g[i][1] * a[i] % P) % P;
	}
	printf("%lld\n", (1ll * f[n][0] + 1ll * f[n][1]) % P);
	return 0;
}
```

---

## 作者：zzh0755 (赞：0)

### 题意：
读入 $n$ 个数字，进行 $+$ 或 $-$ 的操作，其中 $-$ 操作不能连续进行两次或两次以上，求所有可能情况的和。

### 思路：
$dp[i][0]$ 表示以 $+a[i]$ 结尾的和，$cnt[i][1]$ 表示以 $-a[i]$ 结尾和；
$cnt[i][0]$ 表示以 $+a[i]$ 结尾的个数，$cnt[i][1]$ 表示以 $-a[i]$ 结尾的个数。

由此可得：

$\begin{cases} dp[i][0]=(dp[i−1][0]+dp[i−1][1])+(cnt[i−1][0]+cnt[i−1][1])×a_{i} \\
dp[i][1]=dp[i−1][0]—cnt[i−1][0]×a_{i} 
\end{cases}$

$\begin{cases}
cnt[i][0]=cnt[i−1][0]+cnt[i−1][1]\\ cnt[i][1]=cnt[i−1][0]
\end{cases}$
 
答案为 $dp[n][1] + dp[n][0]$。

注意到减法的取模运算，进行取模后可能是负数，所以要用以下方法取模：
```cpp
ll MOD (ll x) {
	return (x % mod + mod) % mod;
}

```
 代码如下：
```cpp
#include <bits/stdc++.h>//万能头最棒力
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7, N = 1e6 + 10;
ll dp[N][2], a[N], m[N], cnt[N][2];
ll MOD (ll x) { 
    return (x % mod + mod) % mod; 
} 
int main () { 
    int n; 
    cin >> n;
    for (int i = 1; i <= n; i ++){
        cin >> a[i];
        a[i] %= mod;
    }
    if (n == 1){
        cout << a[1] % mod << endl;
        return 0；
    }
    dp[2][0] = MOD(a[1] + a[2]);
    dp[2][1] = MOD(a[1] - a[2]);
    cnt[2][0] = 1;
    cnt[2][1] = 1;
    for (int i = 3; i <= n; i ++){
        dp[i][0] = ((dp[i - 1][0] % mod + dp[i - 1][1] % mod) + (cnt[i - 1][0] % mod + cnt[i - 1][1] % mod) * a[i] % mod) % mod;
        cnt[i][0] = (cnt[i - 1][0] % mod + cnt[i - 1][1] % mod) % mod;
        dp[i][1] = MOD(dp[i - 1][0] % mod - cnt[i - 1][0] * a[i] % mod);
        cnt[i][1] = cnt[i - 1][0] % mod;
    }
    cout << (dp[n][0] + dp[n][1]) % mod << endl;
    return 0;
}
```


---


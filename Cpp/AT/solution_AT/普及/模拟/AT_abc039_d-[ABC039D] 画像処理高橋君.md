# [ABC039D] 画像処理高橋君

## 题目描述

对一幅黑白图像进行“收缩”处理。

“收缩”是指，对于每个像素，如果在它周围（$8$个方向）有一个黑色的像素，即将该像素视为黑色。

给你一幅被收缩过的图像，判断是否有一幅图像可以通过收缩得到这幅图像。如果有，请复原其中之一。
图像是由 $H$ 行 $W $ 列字符组成的图形。

## 样例 #1

### 输入

```
4 4
##..
##..
..##
..##```

### 输出

```
possible
#...
....
....
...#```

## 样例 #2

### 输入

```
4 4
###.
####
..##
..##```

### 输出

```
possible
##..
....
...#
...#```

## 样例 #3

### 输入

```
4 4
###.
##.#
..##
..##```

### 输出

```
impossible```

# 题解

## 作者：q779 (赞：4)

**题意**：给出压缩后的图像，求压缩前的图像


压缩是指对于各个像素，在其周围8个方向的像素中，**只要有一个黑色像素，其像素就会变黑的处理**

从这句可以初步推断出，~~只要是~~**周围8个方向上都是黑色的像素就是压缩前存在的黑色像素**
例如

```latex
###..
###..
.....
```


压缩前的图像就是
```latex
##...
.....
.....
```
 _~~这么说来只要扫一遍，把和白色像素相接的黑色像素全部变为白色不就好了？~~_ 

但是如果是下面这种情况
```latex
###.
##.#
..##
..##
```
用刚才的思路做，会得到这样的图像
```latex
#...
....
....
...#
```
这样就出现了问题

如果把得到的这个图像压缩，得到的应该是
```latex
#...          ##..
....    ->    ##..
....          ..##
...#          ..##
```
这样就还得再检查一遍得到的图像是否合法

代码如下
```cpp
//AT1899
#include<bits/stdc++.h>
using namespace std;
int n,m;
char a[205][205];//记录压缩后的图像（即输入的图像）
char b[205][205];//用于输出压缩前的图像
int dx[9]={1,1,1,0,0,0,-1,-1,-1};//八个方向+原地
int dy[9]={1,0,-1,1,0,-1,1,0,-1};
signed main()
{
    cin>>n>>m;
    for(int i=0; i<n; i++)
        cin>>a[i];//输入
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<m; j++)
        {
            int flag=0;
            for(int k=0; k<9; k++)
            {
                int tx = i+dx[k];
                int ty = j+dy[k];
                if(tx>=0&&ty>=0&&tx<n&&ty<m&&a[tx][ty]=='.')flag=1;
            }
            if(flag)b[i][j]='.';//如果这个像素本来就是白的，或者这是个和白色像素相连的黑色像素
            else b[i][j]='#';//不和白色像素相连的黑色像素
        }
    }
        
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<m; j++)
        {
            if(a[i][j]=='#')//检查压缩后的图像
            {
                int flag=0;
                for(int k=0; k<9; k++)
                {
                    int tx = i+dx[k];
                    int ty = j+dy[k];
                    if(tx>=0&&ty>=0&&tx<n&&ty<m&&b[tx][ty]=='#')flag=1;//该像素是压缩出来的
                }
                if(!flag)//得到的压缩前的图像 无法压缩为 压缩后的图像
                {
                    cout<<"impossible"<<endl;//不是合法压缩出来的图像
                    return 0;
                }
            }
        }
    }
    cout<<"possible"<<endl;//合法
    for(int i=0; i<n; i++)
    {    
        for(int j=0; j<m; j++)
        {
            cout<<b[i][j];
        }
        cout<<endl;
    }
    return 0;//完结撒花>_<
}
```
这是我第一次提交题解，有问题的地方欢迎各位指出>_<

---


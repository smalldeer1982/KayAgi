# [ABC184C] Super Ryuma

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc184/tasks/abc184_c

無限に広がる $ 2 $ 次元グリッドがあり、マス $ (r_1,\ c_1) $ に駒「超竜馬」が置かれています。  
 この駒は、 $ 1 $ 手で次のような動きができます。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc184_c/5bfa39c442ba1e792051275842c037db26123fff.png)

より正確には、超竜馬がマス $ (a,\ b) $ にあるとき、以下のいずれかの条件を満たすマス $ (c,\ d) $ に動かすことができます。

- $ a\ +\ b\ =\ c\ +\ d $
- $ a\ -\ b\ =\ c\ -\ d $
- $ |a\ -\ c|\ +\ |b\ -\ d|\ \le\ 3 $

超竜馬を $ (r_1,\ c_1) $ から $ (r_2,\ c_2) $ に動かすのに必要な最小手数を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ r_1,\ c_1,\ r_2,\ c_2\ \le\ 10^9 $

### Sample Explanation 1

例えば、 $ (1,\ 1)\ \rightarrow\ (5,\ 5)\ \rightarrow\ (5,\ 6) $ と動かすと $ 2 $ 手になります。

### Sample Explanation 2

例えば、 $ (1,\ 1)\ \rightarrow\ (100001,\ 100001)\ \rightarrow\ (1,\ 200001) $ と動かすと $ 2 $ 手になります。

### Sample Explanation 3

例えば、 $ (2,\ 3)\ \rightarrow\ (3,\ 3)\ \rightarrow\ (-247,\ 253)\ \rightarrow\ (998244353,\ 998244853) $ と動かすと $ 3 $ 手になります。

## 样例 #1

### 输入

```
1 1
5 6```

### 输出

```
2```

## 样例 #2

### 输入

```
1 1
1 200001```

### 输出

```
2```

## 样例 #3

### 输入

```
2 3
998244353 998244853```

### 输出

```
3```

## 样例 #4

### 输入

```
1 1
1 1```

### 输出

```
0```

# 题解

## 作者：yinbe (赞：3)

## 题目描述

有一个无限大的棋盘，棋盘上的点 $(a,b)$ 能一步走到 $(c,d)$，当且仅当下面的三条条件至少一条成立：

- $a+b=c+d$
- $a-b=c-d$
- $|a-c|+|b-d|\le 3$

求 $(r_1,c_1)$ 走到 $(r_2,c_2)$ 的最少步数。

### 数据范围

- $1\ \le\ r_1,\ c_1,\ r_2,\ c_2\ \le\ 10^9$

---

## 思路

操作 $1$ 和操作 $2$ 本质上就是走斜线，操作 $3$ 就是走到距离自己距离不超过 $3$ 的点。

这道题看起来很简单，实际上想要不重不漏的把所有情况分类讨论出来还是很难的。

先来证明一个答案的性质：**答案最大不会超过 3**。

![](https://cdn.luogu.com.cn/upload/image_hosting/cewp7yoa.png)

如上图，我们可以将棋盘的点用类似国际象棋的方式标记成黑白两色，显然，当起点与终点颜色相同时，我们最多只需要像上图一样走两次斜线即可。

当起点与终点颜色不同时，我们只需要从起点往左一格就可以转换成上一种情况，此时最多需要走三次。

所以，**答案最大不会超过 3**。

这样，我们就可以开始按照走的次数进行分类讨论。

---

### 第一类：答案为 $0$ 的情况

显然，当起点与终点重合时，答案为 $0$。

### 第二类：答案为 $1$ 的情况

按照题目中一步能走到的地方进行判断即可，即当满足下面条件中的一条时，答案为 $1$：

- $a+b=c+d$
- $a-b=c-d$
- $|a-c|+|b-d|\le 3$

### 第三类：答案为 $2$ 的情况

这是我认为最难的情况，很容易少分类或分错。

首先是只走斜线的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/cewp7yoa.png)

把上面的图搬过来，显然，当起点和终点同色时，答案为 $2$。

怎么判断起点与终点同色呢？首先，同色的格子一定会形成若干个斜线，而这些斜线分成两种：

1. 从左上到右下的斜线，这种斜线上的点的横坐标与纵坐标之和相等，显然，他们的和模 $2$ 的余数也会相等。

![](https://cdn.luogu.com.cn/upload/image_hosting/lp8qztho.png)

如上图，绿线上的点的横坐标与纵坐标之和模 $2$ 的余数相等。

2. 从左上到右下的斜线，它们从上到下的横坐标与纵坐标会依次加一，也就是横坐标与纵坐标之和会依次加二，这样模 $2$ 的余数也不会变。

![](https://cdn.luogu.com.cn/upload/image_hosting/1jydd8cr.png)

例如：如上图，图中有一条从左上到右下的斜线经过了 $(5,1)$，$(6,2)$，$(7,3)$，横坐标与纵坐标之和依次是 $6,8,10$，模 $2$ 的余数都是 $0$。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/beufya18.png)

如上图，把两种斜线叠在一起，斜线上的方格的横坐标与纵坐标之和模 $2$ 的余数都相等，显然，这样的斜线将所有的黑色的方格连接了起来，也就是说，所有的黑色方格的横坐标与纵坐标之和模 $2$ 的余数都相等，白方格也同理。

所以，当起点的横坐标与纵坐标之和模 $2$ 的余数与终点的横坐标与纵坐标之和模 $2$ 的余数相等时，答案为 $2$。

用数学符号来表示就是：

- $(a+b) \equiv (c+d) \pmod 2$

---

然后是不走斜线，直接移动 $2$ 次移动到距离小于等于 $6$ 的情况，即当满足下面条件时答案为 $2$：

- $|a-c|+|b-d|\le 6$

---

接着是先移动一次移动到距离小于等于 $3$ 的点，再走一次斜线的情况。

移动一次后横坐标与纵坐标之和 $a+b$ 就会变成 $a+b+p(-3 \le p \le 3)$，横坐标与纵坐标之差 $a-b$ 也会变成 $a-b+p(-3 \le p \le 3)$，而走斜线一次可以走到要满足一下条件中的一个：

- $a+b=c+d$
- $a-b=c-d$

因为 $a+b$ 变成了 $a+b+p(-3 \le p \le 3)$，$a-b$ 变成了 $a-b+p(-3 \le p \le 3)$。

所以条件就变成了：

- $a+b+p=c+d$
- $a-b+p=c-d$

移项得：

- $(a+b)-(c+d)=p$
- $(a-b)-(c-d)=p$

因为 $-3 \le p\le 3$。

代入得：

- $-3 \le (a+b)-(c+d) \le 3$
- $-3 \le (a-b)-(c-d) \le 3$

为了判断方便，我们可以套一个绝对值，就变成了：

- $\left | (a+b)-(c+d) \right |\le 3$
- $\left | (a-b)-(c-d) \right |\le 3$

---

综上所述，当满足一下条件中的一个，答案就是 $2$。

- $(a+b) \equiv (c+d) \pmod 2$
- $|a-c|+|b-d|\le 6$
- $\left | (a+b)-(c+d) \right |\le 3$
- $\left | (a-b)-(c-d) \right |\le 3$

### 第四类：答案为 $3$ 的情况

因为答案不会超过 $3$，所以剩下的情况答案就全部是 $3$。

---

## 代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a,b,c,d; 
int main()
{
	scanf("%d%d%d%d",&a,&b,&c,&d);
	if(a==c&&b==d)
        printf("0");
	else if(a+b==c+d||a-b==c-d||abs(a-c)+abs(b-d)<=3)
		printf("1");
	else if((a+c)%2==(b+d)%2)
		printf("2");
	else if(abs(a-c)+abs(b-d)<=6)
		printf("2");
	else if(abs((a+b)-(c+d))<=3)
		printf("2");
	else if(abs((a-b)-(c-d))<=3)
		printf("2");
	else
		printf("3");
	return 0;
}
```

---

## 作者：chrispang (赞：0)

## 题目大意

给定一个无限大的棋盘，你有两种走法从起点走到终点，一种是走斜线，另一种是走 $3$ 格以内，问到达终点最少需要走几步？

## 题目分析

首先，证明需要的移动步数 $<$ $3$。

我们可以对这个棋盘染色，就像我们的国际象棋棋盘一样：

![](https://cdn.luogu.com.cn/upload/image_hosting/8o69t4ia.png)

之后，我们可以观察到两个结论：

- 第一条：如果起点与终点同色，那么可以在两步以内到达终点（形象地想一下，左斜跳一下，右斜跳一下）
- 第二条：如果起点与终点异色，那么可以往上下左右移动一步，再接着就是第一条结论了。

因此，最多只需要走三步就可以到终点了。

那么我们开始分析吧！

---

设起点的坐标为 $(x_1,y_1)$，终点的坐标为 $(x_2,y_2)$。

- 步数为 $0$：

> 只有一种情况，起点与终点在同一个地方（$x_1=x_2,y_1=y_2$）。

- 步数为 $1$：

> 就是把题目给的那三种走法走一遍：
>
> 1. $x_1+y_1=x_2+y_2$；
> 2. $x_1-y_1=x_2-y_2$；
> 3. $|x_1-x_2|+|y_1-y_2|\le 3$。

- 步数为 $2$：

>~~完了完了，最烦人的一个讨论来了~~。
>
>我们前面说过，如果起点与终点同色，那么可以在两步以内到达终点。那如何判断两点是否同色呢？
>
>观察上面的棋盘，可以看到同色格子很有规律，经过观察可发现它们的横纵坐标相加 $\mod 2$ 相等的。所以，只要判断 $(x_1+y_1)\bmod 2=(x_2+y_2)\bmod 2$ 就可以判断起点是否同色了。
>
>但是还没完！
>
>我们可以看向题目中给出的三种走法中的第三步，稍加分析，可以得出结论：$|x_1-x_2|+|y_1-y_2|\le 6$ 也可以两步之内到达终点。
>
>但真的结束了吗？
>
>![](https://cdn.luogu.com.cn/upload/image_hosting/h9e2idz2.png)
>
>图中我们用绿色表示起点，红色表示终点。很明显，它都不满足我们上面所述的两点，但我们先让绿圈斜跳到红圈下面，再往上一步就可以到了。
>
>因此，我们还能得出一个结论（先斜跳再乱跳，其中乱跳是指第三种跳法）：$-3\le (x_1-y_1)-(x_2-y_2)\le 3$，方便起见写成 $|(x_1-y_1)-(x_2-y_2)|\le 3$。
>
>当然，顺着这个思路，我们还能推出 $|(x_1+y_1)-(x_2+y_2)|\le 3$。

- 步数为 $3$。

> 前面的情况都不成功就说明步数为 $3$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a, b, c, d;
int main() {
	scanf("%d%d%d%d", &a, &b, &c, &d);
	if (a == c && b == d) printf("0\n");
	else if (a + b == c + d) printf("1\n");
	else if (a - b == c - d) printf("1\n");
	else if (abs(a - c) + abs(b - d) <= 3) printf("1\n");
	else if ((a + b) % 2 == (c + d) % 2) printf("2\n");
	else if (abs(a - c) + abs(b - d) <= 6) printf("2\n");
	else if (abs(a + b - (c + d)) <= 3) printf("2\n");
	else if (abs(a - b - (c - d)) <= 3) printf("2\n");
	else printf("3\n");
	return 0;
}
```

---

## 作者：z_yq (赞：0)

# 题意
意思很简单，就是允许你有两种走法，第一种是斜着走，第二种是走距离为 $3$ 以内的点，求两个点之间距离多少。
# 做法
我们和第一篇题解的做法一样，有两种点，黑点和白点，如果起点和终点的颜色一样就只需要走两步这是显而易见的。同时如果我们的颜色不一样就可以往左边走一步变成相反的颜色，然后就只用花三步走到终点，所以步数不超过 $3$ 也是显而易见的。 \
这里我们就分类讨论，首先 $0$ 步走到的特判一下就可以了，$1$ 步的就看是不是满足上述的三种走法，$2$ 步的就是看颜色是不是相同的，但是这还不够，因为有可能出现往左走一步然后斜着走就可以到的情况，所以要特判一下，剩下的就是三步的情况了，这里不阐述了。
# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a,b,c,d;
int main()
{
	cin>>a>>b>>c>>d;
	if(a==c && b==d) cout<<0;
	else if(abs(a-c)+abs(b-d)<=3) cout<<1;
	else if(a+b==c+d || a-b==c-d) cout<<1;
	else if(((a+b)+1000000000)%2==((c-d)+1000000000)%2) cout<<2;
	else if(abs(a-c)+abs(b-d)<=6) cout<<2;
	else if(abs((a+b)-(c+d))<=3 || abs((a-b)-(c-d))<=3) cout<<2;
	else cout<<3;
    return 0;
}
```

---

## 作者：aCssen (赞：0)

### Solution

ABC 咋天天放这种题。

首先答案不超过 $3$，证明在下面。

考虑答案为 $0$：当且仅当两个点坐标相同。

考虑答案为 $1$：当且仅当起点和终点在同一个 $3 \times 3$ 的矩形里或在同一条对角线上（其实就是题目中给的条件）。

考虑答案为 $2$：考虑分别算这两步是什么。称原题中的三类移动分别为 $1,2,3$ 类移动。

+ 第一步是 $1$ 类移动，第二步也是 $1$ 类移动。显然这没有必要。两步 $2$ 类移动同理。
+ 第一步是 $1$ 类移动，第二步是 $2$ 类移动。这与第一步是 $2$ 类移动，第二步是 $1$ 类移动的情况对称（交换两步围成了一个平行四边形）。那么假设中间走到了 $(x,y)$，应当满足的是 $x+y=r_1+c_1,x-y=r_2-c_2$，那么 $2x=r_1+c_1+r_2-c_2$，因为 $x$ 为整数，所以 $r_1+c_1+r_2-c_2$ 应该为偶数，这样，$x$ 是整数显然 $y$ 也是整数。
+ 第一步是 $1$ 类移动，第二步是 $3$ 类移动。这与第一步是 $3$ 类移动，第二步是 $1$ 类移动的情况对称。与第一步是 $2$ 类移动，第二步是 $3$ 类移动的情况相似。基于贪心的想法，我们肯定是想要走到 $r_2$ 或走到 $c_2$，一个都走不到显然不会使其 $(r_2,c_2)$ 更近。假设走到了 $r_2$，那么对角线长度为 $|r_2-r_1|$。根据不同的对角线方向，我们分别可以走到 $(r_2,c_1+|r_2-r_1|)$ 和 $(r_2,c_1-|r_2-r_1|)$。走到 $r_2$ 也同理，对着四种情况分别判断即可。
+ 两步都是 $3$ 类移动，那么应当满足 $|c_1-c_2|+|r_1-r_2| \le 2 \times 3=6$。如果你只 WA 了 `after_contest` 一个点，大抵是这里的问题。

如果以上情况都不满足，那我们可以依次进行 $3,1,2$ 操作，先移动一格，这样就改变了 $r_1+c_1+r_2-c_2$ 的奇偶性，然后直接依次进行 $1,2$ 操作就行了。

### Code
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<cmath>
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
typedef long long ll;
namespace FastIO{
	template<typename T=int> T read(){
		T x=0;int f=1;char c=getchar();
		while(!isdigit(c)){if(c=='-') f=~f+1;c=getchar();}
		while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
		return x*f;
	}
	template<typename T> void write(T x){
		if(x<0){putchar('-');x=-x;}
		if(x>9) write(x/10);
		putchar(x%10+'0');
	}
	template<typename T> void Write(T x,char c='\n'){write(x);putchar(c);}
}
using namespace FastIO;
int main(){
	int r1=read(),c1=read(),r2=read(),c2=read();
	if(r1==r2&&c1==c2){
		printf("0");
		return 0;
	}
	if(abs(r1-r2)+abs(c1-c2)<=3||r1+c1==r2+c2||r1-c1==r2-c2){
		printf("1");
		return 0;
	}
	if(abs(r1-r2)+abs(c1-c2)<=6||(r1+c1+r2-c2)%2==0||abs(c1+abs(r1-r2)-c2)<=3||abs(c1-abs(r1-r2)-c2)<=3||abs(r1+abs(c1-c2)-r2)<=3||abs(r1-abs(c1-c2)-r2)<=3){
		printf("2");
		return 0;
	}
	printf("3");
	return 0;
}
```

---


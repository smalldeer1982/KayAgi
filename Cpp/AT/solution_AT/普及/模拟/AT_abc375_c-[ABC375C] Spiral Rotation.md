# [ABC375C] Spiral Rotation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc375/tasks/abc375_c

$ N $ 行 $ N $ 列のグリッドが与えられます。ここで、$ N $ は偶数です。グリッドの上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,\ j) $ と表記します。

グリッドの各マスは黒か白のいずれかで塗られており、$ A_{i,\ j}\ = $ `#` のときマス $ (i,\ j) $ は黒、$ A_{i,\ j}\ = $ `.` のときマス $ (i,\ j) $ は白で塗られています。

$ i\ =\ 1,\ 2,\ \ldots,\ \frac{N}{2} $ の順に以下の操作を行った後のグリッドの各マスの色を求めてください。

- $ i $ 以上 $ N\ +\ 1\ -\ i $ 以下の整数 $ x,\ y $ について、マス $ (y,\ N\ +\ 1\ -\ x) $ の色をマス $ (x,\ y) $ の色で置き換える。この置き換えは**条件を満たすすべての整数 $ x,\ y $ について同時に行う**。

## 说明/提示

### 制約

- $ N $ は $ 2 $ 以上 $ 3000 $ 以下の偶数
- $ A_{i,\ j} $ は `#` または `.`
 
### Sample Explanation 1

操作によってグリッドの各マスの色は以下のように変化します。 
``` 
.......#
.......#
.####..#
.####..#
.##....#
.##....#
.#######
.#######

.......#   ........   ........   ........   ........
.......#   ######..   #######.   #######.   #######.
.####..#   ######..   #....##.   #.....#.   #.....#.
.####..# ->##..##..-> #....##.-> #.##..#.-> #.###.#.
.##....#   ##..##..   #..####.   #.##..#.   #.#...#.
.##....#   ##......   #..####.   #.#####.   #.#####.
.#######   ##......   #.......   #.......   #.......
.#######   ########   ########   ########   ########```

## 样例 #1

### 输入

```
8
.......#
.......#
.####..#
.####..#
.##....#
.##....#
.#######
.#######```

### 输出

```
........
#######.
#.....#.
#.###.#.
#.#...#.
#.#####.
#.......
########```

## 样例 #2

### 输入

```
6
.#.#.#
##.#..
...###
###...
..#.##
#.#.#.```

### 输出

```
#.#.#.
.#.#.#
#.#.#.
.#.#.#
#.#.#.
.#.#.#```

## 样例 #3

### 输入

```
12
.......#.###
#...#...#..#
###.#..#####
..#.#.#.#...
.#.....#.###
.......#.#..
#...#..#....
#####.......
...#...#.#.#
..###..#..##
#..#.#.#.#.#
.####.......```

### 输出

```
.#..##...##.
#.#.#.#.#...
###.##..#...
#.#.#.#.#...
#.#.##...##.
............
............
.###.###.###
...#...#.#..
.###...#.###
...#...#...#
.###...#.###```

# 题解

## 作者：A_R_O_N_A (赞：3)

## 题意

给你一个 $n\times n$ 大小的矩阵 $A$，若 $A_{i,j}$ 为 `#` 则该格子为黑色，否则为白色。现在请你对矩阵进行如下修改：

对于每一个整数 $i$（$1\le i\le \frac{n}{2}$）：

- 将每一个 $A_{y,n-x+1}$（$1\le x,y \le n-i+1$）修改为 $A_{x,y}$。

范围：$2\le n\le 3000$ 且 $n$ 为偶数。

## 分析

首先一眼看去就可以想到一个暴力做法：枚举每一个 $i$ 然后按题意进行模拟操作。

### 暴力代码


```cpp
for(int i=1;i<=n/2;i++){
		for(int x=i;x<=n-i+1;x++){
			for(int y=i;y<=n-i+1;y++){
				ans[y][n-x+1]=mp[x][y];
			}
		}
		for(int x=1;x<=n;x++){
			for(int y=1;y<=n;y++){
				mp[x][y]=ans[x][y];
			}
		}//必须要转移拷贝，不然你的矩阵会错到天边
	}
```
这代码一眼看过去就是 $O(n^3)$ 啊，包超时的牢弟。

所以我们需要仔细推算，观察样例，得出结论，从而做到仅需一次操作即可得出答案。即时间复杂度为 $O(n^2)$。刚好官方给了一组样例解释：


```latex
.......#    ........    ........    ........    ........
.......#    ######..    #######.    #######.    #######.
.####..#    ######..    #....##.    #.....#.    #.....#.
.####..# → ##..##.. → #....##. → #.##..#. → #.###.#.
.##....#    ##..##..    #..####.    #.##..#.    #.#...#.
.##....#    ##......    #..####.    #.#####.    #.#####.
.#######    ##......    #.......    #.......    #.......
.#######    ########    ########    ########    ########
```

在这组样例中，我们可以使用**逐层分析法**，注意到从第 $1$ 层到第 $\frac{n}{2}$ 层，对于第 $i$ 层，此层的字符就**顺时针**旋转了 $i\times 90$ 度。

还是不是很清晰？看图说话：

这是第 $1$ 层。

```latex
.......#    ........    ........    ........    ........
.      #    #      .    #      .    #      .    #      .
.      #    #      .    #      .    #      .    #      .
.      # → #      . → #      . → #      . → #      .
.      #    #      .    #      .    #      .    #      .
.      #    #      .    #      .    #      .    #      .
.      #    #      .    #      .    #      .    #      .
.#######    ########    ########    ########    ########
```

这是第 $2$ 层：

```latex
......      #####.      ######      ######      ######
#    .      #    .      .    #      .    #      .    #
#    .  →  #    .  →  .    #  →  .    #  →  .    #
#    .      #    .      .    #      .    #      .    #
#    .      #    .      .    #      .    #      .    #
######      #.....      ......      ......      ......
```

这是第 $3$ 层：

```latex
###.        ####        ...#        ....        ....
#  .   →   .  #   →   .  #   →   #  .   →   #  .
#  .        .  #        .  #        #  .        #  .
#...        ....        .###        ####        ####
```

这是第 $4$ 层：

```latex
##    →    .#    →    ..    →    #.    →    ##
..          .#          ##          #.          . 
```

现在清晰多了吧。所以该题就转化成为了逐层旋转的矩阵操作题。

那我们便可以 $O(1)$ 旋转一个点，$O(n)$ 旋转一层矩阵，$O(n^2)$ 旋转完毕整个矩阵了。

那么问题来了，怎么让程序实现这种旋转？

其实很简单，我们可以以 $A_{i,j}$ 为例，将其所对应的旋转点一一表示出来，即：$A_{i,j}$，$A_{j,n-i+1}$，$A_{n-i+1,n-j+1}$，$A_{n-j+1,i}$。那么就可以根据情况，互相赋值了。

那么旋转度数呢？相信大家都会，对于旋转度数 $\ge 360$ 度的情况，都可以转化成为 $< 360$ 度的情况。

## 正确代码

已经经过格式化，马蜂十分良好。因为是上面的暴力代码改的，所以说循环变量名有点不走寻常路。

```cpp
for (int j = 1; j <= n / 2; j++) {
        if (j % 4 == 1) {
            for (int x = j; x <= n - j + 1; x++) {
                ans[j][x] = mp[n - x + 1][j];
                ans[x][n - j + 1] = mp[j][x];
                ans[n - j + 1][n - x + 1] = mp[x][n - j + 1];
                ans[n - x + 1][j] = mp[n - j + 1][n - x + 1];
            }
        }

        if (j % 4 == 2) {
            for (int x = j; x <= n - j + 1; x++) {
                ans[j][x] = mp[n - j + 1][n - x + 1];
                ans[x][n - j + 1] = mp[n - x + 1][j];
                ans[n - j + 1][n - x + 1] = mp[j][x];
                ans[n - x + 1][j] = mp[x][n - j + 1];
            }
        }

        if (j % 4 == 3) {
            for (int x = j; x <= n - j + 1; x++) {
                ans[j][x] = mp[x][n - j + 1];
                ans[x][n - j + 1] = mp[n - j + 1][n - x + 1];
                ans[n - j + 1][n - x + 1] = mp[n - x + 1][j];
                ans[n - x + 1][j] = mp[j][x];
            }
        }

        if (j % 4 == 0) {
            for (int x = j; x <= n - j + 1; x++) {
                ans[j][x] = mp[j][x];
                ans[x][n - j + 1] = mp[x][n - j + 1];
                ans[n - j + 1][n - x + 1] = mp[n - j + 1][n - x + 1];
                ans[n - x + 1][j] = mp[n - x + 1][j];
            }
        }
    }
```

## 后话

这题是 C 题，却有 $400$ 分，可见这题比平常稍微难一些，~~虽然说我没感觉就是了~~。

---

## 作者：Bobxing (赞：3)

#### 题意：

给定一个 $n$ 行 $n$ 列的网格，保证 $n$ 是偶数，约定 $(i,j)$ 表示从上到下地 $i$ 行和从左到右第 $j$ 列的单元格。每个单元格都被涂成了黑色或者白色，如果 $A_{i,j}=$ `#`，表示颜色为黑色，如果 $A_{i,j}=$ `.`，表示颜色为白色。

下面对 $i=1,2,\ldots,\frac{n}{2}$，都执行以下操作：

- 对于 $i$ 和 $n+1-i$ 之间（含）的所有整数对 $(x,y)$，将单元格 $(y,n+1-x)$ 的颜色替换为单元格 $(x,y)$ 的颜色，所有满足条件的整数对都要被操作。

你需要求出最终网格的颜色。

#### 分析：

观察数据范围，发现 $2\leq n\leq 3000$，所以复杂度约为 $O(n^2)$，而直接模拟的复杂度为 $O(n^3)$，无法接受。

考虑优化，可以发现，操作相当于对这个网格中的 $i\sim n-i+1$ 这些网格顺时针旋转 $90^{\circ}$，所以最终最外圈顺时针旋转了 $90^{\circ}$，从外向内第 $2$ 圈顺时针旋转了 $180^{\circ}$，所以从外向内第 $t$ 圈顺时针旋转了 $(90t)^{\circ}$，这样我们就可以一圈一圈地模拟，时间复杂度 $O(n^2)$。

#### 代码：

```cpp
#include<iostream>
using namespace std;
#define maxn 3010
int n;
char c[ maxn ][ maxn ], t[ maxn ];
void change( int x )				//表示将第x圈旋转90度
{
    for( int i = x; i <= n - x + 1; i++ )
        t[ i ] = c[ x ][ i ];
    for( int i = x; i <= n - x + 1; i++ )
        c[ x ][ i ] = c[ i ][ n - x + 1 ];
    for( int i = x; i <= n - x + 1; i++ )
        c[ i ][ n - x + 1 ] = c[ n - x + 1 ][ n - i + 1 ];
    for( int i = x + 1; i < n - x + 1; i++ )
        c[ n - x + 1 ][ i ] = c[ i ][ x ];
    for( int i = x; i <= n - x + 1; i++ )
        c[ i ][ x ] = t[ n - i + 1 ];
}
int main()
{
    cin >> n;
    for( int i = 1; i <= n; i++ )
        scanf( "%s", c[ i ] + 1 );
    for( int i = 1; i <= n / 2; i++ )
    {
        //每旋转4圈就回来了，所以模4
        if( i % 4 == 1 )
        {
            change( i );
            change( i );
            change( i );
        }
        if( i % 4 == 2 )
        {
            change( i );
            change( i );
        }
        if( i % 4 == 3 )
        {
            change( i );
        }
    }

for( int i = 1; i <= n; i++, cout << endl )
        for( int j = 1; j <= n; j++ )
            cout << c[ i ][ j ];
    return 0;
}
```

---

## 作者：cjh20090318 (赞：3)

近 40 场以来最难的 C，有点难写。

## 题意

有一个 $N \times N$ 的网格，每个网格由黑色 `#` 和白色 `.` 组成。

按照顺序 $i = 1, 2, \ldots, \frac{N}{2}$ 依次以下进行操作：

- 对于 $i$ 和 $N + 1 - i$ 之间的所有整数对 $x, y$ ，用单元格 $(x, y)$ 的颜色替换单元格 $(y, N + 1 - x)$ 的颜色。**同时**对所有这些单元格对 $x, y$ 进行替换。

最后找出每个单元格的颜色。

## 分析

这个操作感觉没有说人话，经过一定的模拟发现，每一次操作即把一个左上顶点为 $(i,i)$，右下顶点为 $(N-i+1,N-i+1)$ 的正方形顺时针旋转 $90$ 度。

直接暴力的对于每个 $i$ 旋转是不可取的，需要考虑更好的方法。

设第 $i$ 层表示的单元格集合为 $\{ (x,y) \mid x = i \lor x = N-i+1 \lor y = i \lor y = N-i+1\}$。

因为外层的影响，第 $i$ 层将会被旋转 $i$ 次，但是因为 $4$ 次就会被转回原位，所以就只需要转 $i \bmod 4$ 次即可。

时间复杂度 $O(n^2)$，具体实现有点复杂所以请看代码。

## 代码

```cpp
//the code is from chenjh
#include<cstdio>
using namespace std;
int n;
char s[3005][3005],b[3005][3005];
void r(const int i){
	//对第 i 层进行右旋。
	for(int j=i;j<=n-i;j++) b[j][n-i+1]=s[i][j];
	for(int j=i;j<=n-i;j++) b[n-i+1][n-j+1]=s[j][n-i+1];
	for(int j=n-i+1;j>i;j--) b[j][i]=s[n-i+1][j];
	for(int j=n-i+1;j>i;j--) b[i][n-j+1]=s[j][i];
	//将临时存储的数组复制回原数组。
	for(int j=i;j<=n-i;j++) s[i][j]=b[i][j];
	for(int j=i;j<=n-i;j++) s[j][n-i+1]=b[j][n-i+1];
	for(int j=n-i+1;j>i;j--) s[n-i+1][j]=b[n-i+1][j];
	for(int j=n-i+1;j>i;j--) s[j][i]=b[j][i];
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
	for(int i=1;i<=(n>>1);i++)for(int _=i&3;_--;)r(i);//i&3 和 i%4 等价。
	for(int i=1;i<=n;i++) puts(s[i]+1);
	return 0;
}
```

---

## 作者：Redamancy_Lydic (赞：2)

看懂题以后其实也不太难。

题意有点难懂，但是借助样例不难发现第一次操作是把原图按顺时针转 $90^{\circ}$。此时再看题面，易得操作就是每次把图的一部分顺时针旋转 $90^{\circ}$，最开始为整图操作，每次操作后都舍弃当前操作的图的最外层一圈后再进行下一次操作。

看懂题意以后，我们发现直接模拟肯定是不行的，但是我们可以分别对每个点考虑。

具体的，我们设点 $(x,y)$ 一共被操作了 $k$ 次，因为操作时 $4$ 次一循环，所以我们只需要考虑 $k$ 对 $4$ 取余后的值。

容易发现点 $(x,y)$ 旋转一次后坐标会变成 $(y,n-x+1)$，那么我们只需要执行 $k$ 次后就可以得到 $(x,y)$ 现在的位置。

这样我们构建一张新矩阵，把原图上的点与其一一对应，最后输出即可。

[提交记录](https://atcoder.jp/contests/abc375/submissions/58699944)

---

## 作者：Liuhy2996 (赞：1)

## 思路
不难发现，从外往里数第 $k$ 层被顺时针转了 $k$ 次。对于每个点计算层数，然后转 $k\bmod4$ 次就行。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e3+10;
int n;
char c[N][N],a[N][N];
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j) cin>>c[i][j];
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			int k=min(min(i,n-i+1),min(j,n-j+1))%4; //计算层数
			if(k==0) cout<<c[i][j];
			else if(k==1) cout<<c[n+1-j][i];
			else if(k==2) cout<<c[n+1-i][n+1-j];
			else cout<<c[j][n+1-i];
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：zengziqvan (赞：1)

这次 $C$ 需要很强的码力。

发现原问题等价于逆时针旋转。每旋转一次后把最外面一圈丢掉继续转。

直接模拟显然是 $\operatorname{O}(n^2\times m)$，难以通过

又发现逆时针旋转 $4$ 次相当于没转。

所以可以预处理每一圈转的次数 $\bmod 4$ 的值。再一圈一圈转，这样就可以通过了。

复杂度 $\operatorname{O}(n\times m)$。

```c++
int n,nd[3010];
char a[3010][3010],b[3010][3010];
void change(int x) {
	FOR(o,1,nd[x]) {
		FOR(i,x,n-x+1) b[i][n-x+1]=a[x][i];//最后一列 
		FOR(i,x,n-x+1) b[i][x]=a[n-x+1][i];//第一列 
		FOR(i,x,n-x+1) b[x][i]=a[n-i+1][x];//第一行 
		FOR(i,x,n-x+1) b[n-x+1][i]=a[n-i+1][n-x+1];//最后一行 
		FOR(i,x,n-x+1) a[i][x]=b[i][x],a[i][n-x+1]=b[i][n-x+1];
		FOR(i,x,n-x+1) a[x][i]=b[x][i],a[n-x+1][i]=b[n-x+1][i];
	}
}
main() {
	cin>>n;
	FOR(i,1,n) scanf("%s",a[i]+1);
	FOR(i,1,n/2) nd[i]=(nd[i-1]+1)%4;
	FOR(i,1,n/2) change(i);
	FOR(i,1,n) {
		FOR(j,1,n) cout<<a[i][j];
		puts("");
	}
	return 0;
}
```

---

## 作者：Anins (赞：1)

## [Spiral Rotation](https://www.luogu.com.cn/problem/AT_abc375_c)

### 题意：

有一个 $n \times n$ 的矩阵，从最外层向内依次旋转 $90 \degree$（旋转的是实心矩阵，也就是说包含其内部元素）。

图示如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/qx06hb9e.png)

### 思路：
我们对每次旋转的矩阵的最外层进行讨论：从外向内数第 $k$ 个外层会被它外面的 $k-1$ 个外层连带旋转 $k-1$ 次，那么它一共会旋转 $k$ 次。这样我们就将旋转矩阵转换为了旋转一个外层。另外，最外层旋转 $k$ 次等价于旋转 $k \bmod 4$ 次，这样可以保证正确的时间复杂度。

旋转一个外层只需要复制一个辅助数组按顺序重新赋值即可。

### 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
char c[3005][3005], cc[3005][3005];
ll n;
void solve(ll k) {
	memcpy(cc, c, sizeof(c)); //复制一份方便旋转 
	for(int i=k; i<=n-k+1; i++) c[i][n-k+1]=cc[k][i]; //上方->右方 
	for(int i=k; i<=n-k+1; i++) c[n-k+1][n-i+1]=cc[i][n-k+1]; //右方->下方 
	for(int i=k; i<=n-k+1; i++) c[i][k]=cc[n-k+1][i]; //下方->左方 
	for(int i=k; i<=n-k+1; i++) c[k][n-i+1]=cc[i][k]; //左方->上方 
}
int main() {
	cin >> n;
	for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) cin >> c[i][j];
	for(int k=1; k<=n/2; k++) for(int j=1; j<=k%4; j++) solve(k);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) cout << c[i][j];
		puts("");
	}
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：1)

个人认为比 D 题难。

题目名叫螺旋旋转，所以思考旋转。

观察样例解释可发现，每次操作是将中心的正方形顺时针旋转 $90$ 度，每次旋转的正方形大小都会缩小 $1$ 圈，对于每一圈（距中心曼哈顿距离相同的格子），都会旋转相同次。

又易得转 $4$ 次与不转没有区别，所以从外到内每圈的转圈数为 $(上一次转的圈数+1)\bmod4$。

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char c[3005][3005], t[3005][3005];
void change(int st, int ed){//转一圈
	for(int i = st; i < ed; i ++) t[i][ed] = c[st][i];
	for(int i = st + 1; i <= ed; i ++) t[i][st] = c[ed][i];
	for(int i = st + 1; i <= ed; i ++) t[st][n - i + 1] = c[i][st];
	for(int i = st; i < ed; i ++) t[ed][n - i + 1] = c[i][ed];
	for(int i = st; i < ed; i ++) c[i][ed] = t[i][ed];
	for(int i = st + 1; i <= ed; i ++) c[i][st] = t[i][st];
	for(int i = st + 1; i <= ed; i ++) c[st][n - i + 1] = t[st][n - i + 1];
	for(int i = st; i < ed; i ++) c[ed][n - i + 1] = t[ed][n - i + 1];
}
int main(){
	cin >> n;
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= n; j ++)
		cin >> c[i][j];
	for(int i = 1; i <= n / 2; i ++){//每次操作
		for(int j = 1; j <= i % 4; j ++) change(i, n - i + 1);
	}
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= n; j ++)
		cout << c[i][j];
		cout << "\n";
	}
	return 0;
}

```
转圈的大致思路为如下：
```
a b c
h . d
g f e
```
`ab`，`cd`，`ef`，`gh`，是四条边上的点，分别在中间数组上旋转即可。

---

## 作者：201012280925LSY (赞：0)

## 前言
一道好题，赛时把这个蒟蒻卡了好一会。
## 大意
给你一个 $N$ 行 $N$ 列的矩阵，矩阵由两种字符 `#` 和 `.` 组成。当一个正整数 $i=1,2,3,\dots , \frac{N}{2}$ 时，对于任意一个在 $i$ 到 $N+1-i$ 之间的整数对 $(x,y)$，把矩阵中 $(y,N+1-x)$ 格子的颜色改成 $(x,y)$ 格子的颜色。
## 思路
在第一次看看题时，笔者并没有看懂题面到底在说什么。所以我们可以先看样例。在第一个样例当中，样例解释是这样的：

```
.......#    ........    ........    ........    ........
.......#    ######..    #######.    #######.    #######.    
.####..#    ######..    #....##.    #.....#.    #.....#.
.####..# → ##..##.. → #....##. → #.##..#. → #.###.#.
.##....#    ##..##..    #..####.    #.##..#.    #.#...#.
.##....#    ##......    #..####.    #.#####.    #.#####.
.#######    ##......    #.......    #.......    #.......
.#######    ########    ########    ########    ########
```
通过观察，我们可以发现：在第 $i$ 次修改时，在行上从 $i$ 到 $N-i+1$，以及在列上从 $i$ 到 $N-i+1$ 的矩阵，会向右边旋转九十度。然后我们结合题目，就可以得出我们的结论是正确的。

所以可以得出暴力代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[3010][3010],b[3010][3010];
long long n;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
		}
	}
	long long l=1,r=n;
	for(int i=1;i<=n/2;i++)
	{
		for(int j=l;j<=r;j++)
		{
			for(int k=l;k<=r;k++)//2 2
			{
				b[k][r-j+l]=a[j][k];
			}
		}
		for(int j=l;j<=r;j++)
		{
			for(int k=l;k<=r;k++)
			{
				a[j][k]=b[j][k];
			}
		}
		l++;
		r--;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			cout<<a[i][j];
		cout<<"\n";
	}
	return 0;
}
```
进一步思考，这个东西是会超时的，那么有没有规律呢？

第一次旋转：`a[i][j]=a[j][R-i+L]`

第二次旋转：`a[j][R-i+L]=a[R-i+L][(R-1)-j+(L+1)]=a[R-i+L][R-j+L]`

第三次旋转：`a[R-i+L][R-j+L]=a[R-j+L][(R-2)-(R-i+L)+(L+2)]=a[R-j+L][i]`

第四次旋转：`a[R-j+L][i]=a[i][(R-3)-(R-j+L)+(L+3)]=a[i][j]`

发现了吗？显然吗每转四次它就会回到原来的颜色，结合图形，也可以知道它每转四次九十度就会回到原来的位置~~这不是显而易见的吗~~。

所以就可以得出优化后的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[3010][3010],b[3010][3010];
long long n;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
		}
	}
	long long l=1,r=n;
	for(long long i=1;i<=n;i++)
	{
		for(long long j=1;j<=n;j++)
		{
			long long sum=min(i,j);//计算转了几次，请读者自己思考
			if(i<=n/2)sum=i;
			else sum=n-i+1;
			if(j<=n/2)sum=min(sum,j);
			else sum=min(n-j+1,sum);
			if(sum%4==1)
			{
				b[j][n-i+1]=a[i][j];
			}
			if(sum%4==2)
			{
				b[n-i+1][n-j+1]=a[i][j];
			}
			if(sum%4==3)
			{
				b[n-j+1][i]=a[i][j];
			}
			if(sum%4==0)
			{
				b[i][j]=a[i][j];
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			cout<<b[i][j];
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：cjh_trailblazer (赞：0)

[at原题面](https://atcoder.jp/contests/abc375/tasks/abc375_c)
## 题目分析：
~~构式翻译害人不浅。~~  
对于题目上所说的变化方式，即 $(y,n+1-x)->(x,y)$，不难发现这是顺时针旋转 $90$ 度，且 $x,y$ 处于 $i$ 到 $n+1-i$ 的范围内，$i$ 不超过 $\frac{n}{2}$ ，所以是每次舍弃外面一层再进行旋转，直接大力模拟即可。
## [Code](https://atcoder.jp/contests/abc375/submissions/58819183)

---

## 作者：liuziqin (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/AT_abc375_c)

## 思路

由于 $n \le 3000$ ， $n^4$ 暴力显然不可能。

考虑对于每个点计算操作次数，然后统一进行修改。

对于一个点 $(i,j)$ 进行 $1$ 次操作后位置变为 $(j,n-i+1)$ ， $2$ 次操作后变为 $(n-i+1,n-j+1)$ ， $3$ 次操作后变为 $(n-j+1,i)$ ， $4$ 次操作后变为 $(i,j)$ 。显然，这个变化是周期性的。

接下来考虑点 $(i,j)$ 被操作了多少次。容易推出被操作次数是该点到边的最短距离。

## Code

```c++
#include<bits/stdc++.h>
#define int long long 
using namespace std;
char mp[3005][3005];
char tmp[3005][3005];
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)cin>>mp[i][j];//输入
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++){
		int now=min(i,n-i+1);//被操作次数
		now=min(now,min(j,n-j+1));
		if(now%4==0)tmp[i][j]=mp[i][j];
		if(now%4==1)tmp[j][n-i+1]=mp[i][j];
		else if(now%4==2)tmp[n-i+1][n-j+1]=mp[i][j];
		else if(now%4==3)tmp[n-j+1][i]=mp[i][j];//周期性
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)cout<<tmp[i][j];
		cout<<"\n";//输出
	}
	return 0;
}

```

---


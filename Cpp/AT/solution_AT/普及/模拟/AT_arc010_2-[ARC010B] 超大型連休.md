# [ARC010B] 超大型連休

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc010/tasks/arc010_2

$ 2011 $ 年、$ AtCoder $ 国の高橋首相はある重大な決定を行った。  
 その決定とは...法改正である。国民の祝日に関する法律を変更し、休日を増やすことにした!!  
 国民の創造性を尊重するその決定が、霞が関を魔境へと変えたッ！  
  
 あなたは霞が関の国土交通省に勤務する職員であり、この法改正により上司から新たな任務を与えられた。  
 その任務とは、$ 2012 $ 年の「連休の最大日数」を計算することである。  
 連休の大きさを事前に計算することで国民の行動を予想し、高速道路の部分的な値下げを行い、経済を活性させるためだ。  
 したがって、あなたに失敗することは許されない。国民の行動を正確に予想できなくなるからだ。  
  
 以下に、「連休」の定義と諸注意を記す。

1. $ AtCoder $ 国が使用する暦は[グレゴリオ暦](http://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AC%E3%82%B4%E3%83%AA%E3%82%AA%E6%9A%A6)に従う。
2. 「連休」とは、「休日」が連続して続くことである。
3. 「土曜日」「日曜日」「祝日」「振替休日」が「休日」に相当する。
4. 「祝日」が他の休日と同じ日に指定されていた場合、「振替休日」を必ず設置する。
5. 「振替休日」は祝日の時系列順に決定していき、その祝日以降最も近い平日（休日を除いた日）となる。
6. $ 2012 $ 年 $ 1 $ 月 $ 1 $ 日は日曜日である。
 
 入力は以下の形式で標準入力から与えられる。 > $ N $ $ m_{1} $/$ d_{1} $ $ m_{2} $/$ d_{2} $ $ : $ $ : $ $ m_{n} $/$ d_{n} $

- $ 1 $ 行目には祝日の日数を表す整数 $ N $ が与えられ、 $ 0≦N≦366 $ を満たす。
- $ 2 $ 行目から $ N+1 $ 行目までの $ N $ 行で祝日の日付が与えられる。

1. $ m_{i} $ は $ i(1≦i≦366) $ 番目に与えられる祝日の月で、 $ 1≦m_{i}≦12 $ を満たす。
2. $ d_{i} $ は $ i(1≦i≦366) $ 番目に与えられる祝日の日で、
1. $ m_{i}\ =\ 2 $ のとき、 $ 1≦d_{i}≦29 $ を満たす。
2. $ m_{i}\ =\ (4,\ 6,\ 9,\ 11) $ のとき、 $ 1≦d_{i}≦30 $ を満たす。
3. $ m_{i}\ =\ (1,\ 3,\ 5,\ 7,\ 8,\ 10,\ 12) $ のとき、 $ 1≦d_{i}≦31 $ を満たす。

4. $ m_{i} $ と $ d_{i} $ はともに整数である。
5. $ m_{i} $ と $ d_{i} $ は必ず`/`で区切られて与えられる。
6. 祝日は時系列順に与えられるとは限らないことに注意せよ。ただし、同じ日付が複数与えられないことは保証されている。
 
 法改正後における $ 2012 $ 年の連休の最大日数を出力せよ。  
 出力は標準出力におこない、末尾には改行をいれること。  
```

1
1/9
```

 ```

3
```

- 1/7(土),1/8(日),1/9(月)の $ 3 $ 連休が最長です。
 
```

1
1/10
```

 ```

2
```

- 1/10(火)が祝日となり、1/7(土),1/8(日)などの $ 2 $ 連休が最長です。
 
```

1
1/7
```

 ```

3
```

- 1/7は土曜日なので、以降で最も近い平日である1/9が振替休日になります。
- よって、1/7(土)、1/8(日)、1/9(月)の3連休が最長です。
 
```

2
1/7
1/9
```

 ```

4
```

- 1/7は土曜日なので振替休日を以降に設定したく、1/9が祝日なので1/10が振替休日になります。
- よって、1/7(土)、1/8(日)、1/9(月)、1/10(火)の4連休が最長です。

# 题解

## 作者：封禁用户 (赞：2)

首先吐槽一下这个翻译，这是什么鬼。

其实题意很简单，就是说岛国人民搞了个新政策，他们现在有 $n$ 个节日，也有双休日（「土曜日」「日曜日」就是人家的周六日），然后还有「补休日」，跟调休正好相反，就是「公休日」是双休日的话，就设下面第一个非节日的工作日为「补休日」。

~~你要这样我乐开花了，中秋五一好几年全是涵盖周末，如果我没记错的话。~~

下面我来说一下坑。

1. 本题是 $2012$（$2011$？）年的题，$2012$ 是个闰年，有 $366$ 天。
2. 简单去看一下万年历，$2012.1.1$ 是个周日。

代码大致分为三个部分。

1. 预处理。为了方便我们求 $x$ 月 $y$ 日是一年第多少天（即前 $x-1$ 个月的天数和再加 $y$ 天），我们需要计算月的前缀和。我们还要定义一个布尔数组标记休假日。
2. “日式调休”，如果这个节日是双休日，则设置补休（利用循环），否则设为休假日。
3. 统计，使用擂台法。

下面看代码：（可以自行过滤很多注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
bool rest[114514];
int mouth[13]={0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, month[13];
// 奶奶的，2012年是个闰年，草
void meow(){
    cin>>n;
    // 前缀和，不然不好算，这样计算是一年第多少天只需要加上前面那些月的和再加日期即可
    for (int i=1; i<=12; i++) month[i]=month[i-1]+mouth[i]; // 都懒得换一个容易区分的变量名，就是玩

    // 标记双休日
    for (int i=1; i<=366; i++)
        if (!(i%7) || i%7==1) rest[i]=true; // 366，366，闰年天数366！
}

void woof(){
    while (n--){
        int m, d;
        scanf("%d/%d", &m, &d); // 都一样
        int kth_date=month[m-1]+d; // 一年第多少天，计算方法在上一个函数的注释中
    
        if (rest[kth_date]){ // 如果是节假日也是双休日，往下找到第一个非节假日改为节假日
            for (int i=kth_date+1; i<=366; i++)
                if (!rest[i]){ rest[i]=true; break; }
        }
        else rest[kth_date]=true; // 否则改成节假日
    }
}

void oink(){
    int maxd=0, real=0; // 擂台计数器，最终输出的数
    for (int i=1; i<=366; i++){ // 最长连休日（超大型連休）
        if (rest[i]) maxd++; // 是节假日，最长连续计数加一
        else real=max(real, maxd), maxd=0; // 不是了，计算目前的最长连休
    }
    cout<<max(maxd, real)<<endl; // 把最后可能落下的连休记录下来
}

int main(){
    meow(); // 预处理
    woof(); // 调休？日式调休（确信
    oink(); // 统计
    return 0;
}
/*
Este es el zoo!
*/
```

就是这样，谢谢大家。

---

## 作者：SuperCowHorse (赞：1)

一道~~简单~~的模拟题。
### 题目大意
给定 ${n}$ 个节假日，周六周日也算节假日，求最长的连休日。
### 思路分析
首先，我们需要做一些预处理，把所有月份用前缀和计算一遍，方便用一维数组，并将周六日给记录下来，将他们归为节假日。注意：这里有两个坑。
#### 坑一：2012 年是闰年，循环从 1~366。
#### 坑二：2012 年 1 月 1 日是周日，而非2012 年 1 月 11 日。
所以，我们就有以下代码：
``` cpp
for(int i=1;i<=12;++i)
		sum[i]=sum[i-1]+MonthDay[i];//前缀和 
	for(int i=1;i<=366;++i)//把周六日用u数组记录下来 
		if(i%7==0||i%7==1)
			u[i]=1;
```
其次，就是输入。可以边输入，边统计。如果节假日本来就是周六日，就找到其后第一个非节假日，将它改为节假日。代码如下：
``` cpp
for(int i=1;i<=n;++i)
	{
		scanf("%d/%d",&m,&d);//scanf输入方便一些 
		if(u[sum[m-1]+d]==1)//如果本来就是周六日 
		{
			for(int j=sum[m-1]+d+1;j<=366;++j)//找第一个不是节假日的 
				if(!u[j])
				{
					u[j]=1;
					break;
				}
		}
		else
			u[sum[m-1]+d]=1;//标记成为节假日 
	}
```
最后，就是统计。具体就看注释吧。
``` cpp
for(int i=1;i<=366;++i)//统计最长连休 
	{
		if(u[i])//是节假日++now 
			++now;
		else//不是统计最大值 
		{
			ans=max(ans,now);
			now=0;
		}
	}
    ans=max(ans,now);//可能在最后有连休 
```
全部代码如下：（无注释）
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,d,ans,now;
int MonthDay[]={0,31,29,31,30,31,30,31,31,30,31,30,31},sum[15];
char ch;
bool u[370];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=12;++i)
		sum[i]=sum[i-1]+MonthDay[i];
	for(int i=1;i<=366;++i)
		if(i%7==0||i%7==1)
			u[i]=1;
	for(int i=1;i<=n;++i)
	{
		scanf("%d/%d",&m,&d);
		if(u[sum[m-1]+d]==1)
		{
			for(int j=sum[m-1]+d+1;j<=366;++j)
				if(!u[j])
				{
					u[j]=1;
					break;
				}
		}
		else
			u[sum[m-1]+d]=1;
	}
	for(int i=1;i<=366;++i)
	{
		if(u[i])
			++now;
		else
		{
			ans=max(ans,now);
			now=0;
		}
	}
	ans=max(ans,now);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Asimplename (赞：1)

一道模拟题。

可以用一个 bool 类型数组表示每一天是否是休息日（闰年有 366 天，2012 年是闰年）。只要计算出周六周日在那一天，然后计算出每个新增的休息日在那一天（如果这一天也是休息日了，找后面第一个不是休息日的天数，变成休息日），最后统计一下就可以了。

注意，应该是 $2012$ 年 $1$ 月 $1$ 日是周日才对，题目翻译错了。

代码：
```cpp


#include<iostream>

using namespace std;

bool jia[367];
int monthDay[13] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
int N = 0;
int cnt = 0;
int res = 0;

int main () {
	cin >> N;
	int curM = 0;
	int curD = 0;
	jia[1] = true;
	for(int i = 1; i <= 12; i ++){
		monthDay[i] = monthDay[i - 1] + monthDay[i];//统计每个月结束时的天数。
	}
	for(int i = 1; i <= 366; i ++){
		if(i % 7 == 0){//1 月 1 日是周日，那么以后的天数如果模 7 等于 0,就是周六。
			jia[i] = true;
			jia[i + 1] = true;
		}
	}
	char op;
	for(int i = 1; i <= N; i ++){
		cin >> curM >> op >> curD;
		if(jia[monthDay[curM - 1] + curD] == true){//上一个月结束的天数加上这个月过的天数。
			for(int j = monthDay[curM - 1] + curD + 1; j <= 366; j ++){//如果这一天已经是休息日了，那么从后面找到第一个没有休息的日子。
				if(jia[j] == false){
					jia[j] = true;
					break;
				}
			}
		}
		else{
			jia[monthDay[curM - 1] + curD] = true;
		}
	}
	for(int i = 1; i <= 366; i ++){
		if(jia[i] == false){
			res = max(res, cnt);
			cnt = 0;
		}
		else{
			cnt ++;
		}
	}
	cout << max(res, cnt) << endl;//最后的一段连休没有统计上。
	return 0;
}

---


# [ARC040B] 直線塗り

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc040/tasks/arc040_b

イカの高橋君は床を塗るのが大好きです。床は $ N $ 個のマスが左右に $ 1 $ 列に並んでいるような形をしています。左から $ i $ 個目のマスをマス $ i $ と呼ぶことにします。すでにいくつかのマスは塗られていますが、いくつかのマスは塗られていません。高橋君はインクを発射できる射程が $ R $ の銃を使って全てのマスを塗ろうとしています。高橋君は最初マス $ 1 $ にいます。そして、$ 1 $ 秒の間に以下のいずれか $ 1 $ つの行動が行えます。

- $ 1 $ つ右のマスに移動する。すなわち、マス $ i $ からマス $ i+1 $ に移動する。ただし、マス $ N $ にいるときは行えない。
- 銃を撃って床を塗る。マス $ i $ にいるときに銃を撃つと、マス $ i $ からマス $ i+R-1 $ までのマスを全て塗ることができる。ただし、$ i+R-1 $ が $ N $ より大きい場合は、マス $ i $ からマス $ N $ までのマスが塗られる。

高橋君が全てのマスを塗るためにかかる時間の最小値を求めてください。

## 说明/提示

### Sample Explanation 1

銃を撃つ → $ 4 $ 歩前進 → 銃を撃つ、という行動をとると時間が最小となります。

### Sample Explanation 2

銃を撃つ → $ 1 $ 歩前進 → 銃を撃つ、という行動をとると時間が最小となります。

### Sample Explanation 3

最初から全てのマスが塗られています。

## 样例 #1

### 输入

```
7 3
...o.o.```

### 输出

```
6```

## 样例 #2

### 输入

```
8 4
...o.ooo```

### 输出

```
3```

## 样例 #3

### 输入

```
4 4
oooo```

### 输出

```
0```

# 题解

## 作者：2022_7_6_just_end (赞：2)

## solution
对于这道题，我采用倒推加贪心的方法，我们借助贪心，可以减少判断的次数，同时降低代码实现难度。

我是这样想的，从这个字符串的末尾向前扫一遍，我们将一个位置 $ i $ 把它和它后面 $ R $ 个未涂色字符涂成黑色的个数称为它的价值。

采用贪心的思想，时间能少就少，也就是涂色开始的那一个位置（因为是倒推的，所以涂色开始的位置就是涂色的那一段结束的位置）价值能高就尽量高，如果在这个位置的前面有另一个位置的价值比这个位置高，那么就在另一个位置上涂色，每次到一个位置移动距离 $ c $ 都要加一，最后当所有的位置都被涂完色时，加上移动距离 $ c $ ，即可算出最终结果。

### 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int N, R, c = 0, x = 0;
string S;

int main() {
	cin >> N >> R >> S;
		for (int i = N - 1; i >= 0; i--) {
		if (S[i] == '.') {
			x = max(x, i - R + 1);//选取价值最高的位置
			c ++;//添加移动距离
			i -= R - 1;//移动到未涂色的位置
		}
	}
	cout << c + x << endl;
	return 0;
}
```
### Tips

注意！！！岛国题最终要加换行，~~因为这个挂了几遍QAQ~~。

---

## 作者：ZHANGyutao123 (赞：0)

# [ARC040B] 直線塗り题解
## [传送门](https://www.luogu.com.cn/problem/AT_arc040_b)

## 题目大意

在平面上有 $n$ 个方格，你最开始在1号方格上。每一秒，你可以执行以下两种操作之一：

- 向右移动一格。
- 假设你当前在第 $i$ 个方格，你可以将第 $i$ 个方格到第 $i+s-1$ 个方格涂成黑色。

给定这些方格的初始状态，其中 `.` 表示白色空方格,`o` 表示已经涂成黑色的方格。

问将所有方格都涂成黑色所需的最少时间。
## 分析
这是一个简单的求解最少时间的问题。我们可以使用贪心的思想来解决。

1. 遍历方格的过程中，尽可能涂黑连续的方格。当遇到一个白色空方格时，我们可以选择将它和它后面的 $R-1$ 个方格涂黑，以尽快涂黑更多的方格。

2. 在涂黑连续方格时，需要考虑使得涂黑方格的最远位置尽量靠前。这是因为我们希望在涂黑过程中尽可能多地移动到已涂黑区域之前的方格，以减少总的时间。

具体来说，我们定义一个计数变量 `count` 来记录涂黑的方格数量。然后定义一个变量 `maxPos` 来记录涂黑方格的最远位置。

接下来，从最后一个方格开始向前遍历。如果当前方格是白色空方格（即 `S[i] == '.'`），则将该方格和它后面的 `R-1` 个方格涂黑。同时更新 `maxPos` 的值为当前方格位置减去 `R-1`。然后将计数变量 `count` 加1，并将遍历指针 `i` 减去 `R-1`。

最后，最少时间等于涂黑方格的数量 `count` 加上 `maxPos` 的值。输出最少时间即可。

## 代码实现

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    int N, R;
    string S;

    cin >> N >> R >> S;

    int count = 0;
    int maxPos = 0;

    for (int i = N - 1; i >= 0; i--) {
        if (S[i] == '.') {
            maxPos = max(maxPos, i - R + 1);
            count++;
            i -= R - 1;
        }
    }

    int ans = count + maxPos;
    cout << ans << endl;

    return 0;
}
```
## 复杂度
这个算法的时间复杂度是 $O(N)$，其中 $N$ 是方格的数量。因为我们只需要遍历一遍所有的方格。


---

## 作者：hmh100211 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/AT_arc040_b)

# 题意分析：

给出整数 $n$，$r$ 和一个只包含 `.` 和 `o` 的字符串 $s$ 代表平面上的方格，`.` 表示没有涂色，`o` 表示已经涂色。

每秒能执行以下（一个）操作：

- 向右移动一格。

- 假设你当前在方格 $i$，将第 $i$ 个方格到第 $i+s-1$ 个方格涂成黑色。

问将所有方格涂成黑色所需几秒。

# 思路：

从输入中读取三个变量：$n$，$r$，$s$。

$n$ 表示字符 $s$ 的长度，$r$ 表示每次涂色的范围，$s$ 表示需要涂色的字符串。

然后从字符串的最后一个字符开始遍历，如果当前字符是 `.`，表示需要涂色，那么就计算出涂色的起始位置，即 $i - r + 1$，然后更新 $x$ 为最大的起始位置。

同时，每次涂色都需要移动 $r$ 个位置，所以将 $i$ 减去  $r-1$，即移动到下一个未涂色的位置。

最后，输出移动的总距离，即 $c + x$。


# AC code:
```c
#include<bits/stdc++.h>

using namespace std;

int main() 
{ 
	int n,r,c=0,x=0;
	string s;
    
	cin>>n>>r>>s; //输入
    
	for(int i=n-1;i>=0;i--) //从最后一个字符开始遍历
	{
		if(s[i]=='.') //如果要涂色
		{
			x=max(x,i-r+1); //更新涂色起始位置
			c++;
			i-=r-1; //移动到下一个未涂色的位置
		}
	}
	cout<<c+x<<endl; //输出移动的总距离（要换行）
	return 0;
}
```


# [AC](https://www.luogu.com.cn/record/115055534)

---

## 作者：yyz_100110 (赞：0)



# [[ARC040B] 直線塗り](https://www.luogu.com.cn/problem/AT_arc040_b)

**题意：**

我们可以发现，这一题贪心是最好的解法。关于其他解法，暴力基本没有希望，至于动态规划，只要你学得好就可以。当然我只讲关于贪心的做法，性价比最高。

**解法：**

[贪心算法](https://blog.csdn.net/qq_60462402/article/details/124109897)

注意：时间复杂度要在 $O( n^2 )$ 到 $O ( n^2 )$ 之间，不好暴力。但是我们的贪心仅仅在 $O (n) $ 就能结束，是不是特别划算。

根据贪心算法，我们要做到一个字“贪”，所以时间要尽量减少，同时也要做到最大的价值。如果我们前面有一个没有涂色的位置，但是前面又有一个价值更高的无涂色位置，我们肯定选择性价比最高的那个去涂色，一直保持时间最短价值最高的信念，直到所有部分涂色完成了之后，再加上我们的行动时间，我们的贪心不就有了吗，看代码。

**AC Code：**

```cpp
#include<bits/stdc++.h> //c++全能库
using namespace std;
int n,a,t,v; //v 是路程，t 是时间
string s; //字符串定义，要使用 cstring 头文件
int main(){
    scanf("%d%d\n",&n,&a); //输入
    cin>>s;
    t=v=0;
    for (int i=n-1;i>=0;i--)  
        if (s[i] == '.'){  //如果第 i 个点是没涂色，那么我们的距离加一。
            v=max(v,i-a+1); //贪心
            t++;//路程
            i-=a-1;
        }
return cout<<v+t<<endl, 0; //输出
}//辛苦管理员审核了呀
```
代码风气不好，大家见笑了。

奉上 [AC 记录](https://www.luogu.com.cn/record/113993994)


谢谢观看。

---

## 作者：TLEWA (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT_arc040_b)

## Part 1 暴力部分分

dfs 每次二操作的位置，非常暴力，大概是刚学 dfs 的小朋友会写的东西，时间复杂度 $O(n!)$，代码实现没什么细节，这里不给出，不能通过此题。

## Part 2 动态规划

考虑 dp，设 $\mathit{dp}_{i,j}$ 为前 $i$ 个方格已经全部变成了 `o`，现在自己在第 $j$ 个方格。根据转移方式不同，时间复杂度在 $O(n^2)$ 到 $O(n^3)$ 之间，在此题的数据范围可以通过，但是不是本题的最优复杂度，本篇题解不深入讨论这种做法，读者可以自行思考。


## Part 3 贪心

**这是本篇题解的重点。**

可以注意到，如果自己的左边还有 `.` 点，那么这种解法绝对是不符合要求的（因为没有方法将左边的 `.` 点变为 `o` 点）。所以每一次都在碰到 `.` 点时进行二操作可以保证进行的二操作次数最少（因为每次二操作都在允许的范围的最右边，可以保证把最多的 `.` 点变为 `o` 点）。但是这不能保证一操作最优。若是想要将所有 `.` 点变为 `o` 点，那么最后一次二操作的覆盖范围不能比最后一个 `.` 点的位置更左，在满足上述条件的情况下将最后一次二操作的位置尽量挪左，就可以使得一操作最少。

我们发现，如果按照二操作最优的方法先构造，然后调整最后一个二操作的位置使得一操作最优并不会改变二操作次数。也就是说这样构造的方法总步数是最少的。这种做法可以在 $O(n)$ 的时间复杂度内解决该问题。

### Part 3.1 代码实现

如果从前往后扫的话最后一个二操作的位置很难确定，我们不妨从最后扫起，将操作反过来，这样就可以确定最后一次二操作的位置了。

代码如下：

```cpp
#include<iostream>
using namespace std;

int n,s;
string str; //存储平面 

int main() {
	cin >> n >> s;
	cin >> str;
	int step=0,tag=0; //初始化计数变量 
	for(int i=str.size()-1;i>=0;--i) {
		if(str[i]=='.') {
			tag=max(tag,i+1-s); /*计算最后需要向右移动的最少次数*/
			++step;//累加二操作的次数
			for(int j=i;j>=0&&j>=i-s+1;--j) str[j]='o'; //进行操作 
		}
	}
	cout << tag+step << endl; 
	return 0;
} 


```


---

## 作者：无钩七不改名 (赞：0)

[原题戳](https://www.luogu.com.cn/problem/AT_arc040_b)



------------


是一道双指针的思维题吧。

思路如下：

+ 用一个数组 $b[i]$ 记录前缀和：从起始位置到点 $i$ 一共需要上色的点数；

+ 用 $i$ 表示所处位置，用 $j$ 表示上一次染色的最后一个点

+ $i$ 增加的条件：
	1.  $i$ 如果比 $j$ 大， $i$ 、 $j$ 之间不能有需要染色的点；
	2.  $i$ 要小于等于 $(n-s+1)$ （因为大了会浪费时间的，没必要增加了）
	3. 如果 $(i+s-1)$ 到 $n$ 之间没有需要染色的点了就不需要增加了

核心代码：

```cpp
if(b[n]==0){
	printf("0");
	return 0;
}
//特判
for(int i=1,j=0;i<=n-s+1;i++){
	while(i<n-s+1&&(b[i]-b[j]==0||i<=j)&&b[i+s-1]<b[n]){//判断
		i++;//前进一步
		ans++;//操作时间增加
	}
	j=i+s-1;//更新最后一个染色的点
	ans++;//染色需要时间，时间增加
	if(b[j]==b[n])break;//如果(j+1)到n之间没有需要染色的点了就跳出循环
	ans++;//此处其实藏了循环的i++，因此时间也要增加
}

```


---


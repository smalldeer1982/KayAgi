# [ABC069D] Grid Coloring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc069/tasks/arc080_b

縦 $ H $ 行、横 $ W $ 列のマス目があります。 すぬけ君は、このマス目を色 $ 1 $, $ 2 $, $ ... $, $ N $ で塗り分けようとしています。 このとき、次の条件が成り立つようにします。

- 各 $ i $ ($ 1\ <\ =\ i\ <\ =\ N $) について、色 $ i $ のマスはちょうど $ a_i $ 個存在する。 ただし、$ a_1\ +\ a_2\ +\ ...\ +\ a_N\ =\ H\ W $ である。
- 各 $ i $ ($ 1\ <\ =\ i\ <\ =\ N $) について、色 $ i $ のマスは上下左右に連結である。 すなわち、どの色 $ i $ のマスからどの色 $ i $ のマスへも、上下左右に隣り合う色 $ i $ のマスのみを辿って行き来できる。

条件を満たす塗り分け方をひとつ求めてください。 解は必ず存在することが示せます。

## 说明/提示

### 制約

- $ 1\ <\ =\ H,\ W\ <\ =\ 100 $
- $ 1\ <\ =\ N\ <\ =\ H\ W $
- $ a_i\ >\ =\ 1 $
- $ a_1\ +\ a_2\ +\ ...\ +\ a_N\ =\ H\ W $

### Sample Explanation 1

例えば、次の塗り分け方は条件を満たしません。 色 $ 1 $ のマスが上下左右に連結でないからです。 ``` 1 2 3 1 ```

## 样例 #1

### 输入

```
2 2
3
2 1 1```

### 输出

```
1 1
2 3```

## 样例 #2

### 输入

```
3 5
5
1 2 3 4 5```

### 输出

```
1 4 4 4 3
2 5 4 5 3
2 5 5 5 3```

## 样例 #3

### 输入

```
1 1
1
1```

### 输出

```
1```

# 题解

## 作者：Ryo_Yamada (赞：0)

考虑对于每行填充，只需要连续填充同一种颜色就能保证同一行内同种颜色一定联通。而行之间只需要使换行后的第一块与上一行填充的最后一块联通即可。所以蛇形填充即可。

```cpp
int n, m, k;
int ans[105][105];
int a[10005];

int main() {
	qread(n, m, k);
	rep(i, 1, k) qread(a[i]);
	int nw = 1;
	rep(i, 1, n) {
		if(i & 1) {
			rep(j, 1, m) {
				ans[i][j] = nw;
				--a[nw];
				if(!a[nw]) ++nw;
			}
		}
		else {
			per(j, m, 1) {
				ans[i][j] = nw;
				--a[nw];
				if(!a[nw]) ++nw;
			}
		}
	} 
	rep(i, 1, n) rep(j, 1, m) printf("%d%c", ans[i][j], " \n"[j == m]);
	return 0;
}
```

---

## 作者：fly20040720 (赞：0)

题意：有N种颜色，第i种ai个格子，要填满一个H\*W的方格，且同种颜色不许形成连通块 只有上下左右相邻才算作连通

题目构造方法应该很多，但是只要随便推一下就能发现，蛇形填涂是肯定行的，因为每一个都必定和上一个连通。
```
#include <bits/stdc++.h>
using namespace std;

int h,w,n;
int Grid[1000][1000];
vector<int>v;
    
int main()
{
    cin>>h>>w>>n;
    int x;
    for(int i=0;i<n;i++)
    {
        cin>>x;
        for(int j=0;j<x;j++)
            v.push_back(i+1);
    }
    for(int i=0;i<h;i++)
    {
        if(i%2==0)
            for(int j=0;j<w;j++)
                Grid[i][j]=v[w*i+j];
        else
            for(int j=0;j<w;j++)
                Grid[i][w-1-j]=v[w*i+j];
    }
    for(int i=0;i<h;i++)
    {
        for(int j=0;j<w;j++)
            cout<<Grid[i][j]<<' ';
        cout<<endl;
    }
}


---


# [ABC101C] Minimization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc101/tasks/arc099_a

長さ $ N $ の数列 $ A_1,\ A_2,\ ...,\ A_N $ があります．最初，この数列の要素は $ 1,\ 2,\ ...,\ N $ を並び替えたものになっています．

スヌケ君は，この数列に対して次の操作を行うことができます．

- 数列のうち，連続した $ K $ 個の要素を選ぶ．その後，選んだ要素それぞれの値を，選んだ要素の中の最小値で置き換える．

スヌケ君は，上の操作を何回か繰り返すことで，この数列の要素をすべて等しくしたいです． 必要な操作の回数の最小値を求めてください． この問題の制約の下，このようなことは必ず可能であることが証明できます．

## 说明/提示

### 制約

- $ 2\ \leq\ K\ \leq\ N\ \leq\ 100000 $
- $ A_1,\ A_2,\ ...,\ A_N $ は $ 1,\ 2,\ ...,\ N $ の並び替え

### Sample Explanation 1

例えば，次のようにするとよいです： - $ 1 $ 回目の操作では，$ 1,\ 2,\ 3 $ 番目の要素を選ぶ．すると，数列 $ A $ は $ 1,\ 1,\ 1,\ 4 $ になる． - $ 2 $ 回目の操作では，$ 2,\ 3,\ 4 $ 番目の要素を選ぶ．すると，数列 $ A $ は $ 1,\ 1,\ 1,\ 1 $ になる．

## 样例 #1

### 输入

```
4 3
2 3 1 4```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3
1 2 3```

### 输出

```
1```

## 样例 #3

### 输入

```
8 3
7 3 1 8 4 6 2 5```

### 输出

```
4```

# 题解

## 作者：lkjzyd20 (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/AT4160)

### 思路

对于这道题，读入的 $a$ 数组最终肯定会变成 $1$。

$\because$  读入的是 $1 \sim n$，最小值是 $1$。

$\therefore$  $a$ 数组最终肯定会变成 $1$。  

按照最优决策   

每次推平一定在 $1$ 的最边边，扩展时变为 $1$ 的元素数量为 $k - 1$ 个。

$\because$ 一开始已经有一个 $1$ 了,

$\therefore$ 答案即为 $\lceil\  (n - 1)\ \div\ (k - 1)\ \rceil$

代码如下：

```cpp
#include <stdio.h>
#include <cmath>

int n, k;

main () {
	scanf ("%d %d", &n, &k) ;
	
	printf ("%d", (int) (ceil ( (n - 1) * 1.0 / (k - 1) ) ) ) ;
}

```

### 完结撒花 $\sim\sim\sim$。

---

## 作者：皎月半洒花 (赞：4)

很多人写的比较麻烦。要去扫整个 $\{a_n\}$ 。然而这题 $n$ 是可以开到 $1e18$ 的。

考虑由于所有数不相同，所以最优决策一定是从最小的那个位置开始拓展。之后每次选择区间，必然是选择一个最多与之前那个区间相交为 $1$ 个元素的区间开始。所以最后答案就是 $1+\lceil\frac{n-k}{k-1}\rceil$。跟 $\{a_n\}$ 无关。


---

## 作者：Velix (赞：3)

简单结论题。

---

首先，我们可以看出由于是一个长度为 $n$ 的排列，所以对于所有的数，它们最终肯定会赋值为 $1$，所以只用读入 $n$、$k$ 就行了。

那答案是什么呢？

根据贪心法可得，每次进行选择时在每一端的最边的那一段扩展，也就是说，每一次扩展时变为 $1$ 的元素数量为 $k-1$。

由于最开始已经有一个 $1$ 了，所以答案为

$$\left\lceil\dfrac{n-1}{k-1}\right\rceil$$

---

## 作者：hyc1026 (赞：1)

### 思路：

每次向下推平到最小值，意味着该数组最后所有元素都会被推平到 $1$。为了避免做无用功，我们可以通过一定的操作使得每次操作都满足以下条件：

- 包含 $1$。这是为了使得它推平后结果为 $1$，避免再次推平。

- 仅包含一个 $1$。这是为了避免不必要的资源浪费。

需要注意的是，每次仅能将 $k-1$ 个非 $1$ 数字推平至 $1$。

我们可以按照如下思路构造：

- 找到 $1$ 的位置。

- 求出 $1$ 的右面的元素个数，并对 $k-1$ 取余，称之为 $p$。

- 在第一次操作时将 $1$，以及其右面的 $p$ 个，左面的 $k-p-1$ 个推平。

- 继续向右推平。由于刚才的操作，向右推平一定没有剩余。

- 向左推平。

此时，我们可以总结，本题无序看数组的排布，推平最小次数仅和 $n,k$ 有关，最小的操作次数为：

$$\left\lceil \dfrac{n-1}{k-1} \right\rceil$$

### AC Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int a;

int main()
{
    int n,k;
    cin >> n >> k;
    for(int i=1; i<=n; i++) cin >> a;
    cout << (n+k-3) / (k-1) << endl; // 这样做不明白的请继续阅读
}
```

### 拓展：

原式可以变成：

$$\left\lfloor \dfrac{n+k-3}{k-1} \right\rfloor$$

原因是：

$$\left\lceil \dfrac{a}{b} \right\rceil = \left\lfloor \dfrac{a+b-1}{b} \right\rfloor$$

两个式子之间并无本质区别，都可以 AC 此题，但在实际应用中如果拿不准尽量写最原始的式子。

---

## 作者：linbaicheng2022 (赞：1)

## 1.题目

[题目传送门](https://www.luogu.com.cn/problem/AT4160)

## 2.思路

~~就这题也配标成黄题？？？~~

**很水的一道总结公式题**

根据题意，不难得到最后序列要全部变成序列中最小的值。

因为序列由 $1$ 到 $n$ 组成，所以最小值为 $1$。

根据贪心法可得，每次进行选择时在每一端的最边的那一段扩展，也就是说，每一次扩展时变为 $1$ 的元素数量为 $m-1$ 。

最终公式为:

$$
\boxed{ans = \lceil {n-1 \over m-1} \rceil}
$$

## 3.代码：

```cpp
#include <iostream>
#include <cmath>

using namespace std;

const int N = 100010;
int n, m, a[N];

int main () {
	cin >> n >> m;
	
	for (int i = 1; i <= n; i ++)
		cin >> a[i];
		
	int ans = ceil ((double) (n - 1) / (double) (m - 1));
	cout << ans << endl;	
	return 0;
}
```

---

## 作者：Daidly (赞：1)

首先我们要知道，无论 $k$ 为多少，只要序列中有 $1$，那么平推后的结果必然全是 $1$，这个不难证明。

所以只要先平推有 $1$ 的 $k$ 个数区间，剩下还有 $n-k$ 个数。每一次包含一个 $1$，再包含 $k-1$ 个其他数。这样，那 $k-1$ 个其他数都会变成 $1$，这个的次数为$\left\lceil\frac{n-k}{k-1}\right\rceil$，再加上 $1$，就等于 $\left\lceil\frac{n-k+(k-1)}{k-1}\right\rceil=\left\lceil\frac{n-1}{k-1}\right\rceil$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double n,k;
int main(){
	cin>>n>>k;
	cout<<ceil((n-1)/(k-1));
}
```

---

## 作者：零殇 (赞：0)

#### 思路

根据题意，不难得到最后序列要全部变成序列中最小的值。

因为序列由$1$到$n$组成，所以最小值为$1$。

因此可以直接向外推平。

不过用数组模拟太麻烦了。

我们可以直接推结论。

因为并没有规定$1$必须是边缘那个数，因此我们可以确保一边完全推平不会造成浪费。

然后向另一边推平。

既然已经确保了一边不会浪费，那么把最初的$1$放到边缘也没有区别。

举个例子（红色代表最初的$1$）：

$n=8,k=3$

原序列：

$2$ $3$ $4$ $1$ $5$ $6$ $7$ $8$

向左推平得：

$1$ $1$ $1$ $\color{red}1$ $1$ $6$ $7$ $8$

等同于：

$\color{red}1$ $1$ $1$ $1$  $1$ $6$ $7$ $8$

因此我们可以直接用$n-1$除以$k-1$得到答案。

上代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[100001];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
	} 
	cout<<ceil((double)(n-1)/(double)(k-1))<<endl;
}
```

完结撒花~

---


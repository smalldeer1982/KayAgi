# [ARC132B] Shift and Reverse

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc132/tasks/arc132_b

$ 1,\dots,\ n $ の順列 $ p_1,\dots,p_n $ が与えられます。 この順列に対して以下の操作を、好きな順で何度でも行えます。

- 全体をひっくりかえす。つまり、$ p_1,p_2,\dots,p_n $ を $ p_n,p_{n-1},\dots,p_1 $ に並び替える。
- 先頭の項を末尾に移動させる。つまり、$ p_1,\ p_2,\ \dots,p_n $ を $ p_2,\dots,\ p_n,\ p_1 $ に並び替える。

順列を昇順に並び替えるのに必要な操作回数の最小値を求めてください。 ただし、与えられる入力について、これらの操作によって順列を昇順に並び替えられることが保証されています。

## 说明/提示

### 制約

- $ 2\ \leq\ n\ \leq\ 10^5 $
- $ p_1,\dots,p_n $ は $ 1,\dots,n $ の順列
- 問題文中の操作によって $ p_1,\dots,p_n $ を昇順に並び替えられる

### Sample Explanation 1

次のように操作すると $ 2 $ 回で昇順に並び替えできます。 1. 先頭の項を末尾に移動させ、 $ 3,\ 2,\ 1 $ に並び替える。 2. 全体をひっくりかえし、$ 1,\ 2,\ 3 $ に並び替える。 $ 2 $ 回未満の操作で昇順に並び替えることはできないため、答えは $ 2 $ です。

### Sample Explanation 2

どちらの操作をしても $ 1 $ 回で昇順に並び替えできます。 $ 1 $ 回未満の操作で昇順に並び替えることはできないため、答えは $ 1 $ です。

### Sample Explanation 3

次のように操作すると $ 3 $ 回で昇順に並び替えできます。 1. 全体をひっくりかえし、$ 1,10,9,8,7,6,5,4,3,2 $ に並び替える。 2. 先頭の項を末尾に移動させ、 $ 10,9,8,7,6,5,4,3,2,1 $ に並び替える。 3. 全体をひっくりかえし、 $ 1,2,3,4,5,6,7,8,9,10 $ に並び替える。 $ 3 $ 回未満の操作で昇順に並び替えることはできないため、答えは $ 3 $ です。

### Sample Explanation 4

一度も操作する必要がありません。

## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2
2 1```

### 输出

```
1```

## 样例 #3

### 输入

```
10
2 3 4 5 6 7 8 9 10 1```

### 输出

```
3```

## 样例 #4

### 输入

```
12
1 2 3 4 5 6 7 8 9 10 11 12```

### 输出

```
0```

# 题解

## 作者：chinazhanghaoxun (赞：6)

## 题意

如题面翻译，翻译的非常简洁明了。
## 分析

这道题最大的突破口就是在题目中说“数据保证有解”。那么我们就可以得到一个结论，就是这个序列并不是一种完全杂乱的状态，而是出于一种半有序状态。我们只要移动一些元素，就可使序列有序。移动又只有两种方式，分别为将前面的一些元素有序移动到后面，以及将整个序列翻转。

例如这个例子：```4 5 6 7 8 9 1 2 3```，显然这个序列有两种操作方式。

- 第一种是不用翻转，直接从前面移动 6 个元素到最后，可以达到题目所说的效果。
- 第二种是先翻转，然后移动 3 次，最后再翻转回来，一共使用 5 次操作。

经过这样的推论，可以发现整个序列我们只需要 $n$ 和 $a_1$ 以及 $a_2$，需要进行的操作只有 3 种情况。

1.  序列已经有序，不需要操作，直接输出 0 即可。
2.  只使用移动元素这一种操作，操作次数为 $n-a_1+1$ 次。
3.  先翻转再移动最后又翻转一遍，操作次数为 $a_1+1$。

对于后 2 种操作，视情况而定选哪种，所以我们要取 $\min(n-a_1+1,a_1+1)$，我说还要用 $a_2$ 纯粹只是为了判断是否已经有序。
## 代码+注释

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a1,a2;
	cin>>n>>a1>>a2;
	if(a1==1 && a2==2){ //已经有序，直接输出0 
		cout<<0;
		return 0;
	}
	cout<<min(n-a1+1,a1+1);//两种情况取最小值 
    return 0;
}
```

---

## 作者：EternalHeart1314 (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/AT_arc132_b)

# 思路

我认为题目中最重要的信息是“数据保证有解”。

这意味着有以下三种情况：

1. 序列为 $\{1,2,\cdots,n\}$，可以直接输出 $0$。

2. 序列为 $\{m,m+1,\cdots,n,1,2,\cdots,m-1\}$，这种情况有两种做法：

> 1. 直接把前 $n-m+1$ 个数依次移到后面，此时序列变成 $\{1,2,\cdots,m-1,m,m+1,\cdots,n\}$，也就是 $\{1,2,\cdots,n\}$。一共 $n-m+1$ 次操作。
>
> 2. 先把序列反转，此时序列变成 $\{m-1,m-2,\cdots,1,n,n-1,\cdots,m\}$，再把前 $m-1$ 个数依次移到后面，此时序列变成 $\{n,n-1,\cdots,m,m-1,m-2,\cdots,1\}$，也就是 $\{n,n-1,\cdots,1\}$，最后反转一下，就变成了 $\{1,2,\cdots,n\}$。一共 $1+(m-1)+1=m+1$ 次操作。

所以，这种情况的操作数为 $\min(n-m+1,m+1)$。

3. 序列为 $\{m,m-1,\cdots,1,n,n-1,\cdots,m+1\}$，这种情况有两种做法：

> 1. 直接把前 $m$ 个数依次移到后面，此时序列变成 $\{n,n-1,\cdots,m+1,m,m-1,\cdots,1\}$，也就是 $\{n,n-1,\cdots,1\}$，再把序列反转，此时序列变成 $\{1,2,\cdots,n\}$。一共 $m+1$ 此操作。
>
> 2. 先把序列反转，此时序列变成 $\{m+1,m+2,\cdots,n,1,2,\cdots,m\}$，再把前 $n-m$ 个数依次移到后面，此时序列变成 $\{1,2,\cdots,m,m+1,m+2,\cdots,n\}$，也就是 $\{1,2,\cdots,n\}$。一共 $1+(n-m)=n-m+1$ 次操作。

所以，这种情况的操作数为 $\min(m+1,n-m+1)$。

你会发现第二种情况和第三种情况的操作数一样，所以可以合并成一种，很神奇吧。

# Code
```
#include<bits/stdc++.h>
using namespace std;

int n, x, y;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> x >> y;
	if(x == 1 && y == 2) {
		return cout << 0, 0;
	}
	return cout << min(x + 1, n - x + 1), 0;
}
```

### 珍惜生命，远离抄袭

---

## 作者：Ray_yi (赞：2)

### 思路：

容易发现，题目**保证一定有解**。

且只能进行的两种操作：
1. 翻转整个数列。
2. 将第一个数挪到最后面。

说明数列 $a$ 是**半排序**的。

在这种情况下，这个数列就只有两种情况：
1. 一开始就是**有序**的，不需要任何操作，这时就直接输出 $0$ 即可。
2. 一开始是**无序**的，而在这种情况下，容易发现，这个数列也只有两种情况。要么**只需要移动数**，也就是第二种操作，要么**先翻转再移动有可能又翻转**。而在这两种情况下，操作次数都可以算出来，最后把这两种情况取一个最小值就可以了。

具体看代码。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,r;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>l>>r;
	if(l==1&&r==2) cout<<0;
	else cout<<min(l+1,n-l+1);
	/*只需要移动数：l+1 */
	/*先翻转再移动有可能又翻转：n-l+1 */
	return 0;
}
```

---

## 作者：chlchl (赞：2)

## 题意简述 & 翻译
给定一个 $1\sim n$ 的排列 $a$，每次可以对其进行下面两种操作的其中之一：
1. 取反整个数列，即 $\{a_1,a_2,\cdots,a_n\}\rightarrow\{a_n,a_{n-1},\cdots,a_1\}$。
2. 将第一个数挪到最后面，即 $\{a_1,a_2,\cdots,a_n\}\rightarrow\{a_2,a_3,\cdots,a_n,a_1\}$。

问若要将 $a$ 变成 $\{1,2,\cdots,n\}$，至少需要多少次操作。数据保证有解。

## Question
首先，有解的情况是什么？

假设我们现在的目标是把原数组变成完全升序或完全降序（降序时再翻转一次即可得到升序，所以是等价的）。

这样可以不用考虑操作 1。我们再以升序为例。

此时，若 $\exists i\in[1,n)$ 满足 $a_i>a_{i+1}$，那么我们需要通过很多次 2 操作交换 $i,i+1$。

但是，若 $\exists k\in[1,i),a_k>a_i$，那么 $i$ 被挪到最后之后，它一定在 $i$ 的前面。你会发现 $i,i+1$ 合法了，但是 $k',i'$ 又挂了（$i',k'$ 表示移位后 $i,k$ 对应的位置）。

因此，我们一定需要满足至多存在一对 $(i,i+1)$，有 $a_i>a_{i+1}$。换言之，$\forall j\in[1,i),a_j<a_{j+1}$。同理，$\forall j\in[i+2,n),a_j<a_{j+1}$。

显然只有当 $a_i=n,a_i=1$ 时才能满足条件。此时 $a=\{\cdots,n-2,n-1,n,1,2,\cdots\}$。

同理，你可以推出剩下几种情况类似。

所以，我们得出结论：**当且仅当 $a$ 半有序的时候才能有解。**

## Solution
根据 `question` 中的推论，我们发现 $1$ 和 $n$ 的位置尤为重要。

设 $1$ 的初始位置为 $p$。讨论以下 4 种情况（并且以 $n=6$ 作为例子）：
- $p$ 在数组**前**半边且数组**升**序排列（如 $\{5,6,1,2,3,4\}$）。此时直接把它前面的东西挪到后面去即可，操作次数 $p-1$。
- $p$ 在数组**前**半边且数组**降**序排列（如 $\{2,1,6,5,4,3\}$）。将 $p$ 和它前面的全部挪到后面，此时就递减了，直接翻回来即可，操作次数 $p+1$。
- $p$ 在数组**后**半边且数组**升**序排列（如 $\{3,4,5,6,1,2\}$）。翻转之后就是第二种情况。记翻转之后的位置为 $p'=n-p+1$，操作次数 $1+p'+1=n-p+3$。

- $p$ 在数组**后**半边且数组**降**序排列（如 $\{4,3,2,1,6,5\}$）。翻回来之后就是第一种情况，操作次数 $1+(p'-1)=n-p+1$。

但是注意一下两种情况情况：
1. 当 $n$ 为奇数且 $p$ 刚好在正中央时，我把它归到后半部分了。这可以正确地解决 $\{2,1,3\}$ 这种降序的情况。但对于 $\{3,1,2\}$ 这种情况，它会把序列转到 $\{2,1,3\}$ 再操作。但实际上，只需要把 $3$ 挪到后面就行了。因此，在这种情况下需要特判。
2. $n=2$ 特判。

判断一下就行，贴代码收工。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, p, op1, op2, a[N];

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%d", &a[i]);//数组一定半有序
	if(n == 2)
		return printf("%d\n", (a[1] == 1 ? 0 : 1)), 0; 
	for(int i=1;i<=n;i++){
		if(a[i] == 1){
			p = i;
			op1 = (p <= n / 2 ? 0 : 1);//前半 0，后半 1 
			if(i > 1)
				op2 = (a[i - 1] == n ? 0 : 1);//升序 0 降序 1 
			else
				op2 = (a[i + 1] == 2 ? 0 : 1);
		}
	}
	if(!op1 && !op2)//前半部分 & 升序（5 6 1 2 3 4），直接往后挪 
		printf("%d\n", p - 1);
	else if(op1 && !op2)//后半部分 & 升序（3 4 5 6 1 2），取反、挪位、取反 
		printf("%d\n", min(n - p + 3, p - 1));//特判，{3,1,2} 类型的操作次数是p-1
	else if(!op1 && op2)//前半部分 & 降序（2 1 6 5 4 3），挪位 + 取反 
		printf("%d\n", p + 1);
	else if(op1 && op2)//后半部分 & 降序（4 3 2 1 6 5），取反 + 移位 
		printf("%d\n", n - p + 1);
	return 0;
}
```

好题，适合提升思维。

---

## 作者：PengRuiXuan (赞：1)

## 题目大意

有两种操作，第一种是把整个数列倒过来，第二种是把数列中的第一个数放到最后一个，问你最少需要几次操作能让数列有序，**题目保证有解**。

## 思路

既然题目**保证有解**，那么就很简单了，只有三种情况，分别是：

1. 如果数列第一个数和第二个数有序，那么不需要排序，直接输出零就好了。

2. 如果数列无序，那么将数列反转移动再反转，需要 $a+1$ 次。

3. 如果数列无序，那么直接把元素一个一个移动到后面，需要 $n−a+1$ 次。

如果无序，使用 $\min$ 函数判断第二种方法需要的次数少还是第三种方法需要的次数少。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n, x, y;
	cin >> n >> x >> y;
	if (x == 1 && y == 2) {
		cout << 0 << endl;
	} else {
		cout << min(n - x + 1, x + 1) << endl;
	}
	return 0;
}
```

---

## 作者：JCT_addyi (赞：1)

### 题意：

只有两个操作每次只能用一种：

1. 将整个数列倒过来。
2. 把第一个数放到末尾。

问用几次操作能使数列从 $1$ 到 $n$ 有序。
### 思路：

我们只能动开头和结尾，如果开头有序中间和结尾无序就无解，但题目保证一定有解，那么开头有序就有解，我们再枚举一下发现只用枚举第一个和第二个数。

如果第一个和第二个数有序就输出 $0$ 。

如果第一个和第二个数无序：

1. 直接移动不用反转，从头一个一个移动到末尾，就要操作 $n$ 减 $a$ 加 $1$ 次。
2. 反转再移动再反转，就操作 $n$ 加 $1$ 次。

最后取最小值。

### 代码如下：

详细看代码。

```
#include<bits/stdc++.h>
using namespace std;
int n,a,b;
int main(){
	cin>>n>>a>>b;
	if(a==1&&b==2) cout<<0;//有序
	else cout<<min(a+1,n-a+1);//先反转再移动 直接移动
	return 0;
}
```

谢谢大家！

---

## 作者：Yiyi_52MIYEON1314 (赞：1)

# 题意
[题目链接，不爱看题的快去给我看！！](https://www.luogu.com.cn/problem/AT_arc132_b)

翻译简洁，不再赘述了哈。

# 思路
由于题目说**数据保证有解**，所以题目所给数据一定是通过某些操作就可以轻易得到的，并不是我们想象的那样杂乱无章。

现在，我们来尝试枚举出所有可能**需要进行的操作情况**。

1. 无需进行任何操作，本身有序。这种情况我们只需要**判断第一项和第二项的值**，证明：如果前两项为 $1$ 和 $2$ 且序列无序，那么这种情况是无解的，而题目保证有解。
2. 只使用了**移动元素**这一种操作，操作次数为移动的个数，也就是 $n-a_1+1$。
3. **先反转再移动最后再反转**，操作次数为最后一个元素加 $2$ ，实际上就是 $a_1+1$。

最后取情况 $2$ 和情况 $3$ 的最小值即可。

_如果不能理解，可以根据样例或自己再举几个例子进行分析_。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a1,a2;
int main()
{
	cin>>n>>a1>>a2;
	if(a1==1&&a2==2){
		cout<<0<<endl;
	}
	else{
		cout<<min(n-a1+1,a1+1)<<endl;
	}
 	return 0;
}

```
### 谢谢大家！

---

## 作者：_hxh (赞：1)

### 分析

非常巧妙的一道题，看懂了就很简单。

首先题目中说**数据保证有解**，这说明这个序列不会“特别乱”，我们可以通过 $\textcolor{blue}{取反整个数列}$ 和 $\textcolor{blue}{将第一个数挪到最后面}$ 这两种操作使这个排列 $a$ 变得有序。

由于**先取反整个序列再将第一个数挪到最后面再取反整个序列等于将最后一个数挪到最前面**，所以其实这个序列只有两种情况：

1. 一开始就是有序的，不用进行任何操作；
2. 一开始是无序的，但可以拆成两个单调区间（同为单调递增或单调递减）。形如 $n,n - 1,n - 2,\dots,2,1$ 的序列除外。

举个例子：`1 2 3 4` 的排列，只有这几种情况：

`1 2 3 4` `2 3 4 1` `3 4 1 2` `4 1 2 3`  
`4 3 2 1` `1 4 3 2` `2 1 4 3` `3 2 1 4`

对于一开始是无序的情况，有两种操作方法：

1. 直接将元素一个一个移到后面（有可能需要再取反）；
2. 先取反整个序列，再将元素一个一个移到后面（有可能需要再取反）。

由于题目让我们求**最少**的操作次数，所以我们要计算这两种操作需要的次数，然后取最小值。

### Code

非常简短。$a$ 是用来计算操作次数的，$b$ 仅仅是判断序列一开始是不是有序的。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a,b;
int main()
{
	cin >> n >> a >> b;
	if (a == 1 && b == 2)
		cout << 0 << endl;
	else
		cout << min(a + 1,n - a + 1) << endl;
	return 0;
}
```

---

## 作者：huangzilang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/AT_arc132_b)

**题目大意：**

给定一个数组 $a$，每次可以对其进行下面两种操作的其中之一：

- 取反整个数列。
- 将第一个数挪到最后面。

问若要将 $a$ 变成 $\left\{{1,2,⋯,n}\right\}$，至少需要多少次操作。**数据保证有解**。

**思路：**

由于题目说了数据保证有解，所以这个数组就只有两种情况：

1. 一开始就是有序的，不用进行任何操作，我们可以直接输出 $0$；
2. 一开始是无序的，我们可以将前面的向后挪使序列降序，然后反转序列，这种方法就要用 $n-a_1+1$ 次，$n-a_1$ 就是将前面的向后挪的次数，然后反转序列又用一次；或着将序列反转后将前面的向后挪使序列降序再翻回来，这种方法就要用 $a_1+1$ 次，输出较小的即可。

如何判断这个数组是否有序呢？

我们可以在输入前定义一个变量 $bz$，它的初值是 $0$，在输入时，如果 $a_i$ 不等于 $i$，那么 $bz$ 的值就设为 $1$，输入完后，如果 $bz$ 的值依旧是 $0$，那就说明是有序的。

**代码：**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
int main()
{
	scanf("%d",&n);
	int bz=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]!=i)
		{
			bz=1;
		}
	}
	if(bz==0)
	{
		cout<<0;
		return 0;
	}
	else
	{
		cout<<min(n-a[1]+1,a[1]+1);
	}
} 
```

---

## 作者：herezz (赞：0)

### 思路：
这个序列只有 $a_1$，$a_2$ 有用：  
如果 $a_1=1$ 且 $a_2=2$，那么无需排序（否则无解）；  
否则，将前面的向后挪使序列降序后反转序列（$n-a_1+1$ 次），或着将序列反转后将前面的向后挪使序列降序再翻回来（$a_1+1$ 次），比较输出即可。  
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,a1,a2;
    cin>>n>>a1>>a2;
    if(a1==1&&a2==2)cout<<0;
    else cout<<min(a1+1,n-a1+1);
}
```

---

## 作者：nieqiuran (赞：0)

### AT_arc132_b 题解
[题目传送门](https://www.luogu.com.cn/problem/AT_arc132_b)
#### 题意
有两个操作，分别是把整个数列倒过来和把数列中的第一个数放到最后一个，问最少需要几次操作能让数列有序，题目保证有解。
#### 思路
题目保证有解就简单不少了，这意味着最多只有三种情况，分别是：
1. 数列第一个数和第二个数有序，不用排序，直接输出零。
2. 若无序，把元素直接一个一个移动到后面，要 $n−a+1$ 次。
3. 若无序，反转移动再反转，要 $a+1$ 次。

若无序最终看第二种方法需要的次数少还是第三种，用最小值函数即可。

[代码](https://www.luogu.com.cn/paste/waxnha4c)

---

## 作者：New_Void (赞：0)

# [[ARC132B] Shift and Reverse](https://www.luogu.com.cn/problem/AT_arc132_b)



### 思路
这道题我们分类讨论：

- 第一种情况就是已经排好序了，那就输出零。
- 第二种情况就是将数组中的头部元素一个一个的放到尾部，一共移动 $n-f+1$ 个元素，所以这种情况的公式就是 $n-f+1$ 了。
- 第三种情况就是将数组整个翻转，然后再将头部元素一个个放到尾部，第一次翻转次数是 $1$ 次，之后再将前 $n-f$ 个元素放入尾部，所以总次数是 $n-f+1$ 次。
- 第四种情况就是先将前 $f$ 个元素放入尾部，之后再翻转一次，所以总次数就是 $f+1$ 次。

而第二种情况和第三种情况的公式一样，所以省略一个。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n,f,s;
    cin>>n>>f>>s;
    if (f==1 && s==2){
        cout<<0<<endl;
        return 0;
    }
    cout<<min(f+1,n-f+1)<<endl;
    return 0;
}
```

---

## 作者：drah_yrev (赞：0)

### 题意简述
题面非常简洁，不是小作文。就是把一个数字串，通过翻转与把第一个数放到最后面，数据保证有解。
### 思路
我们通过已知条件分析此题：

如果进行翻转，翻转后不会再翻转，所以翻转后只会把第一个数放到最后面。

如果是有序数组的话，那么数组就不用动了。
  
所以如果会动的话，动的方式无非以下两种：

如果只把第一个数放到最后面，要 $n-a_1+1$ 步；

如果先翻转，再把第一个数放到最后面，最后再翻转,要   $n-a_1+1$ 步。

综上所述：我们只需要将上面两种步数求最小值就可以啦。

PS：记得特判数组是不是有序哦！

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
int main(){
	cin>>n>>x>>y;
	if(x==1&&y==2)cout<<0;
	else cout<<min(x+1,n-x+1)<<endl;
	return 0;
}


```

[过力](https://www.luogu.com.cn/record/176384619)

---

## 作者：lovely_codingcow (赞：0)

## 题意

有一个序列，你可以将它**翻转**或者将**第一个数挪到最后面**，求最小的操作使得序列升序的次数。**数据保证有解**。

## 思路

首先我们可以看到题目中说**保证一定有解**，因此我们可以发现挪动的方式一定是将前面的数整体挪到到后面或者翻转后将前面的数移到后面再翻转回来。看一个例子：

```
3 4 5 6 7 8 9 10 1 2
```

答案显然是将序列整体翻转后将 `2 1` 挪到最后面然后再翻转回来，次数为 $4$。

有了上面的结论，我们就可以分类讨论一下：

- **有序。** 直接输出 $0$。
- **直接移动**。 答案为 $n - a_1 + 1$。
- **翻转后移动再翻转。** 答案为 $a_1 +1$。

对于后面的两种情况，取最小值即可。

## 代码

```cpp
#include <iostream>

using namespace std;

int n, a[3];

signed main() {
	cin >> n >> a[1] >> a[2];
	if (a[1] == 1 && a[2] == 2) {
		cout << 0;
	} else {
		cout << min(a[1] + 1, n - a[1] + 1);
	}
}
```

---

## 作者：_czy (赞：0)

### 题意

有一个排列，你可以取反整个排列，也可以将第一个移到最后，问将它变成 $\{1,2,\cdots,n\}$。

### 分析

容易发现：取反操作不会影响排列是否有序，而且由于可以将第一个移到最后。所以我们发现，整个序列是半有序的，通过移动可以使其有序。

### 实现

所以，我们可以通过第一个数确定要移动的个数。

容易发现，只有两种方式会是最优解，将前半段有序的移到最后，将后半段有序的移到最前，我们可以将它们取 $\min$。

就有了以下简洁的代码：

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
int main(){
	scanf("%d%d%d",&n,&x,&y);
	if(x==1&&y==2)putchar(48);\\特判
	else printf("%d",min(x+1,n-x+1));
}
```

---


# [ARC150A] Continuous 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc150/tasks/arc150_a

`0`, `1`, `?` のみからなる長さ $ N $ の文字列 $ S=S_1S_2\dots\ S_N $ が与えられます。

これから $ S $ に含まれるすべての `?` を `0`, `1` のいずれかに置き換えることで、以下の条件がすべて満たされるようにしたいです。

- $ S $ は `1` をちょうど $ K $ 個含む。
- $ K $ 個の `1` は連続している。すなわち、ある $ i\ (1\ \leq\ i\ \le\ N-K+1) $ があって、$ S_i=S_{i+1}=\dots=S_{i+K-1}= $ `1` が成り立つ。

条件を満たすような `?` の置き換え方がちょうど $ 1 $ 通りであるか判定してください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^5 $
- $ 1\ \leq\ K\ <\ N\ \leq\ 3\ \times\ 10^5 $
- $ S $ は `0`, `1`, `?` のみからなる長さ $ N $ の文字列
- 全テストケースに対する $ N $ の総和は $ 3\ \times\ 10^5 $ 以下

### Sample Explanation 1

$ 1 $ 個目のテストケースについて、例えば $ S $ を `101` に変えることができますが、この場合は `1` が連続していないため、条件を満たしません。 $ S $ が条件を満たすようにするには $ S $ を `110` に変えるしかありません。 $ 2 $ 個目のテストケースについて、 $ S $ が条件を満たすようにするには $ S $ を `1100`, または `0110` に変えればよく、条件を満たすような `?` の置き換え方は $ 2 $ 通りあります。 $ 3 $ 個目のテストケースについて、$ S $ が条件を満たすよう `?` を置き換える方法は存在しません。

## 样例 #1

### 输入

```
4
3 2
1??
4 2
?1?0
6 3
011?1?
10 5
00?1???10?```

### 输出

```
Yes
No
No
Yes```

# 题解

## 作者：FReQuenter (赞：4)

## 题意

给你一个长度为 $N$ 的字符串 $S$，仅含 `0`，`1`，`?`，问你能不能通过把一个 `?` 变成任意 `0` 或 `1`，**仅有一种方案**使得这个字符串**有且仅有一段**连续的 `1`，且长度为 $K$。

## 思路

对于每一段 $S_i,S_{i+1},...,S_{i+k-1}$，要使得它们全是 `1` 而 $S$ 的其它部分都是 `0`，要满足这一段里有 $S$ 所有的 `1` 且没有 `0`。而题目要求只能有一段这样的子串，所以我们可以统计这样子串的数量，如果是 $1$ 就输出 `Yes`，反之 `No`。

关于统计一个子串里 `0` 或 `1` 的数量：可以使用前缀和 $O(1)$ 求解。总复杂度 $O(N)$。

## 代码

```cpp
#include<bits/stdc++.h>
int sum[300005],sum0[300005];
//sum是1的前缀和，sum0是0的前缀和。
char s[300005];
int get1(int l,int r){return sum[r]-sum[l-1];}
//计算[l,r]有多少1。
int get0(int l,int r){return sum0[r]-sum0[l-1];}
//计算[l,r]有多少0。
signed main(){
    int t;
    scanf("%d",&t);
    while(t--){
        int n,k,f=0;
        scanf("%d%d\n%s",&n,&k,s+1);
        for(int i=1;i<=n;i++) sum[i]=sum[i-1]+(s[i]=='1'),sum0[i]=sum0[i-1]+(s[i]=='0');
        //预处理前缀和。
        for(int i=1;i<=n-k+1;i++){
            if(get1(i,i+k-1)==sum[n]&&!get0(i,i+k-1)) f++;//按上文中的条件检查。
            if(f>1) break;//已经不符合。
        }
        printf(f==1?"Yes\n":"No\n");
    }
    return 0;
}
```

---

## 作者：CarroT1212 (赞：3)

### 题目大意

$T$ 组数据。每组数据给定 $N,K$ 和一个长度为 $N$ 的仅含 `0` `1` `?` 的字符串 $S$，你可以将 $S$ 中的 `?` 替换成 `0` 或 `1`，问是否有且仅有一种替换方法，使得 $S$ 中有且仅有一段连续的 `1`，且长度为 $K$。

数据范围：$1 \le T \le 10^5$，$1 \le K \le N \le 3\times 10^5$，所有数据中 $N$ 之和不超过 $3\times10^5$。

------------

### 解法分析

一个很臭的做法，参考一下就好。

交了三次才过，降智了属于是。

列一下答案为 `YES` 时替换前的 $S$ 需要满足的条件。

+ $S$ 中不存在 `1`

注意这种情况不能直接输出 `NO`，因为你可以通过替换掉 `?` 来创造出一段连续 `1`，是可能有解的。（第一次提交错因）

所以按照题目要求我们可以直接扫一遍 $S$ 中连续的 `?`，如果最长连续 `?`  序列有且仅有一个（第二次提交错因，题目要求只有一种替换方法）且长度恰好为 $K$，则替换掉这个序列就可以了。

+ $S$ 中存在 `1`

先找到 $S$ 中位于最左端和最右端的 `1` 位置，记作 $l,r$。如果要使替换后的 $S$ 中仅存在一段连续 `1`，显然这段序列必须要覆盖 $l,r$ 两个位置。所以我们确认一下这两个位置之间是否存在 `0`，有则无法替换，没有就继续。

然后我们从 $l,r$ 往外延伸，找到最长的包含 $l,r$ 两个位置的仅含 `1` `?` 的序列（就是找 $l,r$ 两端最长连续 `?`），左右端点记作 $f,b$。明显最后题目所求的连续 `1` 序列必须要覆盖 $l,r$ 两个位置，如果 $r-l+1>k$，就算仅覆盖从 $l$ 到 $r$ 的区间长度也会大于 $k$；同时，如果 $b-f+1>k$，就算把从 $f$ 到 $b$ 的区间全部覆盖长度也达不到 $k$。要是这些筛选都逃过了，就一定存在这样一段区间。接下来验证是否仅存在一段这样的区间。如果在区间左右端点不超过 $f,b$，必须覆盖 $l,r$ 的限制下，只有一段长度为 $k$ 的区间满足条件，那就可以输出 `YES` 了。

这么多筛选条件漏一个都过不了，一定要小心。

~~但换成楼上的做法解决一切。~~

------------

### 代码

```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define ll long long
#define pb push_back
#define pll pair<ll,ll>
using namespace std;
const int N=3e5+7;
int n,k,f,b,l,r;
char str[N];
void solve() {
	scanf("%d%d%s",&n,&k,str+1),f=b=0;
	for (int i=1;i<=n;i++) if (str[i]=='1') { f=i; break; }
	for (int i=n;i;i--) if (str[i]=='1') { b=i; break; }
	if (!f) { // S 里没有 1
		int len=0,cnt=0;
		for (int i=1,lst=0;i<=n;i++) {
			if (str[i]=='0') lst=i;
			else {
				if (i-lst>len) len=i-lst,cnt=1;
				else if (i-lst==len) cnt++;
			}
		}
		if (len==k&&cnt==1) printf("Yes\n");
		else printf("No\n");
	}
	else { // 有 1
		for (int i=f;i<=b;i++) if (str[i]=='0') { printf("No\n"); return; } // l,r 中存在 0
		l=f,r=b;
		while (str[f-1]=='?') f--;
		while (str[b+1]=='?') b++;
		if (b-f+1<k||r-l+1>k) printf("No\n"); // 长度不符合
		else if (min(l+k-1,b)-max(f+k-1,r)!=0) printf("No\n"); // 多解
		else printf("Yes\n");
	}
}
int main() {
	int t; scanf("%d",&t); for (;t--;) solve();
	return 0;
}
```

---


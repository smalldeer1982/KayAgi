# 暴露

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-thanks-festival-2015-open/tasks/code_thanks_festival_2015_d

$ 1 $ から $ N $ までの番号が付けられた $ N $ 人の生徒からなるある学園で期末試験が行われた。試験は $ 100 $ 点満点で、どの生徒も非負の整数の得点を獲得した。

この学園ではどの生徒も自分の得点と全受験者の合計点を通知されるが、それ以外の情報は通知されない。

しかしながらどの生徒も他の生徒の得点が気になる。そのため生徒は他の生徒から得点を聞き出し、それらの値を基に他の生徒の得点を予想することにしている。

学園の教師であり、生徒が他の生徒の得点をどれくらい正確に把握しているのかが気になったあなたは、生徒の行動によってどのくらい得点が特定できているのかを調査することにした。

具体的には、以下に示す $ M $ 個の情報クエリあるいは質問クエリを番号の昇順に処理した際の質問クエリの答えを計算することにした。

- クエリには $ 1 $ から $ M $ までの番号が付けられている。どのクエリも $ 3 $ つの整数 $ a_i\ (0\ ≦\ a_i\ ≦\ 1) $, $ b_i\ (1\ ≦\ b_i\ ≦\ N) $, $ c_i\ (1\ ≦\ c_i\ ≦\ N,\ b_i≠c_i) $ によって定められる。
- $ a_i $ = $ 0 $ のとき、クエリ $ i $ は情報クエリである。これは、生徒 $ b_i $ が生徒 $ c_i $ の得点を知ったことを表す。
- $ a_i $ = $ 1 $ のとき、クエリ $ i $ は質問クエリである。これは、生徒 $ b_i $ がクエリ $ i $ までの情報クエリと元々知っている情報のみで、生徒 $ c_i $ の得点が何点以上何点以下であると判定できるのかを答えなければならないことを表す。

## 说明/提示

### Sample Explanation 1

生徒は $ 4 $ 人であり、クエリは $ 6 $ 個ある。 - クエリ $ 1 $ は情報クエリである。生徒 $ 2 $ は生徒 $ 3 $ の得点が $ 70 $ 点であることを知る。 - クエリ $ 2 $ は情報クエリである。生徒 $ 4 $ は生徒 $ 2 $ の得点が $ 90 $ 点であることを知る。 - クエリ $ 3 $ は質問クエリである。この時点で生徒 $ 2 $ は合計点が $ 80+90+70+100=340 $ 点であること、生徒 $ 2 $ の得点が $ 90 $ 点であること、生徒 $ 3 $ の得点が $ 70 $ 点であることを知っているので、生徒 $ 4 $ の得点は $ 80 $ 点以上 $ 100 $ 点以下であることがわかる。よって出力の $ 1 $ 行目は `80 100` となる。 - クエリ $ 4 $ は情報クエリである。生徒 $ 2 $ は生徒 $ 4 $ の得点が $ 100 $ 点であることを知る。 - クエリ $ 5 $ は質問クエリである。この時点で生徒 $ 2 $ は合計点および生徒 $ 1 $ 以外すべての生徒の得点を知っているので、生徒 $ 1 $ の得点はちょうど $ 80 $ 点であることがわかる。よって出力の $ 2 $ 行目は `80 80` となる。 - クエリ $ 6 $ は質問クエリである。この時点で生徒 $ 4 $ は合計点が $ 340 $ 点であること、生徒 $ 2 $ の得点が $ 90 $ 点であること、生徒 $ 4 $ の得点が $ 100 $ 点であることを知っているので、生徒 $ 1 $ の得点は $ 50 $ 点以上 $ 100 $ 点以下であることがわかる。よって出力の $ 3 $ 行目は `50 100` となる。

### Sample Explanation 2

既に得点を知っている相手に対して質問クエリが飛んで来る場合もあります。

## 样例 #1

### 输入

```
4
80
90
70
100
6
0 2 3
0 4 2
1 2 4
0 2 4
1 2 1
1 4 1```

### 输出

```
80 100
80 80
50 100```

## 样例 #2

### 输入

```
3
25
12
31
3
1 1 2
0 1 2
1 1 2```

### 输出

```
0 43
12 12```

## 样例 #3

### 输入

```
7
32
19
22
25
23
17
18
11
0 1 2
0 4 5
0 1 4
0 2 3
0 2 7
1 1 5
1 2 7
1 2 1
0 4 3
1 4 2
1 6 7```

### 输出

```
0 80
18 18
0 97
0 86
0 100```

# 题解

## 作者：Strelitzia_ (赞：3)

## 题目大意

模拟题。

这道题的题面给的很绕。总结来说就是：每个学生在一开始知道所有学生的总分和自己的得分，然后在 $m$ 次操作中还会让某一位学生知道另一位学生的成绩。在询问时会让一个学生根据信息估算另一名学生的成绩可能的上下界。

## 思路

首先，我们记录所有学生的总成绩 ```sum```，用 ```a[i]``` 记录每个学生的成绩，用 ```peo[i]``` 记录每个学生不知道多少人的成绩，用 ```s[i]``` 记录每个学生知道的成绩的总和。此外，我们还要用类似邻接矩阵 ```f[i][j]``` 的方式存第 $i$ 个学生知道了第 $j$ 个学生的成绩。

对于 $a=0$ 的情况，学生 $b$ 知道了学生 $c$ 的成绩，相当于学生 $b$ 到学生 $c$ 连有向边；同时学生 $b$ 知道的人数多了一个，知道的总成绩多了 ```a[i]```。

对于 $a=1$ 的情况，如果 $b$ 已经知道了 $c$，那么直接输出 $c$ 的成绩即可；如果 $b$ 不知道 $c$，那么可以先假设不知道的所有人（除去 $c$）都考了 $100pts$，这样就得到了 $c$ 的最小成绩；再假设除去 $c$ 的所有人都爆零了，就得到了 $c$ 的最大成绩。

两个小坑点：查询时不知道的成绩的人不包括 $c$；每个人的分数最低 $0$，最高 $100$。

代码：

```cpp
signed main(){
	int n=read();
	for(int i=1;i<=n;i++){
		peo[i]=n-2;
		a[i]=read();
		sum+=a[i];
		s[i]+=a[i];
	}
	int m=read();
	while(m--){
		int type=read(),x=read(),y=read();
		if(type==0){
			stu[x][y]=1;
			peo[x]--;
			s[x]+=a[y];
		}
		else{
			if(stu[x][y]) printf("%lld %lld\n",a[y],a[y]);
			else printf("%lld %lld\n",max(sum-s[x]-peo[x]*100,0),min(sum-s[x],100));
		}
	}
	return 0;
}
```

---

## 作者：nbtngnllmd (赞：2)

~~一道挺麻烦的模拟题。~~

------------

## 题意：

已知给出编号从 $1$ 到 $n$ 的 $n$ 名学生的考试成绩，所有学生成绩均为非负整数。每个学生最开始均知道自己成绩，他们想要知道其他人的成绩。
输入三个正整数 $a$，$b$ 和 $c$。
有 $2$ 种操作：

$1$：当 $a=0$ 时，表明编号 $b$ 的学生知道了编号为 $c$ 的学生成绩，合并成绩。

$2$：当 $a=1$ 时，在已知条件和 $b$ 同学所掌握的信息中判断 $c$ 同学的成绩，输出下限和上限。


------------

## 分析：

首先我们先通读题意，找出关键点。

$1$：所有同学的成绩都为非负整数，这证明所有同学的成绩都不小于 $0$。这证明输出下限时绝对不能输出一个负数！！！

$2$：找上限和下限时只能根据当前 $b$ 同学所掌握的信息，用成绩总分减去已知成绩再减去未知成绩的最大值和最小值，绝对不能用其他同学的信息！！

$3$：查找时，要注意可能会给出已知同学的成绩的编号，这是不能再估算了，直接输出该同学成绩！！！

明白坑点后就思路不难想了。

------------

## 思路：

首先我们用 $sum$ 代表总分，用 $l$ 代表每个同学已知的成绩，$flag$ 代表未知的同学个数,$ans$ 代表界限。我们可以得到一个式子。
 
上限最大等于 $100$，反之如果成绩达不到满分 $ans = sum - l[b]$。

下限等于 $ans = sum - l[b] - (flag[b] - 1) \times 100$，如果小于 $0$ 输出 $0$。

注意这里的 $flag$ 的个数要减去要查询同学的本身。

但要加个特判，我们定义一个 $vis$ 数组，$vis[i][j]$ 代表第 $i$ 个同学知道了 $j$ 个同学的成绩。再查询中如果 $vis[i][j] = true$ 直接输出该同学成绩。

合并操作中，我们直接将 $vis[b][c]$ 标为已知，然后把 $b$ 同学已知的成绩加上 $c$ 同学的成绩，未知成绩个数 $flag[b]-1$。

具体实现，请移步参考代码。



------------

## $ACcode$

```cpp
#include<bits/stdc++.h>

using namespace std;
int n,w[100010],m,a,b,c,l[5001],sum;
bool vis[5001][5001];
int flag[5001];
int main(){
	cin >> n ;
	for(int i = 1 ; i <= n ; i++ ) flag[i] = n - 1;
	for(int i = 1 ; i <= n ; i++ ) cin >> w[i],sum += w[i],l[i] = w[i];
	cin >> m ;
	for(int i = 1 ; i <= m ; ++i ) {
	    cin >> a >> b >> c;
	    if(a){
	    	if(vis[b][c]) {
	    		cout << w[c] <<' ' <<w[c] << endl;
	    		continue;
		}
	    	if(flag[b] > 1) {
	    	    if(sum - l[b] < 100 ) cout << 0 << ' ' <<sum - l[b] << endl;
		    else {
			 if(sum - l[b] - (flag[b]-1) * 100 >= 0 ) cout << sum - l[b] - (flag[b]-1) * 100 <<' ' << 100 << endl;
			 else cout << 0 <<' ' << 100 << endl;
		    }
		}
		    else cout << sum - l[b] <<' ' <<sum - l[b] << endl;
		}
		else {
			vis[b][c] = true;
			l[b] += w[c];
			flag[b]--;
		}
	}
	return 0;
}
```





 

---


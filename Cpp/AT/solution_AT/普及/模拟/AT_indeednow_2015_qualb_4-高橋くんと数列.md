# 高橋くんと数列

## 题目描述

[problemUrl]: https://atcoder.jp/contests/indeednow-qualb/tasks/indeednow_2015_qualb_4

高橋くんは長さ $ N $ の $ 1 $ から $ C $ の整数からなる数列 $ \{a_N\}\ =\ \{a_1,a_2,\ ...,a_N\} $ を受け取って、 $ 1 $ 以上 $ C $ 以下のそれぞれの整数について、その数を1つでも含む連続する部分列の数を返す機械です。

より正確には、 $ 1 $ 以上 $ C $ 以下の整数 $ k $ について、 $ 1\ ≦\ l\ ≦\ r\ ≦\ N $ となるような $ l,r $ で、 $ a_i\ =\ k $ かつ $ l≦\ i\ ≦\ r $ を満たすものが存在するような $ (l,r) $ の組の数を高橋くんは求めます。

連続する部分列の中身が同じでも、$ (l,r) $ の組が異なれば異なるものとして認識することに注意してください。 高橋くんの動作を確認するためのプログラムを書いてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 30 $ 点分のテストケースにおいて、$ 1≦C≦20 $ を満たす。

### Sample Explanation 1

$ 1 $ を含む連続する部分列として当てはまるものは、 $ (l,r)=(1,1),(1,2),(1,3),(1,4),(2,4),(3,4),(4,4) $ $ 2 $ を含む連続する部分列として当てはまるものは、 $ (l,r)=(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4) $ です。

## 样例 #1

### 输入

```
4 2
1 2 2 1```

### 输出

```
7
8```

## 样例 #2

### 输入

```
4 4
1 4 2 3```

### 输出

```
4
6
4
6```

## 样例 #3

### 输入

```
5 1
1 1 1 1 1```

### 输出

```
15```

# 题解

## 作者：xianxi (赞：2)

# 题意

给你一个长度为 $N$ 序列 $A$，保证每一个数 $A_i \le C$，要求对于从 $1$ 到 $C$ 中的每一个数都在序列中寻找闭区间，使得区间中至少有一个数等于它，输出从 $1$ 到 $C$ 中的每一个数的满足条件的所有闭区间。

# 解题思路

看到这道题，不知道各位有没有跟我一样想到**排列组合**，因为暴搜肯定超时。

首先，当你想到排列组合时，你已经成功了三分之一。

其次，可以想到，将所有相同的数的下标放到一个数组 $v$ 里，然后假设当前要搜索的数字为 $X$，那么对于在数组 $v$ 中每一个与 $X$ 相等的数 $Y$，让左端点 $l$ 小于等于当前 $Y$ 的下标 $i$，右端点 $r$ 大于等于当前 $Y$ 的下标 $i$，即保证当前的 $A_i = X$ 且位于区间中，一共有 $i \times (n-i)$ 个区间满足我们的条件。

哦，你问我为什么是大于等于与小于等于，因为我们选的是闭区间，也就是可以选 $[i,i]$，自然是大于等于与小于等于了。

如果看不懂文字描述，可以结合看看下面这幅图。

![](https://cdn.luogu.com.cn/upload/image_hosting/4e7uywpa.png)

紧接着，你会发现，你找出的区间数大于实际区间数。这是因为有重复的区间被选择，如下图，以图片左端绿色区间为所选区间左端点，右端绿色区间为所选区间右端点的区间被重复选择。

![](https://cdn.luogu.com.cn/upload/image_hosting/icr3fhdl.png)

那么如何去重就是我们要解决的下一个问题。

于是，我想到我们不能对于所有左端点 $l \le i$ 都纳入答案，但是对于所有右端点 $i \le r$ 是可以被都选择的。所以我们的左端点只需在当前数组位置到前一个与 $X$ 值相等的数的数组位置的区间中寻找。

注意，**左端点不与前一个与 $X$ 值相等的数的数组位置相等**，即设前一个与 $X$ 值相等的数的数组位置为 $i$，则 $i < l$。

看不懂文字可以结合下图理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/quazb3bo.png)

这样选择就可以避免重复选择区间。

注：以上所有图片中的不同颜色的箭头以及黑色竖线代表值相同但下标不同的数组中的数。

# 代码实现

如果前面思路结合图片还看不懂，可以理解一下代码。

本题代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,a[100005],c;
vector<unsigned long long>v[100005];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>c;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		v[a[i]].push_back(i);
	}
	for(int i=1;i<=c;++i)
	{
		unsigned long long ans=0;
		for(int j=0;j<v[i].size();++j)
		{
			unsigned long long u=v[i][j];
			if(j!=0)ans+=(unsigned long long )((n-u+1)*(u-v[i][j-1]));
			else ans+=(unsigned long long )((n-u+1)*u);
		} 
		cout<<ans<<"\n";
	}
	return 0;
}
```

# 警钟长鸣

本题需开 `long long`, 当然，本人习惯开了 `unsigned long long`。

注意特判数组中第一个与 $X$ 值相同的数。

注意数组大小。

最后感谢您的留步与观看，希望本篇题解能够帮到您。

---

## 作者：cff_0102 (赞：1)

题意简述：给出一个 $n$ 个数的数列 $a$，对于每个 $1\le k\le c$，求出满足 $a_i=k$ 且 $l\le i\le r$ 的 $(l,r)$ 数量，即求出有多少对 $(l,r)$ 满足在 $[l,r]$ 之间至少存在一个数 $i$，使得 $a_i=k$。

首先算出 $a$ 中所有连续子序列的数量，不管这个连续子序列是否包含 $k$。不难算出这个数就是 $1+2+3+\dots+n=\frac{n\times(n+1)}{2}$。

接着求出所有一个 $k$ 都不包含的连续子序列的数量。记录下每个 $k$ 的位置，那么在前一个 $k$ 和后一个 $k$ 之间一定没有其它 $k$。假设第 $i$ 个 $k$ 和第 $i+1$ 个 $k$ 之间有 $l_i$ 个其它数，则第 $i$ 个 $k$ 和第 $i+1$ 个 $k$ 之间的这个范围有 $\frac{l_i\times(l_i+1)}{2}$ 个连续子序列，且它们都不含 $k$。

计算出 $\frac{n\times(n+1)}{2}-\sum\limits_{i=0}^{n}\frac{l_i\times(l_i+1)}{2}$，就是所有含 $k$ 的子序列的数量了。

---

考虑用 `vector` 实现，第 $k$ 项就存下所有 $k$ 出现的地方。为了方便，再存上 $0$ 和 $n+1$。

每次读入一个数，就在 `vector` 里存下这个数的位置，最后直接算出答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>b[114514];
int main(){
    int n,c;cin>>n>>c;
    for(int i=1;i<=c;i++)b[i].push_back(0);// 先存个 -1，方便计算 l_0
    for(int i=1;i<=n;i++){
        int a;
        cin>>a;
        b[a].push_back(i);// 存 a 的位置 
    }
    for(int i=1;i<=c;i++)b[i].push_back(n+1);// 最后存个 n，方便计算 l_n
    for(int i=1;i<=c;i++){// 每个 k
        long long s=(long long)n*(n+1)/2;// int 会爆
        for (int j=0;j<b[i].size()-1;j++){// 每个 k 出现的位置
            long long l=b[i][j+1]-b[i][j]-1;// 不能包括这俩 k 了，所以减 1
            s-=l*(l+1)/2; 
        }
        cout<<s<<endl;
    }
}
```

---

## 作者：Elairin176 (赞：1)

[传送门](https://www.luogu.com.cn/problem/AT_indeednow_2015_qualb_4)   
又是一道简单题。   
## 题意
给你一个数列，它的长度为 $n$，数字的取值范围在 $[1,c]$ 之间。    
设 $s_i$ 为这个数列中含 $i$ 的连续子序列数量，现在让你求出所有的 $s_i$。   
## 解法
发现我们直接维护有一些难度，所以我们可以利用其他的信息来辅助维护。   
我们先求出所有连续子序列的数量，之后把不含 $i$ 的连续子序列数量减掉就可以了。    
那么如何求出不含 $i$ 的连续子序列数量呢？   
我们发现，不含 $i$ 的连续子序列只会在两个 $i$ 之间（这之间不能有 $i$），所以我们可以枚举 $i$，再扫一遍数列进行维护。    
这样的复杂度是 $O(nc)$，无法通过本题。  
考虑优化：显然我们每次只要找上一个 $i$，所以我们开数组维护上一个 $i$ 的位置即可。那么这样我们的时间复杂度就降到了 $O(n)$，可以通过。   
注意我们其实还需要求出第一个 $i$ 之前和最后一个 $i$ 之后的连续子序列数量，这些细节问题请读者自行思考（和前面类似）。   
[CODE](https://www.luogu.com.cn/paste/la9jtvnr)

---


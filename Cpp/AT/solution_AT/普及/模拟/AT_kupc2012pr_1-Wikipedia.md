# Wikipedia

## 题目描述

PA君某天在维基百科上看到了阿克曼函数。根据维基百科上的解释，阿克曼函数按以下函数进行递归。
- $A(0,n)=n+1(n≥0)$
- $A(m,0)=A(m-1,1)(m≥1)$
- $A(m,n)=A(m-1,A(m,n-1))(m,n≥1)$

阿克曼函数以它随给定参数爆炸式增长而著名。PA君试着手算了一下阿克曼函数的值，但这实在是太毒瘤了因此他很快便放弃了。你的任务就是帮PA君计算阿克曼函数的值。

## 说明/提示

- $0≤m≤3$
- $0≤n≤60$
- 输入都为整数。

注：亲测答案在long long范围内。

感谢@ミク 提供的翻译

# 题解

## 作者：翰森锐 (赞：4)

## 这道题有点高估我

首先，我们可以看出这是一道递归题。

模拟一下，就有了下面的一段代码

```
unsigned long long akm(int m,int n)
{
	if(m==0)
		return n+1;
	else if(m>0&&n==0)
		return akm(m-1,1);
	else
		return akm(m-1,akm(m,n-1));
}
```
不过，这样大一点了 就卡不出来导致TLE。。。

于是，过程已经有dalao解释了

```
long long akm(int m，int n)
{
	if(n==0) return akm(m-1,1);
    if(m==0) return n+1；
    if(m==1) return n+2;
    if(m==2) return n*2+3；
    if(m==3) return akm(m,n-1)*2+3;		
}
```

完整CODE：

```
#include<bits/stdc++.h>
using namespace std；
long long akm(int m，int n)
{
	if(n==0) return akm(m-1，1)；
    if(m==0) return n+1;//规律
    if(m==1) return n+2;
    if(m==2) return n*2+3;
    if(m==3) return akm(m，n-1)*2+3；	
    /*因为在m=2时会卡下去，所以我们要根据题目得出n*2+3*/
}
int main()
{
	int n，m；
	cin>>m>>n；
	cout<<akm(m,n）<<endl；;//大坑！换行！
    return 0；
}

```

CE了就别怪我

你自己知道

---

## 作者：CrTsIr400 (赞：3)

# 0.前言

本题解主要介绍由暴力递归到递归剪枝再到打表。

## 1.暴力递归

直接按照原题的公式

* $A(0,n)=n+1(n≥0)$

* $A(m,0)=A(m-1,1)(m≥1)$

* $A(m,n)=A(m-1,A(m,n-1))(n,m≥1)$

直接实现代码：

```cpp
LL a(int m,int n)
{
	if(m==0)return n+1;
   	if(n==0)return a(m-1,1);
	return a(m-1,a(m,n-1));
}
```

然而时间复杂度很高，不能接受。

### 2.递归剪枝优化

我能在哪里实现优化呢？

对于第二个操作来说，可以把它展开来，然后找一找规律。

要**分类讨论**一下：


对于 $A(0,n)$ ，就等同于 $ n+1$ 。

对于 $A(1,n)$ ，


$=A(0,A(1,n-1))$

$=A(1,n-1)+1$

边界条件：

$\because A(1,0)=A(0,1)$

$\therefore A(1,0)=2$

可得出：

$\therefore A(1,n)=n+2$

证明完毕。

对于 $A(2,n)$ ，

$=A(1,A(2,n-1))$

$\because A(1,n)=n+2$

$\therefore A(1,A(2,n-1))=A(2,n-1)+2$

边界条件：

$\because A(2,0)=A(1,1),$

$\because A(1,n)=n+2$

$\therefore A(2,0)=3$

可得出：

$\therefore A(2,n)=2n+3$

证明完毕。

对于 $A(3,n)$，

$=A(2,A(3,n-1))$

$\because A(2,n)=2n+3$

$\therefore A(2,A(3,n-1))=2A(3,n-1)+3$

边界条件：

$\because A(3,0)=A(2,1)$

$\because A(2,1)=5$

$\therefore A(3,0)=5$

可得出：

$A(3,n)=2^{n+3}-3$

证明完毕。

这个时间复杂度比上面的小很多，可以AC。



---

## 作者：绝艺 (赞：3)

### 初见题面感觉~~简单到炸~~

### 不就是模拟吗？？

然后二话不说照题意两分钟敲出代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f(int m,int n){
    if(n==0) return f(m-1,1);
    if(m==0) return n+1;
    return f(m-1,f(m,n-1));
}
int main(){
    int m,n;
    cin>>m>>n;
    cout<<f(m,n)<<endl;
    return 0;
}
```
结果TLE了12个点······

又看了一眼题面，发现了这样一行字

### 阿克曼函数以它随给定参数爆炸式增长而著名

······突然觉得有点坑

不忍放弃的我随后像PA君那样苦心手算了好一会（~~结果还是没算出来~~）

突然发现m的取值范围很小，只在0到3之间

灵机一动~~然后又是漫长的手算~~

终于找出了m之中隐藏的规律（~~不容易啊啊啊~~）

于是有了以下代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f(int m,int n){
    if(n==0) return f(m-1,1);
    if(m==0) return n+1;
    if(m==1) return n+2;
    if(m==2) return n*2+3;
    if(m==3) return f(m,n-1)*2+3;
}
int main(){
    int m,n;
    cin>>m>>n;
    cout<<f(m,n)<<endl;
    return 0;
}
```
消掉了一层递归总不会TLE了吧······

兴高采烈地看评测记录

发现······发现之前TLE的12个点全变成了WA

差点WA地一声哭了出来······

怎么就错了？？！（~~这道题又不给下载测试数据~~）

又是艰辛的调试

发现······发现自己没开long long（又是一把泪）

开了long long 以后再提交一遍

居然居然就过了！（好想扇自己一巴掌）

# 终于可以放AC代码了

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f(int m,int n){
    if(n==0) return f(m-1,1);
    if(m==0) return n+1;
    if(m==1) return n+2;
    if(m==2) return n*2+3;
    if(m==3) return f(m,n-1)*2+3;
}
int main(){
    int m,n;
    cin>>m>>n;
    cout<<f(m,n)<<endl;
    return 0;
}
```
居然只用60ms（~~我之前干什么去了~~）

~~不过看着60个测试点都AC了还是挺爽的~~

蒟蒻AC不易，码字更不易，望管理员大佬通过QwQ

---

## 作者：打表大蒟蒻 (赞：1)

一拿到题面，扫了一眼后，哎呀，不就是本蒟蒻最喜欢的打表题吗！！于是，我信心满满的根据题意开始~~瞎~~模拟了，代码在这里
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a(int m,int n){
	if(m==0) return n+1;
	else if(n==0) return a(m-1,1);
	else return a(m-1,a(m,n-1));
}
int main ()
{
    for(int i=0;i<=3;i++)
    	for(int j=0;j<=60;j++)
		cout<<a(i,j)<<",";
	return 0;
}
```

这份代码可以不用解释了吧，纯粹按题意模拟，结果，我运行出来的结果让我大跌眼镜：屏幕上赫然显示出一条错误信息，打表021.exe已停止工作。

~~我也是佩服我自己，竟然能把这个程序弄成这样~~

于是，我继续开始思考了，后来发现了如下规律，证明过程有一位dalao已经讲过了，我便不赘述了，于是，真正的打表代码出炉了！！！
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a(int m,int n){
	if(n==0) return a(m-1,1);
    if(m==0) return n+1;
    if(m==1) return n+2;
    if(m==2) return n*2+3;
    if(m==3) return a(m,n-1)*2+3;
}
int main ()
{
    for(int i=0;i<=3;i++)
    {
    	cout<<"{";
		for(int j=0;j<=60;j++)
			cout<<a(i,j)<<",";
		cout<<"},";
	}	
    return 0;
}
```
运行结果如下
```
{4294967295,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,},{2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,},{3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,},{5,13,29,61,125,253,509,1021,2045,4093,8189,16381,32765,65533,131069,262141,524285,1048573,2097149,4194301,8388605,16777213,33554429,67108861,134217725,268435453,536870909,1073741821,2147483645,4294967293,8589934589,17179869181,34359738365,68719476733,137438953469,274877906941,549755813885,1099511627773,2199023255549,4398046511101,8796093022205,17592186044413,35184372088829,70368744177661,140737488355325,281474976710653,562949953421309,1125899906842621,2251799813685245,4503599627370493,9007199254740989,18014398509481981,36028797018963965,72057594037927933,144115188075855869,288230376151711741,576460752303423485,1152921504606846973,2305843009213693949,4611686018427387901,9223372036854775805,},
```
代码经历千辛万苦，总算被我搞出来了
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[4][61]={{4294967295,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61},{2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62},{3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123},{5,13,29,61,125,253,509,1021,2045,4093,8189,16381,32765,65533,131069,262141,524285,1048573,2097149,4194301,8388605,16777213,33554429,67108861,134217725,268435453,536870909,1073741821,2147483645,4294967293,8589934589,17179869181,34359738365,68719476733,137438953469,274877906941,549755813885,1099511627773,2199023255549,4398046511101,8796093022205,17592186044413,35184372088829,70368744177661,140737488355325,281474976710653,562949953421309,1125899906842621,2251799813685245,4503599627370493,9007199254740989,18014398509481981,36028797018963965,72057594037927933,144115188075855869,288230376151711741,576460752303423485,1152921504606846973,2305843009213693949,4611686018427387901,9223372036854775805}};
int main ()
{
    int n, m;
    cin>>m>>n;
    cout<<a[m][n]<<"\n";
    return 0;
}
```
总之，这道题是一道练习打表的好题目，大家可以做一做

---


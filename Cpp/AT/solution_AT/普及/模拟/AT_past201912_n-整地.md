# 整地

## 题目描述

坐标轴上有 $n$ 个区间，每个区间均在左端点为 $0$，右端点为 $w$ 的线段内。第 $i$ 个区间的左右端点表示的数字分别为 $l_i$ 和 $r_i$。

现在你要去掉一部分区间，使得有一段长度为 $c$ 的线段没有被任何区间覆盖。第 $i$ 个区间删去的代价为 $p_i$。请输出你所花费的最小代价。

## 样例 #1

### 输入

```
3 10 5
1 3 100
8 10 123
4 6 3```

### 输出

```
3```

## 样例 #2

### 输入

```
22 30 10
0 30 1000000000
0 30 1000000000
0 30 1000000000
7 30 261806
6 19 1
5 18 1238738
12 28 84
10 14 5093
9 20 9
15 26 8739840
6 8 240568
14 19 198
2 4 1102
1 29 5953283
9 20 183233
9 13 44580
6 23 787237159
12 14 49
28 29 9020727
14 20 318783
2 19 9862194
9 30 166652```

### 输出

```
3805189325```

# 题解

## 作者：eoinlee (赞：2)

一个比较显然的结论是，最终空出来的区间（下文称之为 $\text{seg}$）完全可以以现有区间的端点作为端点。如果不以现有区间为端点，那么完全可以将其平移到某一个现有端点的位置而不影响答案。

因此，既然长度已经给定，我们可以 $\mathcal{O}\left(N\right)$ 枚举所有可能作为 $\text{seg}$ 的长度为 $c$ 的区间，接下来需要做的就是 $\mathcal{O}\left(1\right)$ 计算所有可能 $\text{seg}$ 的答案，并统计最小值。对于每一个长度为 $c$ 的区间，判断要删掉哪些线段才能使之合法，感觉不太好实现。正难则反，可以考虑每种情况下最多可以保留哪些区间，那么需要删除的区间就是除开这些保留的区间之外的其他区间。

我们对于离散化后的每一个端点 $i$ 维护前缀和后缀中的完整区间的费用之和 $\text{pre}[i]$ 和 $\text{suf}[i]$，以及所有区间的费用和 $\text{sum}$，则统计答案时，假设当前考虑的可能区间为 $\left[L, R\right]$，则答案为 $\text{sum} - \text{pre}[L] - \text{suf}[R]$。

[Submission](https://atcoder.jp/contests/past201912-open/submissions/59800663)，总复杂度 $\mathcal{O} \left(N \log N\right)$，$\log$ 是离散化的复杂度。

---

## 作者：Chenyanxi0829 (赞：1)

下文线段指要求的最小值对应的线段，区间指给定的 $n$ 个区间。

发现肯定有一个最优线段的至少一个端点是贴着某个区间或 $0$ 或 $w$ 的，所以只有 $O(2n)$ 个线段可能成为答案线段，把这些线段按左端点排序，再把给定区间按左端点排序，从前往后依次计算这些线段的答案，当一个区间左端点被包含在当前枚举的答案线段时，就把 $p_i$ 加入到代价，并把其右端点加入到优先队列中，这样当一个区间的 $r_i\le$ 当前枚举的答案线段的左端点时，就可以把 $p_i$ 从代价中删去了。

### 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
using Pii = pair<int, int>;

const int kMaxN = 1e5 + 100;

int n, w, c;
long long ans = 2e18, sum;
Pii b[kMaxN << 1];
priority_queue<Pii, vector<Pii>, greater<Pii>> q;
array<int, 3> a[kMaxN];

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> w >> c;
    for (int i = 1; i <= n; i++) {
        cin >> a[i][0] >> a[i][1] >> a[i][2],
            b[2 * i - 1] = { max(0, a[i][0] - c), max(0, a[i][0] - c) + c },
                      b[2 * i] = { min(w, a[i][1] + c) - c, min(w, a[i][1] + c) };
    }
    sort(a + 1, a + n + 1), sort(b + 1, b + 2 * n + 1);
    for (int i = 1, j = 0; i <= 2 * n; i++) {
        if (b[i] != b[i - 1]) {
            for (; j < n && a[j + 1][0] < b[i].second; j++, q.push({ a[j][1], a[j][2] }), sum += a[j][2]) {
            }
            for (; q.size() && q.top().first <= b[i].first; sum -= q.top().second, q.pop()) {
            }
            ans = min(ans, sum);
        }
    }
    cout << ans;
    return 0;
}
```

---


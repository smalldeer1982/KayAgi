# [ABC029D] 1

## 题目描述

高桥先生用十进制标记一次性地在纸上写了  $1$ ~ $N$  以下的所有整数。 在这项工作中，高桥君写了几个  $1$  这样的数字呢？即求从 
 $1$ ~ $N$  中数字  $1$  出现的次数。（本题类似 P1980）

## 样例 #1

### 输入

```
12```

### 输出

```
5```

## 样例 #2

### 输入

```
345```

### 输出

```
175```

## 样例 #3

### 输入

```
999999999```

### 输出

```
900000000```

# 题解

## 作者：lzqy_ (赞：43)

## O(1)算法，不用DP、不用循环，甚至变量都只需要两个！


### **先上思路：**

####  _我们一位一位的看。_ 

首先，个位的$1$有几个？ 那就是$n/10+1$,这个很容易；

接着，十位的$1$有几个？这时，可能有朋友就会说了（包括我），那不就是$n/100+1$嘛。且慢，除了$10$、$100$、$1000$这些以外，还有$11$、$12$、$13......$所以，正确的式子应该是$(n/10+1)*10$。

那百位呢？就是$(n/1000+1)*100$。

以此类推$......$


------------


### 注意：

- 这个代码很容易被卡掉，比如数据$12$，这个程序算出来的就是$12$；为什么会这样呢？

  因为$1$~$12$中，$13,14,15,16,17,18,19$中十位的1都不能算入总数，所以，我们还要特判一下这种情况。
  

------------


万事俱备，上代码：
```
#include <bits/stdc++.h>
using namespace std;
long long min(long long a,long long b)
//手写min（可以省略）
{
  if(a>b) return b;
  else return a;
}
int main()
{
  int n,ans=0;
  cin>>n;
  //开始计算~
  if(n>=1)
  {
    ans+=(n/10+1)*1;
    if(n%10<2-1)//上文所说的特判
      ans-=min(1,2-n%10-1);
  }
  if(n>=10)
  {
    ans+=(n/100+1)*10;
    if(n%100<20-1)
      ans-=min(10,20-n%100-1);
      //这里用min，是为了防止出现减去的数过大（比如
      100，可以自己试一试）；
  }
  if(n>=100)
  {
    ans+=(n/1000+1)*100;
    if(n%1000<200-1)
      ans-=min(100,200-n%1000-1);
  }
  if(n>=1000)
  {
    ans+=(n/10000+1)*1000;
    if(n%10000<2000-1)
      ans-=min(1000,2000-n%10000-1);
  }
  if(n>=10000)
  {
    ans+=(n/100000+1)*10000;
    if(n%100000<20000-1)
      ans-=min(10000,20000-n%100000-1);
  }
  if(n>=100000)
  {
    ans+=(n/1000000+1)*100000;
    if(n%1000000<200000-1)
      ans-=min(100000,200000-n%1000000-1);
  }
  if(n>=1000000)
  {
    ans+=(n/10000000+1)*1000000;
    if(n%10000000<2000000-1)
      ans-=min(1000000,2000000-n%10000000-1);
  }
  if(n>=10000000)
  {
    ans+=(n/100000000+1)*10000000;
    if(n%100000000<20000000-1)
      ans-=min(10000000,20000000-n%100000000-1);
  }
  if(n>=100000000)
  {
    ans+=(n/1000000000+1)*100000000;
    if(n%1000000000<200000000-1)
      ans-=min(100000000,200000000-n%1000000000-1);
  }
  if(n>=1000000000)
  {
    ans+=(n/10000000000+1)*1000000000;
    if(n%10000000000<2000000000-1)
      ans-=min(1000000000,2000000000-n%10000000000-1);
  }
  cout<<ans<<endl;
  return 0;
}

```

亲测AC，所有数据$1ms$过。

写题解不易，觉得好的，给个赞再走呗~

---

## 作者：初音Miku (赞：14)

这题数据有点毒啊，数据很大，开局TLE11，
$ O(nlog_{10}n) $会超时，用$ O(log_{10}n) $即可。


```cpp
#include <cstdio>
int main()
{
    unsigned long long h,m=10,ans=0;//不解释的定义，因为数据大，用unsigned long long。
    scanf("%lld",&h);//不解释的读入。
    while(h/m>0)//来一个循环。
    {
        ans+=(h-h%m)/10+(h%m>=1*m/10?(h%m<(1+1)*m/10?h%m-1*m/10+1:m/10):0);//看不懂的去了解一下三目运算符，把这句话拆开就行。
        m*=10;
    }
    ans+=(h%m>=1*m/10?(h%m<(1+1)*m/10?h%m-1*m/10+1:m/10):0);//同上，就是有点长，初学者有点耐心。
    printf("%lld\n",ans);//AT的习惯，换行，换行，换行。大佬YangWill就因为这个爆零。
    return 0;
}
```
P.S.尽量用scanf和printf，cin和cout面对大数据很慢，特慢，不解释的慢。

这个题对于初学者来看有一定难度，但值得思考去做，挺考验思考能力。

---

## 作者：Z_M__ (赞：6)

这题是一道数位DP。

---
**1. 状态表示:** 我们设$f[i][j][k]$表示所有**数位为i位**$\;$且$\;$**最高位为j**$\;$出现数字**k的次数**,（如$f[2][1][1]=11$,因为10~19间出现了11次1）。（其实这题不用3维，但为了更好享用[~~多倍经验~~](https://www.luogu.com.cn/paste/zyszoonf)，所以...）
 
**2.状态转移：** 先给些柿子

（1）
$$
\sum_{i=0}^{i=9}{f[1][i][i]=1}
$$
（2）
$$
 f[i][j][k] += \sum_{j=0}^{j=9}{f[i - 1][j][k]}
 $$
（3）
$$
 \sum_{j=0}^{j=9} {f[i][j][j] += pow(10,i-1)}
$$

- 首先对于1位数我们可以直接赋值，$f[1][0][0] = f[1][1][1] =f[1][2][2]...f[1][9][9] = 1$

- 其他不是1位数的，则是上面的柿子2。
比如$f[3][1][1]$**表示的**(是所有3位数且最高位为1的数中出现数字1的次数)**就是100到199中出现数字1的次数**，如果去掉最高位的1，那剩下的数就是0到99，也就是所有两位数和一位数，由于我们是从1位数开始枚举转移的，所以我们现在已经有了$f[2][0...9][1]$这只是$f[3][1][1]$的一部分（后面两位数的部分），还有一部分就是最高位1，所以100-199这些数每个数都对$f[3][1][1]$有1的贡献，所以$f[3][1][1]+=pow(10,2)$,**这就是柿子3**。

```cpp
for (int i = 0; i <= 9; i++)//柿子1
	f[1][i][i] = 1; //显然！
for (int i = 2; i <= 9; i++)//枚举当前位数
{
	for (int j = 0; j <= 9; j++)//枚举最高位
	{
      for (int k = 0; k <= 9; k++)
			for (int l = 0; l <= 9; l++)//枚举上1位数的最高位
			f[i][j][k] += f[i - 1][l][k];//柿子2
		f[i][j][j] += pow (10, i -1);//柿子3
	}
}
```

**3.计算答案：** 由于$f[i][j][k]$中的只是一段一段的，所以在计算答案时也要分段求:

- **举个栗子: n=433 是，算出现1的次数：**

- **第一段：** $1-99$
	
   我们有$1-9,f[2][1][1](10-19),f[2][2][1](20-29)...f[2][9][1](90-99)$
   
- **第二段：** $100-399$ 

   我们有$f[3][1][1](100-199),f[3][2][1](200-299)$
   
- **第三段**: $400-433$

   这时我们最高位只能是4了，所以只要枚举后两位就行了，但**如果最高位是1**的话那么**第三段的所有数对答案都多有1的贡献**，**这时要加上pow(10,3-1)**，分开枚举则为$f[2][0][1](400-409),f[2][1][1](410-429)$，最后只剩$430-433$了，也就是$f[1][1][0]f[1][1][1](431),f[1][2][1](432),f[1][3][1](434)$
```cpp
#include <bits/stdc++.h> 
#define int long long//要开longlong，数据有问题
using namespace std;
const int MAXN = 1e2;
int n, f[MAXN][22][22];
void init ()
{
	for (int i = 0; i <= 9; i++)//柿子1
		f[1][i][i] = 1; //显然！
	for (int i = 2; i <= 9; i++)//枚举当前位数
	{
		for (int j = 0; j <= 9; j++)//枚举最高位
		{
	      for (int k = 0; k <= 9; k++)
				for (int l = 0; l <= 9; l++)//枚举上1位数的最高位
				f[i][j][k] += f[i - 1][l][k];//柿子2
			f[i][j][j] += pow (10, i -1);//柿子3
		}
	}
}
int sum (int x, int num)
{
	int a[10] = {}, len = 0, sum = 0;
	while (x)
	{
		a[++len] = x % 10;
		x /= 10;
	}
	
	for (int i = 1; i <= len - 1; i++)//第一段 (1-9,不能是0，因为不能有前导0)
		for (int j = 1; j <= 9; j++)
			sum += f[i][j][num];
	
	for (int i = 1; i <= a[len] - 1; i++)//第二段 
		sum += f[len][i][num];
		
	for (int i = len - 1; i >= 1; i--)//第三段 
	{
		for (int j = 0; j <= a[i] - 1; j++)//可以是0，以为前面已经确定了非0数 
			sum += f[i][j][num];
			
		for (int j = len; j > i; j--)//不要忘了这!! 
			if (a[j] == 1)
			   sum += a[i] * pow (10, i - 1);
	}
	return sum;
}
signed main ()
{
	init ();
	cin >> n;
	cout << sum (n + 1, 1) << endl;//n+1是因为sum()中只统计到x-1 
	return 0;
}
```

---

## 作者：陈晋衍 (赞：6)

本蒟蒻刚学数位DP，请大家多多指教。（我只会一种写法）

本题是数位DP的模板。

思路：先把数给拆了，用DFS搜索各个数位，把1的个数累加，在最后返回1的个数。在返回时累加1的个数即可。

~~题目很水，数据不大~~


------------


```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[101],t[10][100];
int dfs(int k,int sum,int ok)
/*k为数位，sum为1的个数，ok为要不要搜到9*/
{
	if(k==0)return sum;//返回1的个数
	int end=ok?a[k]:9;//看看要不要搜到9
	int s=0;//从0开始累加
	if(!ok&&t[sum][k]!=0)return t[sum][k];//记忆化
	for(int i=0;i<=end;i++)
	{
		s+=dfs(k-1,sum+(i==1),ok&&i==end);//累加
	}
	t[sum][k]=s;//记忆化
	return s;//返回累加1的个数
}
int chai(int n)
{
	//if(n==0)return 0;
	memset(a,0,sizeof(a));
	memset(t,0,sizeof(t));//可以把这两行写在main函数中
	int i=0;
	while(n!=0)//拆
	{
		i++;
		a[i]=n%10;//存在a[i]里
		n/=10;
	}
	return dfs(i,0,1);//搜
}
int main()
{
	int n,m;
	cin>>n;//输入不解释
	cout<<chai(n)<<endl;//一定要换行！我曾因此爆0
	return 0;
}
```

---

## 作者：peterwuyihong (赞：6)

并没有人分段打表
```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+48);
}
#define B 2000000
int n;
int ans;
int h[1000000000/B+1]={0,2200000,3400000,4600000,5800000,7000001,11200001,14400001,17600001,20800001,24000000,26200000,27400000,28600000,29800000,31000000,33200000,34400000,35600000,36800000,38000000,40200000,41400000,42600000,43800000,45000000,47200000,48400000,49600000,50800000,52000000,54200000,55400000,56600000,57800000,59000000,61200000,62400000,63600000,64800000,66000000,68200000,69400000,70600000,71800000,73000000,75200000,76400000,77600000,78800000,80000001,84200001,87400001,90600001,93800001,97000002,103200002,108400002,113600002,118800002,124000001,128200001,131400001,134600001,137800001,141000001,145200001,148400001,151600001,154800001,158000001,162200001,165400001,168600001,171800001,175000001,179200001,182400001,185600001,188800001,192000001,196200001,199400001,202600001,205800001,209000001,213200001,216400001,219600001,222800001,226000001,230200001,233400001,236600001,239800001,243000001,247200001,250400001,253600001,256800001,260000000,262200000,263400000,264600000,265800000,267000001,271200001,274400001,277600001,280800001,284000000,286200000,287400000,288600000,289800000,291000000,293200000,294400000,295600000,296800000,298000000,300200000,301400000,302600000,303800000,305000000,307200000,308400000,309600000,310800000,312000000,314200000,315400000,316600000,317800000,319000000,321200000,322400000,323600000,324800000,326000000,328200000,329400000,330600000,331800000,333000000,335200000,336400000,337600000,338800000,340000000,342200000,343400000,344600000,345800000,347000001,351200001,354400001,357600001,360800001,364000000,366200000,367400000,368600000,369800000,371000000,373200000,374400000,375600000,376800000,378000000,380200000,381400000,382600000,383800000,385000000,387200000,388400000,389600000,390800000,392000000,394200000,395400000,396600000,397800000,399000000,401200000,402400000,403600000,404800000,406000000,408200000,409400000,410600000,411800000,413000000,415200000,416400000,417600000,418800000,420000000,422200000,423400000,424600000,425800000,427000001,431200001,434400001,437600001,440800001,444000000,446200000,447400000,448600000,449800000,451000000,453200000,454400000,455600000,456800000,458000000,460200000,461400000,462600000,463800000,465000000,467200000,468400000,469600000,470800000,472000000,474200000,475400000,476600000,477800000,479000000,481200000,482400000,483600000,484800000,486000000,488200000,489400000,490600000,491800000,493000000,495200000,496400000,497600000,498800000,500000000,502200000,503400000,504600000,505800000,507000001,511200001,514400001,517600001,520800001,524000000,526200000,527400000,528600000,529800000,531000000,533200000,534400000,535600000,536800000,538000000,540200000,541400000,542600000,543800000,545000000,547200000,548400000,549600000,550800000,552000000,554200000,555400000,556600000,557800000,559000000,561200000,562400000,563600000,564800000,566000000,568200000,569400000,570600000,571800000,573000000,575200000,576400000,577600000,578800000,580000000,582200000,583400000,584600000,585800000,587000001,591200001,594400001,597600001,600800001,604000000,606200000,607400000,608600000,609800000,611000000,613200000,614400000,615600000,616800000,618000000,620200000,621400000,622600000,623800000,625000000,627200000,628400000,629600000,630800000,632000000,634200000,635400000,636600000,637800000,639000000,641200000,642400000,643600000,644800000,646000000,648200000,649400000,650600000,651800000,653000000,655200000,656400000,657600000,658800000,660000000,662200000,663400000,664600000,665800000,667000001,671200001,674400001,677600001,680800001,684000000,686200000,687400000,688600000,689800000,691000000,693200000,694400000,695600000,696800000,698000000,700200000,701400000,702600000,703800000,705000000,707200000,708400000,709600000,710800000,712000000,714200000,715400000,716600000,717800000,719000000,721200000,722400000,723600000,724800000,726000000,728200000,729400000,730600000,731800000,733000000,735200000,736400000,737600000,738800000,740000000,742200000,743400000,744600000,745800000,747000001,751200001,754400001,757600001,760800001,764000000,766200000,767400000,768600000,769800000,771000000,773200000,774400000,775600000,776800000,778000000,780200000,781400000,782600000,783800000,785000000,787200000,788400000,789600000,790800000,792000000,794200000,795400000,796600000,797800000,799000000,801200000,802400000,803600000,804800000,806000000,808200000,809400000,810600000,811800000,813000000,815200000,816400000,817600000,818800000,820000000,822200000,823400000,824600000,825800000,827000001,831200001,834400001,837600001,840800001,844000000,846200000,847400000,848600000,849800000,851000000,853200000,854400000,855600000,856800000,858000000,860200000,861400000,862600000,863800000,865000000,867200000,868400000,869600000,870800000,872000000,874200000,875400000,876600000,877800000,879000000,881200000,882400000,883600000,884800000,886000000,888200000,889400000,890600000,891800000,893000000,895200000,896400000,897600000,898800000,900000001};
int calc(int x){
	int ret=0;
	while(x){
		ret+=x%10==1;
		x/=10;
	}
	return ret;
}
signed main(){/*
	freopen("testdata.in","w",stdout);
	for(register int i=0;i<=1e9;i++){
		ans+=calc(i);
		if(i%B==0)write(ans),putchar(',');
	}*/
	cin>>n;
	ans=h[n/B];
	for(int i=n/B*B+1;i<=n;i++)ans+=calc(i);
	write(ans),putchar('\n');
}

```
### Tips
面对$1e9$的水数据，可以考虑分段打表。

~~垃圾日本题还要结尾换行，害我$WA$两次，差评~~

---

## 作者：Otomachi_Una_ (赞：4)

# 区间打表能过

考虑到输入比较单一，考虑打表。

但因为 $n$ 比较大，不能打出全部的表，考虑区间打表。

先暴力求解，然后每隔一段就输出一次结果，这就是区间打表。

总的来说，区间打表可以骗分，AC，甚至拿到最优解。

打表程序：
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int ans=0;
void check(int x){
	while(x){
		if(x%10==1)
			ans++;
		x/=10;
	}
}
int main(){
	freopen("dabiao.out","w",stdout);
	for(int i=1;i<=1e9;i++){
		check(i);
		if(i%1000000==0)
			cout<<ans<<",";
	}
	return 0;
}

```
# 打表结果：
```cpp
600001,2200000,2800000,3400000,4000000,4600000,5200000,5800000,6400000,7000001,8600002,11200001,12800001,14400001,16000001,17600001,19200001,20800001,22400001,24000000,24600001,26200000,26800000,27400000,28000000,28600000,29200000,29800000,30400000,31000000,31600001,33200000,33800000,34400000,35000000,35600000,36200000,36800000,37400000,38000000,38600001,40200000,40800000,41400000,42000000,42600000,43200000,43800000,44400000,45000000,45600001,47200000,47800000,48400000,49000000,49600000,50200000,50800000,51400000,52000000,52600001,54200000,54800000,55400000,56000000,56600000,57200000,57800000,58400000,59000000,59600001,61200000,61800000,62400000,63000000,63600000,64200000,64800000,65400000,66000000,66600001,68200000,68800000,69400000,70000000,70600000,71200000,71800000,72400000,73000000,73600001,75200000,75800000,76400000,77000000,77600000,78200000,78800000,79400000,80000001,81600002,84200001,85800001,87400001,89000001,90600001,92200001,93800001,95400001,97000002,99600003,103200002,105800002,108400002,111000002,113600002,116200002,118800002,121400002,124000001,125600002,128200001,129800001,131400001,133000001,134600001,136200001,137800001,139400001,141000001,142600002,145200001,146800001,148400001,150000001,151600001,153200001,154800001,156400001,158000001,159600002,162200001,163800001,165400001,167000001,168600001,170200001,171800001,173400001,175000001,176600002,179200001,180800001,182400001,184000001,185600001,187200001,188800001,190400001,192000001,193600002,196200001,197800001,199400001,201000001,202600001,204200001,205800001,207400001,209000001,210600002,213200001,214800001,216400001,218000001,219600001,221200001,222800001,224400001,226000001,227600002,230200001,231800001,233400001,235000001,236600001,238200001,239800001,241400001,243000001,244600002,247200001,248800001,250400001,252000001,253600001,255200001,256800001,258400001,260000000,260600001,262200000,262800000,263400000,264000000,264600000,265200000,265800000,266400000,267000001,268600002,271200001,272800001,274400001,276000001,277600001,279200001,280800001,282400001,284000000,284600001,286200000,286800000,287400000,288000000,288600000,289200000,289800000,290400000,291000000,291600001,293200000,293800000,294400000,295000000,295600000,296200000,296800000,297400000,298000000,298600001,300200000,300800000,301400000,302000000,302600000,303200000,303800000,304400000,305000000,305600001,307200000,307800000,308400000,309000000,309600000,310200000,310800000,311400000,312000000,312600001,314200000,314800000,315400000,316000000,316600000,317200000,317800000,318400000,319000000,319600001,321200000,321800000,322400000,323000000,323600000,324200000,324800000,325400000,326000000,326600001,328200000,328800000,329400000,330000000,330600000,331200000,331800000,332400000,333000000,333600001,335200000,335800000,336400000,337000000,337600000,338200000,338800000,339400000,340000000,340600001,342200000,342800000,343400000,344000000,344600000,345200000,345800000,346400000,347000001,348600002,351200001,352800001,354400001,356000001,357600001,359200001,360800001,362400001,364000000,364600001,366200000,366800000,367400000,368000000,368600000,369200000,369800000,370400000,371000000,371600001,373200000,373800000,374400000,375000000,375600000,376200000,376800000,377400000,378000000,378600001,380200000,380800000,381400000,382000000,382600000,383200000,383800000,384400000,385000000,385600001,387200000,387800000,388400000,389000000,389600000,390200000,390800000,391400000,392000000,392600001,394200000,394800000,395400000,396000000,396600000,397200000,397800000,398400000,399000000,399600001,401200000,401800000,402400000,403000000,403600000,404200000,404800000,405400000,406000000,406600001,408200000,408800000,409400000,410000000,410600000,411200000,411800000,412400000,413000000,413600001,415200000,415800000,416400000,417000000,417600000,418200000,418800000,419400000,420000000,420600001,422200000,422800000,423400000,424000000,424600000,425200000,425800000,426400000,427000001,428600002,431200001,432800001,434400001,436000001,437600001,439200001,440800001,442400001,444000000,444600001,446200000,446800000,447400000,448000000,448600000,449200000,449800000,450400000,451000000,451600001,453200000,453800000,454400000,455000000,455600000,456200000,456800000,457400000,458000000,458600001,460200000,460800000,461400000,462000000,462600000,463200000,463800000,464400000,465000000,465600001,467200000,467800000,468400000,469000000,469600000,470200000,470800000,471400000,472000000,472600001,474200000,474800000,475400000,476000000,476600000,477200000,477800000,478400000,479000000,479600001,481200000,481800000,482400000,483000000,483600000,484200000,484800000,485400000,486000000,486600001,488200000,488800000,489400000,490000000,490600000,491200000,491800000,492400000,493000000,493600001,495200000,495800000,496400000,497000000,497600000,498200000,498800000,499400000,500000000,500600001,502200000,502800000,503400000,504000000,504600000,505200000,505800000,506400000,507000001,508600002,511200001,512800001,514400001,516000001,517600001,519200001,520800001,522400001,524000000,524600001,526200000,526800000,527400000,528000000,528600000,529200000,529800000,530400000,531000000,531600001,533200000,533800000,534400000,535000000,535600000,536200000,536800000,537400000,538000000,538600001,540200000,540800000,541400000,542000000,542600000,543200000,543800000,544400000,545000000,545600001,547200000,547800000,548400000,549000000,549600000,550200000,550800000,551400000,552000000,552600001,554200000,554800000,555400000,556000000,556600000,557200000,557800000,558400000,559000000,559600001,561200000,561800000,562400000,563000000,563600000,564200000,564800000,565400000,566000000,566600001,568200000,568800000,569400000,570000000,570600000,571200000,571800000,572400000,573000000,573600001,575200000,575800000,576400000,577000000,577600000,578200000,578800000,579400000,580000000,580600001,582200000,582800000,583400000,584000000,584600000,585200000,585800000,586400000,587000001,588600002,591200001,592800001,594400001,596000001,597600001,599200001,600800001,602400001,604000000,604600001,606200000,606800000,607400000,608000000,608600000,609200000,609800000,610400000,611000000,611600001,613200000,613800000,614400000,615000000,615600000,616200000,616800000,617400000,618000000,618600001,620200000,620800000,621400000,622000000,622600000,623200000,623800000,624400000,625000000,625600001,627200000,627800000,628400000,629000000,629600000,630200000,630800000,631400000,632000000,632600001,634200000,634800000,635400000,636000000,636600000,637200000,637800000,638400000,639000000,639600001,641200000,641800000,642400000,643000000,643600000,644200000,644800000,645400000,646000000,646600001,648200000,648800000,649400000,650000000,650600000,651200000,651800000,652400000,653000000,653600001,655200000,655800000,656400000,657000000,657600000,658200000,658800000,659400000,660000000,660600001,662200000,662800000,663400000,664000000,664600000,665200000,665800000,666400000,667000001,668600002,671200001,672800001,674400001,676000001,677600001,679200001,680800001,682400001,684000000,684600001,686200000,686800000,687400000,688000000,688600000,689200000,689800000,690400000,691000000,691600001,693200000,693800000,694400000,695000000,695600000,696200000,696800000,697400000,698000000,698600001,700200000,700800000,701400000,702000000,702600000,703200000,703800000,704400000,705000000,705600001,707200000,707800000,708400000,709000000,709600000,710200000,710800000,711400000,712000000,712600001,714200000,714800000,715400000,716000000,716600000,717200000,717800000,718400000,719000000,719600001,721200000,721800000,722400000,723000000,723600000,724200000,724800000,725400000,726000000,726600001,728200000,728800000,729400000,730000000,730600000,731200000,731800000,732400000,733000000,733600001,735200000,735800000,736400000,737000000,737600000,738200000,738800000,739400000,740000000,740600001,742200000,742800000,743400000,744000000,744600000,745200000,745800000,746400000,747000001,748600002,751200001,752800001,754400001,756000001,757600001,759200001,760800001,762400001,764000000,764600001,766200000,766800000,767400000,768000000,768600000,769200000,769800000,770400000,771000000,771600001,773200000,773800000,774400000,775000000,775600000,776200000,776800000,777400000,778000000,778600001,780200000,780800000,781400000,782000000,782600000,783200000,783800000,784400000,785000000,785600001,787200000,787800000,788400000,789000000,789600000,790200000,790800000,791400000,792000000,792600001,794200000,794800000,795400000,796000000,796600000,797200000,797800000,798400000,799000000,799600001,801200000,801800000,802400000,803000000,803600000,804200000,804800000,805400000,806000000,806600001,808200000,808800000,809400000,810000000,810600000,811200000,811800000,812400000,813000000,813600001,815200000,815800000,816400000,817000000,817600000,818200000,818800000,819400000,820000000,820600001,822200000,822800000,823400000,824000000,824600000,825200000,825800000,826400000,827000001,828600002,831200001,832800001,834400001,836000001,837600001,839200001,840800001,842400001,844000000,844600001,846200000,846800000,847400000,848000000,848600000,849200000,849800000,850400000,851000000,851600001,853200000,853800000,854400000,855000000,855600000,856200000,856800000,857400000,858000000,858600001,860200000,860800000,861400000,862000000,862600000,863200000,863800000,864400000,865000000,865600001,867200000,867800000,868400000,869000000,869600000,870200000,870800000,871400000,872000000,872600001,874200000,874800000,875400000,876000000,876600000,877200000,877800000,878400000,879000000,879600001,881200000,881800000,882400000,883000000,883600000,884200000,884800000,885400000,886000000,886600001,888200000,888800000,889400000,890000000,890600000,891200000,891800000,892400000,893000000,893600001,895200000,895800000,896400000,897000000,897600000,898200000,898800000,899400000,900000001,
```
# 最终程序：
```cpp
#include<iostream>
#include<cstdio> 
using namespace std;

int n,ans=0;
void check(int x){
	while(x){
		if(x%10==1)
			ans++;
		x/=10;
	}
}
int a[]={0,600001,2200000,2800000,3400000,4000000,4600000,5200000,5800000,6400000,7000001,8600002,11200001,12800001,14400001,16000001,17600001,19200001,20800001,22400001,24000000,24600001,26200000,26800000,27400000,28000000,28600000,29200000,29800000,30400000,31000000,31600001,33200000,33800000,34400000,35000000,35600000,36200000,36800000,37400000,38000000,38600001,40200000,40800000,41400000,42000000,42600000,43200000,43800000,44400000,45000000,45600001,47200000,47800000,48400000,49000000,49600000,50200000,50800000,51400000,52000000,52600001,54200000,54800000,55400000,56000000,56600000,57200000,57800000,58400000,59000000,59600001,61200000,61800000,62400000,63000000,63600000,64200000,64800000,65400000,66000000,66600001,68200000,68800000,69400000,70000000,70600000,71200000,71800000,72400000,73000000,73600001,75200000,75800000,76400000,77000000,77600000,78200000,78800000,79400000,80000001,81600002,84200001,85800001,87400001,89000001,90600001,92200001,93800001,95400001,97000002,99600003,103200002,105800002,108400002,111000002,113600002,116200002,118800002,121400002,124000001,125600002,128200001,129800001,131400001,133000001,134600001,136200001,137800001,139400001,141000001,142600002,145200001,146800001,148400001,150000001,151600001,153200001,154800001,156400001,158000001,159600002,162200001,163800001,165400001,167000001,168600001,170200001,171800001,173400001,175000001,176600002,179200001,180800001,182400001,184000001,185600001,187200001,188800001,190400001,192000001,193600002,196200001,197800001,199400001,201000001,202600001,204200001,205800001,207400001,209000001,210600002,213200001,214800001,216400001,218000001,219600001,221200001,222800001,224400001,226000001,227600002,230200001,231800001,233400001,235000001,236600001,238200001,239800001,241400001,243000001,244600002,247200001,248800001,250400001,252000001,253600001,255200001,256800001,258400001,260000000,260600001,262200000,262800000,263400000,264000000,264600000,265200000,265800000,266400000,267000001,268600002,271200001,272800001,274400001,276000001,277600001,279200001,280800001,282400001,284000000,284600001,286200000,286800000,287400000,288000000,288600000,289200000,289800000,290400000,291000000,291600001,293200000,293800000,294400000,295000000,295600000,296200000,296800000,297400000,298000000,298600001,300200000,300800000,301400000,302000000,302600000,303200000,303800000,304400000,305000000,305600001,307200000,307800000,308400000,309000000,309600000,310200000,310800000,311400000,312000000,312600001,314200000,314800000,315400000,316000000,316600000,317200000,317800000,318400000,319000000,319600001,321200000,321800000,322400000,323000000,323600000,324200000,324800000,325400000,326000000,326600001,328200000,328800000,329400000,330000000,330600000,331200000,331800000,332400000,333000000,333600001,335200000,335800000,336400000,337000000,337600000,338200000,338800000,339400000,340000000,340600001,342200000,342800000,343400000,344000000,344600000,345200000,345800000,346400000,347000001,348600002,351200001,352800001,354400001,356000001,357600001,359200001,360800001,362400001,364000000,364600001,366200000,366800000,367400000,368000000,368600000,369200000,369800000,370400000,371000000,371600001,373200000,373800000,374400000,375000000,375600000,376200000,376800000,377400000,378000000,378600001,380200000,380800000,381400000,382000000,382600000,383200000,383800000,384400000,385000000,385600001,387200000,387800000,388400000,389000000,389600000,390200000,390800000,391400000,392000000,392600001,394200000,394800000,395400000,396000000,396600000,397200000,397800000,398400000,399000000,399600001,401200000,401800000,402400000,403000000,403600000,404200000,404800000,405400000,406000000,406600001,408200000,408800000,409400000,410000000,410600000,411200000,411800000,412400000,413000000,413600001,415200000,415800000,416400000,417000000,417600000,418200000,418800000,419400000,420000000,420600001,422200000,422800000,423400000,424000000,424600000,425200000,425800000,426400000,427000001,428600002,431200001,432800001,434400001,436000001,437600001,439200001,440800001,442400001,444000000,444600001,446200000,446800000,447400000,448000000,448600000,449200000,449800000,450400000,451000000,451600001,453200000,453800000,454400000,455000000,455600000,456200000,456800000,457400000,458000000,458600001,460200000,460800000,461400000,462000000,462600000,463200000,463800000,464400000,465000000,465600001,467200000,467800000,468400000,469000000,469600000,470200000,470800000,471400000,472000000,472600001,474200000,474800000,475400000,476000000,476600000,477200000,477800000,478400000,479000000,479600001,481200000,481800000,482400000,483000000,483600000,484200000,484800000,485400000,486000000,486600001,488200000,488800000,489400000,490000000,490600000,491200000,491800000,492400000,493000000,493600001,495200000,495800000,496400000,497000000,497600000,498200000,498800000,499400000,500000000,500600001,502200000,502800000,503400000,504000000,504600000,505200000,505800000,506400000,507000001,508600002,511200001,512800001,514400001,516000001,517600001,519200001,520800001,522400001,524000000,524600001,526200000,526800000,527400000,528000000,528600000,529200000,529800000,530400000,531000000,531600001,533200000,533800000,534400000,535000000,535600000,536200000,536800000,537400000,538000000,538600001,540200000,540800000,541400000,542000000,542600000,543200000,543800000,544400000,545000000,545600001,547200000,547800000,548400000,549000000,549600000,550200000,550800000,551400000,552000000,552600001,554200000,554800000,555400000,556000000,556600000,557200000,557800000,558400000,559000000,559600001,561200000,561800000,562400000,563000000,563600000,564200000,564800000,565400000,566000000,566600001,568200000,568800000,569400000,570000000,570600000,571200000,571800000,572400000,573000000,573600001,575200000,575800000,576400000,577000000,577600000,578200000,578800000,579400000,580000000,580600001,582200000,582800000,583400000,584000000,584600000,585200000,585800000,586400000,587000001,588600002,591200001,592800001,594400001,596000001,597600001,599200001,600800001,602400001,604000000,604600001,606200000,606800000,607400000,608000000,608600000,609200000,609800000,610400000,611000000,611600001,613200000,613800000,614400000,615000000,615600000,616200000,616800000,617400000,618000000,618600001,620200000,620800000,621400000,622000000,622600000,623200000,623800000,624400000,625000000,625600001,627200000,627800000,628400000,629000000,629600000,630200000,630800000,631400000,632000000,632600001,634200000,634800000,635400000,636000000,636600000,637200000,637800000,638400000,639000000,639600001,641200000,641800000,642400000,643000000,643600000,644200000,644800000,645400000,646000000,646600001,648200000,648800000,649400000,650000000,650600000,651200000,651800000,652400000,653000000,653600001,655200000,655800000,656400000,657000000,657600000,658200000,658800000,659400000,660000000,660600001,662200000,662800000,663400000,664000000,664600000,665200000,665800000,666400000,667000001,668600002,671200001,672800001,674400001,676000001,677600001,679200001,680800001,682400001,684000000,684600001,686200000,686800000,687400000,688000000,688600000,689200000,689800000,690400000,691000000,691600001,693200000,693800000,694400000,695000000,695600000,696200000,696800000,697400000,698000000,698600001,700200000,700800000,701400000,702000000,702600000,703200000,703800000,704400000,705000000,705600001,707200000,707800000,708400000,709000000,709600000,710200000,710800000,711400000,712000000,712600001,714200000,714800000,715400000,716000000,716600000,717200000,717800000,718400000,719000000,719600001,721200000,721800000,722400000,723000000,723600000,724200000,724800000,725400000,726000000,726600001,728200000,728800000,729400000,730000000,730600000,731200000,731800000,732400000,733000000,733600001,735200000,735800000,736400000,737000000,737600000,738200000,738800000,739400000,740000000,740600001,742200000,742800000,743400000,744000000,744600000,745200000,745800000,746400000,747000001,748600002,751200001,752800001,754400001,756000001,757600001,759200001,760800001,762400001,764000000,764600001,766200000,766800000,767400000,768000000,768600000,769200000,769800000,770400000,771000000,771600001,773200000,773800000,774400000,775000000,775600000,776200000,776800000,777400000,778000000,778600001,780200000,780800000,781400000,782000000,782600000,783200000,783800000,784400000,785000000,785600001,787200000,787800000,788400000,789000000,789600000,790200000,790800000,791400000,792000000,792600001,794200000,794800000,795400000,796000000,796600000,797200000,797800000,798400000,799000000,799600001,801200000,801800000,802400000,803000000,803600000,804200000,804800000,805400000,806000000,806600001,808200000,808800000,809400000,810000000,810600000,811200000,811800000,812400000,813000000,813600001,815200000,815800000,816400000,817000000,817600000,818200000,818800000,819400000,820000000,820600001,822200000,822800000,823400000,824000000,824600000,825200000,825800000,826400000,827000001,828600002,831200001,832800001,834400001,836000001,837600001,839200001,840800001,842400001,844000000,844600001,846200000,846800000,847400000,848000000,848600000,849200000,849800000,850400000,851000000,851600001,853200000,853800000,854400000,855000000,855600000,856200000,856800000,857400000,858000000,858600001,860200000,860800000,861400000,862000000,862600000,863200000,863800000,864400000,865000000,865600001,867200000,867800000,868400000,869000000,869600000,870200000,870800000,871400000,872000000,872600001,874200000,874800000,875400000,876000000,876600000,877200000,877800000,878400000,879000000,879600001,881200000,881800000,882400000,883000000,883600000,884200000,884800000,885400000,886000000,886600001,888200000,888800000,889400000,890000000,890600000,891200000,891800000,892400000,893000000,893600001,895200000,895800000,896400000,897000000,897600000,898200000,898800000,899400000,900000001};
int main(){
	cin>>n;
	ans=a[n/1000000];
	for(int i=(n/1000000)*1000000+1;i<=n;i++)
		check(i);
	cout<<ans;
	return 0;
}

```
这个你总不能复制粘贴了吧（全写在同一行）

---

## 作者：Fcersoka (赞：3)

这道题暴力肯定是不能过的 ！  
这道题呢 ，就是套数位 dp 的板子 ！  
数位 dp 其实就是通过递归搜索数位 ，这当然比搜索数字快的的多 。接着呢 ，就是通过记忆化搜索 ，加快速度 。只不过有些东西很细节 。  
这些细节就是对于这个数的最高位处理 ，和这个记忆化数组的状态处理 。对于最高位处理 ，先设一个参数 $limit$，第一层递归肯定是最高位 ，所以传过去的参数是为真的 。这个最高位标记 $limit$ 的主要作用就是找出当前数位最大能枚举到几 ，如果当前是最高位 ，那么当前数位只能枚举到这个数在这个数位的数字 ，否则 ，最大能枚举到 $9$。再说一下这个记忆化数组的状态处理 ，记忆化数组的状态用下标来表示 ，有两个状态 ，一个是当前位数 ，另一个是当前有了多少个 $1$。比如 $dp\left[pos\right]\left[num\right]$ 表示的就是第 $pos$ 位 ，现在已经有了 $num$ 个 $1$。   
下面是 AC 代码 。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll dp[1001][1001],a[1001];
ll dfs(ll pos,bool limit,ll num) {
	if(pos==0) return num;
	if(!limit&&dp[pos][num]!=-1) return dp[pos][num];//直接返回已经算过了的结果
	ll up=limit?a[pos]:9;
	ll sum=0;
	for(int i=0; i<=up; i++) {
		if(i==1) {//两种情况
			sum+=dfs(pos-1,limit&&i==up,num+1);
		} else {
			sum+=dfs(pos-1,limit&&i==up,num);
		}
	}
	dp[pos][num]=sum;//记忆化
	return sum;
}
ll solve(ll x) {//拆数
	int len=0;
	memset(dp,-1,sizeof(dp));
	while(x) {
		a[++len]=x%10;
		x/=10;
	}
	return dfs(len,true,0);
}
int main() {
	ll n;
	scanf("%lld",&n);
	printf("%lld\n",solve(n));
	return 0;
}
```
感谢您的观看 ！

---

## 作者：A_Pikachu (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/AT1483)
（如果 $\LaTeX$ 炸了，请到博客[观看](https://www.luogu.com.cn/blog/thats-me/ti-jie-at1483-1)）

$\Large\mathscr{Part\,\,1\;\;}\text{基本思路}$

这道题其实是一道小学奥数题。为后文叙述方便，所以我们设表达式 $\operatorname{f}\ (\ left \ ,\ right\ )$ 表示 $[\ left\ ,\ right\ ]$ 中数字 $1$ 出现的个数。

我们首先来探讨 $\operatorname{f}\ (\ 0\ ,\ \underbrace{99 \dots 99}_{\text{n个9}}\ )$ 的值。我们可以从数位的角度去探讨。当第 $i\ (1 \leq i \leq n)$ 位为 $1$ 且其它 $n-1$ 位为 $[0,9]$ 中的整数时，这个数的第 $i$ 位为 $1$ 且这个数小于等于 $\underbrace{99 \dots 99}_{\text{n个9}}$，因为这个数的位数一定小于等于 $n$（首位可以为 $0$ ），并且 $\underbrace{99 \dots 99}_{\text{n个9}}$ 是 $n$ 位数中最大的数，又因为 $n$ 位数以内 $1$ 出现时只能在 $1-n$ 位上，所以这种方法也不会漏。综上，$\operatorname{f}\ (\ 0\ ,\ \underbrace{99 \dots 99}_{\text{n个9}}\ )=\sum\limits_{i=1}^{n}\prod\limits_{j=1}^{n}10=n  \times 10^{n-1}$，对照样例 $3$ 验证结果后发现是对的。

我们再来探讨更一般的的表达式 $\operatorname{f}\ (\ 0\ ,\ \overline{a_n\underbrace{99 \dots 99}_{\text{n-1个9}}}\ )$ 的值。我们可以把它拆分成 $a_n+1$ 个表达式的和，即 $\operatorname{f}\ (\ 0\ ,\ \overline{a_n\underbrace{99 \dots 99}_{\text{n-1个9}}}\ )=\sum\limits_{i=0}^{a_n}\operatorname{f}\ (\ \overline{i\ \underbrace{00 \dots 00}_{\text{n-1个0}}}\ ,\ \overline{i\ \underbrace{99 \dots 99}_{\text{n-1个9}}}\ )$。注意到对于每个 $i$，如果 $i$ 不为 $1$，则 $\operatorname{f}\ (\ \overline{i\ \underbrace{00 \dots 00}_{\text{n-1个0}}}\ ,\ \overline{i\ \underbrace{99 \dots 99}_{\text{n-1个9}}}\ )=\operatorname{f}\ (\ 0\ ,\ \underbrace{99 \dots 99}_{\text{n-1个9}}\ )$，反之，若 $i$ 为 $1$，则 $\operatorname{f}\ (\ \overline{i\ \underbrace{00 \dots 00}_{\text{n-1个0}}}\ ,\ \overline{i\ \underbrace{99 \dots 99}_{\text{n-1个9}}}\ )=\operatorname{f}\ (\ 0\ ,\ \underbrace{99 \dots 99}_{\text{n-1个9}}\ )+10^{n-1}$，由于我们已知 $\operatorname{f}\ (\ 0\ ,\ \underbrace{99 \dots 99}_{\text{n-1个9}}\ )=(n-1) \times 10^{n-2}$，且 $a_n > 0$，所以  $\operatorname{f}\ (\ 0\ ,\ \overline{a_n\underbrace{99 \dots 99}_{\text{n-1个9}}}\ )=(n-1) \times 10^{n-2} \times (a_n+1)+10^{n-1}$。

最后，我们来探讨题目，即表达式 $\operatorname{f}\ (\ 0\ ,\ \overline{a_{n}a_{n-1}\dots a_{2}a_{1}}\ )$ 的值。我们可以知道，原式$= \operatorname{f}\ (\ 0\ ,\ \overline{(a_{n}-1)\underbrace{99 \dots 99}_{\text{n-1个9}}}\ )+\operatorname{f}\ (\ \overline{a_n\ \underbrace{00 \dots 00}_{\text{n-1个0}}}\ ,\ \overline{a_{n}(a_{n-1}-1)\ \underbrace{99 \dots 99}_{\text{n-2个9}}}\ )+ \cdots+\operatorname{f}\ (\ \overline{a_{n}a_{n-1}\dots a_{4}a_{3}00}\ ,\ \overline{a_{n}a_{n-1}\dots a_{3}(a_{2}-1)9}\ )+\operatorname{f}\ (\ \overline{a_{n}a_{n-1}\dots a_{3}a_{2}0}\ ,\ \overline{a_{n}a_{n-1}\dots a_{2}a_{1}}\ )$，这看起来跟前文提及的式子相似，但要注意这里的 $a_i\ (1\leq i <n)$ 是可以为零的，所以我们在计算时需要直接跳过这一情况。当 $a_i(1\leq i \leq n)$ 为 $1$ 时，$\operatorname{f}\ (\ \overline{a_i\ \underbrace{00 \dots 00}_{\text{i-1个0}}}\ ,\ \overline{a_{i}(a_{i-1}-1)\ \underbrace{99 \dots 99}_{\text{i-2个9}}}\ )=\operatorname{f}\ (\ 0\ ,\ \overline{(a_{i-1}-1)\ \underbrace{99 \dots 99}_{\text{i-2个9}}}\ )+a_{i-1} \times 10^{i-2}$，反之，即 $a_i>1$ 时，$\operatorname{f}\ (\ \overline{a_i\ \underbrace{00 \dots 00}_{\text{i-1个0}}}\ ,\ \overline{a_{i}(a_{i-1}-1)\ \underbrace{99 \dots 99}_{\text{i-2个9}}}\ )=\operatorname{f}\ (\ 0\ ,\ \overline{(a_{i-1}-1)\ \underbrace{99 \dots 99}_{\text{i-2个9}}}\ )$。

上述每个式子均可直接计算，结果就是每个式子之和。

其实这么说可能有些空洞了，下面我们就来举个栗子。

假设题目中给的数是 $231056$，则我们要求的表达式就是 $\operatorname{f}\ (\ 0\ ,\ 231056\ )=\operatorname{f}\ (\ 0\ ,\ 199999\ )+\operatorname{f}\ (\ 200000\ ,\ 229999\ )+\operatorname{f}\ (\ 230000\ ,\ 230999\ )+\operatorname{f}\ (\ 231000\ ,\ 231049\ )+\operatorname{f}\ (\ 231050\ ,\ 231056\ )$。

我们可以算出，$\operatorname{f}\ (\ 0\ ,\ 199999\ )=5 \times 10^4 \times 2+10^5=200000$，$\operatorname{f}\ (\ 200000\ ,\ 229999\ )=\operatorname{f}\ (\ 0\ ,\ 29999\ )=4 \times 10^3 \times 3+10^4=22000$，$\operatorname{f}\ (\ 230000\ ,\ 230999\ )=\operatorname{f}\ (\ 0\ ,\ 999\ )=3 \times 10^2=300$，$\operatorname{f}\ (\ 231000\ ,\ 231049\ )=\operatorname{f}\ (\ 0\ ,\ 49\ )=1 \times 10^0 \times 5+10^1+50=65$，$\operatorname{f}\ (\ 231050\ ,\ 231056\ )=\operatorname{f}\ (\ 0\ ,\ 6\ )=7+1=8$。

所以$\small\text{原式}$ $=200000+22000+300+65+8=222373$

$\Large\mathscr{Part\,\,2\;\;}\text{Code}$ $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $ $\tiny\sout\text{Talk is cheap, show me your code.}$

```cpp
#include <cstdio>
#include <cstring>
char ch[99]; //读入数据，为了方便计算，这里用字符数组
int len,ans,q,pow[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000}; //这里预处理出 10 的 i 次方
inline int solve(int x,int n){ //这里的 x 是 首位-1（可能为零），n 是末尾 9 的个数
	if(x==0) return n*pow[n-1];
	return n*pow[n-1]*(x+1)+pow[n];
}
int main(){
	scanf("%s",ch);
	len=strlen(ch);
	for(int i=0; i<len-1; i++){ //循环到倒数第二位，最后一位仅需判断是否为零
		if(ch[i]=='0') continue; //跳过为零
		ans+=solve(ch[i]-'0'-1,len-i-1);
		if(ch[i]=='1'){ //当这一位为一时
			sscanf(ch+i+1,"%d",&q); //把比 i 位小的位数组成的数加上
			ans+=q+1;
		}
	}
	if(ch[len-1]>'0') ans++; //最后一位判断
	printf("%d\n",ans);
	return 0;
}
```
时间复杂度为 $\Theta(\lfloor\log_{10}n\rfloor)$。

于是又愉快地[$\color{green}AC$](https://www.luogu.com.cn/record/32984262)了！

---

## 作者：_虹_ (赞：1)

貌似没有递推的题解。

补上一篇。

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;
#define reg register
const int kmaxn=25;
typedef long long ll;
ll dp[kmaxn][10];//dp(i,j)表示在第1-i位，第i位以1结尾，1到(i-1)位随便放时，1出现的次数
ll m[kmaxn];
int n;
void init()
{
    m[0]=dp[1][1]=1;
    m[1]=10;
    for(reg int i=2;i<=n;++i)
    {
        m[i]=m[i-1]*10;//预处理出10的i次幂
        for(reg int j=0;j<10;++j)
        {
            for(reg int k=0;k<10;++k)
            {
                dp[i][j]+=dp[i-1][k];//不管这一位放什么，前一位都随便放，所以dp(i,j)=sigma dp(i,0 to 9);
            }
        }
        dp[i][1]+=m[i-1];//当这一位放1时贡献的答案
    }
}
ll query(const vector<int>& vec)
{
    ll res=0;
    ll ans=0;
    for(reg int i=0,j=vec.size();i<j;++i)//预处理出上界的数值
    {
        res+=vec[i]*m[i];
    }
    for(reg int i=vec.size();i>0;--i)
    {
        for(reg int j=0;j<vec[i-1];++j)//当前位小于上界，更高位==上界时
        {
            ans+=dp[i][j];
        }
        res-=vec[i-1]*m[i-1];
        if(vec[i-1]==1)//当前位上界是一时，这个1产生的贡献就是低位的数值
            ans+=res;
    }
    return ans;
}
inline void trans(vector<int>& vec,const string& str)//倒置整数+char转int
{
    vec.clear();
    for(reg int i=str.size()-1;i>=0;--i)
    {
        vec.push_back(str[i]-'0');
    }
}
inline void add(vector<int>& vec)//加个一，闭区间变开区间
{
    int t=1;
    for(reg int i=0,j=vec.size();i<j;++i)
    {
        vec[i]+=t;
        t=vec[i]/10;
        vec[i]%=10;
    }
    if(t)
        vec.push_back(t);
}
string l,r;
vector<int> lv,rv;
int main()
{
    ios::sync_with_stdio(false);
    cin>>r;
    n=r.size()+1;
    init();
    trans(rv,r);
    add(rv);
    cout<<query(rv)<<endl;
    return 0;
}
其实l和lv并没有用上的说，毕竟左边界是1,query(0)显然等于0...
```


---

## 作者：minVan (赞：0)

**解题思路**

新方法，十个为一段计算答案，小常数，时间复杂度为 $\mathcal{O}(n\times\lg n)$，因为带有 $\dfrac{1}{10}$ 的常数，所以可以通过本题。

**AC 代码，请勿抄袭**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, ans = 1;
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n;
  int i;
  for(i = 10; i <= n; i += 10) {
    int cnt = 0, tmp = i;
    while(tmp) {
      cnt += (tmp % 10 == 1);
      tmp /= 10;
    }
    ans += cnt * min(10ll, n - i + 1) + 1;
  }
  if(n % 10 == 0) {
    --ans;
  }
  cout << ans << '\n';
  return 0;
}
```

---

## 作者：dingshengyang (赞：0)

其实……这道题……就是数位 DP 板子题之一（求区间内某一数码（所有数码）出现的个数，板子题：P2602。）

---

好，开始。定义数组 $f_{i,j,k}$ 为前 $i$ 位，这一位填的 $j$，$k$ 出现了几次。

- 状态边界：第 $1$ 位，填的 $i$，那么除了 $i$ 填了一次之后，其他都是 $0$。因此 $f_{1,i,i}=1$。

- 状态转移：上一位填的什么鬼数都可以：$f_{i,j,k} = \sum^{9}_{t=0} f_{i-1,t,k}$。但是，注意 $f_{i,j,j}$ 需要特判，加上 $10^{i-1}$。因为如果现在填 $12$（求 $f_{2,2,2}$），填了个 $2$，转移到 $f_{1,t,2}=1(t=2)$ 和 $f_{1,t,2}=0(t\not = 2)$，但是只管了 $2$，$12,22,32,42,...,92$，你不去管他了？当然要加上。

+ dp 过程：先分解数位，用 `vector<int>`存下来。倒着枚举。在当前位以下的，都是整块的，直接加上。同时，之前高位可能也有 $1$，那么还需要加上 $10^{i-1}$，但是因为数组下标从 $0$ 开始，就不用减一了。如果已经是最后一位（$i=0$），那么查一下自己的数位，有 $1$ 就加上。我们之前讨论的都是 $10^{\lfloor \log_{10}^{x} \rfloor}$ 及其以上的。那么之前的直接加上。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL f[40][10][10];
void init(){
	for(int i = 0;i <= 9;i ++)f[1][i][i] = 1;//状态边界
	for(int i = 2;i <= 13;i ++){
		for(int j = 0;j <= 9;j ++){
			for(int k = 0;k <= 9;k ++){
				for(int t = 0;t <= 9;t ++){
					f[i][j][k] += f[i-1][t][k];//状态转移
				}
			}
			f[i][j][j] += pow(10,i-1);//特殊判断
		}
	}
}
LL dp(LL n,LL k){//1 到 n 当中，k 出现了多少次。
	vector<int> nums;
	while(n) nums.push_back(n%10),n/=10;//分解数位
	LL res = 0;//答案
	for(int i = nums.size()-1;i >= 0;i --){
		if(nums[i]){
			for(int j = (i == nums.size()-1);j < nums[i];j ++)res += f[i+1][j][k];//整块加上
			for(int j = nums.size()-1;j > i;j --){
				if(nums[j] == k)res += pow(10,i)*nums[i];//遍历高位
			} 
		}
		if(i == 0){//检查自己
			for(int j = 0;j < nums.size();j ++){
				res += nums[j] == k;
			}
		}
	}
	for(int i = nums.size()-1;i >= 1;i --){//不足 10 的那几次幂，直接加上。
		for(int j = 1;j <= 9;j ++){
			res += f[i][j][k];
		}
	}
	return res;
}
int main(){
	init();
	LL l = 1,r;
	cin>> r;
	cout << dp(r,1) - dp(l-1,1) << endl;
	return 0;
}

```

---

## 作者：Meatherm (赞：0)

似乎没人写我这种丑陋的四维 DP...

那好吧我来发一篇...

## 思路

设 $f[i][sum][high][zero]$ 为搜到第 $i$ 位，当前有 $sum$ 个 $1$ ，是否顶到上界，是否为前导零。

那么接下来就是很简单的 DFS 了...这里就不解释了，自己看代码吧


```cpp
# include <bits/stdc++.h>
# define int long long
# define rr register
const int N=15;
int f[N][N][2][2];
int n;
int a[N],len;
inline int read(void){//快速读入
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')
		res=res*10+c-48;
	return res*f;		
}
inline void make(int x){//数位分离
	len=0;
	while(x){
		a[++len]=x%10,x/=10;
	}
	return;
}
int dfs(int i,int sum,bool high,bool zero){//记忆化搜索过程
	if(!i)//搜完了
		return f[i][sum][high][zero]=sum;
	if(~f[i][sum][high][zero])//如果当前状态已经被处理过
		return f[i][sum][high][zero];	
	int res=0;	
	for(rr int j=0;j<10;++j){
		if(high&&j>a[i])//上界判断
			break;
		res+=dfs(i-1,sum+(j==1),high&&j==a[i],zero&&!j);		
	}
	return f[i][sum][high][zero]=res;
}
inline int work(int x){
	make(x);
	memset(f,-1,sizeof(f));//记住要 memset
	return dfs(len,0,true,true);
}
signed main(void){
	n=read();
	printf("%lld\n",work(n));
	return 0;
}
```

---

## 作者：Bartholomew (赞：0)

其实就是一个**数位DP**,其实不知道的同学可以Google一下！

那么个人认为数位dp的复杂度就是：状态数 * 转移复杂度

DFS(now, limit, sum)

分别表示搜索到了第几位，是不是顶到区间的极限，目前为止的出现了1的个数

因为一个数前面的数字1次数与之后的无关，我们只关心是不是limit！
所以不需要再开一维来记录上一位是什么数字
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define R register
using namespace std;

const int N = 35;

int n, cnt, s[N], dp[N][N];

int DFS(int now, bool limit, int sum)
{
	if(!limit && dp[now][sum] != -1) return dp[now][sum];
	if(!now) return sum;
	int to = limit ? s[now] : 9, res = 0;
	for(R int i = 0; i <= to; i++)
	{
		res += DFS(now - 1, limit && (i == s[now]), sum + (i == 1));
	}
	if(!limit) dp[now][sum] = res;
	return res;
}

int solve(int n)
{
	while(n) s[++cnt] = n % 10, n /= 10;	
	memset(dp, -1, sizeof dp);
	return DFS(cnt, 1, 0);
}

int main()
{
	scanf("%d", &n);
	printf("%d\n", solve(n));
	return 0;
} 
```

---


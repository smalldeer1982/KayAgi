# [ABC323D] Merge Slimes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_d

最初、$ N $ 種類のサイズのスライムがいます。  
具体的には、$ 1\leq\ i\leq\ N $ について、サイズ $ S_i $ のスライムが $ C_i $ 匹います。

高橋君はスライムの合成を好きな順番で好きなだけ($ 0 $ 回でも良い)繰り返すことができます。  
スライムの合成では、次のことを行います。

- **同じ** サイズの $ 2 $ 匹のスライムを選ぶ。選ばれたスライムのサイズが $ X $ であったとき、新しくサイズ $ 2X $ のスライムが出現する。合成後、選ばれた元のスライムは $ 2 $ 匹とも消滅する。

高橋君はスライムの匹数を最小にしたいと考えています。 高橋君がうまく合成を繰り返した時、最小で何匹にすることができるでしょうか?

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 10^5 $
- $ 1\leq\ S_i\leq\ 10^9 $
- $ 1\leq\ C_i\leq\ 10^9 $
- $ S_1,S_2,\ldots,S_N $ はすべて異なる。
- 入力はすべて整数

### Sample Explanation 1

最初、サイズ $ 3 $ のスライムが $ 3 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 1 $ 匹います。 高橋君は次のように合成を $ 2 $ 回行うことができます。 - まず、サイズ $ 3 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 2 $ 匹となります。 - 次に、サイズ $ 6 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 12 $ のスライムが $ 1 $ 匹となります。 高橋君は最初の状態からどのように合成を繰り返してもスライムを $ 2 $ 匹以下にすることはできないため、$ 3 $ を出力します。

### Sample Explanation 2

高橋君は合成を行うことができません。

## 样例 #1

### 输入

```
3
3 3
5 1
6 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3
1 1
2 1
3 1```

### 输出

```
3```

## 样例 #3

### 输入

```
1
1000000000 1000000000```

### 输出

```
13```

# 题解

## 作者：LiJoQiao (赞：5)

[题目链接](https://atcoder.jp/contests/abc323/tasks/abc323_d) [洛谷题面](https://www.luogu.com.cn/problem/AT_abc323_d) [提交记录](https://atcoder.jp/contests/abc323/submissions/46338235)  
### 题意简述  
>共有 $N$ 个不同大小的数 $S_i$。  
>每种数有 $C_i$ 个。  
>两个相同的数 $X$ 可以合成一个数 $2X$，而合成前的两个数消失。  
>求合成的操作结束后最少有多少个数。  

### 分析问题  
只有相同的数 $X$ 才能合成，且合成的数一定为 $2X$，所以合成的顺序不会影响最终的结果，**任何合成顺序最后的结果都是一样的**。  

最简单粗暴的方法就是把所有数读进来，然后模拟合成的操作。  
如果有两个相同的数，将它合成，然后重新统计合成的数。  
最后输出数的数量即可。  
我们需要一个实现**查找、插入、删除、统计数量**的数据结构。  
很自然想到了 `std::set`。  

在 `std::set` 中插入一个数 $X$ 的时候，先查找一下 `std::set` 中有没有该数，如果有就删除该数，进行插入 $2X$ 的操作，直到插入的数在 `std::set` 中不存在，直接插入即可。  

最后数的数量即 `std::set` 的元素数量。

于是我们得到了一个正确但是很慢的暴力程序。  

考虑对算法的优化。  
一种数的数量 $C_i$ 和它本身的大小 $S_i$ 决定了仅用这种数的合成时的最终结果。  
**两个**数能合成一个大的，观察合成的最终结果。  
很容易发现 $C_i$ 的二进制已经在程序里把其最终的结果划分好了。  

我们可以在 $C_i$ 为奇数的时候将一个 $S_i$ 放入数据结构中，在 $C_i$ 为偶数的时候将 $S_i$ 乘以 $2$，将 $C_i$ 除以 $2$，直到 $C_i$ 为 $0$（相当于在读入的时候进行了合成的操作，然后再继续合成统计）。  

由于**任何合成顺序最后的结果都是一样的**，所以我们的算法是正确的。  

代码在上方的提交记录里。  

---

## 作者：wangchai2009 (赞：2)

### ABC323D Merge Slimes

#### 题目简述

小 A 有 $N$ 种橡皮泥。对于第 $i$ 种橡皮泥，它的大小为 $S_i$ 且一共有 $C_i$ 个。

小 A 可以合成两个大小相同的橡皮泥，若这两个橡皮泥大小为 $X$，则新和成的橡皮泥大小为 $2X$。

小 A 想知道，在进行若干次合成后（有可能 $0$ 次），他能获得的最小的橡皮泥的种类数是多少。

#### 思路

要尽量多地进行合成操作，很容易想到从小到大地合成橡皮泥。

每次要合成当前大小最小的橡皮泥，合成之后要么剩余 $0$ 个，要么剩余 $1$ 个。如果剩余 $1$ 个，则之后无论怎样合成都不能消除掉，故对答案产生 $1$ 的贡献。

可以用优先队列维护数量大于 $1$ 的橡皮泥，每次取出队列中大小最小的橡皮泥进行更新。

[Code](https://atcoder.jp/contests/abc323/submissions/46330724)

---

## 作者：无钩七不改名 (赞：1)

题意是给出 $n$ 种数和每种数的个数，每 $2$ 个 $x$ 都可以合并为 $x\times 2$，求最后剩下的数字个数最少为多少。

可以发现，每 $2^y(y\ge0)$ 个 $x$ 可以合并为 $x\times 2^y$。我们只要贪心地对于每个数一直尽量往大数合并就行了。

具体实现是从高到低枚举幂次方，看看能不能合并。

需要注意的是多种数可能合成一个数的情况，这时候如果各自合并可能会出现有剩下的数还能合并的情况，导致答案增大。可以发现，这时候较大数一定是小数的 $2^y(y\ge0)$，我们可以对原来的数组按数字大小从小到大排序，尽量把小数合并到较大数即可。

### 赛时代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100005;

int n,mx;
struct emm{
	int s;
	long long c;
}a[N];
map<int,int> mp;
long long ans;

int read(){
	int f=1,k=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=k*10+c-'0';
		c=getchar();
	}
	return f*k;
}

bool cmp(emm aaa,emm bbb){
	return aaa.s<bbb.s;
}

int main(){
//	cout<<log2(1e14);
	n=read();
	for(int i(1);i<=n;++i){
		a[i].s=read();a[i].c=read();
		mx=max(mx,a[i].s);
	}
	sort(a+1,a+1+n,cmp);
	for(int i(1);i<=n;++i)mp[a[i].s]=i;
	for(int i(1);i<=n;++i){
		//cout<<i<<" "<<a[i].s<<" "<<a[i].c<<'\n';
		if(a[i].c==1){
			++ans;
			continue;
		}
		for(int j(1);j<=30;++j){
			long long k(1ll<<j);
			if(a[i].c<k||a[i].s*k>mx)break;
			//cout<<i<<" "<<k<<'\n';
			int x=mp[a[i].s*k];
			if(x){
				a[x].c+=a[i].c/k;
				a[i].c%=k;
				break;
			}
		}
		//cout<<i<<" "<<a[i].s<<" "<<a[i].c<<'\n';
		if(a[i].c<=1){
			ans+=a[i].c;
			continue;
		}
		for(int j(46);j>=0;--j){
			long long k(1ll<<j);
			if(a[i].c<k)continue;
			ans+=a[i].c/k;
			a[i].c%=k;
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：hellolin (赞：1)

# ABC323D Merge Slimes 题解

建议前往 [note.hellolin.cf](https://note.hellolin.cf/solutions/abc323d/) 获得更好的阅读体验！


对于两个相同的史莱姆，我们可以把它们合成一个更大的史莱姆。而更大的史莱姆在之后又可被合成，以此类推。

这个过程可以用 `std::map` 来实现，由于其键值自动排序的特性，我们 range-for 访问到的元素键值一定是递增的。同时，`std::map` 是一个 **关联式容器**，所以在插入元素时，任何迭代器都不会失效。

具体实现是，先把每个史莱姆的体积作为键值，存储他们的数量，之后遍历每个元素，如果元素中史莱姆数量 $b$ 大于等于两个，那么更大的史莱姆会出现 $\lfloor\frac{b}{2}\rfloor$ 个，同理这个史莱姆只会剩下 $b\bmod 2$ 个。

``` cpp
constexpr int N = 1e5 + 11;
int n, s, c, ans;
std::map<i64, i64> buc;
void solve() {
    std::cin >> n;
    rep(i, n) {
        std::cin >> s >> c;
        buc[s] = c;
    }
    for(auto &[a, b] : buc) {
        if(b >= 2) {
            buc[a * 2] += b / 2;
            ans += b % 2;
        } else {
            ans += b;
        }
    }
    std::cout << ans << '\n';
}
```

---

## 作者：Halberd_Cease (赞：0)

题意：$N$ 种史莱姆，第 $i$ 种大小为 $S_i$，有 $C_i$ 个。$2$ 个大小为 $X$ 的史莱姆可以合成一个大小为 $2X$ 的史莱姆，问在若干次合并之后最少可以剩下多少史莱姆。

---

思路就是循环取最小的史莱姆，因为小的史莱姆只能合成大的史莱姆，所以就不会出现后面的还可以和前面的合并的情况。

取出当前最小史莱姆合并，如果当前大小的数量是奇数就答案加上 $1$，然后将大小乘上 $2$ 的史莱姆个数加上当前史莱姆个数除以 $2$。

这道题有在实现的方式上比较有趣，这里会给出 3 种实现。

1. set + map 版

使用 set 记录当前所有的史莱姆大小，然后用 map 将大小和数量连起来（当时脑子抽了没想到 map 可以按键值排序还傻逼地用 set 排一遍）。

每一次从头取 set 中的元素，然后用 map 获取当前大小史莱姆的数量，将合成后的史莱姆大小加入 set，数量加入 map（注意要用 `+=`，不要直接赋值）。

这个东西实现不好会超时一点，set 在删除最前面的元素时要删指针不要删数。

[code](https://atcoder.jp/contests/abc323/submissions/46362553)

2. set 版

用结构体存储大小和数量，重载运算符按大小排序。

每一次从头取出大小和数量，操作后查找 set 中有没有 $2$ 倍当前大小的元素，有的话取出，加上合成的过后再放回。

[code](https://atcoder.jp/contests/abc323/submissions/46325109)

3. map 版

将 set+map 版改成只有 map，由于 map 自动按键值从小到大排序，所以可以代替 set 的操作。

[code](https://atcoder.jp/contests/abc323/submissions/46362750)

还有一种思路，就是把大的史莱姆往小了砍，砍成大小为奇数后就加进一个集合里面，最后统计就可以了。

---


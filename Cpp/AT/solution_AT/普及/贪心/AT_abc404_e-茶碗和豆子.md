# 茶碗和豆子

## 题目描述

你有 $N$ 个茶碗，它们排成一排，从左往右依次编号 $0,1,\cdots,N-1$。

对于 $1$ 号碗和它右边的碗，$i$ 号碗上面写有一个数字 $C_i$，里面装有 $A_i$ 颗豆子；$0$ 号碗上面没有数字，碗里没有豆子。

你将执行以下操作若干次：
- 选择一个带有数字的、装有豆子的碗 $i$，拿走其中的一部分豆子（可以全拿）；
- 将你拿出的豆子任意放入 $i-C_i,i-C_i+1,\cdots,i-1$ 号碗中，你放入的豆子数总和要等于你从 $i$ 号碗中拿出的豆子数。

请你求出让所有豆子都被放入 $0$ 号碗的最小操作次数。

## 说明/提示

**样例 1 解释**

以下是一种可能的操作序列：
- 从 $4$ 号碗里拿出 $1$ 颗豆子，将其放入 $3$ 号碗；
- 从 $3$ 号碗里拿出 $1$ 颗豆子，将其放入 $1$ 号碗；
- 从 $1$ 号碗里拿出 $2$ 颗豆子，将其放入 $0$ 号碗。

花费 $3$ 次操作完成了题目的要求。可以证明这是可能的最小操作次数。

**样例 2 解释**

以下是一种可能的操作序列：
- 从 $5$ 号碗里拿出 $1$ 颗豆子，将其放入 $4$ 号碗；
- 从 $4$ 号碗里拿出 $2$ 颗豆子，$1$ 颗放入 $1$ 号碗，$1$ 颗放入 $2$ 号碗；
- 从 $1$ 号碗里拿出 $2$ 颗豆子，将其放入 $0$ 号碗；
- 从 $2$ 号碗里拿出 $2$ 颗豆子，将其放入 $0$ 号碗。

花费 $4$ 次操作完成了题目的要求。可以证明这是可能的最小操作次数。

By chenxi2009

## 样例 #1

### 输入

```
5
1 1 2 1
1 0 0 1```

### 输出

```
3```

## 样例 #2

### 输入

```
6
1 2 1 3 1
1 1 0 1 1```

### 输出

```
4```

## 样例 #3

### 输入

```
16
1 1 1 2 5 1 1 3 4 1 4 3 1 1 2
1 0 0 0 1 0 0 1 1 0 0 0 0 0 1```

### 输出

```
7```

# 题解

## 作者：Maureen0124 (赞：2)

## 题意
给你 $n$ 个碗，编号为 $0,1,...,n-1$。每个碗中最开始有 $A[i] (0 \le A[i] \le 1)$ 颗豆子，每个碗上还写有一个数字 $C[i]$，表示对第 $i$ 个碗操作，第 $i$ 个碗中的豆子最远可以移到第 $i - C[i]$ 个碗中。求把所有豆子都移到第 $0$ 个碗的最小操作次数。
## 思路
这种题首先考虑 dp 思想。

注意到需要最优策略，所以每次移豆子都只有两个选择：

- 在可行的范围里，移到最远的有豆子的碗中。
- 若可行的范围里没有其它碗有豆子，那么移到下一步可以移的最远的碗中。

下面来证明为什么这么移豆子是最优的：

先看第一个选择，我们设最远的有豆子的碗叫 $A$，$A$ 移到第 $0$ 个碗的最小操作次数为 $a$，当前的碗叫做 $now$，$now$ 移到第 $0$ 个碗的最小操作次数为 $b (b \ge 1)$。则有 $a + b \ge a + 1$，而将当前 $now$ 中的豆子移到 $A$ 中的操作数为 $1$，因此第一个选择一定最优。

再来看第二个选择，这句话有点绕。实现起来其实就是循环一遍 $now$ 可以移动的范围，假设循环到了第 $i$ 个碗，当 $i - C[i]$ 最小时，$now$ 移动到第 $i$ 个碗。

那如何证明移到其它碗 $j$ 不会比移到碗 $i$ 更优呢？先想想碗 $j$ 怎么才能比第 $i$ 个碗更优。只有移到碗 $j$ 后能在 $j$ 的可行范围中找到比 $i$ 的可行范围中移动更远的碗才行，即找到一个 $j - C[j] < i - C[i]$。但这样的碗是找不到的，因为我们确保了 $i - C[i]$ 最小。

综上，这样的选择策略一定是最优的。

最后代码就很好写了，非常短。

## 代码

```cpp
int n, C[N], A[N], res;

int dp(int x){
    int minx = 1e9, id;
    for(int i = x - C[x]; i < x; i++){
        if(A[i]) return 1;  //第一种选择
        if(minx > i - C[i]) minx = i - C[i], id = i;
    }
    return dp(id) + 1;  //移动到第id个碗（不就是dp转移吗！）
}

int main(){
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n, A[0] = 1; //记得要初始化A[0]！！！
    for(int i = 1; i < n; i++) cin >> C[i];
    for(int i = 1; i < n && cin >> A[i]; i++)
        if(A[i]) res += dp(i);
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：dongzirui0817 (赞：2)

## 思路

先浅浅地证些结论：

- **定理 $1$**：在分配时，最优方案一定只分给一个碗。

因为分过的所有不是 $0$ 号的碗，之后还要继续分配。  
所以相比分配多个，还不如只分配一个。

- **定理 $2$**：对于每一个满足 $1 \le i < n$ 的 $i$，如果 $\sum _ {j = i - c_i} ^ {i - 1} > 0$，那么全部分配给一个本来就有球的碗最优。

因为本来就有豆子的碗，无论再往里边放多少，它之后也要去分配；而本来为空的碗往里边放，之后还要花费额外操作去分配。

- **定理 $3$**：对于每一个满足 $1 \le i < n$ 的 $i$，如果 $\sum _ {j = i - c_i} ^ {i - 1} = 0$，将其分配给满足 $i - c_i \le j < i$ 且能使 $j - c_j$ 最小的碗最优。

因为这个碗能分配到的碗皆空，所以肯定希望分配完后，能分配到更小编号的碗，这样才能更快接触到下一个非空的碗，以减少操作数。

## 实现

考虑用 $b$ 数组来记录 $\sum _ {j = i - c_i} ^ {i - 1}$ 是否为 $0$，可以判断是用定理 $2$ 还是定理 $3$。  
$f$ 数组来记录定理 $3$ 时分给哪一个碗最优。

这两个 $O(n ^ 2)$ 处理即可。之后从编号大的碗 $i$ 开始看，如果有豆子，答案加 $1$。如果要执行定理 $3$，就把豆子传给 $f_i$，否则不做操作。

其他细节详见代码：[Submission](https://atcoder.jp/contests/abc404/submissions/65481795)。

---

## 作者：HasNoName (赞：1)

### 思路
考虑贪心。

对于任意一个位置 $i$，如果 $A_i$ 等于 $0$，则不用移动。

否则一定依次将这格的 $A_i$ 个一定一次性取出。

如果在 $i-C_i$ 号到 $i-1$ 号之间有一个 $A_j>0$ 的位置，则一定会再在那里划一步，移到 $A_j>0$ 的任意一格即可。

如果没有这样的格，则考虑 $j-C_j$ 最小的即可。因为这样的话 $A_k>0$ 的可能性更大。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int a[N],c[N];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,cnt=0;
	cin>>n;
	n--;
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=n;i>=1;i--)
	{
		if(!a[i])continue;
		cnt++;
		if(i-c[i]==0)continue;
		bool flag=0;
		for(int j=i-1;j>=i-c[i];j--)
		{
			if(a[j])
			{
				a[j]+=a[i];
				flag=1;
				break;
			}
		}
		if(!flag)
		{
			int mn=1e9,mni=i-c[i];
			for(int j=i-1;j>=i-c[i];j--)
			{
				if(j-c[j]<mn)
				{
					mn=j-c[j];
					mni=j;
				}
			}
			a[mni]+=a[i];
		}
	}
	cout<<cnt<<'\n';
	return 0;
}
```

---

## 作者：star_field (赞：1)

## 题意
有 $N$ 个碗（编号从 $0$ 到 $N-1$），对于每个碗 $i$（$1\le i\le N-1$），碗上有一个整数 $C_i$，当中有 $A_i$ 粒豆子，$0$ 号碗上没有整数，最初没有豆子。你可以进行任意次操作，每次操作可以从 $i$（$1\le i\le N-1$）号碗中取一颗或多颗豆子，你需要将这些豆子放在 $i-C_i,i-C_i+1,\cdots,i-1$ 号碗中，每个碗放任意颗。问将所有豆子**全部**放进 $0$ 号碗中的最小操作次数。
## 思路
设 $f_i$ 为将 $i,i+1,\cdots,N-1$ 号碗中的豆子全转移到 $i$ 号碗中需要的步数，然后我们就可以从 $N-1$ 到 $0$ 进行 DP。

首先将 $f$ 数组初始化为一个极大数（因为后面要进行取 $\min$ 操作），然后找到最后一个非 $0$ 的 $A_i$，将 $f_i,f_{i+1},\cdots,f_{N-1}$ 设为 $0$（因为后面没有豆子）。

观察可得，$f_i$ 可以等于 $f_{i+j}+1$（$1\le j\le C_i$），所以我们对于所有方案取最小值即可。

状态转移方程：$f_j=\max\{f_j,f_i+1\}$（$j$ 从 $i-1$ 到 $\max\{0,i-C_i\}$，因为 $i$ 也是倒序的）。

注意当 $A_j=0$ 时，后面的碗中的豆子可能不会转移出去，所以 $A_j=0$ 时我们需要 `break;`。

## [code](https://atcoder.jp/contests/abc404/submissions/65586115)

---

## 作者：Jerry20231029 (赞：1)

## 题目大意

有 $N$ 个碗排成一行，编号为 $0,1,2,\dots,N-1$，每个碗里有一些豆子，碗上还写有一个数字 $C_i$。

$0$ 号碗上一开始没有豆子，上面也没有数字。

然后进行一些操作，每次操作，你可以：

1. 选择一个碗 $i$（不能是碗 $0$）。
2. 将碗中的一些豆子随意分配到碗 $i-C_i,i-C_i+1,\dots,i-1$ 中。

求至少需要几次操作才能将所有豆子放入碗 $0$ 中。

## 思路

我们发现每次操作时会把豆子都放到一个碗里，因为分开放没意义。

而且我们应尽量把豆子放到本身有豆子的碗里，这样就可以节省操作次数。

但是贪心不好做，于是考虑 DP。

定义 $dp_i$ 为把 $i$ 号位置上的豆子放到 $0$ 号碗里至少要几次。

初始时：$dp_0 = 0,dp_i = \infty$。

转态转移：

- 若第 $i-C_i$ 到 $i-1$ 有一个碗不为空，则 $dp_i = 1$。
- 否则 $dp_i = \min\{dp_{i-C_i},dp_{i-C_i+1},\dots,dp_{i-1}\}+1$。

所求结果为 $\displaystyle\sum_{i=1}^{N-1} dp_i$（若 $i$ 号碗里有豆子）。

## 代码

[AC 记录](https://atcoder.jp/contests/abc404/submissions/65529053)

```cpp
#include<iostream>
#include<cstring>
using namespace std;

int a[2100],c[2100],dp[2100];

int main(){
	int n;
	cin>>n;
	memset(dp,0x7f,sizeof dp);
	for(int i = 1; i < n; i++){
		cin>>c[i];
	}
	for(int i = 1; i < n; i++){
		cin>>a[i];
	}
	dp[0] = 0;
	for(int i = 1; i < n; i++){
		for(int j = i-c[i]; j < i; j++){
			dp[i] = min(dp[i],a[j] ? 1 : dp[j]+1);
		}
	}
	int s = 0;
	for(int i = 1; i < n; i++){
		if(a[i]){
			s += dp[i];
		}
	}
	cout<<s;
	return 0;
}
```

---

## 作者：Double_Light (赞：0)

首先发现如果一个碗里有一些豆子，最优的方案一定是把它们一次性都放到前面的同一个碗（前面的碗显然存在至少一个最优的碗）里。这样代价只有 $1$ 次操作。

顺着这个思路下去，假设一个碗里现在有豆子，前面一个能一次放入的碗里也有豆子，那么就可以把这个碗的豆子全部放入那个有豆子的碗中，这样这些豆子只需要跟着前面的豆子一起转移，总共只需要单独转移 $1$ 次。

进一步地，我们发现每一个豆子的最优情况都是尽可能花费少的操作数到另一个有豆子的碗里跟着那个碗里的豆子一起转移。

于是考虑记录每一个有豆子的碗最快多少步就可以到达前面的某一个有豆子的碗或者 $0$ 号碗，设这个值为 $b_i$，那么答案就是所有有豆子的碗 $i$ 的 $b_i$ 之和。

给个求 $b_i$ 的代码。

```cpp
for(int i=1;i<=n;i++){
  lst[i]=1e9;
  for(int j=i-c[i];j<=i-1;j++){
  	if(a[j])lst[i]=1;
  	else lst[i]=min(lst[i],lst[j]+1);
	}
}
``

---

## 作者：thedyingkai (赞：0)

### 思路
- 这道题可以不 DP，考虑贪心。
- 题目的意思很简单，对于一排 $N$ 个碗，每次操作都可以选择一个碗 $i$，把该碗的豆子自由分配到该碗和前面紧挨的 $c_i$ 个碗中，求把所有豆子移到最左边需要的最小操作次数。
- 对于 $a_i=0$ 的碗，即空碗，我们先不进行操作。而对于 $a_i \neq 0$ 的碗，每个碗至少要操作一次来移除其中的豆子，我们创建一个自定义的优先队列存储该碗豆子能分给的碗的区间左右端点，以右端点降序排列。
- 检查区间 $[l,r]$ 是否已经被部分覆盖，对于每个无法直接访问的区间，找到最优的碗进行操作，使区间覆盖范围最远，操作后标记该碗，并增加新的区间到优先队列中，重复上述过程直到所有区间都可以被访问。
> ~说不是 DP，其实有 DP 的味道在的。~
### AC code
```cpp
#define pii pair<int,int>
void solve(){
    int n;
    cin>>n;
    vector<int> c(n),a(n);
    rep(i,1,n-1) cin>>c[i];
    rep(i,1,n-1) cin>>a[i];
    int ans=0;
    set<int> vis={0};
    rep(i,1,n-1) if(a[i]){
        ans++;
        vis.insert(i);
    }
    priority_queue<pii,vector<pii>,function<bool(pii,pii)>> pq([](pii x,pii y){return x.second>y.second;});
    rep(i,1,n-1) if(a[i]){
        int l=i-c[i];
        if(l>0) pq.push({l,i-1});
    }
    while(!pq.empty()){
        auto [l,r]=pq.top();
        pq.pop();
        auto it=vis.lower_bound(l);
        if(it!=vis.end()&&*it<=r);
        else{
            int res=l;
            int Min=l-c[l];
            rep(i,l+1,r){
                int cur=i-c[i];
                if(cur<Min){
                    res=i;
                    Min=cur;
                }
            }
            ans++;
            vis.insert(res);
            if(Min>0) pq.push({Min,res-1});
        }
    }
    cout<<ans<<endl;
}
```

---

## 作者：_Weslie_ (赞：0)

感觉最近 ABC 能力下降了，连绿都做不出来了（指 G）。

## Solution AT_abc404_e

### Idea

我们设 $dp_i$ 为位置 $i$ 的豆子转移到前面**任意一个**有豆子的碗所需的最少步骤。

因为一次最多移动 $a_i$ 步，所以 $dp_i=\min\limits_{j=i-a_i}^{i-1}\{f(j)\}$，其中如果第 $j$ 个碗有豆子则 $f(j)=0$，否则 $f(j)=dp_j$。

最后答案是所有有豆子的碗的 $dp$ 值的和。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int a[N],n,b[N],dp[N];
int main(){
    scanf("%d",&n);n--;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&b[i]);
    }
    b[0]=1;//把 0 点看成有豆子，方便转移
    for(int i=1;i<=n;i++){
        dp[i]=0x3f3f3f3f;
        for(int j=max(i-a[i],0);j<i;j++){
            if(b[j]==0)dp[i]=min(dp[i],dp[j]+1);
            else dp[i]=1;
        }
    }int ans=0;
    for(int i=1;i<=n;i++){
        if(b[i])ans+=dp[i];
    }
    printf("%d",ans);
}
```

### Evidence the conclusion easily

有些人可能觉得很疑惑：为什么要移到前面任意一个有豆子的碗呢？

因为假设我们不合并，一步一步操作。假如现在 $i$ 号碗里有来自两个不同碗的豆子，假如我们不合并，就需要从 $i$ 移动第一个碗的豆子，再移动另外一个。显然合并要更优。

---

## 作者：yuhong056 (赞：0)

# 题解：AT_abc404_e [ABC404E] Bowls and Beans
## 题意
有 $N$ 个碗，编号从 $0$ 到 $n - 1$。

每次可以将一个碗 $i$ 中的豆子分配到 $[i - c_i, i)$ 中。

求最小将豆子全部移到碗 $0$ 的操作次数。
## 思路
贪心。

首先有几个贪心性质：
1. 从后往前分配豆子。
2. 豆子最多分到一个碗中。
3. 如果可分范围内的碗有豆子，优先分有豆子的碗。
4. 否则，优先分到 $j - c_j$ 最小的碗中。
### 证明
1. 豆子只能往前分，所以优先分后面就能与前面一起分。
2. 明显，分豆子后的多个碗，之后还要继续分配。分配多个必然操作次数更多。
3. 明显，分到有豆子的碗中必然比分到没豆子的碗中优。
4. 无论怎么分，必然会增加一次操作，所以让它尽早往前分。

最终时间复杂度：$O(n ^ 2)$，足以通过此题。
## Code
```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 2e3 + 23;

int n;
bool hv[MAXN];
int c[MAXN];

int main() {
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n;
	for(int i = 1; i < n; i++) {
		cin >> c[i];
	}
	for(int i = 1; i < n; i++) {
		cin >> hv[i];
	}
	int ans = 0;
	for(int i = n - 1; i; i--) {
		if(hv[i]){
			ans++;
			bool fg = 1;
			int id = -1;
			for(int j = i - c[i]; j < i; j++) {
				if(hv[j]) {
					fg = 0;
					break;
				}
				if(id == -1 || j - c[j] < id - c[id]) {
					id = j;
				}
			}
			if(fg)hv[id] = 1;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：wwwidk1234 (赞：0)

## 题目

有 $N$ 个编号为 $0$ 到 $N-1$ 的碗排成一排。初始时，碗 $0$ 为空，碗 $i$（$1 \leq i \leq N-1$）有 $A_i$ 颗豆子，并标有数字 $C_i$。

每次操作，你可以：

1. 任选一个碗 $i$（$1 \leq i \leq N-1$）
2. 取出至少一颗豆子
3. 将这些豆子分配到碗 $i-C_i$ 到 $i-1$（可任意分配）

求将所有豆子都移到碗 $0$ 的最少操作次数。

## 思路

注：下文为了方便表示，令 $n=N-1$。

一道很好的 DP 题。设 $dp_i$ 为将 $i \sim n$ 中的所有豆子转运到 $i$ 的最小操作步骤。然后可以就可以从 $n$ 开始倒着做 DP。

初始时将 $dp$ 全部元素设置为无穷大。首先从 $n$ 开始找一个起点 $n ^\prime$（即找最后一个有豆子的碗），将 $dp_{n ^\prime} \sim dp_{n}$ 都设置为 $0$（没有豆子需要转移）。

由题意知，第 $i$ 个碗的豆子可以转移到第 $j \left(\max \left\{0,i-c_i \right\} \le j \le i-1 \right)$ 个碗中，那么将第 $j \sim n$ 个碗中所有豆子都转移到第 $j$ 个碗的操作次数（$dp_j$）可以是转移到第 $i$ 个碗的次数再加上一次（$dp_i+1$）。在所有方案中取个最小值即可。

注意：在第 $j$ 个碗原本就有豆子的情况下，如果在找到第 $j$ 个碗后再往前找最小值，那么有可能第 $j$ 个碗的豆子就不会被转移出去（后面的豆子可以绕过第 $j$ 个碗转移到前面去），所以在枚举 $j$ 时若 $a_j \ne 0$ 就要退出循环（即代码中的 `if(a[i]!=0) break;`）。

将所有豆子全部转移到第 $0$ 个碗的最小操作步数 $dp_0$ 即为最终答案。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
constexpr int N=2007;
int a[N],c[N],dp[N],n;
int main()
{
    //freopen("neuvillette.in","r",stdin);
    //freopen("neuvillette.out","w",stdout);
    cin>>n;
    n--;
    for(int i=1;i<=n;i++) cin>>c[i];
    for(int i=1;i<=n;i++) cin>>a[i];
    memset(dp,0x3f,sizeof dp);
    int i;
    for(i=n;i>=0;i--)
    {
        dp[i]=0;
        if(a[i]!=0) break;
    }
    i++;
    for(;i>=0;i--)
    {
        for(int j=i-1;j>=max(0,i-c[i]);j--)
        {
            dp[j]=min(dp[j],dp[i]+1);
            if(a[j]) break; //防止这个碗的豆子没有转移出去
        }
    }
    // for(int i=0;i<=n;i++) cerr<<dp[i]<<' ';
    cout<<dp[0];
    return 0;
}
```

---


# [AGC033B] LRUD Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc033/tasks/agc033_b

縦 $ H $ 行、横 $ W $ 列の長方形上のマス目があります。上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,j) $ と表します。 このマス目の上には一つの駒が置いてあり、最初はマス $ (s_r,s_c) $ に置いてあります。

高橋君と青木君はそれぞれ長さ $ N $ の文字列を用意してゲームをすることにしました。 高橋君は文字列 $ S $ を、青木君は文字列 $ T $ を用意し、$ S $ と $ T $ はともに `L`, `R`, `U`, `D` の $ 4 $ 種類の文字からなります。

ゲームは $ N $ 回のステップからなります。$ i $ 回目のステップは以下のように進行します。

- まず高橋君が操作を行う。この操作では、駒を $ S_i $ の方向に動かす、もしくは、駒を動かさないかのいずれかを行う。
- 次に青木君が操作を行う。この操作では、駒を $ T_i $ の方向に動かす、もしくは、駒を動かさないかのいずれかを行う。

ここで、駒を `L`, `R`, `U`, `D` の方向に動かすとは、駒がマス $ (r,c) $ にあったとき、 それぞれマス $ (r,c-1) $, $ (r,c+1) $, $ (r-1,c) $, $ (r+1,c) $ に動かす操作を指します。 ただし、その座標に対応するマスが存在しない場合は、駒をマス目から取り除く操作を指すことにします。 この操作が行われた場合、$ N $ 回のステップが終わっていなくても、その時点でゲームは終了します。

高橋君は $ N $ 回のステップのいずれかのステップで駒をマス目から取り除きたいです。 一方で、青木君は最終的に駒がマス目上に残ったまま、$ N $ 回のステップを終えたいです。 二人が最適に行動したとき、ゲームが終了した時点で駒がマス目上に残っているかどうかを判定してください。

## 说明/提示

### 制約

- $ 2\ ≦\ H,W\ ≦\ 2\ \times\ 10^5 $
- $ 2\ ≦\ N\ ≦\ 2\ \times\ 10^5 $
- $ 1\ ≦\ s_r\ ≦\ H $
- $ 1\ ≦\ s_c\ ≦\ W $
- $ |S|=|T|=N $
- $ S $ と $ T $ は `L`, `R`, `U`, `D` の $ 4 $ 種類の文字からなる。

### Sample Explanation 1

ゲームは例えば以下のように進行します。 - 高橋君が駒を右に動かし、駒は $ (2,3) $ に移動する。 - 青木君が駒を左に動かし、駒は $ (2,2) $ に移動する。 - 高橋君は駒を動かさず、駒の位置は $ (2,2) $ のままとなる。 - 青木君は駒を上に動かし、駒は $ (1,2) $ に移動する。 - 高橋君は駒を左に動かし、駒は $ (1,1) $ に移動する。 - 青木君は駒を動かさず、駒の位置は $ (1,1) $ のままとなる。

## 样例 #1

### 输入

```
2 3 3
2 2
RRL
LUD```

### 输出

```
YES```

## 样例 #2

### 输入

```
4 3 5
2 2
UDRRR
LLDUD```

### 输出

```
NO```

## 样例 #3

### 输入

```
5 6 11
2 1
RLDRRUDDLRL
URRDRLLDLRD```

### 输出

```
NO```

# 题解

## 作者：wind_seeker (赞：4)

~~这是一个很屑的题，因为数据很水。~~

不得不吐槽一下这道题，模拟赛我打了一个半小时这道题，结果别人有种情况没考虑还过了。

### 方法一：

可能很多人都是这么过的，考虑先手只会往一个方向上冲出去，只要后手在通过跑相反方向守住即可。这样只需要四个方向上各跑一遍就能通过这道题目。

### 方法二：

实际上我们只需要稍微把样例二改一改，就可以 hack 掉上面的方法：

```
4 3 5
2 2
UDLRR
LLDUD
```

在上述数据中，我们考虑左右方向。由于先后手都是绝顶聪明的，所以先手不可能只往一个方向上跑。在上面数据，如果在前两轮中，后手选择不动，那么先手在四五两轮往右跑即可以跑出地图。如果在前两轮中，后手选择向左跑一次，那么在第三轮先手即可以往左跑跑出地图，所以这个情况实际上是能跑出地图的。

考虑避免这种情况，我们需要把这道题目转换思路。显然后面的跑法一定会影响前面的跑法，所以我们从后面往前面跑。

分左右和前后两种互不干扰的情况考虑。以左右为例，最后的范围是 $[1,W]$。从后往前，先遇到后手，如果后手是 `R`，那么也就意味着最小范围从前面到达这个后手时可以变更小，同理，如果是 `L`，那么最大范围就可以更大。之后遇到先手，如果先手是 `R`，那么由于不能让其超过后面范围，最大范围就会缩小一，同理如果是 `L`，那么最小范围就会增大一。

这样知道跑到开头，如果过程中有出现区间长度小于 $1$，或者说起始位置不在最后的区间，那么就是可以跑出地图，否则不行。

### code
```cpp
/*********************************************************************
    作者: wind_seeker
    日期: 2023-07-06 07:58 
*********************************************************************/
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+1e3;

int H,W,n,h,w;
char s[N],t[N];
bool flag=true;

inline int read(){
	int res=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) res=(res<<3)+(res<<1)+(c^48);
	return res*f;
}

int maxn,minn,a[N],b[N];
void solve1(){
	for(int i=1;i<=n;i++){
		if(s[i]=='L') a[i]=-1;
		else if(s[i]=='R') a[i]=1;
		else a[i]=0;
		if(t[i]=='L') b[i]=-1;
		else if(t[i]=='R') b[i]=1;
		else b[i]=0;
	}
	maxn=W,minn=1;
	for(int i=n;i>=1;i--){
		if(b[i]==1) minn=max(1,minn-1);
		else if(b[i]==-1) maxn=min(W,maxn+1);
		if(a[i]==1) maxn--;
		else if(a[i]==-1) minn++;
		if(maxn<minn||maxn==0||minn==W+1) flag=false; 
	}
	if(w<minn||w>maxn) flag=false;
}
void solve2(){
	for(int i=1;i<=n;i++){
		if(s[i]=='U') a[i]=-1;
		else if(s[i]=='D') a[i]=1;
		else a[i]=0;
		if(t[i]=='U') b[i]=-1;
		else if(t[i]=='D') b[i]=1;
		else b[i]=0;
	}
	maxn=H,minn=1;
	for(int i=n;i>=1;i--){
		if(b[i]==1) minn=max(1,minn-1);
		else if(b[i]==-1) maxn=min(H,maxn+1);
		if(a[i]==1) maxn--;
		else if(a[i]==-1) minn++;
		if(maxn<minn||maxn==0||minn==H+1) flag=false;
	}
	if(h<minn||h>maxn) flag=false;
}

int main(){
	//所谓难点，这道题的难点就在于它可以不动
	//既然是要求后手获胜，那么我们就看能否干掉先手
	//不是这题目咋不是我理解的那样呢
	//okk，那么这道题的关键就在于敌驻我扰，敌退我打，敌进攻我反着来
	//显然这玩意先手是肯定往一个方向莽，那我只要看是否在其每一步都恰好通过相反拿下，但是千万别走出去
	//我太小瞧这玩意里，我纯纯大散兵，这道题只能份两类，左右和上下，因为先手不蠢
	//它每一步都有范围的
	//***
	//把问题转化一下，把L标-1，R标1，U，D标0做左右，上下同理。
	//真的有点难，后面会影响前面，所以想必要从后往前扫
	//***，根本不会
	//这**太难了
	//我感觉应该可以对了，因为这样通过范围反推，显然是非常有道理的
	freopen("B.in","r",stdin);
	freopen("B.out","w",stdout);
	H=read(),W=read(),n=read(),h=read(),w=read();
	cin>>s+1>>t+1;
	solve1();solve2();
	if(flag) puts("YES");
	else puts("NO");
	return 0;
}

```

---

## 作者：火车司机 (赞：2)

## 简要分析

首先可以发现，左右和上下是互不干扰的，所以可以分开来考虑

对于一个维度，考虑倒推保证能留下来的区间

如果最后两个维度中任意一个维度的区间不存在，或者初始位置不在这个区间中，那么就必输

## 完整代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ri register int
#define N 200005
using namespace std;
int h, w, n, u, d, l, r, x, y;
char s[N], t[N];
inline int mnn(int a, int b)
{
	return a < b ? a : b;
}
inline int mxx(int a, int b)
{
	return a > b ? a : b;
}
signed main()
{
	scanf("%lld%lld%lld%lld%lld%s%s", &h, &w, &n, &x, &y, s + 1, t + 1), d = h, r = w, l = u = 1;
	for (ri i = n; i; --i)
	{
		if (t[i] == 'U')
			d = mnn(d + 1, h);
		else if (t[i] == 'D')
			u = mxx(u - 1, 1);
		else if (t[i] == 'L')
			r = mnn(r + 1, w);
		else
			l = mxx(l - 1, 1);
		if (s[i] == 'U')
			++u;
		else if (s[i] == 'D')
			--d;
		else if (s[i] == 'L')
			++l;
		else
			--r;
		if (u > d || l > r)
		{
			puts("NO");
			return 0;
		}
	}
	if (x < u || x > d || y < l || y > r)
		puts("NO");
	else
		puts("YES");
	return 0;
}
```


---

## 作者：_Extroversion (赞：0)

此题是一个博弈游戏，所以我们从最优策略的角度分析。

------------

## 题目分析

此题不同于一般的博弈，因为双方的游戏目标不同。那我们是要分析先手还是后手呢？

作为后手，需要考虑先手后面的操作序列能造成哪些影响，不能贪心地往棋盘中间走。

```
2 5 4
2 2
URRR
RUDU
```

这组数据中，后手如果贪心走到第三列，那么先手往右走三次就能获胜；但第一回合选择不走，先手就移不出棋盘。

而先手就好考虑了，我们先给出结论 : **先手不会向两个相反方向都进行过移动。**

如果这样移动了，那么相反方向移动互相抵消，带来的移动效果不如只朝一个方向，而为了移出棋盘，朝一个方向走得越多，就越有利。因此我们枚举先手始终走哪两个方向，就能确定每一回合是否进行移动。这四种方向的选择中一定有最优策略。

在先手这样的最优操作下，后手就应尽力走与先手相反的方向，例如先手只走 U 和 R，后手就只走 D 和 L。尽量抵消先手的影响，当然，是在不走出棋盘的条件下。

### hack:

```
10000 7 10
5000 4
UUULRRRRRR
LLLDDDDDDD
```

答案应为 `NO`，这是为什么呢？

第三回合若后手往左移动，下一步先手能移出棋盘，所以在上述策略下，第三回合不能移动。因此，我们维护序列每个方向先手与后手抵消后效果的前缀和，若移动后接下来可能的效果能让先手移出棋盘，则后手不移动。

## 代码实现

枚举四个方向，按照上述的策略模拟每次移动，若有一种方向组合能移出棋盘，输出 `YES`，否则输出 `NO`。AtCoder 上的所有题记得换行。
## Code:
```
#include<cstdio>
#include<cstring>
#define N 200010
int n,m,k,x,y,xn,yn,c1[N][4],c2[N][4];//用这类变量名就不要用cmath
char s1[N],s2[N],d[]={'U','D','L','R'};
int main(){
	scanf("%d%d%d",&n,&m,&k);
	scanf("%d%d",&x,&y);
	scanf("%s%s",s1+1,s2+1);
	for(int i=1;i<=k;i++){
		for(int j=0;j<4;j++){
			c2[i][j]=c2[i-1][j];
			if(s2[i]==d[j])c2[i][j]++;//记录移动序列前缀和
			if(s1[i]==d[j^1])c2[i][j]--;
		}
	}
	xn=x,yn=y;//模拟每种方向组合的操作
	for(int i=1;i<=k;i++){
		if(s1[i]=='U')xn--;
		if(s1[i]=='L')yn--;
		if(xn<1||yn<1){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='D'&&xn+1+c2[k][1]-c2[i+1][1]<=n)xn++;//确保后面不被先手往同一方向移出
		if(s2[i]=='R'&&yn+1+c2[k][3]-c2[i+1][3]<=m)yn++;
	}
	xn=x,yn=y;
	for(int i=1;i<=k;i++){
		if(s1[i]=='D')xn++;
		if(s1[i]=='L')yn--;
		if(xn>n||yn<1){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='U'&&xn-1+c2[k][0]-c2[i+1][0]>=1)xn--;
		if(s2[i]=='R'&&yn+1+c2[k][3]-c2[i+1][3]<=m)yn++;
	}
	xn=x,yn=y;
	for(int i=1;i<=k;i++){
		if(s1[i]=='U')xn--;
		if(s1[i]=='R')yn++;
		if(xn<1||yn>m){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='D'&&xn+1+c2[k][1]-c2[i+1][1]<=n)xn++;
		if(s2[i]=='L'&&yn-1+c2[k][2]-c2[i+1][2]>=1)yn--;
	}
	xn=x,yn=y;
	for(int i=1;i<=k;i++){
		if(s1[i]=='D')xn++;
		if(s1[i]=='R')yn++;
		if(xn>n||yn>m){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='U'&&xn-1+c2[k][0]-c2[i+1][0]>=1)xn--;
		if(s2[i]=='L'&&yn-1+c2[k][2]-c2[i+1][2]>=1)yn--;
	}
	printf("YES\n");
	return 0;
}
```

---


# [ARC174B] Bought Review

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc174/tasks/arc174_b

$ T $ 個のテストケースについて、次の問題に答えてください。

グルメレビューサイトである EatCocoder では、レストランに $ 1 $ 以上 $ 5 $ 以下の整数個の星を付けてレビューすることができます。  
 最初、B料理長の経営するレストランには、星 $ i $ のレビューが $ A_i $ 件付いています。 $ (1\ \le\ i\ \le\ 5) $  
 B料理長は EatCocoder の運営に $ P_i $ 円の賄賂を渡すことで、星 $ i $ のレビューを $ 1 $ 件追加してもらえます。 $ (1\ \le\ i\ \le\ 5) $

賄賂によってレビューを全部で $ k $ 件追加したとき、最終的なレビューは合計で $ A_1+A_2+A_3+A_4+A_5+k $ 件になります。  
 B料理長はこれらのレビューの平均評価を星 $ 3 $ 以上にしたいと考えています。これを達成するために必要な賄賂の合計金額の最小値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ T\ \le\ 10^4 $
- $ 0\ \le\ A_i\ \le\ 10^8 $
- $ 1\ \le\ A_1+A_2+A_3+A_4+A_5 $
- $ 1\ \le\ P_i\ \le\ 10^8 $
 
### Sample Explanation 1

この入力には $ 6 $ 個のテストケースが含まれています。 - $ 1 $ 個目のテストケースについて、例えば以下のようにすると $ 5 $ 円の賄賂で平均評価を星 $ 3 $ 以上にでき、これが達成可能な最小値です。 - 元々星 $ 1,2,3,4,5 $ のレビューが $ 1,0,1,0,0 $ 件付いています。 - $ P_5\ =\ 5 $ 円の賄賂を渡し、星 $ 5 $ のレビューを $ 1 $ 件追加させます。 - その結果、星 $ 1,2,3,4,5 $ のレビューが $ 1,0,1,0,1 $ 件となり、これらの平均は星 $ 3 $ です。 - $ 2 $ 個目のテストケースについて、例えば以下のようにすると $ 2 $ 円の賄賂で平均評価を星 $ 3 $ 以上にでき、これが達成可能な最小値です。 - 元々星 $ 1,2,3,4,5 $ のレビューが $ 0,2,2,0,0 $ 件付いています。 - $ P_4\ \times\ 2\ =\ 2 $ 円の賄賂を渡し、星 $ 4 $ のレビューを $ 2 $ 件追加させます。 - その結果、星 $ 1,2,3,4,5 $ のレビューが $ 0,2,2,2,0 $ 件となり、これらの平均は星 $ 3 $ です。 - $ 3 $ 個目のテストケースについて、例えば以下のようにすると $ 3 $ 円の賄賂で平均評価を星 $ 3 $ 以上にでき、これが達成可能な最小値です。 - 元々星 $ 1,2,3,4,5 $ のレビューが $ 0,1,2,0,0 $ 件付いています。 - $ P_5\ =\ 3 $ 円の賄賂を渡し、星 $ 5 $ のレビューを $ 1 $ 件追加させます。 - その結果、星 $ 1,2,3,4,5 $ のレビューが $ 0,1,2,0,1 $ 件となり、これらの平均は星 $ 3.25 $ です。 - $ 4 $ 個目のテストケースについて、例えば以下のようにすると $ 2 $ 円の賄賂で平均評価を星 $ 3 $ 以上にでき、これが達成可能な最小値です。 - 元々星 $ 1,2,3,4,5 $ のレビューが $ 1,1,1,0,0 $ 件付いています。 - $ P_4\ =\ 1 $ 円の賄賂を渡し、星 $ 4 $ のレビューを $ 1 $ 件追加させます。 - $ P_5\ =\ 1 $ 円の賄賂を渡し、星 $ 5 $ のレビューを $ 1 $ 件追加させます。 - その結果、星 $ 1,2,3,4,5 $ のレビューが $ 1,1,1,1,1 $ 件となり、これらの平均は星 $ 3 $ です。 - $ 5 $ 個目のテストケースについて、例えば以下のようにすると $ 0 $ 円の賄賂で平均評価を星 $ 3 $ 以上にでき、これが達成可能な最小値です。 - 元々星 $ 1,2,3,4,5 $ のレビューが $ 0,0,0,0,1 $ 件付いています。 - これらの平均は星 $ 5 $ でありこれは既に $ 3 $ 以上であるため、賄賂を全く渡しません。 - $ 6 $ 個目のテストケースについて、答えが $ 32 $bit 符号付き整数に収まらないこともあります。

## 样例 #1

### 输入

```
6
1 0 1 0 0
1 2 3 4 5
0 2 2 0 0
1 1 1 1 5
0 1 2 0 0
1 1 1 5 3
1 1 1 0 0
1 1 1 1 1
0 0 0 0 1
1 1 1 1 1
100000000 100000000 100000000 0 0
100000000 100000000 100000000 100000000 100000000```

### 输出

```
5
2
3
2
0
15000000000000000```

# 题解

## 作者：bishenke_2008 (赞：4)

## AT_arc174_b [[ARC174B] Bought Review](https://www.luogu.com.cn/problem/AT_arc174_b)  题解 
### $Update$ $on$ $2024.9.2$：解决了文章版面杂乱问题，球球管理员大大放行！
### 0.开头废话
> 本 ~~蒟蒻~~ ~~废柴~~ 第一篇题解，   
> 若题解中存在错瘪字，错误思路、错误代码可以在评论区指出，   
> 方便神犇们理解，同时便于我修改。  
>~~码风什么的就不要在意啦！~~
### 1.题目翻译
有 $T$ 次询问，在每次询问中：  
用 $A _ {i}$ 表示初始有 $A _ {i}$ 条 $i$ 星好评，   
给定 $P _ {i}$ 表示可以用 $P _ {i}$ 元买一条 $i$ 星好评，   
求至少花多少元使得所有评价的平均评分至少为 $3$。

#### 输入格式
> $T$     
> $Case _ {1}$ $Case _ {2}$ $\cdots$  $Case _ {T}$   
> 其中各组数据 $Case _ {i}$ 以以下形式给出：  
> $A _ {1}$ $A _ {2}$ $A _ {3}$ $A _ {4}$ $A _ {5}$  
> $P _ {1}$ $P _ {2}$ $P _ {3}$ $P _ {4}$ $P _ {5}$
#### 输出格式
> 整体输出 $T$ 行，  
> 在第 $i$ 行中，将第 $i$ 组输入数据的答案以一个正整数输出。
### 2.题目分析     
根据题目分析可知：
1. 我们可以发现题面中有至少一词，不难想AC这道题的主要思想就是**贪心**。
2. 若我们选择买一星、二星、三星好评，反而会使平均评分减少，所以我们**不能购买一星、二星、三星好评**。

我们不妨设未知数如下表：

 |  |一星好评⭐ |二星好评⭐⭐|三星好评⭐⭐⭐|四星好评⭐⭐⭐⭐|五星好评⭐⭐⭐⭐⭐ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $A _ {i}$ | $a$ | $b$ | $c$ | $d$ | $e$ |
| $P _ {i}$ | \ | \ | \ | $p$ | $q$ |
|**购买评论数**| \ | \ | \ | $x$ | $y$ |

则可列出不等式如下：

$$
	\frac{a+2b+3c+4d+5e+4x+5y}{a+b+c+d+e+x+y}\ge3
$$
对不等式进行化简：
$$  
\begin{aligned}
   \frac{a+2b+3c+4d+5e+4x+5y}{a+b+c+d+e+x+y}&\ge3 \\
	 a+2b+3c+4d+5e+4x+5y&\ge3(a+b+c+d+e+x+y)	\\
    x+2y&\ge2a+b-d-2e
\end{aligned}

$$
由于 $a,b,d,e$ 均为输入给出的已知数，   
我们可以定义变量 ${least}$ 为**至少需要的星数**，易得：
$$
	x+2y\ge{least}（least = 2a + b - d - 2e）
   
$$  
我们可以这么想：　　　
- 因为四星好评比三星好评多一颗星，五星好评比三星好评多两颗星，则**两个四星好评的收益等于一个五星好评的收益**。

也可以这么想：   　
- 我们所设的 ${least}$ 是基于平均星数 $3$ 所多出来的那一部分星数，因此当我们求购买四星、五星好评的个数时，也应用四星、五星好评相较于平均星数 $3$ **多出来的那一部分星数**来进行**贪心**。

至此**贪心**的方法也就显而易见了：

1.  第一种情况 —— 把全部的钱梭哈在**四星好评**上。（当且仅当 $2p\le q$ 时）
2.  第二种情况 —— 把全部的钱梭哈在**五星好评**上。（当且仅当 ${least}$ 为偶数时）
3. 第三种情况 —— **先买最多偶数个五星好评**，再比较四星好评和五星好评各需要的钱，**哪个需要的钱少加哪个**。（当且仅当 ${least}$ 为奇数时）


### 3.代码
```c
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N=15;

int t;
int a[N],p[N];

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
	
    cin>>t;
	
    while(t--){
    	for(int i=1;i<=5;i++) cin>>a[i];
    	for(int i=1;i<=5;i++) cin>>p[i];

    	int least=2*a[1]+a[2]-a[4]-2*a[5];	//least为至少需要的"i星好评"星数 
    	
		if(least<=0){	//当前平均星数已达到3,不需要再花钱买好评 
            cout<<0<<'\n';
            continue;
        }
        
    	int ans;
    	if(p[4]*2<=p[5])	
			ans=least*p[4];
			//第一种情况:2个四星好评所需的钱比1个五星好评所需的钱少
			 
    	else if(least%2==0)	
			ans=least*p[5]/2;
    	    //第二种情况:所需的最少星数least为偶数	
    	    
    	else if(least%2==1){
    		if(p[4]<=p[5])
    			ans=least/2*p[5]+p[4];
    		if(p[4]>p[5])
				ans=(least/2+1)*p[5];
			/*
			ans=(least/2+1)*p[5];
			ans=min(ans,least/2*p[5]+p[4]);
			*/ 
        	//第三种情况:所需的最少星数least为奇数
    	}
    	
		cout<<ans<<'\n';
	}
	return 0;
}
```
### 4.结尾废话  
>以上就是本蒟蒻对此题的分析，    
>本蒟蒻的讲解或许不是很清楚，   
>还不太理解的神犇们可以看看其他神犇们的题解。   
>希望本篇题解能对各位有所帮助！   
![](https://cdn.luogu.com.cn/upload/usericon/54465.png)

---

## 作者：whrwlx (赞：3)

## 题目翻译

针对 $T$ 个测试用例解决以下问题：

在美食评论网站 EatCocoder 上，你可以评论餐厅的星级(从 $1$ 到 $5$ 的整数)。

最初，由厨师长 B 管理的餐厅有 $A_i$ 条 $i$ 星级评价。（$1 ≤ i ≤ 5$）

厨师可以向 EatCocoder 管理部门~~行贿~~提供 $P_i$ 日元，以获得一次**额外**的 $i$ 星评论。（$1 ≤ i ≤ 5$）

通过贿赂添加总共 $k$ 条评论后，将有 $A_1+A_2+A_3+A_4+A_5+k$ 条评论。

厨师 B 希望这些评论的平均评分**至少为三星**。

请求出实现这一目标所需的**最低**~~贿赂~~消费总额。

## 算法

### 法一（暴力）

~~不会写暴力了~~，呜呜呜…

### 法二（正解）

首先，如果平均分就 $≥3$，显然答案为 $0$。

然后—我们可以发现一个优化：

>我们每增加一条评论，那么应新增的星数就加 $3$，
>那么为了补回星数，我们只能选择比 $3$ 大的，即 $4$ 和 $5$。

我们可以贪心：

- 全买 $4$ 分的。
- 买 $1$ 个 $4$ 分的和一些 $5$ 分的。
- 全买 $5$ 分的。

```c++
#include<bits/stdc++.h>
#define int long long
#define fd(i,a,b) for(int i=a;i<=b;i=-~i)
using namespace std;
int n,c,T,a[300100],f[2500],p[300100],ans=-1,cnt,sum;
signed main()
{
	ios::sync_with_stdio(0);
	cin>>T;
	while(T--)
	{
   		cnt=sum=0;
   		ans=1e18;
		fd(i,1,5) cin>>a[i],cnt+=a[i]*3,sum+=a[i]*i;
		fd(i,1,5) cin>>p[i];
		if(sum>=cnt)//平均分≥3
		{
			cout<<0<<endl;
			continue;
		}
		if((cnt-sum)%2)
		ans=min(ans,min(((cnt-sum)/2+1)*p[5],((cnt-sum)/2)*p[5]+p[4]));
		//买1个4分的和一些5分的/全买5分的
		if((cnt-sum)%2==0)
		ans=min(ans,((cnt-sum)/2)*p[5]);
		//全买5分的
		ans=min(ans,(cnt-sum)*p[4]);
		//全买4分的
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Double_Light (赞：1)

如果本身已经满足平均分 $\geq 3$ 的条件，那么显然并不需要贿赂，答案为 $0$。

如果贿赂一条 $1\sim 3$ 分的评论，显然是没有必要的。因为只增加这三种的评分肯定不能使平均分提升到 $3$ 以上。如果同时贿赂一条高分评论和低分评论，还不如只贿赂高分的评论。

所以把范围缩小到 $4$ 分或 $5$ 分的评论上。

以 $3$ 分的平均分为基准，$1$ 分的评论比平均少贡献了 $2$ 分，$2$ 分评论少贡献 $1$ 分，$4$ 分评论多贡献 $1$ 分，$5$ 分评论多贡献 $2$ 分。以此我们就可以算出目前的分数比满足要求的最低分数低了多少分，设这个差值为 $k$。

秉持贪心的策略，进行以下几种分类讨论：

- 全部贿赂 $4$ 分评论，花费 $k\times P_4$ 元。

- 全部贿赂 $5$ 分评论，花费 $\lceil\frac{k}{2}\rceil\times P_4$ 元。

- 当 $k$ 为奇数时，贿赂一条 $4$ 分评论，剩下全部贿赂 $5$ 分评论，花费 $(\lfloor\frac{k}{2}\rfloor\times P_4+P_5)$ 元。

最后取最大值即可。

代码如下：

```cpp
#include<iostream>
#define int long long
using namespace std;
int t,sum,k,ans;
int a[10],b[10],n=5;
signed main(){
	cin>>t;
	while(t--){
		ans=1e18;
		sum=0;k=0;
		for(int i=1;i<=n;i++)cin>>a[i],sum+=a[i],k+=a[i]*i;//此处k表示总星数
		for(int i=1;i<=n;i++)cin>>b[i];
		if(k/sum>=3){
			cout<<0<<endl;
			continue;
		}
		k=a[1]*2+a[2]-a[4]-a[5]*2;//这里k表示差的星数
      //下面是分类讨论
		ans=min(ans,k*b[4]);
		if(k%2==0)ans=min(ans,k/2*b[5]);
		if(k%2==1){
			ans=min(ans,(k/2+1)*b[5]);
			ans=min(ans,k/2*b[5]+b[4]); 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Starrykiller (赞：1)

首先一开始就合法的情况可以直接判掉。

注意到对答案有用的实际上只有 $4,5$。证明：因为现在这堆数的平均值已经小于 $3$ 了，必然只能加上大于 $3$ 的数才能让平均值不小于 $3$。

设当前一共有 $n$ 个评价，星数为 $sum$。对于只使用 $v$（$v\in \{4,5\}$）的情况，无非就是二分出最小的正整数 $k$，使得 $\displaystyle \frac{sum+k\cdot v}{n+k}\ge 3$，二分是容易的。

但是你发现直接这么做会 WA。不难想到，最优的情况可能是用很多 $4$，但是最后用一个 $5$。然后就可以过了。

[My Submission](https://atcoder.jp/contests/arc174/submissions/51387885)。

---

## 作者：JackMerryYoung (赞：1)

# 前言

B 题，简单数学问题。

# 正文

首先我们发现只要自己大脑正常，就不会购买 $1, 2, 3$ 星的评论，因为这毫无意义。

设我们购买 $a$ 条 $4$ 星与 $b$ 条 $5$ 星评论，那么有一个不等式（$p_{org}$ 表示原来的分值和，$cnt_{org}$ 表示原来的评论数）：

$$
\begin{aligned}
\dfrac{4a + 5b + p_{org}}{a + b + cnt_{org}} &\geq 3 \\
4a + 5b + p_{org} &\geq 3a + 3b + 3cnt_{org}\\
a + 2b &\geq 3cnt_{org} - p_{org}
\end{aligned}
$$

要求的是 $(a \cdot P_4 + b \cdot P_5)_{min}$，很显然当 $3cnt_{org} - p_{org} \leq 0$ 时啥都不用干直接输出 $0$，因为显然已经自动满足了。

接下来我们发现加 $2$ 个 $4$ 星等于 $1$ 个 $5$ 星，因此考虑如下几种情况：

1. 只加一个 $4$ 星，其余都加 $5$ 星

2. 全是 $4$ 星

3. 全是 $5$ 星

于是就做完了。时间复杂度 $\mathcal{O}(N)$，显然可以通过。

---

## 作者：_WF_ (赞：0)

## 题目分析
这个老板希望花钱刷好评来让自己的~~豆瓣~~评分高于三星（评分平均值）。而刷评分的代价不同，所以不能总是刷五星好评，因而有了这道题。
## 题目实现
首先，如果本身就已经达到了三星的评分就不用刷好评了，所以输出 $0$。

让后我们可以观察到，刷三星以下的评分只能使评分无限接近三星而不能达到三星，所以我们只需要考虑三种情况，即：只刷 $4$ 星，只刷 $5$ 星和刷一个 $4$ 星和若干个 $5$ 星。（听我慢慢分析）

计现在有 $k$ 颗星，$p$ 个评分，补了 $a$ 个 $4$ 星好评和 $b$ 个 $5$ 星好评。

所以：
$$ \frac{k + 4 \times a + 5 \times b }{p+a+b} \ge 3$$

即：
$$ a + 2 \times b \ge 3 \times p - k $$

可以观察到，当刷四星好评的代价的二倍**不大于**刷五星好评的代价时就刷四星。

当 $3 \times p - k$ 是二的倍数是那么就刷五星好评。

对于不是二的倍数，那么判断四星好评的代价和五星好评的代价，来判断多的那些应刷四星还是五星好评。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long T;
	cin>>T;
	while(T--){
		long long a[6],p[6];
		long long all=0,sum=0;
		for(long long i=1;i<=5;i++){
			cin>>a[i],sum+=a[i],all+=i*a[i];//记录 k 和 p 
		}
		for(long long i=1;i<=5;i++)cin>>p[i];
		if(all/sum>=3){//第一种情况
			cout<<0<<endl;
			continue;
		}
		long long ex=3*sum-all;
		if(2*p[4]<=p[5]){//第二种情况
			cout<<ex*p[4]<<endl;
			continue;
		}
		if(ex%2==0){//第三种情况
			cout<<ex/2*p[5]<<endl;
			continue;
		}
		if(p[4]>p[5]){//第四种情况
			cout << (ex+1)/2*p[5]<<endl;continue;
		}
		cout<<(ex-1)/2*p[5]+p[4]<<endl;
	}
}
```

---

## 作者：DFM_O (赞：0)

## [AT_arc174_b 题目](https://www.luogu.com.cn/problem/AT_arc174_b)

### 解题思路
显然，如果我们想让平均值大于等于 $3$，就得买比 $3$ 大的分数，即得买 $4$ 分的和 $5$ 分的。

那么可能最优的方案就只剩了 $3$ 种：
- 全部买 $5$ 分的

- 全部买 $4$ 分的

- 买一些 $5$ 分的和 $1$ 个 $4$ 分的

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[6],p[6];
signed main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--)
	{
		int mb=0,s=0;
		for(int i=1;i<=5;i++)
		{
			cin>>a[i];
			s+=i*a[i],mb+=a[i]*3;
		}
		for(int i=1;i<=5;i++)
			cin>>p[i];
		if(mb<=s)
		{
			cout<<"0\n";
			continue;
		}
		int ne=mb-s,minn=LLONG_MAX;
		if(ne%2==0)
			minn=min(minn,ne/2*p[5]);
		else
			minn=min(minn,(ne/2+1)*p[5]),minn=min(minn,ne/2*p[5]+p[4]);
		minn=min(minn,ne*p[4]);
		cout<<minn<<"\n";
	}
	return 0;
}
```

---

## 作者：Dream_Stars (赞：0)

## 题目大意：
这道题共有 $T$ 组测试数据，每组测试数据由两个内容组成：每种评分的次数和贿赂每种评分所需的金钱。而我们需要让平均评分保持在 $3.0$ 以上，并且还要使贿赂所需的钱数花费**最少**。
## 算法分析：
这道题其实就是一个**贪心**的算法，题面看起来很复杂，事实上，我们只需要考虑贿赂评分 $4$ 和评分 $5$ 即可，因为如果贿赂评分$1$，$2$ 和 $3$ 你会发现平均的评分其实还是低于 $3$ 的，所以，我们只需要贿赂 $4$ 和 $5$ 即可得到最优解。

于是，在以上分析的基础上，我们不难得出贪心的方法，就是分类讨论几种情况所需的金钱，最终取出**最小值**即可，具体情况如下：

- 只买评分 $4$；
- 只买评分 $5$；
- 买**一个**评分 $4$ 和 **一些**评分 $5$。
  
前两种情况相信大家都可以理解，我这里就不多解释了，而第三种情况为什么要买一个评分 $4$ 呢？因为我们与目标情况相差的值可能是一个奇数，而评分 $5$ 的贡献都是偶数，得出贡献综合一定是一个偶数，所以，可能会造成浪费，进而使答案**不是最小值**，所以，一定要注意一下第三种情况。

## 代码展示：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 1e4 + 10;
ll t , n , x , cnt , sum , ans;
ll a[N] , b[N];
int main(){
  cin >> n;
  for(int i = 1 ; i <= n ; i++){
  	t = 0 , sum = 0 , cnt = 0 , ans = LONG_LONG_MAX;
  	for(int j = 1 ; j <= 5 ; j++) cin >> a[j];
  	for(int j = 1 ; j <= 5 ; j++) cin >> b[j];
	t = ( a[1] + a[2] + a[3] + a[4] + a[5] ) * 3 - ( a[1] * 1 + a[2] * 2 + a[3] * 3 + a[4] * 4 + a[5] * 5 );
/*
这个t是指我们与目标状态所相差的贡献。
目标状态的总星数就是：
( a[1] + a[2] + a[3] + a[4] + a[5] ) * 3
而我们现在的总星数是：
( a[1] * 1 + a[2] * 2 + a[3] * 3 + a[4] * 4 + a[5] * 5 )
两者之差就是我们所相差的贡献值。
*/
	if(t <= 0){
  	  cout << 0 << endl;
	  continue;
	}
//这里判断一下t是不是负数，是负数证明现在的星数已经高于目标星数了，不需要贿赂，则直接输出0即可。
	ans = min(ans , t * b[4]);//全部买4，因为贡献是1，无论奇偶，都没有浪费。
	if(t % 2 == 0)
	  ans = min(ans , t / 2 * b[5]);//如果是偶数的话考虑5的评分，它的贡献是2，不会造成浪费。
	else//如果t是一个奇数。
	  ans = min(ans , (t / 2 + 1) * b[5]) , ans = min(ans , (t / 2) * b[5] + b[4]);
//先判断全部买5的可能，再判断买1个4加上一些5第可能性。
	cout<<ans<<endl;//输出最后结果即可。
  }
  return 0;//return 养成好习惯。
}
```

---

## 作者：linjinkun (赞：0)

全世界应该没有比我更傻的人了（哭笑不得），竟然完全无法理解为什么不能选前 $3$   个评论！！$*$ $_$ $*$。

~~不过大佬们写的题解我全部都看不懂（我太逊了），所以我要写一篇题解来记录一下……~~

先说一下为什么不能选前 $3$ 个评论，因为它要使所有评价的评分平均分大于等于 $3$，所以选了价值比 $3$ 还低或相等的平均分只是在浪费钱（小学四年级都懂吧（就我没有理解题目））。

所以要选 $4$ 号评论或者 $5$ 号评论，咱们把四号评论价值想象成一颗星，五号评论想象成两颗星。（原因：因为 $4$ 除以 $3$ 的余数是 $1$，$5$ 除以 $3$ 的余数是 $2$）

那么如果选 $4$ 号的性价比比 $5 $号的高，那就全选 $4$ 号，否则就选 $5$ 号。如果选了 $5$ 号还没有达到要求（也就是离达到要求还差一步，也就是原本要增加的量是奇数），就再选 $5$ 号和 $4$ 号的最小值。

注意：**如果本身平均值就比 $3$ 大或者等于 $3$，就输出 $0$。**

代码：
~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
signed main()
{
	int n;
	scanf("%lld",&n);
	while(n--)
	{
		int a[10],p[10];
		for(int i = 1;i<=5;i++)
		{
			scanf("%lld",&a[i]);
		}
		for(int i = 1;i<=5;i++)
		{
			scanf("%lld",&p[i]);
		}
		int t = 3*(a[1]+a[2]+a[3]+a[4]+a[5])-(a[1]+a[2]*2+a[3]*3+a[4]*4+a[5]*5);//计算还需要多少星才能满足要求
		if(t<=0)//不用贿赂
		{
			printf("0\n");
		}
		else
		{
			if(p[4]*2<=p[5])//一个胜两个（思路中的第一种情况）
			{
				printf("%lld\n",t*p[4]);
			}
			else if(t&1)//第一个不如第二个，但t是奇数，得先分t-1个，再在p[4]和p[5]中找一个最小的
			{
				printf("%lld\n",(t-1)*p[5]/2+min(p[5],p[4]));//除以二的原因是5号是两颗星
			}
			else
			{
				printf("%lld\n",t*p[5]/2);//是偶数，直接全部买了
			}
		}
	}
    return 0;
}
~~~

---

## 作者：I_will_AKIOI (赞：0)

首先我们判断当前评分的平均值是否 $\ge3$，是的话就输出 $0$，因为不需要贿赂。由于浮点数可能会掉精度，我们给式子做一下交叉相乘，判断评分个数 $\times3$ 是否大于总评分即可。

否则，我们发现给你一条评分 $\le3$ 的评论是没用的，因为再怎么评论你的评分永远不会 $\ge3$。所以只有 $4$ 和 $5$ 是有用的。

接下来我们分情况讨论。要么全部用 $4$，要么全部用 $5$，或者用一个 $5$，再用多个 $4$。取最小值即可。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,a[10],p[10];
void solve()
{
  int sum=0,cnt=0;
  for(int i=1;i<=5;i++) cin>>a[i],cnt+=a[i],sum+=i*a[i];
  for(int i=1;i<=5;i++) cin>>p[i];
  sum-=cnt*3;
  if(sum>=0)//不需要贿赂
  {
    cout<<0<<"\n";
    return;
  }
  sum=-sum;
  int ans=sum*p[4];//全部用4
  if(sum&1) ans=min(ans,(sum/2+1)*p[5]),ans=min(ans,sum/2*p[5]+p[4]);//多个4+一个5
  else ans=min(ans,sum/2*p[5]);//
  cout<<ans<<"\n";
  return;
}
signed main()
{
  ios::sync_with_stdio(0);
  cin>>t;
  while(t--) solve();
  return 0;
}
```

---

## 作者：wosile (赞：0)

题目背景很现实啊，这个东西全球统一。

碰到平均时的经典套路，把所有数减掉平均值。

所以把评价分别看作 $-2,-1,0,1,2$，就可以转化为至少多少次才能使总评价非负。

也就是说需要用评价 $1$ 和 $2$ 来补上总的负评价。

判断一下评价 $1$ 和 $2$ 哪个单价更低就优先用哪个就行。注意边界情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10],p[10];
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		for(int i=1;i<=5;i++)scanf("%d",&a[i]);
		for(int i=1;i<=5;i++)scanf("%d",&p[i]);
		int tot=a[1]+a[1]+a[2]-a[4]-a[5]-a[5];
		if(tot<=0)printf("0\n");
		else if(p[4]+p[4]<=p[5])printf("%lld\n",1LL*p[4]*tot);
		else if(p[5]<=p[4])printf("%lld\n",1LL*(tot+1)/2*p[5]);
		else printf("%lld\n",1LL*tot/2*p[5]+tot%2*p[4]);
	}
	return 0;
	//quod erat demonstrandum
}
```

---

## 作者：Link_Cut_Y (赞：0)

答案显然满足可二分性。

不妨设当前二分中点为 $m$。购买星数 $\le 3$ 是没有意义的。可以发现，最优策略最多有下面两种可能：

- 全部购买四星，剩下一点钱买五星。

- 全部购买五星，剩下一点钱买四星。

将两种情况能够获得的平均星数取最大值，并与 $3$ 比较即可。复杂度 $O(\log n)$。[submission](https://atcoder.jp/contests/arc174/submissions/51389067)。

---

## 作者：Sundar_2022 (赞：0)

[Cnblogs](https://www.cnblogs.com/Sundar-2022/p/18086193)

### 【题目描述】

你开了一家店，有 $A_i$ 个 $i$ 星级评论，你可以花费 $P_i$ 元买到一个 $i$ 星评论，问使得这家店评论的星星平均值不小于 $3$，最少要花多少钱。

$1\le i \le 5$。

### 【思路】

* 首先读入，判断平均值是否小于 $3$，如果大于等于，直接输出 $0$

* 然后根据 $3\times(当前的评论数)$ 算出平均值为 $3$ 时，应该有多少个星星，还差多少个星星。

* 然后买 $1,2,3$ 星的评论一定是没有用的。

* 现在问题转化为：

  > 你现在要攒 $n$ 个星星，可以花费 $P_4$ 元买到 $1$ 个星星，也可以花费 $P_5$ 元买到 $2$ 个星星

* 分类讨论：
  * 首先，如果 $P_4\times2\le P_5$（一个一个买比一次买两个性价比高/一样），那么直接买就行。
  * 否则，先两个两个买，然后最后如果有剩下的就再买一个。

做完了。

### 【Code】

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int T,A[6],P[6],Point;
void Main()
{
    for(int i=1;i<=5;i++) scanf("%lld",&A[i]);
    for(int i=1;i<=5;i++) scanf("%lld",&P[i]);
    Point=3*(A[1]+A[2]+A[3]+A[4]+A[5])-(A[1]*1+A[2]*2+A[3]*3+A[4]*4+A[5]*5);
    if(Point<=0){ //不需要贿赂
        puts("0");
    }else{
        if(P[4]*2<=P[5]){                //算性价比
            printf("%lld\n",Point*P[4]); //不如一个一个贿赂
        }else{
            if(Point%2==0) printf("%lld\n",Point*P[5]/2);                    //两个两个贿赂
            else           printf("%lld\n",(Point-1)*P[5]/2+min(P[4],P[5])); //两个两个贿赂，多一个
        }
    }
}

signed main()
{
    scanf("%lld",&T);
    while(T--){
        Main();
    }
    return 0;
}
```

---

## 作者：Dtw_ (赞：0)

# B - Bought Review
[atcoder](https://atcoder.jp/contests/arc174/tasks/arc174_b)
## 题目大意
多测，评 $i$ 分的有 $A_i$ 条，可以花 $P_i$ 的钱买一个 $i$ 分的评论，求平均分大于等于 $3$ 最少花费。

$1 \leq i \leq 5$

## 思路
贪心，我们假设一开始的评分是 $p$ 分，$q$ 条评论，我们花钱买了 $B_1$ 个 $1$ 分评论，$B_2$ 个 $2$ 分评论，...，$B_5$ 个 $5$ 分评论。

那么根据题意得：

$$\frac{p+B_1+2B_2+3B_3+4B_4+5B_5}{q+B_1+B_2+B_3+B_4+B_5} \ge 3 $$

化简得：

$$p - 3q - 2B_1 - B_2 + B_4 + 2B_5 \ge 0$$

由此可得我们不可能买 $3$ 分及 $3$ 分以下的评价，因为买了会更劣或不变，所以得到：

$$B_4 + 2B_5 \ge 3q - p$$

所以我们就可以得出这个式子，然后我们**感性**理解一下，就是 $2$ 个 $4$ 分评价就等于 $1$ 个 $5$ 分评价，为什么呢？因为 $4$ 分比 $3$ 分多 $1$ 分，而 $5$ 分比 $3$ 分多 $2$ 分，所以我们可以运用这个等式，然后我们就可以这样贪心：

1. 全买 $4$ 分的
2. 买 $1$ 个 $4$ 分的和一些 $5$ 分的
3. 全买 $5$ 分的

解释一下第二条，因为两个 $4$ 和一个 $5$ 是等价的，所以如果我们买了超过一个，那些超过一个的部分都可以用 $5$ 来代替。

## Code
[link](https://atcoder.jp/contests/arc174/submissions/51413820)。

---


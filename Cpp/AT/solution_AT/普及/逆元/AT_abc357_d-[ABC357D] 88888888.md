# [ABC357D] 88888888

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc357/tasks/abc357_d

正整数 $ N $ に対して、$ N $ を $ N $ 個つなげた整数を $ V_N $ とします。  
 より厳密には、$ N $ を文字列とみなしたものを $ N $ 個連結し、 それを再度整数とみなしたものを $ V_N $ とします。  
 例えば、$ V_3=333 $, $ V_{10}=10101010101010101010 $ です。

$ V_N $ を $ 998244353 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 10^{18} $
- $ N $ は整数
 
### Sample Explanation 1

$ V_5=55555 $ を $ 998244353 $ で割った余りは $ 55555 $ です。

### Sample Explanation 2

$ V_9=999999999 $ を $ 998244353 $ で割った余りは $ 1755646 $ です。

### Sample Explanation 3

入力が $ 32 $ bit 整数型に収まらない可能性があることに注意してください。

## 样例 #1

### 输入

```
5```

### 输出

```
55555```

## 样例 #2

### 输入

```
9```

### 输出

```
1755646```

## 样例 #3

### 输入

```
10000000000```

### 输出

```
468086693```

# 题解

## 作者：stripe_python (赞：11)

建议标签：数学、逆元。建议难度：黄到绿。

# 题意

定义 $v(n)$ 为将 $n$ 首位顺次相接 $n$ 次所得的整数，求 $v(n) \bmod 998244353$。

# 题解

前置知识：[等比数列求和](https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/7527367)、[有理数取余](https://www.luogu.com.cn/problem/P2613)。

先考虑推一波 $v(n)$ 的式子。

不妨令 $d$ 为 $n$ 的位数，则 $v(n)$ 可以看作一个 $b=10^d$ 进制的整数，每个数位上都是 $n$，有：

$$
\begin{aligned}
  v(n) &= \sum_{i=0}^{n-1}n\times b^i  \\
       &= n\sum_{i=0}^{n-1}b^i \\
       &= n \times \dfrac{b^n-1}{b-1}

\end{aligned}
$$

接下来注意随时取模，除法求个逆元即可。需要注意的是，$b$ 最大可达 $10^{19}$，需要开 `unsigned long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ull = unsigned long long;

ull n;
const ull mod = 998244353;

ull power(ull a, ull b) {
	ull res = 1;
	for (a %= mod; b; b >>= 1) {
		if (b & 1) res = res * a % mod;
		a = a * a % mod;
	}
	return res;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	ull b = 1;
	while (b <= n) b *= 10;
	cout << n % mod * (power(b, n) - 1) % mod * power(b - 1, mod - 2) % mod << endl;
	return 0;
}
```

复杂度：$O(\log n)$。

---

## 作者：zhlzt (赞：5)

### 题解
倍增套快速幂即可，其实本质上就是快速幂套快速幂。

将 $N$ 二进制拆分（这里用快速幂的写法），分别计算 $2^0,2^1,2^2,\ldots$ 个 $N$ 拼接的结果即可。注意拼接的时候要记得乘上 $10^{cnt}$（快速幂计算），这个 $cnt$ 要动态维护，并且要开 `__int128`，防止溢出。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=998244353;
ll qkpow(__int128 pos){
	ll ans=1,num=10; 
	while(pos){
		if(pos%2==1) ans=1ll*ans*num%mod;
		num=1ll*num*num%mod; pos=pos/2;
	}
	return ans;
}
int main(){
	ll n;scanf("%lld",&n);
	ll m=n; int cnt=0; 
	while(m) cnt++,m/=10;
	ll p=n%mod,q=n,ans=0; 
	__int128 pos=cnt;
	while(q){
		if(q%2==1){
			ans=1ll*ans*qkpow(pos)%mod;
			ans=(ans+p)%mod;
		}
		p=(1ll*p*qkpow(pos)%mod+p)%mod;
		q=q/2; pos=pos*2;
	}
	printf("%lld\n",ans); 
	return 0;
}
```

---

## 作者：Empty_Dream (赞：4)

## 分析

不难想到可以直接拆开，对于一个大数就变成 $N \times 10^{x1}+N \times 10^{x_2}+ \cdots + N \times 10^{x_N}$。

现在需要搞清楚 $x_i$ 是什么，观察一下不难发现，从右往左的第一个 $N$ 和第二个之间相差了 $10^{k}$ 这里 $k$ 表示 $N$ 的位数。以此类推，第 $i$ 个 $N$ 应该与第一个 $N$ 相差 $10^{(i-1)k}$。式子就变成了 $N \times 10^{0k}+ N \times 10^{k} + \cdots + N \times 10^{(N-1)k}$。

回到式子，学过小学数学的都知道能提取公因式，变成 $N \times (10^{0} + 10^{k} + 10^{2k} + \cdots + 10^{(N-1)k})$。再观察，又发现后面也是等比数列，求和公式秒了，公比就是 $10^k$，最终公式：$N\times \frac{10^{Nk}-1}{10^k-1}$，记得用上逆元。

注意：记得开 `__int128`，不然在计算时可能会炸。

## 代码

```cpp
#include <bits/stdc++.h>
#define int __int128
using namespace std;

const int mod = 998244353;
int ans;
long long x;

int ksm(int a, int b){
    int cnt = 1;
    while (b){
        if (b & 1) cnt = cnt * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return cnt;
}

signed main(){
    cin >> x;
    int n = x, tmp = n, cnt = 0;
    while (tmp) cnt++, tmp /= 10;
    cout << (long long)(((n % mod) * ((ksm(10, n * cnt) - 1 + mod) % mod) * (ksm((ksm(10, cnt) - 1 + mod) % mod, mod - 2) % mod)) % mod);
    return 0;
}
```

---

## 作者：weilycoder (赞：4)

# 思路

我们定义一种运算 $a\ast b$ 是将 $a$，$b$ 的数字拼接形成一个新数，如 $11\ast 222=11222$，显然这种运算满足结合律。

类似地，我们还能定义 $\ast$ 上的幂运算：$a^{(k)}=\underbrace{a\ast a\ast\cdots\ast a}_{k\text{个}a}$.

问题转化为：求 $N^{(N)}\bmod 998244353$.

由于 $\ast$ 满足结合律，因此它的幂运算可以使用快速幂。

<!-- 虽然要求使用中文标点，但公式后接句号实在不太好看（且容易与下角标 0 混淆），管理实在有意见我再改吧 -->

# Code

关键代码是 `bigint` 结构体。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int p = 998244353;

inline int len(long long x) { return to_string(x).length(); }

long long qpow(long long a, long long b) {
  long long r = 1;
  for (; b; b >>= 1) {
    if (b & 1) r = r * a % p;
    a = a * a % p;
  }
  return r;
}

struct bigint {
  long long v, l;
  bigint() : v(0), l(1) {}
  bigint(long long x) {
    v = x % p;
    l = qpow(10, len(x));
  }
  bigint(long long v, long long l) : v(v), l(l) {}
  bigint operator*(const bigint &b) {
    return {(v * b.l + b.v) % p, b.l * l % p};
  }
};

bigint qpow(bigint a, long long n) {
  bigint r;
  for (; n; n >>= 1) {
    if (n & 1) r = r * a;
    a = a * a;
  }
  return r;
}

int main() {
  long long n;
  cin >> n;
  cout << qpow(bigint(n), n).v << endl;
  return 0;
}
```

---

## 作者：DrAlfred (赞：1)

摘要：数学，等比数列，逆元

[传送门：https://www.luogu.com.cn/problem/AT_abc357_d](https://www.luogu.com.cn/problem/AT_abc357_d)

## 题意

对于正整数 $N$，设 $V_N$ 为正整数 $N$ 拼接 $N$ 次形成的整数。如 $V_5 = 55555$。

现在给定一个正整数 $N$，求 $V_N \bmod 998244353$。

## 分析思路

注意到 $N$ 很大，考虑数学方法。

我们记 $N$ 在十进制下的位数为 $d$。显然，原问题转化为：

$$
\begin{aligned}
V_N &= \sum_{i=0}^{N-1} N \times (10 ^ d) ^ i \bmod 998244353 \\
&= N \times \sum_{i=0}^{N-1} (10 ^ d) ^ i \bmod 998244353
\end{aligned}
$$

显然后半部分我们要求解的和是一个公比为 $10^d$，首项为 $1$ 的等比数列。

根据等比数列求和通项公式我们有：

$$
\sum_{i=0}^{N-1} (10 ^ d) ^ i = \frac{(10^d)^N - 1}{10^d - 1}
$$

而根据费马小定理：

$$
\frac{(10^d)^N - 1}{10^d - 1} \equiv [(10^d)^N - 1] \times (10^d - 1)^{998244351} \pmod {998244353}
$$

所以我们处理出 $d$，再写一个快速幂，就能在 $O\left(\log N + \log \log N \right)$ 的时间复杂度内求解该问题。

**注意：题解代码中的快速幂是在 `ModInt operator^` 中实现的**

最后敲个警钟，快速幂的指数记得传 `long long`。

## 代码

```cpp

#include <bits/stdc++.h>
using namespace std;
template <int mod>
inline uint64_t down(uint64_t x) { return x >= mod ? x - mod : x; }
template <int mod>
struct ModInt {
    uint64_t x;
    ModInt() = default;
    ModInt(uint64_t x) : x(x % mod) {}
    friend istream &operator>>(istream &in, ModInt &a) { return in >> a.x; }
    friend ostream &operator<<(ostream &out, ModInt a) { return out << a.x; }
    friend ModInt operator+(ModInt a, ModInt b) { return down<mod>(a.x + b.x); }
    friend ModInt operator-(ModInt a, ModInt b) { return down<mod>(a.x - b.x + mod); }
    friend ModInt operator*(ModInt a, ModInt b) { return (__int128)a.x * b.x % mod; }
    friend ModInt operator/(ModInt a, ModInt b) { return a * ~b; }
    friend ModInt operator^(ModInt a, long long b) {
        ModInt ans = 1;
        for (; b; b >>= 1, a *= a)
            if (b & 1) ans *= a;
        return ans;
    }
    friend ModInt operator~(ModInt a) { return a ^ (mod - 2); }
    friend ModInt operator-(ModInt a) { return down<mod>(mod - a.x); }
    friend ModInt &operator+=(ModInt &a, ModInt b) { return a = a + b; }
    friend ModInt &operator-=(ModInt &a, ModInt b) { return a = a - b; }
    friend ModInt &operator*=(ModInt &a, ModInt b) { return a = a * b; }
    friend ModInt &operator/=(ModInt &a, ModInt b) { return a = a / b; }
    friend ModInt &operator^=(ModInt &a, long long b) { return a = a ^ b; }
    friend ModInt &operator++(ModInt &a) { return a += 1; }
    friend ModInt operator++(ModInt &a, int) {
        ModInt x = a;
        a += 1;
        return x;
    }
    friend ModInt &operator--(ModInt &a) { return a -= 1; }
    friend ModInt operator--(ModInt &a, int) {
        ModInt x = a;
        a -= 1;
        return x;
    }
    friend bool operator==(ModInt a, ModInt b) { return a.x == b.x; }
    friend bool operator!=(ModInt a, ModInt b) { return !(a == b); }
};
using mint = ModInt<998244353>;
inline void optimizeIO(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
}
long long n, d, x;
int main(int argc, char const *argv[]) {
    optimizeIO(), cin >> n, x = n;
    while (x) d++, x /= 10;
    mint b = (mint)10 ^ d, ans = 0;
    cout << ((b ^ n) - 1) / (b - 1) * n << endl;
    return 0;
}

```

---

## 作者：No_Rest (赞：1)

# 思路

考虑 $\mathcal O(\log n)$ 算出重复 $2^i$ 遍的 $n$ 取模后的结果，存入 $ans_i$，再用 $ans_i$ 去拼出 $n$ 遍的 $n$。易知 $ans_i = ans_{i-1} + ans_{i-1} \times |ans_{i-1}|$，其中 $|ans_{i-1}|$ 表示 $ans_{i-1}$ 的位数。

例如 $n=9$ 时，因为 $9 = 2^3 + 2^1$，所以答案为 $ans_1 + ans_3 \times 10$（因为是 $3$ 个 $9$ **拼上** $1$ 个 $9$，所以要乘以 $10^{\lceil \log_{10}|ans_1| \rceil}$ 即 $10$ 而不是单纯加，）。

具体实现 $ans$ 可以仅为一个变量，用 $base$ 记录 $ans$ 的位数，每次 $base \gets base^2$，这样不用每次算 $ans$ 的位数。还需要记录一个 $now$ 记录现在已经拼出来的数的位数。

时间复杂度 $\mathcal O(\log n)$。

易错点：

- 某些实现方式要开 `unsigned long long`。
- 重复 $n$ 遍 $\bmod \ 998244353$ 和重复 $n \bmod 998244353$ 遍 $\bmod \ 998244353$ 不一样（为什么？）

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn = 65;
const ll mod = 998244353;
ll read(){
	char ch;
	ll f = 0, r = 0;
	ch = getchar();
	while(ch > '9' || ch < '0') f |= ch == '-', ch = getchar();
	while(ch <= '9' && ch >= '0') r = (r << 3) + (r << 1) + (ch ^ 48), ch = getchar();
	return f ? -r : r;
}
ll n = read(), base, p10[maxn], ans, now = 1, res;
int main(){
	p10[0] = 1, ans = n % mod;
	for(ll i = 1; i <= 18; ++i) p10[i] = p10[i - 1] * 10;//用来算位数
	p10[19] = p10[18] % mod * 10 % mod;//注意 p10[19] 单独处理，1e19 会炸 long long
	base = p10[upper_bound(p10 + 1, p10 + 19, n) - p10] % mod;//算出位数，小心不要写成 upper_bound(p10 + 1, p10 + 20, n)，p10[19] < p10[18] 不满足单调性，我在这里白吃三次罚时
	if(n & 1) res = (res + ans) % mod, now = base;//重复 2 ^ 0 次的要单独算
	for(ll i = 1; i <= 60; ++i){
		ans = (ans + ans * base % mod) % mod, base = base * base % mod;//算出 ans 和其位数
		if((n >> i) & 1) res = (res + ans * now % mod) % mod, now = now * base % mod;//如果拼 n 次需要 2 ^ i 次，那么拼上，更新最终答案和目前拼出的数的位数
	}
	printf("%lld", res);
    return 0;
}
```

---

## 作者：LuukLuuk (赞：1)

# 题解：AT_abc357_d [ABC357D] 88888888
### 题目大意

给你一个数 $N$，要你求 $N$ 个 $N$ 串连起来所组成的数模 $998244353$ 是多少。

例如当 $N = 3$ 时，结果为 $333$，也就是 $3$ 个 $3$。

数据范围是 $1 \le N \le 10^{18}$。

--------------------------------------
### 题解
注：题解中以 $\overline{NN...NN}$ 的方式表示 $N$ 个 $N$ 串连起来所组成的数，以 $\div$ 的方式表示向下取整除法。

首先，这道题高精是 $O(N)$ 的，要炸。我们要考虑其他方案，例如使用 $O(1)$ 的公式解决，也就是数学方法。

我们可以发现，对于一个数 $\overline{NN...NN}$ 来说，若设 $M$ 为 $N$ 的位数，则这个数可以被表示成下面的式子：
$$
10^0 \times N + 10^M \times N + 10^{2M}\times N + ... + 10^{N \times M} \times N
$$
将该式化简，可得
$$
N \times (10^0 + 10^M + 10^{2M} + ... 10^{N \times M})
$$
我们可以发现，该式是一个首项为 $1$（$10^0 = 1$），末项为 $10^{N \times M}$，公比为 $10^{M}$ 的[等比数列](https://blog.csdn.net/LaoYuanPython/article/details/125581056#:~:text=%E5%AF%B9%E4%BA%8E%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%EF%BC%8C%E6%9C%89%E5%A6%82%E4%B8%8B%E5%85%AC%E5%BC%8F%EF%BC%9A%20%E8%AE%B0%E6%95%B0%E5%88%97%20%7Ban%7D%E4%B8%BA%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%EF%BC%8C%E5%85%AC%E6%AF%94%E4%B8%BAq%EF%BC%8C%E5%85%B6%E5%89%8Dn%E9%A1%B9%E5%92%8C%E4%B8%BASn%EF%BC%8C%E5%88%99%E6%9C%89%EF%BC%9A%20%E5%85%AC%E6%AF%94q%3D1%E6%97%B6%EF%BC%8CS%20n%20%3Dna%201%20%E5%85%AC%E6%AF%94q%E2%89%A01%E6%97%B6%EF%BC%8CS,%281-q%20n%29%2F%20%281-q%29%3D%EF%BC%88a%201%20-a%20n%20q%EF%BC%89%2F%20%281-q%29%E3%80%82)。因此，可进一步化简得到
$$
N \times \frac{1-10^{N \times M}}{1-10^M}
$$
又由分式中两者皆为负数可得（因为 $N \ge 1$ 所以 $M \ge 1$ 则 $10^M \ge 10 \ge 1$）  
$$
N \times \frac{10^{N \times M}-1}{10^M-1}
$$
接下来，我们要对该式取模，为了方便，将该式化为
$$
N \times (10^{N \times M}-1) \times (10^M-1)^{-1}
$$
这里，我们要用到一个叫[费马小定理](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158)的东西。至于使用，我们分 $10^{N \times M}-1$ 和 $(10^M-1)^{-1}$ 这两项讨论。（其它的不用说了吧）

对于第一项，也就是 $10^{N \times M}-1$ 而言，$-1$ 并没有太大的影响，那我们先把它放一边。接下来，便只剩下了 $10^{N \times M}$。（设 $998244353$ 为 $md$）

由于 $md$ 为质数，$md \nmid 10$，得
$$
10^{md - 1} \equiv 1 \pmod{md}
$$
又因为
$$
10^{N \times M} = 10^{(N \bmod (md - 1))\times M} \times 10^{(N \div (md - 1))\times M}
$$
则等式右边第二项为 $10^{md - 1}$ 的倍数，即可得
$$
10^{(N \bmod (md - 1))\times M} \times 10^{(N \div (md - 1))\times M} \equiv 10^{(N \bmod (md - 1))\times M} \times 1 \pmod{md}
$$
再加入被放在一边的 $-1$，原项就变成了下面的样子：
$$
10^{(N \bmod (mod - 1))\times M} - 1
$$
而幂怎么求，我们用一下[快速幂](https://oi-wiki.org/math/binary-exponentiation/)就行了。

接下来看第二项，同样的，我们可以得到
$$
(10^{m}-1)^{md-1} \equiv 1 \pmod{md}
$$
两边同时乘上 $(10^{m}-1)^{-1}$，得
$$
(10^{m}-1)^{md-2} \equiv (10^{m}-1)^{-1} \pmod{md}
$$
所以第二项就是
$$
(10^{m}-1)^{md-2}
$$

综上所述，得 $\overline{NN...NN}$ 的值模 $md$ 为
$$
(n \bmod md)\times((10^{(N \bmod (md - 1))\times M} - 1) \bmod md) \times ((10^{m}-1)^{md-2} \bmod md) 
$$
变成代码就是（为了避免快速幂炸掉，这里我们设 `t` 为 $10^m - 1$）
```cpp
	ans = n % mod * (pow(10, n % (mod - 1) * m) - 1) % mod * pow(t, mod - 2) % mod;
```

### 完整代码

**注意开 `long long`。**

```cpp

#include <cstdio>
using namespace std;

#define int long long

const int mod = 998244353;

int n, ans; 
int m, t;

int pow(int a, int b) {
    int sum = 1;
    while (b) {
        if (b & 1) {
            sum = (sum * a) % mod;
            b--;
        }
        b /= 2;
        a = a * a % mod;
    }
    return sum;
}

signed main() {
	scanf("%lld", &n);
	t = n;
	while (t)	m++, t /= 10;
	t = pow(10, m) - 1;
	ans = n % mod * (pow(10, n % (mod - 1) * m) - 1) % mod * pow(t, mod - 2) % mod;
	ans = (ans + mod) % mod;
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：ttq012 (赞：1)

考虑经典套路。这里重定义 $|n|$ 表示 $n$ 的位数，即 `to_string(n).size()`（请使用 C++11 及以上版本）。$S_n$ 表示 $N=n$ 时的答案。

首先考虑 $|n|\le 1$ 的情况。此时沿用 P4884 的解决方案。有  $S_n=n\times \frac{10^n-1}{9}$。

问题是 $|n|>1$ 时的情况。容易发现此时等式 $\large S_n=n\times \frac{10^{n\times|n|}}{10^k-1}$ 成立。证明显然。

然后考虑计算这个东西。当 $n=10^{18}$ 时 $n\times |n|=10^{18}\times 19=1.9\times 10^{18}>2^{64}-1$ 是很恶心的一点，所以请使用 `__int128` 来计算答案。其实也可以使用 `atcoder::modint998244353` 来计算答案。

```cpp
#pragma GCC optimize(3)
#include <bits/stdc++.h>
#define int long long
#define pb push_back
#define em emplace_back
#define F(i,x,y) for(int i=x;i<=y;i++)
#define G(i,x,y) for(int i=x;i>=y;i--)
#define W(G,i,x) for(auto&i:G[x])
#define W_(G,i,j,x) for(auto&[i,j]:G[x])
#define add(x,y) z[x].em(y)
#define add_(x,y) add(x,y),add(y,x)
#define Add(x,y,d) z[x].em(y,d)
#define Add_(x,y,z) Add(x,y,z),Add(y,x,z);
#ifdef int
#define inf (7611257611378358090ll/2)
#else
#define inf 0x3f3f3f3f
#endif
using namespace std;
const int mod = 998244353;
int ksm(int a, __int128 b, int c) {
    if (!b) return 1;
    int ans = ksm(a, b / 2, c);
    ans = ans * ans % c;
    if (b & 1) ans = ans * a % c;
    return ans;
}
signed main() {
    int n;
    cin >> n;
    int len = to_string(n).size();
    int key = ksm(10, (__int128)(len) * n, mod);
    key = (key + mod - 1) % mod;
    int ii = ksm((ksm(10, len, mod) + mod - 1) % mod, mod - 2, mod);
    // cout << "dbg " << ii << ' ' << key << '\n';
    cout << (n % mod) * ii % mod * key % mod << '\n';
}

```

---

## 作者：Harrylzh (赞：1)

设 $n$ 的位数为 $k$，$V_n$ 中的第 $i$ 个 $n$ 可以表示为 $n\times 10^{(i-1)k}$。把 $n$ 提出来，然后用等比数列公式。

$
n\times (1+10^k+\ldots +10^{(n-1)k})
= n\times \frac{10^{nk}-1}{10^k-1}
$

$n$ 乘的时候需要取模。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long P=998244353;
long long n;
long long ws(long long x)
{
	long long res=0;
	while(x)
	{
		res++;
		x/=10;
	}
	return res;
}
long long qp(long long a,long long b)
{
	a%=P;
	if(b==0) return 1;
	long long ans=qp(a,b/2)%P;
	ans=ans*ans%P;
	if(b%2==1) ans=ans*a%P;
	return ans%P;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	long long k=ws(n);
	long long ans=1;
	ans=qp(10,n)%P;
	ans=qp(ans,k)%P;//分开快速幂
	ans=(ans-1+P)%P;
	long long fm=qp(10,k)%P;
	fm=(fm-1+P)%P;
	fm=qp(fm,P-2);//逆元
	ans=ans*fm%P;
	ans=ans*(n%P)%P;//n要取模
	cout<<ans<<"\n";
   return 0;
}
```

---

## 作者：I_will_AKIOI (赞：0)

由于 $v_N$ 是由 $n$ 个 $n$ 相连组成的，所以 $v_N$ 是 $n$ 的倍数。我们将二者相除，找找规律。

$$\displaystyle\frac{55555}{5}=11111$$

$$\displaystyle\frac{121212121212121212121212}{12}=10101010101010101010101$$

我们设 $|N|=m$，也就是 $N$ 的长度。则 $v_N=N\times (10^0+10^m+10^{2m}+10^{3m}\dots +10^{(n-1)m})$。所以我们只要求出 $\displaystyle\frac{v_N}{N}$ 就行了。

然后我这里脑抽没想到等比数列求和，若有需要请移步至其他题解。但是想到了一个递推式：

$$f_0=1,f_i=f_{i-1}\times 10^m +1$$

然后发现这玩意可以矩阵快速幂求，接着考虑构造矩阵。

我们设当前的矩阵为 $A=\begin{bmatrix} f_i\\1\end{bmatrix}$。我们需要将它乘上一个矩阵 $C$，变为 $B=\begin{bmatrix} f_i\times10^m+1\\1\end{bmatrix}$。

从 $C$ 的第一行考虑，他要乘以 $10^m$，还要 $+1$，所以 $C_{1,1}=10^m,C_{1,2}=1$。

第二行我们需要将 $B$ 中的 $1$ 保留，所以 $C_{2,1}=0,C_{2,2}=1$。

推出了 $C$ 矩阵后，套上矩阵快速幂板子，就可以求出 $\displaystyle\frac{v_N}{N}$ 了。然后再乘上 $N$ 就是最终答案。

注意这里矩阵快速幂时 $N$ 不能取模，指数哪里能取模啊？

```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define int long long
#pragma GCC optimize("O3")
using namespace std;
struct Data{int a[3][3];}v,w,ans;
int len=1,n,m;
Data mul(Data x,Data y)
{
  Data res;
  res.a[1][1]=res.a[1][2]=res.a[2][1]=res.a[2][2]=0;
  for(int i=1;i<=2;i++) for(int j=1;j<=2;j++) for(int k=1;k<=2;k++) res.a[i][j]=(res.a[i][j]+x.a[i][k]*y.a[k][j]%mod)%mod;
  return res;
}
Data mul1(Data x,Data y)
{
  Data res;
  res.a[1][1]=res.a[1][2]=res.a[2][1]=res.a[2][2]=0;
  for(int i=1;i<=2;i++) for(int j=1;j<=1;j++) for(int k=1;k<=2;k++) res.a[i][j]=(res.a[i][j]+x.a[i][k]*y.a[k][j]%mod)%mod;
  return res;
}
Data Pow(Data x,int y)
{
  Data res;
  res.a[1][1]=res.a[1][2]=res.a[2][1]=res.a[2][2]=0;
  for(int i=1;i<=2;i++) res.a[i][i]=1ll;
  while(y)
  {
    if(y&1) res=mul(res,x);
    x=mul(x,x);
    y>>=1ll;
  }
  return res;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>n;
	m=n;
	while(m)
	{
		m/=10;
		len=len*10%mod;
	}
	w.a[1][1]=len;
	w.a[1][2]=1;
	w.a[2][1]=0;
	w.a[2][2]=1;
	v.a[1][1]=1;
	v.a[2][1]=1;
	ans=Pow(w,(n-1));
	ans=mul1(ans,v);
  n%=mod;
	cout<<ans.a[1][1]%mod*n%mod;
	return 0;
}
```

---

## 作者：Starrykiller (赞：0)

记 $x$ 在十进制表记法下的长度为 $l$。不难发现答案为

$$\sum_{i=0}^{x-1} x\cdot 10^{l\cdot i}$$

注意到这是一个等比数列求和的形式，公比是 $10^{l}$。由于 $1\le l\le \log_{10} 10^{18}=18\lt 998,244,352$，所以分母不会是 $0$。

利用 $\displaystyle \sum_{i=0}^{n-1} x^i=\frac{x^n-1}{x-1}$，不难得到答案。

时间复杂度 $\Theta(\log n)$。


[My submission](https://atcoder.jp/contests/abc357/submissions/54345880).

---

## 作者：MicroSun (赞：0)

upd：时间复杂度算错了。

烦人题。

考虑类似快速幂的分治方法。

将原问题即求 $n$ 个 $n$ 连接后的值转化为求 $\frac{n}{2}$ 个 $n$ 连接后的值，并将两个上述问题的答案合并。

对于如何求 $\frac{n}{2}$ 个 $n$ 连接后的值，考虑类比上述过程进行下一轮递归。

时间复杂度 $\Omicron(n\log^2 n)$。

实现细节比较多，调了半天，听说有更简单的方法但是不会。

Code:

```cpp
// Problem: D - 88888888
// LuoguUID: 514700 
// LuoguUserName: MicroSun
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define pb push_back
#define fst first
#define scd second
#define rep(i,s,e) for(int i=s;i<=e;i++)
#define dep(i,s,e) for(int i=s;i>=e;i--)

using ll=long long;
using ll1=__int128_t;
using pii=pair<int,int>;
using pll=pair<ll,ll>;

const int maxn=2e5+10;

ll a[maxn];
const ll1 mod=998244353;
ll1 dig(ll1 x){
	ll1 cnt=0;
	while(x){
		x/=10;
		++cnt;
	}
	return cnt;
}
ll n;
ll1 nn,t;
ll1 po(ll1 n,ll1 a=10){
	if(n==1) return a%mod;
	ll1 k=po(n/2);
	return ((k*k)%mod*(n%2?a%mod:1))%mod;
}
ll1 db(ll1 a,ll1 t){
	return (a*po(t)+a)%mod;
}
pair<ll1,ll1> fp(ll1 x,ll1 a){
	if(a==1) return {x%mod,t};
	auto p1=fp(x,a/2);
	ll1 p2=db(p1.fst,p1.scd);
	if(a%2) return {(p2*po(t)+x)%mod,p1.scd*2+t};
	return {p2,p1.scd*2};
}
void solve(){
	cin>>n;
	nn=n;
	t=dig(nn);
	cout<<(ll)fp(nn,nn).fst;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--) solve();
    return 0;
}
```

---


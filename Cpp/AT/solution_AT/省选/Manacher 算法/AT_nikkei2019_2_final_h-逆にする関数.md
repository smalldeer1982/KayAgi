# 逆にする関数

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-2-final/tasks/nikkei2019_2_final_h

$ 1,\ 2,\ \dots\ ,\ m $ からなる数列 $ (v_1,\ v_2,\ \dots,\ v_k) $ と 関数 $ f\colon\ \{1,\dots,m\}\ \to\ \{1,\dots,m\} $ について、 $ f $ が以下の条件を満たすとき、$ f $ が $ (v_1,\ v_2,\ \dots,\ v_k) $ を*逆にする* と言います。

- 数列 $ (f(v_1),\ f(v_2),\ \dots,\ f(v_k)) $ はもとの数列をひっくり返した数列 $ (v_k,\ v_{k-1},\ \dots,\ v_1) $ と一致する

$ 1,\ 2,\ \dots\ ,m $ からなる数列 $ (a_1,\ a_2,\ \dots,\ a_n) $ が与えられます。 この数列の空でない連続部分列は $ \frac{n(n+1)}{2} $ 通りありますが、 逆にする関数が何通り存在するかをこれら全てに対して数え上げて、その総和を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 注意

- 関数 $ f $ と $ g $ について $ f(i)\neq\ g(i) $ となる $ i\in\ \{1,\dots,m\} $ が存在するとき $ f $ と $ g $ が異なる関数であるとみなす

### 制約

- $ 1\leq\ n,\ m\ \leq\ 3\times\ 10^5 $
- 各 $ i=1,\ 2,\ \dots,\ n $ について $ 1\leq\ a_i\ \leq\ m $
- 入力はすべて整数である

### Sample Explanation 1

数列 $ (1,\ 1,\ 2) $ の連続部分列は $ (1) $ と $ (1,\ 1) $ と $ (1,\ 1,\ 2) $ と $ (1) $ と $ (1,\ 2) $ と $ (2) $ です。 - 関数 $ f $ が数列 $ (1) $ を逆にするための必要十分条件は $ f(1)=1 $ で、この条件を満たす $ \{1,\ 2,\ 3\} $ 上の関数は $ 9 $ 通りあります。 - 関数 $ f $ が数列 $ (1,\ 1) $ を逆にするための必要十分条件は $ f(1)=1 $ で、この条件を満たす $ \{1,\ 2,\ 3\} $ 上の関数は $ 9 $ 通りあります。 - 関数 $ f $ が数列 $ (1,\ 1,\ 2) $ を逆にするための必要十分条件は $ f(1)=2 $ かつ $ f(1)=1 $ かつ $ f(2)=1 $ で、この条件を満たす関数はありません。 - 関数 $ f $ が数列 $ (1,\ 2) $ を逆にするための必要十分条件は $ f(1)=2 $ かつ $ f(2)=1 $ で、この条件を満たす $ \{1,\ 2,\ 3\} $ 上の関数は $ 3 $ 通りあります。 - 関数 $ f $ が数列 $ (2) $ を逆にするための必要十分条件は $ f(2)=2 $ で、この条件を満たす $ \{1,\ 2,\ 3\} $ 上の関数は $ 9 $ 通りあります。 よって、答えは $ 9\ +\ 9\ +\ 0\ +\ 9\ +\ 3\ +\ 9\ =\ 39 $ です。

### Sample Explanation 2

$ 998244353 $ で割ったあまりを取るのを忘れないようにしてください。

## 样例 #1

### 输入

```
3 3
1 1 2```

### 输出

```
39```

## 样例 #2

### 输入

```
20 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20```

### 输出

```
326566600```

## 样例 #3

### 输入

```
46 128
109 98 111 106 103 46 51 46 58 50 49 51 106 102 108 108 106 111 48 116 117 116 102 117 111 112 100 48 113 107 47 115 102 101 112 100 117 98 48 48 59 116 113 117 117 105```

### 输出

```
249064602```

# 题解

## 作者：Inui_Sana (赞：3)

没人写题解，丢一篇来。

首先容易发现，若 $P$ 某些对应位置的限制之间有矛盾，则 $f(P)=0$，否则设 $c$ 为其中元素数量，则 $f(P)=m^{m-c}$。

发现 $Q_{P_i}=P_{i-len+1}$ 这样的限制相当于，每个在序列中的元素都和与它**对称位置**的元素形成双射。对称位置，很难不联想到回文串。回文串上的计数问题，很难不想到 manacher。

以下 $l,mid,r$ 均为 manacher 中记录的信息。

于是考虑这个问题是否为一个 manacher 能解决的问题。manacher 的核心操作就是，找到当前位置 $i$ 关于 $mid$ 的对称点，再将 $mid$ 的信息继承过来。那么到这题，容易发现是对双射后的结果在进行一次双射，显然还是一个双射，于是可以用 manacher 类似的方式处理。

然后具体考虑怎么处理。先处理合法的区间。设 $f_i$ 为 $i$ 点的最长合法半径。则若 $i+f_{mid\times 2-i}\le r$，则可以直接继承 $mid\times 2-i$ 的信息。

否则，发现如果按照常规的 manacher 一样，先将 $f_i$ 设为 $r-i$，我们则需要知道 $[i\times 2-r,r]$ 区间内的信息，才能继续往后推。但是我们显然是不知道的，怎么办呢？

此时发现一个性质：所有这样的超出 $r$ 的 $[r+1,i+f_{mid\times 2-i}]$ 的区间的长度总和**不会超过 $n\times 2$**。

证明：设 $j=mid\times 2-i$，首先如果想让上述区间尽可能大，$f_j$ 一定尽可能大，即 $j+f_j=r$。此时有；$i+f_j-r=l-(j-f_j)=2(mid-j)=2(i-mid)$。同时，处理完这 $f_i$ 后，$i+f_i\ge r$，一定可以把 $mid$ 设为 $i$，于是每次要处理的 $i+f_j-r$ 这一段长度 $\le$ 两倍的 $mid$ 的总移动次数，也就是 $2n$。得证。

于是，每次有 $i+f_j>r$ 时，先暴力地处理出 $f_j$ 去掉超出的部分后，得到的值，再依次尝试加入 $[r+1,i+f_j]$ 中的位置后是否合法。

但是此时我们只知道每个位置的最长合法半径，还没记录答案。但是很难不发现这是 trivial 的。对每个位置记录最长合法半径对应的答案，然后操作无非就是三种：继承某个位置的信息，或者加/删一个位置。随便维护一下就好了。

时间复杂度 $O(n)$ 或 $O(n\log n)$，取决于你是否预处理快速幂。我比较懒所以没预处理。

code：

```cpp
int n,m,a[N],pre[N],suf[N],lst[N];
int c[N],f[N],g[N];
il int Mod(int x,int y){
	return x+y>=mod?x+y-mod:x+y;
}
il int qpow(int x,int y){
	int ret=1;
	while(y){
		if(y&1){
			ret=1ll*ret*x%mod;
		}
		x=1ll*x*x%mod,y>>=1;
	}
	return ret;
}
il bool check(int l,int r){
	if(l<1||r>n){
		return 0;
	}
	if(pre[r]<=l&&suf[l]>=r){
		return 1;
	}
	if(pre[r]>l){
		return a[l+r-pre[r]]==a[l];
	}
	return 0;
}
void Yorushika(){
	read(n,m);
	a[1]=0;
	rep(i,1,n){
		read(a[i+i]);
		a[i+i+1]=0;
	}
	n=n+n+1;
	rep(i,1,n){
		pre[i]=lst[a[i]];
		lst[a[i]]=i;
	}
	mems(lst,0x3f);
	drep(i,n,1){
		suf[i]=lst[a[i]];
		lst[a[i]]=i;
	}
	int mid=0,l=0,r=0,ans=0;
	rep(i,1,n){
		int p=mid*2-i;
		c[i]=1;
		if(a[i]){
			g[i]=qpow(m,m-1);
		}
		if(i<=r){
			f[i]=f[p],c[i]=c[p];
			g[i]=g[p];
			if(i+f[p]>r){
				rep(j,p-f[p],l-1){
					if(a[j]){
						g[i]=Mod(g[i],mod-qpow(m,m-c[i]+1));
					}
					if(suf[j]>p+p-j){
						c[i]--;
					}
					if(pre[p+p-j]<=j){
						c[i]--;
					}
				}
				rep(j,r+1,i+f[p]){
					if(!check(2*i-j,j)){
						f[i]=j-i-1;
						break;
					}
					if(pre[j]<=i+i-j){
						c[i]++;
					}
					if(suf[i+i-j]>j){
						c[i]++;
					}
					if(a[j]){
						g[i]=Mod(g[i],qpow(m,m-c[i]+1));
					}
				}
			}
		}
		if(i+f[i]>=r){
			mid=i,l=i-f[i],r=i+f[i];
		}
		while(check(i-f[i]-1,i+f[i]+1)){
			f[i]++;
			if(pre[i+f[i]]<=i-f[i]){
				c[i]++;
			}
			if(suf[i-f[i]]>i+f[i]){
				c[i]++;
			}
			if(a[i+f[i]]){
				g[i]=Mod(g[i],qpow(m,m-c[i]+1));
			}
			if(i+f[i]>=r){
				mid=i,l=i-f[i],r=i+f[i];
			}
		}
		ans=Mod(ans,g[i]);
	}
	printf("%d\n",ans);
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：daduoli (赞：2)

挺有意思的一道题，没人写题解，那我来写一发。

首先我们先来考虑我们的操作到底在干什么。

倘若我们存在一个序列 $P={1,2,3,1,2}$。

我们相当于令 $P_1=2,P_2=1,P_3=3$。

其实很容易知道就是将 $P_i,P_{len-i+1}$ 两个数绑定起来，然后 $P_i$ 这个数值的数只能匹配 $P_{len-i+1}$ 这个数值的数。

而一种方案的贡献，我们记没有被绑定过的数的个数为 $t$，那么贡献为 $m^t$，这个也是容易知道的。

接下来考虑如何解决问题。

因为我们是将 $P_i,P_{len-i+1}$ 绑定起来，假如我们有 $P_1,P_2,P_3,P_4,P_5$，倘若我们把 $P_2,P_3,P_4$ 这个的序列抽出来做上面的操作就已经不合法了，那么这时候再加上 $P_1,P_5$ 也肯定是不合法的。

所以我们考虑按照序列长度从小到大做，而倘若当前序列长度合法，那么我们要往下继续转移，显然只有在两边加上两个数，这样我们就没有改变原本的什么信息，比较好处理。

所以我们考虑枚举中间点，记为 $mid$。

对于暴力求值是容易的，那么我们现在有一个 $O(n^2)$ 的做法，考虑如何进一步优化。

我们会发现对于绑定过的两个数，$P_i$ 一定只会匹配 $P_{len-i+1}$ 这个值，且一个数只会和一个数绑定一次，所以每个数都是一一对应的。

对于一个字符串 $S$，要求 $S_i=S_{len-i+1}$，且每个字符必须要匹配一个唯一对应的字符。

我们可以想到什么，马拉车！~~（我也不知道要怎么想到这个东西~~

你手玩一下就会发现，我们的匹配这个操作完全符合马拉车要求的性质，对于马拉车的所有操作都能适配，所以我们就可以心安理得的把马拉车套上去了。

---

接下来思考我们要干嘛。

我们先改一下上面的 $mid$ 的意义，把他变成马拉车中最靠右的回文串的回文中心，再记 $R$ 表示回文串最右边的位置。

每次向两边拓展需要知道新加进来的两个数之前有没有绑定过，如果绑定过，那么是否新加进来的两个数的绑定关系和之前相同。

对于 $i$，直接从 $2\times mid-i$ 的位置继承信息过来。

要完成第一个操作，一种想法是暴力记录所有数的匹配情况，但是显然是不行的，这样在第二个操作中信息的转移是困难的。

我们思考为什么要记录所有数的匹配情况，实际上就是拓展的时候想知道新拓展的 $P_l,P_r$ 两个点有没有匹配过。

而如果一个数出现过，那么就一定匹配过，而因为如果匹配了，那么对于所有的 $P_l,P_r$ 的匹配情况都是相同的，所以我们只需要找到一个 $P_L$ 或者 $P_r$ 即可。

所以我们考虑找离他们最近的数，记 $suf_i$ 表示最小的满足 $P_j=P_i$ 的 $j$，$pre_i$ 同理，表示最大的满足 $P_j=P_i$ 的 $j$，这样就可以很好地判定了。

具体地我们记 $f_i$ 表示以 $i$ 为匹配中心最大匹配长度，$lp_i$ 表示以 $i$ 为匹配中心最大匹配长度时有多少个数被绑定了，$sum_i$ 表示以 $i$ 为匹配中心的所有匹配方式的贡献和，然后就行了。

---


貌似到这里问题就结束了，但还有一个严重的问题。

我们马拉车中会有一个式子：

$$f_i=\min(R-i+1,f_{2\times mid-i})$$

而到了这里我们不能直接取 $\min$，如果直接取 $\min$，我们中途的需要减掉的贡献就不知道是多少了。

能不能暴力一步一步减？这是对的吗？

实际上这是对的。

考虑证明：

记 $x$ 为匹配中心，$i$ 为当前枚举点，那么 $2x-i$ 为对称的点，上面的这个结论就是 $\sum\max(0,(len_{2x-i}-(r-i+1)))=O(n)$。

设 $i-x=k$，那么因为 $x$ 为回文中心而不是 $x-k$，容易知道 $len_{x-k}<len_x+k$。

只有当 $i+len_{x-k}\ge x+len_x\Rightarrow len_{x-k}+k\ge len_x$ 时会回缩。

所以 $-k<len_x-len_{x-k}\le k$。

所以至多会回缩 $2k$，而这时回文中心会移动 $k$，所以均摊下来是 $O(n)$ 回缩。

不过要注意当等于 $i+len_i=x+len_x$ 的时候，要更新回文中心，因为只有这样我们才能保证回缩 $2k$ 的时候，回文中心移动了 $k$，而根据回文中心最多移动 $n$ 次，得到线性。

---

最后这个题就被我们解决了，时间复杂度 $O(n)$，空间复杂度 $O(n)$。

## 启示：

马拉车不一定只对于回文有用，对于与回文有类似性质的东西同样适用的。

当然马拉车的回缩时线性的这个性质挺有用。

```
#include<bits/stdc++.h>
#define Yzl unsigned long long
typedef long long LL;

using namespace std;

const Yzl Lty=20120712;

const int MAXN=6e5+10,P=998244353;
int n,m,a[MAXN],b[MAXN],cnt;
int f[MAXN],lt[MAXN],pre[MAXN],suf[MAXN],lp[MAXN];
LL pw[MAXN],sum[MAXN],ans;
LL fad(LL x,LL y) {
	return (x+y>=P?x+y-P:x+y);
}
int main () {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) {
		scanf("%d",&a[i]);
	}
	pw[0]=1;
	for(int i=1;i<=m;++i) {
		pw[i]=pw[i-1]*m%P;
	}
	b[++cnt]=0;
	for(int i=1;i<=n;++i) {
		b[++cnt]=a[i];
		b[++cnt]=0;
	}
	n=cnt;
	for(int i=1;i<=n;++i) {
		pre[i]=lt[b[i]];
		lt[b[i]]=i;
	}
	for(int i=1;i<=m;++i) lt[i]=n+1;
	for(int i=n;i>=1;--i) {
		suf[i]=lt[b[i]];
		lt[b[i]]=i;
	}
	int R=0,mid=0;
	for(int i=1;i<=n;++i) {
		if(i<=R) {
			int to=2*mid-i;
			while(i+f[to]-1>R) {
				if(!b[to+f[to]]) {
					--f[to];
					continue;
				}
				int t1=to-f[to];
				int t2=to+f[to];
				sum[to]=fad(sum[to],P-pw[m-lp[to]]);
				if(pre[t2]<=t1&&suf[t1]>=t2) {
					if(b[t1]==b[t2]) --lp[to];
					else lp[to]-=2;
				}
				--f[to];
			}
			sum[i]=sum[to];
			lp[i]=lp[to];
			f[i]=f[to];
		}
		else {
			if(b[i]) {
				lp[i]=1;
				sum[i]=pw[m-1];
			}
		}
		while(i-f[i]-1>=1&&i+f[i]+1<=n) {
			if(!b[i+f[i]+1]) {
				++f[i];
				continue;
			}
			int t1=i-f[i]-1;
			int t2=i+f[i]+1;
			if(pre[t2]<=t1&&suf[t1]>=t2) {
				if(b[t1]==b[t2]) ++lp[i];
				else lp[i]+=2;
			}
			else {
				int asd=Lty;
				if(pre[t2]>=t1) {
					asd=2*i-pre[t2];
					if(b[asd]!=b[t1]) break;
				}
				if(suf[t1]<=t2) {
					asd=2*i-suf[t1];
					if(b[asd]!=b[t2]) break;
				}
			}
			sum[i]=fad(sum[i],pw[m-lp[i]]);
			++f[i];
		}
		if(i+f[i]-1>=R) {
			R=i+f[i]-1;
			mid=i;
		}
		ans=fad(ans,sum[i]);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


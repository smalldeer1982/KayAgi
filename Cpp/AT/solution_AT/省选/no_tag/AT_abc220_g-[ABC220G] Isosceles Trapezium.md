# [ABC220G] Isosceles Trapezium

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc220/tasks/abc220_g

$ xy $ 平面上に $ N $ 個の点があり、それぞれの点に重みがついています。  
 $ i $ 個目の点の座標は $ (X_i,Y_i) $ で、重みは $ C_i $ です。

$ N $ 点の中から $ 4 $ 点を選んで、それらを頂点とする面積が正の等脚台形を作ります。  
 このとき、選んだ $ 4 $ 点の重みの和の最大値はいくつですか？

等脚台形を作ることができないときは `-1` と出力してください。

なお、等脚台形とは以下の条件を全て満たす四角形のことです。

- 台形である
- 平行な $ 2 $ つの辺のうち、$ 1 $ つの辺の両端の角が等しい

## 说明/提示

### 制約

- $ 4\ \leq\ N\ \leq\ 1000 $
- $ -10^9\ \leq\ X_i,Y_i\ \leq\ 10^9 $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- $ i\ \neq\ j $ ならば $ (X_i,Y_i)\ \neq\ (X_j,Y_j) $
- 入力は全て整数

### Sample Explanation 1

!\[\](https://img.atcoder.jp/ghi/950d55e5491c25b5776d4bec170f313a.png) 点 $ 1,2,3,5 $ を選ぶことで等脚台形を作ることができ、点の重みの和は $ 40 $ です。 それ以外の点の選び方では等脚台形を作ることはできません。

### Sample Explanation 2

!\[\](https://img.atcoder.jp/ghi/5b2010c444d75d8220a5b19a356a3ee9.png) 正方形や長方形も等脚台形に含まれることに注意してください。

### Sample Explanation 3

等脚台形を作ることはできません。

## 样例 #1

### 输入

```
5
0 3 10
3 3 10
-1 0 10
2 0 10000
4 0 10```

### 输出

```
40```

## 样例 #2

### 输入

```
6
0 1 1
1 4 20
2 7 300
5 6 4000
4 3 50000
3 0 600000```

### 输出

```
650021```

## 样例 #3

### 输入

```
7
-3 0 1
-2 0 1
-1 0 1
0 0 1
1 0 1
2 0 1
3 0 1```

### 输出

```
-1```

# 题解

## 作者：EuphoricStar (赞：1)

简单题。

首先肯定是要枚举梯形其中一条底边的两个端点的。那么另一条底边除了斜率与这条边相等，两个端点的距离要分别与这条底边两个端点的距离相等。

发现这个十分不好做，考虑一个梯形是等腰梯形的一个充要条件。不难想到，连接两底中点，这条线段垂直于两条底边。于是除了要满足斜率相等外，还要满足两个点的中点连线的斜率为底边斜率的负倒数。要限定 $\frac{y_1 - y_2}{x_1 - x_2} = k$，移项得到 $y_1 - k x_1 = y_2 - k x_2$。于是只需限定这一项相等即可。实现时可以用 map。

注意一些细节，为了避免精度问题可以自己手写分数类，而且要特殊处理底边为水平线或竖直线的情况，两底还不能共线（可以把重合的直线放一起处理）。

时间复杂度 $O(n^2 \log n)$，常数有点大。

[code](https://atcoder.jp/contests/abc220/submissions/42277478)

---

## 作者：Felix72 (赞：0)

题目让我们凑出一个点权最大的等腰梯形。

如果直接按照四个点统计，不仅超时，合法性也难以判断。但是注意到等腰梯形有一个优秀的性质：上下底中点对应的直线与底垂直，于是我们只需要维护这两个中点就行了，信息量大大减少。

然而并不是每两对中点都对应着一个梯形的。因为垂直的缘故，一个中点对应的斜率被限定了。好在这个斜率我们能提前求出来，后面分类更新答案即可。具体的，把斜率相同的中点放在一起。

这里又出现了一个问题：两个对应斜率相同的中点不一定在该斜率的一条直线上。问题出在确定一条直线需要斜率和偏移量，但这里只维护了斜率，我们把偏移量算上即可。

到这里大部分问题就解决了。唯一要注意的是两个中点若重合则梯形高为零不成立，需要特判。

不贴完整代码。以下是计算斜率、偏移量和坐标的代码，计算答案时针对每个同类点统计就好了。

```cpp
//注意代码里 delta 是特判用的，sme 才是偏移量
for(int i = 1; i <= n; ++i)
{
	for(int j = i + 1; j <= n; ++j)
	{
		++cnt;
		if(a[i].x == a[j].x)
		{
			b[cnt].k = 1e10;
			b[cnt].x = (a[i].x + a[j].x) / 2;
			b[cnt].y = (a[i].y + a[j].y) / 2;
			b[cnt].sme = b[cnt].y;
			b[cnt].delta = a[i].x;
			b[cnt].val = a[i].val + a[j].val;
		}
		else if(a[i].y == a[j].y)
		{
			b[cnt].k = 0;
			b[cnt].x = (a[i].x + a[j].x) / 2;
			b[cnt].y = (a[i].y + a[j].y) / 2;
			b[cnt].sme = b[cnt].x;
			b[cnt].delta = a[i].y;
			b[cnt].val = a[i].val + a[j].val;
		}
		else
		{
			node u = a[i], v = a[j];
			if(u.y > v.y) swap(u, v);
			b[cnt].k = (v.y - u.y) / (v.x - u.x);
			b[cnt].x = (u.x + v.x) / 2;
			b[cnt].y = (u.y + v.y) / 2;
			b[cnt].sme = b[cnt].y - b[cnt].x * (-1.0 / b[cnt].k);
			b[cnt].delta = b[cnt].y;
			b[cnt].val = a[i].val + a[j].val;
		}
	}
}
```

---


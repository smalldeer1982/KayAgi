# [AGC015D] A or...or B Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc015/tasks/agc015_d

ぬけす君は、$ A $ 以上 $ B $ 以下の整数から $ 1 $ 個以上選んで、それらの整数の bitwise or を取ってできる整数を持っています。 ぬけす君が持っている整数としてありうるものは何通りあるでしょうか。

## 说明/提示

### 制約

- $ 1\ ≦\ A\ ≦\ B\ <\ 2^{60} $
- $ A,B $ は整数である

### Sample Explanation 1

$ 7,8,9 $ のうちの $ 1 $ 個以上の整数の bitwise or で書ける整数は、$ 7,8,9,15 $ の $ 4 $ つです。

## 样例 #1

### 输入

```
7
9```

### 输出

```
4```

## 样例 #2

### 输入

```
65
98```

### 输出

```
63```

## 样例 #3

### 输入

```
271828182845904523
314159265358979323```

### 输出

```
68833183630578410```

# 题解

## 作者：灵茶山艾府 (赞：25)

首先 $[A,B]$ 范围内的每个数都可以取到，先把 $B-A+1$ 加到答案中。

由于 OR 操作不会让数字变小，接下来只需要考虑：还可以 OR 出哪些大于 $B$ 的数字？

举例说明。

```
B=1011001100
A=1010110001
```

由于 $A$ 和 $B$ 的最长公共前缀 `101` 肯定是没法改变的，干脆去掉最长公共前缀，只考虑剩余的部分。

```
B=1001100
A=0110001
```

此时 $B$ 的最高位一定是 $1$，$A$ 的最高位一定是 $0$。（如果 $A=B$，直接输出 $1$。）

### 第一类构造方案

取 $[A,B]$ 内的两个数 $x$ 和 $y$：

```
x=1000000 // 只保留最高位的 1
y=0111111 // x-1 
```

这两个数 OR 一下，可以得到最大的数 `M=1111111`。

如果继续减少 $y$，只能减少到 $A$，这意味着我们可以得到 $[x|A,M]$ 内的所有数，这一共有 $M-(x|A)+1$ 个数，加到答案中。

### 第二类构造方案

取 $[A,B]$ 内的两个数 $p$ 和 $q$：

```
p=1001000 // 保留最高位和次高位的 1
q=1000111 // p-1
```

这两个数 OR 一下，得到 `M2=1001111`。

继续减少 $q$ 可以一直减少到 $1000000$，这意味着我们可以得到 $[B+1,M_2]$ 内的所有数，这一共有 $M_2-B$ 个数，加到答案中。

### 特殊情况

如果 $A$ 最高位的 $1$ 小于等于 $B$ 次高位的 $1$，例如

```
B=1001100
A=0000100
```

这会导致 $[B+1,M_2]$ 和 $[x|A,M]$ 有交集，即 $M_2\ge x|A$。

这两个区间并起来是 $[B+1,M]$，我们可以直接把 $M-B$ 加到答案中。

代码实现时，由于这些大于 $B$ 的数的最高位都是 $1$，可以在最长公共前缀的基础上再去掉一位。

```go
package main
import(."fmt";"math/bits")

func main() {
	var low, high uint
	Scan(&low, &high)
	if low == high {
		Print(1)
		return
	}
	ans := high - low + 1
	mask := uint(1)<<(bits.Len(high^low)-1) - 1
	high &= mask
	low &= mask
	nh := bits.Len(high)
	if bits.Len(low) <= nh {
		ans += mask - high
	} else {
		ans += mask - low + 1<<nh - high
	}
	Print(ans)
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(1)$。
- 空间复杂度：$\mathcal{O}(1)$。


---

## 作者：clamee (赞：25)

之前校内考试的时候考了这个题，所以就写篇题解。

~~现在你古好像交不了 ATcoder 了~~

题目要求用$[l,r]$ 内的数可以按位或出多少不同的值。

发现对于给定的 l,r 其中它们二进制表示中相通的前缀是没用的，可以直接删掉。

假定 现在 r 有 lim 位。

那么我们可以通过 $2^{lim}$和 $[l,2^{lim} )$ 构造出 $[l+2^{lim},2^{lim+1} )$ 内的所有整数。

之后找到 r 次高位的 1 ，假设在第 k 位，这样可以通过 $[2^{lim},2^{lim}+2^{k})$ 和$2^{lim}+2^{k}$ 构造$[2^{lim} , 2^{lim}+2^{k+1})$ 的所有数。

最后还有区间 $[l,r]$

然后将以上区间取并，区间内的整数个数即为答案。

然后 $T\log _2{r}$ 求即可。

由于写的代码是校内考试的时候写的，所以一些奇怪的多组数据还在那。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define il inline
il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}
il void write(int x)
{
	if(x<0)return putchar('-'),write(-x),void();
	if(x<=9)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}
int t,n,l,r,ans;
const int M=4e18+7;
signed main()
{
//	freopen("c.in","r",stdin);
//	freopen("c.out","w",stdout);
	t=1;
	while(t--)
	{
		n=2;l=read();r=read();
		if(l==r)
		{
			puts("1");continue;
		}
		if(n==1ll)
		{
			write((r-l+1ll)%M);puts("");continue;
		}
		int rr,ll,rrr;
		int lim=62ll;
		while(lim>=0ll)
		{
			if(((l>>lim)&1ll)!=((r>>lim)&1ll))
			{
				ll=l&((1ll<<(lim+1ll))-1ll);
				rr=(1ll<<(lim))+ll;
				int tt=lim-1ll;
				while(tt>=0ll&&!((r>>tt)&1ll))tt--;
				rrr=(1ll<<lim)+(1ll<<(tt+1ll))-1ll;
				break;
			}
			lim--;
		}
		if(rrr>=rr)//区间取并
		{
			ans=(1ll<<(lim+1ll))-ll;
		}
		else
		{
			ans=(1ll<<(lim+1ll))-rr+rrr-ll+1ll;
		}
		write(ans%M);
		puts("");
	}
}
```

---

## 作者：zhimao (赞：16)

思路和官方题解一样 。
首先特判掉 $l=r$ 的情况 , 否则我们可以找出 l 与 r 在二进制下最高的不同位 。 就像这样 ：
```
1100...0    1     001...1 -> r
1100...0    0     101...0 -> l
  相同  最高不同位 剩下位
 ```
则最高位 $r$ 必为 $1$ 。此时我们再引入另一个数 $z$ ,

```
1100...0    1     001...1 -> r
1100...0    0     101...0 -> l
  相同  最高不同位 剩下位

1100...0    1     000...0 -> z
                   都为零
```
则我们可以把 $[l,r]$ 拆为 $[l,z)$ 与 $[z,r]$ 。 分开讨论 。

1.  $[l,z)$ 间相互运算 , 因为 $or$ 运算不会进位 ，也不会变小 。 所以还是得到区间 $[l,z)$ 。

2.  $[z,r]$ 间相互运算 , 我们找出 $r$ 中最高不同位以下的最高的一（设位数为 $k$ ） ， 即例子中 $r$ 的倒数第二个 $1$ ，则设数 $p$ ，
```
1100...0    1       00      1...1 -> p
  相同  最高不同位 剩下位    都是一
```

可证明只能运算得到 $[z,p]$ ， 我们可以找出这样的数
```
1100...0    1       00   1 0...0 -> x1
  相同  最高不同位 剩下位   为零 
1100...0    1       00   01 0...0 -> x2
  相同  最高不同位 剩下位    为零 
1100...0    1       00   001 0...0 -> x3
  相同  最高不同位 剩下位     为零 
......
1100...0    1       00   0...0 1 -> xn
  相同  最高不同位 剩下位 为零 
```
可拼出 $[z,p]$ ， 因为 $or$ 运算不会进位 ， 所以拼不出其他的了 。

3.  两个区间的数相互运算 ， 则为 $[l|z,z|(z-1)]$ 证法与上雷同 ， 就不写了 。

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,ans;
int main()
{
	scanf("%lld%lld",&x,&y);
	if(x==y)
	{
		puts("1");
		return 0;
	}
	long long z=y,j=0;
	for(int i=1;(1ll<<i)<=y;i++)
		if((((x&y)>>i)&1)!=(((x|y)>>i)&1)) 
		{
			z>>=i;
			z<<=i;
			j=i;
		}
	ans=z-x;
	long long l1=z,r1=z,l2=x|z,r2=z|(z-1);
	for(int i=j-1;i>=0;i--)
		if(y&(1ll<<i))
		{
			r1|=(1ll<<(i+1))-1;
			break;
		}
	if(r1<l2) ans+=r1-l1+r2-l2+2; else ans+=r2-l1+1;
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：serene_analysis (赞：7)

首先把 $A$ 和 $B$ 二进制下相同的高位全都扔掉，这里特判 $A=B$。那么现在就存在一个 $k$ 使得 $A \lt 2^k \leq B \lt 2^{k+1}$，把这个 $k$ 找出来，分类讨论我们想要构造的数的二进制下第 $k$ 位（标号从第 $0$ 位开始）是否为 $1$：

+ 如果为 $0$，那么所有不小于 $2^k$ 的数都不能使用，剩下的就是 $[A,2^k-1]$ 这个区间内的数，可以发现能构造的数不小于 $A$ 且不大于 $2^k-1$，于是这一部分的答案就是 $2^k-A$。
+ 如果为 $1$，找到 $B$ 在减去 $2^k$ 之后的最高位，设其为第 $p$ 位，那么可以发现对于所有 $q \leq p$，都有 $2^k+2^q \leq B$，也即我们可以任意选择 $\operatorname{OR}$ 上 $[2^k,2^k+2^{p+1}-1]$ 的一个数，那么此时就只需要关心 $[p+1,k-1]$ 这些位了，把 $A$ 的这些位截取出来设为 $v$，那么如果我们选择的数截取 $[p+1,k-1]$ 构成的数大于 $v$ 后面的位可以任取，否则会被 $A$ 后面的位限制，这就变成了一个子问题，可以递归求解。

设 $f(A,B)$ 表示输入 $A,B$ 的答案，有一些细节要注意：

+ 转成子问题过后，$A$ 可能为 $0$。
+ 如果 $B=2^k$，此时对于所有的在 $[A,2^k-1]$ 之内的数都可以选择 $\operatorname{OR}$ 上 $2^k$，答案可以写成 $2f(l,r-1)+[l \neq 0]$。
+ 如果截取 $A$ 得到的 $v=0$，那么答案就是 $2^{k+1}-A$。

时间复杂度 $\mathcal{O}(\log^2 V)$，其中 $V$ 为值域。

```cpp
#include<algorithm>
#include<cassert>
#include<cstdio>
#include<vector>
typedef long long ll;
const int logv=6e1+5;
ll l,r;
ll go(ll l,ll r){
	if(l==r)return 1;
	for(int i=logv-2;i>=0;i--){
		int lv=(l>>i)&1,rv=(r>>i)&1;
		if(lv&&rv)l-=(1ll<<i),r-=(1ll<<i);
		else if(lv||rv)break;
	}
//	assert(l<=r&&r!=1);
//	printf("go:%lld,%lld\n",l,r);
	ll mx=1,imx=1,icou=1;
	while(r>=mx*2)mx<<=1;
	if(r==mx)return 2*go(l,r-1)+(l!=0);
	while((r-mx)>=imx*2)imx<<=1,icou++;
//	printf("mx=%lld,imx=%lld,icou=%lld\n",mx,imx,icou);
	if(l>>icou){
		ll inc=(mx>>icou)-(l>>icou),ans=mx-l+inc*(1ll<<icou);
		return ans+(l==((l>>icou)<<icou)?(1ll<<icou):go(l&((1ll<<icou)-1),(1ll<<icou)-1));
	}
	else return mx-l+mx;
}
signed main(){
	scanf("%lld%lld",&l,&r);
	printf("%lld",go(l,r));
	return 0;
}
//namespace burningContract
```

感谢你的阅读。

---

## 作者：Lyrella (赞：2)

# 简要题意

给定一个区间 $[l,r]$，从中选出若干整数按位或，求可能出现的数的方案数。

数据范围：$1\le l\le r\le2^{60}$。

# 思路

首先对于 $[l,r]$ 里的数全都满足条件，然后因为是按位或，所以 $l,r$ 二进制下的一段前缀就与答案无关可以先去掉。

现在我们只需要考虑比 $r$ 还要大的数。去掉一段前缀后 $r$ 二进制的最高位一定是 $1$，设 $x=\operatorname{highbit}(r)$，我们可以根据 $x$ 将这个区间划分成两部分 $[l,x)$ 和 $[x,r]$。对于第一个区间里，任何数按位或答案都在第一个区间内，所以不用考虑，我们只用考虑只在第二个区间选数或者两个区间都选数。你会发现在第一个区间选多少数都可以等价为选一个数，所以其实只用考虑选两个数的情况。

1. 如果只在第二个区间选数，我们可以不看最高位的一，因为他是公共部分。假设剩下的部分为 $y$，那么在第二个区间选数就等价于在 $[0,y]$ 内选数，设 $z=\operatorname{highbit}(y)$，实际上选出来的就是 $[x,x+2z)$ 的所有数，去掉小于等于 $r$ 的答案区间就为 $(r,x+2z)$；
2. 如果在两个区间中各选一个数，我们可以发现对于第一个区间我们可以选 $[l,x)$，当第二个区间选 $x$ 的时候就可以凑出 $[x+l,2x)$ 中的所有数，答案区间就为 $[\max(x+l,r+1),2x)$。

最后只需要判断一下后两种情况是否有交集，如果有交集那么最后答案就直接为 $[l,2x)$，否则就把答案区间累加即可。时间复杂度只有 $O(\log r)$，非常优秀！

# 代码

```cpp
signed main(){
    // fileio(fil);
    l = rd(), r = rd();
    if(l == r)return puts("1"), 0;
    for(int i = 60; ~ i; --i){
        x |= r >> i << i;
        if((l >> i) ^ (r >> i))break;
    }
    y = x & - x; r += y - x;
    l += y - x; ans = r - l + 1;
    for(x = 1; x + y <= r; x <<= 1); x += y - 1;
    if((y | l) <= x)return printf("%lld", (y << 1) - l), 0;
    ans += (y << 1) - (y | l) + x - r;
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：AKPC (赞：2)

今天某十三连测（四道原题场）的第一题，场切了，赛后找到了这道题，写个题解纪念一下。

首先把 $l,r$ 转换为二进制形式，补齐 $l$ 前导 $0$ 直到 $l,r$ 位数相同。注意到前缀相同的部分毫无用处，全部去掉后 $l,r$ 开头的数字，重新赋值 $l,r$，它们开头数字必定分别为 $0,1$。

这里给出几个结论：

- $\forall a,b\in N^*,a,b\leq a\operatorname{OR}b$，显然。
- 选择一个或两个数一定可以得到所有可能的结果，因为可以不停找出其中两个数，其与范围内另一个数去参与计算等价，手玩小数据很容易发现。

令最高位为从右往左第 $k+1$ 位，依据结果最高位的值，可以进行分类讨论：

- 最高位 $0$。根据结论 $1$，只使用一个数可以达到所有可能结果，总共 $2^k-l$ 个可能结果。
- 最高位 $1$。可以用 $2^k$ 与任意整数 $i\in[l,2^k)$ 取或值，那么 $[2^k+l,2^{k+1})$ 都是可能答案。而记 $t+1$ 为 $r$ 次高的值为 $1$ 的那一位，对于任意整数 $i\in[2^k,r]$，其对于 $\leq t$ 的所有位都可能取到 $1$，故 $[2^k,2^k+2^t]$ 都是可能的结果，计算并集即可。

答案即为两个结果相加，[code](/paste/edediihw)。

---

## 作者：zh1221_qwq (赞：2)

考虑将 $l,r$ 转为二进制数。

为了方便，我们令 $h$ 为 $r$ 二进制数的最高位。

我们首先发现一个很显然的性质，$l,r$ 的相同前缀可以一起去掉。因为值在 $l,r$ 的范围内，$l,r$ 的相同前缀也是任意值的前缀，或起来的值也有这个前缀，不影响结果。

我们还有一个性质，就是或不会使答案变小，所以答案最小值不会小于 $l$。最大值又不会超过 $2^{h+1}$，因为没有值 $h+1$ 位为一。

### case1
我们先统计位数比 $h$ 小的或值。

由于第二条性质，我们可以证明答案肯定是小于等于  $2^{h}-l$ 的。又因为每个在 $l$ 到 $2^{h}-1$ 的值自己拿出来就是符合的，所以这一部分答案就是 $2^{h}-l$。

### case2

我们再考虑位数为 $h$ 的情况。我们可以先算出 $r$ 的第二高位 $se$，我们发现对于小于 $se$ 的位总存在一个在范围内的数使得只有 $h$ 和这一位上为一。

那么对于任意的小于 $2^{h}+2^{se+1}$ 的数，都存在一种组合使得或的值为它。

举个栗子，我们的 $r$ 为 $1001001$，则 $1001101$ 可以由 $1001000$，$1000100$，$1000001$ 或成。答案再加上 $2^{se}$。

但我们这样考虑还不完整，上面只统计了 $h$ 位或的情况。还有可能是 $h$ 位的与非 $h$ 位的或。又因为第二条性质，所以或值一定大于等于 $l+2^{h}$，小于 $2^{h+1}$。且这个区间是连续的，所以答案为 $2^{h}-l$。

最后上两种情况可能重复，所以容斥一下就完了。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,l,r,x[65],y[65],hl,hr,f[65]={1},se;
signed main(){
    cin>>l>>r;
	if(l==r){//亲测过，不特判WA30 
		cout<<1;
		return 0;
	}
	for(int i=1;i<=60;i++)f[i]=f[i-1]*2;//(1<<i)是int 
	int ls=l;
	for(int i=59;i>=0;i--)//分解成二进制数 
		if(ls>=f[i]){
			x[i+1]=1ll;
			ls-=f[i];
			hl=(!hl)?(i+1):hl;
		}
	ls=r;
	for(int i=59;i>=0;i--)
		if(ls>=f[i]){
			y[i+1]=1ll;
			ls-=f[i];
			se=((!se)&&(hr))?(i+1):se;
			hr=(!hr)?(i+1):hr;
		}
	if(hl==hr){//有同样前缀 
		for(int i=hr;i>=1;i--){//删去同样前缀 
			if(x[i]!=y[i])break;
			if(x[i]==1)l-=f[i-1];
			if(y[i]==1)r-=f[i-1];
		}
		ls=l;
		hl=0;
		hr=0;
		se=0;
		for(int i=59;i>=0;i--)
			if(ls>=f[i]){
				ls-=f[i];
				hl=(!hl)?(i+1):hl;
			}
		ls=r;
		for(int i=59;i>=0;i--)
			if(ls>=f[i]){
				ls-=f[i];
				se=((!se)&&(hr))?(i+1):se;
				hr=(!hr)?(i+1):hr;
			}
		}
		cout<<2*(f[hr-1]-l)+min(l,f[se])<<"\n";
	return 0;
}
```
## 闲话

做到这道题是因为花钱买了某熊的 NOIP13 连测，结果 Day 5 考了 3 道原，T3 搬题人还搬错题意了，但是场切了这道题，这篇题解也算记录一下我场切的第一道紫吧。

---

## 作者：_Cheems (赞：1)

闲话：考场做法，比较奇怪。

为了方便起见，令 $l\gets l-1,r\gets r+1$，求 $(l,r)$ 的答案。

套路的，考虑将区间内的数划分区间。

从高位向低位看，首先去掉 $l,r$ 的相同前缀，然后将数分为第一位为 $0$ 和第一位为 $1$ 的，记为 $0$ 类数和 $1$ 类数。

对于 $0$ 类数可以分为 $\log$ 个区间，具体而言，其实就是最高位到第 $i$ 位与 $l$ 一样，然后第 $i-1$ 位是 $1$（$l$ 第 $i-1$ 位是 $0$），这样 $[0,i-2]$ 位就能随便取。

![](https://cdn.luogu.com.cn/upload/image_hosting/jucixjr6.png)

划分如上图，注意到假如选取了集合 $i$，那么没有必要选集合 $i<j$ 了，因为没影响。记下 $a_i$ 表示第 $i$ 个集合在 $[0,i)$ 位可以随便取。那么只选 $l$ 集合的数，也就是令最高位为 $0$ 的方案为 $\sum 2^{a_i}$。

对于 $1$ 类数也同理，划分如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/sa0e8x36.png)

记集合 $1$ 在 $[0,i)$ 位可以随便取，那么只用它可以凑出所有数 $x$，$x$ 满足其最高位为 $1$，然后一直到 $i$ 位都是 $0$，第 $[0,i)$ 位随意。注意到其它集合的唯一作用是与集合 $1$ 搭配，使得 $x$ 的第 $i$ 位也可以为 $1$。

综上，$1$ 类数可以凑出的数形如：最高位为 $1$ 然后跟着若干个连续 $0$，之后 $[0,k)$ 位随便取。总数为 $2^k$。

现在考虑同时选了 $0$ 类数和 $1$ 类数。实际上就是在 $0$ 类数的基础上，令最高位为 $1$，然后允许第 $[0,k)$ 位可以放 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/tu3srgec.png)

首先假如 $1$ 类数除了最高位都是 $0$，那么就有 $\sum 2^{a_i}$ 种方案。可以发现，假如 $1$ 类数除了最高位还存在一个 $1$，那么一定会算重，所以不用考虑。

结束了吗？没有，刚刚还是会算重，具体来说，假如选取的 $0$ 类数集合最高位到第 $p$ 位都是 $0$，那么在 $p\le k$ 时就会和“只选 $1$ 类数”的方案重复。这也很好理解，因为它不会改变最高位到第 $k$ 位的状态。也就是说我们只在 $p>k$ 时统计即可。

复杂度 $O(\log V)$。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N = 62;
int T, a, b, ans, pw[N], c;
vector<pair<int, int> > A;
vector<int> B;

inline int get(int x, int p) {return (x >> p) & 1;}
inline int dif(int a, int b){
	for(int i = 60; i; --i)
		if(get(a, i) ^ get(b, i)) return i;
}
signed main(){
	pw[0] = 1;
	for(int i = 1; i < N; ++i) pw[i] = pw[i - 1] * 2ll;
	
	scanf("%lld%lld", &a, &b), --a, ++b;
	ans = 0, A.clear(), B.clear();
	int pos = dif(a, b); //第一个不同的位
	for(int i = pos - 1, pd = -1; ~i; --i){
		if(!get(a, i)) A.push_back({i, max(pd, i)}); //0类数集合，二元组(x,y)表示[0,x)位随便取，最高位的1在第y位
		if(get(b, i)) B.push_back(i); //1类数集合
		if(pd == -1 && get(a, i)) pd = i;
	}
	for(auto i : A) ans += pw[i.first]; //计算只选0类数
	if(B.empty()) printf("%lld\n", ans); //假如不存在1类数
	else{
		c = B[0] + (B.size() > 1); //计算只选1类数
		ans += pw[c];
		for(auto i : A)	if(i.second >= c) ans += pw[i.first]; //计算同时选0,1类数
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：Rem_CandleFire (赞：1)

**题目大意**

在区间 $[L,R]$ 中选择任意多个数进行按位或，求可能的结果的数量。$1\le L\le R\le 2^{60}$。

**分析与做法**

非常好的构造，使我的大脑旋转。

因为按位或操作不会使数变小，于是考虑如何构造出大于 $R$ 的结果。首先将 $L,R$ 二进制表示的相同前缀去掉，此时 $R$ 最高位为 $1$，$L$ 对应位置为 $0$。接下来可以从是否保留 $L$ 的最高位进行讨论。

如果保留，那么有如下构造：
```
R=100010101101
L=001000010100
D=111111111111
X=100000000000
```
如上，$D$ 是可以构造出的最大值，$X|L$ 是可以构造出的最小值，在区间 $[X|L,D]$ 中的数都是可以被构造的。

如果不保留，那么有如下构造：
```
R=100010101101
L=001000010100
Y=100010000000
F=100011111111
```
如上，$F$ 是可以构造出的最大值，$R$ 是可以构造出的最小值，在区间 $[R,F]$ 中的数都是可以被构造的。

特殊的，$[L,R]$ 本身也是可以被构造的。所以答案就是三个区间交集内的数的数量。实现是简单的，时间复杂度 $O(\log V)$。

---

## 作者：wjh2022 (赞：1)

约定：

设 $l$，$r$ 分别为选择的整数中，最小的和最大的整数。

在一个数的二进制表示中，若 $\dots$ 的左右两边的数字相等，则这一段内，每一位上的数字，均与 $\dots$ 左右两边的数字相等。

在二进制下，位数为「形式化表示」中从右往左的位。最右边（表示奇偶性的位）的位数为 $0$。

设 $p$ 为满足「小于 $r$」，「可以表示为 $2^{k} - 1$，$k \in N$」和「$r$ 的第 $k$  位为 $1$」这三个条件的最大数。

---

观察题目，发现有一个比较显然的性质：因为或运算满足答案不小于参与运算的任意数，或起来之后的数必定不小于 $l$。

由于我们要考虑两者或起来的结果，故不妨将 $l$，$r$ 转化为二进制数。

我们发现，对于一般的情况，我们是很难搞的。故不妨从更为简单的情况入手。我的切入点如下：

> $l$ 的 $2$ 进制表示：$\texttt{100\dots00\dots00}$
> 
> $r$ 的 $2$ 进制表示：$\texttt{100\dots001\dots}$
>
> $l$ 与 $r$ 的位数相等，且 $r$ 的第二个 $1$ 后为任意数

此时，我们发现，只需选取三个数，其中一个为 $l$，另两个为特定值，或起来后就可以组成介于 $\texttt{100\dots00\dots00}$ 和 $\texttt{100\dots011\dots11}$ 两个数间的所有数。

接下来，我们发现每一个 $r$，都存在唯一的 $l$ 与之构成「特殊情况」，不妨设这个特殊的 $l$ 是 $l_1$，则我们可以把实际的 $l$ 分为如下两种情况：

1. $l \ge l_1$

2. $l < l_1$

### case1

对于这种情况，打表或分析即可发现它很难搞。但我们发现，由于 $l_1$ 和 $r$ 在二进制表示下的位数相等，故此时 $l$ 和 $r$ 在二进制表示下的位数也相等。

故有：对于每一个被统计的数，它的「二进制位数」和 $r$ 的「二进制位数」也相等。

那么我们显然就可以将最高位删掉。

此时，$l$ 和 $r$ 将转化为两种情况：

1. $l = r$，直接输出 $1$ 即可。

2. $l \neq r$，不断删掉最高位，直到情况转化为 case2。

### case2

通过前文的分析，我们已经统计了只有 $l_1$，$r$ 之间的数时的答案。

我们发现，此时，对于所有在属于区间 $[p + 1,l_1 - 1]$ 的数，它对于答案的贡献为 $2$。设这个数为 $\texttt{0\dots01\dots}$，则它产生的贡献分别对应着数 $\texttt{0\dots01\dots}$ 和 $\texttt{10\dots01\dots}$。由于区间内的数都大于 $p$，故产生贡献的两个数都没有被计算过。

而对于小于等于 $p$ 的数，由于任意数与它进行「或运算」后的值都已经被统计过，故它们的贡献为 $1$，该贡献对应这个数本身。

计算不同区间内的数的数量和贡献即可。复杂度 $O(\log r)$。题解的代码是校内模拟赛中写的，实现较劣，复杂度为 $O(\log^2r)$。

code：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
const int N = 1e5 + 5;

int T, l, r;
int getl, getr, tmpl, tmpr;	// getl 和 getr 分别存储 l 和 r 的位数 
int mul[N], a[N], b[N];

int get(int x) {
	// 获得 x 的二进制位数。 
	int res = 1, ans = -1;
	while (x >= res) {
		ans ++ ;
		res *= 2;
	}
	return ans;
}

void init() {
	// 初始化，a 中保存 l 的二进制形式，b 中保存 r 的二进制形式。 
	tmpl = l, tmpr = r;
	for (int i = getl; i >= 0; i -- ) {
		if (tmpl >= mul[i])	{
			a[i] = 1;
			tmpl -= mul[i];
		} else {
			a[i] = 0;
		}
	}
	for (int i = getr; i >= 0; i -- ) {
		if (tmpr >= mul[i]) {
			b[i] = 1;
			tmpr -= mul[i];
		} else {
			b[i] = 0;
		}
	}
}

signed main() {
	mul[0] = 1;
	for (int i = 1; i <= 62; i ++ )	mul[i] = mul[i - 1] * 2;
	// mul[i] 中存储 2^i 
	
	scanf("%lld%lld", &l, &r);
	getl = get(l), getr = get(r), tmpl = l, tmpr = r;
	init();
	
	while (getl == getr && l != r) {
		// 将 case1 转换为 case2，实现原因，这部分的时间复杂度是 O(log^2r) 
		l -= mul[getl], r -= mul[getr];
		if (l > r)	swap(l, r);
		getl = get(l), getr = get(r);
	}
	
	init();
	int ans = 0, k, p;
	if (l == r) {	// 特殊情况 
		puts("1");
	} else {
		k = getr;
		for (int i = getr - 1; i >= 0; i -- ) {
			if (b[i] == 1) {
				k = i;
				break;
			}
		}
		
		if (k == getr)	p = 0;
		else	p = mul[k + 1] - 1;
		ans += (p + 1);	// 统计位数和 r 相同的数的贡献 
		
		if (p < l) {
			ans += (mul[getr] - l) * 2;	// 统计「贡献为 2 的数」的贡献
		} else {
			ans += (mul[getr] - 1 - p) * 2;	// 统计「贡献为 2 的数」的贡献 
			ans += (p - l + 1);	// 统计其余部分的贡献
		}
		printf("%lld\n", ans);
	}
	
	return 0;
}
```

---

## 作者：Garbage_fish (赞：0)

> *思路一小时，*
>
> *oo 不慎开太小，*
>
> *调题三个钟。*
>
> *——Garbage_fish 于 2024/11/13 21:41*

神秘「找规律」做法。

## Part 1 观察 $2$ 的幂

```
0001 
0010 0011 
0100 0101 0110 0111 
1000 
```


首先假设没有左边界研究一下，观察 $4,8,16$ 这种 $2$ 的幂，如上图所示。举 $4$ 为例，你会发现和 $4$ 一样位数的数，都可以通过 $4$ 或上 $4$ 以前的数得到，且这样或出来的数是不重不漏的。而和 $4$ 一样位数的数之间，互相或也只能得到和 $4$ 一样位数的数，因此可以只枚举 $2$ 的幂。

```
0110 0111 
1000 1001 1010 1011 ... 1110 1111
10000
```

但现在有了左边界，假设是 $6$，如上图所示，你会发现通过 $8$ 或 $8$ 以前的数，只能取到 $8\times 2-2 \sim 8\times 2-1$，原因是 $8-6=2$，即当前枚举的次幂减去左边界（可以或上的数）。

这样子就会漏掉 $8+1\sim 8\times 2-3$ 的所有数，但显然这个 $3$ 可以算出来，加上这一部分的答案即可。

## Part 2 处理左边

这种处理 $2$ 的幂及其后面的做法，显然会漏掉左边界到左边界后面第一个 $2$ 的幂中间的数，还是如上例，$6\sim 7$ 就被漏掉了。

```
100100 100101 100110 100111
101000 101001 ... 101100 101101 101110 101111
```

观察第一行和省略号后面的数，会发现什么？$(101000)_2$ 或上第一行的数可以得到省略号后面的数！两行的第一个数什么关系？加上 $\operatorname{lowbit}$ 的关系！所以对于处理左边的，可以像处理 $2$ 的幂的一样，从左区间开始不断增加 $\operatorname{lowbit}$ 即可。

这是什么原理呢？加 $\operatorname{lowbit}$ 相当于固定前面若干位，而后面几位显然又能构成“$2$ 的幂”形式。

然后你会发现，对 $2$ 的次幂乘 $2$，也是相当于加 $\operatorname{lowbit}$。由于这两部分更新答案原理一样，所以 Part 1 和 Part 2 只需一个循环即可搞定！

## Part 3 处理右边

```
1000 1001 1010
```

如上例，询问的区间是 $[8,10]$，而 $8$ 只能算出来它自己的一个答案，而 $9$，$10$ 乃至 $9$ 或 $10$ 就被忽略了（显然 $8+\operatorname{lowbit(8)}>10$），怎么办？

可以把左边界移动到这个加上 $\operatorname{lowbit}$ 就超出范围的 $8$ 的后一位，对 $[8+1,10]$ 进行和处理左区间相同的操作即可。

```
011
100 101 110 111
```

又会发现一个问题，如上例，询问的区间是 $[3,7]$，而 $7$ 已经被 $4$ 或上 $3$ 算过了，计算区间 $[5,7]$ 显然 $7$ 又会被算若干次。所以对于「左边界移到 $x$ 的后一位」操作，需要处理出 $x$ 本来已经算到的地方 $ed$，这样子处理后面的东西时如果算到了 $ed$ 就不要加上那一部分的。

然后就没了，实现的时间复杂度瓶颈是 $\operatorname{lowbit}$，可能略大于 $O(\log (r-l))$，「使用 $4$ 个空格而不是制表符缩进」的代码仅 $694\operatorname{B}$（除注释）。

```cpp
#include <bits/stdc++.h>
#define int long long
#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;
int l, r;
int lowbit(int x) {
    return x & -x;
}
signed main() {
    IOS;
    cin >> l >> r;
    int i = l, ed = 9e18, ans = 0; // 初始 ed 要开 9e18，因为 1e18 < 2 ^ 60。
    for (; i <= r;) {
        if (i + i - l >= ed) // i 算的东西超过了 ed，已经被算过了。
            ans += max(0ll, ed - i);
        else // i 能算出哪些数？
            ans += i - l + 1;
        if (i + lowbit(i) > r) { // 移动左边界，并重新计算 ed。
            ed = (i + lowbit(i)) - (i - l);
            l = i = i + 1;
        } else {
            ans += max(0ll, min(r, (i + lowbit(i)) - (i - l) - 1) - i); // 有哪些被漏算了？
            i += lowbit(i);
        }
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/AT_agc015_d)

**题目大意**

> 在 $[l,r]$ 的元素中选出一个子集 $S$，求 $S$ 中元素按位或有多少种不同取值。
>
> 数据范围：$l,r<2^{60}$。

**思路分析**

首先 $[l,r]$ 内的元素肯定能得到，只需要考虑 $>r$ 的元素有哪些能得到。

对于 $l,r$ 二进制下的一段公共前缀，很显然不会影响答案，可以去掉。

此时设 $r$ 的最高位为 $x$，次高位为 $y$，很显然 $l<2^x$。

那么我们把元素分成 $[l,2^x)$ 和 $[2^x,r)$ 两部分。

如果不选第一部分的元素，那么能得到的元素就是 $[2^x,2^x+2^{y+1}-1]$，否则得到的元素就是 $[2^x+l,2^{x+1}-1]$。

取出这两部分元素的并，并且和 $(r,2^{x+1}-1]$ 取并得到答案。

时间复杂度：$\mathcal O(1)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int d(ll x) { return x?63-__builtin_clzll(x):-1; }
signed main() {
	ll A,B;
	scanf("%lld%lld",&A,&B);
	if(A==B) return puts("1"),0;
	ll ans=B-A+1,i=d(A^B),S=(1ll<<i)-1;
	A&=S,B&=S;
	if(d(A)<=d(B)) ans+=S-B;
	else ans+=S-A+(1ll<<(d(B)+1))-B;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：肖翔 (赞：0)

给一个相对好想的思路和写法，和现在大部分做法可能存在思路上不同，本质是**类似**陈丹琦分治的分类处理。

对于位运算问题，容易想到按位考虑。

首先判掉 $l=r$ 的情况再开始做。

如果 $l,r$ 最高位相同，那么无论怎么或，最高位都不会变，所以最高位对答案数没有贡献。可以把最高位删掉然后递归处理。


然后一定存在某一位 $k$，使得 $r$ 的第 $k$ 位为 $1$，而 $l$ 的第 $k$ 位为 $0$。（因为此时 $r>l$）

我们对 $[l,2^k-1]$ 和 $[2^k,r]$ 分开考虑。（分类依据是第 $k$ 位是否为 $1$。）

一：

只有 $[l,2^k-1]$ 中的数内部去或，可以发现或出来的一定只有 $[l,2^k-1]$。因为或运算是不进位的加法，数字不会变小也不会超过 $2^k$，一定在该区间里。



二： 

存在 $[2^k,r]$ 中的数参与到了或运算中。那么一定是 $[l,2^k-1]$ 中的若干数和 $[2^k,r]$ 中的若干数或在一起。（第一部分可以全都不选，第二部分至少选一个。）

那么或出来的数第 $k$ 位一定为 $1$，且一定是最高位。既然如此，可以考虑去掉第 $k$ 位再来考虑（思维过程同最开始的删位）。

不妨令 $r'=r-2^k$，以下把 $ r'$ 称作了 $r$。

于是两个区间就变成了 $[0,r]$ 与 $[l,2^k-1]$（第二个区间里的数第 $k$ 位为 $0$，所以完全没受影响。）

可以发现这就是 $[0,2^k-1]$ 的某前缀和某后缀。可以动态规划来求两个区间内的数可以或出的结果，但我们有更优美的方法。

1. 考虑 $[0,r]$ 内部可以或出哪些数。打个表或分析一下可以发现是大于 $r$ 	的第一个 $2$ 的次幂减去 $1$。即代码中的 ```pre()```。 证明比较容易，放在最后了。

2. 考虑 $[l,2^k-1]$ 内部或出来的，发现和“一”中的讨论一模一样，就是 $[l,2^k-1]$ 内部的数字。

3. 左右两个区间各取若干数字（数量大于 $0$），假设在第二个区间里取了一个数 $n$，最后或出来的数字为 $m$。那么 $m$ 一定满足 $m \ge n \ge l$，而且因为没有进位， $m \le 2^k-1 $。这说明什么什么？这说明 $m \in [l,2^k-1]$ 啊！！！所以这种情况得出的数字一定是情况 $2$ 中可以得到的数的子集。反正最后是并起来，所以可以当作情况 $3$ 不存在了！（就是说任意数和后缀取或一定还在后缀里）

4. 综上，我们很好地解决了情况 $1,2$，并把情况 $3$ 并到了情况 $2$ 里。记情况 $1$ 的答案区间为 $[0,ans]$，那么这个答案就是 $[0,ans]\cup[l,2^k-1]$。

综上，我们的答案范围即为 $[l,2^k-1]\cup[2^k,2^k+ans]\cup[2^k+l,2^k+2^k-1]$

第一个范围和后两个显然没有交集，对它单独计大小再对 $[0,ans]\cup[l,2^k-1]$ 求大小（一个 $\min$ 的事~）最后求和即可。

给下代码，注意边界处理。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int cal(int x){//统计x的最高位是第几位，最低位为0，0的位记为-1!!
	int ans=-1;
	while(x){
		ans++;
		x>>=1;
	}
	return ans;
}
int s[300],top;int po[300];
inline int del(int x){//暴力地去掉最高位
	top=0;
	while(x){
		s[++top]=x%2;
		x/=2;
	}
	int ans=0;
	top--;
	while(top>0){
		ans+=po[top-1]*s[top];
		top--;
	}
	return ans;
}
inline int pre(int x){//求[0,r]可以或出的答案
	int ans=1;
	while(ans<=x)ans*=2;
	return ans-1;
}
inline int solve(int l,int r){//递归去最高位然后做
	if(cal(l)==cal(r)){
		if(l==r)return 1LL;
		return solve(del(l),del(r));
	}
	int ans=0;
	ans+=po[cal(r)]-l;
	int zr=pre(del(r))+1,yl=po[cal(r)]-1-l+1;
	ans+=min(zr+yl,po[cal(r)]);
	return ans;
}
signed main(){
	int l,r;
	po[0]=1;
	for(int i=1;i<=65;i++)po[i]=po[i-1]*2;//预处理次幂
	cin>>l>>r;
	cout<<solve(l,r);
	
}
/*
1134006168159047386
1134006168159047387
*/
//一份我之前没处理好然后WA的数据
```





------------

文中的证明：对于 $[0,r]$，记我们找到的次幂次数为 $k$，那么 $2^0,2^1...\ 2^{k-1}$ 都在 $[0,r]$ 之中。那么 $[0,2^k-1]$ 都是可以被或出的，而且更大的需要进位，显然或不出来。这就得证了。

---


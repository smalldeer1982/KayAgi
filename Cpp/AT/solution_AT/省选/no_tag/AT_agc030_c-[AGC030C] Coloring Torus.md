# [AGC030C] Coloring Torus

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc030/tasks/agc030_c

$ n\ \times\ n $ のマス目に対して，上から $ r+1 $ 行目，左から $ c+1 $ 列目にあるマスを $ (r,\ c) $ で表します． このマス目の $ K $ 色でのよい塗り方とは，次のような塗り方を言います：

- それぞれのマスは $ K $ 色のいずれかで塗られている．
- $ K $ 色のうちすべての色が，いずれかのマスに塗られている．
- $ K $ 色にそれぞれ $ 1,\ 2,\ ...,\ K $ の番号をつける．任意の色 $ i,\ j $ ($ 1\ \leq\ i\ \leq\ K,\ 1\ \leq\ j\ \leq\ K $) に対して，色 $ i $ のマスに接している色 $ j $ のマスの個数は，色 $ i $ のマスの選び方によらず等しい．ここで，マス $ (r,\ c) $ に接しているマスは，$ ((r-1)\;\ mod\;\ n,\ c),\ ((r+1)\;\ mod\;\ n,\ c),\ (r,\ (c-1)\;\ mod\;\ n),\ (r,\ (c+1)\;\ mod\;\ n) $ とする (これら $ 4 $ つの中に同じマスが複数回現れる場合は，そのマスの色は重複している回数だけ数えるものとする)．

$ K $ が与えられたとき，**$ 1 $ 以上 $ 500 $ 以下の $ n $** を自由に選んで，$ n\ \times\ n $ のマス目の $ K $ 色でのよい塗り方を構成してください． この問題の制約の下，これは常に可能であることが証明できます．

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ 1000 $

### Sample Explanation 1

\- どの色 $ 1 $ のマスも，$ 3 $ 個の色 $ 1 $ のマス，$ 1 $ 個の色 $ 2 $ のマスと接しています． - どの色 $ 2 $ のマスも，$ 2 $ 個の色 $ 1 $ のマス，$ 2 $ 個の色 $ 2 $ のマスと接しています． 次のような出力は不正解となります： ``` 2 1 2 2 2 ``` ``` 3 1 1 1 1 1 1 1 1 1 ```

## 样例 #1

### 输入

```
2```

### 输出

```
3
1 1 1
1 1 1
2 2 2```

## 样例 #2

### 输入

```
9```

### 输出

```
3
1 2 3
4 5 6
7 8 9```

# 题解

## 作者：CYJian (赞：14)

首先，对于 $k \leq 500$，我们可以像下面这样无脑构造解：

```plain
k
1 1 1 ... 1
2 2 2 ... 2
3 3 3 ... 3
. . . ... .
. . . ... .
. . . ... .
k k k ... k
```

然后考虑 $k > 500$ 怎么办。

用上面的办法肯定没法搞。考虑斜着填数：

```plain
1 2 3 4 ... n
2 3 4 ... n 1
3 4 ... n 1 2
4 ... n 1 2 3
. ... . . . .
. ... . . . .
. ... . . . .
n 1 2 . . . n-1
```

这样填出来也是合法的。考虑对这个下手：

比如一个 $n=4$ 的矩阵：

```plain
1 2 3 4
2 3 4 1
3 4 1 2
4 1 2 3
```

我们考虑随便钦定一斜行，让它加入一个新数字，和原有的数字交替出现：

```plain
1 2 3 4
2 3 5 1
3 4 1 2
5 1 2 3
```

不难发现，这样也一定是合法的。然后我们还可以选择更多的斜行进行此操作。不难发现，我们用这个方法能加入的数字个数就是 $2n$ 级别的，正好能完成题目的要求。

然后这题就做完了。

$\rm Code$：

```cpp
int nx[510];
int A[510][510];

int main() {
	int k = ri;
	if(k <= 500) {
		cout << k << endl;
		for(int i = 1; i <= k; i++)
			for(int j = 1; j <= k; j++)
				printf("%d%c", i, " \n"[j == k]);
	} else {
		int n = 500, N = 0;
		for(int i = 1; i <= n; i++) nx[i] = i + 1;
		nx[n] = 1, cout << 500 << endl, k -= n;
		for(int i = 1; i <= n; i++) {
			int a = ++N, b = k ? ++N : N;
			k -= b - a;
			for(int x = 1, y = i; x <= n; x++, y = nx[y])
				A[x][y] = x & 1 ? a : b;
		}
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				printf("%d%c", A[i][j], " \n"[j == n]);
	}
	return 0;
}
```

---

## 作者：lzk5627 (赞：8)

先orz楼上CYJian
这题最开始的思路是对角线去填,然后发现大概就是这样的一个图

![无标题.png](https://i.loli.net/2020/02/15/2XjhuTREUS9wHKf.png)

然后突然发现如果 $n\le500$,而 $k\le 1000$ ,也就是说 $2n=k$,

~~疯狂暗示~~

那么我们考虑怎么强行加成2n
发现如果n是偶数的话,对于每一种颜色的对角线,是可以用和一种颜色交替出现的方式来添加颜色的,因为这样保证了,原来的每一个和这种颜色相关的块由有 $2$ 个颜色 $i$ 变成有一个颜色 $i$ 和一个颜色 $j$ ,这样依旧是合法的
也就是这样,**紫色**和**深蓝色**交替出现
![无标题.png](https://i.loli.net/2020/02/15/RbH5jAgEY6Q9aGq.png)

然后我们特判一下1,把 $n$ 取一个对应的偶数就好了

---

## 作者：xht (赞：5)

## [Coloring Torus](https://atcoder.jp/contests/agc030/tasks/agc030_c)

### 题意

- 对于一个 $n \times n$ 的网格，下标从 $0$ 开始，且第 $0$ 行在第 $n-1$ 行下面，列同理。
- 你要用 $k$ 种颜色对这个矩阵染色，需要满足以下条件：
  - 每个格子被染成 $k$ 种颜色之一。
  - $k$ 种颜色都染了至少一个格子。
  - 对于任意两种颜色 $i,j$，满足所有颜色为 $i$ 的格子，其上下左右相邻的颜色 $j$ 的格子数相同（如果一个格子出现多次也会被计算多次）。
- 给定 $k$，要求构造一种网格染色方案。
- $k \le 10^3$，$n \le 500$。

### 题解

设颜色为 $[0,k-1]$，考虑 $n$ 为偶数的情况，构造 $c_{i,j} = ((i + j) \bmod n)$。

注意到如果将某一种颜色加入一个新颜色与之交替，同样是合法的。

因此特判 $k = 1$ 的情况，令 $n = 2\lceil \frac k4 \rceil$ 即可。

### 代码

```cpp
int main() {
	int k;
	rd(k);
	if (k == 1) return prints("1\n1"), 0;
	int n = (k + 3) / 4 * 2;
	print(n);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++) {
			int c = (i + j) % n;
			if ((i & 1) && c + n < k) c += n;
			print(c + 1, " \n"[j==n-1]);
		}
	return 0;
}
```

---

## 作者：Mirasycle (赞：1)

对于题目要求很神秘的题，我们可以尝试从感性角度理解一下题目，其实题目的要求就是对于每个数字相同的格子，**要求他们所处的 "地位相同"(周围数字的可重集合相同)。所以相同数字的格子应该是比较对称的。**

所以我们可以给出 $k\le 500$ 的构造，就是第 $i$ 行全填 $i$。

对于 $k> 500$ 的情况，我们无法采取以上策略，因为会有若干数学无法填入了。

思考一下能否扩展，在 $4\mid n$ 的时候，我们将更大的数间隔塞入。


```latex
1 5 1 5
2 6 2 6
3 7 3 7
4 8 4 8
```

对于 $4\mid k$ 的情况，我们还是可以构造出来这么一个对称形状的。

对于 $2\mid k\wedge 4 \nmid k$ 的情况，同一行内首尾相同会造成不满足要求。

同时当 $k$ 是奇数，我们也无法完成。因为必然存在某一行无法被更大数间隔地塞入。局部结构大概是这样子地，


```latex
1 x 1 x
2 2 2 2
```


我们可以发现偶数列的 $2$ 可以被 $x$ 影响到，但是奇数列的 $2$ 无法被 $x$ 影响到。所以 $2$ 的地位不对称。

考虑如何解决这个问题，我们要通过某种手段使得统一奇偶列。可以发现如果我们将原图旋转 $45°$ 的话，原本和 $x$ 在对角线的奇数列 $2$ 就可以和 $x$ 相邻了，并且偶数列的 $2$ 还是保持相邻。而且对角线也正好保证了对称性。

先给出对角线的基本 $k\le 500$ 构造。

当 $k=6$ 的时候，大概是长这样子的，


```latex
1 2 3 4 5 6 
2 3 4 5 6 1
3 4 5 6 1 2
4 5 6 1 2 3
5 6 1 2 3 4
6 1 2 3 4 5
```


尝试加入三个数，我们就按照对角线上交替放的原则来插入新数。


```latex
1 2 3 4 8 6
2 3 9 5 7 1
3 4 8 6 1 2
9 5 7 1 2 3
8 6 1 2 3 4
7 1 2 3 9 5
```


注意就是我们默认上三角矩阵加入新的数字就是从每个斜线的第一列开始加，然后对于下三角矩阵，为了符合要求，对于第 $i$ 行，我们从 $1+(i\bmod 2)$ 列开始加。

可以发现是符合要求的。发现只有 $n$ 为偶数的时候，构造才符合要求，因此取 $n=\lceil\frac{k}{4}\rceil\times 2$。我们维护 $2n-1$ 条对角线，然后不断插入新的数，最后还原成一个正方形即可。

其实还有一种构造很精妙，那就是 $k\le 500$ 的时候 $a_{i,j}=(i+j)\bmod n$。对于 $k$ 更大的情况进行调整。这样子保证了 $a_{i,j}$ 相邻数字的一致性，不过很难想到。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=510;
typedef long long ll;
int k,a[maxn<<1][maxn],b[maxn][maxn];
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>k; int n=(k+3)/4*2,tot=2*n-1;
	if(k==1){ cout<<"1\n1"; return 0; }
	cout<<n<<endl;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++) a[i][j]=i;
	for(int i=n+1;i<=tot;i++)
		for(int j=1;j<=2*n-i;j++) a[i][j]=i-n;
	for(int i=1,cur=n;i<=k-n;i++,cur--){
		for(int j=1;j<=cur;j+=2) a[cur][j]=n+i;
		if(cur!=n) for(int j=1+(cur%2);j<=n-cur;j+=2) a[cur+n][j]=n+i;
	}
	for(int i=1;i<=n;i++)
		for(int x=i,y=1,p=1;x;x--,y++,p++) b[x][y]=a[i][p];
	for(int i=tot;i>=n+1;i--)
		for(int x=n,y=i+1-n,p=1;y<=n;x--,y++,p++) b[x][y]=a[i][p];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) cout<<b[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Felix72 (赞：1)

对于我这类构造力不强或者思维不敏捷的选手而言，用“考虑”“发现”措辞的题解未免太过残忍。实际上，这道题是可以凭借逻辑推理完成大部分思路的。

首先我们知道，题目的上下左右边界是联通的，也就是并没有真正的边界可言。因此，我们需要把限制条件转化成一个更易于理解的形式。以下是我的转化：

> 用 $k$ 中颜色填满一个**无限大**的平面，使其满足原题目限制。然后从中框一个正方形出来，要求这个正方形是平面的一个基本部分（即无线个这样的正方形可以还原出平面）。

这样就能去掉这个坐标跨越分界线的难题了。还是想不到怎么构造？我们继续逻辑推理：

对于一个 $mp_{x, y} = c$，其 $vis_{x, y, c}$ 为 $\{0, 1, 2, 3, 4\}$ 当中的其中一种。（即周围与自己颜色相同的格子个数）

- 如果 $vis_{x, y, c} = 4$，那么整个平面仅一种颜色，无法构造；
- 如果 $vis_{x, y, c} = 3$，那么手动模拟一下，除了两行相同颜色的情况之外是不可能的；
- 如果 $vis_{x, y, c} = 2$，那么这种颜色在无限大的平面上构成若干无限长的折线或者环，绝不出现链；
- 如果 $vis_{x, y, c} = 1$，那么只能是两个同色挨在一起；
- 如果 $vis_{x, y, c} = 0$，那么就是一个单独的颜色。

$k \leq 500$ 情况下，可以用 $vis_{x, y, c} = 2$，即铺 $k$ 条直线。

$k > 500$ 时，$vis_{x, y, c} = 4$ 无解，$vis_{x, y, c} = 3$ 无意义（两条直线只不过把平面划分成了很多个区域，而颜色仅增加 $1$ 个，是没有前途的），$vis_{x, y, c} = 2$ 构造难度极高（要构造出不规则图案，还有框出一个基本单位，且恰好包含 $k$ 种颜色，这大概率不可做）。

因此我们推出一个非常强的条件，所有同色连通块必然是单体（或者两个在一起）。（你会发现两个在一起实际上和单体并没有什么区别）

于是考虑用尽量规则、且没有 $siz > 2$ 连通块的图形填满整个平面。这个限制够强，可以想出以下图案：

![](https://cdn.luogu.com.cn/upload/image_hosting/avi8go9k.png)

这样最大的颜色数是 $500$。而如果我们对一种颜色的对角线隔一个位置替换成一种新颜色，那么整个平面就增加了一种颜色。故可以解决 $k \in [1, 1000]$ 的问题。

---

## 作者：MiRaciss (赞：1)

非常好构造，使我大脑旋转。

平凡的是 $k\le 500$ 的部分。可以每一行都放一个相同的数。但是如果说 $k$ 大于 $500$ 了呢？

这时候如果还是考虑在原基础上优化，即在每行放相同的基础上放置其他数替换。但是你考虑这个时候每个数周围数的构成。举个例子

```
1111
2222
3333
4444
```

对于 `1` 来说，他的周围是由一个 `2` 和一个 `4` 和两个 `1` 组成。如果我们选择一个 `5` 来替换 `1`，那么就有一个 `2` 和 一个 `4` 和其他的 `2` 和 `4` 不匹配了。如果要改变这种情况就只能把所有的 `1` 换掉但这样就没有 `1` 了。

但是这时候你发现对于 `1` 来说，他斜着相邻的分别为两个 `2` 和 两个 `4`。你发现我们有机会更换 $\frac{k}{2}$ 个 `1` 来让所有的 `2` 和 `4` 匹配。但是什么情况下可以看斜着的呢？就是把图形斜过来！ 

![](https://cdn.luogu.com.cn/upload/image_hosting/dd9qzm85.png)

考虑斜着放。这下我们发现只要在原本放 `1` 的位置交替放 `1` 和 `5` 就可以让矩阵合理，因为你改变一个 `1` 就会让相邻的两个 `2` 和  `4` 变化。

发现这种替换的瓶颈是要求矩阵的长宽是偶数。我们发现 $n=500$ 刚好是偶数，所以直接在 $n=500$ 的情况下一直替换就最多能替换到 $2n$ 个数。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,k;
int a[505][505];


int main(){
//	freopen("1.out","w",stdout);
	cin>>k;
	if(k<=500){
		printf("%d\n",k);
		for(int i=1;i<=k;i++){
			for(int j=1;j<=k;j++) printf("%d ",i);
			printf("\n");
		}
	}
	else{
		printf("%d\n",n=500);
		for(int i=1;i<=n;i++){
			int x=0,y=i-1;a[x][y]=i;
			int xx=(x+1)%n,yy=(y+1)%n;
			while(x!=xx&&y!=yy) a[xx][yy]=i,xx=(xx+1)%n,yy=(yy+1)%n;
		} 
		for(int i=n+1;i<=k;i++){
			int x=0,y=i-n-1;a[x][y]=i;
			int xx=(x+2)%n,yy=(y+2)%n;
			while(x!=xx&&y!=yy) a[xx][yy]=i,xx=(xx+2)%n,yy=(yy+2)%n;
			
		}
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++) printf("%d ",a[i][j]);
			printf("\n");
		}
	}
	return 0;
}
/*

4 3 2 1
1 4 3 2
2 1 4 3
3 2 1 4
*/
```

---

## 作者：hjqhs (赞：1)

一道很神仙的紫构造。  
首先如果 $k\le 500$ 是很简单的：第 $i$ 行全部填 $i$ 即可。
```cpp
if(k<=500){
    cout<<k<<'\n';
    rep(i,1,k){
      rep(j,1,k){
        cout<<i<<' ';
      }
      cout<<'\n';
    }
  }
```
那如果 $k$ 大于 $500$ 呢，发现斜着染是可行的，又发现每一斜行改成交替染不同色也是可行的。然后就做完了。
```cpp
else{
    cout<<500<<'\n';
    rep(i,1,500)rep(j,1,500)a[i][j]=(i+j-2)%500+1;
    rep(i,501,k)rep(j,1,500)if(j&1)a[(i-j+498)%500+1][j]=i;
    rep(i,1,500){
      rep(j,1,500){
        cout<<a[i][j]<<' ';
      }
      cout<<'\n';
    }
  }
```

---


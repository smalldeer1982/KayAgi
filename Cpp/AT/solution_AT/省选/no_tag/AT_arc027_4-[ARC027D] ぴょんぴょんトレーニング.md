# [ARC027D] ぴょんぴょんトレーニング

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc027/tasks/arc027_4

跡鼓駄 (あとこだ) 町には ARC 珈琲店があり、競技プログラミング喫茶店として知られている。

高橋君は ARC 珈琲店でアルバイトをしている。

高橋君は ARC 珈琲店に行く際にいつも精進通りという道を通る。精進通りは、高橋君の家と ARC 珈琲店とを結んでいる。

精進通りは $ N $ 個の石で構成されている石畳の道である。石には、高橋君の家がある側から順に $ 1 $ から $ N $ まで番号がつけられている。

高橋君は足腰を鍛えるため、$ D $ 日間精進通りでトレーニングをすることにした。

$ i $ 日目のトレーニングは、以下の要領で行われる。

- トレーニング中、石 $ x $ にいる場合、石 $ x $ からは石 $ x\ +\ 1 $, $ x\ +\ 2 $, … , $ x\ +\ h_x $ に跳んで移動することができる。$ h_x $ はトレーニングの日によらず一定である。
- トレーニング開始時点では石 $ s_i $ にいる。
- トレーニングでは、石 $ s_i $ からジャンプを繰り返して石 $ t_i $ に移動する。途中で石 $ t_i $ より大きな番号の石に跳べたとしても、$ t_i $ より大きな番号の石に移動してはならない。
- トレーニングは石 $ t_i $ に到達した時点で終了する。

高橋君は、石 $ s_i $ から石 $ t_i $ までジャンプで移動する組み合わせが全部で何通りあるのかが気になった。ジャンプで移動する組み合わせというのは、ジャンプで移動する際に使用する石の組み合わせの総数である。高橋君はすべての組み合わせについて自力で跳んで確かめるつもりである。

同僚の青木君は、高橋君を止めるために、石 $ s_i $ から石 $ t_i $ までジャンプで移動する方法が全部で何通りあるのかを前もって調べ、結果を高橋君に伝えることにした。

それぞれの日について、石 $ s_i $ から石 $ t_i $ までジャンプで移動する方法が全部で何通りあるのかを求めるプログラムを作成せよ。 なお、 $ 2 $ つの移動方法が異なるとは、途中で通った石の組み合わせが異なることである。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ N\ ≦\ 500 $ を満たすデータセット $ 1 $ に正解した場合は、$ 30 $ 点が与えられる。
- 追加制約のないデータセット $ 2 $ に正解した場合は、上記とは別に $ 70 $ 点が与えられる。

### Sample Explanation 1

$ 1 $ 日目のトレーニングでは、石 $ 2 $ から石 $ 6 $ に移動します。この入力では、($ h_2 $, $ h_3 $, $ h_4 $, $ h_5 $, $ h_6 $) =($ 2 $, $ 3 $, $ 2 $, $ 2 $, $ 1 $) です。ジャンプによる移動としては、以下の $ 6 $ 通りが考えられます。 !\[\](/img/arc/027/4-1.png)

## 样例 #1

### 输入

```
7
1 2 3 2 2 1 1
3
2 6
5 7
1 7```

### 输出

```
6
2
9```

## 样例 #2

### 输入

```
11
3 1 4 1 5 9 2 6 5 3 5
4
3 7
2 9
1 10
1 11```

### 输出

```
6
22
90
175```

# 题解

## 作者：AzusidNya (赞：1)


### [ARC027D] ぴょんぴょんトレーニング 题解

- - -
#### 题意：
有 $n(1\le n\le  300000)$ 个石柱，从第 $i$ 个石柱可以跳到第 $i+1,i+2,\dots,i+h_i(1\le h_i\le 10)$ 个石柱，有 $d(1\leq d\leq 5000)$ 组询问，每次问从 $l_i$ 到 $r_i$ 有多少种走法。

#### solution:


考虑朴素的 DP。设状态 $f_{i}$ 代表从指定左端点走到 $i$ 的方案数。只需要将每个 $f_i$ 贡献到所有 $j \le i + h_i$ 的 $f_j$ 即可。

初始值为指定的左端点的 $f$ 值为 $1$，其它都为 $0$。

那么有个 $n^2$ 的做法就是每次改变初始值然后 dp 一遍即可。

考虑优化这一 dp。我们发现 $h_i \le 10$，那么我们每次只需要记录 $10$ 个 $f$ 值就够了。

假设现在记录了 $f_i$ 到 $f_{i + 9}$，现在要考虑第 $i$ 个位置的转移，容易得知此时 $f_i$ 的值已经求出。

那么可以构造转移矩阵将 $f_i$ 到 $f_{i + 9}$ 转移到 $f_{i + 1}$ 到 $f_{i + 10}$。矩阵的第一行有 $h_i$ 个 $1$，而其他行则有第 $i+1$ 行 $i$ 列为 $1$。

这里以 $h_i$ 为 $6$ 为例给出转移矩阵，当$h_i$ 为其他情况则修改第一行即可。

$$\begin{bmatrix}
 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0\\
 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix}$$

而根据 dp 的初始值，可构造初始矩阵如下。

$$\begin{bmatrix}
 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}$$

那么转移即变成了求初始矩阵与一段区间的乘积。不带修求区间乘就有很多很多种方法了。但是用线段树需要注意空间复杂度。

我喜欢暴力所以我了分块。当然这里应该有更好的实现方式，我太菜了没想出来。

时间复杂度是 $O(n\sqrt{n})$ 的，但是矩阵乘法有个 $1000$ 的常数，非常大，理论上比较难过，只是这题的时限给的很宽所以能够跑过。

#### code:

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cmath>
#define int long long
using namespace std;
const int modd = 1000000007;
struct matr{
	int st[10][10];
	int n, m;
	matr(int nl, int ml){
		n = nl, m = ml;
		for(int i = 0; i < n; i ++)
			for(int j = 0; j < m; j ++)
				st[i][j] = 0;
	}
	matr(int nl, int ml, bool fl){
		n = nl, m = ml;
		for(int i = 0; i < n; i ++)
			for(int j = 0; j < m; j ++)
				st[i][j] = (i == j);
	}
	matr(){
		n = 10, m = 10;
	}
	int write(){
		for(int i = 0; i < n; i ++){
			for(int j = 0; j < m; j ++)
				cout << st[i][j] << " ";
			cout << "\n";
		}
		return 0;
	}
}I(10, 10, 1);
matr A[300005], B[805];
matr mul(matr t1, matr t2){
	matr m3(t1.n, t2.m);
	for(int i = 0; i < t1.n; i ++)
		for(int j = 0; j < t2.m; j ++)
			for(int k = 0; k < t2.m; k ++)
				(m3.st[i][j] += (1ll * (t1.st[i][k] % modd) * (t2.st[k][j] % modd)) % modd) %= modd;
	return m3;
}
matr D(1, 10);
matr E(1, 10);
int n, q;
int T, bl;
int L[805], R[805], belong[300005];
int query(int l, int r){
	if(belong[l] == belong[r]){
		for(int i = l; i <= r; i ++)
			E = mul(E, A[i]);
		return E.st[0][0];
	}
	int u = belong[l], v = belong[r];
	for(int i = l; i <= R[u]; i ++)
		E = mul(E, A[i]);
	for(int i = u + 1; i < v; i ++)
		E = mul(E, B[i]);
	for(int i = L[v]; i <= r; i ++)
		E = mul(E, A[i]);
	return E.st[0][0];
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	D.st[0][0] = 1;
	for(int i = 1, x; i <= n; i ++){
		cin >> x;
		A[i].n = 10, A[i].m = 10;
		for(int j = 0; j < x; j ++)
			A[i].st[0][j] = 1;
		for(int j = 0; j < 9; j ++)
			A[i].st[j + 1][j] = 1;
	}
	T = 605, bl = n / T;
	for(int i = 1; i <= bl; i ++)
		B[i] = I, L[i] = R[i - 1] + 1, R[i] = L[i] + T - 1;
	if(R[bl] < n)	bl ++, L[bl] = R[bl - 1] + 1, R[bl] = n;
	for(int i = 1; i <= bl; i ++)
		for(int j = L[i]; j <= R[i]; j ++){
			belong[j] = i;
			B[i] = mul(B[i], A[j]);
		}
	cin >> q;
	for(int i = 1, l, r; i <= q; i ++){
		E = D;
		cin >> l >> r;
		if(l == r){
			cout << 1 << "\n";
			continue;
		}
		r --;
		cout << query(l, r) << "\n";
	}
	return 0;
}
```

---


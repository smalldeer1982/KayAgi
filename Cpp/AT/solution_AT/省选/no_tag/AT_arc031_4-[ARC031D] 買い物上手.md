# [ARC031D] 買い物上手

## 题目描述

高桥君沉迷于一款游戏。在这款游戏中，玩家可以通过购买并组合一些物品来获取经验值。给定每种物品的价格以及通过指定物品组合获得的经验值列表，要求你选择购买的物品，使得「获得的经验值 ÷ 花费的金钱」最大化。需要注意的是，至少购买一种物品，而且每种物品只需要购买一个就可以获得相应的经验值。

## 说明/提示

在本问题中共有两个数据集，每个数据集的具体条件如下：

- 如果在数据集中 $N \le 10$ 的情况下提供正确答案，可以得到 $50$ 分。
- 在没有额外限制的情况下提供正确答案，可以在前述数据集之外额外得到 $50$ 分。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 4
4 3 2
4 2 1 10
2 1 2
2 1 3
3 2 3 4```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5
7 1 3 6 6
6 3 2 6 5
1 2
2 2 3
4 1 2 4 5
2 2 4
2 2 3```

### 输出

```
2.8```

# 题解

## 作者：UnyieldingTrilobite (赞：1)

题意大概就是，你有 $m$ 个物品，第 $i$ 个物品需要 $T_i$ 的钱买；你有 $n$ 个组合，每个组合由一些物品的编号构成，如果你买了组合中的每一个物品，那你就能得到 $S_i$ 的经验。你需要最大化所得经验与所花的钱的比。样例就是你买前三个物品触发前两个组合，得到 $\frac77=1$。

首先这个比一眼得二分答案。假设我们现在考虑比是否能够达到 $x$。我们在这里考虑一个很天才的事情。建立一张图，源点向每个组合连容量为 $S_i$ 的边，每个组合向它包含的每个物品连容量为 $+\infty$ 的边，每个物品向汇点连容量为 $xT_i$ 的边。我们考虑求这个东西的最小割。

首先组合连物品的边肯定不能割。其次我们考虑如果源点连组合的边没割完，那一定是多割了一些物品到汇点的边。我们发现能不割的源点到组合的边，一定要满足这个组合中每个物品到汇点的边都被割掉了。这样一来，我们额外对于每个割（选）的物品花费了 $xT_i$ 的代价（钱），对于每个不割（触发）的组合节省了 $S_i$ 的代价（经验），且 $\sum S_i-x\sum T_i$ 达到最大。我们只需要考虑这个值是否等于 $0$ 即可。等于 $0$ 说明最优解就是全割源点到组合的边，不存在方案使所取物品的性价比能 **大于** $x$。注意其实可能是等于 $x$ 的，但 $10^{-4}$ 的精度弥补了这一点，我们并不需要考虑其实存在方案使得取等的情况。

实现方面，如果你不想写浮点数网络流，你可以合理利用精度限制把所有经验乘一个大数然后处理。这样做最显著的好处是可以用 atcoder lib。

```cpp
#include <bits/stdc++.h>

#include <atcoder/maxflow>
#define int long long
using namespace std;
constexpr int N = 109, A = 1e6;
int n, m, sv[N], tv[N];
vector<int> bv[N];
int calc(int k) {
  atcoder::mf_graph<int> g(n + m + 2);
  int s = 0, t = n + m + 1;
  for (int i = 1; i <= n; ++i) {
    g.add_edge(s, i, sv[i]);
    for (int j : bv[i]) g.add_edge(i, j + n, LLONG_MAX);
  }
  for (int i = 1; i <= m; ++i) g.add_edge(i + n, t, tv[i] * k);
  return g.flow(s, t);
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> m;
  for (int i = 1; i <= n; ++i) cin >> sv[i], sv[i] *= A;
  for (int i = 1; i <= m; ++i) cin >> tv[i];
  for (int i = 1, k; i <= n; ++i) {
    cin >> k, bv[i].resize(k);
    for (int& x : bv[i]) cin >> x;
  }
  int l = 1, r = 1e10, ans = 0, sm = accumulate(sv + 1, sv + n + 1, 0ll);
  while (l <= r) {
    int mid = (l + r) >> 1;
    if (calc(mid) < sm)
      l = mid + 1;
    else
      r = mid - 1, ans = mid;
  }
  return cout << fixed << setprecision(5) << 1. * ans / A << endl, 0;
}
```

---


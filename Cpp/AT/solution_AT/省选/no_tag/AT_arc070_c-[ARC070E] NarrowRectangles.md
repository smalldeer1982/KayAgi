# [ARC070E] NarrowRectangles

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc070/tasks/arc070_c

シカのAtCoDeerくんは縦の長さが $ 1 $ の細長い長方形が $ N $ 個机に置いてあるのを見つけました。 机を二次元平面とみなすと、以下の図のように、$ i(1≦i≦N) $ 個目の長方形は、縦は $ [i-1,i] $ の範囲を、横は $ [l_i,r_i] $ の範囲を占めています。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc070_c/48c83ba23abe08ae2a1cfd9ab3b077e4e13af8a7.png)

AtCoDeerくんはこの長方形をそれぞれ横に動かすことで、全ての長方形を連結にしようと考えました。 各長方形は横に距離 $ x $ 動かすのに $ x $ のコストがかかります。 全ての長方形を連結にするのに必要なコストの最小値を求めてください。 問題の制約のもとでこの値は整数になることが証明できます。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1≦N≦10^5 $
- $ 1≦l_i\ <\ r_i≦10^9 $

### 部分点

- $ 1≦N≦400 $, $ 1≦l_i\ <\ r_i≦400 $ を満たすデータセットに正解した場合は、部分点として $ 300 $ 点が与えられる。

### Sample Explanation 1

$ 2 $ 個目の長方形を左に $ 2 $ 動かすのが最小です。

### Sample Explanation 2

はじめから連結になっているため、動かす必要はありません。

## 样例 #1

### 输入

```
3
1 3
5 7
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
3
2 5
4 6
1 4```

### 输出

```
0```

## 样例 #3

### 输入

```
5
999999999 1000000000
1 2
314 315
500000 500001
999999999 1000000000```

### 输出

```
1999999680```

## 样例 #4

### 输入

```
5
123456 789012
123 456
12 345678901
123456 789012
1 23```

### 输出

```
246433```

## 样例 #5

### 输入

```
1
1 400```

### 输出

```
0```

# 题解

## 作者：一叶知秋。 (赞：28)

神仙题，sto $\text{W}\textcolor{red}{\text{hiteCmile}}$ orz

首先可以列出一个很好想的 $\text{DP}$ ：

设 $f_{i,j}$ 为转移到了第 $i$ 个长方形，且这个长方形的左端点放在 $j$ 的最小答案

同时设 $len_i=r_i-l_i$ 方便书写（注意没有加 $1$ ）

转移也较为容易，在此直接列出方程：

$f_{i,j}=\min\{f_{i-1,k}\}+|j-l_i|,k \in [j-len_{i-1},j+len_i]$


------------


把 $f_{i,j}$ 写为 $f_i(j)$ （也就是一个函数），易证 $f_i(x)$ 肯定是个凸函数

于是问题就转移成了如何快速将两个有一些特殊性质的凸函数相加（绝对值函数也是凸函数）

------------

我们先看 $f_i(x)$ ，将其分开讨论：

我们将这个 $f_{i-1}(x)$ 这个函数分成三段：我们**称**这个 $f_i(x)$ 的**左边是斜率小于 $0$ 的**，**中间是斜率等于 $0$ 的**，**右边是斜率大于 $0$ 的**

可以发现如果 $x$ 越靠近中间那一段，$f_{i-1}(x)$ 取值就越小

设 $L$ 和 $R$ 分别为 $f_{i-1}(x)$ 中间一段的左端点和右端点，于是我们可以用上面的性质将 $f_i(x)$ 的取值写成如下这种式子：

$f_i(x)=|x-l_i|+
\begin{cases}
f_{i-1}(x+len_i) &  & x \in   (-\infty,L-len_i) \\
f_{i-1}(L) &  & x \in   [L-len_i,R+len_{i-1}] \\
f_{i-1}(x-len_{i-1}) &  & x \in   (R+len_{i-1},\infty) 
\end{cases}$

先不考虑绝对值函数，只看后面的大括号

通过这个取值范围，可以明显的发现每次相当于将 $f_{i-1}$ 左边往左移了 $len_i$ ，右边往右移了 $len_{i-1}$ ，中间 $L$ 变成了 $L-len_i$ ，$R$ 变成了 $R+len_{i-1}$

于是可以用两个标记，一个标记左边向做平移了多少，一个标记右边向右平移了多少，中间的两个端点其实就是左边的最右边那个点和右边的最左边那个点，可以不用特殊处理了

------------

至此，我们只需要考虑绝对值如何处理了

很容易可以看出绝对值函数只跟 $l_i$ 的位置有关（因为斜率始终为左边 $-1$ ，右边 $+1$ ，这里要注意，这个性质等会要用到）

可以考虑再分三种情况讨论（~~没错，还要分类讨论~~）：

1、 $l_i$ 在中间，那么 $L=R=l_i$ ，$l_i$ 左边斜率 $-1$ ，右边斜率 $+1$（因为只有 $l_i$ 这个位置是 $0$ ，且原本在的位置就是取值最小的）

2、 $l_i$ 在左边，那么首先 $l_i$ 左边的斜率 $-1$ ，右边斜率 $+1$ ，但是 $L$ 和 $R$ 分别在哪？

　　因为 $l_i$ 在左边，所以 $l_i$ 往右走斜率大于等于 $l_i$ 所在的这一段的斜率，所以中间变成了原本斜率为 $-1$ 的地方，原本的中间那一段就加到了右边（注意如果 $l_i$ 在 $-1$ 这一段，那么 $l_i$ 以左（到这一段的左端点）斜率变为 $-2$ ，以右（到这一段的右端点）斜率变为 $0$ ，但事实上实现时不用讨论这些情况，如何维护这些东西下面再谈）

 3、$l_i$ 在右边，其实和 $l_i$ 在左边情况差不太多，反过来一下就可以了

------------

现在思考如何具体维护，发现维护许多线段是很复杂且困难的，但是其实每次相邻线段斜率只会相差 $1$ 

（其实在加完绝对值后会出现相差为 $2$ 甚至更大的情况，但是其实这个可以看成这两个线段之间有几个长度为 $0$ 的线段，这些长度为 $0$ 的线段就很灵活的处理了这个问题（这里真的很妙啊））

于是我们就只需要存下这些线段的端点，这样每条线段的端点和斜率都可以通过这些点算出来（斜率就是在这条线段前的线段数也就是点数）

发现我们需要支持的操作有插入一些点，询问最大值和最小值，和删除最大值和最小值（左边和右边），于是可以直接用堆来维护（貌似这是个套路？）

------------

但还有一个问题（真的是最后一个了 QAQ）：统计答案

我们发现最后 $f_n(x)$ 中间一段的纵坐标（也就是最低点的纵坐标）就是答案，但是我们发现并不怎么好直接得到，考虑每次转移时计算

设 $ans_i$ 为 $f_i(x)$ 的中间一段的纵坐标方便表示

那么一共会有三种情况：

1、 $l_i$ 在 $f_{i-1}(x)$ 的中间，那么最低点的纵坐标仍然没有改变（因为中间一段的纵坐标相同），所以 $ans_i=ans_{i-1}$

2、 $l_i$ 在 $f_{i-1}(x)$ 的左边，那么是原本斜率为 $-1$ 的一段变成了 $f_i(x)$ 的中间，由于斜率同为 $0$ 的一段纵坐标都相等，那么我们用最好算的点来计算，也就是 $L$ 点（因为 $L$ 是 $f_{i-1}(x)$ 的中间的左端点，也就是斜率为 $-1$ 的右端点），那么由于 $f_{i-1}(x)$ 是加上 $|l_i-x|$ ，那么 $ans_i=ans_{i-1}+(L-l_i)$ 

3、 $l_i$ 在 $f_{i-1}(x)$ 的右边，和第 2 种情况差不多，所以转移为 $ans_i=ans_{i-1}+(l_i-R)$

可以发现这里的讨论和在上面讨论绝对值函数差不多可以顺便处理答案

------------

具体实现可以看一下代码（看似需要讨论的情况很多，但其实用堆可以去掉许多情况的讨论，所以码量可能比暴力还短，细节也少的离谱/fad）

$code$ :

```cpp
#include<cstdio>
#include<cctype>
#include<queue>

using namespace std;

#define maxn 101101

template<class T>

inline T read(){
	T r=0,f=0;
	char c;
	while(!isdigit(c=getchar()))f|=(c=='-');
	while(isdigit(c))r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f?-r:r;
}

int n,l[maxn],r[maxn],len[maxn];

#define int long long

int addl,addr,ans;

priority_queue<int>ql;

priority_queue<int,vector<int>,greater<int> >qr;

#undef int

int main(){
	n=read<int>();
	for(int i=1;i<=n;i++){
		l[i]=read<int>();
		r[i]=read<int>();
		len[i]=r[i]-l[i];
	}
	ql.push(l[1]);
	qr.push(l[1]);//一开始第一次斜率为0的地方肯定是l[1]
	for(int i=2;i<=n;i++){//所以这里从2开始
		addl-=len[i],addr+=len[i-1];//打标记来处理平移
		long long L=ql.top()+addl;//记得加上标记
		long long R=qr.top()+addr;//中间的左右端点
		if(l[i]<L){//绝对值的顶点在左边
			ans+=L-l[i];//最近的显然是这个
			ql.pop();//中间的左端点不再是中间的左端点了
			ql.push(l[i]-addl);//注意这里这个点要加2次，因为l[i]的左边的斜率跟
			ql.push(l[i]-addl);//它右边的斜率相差为2了，于是要插入一条长度为0的线段
			qr.push(L-addr);//将原本中间的左端点加到右边去
		}
		else if(l[i]>R){//在右边
			ans+=l[i]-R;//这个同上
			qr.pop();//同上
			qr.push(l[i]-addr);//同上
			qr.push(l[i]-addr);
			ql.push(R-addl);//同上
		}
		else {//如果本来就在中间，那么答案肯定不变
			ql.push(l[i]-addl);//左边的最右边端点变成l[i]
			qr.push(l[i]-addr);//同理
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Lgx_Q (赞：7)

题意：平面上有 $n$ 个矩形，左下角点坐标为 $(l_i,i-1)$，右上角点坐标为 $(r_i,i)$。每次把一个矩形沿着横轴方向移动一个长度单位，求移动多少次使得任意两个相邻矩形存在交点。

$1\le n\le 10^5,\space 1\le l_i< r_i\le 10^9$

考虑最简单的 dp，设 $f[i,j]$ 表示处理了前 $i$ 个矩形，并且第 $i$ 个矩形左边界移动到了 $j$ 位置的最小代价。

有转移：

$$f[i,j]=|j-l_i|+\min_{j-len_{i-1}\le k\le j+len_i}\{f[i-1,k]\}$$

一个很巧妙的 trick：考虑 $|j-l_i|$ 是凸函数，并且凸函数的区间平移最小值还是凸函数，可以归纳证明 $f[i,]$ 也是凸函数。

设 $f_i(x)$ 为 $f[i,]$ 在图像上的函数，设 $L,R,v$ 为 $f_{i-1}(x)$ 上最小值的区间，以及对应的最小值，那么：

$$f_i(x)=|x-l_i|+\begin{cases} f_{i-1}(x+len_i) & x<L-len_i \\ v & L-len_i\le x\le R+len_{i-1} \\ f_{i-1}(x-len_{i-1}) & x>R+len_{i-1} \end{cases}$$

忽视前面的 $|x-l_i|$，我们相当于是把原来的 $f_{i-1}(x)$ 的 $L\gets L-len_i,\space R\gets R+len_{i-1}$。

然后我们需要加上 $|x-l_i|$ 这个绝对值函数，本质是把 $[-\infty,l_i]$ 这一整段函数斜率整体 $-1$，$[l_i,\infty]$ 这一整段函数整体 $+1$。具体的，分类讨论：

+ $L\le l_i\le R$

此时最小值只有一个位置 $l_i$，把 $l_i$ 左边斜率 $-1$，右边斜率 $+1$。

+ $l_i<L$

原来在 $l_i$ 右边的斜率为 $-1$ 的这一段斜率会变成 $0$。设斜率为 $-1$ 的这一段函数为 $[s,t]$，令 $s'$ 为 $\max(s,l_i)$，那么新的 $L'=s',R'=t$，然后原来 $l_i$ 右边的斜率全部 $-1$，$[l_i,t]$ 斜率全部 $+1$，$R'$ 右边的斜率整体 $+1$。

+ $l_i>R$

同理。

考虑使用两个堆 $q_l,q_r$ 分别维护 $L$ 左边、$R$ 右边的斜率拐点（严格来说是斜率 $+1$ 或 $-1$ 的分界点）。$q_l$ 是大根堆，$q_r$ 是小根堆，所以 $L,R$ 其实是 $q_l,q_r$ 各自的堆顶。

每次需要支持找到 $q_l$ 或 $q_r$ 的前两个拐点，或者给 $q_l$ 或 $q_r$ 中的拐点整体偏移，后者可以维护两个堆的整体偏移标记。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned ll
#define mkp make_pair
#define fi first
#define se second
#define pir pair<ll,ll>
#define pb push_back
using namespace std;
const ll maxn=1e5+10, inf=1e17;
ll n,l[maxn],r[maxn],len[maxn],ans,tagl,tagr;
priority_queue<ll>ql,qr;
int main(){
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++){
		scanf("%lld%lld",l+i,r+i); len[i]=r[i]-l[i];
		if(i==1){
			ql.push(l[i]), qr.push(-l[i]);
			ql.push(-inf), qr.push(-inf);
			continue;
		}
		tagl+=len[i], tagr+=len[i-1];
		if(l[i]<ql.top()-tagl){
			ll x=ql.top()-tagl; ql.pop(); ans+=x-l[i];
			ll t=max(l[i],ql.top()-tagl);
			ql.push(l[i]+tagl), ql.push(l[i]+tagl), qr.push(-x+tagr);
		} else if(l[i]<=-qr.top()+tagr){
			ql.push(l[i]+tagl), qr.push(-l[i]+tagr);
		} else{
			ll x=-qr.top()+tagr; qr.pop(); ans+=l[i]-x;
			ll t=min(l[i],-qr.top()+tagr);
			qr.push(-l[i]+tagr), qr.push(-l[i]+tagr), ql.push(x+tagl);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：louhao088 (赞：4)

烟火表演的弱化版。

首先，我们很容易列出一个 $n^2$​ dp，$f[i][j] $ 表示第 $i$ 个到长方形 $l$ 的位置是 $j$。显然 $f[i][j]=min(f[i-1][k]+abs(j-l)) (j+r-l\geq k\geq j+r_{i-1}-l_{i-1})$。取 $f_n$ 最小值即可。

我们发现每个 $f_i$ 函数都是一个凸函数，因为绝对值函数是凸的，取最小值也是凸的，于是我们可以用队列来维护他的转折点。

由于他每次都只增加一个绝对值函数，所以他最多增加两个凸点，凸度最多增加二。

具体的，我们用两个队列分别维护他斜率小于 0 和大于 0 的部分，维护转折点，答案必然在斜率为 0 时取到。

[代码](https://www.luogu.com.cn/paste/cgr06c6l)

---

## 作者：Yorg (赞：1)

upd on 25/1/15：发现格式错误，进行调整。

---

首先是朴素的 dp。  
令 $f_{i, j}$ 表示考虑到第 $i$ 行，其中这一行的左端点位置为 $j$ 的最优花费。  
容易写出转移：
$$
f_{i, j} \gets \min_{k \in [j - len_{i - 1}, j + len_i]} f_{i - 1, k} + |j - l_i|
$$

考虑优化。  
注意到绝对值是「凸函数」，你把 $f_{i, j}$ 视作 $n$ 个函数 $f_i(x)$，容易递归证得 $f_i(x)$ 也是「凸函数」。

用函数的形式表示 $f_{i - 1}$，然后考虑转移：
[![pEitndf.png](https://s21.ax1x.com/2025/01/14/pEitndf.png)](https://imgse.com/i/pEitndf)

你发现转移相当于在这个函数上做一个滑动窗口，然后求最小，具体的：
[![pEitJLq.png](https://s21.ax1x.com/2025/01/14/pEitJLq.png)](https://imgse.com/i/pEitJLq)

记中间那一段斜率为 $0$ 的左右端点为 $L, R$。

利用你的初中数学知识得到表达式：
$$
\begin{align*}
f_i (x) \gets
|x - l_i|
+
\begin{cases}
f_{i - 1} (x + len_i) , \textrm{ case } x \in (-\infty, L - len_{i}) \\
f_{i - 1} (L) , \textrm{ case } x \in [L - len_i, R + len_{i - 1}] \\
f_{i - 1} (x - len_{i - 1}) , \textrm{ case } x \in (R + len_{i - 1}, \infty) \\
\end{cases}
\end{align*}
$$

你发现如果只考虑大括号，就是一个对 $L, R$ 的偏移，使得中间斜率为 $0$ 的部分拉长，然后两边扩张。

> 具体为什么：左加右减常数项，上加下减自变量。

考虑加上绝对值。  
首先不难证明，绝对值函数由 $k = -1, 1$ 的一次函数拼成，可以看作对 $x = l_i$ 左侧的 $k \gets k - 1$，对 $x = l_i$ 右侧的 $k \gets k + 1$。

考虑其影响，你发现对 $l_i$ 两侧的斜率 $\pm 1$ 并不好维护。  
你发现斜率 $\pm 1$，如果 $l_i$ 恰好在原来的端点上，会保持一个优美的性质：相邻两线段 $k$ 值相差为 $1$。  
考虑维护每一个斜率对应的线段的左右端点，你会发现 $l_i$ 不在端点上时，会出现相邻两线段 $k$ 相差 $2$ 的情况，怎么办？  
大胆令 $x = l_i$ 这个点的斜率为相邻两线段的 $k$ 中间值，于是满足了这个美丽性质。

由上，我们把 $L$ 左侧以及 $L$ 的线段端点（上面的图中的红色点）放到一块，把 $R$ 右侧以及 $R$ 的线段端点放到一块，一会解释为什么。

那么我们现在大可以把 $f_i \gets f_{i - 1}$ 分成两次操作：
- 处理斜率的变化，会产生新的左右端点。
- 处理 $L, R$ 的偏移。

---

具体一点，我们来模拟一些这样的过程。  
### 处理斜率的变化  
#### 对于 $l_i < L$  
[![pEiarlQ.png](https://s21.ax1x.com/2025/01/14/pEiarlQ.png)](https://imgse.com/i/pEiarlQ)

你可以看作把原来的 $L$，也就是左侧最小的线段端点弹出左侧线段端点，然后把它放进右侧线段端点。  
还需要把 $l_i$ 所处的位置看作一个新的端点放进左侧端点的集合中，因为  
> 大胆令 $x = l_i$ 这个点的斜率为相邻两线段的 $k$ 中间值，于是满足了这个美丽性质。

所以要放两个 $l_i$ 进去，表示左右端点。

---

> 注意负数斜率 $-1$，在画图的时候表示为更陡。

#### 对于 $l_i > R$  
跟上面的情况是类似的，对称。  
~~绝对不是我懒~~

#### 对于 $L \leq l_i \leq R$  
[![pEia8QH.png](https://s21.ax1x.com/2025/01/14/pEia8QH.png)](https://imgse.com/i/pEia8QH)

你发现 $l_i$ 变成了左右的同时端点，其他的不变。

### 处理 $L, R$ 的偏移  
显然可以处理每次操作的偏移量。  
这里有一个小问题，你无法同时更新两个部分中所有的端点位置，怎么办？  
很巧妙的方法是，你每次将 $L, R$ 还原之后插入，然后对两个部分维护偏移量，即可动态维护 $L, R$ 的位置。

现在可以解释为什么：  
> 我们把 $L$ 左侧以及 $L$ 的线段端点放到一块，把 $R$ 右侧以及 $R$ 的线段端点放到一块，一会解释为什么。
> 
这样可以快速求出 $f_i$ 的 $L, R$，只需要对 $L$ 维护大根堆，对 $R$ 维护小根堆即可。

---

最后一个问题：答案怎么求得？

你发现最后的答案可以表示成 $f_n (L \sim R)$，可惜不好维护。  
考虑每次操作的时候，动态维护当前的 $f_i (L), f_i(R)$。

---

具体怎么做？  
首先需要发现偏移操作并不影响 $y$ 值。  
#### 对于上文中 $l_i < L$ 的情况  
我们可以发现这种情况下，答案会变成 $f_{i - 1} (L) + (L - l_i)$。

#### 对于上文中 $l_i > R$ 的情况  
我们可以发现这种情况下，答案会变成 $f_{i - 1} (L) + (l_i - R)$。

#### 对于上文中 $L \leq l_i \leq R$ 的情况  
我们可以发现这种情况下，答案不变。

---

动态维护即可。

---

总结一下，每次维护新的 $f_i$，我们首先计算偏移量，然后维护新的线段端点，统计对答案的影响。

代码就不放了，题解区几篇代码都很好

---

## 作者：sqrtqwq (赞：0)

Slope Trick!

先有个朴素的 dp：我们定义 $dp_{i,j}$ 表示把第 $i$ 个方块移到 $j$ 这个位置上的最小代价。那么转移方程就是：

$$dp_{i,j} = |j - l_i| + \min_{j - len_{i - 1} \le k \le j + len_i} dp_{i - 1,k}$$

然后因为 $|j - l_i|$ 为凸函数，然后我们发现 $dp_{i,*}$ 为凸函数。然后我们考虑用队列来维护这个凸包的每一个转折点。

具体的，我们维护斜率大于 $0$ 和斜率小于 $0$ 的部分的转折点，同时答案必定会在斜率等于 $0$ 时取到。

---


# [ARC114D] Moving Pieces on Line

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc114/tasks/arc114_d

$ X\ =\ 10^{100} $ として，各整数 $ -X\ \leq\ i\ \leq\ X $ に対応する頂点があり，$ -X\ \leq\ i\ \leq\ X-1 $ について頂点 $ i,\ i\ +\ 1 $ を結ぶ無向辺 (以降，辺 $ \{\ i,\ i\ +\ 1\ \} $ と呼ぶ) があるグラフがあります．

このグラフの辺は初めすべて赤く塗られています．また，$ N $ 個 のコマがあり，$ i $ 個目のコマは頂点 $ a_i $ に置かれています．

maroon 君は次の操作を行うことができます．

- コマを $ 1 $ つ選ぶ． このコマが頂点 $ i $ にあるとき，コマを頂点 $ i-1 $ または頂点 $ i+1 $ に動かし，通った辺を，現在の色が赤なら青，青なら赤に塗り替える．

操作の過程で，同じ頂点に複数のコマが存在しても構いません．

maroon 君はこれから上記の操作を $ 0 $ 回以上繰り返して，辺の色の組合せを目的の状態にしたいと思っています．目的の状態は 偶数 $ K $ と，$ K $ 個の整数 $ t_1\ <\ t_2\ <\ \cdots\ <\ t_K $ で表され，$ i\ <\ t_1 $ について辺 $ \{\ i,\ i\ +\ 1\ \} $ は赤，$ t_1\ \leq\ i\ <\ t_2 $ について辺 $ \{\ i,\ i\ +\ 1\ \} $ は青，$ \cdots,\ t_K\ \leq\ i $ について辺 $ \{\ i,\ i\ +\ 1\ \} $ は赤 という状態です．より正確には，各奇数 $ j\ =\ 1,\ 3,\ \cdots,\ K-1 $ に対して，$ t_j\ \leq\ i\ <\ t_{j+1} $ を満たす $ i $ について辺 $ \{\ i,\ i\ +\ 1\ \} $ は青で，それ以外の辺はすべて赤です．

maroon 君が辺の色の組合せを目的の状態にするために必要な操作回数の最小値を求めてください．また，そのような操作が不可能であるなら $ -1 $ を出力してください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5000 $
- $ 2\ \leq\ K\ \leq\ 5000 $
- $ K $ は偶数
- $ |a_i|\ \leq\ 10^9 $
- $ |t_i|\ \leq\ 10^9 $
- $ t_i\ <\ t_{i+1} $
- 入力は全て整数

### Sample Explanation 1

例えば以下のように $ 4 $ 回の操作で目的の状態にでき，$ 4 $ 本の辺の色を変える必要があるのでこれが最適です． これは初めの状態です．便宜上 $ -3 $ より左と $ 3 $ より右の辺は省いています． !\[0\](https://img.atcoder.jp/arc114/cfe333a77072f2bb54812c06d62de656.png) $ -1 $ にあるコマを $ -2 $ に動かすと次の状態になります． !\[1\](https://img.atcoder.jp/arc114/93c2fca818e0d1a8069b70919a043d21.png) $ 2 $ にあるコマを $ 1 $ に動かすと次の状態になります． !\[2\](https://img.atcoder.jp/arc114/f7520729ea3f02659eef7df2d17c1363.png) $ 1 $ にあるコマを $ 0 $ に動かすと次の状態になります． !\[3\](https://img.atcoder.jp/arc114/fa295d290a5de5c01f66934899fb6280.png) $ 0 $ にあるコマを $ -1 $ に動かすと次の状態になり，これが目的の状態です． !\[last\](https://img.atcoder.jp/arc114/eab39d19d0973644aa27e8c695ab5812.png)

### Sample Explanation 2

初めから同じ頂点に複数のコマがある場合もあります．

## 样例 #1

### 输入

```
2 2
2 -1
-2 2```

### 输出

```
4```

## 样例 #2

### 输入

```
2 2
2 2
5 8```

### 输出

```
9```

## 样例 #3

### 输入

```
3 4
1 3 5
0 2 4 6```

### 输出

```
-1```

## 样例 #4

### 输入

```
4 4
3 4 5 6
3 4 5 6```

### 输出

```
2```

# 题解

## 作者：柳易辰 (赞：4)

很深刻的题目，使用了很巧妙的转化。我由于没有进行转化直接进行 DP，写了 5K 错误的代码。

关键转化：把边的颜色**差分**。我们不再关注哪些边是红色还是蓝色，而是关心哪些**点**前后的边**颜色不同**。我们用 $c_i$ 表示第 $i$ 个点的前后两条边颜色是否相同。

引理 1：**任意棋子不会重复经过一个点。**

即棋子不走回头路，容易发现走回头路没有意义，浪费了步数又没有任何贡献。

于是我们可以设第 $i$ 个棋子起点为 $a_i$，终点为 $d_i$，步数则是 $|a_i-d_i|$。则它对 $c$ 的贡献是将 $c_{a_i},c_{d_i}$ **取反**。

最终的局面要求是红蓝颜色段相间，用 $c$ 来形式化描述就是 $\forall p=b_i,c_p=\tt{true}$。由于 $a_i$ 是固定的，我们先把所有 $a_i$ 和 $b_i$ 位置取反，现在得到的若干个 $c_p=\tt{true}$ 的位置就需要通过对 $c_{d_i}$ 取反来满足。

设现在有 $t$ 个位置满足 $c_p=\tt{true}$，记这些位置是 $e_1,\dots e_t$（令 $e$ 是递增的）。

如果 $n<t$，我们显然没办法用 $n$ 次取反操作使 $t$ 个位置为 $\tt true$，所以无解。

考虑 $n=t$ 的情况，我们需要将每个 $a$ 和 $e$ 一一匹配，匹配 $a_i$ 和 $e_j$ 的代价就是 $|a_i-e_j|$，含义就是第 $i$ 个棋子终点为 $e_j$，即 $d_i=e_j$。

引理 2：对于匹配 $a_i-e_j$ 和 $a_x-e_y$，这两个**匹配不交叉**，即不存在 $a_i<a_x\land e_j>e_y$ 或者 $a_i>a_x\land e_j<e_y$。

如果存在，我们可以调整成 $a_i-e_y$ 和 $a_x-e_j$，容易发现这样步数更少。

于是 $n=t$ 的情况就是简单贪心了，将 $a$ 从小到大排序后，$a_i$ 一定与对应的 $e_i$ 匹配。

接下来考虑更加平凡的情况 $n>t$，接下来我们需要引入一种新的匹配：$a_i-a_j$，含义就是我们让 $i-j$ 这两个棋子相遇，代价是 $|a_i-a_j|$，也就相当于令 $c_{d_i}=c_{d_j}$ 从而消除了两个取反操作。推广引理二可知 $i,j$ 必然相邻，否则匹配会交叉。

于是我们就可以设 $f_{i,j}$ 表示 $a_1,\dots,a_i$ 和 $e_1,\dots,e_j$ 匹配的最小代价进行 DP。

转移：$f_{i,j}=\min(f_{i-1,j-1}+|a_i-e_j|,f_{i-2,j}+|a_i-a_{i-1}|)$。

---

## 作者：sidekick257 (赞：3)

> 有点意思，就是感觉满橙有点虚高了。

显然移动棋子就是区间异或，所以代价就是区间长度。

观察到题目的读入，不难想到这种形式我们要差分一下。

设 $v$ 是差分数组。

那么 $x$ 位置的棋子就是选择一个 $y$ 使 $v_x$，$v_y$ 都异或 $1$，代价为 $\text{abs}(x-y)$。

先把所有有棋子的位置都异或在目标局面上，然后会得到一个 $b$ 数组，不难发现是让你匹配 $a$ 数组和 $b$ 数组中的 $1$。

可以简单 $dp_{i,j}$ 表示 $a$ 数组前 $i$ 个和 $b$ 数组前 $j$ 个匹配了，$dp_{i,j}=\min(dp_{i-1,j},dp_{i-1,j-1}+\text{abs}(a_i-b_j))$

然后过不去第四个样例，因为所有棋子一定要找一个落点（也就是第一个转移是错的），也就是说需要在 $a$ 内部来消耗，不难发现这个只会在相邻两个消耗，不然一定更劣，也就是把第一个转移改成 $dp_{i-2,j}+\text{abs}(a_i-a_{i-1})$ 即可。

---

## 作者：Purslane (赞：1)

# Solution

考虑边 $i \to i+1$ 的颜色，取决于**初始状态与结束状态位置 $\le i$ 的棋子的个数和**。这样很容易知道哪些位置**结束状态下有奇数个棋子**。设这些位置有 $m$ 个。

在判断颜色的时候，任意位置上，如果有两个棋子，都可以将其忽视。因此我们需要在 $n$ 个棋子中选 $m$ 个移动到结束状态的位置上，将剩下 $n-m$ 个棋子两两配对。

而两两配对的形态会比较优美：不存在相交或者包含的情况。

这样容易设计 DP 状态：考虑所有关键点的一个前缀，有 $i$（$i>0$） 个原始位置或者 $-i$（$i<0$）个结束位置没有匹配，存在（或者不存在）一个两两配对的棋子。记为 $dp_{n,i,0/1}$。

直接转移即为 $O(nk)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=10000+10;
int n,k,o=5000,st,dp[2][MAXN][2],a[MAXN],t[MAXN],cnt1[MAXN],cnt2[MAXN],lsh[MAXN],tot;
int find(int k) {return lower_bound(lsh+1,lsh+tot+1,k)-lsh;}
void insert1(int v) {
	int lst=st;
	st^=1,memset(dp[st],0x3f,sizeof(dp[st]));
	ffor(i,0,o+o) {
		dp[st][i][0]=dp[lst][i][1]+v;
		dp[st][i][1]=dp[lst][i][0]-v;	
	}
	ffor(i,0,o+o-1) ffor(op,0,1) {
		if(i<o) dp[st][i+1][op]=min(dp[st][i+1][op],dp[lst][i][op]+v);
		else dp[st][i+1][op]=min(dp[st][i+1][op],dp[lst][i][op]-v);
	}
	return ;
}
void insert2(int v) {
	int lst=st;
	st^=1,memset(dp[st],0x3f,sizeof(dp[st]));	
	ffor(i,1,o+o) ffor(op,0,1) {
		if(i<=o) dp[st][i-1][op]=min(dp[st][i-1][op],dp[lst][i][op]-v);	
		else dp[st][i-1][op]=min(dp[st][i-1][op],dp[lst][i][op]+v);
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	ffor(i,1,n) cin>>a[i],lsh[++tot]=a[i];
	ffor(i,1,k) cin>>t[i],lsh[++tot]=t[i];
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	set<int> St;
	ffor(i,1,k) St.insert(t[i]);
	ffor(i,1,n) if(St.find(a[i])!=St.end()) St.erase(a[i]); else St.insert(a[i]);	
	ffor(i,1,n) cnt1[find(a[i])]++;
	for(auto id:St) cnt2[find(id)]++;
	memset(dp,0x3f,sizeof(dp));
	dp[0][o][0]=0;
	ffor(i,1,tot) {
		ffor(j,1,cnt1[i]) insert1(lsh[i]);
		ffor(j,1,cnt2[i]) insert2(lsh[i]);	
	}
	if(dp[st][o][0]<=5e13) cout<<dp[st][o][0];
	else cout<<-1;
	return 0;
}
```

---

## 作者：EuphoricStar (赞：1)

挺有意思的题。

首先显然地，一个棋子不会走回头路。于是一个棋子沿着边走的效果就是区间异或。

更进一步，设 $s_i$ 为 $i-1 \to i$ 的边颜色与 $i \to i+1$ 的边颜色是否相同（差分），相当于对于每个 $i$ 都选择 $s_{a_i}$ 和 $s_{x_i}$，将它们异或上 $1$（$x_i$ 任选），代价为 $|a_i - x_i|$，最后要求恰好 $k$ 个位置 $t_1,t_2,...,t_k$ 为 $1$，求最小代价。

$s_{a_i}$ 的异或操作可以事先处理。操作后需要被 $a_i$ 异或奇数次的位置可知，设这样的位置有 $m$ 个，分别为 $b_1,b_2,...,b_m$。现在问题又变成了，数轴上有 $n$ 个红点 $a_1,a_2,...,a_n$ 和 $m$ 个蓝点 $b_1,b_2,...,b_m$，红点和红点可以匹配（随便选一个它们之间的点互相抵消），红点和蓝点也可以匹配，要求每个蓝点和每个红点都要被匹配，每对匹配的价值是坐标之差的绝对值，求最小代价。

考虑 $n = m$ 怎么做。这个是个经典问题，$a$ 和 $b$ 排序后每对匹配相交一定不优，于是答案就是排序后 $ans = \sum\limits_{i=1}^n |a_i - b_i|$。

现在 $n > m$（如果 $n < m$ 就无解），不妨沿用 $n = m$ 时的结论。不难得出两个红点仅当它们在红点之中相邻才能形成匹配。发现数据范围允许 $O(nm)$，大力 dp，设 $f_{i,j}$ 为排序后前 $i$ 个红点和前 $j$ 个蓝点都能匹配的代价最小值。有转移：

$$f_{i,j} \gets \min(f_{i-1,j-1} + |a_i - b_j|, f_{i-2,j} + a_i - a_{i-1})$$

答案为 $f_{n,m}$。

[code](https://atcoder.jp/contests/arc114/submissions/40811049)

---

## 作者：qzmoot (赞：0)

# 题解：AT_arc114_d [ARC114D] Moving Pieces on Line
## 题目大意
给你一条链，每条边初始值为 $0$，有 $n$ 个棋子在图上面，每个棋子可以往左或者右移动一格，经过的边的值会反转。求达到最后局面的最小操作数，或者判断无解。
## 分析
神仙转换题。

对于每个棋子我们发现，他不可能经过同一条边多次。思考如下：

1. 假若经过偶数次（次数大于 $0$），那么则没有贡献，因为最后还是回到了初始值，还白费了力气。
2. 假若经过奇数次（次数大于 $1$），那么最后的值还是等于次数为 $1$ 的方法。

所以我们得出结论，每一条边对于一个棋子来说只可能走 $1$ 或 $0$ 次。

知道这个结论之后我们可以再进行一个神仙转化，我们不在意边的颜色，只在意从哪里开始边的颜色不一样了。这样我们的区间变色操作就成为了对于起点固定，寻找终点，在起点和终点上异或的操作。也就是所谓的差分。

于是我们就把目标和我们的起点丢到一起，再排序，对于出现偶数次的点就不需要我们转化了，已经消除了。那么如果最后数组的大小比我们的棋子数量要大的话，说明我们不管怎么样都不可能做到，输出 $-1$。

于是我们考虑 dp。

先考虑我们的棋子数量和我们需要转化的点的数量相同的做法，我们直接排序后对应匹配就行了。

若棋子数量更多一些，我们只能选择让两个棋子到同一个点上来消除贡献，这样才能够满足其他的棋子能够匹配。

令棋子坐标为 $a_i$，需要转移的位置为 $c_j$。

转移方程就是：$f_{i,j}=\min(f_{i-1,j-1}+|a_i-c_j|,f_{i-2,j}+a_i-a_{i-1})$。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define pb emplace_back
using namespace std;
const int N=5005;
int n,m;
int a[N];
vector<int>b,c;
int f[N][N];
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]),b.pb(a[i]);
	for(int i=1,k;i<=m;i++)
		scanf("%lld",&k),b.pb(k);
	sort(a+1,a+1+n);
	sort(b.begin(),b.end());
	c.pb(0);
	for(int i=0,j=0;i<b.size();i=++j)
	{
		while(j<b.size()-1 && b[j+1]==b[i])
			j++;
		if((j-i+1)&1)
			c.pb(b[i]);
	}
	if(n<c.size()-1)
		return puts("-1"),0;
	memset(f,0x3f,sizeof f);
	f[0][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<c.size();j++)
		{
			f[i][j]=f[i-1][j-1]+abs(a[i]-c[j]);
			if(i>=2)
				f[i][j]=min(f[i][j],f[i-2][j]+a[i]-a[i-1]);
		}
	printf("%lld",f[n][c.size()-1]);
	return 0;
}
```

---

## 作者：Inui_Sana (赞：0)

非常巧妙的题！

先尝试分析一些简单的性质。

首先，每个棋子可以视作只往一个方向移动若干距离，因为这个操作相当于原本边权为 $0$，每走一步将边权 $\oplus1$。显然走回头路会抵消掉之前走的。也就是说，可以将问题转化成，对于每个 $a_i$ 选择一个 $b_i$，将 $[a_i,b_i]$ 间的边权 $\oplus 1$，使得最后的边权序列满足要求。

其次，棋子移动的终点一定是原本的某个 $a_i$ 或者 $x_i$。否则，可以通过调整变成这种情况并且不劣。称这些点为关键点。

此时其实可以写出一个 $O(n^4)$ dp：设 $dp_{i,j,k,l}$ 表示包含第 $i$ 个关键点的区间，设当前位置为 $x$，有 $j$ 个的 $a_i<x$，$k$ 个的 $a_i>x$，还有 $l$ 个没有确定。转移甚至可能还不是 $O(1)$ 的，但是显然不对所以就没写。

先尝试优化，可能会根据想到进行一些分讨，但是看着就不太行。于是再考虑进行转化。仔细想想，区间异或，只有若干个关键点，会想到？对了，**差分**！

考虑把操作和限制都转化成差分数组上的。操作变成，每次选择 $a_i$ 和任意一个位置 $\oplus 1$，限制变成，要求最后若干个位置是 $1$。于是可以得到还有若干个位置需要 $\oplus1$，而对于若干个可以任意选择的位置，要不两两匹配，要不找一个还需要 $1$ 的位置匹配。

于是把 $a_i$ 和需要 $1$ 的位置放在一起排序后 dp（话说似乎是种不同的 dp）：设 $dp_{i,j,0/1}$ 表示到了第 $i$ 个位置，当前还有 $j$ 个没有匹配，并且没有匹配的是 $a_i$/需要 $1$ 的位置。容易证明两种不会同时没有匹配，因为这样的话在前面就先匹配上更优。转移是 trivial 的，使用一些费用提前计算的技巧即可。

于是时间 $O(n^2)$，空间滚动后 $O(n)$ 通过了这题。

code：

```cpp
int n,m;
ll dp[2][N][2];
pii a[N];
map<int,int> c;
void Yorushika(){
	read(n,m);
	rep(i,1,n){
		read(a[i].fi);
		c[a[i].fi]^=1;
	}
	rep(i,1,m){
		int x;read(x);
		c[x]^=1;
	}
	m=0;
	int cnt=0;
	for(auto [i,j]:c){
		cnt+=j;
		if(j){
			a[++n]=Mp(i,1);
		}
	}
	if(cnt+cnt>n){
		puts("-1");
		return;
	}
	sort(a+1,a+n+1);
	mems(dp,0x3f);
	dp[0][0][0]=0;
	rep(i,1,n){
		int p=i&1;
		mems(dp[p],0x3f);
		rep(j,1,n){
			dp[p][j-1][0]=min(dp[p][j-1][0],dp[p^1][j][0]+1ll*(a[i].fi-a[i-1].fi)*j);
		}
		rep(j,1,n){
			dp[p][j+1][1]=min(dp[p][j+1][1],dp[p^1][j][1]+1ll*(a[i].fi-a[i-1].fi)*j);
		}
		dp[p][1][1]=min({dp[p][1][1],dp[p^1][0][0],dp[p^1][0][1]});
		if(!a[i].se){
			rep(j,1,n){
				dp[p][j-1][1]=min(dp[p][j-1][1],dp[p^1][j][1]+1ll*(a[i].fi-a[i-1].fi)*j);
			}
			rep(j,1,n){
				dp[p][j+1][0]=min(dp[p][j+1][0],dp[p^1][j][0]+1ll*(a[i].fi-a[i-1].fi)*j);
			}
			dp[p][1][0]=min({dp[p][1][0],dp[p^1][0][0],dp[p^1][0][1]});
		}
	}
	printf("%lld\n",min(dp[n&1][0][0],dp[n&1][0][1]));
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---


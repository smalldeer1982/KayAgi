# [ARC128E] K Different Values

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc128/tasks/arc128_e

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $，及び整数 $ K $ が与えられます．

以下の条件を両方満たす整数列 $ x $ を作ることを考えます．

- 各整数 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について，$ x $ はちょうど $ A_i $ 個の $ i $ を含む． また逆に，それ以外の整数を含まない．
- $ x $ の中で連続するどの $ K $ 個を見ても，その $ K $ 個の値はすべて異なる．

条件を満たす $ x $ を作ることが可能かどうか判定し，可能な場合は条件を満たす中で辞書順最小の $ x $ を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ K\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ A_i $
- $ \sum_{1\ \leq\ i\ \leq\ N}\ A_i\ \leq\ 200000 $
- 入力される値はすべて整数である

### Sample Explanation 1

$ x=(1,2,3,1,2),(2,1,3,2,1) $ の二つが条件を満たし，その中で辞書順最小の $ (1,2,3,1,2) $ が答えになります．

## 样例 #1

### 输入

```
3 3
2 2 1```

### 输出

```
1 2 3 1 2```

## 样例 #2

### 输入

```
3 2
2 1 2```

### 输出

```
1 2 3 1 3```

## 样例 #3

### 输入

```
3 3
1 3 3```

### 输出

```
-1```

# 题解

## 作者：ZillionX (赞：4)

# Description

给定一个长度为 $n$ 的序列 $a$，构造一个字典序最小的序列 $x$ 满足：

- 对于每个 $a_i$，$x$ 满足包含 $a_i$ 个 $i$，且 $x$ 不包含其他数
- 对于 $x$ 中任意的长度为 $K$ 的连续段，段中的值互不相等

若无解则输出 ```-1```。

$n,K \le 100, \sum a_i \le 2 \times 10^5$，时限 2s。

# Solution

我们首先找出判断无解的条件。

容易发现，我们可以给 $x$ 序列分块，每块大小为 $K$，最后一段的大小为 $g \le K$，设总共有 $c$ 块，则有解的充要条件是 $\forall a_i \le c, 
\sum [a_i=c] \le g$。读者自证不难。

由此条件容易想出一个构造任一可行解的方法：先把 $a_i=c$ 的数扔到每块最前面，然后剩下的数没填一个数就往右移 $K$ 格，若没法移了就回到第一个空格。

现在我们考虑如何构造一个字典序最小解。这个显然可以贪心做。

我断言这样的贪心做法是正确的：每次将最小的没有在前 $K-1$ 个位置出现过的放在最前面，若 $\sum [a_i=c]=g$ 则只能选 $a_i=c$ 的数，然后递归处理长度 $-1$ 的子问题。

这个做法看起来挺靠谱的，手玩几组样例可以验证其正确性。我们考虑反证。

- 若第一个不合法的位置有 $\sum [a_i=c]=g$：则所有 $a_i=c$ 的数都在前面出现过，则对于包含前面 $K-1$ 个数的情况，有 $g$ 变小 $1$ 但 $\sum [a_i=c]$ 不变，矛盾。

- 否则：至多有 $K-1$ 个数满足 $a_i \neq 0$，假设后面还有 $S$ 个空位，若 $S \ge K$ 的话必然有 $\sum [a_i \neq 0] \ge K$，因此后面只能有 $S<K$ 个空格，则此时 $\sum [a_i=c]=g$，矛盾。

按给定的方法显然能找出最优解。

时间复杂度 $\mathcal O(n \sum a_i)$。

# Code

```cpp
const int N=505;
int n,m,k,a[N],pr[N];
int g(int x) {
	if (!(x%k)) return k;
	return x%k;
}
int main() {
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	int sp=0,m=0;
	for (int i=1;i<=n;i++) m+=a[i],pr[i]=-k;
	for (int i=1;i<=n;i++) {
		if (a[i]>(m-1)/k+1) {
			printf("-1");
			return 0;
		}
		sp+=(a[i]==(m-1)/k+1);
	}
	if (sp>g(m)) {
		printf("-1");
		return 0;
	}
	for (int i=1;i<=m;i++) {
		sp=0;
		for (int j=1;j<=n;j++) sp+=(a[j]==(m-i)/k+1);
		if (sp==g(m-i+1)) {
			for (int j=1;j<=n;j++)
				if (a[j]==(m-i)/k+1 && pr[j]+k<=i) {
					printf("%d ",j),a[j]--,pr[j]=i;
					break;
				}
		}
		else {
			for (int j=1;j<=n;j++)
				if (a[j] && pr[j]+k<=i) {
					printf("%d ",j),a[j]--,pr[j]=i;
					break;
				}
		}
	}
	return 0;
}

```


---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/AT_arc128_e)

**题目大意**

> 给出 $m$ 个值域 $[1,n]$ 的元素，其中有 $a_i$ 个 $i$，求一组字典序最小的排列使得每个长度为 $k$ 的子区间中都没有相同元素。
>
> 数据范围：$n\le 500,m\le 2.5\times 10^5$。

**思路分析**

容易发现同一种颜色的元素最多填 $\left\lceil\dfrac nk\right\rceil$ 个，并且这样的元素至多 $n\bmod k$ 个。

可以递归证明这个条件是充分的。

构造方案时从小到大找到第一个可以填并且上一次填入位置距离当前位置 $\ge k$ 的元素即可。

时间复杂度 $\mathcal O(nm)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=505,MAXL=2e5+5;
int n,m,k,a[MAXN],mx,cnt[MAXL],pre[MAXN];
void del(int x) {
	--cnt[a[x]];
	if(!cnt[mx]) --mx;
	++cnt[--a[x]];
}
void add(int x) {
	--cnt[a[x]];
	++cnt[++a[x]];
	if(cnt[mx+1]) ++mx;
}
bool judge() {
	if(!n) return true;
	if(n%k) return mx<n/k+1||(mx==n/k+1&&cnt[mx]<=n%k);
	return mx<n/k||(mx==n/k&&cnt[mx]<=k);
}
signed main() {
	scanf("%d%d",&m,&k);
	for(int i=1;i<=m;++i) {
		scanf("%d",&a[i]),n+=a[i];
		mx=max(mx,a[i]),++cnt[a[i]];
	}
	while(n--) {
		for(int i=1;i<=m;++i) if(a[i]&&(!pre[i]||pre[i]>=n+k)) {
			del(i);
			if(judge()) { printf("%d ",i),pre[i]=n; goto fd; }
			add(i);
		}
		return puts("-1"),0;
		fd:;
	}
	return 0;
}
```

---

## 作者：Sampson_YW (赞：1)

从前往后确定序列第 $i$ 位该填什么数。记 $las_x$ 表示 $x$ 在序列中最后一次出现的位置。假如没有数量的限制，那么一定是找到最小的 $x$ 使得 $i-las_x>K$ 将 $x$ 填进去。

但是现在出现了数量的限制，考虑何时不得不填最小值之外的数。将 $[i,n]$ 按 $K$ 分段。设最后一段长度为 $v$，去掉最后一段后有 $w$ 段。那么如果出现次数等于 $w+1$ 的数有恰好 $v$ 个，那么就必须填这 $v$ 个数中的一个，否则这 $v$ 个数就会在 $[i+1,n]$ 中填不下。如果按照这种策略填不出答案就是无解。

[code](https://atcoder.jp/contests/arc128/submissions/47983852)

---

## 作者：shiruoyu114514 (赞：0)

考虑按位贪心，即每次选择一个最小的能够使得后面有至少一个选择方案的方案选择。

首先我们探究一下一个序列有解的充要条件。直觉地，我们可以每次选择 $K$ 个不相同的点放在最前面，直到最后剩余的点不足 $K$ 个，并且每种颜色都有 $\le 1$ 个。此时把它们放在最前面即可。既然 $N=K$ 时都能通过 $1234\dots K12 \dots K1234$ 来构造（如果最后的是其它数那么把前面的 $K$ 个数作适当置换使得最后的数合法），而且每次拉的 $K$ 个数不相同，所以能这么构造显然是充要条件。

此时就能转化为这样一个问题：有 $nK$ 堆石子，每次可以从 $K$ 堆石子中取正好一个，问能不能取完。

>结论：当且仅当最大的那堆不超过 $n$ 个才能取完。
>
>证明：首先只能取 $n$ 轮，所以最大的那堆如果超过 $n$ 个一定取不完。其次正好等于 $n$ 个的至多有 $K$ 堆，取这 $K$ 堆就能转化为 $K \leftarrow K-1$ 的子问题了。

类似的，$nK+c$ 的石子个数则是至多 $n+1$ 个，并且有 $n+1$ 个的堆数至多为 $c$。

于是我们就能初步地作此按位贪心：假设当前需要考虑后 $nK+c$ 个位置。如果 $n+1$ 个的堆数正好为 $c$ 那就从它们中选择，否则随便选一个。（当然不能选之前 $K-1$ 个出现过的）

看上去是对的。但是万一由于前面 $K$ 个的限制，导致在选择当前位之后无法构造了呢？

显然这种问题等价于当前位无数可选。如果 $n+1$ 个的堆数正好为 $c$，并且这些数全部在前 $K-1$ 个出现过，那么在选前一个的时候，如果 $c+1$ 不为 $n$（即 $n$ 没有减 $1$），那么前一个所对应的颜色在当时就有 $n+2$ 个，不符合所有都至多 $n+1$ 个的限制，早该无解了。否则此时正确的 $c$ 为 $0$，正确的 $n$ 为 $n+1$，也等价于所有数都至多 $n+1$ 个，无解。

否则如果可选的数只有 $K-2$ 种，那么由于上限是 $n+1$，所以总数上限为 $nK+K-2n-2$。由于 $n \ge K$，所以此时的石子数量 $\le (n-1)K$。而由于整数除法的特性，石子数量 $\ge nK$，矛盾。

于是显然可以构造。每次暴力选出一种数即可。时间复杂度 $O(n\sum a)$。

---

## 作者：R_shuffle (赞：0)

解释一下题面，即对于每个数 $i$ ，我们都有 $a_i$ 个数 $i$ ，现在要把这 $\sum\limits_{i=1}^{n}a_i$ 个数排成一列，要求任意两个相等的数中间不能隔少于 $k-1$ 个数，问是否有这样的序列，如果有，给出字典序最小的构造。

这里给的限制可以认为在某种程度上是“连续”的。而这种“连续”的限制在判断时也会消耗很多的时间，基本是 $O(n)$ 的判断。那么考虑减少限制条数，由于要求相同的数之间间隔的数最少为 $k-1$ ，所以我们显然有任意长度为 $k$ 的区间，区间包含的数都是不相同的。因此我们能把序列分块，以 $k$ 为一个块长（最后一个散块单独考虑），显然每个块内的所有元素都是不同的，所以我们有了一个必要条件。考虑这个条件是否充分。如果我们有了每个块内的元素都不相同，显然是不能保证任意两个相同的数之间的间隔的数不超过 $k-1$ 个，但是我们可以通过重排实现，这是显然的，考虑极端情况，也就是每个块包含的元素都是一样的，这时我们显然对每个块从小到大排即可。所以，我们可以得出原限制的等价形式：能把这 $\sum\limits_{i=1}^na_i$ 个数划分为 $\lceil\frac{\sum\limits_{i=1}^na_i}{k}\rceil$ 个集合，且至多 $1$ 个集合不是 $k$ 个元素的，那么我们一定能构造出来一个合法方案。

现在我们可行性有了，考虑最优性，由于等价性，所以我们对于每个集合贪心的选，也贪心的排列这些集合，答案一定最优。

问题就是代码实现了，代码实现只需要从前到后考虑序列的每一位填什么，由于我们可能把序列填到那个唯一大小不为$k$的集合只有一种方案，所以注意特判一下即可。

---


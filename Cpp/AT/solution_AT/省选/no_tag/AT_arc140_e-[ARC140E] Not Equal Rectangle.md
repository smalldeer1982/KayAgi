# [ARC140E] Not Equal Rectangle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc140/tasks/arc140_e

$ N\ \times\ M $ のマス目があり、あなたはこれから全てのマスに $ 1 $ 以上 $ 25 $ 以下の整数を $ 1 $ つずつ書き込みます。上から $ i $ 行目、左から $ j $ 列目のマスに書き込む整数を $ a_{i,j} $ とします。

以下の条件を満たす整数の書き込み方を一つ求めてください。本問題の制約下で、条件を満たす整数の書き込み方が必ず存在することが証明できます。

- 任意の整数 $ 1\leq\ x_1\ <\ x_2\leq\ N,1\leq\ y_1\ <\ y_2\ \leq\ M $ について、$ a_{x_1,y_1},a_{x_1,y_2},a_{x_2,y_1},a_{x_2,y_2} $ が全て一致してはならない。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ ,\ M\ \leq\ 500 $
- 入力は全て整数

### Sample Explanation 1

$ (x_1,x_2,y_1,y_2) $ の組として考えられるのは $ (1,2,1,2),(1,2,2,3),(1,2,1,3) $ の $ 3 $ つです。 どの組についても $ 4 $ マスに書かれた数字が全て一致してはいないので、この出力は条件を満たします。

## 样例 #1

### 输入

```
2 3```

### 输出

```
1 1 1
1 2 3```

# 题解

## 作者：rui_er (赞：9)

萌萌构造题，随便构造构造就做出来了。似乎跟官方题解思路一样。

首先解决以下问题：给定一个质数 $P$，构造一个每个数在 $0\sim P-1$ 的大小为 $P^2\times P^2$ 的矩阵，满足不存在 $x_1\ne x_2,y_1\ne y_2$ 使得 $a_{x_1,y_1}=a_{x_1,y_2}=a_{x_2,y_1}=a_{x_2,y_2}$。

类似 $9\times 9$ 的数独那样，我们将所求矩阵划分为 $P^2$ 个大小为 $P\times P$ 的宫。如果一个宫 $M$ 满足 $M_{i,j}=(i+j+k)\bmod P$，就称其为 $k$ 类宫，记作 $B_k$。

例如，$P=3$ 时：

$$
B_0=
\begin{bmatrix}
0 & 1 & 2 \\
1 & 2 & 0 \\
2 & 0 & 1 \\
\end{bmatrix},
B_1=
\begin{bmatrix}
1 & 2 & 0 \\
2 & 0 & 1 \\
0 & 1 & 2 \\
\end{bmatrix},
B_2=
\begin{bmatrix}
2 & 0 & 1 \\
0 & 1 & 2 \\
1 & 2 & 0 \\
\end{bmatrix}
$$

对于所求矩阵的第 $i$ 行第 $j$ 列的宫，令其为 $B_{ij\bmod P}$ 即可。

例如，$P=3$ 时：

$$
A=
\begin{bmatrix}
B_0 & B_0 & B_0 \\
B_0 & B_1 & B_2 \\
B_0 & B_2 & B_1 \\
\end{bmatrix}
=
\begin{bmatrix}
0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 \\
1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 & 0 \\
2 & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 \\
0 & 1 & 2 & 1 & 2 & 0 & 2 & 0 & 1 \\
1 & 2 & 0 & 2 & 0 & 1 & 0 & 1 & 2 \\
2 & 0 & 1 & 0 & 1 & 2 & 1 & 2 & 0 \\
0 & 1 & 2 & 2 & 0 & 1 & 1 & 2 & 0 \\
1 & 2 & 0 & 0 & 1 & 2 & 2 & 0 & 1 \\
2 & 0 & 1 & 1 & 2 & 0 & 0 & 1 & 2 \\
\end{bmatrix}
$$

证明采用反证法：假设存在相等的四个数位于两行、两列的交点，显然必须在四个不同的宫，设左上、右上、左下、右下对应的宫分别是 $a,b,c,d$ 类宫，则有 $a-b=c-d$，但是这不可能发生。

解决了上面的问题，原问题便迎刃而解了。

代码：

```cpp
const int P = 23;
cin >> n >> m;
for(int i = 0; i < n; ++i) {
    for(int j = 0; j < m; ++j) {
        int val = ((i / P) * (j / P) + i + j) % P + 1;
        cout << val << " \n"[j == m - 1];
    }
}
```

---

## 作者：cwfxlh (赞：1)

## [AT_arc140_e [ARC140E] Not Equal Rectangle](https://www.luogu.com.cn/problem/AT_arc140_e)    

比较菜，没想出来。     

考虑一种常用的思路，将这个矩阵分成若干子矩阵后，每个子矩阵都可以写成某个初始矩阵在值域上的循环位移。    

先构造一个 $25\times 25$ 的矩阵 $G$，其第 $i$ 行第 $j$ 列的元素为 $(i+j)\bmod 25$，然后考虑它在值域上循环位移后的矩阵，$G_k$ 满足 $G_{k}[i][j]=(i+j+k)\bmod 25$。   

然后考虑怎么用 $G_k$ 填上 $25\times 25$ 的格子。     

如果一个填法不合法，那么考虑出问题的四个角一定在不同的子矩阵，令其类型分别为 $G_a,G_b,G_c,G_d$ 中，则必定满足 $a-b\equiv c-d \bmod 25$。    

如果模数是 25 可能不太容易看出来，但是如果换成一个质数，比如 23，那就很容易看出来了。由于四个角分别纵坐标相同，横坐标相同，所以我们令第 $i$ 行第 $j$ 列的子矩阵类型为 $G_{ij\bmod 23}$。   

上述等式变成     

$$x_1y_1-x_2y_1\equiv x_1 y_2-x_2 y_2\bmod 23$$    

$$(x_1-x_2) y_1\equiv (x_1-x_2) y_2\bmod 23$$     

$$(x_1-x_2)(y_1-y_2)\equiv 0\bmod 23$$     

显然的，因为横纵坐标都小于模数，所以上述等式无法成立。于是做完了。         

代码：     


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[1003][1003],f[25][25];
int getmod(int X){
	if(X%23==0)return 23;
	return X%23;
}
int main(){
	ios::sync_with_stdio(false);
	for(int i=1;i<=23;i++){
		for(int j=1;j<=23;j++)f[i][j]=getmod(i+j);
	}
	for(int i=0;i<23;i++){
		for(int j=0;j<23;j++){
			int oo=i*j%23;
			for(int u=1;u<=23;u++){
				for(int o=1;o<=23;o++)ans[i*23+u][j*23+o]=getmod(f[u][o]+oo);
			}
		}
	}
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)cout<<ans[i][j]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：Schi2oid (赞：1)

# [ARC140E] Not Equal Rectangle 题解

## 题意简述

给出一个 $N\times M(N,M\le 500)$ 的方格图，要求在方格中填入 $1\sim 25$ 的数字，使得不存在一个子矩形的四个角上填入的数字相同。

## 思路分析

首先，我们可以将 $N\times M$ 的方格图扩大，使得 $N=M=23^2$，然后再输出其子矩阵作为答案。

接下来，我们根号分块，以边长为 $23$ 的正方形为一块。接下来，考虑每一种数字（我们只会用到 $23$ 种数字），它们应该在每个块中都出现 $23$ 次。我们可以先填出数字 $1$ 的方案，接下来将其在每一个块中的填法进行横向的循环位移，就可以得到其他数字的方案，正确性显然。记块中最左上角的块坐标为 $(0,0)$，如果数字 $1$ 填在了 $(x,y)$，那么数字 $m$ 就应该相应地填在 $(x,(y+m-i)\bmod 23)$。

对于数字 $1$，我们不妨直接将其填在最左上角一块的对角线上，其他填法可以通过交换列得到，即填在 $\{x\in [0,22]|(x,x)\}$。接下来，我们通过对左上角一块进行横向循环位移得到其他所有块。记 $D(x,y)$ 表示位于第 $x$ 行第 $y$ 列的 $23\times 23$ 的块相对于最左上角的块进行了多少次横向循环位移，那么，显然可以发现，不符合题目条件当且仅当存在 $x_1,x_2,y_1,y_2\in [0,22],x_1\not =x_2,y_1\not =y_2$ 使得 $D(x_1,y_1)-D(x_2,y_1)\equiv D(x_1,y_2)-D(x_2,y_2)\pmod {23}$。考虑一个函数：$D(x,y)=x(y-1)$。那么，如果不符合题意，需要满足：

$$
x_1(y_1-1)-x_2(y_1-1) \equiv x_1(y_2-1)-x_2(y_2-1) \\
x_1y_1-x_2y_1 \equiv x_1y_2-x_2y_2 \\
(x_1-x_2)y_1 \equiv (x_1-x_2)y_2
$$

由于 $x_1,x_2\in [0,22]$，所以 $(|x_1-x_2|,23)=1$，上式子化为 $y_1\equiv y_2$，矛盾，故这样的构造符合题目条件。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[630][630];
int main(){
	int n,m;
	for(int i=1;i<=23;i++){
		for(int j=1;j<=23;j++){
			for(int pyl=0;pyl<=22;pyl++){
				int xbase=(i-1)*23,ybase=(j-1)*23;
				int tpyl=(pyl+(j-1)*i)%23;
				for(int k=1;k<=23;k++){
					a[xbase+k][ybase+((k+tpyl-1)%23)+1]=pyl+1;
				}
			}
		}
	}
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) printf("%d ",a[i][j]);
		puts("");
	}
	return 0;
}
```

---

## 作者：APJifengc (赞：1)

很神奇的构造题，我瞎构造一通然后出来了。

首先观察数据范围，$n\le 500$，$25$ 大概是根号级别的。所以我们考虑构造 $B \times B$ 个 $B \times B$ 的矩形拼接在一起。

我们先考虑固定住一行矩形，然后下面每一行都由第一行值域平移而来。这样我们要构造的这一行矩形需要满足的条件就是：不存在 $x_1, x_2, y_1, y_2$，满足 $a_{x_1,y_1} = a_{x_1, y_2}$ 且 $a_{x_2, y_1} = a_{x_2, y_2}$。（因为值域平移了 $B$ 次，所以每一行的数是啥不重要，肯定都会出现一次，只需要这一行两个数相等即可）

那么我们可以考虑先选出来两个相等的数（以 $1$ 举例），那么接下来我们需要满足这两个数所在的两列数只有 $1$ 是相同的，其它都不相同。考虑裴蜀定理，我们可以令每一列数为一个等差数列，对于从左到右第 $i$ 个矩形（从 $0$ 开始），第 $j$ 列为首项为 $j$，公差为 $i$ 的数列。这样就能满足每两列只有一个数字相同了。

那么我们只需要选取一个质数 $B$ 即可。发现 $23^2 = 529 > 500$，所以选取 $B=23$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 605;
int n, m;
int a[MAXN][MAXN];
int B = 23;
int main() {
    for (int i = 1; i <= B; i++) {
        for (int j = 1; j <= B; j++) {
            for (int k = 1; k <= B; k++) {
                a[k][(i - 1) * B + j] = ((j - (i - 1) * (k - 1) - 1) % B + B) % B + 1;
            }
        }
    }
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        int off = (i - 1) / B, row = (i - 1) % B + 1;
        for (int j = 1; j <= m; j++) {
            printf("%d ", (a[row][j] + off - 1) % B + 1);
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：R_shuffle (赞：0)

显然，如果整体满足条件，那么局部也满足条件。

现在就考虑把如何构造出来一个超过 $500\times 500$ 的矩形，能够满足条件。

有一个不考虑时间的做法就是先打表，然后再输出。

考虑正经的做法，这种不重复的问题容易想到类似数独的东西，所以实际上可以把整体切成若干小块，考虑每个小块与小块之间的，以及小块内部的。

类似分块思想，我们需要保证每块内部合法，且保证把每块都看做一个整体之后也合法。所以就要保证，只要四个块不够成一个矩形的四个顶点，那么就不会产生不合法的解。

所以不妨把整个划分成 $n\times n$ 个块，每个块有 $n\times n$ 个点。显然构造一个块是容易的，用脚都能构造。考虑块块之间，可以得出一个显然的结论，就是任意两个块，对应同一位置的两个数字是不同的。所以实际上我们最多构造 $n$ 个块，但是我们可以把 $n$ 个块按照每个块内部的 $n$ 个点来排。每个块可以用类似循环移位的方式来构造。

为了代码实现的简单，所以可以考虑用一个点的位置与其所属的块来计算这个点的值。具体可以直接把行列宫三个编号加起来取模，模数选择一个质数 $23$ 即可。

```cpp
/*胡金梁*/
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
inline int read()
{
	int f=1,re=0;
	char ch=getchar();
	while(!isdigit(ch)){ if(ch=='-') f=-1; ch=getchar();}
	while( isdigit(ch)) re=(re<<3)+(re<<1)+(ch^'0'),ch=getchar();
	return re*f;
}
signed main()
{
#if __MY_TEST__
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int n=read(),m=read();
	for(int i=0;i<n;i++) for(int j=0;j<m;j++) cout<<((i/23)*(j/23)+i+j)%23+1<<" \n"[j+1==m];
}

```

---

## 作者：xcyyyyyy (赞：0)

### [ARC140E] Not Equal Rectangle 

神奇 ad-hoc 题。

考虑到 $a_{i,j}$ 值域为 25 内，考虑根号分治，取块长 $23 \leq p\leq 25$。对于根号块内，我们找出一个矩阵，使得每一行，每一列的数都不同，记这个矩阵为 $P_0$，考虑 $P_i$ 为将行整体向上移动 $i$ 次后的矩阵（如果超出边界就循环到矩阵最下面）

考虑整个图，我们用 $P_i$ 铺满这个图，此时如果有问题，那么这四个角一定在四个不同的块。

考虑若 $a,b,c,d$ 这四个块（依次为左上，右上，左下，右下）出问题了，那么我们找到 $a,b$ 任意一行的任意一个颜色，将他们对下来在 $c,d$ 块中找到对应的颜色，若这两个颜色在同一行那么就出问题了。

设 $f(u)$ 表示 $u$ 这个块的矩阵为 $P_{f_u}$，按照上面的描述，一定有 $f(c)-f(a) \equiv f(d)-f(b)\pmod p$。

考虑构造一个满足不存在这样的 $p\times p$ 的矩阵，不难想到取根号块长度为 $23$（质数），然后第 $i$ 行（从 $0$ 标号）排上 $P_{0},P_{i},P_{2i}...$，根据逆元的知识知道此时一定合法的情况。

---


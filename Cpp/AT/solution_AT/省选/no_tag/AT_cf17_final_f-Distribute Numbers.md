# Distribute Numbers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/cf17-final/tasks/cf17_final_f

$ 1000 $ 以上 $ 2000 $ 以下の好きな整数 $ N $ と $ 1 $ 以上の好きな整数 $ K $ を選び、以下の問題を解いてください。

#### 問題

$ N $ 枚の紙があります。 これらの紙に以下の条件を満たすように $ K $ 個ずつ整数を書いてください。

- 書く整数は $ 1 $ 以上 $ N $ 以下でなければならない。
- 同じ紙に書かれた $ K $ 個の整数は相異ならなければならない。
- $ 1 $ 〜 $ N $ の整数はいずれも $ K $ 枚ずつの紙に書かれていなければならない。
- どの $ 2 $ 枚の紙をとってきても、それらの紙に共通して書かれた整数がちょうど $ 1 $ つだけ存在する。

## 说明/提示

### Sample Explanation 1

$ N $ が $ 3 $ で $ K $ が $ 2 $ の例です。 ただし、$ N $ の制約を満たしていないためこの出力は不正解となります。

## 样例 #1

### 输入

```
None```

### 输出

```
3 2
1 2
2 3
3 1```

# 题解

## 作者：dead_X (赞：4)

## 题意
这是一道提交答案题。

你需要构造 $n$ 个集合满足以下条件。

* 每个集合包含 $k$ 个数。
* $1,2,3,\cdots,n$ 在每个集合中都出现了 $k$ 次。
* 任意两个集合的交恰好的集合为 $1$。

## Part 1
注意到每两个集合的交集都为 $1$，我们可以考虑某个数让哪几个集合之间互相有交。

我们先考虑**每个数**都出现 $k$ 次这一条件。

这告诉了我们每个数对答案的贡献为 $\frac{k(k-1)}{2}$，结合共出现了 $n$ 个数这一条件，我们可以得到 $\frac{n(n-1)}{2}=n\frac{k(k-1)}{2}$。

因此，我们知道了 $n=k(k-1)+1$，我们就可以捏出几组小数据手玩了。

手玩之后可以发现，我们先钦定一个数在前 $k$ 个集合里面，然后让这 $k$ 个集合去和剩下的 $(k-1)^2$ 个集合依次配对，每个集合再额外包含 $k-1$ 个数。
## Part 2
**该部分 $n$ 的意义与上文不同。**

我们转化题意如下：有 $n^2$ 个数，我们要将它们用 $n$ 种分法分成 $n$ 组，每组 $n$ 个，且不能有两个数同时在两种分法里面都在同一组。

这个东西也可以手玩，失败了几次之后我找到了一种方法，对于所有质数 $n$ 都成立：

首先，将 $n^2$ 个数列成一张 $n\times n$ 的表。

第一种分法为每行一组。

另外 $k$ 种分法中，第 $i$ 种分法在第 $j$ 行的第 $(ij+t) \text{ mod } n$ 属于第 $t$ 组。

这里的策略中，分法，行列下标，组编号均从 $0$ 开始。

易证这个东西对于所有素数均正确。
## Part 3
注意到 $k-1$ 需要是素数，而 $1000\leq k(k-1)+1\leq 2000$，我们考虑依次枚举，最终发现 $k=38$ 或 $42$ 均为合法方案。

时间复杂度 $O(n\sqrt n)$，空间复杂度 $O(n\sqrt n)$。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
#define KKK 37
int a[2003][53],c[2003];
void add(int pos,int col)
{
	a[pos][++c[pos]]=col;
}
int grid(int i,int j)
{
	return KKK*i+j+1;
}
signed main()
{
	int n=(KKK+1)*KKK+1,k=(KKK+1),g=1;
	printf("%d %d\n",n,k);
	for(int i=1; i<=k; ++i) add(i,1);
	int r=n-k;
	for(int i=0; i<KKK; i++) for(int j=0; j<KKK; j++)
	{
		++g,add(i+1,g);
		for(int K=0; K<KKK; K++) add(grid(K,(j+i*K)%KKK)+(KKK+1),g);	
	}
	for(int i=k+1; i<=n;)
	{
		++g,add(k,g);
		for(int j=1; j<k; j++) add(i++,g);
	}
	for(int i=1; i<=n; ++i,puts("")) for(int j=1; j<=k; ++j) printf("%d ",a[i][j]);
    return 0;
}
```

---

## 作者：zhangmj2008 (赞：1)

可能跟上面的所有题解都不完全相同。该做法来自 Proofs from the Book。本人只是搬运。

取素数 $p$，考虑向量空间 $\mathbb{Z} _ p ^ 3 \setminus \{ \mathbf{0} \}$。

划分等价类 $\mathbf{x} \sim k \mathbf{x}$，其中 $k \in \mathbb{Z} _ p \setminus \{ 0 \}$。则恰好有 $p ^ 2 + p + 1$ 个等价类。

构造二部图 $G$ 如下：

- $G$ 的左部点，右部点分别是所有 $p ^ 2 + p + 1 $ 个等价类。
- $G$ 的左部点 $\mathbf{x}$ 和右部点 $\mathbf{y}$ 连边当且仅当 $\mathbf{x} \cdot \mathbf{y} \equiv 0 \pmod{p}$。

则容易验证：$G$ 是 $p + 1$ 正则图；且任意两个左部点的公共邻居数为 $1$；且任意两个右部点的公共邻居数为 $1$。

所以在本题中，取 $p = 37$ 就完成了构造！

---

## 作者：Mophie (赞：1)

这题是一道构造题。

首先先翻译一下题面：

现在有 $n$ 张纸，你可以在 $n$ 张纸上写上 $k$ 个数（ $n,k$ 自己决定 ），需要满足以下条件：

- 所有数的值都在 $[1,n]$ 以内。

- 每张纸上的数互不相同。

- 所有 $[1,n]$ 内的数恰好出现 $k$ 次。

- 任何两张纸上有且仅有一个数相同。

你需要构造一种满足这些条件的写数方法。

构造方案必须满足 $1000\leq n\leq 2000$

首先可以发现， $k$ 定小并不高效。

比如说当 $n$ 较大时，若 $k$ 设为 $2$ ，则显然无法满足条件。

那么考虑一种 $n=7,k=3$ 的构造方案：

```
7 3
1 2 3
1 4 5
1 6 7
2 4 6
2 5 7
3 4 7
3 5 6
```
可以发现，因为每两张纸只能有一个数相同，且每个数出现 $k$ 次。

那我们可以以最小为 $1$ ，最小为 $2$ …… 最小为 $k$ 来分类。

可以先在一张纸上写下 $1,2,3,\cdots,k$ ，然后再分组，就像这样：

```
7 3
1 2 3
1
1
2
2
3
3

```
这样每组之间只要互不相同就行了。

所以可以得到：$k+(k-1)^2=k^2-k+1 \leq n$ 时可以满足互不相同的条件。

那我们就考虑 $n=k^2-k+1$ 的情况最为轻松。

然后为了互不相同，我们可以先将 $1$ 开头的填完。

```
7 3
1 2 3
1 4 5 
1 6 7
2
2
3
3

```
那么接下来若要取数，则就必须满足在一张纸上写的数不同时取到前 $k$ 张上的数。

那么可以构造一个矩阵

```
4 5
6 7
```
然后接下来对于 $2$ 来讲，只要取不同行的就行。那可以直接取 $4,6$ 和 $5,7$ 作为其它两个数。

然后再对于 $3$ 来讲，因为不能与前面重叠，所以必须取 $4,7$ 和 $5,6$ 作为其它两个数。

也就是错开 $1$ 位。

那接下来若有的话，那错 $2$ 位，错 $3$ 位……就行了。

那这样不会导致不同的两组有大于两个的重复吗？

如只有 $4$ 个数时，那当我们取错 $2$ 位时会有重复。

那这种问题的解决方案就是当 $k+1$ 为质数时就不会冲突了。

所以必须要取 $k+1$ 为质数，才不会发生冲突。

那接下来就没什么难度了，代码也很简短，具体细节看代码吧。

### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int sum=0,nega=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')nega=-1;ch=getchar();}
	while(ch<='9'&&ch>='0')sum=sum*10+ch-'0',ch=getchar();
	return sum*nega;
}
int n,k=38,s[50][50],cnt,pos;
int main()
{
	n=1+k*(k-1);
	cout<<n<<" "<<k<<endl;
	for(int i=1;i<=k;i++)
	{
		cnt=0;
		printf("1 ");
		for(int j=2+(k-1)*(i-1);j<=1+i*(k-1);j++)
		{
			cnt++;
			printf("%d ",j);
			if(i>=2)s[i-1][cnt]=j;
		}
		puts("");
	}
	for(int i=2;i<=k;i++)
		for(int j=1;j<=k-1;j++)
		{
			printf("%d ",i);
			pos=i-2;
			for(int p=1;p<=k-1;p++)printf("%d ",s[p][(pos*(p-1)+j-1)%(k-1)+1]);
			puts("");
		}
	return 0;
}
```


---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/AT_cf17_final_f)

**题目大意**

> 选择一个 $n\in[1000,2000]$，以及一个 $k$，构造 $n$ 个大小为 $k$ 的 $[1,n]$ 子集，使得任意两个集合的交集大小为 $1$，且每个元素出现 $k$ 次。

**思路分析**

把有交的集合连边，那么相当于把 $K_n$ 分解成 $n$ 个 $K_k$，考虑边数：$\dfrac {n(n-1)}2=n\dfrac{k(k-1)}2$，则 $n=k(k-1)+1$。

不妨考虑第 $n$ 个点所在的集合，那么会把 $[1,n-1]$ 分成 $k$ 个组，不妨设为 $[1,k-1],[k,2(k-1)],\dots $。

那么剩下的每个集合在每个组中都恰好选出一个元素，且每个元素被选 $k-1$ 次。

可以发现对于每对 $(i,j)$ 第一组的第 $i$ 个点和第二组的第 $j$ 个点恰在一个组中出现过。

那么一种合法的构造就是对于 $(i,j)$， 选出第 $3$ 组的第 $(j+i)\bmod {k-1}$ 个点，第 $4$ 组的 $(j+2i)\bmod(k-1)$ 个点。

那么两个组的交点就是 $j_1+xi_1\equiv j_2+xi_2\pmod{k-1}$ 的解，容易发现 $k-1$ 为质数时解唯一，取 $k=38$ 即可。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int k=38,n=k*(k-1)+1;
	cout<<n<<" "<<k<<"\n";
	for(int i=0;i<k;++i) {
		for(int j=1;j<k;++j) cout<<i*(k-1)+j<<" ";
		cout<<n<<"\n";
	}
	for(int i=0;i<k-1;++i) for(int j=0;j<k-1;++j) {
		cout<<i+1<<" ";
		for(int t=1,u=j;t<k;++t,u=(u+i)%(k-1)) cout<<t*(k-1)+u+1<<" \n"[t==k-1];
	}
	return 0;
}
```

---


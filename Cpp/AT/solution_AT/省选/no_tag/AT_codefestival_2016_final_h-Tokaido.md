# Tokaido

## 题目描述

[problemUrl]: https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_h

$ N $ 個のマスが一列に並んでおり、左から順に $ 1～N $ の番号が付けられています。 すぬけくんとりんごさんはこのマス目を使って、以下のようなボードゲームで遊ぼうとしています。

1. はじめに、すぬけくんがすべてのマスに $ 1 $ つずつ整数を書く。
2. $ 2 $ 人のプレイヤーはそれぞれ $ 1 $ つずつ駒を用意し、すぬけくんは自分の駒をマス $ 1 $ に、りんごさんは自分の駒をマス $ 2 $ に置く。
3. 自分の駒が相手の駒より左にあるプレイヤーが駒を動かす。駒を動かす先は、今自分の駒が置かれているマスよりも右にあってかつ相手の駒が置かれていないマスでなければならない。
4. *3.* を繰り返し、これ以上駒を動かすことができなくなるとゲームは終了となる。
5. ゲーム終了時までに自分の駒を置いたことのあるマスに書かれた整数の合計が、それぞれのプレイヤーのスコアとなる。

すぬけくんはすでにマス $ i\ (1≦i≦N-1) $ に整数 $ A_i $ を書きましたが、まだマス $ N $ には整数を書いていません。 すぬけくんは $ M $ 個の整数 $ X_1,X_2,...,X_M $ それぞれについて、その数をマス $ N $ に書いてゲームを行ったときに「（すぬけくんのスコア）ー（りんごさんのスコア）」がいくらになるのかを計算することにしました。 ただし、それぞれのプレイヤーは「（自分のスコア）ー（相手のスコア）」を最大化するように駒を動かすものとします。

## 说明/提示

### 制約

- $ 3≦N≦200,000 $
- $ 0≦A_i≦10^6 $
- $ A_i $ の総和は $ 10^6 $ 以下である。
- $ 1≦M≦200,000 $
- $ 0≦X_i≦10^9 $

### 部分点

- $ M=1 $ を満たすデータセットに正解した場合は、$ 700 $ 点が与えられる。
- 追加制約のないデータセットに正解した場合は、上記とは別に $ 900 $ 点が与えられる。

### Sample Explanation 1

ゲームは下図のように進行します。Sはすぬけくんの駒、Rはりんごさんの駒を表しています。 !\[\](https://atcoder.jp/img/code-festival-2016-final/0c38db3b7902579a8bc2d0798b8dda27.png) スコアは $ 2 $ 人とも $ 10 $ となり、「（すぬけくんのスコア）ー（りんごさんのスコア）」は $ 0 $ となります。

## 样例 #1

### 输入

```
5
2 7 1 8
1
2```

### 输出

```
0```

## 样例 #2

### 输入

```
9
2 0 1 6 1 1 2 6
5
2016
1
1
2
6```

### 输出

```
2001
6
6
7
7```

# 题解

## 作者：enucai (赞：2)

## Analysis

我们称先手为 Alice，后手为 Bob。初始时 Alice 的棋子在 $1$ 号位置，Bob 的棋子在 $2$ 号位置。由于 $A_i\ge0$，不难发现，最终的形态一定是 Alice 段与 Bob 段交替出现。而每一段的开头是由自己决策的，结尾是由对手决策的。

考虑朴素 dp，由于自己只能决策开头位置，结尾由对手决策，故考虑倒叙 dp。

令 $f_{i,0/1}$ 表示 $[i,n]$ 这段已经被取完，且开头一段（即包含 $i$ 位置的一段）是由 $0/1$ Alice 或 Bob 取的，这样情况下的 Alice 得分 $-$ Bob 得分。不难写出 dp 式：

$$
f_{i,0}=\min_{j=i+1}^nf_{j,1}+\sum_{k=i}^{j-1}a_k
$$

$$
f_{i,1}=\max_{j=i+1}^nf_{j,0}-\sum_{k=i}^{j-1}a_k
$$

加上前缀和优化就可以单次 $O(n^2)$ 完成 dp。不妨写出代码如下：

```cpp
f[n][0]=a[n],f[n][1]=-a[n];
per(i,n-1,2){
  f[i][0]=1e18,f[i][1]=-1e18;
  rep(j,i+1,n) f[i][0]=min(f[i][0],f[j][1]+sum[j-1]-sum[i-1]);
  rep(j,i+1,n) f[i][1]=max(f[i][1],f[j][0]-sum[j-1]+sum[i-1]);
}
cout<<a[1]+f[2][1]<<"\n";
```

随后，不难发现 $f_{i,0/1}$ 正好是相反数，于是将 dp 状态转换为一维，代码如下：

```cpp
f[n]=a[n];
per(i,n-1,2){
  f[i][0]=1e18;
  rep(j,i+1,n) f[i]=min(f[i],-f[j]+sum[j-1]-sum[i-1]);
}
cout<<a[1]-f[2]<<"\n";
````

再次观察 dp，发现转移后半部分其实可以记录 $sum_{i-1}-f_i$ 的最小值直接转移，于是有：

```cpp
f[n]=a[n]; int mn=sum[n-1]-f[n];
per(i,n-1,2) f[i]=mn-sum[i-1],mn=min(mn,sum[i-1]-f[i]);
cout<<a[1]-f[2]<<"\n";
```

然后我们惊奇地发现 $f$ 数组是没有用的，每个 $f$ 值都只与之前地 $mn$ 有关，再次简化代码：

```cpp
int mn=sum[n-1]-f[n];
per(i,n-1,3) mn=min(mn,2*sum[i-1]-mn);
cout<<2*a[1]-mn<<"\n";
```

接下来就是最为精彩地部分。题目有条件 $\sum A_i\le10^6$，也就是说 $mn$ 的初始值在正的情况下只有 $10^6$ 种值,而初始是负的则 checkmin 操作不会对其产生影响，故不做考虑。

考虑一遍预处理处对于所有 $mn\in(0,10^6]$ 的初始值，循环完后会变成什么值。

当枚举到一个 $sum_i$ 会使 $mn$ 值变小当且仅当 $2\times sum_i-mn<mn$，即 $mn>sum_i$。于是考虑将每个值看作一个点，从大到小枚举所有的 $sum$，暴力的将每个大于当前 $sum$ 且小于上一个 $sum$ 的点往他操作后的点连一条边，最终会构成一个森林，在森林上进行 dfs，就能在线性复杂度内求出每个初始的 $mn$ 在操作完后会变成的值了。

处理完后单次复杂度 $O(1)$，最终复杂度 $O(\sum A_i+q)$。

## Code

```cpp
const int N=200010;
const int M=1000010;
int n,m,mn,sum[N],a[N],fa[M],val[M];
vi son[M];
inline void go(int x,int s){
  int y=2*s-x;
  if(y<=0) val[x]=y;
  else fa[x]=y,son[y].eb(x);
}
inline void dfs(int u,int w){
  val[u]=w;
  for(int v:son[u]) dfs(v,w);
}
signed main(){IOS;
  cin>>n;
  rep(i,1,M-10) val[i]=i;
  rep(i,1,n-1) cin>>a[i],sum[i]=sum[i-1]+a[i];
  per(i,M-10,sum[n-2]+1) go(i,sum[n-2]);
  per(i,n-2,3) rep(j,sum[i-1]+1,sum[i]) go(j,sum[i-1]);
  rep(i,1,M-10) if(!fa[i]) dfs(i,val[i]);
  cin>>m;
  while(m--){
    cin>>a[n],sum[n]=sum[n-1]+a[n];
    mn=sum[n-1]-a[n];
    if(mn<=0) cout<<2*a[1]-mn<<"\n";
    else cout<<2*a[1]-val[mn]<<"\n";
  }
}
```

---

## 作者：zhiyangfan (赞：1)

### 题意
有 $n$ 个方格从左到右编号为 $1\sim n$ 排成一列，初始时每一格上面有一个整数 $a_i$，Snuke 和 Rng 在按照以下的规则玩游戏：
1. 两个人各执一枚棋子，Snuke 放在一号方格，Rng 放在二号方格。
2. 棋子在另一个人左边的人移动，移动的目的地必须是它当前位置的右边且不为对手的位置。
3. 重复执行2.步骤直到无法行动。
4. 每个人的得分是他的棋子经过的格子上面的整数之和。

假设两个人都是足够聪明的，他们都想最大化自己比别人分数高的值。现在 $a_1\sim a_{n-1}$ 已经确定了，给出 $m$ 组询问 $x_i$，每组询问表示如果 $a_n=x_i$，则求出 Snuke 的分数 - Rng 的分数会是多少。($3\le n\le2\times10^5,0\le a_i\le10^6,\sum a_i\le10^6,1\le m\le2\times10^5,0\le x_i\le10^9$)

### 题解
既然是博弈论，那么我们可以先考虑两个人怎么移动是最优的。注意到如果当前格子右边相邻的格子是空着的，则最优步数是棋子走到那里。原因显然，因为格子的权值非负，所以这样走不会损失分数，也不会损失自己的轮次。所以游戏的步骤（计分系统不变）如果改成这样是相同的：
- 每次移动完棋子，玩家要把对手的棋子一格一格移动到他棋子的左边。
- 每次移动完后两个棋子是相邻的。

接下来首先考虑 $m=1$ 的部分分。考虑 $\rm dp$，我们设 $f_i$ 表示从玩家的棋子位置在 $i-1$ 号格子，对手的棋子在 $i$ 号格子开始，能得到的玩家分数比对手多的分数的最大值。注意这里状态不包括 $a_{i-1}$ 和 $a_i$ 的差，这样最终答案即为 $f_2+a_1-a_2$。最朴素的转移为：
$$f_i=\max_{i<j\le n}\{a_j-\operatorname{sum}(a_{i+1}\sim a_{j-1})-f_{j}\}$$
其中 $\operatorname{sum}(a_l\sim a_r)$ 表示 $a_l$ 到 $a_r$ 的和。但这样直接转移是 $\mathcal{O}(n^2)$ 的，显然无法接受。

发现 $f_i=\max_{i<j\le n}\{a_j-\operatorname{sum}(a_{i+1}\sim a_{j-1})-f_{j}\}$，而 $f_{i+1}=\max_{i+1<j\le n}\{a_j-\operatorname{sum}(a_{i+1+1}\sim a_{j-1})-f_{j}\}$，长得真的很像。所以我们考虑能不能把 $f_{i+1}$ 扔到 $f_i$ 的转移里面，这样就会快很多，变一变式子，有：
$$f_{i}=\max\left(\max_{i+1<j\le n}\{a_j-a_{i+1}-\operatorname{sum}(a_{i+1+1}\sim a_{j-1})-f_j\},a_{i+1}-f_{i+1}\right)$$
即，$f_{i}=\max(f_{i+1}-a_{i+1},a_{i+1}-f_{i+1})$。可以做到 $\mathcal{O}(n)$ 转移了。

接下来考虑正解。注意到原式子其实就是 $f_{i}=|f_{i+1}-a_{i+1}|$。那这样我们就没必要再用 $f$ 数组来递推结果了，直接用一个 $x$ 记录结果，考虑以下伪代码：
```
x := a[n]
for i := n - 1 down to 3 
    x := abs(x - a[i])
ans := x + a[1] - a[2]
```
我们叫这个算法 x 算法，接下来的问题就是当 `a[n]` 改变时快速计算 $x$ 的值。（注意接下来我们不再考虑 `a[1]-a[2]` 的值，因为只有 $x$ 的值是有用的）

当 $a_n$ 很大时，具体来讲，当 $a_n\ge \operatorname{sum}(a_1\sim a_{n-1})$ 时，所有 $\operatorname{abs}(x-a_i)$ 都应该等于 $x-a_i$，这样最终的 $x$ 就等于 $a_n-\operatorname{sum}(a_3\sim a_{n-1})$。

当 $a_n$ 比较小时，具体来讲，当 $a_n< \operatorname{sum}(a_1\sim a_{n-1})$ 时，由于题目数据范围的限制，应该有 $a_n\le 10^6$。这个就比原范围 $10^9$ 来得友好得多了，我们可以考虑对每一种情况都提前预处理一下。具体来讲，我们设 $dp_{j,k}$ 表示当伪代码中的循环运行到 $i=j$ 时（特别地，我们令第 $i=n$ 表示循环之前的那一行语句），$x$ 的值为 $k$，$x$ 的最终值为 $dp_{j,k}$。首先显然有 $dp_{3,k}=k$，然后当对于 $a_n$ 的某个特定值，$x$ 的最终值为 $dp_{n,a_n}$。转移有 $dp_{j+1,k}=dp_{j,\operatorname{abs}(k-a_j)}$。当然我们不可能真的开下这样一个 $dp$ 数组，我们关心的只有 $dp_n$ 这一行，所以我们尝试用小数据打个表，看看能不能找到 $dp_n$ 的什么规律，当 $n=6,a_3=5,a_4=3,a_5=4$ 时，有：
$$\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}k&\bf 0&\bf 1&\bf 2&\bf 3&\bf 4&\bf 5&\bf 6&\bf 7&\bf 8&\bf 9&\bf 10&\bf 11&\bf 12&\bf 13&\bf 14&\bf 15\\dp_{3,k}&0&1&2&3&4&5&6&7&8&9&10&11&12&13&14&15\\dp_{4,k}&5&4&3&2&1&0&1&2&3&4&5&6&7&8&9&10\\dp_{5,k}&2&3&4&5&4&3&2&1&0&1&2&3&4&5&6&7\\dp_{6,k}&4&5&4&3&2&3&4&5&4&3&2&1&0&1&2&3\end{array}$$
如果我们能找出来 $dp_6$ 的值对于所有小的 $a_n$ 询问都可以 $\mathcal{O}(1)$ 回答了，当然这个表格也很有规律：
$$\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}k&\bf 0&\bf 1&\bf 2&\bf 3&\bf 4&\bf 5&\bf 6&\bf 7&\bf 8&\bf 9&\bf 10&\bf 11&\bf 12&\bf 13&\bf 14&\bf 15\\dp_{3,k}&0&\color{red}1&\color{red}2&\color{red}3&\color{red}4&\color{red}5&6&7&8&9&10&11&12&13&14&15\\dp_{4,k}&\color{blue}5&\color{purple}4&\color{purple}3&\color{purple}2&\color{blue}1&0&1&2&3&4&5&6&7&8&9&10\\dp_{5,k}&\color{blue}2&\color{purple}3&\color{purple}4&\color{red}5&\color{red}4&3&2&1&0&1&2&3&4&5&6&7\\dp_{6,k}&\color{blue}4&\color{blue}5&\color{blue}4&\color{blue}3&2&3&4&5&4&3&2&1&0&1&2&3\end{array}$$
注意到每行 $dp_i$ 的开头，也就是蓝色部分，其实是上一行的红色部分，也就是 $dp_{i-1,1\sim a_{i-1}}$ 倒序放过来的（蓝色红色重叠的部分我放上紫色了）。我们根据这个规律就非常好递推了，随便用个 `deque` 维护一下当前处理到的 $dp_i$，然后每一轮开个 `vector` 之类的记录一下要把哪些塞到前面，之后直接倒序塞即可。因为题目保证了 $\sum a_i$ 的范围，所以 `deque` 只 `push_front` 不 `pop_back` 也不会导致 $\tt MLE$，而递推复杂度也只有 $\mathcal{O}(\sum a_i)$。处理出来 $dp_n$ 之后就可以是 $\mathcal{O}(1)$ 回答询问了（这个规律的证明比较不好用语言描述我就不写了，可以自己多手玩几组数据递推一下，应该就能发现证明）。所以本题最终时间复杂度 $\mathcal{O}(n+m+\sum a_i)$。
```cpp
#include <queue>
#include <cstdio>
#include <vector>
const int N = 2e5 + 10; int a[N]; std::deque<int> dp;
int main()
{
    int n, sum = 0; scanf("%d", &n); 
    for (int i = 1; i < n; ++i) scanf("%d", &a[i]), sum += a[i];
    sum -= a[1]; sum -= a[2]; 
    for (int i = 0; i <= sum; ++i) dp.push_back(i);
    for (int i = 3; i < n; ++i)
    {
        std::vector<int> vec;
        for (int j = 1; j <= a[i]; ++j) vec.push_back(dp[j]);
        for (int i = 0; i < vec.size(); ++i) dp.push_front(vec[i]);
    } 
    int m; scanf("%d", &m);
    for (int i = 1, x; i <= m; ++i)
    {
        scanf("%d", &x);
        if (x >= sum) { printf("%d\n", x - sum + a[1] - a[2]); }
        else { printf("%d\n", dp[x] + a[1] - a[2]); }
    }
    return 0;
}
```

---


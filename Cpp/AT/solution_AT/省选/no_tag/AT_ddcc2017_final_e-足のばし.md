# 足のばし

## 题目描述

[problemUrl]: https://atcoder.jp/contests/ddcc2017-final/tasks/ddcc2017_final_e

高橋君は $ N $ 頂点からなる木のぬいぐるみを持っています。 頂点には番号 $ 1,\ 2,\ ...,\ N $ がついています。

$ i $ 番目の辺は頂点 $ a_i,\ b_i $ をつないでおり、長さは $ 1 $ です。

$ {\rm\ dist}(u,\ v) $ を頂点 $ u $ から頂点 $ v $ への最短距離と定義します。すると木の直径は $ {\rm\ max}_{1\ ≦\ u\ <\ v\ ≦\ N}({\rm\ dist}(u,\ v)) $ となります。

青木君はこのぬいぐるみに対して、辺を $ 1 $ 本選んでその長さを $ 1 $ 増やす、というイタズラを何回か行いました。 イタズラの回数は $ K_1,\ K_2,\ ...,\ K_Q $ のどれかであることが分かっています。

また、青木君は直径の短い木のほうが好きなので、イタズラを全て終えた後の木の直径ができる限り短くなるように操作を行ったことが分かっています。

イタズラの回数が $ K_1,\ K_2,\ ...,\ K_Q $ の場合それぞれについて、イタズラを全て終えた後の木の直径を求めてください。

## 说明/提示

### 制約

- $ 3\ ≦\ N\ ≦\ 200,000 $
- $ 1\ ≦\ a_i,\ b_i\ ≦\ N $
- 入力は木になっている
- $ 1\ ≦\ Q\ ≦\ 200,000 $
- $ 0\ ≦\ K_1\ <\ K_2\ <\ ...\ <\ K_Q\ ≦\ 10^{18} $

## 样例 #1

### 输入

```
4
1 2
1 3
1 4
10
0 1 2 3 4 5 6 7 8 9```

### 输出

```
2
3
4
4
5
6
6
7
8
8```

## 样例 #2

### 输入

```
9
1 4
2 4
3 4
4 5
5 6
6 7
7 8
8 9
10
0 1 2 3 4 5 6 7 8 9```

### 输出

```
6
7
7
7
8
8
8
9
9
9```

## 样例 #3

### 输入

```
6
6 3
3 4
3 2
3 1
1 5
31
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30```

### 输出

```
3
4
4
4
5
6
6
6
7
8
8
8
9
10
10
10
11
12
12
12
13
14
14
14
15
16
16
16
17
18
18```

# 题解

## 作者：KAxdd (赞：6)

## 题意
给你一棵树大小为 $n$ 初始边权为 $1$，我们定义一次操作为选择这棵树的一条边使其边权增加 $1$ 。给出 $q$ 个询问，询问之间相互独立，对于每个询问给出一个数字 $k$ 。你需要回答这棵树操作 $k$ 次的可能的最小直径的长度。

$n,q\le 2\times 10^5,k\le 10^{18}$
## 题解

我们可以发现，其实操作是拥有循环节的，也就是说经过一定操作次数后，树上的任何一条直径值都相同。

同时这种情况下我们只会对叶子的值进行修改，因为修改叶子最多只会影响一条直径，可以最大化操作次数从而减小直径，同时，可以将只会修改叶子推广到任意操作，证明同上。

那么对于任意一个点，实际上我们可以计算出他达到上述所说的直径相同的方案。

可以这样计算 $\frac{从自己出发最长直径\times 叶子数 -所有叶子到此的距离}{2}$

那么就有了一个问题，答案可能是小数，问题很好解决，把边再建一个点就可以了，半径就是答案。那么我们可以对于每一种答案求出其的最小满足任意直径相同的方案，后面都是所有叶子轮流增加的循环。

可以先将询问离线排序，使用类似扫描线计算方案，大于一个半径的阈值可以直接计算周期。记得分讨奇数半径和偶数半径的情况。

时间复杂度 $O(n \log n)$ 瓶颈在于询问离线的排序。

代码 [link](https://www.luogu.com.cn/paste/udiqbdt6)

---

## 作者：sidekick257 (赞：5)

### [题目链接](https://atcoder.jp/contests/ddcc2017-final/tasks/ddcc2017_final_e)
### 题意简述

给你一颗树，多次询问（询问间独立），每次询问给定一个 $k$，问你执行 $k$ 次使任意边边权 $+1$ 的操作后树的直径最少是多少。

### 题解

不难发现只会在叶子的边上操作。

可能出现分讨直径中心是边还是点，所以先在每条边上加一个点，这样直径中心一定为点。

我们将根设为直径中心。

考虑 $dp_x$ 表示直径为 $x$ 时最大操作次数。

找到最小的 $ans$ 使得 $dp_{ans}\ge k$ 就是答案。

有转移 $dp_{x+2}\gets dp_{x}+cnt_{leaf}$，$cnt_{leaf}$ 表示叶子数量，这个转移是对所有的叶子都操作一次。

还有移动直径中心到根的一个儿子（然后使其变为新根），$dp_{x+1}\gets dp_x+cnt_{to}$，$cnt_{to}$ 表示目标点的子树的叶子数量，这个转移是对移动目标的子树内的每个叶子操作一次。

我们发现这个转移是不会走回头路的，因为走回头路相当于一次 $x+2$ 的转移，于是只有 $n$ 种，可以提前跑出来，剩下的就只剩 $+2$ 转移了，这个是非常好快速维护的。

---


# Majority of Balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_e

**これはインタラクティブな問題です。**

$ 2N $ 個のボールが一列に並べられており，左から順にボール $ 1,\ 2,\ 3,\ ...,\ 2N $ と番号づけられています．ここで，$ N $ は奇数です．この中には，$ N $ 個の赤いボールと $ N $ 個の青いボールが含まれています．

目隠しをされたあなたは，それぞれのボールの色を当てなければなりません．そのために，以下の質問を $ 210 $ 回まで行うことができます．

- $ 2N $ 個のボールから任意に $ N $ 個を選び，その中で赤いボールと青いボールのどちらの方が多いかを聞く．

では，始めましょう．

### Input &amp; Output Format

最初に，各色のボールの数 $ N $ を標準入力から受け取ってください．

> $ N $

次に，すべてのボールの色が分かるまで質問を繰り返してください．  
 質問は，以下の形式で標準出力に出力してください．

> ? $ A_1 $ $ A_2 $ $ A_3 $ $ ... $ $ A_N $

これは，あなたが $ N $ 個のボール $ A_1,\ A_2,\ A_3,\ ...,\ A_N $ を選んで質問することを意味します．  
 ただし，$ 1\ \leq\ A_i\ \leq\ 2N,\ A_i\ \neq\ A_j\ (i\ \neq\ j) $ を満たさなければなりません．

これに対する応答は，次の形式で標準入力から与えられます．

> $ T $

ここで，$ T $ は以下のいずれかの文字列です．

- `Red`: 選んだ $ N $ 個のボールの中では，青のボールより赤のボールの方が多い．
- `Blue`: 選んだ $ N $ 個のボールの中では，赤のボールより青のボールの方が多い．
- `-1`: あなたは不正な質問 (質問の回数が $ 210 $ 回を超えた場合を含む)，またはその他の不正な出力を行った．

ジャッジが応答 `-1` を返した場合，提出はすでに不正解とみなされています．この場合，プログラムをすぐに終了させてください．

すべてのボールの色が分かったら，解答を以下の形式で標準出力に出力してください．

> ! $ c_1 $$ c_2 $$ c_3 $$ ... $$ c_{2N} $

ここで，$ c_i $ はボール $ i $ の色を表す文字で，赤の場合は $ c_i= $`R`，青の場合は $ c_i= $`B` としてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 99 $
- $ N $ は奇数

- - - - - -

### 注意

- **出力のたびに標準出力を flush してください．**そうしない場合、`TLE` の可能性があります．
- 解答を出力したら (または応答 `-1` を受け取ったら)，プログラムをすぐに終了してください．そうしない場合、ジャッジ結果は不定です。
- 不正な出力が行われた場合のジャッジ結果は不定です。

- - - - - -

### 入出力例

Input Output `3`   `? 1 2 3` `Red`   `? 2 4 6` `Blue`   `! RRBBRB`この例では $ N\ =\ 3 $ であり，ボール $ 1,\ 2,\ 3,\ 4,\ 5,\ 6 $ の色はそれぞれ赤，赤，青，青，赤，青です．

- $ 1 $ 回目の質問では，ボール $ 1,\ 2,\ 3 $ のうち赤は $ 2 $ 個，青は $ 1 $ 個であり，赤の方が多いのでジャッジは `Red` を返します．
- $ 2 $ 回目の質問では，ボール $ 2,\ 4,\ 6 $ のうち赤は $ 1 $ 個，青は $ 2 $ 個であり，青の方が多いのでジャッジは `Blue` を返します．

# 题解

## 作者：Light_in_Dark (赞：2)

这是一道很有创新性的题，发现其他题解没有讲清楚，所以就记录一份。

### 题意
有 $2N$ 个球排成一列，其中有 $N$ 个红球，$N$ 个蓝球。（保证 $N$ 为奇数）
每次你可以从 $2N$ 个球中选 $N$ 个球，询问这些球中红球的数量与蓝球的数量较多的是哪一个。要求找出每个球的颜色，并且询问次数不超过 $210$。

### 题解
显然，如果我们找到了一组有 $N-1$ 个球的球堆，满足红球数量等于蓝球数量，就可以快速求出每个球的颜色了。具体的，对于不属于这 $N-1$ 个球中的球，询问时询问这 $N-1$ 个球与该球共同组成的 $N$ 个球中数量较多的颜色，得到的颜色即为该球颜色；对于不属于这 $N-1$ 个球中的球，一定可以通过之前已经推断出的颜色找出另外一组不包含该球的满足条件的球堆。这一部分的询问次数为 $2N$，但由于最后一组询问时不必要的，可以只用 $2N-1$。

那如何快速找到那一组满足条件的球堆呢？考虑到，如果 $[l,r]$ 这个区间内较多的是红球，而 $[l+1,r+1]$ 这个区间内较多的是蓝球，则区间 $[l+1,r]$ 一定是满足条件的，反之亦然。又由于区间 $[N+1,2N]$ 是区间 $[1,N]$ 在全集 $[1,2N]$ 的补集，所以区间 $[1,N]$ 与 $[N+1,2N]$ 的较多颜色一定是不同的。所以枚举区间 $[i,N+i-1]$，一定可以找到一组解。

暴力枚举的时间复杂度是不能接受的。考虑对于一个区间 $[l,r]$，他的较多颜色一定和区间 $[1,N],[N+1,2N]$ 中的一个不同，那在它与与它较多颜色不同的区间的范围中一定存在一组解。二分即可。

这个二分是不容易想到的 ~~，所以要多想几遍~~。总的询问次数是可以接受的。

---

## 作者：uid_310801 (赞：2)

随到的一道冷门题。

### 题意：

有 $2n$ 个球，球有红色和蓝色。每次你可以询问 $n$ 个球，交互库会回答这 $n$ 个球中红色球的数量和蓝色球的数量谁更多。你需要在 $210$ 次询问内猜出答案。保证 $n$ 是奇数，$1\le n \le 99$。

### 题解：

如果我们能找出一段长为 $n-1$ 的区间满足区间内蓝色球和红色球的数量相等，我们就能轻松地求出所有球的颜色了。具体操作为：

设我们要求第 $i$ 个球的颜色

- 若 $i$ 不在区间内，询问 $i$ 和区间内所有球。如果答案是 `Red` 说明 $i$ 是红色，否则是蓝色。

- 若 $i$ 在区间内，先求出区间外的球的颜色，然后找到任意 $n-1$ 个球满足红色球和蓝色球的数量相等，询问 $i$ 和这些球即可得到 $i$ 的颜色。

综上，如果找到了这么一个区间，我们可以在 $2n$ 次询问内找到所有球。

现在问题变为，如何找到这么一个区间？

首先询问出区间 $[1,n]$ 的答案，易证 $[n+1,2n]$ 的答案与前者不同。不妨假设区间 $[1,n]$ 的答案为 `Red` 。想象一个长为 $n$ 的区间从 $[1,n]$ 滑到 $[n+1,2n]$，每次都询问一遍答案，总能找到一个点 $s$，满足 $[s,s+n-1]$ 的答案为 `Red` 并且 $[s+1,s+n]$ 的答案为 `Blue`，不难看出 $[s+1,s+n-1]$ 满足区间内蓝色球数量等于红色球。

这样直接做最坏情况需要 $O(n)$ 次操作，需要优化。可以看出 $s$ 可以通过二分求出来，具体来说，如果询问 $mid$  答案为 `Red` 则递归右半边，否则递归左半边，总能找到 $s$。

算一下总操作数：初始询问 $1$ 的答案耗费 $1$ 次，二分耗费 $7$ 次，求颜色耗费 $198$ 次，可以省去对 $s$ 和 $s+n$ 的询问，总操作数为 $1+7+198-2=204$ 次，满足题目限制。

```cpp
#include<bits/stdc++.h>
namespace Spouter_27{
using namespace std;
typedef long long ll;
#define int long long
#define deb(x) cerr<<"Line: "<<__LINE__<<", val= "<<x<<"; \n"
#define pii pair<ll,ll>
#define mp make_pair
#define fi first
#define se second
const ll N=2e5+10;
inline ll read(){
	ll a=0,x=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	x=-x;
		c=getchar();
	}
	while(isdigit(c)){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*x;
}
ll n,s;
bool c[N];//R:0,B:1;
bool ask(ll x){
	string ans;
	cout<<"? ";
	for(int i=x;i<=x+n-1;i++){
		cout<<i<<" ";
	}
	cout<<endl;
	cin>>ans;
	if(ans[0]=='R')	return 0;
	else return 1;
}
bool ask2(ll x,ll l,ll r){
	string ans;
	cout<<"? "<<x<<" ";
	for(int i=l;i<=r;i++){
		cout<<i<<" ";
	}
	cout<<endl;
	cin>>ans;
	if(ans[0]=='R')	return 0;
	else return 1;
}
bool ask3(ll x,ll l,ll r){
	string ans;
	cout<<"? "<<x<<" ";
	for(int i=1;i<=l;i++){
		cout<<i<<" ";
	}
	for(int i=r;i<=2*n;i++){
		cout<<i<<' ';
	}
	cout<<endl;
	cin>>ans;
	if(ans[0]=='R')	return 0;
	else return 1;
}
signed main(){
	cin>>n;
	bool m1=ask(1);
	ll l=2,r=n+1,mid,ans=1;
	while(l<=r){
		mid=(l+r)/2;
		if(ask(mid)==m1){
			ans=mid;
			l=mid+1;
		}
		else{
			r=mid-1;
		}
	}
	c[ans]=m1,c[ans+n]=1-m1;
	for(int i=1;i<=ans-1;i++)	c[i]=ask2(i,ans+1,ans+n-1);
	for(int i=ans+n+1;i<=2*n;i++)	c[i]=ask2(i,ans+1,ans+n-1);
	for(int i=ans+1;i<=ans+n-1;i++)	c[i]=ask3(i,ans-1,ans+n+1);
	cout<<"! ";
	for(int i=1;i<=2*n;i++){
		if(c[i])	putchar('B');
		else putchar('R');
	}
	cout<<endl;
	return 0;
}












}signed main(){return Spouter_27::main();}

```




---


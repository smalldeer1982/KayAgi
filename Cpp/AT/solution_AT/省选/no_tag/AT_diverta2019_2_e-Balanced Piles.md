# Balanced Piles

## 题目描述

[problemUrl]: https://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_e

$ N $ 個のマスが横一列に並んでおり、左から順に $ 1 $ から $ N $ までの番号がつけられています。高橋君はこれらのマスに積み木を積もうとしています。 まだそれぞれのマスには積み木が $ 1 $ つも積まれていません。

積み木をバランス良く積みたい高橋君は、以下の操作を繰り返して全てのマスに積み木がちょうど $ H $ 個ずつ積まれている状態にしようとしています。

- $ 1 $ マスに積まれている積み木の最大値を $ M $ 個、最小値を $ m $ 個とする。$ m $ 個の積み木が置かれているマスを $ 1 $ つ選び (複数ある場合はどれを選んでもよい)、そのマスに積まれた積み木が $ M $ 個以上 $ M\ +\ D $ 個以下になるように積み木を正の個数積む。

高橋君のために、この操作を繰り返して全てのマスに積み木がちょうど $ H $ 個積まれている状態にする方法が何通りあるか数えてあげてください。答えは非常に大きくなる場合があるので、$ 10^9+7 $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^6 $
- $ 1\ \leq\ D\ \leq\ H\ \leq\ 10^6 $
- 入力は全て整数である

### Sample Explanation 1

(マス $ 1 $ に積まれた積み木の個数, マス $ 2 $ に積まれた積み木の個数) は次のように変化させることができます。 - $ (0,\ 0) $ -&gt; $ (0,\ 1) $ -&gt; $ (1,\ 1) $ -&gt; $ (1,\ 2) $ -&gt; $ (2,\ 2) $ - $ (0,\ 0) $ -&gt; $ (0,\ 1) $ -&gt; $ (1,\ 1) $ -&gt; $ (2,\ 1) $ -&gt; $ (2,\ 2) $ - $ (0,\ 0) $ -&gt; $ (0,\ 1) $ -&gt; $ (2,\ 1) $ -&gt; $ (2,\ 2) $ - $ (0,\ 0) $ -&gt; $ (1,\ 0) $ -&gt; $ (1,\ 1) $ -&gt; $ (1,\ 2) $ -&gt; $ (2,\ 2) $ - $ (0,\ 0) $ -&gt; $ (1,\ 0) $ -&gt; $ (1,\ 1) $ -&gt; $ (2,\ 1) $ -&gt; $ (2,\ 2) $ - $ (0,\ 0) $ -&gt; $ (1,\ 0) $ -&gt; $ (1,\ 2) $ -&gt; $ (2,\ 2) $ よって、全てのマスに積み木がちょうど $ 2 $ 個積まれている状態にする方法の個数は $ 6 $ 通りです。

### Sample Explanation 3

個数を $ 10^9+7 $ で割った余りを出力することに注意してください。

## 样例 #1

### 输入

```
2 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
2 30 15```

### 输出

```
94182806```

## 样例 #3

### 输入

```
31415 9265 3589```

### 输出

```
312069529```

# 题解

## 作者：frank3215 (赞：1)

更多文章、更好的阅读体验：可以移步[我的博客](https://www.cnblogs.com/frank3215/p/diverta2019-2E.html)

[题目链接](https://www.luogu.com.cn/problem/AT5092)

## Solution

（官方）题解：定义$(h, x)$为最高高度为 $h$，最高块数为 $x$ 的状态。(假设同一高度的方块有(操作顺)序)

$N = 4, H = 4, D = 1$ 时，方案数等价于以下图的$(0,4)\to(4,4)$的路径条数：（用Graphviz生成）

![](https://images.cnblogs.com/cnblogs_com/topsecret/1664237/o_210522073408diverta2019-2E-1.png)

$N = 4, H = 4, D = 2$ 时，方案数等价于以下图的$(0,4)\to(4,4)$的路径条数：

![](https://images.cnblogs.com/cnblogs_com/topsecret/1664237/o_210522073527diverta2019-2E-2.svg.png)

然后就做完了……

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn = 1e6+10, MOD = 1e9+7;
int n, h, d;
int a[maxn], sum, b[maxn], s[maxn], ans;

int main() {
	scanf("%d%d%d", &n, &h, &d);
	a[0] = 1;
	for (int i = 1; i <= n; ++i) {
		a[i] = (ll)a[i-1]*i%MOD;
		sum = (ll)(sum+a[i])%MOD;
	}
	for (int i = 1; i <= h; ++i) {
		b[i] = ((s[i-1]-((i-d-1<1)?0:s[i-d-1])+MOD)*(ll)sum+(i<=d))%MOD;
		s[i] = (s[i-1]+b[i])%MOD;
	}
	ans = (ll)b[h]*a[n]%MOD;
	printf("%d\n", ans);
}
```

---


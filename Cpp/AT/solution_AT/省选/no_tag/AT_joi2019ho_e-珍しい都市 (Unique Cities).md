# 珍しい都市 (Unique Cities)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2019ho/tasks/joi2019ho_e

JOI 国には $ N $ 個の都市があり，$ 1 $ から $ N $ までの番号がついている．これらの都市は $ N\ -\ 1 $ 本の道路で結ばれている．$ i $ 番目 ($ 1\ \leqq\ i\ \leqq\ N\ -\ 1 $) の道路は都市 $ A_i $ と都市 $ B_i $ を結んでおり，双方向に通行可能である．どの都市からどの都市へも何本かの道路を通行することで移動できる．

JOI 国にはいくつかの特産品が存在する．特産品には，種類を表す $ 1 $ 以上 $ M $ 以下の番号が付けられている (JOI 国で生産されている特産品に対応していない番号があるかもしれない)．各都市は $ 1 $ つの特産品を生産しており，都市 $ j $ ($ 1\ \leqq\ j\ \leqq\ N $) では特産品 $ C_j $ を生産している．複数の都市が同じ種類の特産品を生産することがあるかもしれない．

$ 2 $ つの都市の間の距離は，その間を移動するために通る道路の本数の最小値である．都市 $ x $ ($ 1\ \leqq\ x\ \leqq\ N $) から見て都市 $ y $ ($ 1\ \leqq\ y\ \leqq\ N,\ y\ \neq\ x $) が珍しい都市であるとは，すべての都市 $ z $ ($ 1\ \leqq\ z\ \leqq\ N,\ z\ \neq\ x,\ z\ \neq\ y $) について，都市 $ x $, $ y $ 間の距離と都市 $ x $, $ z $ 間の距離が異なることを意味する．

JOI 国の大臣である $ K $ 理事長は，すべての $ j $ ($ 1\ \leqq\ j\ \leqq\ N $) について，都市 $ j $ から見て珍しい都市で生産されている特産品が何種類あるかを知りたい．

JOI 国の道路の情報と，各都市で生産されている特産品の番号が与えられたとき，各都市ごとに，その都市から見て珍しい都市で生産されている特産品が何種類あるかを求めるプログラムを作成せよ．

- - - - - -

## 说明/提示

### 制約

- $ 2\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ M\ \leqq\ N $．
- $ 1\ \leqq\ A_i\ \leqq\ N $ ($ 1\ \leqq\ i\ \leqq\ N\ -\ 1 $)，$ 1\ \leqq\ B_i\ \leqq\ N $ ($ 1\ \leqq\ i\ \leqq\ N\ -\ 1 $)．
- $ A_i\ ,\ B_i\ (1\ \leqq\ i\ \leqq\ N\ -\ 1 $)．
- どの都市からどの都市へも何本かの道路を通行することで移動できる．
- $ 1\ \leqq\ C_j\ \leqq\ M $ ($ 1\ \leqq\ j\ \leqq\ N $)．

### 小課題

1. ($ 4 $ 点) $ N\ \leqq\ 2\,000 $．
2. ($ 32 $ 点) $ M\ =\ 1 $．
3. ($ 32 $ 点) $ M\ =\ N $，$ C_j\ =\ j $ ($ 1\ \leqq\ j\ \leqq\ N $)．
4. ($ 32 $ 点) 追加の制約はない．

- - - - - -

### Sample Explanation 1

都市 $ 1 $ から見て珍しい都市は都市 $ 2,\ 3 $ であり，そこで生産される特産品は特産品 $ 2,\ 1 $ なので，答えは $ 2 $種類である． 都市 $ 2 $ から見て珍しい都市は存在しないので，答えは $ 0 $ 種類である． 都市 $ 3 $ から見て珍しい都市は都市 $ 1 $ であり，そこで生産される特産品は特産品 $ 1 $ なので，答えは $ 1 $ 種類である． 都市 $ 4 $ から見て珍しい都市は都市 $ 1,\ 3 $ であり，どちらの都市においても生産される特産品は特産品 $ 1 $ なので，答えは $ 1 $ 種類である． 都市 $ 5 $ から見て珍しい都市は都市 $ 1,\ 3 $ であり，どちらの都市においても生産される特産品は特産品 $ 1 $ なので，答えは $ 1 $ 種類である． 番号 $ 3 $ の特産品は存在しないことに注意せよ． - - - - - -

### Sample Explanation 2

この入力例は小課題 $ 2 $ の制約を満たす． - - - - - -

### Sample Explanation 3

この入力例は小課題 $ 3 $ の制約を満たす． - - - - - -

## 样例 #1

### 输入

```
5 4
1 2
2 3
3 4
3 5
1 2 1 2 4```

### 输出

```
2
0
1
1
1```

## 样例 #2

### 输入

```
7 1
1 2
2 3
3 4
4 5
5 6
6 7
1 1 1 1 1 1 1```

### 输出

```
1
1
1
0
1
1
1```

## 样例 #3

### 输入

```
10 10
2 6
5 8
10 8
1 4
10 6
4 5
10 7
6 9
3 7
1 2 3 4 5 6 7 8 9 10```

### 输出

```
4
3
4
2
0
2
2
0
3
2```

## 样例 #4

### 输入

```
22 12
9 6
12 13
4 20
21 22
3 19
2 9
6 18
18 11
18 3
16 2
6 4
3 17
16 10
8 16
22 1
16 14
15 8
9 21
2 12
21 5
12 7
1 1 4 8 4 11 7 6 7 11 6 11 10 4 7 5 3 12 9 6 12 2```

### 输出

```
2
0
1
1
1
1
1
0
0
1
2
0
1
1
2
0
2
1
2
3
0
0```

# 题解

## 作者：wwwwwza (赞：1)

### 前置知识：
- 对于一棵树的一个节点 $u$，当点 $v$ 到点 $u$ 的距离比点 $u$ 到其他点的距离都要大，那么点 $v$ 是这棵树上的直径中的一段。

### 思路：
1. 能对点 $u$ 产生贡献的点，一定在关于点 $u$ 的最长链上。

2. 对于直径的两端各算一次答案，取其最大值为答案。

3. 在遍历这棵树时，用一个栈来记录所有可能产生贡献的点，用一个桶来记录答案。

4. 处理到一个点时，先遍历重儿子，把栈中和其距离小于等于深度最大的轻儿子弹出栈，即清除不产生贡献的点。

5. 再遍历所有轻儿子，把栈中和其距离小于等于重儿子的点弹出栈。

6. 时间复杂度 $\mathcal O(n)$。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m,x,y,val[N],rt=1,dep[N],son[N][2],f[N],ans[N];
int t[N],cnt=0,in[N],tot=0;
vector<int>g[N];
void ins(int x){
	cnt+=!t[x]++;
}
void del(int x){
	cnt-=!--t[x];
}
void dfs1(int u,int fa){
	dep[u]=dep[fa]+1;
	if(dep[u]>dep[rt])rt=u;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa)continue;
		dfs1(v,u);
	}
}
void dfs2(int u,int fa){
	dep[u]=dep[fa]+1;
	son[u][0]=son[u][1]=0;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa)continue;
		dfs2(v,u);
		if(f[v]>f[son[u][0]]){
			son[u][1]=son[u][0];
			son[u][0]=v;
		}else if(f[v]>f[son[u][1]]){
			son[u][1]=v;
		}
	}
	f[u]=f[son[u][0]]+1;
}
void dfs3(int u,int fa){
	if(fa){
		ins(val[fa]);
		in[++tot]=fa;
	}
	if(son[u][0]){
		while(tot&&dep[in[tot]]>=dep[u]-f[son[u][1]]){
			del(val[in[tot--]]);
		}
		dfs3(son[u][0],u);
	}
	while(tot&&dep[in[tot]]>=dep[u]-f[son[u][0]]){
		del(val[in[tot--]]);
	}
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa||v==son[u][0])continue;
		dfs3(v,u);
	}
	ans[u]=max(ans[u],cnt);
	if(in[tot]==fa)del(val[in[tot--]]);
}
void solve(int u){
	rt=u;
	dfs1(u,0);
	dfs2(rt,0);
	memset(t,0,sizeof(t));
	tot=cnt=0;
	dfs3(rt,0);
}
int main(){
	cin >>n>>m;
	for(int i=1;i<n;i++){
		cin >>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		cin >>val[i];
	}
	solve(rt);solve(rt);
	for(int i=1;i<=n;i++){
		cout <<ans[i]<<endl;
	}
	return 0;
}

```

---

## 作者：ty_mxzhn (赞：0)

## 题意


JOI 国有 $N$ 个城市，城市从 $1$ 到 $N$ 编号。这些城市被 $N-1$ 条双向道路连接，第 $i$ 条路连接两个城市 $A_i$ 和 $B_i$。从任何城市出发，可以到达所有城市。

JOI 国有些特产，每种特产的编号都在 $1$ 到 $M$ 之间（包括 $1$ 和 $M$），但是 $1$ 到 $M$ 的某些整数可能不代表 JOI 国的特产。JOI 国的每个城市都产一种特产。$j$ 城产的特产是 $C_j$。多个城市可能产相同的特产。

我们定义两个城市之间的距离为从一个城市到另一个城市需要经过的最少道路数，对于城市 $x$，我们定义城市 $y$（$y\neq x$）是**独特的城市**当且仅当对于任何一个城市 $z$（$z\neq x,z\neq y$），$x$ 与 $y$ 间的距离不等于 $x$ 与 $z$ 之间的距离。

JOI 国交通部部长 K 先生想知道对于城市 $j$ 的**独特的城市**一共能产多少种特产。

给出 JOI 国的道路信息与每个城市产的特产，写一个程序计算对于每个城市的**独特的城市**，一共能产多少种特产。

## 题解

**关键性质：到一个点最远的点肯定是直径之一。**

观察到：一个城市独特的城市，一定在这个城市的严格最长链上。

每个城市可以先预处理出他最长链的端点是直径的哪一个端点。问题变成确定了直径的一个端点求答案。

对于每一个点，提前维护其向下最长链和次长链，把到该点距离 $\le$ 次长链的点毙掉。这些点可以给长儿子贡献答案，而剩下的儿子都会因为长儿子过长而毙掉到该点 $\le$ 最长链的点。

实现时使用栈和桶精细维护可以做到 $O(n)$。

---


# ロボット (Robot)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2021ho/tasks/joi2021ho_d

IOI 町には $ N $ 個の交差点があり，$ 1 $ から $ N $ までの番号が付いている．また，$ M $ 本の道があり，$ 1 $ から $ M $ までの番号が付いている．それぞれの道は $ 2 $ 個の異なる交差点を双方向に結んでいる．道 $ i $ ($ 1\ \leqq\ i\ \leqq\ M $) は交差点 $ A_i $ と交差点 $ B_i $ を結んでいる．$ 2 $ 本の異なる道が同じ交差点の組を結ぶことはない．これらの道には $ 1 $ 以上 $ M $ 以下の整数で表される色が塗られており，道 $ i $ の現在の色は $ C_i $ である．複数の道が同じ色で塗られているかもしれない．

JOI 社は IOI 町の交差点を移動するロボットを開発した．あなたがこのロボットに道の色を指示すると，ロボットは指示された色の道を通り隣接した交差点に移動する．ただし，ロボットが現在いる交差点につながれた道のうちに，指示された色の道が $ 2 $ 本以上存在すると，次に進むべき道を判別できずに停止してしまう．

あなたの目的は，現在交差点 $ 1 $ にいるロボットに何回かの指示を出して，交差点 $ N $ に移動させることである．ただし，現在の道の色ではそれができるとは限らないため，何本かの道の色を**事前に**塗り替えることで， ロボットを交差点 $ N $ に移動させることができるようにしたい．道 $ i $ ($ 1\ \leqq\ i\ \leqq\ M $) は $ P_i $ 円をかけて，$ 1 $ 以上 $ M $ 以下の好きな整数の色に塗り替えることが出来る．

交差点と道の情報が与えられたとき，必要な金額の最小値を求めるプログラムを作成せよ．ただし，どのように道の色を塗り替えてもロボットを交差点 $ N $ に移動させることができない場合は，代わりに `-1` を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 2\ \leqq\ N\ \leqq\ 100\,000 $．
- $ 1\ \leqq\ M\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ A_i\ <\ B_i\ \leqq\ N $ ($ 1\ \leqq\ i\ \leqq\ M $)．
- $ (A_i,\ B_i)\ \neq\ (A_j,\ B_j) $ ($ 1\ \leqq\ i\ <\ j\ \leqq\ M $)．
- $ 1\ \leqq\ C_i\ \leqq\ M $ ($ 1\ \leqq\ i\ \leqq\ M $)．
- $ 1\ \leqq\ P_i\ \leqq\ 1\,000\,000\,000 $ ($ 1\ \leqq\ i\ \leqq\ M $)．

### 小課題

1. ($ 34 $ 点) $ N\ \leqq\ 1\,000 $，$ M\ \leqq\ 2\,000 $．
2. ($ 24 $ 点) $ P_i\ =\ 1 $ ($ 1\ \leqq\ i\ \leqq\ M $)．
3. ($ 42 $ 点) 追加の制約はない．

- - - - - -

### Sample Explanation 1

$ 1 $ 円で道 $ 4 $ を色 $ 3 $ から色 $ 4 $ に塗り替え，$ 2 $ 円で道 $ 6 $ を色 $ 4 $ から色 $ 2 $ に塗り替える．合計 $ 3 $ 円かかる． この結果，交差点 $ 1 $ にいるロボットに色 $ 2 $ を指示することで，ロボットを交差点 $ 2 $ に移動させることができる．続けて，ロボットに色 $ 4 $ を指示することで，ロボットを交差点 $ 4 $ に移動させることができる． $ 2 $ 円以下でロボットを交差点 $ 4 $ に移動させることは不可能であるため，$ 3 $ を出力する． - - - - - -

### Sample Explanation 2

道をどのように塗り替えても，ロボットを交差点 $ 5 $ に移動させることはできない．したがって，$ -1 $ を出力する． - - - - - -

### Sample Explanation 3

この入力例は小課題 $ 2 $ の制約を満たす． - - - - - -

## 样例 #1

### 输入

```
4 6
1 4 4 4
3 4 1 3
1 3 4 4
2 4 3 1
2 3 3 2
1 2 4 2```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2
1 4 1 2
3 5 1 4```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 7
2 3 7 1
1 4 5 1
4 5 3 1
3 4 7 1
2 4 3 1
3 5 6 1
1 2 5 1```

### 输出

```
1```

## 样例 #4

### 输入

```
13 21
7 10 4 4
3 6 4 7
8 10 4 5
3 9 2 5
1 4 4 5
2 6 4 2
3 11 2 2
3 8 16 2
8 11 16 1
6 10 4 14
6 8 16 6
9 12 16 5
5 13 4 6
1 12 4 7
2 4 4 18
2 9 4 10
2 12 4 6
10 13 4 28
5 7 2 5
5 11 2 16
7 13 4 20```

### 输出

```
7```

# 题解

## 作者：AKPC (赞：2)

![](https://cdn.luogu.com.cn/upload/image_hosting/vsgpbjxj.png)

**题意**

有一张无向图，图上每条边都有各自的颜色，不一定两两不同，也不一定都相同。

每次走到一个节点，你可以给机器人一种颜色，机器人会把这个点所有该颜色的出边全部框选，进行如下判断：

- 如果只有一条，机器人会顺着这条边走到它指向的节点。
- 反之，机器人会原地不动。

在把机器人放到这张图之前，你可以花费一些代价改变一些边的颜色，每条边都有一个代价，改动某条边需要花费这条边的代价。

你需要找到最小的代价，使得机器人可以从 $1$ 节点走到 $n$ 节点。

**思路**

对于目前在一个节点 $u$，你给出了颜色 $c$，那么对于每条 $u\to v$ 的颜色为 $c$ 的边，如果要走这条边，有两种决策：

- 改该边为 $u$ 的所有出边都未出现过的颜色，代价 $P_{u\to v}$。
- 改掉除了该边之外所有 $u$ 出边的同色边的颜色，代价是 $u$ 所有同色出边的 $P$ 之和减去 $P_{u\to v}$。

一种朴素的做法就是把一条边的边权设为上面两种决策中代价最小值然后跑 dijkstra，但是如果出现 $u\to v$，$v\to w$ 这条路径颜色相同，但是没有在 $u$ 节点改变 $u\to v$ 的颜色，那么这两条边在 $v$ 节点都会被计算代价，所以一个节点对两个决策代价取 $\min$ 不保证最优。

如果我们能把两种决策的边都建出来，就可以保证正确性了。但是如果在原图设边权，是不好考虑代价设定的。因此，我们需要一些虚点来辅助。

![](https://cdn.luogu.com.cn/upload/image_hosting/mxljevyt.png)

图中红边都是 $1$ 节点红颜色的**实边**，黑框节点都是**实点**，而红框节点 $x$ 是专门为 $1$ 的红色出边建立的**虚点**，黑边都是虚边。

具体的建图方案是：

- 建立 $1\to x$，边权为 $0$。
- 建立 $x\to 2,3,4$，对于 $x\to y$，其边权为 $\sum_{i=2}^4P_{1\to i}-P_{1\to y}$，这构造了第二种决策的路径。
- 建立 $2,3,4\to x$，边权 $0$，便于 dijkstra 反悔。

跑 dijkstra 即可。

**代码**

[code](/paste/vwjqudaw)。

---

## 作者：wxzzzz (赞：2)

### 思路

有一个显然但是错误的思路：将一条边 $(x,y)$ 的权值当作 $\displaystyle\min\Big(\sum_{c(x,k)=c(x,y)}p(x,k)-p(x,y),p(x,y)\Big)$，直接跑最短路。

这样会漏掉一种情况：走 $x\to y\to z$，最优方案可能是将所有 $(x,k)\ (c(x,k)=c(x,y),k\ne y)$ 都改成其他颜色，然后以 $0$ 的代价走过 $(x,y),(y,z)$。下图就是例子（$1\to 2\to 5$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/4zh8knr8.png)

考虑建虚点处理上述情况：

1. 对每个点的每一种颜色的出边建一个虚点。对于一条边 $(x,y)$，令 $x$ 的颜色为 $c(x,y)$ 的虚点为 $u$。

1. 连边 $(x,u)$，令 $c(x,y)=0,p(x,y)=0$。（注意，虚点连出的都是有向边，下同）

1. 连边 $(u,y)$，令 $c(u,y)=0,p(u,y)=\displaystyle\sum_{c(x,k)=c(x,y)}p(x,k)-p(x,y)$。

1. 连边 $(y,u)$，令 $c(y,u)=0,p(y,u)=0$。

如下图：（由于软件显示问题，下图中用 $6.,7.$ 代替 $6,7$）

![](https://cdn.luogu.com.cn/upload/image_hosting/j5xvcfah.png)

可以发现，建立虚点后，所有 $x\to y\to z$ 的路径包含了所有可能的最优路径，跑最短路即可。

### 代码

这题的出边需要排序，因此用 vector 存图。

注意千万不能用迭代器遍历出边，因为加边操作会使迭代器失效，从而 RE。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, cnt;
long long s[1000005], dis[1000005];
bitset<1000005> vis;
struct graph {
    int y, c;
    long long p;
};
vector<graph> g[1000005];
priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> q;
bool cmp(graph x, graph y) {
    return x.c < y.c;
}
void dijkstra() {
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0, q.push({0, 1});

    while (!q.empty()) {
        int x = q.top().second;
        q.pop();

        if (vis[x])
            continue;

        vis[x] = 1;

        for (graph i : g[x]) {
            int y = i.y, c = i.c;
			long long p = i.p;

            if (dis[x] + p < dis[y]) {
                dis[y] = dis[x] + p;
                q.push({dis[y], y});
            }
        }
    }
}
int main() {
    cin >> n >> m;
    cnt = n;

    while (m--) {
        int x, y, a, b;
        cin >> x >> y >> a >> b;
        g[x].push_back({y, a, b});
        g[y].push_back({x, a, b});
    }

    for (int i = 1; i <= n; i++) {
        sort(g[i].begin(), g[i].end(), cmp);

        for (int j = 0; j < g[i].size(); j++)
            if (g[i][j].c)
                s[g[i][j].c] += g[i][j].p;

        for (int j = 0; j < g[i].size(); j++) {
            int y = g[i][j].y, c = g[i][j].c;
            long long p = g[i][j].p;

            if (!c)
                continue;

            if (!vis[c]) {
                g[i].push_back({++cnt, 0, 0});
                vis[c] = 1;
            }

            g[cnt].push_back({y, 0, s[c] - p});
            g[y].push_back({cnt, 0, 0});
        }

        for (int j = 0; j < g[i].size(); j++)
            if (g[i][j].c)
                s[g[i][j].c] = vis[g[i][j].c] = 0;
    }

    dijkstra();

    if (dis[n] > 1e18)
        cout << "-1";
    else
        cout << dis[n];

    return 0;
}
```

---

## 作者：Z1qqurat (赞：1)

一雪前耻题。首先发现颜色范围 $\in[1,m]$，也就是说一定能将所有边变成不同的颜色，所以根本不需要考虑具体染成什么颜色，只要图联通就一定会有解。于是我们想，如果走 $(u,v,c,w)$ 这条边，我们要付出多少代价：

* 如果这是 $u$ 开头的唯一一条颜色 $c$ 边，那么走它不需要代价，$u\xrightarrow{0} v$。
* 否则，要么将这条边修改为一条不同颜色的边，要么将 $u$ 开头的其他 $c$ 边全部改成不同颜色，$u\xrightarrow{\min(w,sum_{u,c})} v$，这里 $sum_{u,c}$ 表示从 $u$ 开头的颜色为 $c$ 的边的 $w$ 之和。

你以为这样就结束了？其实还有一种情况，如果从 $x\to y\to z$，$(x,y),(y,z)$ 原色都是 $c$，通过 $w_{x,y}$ 的代价将 $(x,y)$ 修改为了一种不同的颜色，通过 $s_{y,c}-w_{y,z}$ 的代价将 $(y,z)$ 的同色边修改为不同颜色，那么直接叠加两个代价其实是错的，实际上这一共只需要 $s_{y,c}-w_{y,z}$ 的总代价，因为在 $(y,z)$ 之前 $(x,y)$ 已经被修改掉了颜色。于是考虑我们建出一个虚点 $vt$，然后建边 $x\xrightarrow{0} vt, vt\xrightarrow{s_{y,c}-w_{y,z}} z$，这样 $x\to vt\to z$ 的路径就代表了这种情况的代价。

分析一下这种建边下虚边的数量，发现如果我们给一个边颜色全部相同的菊花，那么虚边数量可能达到 $\mathcal{O}(m^2)$，考虑是否出现了重复连接的边：

![](https://pic.imgdb.cn/item/65b8478f871b83018a417b8e.jpg)

发现我们其实并不需要对每一组 $x\to y\to z$ 都连一次，这些边中对于固定的虚点 $vt$ 都是一样的。这样连边就保证虚边数量是 $\mathcal{O}(m)$ 的了。

注意不能直接对每种颜色开一个虚点，只能对于每个中间点 $y$，它的出边颜色 $c$ 开一个新的虚点 $vt$，这样才能保证正确。由于边是双向边，所以虚点数量上界是 $2m$。总体复杂度 $\mathcal{O}(n\log n+m)$，瓶颈在 Dijkstra。

[Submission.](https://atcoder.jp/contests/joi2021ho/submissions/49800597)

---


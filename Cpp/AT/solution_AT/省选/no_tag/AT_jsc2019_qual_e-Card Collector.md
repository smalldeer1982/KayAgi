# Card Collector

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e

$ H $ 行 $ W $ 列に並んだマス目の上に合計 $ N $ 枚のカードが置かれています。

$ i $ 番目のカードには整数 $ A_i $ が書かれており、上から $ R_i $ 行目、左から $ C_i $ 列目のマスの上に置かれています。

同じマスに複数枚のカードが置かれていることもあります。

あなたは各行からそれぞれ $ 1 $ 枚までカードを選んで取ります。

次に、各列からそれぞれ $ 1 $ 枚までカードを選んで取ります。

取ったカードに書かれた整数の合計の最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ H,\ W\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^5 $
- $ 1\ \leq\ R_i\ \leq\ H $
- $ 1\ \leq\ C_i\ \leq\ W $

### Sample Explanation 1

以下のように取ると、取ったカードに書かれた整数の合計は $ 28 $ になり、このときが最大です。 - $ 1 $ 行目から $ 4 $ 番目のカードを取ります。 - $ 2 $ 行目から $ 6 $ 番目のカードを取ります。 - $ 1 $ 列目から $ 2 $ 番目のカードを取ります。 - $ 2 $ 列目から $ 5 $ 番目のカードを取ります。

## 样例 #1

### 输入

```
6 2 2
2 2 2
1 1 8
1 1 5
1 2 9
1 2 7
2 1 4```

### 输出

```
28```

## 样例 #2

### 输入

```
13 5 6
1 3 35902
4 6 19698
4 6 73389
3 6 3031
3 1 4771
1 4 4784
2 1 36357
2 1 24830
5 6 50219
4 6 22645
1 2 30739
1 4 68417
1 5 78537```

### 输出

```
430590```

## 样例 #3

### 输入

```
1 100000 100000
1 1 1```

### 输出

```
1```

# 题解

## 作者：Lice (赞：3)

### Description

现有 $h$ 行 $w$ 列的网格。给定 $n$ 张卡片，每张卡片 $i$ 有一个位置 $(r_i, c_i)$ 以及数字 $a_i$。

你可以先在每一行拿走不超过一个卡片，然后在每一列再拿不超过一个。不能重复拿。

求最后可得的卡片上数字之和的最大值。

### Hint

- $1\le n, w, h\le 10^5$
- $a_i \in [1, 10^5]$
- $1\le r_i \le h, 1\le c_i \le w$

### Solution

*Reference : https://autumnkite.github.io/atcoder-jsc19qualE-sol/*

如果把每一行、列都视作一个点，把卡片视为边，我们会得到一个 $w+h$ 个点， $n$ 条边的图。若有一张第 $i$ 行第 $j$ 列的卡片，那么就视作一条结点 $i$，$h+j$ 之间的边，权值为卡片数值。

考虑题面上取卡片的过程如何转换到图上：我们假定图有向，那么在第 $i$ 行取走第 $j$ 列的卡片，就相当于一条 $i\to j+h$ 的边；同理，在第 $i$ 列取走第 $j$ 行的卡片，就相当于一条 $i + h\to j$ 的边。

试着研究最后取完建出的新图的性质。一个结点的出度最多为 $1$，那么整个新图就是（内向）基环树的森林。最后将边转为无向。

题目要求权值最大化，那么就是求图上的最大生成基环树森林。要求最大生成基环树森林，可以仿照 Kruskal 算法贪心地取边，与一般 MST 的不同之处就是需要判环，实现要点是一个点所在连通块中最多一个环。

时间复杂度 $O(n\log n)$。

### Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1e5 + 5;

int n, w, h;
struct edge { int u, v, w; } e[N];
int fa[N << 1];
bool ring[N << 1];

int find(int x) {
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}

signed main() {
    ios::sync_with_stdio(false);
    cin >> n >> h >> w;
    for (int i = 1; i <= w + h; i++)
        fa[i] = i, ring[i] = false;
    for (int i = 1; i <= n; i++)
        cin >> e[i].u >> e[i].v >> e[i].w;
    
    sort(e + 1, e + 1 + n, [](const edge& x, const edge& y) {
        return x.w > y.w;
    });

    long long ans = 0ll;
    for (int i = 1; i <= n; i++) {
        int u = e[i].u, v = e[i].v + h, w = e[i].w;
        u = find(u), v = find(v);

        if (u == v) {
            if (!ring[u]) ring[u] = 1, ans += w;
        } else {
            if (!ring[u] || !ring[v]) {
                ring[u] = ring[v] = ring[u] | ring[v];
                fa[u] = v, ans += w;
            }
        }
    }

    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：DPair (赞：2)

## 【翻译】
有$N$张卡片被放在一个$H$行$W$列的平面上，第$i$张卡上标有一个整数$A_i$，并被放在第$R_i$行第$C_i$列。

同一个格子上可能会有多张卡片。

现在你要先从每一行拿走一张卡，再从每一列拿走一张卡（也可以可以不拿），使得拿走的所有卡片上的数字和最大。

## 【思路（伪）】
我们考虑每一张卡片最多被拿一次，且这张卡片要么是在你从每一列中拿取时被拿走的，要么是在你从每一行中拿取时被拿走的，要么就没被拿走。

因此考虑建立网络流模型，对于每一个物品建立一个节点，并对于每一个出现的行、列**各**建立一个节点，然后每一个物品节点向它所**对应的**行、列各连一条容量无限，费用为物品价值的边。

然后建立一个超级源点$S$向每一个物品节点连一条费用为$0$，容量为$1$的点，建立一个超级汇点$T$，由每一个行、列节点出发向超级汇点连一条容量为$1$，费用为$0$的点。以保证每一个物品、每一行、每一列都最多只被选过一次。

然后对于建好的图跑最大费用最大流就可以得出能得到的最大权值了

吗？

很显然，$N\leq10^5$的数据范围不允许我们这么做。


因此考虑优化。

## 【思路（真）】
我们发现，我们建模好的网络流删去超级原点与超级汇点，会发现这是一个二分图。

然后跑二分图匹配就行了？答案是不行，还是跑太慢。

因此我们来看看这个图还有什么性质。

我们发现，我们最后匹配完时，左边（物品节点）的点数一定要等于右边（行列节点）的点数。也就是说不能这样
```
1 -- 2
    /
   /
  /
3
```
证明显然吧，你每一行每一列只能选一个啊，在此不赘述了

而且我们发现，对于我们得到的最终匹配的每一个子匹配（~~我不知道是不是这么叫~~），都满足这个性质（毕竟你每行每列最多选一个）。

因此我们考虑贪心，将左边节点的权值进行排序，然后将与这个节点有联系的行列节点加入一个集合，我们定义行列节点的一个集合的权值为这个集合还能承受的物品节点个数，因此每次选择最大的一个节点时，我们先判断目前的集合能不能承受这个最大的节点（因为这个集合一定是答案集合的子集，所以一定满足这个右边节点集合的大小大于我们在左边节点选过的点的集合大小），然后将这个集合的权值减一就行。如果与这个点有联系的行列节点已经在集合内了，只需减小集合权值（或不选）即可。

这个集合可以用并查集来维护，带个权就行。

下面简单说一下它的正确性（其实算是模拟一下过程）。

比如你有三个点
```
a[1] = 3 a[2] = 2 a[3] =1
```
它们分别在
```
(1, 2), (1, 1) (1, 1)
```

那么建出来的图就是
![](https://cdn.luogu.com.cn/upload/image_hosting/8up35uge.png)


我们先找到了权值为$3$的**一号节点**（图中序号为$1$，~~我不会告诉你是我一开始图画错了懒得改的~~）。

然后我们难道就直接让$1$对应$1$（行）了吗？

这样显然不是最优的，因此我们先把“1行”与“2列”存入同一个集合中，然后把整个集合的权值减一。

这样子一来，以后再用到这个集合时，我们可以自动默认**一号节点**匹配了“2列”。

就像上图，我们接下来跑**二号节点**时，把“1列”加入集合，然后再把集合权值减一即可。

最后加入**三号节点**时，我们仍然只是把集合权值减一，表明我们又选了一个**行列节点**。

这么写的好处及正确性就在于：

### 我们不直接确定每个点的匹配情况，只确定剩余可以被匹配的左边节点的个数

就是酱紫。

## 【p.s.】
我看网上很多其他的题解都用了$Hall$定理，我好像完全没用到啊。。。是我哪一步跳步了吗。。。（欢迎评论里指出）

## 【代码】（觉得我讲的不好的就来看看吧）
`其实很短`
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long LL;
int n, h, w;
struct NODE{
	LL a;
	int r, c;
	inline bool operator < (const NODE &tmp) const
	{
		return a > tmp.a;
	}
}t[100010];
int fa[200010];
LL val[200010];

int find(int x)
{
	if(x == fa[x]) return x;
	return fa[x] = find(fa[x]);
}


int main()
{
	scanf("%d%d%d", &n, &h, &w);
	for (register int i = 1;i <= n;i ++) scanf("%d%d%lld", &t[i].r, &t[i].c, &t[i].a);
	sort(t + 1, t + n + 1);
	for (register int i = 1;i <= h + w;i ++)
	{
		fa[i] = i;
		val[i] = 1;//行列集合的原来每个节点都默认有1个物品节点的承受能力
	}
	LL ans = 0;
	for (register int i = 1;i <= n;i ++)
	{
		int xx = find(t[i].r), yy = find(t[i].c + h);
		if(xx == yy)
		{
			if(val[xx])
			{
				val[xx] --;
				ans += t[i].a;
			}
		}
		else
		{
			if(val[xx] + val[yy])
			{
				val[xx] += val[yy];
				val[xx] --;
				fa[yy] = xx;
				ans += t[i].a;
			}
		}
	}
	printf("%lld\n", ans);
}
```

---

## 作者：int233 (赞：0)

- 好题！好题！我从中学到了很多！

- 建议二分图相关 trick 没怎么学过的童鞋左转 P1263 。

- 看到这种“每行最多拾取一张卡”，“每列中最多拾取一张卡”的限制可以首先考虑二分图，然后考虑把每个物品分别向它所处的行和列连边，这样这个题就变成了一个求二分图最大匹配的问题，但是直接把板子码上去显然会 `TLE` ，所以我们还需要考虑一些其他办法。

- 本人在学校想这个题的时候突然灵感大发（不得不说在校园里的湖旁边踱步想题是真的心旷神怡，能想出来很多平时想不到的东西），把这个问题给抽象了一下，具体步骤如下：

首先考虑对于每个物品将他所处的行和列之间连一条边权为物品权值的虚边（颜色为物品颜色）。然后定义 $n$ 种颜色，编号为 $1\sim n$ ，定义物品颜色为编号为物品编号的颜色。实际上原来求二分图最大匹配的问题就等价于在虚图上选出一些边，对于每条选出来的边在其两个端点上任意选一个点染成这条边的颜色，要求同一个点不能被重复染色，求选出边的边权之和的最大值。

- 然后这个问题一下子就被简化了不少，发现对于每一个由最终选出来的边组成的连通块内的边数永远等于点数 $-1$ 或者等于点数。我们发现如果边数等于点数 $-1$ ，那么会有一个点没有被染色，从而答案可以变得更优。下面我们需要证明一个结论：

对于所有边数等于点数的选边方案均有一种染色方案满足要求。

- 证明其实很简单，这个请读者自证。

- 有了这个结论之后发现整个问题就是在求最大基环树森林，把边按边权从大到小排序贪心即可解决，复杂度 $O(n)$ 。

Code：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
ll n,H,W,fa[200005],sum[200005],ans;
struct node{
	ll u,v,w;
}c[100005];
ll find(ll x){
	if(x==fa[x]){
		return x;
	}
	return fa[x]=find(fa[x]);
}
ll cmp(node x,node y){
	return x.w>y.w;
}
int main(){
	cin>>n>>H>>W;
	for(int i=1;i<=n;i++){
		cin>>c[i].u>>c[i].v>>c[i].w;
		c[i].v+=H; 
	}
	for(int i=1;i<=H+W;i++){
		sum[i]=1;
		fa[i]=i;
	}
	sort(c+1,c+n+1,cmp);
	for(int i=1;i<=n;i++){
		ll fx,fy;
		fx=find(c[i].u);
		fy=find(c[i].v);
		if(fx==fy){
			if(sum[fx]){
				sum[fx]--;
				ans+=c[i].w;
			}
		}
		else{
			if(sum[fx]+sum[fy]){
				sum[fy]+=sum[fx];
				sum[fx]=0;
				sum[fy]--;
				fa[fx]=fy;
				ans+=c[i].w;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---


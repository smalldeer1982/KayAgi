# Greedy Ant

## 题目描述

[problemUrl]: https://atcoder.jp/contests/keyence2021/tasks/keyence2021_e

数直線上に $ N $ 個の飴があります。左から $ i $ 番目の飴は位置 $ 2i $ にあり、美味しさ $ a_i $ の飴です。 ここで、飴の美味しさは相異なることが保証されます。

すぬけ君と蟻が交互に飴を一つずつ取り合うことにしました。 はじめに蟻が位置 $ 1,3,\ldots,\ 2N+1 $ の一つを選んでそこに立ち、取り合いを開始します。

すぬけ君が先に飴を取ります。 すぬけ君は、自分の手番において好きな飴を一つ選んで取ることができます。

蟻は、自分の手番において、自分がいる位置から左右それぞれの方向について最も近い位置にある飴のうち、美味しさが大きい方を選んで取ります。一方向にしか飴が存在しない場合は、その方向にある最も近い位置にある飴を取ります。

飴がなくなった時点で取り合いは終了します。 蟻がはじめに立つ位置が $ 1,\ 3,\ \ldots,\ 2N+1 $ の場合のそれぞれについて、すぬけ君が取る飴の美味しさの総和としてありうる値の最大値を求めてください。

## 说明/提示

### 制約

- 与えられる入力は全て整数
- $ 1\ \leq\ N\ \leq\ 400 $
- $ 1\ \leq\ a_i\ \leq\ 10^{6} $
- $ a_i $ は相異なる

### Sample Explanation 1

\- 蟻がはじめに位置 $ 7 $ に立ったときのすぬけ君の最適な戦略の一例について説明します。 - すぬけ君は美味しさ $ 1 $ の飴を取ります。 - 蟻の左方向にある蟻に最も近い飴は美味しさ $ 3 $ の飴です。蟻の右方向にある蟻に最も近い飴は美味しさ $ 2 $ の飴です。蟻は美味しさが大きい方である美味しさ $ 3 $ の飴を取ります。 - すぬけ君は美味しさ $ 1000 $ の飴を取ります。 - 蟻の左方向にある蟻に最も近い飴は美味しさ $ 4 $ の飴です。蟻の右方向にある蟻に最も近い飴は美味しさ $ 2 $ の飴です。蟻は美味しさが大きい方である美味しさ $ 4 $ の飴を取ります。 - すぬけ君は美味しさ $ 2000 $ の飴を取ります。 - 蟻の左方向にある蟻に最も近い飴は存在しません。蟻の右方向にある蟻に最も近い飴は美味しさ $ 2 $ の飴です。蟻は美味しさ $ 2 $ の飴を取ります。 - すぬけ君は美味しさ $ 3000 $ の飴を取ります。 - すぬけ君の取った飴の美味しさの総和は $ 6001 $ です。これを超えるようなすぬけ君の飴の取り方は存在しません。

## 样例 #1

### 输入

```
7
4 3 1 2 1000 2000 3000```

### 输出

```
6004
6004
6004
6001
5007
4007
4007
4007```

## 样例 #2

### 输入

```
40
45651 92206 55173 24815 34809 73343 60978 57984 6919 89624 19693 30037 87070 6713 65976 37597 51929 93304 70911 7343 65414 38977 47998 52123 53590 35714 59319 50872 53850 40991 85668 8808 32846 70831 3416 42173 89538 73410 21502 69631```

### 输出

```
1416699
1416699
1416699
1416699
1413888
1410894
1410894
1410894
1413888
1413888
1413888
1413888
1413888
1413888
1419943
1419943
1419943
1400961
1400961
1400961
1419943
1419943
1419943
1419749
1419749
1419749
1419749
1419749
1419749
1419749
1419749
1419749
1419943
1419943
1419943
1419943
1398462
1398462
1398462
1402241
1402241```

# 题解

## 作者：Diode123 (赞：4)

## 前言

本题解也参考了 @[0x3F](https://www.luogu.com.cn/user/153422) 的代码，但前几篇题解有点简洁导致像我这样的蒟蒻看不太懂，所以此题解针对一些细节（比如 区间 DP 的由来 等）做了详细解释方便理解，有错误欢迎大佬指出。

## 题意简述
数轴上有 $n$ 颗糖均匀排列，每个糖果的可口度 $a_i$ 均不相同。

Snuke 和蚂蚁从中轮流取一颗糖果。开始时，蚂蚁会选择 任意相邻糖果之间，所有糖果左边 或 所有糖果右边 中的任意一个位置作为初始位置。

Snuke 先取糖果，他可以取走数轴上还在的任意一颗糖果。

蚂蚁行动时，它会从离它左右最近的至多两颗糖果中，选择可口度更大的一颗。

当糖果取完后结束。对于蚂蚁的所有可能初始位置，输出 Snuke 能获得糖果的最大可口度之和。

## 题目分析

分析这个取走糖果的问题，可以发现，如果把蚂蚁的初始位置看成定值，那么问题的结果只受 Snuke 影响。要求最大可口度之和，既然从样例1的解释可以发现很难有一个贪心策略，那么我们考虑DP。

既然 Snuke 的行动比较重要，那么DP就依靠 Snuke 的行动定义

这一次拿走一颗糖果，而蚂蚁也能取一颗。而 Snuke 有时可以对蚂蚁的行动做出调整。如图，中间为蚂蚁，设左边两颗糖果为 $a,b$，右边两颗糖果为 $c,d$：

![](https://cdn.luogu.com.cn/upload/image_hosting/qbkl4ez7.png)

可以发现在 Snuke 行动后，蚂蚁可能取到三种情况：$\max(b,c)\   \max(a,c)\  \max(b,d)$  那么我们分别根据三种情况进行转移。

但这时我们发现，当取 $\max(b,c)$ 时，Snuke 就可以**囤下一次操作**，下次蚂蚁取时如果 Snuke 囤下了操作，那么就会增加可能性。所以要把这个影响因素也加进状态。

可是我们发现，在 DP 中很难记录 Snuke 或者蚂蚁已经取走了哪些糖果。这时怎么办？看到前面 Snuke 可以囤下操作这一过程，可以想到如果假设囤下操作暂时不对糖果产生影响，那么取走的糖果一定在一个 **区间**，而且蚂蚁一定在这个空区间里。 分析到这里就可以开始考虑 **区间DP** 了。而为了方便写代码，可以把囤操作与释放操作分开处理。

1. **定义问题状态**： 

     定义 $dp_{i,j,k}$ 表示当前区间 $[l,r]$ 已经被取完（或者说蚂蚁在 $[l,r]$ 这个空区间），Snuke 囤了 $k$ 次操作时 Snuke 能得到的最大可口度；

2. **找出状态转移方程**：

     首先枚举区间大小 $x$ (从 $n-1$ 到 $1$，**从大到小**倒着来以方便处理答案)，区间左 $l$ (从 $0$ 到 $n-x$ )，区间右 $r (=l+x)$，囤下步数 $k$ (从 $0$ 到 $x+1$)；（$0 \sim n$ 表示每一个蚂蚁可能存在的位置，$1 \sim n$ 分别为对应糖果的右边，$0$ 是 $1$ 号糖果左边；对于每个序号，左边糖果序号与之相同，右边则为其序号 $+1$，这样应该更好理解为什么区间是**左闭右开**的，参考植树问题）

     当有囤积步数时，如果蚂蚁左边不为空，那么可以消耗一次步数把最左边的拿走，即：

      $$ dp_{l,r,k} = \max(dp_{l,r,k},dp_{l-1,r,k-1}+a_l)$$ 

     如果蚂蚁右边不为空，那么消耗一次步数把最右边的拿走，即：

      $$ dp_{l,r,k} = \max(dp_{l,r,k},dp_{l,r+1,k-1}+a_{r+1})$$ 

     然后要让蚂蚁拿了，同时囤积步数。如果蚂蚁右边是空的（根据 $l$ 与 $r$ 的关系此时左边不为空）或者左边更大，那么让它从左边选:

      $$ dp_{l,r,k} = \max(dp_{l,r,k},dp_{l-1,r,k+1})$$ 

     否则让它从右边选：

      $$ dp_{l,r,k} = \max(dp_{l,r,k},dp_{l,r+1,k+1})$$  

3. **初始化状态数组与边界**  

    $dp_{i,j} = 0,\ dp_{0,n,0}(\text{整个区间}) =0$ ； 所以不用管；

4. **枚举顺序**

    同上，枚举区间大小 $x$ (从 $n-1$ 到 $1$ ，从大到小以方便处理答案)，区间左 $l$ (从 $0$ 到 $n-x$ )，区间右 $r (=l+x)$，囤下步数 $k$ (从 $0$ 到 $x+1$ )；

5. **答案**

    直接枚举 $i$ ( $0 \sim n$ ) 并输出  就可以输出对应蚂蚁在此初始位置的答案了。

时间复杂度 $O(n^3)$ 可以通过此题。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 405
using namespace std;
ll n,a[N],dp[N][N][N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin >> n;
	for(int i=1; i<=n; i++) cin >> a[i];
	for(int x=n-1; x>=0; x--)
		for(int l=0, r=x; r<=n; l++,r++)
			for(int k=0; k<=x+1; k++){
				if(k){
					if(l) dp[l][r][k] = max(dp[l][r][k],dp[l-1][r][k-1]+a[l]);
					if(r!=n) dp[l][r][k] = max(dp[l][r][k],dp[l][r+1][k-1]+a[r+1]);
				}
				if(r==n|a[l]>a[r+1]) dp[l][r][k]=max(dp[l][r][k],dp[l-1][r][k+1]);
				else dp[l][r][k]=max(dp[l][r][k],dp[l][r+1][k+1]);
			}
	for(int i=0; i<=n; i++) cout << dp[i][i][1] << '\n';
	return 0;
}
```

结论：确实不是人能想出来的！

---

## 作者：0x3F (赞：4)

这真的是人能想出来的？

由于 Ant 只是按照一个固定的方式移动，看不到 Snuke 选了哪些物品。所以 Snuke 可以把自己的操作积累起来，等到 Ant 走到对应位置再操作，容易证明这样答案不变。

我们记 $dp_{l,r,k}$ 表示当前区间 $[l,r]$ 已经被取完，Snuke 还有 $k$ 步的余额，则每一步 Snuke 有以下两种选择：

1. 自己选择一个数，可以选 $l-1$ 或 $r+1$，得到该物品的权值，操作后 $k\gets k-1$。

2. 放弃自己的回合，让 Ant 选一个数。注意 Ant 只能选 $l-1$ 和 $r+1$ 中权值较大的那一个，操作后 $k\gets k+1$。

时间复杂度为 $\mathcal{O}(n^3)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 410;
int n, a[_], dp[_][_][_];
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int d = n - 1; d >= 0; d--) {
        for (int l = 0, r = d; r <= n; l++, r++) {
            for (int k = 0; k <= d + 1; k++) {
                if ((k) && (l != 0)) {
                    dp[l][r][k] = max(dp[l][r][k], dp[l-1][r][k-1] + a[l]);
                }
                if ((k) && (r != n)) {
                    dp[l][r][k] = max(dp[l][r][k], dp[l][r+1][k-1] + a[r+1]);
                }
                if ((l != 0) && ((r == n) || (a[l] > a[r+1]))) {
                    dp[l][r][k] = max(dp[l][r][k], dp[l-1][r][k+1]);
                } else {
                    dp[l][r][k] = max(dp[l][r][k], dp[l][r+1][k+1]);
                }
            }
        }
    }
    for (int i = 0; i <= n; i++) {
        cout << dp[i][i][1];
        if (i != n) {
            cout << '\n';
        }
    }
    cout << endl;
    return 0;
}
```

---

## 作者：yx666 (赞：1)

# AT_keyence2021_e Greedy Ant 题解

$$\text{Description}$$

数轴上有 $n$ 颗糖，第 $i$ 颗糖在坐标 $2i$ 处，且有一个美味度 $a_i$，糖果的美味度均不相同。

Snuke 和蚂蚁准备玩一个轮流取一颗糖果的游戏。游戏开始时，蚂蚁会选择 $1,3,\cdots,2n+1$ 中的一个位置作为初始位置。

Snuke 先取糖果，他可以任意取走数轴上还在的任何一颗糖果。

蚂蚁行动时，它会从离它两边最近的至多两颗糖果中，选择美味度更大的一颗。

当最后没有糖果可取后，游戏结束。对蚂蚁的每个开始位置 $1,3,\cdots,2n+1$，求出 Snuke 可以获得的糖果的美味度之和的最大值。

- $ 1\le N\le400$。
- $ 1\le a_i\le10^6$。

$$\text{Solution}$$

暴力的做法就略过了，时间复杂度是逆天的。

参考 @[0x3F](https://www.luogu.com.cn/user/153422) 的题解，这里写一篇稍微有点不一样的。

### Part 1. 定义问题状态
因为 Ant 只是按照一个固定的方式移动，所以 Snuke 可以把自己的操作积累起来，等到 Ant 走到对应位置再操作，这样答案也是不变的。

所以定义 $dp_{l,r,k}$ 表示区间 $[l,r)$ 已经被取完，Snuke 还囤了 $k$ 步没走。

### Part 2. 状态转移方程
对于每个已选区间 $[l,r)$，Snuke 有两种选择：

1. 选择糖 $l-1$ 或 $r$：

  $$dp_{l,r,k}=\max(dp_{l-1,r,k-1}+a_{l-1},dp_{l,r+1,k-1}+a_r)$$

2. 不选，将选择留给 Ant：

  $$dp_{l,r,k}=\max(dp_{l,r+1,k+1},dp_{l-1,r,k+1})$$

### Part 3. 初始化与边界状态
1. 初始化全为 $0$。

2. 边界状态：$l=1$ 或 $r=n+1$ 或 $l=r$。

### Part 4. 计算顺序与答案
1. 计算顺序：依次枚举区间长（从大到小），枚举 $l,r$（$l$ 从 $1$ 开始），枚举屯的步数 $k$。

2. 答案：$dp_{i,i,1}$ ，$i$ 从 $1\to n+1$。

$$\text{Code}$$

实际上代码才是最重要的。

注意 $[l,r)$ 是左闭右开的。

``` cpp
#include<stdio.h>
#include<string.h>

#define T int
#define gc() getchar()
#define pc(x) putchar(x)

static inline T read(){T x=0;char ch=gc();while(ch<'0'||'9'<ch) ch=gc();while('0'<=ch&&ch<='9') {x=(x<<3)+(x<<1)+(ch-'0');ch=gc();}return x;}
static inline void writeln(T x) {static int sta[28];if(x<0){pc('-');x=-x;}int top = 0;do sta[top++] = x % 10, x /= 10;while (x);while (top) pc(sta[--top] + '0');pc('\n');}
#undef T


#define ll int
static inline ll max(ll a,ll b){return a>b?a:b;}
static inline ll min(ll a,ll b){return a<b?a:b;}

#define N 404
ll n,a[N],dp[N][N][N];
signed main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	
	for(int s=n;s;--s){							// 区间长 
		for(int l=1,r=l+s-1;r<=n+1;++l,++r){	// 枚举区间 [l,r)
			for(int k=0;k<=s;++k){				// 最多屯 s 步 
				// 蚂蚁取： 
				if(l==1||(r!=n+1&&a[l-1]<a[r]))	// 留给蚂蚁取右边的
					dp[l][r][k]=max(dp[l][r][k],dp[l][r+1][k+1]);
				else 								// 留给蚂蚁取左边的 
					dp[l][r][k]=max(dp[l][r][k],dp[l-1][r][k+1]); 
				
				// 自己取：
				if(k!=0){		// 自己能取 
					if(l!=1)	// 取左边的 
						dp[l][r][k]=max(dp[l][r][k],dp[l-1][r][k-1]+a[l-1]);
					if(r!=n+1)	// 取右边的 
						dp[l][r][k]=max(dp[l][r][k],dp[l][r+1][k-1]+a[r]);
				} 
			}
		}
	}
	for(int i=1;i<=n+1;++i) writeln(dp[i][i][1]);
	return 0;
}
```

再贴一份 $(l,r]$，左开右闭的。

``` cpp
#include<stdio.h>
#include<string.h>

#define T int
#define gc() getchar()
#define pc(x) putchar(x)

static inline T read(){T x=0;char ch=gc();while(ch<'0'||'9'<ch) ch=gc();while('0'<=ch&&ch<='9') {x=(x<<3)+(x<<1)+(ch-'0');ch=gc();}return x;}
static inline void writeln(T x) {static int sta[28];if(x<0){pc('-');x=-x;}int top = 0;do sta[top++] = x % 10, x /= 10;while (x);while (top) pc(sta[--top] + '0');pc('\n');}
#undef T

#define ll long long 
static inline ll max(ll a,ll b){return a>b?a:b;}
static inline ll min(ll a,ll b){return a<b?a:b;}

#define N 404
ll n,a[N],dp[N][N][N];
signed main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	
	for(int s=n;s;--s){							// 区间长 
		for(int l=0,r=l+s-1;r!=n+1;++l,++r){	// 枚举区间 (l,r]
			for(int k=0;k<=s;++k){				// 最多屯 s 步 
				// 留给蚂蚁取： 
				if(l==0||(r!=n&&a[l]<a[r+1]))	// 留给蚂蚁取右边的
					dp[l][r][k]=max(dp[l][r][k],dp[l][r+1][k+1]);
				else 								// 留给蚂蚁取左边的 
					dp[l][r][k]=max(dp[l][r][k],dp[l-1][r][k+1]); 
				
				// 自己取：
				if(k!=0){		// 自己能取 
					if(l!=0)	// 取左边的 
						dp[l][r][k]=max(dp[l][r][k],dp[l-1][r][k-1]+a[l]);
					if(r!=n)	// 取右边的 
						dp[l][r][k]=max(dp[l][r][k],dp[l][r+1][k-1]+a[r+1]);
				} 
			}
		}
	}
	for(int i=0;i<=n;++i) writeln(dp[i][i][1]);
	return 0;
}
```

（不开 `long long` 也能过）。

$$\text{Afterword}$$

本来想打左闭右闭的，但是打不出来。

有锅请私信。

---

## 作者：EuphoricStar (赞：0)

看到 $n \le 400$，以及对于每个点输出答案，很容易猜到是区间 dp。

但是我们发现我们没办法记录 Snuke 选了哪些数。

考虑 Snuke 选的数，有些是暂时对 Ant 不会造成影响的，只有 Ant 能取的范围到了这个数才会。

于是 Snuke 可以跳过一些轮到它选的步数，囤到能对 Ant 造成影响再选。

于是设 $f_{l, r, k}$ 表示选了 $[l, r]$ 的数，Snuke 囤了 $k$ 步，也就是说它还能选 $k$ 次。

转移大概是 $[l, r] \gets [l - 1, r], [l, r] \gets [l, r + 1]$。讨论 $a_{l - 1}$ 或 $a_{r + 1}$ 是 Snuke 选还是 Ant 选即可。注意如果是 Ant 选，由题意，需要满足这个数大于另一端的数。

实现时可以写记搜。

时间复杂度 $O(n^3)$。

[code](https://atcoder.jp/contests/keyence2021/submissions/43289704)

---


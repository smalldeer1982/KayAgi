# Urban Planning

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nomura2020/tasks/nomura2020_d

$ 1,\ 2,\ \cdots,\ N $ の番号がついた $ N $ 個の町があります。

現在、$ 2 $ つの相異なる町を双方向に結ぶ道をいくつか作ることが計画されています。現時点では、町を結ぶ道はありません。

この計画において、各町は他の町を $ 1 $ つ選んで、道を $ 1 $ 本以上使ってその町に移動できるように要請します。

$ N $ 個の町の要請は配列 $ P_1,\ P_2,\ \cdots,\ P_N $ で表され、町 $ i $ の要請は、$ P_i\ =\ -1 $ のときまだ決定されていないこと、$ 1\ \leq\ P_i\ \leq\ N $ であるとき町 $ P_i $ を選んだことを表します。

$ P_i\ =\ -1 $ である町の個数を $ K $ 個としたとき、全体では $ (N-1)^K $ 通りの要請方法が考えられます。それぞれの要請方法について、すべての町の要請を満たすために作る必要がある道の本数の最小値を求め、その総和を $ 10^9+7 $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ P_i\ =\ -1 $ または $ 1\ \leq\ P_i\ \leq\ N $
- $ P_i\ \neq\ i $
- 入力は全て整数である

### Sample Explanation 1

要請方法としては次の $ 3 $ 通りがあります。 - $ P_1\ =\ 2,\ P_2\ =\ 1,\ P_3\ =\ 1,\ P_4\ =\ 3 $ とする。このとき、例えば道 $ (1,2),(1,3),(3,4) $ の $ 3 $ つを作ることですべての町の要請を満たすことができ、これが最小です。 - $ P_1\ =\ 2,\ P_2\ =\ 1,\ P_3\ =\ 2,\ P_4\ =\ 3 $ とする。このとき、例えば道 $ (1,2),(1,3),(3,4) $ の $ 3 $ つを作ることですべての町の要請を満たすことができ、これが最小です。 - $ P_1\ =\ 2,\ P_2\ =\ 1,\ P_3\ =\ 4,\ P_4\ =\ 3 $ とする。このとき、例えば道 $ (1,2),(3,4) $ の $ 2 $ つを作ることですべての町の要請を満たすことができ、これが最小です。 必ずしも町 $ i $ と町 $ P_i $ が直接繋がっている必要がないことに注意してください。 よって、総和は $ 8 $ です。

### Sample Explanation 2

初めから要請が $ 1 $ 通りに決まっている場合もあります。

## 样例 #1

### 输入

```
4
2 1 -1 3```

### 输出

```
8```

## 样例 #2

### 输入

```
2
2 1```

### 输出

```
1```

## 样例 #3

### 输入

```
10
2 6 9 -1 6 9 -1 -1 -1 -1```

### 输出

```
527841```

# 题解

## 作者：小粉兔 (赞：4)

搬运[原博客园题解](https://www.cnblogs.com/PinkRabbit/p/AtCoderNOMURA2020.html)于 2020-06-01。

假设原图由 $M$ 个基环内向树和 $K$ 个内向树构成。  
并且令 $K$ 个内向树的大小依次为 $b_1, b_2, \ldots , b_K$。

要求将给定点对连通的最小边数，也就相当于求 $N$ 减去连通块个数。  
只要求出所有图中的连通块个数，再用 $N {(N - 1)}^K$ 减去这个值即可。

显然至少有 $M$ 个连通块，给总连通块个数贡献 $M {(N - 1)}^K$。

在其余的 $K$ 个内向树中，可以将每个内向树看作一个整体，每在其中形成一个环，就为连通块个数贡献 $1$。

考虑枚举某个环中的所有内向树，假设为 $k$（$k \ge 1$）个，为 $\{ a_1, a_2, \ldots , a_k \}$（无顺序）。  
那么它们形成环的方案数就为 $\displaystyle (k - 1)! \prod_{i = 1}^{k} b_{a_i}$。

即枚举一种圆排列（共有 $(k - 1)!$ 种），每一个内向树的根可以连向下一个内向树的任何一个点，所以把所有 $b$ 值相乘即可。

除了一种例外情况，当 $k = 1$ 时，方案数应该为 $(b_{a_1} - 1)$，因为有不能连向自己的限制。

据此可以考虑一个 DP：对于每个 $k$ 满足 $1 \le k \le K$，求出在所有内向树中选出 $k$ 个时它们的 $b$ 值的乘积之和。

依次加入每个内向树即可维护。

求出后每项乘上 $(k - 1)!$，再乘上 ${(N - 1)}^{K - k}$（剩下的其它内向树的方案数）贡献给答案即可，对于 $k = 1$ 特殊处理一下。

```cpp
#include <cstdio>
#include <vector>

typedef long long LL;
const int Mod = 1000000007;
const int MN = 5005;

inline int qPow(int b, int e) {
	int a = 1;
	for (; e; e >>= 1, b = (LL)b * b % Mod)
		if (e & 1) a = (LL)a * b % Mod;
	return a;
}

int N, M, A[MN], Fac[MN];
std::vector<int> G[MN];
int K, B[MN];

int vis[MN];
void DFS(int u) {
	++B[K], vis[u] = 1;
	for (int v : G[u]) DFS(v);
}
void DFS2(int u, int o) {
	vis[u] = 1;
	for (int v : G[u])
		if (!vis[v]) DFS2(v, o);
		else if (v == o) ++M;
}

int dp[MN][MN];

int main() {
	scanf("%d", &N), Fac[0] = 1;
	for (int i = 1; i <= N; ++i) scanf("%d", &A[i]), Fac[i] = (LL)Fac[i - 1] * i % Mod;
	for (int i = 1; i <= N; ++i) if (~A[i]) G[A[i]].push_back(i);
	for (int i = 1; i <= N; ++i) if (!~A[i]) ++K, DFS(i);
	for (int i = 1; i <= N; ++i) if (!vis[i]) DFS2(i, i);
	dp[0][0] = 1;
	for (int i = 1; i <= K; ++i) {
		dp[i][0] = 1;
		for (int j = 1; j <= i; ++j)
			dp[i][j] = (dp[i - 1][j] + (LL)dp[i - 1][j - 1] * B[i]) % Mod;
	}
	dp[K][1] -= K;
	int Ans = (LL)M * qPow(N - 1, K) % Mod;
	for (int j = 1; j <= K; ++j) Ans = (Ans + (LL)dp[K][j] * Fac[j - 1] % Mod * qPow(N - 1, K - j)) % Mod;
	Ans = ((LL)N * qPow(N - 1, K) % Mod - Ans + Mod) % Mod;
	printf("%d\n", Ans);
	return 0;
}
```

---

## 作者：Arghariza (赞：2)

考虑排列 $P_i$ 已经固定了的情况，那么连边 $i\to P_i$ 形成有向图 $G$，最小连边数就是 $N$ 减去弱连通块数。善良的出题人已经告诉你连边方案就是 $(N-1)^K$，所以答案就是 $N(N-1)^K$ 减去所有连边方案中弱连通块数量总和。于是只需要考虑所有连边方案中弱连通块数量总和即可。

注意到最后这张图一定是个**内向基环树**森林，所以某些 $P_i$ 未确定时就应该是个**内向基环树**加若干**内向树**构成的森林（孤立点也算内向树）。考虑一个弱连通块 $G'\subseteq G$，按照其形态分类：

- $G'$ 为**内向基环树**，则 $G'$ 内的点的 $P_i$ 均固定，且只有一个环，所以对一个连边方案的贡献为 $1$，算上外部连边方案，总贡献为 $(N-1)^K$。
- $G'$ 为**内向树**，则 $G'$ 内存在**唯一** $P_i$ 不固定的点 $i$，就是内向树的**根**。这个连通块有两种选择：
 - $P_i$ 选择 $G'$ 内的点，那么 $P_i$ 有 $|V_{G'}|-1$ 种选择方案（不能选自己），外部还剩 $(N-1)^{K-1}$ 种方案，那么贡献为 $(|V_{G'}|-1)(N-1)^{K-1}$。
 - $P_i$ 选择 $G'$ 外的点，那么 $G'$ 就变成了某个大内向基环树的子图，而这个基环树除去环边是由若干个内向树组成的。这类贡献有关其它连通块大小，单独拉出来在下面讨论。

刚才的问题可以转化为单独考虑每个大环的贡献，大环是由从 $G$ 中选出若干个**形态为内向树的连通块**，选出它们的根之后连接组成的。假设选择了 $G_1,G_2,\cdots,G_m$ $m$ 个连通块形成一个环，环上的树的排列方式有圆排列 $(m-1)!$ 种，每个根 $i$ 的 $P_i$ 可以在下一棵内向树的点中任意选择，选择方案有 $\prod |V_{G_i}|$ 种（$V_G$ 为构成子图 $G$ 的点集），其余 $P_i$ 未匹配的 $i$ 有 $K-m$ 个，选出这些 $P_i$ 有 $(N-1)^{K-m}$ 种方案。

那么设组成基环树的内向树数量为 $m(m\ge 2)$，方案数就是：

$$(m-1)!(N-1)^{K-m}\sum\limits_{G_1,G_2,\cdots,G_m}\prod\limits_{i=1}^m|V_{G_i}|$$

后面这个东西就是个背包，设 $f(m)=[x^m]\prod\limits(|V_{G_i}|x+1)$，可以 $O(N^2)$ 背包 dp 求出来，那么 $m$ 的总贡献就是：

$$(m-1)!(N-1)^{K-m}f(m)$$

然后算上之前的贡献就做完了，复杂度 $O(N^2)$。瓶颈在于计算 $f(m)$，可以多项式优化。

---


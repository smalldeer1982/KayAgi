# Binary Programming

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nomura2020/tasks/nomura2020_e

高橋くんは、空文字列 $ S $ と、$ 0 $ で初期化された変数 $ x $ を持っています。

また `0` および `1` のみからなる文字列 $ T $ があります。

高橋くんはこれから、以下の $ 2 $ ステップからなる操作を $ |T| $ 回繰り返します。

- $ S $ の好きな位置に `0` または `1` を挿入する。
- 次に、$ S $ の左から奇数番目に書かれた数字の総和を $ x $ に加算する。例えば現在 $ S $ が `01101` であるなら、$ S $ の左から奇数番目に書かれた数字は左から `0`, `1`, `1` なので、$ 2 $ を $ x $ に加算する。

最終的に $ S $ が $ T $ に一致するような操作列における、最終的な $ x $ の値の最大値を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ |T|\ \leq\ 2\ \times\ 10^5 $
- $ T $ は `0` および `1` のみからなる。

### Sample Explanation 1

例えば以下のような操作列が、最終的な $ x $ の値を $ 5 $ に最大化します。 - $ S $ の先頭に `1` を挿入する。$ S $ は `1` になり、$ x $ に $ 1 $ を加算する。 - $ S $ の $ 1 $ 文字目の直後に `0` を挿入する。$ S $ は `10` になり、$ x $ に $ 1 $ を加算する。 - $ S $ の $ 2 $ 文字目の直後に `1` を挿入する。$ S $ は `101` になり、$ x $ に $ 2 $ を加算する。 - $ S $ の先頭に `1` を挿入する。$ S $ は `1101` になり、$ x $ に $ 1 $ を加算する。

## 样例 #1

### 输入

```
1101```

### 输出

```
5```

## 样例 #2

### 输入

```
0111101101```

### 输出

```
26```

# 题解

## 作者：小粉兔 (赞：3)

搬运[原博客园题解](https://www.cnblogs.com/PinkRabbit/p/AtCoderNOMURA2020.html)于 2020-06-01。

令 $N = |T|$，等价于执行以下操作 $N$ 次：

- 所有奇数位的数之和贡献给答案。
- 删去任意一位。

首先可以发现当 `0` 还没删光时，删 `1` 是不优的。

然而当 `0` 删光了的时候，之后的操作对答案的贡献就很显然了。所以这里考虑如何删 `0` 是最优的。

可以发现如果有两个相邻的 `1`，那么每次操作时它们对答案的贡献都是 $1$。所以可以先不考虑。

那么一直删除相邻的两个 `1` 后，只剩下 $k$ 个 `1` 时，就形成了 $a_0\mathtt{0} \quad \mathtt{1} \quad a_1\mathtt{0} \quad \mathtt{1} \quad \cdots \quad \mathtt{1} \quad a_k\mathtt{0}$ 的情况。

对于其中的第 $i$ 个 `1`，它最多给答案贡献 $(a_0 + \cdots + a_{i - 1})$ 的一半（取整方式取决于位置的奇偶性）加 $(a_i + \cdots + a_k)$。

而事实上这个上界是可以被达到的，也就是需要对每个 `1` 都满足在删它后面的 `0` 时它的位置在奇数：  
先把 $a_0$ 个最开始的 `0` 删光，然后删 $a_1 - 1$ 个 `0` 留下恰好一个，以此类推，删掉 $a_{k - 1} - 1$ 个 `0` 留下恰好一个。  
这时形如 $\mathtt{1010100000000 \cdots}$，然后从右到左把所有的 `0` 删掉即可。

所以使用上述结论求答案即可。

```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;
const int MN = 200005;

int N, C0, C1, K;
char T[MN];
int stk[MN], cnt[MN], tp;
LL Ans;

int main() {
	scanf("%s", T + 1), N = strlen(T + 1);
	for (int i = 1; i <= N; ++i) ++(T[i] & 1 ? C1 : C0);
	Ans = (LL)(C1 + 1) * (C1 + 1) / 4;
	T[0] = T[N + 1] = '0';
	for (int i = 0; i <= N + 1; ++i) {
		int x = T[i] - '0';
		if (!x) {
			if (tp && !stk[tp]) ++cnt[tp];
			else stk[++tp] = 0, cnt[tp] = 1;
		} else {
			if (tp && stk[tp]) --tp, Ans += C0;
			else stk[++tp] = 1, cnt[tp] = 1;
		}
	} --cnt[1], --cnt[tp];
	for (int i = 1, s = 0; 2 * i <= tp; ++i)
		s += cnt[2 * i - 1],
		Ans += (s + i + 1) / 2 - (i + 1) / 2 + (C0 - s);
	printf("%lld\n", Ans);
	return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：2)

首先题目叫我们正推，但是正推不太好做约束锕，于是我们考虑逆转整个过程，从输入串开始，每部执行：

+ 求奇数位的和；

+ 随便删一位。

我们可以先来研究一下删位的性质。首先显然有一个简单的事实：如果一堆一连成一块，删它们中的哪一个是没有所谓的，效果都是让这个连一块的长度减少恰好一。如此，我们可以不妨假设删一的时候永远删的是连一块的边界。但我们这个时候发现，除非只剩一了，否则每个连一块一定有至少一个边界挨了个零。我们意识到删这个边界一不如删零来得实惠（删完状态唯一的差异就是把那个零的位置改成了一，由于我们要最大化总价值肯定是留一比较好）。于是我们导出了一条基本性质：有零可以删的时候一定优先删零。

而不包含零之后的操作是易于刻画的，每次随便删一个一就好，统计起来高度方便，于是我们只要考虑这之前的抉择就好。我们又观察到，对于两个连在一起的一，它们在（零被删完前）任意时刻位置一定是一奇一偶，每轮都能稳定产生一的贡献，我们不妨先行统计掉这部分贡献然后把这俩一一起消掉。于是，我们现在还需要考虑的串中，不存在长度超过一的连一块。

那么现在我们的串长成了这个鬼样子：

【一堆 0】1【一堆 0】1【一堆 0】1……

我们注意到，对于一个特定的一，在它之前的零每删去一次都会导致它位置奇偶变化，至多有一半的时间可以让它被加入贡献；那剩下的时间，删它后面的零的时候，作为上限，我们希望它全部被加入贡献。而这是可以做到的——先把开头一堆零删完，然后把第二堆零删到剩一个，然后第三堆剩一个……以此类推，最后反扫一遍把这些零删完就好了。

代码非常好写，就不展示了。

---


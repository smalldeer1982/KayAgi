# Indifferent

## 题目描述

[problemUrl]: https://atcoder.jp/contests/cf17-relay-open/tasks/relay2_j

$ 2N $ 個の壺があります。このうち $ i $ 個目の壺 $ (1\ <\ =\ i\ <\ =\ 2N) $ の市場価格は $ p_i $ 円です。

これから、あなたとダックスフンドのルンルンは交互に壺を一つずつ取っていきます。あなたから始めて、すべての壺があなたかルンルンに取られるまで続けます。ルンルンは壺の市場価格がわからないので、毎回、残っている壺の中から無作為に等確率で一つを選びます。あなたはこのルンルンの行動と、壺の市場価格を知っています。

あなたの目的は、取る壺の市場価格の合計を $ S $ 円としたとき、$ S $ の期待値を最大化することです。最適な戦略を取ったときの $ S $ の期待値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ p_i\ <\ =\ 2\ ×\ 10^5 $
- 入力値はすべて整数である。

### Sample Explanation 1

当然、$ 15 $ 万円の壺を選ぶべきです。

### Sample Explanation 2

あなたはまず、$ 10 $ 万円の壺のうち一つを取ります。もう一つの $ 10 $ 万円の壺は、次のルンルンの番で取られなければ手に入り、その確率は $ 2/3 $ です。もしその壺を取られてしまった場合は、$ 5 $ 万円の壺で我慢することになります。以上から、最適な戦略を取ったときの $ S $ の期待値は $ 2/3\ ×\ (100000\ +\ 100000)\ +\ 1/3\ ×\ (100000\ +\ 50000)\ =\ 183333.3333… $ となります。

## 样例 #1

### 输入

```
1
150000
108```

### 输出

```
150000.0```

## 样例 #2

### 输入

```
2
50000
50000
100000
100000```

### 输出

```
183333.3333333333```

# 题解

## 作者：hwk0518 (赞：4)

不难想到，最优策略一定是每次取最大的数。

从选的数总体考虑，很难有突破性的进展，只能状压。所以我们分别考虑每个数被选的概率。状压打表不难发现，有2n个数时，从小到大第i个数被选的概率是(i-1)/(2n-1).

证明：

我们使用数学归纳法。

当n=1时显然成立。

当n=k时成立，归纳n=k+1.

    (1)i=2n成立。
    (2)i<2n.设第二个人第一次选的数是k.
       1)k<i:第二个人选这样一个数的概率是(i-1)/(2n-1).此时i从小到大排(i-1)位。退化成一个2*(n-1)的游戏。由归纳假设，接下来选到i的概率是(i-2)/(2n-3).
       2)k>i:第二个人选这样一个数的概率是(2n-1-i)/(2n-1).同1)接下来选到i的概率是(i-1)/(2n-3).
       3)k=i:第二个人选这样一个数的概率是1/(2n-1).显然接下来选到i的概率为0.
       
      加起来得到：P(i)=(i-1)/(2n-1).
    综上，成立。


所以对于所有n∈Z+，上述定理成立。

按照定理模拟即可。

代码：

```

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const int N=3e5+5;
int n,s[N];
long long ans;

void init()
{
	int i;
	scanf("%d",&n);
	for(i=1;i<=2*n;++i) scanf("%d",&s[i]);
	sort(s+1,s+2*n+1);
}

void work()
{
	int i;
	for(i=1;i<=2*n;++i) ans+=1LL*(i-1)*s[i];
	printf("%.12lf\n",1.0*ans/(2*n-1));
}

int main()
{
	init();
	work();
	return 0;
}


```

---


# [AGC006D] Median Pyramid Hard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc006/tasks/agc006_d

$ N $ 段のピラミッドがあります。 段は上から順に $ 1 $, $ 2 $, $ ... $, $ N $ と番号が振られています。 各 $ 1\ <\ =i\ <\ =N $ について、$ i $ 段目には $ 2i-1 $ 個のブロックが横一列に並んでいます。 また、各段の中央のブロックに注目すると、これらは縦一列に並んでいます。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc006_d/a992c42b0e9b0597f104bf82a0adc1131324bb4f.png)$ N=4 $ 段のピラミッド

 

すぬけ君は $ N $ 段目のブロックに ($ 1 $, $ 2 $, $ ... $, $ 2N-1 $) を並べ替えたもの（順列）を書き込みました。 さらに、次のルールに従い、残りすべてのブロックに整数を書き込みました。

- あるブロックに書き込まれる整数は、そのブロックの左下、真下、右下のブロックに書き込まれた整数の中央値である。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc006_d/545e109d7af3caf92b1a8f9ac80715efa6c3d3db.png)ブロックに整数を書き込む例

 

その後、すぬけ君はすべてのブロックに書き込まれた整数を消してしまいました。 すぬけ君は、$ N $ 段目のブロックに書き込まれた順列が ($ a_1 $, $ a_2 $, $ ... $, $ a_{2N-1} $) であったことだけを覚えています。

$ 1 $ 段目のブロックに書き込まれた整数を求めてください。

## 说明/提示

### 制約

- $ 2\ <\ =N\ <\ =10^5 $
- ($ a_1 $, $ a_2 $, $ ... $, $ a_{2N-1} $) は ($ 1 $, $ 2 $, $ ... $, $ 2N-1 $) の順列である。

### Sample Explanation 1

問題文中の図の例です。

## 样例 #1

### 输入

```
4
1 6 3 7 4 5 2```

### 输出

```
4```

## 样例 #2

### 输入

```
2
1 2 3```

### 输出

```
2```

# 题解

## 作者：chengni (赞：60)

这道例题看到时毫无头绪，因为课程是二分，所以往二分的方向想，猜到是二分枚举最上面的那个数是多少，但依然不会做。

事实上，因为我们求得是中位数，所以每个数对我们来说只有与枚举的数的大小关系需要我们考虑，我们可以使大于这个数的数为1，其余的为0。

如此将其转化成一个01串，接下来我们讨论这个01串。

接下来我们可以小小的推一下。事实上，当有两个都为0的数或者都为1的数，那么就可以一直往上走。

简单地表示一下。

我们有这样一个 0 1 数列

                              0  1  1  0  1

然后我们继续推，会变成这样

								    1 
                                
                                 1  1  1  
                              
                              0  1  1  0  1
                              
可以看到如果有两个一样的数挨在一起，他们就会一直往上走。

似乎我们只要找到相邻一样的就可以了。

还是给一张 Atcoder 题解的例图吧。

![](https://cdn.luogu.com.cn/upload/pic/28097.png)

大概就是这个意思吧。

我们只需要找到离中间最近的一组相邻一样的两个数，就可以得到最上面是什么数。

那么就有人问了，如果有两个不同的相邻的离中间一样远呢？

......

我建议你再想一想。

因为一共只有两种数，又是奇数个，所以这种可能不存在。

最后还有一种特殊情况。就是没有任何两个相邻的。

大概长这样。。

![](https://cdn.luogu.com.cn/upload/pic/28098.png)

我们只需要特判一下就行了。

大概就是这样。

说了这么多，别忘了还有二分的。

代码（部分借鉴于博客）

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read(){
	char ch=getchar();int x=0,f=1;
	while(ch>'9' || ch<'0'){
        if(ch=='-') f=-1;
	    ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

int n,a[20000010];

int small(int i,int j,int k) {//求是否都小于等于
	return a[i]<=k && a[j]<=k;
}

int big(int i,int j,int k){//求是否都大于
	return a[i]>k && a[j]>k;
} 

int check(int k){
	for(int i=0;i<n-1;i++){//枚举距离判断
		if(big(n+i,n+i+1,k) || big(n-i,n-i-1,k)) return 0;
		if(small(n+i,n+i+1,k) || small(n-i,n-i-1,k)) return 1;
	}
	return small(1,1,k);//没有重合的特判
}

int main(){
	n=read();
	for(int i=1;i<=2*n-1;i++){
		a[i]=read();
	}
	int l=1,r=2*n-1,ans;
	while(l<r){//二分判断
		int mid=l+r>>1;
		if(check(mid)) {
			r=mid;
		}
		else l=mid+1;
	}
	cout<<r;
	return 0; 
}

```

总结，一道二分贪心题，需要一定的手推过程找到规律。

---

## 作者：WeLikeStudying (赞：45)

- 有比正解时间复杂度更优的线性解法！值得一看！

**题意**
- [题目链接](https://www.luogu.com.cn/problem/AT2165)。
- 给定一个数字金字塔，底层有 $2n-1$ 个数，分别是 $1$ 到 $2n-1$ 的一个排列，逐次减 $2$，顶层有 $1$ 个数。
- 每个方格内的数是正下，左下，右下的三个数的中位数。
- 求最上面方格的数字。

**分析**
- 首先可以二分答案，然后问题变成只有 $0,1$ 的情况，然后我们就写个关于 $0,1$ 的 $O(n^2)$ 暴力求解找规律。
- [实验程序和探究结论](https://www.luogu.com.cn/paste/h75767rv)。
- 通过这个实验程序的辅助，我们找到了 $O(n)$ 判定 $01$ 情况的做法，那么通过二分，我们也找到了 $O(n\log n)$ 判定一般情况的做法，代码实现不算困难。
- [代码实现](https://www.luogu.com.cn/paste/uxlxi68l)。

**拓展**
- 学过二分的都知道二分答案有个重要的思想：去二分化。
- 其大概意思就是二分虽好，可以大大简化问题，方便性质的发现，但是时间复杂度会增加一个 $\log$，有的时候跑一个 $\log$ 未必轻松，所以我们可以先用二分找到一个问题的较好解法，然后根据这个性质，将二分改为扫描，尝试用另一种方法动态维护这个性质，复杂度就会降低一个 $\log$。
- 我们首先对输入进行计数排序，然后逐个从小到大加入，情况与 $01$ 类似（可以理解成一堆 $1$，按照顺序逐个把它们变成 $0$）。
- 根据我们之前发现的性质，如果加入这个数字位置的 $0$ 之后，第一次使得所有奇数位置上全都是 $0$，或者使得有两段连续的 $0$ 比两段连续的 $1$ 更靠近中间，那么这个数字就是答案。
- 这显然是可以均摊 $O(1)$ 维护的，双指针维护最靠近中心的连续 $1$ 的位置均摊复杂度是对的，开个数组维护奇数位置上的 $1$ 的个数，每次答案的时候都 $O(1)$ 更新最近的连续 $0$ 的个数……总之都是基础的普及难度的操作。
- 说句实话，这么简单的线性方法，以各位的智商，想到是不困难的，但区别就在于愿意不愿意，虽然各位或许都比我强，但我仍然希望各位多思考，或许也有不一样的收获呢。
- [代码实现](https://www.luogu.com.cn/paste/67ng1tqu)，代码实现也很简单。

**再拓展**
- [这篇](https://www.luogu.com.cn/discuss/332142)提到的问题，为什么有的二分不能处理一般情况？题解似乎并没有用到排列的性质。
- 我给出的回答是：错误的原因是因为数据值域不连续，将数据离散化就可以了，为什么？

---

## 作者：ezoiLZH (赞：10)

## 题解：

我还是太蒟了，没有想到能二分答案……

我们二分塔顶的值，把小于等于这个值的变为1，大于变为0。

我们可以发现如果有多个个1或0连在一起，那么他们就无法被分开，他会一直往上走。

那也就是说，最后那组先走到顶那组就赢了，那就要看那组离中心更近。

那会不会存在两个不同阵营的组距离一样远能，你会发现这是不可能的。

因为，如果距离相等，那么中间一定是奇数个位置，我们用1和0,交替隔开两组，那么最后一个位置肯定会和左边或者右边一样，又形成一个组，所这两个组要么都是1，要么都是0。

解决了这些问题就能愉快的判断了！

## CODE：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n,a[200005];

inline bool check(const int &k){
	if((a[n-1]<=k&&a[n]<=k)||(a[n]<=k&&a[n+1]<=k))return 1;
	if((a[n-1]> k&&a[n]> k)||(a[n]> k&&a[n+1]> k))return 0;
	for(int i=1;i<n-1;i++){
		if((a[n+i]<=k&&a[n+i+1]<=k)||(a[n-i]<=k&&a[n-i-1]<=k))return 1;
		if((a[n+i]> k&&a[n+i+1]> k)||(a[n-i]> k&&a[n-i-1]> k))return 0;
	}
	return a[1]<=k;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<n<<1;i++)scanf("%d",a+i);
	int l=1,r=(n<<1)-1;
	while(l<r){
		int mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%d",l);
}
```
挺短的把……

---

## 作者：tzc_wk (赞：5)

[Atcoder 题面传送门](https://atcoder.jp/contests/agc006/tasks/agc006_d) & [洛谷题面传送门](https://www.luogu.com.cn/problem/AT2165)

~~u1s1 Atcoder 不少思维题是真的想不出来，尽管在 Atcoder 上难度并不高~~

二分答案（这我倒是想到了），检验最上面一层的数是否 $\ge x$。

我们将最底下一层的数中 $\ge x$ 的 $a_i$ 设为 $1$，$<x$ 的设为 $0$，那么原题可以转化为每次操作对于相邻三个数，如果 $1$ 的个数 $\ge 2$，就在该位上填一个 $1$，否则在该位上填一个 $0$，求最终顶上的数是 $0$ 还是 $1$。

不难发现经过二分答案这个转化，我们将原来值域在 $[1,2n-1]$ 范围内的问题缩小为值域在 $[0,1]$ 范围内的问题，可直接做似乎还是有些棘手，我们不妨进一步探究这里面的规律。

我们手玩几组数据即可发现一个性质，如果相邻两个数都是 $1$，那么它上面所有数都是 $1$，反正如果相邻两个数都是 $0$，那么它上面所有数都是 $0$，并且如果 $i$ 满足 $a_{i}=a_{i+1}=a_{i-2}=1$，那么到了上一层第 $i-1$ 列也会变成 $1$，可以看作这个 $1$ “蔓延”到了第 $i-1$ 列，于是我们猜测，第 $n$ 层的数一定与距离中心点最近的 $a_{i}=a_{i+1}$ 的 $i$ 有关，因为它能最快“蔓延”到第 $n$ 列。

事实果真如此。

这里稍微证明一下。记 $i=n+p$ 为距离中心点最近的满足 $a_i=a_{i+1}$ 的 $i$，其中 $p\ge 0$（$p<0$ 也同理，翻转一下就行了），如果 $p=0$ 那显然根据之前的结论，第 $n$ 列的数就是 $a_n$，符合题意。否则，由于 $i=n+p$ 为最近的满足 $a_i=a_{i+1}$ 的 $i$，必然有 $[n-p,n+p]$ 部分的 $a_i$ 为 $01$ 间隔分布，即 $a_{n+p-2}=a_{n+p-4}=a_{n+p-6}=\cdots=a_{n-p+2}=a_{n-p}=a_{n+p}$，$a_{n+p-1}=a_{n+p-3}=a_{n+p-5}=\cdots=a_{n-p+1}=1-a_{n+p}$，由 $a_{n+p-2}=a_{n+p}=a_{n+p+1}$ 可知从下往上数第二行第 $n+p-1$ 位置上的值也是 $a_{n+p}$，相当于 $a_{n+p}$ 向左蔓延了一格。而显然对于 $01$ 分布的序列，进行一遍取中位数操作之后还是 $01$ 间隔分布的，因此到第二行可以看作 $p'=p-1$ 的版本继续递归下去，归纳可得最终的数就是 $a_{n+p}$。

有人可能会问：如果存在 $p$ 使得 $i=n+p$ 为距离中心点最近的满足 $a_i=a_{i+1}$ 的 $i$，满足 $a_{n+p}=a_{n+p+1}\ne a_{n-p}=a_{n-p-1}$ 怎么办呢？稍微动点脑子即可知道这种情况是不可能的，因为根据上面的证明过程可知 $[n-p,n+p]$ 是 $01$ 间隔分布的，因此 $\forall x,y\in[n-p,n+p]$，若 $|x-y|$ 为偶数，则 $a_x=a_y$，反之 $a_x\ne a_y$，而 $n-p\equiv n+p\pmod{2}$，故 $a_{n-p}=a_{n+p}$，因此不会出现这种情况。

最后特判整个 $a$ 数组就是 $01$ 间隔分布的情况，此时最上面一层的数就是 $a_{2n-1}$。

```cpp
const int MAXN=1e5;
int n,a[MAXN*2+5],b[MAXN*2+5];
bool check(int x){
	for(int i=1;i<(n<<1);i++) b[i]=(a[i]>=x);
	for(int i=0;i<n-1;i++){
		if(b[n+i]==b[n+i+1]) return b[n+i];
		if(b[n-i]==b[n-i-1]) return b[n-i];
	} return b[1];
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<(n<<1);i++) scanf("%d",&a[i]);
	int l=1,r=(n<<1)-1,mid,x=-114514;
	while(l<=r) (check(mid=l+r>>1))?(x=mid,l=mid+1):(r=mid-1);
	printf("%d\n",x);return 0;
}
```



---

## 作者：yixinxiangxue172 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/AT2165)

------------

### solution

我们需要求的是每组的中位数，所以记录大小关系是很重要的（~~废话~~。

对于一个数字 $x$，记录在塔底的数列中，每一个 $a_i$ 是否小于等于 $x$，如果小于等于 $x$ 则为 $0$，大于 $x$ 则为 $1$，这样就得到了一个 $01$ 序列。

以样例为例，当 $x$ 为 $3$ 时序列是 $0,1,0,1,1,1,0$。很明显下面的三个数有 $110$，$001$，$111$，$000$的可能。取中位数时，一定得到的是出现得多的数，然后在 $110$ 中取到 $1$，$001$ 中取到 $0$。

把这个性质向上推，就有一种情况：当 $a_i$，$a_{i+1}$ 为 $1$，上一行的 $i$，$i+1$ 也为 $1$。
 
可以知道只要一直往上推，直到塔尖，这个性质依然适用。那么有这么多的 $11$，$00$，只要谁离中间点最近，它就可以"走"到塔尖，塔尖的 $01$ 值与它相等。

那怎样找到这个 $x$ 呢？可以枚举。想到枚举，就可以想到二分。注意，我们应该用用数组下标（即数字组合）来二分才对。

------------

### code


```cpp
#include <cstdio>
#include <cstring>
int N, Ans, A[200001], B[200001];

namespace S {
	inline bool Min(int w1, int w2, int d) {
		return A[w1] <= d && A[w2] <= d;
		//两个是否都是小于等于当前值 
	} 

	inline bool Max(int w1, int w2, int d) {
		return A[w1] > d && A[w2] > d;
		//两个是否都是大于当前值 
	}

	inline int check(int x) {
		int Mid = N / 2 + 1; //中间点（塔顶对于塔底数列是第几个）
		for(int i = 0; i < Mid - 1; i ++) {
			/*
			   制作 01 序列：从中间往边上找有没有 00 或 11
			   就可以找到最靠中间的两个相同的，像解释中那样
			*/
			if(Max(Mid - i, Mid - i - 1, x) || Max(Mid + i, Mid + i + 1, x)) {
				return 1;
			}
			if(Min(Mid - i, Mid - i - 1, x) || Min(Mid + i, Mid + i + 1, x)) {
				return 0;
			}
		}
		return !(A[1] <= x);
		//特判没有 00 , 11 时的情况，此时易得塔顶应为第一个或最后一个 0 或 1
	}

	inline int read() { //读入优化 
		int cnt = 1, res = 0;
		char ch = getchar();
		while(ch < '0' || ch > '9') {
			cnt = ch == '-' ? -1 : 1, ch = getchar();
		}
		while(ch >= '0' && ch <= '9') {
			res = res * 10 + (ch ^ 48), ch = getchar();
		}
		return res * cnt;
	}

	inline void print(int x) {
		if(x < 0) putchar('-'), x = -x;
		x > 9 ? print(x / 10), putchar((x % 10) ^ 48) : putchar((x % 10) ^ 48);
	}

	inline void Erfen() { //二分寻找 x 作为候选答案
		int l = 1, r = N; //因为 N 已是 N * 2 - 1，所以 r 直接赋值为 N
		while(l < r) { //因为要求的是最后一个小于等于的，所以是用右标记查找
			int Mid = (l + r) / 2; //二分查找中的中间值
			int p = check(Mid); //判断塔顶答案是否比 x 大
			if(p == 0) {
				r = Mid;
			} else {
				l = Mid + 1;
			}
		}
		print(r); //找到答案，输出
	}
}
using namespace S;

int main(int argc, char const * argv[]) {
	memset(B, 127, sizeof(B)); //赋值为无穷大
	N = read() * 2 - 1; //读入 N 的值  
	for(int i = 1; i <= N; i ++) {
		A[i] = read();
	}
	Erfen(); //直接二分 
	return 0; //完美的结束 
} 
```

------------


### tips

如果一个 $11$，$00$ 都没有出现，要特判塔尖应改为最左边，还是最右边那个值？~~（想一想~~。

---

## 作者：言琢დ (赞：4)

考虑使用二分优化选数过程。

记 $x\le mid$ 为 0，$x>mid$ 为 1.

最终得到的数列形如

$$\color{blue}01010\color{red}11\color{blue}0101$$

考虑找到最靠中间的“一对” 0 或者 1.

它们的即是最后在顶上方的那个数字。

考虑证明一下：

我们选择中位数的时候，无非四种情况：

- `0 0 0`
- `0 0 1`
- `0 1 1`
- `1 1 1`

而这四种情况中，出现次数最多的数码一定被选出来。

那么考虑相邻的“一对” 0 或者 1，相当于投票，我给你投一票，你也给我投一票，咱们俩手牵着手就上去了。

但是有多对相同的数的时候，边上的数有时候被强行合并上去，不能再接着帮忙投票。

所以最靠近中间的位置最佳也就不难证。

本篇题解主要是把二分之后检验的过程说明白一点，代码和外面的二分参见其他已有题解即可。

---

## 作者：幻影星坚强 (赞：1)

提供一种不同的理解方法

同样是二分答案，将所有大于等于该数的设为1，其余设为0，之后就变成了只有零和一的一个序列。

对于一般情况，即没有数的相邻两个都与自己不一样，它的结果会如下面：

```
    1
   111
  01111
 0011111
000111111
```
所有的数字都不会发生改变，所以唯一需要考虑的仅为相邻两个都和自己不同的情况，然后我们发现对于一整个相邻两个都和自己不同的区间，它的过程都是将这整个区间异或1，之后这个区间的左右端点都向内移一位，于是就有了如下发现：

- 1.长度为奇数

```
     0
    000          <-没了
   00100         <-5~5  
 0 01010 0       <-4~6
00 10101 00      <-3~7

```
比如这组数据第三到第七个数字均与其相邻不同，然后我们发现这个区间最后都会变成0，而它正是这个区间的第一个数异或1。所以对于每种长度为奇数的这样的区间我们都可以将其变为区间第一个数异或1来代表他们的最终状态。

- 2.长度为偶数

```
     1
    110
  1 1100         <-没了
 11 1010 0       <-5~6
111 0101 00      <-4~7

```
比如这组数据第四到第七个数字均与其相邻不同，我们发现这个区间的左半边最后变成了1，右半边最后变成了0，所以对于长度为偶数的区间我们将左半边设为开头的数异或1，后半边设为结尾的数异或1，来代表他们的最终状态。

如果不懂可以手玩一下，~~或者问下我~~。

然后我们就求出了所有位置的最终状态，此时顶上的数就是最中间的数了

```
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1e5 + 10;
int n;
int a[N << 1];
int vis[N << 1];
bool check(int x)
{
    for (int i = 1; i <= 2 * n - 1; ++ i)
    vis[i] = (a[i] >= x);
    int be = 0;
    for (int i = 2; i < 2 * n - 1; ++ i)
    {
        if(vis[i - 1] != vis[i] && vis[i + 1] != vis[i])
        {
            if(be == 0)
            {
                be = i;
            }
        }
        else
        {
            if(be != 0)
            {
                int tot = 0, len = i - be, op = vis[be] ^ 1;
                if(len & 1)
                for (int j = be; j < i; ++ j)
                vis[j] = op;
                else
                for (int j = be; j < i; ++ j)
                {
                    ++ tot;
                    vis[j] = op;
                    if(tot == (len + 1) >> 1)
                    op ^= 1;
                }
                be = 0;
            }
        }
    }
    if(be != 0)
    {
        int i = 2 * n - 1;
        int tot = 0, len = i - be, op = vis[be] ^ 1;
        if(len & 1)
        for (int j = be; j < i; ++ j)
        vis[j] = op;
        else
        for (int j = be; j < i; ++ j)
        {
            ++ tot;
            vis[j] = op;
            if(tot == (len + 1) >> 1)
            op ^= 1;
        }
        be = 0;
    }
    return vis[n];
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= 2 * n - 1; ++ i)
    {
        scanf("%d", &a[i]);
    }
    int ans = 1;
    int l = 1, r = 2 * n - 1;
    for(int mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1)
    {
        if(check(mid))
        ans = mid, l = mid + 1;
        else r = mid - 1;
    }
    printf("%d\n", ans);
}

```


---

## 作者：弦巻こころ (赞：1)

这道题思路非常的巧，要不是看了标签是二分答案可能还真想不到

首先，由于我们求得是中位数，中位数因为它求得是数值在中间的数，所以我们不必记录每个数的大小，只需记录它们的**相对大小**。 

我们可以二分答案并在每次$check$时将数组处理为$01$串 ，小于等于这个数的设为$0$，大于等于这个数的设为$1$。

我们在考虑怎么在$O$($n$)内进行$check$，首先我们可以想到，当有连续的两个$0$或连续的两个$1$时**只要它不贴着边缘**就一定能传到上面去。

举个例子

```
    1 
  0 1 1
0 0 1 1 0
```
这里的 两个$1$连续且不挨着边，就有两个$1$传了上去，但这里连着的两个$0$虽然连续，但贴着边，就只能传$1$个$0$上去

那怎么保证有一组$0$或$1$一路不碰边到最上层呢。

答案是：最靠近中间的那一组。

我们就可以得出结论，只要有两个连续的$1$或$0$，它们且最靠近中间那么最上面的数一定是它。

但是有一个问题：会不会有两组不相同的$0$ $1$里中间一样远。

答案是：不可能

我们假设有这种情况

因为如果你搜到这里了，中间一定是$01$交替的串组成

这是如果有两组连续的$0$或$1$，里中间一样远，那么其中一个**一定在上一个位置就搜到了**，所以这种情况不存在

举个例子
```
0 0 1 0 1 1 1 
0 0 0 1 0 1 1 
```
这里的有两组连续的$0$，$1$离中间一样远，但因为中间是$101$或$010$

就有一组在上一位就被搜到，所以不可能存在。

最后因为有可能会有全程$01$交替的存在故需要特判

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[400005],n;
int small(int i,int k)
{
	return a[i+1]<=k&&a[i]<=k;//判断小于等于 
}
int big(int i,int k)
{
	return a[i+1]>k&&a[i]>k;//判断大于
}
int check(int k)
{
	for(int i=0;i<=n-1;i++)//从中心开始看是否有两个连续的1或0
	{
		if(small(n+i,k)==1||small(n-i-1,k)==1)//如果小于等于k的数在最上面
		{
			return 1;
		}
		if(big(n+i,k)==1||big(n-i-1,k)==1)如果大于k的数在最上面
		{
			return 0;
		}
	}
   //特判 全是01交替的情况 
	if(a[1]<=k)
	{
		return 1;
	}else
	{
		return 0;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=2*n-1;i++)
	{
		scanf("%d",&a[i]);
	}
	int l=1,r=2*n-1;//这里r是2*n-1
	while(l<r)//二分答案
	{
		int mid=(l+r)>>1;
		if(check(mid)==1)
		{
			r=mid;
		}else
		{
			l=mid+1;
		}
	}
	cout<<r;
	return 0;
}
```


---


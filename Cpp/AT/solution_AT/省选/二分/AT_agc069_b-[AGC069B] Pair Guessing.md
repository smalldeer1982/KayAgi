# [AGC069B] Pair Guessing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc069/tasks/agc069_b

$ N $ 個の、長さ $ N $ の $ 01 $ 文字列 $ S_1,\ldots,S_N $ が与えられます。$ S_i $ の $ j $ 文字目を $ S_{i,j} $ と表します。ここで、$ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在することが制約より保証されています。

高橋君と青木君が以下のようなゲームを行います。

1. 高橋君が $ 1\ \leq\ i,j\ \leq\ N,\ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ を $ 1 $ つ選ぶ。
2. $ 0 $ 回以上 $ N $ 回以下、青木君が高橋君に質問を行う。各質問では青木君が $ 1\leq\ i',j'\ \leq\ N $ を満たす整数組 $ (i',j') $ を選び、「$ i=i' $ と $ j=j' $ のうち少なくとも一方が成り立つ」の真偽を高橋君から教えてもらう。
3. 青木君が $ (i,j) $ を予想する。予想が当たっていれば青木君の勝ち、そうでなければ負けとなる。
 
青木君は高橋君が選ぶ $ (i,j) $ の候補、すなわち $ S_1,\ldots,S_N $ を知った状態でゲームを行います。また、上記2では以前の質問に対する返事を聞いたうえで $ (i',\ j') $ を選ぶことができます。

青木君が適切な戦略を取った場合、高橋君の $ (i,j) $ の選び方や運によらず必ずゲームに勝てるかどうかを判定してください。

$ 1 $ つの入力につきテストケースは $ T $ 個あります。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 500 $
- $ 1 $ つの入力の中のテストケースすべてにわたる $ N^2 $ の総和は $ 500^2 $ 以下である
- $ S_i $ は長さ $ N $ の $ 01 $ 文字列
- $ S_{i,j}=\ $ `1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在する
 
### Sample Explanation 1

$ 1 $ 番目のテストケースに対するゲームの一例を以下に示します。 1. 高橋君が $ S_{i,j}=\ $`1` を満たす $ (i,j) $ として $ (2,2) $ を選ぶ。 2. 青木君が $ 2 $ 回質問を行う。$ 1 $ 回目の質問では $ (i',j')=(1,1) $ として、高橋君から「$ i=1 $ と $ j=1 $ のうち少なくとも一方が成り立つ」が偽であると教えてもらう。$ 2 $ 回目の質問では $ (i',j')=(2,2) $ として、高橋君から「$ i=2 $ と $ j=2 $ の少なくとも一方が成り立つ」が真であると教えてもらう。 3. 青木君が $ (i,j)=(2,2) $ と予想する。この予想は当たっているため、青木君の勝ちである。 これはあくまでゲームの一例であり、青木君の戦略が適切とは限りません。しかし、青木君が適切な戦略を取った場合には必ず青木君がゲームに勝つため、$ 1 $ 番目のテストケースに対する出力は `Yes` になります。

## 样例 #1

### 输入

```
3
2
01
11
2
11
11
10
0101011110
1100100001
1101100000
0111101010
1000011001
1110101010
1110110100
1110000110
0000001011
1001111100```

### 输出

```
Yes
No
Yes```

# 题解

## 作者：Eraine (赞：5)

编号：AT_agc069_b  
tag：Ad-hoc  
难度：$\color{red}{2859}$

首先不难注意到必然有一段询问前缀（可以为空）为 $0$，那么这些行列都是没有用的。

当第一次碰到 $1$ 的时候，意味着要在两个长为 $x$，宽为 $1$ 的矩形横竖拼起来的十字架中用 $x-1$ 操作中找到关键点。当且仅当十字架上的元素全为 $1$ 无解，否则有解，可以转化为是否有 $0$。重新考虑问题。转化为在一个 $n\times n$ 上依次执行 $n-1$ 次如下操作的可行性：

- 找到当前剩余网格图中的某一个点，假设为 $(i,j)$，要满足 $(i,j^\prime)$ 和 $(i^\prime,j)$ 中至少有一个为 $0$。
- 删除第 $i$ 行和第 $j$ 列，剩下的部分按原正方形位置重新拼成小正方形。

那么这样的问题显然是建关于 $0$ 的二分图后 $2n-\sum block\ge n-1$ 的合法性。可以用并查集维护。但是我们提交上去，是：

![](https://cdn.luogu.com.cn/upload/image_hosting/sxxiospf.png)

为什么呢？

我们重新审视一下思维过程，发现对于 $\text{Yes}$ 的判断不是必要的。对于上述条件只是 $\text{Yes}$ 的一个充分条件，而非必要。我们会发现上述判断过程有两个漏洞，分别是一次操作只能检验行列分别一个元素以及没有利用之前检测过不合法的行列。对于这个样例：

```
011
111
111
```

显然有解，先测左上角的 $0$，如果不存在，则测 $(1,2),(2,1)$，由于只有两行两列，所以行列的状态只能为 $0/1$。也可以找到解。所以应该是检测 $2n-\sum block\ge n-2+[n=2]$ 的合法性。

$\Theta(\sum n^2)$。

[submission](https://atcoder.jp/contests/agc069/submissions/60163539)

若有疑问和错误请指出，虚心接受您的意见。

---

## 作者：gdf_yhm (赞：0)

[agc069b](https://www.luogu.com.cn/problem/AT_agc069_b)

[my blog](https://yhddd123.github.io/post/agc069b-ti-jie/)

### 思路

取两个排列 $p,q$。假设第一步问 $(p_1,q_1)$ 返回是，接下来问 $(p_2,q_2),\dotsb,(p_i,q_i),\dotsb,(p_{n-1},q_{n-1})$。如果某一步问到了是，就再一步把 $(1,q_i),(p_i,1)$ 分出来。最后剩一个问题和 $(p_1,q_1),(p_1,q_n),(p_n,q_n)$，此时三个位置要求至少存在一个 $0$。如果第一步问 $(p_1,q_1)$ 返回否，删掉 $i=p_1$ 和 $j=q_1$ 一行一列进入 $n-1$ 的子问题。当 $n=1$ 时合法。

等价于 $n-1$ 次删掉一行一列，要求这一行一列中至少有一个 $0$。套路的对每个 $a_{i,j}=0$ 连边 $(i,j+n)$。对于每个连通块，找出一颗生成树，从叶子开始连起，最后根不要了，即能找出 $siz-1$ 对一行一列。如果 $\sum siz-1 \ge n-1$ 就合法了。

然后写出来发现 WA $18$ 个点就破防了！特别的，当 $n>2$ 且去到了 $n=2$ 的全 $1$ 矩阵，剩两个问题时，可以问矩阵以外的位置排除一行或一列，所以 $n>2$ 时，$\sum siz-1\ge n-2$ 就合法了。

### code

```cpp
int n;
char s[maxn];
int a[maxn][maxn];
int f[maxn<<1],siz[maxn<<1];
int fd(int x){
	if(f[x]==x)return x;
	return f[x]=fd(f[x]);
}
void work(){
	n=read();
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=n;j++)a[i][j]=(s[j]=='1');
	}
	for(int i=1;i<=n*2;i++)f[i]=i,siz[i]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)if(!a[i][j])f[fd(i)]=fd(j+n);
	}
	for(int i=1;i<=2*n;i++)siz[fd(i)]++;
	int ans=0;
	for(int i=1;i<=2*n;i++)if(fd(i)==i)ans+=siz[i]-1;
	if(ans>=n-1||(n>2&&ans>=n-2))puts("Yes");
	else puts("No");
}
```

---

## 作者：complete_binary_tree (赞：0)

考虑小数据时答案的情况。$N=1$ 显然无解，$N=2$ 时只要有 $0$ 就有解。

注意到这样的数据：

```
2
0 1
1 1
```

可以先询问除（第二行与第二列）外的任何区域都一定能求得答案。

于是猜想每一次询问都要包含一个 $0$。

此时考虑 $N>2$ 的情况：

- 如果高桥在这个询问的十字形上：

  此时每次询问可以确定两个 $1$ 是否是高桥的位置，这样可以通过至多 $N-2$ 次询问把范围缩小到两个位置；然后再进行一次询问就能确定高桥的位置。

- 如果高桥不在这个询问的十字形上：

  那么可以看成“删去”这一行和这一列，变成 $N-1$ 的子问题，然后重复以上操作。

发现一个位置是 $0$ 可以使这一行或这一列被选上，且一旦被选必影响一行或一列，所以当一个位置是 $0$ 的时候考虑令其所在行列连上无向边得到一个二分图，那么最后只需选 $N-2$ 条边使得其中不出现环即可。（出现环了那么至少一行或一列会被选两次）这可以用并查集做。

为什么只需要选 $N-2$ 条边而不是 $N-1$ 条边呢？手模一下可以发现 $N > 2$ 的时候如果只剩两行两列一定能判完（因为可以选择除这两行列以外的列让一次只选两个位置），如果判 $N-1$ 的话这东西就会判错~~喜提罚时*1~~。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
int fa[N<<1],t,n,ans,x,y;
char ch;
inline void csh(int n){for(int i=1;i<=n;++i)fa[i]=i;}
int get(int n){return n==fa[n]?n:fa[n]=get(fa[n]);}
int main() {
    ios::sync_with_stdio( 0 ), cin.tie( 0 ), cout.tie( 0 );
    for(cin>>t;cin>>n,t--;){
        ans=0,csh(n<<1);
        if(n<=2){
            if(n==1){cin>>n;cout<<"Yes\n";}
            else{
                cin>>x>>y;
                if(x==11&&y==11)cout<<"No\n";
                else cout<<"Yes\n";
            }
            continue;
        }
        for(int i=1;i<=n;++i)for(int j=1;j<=n;++j){
            cin>>ch;
            if(ch=='0'&&get(i)!=get(n+j))fa[get(i)]=get(n+j),++ans;
        }
        if(ans<n-2)cout<<"No\n";
        else cout<<"Yes\n";
    }
    return 0;
}
```

---


# [ABC329G] Delivery on Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc329/tasks/abc329_g

$ N $ 頂点の二分木が与えられます。 頂点には $ 1 $ から $ N $ までの番号が付けられており、頂点 $ 1 $ が根です。 $ i\ (1\leq\ i\ \leq\ N-1) $ 番目の辺は、頂点 $ i+1 $ と頂点 $ P_i\ (\leq\ i) $ を双方向に結んでいます。

この木の上には $ 1 $ 個のカゴと $ M $ 個のボールがあります。 ボールには $ 1 $ から $ M $ までの番号が付けられており、各ボール $ j $ について**スタート頂点** $ S_j $ と**ゴール頂点** $ T_j $ が定められています。 最初、カゴは空の状態で頂点 $ 1 $ に置かれており、ボールはそれぞれのスタート頂点に置かれています。

あなたは、以下の操作を好きな回数、好きな順序で行うことができます。

- 今カゴが置かれている頂点を $ v $ として、以下のいずれかを行う。
  - 頂点 $ v $ に繋がる辺を $ 1 $ つ選び、カゴをその辺に沿って動かして隣接する頂点に移動させる。 このとき、カゴの中に入っているボールも一緒に移動する。
  - スタート頂点が $ v $ であり、今もスタート頂点に置かれているようなボールを $ 1 $ つ選んで、カゴの中に入れる。 この操作は、元々カゴの中に入っているボールが $ K $ 個未満である場合にのみ行える（すなわち、カゴの中に $ K+1 $ 個以上のボールを入れることはできない）。
  - ゴール頂点が $ v $ であり、今カゴの中に入っているようなボールを $ 1 $ つ選んでカゴから取り出し、頂点 $ v $ に置く。
 
全ての操作が終了した時点で、カゴは空の状態で頂点 $ 1 $ に置かれており、ボールはそれぞれのゴール頂点に置かれているような操作列を**良い操作列**と呼びます。

カゴを何度も動かすのは疲れるので、カゴが動く経路は、全ての辺をちょうど $ 2 $ 回ずつ通り頂点 $ 1 $ に戻ってくるようなものに限定したいです。 そのような経路のうち、その経路に従ってカゴを動かす良い操作列が存在するようなものの数を $ 998244353 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 10^4 $
- $ 1\leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ K\ \leq\ 10^3 $
- $ 1\leq\ P_i\ \leq\ i $
- 全ての $ v\ (1\leq\ v\ \leq\ N) $ について、$ P_i=v $ を満たす $ i $ の数は高々 $ 2 $ 個
- $ 1\leq\ S_j,\ T_j\ \leq\ N $
- $ S_j\ \neq\ T_j $
- 入力は全て整数
 
### Sample Explanation 1

与えられるグラフは以下の図の通りです。頂点の側に書かれた丸と四角は、それぞれその番号のボールのスタート頂点とゴール頂点を表します。 !\[\](https://img.atcoder.jp/abc329/afa9812169c0c570270c32e5aa1c814a.jpg) 全ての辺をちょうど $ 2 $ 回ずつ通り頂点 $ 1 $ に戻ってくるような経路のうち、その経路に従ってカゴを動かす良い操作列が存在するようなものは以下の $ 1 $ 通りのみです。 !\[\](https://img.atcoder.jp/abc329/b80e2b20635a90cf935fa4bbc89872fd.jpg) 具体的には、以下のような良い操作列を構成できます。 1. カゴを頂点 $ 2 $ に動かす。 2. ボール $ 1 $ をカゴに入れる。 3. カゴを頂点 $ 1 $ に動かす。 4. カゴを頂点 $ 3 $ に動かす。 5. カゴを頂点 $ 4 $ に動かす。 6. ボール $ 1 $ をカゴから出して頂点 $ 4 $ に置く。 7. カゴを頂点 $ 3 $ に動かす。 8. カゴを頂点 $ 5 $ に動かす。 9. ボール $ 2 $ をカゴに入れる。 10. カゴを頂点 $ 3 $ に動かす。 11. ボール $ 2 $ をカゴから出して頂点 $ 3 $ に置く。 12. カゴを頂点 $ 1 $ に動かす。

### Sample Explanation 2

入出力例 1 から $ K $ の値が $ 1 $ 増えています。 これにより、上述した経路に加えて、以下の経路についても良い操作列を構成できるようになります。 !\[\](https://img.atcoder.jp/abc329/31ce5331d578d5f2d0c0fe86751fd60d.jpg)

## 样例 #1

### 输入

```
5 2 1
1 1 3 3
2 4
5 3```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2 2
1 1 3 3
2 4
5 3```

### 输出

```
2```

## 样例 #3

### 输入

```
15 4 2
1 2 1 4 2 3 4 7 3 7 5 9 11 8
14 12
5 4
13 15
5 12```

### 输出

```
8```

# 题解

## 作者：irris (赞：14)

## Preface

噗叽 T4 难度。感觉如果给点 $N = 15$ 的中样例是不是就很好做啊？写了个拍子立马调出来了，原神启动。

![](https://cdn.luogu.com.cn/upload/image_hosting/fyk5u8b2.png)

## Problem

给出 $N$ 个节点的 **二叉树**，有 $M$ 个球和对应的目标（对于第 $i$ 组，球在 $s_i$ 节点，目标在 $t_i$ 节点）。你需要用一个篮子遍历整棵树，使得：

- 起止位置都是点 $1$，每条边经过 $= 2$ 次；
- 在某些时刻你可以把某个球从起始位置拿起，在某些时刻你可以把某个球放到它对应的目标位置。球不能在中途的任何位置被放下或重新拿起。
- 要求任意时刻篮子里有 $\leq K$ 个球。

求不同的遍历方案数，答案对 $998244353$ 取模。

$1 \leq N \leq 10^4$，$1 \leq M \leq 2\times 10^5$，$1 \leq K \leq 10^3$。

## Solution

我们考虑每条边经过恰好两次，这其实就是 **dfs 整颗树**。

那么不同的遍历方案就相当于，要求 **安排每个儿子数恰好为 $2$ 的顶点的儿子 dfs 顺序**。

我们考虑如果决定了这个遍历顺序怎么计算答案。一个很臭的想法是 dfs 出来顺序，然后先判一下这个顺序是不是合法的（是不是存在一个 $s_i$ 走不到 $t_i$），然后再对于篮子里的球数区间加，查一下全局最大值（差分实现即可）。这个是我的对拍暴力写法，但这实在是太臭了，根本没有可拓展性。

![](https://cdn.luogu.com.cn/upload/image_hosting/2q71b5ii.png)

好吧，我们看一个更愚蠢的想法：我们考虑下界，其实就是 **每个 $s_i$ 能够中间不绕任何路，直接走到 $t_i$ 位置**，然后这个时候如果都不合法（也就是中间有一个过程篮子里球数 $\geq k + 1$）那就无解。但是如果这看起来合法怎么办？

且慢，这个时候我们不知道 dfs 序，所以我们怎么模拟出篮子里的球数？（下文，我们先把这个在边上的量转化到在点上，也就是记录在它的深度较大的端点上）。**我们考虑一个球的运送过程**，它应该先是 $s \to \text{lca}(s, t)$ 向上再是 $\text{lca}(s, t) \to t$ 向下。

对于某一条特定的边 $u$（我们这里设 $u$ 是它深度较大的那个端点，也就是符合上面的定义），那么显然经过它一定要一个端点在 $u$ 的子树内，一个端点在 $u$ 的子树外。也就是说，

- 如果向下经过它，一定会在 $u$ 的子树内某个时刻丢下这个球；
- 如果向上经过它，一定会藉由它走出 $u$ 的子树。

所以这是一个祖先-后代链加，树上差分求出 $L_1(u)$ 和 $L_2(u)$ 分别表示向上经过 $u$ 和向下经过 $u$ 的路径数量，**那么经过边 $u$ 的所有时刻，篮子中最大球数就是 $L_u = \max(L_1(u), L_2(u))$**。注意这里不要误解成为 $L_1(u) + L_2(u)$，虽然莫名其妙能过样例 /wq。

然后我们考虑，如果绕了路会怎样？画一张图解释一下。

举个例子，这里有一棵可爱的完全二叉树：

![](https://cdn.luogu.com.cn/upload/image_hosting/gdehdbc6.png)

假如我们要在这棵树上从 $4$ 走到 $6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ya8152po.png)

显然，无论如何这个球不会影响 $4$ 和 $6$ 的子树，因为我们总可以在最后离开 $4$ 的时候拿起这个球，在第一次到达 $6$ 的时候放下这个球。

但是节点 $2$ 呢？如果我们在遍历 $5$ 之前先遍历了 $4$，那么这个球就会在 $5$ 的子树内转一个大圈，整整把里面的所有边上下都遍历一遍。对于节点 $3$ 同理，如果我们后遍历 $6$，那么球会在 $7$ 的子树内转一圈！

我们发现了一个好东西：这是以子树为单位的 $L$ 增加。但在这之前，我们先找到这个增加量：设 $c_1(i)$ 表示，如果点 $i$ 在 dfs 时被第一个遍历，那么被第二个遍历的兄弟（如果存在）的子树内 $L$ 会多多少贡献；$c_2(i)$ 同理。这同样是祖先-后代链加，也就是说：

- 对 $s$ 到 $\text{lca}(s, t)$ 的下端（**不包含 $\text{lca}(s, t)$**）进行 $c_1$ 的链加 $1$；
- 对 $t$ 到 $\text{lca}(s, t)$ 的下端（**不包含 $\text{lca}(s, t)$**）进行 $c_2$ 的链加 $1$。

同样使用树上差分解决。

现在的形式就显得就很好了，考虑 dp，设 $dp_{i,j}$ 表示，点 $i$ 的子树内，$\max(L_u) = j$ 的方案数。没有提到的 dp 初始值均为 $0$。

- 若点 $i$ 为叶子，那么 $dp_{i,L_i} = 1$。
- 若点 $i$ 有且仅有一个儿子 $u$，那么 $dp_{i,\max(L_i, j)} \gets^+ dp_{u,j}$。
- 若点 $i$ 有两个儿子 $u, v$。枚举哪个是第一个遍历的，不失一般性设为 $u$，剩余情况对称：
	- $dp_{i,\max(j + c_2(v), k + c_1(u))} \gets^+ dp_{u,j}\cdot dp_{v,k}$。
	- 直接实现复杂度是 $\mathcal O(NK^2)$ 的，不可接受。
	- 不妨设 $j + c_2(v) \geq k + c_1(u)$，那么这个时候枚举 $j$，对 $dp_{v,k}$ 做 **前缀和** 即可。另一种情况也是对称的，注意不要把等于号算两遍。
	- 时间复杂度 $\mathcal O(NK)$。

但是这真的对吗？回忆起暴力做法里我们有判一个无解：如果从 dfs 序上推断 $s$ 走不到 $t$，直接无解。这里我们也要同样考虑：对于一个 $s \to t$ 的 **非祖先-后代链上** 要求，我们设 $k = \text{lca}(s, t)$。这显然要求 $k$ 的两个子树的 dfs **顺序固定**，否则就不能从含有 $s$ 的子树走到含有 $t$ 的子树上去了。也就是说，我们还要在跳 lca 的时候记录固定关系，然后 dp 转移的时候 chk 一下。特殊地，如果固定关系出现了矛盾，直接输出 $0$ 即可。

做完了？做完了。最终的时间复杂度为 $\mathcal O((N + M)\log N + NK)$。

## Code

看起来感觉代码难度很低（思维难度也很低吧！），为啥我其实写了很久呢，要加训了。

[atcoder 提交记录](https://atcoder.jp/contests/abc329/submissions/47744282)。

![](https://cdn.luogu.com.cn/upload/image_hosting/2od57nnm.png)

---

## 作者：SpadeA261 (赞：2)

可以发现要求的就是可行的 dfs 序的数量，尝试刻画每一对 $(s,t)$ 对其产生的约束。

一个显然的结论是，最优策略是在最后一次遍历 $s$ 时拿取球，在第一次到达 $t$ 时放下球，那么此时必然经过 $\operatorname{lca}(s,t)$。

设 $w=\operatorname{lca}(s,t)$，$w_s$ 表示 $w$ 的儿子中是 $s$ 祖先的结点（可能不存在），$w_t$ 同理。

根据 $w$ 与 $s$ 和 $t$ 的位置关系可以分为三种情况。

- 若 $w=s$，即 $s$ 为 $t$ 的祖先时，这个球会在 $w\rightarrow w_t$ 时放入筐内，并在 $fa_t\rightarrow t$ 时放下。

- 若 $w=t$，即 $t$ 为 $s$ 的祖先时，这个球会在 $w\rightarrow w_s$ 时放入筐内，并在 $fa_s\rightarrow s$ 时放下。

- 若 $w\neq s$ 且 $w\neq t$，这个球会在 $s\rightarrow fa_s$ 时放入筐内，并在 $fa_t\rightarrow t$ 时放下，并且遍历 $w$ 的子树时要先遍历 $w_s$ 一侧。

以上约束可以统一记为 $in_{u,0/1/2}$ 与 $out_{u,0/1/2}$。其中 $in_{u,0/1/2}$ 表示从 $u$ 到左儿子/右儿子/父亲要放入筐内的球的个数，$out_{u,0/1/2}$ 为要拿出的球的个数。

由以上约束可以预处理 $f_{u,i}$，表示若 $fa_u\rightarrow u$ 时筐内有 $i$ 个球，则 $u\rightarrow fa_u$ 时筐内会有 $f_{u,i}$ 个球。

同时可以记录 $dp_{u,i}$，表示若 $fa_u\rightarrow u$ 时筐内有 $i$ 个球，此时的方案数为多少。

转移时枚举可行的遍历顺序即可，需要时刻注意当前筐内球的数量经 $in$ 与 $out$ 后的变化。

答案即为 $dp_{1,0}$。

```cpp
const int N=1e4+5,M=1e3+5,B=13,mod=998244353;
int n,m,k;
vector<int> e[N];
int dfn[N],st[14][N],tot;
int fir[N],in[N][3],out[N][3];
int f[N][M],dp[N][M];
int get(int x,int y){return dfn[x]<dfn[y]?x:y;}
void dfs(int u,int fa)
{
    st[0][dfn[u]=++tot]=fa;
    for(int v:e[u]) dfs(v,u);
}
int lca(int u,int v)
{
    if(u==v) return u;
    if((u=dfn[u])>(v=dfn[v])) swap(u,v);
    int d=log2(v-u++);
    return get(st[d][u],st[d][v-(1<<d)+1]);
}
void dfs1(int u)
{
    for(int v:e[u]) dfs1(v);
    fir(i,0,k)
    {
        vector<int> ord(e[u].size());
        iota(ord.begin(),ord.end(),0);
        do
        {
            if(!ord.empty()&&fir[u]==1-ord[0]) continue;
            int now=i,mul=1;
            now-=out[u][2];
            if(now<0) continue;
            for(int id:ord)
            {
                int v=e[u][id];
                now+=in[u][id];
                if(now>k){now=-1;break;}
                mul=1ll*mul*dp[v][now]%mod,now=f[v][now];
                if(now==-1) break;
                now-=out[u][id];
                if(now<0){now=-1;break;}
            }
            if(now==-1) continue;
            now+=in[u][2];
            if(now>k) continue;
            f[u][i]=now,(dp[u][i]+=mul)%=mod;
        }
        while(next_permutation(ord.begin(),ord.end()));
    }
}
void solve()
{
    cin>>n>>m>>k;
    fir(i,2,n,x) cin>>x,e[x].push_back(i);
    dfs(1,0);
    fir(j,1,B) fir(i,1,n-(1<<j)+1) st[j][i]=get(st[j-1][i],st[j-1][i+(1<<(j-1))]);
    memset(fir,-1,sizeof(fir));
    memset(f,-1,sizeof(f));
    fir(_,1,m,s,t,w)
    {
        cin>>s>>t;
        w=lca(s,t);
        int ws=-1,wt=-1;
        fir(i,0,e[w].size()-1)
        {
            if(lca(s,e[w][i])==e[w][i]) ws=i;
            if(lca(t,e[w][i])==e[w][i]) wt=i;
        }
        if(w==s) in[w][wt]++,out[t][2]++;
        else if(w==t) in[s][2]++,out[w][ws]++;
        else
        {
            in[s][2]++,out[t][2]++;
            if(fir[w]==wt){cout<<0<<endl;return;}
            fir[w]=ws;
        }
    }
    dfs1(1);
    cout<<dp[1][0]<<endl;
    return;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

首先二叉树的欧拉序。即我们给定每个有两个儿子的节点一个左右浏览的顺序。

然后新到达一个点 $u$ 的时候。我们会背负所有终点在 $u$ 子树内，而起点不在的元素。出来的时候背负所有起点在 $u$ 子树内，而终点不在的元素。然而，我们还会背负其他起点终点都不在的垃圾元素。

思考这样的垃圾元素是如何形成的？比如 $u$ 有两个儿子 $l,r$。$M$ 起点在 $l$ 子树内，终点在 $u$ 子树外。

我们先浏览 $u$ 再浏览 $v$。这样子我们就不得不背负 $M$ 在 $v$ 子树转一圈。

这样的垃圾元素贡献形如：如果 $x$ 先走/后走就要背负这个垃圾元素。其中 $x$ 是 $s\to t$ 路径上一点。

我们算出 $p_{u,0/1}$ 表示 $u$ 先走/后走需要额外背负的垃圾元素就能转移了。

$f_{u,i}$ 表示 $u$ 进来时已经背负了 $i$ 个垃圾元素的方案数。转移是 $f_{u,i}=f_{l,i-p_{l,0}}\times f_{r,i-p_{r,1}}+f_{r,i-p_{r,0}}\times f_{l,i-p_{l,1}}$。

---


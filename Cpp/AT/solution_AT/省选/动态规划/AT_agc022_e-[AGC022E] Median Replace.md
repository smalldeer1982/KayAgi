# [AGC022E] Median Replace

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc022/tasks/agc022_e

タイチは、`0` と `1` からなる奇数長 $ N $ の文字列 $ X $ は次の条件を満たすとき **美しい** と考えています。条件：次の操作を $ \frac{N-1}{2} $ 回行って、最終的な文字列の唯一の文字を `1` にすることができる。

- $ X $ の **連続する** $ 3 $ つのビットを選び、それらの中央値でそれらを置き換える。例えば、`00110` の中央の $ 3 $ ビットに操作を適用すると、この文字列は `010` となる。

タイチは `0`、`1`、`?` からなる文字列を持っています。この文字列の `?` をそれぞれ `1` か `0` に置き換える方法であって、美しい文字列が得られるものの個数を $ 10^{9}\ +\ 7 $ で割った余りをタイチは知りたいです。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 300000 $
- $ |S| $ は奇数である。
- $ S $ のすべての文字は `0`、`1`、`?` のいずれかである。

### Sample Explanation 1

`?` を `0` か `1` で置き換える方法は以下の $ 4 $ 通りあります。 - `11100` : この文字列は美しいです。なぜなら、まず最後の $ 3 $ ビットに操作を適用して `110` とし、次に文字列全体に操作を適用すると `1` となるからです。 - `11000` : この文字列は美しいです。なぜなら、まず最後の $ 3 $ ビットに操作を適用して `110` とし、次に文字列全体に操作を適用すると `1` となるからです。 - `10100` : この文字列は美しくありません。なぜなら、最終的に文字列が `1` となるような操作手順が存在しないからです。 - `10000` : この文字列は美しくありません。なぜなら、最終的に文字列が `1` となるような操作手順が存在しないからです。 よって、美しい文字列を得る方法は $ 2 $ 通りです。

### Sample Explanation 2

この場合、`1` が唯一の美しい文字列です。

### Sample Explanation 3

答えを $ 10^{9}\ +\ 7 $ で割った余りを出力することを忘れずに。

## 样例 #1

### 输入

```
1??00```

### 输出

```
2```

## 样例 #2

### 输入

```
?```

### 输出

```
1```

## 样例 #3

### 输入

```
?0101???10???00?1???????????????0????????????1????0```

### 输出

```
402589311```

# 题解

## 作者：关怀他人 (赞：22)

### AGC 022E
首先考虑如何判断一个数列是否合法。

考虑维护一个栈，满足从栈顶到栈底是由一段连续的$0$和一段连续的$1$组成。从左到右将每一个数加入栈中，考虑加入的数是什么
1. 若加入的数为$0$：
    + 若栈顶为$0$，如果栈内有$2$个$0$，那么可以替换成一个$0$，否则入栈。
    + 若栈顶为$1$，直接入栈即可。
2. 若加入的数为$1$：
    + 若栈顶为$0$，则新加入的$1$可以和栈顶的$0$抵消，因为再加入一个数，这三个数的中位数之和新加入的数有关。
    + 若栈顶为$1$，如果栈内只有一个$1$则入栈，否则忽略它。

最后只需要判断栈内$1$的个数是否大于等于$0$的个数即可。

不难发现栈中$0$和$1$的个数只有可能是$0\sim 2$，于是便可以dp了，设$f_{i,a,b}$表示看到了第$i$位，栈内有$a$个$1$和$b$个$0$的方案数。接下来考虑转移：
1. $s[i+1]=0$，则有转移：

$$
\begin{aligned}
f_{i,a,2}&\to f_{i + 1,a,1}\\
f_{i,a,1}&\to f_{i + 1,a,2}\\
f_{i,a,0}&\to f_{i + 1,a,1}\\
\end{aligned}
$$

2. $s[i+1]=1$，则有转移：

$$
\begin{aligned}
f_{i,a,b}&\to f_{i + 1,a,b - 1}\\
f_{i,0,0}&\to f_{i + 1,1,0}\\
f_{i,1,0}&\to f_{i + 1,2,0}\\
f_{i,2,0}&\to f_{i + 1,2,0}
\end{aligned}
$$

3. 若这一位为?，则将上面两种转都做一遍即可。

时间复杂度为$\mathcal O(n)$

#### Code
```cpp
int n;
int f[MAXN][3][3];
char s[MAXN];

int main(){
    scanf("%s",s + 1);
    n = strlen(s + 1);
    f[0][0][0] = 1;
    for(int i = 0;i < n;i++){
        if(s[i + 1] != '1'){
            for(int a = 0;a <= 2;a++){
                addmod(f[i + 1][a][1],f[i][a][2]);
                addmod(f[i + 1][a][2],f[i][a][1]);
                addmod(f[i + 1][a][1],f[i][a][0]);
            }
        }
        if(s[i + 1] != '0'){
            for(int a = 0;a <= 2;a++){
                addmod(f[i + 1][a][0],f[i][a][1]);
                addmod(f[i + 1][a][1],f[i][a][2]);
            }
            addmod(f[i + 1][1][0],f[i][0][0]);
            addmod(f[i + 1][2][0],f[i][1][0]);
            addmod(f[i + 1][2][0],f[i][2][0]);
        }
    }
    int ans = 0;
    for(int a = 0;a <= 2;a++){
        for(int b = 0;b <= a;b++)
            addmod(ans,f[n][a][b]);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：18)

题解区令人迷惑的一道题，我来认真解释一下。

这是一篇偏理解的题解，如果你想理解而不是写代码的话可以来瞰瞰qwq。

先考虑对于无 “?” 的确定串考虑是否合法，首先我们要求最后剩的数是 1，那么我们就得消 0。

消 0 最有效的手段就是 000，我们从左往右维护一个栈表示前面剩余数的情况，那么我们希望看到的就是 0 堆在栈顶，从而消去 0。

考虑栈顶都是 0 时来了个 1，我们偏感性的理解一下：

- 如果只是虚晃一枪，后面继续给你丢 0，那么我们显然把 [x01]00... 变成 [x]00 不劣，更可能消 000。

- 如果是真的要给你很多 1，那么我们把 x[011]1.. 变成 x[1]1 也不劣，本来就会挨着往前消。

简单来说就是如果后面来 1，我们正常来说就会把这个 01 给消掉，如果后面来 0，这个 01 阻断了前后 0 的相连，我们也会把它消掉。

那么以上就是栈顶堆 0 的情况：

- 如果有 000 直接消成 0，血赚，情况不变

- 如果有 01，消掉不亏，情况不变或把 0 消完

栈顶堆 1 的情况：

- 如果一直来 1，我们暂且不考虑需要几个 1，先堆着，情况不变。

- 如果来了 0，我们希望的就是 0 堆着消掉，我们也堆着，此时就转化为栈顶为 0 的情况。

发现按此策略，0上面不可能堆 1，1 上面可能堆 0。

那么有情况：空栈，全是 0，全是 1，1 上有 0。

但由于串为奇数，每次消掉 2 个，最后的栈也一定为奇数。

首先 0 至多 2 个，如果再多就会有 000 消掉，那么有三种情况：

1. 栈顶堆 0，下面无 1，即 1 个 0，不合法。

1. 栈顶堆 1，没有 0，即 11111...奇数个 1，合法

1. 栈顶堆 0，下面有 1，考虑 0 和 1 的数量：
  
   - 11100 此时合法
  
     那么我们发现下面堆的 1 只用留 3 个就可以把 2 都消掉，如果 1 比 3 多一定合法。
     
   - 1110 为奇数，不存在
  
   - 1100 不存在
  
   - 110 合法
  
   - 100 不合法
  
   - 10 不存在
   
如果手动编号转移可能把人都转崩，发现用 0,1 的个数来代表状态是唯一确定的！

$\left(x,y\right)$ 代表栈中 $x$ 个 0，$y$ 个 1。

以下仅列举串长为奇数的情况，偶数同理，画个表格(横 $y$)：

$\begin{array}{|c|c|c|c|c|}(x,y)&0&1&2&>2\\0&\text{空栈}&\text{合法}&\text{不存在}&\text{合法}\\1&\text{不合法}&\text{不存在}&\text{合法}&\text{合法}\\2&\text{不存在}&\text{不合法}&\text{不存在}&\text{合法}\end{array}$

如果丧心病狂，手动转移，把不存在的状态全部压掉应该可以做到 $5\sim6$ 种状态。

完全不压直接转移就是 12 种状态，压了一半是 9 种状态。

我说停、停，还能压一半？然而事实就是如此，许多题解都这么搞：把 $y=3$ 的那层直接压到 $y=2$ 的那层转移，仍然使用 0,1 的个数自动转移。

这样做常数肯定减小，但就特别的搞人理解，关键是说的不清楚！

就算有 “?” 自动化转移也很好实现，代码就不放了。

---

## 作者：xht (赞：8)

## [Median Replace](https://atcoder.jp/contests/agc022/tasks/agc022_e)

### 题意

- 给定一个长度为 $n$ 的 $0/1$ 串 $s$，保证 $n$ 为奇数，其中有些位置上的字符不确定。
- 请你求出有多少个 $s$ 满足执行下列操作 $\frac {n-1}2$ 次后能使 $s$ 为 `1`：
  - 选择 $s$ 的三个连续的字符，将它们替换为这三个数的中位数。
- $n \le 3 \times 10^5$，答案对 $10^9+7$ 取模。

### 题解

考虑如何判断一个 $0/1$ 串是否合法。

维护一个栈，这个栈从栈底到栈顶由一段连续的 $1$ 和一段连续的 $0$ 组成。

对于一个新加字符 $c$：

- 若 $c=0$：由于三个 $0$ 抵消为一个 $0$ 严格不劣，因此若原来栈顶有两个 $0$ 则抵消为一个，否则加一个 $0$。
- 若 $c=1$：如果栈顶是 $0$，可以直接将这个 $0$ 与新加的 $1$ 抵消（因为无论和另外哪个数取中位数，答案都是另外那个数）；如果栈顶为 $1$，若已经有两个 $1$ 了，那么这个串一定合法，因此直接忽略掉这个 $1$ 就可以了，否则加一个 $1$。

根据这个过程可以知道栈 $0/1$ 的个数只有 $0 \sim 2$ 这三种，总共只有 $9$ 种情况。

考虑根据这个判定方法进行 DP，时间复杂度 $\mathcal O(n)$。

### 代码

```cpp
const int N = 3e5 + 7;
int n;
char s[N];
modint f[N][3][3], ans;

int main() {
	rds(s, n), f[0][0][0] = 1;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < 3; j++)
			for (int k = 0; k < 3; k++)
				if (!!f[i][j][k]) {
					if (s[i+1] != '0') {
						if (k) f[i+1][j][k-1] += f[i][j][k];
						else f[i+1][min(j+1,2)][k] += f[i][j][k];
					}
					if (s[i+1] != '1') {
						if (k == 2) f[i+1][j][1] += f[i][j][k];
						else f[i+1][j][k+1] += f[i][j][k];
					}
				}
	for (int i = 0; i < 3; i++)
		for (int j = 0; j <= i; j++)
			ans += f[n][i][j];
	print(ans);
	return 0;
}
```

---

## 作者：Yansuan_HCl (赞：7)

先考虑操作的真值表。

$$
\begin{matrix}
000\to 0 \\
010\to 0, 001\to 0, 100\to 0 \\
110\to 1, 011\to 1, 101\to 1 \\
111\to 1
\end{matrix}
$$

中间两种操作都能通过删掉一对 $10/01$ 来完成，本质不同的操作只有三种。

感性理解，$000\to 0$ 一定可以最先完成，$111\to 1$ 一定可以留最后完成。分析：若第二种操作和第一种操作都能运用于某一个串，则用完第一种操作还能剩一个 $1$。于是三种操作有优先级。

在有优先级的情况下可以直接按顺序操作。遇到三个 $0$ 直接删掉，一个 $1$ 后面跟着 $0$ 直接删掉。一个 $1$ 后面跟着 $0$ 的状态可能需要等 $0$ 匹配到三个 $0$。有连续至少两个 $1$ 时，先把后面的删完，再合并上两个 $1$，一定合法。有以下转移：

![](https://i.loli.net/2021/05/22/cEsqTQIJjYhzuAD.jpg)

---

## 作者：DengDuck (赞：4)

DP 套 DP 太难了呜呜呜。

首先考虑怎么 Check 一个确定的状态。

首先对于 `000` 缩成 `0` 肯定不劣。之后这玩意的长相形如 `1` 的连续段加上长度小于 $3$ 的 `0` 的连续段。

然后你考虑合并，我们肯定会把 `111` 这种留在最后，然后剩下的合并你发现本质都是一个 `1` 和 `0` 撞没了。但是我们直接判断 `1` 和 `0` 的数量是对的吗？显然不对因为合并过程中可能会产生新的 `000`。

所以我们就想到用栈来维护。

- 加入 `1` 时：
  - 如果栈顶是 `0`，我们就抵消掉。
  - 如果栈顶是 `1`，我们就插入。
- 加入 `0` 时：
  -  如果栈顶是 `1` 或者一个 `0`，我们直接插入。
  -  如果栈顶是两个 `0`，我们合并成一个。

我们试图以这个策略来 DP 套 DP，仔细思考，按照上述策略，`0` 可能在 `1` 后面，但是 `1` 不会出现在 `0` 后面（我们会抵消），所以状态可以用 $F(i,x,y)$ 表示前 $i$ 位处理出来的栈的状态是 $x$ 个 `1` 后面接上 $y$ 个 `0`，大力转移即可。

但是发现不太对，因为 `1` 可以疯狂叠放所以状态数还是 $\mathcal O(n^2)$ 的。然而最终我们只需要保证 `1` 的数量不比 `0` 少就行，所以当连续的 `1` 超过 $2$ 时肯定会比后面的 `0` 多，我们直接将其也钦定为 $2$ 即可。

---

## 作者：myee (赞：4)

### 思路

先考虑如何判定是否合法。

我们考虑先把每个 $\tt 010/000$ 结构收缩成单个 $\tt 0$。

于是接下来除了边界外不会有单个 $\tt 1$，且 $\tt 0$ 段长度不会超过 $2$。

此后若 $\tt 1$ 比 $\tt 0$ 多，则可以为 $\tt 1$；否则只能为 $\tt 0$。证明是平凡的。

考虑记录此时每个前缀中 $\tt 1$ 比 $\tt 0$ 多的个数，如果一个前缀中 $\tt 1$ 已经比 $\tt 0$ 多了至少 $3$ 个，则显然答案只能为 $\tt 1$ 了；而少的个数不可能少于 $2$ 个。

考虑加入一个字符，我们在状态中记录：
* 当前是否已有某个前缀满足其已必胜；如已必胜则不用记录之后的东西了。
* 当前前缀 $\tt 1$ 比 $\tt 0$ 多的个数（$-2\sim2$）
* 当前结末符状态，包括 $\tt 11,1101,11001,110,1100$ 五种。

这些结末符之间的转移关系是

$$\tt 11 + 0\rightarrow 110$$

$$\tt 11 + 1\rightarrow 11$$

$$\tt 1101 + 0\rightarrow 110$$

$$\tt 1101 + 1\rightarrow 11$$

$$\tt 11001 + 0\rightarrow 1100$$

$$\tt 11001 + 1\rightarrow 11$$

$$\tt 110 + 0\rightarrow 1100$$

$$\tt 110 + 1\rightarrow 1101$$

$$\tt 1100 + 0\rightarrow 110$$

$$\tt 1100 + 1\rightarrow 11001$$

其中 $\tt 1100+0$ 的变换会对前缀 $\tt 1$ 比 $\tt 0$ 多的个数造成特殊影响，而其余只会普通地造成影响。

容易发现自动机上实际状态数是不满的，直接 dp 套 dp 来统计方案数即可。

假设自动机上的状态集为 $\Sigma$，复杂度即为 $O(n|\Sigma|)$。

在本题背景下，按刚刚的方式直接暴力实现，则有 $|\Sigma|\le26$。

有没有基于压状态的更优实现？

仔细分析容易发现 $\tt 11$ 和 $\tt 1101$ 可以压在一起，$\tt 11001$ 和 $\tt 110$ 可以压在一起，直接压缩即可。

这样结末符只有 $\tt11,110,1100$ 三种了。

$$\tt 11 + 0\rightarrow 110$$

$$\tt 11 + 1\rightarrow 11$$

$$\tt 110 + 0\rightarrow 1100$$

$$\tt 110 + 1\rightarrow 11$$

$$\tt 1100 + 0/1\rightarrow 110$$

于是即有 $|\Sigma|\le16$。

实际上由于每次操作时前后缀和总是奇数 / 偶数，可以凭此再减小一半常数，不过没有必要。

如果认为 $|\Sigma|$ 为常数，复杂度即为 $O(n)$。

### Code

核心代码很短。

使用了滚动数组，所以空间是 $O(|\Sigma|)$ 的。

```cpp
const ullt Mod=1e9+7;
typedef ConstMod::mod_ullt<Mod>modint;
typedef std::vector<modint>modvec;
struct state
{
    uint sum,ed;
    state():sum(2),ed(0){}
    state(uint v):sum(v/3),ed(v%3){}
    state go(bol v){
        if(sum==5)return*this;
        state ans=*this;
        if(v||ed==2)ans.sum++,ans.ed=ed?ed-1:ed;else ans.sum--,ans.ed++;
        if(ans.sum==5)ans.ed=0;
        return ans;
    }
    uint hash(){return sum*3+ed;}
};
modint Dp[16],User[16];
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    freopen("QAQ.out","w",stdout);
#endif
    Dp[state().hash()]=1;
    chr c;
    while(~(c=getchar())&&(c=='0'||c=='1'||c=='?')){
        for(uint i=0;i<=15;i++)if(Dp[i]())
        {
            if(c!='1')User[state(i).go(0).hash()]+=Dp[i];
            if(c!='0')User[state(i).go(1).hash()]+=Dp[i];
        }
        for(uint i=0;i<=15;i++)Dp[i]=User[i],User[i]=0;
    }
    modint ans;
    for(uint i=0;i<=15;i++)if(state(i).sum>=2)ans+=Dp[i];
    ans.println();
    return 0;
}
```




---

## 作者：little_sun (赞：4)

### 题目大意

你有一个长度为$n$的串$\texttt{S}$，其中有一些位置上的字符是`?`，其他的字符则是$0/1$之间的一种

每次可以进行一步操作：选择$3$个连续的字符，并把它们用它们的中位数替换

求有多少种把`?`替换成$0/1$的方案使得在进行$\frac{n-1}{2}$次操作后剩下的字符为$1$？

### 分析

我们先考虑如果给定一个符合条件的串，要怎么判定这个串是否合法。

我们维护一个栈，这个栈从栈底到栈顶由一段连续的$1$和一段连续的$0$组成

对于新的一个字符$\texttt{c}$，我们分$0/1$情况考虑

- $c=0$，我们发现连续的$3$个$0$可以被抵消成为$1$个$0$，所以如果原来栈顶有$2$个连续的$0$，那么就把这$3$个$0$抵消掉$2$个变成$1$个$0$，否则直接把这个$0$插入栈顶

- $c=1$，如果栈顶是$0$，则可以将这个$0$与$1$抵消（因为再找一个数，$3$个数取中位数的话，结果只与新找的数有关），否则把这个$1$插入栈。（如果栈中已经有了两个$1$，则怎么合并剩下的都是$1$，所以如果栈中已经有了两个$1$就可以忽略新的这个$1$了）

然后我们发现栈中$1$的个数只有$0\sim2$这$3$种情况，$0$的个数也只有$0\sim2$这$3$种情况，所以栈的种类数只有$3 \times 3 = 9$种

现在我们考虑怎么$\texttt{dp}$：我们可以把当前栈的状态当做$\texttt{dp}$的状态，设$f[i][j][k]$表示当前处理第$i$位，栈中有$j$个$1$和$k$个$0$，则我们就可以按照上述的方式转移，对于`?`只要当做$0/1$分别转移一次就可以了。（具体转移可参见代码）

时间复杂度$\mathcal{O(n)}$

### 代码

```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define sum(a, b, mod) (((a) + (b)) % mod)

const int mod = 1e9 + 7;
const int MaxN = 3e5 + 10;

char s[MaxN];
ll n, f[MaxN][3][3];
void add(ll &a, ll b) {a += b, ((a > mod) ? (a -= mod) : 0); }

int main()
{   
    f[0][0][0] = 1;
    scanf("%s", s + 1), n = strlen(s + 1);
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < 3; j++)
        {
            for(int k = 0; k < 3; k++)
            {
                if(s[i + 1] != '0')
                {
                    if(k)
                        add(f[i + 1][j][k - 1], f[i][j][k]);
                    else add(f[i + 1][std::min(j + 1, 2)][k], f[i][j][k]);
                }
                if(s[i + 1] != '1')
                {
                    if(k == 2)
                        add(f[i + 1][j][1], f[i][j][k]);
                    else add(f[i + 1][j][k + 1], f[i][j][k]);
                }
            }
        }
    }
    ll ans = 0;
    for(int i = 0; i < 3; i++)
        for(int j = 0; j <= i; j++)
            add(ans, f[n][i][j]);
    printf("%lld\n", ans);
    return 0;
}
```





---

## 作者：xxr___ (赞：3)

首先考虑如果给定串 $S$ 没有通配符如果 `check`。

我们发现，合并的时候尽量让 $1$ 尽可能多留，$0$ 尽可能少留，所以有以下的讨论。我们维护一个栈，用来记录当前还剩下哪些字符。

1. 当前字符是 $1$
   - 栈顶是 $1$ 那么因为要尽可能多地保存 $1$ 所以直接入栈。
   - 栈顶连续两个都是 $1$ 那么最后答案肯定是合法，不用继续加了。
   - 栈顶是 $0$ 我们发现，此时如果再放入一个数 $x$ 那么栈顶的三个字符就会形如 $01x$ 那么最后合并的结果是 $x$ 和 $0,1$ 无关，所以直接把 $0$ 踢出栈去。
2. 当前字符是 $0$
   - 栈顶是 $0$ 直接入栈，等待有 $3$ 个 $0$ 的时候合并它们。
   - 栈顶是两个 $0$ 贪心的话，肯定让他们合并，因为 $0$ 越少越不劣。
   - 栈顶是 $1$ 直接加入，此时对答案没有影响，这里不能把 $1$ 踢出去，因为有可能后面 $0$ 可以合并。

归纳可以发现，最后栈内必然是先 $0$ 后 $1$ 要么就是只有 $1$ 或者 $0$ 要么是空串。
- 考虑反证，根据我们的操作我们发现，加入存在先 $1$ 后 $0$ 的情况，那么插入 $1$ 的时候会和 $0$ 抵消。

并且我们还能发现最后栈内 $1$ 和 $0$ 的个数均小于等于 $2$ 其实就是 $1$ 多了就不放了，$0$ 连续了就合并了。

所以可以设 $f(i,j,k)$ 表示前 $i$ 位当前栈内是先 $k$ 个 $0$ 后 $j$ 个 $1$ 的方案数，这样设向后转移较为方便，转移的过程，代码中写有较详细的注释，详见代码。

时间复杂度是 $\mathcal O(n)$ 的，带个 $3$ 倍常数。空间可以滚动数组优化到 $\mathcal O(1)$ 级别。

代码：
```cpp
#include<iostream>
#include<cstring> 

using ll = long long;

const ll mod = 1e9 + 7;
const int N = 3e5 + 5;

ll f[2][4][4];
/*
f[i][j][k] 前 i 个数中，当前栈顶是 k 个 0 加上 j 个 1 的形态的方案数 
*/
char c[N];

inline void add(ll & x,ll k){
	(x += k) %= mod;
}
int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	int n = 0;
	char d = getchar();
	while((d ^ '?') && (d ^ '1') && (d ^ '0')) d = getchar();
	while((d == '?') || (d == '1') || (d == '0')){
		c[++ n] = d;
		d = getchar();
	}
	f[0][0][0] = 1ll;
	for(int i = 0;i < n; ++ i){
		for(int j = 0;j <= 2; ++ j){
			for(int k = 0;k <= 2; ++ k){
				f[(i + 1) & 1][j][k] = 0;
			}
		}
		if(c[i + 1] ^ '1'){
			for(int j = 0;j <= 2; ++ j){
				//1.如果是 00 那么加入一个 0 就把他们合并成一个 0 
				add(f[(i + 1) & 1][j][1],f[i & 1][j][2]);
				//2.如果是 0 就加入 0，变成 00 等待以后的合并 
				add(f[(i + 1) & 1][j][2],f[i & 1][j][1]);
				//3.如果是只有 1 的那么直接入栈 
				add(f[(i + 1) & 1][j][1],f[i & 1][j][0]);
			}
		}
		if(c[i + 1] ^ '0'){
			for(int j = 0;j <= 2; ++ j){
				//1.如果栈顶是0，那么形如 01x 最后会合并成x 所以这一位无所谓，可以直接等待下一位的决策
				add(f[(i + 1) & 1][j][0],f[i & 1][j][1]);
				add(f[(i + 1) & 1][j][1],f[i & 1][j][2]);
			}
			//2.如果栈顶是1，那么直接插入
			add(f[(i + 1) & 1][1][0],f[i & 1][0][0]);
			add(f[(i + 1) & 1][2][0],f[i & 1][1][0]);
			//3.如果栈顶已经有了两个1，那么肯定是必胜策略，无所谓了
			add(f[(i + 1) & 1][2][0],f[i & 1][2][0]); 
		}
	}
	ll ans = 0;
	for(int i = 0;i <= 2; ++ i){
		for(int j = 0;j <= i; ++ j){
			//找那些 1 不少于 0 的 
			add(ans,f[n & 1][i][j]);
		}
	}
	std::cout << ans;
	return 0;
}
```

---

## 作者：tzc_wk (赞：3)

[Atcoder 题面传送门](https://atcoder.jp/contests/agc022/tasks/agc022_e) & [洛谷题面传送门](https://www.luogu.com.cn/problem/AT3950)

首先考虑对于固定的 01 串怎样计算它是否可以通过将三个连续的 $0$ 或 $1$ 替换为其中位数得到。我们考虑单调栈，新建一个栈，栈底到栈顶分别是一段连续的 $1$ 和一段连续的 $0$，分别表示当前未合并完的字符，我们从左往右扫描，每遇到一个字符可分以下两种情况：

- 如果我们遇到一个 $0$：

  - 如果栈为空，那直接将这个 $0$ 入栈就好了。

  - 如果栈顶 $0$ 的个数 $\ge 2$，那么显然我们可以把三个连续的 $0$ 合并成一个 $0$，因为不论我们后来加入什么样的数字，这样一一合并下去最终只可能得到一个 $0$，也就是说原来栈顶的两个 $0$ 变成了一个 $0$。
  - 如果栈顶没有 $0$，否则直接将这个 $0$ 入栈。

- 如果我们遇到一个 $1$：

  - 如果栈为空，那直接将这个 $1$ 入栈就好了。

  - 如果栈顶有 $0$，并且栈不为空，那么栈最顶上的两个元素一定是一个 $0$ 一个 $1$，而显然如果第一个数是 $0$，第二个数是 $1$，那第三个数不论是多少，取中位数得到的结果一定还是第三个数，所以我们索性将最开头的 $01$ 抵消，也就是说栈中 $0$ 的个数减少了 $1$，此时栈底到栈顶还是一段连续的 $1$ 和一段连续的 $0$。
  - 否则，栈中一定只剩一段连续的 $1$。如果这段 $1$ 的个数 $\ge 3$，仿照之前的推理过程它可以等效于 $3$ 个 $1$，否则我们就直接将 $1$ 入栈。

显然最终栈不为空，并且该 01 串 $s$ 满足条件的充要条件是最后 $1$ 的个数大于 $0$ 的个数，因为如果在合并过程中不存在栈中剩余 $\ge 3$ 个 $1$，并且又进来了一个 $1$ 的情况，那么每次操作栈内数的个数要么 $+1$ 要么 $-1$，而 $n$ 为奇数，故最后栈中剩余数的个数是奇数。如果只剩一个 $1$ 那就直接满足条件了，如果剩 $2$ 个 $1$ 一个 $0$ 或者 $3$ 个 $1$ 把这三个数合并一下即可，如果剩 $3$ 个 $1$ 两个 $0$ 根据抽屉原理一定存在连续的三个数中恰好有 $2$ 个 $1$，把这三个数合并得到一个 $1$，再把剩下三个数合并即可。如果在合并过程中存在栈中剩余 $\ge 3$ 个 $1$，并且又进来了一个 $1$ 的情况，那么最终这三个 $1$ 一定不会被消掉，也就是说最终 $1$ 的个数为 $3$，严格大于 $0$ 的个数的最大值 $2$，也符合题意。

接下来考虑原题。不难发现任何时刻单调栈中 $1$ 的个数 $\le 3$，$0$ 的个数 $\le 2$，也就是说本质不同的单调栈的个数 $\le 12$。我们考虑将单调栈放入 DP 状态中，即设 $dp_{i,x,y}$ 表示考虑到第 $i$ 个字符，单调栈中还剩 $x$ 个 $0$ 和 $y$ 个 $1$ 的方案数。分该位填 $0$ 和该位填 $1$ 转移即可。复杂度线性。

```cpp
const int MAXN=3e5;
const int MOD=1e9+7;
int n,dp[MAXN+5][3][4];char s[MAXN+5];
void add(int &x,int v){((x+=v)>=MOD)&&(x-=MOD);}
int main(){
	scanf("%s",s+1);n=strlen(s+1);dp[0][0][0]=1;
	for(int i=0;i<n;i++) for(int c0=0;c0<3;c0++) for(int c1=0;c1<4;c1++){
		if(s[i+1]!='1'){//digit 0
			if(c0==2) add(dp[i+1][1][c1],dp[i][c0][c1]);
			else add(dp[i+1][c0+1][c1],dp[i][c0][c1]);
		} if(s[i+1]!='0'){//digit 1
			if(c0) add(dp[i+1][c0-1][c1],dp[i][c0][c1]);
			else add(dp[i+1][c0][min(c1+1,3)],dp[i][c0][c1]);
		}
	} int ans=0;
	for(int c1=1;c1<=3;c1++) for(int c0=0;c0<c1;c0++)
		add(ans,dp[n][c0][c1]);
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：冰冷的心 (赞：3)

像这种把某些字符合并的题目似乎都有套路

就是确定消去的优先顺序然后用栈来维护消去的情况

最后用dp的状态来确定栈的情况

~~然而我还是不会 看的集训队大佬的题解~~

由于$01$,$10$无论$0,1$接在左边还是右边 都会是接上的数 所以可以直接删去这样的串

对$000$, $01$,$10$,$111$四种串进行考虑

显然有$000$要先删除,然后删除$01,10$ 最后删除$111$

$01,10$之间的删除可以无序，因为$01$左边只能接$1$,(接$0$的又只能变成$3$个的情况)最后都剩下$1$,另一种同理。

所以考虑栈中加入什么元素：

加入$1$,栈顶是$0$,直接删除,否则不做变化

加入$0$,栈顶是$1$,还是不删,因为$000$的优先级更大,栈顶是$00$直接删就好了

最后得出栈的形态一定是$x$个$1$,$y$个$0$且$0$在$1$之前

只要$x\geq y$就一定满足条件,且$y\leq 2$ 把$x\geq 2$的情况存到$x=2$的情况就好了

设$f[i][x][y]$表示考虑前i个字符，栈的形态是$x,y$直接转移即可

## CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
const int N = 3e5 + 11;
int f[N][3][3], n;
char s[N];
inline int A(int x, int y){
	return x + y - (x + y >= mod ? mod : 0);
}
inline int M(int x, int y){
	return 1LL * x * y % mod;
}
int main(){
	scanf("%s", s + 1);
	n = strlen(s + 1);
	f[0][0][0] = 1;
	for(int i = 0;i < n; i++){
		for(int x = 0;x <= 2; x++){
			for(int y = 0;y <= 2; y++){
				int F = f[i][x][y];
				if(s[i+1] != '0'){
					if(y == 0) f[i+1][x+(x!=2)][y] = A(f[i+1][x+(x!=2)][y], F);
					else f[i+1][x][y-1] = A(f[i+1][x][y-1], F);
				}
				if(s[i+1] != '1'){
					if(y == 2) f[i+1][x][y-1] = A(f[i+1][x][y-1], F);
					else f[i+1][x][y+1] = A(f[i+1][x][y+1], F);
				}
			}
		}
	}
	int ans = 0;
	for(int x = 0;x <= 2; x++){
		for(int y = x;y >= 0; y--)ans = A(ans, f[n][x][y]);
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：RiceFruit (赞：2)

先考虑如何判断一个串是否合法。

通过手玩可以发现，对于一个合法的串，考虑其最后一次合并，我们必然可以让第一个为 $1$ 的串的长度尽可能的少，直到为 $1$，于是考虑动态规划，维护每个长度为奇数的后缀能否变成 $1$，那么对于 $011$ 的转移是好维护的，因为中间的长度为 $1$，对于第一段为 $1$ 的转移，继续推性质，可以得到第二段的长度也为 $1$，至此，我们已经可以判断一个串是否合法，代码如下：
```cpp
bool check() {
    for (int i = 1; i <= n; ++i) f[i] = 0;
    int m = (n + 1) / 2;
    f[m] = a[n];
    bool ok = f[m], flg = 0;
    for (int i = m - 1; i >= 1; --i) {
        f[i] = (a[2 * i] && f[i + 1]) | flg;
        if (a[2 * i - 1]) {
            if (a[2 * i]) f[i] = 1;
            else f[i] |= ok;
        }
        ok |= f[i], flg |= (a[2 * i] && f[i + 1]);
    }
    return f[1];
}
```
观察代码，发现有用的只有对于 $i$，有用的只有当前的 `ok`，`flg`，`f{i+1}`，于是直接计入状态，`dp on dp` 即可，复杂度线性，代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 300300, mod = 1e9 + 7;
int n, m;
char a[N];
int res;
bool f[N];
int zy(int x, int a, int b) {
    int ok = x / 4, fg = x % 4 / 2, nxt = x % 2, s = (b && nxt) | fg;
    if (a) {
        if (b) s = 1;
        else s |= ok;
    }
    ok |= s, fg |= (b && nxt);
    return ok * 4 + fg * 2 + s;
}
void Add(int &x, int y) {
    x += y;
    if (x >= mod) x -= mod;
}
int g[N][8];
int main() {
    scanf("%s", a + 1), n = strlen(a + 1), m = (n + 1) / 2;
    if (a[n] != '1') g[m][0] = 1;
    if (a[n] != '0') g[m][5] = 1;
    for (int i = m - 1; i >= 1; --i) {
        for (int j = 0; j < 8; ++j) if (g[i + 1][j]) {
            for (int k = 0; k < 2; ++k) if (a[2 * i - 1] - '0' != 1 - k) {
                for (int l = 0; l < 2; ++l) if (a[2 * i] - '0' != 1 - l) {
                    Add(g[i][zy(j, k, l)], g[i + 1][j]);
                }
            }
        }
    }
    for (int i = 0; i < 8; ++i) if (i & 1) Add(res, g[1][i]);
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

讲一下自己的思路：

- 考虑对于长大于 $3$ 的 $0$ 颜色段暴力减成长为 $1/2$ 的颜色段是比较优的；

- 之后每次合并除了全 $1$ 段 $0$ 和 $1$ 都要一起减少一个，保证奇数的前提下只要 $1$ 的个数严格大于 $0$ 的个数即可，可以设计一个简单的 $O(n ^ 2)$ dp 但无法通过此题；

- 观察到我们如果可以强制令最后剩余的颜色段顺序为一段连续的 $1$ 和一段连续的 $0$，显然如果是一段 $0$ 和一段 $1$ 那么前面的 $0$ 自然要且必须被后面的 $1$ 用上述数量共同减一不劣的贪心方法抵消，否则序列会存在减不掉的 $0$，不合法；

- 那么对于后面的 $0$，如果加入 $1$ 就直接抵消了，因为取决的是两者之外的另一个数；如果加入 $0$ 则得在保证当前颜色段长不超过 $2$ 的情况下更新，显然这是不劣的。

- 此处有一个变成线性转移的优化：我们发现一个 corner，即如果此时全是 $1$ 没有 $0$ 而我又加入了 $1$，那么我们只需要在转移时将 $1$ 段的长和 $3$ 取 $\min$ 即可，因为对于 $0$ 加入的维护保证了 $0$ 段的长时刻是 $\leq 2$ 的，则如果前面的 $1$ 能扩展到 $\geq 3$ 的长度则必然是已经合法了的。

时间复杂度 $O(12n)$。还是比较简单的。

注意理解最开始的两种不劣贪心策略：对于长大于 $3$ 的 $0$ 颜色段暴力减成长为 $1/2$ 的颜色段；对于一个 $0/1$ 并列可以直接一起剪掉保证数量差不变。

```cpp
/*
读错题了。
考虑颜色段，对于所有长 > 2 的 0 颜色段暴力变成 0/00 
则我们发现后面的兑换一定消耗一个 0 和 1，换言之保证 1 的个数大于 0 即可。
设 dp_i,j,0/1/2 表示当前位置填了 1 - 0 = j 且当前最末尾是 1 / 0 / 00 的个数。
这个转移是 n ^ 2 的，我该怎么办？
考虑优化。
观察其实我们在每一次 0 段结束就可以直接合并了。
但是这还是得记录前面的 1 的个数，还能不能再优化。
sb 了，日。
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 3e5 + 5 , mod = 1e9 + 7;
int n,m,fac[Len],ifac[Len];
inline int qpow(int a,int b){int res = 1;while(b){if(b & 1) res = 1ll * res * a % mod;a = 1ll * a * a % mod;b = b >> 1;}return res;}
inline int C(int N,int M){return 1ll * fac[N] * ifac[N - M] % mod * ifac[M] % mod;}
char s[Len];
int dp[Len][4][3];
inline void Mod(int &x){if(x > mod) x -= mod;}
void DP(int i,int j,int k,int op)
{
    #define now dp[i][j][k]
    if(op == 0)
    {
        if(k <= 1) dp[i + 1][j][k + 1] += now , Mod(dp[i + 1][j][k + 1]);
        else dp[i + 1][j][1] += now , Mod(dp[i + 1][j][1]);
    }
    else
    {
        if(!k) dp[i + 1][min(j + 1 , 3)][k] += now , Mod(dp[i + 1][min(j + 1 , 3)][k]);
        else dp[i + 1][j][k - 1] += now , Mod(dp[i + 1][j][k - 1]);
    }
    #undef now
}
int main()
{
    scanf("%s",s + 1);
    n = strlen(s + 1);
    dp[0][0][0] = 1;
    for(int i = 0 ; i < n ; i ++)
    {
        for(int j = 0 ; j <= 3 ; j ++)
            for(int k = 0 ; k <= 2 ; k ++)
            {
                if(s[i + 1] == '?') DP(i , j , k , 0) , DP(i , j , k , 1);
                else if(s[i + 1] == '1') DP(i , j , k , 1);
                else DP(i , j , k , 0);
            }
    }
    int res = 0;
    for(int j = 0 ; j <= 3 ; j ++)
        for(int k = 0 ; k <= 2 ; k ++) if(j > k) res += dp[n][j][k] , Mod(res);
    printf("%d\n",res);
    return 0;
}
```

---

## 作者：Mittsommernacht (赞：1)

考虑检验一个串是否合法，可以用一个栈来模拟这个过程。

当遇到 $01$ 时，直接删掉没有影响；

当遇到 $000$ 时，直接变成一个 $0$ 显然更优。

发现最后会剩下多个 $1$，比较麻烦，不如考虑怎么输。

发现如果要输，因为长度是奇数，只有剩下一个单 $0$ 或 $100$ 两种情况。

那就很简单了，中间所有会用到的转移情况也只有空栈、$1$、$10$、$00$ 这四种，将这六种直接转移即可。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3e5 + 147, mod = 1e9 + 7;
string s;
int n, f[N][6], tot = 1, res; // empty, 0, 1, 10, 100, 00
int read() {
	char ch;
	int s = 0; int w = 1;
	while ((ch = getchar()) > '9' || ch < '0') if (ch == '-') w = -1;
	while (ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
	return s * w;
}
signed main() {
	cin >> s;
	n = s.size(); s = ' ' + s;
	if (s[1] == '0' || s[1] == '?') f[1][1] = 1;
	if (s[1] == '1' || s[1] == '?') f[1][2] = 1;
	for (int i = 1; i <= n; i++) if (s[i] == '?') tot = (tot * 2) % mod;
	for (int i = 2; i <= n; i++) {
		if (s[i] == '0' || s[i] == '?') {
			f[i][1] = (f[i][1] + f[i - 1][0] + f[i - 1][5]) % mod;
			f[i][3] = (f[i][3] + f[i - 1][2] + f[i - 1][4]) % mod;
			f[i][4] = (f[i][4] + f[i - 1][3]) % mod;
			f[i][5] = (f[i][5] + f[i - 1][1]) % mod;
		}
		if (s[i] == '1' || s[i] == '?') {
			f[i][0] = (f[i][0] + f[i - 1][1]) % mod;
			f[i][1] = (f[i][1] + f[i - 1][5]) % mod; 
			f[i][2] = (f[i][2] + f[i - 1][0] + f[i - 1][3]) % mod;
			f[i][3] = (f[i][3] + f[i - 1][4]) % mod;
		}
	}
	printf("%lld\n", (tot - f[n][1] - f[n][4] + mod + mod) % mod);
	return 0;
}
```

---

## 作者：EuphoricStar (赞：1)

考虑对于一个确定的串怎么判断合法性。

容易发现删到某个时刻若 $1$ 的个数大于 $0$ 的个数了，因为我们肯定不会蠢到在不是全 $1$ 的时候删 $111$，所以 $c_1 - c_0$ 在不是全 $1$ 的时候至少是不会变小的。

所以我们的目标就是让 $c_1 - c_0$ 尽可能大。

发现删 $000$ 这个操作看起来很优，它能使 $c_1 - c_0$ 增加 $2$。所以我们只要贪心地删 $000$ 就可以了……吗？

考虑这个串：$0010011$，删不了 $000$，并且 $c_1 - c_0 < 0$。但是实际上这个串可以先删中间的 $010$ 变成 $00011$，再删 $000$。发现问题出在没有删 $010$。发现删 $010$ 之后 $c_1 - c_0$ 不变，并且它左侧和右侧的 $0$ 可以拼在一起形成一个新的 $000$。感性理解一下这个策略是不劣的。

也就是说有 $000$ 或者 $010$ 就删。最后判 $c_1 - c_0$ 是否 $> 0$ 即可。

考虑计数。可以考虑设计一个自动机，并且记录当前考虑到的前缀的 $c_1 - c_0$ 的值。我们有：

$$\begin{aligned} \varnothing & \stackrel{0}{\Longrightarrow} 0 \\ & \stackrel{1}{\Longrightarrow} 1 \Longrightarrow \varnothing \end{aligned}$$

注意这里 $1$ 可以变成 $\varnothing$ 是因为这个 $1$ 之后不会参与删除了，所以直接忽略它，并且让 $c_1 - c_0$ 增加 $1$。

还有：

$$\begin{aligned} 0 & \stackrel{0}{\Longrightarrow} 00 \\ & \stackrel{1}{\Longrightarrow} 01 \\ 00 & \stackrel{0}{\Longrightarrow} 000 \Longrightarrow 0 \\ & \stackrel{1}{\Longrightarrow} 001 \\ 01 & \stackrel{0}{\Longrightarrow} 010 \Longrightarrow 0 \\ & \stackrel{1}{\Longrightarrow} 011 \Longrightarrow 1 \Longrightarrow \varnothing \\ 001 & \stackrel{0}{\Longrightarrow} 0010 \Longrightarrow 00 \\ & \stackrel{1}{\Longrightarrow} 0011 \Longrightarrow \varnothing \end{aligned}$$

所以自动机状态数为 $5$。先把当前在自动机上的结点记入状态。还要记一个当前 $c_1 - c_0$ 的值。

发现若 $c_1 - c_0 \ge 3$ 那么把后面的全部删了之后一定满足 $c_1 - c_0 > 0$。同时由于我们的策略，不会出现 $c_1 - c_0 \le -3$ 的情况。所以 $c_1 - c_0 \in [-2, 2]$，这样就可以记入状态了。

时间复杂度 $O(n)$。

[code](https://atcoder.jp/contests/agc022/submissions/51198131)

---

## 作者：Caicz (赞：1)

### [在博客食用效果更佳](https://www.luogu.com.cn/blog/224229/solution-at3950)
### [题目链接](https://www.luogu.com.cn/problem/AT3950)
### [Atcoder链接](https://atcoder.jp/contests/agc022/tasks/agc022_e)

------------

~~本题由zzy讲课后完成，思路全靠zzy讲懂~~

#### 题目大意

**给你一个由 $\text{0,1,?}$ 所构成的长度为奇数 $N$ 的字符串，你可以将字符串中连续三个字符变为其中位数,其中 $?$ 可以被替换为 $\text{0,1,}$ 求将所有 $?$ 替换并对字符串进行$\frac{N-1}{2}$次操作后，字符串为 $1$ 的方案数并对$1e9+7$取模**

看题目，并观察其中的性质，我们可以转换为加入每一个字符，就尽量消掉。那么我们就可以用栈来储存状态

则在栈中，我们将栈分为上下两部分，并将下面部分维护为全为 $1$ ，将上面有一部分维护成全为 $0$ 。

根据题目要求如果有$3$个连续的$0$,我们将其修改为$1$个$0$是较为优秀的解法。

同样的，如果在栈中还存在$0$时,加入了一个$1$,我们为了维护这个栈，就必须将这个$1$消掉，我们不难发现，消掉后变成 $0$或$1$ 取决于下一个加入进栈中的数。

因此，我们可以得出栈中 $0$ 的个数不会超过 $2$ 。

不难发现只要栈中 $1$ 的个数不小于 $0$ 的个数，这个字符串就一定能变成 $1$,所以当 $1$ 的个数$>=2$是，我们就当做 $1$ 的个数为 $2$ 处理

因此，我们的就可以得到 $dp[i][j][k]$ 表示扫描到第 $i$ 个字符，栈中的状态为 $j$ 个 $1$ 和 $k$ 个 $0$,其中栈总共只有$3\times 3=9$种状态，我们扫描完一遍统计答案即可

时间复杂度$O(kN)$其中 $k$ 为栈的总状态数
$$
\text{Talk is cheap,show you the code}
$$

```cpp
#include<touwenjian.h>\\从MMM处偷来的万能头文件
#define ll long long
#define maxn 300005
#define p 1000000007
using namespace std;
char s[maxn];
int dp[maxn][5][5];

int main()
{
	scanf("%s",s+1);
	int len=strlen(s+1);
	dp[0][0][0]=1;
	for(register int i=0;i<len;++i)
	{
		if(s[i+1]!='1')
		{
			for(int j=0;j<3;++j)
				for(int k=0;k<3;++k)
				{
					if(k==2)
						dp[i+1][j][k-1]=(dp[i+1][j][k-1]+dp[i][j][k])%p;
					else
						dp[i+1][j][k+1]=(dp[i+1][j][k+1]+dp[i][j][k])%p;
				}
					
		}
		if(s[i+1]!='0')
		{
			for(int j=0;j<3;++j)
				for(int k=0;k<3;++k)
				{
					if(k==0)
						dp[i+1][j+(j!=2)][k]=(dp[i+1][j+(j!=2)][k]+dp[i][j][k])%p;
					else
						dp[i+1][j][k-1]=(dp[i+1][j][k-1]+dp[i][j][k])%p;
				}
		}
	}
	int ans=0;
	for(register int i=0;i<3;++i)
		for(register int j=0;j<=i;++j)
			ans=(ans+dp[len][i][j])%p;
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：GoPoux4 (赞：1)

这种求合法方案数的题，先考虑如何判定一个数列合法。

维护一个栈，使得栈中有一个分界线，满足分界线下的数都为$1$，线上的数都为$0$。

从左往右依次将数列中每一个数加入栈中，有几种情况：

如果加入的数是 $1$ ：

1. 若栈顶为 $0$ ，则加入的 $1$ 可以与 $0$ 抵消掉。因为这两个数与下一个数的中位数取决于下一个数是 $0$ 还是 $1$ 。

2. 若栈顶为 $1$ ，则如果栈内有两个 $1$ ，不入栈，因为两个及以上个 $1$ 的中位数一定为 $1$ 。反之直接入栈。

如果加入的数是 $0$ ：

1. 若栈顶是 $0$ ，则如果栈内有两个 $0$ ，则可以抵消成一个 $0$。反之直接入栈。

2. 若栈顶是 $1$ ，直接入栈。

最后如果栈内 $1$ 的个数不小于 $0$ 的个数，那么整个数列操作后的数为 $1$ 。

---

发现栈中 $0,1$ 的个数都不超过2，于是可以将栈的形态作为状态进行dp。设 $f_{i,a,b}$ 表示当前将要加入的数的下标为 $i$ ，当前栈中有 $a$ 个 $1$ , $b$ 个 $0$ 。

如果当前数是 $?$ ，两种情况都转移即可。

---

Code:

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 300005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
#define mod 1000000007
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

char s[maxn];
lxl n,a[maxn],f[maxn][3][3];

int main()
{
	//freopen("AT3950.in","r",stdin);
	scanf("%s",s);
	n=strlen(s);
	for(R int i=0;i<n;++i)
		a[i+1]=s[i]=='?'?-1:s[i]-'0';
	f[1][0][0]=1;
	for(R int i=1;i<=n;++i)// 刷表法
	{
		if(a[i]==1)
		{
			f[i+1][0][0]+=f[i][0][1];
			f[i+1][0][1]+=f[i][0][2];
			f[i+1][1][0]+=f[i][0][0]+f[i][1][1];
			f[i+1][1][1]+=f[i][1][2];
			f[i+1][2][0]+=f[i][1][0]+f[i][2][1]+f[i][2][0];
			f[i+1][2][1]+=f[i][2][2];
		}
		else if(a[i]==0)
		{
			f[i+1][0][1]+=f[i][0][0]+f[i][0][2];
			f[i+1][0][2]+=f[i][0][1];
			f[i+1][1][1]+=f[i][1][0]+f[i][1][2];
			f[i+1][1][2]+=f[i][1][1];
			f[i+1][2][1]+=f[i][2][0]+f[i][2][2];
			f[i+1][2][2]+=f[i][2][1];
		}
		else
		{
			f[i+1][0][0]+=f[i][0][1];
			f[i+1][0][1]+=f[i][0][2];
			f[i+1][1][0]+=f[i][0][0]+f[i][1][1];
			f[i+1][1][1]+=f[i][1][2];
			f[i+1][2][0]+=f[i][1][0]+f[i][2][1]+f[i][2][0];
			f[i+1][2][1]+=f[i][2][2];
			f[i+1][0][1]+=f[i][0][0]+f[i][0][2];
			f[i+1][0][2]+=f[i][0][1];
			f[i+1][1][1]+=f[i][1][0]+f[i][1][2];
			f[i+1][1][2]+=f[i][1][1];
			f[i+1][2][1]+=f[i][2][0]+f[i][2][2];
			f[i+1][2][2]+=f[i][2][1];
		}
		for(R int a=0;a<3;++a)
			for(R int b=0;b<3;++b)
				f[i+1][a][b]%=mod;
	}
	lxl ans=(((f[n+1][0][0]+f[n+1][1][0])%mod+f[n+1][2][0])%mod+f[n+1][2][1])%mod+f[n+1][2][2];
	printf("%lld\n",ans%mod);
	return 0;
}
```


---

## 作者：starseven (赞：1)

[AtCoder](https://atcoder.jp/contests/agc022/tasks/agc022_e)

[luogu](https://www.luogu.com.cn/problem/AT3950)

[我的博文](https://www.cnblogs.com/starseven/p/13110345.html)

-----------------------------------------------

# 题意

给你一行字符串，里面有$1,0,?$,？表示既可以填$1$,又可以填$0$,而对于连续的三个数，可以合并，合并的结果是他们的中位数，求有多少个合法的序列满足合并的最后结果可能为1.

# 输入

$$ 101010?11?101??010101\dots 101???01$$

$$ 反正就是一行字符串 $$

# 分析

我拿到这题时没有办法，所以纯粹是听了老师讲了之后才懂的。老师说这类题（相邻的数合并）大多数都是用的一个栈模型来解决，为什么可以用栈模型，因为可以**贪心**。

### 注意：我们这里的栈是0一边，1一边

![栈.png](https://i.loli.net/2020/06/12/qH6jRmJX4E7vd1A.png)

所以我们可以看这三个例子：

1. $\dots 000 \dots $

对于这连续的三个零，我们应不应该合并，因为我们要求的最后是一，而在这里是三个零互相抵消，然后变为一个零，我们肯定是稳赚不赔的！

2. $\dots 01\dots $
这里我们可以看到，我们之后的数加入为1，那合并就为1，反之亦然。所以这个可以直接在栈中“抵消”

3. $1111\dots$(这是在栈中)

我们通过前两个规则都可以知道，栈中的0最多有两个，那两个0用几个1就可以使中位数为一了呢，当然是三个就可以了，所以这个时候放入一也可以直接抵消

------

# 代码

通过我们前三个规则就可以打出代码了：

```cpp
#include<cstdio>
#include<iostream>
#define re register int
#define Starseven main
#define ll long long
using namespace std;
const int N=3e5+20;
const ll mod=1e9+7;
int num[N],len;
ll dp[N][4][4];

int Starseven(void){
	while(1){
		len++;
		char ch=getchar();
		if(ch=='\n') break;
		while(ch!='0'&&ch!='1'&&ch!='?'){
			ch=getchar();
		}
		if(ch=='1') num[len]=1;
		else if(ch=='0') num[len]=2;
		else num[len]==0; 
	}
	len--;
	dp[0][0][0]=1;
	for(re i=1;i<=len;i++){
		if(num[i]){
			if(num[i]==1){
				dp[i][1][0]=(dp[i][1][0]+dp[i-1][0][0]+dp[i-1][1][1])%mod;
				dp[i][2][0]=(dp[i][2][0]+dp[i-1][1][0]+dp[i-1][2][1])%mod;
				dp[i][3][0]=(dp[i][3][0]+dp[i-1][2][0]+dp[i-1][3][1]+dp[i-1][3][0])%mod;
				dp[i][0][0]=(dp[i][0][0]+dp[i-1][0][1])%mod;
				for(re j=0;j<=3;j++) dp[i][j][1]=(dp[i][j][1]+dp[i-1][j][2])%mod;
			}
			else{
				for(re j=0;j<=3;j++) dp[i][j][1]=(dp[i][j][1]+dp[i-1][j][0]+dp[i-1][j][2])%mod;
				for(re j=0;j<=3;j++) dp[i][j][2]=(dp[i][j][2]+dp[i-1][j][1])%mod;
			}
		}
		else{
			dp[i][1][0]=(dp[i][1][0]+dp[i-1][0][0]+dp[i-1][1][1])%mod;
			dp[i][2][0]=(dp[i][2][0]+dp[i-1][1][0]+dp[i-1][2][1])%mod;
			dp[i][3][0]=(dp[i][3][0]+dp[i-1][2][0]+dp[i-1][3][1]+dp[i-1][3][0])%mod;
			dp[i][0][0]=(dp[i][0][0]+dp[i-1][0][1])%mod;
			for(re j=0;j<=3;j++) dp[i][j][1]=(dp[i][j][1]+dp[i-1][j][2])%mod;
			
			for(re j=0;j<=3;j++) dp[i][j][1]=(dp[i][j][1]+dp[i-1][j][0]+dp[i-1][j][2])%mod;
			for(re j=0;j<=3;j++) dp[i][j][2]=(dp[i][j][2]+dp[i-1][j][1])%mod;
		}
	}
	ll ans=0;
	for(re i=0;i<=3;i++) ans=(ans+dp[len][i][0])%mod;
	ans=(ans+dp[len][2][1]+dp[len][3][1]+dp[len][3][2])%mod;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：_Cheems (赞：0)

题意：一个 $01$ 串假如能通过若干次“将三个连续的数替换为它们的中位数”的操作，最终变成 $1$，则称它是合法的。将串 $S$ 中的通配符替换为 $0/1$ 能得到多少合法串？$|S|\le 3\times 10^5$。

考虑合法的条件。肯定要尽量多 $1$ 而少 $0$。可以考虑用一个栈扫一遍，栈中存储剩余元素，我们归纳地认为栈由下面一段 $1$ 和上面一段 $0$ 构成：

* 若新增了 $0$：

  * 若栈顶已有 $2$ 个 $0$，直接消掉即可。
  * 若栈顶只有一个 $0$ 或者栈为空，先入栈，看看之后怎么决策。
  * 若栈顶为 $1$，你发现操作的数若包含 $01$，则可以认为是消掉 $01$ 保留剩下元素。但是之后可能有新来的 $0$ 发生抵消，所以还是先入栈等待。
* 若新增了 $1$：

  * 若栈顶有 $0$：此时这些 $0$ 不可能和后面的 $0$ 相消，并且先前已经做过决策了，所以可以放心地让 $01$ 消掉。
  * 否则入栈。

显然 $0$ 的个数 $\le 2$，同时注意到若左边有 $\ge 2$ 个 $1$ 则必胜。那么容易有 dp，$f_{i,j,k}$ 表示考虑 $[1,i]$，栈中 $j$ 个 $1$，$k$ 个 $0$。可以认为 $j=2$ 的情况为必胜态。

复杂度 $O(n)$。

---

## 作者：wwwwwza (赞：0)

用一个栈来模拟一下放数的情况。

- 放入 $0$。

栈顶是 $0$，直接放，如果有三个 $0$ 就合并。

栈顶是 $1$，也直接放，可能后面会继续放 $0$ 让其合并。

- 放入 $1$。

栈顶是 $0$，显然 ```x01``` 这种情况合并会留下一个 ```x```，所以直接合并一定不劣。

栈顶是 $1$ 直接放。

最后栈会有四种情况：空栈、全是 $0$、全是 $1$、先 $1$ 后 $0$。

显然当 $1$ 的个数大于等于 $0$ 的个数时合法。

转移是显然的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e5+5,mod=1e9+7;
int n,dp[N][3][3],ans=0;
char ch[N];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin >>ch+1;
	n=strlen(ch+1);
	dp[0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<3;j++){
			for(int k=0;k<3;k++){
				if(ch[i]!='0'){
					if(k)dp[i][j][k-1]=(dp[i][j][k-1]+dp[i-1][j][k])%mod;
					else dp[i][min(j+1,2)][k]=(dp[i][min(j+1,2)][k]+dp[i-1][j][k])%mod;
				}
				if(ch[i]!='1'){
					if(k==2)dp[i][j][1]=(dp[i][j][1]+dp[i-1][j][k])%mod;
					else dp[i][j][k+1]=(dp[i][j][k+1]+dp[i-1][j][k])%mod;
				}
			}
		}
	}
	for(int i=0;i<3;i++)for(int j=0;j<=i;j++)ans=(ans+dp[n][i][j])%mod;
	cout <<ans;
	return 0;
}

```

---

## 作者：BreakPlus (赞：0)

首先考虑将所有相邻的三个 $0$ 缩起来变成一个 $0$，然后发现任意两个 $1$ 之间的 $0$ 的数量一定是 $[0,2]$ 之间的整数。如 $\texttt{1000100101000010} \to \texttt{11001010010}$。

把相邻两个 $1$ 之间的 $0$ 的数量记录下来，以此来描述一个序列。如 $\texttt{11001010010}$ 可以被描述为 $[0,0,2,1,2,1]$（注意第一个 $1$ 的前面和最后一个 $1$ 的后面也要记）。令 $[0,0,2,1,2,1]$ 为$\texttt{11001010010}$ 的**生成序列**。

然后考虑接下来的操作：

+ $\texttt{1001001}$，操作一次可以得到 $\texttt{101}$，对应生成序列上 $[2,2] \to [1]$；
+ $\texttt{101001}$，操作一次可以得到 $\texttt{1001}$，对应生成序列上 $[1,2] \to [2]$（同理 $[2,1] \to [2]$）；
+ $\texttt{10101}$，操作一次可以得到 $\texttt{101}$，对应生成序列上 $[1,1] \to [1]$；
+ $\texttt{11001}$，操作一次可以得到 $\texttt{101}$，对应生成序列上 $[0,2] \to [1]$（同理 $[2,0] \to [1]$）；
+ $\texttt{1101}$，操作一次可以得到 $\texttt{111}$，对应生成序列上 $[0,1] \to [0]$（同理 $[1,0] \to [0]$）；
+ $\texttt{111}$，操作一次可以得到 $\texttt{1}$，对应生成序列上 $[0,0] \to [\empty]$。

也就是在原序列上对相邻三个数的操作，可以转化为在生成序列上对相邻两个数的操作。原序列合法等价于生成序列可以被删空（因为 $\texttt{1}$ 对应 $[0,0]$，而 $[0,0] \to [\empty]$）

发现生成序列上，$1$ 和 $2$ 的合并可以看做类似异或的运算，而和 $0$ 合并比较复杂。

果断写个打表程序，观察一个生成序列对的应原序列**不合法**的充要条件。打出来一堆，好像观察不出来。

于是先让打表程序输出所有不合法的**不含** $0$ 的生成序列，发现一定是将所有 $1,2$ 合并起来后剩一个 $1$（如果剩一个 $2$，原序列的长度甚至不是奇数）。

然后再让它输出所有不合法的**恰好含有一个** $0$ 的生成序列，发现 $0$ 的左右两边的 $1,2$ 合并起来后，有 $[1,0,2]$ 或者 $[2,0,1]$ 不合法。

于是再次猜想，所有相邻的 $1,2$ 可以先合并起来。继续打表，发现 $[2,0,2,0,1]$，$[2,0,1,0,2]$，$[1,0,2,0,2]$ 都是不合法的。由此可以猜到最终结论：贪心合并 $1,2$ 后，剩下恰好一个 $1$ 的生成序列不合法。

注意如果一个生成序列开头/结尾是 $0$，那么在对应的前面/后面需要再添加一个 $1$ 来补齐这个形式。

按照这个猜想设计一个自动机状物，然后就是简单的线性 DP 了。设计状态是容易的。

```cpp
int dp[300005][3][2][2], n;
char s[300005];

void procedure(){
	scanf("%s", s+1); n=strlen(s+1);
	dp[0][0][0][0]=1;
	int ans = 1;
	for(int i=1;i<=n;i++)
		if(s[i] == '?') addmod(ans += ans);
	for(int i=1;i<=n+1;i++){
		for(auto a:{0,1,2}) for(auto b:{0,1}) for(auto c:{0,1}){
			if(i <= n){
				if(s[i]!='1') addmod(dp[i][(a&1)+1][b][c] += dp[i-1][a][b][c]);
				if(s[i]!='0'){
					if(a==0){
						if(c+(!b)<=1) addmod(dp[i][0][0][c+(!b)] += dp[i-1][a][b][c]);
					}else{
						addmod(dp[i][0][b^(a-1)][c] += dp[i-1][a][b][c]);
					}
				}
			}else{
				if(a){
					int w=b^(a-1);
					if(c+(!w)<=1) addmod(dp[i][0][0][c+(!w)] += dp[i-1][a][b][c]);
				}else{
					if(c+(!b)<=0) addmod(dp[i][0][0][c+(!b)+1] += dp[i-1][a][b][c]);
				}
			}
		}
	}
	printf("%d\n", (mod + ans - dp[n+1][0][0][1]) % mod);
}
```

---

## 作者：char_cha_ch (赞：0)

考虑如何描述这个合法的串。

设 $cnt_{0/1}$ 分别表示串中 $0/1$ 的出现次数。

显然当串长度为 $1$ 时，串合法的条件为 $cnt_1>cnt_0$。

考虑拓展这个东西: 

现在对于一个串有四种操作: 

1. 操作形如 $000$ 的串，$cnt_0\gets cnt_0-2$。

2. 操作形如 $001$ 的串，$cnt_0\gets cnt_0-1, cnt_1\gets cnt_1-1$。

3. 操作形如 $011$ 的串，$cnt_0\gets cnt_0-1, cnt_1\gets cnt_1-1$。

4. 操作形如 $111$ 的串，$cnt_1\gets cnt_1-2$。

贪心地，我们为了 $cnt_1>cnt_0$ ，会先操作一大堆 $000$。其中操作 $001$, $011$ 是不会影响 $cnt_1,cnt_0$ 的相对大小的，可以一直做这个。最后要操作 $111$，我们只希望在没有 $0$ 的时候操作。那么，充要的条件是，设 $tot$ 为把所有 $000$ 操作完后的 $cnt_0$ ，那么 $cnt_1>tot$。

考虑对这个做类似于背包的 dp，记 $cnt_1-tot$ 为多少，再维护关于结尾段的重要信息(为 $1$, 或者是 $0$ 的个数的奇偶性)，这时候就有 $\Theta(n^2)$ 了。

剩下不会优化了，看题解。

看了一圈发现[这一篇](https://www.luogu.com.cn/article/qp4kqf93)跟我的思路很像。他的优化很牛。

想法大概是每一次都把 $0$ 扔到背包里很不牛，那么重新观察下那几个操作和充要条件，设计一个更好的状态。

1.考虑加入字符 $1$。如果上一个是 $0$, 那么这两个数都不计入 $cnt$ ，对答案没有影响。如果上一个是 $00$，那么可以合并为 $0$，对答案没有任何影响。上一个是 $1$，那么 $cnt_1 \gets cnt_1+1$。

2.考虑加入字符 $0$。如果上一个是 $0,00$, 那么是简单的。上一个是 $1$ 的话，因为这个 $0$ 的贡献是在末尾处理，那么这个情况是没有改变任何信息的。

变为这个状态的时候，你有发现，有了 $0\le tot\le 2$，那么有效的 $cnt_1$ 只有 $4$ 类，$0,1,2$ 和 $\ge 3$ 的。综上，复杂度 $\Theta(12n)$。

---

## 作者：lgswdn_SA (赞：0)

考虑感性分析一下。

我们为什么前缀能消就消（指除了全 $1$ 之外能消就消）会不优呢？因为首先如果我们能保留到两个 $1$ 作为前缀，那么后面随便消都能合法。其次，后面可能能把很多个 $0$ 消成一个 $0$，那么前面的 $0$ 和前面的 $1$ 相互消就很不合算。

但是，如果一个 `0` 被 `1` 拦在了前缀，那么它无论如何也是没法在不和这个 `1` 消的情况下，和后面的 `0` 消的。

于是我们发现对于形如 `010` `001`，`011` 等 $0$ 开头的 pattern 是见到就能消的，不会影响最优性。

所以我们整理一下，有用的状态只有 `0`，`1`，`00`，`01`，`10`，`100`，`X`（`X` 指已经存在了前缀的两个 $1$ 后面随便消都无所谓）。

手动画一下这 $7$ 个状态之间的转移即可。复杂度 $O(n)$。

```
const int N=3e5+5,mod=1e9+7;
int n,f[N][8];
char s[N];
int e[8][2]={{1,2},{3,4},{5,7},{1,1},{1,2},{6,2},{5,5},{7,7}};

signed main() {
  scanf("%s",s+1); n=strlen(s+1); f[0][0]=1;
  rep(i,1,n) {
    if(s[i]!='1') rep(x,0,7) (f[i][e[x][0]]+=f[i-1][x])%=mod;
    if(s[i]!='0') rep(x,0,7) (f[i][e[x][1]]+=f[i-1][x])%=mod;
  }
  printf("%d\n",(f[n][2]+f[n][7])%mod);
  return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：0)

挺厉害的。

对于这种**以一定的规则删除某些数**的题目，我们可以考虑**分析操作之间的顺序**，然后用**自动机**模拟该过程。

首先可以注意到，$000$ 一定是能操作就操作的，$111$ 一定放在最后，初次之外的所有操作都不改变 $cnt_1-cnt_0$，如果我们不考虑删除 $111$，串串合法当且仅当最终的 $cnt_1-cnt_0\ge0$。

呃呃，首先你要有一个关键观察：如果某个时刻的 $cnt_1-cnt_0\ge2$，容易证明此时一定合法（考虑最坏情况加了个 $00$）

我们考虑为该转移构造自动机：

1. $c=0$

此时，若最后已经有了 $2$ 个 $0$，直接删除一个 $0$。

反之，我们不知道这个 $0$ 会不会在将来被 $000$ 叉掉，因此直接扔到状态最后。

2. $c=1$

此时，若最后为 $0$，注意到**此时的 $0$ 一定不可能在未来形成 $000$ 了，因此可以直接删掉一个 $0$（因为中位数一定是剩下的那个数）**

大概就是，$001\to0$ 这个样子

反之，直接扔最后，如果 $1$ 过多了直接统计到答案里。

呃啊，你写出来转移之后就可以发现，合法状态一定是下面几个 $1$ 加上上面几个 $0$ 的样子，然后你维护下目前最下面有几个 $1$ 和最上面有几个 $0$ 就行了。

直接写个自动机是不是也能过来着。

[code](https://www.luogu.com.cn/paste/076m3wjy)

---

## 作者：WhisperingWillow (赞：0)

[AGC022E Median Replace](https://www.luogu.com.cn/problem/AT_agc022_e)

一道思维价值很高的题。

考虑先写一个 check。

我们维护一个栈。

对于 $i$ 我们考虑以下几种情况：

- $s_i=1$，栈顶为 $1$，此时若栈中有 $2$ 个 $1$ 则将其忽略，否则将 $1$ 插入栈中。
- $s_i=0$，栈顶为 $0$，此时若栈顶有 $2$ 个 $0$ 则将栈顶消除，否则将 $0$ 插入栈中。
- $s_i=1$，栈顶为 $0$，此时将栈顶消除，因为剩下的取决于另一个数。
- $s_i=0$，栈顶为 $1$，此时将 $0$ 插入栈中。

有解仅当 $0$ 的个数小于等于 $1$ 的个数。

发现 $0,1$ 的数量都不会超过 $2$，因此直接转移即可，状态数量不会超过 $9n$。

```
#include <bits/stdc++.h>
#define f(c, a, b) for (register int c = a; c <= b; c++)
#define fd(c, a, b) for (register int c = b; c >= a; c--)
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define vi vector<int>
#define int long long
#define vpii vector<pi>
#define il inline
#define ri register
#define aint(a) a.begin(), a.end()
#define fr(a) freopen(a, "r", stdin)
#define fo(a) freopen(a, "w", stdout);
#define debug puts("------------------------")
#define lowbit(x) (x & -x)
#define ls(x) x << 1
#define rs(x) x << 1 | 1
#define co const
using namespace std;
const int N = 1e6 + 3;
int n, m;//**//
const int INF=2e9,P=1000000007;
const double eps=1e-6;
typedef long double lb;
namespace DEBUG{
	const bool DeBug=true;
	int db_cnt;
	il void db() { if (DeBug) puts("--------------"); return; }
	il void db(const auto a) { if (DeBug) ++ db_cnt, cerr << "-- | t" << db_cnt << " : " << a << '\n'; return; }
	il void db(const auto a, const auto b) { if (DeBug) ++ db_cnt, cerr << "-- | t" << db_cnt << " : " << a << ", " << b << '\n'; return; }
	il void db(const auto a, const auto b, const auto c) { if (DeBug) ++ db_cnt, cerr << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << '\n'; return; }
	il void db(const auto a, const auto b, const auto c, const auto d) { if (DeBug) ++ db_cnt, cerr << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << '\n'; return; }
	il void db(const auto a, const auto b, const auto c, const auto d, const auto e) { if (DeBug) ++ db_cnt, cerr << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << ", " << e << '\n'; return; }
	il void db(const auto *a, const auto len) { if (DeBug) { ++ db_cnt; cerr << "-- | t" << db_cnt << " : {"; if (!len) cout << "empty";else { cout << a[1]; for (int i = 2; i <= len; ++ i ) cerr << ", " << a[i]; } cout << "}\n"; } return; }
	il void db(const pair<auto, auto> a) { if (DeBug) ++ db_cnt, cerr << "-- | t" << db_cnt << " : <" << a.first << ", " << a.second << ">\n"; return; }
}
namespace Mod{
	template<int mod>
	inline unsigned int down(unsigned int x) {
		return x >= mod ? x - mod : x;
	}
	template<int mod>
	struct Modint {
		unsigned int x;
		Modint() = default;
		Modint(unsigned int x) : x(x) {}
		friend istream& operator>>(istream& in, Modint& a) {return in >> a.x;}
		friend ostream& operator<<(ostream& out, Modint a) {return out << a.x;}
		friend Modint operator+(Modint a, Modint b) {return down<mod>(a.x + b.x);}
		friend Modint operator-(Modint a, Modint b) {return down<mod>(a.x - b.x + mod);}
		friend Modint operator*(Modint a, Modint b) {return 1LL * a.x * b.x % mod;}
		friend Modint operator/(Modint a, Modint b) {return a * ~b;}
		friend Modint operator^(Modint a, int b) {Modint ans = 1; for(; b; b >>= 1, a *= a) if(b & 1) ans *= a; return ans;}
		friend Modint operator~(Modint a) {return a ^ (mod - 2);}
		friend Modint operator-(Modint a) {return down<mod>(mod - a.x);}
		friend Modint& operator+=(Modint& a, Modint b) {return a = a + b;}
		friend Modint& operator-=(Modint& a, Modint b) {return a = a - b;}
		friend Modint& operator*=(Modint& a, Modint b) {return a = a * b;}
		friend Modint& operator/=(Modint& a, Modint b) {return a = a / b;}
		friend Modint& operator^=(Modint& a, int b) {return a = a ^ b;}
		friend Modint& operator++(Modint& a) {return a += 1;}
		friend Modint& operator--(Modint& a) {return a -= 1;}
		friend bool operator==(Modint a, Modint b) {return a.x == b.x;}
		friend bool operator!=(Modint a, Modint b) {return !(a == b);}
		friend bool operator<(Modint a, Modint b) {return (a.x<b.x);}
		friend bool operator>(Modint a, Modint b) {return (a.x>b.x);}
	};
	typedef Modint<1000000007> _int;
}
namespace Functions{
	il auto Max(const auto x,const auto y){return x>y?x:y;};
	il auto toMax(auto &x,const auto y){return x=(x>y?x:y);};
	il auto Min(const auto x,const auto y){return x<y?x:y;};
	il auto toMin(auto &x,const auto y){return x=(x<y?x:y);};
	il auto Add(const auto x,const auto y){return x+y;};
	il auto toAdd(auto &x,const auto y){return x=(x+y);};
	il auto Mus(const auto x,const auto y){return x-y;};
	il auto toMus(auto &x,const auto y){return x=(x-y);};
	il auto Mul(const auto x,const auto y){return x*y;};
	il auto toMul(auto &x,const auto y){return x=(x*y);};
	il auto Mul(const auto x,const auto y,const auto p){return (x*y)%p;};
	il auto toMul(auto &x,const auto y,const auto p){return x=((x*y)%p);};
	il auto Div(const auto x,const auto y){return x/y;};
	il auto toDiv(auto &x,const auto y){return x=(x/y);};
	il int Xor(const int x,const int y){return x^y;};
	il int toXor(int &x,const int y){return x=(x^y);};
	il int And(const int x,const int y){return x&y;};
	il int toAnd(int &x,const int y){return x=(x&y);};
	il int Or(const int x,const int y){return x|y;};
	il int toOr(int &x,const int y){return x=(x|y);};
	il int popcnt(const int x){return __builtin_popcount(x);}
	il auto Sqr(const auto x){return x*x;}
	il auto toSqr(auto &x){return x=x*x;}
	il auto Sqr3(const auto x){return x*x*x;}
	il auto toSqr3(auto &x){return x=x*x*x;}
	il auto Sqr4(const auto x){return x*x*x*x;}
	il auto toSqr4(auto &x){return x=x*x*x*x;}
	il auto Sqr(auto x,int res,const int Mod){auto now=x;while(res){if(res&1) toMul(now,x);toMul(x,x);res>>=1;}return now;}
	il auto toSqr(auto x,const int res,const int Mod){return x=(Sqr(x,res,Mod));};
	il auto H_dis(const auto x,const auto y,const auto a,const auto b){return abs(x-a)+abs(y-b);}
	il auto H_dis(const pair<auto,auto> x,const pair<auto,auto> y){return H_dis(x.first,x.second,y.first.y.second);};
	il auto O_dis(auto x,auto y,auto a,auto b){return (lb)sqrt(Sqr(x-a)+Sqr(y-b));}
	il auto O_dis(const pair<auto,auto> x,const pair<auto,auto> y){return O_dis(x.first,x.second,y.first.y.second);};
}
namespace FastIO{
	il int read() {ri int ans = 0;ri char c = getchar();ri bool neg = 0;while ((c < '0') | (c > '9')) neg ^= !(c ^ '-'), c = getchar();while ((c >= '0') & (c <= '9')) ans = (ans << 3) + (ans << 1) + c - 48, c = getchar();return neg ? -ans : ans;}
	il void write(ri int x) {if (x < 0)x = -x, putchar('-');if (x > 9)write(x / 10);putchar(x % 10 + '0');}
	il void writes(ri int x) {write(x);putchar(' ');}
	il void writed(ri int x) {write(x);putchar('\n');}
}

using namespace Mod;
using namespace DEBUG;
using namespace Functions;
using namespace FastIO;
_int f[N][3][3];
void solve(){
	string s;cin>>s;
	n=s.size();
	s=' '+s;
	f[0][0][0]=1;
	f(i,0,n){
		f(j,0,2){
			f(k,0,2){
				_int p=f[i][j][k];
				if(s[i+1]!='0'){
					if(k)f[i+1][j][k-1]+=p;
					else f[i+1][Min(j+1,2)][k]+=p;
				}
				if(s[i+1]!='1'){
					if(k==2) f[i+1][j][1]+=p;
					else f[i+1][j][k+1]+=p;	
				}		
			} 
		}
	}
	_int ans=0;
	f(i,0,2) f(j,0,i) ans+=f[n][i][j];
	cout<<ans<<endl; 
	 return;
}

signed main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	int T=1;

	while(T--)
	    solve();

    return 0;
}
```

---

## 作者：Jsxts_ (赞：0)

不同的做法！

仍然是先考虑 check，一开始容易发现 $1$ 的个数 $>0$ 的个数肯定有解，但这还远远不够。

又发现若最左边和最右边都为 $1$，则肯定可以将中间的 $0$ 数量减成至多 $1$ 个后满足条件。受这个启发，我们期望寻找到两个 $1$（设为 $l,r$），满足可以消去它们左边和右边的 $0$ 后只剩下这个区间的数（当然旁边有更多的 $1$ 也无妨）。发现只要求出最小的 $l$ 和最大 $r$ 满足 $l\le r$ 即可合法。现在尝试求最小 $l$（最大 $r$ 同理）。

发现我们有两个操作，一个是消去一对 $01$，一个是将 $0$ 的数量减 $2$。

所以我们考虑从左到右扫，记录当前最少 $0$ 的数量 $c$，加入一个 $1$ 就将 $c$ 减一，加入 $0$ 就加一后若 $c=3$ 就变为 $c=1$（贪心地删去 $0$ 连续段）。

当一个 $1$ 左侧前缀的 $c=0$ 时，证明这个 $1$ 作为 $l$ 是合法的。

像这样 check，经过暴力验证是正确的。

现在考虑 dp。设 $dp_{i,j}$ 表示前 $i$ 个数，$c=j$ 的方案数。转移就讨论这一个填 $0$ 或 $1$ 然后再简单地转移，发现第二维只会取到 $0\sim 2$，所以直接 dp 即可。

在 dp 的同时记录 $L_i$ 表示 $i$ 作为上文的 $l$ 的方案数。统计就在第 $i$ 位取到 $1$ 时，令 $L_i\leftarrow L_i+dp_{i-1,0}$。

同理，倒着 dp 可以得到 $R_i$ 表示 $i$ 作为 $r$ 的方案数。

计算方案数就是统计如下式子：

$$\sum_{i=1}^n\sum_{j=i}^nL_iR_j2^{p_{j-1}-p_i}$$

其中 $p_i$ 为前缀问号个数。

这个可以轻松优化，注意 $i=j$ 要单独计算。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 1e9;
const ll INF = 1e15;
const int N = 3e5;
inline int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
char s[N + 10];
int dp[N + 10][3],L[N + 10],R[N + 10];
const int mod = 1e9 + 7,inv2 = mod + 1 >> 1;
int getmod(int x) {
	return x - (x >= mod) * mod;
}
int pw[N + 10],pre[N + 10],ipw[N + 10];
int main() {
	scanf("%s",s + 1);
	int n = strlen(s + 1);pw[0] = ipw[0] = 1;
	for (int i = 1;i <= n;i ++ )
		pw[i] = 2ll * pw[i - 1] % mod, pre[i] = pre[i - 1] + (s[i] == '?'), ipw[i] = 1ll * ipw[i - 1] * inv2 % mod;
	dp[0][0] = 1;
	for (int i = 0;i < n;i ++ ) {
		for (int j = 0;j < 2;j ++ ) {
			if (s[i + 1] != j + '0' && s[i + 1] != '?') continue;
			if (j == 1) {
				L[i + 1] = getmod(L[i + 1] + dp[i][0]);
				for (int k = 0;k < 2;k ++ ) {
					dp[i + 1][k] = getmod(dp[i + 1][k] + dp[i][k + 1]);
				}
			}
			else {
				for (int k = 1;k < 3;k ++ )
					dp[i + 1][k] = getmod(dp[i + 1][k] + dp[i][k - 1]);
				dp[i + 1][1] = getmod(dp[i + 1][1] + dp[i][2]);
			}
		}
	}
	memset(dp,0,sizeof dp);
	dp[n + 1][0] = 1;
	for (int i = n + 1;i >= 2;i -- ) {
		for (int j = 0;j < 2;j ++ ) {
			if (s[i - 1] != j + '0' && s[i - 1] != '?') continue;
			if (j == 1) {
				R[i - 1] = getmod(R[i - 1] + dp[i][0]);
				for (int k = 0;k < 2;k ++ ) {
					dp[i - 1][k] = getmod(dp[i - 1][k] + dp[i][k + 1]);
				}
			}
			else {
				for (int k = 1;k < 3;k ++ )
					dp[i - 1][k] = getmod(dp[i - 1][k] + dp[i][k - 1]);
				dp[i - 1][1] = getmod(dp[i - 1][1] + dp[i][2]);
			}
		}
	}
	int ans = 0;
	for (int i = 1;i <= n;i ++ ) ans = (ans + 1ll * L[i] * R[i]) % mod;
	for (int i = 1;i <= n;i ++ ) L[i] = 1ll * L[i] * ipw[pre[i]] % mod, R[i] = 1ll * R[i] * pw[pre[i - 1]] % mod;
	for (int i = n;i;i -- ) R[i] = getmod(R[i] + R[i + 1]);
	for (int i = 1;i <= n;i ++ ) ans = (ans + 1ll * L[i] * R[i + 1]) % mod;
	cout << ans;
	return 0;
}
/*
?0101
*/
```


---

## 作者：樱雪喵 (赞：0)

Tags: 神奇贪心，dp

居然还记得它怎么做，太感动了。

先考虑对于一个给定的串怎么判定答案。

首先我们希望在不损失 $\texttt{1}$ 的情况下减少 $\texttt{0}$ 的个数，因此第一步肯定是把 $\texttt{000}$ 全消掉。下文均默认做完了这步操作。   
然后除了 $\texttt{111}$（我们不希望消掉这个）以外每种消法都相当于删掉一个 $\texttt{0}$ 和一个 $\texttt{1}$。因此只要这个序列 $\texttt{1}$ 比 $\texttt{0}$ 多就合法。

但是这样直接塞进状态里 dp 复杂度是 $\mathcal{O}(n^2)$ 的。接着找性质：

- 如果一个前缀 $\texttt{1}$ 比 $\texttt{0}$ 多 $3$ 个，那整个串都赢了。证明的话考虑先把这个前缀消成只剩 $3$ 个 $\texttt{1}$，后面的部分显然不会剩下多于 $2$ 个连续的 $\texttt{0}$。
- 如果一个前缀 $\texttt{0}$ 比 $\texttt{1}$ 多 $3$ 个，相当于只多 $1$ 个，因为能消掉。

因此我们可以改一下判断合法的过程。

维护一个栈。每次考虑当前字符与栈顶的关系：

- 当前加入 $\texttt{0}$
	- 栈顶已有两个 $\texttt{0}$，把它们三个消成一个；
    - 否则入栈。
- 当前加入 $\texttt{1}$ 
	- 栈顶是 $\texttt{0}$，说明这段 $\texttt{0}$ 不消除肯定形不成三个连续，因此把当前数和栈顶抵消掉；
    - 栈顶是 $\texttt{1}$，如果栈里已经有两个了就摆，否则加进去。  
    为什么这么搞是对的呢？因为栈维护的过程优先消后面的 $\texttt{0}$，参见前缀至多 $3$ 个 $\texttt{1}$ 的证明。
    
最后栈里 $\texttt{1}$ 的个数**大于等于** $\texttt{0}$ 的就合法。
    
于是设 $f_{i,x,y}$ 表示前 $i$ 个，栈里有 $x$ 个 $\texttt{0}$ 和 $y$ 个 $\texttt{1}$。dp 转移一下就行了。

```cpp
const int N=3e5+5,mod=1e9+7;
int n,f[N][5][5];
char s[N];
il void add(int &x,int y) {x+=y;if(x>=mod) x-=mod;}
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    f[0][0][0]=1;
    for(int i=1;i<=n;i++)
    {
        if(s[i]!='1')
        {
            for(int x=0;x<=2;x++) 
            {
                add(f[i][x][1],f[i-1][x][2]);
                add(f[i][x][2],f[i-1][x][1]);
                add(f[i][x][1],f[i-1][x][0]);
            }
        }
        if(s[i]!='0')
        {
            for(int x=0;x<=2;x++) 
                for(int y=0;y<=2;y++) add(f[i][x][y],f[i-1][x][y+1]);
            add(f[i][1][0],f[i-1][0][0]);
            add(f[i][2][0],f[i-1][1][0]);
            add(f[i][2][0],f[i-1][2][0]);
        }
    }
    int ans=0;
    for(int x=0;x<=2;x++)
        for(int y=0;y<=x;y++) add(ans,f[n][x][y]);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：aaaaaaaawsl (赞：0)

方法是 DP。

考虑维护信息，要做到在递推的维护当前序列的合法性和方案。那么开一个栈，如果当前往里放 $0$：

- 当前栈里没东西，那么直接加入。

- 当前栈里有一个 $0$，操作不了，继续入栈

- 当前栈里有两个 $0$，因为要求结果是 $1$ 那么 $0$ 肯定越少越好，于是将三个零合并成一个零。

- 由于合并，不会出现四个零的情况。

- 当前栈里是 $1$，入栈。

- 当前栈里是 $110$ 或 $100$ 等等，等同于 $0$，$00$ 情况。

如果当前往里放 $1$：

- 当前栈里没东西，那么直接加入。

- 当前栈里有一个 $0$，那么两个都删去，因为下一个填什么合并完就剩什么。

- 当前栈里有两个 $0$，同理，删去一个。

- 当前栈里有一个 $1$，加入。

- 当前栈里有两个 $1$，由于要尽可以化到一上，所以不要合并成一个 $1$，考虑下一个无论加什么会化成 $1$ 于是等同于这个 $1$ 没有加入。

---------

### Code

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 3e5 + 10;
const int Mod = 1e9 + 7;

typedef long long ll;
typedef __int128 i128;

i128 InvMod = ((i128(1) << 64) / Mod) + 1;

inline int mod(ll x){
	return x - ll(x * InvMod >> 64) * Mod;
}

char ch[N];
int f[N][5][5], ans; // pos  ¼¸¸ö0£¬ ¼¸¸ö1 

signed main(){
	scanf("%s", ch + 1);
	int n = strlen(ch + 1); f[0][0][0] = 1;
	for(int i = 0; i < n; ++ i){
		if(ch[i + 1] != '0'){
			for(int j = 0; j <= 2; ++ j) f[i + 1][0][j] = mod((ll)f[i + 1][0][j] + f[i][1][j]), f[i + 1][1][j] = mod((ll)f[i + 1][1][j] + f[i][2][j]);//01
			f[i + 1][0][2] = mod((ll)f[i + 1][0][2] + mod((ll)f[i][0][1] + f[i][0][2])); f[i + 1][0][1] = mod((ll)f[i + 1][0][1] + f[i][0][0]); 
		}
		if(ch[i + 1] != '1') for(int j = 0; j <= 2; ++ j) f[i + 1][1][j] = mod((ll)f[i + 1][1][j] + mod((ll)f[i][0][j] + f[i][2][j])), f[i + 1][2][j] = mod((ll)f[i + 1][2][j] + f[i][1][j]); 
	}
	for(int i = 0; i <= 2; ++ i){
		for(int j = 0; j <= i; ++ j){
			ans = mod((ll)ans + f[n][j][i]);
		}
	}
	printf("%d", ans);
	return 0;
}

```

---

## 作者：Doubeecat (赞：0)

> [AGC022E Median Replace](https://www.luogu.com.cn/problem/AT3950)
> 
> 给出一个长度为奇数 $n$ 的残缺 $01$ 串，问有多少种补全方法，每次将连续三个位替换为它们的中位数后，能有一种方案使它变为 $1$。
>
> $n\leq 3\times 10^5$

<!-- more -->

## 解题思路：

考虑如何判断合法，题目操作本质是 $000$ 变为 $0$，$111$ 变为 $1$，删去 $10,01$

维护一个栈，从左往右加入每一个字符，如果栈顶为 $0$ 那么就将 $0$ 留下，直到有连续 3 个 0 的时候删掉两个。

若新加入了 1，删去栈顶的 0 和新加入的 1。如果栈顶为 1 ，那么不管加入什么都留下。通过这个可以得出新的 $j',k'$

栈里必定是若干 $1$ 接上若干 $0$，当 $1$ 个 $1$ 的段数大于等于 $2$ 个 $0$ 的段数或者最后只有 1 的时候，串就是美丽的。

定义 $f_{i,j,k}$ 表示考虑前 $i$ 位，当前有 $j$ 个 $1$ 和 $k$ 个 $0$ 的方案数，枚举❓是 $0/1$ 转移。
那么转移需要分类讨论一下了：

- 若加入的是 $1$
    - 若栈里已经有至少 $1$ 个 $0$，直接抵消，$f_{i-1,j,k} \to f_{i,j,k-1}$ （$01$ 无用）
    - 否则，若栈里有 $2$​​ 个 $1$​​，加入后无影响不改变 $f_{i-1,2,k} \to f_{i,2,k}$​​ 
    - 否则，栈里 $1$​​ 个数 $+1$​​ $f_{i-1,j,k} \to f_{i,j+1,k}$​​ 

- 若加入的是 $0$ 

    - 若栈里已有 $2$ 个 $0$ 消成 $1$ 个，$f_{i-1,j,2} \to f_{i,j,1}$
    - 否则栈里 $0$ 个数 $+1$ $f_{i-1,j,k} \to f_{i,j,k+1}$

- 若加入的是 $?$

    分别当成 $0/1$ 转移即可。

不难发现我们的 $j,k \leq 2$ 代码并不难写。

时间复杂度 $O(n)$


## 代码：

```cpp
char s[N];
int f[N][3][3],n,ans;

signed main() {
    #ifndef ONLINE_JUDGE
        freopen("test.in","r",stdin);
        freopen("test.out","w",stdout);
    #endif
    f[0][0][0] = 1;
    scanf("%s",s+1);
    n = strlen(s+1);
    for (int i = 1;i <= n;++i) {
        for (int j = 0;j <= 2;++j) {
            for (int k = 0;k <= 2;++k) {
                if (s[i] == '0') {
                    if (k < 2) f[i][j][k+1] = (f[i][j][k+1] + f[i-1][j][k]) % mod;
                    else f[i][j][1] = (f[i][j][1] + f[i-1][j][k]) % mod;
                }
                if (s[i] == '1') {
                    if (k) {
                        f[i][j][k-1] = (f[i][j][k-1] + f[i-1][j][k]) % mod;
                    } else {
                        if (j < 2) f[i][j+1][k] = (f[i][j+1][k] + f[i-1][j][k]) % mod;
                        else f[i][2][k] = (f[i][2][k] + f[i-1][j][k]) % mod;
                    }
                }
                if (s[i] == '?') {
                    if (k < 2) f[i][j][k+1] = (f[i][j][k+1] + f[i-1][j][k]) % mod;
                    else f[i][j][1] = (f[i][j][1] + f[i-1][j][k]) % mod;
                    
                    if (k) {
                        f[i][j][k-1] = (f[i][j][k-1] + f[i-1][j][k]) % mod;
                    } else {
                        if (j < 2) f[i][j+1][k] = (f[i][j+1][k] + f[i-1][j][k]) % mod;
                        else f[i][2][k] = (f[i][2][k] + f[i-1][j][k]) % mod;
                    }
                }
            }
        }
    }
    for (int i = 0;i <= 2;++i) {
        for (int j = 0;j <= i;++j) {
            ans = (ans + f[n][i][j]) % mod;
        }
    }

    printf("%lld\n",ans);
    #ifndef ONLINE_JUDGE
        fclose(stdin);fclose(stdout);
    #endif
	return 0;
}

```

---


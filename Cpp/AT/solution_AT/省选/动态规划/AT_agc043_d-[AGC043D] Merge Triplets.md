# [AGC043D] Merge Triplets

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc043/tasks/agc043_d

正整数 $ N $ が与えられます。 $ (1,2,\cdots,3N) $ の順列 $ (P_1,P_2,\cdots,P_{3N}) $であって、次の操作によって生成されうるものの数を求めてください。 ただし、答えは非常に大きくなることがあるので、素数 $ M $ で割ったあまりを求めてください。

- 長さ $ 3 $ の数列を $ N $ 個用意する。この数列たちを $ A_1,A_2,\cdots\ ,A_N $ とする。この $ 3N $ 個の値には $ 1 $ から $ 3N $ がちょうど一度ずつ登場せねばならない。
- 空の数列 $ P $ を用意する。以下の操作を $ 3N $ 回繰り返す。
  - 各数列 $ A_i $ のうち、空でないものの先頭の要素を見て、そのうち最小の要素を $ x $ とする。
  - $ x $ を $ A_i $ から消去する。 $ P $ の最後尾に $ x $ を追加する。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2000 $
- $ 10^8\ \leq\ M\ \leq\ 10^9+7 $
- $ M $ は素数
- 入力はすべて整数

### Sample Explanation 1

すべての長さ $ 3 $ の順列が条件を満たします。

## 样例 #1

### 输入

```
1 998244353```

### 输出

```
6```

## 样例 #2

### 输入

```
2 998244353```

### 输出

```
261```

## 样例 #3

### 输入

```
314 1000000007```

### 输出

```
182908545```

# 题解

## 作者：xht (赞：33)

考虑已知每个序列，我们是如何构造排列的。

按照题意，每次选择最小的开头放入排列，然后扔掉。

这意味着，由于序列长度为 $3$，排列中一定不会出现连续四个（或以上）的数 $x_{1\dots 4}$，满足 $x_1 > x_{2\dots 4}$。

因此，**最终的排列中，按照前缀 $\max$ 的位置划分，每一段的长度不超过 $3$**，这是必要条件。

充分吗？不充分，比如 $2\ 1\ 4\ 3\ 6\ 5$ 就不可以。

我们发现，按照前缀 $\max$ 的位置划分，有三个长度为 $2$ 的段，而我们没办法讲其拼成两个长度为 $3$ 的序列。

于是另一个必要条件为，**长度为 $2$ 的段个数不超过长度为 $1$ 的段个数**。

充分吗？充分，因为一旦满足这个条件，我们就能构造出来序列。

那么考虑如何计数，设 $f_{i,j}$ 表示考虑前 $i$ 个数，**长度为 $1$ 的段个数减去长度为 $2$ 的段个数**为 $j$ 的方案数。

转移时枚举下一段的长度 $1/2/3$ 即可，如果长度不为 $1$ 还要额外乘上系数，具体见代码。

时间复杂度 $\mathcal O(n^2)$。

```cpp
const int N = 2e3 + 7, M = N * 3;
int n;
modint f[M][M<<1], ans;

int main() {
	rd(n), rd(P), n *= 3;
	f[0][M] = 1;
	for (int i = 0; i < n; i++)
		for (int j = -i; j <= i; j++) {
			f[i+1][j+1+M] += f[i][j+M];
			f[i+2][j-1+M] += f[i][j+M] * (i + 1);
			f[i+3][j+M] += f[i][j+M] * (i + 1) * (i + 2);
		}
	for (int j = 0; j <= n; j++) ans += f[n][j+M];
	print(ans);
	return 0;
}
```

---

## 作者：pufanyi (赞：12)

首先我们不难发现这个序列在一定程度上肯定是有单调性的，因为本身这个生成的方式就是一个单调的过程。

我们发现对于一个块 $\{a,b,c\}$，如果 $a>b$，那 $b$ 一定是紧跟在 $a$ 后面的。而如果 $a<b$，那么我们不难发现这个快可以分裂成两个，也就是 $\{a\},\{b,c\}$，因为 $b$ 肯定在 $a$ 之后选。

那么也就是说，我们现在的情况是，有一些长度为 $1,2,3$ 的块，每个块都是的开头都是最大的。这给我们了一个提示，因为这样的东西给了我们一个将构造方法和序列连结起来的桥梁。因为这个东西与序列一一对应，这个只要将首字母排序一下就可以了。那么我们现在就只要考虑把划分后的块和划分前的块一一对应就可以了。

也就是说我们需要找到其充要条件。我们发现，其实长度为 $3$ 的块再多也不要紧，因为本来的块就是长度 $3$ 的，我们考虑划分后的块。不难发现每次划分要么就是去掉一个长度为 $3$ 的块，加上一个长度为 $2$ 的块和一个 $1$ 的块，要么就是将一个 $2$ 的块划分成两个 $1$ 的块。我们考虑这件事情，就不难发现这个条件了：$2$ 的块数小于等于 $1$ 的块数。

现在我们只要将划分完的块拼起来就可以了。也就是说，一个序列合法的充要条件是：存在一种划分方案，使得划分后每个块大小小于等于 $3$，而且每个块的开头是块中最大的，且比其之前的数都要大。经过之前的推导，我们也知道了这种划分方案是唯一的。

我们思考这东西怎么计算，我们先考虑如果划分方案已经给出，数字随便填，这样有几种方案。

我们发现，一些限制就是：$a_i$ 在 $[1,r]$ 中是最大的。如果长度为 $n$，那么答案就是 $\frac{n!}{\prod r}$。于是我们用这个性质就可以 `dp` 了。

我们令 $f_{i,j}$ 表示如果排列的长度为 $i$（只能填前 $i$ 个数），长度为 $1$ 的块的个数减去长度为 $2$ 的块的个数为 $j$ 的方案数。其实就是考虑右面加一个什么样的块。根据上面的式子，我们不难得到：

![](https://i.loli.net/2020/04/01/aDJZ48j2oH1U3kY.png)

（由于本人不是很会 $\LaTeX$，所以上面的公式好像不是很会打，如果想要更舒服的体验可以直接看[我的博客](https://pufanyi.github.io/oi-blog/agc043_d/)）

然后就可以愉快地转移啦！

---

## 作者：qiqing (赞：9)

> **题意**：给定如下构造长度为$3n$的排列$P$的方法：
>
> * 生成长度为$3n$的排列$A$， 然后将 $\forall k \in [0, N-1]$，$A_{3k+1},A_{3k+2},A_{3k+3}$分成一块 
> * 有$n$个指针，初始指向每个块的第一个数 
> * 每次选择指针中最小的数放到 $P$的末尾 ，然后指针指向块内后一个数
>
> 求排列$P$总共有多少种

### 题解

先手模几个排列P，然后发现这些排列有一些性质

![p1](https://cdn.luogu.com.cn/upload/image_hosting/xmdcjjbm.png)

* 排列中存在一些单调的片段，比如

![p2](https://cdn.luogu.com.cn/upload/image_hosting/vebrc0qy.png)


* 每个单调片段的首项递增

![p3](https://cdn.luogu.com.cn/upload/image_hosting/j8cwmw21.png)

> 构造排列P的方式是有单调性的，所以显然排列P也是有单调性的
>
> 若存在$A_1>A_2$或者$A_2>A_3$，则这两个数会被相邻地取出
>
> 若存在$A_1>A_2$并且$A_1>A_3$，则这三个数也会被相邻取出
>
> **必然相邻取出**的情况分进一个单调内，块的大小不超过3
>
> $\because$ *大小为2的块、大小为1的块一定成对出现*
>
> $\therefore$ 大小为2的块的数量 $\leqslant$ 大小为1的块的数量
>
> 在构造块的过程中，一定会按照*块的第一个元素*的大小进行排序构造出一个排列
>
> 因此，如果块合法，可以**唯一确定一个排列P**

考虑若块已知，如何填数，方案为$\displaystyle\frac{n!}{\displaystyle\prod_{i=1}^{k}(\sum_{j=1}^{i}a_j)}$

考虑**差值DP**

设$\texttt {c[i]}$表示大小为$\texttt i$的块的数量

设$\texttt {dp[i][j]}$表示长度为$\texttt i$，$\texttt {c[1] - c[2]}$为$\texttt j$的排列P的方案数

考虑右边增加的块进行转移

1. 增加大小为1的块

$$
\texttt {dp[i + 1][j + 1] = dp[i][j]}
$$

2. 增加大小为2的块

$$
\texttt {dp[i + 2][j - 1] = dp[i][j] * (i + 1)}
$$

3. 增加大小为3的块

$$
\texttt {dp[i + 3][j] = dp[i][j] * (i + 1) * (i + 2)}
$$

最后答案就是$\displaystyle\sum_{\texttt {i=1}}^{\texttt n}\texttt {dp[3 * n][i]}$

## 

---

## 作者：lanos212 (赞：6)

考虑探究一个排列是怎么被生成的。

这是一个将 $N$ 个三元序列进行类似归并排序的过程，这里记第 $i$ 个序列为 $A_i$。

那么如果被归并的序列都是升序的，即 $A_{i,1}<A_{i,2}<A_{i,3}$，我们将得到一个有序的序列：

![](https://cdn.luogu.com.cn/upload/image_hosting/z5wc12m9.png)

那么如果序列不是升序的，如序列 $B$ 中出现 $B_1<B_2>B_3$ 的情况，那么我们发现 $B_3$ 在得到的排列中，会紧跟在 $B_2$ 的后面。

又如 $B_1>B_2>B_3$ 的情况，我们发现 $B_2$ 会紧跟在 $B_1$ 后面，$B_3$ 会紧跟在 $B_2$ 后面。

那么所有跟从的情况如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/0edanzd1.png)

这里可以看出一些性质：

- 一个非跟随数，后面跟随的数字个数在 $0\sim 2$ 之间。

- 一个非跟随数，后面跟随的数字比自己小。

- 后面跟随 $0$ 个数的非跟随数个数**不少于**后面跟随 $1$ 个数的非跟随数个数。

---

现在考虑如何利用性质计算答案。

下文中，不作为跟随在别的数后面的数将会被**标红**。

那么这样，所有标红的数是答案排列中的**大于前面所有数**的数。

例如 $A_1=\{{\color{Red}2},1,{\color{Red}3}\},A_2=\{{\color{Red}6},5,4\}$，则最终排列 $P=\{{\color{Red}2},1,{\color{Red}3},{\color{Red}6},5,4\} $。

由此可得，如果两个最终排列中标红数字组成的序列不同，那么这两个最终排列一定不同。

那么可以初步定下计算的思路，我们在计算非跟随数的方案数时，同时计算上其跟随的数分配方案即可。

根据上面的性质，可以推得一个最终排列的性质：

- 等价于若干个非跟随数带上后面的跟随数，按照非跟随数本身从小到大排序的方式组合。

- 其中，后面跟随 $0$ 个数的非跟随数个数**不少于**后面跟随 $1$ 个数的非跟随数个数。

这个性质是充要条件，必要性已说明，充分性可以简单构造，在这里不赘述。

那么我们考虑从 $\{1,2,\dots,3N\}$ 这样一个集合开始，不断将剩余数中最大的作为非跟随数（剩余最大数显然不能再作为跟随数），分割出非跟随数，顺带为其配上相应的跟随数。

这个过程得到的方案数，可以直接用 DP  计算。

设计状态 $f_{i,j}$ 表示，还剩下 $i$ 个数待分割，跟随 $0$ 个数的非跟随数个数比跟随 $1$ 个数的非跟随数个数多 $j$ 个。

直接对于以下三种情况转移即可：

- 单独割去最大数，剩余 $i-1$ 个数继续进行分割。

- 割去最大数，在其余 $i-1$ 个数中选一个作为跟随数，剩余 $i-2$ 个数继续进行分割。

- 割去最大数，在其余 $i-1$ 个数中选两个作为跟随数（注意，这两个数前后顺序不同是不同的方案），剩余 $i-3$ 个数继续进行分割。

![](https://cdn.luogu.com.cn/upload/image_hosting/85yazj42.png)

时间复杂度 $O(N^2)$。

code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,mo,f[6001][9001];
int main(){
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>mo;
	f[3*n][3000]=1;
	for (int i=3*n;i;--i) for (int k=0;k<=9000;++k) if (f[i][k]){
		for (int j=1;j<=3;++j) if (j<=i){
			if (j==1) f[i-1][k+1]=(f[i-1][k+1]+f[i][k])%mo;
			if (j==2) f[i-2][k-1]=(f[i-2][k-1]+f[i][k]*(i-1))%mo;
			if (j==3) f[i-3][k]=(f[i-3][k]+f[i][k]*(i-1)*(i-2))%mo;
		}
	}
	long long ans=0;
	for (int i=3000;i<=9000;++i) ans=(ans+f[0][i])%mo;
	cout<<ans;
	return 0;
}
```


---

## 作者：lzk5627 (赞：6)

### sol
直接对构造的三元组显然是不好计算的

于是我们可以考虑直接计算合法的序列 $P$

首先会发现一个必要条件是连续下降子串长度不超过 $3$

考虑证明:

对于一个三元组 $(x_i,x_{i+1},x_{i+2})$,只有当 $x_i>x_{i+1}$ 的时候才会出现下降的情况,而且选了 $x_i$ 之后下一个必然会选 $x_{i+1}$ ,所以最长下降子串不超过 $3$,同时第一个位置被选当且仅当它是一个前缀最大值

于是我们就可以把每一个前缀最大值的分成一段, $P$ 合法的必要条件之一就是每段的大小都不超过 $3$

然后考虑如下构造,把排列看成一些段,长度为 $1,2,3$ ,然后把 $1,2$ 拼接起来变成一个三元组,然后发现这样还需要满足长度为 $2$ 的串的数量要小于等于长度为 $1$ 的串的数量,因为对于每一个满足条件的排列我们都可以构造出来一组三元组,所以这就是 $P$ 合法的充要条件

设每一段的大小为 $a_1 , a_2....... a_k$ 的话,那么选择的方案数就是 $\frac{n!}{a_1(a_1+a_2)......(a_1+a_2+.....+a_k)}$,其实就是强制每一段的开头是前缀最大值

于是就可以考虑设 $f_{i,j}$ 表示考虑了前 $i$ 个数,长度为1的段的数量-长度为2的段的数量为 $j$ 的方案数,转移是 O(1) 的.

---

## 作者：dead_X (赞：5)

## 前言
APIO 观光团（
## Part 1
注意到如果一个序列里有一个下降的段，例如 $3,2,1$。

这个段肯定会在第一个数被选出来之后**立刻**被选完，原因显然。

于是我们可以把下降的段缩成一段，这一段的值为其第一个数的值。

这步转化之后，合并的过程就变成了一个正常的归并排序，即按照值从小到大排序。
## Part 2
然后考虑如何判定一个序列能不能被构造出来。

显然一个序列只能提供以下三种之一：

* 长度为 $3$ 的下降序列。
* 一个长度为 $2$ 的下降序列和一个长度为 $1$ 的下降序列。
* 三个长度为 $1$ 的下降序列。

因此，长度为 $3n$，仅包含长度为 $1,2,3$ 的下降序列，且长度为 $2$ 的下降序列不多于长度为 $1$ 的下降序列的所有序列都可以被构造出来。

于是 dp 就好了。
## Code
```cpp
// Problem: AT5801 [AGC043D] Merge Triplets
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT5801
// Memory Limit: 1000 MB
// Time Limit: 6000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int p=998244353;
int f[6003][9003];
signed main()
{
	int n=read(),m=n*3,C=m>>1;
	p=read(),f[0][C]=1;
	for(int i=1; i<=m; ++i)
	for(int j=-(i>>1); j<=i; ++j)
		f[i][j+C]=f[i-1][j-1+C],
		(i>=2)&&(f[i][j+C]=(f[i][j+C]+1ll*f[i-2][j+1+C]*(i-1)%p)%p),
		(i>=3)&&(f[i][j+C]=(f[i][j+C]+1ll*f[i-3][j+C]*(i-1)%p*(i-2)%p)%p);
	int ans=0;
	// for(int i=0; i<=m; ++i,puts(""))
	// for(int j=0; j<=i; ++j) printf("%d ",f[m][j+C]);
	for(int j=0; j<=m; ++j) ans=(ans+f[m][j+C])%p;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Grisses (赞：3)

怎么都是写的 dp？

---

首先，所有的题解都提到了降序的块长度不超过 3，并且要求长度为 2 的块数量不多于长度为 1 的块。

然后我们发现可以枚举长度为 3 或 2 的块的数量，这是 $O(n^2)$ 的。

假设有 $a$ 个长度为 3 的块，$b$ 个长度为 2 的，那么首先要求 $b\le 3n-3a-2b$，然后我们考虑推个式子来求这种情况的方案数。 

首先我们要选出 $3a$ 个数组成 $a$ 个段，然后选 $2b$ 个数组成 $b$ 个段，然后显然每个段会有一个最大值，最后的序列是将段按照最大值递增的顺序排布，所以这部分的方案数为 $\dbinom{3n}{3a}\dbinom{3n-3a}{2b}f(a)g(b)$，其中 $f(x)$ 为 $x$ 个长度为 3 的段在确定的数之后的排布方案数，$g(x)$ 为 $x$ 个长度为 2 的段在确定的数之后的排布方案数。

我们先考虑 $g(x)$，从 $2x$ 个数中我们先选出 $x$ 个再将剩下的 $x$ 个数分到前 $x$ 个组里，一共 $\dbinom{2x}{x}x!$ 种，但是这样显然会把每一组算两次，所以 $g(x)=\dfrac{\dbinom{2x}{x}x!}{2^x}$。

同理 $f(x)=\dfrac{\dbinom{3x}{x}(2x)!}{3^x}$。

---

所以答案为 $\sum\limits_{0\le a,b\wedge b\le 3n-3a-2b}\dbinom{3n}{3a}\dbinom{3n-3a}{2b}\times \dfrac{\dbinom{3a}{a}(2a)!}{3^a}\times \dfrac{\dbinom{2b}{b}b!}{2^b}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int c[10005],inc[10005];
int n,mod,ans;
int fpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
int C(int n,int m){
	if(n<m||n<0||m<0)return 0;
	return c[n]*inc[m]%mod*inc[n-m]%mod;
}
int f(int x){
	return c[3*x]*inc[x]%mod*fpow(3,mod-1-x)%mod;
}
int g(int x){
	return c[2*x]*inc[x]%mod*fpow(2,mod-1-x)%mod;
}
signed main()
{
	scanf("%lld%lld",&n,&mod);
	n*=3;
	c[0]=1;
	for(int i=1;i<=10000;i++)c[i]=c[i-1]*i%mod;
	inc[10000]=fpow(c[10000],mod-2);
	for(int i=9999;i>=0;i--)inc[i]=inc[i+1]*(i+1)%mod;
	for(int a=0;3*a<=n;a++){
		for(int b=0;2*b+3*a<=n;b++){
			if(n-2*b-3*a>=b){
				ans=(ans+C(n,3*a)*C(n-3*a,2*b)%mod*f(a)%mod*g(b)%mod)%mod;
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：larsr (赞：3)

假设一个块内的数是 $[A,B,C]$。以下定理显然：

- 如果 $A>B$，当 $A$ 加入 $P$ 之后，$B$ 会马上加入 $P$。
- 如果 $A>B,C$，当 $A$ 加入 $P$ 之后，$B,C$ 会马上加入 $P$。

由此可知，如果 $A < B$，那么将这个块分成 $[A]$ 和 $[B,C]$ 后生成的序列 $P$ 也是一样的。对于其他的一些情况也一样这么分裂。

那么这道题就很显然了，把一个 $P$ 分裂成好几个块满足 $P_l = \max_{l\le i\le r}P_i$（并且尽量大），如果把这些块合并随便组合（不按顺序）后可以是 $n$ 个长度为 $3$ 的块，那么 $P$ 就可以构造出来。

$P$ 分的块的长度要小于等于 $3$。可列状态 $f_{i,a,b,c}$ 代表前 $i$ 数中有 $a$ 个长度为 $1$ 的块，$b$ 个长度为 $2$ 的块，$c$ 个长度为 $3$ 的块的状态数。但这么列肯定超时。

- 发现递推时有时需要乘数值 $i$。
- 想满足这些块可以组成 $n$ 个长度为 $3$ 的块，要保证 $i = 3n$ 且 $b + c\le n$。

那么只维护 $i$ 和 $b+c$ 即可，设状态 $f_{i,j}$ 代表 $j$ 个数中 $i$ 个块长度大于 $1$ 的方案数。递推式：

$$
\begin{aligned}
  f_{i,j+1} &\gets f_{i,j} \\
  f_{i+1,j+2} &\gets (j+1)f_{i,j} \\
  f_{i+1,j+3} &\gets (j+1)(j+2)f_{i,j}
\end{aligned}
$$

答案为：

$$\sum_i^n f_{i,3n}$$

Code:
```cpp
#include<cstdio>
#define ll long long
using namespace std;
ll dp[2010][6010], mod;
int n;
void add(int x, int y, ll a)
{
        dp[x][y] = (dp[x][y] + a) % mod;
}
int main()
{
        dp[0][0] = 1;
        scanf("%d%lld", &n, &mod);
        ll ans = 0;
        for(int i = 0; i <= n; i++)
                for(int j = 0; j <= 3 * n; j++)
                {
                        add(i, j + 1, dp[i][j]);
                        add(i + 1, j + 2, dp[i][j] * (j + 1));
                        add(i + 1, j + 3, dp[i][j] * (j + 1) * (j + 2));
                        if(j == 3 * n)ans = (ans + dp[i][j]) % mod;
                }
        printf("%lld\n", ans);
        return 0;
}

```

---

## 作者：_Cheems (赞：3)

令块 $i$ 中的元素分别为 $a_{i,1/2/3}$。

假如 $\forall i,a_{i,1}<a_{i,2}<a_{i,3}$，那么生成的排列 $P$ 就是其升序排列。

考虑块内元素，若 $a_{i,j}>a_{i,j+1}$ 则 $P$ 中 $a_{i,j},a_{i,j+1}$ 必然相邻、若 $a_{i,1}>a_{i,2},a_{i,3}$ 则 $a_{i,1},a_{i,2},a_{i,3}$ 必然相邻。

于是让满足条件块内的元素绑在一起，关注其第一个元素，那么就转化成升序排列了。

考虑判定 $P$ 是否合法，将降序序列绑起来，那么其长度必须 $=1/2/3$，且开头元素必然递增。

这是充要条件吗？手摸构造一下：首先排除长度 $3$ 的，然后可以让长度 $1$ 和长度 $2$ 的放在一起，最后必然剩下若干 $1$，其个数为 $3$ 的倍数。

由于 $2$ 只能与 $1$ 配对，所以得出结论：只要 $2$ 个数小于等于 $1$ 个数即可。

怎么计数？记 $f_{i,j}$ 表示考虑 $i$ 个元素，$1$ 与 $2$ 个数之差为 $j$ 的绑定方案。

转移：$f_{i,j}=f_{i-1,j-1}+f_{i-2,j-1}\times (i-1)+f_{i-3,j-2}\times (i-1)\times (i-2)$。

复杂度 $O(n^2)$。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define ADD(a, b) a = (a + (b)) % mod
const int N = 6e3 + 5;
int n, mod, f[N][N << 1], ans;

signed main(){
	cin >> n >> mod, n *= 3;
	f[0][n] = 1; 
	for(int i = 1; i <= n; ++i)
		for(int j = 0; j <= 2 * n; ++j){
			ADD(f[i][j], f[i - 1][j - 1]);
			if(i >= 2) ADD(f[i][j], f[i - 2][j + 1] * (i - 1) % mod);
			if(i >= 3) ADD(f[i][j], f[i - 3][j] * (i - 1) % mod * (i - 2) % mod);
		}
	for(int j = n; j <= 2 * n; ++j) ADD(ans, f[n][j]);
	cout << ans;
	return 0;
}
```

---

## 作者：tzc_wk (赞：3)

一道挺有意思的数数题。

首先碰到这样的问题我们肯定要考虑什么样的排列符合要求。我们考虑 $n$ 的位置——显然只有在迫不得已，即另外 $n-1$ 个指针都已经被摧毁的时候才会将 $n$ 加入序列，因此在 $n$ 后面的元素肯定跟 $n$ 是在一组的，我们完全可以把这些元素**捆在一起**，显然如果 $n$ 后面元素个数 $\ge 4$ 就直接不合法了，否则我们考虑删除这些元素，接着考虑序列中最大的元素，依次类推下去即可。因此对于一个排列 $p$，它可以成为合法的排列的**必要条件**是：如果我们每次找出序列最大的元素并将其后面的元素全部删除，那么每次删除的元素个数 $\le 3$。为什么说是“必要条件”呢？因为考虑排列 $p=(2,1,4,3,6,5)$，虽然它每次删除的数的个数都 $\le 3$（$=2$），但就是无法找到某个排列 $p'$ 使得 $p'$ 能够生成 $p$。因为我们不仅要将这些元素捆在一起，还要将它们**组成若干个三元组**，而三个 $2$ 无法通过组合变成两个 $3$，因此不可行。所以我们还要使拆出的数能够构成若干个三元组，$3$ 自然可以单独成一组，我们 duck 不必管它，$2$ 显然只能和 $1$ 配对，如果 $2$ 的个数严格多于 $1$ 的个数那就会存在多余的 $2$，也就不合法了，因此我们还要让拆出来的 $2$ 的个数 $\le 1$ 的个数。

到这里此题排列 $p$ 的性质都已经分析完了，我们先考虑如何暴力地求答案，以 $n=2$ 为例，我们枚举拆出的每段按顺序的值分别是多少，显然共有 $1,1,1,1,1,1$、$1,1,1,1,2$、$1,1,1,2,1$、$1,1,2,1,1$、$1,2,1,1,1$、$2,1,1,1,1$、$1,1,1,3$、$1,1,3,1$、$1,3,1,1$、$3,1,1,1$，$1,1,2,2$、$1,2,1,2$、$1,2,2,1$、$2,1,1,2$、$2,1,2,1$、$2,2,1,1$、$1,2,3$、$1,3,2$、$2,1,3$、$2,3,1$、$3,1,2$、$3,2,1$、$3,3$ 这些种可能，考虑怎样计算每一种可能的答案，以 $1,3,2$ 为例，显然由于最后一组为 $2$，因此 $6$ 必须填第 $5$ 个位置，这样一来最后一个元素就有 $5$ 种可能，确定最后一个元素后，剩余 $4$ 个元素中最大值的位置就定下来了，剩下来 $a_3,a_4$ 还有 $A_{3}^2=6$ 种可能，第一个元素也就只有 $1$ 种选择了，所以这种情况的贡献为 $30$，建议读者手算一下 $n=2$ 的情况，看看是不是 $261$，虽然有点烦但对正解有很强的启发性作用。

相信通过上面手算的过程我们可以看出，假设从左到右每一段长度分别为 $a_1,a_2,\cdots,a_k$，那么方案数就是 $\dfrac{n!}{a_1(a_1+a_2)(a_1+a_2+a_3)\cdots(a_1+a_2+\cdots+a_k)}$，这样就可以 $dp$ 了，$dp_{i,j}$ 表示考虑到第 $i$ 个元素，$1$ 的个数减去 $2$ 的个数等于 $j$ 的方案数，转移显然可以 $\mathcal O(1)$，总复杂度 $n^2$。

```cpp
const int MAXN=6000;
const int DELTA=6002;
int n,mod,ans=0;
int dp[MAXN+5][MAXN*2+5];
void add(int &x,int v){((x+=v)>=mod)&&(x-=mod);}
int main(){
	scanf("%d%d",&n,&mod);n*=3;dp[0][DELTA]=1;
	for(int i=0;i<n;i++) for(int j=DELTA-n;j<=DELTA+n;j++) if(dp[i][j]){
		add(dp[i+1][j+1],dp[i][j]);
		if(i+2<=n) add(dp[i+2][j-1],1ll*dp[i][j]*(i+1)%mod);
		if(i+3<=n) add(dp[i+3][j],1ll*dp[i][j]*(i+1)%mod*(i+2)%mod);
	} for(int i=DELTA;i<=DELTA+n;i++) add(ans,dp[n][i]);
	printf("%d\n",ans);
	return 0;
}
```

当然 lxr 总有比我更 nb 的做法，我们不考虑什么 DP，直接枚举 $2,3$ 的个数计算方案数，假设 $1,2,3$ 个数分别为 $c_1,c_2,c_3$，那么显然对于每个块我们给它们填上数的方案数是一个多重组合数的形式，即 $\dbinom{n}{1,1,\cdots,1,2,2,\cdots,2,3,3,\cdots,3}$，其中下面 $1,2,3$ 分别是 $c_1,c_2,c_3$ 个，套用多重组合数公式算一下是 $\dfrac{n!}{2^{c_2}6^{c_3}}$，那么显然我们给这些块填好数后，我们肯定会按照最大数的大小从小到大将这些块排成一列，当然所有 $1,2,3$ 都视作相同元素，因此还需除以 $\dfrac{1}{c_1!c_2!c_3!}$。对于长度为 $3$ 的块还有 $3,1,2$ 和 $3,2,1$ 两种填数的方法，因此还要乘上 $2^{c_3}$，故对于某对 $c_1,c_2,c_3$，填数的方案数就是 $\dfrac{n!}{c_1!c_2!c_3!2^{c_2}3^{c_3}}$，这个随便算算就行了。

~~不过似乎这个做法依赖于 $m$ 是质数？~~

~~代码？sorry，暂（yong）时（jiu）没有代码，不过代码难度这么低的题为什么还要参考别人的代码呢？~~

---

## 作者：Limury (赞：2)

设块中的三个数分别是 $A,B,C$。

如果 $A > B$，则输出完 $A$ 一定会输出 $B$，如果 $B > C$，则输出完 $B$ 一定会输出 $C$，如果 $A > B > C$，则这个块就输出完了。

所以最后的生成序列一定可以分成很多大小为 $1,2,3$ 的块，满足：

* 其中大小为 $2$ 的块数量小于等于大小为 $1$ 的块。

* 每个块满足其中数递减。

* 每个块的第一个数递增。

当我们确定了序列中的块长分别是 $l_1, l_2, ...l_k$，则对于每个块的第一个数，要求填包含其最大的数，则方案数就是 $\Large \frac{n!}{\prod_{j = 1}^{k}(\sum_{i = 1}^{j}l_i)}$。

根据最终序列的性质考虑 $dp$，设 $f_{i,j}$ 为当前长度为 $i$，长度为 $1$ 的块数和长度为 $2$ 的块数的差为 $j$。

可以得到转移：

$$f_{i,j} = f_{i - 1, j - 1} + f_{i - 2,j + 1} \times (i - 1) + f_{i - 3, j} \times (i - 1) \times (i - 2)$$

```cpp
cin >> n >> mod;
n *= 3;
m = n * 2;
f[0][m] = 1;
for (int i = 1; i <= n; i ++){
	for (int j = -i; j <= i; j ++){
		f[i][j + m] += f[i - 1][j + m - 1] % mod, f[i][j + m] %= mod;
		if (i >= 2)
			f[i][j + m] += 1ll * f[i - 2][j + m + 1] * (i - 1) % mod, f[i][j + m] %= mod;
		if (i >= 3)
			f[i][j + m] += 1ll * f[i - 3][j + m] * (i - 1) % mod * (i - 2) % mod, f[i][j + m] %= mod;
		if (i == n && j >= 0)
			ans += f[i][j + m] + mod, ans %= mod;
	}
}
```

---

## 作者：strcmp (赞：2)

设原序列 $a$，生成序列 $p$。

每次都是取最小，然后 `pop_front`。

这启发我们得到的排列应该满足一些单调性。

不妨任意搞一个块 $\{x,\,y,\,z\}$。

首先一个显然的观察，就是如果一个块如果是整个下降的，那么当第一次访问到块首，必然会顺着块首继续生成下去。即 $x > y > z$ 则第一次遇到 $x$ 必然之后接着 $y$ 和 $z$。更强的结论是 $x > \max(y,\,z)$ 则整个块就直接输出。

如果是 $z > x > y$  呢？那我们可以直接看作 $\{x,\,y\}$ 和 $\{z\}$ 两个块，因为 $x$ 所在块一定先比 $z$ 先选完。

这就告诉我们按前缀最大值分块，搞出来一些大小为 $1,\,2,\,3$ 的块，而且块首单调递增。

得到我们构造的排列的性质：

- 连续极长下降段长度不超过 $3$，下降段首是递增的。

- 长度为 $2$ 的下降段必然伴随着一个长度为 $1$ 的下降块，即前者的数量不多于后者的数量。

经过打表和构造容易得到这两个条件是充要的。

考虑差值 dp，设 $f_{i,\,j}$ 代表构造到第 $i$ 个位置，长度为 $1$ 下降块数量减去长度为 $2$ 下降块数量为 $j$ 的方案数。

- 分出来一个大小为 $1$ 的块，只能填 $i + 1$。

$$
f_{i + 1,\,j + 1} \leftarrow f_{i + 1,\,j + 1} + f_{i,\,j}
$$

- 分出来一个大小为 $2$ 的块，$i + 2$ 在前，$i + 1$ 位置有 $i + 1$ 种填法。

$$
f_{i + 1,\,j - 1} \leftarrow f_{i + 1,\,j + 1} + f_{i,\,j} \times (i + 1)
$$

- 分出来一个大小为 $3$ 的块，$i + 3$ 在前，后面两个位置各有 $i + 1$ 和 $i + 2$ 种填法。

$$
f_{i + 1,\,j} \leftarrow f_{i + 1,\,j + 1} + f_{i,\,j} \times (i + 1) \times (i + 2)
$$

时空复杂度 $\Theta(n^2)$ 可以通过。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define mp make_pair
#define gc getchar
#define pc putchar
using namespace std;
using ld = double;
typedef long long int ll;
typedef long long int i128;
using pli = pair<ll, int>;
using ppi = pair<pli, int>;
using vec = vector<int>;
const ll inf = 1LL << 60;
constexpr int maxn = 6e3 + 10, m = 2e3 + 3;
int n, mod, f[maxn][maxn << 1], ans;
int main() {
    scanf("%d%d", &n, &mod); n *= 3; f[0][m] = 1;
    for (int i = 0; i < n; i++) {
        for (int j = -i; j <= i; j++) {
            f[i + 1][j + m + 1] = (f[i + 1][j + m + 1] + f[i][j + m]) % mod;
            f[i + 2][j + m - 1] = (f[i + 2][j + m - 1] + (ll)f[i][j + m] * (i + 1) % mod) % mod;
            f[i + 3][j + m] = (f[i + 3][j + m] + (ll)f[i][j + m] * (i + 1) % mod * (i + 2)) % mod;
        }
    }
    for (int i = 0; i <= n; i++) ans = (ans + f[n][i + m]) % mod;
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Otue (赞：1)

## [[AGC043D] Merge Triplets](https://www.luogu.com.cn/problem/AT_agc043_d)

### 题目描述

- 给定如下构造生成长度为 $3N$ 的排列 $P$ 的方法：
  - 生成一个长度为 $3N$ 的排列 $A$。然后将 $\forall k\in[0,N - 1]$，$A_{3k + 1},A_{3k+2},A_{3k + 3}$ 分成一块。
  - 有 $N$ 个指针，初始指向每个块的第一个数。
  - 每次选择所有指针指向的数中最小的数删除，然后放到 $P$ 的末尾。之后指向被删除的数后移一个位置。若移出块了，则删除这个指针。
- 请你求出，一共能生成长度为 $3N$ 的排列共多少种。

### 题目思路

首先发现一个块内如果删除掉一个数后，紧接在它后面且比他小的数会挨着被删除。所以可以按照降序分成很多块，块内满足第一个数大于后面所有数。分成很多块后可以发现，块首元素单调递增。因此块首元素是前缀 $\max$。

其次发现最终生成的序列不存在连续的四个数满足第一个数大于第二三四个数。因此块长不超过 $3$。

同时在操作过程中，最开始的块长为 $3$ 的块可以分裂成块长为 $2$ 的块和块长为 $1$ 的块，或者分裂成三个块长为 $1$ 的块。因此发现块 $2$ 个数小于等于块 $1$ 个数。

满足这两个条件就一定可以构造序列了。那么直接开始计数好了。在计数过程中，我们需要求解问题：如果 $i$ 是块尾，那么最终序列个数为 $\dfrac{n!}{∏i}$。发现计数过程中，不需要关心每个位置填什么数，只需要关心当前位置填不填前缀最大值。

定义 $f_{i,j}$ 表示前 $i$ 个数，块 $1$ 个数减去块 $2$ 个数为 $j$ 的方案数。转移有：

* $f_{i+1,j+1}←f_{i,j}$。表示 $[i+1]$ 单独为一块。
* $f_{i+2,j-1}←f_{i,j}\times (i+1)$。表示 $[i+1,i+2]$ 单独为一块。
* $f_{i+3,j}←f_{i,j}\times (i+1)(i+2)$。表示 $[i+1,i+2,i+3]$ 单独为一块。

---

## 作者：Fading (赞：1)

前天 noip 模拟赛阴间原题哥把这题魔改了一下拿来考，然后我现场脑残方向走错了，花了好久想了一个巨麻烦但是结论和题解几乎一致的做法，~~可惜最后大样例调不出来，手玩的小数据都过了，忘记还能对拍，于是就暴毙了。数据一下发就知道哪里挂了。。。~~

那题只有 $2$ 组，每组 $n$ 个，对于那题玩一下样例也许可以猜出结论？

如果不和我一样作死尝试用数学模型解题，就可以切了...有些~~吊打我的~~同学也没猜到结论。

直接讲这题吧。

考虑对于要计数的排列 $p$（长度为 $3n$）进行划分，化成长度为 $3$ 的 $n$ 组。我们考虑过 $p_1$ 的那个组需要满足什么条件。

这其实可以看成偏序关系，然后建个 DAG 看看能不能分就好了。考虑$i$的下方是 $j$ 需要满足什么条件。

如果 $j-i>1$ ，那么相当于是一个“跳”的过程。那么需要满足的条件是：

$$\max_{k=i+1}^{j-1}<p_j$$

当然还有

$$p_{i+1}>p_i$$

如果 $j-i=1$，那么相当于是一个“爬”的过程，设$i$一直“爬”到$j'$。那么需要满足的条件是：

$$\max_{k=i+1}^{j}<p_{j+1}$$

因为这个段在“爬”的同时，其他的段在“跳”。

这样就可以建边了，看起来很抽象，发现这个东西具有单调性，考虑大根笛卡尔树。那么条件就变成：

$i$ 如果要“爬”，那么“爬”完一定要到他的一个父亲$-1$。

$i$ 如果要“跳”，那么一定要“跳”到他的父亲，

还有一个很重要的条件。如果 $i$ 有右儿子，那一定要“爬”完所有的右儿子。

~~然后那题是判定，我直接在笛卡尔树上 dp 了，没发现这个链就是前缀最大值，真是傻逼。~~

观察这个过程，如果 $1$ 所在的组没有选择一个它到根节点的路径上的父亲，那么一定是其他组选择，而且如果选了就一定要“爬”掉所有的右儿子。$1$ 到根节点上的路径全都是前缀最大值的位置！！！

所以转化为：如果这个组选择了第 $i$ 个前缀最大值的位置 $x_i$，那么 $[x_i,x_{i+1})$ 全部要选入这个组。求多少个排列能划分出 $n$ 个组，每个组有 $3$ 个数。


~~哇，BB 了这么多终于出现了题解给出的结论，真是棒呢。数学真是美妙啊！！！~~

知道了这个结论接下来就很简单了，如果有一段前缀最大值长度 $\geq 4$，无解，否则？

发现如果长度为 $2$ 的必须要选 $1$，不然就会出现 $4$，通过构造的角度分析可以发现 $1$ 个数一定要 $\geq2$ 个数。

直接 dp 维护差值就完事了。时间复杂度$O(n^2)$。

代码不贴了...

---

## 作者：小周猪猪 (赞：1)

## $\mathrm{Problem}$

- 给定如下构造生成长度为 $3N$ 的排列 $P$ 的方法：
  - 先生成一个长度为 $3N$ 的排列 $A$。然后将 $\forall k \in [0, N-1]$，$A_{3k+1},A_{3k+2},A_{3k+3}$ 分成一块。
  - 有 $N$ 个指针，初始指向每个块的第一个数。
  - 每次选择所有指针指向的数中最小的数删除，然后放到 $P$ 的末尾。之后指向被删除的数后移一个位置。若移出块了，则删除这个指针。
- 请你求出，一共能生成长度为 $3N$ 的排列共多少种。答案可能很大，请求出对 $M$ 取模的结果。
- $1 \leq N \leq 2 \times 10^3$，$10^8\leq M \leq 10^9+7$。

---

## $\mathrm{Solution}$
这道题我们的题意，我们可以转化为：
- 将长度为 $3n$ 的序列 $3$ 个一组分成 $n$ 组。
- 类似于归并排序，每一次加入序列的数字为每一组开头数字中最小的数。

这道题的题目很奇怪，我们需要去发掘题目中的性质。

观察到如果生成序列中出现了连续的三个数$a_i,a_j,a_k(i<j<k)$满足$a_i>a_j,a_i>a_k$，那么我们就可以确定这三个数字在原序列中是同一组的三个数字。~~这种奇怪的性质根本想不到啊~~ 

因为当$a_i$出现在序列中时，就说明了$a_i$是每一组开头元素中最小的。因而剩下每一组开头的元素都比它大，所以比它小唯一的可能性就是$a_i$的后面$a_j$，$a_k$同理。

据此，我们同时也能发现，不可能存在连续的四个数$a_1,a_2,a_3,a_4$满足$a_1>a_k(k∈[1,3])$。因为根据上面的分析，我们发现在取完$a_2,a_3$以后，比$a_1$小的数字已经取完了，因此在$a_1>a_2/a_3$的情况下必然有$a_1<a_4$。

因此序列中连续下降序列不超过3，若令$b_i=\max\{a_i\}$，我们会发现$b_i$相同的段数不会超过$3$段，即我们可以分成若干段长度为$1,2,3$的段，使得每一段的$b_i$都相同。
- 对于长度为 $3$ 的段，我们可以用这三个数字在原序列中形成一个分组，故没有影响。
- 对于长度为 $2$ 的段，我们无法形成一个分组，但这两个数又要在同一个组，因此我们需要长度为 $1$ 的段来填补剩下一个位置的空缺。而且这样是一定能构造出合法方案的。

因此我们可以得到这道题的终极结论：**$b_i$中长度为 $2$ 的段数不能小于长度为 $1$ 的段数。**

则我们可以设$f[i][j]$表示 $1$ 到 $i$ 的排列中，长度为 $1$ 的段数$-$长度为 $2$ 的段数 $=j$ 的方案数。

因此就有：
$$f[i][j]=f[i-1][j-1]+f[i-2][j+1]\times (i-1)+f[i-3][j]\times (i-1)(i-2)$$

然后代码就贼好写了...

---
## $\mathrm{Code}$

```cpp
#include <bits/stdc++.h>
#define f(i, j) f[i][j+3000]
#define int long long 

using namespace std;
const int N = 6100;

int n, P;
int f[N][N+3000];

signed main(void)
{
	cin >> n >> P;
	f(0, 0) = 1;
	for (int i = 0; i < n * 3; ++ i)
		for (int j = -n; j <= 3 * n; ++ j) {
			f(i+1, j+1) = (f(i+1, j+1) + f(i, j)) % P;
			f(i+2, j-1) = (f(i+2, j-1) + f(i, j) * (i + 1) % P) % P;
			f(i+3, j) = (f(i+3, j) + f(i, j) * (i + 1) % P * (i + 2) % P) % P; 
		}
	int res = 0;
	for (int i = 0; i <= n; ++ i) res = (res + f(n*3, i*3)) % P;
	cout << res << endl;
	return 0;
}
```


---

## 作者：cwfxlh (赞：0)

# [AT_agc043_d](https://www.luogu.com.cn/problem/AT_agc043_d)        

妙妙题。       

考虑合法的 $P$ 有什么性质。根据 $P$ 的生成方式可得出，$P$ 的前缀 $\max$ 变化是密集的，如果当前位置 $P_i$ 是 $P$ 的一个前缀 $\max$，则从最小值的那个块 $A_x$ 里面不断取出数，直到 $A_x$ 被取空或者最小值不在 $A_x$ 里面，这个时候的最小值便成为了新的前缀 $\max$。      

证明是容易的，因为当前的 $\min$ 不在 $A_x$ 中，所以其在计算 $P_i$ 时被考虑过，且大于 $P_i$，于是必定成为新的前缀 $\max$。           

由上面的过程可以导出，按前缀 $\max$ 分段，每一段都是相同块的元素按顺序拼在一起。现在有若干段，考虑同一块的元素可以被如何分段。        

因为每一段的开头都是前缀 $\max$，所以如何分段并没有什么限制，随便找几段拼在一起拼成一块就是合法的。段长共有三种，长为 3 的自成一块，长为 2 和长为 1 的拼起来拼成一块，剩下的若干长为 1 的可以三个拼一块。于是分完段后，只需要保证长为 2 的不比长为 1 的少就可以了。       

于是 dp，记录到当前位置，长为 1 的段数减去长为 2 的段数。新加入元素的时候使用插入计算排名的方法，这样就可以做到 $O(n^2)$ 了。             

代码：          


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,MOD,dp[6005][8005],ans;
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>MOD;
    dp[0][2000]=1;
    for(int i=0;i<3*n;i++){
        for(int j=0;j<=8000;j++){
            if(dp[i][j]==0)continue;
            dp[i+3][j]=(dp[i+3][j]+dp[i][j]*(i+1)*(i+2))%MOD;
            if(j+1<=8000)dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%MOD;
            if(j-1>=0)dp[i+2][j-1]=(dp[i+2][j-1]+dp[i][j]*(i+1))%MOD;
        }
    }
    for(int i=2000;i<=8000;i++)ans=(ans+dp[3*n][i])%MOD;
    ans%=MOD;
    ans+=MOD;
    ans%=MOD;
    cout<<ans;
    return 0;
}
```

---

## 作者：Leasier (赞：0)

Update on 2023.9.24：突然发现了模拟赛原题（

------------

- **对结果序列而非删除过程计数。寻找一种一一对应的方式。**

考虑上一步删除了某个 $(x, y, \cdots)$ 中的 $x$，设 $z$ 为除了 $x$ 之外首项的最小值（若不存在则为 $+\infty$），则这一步有两种情况：

- $y < z$，此时会接着删除 $y$。
- $y > z$，此时会删除 $z$。

进而，对于一个初始的 $(x, y, z)$，删除它的过程会存在下面几种情况：

- $x > \max(y, z)$，此时在删除 $x$ 后会接着删除 $y, z$。
- $x > y, x < z$，此时在删除 $x$ 后会接着删除 $y$，$z$ 会在后面某处删除。
- $x < z < y$，此时会先删除 $x$，$y, z$ 会在后面某处连续删除。
- $x < y < z$，此时 $x, y, z$ 会分开删除。

或者说，我们可以将其看做：

- 一个大小为 $3$ 的连续删除段。
- 一个大小为 $2$ 的连续删除段和一个单点删除项。
- 一个单点删除项和一个大小为 $2$ 的连续删除段。
- 三个单点删除项。

其中，一个大小为 $k$ 的连续删除段 $(a_1, a_2, \cdots, a_k)$ 要求 $a_1 > \displaystyle\max_{i = 2}^k a_i$，且此前所有被删除的数都满足其 $< a_1$。

考虑按最终所得序列的顺序插入连续删除段。

由于这里我们只关心相对大小，因此我们可以考虑将加入 $i$ 个数时的值域视作 $i$。

设此前已经加入了 $i$ 个数，则：

- 插入一个单点删除项：此时其一定为前面所有项的最大值，则只有一种方案。
- 插入一个大小为 $2$ 的连续删除段：此时第一项一定为前面所有项的最大值，但第二项只要比第一项小就可以了，则方案数为 $i + 1$。
- 插入一个大小为 $3$ 的连续删除段：同理，第二、三项只要比第一项小就可以了，则方案数为 $(i + 1)(i + 2)$。

看上去我们已经得到了一种将最终所得序列与组成其的连续删除段一一对应的方式……吗？

注意到当 $n = 2$，插入三个大小为 $2$ 的连续删除段实际上是不合法的，因为每出现一个大小为 $2$ 的连续删除段就一定会出现一个单点删除项。

于是我们需要钦定单点删除项的数量 $\geq$ 大小为 $2$ 的连续删除段，不难发现该条件为充要的。

考虑 dp，设 $dp_{i, j}$ 表示已经加入了 $i$ 个数，单点删除项的数量 $-$ 大小为 $2$ 的连续删除段的数量 $= j$ 的方案数。

转移等略去，实现时 $4$ 位滚动数组即可。时间复杂度为 $O(n^2)$。

如果被卡常了可以考虑在转移时判掉空状态。

代码：
```cpp
#include <stdio.h>

int p;
int dp[7][12007];

inline void add(int &x, int y){
	if ((x += y) >= p) x -= p;
}

int main(){
	int n, m, k, lst, ans = 0;
	scanf("%d %d", &n, &p);
	m = n * 3;
	k = m * 2;
	lst = m & 3;
	dp[0][m] = 1;
	for (int i = 1; i <= m; i++){
		int cur = i & 3, pre1 = (i - 1) & 3, pre2 = (i - 2) & 3, pre3 = (i - 3) & 3;
		for (int j = 0; j <= k; j++){
			dp[cur][j] = j == 0 ? 0 : dp[pre1][j - 1];
			if (i >= 2){
				if (j < k && dp[pre2][j + 1] != 0) add(dp[cur][j], 1ll * dp[pre2][j + 1] * (i - 1) % p);
				if (i >= 3 && dp[pre3][j] != 0) add(dp[cur][j], 1ll * dp[pre3][j] * (i - 1) % p * (i - 2) % p);
			}
		}
	}
	for (int i = m; i <= k; i++){
		add(ans, dp[lst][i]);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

艹，OEIS 上没有。

一个块降序部分的显然会跟着它一起取出来，就是紧跟着它后面。

考虑原排列，显然不会出现超过 $3$ 的降序序列。

考虑每个块降序序列的构成：

- $3$

- $2+1$

- $1+1+1$

注意到一个 $2$ 一定绑定一个 $1$，我们可以得到一个充要条件是：降序序列的长度不超过 $3$ 且 $2$ 的数量不超过 $1$ 的数量。

发现每个降序序列之间是独立的，所以可以 dp。

因此定义 $f_{i,j}$ 表示剩下 $i$ 个数且 $1$ 的个数减去 $2$ 的个数的差为 $j$ 的方案数。

为了保证不重复，你下一个一定得选没选过的最小值。然后对于 $2$ 和 $3$ 剩下两个是可以随便选的，因为确定了顺序，每种选法都对应了一个方案。

---


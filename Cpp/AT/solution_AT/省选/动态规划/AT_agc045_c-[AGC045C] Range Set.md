# [AGC045C] Range Set

## 题目描述

Snuke 君有长为 $N$ 的字符串 $x$，最初 $x$ 的所有字符都是 $0$。Snuke 君可以按照任意顺序进行任意次数以下两种操作:

- 选择 $x$ 中连续的长为 $A$ 的子串，将它们全部设为 $0$。
- 选择 $x$ 中连续的长为 $B$ 的子串，将它们全部设为 $1$。

请计算操作结束后的可能达成的不同的 $x$ 的数量，对 $10^9+7$ 取模。

## 样例 #1

### 输入

```
4 2 3```

### 输出

```
11```

## 样例 #2

### 输入

```
10 7 2```

### 输出

```
533```

## 样例 #3

### 输入

```
1000 100 10```

### 输出

```
828178524```

# 题解

## 作者：jun头吉吉 (赞：6)

## 题意
一个全 $0$ 的长度为 $n$ 的数组，每次可以把一段长度为 $A$ 的赋值成 $0$，也可以把长度为 $B$ 的赋值为 $1$，求最后有多少种不同的数组。

$1\le A,B\le n$

## 题解

令 $A\ge B$，如果不满足交换 $A,B$ 即可。

然后考虑一个序列能被构造出来的充要条件：存在一段长度 $\ge A$ 的子序列，不包含 $<B$ 的 $1$ 的段。

证明为什么是对的：一个填色过程，最后一次填 $0$ 之后在填 $1$，那么这段 $0$ 上的连续的 $1$ 一定长度 $\ge B$。这是必要性。充分性就是考虑先把这个子序列外面的部分填完（因为 $A\ge B$ 所以外面肯定是可以成任意的，随便手玩一下即可），然后填上这个子序列的 $0$，然后填 $1$。所以也是充分的。

有了这个条件就可以 dp 了。考虑对连续的 $01$ 段 dp，$f_{i,j,0/1}$ 表示当前长度为 $i$，已经有长度为 $j$ 的后缀不包含 $<B$ 的 $1$ 的段，最后一段的颜色是 $0/1$。在第一次满足 $\ge A$ 的子序列不包含 $<B$ 的 $1$ 的段时贡献给答案。朴素的实现是 $\mathcal O(n^3)$ 的。

然后用前缀和优化就可以做到 $\mathcal O(n^2)$。

具体实现可以看代码。

## 代码
```cpp
const int N=5e3+10;
int n,a,b;mint dp[N][N][2],pw[N],ans;
mint pre[N],sum[N][N][2];
signed main(){
	read(n,a,b);
	pw[0]=1;for(int i=1;i<=n;i++)pw[i]=pw[i-1]*2;
	if(a<b)swap(a,b);
	dp[0][0][0]=dp[0][0][1]=pre[0]=sum[0][0][0]=sum[0][0][1]=1;
	/*for(int i=0;i<n;i++)
		for(int j=0;j<=i;j++){
			//如果当前是0，接下来接一段1
			for(int k=1;k<b;k++)dp[i+k][0][1]+=dp[i][j][0];
			for(int k=b;i+k<=n;k++){
				if(j+k>=a)ans+=dp[i][j][0]*pw[max(n-i-k-1,0)];
				else dp[i+k][j+k][1]+=dp[i][j][0];
			}
			//如果当前是1，接下来接一段0
			for(int k=1;i+k<=n;k++){
				if(j+k>=a)ans+=dp[i][j][1]*pw[max(n-i-k-1,0)];
				else dp[i+k][j+k][0]+=dp[i][j][1];
			}
		}*/
	//前缀和优化上述dp
	for(int i=1;i<=n;i++){
		sum[i][0][1]=dp[i][0][1]=pre[i-1]-(i-b>=0?pre[i-b]:0);
		for(int j=1;j<=i;j++)if(j>=b){
			mint val=sum[i-b][j-b][0];
			if(j>=a)ans+=val*pw[max(n-i-1,0)];
			else dp[i][j][1]=val;
		}
		for(int j=1;j<=i;j++){
			mint val=sum[i-1][j-1][1];
			if(j>=a)ans+=val*pw[max(n-i-1,0)];
			else dp[i][j][0]=val;
		}
		pre[i]=pre[i-1];
		for(int j=1;j<=i;j++)
			pre[i]+=dp[i][j][0],
			sum[i][j][0]=sum[i-1][j-1][0]+dp[i][j][0],
			sum[i][j][1]=sum[i-1][j-1][1]+dp[i][j][1];
	}
	writeln(ans.x);
}
```

---

## 作者：activeO (赞：2)

别的题解好像解释得不是很清楚，听了讲题，来写发题解。

## 做法

首先可以把题目的限制改成可以选择 $ \geq b $ 的字串覆盖成 0，$ \geq b $ 的子串府改为 1，因为比如你想让 $ [l,r] (r-l+1 \geq a) $ 的子串覆盖为 0，就操作 $ [l,l+a-1] $ 然后是 $ [l+1,l+a] $ 如此往下一步步推。

对于这类问题，先考虑长成怎么样的字符串是可以被达到的。

发现正着推的话，后面覆盖的区间也许会覆盖掉前面的部分覆盖，于是我们考虑反着推回原串，一个区间被推回去原来既可以是 $ 0 $ 也可以是 $ 1 $，所以我们不妨暂且设被退回去的所有字符都是 $ ? $，表示既可以是 $ 0 $ 也可以是 $ 1 $。然后现在操作就形如：

- 选择一段长度 $ \geq a $ 的只包含 $ \texttt{0} $ 和 $ \texttt{?} $ 的区间全部变成 $ \texttt{?} $。
- 选择一段长度 $ \geq b $ 的只包含 $ \texttt{1} $ 和 $ \texttt{?} $ 的区间全部变成 $ \texttt{?} $。

然后因为原串全是 $ 0 $，所以目标是只包含 $ \texttt{0} $ 和 $ \texttt{?} $，但是可以发现我们再操作一遍就变为全是 $ \texttt{?} $，所以目标是 $ \texttt{?} $ 串，所以可以发现 $ 0 $ 和 $ 1 $ 是等价的，$ a $ 和 $ b $ 可以互换。不妨设 $ a \leq b $。

然后发现对于一个串要变为全是 $ \texttt{?} $，只需要有一个全 $ \texttt{1} $ 或 $ \texttt{?} $ 串长度 $ \geq b $，这样就可以用开头的方法一步步推回全 $ ? $，然后要有一个这样的子串，中间也可以有长度 $ \geq a $ 的 $ 0 $ 串，这样也可以操作过去。但是发现长度 $ \leq a $ 的 $ 0 $ 串是没办法操作的，所以至此我们就找到了一个串合法的充要条件：**一个串合法当且仅当他有一个长度 $ \geq b $ 的只包含 $ 1 $ 和长度 $ \geq a $ 的 $ 0 $ 的段的子串。**~~好像有点绕~~

证明就是上述推导过程。

然后就可以 $ dp $，设 $ f_{i,j,0/1} $ 表示目前串长度是 $ i $，有一个长度是 $ j $ 的满足条件的后缀，最后一段是 $ 0/1 $，转移就是新加一个长度为 $ k $ 的段，$ j $ 一大于 $ b $ 就立马统计答案，可以用前缀和优化成 $ O(n^2) $。

## 实现

```cpp
// Problem: [AGC045C] Range Set
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT_agc045_c
// Memory Limit: 1 MB
// Time Limit: 2000 ms

#include <bits/stdc++.h>

using namespace std;

const int maxn=5005;
const int mod=1e9+7;
int dp[maxn][maxn][3],poww[maxn];
int sum[maxn][maxn][3],pre[maxn];

inline void init(int n){
	poww[0]=1;
	for(int i=1;i<=n;i++) poww[i]=2ll*poww[i-1]%mod;
}

int main(){
	
	int n,a,b;
	
	scanf("%d %d %d",&n,&a,&b);
	
	init(n);
	
	if(a<b) swap(a,b);
	
	int res=0;
	sum[0][0][0]=sum[0][0][1]=dp[0][0][0]=dp[0][0][1]=pre[0]=1;
	
	for(int i=1;i<=n;i++){
		int tt=pre[max(0,i-b)];
		if(i-b<0) tt=0;
		sum[i][0][1]=dp[i][0][1]=(pre[i-1]-tt+mod)%mod;
		for(int j=1;j<=i;j++){
			if(j>=a){
				if(j>=b) res=(res+1ll*sum[i-b][j-b][0]*poww[max(0,n-i-1)]%mod)%mod;
				res=(res+1ll*sum[i-1][j-1][1]*poww[max(0,n-i-1)]%mod)%mod;
			}else{
				if(j>=b) dp[i][j][1]=sum[i-b][j-b][0];
				dp[i][j][0]=sum[i-1][j-1][1];
			}
		}
		pre[i]=pre[i-1];
		for(int j=1;j<=i;j++){
			pre[i]=(pre[i]+dp[i][j][0])%mod;
			sum[i][j][0]=(sum[i-1][j-1][0]+dp[i][j][0])%mod;
			sum[i][j][1]=(sum[i-1][j-1][1]+dp[i][j][1])%mod;
		}
	}
	
	printf("%d\n",res);
	
	return 0;
}
```


---

## 作者：Leasier (赞：2)

训 dp 就像坐牢，因为状态都列不出来 /ll

------------

对过程计数是不可能的，考虑如何判断一个最终串是否可以得到。

不难发现我们事实上可以：

- 给任意一个长度 $\geq a$ 的子串赋 $0$。
- 给任意一个长度 $\geq b$ 的子串赋 $1$。

但直接考虑正着操作好像有点困难。~~显然是我太菜了 /kk~~

- **若操作有一定可逆性，我们可以考虑从最终状态出发进行若干次逆操作看能不能得到初始状态。**

我们尝试给出上面两种操作的逆操作：

- 给任意一个长度 $\geq a$ 的全为 $0$ 的子串赋 $1$。
- 给任意一个长度 $\geq b$ 的全为 $1$ 的子串赋 $0$。

这里我们可以强化操作限制的原因是：

- 若我们要执行操作一且操作前那一段不全为 $1$，则我们不妨把之前的两次赋 $1$ 操作换成包含中间的 $0$ 的一次操作。
- 若我们要执行操作二且操作前那一段不全为 $0$，则我们不妨操作之前先通过若干次操作把这段区间赋为 $0$。

接下来讨论什么时候我们可以通过若干次逆操作得到全 $0$。下文中钦定 $a \leq b$。

- 若一开始不存在长度 $\geq a$ 的全 $0$ 段且不存在长度 $\geq b$ 的全 $1$ 段，则一定不行。
- 若一开始存在长度 $\geq b$ 的全 $1$ 段，则我们一定可以通过将其向两边扩展得到全 $0$，则一定可以。
- 若一开始存在长度 $\geq a$ 的全 $0$ 段，则为了满足上面一个获胜条件，我们可以考虑将其换成若干 $1$，若换后存在长度 $\geq b$ 的全 $1$ 段则一定可以，否则我们一定无法执行其他任何操作，则一定不行。

综上，我们可以得出可以赋成全 $0$ 的条件：

- 一开始把所有长度 $\geq a$ 的极长全 $0$ 段赋成全 $1$，若操作后存在长度 $\geq b$ 的全 $1$ 段则一定可以将其赋成全 $0$，否则一定不行。

考虑容斥，改为求有多少种方案不合法，即把条件中的“存在一段”换成“不存在任何一段”。

考虑 dp，设：

- $f_i$ 表示把 $[1, i]$ 赋值使得末尾为 $0$ 且末尾的极长 $0$ 段 $< a$ 的方案数。
- $g_{i, j}$ 表示把 $[1, i]$ 赋值使得末尾为 $0$，末尾的极长 $0$ 段 $\geq a$ 且进行一开始的赋值操作后末尾的极长 $1$ 段 $< b$ 的方案数。
- $h_{i, j}$ 表示把 $[1, i]$ 赋值使得末尾为 $1$ 且进行一开始的赋值操作后末尾的极长 $1$ 段 $< b$ 的方案数。

转移较为简单，前缀和优化即可，此处略去。

时间复杂度为 $O(n \max(a, b))$。

代码：
```cpp
#include <iostream>

using namespace std;

const int mod = 1e9 + 7;
int dp1[5007], dp2[5007][5007], dp3[5007][5007], sum1[5007][5007], sum2[5007][5007], sum3[5007];

int main(){
	int n, a, b, ans = 1;
	cin >> n >> a >> b;
	if (a > b) swap(a, b);
	dp1[0] = dp2[0][0] = dp3[0][0] = 1;
	for (int i = 0; i <= n; i++){
		sum1[i][0] = sum2[0][i] = 1;
	}
	for (int i = 1; i <= n; i++){
		for (int j = 0; j < b; j++){
			dp1[i] = (dp1[i] + sum1[i - 1][j]) % mod;
			if (a <= i) dp1[i] = ((dp1[i] - sum1[i - a][j]) % mod + mod) % mod;
		}
		for (int j = a; j < b && j <= i; j++){
			dp2[i][j] = sum2[i - j][i - a];
		}
		for (int j = 1; j < b && j <= i; j++){
			dp3[i][j] = (dp1[i - j] + sum3[i - j]) % mod;
			sum1[i][j] = (sum1[i - 1][j] + dp3[i][j]) % mod;
			sum2[i - j][i] = (sum2[i - j][i - 1] + dp3[i][j]) % mod;
		}
		for (int j = a; j < b && j <= i; j++){
			sum3[i - j] = (sum3[i - j] + dp2[i][j]) % mod;
		}
	}
	for (int i = 1; i <= n; i++){
		ans = ans * 2 % mod;
	}
	ans = ((ans - dp1[n]) % mod + mod) % mod;
	for (int i = 1; i < b; i++){
		ans = ((ans - dp2[n][i] - dp3[n][i]) % mod + mod) % mod;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：2008verser (赞：1)

任意进行操作，问可达状态数，一般来说直接从合法或不合法的充要条件入手。

寻找充要条件可以考虑合并操作、贪心或者倒推。这里我尝试过贪心和倒推，最终倒推会了。

首先我们将操作合并为 $\geq A,\geq B$。

不失一般性地，假设 $A\leq B$。

考虑最后一次粉刷，如果粉刷的段连同它两侧异色段的总长不小于异色刷子的长度的话，我们找到了倒数第二次粉刷。

这时发现只要存在长度 $\geq B$ 的 $1$ 段，推下去，这个序列一定是合法的。

没有长度 $\geq B$ 的 $1$ 段时，不断将 $\geq A$ 的 $0$ 段看成是 $1$。我们理解为把它和左右合并。

这时序列合法的充要条件是最终出现长度 $\geq B$ 的 $1$ 段。

自然考虑用 $2^n$ 减去最终不存在长度 $\geq B$ 的 $1$ 段的数目。

直接 dp。设 $f_{i,j,0/1}$ 表示长为 $i$，末尾视作 $1$ 段的长度为 $j(0\leq j\lt B)$，末位是 $0/1$ 的方案数。

暴力枚举下一异色段长度 $k$ 是 $O(n^3)$ 的，前缀和优化可以做到 $O(n^2)$。

细节可以看我的代码。

[AC 链接](https://atcoder.jp/contests/agc045/submissions/63866274)

---

## 作者：WRuperD (赞：1)

orz zjk。学到了。对于这一类计数最终由多少不同局面的题，我们首先应当考虑一下如何判断最终局面合法。感觉正着做不太方便，于是我们考虑倒着做。

首先，容易发现 0 和 1 是对称的，哪个是 0 哪个是 1 不重要，所以我们不妨设 $A \leq B$。

考虑倒着操作是怎么样的，于是我们将操作改写为：

- 选择 $x$ 中长度为 $A$ 的字串，其中字符为 0 或 ?，将他们改为 ?。
- 选择 $x$ 中长度为 $B$ 的字串，其中字符为 1 或 ?，将他们改为 ?。

容易发现，我们只要最后到达了全是 0 或者 ? 的字符串就有解了。观察并手玩一下，发现只要进行了一次二操作，就一定有解。原因是进行一次二操作后我们可以得到一个长度为 $B$ 的 ? 区间。我们必定可以通过每次往左，往右拓展一格使得整个字符串被置为 ?。

到这里有解的限制就变得清晰了。**一个最终局面 $x$ 有解当且仅当将其长度大于等于 $A$ 的字串置为 1之后，1 的极长连续段的长度大于等于 $B$。**

现在你可以直接计数了。这部分是简单的。

[code](https://atcoder.jp/contests/agc045/submissions/50418079)

---

## 作者：Milmon (赞：1)

首先容易发现操作可以加强为对 $\geq a$ 或 $\geq b$ 的段进行修改。由于可以直接把整个串改为 `1`，所以 $a,b$ 可以交换，不妨设 $a\leq b$。

把操作反过来，考虑对于一个 `01` 序列，能否经过若干次逆操作变为全为 `0`。

原操作的逆操作就是选择一个长度 $\geq a$ 的全为 `0` 的段变为任意数。因为我们现在不知道变为什么数对我们有利，我们不妨把它们变为 `?`，这样我们可以选择一个长度 $\geq a$ 的不包含 `1` 的段全变为 `?`，或选择一个长度 $\geq b$ 的不包含 `0` 的段全变为 `?`。而目标就是把整个序列变为 `0` 或 `?`，等价于变为全部是 `?`。

由于 `?` 的功能严格包含 `0` 和 `1` 的功能，所以我们贪心地只要遇到长 $\geq a$ 的非 `1` 段就变为 `?`。

注意到如果我们把一个长为 $b$ 的段变为了 `?`，由于 $a\leq b$，我们可以把这个 `?` 段无限延长，直至整个序列都变为 `?`。

于是我们得出了如下结论：一个序列能否变为全 `0` 串，等价于把其中所有长度至少为 $a$ 的极长连续 `1` 段全变为 `0` 后是否存在长至少为 $b$ 的连续 `0` 段。

由容斥原理，只需求用长 $< a$ 的极长连续 `1` 段分割后每段长 $< b$ 且所有极长连续 `1` 段的长度都 $\geq a$。

考虑动态规划，记

- $f_i$ 表示到第 $i$ 位为止最后一个连续段是长度小于 $a$ 的 `1` 段；
- $g_{i,j}$ 表示到第 $i$ 位为止有一个长度为 $j$ 不包含长度小于 $a$ 的极长连续 `1` 段的极长段且最后一个连续段是 `0`；
- $h_{i,j}$ 表示到第 $i$ 位为止有一个长度为 $j$ 不包含长度小于 $a$ 的极长连续 `1` 段的极长段且最后一个连续段是 `1`。

用朴素方法转移是 $\Theta(n^3)$ 的，使用前缀和优化即可做到 $\Theta(n^2)$。

```cpp
/**
 * @date: 2024.02.18
 * @problem: AT_agc045_c
 * @tags: 数学, 组合数学, 组合计数, 思维, 动态规划
 */

#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;

int n,a,b;
long long f[5001],g[5001][5001],h[5001][5001];
long long sg[5001],sumg[5001][5001],sumh[5001];

int main(){
    scanf("%d%d%d",&n,&a,&b);
    if(a>b)swap(a,b);
    f[0]=g[0][0]=h[0][0]=1;
    if(n<=1000){
        // O(N^3)
        for(int i=1;i<=n;i++){
            if(i<a)f[i]++;
            for(int j=max(0,i-a+1);j<i;j++)
                for(int k=1;k<=j;k++)
                    f[i]+=g[j][k],f[i]%=mod;
            for(int j=1;j<=i&&j<b;j++){
                for(int k=1;k<j;k++)
                    g[i][j]+=h[i-k][j-k];
                g[i][j]+=f[i-j],g[i][j]%=mod;
            }
            if(a<=i&&i<b)h[i][i]++;
            for(int j=1;j<=i&&j<b;j++){
                for(int k=a;k<j;k++)
                    h[i][j]+=g[i-k][j-k];
                h[i][j]%=mod;
            }
        }
    }
    else{
        // O(N^2)
        for(int i=1;i<=n;i++){
            for(int j=1;j<i;j++)
                sg[i-1]+=g[i-1][j];
            sg[i-1]%=mod;

            if(i<a)f[i]++;
            for(int j=max(0,i-a+1);j<i;j++)f[i]+=sg[j];
            f[i]%=mod;
            for(int j=1;j<=i&&j<b;j++){
                g[i][j]=(sumh[i-j]+f[i-j])%mod;
                sumg[i][j]=(sumg[i-1][j-1]+g[i][j])%mod;
            }
            if(a<=i&&i<b)h[i][i]++;
            for(int j=1;j<=i&&j<b;j++){
                if(i>=a&&j>=a)h[i][j]+=sumg[i-a][j-a],h[i][j]%=mod;
                sumh[i-j]+=h[i][j],sumh[i-j]%=mod;
            }
        }
    }
    long long answer=1;
    for(int i=1;i<=n;i++)answer=answer*2%mod;
    answer-=f[n];
    for(int i=1;i<=n;i++)
        answer-=g[n][i]+h[n][i];
    printf("%lld\n",(answer%mod+mod)%mod);
    return 0;
}
```

---


# [AGC069A] Schedule Optimization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc069/tasks/agc069_a

高橋君は全 $ 10^9 $ 日間からなるトーナメント形式の大会を開くことにしました。  
 選手は $ 2^N $ 人いて、それぞれ選手 $ 1 $、$ \ldots $、選手 $ 2^N $ と呼ばれます。 選手 $ i $ は大会の $ l_i $ 日目から $ r_i $ 日目までの $ r_i-l_i+1 $ 日間参加する予定です。

まず、大会の流れを述べます。$ 1\ \leq\ i\ \leq\ N,\ 1\ \leq\ j\ \leq\ 2^{N-i} $ を満たす整数組 $ (i,j) $ は $ 2^N-1 $ 通りありますが、それらと大会中の試合が一対一で対応します。$ (i,j) $ に対応する試合では以下に述べる $ 2 $ 人の選手が対戦して勝者と敗者を決めます。

- $ i=1 $ の場合、選手 $ 2j-1 $ と選手 $ 2j $
- $ i\ \geq\ 2 $ の場合、$ (i-1,\ 2j-1) $ に対応する試合の勝者と $ (i-1,2j) $ に対応する試合の勝者
 
各試合は、対戦することになる $ 2 $ 人を決める為に必要な試合すべてが完了していて、かつその $ 2 $ 人が大会に参加中ならばただちに完了させられます。特に、一人の選手が同日に複数の試合を行うことも可能です。  
 $ (N,\ 1) $ に対応する試合は決勝戦と呼ばれ、これを完了させるのが大会の目的です。

高橋君は決勝戦を完了させて大会を成功させるために、以下の工作を行うことにしました。

- 審判に指示を出し、各試合の勝者を都合よく決める。
- 各選手にお金を払い、参加する日程を変えてもらう。選手 $ i $ に $ l'_i $ 日目から $ r'_i $ 日目まで参加してもらう場合、$ |l_i-l'_i|+|r_i-r'_i| $ 円を支払う必要がある。ここで、$ l'_i,\ r'_i $ は $ 1\leq\ l'_i\ \leq\ r'_i\ \leq\ 10^9 $ を満たす整数である。
 
高橋君が選手たちに支払う必要のある金額の総和の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 18 $
- $ 1\ \leq\ l_i\ \leq\ r_i\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

選手 $ 4 $ に $ 1 $ 円を払って $ (l'_4,\ r'_4)=(2,3) $ に変え、他の選手の日程は変えないことにします。すると、例えば以下のようにして決勝戦を完了させることができます。 1. $ 1 $ 日目に $ (1,1) $ に対応する試合(選手 $ 1 $ 対選手 $ 2 $ )を行い、選手 $ 2 $ を勝たせる。 2. $ 3 $ 日目に $ (1,2) $ に対応する試合(選手 $ 3 $ 対選手 $ 4 $ )を行い、選手 $ 3 $ を勝たせる。 3. $ 3 $ 日目に $ (2,1) $ に対応する試合(選手 $ 2 $ 対選手 $ 3 $ )を行い、選手 $ 3 $ を勝たせる。 4. $ 3 $ 日目に $ (1,4) $ に対応する試合(選手 $ 7 $ 対選手 $ 8 $ )を行い、選手 $ 8 $ を勝たせる。 5. $ 4 $ 日目に $ (1,3) $ に対応する試合(選手 $ 5 $ 対選手 $ 6 $ )を行い、選手 $ 5 $ を勝たせる。 6. $ 4 $ 日目に $ (2,2) $ に対応する試合(選手 $ 5 $ 対選手 $ 8 $ )を行い、選手 $ 8 $ を勝たせる。 7. $ 4 $ 日目に $ (3,1) $ に対応する試合(選手 $ 3 $ 対選手 $ 8 $ )を行い、選手 $ 8 $ を勝たせる。 一方、$ 1 $ 円未満の支払いで決勝戦を完了させることはできません。そのため、$ 1 $ が期待される出力です。

## 样例 #1

### 输入

```
3
1 4
1 3
3 4
2 2
3 4
4 4
2 3
3 4```

### 输出

```
1```

## 样例 #2

### 输入

```
1
1 1
1000000000 1000000000```

### 输出

```
999999999```

## 样例 #3

### 输入

```
4
158260522 877914575
24979445 602436426
623690081 861648772
433933447 476190629
211047202 262703497
628894325 971407775
731963982 822804784
430302156 450968417
161735902 982631932
880895728 923078537
189330739 707723857
802329211 910286918
303238506 404539679
317063340 492686568
125660016 773361868
650287940 839296263```

### 输出

```
1088492036```

# 题解

## 作者：hegm (赞：5)

好题，我的做法似乎和AT官方完全不同。

首先大致做法比较显然，直接递归处理子问题，处理完 $l,mid$ 和 $mid+1,r$ 然后合并出当前区间的答案，问题在于如何合理的处理出当前区间的答案。

我们先从最简单的例子考虑，现在处理的区间长度为 $2$，即两个人比赛。两人区间分别为 $(l_1,r_1),(l_2,r_2)$

不妨分讨

1. 如果当前的两人区间已经相交了，那么我们是不需要对其进行任何操作的，进一步说，我们需要让胜利的人的时间区间尽可能的长。

     容易发现，我们新产生的区间左端点是固定的，一定为 $\max(l_1,l_2)$，因为在这个瞬间，两人胜负即可决定，显然向后拖没有意义。

      既然左端点是确定的，那么我们就需要让右端点尽可能的长，我们如果选择 $1$ 号，那么右端点是 $r_1$，选择 $2$ 号右端点是 $r_2$，为了让右端点尽可能的长，我们最后的区间实际上是 $(\max(l_1,l_2),\max(r_1,r_2))$。

2. 如果当前区间没有相交，即 $r_1<l_2$。那么为了让二人能拼出胜负，我们需要花钱改动区间，显然当前的最优花费一定是 $l_2-r_1$，即挪动两者的端点使其相交，再此基础上，我们要让拼出来的区间尽量的长，那么最优策略一定是挪动 $l_2$ 到 $r_1$，如此操作，拼出来的区间为 $(r_1,r_2)$。

这样两人的合并就做完了，但是接下来的合并不止于此。

如果我们需要合成四个人的答案， `case1` 由于没有花费，不会有区别，但是 `case2` 就有大区别了。

考虑 $l_3=3,l_4=3$，显然这种情况下合并出来的新的 $l'=3$，但是当 $l'$ 需要向左移动的时候，我们的花费不再是 $1$ ，而是 $2$。

在这种情况下，我们的 $case2$ 也许最优策略不再是移动 $l_2$ 了，因为移动一下 $l_2$ 的花费可能很大，而移动 $r_1$ 的花费一定是 $1$（建议画个图思考下为什么一定为 $1$）。我们将移动 $l_2$ 的花费记为 $ct(ct\ge1)$。

那么此时（即 $ct\ne1$）我们不妨先贪心最小花费的移动 $r_1$ 至 $l_2$，然后将 $ct-1$，返回区间 $(l_2,r_2)$。考虑这么做为什么是对的，我们当前是移动了 $r_1$ 到了 $l_2$ 的，如果未来我要移动 $l_2$ 到 $r_1$ 这个过程中，我可以撤销这一步的操作，相当于每一步的花费可以减少 $1$。

这样的想法非常之对，即我当前的 $ct= 1$ 我就一步一步的移动 $l_2$，如果某时刻 $ct\ne 1$，我就直接移动 $r_1$ 到此处，然后等待未来可能存在的撤销。

那么如何维护 $ct$，容易发现，我们只需要维护一个当前人的左端点序列 $s$ 即可，每次处理当前区间，我暴力的把两儿子的 $s$ 合并到当前节点，然后更新，当 $l_2$ 扫到 $s$ 的最大值时，我们让 $ct+1$，然后删除 $s$ 的最大值。

当我们遇到 $ct\ne 1$ 的操作的时候，我们让 $ct-1$，然后插入一个 $r_1$，因为 $ct-1$ 效果的存在区间只持续到 $r_1$。

代码实现也比较简单，由于数据范围小我就用了 $\text{vector}$ 加暴力排序。实际上复杂度可以做到更优，当前复杂度算是个 $n^22^n$。但是根本跑不满。

 ### $\text{CODE}$

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 600005
#define ls (now<<1)
#define rs (now<<1|1)
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,lim,L[N*4],R[N*4];
int ans,ct[N*4];
struct node
{
	int l,r;
}v[N*4];
vector<int> s[N*4];
node get(int now)
{
	node a=v[ls],b=v[rs];
	for(int x:s[ls])s[now].push_back(x);
	for(int x:s[rs])s[now].push_back(x);
	if(ct[ls])while(ct[ls]--)s[now].push_back(a.l);
	if(ct[rs])while(ct[rs]--)s[now].push_back(b.l);
	sort(s[now].begin(),s[now].end());
	if(a.l>b.l)swap(a,b);
	while(s[now].size()&&b.l==*s[now].rbegin())
	{
		ct[now]++;
		s[now].pop_back();
	}
	if(b.l>a.r)
	{
		if(ct[now]>1)
		{
			ans+=(b.l-a.r);
			s[now].push_back(a.r); 
			ct[now]--;
			return {b.l,b.r};
		}
		if(*s[now].rbegin()<=a.r)
		{
			while(s[now].size()&&*s[now].rbegin()==a.r)ct[now]++,s[now].pop_back();
			ans+=(b.l-a.r);
			return {a.r,b.r};
		}
		else
		{
			int w=*s[now].rbegin();
			while(s[now].size()&&*s[now].rbegin()==w)ct[now]++,s[now].pop_back();
			ct[now]--;
			s[now].push_back(a.r);
			ans+=(b.l-a.r);
			return {w,b.r};
		}
	}
	return {b.l,max(a.r,b.r)};
}
void solve(int now,int l,int r)
{
	if(l==r)
	{
		v[now]={L[l],R[l]};
		ct[now]=1;
		return ;
	}
	int mid=(l+r)>>1;
	solve(ls,l,mid);
	solve(rs,mid+1,r);
	v[now]=get(now);
}
signed main()
{
	n=read();
	lim=(1<<n);
	for(int i=1;i<=lim;i++)L[i]=read(),R[i]=read();
	solve(1,1,lim);
	cout<<ans<<"\n";
	return 0;
}

```

---

## 作者：SnowTrace (赞：4)

场切失败。

-------

我们观察问题的操作。

先画出满二叉树的结构，每个人都站在叶子。

贪心的考虑，观察到，钦定一个比赛开始的时间相当于固定了左端点。因为我们希望区间尽可能相交，所以我们希望右端点尽可能大。

假设现在比赛的两个人对应的区间是 $[l_1,r_1],[l_2,r_2](r1<r2)$，钦定这两个人在 $i$ 时刻比赛，然后如果让 $1$ 上去进行下一轮比赛，接下来 $1$ 可以比赛的时间区间是 $[i,r_1]$，如果让 $2$ 上去，$2$ 可以比赛的时间区间是 $[i,r_2]$，左端点固定了，所以我们选右端点较大的会更优。

根据上面的这一观察，可以想到一个贪心策略，假如目前要比赛的两人可行的时间区间有交，就什么都不干，钦定比赛在交区间的左端点进行，如果无交则把靠右边区间对应的人的区间左端点往左边移动直到和左边区间有交。这样我们可以让合并产生的区间的左端点尽量的靠左。

但是这样做有两个问题：

1. 当前某个人对应的可行区间，实际上不能当作**一个区间**来处理，因为实际上这时候的可行区间是这个点所在的子树的区间合并出来的，如果把左端点左移可能需要让很多个人的左端点左移才能保证这个子树内的合并都是合法的，也就是说，这时候移动左端点的代价不是 1。

2. 实际上不能保证端点移动到最左边的时候是最优方案，因为现在代价都不是 1，所以可能让右端点移动会更优。

所以贪心肯定无法实现了，我们考虑能不能对这个东西 dp。

根据一开始观察到的性质，我们发现当前选手的区间 $[l,r]$ 对应的子树，对应的时间区间的左端点可能不固定，但是右端点一定是 $[l,r]$ 选手中右端点的最大值。这个根据上面的合并过程容易看出来，因为我们不确定的实际上是左端点的位置，右端点永远能选择较大的那一个。

设计 dp。先把二叉树建出来，设 $dp_{i,j}$ 表示考虑到以 $i$ 为根的子树时可行的左端点是 $j$，而且在以后这个左端点的值都不会变的最小代价。

相当于我们把决策放到叶子处去做，每次干的事情是合并。

直接转移可以做到 $O(nV)$。

我们注意到，这个 dp 值实际上可以被表示为若干一次函数的加和。

具体来说对于叶子节点 $i $，设其区间为 $[l,r]$，会给 $dp_{i,j}$ 加上 $|l-i|$。 

在合并的过程中，只有两个区间不交的时候才会多产生贡献，此时要把靠左的右端点 $r_2$，移动到右边，也就是给 $dp_{i,j}$ 加上 $\operatorname{min}(j-r_2,0)$。

合并是一个取前缀 min 然后合并的过程，要先算出 dp 数组的前缀最小值，然后再和另一边的原数组合并（或许可以称它为 $min-max$ 卷积，也就是卷积的时候下标取较大值）

做到这一步就可以直接写了，因为这个二叉树是一个平衡结构，直接上 vector 暴力合并，然后维护前缀最小值需要一些讨论。

我场上做到这一步就倒闭了，我感觉我也写不出来这个维护一次分段函数的代码，但是由于我一直在感性理解这个过程，我没有意识到它直接就是凸的。

注意到我们加上去的东西都是凸的，使用 slope trick 优化。

维护斜率 $>0$ 的斜率分界点，每次合并左右两个子树所在的队列，然后在 $r_2$ 位置插入分界点，这个东西写起来和 CF731C 是很像的。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
priority_queue<int>q[600005];
int L[500005],R[500005];
int n;
int f[600005];
int solve(int l,int r,int k){
	if(l==r){q[k].push(L[l]);return R[l];}
	int k1 = k<<1,k2 = k<<1|1,mid = l+r>>1;
	int R1 = solve(l,mid,k1),R2 = solve(mid+1,r,k2);
	if(R1<R2)swap(R1,R2),swap(k1,k2);
	while(q[k1].size())q[k].push(q[k1].top()),q[k1].pop();
	while(q[k2].size())q[k].push(q[k2].top()),q[k2].pop();
	if(q[k].top()<=R2){
		f[k]=f[k1]+f[k2];
	}else{
		f[k]=f[k1]+f[k2]+q[k].top()-R2;
		q[k].pop();q[k].push(R2);
	}
	return R1;
}
signed main(){
	cin >> n;
	for(int i = 1;i<=(1<<n);i++)cin >> L[i] >> R[i];
	solve(1,(1<<n),1);
	cout << f[1] << endl;
	return 0;
}
```

---

## 作者：Petit_Souris (赞：1)

线性规划对偶是啥？DP + slope trick 又是啥？我咋都想不到？来个人类可以想到的做法。

首先发现 $l$ 只会往小了改，$r$ 只会往大了改，合并两个区间等价于取 $[\max(l_1,l_2),\max(r_1,r_2)]$。看起来毫无头猪，先尝试做 $n=1$ 的情况。

如果两个区间已经相交了，那么不需要动。否则假设 $l_1\le r_1<l_2\le r_2$，那么有两种策略：

- 把 $r_1$ 右移到 $l_2$；
- 把 $l_2$ 左移到 $r_1$。

显然，后者比前者优，因为得到的区间更大。

那么是不是全都这样把右端点移到左边就最优了呢？试一下 $n=2$，发现出锅了......

![](https://cdn.luogu.com.cn/upload/image_hosting/jo3haicy.png?x-oss-process=image)

其中，黑色线段表示初始的四条线段；红色线段表示第一层合并的结果，紫色和蓝色线段表示第二层合并的最优解。

可以看到，这里没有把蓝色线段延申到最左边，**原因是过了 $l_3$ 之后，向左移动的单价已经变成了 $2$，反而不如 $r_2$ 向右移动了。**

如果 $n$ 再变大呢？又说不定是移动 $l_3$ 更优了（为了增大区间节省下一层代价），但是也还是可以移动 $r_2$ 更优......

这时候容易想到引入一个**反悔**的机制。比如上图，我们先达到目前这个状态（子树内的最小代价前提下 $l$ 最小），接着可以让蓝色的左端点向左移动，向左移动的单价为 $1$（因为紫色已经花掉了 $1$ 的代价，那么只需要额外支付 $1$）。在移动到左边的红色的右端点之后再移动就需要 $2$ 的代价了（这段代价紫色没覆盖），经过了红色左端点之后再是 $3$ 的代价，经过最左的左端点之后再是 $4$ 的代价......

所以我们可以给树上每个节点维护一个 vector，存储所有向左移动的决策（代码里存的是至多还能左移多少单位距离）。每次合并两个节点的时候，如果两个区间相交，那么直接合并；否则，先考虑尽量左移右边那个区间（也就是在代价为 $1$ 的前提下移到最左边），然后再合并决策。

时间复杂度和总子树大小有关，带上排序了，所以是 $\mathcal O(n^22^n)$ 的，归并排序可以优化到 $\mathcal O(n2^n)$，在本题中不必要。

最后发现写出来的代码好像和 slope trick 相同......很美妙啊。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=(1<<20)+9,INF=1e16;
ll n,L[N],R[N],ans;
vector<ll>tr[N];
void Build(ll x,ll l,ll r){
    if(l==r){
        L[x]=read(),R[x]=read();
        tr[x].push_back(0);
        return ;
    }
    ll mid=(l+r)>>1;
    Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
    if(L[x<<1]>L[x<<1|1]){
        swap(L[x<<1],L[x<<1|1]);
        swap(R[x<<1],R[x<<1|1]);
        swap(tr[x<<1],tr[x<<1|1]);
    }
    if(L[x<<1|1]>R[x<<1]){
        ll pos=((ll)tr[x<<1|1].size()>=2?tr[x<<1|1][1]:INF);
        ll len=L[x<<1|1]-R[x<<1];
        ans+=len,pos=min(pos,len);
        L[x]=L[x<<1|1]-pos,R[x]=max(R[x<<1],R[x<<1|1]);
        rep(j,1,(ll)tr[x<<1|1].size()-1)tr[x].push_back(tr[x<<1|1][j]-pos);
        tr[x].push_back(len-pos);
        for(ll y:tr[x<<1])tr[x].push_back(y+L[x]-L[x<<1]);
    }
    else {
        L[x]=max(L[x<<1],L[x<<1|1]),R[x]=max(R[x<<1],R[x<<1|1]);
        tr[x]=tr[x<<1|1];
        for(ll y:tr[x<<1])tr[x].push_back({y+L[x<<1|1]-L[x<<1]});
    }
    sort(tr[x].begin(),tr[x].end());
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    n=read();
    Build(1,1,(1<<n));
    write(ans);
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：Nightingale_OI (赞：1)

## 大意

锦标赛有 $2^n$ 名选手和 $2^n-1$ 场比赛，都从 $1$ 开始编号。比赛的编号不代表比赛顺序。  
选手 $i$ 会在第 $l_i$ 到 $r_i$ 天参加比赛。
特别地，我们认为第 $2^n+i-1$ 场比赛的胜者是选手 $i$ 。 

第 $i$ 场比赛由第 $2i$ 场和第 $2i+1$ 场的胜者进行对决。第 $i$ 场比赛可以在第 $2i$、$2i+1$ 场比赛都结束且两场比赛胜者都在场时瞬间开始然后瞬间结束。

你可以任意次以 $1$ 的代价使某个选手的 $l_i$ 或 $r_i$ 增加或减少 $1$。  
你还可以直接指定每一场的胜者（必须为参加比赛的两名选手之一）。  
求最少代价，使得编号为 $1$ 的比赛可以结束。

保证 $1\leq n\leq18,1\leq l_i\leq r_i\leq 10^9$。

## 思路

先进行一些观察：$l_i$ 肯定越小越好，$r_i$ 肯定越大越好。

考虑一个参赛时间为 $[l_1,r_1]$ 的选手和一个参赛时间为 $[l_2,r_2]$ 的选手进行的比赛（$r_1\leq r_2$），比赛的时间越早月好，一定选择 $\max(l_1,l_2)$。于是我们需要有 $\max(l_1,l_2)\leq\min(r_1,r_2)$，化简一下就是 $l_2\leq r_1$。然后我们可以看成这两个选手“合并”成了一个参赛时间为 $[\max(l_1,l_2),\max(r_1,r_2)]$ 的选手。

贪心地想，当我们由于 $l_2>r_1$ 需要花代价修改时，如果想将 $r_1$ 增加 $1$，那么不论这个选手是由多少选手“合并”得到的，也只要花费 $1$ 的代价。而且我们只会把 $r_1$ 增加到 $r_1=l_2\leq r_2$，不会对 $\max(r_1,r_2)$ 产生影响。

记 $R_{2^n+i-1}=r_i$，$R_p=\max(R_{2p},R_{2p+1})$。

于是可以设计一个 DP：$f_{p,i}$ 表示第 $p$ 场比赛“合并”出的选手的参赛时间是 $[i,R_p]$ 的最小代价。

归纳证明 $f_{p,i}$ 是凸的。做前缀 $\min$ 后转移是对位加。直接 slope-trick 记录拐点即可。

注意到比赛结构是完全二叉树，不需要困难数据结构，暴力合并 vector 然后排序就是 $O(N^22^N)$。归并排序可以做到 $O(N2^N)$。

---

详细说明一下如何算答案。记 $f'_{p,i}$ 是 $f_{p,i}$ 的前缀 $\min$。

记 $u=2p,v=2p+1$，若 $R_u>R_v$ 则交换 $u,v$。

直接写出转移是 $f_{u,i}+f_{v,j}+\max(j-R_u,0)\to f_{p,\max(i,j)}$。

由凸，化成 $f'_{u,i}+f'_{v,j}+\max(j-R_u,0)\to f'_{p,k\geq\max(i,j)}$

三个凸函数，直接对位加。放到 slope-trick 就是合并拐点集合。

注意现在得到的函数最后一段的斜率是 $1$，做前缀 $\min$ 就是把这段丢掉。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define f(i,j,k) for(int i=j;i<=k;++i)
#define g(i,j,k) for(int i=j;i>=k;--i)
int n,m,s,l;
const int N=1<<20;
struct Kazemaru{
	int r,c;
	vector<int>a;
	inline void min(int x){
		a.push_back(x);
		sort(a.begin(),a.end());
		c+=a.back()-x;a.pop_back();
	}
};
int L[N],R[N];
Kazemaru dfs(int x){
	if(x>=n){x-=n-1;return {R[x],0,{L[x]}};}
	Kazemaru u=dfs(x*2),v=dfs(x*2+1),w;
	if(u.r>v.r)swap(u,v);v.min(u.r);
	for(int x:v.a)u.a.push_back(x); 
	w={max(u.r,v.r),u.c+v.c,u.a};
	return w;
}
signed main(){
	cin>>n;n=1<<n;
	f(i,1,n)cin>>L[i]>>R[i];
	cout<<dfs(1).c;
	return 0;
}
```

把结构体拆开可以变得更短：[441B](https://atcoder.jp/contests/agc069/submissions/60178675)。

---


# [ABC389G] Odd Even Graph

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc389/tasks/abc389_g

给定一个正偶数 $ N $ 和一个素数 $ P $。

对于每个 $ M = N-1, \ldots, \frac{N(N-1)}{2} $，请解决以下问题：

统计满足以下条件的 $ N $ 顶点 $ M $ 边无向连通简单图的数量，并对 $ P $ 取模：
- 从顶点 $ 1 $ 出发的最短距离为偶数的顶点数量与最短距离为奇数的顶点数量相等。

## 说明/提示

### 约束条件

- $ 2 \leq N \leq 30 $
- $ 10^8 \leq P \leq 10^9 $
- $ N $ 是偶数
- $ P $ 是素数
- 输入均为整数

### 样例解释 1

对于 $ 4 $ 顶点 $ 3 $ 边的情况，满足条件的图有 $ 12 $ 个。  
对于 $ 4 $ 顶点 $ 4 $ 边的情况，满足条件的图有 $ 9 $ 个。  
对于 $ 4 $ 顶点 $ 5 $ 边的情况，满足条件的图有 $ 3 $ 个。  
对于 $ 4 $ 顶点 $ 6 $ 边的情况，满足条件的图有 $ 0 $ 个。

### 样例解释 3

注意答案需对 $ P $ 取模。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4 998244353```

### 输出

```
12 9 3 0```

## 样例 #2

### 输入

```
6 924844033```

### 输出

```
810 2100 3060 3030 2230 1210 450 100 10 0 0```

## 样例 #3

### 输入

```
10 433416647```

### 输出

```
49218750 419111280 321937732 107111441 372416570 351559278 312484809 334285827 317777667 211471846 58741385 422156135 323887465 54923551 121645733 94354149 346849276 72744827 385773306 163421544 351691775 59915863 430096957 166653801 346330874 185052506 245426328 47501118 7422030 899640 79380 4536 126 0 0 0 0```

# 题解

## 作者：封禁用户 (赞：14)

**如果你想保证今后你能够见了计数有可能切，耐心读完，不要只看转移公式。**

我有一个 $O(n^7)$ 的做法（与其他做法一样常数极小），这里来介绍一下。

首先我们可以想到一个非常明显的方法：一层一层 $dp$。我们可以观察到每一层的点离 $1$ 号点的距离相同，它们之间随便连边，而下一层每个点都能通过上一层连边过来。距离差 $\ge 2$ 的层之间没有连边。

$dp_{i,j,k,l,T}$ 表示使用 $n$ 以内的 $i$ 个结点构成，最后一层有 $j$ 个点，离 $1$ 号点距离为偶数（即在偶数层）的结点数量为 $k$，连了 $l$ 条边，最后一层离 $1$ 号点距离与 $T$ 模 $2$ 同余的方案数。

然后我们发现**同一层之间随便连边**的方案数已经够不好处理了，相邻两层连边还要考虑**后面的一层每个点**是不是**都被前面一层的点连了**，非常难缠。

于是我们微调一下 $dp$ 状态：$dp_{i,j,k,l,T}$ 表示使用 $n$ 以内的 $i$ 个结点构成，最后一层有 $j$ 个点，离 $1$ 号点距离为偶数（即在偶数层）的结点数量为 $k$，**指定了 $l$ 条边可以随便选择连接或不连接**，最后一层离 $1$ 号点距离与 $T$ 模 $2$ 同余的方案数。

我们假设上一层有 $j$ 个点，除去这一层总共已选 $i$ 个点和 $l$ 条**自由边**，这一层有 $j_1$ 个点，那么选择这 $j_1$ 个点有 $C_{n-i}^{j_1}$ 种方法。

接着我们可以看出，这个 $dp$ 状态，非常容易讨论**同一层之间随便连边**的情况。这部分由上一层转移到这一层只用丢进去 $\frac{1}{2}j_1(j_1-1)$ 条自由边即可。

但是，**后面的一层每个点都被前面一层的点连了**这个不好处理。知道一点容斥的人可以立即看出，我们钦定这 $j_1$ 个点里面有 $j_2$ 个与上一层连通性不限制，$j_1-j_2$ 个**不连通**，那么这 $j_1-j_2$ 个点与上一层之间必然没有连边，而剩下 $j_2$ 个点与上一层的 $j$ 个点随意连边，贡献 $j_2j$ 条自由边。最后乘上容斥系数 $(-1)^{j_1-j_2}C_{j_1}^{j_2}$，这样就好转移了。

总体来说，转移方程如下：

$$\forall i,j,k,l,T,j_1\ge 1,0\le j_2\le j_1,(-1)^{j_1-j_2}C_{j_1}^{j_2}C_{n-i}^{j_1}dp_{i,j,k,l,T}\rightarrow dp_{i+j_1,j_1,k+Tj_1,l+\frac{1}{2}j_1(j_1-1)+j_2j,1-T}$$

边界条件即为 $dp_{1,1,1,0,0}=1$。

转移完毕后，我们设 $f_i=\sum\limits_{j,T}dp_{n,j,\frac{n}{2},i,T}$，也就是满足题目的条件情况下有 $i$ 条**自由边**的方案数。最后，有切切实实的 $i$ 条边方案数就是：

$$\sum\limits_{j\ge i}C_j^i f_j$$

完结撒花。

我们分析一下时间复杂度：枚举出 $i,j,k,l$ 总共有 $O(n^5)$ 种情况，然后枚举 $j_1,j_2$ 只有 $O(n^2)$ 种情况，转移时间复杂度就是 $O(n^7)$。统计的话时间复杂度为 $O(n^4)$，不是瓶颈。

最终时间复杂度就是 $O(n^7)$，暴打一切 $O(n^8)$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,modp,C[455][455],dp[35][35][35][905][2],fuck[905];

signed main(){
	cin>>n>>modp;dp[1][1][1][0][0]=1;
	for(int i=0;i<=450;i++){
		C[i][0]=1;for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%modp;
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=i;j++){
			for(int k=1;k<=i;k++){
				for(int L=0;L<=i*(i-1)/2;L++){
					for(int jj=1;jj<=n-i;jj++){
						for(int kk=0;kk<=jj;kk++)for(int o=0;o<2;o++)(dp[i+jj][jj][k+o*jj][L+kk*j+jj*(jj-1)/2][o^1]+=dp[i][j][k][L][o]*((jj-kk)%2==1?modp-C[jj][kk]:C[jj][kk])%modp*C[n-i][jj])%=modp;
					}
				}
			}
		}
	}
	for(int i=0;i<=n*(n-1)/2;i++)for(int j=1;j<=n;j++)(fuck[i]+=dp[n][j][n/2][i][0]+dp[n][j][n/2][i][1])%=modp;
	for(int i=n-1;i<=n*(n-1)/2;i++){
		int ans=0;
		for(int j=i;j<=n*(n-1)/2;j++)ans=(ans+fuck[j]*C[j][i])%modp;
		cout<<ans<<' ';
	}
	return 0;
}
```

---

## 作者：ZepX_D (赞：11)

最短路显然是从 1 开始 bfs 分层，最后是要对每个 $m$ 求奇数层点数等于偶数层点数的方案数。

很显然是一个计数 dp。

那么我们可以根据 bfs 的过程逐层添加点，具体的，设 $f_{0/1,i,j,l,k}$ 为上一层为偶数/奇数层，奇数层共有 $i$ 个点，偶数层共有 $j$ 个点，上一次有 $l$ 个点，一共连了 $k$ 条边的方案数，每次枚举这一层添加的点数 $a$ 和边数 $b$ 即可。

一个值得注意的细节就是当前层不仅可以向上一层的点连边，他们也可以在本层互相连边，这样并不会影响 1 到他们的最短路。

设 $g_{i,j,k}$ 为 当前层 $j$ 个点向上一层 $i$ 的点连边，加上本层间的边
共有 $k$ 条边的方案数。

那么有如下转移（省略取模）：
$$
f_{0,i,j+a,a,k+b} \gets f_{0,i,j+a,a,k+b}+f_{1,i,j,l,k}\times\binom{n-i-j}{a}\times g_{l,a,b}\\
f_{1,i+a,j,a,k+b} \gets f_{1,i+a,j,a,k+b}+f_{0,i,j,l,k}\times\binom{n-i-j}{a}\times g_{l,a,b}
$$
现在仅剩的问题是如何求出 $g_{i,j,k}$ 。

设 $t_{i,j,k}$ 为本层 $j$ 个点仅向上一层 $i$ 连边，本层间不连边的方案数。那么我们可以枚举新添加的这个点与上一层的连边条数，有：
$$
t_{i,j,k} \gets t_{i,j,k}+t_{i,j-1,k-l}\times\binom il
$$
求完 $t$ 数组后枚举层间的连边数求出 $g$ 数组，如下：
$$
g_{i,j,k+l} \gets g_{i,j,k+l}+t_{i,j,k}\times\binom{\frac{j(j-1)}{2}}{l}
$$
总时间复杂度为 $O(n^8)$，但是这种维数比较多的 dp 有效状态数并不多，循环枚举的时候卡一下上界和下界就会发现常数小到离谱。

[code](https://atcoder.jp/contests/abc389/submissions/61847605)

---

## 作者：2008verser (赞：5)

场上大脑被标号分配卡死了。没有困难的性质需要观察，只要找到自然的方法，顺着计数就能做出来。

看到要关注每个点的最短路，那么肯定是要先将图分层，就像这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/npnhsaa2.png)

换言之我们计数若干层点的“组合体”的数目（组合体和图形成双射）。这些组合体要求：

- 每个点都与上一层有至少一条边相连。
- 只有相邻的层有边相连。
- 一个层内随意连边
- 一号点在第一层。
- 奇数层和偶数层总点数相等。

设计状态 $f_{i,n1,m,d,0/1}$ 表示有 $i$ 个点 $m$ 条边的组合体数目，奇偶点之差为 $d$，最后一层有 $n1$ 个点，最后一层是奇数层呢还是偶数层呢。

转移枚举新一层点数 $s$ 和边数 $x$。这里 $x$ 既包括两层之间的边，也包括下一层自己内部随意连的边。

下意识地设 $h_{n1,s,x}$ 表示转移系数，这样转移就是
$$
f_{i,n1,m,d,op}\times h_{n1,s,x}\times{i-1+s\choose s}\to f_{\ldots}
$$
组合数是为了分配标号，减一是因为 $1$ 一定在第一层。接下来想想，为了让这个方程是对的，$h$ 的两个点集应是已经标号的。

那么求 $h$ 的方法就很清晰了，对于每个 $s$ 的点枚举它向 $n1$ 连了 $a(a\gt 1)$ 条边那就是 $n1\choose a$ 种方案，乘起来。

比如我要算两层之间连了 $x'$ 条边，这个数量就是
$$
\sum_{a_1+a_2+\ldots+a_s=x'}\prod{n1\choose a_i}
$$
还没算新层内部的连边呢。我可以先做上面这部分，接着同层转移就可以求出最终的 $h$ 了。

内部连边就是在 $s\choose 2$ 条边里选啊，这个不必多说了。

我们进行一个代码的写，在 $n=30$ 计算次数达到了 $2\times 10^9$ 左右。

因此进行一个枝的剪（或者直接开 O2），具体可以看我的代码。atcoder 上在不开 O2 情况下运行了三百多毫秒。

~~然而本地 $n=30$ 跑了两秒。~~

[AC 链接](https://atcoder.jp/contests/abc389/submissions/61877264)

---

## 作者：YYZ1208 (赞：4)

# abc389G

## 题意：

有 $n$ 个点（$n\le 30$），让你求满足使得与 $1$ 的距离为奇数和为偶数的点数相同的图的个数模 $p$。

## 做法：

看到题目有点懵，但是其实只是一个简（e）单（xin）的高维 dp 而已。

以下的“深度”都指那个点到 $1$ 的最短路的长度。

首先我们有一个小结论：对于两个点，如果他们的深度相差超过 $1$，那么他们之间不可能直接连边（不然就最多相差 $1$ 了）。

根据这个结论，我们可以得知，一个边上的两个点的深度最多差 $1$。

所以我们可以想一个 dp：

考虑按深度 dp：首先我们要知道现在的深度的奇偶性（ $i\in\{0,1\}$ ），还要知道现在连了几条边（ $j$ ），也得知道现在深度为奇数（ $k$ ）和偶数（ $l$ ）的点的个数，因为这一层的边最多只会连到上一层，所以还要记录上一层的点数（ $s$ ）。

这时我们的状态也就设好了：$f_{i,j,k,l,s}$。

考虑转移：

我们枚举下一层的点数（ $x$ ）以及下一层的点向下一层和这一层连的边数（ $y$ ）。

我们令 $g_{x,y,z}$ 表示 $y$ 个点连出 $z$ 条边使得那 $y$ 个点每个都至少与 $x$ 个点中的一个连边的方案数。

这时我们的转移就比较明了了：

$i$ 为 $0$ 时：$f_{1,j+y,k,l+x,x}=f_{1,j+y,k,l+x,x}+f_{0,j,k,l,s}\cdot \binom{n-k-l}{x}\cdot g_{s,x,y}$

$i$ 为 $1$ 时：$f_{0,j+y,k+x,l,x}=f_{0,j+y,k+x,l,x}+f_{1,j,k,l,s}\cdot \binom{n-k-l}{x}\cdot g_{s,x,y}$

中间的组合数是编号的方案数。

那么我们再来看一下如何求 $g_{x,y,z}$：

我们考虑多加一个点($y+1$)的变化，我们假设这个新点连了 $i$ 条边，那么就有 $\binom{x+y}{i}-\binom{y}{i}$ 种方案，因为它至少要连一条边到那 $x$ 个点中，所以要减去全部连到那 $y$ 个点方案，即 $\binom{y}{i}$。

所以我们就有以下转移：

$g_{x,y,z}=\sum_{i=1}^{\min(z,x+y-1)}g_{x,y-1,z-i}\cdot (\binom{x+y-1}{i}-\binom{y-1}{i})$

至此 dp 部分就完结了。

关于时间复杂度：

对于 $g$ 它前两维都是 $O(n)$，第三维 $O(n^2)$，转移为 $O(n)$，时间 $O(n^5)$，因为 $n$ 很小，所以没问题。

而 $f$ 第二维是 $O(n^2)$ 的，后三维都是 $O(n)$ 的，转移是 $O(n^3)$，总共是 $O(n^8)$。

虽然它看着很悬，但是它常数小啊，基本上每一维的取值都会除个 $2$，合起来就能过了。

所以这道简（e）单（xin）的 dp 题启示我们要对自己的程序常数保持充分自信。


[Code](https://atcoder.jp/contests/abc389/submissions/61859363)

---

## 作者：born_to_sun (赞：4)

让我们来粗略证明一下官解 $O(n^8)$ 的常数大约为多少。

先复述一下官解的 dp 状态和转移。

$f_{i,j,A,k,0/1}$ 表示选了 $i$ 个最短路为奇数的点，$j$ 个最短路为偶数的点，一共有 $A$ 条边，上一层的点数为 $k$，距离为偶数 / 奇数。

转移为枚举新一层点的数量 $d$，以及边的数量 $B$。

于是我们得到了这样一个计算转移次数的求和式子，其中 $m={n\over 2}$。

$$ \sum_{i=1}^m\sum_{j=1}^m {(i+j)(i+j-1)\over 2}(\sum_{k=1}^i\sum_{d=1}^{m-j}(kd+{d(d-1)\over 2}-d+1)+\sum_{k=1}^j\sum_{d=1}^{m-i}(kd+{d(d-1)\over 2}-d+1))$$

式子中的所有小写变量和上文含义相同，$A$ 上界为 ${(i+j)(i+j-1)\over 2}$，$B$ 的上界为 $kd+{d^2\over 2}$，下界为 $d$，后面有两个求和是在枚举奇偶。

### 法 1，拉格朗日插值暴求常数
上述式子前 $9$ 个点值为：
```cpp
1 0
2 20
3 438
4 3940
5 22050
6 91098
7 304388
8 869232
9 2199420
```
求得多项式为：
$$f(x)=0.0472x^8+0.0194x^7+0.1389x^6+0.0278x^5-0.2694x^4-0.0472x^3+0.0833x^2$$

可以求得常数约为：
$$1\over 5424$$

插值 / 代入可以求出 $m=15$ 时点值为 $125937000(\approx 1.3\times 10^8)$（其实暴算更快）。

拉插的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
double x[N],y[N];
double f[N],g[N],h[N];
int n;
void lang(){
	g[0]=1;
	for(int i=1;i<=n+1;i++){
		for(int j=n+1;j>=0;j--){
			g[j]=g[j]*(-x[i])+(j? g[j-1]: 0);
		}
	}
	for(int i=1;i<=n+1;i++){
		memset(h,0,sizeof(h));
		double lst=g[n+1];
		for(int j=n;j>=0;j--){
			h[j]=lst;
			lst=g[j]+lst*x[i];
		}
		double bs=y[i];
		for(int j=1;j<=n+1;j++) if(i!=j) bs/=x[i]-x[j];
		for(int j=0;j<=n;j++) f[j]+=h[j]*bs;
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n+1;i++) cin>>x[i]>>y[i];
	lang();
	for(int i=n;i>=0;i--){
		if(f[i]>0&&i!=n) cout<<"+";
		printf("%.4lfx^%lld",f[i],i);
	}
	return 0;
}
```
### 法 2，适当放缩暴求常数
因为
$${n^{k+1}\over k+1} \leq \sum_{i=1}^n i^k \leq {(n+1)^{k+1}\over k+1}$$

所以在以下的证明中，我们姑且认为中间那个式子等于左边那个式子。

暂且忽略 $-d+1$ 这一项，并把 $(i+j)(i+j-1)$ 和 $d(d-1)$ 改写为平方，因为它影响不大，而且不忽略的话后面的计算会更恶心，然后对后面的两个求和号进行化简，得到：
$$ \sum_{i=1}^m\sum_{j=1}^m {(i+j)^2\over 2}({i^2{(m-j)}^2\over 4}+{i{(m-j)}^3\over 6}+{j^2{(m-i)}^2\over 4}+{j{(m-i)}^3\over 6})$$

提出一个常数 $1\over 24$：
$$ {1\over 24}\sum_{i=1}^m\sum_{j=1}^m (i+j)^2(3i^2{(m-j)}^2+{2i(m-j)}^3+3j^2{(m-i)}^2+{2j(m-i)}^3)$$

借助[外部力量](https://zh.numberempire.com/expressioncalculator.php)，对后面这个超级大式子进行暴力展开：

$$ {1\over 24}\sum_{i=1}^m\sum_{j=1}^m 2j^3m^3+6ij^2m^3+6i^2jm^3+2i^3m^3+3j^4m^2-6ij^3m^2-18i^2j^2m^2-6i^3jm^2+3i^4m^2-2ij^5+2i^2j^4+8i^3j^3+2i^4j^2-2i^5j$$

然后对每一项单独计算常数，继续化简为：
$${1\over 24}({2\over 16}+{6\over 6}+{6\over 6}+{2\over 16}+{3\over 5}-{6\over 8}-{18\over 9}-{6\over 8}+{3\over 5}-{2\over 12}+{2\over 15}+{8\over 16}+{2\over 15}-{2\over 12})m^8$$

最终结果为：

$${23\over 1440}m^8 \approx {1\over 16028}n^8 \approx 4\times 10^7$$

因为放缩过度，这个结果和插值计算的结果相差较大，但这并不意味着这个方法没用，在遇到极为简单的式子时，这个方法既高效也不会相差很多。

### 法 3，直接拿正解跑
但是用真实程序跑一下，结果为 $57919975(\approx 6\times 10^7)$，比理论值小很多，这是因为即使经过这么精细的计算，仍然会有一些无效状态我们没有排除。

代码如下，代码中 $cnt$ 是用来记录 for 次数的。最开始预处理的复杂度很低就忽略了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=31;
int n,mod;
int g[N][N][N*N];
int c[N][N];
int qpow(int a,int x){
	int sum=1;
	while(x){
		if(x&1) sum=sum*a%mod;
		a=a*a%mod;
		x>>=1;
	}return sum;
}
int h[N*2];
void init(){
	for(int i=1;i<=n;i++){
		g[i][0][0]=1;
		for(int j=0;j<n;j++){
			memset(h,0,sizeof(h));
			for(int A=1;A<=i;A++){
				for(int B=0;B<=j;B++) h[A+B]+=c[i][A]*c[j][B]%mod;
			}
			for(int i=1;i<=n;i++) h[i]%=mod;
			for(int k=0;k<=n*n;k++){
				if(!g[i][j][k]) continue;
				int vl=(g[i][j][k]%=mod);
				for(int A=1;A<=i+j;A++){
					g[i][j+1][k+A]+=vl*h[A]%mod;
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n*n;k++) g[i][j][k]%=mod;
		}
	}
}
int cnt;
int f[N][N][N][N*N][2];
//奇数，偶数，上一次，边数，当前奇偶
int res[N*N];
void solve(){
	f[0][1][1][0][0]=1;
	for(int A=0;A<=n;A++){
		for(int B=0;B<=n;B++){
			for(int C=1;C<=n;C++){
				for(int D=0;D<=n*n;D++){
					int vl=(f[A][B][C][D][0]%=mod);
					if(vl){
						for(int i=1;i+A+B<=n&&i+A<=n/2;i++){
							int up=C*i+i*(i-1)/2;
							int v0=vl*c[A+B+i][i]%mod;
							for(int j=i;j<=up;j++){
								cnt++;
								f[A+i][B][i][D+j][1]+=v0*g[C][i][j]%mod;
							}
						}
					}
					vl=(f[A][B][C][D][1]%=mod);
					if(vl){
						for(int i=1;i+A+B<=n&&i+B<=n/2;i++){
							int up=C*i+i*(i-1)/2;
							int v0=vl*c[A+B+i][i]%mod;
							for(int j=i;j<=up;j++){
								cnt++;
								f[A][B+i][i][D+j][0]+=v0*g[C][i][j]%mod;
							}
						}
					}
					if(A+B==n) res[D]+=f[A][B][C][D][0]+f[A][B][C][D][1];
				}
			}
		}
	}
}
signed main(){
	// cin>>n>>mod;
	n=30;mod=998244353;
	c[0][0]=1;
	for(int i=1;i<N;i++){
		c[i][0]=c[i-1][0];
		for(int j=1;j<=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}
	init();
	solve();
	for(int i=n-1;i<=n*(n-1)/2;i++){
		res[i]=res[i]%mod*qpow(n,mod-2)%mod;
		// cout<<res[i]<<' ';
	}
	cerr<<cnt;
	return 0;
}
```

---

## 作者：Register_int (赞：4)

可以转化成从 $1$ 开始 bfs 染色，要求黑点白点个数一样。于是你转移时可以一次填最短距离都相等的一层。

考虑 dp，设 $dp_{i,j,k,l}$ 表示当前放了 $i$ 个点，这一层放了 $j$ 个，黑点个数减白点个数为 $k$，用了 $l$ 条边的方案数。这里有一个小技巧：可以直接钦定这一层是白色，新加一层可以将前面所有颜色反转，这样就能少记录一维颜色。每次新加一层枚举多加了 $p$ 个点，系数由两部分组成：

- 从剩下的点中选出 $p$ 个点的方案数，即 $\binom{n-i}p$。
- 在这层与上层间连边和在这层自身连边的方案数。设连了 $q$ 条，方案数为 $f_{j,p,q}$。

考虑怎么预处理 $f_{j,p,q}$。仍然 dp，固定 $j$，每次在这层加一个点，那么这个点必须和上一层连至少一条边。枚举这个点和上一层连了 $x$ 条，和这一层连了 $y$ 条，方案数为 $\binom jx\binom{p-1}yf_{j,p-1,q-x-y}$。转移复杂度 $O(n^2)$，预处理复杂度 $O(n^2m\times n^2)=O(n^6)$。

然后就能算出最终方案数，转移复杂度 $O(nm)$，总复杂度 $O(n^3m\times nm)=O(n^8)$。可以发现有值的位置并不会很多，转移时跳过 dp 值为 $0$ 的即可缩小非常多的常数。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

struct Mod {
    ll m, p;
    void init(int pp) { m = ((__int128)1 << 64) / pp; p = pp; }
    ll operator () (ll x) {
        return x - ((__int128(x) * m) >> 64) * p;
    }
} mod;

int cmod;

int n, c[600][600], f[40][40][600], dp[40][40][81][600], ans[600];

int main() {
	scanf("%d%d", &n, &cmod), mod.init(cmod);
	for (int i = 0; i < 600; i++) c[i][0] = 1;
	for (int i = 1; i < 600; i++) {
		for (int j = 1; j <= i; j++) c[i][j] = mod(c[i - 1][j] + c[i - 1][j - 1]);
	}
	for (int i = 1; i <= n; i++) {
		f[i][0][0] = 1;
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= n * (n + 1) / 2; k++) {
				for (int l = 1; l <= i; l++) {
					for (int r = 0; r < j; r++) {
						if (k >= l + r) f[i][j][k] = mod(f[i][j][k] + mod((ll)c[i][l] * c[j - 1][r]) * f[i][j - 1][k - l - r]);
					}
				}
			}
		}
	}
	dp[1][1][1 + 35][0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			for (int k = -i; k <= i; k++) {
				for (int l = i * (i - 1) / 2; ~l; l--) {
					int x = dp[i][j][k + 35][l]; if (!x) continue;
					for (int r = 1; r <= n - i; r++) {
						int z = mod((ll)c[n - i][r] * x);
						for (int p = (i + r) * (i + r + 1) / 2; p >= l; p--) {
							int &y = dp[i + r][r][r - k + 35][p];
							y = mod(y + (ll)z * f[j][r][p - l]);
						}
					}
				}
			}
		}
	}
	for (int i = n - 1; i <= n * (n - 1) / 2; i++) {
		for (int j = 1; j <= n; j++) ans[i] = mod(ans[i] + dp[n][j][35][i]);
		printf("%d ", ans[i]);
	}
}
```

---

## 作者：201012280925LSY (赞：3)

## 前言
作者是依照官解做出来的题，同时无论是官解还是题解区的大佬们的题解思维都太快了，令作者这个蒟蒻有点读不懂，所以才写了这篇题解。
## 题意
给出正整数 $N$ 与一个质数 $P$。对于图 $G$ 有 $N$ 个点，有 $M$ 条边，且 $N-1 \le M \le \frac{N(N-1)}{2}$，同时图 $G$ 中的点到结点 $1$ 的距离为偶数的个数与到结点 $1$ 的距离为奇数的个数相等。求这样的图的个数对 $P$ 取模的结果。
## 思路
先说距离的定义是啥，我们知道最简单的最短路算法就是宽度优先搜索，所以一个点到结点 $1$ 的距离即为从结点 $1$ 开始宽搜，搜到这个点用的次数。

对于这样的计数题我们肯定先往动态规划上想。我们令状态的答案为在这个情况下满足题目条件的图的个数。

### 状态的设计
然后来考虑状态的设计。既然有关于点到结点 $1$ 的距离，所以状态的设计就应该有一维是关于深度的。其次，图的基本信息也应当记录，本题中的图的基本信息即为图的点数，边数。因为本题的点数不变，一直为 $N$，所以就不用管。那么也有一维表示有多少条边。

题目中一个重要的要求就是点到结点 $1$ 的距离为偶数的点数和点到结点 $1$ 的距离为奇数的点数相等，所以还有两维是点到结点 $1$ 的距离为偶数的点数和点到结点 $1$ 的距离为奇数的点数。

这个时候我们的状态就是这样：$DP_{i,j,k,l}$，表示有这么多的图的点距离小于等于 $i$，结点间有 $j$ 条边，有 $k$ 个点到结点 $1$ 的距离为奇数，有 $l$ 个点到结点 $1$ 的距离为偶数。

然后怎么转移呢？然而却发现少了点东西。因为如果我们想要增加一个点到结点 $1$ 距离为奇数或偶数，那么就得从原来距离为 $i-1$ 的点连边到新的点，增加一个距离为 $i$ 的点。所以还得记录上一层的点数，即距离为 $i-1$ 的点的个数。

状态就变成了：$DP_{i,j,k,l,s}$，表示图的点距离小于等于 $i$，结点间有 $j$ 条边，有 $k$ 个点到结点 $1$ 的距离为奇数，有 $l$ 个点到结点 $1$ 的距离为偶数，距离为 $i$ 的点的个数为 $s$。

### 考虑转移
当 $i$ 为偶数时，令新连的点的数量为 $x$。因为我们要从剩下的点里选择出新连的点，所以根据组合的公式，方案数即为 $\binom{N-k-l}{x}$。

根据一个小的结论：每一个距离为 $i$ 的点都至少会和一个距离为 $i-1$ 的相连。

然后我们枚举 $x$ 个点，判断它们可能与哪些距离为 $i$ 的点相连。最后再在这 $x$ 个点之间自由添加边。由于这种方案始终只与连的边的个数、距离为 $i$ 的点的个数和距离为 $i+1$ 的点的个数相关，所以我们令结果为 $f(x,y,z)$，其中 $x$ 表示距离为 $i$ 的点的个数，$y$ 表示距离为 $i+1$ 的点的个数，$z$ 表示连的边的总个数。

因为 $i$ 为偶数，所以 $i+1$ 必然为奇数，则有：
$$
DP_{i+1,j+z,k+y,l,y}=DP_{i+1,j+x,k+y,l,y}+DP_{i,j,k,l,s} \times \binom{N-k-l}{y} \times f(x,y,z)
$$

这个转移是什么意思呢？$i+1$ 表示新连的点必然和上一层的点相连，距离自然加一；$j+z$ 是因为总边数增加 $z$；$k$ 因为新增的点距离都为奇数，所以 $k$ 不动；$l+y$ 距离为奇数的点加上新增的点的个数；$y$ 是这一层的点数，即新增的距离为 $i+1$ 的个数。

同时因为方案数都是从 $DP_{i,j,k,l,s}$ 转移过来的，所以首先先把选择的点的方案数乘上 $DP_{i,j,k,l,s}$，然后再乘上每一种选点的方案数的结果，就形成了这个转移方程。

再考虑 $i$ 为奇数的时候的转移，发现其实无非就是把原来加在 $l$ 上的加到 $k$ 上而已。

同理可得转移方程为：
$$
DP_{i+1,j+z,k,l+y,y}=DP_{i+1,j+z,k,l+y,y}+DP_{i,j,k,l,s} \times \binom{N-k-l}{y} \times f(x,y,z)
$$

接下来我们来考虑怎样求解 $f(x,y,z)$。假设现在有一个新的点（不计算在 $y$ 个点以内），根据我们 $f(x,y,z)$ 的定义，这个新的点必然和这 $x$ 个点以及这 $y$ 个点随便连边。那么它连边也可以视为它与其他每一个点的边中选择几个，这个总边数易得为 $x+y$。设它总共连了 $i$ 条边，那么方案数即为 $\binom{x+y}{i}-\binom{y}{i}$。为啥还要减去 $\binom{y}{i}$ 呢？根据之前的小结论，距离为 $i+1$ 的点必然要和至少一个距离为 $i$ 的点连边，所以还要减去只和 $y$ 个点连边的方案（不和 $x$ 有关联是因为默认没有和任何一个 $x$ 个点中的点连边）。

那么我们枚举一共连了几条边，得出 $f(x,y,z)$ 的转移即为：
$$
f(x,y,z)=\sum_{i=1}^{\min(z,x+y-1)}f(x,y-1,z-i) \times (\binom{x+y}{i}-\binom{y}{i})
$$

注意在求和符号中的 $\min(z,x+y-1)$，对 $z$ 和 $x+y-1$ 是因为总共只连了 $z$ 条边，同时新的点最多只能和其他点连 $x+y-1$ 条边（不能和自己连边）。

那么动态规划的部分 OK 了。

### 优化
注意到整片似乎都没和 $i$ 的大小相关，思考一下即可得出这个问题只和 $i$ 的奇偶性有关。所以就可以把状态中的 $i$ 改成 $0/1$。

同时因为运算过程中的组合运算较多，所以也可以
杨辉三角预处理。
### 时间复杂度
时间复杂度其他题解已经解释过了，这里不再进行赘述。

最后记得在运算过程中加上取模运算。
## Code
如果仍然不是很懂的话，可以看一下代码中写的注释，加深理解。

[代码与实际效果](https://atcoder.jp/contests/abc389/submissions/61943949)

---

## 作者：rubbishZZZ (赞：2)

## ABC389G Odd Even Graph 从 $n^8$ 到 $n^6$



#### 题意：

- 给定 $n$，对于 $M=n-1\sim\frac{n(n-1)}{2}$，求有多少边数为 $M$、点数为 $n$ 的连通无向图，满足距离 $1$ 最短路长度为奇数和偶数的点个数相同。
- $n\leq 30$，对质数取模。



#### 解法：

- 考虑分层 DP，可行的连边只有相邻两层以及同层之间的点对。

  设 $f_{i,j,k,l,m}$ 表示前 $i$ 个点，构成了前 $j$ 层，奇偶层之差为 $k$，边数为 $l$，最后一层有 $m$ 个点。

  状态中 $i$ 具体值不重要，只和奇偶有关系，故状态数是 $O(n^5)$。

  通过预处理 $g_{i,j,k}$ 表示 $i$ 个点和 $j$ 个点之间连了 $k$ 条边，可以做到总复杂度 $O(n^8)$。

- 进一步，转移 $f$ 的时候可以一个点一个点的加入。

  设 $h_{i,j,k,l,m,o}$，前五项和 $f$ 意义相同，$o$ 表示多加了几个点。

  转移 $h$ 时只考虑相邻两层的边，状态数 $O(n^6)$，转移复杂度 $O(n)$，总复杂度 $O(n^7)$。

  通过 $h$ 转移出 $f$ 后，同层间的边没有考虑到，可以 $O(n^2)$ 算一下同层边，这部分的复杂度也是 $O(n^7)$。

  故总复杂度 $O(n^7)$。

- 我们发现这个做法复杂度的大头在于边数，如果有方法不记录边数就很好。

  设 $ans_i$ 表示 $M=i$ 时的答案，我们设生成函数 $F(x)=\sum\limits_{i=0}^{\frac{n(n-1)}{2}} ans_ix^i$。

  这个生成函数有什么好处？我们考虑某个 $F(w)$，我们发现转移时不需要记录边选了几条，只需要用一个转移系数即可。

  我们选出 $O(n^2)$ 个 $w$ 进行计算。我们初始时 $O(n^6)$ 预处理第一个解法中的 $g$，那么对于单个 $w$，$x$ 个点和 $y$ 个点之间的转移系数 $h_{x,y}$ 就可以通过 $g$ $O(n^4)$ 处理出来。

  这个时候的状态设为 $f_{i,j,k,l}$ 表示最短路奇偶性为 $i$，奇数层 $j$ 个点，偶数层 $k$ 个点，最后一层有 $l$ 个点。转移时只需枚举下一层点的个数即可 $O(n^4)$ 计算。

  我们计算出了 $O(n^2)$ 个 $F(x)$ 后，可以 $O(n^4)$ 复原出 $F(x)$ 的系数，那么我们就解出了每个 $ans_i$。

  $w$ 要选 $O(n^2)$ 个，故总复杂度 $O(n^6)$。

---

## 作者：Otue (赞：2)

### 题目翻译

给你一个正偶数整数 $N$ 和一个质数 $P$ 。对于 $M = N-1, \ldots, \frac{N(N-1)}{2}$ ，求解下面的问题。

有 $N$ 个顶点，标号为 $1$ 至 $N$ ，且有 $M$ 条边的无向连接简单图中，有多少个满足以下条件：与顶点 $1$ 的最短距离为偶数的顶点数等于与顶点 $1$ 的最短距离为奇数的顶点数？求这个数的模数 $P$ 。

### 思路

此类图论分层的题还是做少了。首先可以模仿 bfs 的过程，初始层只有点 $1$，然后每次扩展一层点，那么奇数层的最短距离就为偶数，偶数层的最短距离就位奇数，可以总结为一下模型：

当且仅当边满足以下条件时，该图才是有效的：

* 每个距离为 $i$ 的顶点至少与一个距离为 $i-1$ 的顶点相连。
* 距离相同的顶点之间的边可以自由选择。
* 距离相差 $2$ 或更大的顶点之间没有边。

那么可以开始 dp 了。定义 $dp_{i,j,k,l}$ 表示当前填充了 $i$ 个点，本层有 $j$ 个点，奇偶点的差值为 $k$，一共用了 $l$ 条边。（其中，第几层的条件可以被省略）

转移直接枚举下一层填充 $A$ 个数，用了 $p$ 条边。即为 $dp_{i,j,k,l}\to dp_{i+A,A,A-k,p}$。奇偶点差值在奇数减偶数和偶数减奇数之间来回变换，只要相等变差值为 $0$ 即可，谁减谁不重要。

转移系数有 $\binom{n-i}{A}$，表示从剩下 $n-i$ 个点中选择 $A$ 个点。还有系数 $f_{j,A,p-l}$ 表示在 节点个数为 $j$ 的上一层和节点个数为 $A$ 的本层之间填 $p-l$ 条边的方案数。这个需要预处理转移。

固定上一层的节点个数，假设有新节点 $x$ 添加至本层。那么 $x$ 可以向本层连边 $a$ 条，也可以向上一层连边 $b$ 条。则转移为 $f_{i,j-1,p-a-b}\to f_{i,j,p}$。转移系数为 $\binom{i}{b}\times \binom{j-1}{a}$。

代码：https://pastebin.com/UthruykF

---

## 作者：Milthm (赞：1)

个人难度：$32/50$。

这个做法是对于[这篇题解](https://www.luogu.com.cn/article/dawu2ne7)的详细介绍，目的是让大家更明白这种比较大的 dp 的思路。感谢这篇题解的作者。

这不太像人类能出出来的题：求满足与 $1$ 的最短路长度为奇数和偶数的点的数量相等的 $n$ 个点的图的个数。

然后我们发现：$n\le 30$。

这下可做了，但是注意到 $n$ 是 $30$ 而不是 $20$ 之类的，说明状压大概不可行。折半搜索什么的就别想了，显然做不了。

这下大概只有一种可能了，就是正解的时间复杂度可能是 $O(n^k)$，这题看上去 $k$ 是大概 $5,6$ 的一个数（只是看上去）。

这种计数题必须把状态设全，才能保证转移的过程中能转。首先这题一个很重要的性质是，这个满足条件的图大概是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/umdniei7.png)

我们发现图按照到一号点的最短路距离进行了分层，且有以下性质：

- $1$ 号点在第一层，且第一层只有 $1$ 号点。

- $i$（$i>1$）层的任意点必须和 $i-1$ 层中的至少一个点连边。

- 层内随意连边。

- 只有相邻的层有边相连。

- 奇数层和偶数层总点数相等（这图没体现这点，因为是我乱画的）。

然后我们看看 dp 需要什么：

- 现在是第几层。

- 这层有多少点。

- 一共有多少点，多少边。

- 奇数层有多少点、偶数层有多少点。

你可能会问为什么不需要知道这层有多少边，这个等会转移的时候我们就知道了。

现在开始设状态。注意到知道了“奇数层有多少点、偶数层有多少点”，也就知道了一共有多少点。而且“现在是第几层”其实不重要，只需要记录该层的奇偶性（当然只是减少了空间）。所以设 $f_{i,j,k,l,s}$ 表示当前深度奇偶性为 $i$，连了 $j$ 条边，奇数层有 $k$ 个，偶数层有 $l$ 个，当前层有 $s$ 个点的答案。

接下来是转移。我们发现 $i-1$ 层到 $i$ 层只需要知道加了多少个点（$x$）、多少条边（$y$）。所以我们得到了：

$$f_{1,j+y,k,l+x,x}=f_{1,j+y,k,l+x,x}+f_{0,j,k,l,x}C_{n-k-l}^xg_{s,x,y}$$

其中 $g_{s,x,y}$ 是一个要算很多次的贡献，即 $s$ 个点连出 $y$ 条边使得 $x$ 个点每个都至少与 $s$ 个点中的一个相连的方案数。这个东西在这里算显然不划算，所以可以预处理出来（等会再说怎么预处理）。这个组合数 $C_{n-k-l}^x$ 就是在剩余的点里取 $x$ 个，也不是很难理解。当然同理有：

$$f_{0,j+y,k,l+x,x}=f_{0,j+y,k,l+x,x}+f_{1,j,k,l,x}C_{n-k-l}^xg_{s,x,y}$$

这个时候我们就发现了，没有当前层的边数照样也能转移，所以根本不需要记录。

然后是 $g_{i,j,k}$，在 $j-1$ 个点到 $j$ 个点的过程中，我们可以枚举这个点连了多少条边，那么就得到了：

$$g_{i,j,k}=\sum_{l=1}^{\min(i+j-1,k)}(C_{i+j-1}^l-C_{j-1}^l)g_{i,j-1,k-l}$$

这个 $C_{i+j-1}^l-C_{j-1}^l$ 是怎么来的？其实是因为不算新来的点两层一共有 $i+j-1$ 个点，所以可以随便连 $l$ 个。但是必须和那 $i$ 个点有连边，所以减去全都连到 $j-1$ 个点的情况。

分析一下复杂度，瓶颈在 $f$ 的转移，是 $O(n \cdot n^2 \cdot n \cdot n \cdot n^3)=O(n^8)$ 的。但是我们发现我们自带极小的常数，再加上有一些状态是 $0$ 可以直接跳过转移，我们就可以通过这道题目了。

写的时候记得不要把数组开小。

---

## 作者：DengStar (赞：0)

[在我的博客中查看](https://www.cnblogs.com/dengstar/p/18704676)

非常好的题目。一开始做这道题的时候毫无头绪，看了题解之后才懂，感觉也并没有想象中那么难。从“不懂”到“懂了”之间的思维过程是需要仔细体会的。

处理无权图最短路问题的经典方式是**分层图**：按照节点到 $1$ 号点的距离分层，距离相同的点在同一层。为了方便表述，下文中成节点到 $1$ 号点的距离为“深度”。分层给图带来了一些性质：第 $i$ 层（$i \neq 0$）中的每个点都必须和 $(i - 1)$ 层中的至少一个点相邻，且不与 $(i - 1)$ 层之前的点相邻；同一层之间的点可以任意连边。我们的 dp 也基于分层图的思想。

首先想想怎么设计状态。我们的大致方向是设 $f(\dots)$ 表示符合某种条件的图的数量，然后想想状态中需要包含什么来刻画图的性质。容易想到状态需要包含点数和边数。由于我们要统计深度为奇数和深度为偶数的点数相同的图的数量，所以状态中还要包含深度为偶数的点数（一种等价的方法是记录深度为偶数和奇数的点数之差）。

到这里也还没有结束。不妨想想我们需要怎么转移，从中反推状态设计。可以想到一种比较好的转移方式是**每次加入新的一层点**。如果这样转移，就还需要在状态中记录最后一层（即深度最大层）的信息。这里我们要记录的是最后一层的点数，以及其深度的奇偶性。

综上所述，状态设计为：设 $f(i, j, k, l, t)$ 为满足以下条件的有标号无向简单图的数量：

- 有 $i$ 个点和 $j$ 条边
- 有 $k$ 个深度为偶数的点
- 最后一层有 $l$ 个点，其深度模 $2$ 同余 $t$。（$t \in \{0, 1\}$）

转移时，考虑一次加入新的一层点，以及与这一层点相邻的边。（你会发现其它方式都不方便或者无法转移）假设一次加入 $x$ 个点和 $y$ 条边，并且 $t = 0$，那么转移方程为：
$$
\boxed{f(i + x, j + y, k, x, 1) \gets f(i + x, j + y, k, x, 1) + f(i, j, k, l, 0) \times \dbinom{n - i}{x} \times g(l, x, y)}
$$
其中，$g(a, b, c)$ 表示有两层点（区分为“内层”和“外层”），内层有 $a$ 个点，外层有 $b$ 个点，内外层之间和外层内部共有 $c$ 条边时（注意，没有计算内层内部的边数），**合法**连边方式的数量。

这个转移方程不难理解：从剩下的 $(n - i)$ 个点中选 $x$ 个点作为新的一层，有 $\dbinom{n - i}{x}$ 种方式；新加入 $y$ 条边，有 $g(l, x, y)$ 种方式；加入 $x$ 个点和 $y$ 条边后，新图的点数和边数分别为 $i + x$ 和 $j + y$，由于新的一层的点数深度为奇数，所以深度为偶数的点数仍为 $k$，因此转移到 $f(i + x, j + y, k, x, 1)$ 这个状态。

对于 $t = 1$ 的情况，转移方程是类似的。

初始化和答案统计是容易的，详见代码。

然后想想怎么计算 $g(a, b, c)$。一开始我尝试找到某种封闭形式直接计算，但这似乎是不可行的，所以还是使用 dp（递推）。

考虑一次在外层加入 $1$ 个点以及 $i$ 条与其相连的边。我们需要满足加完之后连边方式是合法的，也就是说：至少有一条边连向内层节点。如果没有这个限制，就有 $\dbinom{a + b}{i}$ 种连边方式。但这个限制不太好满足，正难则反，考虑容斥：如果所有的边都没有连向内层节点，就说明它们都连向了外层节点，方案数为 $\dbinom{b}{i}$。减去这些方案，则合法的方案数为 $\dbinom{a + b}{i} - \dbinom{b}{i}$。那么 $g(a, b, c)$ 的转移方程为：
$$
g(a, b + 1, c + i) \gets g(a, b + 1, c + i) + g(a, b, c) \times \left( \dbinom{a + b}{i} - \dbinom{b}{i} \right)
$$
初始化 $g(a, 0, 0) = 1$。

预处理 $g(\cdot, \cdot, \cdot)$ 后就可以直接 dp 了。

**时间复杂度分析**：dp 状态数为 $O(n) \times O(n^2) \times O(n) \times O(n) \times O(1) = O(n^5)$，转移的时间复杂度为 $O(n) \times O(n^2) = O(n^3)$。预处理的时间复杂度不是瓶颈，因此总时间复杂度为 $O(n^8)$。

这个时间复杂度看似不能通过，但如果循环的上下界卡得比较紧，由于常数较小，是可以 AC 的。我写这道题时由于某个地方上界并未卡紧，TLE 了很久才通过。下面给出我 AC 时各个循环的上下界（伪代码）：

```cpp
for(i: 1 -> n - 1):
    for(j: i - 1 -> binom(i, 2)): // binom 表示组合数，下同。
        for(k: 0 -> i):
            for(l: 1 -> i):
                for(t: 0 -> 1):
                    if(f[i][j][k][l][t] = 0): // 特判 0
                        continue;
                    for(x: 1 -> n - i):
                        for(y: x -> binom(x, 2) + x * l): // 这个上界很重要！
                            // dp
```

其中 $y$ 的上界是 $\dbinom{x}{2} + x \cdot l$，原因是：新加入的边数最多时，新的一层中任意两个点都有边，数量为 $\dbinom{x}{2}$，除此之外新的一层中每个点与原先最后一层中的每个点两两连边，数量为 $x \cdot l$，总数为 $\dbinom{x}{2} + x \cdot l$。我写这道题时，由于这个上界没有卡紧（一开始写成了 $\dbinom{x + i}{2}$，现在看来完全就是错的），TLE 了非常多次，后来对着 [这篇题解](https://www.luogu.com.cn/article/webmd1xp) 改了很久才发现问题。（但我输出转移次数后发现，即使我和他的代码转移次数相同，我花费的时间仍然是他的 $4 \sim 5$ 倍，原因不明。）

[AC 记录](https://atcoder.jp/contests/abc389/submissions/62490140)

---


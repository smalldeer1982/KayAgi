# [AGC070A] Multiples in the String

## 题目描述

本题为 **仅需输出** 类型的问题，所以没有输入数据。

请找出一对正整数 $X$ 和字符串 $S$，满足以下所有条件：

- $X$ 是一个大于等于 $10^{50}$ 且小于 $10^{5000}$ 的正整数。
- $S$ 是一个由数字 `0` 到 `9` 组成的字符串，长度不超过 $5000$。
- 对所有满足 $1 \leq i \leq 1000$ 的整数 $i$，都必须满足以下条件：
  - 对 $X$ 乘以 $i$ 后得到的十进制表示的数字，一定是 $S$ 的某个连续子串。

## 说明/提示

### 示例说明 1

以下是一个不符合条件的输出示例。这组数据不满足题目要求的原因有：
- $X$ 并不在题目设定的取值范围内。
- 当 $i = 1, 2$ 时，`5` 和 `10` 是 $S$ 的子串。然而，当 $i = 3$ 时，`15` 并不是 $S$ 的子串。因此，$(X, S)$ 不满足题目中的第三个条件。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
None```

### 输出

```
5
105```

# 题解

## 作者：Argon_Cube (赞：9)

目前的题解一篇[乱搞](https://www.luogu.com.cn/article/ufbfmv3u)一篇[正解](https://www.luogu.com.cn/article/db7lywrw)还有一篇是[结论完全错误的东西（事实上对任意质数 $p$，$\frac 1p$ 都是纯循环小数）](https://www.luogu.com.cn/article/rhxyf4qs)。所以来补一个题解。

顺带一提这个题怎么是我四五个月前研究过的东西。

-----

首先如果考虑拼接等等方法看起来就不是很行，我们希望找到一个空间利用率尽可能高的方法。有一个很知名的“走马灯数”，即 $\frac{1}{7}$ 的循环节：$a=142857$，$ia(1\leq i<7)$ 事实上遍历了 $a$ 的每一种循环移位：

$$
\begin{cases}
2\times 142857=285714\\
3\times 142857=428571\\
4\times 142857=571428\\
5\times 142857=714285\\
6\times 142857=857142\\
\end{cases}
$$

那么只需要让 $S=\textsf{142857142857}$ 就包含了 $a$ 的六个倍数。

取分母 $p=17$ 或 $p=19$，将 $\frac 1p$ 的循环节 $a$ 取出，此时 $ia(1\leq i<p)$ 也同样遍历了 $a$ 的所有循环移位。$100$ 以内合法的数有 $7,17,19,23,29,47,59,61,97$。

那么如果我们找到一个合法的 $p>1000$，这道题就做完了：将 $\frac 1p$ 的循环节在第一行输出一次去掉前导零作为 $X$，在第二行输出两次作为 $S$ 就是一个符合要求的构造。

考虑怎么寻找合法的 $p$，条件显然就是 $\frac 1p$ 的每个小于 $1$ 的倍数都可以通过将 $\frac 1p$ 的小数部分循环移位得到。对于小数部分循环移位我们显然会考虑乘以 $10^k$ 然后模 $1$ 去掉整数部分。于是对于每个 $1\leq n<p$ 存在一个 $m\geq 0$ 使得

$$10^mp^{-1}\equiv np^{-1}\pmod 1\iff 10^m\equiv n\pmod p$$

于是我们只需要枚举质数 $p$，并检验 $10$ 是否是 $p$ 的原根即可（这等价于 $\frac 1p$ 的循环节长 $p-1$），暴力枚举发现 $p=1019$ 是最小的大于 $1000$ 的合法解。

最小的几个合法解是 $1019,1021,1033,1051,1063,1069,1087,1091,1097$。

~~事实上你可以在 $\Omicron(v\log v)$ 的时间里检验所有 $1\leq p\leq n$。但是显然这没有什么用处。~~

[Code.](https://atcoder.jp/contests/agc070/submissions/61317790)

---

## 作者：Sharpsmile (赞：7)

## 题面

请构造一个数字 $x$ 和一个长度不超过 $5000$ 的字符串 $S$。满足：

- $10^{50}\leq x<10^{5000}$ 

- 对所有正整数 $i\leq 1000$，满足 $ix$ 构成的数字串是 $S$ 的子串。

很神秘的题目（）我当时做了六十分钟才做出来，但是有人六分钟就过了（）应该是我比较笨的原因。



## 题解



来带大家看看我当时是怎么想的。

首先看到这个 $ix$ 全都是 $S$ 的子串，启发我们首先用到的数字集合肯定不会差太多。

先来思考比较小的情况。

然后这里有一个很著名的数字 $t=142857$，这东西是 $\frac{1}{7}$ 小数的循环部分。他的倍数们如下：

$142857,285714,428571,571428,714285,857142,999999$。

看上去很妙，除了最后一个数，都满足数字集合完全一致。

接下来怎么做呢？我们毕竟要构造的是一个长度很长的数字。只有 $6$ 的长度肯定不够。

这个时候我做出了很多尝试，比如啥用若干 $t$ 及其倍数把他们按照这个东西拼一遍。然后发现没啥用，还是不会。

但是我发现了一个被我忽略的性质，除去 $7t$，$1t\sim 6 t$ 全部都是 $t$ 的循环位移。且 $7t$ 是由 $6$ 个 $9$ 构成的。

好，如果我们能发现一个大于 $1000$ 的 $k$，满足 $k$ 个 $9$ 构成数是被 $k+1$ 整除，且得到的数字 $t$ 满足 $1t\sim kt$ 全都是 $t$ 的循环位移，那岂不是对完了？我们直接输出 $x=t,S=tt$ 即可（$tt$ 表示两个 $t$ 拼起来）。

但是直接求不太现实，这咋找。我们首先先小范围打一下表，首先在 $k\leq 18$ 中，满足整除限制的数都是 $3$ 的倍数。接着看看字符集合大概的样子，感觉上只有 $6$ 的倍数是合法的？

我们大胆猜测合法的 $k$ 的密度不会太小。我们只取 $6|k$ 且 $k\geq 1000$ 的 $k$ 来验证。

使用 `python3` 的高精度来跑这个东西。人肉输入一波，发现到 $k=1020$ 的时候，$k$ 个 $9$ 构成的数字 $p$ 可以被 $k+1$ 整除，令 $\frac{p}{k-1}=t$，看起来 $2t$ 和 $t$ 虽然比较起来杂乱无章，没啥共性，我们多次随机在 $t$ 中取几段数字串在 $2t$ 里 `Ctrl+F`  一下，发现都能找到。

然后你尝试写个程序验证一下是否满足上面的限制，发现直接跑并不满足。仔细思考你发现弄到后面位数都对不上。

发动人类智慧，我们用前导零把每个数都补充到 $1020$ 位。并感觉这东西很对，满足上面循环位移的限制。验证一下发现果真对了。

交上去过了。

顺带一提，$x$ 有前导零貌似不会有问题（）可能是没有判这个算不合法。

---

## 作者：ケロシ (赞：7)

首先考虑一个关于 $\frac{1}{7}$ 的经典例子:

$$
\begin{aligned}
\frac{1}{7}=0.142857142857\cdots \\
\frac{2}{7}=0.285714285714\cdots \\
\frac{3}{7}=0.428571428571\cdots \\
\frac{4}{7}=0.571428571428\cdots \\
\frac{5}{7}=0.714285714285\cdots \\
\frac{6}{7}=0.857142857142\cdots \\
\end{aligned}
$$

小数部分呈六位完全循环，是因为 $\frac{x}{7}=\frac{142857x}{999999}$。

那么为什么会出现轮换呢，现在可以转到小学竖式除法的角度，设被除数为 $x$，除数为 $p$，那么竖式除法的重复的过程：

1. $x \gets 10x$
2. 当前位的答案为 $\left \lfloor \frac{x}{p} \right \rfloor $
3. $x \gets x \bmod p$

不难发现 $x$ 每次都变换到一个固定的值。因为 $x$ 的取值只有 $\mathbb{F}_p$，所以 $x$ 的变换可以用一个置换表示，例如 $p=7$ 时的置换：

$$
\begin{pmatrix}
0~1~2~3~4~5~6 \\
0~3~6~2~5~1~4
\end{pmatrix}
$$

不同的 $\frac{x}{7}$ 都表示从置换的某一个数开始迭代，一直在一个置换环上循环，这就解释了为什么 $\frac{x}{7}$ 小数部分都是循环同构的。

接下来考虑如何将上文与本题结合在一起，不难将小数放到整数部分：

$$
\begin{aligned}
142857\times1&=142857\\
142857\times2&=285714\\
142857\times3&=428571\\
142857\times4&=571428\\
142857\times5&=714285\\
142857\times6&=857142\\
\end{aligned}
$$

接下来对于上面的例子，只需要把每个置换环重复两边即可包含所有的数：$142857142857$。

接下来分析满足的形式，对于 $p$ 有最小的 $r$ 满足 $10^r \equiv 1 (\bmod~ p)$，那么可以构造出 $X= \frac{10^r-1}{p}$，其中 $0<x<p$，例如上文就是 $p=7,r=6$。

为了满足本题的要求，需要 $i \le 1000$，所以只要选择满足 $p > 1000$ 且 $p$ 没有 $2$ 和 $5$ 因子，这样就能覆盖所有答案且小数部分是完全循环。

注意 $p$ 不是质数的时候同一个置换环要跑很多遍，字符串长度会比较长。

接下来将所有的置换环输出两遍即可，注意 $\frac{10^r-1}{p}$ 的长度需要符合题意。

满足题意的最小的质数 $p$ 是 $1009$，$S$ 长度为 $2012$。

```cpp
const int N = 2e3 + 5;
int p, r, a[N], b[N], c[N];
void solve() {
	p = 1009;
	int res = 1;
	FOR(i, 1, 1e8) {
		res = (res * 10) % p;
		if(res == 1) {
			r = i;
			break;
		}
	} 
	assert(r > 50 && r < 4500);
	FOR(i, 1, p - 1) {
		b[i] = (i * 10) / p;
		a[i] = (i * 10) % p;
	}
	int u = 1, ok = 0;
	REP(_, r) {
		if(b[u]) ok = 1;
		if(ok) cout << b[u];
		u = a[u];
	}
	cout << endl;
	FOR(i, 1, p - 1) if(! c[i]) {
		int u = i;
		REP(_, r * 2 - 1) {
			c[u] = 1;
			cout << b[u];
			u = a[u];
		}
	}
	cout << endl;
}
```

---

## 作者：JXR_Kalcium (赞：1)

## 题目大意

需要找出一对 $(X,S)$，满足

- $X$ 是 $[10^{50},10^{5000})$ 内的整数。
- $S$ 是一个数字串且 $|S|\le 5000$。
- 对于每一个 $i\in [1,1000]$ 都要满足 $X\times i$ 是 $S$ 的子串。

## 解题思路

本题考查了有关循环数的知识。

首先 $X\times i$ 都满足是 $S$ 的子串，而 $X$ 很大，$|S|$ 很小，所以需要用尽可能少的位数表示尽可能多的乘积，于是我们就想到了循环数。一个典型的循环数例子是 $142857$，例如

$$
142857\times 1=142857\\
142857\times 2=285714\\
142857\times 3=428571\\
142857\times 4=571428\\
142857\times 5=714285\\
142857\times 6=857142
$$

而 $142857\times 7=999999=10^6-1$，于是可设一个循环数 $x$ 及一个质数 $p$ 满足 $x\times p=10^{p-1}-1$，便可得

$$
x=\frac{10^{p-1}-1}{p}
$$

所以循环数就是费马商的形式。但并不是所有的质数 $p$ 都满足条件，容易看出循环节长度为 $p-1$，所以 $p$ 可以直接从 $1009$ 试起。当试到 $1019$ 的时候，通过记事本查找发现可行，于是 $X=\frac{10^{1018}-1}{1019}$，而 $S$ 就是两个 $X$ 连在一起，中间用 $000$ 分隔（因为会乘上 $1000$），这样这一题就做完了。对于 $X$ 的计算可以使用 Wolfram Alpha 求解，存在字符串里面就可以了。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

string s={"9813542688910696761530912659470068694798822374877330716388616290480863591756624141315014720314033366045142296368989205103042198233562315996074582924435721295387634936211972522080471050049067713444553483807654563297350343473994111874386653581943081452404317958783120706575073601570166830225711481844946025515210991167811579980372914622178606476938174681059862610402355250245338567222767419038272816486751717369970559371933267909715407262021589793915603532875368007850834151128557409224730127576054955839057899901864573110893032384690873405299313052011776251226692836113837095191364082433758586849852796859666339548577036310107948969578017664376840039254170755642787046123650637880274779195289499509322865554465161923454367026496565260058881256133464180569185475956820412168792934249263984298331697742885181550539744847890088321884200196270853778213935230618253189401373895976447497546614327772325809617271835132482826300294406280667320902845927379784102060843964671246319921491658488714425907752698724239450441609421"};

int main()
{
	cout << s; endl; cout << s+"000"+s;
    return 0;
}
```

---

## 作者：Eric998 (赞：0)

注意到对于非 $2,5$ 的质数 $p$，$\frac 1p$ 都是纯循环小数。手模一下发现具有类似于 $142857$ 的性质。

取 $p=1019$，$X$ 为 $\frac{1}{1019}$ 的最短循环节，$S$ 为 $X$ 复制 $2$ 遍即可。

---


# [AGC007C] Pushing Balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc007/tasks/agc007_c

$ N $ 個の球と $ N+1 $ 個の穴が一直線上に並んでいます。球には左から順に $ 1 $ から $ N $ の番号が、穴には左から順に $ 1 $ から $ N+1 $ の番号が振られています。$ i $ 番の球は $ i $ 番の穴と $ i+1 $ 番の穴の間に置かれており、隣り合う穴と球の間の距離を左から順に並べて得られる数列を $ d_i $ ($ 1\ \leq\ i\ \leq\ 2\ \times\ N $) とおきます。$ d_1 $ の値とパラメータ $ x $ が与えられており、$ d_i\ -\ d_{i-1}\ =\ x $ が任意の $ i $ ($ 2\ \leq\ i\ \leq\ 2\ \times\ N $) に対して成り立っています。

これら $ N $ 個の球を $ 1 $ 個ずつ転がし、穴に落としていくことを考えます。球が穴の上を通ると、その穴にすでに別の球が入っていなければその穴に落ちます。すでに別の球がその穴に入っていた場合は、球は落ちずにそのまま転がり続けます。（なお、この問題で考える球の転がし方において、球どうしが衝突することはありません。）

球を転がす際は、まだ転がされていない球の中から等確率で $ 1 $ つを選び、その球を左または右に等確率で転がします。これを $ N $ 回繰り返してすべての球を転がすとき、すべての球が移動する距離の総和の期待値を求めてください。

以下に $ N\ =\ 3 $, $ d_1\ =\ 1 $, $ x\ =\ 1 $ の場合の球の転がし方の例を挙げます。

 ![c9264131788434ac062635a675a785e3.jpg](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc007_c/60a5d5d029df9794870209eb9c921ace7bb48177.png)

1. $ 2 $ 番の球を左に転がす。球は $ 2 $ 番の穴に落ちる。球が移動する距離は $ 3 $ である。
2. $ 1 $ 番の球を右に転がす。球は $ 2 $ 番の穴の上を通り、$ 3 $ 番の穴に落ちる。球が移動する距離は $ 9 $ である。
3. $ 3 $ 番の球を右に転がす。球は $ 4 $ 番の穴に落ちる。球が移動する距離は $ 6 $ である。

この例では、球が移動する距離の総和は $ 18 $ となります。

なお、球をどのように転がしてもどの球も必ずいずれかの穴に落ち、最後に穴が一つだけ空のまま残ることになります。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 200,000 $
- $ 1\ \leq\ d_1\ \leq\ 100 $
- $ 0\ \leq\ x\ \leq\ 100 $
- 入力値はすべて整数である。

### Sample Explanation 1

球が $ 1 $ 個、穴が $ 2 $ 個あります。球から左の穴までの距離は $ 3 $ 、球から右の穴までの距離は $ 6 $ です。球を左に転がすか右に転がすかの $ 2 $ 通りの転がし方があり、それぞれにおいて球が移動する距離は $ 3,\ 6 $ です。したがって、答えは $ (3+6)/2\ =\ 4.5 $ となります。

## 样例 #1

### 输入

```
1 3 3```

### 输出

```
4.500000000000000```

## 样例 #2

### 输入

```
2 1 0```

### 输出

```
2.500000000000000```

## 样例 #3

### 输入

```
1000 100 100```

### 输出

```
649620280.957660079002380```

# 题解

## 作者：litble (赞：23)

[戳我＝￣ω￣＝](https://blog.csdn.net/litble/article/details/83089429)

我们来到操场的沙坑上，赶走在练习跳远的人，然后挖四个坑，然后找体育组借三个实心球放在四个坑直接，那么这些物品两两的初始距离是：

$d$，$d+x$，$d+2x$，$d+3x$，$d+4x$，$d+5x$

考虑一下不同的推球方法，当一个球进入一个坑后，就默不作声地用沙子将这个球埋起来，假装什么都没有发生过，将这些球重新编号。你会发现物品两两间距离有这么几种可能（表格头的编号是重编过的）：

|情况|坑1与球1|球1与坑2|坑2与球2|球2与坑3|
|---|---|---|---|---|
|球1入坑1|$d+2x$ | $d+3x$ | $d+4x$ | $d+5x$ |
|球1入坑2|$3d+3x$ | $d+3x$ | $d+4x$ | $d+5x$ |
|球2入坑2|$d$ | $3d+6x$ | $d+4x$ | $d+5x$ |
|球2入坑3|$d$ | $d+x$ | $3d+9x$ | $d+5x$ |
|球3入坑3|$d$|$d+x$|$d+2x$|$3d+12x$|
|球3入坑4|$d$|$d+x$|$d+2x$|$d+3x$|
|期望|$\frac{8d+5x}{6}$ |$\frac{8d+15x}{6}$|$\frac{8d+25x}{6}$|$\frac{8d+35x}{6}$|

哇，好神奇啊，期望的物品间距离居然还是个等差数列～

你会对这个发现感到异常惊奇，但还是不要忘了把实心球挖出来还回去。

现在来观察，等差数列的第一项就是我们表格的**坑1与球1**这一列，你会发现不管初始用几个球，这一列只有前两行是$d+2x$和$3d+3x$，其他行都是$d$。所以$d'=d+\frac{2d+5x}{2n}$。至于公差，我们观察一下**球2与坑2**这一列，发现这一列的期望永远会是$d+x+\frac{2d+9x}{2n}$，所以公差$x'=x+\frac{4x}{2n}$。

这样我们做$n$次对$d$和$x$（其实还有$n$别忘了）的变换，即可得到答案。

oh，对，至于每种局面下的推球期望距离，应该是$d+\frac{2n-1}{2x}$，具体为什么自己推(zhǎo)一(guī)推(lǜ)吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
typedef double db;
int n;db d,x,ans;
int main()
{
	scanf("%d%lf%lf",&n,&d,&x);
	db nn=n+n;
	for(RI i=n;i>=1;--i) {
		ans+=d+(nn-1)/2*x;
		db dd=d+(2*d+5*x)/nn;
		db xx=x+4*x/nn;
		x=xx,d=dd,nn-=2;
	}
	printf("%.10lf\n",ans);
	return 0;
}
```

---

## 作者：zhylj (赞：14)

类似等差数列求和的办法，考虑把整个直线倒过来，显然不改变答案，然后把每个线段的贡献依次加起来，不难发现每条线段都对此时的答案贡献了期望经过次数的 $2d_1+(2n-1)x$ 倍，于是我们算出 $d_1=1$，$x=0$ 时的答案，然后再乘上 $\dfrac{2d_1+(2n-1)x}2$ 就可以得到答案了。

然后考虑第一次推球之后，有 $\dfrac 1n$ 的概率会减少一段开头或结尾的线段，有 $\dfrac {n-1}n$ 的概率会等概率选取两条线段合并，只有当后者选中的线段恰好为第 $i$ 条线段时才会对第 $i$ 条线段产生影响，于是可以列出式子，新的第 $i$ 条线段长度的期望值为：
$$
d_1'=d_1+\frac {n-1}{n}\cdot \frac 1{n-1}\cdot 2d_1 = \frac {n+1}n\cdot d_1
$$
由于 $\dfrac{n+1}n$ 是确定的常数，所以若记 $e_i$ 表示第 $i$ 次推球后每条线段长度的期望，我们也可以得到：
$$
e_i = \dfrac {n-i}{n-i+1}\cdot e_{i-1},\ e_0 = d_1=1\implies e_i = \dfrac {n+1}{n-i+1}
$$
而第 $i$ 次推球移动的期望距离显然为 $e_{i-1}$，于是就有答案为：
$$
\dfrac{2d_1+(2n-1)x}2\sum_{i=2}^{n+1}\dfrac {n+1}{i}
$$
暴力计算即可，时间复杂度 $\mathcal O(n)$。

```cpp
typedef double ff;

int n, x, d;

int main() {
	scanf("%d%d%d", &n, &d, &x);
	ff ans = 0;
	for(int i = 1; i <= n; ++i) 
		ans += (ff)1 / (i + 1);
	ans *= (ff)(2 * d + (2 * n - 1) * x) / 2 * (n + 1);
	printf("%.12lf\n", ans);
	return 0;
}
```

---

## 作者：strapplE (赞：8)

给个无脑做法。题解做法固然妙，但不是我这种人能够想到的。

第一步一样，左右对称，于是可以把答案直接乘上一个 $d+x(n-\frac{1}{2})$。这就转化成了一个这样的问题：一个数轴，有 $n+1$ 个洞分别在 $0,2,4,\dots,2n$ 位置；有 $n$ 个球分别在 $1,3,5,\dots,2n-1$ 位置。每次删掉相邻两个东西，加上它们的坐标差，并删掉，求价值的期望。

显然区间要么不交要么包含。把它理解成一个括号序列，于是可以理解为：你可以选择一个偶数位（表示最终没被到达的洞），分成左边 $2k$ 个位置和右边 $2(n-k)$ 个位置，每个连续段都要放置合法括号序列，答案是每个右括号的坐标之和减掉左括号的坐标之和，乘上得到这个括号序列方案数的期望。

考虑得到一个长度为 $2k$ 的合法括号序列的方案数/概率：注意到每一对匹配的括号之间可以建树，祖孙关系就是直接包含关系。因此刚好得到这个括号序列的概率就是：$\dfrac{1}{\prod\limits_{(i,j)\in M}\frac{j-i+1}{2}}$，获得的价值是 $\sum\limits_{(i,j)\in M}(j-i)$，其中 $M$ 是括号序列所有的匹配对构成的集合。

由于总方案数是 $n!\times 2^n$，拆成左边 $2k$ 和右边 $2(n-k)$ 的时候会有一个 $\binom{n}{k}$ 的系数，所以实质上对于例如左边只要比掉一个 $k!2^k$。设 $c_i=\dfrac{1}{i!2^i}\sum\limits_{M}\frac{i!}{\prod\limits_{(i,j)\in M}\frac{j-i+1}{2}},f_i=\dfrac{1}{i!2^i}\sum\limits_{M}\frac{i!\sum\limits_{(i,j)\in M}(j-i)}{\prod\limits_{(i,j)\in M}\frac{j-i+1}{2}}$，则答案为 $\sum\limits_{k=1}^{n+1}(f_{k-1}c_{n+1-k}+f_{n+1-k}c_{k-1})$。因而我们转化成了求 $c_i$ 和 $f_i$ 的一个问题。

求 $c_i$ 是容易的。因为总操作方案数是 $(2i-1)!!$，所以比掉 $i!2^i$ 之后就是 $\dfrac{(2i-1)!!}{(2i)!!}$。

求 $f_i$。考虑最左边的左括号的匹配位置。这样整个括号序列就被分成两部分。因此有 $f_i=\sum\limits_{j=1}^{i}\dfrac{1}{2j}(c_{j-1}f_{i-j}+c_{i-j}f_{j-1}+(2j-1)c_{j-1}c_{i-j}),c_i=\sum\limits_{j=1}^{i}\dfrac{1}{2j}c_{j-1}c_{i-j}$。直接分治 FFT 可以做到 $O(n\log^2n) $ 的复杂度。

注意到 $\forall i,\sum\limits_{j=1}^{i}c_{j-1}c_{i-j}=1$，还可以合并同类项。因此 $f_i=\dfrac{1}{2}(\sum\limits_{j=1}^{i}c_{j-1}f_{i-j}(\dfrac{1}{j}+\dfrac{1}{i-j+1})+1)-c_{i}$。

$\therefore f_i=\dfrac{i+1}{2}\sum\limits_{j=1}^{i}\dfrac{c_{j-1}}{j}\cdot\dfrac{f_{i-j}}{i-j+1}+(\dfrac{1}{2}-c_i)$

设 $cc_{i}=\dfrac{c_i}{i+1},ff_{i}=\dfrac{f_i}{i+1}$，则 $ff_{i}=\dfrac{1}{2}\sum\limits_{j=1}^{i}cc_{j-1}ff_{i-j}+(\dfrac{1}{2}-c_i)$

这是多项式求逆的形式，可以做到 $O(n\log n)$。

简便一些的做法：考虑 GF。注意到 $cc$ 的 OGF 是一个 Catalan 数的形式，$c$ 也差不太多，所以这些东西都是能求的。

经过简单计算可以得出：$\sum\limits_{i}ff_ix^i=\dfrac{\ln(1-x)+2-2\sqrt{1-x}}{-x\sqrt{1-x}}$。由于牛顿二项式定理 $(1-x)^{-1/2}=\sum\limits_{k}c_kx^k$，所以以上的东西只需要一遍 FFT 即可。

时间复杂度 $O(n\log n)$，不知道能不能不依赖其他的，进一步优化这个东西/kel

upd:

经过大神的指点，我发现这个东西可以做到线性，如下：

只需求出 $F=\dfrac{-\ln(1-x)}{\sqrt{1-x}}$ 的前 $n+1$ 项。

注意到将 $F$ 求导稍微计算得出：$(1-x)F'=(1-x)^{-1/2}+\dfrac{F}{2}$

因此有 $(i+1)[x^{i+1}]F=c_i+(i+\dfrac{1}{2})[x^i]F$，可以递推求出。

于是我们这个东西得到了一个 $\Theta(n)$ 的做法，它和题解做法居然有这么多相似之处！印证了"不谋而合，殊途同归"这句话。顺便放个代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double c[200005],cc[200005],ff[200005],he=0;
int main(){
	int n,d,x;
	scanf("%d%d%d",&n,&d,&x);
	c[0]=cc[0]=ff[1]=1;
	for(int i=1;i<=n+1;++i)c[i]=c[i-1]*(2*i-1)/(2*i);
	for(int i=1;i<=n;++i)cc[i]=cc[i-1]*(2*i-1)/(2*i+2);
	for(int i=2;i<=n+1;++i)ff[i]=c[i-1]/i+ff[i-1]/(2*i)*(2*i-1);
	for(int i=1;i<=n+1;++i){
		double tt=(ff[i]-2*c[i])*cc[n+1-i]+(ff[n+2-i]-2*c[n+2-i])*cc[i-1];
		he+=tt*i*(n+2-i);
	}
	printf("%.10f\n",he*(d+x*(n-0.5)));
	return 0;
}
```

---

## 作者：ETHANK (赞：4)

神仙题。

每次滚完少一个球一个坑，留下的会是 $n-1$ 个球 $n$ 个坑的情况，不妨考虑新序列的期望长度和原序列的关系。我们枚举第一个球的所有可能性，计算新的距离序列的期望值。观察发现仍然是一个等差数列！很多题解都提到了这一点，这里提供一种证明方法：

一共有 $2n$ 种滚球的可能，考虑对第 $i$ 段距离，有哪些情况能对其期望长度的增加产生贡献：

- 原来的前 $i$ 段距离被滚过（也就是第 $i$ 段距离之前的球滚完了），使原第 $i+2$ 段距离代替了第 $i$ 段。
- 原来的第 $i+1$ 段距离被滚过，使原第 $i,i+2,i+3$ 段代替了第 $i$ 段。

设新的距离序列为 $d'_i$ ，那么有：
$$
d'_i=d_i+\frac{i\times(d_{i+2}-d_i)+(d_{i+2}+d_{i+3})}{2n}=d_i+\frac{i\times 2x+2d+5x}{2n}
$$
这构成一个新的等差数列，而对每个 $d,x$ 我们推一次球的期望距离为数列的中位数，递推到最后即可。

时间复杂度：$O(n)$

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;
int main(){
    int n;double d,x,ans=0;
    scanf("%d%lf%lf",&n,&d,&x);
    while(n){
        ans+=d+x*(2*n-1)/2;
        double dd=d+(2*d+5*x)/(2*n),xx=x+2*x/n;
        d=dd,x=xx;n--;
    }
    printf("%.10lf\n",ans);
    return 0;
}
```

### 

---

## 作者：APJifengc (赞：3)

首先我们可以考虑将原问题转化成更简单的问题。类似于等差数列的求和法，我们可以将同样的问题反过来进行计算一遍，并且将这两次计算加和，这两个问题的答案显然是相等的。而根据期望的线性性，我们可以考虑每段距离的贡献，那么可以发现将两个问题中每段距离对应加和后得到的新问题的答案是相等的，而后者变成了每个位置距离均相等的更简单的问题。那么我们就只需要考虑每段距离都相等的情况（即 $d=1,x=0$ 的情况）即可，最后将答案乘上 $\frac{2d + (2n - 1) x}{2}$ 即可。

那么接下来考虑每段距离都相等怎么做。我们转化一下问题，将球与洞都看作元素排列成一个长度 $2n+1$ 的序列，考虑其中的 $2n$ 段距离。发现，每段距离正好对应着一种让球滚入洞中的方案。而若选择的这一段是中间的某一段，操作之后会使得相邻的三段合并成一整段；若选择的边缘的两段，则会使边缘的两个元素直接删除。

那么我们的问题可以重新描述成这样：有 $2n$ 个数，每次随机选择一个数，若这个数在边缘，那么删除最边缘上两个数；否则将这个数相邻的三个数加和合并。问进行 $n$ 次操作后，选择的数的总和的期望值。

我们可以发现这样一件事情：若进行合并操作，那么每个数被合并的概率都是相同的，即合并后新的数可能出现在 $2n-2$ 个位置中的任意一个。那么这意味着，这 $2n-2$ 段的期望长度也都是相同的。那么我们设 $d_i$ 表示在进行 $i$ 次操作后，每一段的期望长度是多少。那么有：

$$
d_0 = 1, d_i = \frac{(2n'-1) d_{i - 1} + 3d_{i - 1}}{2n'} = \frac{n'+1}{n'} d_{i - 1}
$$

$n'$ 代表推之前还剩下多少个球，即 $n - i + 1$。

每一次推球期望距离显然就是 $d_i$，那么答案就等于 $\frac{2d + (2n - 1) x}{2} \sum_{i = 0}^{n - 1} d_i$。可以直接递推计算，同时也可以推出 $d_i$ 的通项公式再计算，易得 $d_i = \frac{n + 1}{n + 1 - i}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, d, x;
int main() {
    scanf("%d%d%d", &n, &d, &x);
    double k = (2 * d + (2 * n - 1) * x) / 2.0;
    double a = 0;
    for (int i = 0; i <= n - 1; i++) a += 1.0 * (n + 1) / (n + 1 - i);
    printf("%.12lf\n", k * a);
    return 0;
}
```

---

## 作者：kczno1 (赞：2)

第一次见到这么难的$C$题。  
首先转化问题为，有$2 \times n+1$个点，$n$次操作，每次选两个相邻的点，贡献为距离，求贡献的和的期望。  
然后可以发现，期望距离的序列作为等差数列操作完了还是等差数列。  
记$d_{i}$($i=1..2 \times n$)为当前的距离序列，$x$为当前公差;  
$d'_{i}$($i=1..2 \times (n-1) $)，$x'$为操作后的。  
分类讨论可推得$d'_{i}=((2 \times n +2 )d_{i}+(2 \times i+3)x)/(2 \times n )$，  
然后可以推得$x'$=$(2 \times n+4)x/(2 \times n)$。  
然后就简单了。  
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	freopen("1.in","r",stdin);
	int n;double d,x;
	cin>>n>>d>>x;
	double ans=0;
	for(;n;--n)
	{
		ans+=d+(n-0.5)*x;
		d=((2*n+2)*d+5*x)/(2*n);
		x=(2*n+4)*x/(2*n);
	}
	printf("%.9f\n",ans);
}
```

---

## 作者：LYY_yyyy (赞：1)

听课的时候学到的做法，很深刻。

考虑将每一段拆开考虑贡献。由于操作很对称，reverse 一下不影响答案。这就意味着，对称的两段期望次数相等。于是我们可以将对称的两段长度取平均。由于原序列为等差数列，所以取完平均每段期望长度相等了，这是很好的。我们考虑做完一次操作之后长度会发生什么变化。每次操作会扣掉两个点，于是就少了两段。如果扣掉的是开头或者结尾的两个点，那么每段长度不变；否则被扣掉的两个点左右的点组成的段长度 $\times 3$。我们惊讶地发现每个段长度不变和 $\times 3$ 的情况数是相等的，这就意味着操作后每段长度期望仍然相等。根据上面的分析，设现在有 $2\times n$ 段，总情况数为 $2\times n$，长度和为 $2\times n+2$ 乘上原长，所以每段期望长度变为原本的 $\frac{n+1}{n}$。模拟这个过程即可，时间复杂度线性。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d1,x;
long double d,ans;
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>d1>>x;
	d=d1*1.00+(double)x*(2*n-1)/2.00;
	for(int i=1;i<=n;i++)
	{
		ans+=d;
		d=d*1.00*(n-i+2)/(n-i+1);
	}cout<<fixed<<setprecision(10)<<ans;
	return 0;
}
```

---


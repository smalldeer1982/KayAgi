# Keep Distances

## 题目描述

[problemUrl]: https://atcoder.jp/contests/acl1/tasks/acl1_d

数直線上に $ N $ 個の点があり，そのうち $ i $ 番目の点は座標 $ X_i $ にあります． これらの点は座標の昇順に番号がついています． つまり，すべての $ i $ ($ 1\ \leq\ i\ \leq\ N-1 $) について，$ X_i\ <\ X_{i+1} $ が成り立ちます. また，整数 $ K $ が与えられます．

$ Q $ 個のクエリを処理してください．

$ i $ 番目のクエリでは，整数 $ L_i,R_i $ が与えられます． ここで，点の集合 $ s $ が**よい**集合であるとは，以下の条件をすべて満たすことを意味します． よい集合の定義がクエリごとに変わることに注意してください．

- $ s $ に含まれる点は，$ X_{L_i},X_{L_i+1},\ldots,X_{R_i} $ のいずれかである．
- $ s $ に含まれるどの異なる $ 2 $ 点についても，その間の距離が $ K $ 以上である．
- $ s $ のサイズは，上記の条件を満たす集合の中で最大である．

各クエリごとに，すべてのよい集合の和集合のサイズを求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 0\ \leq\ X_1\ <\ X_2\ <\ \cdots\ <\ X_N\ \leq\ 10^9 $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ L_i\ \leq\ R_i\ \leq\ N $
- 入力は全て整数である．

### Sample Explanation 1

$ 1 $ つめのクエリでは，最大 $ 3 $ つの点を集合に含めることができます． よい集合は，$ \{1,4,7\} $ と $ \{1,4,8\} $ の $ 2 $ つです． よって，すべてのよい集合の和集合のサイズは $ |\{1,4,7,8\}|=4 $ です． $ 2 $ つめのクエリでは，最大 $ 1 $ つの点を集合に含めることができます． よい集合は，$ \{1\} $ と $ \{2\} $ の $ 2 $ つです． よって，すべてのよい集合の和集合のサイズは $ |\{1,2\}|=2 $ です．

## 样例 #1

### 输入

```
5 3
1 2 4 7 8
2
1 5
1 2```

### 输出

```
4
2```

## 样例 #2

### 输入

```
15 220492538
4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194
5
6 14
1 8
1 13
7 12
4 12```

### 输出

```
4
6
11
2
3```

# 题解

## 作者：良心WA题人 (赞：4)

## 前言

VP 出现之前模拟赛考过的原题了。感觉很炫酷，可惜不是赛时，要不然爽翻。不过模拟赛大概是搬的这题，赛时也碰不到原题倒是了。

## 题意

每次可以从一个点到达一个和这个点距离超过 $k$ 的点，每次给出 $l$ 和 $r$，要求你找出在区间 $[l,r]$ 内所有最长路经过的点的并集的数量。

## 思路

先考虑最长路怎么求。可以贪心地去求一个当前点能跳到的最近的点，一直跳下去，不难证明一定是最长路。那么我们考虑从左往右贪心地跳的结果以及从右往左贪心地跳的结果。


![](https://cdn.luogu.com.cn/upload/image_hosting/3c1ynbic.png)

首先，红色的部分一定是最长路能经过的，证明显然。现在考虑黑色的部分一定不会被最长路经过。

不妨考虑假设法，若黑色的部分能被最长路经过，则设最长路中间有一段黑色，那么一定会跳过最左和最右的两部分红色，且中间不可能经过别的红点，除非跳过一段黑色。那么无论如何，从黑色部分切换到红色部分一定是不优于原方案的。所以，计算红色部分的长度即可。

红色长度的计算是很 easy 的。直接倍增，存储一个下标和，用从右往左跳的减去从左往右跳的。注意红色部分是闭区间，但是我们直接减算的是左开右闭，所以要加上区间个数个点。时间复杂度 $O((n+q)\log_2n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int NN=2e5+4;
ll s[2][NN][24];
int to[2][NN][24],a[NN];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		s[0][i][0]=s[1][i][0]=i;
	}
	for(int i=1;i<=n;i++)
	{
		to[0][i][0]=lower_bound(a+1,a+1+n,a[i]+k)-a;
		to[1][i][0]=upper_bound(a+1,a+1+n,a[i]-k)-a-1;
	}
	to[0][n+1][0]=n+1;
	for(int i=0;i<=1;i++)
		for(int k=1;k<=20;k++)
			for(int j=0;j<=n+1;j++)
			{
				to[i][j][k]=to[i][to[i][j][k-1]][k-1];
				s[i][j][k]=s[i][j][k-1]+s[i][to[i][j][k-1]][k-1];
			}
	int q;
	scanf("%d",&q);
	while(q--)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		int u=l;
		ll res=0;
		for(int i=20;~i;i--)
			if(to[0][u][i]<=r)
			{
				res-=s[0][u][i]-(1<<i);
				u=to[0][u][i];
			}
		res-=u-1;
		u=r;
		for(int i=20;~i;i--)
			if(to[1][u][i]>=l)
			{
				res+=s[1][u][i];
				u=to[1][u][i];
			}
		printf("%lld\n",res+u);
	}
	return 0;
}
```

---

## 作者：small_john (赞：3)

## 思路

首先思考如何达到最大的长度。我们可以把问题具象为在一个数轴上跳，显然，每个点往右边第一个的和他距离大于等于 $k$ 的点是最优的。

考虑在这一条路径（设这条路径为路径一，长度为 $len$）上扩展出所有合法的点。

我们从右端点往左跳，每次跳左边最后一个合法的点（设这条路径为路径二）。

设路径一上的第 $i$ **小**的点在**所有点中编号**为 $p_i$，路径二上的第 $i$ **小**的点在**所有点中编号**为 $q_i$，容易用反证法证明，$p_i\le q_i\le p_{i+1}$（也就是两条路径互相交叉），如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/q8r6dgc0.png)

其中，黑色为第一条路径，蓝色为第二条路径。

不难发现，红色的段内的点是合法的，因为这段的长度是小于 $k$ 的，并且这些点在路径上时一定能往右边跳到第一条路径和第二条路径上，往左边同理。而其他的点一定不可以。

也就是说，答案为 $\sum\limits_{i=1}^{len}(q_i-p_i+1)=\sum\limits_{i=1}^{len}q_i-\sum\limits_{i=1}^{len}(p_i-1)$。

现在这道题就很简单了，倍增维护每个点的前驱后继，求路径和即可。

时间复杂度 $O((n+q)\log n)$，轻松通过。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5+5;
int n,k,a[N],fl[N][18],sl[N][18],sr[N][18],fr[N][18];
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i = 1;i<=n;i++)
		cin>>a[i];
	int p = 1;
	for(int i = 1;i<=n;i++)
	{
		while(a[p]<=a[i]-k) p++;
		fl[i][0] = p-1,sl[i][0] = p-1;
//		cout<<"fl"<<i<<' '<<p-1<<'\n';
	}
	p = n;
	for(int i = n;i;i--)
	{
		while(a[p]>=a[i]+k) p--;
		fr[i][0] = p+1,sr[i][0] = p;
//		cout<<"fr"<<i<<' '<<p+1<<'\n'; 
	}
	for(int j = 1;j<18;j++)
		for(int i = 1;i<=n;i++)
			fl[i][j] = fl[fl[i][j-1]][j-1],sl[i][j] = sl[i][j-1]+sl[fl[i][j-1]][j-1],
			fr[i][j] = fr[fr[i][j-1]][j-1],sr[i][j] = sr[i][j-1]+sr[fr[i][j-1]][j-1]; 
	int q;
	cin>>q;
	while(q--)
	{
		int l,r;
		cin>>l>>r;
		int suml = l-1,sumr = r;
		p = l;
		for(int i = 17;~i;i--)
			if(fr[p][i]<=r&&fr[p][i]) suml+=sr[p][i],p = fr[p][i]; 
		p = r;
		for(int i = 17;~i;i--)
			if(fl[p][i]>=l) sumr+=sl[p][i],p = fl[p][i];
		cout<<sumr-suml<<'\n';
	}
	return 0;
}
```

---


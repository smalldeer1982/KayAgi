# [AGC050A] AtCoder Jumper

## 题目描述

你有注意过 AtCoder 的这个部分吗？

![](https://img.atcoder.jp/agc050/2a140890f3297cce737744ff4d2f296d.png)

这里的序号，是在考虑了提高任意两个页面间跳转的速度和每个页面不显示太多的选项这两个因素，并精心考虑之后选出来的。在这个问题，你需要在每个页面只有 **两个链接** 的前提下实现类似的功能。

Snuke 制作了一个有 $N$ 个页面的网站，分别标号为 $1$ 到 $N$ 。对每个 $i(1\le i \le N)$ ，选出两个正整数 $a_i$ 和 $b_i(1\le a_i \le N)$ ，把通往第 $a_i$ 个页面和通往第 $b_i$ 个页面的链接加入页面 $i$ 。这个网站必须满足以下的要求：

- 你必须能够在最多点击 $10$ 个链接后从任意的一个页面跳转到任意的另一个页面。

在这个问题的限制条件下，我们可以证明这是一定可行的。

## 说明/提示

- $1 \le N \le 1000$

#### 样例解释 1

Snuke 做了一个只有一个页面的网站。这个页面的两个链接都指向它自己。

#### 样例解释 2

这样设置链接的话，不管哪个页面都有直接指向其他所有页面的链接。

## 样例 #1

### 输入

```
1```

### 输出

```
1 1```

## 样例 #2

### 输入

```
3```

### 输出

```
2 3
1 3
1 2```

# 题解

## 作者：sqrtDataStructure (赞：60)

考虑连边 $x\to 2x,x\to 2x+1$。

走 $10$ 条边后 $x$ 能到达所有 $1024x+y,y\in[0,1024)$。

在连边时对 $N$ 取模再加一，由于 $(1024x+y) \bmod N + 1$ 包含 $[1, N]$ 中的所有数，因此该构造成立。

---

## 作者：cff_0102 (赞：6)

更加详细的题解，如果没看懂其它题解的话可以看这篇。

每一个页面只能连出去两条向其它页面的边，不考虑页面范围的限制，至多走 $10$ 次最多可以达到 $2^0+2^1+\dots+2^{10}=2^{11}-1$ 个不同的点，走恰好 $10$ 次最多可以到达 $2^{10}=1024$ 个不同的点。注意到 $1024>1000$（$n$ 的范围），考虑从这里入手。

还是不考虑页面范围的限制，画出走 $10$ 次的所有可能的图，发现这是一个完全二叉树。给这个完全二叉树的每个节点层序编号，则非叶节点 $x$ 指向的两条边是 $2x$ 和 $2x+1$。这样，从根节点 $1$ 出发走 $10$ 次可以到达的所有点就是这棵树的所有叶子节点，编号从 $1024$ 到 $2047$。

注意到这段编号是连续的，且长度为 $2^{10}=1024$，所以从其中截取一个长度为 $n$ 的段，这一段中的所有数都可以被 $1$ 经过 $10$ 步访问到。如果我们把这棵树中所有的点取模 $n$，或者说让所有 $x$ 连向 $2x\bmod n$ 和 $(2x+1)\bmod n$（如果为 $0$ 则改为 $n$），那么一定可以从 $1$ 出发到达  $n$ 以内的所有的点。

那么如何证明 $n$ 以内其它点出发的情况也可以在 $10$ 步以内到达所有点呢？不考虑页面范围的限制，按同样的方法生成一个 $x$ 为根的完全二叉树。考虑它走 $10$ 步到的所有点，实际上它们也是相邻的 $1024$ 个数（因为每次走一步就相当于在 $x$ 的二进制后面加一位 $0$ 或 $1$，走十步之后就会得到除了后十位以外前面相同的 $2^{10}$ 个数）。那么用同样的方法取模之后，也一定可以经过 $10$ 步到达所有点。

因此，对于第 $i$ 个点，只需要向 $2x\bmod n$ 和 $(2x+1)\bmod n$ 连边就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int f(int x){
	x%=n;
	return x==0?n:x;
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cout<<f(i<<1)<<" "<<f((i<<1)|1)<<"\n";
	}
	return 0;
}
```

---

## 作者：Yxy7952 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/AT_agc050_a)

先说明，**一切描述都有可能不准确**，有错误请指出。

## 思路

因为：

>你必须能够在最多点击 $10$ 个链接后从任意的一个页面跳转到任意的另一个页面。

且：

>每个页面只有有且仅有两个链接。

又结合加法原理和乘法原理，可以知道从一个页面出发点击 $10$ 次链接，**最多**可以到达 $2^1+2^2+\dots +2^9+2^{10}=2^{11}-2=2046$ 个不同的点。画图理解（显示不完全）：
![https://cdn.luogu.com.cn/upload/image_hosting/9k7txmhj.png](https://cdn.luogu.com.cn/upload/image_hosting/9k7txmhj.png)

这是一棵满二叉树或完全二叉树。也可以直接用公式，一棵高度为 $k$ 的满二叉树全部节点为 $2^k-1$（例如图片中，高度为 $3$，结点总数为 $2^3-1=7$）。

结果发现，最多能到达的节点刚好大余 $N$ 的最大值。

但是现在只有 $1$ 能到达任意一个点（如图所示，多理解一下）。哎，很容易发现，既然 $1$ 能到达任意一个点，那我直接把叶子节点的边连向 $1$ 不就行了！
### 错误代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,h=1; 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	while(h<=n) h<<=1;
	h>>=1; h--;
	for(int i=1;i<=n;i++){
		if(i<=h) cout<<2*i<<" "<<2*i+1<<"\n";
		else cout<<"1 1\n";
	}
	return 0;
}
```
但是很可惜，这样是错误的。考虑极端情况：当我们在第 $1000$ 个点时，我们从这个点连边到 $1$，之后他前往任意一个点的路程都是大于等于 $10$ 的，所以不行。

既然连 $1$ 不行，就回到一开始：如果随便以一个数为根节点，前往其他数，最多的路程刚好是 $10$，所以可行（前提是这是一颗完全二叉树）。那我让他循环起来！让他以他自己为根节点的子树都是一颗完全二叉树就行了！对于每个节点 $i$ 都连接 $2\times i$ 和 $2 \times i+1$，如果超出了 $n$，那就对其取模，使范围在 $1\sim n$ 之间。

最后一步是非常难理解的（当然有一大部分原因是我的问题），最后再证明一下可行（用图片理解）：
![https://cdn.luogu.com.cn/upload/image_hosting/dizv9k3x.png](https://cdn.luogu.com.cn/upload/image_hosting/dizv9k3x.png)
![https://cdn.luogu.com.cn/upload/image_hosting/uycz9kuz.png](https://cdn.luogu.com.cn/upload/image_hosting/uycz9kuz.png)
![https://cdn.luogu.com.cn/upload/image_hosting/rxsinpzh.png](https://cdn.luogu.com.cn/upload/image_hosting/rxsinpzh.png)

这里只放 $3$ 张图片，观察到，这些边能使每一个结点都为根结点后是一颗高度最多为 $10$ 的完全二叉树（抛出那些多余的边）。这能满足题目的要求。
## AC代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,h=1; 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		int x=2*i,y=2*i+1;
		cout<<(x-1)%n+1<<" "<<(y-1)%n+1<<"\n";
	}
	return 0;
}
```

---

## 作者：Ivan422 (赞：2)

结论：连 $(2x-1) \bmod n +1$ 与 $2x \bmod n + 1$ 的边，[代码](https://atcoder.jp/contests/agc050/submissions/60006473)。

首先我们看到数据范围，$n\leq 1000$，我们发现 $\lfloor \log_2 n\rfloor \leq 10$，大家在赛场上如果没时间证明的话，看到数据范围应该可以猜出个大概。

接着我们考虑没有取模的情况。因为跳的位置在 $1$ 到 $1000$ 以内的所有正整数，我们考虑凑一下数。那么，这个问题就转成了我们要找出一个可以覆盖整个区间的变动方式，并且只能有两种变化。

根据上面的推论，我们考虑在 $2$ 的倍数上做文章。我们首先证明：用 $1$ 和 $2$ 能不能凑出所有正整数。首先只靠 $2$ 可以凑出 $2k$，其中 $k$ 为非负整数，而我们只需要在这 $2k$ 上加 $1$，就可以构造出 $2k$，$2k+1$ 这样的正整数数列，最后一个数，$1$，拿一个 $1$ 即可。所以，使用 $2k$ 与 $2k+1$ 可以凑出所有的正整数。

再加上一个取模，也不是难事。我们发现取模的范围是在 $0$ 到 $n-1$ 之间的，不过我们同样可以通过构造 $n$ 的凑数方法使得 $n\mod n=0$，完成条件。我们也发现，要是凑出所有正整数，那么就算取模，也是可以凑出来的，即取模不影响结果。

既然不影响结果，那直接做就是了。

写的可能不那么缜密，但是此题建议给蓝上下。

---

## 作者：WsW_ (赞：2)

### 思路
观察数据范围，发现 $10\approx \log_{2}1000$，而且每个点向另外两个点连边。想一想有什么跟 $\log_{2}N$ 和每个点出度为 $2$，合理想起线段树。  

发现线段树可以满足根结点到所有叶子结点不超过 $10$。但是这道题要任意一个结点到任意一个结点不超过 $10$，从二进制角度考虑一下。  

对每个点 $X$ 分别向 $X\times 2$ 和 $X\times 2+1$ 连边。从二进制的角度来看，不管一开始根 $X$ 是啥，上面这两个操作每次选一个进行 $10$ 次之后一定会变成**连续的 $1024$ 个数**。这连续的 $1024$ 个数对 $N$ 取模，得到的结果会覆盖 $0\sim N-1$；再加 $1$，得到的结果就会覆盖 $1\sim N$。  

所以，对每个点 $X$ 分别向 $X\times 2$ 和 $X\times 2+1$ 连边，走 $10$ 步的的结果能覆盖 $1\sim N$，可行。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int N;cin>>N;
	for(int i=1;i<=N;i++)
		cout<<i*2%N+1<<' '<<(i*2+1)%N+1<<'\n';
	return 0;
}
```

---

## 作者：whrwlx (赞：2)

~~很好构造题，害的我想了快一个小时。~~

经常看序号的同学都知道，序号之间一般是 $2$ 倍关系。

例如（这是第 $1$ 页的）：

| $1$ | $2$ | $4$ | $8$ | $16$ | $32$ | $64$ | $128$ | $256$ | $512$ | $603$ |
| :-: | :-: | :-: | :-: | :--: | :--: | :--: | :---: | :---: | :---: | :---: |

所以页数大概为 $x \rightarrow 2x$。

看到这个，容易想到大概是类似线段树建树的方式。

即 $x \rightarrow 2x$，$x \rightarrow 2x+1$。

刚好符合只有两个序号的限制。

为什么这样可以保证能够在最多点击 $10$ 个链接后从任意的一个页面跳转到任意的另一个页面？

因为在这种构造方法下，一定可以通过 $10$ 次操作从 $x$ 到达 $2^{10}x+y$，并且 $2^{10}>10^3$，所以在模 $n$ 再 $+1$ 的情况下，一定可以得到 $[1,n]$ 中的任意数。

代码实现很简单：

```c++
n=read();
fd(i,1,n) printf("%lld %lld\n",(i*2)%n+1,(i*2+1)%n+1);
```

---

## 作者：1234567890sjx (赞：2)

[前情提要](https://www.luogu.com.cn/discuss/1001028)，但是被 [KID2695](https://www.luogu.com.cn/user/544696) dalao 10 秒猜出了结论，%%%

猜结论题考虑观察数据范围。考虑到 $\log_2 1000<10$ 且 $|\log_2 1000-10|\approx\text{eps}$，因此考虑构造一个类似于二叉树的结构，因此可以想到对于每一个点 $x$，构造边 $x\times 2+1$ 和 $x\times 2$，并对 $n$ 取模。

然后你就能快乐的通过这个题了。

证明：

考虑 $x$ 点在 $10$ 步之内能够走到的集合。在不对 $n$ 取模的情况下，考虑到 $x$ 点 $10$ 步能走到的编号最大的点为 $2^{10}x+2^{10}-1=1024x+1023$，编号最小的点为 $2^{10}x=1024x$。此时能取得的点编号范围为 $[1024x,1024x+1023]$，显然在模 $n$ 意义下（$n\le 1000$）可以取到 $1\sim n$ 中所有的整数。因此证毕。

时间复杂度为 $O(n)$，可以通过。

```python
n = int(input())
for i in range(n):
  print(i * 2 % n + 1, (i * 2 + 1) % n + 1)
```

---

## 作者：ty_mxzhn (赞：2)

先想一个三条边的构造：$\lfloor\dfrac{x}{2}\rfloor,2x,2x+1$。

这个是有前途的！考虑把 $2x,2x+1$ 保留，欸但是这个怎么变成更小的数啊？

考虑溢出。乘二的时候溢出 $10$ 位无符号整数即可！

于是我们成功的对上了出题人的脑电波，AC 了一道紫题。

---

## 作者：Linge_Zzzz (赞：1)

给出一个最易理解的做法。

注意到 $n=1000$，而限制为 $10$，不难想到是 $\log n$。遍历我们学过的所有严格 $\log$ 的东西，不难想到线段树。

把所有的页面看做一个序列。先把 $1$ 当做根节点，建出一个线段树来。此时从 $1$ 出发，只需要走 $\lceil\log n\rceil$ 步就能到达所有节点，但是其他的节点可能到不了别的节点。

此时我们的叶子结点还没有往外连边，考虑利用叶子结点，然而我们并不知道叶子该往哪连。

此时用到本题最人类智慧的一步：

考虑把这个序列首尾相接，变成循环序列，然后以每一个点为根建线段树。此时把重复的边去掉，恰好满足每个点两条出边，且任意一个点为根都有一棵完整的二叉树。

我们如何想到这一步？发现线段树每个点往 $2i$ 和 $2i+1$ 连是一个很优美的东西，考虑对叶子结点沿用这个东西，那么就只能对 $n$ 取模。

---

## 作者：Y_QWQ_Y (赞：1)

### 解题思路
既然我们需要最少的跳跃次数，并且每个页面可以放两个链接，也就是有两个子节点，那么我们就可以想到通过构建一颗二叉树来最优化答案（从根到叶子节点的距离是 $\lceil\log n\rceil$ 的）。

但还是有点雾，所以就写了一份构造成线段树的代码，对于编号超过 $n$ 的就 $\bmod$ 一下。然后写了一份代码来对拍判断是否满足，发现这种构造方法的最大的距离是 $\lceil\log n\rceil$ 的。~~然后就做完了。~~

同时可以发现，最远的距离存在于从 $1$ 的左子节点到 $1$ 的右子树的叶子节点之间，下面给出证明：

在 $1$ 的左子树中，它的叶子节点为 $d$，可以到达 $2\times d$ 和 $2\times d + 1$，所有叶子节点到达的点（取模后）组合起来就可以到达所有编号小于编号最小的叶子节点（即 $2^{\lceil\log n\rceil - 1}$）的节点，这一句可能有点绕，所以我们~~感性理解一下~~，即所有编号 $<2^{\lceil\log n\rceil - 1}$ 点都能到达。虽然不能直接到达右子树的叶子节点，但是可以到达右子树的叶子节点的父亲，从而到达 $1$ 的右子树的叶子节点。

所以总共的距离是 $\lceil\log n\rceil - 2$（$\lceil\log n\rceil - 1$ 是 $1$ 到 左子树的叶子节点的距离，因为是从 $1$ 的左子节点出发，所以还要减一）$+1$（这个 $1$ 是从左子树的叶子节点到右子树的叶子节点的父亲的距离）$+1$（这个 $1$ 是从右子树的叶子节点的父亲到右子树的叶子节点的距离），总距离为 $\lceil\log n\rceil$。

所以就直接按照线段树构造即可，最大距离为 $\lceil\log n\rceil$。

---

## 作者：ni_ju_ge (赞：0)

## 题意
[题目传送门](https://www.luogu.com.cn/problem/AT_agc050_a)

有 $n$ 个点，求一种构造，使得所有点的出度均为 $2$，且任意两点间的最短路径长度小于等于 $10$。
## 思路
注意到 $2^{10}=1024>1000$，可以构造为类似完全二叉树的形式，即 $pos$ 指向 $pos\times 2$ 以及 $pos\times 2+1$，然后对其取模，由于取模前走 $10$ 步得到的为连续的 $2^{10}$ 个数，故而在取模后仍然满足要求。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++)cout<<(i*2)%n+1<<" "<<(i*2+1)%n+1<<endl;//记得加一
}
```

---

## 作者：fish_love_cat (赞：0)

从难度评定帖过来的，好神秘的题。

---

题意：

给定 $n$，你需要构造一个有 $n$ 个点的有向图，每个点的出度均为 $2$，要求任意两点的最短路径长度小于 $10$。

$n\le 1000$。

---

出度为 $2$，想到可以先构造一个二叉树。

也就是将 $x$ 连边 $2x,2x+1$。

那么从根节点到任意一个节点的最短路径长度不超过 $\lceil \log_2 n\rceil$，满足条件。

可致命缺陷是无法从任意一个节点出发。

~~然后就不会了……~~

---

有如下构造可以解决目前的困境。

当当前边连向的节点编号 $v$ 满足 $v>n$，我们将 $v$ 取模 $n$ 后加一，然后连边。

这样构造出来的图是正确的。

---

证明：

从原来二叉树的构造发现，从 $x$ 开始走，$10$ 步后能到达的点的编号 $v$ 在 $[1024x,1024x+1024)$ 区间内。

我们令 $v$ 对 $n$ 取模，你会发现前面的 $1024x$ 因为取模已经没用了，此时余数包含 $[0,n)$ 中所有的数。我们只需要再加一就可以令结果包含 $[1,n]$ 内所有的数。

容易发现，一个子树的根节点可以在 $10$ 步以内到达该树的叶子结点，然后我们可以再利用叶子结点跳到某个其他节点。

此时，当出发点的深度不够低时，他所能到达的叶子结点就更多，从叶子结点跳转后跑到目标点的次数就更少。而深度低时，走到叶子结点次数更少，足够跳转后走到目标点的消耗。

那么就可以保证在不超过 $10$ 次的跳转完成任务。

证毕。

---

代码实现简单不放了。

---


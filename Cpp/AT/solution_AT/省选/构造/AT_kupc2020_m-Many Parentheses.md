# Many Parentheses

## 题目描述

括号序列是由 `(` 和 `)` 组成的字符串。我们将满足以下任一条件的序列称为正确的括号序列：

- 空字符串
- 存在一个正确的括号序列 $A$，使得 `(`, $A$, `)` 按序连接构成新的序列
- 存在非空的正确括号序列 $S$ 和 $T$，使得 $S$, $T$ 连接形成新的序列

现在有 $N$ 个不同的盒子，你希望向每个盒子中放入一个正确的括号序列，但必须满足这两个条件：

1. 所有盒子中 `(` 的总个数为 $M$。
2. 长度恰为 $2 \times K$ 的括号序列不能放入任何盒子。

请计算满足条件的所有不同放置方法的总数，并输出其除以 $998244353$ 的余数。

在这里，我们认为两种放置方法不同当且仅当在某个盒子中放入的括号序列不同。

## 说明/提示

- $1 \leq N \leq 10^6$
- $1 \leq M \leq 10^6$
- $1 \leq K \leq M$

### 部分分

- 当 $1 \leq N, M \leq 2000$ 时，正确解答可得 $10$ 分。
- 无额外限制的数据集，正确解答可额外得到 $490$ 分。

### 示例解释

例如，对于以下组合：
- `(())` ，空
- `()()` ，空
- 空，`(())`
- 空，`()()`

共计 $4$ 种不同的放置方法。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
2 2 1```

### 输出

```
4```

## 样例 #2

### 输入

```
1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
24 120 30```

### 输出

```
379268651```

# 题解

## 作者：nullqtr_pwp (赞：0)

显然要对有 $k$ 个左括号的容斥，你发现核心问题在于求：$f(n,m)$：有多少组可空合法括号串，放入 $n$ 个不同的盒子，总长为 $2m$。直接给出结论：

$$
f(n,m)=\binom{2m+n-1}{m}-\binom{2m+n-1}{m-1}

$$

**【证明方法 $\bm 1$】**

事实上我们可以解决更强的问题（原题为 CF1924D，笔者场切了）：$n$ 个左括号 $m$ 个右括号，最长合法括号子序列长度为 $2k$ 的方案数。本题只需要令 $n'=m,m'=m+n,k=m$ 就好了。与一组操作形成双射。这个问题的答案 $g(n,m,k)=\binom{n+m}{k}-\binom{n+m}{k-1}$。证明是这样考虑的：套路化地将这个变成折线问题，令触碰 $y=0$ 是折线的最低点，触碰的时候充要条件是这个拿来匹配的栈变为空。因此统计关于 $k$ 最低点为某个直线就好了。容斥为 $\leq x$ 减去 $\leq x-1$，可以反射容斥。


**【证明方法 $\bm 2$】**

大概把暴力 dp 进行一下坐标变换然后扔到坐标系上转化为格路计数，也是典型的，这是另一篇题解。

**【证明方法 $\bm 3$】**

考虑将若干括号串合起来计数，成为一个括号串，构造双射，假设有四个盒子中的串分别是 $\texttt{A,B,C,D}$，我们在最前面插入 $4$ 个左括号，然后与这些括号匹配的右括号就是分隔符。也就是说对于 $\texttt{A,B,C,D}$ 我们构造 $\texttt{((((A)B)C)D)}$，现在相当于只确定了最前面的 $n$ 个左括号，后面的计数就是反射容斥了，即确定了起点和终点，不允许到 $x$ 轴下面，是简单的，可以推出来的就是那个式子。时间复杂度 $\mathcal O(n)$。

``` cpp
int n,m,k;
inline int f(int n,int m){
	if(!n)return (m==0);
	return sub(C((m<<1)+n-1,m),C((m<<1)+n-1,m-1));
}
void solve(){
	cin>>n>>m>>k,Fast_mod=FastMod(mod),init(maxn-3); const int p=f(1,k);
	int coef=1,ans=0;
	F(i,0,min(m/k,n)){
		if(!(i&1))inc(ans,norm(1ll*norm(1ll*C(n,i)*f(n-i,m-i*k))*coef));
		else dec(ans,norm(1ll*norm(1ll*C(n,i)*f(n-i,m-i*k))*coef));
		coef=norm(1ll*coef*p);
	} cout<<ans<<'\n';
}
```

---

## 作者：arrow_king (赞：0)

给定 $n$ 个有标号盒子，需要给每个盒子中放一个正则括号串（可以为空），满足要求：

- 所有括号串的总长是 $2m$。
- 没有任何一个盒子中的括号串长度为 $2k$。

求总方案数模 $998244353$。

---

线性做法。

先不管 $2k$ 的限制，求 $G(m,n)$ 表示将总长 $2m$ 的括号串放置在 $n$ 个盒子中的方案数。

~~显然可以多项式快速幂草过去对吧~~考虑建立递推关系，枚举第 $n$ 个盒子中装的串长度是多少，有
$$
G(m,n)=\sum_{k=0}^mG(m-k,n-1)\cdot C_k
$$
其中 $C_k$ 是第 $k$ 个卡特兰数 $\dfrac1{n+1}\dbinom{2n}n$。

这样转移是 $O(m^2n)$ 的，看看有没有什么更好的转移式子。

把 $G(m-k,n-1)$ 展开，得到
$$
\begin{aligned}
G(m,n)&=\sum_{k=0}^mC_k\sum_{j=0}^{m-k}G(m-k-j,n-2)\cdot C_j\\
&=\sum_{s=0}^mG(m-s,n-2)\sum_{k=0}^sC_kC_{s-k}\\
&=\sum_{s=0}^mG(m-s,n-2)\cdot C_{s+1}
\end{aligned}
$$
注意到
$$
\begin{aligned}
G(m+1,n-1)&=\sum_{s=0}^{m+1}G(m-s+1,n-2)\cdot C_s\\
G(m+1,n-1)&=G(m+1,n-2)+\sum_{s=0}^mG(m-s,n-2)\cdot C_{s+1}\\
G(m+1,n-1)&=G(m+1,n-2)+G(m,n)
\end{aligned}
$$
得到递推关系，可以 $O(nm)$ 求解。

但还是太慢了。这个递推关系在方格表上是对左侧和右上求和。考虑变换坐标，把第 $i$ 行向右平移 $i$ 格，令 $F(m,m+n)=G(m,n)$，得到
$$
F(m+1,m+n)=F(m+1,m+n-1)+F(m,m+n)
$$
即
$$
F(m,n)=F(m,n-1)+F(m-1,n)
$$

~~实际上这个递推关系完全可以打表打出来~~

但是注意到坐标变换之后对于所有 $n>0$ 有 $F(n,n)=0$，因此相当于格子走路但不能跨过 $y=x$，求走到 $(m,n)$ 的方案数。这就是我们反射容斥啊，有
$$
F(m,n)=\dbinom{n+m}m-\dbinom{n+m}{m-1}
$$
因此
$$
G(m,n)=\dbinom{n+2m-1}{m}-\dbinom{n+2n-1}{m-1}
$$

有边界 $G(0,0)=1$。

最后剩下个 $k$ 的限制，此时再容斥一下，枚举恰好等于 $k$ 的个数 $j$，系数是 $\dbinom nj(-1)^j$，方案数是 ${C_k}^j\cdot G(m-j\cdot k,n-j)$。最后求和即可。

复杂度 $O(n+m)$。

---

## 作者：KSCD_ (赞：0)

前段时间模拟赛做到的题，是同学分享的做法，感觉妙，写个题解。

先不考虑 $k$ 的限制，通过容斥计算答案。设不考虑限制时答案为 $f_{n,m}$，则再钦定一部分盒子内放长为 $2k$ 的括号序列，容斥一下可以得到答案为 $\sum_{i=0}^{\min(n,\lfloor\frac mk\rfloor)} (-1)^i\times {n\choose i} \times C_k^i\times f_{n-i,m-ik}$，其中 $C_k^i$ 为卡特兰数第 $k$ 项的 $i$ 次方，表示所钦定盒子内的方案数。因此只需要实现多次求解 $f_{n,m}$ 即可。

考虑把 $n$ 个串塞到一个新串里，构造一个双射。方式是在新串开头预先放置 $(n-1)$ 个左括号，后面继续构造合法括号串，要求后面部分还要再加入 $m$ 个左括号。对新串做括号匹配，以与前 $(n-1)$ 个左括号匹配的 $(n-1)$ 个右括号为分界点，把后面分成 $n$ 部分，每一部分均为合法括号串且总长为 $2m$，~~感性理解~~可以证明构成双射。

所以 $f_{n,m}$ 等价于长为 $2(n+m-1)$ 且开头 $(n-1)$ 位均为左括号的合法括号串数量。考虑反射容斥求解，经典地把左括号看成 $1$，右括号看成 $-1$，并以下标和前缀和建立坐标系。则答案即为从 $(n-1,n-1)$ 走到 $(2n+2m-2,0)$，且全程不跨过 $x$ 轴的方案数。推一推式子发现无后一条限制时方案数为 ${n+2m-1}\choose m$，也即在后面部分的 $(n+2m-1)$ 个位上随便选 $m$ 个放左括号。

那么还要减去跨过 $x$ 轴的方案数。注意到这些方案都经过了 $y=-1$ 这条直线，考虑把这种方案第一次经过 $y=-1$ 之后的部分沿 $y=-1$ 对称，终点变为 $(2n+2m-2,-2)$，~~感性理解~~可以证明起点到新终点的路径与原来的不合法路径形成双射，所以推一推得到不合法方案数为 ${n+2m-1}\choose {m-1}$，因此也有 $f_{n,m}={{n+2m-1}\choose m}-{{n+2m-1}\choose {m-1}}$。

这样就做完了，预处理阶乘和逆元，时间复杂度线性，[这是代码](https://atcoder.jp/contests/kupc2020/submissions/62710688)。

---


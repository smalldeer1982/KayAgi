# [ARC038D] 有向グラフと数

## 题目描述

有一有向图，带有 $N$ 个顶点和 $M$ 条边。图中的每个顶点上都写有整数，第 $i$ 个顶点上的整数是 $X_{i}$ 。一对喜欢玩游戏的兄妹用一枚象棋“马”在上面玩游戏。

- 游戏开始时，马位于 $1$ 号顶点。
- 在自己的回合，玩家必须在下述操作中恰好选择一项：
	+ **移动**：将马沿着边，从其当前所在的顶点移动至相邻顶点。必须恰好移动 $1$ 次；
    + **结束**：使游戏结束。
- 两名玩家轮流进入自己的回合。当有玩家执行“结束”操作时、或者在后手恰好移动 $10^{9}$ 次后，游戏立即结束。此时，游戏的**分数**就是马所在的顶点上写着的整数。

先手会采取行动使得分数尽可能地大，后手会采取行动使得分数尽可能地小。你知道游戏分数最后会是多少吗？

## 说明/提示

## 分部计分
此题分部计分。
- 数据集 $1$ 满足 $N \le 1000,$$M \le 2000$，解答正确者计 $30$ 分；
- 全部正确者，在上述 $30$ 分的基础上再计 $70$ 分。

此例中，游戏以下述过程进行：
- 先手将马从顶点 1 移至顶点 2 ；
- 后手将马从顶点 2 移至顶点 3 ；
- 先手结束游戏。

此时游戏结束，分数为2。在后手采取最优策略的情况下，先手不论采取何种策略，都不可能使分数大于2；且，在先手采取最优策略的情况下，后手不论采取何种策略，都不可能使分数小于2。

此例中，游戏以下述过程进行：
- 先手将马从顶点 1 移至顶点 2 ；
- 后手将马从顶点 2 移至顶点 4 ；
- 先手将马从顶点 4 移至顶点 3 ；
- 后手将马从顶点 3 移至顶点 1 ；
- （上述过程重复）
- 后手的第 $10^{9}$ 次移动，将马从顶点 3 移至顶点 1。

此时游戏结束，分数为1。在后手采取最优策略的情况下，先手不论采取何种策略，都不可能使分数大于1；且，在先手采取最优策略的情况下，后手不论采取何种策略，都不可能使分数小于1。

## 样例 #1

### 输入

```
3 3
1 3 2
1 2
2 3
3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 5
1 3 2 1
1 2
2 3
3 1
2 4
4 3```

### 输出

```
1```

# 题解

## 作者：wizard（偷开O2 (赞：1)

一道拓扑排序加二分的好题。

~~评黑就是搞笑，最多紫。~~

题解写完降紫了。
### 题意

有一个有向图，图中每个节点都有一个权值。

刚开始时，有一个棋子图上的 $1$ 节点。然后先手后手开始轮流操作，对于每一次操作，有两种选择：移动棋子到一个相邻的位置上；或者直接选择结束游戏。

先手的目标是使最终棋子的节点权值更大，后手目标是使最终棋子停止的节点权值更小。

如果没人结束游戏，那么后手在 $10^{9}$ 次操作后游戏结束。

求最终停留的节点权值。

### 分析

先后手的目标不同，所以先手每次会使棋子向着可以走道的最大节点走，后手反之。

我们先构造一组数据思考一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/bt1q5guv.png)

比如说张图，因为我们只需考虑 $1,2,3$ 三个点，所以我只给这三个点用红笔表上该点的权值（$5$ 点权值比 $3$ 点大，忘标了）。

首先，从 $1$ 点出发，先手必定会考虑 $2$ 点，当前权值为 $3$，接着后手会考虑两个点 $5$ 和 $3$，但是他目的是小的点，所以他必定会去 $3$，然后先手回到 $1$。

所以我们发现形成了一个环，先手必定胜利，因为他可以直接选择停止游戏。

现在就明了了，我们可以直接枚举答案，然后把图中点分为 $0$ 和 $1$ 两部分。

对于每个点来说，接下来的那一手都希望可以走到不一样的点上去。

$pos_{i}=0$ 表示他可以走到的所有的点 $pos_{next}=1$。

$pos_{i}=1$ 表示他至少可以走到一个不同的点，且 $pos_{next}=0$。

直接在二分判断的时候跑拓扑排序就行。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ls ((now<<1))
#define rs ((now<<1)|1)
#define mid (((l+r)>>1))
const int maxn=1e6+10;
const int inf=1e9;
const int maxa=2e3+10;
const int modd=998244353;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,l,r,m;
int c[maxn],a[maxn],q[maxn],p[maxn],f[maxn];
vector<int>v[maxn],g[maxn];
int h,t;
bool check(int now){
	h=0,t=0;
	for(int i=1;i<=n;i++){
		f[i]=-1,p[i]=(a[i]>=now?1:0),c[i]=0;
	}
	for(int i=1;i<=n;i++){
		for(int j:v[i]) c[i]+=(p[i]^p[j]);
		if(!c[i]) f[i]=0,q[t++]=i;
	}
	while(h<t){
		int u=q[h++];
		for(int j:g[u])if(p[u]!=p[j]&&f[j]==-1){
			if(f[u]){
				--c[j];
				if(!c[j]){
					f[j]=0;
					q[t++]=j;
				}
			}else f[j]=1,q[t++]=j;
		}
	}
	return f[1]==1;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		r=max(r,a[i]);
	}
	for(int i=1,x,y;i<=m;i++){
		cin>>x>>y;
		v[x].push_back(y);
		g[y].push_back(x);
	}
	l=a[1]+1;
	while(l<=r){
		if(check(mid)){
			l=mid+1;
		}
		else{
			r=mid-1;
		}
	}cout<<l-1<<endl;
	return 0;
} 
```

---

## 作者：juju527 (赞：1)

### $\texttt{Solution}$
显然，答案至少为 $x_1$，因为先手可直接结束

考虑二分答案，将原图权值分成两个集合，小于答案的与大于等于答案的，分别称为 0点，1点

先手显然想从0点走到1点，后手想从1点走到0点（也只能如此，否则对方即可结束）

记 $a_i$ 表示 $i$ 号点所属集合

考虑设 $f_i$ 表示 $i$ 号点最终是否能走到与自己不在同一集合的点

考虑对于有向边 $(j,i)$ 如何转移

1. $f_i=0,a_i\neq a_j$，那么 $f_j=1$
2. $\forall i\in \{i|(j,i) \And a_i\neq a_j\}$ 有 $f_i=1$，那么 $f_j=0$

初始状态即所有出边所属集合都与自己相同点，$f_i=0$

建反图拓扑排序转移即可

若最终 $f_1$ 未得出，即游戏将无限进行，由于后手结束游戏，故此情况后手在0/1游戏中胜利

[code](https://www.luogu.com.cn/paste/6vitt8iz)

---


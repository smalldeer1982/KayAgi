# Moving Slimes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/awtf2024-open/tasks/awtf2024_a

数直線上に $ N $ 匹のスライムがおり，$ i $ 番目のスライムは座標 $ A_i $ にいます． これらの座標はすべて異なります． 各スライムの重さは $ 1 $ です． また整数 $ K $ が与えられます．

あなたはまず $ K $ 匹のスライムを選び，選ばなかったスライムを数直線上から取り除きます． その後，選ばれたスライムは時刻 $ 0 $ から以下のように移動を行います．

- 各スライムの移動: 自分より大きい座標にいるスライムの重さの総和を $ R $，自分より小さい座標にいるスライムの重さの総和を $ L $ とする． そして，速度 $ R-L $ で移動する．ここで，速度が符号付きであることに注意せよ．つまり，$ R-L\ <\ 0 $ のときスライムは数直線上を負の方向へ動くものとする．

$ 2 $ 匹以上のスライムが同時に同じ座標に到達したとき，それらのスライムは合体します． 合体後のスライムの重さは合体前のスライムの重さの総和です． また合体後のスライムは上と同じ規則にしたがって移動します．

$ K $ 匹のスライムは合体を繰り返し，いずれ $ 1 $ 匹のスライムになります． このスライムが誕生する瞬間を時刻 $ t $ とします． あなたの目標は，$ K $ 匹のスライムを上手に選び，この $ t $ を最大化することです． $ t $ の最大値を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ K\ \leq\ N\ \leq\ 250000 $
- $ 0\ =\ A_1\ <\ A_2\ <\ \cdots\ <\ A_N\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

\- $ 1 $ 番目と $ 2 $ 番目のスライムを選ぶと $ t=0.5 $ になります． - $ 1 $ 番目と $ 3 $ 番目のスライムを選ぶと $ t=1 $ になります． - $ 2 $ 番目と $ 3 $ 番目のスライムを選ぶと $ t=0.5 $ になります． よって答えは $ 1 $ です．

### Sample Explanation 2

$ 1,2,4 $ 番目のスライムを選んだ場合，スライムの移動の様子は以下のとおりです． - $ 1,2,4 $ 番目のスライムを便宜的に $ X,Y,Z $ と呼ぶことにする． - 時刻 $ 0 $ : $ X,Y,Z $ はそれぞれ速度 $ +2,0,-2 $ で移動を開始する． - 時刻 $ 1/2 $ : $ X $ と $ Y $ が座標 $ 1 $ で合体する．合体後のスライムを $ XY $ と呼ぶことにする．$ XY $ は速度 $ 1 $ で移動を開始する．$ Z $ はこのとき座標 $ 8 $ におり，速度は $ -2 $ のままである． - 時刻 $ 17/6 $ : $ XY $ と $ Z $ が座標 $ 10/3 $ で合体する．よって $ t=17/6 $ となる． $ t $ を $ 17/6 $ より大きくすることはできないので，これが答えになります．

## 样例 #1

### 输入

```
3 2
0 1 2```

### 输出

```
1.00000000000000000000```

## 样例 #2

### 输入

```
4 3
0 1 4 9```

### 输出

```
2.83333333333333333333```

## 样例 #3

### 输入

```
4 4
0 1 2 3```

### 输出

```
0.50000000000000000000```

## 样例 #4

### 输入

```
20 6
0 3441380 120768398 229897071 231209282 232046760 254924545 325399248 385631087 400098966 480503302 501372095 502644652 524585010 541761042 691400171 725009462 767549897 837806226 927396743```

### 输出

```
135453315.33333333333333333333```

# 题解

## 作者：takanashi_mifuru (赞：1)

很巧妙的题。

首先有一个显而易见的结论，最终答案的形式必然是取一段前缀和一段后缀，如果不是这么选，我一定可以通过调整法把一个点调得更远一点，把总时间强行拉大。

如果一个一个史莱姆分析，这个题非常的不方便，考虑这个移动的过程，啥东西是不变量？

考虑分析前缀 $i$ 个和后缀 $i-k$ 个移动时所产生的贡献，我们需要想到一个方便的形式维护他们的移动状态以及方便判定达成答案条件的状态。

我们考虑先不考虑相撞啊融合啊来计算他们的移动距离，对于前 $i$ 个（这里假设 $i<k-i$，反过来则是对称情况。），其下标的总变化量为 $\frac{\{[(k-i)-(i-1)]+(k-i)\}i}2=(k-i)i$，至于后 $k-i$ 个，考虑除去最后 $i$ 个，其余的都在对冲，其距离恰好一一配对消去，只需要考虑后 $i$ 个即可，容易发现这和前 $i$ 个是对称的。

我们想让这个式子变得更为规则，并且还需要能刻画其相等状态，那自然是维护其平均数之差，容易发现左边会送平均数去右边 $\frac{(k-i)i}{i}=k-i$ 步，而右边则会送来 $\frac{(k-i)i}{k-i}=i$ 步，他们加起来正好是 $k$ 步！

这是一个很好的形式，我们脱离了 $i$。

假设他们平均数之差为 $neta$，则 $\frac{neta}{k}$ 显然成为了下界，因为我们的分析忽略了合并，而实际出现合并的时候，他们的平均数相遇的时间更慢。

但是细细想来，由于我们没有考虑相撞和各种乱七八糟的问题，这直接导致了 $\frac{neta}{k}$ 根本不能够代表任何东西？

是的，根本这个式子根本不能够代表答案，但是显然可以代表第 $i$ 个史莱姆与 $k-i$ 个史莱姆相遇时间，因为这个式子一旦满足，前后必然有相交段。

我们来分析一下最终答案的下界，最后所有史莱姆并为一点，所有 $neta$ 都为 $0$，理想状态下每次减去 $k$ 不变，则 $\frac{\max\{neta\}}{k}$ 就是答案的下界。

而最终答案的上界，我们考虑对于一个点 $i$ 他和点 $i+1$ 啥时候能够合并，容易发现越合并合并进程只会越来越快，那么最慢的就是根本不合并，也就是在时间 $\frac{neta}{k}$ 取到时间的上界。

最终答案肯定要求最终状态下相邻两个点都合并完成，也就是 $\frac{neta}{k}$ 取到最大值即为答案上界，即 $\frac{\max\{neta\}}{k}$ 是答案的上界。

容易发现此时上界和下界相同，所以我们得到 $\frac{\max\{neta\}}{k}$ 就是此时的答案。

那么这个的求解自然是容易的，考虑预处理出每个前缀的 $neta$，求其最大值同 $k$ 取模即可，时间复杂度 $O(n)$。

再看一遍还是很巧妙的题，平均数的转化根本没想到。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int a[250005];
int pre[250005];
double neta[250005];
double ans;
signed main(){
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        pre[i]=pre[i-1]+a[i];
    }
    for(int i=1;i<k;i++){
        neta[i]=1.*(pre[n]-pre[n-(k-i)])/(k-i)-1.*(pre[i])/i;
        ans=max(ans,neta[i]/k);
    }
    printf("%.9lf\n",ans);
    return 0;
}
```

---

## 作者：bluewindde (赞：0)

发现史莱姆不合并也不会影响答案，所以就不用考虑合并了。

这样处理之后，史莱姆的移动可以看作是受到与其不在同一位置的史莱姆的吸引所完成的，每只史莱姆可以给其他史莱姆一个单位的吸引力。

因为每只史莱姆提供的吸引力是恒定的，所以考虑把吸引力放在它们的重心上，设 $pre_i$ 表示坐标比第 $i$ 只史莱姆小的所有史莱姆的重心的坐标，$suf_i$ 表示坐标比第 $i$ 只史莱姆大的所有史莱姆的重心的坐标。

设 $d_i = suf_i - pre_i$，如果对所有史莱姆 $i$，都有 $d_i = 0$，则说明所有史莱姆已经处在同一个坐标上，满足终止条件。

只需要考虑每个 $d_i$ 需要多长时间减少到 $0$。为了方便，称从开始移动直到有两个史莱姆发生碰撞为一轮。

每一轮结束后，因为发生了碰撞，所以 $d_i$ 至少减少 $k$，得到答案的下界 $\frac {\max\{d_i\}} k$。

显然史莱姆的相对顺序是不变的，终止条件也可以表述为对除最后一个以外的史莱姆 $i$，$a_i = a_{i + 1}$。为了得到答案的上界，考虑尽可能延长这个条件达成的时间，则答案的上界也是 $\frac {\max\{d_i\}} k$。

为了最大化 $\max\{d_i\}$，显然选择的 $k$ 只史莱姆来自一段前缀和一段后缀。枚举每一对前后缀，容易在 $O(1)$ 的时间内计算这一方案的答案，时间复杂度 $O(n)$。

```cpp
#include <iomanip>
#include <iostream>

using namespace std;

typedef long long ll;
typedef long double ld;

int n, k;
int a[250005];
ll f[250005];

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        f[i] = f[i - 1] + a[i];
    }
    ld ans = 0;
    for (int i = 1; i < k; ++i)
        ans = max(ans, (ld)(f[n] - f[n - k + i]) / (k - i) - (ld)f[i] / i);
    cout << fixed << setprecision(20) << ans / k << endl;
    return 0;
}
```

---


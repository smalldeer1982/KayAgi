# Odd Sum Rectangles

## 题目描述

[problemUrl]: https://atcoder.jp/contests/hitachi2020/tasks/hitachi2020_e

$ (2^N\ -\ 1) $ 行 $ (2^M-1) $ 列のグリッドがあり、 あなたはこれからすべてのマスに $ 0,\ 1 $ のいずれかの数字を書き込みます。 上から $ i $ 行目、左から $ j $ 列目に書き込む数字を $ a_{i,j} $ とします。

$ 1\leq\ i_1\ \leq\ i_2\leq\ 2^N-1,\ 1\leq\ j_1\ \leq\ j_2\leq\ 2^M-1 $ をみたす整数の組 $ (i_1,\ i_2,\ j_1,\ j_2) $ に対し、 $ S(i_1,\ i_2,\ j_1,\ j_2)\ =\ \displaystyle\ \sum_{r=i_1}^{i_2}\sum_{c=j_1}^{j_2}a_{r,c} $ と定義し、 さらに、グリッドの「奇妙さ」を $ S(i_1,\ i_2,\ j_1,\ j_2) $ が奇数となるような $ (i_1,\ i_2,\ j_1,\ j_2) $ の個数 と定義します。

奇妙さが最大となるような数字の書き込み方を $ 1 $ つ求めてください。

## 说明/提示

### 制約

- $ N,\ M $ は $ 1 $ 以上 $ 10 $ 以下の整数

### Sample Explanation 1

$ S(1,\ 1,\ 1,\ 1) $、$ S(1,\ 1,\ 2,\ 2) $、$ S(1,\ 1,\ 3,\ 3) $、$ S(1,\ 1,\ 1,\ 3) $ が奇数となるため、このグリッドの奇妙さは $ 4 $ です。 奇妙さを $ 5 $ 以上にすることはできないため、これは奇妙さが最大となる書き込み方の $ 1 $ つです。

## 样例 #1

### 输入

```
1 2```

### 输出

```
111```

# 题解

## 作者：gyh20 (赞：11)

打表找规律出奇迹！！！

但本篇题解不仅会告诉你规律，还会告诉你是怎么找到的，同时也分享一下个人比赛时的经历。

做完 A 和 B 之后，一看 C，完全没思路（虽然好像很简单），D 和 F 也跳过了，看向可这个仿佛是结论的 E。

由于我 $A,B$ 做的很慢，不再做出一道就要掉 Rating,我就尽全力去搞这道题。

样例给的太简单，自己手推几个稍微大一点的，发现：答案的 $1$，$0$ 是分布的很均匀的，于是，第一次，我提交了这样的一种形式。

```cpp
101
010
101
```

手推了几个小样例，都能过，于是交了一发。

结果不出所料，只 A 了 $6$ 个点（没那么简单）。

之后手写了一个 $2^{2^{nm}} \times 2^{nm^4}$ 的暴力做法，打了一些小的表，但解太多，不好得出结论。

之后我又加了一些条件：只输出中心对称图形，然后我找到了这样一个图形。

```cpp
01000
10100
01010
00101
00010
```

然后我算了算 $n=3,m=3$ 的情况（如果找到更优解就直接退出，这样能更高效的判断是否存在更优解），好像是最优的。

再考虑 $n\neq m$ 的情况，可以将上述的图形复制几遍，打表得出，中间的几个无论填什么都可以。

交上去，也只 A 了$6$ 个点。

虽然这个方法 WA 了，但这为正解做了铺垫。

这时，我又看了看题目，发现，求的方阵是 $2^n-1,2^m-1$ 的形式，结合之前的方法得出，这可以用几个正方形拼起来。

而遇到这种 $2^n-1$ 的形式，可以用划分的方法解决，也就是说左上角，右上角，左下角，右下角都是一样的，然后中间的一行一列单独考虑，为了确保 $0,1$ 均衡，自己试了几个规律，最后发现了一个似乎是最优解的方法。

在最中间的格子填 $1$，然后处理左上角，右上角，左下角，右下角。

其实我比赛的时候交了很多次，只不过有小毛病，就不再提了。

当时的我其实不确定一个长方形是否能由几个正方形拼起来，所以我只写了正方形的情况。然后我加了一句：
```cpp
if(n<10||m<10)while(1);
```

出题人肯定会出 $n=10,m=10$ 的数据。

然后打开提交记录，我看到了 $16$ 个 T 和 $1$ 个A！

这比我看到 $16$ 个 A 和 $1$ 个 WA 还高兴！

我加上了长方形的情况，交了一遍。

AC 了？！

AC 了！！

排行榜上排名升了 $800$ 名，Rating++。（似乎 Rank 2 都没做出来这道题）

总结一下:遇到一些结论题，可以通过打表(oeis)的方法来找规律，同时可以通过剪枝的枚举（找到更优解就退出）来检验，在观察题目中的一些特殊性质（比如 $2^n$）和表的一些性质（$0,1$ 分布均衡）再加上手算得到最优解。

附上代码（重点在上面，代码没有难度）：

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#define re register
using namespace std;
int n,m;
int mp[2052][2052];
inline void work(re int x,re int y,re int X,re int Y){
	if(x==X&&y==Y){
		mp[x][y]=1;
		return;
	}
	mp[x+X>>1][y+Y>>1]=1;
	int midx=x+X>>1,midy=y+Y>>1;
	work(x,y,midx-1,midy-1);
	work(midx+1,y,X,midy-1);
	work(x,midy+1,midx-1,Y);
	work(midx+1,midy+1,X,Y);
}
signed main(){
	int tmp=0;
	scanf("%d%d",&n,&m);
	if(n<m){
		for(re int i=1;i<=(1<<m);i+=(1<<n)){
			work(1,i,(1<<n)-1,i+(1<<n)-2);
		}
	}
	else{
		for(re int i=1;i<=(1<<n);i+=(1<<m)){
			work(i,1,i+(1<<m)-2,(1<<m)-1);
		}
	}
	for(re int i=1;i<(1<<n);++i){
		for(re int j=1;j<(1<<m);++j)
		printf("%d",mp[i][j]);
		putchar('\n');
	}
}
```


---

## 作者：qweradf (赞：8)

[link](https://www.luogu.com.cn/problem/AT_hitachi2020_e)

以下设 $N\leq M$.

考虑原矩阵的前缀异或和矩阵，原问题等价于：使 $2^N$ 行 $2^M$ 列且第一行、第一列全为 $0$ 的 $01$ 矩阵 $S$ 中，顶点异或和为奇数的子矩形数目最大.

考虑 $S$ 中任意两行，设这两行中对应位置有 $u$ 对元素相同，$v$ 对元素不同，则 $u+v=2^M$. 

容易看出，顶点在这两行上，符合条件的矩形个数就等于 $uv$. 

而 $uv\leq (\frac{u+v}{2})^2=2^{2M-2}$，所以符合条件的矩形个数上界为 $\binom{n}{2} \cdot 2^{2M-2}$，取等条件为任意两行都恰有一半对应位置上的数相等（这个条件很松）.

构造见代码，正确性显然.

```cpp
for(i=0;i<n;i++){
	for(j=(1<<i);j<(1<<(i+1));j++){
		for(k=0;k<(1<<m);k++){
			S[j][k]=S[j-(1<<i)][k]^((k>>i)&1);
		}
	}
}
```

有同学反映构造看不懂，大意就是第 $0$ 行全取零，第 $2^i$ 到第 $2^{i+1}-1$ 行复制第 $0$ 到 $2^i-1$ 行，并将 $\mod 2^{i+1}$ 余数大于等于 $2^i$ 的列取反.

---

## 作者：GIFBMP (赞：4)

前言：瞎猜结论出奇迹！

首先我们考虑题目中的 $2^n-1$ 和 $2^m-1$ 是做什么的，我们可以发现，可以把这个大矩形分成四个 $2^{n-1}-1\times 2^{m-1}-1$ 的小矩形，再加上中间的一行和一列。

然后这个问题就转化成了一个分治的问题，边界条件直接填 $1$ 即可。现在关键是如何处理中间的一行和一列。

通过对小数据的模拟可以得出，在第 $2^{n-1}$ 行第 $2^{m-1}$ 列填 $0$，中间一行和一列的其它位置全部填 $1$ 时，答案是最优的。于是我们就通过手动模拟和瞎猜结论通过了本题。

Code：
```cpp
#include <cstdio>
using namespace std ;
const int MAXN = 1.5e3 + 10 ;
int n , m , a[MAXN][MAXN] ;
#define midx ((x1 + x2) >> 1)
#define midy ((y1 + y2) >> 1)
void solve (int x1 , int x2 , int y1 , int y2) {
	if (x1 > x2 || y1 > y2) return ;
	if (x1 == x2 && y1 == y2) {a[x1][y1] = 1 ; return ;}
	solve (x1 , midx - 1 , y1 , midy - 1) ;
	solve (midx + 1 , x2 , y1 , midy - 1) ;
	solve (x1 , midx - 1 , midy + 1 , y2) ;
	solve (midx + 1 , x2 , midy + 1 , y2) ;
	for (int i = y1 ; i <= y2 ; i++)
		if (i != midy) a[midx][i] = 1 ;
	for (int i = x1 ; i <= x2 ; i++)
		if (i != midx) a[i][midy] = 1 ;
}
int main () {
	scanf ("%d%d" , &n , &m) ;
	n = (1 << n) - 1 , m = (1 << m) - 1 ; 
	solve (1 , n , 1 , m) ;
	for (int i = 1 ; i <= n ; i++ , puts (""))
		for (int j = 1 ; j <= m ; j++)
			printf ("%d" , a[i][j]) ;
	return 0 ; 
} 
```

---

## 作者：lr580 (赞：4)

给出两种构造方法。~~然而本蒟蒻不会证明该解法的正确性。~~ 

###### 方法一

通过写暴力验证程序，然后在小数据范围内任意~~胡乱~~进行输入测试，发现测试能找到的最大的解满足如下规律：偶数行的部分偶数列是 $0$，其他位置为 $1$。

继续进行更多针对性的暴力验证，进一步发现：第 $2,6,10,\cdots$ 行每隔两个填一个 $0$；第 $4,12,20,28,\cdots$ 行每隔四个填一个 $0$。以此类推，总结下来是：记当前偶数行是第 $i$ 行，那么第 $lowbit(i)$ 行每隔 $lowbit(i)$ 列填一个 $0$。如下所示。

```c++
1111111
1010101
1111111
1110111
1111111
1010101
1111111
```

```c++
111111111111111
101010101010101
111111111111111
111011101110111
111111111111111
101010101010101
111111111111111
111111101111111
111111111111111
101010101010101
111111111111111
111011101110111
111111111111111
101010101010101
111111111111111
```

于是写出程序，如下所示。

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
#define mn 1030
ll n, m, a[mn][mn];
signed main()
{
    sc(n), sc(m);
    for (ll i = 1, ie = (1 << n) - 1; i <= ie; ++i)
    {
        for (ll j = 1, je = (1 << m) - 1; j <= je; ++j)
        {
            a[i][j] = 1;
        }
    }
    for (ll i = 2; i <= (1 << n) - 1; i += 2)
    {
        ll k = i & (-i); //lowbit
        for (ll j = k; j <= (1 << m) - 1; j += k)
        {
            a[i][j] = 0;
        }
    }
    for (ll i = 1, ie = (1 << n) - 1; i <= ie; ++i)
    {
        for (ll j = 1, je = (1 << m) - 1; j <= je; ++j)
        {
            printf("%lld", a[i][j]);
        }
        putchar('\n');
    }
    return 0;
}
```



###### 方法二

事实上，我一开始找出的规律并不是上面那样的。而是像下面例子展示这样的规律。不难发现，该规律的与方法一区别在于第 $lowbit(i)$ 行每隔 $ 2\times lowbit(i)$ 列填一个 $0$。直观上看，这是递归可以轻松构造出的分形，即先在图形中心设一个 $0$ 然后一分为四地递归往下处理。所以这样的规律比较便于递归输出。

```c++
1111111
1011101
1111111
1110111
1111111
1011101
1111111
```

```c++
111111111111111
101110111011101
111111111111111
111011111110111
111111111111111
101110111011101
111111111111111
111111101111111
111111111111111
101110111011101
111111111111111
111011111110111
111111111111111
101110111011101
111111111111111
```

这样的规律对 $n\neq m$ 我不会构造，所以当 $n\neq m$ 的时候，我强行将矩阵拓展到了 $n=m$ 然后构造。

参考代码如下。

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
#define mn 1030
ll n, m, a[mn][mn], top;
void f(ll ax, ll bx, ll ay, ll by)
{
    if (bx - ax >= 2 && by - ay >= 2)
    {
        ll cx = (ax + bx) >> 1, cy = (ay + by) >> 1;
        a[cx][cy] = 0;
        f(ax, cx - 1, ay, cy - 1);
        f(cx + 1, bx, ay, cy - 1);
        f(ax, cx - 1, cy + 1, by);
        f(cx + 1, bx, cy + 1, by);
    }
}
signed main()
{
    sc(n), sc(m), top = max(n, m); //强行拓展到n=m进行递归
    for (ll i = 1, ie = (1 << top) - 1; i <= ie; ++i)
    {
        for (ll j = 1, je = (1 << top) - 1; j <= je; ++j)
        {
            a[i][j] = 1;
        }
    }
    f(1, (1 << top) - 1, 1, (1 << top) - 1);
    for (ll i = 1, ie = (1 << n) - 1; i <= ie; ++i)
    {
        for (ll j = 1, je = (1 << m) - 1; j <= je; ++j)
        {
            printf("%lld", a[i][j]);
        }
        putchar('\n');
    }
    return 0;
}
```



---

## 作者：Purslane (赞：2)

# Solution

首先转为前缀和数组（包含第 $0$ 行和第 $0$ 列）。对于这个 $2^M \times 2^N$ 的矩阵，只用要求第一行和第一列是 $0$，其他的格子都是自由的。答案就是四个端点异或起来得到 $1$ 的矩形个数。不妨设 $M \le N$。

下面的做法很劲爆：对于 $i$ 行和 $j$ 行，假设对应列有 $u$ 个数相同，$v$ 个数不同，则 $u+v = 2^N$，答案就是 $uv$。根据均值不等式，我们希望 $u=v=2^{N-1}$。

问题变为：在每一行钦定一半的 $0$ 和一半的 $1$，使得任意两行差异数为一半。对于每一行的所有数，分别用某种方法区分一半 $0$ 和一半 $1$，而不同行之间几乎是毫不相干的。

那么考虑直接令 $pre_{i,j} = \text{popcount}(i \& j) \bmod 2$，容易验证正确性。

非常 MO 向的一道题，个人很喜欢。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1050;
int n,m,a[MAXN][MAXN];
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,(1<<n)-1) ffor(j,1,(1<<m)-1) a[i][j]=__builtin_popcount(i&j)&1;
	roff(i,(1<<n)-1,1) roff(j,(1<<m)-1,1) a[i][j]=a[i][j]^a[i-1][j]^a[i][j-1]^a[i-1][j-1];
	ffor(i,1,(1<<n)-1) {
		ffor(j,1,(1<<m)-1) cout<<a[i][j];
		cout<<'\n';	
	}
	return 0;
}
```

---

## 作者：__OwO__ (赞：1)

翻译了一下官方题解.

首先是证明上界

先假设 $N\geqslant M$ ,
记 $H=2^N,W=2^M$.

我们取出 $W(W-1)/2$ 组满足 $1\leqslant j_1\leqslant j_2\leqslant W-1$ 的 $(j_1,j_2)$.

用 $f(i)(0\leqslant i\leqslant H-1)$ 表示 $S(1,i,j_1,j_2)$ 那么满足 $S(i_1,i_2,j_1,j_2)$ 是奇数的方案数就是使得 $f(i)$ 为 $0$ 的 $i$ 的数目乘上使得 $f(i)$ 为 $1$ 的 $i$ 的数目. 这个值的上界是 $(H/2)*(H/2)$ 因此答案的上界是 $\dfrac {H^2} 2 \times\dfrac{W(W-1)}2$

然后是证明上界能够被构造出.

当 $N=M$ 时, 我们使用数学归纳法证明.
此时的答案上界是 $2^{3N-3}(2^N-1)$
1. 当 $N=1$ , 填上 $1$ 即可.
2. 假设和 $N=K$ 时有解,
当前的最优答案是 $2^{4K-3}-2^{3K-3}$,
我们要构造出一个 $N=K+1$ 的解,
这个解的答案是 $2^{4K+1}-2^{3K}$,
首先我们把 $N=K$ 的解放在四个角上,
然后剩下了一个宽度为 $1$ 的一个 "十字形" 空,
我们在他的中间即 $(2^K,2^K)$ 填上一个 $1$ ,
其余的填 $0$ .

(然后官方题解说没时间了没有证明)

我们可以考虑中间点的贡献,
只要证明增加了这个中间点对答案的贡献是之前和之后的贡献之差即可.

当 $N>M$ 时,
我们可以把 $M$ 置为 $N$ 求解,
然后输出的时候按照给定的大小输出即可.

但是实际上实现的时候也没有必要这样写,
可以直接考虑每次在中间填一个数,
然后递归四个角,
这样可以在 $N=M$ 的时候同样正确.

(一般看到 $2^N$ 可以猜一下二分下去递归构造).

代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e3 + 5;

int n, m;
int a[N][N];

void cons(int l, int r, int x, int y) {
    if (l > r || x > y) return;
    int mx = (l + r) >> 1, my = (x + y) >> 1;
    a[mx][my] = 1;
    cons(l, mx - 1, x, my - 1);
    cons(mx + 1, r, x, my - 1);
    cons(l, mx - 1, my + 1, y);
    cons(mx + 1, r, my + 1, y);
}

int main() {
    scanf("%d%d", &n, &m);
    cons(1, (1 << n) - 1, 1, (1 << m) - 1);
    for (int i = 1; i < 1 << n; ++i, puts(""))
        for (int j = 1; j < 1 << m; ++j) printf("%d", a[i][j]);
}
```

---


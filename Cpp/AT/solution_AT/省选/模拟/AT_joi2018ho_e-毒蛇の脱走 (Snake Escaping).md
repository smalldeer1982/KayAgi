# 毒蛇の脱走 (Snake Escaping)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2018ho/tasks/joi2018ho_e

JOI 研究所では $ 2^L $ 匹の毒蛇を飼っており，それぞれ $ 0,\ 1,\ \ldots,\ 2^L\ -\ 1 $ の番号が付けられている．すべての毒蛇は頭から順に $ L $ 個の部分に分かれており，それぞれの部分は青または赤である．毒蛇 $ i $ に対し，$ i $ を $ 2 $ 進表記して $ i\ =\ \sum_{k\ =\ 1}^{L}\ c_k\ 2^{L\ -\ k} $ ($ 0\ \leqq\ c_k\ \leqq\ 1 $) とおいたとき，

- $ c_k\ =\ 0 $ であれば，毒蛇 $ i $ の頭から数えて $ k $ 番目の部分は青であり，
- $ c_k\ =\ 1 $ であれば，毒蛇 $ i $ の頭から数えて $ k $ 番目の部分は赤である．

各毒蛇には毒性と呼ばれる $ 0 $ 以上 $ 9 $ 以下の整数値が定まっている．`0`，`1`，`2`，`3`，`4`，`5`，`6`，`7`，`8`，`9` からなる長さ $ 2^L $ の文字列 $ S $ が与えられ，その $ i $ 文字目 ($ 1\ \leqq\ i\ \leqq\ 2^L $) は毒蛇 $ i\ -\ 1 $ の毒性を表す．

毒蛇たちの動きは素早いので，JOI 研究所からは，よく毒蛇たちが脱走してしまう．JOI 研究所には脱走した毒蛇を目撃した周辺住民から苦情が寄せられる．

あなたには，$ Q $ 日間にわたる苦情の情報が与えられる．$ d $ 日目 ($ 1\ \leqq\ d\ \leqq\ Q $) に寄せられた苦情は `0`，`1`，`?` からなる長さ $ L $ の文字列 $ T_d $ として表され，

- $ T_d $ の $ j $ 文字目 ($ 1\ \leqq\ j\ \leqq\ L $) が `0` の場合は，$ d $ 日目に脱走したすべての毒蛇の頭から数えて $ j $ 番目の部分が青であることを表し，
- $ T_d $ の $ j $ 文字目 ($ 1\ \leqq\ j\ \leqq\ L $) が `1` の場合は，$ d $ 日目に脱走したすべての毒蛇の頭から数えて $ j $ 番目の部分が赤であることを表し，
- $ T_d $ の $ j $ 文字目 ($ 1\ \leqq\ j\ \leqq\ L $) が `?` の場合は，$ d $ 日目に脱走した毒蛇の頭から数えて $ j $ 番目の部分については，周辺住民からは情報が与えられなかったことを表す．

苦情はすべて正確な情報である．脱走した毒蛇は JOI 研究所の職員がその日のうちに捕獲する．捕獲された毒蛇が，翌日以降に再び脱走することはあり得る．

毒蛇の脱走によるリスクを見積もるために，JOI 研究所の K 理事長は脱走した可能性のある毒蛇の毒性の合計を知りたい．あなたの仕事は，$ Q $ 日間にわたる苦情の情報から，それぞれの日ごとに，その日に脱走した可能性のある毒蛇の毒性の合計を求めるプログラムを作成することである．

## 说明/提示

### 課題

毒蛇の毒性を表す文字列 $ S $ と，$ Q $ 日間の苦情の情報が与えられるので，それぞれの日ごとに，その日に脱走した可能性のある毒蛇の毒性の合計を求めるプログラムを作成せよ．

メモリ制限が小さいことに注意すること．

- - - - - -

### 制限

すべての入力データは以下の条件を満たす．

- $ 1\ \leqq\ L\ \leqq\ 20 $．
- $ 1\ \leqq\ Q\ \leqq\ 1\,000\,000 $．
- $ S $ は長さ $ 2^L $ の文字列である．
- 文字列 $ S $ は `0`，`1`，`2`，`3`，`4`，`5`，`6`，`7`，`8`，`9` からなる．
- $ T_d $ は長さ $ L $ の文字列である ($ 1\ \leqq\ d\ \leqq\ Q $)．
- 文字列 $ T_d $ は `0`，`1`，`?` からなる ($ 1\ \leqq\ d\ \leqq\ Q $)．

### 小課題

#### 小課題 1 \[5 点\]

以下の条件を満たす．

- $ L\ \leqq\ 10 $．
- $ Q\ \leqq\ 1\ 000 $．

#### 小課題 2 \[7 点\]

- $ L\ \leqq\ 10 $ を満たす．

#### 小課題 3 \[10 点\]

- $ L\ \leqq\ 13 $ を満たす．

#### 小課題 4 \[53 点\]

- $ Q\ \leqq\ 50\ 000 $ を満たす．

#### 小課題 5 \[25 点\]

- 追加の制限はない．

- - - - - -

### Sample Explanation 1

この入力例では，$ L\ =\ 3 $ である．$ 3 $ つの部分に分かれた毒蛇が，全部で $ 2^3\ =\ 8 $ 匹いる．苦情は $ 5 $ 日間にわたって寄せられる． - $ 1 $ 日目に脱走した可能性のある毒蛇は，毒蛇 $ 0 $ のみである．毒性の合計は $ 1 $ である． - $ 2 $ 日目に脱走した可能性のある毒蛇は，毒蛇 $ 0,\ 1,\ 2,\ 3 $ である．毒性の合計は $ 10 $ である． - $ 3 $ 日目に脱走した可能性のある毒蛇は，毒蛇 $ 4,\ 6 $ である．毒性の合計は $ 12 $ である． - $ 4 $ 日目に脱走した可能性のある毒蛇は，毒蛇 $ 3,\ 7 $ である．毒性の合計は $ 12 $ である． - $ 5 $ 日目に脱走した可能性のある毒蛇は，毒蛇 $ 0,\ 1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7 $ である．毒性の合計は $ 36 $ である． - - - - - -

## 样例 #1

### 输入

```
3 5
12345678
000
0??
1?0
?11
???```

### 输出

```
1
10
12
12
36```

## 样例 #2

### 输入

```
4 8
3141592653589793
0101
?01?
??1?
?0??
1?00
01?1
??10
????```

### 输出

```
9
18
38
30
14
15
20
80```

# 题解

## 作者：童年的小翼龙 (赞：5)

### 题意

给你 $2^L$ 个长为 $L$ 的 $0/1$ 串，第 $i$ 个串为 $i$ 的二进制表达，每个串有权值 $a_i$。$q$ 次询问，每次给你一个长为 $L$ 的串，其由 $0/1/?$ 构成。求将 $?$ 换成任意的 $0/1$ 之后，所有 可能与给定的询问串相同的串 的权值之和。 

### 题解

本文中的 $\&,|$ 分别表示二进制与运算，二进制或运算。

考虑一个给定的询问串。

记 $cnt_0,cnt_1,cnt_2$ 分别表示 $0,1,?$ 在询问串的个数，$all_0,all_1,all_2$ 表示询问串中 $0,1,?$ 的位置，如 $L=3$，询问串为 $01?$，则 $all_0=100,all_1=010,all_2=001$。由于 $cnt_0+cnt_1+cnt_2\le 20$，所以 $\min\{cnt_0 , cnt_1 , cnt_2\} \le 6$，对这三种情况分类讨论。

- 若 $cnt_2\le 6$

  直接暴力枚举每一个 $?$ 填什么，给总答案加上对应的 $0/1$ 串的权值。时间复杂度 $O(2^{cnt_2})$。

- 若 $cnt_0\le 6$

  记 $f1_i=\sum_{i|j=j}a_j$。此时：

  - 若 $cnt_0=0$，则答案为 $f1_{all_1}$。
  - 若 $cnt_0=1$，则答案为 $f1_{all_1}-f1_{all_1|all_0}$，即用钦定 $all_1$ 的所有位置填 $1$ 的方案数减去本来是 $0$ 的位置填了 $1$ 的方案数。

  这启示我们考虑容斥，用钦定 $all_1$ 的位置填 $1$ 的方案数，减去 $all_0$ 的位置填了 $1$ 的方案数。因为 $cnt_0\le 6$ 所以直接枚举哪些本来是 $0$ 的位置填了 $1$ 即可，即枚举 $all_0$  的子集。即答案为：
  $$
  \sum_{i|all_0=all_0,popcount(i)\&1=0} f1_{all_1|i}-\sum_{i|all_0=all_0,popcount(i)\&1=1}f1_{all_1|i}
  $$
  时间复杂度 $O(2^{cnt_0})$。

- 若 $cnt_1\le 6$

  同 $cnt_0\le 6$，记 $f0_i\sum_{j|i=i}a_j$ ，即 $f0_i$ 表示所有串 $j$ 满足其所有 $0$ 的位置构成的集合是 $i$ 中 $0$ 的位置构成的集合的超集的串 $j$ 的权值和，则答案为：
  $$
  \sum_{i|all_1=all_1,popcount(i)\&1=0} f0_{all_0|i}-\sum_{i|all_1=all_1,popcount(i)\&1=1}f0_{all_0|i}
  $$
  时间复杂度 $O(2^{cnt_1})$。

综上所述，单次询问的时间复杂度为 $O(2^{\lfloor\frac{L}{3}\rfloor})$，考虑上述的 $f0,f1$ 实际上就是一个高维前缀和，预处理的时间复杂度为 $O(2^LL)$，所以总时间复杂度为 $O(2^LL+q2^{\lfloor\frac{L}{3}\rfloor})$，可以通过。

[AC 记录及 Code](https://atcoder.jp/contests/joi2018ho/submissions/45954278)。


---

## 作者：NOI_Winner (赞：3)

双倍经验：[P7670 [JOI2018] Snake Escaping](https://www.luogu.com.cn/problem/P7670)。

先考虑暴力做法，我们枚举询问字符串所有可能的情况，直接统计答案。这种做法的时间复杂度为 $O(Q\cdot2^L)$ 。

考虑如何优化，注意到 $\texttt{0,1,?}$ 三种字符出现次数最少的最多只有 $\frac{n}{3}$ 个，因此我们可以对三种可能的最少的字符分别用不同方式处理。

1. 最少的字符为 $\texttt{?}$ ，直接用暴力方法即可。

2. 最少的字符为 $\texttt{1}$ ，我们将编号的每一位作为一个维度，预处理高维前缀和。查询时将 $\texttt{?}$ 的位置改为 $\texttt{1}$ ，并对 $\texttt{1}$ 的位置应用容斥原理即可。

3. 最少的字符为 $\texttt{0}$ ，同理，我们预处理高维后缀和，同样处理就行了。

时间复杂度降为 $O(Q\cdot2^\frac{n}{3})$ 。

具体实现方式请见代码：

```cpp
#include <iostream>

using namespace std;

const int maxl = 20, maxn = 1 << maxl;
int val[maxn + 5], s1[maxn + 5], s2[maxn + 5];
char str[maxn + 5];

void fwt1(int* a, int k)           //  预处理高维前缀和 
{
	if (!k)
		return;
	
	fwt1(a, k - 1); fwt1(a + (1 << (k - 1)), k - 1);
	for (int i = 0; i < 1 << (k - 1); ++i)
		a[i + (1 << (k - 1))] += a[i];
}

void fwt2(int* a, int k)           //  预处理高维后缀和 
{
	if (!k)
		return;
	
	fwt2(a, k - 1); fwt2(a + (1 << (k - 1)), k - 1);
	for (int i = 0; i < 1 << (k - 1); ++i)
		a[i] += a[i + (1 << (k - 1))];
}

inline int f(int x)
{
	return (x & 1) ? -1 : 1;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int k, q; cin >> k >> q;
	for (int i = 0; i < 1 << k; ++i)
	{
		char ch; cin >> ch;
		val[i] = ch - '0';
	}
	for (int i = 0; i < 1 << k; ++i)
		s1[i] = s2[i] = val[i];
	fwt1(s1, k); fwt2(s2, k);           //  预处理 
	
	while (q--)
	{
		cin >> str;
		int cnt0 = 0, cnt1 = 0;
		for (int i = 0; i < k; ++i)
			if ('0' == str[i])
				++cnt0;
			else if ('1' == str[i])
				++cnt1;
		if (k - cnt0 - cnt1 <= cnt0 && k - cnt0 - cnt1 <= cnt1)
		{
			int v1 = 0, v2 = 0;        //  最少的是 ? 
			for (int i = 0; i < k; ++i)
			{
				v1 <<= 1; v2 <<= 1;
				if ('?' == str[i])
					v2 |= 1;
				else if ('1' == str[i])
					v1 |= 1;
			}
			int ans = val[v1];
			for (int s = v2; s; s = (s - 1) & v2)
				ans += val[s | v1];    //  直接统计 
			cout << ans << endl;
		}
		else if (cnt1 <= cnt0)
		{
			int v1 = 0, v2 = 0;      //  最少的是 1 
			for (int i = 0; i < k; ++i)
			{
				v1 <<= 1; v2 <<= 1;
				if ('?' == str[i])
					v1 |= 1;
				else if ('1' == str[i]) 
					v2 |= 1;
			}
			int c = __builtin_popcount(v2), ans = s1[v1] * f(c);
			for (int s = v2; s; s = (s - 1) & v2)
				ans += s1[s | v1] * f(c - __builtin_popcount(s));  // 容斥原理
			cout << ans << endl;
		}
		else
		{
			int v1 = 0, v2 = 0;     // 最少的是 0 
			for (int i = 0; i < k; ++i)
			{
				v1 <<= 1; v2 <<= 1;
				if ('0' == str[i])
					v2 |= 1;
				else if ('1' == str[i])
					v1 |= 1;
			}
			int ans = s2[v1];
			for (int s = v2; s; s = (s - 1) & v2)
				ans += s2[s | v1] * f(__builtin_popcount(s));  //  容斥原理 
			cout << ans << endl;
		}
	}
	
	return 0;
}
```

---

## 作者：Priestess_SLG (赞：0)

黑色的双倍经验！[P7670](https://www.luogu.com.cn/problem/P7670) 

前置定义：$k_0$ 表示 $0$ 的数量，$k_1$ 表示 $1$ 的数量，$k_?$ 表示 $?$ 的数量。

前置知识：数据点分治，快速沃尔什变换（FWT）。

首先考虑一个非常 trival 的暴力，对于每一个 `?` 字符，将其暴力替换为 `0` 和 `1` 然后判断答案。因此获得了一个 $O(Q2^{k_?})$ 的暴力。

然后考虑其的一个子问题：若字符串中只含有 `0` 字符和 `?` 字符，那怎么做？考虑将该状态用二进制数表示，`0` 字符所对应的位置固定，`?` 字符可以对应 $0/1$。因此问题转化为给定固定集合求其子集的和，这个东西可以使用 FWT 来解决。`1` 和 `?` 也同理。

如果字符串中同时含有 `0`，`1`，`?` 呢？考虑容斥，将所有的 `1` 转化为 `?`，然后问题转化为 `0` 和 `?` 的部分，可以用 FWT 解决。但是这样显然算多了，`1` 的部分已经固定，不能用 $0$ 来代替。因此暴力容斥掉 $0$ 的部分即可，获得了一个 $O(Q2^{k_1})$ 的暴力。

同样的，考虑将 `0` 转化为 `?`，然后 FWT 套容斥，此时获得了一个 $O(Q2^{k_0})$ 的暴力。

但是问题是这三个暴力都可以被卡掉！因此考虑将她们数据点分，每一次找到其中期望跑的最快的一个跑，即比较 $k_0,k_1,k_?$ 中最小的元素然后跑暴力。这样就可以在 $O(n2^n+Q2^{\min(k_0,k_1,k_?)})$ 的时间复杂度内十分暴力的过题啦。代码很好写就不放了。

---


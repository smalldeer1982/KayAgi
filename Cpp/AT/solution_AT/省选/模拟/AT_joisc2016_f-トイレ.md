# トイレ

## 题目描述

JOI会场附近有两个厕所，一个是女性专用的，另外一个是男女混用的。女性可以用两种厕所，但是男性只能用男女混用的。   
比赛结束后，有$2N$个选手排成一列上厕所。排队的人有男的和女的。他们将按照下列规则排队上厕所。

- 如果当前是一个女生在队头，那么选择空的那个厕所进入。若两边都是空的，优先进入女性专用厕所。

- 如果当前是一个男生在队头，他会遵守以下规则。

	- 如果男女公用厕所是空的，他就会去男女共用的厕所。
    
   - 如果男女公用厕所不是空的但是女性专用厕所是空的，他会请队伍里面最前面的一个女生去女性专用厕所。
   
所有的选手都会用1分钟上厕所。你可以忽略选手出入厕所的时间。   
但是这样可能不会在$N$分钟之内上完厕所，于是我们希望能够改变选手排队的次序，进而保证所有选手能在$N$分钟之内上完厕所。   
排完次序之后，我们定义一个选手的不满度。

- 一个选手的不满度定义为排序之前在这个选手的后面但是排序后在该选手的前面的人数。

不满度与排队时进入厕所次序无关。

我们希望能够适当地排序后使得所有人能在$N$分钟之内上完厕所，并且不满度最小。

我们给定$2N$个选手的初始排队顺序，确定是否能够在$N$分钟内上完厕所。如果可以的话，写出一个程序，找到选手的不满度的最小值。

## 说明/提示

输入数据满足以下数据。

- $1 \leq N \leq 10^{18}$。

- $1 \leq M \leq 100000$。

- $1 \leq K_i \leq 2N (1 \leq i \leq M)$。

- $1 \leq |S_i| \leq 2N (1 \leq i \leq M)$，其中$|S_i|$代表$S_i$的长度。

- $S_i (1 \leq i \leq M)$的所有字符都是`M`或者`F`。

- 通过$K_i$和$S_i$构造的字符串$X$，满足$X$长度为$2N$。

## 任务

#### 子任务1[14分]

满足以下条件。

- $N \leq 10$。

- $M=1$。

- $K_i=1$。

#### 子任务2[22分]

满足以下条件。

- $N \leq 100000$。

- $M=1$。

- $K_i=1$。

#### 子任务3[64分]

没有追加条件。

## 测试样例

#### 输入1

```
6
1
FFFMMMMMMFFF 1
```

#### 输出1

```
2
```

重排序列之后为`FMMFFMMMMFFF`。

#### 输入2

```
6
1
MMFFMMMMFFMF 1

```

#### 输出2

```
-1
```

无论如何排序都无法完成在$N$分钟之内完成。

#### 输入3

```
6
1
MFFFMFMMFFFM 1
```

#### 输出3

```
0
```

#### 输出4

```
6
4
M 1
F 2
FM 2
MFFFM 1
```

#### 输出4

```
0
```

输入样例3和4构造的字符串$X$是一样的，重排序列之后为`MFFFMFMMFFFM`。

# 题解

## 作者：ZnPdCo (赞：0)

采用 [loj](https://loj.ac/p/2734) 题面，更有趣。

首先容易观察到因为是 $2N$ 个人，$2$ 个发放点，$N$ 的时间限制，所以每时每刻每个点都必须有人。也就是不能有发放点空着。

如果队首是女装大佬的话，她肯定不会等的，因为只要空了**就可以进**。如果是正常男生的话，**如果进不了**，就会让给后面的**女装大佬来进**，但是如果后面没有女装大佬，那就女生位置就空了。所以没办法了，~~这个正常男生只能变成女装大佬了。~~

就是我们把正常男生看成 $-1$，**女装大佬是** $\bf{1}$，每个后缀的和不能为 $-2$，不然就会出现两个正常男生选择一个变成女装大佬。

这时候如果你强硬地去维护，也是可以做出来的，但是不够优美。考虑一种优美的实现方法。

对于一个后缀如果和为 $-2$ 了，我们需要将后缀最前面的正常男生移动到一个女装大佬**正前面**，如果两个移动：$a\larr b$，$c\larr d$ 满足一个包含另一个，那么中间的元素会产生 $2$ 的贡献。也就是说我们的移动嵌套最大数量就是答案。另一方面，也就是设最小的后缀和为 $-k$，答案就是 $k-1$，为什么要减一，因为后缀和为 $-1$ 就行了。

当然你可能发现还有一种移动方法就是女装大佬移动到正常男生前面，那这样代价就和移动距离有关，发现因为前者的代价是嵌套层数，这个数是小于等于距离的，所以这么做肯定不优。

关于 $-1$ 的判法，要求女装大佬数量不比正常男生少，不然肯定有男生要变女装大佬。

```cpp
#include <bits/stdc++.h>
#define N 100010
#define ll long long
using namespace std;
ll n, m, k[N], z[N], ans = -1, pre;
string s[N];
int main() {
    z['M'] = -1, z['t'] = 0, z['F'] = 1;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> s[i] >> k[i], reverse(s[i].begin(), s[i].end());
    for (int i = m; i >= 1; i--) {
        ll sum = 0, mn = 0;
        for (char c : s[i]) sum += z[c], mn = min(mn, sum);
        if (sum < 0) {
            pre += sum * (k[i] - 1);
            ans = min(ans, pre + mn);
            pre += sum;
        } else {
            ans = min(ans, pre + mn);
            pre += sum * k[i];
        }
    }
    cout << ((pre < 0) ? -1 : (-ans - 1)) << endl;
}
```

---

## 作者：pomelo_nene (赞：0)

$\ \ \ \ \ \ $重题同P3615

$\ \ \ \ \ \ $[原题面戳我](https://www.ioi-jp.org/camp/2016/2016-sp-tasks/2016-sp-d2.pdf)

---

$\ \ \ \ \ \ $因为这道题我们的序列是复读给出来的，所以很长，不会想到把序列还原。

$\ \ \ \ \ \ $考虑我们的时间和我们的人，因为有$2n$个人只有$n$分钟，所以每时每刻厕所必须有人蹲坑。

$\ \ \ \ \ \ $于是乎，我们可以倒推回去，我们就能够想到后缀和，把男生设为$1$，女生设为$-1$，进行一次后缀和。   
$\ \ \ \ \ \ $我们惊奇地发现如果我们的后缀和在某一时刻发生了值是大于等于$2$，那么只有两个男生考虑一起上了，这时直接输出$-1$。

$\ \ \ \ \ \ $这么说，我们能够发现我们要让队列合法，当且仅当$i \in [1,n]$，从后往前的第$i$个女生在从后往前的$2i$个位置及以外。

$\ \ \ \ \ \ $然后考虑计算我们的答案。我们还是选择倒推。当前如果我们遇到一个女生在从后往前的第$i$个位置，我们发现把她移到从后往前第$2i$个位置是最优的（因为没人站她的位置，并且如果更远，答案越大），我们就可以$\Theta(n)$计算答案

$\ \ \ \ \ \ $正如kkk所说的

>我们可以画一个折线图，记录后缀和曲线（请读者自备纸笔），从后往前。我们可以发现，每将一个男的移动到前面去，折线图就会整体往上面移动1。所以说，我们只要计算整个序列中后缀和最小值是多少。每一个小段都可以算出后缀和的贡献，然后我们就$\Theta(M+\sum^n_{i=1} (S_i))$可以求出这个值，假设是$-k$。那么最终答案就是$k-1$。

$\ \ \ \ \ \ $于此，我们将从后往前数的第$i$个女生匹配在第$2i$个位置，当前处理的长度为$a$的，其中女生有$b$个的话，对于每次$repeat$，我们匹配的位置也会相对移动$2b-a$

$\ \ \ \ \ \ $我们只需要计算最大不满值，如果$2b-a>0$考虑第一次$repeat$，否则考虑最后一次

$\ \ \ \ \ \ $时间复杂度$\Theta(m+\sum_{i=1}^n)$，至此我们的题目完美解决

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<iostream>
#include<cstring>
using namespace std;
string p;
long long bak[100005],mbak[100005],cnt=1,k[100005];
int main(){
	long long n,m;
	cin>>n>>m;
	long long check=0;
	for(long long i=1;i<=m;++i)
	{
		cin>>p>>k[i];
		for(long long j=p.length()-1;~j;--j)
		{
			if(p[j]=='F')	--bak[i];
			else	++bak[i];
			mbak[i]=max(mbak[i],bak[i]);
		}
		check+=bak[i]*k[i];
	}
	if(check>0)
	{
		cout<<-1<<endl;
		return 0;
	}
	long long ans=1,calc=0;
	for(long long i=m;i>=1;--i)
	{
		if(bak[i]>0)	ans=max(ans,calc+(k[i]-1)*bak[i]+mbak[i]);
		else	ans=max(ans,calc+mbak[i]);
		calc+=bak[i]*k[i];
	}
	cout<<ans-1<<endl;
	return 0;
}
```

---


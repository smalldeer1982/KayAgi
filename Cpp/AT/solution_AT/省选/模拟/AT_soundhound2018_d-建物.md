# 建物

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018/tasks/soundhound2018_d

kenkooooさんはSoundHound社で働いています。建物は $ H $ 階建てで、$ 1 $ つのフロアは $ W $ 個の東西に直線上につながった部屋からなります。上から $ i $ 番目の階の、西から $ j $ 番目の部屋を部屋 $ (i,j) $ と呼ぶことにします。

いま、kenkooooさんは部屋 $ (1,1) $ にいます。kenkooooさんは以下の動作を繰り返すことで、地上階(上から $ H $ 番目の階)の部屋から建物を出ることにしました:

- 部屋 $ (i,j) $ にいるとき、存在するなら部屋 $ (i,j-1) $に移動する。
- 部屋 $ (i,j) $ にいるとき、存在するなら部屋 $ (i,j+1) $に移動する。
- 部屋 $ (i,j) $ にいるとき、存在するなら部屋 $ (i+1,j) $に移動する。

ただし、地上階にたどり着いてからも移動をしてもかまいません。

さらに、部屋 $ (i,j) $ には $ P_{i,j} $ 円が落ちており、その部屋に初めて入るときkenkooooさんはこれを拾います。

一方で、部屋 $ (i,j) $ に入るたびに、入室料として $ F_{i,j} $ 円を払う必要があります。

kenkooooさんはすでに十分大きい金額を今持っているため、途中で手持ちのお金がなくなってしまうことはありません。部屋 $ (H,j) $ から建物を出るとき、この建物で最大いくら得ることができるかをすべての $ 1≦j≦W $ について求めてください。

## 说明/提示

### 制約

- $ 2≦H≦10 $
- $ 1≦W≦5×10^4 $
- $ 0≦P_{i,j}\ <\ 10^5 $
- $ 0≦F_{i,j}\ <\ 10^5 $

### Sample Explanation 1

例えば、部屋 $ (2,1) $ にたどり着くには、$ (1,1),(1,2),(1,3),(1,2),(2,2),(2,1) $ の順に訪れることで、$ 2+1+3+3 $ 円を手にしつつ、$ 2+2+5 $ 円を払うことで合計 $ 0 $ 円の利益を得ることができます。

### Sample Explanation 2

部屋 $ (1,1) $ でも入室料を取られること、地上にたどり着いた後も動いてよいこと、最終的な利益が負になることもあることに注意してください。

## 样例 #1

### 输入

```
2 4
2 1 3 0
0 3 0 3
0 2 0 0
5 0 5 0```

### 输出

```
0
5
2
7```

## 样例 #2

### 输入

```
2 4
2 0 3 5
1 3 1 3
1 3 2 1
0 0 0 10```

### 输出

```
6
6
6
-1```

## 样例 #3

### 输入

```
3 4
1 2 3 4
4 3 2 1
2 4 3 1
1 4 2 3
3 4 1 2
4 1 3 2```

### 输出

```
2
4
3
2```

# 题解

## 作者：Miss_SGT (赞：1)

递推题不知道为什么能有紫。

考虑 dp，设 $f_{i,j}$ 为走到位置 $(i,j)$ 最多能有多少钱，不同层间转移简单，问题在同层的。

一层楼里的移动可以用四个关键点描述： $l \le u ,v \le r$，分别表示到过的最小位置，入点，出点，最大位置。假设 $u \le v$，反之一样。这样最小的贡献一定是：

 $$ (P_l - F_l) + \sum_{i=l+1}^{u} (P_i - 2 F_i) + 
 \sum_{i=u+1}^{v-1} (P_i - F_i)
 + \sum_{i=v}^{r-1} (P_i - 2F_i) +(P_r -F_r)
 $$

分别记 $pre_{j,0/1}$ 为前 $j$ 个是否存在 $u$ 的最大答案，$suf_{j,0/1}$ 为后 $j$ 个是否存在 $u$ 的最大答案,转移不难。

最后枚举 $v$，分讨 $u$ 在那边就行了。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int m,n,a[11][N],b[11][N];
long long f[11][N],pre[N][2],suf[N][2];
int main(){
	read(m),read(n);
	for(int i=1;i<=m;++i)
	for(int j=1;j<=n;++j) read(a[i][j]);
	for(int i=1;i<=m;++i)
	for(int j=1;j<=n;++j) read(b[i][j]);
	memset(f[0],-0x3f,sizeof(f[0]));
	pre[0][1]=suf[n+1][1]=-1e16;
	f[0][1]=0;
	for(int j=1;j<=m;++j){
		for(int i=1;i<=n;++i){
			pre[i][0]=max(max(pre[i-1][0]-b[j][i],0ll)+a[j][i]-b[j][i],0ll);
			pre[i][1]=max(pre[i-1][1],max(pre[i-1][0]-b[j][i],0ll)+f[j-1][i])+a[j][i]-b[j][i];
		}
		for(int i=n;i;--i){
			suf[i][0]=max(max(suf[i+1][0]-b[j][i],0ll)+a[j][i]-b[j][i],0ll);
			suf[i][1]=max(suf[i+1][1],max(suf[i+1][0]-b[j][i],0ll)+f[j-1][i])+a[j][i]-b[j][i];
		}
		for(int i=1;i<=n;++i) f[j][i]=max(pre[i][1]+max(suf[i+1][0]-b[j][i],0ll),max(pre[i-1][0]-b[j][i],0ll)+suf[i][1]);
	}
	for(int i=1;i<=n;++i) print(f[m][i]),pc('\n');
	flush();
	return 0;
}


```

---


# ReTravel

## 题目描述

在 $xy$ 平面上的原点处，有一个机器人。你需要操控这个机器人按顺序访问编号为 $1, 2, \dots, N$ 的 $N$ 个点。第 $i$ 个点的坐标是 $(X_i, Y_i)$，其中 $1 \le i \le N$。

机器人初始位于原点，并带有一个空白字符串变量 $S$。你可以用以下四种操作来引导机器人的移动：

1. 将机器人的 $x$ 坐标增加 $1$，同时在字符串 $S$ 的末尾添加字符 `X`。这个操作的代价为 $1$。
2. 将机器人的 $y$ 坐标增加 $1$，同时在字符串 $S$ 的末尾添加字符 `Y`。这个操作的代价为 $1$。
3. 如果 $S$ 的末尾是 `X`，你可以减少机器人的 $x$ 坐标 $1$，并从 $S$ 中删除末尾的 `X`。这个操作无需任何代价。
4. 如果 $S$ 的末尾是 `Y`，你可以减少机器人的 $y$ 坐标 $1$，并从 $S$ 删除末尾的 `Y`。这个操作同样没有代价。

你需要计算机器人按顺序访问所有点 $1, 2, \ldots, N$ 所需的最小代价。这代价是指机器人在移动过程中，执行操作 $1$ 和操作 $2$ 的次数总和。

## 样例 #1

### 输入

```
2
3 3
1 2```

### 输出

```
6```

## 样例 #2

### 输入

```
3
2 2
3 3
1 3```

### 输出

```
7```

# 题解

## 作者：伊地知虹夏 (赞：1)

## [ReTravel](https://www.luogu.com.cn/problem/AT_ttpc2024_1_e)

### Description

二维平面上有 $n$ 个点 $(x_i,y_i)$，你要从 $(0,0)$ 出发，按顺序访问所有点。

你可以花 $1$ 代价向 上/右 走一步，或花 $0$ 的代价撤销上一个操作，求最小代价。

$1\le n \le 500$。

### Analysis

考虑按顺序走给出了一个什么提示，实际上是告诉我们可以将访问的点分成很多个区间去走。我们考虑区间 dp，设 $f_{l,r}$ 表示区间 $[l,r]$ 走完的最小代价，可是这样不知道出发点，无法转移。但由于我们只需考虑 $[l,r]$ 的点，将出发点设为 $(\min\limits_{i=l}^{r} x_i, \min\limits_{i=l}^{r} y_i)$ 即可转移，具体转移方程见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define rep(i,l,r) for(int i = l; i <= r; i ++)
#define rrp(i,l,r) for(int i = l; i >= r; i --)
const int N = 505;
int n, a[N], b[N], x[N][N], y[N][N];
LL f[N][N];
signed main() {
  cin.tie(0)->ios::sync_with_stdio(0);
  cin >> n, ++ n;
  rep (i, 2, n) cin >> a[i] >> b[i];
  rep (l, 1, n) {
    x[l][l] = a[l], y[l][l] = b[l];
    rep (r, l + 1, n) {
      x[l][r] = min(x[l][r-1], a[r]);
      y[l][r] = min(y[l][r-1], b[r]);
    }
  }
  rrp (l, n, 1) rep(r, l + 1, n) {
    f[l][r] = 1e18;
    rep (i, l, r - 1) f[l][r] = min(f[l][r], f[l][i] + f[i+1][r] +
    x[l][i] + x[i+1][r] + y[l][i] + y[i+1][r] - 2 * (x[l][r] + y[l][r]));
  }
  cout << f[1][n];
  return 0;
}
```

---

## 作者：lalaouye (赞：1)

好题。

先想性质发现想不出来，只好从做法考虑，结合数据范围和题意不难想到区间 dp，有个很蠢的方法是设 $f_{l,r}$ 表示从 $l$ 出发回溯最多回到 $l$ 一直走到 $r$ 的最小代价，发现这根本转移不了，不过我们不难发现整个过程长得是一棵树的形式，要经过所有 $l$ 到 $r$ 的点，考虑找到它们的子树根，而根的位置的 $x,y$ 坐标分别为区间内所有点的 $x$ 坐标的最小值，区间内所有点的 $y$ 坐标的最小值，容易证明这是最优的。

于是我们跑一个很简单的 dp 就行了。

[代码](https://atcoder.jp/contests/ttpc2024_2/submissions/62400774)，时间复杂度 $\mathcal{O}(n^3)$。

---


# Triangular Lamps Easy

## 题目描述

[problemUrl]: https://atcoder.jp/contests/wtf19/tasks/wtf19_c1

以下のような、無限に広がる三角グリッドがあります。 座標がともに整数であるような点のそれぞれには、ランプがひとつ設置されています。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_wtf19_c1/49b2130f65c1769a41dbab659975767a4d56bcfb.png)

はじめ、$ (X,\ 0) $ のランプのみが点灯しており、その他のランプはすべて消灯していました。 この状態から、すぬけ君が次の操作を $ 0 $ 回以上行いました。

- $ 2 $ つの整数 $ x,\ y $ を選ぶ。 $ 3 $ つのランプ $ (x,\ y),\ (x,\ y+1),\ (x+1,\ y) $ の状態を切り替える (点灯していれば消灯させ、消灯していれば点灯させる)。

この操作のあと、$ N $ 個のランプ $ (x_1,\ y_1),\ \cdots,\ (x_N,\ y_N) $ が点灯しており、その他のランプはすべて消灯していました。 $ X $ を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ -10^{17}\ \leq\ x_i,\ y_i\ \leq\ 10^{17} $
- $ (x_i,\ y_i) $ は互いに異なる。
- 入力は問題文と矛盾せず、$ X $ は一意に定まる。

### Sample Explanation 1

行われた操作の列として考えられるものをひとつ、以下の画像に示します。 !\[\](https://img.atcoder.jp/wtf19/cff6dc4d81e995e9300ccbaca5bf85de.png)

## 样例 #1

### 输入

```
4
-2 1
-2 2
0 1
1 0```

### 输出

```
-1```

# 题解

## 作者：Last_Flame (赞：6)

我们考虑把所有的亮灯通过几次操作放到同一行。

这显然是可行的，对于当前最高一行的灯，我们让它位于操作三角形的上面的点，那么它就会熄灭，换下面的灯状态变化。一定可以通过某种操作使得所有亮的灯位于同一行。

那么对于同一行的亮灯序列，一定是可以通过最初始亮的那盏灯通过操作变换而来，我们看看这种变换有什么特点。

（为了方便，用平面直角坐标系表示）

![模 2 意义下的杨辉三角](https://cdn.luogu.com.cn/upload/image_hosting/piawh914.png)

如果初始亮的灯为最左上角的，那么变换到下面每一行就会分别变成这些样子。

这种三角形可能有一个专有名词描述，但是我不知道。总之，我们可以发现如果一个位置与初始亮灯位置的 $\Delta x$ 和 $\Delta y$，有 $\Delta x \oplus \Delta y \operatorname{and} \Delta x=0$，且这个位置位于初始位置左下，那么这个位置会被点亮，否则不会。

然后对于所有与初始亮灯位置的 $\Delta y =2^{k}-1$ 的所有可以被点亮的位置一定是连续的，这个手玩容易知道。

那么显然位置 $(10^{17},-2^{60}+1)$ 是会被点亮的，我们可以直接对于 $y=-2^{60}+1$ 的点进行二分，其中可以被点亮的位置中最小的 $x$ 即为答案。

总复杂度 $O(n \log V)$。

---

```cpp
/*
我们可以得到一点可以覆盖另一个点的充要条件
设 x,y 为它们 x,y 的差，如果 x<=y 且 (x^y)&x >0 那么无法覆盖，否则可以覆盖
如果一个位置被覆盖奇数次，那么就是被点亮的
我们考虑选择距离 y=0 为 2^k-1 的高度，这个高度下被点亮的灯一定是连续的，我们直接选择最低的位置
我们钦定 k=60，由于给定的点都在 +-1e17 的范围内，那么 (1e17,-2^60+1) 一定被点亮，我们可以二分最小的 x，满足 (x,-2^60+1) 被点亮，答案即 (x,0)
*/
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mn=114514;
int n;
ll n2[65];
ll ans;

struct point{
    ll x,y;
}pot[mn];

bool cmp(point a,point b){
    return a.x<b.x;
}

int getnum(ll x){
    int num=0;
    ll dx=0,dy=0;
    for(int i=1;i<=n && pot[i].x<=x;i++){
        dx=x-pot[i].x,dy=pot[i].y-(-n2[60]+1);
        if(!((dx^dy)&dx)) num++;
    }
    return num;
}

int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>pot[i].x>>pot[i].y;
    sort(pot+1,pot+n+1,cmp);
    n2[0]=1;
    for(int i=1;i<=61;i++) n2[i]=n2[i-1]<<1;

    ll s=-1e17,e=1e17,mid=0;
    while(s<=e){
        mid=(s+e)>>1;
        int pget=getnum(mid);
        if(pget&1) e=mid-1;
        else s=mid+1;
    }
    ans=s;

    cout<<ans<<'\n';

    return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

考虑找一个操作的不变量。

考虑这样一个流程：从上到下考虑每一个节点，如果它是亮着的，就将其下传。最后在纵坐标取到 $- \infty$（注意这里实际上是一个常数）会得到唯一的开/关状态，对应到原来的 $(x,0)$ 上即可。

显然一个点 $(0,0)$ 对 $(x,-y)$ 的贡献为 $\binom{y}{x}$ 次。根据 Kummer 定理，它 $\bmod 2$ 为 $1$ 等价于 $x \subseteq y$（表示二进制下的包含关系）。

考虑令 $- \infty$ 为 $-2^N+1$，这样 $x \subseteq y$ 对于所有 $0 \le x \le y$ 都成立。这样 $(x,0)$ 对 $y = -\infty$ 上的点的贡献是一段连续的区间，且最左端点的横坐标就是 $x$。

取 $N$ 充分大，就可以直接在 $x$ 的值域里面二分。

代码非常好写，懒得放了。。

---

## 作者：R_shuffle (赞：0)

考虑怎么通过一个比较统一的方式把所有点给变的整齐一点，显然最好我们是希望能把所有的点给操作到 $x$ 轴上，这样显然我们就可以得到答案。从 $x$ 上方的点操作到 $x$ 轴是非常容易的，我们直接每次以一个点为三角形的上顶点操作即可，但是从 $x$ 下方的点操作则不容易，因为不存在一种统一的无后效性的操作方式。

但是我们发现从上往下操作是容易的，所以不妨把所有点都给操作到一个与 $x$ 轴平行且极为靠下的直线上。由于本题的操作是显然具有交换律且可逆的，所以由 $x$ 轴上的一个点能操作出来的局面，我们用题目中给出的点同样可以操作出来。那么问题就在于一个点向下能操作出哪些局面，不妨手推一下，可以发现对于所有纵坐标为 $1-2^k$ 的行，如果我们让所有的点都在这一行，那么会形成一段连续的，长度为 $2^k$ 的点段。所以我们不妨选取一个极端的，直接把所有的点都操作到 $1-2^{60}$，刚好在所有的点的下方。然后求出把所有点都操作到这一行之后的最靠左的点的横坐标即可。

具体的，求最左边的坐标是不好求的，因为我们不能真的去操作。考虑二分，二分出最左边的横坐标，然后判断。在上面的手推的时候，我们发现若一个点与初始亮灯位置的横纵坐标差分别为 $\Delta x,\Delta y$，那么若可以只从初始亮灯位置开始向下推到这个点，则有 $(\Delta x  \operatorname{xor}\Delta y)\operatorname{and}\Delta x=0$。所以假设我们需要判断 $(x,1-2^{60})$ 这个点，只需要求有多少个在 $(x,1-2^{60})$ 的左上方的点与这个点的横纵坐标差满足这个条件，再判断一下点数的奇偶即可。

代码非常简单，就不放了。

---


# [ARC170E] BDFS

## 题目描述

给定整数 $N, P$。

有一个 $N$ 个顶点 $N$ 条边的图，顶点编号为 $1$ 到 $N$。第 $i$ 条边连接顶点 $i$ 和顶点 $i+1$，是双向的。这里顶点 $N+1$ 代表顶点 $1$。

请执行以下算法，得到一个长度为 $N$ 的数列 $D=(D_1, D_2, \ldots, D_N)$。

- 令长度为 $N$ 的整数列 $D = (D_1, \ldots, D_N) = (-1, \ldots, -1)$。同时，令数对序列 $Q = ((1, 0))$。只要 $Q$ 非空，重复以下操作：

  - 取出 $Q$ 的首元素 $(v, d)$，并将其从 $Q$ 中删除。
  - 如果 $D_v = -1$，则令 $D_v := d$，并对与顶点 $v$ 相邻且满足 $D_x = -1$ 的每个顶点 $x$，按顶点编号从小到大依次进行如下操作：
    1. 以概率 $\frac{P}{100}$，将 $(x, d+1)$ 加入 $Q$ 的**首部**。
    2. 若未将 $(x, d+1)$ 加入 $Q$ 的首部，则将其加入 $Q$ 的**尾部**。

最终得到的 $D$ 的所有元素之和的期望值，模 $998244353$ 后输出。

给定 $T$ 组测试数据，请分别输出每组的答案。

期望值 $\bmod\ 998244353$ 的定义：可以证明，所求期望值一定是有理数。在本题的约束下，若将其表示为最简分数 $\frac{P}{Q}$，则 $Q$ 保证不被 $998244353$ 整除。此时，唯一存在一个 $0$ 到 $998244352$ 之间的整数 $R$ 满足 $R \times Q \equiv P \pmod{998244353}$。请输出这个 $R$ 作为答案。

## 说明/提示

### 数据范围

- $1 \leq T \leq 10^4$
- $3 \leq N \leq 10^{18}$
- $1 \leq P \leq 99$
- 输入的所有数均为整数

### 样例解释 1

对于第 $1$ 组测试数据，算法的执行过程例如如下：

- 初始时，$D = (-1, -1, -1),\ Q = ((1, 0))$。取出 $Q$ 首元素 $(1, 0)$。
- 因为 $D_1 = -1$，令 $D_1 := 0$。与顶点 $1$ 相邻且 $D_x = -1$ 的顶点为 $2, 3$。
- 将 $(2, 1)$ 加入 $Q$ 首部，将 $(3, 1)$ 加入 $Q$ 尾部。此时 $Q = ((2, 1), (3, 1))$。
- 取出 $Q$ 首元素 $(2, 1)$。
- 因为 $D_2 = -1$，令 $D_2 := 1$。与顶点 $2$ 相邻且 $D_x = -1$ 的顶点为 $3$。
- 将 $(3, 2)$ 加入 $Q$ 首部。此时 $Q = ((3, 2), (3, 1))$。
- 取出 $Q$ 首元素 $(3, 2)$。
- 因为 $D_3 = -1$，令 $D_3 := 2$。与顶点 $3$ 相邻且 $D_x = -1$ 的顶点不存在，不做任何操作。
- 取出 $Q$ 首元素 $(3, 1)$。
- 因为 $D_3 = 2$，不做任何操作。
- $Q$ 为空，算法结束。

此时最终 $D = (0, 1, 2)$。上述过程发生的概率为 $\frac{1}{8}$，$D$ 的元素和的期望值为 $\frac{5}{2}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
3 50
4 1
1000000000000000000 70```

### 输出

```
499122179
595552585
760296751```

# 题解

## 作者：NobodyThere (赞：12)

~~本题难点：整理题意。事情是真的，我做题的大部分时间都在整理题意。~~

经过一番整理，你发现题目实际上在描述这样一件事：

> 有一个环，一开始的已到达元素构成区间 $[l,r]=[1,1]$，进行 $n-1$ 次操作，每次会基于概率执行 $l\gets l-1$ 或者 $r\gets r+1$（循环意义下，下同）。最后求元素 "bfs" 遍历深度和 $S$ 的期望值。设 $opt=\texttt L$ 为当前的“方向”。那么相当于有若干次这样的操作：
>
> 1. 有 $p$ 的概率使得 $opt$ 不变（对应放到队首的操作），剩下 $1-p$ 的概率使得 $opt$ 取反（对应放到队尾的操作，此时上次放到队尾的元素将变为队首，因为实际上队列 $Q$ 的长度最多为 $2$），即 $\texttt R$ 变成 $\texttt L$，$\texttt L$ 变成 $\texttt R$。
> 1. 若 $opt=\texttt L$，则左端点扩张（即执行 $l\gets l-1$），否则右端点扩张（即执行 $r\gets r+1$）。
> 1. $S$ 的变化量为该元素的遍历深度，即从 $1$ 开始沿 $opt$ 的方向到该元素的步数。

考虑 DP 转移，除了记录当前答案 $ans=\operatorname E(S)$ 外，为了方便转移，还要记录当前方向上的深度期望 $f_0$ 和另外一个方向上的深度期望 $f_1$。

那么显然有转移：

$$
\begin{aligned}
f_0'&=pf_0+(1-p)f_1+1,\\
f_1'&=(1-p)f_0+pf_1,\\
ans'&=pf_0+(1-p)f_1+1+ans.
\end{aligned}
$$

由期望的线性性可知转移正确。

矩阵快速幂优化转移即可，复杂度 $O(T\log n)$。~~实际上带矩阵乘法的 $k^3$ 常数，效率被推式子做法薄纱。~~

提交记录：<https://atcoder.jp/contests/arc170/submissions/50020715>。

---

## 作者：qiuzx (赞：3)

比官方题解略简单快速一点的方法。

## 题意

在一个长度为 $n$ 的环进行 bfs，初始在点 $1$，每次取出当前点相邻的所有未访问过的点，按编号大小顺序更新最短路，并依次加入队列，其中每个点有 $p$ 的概率加入队首，有 $1-p$ 的概率加入队尾。求所有点的距离之和的期望。$n\le 10^{18}$。

## 思路

分析一下这个 bfs 的过程，相当于是从 $1$ 开始，每次有一定概率向前拓展一个点，有一定概率向后拓展一个点。具体地，每个时刻的状态都可以表示为 $(x,y)$，表示 $[1,x]$ 和 $[y,n]$ 的点都已经被拓展过了。记从 $x$ 拓展 $x+1$ 这个操作为 `L`，从 $y$ 拓展 $y+1$ 这个操作为 `R`，则每一个 bfs 的过程都可以看作是由总共 $n-1$ 个 `L` 和 `R` 组成的序列，则问题转化为对于所有长度为 $n-1$ 的 `LR` 序列，计算其权值与其发生的概率。

先考虑对于一个固定的序列如何计算其权值与概率。显然若一个序列中有 $a$ 个 `L`，$b$ 个 `R`，那么其权值是 $\dfrac{a(a+1)}2+\dfrac{b(b+1)}2$，这是因为所有 `L` 涉及到的点距离依次为 $1,2,\cdots$，`R` 同理。而这个序列的概率就是每一步发生的概率的乘积。其中第一步是 `L` 的概率为 $1-p$，第一步是 `R` 的概率为 $p$，而在此之后，若前一个字符和当前字符相同，则概率为 $p$，否则概率为 $1-p$。这样就容易计算一个序列的概率了。

考虑原问题怎么做。利用期望的线性性，将权值拆成对于序列中每两个元素（可相同），它们对应的字符相等的概率之和。假设枚举位置 $x<y$ 相同，那么这两个位置相等的概率就 $x,y$ 中间的部分有偶数个位置与上一个不同的概率。所以相当于是这样一个问题，在一个长度为 $m$ 的序列中，每个元素要么取 $p$，要么取 $q$，求有偶数个 $q$ 的概率是多少，即 $\displaystyle\sum_{i=0}^{m}[i\bmod 2=0]\binom mi p^{m-i}q^i$。这是一个二项式定理的形式，构造函数 $f(x)=(p+qx)^m$，则 $\displaystyle [x^i]f(x)=\binom mip^{m-i}q^i$，那么就是要求 $\displaystyle\sum_{i=0}^m[i\bmod 2=0][x^i]f(x)$，这个等于 $\displaystyle\dfrac{f(1)+f(-1)}2$。而在这道题中，$f(x)=(p+(1-p)x)^m$，所以 $f(1)+f(-1)=1+(2p-1)^m$。

那么现在就要求这样一个式子：$\displaystyle\sum_{x=1}^{n-1}\sum_{y=x}^{n-1}1+(2p-1)^{y-x}=\sum_{m=0}^{n-2}(n-m-1)(1+(2p-1)^m)$，这里面的 $1$ 可以直接提出去算，然后令 $x=2p-1$，则需要计算 $\displaystyle\sum_{m=0}^{n-2}(n-m-1)x^m=(n-1)\sum_{m=0}^{n-2}x^m-\sum_{m=0}^{n-2}mx^m$，前者是等比数列求和，可以直接计算。后者把 $m$ 拆开，变成 $\displaystyle\sum_{i=1}^{n-2}\sum_{m=i}^{n-2}x^m=\sum_{i=1}^{n-2}\dfrac{x^i(x^{n-1-i}-1)}{x-1}=\dfrac{\sum_{i=1}^{n-2}x^{n-1}-x^i}{x-1}$，分母可以最后算，上面的分子前面的部分直接乘，后面的部分又是一个等比数列求和，同样可以直接计算。这样就做完了，复杂度 $O(\log n)$。

[代码](https://atcoder.jp/contests/arc170/submissions/49556815)

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/AT_arc170_e)

**题目大意**

> 在一个长度为 $n$ 的环进行 bfs，初始在点 $1$，每次取出当前点相邻的所有未访问过的点，按编号大小顺序更新最短路，并依次加入队列，其中每个点有 $p$ 的概率加入队首，有 $1−p$ 的概率加入队尾。求所有点的距离之和的期望。
>
> 数据范围：$n\le 10^{18}$。

**思路分析**

注意到任何时候队里只有两个元素，每次会更新队首元素的后继，然后以 $1-p$ 的概率交换队首队尾，进行这样的操作 $n-1$ 次。

那么可以 dp，设 $f_i/g_i$ 表示拓展 $i$ 步后队首或队尾元素距离的期望，答案就加上 $f_i+1$，更新就是 $f_{i+1}=p(f_i+1)+(1-p)g_i,g_{i+1}=(1-p)(f_i+1)+pg_i$。

不难用一个 $4\times 4$ 的矩阵描述 $f_i,g_i,1,ans$ 的转移，矩阵快速幂优化 dp 即可。

时间复杂度 $\mathcal O(\delta^3\log n)$，其中 $\delta=4$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
typedef array<array<ll,4>,4> Mat;
const int MOD=998244353,inv=828542813;
inline Mat operator *(const Mat &u,const Mat &v) {
	Mat w; w.fill({0,0,0,0});
	for(int i:{0,1,2,3}) for(int k:{0,1,2,3}) if(u[i][k]) for(int j:{0,1,2,3}) {
		w[i][j]=(w[i][j]+u[i][k]*v[k][j])%MOD;
	}
	return w;
}
void solve() {
	ll n,p;
	scanf("%lld%lld",&n,&p),--n,p=inv*p%MOD;
	Mat I,X; //f g 1 ans
	I.fill({0,0,0,0}),X.fill({0,0,0,0});
	I[0][0]=p,I[0][1]=1+MOD-p,I[0][3]=1;
	I[1][0]=1+MOD-p,I[1][1]=p;
	I[2][0]=p,I[2][1]=1+MOD-p,I[2][2]=1,I[2][3]=1;
	I[3][3]=1,X[0][2]=1;
	for(;n;n>>=1,I=I*I) if(n&1) X=X*I;
	printf("%lld\n",X[0][3]);
}
signed main() {
	int T; scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：0x3F (赞：0)

令 $n\gets n-1$，$p\gets\frac{p}{100}$。

我们发现队列中最多只有两个元素。记 $dp_{i,j}$ 表示队首到 $1$ 的距离为 $i$，队尾到 $1$ 的距离为 $j$，出现过这种情况的概率。

则初始条件为 $dp_{0,0}=1$，转移为 $dp_{i+1,j}\gets pdp_{i,j}$，$dp_{j,i+1}\gets(1-p)dp_{i,j}$，答案为 $\sum_{i+j=n}\left(\frac{i(i+1)}{2}+\frac{j(j+1)}{2}\right)dp_{i,j}$。

记 $F=\sum_{i,j}x^iy^jdp_{i,j}$，$G=\sum_{i,j}x^jy^idp_{i,j}$，则有：

$$
\begin{cases}
F=1+x\left[pF+(1-p)G\right]
\\
G=1+y\left[pG+(1-p)F\right]
\end{cases}
$$

解得：

$$F=\frac{1+(1-p)x-py}{1-px-py+(2p-1)xy}$$

我们要求：

$$\sum_{i+j=n}\left(\frac{i(i+1)}{2}+\frac{j(j+1)}{2}\right)[x^iy^j]F$$

记 $H=xF_x+\frac{x^2}{2}F_{xx}+yF_y+\frac{y^2}{2}F_{yy}$，此处下标表示偏导，答案即为 $\sum_{i+j=n}[x^iy^j]H$。

计算可得：

$$H=\frac{-2p^{3}x^{3}y-2p^{3}xy^{3}+3p^{2}x^{3}y+3p^{2}x^{2}y+p^{2}xy^{3}+5p^{2}xy^{2}-px^{3}y-4px^{2}y-2pxy^{2}-5pxy+x^{2}y+2xy+x}{\left(2pxy-px-py-xy+1\right)^{3}}$$

可以令 $I(x)=H(x,x)$，则答案为 $[x^n]I$。

计算可得：

$$I=\frac{x-px^2}{1-(2p+2)x+6px^2-(6p-2)x^3+(2p-1)x^4}$$

直接矩阵快速幂计算即可。

时间复杂度为 $\mathcal{O}(\log n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
int mat[4][4], ans[4][4], tmp[4][4];
int main() {
    int T;
    cin >> T;
    while (T--) {
        long long n;
        int p;
        cin >> n >> p;
        n--;
        p = (long long) p * 828542813 % mod;
        memset(mat, 0, sizeof(mat));
        memset(ans, 0, sizeof(ans));
        mat[0][0] = (2LL * p + 2) % mod;
        mat[0][1] = (mod - 6LL * p % mod) % mod;
        mat[0][2] = (6LL * p + mod - 2) % mod;
        mat[0][3] = (1 + mod - 2LL * p % mod) % mod;
        mat[1][0] = 1;
        mat[2][1] = 1;
        mat[3][2] = 1;
        ans[0][0] = (2LL * p * p + 4) % mod;
        ans[1][0] = (p + 2) % mod;
        ans[2][0] = 1;
        ans[3][0] = 0;
        while (n) {
            if (n & 1) {
                memset(tmp, 0, sizeof(tmp));
                for (int i = 0; i <= 3; i++) {
                    for (int j = 0; j <= 3; j++) {
                        for (int k = 0; k <= 3; k++) {
                            tmp[i][j] = (tmp[i][j] + (long long) mat[i][k] * ans[k][j]) % mod;
                        }
                    }
                }
                memcpy(ans, tmp, sizeof(tmp));
            }
            memset(tmp, 0, sizeof(tmp));
            for (int i = 0; i <= 3; i++) {
                for (int j = 0; j <= 3; j++) {
                    for (int k = 0; k <= 3; k++) {
                        tmp[i][j] = (tmp[i][j] + (long long) mat[i][k] * mat[k][j]) % mod;
                    }
                }
            }
            memcpy(mat, tmp, sizeof(tmp));
            (n >>= 1);
        }
        cout << ans[3][0] << endl;
    }
    return 0;
}
```

upd：上面那个分式的分母可以因式分解，所以可以拆成部分分式，加上预处理一些东西（因为 $p$ 只有 $99$ 种），可以做到单次查询 $\mathcal{O}(1)$。

---


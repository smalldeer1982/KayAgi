# Segment Tree

## 题目描述

给你一个无向图 $G$，它包含 $2^N + 1$ 个顶点和 $2^{N+1} - 1$ 条边。顶点的编号分别是 $0, 1, \dots, 2^N$，边的编号为 $1, 2, \dots, 2^{N+1}-1$。

图中的边分为 $N+1$ 种类型，从类型 $0$ 到类型 $N$。第 $i$ 种类型（$0 \le i \le N$）的边总共有 $2^i$ 条，编号依次为 $2^i + 0, 2^i + 1, \dots, 2^i + (2^i - 1)$。编号为 $2^i + j$ 的边（$0 \le j \le 2^i - 1$）连接顶点 $j \times 2^{N-i}$ 和顶点 $(j + 1) \times 2^{N-i}$，边的长度为 $C_{2^i + j}$。

例如，当 $N = 3$ 时，图 $G$ 如下图所示。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_ttpc2024_1_c/eeee648dd769ea41d1a8e76adff12eede55a57c5.png)

你需要处理 $Q$ 个查询，查询分为两种类型：

- `1 j x`：将编号为 $j$ 的边的长度更新为 $x$。
- `2 s t`：询问从顶点 $s$ 到顶点 $t$ 的最短路径长度。

## 说明/提示

- 输入的所有数值均为整数。
- $1 \le N \le 18$
- $1 \le C_j \le 10^7$，$ (1\le j\le 2^{N+1}-1$）
- $1 \le Q \le 2 \times 10^5$
- 对于 `1 j x` 类型的查询，$1 \le j \le 2^{N+1}-1$ 且 $1 \le x \le 10^7$
- 对于 `2 s t` 类型的查询，$0 \le s < t \le 2^N$
- 至少存在一个 `2 s t` 类型的查询

### 部分得分

如果在不包含 `1 j x` 类型查询的数据集上正确解答，可以获得 $30$ 分。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3
7 1 14 3 9 4 8 2 6 5 5 13 8 2 3
10
2 0 1
2 0 4
2 4 6
2 4 8
2 3 5
1 6 30
2 3 5
2 4 6
1 1 10000000
2 0 8```

### 输出

```
2
1
4
8
17
18
13
15```

# 题解

## 作者：fydj (赞：2)

题目中给定的图是一颗满二叉树，既具有线段树的结构，又具有树状数组 lowbit 之类的性质，还有很好的分治结构。对于这样一种优美的结构，不应该思考一些分类讨论，而是要找到一种优美的解法。

这里优美的解法指缩小问题规模。先设 $w_i$ 表示从第 $i$ 条边的左端点每一次只能向右走走到右端点的最短距离，显然 $w_i=\min(c_i,w_{lson}+w_{rson})$。由于 $w$ 的性质，每步一定是能走大步就走大步。观察底层连接 $i$ 和 $i+1$ 的边，如果起点 $s$ 是奇数，它只会在第一步走底层的边，但是不知道是向右走还是向左走，就都尝试一下；如果起点 $s$ 是偶数，就不可能走底层的边；对于终点 $t$ 同理。这样，以后就不会用到底层的边，并且 $s,t$ 都是偶数，就可以删掉底层边并且把问题规模减半。

如果遇到奇数点需要走递归两侧，乍一看好像会爆炸，实际上可能到达的点并不多，可以用记忆化之类处理。为什么？如果起点 $s$ 是奇数，它会递归到 $\frac{s-1}{2},\frac{s+1}{2}$ 中，它们是相邻的整数，一奇一偶，假设 $\frac{s-1}{2}$ 是奇数，它会递归到 $\frac{s-3}{4},\frac{s+1}{4}$ 中，而 $\frac{s+1}{2}$ 会递归到 $\frac{s+1}{4}$ 中，有一个数出现了两次，不同的数只有两个，而且依然是相邻的，再递归也是如此。

对于询问，只会递归 $O(n)$ 层，所以单次是 $O(n)$ 的。对于修改，可以像线段树一样依次更新父亲的 $w$，也是单次 $O(n)$ 的。所以总的时间复杂度是 $O(2^n+qn)$。

---

## 作者：qczrz6v4nhp6u (赞：1)

一种与官解不同的做法。

不过吐槽一下，真的有人第一反应是从奇偶性考虑的吗？

### Solution

首先这是一个线段树状的结构，那我们必然要从分治的角度进行思考。直接上二区间分治的模板，维护区间内每个点到区间两端的最短路，这样可以做到无修改的 $O(n2^n+qn)$。

然后我们现在要修改了，这就导致我们无法维护太多的信息。感受一下发现可以维护 $w_p$ 表示只考虑 $p$ 子树内的边，从节点 $p$ 的左端点走到右端点的最短路，这样具有比较好的性质。不难据此设计出一个做法：

> 设 ${\rm query}(s,t,p)$ 只考虑节点 $p$ 子树内的边，从 $s$ 走到 $t$ 的最短路。同时设 $l,r$ 表示节点 $p$ 代表的边为 $l$ 连向 $r$，$m=\frac{l+r}{2}$。
>
> - 若 $t\le m$：
> 
>   此时询问的两个点都在左侧子树内，我们递归问出左子树中 $s\to t$、$s\to l$、$t\to m$ 的最短路，再更新 $s\to l\to r\to m\to t$ 形式的答案；
>
> - 否则，若 $s>m$：
> 
>   此时询问的两个点都在右侧子树内，我们递归问出右子树中 $s\to t$、$s\to m$、$t\to r$ 的最短路，再更新 $s\to m\to l\to r\to t$ 形式的答案；
>
> - 否则：
>
>   此时询问的两个点一个在左子树，一个在右子树。我们递归问出 $s\to l$、$s\to m$、$t\to m$、$t\to r$ 的最短路，再更新 $s\to m\to t$ 与 $s\to l\to r\to t$ 两种形式的答案。

不难发现这个做法的复杂度是很假的，一次递归有三个甚至四个分支。但是如果你有随手记忆化的好习惯的话就发现它直接过了，这是为什么呢？

尝试分析一下它的状态数。不难发现我们在递归中问到的 $s,t$ 都在 $p$ 的子树内，且 $s,t$ 中必定有一个等于最外层询问的 $s,t$。根据区间查询线段树的复杂度分析，这就是说我们只会问到线段树上的 $O(\log n)$ 个节点。同时，不等于最外层询问的 $s$ 或 $t$ 必定满足它是区间的两个端点之一，这样每个节点只会有常数种状态。于是直接记忆化即可做到单次查询 $O(n)$。

修改操作是容易维护的，直接从 $i$ 往上跳不断 pushup 即可。时间复杂度即为 $O(2^n+qn)$。

另外，我们也可以完全不记忆化：在递归过程中同时维护 $s\to l$、$s\to r$、$t\to l$、$t\to r$、$s\to t$ 的最短路，合并的时候分讨算一下即可。复杂度仍然是 $O(2^n+qn)$，但是代码常数小很多。

### Code

[记忆化](https://atcoder.jp/contests/ttpc2024_2/submissions/64944322)，[不记忆化](https://atcoder.jp/contests/ttpc2024_2/submissions/64945581)。

---


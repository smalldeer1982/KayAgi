# [ARC128D] Neq Neq

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc128/tasks/arc128_d

$ N $ 個のボールが一列に並べられており，左から順に $ 1 $ から $ N $ までの番号がついています． ボール $ i $ には整数 $ A_i $ が書かれています．

あなたは，以下の操作を好きなだけ繰り返すことができます．

- 連続して並んでいる $ 3 $ つのボール $ x,y,z $ ($ 1\ \leq\ x\ <\ y\ <\ z\ \leq\ N $) を選ぶ． ただしこの時，$ A_x\ \neq\ A_y $ かつ $ A_y\ \neq\ A_z $ を満たす必要がある． その後，ボール $ y $ を食べる． なお，この操作の後，ボール $ x $ とボール $ z $ は列の中で連続しているとみなす．

最終的に残っているボールの集合としてありうるものの個数を $ 998244353 $ で割った余りを求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 200000 $
- $ 1\ \leq\ A_i\ \leq\ N $
- 入力される値はすべて整数である

### Sample Explanation 1

最終的に残っているボールの集合として考えられるのは，$ \{1,2,3,4\},\{1,2,4\},\{1,3,4\} $ の $ 3 $ 通りです．

### Sample Explanation 2

異なる操作方法でも，最終的に残るボールの集合が同じであれば区別しません．

### Sample Explanation 3

残るボールに書かれた整数を並べた列が同じでも，ボールの集合が異なる場合は区別されます．

## 样例 #1

### 输入

```
4
1 2 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
5
5 4 3 2 1```

### 输出

```
8```

## 样例 #3

### 输入

```
5
1 2 3 2 1```

### 输出

```
8```

## 样例 #4

### 输入

```
9
1 4 2 2 9 6 9 6 6```

### 输出

```
14```

# 题解

## 作者：ZillionX (赞：6)

# Description

给定一个长度为 $n$ 的序列 $a$，可以做若干次操作：

- 选择三个连续的下标 $x,y,z$，若 $a_x \neq a_y, a_y \neq a_z$，则删去 $a_y$

问最终能形成多少种可能的序列。

$n \le 2 \times 10^5, a_i \le n$，时限 2s。

# Solution

经典的 ATC 风格计数问题，我们不妨先考虑做一个简单的 DP。

设 $f_i$ 表示前 $i$ 个数可能形成的序列个数。不难发现，我们可以枚举一段后缀 $[l,i]$，使 $(l,i)$ 全部被删去，然后就可以转移到子问题 $f_l$。

我们考虑如何判断一段区间是否能被删去。

观察一下可以发现这应该是存在简洁的充要条件的。

我们首先特殊处理 $i-j\le 2$ 的情况。然后一个比较显然的条件是 $[j,i]$ 中不存在相邻相等的数。

进一步可以发现若 $[i,j]$ 的种类数 $= 2$ 是无法被删除的，因为只要操作一次就必然会导出存在相邻相等的局面。

这时候好像找不到别的条件了。我们不妨证明一下对于更多种类的情况必然可以被删除。容易发现若种类数 $=3$ 时可行则其他都可行。转化为证明种类数 $=3$ 的情况。

我们可以找到连续三个互不相同的数 $(a,b,c)$，若删去 $b$ 后种类数仍不变则删去；若不满足的话，则以 $b$ 为端点将其他数依次删去，最后再删去 $b$ 本身即可。

虽然很不严谨，但是我们现在得到了一个看起来很靠谱的充要条件。回到 DP 部分，暴力做是 $\mathcal O(n^2)$ 的，可以维护两个单调右移的指针，维护相邻不等和元素种类 $>2$ 的条件，时间复杂度线性。

# Code

```cpp
const int N=2e5+5,mo=998244353;
int n,a[N],f[N],s[N],p[N];
int main() {
	scanf("%d",&n);
	int l=0,r=1,c=0;
	f[0]=1;
	for (int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		f[i]=f[i-1];
		if (a[i]==a[i-1]) l=i-1;
		if (i>2 && a[i]!=a[i-1] && a[i-1]!=a[i-2]) f[i]=(f[i]+f[i-2])%mo;
		if (!p[a[i]]) c++;
		p[a[i]]++;
		while (r<i-2 && c>=3) {
			p[a[r]]--;
			if (!p[a[r]]) c--;
			r++;
		}
		if (l<r) f[i]=(f[i]+(s[r-1]+(mo-s[l]))%mo)%mo;
		s[i]=(s[i-1]+f[i])%mo;
	}
	printf("%d",f[n]);
	return 0;
}
```


---

## 作者：EuphoricStar (赞：2)

考虑把所有 $a_i = a_{i+1}$ 的位置断开，分别计算然后把方案数乘起来。接下来的讨论假设 $a_i \ne a_{i+1}$。

考虑一个 dp，设 $f_i$ 为 $[1,i]$ 最后剩下的集合的方案数。转移显然是 $f_i \gets f_i + f_j$，但是需要满足 $(a_j, a_{j+1}, ..., a_i)$ 需要被删至只剩 $(a_j, a_i)$。

现在问题变成了如何判定 $(a_1, a_2, ..., a_m)$ 可以被删至只剩 $(a_1, a_m)$。

如果 $m \le 3$ 一定可行，下面假设 $m \ge 4$。

发现只要数组中不同数的个数 $\ge 3$ 即可。

考虑证明。如果不同数的个数 $\le 2$ 一定不可行，否则接下来找到 $a_{i-1}, a_i, a_{i+1}$ 使得它们两两互不相同，如果删去 $a_i$ 后不同数个数变成 $2$，那么数组形式一定是 $(x,y,...,x,y,a_i,x,y,...)$。此时删去 $a_{i-1}$ 或 $a_{i+1}$ 即可。否则删去 $a_i$。证毕。

知道了这个限制，可以双指针 + 前缀和简单维护。

时间复杂度 $O(n)$。

[code](https://atcoder.jp/contests/arc128/submissions/41140944)

---

## 作者：Phartial (赞：1)

不难考虑设 $f_i$ 表示现在处理了前 $i$ 个数，第 $i$ 个数必选得到的方案数。由于 $a_n$ 不可能被删掉（需要一个 $a_{n+1}$），所以答案即为 $f_n$。

对 $f_i$，我们考虑前一个被保留的数 $j$，问题转化成被 $i,j$ 夹住的一段连续的数可不可以全部删掉，分类讨论：

1. $j=i-1$：啥都没夹，当然能全删了。
2. 有两个相同颜色的数相邻：肯定不行，因为这两个数互相锁死了。
3. 相邻数互不相等：
   1. 有两种颜色：那么只可能形如 `b|abababab|a`，这种情况能够全删只可能是 `a|b|a`。因为只要中间那段长度大于 $1$ 后，随便删掉哪个数都会变成第二种情况。
   2. 有三种及以上颜色：那么最坏情况下也肯定形如 `a|babacabab|a`，我们单独把 `c` 拿出来，可以发现，我们只要以 `c` 为中心，不断地消除左边和右边的数即可。

我们现在就能判断一段数能不能被删了，现在只剩下一个问题：怎么快速寻找 $j$？

由于不能有两个相同颜色的数相邻，所以在扫描序列的过程中，只要出现了 $a_{i-1}=a_i$，那么之后的数就不能扫描到 $i-1$，因为扫到那里就会出现相邻同颜色，于是我们解决了这个问题。

至于判断颜色种数，你直接双指针不就完了。/cf/cf/cf。

```cpp
#include <atcoder/all>
#include <iostream>

using namespace std;
using LL = atcoder::modint998244353;

const int kN = 2e5 + 1;

int n, a[kN], c[kN], cc;
LL f[kN], s[kN];

void A(int x) { cc += !c[a[x]]++; }
void D(int x) { cc -= !--c[a[x]]; }

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
  }
  f[1] = s[1] = 1, A(1);
  for (int i = 2, p = 0, j = 1; i <= n; ++i) {
    f[i] += f[i - 1];
    if (i > 2 && a[i - 2] == a[i] && a[i - 1] != a[i]) {
      f[i] += f[i - 2];
    }
    A(i);
    if (a[i - 1] == a[i]) {
      p = i - 1;
      s[i] = s[i - 1] + f[i];
      continue;
    }
    for (; cc > 2; D(j++)) {
    }
    if (cc == 2 && j > p) {
      f[i] += s[j - 1] - s[p];
    }
    s[i] = s[i - 1] + f[i];
  }
  cout << f[n].val();
  return 0;
}
```


---

## 作者：shiruoyu114514 (赞：0)

结论题。

题意是问有多少种保留位置合法，于是想到令 $dp_i$ 为以 $i$ 作为最后一个保留位置的方案数，则转移方程形如 $dp_i = \sum dp_j\text{able}(i,j)$，其中 $\text{able}(i,j)$ 为对于 $a[i:j]$，仅保留 $a_i,a_j$ 是否合法。

现在的重头戏就是探寻 $\text{able}(i,j)$ 的性质。

显然 $j=i+1$ 时一定有解。除此之外当存在两个连续相等字母时无解。但是这是充要条件吗？可以轻易地想到 ``1010101`` 串，你找不出来一种方案。事实上，除了 ``101`` 字符串删中间就完了之后，一切恰好由两种字符串组成的串都是 ``1010101010`` 型，删掉一个位置之后就会出现相同相邻，无解。

但是这是充要条件吗？

>断言：当有至少 $3$ 种字符时，一定有解。
>
>证明：考虑随便选择一个 $i$ 使得 $a_{i-1},a_i,a_{i+1}$ 互不相等。如果 $a_i$ 只有一个数的话，直接不断删左邻居（一定合法，因为如果左邻居与左左邻居相等，那么违反“相邻数不等”。由于 $a_i$ 唯一，所以 $a_i$ 一定不等于左邻居）然后不断删右邻居，最后一定为 ``101``，直接删中间即可。
>
>否则删除 $a_i$ 即可转化为序列长度 $-1$ 的子问题。（不需要专门注意单一颜色，把其削到 $1$ 次之后再转化为前述情况）。

观察到如果 $[j,i]$ 违背“相邻不等，那么 $[j-1,i]$ 违背相邻不等。如果 $[j,i]$ 种类数至少为 $3$，那么 $[j-1,i]$ 种类数至少为 $3$。所以满足相邻不等，并且种类数至少为 $3$ 的 $j$ 是一个区间，可以前缀和区间求和。对于 $j-1$ 以及 $j-2$ 带来的 ``101`` 单独处理即可。双指针即可处理出 $j$ 所在的区间。前缀和即可。

时间复杂度 $O(n)$。

---

## 作者：under_the_time (赞：0)

## 题意

> 给定一个长度为 $n$ 的序列 $a$，每次操作可以选择一段长度为 $3$ 的子区间，满足左右的两个元素均与中间的元素不等（两端允许相等），然后删除中间的元素。求进行 $0$ 次或若干次操作后能得到的序列数量。两个序列用剩下的元素在 $a$ 中的位置来区分是否不同。
>
> $2\le n\le 2\times 10^5$，$1\le a_i\le n$。

## 解法

先考虑一下对于一段序列 $[l,r]$ 能否将 $[l+1,r-1]$ 全部删除如何判断。显然如果有相邻的两个数相等就不行，其次如果 $[l,r]$ 中只有两种值那也不行（`2 1 2` 等情况除外，特判即可），因为删掉一个元素后立即会出现两个相邻且相等的数。考虑不满足这些条件的序列是否可以被删成只剩左右端点。比如说 $a=\{1,2,3,2,1\}$，我们发现 $3$ 若被删去那么会出现相邻的两个 $2$，考虑以这个 $3$ 为端点删掉两个 $2$ 之后再把 $3$ 删了即可。于是我们得到了 $[l,r]$ 能把 $[l+1,r+1]$ 删掉的条件：

- $[l,r]$ 中值的种类数 $\ge3$；
- $[l,r]$ 不存在相邻两个相等的数。

对于计算方案数，我们考虑 dp，设 $f(i)$ 表示只考虑 $[1,i]$ 且 $i$ 为右端点的答案。显然可以啥都不删，即 $f(i)\gets f(i)+f(i-1)$。考虑找到一段后缀 $[j,i]$ 满足 $[j+1,i-1]$ 能被删完，那么答案就可以是 $f(j)$ 的方案数和考虑 $[j+1,i-1]$ 删不删，不删的情况在 $f(i-1)$ 中，所以直接 $f(i)\gets f(i)+f(j)$。

若直接枚举 $j$ 判断 $[i,j]$ 中间是否可删是 $O(n^2)$ 的。在扫的过程中，如果发现了一对 $a_i=a_{i-1}$，那么 $f(i-1)$ 及以前的答案都取不到了；值的种类数随着区间长度的缩小而减少。于是我们考虑双指针，维护两个指针 $l,r$，对于 $j\in[l,r)$ 表示 $[i,j]$ 中 $[i+1,j-1]$ 是可删除的。每次扫到 $a_i$ 时考虑移动 $l$，然后考虑移动 $r$，用一个桶记录当前 $[r,i]$ 值的种类数，$r$ 一直右移直到不合法或 $r=i-2$（此时再短就不可能删了），如果 $l<r$ 那么 $\forall j\in[l,r)$，$f(j)$ 的答案都能取，维护一个前缀和即可。时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
int a[maxn], f[maxn], sum[maxn], n;
int table[maxn], tot;
void add(int val) { tot += ((++ table[val]) == 1); }
void del(int val) { tot -= ((-- table[val]) == 0); }
const int P = 998244353;
int main() {
    scanf("%d", &n), f[0] = 1;
    for (int i = 1, l = 1, r = 1; i <= n; i ++) {
        scanf("%d", &a[i]); f[i] = f[i - 1];
        if (a[i] == a[i - 1]) l = i;
        if (i > 2 && a[i] != a[i - 1] && a[i - 1] != a[i - 2]) f[i] = (1ll * f[i] + 1ll * f[i - 2]) % P;
        for (add(a[i]); r < i - 2 && tot >= 3; del(a[r ++]));
        if (l <= r) f[i] = (1ll * f[i] + 1ll * (1ll * sum[r - 1] - 1ll * sum[l - 1] + P) % P) % P;
        sum[i] = (1ll * sum[i - 1] + 1ll * f[i]) % P;
    } printf("%d", f[n]);
    return 0;
}
```

---


# [ARC177E] Wrong Scoreboard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc177/tasks/arc177_e

AtCoder World Tour Finals 2800 には $ N $ 人の選手が参加し、全 $ 5 $ 問の問題が出題されました。 各問題には $ 1 $ 点以上の整数の配点が付けられており、配点が**広義単調増加**になるように、問 $ 1 $ から問 $ 5 $ までの問題番号が付けられています。 ここで部分点はありません。 また、通常の AtCoder のルールと同様、以下の方法で順位付けが行われます。**なお、本問では合計得点もペナルティも同じという状況は考えないことにします。**

 順位付けの方法合計得点の高い方が上の順位となる。同点の場合は、ペナルティが $ 1 $ 秒でも少ない方が上の順位となる。さて、AtCoder World Tour Finals の取材を担当している青木記者は、以下の情報をメモしました。

1. 参加者数 $ N $。
2. 各選手がどの問題を解いたかの情報。$ A_{i,j}=1 $ のとき $ i $ 番目の選手 $ (1\ \leq\ i\ \leq\ N) $ は問 $ j $ を正解し、$ A_{i,j}=0 $ のとき正解しなかった。
3. 各選手の順位。$ i $ 番目の選手 $ (1\ \leq\ i\ \leq\ N) $ は $ R_i $ 位を獲得した。
 
しかし、記事を書き始めようとしたとき、彼は配点およびペナルティの情報をメモしていないことに気付きました。 さらに、メモした情報に矛盾があるかもしれないことにも気付きました。 そこで以下の問題を解いてください。

> メモ 1 およびメモ 2 が正しいと仮定する。 選手 $ i $ $ (1\ \leq\ i\ \leq\ N) $ の実際の順位を $ D_i $ とするとき、二乗誤差の合計 $ (D_1\ -\ R_1)^2\ +\ (D_2\ -\ R_2)^2\ +\ \dots\ +\ (D_N\ -\ R_N)^2 $ として考えられる最小値を求めよ。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^5 $
- $ 2\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ A_{i,1},\ A_{i,2},\ A_{i,3},\ A_{i,4},\ A_{i,5} $ は $ 0 $ または $ 1 $ $ (1\ \leq\ i\ \leq\ N) $
- $ A_{i,1},\ A_{i,2},\ A_{i,3},\ A_{i,4},\ A_{i,5} $ の合計は $ 1 $ 以上 $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ R_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N) $
- $ R_1,\ R_2,\ \dots,\ R_N $ は相異なる
- すべてのテストケースにおける $ N $ の値の合計は $ 3\ \times\ 10^5 $ 以下
- 入力はすべて整数
 
### Sample Explanation 1

この入力には全部で $ 6 $ 個のテストケースがありますが、まずは $ 1 $ つ目のテストケースについて説明します。 &gt; 以下のような場合を考えます。 &gt; &gt; - $ 1,\ 2,\ 3,\ 4,\ 5 $ 問目の配点がそれぞれ $ 100 $ 点、$ 500 $ 点、$ 800 $ 点、$ 900 $ 点、$ 1300 $ 点である。 &gt; - $ 1,\ 2,\ 3,\ 4 $ 番目の参加者のペナルティがそれぞれ $ 90 $ 分、$ 80 $ 分、$ 70 $ 分、$ 60 $ 分である。 &gt; &gt; このとき、順位表は下表のようになり、二乗誤差の合計は $ (2-1)^2\ +\ (3-2)^2\ +\ (1-3)^2\ +\ (4-4)^2\ =\ 6 $ となります。二乗誤差の合計を $ 5 $ 以下にする方法は存在しないため、$ 6 $ が答えとなります。 &gt; &gt; 参加者 問 1 問 2 問 3 問 4 問 5 合計点 ペナルティ 順位 \*\*1 番目\*\* - 500 800 - - 1300 90 分 2 位 \*\*2 番目\*\* 100 - - 900 - 1000 80 分 3 位 \*\*3 番目\*\* 100 500 - 900 - 1500 70 分 1 位 \*\*4 番目\*\* 100 - 800 - - 900 60 分 4 位 - - - - - - 続いて、$ 2 $ つ目のテストケースについて説明します。 &gt; 以下のような場合を考えます。 &gt; &gt; - $ 1,\ 2,\ 3,\ 4,\ 5 $ 問目の配点がそれぞれ $ 1000 $ 点、$ 1400 $ 点、$ 2000 $ 点、$ 2000 $ 点、$ 2718 $ 点である。 &gt; - $ 1,\ 2,\ \dots,\ 8 $ 番目の参加者のペナルティがそれぞれ $ 295 $ 分、$ 286 $ 分、$ 242 $ 分、$ 236 $ 分、$ 277 $ 分、$ 288 $ 分、$ 187 $ 分、$ 299 $ 分である。 &gt; &gt; このとき、順位表は下表のようになります。どの $ i $ $ (1\ \leq\ i\ \leq\ N) $ についても $ i $ 番目の参加者の順位が $ R_i $ となっているため、二乗誤差の合計は $ 0 $ となります。 &gt; &gt; 参加者 問 1 問 2 問 3 問 4 問 5 合計点 ペナルティ 順位 \*\*1 番目\*\* - 1400 - - - 1400 295 分 7 位 \*\*2 番目\*\* 1000 1400 - 2000 - 4400 286 分 4 位 \*\*3 番目\*\* - 1400 2000 - 2718 6118 242 分 2 位 \*\*4 番目\*\* 1000 - - - - 1000 236 分 8 位 \*\*5 番目\*\* 1000 1400 - 2000 - 4400 277 分 3 位 \*\*6 番目\*\* - 1400 - - - 1400 288 分 6 位 \*\*7 番目\*\* - - - 2000 - 2000 187 分 5 位 \*\*8 番目\*\* - 1400 2000 2000 2718 8118 299 分 1 位

## 样例 #1

### 输入

```
6
4
0 1 1 0 0
1 0 0 1 0
1 1 0 1 0
1 0 1 0 0
1 2 3 4
8
0 1 0 0 0
1 1 0 1 0
0 1 1 0 1
1 0 0 0 0
1 1 0 1 0
0 1 0 0 0
0 0 0 1 0
0 1 1 1 1
7 4 2 8 3 6 5 1
6
1 1 0 0 0
0 0 1 0 0
1 1 1 0 0
0 0 0 1 0
1 1 1 1 0
0 0 0 0 1
1 2 3 4 5 6
6
1 1 0 0 0
0 0 1 0 0
1 1 1 0 0
0 0 0 1 0
1 1 1 1 0
0 0 0 0 1
6 5 4 3 2 1
20
0 0 0 0 1
0 0 1 0 0
1 1 0 0 1
1 0 1 0 1
0 0 0 1 1
0 0 1 1 1
1 1 1 1 0
1 1 0 1 0
0 0 1 1 0
1 0 1 0 0
0 1 0 0 1
0 1 1 1 1
1 1 1 1 1
0 1 0 1 0
1 0 0 0 1
1 1 1 0 0
0 1 1 1 0
0 0 0 1 0
1 1 1 0 1
1 1 0 1 1
7 18 3 5 19 11 13 2 4 10 14 15 17 6 16 9 8 12 1 20
15
0 0 1 1 0
0 0 0 1 0
0 0 0 0 1
0 0 1 1 1
1 1 0 0 1
0 1 1 1 0
1 1 1 1 1
0 1 1 0 1
1 1 0 1 0
1 0 0 1 1
1 0 1 0 0
1 1 0 1 1
0 1 0 1 0
1 1 0 0 0
0 1 0 0 1
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15```

### 输出

```
6
0
26
0
1054
428```

# 题解

## 作者：songhongyi (赞：2)

简要题意：一场 ACM 赛事，五道题目，分数递增。现在给定每个人通过了哪些题，和期望排名 $R_i$，你可以随意钦定罚时，设真实排名为 $r_i$，最小化平方误差 $\sum (R_i-r_i)^2$

**Part I：** 在每题得分给定的情况下（其实是任意情况下），按照 $R_i$ 从小到大钦定罚时，一定最优。

只需要最大化 $\sum R_ir_i$，考虑得分相同的每一部分，根据排序不等式可得以上结论。

这样解决一个给定得分的复杂度为 $\Theta(n \log n)$。

**Part II：** 我们设 $f(S)$ 表示通过题目集合为 $S$ 时的得分和。显然，对于两个 $f,g$，若有 $\forall f(S)<f(T), g(S)<g(T)$ 且 $\forall f(S)=f(T), g(S)=g(T)$ 且 $\forall f(S)>f(T), g(S)>g(T)$，则 $f$ 和 $g$ 等价。这是显然的。也是说，只有 $f$ 的相对大小关系有意义。所以可以对 $f$ 离散化后去重。

在这个基础上搜索，可以得到 $4672$ 个本质不同的得分。这样仍然不足以通过此题。

**Part III：** 我们发现对于得分相同的人，可以通过钦定罚时的方式任意决定其顺序。因而，对于某两个得分方案 $f,g$，若有 $\forall f(S)<f(T)$，都有 $g(S)\le g(T)$，则每一种 $f$ 能达到的方案都可以通过 $g$ 得到，因此 $f$ 是冗余的。

在 **Part II** 的基础上，删去冗余的方案，则只剩下 $113$ 种方案。此时可以通过。

参考代码：

```cpp
#include <algorithm>
#include <iostream>
using namespace std;
const int V[][ 5 ] = {
    { 1, 1, 1, 1, 1 },  // Edited

};
const int MAXN = 3e5 + 10;
bool f[ MAXN ][ 5 ];
int r[ MAXN ];
pair< int, int > v[ MAXN ];
int main()
{
    cin.tie( 0 );
    int T;
    cin >> T;
    while ( T-- )
    {
        int n;
        cin >> n;
        for ( int i = 1; i <= n; i++ )
        {
            for ( int j = 0; j < 5; j++ )
            {
                cin >> f[ i ][ j ];
            }
        }
        for ( int i = 1; i <= n; i++ )
        {
            cin >> r[ i ];
        }
        long long int res = 1e18;
        for ( int T = 0; T < 113; T++ )
        {
            for ( int i = 1; i <= n; i++ )
            {
                int s = 0;
                for ( int j = 0; j < 5; j++ )
                {
                    s += V[ T ][ j ] * f[ i ][ j ];
                }
                v[ i ] = { -s, r[ i ] };
            }
            sort( v + 1, v + n + 1 );
            long long int s = 0;
            for ( int i = 1; i <= n; i++ )
            {
                int d = i - v[ i ].second;
                s += 1ll * d * d;
            }
            res = min( res, s );
        }
        cout << res << endl;
    }
}
```

---


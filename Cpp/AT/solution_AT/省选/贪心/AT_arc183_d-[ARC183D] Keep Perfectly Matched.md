# [ARC183D] Keep Perfectly Matched

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc183/tasks/arc183_d

$ 1 $ から $ N $ までの番号のついた $ N $ 頂点からなる木があります． $ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結ぶ辺です． ここで $ N $ は偶数で，さらにこの木は完全マッチングを持ちます． 具体的には，各 $ i $ ($ 1\ \leq\ i\ \leq\ N/2 $) に対し，$ A_i=i\ \times\ 2-1,B_i=i\ \times\ 2 $ が保証されます．

あなたは以下の操作を $ N/2 $ 回行います．

- 葉 (次数がちょうど $ 1 $ の頂点) を $ 2 $ つ選び，木から削除する． ただしここで，削除したあとの木も完全マッチングを持つ必要がある． なお，この問題では頂点が $ 0 $ 個の場合も木と呼ぶことにする．
 
各操作について，そのスコアを「選んだ $ 2 $ つの頂点の間の距離 (その $ 2 $ つの頂点を結ぶ単純パス上の辺の個数) 」とします．

スコアの合計を最大化するような手順を $ 1 $ つ示してください． なお，この問題の制約下で $ N/2 $ 回の操作を完了する手順が常に存在することが証明できます．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 250000 $
- $ N $ は偶数
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $ ($ 1\ \leq\ i\ \leq\ N-1 $)
- $ A_i=i\ \times\ 2\ -1,B_i=i\ \times\ 2 $ ($ 1\ \leq\ i\ \leq\ N/2 $)
- 与えられるグラフは木である
- 入力される値はすべて整数
 
### Sample Explanation 1

出力例の手順は以下の通りです． - $ 1 $ 回目の操作: 頂点 $ 4,1 $ を消す．残る木は頂点 $ 2,3 $ からなり，完全マッチングを持つ．操作のスコアは $ 3 $ である． - $ 2 $ 回目の操作: 頂点 $ 2,3 $ を消す．残る木は $ 0 $ 頂点からなり，完全マッチングを持つ．操作のスコアは $ 1 $ である． - スコアの合計は $ 3+1=4 $ になる． スコアの合計を $ 4 $ より大きくすることはできないので，この入力例はこの出力で正解できます．

## 样例 #1

### 输入

```
4
1 2
3 4
2 3```

### 输出

```
4 1
2 3```

## 样例 #2

### 输入

```
8
1 2
3 4
5 6
7 8
2 3
1 5
1 7```

### 输出

```
4 8
7 6
5 3
2 1```

## 样例 #3

### 输入

```
14
1 2
3 4
5 6
7 8
9 10
11 12
13 14
2 8
4 11
5 12
7 13
11 14
9 13```

### 输出

```
1 6
5 2
8 12
3 7
10 4
11 9
13 14```

## 样例 #4

### 输入

```
20
1 2
3 4
5 6
7 8
9 10
11 12
13 14
15 16
17 18
19 20
8 10
16 18
16 19
5 9
10 17
2 13
7 14
3 7
3 12```

### 输出

```
6 1
2 15
20 13
14 19
16 4
11 18
17 12
3 5
9 7
8 10```

# 题解

## 作者：WrongAnswer_90 (赞：4)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18380150)

### [[ARC183D] Keep Perfectly Matched](https://www.luogu.com.cn/problem/AT_arc183_d)

这场不打感觉亏麻了，怎么大家都不会 D。首先匹配路径长度之和最大，很典的想到取重心，猜测答案上界 $\sum_i dep_i$ 可以取到。

取完重心之后，希望不断把两个不同的子树里的点进行匹配，直到删空。因为原树本身存在完美匹配，所以找一对不同子树里的点删去后，根节点的匹配一定变了。

所以选的点一定有一个在根节点当前的匹配点的子树里，否则根节点没有理由更改匹配点。设这个点为 $x$，则 $x$ 一定满足：其到根的路径上，边的种类是“匹配边，非匹配边，匹配边...”，即：

![image.png](https://s2.loli.net/2024/08/26/sGZhqnp98wAM2kc.png)

图中标 $1$ 的边是匹配边，可以发现删六号点是合法的，而删 $8$ 号点的过程中会因为连续出现了两条非匹配边而寄掉。

这样确定了一个子树中的点，另一个点是可以任意选的。因为要尽量匹配对，所以另一个点应该选在除此之外的 $siz$ 最大的子树里面。接下来根的匹配就是选的第二个子树中的根节点。继续做上述过程即可。

这样做为何能取到最优值：设 $x$ 是根的初始匹配节点，首先第一次删点的两棵子树一定分别是 $(x,y)$，然后第二次因为此时根和 $y$ 匹配，所以要删 $(y,z)$，以此类推，可以发现除了开始的 $x$ 删了一个点，剩下的操作都是，选一个子树删两个点，然后跳到另一棵子树。

除了 $x$ 子树大小是奇数，剩下的子树大小都是偶数，一开始 $x$ 删了 $1$ 就全部变成了偶数。所以不会有奇偶性不对的情况。如果跳到另一棵子树选择当前 $siz$ 最大的，那就一定能够删空。因为此时根是树的重心，每个子树内需要的操作次数大小都不会超过 $\frac m 2$，其中 $m$ 是总操作次数，所以这样做一定不会爆掉。

现在的问题就是如何高效的找出当前能删掉的合法点。策略也很简单：对于点 $x$ 来说，如果初始他的匹配是他的父亲，则他儿子可以按任意顺序一个一个删光。

如果初始他的匹配是他的某个儿子，则先把这个儿子全部删空时最优的。然后他的匹配就变成了他的父亲，他剩下的儿子可以任意排列。

可以 $\text{dfs}$ 求出每个子树的后序遍历，如果有某个儿子和他匹配就优先向这个儿子走，这样可以求出每个点的合法操作序列。然后套用上述过程，总复杂度 $\mathcal O(n\log n)$ 或者 $\mathcal O(n)$。

```cpp
int n,rt,minn=inf,len,ans[500010],siz[250010];
vi T[250010],ve[250010];
void findrt(int x,int fa=0)
{
	int maxn=0;siz[x]=1;
	for(auto to:T[x])if(to!=fa)
	findrt(to,x),siz[x]+=siz[to],Mmax(maxn,siz[to]);
	if(Mmin(minn,max(n-siz[x],maxn)))rt=x;
}
void dfs(int x,int fa,int top)
{
	ve[top].eb(x);
	for(auto to:T[x])if(to!=fa&&to!=(((x-1)^1)+1))dfs(to,x,top);
	if(fa!=(((x-1)^1)+1))dfs(((x-1)^1)+1,x,top);
}
priority_queue<pii> q;
inline void mian()
{
	read(n);int x,y;pii p;
	for(int i=1;i<n;++i)read(x,y),T[x].eb(y),T[y].eb(x);
	findrt(1),findrt(rt);
	for(auto to:T[rt])dfs(to,rt,to);
	int pos=((rt-1)^1)+1;ans[++len]=ve[pos].back(),ve[pos].pop_back(),--siz[pos];
	for(auto to:T[rt])q.e(mp(siz[to],to));
	for(int I=1;I<(n>>1);++I)
	{
		if(q.top().se==pos)p=q.top(),q.pop();else p=mp(-1,-1);
		pos=q.top().se;
		ans[++len]=ve[pos].back(),ve[pos].pop_back();
		ans[++len]=ve[pos].back(),ve[pos].pop_back();
		siz[pos]-=2;
		q.pop(),q.e(mp(siz[pos],pos));
		if(p.fi!=-1)q.e(p);
	}
	for(auto to:T[rt])if(siz[to])ans[++len]=to;
	ans[++len]=rt;
	for(int i=1;i<=len;i+=2)write(ans[i],' ',ans[i+1],'\n');
}
```

---

## 作者：_zdc_ (赞：3)

观察样例可以发现，对于每条边 $(u, v)$，其贡献次数为两端子树大小的较小值，这也是答案的上界。考虑把重心换成根，一条边两端的子树大小较小值就是较深点的子树大小，且每次删除的两个点分属重心的两个不同子节点的子树。

令 $siz_i$ 为 $i$ 的子树大小。称 $siz$ 为奇数的点为 $1$ 类点，反之为 $0$ 类点。可以发现，一棵树存在完美匹配要满足三个条件：

+ 对于每个 $1$ 类点，其所有子节点均为 $0$ 类点。
+ 对于每个 $0$ 类点，其恰有一个子节点为 $1$ 类点。
+ 根为 $0$ 类点。

只考虑前两个条件，考虑什么样的 $x$ 是可以删的。如果 $x$ 的某个祖先 $u$ 在删 $x$ 之前为 $0$ 类点，那么删之后为 $1$ 类点，于是有 $fa_u$ 在删之后为 $0$ 类点，删之前为 $1$ 类点。同理，如果 $u$ 在删 $x$ 之前为 $1$ 类点，则 $fa_u$ 在删之前为 $0$ 类点。

于是当在掉 $x$ 前，$x$ 到根的链类型是 $01$ 交替的，并且在删之后 $x$ 到根类型反转。因为根的不同子节点独立，可以对于每个子节点构造删除路径。考虑 dfs，每次记录当前的类型，找一个合法的子节点递归下去即可。

为了满足根的条件，每次选的子树需要一奇一偶。考虑用两个数据结构分别维护大小为奇或偶的子节点，事实上只要保持根是重心就能删完，于是每次选最大的两个子树删一个叶子即可。时间复杂度为单 $\log$ 或线性。

```cpp
#include <bits/stdc++.h>
#define ALL(x) begin(x), end(x)
#define All(x, l, r) &x[l], &x[r] + 1
using namespace std;
void file() {
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
}
using ll = long long;
template <typename T> using vec = vector<T> ;

const int kLim = 2.5e5 + 5;
int n;
array<int, kLim> siz, cur;
array<priority_queue<pair<int, int>>, 2> pq;
array<vec<int>, kLim> g, path;

void find(int x, int Fa, int all, int& root) {
  int mx = 0; siz[x] = 1;
  for(int to : g[x])
    if(to ^ Fa) {
      find(to, x, all, root);
      mx = max(mx, siz[to]);
      siz[x] += siz[to];
    }
  mx = max(mx, all - siz[x]);
  if(mx * 2 <= all) root = x;
}

void dfs(int x, int Fa, int from) {
  if(siz[x] & 1) {
    for(int to : g[x])
      if(to ^ Fa) dfs(to, x, from);
  }else {
    for(int to : g[x])
      if((to ^ Fa) && (siz[to] & 1)) dfs(to, x, from);
    for(int to : g[x])
      if((to ^ Fa) && !(siz[to] & 1)) dfs(to, x, from);
  }
  path[from].push_back(x);
}

int main() {
  // file();
  ios::sync_with_stdio(0); cin.tie(0);
  cin >> n;
  for(int i = 1, u, v; i < n; i++) {
    cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  int root = 0, tmp;
  find(1, 0, n, root); find(root, 0, n, tmp);
  for(int k : g[root]) {
    dfs(k, root, k);
    pq[siz[k] & 1].emplace(siz[k], k);
  }
  pq[0].emplace(-1, root);
  pq[1].emplace(-1, root);
  path[root] = {root};
  for(int i = 1; i <= n / 2; i++) {
    int x = pq[0].top().second, y = pq[1].top().second;
    pq[0].pop(); pq[1].pop();
    if(--siz[x]) pq[1].emplace(siz[x], x);
    if(--siz[y]) pq[0].emplace(siz[y], y);
    cout << path[x][cur[x]++] << " " << path[y][cur[y]++] << "\n";
  }
  return 0;
}
```

---

## 作者：Jryno1 (赞：3)

## ARC 183 D

### 题面

给定一棵 $n$ 个点的树，保证其存在一个完美匹配。现在要求每次删除两个叶子结点，要求树仍然存在一个完美匹配，定义这一次删除的得分为两个点的距离。重复这么做直到树被删空了，求得分之和的最大值。要求构造方案。

$n\le 2.5\times 10^5$。

### Sol

考虑怎么样删保证仍然存在一个完美匹配，由于完美匹配的方案是固定的，定义一个边如果在完美匹配中状态为 $1$ 否则为 $0$，那么要选择的路径必须是 $01$ 交替的，可以通过归纳证明。并且一次操作之后相当于翻转所有边的状态。

给树固定一个根，两个点的距离为 $dep_x+dep_y-2dep_\text{LCA}(x,y)$，由于每个点都会恰好被选择一次，所以每个点的 $dep$ 都会被计入答案中，那么想要答案尽量大就需要 $\sum dep_\text{LCA}$ 尽可能小，最希望做到的就是每一次的 LCA 都是根节点。假设根有若干个儿子，分别为 $v_1\dots v_k$，当前 $rt\to v_c$ 的状态为 $1$，每一次操作相当于选择一个儿子 $v_x$，满足 $x\neq c$，从 $v_c,v_x$ 子树中分别选择一个点，满足两个点的路径满足条件，之后修改边的状态。显然在任意时刻只要 $x\neq c$ 那么一定存在一个合法路径，因此只需要考虑儿子子树大小是多少。每次选择的两个儿子子树大小都要 $-1$，尝试贪心，每次都令 $x$ 为满足 $x\neq c$ 的子树大小最大儿子，这样最后至多留下一个儿子，其他儿子的子树都会被删光。

更进一步，注意到如果根定在重心，就能够做到一个儿子都不剩，所有点都被删光，这样也就达到了理论最大值，每一次 $dep_\text{LCA}$ 都是 $1$。

最后考虑如何分别从 $v_x,v_c$ 子树里面选择一个点，保证路径合法。注意到因为子树到根节点的路径状态确定，因此其实是两个独立的问题。考虑预处理，对于每个子树跑出所有点的 dfn 序，dfs 的过程中优先跑状态为 $0$ 的边，会发现，如果按照 dfn 倒序的方式依次删除每一个点，可以保证从子树根到叶子结点的路径一定合法。再进行分析，会发现其到树根的路径也一定合法，而又因为 $rt\to v_x$ 和 $rt\to v_c$ 的状态不同，也就保证了整个路径合法。

预处理 + 优先队列，时间复杂度 $\mathcal{O}(n\log n)$，题目很良心提前给出来初始匹配的方式，实现起来比较简单，[ATC 提交记录](https://atcoder.jp/contests/arc183/submissions/57185199)。

---

## 作者：Phartial (赞：1)

首先有一个挺重要但很显然的事实是一棵树最多只有一种完美匹配。那么对于两个叶子，我们把它们之间的路径拉出来，如果要删掉这两个叶子，则删后得到的树仍然存在完美匹配当且仅当这条路径上匹配边和非匹配边是交错的。一个简单的证明是，如果有连续两条匹配边，说明交点的匹配不在这条路径上，那么我们从两端向中间调整的时候会需要这个点同时匹配两个点，这显然不行；反之，我们可以通过翻转路径上所有边的状态来把两个叶子调整出完美匹配，从而可以被删掉。

随便定个根，我们希望每次操作删掉的两个叶子不在根的同一棵子树中，因为这样就可以最大化每条边的贡献。由上面的推论可知，这两个叶子必然有一个位于根的匹配点的子树中，于是一次操作就是选一个不是根的匹配点的儿子，然后删掉其中的一个叶子和根的匹配点的子树中的一个叶子，并使得根的匹配转移到这个点上。

再简略一点，这就是说，一开始有若干个子树，我们先将某个子树删掉一个点，然后跳到另一棵子树删掉两个点，再跳到另一棵子树删掉两个点，问能不能删完。显然有一个充要条件是最大子树的大小不超过一半（不用担心奇偶性的问题，因为除了初始的匹配子树，其他子树的大小都是偶数，且匹配子树在一开始已经被删了一个点，也成了偶数），这正是重心的定义。

于是我们定重心为根，就一定存在一种方案顶到答案的上界，现在考虑构造这一方案。

首先需要发现的是，删掉一个子树内的某个叶子对这棵子树带来的影响与另一个叶子的选择无关，于是我们其实只需要处理出每棵子树内部的一组合法删点方案，就能贪心地进行配对来得到一个全局的删点方案。

对于某个我们想删除的点，如果它的匹配点是它的父亲，那么往下的边必须要是非匹配边，同时它的儿子也都不是它的匹配点，所以我们可以以任意顺序删掉它的所有儿子，然后删掉它自己；否则，往下的边必须要是匹配边，这意味着我们第一个删的只能是它的匹配点，并且在删掉匹配点后它的匹配点就变成了父节点，于是我们就可以以任意顺序删掉它剩下的所有儿子，最后删掉它自己。于是对每棵子树跑一遍 DFS 即可。

最后的贪心配对可以直接一个子树一个子树贪心地加进答案里，然后拿个链表维护一下，就做完了（要详细一点的可以去看[这篇题解](https://www.luogu.com.cn/article/ox8is0yl)）。时间复杂度线性。

[code](https://atcoder.jp/contests/arc183/submissions/57227921).

---


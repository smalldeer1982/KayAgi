# [ARC186E] Missing Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc186/tasks/arc186_e

$ 1,\dots,K $ からなる長さ $ M $ の整数列 $ (X_1,\dots,X_M) $ が与えられます。

$ 1,\dots,K $ からなる長さ $ N $ の整数列 $ (A_1,\dots,A_N) $ のうち、以下の条件を満たすものの数を $ 998244353 $ で割ったあまりを求めてください。

- $ 1,\dots,K $ からなる長さ $ M $ の整数列のうち、$ (A_1,\dots,A_N) $ の（連続とは限らない）部分列として取れないものは $ (X_1,\dots,X_M) $ のみ

## 说明/提示

### 制約

- $ 2\le\ M,K\ \le\ N\ \le\ 400 $
- $ 1\le\ X_i\ \le\ K $
- 入力はすべて整数
 
### Sample Explanation 1

以下の $ 4 $ 通りが条件を満たします。 - $ (2,\ 3,\ 1,\ 2,\ 3) $ - $ (2,\ 3,\ 1,\ 3,\ 2) $ - $ (3,\ 2,\ 1,\ 2,\ 3) $ - $ (3,\ 2,\ 1,\ 3,\ 2) $

## 样例 #1

### 输入

```
5 2 3
1 1```

### 输出

```
4```

## 样例 #2

### 输入

```
400 3 9
1 8 6```

### 输出

```
417833302```

## 样例 #3

### 输入

```
29 3 10
3 3 3```

### 输出

```
495293602```

## 样例 #4

### 输入

```
29 3 10
3 3 4```

### 输出

```
0```

# 题解

## 作者：隔壁泞2的如心 (赞：11)

这道题主打一个简单粗暴，条件看起来很神秘，但是直接做就能顺利解决。

首先找到序列 $A$ 里面的第一个 $1,2,3,...,k$，那么容易发现：

- 第一个 $X_1$ 后面的 $A$，应该包含所有长为 $m-1$ 但不为 $X_2,X_3,...,X_m$ 的序列为子序列。

- 其他数第一次出现之后的 $A$，则应该包含所有长为 $m-1$ 的序列为子序列。

这样就很有递推性质了！提取出 $A$ 中最短的存在每个数的前缀，这个前缀以外的方案数就是一个 $m$ 减少了 $1$ 的子问题。不断划分下去，可以划分出 $m-1$ 个前缀和一个 $m=1$ 时容易解决的子问题。只要求出每个前缀的情况数然后再乘起来就可以。那么这个前缀有什么限制呢？

首先，由上一段可以立刻推导出 $X_1$ 应该比其他的数出现得都要晚。结合前缀的选取方式，可以得出 $X_1$ 应该只在前缀的末尾出现过一次。

同时，由于那个 $X_1$ 后面的序列包含所有长为 $m-1$ 但不为 $X_2,X_3,...,X_m$ 的序列为子序列，那么它显然会包含 $X_3,X_4,...,X_m$ 为子序列。因此 $A$ 里面出现第二晚的数后面的序列能把 $X_2,X_3,...,X_m$ 这个子序列补回来的充要条件就是“所选前缀内，出现第二晚的数的后面存在至少一个 $X_2$”。

$X_1=X_2$ 时，上述条件一定会被满足，而 $X_1 \ne X_2$ 的情况都等价，也就是说前缀的情况数只和 $[X_1=X_2]$ 和前缀长度有关。可以用第二类斯特林数的方法把这些情况数都算出来，然后再统计有多少 $i$ 满足 $X_i=X_{i+1}$，再用多项式快速幂合并即可。时间复杂度 $O(n\log n)$。

要是手头有多项式板子，那么用多项式比 dp 方便不少（


```cpp
//省略多项式板子
int n,m,k,l[729];
int main()
{
	scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)scanf("%d",l+i);
    default_shrink=n+1;
    poly p0,p1,p2;
    for(int i=1;i<=n;i++)p2[i]=rfac[i];p2=gpow(p2,k-1);
    for(int i=1;i<=n;i++)p2[i]=p2[i]*fac[i];
    for(int i=n;i>=1;i--)p1[i]=p2[i-1];
    for(int i=1;i<=n;i++)p0[i]=rfac[i];p0=gpow(p0,k-2);
    for(int i=n;i>=1;i--)p0[i]=p0[i-1]*fac[i-1]*(k-1);p0[0]=0;
    poly p3;for(int i=1;i<=n;i++)p3[i]=qp((mi)k-1,i-1)-qp((mi)k-2,i-1);
    p0=p0*p3;
    int c0=0,c1=0;
    for(int i=1;i<m;i++){
        if(l[i]==l[i+1])c1++;
        else c0++;
    }
    int ans=(gpow(p0,c0)*gpow(p1,c1)*p2)[n].w;
    printf("%d",ans);
}
```

还有没有更快的做法呢……？

这道题真的很好，它的形式简洁且很有美感，甚至能让人联想到一些故事的片段。我觉得它真的很缺一个优美动人的题目背景……可惜我也写不出来。

---

## 作者：vegetable_king (赞：7)

[可能更好的阅读体验](https://yjh965.github.io/post/arc186e-missing-subsequence-ti-jie/)

赛时没敢开这个题，但是赛后单杀了。以后还是得相信自己，大胆开题啊。

首先考虑解决去掉“$b$ 不是子序列”这个限制，即下面的问题：

> 给定正整数 $n, m, k$，请你求出满足以下条件的值域为 $[1, k]$ 的整数序列 $a_{1 \sim n}$ 的个数：
>
> - 所有长度为 $m$，值域为 $[1, k]$ 的整数序列都是 $a$ 的（不一定连续的）子序列。

先尝试快速判断是否合法，相当于我们需要尽量找到一个序列不在 $a$ 中出现。那么贪心的想，每次肯定是加入一个数使得这个数匹配到的位置最远。那么设当前匹配 $a$ 的位置为 $i$，下一个为 $j$，那么 $j$ 显然是满足 $[i + 1, j]$ 区间内 $1 \sim k$ 每个数都出现的最小位置，这样跳 $m$ 次如果还是没有跳出序列那么就合法。

所以我们顺带刻画了这个序列的结构，肯定至少是 $m$ 个完整的段拼起来，然后后面任意填。其中一“段"需要满足里面 $1 \sim k$ 每个数都出现，并且不存在一个更短的前缀满足该条件。一段的方案数是好算的，那么我们就做完了这个简单版问题。

回来解决原问题，我们迅速发现原序列肯定是在完整的 $m$ 段的基础上删掉最后一个数形成的。因为如果原序列至少有完整的 $m$ 段，那么一定可以匹配所有的序列。显然，这 $m$ 段中，第 $i$ 段的结尾一定是 $b_i$，否则若每一段组成的结尾组成的新序列 $c$（显然 $c \ne b$）若出现则 $b$ 必定出现。

我们发现这两个条件还不够，因为条件显然避免了 $b$ 的出现，但是又可能弄出了一个其它序列也无法出现。

此时我们要贪心的找一个序列 $c$ 使 $b \ne c$，但是 $c$ 也不在 $a$ 中出现。考虑一个策略：使 $c$ 恰好有一个位置和 $b$ 不同。显然该策略一定是不劣的，否则如果有多个位置 $c_p \ne b_p$ 且策略可以成功，只保留最后一个也是可以成功的。

而我们阻止该策略的方法就是，让每一段不匹配到最后的位置都无法直接跳到下一段的最后位置，比如 $[1, 2, 3, 4, 4, 5], [1, 2, 3, 5, 4]$，在第一段中不匹配到最后的位置，都会被倒数第二个位置给拦住。而只要匹配过程中在某一段匹配了大于一次就一定会在 $a$ 中出现，从而策略失败。

但是还有一个情况，如果对于一个 $p$ 有 $p = m$ 或 $b_p = b_{p + 1}$，那么就不需要额外添加位置拦住。

那么我们只需要分别对于两种段，分别算出其方案数，并卷起来即可。

对于 $p = m$ 或 $b_p = b_{p + 1}$ 的段，要满足该段最后一个位置是 $b_p$。

对于 $b_p \ne b_{p + 1}$ 的段，在上面的要求的基础上，还要满足 $b_{p + 1}$ 的最后一个位置满足：在该段内，它前面每种除 $b_p$ 之外的数都存在。

这两个都是容易算出的，所以原问题得以解决。

[code](https://atcoder.jp/contests/arc186/submissions/59290007)

---

## 作者：critnos (赞：1)

非常好的题。

首先我们猜测一个充要条件：每次选择第一次出现位置最靠后的数，然后砍掉这个数对应的前缀，这样能够选择 $m-1$ 次，第 $i$ 次选择的数是 $b_i$。最后剩下一段包含了除了 $b_m$ 之外的所有数。再倒着做一遍，类似的，最后剩下一个前缀包含了除了 $b_1$ 之外的所有数。

考虑对这个结构 dp。用 $x$ 表示从前往后选的数，$y$ 表示从后往前选的数。类似于这样的：


```
      1      2      3       4
      x      x      x       x     
    y        y    y      y
    2        3    4      5
```
考虑对 $x$ dp。$dp_{i,j}$ 表示 $x_{j-1}$ 选到了位置 $i$，考虑 $x_j$ 的位置。枚举之，如果 $b_j=b_{j+1}$ 或者 $j=m$，$y_{j+1}$ 就直接选到 $x_j$ 的位置了，带个第二类斯特林数的系数就行了。否则再枚举一个前缀表示这个前缀是最短的包含了除了 $x_j$ 之外的所有数的前缀，然后再钦定这个前缀到 $x_j$ 之间包含 $b_{j+1}$，可以发现这样 $y$ 就合法了。

容易做到 $O(n^3)$。[提交记录](https://atcoder.jp/contests/arc186/submissions/62908468)。

---

## 作者：forest114514 (赞：0)

主播主播，你的 DP 确实很厉害，但还是太考验手法了，有没有简单又强势的方法推荐一下。有的兄弟，有的有的，后面忘了，反正 GF 太赖了。

虽然已经有 GF 的题解了，但是像我这样的蒟蒻不会推一点式子和做一点 DP 怎么办，于是详细写一下式子是啥。

先不管 $b$ 的限制，就直接求包含所有 $m^k$ 的子序列的数组，可以把序列分成 $k$ 段，每一段末尾是最后一个没出现的数，前面恰好出现了其他所有的数，长 $l$ 的方案是 $m[\frac{x^{l-1}}{(l-1)!}](e^x-1)^{m-1}=m{l-1\brace m-1}  $，大概是若干段这个的 OGF 卷起来然后再卷另一个 GF，能 $O(n\log n)$。

现在考虑这个不能出现某个子序列的限制，所有的数还是都能分成 $m$ 段，倒着看，最后一段不能有 $a_m$，后面第 $i\in [1,m-1]$ 段不能在 $a_{i+1}$ 之前有 $a_{i}$。

最后一段不能有 $a_{m}$，就是正好 $m-1$ 种数，方案为 ${l\brace m-1}$。

剩下的讨论一下：

1. $a_{i}=a_{i+1}$，等价于 $a_{i}$ 只能选一个。

   要么是最后一个数方案 ${l-1\brace m-1}$，要么就正好选个位置 $m{l-1\brace m-1}\to (m-1)(l-1){l-2\brace m-2}$。

2. 否则不相等，所有 $a_{i}$ 在 $a_{i-1}$ 后面。

   还是如果 $a_{i}$ 正好是最后一个数，此时答案 ${l-1\brace m-1}$。

   考虑这两个数钦定位置的话就的 EGF 就是 $\langle 0,1,2,3,4,\ldots,\rangle=ze^z$，其他数的 EGF 是 $e^z-1$，最后还是求 
   $(m-2)[\frac{x^{l-1}}{(l-1)!}]ze^z(e^x-1)^{m-2}$。

上面直接把两种情况的 GF 加一起就行了。

反正就是这样至多三种不同的 GF 的幂次卷起来，直接暴力模拟卷积是 $O(n^2)\sim O(n^3)$，良心模数 $998244353$ 随便 NTT 一下就 $O(n\log n)$ 了。

---


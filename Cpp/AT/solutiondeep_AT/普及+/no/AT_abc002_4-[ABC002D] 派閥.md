# 题目信息

# [ABC002D] 派閥

## 题目描述

从上帝和母亲鼓励的话语中重新获得信心（中二）的高桥君决定去任选国会议员，以纠正AtCoder国家的腐败政治。
以实践操控和演讲而闻名的高桥君最终以实践操控和演讲而闻名的高桥君最终没有困难地赢得了大家的信任，成为了国会议员。
成为国会议员后，接下来就是实际操作。为了纠正这个国家的腐败政治，他需要被任命为总理。
在AtCoder国家除了高桥君之外，还有**N名议员**，存在**M个人际关系（x，y）**。
**人际关系（x，y）的意思是表示成员x和成员y彼此熟悉**（就是可以搞投票的意思）。
高桥君计划通过从N位议员中选出一些议员来制造自己的派系（就是会支持自己）。
**要求包括在该派系中的所有成员必须彼此了解。**
请你动动你的小手写一个程序，求出能属于高桥派系的最大成员人数。

## 说明/提示

（样例一）

第1行：与五位议员有三种人际关系。
第2行：议员1和2互相熟悉。（1,2）
第3行：议员2和3互相熟悉。 （2,3）
第4行：议员1和3互相熟悉。 （1,3）
因为国会议员1，国会议员2，国会议员3相互认识，所以这三个人可以组成高桥君的~~后宫~~支持队伍。

（样例二）

这一个样例有以下可能的关系 ：
1.议员1和议员2互相熟悉（1,2）
2.议员2和议员3互相熟悉 （2,3）
3.议员3和议员4互相熟悉（3,4）
（但是议员1和议员4不互相熟悉所以只能是选择2号议员和3号议员）

翻译：Forgetrmber~这个小小蒟蒻

# AI分析结果

### 题目重写
【题目内容】
# [ABC002D] 派閥

## 题目描述

从上帝和母亲鼓励的话语中重新获得信心（中二）的高桥君决定去任选国会议员，以纠正AtCoder国家的腐败政治。
以实践操控和演讲而闻名的高桥君最终以实践操控和演讲而闻名的高桥君最终没有困难地赢得了大家的信任，成为了国会议员。
成为国会议员后，接下来就是实际操作。为了纠正这个国家的腐败政治，他需要被任命为总理。
在AtCoder国家除了高桥君之外，还有**N名议员**，存在**M个人际关系（x，y）**。
**人际关系（x，y）的意思是表示成员x和成员y彼此熟悉**（就是可以搞投票的意思）。
高桥君计划通过从N位议员中选出一些议员来制造自己的派系（就是会支持自己）。
**要求包括在该派系中的所有成员必须彼此了解。**
请你动动你的小手写一个程序，求出能属于高桥派系的最大成员人数。

## 说明/提示

（样例一）

第1行：与五位议员有三种人际关系。
第2行：议员1和2互相熟悉。（1,2）
第3行：议员2和3互相熟悉。 （2,3）
第4行：议员1和3互相熟悉。 （1,3）
因为国会议员1，国会议员2，国会议员3相互认识，所以这三个人可以组成高桥君的~~后宫~~支持队伍。

（样例二）

这一个样例有以下可能的关系 ：
1.议员1和议员2互相熟悉（1,2）
2.议员2和议员3互相熟悉 （2,3）
3.议员3和议员4互相熟悉（3,4）
（但是议员1和议员4不互相熟悉所以只能是选择2号议员和3号议员）

翻译：Forgetrmber~这个小小蒟蒻

### 算法分类
枚举、位运算、剪枝

### 题解分析与结论
1. **Ray662的题解**：使用状态压缩枚举所有可能的子集，并通过邻接矩阵判断子集内的成员是否彼此认识。时间复杂度为O(n^2 * 2^n)，但由于n较小，完全可行。代码简洁，思路清晰。
2. **ivyjiao的题解**：采用深度优先搜索（DFS）进行枚举，并加入剪枝优化，减少不必要的搜索。时间复杂度为O(2^n * n)，相比Ray662的题解更优。此外，还提供了随机化贪心的解法，虽然时间复杂度较高，但在实际应用中表现良好。

### 精选题解
1. **Ray662的题解**（4星）
   - 关键亮点：使用状态压缩枚举所有可能的子集，代码简洁，思路清晰。
   - 个人心得：通过位运算减少码量，提高了代码的可读性。

```cpp
#include <bits/stdc++.h>
#define _for(i, a, b)  for (int i = (a); i <= (b); i ++ )
using namespace std;
const int N = 15;
int n, m, ans, G[N][N];
int main() {
	cin >> n >> m;
	int a, b;
	_for (i, 0, n - 1)  G[i][i] = 1;  // 自己认识自己 
	_for (i, 1, m) {
		cin >> a >> b, a -- , b -- ;
		G[a][b] = G[b][a] = 1;  // 两点之间有连边 
	}
	int st = 0;
	while (st <= (1 << n) - 1) {  // 遍历每一个状态 
		vector<int> v;
		_for (i, 0, n - 1)
			if (st & (1 << i))  v.push_back(i);  // 把选出的点存入 
		int bj = 1;  // 标记 
		for (int x : v)  for (int y : v)
			if (! G[x][y]) { bj = 0; break; }  // 如果有两人不认识，散伙 
		if (bj == 1)  ans = max(ans, (int)v.size());  // 更新答案（最多人数） 
		st ++ ;  // 别忘了更新状态 
	}
	cout << ans << endl;
	return 0;
}
```

2. **ivyjiao的题解**（4星）
   - 关键亮点：采用DFS进行枚举，并加入剪枝优化，减少了不必要的搜索。
   - 个人心得：通过剪枝优化，显著提高了算法的效率。

```cpp
#include<iostream>
using namespace std;
int n,m,x,y,g[13][13],a[13],ans;
void dfs(int l1,int l2){
    if(l2+n-l1+1<=ans) return;
    if(l1==n+1){
        ans=max(ans,l2);
        return;
    }
    dfs(l1+1,l2);
    for(int i=1;i<=l2;i++) if(!g[l1][a[i]]) return;
    a[l2+1]=l1;
    dfs(l1+1,l2+1);
    a[l2+1]=0;
    return;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>x>>y,g[x][y]=1,g[y][x]=1;
    for(int i=1;i<=n;i++) g[i][i]=1;
    dfs(1,0);
    cout<<ans<<endl;
}
```

### 最优关键思路
- **状态压缩枚举**：通过二进制数表示子集，利用位运算快速判断子集内的成员是否彼此认识。
- **剪枝优化**：在DFS过程中，通过剪枝减少不必要的搜索，提高算法效率。

### 可拓展之处
- 类似问题：最大团问题、图的极大独立集问题。
- 类似算法：回溯法、分支限界法。

### 推荐题目
1. [P2210 Haywire](https://www.luogu.com.cn/problem/P2210)
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

---
处理用时：37.13秒
# 题目信息

# [ABC008C] コイン

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc008/tasks/abc008_3

高橋君は裏表が区別できる $ N $ 枚のコインを持っている。コインの大きさは異なり、それぞれのコインには $ 1 $ つずつ正の整数が書かれている。

これらのコインを無作為に ($ N! $ 通りの組み合わせがすべて同じ確率で出てくるように) 一列に並べる。その後、以下の手順を実行する。

1. すべてのコインを表向きにする。
2. 左端のコインから順に、現在見ているコインよりも右側 (それ自身を除く) にあるコインのうち、現在見ているコインに書かれている整数の倍数が書かれているコインすべての裏表をひっくり返す。

高橋君はこの操作を終了した後に表を向いているコインの枚数の期待値が知りたい。

あなたは高橋くんの代わりに、期待値を計算するプログラムを作成してほしい。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ N\ ≦\ 8 $ を満たすデータセット $ 1 $ に正解した場合は、$ 99 $ 点が与えられる。
- 追加制約のないデータセット $ 2 $ に正解した場合は、さらに $ 1 $ 点が与えられ、合計で $ 100 $ 点が得られる。

### Sample Explanation 1

コインには、サイズの小さい方から順にそれぞれ $ 2 $ , $ 4 $ , $ 8 $ という数が書かれています。例えば、$ 3! $ 通りの並べ方のうち、コインが大きさの昇順に並んでいる場合は、以下の手順が行われることになります。 1. 初期状態で、すべてのコインを表に向けるので、コインは左から順に、\\\[`表`, `表`, `表`\\\] となっています。 2. 次に、左から $ 2 $ 番目以降のコインの中で、$ 2 $ の倍数が書かれたコインを探します。左から $ 2 $ 番目のコインと左から $ 3 $ 番目のコインが該当するので、これらのコインを裏返します。その結果、コインは左から順に \\\[`表`, `裏`, `裏`\\\] となります。 3. 次に、左から $ 3 $ 番目以降のコインの中で、$ 4 $ の倍数が書かれたコインを探します。左から $ 3 $ 番目のコインのみが該当するので、このコインを裏返します。その結果、コインは左から順に \\\[`表`, `裏`, `表`\\\] となります。 コインの裏表は下図のように変化します。この図において、白いコインは表向きのコイン、黒いコインは裏向きのコインで表してあります。 !\[\](http://abc008.contest.atcoder.jp/img/abc/008/3-1.png)このように、$ 3!\ =\ 6 $ 通りの並べ方について、それぞれの並べ方での最終状態は下図のようになります。 !\[\](http://abc008.contest.atcoder.jp/img/abc/008/3-2.png)以上より期待値は $ 13/6\ =\ 2.16666666666... $ となります。

### Sample Explanation 2

どのような順番で並べても、左から順に、\\\[`表`, `裏`, `表`, `裏`\\\] となります。

## 样例 #1

### 输入

```
3

2

4

8```

### 输出

```
2.166666666667```

## 样例 #2

### 输入

```
4

5

5

5

5```

### 输出

```
2.000000000000```

## 样例 #3

### 输入

```
5

2

3

2

6

12```

### 输出

```
3.100000000000```

# AI分析结果

### 题目内容翻译

#### [ABC008C] 硬币

**题目描述**

高桥君有 $N$ 枚可以区分正反面的硬币。硬币的大小各不相同，每枚硬币上写有一个正整数。

这些硬币被随机排列成一列（所有 $N!$ 种排列的可能性相同）。然后，执行以下操作：

1. 将所有硬币初始化为正面朝上。
2. 从左到右依次处理每枚硬币。对于当前处理的硬币，将其右侧（不包括自身）所有硬币中，数字是当前硬币数字倍数的硬币的正反面进行翻转。

高桥君想知道，操作结束后，正面朝上的硬币数量的期望值是多少。

**说明/提示**

**部分分**

- 对于 $N \leq 8$ 的数据集，正确解答可以获得 99 分。
- 对于没有额外限制的数据集，正确解答可以获得 1 分，总计 100 分。

**样例解释**

**样例 1**

输入：
```
3
2
4
8
```
输出：
```
2.166666666667
```

**样例 2**

输入：
```
4
5
5
5
5
```
输出：
```
2.000000000000
```

**样例 3**

输入：
```
5
2
3
2
6
12
```
输出：
```
3.100000000000
```

### 算法分类
**概率论**

### 题解分析与结论

#### 综合分析
本题的核心在于计算每枚硬币最终正面朝上的概率，并将这些概率相加得到期望值。所有题解都采用了相同的思路：对于每枚硬币，计算其被翻转的次数，然后根据翻转次数的奇偶性来确定其最终状态的概率。

#### 关键思路
1. **翻转次数与概率的关系**：每枚硬币的最终状态取决于其被翻转的次数。如果被翻转的次数为偶数，则最终正面朝上；否则，反面朝上。
2. **约数的影响**：每枚硬币的翻转次数取决于其右侧有多少枚硬币的数字是其约数。因此，计算每枚硬币的约数个数是关键。
3. **概率公式**：对于每枚硬币，其最终正面朝上的概率为 $(x / 2 + 1) / (x + 1)$，其中 $x$ 是其约数的个数。

#### 所选高分题解

**题解作者：qwerty12346 (赞：8)**
- **星级：4.5**
- **关键亮点**：思路清晰，代码简洁，直接应用了概率公式，避免了复杂的推导。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++) {
      int sum=0;
      for(int j=1;j<=n;j++) if(i!=j&&!(a[i]%a[j])) sum++;
      ret+=(double)(sum/2+1)/(sum+1);
  }
  ```

**题解作者：Misaka_Mik0t0 (赞：6)**
- **星级：4**
- **关键亮点**：详细解释了概率公式的推导过程，代码实现也较为简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;++i){
      int v=0;
      for(int j=1;j<=n;++j) if(j!=i&&p[i]%p[j]==0) ++v;
      ans+=(double)(int)(v/2+1)/(v+1);
  }
  ```

**题解作者：scp020 (赞：5)**
- **星级：4**
- **关键亮点**：提供了部分分解法和满分解法，适合不同层次的读者理解。
- **核心代码**：
  ```cpp
  for(int i=1,cnt=0;i<=n;i++,cnt=0) {
      for(int j=1;j<=n;j++) if(a[i]%a[j]==0) cnt++;
      cnt--;
      ans+=(cnt/2+1)*1.0/(cnt+1);
  }
  ```

### 最优关键思路与技巧
- **概率公式的应用**：通过计算每枚硬币的约数个数，直接应用概率公式 $(x / 2 + 1) / (x + 1)$ 来计算其最终正面朝上的概率。
- **代码优化**：避免重复计算，通过一次遍历即可完成所有硬币的概率计算。

### 可拓展之处
- **类似问题**：可以扩展到其他涉及概率和期望的问题，如随机排列中的某些特定事件发生的期望值。
- **算法优化**：对于更大规模的数据，可以考虑优化约数计算的方法，如预处理所有数字的约数。

### 推荐题目
1. [P3802 小魔女帕琪](https://www.luogu.com.cn/problem/P3802)
2. [P4317 花神的数论题](https://www.luogu.com.cn/problem/P4317)
3. [P1654 OSU!](https://www.luogu.com.cn/problem/P1654)

### 个人心得摘录
- **调试经历**：在计算约数时，需要注意排除自身，否则会导致概率计算错误。
- **顿悟感想**：通过将问题转化为概率计算，可以大大简化问题的复杂度，避免复杂的排列组合计算。

---
处理用时：34.84秒
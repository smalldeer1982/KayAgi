# 题目信息

# [ABC014D] 閉路

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc014/tasks/abc014_4

$ n $ 個の頂点と $ n-1 $ 本の辺からなる連結な無向グラフが与えられます．それぞれの頂点には $ 1 $ から $ n $ までの番号が順番にふられています．

グラフ理論において，このような条件を満たすグラフは木と呼ばれ，閉路を含まないという性質があります． このグラフに対し，元のグラフに含まれない追加辺 $ (a,b) $ を1つ追加したグラフについて考えてみると，このグラフはちょうど1つの閉路を含みます． あなたの仕事は，そのようなグラフについて，閉路の長さ(閉路に含まれる辺の数)を出力することです．ただ，追加辺の候補はいくつかあり，$ Q $ 個与えられるので，それら全ての候補について答えを出力してください．

## 说明/提示

### 部分点

この問題には2つのデータセットがあり，データセット毎に部分点が設定されている．

- $ Q=1 $ を満たすデータセット 1 に正解した場合は $ 30 $ 点が与えられる．
- 追加制約のないデータセット 2 に正解した場合は，上記のデータセットとは別に $ 70 $ 点が与えられる．

### Sample Explanation 1

図は以下の通りです．
![](https://atcoder.jp/img/abc/014/d1.png)

## 样例 #1

### 输入

```
5

1 2

1 3

1 4

4 5

3

2 3

2 5

2 4```

### 输出

```
3

4

3```

## 样例 #2

### 输入

```
6

1 2

2 3

3 4

4 5

5 6

4

1 3

1 4

1 5

1 6```

### 输出

```
3

4

5

6```

## 样例 #3

### 输入

```
7

3 1

2 1

2 4

2 5

3 6

3 7

5

4 5

1 6

5 6

4 7

5 3```

### 输出

```
3

3

5

5

4```

# AI分析结果

### 题目内容
$ n $ 个顶点的树，给出 $ Q $ 个询问，每次询问给出两个顶点 $ a $ 和 $ b $，表示在 $ a $ 和 $ b $ 之间添加一条边，求包含这条边的环的长度。

### 算法分类
图论、最近公共祖先（LCA）

### 题解分析与结论
所有题解的核心思路都是通过计算两个顶点的最近公共祖先（LCA）来求解环的长度。具体来说，环的长度等于两个顶点到其 LCA 的路径长度之和加 1。不同题解的区别主要在于 LCA 的实现方式，如重链剖分、倍增法、ST 表等。

### 所选高星题解
1. **作者：scp020 (4星)**
   - **关键亮点**：使用重链剖分求 LCA，代码结构清晰，详细解释了树的性质和环的构成。
   - **核心代码**：
     ```cpp
     inline int lca(int x,int y) {
         while(start[x]!=start[y])
             if(dep[start[x]]>=dep[start[y]]) x=f[start[x]];
             else y=f[start[y]];
         if(dep[x]>=dep[y]) return y;
         else return x;
     }
     ```
   - **个人心得**：强调了树的性质和环的构成，帮助理解问题的本质。

2. **作者：hjqhs (4星)**
   - **关键亮点**：使用倍增法求 LCA，代码简洁，预处理和查询部分分离，易于理解。
   - **核心代码**：
     ```cpp
     int queryLCA(int u,int v) {
         if(dep[u]<dep[v]) swap(u,v);
         for(int i=21;i>=0;i--)
             if(dep[anc[u][i]]>=dep[v])
                 u=anc[u][i];
         if(u==v) return u;
         for(int i=21;i>=0;i--)
             if(anc[u][i]!=anc[v][i])
                 u=anc[u][i],v=anc[v][i];
         return anc[u][0];
     }
     ```
   - **个人心得**：强调了倍增法的实现细节，帮助理解 LCA 的求解过程。

3. **作者：CSPJ10pts (4星)**
   - **关键亮点**：使用倍增法求 LCA，代码结构清晰，详细解释了深度和 LCA 的关系。
   - **核心代码**：
     ```cpp
     int lca(int x, int y) {
         if (dep[x] < dep[y]) swap(x, y);
         for (int i = maxl - 1; i >= 0; i--) 
             if (dep[x] - dep[y] >= (1 << i)) x = f[x][i];
         if (x == y) return x;
         for (int i = maxl - 1; i >= 0; i--) 
             if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
         return f[x][0];
     }
     ```
   - **个人心得**：通过模拟样例帮助理解问题，强调了深度和 LCA 的关系。

### 最优关键思路
1. **LCA 的应用**：通过求两个顶点的 LCA，可以快速计算它们之间的路径长度，进而求出环的长度。
2. **树的性质**：树中任意两个顶点之间只有一条唯一的路径，添加一条边后会形成一个唯一的环。
3. **多种 LCA 实现**：重链剖分、倍增法、ST 表等，各有优缺点，选择适合的实现方式可以提高代码效率和可读性。

### 可拓展之处
1. **其他图论问题**：如最短路径、最小生成树等，都可以通过类似的方法解决。
2. **LCA 的变种**：如求多个顶点的 LCA，或者在有向图中求 LCA。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)
3. [P3258 [JLOI2014]松鼠的新家](https://www.luogu.com.cn/problem/P3258)

### 个人心得总结
- **调试经历**：在实现 LCA 时，需要注意深度的计算和跳转的细节，避免出现死循环或错误结果。
- **踩坑教训**：预处理时要注意数组的大小和初始化，避免越界或未定义行为。
- **顿悟感想**：理解树的性质和 LCA 的应用，可以大大简化问题的求解过程。

---
处理用时：33.56秒
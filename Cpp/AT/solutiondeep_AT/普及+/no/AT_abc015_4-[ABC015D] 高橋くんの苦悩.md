# 题目信息

# [ABC015D] 高橋くんの苦悩

## 题目描述

# 题目大意

你有 $N$ 个物品，第 $i$ 个物品的重量为 $A_i$ ，体积为 $1$ ，价值为 $B_i$ ，你还有一个背包，背包的容积为 $K$ ，所能承受的最大重量为 $W$ ，现在你要将一些物品放入背包中，求放入背包的物品的最大价值。

## 样例 #1

### 输入

```
10

3 2

4 20

3 40

6 100```

### 输出

```
140```

## 样例 #2

### 输入

```
10

5 4

9 10

3 7

3 1

2 6

4 5```

### 输出

```
18```

## 样例 #3

### 输入

```
22

5 3

5 40

8 50

3 60

4 70

6 80```

### 输出

```
210```

# AI分析结果

### 题目内容
你有 $N$ 个物品，第 $i$ 个物品的重量为 $A_i$ ，体积为 $1$ ，价值为 $B_i$ ，你还有一个背包，背包的容积为 $K$ ，所能承受的最大重量为 $W$ ，现在你要将一些物品放入背包中，求放入背包的物品的最大价值。

### 算法分类
动态规划

### 题解分析与结论
本题的核心是二维费用背包问题，需要在考虑物品重量的同时，还要考虑物品的体积。题解通过动态规划的方式，定义状态`dp[i][j][k]`表示用前 $i$ 件物品装入所能承受的最大重量为 $j$ ，容积为 $k$ 的背包的最大价值。通过状态转移方程`dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-a[i]][k-1]+b[i])`来求解最大价值。

### 所选题解
#### 题解作者：a_blue_cell (赞：4)
- **星级**: 4星
- **关键亮点**: 使用二维费用背包的动态规划解法，代码简洁明了，状态转移方程清晰，且通过倒序枚举优化了空间复杂度。
- **个人心得**: 作者提到使用二维数组而非三维数组，通过倒序枚举避免了叠加问题，这是动态规划中常见的优化技巧。

### 核心代码
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,x,y;
int a[55],b[55],dp[10005][55];
int main(){
	scanf("%d%d%d",&x,&n,&y);			//输入很奇怪，输入顺序为：背包所能承受的最大重量，物品数量，背包容积
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);			
	}
	for(int i=1;i<=n;i++){
		for(int j=x;j>=a[i];j--){			//由于我们使用的二维数组，而非三维，所以需要倒着枚举，避免出现叠加的状况
			for(int k=y;k>=1;k--){
				dp[j][k]=max(dp[j][k],dp[j-a[i]][k-1]+b[i]);
			}
		}
	}
	printf("%d",dp[x][y]);
	return 0;
}
```

### 最优关键思路或技巧
- **状态定义**: 使用`dp[i][j][k]`表示前 $i$ 件物品在重量限制 $j$ 和体积限制 $k$ 下的最大价值。
- **状态转移**: 通过`max(dp[i-1][j][k],dp[i-1][j-a[i]][k-1]+b[i])`来更新状态。
- **空间优化**: 使用二维数组并通过倒序枚举避免状态叠加问题。

### 可拓展之处
- **多维背包问题**: 可以扩展到更多维度的背包问题，如考虑时间、空间等多重限制。
- **其他优化技巧**: 可以进一步探讨滚动数组、记忆化搜索等优化技巧在动态规划中的应用。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：23.92秒
# 题目信息

# [ABC017C] ハイスコア

## 题目描述

### 题意 

高桥君非常喜欢打电动。

现在他在玩的这个游戏中有 $N$ 个遗迹，你可以按照你喜欢的顺序去探索这些遗迹（不一定都要探索）。在探索遗迹的过程中会获得宝石，游戏中一共有 $M$ 种宝石。

当你探索过第 $i(1\le i \le N)$ 个遗迹后，你的得分将增加 $s_i$，同时，你将得到所有种类编号在 $l_i$ 到 $r_i$ 之间的宝石各一个，但是再一次探索同一个遗迹的话，你将什么都无法得到。

获得的宝石无法被丢弃，当所有种类的宝石都获得之后，会复活魔王导致得分清零且不再能得分。

高桥君想要得到尽可能高的分数，请求出在不复活魔王的情况下，可以得到的分数最高能是多少。

## 说明/提示

- $1\le N \le 10^5$
- $1\le M \le 10^5$
- $1\le l_i,r_i \le M$
- $1\le s_i \le 5\times 10^3$
- 所有读入的数值都是整数。

---

## 样例 #1

### 输入

```
4 6

1 3 30

2 3 40

3 6 25

6 6 10```

### 输出

```
80```

## 样例 #2

### 输入

```
2 7

1 3 90

5 7 90```

### 输出

```
180```

## 样例 #3

### 输入

```
1 4

1 4 70```

### 输出

```
0```

# AI分析结果

### 题目内容
# [ABC017C] ハイスコア

## 题目描述

### 题意 

高桥君非常喜欢打电动。

现在他在玩的这个游戏中有 $N$ 个遗迹，你可以按照你喜欢的顺序去探索这些遗迹（不一定都要探索）。在探索遗迹的过程中会获得宝石，游戏中一共有 $M$ 种宝石。

当你探索过第 $i(1\le i \le N)$ 个遗迹后，你的得分将增加 $s_i$，同时，你将得到所有种类编号在 $l_i$ 到 $r_i$ 之间的宝石各一个，但是再一次探索同一个遗迹的话，你将什么都无法得到。

获得的宝石无法被丢弃，当所有种类的宝石都获得之后，会复活魔王导致得分清零且不再能得分。

高桥君想要得到尽可能高的分数，请求出在不复活魔王的情况下，可以得到的分数最高能是多少。

## 说明/提示

- $1\le N \le 10^5$
- $1\le M \le 10^5$
- $1\le l_i,r_i \le M$
- $1\le s_i \le 5\times 10^3$
- 所有读入的数值都是整数。

---

## 样例 #1

### 输入

```
4 6

1 3 30

2 3 40

3 6 25

6 6 10```

### 输出

```
80```

## 样例 #2

### 输入

```
2 7

1 3 90

5 7 90```

### 输出

```
180```

## 样例 #3

### 输入

```
1 4

1 4 70```

### 输出

```
0```

### 算法分类
差分

### 综合分析与结论
题目要求在不集齐所有宝石的情况下，最大化得分。由于得分均为正数，贪心策略是尽可能多地探索遗迹，同时避免集齐所有宝石。通过差分数组来记录每个宝石的得分贡献，最终通过前缀和计算每个宝石的得分贡献，选择得分贡献最小的宝石，将其对应的得分从总得分中减去，得到最大得分。

### 所选高分题解
#### 作者：Walter_Fang (赞：5)
**星级：5星**
**关键亮点：**
- 使用差分数组记录每个宝石的得分贡献，通过前缀和计算每个宝石的得分贡献。
- 选择得分贡献最小的宝石，将其对应的得分从总得分中减去，得到最大得分。
- 代码简洁高效，时间复杂度为 $O(n + m)$。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,i,mi=INT_MAX,s,tmp,a[N],x[N],y[N],f[N];
int main(){
    cin>>n>>m;
    for(i=1;i<=n;i++)cin>>x[i]>>y[i]>>f[i];
    for(i=1;i<=n;i++)a[x[i]]+=f[i],a[y[i]+1]-=f[i],s+=f[i];
    for(i=1;i<=m;i++)tmp+=a[i],mi=min(mi,tmp);
    cout<<s-mi<<'\n';
}
```

#### 作者：scp020 (赞：2)
**星级：4星**
**关键亮点：**
- 使用差分和前缀和优化区间修改和单点查询。
- 通过枚举不选的宝石，计算其对应的得分贡献，选择得分贡献最小的宝石。
- 代码清晰，时间复杂度为 $O(n + m)$。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define Getchar() p1==p2 and (p2=(p1=Inf)+fread(Inf,1,1<<21,stdin),p1==p2)?EOF:*p1++
char Inf[1<<21],*p1,*p2;
inline void read(int &x,char c=Getchar())
{
    bool f=c!='-';
    x=0;
    while(c<48 or c>57) c=Getchar(),f&=c!='-';
    while(c>=48 and c<=57) x=(x<<3)+(x<<1)+(c^48),c=Getchar();
    x=f?x:-x;
}
int n,m,pre[100010],sum,mini=0x3f3f3f3f;
int main()
{
    read(n),read(m);
    for(int i=1,L,R,s;i<=n;i++) read(L),read(R),read(s),pre[L]+=s,pre[R+1]-=s,sum+=s;
    for(int i=1;i<=m;i++) pre[i]+=pre[i-1],mini=min(mini,pre[i]);
    cout<<sum-mini<<endl;
    return 0;
}
```

#### 作者：TankYu (赞：0)
**星级：4星**
**关键亮点：**
- 使用差分数组记录每个宝石的得分贡献，通过前缀和计算每个宝石的得分贡献。
- 选择得分贡献最小的宝石，将其对应的得分从总得分中减去，得到最大得分。
- 代码简洁，时间复杂度为 $O(n + m)$。

**核心代码：**
```cpp
#include <iostream>
using namespace std;

int d[100010];

int main()
{
    int n, m;
    cin >> n >> m;
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        int l, r, s;
        cin >> l >> r >> s;
        ans += s;
        d[l] += s;
        d[r + 1] -= s;
    }
    int minn = ans;
    for (int i = 1; i <= m; i++)
    {
        d[i] += d[i - 1];
        minn = min(minn, d[i]);
    }
    cout << ans - minn << '\n';
    return 0;
}
```

### 最优关键思路或技巧
1. **差分数组**：用于高效记录区间修改，通过前缀和快速计算单点值。
2. **贪心策略**：尽可能多地探索遗迹，同时避免集齐所有宝石。
3. **前缀和**：用于快速计算每个宝石的得分贡献，选择得分贡献最小的宝石。

### 可拓展之处
类似的问题可以通过差分数组和前缀和来优化区间修改和单点查询，适用于需要频繁进行区间操作的场景。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

---
处理用时：38.50秒
# 题目信息

# [ABC018C] 菱型カウント

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc018/tasks/abc018_3

縦 $ R $ 行、横 $ C $ 列の長方形領域がある。上から $ i\ (1\ ≦\ i\ ≦\ R) $ 行目、左から $ j\ (1\ ≦\ j\ ≦\ C) $ 列目にあるマスをマス ($ i $, $ j $) と呼ぶことにする。これらのマスのうちいくつかのマスは黒く、他のマスは白く塗られている。

また、ある整数 $ K $ が定められている。

ここで、以下の条件を満たすように新たに緑色を塗ることを考える。この操作は1 回だけ行う。

- ある整数 の組 $ x\ (K\ ≦\ x\ ≦\ R\ -\ K\ +\ 1) $, $ y\ (K\ ≦\ y\ ≦\ C\ -\ K\ +\ 1) $ に対して、|$ i-x $|+|$ j-y $|$ ≦\ K\ -\ 1 $ を満たすすべてのマス ($ i $,$ j $) について、マス ($ i $,$ j $) は元々白いマスで、かつ、この操作で緑色に塗られる。さらに、|$ i-x $|+|$ j-y $|$ ≧\ K $ を満たすすべてのマスについて、そのマスは緑色に塗らない。

このような色の塗り方の総数はいくらか。ただし、ここでいう塗り方とは、どのマスがどの色になったかという組み合わせのことで、色の塗る順番は考慮しないものとする。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ R\ ≦\ 50 $ かつ $ C\ ≦\ 50 $ を満たすデータセット $ 1 $ に正解した場合は、$ 30 $ 点が与えられる。

### Sample Explanation 1

以下の $ 3 $ 通りが考えられます (`o` は白いマス、`x` は黒いマス、`\*` は緑色のマスを表します)。 x\\\*ooo\\\*\\\*\\\*oxo\\\*ooooxxoo xo\\\*ooo\\\*\\\*\\\*xoo\\\*oooxxoo xooooooo\\\*xoo\\\*\\\*\\\*oxx\\\*o

## 样例 #1

### 输入

```
4 5 2

xoooo

oooox

ooooo

oxxoo```

### 输出

```
3```

## 样例 #2

### 输入

```
4 5 2

ooooo

oxoox

oooox

oxxoo```

### 输出

```
0```

## 样例 #3

### 输入

```
8 6 3

oooooo

oooooo

oooooo

oooooo

oxoooo

oooooo

oooooo

oooooo```

### 输出

```
4```

# AI分析结果

【题目内容】
# [ABC018C] 菱型カウント

## 题目描述

给定一个 $R$ 行 $C$ 列的长方形区域，每个格子可能是黑色（`x`）或白色（`o`）。给定一个整数 $K$，要求在所有可能的中心点 $(x, y)$ 中，满足以 $(x, y)$ 为中心、曼哈顿距离不超过 $K-1$ 的所有格子都是白色，并且这些格子被涂成绿色。求满足条件的涂色方案的总数。

## 说明/提示

### 部分点

- $R \leq 50$ 且 $C \leq 50$ 的数据集，正解可得 $30$ 分。

### 样例解释

样例1中，有3种涂色方案满足条件。

## 样例 #1

### 输入

```
4 5 2

xoooo

oooox

ooooo

oxxoo
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4 5 2

ooooo

oxoox

oooox

oxxoo
```

### 输出

```
0
```

## 样例 #3

### 输入

```
8 6 3

oooooo

oooooo

oooooo

oooooo

oxoooo

oooooo

oooooo

oooooo
```

### 输出

```
4
```

【算法分类】  
前缀和

【题解分析与结论】  
该题的核心在于如何高效地判断以某个点为中心的菱形区域内是否全部为白色。题解中主要采用了前缀和的方法来优化查询效率，避免了对每个点进行暴力搜索。

【所选高星题解】

1. **作者：Rigel (5星)**  
   - **关键亮点**：通过旋转矩阵将问题转化为更容易处理的形式，并利用前缀和快速计算菱形区域内的黑色格子数量。  
   - **代码核心思想**：将原矩阵旋转后，使用前缀和数组快速查询菱形区域内的黑色格子数量，判断是否满足条件。
   ```cpp
   for(int i=1;i<=mx;i++)for(int j=1;j<=mx;j++)b[i+j-1][n-i+j]=a[i][j],vis[i+j-1][n-i+j]=1;
   for(int i=1;i<=N;i++)for(int j=1;j<=N;j++)f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+b[i][j];
   for(int i=k+1;i<=N-k;i++){
       for(int j=k+1;j<=N-k;j++){
           if(!vis[i][j])continue;
           int w=f[i+k][j+k]-f[i-k-1][j+k]-f[i+k][j-k-1]+f[i-k-1][j-k-1];
           if(!w)ans++;
       }
   }
   ```

2. **作者：shiyihang (4星)**  
   - **关键亮点**：通过预处理每个格子上下方的白色格子数量，快速判断菱形区域是否全部为白色。  
   - **代码核心思想**：预处理每个格子上下方的白色格子数量，然后遍历所有可能的中心点，判断其菱形区域是否满足条件。
   ```cpp
   for(int i=1;i<=r;++i)for(int j=1;j<=c;++j)s[i][j][0]=mp[i][j]=='o'?s[i-1][j][0]+1:0;
   for(int i=r;i>=1;--i)for(int j=1;j<=c;++j)s[i][j][1]=mp[i][j]=='o'?s[i+1][j][1]+1:0;
   for(int i=k;i<=r-k+1;++i){
       for(int j=k;j<=c-k+1;++j){
           int flg=1;
           for(int l=j-k+1,cnt=0;l<j+k;++l){
               if(l<=j)++cnt;else --cnt;
               if(s[i][l][0]<cnt||s[i][l][1]<cnt){flg=0;break;}
           }
           ans+=flg;
       }
   }
   ```

【最优关键思路】  
利用前缀和或预处理的方法，快速查询菱形区域内的黑色格子数量，避免暴力搜索，显著提高效率。

【拓展思路】  
类似的问题可以扩展到其他形状的区域，如矩形、圆形等，同样可以采用前缀和或预处理的方法来优化查询效率。

【推荐题目】  
1. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)  
2. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)  
3. [P2280 [HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)

---
处理用时：32.05秒
# 题目信息

# [ABC018D] バレンタインデー

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc018/tasks/abc018_4

あるクラスには女子が $ N $ 人、男子が $ M $ 人いる。女子には $ 1 $ から $ N $ までの出席番号が、男子には $ 1 $ から $ M $ までの出席番号が割り当てられている。

幸運のキューピットはここから女子 $ P $ 人と男子 $ Q $ 人からなる、1 つの旅行グループを作る。

$ N $ 人の女子は合わせて $ R $ 個のチョコレートを持っており、チョコレートには $ 1 $ から $ R $ までの番号が付けられている。

チョコレート $ i\ (1\ ≦\ i\ ≦\ R) $ は出席番号が $ x_i $ である女子が持っており、旅行中に出席番号が $ y_i $ である男子に渡す予定である。そのため旅行グループに出席番号が $ x_i $ である女子と出席番号が $ y_i $ である男子が両方含まれていた場合に限り渡すことができる。無事にチョコレート $ i $ が渡された場合の幸福度は $ z_i $ である。

無事に渡されたチョコレートによる幸福度の合計値として考えられる最大値はいくらか。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ N\ ≦\ 8 $ かつ $ M\ ≦\ 8 $ を満たすデータセット $ 1 $ に正解した場合は、$ 30 $ 点が与えられる。

### Sample Explanation 1

出席番号が $ 1 $, $ 2 $ の女子と出席番号が $ 2 $, $ 3 $, $ 4 $ の男子からなる旅行グループを考えます。 - チョコレート $ 1 $ は出席番号が $ 1 $ の男子が旅行に参加しないため、渡されません。 - チョコレート $ 2 $ は受け渡しする男女がともに旅行に参加するため、無事に渡されます。チョコレートの幸福度は $ 7 $ です。 - チョコレート $ 3 $ は受け渡しする男女がともに旅行に参加するため、無事に渡されます。チョコレートの幸福度は $ 15 $ です。 - チョコレート $ 4 $ は受け渡しする男女がともに旅行に参加するため、無事に渡されます。チョコレートの幸福度は $ 6 $ です。 - チョコレート $ 5 $ は受け渡しする男女がともに旅行に参加するため、無事に渡されます。チョコレートの幸福度は $ 3 $ です。 - チョコレート $ 6 $ は受け渡しする男女がともに旅行に参加するため、無事に渡されます。チョコレートの幸福度は $ 6 $ です。 - チョコレート $ 7 $ は出席番号が $ 3 $ の女子が旅行に参加しないため、渡されません。 幸福度の合計値は $ 7\ +\ 15\ +\ 6\ +\ 3\ +\ 6\ =\ 37 $ となり、これが最大値となります。

## 样例 #1

### 输入

```
3 4 2 3 7

1 1 9

1 2 7

1 3 15

1 4 6

2 2 3

2 4 6

3 3 6```

### 输出

```
37```

## 样例 #2

### 输入

```
4 5 3 2 9

2 3 5

3 1 4

2 2 2

4 1 9

3 5 3

3 3 8

1 4 5

1 5 7

2 4 8```

### 输出

```
26```

# AI分析结果

### 题目内容重写

某班级有 $N$ 名女生和 $M$ 名男生。女生和男生分别被分配了从 $1$ 到 $N$ 和从 $1$ 到 $M$ 的学号。

幸运的丘比特要从这些女生和男生中选出 $P$ 名女生和 $Q$ 名男生组成一个旅行团。

$N$ 名女生共有 $R$ 块巧克力，每块巧克力都有一个从 $1$ 到 $R$ 的编号。

第 $i$ 块巧克力（$1 \leq i \leq R$）由学号为 $x_i$ 的女生持有，并计划在旅行中送给学号为 $y_i$ 的男生。只有当旅行团中同时包含学号为 $x_i$ 的女生和学号为 $y_i$ 的男生时，这块巧克力才能被成功送出。成功送出第 $i$ 块巧克力时，获得的幸福度为 $z_i$。

求成功送出的巧克力所带来的最大幸福度总和。

### 算法分类
深度优先搜索 DFS

### 题解分析与结论

本题的核心是通过深度优先搜索（DFS）枚举所有可能的女生和男生组合，计算每种组合下的幸福度总和，最终取最大值。由于数据范围较小（$N, M \leq 18$），DFS 是一种可行的解决方案。

### 所选高星题解

#### 1. 作者：ikunTLE (赞：11)
- **星级**：5星
- **关键亮点**：
  - 使用 DFS 枚举所有可能的女生组合，确保选择 $P$ 名女生。
  - 对于每种女生组合，计算每个男生的幸福度总和，并排序取前 $Q$ 名。
  - 代码简洁，逻辑清晰，易于理解。
- **核心代码**：
  ```cpp
  void dfs(int x, int y) {
      if (y > e) return;
      if (x > n) {
          if (y == e) {
              memset(p, 0, sizeof(p));
              for (int i = 1; i <= n; ++i)
                  for (int j = 1; j <= m; ++j)
                      p[j] += vis[i] * a[i][j];
              sort(p + 1, p + m + 1, greater<int>());
              int sum = 0;
              for (int i = 1; i <= q; ++i)
                  sum += p[i];
              ans = max(ans, sum);
          }
          return;
      }
      vis[x] = true, dfs(x + 1, y + 1);
      vis[x] = false, dfs(x + 1, y);
  }
  ```

#### 2. 作者：Walter_Fang (赞：4)
- **星级**：4星
- **关键亮点**：
  - 使用 DFS 枚举所有可能的女生组合，确保选择 $P$ 名女生。
  - 对于每种女生组合，计算每个男生的幸福度总和，并排序取前 $Q$ 名。
  - 代码结构清晰，注释详细，易于理解。
- **核心代码**：
  ```cpp
  void dfs(int step, int num) {
      if (num > p) return;
      if (step > n) {
          if (num == p) check();
          return;
      }
      f[step] = 1;
      dfs(step + 1, num + 1);
      f[step] = 0;
      dfs(step + 1, num);
  }
  ```

#### 3. 作者：lylcpp (赞：2)
- **星级**：4星
- **关键亮点**：
  - 使用 DFS 枚举所有可能的女生组合，确保选择 $P$ 名女生。
  - 对于每种女生组合，计算每个男生的幸福度总和，并排序取前 $Q$ 名。
  - 代码简洁，逻辑清晰，易于理解。
- **核心代码**：
  ```cpp
  void dfs(int x, int w) {
      if (w > p) return;
      if (x == n + 1) {
          if (w == p) calc();
          return;
      }
      a[x] = 1;
      dfs(x + 1, w + 1);
      a[x] = 0;
      dfs(x + 1, w);
  }
  ```

### 最优关键思路与技巧
- **DFS 枚举**：通过 DFS 枚举所有可能的女生组合，确保选择 $P$ 名女生。
- **贪心选择**：对于每种女生组合，计算每个男生的幸福度总和，并排序取前 $Q$ 名。
- **代码优化**：使用数组记录选择状态，避免重复计算，提高效率。

### 可拓展之处
- **状态压缩**：对于更大的数据范围，可以考虑使用状态压缩来优化枚举过程。
- **动态规划**：如果数据范围进一步增大，可以考虑使用动态规划来优化计算过程。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得总结
- **调试经历**：在实现 DFS 时，需要注意递归的终止条件，避免无限递归。
- **踩坑教训**：在计算幸福度总和时，需要确保数组初始化，避免脏数据影响结果。
- **顿悟感想**：通过 DFS 枚举所有可能的组合，可以有效地解决这类组合优化问题。

---
处理用时：36.55秒
# 题目信息

# [ABC021D] 多重ループ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc021/tasks/abc021_d

新入社員の高橋君は、とある企業の新人プログラマーとして部署に配属されました。 高橋君が担当した初めての仕事は、以下の擬似コードで表されるプログラムを高速化するというものでした。

 ```

n←(標準入力)
ans←0
for i=1..n
  for j=i..n
    ans ← ans+1
ansの値を表示
```

高橋君にかかってしまえばこんな仕事はお茶の子さいさいです。 各 $ i $ に対する内側のループ回数を考えて総和の公式を用いれば $ ans=n+n-1+…+1=n(n+1)/2 $ となり、これを用いればすぐ答えが出せます。

劇的な高速化に成功した高橋君への部署からの期待は鰻登りです。そこで、上司は彼に更なる仕事を与えることにしました。

その仕事内容は、以下のような for ループのネストの深さが $ k $ の場合におけるプログラムの高速化です。

 ```

n←(標準入力)
k←(標準入力)
ans←0
for a_1=1..n
  for a_2=a_1..n
    for a_3=a_2..n
      …
      for a_k=a_{k-1}..n // a_0=1とする
        ans ← ans+1
ansの値を表示
```

さすがの高橋君もこれには少し悩みました。総和の公式が使えないからです。

いろいろ考えてみたところ、このプログラムの出力する答えは $ 1≦a_1≦a_2≦…≦a_k≦n $ であるような整数の組 $ (a_1,a_2,…,a_k) $ の個数に等しいということに気づきました。 しかし、彼はそのようなものの個数を数える方法を思いつきませんでした。

彼の同僚であるあなたは、彼の代わりにこの課題をこなすプログラムを作ってあげることにしました。 ただし、答えは非常に大きくなることがあるので、ans の代わりに ans を $ 1,000,000,007(=10^9+7) $ で割った余りを出力してください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1≦n≦1000 $ かつ $ 1≦k≦1000 $ であるようなデータセットに正解した場合は $ 99 $ 点が得られる。
- 上記のデータセットを含む全てのデータセットに正解した場合はさらに $ 1 $ 点が得られる。

## 样例 #1

### 输入

```
10

2```

### 输出

```
55```

## 样例 #2

### 输入

```
10

3```

### 输出

```
220```

## 样例 #3

### 输入

```
10

4```

### 输出

```
715```

## 样例 #4

### 输入

```
400

296```

### 输出

```
546898535```

## 样例 #5

### 输入

```
100000

100000```

### 输出

```
939733670```

# AI分析结果

### 题目内容重写
新入社員の高橋君は、とある企業の新人プログラマーとして部署に配属されました。 高橋君が担当した初めての仕事は、以下の擬似コードで表されるプログラムを高速化するというものでした。

```
n←(標準入力)
ans←0
for i=1..n
  for j=i..n
    ans ← ans+1
ansの値を表示
```

高橋君にかかってしまえばこんな仕事はお茶の子さいさいです。 各 $ i $ に対する内側のループ回数を考えて総和の公式を用いれば $ ans=n+n-1+…+1=n(n+1)/2 $ となり、これを用いればすぐ答えが出せます。

劇的な高速化に成功した高橋君への部署からの期待は鰻登りです。そこで、上司は彼に更なる仕事を与えることにしました。

その仕事内容は、以下のような for ループのネストの深さが $ k $ の場合におけるプログラムの高速化です。

```
n←(標準入力)
k←(標準入力)
ans←0
for a_1=1..n
  for a_2=a_1..n
    for a_3=a_2..n
      …
      for a_k=a_{k-1}..n // a_0=1とする
        ans ← ans+1
ansの値を表示
```

さすがの高橋君もこれには少し悩みました。総和の公式が使えないからです。

いろいろ考えてみたところ、このプログラムの出力する答えは $ 1≦a_1≦a_2≦…≦a_k≦n $ であるような整数の組 $ (a_1,a_2,…,a_k) $ の個数に等しいということに気づきました。 しかし、彼はそのようなものの個数を数える方法を思いつきませんでした。

彼の同僚であるあなたは、彼の代わりにこの課題をこなすプログラムを作ってあげることにしました。 ただし、答えは非常に大きくなることがあるので、ans の代わりに ans を $ 1,000,000,007(=10^9+7) $ で割った余りを出力してください。

### 算法分类
组合数学

### 题解分析与结论
题目要求计算满足 $1 \leq a_1 \leq a_2 \leq \dots \leq a_k \leq n$ 的整数组 $(a_1, a_2, \dots, a_k)$ 的个数。这实际上是一个组合数学问题，可以通过组合数公式来解决。

### 所选题解
#### 题解1：Soohti (5星)
**关键亮点：**
- 通过数学变换得出通项公式 $ans = \frac{\prod_{i=0}^{k-1}(n+i)}{k!}$。
- 使用快速幂求逆元来处理除法取模问题。
- 代码简洁高效，直接计算组合数并输出结果。

**核心代码：**
```cpp
int pom(int a,int b){
    int r=1;
    for(;b;b>>=1,a=1LL*a*a%P)
        if(b&1)r=1LL*r*a%P;
    return r;
}
int main(){
    scanf("%d%d",&n,&k);
    s=n;f=1;
    for(int i=2;i<=k;i++)
        s=1LL*s*(n+i-1)%P,
        f=1LL*f*i%P;
    printf("%d\n",1LL*s*pom(f,P-2)%P);
    return 0;
}
```

#### 题解2：查帅 (4星)
**关键亮点：**
- 通过递推公式 $dp[i][j] = dp[i-1][j] + dp[i][j-1]$ 进行动态规划。
- 使用滚动数组优化空间复杂度。
- 最终通过组合数公式得出答案，并使用快速幂求逆元。

**核心代码：**
```cpp
int main(){
    read(n) ; read(k) ;
    int p = 0 ;
    for(int i = 1 ; i <= n ; i++)
        dp[p][i] = i ;
    for(int q = 2 ; q <= k ; q++){
        p^=1 ;
        for(int i = 1 ; i <= n ; i++)
            dp[p][i] = (dp[p^1][i]+dp[p][i-1])%mod ;
    } 
    cout<<dp[p][n]<<endl ;
    return 0 ;
}
```

### 最优关键思路或技巧
- **组合数公式**：通过组合数公式 $\binom{n+k-1}{k}$ 直接计算满足条件的整数组个数。
- **快速幂求逆元**：处理大数取模问题，特别是除法取模时使用快速幂求逆元。
- **滚动数组优化**：在动态规划中，使用滚动数组优化空间复杂度。

### 可拓展之处
- 类似的问题可以扩展到多维度的组合数计算，如多重集合的组合数计算。
- 快速幂求逆元的技巧可以应用于其他需要处理大数取模的问题。

### 推荐题目
1. [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)
2. [P3807 卢卡斯定理](https://www.luogu.com.cn/problem/P3807)
3. [P1495 曹冲养猪](https://www.luogu.com.cn/problem/P1495)

### 个人心得
- **调试经历**：在实现过程中，确保组合数计算的正确性，特别是在处理大数取模时，需要仔细检查每一步的计算。
- **顿悟感想**：通过数学变换和组合数公式，可以将复杂的问题简化为简单的数学计算，这需要扎实的数学基础和灵活的思维。

---
处理用时：36.16秒
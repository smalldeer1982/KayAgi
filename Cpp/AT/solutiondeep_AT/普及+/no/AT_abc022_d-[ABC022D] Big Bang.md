# 题目信息

# [ABC022D] Big Bang

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc022/tasks/abc022_d

宇宙はビッグバンによって誕生して以来、膨張し続けていることが知られています。

天文学者である高橋君はその宇宙の膨張の速度を計測することにしました。

高橋君はある $ 2 $ つの日について、同じ $ N $ 個の星の位置を観測しました。星の位置は座標平面上の点として記録されます。つまり各日の観測結果は座標平面上の $ N $ 個の点からなる点集合になります。

$ 2 $ 回の観測の結果を見比べてみると、$ 1 $ 回目の観測結果である点集合に対して以下の $ 3 $ つの操作を順に実行すると $ 2 $ 回目の観測結果である点集合に一致することがわかりました。

1. 同じ向きに同じ距離だけ平行移動する。
2. 原点を中心に同じ角度だけ回転する。
3. 原点を中心に $ P $ 倍 $ (1\ ≦\ P) $ に相似拡大する。つまり点 $ (a,\ b) $ を点 $ (a×P,\ b×P) $ に移すという操作をすべての点に実行する。

ここで $ P $ の値がわかれば膨張速度を求めることができそうです。

いざ $ P $ を求めようとした高橋君でしたが、うっかりどの点がどの星に対応するのか記したデータをなくしてしまいました。

そこで高橋君は優秀なプログラマーであるあなたに助けを借りることにしました。

$ 1 $ 回目と $ 2 $ 回目の観測結果が与えられるので $ P $ を求めてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1\ ≦\ N\ ≦\ 3,000 $を満たすデータセットに正解した場合は $ 50 $ 点が与えられる。
- $ 1\ ≦\ N\ ≦\ 10^5 $を満たすデータセットに正解した場合はさらに $ 50 $ 点が与えられる。合計で$ 100 $点となる。

### Sample Explanation 1

以下のように操作を実行すれば、 $ 1 $ 回目の観測結果の点集合が、 $ 2 $ 回目の観測結果の点集合に移されます。 1. $ x $ 軸方向に $ -0.5 $、 $ y $ 軸方向に $ -0.5 $ 平行移動させる。 2. 原点を中心にして、$ 45° $ 時計回りに回転させる。 3. 原点を中心に $ 2√2 $ 倍する。 よって $ P\ =\ 2√2 $ となります。

## 样例 #1

### 输入

```
4

0 0

0 1

1 0

1 1

0 2

2 0

-2 0

0 -2```

### 输出

```
2.8284271247```

## 样例 #2

### 输入

```
6

3 4

1 3

4 3

2 2

0 1

2 0

5 5

-1 2

-1 -3

2 1

2 6

4 -3```

### 输出

```
2.2360679775```

# AI分析结果

### 题目内容重写
【题目描述】
宇宙自大爆炸以来一直在膨胀。天文学家高桥君想要测量宇宙的膨胀速度。他观测了两天中相同的N颗星的位置，记录为平面坐标系中的点。他发现，第一天的点集经过以下三个操作后，可以变成第二天的点集：
1. 相同的平移。
2. 相同的旋转。
3. 以原点为中心的相似放大，放大倍数为P（P≥1）。
高桥君丢失了点与星之间的对应关系，因此需要你帮助他计算P的值。

【输入格式】
第一行输入N，表示星的数量。接下来2N行，每行两个整数，表示第一天和第二天的星的位置坐标。

【输出格式】
输出P的值，保留10位小数。

【样例输入】
```
4
0 0
0 1
1 0
1 1
0 2
2 0
-2 0
0 -2
```

【样例输出】
```
2.8284271247
```

【说明/提示】
部分分：
- 对于1≤N≤3,000的数据，正确得50分。
- 对于1≤N≤10^5的数据，正确得50分，总计100分。

### 算法分类
数学

### 题解分析与结论
1. **ming2023的题解**（4星）
   - **关键亮点**：通过计算两个点集的凸包面积，利用面积比求解P。思路清晰，代码实现较为简洁。
   - **核心代码**：
     ```cpp
     long double S1=0;
     for(int i=1;i<=m-2;i++) {
         Point a=ch[0],b=ch[i],c=ch[i+1];
         S1+=Cross(b-a,c-a);
     }
     printf("%.9Lf\n",sqrt(S2/S1));
     ```
   - **总结**：通过凸包面积计算P，利用了相似图形的面积比例关系，时间复杂度较低。

2. **Erica_N_Contina的题解**（4星）
   - **关键亮点**：通过计算点集的重心，找到对应点，再计算距离比求解P。思路新颖，代码实现较为简单。
   - **核心代码**：
     ```cpp
     double disa=dis(a[1].x,a[1].y,sumx,sumy);
     double disb=dis(b[1].x,b[1].y,suma,sumb);
     printf("%.10lf\n",disb/disa);
     ```
   - **总结**：通过重心和距离比计算P，避免了复杂的几何计算，时间复杂度较低。

3. **AkeuchiTsuzuri的题解**（4星）
   - **关键亮点**：通过计算点集重心到各点的距离和，利用距离和比求解P。思路简洁，代码实现高效。
   - **核心代码**：
     ```cpp
     double ansa=0,ansb=0;
     for(int i=1;i<=n;i++) {
         ansa+=dis(s1,a[i].first,s3,a[i].second);
         ansb+=dis(s2,b[i].first,s4,b[i].second);
     }
     printf("%.12lf\n",ansb/ansa);
     ```
   - **总结**：通过距离和比计算P，利用了相似图形的距离比例关系，时间复杂度较低。

### 最优关键思路
通过计算点集的几何特征（如凸包面积、重心、距离和等），利用相似图形的比例关系求解P。这种方法避免了复杂的点对应关系，简化了计算过程。

### 可拓展之处
类似的问题可以扩展到三维空间中的相似变换，或者考虑更复杂的几何变换（如仿射变换）。

### 推荐题目
1. [P1357 相似图形](https://www.luogu.com.cn/problem/P1357)
2. [P1358 相似三角形](https://www.luogu.com.cn/problem/P1358)
3. [P1359 相似多边形](https://www.luogu.com.cn/problem/P1359)

---
处理用时：29.79秒
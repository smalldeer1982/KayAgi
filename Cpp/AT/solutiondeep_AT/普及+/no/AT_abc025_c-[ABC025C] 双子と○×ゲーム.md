# 题目信息

# [ABC025C] 双子と○×ゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc025/tasks/abc025_c

直大くんと直子さんは双子の兄妹です。時々、休日に $ 2 $ 人でゲームをしています。

ゲームは○×ゲームをベースにしており、以下の要領でゲームが行われます。

- ゲームは縦 $ 3 $ マス、横 $ 3 $ マスの盤面を使います。ゲーム開始時点ではどのマスにも文字が書かれていません。
- 挨拶した後、直大くんから始めて交互に文字を書いていきます。文字は盤面上のまだ文字が書かれていないマスの上にのみ書くことができます。そのようなマスが複数ある場合は好きな $ 1 $ 箇所を選んで書きます。書く文字は、直大くんが○、直子さんが×です。
- 合わせて $ 9 $ 回文字を書いた時点で、すべてのマスが埋まります。その後、得点計算を行い、得点の高い方が勝ちます。

得点計算は以下の方法で行われます。ここで、盤面の左上のマスをマス $ (1,\ 1) $ とし、左上から下に $ i-1\ (1\ ≦\ i\ ≦\ 3) $ マス、右に $ j-1\ (1\ ≦\ j\ ≦\ 3) $ マス進んだところにあるマスをマス $ (i,\ j) $ と呼ぶことにします。

- $ 1\ ≦\ i\ ≦\ 2 $ および $ 1\ ≦\ j\ ≦\ 3 $ を満たすすべての整数組 $ (i,j) $ に対して、マス $ (i,j) $ とマス $ (i+1,j) $ に書かれているマスを見て、同じ文字が書かれていたなら直大くんに、違う文字が書かれていたなら直子さんに $ b_{i,j} $ 点が入る。
- $ 1\ ≦\ i\ ≦\ 3 $ および $ 1\ ≦\ j\ ≦\ 2 $ を満たすすべての整数組 $ (i,j) $ に対して、マス $ (i,j) $ とマス $ (i,j+1) $ に書かれているマスを見て、同じ文字が書かれていたなら直大くんに、違う文字が書かれていたなら直子さんに $ c_{i,j} $ 点が入る。

直大くんも直子さんも、最終的に得られる自分の得点ができるだけ多くなるようにゲームを行います。両者が最善を尽くしたときのそれぞれの得点を計算してください。

## 说明/提示

### Sample Explanation 1

\- 例えば、マス $ (2,1) $ →マス $ (1,1) $ →マス $ (2,2) $ →マス $ (1,3) $ →マス $ (1,2) $ →マス $ (2,3) $ →マス $ (3,1) $ →マス $ (3,2) $ →マス $ (3,3) $ の順に文字が書かれた場合を考えます。この場合、盤面は最終的に以下のようになります。 ×○×○○×○×○- この場合、直大くんの得点は、$ (b_{1,2}\ +\ b_{1,3}\ +\ b_{2,1}\ +\ c_{1,2}\ =\ )\ 15\ +\ 0\ +\ 0\ +\ 0\ =\ 15 $ 点となります。 - 一方、直子さんの得点は、$ (b_{1,1}\ +\ b_{2,2}\ +\ b_{2,3}\ +\ c_{1,1}\ +\ c_{1,2}\ +\ c_{2,2}\ +\ c_{3,1}\ +\ c_{3,2}\ =\ )\ 0\ +\ 0\ +\ 25\ +\ 20\ +\ 10\ +\ 0\ +\ 25\ +\ 0\ =\ 80 $ 点となります。

## 样例 #1

### 输入

```
0 15 0

0 0 25

20 10

0 0

25 0```

### 输出

```
15

80```

## 样例 #2

### 输入

```
18 22 15

11 16 17

4 25

22 15

10 4```

### 输出

```
72

107```

# AI分析结果

### 题目内容重写

直大和直子是双胞胎兄妹。他们有时在休息日一起玩游戏。

游戏基于井字棋，规则如下：

- 游戏使用一个3x3的棋盘。游戏开始时，棋盘上没有任何标记。
- 游戏开始后，直大先手，两人交替在棋盘上未标记的格子中放置标记。直大放置“○”，直子放置“×”。
- 当所有9个格子都被标记后，游戏结束，进行得分计算，得分高的一方获胜。

得分计算方式如下：

- 对于所有满足1 ≤ i ≤ 2和1 ≤ j ≤ 3的整数对(i, j)，如果格子(i, j)和格子(i+1, j)上的标记相同，直大获得b_{i,j}分；否则，直子获得b_{i,j}分。
- 对于所有满足1 ≤ i ≤ 3和1 ≤ j ≤ 2的整数对(i, j)，如果格子(i, j)和格子(i, j+1)上的标记相同，直大获得c_{i,j}分；否则，直子获得c_{i,j}分。

直大和直子都会尽力使自己的得分最大化。请计算双方在最佳策略下的最终得分。

### 算法分类
深度优先搜索 DFS

### 题解分析与结论

#### 题解1：残阳如血
- **星级**：4星
- **关键亮点**：
  - 使用DFS进行全盘搜索，通过递归模拟每一步的落子。
  - 利用全局变量保存棋盘状态，减少参数传递。
  - 通过当前步数的奇偶性判断当前玩家，分别进行最大化和最小化操作。
  - 利用得分总和的性质，减少计算量，只需计算一方的得分即可推出另一方的得分。
- **核心代码**：
  ```cpp
  int dfs(int step) {
      if (step == 9) {
          int res = 0;
          for (int i = 0; i < 2; ++i)
              for (int j = 0; j < 3; ++j)
                  if (board[i][j] == board[i + 1][j]) res += b[i][j];
          for (int i = 0; i < 3; ++i)
              for (int j = 0; j < 2; ++j)
                  if (board[i][j] == board[i][j + 1]) res += c[i][j];
          return res;
      }
      if (step & 1) {
          int res = 2e9;
          for (int i = 0; i < 3; ++i)
              for (int j = 0; j < 3; ++j) {
                  if (!board[i][j]) {
                      board[i][j] = 'o';
                      res = std::min(res, dfs(step + 1));
                      board[i][j] = 0;
                  }
              }
          return res;
      } else {
          int res = 0;
          for (int i = 0; i < 3; ++i)
              for (int j = 0; j < 3; ++j) {
                  if (!board[i][j]) {
                      board[i][j] = 'x';
                      res = std::max(res, dfs(step + 1));
                      board[i][j] = 0;
                  }
              }
          return res;
      }
  }
  ```

#### 题解2：AkeuchiTsuzuri
- **星级**：3星
- **关键亮点**：
  - 同样使用DFS进行全盘搜索，但代码结构较为简单。
  - 通过递归模拟每一步的落子，分别进行最大化和最小化操作。
  - 利用得分总和的性质，减少计算量。
- **核心代码**：
  ```cpp
  int dfs(int now[4][4],int cnt) {
      if(cnt==9) {
          int res=0;
          for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) if(now[i][j]==now[i+1][j]) res+=b[i][j];
          for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) if(now[i][j]==now[i][j+1]) res+=c[i][j];
          return res;
      }
      int s=INT_MAX;
      if(cnt%2==0) {
          s=-INT_MAX;
          for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) {
              if(now[i][j]!=0) continue;
              now[i][j]=1;
              s=std::max(s,dfs(now,cnt+1));
              now[i][j]=0;
          }
      } else {
          for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) {
              if(now[i][j]!=0) continue;
              now[i][j]=-1;
              s=std::min(s,dfs(now,cnt+1));
              now[i][j]=0;
          }
      }
      return s;
  }
  ```

### 最优关键思路或技巧
- **DFS全盘搜索**：通过DFS模拟每一步的落子，分别进行最大化和最小化操作，确保双方都在最佳策略下进行游戏。
- **得分总和性质**：利用得分总和不变的性质，只需计算一方的得分即可推出另一方的得分，减少计算量。

### 可拓展之处
- 类似的问题可以扩展到更大的棋盘或不同的得分规则，DFS仍然适用，但需要考虑剪枝优化以减少计算量。

### 推荐题目
1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

---
处理用时：40.68秒
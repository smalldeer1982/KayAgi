# 题目信息

# [ABC026D] 高橋君ボール1号

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc026/tasks/abc026_d

高橋君は野球が得意です。高橋君は、高橋君ボール $ 1 $ 号という変化球を投げることが出来ます。

このボールは、投げてから $ t $ 秒後のボールの位置を $ f(t) $ とすると、 $ f(t)\ =\ A\ \times\ t\ +\ B\ \times{\rm\ sin}(C\ \times\ t\ \times\ π) $ と表すことが出来ます。

あなたは、$ t\ ≧\ 0 $ かつ $ f(t)\ =\ 100 $ となるタイミングで、ボールを打たなければいけません。この時の $ t $ を求めたいです。

## 说明/提示

### Sample Explanation 1

$ t\ =\ 100 $ のとき、 $ f(t)\ =\ 100 $ となります。

### Sample Explanation 2

解が一つではないことに注意してください。

## 样例 #1

### 输入

```
1 1 1```

### 输出

```
100```

## 样例 #2

### 输入

```
53 82 49```

### 输出

```
1.63372043395339```

# AI分析结果

### 题目内容重写
【题目描述】
高橋君擅长打棒球。他能够投掷一种名为“高橋君ボール1号”的变化球。这个球在投掷后t秒的位置可以表示为函数 \( f(t) = A \times t + B \times \sin(C \times t \times \pi) \)。你需要找到 \( t \geq 0 \) 且 \( f(t) = 100 \) 的时刻 \( t \)。

【样例解释1】
当 \( t = 100 \) 时，\( f(t) = 100 \)。

【样例解释2】
注意解可能不唯一。

### 算法分类
二分

### 综合分析与结论
本题的核心是通过二分法求解方程 \( f(t) = 100 \) 的解。由于函数 \( f(t) \) 不是严格单调的，因此直接使用二分法可能会遇到多个解的情况。但题目只要求找到一个解，因此二分法仍然适用。以下是各题解的要点对比：

1. **Walter_Fang** 和 **ys2012** 的题解都使用了二分法，通过多次迭代来逼近解。Walter_Fang 的代码中使用了 `acos(-1.0)` 来计算圆周率，而 ys2012 的代码中直接定义了圆周率的值。两者的代码实现都非常简洁，适合初学者理解。
2. **0x00AC3375** 的题解使用了牛顿法，这是一种更高效的数值方法，适用于非单调函数的求解。牛顿法的收敛速度通常比二分法快，但需要计算导数，实现稍复杂。

### 所选高分题解
#### 1. Walter_Fang (5星)
**关键亮点**：
- 使用二分法，代码简洁易懂。
- 通过 `acos(-1.0)` 计算圆周率，避免了直接定义常数的误差。

**核心代码**：
```cpp
double f(double x){  //题目中给出的f(x)函数 
	return a*x+b*sin(c*x*pi);
}
int main(){
    cin>>a>>b>>c;
    l=1;r=INT_MAX;  //区间限定 
    for(i=1;i<=114514;i++){  //二分多做几次 
        x=(l+r)/2;
        if(f(x)<=100)l=x;
        else r=x;
    }
    printf("%.12lf",l);  //进行输出 
}
```

#### 2. ys2012 (4星)
**关键亮点**：
- 使用二分法，代码简洁。
- 直接定义了圆周率的值，代码更直观。

**核心代码**：
```cpp
double fac(double mid){
	return a*mid+b*sin(c*mid*pi);//求 mid 于公式内的答案 
} 
signed main()
{
	fast; 
	cin>>a>>b>>c;
	double l=0,r=3e9;//小数二分用 double 定义变量 
	for(ll laoda=1;laoda<=1000000;++laoda){//二分 
		double mid=(l+r)/2;//给定 mid 为中间值
		if(fac(mid)<=100){//判断如何改变左值和右值的条件
			l=mid;
		}else{
			r=mid;
		}
	}
	printf("%.12lf",l);//输出 
}
```

#### 3. 0x00AC3375 (4星)
**关键亮点**：
- 使用牛顿法，收敛速度快。
- 详细解释了牛顿法的原理和实现。

**核心代码**：
```cpp
long double F(long double x)
{
	return A*x+B*sinl(C*pi*x)-100.L;
}
long double derivateF(long double x)
{
	return A+B*C*pi*cosl(C*pi*x);
}
int main()
{
	cin>>A>>B>>C;
	int r=0;
	sln[0]=100.L/A;
	while(r<=9998)
	{
		sln[r+1]=sln[r]-1.0L*F(sln[r])/derivateF(sln[r]);
		if(fabs(sln[r+1]-sln[r])<=eps) break;
		r+=1;
	}
	printf("%.14Lf",sln[r]);
}
```

### 最优关键思路或技巧
- **二分法**：适用于求解非线性方程的近似解，尤其是当函数单调性不明显时。
- **牛顿法**：适用于求解非线性方程的近似解，收敛速度快，但需要计算导数。

### 可拓展之处
- 类似的问题可以扩展到其他非线性方程的求解，如求解 \( f(x) = k \) 的解。
- 可以使用其他数值方法，如割线法、弦截法等。

### 推荐题目
1. [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)
2. [P1883 函数](https://www.luogu.com.cn/problem/P1883)
3. [P3382 【模板】三分法](https://www.luogu.com.cn/problem/P3382)

### 个人心得摘录
- **Walter_Fang**：二分法不需要严格的终止条件，只需多做几次迭代即可。
- **0x00AC3375**：牛顿法虽然收敛快，但需要选择合适的初始值，否则可能无法收敛。

---
处理用时：35.06秒
# 题目信息

# [ABC031D] 語呂合わせ

## 题目描述

日本有一种将数字与短字符串对应的记忆文化。

对此产生兴趣的高桥君，决定推断出仅由 $1$ 以上 $K$ 以下的数字组成的正整数 $v_1,v_2,\cdots,v_n$ 以及对应的字符串 $w_1,w_2,\cdots,w_n$ 的组合 $(v_1,w_1),(v_2,w_2),\cdots,(v_n,w_n)$ 中，哪个数字对应哪个字符串。

也就是说，想要找出满足以下条件的 $K$ 个字符串 $s_1,s_2,\cdots,s_K$。

- 对于满足 $1 \leqq i \leqq K$ 的任意整数 $i$，必须满足 $1 \leqq |s_i| \leqq 3$。
- 对于满足 $1 \leqq i \leqq N$ 的任意整数 $i$，当将整数 $v_i$ 按位分解时，得到的数字从上到下依次为 $d_1,d_2,\cdots,d_l$，则将字符串 $s_{d_1},s_{d_2},\cdots,s_{d_l}$ 按此顺序连接的字符串等于 $w_i$。

请编写程序输出 $K$ 个字符串 $s_1,s_2,\cdots,s_k$。

## 样例 #1

### 输入

```
6 4

356 migoro

461 yoroi

2 ni

12 ini```

### 输出

```
i

ni

mi

yo

go

ro```

## 样例 #2

### 输入

```
3 4

21 aaa

12 aaa

123 aaaaaa

13 aaaa```

### 输出

```
a

aa

aaa```

## 样例 #3

### 输入

```
2 3

12211 abcaaaaabcabc

2121 aaabcaaabc

222221 aaaaaaaaaaabc```

### 输出

```
abc

aa```

## 样例 #4

### 输入

```
2 1

12 abcab```

### 输出

```
ab

cab```

# AI分析结果

### 题目内容重写

【题目描述】

日本有一种将数字与短字符串对应的记忆文化。

对此产生兴趣的高桥君，决定推断出仅由 $1$ 以上 $K$ 以下的数字组成的正整数 $v_1,v_2,\cdots,v_n$ 以及对应的字符串 $w_1,w_2,\cdots,w_n$ 的组合 $(v_1,w_1),(v_2,w_2),\cdots,(v_n,w_n)$ 中，哪个数字对应哪个字符串。

也就是说，想要找出满足以下条件的 $K$ 个字符串 $s_1,s_2,\cdots,s_K$。

- 对于满足 $1 \leqq i \leqq K$ 的任意整数 $i$，必须满足 $1 \leqq |s_i| \leqq 3$。
- 对于满足 $1 \leqq i \leqq N$ 的任意整数 $i$，当将整数 $v_i$ 按位分解时，得到的数字从上到下依次为 $d_1,d_2,\cdots,d_l$，则将字符串 $s_{d_1},s_{d_2},\cdots,s_{d_l}$ 按此顺序连接的字符串等于 $w_i$。

请编写程序输出 $K$ 个字符串 $s_1,s_2,\cdots,s_k$。

### 算法分类

**搜索**

### 题解分析与结论

该题的核心问题是通过给定的数字和字符串组合，推断出每个数字对应的字符串。由于每个数字对应的字符串长度在1到3之间，且需要满足所有给定的组合条件，因此可以采用**深度优先搜索（DFS）**的方法来枚举所有可能的字符串长度组合，并验证其合法性。

### 所选题解

#### 题解作者：Nazale_

**星级：4星**

**关键亮点：**
1. **思路清晰**：通过DFS枚举每个数字对应的字符串长度，然后验证所有组合是否合法。
2. **代码简洁**：代码结构清晰，易于理解。
3. **优化合理**：通过剪枝（如长度不匹配时直接返回）减少了不必要的搜索。

**个人心得：**
- 作者提到“找到情况就输出”，这表明在搜索过程中一旦找到合法解就立即输出并结束程序，避免了不必要的继续搜索。

**核心代码：**

```cpp
void dfs(int pos){
    if(pos>k){
        for (int i=1;i<=k;i++) s[i]="";
        for (int i=1;i<=n;i++){
            int sum=0;
            for (int j=0;j<v[i].length();j++){
                sum+=len[v[i][j]-'0']; 
            }
            if(sum!=w[i].length()) return;
            int st=0;
            for (int j=0;j<v[i].length();j++){
                string str=w[i].substr(st,len[v[i][j]-'0']);
                if(s[v[i][j]-'0']=="") s[v[i][j]-'0']=str;
                else if(s[v[i][j]-'0']!=str) return;
                st+=len[v[i][j]-'0'];
            }
        }
        if(!f){
            for (int i=1;i<=k;i++){
                cout<<s[i]<<"\n";
            }
            exit(0);
        }
    }
    for (int i=1;i<=3;i++){
        len[pos]=i;
        dfs(pos+1);
    }
}
```

**核心实现思想：**
- `dfs`函数递归地枚举每个数字对应的字符串长度（1到3）。
- 在枚举完成后，验证所有给定的数字和字符串组合是否合法。
- 如果合法，则输出结果并结束程序。

### 最优关键思路或技巧

- **DFS枚举**：通过DFS枚举每个数字对应的字符串长度，确保所有组合的合法性。
- **剪枝优化**：在验证过程中，如果发现长度不匹配或字符串不一致，立即返回，减少不必要的搜索。

### 可拓展之处

- **类似问题**：可以扩展到其他需要枚举所有可能组合并验证合法性的问题，如密码破解、拼图游戏等。
- **优化思路**：可以考虑使用记忆化搜索或动态规划来进一步优化搜索过程。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 考察DFS和剪枝的应用。
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 经典的DFS问题，适合练习枚举和剪枝。
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433) - 通过DFS枚举所有可能的路径，适合练习搜索算法。

---
处理用时：29.08秒
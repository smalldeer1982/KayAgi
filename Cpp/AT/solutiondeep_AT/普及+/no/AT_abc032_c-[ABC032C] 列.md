# 题目信息

# [ABC032C] 列

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc032/tasks/abc032_c

 長さ $ N $ の非負整数列 $ S={s_1,s_2,...,s_N} $ と整数 $ K $ があります。 あなたの仕事は、以下の条件を満たす $ S $ の **連続する** 部分列のうち、最も長いものの長さを求めることです。部分列の長さは $ 1 $ 以上の列でないといけません。

- その部分列に含まれる全ての要素の値の積は、$ K $ 以下である。

もし条件を満たす部分列が一つも存在しないときは、$ 0 $ を出力してください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。満点は $ 100 $ 点である。

- $ N≦1000 $ を満たすデータセット $ 1 $ に正解した場合は、$ 20 $ 点が与えられる。
- 追加制約のないデータセット $ 2 $ に正解した場合、上記の点数に加え $ 80 $ 点が与えられる。

### Sample Explanation 1

部分列 $ S[2..5]=s_2,s_3,s_4,s_5 $ を選ぶと、積は $ 3×1×1×2=6 $ となり、$ K $ 以下になります。

## 样例 #1

### 输入

```
7 6

4

3

1

1

2

10

2```

### 输出

```
4```

## 样例 #2

### 输入

```
6 10

10

10

10

10

0

10```

### 输出

```
6```

## 样例 #3

### 输入

```
6 9

10

10

10

10

10

10```

### 输出

```
0```

## 样例 #4

### 输入

```
4 0

1

2

3

4```

### 输出

```
0```

# AI分析结果

### 题目内容重写
题目描述：

给定一个长度为 $N$ 的非负整数序列 $S = \{s_1, s_2, \dots, s_N\}$ 和一个整数 $K$。你的任务是找到满足以下条件的 $S$ 的**连续**子序列中最长的长度。子序列的长度必须大于等于 $1$。

- 该子序列中所有元素的乘积不超过 $K$。

如果不存在满足条件的子序列，则输出 $0$。

### 算法分类
双指针

### 题解分析与结论
本题的核心是通过双指针维护一个滑动窗口，动态计算窗口内元素的乘积，并确保该乘积不超过 $K$。以下是各题解的要点对比：

1. **残阳如血**：
   - 使用双指针维护区间 $[i, j]$，并动态计算区间内元素的乘积 $s$。
   - 特别注意当 $i$ 移出区间时，只有当 $j \geq i$ 时才除以 $a_i$。
   - 代码简洁，逻辑清晰。

2. **InversionShadow**：
   - 同样使用双指针维护区间，动态维护区间乘积 $ans$。
   - 代码结构与残阳如血类似，但变量命名略有不同。

3. **CatnipQwQ**：
   - 使用双指针维护右端点 $r$，并动态计算区间内元素的乘积 $prod$。
   - 特别处理了 $r < i$ 的情况，确保区间合法。
   - 代码逻辑较为复杂，但处理了更多边界情况。

### 评分与关键亮点
1. **残阳如血**（5星）
   - 关键亮点：代码简洁，逻辑清晰，处理了特殊情况（存在 $0$ 的情况）。
   - 代码核心：
     ```cpp
     for (int i = 1, j = 0; i <= n && j <= n; ++i) {
         while (j < n && s * a[j + 1] <= k) s *= a[++j];
         len = std::max(len, j - i + 1);
         if (j >= i) s /= a[i];
     }
     ```

2. **InversionShadow**（4星）
   - 关键亮点：代码结构清晰，变量命名合理。
   - 代码核心：
     ```cpp
     for (int i = 1, j = 0; i <= n; i++) {
         while (j < n && ans * a[j + 1] <= k) {
             ans *= a[++j];
             mx = max(mx, j - i + 1);
         }
         if (j >= i) {
             ans /= a[i];
         }
     }
     ```

3. **CatnipQwQ**（4星）
   - 关键亮点：处理了更多边界情况，逻辑较为全面。
   - 代码核心：
     ```cpp
     for (int i = 1; i <= n; i++) {
         while (r < n && 1ll * prod * a[r + 1] <= k) {
             r++;
             prod *= a[r];
         }
         ans = max(ans, r - i + 1);
         if (r < i) {
             r = i;
             prod = 1;
         } else
             prod /= a[i];
     }
     ```

### 最优关键思路
使用双指针维护滑动窗口，动态计算窗口内元素的乘积，并确保该乘积不超过 $K$。特别处理窗口左移时除以左端点元素的情况，以及存在 $0$ 时的特殊情况。

### 可拓展之处
类似的双指针技巧可以应用于其他滑动窗口问题，如最长连续子数组和、最长无重复字符子串等。

### 推荐题目
1. [P1007 最长连续子序列和](https://www.luogu.com.cn/problem/P1007)
2. [P1008 最长无重复字符子串](https://www.luogu.com.cn/problem/P1008)
3. [P1009 最长连续递增子序列](https://www.luogu.com.cn/problem/P1009)

### 个人心得
- **残阳如血**：特别注意了当 $i$ 移出区间时，只有当 $j \geq i$ 时才除以 $a_i$，避免了不必要的计算。
- **CatnipQwQ**：处理了 $r < i$ 的情况，确保区间合法，逻辑较为全面。

---
处理用时：32.61秒
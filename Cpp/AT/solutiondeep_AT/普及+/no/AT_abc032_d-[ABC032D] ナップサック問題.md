# 题目信息

# [ABC032D] ナップサック問題

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc032/tasks/abc032_d

0/1ナップサック問題を解いてください。0/1ナップサック問題とは以下のような問題のことです。

- $ N $ 個の荷物があり、$ i\ (1≦i≦N) $ 番目の荷物には価値 $ v_i $ と重さ $ w_i $ が割り当てられている。
- 許容重量 $ W $ のナップサックが1つある。
- 重さの和が $ W $ 以下となるように荷物の集合を選びナップサックに詰め込むとき、価値の和の最大値を求めよ。ただし、同じ荷物は一度しか選ぶことができない。

## 说明/提示

### 部分点

この問題には部分点が設定されている。満点は $ 100 $ 点である。

- $ N≦30 $ を満たすデータセット $ 1 $ に正解した場合は、$ 34 $ 点が与えられる。
- $ N≦200 $ かつ全ての $ i(1≦i≦N) $ について $ 1≦w_i≦1000 $ を満たすデータセット $ 2 $ に正解した場合は、上記の点数とは別に $ 33 $ 点が与えられる。
- $ N≦200 $ かつ全ての $ i(1≦i≦N) $ について $ 1≦v_i≦1000 $ を満たすデータセット $ 3 $ に正解した場合は、上記の点数とは別に $ 33 $ 点が与えられる。

### Sample Explanation 1

$ 2 $ 番目と $ 3 $ 番目のアイテムを選ぶと、合計の重みが $ 10 $ で価値が $ 16 $ となり、最大価値を達成できます。 この入出力例は、データセット $ 1,2,3 $ の制約を満たしているため、全てのデータセットの採点に用いられます。

### Sample Explanation 2

この入出力例は、データセット $ 1 $ の制約のみ満たしているため、データセット $ 2,3 $ の採点には用いられません。

### Sample Explanation 3

この入出力例は、データセット $ 3 $ の制約を満たしていないため、データセット $ 3 $ の採点には用いられません。

### Sample Explanation 4

この入出力例は、データセット $ 2 $ の制約を満たしていないため、データセット $ 2 $ の採点には用いられません。

## 样例 #1

### 输入

```
3 10

15 9

10 6

6 4```

### 输出

```
16```

## 样例 #2

### 输入

```
30 499887702

128990795 137274936

575374246 989051853

471048785 85168425

640066776 856699603

819841327 611065509

704171581 22345022

536108301 678298936

119980848 616908153

117241527 28801762

325850062 478675378

623319578 706900574

998395208 738510039

475707585 135746508

863910036 599020879

340559411 738084616

122579234 545330137

696368935 86797589

665665204 592749599

958833732 401229830

371084424 523386474

463433600 5310725

210508742 907821957

685281136 565237085

619500108 730556272

88215377 310581512

558193168 136966252

475268130 132739489

303022740 12425915

122379996 137199296

304092766 23505143```

### 输出

```
3673016420```

## 样例 #3

### 输入

```
10 2921

981421680 325

515936168 845

17309336 371

788067075 112

104855562 96

494541604 960

32007355 161

772339969 581

55112800 248

98577050 22```

### 输出

```
3657162058```

## 样例 #4

### 输入

```
10 936447862

854 810169801

691 957981784

294 687140254

333 932608409

832 42367415

642 727293784

139 870916042

101 685539955

853 243593312

369 977358410```

### 输出

```
1686```

# AI分析结果

### 题目内容重写
#### [ABC032D] 背包问题

##### 题目描述
给定一个0/1背包问题，具体描述如下：
- 有 $N$ 个物品，第 $i$ 个物品的价值为 $v_i$，重量为 $w_i$。
- 有一个容量为 $W$ 的背包。
- 要求从这些物品中选择一些放入背包，使得总重量不超过 $W$，且总价值最大。每个物品只能选择一次。

##### 说明/提示
###### 部分点
- 数据点1：$N \leq 30$，得34分。
- 数据点2：$N \leq 200$，且所有物品的重量 $w_i \leq 1000$，得33分。
- 数据点3：$N \leq 200$，且所有物品的价值 $v_i \leq 1000$，得33分。

##### 样例输入输出
###### 样例1
输入：
```
3 10
15 9
10 6
6 4
```
输出：
```
16
```

### 算法分类
动态规划

### 题解分析与结论
该题目是一个经典的0/1背包问题，但由于数据范围较大，需要根据不同的数据范围采用不同的解法。主要思路如下：
1. **Subtask 1**：$N \leq 30$，采用**Meet in the Middle**算法，将问题分为两部分，分别搜索并合并结果，时间复杂度为 $O(2^{n/2})$。
2. **Subtask 2**：$N \leq 200$，且 $w_i \leq 1000$，采用**动态规划**，状态转移方程为 $f_{i,j} = \max(f_{i-1,j}, f_{i-1,j-w_i} + v_i)$，时间复杂度为 $O(n \cdot W)$。
3. **Subtask 3**：$N \leq 200$，且 $v_i \leq 1000$，采用**动态规划**，但状态定义为 $f_{i,j}$ 表示前 $i$ 个物品中总价值为 $j$ 的最小体积，时间复杂度为 $O(n \cdot \sum v_i)$。

### 精选题解
#### 题解1：残阳如血
**星级：5**
**关键亮点**：
- 详细解释了不同数据范围的解法，特别是**Meet in the Middle**算法的实现。
- 代码结构清晰，注释详细，易于理解。
- 通过前缀最大值优化了搜索过程，提高了效率。

**核心代码**：
```cpp
void dfs1(int i, lint sv, lint sw) {
	if (i > x) {
		mp[sv] = std::max(mp[sv], sw);
		return ;
	}
	dfs1(i + 1, sv, sw);
	if (sv + v[i] <= V) dfs1(i + 1, sv + v[i], sw + w[i]);
}

void dfs2(int i, lint sv, lint sw) {
	if (i > n) {
		ans = std::max(ans, (--mp.upper_bound(V - sv))->second + sw);
		return ;
	}
	dfs2(i + 1, sv, sw);
	if (sv + v[i] <= V) dfs2(i + 1, sv + v[i], sw + w[i]);
}
```

#### 题解2：_AyachiNene
**星级：4**
**关键亮点**：
- 直接分类讨论，思路简洁明了。
- 代码实现简单，适合初学者理解。
- 通过状态定义的转换，解决了Subtask 3的问题。

**核心代码**：
```cpp
void dfs(int x, ll sumw, ll sumv) {
	if (x > n) {
		ans = max(ans, sumw);
		return;
	}
	if (v[x] <= sumv)
		dfs(x + 1, sumw + w[x], sumv - v[x]);
	dfs(x + 1, sumw, sumv);
}
```

#### 题解3：lylcpp
**星级：4**
**关键亮点**：
- 代码简洁，逻辑清晰。
- 通过状态定义的转换，解决了Subtask 3的问题。
- 代码中使用了前缀和优化，提高了效率。

**核心代码**：
```cpp
void dfs(int x, ll sp, ll sum) {
	if (x > n) {
		ans = max(ans, sum);
		return ;
	}
	if (w[x] <= sp) 
		dfs(x + 1, sp - w[x], sum + v[x]);
	dfs(x + 1, sp, sum);
}
```

### 最优关键思路
1. **Meet in the Middle**：将问题分为两部分，分别搜索并合并结果，适用于 $N \leq 30$ 的情况。
2. **动态规划状态转换**：根据数据范围的不同，灵活定义状态，如将体积转换为价值，或反之。

### 拓展思路
- 对于更大范围的背包问题，可以考虑**分支限界法**或**启发式搜索**。
- 类似问题：多重背包问题、完全背包问题。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：37.08秒
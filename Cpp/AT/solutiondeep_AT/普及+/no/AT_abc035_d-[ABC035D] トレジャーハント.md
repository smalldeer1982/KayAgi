# 题目信息

# [ABC035D] トレジャーハント

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc035/tasks/abc035_d

高橋君が住む国には $ N $ 箇所の町と町同士をつなぐ一方通行の道が $ M $ 本あり、それぞれの町には $ 1 $ から $ N $ の番号が割りふられています。 $ i $ 番目の道は $ a_i $ 番の町から $ b_i $ 番の町へ移動することが可能であり、移動に $ c_i $ 分だけかかります。

所持金が $ 0 $ 円の高橋君は $ T $ 分間のトレジャーハントに出かけることにしました。高橋君は開始 $ 0 $ 分の時点で $ 1 $ 番の町にいます。また、開始から $ T $ 分の時点にも $ 1 $ 番の町にいなくてはなりません。高橋君が $ i $ 番の町に $ 1 $ 分間滞在すると、 $ A_i $ 円が高橋君の所持金に加算されます。

$ T $ 分間のトレジャーハントによって高橋君の所持金は最大いくらになるか求めてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1≦N≦200 $ を満たすデータセットに正解した場合 $ 50 $ 点が与えられる。
- 追加制約のないデータセットに正解した場合は、追加で $ 50 $ 点が与えられ、合計 $ 100 $ 点が得られる。

### Sample Explanation 1

\- 開始から $ 0 $ 分の時点から $ 2 $ 分かけて町 $ 1 $ から町 $ 2 $ に移動します。 - 開始から $ 2 $ 分の時点から $ 2 $ 分間、町 $ 2 $ に滞在します。所持金は $ 6 $ 円になります。 - 開始から $ 4 $ 分の時点から $ 1 $ 分かけて町 $ 2 $ から町 $ 1 $ に移動します。 - 開始から $ 5 $ 分の時点で町 $ 1 $ にいます。トレジャーハントが終了します。 - このケースは部分点の制約を満たします。

### Sample Explanation 2

\- 開始 $ 0 $ 分の時点から $ 3 $ 分間、町 $ 1 $ に滞在するのが最適であり、所持金を $ 3 $ 円にすることができます。 - このケースは部分点の制約を満たします。

### Sample Explanation 3

\- このケースは部分点の制約を満たします。

## 样例 #1

### 输入

```
2 2 5

1 3

1 2 2

2 1 1```

### 输出

```
6```

## 样例 #2

### 输入

```
2 2 3

1 3

1 2 2

2 1 1```

### 输出

```
3```

## 样例 #3

### 输入

```
8 15 120

1 2 6 16 1 3 11 9

1 8 1

7 3 14

8 2 13

3 5 4

5 7 5

6 4 1

6 8 17

7 8 5

1 4 2

4 7 1

6 1 3

3 1 10

2 6 5

2 4 12

5 1 30```

### 输出

```
1488```

# AI分析结果

### 题目内容重写

高桥君居住的国家有 $N$ 个城镇，城镇之间由 $M$ 条单向道路连接，每个城镇编号从 $1$ 到 $N$。第 $i$ 条道路可以从城镇 $a_i$ 到城镇 $b_i$，移动需要花费 $c_i$ 分钟。

高桥君有 $0$ 日元，他决定进行一场 $T$ 分钟的寻宝活动。高桥君在开始时的 $0$ 分钟位于城镇 $1$，并且在 $T$ 分钟结束时也必须回到城镇 $1$。高桥君在城镇 $i$ 停留 $1$ 分钟，可以获得 $A_i$ 日元。

求高桥君在 $T$ 分钟内可以获得的最大金额。

### 算法分类
最短路、图论

### 题解分析与结论

#### 题解1：Erica_N_Contina
**星级：4星**
**关键亮点：**
1. 通过两次最短路算法（Dijkstra）分别计算从起点到各点的最短路径和各点到起点的最短路径。
2. 枚举每个点，计算在该点停留的最大收益，并更新全局最大值。
3. 代码结构清晰，逻辑严谨，考虑了所有可能的情况。

**核心代码：**
```cpp
void djstr(int rt) {
    pq.push(make_pair(0,rt));
    int u=rt;
    for(int i=1; i<=n; i++)dis[i]=INF;
    dis[rt]=0;
    vis[rt]=1;
    while(pq.size()) {
        u=pq.top().second;
        vis[u]=1;
        pq.pop();
        for(int i=0;i<e[u].size();i++){
            int v=e[u][i].nxt,w=e[u][i].dis;
            if(!vis[v]&&dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                pq.push(make_pair(-dis[v],v));
            }
        }
    }
}
```
**个人心得：**
- 作者提到最初的想法是考虑经过点 $1$ 的环，但发现删除路径难以实现，最终通过枚举每个点并计算最短路径来解决问题。

### 最优关键思路或技巧
1. **两次最短路算法**：分别计算从起点到各点的最短路径和各点到起点的最短路径，确保路径的合法性。
2. **枚举每个点**：通过枚举每个点，计算在该点停留的最大收益，确保全局最优解。
3. **反向边构建**：通过构建反向边，方便计算各点到起点的最短路径。

### 可拓展之处
1. **多起点多终点问题**：可以扩展到多个起点和终点的情况，计算每个起点到每个终点的最短路径。
2. **带权图的最短路径**：可以扩展到带权图的最短路径问题，考虑边的权重和点的权重。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

这些题目都涉及到最短路径的计算，可以帮助巩固和拓展相关知识。

---
处理用时：24.35秒
# 题目信息

# [ABC036D] 塗り絵

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc036/tasks/abc036_d

# AI分析结果

### 题目内容重写
#### [ABC036D] 塗り絵

**题目描述**

给定一棵由 \(N\) 个节点和 \(N-1\) 条边组成的树。每个节点可以被染成黑色或白色，但相邻的两个节点不能同时被染成黑色。求所有合法的染色方案数，结果对 \(10^9+7\) 取模。

### 算法分类
动态规划（树形DP）

### 题解分析与结论
本题的核心思路是通过树形动态规划（DP）来计算每个节点的染色方案数。所有题解都采用了类似的DP状态定义和转移方程，主要区别在于代码实现细节和优化程度。

#### 关键思路
1. **状态定义**：设 \(dp_{u,0}\) 表示节点 \(u\) 染成白色的方案数，\(dp_{u,1}\) 表示节点 \(u\) 染成黑色的方案数。
2. **转移方程**：
   - 如果节点 \(u\) 染成白色，则其子节点可以染成白色或黑色，因此 \(dp_{u,0} = \prod (dp_{v,0} + dp_{v,1})\)。
   - 如果节点 \(u\) 染成黑色，则其子节点只能染成白色，因此 \(dp_{u,1} = \prod dp_{v,0}\)。
3. **初始化**：对于叶子节点，\(dp_{u,0} = dp_{u,1} = 1\)。
4. **最终答案**：根节点的总方案数为 \(dp_{root,0} + dp_{root,1}\)。

#### 最优题解
1. **作者：MinimumSpanningTree (赞：5)**
   - **星级**：5星
   - **关键亮点**：代码简洁，逻辑清晰，状态转移方程明确，且使用了链式前向星存储树结构，优化了空间和时间复杂度。
   - **核心代码**：
     ```cpp
     void dfs(int x, int fa) {
         dp[1][x] = dp[2][x] = 1;
         for (int i = t[x]; i; i = a[i].last) {
             if (a[i].id == fa) continue;
             dfs(a[i].id, x);
             dp[1][x] = (dp[1][x] * dp[2][a[i].id]) % MOD;
             dp[2][x] = (dp[2][x] * ((dp[1][a[i].id] + dp[2][a[i].id]) % MOD)) % MOD;
         }
     }
     ```

2. **作者：Dreamer_xbt910 (赞：3)**
   - **星级**：4星
   - **关键亮点**：代码结构清晰，状态转移方程明确，使用了链式前向星存储树结构，且代码可读性较好。
   - **核心代码**：
     ```cpp
     void dfs(int x, int fa) {
         dp[x][0] = 1, dp[x][1] = 1;
         for (int i = head[x]; i; i = arr[i].next) {
             int y = arr[i].to;
             if (fa == y) continue;
             dfs(y, x);
             dp[x][0] *= dp[y][0] + dp[y][1];
             dp[x][1] *= dp[y][0];
             dp[x][1] %= mod;
             dp[x][0] %= mod;
         }
     }
     ```

3. **作者：AlanFong (赞：2)**
   - **星级**：4星
   - **关键亮点**：代码简洁，状态转移方程明确，使用了链式前向星存储树结构，且代码可读性较好。
   - **核心代码**：
     ```cpp
     void dfs(int x, int fa) {
         dp[x][0] = 1;
         dp[x][1] = 1;
         for (int i = head[x]; i; i = nxt[i]) {
             int y = to[i];
             if (y == fa) continue;
             dfs(y, x);
             dp[x][0] = dp[x][0] * (dp[y][1] + dp[y][0]) % mod;
             dp[x][1] = dp[x][1] * dp[y][0] % mod;
         }
     }
     ```

### 最优关键思路或技巧
1. **树形DP**：通过递归遍历树结构，从叶子节点开始计算每个节点的染色方案数，最终汇总到根节点。
2. **链式前向星**：使用链式前向星存储树结构，优化了空间和时间复杂度。
3. **状态转移方程**：明确的状态转移方程是解决树形DP问题的关键，确保每个节点的方案数能够正确计算。

### 可拓展之处
1. **类似问题**：可以扩展到其他树形DP问题，如树上最大独立集、树上最小支配集等。
2. **优化技巧**：在实际应用中，可以通过剪枝、记忆化搜索等技巧进一步优化树形DP的复杂度。

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)
3. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)

### 个人心得摘录
- **调试经历**：在实现树形DP时，确保状态转移方程的正确性非常重要，尤其是在处理边界条件和初始化时。
- **踩坑教训**：在计算方案数时，务必注意取模操作，避免溢出。
- **顿悟感想**：树形DP的核心在于将问题分解为子问题，并通过递归逐步解决，这种思维方式在解决复杂问题时非常有效。

---
处理用时：41.06秒
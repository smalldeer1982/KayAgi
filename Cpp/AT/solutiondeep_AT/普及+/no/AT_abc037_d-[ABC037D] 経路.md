# 题目信息

# [ABC037D] 経路

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc037/tasks/abc037_d

$ H\ *\ W $ のマス目があり、それぞれのマスには整数が書かれています。 $ i $ 行 $ j $ 列に書かれている数は $ a_{ij} $ です。

あなたはこのグリッドの中の好きなマスから好きなだけ動きます(最初のマスから動かなくてもかまいません)。 今いるマスの上下左右に隣接しているマスのうち、今いるマスより大きな整数が書かれたマスに移動することができます。

ありうる移動経路の個数を$ 10^9+7 $で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 1,000 $
- $ 1\ \leq\ a_{ij}\ \leq\ 10^9 $

### Sample Explanation 1

例えば、$ 1 $ 行 $ 2 $ 列から出発し、右、下と移動する経路や、 $ 1 $ 行 $ 1 $ 列から出発し、下に移動する経路などがあります。 全部で $ 18 $ 種類の経路があります。

## 样例 #1

### 输入

```
2 3

1 4 5

2 4 9```

### 输出

```
18```

## 样例 #2

### 输入

```
6 6

1 3 4 6 7 5

1 2 4 8 8 7

2 7 9 2 7 2

9 4 2 7 6 5

2 8 4 6 7 6

3 7 9 1 2 7```

### 输出

```
170```

# AI分析结果

### 题目内容重写

**题目描述**

有一个 $H \times W$ 的网格，每个格子上写有一个整数。第 $i$ 行第 $j$ 列的格子上的数是 $a_{ij}$。

你可以从网格中的任意一个格子出发，移动任意次数（也可以不移动）。每次移动时，你可以从当前格子移动到上下左右相邻的格子，且目标格子上的数必须大于当前格子上的数。

求所有可能的移动路径的总数，结果对 $10^9+7$ 取模。

**说明/提示**

**约束条件**

- $1 \leq H, W \leq 1,000$
- $1 \leq a_{ij} \leq 10^9$

**样例解释 1**

例如，从第 1 行第 2 列出发，向右、向下移动的路径，或者从第 1 行第 1 列出发，向下移动的路径等。总共有 18 种不同的路径。

**样例 #1**

**输入**

```
2 3

1 4 5

2 4 9
```

**输出**

```
18
```

**样例 #2**

**输入**

```
6 6

1 3 4 6 7 5

1 2 4 8 8 7

2 7 9 2 7 2

9 4 2 7 6 5

2 8 4 6 7 6

3 7 9 1 2 7
```

**输出**

```
170
```

### 算法分类

动态规划

### 综合分析与结论

本题的核心是计算所有可能的移动路径的总数。由于每次移动只能向数值更大的相邻格子移动，因此可以将问题转化为在有向无环图（DAG）中计算从每个节点出发的所有路径数。由于网格的大小可能达到 $1000 \times 1000$，直接使用深度优先搜索（DFS）会导致时间复杂度过高，因此需要使用动态规划（DP）来优化计算。

### 关键思路与技巧

1. **动态规划**：使用 DP 数组 `dp[i][j]` 表示从格子 `(i, j)` 出发的所有路径数。初始化时，每个格子的路径数为 1（即不移动的情况）。然后，对于每个格子，遍历其所有可能的移动方向，并累加目标格子的路径数。

2. **记忆化搜索**：为了避免重复计算，可以使用记忆化搜索来存储已经计算过的格子的路径数。

3. **排序与遍历顺序**：为了确保在计算 `dp[i][j]` 时，所有可能的移动目标格子的路径数已经被计算过，可以按照格子的数值从小到大进行排序，然后依次计算每个格子的路径数。

### 推荐题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 搜索与回溯
2. [P1434 [SHOI2002]滑雪](https://www.luogu.com.cn/problem/P1434) - 动态规划与记忆化搜索
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 动态规划与背包问题

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};

int H, W;
vector<vector<int>> a, dp;

int dfs(int x, int y) {
    if (dp[x][y] != -1) return dp[x][y];
    dp[x][y] = 1;
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >= 0 && nx < H && ny >= 0 && ny < W && a[nx][ny] > a[x][y]) {
            dp[x][y] = (dp[x][y] + dfs(nx, ny)) % MOD;
        }
    }
    return dp[x][y];
}

int main() {
    cin >> H >> W;
    a.assign(H, vector<int>(W));
    dp.assign(H, vector<int>(W, -1));
    for (int i = 0; i < H; ++i) {
        for (int j = 0; j < W; ++j) {
            cin >> a[i][j];
        }
    }
    int ans = 0;
    for (int i = 0; i < H; ++i) {
        for (int j = 0; j < W; ++j) {
            ans = (ans + dfs(i, j)) % MOD;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 代码说明

1. **DFS函数**：`dfs(x, y)` 计算从格子 `(x, y)` 出发的所有路径数。如果 `dp[x][y]` 已经被计算过，则直接返回。否则，初始化 `dp[x][y]` 为 1，然后遍历四个方向，如果目标格子的数值大于当前格子，则递归计算目标格子的路径数，并累加到 `dp[x][y]` 中。

2. **主函数**：读取输入数据，初始化 DP 数组，然后遍历所有格子，累加每个格子的路径数，最后输出结果。

### 总结

本题通过动态规划与记忆化搜索的结合，有效地解决了大规模网格中的路径计数问题。关键点在于如何合理地设计 DP 状态转移方程，并利用记忆化搜索避免重复计算。

---
处理用时：38.04秒
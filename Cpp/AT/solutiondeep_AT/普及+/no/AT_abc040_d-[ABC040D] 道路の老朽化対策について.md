# 题目信息

# [ABC040D] 道路の老朽化対策について

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc040/tasks/abc040_d

ある国には $ N $ 個の都市があり、それぞれ $ 1 $ から $ N $ までの番号がつけられています。これらの都市間を結ぶ $ M $ 本の道路があり、$ i $ 本目の道路は都市 $ a_i $ と都市 $ b_i $ を結ぶもので、$ y_i $ 年に造られたものです。

この国の国民はとても心配性なので、あまりに古い道は事故の危険性が高いと考えて使わないことがあります。そこであなたは、この国の交通状況を調査することにしました。

$ Q $ 人の国民の情報が与えられます。$ j $ 人目の国民について、都市 $ v_j $ に住んでおり、造られた年が $ w_j $ 年以前 ($ w_j $ 年ちょうども含む) であるような道路を使わないことがわかっています。

それぞれの国民に対し、その人が住んでいる都市から道路のみを使って行き来できるような都市の個数を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 100,000 $
- $ 0\ ≦\ M\ ≦\ 200,000 $
- $ 1\ ≦\ a_i,b_i\ ≦\ N $
- $ a_i\ ≠\ b_i $
- $ 1\ ≦\ y_i\ ≦\ 200,000 $
- $ 1\ ≦\ Q\ ≦\ 100,000 $
- $ 1\ ≦\ v_j\ ≦\ N $
- $ 0\ ≦\ w_j\ ≦\ 200,000 $

### 部分点

- $ 50 $ 点分のテストケースでは、$ N\ ≦\ 1,000 $, $ M\ ≦\ 2,000 $, $ Q\ ≦\ 1,000 $ をみたす。

### Sample Explanation 1

$ Q $ 人それぞれの国民について、答えは以下のようになります。 - $ 1 $ 人目は都市 $ 1 $ に住んでおり、$ 2000 $ 年以前に造られた道を使いません。都市 $ 1 $ につながる唯一の道は $ 2000 $ 年に造られているので、都市 $ 1 $ 以外へ行くことができません。したがって答えは $ 1 $ となります。 - $ 2 $ 人目は都市 $ 1 $ に住んでおり、都市 $ 2 $ や $ 3 $ へ行くことができます。しかし、$ 1999 $ 年以前に造られた道を使わないので都市 $ 4 $ へ行くことはできません。したがって答えは $ 3 $ となります。 - $ 3 $ 人目は $ 1995 $ 年以前に造られた道を使いませんが、すべての道はそれより新しいため、すべての道をつかってすべての都市へ行くことができます。したがって答えは $ 5 $ となります。

### Sample Explanation 3

同じふたつの都市間を結ぶ道が $ 2 $ 本以上あることや、すべての道を使っても辿り着けない都市がありうることに注意してください。

## 样例 #1

### 输入

```
5 4

1 2 2000

2 3 2004

3 4 1999

4 5 2001

3

1 2000

1 1999

3 1995```

### 输出

```
1

3

5```

## 样例 #2

### 输入

```
4 5

1 2 2005

3 1 2001

3 4 2002

1 4 2004

4 2 2003

5

1 2003

2 2003

1 2001

3 2003

4 2004```

### 输出

```
3

3

4

1

1```

## 样例 #3

### 输入

```
4 5

1 2 10

1 2 1000

2 3 10000

2 3 100000

3 1 200000

4

1 0

2 10000

3 100000

4 0```

### 输出

```
3

3

2

1```

# AI分析结果

【题目内容重写】
# [ABC040D] 道路的老化对策

## 题目描述

某国有N个城市，编号从1到N。这些城市之间有M条道路，第i条道路连接城市a_i和城市b_i，建造于y_i年。

该国的国民非常担心，认为过于老旧的道路存在较高的交通事故风险，因此不会使用这些道路。你需要调查该国的交通状况。

给出Q个国民的信息。对于第j个国民，他住在城市v_j，并且不会使用建造于w_j年及以前（包括w_j年）的道路。

对于每个国民，求出他所在城市通过道路可以到达的其他城市的数量。

## 说明/提示

### 约束

- 1 ≤ N ≤ 100,000
- 0 ≤ M ≤ 200,000
- 1 ≤ a_i, b_i ≤ N
- a_i ≠ b_i
- 1 ≤ y_i ≤ 200,000
- 1 ≤ Q ≤ 100,000
- 1 ≤ v_j ≤ N
- 0 ≤ w_j ≤ 200,000

### 部分分

- 50分的测试用例满足N ≤ 1,000，M ≤ 2,000，Q ≤ 1,000。

### 样例解释

样例1中，Q个国民的答案分别为1、3、5。

### 样例3

注意：两个城市之间可能存在多条道路，且并非所有城市都连通。

【算法分类】
并查集

【题解分析与结论】
该题的核心是处理连通性问题，且需要根据时间限制动态调整边的使用情况。所有题解均采用了并查集数据结构，并利用离线处理的方式，将边和询问按时间从大到小排序，逐步加入边并维护连通块的大小。这种方法避免了重复加边，提高了效率。

【评分较高的题解】
1. **作者：Wf_yjqd (5星)**
   - **关键亮点**：思路清晰，代码结构良好，详细注释了并查集的实现过程，且对排序和离线处理的逻辑解释得非常清楚。
   - **核心代码**：
     ```cpp
     struct UF_Set{
         int fa[maxn],s[maxn];
         void init(int n){
             for(int i=1;i<=n;i++){
                 fa[i]=i;
                 s[i]=1;
             }
         }
         int find(int ka){
             return fa[ka]=ka==fa[ka]?ka:find(fa[ka]);
         }
         void cnct(int xy,int zb){
             int fxy=find(xy),fzb=find(zb);
             if(fxy!=fzb){
                 fa[fxy]=fzb;
                 s[fzb]+=s[fxy];
             }
         }
     }s;
     ```
   - **个人心得**：作者提到“可以不按质合并，总体复杂度不变”，强调了并查集的优化技巧。

2. **作者：残阳如血 (4星)**
   - **关键亮点**：详细解释了离线处理的必要性，并提供了清晰的代码实现，强调了排序的重要性。
   - **核心代码**：
     ```cpp
     void merge(int x, int y) {
         int fx = find(x), fy = find(y);
         if (fx != fy) fa[fx] = fy, siz[fy] += siz[fx];
     }
     ```
   - **个人心得**：作者提到“因为每个人的时间不增，所以每个人可以使用的道路是不减的”，强调了离线处理的单调性。

3. **作者：Hilaria (4星)**
   - **关键亮点**：代码简洁，逻辑清晰，特别强调了双指针的使用，使得代码更加高效。
   - **核心代码**：
     ```cpp
     while(cur<=m&&e[cur].t>que[i].t){
         int fx=find(e[cur].x);
         int fy=find(e[cur].y);
         if(fx!=fy){
             f[fx]=fy;
             siz[fy]+=siz[fx];
         }
         ++cur;
     }
     ```
   - **个人心得**：作者提到“直接用双指针跑就行了”，强调了双指针在离线处理中的高效性。

【最优关键思路或技巧】
1. **离线处理**：将边和询问按时间从大到小排序，逐步加入边并维护连通块的大小，避免了重复加边。
2. **并查集优化**：使用路径压缩和按秩合并优化并查集，提高查询和合并的效率。
3. **双指针**：利用双指针维护当前加入的边，减少不必要的遍历。

【可拓展之处】
类似的问题可以扩展到其他需要动态维护连通性的场景，如网络流、社交网络分析等。离线处理和并查集的结合在解决这类问题时非常有效。

【推荐题目】
1. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
3. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)

---
处理用时：36.71秒
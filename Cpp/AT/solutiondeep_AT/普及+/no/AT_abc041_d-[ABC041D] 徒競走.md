# 题目信息

# [ABC041D] 徒競走

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc041/tasks/abc041_d



## 样例 #1

### 输入

```
3 2
2 1
2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5 5
1 2
2 3
3 5
1 4
4 5
```

### 输出

```
3
```

## 样例 #3

### 输入

```
16 1
1 2
```

### 输出

```
10461394944000
```

# AI分析结果

### 题目翻译
# [ABC041D] 徒競走

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc041/tasks/abc041_d

## 样例 #1

### 输入

```
3 2
2 1
2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5 5
1 2
2 3
3 5
1 4
4 5
```

### 输出

```
3
```

## 样例 #3

### 输入

```
16 1
1 2
```

### 输出

```
10461394944000
```

### 算法分类
动态规划、状压 DP

### 题解分析与结论
本题的核心是计算满足给定约束条件的排列数，主要使用了状压 DP 的方法。各题解均采用了状压 DP 的思路，但在实现细节和优化上有所不同。

1. **syzxzqy 的题解**：
   - 使用了二维 DP 数组 `dp[i][j]`，表示选择了第 `i` 个数，状态为 `j` 的方案数。
   - 通过枚举当前选择的数和之前的状态，逐步更新 DP 数组。
   - 时间复杂度为 $O(n^2m2^n)$，但由于剪枝，实际运行时间较短。

2. **StayAlone 的题解**：
   - 将问题转化为拓扑排序的方案数，使用一维 DP 数组 `f[s]` 表示状态为 `s` 的方案数。
   - 提供了两种实现方式：顺推和记搜，时间复杂度均为 $O(n \cdot 2^n)$。
   - 代码简洁，思路清晰，易于理解。

3. **sto_5k_orz 的题解**：
   - 使用一维 DP 数组 `dp[i]`，表示状态为 `i` 的方案数。
   - 通过逆推的方式，初始化 `dp[0] = 1`，逐步更新 DP 数组。
   - 时间复杂度为 $O(n \cdot 2^n)$，代码简洁，易于实现。

### 所选高分题解
#### 1. StayAlone 的题解（5星）
- **关键亮点**：将问题转化为拓扑排序的方案数，提供了两种实现方式（顺推和记搜），代码简洁，思路清晰。
- **个人心得**：通过类似拓扑的顺序转移，找到了所有满足条件的点，从而获得答案。

```cpp
int n, m, son[MAXN]; ll f[MAXN];

int main() {
	read(n, m);
	rep1(i, 1, m) {
		int x, y; read(x, y);
		son[x] |= 1 << y - 1;
	} f[0] = 1;
	rep1(s, 0, (1 << n) - 1) rep1(x, 1, n) {
		if ((son[x] & s) == son[x] && !(s >> x - 1 & 1)) f[s | (1 << x - 1)] += f[s];
	} printf("%lld", f[(1 << n) - 1]);
	rout;
}
```

#### 2. sto_5k_orz 的题解（4星）
- **关键亮点**：使用逆推的方式，初始化 `dp[0] = 1`，逐步更新 DP 数组，代码简洁，易于实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 17; int son[N], n, dp[1 << N], m;
signed main() {
	cin >> n >> m;
	while(m--) {
		int x, y; cin >> x >> y; x--, y--;
		son[x] |= (1 << y);
	}
	dp[0] = 1;
	for(int i = 0; i < (1 << n); i++) {
		for(int j = 0; j < n; j++) {
			if(i & (1 << j)) continue;
			if((i & son[j]) != son[j]) continue;
			dp[i | (1 << j)] += dp[i];
		}
	}
	cout << dp[(1 << n) - 1];
	return 0;
}
```

### 最优关键思路或技巧
- **状压 DP**：通过状态压缩表示已选择的点集，逐步更新 DP 数组。
- **拓扑排序**：将问题转化为拓扑排序的方案数，利用拓扑顺序进行转移。
- **剪枝优化**：通过条件判断跳过不符合的状态，减少不必要的计算。

### 可拓展之处
- **类似题目**：可以扩展到其他需要计算满足特定约束条件的排列数的问题，如拓扑排序、任务调度等。

### 推荐题目
1. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P2704 [NOI2001]炮兵阵地](https://www.luogu.com.cn/problem/P2704)
3. [P2831 [NOIP2016 提高组]愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)

---
处理用时：34.37秒
# 题目信息

# [ABC051D] Candidates of No Shortest Paths

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc051/tasks/abc051_d

自己ループと二重辺を含まない $ N $ 頂点 $ M $ 辺の重み付き無向連結グラフが与えられます。  
 $ i\ (1≦i≦M) $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を距離 $ c_i $ で結びます。   
 ここで、自己ループは $ a_i\ =\ b_i\ (1≦i≦M) $ となる辺のことを表します。   
 また、二重辺は $ (a_i,b_i)=(a_j,b_j) $ または $ (a_i,b_i)=(b_j,a_j)\ (1≦i\ <\ j≦M) $ となる辺のことを表します。   
 連結グラフは、どの異なる $ 2 $ 頂点間にも経路が存在するグラフのことを表します。   
 どの異なる $ 2 $ 頂点間の、どの最短経路にも含まれない辺の数を求めてください。

## 说明/提示

### 制約

- $ 2≦N≦100 $
- $ N-1≦M≦min(N(N-1)/2,1000) $
- $ 1≦a_i,b_i≦N $
- $ 1≦c_i≦1000 $
- $ c_i $ は整数である。
- 与えられるグラフは自己ループと二重辺を含まない。
- 与えられるグラフは連結である。

### Sample Explanation 1

この入力例で与えられるグラフにおける、全ての異なる $ 2 $ 頂点間の最短経路は以下の通りです。 - 頂点 $ 1 $ から頂点 $ 2 $ への最短経路は、頂点 $ 1 $ → 頂点 $ 2 $ で経路長は $ 1 $ - 頂点 $ 1 $ から頂点 $ 3 $ への最短経路は、頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 1 $ - 頂点 $ 2 $ から頂点 $ 1 $ への最短経路は、頂点 $ 2 $ → 頂点 $ 1 $ で経路長は $ 1 $ - 頂点 $ 2 $ から頂点 $ 3 $ への最短経路は、頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 2 $ - 頂点 $ 3 $ から頂点 $ 1 $ への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ で経路長は $ 1 $ - 頂点 $ 3 $ から頂点 $ 2 $ への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ → 頂点 $ 2 $ で経路長は $ 2 $ したがって、一度も最短経路として使用されていない辺は、頂点 $ 2 $ と頂点 $ 3 $ を結ぶ長さ $ 3 $ の辺のみであるため、$ 1 $ を出力します。

### Sample Explanation 2

全ての辺が異なる $ 2 $ 頂点間のある最短経路で使用されます。

## 样例 #1

### 输入

```
3 3

1 2 1

1 3 1

2 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
3 2

1 2 1

2 3 1```

### 输出

```
0```

# AI分析结果

### 题目内容重写
【题目内容】
# [ABC051D] Candidates of No Shortest Paths

## 题目描述

给定一个不包含自环和重边的 $N$ 个顶点 $M$ 条边的带权无向连通图。  
第 $i\ (1≦i≦M)$ 条边连接顶点 $a_i$ 和顶点 $b_i$，距离为 $c_i$。   
这里，自环指的是 $a_i\ =\ b_i\ (1≦i≦M)$ 的边。   
重边指的是 $ (a_i,b_i)=(a_j,b_j) $ 或 $ (a_i,b_i)=(b_j,a_j)\ (1≦i\ <\ j≦M) $ 的边。   
连通图指的是任意两个不同顶点之间都存在路径的图。   
求有多少条边不在任何两个不同顶点之间的最短路径中。

## 说明/提示

### 制約

- $ 2≦N≦100 $
- $ N-1≦M≦min(N(N-1)/2,1000) $
- $ 1≦a_i,b_i≦N $
- $ 1≦c_i≦1000 $
- $ c_i $ 是整数。
- 给定的图不包含自环和重边。
- 给定的图是连通的。

### 样例解释 1

这个输入样例中，所有不同顶点之间的最短路径如下：  
- 顶点 $1$ 到顶点 $2$ 的最短路径是 $1$ → $2$，路径长度为 $1$  
- 顶点 $1$ 到顶点 $3$ 的最短路径是 $1$ → $3$，路径长度为 $1$  
- 顶点 $2$ 到顶点 $1$ 的最短路径是 $2$ → $1$，路径长度为 $1$  
- 顶点 $2$ 到顶点 $3$ 的最短路径是 $2$ → $1$ → $3$，路径长度为 $2$  
- 顶点 $3$ 到顶点 $1$ 的最短路径是 $3$ → $1$，路径长度为 $1$  
- 顶点 $3$ 到顶点 $2$ 的最短路径是 $3$ → $1$ → $2$，路径长度为 $2$  
因此，唯一不在任何最短路径中的边是连接顶点 $2$ 和顶点 $3$ 的长度为 $3$ 的边，输出为 $1$。

### 样例解释 2

所有边都在某些不同顶点之间的最短路径中使用。

## 样例 #1

### 输入

```
3 3

1 2 1

1 3 1

2 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
3 2

1 2 1

2 3 1```

### 输出

```
0```

### 算法分类
最短路

### 题解分析与结论
题目要求找出不在任何最短路径中的边的数量。由于图的规模较小（$N \leq 100$），可以使用 Floyd-Warshall 算法计算所有顶点对之间的最短路径，并在计算过程中标记那些被松弛掉的边。最终，未被标记的边即为不在任何最短路径中的边。

### 所选题解
1. **作者：panyanppyy (赞：3)**  
   - **星级：4**  
   - **关键亮点：** 使用 Floyd-Warshall 算法计算全源最短路，并在松弛过程中标记被松弛掉的边。代码简洁，思路清晰。  
   - **核心代码：**
     ```cpp
     for(int k=1;k<=n;k++)
         for(int i=1;i<=n;i++)
             for(int j=1;j<=n;j++)
             if(g[i][j]>g[i][k]+g[k][j]){
                 if(vis[i][j])ans++,vis[i][j]=0;
                 g[i][j]=g[i][k]+g[k][j];
             }
     ```

2. **作者：Tear_stains (赞：2)**  
   - **星级：4**  
   - **关键亮点：** 同样使用 Floyd-Warshall 算法，思路与上一位作者相似，代码结构清晰，易于理解。  
   - **核心代码：**
     ```cpp
     for(int k = 1;k <= n; ++k) {
         for(int i = 1;i <= n; ++i) {
             for(int j = 1;j <= n; ++j) {
                 if(ds[i][j] > ds[i][k] + ds[k][j]){
                     if(vs[i][j]) {
                         ++ans;
                         vs[i][j] = 0;
                     }
                     ds[i][j] = ds[i][k] + ds[k][j];
                 }
             }	
         }
     }
     ```

### 最优关键思路
使用 Floyd-Warshall 算法计算全源最短路，并在松弛过程中标记被松弛掉的边。最终，未被标记的边即为不在任何最短路径中的边。

### 可拓展之处
类似的问题可以扩展到有向图或带负权边的图中，Floyd-Warshall 算法同样适用。此外，Dijkstra 算法或 Bellman-Ford 算法也可以用于计算单源最短路，但在全源最短路问题中，Floyd-Warshall 算法更为高效。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P5905 【模板】全源最短路径（Johnson）](https://www.luogu.com.cn/problem/P5905)

---
处理用时：42.40秒
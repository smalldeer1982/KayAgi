# 题目信息

# [ABC070D] Transit Tree Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc070/tasks/abc070_d

$ N $ 頂点の木が与えられます。   
 木とはグラフの一種であり、頂点の数を $ N $ とすると、辺の数が $ N-1 $ 本である閉路のない連結グラフです。   
 $ i(1≦i≦N-1) $ 番目の辺は 頂点 $ a_i $ と 頂点 $ b_i $ を距離 $ c_i $ で結びます。

また、$ Q $ 個の質問クエリと整数 $ K $ が与えられます。

- $ j(1≦j≦Q) $ 番目の質問クエリでは、頂点 $ x_j $ から 頂点 $ K $ を経由しつつ、頂点 $ y_j $ まで移動する場合の最短経路の距離を求めてください。

## 说明/提示

### 制約

- $ 3≦N≦10^5 $
- $ 1≦a_i,b_i≦N\ (1≦i≦N-1) $
- $ 1≦c_i≦10^9\ (1≦i≦N-1) $
- 与えられるグラフは木である。
- $ 1≦Q≦10^5 $
- $ 1≦K≦N $
- $ 1≦x_j,y_j≦N\ (1≦j≦Q) $
- $ x_j≠y_j\ (1≦j≦Q) $
- $ x_j≠K,y_j≠K\ (1≦j≦Q) $

### Sample Explanation 1

与えられた $ 3 $ つの質問クエリに対する最短経路は以下の通りです。 - $ 1 $ つ目の質問クエリ: 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 4 $ : 距離 $ 1+1+1=3 $ - $ 2 $ つ目の質問クエリ: 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ : 距離 $ 1+1=2 $ - $ 3 $ つ目の質問クエリ: 頂点 $ 4 $ → 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ → 頂点 $ 5 $ : 距離 $ 1+1+1+1=4 $

### Sample Explanation 2

質問クエリに対する最短経路は、必ず頂点 $ K=2 $ を通過する必要があります。

## 样例 #1

### 输入

```
5

1 2 1

1 3 1

2 4 1

3 5 1

3 1

2 4

2 3

4 5```

### 输出

```
3

2

4```

## 样例 #2

### 输入

```
7

1 2 1

1 3 3

1 4 5

1 5 7

1 6 9

1 7 11

3 2

1 3

4 5

6 7```

### 输出

```
5

14

22```

## 样例 #3

### 输入

```
10

1 2 1000000000

2 3 1000000000

3 4 1000000000

4 5 1000000000

5 6 1000000000

6 7 1000000000

7 8 1000000000

8 9 1000000000

9 10 1000000000

1 1

9 10```

### 输出

```
17000000000```

# AI分析结果

### 题目内容重写
#### 题目描述
给定一棵包含 $N$ 个顶点的树。树是一种特殊的图，具有 $N$ 个顶点和 $N-1$ 条边，且没有环的连通图。第 $i$ 条边（$1 \leq i \leq N-1$）连接顶点 $a_i$ 和顶点 $b_i$，距离为 $c_i$。

此外，给出 $Q$ 个查询和一个整数 $K$。每个查询要求从顶点 $x_j$ 出发，经过顶点 $K$，最终到达顶点 $y_j$，求其最短路径的距离。

#### 说明/提示
##### 约束
- $3 \leq N \leq 10^5$
- $1 \leq a_i, b_i \leq N$ （$1 \leq i \leq N-1$）
- $1 \leq c_i \leq 10^9$ （$1 \leq i \leq N-1$）
- 给定的图是一棵树。
- $1 \leq Q \leq 10^5$
- $1 \leq K \leq N$
- $1 \leq x_j, y_j \leq N$ （$1 \leq j \leq Q$）
- $x_j \neq y_j$ （$1 \leq j \leq Q$）
- $x_j \neq K, y_j \neq K$ （$1 \leq j \leq Q$）

### 算法分类
最短路、深度优先搜索（DFS）

### 题解分析与结论
题目要求从 $x$ 到 $y$ 的路径必须经过 $K$，且树的性质决定了任意两点之间只有一条路径。因此，最短路径就是从 $x$ 到 $K$ 的路径加上从 $K$ 到 $y$ 的路径。各题解的核心思路都是通过 DFS 或 BFS 预处理出 $K$ 到所有节点的距离，然后对每个查询直接输出 $dis[x] + dis[y]$。

### 精选题解
#### 1. 作者：GuideZombies (4星)
**关键亮点**：
- 使用 SPFA（BFS 实现）预处理 $K$ 到所有节点的距离。
- 代码简洁，直接输出 $dis[x] + dis[y]$。

**核心代码**：
```cpp
void bfs() {
    for (int i = 1; i <= n; ++i) dis[i] = 1e18;
    dis[k] = 0;
    queue<int> Q;
    Q.push(k);
    while (!Q.empty()) {
        int cur = Q.front();
        Q.pop();
        in_qu[cur] = 0;
        for (int i = h[cur]; i != -1; i = ne[i]) {
            if (dis[e[i]] > dis[cur] + w[i]) {
                dis[e[i]] = dis[cur] + w[i];
                if (in_qu[e[i]] == 0) {
                    in_qu[e[i]] = 1;
                    Q.push(e[i]);
                }
            } 
        }
    } 
}
```

#### 2. 作者：ZolaWatle (4星)
**关键亮点**：
- 详细推导了公式 $dist_x + dist_y + 2 \cdot (dist_K - dist_{lca(x,K)} - dist_{lca(K,y)})$。
- 使用 DFS 预处理每个节点的深度和到根的距离，并利用倍增法求 LCA。

**核心代码**：
```cpp
inline void dfs(int x,int fa) {
    dep[x] = dep[fa] + 1;
    F[x][0] = fa;
    for(re i = 1; i <= 20; i++)
        F[x][i] = F[F[x][i-1]][i-1];
    for(re i = 0; i < E[x].size(); i++) {
        re y = E[x][i].first;
        if(y != fa) {
            dist[y] = dist[x] + E[x][i].second;
            dfs(y, x);
        }
    }
}
```

#### 3. 作者：D2T1 (4星)
**关键亮点**：
- 直接以 $K$ 为根进行 DFS，简化了 LCA 的计算。
- 代码简洁，直接输出 $Dis[u] + Dis[v]$。

**核心代码**：
```cpp
void dfs(int st, long long d) {
    Dis[st] = d;
    Vis[st] = true;
    for(int i = 0; i < Edge[st].size(); ++i) {
        int to = Edge[st][i].first;
        if(Vis[to]) continue;
        dfs(to, d + Edge[st][i].second);
    }
}
```

### 最优关键思路
- **以 $K$ 为根进行 DFS**：通过将 $K$ 作为根节点，可以简化路径计算，避免复杂的 LCA 计算。
- **预处理距离**：通过一次 DFS 或 BFS 预处理出 $K$ 到所有节点的距离，查询时直接输出 $dis[x] + dis[y]$。

### 拓展思路
- **类似问题**：可以扩展到其他图论问题，如最短路径、最小生成树等。
- **优化**：对于大规模数据，可以考虑使用更高效的算法如 Dijkstra 或 A* 算法。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)

---
处理用时：39.90秒
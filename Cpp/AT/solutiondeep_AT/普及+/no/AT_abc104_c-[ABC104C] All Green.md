# 题目信息

# [ABC104C] All Green

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc104/tasks/abc104_c

プログラミングコンペティションサイト *AtCode* は、アルゴリズムの問題集を提供しています。 それぞれの問題には、難易度に応じて点数が付けられています。 現在、$ 1 $ 以上 $ D $ 以下のそれぞれの整数 $ i $ に対して、$ 100i $ 点を付けられた問題が $ p_i $ 問存在します。 これらの $ p_1\ +\ …\ +\ p_D $ 問が AtCode に収録された問題のすべてです。

AtCode のユーザーは *総合スコア* と呼ばれる値を持ちます。 ユーザーの総合スコアは、以下の $ 2 $ つの要素の和です。

- 基本スコア: ユーザーが解いた問題すべての配点の合計です。
- コンプリートボーナス: $ 100i $ 点を付けられた $ p_i $ 問の問題すべてを解いたユーザーは、基本スコアと別にコンプリートボーナス $ c_i $ 点を獲得します $ (1\ <\ =\ i\ <\ =\ D) $。

AtCode の新たなユーザーとなった高橋くんは、まだ問題を $ 1 $ 問も解いていません。 彼の目標は、総合スコアを $ G $ 点以上にすることです。 このためには、少なくとも何問の問題を解く必要があるでしょうか？

## 说明/提示

### 制約

- $ 1\ <\ =\ D\ <\ =\ 10 $
- $ 1\ <\ =\ p_i\ <\ =\ 100 $
- $ 100\ <\ =\ c_i\ <\ =\ 10^6 $
- $ 100\ <\ =\ G $
- 入力中のすべての値は整数である。
- $ c_i,\ G $ はすべて $ 100 $ の倍数である。
- 総合スコアを $ G $ 点以上にすることは可能である。

### Sample Explanation 1

この場合、AtCode には $ 100 $ 点を付けられた問題が $ 3 $ 問、$ 200 $ 点を付けられた問題が $ 5 $ 問あります。$ 100 $ 点の $ 3 $ 問をすべて解いた際のコンプリートボーナスは $ 500 $ 点、$ 200 $ 点の $ 5 $ 問をすべて解いた際のコンプリートボーナスは $ 800 $ 点です。高橋くんの目標は総合スコアを $ 700 $ 点以上にすることです。 目標を達成する方法の一つは、$ 200 $ 点問題を $ 4 $ 問解いて $ 800 $ 点の基本スコアを得ることです。しかし、$ 100 $ 点問題を $ 3 $ 問すべて解くと、基本スコア $ 300 $ 点に加えてコンプリートボーナスの $ 500 $ 点が与えられて総合スコアが $ 800 $ 点となり、より少ない問題数で目標を達成することができます。

### Sample Explanation 2

入力例 1 と似たケースですが、今回の高橋くんの目標は $ 2000 $ 点以上です。この場合、$ 200 $ 点の $ 5 $ 問は必ずすべて解かなければならず、さらに $ 100 $ 点問題を $ 2 $ 問解くことで総合スコアが $ 2000 $ 点となります。

### Sample Explanation 3

ふたたび入力例 1 と似たケースですが、今回の高橋くんの目標は $ 400 $ 点以上です。この場合、$ 200 $ 点問題を $ 2 $ 問解くだけで目標を達成できます。

### Sample Explanation 4

$ 500 $ 点の問題が $ 1 $ 問しか存在しませんが、このような場合でもその問題を解くことでコンプリートボーナスが与えられます。

## 样例 #1

### 输入

```
2 700

3 500

5 800```

### 输出

```
3```

## 样例 #2

### 输入

```
2 2000

3 500

5 800```

### 输出

```
7```

## 样例 #3

### 输入

```
2 400

3 500

5 800```

### 输出

```
2```

## 样例 #4

### 输入

```
5 25000

20 1000

40 1000

50 1000

30 1000

1 1000```

### 输出

```
66```

# AI分析结果

### 题目内容重写
**题目描述**

编程竞赛网站 *AtCode* 提供了算法问题集。每个问题根据难度分配了不同的分数。目前，对于每个整数 $i$（$1 \leq i \leq D$），有 $p_i$ 道问题，每道问题的分数为 $100i$ 分。这些 $p_1 + \dots + p_D$ 道问题是 AtCode 上所有的问题。

AtCode 的用户有一个称为 *总分数* 的值。用户的总分数由以下两个部分组成：

- 基本分数：用户解决的所有问题的分数总和。
- 完成奖励：如果用户解决了所有 $p_i$ 道分数为 $100i$ 的问题，将额外获得 $c_i$ 分的完成奖励（$1 \leq i \leq D$）。

AtCode 的新用户高桥君还没有解决任何问题。他的目标是使总分数达到 $G$ 分以上。为了实现这个目标，他至少需要解决多少道问题？

**说明/提示**

**约束条件**

- $1 \leq D \leq 10$
- $1 \leq p_i \leq 100$
- $100 \leq c_i \leq 10^6$
- $100 \leq G$
- 输入中的所有值都是整数。
- $c_i$ 和 $G$ 都是 $100$ 的倍数。
- 总分数达到 $G$ 分以上是可能的。

**样例解释**

**样例 #1**

输入：

```
2 700
3 500
5 800
```

输出：

```
3
```

解释：AtCode 上有 $3$ 道 $100$ 分的问题和 $5$ 道 $200$ 分的问题。解决所有 $3$ 道 $100$ 分问题可以获得 $500$ 分的完成奖励，解决所有 $5$ 道 $200$ 分问题可以获得 $800$ 分的完成奖励。高桥君的目标是总分数达到 $700$ 分以上。一种方法是解决 $4$ 道 $200$ 分问题，获得 $800$ 分的基本分数。然而，解决所有 $3$ 道 $100$ 分问题可以获得 $300$ 分的基本分数和 $500$ 分的完成奖励，总分数为 $800$ 分，从而用更少的问题数实现目标。

**样例 #2**

输入：

```
2 2000
3 500
5 800
```

输出：

```
7
```

解释：与样例 #1 类似，但高桥君的目标是 $2000$ 分以上。在这种情况下，必须解决所有 $5$ 道 $200$ 分问题，并且还需要解决 $2$ 道 $100$ 分问题，总分数为 $2000$ 分。

**样例 #3**

输入：

```
2 400
3 500
5 800
```

输出：

```
2
```

解释：与样例 #1 类似，但高桥君的目标是 $400$ 分以上。在这种情况下，只需解决 $2$ 道 $200$ 分问题即可实现目标。

**样例 #4**

输入：

```
5 25000
20 1000
40 1000
50 1000
30 1000
1 1000
```

输出：

```
66
```

解释：只有 $1$ 道 $500$ 分的问题，但解决它仍然可以获得完成奖励。

### 算法分类
动态规划

### 题解分析与结论
1. **Zachary_Cloud 的题解**：使用动态规划（DP）来解决该问题，定义 $dp_{i,j}$ 表示在前 $i$ 套题目范围内，做了 $j$ 题，所能得的最大分值。通过枚举每套题目的完成情况来更新 DP 表，最后找到满足条件的最小题目数。该解法思路清晰，代码实现较为简洁，适合初学者理解 DP 的基本应用。
   
2. **_edge_ 的题解**：同样使用 DP，但将答案作为状态，定义 $f_i$ 表示做了 $i$ 道题目可以得到的最多分数。通过枚举每套题目的完成情况来更新 DP 表，最后找到满足条件的最小题目数。该解法与 Zachary_Cloud 的解法类似，但在状态定义上略有不同，代码实现也较为简洁。

3. **Otomachi_Una_ 的题解**：使用深度优先搜索（DFS）结合贪心策略来解决该问题。通过枚举每套题目的完成情况，使用 DFS 进行搜索，并通过贪心策略计算补充题目数。该解法思路较为复杂，但通过剪枝和贪心策略优化了搜索过程，适合对搜索算法有一定了解的读者。

### 所选高星题解
1. **Zachary_Cloud 的题解**（4星）
   - 关键亮点：使用 DP 解决了问题，思路清晰，代码简洁，适合初学者理解 DP 的基本应用。
   - 核心代码：
     ```cpp
     for (int i = 1; i <= d; ++i)
         for (int j = 0; j <= p[i]; ++j)
             for (int k = 0; k <= ans - j; ++k)
                 if (j != p[i]) dp[i][j+k] = max(dp[i][j+k], dp[i-1][k] + j*i*100);
                 else dp[i][j+k] = max(dp[i][j+k], dp[i-1][k] + j*i*100 + c[i]);
     ```

2. **_edge_ 的题解**（4星）
   - 关键亮点：将答案作为状态，使用 DP 解决了问题，代码实现简洁，适合对 DP 有一定了解的读者。
   - 核心代码：
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = 1000; j >= 0; j--) {
             for (int k = min(j, a[i]); k >= 0; k--) {
                 f[j] = max(f[j], f[j-k] + k*i*100 + ((k==a[i]) ? b[i] : 0));
             }
         }
     }
     ```

### 最优关键思路或技巧
- **动态规划**：通过定义状态和转移方程，逐步求解问题，适合处理具有重叠子问题和最优子结构性质的问题。
- **贪心策略**：在搜索过程中，通过贪心策略优化搜索路径，减少不必要的计算。

### 可拓展之处
- 类似问题：可以考虑将问题扩展到更多类型的问题集，或者增加更多的约束条件，如时间限制、资源限制等。
- 算法套路：可以结合其他算法（如贪心、搜索）来进一步优化 DP 的解法。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

### 个人心得摘录
- **Zachary_Cloud**：通过 DP 解决了问题，代码简洁，适合初学者理解 DP 的基本应用。
- **_edge**：将答案作为状态，使用 DP 解决了问题，代码实现简洁，适合对 DP 有一定了解的读者。
- **Otomachi_Una_**：通过 DFS 结合贪心策略解决了问题，思路较为复杂，但通过剪枝和贪心策略优化了搜索过程。

---
处理用时：47.84秒
# 题目信息

# [ABC104D] We Love ABC

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc104/tasks/abc104_d

文字列 $ T $ の *ABC 数* とは、以下の条件をすべて満たす整数の組 $ (i,\ j,\ k) $ の個数です。

- $ 1\ <\ =\ i\ <\ j\ <\ k\ <\ =\ |T| $（$ |T| $ は $ T $ の長さ）
- $ T_i\ = $ `A`（$ T_i $ は $ T $ の先頭から $ i $ 番目の文字）
- $ T_j\ = $ `B`
- $ T_k\ = $ `C`

例えば、$ T\ = $ `ABCBC` のとき、条件をすべて満たす組 $ (i,\ j,\ k) $ は $ (1,\ 2,\ 3),\ (1,\ 2,\ 5),\ (1,\ 4,\ 5) $ の $ 3 $ 個であるため、$ T $ の ABC 数は $ 3 $ です。

文字列 $ S $ が与えられます。$ S $ のそれぞれの文字は `A`, `B`, `C`, `?` のいずれかです。

$ S $ に含まれる `?` の個数を $ Q $ とします。$ S $ に含まれる `?` をそれぞれ `A`, `B`, `C` のいずれかに置き換えることで $ 3^Q $ 通りの文字列が作られます。これらの文字列すべての ABC 数の和を求めてください。

ただし、この和は非常に大きくなりうるため、和を $ 10^9\ +\ 7 $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 3\ <\ =\ |S|\ <\ =\ 10^5 $
- $ S $ のそれぞれの文字は `A`, `B`, `C`, `?` のいずれかである。

### Sample Explanation 1

この場合、$ Q\ =\ 2 $ であり、`?` をそれぞれ `A`, `B`, `C` のいずれかに置き換えることで $ 3^Q\ =\ 9 $ 通りの文字列が作られます。これらの文字列それぞれの ABC 数を以下に示します。 - `AAAC`: $ 0 $ - `AABC`: $ 2 $ - `AACC`: $ 0 $ - `ABAC`: $ 1 $ - `ABBC`: $ 2 $ - `ABCC`: $ 2 $ - `ACAC`: $ 0 $ - `ACBC`: $ 1 $ - `ACCC`: $ 0 $ これらの和は $ 0\ +\ 2\ +\ 0\ +\ 1\ +\ 2\ +\ 2\ +\ 0\ +\ 1\ +\ 0\ =\ 8 $ であり、$ 8 $ を $ 10^9\ +\ 7 $ で割った余りである $ 8 $ を出力します。

### Sample Explanation 2

$ Q\ =\ 0 $ のときは、$ S $ 自体の ABC 数を $ 10^9\ +\ 7 $ で割った余りを出力します。この文字列は問題文中で例として挙げたものと同じであり、その ABC 数は $ 3 $ です。

### Sample Explanation 3

この場合、$ 3^Q $ 通りの文字列すべての ABC 数の和は $ 2291979612924 $ であり、これを $ 10^9\ +\ 7 $ で割った余りである $ 979596887 $ を出力します。

## 样例 #1

### 输入

```
A??C```

### 输出

```
8```

## 样例 #2

### 输入

```
ABCBC```

### 输出

```
3```

## 样例 #3

### 输入

```
????C?????B??????A???????```

### 输出

```
979596887```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个字符串 $S$，其中包含字符 `A`、`B`、`C` 和 `?`。`?` 可以被替换为 `A`、`B` 或 `C` 中的任意一个。要求计算所有可能的替换后字符串中，满足以下条件的子序列 `ABC` 的总数：
- 子序列 `ABC` 由三个字符组成，且顺序为 `A`、`B`、`C`。
- 子序列中的字符在原字符串中的位置必须严格递增。

最终结果需要对 $10^9 + 7$ 取模。

【样例解释】
- 样例1：输入 `A??C`，输出 `8`。
- 样例2：输入 `ABCBC`，输出 `3`。
- 样例3：输入 `????C?????B??????A???????`，输出 `979596887`。

### 算法分类
动态规划

### 题解分析与结论
本题的核心在于如何处理 `?` 字符，并计算所有可能的替换后字符串中 `ABC` 子序列的总数。大多数题解采用了动态规划的思路，通过维护不同状态的前缀和来统计 `A`、`B`、`C` 的出现次数，并考虑 `?` 的替换对结果的影响。

### 精选题解
#### 题解1：Composite_Function (5星)
**关键亮点**：
- 使用动态规划，状态定义为 `dp[i][j]`，表示前 $i$ 个字符中形成 `A`、`B`、`C` 的前 $j$ 项的子串数量。
- 通过分类讨论 `?` 的替换情况，巧妙地利用乘法原理更新状态。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (int i = 0; c[i]; ++i) {
    if (c[i] == '?') {
        dp[i + 1][0] = dp[i][0] * 3 % mod;
        dp[i + 1][1] = (dp[i][1] * 3 + dp[i][0]) % mod;
        dp[i + 1][2] = (dp[i][2] * 3 + dp[i][1]) % mod;
        dp[i + 1][3] = (dp[i][3] * 3 + dp[i][2]) % mod;
    } else {
        for (int j = 0; j <= 3; ++j) dp[i + 1][j] = dp[i][j];
        if (c[i] == 'A') dp[i + 1][1] = (dp[i][1] + dp[i][0]) % mod;
        if (c[i] == 'B') dp[i + 1][2] = (dp[i][2] + dp[i][1]) % mod;
        if (c[i] == 'C') dp[i + 1][3] = (dp[i][3] + dp[i][2]) % mod;
    }
}
```

#### 题解2：星之尘埃 (5星)
**关键亮点**：
- 同样采用动态规划，状态定义为 `dp[i][j]`，表示前 $i$ 个字符中形成 `A`、`B`、`C` 的前 $j$ 项的子串数量。
- 通过预处理 `?` 的替换情况，简化了状态转移方程。
- 代码结构清晰，易于扩展。

**核心代码**：
```cpp
for (re int i = 1; i <= n; i++) {
    if (s[i] == '?') {
        for (re int j = 0; j < 4; j++)
            dp[i + 1][j] = (dp[i + 1][j] + (dp[i][j] * 3)) % mod;
    } else {
        for (re int j = 0; j < 4; j++)
            dp[i + 1][j] = (dp[i][j] + dp[i + 1][j]) % mod;
    }
    if (s[i] == 'A') dp[i + 1][1] = (dp[i + 1][1] + dp[i][0]) % mod;
    if (s[i] == 'B') dp[i + 1][2] = (dp[i + 1][2] + dp[i][1]) % mod;
    if (s[i] == 'C') dp[i + 1][3] = (dp[i + 1][3] + dp[i][2]) % mod;
}
```

#### 题解3：一只书虫仔 (4星)
**关键亮点**：
- 使用动态规划，状态定义为 `f[i][1/2/3]`，表示前 $i$ 个字符中形成 `A`、`AB`、`ABC` 的子串数量。
- 通过分类讨论 `?` 的替换情况，利用乘法原理更新状态。
- 代码逻辑清晰，但状态转移方程稍显复杂。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    if (s[i] == 'A') {
        f[i][1] = (f[i - 1][1] + 3^g) % mod;
        f[i][2] = f[i - 1][2];
        f[i][3] = f[i - 1][3];
    } else if (s[i] == 'B') {
        f[i][1] = f[i - 1][1];
        f[i][2] = (f[i - 1][2] + f[i - 1][1]) % mod;
        f[i][3] = f[i - 1][3];
    } else if (s[i] == 'C') {
        f[i][1] = f[i - 1][1];
        f[i][2] = f[i - 1][2];
        f[i][3] = (f[i - 1][3] + f[i - 1][2]) % mod;
    } else if (s[i] == '?') {
        f[i][1] = (f[i - 1][1] + 3^(g - 1)) % mod;
        f[i][2] = (f[i - 1][2] + f[i - 1][1] / 3) % mod;
        f[i][3] = (f[i - 1][3] + f[i - 1][2] / 3) % mod;
    }
}
```

### 最优关键思路
- **动态规划**：通过维护不同状态的前缀和，统计 `A`、`B`、`C` 的出现次数，并考虑 `?` 的替换对结果的影响。
- **乘法原理**：利用 `?` 的三种替换情况，通过乘法原理更新状态，避免重复计算。

### 可拓展之处
- **类似题目**：可以扩展到处理其他类型的字符替换问题，如 `?` 可以被替换为更多字符，或者替换规则更复杂的情况。
- **优化思路**：可以通过预处理 `?` 的替换情况，进一步优化动态规划的状态转移方程。

### 推荐题目
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

### 个人心得
- **调试经历**：在处理 `?` 的替换时，容易忽略 `?` 作为 `B` 的情况，导致结果不准确。通过仔细分类讨论，可以避免这一问题。
- **顿悟感想**：动态规划的状态转移方程设计是关键，合理的状态定义可以大大简化问题的复杂度。

---
处理用时：50.69秒
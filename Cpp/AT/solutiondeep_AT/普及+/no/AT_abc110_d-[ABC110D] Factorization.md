# 题目信息

# [ABC110D] Factorization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc110/tasks/abc110_d

正整数 $ N,\ M $ が与えられます。

$ a_1\ \times\ a_2\ \times\ ...\ \times\ a_N\ =\ M $ となる正整数からなる長さ $ N $ の数列 $ a $ が何通りあるかを $ 10^9+7 $ で割った余りを求めてください。

ただし、数列 $ a' $ と $ a'' $ が異なるとは、ある $ i $ が存在して $ a_i'\ \neq\ a_i'' $ であることをいいます。

## 说明/提示

### 制約

- 入力はすべて整数である
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^9 $

### Sample Explanation 1

$ \{a_1,\ a_2\}\ =\ \{1,\ 6\},\ \{2,\ 3\},\ \{3,\ 2\},\ \{6,\ 1\} $ の $ 4 $ 通りの数列が条件を満たします。

## 样例 #1

### 输入

```
2 6```

### 输出

```
4```

## 样例 #2

### 输入

```
3 12```

### 输出

```
18```

## 样例 #3

### 输入

```
100000 1000000000```

### 输出

```
957870001```

# AI分析结果

### 题目内容重写
【题目描述】

给定正整数 $N$ 和 $M$，求满足 $a_1 \times a_2 \times \dots \times a_N = M$ 的正整数序列 $a$ 的个数，结果对 $10^9+7$ 取模。

其中，序列 $a'$ 和 $a''$ 被认为是不同的，当且仅当存在某个 $i$ 使得 $a_i' \neq a_i''$。

【说明/提示】

- 输入均为整数。
- $1 \leq N \leq 10^5$
- $1 \leq M \leq 10^9$

【样例解释】

样例1：$N=2$, $M=6$，满足条件的序列有 $\{1, 6\}, \{2, 3\}, \{3, 2\}, \{6, 1\}$，共4种。

样例2：$N=3$, $M=12$，输出18。

样例3：$N=100000$, $M=1000000000$，输出957870001。

### 算法分类
组合数学

### 题解分析与结论
本题的核心是将 $M$ 分解质因数，然后通过组合数学中的插板法计算每个质因数的分配方案数，最终将所有质因数的方案数相乘得到结果。难点在于如何高效地分解质因数以及如何计算组合数。

### 评分较高的题解
#### 1. 作者：ran_qwq (赞：8)
- **星级**: 5
- **关键亮点**: 通过打表找规律，推导出组合数学公式，使用逆元计算组合数，代码简洁高效。
- **个人心得**: 通过打表找规律，避免了复杂的数学推导，直接得出了组合数的公式。
- **核心代码**:
```cpp
int C(int n, int m) {
    return n >= m ? fac[n] * ifac[m] % Mod * ifac[n - m] % Mod : 0;
}
```
- **核心思想**: 使用预处理的阶乘和逆元数组快速计算组合数。

#### 2. 作者：Nightingale_OI (赞：4)
- **星级**: 4
- **关键亮点**: 清晰地解释了组合数学的思路，代码实现简洁，时间复杂度为 $O(\sqrt{m})$。
- **核心代码**:
```cpp
int C(int n, int m) {
    if (n < m) return 0;
    int a = 1, b = 1;
    for (int i = n - m + 1; i <= n; i++) a = 1ll * a * i % mo;
    for (int i = 1; i <= m; i++) b = 1ll * b * i % mo;
    return 1ll * a * ksm(b, mo - 2) % mo;
}
```
- **核心思想**: 使用快速幂计算逆元，直接计算组合数。

#### 3. 作者：_Gabriel_ (赞：3)
- **星级**: 4
- **关键亮点**: 详细解释了插板法的应用，代码实现清晰，使用了预处理组合数的方法。
- **核心代码**:
```cpp
ll c[N][40];
void init() {
    for (int i = 0; i <= 100030; i++) {
        c[i][0] = 1, c[i][i] = 1;
        for (int j = 1; j <= 30 && j <= i; j++) {
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
        }
    }
}
```
- **核心思想**: 预处理组合数数组，方便后续查询。

### 最优关键思路
1. **质因数分解**: 将 $M$ 分解为质因数的乘积，得到每个质因数的幂次。
2. **插板法**: 对于每个质因数，使用插板法计算其幂次分配到 $N$ 个位置的方案数，即 $C_{N + c_i - 1}^{c_i}$。
3. **组合数计算**: 使用预处理阶乘和逆元的方法快速计算组合数，确保时间复杂度在可接受范围内。

### 可拓展之处
- **类似问题**: 可以扩展到多个约束条件的组合问题，如多个质因数的分配问题。
- **优化技巧**: 使用更高效的质因数分解算法（如Pollard's Rho算法）可以进一步优化时间复杂度。

### 推荐题目
1. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)
2. [P1495 【模板】中国剩余定理](https://www.luogu.com.cn/problem/P1495)
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

### 个人心得总结
- **调试经历**: 在质因数分解时，需要注意特判 $M$ 为质数的情况，否则会导致答案错误。
- **踩坑教训**: 组合数计算时，要注意模数的处理，避免溢出和计算错误。
- **顿悟感想**: 通过打表找规律，可以快速理解问题的本质，避免复杂的数学推导。

---
处理用时：40.15秒
# 题目信息

# [ABC116D] Various Sushi

## 题目描述

现有 $N$ 个寿司。每个寿司有两个参数：“寿司种类” $t_i$ 和 “美味程度” $d_i$。您现在需要在这 $N$ 个寿司中选择吃 $K$ 个。您的 “满足感” 会被按照如下标准计算：

- 满足感是 “基础美味程度总和” 和 “多样性加成” 数值的总和。

- “基础美味程度总和” 指的是你吃的所有寿司的美味程度的总和。

- “多样性加成” 是 $x \times x$，其中 $x$ 是你吃的寿司种类 （即一共有多少种 $t$）。

您现在想要得到最大的 “满足感”。找到这个 “满足感” 的最大值。

## 说明/提示

- $1 \leq K \leq N \leq 10 ^ 5$

- $1 \leq t_i \leq N$

- $1 \leq d_i \leq 10 ^ 9$

- 所有输入数据均为整数

### 样例解释 1

吃第 $1,2,3$ 个寿司时，“基础美味程度总和” 为 $9 + 7 + 6 = 22$，“多样性加成” 为 $2 \times 2 = 4$ ，得到 “满足感” 最大值为 $26$ ，可以验证不存在更好的吃法。

### 样例解释 2

吃第 $1,2,3,4$ 个寿司，可以验证不存在更好的吃法。

### 样例解释 3

注意数据可能会爆 $int$

### 样例解释 4、5、6

同上

## 样例 #1

### 输入

```
5 3

1 9

1 7

2 6

2 5

3 1```

### 输出

```
26```

## 样例 #2

### 输入

```
7 4

1 1

2 1

3 1

4 6

4 5

4 5

4 5```

### 输出

```
25```

## 样例 #3

### 输入

```
6 5

5 1000000000

2 990000000

3 980000000

6 970000000

6 960000000

4 950000000```

### 输出

```
4900000016```

# AI分析结果

### 题目内容重写

#### [ABC116D] Various Sushi

##### 题目描述

现有 $N$ 个寿司。每个寿司有两个参数：“寿司种类” $t_i$ 和 “美味程度” $d_i$。您现在需要在这 $N$ 个寿司中选择吃 $K$ 个。您的 “满足感” 会被按照如下标准计算：

- 满足感是 “基础美味程度总和” 和 “多样性加成” 数值的总和。

- “基础美味程度总和” 指的是你吃的所有寿司的美味程度的总和。

- “多样性加成” 是 $x \times x$，其中 $x$ 是你吃的寿司种类 （即一共有多少种 $t$）。

您现在想要得到最大的 “满足感”。找到这个 “满足感” 的最大值。

##### 说明/提示

- $1 \leq K \leq N \leq 10 ^ 5$

- $1 \leq t_i \leq N$

- $1 \leq d_i \leq 10 ^ 9$

- 所有输入数据均为整数

### 算法分类

贪心

### 题解分析与结论

这道题的核心在于如何在选择 $K$ 个寿司时，平衡美味程度和种类多样性，以最大化满足感。大多数题解都采用了贪心策略，先按美味程度排序，然后通过替换操作来增加种类多样性。

### 精选题解

#### 题解1：作者：2huk (赞：6)

**星级：★★★★★**

**关键亮点：**
- 详细解释了贪心策略的实现过程，特别是如何通过替换操作来增加种类多样性。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码：**
```cpp
for (int i = m + 1; i <= n && k; i ++ )
{
    if (types[a[i].t]) continue;            // 如果这个种类前面出现过，就不应该继续处理 
    types[a[i].t] ++ , x += a[i].d;         // 这个种类数量加 1，总美味值加上当前的美味值 
    while (types[a[k].t] <= 1 && k) k -- ;  // 从后向前找到第一个数量出现多次（≥ 2 次）的 
    if (!k) break;                          // 如果不存在出现多次的，退出 
    y ++, x -= a[k].d, k -- ;               // 种类加 1，总美味值减去出现多次的寿司的美味值，并在以后只需要在前 k - 1 个寿司中寻找 
    res = max(res, x + y * y);              // 尝试更新答案 
}
```

**个人心得：**
- 通过从后向前查找可以替换的寿司，确保了在增加种类的同时，美味程度的损失最小。

#### 题解2：作者：Maxmilite (赞：6)

**星级：★★★★★**

**关键亮点：**
- 使用了优先队列来维护当前选择的寿司，便于快速找到可以替换的寿司。
- 通过逐步替换，确保每次操作都能增加满足感。

**核心代码：**
```cpp
while (q.size() && rev.size())
{
    if (num[q.top().t] != 0)
    {
        q.pop();
        continue;
    }
    if (num[rev.top().t] == 1)
    {
        rev.pop();
        continue;
    }
    num[rev.top().t]--;
    num[q.top().t]++;
    cnt++;
    sum -= rev.top().d;
    sum += q.top().d;
    rev.pop();
    q.pop();
    ans = sum + cnt * cnt > ans ? sum + cnt * cnt : ans;
}
```

**个人心得：**
- 通过优先队列和替换操作，确保了在增加种类的同时，美味程度的损失最小。

#### 题解3：作者：TLEWA (赞：1)

**星级：★★★★**

**关键亮点：**
- 使用了栈来记录可以替换的寿司，简化了替换操作。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
for(int i=k+1;i<=n;++i) {
    if(!t[arr[i].t]&&!sta.empty()) { //可以增加种类数 
        ++t[arr[i].t];
        now_ans+=(arr[i].d-sta.top());
        ++num;
        ans=max(ans,now_ans+num*num);
        sta.pop();
    }
}
```

**个人心得：**
- 通过栈记录可以替换的寿司，确保了在增加种类的同时，美味程度的损失最小。

### 最优关键思路与技巧

1. **排序优先**：先按美味程度从大到小排序，确保初始选择的美味程度最大。
2. **替换操作**：通过替换操作来增加种类多样性，确保每次替换都能增加满足感。
3. **数据结构**：使用优先队列或栈来记录可以替换的寿司，简化操作。

### 可拓展之处

类似的问题可以扩展到其他需要平衡多个因素的场景，如选择物品时同时考虑价值和多样性。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1208 [USACO1.3]混合牛奶 Mixing Milk](https://www.luogu.com.cn/problem/P1208)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得总结

通过这道题，我深刻理解了贪心策略在平衡多个因素时的应用，特别是在需要同时考虑价值和多样性的场景下，如何通过替换操作来优化结果。

---
处理用时：37.28秒
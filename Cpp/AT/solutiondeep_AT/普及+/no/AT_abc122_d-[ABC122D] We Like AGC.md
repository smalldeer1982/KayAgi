# 题目信息

# [ABC122D] We Like AGC

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc122/tasks/abc122_d

整数 $ N $ が与えられます。次の条件を満たす長さ $ N $ の文字列の数を $ 10^9+7 $ で割った余りを求めてください。

- `A`, `C`, `G`, `T` 以外の文字を含まない。
- `AGC` を部分文字列として含まない。
- 隣接する $ 2 $ 文字の入れ替えを $ 1 $ 回行うことで上記の条件に違反させることはできない。

## 说明/提示

### 注記

文字列 $ T $ の部分文字列とは、$ T $ の先頭と末尾から $ 0 $ 文字以上を取り去って得られる文字列です。

例えば、`ATCODER` の部分文字列には `TCO`, `AT`, `CODER`, `ATCODER`, `` (空文字列) が含まれ、`AC` は含まれません。

### 制約

- $ 3\ \leq\ N\ \leq\ 100 $

### Sample Explanation 1

`A`, `C`, `G`, `T` 以外の文字を含まない長さ $ 3 $ の文字列は $ 4^3\ =\ 64 $ 通り存在し、そのうち `AGC`, `ACG`, `GAC` のみが条件に違反するため、答えは $ 64\ -\ 3\ =\ 61 $ 通りです。

### Sample Explanation 3

文字列の数を $ 10^9+7 $ で割った余りを出力することをお忘れなく。

## 样例 #1

### 输入

```
3```

### 输出

```
61```

## 样例 #2

### 输入

```
4```

### 输出

```
230```

## 样例 #3

### 输入

```
100```

### 输出

```
388130742```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个整数 $N$，请找出满足以下条件的长度为 $N$ 的字符串的数目，答案对 $10^9+7$ 取模。

- 该字符串仅由 `A`、`C`、`G`、`T` 四种字符组成。
- 该字符串不包含子串 `AGC`。
- 交换相邻两个字符一次后，仍然不包含子串 `AGC`。

【说明/提示】

- 字符串 $T$ 的子串是指从 $T$ 的开头和结尾去掉 0 个或多个字符后得到的字符串。
- 例如，`ATCODER` 的子串包括 `TCO`、`AT`、`CODER`、`ATCODER` 和空字符串，但不包括 `AC`。

【样例解释】

- 样例 1：长度为 3 的字符串共有 $4^3 = 64$ 种，其中 `AGC`、`ACG`、`GAC` 违反条件，因此答案为 $64 - 3 = 61$。
- 样例 3：注意输出结果需要对 $10^9+7$ 取模。

### 算法分类

动态规划

### 题解分析与结论

本题的核心在于如何通过动态规划（DP）来统计满足条件的字符串数量。难点在于如何正确处理第三个条件，即交换相邻字符后不产生 `AGC` 子串。大多数题解通过枚举字符串的最后几位，并排除那些在交换后可能产生 `AGC` 的情况来实现。

### 精选题解

1. **作者：hxhhxh (4星)**
   - **关键亮点**：使用五进制数表示字符，通过模运算快速判断是否违反条件，代码简洁且高效。
   - **代码核心思想**：通过五进制数表示字符序列，利用模运算快速判断是否违反条件，避免复杂的字符串操作。
   - **核心代码片段**：
     ```cpp
     for(int i=1;i<=n;i++){
         for(int j=0;j<125;j++){
             if(dp[i-1][j]){
                 for(int k=j*5+1;k<=j*5+4;k++){
                     if(!(k%125==38||k%125==42||k%125==58||k==188||k==198||k==238)){
                         dp[i][k%125]=(dp[i][k%125]+dp[i-1][j])%mod;
                     }
                 }
             }
         }
     }
     ```

2. **作者：igAC (4星)**
   - **关键亮点**：通过四维 DP 状态表示字符串的最后三位，结合条件判断进行转移，思路清晰。
   - **代码核心思想**：使用四维 DP 状态 `f[i][a][b][c]` 表示长度为 $i$ 的字符串的最后三位，通过枚举第四位进行转移。
   - **核心代码片段**：
     ```cpp
     for(int i=4;i<=n;++i){
         for(int a=0;a<4;++a){
             for(int b=0;b<4;++b){
                 for(int c=0;c<4;++c){
                     for(int x=0;x<4;++x){
                         if(check(a,b,c) && check(a,c,b) && check(b,a,c) && check(x,a,c) && check(x,b,c)){
                             f[i][a][b][c]=(f[i][a][b][c]+f[i-1][x][a][b])%Mod;
                         }
                     }
                 }
             }
         }
     }
     ```

3. **作者：_Gabriel_ (4星)**
   - **关键亮点**：通过五重循环枚举字符序列，结合条件判断进行转移，代码结构清晰。
   - **代码核心思想**：使用五重循环枚举字符序列，通过条件判断排除不合法情况，进行 DP 转移。
   - **核心代码片段**：
     ```cpp
     for(int i=1;i<=n;i++){
         for(int w=0;w<=3;w++){
             for(int x=0;x<=3;x++){
                 for(int y=0;y<=3;y++){
                     for(int z=0;z<=3;z++){
                         if(check(w,x,y,z)){
                             dp[i][x][y][z]=(dp[i][x][y][z]+dp[i-1][w][x][y])%mod;
                         }
                     }
                 }
             }
         }
     }
     ```

### 最优关键思路与技巧

- **状态表示**：大多数题解通过表示字符串的最后几位（通常是最后三位）来定义 DP 状态，这样可以有效减少状态空间。
- **条件判断**：通过枚举字符序列并排除那些在交换后可能产生 `AGC` 的情况，确保转移的正确性。
- **模运算优化**：部分题解通过模运算快速判断是否违反条件，避免复杂的字符串操作，提高效率。

### 拓展思路

本题的 DP 思路可以推广到其他类似的字符串计数问题，特别是那些需要排除特定子串或满足特定条件的问题。类似的问题包括：

1. **P1641 [SCOI2010]生成字符串**：统计满足特定条件的字符串数量。
2. **P2657 [SCOI2009]windy数**：统计满足特定条件的数字数量。
3. **P2602 [ZJOI2010]数字计数**：统计数字中特定数字的出现次数。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现条件判断的遗漏，导致结果错误，提醒我们在编写代码时要仔细检查所有可能的情况。
- **顿悟感想**：通过五进制数表示字符序列的想法是一个巧妙的优化，减少了字符串操作的复杂度，提高了代码的效率。

---
处理用时：37.77秒
# 题目信息

# [ABC123D] Cake 123

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc123/tasks/abc123_d

AtCoder 洋菓子店は数字の形をしたキャンドルがついたケーキを販売しています。  
 ここには $ 1,\ 2,\ 3 $ の形をしたキャンドルがついたケーキがそれぞれ $ X $ 種類、$ Y $ 種類、$ Z $ 種類あります。  
 それぞれのケーキには「美味しさ」という整数の値が以下のように割り当てられています。

- $ 1 $ の形のキャンドルがついたケーキの美味しさはそれぞれ $ A_1,\ A_2,\ ...,\ A_X $
- $ 2 $ の形のキャンドルがついたケーキの美味しさはそれぞれ $ B_1,\ B_2,\ ...,\ B_Y $
- $ 3 $ の形のキャンドルがついたケーキの美味しさはそれぞれ $ C_1,\ C_2,\ ...,\ C_Z $

高橋君は ABC 123 を記念するために、$ 1,\ 2,\ 3 $ の形のキャンドルがついたケーキを $ 1 $ つずつ買うことにしました。  
 そのようにケーキを買う方法は $ X\ \times\ Y\ \times\ Z $ 通りあります。

これらの選び方を $ 3 $ つのケーキの美味しさの合計が大きい順に並べたとき、$ 1,\ 2,\ ...,\ K $ 番目の選び方でのケーキの美味しさの合計をそれぞれ出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ X\ \leq\ 1\ 000 $
- $ 1\ \leq\ Y\ \leq\ 1\ 000 $
- $ 1\ \leq\ Z\ \leq\ 1\ 000 $
- $ 1\ \leq\ K\ \leq\ \min(3\ 000,\ X\ \times\ Y\ \times\ Z) $
- $ 1\ \leq\ A_i\ \leq\ 10\ 000\ 000\ 000 $
- $ 1\ \leq\ B_i\ \leq\ 10\ 000\ 000\ 000 $
- $ 1\ \leq\ C_i\ \leq\ 10\ 000\ 000\ 000 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

$ 3 $ つのケーキの選び方は $ 2\ \times\ 2\ \times\ 2\ =\ 8 $ 通りあり、それらをケーキの美味しさの合計が大きい順に並べると以下の通りです。 - $ (A_2,\ B_2,\ C_2) $: $ 6\ +\ 5\ +\ 8\ =\ 19 $ - $ (A_1,\ B_2,\ C_2) $: $ 4\ +\ 5\ +\ 8\ =\ 17 $ - $ (A_2,\ B_1,\ C_2) $: $ 6\ +\ 1\ +\ 8\ =\ 15 $ - $ (A_2,\ B_2,\ C_1) $: $ 6\ +\ 5\ +\ 3\ =\ 14 $ - $ (A_1,\ B_1,\ C_2) $: $ 4\ +\ 1\ +\ 8\ =\ 13 $ - $ (A_1,\ B_2,\ C_1) $: $ 4\ +\ 5\ +\ 3\ =\ 12 $ - $ (A_2,\ B_1,\ C_1) $: $ 6\ +\ 1\ +\ 3\ =\ 10 $ - $ (A_1,\ B_1,\ C_1) $: $ 4\ +\ 1\ +\ 3\ =\ 8 $

### Sample Explanation 2

美味しさの合計が同じになる組み合わせが複数ある可能性もあります。例えば、このテストケースで $ (A_1,\ B_3,\ C_3) $ を選ぶときと $ (A_3,\ B_3,\ C_1) $ を選ぶときはともに、美味しさの合計が $ 301 $ となります。 しかし、これらは異なる選び方であるため、出力には $ 301 $ が $ 2 $ 回出現します。

### Sample Explanation 3

入力・出力は $ 32 $ ビット整数に収まらない可能性があることに注意してください。

## 样例 #1

### 输入

```
2 2 2 8

4 6

1 5

3 8```

### 输出

```
19

17

15

14

13

12

10

8```

## 样例 #2

### 输入

```
3 3 3 5

1 10 100

2 20 200

1 10 100```

### 输出

```
400

310

310

301

301```

## 样例 #3

### 输入

```
10 10 10 20

7467038376 5724769290 292794712 2843504496 3381970101 8402252870 249131806 6310293640 6690322794 6082257488

1873977926 2576529623 1144842195 1379118507 6003234687 4925540914 3902539811 3326692703 484657758 2877436338

4975681328 8974383988 2882263257 7690203955 514305523 6679823484 4263279310 585966808 3752282379 620585736```

### 输出

```
23379871545

22444657051

22302177772

22095691512

21667941469

21366963278

21287912315

21279176669

21160477018

21085311041

21059876163

21017997739

20703329561

20702387965

20590247696

20383761436

20343962175

20254073196

20210218542

20150096547```

# AI分析结果

### 题目内容重写

AtCoder 洋菓子店出售带有数字形状蜡烛的蛋糕。这里有三种形状的蜡烛，分别为1、2、3，每种形状的蛋糕分别有 $X$、$Y$、$Z$ 种。每种蛋糕都有一个“美味度”值，具体如下：

- 形状为1的蛋糕的美味度分别为 $A_1, A_2, ..., A_X$
- 形状为2的蛋糕的美味度分别为 $B_1, B_2, ..., B_Y$
- 形状为3的蛋糕的美味度分别为 $C_1, C_2, ..., C_Z$

高桥君为了纪念 ABC 123，决定购买每种形状的蛋糕各一个。这样的购买方式共有 $X \times Y \times Z$ 种。

请将这些购买方式按照蛋糕美味度的总和从大到小排序，并输出前 $K$ 种购买方式的美味度总和。

### 算法分类
贪心

### 题解分析与结论

本题的核心问题是如何高效地找到前 $K$ 个最大的美味度总和。由于 $X, Y, Z$ 的最大值均为1000，直接枚举所有可能的组合会导致时间复杂度过高。因此，需要采用贪心策略来优化。

#### 题解1：龙潜月十五 (5星)
- **关键亮点**：使用大根堆（优先队列）来维护当前最大的美味度总和，并通过逐步扩展候选组合来避免重复计算。通过排序和堆的结合，确保了时间复杂度在可接受范围内。
- **个人心得**：作者详细证明了每次选择次大值的正确性，并通过 `map` 去重，避免了重复计算。

```cpp
priority_queue<node>q;
map<pair<pair<int,int>,int>,bool>mp;

q.push((node){1,1,1});
mp[make_pair(make_pair(1,1),1)]=true;

for(ri i=1;i<=k;i++) {
    node now=q.top();
    q.pop();
    printf("%lld\n",a[now.x]+b[now.y]+c[now.z]);
    
    if(!mp.count(make_pair(make_pair(now.x+1,now.y),now.z))&&now.x<x) {
        mp[make_pair(make_pair(now.x+1,now.y),now.z)]=true;
        q.push((node){now.x+1,now.y,now.z});
    }
    // 类似处理其他两种情况
}
```

#### 题解2：きりと (4星)
- **关键亮点**：通过先枚举 $a$ 和 $b$ 的所有组合，再与 $c$ 组合，最终排序得到前 $K$ 个结果。虽然时间复杂度较高，但由于 $K$ 的限制，实际运行时间在可接受范围内。
- **个人心得**：作者通过数据范围的分析，巧妙地减少了计算量，避免了直接枚举所有组合。

```cpp
for(int i=1;i<=x;i++) {
    for(int j=1;j<=y;j++) {
        d[++c1]=a[i]+b[j];
    }
}
sort(d+1,d+c1+1,cmp);

for(int i=1;i<=k;i++) {
    for(int j=1;j<=z;j++) {
        ans[++c2]=d[i]+c[j];
    }
}
sort(ans+1,ans+c2+1,cmp);
```

#### 题解3：Astatinear (4星)
- **关键亮点**：通过先求出 $a$ 和 $b$ 的前 $K$ 个最大组合，再与 $c$ 组合，最终排序得到前 $K$ 个结果。思路清晰，代码简洁。
- **个人心得**：作者通过逐步缩小候选范围，减少了计算量，同时保证了结果的正确性。

```cpp
for(int i=1;i<=x;++i) {
    for(int j=1;j<=y;++j) {
        ans1[++cnt1]=a[i]+b[j];
    }
}
sort(ans1+1,ans1+cnt1+1);

for(int i=cnt1;i>=max(cnt1-k+1,1);--i) {
    for(int j=1;j<=z;++j) {
        ans2[++cnt2]=ans1[i]+c[j];
    }
}
sort(ans2+1,ans2+cnt2+1);
```

### 最优关键思路与技巧
1. **贪心策略**：通过逐步扩展候选组合，确保每次都能找到当前最大的美味度总和。
2. **优先队列**：使用大根堆来高效地维护和获取当前最大的组合。
3. **去重**：通过 `map` 或其他数据结构避免重复计算，提高效率。

### 可拓展之处
类似的问题可以扩展到多个序列的组合，或者在其他需要求前 $K$ 大或前 $K$ 小值的场景中应用相同的贪心策略。

### 推荐题目
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)

### 个人心得总结
- **调试经历**：在处理重复组合时，使用 `map` 可以有效避免重复计算，但需要注意内存消耗。
- **踩坑教训**：在贪心策略中，确保每次扩展的组合是当前最优的，否则可能导致结果错误。
- **顿悟感想**：通过逐步缩小候选范围，可以大大减少计算量，同时保证结果的正确性。

---
处理用时：34.32秒
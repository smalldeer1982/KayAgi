# 题目信息

# [ABC127F] Absolute Minima

## 题目描述

有一个函数 $f(x)$ ，初始时 $f(x)=0$

接下来你会对这个函数进行 $Q$ 次以下操作：

- $\texttt{1 a b}$，将 $f(x)$ 替换为 $g(x)=f(x)+|x-a|+b$
- $\texttt{2}$，询问最小的整数 $x$ ，使得  $f(x)$ 取到最小值，以及 $f(x)$ 的最小值

## 说明/提示

$1 \le Q \le 200000,-10^9 \le a,b \le 10^9$ ，保证第一次操作一定是修改操作

## 样例 #1

### 输入

```
4

1 4 2

2

1 1 -8

2```

### 输出

```
4 2

1 -3```

## 样例 #2

### 输入

```
4

1 -1000000000 1000000000

1 -1000000000 1000000000

1 -1000000000 1000000000

2```

### 输出

```
-1000000000 3000000000```

# AI分析结果

【题目翻译】
# [ABC127F] Absolute Minima

## 题目描述

有一个函数 $f(x)$ ，初始时 $f(x)=0$

接下来你会对这个函数进行 $Q$ 次以下操作：

- $\texttt{1 a b}$，将 $f(x)$ 替换为 $g(x)=f(x)+|x-a|+b$
- $\texttt{2}$，询问最小的整数 $x$ ，使得  $f(x)$ 取到最小值，以及 $f(x)$ 的最小值

## 说明/提示

$1 \le Q \le 200000,-10^9 \le a,b \le 10^9$ ，保证第一次操作一定是修改操作

## 样例 #1

### 输入

```
4

1 4 2

2

1 1 -8

2```

### 输出

```
4 2

1 -3```

## 样例 #2

### 输入

```
4

1 -1000000000 1000000000

1 -1000000000 1000000000

1 -1000000000 1000000000

2```

### 输出

```
-1000000000 3000000000```

【算法分类】
数学、对顶堆

【题解分析与结论】
本题的核心在于动态维护函数 $f(x)$ 的最小值及其对应的 $x$。通过数学分析，可以得出 $f(x)$ 的最小值出现在所有 $a_i$ 的中位数处。因此，问题转化为动态维护中位数及其相关计算。

各题解的主要思路是通过对顶堆（一个大根堆和一个小根堆）来动态维护中位数，并计算 $f(x)$ 的最小值。部分题解还使用了平衡树或 `multiset` 来实现类似功能。对顶堆的解法在时间复杂度和代码实现上较为简洁，适合本题的需求。

【高星题解】
1. **作者：洛璟 (赞：9)**  
   - **星级：5星**  
   - **关键亮点**：详细解释了对顶堆的原理和实现，代码清晰且优化良好，适合初学者理解。  
   - **核心代码**：
     ```cpp
     priority_queue<int, vector<int>, greater<int> > q;
     priority_queue<int> p;
     int n, ans, tmpp, tmp, cnt;
     ```
     **实现思想**：通过大根堆和小根堆动态维护中位数，并在插入时保持堆的平衡，计算 $f(x)$ 的最小值。

2. **作者：cosf (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：代码简洁，逻辑清晰，适合快速实现。  
   - **核心代码**：
     ```cpp
     priority_queue<int> sl; // 左边的点
     priority_queue<int, vector<int>, greater<int>> sr; // 右边的点
     ll ml = 0, mr = 0; // 左边的和，右边的和
     ```
     **实现思想**：通过两个堆维护中位数及其左右部分的和，计算 $f(x)$ 的最小值。

3. **作者：迟暮天复明 (赞：1)**  
   - **星级：4星**  
   - **关键亮点**：详细解释了中位数的维护方法，代码实现较为清晰。  
   - **核心代码**：
     ```cpp
     priority_queue<int> big; // 大根堆
     priority_queue<int, vector<int>, greater<int>> small; // 小根堆
     int sum = 0, ans = 0;
     ```
     **实现思想**：通过大根堆和小根堆动态维护中位数，并在插入时保持堆的平衡，计算 $f(x)$ 的最小值。

【最优关键思路】
使用对顶堆（一个大根堆和一个小根堆）动态维护中位数，并在插入时保持堆的平衡。通过计算中位数及其左右部分的和，快速得出 $f(x)$ 的最小值。

【拓展思路】
类似的问题可以扩展到其他需要动态维护中位数或区间统计的场景，如滑动窗口的中位数、动态区间和等。

【推荐题目】
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

---
处理用时：28.51秒
# 题目信息

# [ABC129E] Sum Equals Xor

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc129/tasks/abc129_e

正整数 $ L $ が二進数表記で与えられます。 以下の条件を満たす非負整数 $ a,\ b $ の組 $ (a,\ b) $ がいくつ存在するか求めてください:

- $ a\ +\ b\ \leq\ L $
- $ a\ +\ b\ =\ a\ \text{\ XOR\ }\ b $

ただし、この値は非常に大きくなることがあるので、$ 10^9\ +\ 7 $ で割った余りを出力してください。

XOR とは

整数 $ A,\ B $ のビットごとの排他的論理和 $ a\ \text{\ XOR\ }\ b $ は、以下のように定義されます。

$ a\ \text{\ XOR\ }\ b $ を二進数表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進数表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。 例えば、$ 3\ \text{\ XOR\ }\ 5\ =\ 6 $ となります (二進数表記すると: $ 011\ \text{\ XOR\ }\ 101\ =\ 110 $)。

## 说明/提示

### 制約

- $ L $は二進数表記で与えられ、先頭文字は必ず $ 1 $ である
- $ 1\ \leq\ L\ <\ 2^{100,001} $

### Sample Explanation 1

条件を満たす $ (a,\ b) $ としては $ (0,\ 0),\ (0,\ 1),\ (1,\ 0),\ (0,\ 2),\ (2,\ 0) $ の $ 5 $ つが考えられます。

## 样例 #1

### 输入

```
10```

### 输出

```
5```

## 样例 #2

### 输入

```
1111111111111111111```

### 输出

```
162261460```

# AI分析结果

### 题目内容重写
【题目描述】
正整数 $L$ 以二进制形式给出。求满足以下条件的非负整数对 $(a, b)$ 的数量：
- $a + b \leq L$
- $a + b = a \oplus b$

其中，$\oplus$ 表示按位异或运算。由于结果可能非常大，输出时需要对 $10^9 + 7$ 取模。

【样例解释】
样例1：
输入：`10`
输出：`5`
解释：满足条件的 $(a, b)$ 对为 $(0, 0)$, $(0, 1)$, $(1, 0)$, $(0, 2)$, $(2, 0)$。

样例2：
输入：`1111111111111111111`
输出：`162261460`

### 算法分类
动态规划、位运算

### 题解分析与结论
本题的核心在于理解 $a + b = a \oplus b$ 的条件，即 $a$ 和 $b$ 的二进制表示中不能有同时为1的位。这可以通过动态规划来解决，状态转移时需要考虑当前位是否为1，并分别处理等于和小于 $L$ 的情况。

### 所选高分题解
#### 题解1：Acfboy (5星)
**关键亮点**：
- 使用两个状态 $f0$ 和 $f1$ 分别表示严格小于和等于 $L$ 的方案数。
- 通过逐位处理 $L$ 的二进制表示，简洁高效地完成状态转移。
- 代码简洁，仅9行，且时间复杂度为 $O(n)$。

**核心代码**：
```cpp
#include <cstdio>
long long f0 = 0, f1 = 1, p = 1000000007, s;
signed main() {
	while(scanf("%c", &s) != EOF && (s == '0' || s == '1')) {
		f0 = f0 * 3 % p;
		if(s == '1') f0 = (f0 + f1) % p, f1 = f1 * 2 % p;
	}
	printf("%lld", (f0+f1) % p);
}
```

#### 题解2：high_sky (4星)
**关键亮点**：
- 使用二维DP数组 $dp[i][0/1]$ 分别表示前 $i$ 位小于或等于 $L$ 的方案数。
- 详细解释了状态转移方程，便于理解。
- 代码实现清晰，适合初学者学习。

**核心代码**：
```cpp
#include<iostream>
#define int long long
using namespace std;
int n,dp[105000][2];
string s,s1;
const int mod=1e9+7;
signed main(){
	cin>>s1;
	n=s1.size();
	s=' ',s+=s1;
	dp[0][1]=1;
	for(int i=1;i<=n;i++){
		dp[i][0]=(dp[i-1][0]*3)%mod;
		if(s[i]=='1'){
			dp[i][0]=(dp[i][0]+dp[i-1][1])%mod;
			dp[i][1]=(dp[i-1][1]*2)%mod;
		}
		else dp[i][1]=dp[i-1][1];
	}
	cout<<(dp[n][0]+dp[n][1])%mod;
	return 0;
}
```

#### 题解3：YueYang1235 (4星)
**关键亮点**：
- 使用二维DP数组 $dp[i][0/1]$ 分别表示前 $i$ 位小于或等于 $L$ 的方案数。
- 详细解释了状态转移方程，便于理解。
- 代码实现清晰，适合初学者学习。

**核心代码**：
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
long long n,dp[105000][2];
char s[105000];
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	dp[0][1]=1;
	for(int i=1;i<=n;++i){
		dp[i][0]=(dp[i-1][0]*3)%mod;
		if(s[i]=='1'){
			dp[i][0]=(dp[i][0]+dp[i-1][1])%mod;
			dp[i][1]=(dp[i-1][1]*2)%mod;
		}
		else dp[i][1]=dp[i-1][1];
	}
	printf("%lld\n",(dp[n][0]+dp[n][1])%mod);
	return 0;
}
```

### 最优关键思路
- **状态定义**：使用两个状态分别表示严格小于和等于 $L$ 的方案数。
- **状态转移**：根据当前位是否为1，分别更新状态，避免同时为1的情况。
- **优化**：逐位处理，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

### 拓展思路
类似的问题可以通过动态规划和位运算的结合来解决，尤其是在处理二进制表示和限制条件时。例如，求满足某些位运算条件的数对数量，或者求满足某些限制条件的二进制数的数量。

### 推荐题目
1. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P2704 [NOI2001]炮兵阵地](https://www.luogu.com.cn/problem/P2704)
3. [P1879 [USACO06NOV]Corn Fields G](https://www.luogu.com.cn/problem/P1879)

---
处理用时：33.44秒
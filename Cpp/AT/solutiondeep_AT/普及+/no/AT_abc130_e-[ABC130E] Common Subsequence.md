# 题目信息

# [ABC130E] Common Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc130/tasks/abc130_e

$ 1 $ 以上 $ 10^5 $ 以下の整数から成る、長さ $ N $ の整数列 $ S $ と 長さ $ M $ の整数列 $ T $ が与えられます。

$ S $ の部分列と $ T $ の部分列の組であって、整数列として等しいような組は何通りあるでしょうか。

ただし、整数列 $ A $ の部分列とは、$ A $ の要素を $ 0 $ 個以上いくつか選んで削除し、残ったものを元の順序を保って並べた整数列を表します。

また、$ S,\ T $ それぞれの部分列は、整数列として等しい場合でも、削除した要素の添字の集合が異なる場合には異なる部分列として区別してください。

答えは非常に大きくなることがあるので、$ 10^9+7 $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M\ \leq\ 2\ \times\ 10^3 $
- $ S $ の長さは $ N $ である
- $ T $ の長さは $ M $ である
- $ 1\ \leq\ S_i,\ T_i\ \leq\ 10^5 $
- 入力は全て整数である

### Sample Explanation 1

$ S $ の部分列としては $ (),\ (1),\ (3),\ (1,\ 3) $ が考えられます。 $ T $ の部分列としては $ (),\ (3),\ (1),\ (3,\ 1) $ が考えられます。 共に部分列が $ () $ である組は $ 1\ \times\ 1 $ 通り、共に部分列が $ (1) $ である組は $ 1\ \times\ 1 $ 通り、共に部分列が $ (3) $ である組は $ 1\ \times\ 1 $ 通り考えられるので、合計 $ 3 $ 通りの組が存在します。

### Sample Explanation 2

$ S $ の部分列としては $ (),\ (1),\ (1),\ (1,\ 1) $ が考えられます。 $ T $ の部分列としては $ (),\ (1),\ (1),\ (1,\ 1) $ が考えられます。 共に部分列が $ () $ である組は $ 1\ \times\ 1 $ 通り、共に部分列が $ (1) $ である組は $ 2\ \times\ 2 $ 通り、共に部分列が $ (1,\ 1) $ である組は $ 1\ \times\ 1 $ 通り考えられるので、合計 $ 6 $ 通りの組が存在します。 部分列において削除する要素の添字の集合が異なるものを区別することに注意してください。

### Sample Explanation 5

個数を $ 10^9+7 $ で割った余りを出力することに注意してください。

## 样例 #1

### 输入

```
2 2

1 3

3 1```

### 输出

```
3```

## 样例 #2

### 输入

```
2 2

1 1

1 1```

### 输出

```
6```

## 样例 #3

### 输入

```
4 4

3 4 5 6

3 4 5 6```

### 输出

```
16```

## 样例 #4

### 输入

```
10 9

9 6 5 7 5 9 8 5 6 7

8 6 8 5 5 7 9 9 7```

### 输出

```
191```

## 样例 #5

### 输入

```
20 20

1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1```

### 输出

```
846527861```

# AI分析结果

### 题目内容
给定两个长度分别为 $N$ 和 $M$ 的整数序列 $S$ 和 $T$，它们均由 $1$ 到 $10^5$（含）之间的整数组成。求在 $S$ 的子序列和 $T$ 的子序列中，有多少对两个子序列的内容相同。

子序列的说明：$A$ 的子序列是指通过从 $A$ 删除零个或多个元素而不改变顺序而获得的序列。对于 $S$ 和 $T$ 而言，如果子序列的内容相同，但是被删除元素的索引集（位置）不同，也当成两个不同的子序列。

输出答案 $\bmod 10^9+7$ 的结果。

### 算法分类
动态规划

### 题解分析与结论
本题的核心思路是使用动态规划（DP）来统计两个序列中相同子序列的数量。所有题解都采用了类似的状态转移方程，主要区别在于代码的实现细节和优化程度。

#### 关键思路与技巧
1. **状态定义**：$dp[i][j]$ 表示 $S$ 的前 $i$ 项和 $T$ 的前 $j$ 项中相同子序列的数量。
2. **状态转移**：
   - 当 $S[i] = T[j]$ 时，$dp[i][j] = dp[i-1][j] + dp[i][j-1]$。
   - 当 $S[i] \neq T[j]$ 时，$dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]$。
3. **初始化**：$dp[i][0] = dp[0][j] = 1$，表示空子序列的情况。
4. **取模处理**：由于结果可能非常大，需要在每一步计算中对 $10^9+7$ 取模，并处理可能的负数情况。

#### 推荐题解
1. **HanPi (5星)**
   - **关键亮点**：代码简洁，状态转移方程清晰，初始化处理得当，取模操作正确。
   - **代码片段**：
     ```cpp
     f[i][j] = (f[i-1][j] + f[i][j-1] - f[i-1][j-1]) % MOD;
     if (a[i] == b[j]) f[i][j] = (f[i][j] + f[i-1][j-1]) % MOD;
     ```

2. **CYZZ (4星)**
   - **关键亮点**：状态转移方程清晰，初始化处理得当，取模操作正确，代码可读性高。
   - **代码片段**：
     ```cpp
     dp[i][j] = (dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]) % mod;
     if (s[i] == t[j]) dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % mod;
     ```

3. **Coros_Trusds (4星)**
   - **关键亮点**：状态转移方程清晰，初始化处理得当，取模操作正确，代码可读性高。
   - **代码片段**：
     ```cpp
     dp[i][j] = (dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]) % mod;
     if (s[i] == t[j]) dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % mod;
     ```

### 拓展思路
本题的DP思路可以推广到其他涉及子序列匹配的问题，如最长公共子序列（LCS）问题。类似的题目可以通过调整状态转移方程来解决。

### 推荐题目
1. [P1143 最长公共子序列](https://www.luogu.com.cn/problem/P1143)
2. [P1439 最长公共子序列（LCS）](https://www.luogu.com.cn/problem/P1439)
3. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)

### 个人心得
- **调试经历**：在处理取模操作时，容易出现负数情况，需要额外处理。
- **踩坑教训**：初始化时要注意空子序列的情况，否则会导致结果错误。
- **顿悟感想**：动态规划的状态转移方程设计是关键，理解清楚问题本质后，代码实现相对简单。

---
处理用时：27.87秒
# 题目信息

# [ABC132E] Hopscotch Addict

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc132/tasks/abc132_e

ケンくんはけんけんぱが大好きです。今日は有向グラフ $ G $ の上でけんけんぱをすることにしました。 $ G $ は $ 1 $ から $ N $ で番号付けされた $ N $ 頂点および $ M $ 辺からなり、 $ i $ 番目の辺は頂点 $ u_i $ から頂点 $ v_i $ に接続しています。

ケンくんははじめ頂点 $ S $ にいて、頂点 $ T $ までけんけんぱで移動したいです。 $ 1 $ 回のけんけんぱでは、「自分の今いる頂点から出ている辺を $ 1 $ つ選んで、その辺が接続する頂点に移動する」という操作をちょうど $ 3 $ 回連続で行います。

ケンくんが頂点 $ T $ に移動することができるか、また移動できるなら最小何回のけんけんぱで頂点 $ T $ まで移動することができるかを答えてください。 けんけんぱの操作の途中で頂点 $ T $ に訪れても、「頂点 $ T $ に移動できた」とは見なさないことに注意してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min(10^5,\ N\ (N-1)) $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N(1\ \leq\ i\ \leq\ M) $
- $ u_i\ \neq\ v_i\ (1\ \leq\ i\ \leq\ M) $
- $ i\ \neq\ j $ ならば $ (u_i,\ v_i)\ \neq\ (u_j,\ v_j) $
- $ 1\ \leq\ S,\ T\ \leq\ N $
- $ S\ \neq\ T $

### Sample Explanation 1

$ 1 $ 回目のけんけんぱでは $ 1\ \rightarrow\ 2\ \rightarrow\ 3\ \rightarrow\ 4 $、$ 2 $ 回目のけんけんぱでは $ 4\ \rightarrow\ 1\ \rightarrow\ 2\ \rightarrow\ 3 $ と移動することで頂点 $ 3 $ に辿り着くことができ、これが最小回数です。

### Sample Explanation 2

何回けんけんぱを繰り返しても頂点 $ 1 $ に辿り着くため、頂点 $ 2 $ に移動することは不可能です。 けんけんぱの途中で頂点 $ 2 $ を通過することはできますが、これは移動できたとは見なしません。

### Sample Explanation 3

頂点 $ S $ と頂点 $ T $ は非連結である場合があります。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 1

1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

1 2

2 3

3 1

1 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 0

1 2```

### 输出

```
-1```

## 样例 #4

### 输入

```
6 8

1 2

2 3

3 4

4 5

5 1

1 4

1 5

4 6

1 6```

### 输出

```
2```

# AI分析结果

### 题目重写
【题目内容】
# [ABC132E] Hopscotch Addict

## 题目描述

ケンくんはけんけんぱが大好きです。今日は有向グラフ $ G $ の上でけんけんぱをすることにしました。 $ G $ は $ 1 $ から $ N $ で番号付けされた $ N $ 頂点および $ M $ 辺からなり、 $ i $ 番目の辺は頂点 $ u_i $ から頂点 $ v_i $ に接続しています。

ケンくんははじめ頂点 $ S $ にいて、頂点 $ T $ までけんけんぱで移動したいです。 $ 1 $ 回のけんけんぱでは、「自分の今いる頂点から出ている辺を $ 1 $ つ選んで、その辺が接続する頂点に移動する」という操作をちょうど $ 3 $ 回連続で行います。

ケンくんが頂点 $ T $ に移動することができるか、また移動できるなら最小何回のけんけんぱで頂点 $ T $ まで移動することができるかを答えてください。 けんけんぱの操作の途中で頂点 $ T $ に訪れても、「頂点 $ T $ に移動できた」とは見なさないことに注意してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min(10^5,\ N\ (N-1)) $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N(1\ \leq\ i\ \leq\ M) $
- $ u_i\ \neq\ v_i\ (1\ \leq\ i\ \leq\ M) $
- $ i\ \neq\ j $ ならば $ (u_i,\ v_i)\ \neq\ (u_j,\ v_j) $
- $ 1\ \leq\ S,\ T\ \leq\ N $
- $ S\ \neq\ T $

### Sample Explanation 1

$ 1 $ 回目のけんけんぱでは $ 1\ \rightarrow\ 2\ \rightarrow\ 3\ \rightarrow\ 4 $、$ 2 $ 回目のけんけんぱでは $ 4\ \rightarrow\ 1\ \rightarrow\ 2\ \rightarrow\ 3 $ と移動することで頂点 $ 3 $ に辿り着くことができ、これが最小回数です。

### Sample Explanation 2

何回けんけんぱを繰り返しても頂点 $ 1 $ に辿り着くため、頂点 $ 2 $ に移動することは不可能です。 けんけんぱの途中で頂点 $ 2 $ を通過することはできますが、これは移動できたとは見なしません。

### Sample Explanation 3

頂点 $ S $ と頂点 $ T $ は非連結である場合があります。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 1

1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

1 2

2 3

3 1

1 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 0

1 2```

### 输出

```
-1```

## 样例 #4

### 输入

```
6 8

1 2

2 3

3 4

4 5

5 1

1 4

1 5

4 6

1 6```

### 输出

```
2```

### 算法分类
最短路

### 题解分析与结论
本题的核心在于如何在有向图中找到从起点 $S$ 到终点 $T$ 的最短路径，且每次移动必须恰好走三步。多个题解都采用了分层图的思想，将每个点拆分成三个状态，分别表示走 $3k$, $3k+1$, $3k+2$ 步后的状态，然后通过 BFS 或 Dijkstra 算法求解最短路。

### 高星题解推荐
1. **作者：RainFestival (5星)**
   - **关键亮点**：使用分层图的思想，将每个点拆分成三个状态，通过 BFS 求解最短路，代码简洁且时间复杂度为 $O(n+m)$。
   - **代码核心**：
     ```cpp
     void bfs(int s) {
         std::queue<int> q;
         for (int i=1;i<=3*n;i++) dis[i]=1000000000;
         dis[s]=0;q.push(s);
         while (!q.empty()) {
             int v=q.front();q.pop();
             for (int i=0;i<a[v].size();i++) {
                 int u=a[v][i];
                 if (dis[v]+1<dis[u]) dis[u]=dis[v]+1,q.push(u);
             }
         }
     }
     ```

2. **作者：lkjzyd20 (4星)**
   - **关键亮点**：同样采用分层图思想，使用 SPFA 算法求解最短路，代码清晰且易于理解。
   - **代码核心**：
     ```cpp
     void SPFA (int s) {
         memset (val, 0x3f, sizeof val) ;
         val[s] = 0;
         q.push (s) ;
         for (; !q.empty () ;) {
             int x = q.front () ;
             q.pop () ;
             f[x] = 1;
             for (int i = now[x]; i; i = pre[i]) {
                 int y = son[i];
                 if (val[y] > val[x] + 1) {
                     val[y] = val[x] + 1;
                     if (!f[y]) {
                         f[y] = 1;
                         q.push (y) ;
                     }
                 }
             }
         }
     }
     ```

3. **作者：panyanppyy (4星)**
   - **关键亮点**：使用分层图思想，通过 Dijkstra 算法求解最短路，代码结构清晰，且对数组大小进行了合理处理。
   - **代码核心**：
     ```cpp
     void dij(int s){
         queue <node> q;
         for(int i=1;i<=3*n;i++) dis[i]=inf; 
         q.push((node){0,s});
         dis[s]=0;
         while(!q.empty()){
             int u=q.front().id;
             q.pop();
             if(vis[u]) continue;
             vis[u]=1;
             for(int i=head[u];i;i=e[i].nxt){
                 int v=e[i].to;
                 if(dis[v]>dis[u]+1){
                     dis[v]=dis[u]+1;
                     if(!vis[v]) q.push((node){dis[v],v});
                 }
             }
         }
     }
     ```

### 最优关键思路
分层图思想是解决本题的关键，通过将每个点拆分成三个状态，可以有效避免在移动过程中未达到三步的情况。BFS 或 Dijkstra 算法均可用于求解最短路，时间复杂度为 $O(n+m)$。

### 拓展思路
类似的分层图思想可以应用于其他需要特定步数或状态转移的图论问题，如最短路径问题中的步数限制、状态转移等。

### 推荐题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)
3. [P1948 [USACO08OPEN]Roads Around The Farm S](https://www.luogu.com.cn/problem/P1948)

### 个人心得
在调试过程中，确保数组大小开足够大以避免越界错误是非常重要的。此外，分层图的思想在处理特定步数问题时非常有效，可以大大简化问题的复杂度。

---
处理用时：47.51秒
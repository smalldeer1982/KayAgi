# 题目信息

# [ABC133E] Virus Tree 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc133/tasks/abc133_e

$ N $ 頂点、$ N-1 $ 辺を持つ木が与えられます。 頂点には番号 $ 1,2,...,N $ がつけられており、$ i $ 番目の辺は頂点 $ a_i,b_i $ をつないでいます。

あなたは $ K $ 色の絵の具を持っています。 木の頂点それぞれに対して、以下の条件を満たすように、$ K $ 色の中から $ 1 $ 色を選んで塗ることにしました。

- 二つの異なる頂点 $ x,y $ 間の距離が $ 2 $ 以下ならば、頂点 $ x $ の色と頂点 $ y $ の色は異なる。

木を塗り分ける方法は何通りあるでしょうか。 総数を $ 1,000,000,007 $ で割った余りを求めてください。

木とは

木とはグラフの一種です。詳しくはこちらをご覧ください: [Wikipedia「木 (数学)」](https://ja.wikipedia.org/wiki/%E6%9C%A8_(%E6%95%B0%E5%AD%A6))

距離とは

二つの頂点 $ x,y $ 間の距離とは、$ x $ から $ y $ に到達する際にたどる必要のある最小の辺数です。

## 说明/提示

### 制約

- $ 1\ \leqq\ N,K\ \leqq\ 10^5 $
- $ 1\ \leqq\ a_i,b_i\ \leqq\ N $
- 与えられるグラフは木である。

### Sample Explanation 1

!\[zu\](https://img.atcoder.jp/ghi/491cd56a53e99ba7677ee4827b8f767a.png) 塗り分け方は $ 6 $ 通りです。

## 样例 #1

### 输入

```
4 3

1 2

2 3

3 4```

### 输出

```
6```

## 样例 #2

### 输入

```
5 4

1 2

1 3

1 4

4 5```

### 输出

```
48```

## 样例 #3

### 输入

```
16 22

12 1

3 1

4 16

7 12

6 2

2 15

5 16

14 16

10 11

3 10

3 13

8 6

16 8

9 12

4 3```

### 输出

```
271414432```

# AI分析结果

### 题目内容重写
给定一棵包含 $N$ 个顶点和 $N-1$ 条边的树，顶点编号为 $1,2,...,N$。第 $i$ 条边连接顶点 $a_i$ 和 $b_i$。你拥有 $K$ 种颜色的颜料，要求为每个顶点选择一种颜色，满足以下条件：
- 对于任意两个不同的顶点 $x$ 和 $y$，如果它们之间的距离不超过 $2$，则它们的颜色必须不同。

求满足条件的涂色方案数，结果对 $1,000,000,007$ 取模。

### 算法分类
深度优先搜索 DFS、组合数学

### 题解分析与结论
本题的核心是通过 DFS 遍历树，并结合组合数学计算每个节点的可选颜色数。难点在于如何高效地计算每个节点的颜色选择，避免重复计算和颜色冲突。以下是几条题解的对比与总结：

1. **Zhangikun 的题解**：
   - **思路**：通过 DFS 遍历树，记录每个节点的父节点和爷爷节点，计算当前节点的可选颜色数。
   - **难点**：需要处理兄弟节点之间的颜色冲突，确保颜色选择不重复。
   - **优化**：使用动态规划的思想，逐步计算每个节点的颜色选择数，避免重复计算。
   - **评分**：4星
   - **关键代码**：
     ```cpp
     void dfs(int cur, int fa, int grand, int id) {
         int num = 0;
         if (fa) num++;
         if (grand) num++;
         num += id;
         if (k - num <= 0) {
             f = 1;
             return;
         }
         dp[cur] = (k - num) % mod;
         int ii = -1;
         for (int i = 0; i < nbr[cur].size(); i++) {
             int nxt = nbr[cur][i];
             if (nxt == fa) continue;
             dfs(nxt, cur, fa, ++ii);
             dp[cur] = (dp[cur] % mod * (dp[nxt] % mod)) % mod;
         }
     }
     ```

2. **b6e0_ 的题解**：
   - **思路**：按照 DFS 序遍历树，计算每个节点的可选颜色数，确保与父节点和爷爷节点的颜色不同。
   - **难点**：需要处理兄弟节点之间的颜色冲突，确保颜色选择不重复。
   - **优化**：通过记录兄弟节点的数量，动态调整当前节点的可选颜色数。
   - **评分**：4星
   - **关键代码**：
     ```cpp
     void dfs(int x, int f, int d) {
         int p = 0;
         for (int i = 0; i < g[x].size(); i++) {
             if (g[x][i] != f) {
                 if (p) a[g[x][i]] = p - 1;
                 else a[g[x][i]] = k - (d ? 2 : 1);
                 p = a[g[x][i]];
             }
         }
         for (int i = 0; i < g[x].size(); i++) {
             if (g[x][i] != f) dfs(g[x][i], x, d + 1);
         }
     }
     ```

3. **LCat90 的题解**：
   - **思路**：通过 DFS 遍历树，记录每个节点的深度，计算当前节点的可选颜色数。
   - **难点**：需要处理兄弟节点之间的颜色冲突，确保颜色选择不重复。
   - **优化**：通过记录兄弟节点的数量，动态调整当前节点的可选颜色数。
   - **评分**：4星
   - **关键代码**：
     ```cpp
     void dfs(int now, int father) {
         depth[now] = depth[father] + 1;
         for (int i = head[now]; i != 0; i = e[i].next) {
             if (e[i].to != father) dfs(e[i].to, now);
         }
     }
     ```

### 最优关键思路
通过 DFS 遍历树，记录每个节点的父节点和爷爷节点，动态计算当前节点的可选颜色数，确保与父节点和爷爷节点的颜色不同。同时，通过记录兄弟节点的数量，避免颜色冲突。

### 拓展思路
类似的问题可以扩展到更复杂的图结构，如带权图或有向图。可以通过类似的方法，结合 DFS 和动态规划，计算每个节点的可选颜色数。

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

---
处理用时：32.95秒
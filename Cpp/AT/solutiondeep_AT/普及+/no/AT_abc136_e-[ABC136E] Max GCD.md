# 题目信息

# [ABC136E] Max GCD

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc136/tasks/abc136_e

長さ $ N $ の整数列 $ A_1,\ A_2,\ \cdots,\ A_N $ があります。

次の操作を $ 0 $ 回以上 $ K $ 回以下行うことができます。

- $ i\ \neq\ j $ なる $ 1 $ 以上 $ N $ 以下の $ 2 $ つの整数 $ i,\ j $ を選び、$ A_i $ に $ 1 $ を足し、$ A_j $ に $ -1 $ を足す。この操作の後いずれかの要素が負になってもよい。

操作後の $ A $ の全ての要素を割り切る正の整数として考えられる値の最大値を計算してください。ただし、正の整数 $ x $ が整数 $ y $ を割り切るとは、ある整数 $ z $ を用いて $ y\ =\ xz $ と表せる場合を表します。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ A_i\ \leq\ 10^6 $
- $ 0\ \leq\ K\ \leq\ 10^9 $
- 入力は全て整数である

### Sample Explanation 1

例えば以下の操作で、$ 7 $ が $ A $ の全ての要素を割り切るようにできます。 - $ i\ =\ 2,\ j\ =\ 1 $ とする。$ A $ は $ (7,\ 21) $ となる。 また、$ 8 $ 以上の整数が $ A $ の全ての要素を割り切るようにはできません。

### Sample Explanation 2

例えば、以下のように操作を $ 5 $ 回行います。 - $ i\ =\ 2,\ j\ =\ 1 $ とする。$ A $ は $ (2,\ 6) $ となる。 - $ i\ =\ 2,\ j\ =\ 1 $ とする。$ A $ は $ (1,\ 7) $ となる。 - $ i\ =\ 2,\ j\ =\ 1 $ とする。$ A $ は $ (0,\ 8) $ となる。 - $ i\ =\ 2,\ j\ =\ 1 $ とする。$ A $ は $ (-1,\ 9) $ となる。 - $ i\ =\ 1,\ j\ =\ 2 $ とする。$ A $ は $ (0,\ 8) $ となる。 このとき、$ 0\ =\ 8\ \times\ 0,\ 8\ =\ 8\ \times\ 1 $ と表せるので、$ 8 $ は $ A $ の全ての要素を割り切ります。また、$ 9 $ 以上の整数が $ A $ の全ての要素を割り切るようにはできません。

## 样例 #1

### 输入

```
2 3

8 20```

### 输出

```
7```

## 样例 #2

### 输入

```
2 10

3 5```

### 输出

```
8```

## 样例 #3

### 输入

```
4 5

10 1 2 22```

### 输出

```
7```

## 样例 #4

### 输入

```
8 7

1 7 5 6 8 2 6 5```

### 输出

```
5```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个长度为 $N$ 的整数序列 $A_1,\ A_2,\ \cdots,\ A_N$。

你可以进行不超过 $K$ 次操作，每次操作选择两个不同的下标 $i$ 和 $j$，将 $A_i$ 加 $1$，$A_j$ 减 $1$。操作后，序列中的元素可以为负数。

操作结束后，求序列中所有元素的最大公约数（GCD）的最大值。

**输入格式**

第一行包含两个整数 $N$ 和 $K$，表示序列的长度和最大操作次数。

第二行包含 $N$ 个整数 $A_1,\ A_2,\ \cdots,\ A_N$，表示初始序列。

**输出格式**

输出一个整数，表示操作后序列中所有元素的最大公约数的最大值。

**样例**

输入：
```
2 3
8 20
```
输出：
```
7
```

**说明/提示**

- $2 \leq N \leq 500$
- $1 \leq A_i \leq 10^6$
- $0 \leq K \leq 10^9$

### 算法分类

数学、枚举、贪心

### 题解分析与结论

所有题解的核心思路都是基于以下观察：
1. 操作不会改变序列的总和，因此最终的最大公约数必须是总和的因数。
2. 枚举总和的因数，并通过贪心策略计算使序列中所有元素成为该因数倍数所需的最小操作次数，判断是否在 $K$ 次操作内完成。

**关键思路与技巧**：
1. **枚举总和的因数**：由于总和的最大值为 $5 \times 10^8$，枚举其因数的复杂度为 $O(\sqrt{sum})$，在可接受范围内。
2. **贪心策略**：对于每个因数，计算序列中每个元素对该因数的余数，排序后通过双指针贪心地匹配余数较小的元素和余数较大的元素，计算所需操作次数。
3. **优化**：在枚举因数时，同时枚举 $i$ 和 $sum/i$，减少枚举次数。

### 评分较高的题解

#### 1. 作者：wuwendongxi (5星)
**关键亮点**：
- 代码简洁，逻辑清晰。
- 使用双指针贪心策略，高效计算操作次数。
- 枚举因数时同时处理 $i$ 和 $sum/i$，优化了枚举过程。

**核心代码**：
```cpp
bool check(int x) {
    for(int i=1;i<=n;i++) det[i]=a[i]%x;
    sort(det+1,det+n+1);
    int l=1,r=n; long long opc=0;
    while(l<=r) {
        while(det[l]%x==0&&l<=r) ++l;
        while(det[r]%x==0&&l<=r) --r;
        int tmp=min(det[l]%x,x-det[r]%x);
        det[l]-=tmp,det[r]+=tmp; opc+=tmp;
    }
    return (opc<=k);
}
```

#### 2. 作者：TLEWA (4星)
**关键亮点**：
- 详细证明了最大公约数必须是总和的因数。
- 贪心策略实现清晰，代码可读性好。

**核心代码**：
```cpp
bool check(int num) {
    for(int i=1;i<=n;++i) cost_arr[i]=arr[i]%num;
    sort(cost_arr+1,cost_arr+1+n);
    int cost=0,l=1,r=n;
    while(l<=r && cost<=k) {
        if(!cost_arr[l]) {l++;continue;}
        else if(cost_arr[r]==num) {r--;continue;}
        int cnt=min(cost_arr[l],num-cost_arr[r]);
        cost_arr[l]-=cnt,cost_arr[r]+=cnt,cost+=cnt;
        if(cost_arr[r]==num) r--;
    }
    return cost<=k;
}
```

#### 3. 作者：Dreamerly (4星)
**关键亮点**：
- 代码结构清晰，注释详细。
- 使用向量存储余数，排序后双指针贪心匹配。

**核心代码**：
```cpp
bool check(int x){
    vector<int> ve;
    int res=0;
    for(int i=1;i<=n;i++){
        if(a[i]%x) ve.push_back(a[i]%x);
    }
    sort(ve.begin(),ve.end());
    int l=0,r=ve.size()-1;
    while(l<r){
        int tmp=min(ve[l],x-ve[r]);
        res+=tmp;
        ve[l]-=tmp;
        if(!ve[l]) l++;
        ve[r]+=tmp;
        if(ve[r]==x) r--;
    }
    return res<=k;
}
```

### 可拓展之处

类似的问题可以通过枚举因数并结合贪心策略来解决，例如：
1. 给定一个序列，通过有限次操作使序列满足某种性质（如所有元素相等、所有元素为某个数的倍数等）。
2. 在操作次数有限的情况下，最大化或最小化序列的某个性质（如最大公约数、最小公倍数等）。

### 推荐题目

1. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P1062 数列](https://www.luogu.com.cn/problem/P1062)
3. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)

---
处理用时：37.35秒
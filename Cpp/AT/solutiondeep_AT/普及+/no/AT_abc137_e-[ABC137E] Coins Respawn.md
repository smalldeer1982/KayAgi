# 题目信息

# [ABC137E] Coins Respawn

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc137/tasks/abc137_e

$ 1 $ から $ N $ までの番号がつけられた $ N $ 頂点と $ M $ 辺からなる有向グラフがあります。 $ i $ 番目の辺は頂点 $ A_i $ から頂点 $ B_i $ へと向かい、この辺の上には $ C_i $ 枚のコインが置かれています。 また、頂点 $ N $ にはボタンが設置されています。

このグラフ上でゲームを行います。 あなたは頂点 $ 1 $ でコインを $ 0 $ 枚持ってゲームを開始し、辺をたどってコインを拾いながら頂点 $ N $ を目指します。 $ 1 $ 本の辺を通るには $ 1 $ 分の時間がかかり、辺を通るたびにその辺の上に置かれているすべてのコインを拾うことができます。 ゲームの世界ではよくあるように、ある辺を通ってその上のコインを拾っても、その辺を次に通る際には同じ枚数のコインが再び出現しており、それらを再び拾うことができます。

頂点 $ N $ に到着したとき、ボタンを押してゲームを終了することができます。(ボタンを押さずに移動を続けることもできます。) ただし、ゲームを終了する際に、ゲーム開始からの経過時間を $ T $ 分として $ T\ \times\ P $ 枚のコインの支払いが要求されます。持っているコインの枚数が $ T\ \times\ P $ 枚未満の場合は、代わりに持っているコインをすべて支払います。

この支払いの後に残ったコインの枚数があなたのスコアとなります。 獲得できるスコアの最大値が存在するか判定し、存在する場合はその最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2500 $
- $ 1\ \leq\ M\ \leq\ 5000 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N $
- $ 1\ \leq\ C_i\ \leq\ 10^5 $
- $ 0\ \leq\ P\ \leq\ 10^5 $
- 入力中の値はすべて整数である。
- 頂点 $ 1 $ から頂点 $ N $ に到達することが可能である。

### Sample Explanation 1

!\[入力例 1 で与えられるグラフの図\](https://img.atcoder.jp/ghi/5cb074e2d7c3282da137ac4ab2fbc700.png) 頂点 $ 1 $ から頂点 $ 3 $ に移動する方法は以下の $ 2 $ 通りです。 - 頂点 $ 1\ \rightarrow\ 2\ \rightarrow\ 3 $: 道中でコインを $ 20\ +\ 30\ =\ 50 $ 枚拾う。ゲーム開始から $ 2 $ 分後に頂点 $ 3 $ に着き、ボタンを押してコインを $ 2\ \times\ 10\ =\ 20 $ 枚支払い、$ 50\ -\ 20\ =\ 30 $ 枚残る。 - 頂点 $ 1\ \rightarrow\ 3 $: 道中でコインを $ 45 $ 枚拾う。ゲーム開始から $ 1 $ 分後に頂点 $ 3 $ に着き、ボタンを押してコインを $ 1\ \times\ 10\ =\ 10 $ 枚支払い、$ 45\ -\ 10\ =\ 35 $ 枚残る。 よって、獲得できるスコアの最大値は $ 35 $ です。

### Sample Explanation 2

!\[入力例 2 で与えられるグラフの図\](https://img.atcoder.jp/ghi/eb2188ad1e8189f963d233415fb293b6.png) 頂点 $ 1 $ から伸びる辺を通ると頂点 $ 2 $ に着き、ここで頂点 $ 2 $ から自分自身へと向かう辺を $ t $ 回通ってからボタンを押すとスコアは $ 90\ +\ 90t $ となります。よってスコアは無限に高めることができ、獲得できるスコアの最大値は存在しません。

### Sample Explanation 3

!\[入力例 3 で与えられるグラフの図\](https://img.atcoder.jp/ghi/217f7a224b80a05d8e25140c57e65ae7.png) 頂点 $ 1 $ から頂点 $ 4 $ へと直接向かう辺を通ること以外に頂点 $ 1 $ から頂点 $ 4 $ に移動する方法はありません。この辺の上で $ 1 $ 枚のコインを拾いますが、ゲーム終了時に $ 10 $ 枚のコインの支払いを要求されてスコアは $ 0 $ となります。 なお、頂点 $ 1 $ から頂点 $ 2 $ へと向かう辺を通るとその後コインを無限に拾えますが、頂点 $ 4 $ に到達してゲームを終了することができなくなるため無意味です。

## 样例 #1

### 输入

```
3 3 10

1 2 20

2 3 30

1 3 45```

### 输出

```
35```

## 样例 #2

### 输入

```
2 2 10

1 2 100

2 2 100```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 5 10

1 2 1

1 4 1

3 4 1

2 2 100

3 3 100```

### 输出

```
0```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个有向图，包含 $N$ 个顶点和 $M$ 条边，顶点编号从 $1$ 到 $N$。每条边从顶点 $A_i$ 指向顶点 $B_i$，并且这条边上放置了 $C_i$ 枚硬币。顶点 $N$ 上有一个按钮。

在游戏中，你从顶点 $1$ 开始，初始时没有硬币。你可以沿着边移动，每经过一条边需要花费 $1$ 分钟，并且可以拾取该边上的所有硬币。每次经过一条边时，硬币会重新出现，因此你可以多次拾取同一枚硬币。

当你到达顶点 $N$ 时，可以按下按钮结束游戏（也可以选择继续移动）。游戏结束时，你需要支付 $T \times P$ 枚硬币，其中 $T$ 是游戏开始到结束的时间。如果你的硬币数量不足 $T \times P$，则需要支付所有硬币。

你的得分是支付后剩余的硬币数量。请判断是否存在最大得分，如果存在，请计算最大得分。

#### 说明/提示

- 约束条件：
  - $2 \leq N \leq 2500$
  - $1 \leq M \leq 5000$
  - $1 \leq A_i, B_i \leq N$
  - $1 \leq C_i \leq 10^5$
  - $0 \leq P \leq 10^5$
  - 输入中的所有值都是整数。
  - 从顶点 $1$ 到顶点 $N$ 是可达的。

#### 样例解释

**样例 1**：
- 输入：
  ```
  3 3 10
  1 2 20
  2 3 30
  1 3 45
  ```
- 输出：
  ```
  35
  ```
- 解释：
  从顶点 $1$ 到顶点 $3$ 有两条路径：
  1. $1 \rightarrow 2 \rightarrow 3$：拾取 $20 + 30 = 50$ 枚硬币，花费 $2$ 分钟，支付 $2 \times 10 = 20$ 枚硬币，剩余 $30$ 枚。
  2. $1 \rightarrow 3$：拾取 $45$ 枚硬币，花费 $1$ 分钟，支付 $1 \times 10 = 10$ 枚硬币，剩余 $35$ 枚。
  最大得分为 $35$。

**样例 2**：
- 输入：
  ```
  2 2 10
  1 2 100
  2 2 100
  ```
- 输出：
  ```
  -1
  ```
- 解释：
  从顶点 $1$ 到顶点 $2$ 的路径上有一个正环，可以无限增加硬币数量，因此不存在最大得分。

**样例 3**：
- 输入：
  ```
  4 5 10
  1 2 1
  1 4 1
  3 4 1
  2 2 100
  3 3 100
  ```
- 输出：
  ```
  0
  ```
- 解释：
  从顶点 $1$ 到顶点 $4$ 的唯一路径是 $1 \rightarrow 4$，拾取 $1$ 枚硬币，支付 $10$ 枚硬币，得分为 $0$。

### 算法分类

图论、最短路

### 题解分析与结论

本题的核心问题是在有向图中寻找从顶点 $1$ 到顶点 $N$ 的最长路径，并且需要考虑路径上的边权和是否为正环。如果存在正环且该环与顶点 $N$ 连通，则得分可以无限增加，输出 `-1`；否则，输出最大得分。

### 精选题解

#### 题解 1：Lynkcat (5星)

**关键亮点**：
- 将边权转化为 $val - P$，简化了问题。
- 使用 SPFA 算法寻找最长路径，并判断是否存在正环。
- 通过 DFS 预处理，确保只处理与顶点 $N$ 连通的点，避免无效环的干扰。

**代码核心实现**：
```cpp
void dfs(int k) {
    if (vis[k]) return;
    vis[k] = 1;
    for (auto u : G[k]) dfs(u);
}

void SPFA() {
    memset(dis, -0x3f, sizeof(dis));
    dis[1] = 0, Vis[1] = 1;
    int l = 1, r = 0; q[++r] = 1;
    while (l <= r) {
        int u = q[l]; l++;
        Vis[u] = 0;
        for (auto v : g[u]) {
            if (!vis[v.fi]) continue;
            if (dis[v.fi] < dis[u] + v.se) {
                dis[v.fi] = dis[u] + v.se;
                if (!Vis[v.fi]) { cnt[v.fi]++, Vis[v.fi] = 1, q[++r] = v.fi; }
                if (cnt[v.fi] > n) {
                    ans = 1;
                    return;
                }
            }
        }
    }
}
```

#### 题解 2：Billhqh9 (4星)

**关键亮点**：
- 详细解释了为什么需要将边权转化为 $val - P$。
- 使用 SPFA 算法寻找最长路径，并判断正环。
- 通过反图 DFS 预处理，确保只处理与顶点 $N$ 连通的点。

**代码核心实现**：
```cpp
void dfs(int x) {
    if (f[x]) return;
    f[x] = 1;
    for (int i = 0; i < G[x].size(); i++) dfs(G[x][i]);
}

bool SPFA() {
    memset(dis, 0xcf, sizeof dis);
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        vis[x] = 0;
        for (int i = 0; i < g[x].size(); i++) {
            int nxt = g[x][i].v, num = g[x][i].w;
            if (dis[nxt] < dis[x] + num && f[nxt]) {
                dis[nxt] = dis[x] + num;
                if (!vis[nxt]) {
                    q.push(nxt);
                    cnt[nxt] = cnt[x] + 1;
                    vis[nxt] = 1;
                }
                if (cnt[nxt] > n) return 1;
            }
        }
    }
    return 0;
}
```

#### 题解 3：Atserckcn (4星)

**关键亮点**：
- 详细解释了如何通过边权转化简化问题。
- 使用 SPFA 算法寻找最长路径，并判断正环。
- 通过反图 DFS 预处理，确保只处理与顶点 $N$ 连通的点。

**代码核心实现**：
```cpp
void dfs(ljl u) {
    if (vis_in_dfs[u]) return;
    vis_in_dfs[u] = 1;
    for (auto i : vec[u]) dfs(i);
}

bool spfa() {
    memset(dis, -0x3f, sizeof dis);
    queue<ljl> q;
    q.push(1); vis[1] = 1;
    while (!q.empty()) {
        auto u = q.front(); q.pop();
        vis[u] = 0;
        for (ljl i = head[u]; i; i = e[i].pre) {
            ljl v = e[i].to, w = e[i].w;
            if (!vis_in_dfs[v]) continue;
            if (dis[v] < dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    vis[v] = 1;
                    q.push(v);
                    cnt[v] = cnt[u] + 1;
                    if (cnt[v] >= n) return 1;
                }
            }
        }
    }
    return 0;
}
```

### 最优关键思路

1. **边权转化**：将每条边的边权转化为 $val - P$，这样可以直接通过最长路径计算得分。
2. **正环判断**：使用 SPFA 算法寻找最长路径时，判断是否存在正环。如果存在正环且该环与顶点 $N$ 连通，则得分可以无限增加。
3. **预处理**：通过反图 DFS 预处理，确保只处理与顶点 $N$ 连通的点，避免无效环的干扰。

### 可拓展之处

类似的问题可以扩展到其他图论问题，如最短路径、负环判断等。SPFA 算法在处理带有负权边的图时非常有用，但需要注意其时间复杂度可能较高。

### 推荐题目

1. [P1807 最长路](https://www.luogu.com.cn/problem/P1807)
2. [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
3. [P3385 负环](https://www.luogu.com.cn/problem/P3385)

---
处理用时：61.31秒
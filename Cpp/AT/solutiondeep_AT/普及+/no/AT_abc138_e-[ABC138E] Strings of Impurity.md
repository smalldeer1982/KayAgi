# 题目信息

# [ABC138E] Strings of Impurity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc138/tasks/abc138_e

英小文字からなる二つの文字列 $ s,\ t $ が与えられます。次の条件を満たす整数 $ i $ $ (1\ \leq\ i\ \leq\ 10^{100}\ \times\ |s|) $ が存在するか判定し、存在する場合はそのような $ i $ の最小値を求めてください。

- $ s $ を $ 10^{100} $ 個連結して得られる文字列を $ s' $ とする。$ t $ は、文字列 $ {s'}_1{s'}_2\ldots{s'}_i $ ($ s' $ の先頭 $ i $ 文字) の部分列である。

## 说明/提示

### 注記

- 文字列 $ a $ の部分列とは、$ a $ から $ 0 $ 文字以上を削除して残った文字を相対的な順序を保ったまま連結して得られる文字列です。例えば、`contest` の部分列には `net`, `c`, `contest` などがあります。

### 制約

- $ 1\ \leq\ |s|\ \leq\ 10^5 $
- $ 1\ \leq\ |t|\ \leq\ 10^5 $
- $ s,\ t $ は英小文字からなる。

### Sample Explanation 1

$ t\ = $ `son` は文字列 `contestcon` ($ s'\ = $ `contestcontestcontest...` の先頭 $ 10 $ 文字) の部分列であるため、$ i\ =\ 10 $ は条件を満たします。 一方で、$ t $ は文字列 `contestco` ($ s' $ の先頭 $ 9 $ 文字) の部分列ではないため、$ i\ =\ 9 $ は条件を満たしません。 同様に、$ 8 $ 以下の任意の整数も条件を満たしません。よって、条件を満たす整数 $ i $ の最小値は $ 10 $ です。

### Sample Explanation 2

$ t\ = $ `programming` は $ s'\ = $ `contestcontestcontest...` の部分列ではありません。よって、条件を満たす整数 $ i $ は存在しません。

### Sample Explanation 3

ここにそのようなケースを置くことはできませんが、答えは $ 32 $ bit 整数に収まらない可能性があるのでご注意ください。

## 样例 #1

### 输入

```
contest

son```

### 输出

```
10```

## 样例 #2

### 输入

```
contest

programming```

### 输出

```
-1```

## 样例 #3

### 输入

```
contest

sentence```

### 输出

```
33```

# AI分析结果

### 题目内容重写
给定两个由小写字母组成的字符串 $s$ 和 $t$，判断是否存在一个整数 $i$（$1 \leq i \leq 10^{100} \times |s|$），使得将 $s$ 重复 $10^{100}$ 次后得到的字符串 $s'$ 的前 $i$ 个字符包含 $t$ 作为子序列。如果存在，求出最小的 $i$。

### 算法分类
字符串、贪心

### 题解分析与结论
本题的核心在于如何在无限重复的字符串 $s'$ 中高效地找到 $t$ 作为子序列的最小位置。大多数题解采用了贪心策略，即每次尽可能在 $s$ 中找到 $t$ 的字符，以减少重复次数。以下是几个关键思路：
1. **预处理字符位置**：通过预处理 $s$ 中每个字符出现的位置，可以快速找到下一个匹配字符的位置。
2. **二分查找优化**：使用二分查找在预处理的位置数组中快速找到下一个匹配字符的位置，减少时间复杂度。
3. **平衡树或 set 的使用**：部分题解使用了平衡树或 set 来维护字符的位置，进一步优化查找效率。

### 评分较高的题解
1. **作者：wuwendongxi (4星)**
   - **关键亮点**：预处理字符位置，使用二分查找优化匹配过程，代码简洁高效。
   - **代码核心**：
     ```cpp
     for(int i=0;i<lenb;++i) {
         if(p[lst][b[i]-'a']==-1) ++ans,lst=0;
         lst=p[lst][b[i]-'a']; ++lst;
         if(lst==lena) ++ans,lst=0;
     }
     ```
   - **个人心得**：通过预处理和二分查找，大大减少了匹配的时间复杂度，代码实现简洁明了。

2. **作者：small_john (4星)**
   - **关键亮点**：使用 `vector` 存储字符位置，结合 `lower_bound` 进行二分查找，思路清晰。
   - **代码核心**：
     ```cpp
     auto now = lower_bound(v[t[i]].begin(),v[t[i]].end(),pre);
     if(*now==pre) now++;
     int n1 = *now;
     if(n1==n+1) ans+=n,pre = v[t[i]][0];
     else pre = n1;
     ```
   - **个人心得**：通过 `lower_bound` 和 `vector` 的结合，实现了高效的字符匹配，代码可读性强。

3. **作者：Svemit (4星)**
   - **关键亮点**：使用 `set` 维护字符位置，结合贪心策略，实现简单且高效。
   - **代码核心**：
     ```cpp
     auto it = p[t[cur]].lower_bound(now + 1);
     if(it == p[t[cur]].end()) {
         now = -1;
         k ++;
         continue;
     }
     cur ++;
     now = *it;
     ```
   - **个人心得**：通过 `set` 的自动排序特性，简化了字符位置的查找过程，代码实现简洁。

### 最优关键思路与技巧
1. **预处理字符位置**：通过预处理 $s$ 中每个字符出现的位置，可以快速找到下一个匹配字符的位置，减少重复查找的时间。
2. **二分查找优化**：在预处理的位置数组中使用二分查找，进一步优化匹配过程，降低时间复杂度。
3. **贪心策略**：每次尽可能在 $s$ 中找到 $t$ 的字符，以减少重复次数，确保找到最小的 $i$。

### 可拓展之处
1. **类似问题**：可以扩展到多个字符串的匹配问题，或者更复杂的子序列匹配问题。
2. **数据结构优化**：可以使用更高效的数据结构（如平衡树、线段树）来维护字符位置，进一步优化查找效率。

### 推荐题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3808 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3808)
3. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)

---
处理用时：27.41秒
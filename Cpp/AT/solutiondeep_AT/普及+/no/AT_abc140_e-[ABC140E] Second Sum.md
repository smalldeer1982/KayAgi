# 题目信息

# [ABC140E] Second Sum

## 题目描述

### 题面描述

给出一个 $1 \sim n$ 的排列（即 $1 \sim n$ 每个数只出现一次）$P$。

给出一对 $[L, R]$，设 $X_{L, R}$ 是 $P_L \sim P_R$ 中的次大值（第二大值）。

求 $\sum_{L = 1}^{N - 1} \sum_{R = L + 1}^{N} X_{L, R}$。

注：即求所有 $[L, R]$ 区间的次大值之和。

## 说明/提示

#### 样例 1 解释

$X_{1, 2} = 2, X_{1, 3} = 2, X_{2, 3} = 1$，次大值和为 $2 + 2 + 1 = 5$。

#### 数据约束

对于 $100\%$ 的数据，保证：
- $2 \le N \le 10^5$
- $1 \le P_i \le N$
- $P_i \ne P_j (i \ne j)$
- $1 \le L < R \le N$
- 所有输入均为整数。

---

署名：[George222](https://www.luogu.com.cn/user/848194)

## 样例 #1

### 输入

```
3

2 3 1```

### 输出

```
5```

## 样例 #2

### 输入

```
5

1 2 3 4 5```

### 输出

```
30```

## 样例 #3

### 输入

```
8

8 2 7 3 4 5 6 1```

### 输出

```
136```

# AI分析结果

### 题目内容重写
【题目描述】  
给出一个 $1 \sim n$ 的排列（即 $1 \sim n$ 每个数只出现一次）$P$。  
给出一对 $[L, R]$，设 $X_{L, R}$ 是 $P_L \sim P_R$ 中的次大值（第二大值）。  
求 $\sum_{L = 1}^{N - 1} \sum_{R = L + 1}^{N} X_{L, R}$。  
注：即求所有 $[L, R]$ 区间的次大值之和。

### 算法分类
**组合数学**

### 题解分析与结论
本题的核心思路是通过枚举每个数作为次大值，并计算其在所有区间中作为次大值的贡献。难点在于如何高效地找到每个数作为次大值的区间范围。大多数题解采用了**单调栈**或**双向链表**来维护每个数的左右边界，从而快速计算贡献。

### 评分较高的题解
#### 1. 作者：Acfboy (赞：18)
**星级：5星**  
**关键亮点：**  
- 提供了两种解法，一种是基于单调栈和ST表的 $O(n \lg n)$ 解法，另一种是更巧妙的 $O(n)$ 线性解法。  
- 线性解法通过改变求解顺序，利用双向链表维护边界，避免了复杂的ST表操作，代码简洁高效。  
**核心代码：**
```cpp
for (int i = 1; i <= n; i++) {
    int l = L[map[i]], r = R[map[i]];
    if (l >= 1) ans += i * (l - L[l]) * (r - map[i]);
    if (r <= n) ans += i * (R[r] - r) * (map[i] - l);
    L[r] = l, R[l] = r;
}
```
**个人心得：**  
通过从小到大的顺序求解，避免了重复计算，极大地优化了时间复杂度。

#### 2. 作者：George222 (赞：4)
**星级：4星**  
**关键亮点：**  
- 使用双向链表和组合数学的思路，清晰地解释了如何通过维护左右边界来计算每个数的贡献。  
- 代码结构清晰，易于理解。  
**核心代码：**
```cpp
for (ll i = 1; i <= n; i++) {
    ll l1 = pre[a[i].id], l2 = pre[l1];
    ll r1 = nxt[a[i].id], r2 = nxt[r1];
    if (l2 != -1) ans += (l1 - l2) * (r1 - a[i].id) * a[i].x;
    if (r2 != -1) ans += (r2 - r1) * (a[i].id - l1) * a[i].x;
    del(a[i].id);
}
```
**个人心得：**  
通过链表的删除机制，确保每次处理时边界信息都是最新的，避免了重复计算。

#### 3. 作者：cosf (赞：2)
**星级：4星**  
**关键亮点：**  
- 使用 `set` 维护边界，代码简洁且易于实现。  
- 通过排序和插入顺序，确保每次查找边界时都是最新的。  
**核心代码：**
```cpp
for (int i = 1; i <= n; i++) {
    auto pl = s.lower_bound(b[i]);
    if (pl != s.end()) {
        r[p[i]] = *pl;
        if (next(pl) != s.end()) dr[p[i]] = *next(pl);
    }
    if (pl != s.begin()) {
        pl--;
        l[p[i]] = *pl;
        if (pl != s.begin()) dl[p[i]] = *prev(pl);
    }
    s.insert(p[i]);
}
```
**个人心得：**  
通过 `set` 的有序特性，快速找到每个数的左右边界，避免了复杂的边界维护。

### 最优关键思路
1. **改变求解顺序**：通过从小到大处理每个数，利用双向链表维护边界，避免重复计算，实现 $O(n)$ 的时间复杂度。
2. **边界维护**：使用单调栈或 `set` 维护每个数的左右边界，确保每次计算贡献时边界信息都是最新的。
3. **组合数学**：通过计算每个数作为次大值的区间数，结合乘法原理，快速计算贡献。

### 可拓展之处
- 类似的问题可以扩展到求第 $k$ 大值的贡献，思路类似，但需要维护更多的边界信息。
- 可以结合其他数据结构如线段树或树状数组，进一步优化边界查找的效率。

### 推荐题目
1. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)  
2. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)  
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

---
处理用时：35.08秒
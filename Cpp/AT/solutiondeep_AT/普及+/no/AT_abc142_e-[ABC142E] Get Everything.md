# 题目信息

# [ABC142E] Get Everything

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc142/tasks/abc142_e

鍵のかかった宝箱が $ N $ 個あり、$ 1 $ から $ N $ までの番号がつけられています。

店で $ M $ 個の鍵が売られています。$ i $ 個目の鍵は $ a_i $ 円で販売されており、$ b_i $ 種類の宝箱 $ c_{i1} $ , $ c_{i2} $ , ..., $ c_{i{b_i}} $ を開けることが出来ます。購入した鍵は何度でも使うことが出来ます。

全ての宝箱を開ける為に必要な費用の最小値を答えてください。全ての宝箱を開けることが不可能である場合は $ -1 $ を出力してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ <\ =\ N\ <\ =\ 12 $
- $ 1\ <\ =\ M\ <\ =\ 10^3 $
- $ 1\ \leq\ a_i\ \leq\ 10^5 $
- $ 1\ \leq\ b_i\ \leq\ N $
- $ 1\ \leq\ c_{i1}\ <\ c_{i2}\ <\ ...\ <\ c_{i{b_i}}\ \leq\ N $

### Sample Explanation 1

鍵 $ 1 $ と鍵 $ 2 $ を購入すると、全ての宝箱を開けることが出来ます。このときの費用は $ 25 $ 円であり、これが最小値です。

### Sample Explanation 2

全ての宝箱を開けることは出来ません。

## 样例 #1

### 输入

```
2 3

10 1

1

15 1

2

30 2

1 2```

### 输出

```
25```

## 样例 #2

### 输入

```
12 1

100000 1

2```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 6

67786 3

1 3 4

3497 1

2

44908 3

2 3 4

2156 3

2 3 4

26230 1

2

86918 1

3```

### 输出

```
69942```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $N$ 个上锁的宝箱，编号从 $1$ 到 $N$。商店里有 $M$ 把钥匙出售，第 $i$ 把钥匙的价格为 $a_i$ 元，可以打开 $b_i$ 个宝箱，编号分别为 $c_{i1}, c_{i2}, \dots, c_{i{b_i}}$。购买的钥匙可以无限次使用。求打开所有宝箱所需的最小费用。如果无法打开所有宝箱，则输出 $-1$。

#### 说明/提示

- 输入均为整数。
- $1 \leq N \leq 12$
- $1 \leq M \leq 10^3$
- $1 \leq a_i \leq 10^5$
- $1 \leq b_i \leq N$
- $1 \leq c_{i1} < c_{i2} < \dots < c_{i{b_i}} \leq N$

#### 样例

**样例 #1**

输入：
```
2 3
10 1
1
15 1
2
30 2
1 2
```
输出：
```
25
```

**样例 #2**

输入：
```
12 1
100000 1
2
```
输出：
```
-1
```

**样例 #3**

输入：
```
4 6
67786 3
1 3 4
3497 1
2
44908 3
2 3 4
2156 3
2 3 4
26230 1
2
86918 1
3
```
输出：
```
69942
```

### 算法分类
动态规划、位运算

### 题解分析与结论

#### 综合分析
本题的核心在于如何高效地表示和计算钥匙与宝箱的对应关系，并找到最小费用。由于 $N$ 的范围较小（$1 \leq N \leq 12$），可以使用状态压缩动态规划（DP）来解决问题。每个宝箱的状态可以用一个二进制位表示，钥匙的开启能力也可以用二进制数表示。通过 DP 状态转移，可以逐步计算打开所有宝箱的最小费用。

#### 最优关键思路
1. **状态压缩**：使用二进制数表示宝箱的开启状态，简化状态表示和转移。
2. **动态规划**：设计 DP 状态 $dp_S$ 表示打开状态为 $S$ 的宝箱所需的最小费用，通过枚举钥匙进行状态转移。
3. **初始化与边界处理**：初始化 DP 数组为极大值，处理无法打开所有宝箱的情况。

#### 可拓展之处
类似的状态压缩 DP 可以应用于其他需要枚举子集或组合的问题，如旅行商问题（TSP）、子集和问题等。

#### 推荐题目
1. [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)

### 高星题解

#### 题解1：StevenLiTheOIer (4星)
**关键亮点**：
- 使用状态压缩 DP，清晰地定义了状态和转移方程。
- 代码简洁，初始化与边界处理得当。

**核心代码**：
```cpp
int dp[(1 << 12) + 6], a[1006], cnt[1006];
int main() {
    int n, m;
    cin >> n >> m;
    memset(dp, 0x3f, sizeof(dp));
    for (int i = 1; i <= m; i++) {
        cin >> a[i];
        int b;
        cin >> b;
        for (int j = 1; j <= b; j++) {
            int c;
            cin >> c;
            cnt[i] |= (1 << (c - 1));
        }
    }
    dp[0] = 0;
    for (int S = 0; S <= (1 << n) - 1; S++) {
        if (dp[S] == 0x3f3f3f3f) continue;
        for (int i = 1; i <= m; i++)
            dp[S | cnt[i]] = min(dp[S | cnt[i]], dp[S] + a[i]);
    }
    if (dp[(1 << n) - 1] == 0x3f3f3f3f) cout << -1 << endl;
    else cout << dp[(1 << n) - 1] << endl;
    return 0;
}
```

#### 题解2：dd_d (4星)
**关键亮点**：
- 使用状态压缩 DP，代码结构清晰，易于理解。
- 通过枚举钥匙进行状态转移，逻辑清晰。

**核心代码**：
```cpp
int n, m, a[N], b[N], c[N][N], d[N], f[100001];
signed main() {
    n = read(); m = read();
    for (int i = 1; i <= m; i++) {
        a[i] = read(); b[i] = read();
        for (int j = 1; j <= b[i]; j++)
            c[i][read()] = 1;
        d[i] = 0;
        for (int j = 1; j <= n; j++) {
            d[i] *= 2;
            if (c[i][j] == 1) d[i]++;
        }
    }
    int k = (1 << n) - 1;
    for (int i = 1; i <= k; i++)
        f[i] = 1e9;
    f[0] = 0;
    for (int i = 0; i <= k; i++)
        for (int j = 1; j <= m; j++)
            f[i | d[j]] = min(f[i | d[j]], f[i] + a[j]);
    if (f[k] == 1e9) puts("-1");
    else writeln(f[k]);
}
```

#### 题解3：_zexal_ (4星)
**关键亮点**：
- 使用状态压缩 DP，代码简洁，状态转移清晰。
- 初始化与边界处理得当，代码可读性高。

**核心代码**：
```cpp
int f[1 << 15], h[Maxn], num[Maxn];
signed main() {
    memset(f, 0x7f, sizeof f);
    for (int i = 1; i <= (1 << 13); i++) f[i] = 1e14;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> h[i];
        cin >> k;
        for (int j = 1; j <= k; j++) {
            cin >> k1;
            num[i] += (1 << (k1 - 1));
            f[(1 << (k1 - 1))] = min(h[i], f[(1 << (k1 - 1))]);
        }
    }
    f[0] = 0;
    for (int i = 0; i < (1 << n); i++) {
        for (int j = 0; j < m; j++) {
            f[i | num[j]] = min(f[i | num[j]], f[i] + h[j]);
        }
    }
    if (f[(1 << n) - 1] != 1e14) cout << f[(1 << n) - 1];
    else cout << -1;
    return 0;
}
```

---
处理用时：52.22秒
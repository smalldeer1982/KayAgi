# 题目信息

# [ABC142F] Pure

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc142/tasks/abc142_f

$ N $ 頂点 $ M $ 辺の有向グラフ $ G $ が与えられます。  
 このグラフの頂点には $ 1 $ から $ N $ までの番号が付けられており、$ i $ 番目の辺は頂点 $ A_i $ から頂点 $ B_i $ に向けて張られています。  
 このグラフは自己辺や多重辺を持たないことが保証されています。

すべての頂点の入次数が $ 1 $、出次数が $ 1 $ であるような $ G $ の誘導部分グラフ (注記を参照) が存在するか判定し、 存在するならその一例を示してください。  
 ただし、空グラフは含めないものとします。

## 说明/提示

### 注記

有向グラフ $ G\ =\ (V,\ E) $ に対し、次のような条件を満たす有向グラフ $ G'\ =\ (V',\ E') $ を $ G $ の誘導部分グラフと呼びます。

- $ V' $ は $ V $ の (空でない) 部分集合である。
- $ E' $ は、$ E $ の辺であって両端点がともに $ V' $ に含まれるものすべてを含む集合である。

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 0\ \leq\ M\ \leq\ 2000 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ A_i\ \neq\ B_i $
- 組 $ (A_i,\ B_i) $ はすべて異なる。
- 入力はすべて整数である。

### Sample Explanation 1

頂点集合が $ \{1,\ 2,\ 4\} $ であるような $ G $ の誘導部分グラフの辺集合は $ \{(1,\ 2),\ (2,\ 4),\ (4,\ 1)\} $ であり、すべての頂点の入次数が $ 1 $、出次数が $ 1 $ となります。

### Sample Explanation 2

条件を満たす $ G $ の誘導部分グラフは存在しません。

## 样例 #1

### 输入

```
4 5

1 2

2 3

2 4

4 1

4 3```

### 输出

```
3

1

2

4```

## 样例 #2

### 输入

```
4 5

1 2

2 3

2 4

1 4

4 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 9

1 2

2 3

3 4

4 5

5 6

5 1

5 2

6 1

6 2```

### 输出

```
4

2

3

4

5```

# AI分析结果

### 题目内容重写
给定一个 $N$ 个顶点、$M$ 条边的有向图 $G$，顶点编号从 $1$ 到 $N$。第 $i$ 条边从顶点 $A_i$ 指向顶点 $B_i$。图中没有自环和多重边。

要求判断是否存在一个非空的诱导子图，使得该子图中每个顶点的入度和出度都为 $1$。如果存在，输出一个满足条件的子图。

### 算法分类
图论、深度优先搜索 (DFS)

### 题解分析与结论
题目要求找到一个满足条件的诱导子图，实际上就是寻找一个环，且环中的每个顶点的入度和出度都为 $1$。多个题解都采用了 DFS 或 BFS 来寻找图中的环，并通过栈记录路径来输出环中的顶点。

#### 题解评分与亮点
1. **作者：Lskkkno1 (4星)**
   - **亮点**：通过 DFS 寻找环，并使用栈记录路径。代码清晰，逻辑严谨，处理了特殊情况（如两个点之间的环）。
   - **代码核心**：
     ```cpp
     void dfs(int u) {
         stk[++top] = u;
         instack[u] = vis[u] = true;
         for(int i = head[u]; i; i = nex[i]) {
             int v = to[i];
             if(vis[v]) {
                 if(instack[v]) calc(u, v);
             } else {
                 dfs(v);
             }
         }
         instack[u] = false, --top;
     }
     ```
   - **个人心得**：作者提到 DFS 在比赛中通过，但后来被 hack 掉，提醒我们注意算法的鲁棒性。

2. **作者：small_john (4星)**
   - **亮点**：同样使用 DFS 和栈来寻找环，代码简洁，处理了特判情况。
   - **代码核心**：
     ```cpp
     void dfs(int u) {
         stk[++top] = u;
         vis[u] = vi[u] = 1;
         for(int i = head[u]; i; i = nxt[i]) {
             int v = to[i];
             if(vis[v] && vi[v]) print(v);
             dfs(v);
         }
         vi[u] = 0; --top;
     }
     ```
   - **个人心得**：作者强调了特判两个点之间的环，提醒我们在实现时要注意边界情况。

3. **作者：under_the_time (4星)**
   - **亮点**：详细解释了为什么需要找最小环，并通过 DFS 和栈实现，代码结构清晰。
   - **代码核心**：
     ```cpp
     void dfs(int u) {
         if (used[u]) {
             if (!vis[u]) return ;
             int now_siz = 1, i; 
             for (i = top; st[i] != u; i --, now_siz ++);
             if (siz <= now_siz) return ;
             siz = now_siz, ans.clear();
             for (; i <= top; i ++) ans.push_back(st[i]);
             return ;
         } vis[st[++ top] = u] = used[u] = 1;
         for (int i = head[u]; i; i = e[i].nxt) dfs(e[i].to);
         vis[st[top --]] = 0;
     }
     ```
   - **个人心得**：作者通过反例解释了为什么需要找最小环，帮助理解题目本质。

### 最优关键思路
1. **DFS 找环**：通过 DFS 遍历图，使用栈记录路径，当遇到已经在栈中的节点时，说明找到了一个环。
2. **最小环优先**：优先找到最小环，避免出现环套环的情况，确保子图中每个顶点的入度和出度都为 $1$。
3. **特判处理**：在开始 DFS 前，先特判两个点之间的环，避免遗漏特殊情况。

### 可拓展之处
- **类似题目**：可以扩展到无向图中寻找环，或者在有向图中寻找其他特定结构的子图。
- **算法优化**：可以考虑使用 Tarjan 算法或 Kosaraju 算法来寻找强连通分量，进一步优化环的查找。

### 推荐题目
1. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
2. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)
3. [P2746 [USACO5.3]校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)

---
处理用时：32.26秒
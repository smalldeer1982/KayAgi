# 题目信息

# [ABC145E] All-you-can-eat

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc145/tasks/abc145_e

高橋君は食べ放題のお店に来ました。

$ N $ 種類の料理があり、$ i $ 番目の料理は、食べるために $ A_i $ 分必要で、美味しさは $ B_i $ です。

この店のルールは以下の通りです。

- $ 1 $ 度に $ 1 $ つの料理のみを注文することができます。注文した料理は即座に提供され、食べ始めることができます。
- 同じ種類の料理を $ 2 $ 度以上注文することはできません。
- 提供済みの料理を食べ終わるまで次の料理を注文することはできません。
- 最初の注文から $ T-0.5 $ 分後以降に注文することはできませんが、提供済みの料理を食べることはできます。

高橋君の満足度を、この来店で高橋君が食べる料理の美味しさの合計とします。

高橋君が適切に行動したとき、満足度は最大でいくらになるでしょうか。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 3000 $
- $ 1\ \leq\ T\ \leq\ 3000 $
- $ 1\ \leq\ A_i\ \leq\ 3000 $
- $ 1\ \leq\ B_i\ \leq\ 3000 $
- 入力中のすべての値は整数である。

### Sample Explanation 1

$ 1 $ 番目、$ 2 $ 番目の順に料理を注文することで、満足度は $ 110 $ になります。 注文が時間内に間に合えば、食べるのにどれだけ時間がかかっても良いことに注意してください。

### Sample Explanation 2

$ 60 $ 分以内に全ての料理を食べることができます。

### Sample Explanation 3

$ 2 $ 番目、$ 3 $ 番目の順に料理に注文することで、満足度を $ 50 $ にできます。 どのような順に料理を注文しても、料理を $ 3 $ つ注文することはできません。

## 样例 #1

### 输入

```
2 60

10 10

100 100```

### 输出

```
110```

## 样例 #2

### 输入

```
3 60

10 10

10 20

10 30```

### 输出

```
60```

## 样例 #3

### 输入

```
3 60

30 10

30 20

30 30```

### 输出

```
50```

## 样例 #4

### 输入

```
10 100

15 23

20 18

13 17

24 12

18 29

19 27

23 21

18 20

27 15

22 25```

### 输出

```
145```

# AI分析结果

### 题目翻译
高桥君来到了一家自助餐厅。

餐厅有 $N$ 种料理，第 $i$ 种料理需要 $A_i$ 分钟吃完，美味度为 $B_i$。

餐厅的规则如下：
- 一次只能点一道菜，点菜后立即上菜并开始吃。
- 同一种菜不能点两次。
- 已经点的菜吃完之前不能点下一道菜。
- 从第一次点菜开始，$T-0.5$ 分钟后不能再点菜，但已经点的菜可以继续吃完。

高桥君的满意度定义为他在这次用餐中吃到的所有料理的美味度之和。求高桥君的最大满意度。

### 算法分类
动态规划

### 题解分析与结论
本题的核心是通过动态规划（DP）来解决，主要思路是将时间作为背包容量，美味度作为价值，进行 0-1 背包问题的变形。难点在于如何处理“时间到后不能点菜但可以继续吃”的规则，这要求我们在 DP 过程中将时间范围扩展到 $T + A_i - 1$。

大多数题解都采用了以下关键步骤：
1. **排序**：将料理按时间 $A_i$ 从小到大排序，优先选择时间短的料理，以便在有限时间内尽可能多地选择料理。
2. **DP 状态转移**：使用 $dp_j$ 表示在时间 $j$ 时吃完最后一道菜的最大美味度，状态转移方程为 $dp_j = \max(dp_j, dp_{j-A_i} + B_i)$。
3. **时间范围扩展**：由于时间到后可以继续吃，DP 的时间范围需要扩展到 $T + A_i - 1$。

### 精选题解
#### 1. 作者：Grisses (赞：7)
**星级：5星**
**关键亮点**：
- 代码简洁，思路清晰，直接使用 0-1 背包的变形。
- 详细解释了排序的必要性，并给出了 DP 状态转移的推导过程。
- 代码中通过 `sort` 函数对料理进行排序，并使用倒序循环进行 DP 更新，避免了重复计算。

**核心代码**：
```cpp
sort(a+1,a+n+1);
for(int i=1;i<=n;i++){
    for(int j=t+a[i].a-1;j>=a[i].a;j--){
        dp[j]=max(dp[j],dp[j-a[i].a]+a[i].b);
    }
}
```

#### 2. 作者：xibaohe (赞：3)
**星级：4星**
**关键亮点**：
- 提出了“升维型动规”的思路，使用三维 DP 数组来区分是否使用最后一分钟的点菜权。
- 状态转移方程清晰，分别处理了是否使用最后一分钟点菜权的两种情况。
- 代码实现较为复杂，但思路新颖，适合对 DP 有深入理解的同学。

**核心代码**：
```cpp
if(j>=w[i]){
    f[i][j][0]=max(f[i-1][j][0],f[i-1][j-w[i]][0]+v[i]);
    f[i][j][1]=max(f[i-1][j][0]+v[i],max(f[i-1][j][1],f[i-1][j-w[i]][1]+v[i]));
}
else{
    f[i][j][0]=f[i-1][j][0];
    f[i][j][1]=max(f[i-1][j][0]+v[i],f[i-1][j][1]);
}
```

#### 3. 作者：COsm0s (赞：2)
**星级：4星**
**关键亮点**：
- 代码简洁，直接使用 0-1 背包的变形，思路清晰。
- 详细解释了时间范围扩展的原因，并给出了 DP 状态转移的推导过程。
- 代码中通过 `sort` 函数对料理进行排序，并使用倒序循环进行 DP 更新。

**核心代码**：
```cpp
sort(a + 1, a + n + 1, cmp);
for(int i = 1; i <= n; i ++)
    for(int j = t + a[i].x - 1; j >= a[i].x; j --)
        f[j] = max(f[j], f[j - a[i].x] + a[i].y);
```

### 最优关键思路
1. **排序优先选择时间短的料理**：通过将料理按时间从小到大排序，确保在有限时间内尽可能多地选择料理。
2. **DP 时间范围扩展**：由于时间到后可以继续吃，DP 的时间范围需要扩展到 $T + A_i - 1$，以确保所有可能的点菜时间都被考虑。
3. **倒序循环避免重复计算**：在 DP 更新时使用倒序循环，确保每个料理只被选择一次。

### 拓展思路
本题可以进一步拓展为多阶段 DP 问题，或者结合贪心算法进行优化。类似的题目包括：
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)

### 个人心得摘录
- **Grisses**：通过排序优先选择时间短的料理，确保在有限时间内尽可能多地选择料理。
- **xibaohe**：使用三维 DP 数组来区分是否使用最后一分钟的点菜权，思路新颖但实现复杂。
- **COsm0s**：详细解释了时间范围扩展的原因，并给出了 DP 状态转移的推导过程。

---
处理用时：35.06秒
# 题目信息

# [ABC146E] Rem of Sum is Num

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc146/tasks/abc146_e

長さ $ N $ の正整数列 $ A_1,\ A_2,\ \ldots\ ,\ A_N $ と正の整数 $ K $ が与えられます。

$ A $ の空でない連続する部分列であって、要素の和を $ K $ で割った余りが要素の数と等しくなるものの数を求めてください。ただし、$ 2 $ つの部分列が列として同じでも、取り出す位置が異なるならば区別するものとします。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $

### Sample Explanation 1

$ (1) $, $ (4,2) $, $ (1,4,2) $, $ (5) $ の $ 4 $ つが条件をみたす部分列です。

### Sample Explanation 2

$ (4,2) $ が $ 4 $ 回、$ (2,4) $ が $ 3 $ 回数えられています。

## 样例 #1

### 输入

```
5 4

1 4 2 3 5```

### 输出

```
4```

## 样例 #2

### 输入

```
8 4

4 2 4 2 4 2 4 2```

### 输出

```
7```

## 样例 #3

### 输入

```
10 7

14 15 92 65 35 89 79 32 38 46```

### 输出

```
8```

# AI分析结果

【题目内容】
# [ABC146E] Rem of Sum is Num

## 题目描述

给定一个长度为 $N$ 的正整数序列 $A_1,\ A_2,\ \ldots\ ,\ A_N$ 和一个正整数 $K$。

求 $A$ 中所有非空连续子序列中，满足子序列的元素和模 $K$ 等于子序列长度的子序列的个数。注意，即使两个子序列的元素相同，但如果它们在原序列中的位置不同，也视为不同的子序列。

## 说明/提示

### 制約

- 输入均为整数。
- $1\ \leq\ N\ \leq\ 2\times\ 10^5$
- $1\ \leq\ K\ \leq\ 10^9$
- $1\ \leq\ A_i\ \leq\ 10^9$

### 样例解释 1

$ (1) $, $ (4,2) $, $ (1,4,2) $, $ (5) $ 这 4 个子序列满足条件。

### 样例解释 2

$ (4,2) $ 被计算了 4 次，$ (2,4) $ 被计算了 3 次。

## 样例 #1

### 输入

```
5 4

1 4 2 3 5```

### 输出

```
4```

## 样例 #2

### 输入

```
8 4

4 2 4 2 4 2 4 2```

### 输出

```
7```

## 样例 #3

### 输入

```
10 7

14 15 92 65 35 89 79 32 38 46```

### 输出

```
8```

【算法分类】前缀和

【题解分析与结论】

本题的核心在于如何高效地计算满足条件的子序列。所有题解都采用了前缀和的思路，通过将问题转化为寻找满足特定条件的前缀和差值的子序列。主要难点在于如何处理模运算和区间长度的限制。

【评分较高的题解】

1. **作者：liangbowen (5星)**
   - **关键亮点**：通过移项将问题转化为寻找前缀和差值模 $K$ 为 0 的子序列，使用 `unordered_map` 来存储和查询前缀和差值的频率，代码简洁且高效。
   - **代码核心**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         int x;
         scanf("%d", &x), x %= k, sum += x;
         val[i] = ((sum - i) % k + k) % k;
         if (i >= k) cnt[val[i - k]]--;
         ans += cnt[val[i]], cnt[val[i]]++;
     }
     ```

2. **作者：installb (4星)**
   - **关键亮点**：通过将每个元素减 1，将问题转化为寻找区间和为 $K$ 的倍数的子序列，使用 `map` 来存储前缀和模 $K$ 的频率，思路清晰。
   - **代码核心**：
     ```cpp
     for(LL i = 1;i <= n;i ++){
         cin >> a[i]; a[i] --; a[i] %= k;
         pre[i] = pre[i - 1] + a[i]; pre[i] %= k;
         if(i >= k) mp[pre[i - k]] --;
         tot += mp[pre[i]]; mp[pre[i]] ++;
     }
     ```

3. **作者：Skyjoy (4星)**
   - **关键亮点**：通过将每个元素减 1，将问题转化为寻找区间和为 $K$ 的倍数的子序列，使用 `map` 来存储前缀和模 $K$ 的频率，代码简洁。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=n;i++){
         a[i]=(read()-1)%k,sum[i]=(sum[i-1]+a[i])%k;
         if(i>=k)cnt[sum[i-k]]--;
         ans+=cnt[sum[i]]; cnt[sum[i]]++;
     }
     ```

【最优关键思路或技巧】

- **前缀和与模运算结合**：通过前缀和和模运算的结合，将问题转化为寻找满足特定条件的前缀和差值的子序列。
- **使用哈希表优化查询**：通过 `unordered_map` 或 `map` 来存储和查询前缀和差值的频率，优化查询效率。
- **区间长度限制处理**：通过动态删除超出区间长度限制的前缀和差值，确保查询的正确性。

【可拓展之处】

- **类似问题**：可以拓展到其他需要计算满足特定条件的子序列的问题，如子序列和等于某个固定值、子序列和模某个数等于某个值等。
- **数据结构优化**：可以使用其他数据结构如 `unordered_multiset` 来进一步优化查询效率。

【推荐题目】
1. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)
2. [P3131 [USACO16JAN]Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3131)
3. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)

---
处理用时：34.70秒
# 题目信息

# [ABC146F] Sugoroku

## 题目描述

ABC146F 双六


高桥君在玩双六棋，棋盘格由用$0$到$N$编号的共$N+1$个格子构成。每一回合，高桥君会扔一个点数$1$到$M$的骰子。如果高桥君当前在第$i$格，骰子扔出$k$点，高桥君就前进到第$i+k$格。 如果此时$i+k > N$，高桥君立刻输掉。另外，棋盘上还有若干个“GameOver格”，如果高桥停在这些格子，也立刻输掉游戏。

假设高桥君可以自由控制骰子的点数，那么他从$0$号格子出发，到达$N$号格子，最短需要多少回合？输出用最短回合到达$N$格时，每回合骰子的点数组成的序列；如果无法到达$N$号格子，输出-1。

## 说明/提示

按$1,3,2,3$的顺序扔出骰子的点数，高桥君会经过第$1,4,6$格最终到达第$9$格。

无法在$3$次以内到达第$9$格。$1,3,2,3$是所有$4$次到达第$9$格的点数序列中，字典序最小的。


$1 \le N \le 10^5$

$1 \le M \le 10^5$

$S$长度为$N+1$，只由字符'0'和'1'组成，保证$S_0=0$，$S_N=0$。

## 样例 #1

### 输入

```
9 3

0001000100```

### 输出

```
1 3 2 3```

## 样例 #2

### 输入

```
5 4

011110```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6

0101010```

### 输出

```
6```

# AI分析结果

【题目翻译】
ABC146F 双六

高桥君在玩双六棋，棋盘格由用$0$到$N$编号的共$N+1$个格子构成。每一回合，高桥君会扔一个点数$1$到$M$的骰子。如果高桥君当前在第$i$格，骰子扔出$k$点，高桥君就前进到第$i+k$格。如果此时$i+k > N$，高桥君立刻输掉。另外，棋盘上还有若干个“GameOver格”，如果高桥停在这些格子，也立刻输掉游戏。

假设高桥君可以自由控制骰子的点数，那么他从$0$号格子出发，到达$N$号格子，最短需要多少回合？输出用最短回合到达$N$格时，每回合骰子的点数组成的序列；如果无法到达$N$号格子，输出-1。

【算法分类】
贪心

【题解分析与结论】
本题的核心在于如何在最短步数内从起点到达终点，并且要求字典序最小的路径。大多数题解都采用了贪心策略，通过倒序枚举来保证字典序最小。难点在于如何高效地找到每一步的最优跳跃点，避免重复计算。

【精选题解】
1. **作者：zjc5 (5星)**
   - **关键亮点**：通过倒序枚举，确保字典序最小，且时间复杂度为$O(n)$。
   - **代码核心思想**：从终点向前回溯，每次选择能跳到的最远点，保证步数最少且字典序最小。
   ```cpp
   for(i=n;i>m;){
       for(;p>=i-m;p--)
           if(s[p]=='0') t=p;
       if(t>=i){
           puts("-1");
           return 0;
       }
       ans[++tot]=i-t;
       i=t;
   }
   ```

2. **作者：ace_amuro (4星)**
   - **关键亮点**：利用单调队列优化，确保每一步的最优选择，同时保证字典序最小。
   - **代码核心思想**：通过单调队列维护当前点的最优跳跃点，确保每一步的跳跃距离最小。
   ```cpp
   for(int i=n-1;i>=0;i--){
       if(s[i]=='1') continue;
       for(;idx[d]!=-1;d++){
           if(idx[d]-i<=m){
               idx[d+1]=i;
               break;
           }
       }
       if(idx[d]==-1){
           printf("-1\n");
           return 0;
       }
   }
   ```

3. **作者：xukehg (4星)**
   - **关键亮点**：通过倒序遍历，记录上一个可跳跃点，确保每一步的跳跃距离最大，从而保证字典序最小。
   - **代码核心思想**：从终点向前跳跃，每次选择能跳到的最远点，确保步数最少且字典序最小。
   ```cpp
   while (j > 0){
       if (j < m){
           v.push_back(j);
           cnt++;
           break;
       }
       if (num[j - m] == j){
           cout << -1 << endl;
           return 0;
       }
       v.push_back(j - num[j - m]);
       j = num[j - m];
       cnt++;
   }
   ```

【最优关键思路】
倒序枚举是解决本题的关键，通过从终点向前回溯，可以确保每一步的跳跃距离最小，从而保证字典序最小。同时，利用单调队列或贪心策略可以高效地找到每一步的最优跳跃点，避免重复计算。

【拓展思路】
类似的问题可以扩展到其他路径规划问题，如最短路径问题、最小步数问题等。通过倒序枚举或贪心策略，可以有效地解决这类问题。

【推荐题目】
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)

---
处理用时：27.18秒
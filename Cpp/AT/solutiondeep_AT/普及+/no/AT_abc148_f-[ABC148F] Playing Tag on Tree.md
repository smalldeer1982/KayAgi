# 题目信息

# [ABC148F] Playing Tag on Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc148/tasks/abc148_f

$ N $ 頂点の木があります。$ i $ 番目の辺は頂点 $ A_i $ と $ B_i $ を双方向に結んでいます。

この木の頂点 $ u $ に高橋君が、頂点 $ v $ に青木君がいます。

$ 2 $ 人は次のような手順で鬼ごっこをします。

- $ 1 $. 高橋君と青木君が同じ頂点にいるときゲームを終了する。そうでないとき、高橋君は隣接する頂点を $ 1 $ つ選んでその頂点に移動する。
- $ 2 $. 高橋君と青木君が同じ頂点にいるときゲームを終了する。そうでないとき、青木君は隣接する頂点を $ 1 $ つ選んでその頂点に移動する。
- $ 3 $. $ 1 $ に戻る。

高橋君はできるだけ遅くゲームが終了するように移動し、青木君はできるだけ早くゲームが終了するように移動します。

高橋君と青木君が常に互いの位置と戦略を把握し最適に移動するとき、ゲームが終了するまでに青木君が移動する回数を求めてください。

なお、ゲームは必ず終了することが証明できます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ u,v\ \leq\ N $
- $ u\ \neq\ v $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- 与えられるグラフは木である

### Sample Explanation 1

互いに最適に移動した場合、ゲームは次のように進行します。 - 高橋君が頂点 $ 3 $ に移動 - 青木君が頂点 $ 2 $ に移動 - 高橋君が頂点 $ 5 $ に移動 - 青木君が頂点 $ 3 $ に移動 - 高橋君が頂点 $ 3 $ に移動 このとき、ゲームが終了するまでの青木君の移動回数は $ 2 $ 回です。 各手番で同じ頂点にとどまることは出来ないことに注意してください。

## 样例 #1

### 输入

```
5 4 1

1 2

2 3

3 4

3 5```

### 输出

```
2```

## 样例 #2

### 输入

```
5 4 5

1 2

1 3

1 4

1 5```

### 输出

```
1```

## 样例 #3

### 输入

```
2 1 2

1 2```

### 输出

```
0```

## 样例 #4

### 输入

```
9 6 1

1 2

2 3

3 4

4 5

5 6

4 7

7 8

8 9```

### 输出

```
5```

# AI分析结果

### 题目重写
【题目内容】
# [ABC148F] Playing Tag on Tree

## 题目描述

$ N $ 个顶点的树。第 $ i $ 条边双向连接顶点 $ A_i $ 和 $ B_i $。

高桥君在顶点 $ u $，青木君在顶点 $ v $。

两人按以下步骤进行鬼捉人游戏：

1. 如果高桥君和青木君在同一顶点，游戏结束。否则，高桥君选择一个相邻顶点移动。
2. 如果高桥君和青木君在同一顶点，游戏结束。否则，青木君选择一个相邻顶点移动。
3. 回到步骤1。

高桥君希望尽可能延迟游戏结束，青木君希望尽快结束游戏。

两人始终知道对方的位置和策略，并采取最优移动策略。求游戏结束前青木君的移动次数。

### 说明/提示

#### 约束

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ u,v\ \leq\ N $
- $ u\ \neq\ v $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- 给定的图是树

### 样例 #1

#### 输入

```
5 4 1

1 2

2 3

3 4

3 5```

#### 输出

```
2```

### 样例 #2

#### 输入

```
5 4 5

1 2

1 3

1 4

1 5```

#### 输出

```
1```

### 样例 #3

#### 输入

```
2 1 2

1 2```

#### 输出

```
0```

### 样例 #4

#### 输入

```
9 6 1

1 2

2 3

3 4

4 5

5 6

4 7

7 8

8 9```

#### 输出

```
5```

### 算法分类
深度优先搜索 DFS

### 题解分析与结论
本题的核心是通过DFS或BFS计算每个节点到高桥君和青木君的距离，然后根据距离关系确定游戏结束时的移动次数。大多数题解采用了DFS来计算距离，并通过比较距离来确定最优策略。

### 精选题解
1. **作者：CaiXY06 (赞：3)**
   - **星级：4**
   - **关键亮点：通过BFS计算距离，思路清晰，代码简洁。**
   - **核心实现思想：使用BFS计算每个节点到高桥君和青木君的距离，然后比较距离找到最大值。**
   - **代码片段：**
     ```cpp
     inline void bfs(int S){
         memset(vis,0,sizeof(vis));
         memset(dis,0,sizeof(dis));
         queue<int>q;
         q.push(S);
         vis[S]=1;
         while(!q.empty()){
             int u=q.front();
             q.pop();
             for(int i=head[u];i;i=e[i].next){
                 int v=e[i].to;
                 if(vis[v])continue;
                 vis[v]=1;
                 dis[v]=dis[u]+1;
                 q.push(v);
             }
         }
         if(S==s)memcpy(a,dis,sizeof(dis));
         else memcpy(b,dis,sizeof(dis));
     }
     ```

2. **作者：Tan_Wei_Ye (赞：3)**
   - **星级：4**
   - **关键亮点：通过DFS计算距离，时间复杂度低，代码易读。**
   - **核心实现思想：使用DFS计算每个节点到高桥君和青木君的距离，然后比较距离找到最大值。**
   - **代码片段：**
     ```cpp
     inline void dfs(int dis[],int x,int fa)
     {
         for(int i=0;i<e[x].size();i++)
         {
             int v=e[x][i];
             if(v==fa) continue;
             dis[v]=dis[x]+1;
             dfs(dis,v,x);
         }
     }
     ```

3. **作者：mxjz666 (赞：2)**
   - **星级：4**
   - **关键亮点：通过DFS计算距离，代码简洁，思路清晰。**
   - **核心实现思想：使用DFS计算每个节点到高桥君和青木君的距离，然后比较距离找到最大值。**
   - **代码片段：**
     ```cpp
     void dfs(int dis[],int x,int fa){
         for(auto i:edge[x]){
             if(i==fa){
                 continue;
             }
             dis[i]=dis[x]+1;
             dfs(dis,i,x);
         }
         return;
     }
     ```

### 关键思路与技巧
- **距离计算**：通过DFS或BFS计算每个节点到高桥君和青木君的距离。
- **比较距离**：根据距离关系确定游戏结束时的移动次数。
- **最优策略**：高桥君选择最远节点，青木君选择最近节点。

### 拓展思路
类似的问题可以通过计算节点距离来解决，如最短路径问题、树的直径问题等。

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P1395 会议](https://www.luogu.com.cn/problem/P1395)

---
处理用时：34.22秒
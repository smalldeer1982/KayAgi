# 题目信息

# [ABC149E] Handshake

## 题目描述

Takahashi  作为特殊嘉宾参加一个晚会 , 晚会上还有 N 个非特殊嘉宾 , 第 i  个特殊嘉宾有 A_i  的欢乐值.晚会目前的欢乐值是 0 .  
 Takahashi  想跟非特殊嘉宾握 M  次手来提高晚会的欢乐值.每一次握手可以被描述为以下的操作:  
1.  Takahashi  选择两个非特殊嘉宾 x  和 y   
2.  Takahashi  用左手和 x  握手 , 用右手和 y  握手 , 晚会的欢乐值增加 A_x + A_y .    

然而 ,  Takahashi  不能以同一种握手方式握两次手.也就是说 ,  Takahashi  的 M  次握手必须满足以下条件:  
- 假设在第 k  次握手中 ,  Takashi  握了非特殊嘉宾 x_k  的左手和 y_k  的右手 , 则没有一组 p  ,  q  (  1 ≤ p < q ≤ M)  可以满足 (  x_p  ,  y_p  ) = (  x_q  ,  y_q  ) .  

请问:在 M  次握手后 , 晚会的欢乐值最大是多少 ?

## 样例 #1

### 输入

```
5 3

10 14 19 34 33```

### 输出

```
202```

## 样例 #2

### 输入

```
9 14

1 3 5 110 24 21 34 5 3```

### 输出

```
1837```

## 样例 #3

### 输入

```
9 73

67597 52981 5828 66249 75177 64141 40773 79105 16076```

### 输出

```
8128170```

# AI分析结果

【题目内容】
# [ABC149E] Handshake

## 题目描述

Takahashi 作为特殊嘉宾参加一个晚会，晚会上还有 N 个非特殊嘉宾，第 i 个特殊嘉宾有 A_i 的欢乐值。晚会目前的欢乐值是 0。  
Takahashi 想跟非特殊嘉宾握 M 次手来提高晚会的欢乐值。每一次握手可以被描述为以下的操作：  
1. Takahashi 选择两个非特殊嘉宾 x 和 y  
2. Takahashi 用左手和 x 握手，用右手和 y 握手，晚会的欢乐值增加 A_x + A_y。  

然而，Takahashi 不能以同一种握手方式握两次手。也就是说，Takahashi 的 M 次握手必须满足以下条件：  
- 假设在第 k 次握手中，Takashi 握了非特殊嘉宾 x_k 的左手和 y_k 的右手，则没有一组 p, q (1 ≤ p < q ≤ M) 可以满足 (x_p, y_p) = (x_q, y_q)。  

请问：在 M 次握手后，晚会的欢乐值最大是多少？

## 样例 #1

### 输入

```
5 3

10 14 19 34 33
```

### 输出

```
202
```

## 样例 #2

### 输入

```
9 14

1 3 5 110 24 21 34 5 3
```

### 输出

```
1837
```

## 样例 #3

### 输入

```
9 73

67597 52981 5828 66249 75177 64141 40773 79105 16076
```

### 输出

```
8128170
```

【算法分类】二分

【题解分析与结论】
该题的核心是通过二分法找到第 M 大的两数之和，并计算前 M 大的和。由于直接枚举所有可能的握手组合会导致超时，因此需要优化。大多数题解采用了二分答案的思路，通过二分查找确定第 M 大的两数之和，然后利用双指针或 `lower_bound` 快速统计满足条件的握手次数和对应的欢乐值。

【评分较高的题解】
1. **作者：NATO (赞：7)**
   - **星级：5星**
   - **关键亮点**：详细解释了二分答案的思路，并提供了双指针优化的实现，代码清晰且效率高。
   - **核心代码**：
     ```cpp
     ll check(ll ak) {
         ll j = n, h = 0, res = 0, gs = 0;
         for (ll i = 1; i <= n; ++i) {
             while (j && a[j] + a[i] < ak) --j;
             h += cs[j] * cnt[a[i]];
             res += cs[j] * cnt[a[i]] * a[i] + cnt[a[i]] * sum[j];
             if (a[j] + a[i] == ak) gs += cnt[a[j]] * cnt[a[i]];
         }
         if (h <= m) return res;
         if (h - gs <= m) return res - (h - m) * ak;
         return -1;
     }
     ```

2. **作者：louhao088 (赞：4)**
   - **星级：4星**
   - **关键亮点**：使用了二分答案的思路，并通过 `lower_bound` 进行快速查找，代码简洁且易于理解。
   - **核心代码**：
     ```cpp
     bool check(int x) {
         int num = 0, s = 0, res = 0;
         for (int i = 1; i <= n; i++) {
             if (a[i] + a[1] < x) continue;
             else if (a[i] >= x) num += n, res = res + sum[n] + n * a[i];
             else {
                 int u = get1(x - a[i]), v = get2(x - a[i]);
                 num += u; s += v - u; res += sum[u] + a[i] * u;
             }
         }
         if (num <= m && num + s >= m) {
             ans = res + x * (m - num); cout << ans; exit(0);
         }
         if (num + s <= m) return true;
         else return false;
     }
     ```

3. **作者：TG_Space_Station (赞：1)**
   - **星级：4星**
   - **关键亮点**：通过二分答案和双指针优化，代码实现清晰，且提供了详细的思路解释。
   - **核心代码**：
     ```cpp
     bool check() {
         long long p = n + 1, i, tot = 0;
         for (i = 1; i <= n; i++) {
             while (p >= 2 && a[i] + a[p - 1] >= mid) p--;
             tot += n - p + 1;
         }
         return tot >= m;
     }
     ```

【最优关键思路或技巧】
- **二分答案**：通过二分查找确定第 M 大的两数之和，避免直接枚举所有组合。
- **双指针优化**：在二分查找过程中，使用双指针快速统计满足条件的握手次数和对应的欢乐值。
- **前缀和**：利用前缀和快速计算满足条件的欢乐值总和，减少时间复杂度。

【可拓展之处】
- 类似的问题可以通过二分答案和双指针优化来解决，尤其是在需要查找第 K 大或第 K 小值的情况下。
- 可以进一步优化代码，减少不必要的计算，提高效率。

【推荐题目】
1. [P3382 【模板】二分查找](https://www.luogu.com.cn/problem/P3382)
2. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)

【个人心得】
- **调试经历**：在实现二分答案时，需要注意边界条件的处理，避免出现死循环或错误的结果。
- **踩坑教训**：在使用双指针优化时，要确保指针的移动方向正确，避免漏掉某些情况。
- **顿悟感想**：二分答案和双指针的结合可以大大提高算法的效率，尤其是在处理大规模数据时。

---
处理用时：41.81秒
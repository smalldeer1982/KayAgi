# 题目信息

# [ABC155D] Pairs

## 题目描述

$N$个数两两相乘的结果有 $\frac{N(N-1)}{2}$ 种，问第 $K$ 小的乘积是多少。

## 说明/提示

$N \leq 2 \times 10^5,-10^9 \leq A_i \leq 10^9$

## 样例 #1

### 输入

```
4 3

3 3 -4 -2```

### 输出

```
-6```

## 样例 #2

### 输入

```
10 40

5 4 3 2 -1 0 0 0 0 0```

### 输出

```
6```

## 样例 #3

### 输入

```
30 413

-170202098 -268409015 537203564 983211703 21608710 -443999067 -937727165 -97596546 -372334013 398994917 -972141167 798607104 -949068442 -959948616 37909651 0 886627544 -20098238 0 -948955241 0 -214720580 277222296 -18897162 834475626 0 -425610555 110117526 663621752 0```

### 输出

```
448283280358331064```

# AI分析结果

### 题目内容重写
题目描述：给定 $N$ 个数，两两相乘的结果有 $\frac{N(N-1)}{2}$ 种，问第 $K$ 小的乘积是多少。

说明/提示：$N \leq 2 \times 10^5$，$-10^9 \leq A_i \leq 10^9$。

### 算法分类
二分

### 题解分析与结论
本题的核心思路是通过二分法找到第 $K$ 小的乘积。由于直接暴力计算所有乘积的复杂度为 $O(N^2)$，无法通过时间限制，因此需要优化。二分法的关键在于如何高效地计算小于某个值的乘积数量。题解中普遍采用了分类讨论的方法，根据数的正负性分别处理，利用二分查找或双指针来统计满足条件的乘积数量。

### 精选题解

#### 题解1：作者：GUO120822 (赞：6)
**星级：5星**
**关键亮点：**
- 详细解释了二分法的单调性，并通过分类讨论处理正负数的乘积问题。
- 代码清晰，逻辑严谨，易于理解。
- 使用了二分查找来统计满足条件的乘积数量，时间复杂度为 $O(N \log N)$。

**核心代码：**
```cpp
bool check(ll x) {
    ll sum = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] < 0) {
            int l = 1, r = i - 1;
            while (l <= r) {
                int mid = l + r >> 1;
                if (a[i] * a[mid] < x) r = mid - 1;
                else l = mid + 1;
            }
            sum += i - l;
        } else {
            int l = 1, r = i - 1;
            while (l <= r) {
                int mid = l + r >> 1;
                if (a[i] * a[mid] < x) l = mid + 1;
                else r = mid - 1;
            }
            sum += r;
        }
    }
    return sum < k;
}
```

#### 题解2：作者：dd_d (赞：6)
**星级：4星**
**关键亮点：**
- 将问题转化为求第 $K$ 大的乘积，简化了二分法的实现。
- 使用了双指针替代二分查找，进一步优化了时间复杂度。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
int solve(int x) {
    int sum = n * (n - 1) / 2 + m * (m - 1) / 2 + cnt * n + cnt * m + cnt * (cnt - 1) / 2;
    reverse(b + 1, b + m + 1);
    reverse(a + 1, a + n + 1);
    for (int i = 1, j = n; i <= m; i++) {
        while (j >= 1 && b[i] * a[j] >= x) j--;
        sum += n - j;
    }
    reverse(b + 1, b + m + 1);
    reverse(a + 1, a + n + 1);
    return sum;
}
```

#### 题解3：作者：Erica_N_Contina (赞：3)
**星级：4星**
**关键亮点：**
- 详细解释了二分法的实现细节，并通过分类讨论处理正负数的乘积问题。
- 代码结构清晰，逻辑严谨，易于理解。
- 使用了二分查找来统计满足条件的乘积数量，时间复杂度为 $O(N \log N)$。

**核心代码：**
```cpp
bool judge(int num) {
    int res, sum = 0;
    for (int i = 1; i < n && a[i] <= 0; i++) {
        if (a[i] * a[i + 1] < num) continue;
        int l = i + 1, r = n;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (a[mid] * a[i] >= num) l = mid + 1, res = mid;
            else r = mid - 1;
        }
        sum += res - i;
    }
    int sz = b.size();
    for (int i = 0; i < sz - 1; i++) {
        if (b[i] * b[i + 1] < num) continue;
        int l = i + 1, r = sz - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (b[mid] * b[i] >= num) l = mid + 1, res = mid;
            else r = mid - 1;
        }
        sum += res - i;
    }
    return sum >= k;
}
```

### 最优关键思路
1. **二分法**：通过二分法确定第 $K$ 小的乘积，利用单调性进行判断。
2. **分类讨论**：根据数的正负性分别处理，利用二分查找或双指针统计满足条件的乘积数量。
3. **优化统计**：通过二分查找或双指针优化统计过程，降低时间复杂度。

### 可拓展之处
- 类似问题：可以通过二分法解决其他需要寻找第 $K$ 小或第 $K$ 大元素的问题，如第 $K$ 小的路径、第 $K$ 小的子序列等。
- 算法套路：二分法结合分类讨论是解决复杂问题的常见套路，适用于多种场景。

### 推荐题目
1. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)
3. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)

---
处理用时：39.76秒
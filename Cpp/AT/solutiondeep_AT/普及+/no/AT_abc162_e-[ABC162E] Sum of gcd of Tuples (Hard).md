# 题目信息

# [ABC162E] Sum of gcd of Tuples (Hard)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc162/tasks/abc162_e

$ 1 $ 以上 $ K $ 以下の整数からなる長さ $ N $ の数列 $ \{A_1,...,A_N\} $ を考えます。

そのようなものは $ K^N $ 個ありますが、その全てについての $ \gcd(A_1,...,A_N) $ の和を求めてください。

ただし、答えは非常に大きくなる可能性があるため、和を $ (10^9+7) $ で割ったあまりを出力してください。

なお、$ \gcd(A_1,...,A_N) $ は $ A_1,...,A_N $ の最大公約数を表します。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ 10^5 $
- 入力は全て整数

### Sample Explanation 1

$ \gcd(1,1,1)+\gcd(1,1,2)+\gcd(1,2,1)+\gcd(1,2,2) $ $ +\gcd(2,1,1)+\gcd(2,1,2)+\gcd(2,2,1)+\gcd(2,2,2) $ $ =1+1+1+1+1+1+1+2=9 $ となるため、答えは $ 9 $ です。

### Sample Explanation 3

和を $ 10^9+7 $ で割った余りを出力してください。

## 样例 #1

### 输入

```
3 2```

### 输出

```
9```

## 样例 #2

### 输入

```
3 200```

### 输出

```
10813692```

## 样例 #3

### 输入

```
100000 100000```

### 输出

```
742202979```

# AI分析结果

### 题目内容重写（中文）

**题目描述：**

给定两个整数 $N$ 和 $K$，考虑所有由 $1$ 到 $K$ 的整数组成的长为 $N$ 的数列 $\{A_1, A_2, \dots, A_N\}$。这样的数列共有 $K^N$ 个，求所有数列的 $\gcd(A_1, A_2, \dots, A_N)$ 的和。由于答案可能非常大，输出结果对 $10^9+7$ 取模。

**说明/提示：**

- $2 \leq N \leq 10^5$
- $1 \leq K \leq 10^5$
- 输入均为整数

**样例：**

- 输入：
  ```
  3 2
  ```
- 输出：
  ```
  9
  ```

### 算法分类

数学

### 题解分析与结论

该题的核心在于如何高效计算所有可能数列的 $\gcd$ 之和。由于直接枚举所有数列的 $\gcd$ 计算量过大，题解中主要采用了以下两种思路：

1. **容斥原理**：通过倒序枚举 $\gcd$ 的可能值，利用容斥原理减去重复计算的部分。
2. **欧拉反演**：利用欧拉函数的性质，将 $\gcd$ 的计算转化为欧拉函数的求和问题。

### 精选题解

#### 题解1：Hisaishi_Kanade（4星）

**关键亮点：**
- 通过倒序枚举 $\gcd$ 的可能值，利用容斥原理减去重复计算的部分。
- 代码简洁，思路清晰，适合初学者理解。

**核心代码：**
```cpp
for(x=k;x;--x){
    f[x]=repow(k/x,n);
    for(y=x<<1;y<=k;y+=x)
        f[x]=(f[x]-f[y]+mod)%mod;
    ans=(ans+x*f[x]%mod)%mod;
}
```
**实现思想：**
- 首先计算 $\gcd$ 为 $x$ 的倍数的数列数量，然后通过容斥原理减去 $\gcd$ 为 $2x, 3x, \dots$ 的数列数量，最终得到 $\gcd$ 恰好为 $x$ 的数列数量。

#### 题解2：Aleph1022（4星）

**关键亮点：**
- 使用欧拉反演，将 $\gcd$ 的计算转化为欧拉函数的求和问题。
- 结合线性筛法预处理欧拉函数，提高了计算效率。

**核心代码：**
```cpp
for(int d=1;d<=k;d++)
    ans=(ans+phi[d]*qpow(k/d,n)%mod)%mod;
```
**实现思想：**
- 利用欧拉函数的性质，将 $\gcd$ 的计算转化为欧拉函数的求和问题，通过线性筛法预处理欧拉函数，然后直接计算每个 $d$ 的贡献。

#### 题解3：m256i（4星）

**关键亮点：**
- 使用莫比乌斯反演，将 $\gcd$ 的计算转化为莫比乌斯函数的求和问题。
- 结合线性筛法预处理莫比乌斯函数，提高了计算效率。

**核心代码：**
```cpp
for(int i=1;i<=k;i++)
    ans=(ans+i*findcoprime(k/i,n))%mod;
```
**实现思想：**
- 利用莫比乌斯反演，将 $\gcd$ 的计算转化为莫比乌斯函数的求和问题，通过线性筛法预处理莫比乌斯函数，然后直接计算每个 $i$ 的贡献。

### 最优关键思路或技巧

1. **容斥原理**：通过倒序枚举 $\gcd$ 的可能值，利用容斥原理减去重复计算的部分，适用于需要精确计算 $\gcd$ 恰好为某个值的情况。
2. **欧拉反演**：利用欧拉函数的性质，将 $\gcd$ 的计算转化为欧拉函数的求和问题，适用于需要高效计算 $\gcd$ 贡献的情况。

### 可拓展之处

- **类似问题**：可以扩展到计算 $\gcd$ 的其他函数值，如 $\gcd$ 的平方和、$\gcd$ 的立方和等。
- **算法优化**：可以结合杜教筛等更高效的筛法，进一步优化欧拉函数或莫比乌斯函数的预处理过程。

### 推荐题目

1. [P2303 [SDOI2012] Longge的问题](https://www.luogu.com.cn/problem/P2303)
2. [P2568 GCD](https://www.luogu.com.cn/problem/P2568)
3. [P2522 [HAOI2011] Problem b](https://www.luogu.com.cn/problem/P2522)

### 个人心得摘录

- **调试经历**：在实现容斥原理时，需要注意倒序枚举的顺序，确保每次减去的部分是已经计算过的。
- **踩坑教训**：在使用欧拉反演时，欧拉函数的预处理需要确保线性筛法的正确性，避免漏筛或重复筛。
- **顿悟感想**：通过将 $\gcd$ 的计算转化为欧拉函数或莫比乌斯函数的求和问题，可以大大简化计算过程，提高效率。

---
处理用时：33.71秒
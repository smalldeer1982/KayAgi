# 题目信息

# [ABC166F] Three Variables Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc166/tasks/abc166_f

あるゲームでは $ 3 $ つの変数があり、それぞれ $ A,B,C $ で表されます。

ゲームの進行と共に、あなたは $ N $ 回の選択に迫られます。 それぞれの選択は文字列 $ s_i $ によって示され、 $ s_i $ が `AB` のとき、$ A $ と $ B $ のどちらかに $ 1 $ を足しもう一方から $ 1 $ を引くこと、 `AC` のとき、$ A $ と $ C $ のどちらかに $ 1 $ を足しもう一方から $ 1 $ を引くこと、 `BC` のとき、$ B $ と $ C $ のどちらかに $ 1 $ を足しもう一方から $ 1 $ を引くことを意味します。

いずれの選択の後にも、$ A,B,C $ のいずれも負の値になってはいけません。

この条件を満たしつつ $ N $ 回すべての選択を終えることが可能であるか判定し、可能であるならそのような選択方法をひとつ示してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 0\ \leq\ A,B,C\ \leq\ 10^9 $
- $ N,\ A,\ B,\ C $ は整数である。
- $ s_i $ は `AB`, `AC`, `BC` のいずれか

### Sample Explanation 1

次のようにすることで $ 2 $ 回すべての選択を終えることができます。 - $ 1 $ 回目の選択では、$ A $ に $ 1 $ を足し $ B $ から $ 1 $ を引く。$ A $ の値が $ 2 $ に、$ B $ の値が $ 2 $ に変化する。 - $ 2 $ 回目の選択では、$ C $ に $ 1 $ を足し $ A $ から $ 1 $ を引く。$ C $ の値が $ 1 $ に、$ A $ の値が $ 1 $ に変化する。

## 样例 #1

### 输入

```
2 1 3 0

AB

AC```

### 输出

```
Yes

A

C```

## 样例 #2

### 输入

```
3 1 0 0

AB

BC

AB```

### 输出

```
No```

## 样例 #3

### 输入

```
1 0 9 0

AC```

### 输出

```
No```

## 样例 #4

### 输入

```
8 6 9 1

AC

BC

AB

BC

AC

BC

AB

AB```

### 输出

```
Yes

C

B

B

C

C

B

A

A```

# AI分析结果

### 题目内容重写
[ABC166F] Three Variables Game

#### 题目描述
某游戏中有三个变量，分别用 $A$、$B$、$C$ 表示。随着游戏的进行，玩家需要进行 $N$ 次选择。每次选择由一个字符串 $s_i$ 表示，$s_i$ 为 `AB` 时，表示将 $A$ 或 $B$ 中的一个加 $1$，另一个减 $1$；$s_i$ 为 `AC` 时，表示将 $A$ 或 $C$ 中的一个加 $1$，另一个减 $1$；$s_i$ 为 `BC` 时，表示将 $B$ 或 $C$ 中的一个加 $1$，另一个减 $1$。每次选择后，$A$、$B$、$C$ 的值都不能为负。判断是否可以在满足条件的情况下完成所有 $N$ 次选择，如果可以，输出一种选择方案。

#### 说明/提示
- $1 \leq N \leq 10^5$
- $0 \leq A, B, C \leq 10^9$
- $N, A, B, C$ 为整数
- $s_i$ 为 `AB`、`AC`、`BC` 之一

#### 样例解释
样例 1：
输入：
```
2 1 3 0
AB
AC
```
输出：
```
Yes
A
C
```
解释：第一次选择将 $A$ 加 $1$，$B$ 减 $1$；第二次选择将 $C$ 加 $1$，$A$ 减 $1$。

### 算法分类
贪心

### 题解分析与结论
本题的核心在于如何在每次选择中合理地调整 $A$、$B$、$C$ 的值，确保它们始终不为负。大多数题解采用了贪心策略，即在每次选择中将较小的变量加 $1$，较大的变量减 $1$。然而，当两个变量相等时，简单的贪心策略可能会导致后续选择无法进行，因此需要特殊处理。

#### 关键思路
1. **贪心策略**：在每次选择中，优先将较小的变量加 $1$，较大的变量减 $1$。
2. **特殊情况处理**：当两个变量相等时，根据下一次选择的内容来决定当前选择的操作，以避免后续出现两个 $0$ 的情况。
3. **回溯与剪枝**：部分题解使用了 DFS 进行回溯，通过剪枝来减少不必要的计算。

#### 评分较高的题解
1. **作者：feecle6418 (4星)**
   - **亮点**：通过分类讨论处理了变量相等的情况，确保不会出现两个 $0$ 的情况。
   - **代码实现**：使用贪心策略，并在变量相等时根据下一次选择的内容来决定当前操作。
   ```cpp
   void SolveRR() {
       for(int i=P; i<=n; i++) {
           if(ss[i][0]=='A'&&ss[i][1]=='B') {
               if(max(A,B)<=0)return puts("No"),void();
               if(A==0)ans[i]='A',A++,B--;
               else if(B==0)ans[i]='B',B++,A--;
               else if(i==n||(ss[i+1][0]=='A'&&ss[i+1][1]=='B')){
                   if(i%2==0)ans[i]='A',A++,B--;
                   else ans[i]='B',A--,B++;
               }
               else if(ss[i+1][0]=='A')ans[i]='A',B--,A++;
               else ans[i]='B',A--,B++;
           }
           // 其他情况类似处理
       }
       puts("Yes");
       for(int i=1; i<=n; i++)cout<<ans[i]<<'\n';
   }
   ```

2. **作者：BqtMtsZDnlpsT (4星)**
   - **亮点**：通过鸽巢原理和分类讨论，解决了变量相等时的选择问题。
   - **代码实现**：在变量相等时，根据下一次选择的内容来决定当前操作，确保后续选择的合法性。
   ```cpp
   if(k[i]=="AB"){
       if(a>b)--a,++b,ans[i]='B';
       else if(a==b&&i<q){
           if(!a){puts("No");return 0;}
           if(k[i+1]=="AB")ans[i]='A',ans[i+1]='B';
           if(k[i+1]=="AC")--b,++c,ans[i]='A',ans[i+1]='C';
           if(k[i+1]=="BC")--a,++c,ans[i]='B',ans[i+1]='C';
           ++i;
       }
       else --b,++a,ans[i]='A';
   }
   ```

3. **作者：Mu_leaf (4星)**
   - **亮点**：通过贪心策略和特殊情况处理，确保不会出现两个 $0$ 的情况。
   - **代码实现**：在变量相等时，根据下一次选择的内容来决定当前操作，确保后续选择的合法性。
   ```cpp
   if(k[i]=="AB"){
       if(a>b)--a,++b,ans[i]='B';
       else if(a==b&&i<n){
           if(!a){puts("No");return 0;}
           if(k[i+1]=="AB")ans[i]='A',ans[i+1]='B';
           if(k[i+1]=="AC")--b,++c,ans[i]='A',ans[i+1]='C';
           if(k[i+1]=="BC")--a,++c,ans[i]='B',ans[i+1]='C';
           ++i;
       }
       else --b,++a,ans[i]='A';
   }
   ```

### 关键实现代码
```cpp
void SolveRR() {
    for(int i=P; i<=n; i++) {
        if(ss[i][0]=='A'&&ss[i][1]=='B') {
            if(max(A,B)<=0)return puts("No"),void();
            if(A==0)ans[i]='A',A++,B--;
            else if(B==0)ans[i]='B',B++,A--;
            else if(i==n||(ss[i+1][0]=='A'&&ss[i+1][1]=='B')){
                if(i%2==0)ans[i]='A',A++,B--;
                else ans[i]='B',A--,B++;
            }
            else if(ss[i+1][0]=='A')ans[i]='A',B--,A++;
            else ans[i]='B',A--,B++;
        }
        // 其他情况类似处理
    }
    puts("Yes");
    for(int i=1; i<=n; i++)cout<<ans[i]<<'\n';
}
```

### 拓展思路
本题的贪心策略可以应用于类似的资源分配问题，特别是在每次操作中需要调整多个变量的值，且需要确保这些变量始终满足某些条件的情况下。类似的题目可以考察如何在有限的资源下进行最优分配，或者如何在多步操作中避免某些限制条件的触发。

### 推荐题目
1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

---
处理用时：52.68秒
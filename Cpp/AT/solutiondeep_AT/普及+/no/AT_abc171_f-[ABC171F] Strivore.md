# 题目信息

# [ABC171F] Strivore

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc171/tasks/abc171_f

「好きな英小文字 $ 1 $ 文字を好きな位置に挿入する」という操作を文字列 $ S $ にちょうど $ K $ 回繰り返してできる文字列は何通りあるでしょう？

答えは非常に大きくなる可能性があるので、$ (10^9+7) $ で割ったあまりを出力してください。

## 说明/提示

### 制約

- $ K $ は $ 1 $ 以上 $ 10^6 $ 以下の整数
- $ S $ は英小文字からなる長さ $ 1 $ 以上 $ 10^6 $ 以下の文字列

### Sample Explanation 1

たとえば、`proofend`、`moonwolf`、`onionpuf` などが条件を満たします。 それに対し、`oofsix`、`oofelevennn`、`voxafolt`、`fooooooo` などは条件を満たしません。

## 样例 #1

### 输入

```
5

oof```

### 输出

```
575111451```

## 样例 #2

### 输入

```
37564

whydidyoudesertme```

### 输出

```
318008117```

# AI分析结果

### 题目翻译

【题目描述】
给定一个仅由小写字母组成的字符串 $S$，你需要执行恰好 $K$ 次操作，每次操作可以在字符串的任意位置插入任意一个小写字母。问最终可以得到多少种不同的字符串。由于答案可能非常大，请输出对 $10^9+7$ 取模后的结果。

【说明/提示】
- $K$ 是 $1$ 到 $10^6$ 之间的整数。
- $S$ 是长度在 $1$ 到 $10^6$ 之间的小写字母字符串。

【样例 #1】
输入：
```
5
oof
```
输出：
```
575111451
```

【样例 #2】
输入：
```
37564
whydidyoudesertme
```
输出：
```
318008117
```

### 算法分类
组合数学

### 题解分析与结论

#### 综合分析与结论
本题的核心在于如何计算在字符串 $S$ 中插入 $K$ 次字符后得到的不同字符串的数量。题解主要分为两类：正推和容斥。正推的思路是通过枚举 $S$ 的匹配位置，计算每个位置的贡献；容斥的思路则是通过总方案数减去不合法的方案数。两种方法的核心都是利用组合数学和快速幂来计算方案数。

#### 精选题解

1. **作者：CarroT1212 (赞：9)**  
   - **星级：5**  
   - **关键亮点**：通过枚举 $S$ 的第一位匹配位置，利用组合数和快速幂计算每个位置的贡献，思路清晰，代码简洁。  
   - **核心代码**：
     ```cpp
     for (ll i=1;i<=k+1;i++)
         ans=(ans+qpow(26,i-1)*C(m-i,n-1)%MOD*qpow(25,k-i+1)%MOD)%MOD;
     ```
   - **实现思想**：枚举 $S$ 的第一位匹配位置 $i$，计算前 $i-1$ 位的任意填法、$S$ 的剩下 $N-1$ 位的匹配位置数，以及未匹配位置的填法。

2. **作者：makeinu (赞：1)**  
   - **星级：4**  
   - **关键亮点**：通过容斥原理，计算总方案数减去不合法的方案数，思路独特，适合理解容斥原理的读者。  
   - **核心代码**：
     ```cpp
     for(int i=0;i<n;i++){
         ans=(ans-qmi(25,k+n-i)*C(k+n,i)%p+p)%p;
     }
     ```
   - **实现思想**：枚举失配位置 $i$，计算前 $i$ 位匹配，$i+1$ 位不匹配的方案数，最后用总方案数减去不合法的方案数。

3. **作者：_Flame_ (赞：0)**  
   - **星级：4**  
   - **关键亮点**：通过枚举最后插入的字符数量，利用组合数和快速幂计算贡献，思路简单直接，代码易读。  
   - **核心代码**：
     ```cpp
     for(int i=0;i<=k;i++){
         int cnt=ksm(26,i)*ksm(25,k-i)%mod;
         ans=(ans+C(n+k-i-1,n-1)*cnt%mod)%mod;
     }
     ```
   - **实现思想**：枚举最后插入的字符数量 $i$，计算前 $n+k-i-1$ 位的组合数和未匹配位置的填法。

### 最优关键思路
最优的思路是通过枚举 $S$ 的匹配位置，利用组合数和快速幂计算每个位置的贡献。这种方法不仅思路清晰，而且代码实现简洁，适合处理大规模数据。

### 拓展思路
类似的问题可以考察在字符串中插入字符或删除字符后得到的不同字符串的数量，或者考察字符串的子序列匹配问题。这类问题通常需要结合组合数学和动态规划来解决。

### 推荐题目
1. [P1641 [SCOI2010]生成字符串](https://www.luogu.com.cn/problem/P1641)
2. [P2768 [JSOI2010]最长公共子序列](https://www.luogu.com.cn/problem/P2768)
3. [P2657 [SCOI2009]windy数](https://www.luogu.com.cn/problem/P2657)

### 个人心得摘录
- **CarroT1212**：通过枚举匹配位置，避免了重复计算，思路清晰且高效。
- **makeinu**：容斥原理的应用使得问题简化，适合理解容斥的读者。
- **_Flame_**：直接枚举最后插入的字符数量，思路简单，代码易读。

---
处理用时：31.95秒
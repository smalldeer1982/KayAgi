# 题目信息

# [ABC173E] Multiplication 4

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc173/tasks/abc173_e

$ N $ 個の整数 $ A_1,\ldots,A_N $ が与えられます。

このなかからちょうど $ K $ 個の要素を選ぶとき、選んだ要素の積としてありえる最大値を求めてください。

そして、答えを $ (10^9+7) $ で割った余りを $ 0 $ 以上 $ 10^9+6 $ 以下の整数として出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

要素を $ 2 $ 個選んだときの積としてありえる値は $ 2,-3,-4,-6,-8,12 $ なので、最大値は $ 12 $ です。

### Sample Explanation 2

要素を $ 3 $ 個選んだときの積としてありえる値は $ -24,-12,-8,-6 $ なので、最大値は $ -6 $ です。 これを $ (10^9+7) $ で割った余りである $ 1000000001 $ を出力します。

### Sample Explanation 3

要素を $ 1 $ 個選んだときの積としてありえる値は $ -1,1000000000 $ なので、最大値は $ 1000000000 $ です。

### Sample Explanation 4

答えを $ (10^9+7) $ で割った余りを出力してください。

## 样例 #1

### 输入

```
4 2

1 2 -3 -4```

### 输出

```
12```

## 样例 #2

### 输入

```
4 3

-1 -2 -3 -4```

### 输出

```
1000000001```

## 样例 #3

### 输入

```
2 1

-1 1000000000```

### 输出

```
1000000000```

## 样例 #4

### 输入

```
10 10

1000000000 100000000 10000000 1000000 100000 10000 1000 100 10 1```

### 输出

```
999983200```

# AI分析结果

### 题目内容重写

**题目描述**

给定 $N$ 个整数 $A_1,\ldots,A_N$，从中选出恰好 $K$ 个元素，求所选元素的乘积的最大值，并将结果对 $10^9+7$ 取模后输出。

**说明/提示**

- 约束条件：$1 \leq K \leq N \leq 2 \times 10^5$，$|A_i| \leq 10^9$。
- 样例解释：
  - 样例1：选出2个元素时，乘积的最大值为12。
  - 样例2：选出3个元素时，乘积的最大值为-6，取模后输出1000000001。
  - 样例3：选出1个元素时，乘积的最大值为1000000000。
  - 样例4：输出结果对 $10^9+7$ 取模。

**样例输入输出**

- 样例1：
  - 输入：`4 2`，`1 2 -3 -4`
  - 输出：`12`
- 样例2：
  - 输入：`4 3`，`-1 -2 -3 -4`
  - 输出：`1000000001`
- 样例3：
  - 输入：`2 1`，`-1 1000000000`
  - 输出：`1000000000`
- 样例4：
  - 输入：`10 10`，`1000000000 100000000 10000000 1000000 100000 10000 1000 100 10 1`
  - 输出：`999983200`

### 算法分类

**贪心**

### 题解分析与结论

本题的核心在于如何从给定的整数数组中选出 $K$ 个元素，使得它们的乘积最大。由于数组中可能包含负数，因此需要特别注意负数的处理，尤其是在 $K$ 为奇数时，如何保证乘积的最大值。

#### 题解对比与总结

1. **UperFicial 的题解**：
   - 思路：通过排序后枚举前缀和后缀，利用 $\log$ 的性质比较乘积大小。
   - 难点：需要使用 `long double` 来避免精度问题。
   - 评分：3星（思路新颖，但实现复杂且依赖高精度计算）。

2. **XYQ_102 的题解**：
   - 思路：根据 $K$ 的奇偶性进行贪心选择，优先选择绝对值较大的数。
   - 难点：处理 $K$ 为奇数时的特殊情况，确保乘积为正。
   - 评分：4星（思路清晰，代码简洁，处理了所有边界情况）。

3. **2012_Zhang_ 的题解**：
   - 思路：分类讨论 $K$ 的奇偶性，优先选择正数或绝对值较大的负数。
   - 难点：在 $K$ 为奇数时，需要特别处理最大数为负的情况。
   - 评分：4星（思路清晰，代码简洁，处理了所有边界情况）。

4. **StayAlone 的题解**：
   - 思路：按绝对值排序后，通过调整负数的选择来保证乘积为正。
   - 难点：需要处理多种调整情况，确保乘积最大化。
   - 评分：3星（思路复杂，实现较为繁琐）。

5. **pjh0625 的题解**：
   - 思路：排序后贪心选择，处理 $K$ 为奇数时的特殊情况。
   - 难点：确保乘积为正，并在计算过程中取模。
   - 评分：4星（思路清晰，代码简洁，处理了所有边界情况）。

6. **lucasincyber 的题解**：
   - 思路：排序后贪心选择，优先选择乘积较大的组合。
   - 难点：处理 $K$ 为奇数时的特殊情况，确保乘积为正。
   - 评分：4星（思路清晰，代码简洁，处理了所有边界情况）。

7. **Shunpower 的题解**：
   - 思路：分类讨论 $K$ 的奇偶性，优先选择正数或绝对值较大的负数。
   - 难点：处理 $K$ 为奇数时的特殊情况，确保乘积为正。
   - 评分：3星（思路清晰，但代码较为冗长）。

#### 最优关键思路

- **贪心选择**：根据 $K$ 的奇偶性，优先选择绝对值较大的数，确保乘积最大化。
- **处理负数**：在 $K$ 为奇数时，特别处理最大数为负的情况，确保乘积为正。
- **取模运算**：在计算过程中对 $10^9+7$ 取模，避免数值溢出。

#### 可拓展之处

- 类似问题：在数组中选出 $K$ 个元素，使得它们的和或积满足特定条件。
- 类似算法：贪心算法在其他组合优化问题中的应用，如背包问题、任务调度等。

#### 推荐题目

1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1045 最大乘积](https://www.luogu.com.cn/problem/P1045)

### 精选题解

#### 题解1：XYQ_102

**评分：4星**

**关键亮点**：
- 思路清晰，代码简洁。
- 处理了 $K$ 为奇数时的特殊情况，确保乘积为正。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5,M=1e6+5,inf=0x3f3f3f3f,mod=1e9+7;
#define mst(a) memset(a,0,sizeof a)
#define lx x<<1
#define rx x<<1|1
#define reg register
#define PII pair<int,int>
#define fi first 
#define se second
ll a[N];
int main(){
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i=0;i<n;i++) scanf("%lld",&a[i]);
	sort(a,a+n);
	int l=0,r=n-1,w=1; 
	ll ans=1;
	if(k&1) ans=a[r--],k--,w=(ans<0?-1:1);
	while(k){
		ll x=a[l]*a[l+1],y=a[r]*a[r-1];
		if(x*w>y*w) ans=(ans*(x%mod))%mod,l+=2;
		else ans=(ans*(y%mod))%mod,r-=2;
		k-=2;
	}
	printf("%lld\n",(ans%mod+mod)%mod);
	return 0;
}
```

#### 题解2：2012_Zhang_

**评分：4星**

**关键亮点**：
- 思路清晰，代码简洁。
- 处理了 $K$ 为奇数时的特殊情况，确保乘积为正。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,x[1000000],sum=1;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>x[i];
	sort(x+1,x+n+1);
	int l=1,r=n;
	if(k%2==1){
		if(x[n]<0){
			for(int i=n;i>=n-k+1;i--) sum*=x[i],sum=((sum%1000000007)+1000000007)%1000000007;
			cout<<sum;
			return 0;
		}
		sum=x[n];
		r--,k--,n--;
	}
	while(k>0){
		long long a,b;
		a=x[l]*x[l+1],b=x[r]*x[r-1];
		if(a>b) sum=(sum*(a%1000000007))%1000000007,l+=2,k-=2;
		else sum=(sum*(b%1000000007))%1000000007,r-=2,k-=2;
	}
	cout<<(sum%1000000007+1000000007)%1000000007;
    return 0;
}
```

#### 题解3：pjh0625

**评分：4星**

**关键亮点**：
- 思路清晰，代码简洁。
- 处理了 $K$ 为奇数时的特殊情况，确保乘积为正。

**核心代码**：
```python
import sys
MOD = 10**9 + 7
input = sys.stdin.read
data = input().split()

n = int(data[0])
k = int(data[1])
a = list(map(int, data[2:]))

a.sort()

l, r = 0, n - 1
ans = 1
w = 1

if k % 2 == 1:
    ans = a[r]
    r -= 1
    k -= 1
    w = -1 if ans < 0 else 1

while k > 0:
    if l + 1 >= n or r - 1 < l:
        break
    
    x = a[l] * a[l + 1]
    y = a[r] * a[r - 1]
    
    if x * w > y * w:
        ans = (ans * (x % MOD)) % MOD
        l += 2
    else:
        ans = (ans * (y % MOD)) % MOD
        r -= 2
    
    k -= 2

print((ans % MOD + MOD) % MOD)
```

### 总结

本题的核心在于贪心算法的应用，通过排序和分类讨论，确保所选元素的乘积最大化。在处理负数时，需要特别注意 $K$ 为奇数的情况，确保乘积为正。推荐的题解均采用了清晰的思路和简洁的代码，处理了所有边界情况，值得参考。

---
处理用时：60.53秒
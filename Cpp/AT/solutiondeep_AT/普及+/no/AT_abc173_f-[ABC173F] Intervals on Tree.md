# 题目信息

# [ABC173F] Intervals on Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc173/tasks/abc173_f

$ N $ 頂点 $ N-1 $ 辺から成る木があり、頂点には $ 1,\ 2,\cdots,\ N $ の番号が、辺には $ 1,\ 2,\ \cdots,\ N-1 $ の番号がついています。辺 $ i $ は頂点 $ u_i,\ v_i $ を繋いでいます。

整数 $ 1\ \leq\ L\ \leq\ R\ \leq\ N $ に対して関数 $ f(L,\ R) $ を次のように定義します。

- $ S $ を番号が $ L $ 以上 $ R $ 以下の頂点から成る集合とする。頂点集合 $ S $ と、両端が $ S $ に属する辺のみから成るような部分グラフの連結成分の個数を $ f(L,\ R) $ で表す。

$ \sum_{L=1}^{N}\ \sum_{R=L}^{N}\ f(L,\ R) $ を計算してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 与えられるグラフは木である
- 入力は全て整数である

### Sample Explanation 1

考えられる $ L,\ R $ の組み合わせは以下の $ 6 $ 通りがあります。 - $ L\ =\ 1,\ R\ =\ 1 $ のとき、$ S\ =\ \{1\} $ であり、連結成分の個数は $ 1 $ です。 - $ L\ =\ 1,\ R\ =\ 2 $ のとき、$ S\ =\ \{1,\ 2\} $ であり、連結成分の個数は $ 2 $ です。 - $ L\ =\ 1,\ R\ =\ 3 $ のとき、$ S\ =\ \{1,\ 2,\ 3\} $ であり、辺 $ 1,\ 2 $ は両端が $ S $ に含まれるので、連結成分の個数は $ 1 $ です。 - $ L\ =\ 2,\ R\ =\ 2 $ のとき、$ S\ =\ \{2\} $ であり、連結成分の個数は $ 1 $ です。 - $ L\ =\ 2,\ R\ =\ 3 $ のとき、$ S\ =\ \{2,\ 3\} $ であり、辺 $ 2 $ は両端が $ S $ に含まれるので、連結成分の個数は $ 1 $ です。 - $ L\ =\ 3,\ R\ =\ 3 $ のとき、$ S\ =\ \{3\} $ であり、連結成分の個数は $ 1 $ です。 これらの和は $ 7 $ です。

## 样例 #1

### 输入

```
3

1 3

2 3```

### 输出

```
7```

## 样例 #2

### 输入

```
2

1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
10

5 3

5 7

8 9

1 9

9 10

8 4

7 4

6 10

7 2```

### 输出

```
113```

# AI分析结果

### 题目内容重写
$ N $ 个顶点 $ N-1 $ 条边构成一棵树，顶点编号为 $ 1,\ 2,\cdots,\ N $，边编号为 $ 1,\ 2,\ \cdots,\ N-1 $。边 $ i $ 连接顶点 $ u_i,\ v_i $。

对于整数 $ 1\ \leq\ L\ \leq\ R\ \leq\ N $，定义函数 $ f(L,\ R) $ 如下：

- $ S $ 为编号在 $ L $ 到 $ R $ 之间的顶点集合。$ f(L,\ R) $ 表示由顶点集合 $ S $ 和两端都在 $ S $ 中的边构成的子图的连通分量个数。

计算 $ \sum_{L=1}^{N}\ \sum_{R=L}^{N}\ f(L,\ R) $。

### 算法分类
组合数学

### 题解分析与结论
本题的核心在于如何高效计算所有区间 $[L, R]$ 的连通分量个数之和。由于直接枚举所有区间的复杂度为 $O(N^2)$，无法通过 $N \leq 2 \times 10^5$ 的约束，因此需要利用数学性质进行优化。

大多数题解采用了以下思路：
1. **点的贡献**：每个点在没有边的情况下，独立形成一个连通分量。点的贡献可以通过公式 $\sum_{i=1}^{n} i \times (n-i+1)$ 计算。
2. **边的贡献**：每条边连接两个点，若区间 $[L, R]$ 包含这条边，则减少一个连通分量。边的贡献为 $u \times (n-v+1)$，其中 $u < v$。

最终答案为点的贡献减去边的贡献。

### 精选题解
#### 题解1：Zhao_daodao (4星)
**关键亮点**：
- 清晰的点边容斥思路，推导简洁。
- 代码实现简洁，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    ans+=i*(n-i+1);
}
for(int i=1,u,v;i<n;i++){
    cin>>u>>v;
    if(u>v)swap(u,v);
    ans-=u*(n-v+1);
}
cout<<ans<<"\n";
```

#### 题解2：Expert_Dream (4星)
**关键亮点**：
- 直接切入问题核心，推导过程简洁明了。
- 代码实现简洁，适合快速理解。

**核心代码**：
```cpp
cin>>n;
For(i,1,n) ans+=(1+i)*i/2;
For(i,1,n-1){int x,y;cin>>x>>y;if(x>y) swap(x,y);ans -= (x) * (n-y+1);}
cout<<ans;
```

#### 题解3：toolong114514 (4星)
**关键亮点**：
- 详细解释了贡献的计算过程，适合初学者理解。
- 代码实现清晰，逻辑严谨。

**核心代码**：
```cpp
cin>>n;
for(int i=1;i<=n;i++){
    ans+=(n-i+1)*(n-i+2)/2;
}
for(int i=1;i<n;i++){
    int p1,p2;
    cin>>p1>>p2;
    if(p1>p2) swap(p1,p2);
    ans-=p1*(n-p2+1);
}
cout<<ans;
```

### 最优关键思路
1. **点边容斥**：通过计算点的贡献和边的贡献，最终得到连通分量的总数。
2. **数学公式**：利用数学公式高效计算点的贡献和边的贡献，避免直接枚举所有区间。

### 拓展思路
类似的问题可以通过拆解贡献的方式解决，尤其是在图论中涉及连通分量的问题。例如，计算所有子图的连通分量个数、计算所有区间的某种属性等。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
3. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

---
处理用时：27.07秒
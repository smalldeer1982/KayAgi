# 题目信息

# [ABC178F] Contrast

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc178/tasks/abc178_f

長さ $ N $ の数列 $ A $ と $ B $ が与えられます。 $ A,B $ はそれぞれ昇順にソートされています。 $ B $ を好きに並べ替えてすべての $ i(1\ \leq\ i\ \leq\ N) $ について $ A_i\ \neq\ B_i $ を満たすようにできるか判定し、できるならそのような $ B $ の並べ替え方を一つ示してください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\leq\ A_i,B_i\ \leq\ N $
- $ A,B $ はそれぞれ昇順にソートされている。
- 入力はすべて整数

## 样例 #1

### 输入

```
6

1 1 1 2 2 3

1 1 1 2 2 3```

### 输出

```
Yes

2 2 3 1 1 1```

## 样例 #2

### 输入

```
3

1 1 2

1 1 3```

### 输出

```
No```

## 样例 #3

### 输入

```
4

1 1 2 3

1 2 3 3```

### 输出

```
Yes

3 3 1 2```

# AI分析结果

### 题目内容重写

#### 题目描述

给定长度为 $N$ 的两个升序排列的序列 $A$ 和 $B$，要求重新排列 $B$，使得对于所有的 $i(1 \leq i \leq N)$，都有 $A_i \neq B_i$。如果可以做到，输出任意一个满足条件的排列后的 $B$；否则输出 `No`。

#### 说明/提示

- **约束条件**：
  - $1 \leq N \leq 2 \times 10^5$
  - $1 \leq A_i, B_i \leq N$
  - $A$ 和 $B$ 都是升序排列的。
  - 输入均为整数。

#### 样例 #1

**输入**：
```
6
1 1 1 2 2 3
1 1 1 2 2 3
```

**输出**：
```
Yes
2 2 3 1 1 1
```

#### 样例 #2

**输入**：
```
3
1 1 2
1 1 3
```

**输出**：
```
No
```

#### 样例 #3

**输入**：
```
4
1 1 2 3
1 2 3 3
```

**输出**：
```
Yes
3 3 1 2
```

### 算法分类
**构造**

### 题解分析与结论

#### 综合分析
题目要求通过重新排列 $B$ 使得 $A_i \neq B_i$，且 $A$ 和 $B$ 都是升序排列的。核心思路是通过反转 $B$ 来尽量减少 $A_i$ 和 $B_i$ 相等的可能性，然后处理可能存在的相等区间。

#### 关键思路
1. **反转 $B$**：将 $B$ 反转后，$A$ 和 $B$ 分别呈升序和降序，这样可以减少 $A_i$ 和 $B_i$ 相等的可能性。
2. **处理相等区间**：如果存在 $A_i = B_i$ 的区间，尝试将这些 $B_i$ 与区间外的元素交换，确保交换后的 $B_i$ 不等于 $A_i$。
3. **无解条件**：如果某个数在 $A$ 和 $B$ 中出现的总次数超过 $N$，则无解。

#### 评分较高的题解

##### 题解1：CarroT1212 (5星)
- **关键亮点**：
  - 通过反转 $B$ 来减少相等可能性，思路清晰。
  - 详细分析了相等区间的处理方式，并给出了无解条件的证明。
  - 代码实现简洁高效，处理相等区间的交换逻辑清晰。
  
- **核心代码**：
  ```cpp
  reverse(b+1,b+n+1);
  for (int i=1;i<=n;i++) if (a[i]==b[i]) {
      k=a[i],l=r=i;
      while (b[r+1]==a[r+1]) r++;
      break;
  }
  while (l<=r) {
      while (a[cnt]==k||b[cnt]==k) cnt++;
      if (cnt>n) return printf("No"),0;
      swap(b[l++],b[cnt++]);
  }
  ```

##### 题解2：OyamaMahiro_qwq (4星)
- **关键亮点**：
  - 通过统计每个数的出现次数来判断无解条件，思路清晰。
  - 详细分析了相等区间的处理方式，并给出了交换逻辑。
  - 代码实现较为简洁，处理相等区间的交换逻辑清晰。
  
- **核心代码**：
  ```cpp
  reverse(next(b.begin()), b.end());
  for(int i=1, j=L; i<=n; i++) {
      if(L<=i && i<=R) continue;
      if(a[i]==val || b[i]==val) continue;
      swap(b[i], b[j]);
      j++;
      if(j>R) {
          cout << "Yes\n";
          for(int k=1; k<=n; k++) cout << b[k] << " ";
          cout << "\n";
          return 0;
      }
  }
  ```

##### 题解3：Wzmois (4星)
- **关键亮点**：
  - 通过反转 $B$ 来减少相等可能性，思路清晰。
  - 详细分析了相等区间的处理方式，并给出了无解条件的证明。
  - 代码实现简洁高效，处理相等区间的交换逻辑清晰。
  
- **核心代码**：
  ```cpp
  reverse(b+1,b+n+1);
  for(int i=1;i<=n;i++){
      if(a[i]==b[i]){
          l=i,val=a[i];break;
      }
  }
  for(int i=n;i>=1;i--){
      if(a[i]==b[i]){
          r=i;break;
      }
  }
  int tmp=l;
  for(int i=1;i<=n;i++){
      if((l<=i&&r>=i)||a[i]==val||b[i]==val) continue;
      swap(b[i],b[tmp]);
      tmp++;
      if(tmp>r) p();
  }
  ```

### 最优关键思路
1. **反转 $B$**：通过反转 $B$ 来减少 $A_i$ 和 $B_i$ 相等的可能性。
2. **交换处理**：对于可能存在的相等区间，通过交换区间外的元素来消除相等。

### 可拓展之处
类似的问题可以通过反转或重新排列序列来减少相等可能性，处理相等区间时可以通过交换元素来消除相等。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)

---
处理用时：38.42秒
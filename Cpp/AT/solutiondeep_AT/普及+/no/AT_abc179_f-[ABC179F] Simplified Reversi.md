# 题目信息

# [ABC179F] Simplified Reversi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc179/tasks/abc179_f

縦 $ N $ マス、横 $ N $ マスのグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマスをマス$ (i,j) $ と表します。

グリッドの中央 $ (N-2)\times\ (N-2) $ マスには黒い石が $ 1 $ 個ずつ置いてあり、下辺と右辺の計 $ 2N-1 $ マスには白い石が $ 1 $ 個ずつ置いてあります。

$ Q $ 個のクエリが与えられるので、順番に処理してください。 クエリには $ 2 $ 種類あり、入力形式とクエリの内容は以下のとおりです。

- `1 x`： $ (1,x) $ に白い石を置く。そこから下方向に最も近い白い石との間にある黒い石を全て白い石に置き換える
- `2 x`： $ (x,1) $ に白い石を置く。そこから右方向に最も近い白い石との間にある黒い石を全て白い石に置き換える

$ Q $ 個のクエリを全て処理したあとグリッド上に黒い石はいくつありますか。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ Q\ \leq\ \min(2N-4,2\times\ 10^5) $
- $ 2\ \leq\ x\ \leq\ N-1 $
- 同じクエリが複数回与えられることはない

### Sample Explanation 1

各クエリにより、グリッドは次のように変化します。 !\[図\](https://img.atcoder.jp/ghi/31ba2cd6b3155b137f0e007299225028.png)

## 样例 #1

### 输入

```
5 5

1 3

2 3

1 4

2 2

1 2```

### 输出

```
1```

## 样例 #2

### 输入

```
200000 0```

### 输出

```
39999200004```

## 样例 #3

### 输入

```
176527 15

1 81279

2 22308

2 133061

1 80744

2 44603

1 170938

2 139754

2 15220

1 172794

1 159290

2 156968

1 56426

2 77429

1 97459

2 71282```

### 输出

```
31159505795```

# AI分析结果

### 题目内容重写
有一个边长为 $N$ 的正方形网格，$(i,j)$ 表示第 $i$ 行第 $j$ 列的方格。网格中央 $(N-2)\times(N-2)$ 的每个方格上都有一个黑色的石头。底部和右侧的方格中，每个方格上都有一块白色的石头。

给出了 $Q$ 个查询，有两种查询。它们的输入格式和描述如下:

- `1 x`：在 $(1,x)$ 上放一个白色石头。之后，对于 $(1,x)$ 和 $(1,x)$ 之间的每一个黑色石头，如果你从 $(1,x)$ 开始，用白色石头替换它。
- `2 x`：在 $(x,1)$ 上放一个白色石头。之后，对于 $(x,1)$ 和 $(x,1)$ 之间的每一个黑色石头，如果你从 $(x,1)$ 开始，你击中的第一个白色石头，用白色石头替换它。

在处理完所有 $Q$ 次查询后，网格上有多少黑色石头?

### 算法分类
模拟

### 题解分析与结论
各题解的核心思路是通过维护行和列的边界来快速计算每次操作后黑色石头的减少量。主要区别在于实现方式，有的使用数组直接模拟，有的使用线段树进行优化。

1. **syxmz** 的题解通过维护两个数组 `r` 和 `c` 来记录每行和每列的边界，每次操作后更新边界并减少黑色石头的数量。这种方法简单直接，时间复杂度为 $O(n+q)$。
2. **zhr2021** 的题解使用线段树来维护行和列的最小值，通过区间更新和单点查询来实现操作。这种方法虽然时间复杂度稍高（$O(n+q\log n)$），但代码结构清晰，适合理解线段树的应用。
3. **hellolin** 的题解同样使用数组维护边界，但通过填充数组来更新边界，代码简洁且高效。

### 精选题解
1. **syxmz** (5星)
   - 关键亮点：通过维护两个数组 `r` 和 `c` 来记录每行和每列的边界，每次操作后更新边界并减少黑色石头的数量。代码简洁高效，时间复杂度为 $O(n+q)$。
   - 核心代码：
     ```cpp
     int r[N], c[N];
     signed main() {
         scanf("%lld%lld", &n, &q);
         x = y = n;
         ans = (n - 2) * (n - 2);
         while (q--) {
             scanf("%lld%lld", &opt, &k);
             if (opt == 1) {
                 if (k < y) {
                     ans -= x - 2;
                     while (y > k)
                         c[y--] = x - 2;
                 }
                 else
                     ans -= c[k];
             }
             else {
                 if (k < x) {
                     ans -= y - 2;
                     while (x > k)
                         r[x--] = y - 2;
                 }
                 else
                     ans -= r[k];
             }
         }
         printf("%lld\n", ans);
         return 0;
     }
     ```

2. **hellolin** (4星)
   - 关键亮点：通过填充数组来更新边界，代码简洁且高效。时间复杂度为 $O(n+q)$。
   - 核心代码：
     ```cpp
     int a[N], b[N];
     void main() {
         int n, c, r;
         read(n);
         std::fill(&a[1], &a[n + 1], n);
         std::fill(&b[1], &b[n + 1], n);
         ll ans = (1ll * n - 2ll) * (1ll * n - 2ll);
         c = r = n;
         for (int q = read(); q--;) {
             int op, x;
             read(op, x);
             if (op == 1) {
                 if (x < c) {
                     std::fill(&b[x], &b[c], r);
                     c = x;
                 }
                 ans -= b[x] - 2;
             } else {
                 if (x < r) {
                     std::fill(&a[x], &a[r], c);
                     r = x;
                 }
                 ans -= a[x] - 2;
             }
         }
         writeln(ans);
     }
     ```

### 最优关键思路
通过维护行和列的边界来快速计算每次操作后黑色石头的减少量。这种方法避免了复杂的查询和更新操作，代码实现简单且高效。

### 拓展思路
类似的问题可以通过维护边界或使用数据结构（如线段树）来优化查询和更新操作。例如，处理二维平面上的区间更新和查询问题时，可以考虑使用二维线段树或其他高效的数据结构。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
3. [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)

---
处理用时：34.74秒
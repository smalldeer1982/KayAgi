# 题目信息

# [ABC183F] Confluence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc183/tasks/abc183_f

$ N $ 人の生徒が登校しようとしています。生徒 $ i $ はクラス $ C_i $ に属しています。

各生徒はそれぞれの家から出発したあと、他の生徒と合流を繰り返しながら学校へ向かいます。一度合流した生徒が分かれることはありません。

$ Q $ 個のクエリが与えられるので、順番に処理してください。クエリには $ 2 $ 種類あり、入力形式とクエリの内容は以下の通りです。

- `1 a b` : 生徒 $ a $ を含む集団と、生徒 $ b $ を含む集団が合流する (既に合流しているときは何も起こらない)
- `2 x y` : クエリの時点で既に生徒 $ x $ と合流している生徒(生徒 $ x $ を含む)のうち、クラス $ y $ に属している生徒の数を求める

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ C_i,a,b,x,y\ \leq\ N $
- `1 a b` のクエリにおいて、$ a\ \neq\ b $
- 入力はすべて整数

### Sample Explanation 1

$ 3 $ 番目のクエリの時点で、生徒 $ 1 $ は、生徒 $ 2,5 $ と合流しています。生徒 $ 1,2,5 $ のうちクラス $ 1 $ に属する生徒は $ 2 $ 人です。 $ 5 $ 番目のクエリの時点で、生徒 $ 3 $ は、生徒 $ 4 $ と合流しています。生徒 $ 3,4 $ のうちクラス $ 4 $ に属する生徒は $ 0 $ 人です。

### Sample Explanation 2

すでに同じ集団に属している生徒に対して、`1 a b` のクエリが与えられることもあります。

## 样例 #1

### 输入

```
5 5

1 2 3 2 1

1 1 2

1 2 5

2 1 1

1 3 4

2 3 4```

### 输出

```
2

0```

## 样例 #2

### 输入

```
5 4

2 2 2 2 2

1 1 2

1 1 3

1 2 3

2 2 2```

### 输出

```
3```

## 样例 #3

### 输入

```
12 9

1 2 3 1 2 3 1 2 3 1 2 3

1 1 2

1 3 4

1 5 6

1 7 8

2 2 1

1 9 10

2 5 6

1 4 8

2 6 1```

### 输出

```
1

0

0```

# AI分析结果

### 题目内容重写

#### [ABC183F] Confluence

**题目描述**

有 $N$ 个学生，学生 $i$ 属于班级 $C_i$。学生们会组成一个个集合，初始时每个学生所在的集合只包含自己。有 $Q$ 个操作，操作分为两种：

1. `1 a b`：将学生 $a$ 和学生 $b$ 所在的集合合并。如果它们已经在同一个集合中，则不进行任何操作。
2. `2 x y`：查询学生 $x$ 所在的集合中，有多少个学生属于班级 $y$。

**说明/提示**

- $1 \leq N, Q \leq 2 \times 10^5$
- $1 \leq C_i, a, b, x, y \leq N$
- 在 `1 a b` 操作中，$a \neq b$

**样例输入 1**

```
5 5
1 2 3 2 1
1 1 2
1 2 5
2 1 1
1 3 4
2 3 4
```

**样例输出 1**

```
2
0
```

**样例输入 2**

```
5 4
2 2 2 2 2
1 1 2
1 1 3
1 2 3
2 2 2
```

**样例输出 2**

```
3
```

### 算法分类

并查集

### 题解分析与结论

该题的核心在于使用并查集来维护学生集合的合并操作，并通过启发式合并优化查询效率。题解中大多数作者都采用了并查集+启发式合并的思路，部分作者还使用了 `map` 来存储每个集合中不同班级的学生数量，以优化空间和时间复杂度。

### 评分较高的题解

#### 题解1：卷王 (5星)

**关键亮点：**
- 使用并查集维护集合合并操作。
- 通过启发式合并优化时间复杂度，确保每次合并操作的时间复杂度为 $O(\log N)$。
- 使用 `map` 存储每个集合中不同班级的学生数量，优化查询效率。

**核心代码：**
```cpp
int f[200007];
map<int, int> mp[200007];

int find(int x) {
    if(f[x] == x) return x;
    return f[x] = find(f[x]);
}

inline void join(int x, int y) {
    x = find(x), y = find(y);
    if(x == y) return ;
    if(mp[x].size() > mp[y].size()) swap(x, y);
    f[x] = y;
    for(auto v: mp[x])
        mp[y][v.first] += v.second;
}
```

#### 题解2：Nightingale_OI (5星)

**关键亮点：**
- 使用并查集维护集合合并操作。
- 通过 DFS 序将子树问题转化为区间问题，进一步优化查询效率。
- 使用差分数组处理区间查询，确保查询时间复杂度为 $O(1)$。

**核心代码：**
```cpp
int fifa(int x){return x==fa[x]?x:fa[x]=fifa(fa[x]);}

void dfs(int x){
    dfn[x][0]=++m;
    f(i,1,q[x].size())dfs(q[x][i-1]);
    dfn[x][1]=m;
}
```

#### 题解3：CarroT1212 (4星)

**关键亮点：**
- 使用并查集维护集合合并操作。
- 通过启发式合并优化时间复杂度，确保每次合并操作的时间复杂度为 $O(\log N)$。
- 使用 `map` 存储每个集合中不同班级的学生数量，优化查询效率。

**核心代码：**
```cpp
int find(int x) {
    if(x != fa[x]) fa[x] = find(fa[x]);
    return fa[x];
}

void merge(int x, int y) {
    x = find(x), y = find(y);
    if(x == y) return;
    if(g[x].size() > g[y].size()) swap(x, y);
    for(auto j : g[x]) g[y][j.first] += j.second;
    fa[x] = y;
}
```

### 最优关键思路与技巧

1. **并查集+启发式合并**：通过并查集维护集合的合并操作，并使用启发式合并优化时间复杂度，确保每次合并操作的时间复杂度为 $O(\log N)$。
2. **`map` 存储班级信息**：使用 `map` 存储每个集合中不同班级的学生数量，优化查询效率，避免空间复杂度过高。
3. **DFS 序与差分数组**：通过 DFS 序将子树问题转化为区间问题，并使用差分数组处理区间查询，进一步优化查询效率。

### 可拓展之处

该题的思路可以拓展到其他需要维护集合合并与查询的问题，例如：
- 维护集合中元素的某种属性（如最大值、最小值等）。
- 处理动态图连通性问题。

### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1196 [NOI2002] 银河英雄传说](https://www.luogu.com.cn/problem/P1196)

### 个人心得摘录

- **调试经历**：部分作者提到在调试过程中发现合并操作的时间复杂度较高，通过启发式合并优化后成功通过。
- **踩坑教训**：部分作者提到在初始实现中未使用启发式合并，导致时间复杂度过高，最终通过优化解决了问题。
- **顿悟感想**：部分作者提到在实现过程中发现 `map` 的使用可以大大优化查询效率，避免了空间复杂度过高的问题。

---
处理用时：34.92秒
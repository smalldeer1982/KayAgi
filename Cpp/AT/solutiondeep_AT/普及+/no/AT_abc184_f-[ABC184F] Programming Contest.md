# 题目信息

# [ABC184F] Programming Contest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc184/tasks/abc184_f

高橋くんはプログラミングコンテストに参加します。 このコンテストのコンテスト時間は $ T $ 分間で、 $ N $ 問の問題が出題されます。  
 高橋くんは超能力者なので、 $ i $ 番目の問題が $ A_i $ 分で解けることが分かっています。  
 高橋くんは $ N $ 問の中から $ 0 $ 問以上を、解くのにかかる時間の総和が $ T $ 分以下になるように選び、それらの問題を解きます。  
 選んだ問題を解くのにかかる時間の総和の最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 40 $
- $ 1\ \le\ T\ \le\ 10^9 $
- $ 1\ \le\ A_i\ \le\ 10^9 $

### Sample Explanation 1

$ 1,2,3,4 $ 問目を選ぶと、解くのにかかる時間の総和が $ 2+3+5+7=17 $ 分となり、 $ T=17 $ 分以下での最大になります。

### Sample Explanation 2

全ての問題を解くのが最適です。

### Sample Explanation 3

どの問題も解くことができません。

### Sample Explanation 4

$ 2,3,7 $ 問目を選ぶと、解くのにかかる時間の総和が $ 273555143 $ 分になります。

## 样例 #1

### 输入

```
5 17

2 3 5 7 11```

### 输出

```
17```

## 样例 #2

### 输入

```
6 100

1 2 7 5 8 10```

### 输出

```
33```

## 样例 #3

### 输入

```
6 100

101 102 103 104 105 106```

### 输出

```
0```

## 样例 #4

### 输入

```
7 273599681

6706927 91566569 89131517 71069699 75200339 98298649 92857057```

### 输出

```
273555143```

# AI分析结果

### 题目内容重写
高橋くん参加了一场编程竞赛，竞赛时间为 $T$ 分钟，共有 $N$ 道题目。高橋くん拥有超能力，能够知道每道题目的解题时间 $A_i$ 分钟。他需要从这 $N$ 道题目中选择若干道，使得解题时间的总和不超过 $T$ 分钟，并且尽可能大。求这个最大总时间。

### 算法分类
搜索、折半搜索

### 题解分析与结论
该题的核心问题是在给定的时间内选择若干道题目，使得解题时间的总和最大。由于 $N$ 的最大值为 40，直接使用暴力搜索的复杂度为 $O(2^{40})$，显然无法通过。因此，大多数题解采用了折半搜索的策略，将问题分为两部分，分别搜索前半部分和后半部分的所有可能解，然后通过二分查找合并两部分的结果，最终得到最优解。

### 精选题解

#### 1. 作者：Suan_CY (赞：2)
- **星级**: 4.5
- **关键亮点**: 详细解释了折半搜索的思路，特别是如何将问题分为两部分并合并结果。代码清晰，使用了二分查找优化合并过程。
- **核心代码**:
```cpp
void dfs(int pos, int lim, int sum, bool flag) {
    if (sum > m) return;
    if (pos > lim) {
        if (flag) {
            int tmp = (upper_bound(b + 1, b + 1 + cnt, m - sum) - b);
            damn += tmp - 1;
            tmp--;
            maxx = max(maxx, sum + b[tmp]);
        } else b[++cnt] = sum;
        return;
    }
    dfs(pos + 1, lim, sum, flag);
    dfs(pos + 1, lim, sum + a[pos], flag);
}
```
- **实现思想**: 通过 DFS 分别搜索前半部分和后半部分的所有可能解，使用 `upper_bound` 进行二分查找合并结果。

#### 2. 作者：mlvx (赞：1)
- **星级**: 4
- **关键亮点**: 代码简洁，直接使用折半搜索和二分查找，思路清晰。
- **核心代码**:
```cpp
void dfs1(int x, ll sum = 0) {
    if (sum > w) return;
    if (x > n / 2) return b1[++c1] = sum, void();
    dfs1(x + 1, sum), dfs1(x + 1, sum + a[x]);
}
```
- **实现思想**: 分别对前半部分和后半部分进行 DFS 搜索，并使用 `upper_bound` 进行二分查找合并结果。

#### 3. 作者：cppcppcpp3 (赞：1)
- **星级**: 4
- **关键亮点**: 使用了折半搜索和二分查找，代码结构清晰，易于理解。
- **核心代码**:
```cpp
void dfs(int s, int t, int tot, int o) {
    if (tot > m) return;
    if (s > t) return v[o].push_back(tot), void();
    dfs(s + 1, t, tot, o), dfs(s + 1, t, tot + a[s], o);
}
```
- **实现思想**: 通过 DFS 分别搜索前半部分和后半部分的所有可能解，使用 `upper_bound` 进行二分查找合并结果。

### 最优关键思路与技巧
1. **折半搜索**: 将问题分为两部分，分别搜索前半部分和后半部分的所有可能解，降低时间复杂度。
2. **二分查找**: 在合并两部分结果时，使用 `upper_bound` 进行二分查找，快速找到满足条件的最大值。
3. **剪枝优化**: 在搜索过程中，若当前和已经超过 $T$，则直接返回，减少不必要的搜索。

### 可拓展之处
折半搜索和二分查找的结合可以应用于其他类似的问题，如背包问题、子集和问题等。通过将问题分为两部分，分别搜索并合并结果，可以有效降低时间复杂度。

### 推荐题目
1. [P4799](https://www.luogu.com.cn/problem/P4799) - 折半搜索的经典题目。
2. [P1466](https://www.luogu.com.cn/problem/P1466) - 子集和问题，可以使用折半搜索解决。
3. [P2320](https://www.luogu.com.cn/problem/P2320) - 背包问题，可以使用折半搜索优化。

---
处理用时：33.71秒
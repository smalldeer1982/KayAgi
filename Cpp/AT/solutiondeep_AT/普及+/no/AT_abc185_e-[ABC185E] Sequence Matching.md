# 题目信息

# [ABC185E] Sequence Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc185/tasks/abc185_e

長さ $ N $ の整数列 $ A $ と、長さ $ M $ の整数列 $ B $ があります。  
 高橋君は $ A $ から、いくつかの要素を取り除き、残った要素をそのままの順番で繋げることで新たな数列 $ A' $ を作ります。(一つも取り除かなくても、全部取り除いても構いません。)  
 $ B $ についても同様に、いくつかの要素を取り除き、残った要素をそのままの順番で繋げることで新たな数列 $ B' $ を作ります。(一つも取り除かなくても、全部取り除いても構いません。)  
 このとき、$ |A'|\ =\ |B'| $ となるような取り除き方をします。(数列 $ s $ について $ |s| $ は $ s $ の長さを表します。)  
 $ A,\ B $ から取り除いた合計要素数を $ x $ とし、$ 1\ \le\ i\ \le\ |A'| $ かつ $ {A'}_i\ \neq\ {B'}_i $ を満たす整数 $ i $ の数を $ y $ とするとき、$ x\ +\ y $ として考えられる最小の値を求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N,\ M\ \le\ 1000 $
- $ 1\ \le\ A_i,\ B_i\ \le\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

$ A $ から $ A_4 $ を削除して $ A' $ を作り、$ B $ からは何も削除せず $ B' $ を作ることにすると、$ x\ =\ 1 $ となります。 また、このとき $ 1\ \le\ i\ \le\ |A'| $ かつ $ {A'}_i\ \neq\ {B'}_i $ を満たす整数 $ i $ は $ 2 $ の一つのみなので $ y\ =\ 1 $ となります。そして $ x\ +\ y $ は $ 2 $ となり、これが最小です。

### Sample Explanation 2

$ A $ からは何も取り除かず、$ B $ からは $ B_4,\ B_6 $ の $ 2 $ 要素を削除すると $ x\ =\ 2,\ y\ =\ 1 $ となり、 $ x\ +\ y $ は $ 3 $ で、これが最小です。

### Sample Explanation 3

$ A $ からも $ B $ からも何も取り除かないことも許されます。

## 样例 #1

### 输入

```
4 3

1 2 1 3

1 3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 6

1 3 2 4

1 5 2 6 4 3```

### 输出

```
3```

## 样例 #3

### 输入

```
5 5

1 1 1 1 1

2 2 2 2 2```

### 输出

```
5```

# AI分析结果

### 题目内容重写
#### [ABC185E] Sequence Matching

**题目描述**

给定长度为 $N$ 的整数序列 $A$ 和长度为 $M$ 的整数序列 $B$。  
高桥君可以从 $A$ 中删除一些元素，保留的元素按原顺序连接形成新序列 $A'$。（可以不删除任何元素，也可以删除所有元素。）  
同样，高桥君可以从 $B$ 中删除一些元素，保留的元素按原顺序连接形成新序列 $B'$。（可以不删除任何元素，也可以删除所有元素。）  
此时，要求 $|A'| = |B'|$。（对于序列 $s$，$|s|$ 表示 $s$ 的长度。）  
设从 $A$ 和 $B$ 中删除的元素总数为 $x$，且满足 $1 \le i \le |A'|$ 且 ${A'}_i \neq {B'}_i$ 的整数 $i$ 的个数为 $y$，求 $x + y$ 的最小值。

**说明/提示**

**约束条件**

- $1 \le N, M \le 1000$
- $1 \le A_i, B_i \le 10^9$
- 输入均为整数

**样例解释**

**样例 1**

输入：
```
4 3
1 2 1 3
1 3 1
```
输出：
```
2
```
解释：从 $A$ 中删除 $A_4$ 得到 $A'$，$B$ 中不删除任何元素得到 $B'$，此时 $x = 1$，$y = 1$，$x + y = 2$，这是最小值。

**样例 2**

输入：
```
4 6
1 3 2 4
1 5 2 6 4 3
```
输出：
```
3
```
解释：从 $A$ 中不删除任何元素，从 $B$ 中删除 $B_4$ 和 $B_6$，此时 $x = 2$，$y = 1$，$x + y = 3$，这是最小值。

**样例 3**

输入：
```
5 5
1 1 1 1 1
2 2 2 2 2
```
输出：
```
5
```
解释：从 $A$ 和 $B$ 中都不删除任何元素，此时 $x = 0$，$y = 5$，$x + y = 5$，这是最小值。

### 算法分类
动态规划

### 题解分析与结论
本题的核心是通过动态规划求解两个序列的最优匹配问题。所有题解均采用了动态规划的思路，状态转移方程基本一致，主要区别在于代码实现细节和初始化处理。

### 所选高星题解
#### 题解1：作者：crzcqh (赞：3)
**星级：4星**
**关键亮点：**
- 状态转移方程清晰，直接对应题目要求。
- 代码简洁，初始化处理得当。

**核心代码：**
```cpp
for(ll i=1;i<=n;i++)
    for(ll j=1;j<=m;j++){
        if(a[i]==b[j])
            dp[i][j]=dp[i-1][j-1];
        else
            dp[i][j]=min(dp[i][j-1], min(dp[i-1][j-1], dp[i-1][j]))+1;
    }
```

#### 题解2：作者：loser_seele (赞：2)
**星级：4星**
**关键亮点：**
- 指出了本题与编辑距离问题的等价性，扩展了题目的应用场景。
- 代码实现规范，初始化处理清晰。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        f[i][j]=min(min(f[i-1][j]+1,f[i][j-1]+1),f[i-1][j-1]+(a[i-1]!=b[j-1]));
```

#### 题解3：作者：Acheron_RBM (赞：1)
**星级：4星**
**关键亮点：**
- 状态转移方程与代码实现一致，逻辑清晰。
- 初始化处理得当，代码可读性高。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(a[i-1]==b[j-1])
            dp[i][j]=dp[i-1][j-1];
        else
            dp[i][j]=min(dp[i][j-1], min(dp[i-1][j-1], dp[i-1][j]))+1;
```

### 最优关键思路或技巧
- **动态规划状态定义**：$dp_{i,j}$ 表示 $A$ 的前 $i$ 个元素和 $B$ 的前 $j$ 个元素的最小代价。
- **状态转移方程**：
  - 如果 $A_i = B_j$，则 $dp_{i,j} = dp_{i-1,j-1}$。
  - 否则，$dp_{i,j} = \min(dp_{i-1,j}, dp_{i,j-1}, dp_{i-1,j-1}) + 1$。
- **初始化**：$dp_{i,0} = i$，$dp_{0,j} = j$。

### 可拓展之处
- **编辑距离问题**：本题与编辑距离问题（如 LeetCode 72）类似，可以通过类似的状态转移方程解决。
- **序列匹配问题**：类似的问题还包括最长公共子序列（LCS）等，可以通过动态规划解决。

### 推荐题目
1. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)
2. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)

### 个人心得
- **调试经历**：在初始化时需要注意边界条件，避免数组越界或未初始化导致的错误。
- **顿悟感想**：通过动态规划解决序列匹配问题时，状态转移方程的设计是关键，理解问题的本质有助于快速找到解决方案。

---
处理用时：37.62秒
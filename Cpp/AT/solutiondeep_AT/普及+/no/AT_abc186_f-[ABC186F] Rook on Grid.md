# 题目信息

# [ABC186F] Rook on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc186/tasks/abc186_f

縦 $ H $ マス、横 $ W $ マスのグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,j) $ と表します。

グリッド上には $ M $ 個の障害物があり、$ i $ 番目の障害物はマス $ (X_i,Y_i) $ に置かれています。

マス $ (1,1) $ に飛車の駒が置いてあります。飛車の駒は、今いる位置から右または下方向に伸びる直線上にあり、障害物を飛び越えずに到達できるマスに $ 1 $ 手で移動することができます。

$ 2 $ 手以内の移動で飛車の駒が到達できるマスの数を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\ \leq\ 2\times\ 10^5 $
- $ 0\leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ X_i\ \leq\ H $
- $ 1\leq\ Y_i\ \leq\ W $
- $ (X_i,Y_i)\ \neq\ (1,1) $
- $ (X_i,Y_i) $ は相異なる
- 入力は全て整数

### Sample Explanation 1

障害物のない全てのマスに $ 2 $ 手以内で移動できます。

### Sample Explanation 2

障害物のないマスのうち、$ (4,4),(5,4) $ 以外の全てのマスに $ 2 $ 手以内で移動できます。

## 样例 #1

### 输入

```
4 3 2

2 2

3 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5 4 4

3 2

3 4

4 2

5 2```

### 输出

```
14```

## 样例 #3

### 输入

```
200000 200000 0```

### 输出

```
40000000000```

# AI分析结果

### 题目内容重写

【题目描述】

有一个高度为 $H$ 格，宽度为 $W$ 格的网格。从上到下第 $i$ 行，从左到右第 $j$ 列的格子记为 $(i,j)$。

网格上有 $M$ 个障碍物，第 $i$ 个障碍物位于格子 $(X_i,Y_i)$。

在格子 $(1,1)$ 上有一个飞车的棋子。飞车的棋子可以从当前位置向右或向下延伸的直线上移动，且不能越过障碍物，一步可以移动到这些直线上可达的格子。

求在两步以内移动中，飞车的棋子可以到达的格子数量。

### 算法分类

树状数组

### 题解分析与结论

本题的核心在于如何高效地统计飞车在两步以内可以到达的格子数量，同时避免重复计算。题解中主要使用了树状数组来优化查询和更新操作，确保在 $O(N\log N)$ 的时间复杂度内完成计算。

### 精选题解

#### 题解作者：Hughpig (赞：16)

**星级：5星**

**关键亮点：**
1. 详细分析了两种走法（先右后下和先下后右）的贡献，并给出了去重的思路。
2. 使用树状数组优化了查询和更新操作，确保时间复杂度为 $O(N\log N)$。
3. 代码结构清晰，逻辑严谨，易于理解。

**核心代码：**
```cpp
void add(ll pos){
    for(;pos<=qwq;pos+=lowbit(pos))c[pos]++;
}

ll query(ll pos){
    ll ret=0;
    for(;pos;pos-=lowbit(pos))ret+=c[pos];
    return ret;
}
```
**实现思想：**
通过树状数组维护每列的障碍物信息，快速计算每行的可达格子数量，并避免重复计算。

#### 题解作者：cjh20090318 (赞：5)

**星级：4星**

**关键亮点：**
1. 提出了使用树状数组来维护查询区间的思路，优化了重复计算的部分。
2. 代码实现简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
inline void add(int x,const T&v){assert(0<x&&x<=SIZE);for(;x<=SIZE;x+=x&-x)dt[x]+=v;}
inline T sum(const int&l,const int&r)const{assert(0<l&&l<=r&&r<=SIZE);return sum(r)-sum(l-1);}
```
**实现思想：**
通过树状数组维护每列的障碍物信息，快速计算每行的可达格子数量，并避免重复计算。

### 最优关键思路或技巧

1. **树状数组的应用**：树状数组在本题中起到了关键作用，用于高效地维护和查询每列的障碍物信息，确保在 $O(N\log N)$ 的时间复杂度内完成计算。
2. **去重策略**：通过分析两种走法的贡献，巧妙地避免了重复计算，确保结果的准确性。

### 可拓展之处

本题的思路可以拓展到其他类似的网格问题，特别是涉及到路径统计和障碍物处理的问题。树状数组的应用也可以推广到其他需要高效查询和更新的场景。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得

在调试过程中，树状数组的初始化和更新操作需要特别注意，确保每个位置的正确性。此外，去重策略的实现需要仔细分析，避免遗漏或重复计算。

---
处理用时：25.75秒
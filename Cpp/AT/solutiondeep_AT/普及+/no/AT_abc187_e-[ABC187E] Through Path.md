# 题目信息

# [ABC187E] Through Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc187/tasks/abc187_e

$ N $ 頂点 $ N-1 $ 辺から成る木があり、頂点には $ 1,\ 2,\ \dots,\ N $ の番号が、辺には $ 1,\ 2,\ \dots,\ N-1 $ の番号がついています。辺 $ i $ は頂点 $ a_i $ と頂点 $ b_i $ を結びます。 この木の各頂点には $ 1 $ つの整数が書かれています。頂点 $ i $ に書かれている整数を $ c_i $ とします。はじめ、 $ c_i\ =\ 0 $ です。

$ Q $ 個のクエリが与えられます。 $ i $ 番目のクエリでは、整数 $ t_i,\ e_i,\ x_i $ が与えられます。クエリの内容は以下の通りです。

- $ t_i\ =\ 1 $ のとき : 頂点 $ a_{e_i} $ から辺をたどって頂点 $ b_{e_i} $ を通らずに到達できるような全ての頂点 $ v $ に対して、$ c_v $ を $ c_v\ +\ x_i $ に書き換える。
- $ t_i\ =\ 2 $ のとき : 頂点 $ b_{e_i} $ から辺をたどって頂点 $ a_{e_i} $ を通らずに到達できるような全ての頂点 $ v $ に対して、$ c_v $ を $ c_v\ +\ x_i $ に書き換える。

すべてのクエリを処理した後、各頂点に書かれた整数を出力してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ a_i,\ b_i\ \le\ N $
- 与えられるグラフは木である
- $ 1\ \le\ Q\ \le\ 2\ \times\ 10^5 $
- $ t_i\ \in\ \{1,\ 2\} $
- $ 1\ \le\ e_i\ \le\ N-1 $
- $ 1\ \le\ x_i\ \le\ 10^9 $

### Sample Explanation 1

$ 1 $ 番目のクエリでは、頂点 $ 1 $ から始めて頂点 $ 2 $ を通らずに到達できる頂点 $ 1 $ に $ 1 $ を足します。 $ 2 $ 番目のクエリでは、頂点 $ 4 $ から始めて頂点 $ 5 $ を通らずに到達できる頂点 $ 1,\ 2,\ 3,\ 4 $ に $ 10 $ を足します。 $ 3 $ 番目のクエリでは、頂点 $ 2 $ から始めて頂点 $ 1 $ を通らずに到達できる頂点 $ 2,\ 3,\ 4,\ 5 $ に $ 100 $ を足します。 $ 4 $ 番目のクエリでは、頂点 $ 3 $ から始めて頂点 $ 2 $ を通らずに到達できる頂点 $ 3 $ に $ 1000 $ を足します。

## 样例 #1

### 输入

```
5

1 2

2 3

2 4

4 5

4

1 1 1

1 4 10

2 1 100

2 2 1000```

### 输出

```
11

110

1110

110

100```

## 样例 #2

### 输入

```
7

2 1

2 3

4 2

4 5

6 1

3 7

7

2 2 1

1 3 2

2 2 4

1 6 8

1 3 16

2 4 32

2 1 64```

### 输出

```
72

8

13

26

58

72

5```

## 样例 #3

### 输入

```
11

2 1

1 3

3 4

5 2

1 6

1 7

5 8

3 9

3 10

11 4

10

2 6 688

1 10 856

1 8 680

1 8 182

2 2 452

2 4 183

2 6 518

1 3 612

2 6 339

2 3 206```

### 输出

```
1657

1657

2109

1703

1474

1657

3202

1474

1247

2109

2559```

# AI分析结果

### 题目翻译

给定一棵有 $N$ 个顶点和 $N-1$ 条边的树，顶点编号为 $1, 2, \dots, N$，边编号为 $1, 2, \dots, N-1$。第 $i$ 条边连接顶点 $a_i$ 和 $b_i$。每个顶点初始时有一个整数 $c_i = 0$。

接下来有 $Q$ 个查询，每个查询给出三个整数 $t_i, e_i, x_i$，查询内容如下：

- 如果 $t_i = 1$，则从顶点 $a_{e_i}$ 出发，沿着边遍历，但不经过顶点 $b_{e_i}$，将所有可以到达的顶点 $v$ 的 $c_v$ 增加 $x_i$。
- 如果 $t_i = 2$，则从顶点 $b_{e_i}$ 出发，沿着边遍历，但不经过顶点 $a_{e_i}$，将所有可以到达的顶点 $v$ 的 $c_v$ 增加 $x_i$。

处理完所有查询后，输出每个顶点的最终 $c_i$ 值。

### 算法分类
差分、深度优先搜索 DFS

### 题解分析与结论

1. **核心思路**：  
   所有题解的核心思路都是通过树上差分来处理查询操作。首先通过 DFS 确定每个节点的深度和父子关系，然后根据查询类型和深度关系，决定是对某个子树还是整个树进行差分标记。最后通过第二次 DFS 计算每个节点的最终值。

2. **难点对比**：  
   - **Let_Fly** 的题解通过深度判断来决定是对子树还是全局进行差分标记，思路清晰，代码简洁。
   - **tjtdrxxz** 的题解使用了树链剖分和线段树，虽然思路正确，但代码复杂度较高，不适合本题的简单需求。
   - **GI录像机** 的题解同样使用了树上差分，但代码实现较为冗长，可读性稍差。

3. **最优关键思路**：  
   - 通过 DFS 预处理深度和父子关系。
   - 根据查询类型和深度关系，决定是对子树还是全局进行差分标记。
   - 最后通过第二次 DFS 计算每个节点的最终值。

### 高星题解推荐

1. **Let_Fly (5星)**  
   - **关键亮点**：思路清晰，代码简洁，使用了树上差分和两次 DFS，时间复杂度为 $O(N+Q)$。
   - **代码核心**：
     ```cpp
     void dfs1(int u, int fa) {
         dep[u] = dep[fa] + 1;
         for (auto v : to[u]) {
             if (v == fa) continue;
             dfs1(v, u);
         }
     }

     void dfs(int u, int fa, int j) {
         j += tag[u];
         wei[u] += j;
         for (auto v : to[u]) {
             if (v == fa) continue;
             dfs(v, u, j);
         }
     }
     ```

2. **Muh_Yih (4星)**  
   - **关键亮点**：使用了 DFS 序和差分数组，思路清晰，代码实现较为简洁。
   - **代码核心**：
     ```cpp
     void depdfs(int x, int fa, int dep) {
         depth[x] = dep;
         for (int i = 0; i < mp[x].size(); i++) {
             int pt = mp[x][i];
             if (pt != fa) depdfs(pt, x, dep + 1);
         }
     }
     ```

### 拓展思路
- 类似题目可以考察树上的区间修改和查询，如子树加、路径加等。
- 可以使用树链剖分、线段树等数据结构来处理更复杂的树上操作。

### 推荐题目
1. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P3258 [JLOI2014]松鼠的新家](https://www.luogu.com.cn/problem/P3258)

---
处理用时：30.36秒
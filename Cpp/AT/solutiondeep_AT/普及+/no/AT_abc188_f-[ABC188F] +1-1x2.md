# 题目信息

# [ABC188F] +1-1x2

## 题目描述

高桥君在黑板上写下了一个正整数 X，现在高桥君想要让这个正整数变成 Y，每一次都可以按以下三种中的任意一种方式来改变这个数:

1. 将目前黑板上的数加1。

2. 将目前黑板上的数减1。

3. 将目前黑板上的数乘以2。

现在高桥君想要知道从 X 变成 Y 的最小次数。

## 说明/提示

- 1≤X≤${10^{18}}$
- 1≤Y≤${10^{18}}$

## 样例 #1

### 输入

```
3 9```

### 输出

```
3```

## 样例 #2

### 输入

```
7 11```

### 输出

```
3```

## 样例 #3

### 输入

```
1000000000000000000 1000000000000000000```

### 输出

```
0```

# AI分析结果

### 题目内容
高桥君在黑板上写下了一个正整数 X，现在高桥君想要让这个正整数变成 Y，每一次都可以按以下三种中的任意一种方式来改变这个数:

1. 将目前黑板上的数加1。

2. 将目前黑板上的数减1。

3. 将目前黑板上的数乘以2。

现在高桥君想要知道从 X 变成 Y 的最小次数。

### 说明/提示
- 1≤X≤${10^{18}}$
- 1≤Y≤${10^{18}}$

### 样例 #1
#### 输入
```
3 9```
#### 输出
```
3```

### 样例 #2
#### 输入
```
7 11```
#### 输出
```
3```

### 样例 #3
#### 输入
```
1000000000000000000 1000000000000000000```
#### 输出
```
0```

### 算法分类
搜索（深度优先搜索 DFS）

### 综合分析与结论
本题的核心在于通过搜索找到从 X 到 Y 的最小操作次数。由于 X 和 Y 的范围非常大（1≤X,Y≤10^18），直接暴力搜索会超时，因此需要采用记忆化搜索或逆向搜索来优化。

### 所选题解
#### 题解1：The_End_of_GCC (赞：10)
**星级：4.5星**
**关键亮点：**
- 使用记忆化搜索，避免重复计算。
- 通过递归和分治思想，将问题分解为更小的子问题。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
long long dfs(long long a,long long b)
{
	if(a==b)    //第一种情况。
		return 0;
	if(a>b)    //第二种情况。
		return a-b;
	if(f.count(b)!=0)    //第三种情况。
		return f[b];
	f[b]=b-a;    //第四步。
	if(b%2==0)    //情况 5.1。
		f[b]=min(dfs(a,b/2)+1,f[b]);    //递归判断较小值。
	else    //情况 5.2。
		f[b]=min(min(dfs(a,(b+1)/2)+2,dfs(a,(b-1)/2)+2),f[b]);   //递归判断最小值。
	return f[b];    //返回 f[b]。
}
```

#### 题解2：Mzaaa (赞：4)
**星级：4星**
**关键亮点：**
- 使用 `unordered_map` 进行记忆化，提高效率。
- 逆向搜索，从 Y 开始，减少搜索空间。
- 代码简洁，易于理解。

**核心代码：**
```cpp
long long dfs(long long y)
{
	if(x==y)	//相等返回 0
		return 0;
	if(y==x+1||y==x-1||y==2*x)	//一步能搜到 
		return 1;
	if(mp[y]) return mp[y];		//如果搜过，直接返回 
	if(y<x) return mp[y]=x-y;
	else
		if(y%2!=0)
			return mp[y]=min(dfs(y+1),dfs(y-1))+1;
		else
			return mp[y]=min(dfs(y/2)+1,y-x);
}
```

#### 题解3：vanueber (赞：3)
**星级：4星**
**关键亮点：**
- 使用 BFS 进行搜索，结合 `map` 进行记忆化。
- 逆向搜索，从 Y 开始，减少搜索空间。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
long long bfs(long long s, long long f)
{
	queue<node> Q;
	map<long long, long long> p;
	p[f] = 1;
	Q.push(node{f, 0});
	long long ans = INF;
	while (!Q.empty())
	{
		node x = Q.front();
		Q.pop();
		if (p.find(x.num) != p.end() && p[x.num] < x.cnt)
			continue;
		p[x.num] = x.cnt;
		ans = min(ans, x.cnt + abs(s - x.num)); //计算当前最少操作数
		node tmp;
		if (x.num % 2 == 0)
		{
			Q.push(node{x.num / 2, x.cnt + 1});
		}
		else
		{
			Q.push(node{(x.num + 1) / 2, x.cnt + 2});
			Q.push(node{(x.num - 1) / 2, x.cnt + 2});
		} //扩展，加入队列中
	}
	return ans;
}
```

### 最优关键思路或技巧
1. **记忆化搜索**：通过记录已经计算过的状态，避免重复计算，显著提高效率。
2. **逆向搜索**：从目标 Y 开始，逐步逆向操作，减少搜索空间。
3. **分治思想**：将问题分解为更小的子问题，分别求解，最后合并结果。

### 可拓展之处
类似的问题可以通过逆向搜索和记忆化搜索来解决，例如：
- 从某个状态到目标状态的最小操作次数问题。
- 状态转移问题，如最短路径、最小步数等。

### 推荐题目
1. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得
在解决此类问题时，逆向搜索和记忆化搜索是非常有效的策略，可以显著减少搜索空间和提高效率。同时，分治思想的应用也能帮助我们将复杂问题分解为更易处理的子问题。

---
处理用时：36.90秒
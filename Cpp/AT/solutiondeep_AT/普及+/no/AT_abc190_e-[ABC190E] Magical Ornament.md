# 题目信息

# [ABC190E] Magical Ornament

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc190/tasks/abc190_e

AtCoder 王国には $ 1,\ 2,\ \dots,\ N $ の番号がついた $ N $ 種類の魔法石が流通しています。  
 高橋くんは、魔法石を一列に並べて飾りを作ろうとしています。  
 魔法石には隣り合わせにできる組とできない組があります。 隣り合わせにできる組は $ ( $魔法石 $ A_1, $ 魔法石 $ B_1),\ ( $魔法石 $ A_2, $ 魔法石 $ B_2),\ \dots,\ ( $魔法石 $ A_M, $ 魔法石 $ B_M) $ の $ M $ 組で、それ以外の組は隣り合わせることができません。(これらの組において、石の順序は不問です。)  
 魔法石 $ C_1,\ C_2,\ \dots,\ C_K $ をそれぞれ $ 1 $ 個以上含む魔法石の列を作ることができるか判定し、作れる場合はそのような列を作るのに必要な魔法石の個数の最小値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ <\ = N\ <\ =\ 10^5 $
- $ 0\ <\ = M\ <\ =\ 10^5 $
- $ 1\ <\ =\ A_i\ <\ B_i\ <\ =\ N $
- $ i\ ≠\ j $ ならば $ (A_i,\ B_i)\ ≠\ (A_j,\ B_j) $
- $ 1\ <\ =\ K\ <\ =\ 17 $
- $ 1\ <\ =\ C_1\ <\ C_2\ <\ \dots\ <\ C_K\ <\ =\ N $

### Sample Explanation 1

例えば、魔法石を $ [1,\ 4,\ 2,\ 4,\ 3] $ と並べると、魔法石 $ 1,\ 2,\ 3 $ を含む長さ $ 5 $ の列を作ることができます。

### Sample Explanation 3

例えば、魔法石を $ [1,\ 6,\ 7,\ 5,\ 8,\ 3,\ 9,\ 3,\ 8,\ 10,\ 2] $ と並べると、魔法石 $ 1,\ 2,\ 7,\ 9 $ を含む長さ $ 11 $ の列を作ることができます。

## 样例 #1

### 输入

```
4 3

1 4

2 4

3 4

3

1 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
4 3

1 4

2 4

1 2

3

1 2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 10

3 9

3 8

8 10

2 10

5 8

6 8

5 7

6 7

1 6

2 4

4

1 2 7 9```

### 输出

```
11```

# AI分析结果

### 题目内容重写

**题目描述**

AtCoder 王国中有编号为 $1, 2, \dots, N$ 的 $N$ 种魔法石在流通。高桥君想要将这些魔法石排成一列制作装饰品。魔法石之间有些可以相邻摆放，有些则不能。具体来说，有 $M$ 组魔法石可以相邻摆放，分别是 $(A_1, B_1), (A_2, B_2), \dots, (A_M, B_M)$，除此之外的任何两组魔法石都不能相邻摆放。（这些组中，石头的顺序不限。）

高桥君想要制作一个包含 $C_1, C_2, \dots, C_K$ 这 $K$ 种魔法石的序列，每种魔法石至少出现一次。请判断是否存在这样的序列，如果存在，求出所需魔法石的最小数量；如果不存在，输出 `-1`。

**说明/提示**

- 输入均为整数。
- $1 \leq N \leq 10^5$
- $0 \leq M \leq 10^5$
- $1 \leq A_i < B_i \leq N$
- $i \neq j$ 时，$(A_i, B_i) \neq (A_j, B_j)$
- $1 \leq K \leq 17$
- $1 \leq C_1 < C_2 < \dots < C_K \leq N$

**样例解释**

- 样例1：例如，魔法石按 $[1, 4, 2, 4, 3]$ 排列，可以包含魔法石 $1, 2, 3$，长度为 $5$。
- 样例3：例如，魔法石按 $[1, 6, 7, 5, 8, 3, 9, 3, 8, 10, 2]$ 排列，可以包含魔法石 $1, 2, 7, 9$，长度为 $11$。

### 算法分类

**动态规划、最短路、状压DP**

### 题解分析与结论

本题的核心是找到包含所有指定魔法石的最短序列，且序列中相邻的魔法石必须是可以相邻的。由于 $K \leq 17$，可以使用状压DP来解决。首先，通过BFS预处理每对指定魔法石之间的最短距离，然后使用状压DP来枚举所有可能的序列组合，找到最短的合法序列。

### 所选高星题解

#### 题解1：作者：Meickol (赞：1)

**星级：4星**

**关键亮点：**
- 使用BFS预处理每对指定魔法石之间的最短距离。
- 使用状压DP枚举所有可能的序列组合，找到最短的合法序列。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
void bfs(int u){
    memset(dist,INF,sizeof dist);
    memset(st,0,sizeof st);
    st[u]=1;
    dist[u]=0;
    queue<int> q;
    q.push(u);
    while(!q.empty()){
        auto t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i]){
            int j=e[i];
            if(st[j]) continue;
            dist[j]=dist[t]+1;
            q.push(j);
            st[j]=1;
        }
    }
}
```

#### 题解2：作者：Union_Find (赞：1)

**星级：4星**

**关键亮点：**
- 使用BFS预处理每对指定魔法石之间的最短距离。
- 使用状压DP枚举所有可能的序列组合，找到最短的合法序列。
- 代码实现简洁，优化了空间复杂度。

**核心代码：**
```cpp
void bfs(ll s){
    queue <ll> q;
    memset (vis, 0, sizeof vis);
    memset (dis[s], 0x3f, sizeof dis[s]);
    q.push(c[s]), dis[s][c[s]] = 0, vis[c[s]] = 1;
    while (q.size()){
        ll u = q.front();
        q.pop();
        for (int i = head[u]; i; i = nxt[i]){
            ll v = to[i];
            if (vis[v]) continue;
            vis[v] = 1;
            q.push(v);
            dis[s][v] = min(dis[s][v], dis[s][u] + 1);
        }
    }
}
```

#### 题解3：作者：CQ_Bob (赞：1)

**星级：4星**

**关键亮点：**
- 使用Dijkstra预处理每对指定魔法石之间的最短距离。
- 使用状压DP枚举所有可能的序列组合，找到最短的合法序列。
- 代码实现较为高效，适合大规模数据。

**核心代码：**
```cpp
void dij(int s,int id){
    priority_queue<PII,vector<PII>,greater<PII>> qu;
    qu.push({0,s}),dis[id][s]=0;
    while(!qu.empty()){
        PII now=qu.top();qu.pop();
        if(vis[id][now.y]) continue;
        vis[id][now.y]=1;
        for(re int i=h[now.y];i;i=ne[i]){
            int j=e[i];if(dis[id][j]>dis[id][now.y]+1){
                dis[id][j]=dis[id][now.y]+1,qu.push({dis[id][j],j});
            }
        }
    }
}
```

### 最优关键思路或技巧

1. **预处理最短距离**：使用BFS或Dijkstra预处理每对指定魔法石之间的最短距离，确保后续DP计算的准确性。
2. **状压DP**：利用状压DP枚举所有可能的序列组合，通过状态转移方程找到最短的合法序列。
3. **位运算优化**：使用位运算来高效地表示和转移状态，减少时间和空间复杂度。

### 可拓展之处

本题的状压DP思路可以应用于其他需要枚举所有子集的问题，如旅行商问题（TSP）、子集和问题等。通过预处理最短距离，可以进一步优化类似图论问题中的路径搜索。

### 推荐相似题目

1. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P2831 愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)

---
处理用时：43.28秒
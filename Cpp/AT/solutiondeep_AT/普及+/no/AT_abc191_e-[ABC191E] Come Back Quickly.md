# 题目信息

# [ABC191E] Come Back Quickly

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc191/tasks/abc191_e

AtCoder 国には、町 $ 1 $ から町 $ N $ までの $ N $ 個の町と、道路 $ 1 $ から道路 $ M $ までの $ M $ 本の道路があります。  
 道路 $ i $ は町 $ A_i $ から町 $ B_i $ への一方通行で、通るのに $ C_i $ 分かかります。$ A_i\ =\ B_i $ かもしれませんし、同じ町の組を結ぶ道路が複数あるかもしれません。  
 高橋君はこの国で散歩をしようと考えました。ある町から出発し、$ 1 $ 本以上の道路を通り、出発した町に帰ってくるような経路を**正しい散歩経路**と呼ぶことにします。  
 各町について、その町から出発する正しい散歩経路が存在するかを判定してください。また、存在するなら、そのような経路を通るのにかかる時間の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2000 $
- $ 1\ \le\ M\ \le\ 2000 $
- $ 1\ \le\ A_i\ \le\ N $
- $ 1\ \le\ B_i\ \le\ N $
- $ 1\ \le\ C_i\ \le\ 10^5 $
- 入力は全て整数

### Sample Explanation 1

道路 $ 1,\ 2,\ 3 $ によって、町 $ 1,\ 2,\ 3 $ は一周に $ 30 $ 分かかる一つの輪のように繋がっています。 町 $ 4 $ から町 $ 1,\ 2,\ 3 $ に行くことはできますが、町 $ 4 $ に帰ってくることはできません。

### Sample Explanation 2

$ A_i\ =\ B_i $ であるような道路が存在するかもしれません。 この場合、町 $ 1 $ からは、道路 $ 6 $ だけを使って $ 10 $ 分で町 $ 1 $ に帰ってくることができます。

### Sample Explanation 3

同じ町の組を結ぶ道路が複数あるかもしれないことに注意してください。

## 样例 #1

### 输入

```
4 4

1 2 5

2 3 10

3 1 15

4 3 20```

### 输出

```
30

30

30

-1```

## 样例 #2

### 输入

```
4 6

1 2 5

1 3 10

2 4 5

3 4 10

4 1 10

1 1 10```

### 输出

```
10

20

30

20```

## 样例 #3

### 输入

```
4 7

1 2 10

2 3 30

1 4 15

3 4 25

3 4 20

4 3 20

4 3 30```

### 输出

```
-1

-1

40

40```

# AI分析结果

### 题目内容重写
【题目内容】
# [ABC191E] Come Back Quickly

## 题目描述

AtCoder 国有从城市 $1$ 到城市 $N$ 的 $N$ 个城市，以及从道路 $1$ 到道路 $M$ 的 $M$ 条道路。  
 道路 $i$ 是从城市 $A_i$ 到城市 $B_i$ 的单向道路，通过它需要花费 $C_i$ 分钟。$A_i$ 和 $B_i$ 可能相同，也可能有多条道路连接同一对城市。  
 高桥君想要在这个国家散步。从一个城市出发，经过一条或多条道路，最终回到出发城市的路径称为**正确的散步路径**。  
 对于每个城市，判断是否存在从该城市出发的正确散步路径。如果存在，求出通过该路径所需的最短时间。

## 说明/提示

### 制約

- $1\ \le\ N\ \le\ 2000$
- $1\ \le\ M\ \le\ 2000$
- $1\ \le\ A_i\ \le\ N$
- $1\ \le\ B_i\ \le\ N$
- $1\ \le\ C_i\ \le\ 10^5$
- 输入均为整数

### 样例解释 1

道路 $1,\ 2,\ 3$ 将城市 $1,\ 2,\ 3$ 连接成一个环，绕一圈需要 $30$ 分钟。城市 $4$ 可以到达城市 $1,\ 2,\ 3$，但无法回到城市 $4$。

### 样例解释 2

可能存在 $A_i\ =\ B_i$ 的道路。在这种情况下，城市 $1$ 可以通过道路 $6$ 花费 $10$ 分钟回到城市 $1$。

### 样例解释 3

注意可能存在多条道路连接同一对城市。

## 样例 #1

### 输入

```
4 4

1 2 5

2 3 10

3 1 15

4 3 20```

### 输出

```
30

30

30

-1```

## 样例 #2

### 输入

```
4 6

1 2 5

1 3 10

2 4 5

3 4 10

4 1 10

1 1 10```

### 输出

```
10

20

30

20```

## 样例 #3

### 输入

```
4 7

1 2 10

2 3 30

1 4 15

3 4 25

3 4 20

4 3 20

4 3 30```

### 输出

```
-1

-1

40

40```

### 算法分类
最短路

### 题解分析与结论
本题的核心是求解每个城市出发并回到该城市的最短路径，属于典型的最短路问题。题解中主要使用了Dijkstra算法的优化版本，通过优先队列（堆）来优化松弛操作，从而高效地求解最短路径。

### 所选高分题解
#### 1. 作者：fengenrong (4星)
**关键亮点**：
- 使用了链式前向星存储图结构，优化了空间复杂度。
- 通过优先队列优化Dijkstra算法，提高了时间效率。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
int DIS(int x) {
    int dis[MAX];
    memset(dis, 63, sizeof(dis));
    bool vis[MAX];
    memset(vis, 0, sizeof(vis));
    while (!q.empty()) q.pop();
    for (int i = head[x]; i != -1; i = a[i].from) {
        dis[a[i].to] = min(dis[a[i].to], a[i].sum);
    }
    for (int i = 1; i <= n; i++) {
        if (dis[i] != dis[0]) {
            q.push(node(dis[i], i));
        }
    }
    while (!q.empty()) {
        int NUM = q.top().num;
        q.pop();
        if (vis[NUM]) continue;
        for (int i = head[NUM]; i != -1; i = a[i].from) {
            int jkl = a[i].to;
            if (dis[jkl] > dis[NUM] + a[i].sum) {
                dis[jkl] = dis[NUM] + a[i].sum;
                q.push(node(dis[jkl], jkl));
            }
        }
    }
    return dis[x] == dis[0] ? -1 : dis[x];
}
```

#### 2. 作者：Tang_poetry_syndrome (4星)
**关键亮点**：
- 使用了C++的STL容器和算法，代码简洁高效。
- 通过优先队列优化Dijkstra算法，代码可读性强。
- 对每个城市单独进行最短路计算，思路清晰。

**核心代码**：
```cpp
f(i, 0, n - 1) {
    vector<ll> d(n, INF);
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;
    q.push(make_pair(0LL, i));
    while (!q.empty()) {
        ll c;
        int b;
        tie(c, b) = q.top();
        q.pop();
        if (c > d[b]) continue;
        ll e = d[b];
        if (b == i) e = 0;
        for (pair<ll, int> p : g[b]) {
            ll w = p.first;
            int u = p.second;
            if (e + w < d[u]) {
                d[u] = e + w;
                q.push(make_pair(d[u], u));
            }
        }
    }
    ll ans = d[i];
    if (ans == INF) ans = -1;
    cout << ans << endl;
}
```

#### 3. 作者：lyt_awa (4星)
**关键亮点**：
- 直接使用Dijkstra算法求解最短路，思路简单直接。
- 通过遍历每个城市的最短路，判断是否存在回到起点的路径。
- 代码实现简洁，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    dijkstra(i);
    ll ans = inf;
    for (auto j : G[i]) {
        ans = min(ans, d[j.first] + j.second);
    }
    cout << (ans == inf ? -1 : ans) << '\n';
}
```

### 最优关键思路或技巧
1. **Dijkstra算法的优化**：通过优先队列（堆）来优化松弛操作，提高算法效率。
2. **链式前向星存储图**：优化空间复杂度，适用于稀疏图。
3. **单独计算每个城市的最短路**：通过遍历每个城市的最短路，判断是否存在回到起点的路径。

### 可拓展之处
1. **Floyd-Warshall算法**：适用于求解所有城市对之间的最短路，但时间复杂度较高。
2. **Bellman-Ford算法**：适用于存在负权边的情况。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

---
处理用时：47.84秒
# 题目信息

# [ABC192F] Potion

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc192/tasks/abc192_f

$ N $ 種類の素材があり、素材 $ i $ には $ A_i $ の魔力があります。

魔法使いの高橋君は、この中から $ 1 $ 種類以上を選んで合成し、ポーションを作ろうとしています。

$ k $ 種類の素材を合成して出来たポーションの魔力は、合成した直後には素材の魔力の合計であり、時間が $ 1 $ 経過するごとに $ k $ 増加します。 魔力の増加は連続的ではなく離散的であることに注意してください。

高橋君が時刻 $ 0 $ に $ 1 $ 度だけ素材の合成を行うとき、魔力がちょうど $ X $ のポーションは、最速でいつ手に入りますか？

なお、制約下で魔力がちょうど $ X $ のポーションを作れることが証明されます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ A_i\ \leq\ 10^7 $
- $ 10^9\ \leq\ X\ \leq\ 10^{18} $
- 入力は全て整数

### Sample Explanation 1

素材 $ 1 $ と素材 $ 3 $ を合成して出来たポーションの魔力は、時刻 $ 0 $ で $ 3+8=11 $ であり、時間が $ 1 $ 経過するごとに $ 2 $ 増加するので、時刻 $ 4999999994 $ に $ 9999999999 $ になります。これが最速です。 素材 $ 1,2,3 $ 全てを合成して出来たポーションの魔力は、時刻 $ 3333333327 $ に $ 9999999998 $、時刻 $ 3333333328 $ に $ 10000000001 $ となり、ちょうど $ 9999999999 $ にはなりません。

## 样例 #1

### 输入

```
3 9999999999

3 6 8```

### 输出

```
4999999994```

## 样例 #2

### 输入

```
1 1000000000000000000

1```

### 输出

```
999999999999999999```

# AI分析结果

### 题目内容重写

**题目描述**

有 $N$ 种素材，每种素材 $i$ 具有 $A_i$ 的魔力。

魔法师高桥君想从中选择一种或多种素材进行合成，制作一种药水。

如果选择了 $k$ 种素材进行合成，药水的魔力在合成后立即为所选素材的魔力之和，每经过 $1$ 单位时间，魔力会增加 $k$。注意，魔力的增加是离散的，而不是连续的。

高桥君在时刻 $0$ 进行一次素材合成，问魔力恰好为 $X$ 的药水最早在何时可以获得？

**说明/提示**

- $1 \leq N \leq 100$
- $1 \leq A_i \leq 10^7$
- $10^9 \leq X \leq 10^{18}$
- 输入均为整数

**样例**

输入：
```
3 9999999999
3 6 8
```
输出：
```
4999999994
```

### 算法分类

动态规划

### 题解分析与结论

#### 核心思路

1. **问题转化**：药水的魔力随时间增加，因此需要找到一个时间 $t$，使得 $sum + k \cdot t = X$，其中 $sum$ 是所选素材的魔力之和，$k$ 是所选素材的数量。
2. **模数条件**：为了使 $sum + k \cdot t = X$ 成立，必须满足 $sum \equiv X \pmod k$。
3. **动态规划**：通过枚举 $k$，使用动态规划计算在模 $k$ 下满足条件的最大 $sum$，然后计算最小的时间 $t = \frac{X - sum}{k}$。

#### 最优关键思路

- **枚举 $k$**：通过枚举选择的素材数量 $k$，将问题转化为在模 $k$ 下寻找最大 $sum$ 的问题。
- **动态规划优化**：使用三维 DP 数组 $f_{i,j,k}$ 表示前 $i$ 个素材中选择了 $j$ 个，且 $sum \bmod k = k$ 时的最大 $sum$。通过状态转移方程优化计算。

#### 可拓展之处

- **类似问题**：可以扩展到其他需要满足模数条件的优化问题，如背包问题、子集和问题等。
- **算法优化**：可以考虑进一步优化 DP 的空间复杂度，或者使用剪枝策略减少计算量。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)

### 题解评分与亮点

#### 题解1：Light_Star_RPmax_AFO (5星)

**关键亮点**：
- **清晰的状态转移方程**：明确给出了 DP 的状态转移方程，便于理解。
- **代码简洁**：代码结构清晰，易于实现。

**核心代码**：
```cpp
for(int s = 1;s <= n;s++){//枚举选几个 。 
    memset(f,-1,sizeof(f));
    f[0][0][0] = 0;
    for(int i = 1;i <= n;i++){//枚举现在考虑的。 
        f[i][0][0] = 0;
        for(int j = 1;j <= s;j++)//枚举已经选了几个 
            for(int k = 0; k < s;k++){//枚举余数。 
                f[i][j][k] = f[i - 1][j][k];
                if(f[i - 1][j - 1][(k + s - (a[i - 1] % s)) % s] != -1)
                    f[i][j][k] = max(f[i][j][k],f[i - 1][j - 1][(k + s - (a[i - 1] % s)) % s] + a[i - 1]);
            }
    }
    if(f[n][s][x%s] != -1)
        ans = min(ans,(x - f[n][s][x%s]) / s);
}
```

#### 题解2：Louis_lxy (4星)

**关键亮点**：
- **剪枝优化**：通过剪枝策略减少计算量，提高效率。
- **复杂度分析**：详细分析了算法的复杂度，便于理解。

**核心代码**：
```cpp
for(int k = 1;k <= n;k++) {
    memset(dp,0xcf,sizeof(dp));
    dp[0][0][0] = 0;
    for(int i = 1;i <= n;i++) {
        dp[i][0][0] = 0;
        for(int j = 1;j <= k;j++)
            for(int l = 0;l < k;l++)
                dp[i][j][l] = max(dp[i-1][j][l],dp[i-1][j-1][(l+k-(a[i-1]%k))%k]+a[i-1]);
    }
    if(dp[n][k][x%k]>=0)
        ans = min(ans,(x-dp[n][k][x%k])/k);
}
```

#### 题解3：lfxxx (4星)

**关键亮点**：
- **背包问题思路**：将问题转化为背包问题，思路清晰。
- **代码实现**：代码结构合理，易于理解。

**核心代码**：
```cpp
for(int k = 1;k <= n;k++) {
    memset(dp,0,sizeof dp);
    for(int i = 1;i <= n;i++) {
        for(int j = (k<<1)-1;j >= b[i];j--) {
            for(int u = k-1;~u;u--) {
                if(j-b[i]==0&&u==0||dp[j-b[i]][u]) dp[j][u+1] = max(dp[j][u+1],dp[j-b[i]][u]+a[i]);
            }
        }
        for(int j = 0;j < k;j++) {
            for(int u = 0;u <= k;u++) {
                dp[j][u] = max(dp[j][u],dp[j+k][u]);
                dp[j+k][u] = 0;
            }
        }
    }
    if(dp[X%k][k]) ans = min(ans,(X-dp[X%k][k])/k);
}
```

### 个人心得总结

- **调试经历**：在实现 DP 时，初始状态的设置和边界条件的处理是关键，容易出错。
- **顿悟感想**：通过枚举 $k$ 并利用模数条件，可以将问题转化为经典的背包问题，思路清晰且易于实现。

---
处理用时：51.21秒
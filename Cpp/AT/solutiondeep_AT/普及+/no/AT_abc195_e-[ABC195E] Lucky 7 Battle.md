# 题目信息

# [ABC195E] Lucky 7 Battle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc195/tasks/abc195_e

`0`,$ \ldots $,`9` からなる長さ $ N $ の文字列 $ S $ と、`A`,`T` からなる長さ $ N $ の文字列 $ X $ が与えられます。また、空文字列で初期化された文字列 $ T $ があります。

高橋君と青木君がこれらを使ってゲームをします。ゲームは $ N $ ラウンドからなり、$ i $ 回目 $ (1\leq\ i\ \leq\ N) $ のラウンドでは次の操作が行われます。

- $ X_i $ が `A` なら青木君が、`T` なら高橋君が以下の操作を行う
- 操作：$ T $ の末尾に $ S_i $ か `0` のどちらか一方を加える

$ N $ 回の操作が終了したあと、$ T $ は `0`,$ \ldots $,`9` からなる長さ $ N $ の文字列となります。 $ T $ を (先頭の余計な $ 0 $ を取り除いた上で) $ 10 $ 進法で表された数と解釈したとき、$ 7 $ の倍数であれば高橋君の勝ちであり、そうでなければ青木君の勝ちです。

$ 2 $ 人が最適に行動する時、どちらが勝つか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ S,X $ の長さは $ N $
- $ S $ は `0`,$ \ldots $,`9` のみからなる
- $ X $ は `A`,`T` のみからなる

### Sample Explanation 1

$ 1 $ 回目のラウンドでは青木君が `3` か `0` を $ T $ の末尾に加え、$ 2 $ 回目のラウンドでは高橋君が `5` か `0` を $ T $ の末尾に加えます。 青木君が `3` を加えた場合、高橋君が `5` を追加すると $ T $ は `35` となり、これは $ 7 $ の倍数です。 青木君が `0` を加えた場合、高橋君が `0` を追加すると $ T $ は `00` となり、これは $ 7 $ の倍数です。 したがって、かならず高橋君が勝ちます。

## 样例 #1

### 输入

```
2

35

AT```

### 输出

```
Takahashi```

## 样例 #2

### 输入

```
5

12345

AAAAT```

### 输出

```
Aoki```

## 样例 #3

### 输入

```
5

67890

TTTTA```

### 输出

```
Takahashi```

## 样例 #4

### 输入

```
5

12345

ATATA```

### 输出

```
Aoki```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个由 `0` 到 `9` 组成的长度为 $N$ 的字符串 $S$，以及一个由 `A` 和 `T` 组成的长度为 $N$ 的字符串 $X$。初始时，字符串 $T$ 为空。

高桥君和青木君将进行 $N$ 轮游戏，第 $i$ 轮（$1 \leq i \leq N$）的操作如下：

- 如果 $X_i$ 是 `A`，则由青木君操作；如果是 `T`，则由高桥君操作。
- 操作：将 $S_i$ 或 `0` 添加到 $T$ 的末尾。

$N$ 轮操作结束后，$T$ 将成为一个由 `0` 到 `9` 组成的长度为 $N$ 的字符串。将 $T$ 视为一个十进制数（去掉前导零），如果它是 $7$ 的倍数，则高桥君获胜，否则青木君获胜。

请判断在两人都采取最优策略的情况下，谁会获胜。

### 算法分类

动态规划

### 题解分析与结论

该题的核心在于通过动态规划来模拟游戏的进行，并判断最终的胜负情况。由于游戏的每一轮操作都会影响最终的余数，因此可以通过倒序的动态规划来推导出每一轮的胜负情况。

#### 关键思路与技巧

1. **倒序动态规划**：从最后一轮开始，逐步推导出每一轮的胜负情况。这样可以避免正序推导时的复杂性和不确定性。
2. **余数状态转移**：每一轮的操作都会影响当前的余数，因此可以通过余数的状态转移来推导出下一轮的胜负情况。
3. **博弈论思想**：根据当前操作者的不同，采取不同的策略（`或` 或 `与`）来推导出当前的胜负情况。

#### 最优题解

1. **作者：olegekei (赞：9)**  
   **星级：5**  
   **关键亮点**：  
   - 清晰地解释了倒序动态规划的思路，并通过余数的状态转移来推导出每一轮的胜负情况。  
   - 代码简洁明了，逻辑清晰，易于理解。  
   **核心代码：**
   ```cpp
   bool f[200015][7];
   int N;
   string S,X;
   int main(){
       cin>>N>>S>>X;
       f[N+1][0]=1;
       for(int i=N;i>=1;i--){
           for(int j=0;j<7;j++){
               bool x=f[i+1][10*j%7],y=f[i+1][(10*j+S[i-1]-48)%7];
               if(X[i-1]=='A')f[i][j]=x&y;
               else f[i][j]=x|y;
           }
       }
       cout<<(f[1][0]?"Takahashi":"Aoki");
       return 0;
   }
   ```

2. **作者：max666dong123 (赞：5)**  
   **星级：4**  
   **关键亮点**：  
   - 通过定义状态转移方程，清晰地描述了每一轮的胜负推导过程。  
   - 代码结构清晰，逻辑严谨，易于理解。  
   **核心代码：**
   ```cpp
   bool f[N][10];
   int n;
   string s,t;
   signed main(){
       cin>>n; 
       cin>>s;
       cin>>t;
       f[n][0]=1;
       for(int i=n;i>=1;i--){
           for(int j=0;j<7;j++){
               bool x=f[i][(j*10+s[i-1]-'0')%7];
               bool y=f[i][(j*10)%7];
               if(t[i-1]=='T'){
                   f[i-1][j]=x|y; 
               }else{
                   f[i-1][j]=x&y; 
               }
           }
       }
       cout<<(f[0][0]==1?"Takahashi\n":"Aoki\n");
       return 0;
   }
   ```

3. **作者：Barryb (赞：3)**  
   **星级：4**  
   **关键亮点**：  
   - 通过倒序动态规划，清晰地描述了每一轮的胜负推导过程。  
   - 代码简洁，逻辑清晰，易于理解。  
   **核心代码：**
   ```cpp
   int dp[200010][10];
   int n;
   string s,x;
   int main(){
       cin>>n>>s>>x;dp[n][0]=1;
       for(int i=n;i;i--) {
           for(int j=0;j<=6;j++) {
               int a=dp[i][(j*10+s[i-1]-'0'+7)%7];
               int b=dp[i][j*10%7];
               dp[i-1][j%7]=(x[i-1]=='T'?(a||b):(a&&b));
           }
       }
       if(dp[0][0]==1) cout<<"Takahashi";
       else cout<<"Aoki";
       return 0;
   }
   ```

### 可拓展之处

该题的动态规划思路可以应用于类似的博弈论问题，特别是涉及到状态转移和最优策略的问题。例如，类似的题目可以考察在不同的规则下，如何通过动态规划来推导出最终的胜负情况。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)  
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)  
3. [P1077 摆花](https://www.luogu.com.cn/problem/P1077)

---
处理用时：40.23秒
# 题目信息

# [ABC197E] Traveler

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc197/tasks/abc197_e

数直線上にボール $ 1 $ からボール $ N $ までの $ N $ 個のボールがあります。  
 ボール $ i $ は座標 $ X_i $ にあります。  
 各ボールには $ 1 $ 以上 $ N $ 以下の整数で表される色がついていて、ボール $ i $ の色は整数 $ C_i $ で表されます。  
 今座標 $ 0 $ にいるあなたは、毎秒 $ 1 $ の速さで数直線上を動き、全てのボールを回収してから再び座標 $ 0 $ に戻ります。  
 このとき、ボールの色を表す整数を回収順に並べた時に広義単調増加となっている必要があります。  
 ボールを回収するにはボールと同じ座標にいる必要がありますが、ボールを回収できる時に必ずしも回収する必要はありません。  
 座標 $ 0 $ を出発してから、全てのボールを回収して再び座標 $ 0 $ に戻るまでにかかる時間の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ |X_i|\ \le\ 10^9 $
- $ X_i\ \neq\ X_j\ (i\ \neq\ j) $
- $ X_i\ \neq\ 0 $
- $ 1\ \le\ C_i\ \le\ N $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

以下のように行動するのが最適です。 - $ 3 $ 秒かけて座標 $ 3 $ に移動し、ボール $ 2 $ を回収する - $ 1 $ 秒かけて座標 $ 2 $ に移動し、ボール $ 1 $ を回収する - $ 2 $ 秒かけて座標 $ 4 $ に移動し、ボール $ 4 $ を回収する - $ 1 $ 秒かけて座標 $ 5 $ に移動し、ボール $ 5 $ を回収する - $ 4 $ 秒かけて座標 $ 1 $ に移動し、ボール $ 3 $ を回収する - $ 1 $ 秒かけて座標 $ 0 $ に戻る ボールの色を表す整数を回収順に並べると $ 1,\ 2,\ 2,\ 3,\ 3 $ と広義単調増加になっています。

## 样例 #1

### 输入

```
5

2 2

3 1

1 3

4 2

5 3```

### 输出

```
12```

## 样例 #2

### 输入

```
9

5 5

-4 4

4 3

6 3

-5 5

-3 2

2 2

3 3

1 4```

### 输出

```
38```

# AI分析结果

### 题目内容重写

数直线上有从球 $1$ 到球 $N$ 的 $N$ 个球。  
球 $i$ 位于坐标 $X_i$ 处。  
每个球都有一个颜色，用 $1$ 到 $N$ 之间的整数表示，球 $i$ 的颜色为 $C_i$。  
现在你位于坐标 $0$ 处，每秒以 $1$ 的速度在数直线上移动，收集所有球后再返回坐标 $0$。  
收集球的顺序必须满足颜色的单调不减性。  
收集球时需要位于球的坐标处，但不一定要在到达时立即收集。  
求从坐标 $0$ 出发，收集所有球并返回坐标 $0$ 所需的最小时间。

### 算法分类
动态规划

### 综合分析与结论
本题的核心是通过动态规划来优化路径选择，确保在收集球的过程中满足颜色的单调不减性。各题解均采用了类似的思路，即通过记录每种颜色的最左和最右端点，利用动态规划来计算最小时间。不同题解在实现细节上有所差异，但整体思路一致。

### 所选高分题解

#### 题解1：作者：Lcm_simida
- **星级**：4
- **关键亮点**：通过将问题转化为区间覆盖问题，简化了动态规划的状态转移。代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  for(long long i=2;i<=num;i++){
      dp[i][0]=min(dp[i-1][0]+abs(a[i-1].l-a[i].r)+abs(a[i].r-a[i].l),dp[i-1][1]+abs(a[i-1].r-a[i].r)+abs(a[i].r-a[i].l));
      dp[i][1]=min(dp[i-1][0]+abs(a[i-1].l-a[i].l)+abs(a[i].l-a[i].r),dp[i-1][1]+abs(a[i-1].r-a[i].l)+abs(a[i].l-a[i].r));
  }
  ```
  **实现思想**：通过比较前一个区间的左端点和右端点与当前区间的左端点和右端点的距离，选择最小路径进行转移。

#### 题解2：作者：Leaper_lyc
- **星级**：4
- **关键亮点**：详细分析了状态转移方程，并考虑了颜色可能不存在的情况，代码结构清晰，注释详细。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      if(!fl[i]){ // 懒得写什么 last 于是直接往后抄一遍（逃
          f[i][0] = f[i - 1][0], f[i][1] = f[i - 1][1];
          l[i] = l[i - 1], r[i] = r[i - 1];
          continue;
      }
      f[i][0] = min(f[i - 1][0] + abs(r[i - 1] - l[i]), f[i - 1][1] + abs(l[i - 1] - l[i])) + r[i] - l[i];
      f[i][1] = min(f[i - 1][0] + abs(r[i - 1] - r[i]), f[i - 1][1] + abs(l[i - 1] - r[i])) + r[i] - l[i];
  }
  ```
  **实现思想**：通过记录每种颜色的最左和最右端点，利用动态规划计算最小时间，并考虑了颜色不存在的情况。

#### 题解3：作者：gxp123
- **星级**：4
- **关键亮点**：通过记录每种颜色的最左和最右端点，简化了动态规划的状态转移，代码简洁，思路清晰。
- **核心代码**：
  ```cpp
  for(int i = 1 ; i <= n ; ++i){
      if(!xx[i][2])   continue;
      f[i][0] = min(abs(xx[i][1] - xx[l][0]) + f[l][0],
              abs(xx[i][1] - xx[l][1]) + f[l][1]) + xx[i][1] - xx[i][0];
      f[i][1] = min(abs(xx[i][0] - xx[l][0]) + f[l][0],
              abs(xx[i][0] - xx[l][1]) + f[l][1]) + xx[i][1] - xx[i][0];
      l = i;
  }
  ```
  **实现思想**：通过比较前一个颜色的左端点和右端点与当前颜色的左端点和右端点的距离，选择最小路径进行转移。

### 最优关键思路
通过记录每种颜色的最左和最右端点，利用动态规划来计算最小时间。状态转移时，比较前一个区间的左端点和右端点与当前区间的左端点和右端点的距离，选择最小路径进行转移。

### 拓展思路
类似的问题可以扩展到多维空间或更复杂的路径规划中，动态规划的思路依然适用。可以通过增加状态维度来适应更复杂的情况。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：40.44秒
# 题目信息

# [ABC199E] Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc199/tasks/abc199_e

$ (1,\ 2,\ 3,\ \dots,\ N) $ を並び替えてできる数列 $ a $ であって、以下の条件を満たすものの数を出力してください。

- $ 1\ \le\ i\ \le\ M $ を満たす全ての整数 $ i $ について、$ a_1,\ a_2,\ a_3,\ \dots,\ a_{X_i} $ の中に $ Y_i $ 以下の数は $ Z_i $ 個以下しか存在しない

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 18 $
- $ 0\ \le\ M\ \le\ 100 $
- $ 1\ \le\ X_i\ \lt\ N $
- $ 1\ \le\ Y_i\ \lt\ N $
- $ 0\ \le\ Z_i\ \lt\ N $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

条件を満たす $ a $ は以下の $ 4 $ つです。 - $ (1,\ 3,\ 2) $ - $ (2,\ 3,\ 1) $ - $ (3,\ 1,\ 2) $ - $ (3,\ 2,\ 1) $ $ (1,\ 2,\ 3) $ や $ (2,\ 1,\ 3) $ は、$ a_1,\ a_2 $ の中に $ 2 $ 以下の数が $ 2 $ つあるため条件を満たしません。

## 样例 #1

### 输入

```
3 1

2 2 1```

### 输出

```
4```

## 样例 #2

### 输入

```
5 2

3 3 2

4 4 3```

### 输出

```
90```

## 样例 #3

### 输入

```
18 0```

### 输出

```
6402373705728000```

# AI分析结果

### 题目翻译
【题目内容】
# [ABC199E] Permutation

## 题目描述

将 $ (1,\ 2,\ 3,\ \dots,\ N) $ 进行排列，得到数列 $ a $，要求满足以下条件：

- 对于所有满足 $ 1\ \le\ i\ \le\ M $ 的整数 $ i $，$ a_1,\ a_2,\ a_3,\ \dots,\ a_{X_i} $ 中 $ Y_i $ 以下的数不超过 $ Z_i $ 个。

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 18 $
- $ 0\ \le\ M\ \le\ 100 $
- $ 1\ \le\ X_i\ \lt\ N $
- $ 1\ \le\ Y_i\ \lt\ N $
- $ 0\ \le\ Z_i\ \lt\ N $
- 输入中的所有值均为整数

### 样例解释 1

满足条件的 $ a $ 有以下 $ 4 $ 个：
- $ (1,\ 3,\ 2) $
- $ (2,\ 3,\ 1) $
- $ (3,\ 1,\ 2) $
- $ (3,\ 2,\ 1) $

$ (1,\ 2,\ 3) $ 和 $ (2,\ 1,\ 3) $ 不满足条件，因为 $ a_1,\ a_2 $ 中 $ 2 $ 以下的数有 $ 2 $ 个。

## 样例 #1

### 输入

```
3 1

2 2 1```

### 输出

```
4```

## 样例 #2

### 输入

```
5 2

3 3 2

4 4 3```

### 输出

```
90```

## 样例 #3

### 输入

```
18 0```

### 输出

```
6402373705728000```

### 算法分类
动态规划

### 题解分析与结论
本题的核心是通过动态规划（状压DP）来解决排列问题，并满足给定的限制条件。所有题解都采用了状压DP的思路，但在具体实现和优化上有所不同。

### 所选高星题解
1. **作者：lfxxx (4星)**
   - **关键亮点**：使用状态压缩DP，设计状态 $dp_{i,j}$ 表示考虑 $i$ 个数，每个数的使用情况的二进制压缩表示为 $j$ 的情况下的方案数。通过 `check` 函数在转移时检查是否满足限制条件。
   - **代码核心**：
     ```cpp
     void check(int i,int j){
         for(pair<int,int> now:imp[i+1]){
             int cnt=0;
             for(int pos=0;pos<n;pos++){
                 if(j&(1<<pos)){
                     if((pos+1)<=now.first) cnt++;
                 }
             }
             if(cnt>now.second){
                 dp[i][j]=0;    
             } 
         }
     }
     ```

2. **作者：Zirnc (4星)**
   - **关键亮点**：使用记忆化搜索和递推两种方式实现状压DP，通过 `check` 函数在转移时检查是否满足限制条件。代码简洁且高效。
   - **代码核心**：
     ```cpp
     bool check(int S) {
         int pct = __builtin_popcount(S);
         for (int i = 0; i < v[pct].size(); i++) {
             int cnt = 0;
             for (int j = 1; j <= n; j++)
                 if (S&(1<<(j-1)))
                     if (j <= v[pct][i].y) cnt++;
             if (cnt > v[pct][i].z) return false;
         }
         return true;
     }
     ```

3. **作者：mi_Y13c (4星)**
   - **关键亮点**：使用状压DP，通过 `pcnt` 函数计算二进制中 $1$ 的个数，并在转移时检查是否满足限制条件。代码简洁且高效。
   - **代码核心**：
     ```cpp
     rep(s, n2) {
         int x = pcnt(s);
         for (auto& [y, z] : ps[x]) {
             if (pcnt(s&mask[y]) > z) dp[s] = 0;
         }
         rep(j, n) if (~s>>j&1) {
             dp[s|1<<j] += dp[s];
         }
     }
     ```

### 最优关键思路或技巧
- **状压DP**：利用二进制位表示状态，通过位运算高效地进行状态转移。
- **限制条件检查**：在状态转移时，通过 `check` 函数或类似方法检查当前状态是否满足所有限制条件，确保方案的合法性。

### 可拓展之处
- **类似问题**：可以扩展到其他排列组合问题，如带有更多限制条件的排列问题或组合优化问题。
- **算法优化**：可以通过预处理或剪枝进一步优化状态转移的效率。

### 推荐题目
1. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
2. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)
3. [P1879 [USACO06NOV]Corn Fields G](https://www.luogu.com.cn/problem/P1879)

---
处理用时：35.34秒
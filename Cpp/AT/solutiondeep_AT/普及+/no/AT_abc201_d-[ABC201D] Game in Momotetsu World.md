# 题目信息

# [ABC201D] Game in Momotetsu World

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc201/tasks/abc201_d

$ H $ 行 $ W $ 列のマス目があり、各マスは青マスまたは赤マスのどちらかです。上から $ i $ 番目、左から $ j $ 番目のマスは、$ A_{i,\ j} $ が `+` なら青マスであり、`-` なら赤マスです。  
 最初、このマス目の一番左上のマスに一つ駒が置かれていて、高橋君と青木君はこの駒を使ってゲームをします。  
 $ 2 $ 人の得点は最初 $ 0 $ 点ずつです。$ 2 $ 人は、高橋君から始めて交互に次の操作をします。

- 駒を一つ右または一つ下のマスに動かす。ただし、駒がマス目の外に出るような動かし方はできない。動かした人は、駒の移動後のマスが青マスなら $ 1 $ 点を得て、赤マスなら $ 1 $ 点を失う。

どちらかが操作できなくなった時点でゲームは終了します。ゲームの結果は、終了時の $ 2 $ 人の得点が異なるならば得点の大きい方が勝ち、同じならば引き分けとなります。  
 両者とも自分の勝敗が最適になるように行動したとき、ゲームの結果を求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ H,\ W\ \le\ 2000 $
- $ A_{i,\ j} $ は `+` または `-`

### Sample Explanation 1

高橋君は以下のような戦略で勝つことができます。 まず高橋君が最初に駒を右に動かします。移動先のマスは赤マスなので高橋君は $ 1 $ 点を失い、高橋君と青木君の得点はそれぞれ $ -1,\ 0 $ となります。 - 青木君が次に駒を右に動かしたなら、高橋君は駒を下に動かします - 青木君が次に駒を下に動かしたなら、高橋君は駒を右に動かします いずれの場合でも青木君は赤マスに駒を動かして $ 1 $ 点を失い、高橋君は青マスに駒を動かして $ 1 $ 点を得るため、両者の得点はそれぞれ $ 0,\ -1 $ となります。 現在駒はマス目の上から $ 2 $ 番目、左から $ 3 $ 番目のマスにあるので、次の移動では青木君は下に動かすほかなく、移動先が赤マスなので両者の得点はそれぞれ $ 0,\ -2 $ となります。 もう駒は右にも下にも動かせないのでゲームは終了し、得点の大きい高橋君が勝利します。

### Sample Explanation 2

青木君は、高橋君がどのように操作しても、上手く操作すれば勝つことができます。

### Sample Explanation 3

この場合ゲームは直ちに終了し、両者得点 $ 0 $ であるため結果は引き分けとなります。

## 样例 #1

### 输入

```
3 3

---

+-+

+--```

### 输出

```
Takahashi```

## 样例 #2

### 输入

```
2 4

+++-

-+-+```

### 输出

```
Aoki```

## 样例 #3

### 输入

```
1 1

-```

### 输出

```
Draw```

# AI分析结果

### 题目内容重写
# [ABC201D] Game in Momotetsu World

## 题目描述

有一个 $H$ 行 $W$ 列的网格，每个格子是蓝色或红色。从上到下第 $i$ 行、从左到右第 $j$ 列的格子，如果 $A_{i,j}$ 是 `+`，则为蓝色；如果是 `-`，则为红色。  
最初，棋子在网格的左上角，高桥君和青木君将使用这个棋子进行游戏。  
两人的初始得分均为 $0$ 分。高桥君先手，两人轮流执行以下操作：

- 将棋子向右或向下移动一格。棋子不能移出网格。移动后，如果棋子所在的格子是蓝色，则移动者得 $1$ 分；如果是红色，则移动者扣 $1$ 分。

当棋子无法移动时，游戏结束。如果两人的得分不同，得分高者获胜；如果得分相同，则为平局。  
假设两人都采取最优策略，求游戏的结果。

### 说明/提示

#### 制約

- $1 \le H, W \le 2000$
- $A_{i,j}$ 是 `+` 或 `-`

### 样例 #1

#### 输入

```
3 3

---

+-+

+--```

#### 输出

```
Takahashi```

### 样例 #2

#### 输入

```
2 4

+++-

-+-+```

#### 输出

```
Aoki```

### 样例 #3

#### 输入

```
1 1

-```

#### 输出

```
Draw```

---

### 算法分类
动态规划

---

### 题解分析与结论
本题的核心是博弈论中的动态规划问题，通过倒序计算每个格子的最优得分差，最终判断先手是否能够获胜。各题解均采用了类似的思路，但在实现细节上有所不同。

---

### 精选题解

#### 1. 作者：Jessica2333 (赞：6)
**星级：5星**
**关键亮点：**
- 清晰的思路和状态转移方程。
- 代码简洁易读，初始化处理得当。
- 通过倒序遍历避免了后效性问题。

**核心代码：**
```cpp
for(int i=H-1;i>=1;i--)
    dp[i][W]=mmp[i-1][W]-dp[i+1][W];
for(int i=W-1;i>=1;i--)
    dp[H][i]=mmp[H][i-1]-dp[H][i+1];
for(int i=H-1;i>=1;i--)
    for(int j=W-1;j>=1;j--)
        dp[i][j]=max(mmp[i+1][j]-dp[i+1][j],mmp[i][j+1]-dp[i][j+1]);
```

#### 2. 作者：_Ponder_ (赞：4)
**星级：4星**
**关键亮点：**
- 使用记忆化搜索实现动态规划，避免了复杂的边界处理。
- 通过奇偶性判断当前操作者，简化了状态转移。

**核心代码：**
```cpp
int dfs(int x,int y){
    if(x==n&&y==m) return 0;
    if(dp[x][y]) return dp[x][y];
    if((x+y-1)%2==1){
        dp[x][y]=-inf;
        if(x!=n) dp[x][y]=max(dp[x][y],dfs(x+1,y)+a[x+1][y]);
        if(y!=m) dp[x][y]=max(dp[x][y],dfs(x,y+1)+a[x][y+1]);
        return dp[x][y];
    }
    else{
        dp[x][y]=inf;
        if(x!=n) dp[x][y]=min(dp[x][y],dfs(x+1,y)-a[x+1][y]);
        if(y!=m) dp[x][y]=min(dp[x][y],dfs(x,y+1)-a[x][y+1]);
        return dp[x][y];
    }
}
```

#### 3. 作者：cosf (赞：0)
**星级：4星**
**关键亮点：**
- 简洁的状态转移方程，直接计算得分差。
- 边界处理清晰，代码逻辑简单。

**核心代码：**
```cpp
for(int i=n;i>=1;i--){
    for(int j=m;j>=1;j--){
        if(i==n && j==m) continue;
        else if(i==n) dp[i][j]=get(mp[i][j+1])-dp[i][j+1];
        else if(j==m) dp[i][j]=get(mp[i+1][j])-dp[i+1][j];
        else dp[i][j]=max(get(mp[i][j+1])-dp[i][j+1],get(mp[i+1][j])-dp[i+1][j]);
    }
}
```

---

### 最优关键思路与技巧
1. **倒序动态规划**：从终点开始倒序计算每个格子的最优得分差，避免了正序遍历的后效性问题。
2. **状态转移方程**：通过当前操作者的角色（先手或后手）来决定是取最大值还是最小值。
3. **边界处理**：终点格子的得分差为 $0$，其他边界格子只能从单方向转移。

---

### 拓展思路
类似的问题可以扩展到更复杂的棋盘游戏或博弈论问题，例如多步决策、不同移动规则等。可以尝试使用类似的动态规划或记忆化搜索方法解决。

---

### 推荐题目
1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1280 尼克的任务](https://www.luogu.com.cn/problem/P1280)

---

### 个人心得摘录
- **Jessica2333**：在模拟赛中想到了这个思路，实际实现时发现倒序遍历是关键。
- **_Ponder_**：使用记忆化搜索避免了复杂的边界处理，代码更加简洁。
- **cosf**：直接计算得分差，逻辑简单清晰，适合快速实现。

---
处理用时：40.44秒
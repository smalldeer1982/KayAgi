# 题目信息

# [ABC201E] Xor Distances

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc201/tasks/abc201_e

$ N $ 頂点の重み付き木があります。$ i $ 本目の辺は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結んでいて、その重みは $ w_i $ です。

頂点の組 $ (x,y) $ について、$ \text{dist}(x,y) $ を以下のように定めます。

- $ x $ から $ y $ への最短パスに含まれる辺全ての重みの **XOR**

$ 1\ \leq\ i\ \lt\ j\ \leq\ N $ を満たす全ての組 $ (i,j) $ について $ \text{dist}(i,j) $ を求め、その総和を $ (10^9+7) $ で割った余りを出力してください。

 $ \text{\ XOR\ } $ とは 整数 $ a,\ b $ のビットごとの排他的論理和 $ a\ \text{\ XOR\ }\ b $ は、以下のように定義されます。

- $ a\ \text{\ XOR\ }\ b $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ a,\ b $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \text{\ XOR\ }\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \text{\ XOR\ }\ 101\ =\ 110 $)。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i\ \lt\ v_i\ \leq\ N $
- $ 0\ \leq\ w_i\ \lt\ 2^{60} $
- 与えられるグラフは木
- 入力は全て整数

### Sample Explanation 1

$ \text{dist}(1,2)=1, $ $ \text{dist}(1,3)=3, $ $ \text{dist}(2,3)=2 $ であり、これらの総和は $ 6 $ です。

### Sample Explanation 3

$ (10^9+7) $ で割った余りを出力してください。

## 样例 #1

### 输入

```
3

1 2 1

1 3 3```

### 输出

```
6```

## 样例 #2

### 输入

```
5

3 5 2

2 3 2

1 5 1

4 5 13```

### 输出

```
62```

## 样例 #3

### 输入

```
10

5 7 459221860242673109

6 8 248001948488076933

3 5 371922579800289138

2 5 773108338386747788

6 10 181747352791505823

1 3 803225386673329326

7 8 139939802736535485

9 10 657980865814127926

2 4 146378247587539124```

### 输出

```
241240228```

# AI分析结果

### 题目内容重写

#### [ABC201E] Xor Distances

**题目描述**

给定一棵包含 $N$ 个顶点的带权树。第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$，边权为 $w_i$。

对于顶点对 $(x, y)$，定义 $\text{dist}(x, y)$ 为从 $x$ 到 $y$ 的最短路径上所有边权的 **异或和**。

请计算所有满足 $1 \leq i < j \leq N$ 的顶点对 $(i, j)$ 的 $\text{dist}(i, j)$ 之和，并将结果对 $10^9+7$ 取模后输出。

**说明/提示**

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq u_i < v_i \leq N$
- $0 \leq w_i < 2^{60}$
- 给定的图是一棵树
- 输入均为整数

**样例解释**

- 样例1：$\text{dist}(1,2)=1$, $\text{dist}(1,3)=3$, $\text{dist}(2,3)=2$，总和为 $6$。
- 样例3：输出结果需要对 $10^9+7$ 取模。

### 算法分类

**位运算、深度优先搜索 (DFS)、图论**

### 题解分析与结论

该题的核心在于利用树的性质和异或运算的特性，将问题转化为对每个二进制位的贡献计算。通过 DFS 预处理每个节点到根节点的异或和，然后对每个二进制位统计其贡献，最终将所有位的贡献相加得到结果。

### 精选题解

#### 题解1：allqpsi (赞：6)

**星级：5星**

**关键亮点：**
- 利用树的性质，将问题转化为对每个二进制位的贡献计算。
- 通过 DFS 预处理每个节点到根节点的异或和。
- 对每个二进制位统计其贡献，最终将所有位的贡献相加。

**核心代码：**
```cpp
void dfs(int x,int fa){
    for(int i=0;i<vi[x].size();i++){
        int v=vi[x][i].x,w=vi[x][i].y;
        if(v==fa) continue;
        di[v]=di[x]^w;
        dfs(v,x);
    }
}
```
**实现思想：**
通过 DFS 遍历树，计算每个节点到根节点的异或和。

#### 题解2：_Ponder_ (赞：5)

**星级：4星**

**关键亮点：**
- 详细证明了异或运算的性质，并利用树的性质将问题转化为对每个二进制位的贡献计算。
- 通过 DFS 预处理每个节点到根节点的异或和，然后对每个二进制位统计其贡献。

**核心代码：**
```cpp
void dfs(int s,int fa){
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(v==fa) continue;
        dis[v]=dis[s]^w[i];
        dfs(v,s);
    }
}
```
**实现思想：**
通过 DFS 遍历树，计算每个节点到根节点的异或和。

#### 题解3：Ginger_he (赞：4)

**星级：4星**

**关键亮点：**
- 利用树的性质，将问题转化为对每个二进制位的贡献计算。
- 通过 DFS 预处理每个节点到根节点的异或和，然后对每个二进制位统计其贡献。

**核心代码：**
```cpp
void dfs(int x,int fa){
    for(auto i:g[x]){
        if(i.v==fa) continue;
        dis[i.v]=dis[x]^i.w;
        dfs(i.v,x); 
    }
}
```
**实现思想：**
通过 DFS 遍历树，计算每个节点到根节点的异或和。

### 最优关键思路

1. **树的性质与异或运算的结合**：利用树的性质，将问题转化为对每个二进制位的贡献计算。
2. **DFS 预处理**：通过 DFS 预处理每个节点到根节点的异或和。
3. **二进制位贡献统计**：对每个二进制位统计其贡献，最终将所有位的贡献相加。

### 拓展思路

类似的问题可以考察树的性质与位运算的结合，例如计算树上路径的与、或等运算的和。还可以扩展到图论中的最短路径问题，结合位运算进行优化。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P2420 让我们异或吧](https://www.luogu.com.cn/problem/P2420)
3. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)

---
处理用时：35.92秒
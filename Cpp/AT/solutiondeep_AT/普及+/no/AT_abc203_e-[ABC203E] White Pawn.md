# 题目信息

# [ABC203E] White Pawn

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc203/tasks/abc203_e

$ N $ を正の整数とします。 行と列にそれぞれ $ 0 $ から $ 2N $ までの番号が付いた $ (2N+1)\times\ (2N+1) $ のマス目があり、行 $ i $ かつ列 $ j $ に属するマスを $ (i,j) $ で表します。

白のポーンが $ 1 $ つあり、最初 $ (0,N) $ に置かれています。 黒のポーンは $ M $ 個あり、$ i $ 個目の黒のポーンは $ (X_i,\ Y_i) $ に置かれています。

白のポーンが $ (i,j) $ にあるとき、あなたは以下のいずれかの操作で白のポーンを動かすことができます。

- $ 0\leq\ i\leq\ 2N-1 $, $ 0\ \leq\ j\leq\ 2N $ を満たし、$ (i+1,j) $ に黒のポーンが**無い**ならば、白のポーンを $ (i+1,j) $ に動かす。
- $ 0\leq\ i\leq\ 2N-1 $, $ 0\ \leq\ j\leq\ 2N-1 $ を満たし、$ (i+1,j+1) $ に黒のポーンが**有る**ならば、白のポーンを $ (i+1,j+1) $ に動かす。
- $ 0\leq\ i\leq\ 2N-1 $, $ 1\ \leq\ j\leq\ 2N $ を満たし、$ (i+1,j-1) $ に黒のポーンが**有る**ならば、白のポーンを $ (i+1,j-1) $ に動かす。

黒のポーンは動かすことができません。

この操作を繰り返した結果、$ (2N,Y) $ に白のポーンが置かれている状態にできるような $ Y $ の値としてあり得るものの個数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^9 $
- $ 0\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ X_i\ \leq\ 2N $
- $ 0\ \leq\ Y_i\ \leq\ 2N $
- $ (X_i,\ Y_i)\ \neq\ (X_j,\ Y_j) $ $ (i\ \neq\ j) $
- 入力は全て整数である。

### Sample Explanation 1

$ (4,0) $, $ (4,1) $, $ (4,2) $ の $ 3 $ つへはそれぞれ次のように動かせます: - $ (0,2)\to\ (1,1)\to\ (2,1)\to\ (3,1)\to\ (4,2) $ - $ (0,2)\to\ (1,1)\to\ (2,1)\to\ (3,1)\to\ (4,1) $ - $ (0,2)\to\ (1,1)\to\ (2,0)\to\ (3,0)\to\ (4,0) $ 一方、 $ (4,3) $ と $ (4,4) $ へは動かすことができません。 よって、 $ 3 $ を出力します。

### Sample Explanation 2

白のポーンを $ (0,1) $ から動かすことはできません。

## 样例 #1

### 输入

```
2 4

1 1

1 2

2 0

4 2```

### 输出

```
3```

## 样例 #2

### 输入

```
1 1

1 1```

### 输出

```
0```

# AI分析结果

### 题目内容重写
【题目描述】
$ N $ 是一个正整数。有一个 $ (2N+1) \times (2N+1) $ 的棋盘，行和列的编号从 $ 0 $ 到 $ 2N $。棋盘上的每个格子用 $ (i, j) $ 表示，其中 $ i $ 是行号，$ j $ 是列号。

棋盘上有一个白棋，初始位置在 $ (0, N) $。还有 $ M $ 个黑棋，第 $ i $ 个黑棋的位置是 $ (X_i, Y_i) $。

白棋在 $ (i, j) $ 时，可以进行以下操作之一：
1. 如果 $ (i+1, j) $ 没有黑棋，且 $ 0 \leq i \leq 2N-1 $ 且 $ 0 \leq j \leq 2N $，则可以将白棋移动到 $ (i+1, j) $。
2. 如果 $ (i+1, j-1) $ 有黑棋，且 $ 0 \leq i \leq 2N-1 $ 且 $ 1 \leq j \leq 2N $，则可以将白棋移动到 $ (i+1, j-1) $。
3. 如果 $ (i+1, j+1) $ 有黑棋，且 $ 0 \leq i \leq 2N-1 $ 且 $ 0 \leq j \leq 2N-1 $，则可以将白棋移动到 $ (i+1, j+1) $。

黑棋不能移动。求白棋最终可以到达 $ (2N, Y) $ 的所有可能的 $ Y $ 值的个数。

### 算法分类
模拟

### 题解分析与结论
本题的核心是通过模拟白棋的移动过程，最终统计白棋可以到达的终点位置。由于 $ N $ 的范围很大（$ 1 \leq N \leq 10^9 $），直接模拟每一行的移动是不现实的。因此，题解普遍采用了只处理有黑棋的行，并通过 `set` 来维护白棋当前可以到达的位置。

### 所选高星题解
#### 1. 作者：Louis_lxy (5星)
**关键亮点：**
- 使用 `map` 存储每一行的黑棋位置，`set` 维护当前可到达的位置。
- 通过 `pop` 和 `push` 两个临时数组，分别记录需要删除和添加的位置，避免在遍历过程中直接修改 `set`。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
set<int> can;
can.insert(n);
for (auto i : a)
{
    vector<int> pop, push;
    for (int j : i.second)
        if (can.count(j))
            pop.push_back(j);
    for (int j : i.second)
        if (can.count(j - 1) || can.count(j + 1))
            push.push_back(j);
    for (int j : pop) can.erase(j);
    for (int j : push) can.insert(j);
}
printf("%d", can.size());
```

#### 2. 作者：kanglr1013 (4星)
**关键亮点：**
- 强调了 $ N $ 的范围，指出直接模拟不可行，提出了只处理有黑棋的行。
- 使用 `map` 套 `vector` 存储黑棋位置，`set` 维护可到达的位置。
- 时间复杂度分析清晰，代码实现简洁。

**核心代码：**
```cpp
set<int> can;
can.insert(n);
for (auto i : a)
{
    vector<int> pop, push;
    for (int j : i.second)
        if (can.count(j))
            pop.push_back(j);
    for (int j : i.second)
        if (can.count(j - 1) || can.count(j + 1))
            push.push_back(j);
    for (int j : pop) can.erase(j);
    for (int j : push) can.insert(j);
}
printf("%d", can.size());
```

#### 3. 作者：theb0t (4星)
**关键亮点：**
- 使用 `map` 存储黑棋位置，`set` 维护可到达的位置。
- 通过 `in` 和 `out` 两个临时数组，分别记录需要添加和删除的位置，避免在遍历过程中直接修改 `set`。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
set<int> Set;
Set.insert(n);
for (auto i : Map)
{
    vector<int> in, out;
    for (int j : i.second)
    {
        if (Set.count(j)) out.push_back(j);
        if (Set.count(j - 1) || Set.count(j + 1)) in.push_back(j);
    }
    for (int j : out) Set.erase(j);
    for (int j : in) Set.insert(j);
}
printf("%d", Set.size());
```

### 最优关键思路与技巧
1. **只处理有黑棋的行**：由于 $ N $ 的范围很大，直接模拟每一行不可行，因此只处理有黑棋的行，大大减少了计算量。
2. **使用 `set` 维护可到达的位置**：`set` 可以高效地插入、删除和查询元素，适合用来维护白棋当前可以到达的位置。
3. **避免在遍历过程中直接修改 `set`**：通过临时数组记录需要删除和添加的位置，最后统一处理，避免了在遍历过程中直接修改 `set` 导致的错误。

### 可拓展之处
本题的思路可以拓展到其他类似的棋盘模拟问题，尤其是在棋盘规模较大但关键点较少的情况下，通过只处理关键点来优化计算。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)

### 个人心得摘录
- **Louis_lxy**：提到本题难度不高，主要是技巧优化模拟，强调了处理整层后再进行删除和添加操作的重要性。
- **kanglr1013**：强调了 $ N $ 的范围，指出直接模拟不可行，提出了只处理有黑棋的行，并通过 `map` 和 `set` 来优化计算。

---
处理用时：40.65秒
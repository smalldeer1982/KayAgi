# 题目信息

# [ABC207E] Mod i

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc207/tasks/abc207_e

長さ $ N $ の数列 $ A $ が与えられます。$ A $ をいくつかの連続した空でない部分列 $ B_1,B_2,\ldots,B_k $ に切り分ける方法であって、以下の条件を満たすものの個数を求めてください。

- 全ての $ i\ (1\ \leq\ i\ \leq\ k) $ について、$ B_i $ に含まれる要素の総和が $ i $ で割り切れる。

答えは非常に大きくなることがあるので、$ (10^9+7) $ で割ったあまりを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3000 $
- $ 1\ \leq\ A_i\ \leq\ 10^{15} $
- 入力は全て整数

### Sample Explanation 1

以下の $ 3 $ 通りの切り分け方があります。 - $ (1),(2),(3),(4) $ - $ (1,2,3),(4) $ - $ (1,2,3,4) $

### Sample Explanation 3

入力が $ 32 $ bit 整数型に収まりきらない場合があります。

## 样例 #1

### 输入

```
4

1 2 3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5

8 6 3 3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
10

791754273866483 706434917156797 714489398264550 918142301070506 559125109706263 694445720452148 648739025948445 869006293795825 718343486637033 934236559762733```

### 输出

```
15```

# AI分析结果

【题目内容】
# [ABC207E] Mod i

## 题目描述

给定一个长度为 $N$ 的数列 $A$，要求将 $A$ 分成若干个连续的非空子序列 $B_1,B_2,\ldots,B_k$，满足以下条件：

- 对于所有的 $i\ (1\ \leq\ i\ \leq\ k)$，$B_i$ 中所有元素的总和能够被 $i$ 整除。

求满足条件的分割方案数。由于答案可能非常大，输出对 $10^9+7$ 取模的结果。

## 说明/提示

### 制約

- $1\ \leq\ N\ \leq\ 3000$
- $1\ \leq\ A_i\ \leq\ 10^{15}$
- 输入均为整数

### 样例解释 1

以下 $3$ 种分割方案满足条件：
- $ (1),(2),(3),(4) $
- $ (1,2,3),(4) $
- $ (1,2,3,4) $

### 样例解释 3

输入可能超出 $32$ 位整数范围。

## 样例 #1

### 输入

```
4

1 2 3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5

8 6 3 3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
10

791754273866483 706434917156797 714489398264550 918142301070506 559125109706263 694445720452148 648739025948445 869006293795825 718343486637033 934236559762733```

### 输出

```
15```

【算法分类】
动态规划

【题解分析与结论】
本题的核心是通过动态规划（DP）来求解满足条件的分割方案数。题解中大部分思路都围绕如何优化 DP 的状态转移，将原本 $O(n^3)$ 的复杂度优化到 $O(n^2)$。主要的优化点在于利用前缀和的性质，通过维护一个辅助数组来记录满足特定条件的方案数，从而避免了对每个子序列的重复计算。

【评分较高的题解】

1. **作者：COsm0s (赞：4)**  
   - **星级：4.5**  
   - **关键亮点：**  
     - 详细解释了朴素 DP 的思路，并逐步优化到 $O(n^2)$ 的复杂度。
     - 通过前缀和优化，将状态转移方程转化为 $f_{i,j}=g_{sum_i\bmod j,j-1}$，减少了计算量。
     - 代码清晰，注释详细，易于理解。
   - **核心代码：**
     ```cpp
     int a[N], f[N][N], b[N], modsum[N][N];
     signed main() {
         int n = read();
         up(i, 1, n) a[i] = read(), b[i] = b[i - 1] + a[i];
         modsum[0][0] = 1;
         up(j, 1, n)
         up(i, 1, n) {
             f[i][j] = modsum[b[i] % j][j - 1];
             modsum[b[i] % j][j - 1] += f[i][j - 1];
             modsum[b[i] % j][j - 1] %= mod;
         }
         int ans = 0;
         up(i, 1, n) ans = (ans + f[n][i]) % mod;
         write(ans);
         return 0;
     }
     ```

2. **作者：_Ponder_ (赞：4)**  
   - **星级：4**  
   - **关键亮点：**  
     - 通过引入辅助数组 $g_{i,j}$，优化了状态转移，避免了重复计算。
     - 代码简洁，逻辑清晰，适合快速理解。
   - **核心代码：**
     ```cpp
     int f[N][N], g[N][N];
     int sum[N], a[N];
     signed main() {
         scanf("%lld", &n);
         for (int i = 1; i <= n; i++) {
             scanf("%lld", &a[i]);
             sum[i] = sum[i - 1] + a[i];
         }
         f[0][0] = g[0][0] = 1;
         for (int i = 1; i <= n; i++)
             for (int j = n; j >= 1; j--) {
                 f[i][j] = g[j - 1][sum[i] % j];
                 g[j][sum[i] % (j + 1)] = (g[j][sum[i] % (j + 1)] + f[i][j]) % mod;
             }
         int ans = 0;
         for (int i = 1; i <= n; i++) ans = (ans + f[n][i]) % mod;
         cout << ans << '\n';
         return 0;
     }
     ```

3. **作者：菲斯斯夫斯基 (赞：4)**  
   - **星级：4**  
   - **关键亮点：**  
     - 通过前缀和优化，将状态转移方程转化为 $dp_{i,j}=sum_{j,a[i]\%j}$，减少了计算量。
     - 代码简洁，逻辑清晰，适合快速理解。
   - **核心代码：**
     ```cpp
     int dp[N][N], sum[N][N];
     signed main() {
         cin >> n;
         for (int i = 1; i <= n; i++)
             cin >> a[i], a[i] += a[i - 1];
         for (int i = 1; i <= n; i++) {
             dp[i][1] = 1;
             for (int j = 2; j <= i; j++)
                 dp[i][j] = sum[j][a[i] % j], dp[i][j] %= mod;
             for (int j = 1; j <= n; j++)
                 sum[j][a[i] % j] += dp[i][j - 1];
         }
         for (int i = 1; i <= n; i++)
             ans += dp[n][i], ans %= mod;
         cout << ans;
         return 0;
     }
     ```

【最优关键思路】
1. **前缀和优化：** 通过前缀和的性质，将原本需要计算子序列和的条件转化为前缀和的模数相等，从而减少了计算量。
2. **辅助数组维护：** 通过维护一个辅助数组 $g_{i,j}$，记录满足特定条件的方案数，避免了重复计算。

【拓展思路】
类似的问题可以通过前缀和和模数性质进行优化，例如在区间和问题中，利用前缀和的性质可以大大减少计算量。

【推荐题目】
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：49.63秒
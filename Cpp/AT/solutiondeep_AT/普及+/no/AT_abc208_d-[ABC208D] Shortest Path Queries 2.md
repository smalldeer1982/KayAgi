# 题目信息

# [ABC208D] Shortest Path Queries 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc208/tasks/abc208_d

高橋王国には $ N $ 個の都市と $ M $ 本の道路があります。

都市には $ 1 $ から $ N $ の番号が、道路には $ 1 $ から $ M $ の番号が割り振られています。道路 $ i $ は都市 $ A_i $ から $ B_i $ へ向かう**一方通行**の道で、移動するのに $ C_i $ 分かかります。

$ f(s,\ t,\ k) $ を次のクエリへの答えとして定めます。

- 都市 $ s $ を出発して都市 $ t $ に到着するまでの最短時間を計算してください。ただし、通ってよい都市は $ s,\ t $ および番号が $ k $ 以下の都市のみとします。また、都市 $ t $ に到着できない場合や $ s\ =\ t $ である場合におけるクエリの答えは $ 0 $ とします。

全ての $ s,t,k $ に対して $ f(s,t,k) $ を計算して総和を出力してください。より厳密には、$ \displaystyle\ \sum_{s\ =\ 1}^N\ \sum_{t\ =\ 1}^N\ \sum_{k\ =\ 1}^N\ f(s,\ t,\ k) $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 400 $
- $ 0\ \leq\ M\ \leq\ N(N-1) $
- $ 1\ \leq\ A_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ B_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ A_i\ \neq\ B_i $ $ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ C_i\ \leq\ 10^6 $ $ (1\ \leq\ i\ \leq\ M) $
- $ i\ \neq\ j $ ならば $ A_i\ \neq\ A_j $ または $ B_i\ \neq\ B_j $ である。
- 入力は全て整数である。

### Sample Explanation 1

$ f(s,t,k)\ \neq\ 0 $ であるような $ s,t,k $ を以下に挙げます。 - $ k\ =\ 1 $ のとき：$ f(1,2,1)\ =\ 3,\ f(2,3,1)\ =\ 2 $ - $ k\ =\ 2 $ のとき：$ f(1,2,2)\ =\ 3,\ f(2,3,2)\ =\ 2,\ f(1,3,2)\ =\ 5 $ - $ k\ =\ 3 $ のとき：$ f(1,2,3)\ =\ 3,\ f(2,3,3)\ =\ 2,\ f(1,3,3)\ =\ 5 $

### Sample Explanation 2

全ての $ s,t,k $ に対して $ f(s,t,k)\ =\ 0 $ です。

## 样例 #1

### 输入

```
3 2

1 2 3

2 3 2```

### 输出

```
25```

## 样例 #2

### 输入

```
3 0```

### 输出

```
0```

## 样例 #3

### 输入

```
5 20

1 2 6

1 3 10

1 4 4

1 5 1

2 1 5

2 3 9

2 4 8

2 5 6

3 1 5

3 2 1

3 4 7

3 5 9

4 1 4

4 2 6

4 3 4

4 5 8

5 1 2

5 2 5

5 3 6

5 4 5```

### 输出

```
517```

# AI分析结果

### 题目重写
高桥王国中有 $N$ 个城市和 $M$ 条道路。城市编号为 $1$ 到 $N$，道路编号为 $1$ 到 $M$。道路 $i$ 是从城市 $A_i$ 到城市 $B_i$ 的单行道，通行时间为 $C_i$ 分钟。

定义 $f(s, t, k)$ 为从城市 $s$ 出发到城市 $t$ 的最短时间，且只能经过编号不超过 $k$ 的城市（包括 $s$ 和 $t$）。如果无法到达或 $s = t$，则 $f(s, t, k) = 0$。

要求计算所有 $s, t, k$ 的 $f(s, t, k)$ 的总和，即 $\displaystyle \sum_{s=1}^N \sum_{t=1}^N \sum_{k=1}^N f(s, t, k)$。

### 算法分类
最短路

### 综合分析与结论
本题的核心是计算多源最短路，且需要限制经过的节点范围。Floyd算法由于其动态规划的特性，能够很好地处理这种问题。所有题解都采用了Floyd算法，且通过三维数组或滚动数组的方式实现了对$k$的限制。

### 所选题解
1. **作者：Yamchip (赞：4)**
   - **星级：5**
   - **关键亮点**：清晰地解释了Floyd算法的状态转移方程，并指出其与题目要求的直接对应关系。代码简洁明了，初始化部分处理得当。
   - **代码核心思想**：使用三维数组`dp[k][i][j]`表示只经过编号不超过$k$的城市时，从$i$到$j$的最短路径。通过三重循环更新`dp`数组，并在最后统计所有有效路径的总和。
   ```cpp
   for(int k = 1; k <= n; k++)
       for(int i = 1; i <= n; i++)
           for(int j = 1; j <= n; j++)
               dp[k][i][j] = min(dp[k - 1][i][j], dp[k - 1][i][k] + dp[k - 1][k][j]);
   ```

2. **作者：403notfound (赞：3)**
   - **星级：4**
   - **关键亮点**：详细解释了Floyd算法的状态定义和转移方程，并强调了初始化的重要性。代码结构清晰，注释详细。
   - **代码核心思想**：与Yamchip的解法类似，使用三维数组`f[x][y][k]`表示只经过编号不超过$k$的城市时，从$x$到$y$的最短路径。通过三重循环更新`f`数组，并在最后统计所有有效路径的总和。
   ```cpp
   for(int k = 1; k <= n; k++)
       for(int i = 1; i <= n; i++)
           for(int j = 1; j <= n; j++)
               f[i][j][k] = min(f[i][j][k - 1], f[i][k][k - 1] + f[k][j][k - 1]);
   ```

3. **作者：Brilliant11001 (赞：3)**
   - **星级：4**
   - **关键亮点**：解释了Floyd算法的滚动数组优化，并指出其与背包问题的相似性。代码简洁，优化思路清晰。
   - **代码核心思想**：使用二维数组`g[i][j]`表示从$i$到$j$的最短路径，通过三重循环更新`g`数组，并在每次更新后统计有效路径的总和。
   ```cpp
   for(int k = 1; k <= n; k++)
       for(int i = 1; i <= n; i++)
           for(int j = 1; j <= n; j++) {
               g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
               if(g[i][j] < inf) res += g[i][j];
           }
   ```

### 最优关键思路或技巧
- **Floyd算法的应用**：Floyd算法通过动态规划的方式，逐步引入中间节点，更新最短路径。本题中，Floyd算法的$k$循环正好对应题目中的$k$限制，使得算法能够直接应用于该问题。
- **滚动数组优化**：通过滚动数组的方式，可以减少空间复杂度，使得代码更加简洁高效。

### 可拓展之处
- **类似问题**：如果题目中的限制条件变为只能经过某些特定的节点，可以通过类似的方式修改Floyd算法，增加对节点的限制条件。
- **其他最短路算法**：在某些特定情况下，Dijkstra算法或Bellman-Ford算法也可以用于解决类似问题，但需要根据具体条件进行修改。

### 推荐题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
3. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

### 个人心得摘录
- **Yamchip**：今天是除夕，祝大家新年快乐。
- **Brilliant11001**：做完这道题后感觉对Floyd的理解更深了。
- **Expert_Dream**：如果你只知道Floyd的转移公式，那你真的没有学Floyd。我们想想他的本质是啥？

---
处理用时：37.14秒
# 题目信息

# [ABC210D] National Railway

## 题目描述

## 题目翻译

国王想在他 $ H $ 行 $ W $ 列的国土上建铁路  
具体地，建铁路的花费可以表示为两部分：建车站和建轨道。  
- 在 $ (i,\ j) $ 处建车站的费用表示为 $ A_{i,j} $  
- 连接 $ (i,\ j) $ 处的车站和 $ (i',\ j') $ 处车站之间铁路的花费为 $ C\ \times\ (|i-i'|\ +\ |j-j'|) $  

由于不修铁路会下台，而国王又没有太多钱，所以想知道在不考虑便利性的前提下修铁路的最小花费。

## 样例 #1

### 输入

```
3 4 2

1 7 7 9

9 6 3 7

7 8 6 4```

### 输出

```
10```

## 样例 #2

### 输入

```
3 3 1000000000

1000000 1000000 1

1000000 1000000 1000000

1 1000000 1000000```

### 输出

```
1001000001```

# AI分析结果

### 题目翻译

国王想在他 $ H $ 行 $ W $ 列的国土上建铁路。  
具体地，建铁路的花费可以表示为两部分：建车站和建轨道。  
- 在 $ (i,\ j) $ 处建车站的费用表示为 $ A_{i,j} $  
- 连接 $ (i,\ j) $ 处的车站和 $ (i',\ j') $ 处车站之间铁路的花费为 $ C\ \times\ (|i-i'|\ +\ |j-j'|) $  

由于不修铁路会下台，而国王又没有太多钱，所以想知道在不考虑便利性的前提下修铁路的最小花费。

### 样例 #1

#### 输入

```
3 4 2

1 7 7 9

9 6 3 7

7 8 6 4
```

#### 输出

```
10
```

### 样例 #2

#### 输入

```
3 3 1000000000

1000000 1000000 1

1000000 1000000 1000000

1 1000000 1000000
```

#### 输出

```
1001000001
```

### 算法分类
动态规划

### 题解分析与结论

本题的核心是通过动态规划来求解在两个车站之间修建铁路的最小花费。由于直接枚举所有可能的车站对会导致时间复杂度过高，因此需要通过动态规划来优化计算过程。题解中主要采用了以下几种思路：

1. **方向性动态规划**：由于绝对值的存在，题解通常会将问题分解为四个方向（左上、右上、左下、右下）分别进行动态规划，最后取最小值。
2. **状态转移方程**：通过定义不同的状态转移方程，分别计算在当前点修建车站或连接轨道的最小花费。
3. **矩阵翻转**：为了处理不同方向的情况，部分题解通过翻转矩阵来简化问题。

### 高星题解推荐

#### 题解1：作者：wflhx2011 (赞：5)
- **星级**：5星
- **关键亮点**：思路清晰，代码简洁，通过翻转矩阵处理不同方向的情况，动态规划的状态转移方程明确。
- **核心代码**：
```cpp
void solve() 
{
    memset(dp,0x3f3f3f3f,sizeof(dp));
    for(int i=1;i<=h;i++) 
        for(int j=1;j<=w;j++) 
		{
            dp[i][j]=min({a[i][j],dp[i-1][j]+c,dp[i][j-1]+c});
            ans=min({ans,dp[i-1][j]+c+a[i][j],dp[i][j-1]+c+a[i][j]});
        }
}
```
- **实现思想**：通过动态规划计算每个点的最小花费，并考虑从上方和左方转移的情况，最后通过翻转矩阵处理另一个方向。

#### 题解2：作者：Hyc_ (赞：1)
- **星级**：4星
- **关键亮点**：详细解释了前缀最大值的计算过程，通过四个方向的前缀最大值来求解最小花费，思路较为全面。
- **核心代码**：
```cpp
for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j){
        s1[i][j]=max(s1[i-1][j],s1[i][j-1]);
        s1[i][j]=max(s1[i][j],-a[i][j]+c*(i+j));
    }
```
- **实现思想**：通过四个方向的前缀最大值数组，分别计算每个方向的最小花费，最后取最小值。

#### 题解3：作者：Little_Cabbage (赞：0)
- **星级**：4星
- **关键亮点**：通过动态规划计算每个点的最小花费，并详细解释了状态转移方程，代码结构清晰。
- **核心代码**：
```cpp
rep(i, 1, n) rep(j, 1, m) {
    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});
    if (i > 1 || j > 1) res = min(res, dp[i][j] + a[i][j] + c * (i + j));
    if (i > 1 || j > 1) dp[i][j] = min(dp[i][j], a[i][j] - c * (i + j));
    else dp[i][j] = a[i][j] - c * (i + j);
}
```
- **实现思想**：通过动态规划计算每个点的最小花费，并考虑从上方、左方和左上方转移的情况，最后通过翻转矩阵处理另一个方向。

### 最优关键思路
通过动态规划分别计算四个方向的最小花费，最后取最小值。这种方法通过分解问题，简化了绝对值的处理，并且通过矩阵翻转来统一处理不同方向的情况。

### 可拓展之处
类似的问题可以通过分解方向、使用动态规划或前缀和等方法来优化计算过程。例如，处理二维网格中的最短路径、最小花费等问题时，可以考虑类似的方向性动态规划。

### 推荐题目
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

### 个人心得摘录
- **wflhx2011**：通过翻转矩阵处理不同方向的情况，简化了问题的复杂度。
- **Hyc_**：详细解释了前缀最大值的计算过程，思路较为全面。
- **Little_Cabbage**：通过动态规划计算每个点的最小花费，并详细解释了状态转移方程，代码结构清晰。

---
处理用时：39.45秒
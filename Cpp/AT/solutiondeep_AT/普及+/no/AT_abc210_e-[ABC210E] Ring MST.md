# 题目信息

# [ABC210E] Ring MST

## 题目描述

- 给定一张 $n$ 个点的图，顶点的编号为 $[0, n - 1]$，同时给出两个长度为 $m$ 的数组 $a_1, a_2, \cdots, a_m$ 和 $b_1, b_2, \cdots, b_m$。

- 初始时图中并没有任何边，你可以按照以下操作加边：选择一个 $1 \le i \le m$ 和一个 $0 \le x < n$，并在顶点 $x$ 和顶点 $(x + a_i) \bmod n$ 中添加一条长度为 $b_i$ 的边。

- 你现在想要知道，你添加的边的长度总和至少为多少，才能使得整个图连通?如果无论如何都不能使整个图连通，输出 `-1`。

## 说明/提示

- 对于 $30 \%$ 的数据：$1 \le n, m \le 1000, 1 \le b_i \le 10^9$。

- 对于 $60 \%$ 的数据：$1 \le n, m \le 10^5, 1 \le b_i \le 10^9$。

- 对于 $100 \%$ 的数据：$1 \le n \le 10^9, 1 \le m \le 10^5, 1 \le b_i \le 10^9$。

翻译提供者：[Sunrize](https://www.luogu.com.cn/user/502658)。

## 样例 #1

### 输入

```
4 2

2 3

3 5```

### 输出

```
11```

## 样例 #2

### 输入

```
6 1

3 4```

### 输出

```
-1```

# AI分析结果

【题目内容】
# [ABC210E] Ring MST

## 题目描述

- 给定一张 $n$ 个点的图，顶点的编号为 $[0, n - 1]$，同时给出两个长度为 $m$ 的数组 $a_1, a_2, \cdots, a_m$ 和 $b_1, b_2, \cdots, b_m$。

- 初始时图中并没有任何边，你可以按照以下操作加边：选择一个 $1 \le i \le m$ 和一个 $0 \le x < n$，并在顶点 $x$ 和顶点 $(x + a_i) \bmod n$ 中添加一条长度为 $b_i$ 的边。

- 你现在想要知道，你添加的边的长度总和至少为多少，才能使得整个图连通?如果无论如何都不能使整个图连通，输出 `-1`。

## 说明/提示

- 对于 $30 \%$ 的数据：$1 \le n, m \le 1000, 1 \le b_i \le 10^9$。

- 对于 $60 \%$ 的数据：$1 \le n, m \le 10^5, 1 \le b_i \le 10^9$。

- 对于 $100 \%$ 的数据：$1 \le n \le 10^9, 1 \le m \le 10^5, 1 \le b_i \le 10^9$。

翻译提供者：[Sunrize](https://www.luogu.com.cn/user/502658)。

## 样例 #1

### 输入

```
4 2

2 3

3 5```

### 输出

```
11```

## 样例 #2

### 输入

```
6 1

3 4```

### 输出

```
-1```

【算法分类】
贪心、数学

【题解分析与结论】
本题的核心是通过贪心策略和数学中的最大公约数（GCD）来解决图的最小生成树问题。所有题解都采用了类似的思路：首先对边按权值排序，然后通过不断计算当前连通块数量与 GCD 的关系，逐步减少连通块数量，直到图连通或无法连通。

【所选高星题解】
1. **作者：hswfwkj_ (5星)**
   - **关键亮点**：思路清晰，代码简洁，通过贪心和 GCD 的结合，逐步减少连通块数量，最终得到最小生成树的代价。
   - **代码核心**：
     ```cpp
     for(int i = 1; i <= m; i++) {
         ans += 1ll * (n - __gcd(n, t[i].a)) * t[i].c;
         n = __gcd(n, t[i].a);
         if(n == 1) break;
     }
     ```
   - **个人心得**：通过贪心策略，优先选择权值较小的边，逐步减少连通块数量，最终得到最小生成树的代价。

2. **作者：Ray662 (4星)**
   - **关键亮点**：详细分析了 Kruskal 算法的应用，通过 GCD 计算连通块数量，思路清晰，代码可读性强。
   - **代码核心**：
     ```cpp
     _for (i, 0, m - 1) {
         int tmp = g;
         g = __gcd(g, v[i].S);
         ans += (tmp - g) * v[i].F;
     }
     ```
   - **个人心得**：通过模拟 Kruskal 算法，逐步减少连通块数量，最终得到最小生成树的代价。

3. **作者：xiaoPanda (4星)**
   - **关键亮点**：通过贪心和 GCD 的结合，逐步减少连通块数量，最终得到最小生成树的代价，代码简洁。
   - **代码核心**：
     ```cpp
     for(int i = 1; i <= m; i++) {
         d = __gcd(d, a[i].x);
         ans += (last - d) * a[i].y;
         if(d == 1) break;
         last = d;
     }
     ```
   - **个人心得**：通过贪心策略，优先选择权值较小的边，逐步减少连通块数量，最终得到最小生成树的代价。

【最优关键思路或技巧】
- **贪心策略**：优先选择权值较小的边，逐步减少连通块数量。
- **GCD 计算**：通过计算当前连通块数量与 GCD 的关系，逐步减少连通块数量，直到图连通或无法连通。

【可拓展之处】
- 类似的问题可以扩展到更复杂的图结构，如带权图或有向图。
- 可以结合其他算法，如并查集，来进一步优化连通块的合并过程。

【推荐题目】
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
2. [P1195 【模板】Kruskal算法](https://www.luogu.com.cn/problem/P1195)
3. [P1967 【NOIP2013 提高组】货车运输](https://www.luogu.com.cn/problem/P1967)

---
处理用时：33.22秒
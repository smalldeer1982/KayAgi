# 题目信息

# [ABC212E] Safety Journey

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc212/tasks/abc212_e

AtCoder国には $ N $ 個の都市があり、都市 $ 1 $ , 都市 $ 2 $ , $ \ldots $ , 都市 $ N $ と番号付けられています。 最初、どの $ 2 $ つの相異なる都市の間も双方向に通れる道で結ばれていましたが、老朽化が進み、これらのうち $ M $ 本の道が使えなくなってしまいました。具体的には $ 1\leq\ i\ \leq\ M $ について都市 $ U_i $ と都市 $ V_i $ を結ぶ道が使えなくなってしまいました。

いま、高橋君は都市 $ 1 $ で始まり、都市 $ 1 $ で終わる $ K $ 日間の旅をしようと考えました。都市 $ 1 $ で始まり、都市 $ 1 $ で終わる $ K $ 日間の旅とは、 $ K+1 $ 個の都市の列 $ (A_0,\ A_1,\ \ldots,\ A_K) $ であって、$ A_0=A_K=1 $ をみたし、 $ 0\leq\ i\leq\ K-1 $ について $ A_i $ と $ A_{i+1} $ が相異なり、かつ都市 $ A_i $ と都市 $ A_{i+1} $ が現在も使用可能な道で結ばれているものを指します。

都市 $ 1 $ で始まり、都市 $ 1 $ で終わる $ K $ 日間の相異なる旅の数を $ 998244353 $ で割った余りを出力してください。ただし、 $ 2 $ つの $ K $ 日間の旅 $ (A_0,\ A_1,\ \ldots,\ A_K) $ と $ (B_0,\ B_1,\ \ldots,\ B_K) $ が相異なるとは、ある $ i $ が存在して $ A_i\neq\ B_i $ となることを言います。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ 0\ \leq\ M\ \leq\ \min\left(\ \frac{N(N-1)}{2},5000\ \right) $
- $ 2\ \leq\ K\ \leq\ 5000 $
- $ 1\ \leq\ U_i\ <\ V_i\ \leq\ N $
- $ (U_i,\ V_i) $ は全て互いに相異なる。
- 入力は全て整数である。

### Sample Explanation 1

次のような $ 4 $ 種類の旅が存在します。 - ($ 1,2,1,2,1 $) - ($ 1,2,1,3,1 $) - ($ 1,3,1,2,1 $) - ($ 1,3,1,3,1 $) これ以外に条件をみたすようなものは無いため、 $ 4 $ を出力します。

### Sample Explanation 2

使える道が $ 1 $ 本も残っておらず、条件をみたすような旅は存在しません。

## 样例 #1

### 输入

```
3 1 4

2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
3 3 3

1 2

1 3

2 3```

### 输出

```
0```

## 样例 #3

### 输入

```
5 3 100

1 2

4 5

2 3```

### 输出

```
428417047```

# AI分析结果

### 题目翻译

AtCoder国有 $N$ 个城市，编号为 $1, 2, \ldots, N$。最初，任意两个不同的城市之间都有一条双向道路相连，但由于道路老化，其中的 $M$ 条道路无法使用了。具体来说，对于 $1 \leq i \leq M$，连接城市 $U_i$ 和城市 $V_i$ 的道路无法使用了。

现在，高桥君计划从城市 $1$ 出发，经过 $K$ 天的旅行后回到城市 $1$。旅行的定义是：一个长度为 $K+1$ 的城市序列 $(A_0, A_1, \ldots, A_K)$，满足 $A_0 = A_K = 1$，且对于 $0 \leq i \leq K-1$，$A_i$ 和 $A_{i+1}$ 是不同的城市，并且它们之间有一条可用的道路。

请输出满足条件的不同的旅行方案数，结果对 $998244353$ 取模。两个旅行方案不同，当且仅当存在某个 $i$ 使得 $A_i \neq B_i$。

### 算法分类
动态规划

### 题解分析与结论

#### 综合分析
本题的核心是通过动态规划（DP）来计算从城市 $1$ 出发，经过 $K$ 天后回到城市 $1$ 的不同旅行方案数。由于直接暴力枚举所有可能的路径会导致时间复杂度过高，因此需要优化。大多数题解采用了“补图”的思想，即先计算所有可能的路径，再减去不可行的路径。这种方法通过减少不必要的计算，显著降低了时间复杂度。

#### 最优思路与技巧
1. **补图思想**：由于题目中给出的 $M$ 条边是不可用的，因此可以通过计算所有可能的路径，再减去这些不可用的路径，从而减少计算量。
2. **动态规划优化**：通过预处理每一层的总和，并在转移时减去不可行的路径，可以将时间复杂度从 $O(n^2k)$ 降低到 $O(nk + mk)$。
3. **滚动数组**：为了进一步优化空间复杂度，可以使用滚动数组来存储 DP 状态，减少内存使用。

#### 推荐题解
1. **作者：L_zaa_L**（5星）
   - **关键亮点**：通过边表优化了边的存储，减少了时间复杂度，代码清晰且优化到位。
   - **代码核心思想**：使用边表存储不可用的边，并在 DP 转移时减去这些边的贡献。
   ```cpp
   for(int i=1;i<=k;i++){
       int sum=0;
       for(int j=1;j<=n;j++) sum+=f[i-1][j];
       for(int j=1;j<=n;j++){
           f[i][j]+=sum-f[i-1][j];
           for(int k=head[j];k!=0;k=nxt[k])
               f[i][j]-=f[i-1][to[k]];
           f[i][j]=(f[i][j]+998244353)%998244353;
       }
   }
   ```

2. **作者：_Ponder_**（4星）
   - **关键亮点**：通过补图的思想，优化了 DP 转移方程，代码简洁且易于理解。
   - **代码核心思想**：使用补图的边集进行 DP 转移，减去不可行的路径。
   ```cpp
   for(int i=1;i<=k;i++){
       sum=0;
       for(int s=1;s<=n;s++) sum+=f[i-1][s];
       for(int s=1;s<=n;s++){
           f[i][s]=sum-f[i-1][s];
           for(int j=head[s];j;j=nxt[j]){
               int v=to[j];
               f[i][s]-=f[i-1][v];
           }
           f[i][s]%=mod;
       }
   }
   ```

3. **作者：_lfxxx_**（4星）
   - **关键亮点**：通过预处理每一层的总和，并在转移时减去不可行的路径，优化了时间复杂度。
   - **代码核心思想**：使用预处理的总和进行 DP 转移，减去不可行的路径。
   ```cpp
   for(int j=1;j<=k;++j){
       sum=0;
       for(int i=1;i<=n;++i)
           Mod(sum,f[i][j-1]);
       for(int i=1;i<=n;++i)
           Mod(f[i][j],sum-f[i][j-1]);
       for(int i=1;i<=m;++i)
           Mod(f[u[i]][j],-f[v[i]][j-1]),Mod(f[v[i]][j],-f[u[i]][j-1]);
   }
   ```

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

---
处理用时：32.73秒
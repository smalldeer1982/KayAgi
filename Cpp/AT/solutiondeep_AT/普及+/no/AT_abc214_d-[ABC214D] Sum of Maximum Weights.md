# 题目信息

# [ABC214D] Sum of Maximum Weights

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc214/tasks/abc214_d

$ N $ 頂点の木があり、頂点は $ 1,\ 2,\ \dots,\ N $ と番号付けられています。  
 $ i\ \,\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結び、重みは $ w_i $ です。

異なる頂点 $ u,\ v $ に対し、頂点 $ u $ から頂点 $ v $ までの最短パスに含まれる辺の重みの最大値を $ f(u,\ v) $ とおきます。

$ \displaystyle\ \sum_{i\ =\ 1}^{N\ -\ 1}\ \sum_{j\ =\ i\ +\ 1}^N\ f(i,\ j) $ を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- $ 1\ \leq\ w_i\ \leq\ 10^7 $
- 与えられるグラフは木である。
- 入力は全て整数である。

### Sample Explanation 1

$ f(1,\ 2)\ =\ 10,\ f(2,\ 3)\ =\ 20,\ f(1,\ 3)\ =\ 20 $ であるので、これらの和である $ 50 $ を出力します。

## 样例 #1

### 输入

```
3

1 2 10

2 3 20```

### 输出

```
50```

## 样例 #2

### 输入

```
5

1 2 1

2 3 2

4 2 5

3 5 14```

### 输出

```
76```

# AI分析结果

### 题目翻译
# [ABC214D] Sum of Maximum Weights

## 题目描述

$ N $ 个顶点的树，顶点编号为 $ 1,\ 2,\ \dots,\ N $。  
第 $ i\ \,\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ 条边连接顶点 $ u_i $ 和顶点 $ v_i $，边权为 $ w_i $。

对于不同的顶点 $ u,\ v $，定义 $ f(u,\ v) $ 为从顶点 $ u $ 到顶点 $ v $ 的最短路径上边权的最大值。

求 $ \displaystyle\ \sum_{i\ =\ 1}^{N\ -\ 1}\ \sum_{j\ =\ i\ +\ 1}^N\ f(i,\ j) $。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- $ 1\ \leq\ w_i\ \leq\ 10^7 $
- 给定的图是树。
- 输入均为整数。

### 样例解释 1

$ f(1,\ 2)\ =\ 10,\ f(2,\ 3)\ =\ 20,\ f(1,\ 3)\ =\ 20 $，因此输出它们的和 $ 50 $。

## 样例 #1

### 输入

```
3

1 2 10

2 3 20```

### 输出

```
50```

## 样例 #2

### 输入

```
5

1 2 1

2 3 2

4 2 5

3 5 14```

### 输出

```
76```

### 算法分类
并查集

### 题解分析与结论
该题的核心思路是通过并查集维护连通块，并利用边权从小到大的顺序逐步合并连通块，计算每条边对最终答案的贡献。具体来说，每条边的贡献等于其边权乘以它所连接的两个连通块的大小的乘积。这种方法的时间复杂度为 $O(n \log n)$，主要来自边权排序。

### 评分较高的题解
1. **作者：loser_seele (赞：5)**
   - **星级：5星**
   - **关键亮点**：思路清晰，代码简洁，使用了并查集维护连通块大小，并通过排序边权逐步计算贡献。
   - **核心代码**：
     ```cpp
     for(int i=0;i<n-1;i++) {
         int a=find(vec[i].a);
         int b=find(vec[i].b);        
         if(a!=b) {
             ans+=1LL*vec[i].c*sz[a]*sz[b];
             sz[b]+=sz[a];
             sz[a]=0;
             fa[a]=b;
         }
     }
     ```
   - **个人心得**：通过边权排序和并查集的结合，能够高效地计算每条边的贡献。

2. **作者：EityDawn (赞：2)**
   - **星级：4星**
   - **关键亮点**：详细解释了并查集的应用，强调了边权排序的重要性，并提供了代码实现。
   - **核心代码**：
     ```cpp
     for(int i=1;i<n;i++) {
         int fx=find(x(i)),fy=find(y(i));
         ans+=w(i)*siz[fx]*siz[fy];
         fa[fy]=fx;siz[fx]+=siz[fy];
     }
     ```
   - **个人心得**：通过并查集维护连通块大小，能够有效地计算每条边的贡献。

3. **作者：toolong114514 (赞：1)**
   - **星级：4星**
   - **关键亮点**：详细解释了边权排序和并查集的结合，强调了乘法原理的应用。
   - **核心代码**：
     ```cpp
     for(int i=1;i<n;i++) {
         ans+=cnt[find(edge[i].fr)]*cnt[find(edge[i].to)]*edge[i].val;
         connect(edge[i].fr,edge[i].to);
     }
     ```
   - **个人心得**：通过边权排序和并查集的结合，能够高效地计算每条边的贡献。

### 最优关键思路
1. **边权排序**：将边按权值从小到大排序，确保每次处理的边是当前连通块中的最大边。
2. **并查集维护连通块**：通过并查集维护每个连通块的大小，并在合并时计算贡献。
3. **乘法原理计算贡献**：每条边的贡献等于其边权乘以它所连接的两个连通块的大小的乘积。

### 可拓展之处
类似的问题可以扩展到其他图论问题，如求最小生成树、最大生成树等。还可以考虑处理更复杂的图结构，如带权图、有向图等。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)

---
处理用时：35.10秒
# 题目信息

# [ABC214E] Packing Under Range Regulations

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc214/tasks/abc214_e

$ T $ 個のテストケースについて、以下の問題を解いてください。

$ 1,2,\dots,10^9 $ の番号がついた $ 10^9 $ 個の箱と、 $ 1,2,\dots,N $ の番号がついた $ N $ 個のボールがあります。  
 それぞれの箱に入れることのできるボールの個数は多くとも $ 1 $ 個です。  
 以下の条件を満たすように、 $ N $ 個のボールを全て箱に入れることができるか判定してください。

- 全ての $ 1 $ 以上 $ N $ 以下の整数 $ i $ について、番号 $ i $ のボールが $ L_i $ 以上 $ R_i $ 以下の番号がついた箱に入っている。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ L_i\ \le\ R_i\ \le\ 10^9 $
- $ 1 $ つの入力に含まれるテストケースについて、それらの $ N $ の総和は $ 2\ \times\ 10^5 $ を超えない。

### Sample Explanation 1

この入力には $ 2 $ つのテストケースが含まれます。 - $ 1 $ つ目のテストケースについて、以下のようにボールを箱に入れると、問題文中の条件を満たすように $ 3 $ 個のボールを全て箱に入れることができるので、 `Yes` と出力します。 - ボール $ 1 $ を箱 $ 1 $ に入れる。 - ボール $ 2 $ を箱 $ 2 $ に入れる。 - ボール $ 3 $ を箱 $ 3 $ に入れる。 - $ 2 $ つ目のテストケースについて、問題文中の条件を満たすように $ 5 $ 個のボールを全て箱に入れることはできないので、 `No` と出力します。

## 样例 #1

### 输入

```
2

3

1 2

2 3

3 3

5

1 2

2 3

3 3

1 3

999999999 1000000000```

### 输出

```
Yes

No```

# AI分析结果

### 题目重写
$ T $ 个测试用例，每个测试用例有 $ N $ 个球和 $ 10^9 $ 个盒子。每个盒子最多放一个球，第 $ i $ 个球必须放在 $ [L_i, R_i] $ 区间内的某个盒子中。判断是否可以将所有球放入盒子中。

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是贪心算法，即尽可能将球放在区间的最左端，以便为后续的球留出更多的空间。多个题解都采用了类似的贪心策略，但实现方式有所不同，主要分为以下几种：

1. **并查集+贪心**：通过并查集维护可用位置，按右端点排序后贪心放置。时间复杂度较高，但思路清晰。
2. **优先队列+贪心**：按左端点排序后，使用优先队列维护右端点，贪心放置。时间复杂度为 $O(n \log n)$，效率较高。
3. **扫描线+贪心**：通过扫描线维护区间长度和小球个数的差值，判断是否存在合法方案。实现较为复杂，但思路新颖。

### 高星题解推荐

#### 题解1：作者：Nahida_Buer (赞：3)
**星级：4星**
**关键亮点**：使用优先队列维护右端点，按左端点排序后贪心放置，思路清晰且代码简洁。
**核心代码**：
```cpp
priority_queue<int> q;
int i=1;
while(i<=n){
    q.push(-p[i].se);
    int j=i+1,s=p[i].fi;
    while(p[j].fi==p[i].fi){
        q.push(-p[j].se);
        j++;
    }
    while(s<p[j].fi && !q.empty()){
        int v=-q.top();
        q.pop();
        if(s>v){
            puts("No");
            return ;
        }
        s++;
    }
    i=j;
}
```
**实现思想**：按左端点排序后，将所有左端点相同的球的右端点放入优先队列，然后依次取出最小的右端点进行放置，若无法放置则输出 `No`。

#### 题解2：作者：GeorgeAAAADHD (赞：3)
**星级：4星**
**关键亮点**：使用优先队列维护右端点，按左端点排序后贪心放置，代码结构清晰，易于理解。
**核心代码**：
```cpp
priority_queue<int,vector<int>,greater<int>> p;
int l=0,r=0,f=0;
while(r<n){
    if(p.empty()){
        l=a[++r].l;
        p.push(a[r].r);
    }
    while(r<n&&a[r+1].l<=l) p.push(a[++r].r);
    if(p.top()<l){
        f=1;p.pop();
        break;
    }
    l++;
    p.pop();
}
```
**实现思想**：按左端点排序后，使用优先队列维护右端点，贪心放置，若无法放置则输出 `No`。

### 最优关键思路
优先队列+贪心：按左端点排序后，使用优先队列维护右端点，贪心放置。这种方法时间复杂度为 $O(n \log n)$，效率较高且实现简单。

### 可拓展之处
类似的问题可以扩展到多个维度，如二维平面上的区间覆盖问题，或者更复杂的约束条件。优先队列和贪心算法的结合在解决这类问题时非常有效。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

### 个人心得
在实现过程中，优先队列的使用是关键，能够有效维护当前可用的最小右端点，确保贪心策略的正确性。同时，多测不清空是常见的错误，需要特别注意。

---
处理用时：31.11秒
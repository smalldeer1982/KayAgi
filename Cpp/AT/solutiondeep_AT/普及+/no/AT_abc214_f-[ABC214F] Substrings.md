# 题目信息

# [ABC214F] Substrings

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc214/tasks/abc214_f

文字列 $ S $ が与えられます。高橋君はこの文字列から以下の手順にしたがって新しい文字列 $ T $ を作ります。

- まず、$ S $ の文字のうちの一つ以上に印をつける。ただし、印をつけた文字どうしが隣り合ってはならない。
- 次に、印がついていない文字を全て削除する。
- 最後に、残った文字列を $ T $ とする。ただし、この時に文字を並び替えてはならない。

$ T $ としてありうる文字列は何種類ありますか？ $ (10^9\ +\ 7) $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ S $ は英小文字のみからなる長さ $ 1 $ 以上 $ 2\ \times\ 10^5 $ 以下の文字列

### Sample Explanation 1

$ T $ としてありうるものは `a`、 `b`、 `c`、 `ac` の $ 4 $ つです。 $ S $ の $ 1 $ 文字目のみに印をつけたとき $ T $ は `a`、 $ S $ の $ 2 $ 文字目のみに印をつけたとき $ T $ は `b`、 $ S $ の $ 3 $ 文字目のみに印をつけたとき $ T $ は `c`、 $ S $ の $ 1 $ 文字目と $ 3 $ 文字目のみに印をつけたとき $ T $ は `ac`、 となります。例えば $ 1 $ 文字目と $ 2 $ 文字目の両方に印をつけることはできないことに注意してください。

### Sample Explanation 2

$ T $ としてありうるものは `a` のみです。 印をつけた位置が異なっていても $ T $ が同じ文字列となる可能性があることに注意してください。

### Sample Explanation 3

$ T $ としてありうるものは `a`、 `b`、 `c`、 `aa`、 `ab`、 `ca` の $ 6 $ つです。

## 样例 #1

### 输入

```
abc```

### 输出

```
4```

## 样例 #2

### 输入

```
aa```

### 输出

```
1```

## 样例 #3

### 输入

```
acba```

### 输出

```
6```

## 样例 #4

### 输入

```
chokudai```

### 输出

```
54```

# AI分析结果

【题目内容】
# [ABC214F] 子字符串

## 题目描述

给定一个字符串 $S$。高桥君将按照以下步骤从该字符串中创建一个新的字符串 $T$。

- 首先，在 $S$ 中标记一个或多个字符。这里，任何两个标记字符都不应相邻。
- 接下来，删除所有未标记的字符。
- 最后，让 $T$ 成为剩余的字符串。这里，禁止更改字符的顺序。

有多少个字符串可以作为 $T$？求计数模数 $(10^9 + 7)$。

## 说明/提示

### 制約

- $S$ 是仅由小写字母组成的长度在 $1$ 到 $2 \times 10^5$ 之间的字符串。

### 样例解释 1

$ T $ 可能的结果是 `a`、 `b`、 `c`、 `ac` 共 $4$ 种。例如，仅标记 $S$ 的第 $1$ 个字符时，$T$ 为 `a`；仅标记第 $2$ 个字符时，$T$ 为 `b`；仅标记第 $3$ 个字符时，$T$ 为 `c`；标记第 $1$ 和第 $3$ 个字符时，$T$ 为 `ac`。注意，不能同时标记第 $1$ 和第 $2$ 个字符。

### 样例解释 2

$ T $ 可能的结果只有 `a`。即使标记的位置不同，$T$ 也可能相同。

### 样例解释 3

$ T $ 可能的结果是 `a`、 `b`、 `c`、 `aa`、 `ab`、 `ca` 共 $6$ 种。

## 样例 #1

### 输入

```
abc```

### 输出

```
4```

## 样例 #2

### 输入

```
aa```

### 输出

```
1```

## 样例 #3

### 输入

```
acba```

### 输出

```
6```

## 样例 #4

### 输入

```
chokudai```

### 输出

```
54```

【算法分类】
动态规划

【题解分析与结论】
这道题的核心是通过动态规划来计算所有可能的子字符串数量，且这些子字符串中的字符在原字符串中不相邻。大多数题解都采用了类似的状态转移方程，即 $dp_{i,j}$ 表示前 $i$ 个字符中以字符 $j$ 结尾的子字符串数量。当 $s_i = j$ 时，$dp_{i,j}$ 可以从 $dp_{i-2,k}$ 转移过来，并加上当前字符单独作为一个子字符串的情况；当 $s_i \neq j$ 时，$dp_{i,j}$ 直接从 $dp_{i-1,j}$ 转移过来。

【评分较高的题解】

1. **作者：StevenLiTheOIer (赞：2)**
   - **星级：4**
   - **关键亮点：** 使用了前缀和优化，使得状态转移更加高效，代码简洁明了。
   - **核心代码：**
     ```cpp
     for (int i = 2; i <= n; i++) {
         for (int j = 0; j < 26; j++) {
             if (s[i - 1] != j + 'a') dp[i][j] = dp[i - 1][j];
             else dp[i][j] = (sum[i - 2] + 1) % mod;
             sum[i] = (sum[i] + dp[i][j]) % mod;
         }
     }
     ```

2. **作者：CQ_Bab (赞：1)**
   - **星级：4**
   - **关键亮点：** 在状态转移中引入了 $f_{i,26}$ 来存储前 $i$ 个字符的总方案数，使得代码更加简洁。
   - **核心代码：**
     ```cpp
     rep(i,2,n) {
         rep(j,0,25) {
             if(s[i]!=j+'a') f[i][j]=f[i-1][j];
             else f[i][j]=(f[i-2][26]+1)%mod;
             f[i][26]+=f[i][j];
             f[i][26]%=mod;
         }
     }
     ```

3. **作者：wth2026 (赞：0)**
   - **星级：4**
   - **关键亮点：** 使用了 $Sm_i$ 来存储前 $i$ 个字符的总方案数，代码结构清晰，易于理解。
   - **核心代码：**
     ```cpp
     for (register int i = 2; i <= n; ++ i) {
         for (register int j = 0; j ^ 26; ++ j) {
             if (x[i] ^ (j + 97)) {
                 f[i][j] = f[i - 1][j];
             } else {
                 f[i][j] = (_Sm[i - 2] + 1) % mod;
             }
             _Sm[i] += f[i][j];
             _Sm[i] %= mod;
         }
     }
     ```

【最优关键思路或技巧】
- **状态转移方程：** 使用 $dp_{i,j}$ 表示前 $i$ 个字符中以字符 $j$ 结尾的子字符串数量，通过分类讨论 $s_i$ 是否等于 $j$ 来进行状态转移。
- **前缀和优化：** 使用前缀和或总方案数来优化状态转移，减少时间复杂度。

【可拓展之处】
- 类似的问题可以扩展到更复杂的字符串处理，如允许某些字符重复或限制某些字符的出现次数。

【推荐题目】
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1077 摆花](https://www.luogu.com.cn/problem/P1077)

【个人心得摘录】
- **StevenLiTheOIer：** 通过前缀和优化，使得状态转移更加高效，代码简洁明了。
- **CQ_Bab：** 在状态转移中引入了 $f_{i,26}$ 来存储前 $i$ 个字符的总方案数，使得代码更加简洁。
- **wth2026：** 使用了 $Sm_i$ 来存储前 $i$ 个字符的总方案数，代码结构清晰，易于理解。

---
处理用时：40.57秒
# 题目信息

# [ABC215E] Chain Contestant

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc215/tasks/abc215_e

別世界の AtCoder では現在、 AAC, ..., AJC の $ 10 $ 種類のコンテストが開催されており、これから $ N $ 回のコンテストが開催されます。  
 各コンテストの種類は文字列 $ S $ として与えられ、 $ S $ の $ i $ 文字目が $ x $ なら $ i $ 回目には A$ x $C が開催されます。  
 シカの AtCoDeer くんは、 $ N $ 個のコンテストから $ 1 $ 個以上いくつか選んで、以下の条件を満たすように選んで出場します。

- 出るコンテストを順番を保ったまま抜き出したとき、コンテストの種類ごとにひとかたまりとなっている。
  - 厳密には、 AtCoDeer くんが $ x $ 個のコンテストに出場し、そのうち $ i $ 回目のコンテストの種類が $ T_i $ であるとき、全ての $ 1\ \le\ i\ <\ j\ <\ k\ \le\ x $ を満たす整数組 $ (i,j,k) $ に対して、 $ T_i=T_k $ であるならば $ T_i=T_j $ でなければならない。

AtCoDeer くんが出場するコンテストの選び方として考えられるものの総数を $ 998244353 $ で割った余りを求めてください。  
 ただし、 $ 2 $ つのコンテストの選び方が異なるとは、あるコンテスト $ c $ が存在して、片方の選び方では $ c $ に出場するがもう片方の選び方では出場しないということを指します。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 1000 $
- $ |S|=N $
- $ S $ は `A` から `J` までの英大文字のみからなる

### Sample Explanation 1

例えば、 $ 1,3 $ 回目のコンテストに出場する、 $ 2,4 $ 回目のコンテストに出場するという選び方は条件を満たします。 一方、 $ 1,2,3,4 $ 回目のコンテストに出場する場合、 ABC への出場がひとかたまりになっておらず、整数組 $ (i,j,k)=(1,2,3) $ について条件に違反します。 また、全てのコンテストに出場しないということも認められません。 問題文の条件に適する出場するコンテストの選び方は $ 13 $ 通りあります。

### Sample Explanation 2

総数を $ 998244353 $ で割った余りを求めることに注意してください。

## 样例 #1

### 输入

```
4

BGBH```

### 输出

```
13```

## 样例 #2

### 输入

```
100

BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBIEIJEIJIJCGCCFGIEBIHFCGFBFAEJIEJAJJHHEBBBJJJGJJJCCCBAAADCEHIIFEHHBGF```

### 输出

```
330219020```

# AI分析结果

### 题目内容重写
在另一个世界的 AtCoder 中，目前有 10 种不同类型的比赛（AAC, ..., AJC）正在举办，接下来将举办 $N$ 场比赛。每场比赛的类型由字符串 $S$ 给出，$S$ 的第 $i$ 个字符为 $x$ 表示第 $i$ 场比赛是 A$x$C。AtCoDeer 需要从这 $N$ 场比赛中选择至少一场参加，且满足以下条件：

- 选出的比赛顺序保持原顺序，且每种比赛类型必须连续出现。  
  - 严格来说，如果 AtCoDeer 选择了 $x$ 场比赛，其中第 $i$ 场比赛的类型为 $T_i$，那么对于所有满足 $1 \le i < j < k \le x$ 的整数三元组 $(i,j,k)$，如果 $T_i = T_k$，则必须有 $T_i = T_j$。

求 AtCoDeer 选择比赛的方式总数，结果对 $998244353$ 取模。

### 算法分类
动态规划、状压 DP

### 题解分析与结论
本题的核心是通过动态规划和状态压缩来处理字符串中的字符选择问题。由于字符种类有限（A~J），可以使用二进制状态表示字符的选择情况，并通过 DP 状态转移来确保字符的连续性。

### 精选题解
#### 1. 作者：AlicX (4星)
**关键亮点：**
- 使用三维 DP 状态 $f_{i,s,j}$ 表示前 $i$ 个字符，选择状态为 $s$，最后一个字符为 $j$ 的方案数。
- 通过前缀和优化转移，时间复杂度为 $O(nm2^m)$，其中 $m=10$。
- 代码结构清晰，状态转移逻辑明确。

**个人心得：**
- 调试时发现 `(s&w)==w` 写成了 `s&w==w`，导致错误，提醒了代码细节的重要性。

**核心代码：**
```cpp
for(int i=2;i<=n;i++){ 
    int x=a[i]-'A',w=1<<x; 
    for(int s=0;s<M;s++){ 
        if((s&w)==w){ 
            f[i][s][x]=(f[i][s][x]+g[s][x])%Mod; 
            continue; 
        } int sx=s|w;  
        for(int j=0;j<K;j++) if(j!=x) f[i][sx][x]=(f[i][sx][x]+g[s][j])%Mod; 
    } for(int s=0;s<M;s++) for(int j=0;j<K;j++) g[s][j]=(g[s][j]+f[i][s][j])%Mod; 	
}
```

#### 2. 作者：liangbowen (4星)
**关键亮点：**
- 使用二维 DP 状态 $dp_{i,s}$ 表示选择第 $i$ 个字符，选择状态为 $s$ 的方案数。
- 通过刷表法进行状态转移，时间复杂度为 $O(n^2 2^T)$，其中 $T$ 是字符种类数。
- 代码简洁，转移逻辑清晰。

**核心代码：**
```cpp
for(int s=0;s<(1<<10);s++)
    for(int i=1;i<=n;i++)
        if(s&(1<<a[i]))
            for(int j=i+1;j<=n;j++) {
                if(a[i]==a[j]) (dp[j][s]+=dp[i][s])%mod;
                else if(!(s&(1<<a[j]))) (dp[j][s|(1<<a[j])]+=dp[i][s])%mod;
            }
```

#### 3. 作者：XuYueming (4星)
**关键亮点：**
- 使用滚动数组优化空间，状态转移时通过维护 $g_s$ 来快速计算 $\sum f_{s,k}$。
- 时间复杂度优化到 $O(n 2^{|\Omega|})$，且通过枚举子集进一步优化常数。
- 代码实现高效，逻辑清晰。

**核心代码：**
```cpp
for(int i=2;i<=n;i++){ 
    int ST=((1<<M)-1)^1<<val[i]; 
    for(int S=ST;;S=(S-1)&ST){ 
        int st=S|1<<val[i]; 
        toadd(g[st],dp[st][val[i]]); 
        toadd(g[st],g[st^1<<val[i]]); 
        toadd(dp[st][val[i]],dp[st][val[i]]); 
        toadd(dp[st][val[i]],g[st^1<<val[i]]); 
        if(!S) break; 
    } 
    toadd(dp[1<<val[i]][val[i]],1); 
    toadd(g[1<<val[i]],1); 
}
```

### 最优关键思路
- **状态压缩**：利用二进制状态表示字符的选择情况，简化状态表示。
- **滚动数组优化**：通过滚动数组减少空间复杂度，同时优化时间复杂度。
- **前缀和优化**：通过维护前缀和数组，快速计算状态转移值，减少重复计算。

### 可拓展之处
- 类似问题可以扩展到更长的字符串或更多的字符种类，通过优化状态转移和空间复杂度来提升效率。
- 可以结合其他 DP 优化技巧，如斜率优化、四边形不等式等，进一步提升算法效率。

### 推荐题目
1. [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P2704 [NOI2001]炮兵阵地](https://www.luogu.com.cn/problem/P2704)
3. [P2831 [NOIP2016 提高组]愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)

---
处理用时：39.14秒
# 题目信息

# [ABC215F] Dist Max 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc215/tasks/abc215_f

$ 2 $ 次元平面上の $ N $ 個の相異なる点が与えられます。点 $ i\,\ (1\ \leq\ i\ \leq\ N) $ の座標は $ (x_i,y_i) $ です。

$ 2 $ つの点 $ i,j\,\ (1\ \leq\ i,j\ \leq\ N) $ の距離を $ \mathrm{min}\ (|x_i-x_j|,|y_i-y_j|) $ 、すなわち $ x $ 座標の差と $ y $ 座標の差の小さい方と定義します。

異なる $ 2 $ つの点の距離の最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 200000 $
- $ 0\ \leq\ x_i,y_i\ \leq\ 10^9 $
- $ (x_i,y_i) $ $ \neq $ $ (x_j,y_j) $ $ (i\ \neq\ j) $
- 入力は全て整数である。

### Sample Explanation 1

点 $ 1 $ と点 $ 2 $ の距離は $ 2 $ 、点 $ 1 $ と点 $ 3 $ の距離は $ 4 $ 、点 $ 2 $ と点 $ 3 $ の距離は $ 1 $ です。よって $ 4 $ を出力してください。

## 样例 #1

### 输入

```
3

0 3

3 1

4 10```

### 输出

```
4```

## 样例 #2

### 输入

```
4

0 1

0 4

0 10

0 6```

### 输出

```
0```

## 样例 #3

### 输入

```
8

897 729

802 969

765 184

992 887

1 104

521 641

220 909

380 378```

### 输出

```
801```

# AI分析结果

### 题目内容重写
**题目描述**

给定二维平面上的 \( N \) 个不同的点。点 \( i \)（\( 1 \leq i \leq N \)）的坐标为 \( (x_i, y_i) \)。

定义两个点 \( i, j \)（\( 1 \leq i, j \leq N \)）的距离为 \( \min(|x_i - x_j|, |y_i - y_j|) \)，即 \( x \) 坐标的差与 \( y \) 坐标的差中的较小者。

求不同两点之间距离的最大值。

**说明/提示**

**约束条件**

- \( 2 \leq N \leq 200000 \)
- \( 0 \leq x_i, y_i \leq 10^9 \)
- \( (x_i, y_i) \neq (x_j, y_j) \)（\( i \neq j \)）
- 输入均为整数。

**样例解释 1**

点 1 和点 2 的距离为 2，点 1 和点 3 的距离为 4，点 2 和点 3 的距离为 1。因此输出 4。

**样例 1**

**输入**

```
3
0 3
3 1
4 10
```

**输出**

```
4
```

**样例 2**

**输入**

```
4
0 1
0 4
0 10
0 6
```

**输出**

```
0
```

**样例 3**

**输入**

```
8
897 729
802 969
765 184
992 887
1 104
521 641
220 909
380 378
```

**输出**

```
801
```

### 算法分类
二分

### 题解分析与结论
本题的核心思路是通过二分答案来寻找最大距离。由于直接枚举所有点对的时间复杂度为 \( O(N^2) \)，无法在时间限制内完成，因此采用二分答案的方法将时间复杂度降低到 \( O(N \log V) \)，其中 \( V \) 是值域范围。

各题解的主要思路是：
1. **二分答案**：通过二分法枚举可能的距离值 \( mid \)，然后检查是否存在两个点满足 \( \min(|x_i - x_j|, |y_i - y_j|) \geq mid \)。
2. **双指针优化**：在检查过程中，使用双指针维护满足 \( |x_i - x_j| \geq mid \) 的区间，并在该区间内检查 \( y \) 坐标的差值是否满足条件。
3. **排序预处理**：为了使用双指针，首先对点按 \( x \) 坐标进行排序。

### 高星题解推荐
1. **作者：白简 (5星)**
   - **关键亮点**：思路清晰，代码简洁，详细解释了双指针的维护过程，并给出了时间复杂度分析。
   - **核心代码**：
     ```cpp
     bool check(int mid) {
         int minv = 1e14, maxv = 0;
         for (int l = 1, r = 1; r <= n; r++) {
             while (l < r && a[r].x - a[l].x >= mid) {
                 minv = min(minv, a[l].y);
                 maxv = max(maxv, a[l].y);
                 l++;
             }
             if (maxv - a[r].y >= mid) return true;
             if (a[r].y - minv >= mid) return true;
         }
         return false;
     }
     ```

2. **作者：zhujiangyuan (4星)**
   - **关键亮点**：代码实现较为简洁，详细解释了双指针的维护过程，并给出了时间复杂度分析。
   - **核心代码**：
     ```cpp
     bool check (LL delta) {
         LL minv = 1e14, maxv = 0;
         for (int l = 1, r = 1; r <= n; r++) {
             while (l < r && a[r].x - a[l].x >= delta) {
                 minv = min (minv, a[l].y);
                 maxv = max (maxv, a[l].y);
                 l++;
             }
             if (maxv - a[r].y >= delta) return true;
             if (a[r].y - minv >= delta) return true;
         }
         return false;
     }
     ```

3. **作者：_zzzzzzy_ (4星)**
   - **关键亮点**：代码实现简洁，详细解释了双指针的维护过程，并给出了时间复杂度分析。
   - **核心代码**：
     ```cpp
     bool f(int x){
         int mx=LONG_LONG_MIN,mn=LONG_LONG_MAX;
         for(int i=1,j=1;i<=n;i++){
             while(j<i&&a[i].first-a[j].first>=x){
                 mx=max(mx,a[j].second);
                 mn=min(mn,a[j].second);
                 j++;
             }
             if(mx-x>=a[i].second)return 1;
             if(mn+x<=a[i].second)return 1;
         }
         return 0;
     }
     ```

### 最优关键思路
1. **二分答案**：通过二分法枚举可能的距离值，将问题转化为判定性问题。
2. **双指针优化**：使用双指针维护满足 \( |x_i - x_j| \geq mid \) 的区间，并在该区间内检查 \( y \) 坐标的差值是否满足条件。
3. **排序预处理**：对点按 \( x \) 坐标进行排序，以便使用双指针。

### 拓展思路
类似的问题可以通过二分答案和双指针优化来解决，例如在数组中寻找满足某些条件的最优解。此外，二分答案的思路可以应用于其他需要寻找最大值或最小值的问题。

### 推荐题目
1. [P1873 砍树](https://www.luogu.com.cn/problem/P1873)
2. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)

---
处理用时：42.56秒
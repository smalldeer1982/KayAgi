# 题目信息

# [ABC216F] Max Sum Counting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc216/tasks/abc216_f

長さ $ N $ の数列 $ A\ =\ (A_1,\ \dots,\ A_N),\ B\ =\ (B_1,\ \dots,\ B_N) $ が与えられます。$ \{1,2,\ldots,N\} $ の空でない部分集合 $ S $ であって、以下の条件を満たすものの個数を数えてください。

- $ \max_{i\ \in\ S}\ A_i\ \geq\ \sum_{i\ \in\ S}\ B_i $

なお、答えは非常に大きくなることがあるため、$ 998244353 $ で割ったあまりを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5000 $
- $ 1\ \leq\ A_i,B_i\ \leq\ 5000 $
- 入力は全て整数

### Sample Explanation 1

$ \{1,2,\ldots,N\} $ の空でない部分集合としてあり得るものは、$ \{1\} $, $ \{2\} $, $ \{1,2\} $ の $ 3 $ 通りです。 - $ S=\{1\} $ のとき $ \max_{i\ \in\ S}\ A_i=3 $, $ \sum_{i\ \in\ S}\ B_i=1 $ - $ S=\{2\} $ のとき $ \max_{i\ \in\ S}\ A_i=1 $, $ \sum_{i\ \in\ S}\ B_i=2 $ - $ S=\{1,2\} $ のとき $ \max_{i\ \in\ S}\ A_i=3 $, $ \sum_{i\ \in\ S}\ B_i=3 $ であるため、問題文中の条件、即ち $ \max_{i\ \in\ S}\ A_i\ \geq\ \sum_{i\ \in\ S}\ B_i $ を満たす $ S $ は $ \{1\} $ と $ \{1,2\} $ の $ 2 $ 通りです。

### Sample Explanation 2

条件を満たす $ S $ が存在しない場合もあります。

## 样例 #1

### 输入

```
2

3 1

1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2

1 1

2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
20

1937 3980 2689 1208 3640 1979 581 2271 4229 3948 3708 1522 4161 4661 3797 96 3388 3395 2920 2247

4485 2580 174 1156 3770 3396 3558 3500 3494 479 269 3383 1230 1711 3545 3919 134 475 3796 1017```

### 输出

```
476```

# AI分析结果

### 题目内容重写
# [ABC216F] Max Sum Counting

## 题目描述

给定长度为 $ N $ 的数列 $ A\ =\ (A_1,\ \dots,\ A_N),\ B\ =\ (B_1,\ \dots,\ B_N) $。求 $ \{1,2,\ldots,N\} $ 的非空子集 $ S $ 的个数，满足以下条件：

- $ \max_{i\ \in\ S}\ A_i\ \geq\ \sum_{i\ \in\ S}\ B_i $

由于答案可能非常大，输出时对 $ 998244353 $ 取模。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5000 $
- $ 1\ \leq\ A_i,B_i\ \leq\ 5000 $
- 输入均为整数

### 样例解释 1

$ \{1,2,\ldots,N\} $ 的非空子集有 $ \{1\} $, $ \{2\} $, $ \{1,2\} $ 三种情况。  
- $ S=\{1\} $ 时，$ \max_{i\ \in\ S}\ A_i=3 $, $ \sum_{i\ \in\ S}\ B_i=1 $  
- $ S=\{2\} $ 时，$ \max_{i\ \in\ S}\ A_i=1 $, $ \sum_{i\ \in\ S}\ B_i=2 $  
- $ S=\{1,2\} $ 时，$ \max_{i\ \in\ S}\ A_i=3 $, $ \sum_{i\ \in\ S}\ B_i=3 $  
因此，满足条件的子集为 $ \{1\} $ 和 $ \{1,2\} $，共 $ 2 $ 个。

### 样例解释 2

有时可能不存在满足条件的子集。

## 样例 #1

### 输入

```
2

3 1

1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2

1 1

2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
20

1937 3980 2689 1208 3640 1979 581 2271 4229 3948 3708 1522 4161 4661 3797 96 3388 3395 2920 2247

4485 2580 174 1156 3770 3396 3558 3500 3494 479 269 3383 1230 1711 3545 3919 134 475 3796 1017```

### 输出

```
476```

### 算法分类
动态规划

### 题解分析与结论
本题的核心是通过动态规划来解决子集选择问题，主要思路是将数组按照 $A_i$ 排序，然后使用背包动态规划来计算满足条件的子集数量。难点在于如何有效地处理 $\max$ 和 $\sum$ 的关系，以及如何优化空间和时间复杂度。

### 所选高分题解
#### 1. 作者：liuruian (赞：3)
- **星级**: 4
- **关键亮点**: 通过排序和背包动态规划，时间复杂度为 $O(n^2)$，思路清晰，代码简洁。
- **代码核心思想**:
  ```cpp
  sort(nm+1,nm+n+1,cmp);//排序
  dp[0][0]=1;
  for(int i=1;i<=n;i++){
      dp[i][0]=1;
      for(int j=0;j<=nm[i].a-nm[i].b;j++) ans=(ans+dp[i-1][j])%md;//加上贡献
      for(int j=nm[i].b;j<=5000;j++) dp[i][j]=(dp[i][j]+dp[i-1][j-nm[i].b])%md;
      for(int j=1;j<=5000;j++) dp[i][j]=(dp[i][j]+dp[i-1][j])%md;
  }//背包
  ```

#### 2. 作者：wangyibo201026 (赞：3)
- **星级**: 4
- **关键亮点**: 通过排序和前缀和优化，将复杂度优化到 $O(n^2)$，代码实现较为直观。
- **代码核心思想**:
  ```cpp
  sort ( a + 1, a + 1 + n, cmp );
  sum[0] = 1;
  lep ( i, 1, n ) {
      lep ( j, a[i].y, 5000 ) {
          f[i][j] = sum[j - a[i].y];
      }
      lep ( j, a[i].y, 5000 ) {
          sum[j] += f[i][j];
          sum[j] %= mod;
      }
      lep ( j, 0, a[i].x ) {
          ans += f[i][j];
          ans %= mod;
      }
  }
  ```

#### 3. 作者：WaterSun (赞：1)
- **星级**: 4
- **关键亮点**: 通过定义 $dp_{i,j,0/1}$ 来表示选择或不选择当前元素，状态转移方程清晰，代码结构良好。
- **代码核心思想**:
  ```cpp
  sort(arr + 1,arr + n + 1);
  for (re int i = 1;i <= n;i++){
      for (re int j = 0;j <= arr[n].fst;j++){
          dp[i][j][0] = (dp[i - 1][j][0] + dp[i - 1][j][1]) % mod;
          if (j >= arr[i].snd) dp[i][j][1] = (dp[i - 1][j - arr[i].snd][0] + dp[i - 1][j - arr[i].snd][1]) % mod;
      }
  }
  ```

### 最优关键思路与技巧
1. **排序**: 将数组按照 $A_i$ 排序，确保在遍历时当前 $A_i$ 是最大值。
2. **背包动态规划**: 使用背包动态规划来计算子集的和，并通过前缀和优化来减少时间复杂度。
3. **状态转移**: 通过定义状态 $dp_{i,j,0/1}$ 来表示选择或不选择当前元素，确保每个子集只被统计一次。

### 可拓展之处
类似的问题可以通过排序和动态规划来解决，特别是涉及到子集选择和条件限制的题目。例如，可以扩展到多维背包问题或更复杂的条件限制。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

### 个人心得摘录
- **调试经历**: 在实现动态规划时，需要注意边界条件和状态转移的正确性，特别是在处理模运算时。
- **踩坑教训**: 排序后要确保 $A_i$ 的最大值在遍历时被正确处理，否则会导致错误的结果。
- **顿悟感想**: 通过排序和动态规划的结合，可以有效地解决复杂的子集选择问题，关键在于如何定义状态和转移方程。

---
处理用时：53.38秒
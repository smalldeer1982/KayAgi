# 题目信息

# [ABC216G] 01Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc216/tasks/abc216_g

`0` と `1` のみからなる長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ であって、以下の条件を満たすものを考えます。

> すべての $ i=1,2,\dots,M $ について、$ A_{L_i}, A_{L_i+1},\dots\ ,A_{R_i} $ に `1` が $ X_i $ 個以上含まれる

条件を満たす数列 $ A $ のうち、含まれる `1` の数が**最も少ない**例を $ 1 $ つ出力してください。

なお、制約のもとで条件を満たす数列 $ A $ は必ず存在します。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min(2\ \times\ 10^5,\ \frac{N(N+1)}{2}\ ) $
- $ 1\ \leq\ L_i\ \leq\ R_i\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ R_i-L_i+1 $
- $ i\ \neq\ j $ ならば $ (L_i,R_i)\ \neq\ (L_j,R_j) $
- 入力は全て整数

### Sample Explanation 1

`1 1 0 1 1 0` などの答えも正解です。 `0 1 1 1 1 1` などの答えは含まれる `1` の数が最小化されていないので、不正解です。

## 样例 #1

### 输入

```
6 3

1 4 3

2 2 1

4 6 2```

### 输出

```
0 1 1 1 0 1```

## 样例 #2

### 输入

```
8 2

2 6 1

3 5 3```

### 输出

```
0 0 1 1 1 0 0 0```

# AI分析结果

### 题目内容重写（中文）

你需要构造一个长度为 $N$ 的由 `0` 和 `1` 组成的序列 $A=(A_1,A_2,\dots,A_N)$，满足以下条件：

- 对于所有的 $i=1,2,\dots,M$，序列 $A$ 在区间 $[L_i, R_i]$ 内的 `1` 的个数至少为 $X_i$。

你需要找到满足条件的序列 $A$，并且使得其中 `1` 的个数最少。输出任意一个满足条件的序列即可。

### 算法分类
差分约束

### 题解分析与结论

本题的核心是通过差分约束系统来构造满足条件的序列，并使得 `1` 的个数最少。大多数题解采用了差分约束的思路，通过将问题转化为图论中的最短路问题，利用 Dijkstra 或 SPFA 算法求解。部分题解还结合了贪心策略，通过排序和树状数组来优化求解过程。

### 精选题解

#### 题解1：fjy666 (★★★★★)
**关键亮点**：
- 通过差分约束系统将问题转化为最短路问题，使用 Dijkstra 算法求解。
- 通过统计 `0` 的个数来避免负权边，优化了算法的复杂度。
- 代码简洁，思路清晰。

**核心代码**：
```cpp
for(int i=1;i<=m;i++){
    cin>>u>>v>>w;
    G[u].push_back({v-u+1-w,v+1});
}
for(int i=0;i<=n;i++){
    G[i+1].push_back({0,i});
    G[i].push_back({1,i+1});
}
```
**实现思想**：通过构建差分约束图，使用 Dijkstra 算法求解最短路，最终输出结果。

#### 题解2：_HCl_ (★★★★☆)
**关键亮点**：
- 详细解释了差分约束系统的构建过程，并通过 Dijkstra 算法求解。
- 通过将 `1` 的个数转化为 `0` 的个数，避免了负权边的问题。
- 代码实现较为完整，注释清晰。

**核心代码**：
```cpp
for(int i=1;i<=m;++i){
    int l,r,x;
    scanf("%d%d%d",&l,&r,&x);
    e[l-1].push_back(edge{r,r-l+1-x});
}
for(int i=1;i<=n;++i){
    e[i-1].push_back(edge{i,1});
    e[i].push_back(edge{i-1,0});
}
```
**实现思想**：通过构建差分约束图，使用 Dijkstra 算法求解最短路，最终输出结果。

#### 题解3：SunsetSamsara (★★★★☆)
**关键亮点**：
- 提供了贪心和差分约束两种解法，思路多样。
- 贪心解法通过排序和树状数组优化了求解过程。
- 代码实现较为完整，注释清晰。

**核心代码**：
```cpp
for(int i=1;i<=m;i++){
    int x=bit.sum(a[i].l,a[i].r);
    if(x<a[i].x){
        a[i].x-=x;
        for(int j=F(a[i].r);j>=a[i].l&&a[i].x;j=F(j)){
            bit.add(j,1);
            a[i].x--;
            f[j]=F(j-1);
            ans[j]=1;
        }
    }
}
```
**实现思想**：通过贪心策略，使用树状数组和并查集优化求解过程，最终输出结果。

### 最优关键思路
通过差分约束系统将问题转化为图论中的最短路问题，使用 Dijkstra 算法求解。通过统计 `0` 的个数来避免负权边，优化了算法的复杂度。

### 可拓展之处
类似的问题可以通过差分约束系统转化为图论问题，使用最短路算法求解。还可以结合贪心策略，通过排序和树状数组等数据结构优化求解过程。

### 推荐题目
1. [P1250 种树](https://www.luogu.com.cn/problem/P1250)
2. [P1645 序列](https://www.luogu.com.cn/problem/P1645)
3. [P1986 元旦晚会](https://www.luogu.com.cn/problem/P1986)

### 个人心得摘录
- **fjy666**：通过统计 `0` 的个数来避免负权边，优化了算法的复杂度。
- **_HCl_**：详细解释了差分约束系统的构建过程，并通过 Dijkstra 算法求解。
- **SunsetSamsara**：提供了贪心和差分约束两种解法，思路多样。

---
处理用时：32.20秒
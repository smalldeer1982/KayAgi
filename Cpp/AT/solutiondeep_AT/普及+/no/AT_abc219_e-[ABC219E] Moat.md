# 题目信息

# [ABC219E] Moat

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc219/tasks/abc219_e

$ xy $ -平面上のいくつかの点に村があります。  
 高橋君はこれらの村を民兵や魔女などの外敵から守るため、これらのすべての村を囲むようなお堀を建設します。

$ 0 $ と $ 1 $ からなる $ 4\ \times\ 4 $ 行列 $ A\ =\ (A_{i,\ j}) $ が与えられます。  
 $ A_{i,\ j}\ =\ 1 $ を満たす整数の組 $ (i,\ j) $ $ (1\ \leq\ i,\ j\ \leq\ 4) $ ごとに、座標 $ (i-0.5,\ j-0.5) $ に村があります。

お堀は平面上の多角形です。 高橋君は以下の条件をすべて満たすお堀を建設します（入力例１・出力例１の説明も参考にして下さい）。

1. 自己交差がない
2. 内部にすべての村を含む
3. すべての頂点の $ x $ 座標と $ y $ 座標は $ 0 $ 以上 $ 4 $ 以下の整数
4. すべての辺は $ x $ 軸と $ y $ 軸のどちらかに平行
5. それぞれの内角の大きさは $ 90 $ 度または $ 270 $ 度

高橋君が建設するお堀として考えられるものが何通りあるかを出力して下さい。

## 说明/提示

### 制約

- $ A_{i,\ j}\ \in\ \lbrace\ 0,\ 1\rbrace $
- $ A_{i,\ j}\ =\ 1 $ となる $ (i,\ j) $ が少なくとも $ 1 $ つ存在する

### Sample Explanation 1

下記の $ 2 $ つの画像の例は、高橋君が建設する**お堀の条件を満たします**。 

![](https://img.atcoder.jp/ghi/7b3181deb4e1df72e4c0661b1137db4d.png)
![](https://img.atcoder.jp/ghi/a1e46c7db32d63942caa7119a4f3a593.png) 

下記の $ 4 $ つの画像の例は、高橋君が建設する**お堀の条件を満たしません**。 
![](https://img.atcoder.jp/ghi/335053c01a13eb99e55767a3dc02eb38.png)
![](https://img.atcoder.jp/ghi/c4df3d1fa24557b0d4d94ac0eaa8b9ab.png)
![](https://img.atcoder.jp/ghi/be93de595e9222d5e20c90bd28d24563.png)
![](https://img.atcoder.jp/ghi/37dac3af065c013ce0b8c0ee7591b97a.png) 

上記の $ 4 $ つの例が高橋君の建設するお堀の条件を満たさない理由は、以下の通りです。 - $ 1 $ つ目の画像の例は、「自己交差がない」という条件を満たしません。 - $ 2 $ つ目の画像の例は、「内部にすべての村を含む」という条件を満たしません。 - $ 3 $ つ目の画像の例は、「すべての頂点の $ x $ 座標と $ y $ 座標は $ 0 $ 以上 $ 4 $ 以下の整数」という条件を満たしません。（座標が整数でない頂点があります。） - $ 4 $ つ目の画像の例は、「すべての辺は $ x $ 軸と $ y $ 軸のどちらかに平行」という条件を満たしません。

## 样例 #1

### 输入

```
1 0 0 0

0 0 1 0

0 0 0 0

1 0 0 0```

### 输出

```
1272```

## 样例 #2

### 输入

```
1 1 1 1

1 1 1 1

1 1 1 1

1 1 1 1```

### 输出

```
1```

# AI分析结果

### 题目内容重写

**题目描述**

在 $xy$ 平面上的某些点上有村庄。高桥君为了保护这些村庄免受民兵、魔女等外敌的侵害，决定建造一个包围所有村庄的护城河。

给定一个由 $0$ 和 $1$ 组成的 $4 \times 4$ 矩阵 $A = (A_{i,j})$。对于满足 $A_{i,j} = 1$ 的整数对 $(i,j)$（$1 \leq i,j \leq 4$），在坐标 $(i-0.5, j-0.5)$ 处有一个村庄。

护城河是平面上的一个多边形。高桥君建造的护城河必须满足以下所有条件（请参考输入样例1和输出样例1的说明）：

1. 护城河没有自交点。
2. 护城河内部包含所有村庄。
3. 护城河的所有顶点的 $x$ 和 $y$ 坐标都是 $0$ 以上 $4$ 以下的整数。
4. 护城河的所有边都与 $x$ 轴或 $y$ 轴平行。
5. 护城河的每个内角都是 $90$ 度或 $270$ 度。

请输出高桥君可以建造的护城河的方案数。

**说明/提示**

**约束条件**

- $A_{i,j} \in \{0, 1\}$
- 至少存在一个 $(i,j)$ 满足 $A_{i,j} = 1$

**样例解释1**

下图中的两个例子满足高桥君建造护城河的条件：

![](https://img.atcoder.jp/ghi/7b3181deb4e1df72e4c0661b1137db4d.png)
![](https://img.atcoder.jp/ghi/a1e46c7db32d63942caa7119a4f3a593.png)

下图中的四个例子不满足高桥君建造护城河的条件：

![](https://img.atcoder.jp/ghi/335053c01a13eb99e55767a3dc02eb38.png)
![](https://img.atcoder.jp/ghi/c4df3d1fa24557b0d4d94ac0eaa8b9ab.png)
![](https://img.atcoder.jp/ghi/be93de595e9222d5e20c90bd28d24563.png)
![](https://img.atcoder.jp/ghi/37dac3af065c013ce0b8c0ee7591b97a.png)

上述四个例子不满足条件的原因如下：

- 第一个例子不满足“护城河没有自交点”的条件。
- 第二个例子不满足“护城河内部包含所有村庄”的条件。
- 第三个例子不满足“护城河的所有顶点的 $x$ 和 $y$ 坐标都是 $0$ 以上 $4$ 以下的整数”的条件（存在非整数坐标的顶点）。
- 第四个例子不满足“护城河的所有边都与 $x$ 轴或 $y$ 轴平行”的条件。

**样例1**

**输入**

```
1 0 0 0

0 0 1 0

0 0 0 0

1 0 0 0
```

**输出**

```
1272
```

**样例2**

**输入**

```
1 1 1 1

1 1 1 1

1 1 1 1

1 1 1 1
```

**输出**

```
1
```

### 算法分类
**枚举**

### 题解分析与结论

该题的核心思路是通过枚举所有可能的护城河方案，并检查这些方案是否满足题目的所有条件。由于矩阵的大小为 $4 \times 4$，总共有 $2^{16}$ 种可能的方案，因此可以通过暴力枚举来解决。

### 所选高星题解

#### 1. 作者：2020luke (★★★★☆)
**关键亮点**：
- 使用洪水填充法（Flood Fill）来检查护城河的连通性。
- 通过枚举所有可能的护城河方案，并逐一检查是否满足条件。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
void flood(int x, int y) {
    queue< PII > q;
    q.push({x, y});
    while(!q.empty()) {
        int xx = q.front().fir, yy = q.front().sec;
        q.pop();
        for(int i = 0; i < 4; i++) {
            int nx = xx + dx[i], ny = yy + dy[i];
            if(flag[nx][ny] && !f[nx][ny]) {
                f[nx][ny] = true;
                q.push({nx, ny});
            }
        }
    }
}
```
**核心思想**：通过洪水填充法检查护城河的连通性，确保所有被包围的格子是连通的。

#### 2. 作者：ZBH_123 (★★★★☆)
**关键亮点**：
- 使用状态压缩 DP 的思路，通过二进制枚举护城河的覆盖区域。
- 通过 DFS 检查护城河的连通性和是否包含所有村庄。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
bool dfs_cycle(int x, int y) {
    if(x<1||y<1||x>4||y>4) return true;
    if(b[x][y]==1) return false;
    vis[x][y]=true;
    bool flag=false;
    for(int i=0;i<4;i++) {
        int xx=x+l[i],yy=y+r[i];
        if(vis[xx][yy]==true) continue;
        flag|=dfs_cycle(xx,yy);
    }
    return flag;
}
```
**核心思想**：通过 DFS 检查护城河是否形成环，确保护城河没有自交点。

#### 3. 作者：mojoege (★★★★☆)
**关键亮点**：
- 使用并查集来检查护城河的连通性。
- 通过枚举所有可能的护城河方案，并逐一检查是否满足条件。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int dfs1(int x, int y) {
    if (x <= 0 || x > n || y <= 0 || y > n) return 1;
    if (b[x][y]) return 0;
    vis[x][y] = 1;
    int flag = 0;
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (vis[nx][ny]) continue;
        flag |= dfs1(nx, ny);
    }
    return flag;
}
```
**核心思想**：通过 DFS 检查护城河是否形成环，确保护城河没有自交点。

### 最优关键思路或技巧
- **洪水填充法**：用于检查护城河的连通性，确保所有被包围的格子是连通的。
- **状态压缩**：通过二进制枚举护城河的覆盖区域，减少枚举的复杂度。
- **并查集**：用于检查护城河的连通性，确保护城河没有自交点。

### 可拓展之处
- 类似的问题可以通过枚举所有可能的方案，并结合洪水填充法或并查集来检查方案的合法性。
- 可以扩展到更大的矩阵或更复杂的条件，但需要注意枚举的复杂度和算法的优化。

### 推荐题目
1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得摘录
- **调试经历**：在枚举过程中，需要注意边界条件的处理，特别是在检查护城河是否形成环时，容易忽略边界情况。
- **踩坑教训**：在洪水填充法中，如果未正确处理边界条件，可能导致错误的连通性判断。
- **顿悟感想**：通过状态压缩和并查集的结合，可以有效地减少枚举的复杂度，提高算法的效率。

---
处理用时：54.58秒
# 题目信息

# [ABC220F] Distance Sums 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc220/tasks/abc220_f

$ N $ 頂点の木が与えられます。頂点には $ 1,2,\ldots\ ,N $ の番号がついており、$ i $ 番目の辺は頂点 $ u_i,v_i $ を結ぶ無向辺です。

各整数 $ i\,(1\ \leq\ i\ \leq\ N) $ に対して、$ \sum_{j=1}^{N}dis(i,j) $ を求めてください。

ただし、$ dis(i,j) $ は頂点 $ i $ から頂点 $ j $ に到達する際にたどる必要のある最小の辺数です。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i\ <\ v_i\ \leq\ N $
- 与えられるグラフは木
- 入力は全て整数

### Sample Explanation 1

$ dis(1,1)+dis(1,2)+dis(1,3)=0+1+2=3 $、 $ dis(2,1)+dis(2,2)+dis(2,3)=1+0+1=2 $、 $ dis(3,1)+dis(3,2)+dis(3,3)=2+1+0=3 $、 です。

## 样例 #1

### 输入

```
3

1 2

2 3```

### 输出

```
3

2

3```

## 样例 #2

### 输入

```
2

1 2```

### 输出

```
1

1```

## 样例 #3

### 输入

```
6

1 6

1 5

1 3

1 4

1 2```

### 输出

```
5

9

9

9

9

9```

# AI分析结果

【题目内容】
# [ABC220F] Distance Sums 2

## 题目描述

给定一个包含 $N$ 个顶点的树。顶点编号为 $1,2,\ldots\ ,N$，第 $i$ 条边连接顶点 $u_i$ 和 $v_i$。

对于每个整数 $i\,(1\ \leq\ i\ \leq\ N)$，求 $\sum_{j=1}^{N}dis(i,j)$ 的值。

其中，$dis(i,j)$ 表示从顶点 $i$ 到顶点 $j$ 所需经过的最小边数。

## 说明/提示

### 制約

- $2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $1\ \leq\ u_i\ <\ v_i\ \leq\ N $
- 给定的图是树
- 输入均为整数

### 样例解释 1

$ dis(1,1)+dis(1,2)+dis(1,3)=0+1+2=3 $、 $ dis(2,1)+dis(2,2)+dis(2,3)=1+0+1=2 $、 $ dis(3,1)+dis(3,2)+dis(3,3)=2+1+0=3 $。

## 样例 #1

### 输入

```
3

1 2

2 3```

### 输出

```
3

2

3```

## 样例 #2

### 输入

```
2

1 2```

### 输出

```
1

1```

## 样例 #3

### 输入

```
6

1 6

1 5

1 3

1 4

1 2```

### 输出

```
5

9

9

9

9

9```

【算法分类】
动态规划（换根DP）

【题解分析与结论】
本题的核心是要求每个节点作为根节点时，所有节点到该节点的距离之和。由于直接对每个节点进行DFS会导致时间复杂度为O(N^2)，无法通过本题的约束条件。因此，采用换根DP的思想，通过两次DFS来优化计算。

换根DP的关键在于通过已知的父节点的答案，推导出子节点的答案。具体来说，当根从父节点u转移到子节点v时，v的子树中的节点距离减少1，而其他节点的距离增加1。因此，可以通过父节点的答案和子树大小来快速计算子节点的答案。

【评分较高的题解】
1. **作者：zjinze (赞：5)**
   - **星级：5**
   - **关键亮点：**
     - 清晰地定义了dp[i]、siz[i]和dep[i]的含义，并详细解释了换根DP的推导过程。
     - 代码结构清晰，逻辑严谨，易于理解。
   - **核心代码：**
     ```cpp
     void dfs1(int x,int fa){
         siz[x]=1;
         if(fa!=0)dep[x]=dep[fa]+1;
         for(int j=0;j<ve[x].size();j++){
             int to=ve[x][j];
             if(to!=fa){
                 dfs1(to,x);
                 siz[x]+=siz[to];
             }
         }
     }
     void dfs2(int x,int fa){
         for(int j=0;j<ve[x].size();j++){
             int to=ve[x][j];
             if(to!=fa){
                 dp[to]=dp[x]-2*siz[to]+n;
                 dfs2(to,x);
             }
         }
     }
     ```

2. **作者：__YSC__ (赞：2)**
   - **星级：4**
   - **关键亮点：**
     - 通过图示直观地解释了换根DP的转移过程，帮助理解。
     - 代码简洁，逻辑清晰，适合初学者理解换根DP的思想。
   - **核心代码：**
     ```cpp
     void dfs(int u, int fa, long long dis) {
         sum += dis;
         sz[u] = 1;
         for(int v : e[u]) {
             if(v != fa) {
                 dfs(v, u, dis + 1);
                 sz[u] += sz[v];
             }
         }
     }
     void DFS(int u, int fa) {
         for(int v : e[u]) {
             if(v != fa) {
                 ans[v] = ans[u] + n - 2ll * sz[v];
                 DFS(v, u);
             }
         }
     }
     ```

3. **作者：ruanwentao666 (赞：0)**
   - **星级：4**
   - **关键亮点：**
     - 详细推导了状态转移方程，并解释了换根DP的核心思想。
     - 代码实现简洁，逻辑清晰，适合理解换根DP的推导过程。
   - **核心代码：**
     ```cpp
     void dfs(int u, int fa) {
         s[u] = 1;
         d[u] = d[fa] + 1;
         for (int i = 0; i < g[u].size(); i++) {
             int v = g[u][i];
             if (v != fa) {
                 dfs(v, u);
                 s[u] += s[v];
             }
         }
     }
     void dfs2(int u, int fa) {
         for (int i = 0; i < g[u].size(); i++) {
             int v = g[u][i];
             if (v != fa) {
                 f[v] = f[u] + n - 2 * s[v];
                 dfs2(v, u);
             }
         }
     }
     ```

【最优关键思路或技巧】
- **换根DP**：通过两次DFS，第一次计算以某个节点为根时的子树大小和深度，第二次通过父节点的答案推导出子节点的答案，避免了重复计算，将时间复杂度优化到O(N)。
- **状态转移方程**：`dp[v] = dp[u] + n - 2 * siz[v]`，其中`dp[v]`表示以v为根时的距离和，`dp[u]`表示以u为根时的距离和，`siz[v]`表示以v为根的子树大小。

【可拓展之处】
- 换根DP不仅适用于树中距离和的计算，还可以用于其他树形DP问题，如求树的直径、最大子树和等。
- 类似的问题可以通过换根DP的思想进行优化，避免重复计算。

【推荐题目】
1. [P1395 会议](https://www.luogu.com.cn/problem/P1395)
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)
3. [P3177 树上染色](https://www.luogu.com.cn/problem/P3177)

【个人心得】
- **调试经历**：在实现换根DP时，需要注意子树大小的计算和状态转移的正确性，尤其是在处理边界条件时。
- **踩坑教训**：在第一次DFS时，必须正确计算每个节点的子树大小和深度，否则会影响第二次DFS的结果。
- **顿悟感想**：换根DP的核心在于通过已知的父节点答案推导出子节点答案，避免了重复计算，大大提高了效率。

---
处理用时：47.39秒
# 题目信息

# [ABC222E] Red and Blue Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc222/tasks/abc222_e

$ N $ 頂点の木と、長さ $ M $ の数列 $ A=(A_1,\ldots,A_M) $、整数 $ K $ が与えられます。  
 木の頂点には $ 1 $ から $ N $ の番号がつけられており、$ i $ 番目の辺は頂点 $ U_i $ と $ V_i $ を結んでいます。

この木の $ N-1 $ 個の辺をそれぞれ赤か青のどちらかに塗ります。そのような方法は $ 2^{N-1} $ 通りありますが、そのうち次の条件を満たすような塗り方の個数を $ 998244353 $ で割った余りを求めてください。

条件：  
 最初、駒を頂点 $ A_1 $ におく。$ i=1,\ldots,M-1 $ の順に、駒を頂点 $ A_i $ から頂点 $ A_{i+1} $ まで、辺をたどって最短経路で動かす。 これらの操作を最後まで行ったとき、赤く塗られた辺を通過した回数を $ R $、青く塗られた辺を通過した回数を $ B $ とすると、$ R-B=K $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 1000 $
- $ 2\ \leq\ M\ \leq\ 100 $
- $ |K|\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ N $
- $ 1\leq\ U_i,V_i\leq\ N $
- 与えられるグラフは木である
- 入力に含まれる値は全て整数である

### Sample Explanation 1

$ 1,3 $ 番目の辺を赤く、$ 2 $ 番目の辺を青く塗ったとき、 - 頂点 $ 2 $ から頂点 $ 3 $ への移動で赤い辺を $ 0 $ 回、青い辺を $ 1 $ 回 - 頂点 $ 3 $ から頂点 $ 2 $ への移動で赤い辺を $ 0 $ 回、青い辺を $ 1 $ 回 - 頂点 $ 2 $ から頂点 $ 1 $ への移動で赤い辺を $ 1 $ 回、青い辺を $ 0 $ 回 - 頂点 $ 1 $ から頂点 $ 4 $ への移動で赤い辺を $ 2 $ 回、青い辺を $ 1 $ 回 それぞれ通過し、全体では赤い辺を $ 3 $ 回、青い辺を $ 3 $ 回通るため、条件を満たします。 !\[図\](https://img.atcoder.jp/ghi/f9b2b199fb6eedaca02e15ff556b72b1.png) この他、$ 1,3 $ 番目の辺を青く、$ 2 $ 番目の辺を赤く塗るときも条件を満たし、これら以外の塗り方は条件を満たさないため、答えは $ 2 $ 通りです。

### Sample Explanation 2

条件を満たす塗り方が存在しないこともあります。

## 样例 #1

### 输入

```
4 5 0

2 3 2 1 4

1 2

2 3

3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
3 10 10000

1 2 1 2 1 2 2 1 1 2

1 2

1 3```

### 输出

```
0```

## 样例 #3

### 输入

```
10 2 -1

1 10

1 2

2 3

3 4

4 5

5 6

6 7

7 8

8 9

9 10```

### 输出

```
126```

## 样例 #4

### 输入

```
5 8 -1

1 4 1 4 2 1 3 5

1 2

4 1

3 1

1 5```

### 输出

```
2```

# AI分析结果

### 题目内容重写

**题目描述**

给定一棵有 $N$ 个顶点的树，一个长度为 $M$ 的数列 $A=(A_1,\ldots,A_M)$，以及一个整数 $K$。树的顶点编号为 $1$ 到 $N$，第 $i$ 条边连接顶点 $U_i$ 和 $V_i$。

将这棵树的 $N-1$ 条边分别涂成红色或蓝色。总共有 $2^{N-1}$ 种涂法，求满足以下条件的涂法数量，结果对 $998244353$ 取模。

**条件：**

初始时，将棋子放在顶点 $A_1$。依次从 $A_i$ 移动到 $A_{i+1}$（$i=1,\ldots,M-1$），沿着最短路径移动。最终，设红色边被经过的次数为 $R$，蓝色边被经过的次数为 $B$，要求 $R - B = K$。

### 算法分类

**动态规划**

### 题解分析与结论

#### 题解1：_zzzzzzy_ (3星)

**关键亮点：**
- 使用DFS计算每条边被经过的次数。
- 将问题转化为背包问题，通过动态规划求解。

**核心实现思想：**
- 通过DFS遍历树，计算每条边被经过的次数。
- 使用背包问题的动态规划方法，计算满足条件的涂法数量。

**代码片段：**
```cpp
int dp[maxn];
dp[0] = 1;
for(int i=1;i<n;i++){
    for(int j=sum;j>=c[i];j--){
        dp[j]=(dp[j]+dp[j-c[i]])%mod;
    }
}
cout<<dp[sum];
```

#### 题解2：Endline (4星)

**关键亮点：**
- 使用树链剖分和差分维护每条边被经过的次数。
- 通过动态规划求解，使用滚动数组优化空间。

**核心实现思想：**
- 使用树链剖分和差分数组维护每条边被经过的次数。
- 通过动态规划求解，使用滚动数组优化空间。

**代码片段：**
```cpp
int dp[2][200002];
dp[1][100000] = 1;
for(int i=2;i<=n;i++){
    for(int j=w[i];j<=200000-w[i];j++){
        dp[i&1][j]=(dp[(i&1)^1][j-w[i]]+dp[(i&1)^1][j+w[i]])%mod;
    }
}
printf("%d\n",dp[n&1][100000+k]);
```

#### 题解3：ben090302 (4星)

**关键亮点：**
- 使用树链剖分和差分维护每条边被经过的次数。
- 通过动态规划求解，使用滚动数组优化空间。

**核心实现思想：**
- 使用树链剖分和差分数组维护每条边被经过的次数。
- 通过动态规划求解，使用滚动数组优化空间。

**代码片段：**
```cpp
int dp[2][200005];
dp[0][W] = 1;
for(int i=1;i<n;i++) {
    for(int j=0;j<=W*2;j++){
        dp[i&1][j]=0;
        if(j-w[i]>=0)  dp[i&1][j]+=dp[i&1^1][j-w[i]];
        if(j+w[i]<=W*2)dp[i&1][j]+=dp[i&1^1][j+w[i]];
        dp[i&1][j]%=mod;
    }
}
cout<<dp[(n-1)&1][k+W];
```

### 最优关键思路与技巧

1. **树链剖分与差分**：通过树链剖分和差分数组高效计算每条边被经过的次数。
2. **动态规划与滚动数组**：将问题转化为背包问题，使用动态规划求解，并通过滚动数组优化空间。

### 可拓展之处

- **类似问题**：可以拓展到其他树上路径统计问题，如计算路径上特定属性的边数。
- **算法套路**：树链剖分和差分数组的组合可以用于解决多种树上路径问题。

### 推荐题目

1. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)

### 个人心得摘录

- **调试经历**：在实现树链剖分时，注意处理好边的编号和节点的对应关系，避免混淆。
- **踩坑教训**：在使用差分数组时，注意边界条件的处理，避免数组越界。
- **顿悟感想**：通过滚动数组优化空间，可以有效减少内存使用，提高代码效率。

---
处理用时：32.85秒
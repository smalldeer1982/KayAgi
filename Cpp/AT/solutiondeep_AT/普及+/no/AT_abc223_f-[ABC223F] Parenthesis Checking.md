# 题目信息

# [ABC223F] Parenthesis Checking

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc223/tasks/abc223_f

以下のいずれかの条件を満たす文字列を**正しい括弧列**と定義します。

- 空文字列
- ある**正しい括弧列** $ A $ が存在して、`(`, $ A $, `)` をこの順に連結した文字列
- ある空でない**正しい括弧列** $ A $, $ B $ が存在して、$ A $, $ B $ をこの順に連結した文字列

`(` と `)` のみからなる長さ $ N $ の文字列 $ S $ があります。

$ Q $ 個のクエリ $ \text{Query}_1,\text{Query}_2,\ldots,\text{Query}_Q $ が与えられるので、順番に処理してください。クエリには $ 2 $ 種類があり、入力形式とクエリの内容は以下の通りです。

- `1 l r` : $ S $ の $ l $ 文字目と $ r $ 文字目を入れ替える。
- `2 l r` : $ S $ の $ l $ 文字目から $ r $ 文字目までの連続部分文字列が**正しい括弧列**であるか判定する。

## 说明/提示

### 制約

- $ 1\ \leq\ N,Q\ \leq\ 2\ \times\ 10^5 $
- $ S $ は `(` と `)` のみからなる長さ $ N $ の文字列
- $ 1\ \leq\ l\ <\ r\ \leq\ N $
- $ N,Q,l,r $ はいずれも整数
- 各クエリは `1 l r`、`2 l r` のいずれかの形式で与えられる。
- `2 l r` の形式のクエリは $ 1 $ つ以上与えられる。

### Sample Explanation 1

$ 1 $ つ目のクエリにおいて、`(())` は\*\*正しい括弧列\*\*です。 $ 2 $ つ目のクエリにおいて、`((` は\*\*正しい括弧列\*\*ではありません。 $ 3 $ つ目のクエリにおいて、`)(` は\*\*正しい括弧列\*\*ではありません。

### Sample Explanation 2

$ 1 $ つ目のクエリにおいて、`(())` は\*\*正しい括弧列\*\*です。 $ 2 $ つ目のクエリによって、$ S $ は `)()((` となります。 $ 3 $ つ目のクエリにおいて、`)()(` は\*\*正しい括弧列\*\*ではありません。

## 样例 #1

### 输入

```
5 3

(())(

2 1 4

2 1 2

2 4 5```

### 输出

```
Yes

No

No```

## 样例 #2

### 输入

```
5 3

(())(

2 1 4

1 1 4

2 1 4```

### 输出

```
Yes

No```

## 样例 #3

### 输入

```
8 8

(()(()))

2 2 7

2 2 8

1 2 5

2 3 4

1 3 4

1 3 5

1 1 4

1 6 8```

### 输出

```
Yes

No

No```

# AI分析结果

### 题目翻译
#### [ABC223F] 括号检查

### 题目描述

定义一个字符串为**正确的括号序列**，当且仅当满足以下任一条件：

- 空字符串
- 存在一个**正确的括号序列** $ A $，使得 `(`, $ A $, `)` 按顺序连接而成的字符串
- 存在两个非空的**正确的括号序列** $ A $ 和 $ B $，使得 $ A $ 和 $ B $ 按顺序连接而成的字符串

给定一个由 `(` 和 `)` 组成的长为 $ N $ 的字符串 $ S $。

有 $ Q $ 个查询 $ \text{Query}_1,\text{Query}_2,\ldots,\text{Query}_Q $，请依次处理。查询有两种类型，输入格式和查询内容如下：

- `1 l r` : 交换 $ S $ 的第 $ l $ 个字符和第 $ r $ 个字符。
- `2 l r` : 判断 $ S $ 的第 $ l $ 个字符到第 $ r $ 个字符之间的子串是否为**正确的括号序列**。

### 说明/提示

#### 约束

- $ 1\ \leq\ N,Q\ \leq\ 2\ \times\ 10^5 $
- $ S $ 是由 `(` 和 `)` 组成的长为 $ N $ 的字符串
- $ 1\ \leq\ l\ <\ r\ \leq\ N $
- $ N,Q,l,r $ 均为整数
- 每个查询为 `1 l r` 或 `2 l r` 的形式。
- `2 l r` 形式的查询至少有一个。

### 样例 #1

#### 输入

```
5 3

(())(

2 1 4

2 1 2

2 4 5```

#### 输出

```
Yes

No

No```

### 样例 #2

#### 输入

```
5 3

(())(

2 1 4

1 1 4

2 1 4```

#### 输出

```
Yes

No```

### 样例 #3

#### 输入

```
8 8

(()(()))

2 2 7

2 2 8

1 2 5

2 3 4

1 3 4

1 3 5

1 1 4

1 6 8```

#### 输出

```
Yes

No

No```

### 算法分类
字符串、线段树

### 题解分析与总结

#### 核心思路
1. **合法括号序列的判断**：将左括号视为 `1`，右括号视为 `-1`，合法括号序列需满足：
   - 整个序列的和为 `0`。
   - 任意前缀和均大于等于 `0`。
2. **线段树维护**：使用线段树维护前缀和数组，支持区间最小值查询和区间加减操作。
3. **交换操作的处理**：交换两个位置的字符时，根据字符类型对前缀和数组进行相应的区间加减操作。

#### 难点对比
- **2huk** 的题解详细解释了如何通过线段树维护前缀和数组，并处理交换操作，思路清晰，代码实现较为完整。
- **_ZML_** 的题解在实现上较为简洁，但在处理交换操作时没有详细说明如何更新前缀和数组，代码可读性稍差。
- **OPEC** 的题解思路与 **2huk** 类似，但在代码实现上较为冗长，且没有详细解释如何处理交换操作。

#### 最优思路
**2huk** 的题解提供了最清晰的思路和完整的代码实现，详细解释了如何通过线段树维护前缀和数组，并处理交换操作，适合初学者理解和学习。

### 精选题解

#### 题解1：2huk（★★★★★）
**关键亮点**：
- 详细解释了合法括号序列的判断条件。
- 使用线段树维护前缀和数组，支持区间最小值查询和区间加减操作。
- 详细说明了如何处理交换操作，思路清晰，代码实现完整。

**核心代码**：
```cpp
void update(int p, int l, int r, int val) {
    if (tr[p].l >= l && tr[p].r <= r) {
        tr[p].sum += val * (tr[p].r - tr[p].l + 1);
        tr[p].lazy += val;
        return;
    }
    pushdown(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) update(p << 1, l, r, val);
    if (r > mid) update(p << 1 | 1, l, r, val);
    pushup(p);
}
```

### 拓展思路
- **类似题目**：可以扩展到其他需要维护区间信息的字符串问题，如最长合法括号子串等。
- **优化技巧**：在处理区间加减操作时，可以使用懒标记优化线段树的更新操作。

### 推荐题目
1. [P1040 最长合法括号子串](https://www.luogu.com.cn/problem/P1040)
2. [P1041 括号匹配](https://www.luogu.com.cn/problem/P1041)
3. [P1042 括号序列](https://www.luogu.com.cn/problem/P1042)

---
处理用时：38.13秒
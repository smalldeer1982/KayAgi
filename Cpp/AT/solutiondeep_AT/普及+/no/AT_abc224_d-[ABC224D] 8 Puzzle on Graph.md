# 题目信息

# [ABC224D] 8 Puzzle on Graph

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc224/tasks/abc224_d

高橋君は道端であるパズルを拾いました。  
 このパズルは、$ 9 $ 個の頂点と $ M $ 本の辺からなる無向グラフ、および、$ 8 $ つのコマで構成されます。

グラフの $ 9 $ つの頂点はそれぞれ頂点 $ 1 $、頂点 $ 2 $、$ \ldots $、頂点 $ 9 $ と呼ばれ、 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結んでいます。  
 $ 8 $ つのコマはそれぞれコマ $ 1 $、コマ $ 2 $、$ \ldots $、コマ $ 8 $ と呼ばれ、 $ j\ =\ 1,\ 2,\ \ldots,\ 8 $ について、コマ $ j $ は頂点 $ p_j $ に置かれています。 ここで、すべてのコマはそれぞれ異なる頂点に置かれていることが保証されます。 コマが置かれていない「空の頂点」がただ一つ存在することに注意してください。

高橋君はこのパズルに対して下記の操作を好きな回数（ $ 0 $ 回でもよい）だけ行うことができます。

> 空の頂点に隣接する頂点に置かれたコマを $ 1 $ つ選び、選んだコマを空の頂点に移動する。

高橋君は上記の操作を繰り返して、このパズルを「完成」させようとしています。 パズルは、下記の状態を満たしたときに完成となります。

> $ j\ =\ 1,\ 2,\ \ldots,\ 8 $ について、コマ $ j $ は 頂点 $ j $ に置かれている。

高橋君がパズルを完成させることが可能かどうかを判定し、可能な場合はそのために必要な操作回数の最小値を出力してください。

## 说明/提示

### 制約

- $ 0\ \leq\ M\ \leq\ 36 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ 9 $
- 与えられるグラフは多重辺、自己ループを持たない
- $ 1\ \leq\ p_j\ \leq\ 9 $
- $ j\ \neq\ j'\ \Rightarrow\ p_j\ \neq\ p_{j'} $
- 入力はすべて整数

### Sample Explanation 1

下記の手順によって、$ 5 $ 回の操作でパズルを完成させることができます。 1. コマ $ 2 $ を頂点 $ 9 $ から頂点 $ 1 $ に移動する。 2. コマ $ 3 $ を頂点 $ 2 $ から頂点 $ 9 $ に移動する。 3. コマ $ 2 $ を頂点 $ 1 $ から頂点 $ 2 $ に移動する。 4. コマ $ 1 $ を頂点 $ 3 $ から頂点 $ 1 $ に移動する。 5. コマ $ 3 $ を頂点 $ 9 $ から頂点 $ 3 $ に移動する。 一方、$ 5 $ 回未満の操作でパズルを完成させることはできません。よって、$ 5 $ を出力します。 与えられるグラフは連結とは限らないことに注意してください。

### Sample Explanation 2

パズルは初めから完成しています。よって、完成させるために必要な操作回数の最小値は $ 0 $ 回です。

### Sample Explanation 3

操作の繰り返しによってパズルを完成させることができないので、$ -1 $ を出力します。

## 样例 #1

### 输入

```
5

1 2

1 3

1 9

2 9

3 9

3 9 2 4 5 6 7 8```

### 输出

```
5```

## 样例 #2

### 输入

```
5

1 2

1 3

1 9

2 9

3 9

1 2 3 4 5 6 7 8```

### 输出

```
0```

## 样例 #3

### 输入

```
12

8 5

9 6

4 5

4 1

2 5

8 9

2 1

3 6

8 7

6 5

7 4

2 3

1 2 3 4 5 6 8 7```

### 输出

```
-1```

## 样例 #4

### 输入

```
12

6 5

5 4

4 1

4 7

8 5

2 1

2 5

6 9

3 6

9 8

8 7

3 2

2 3 4 6 1 9 7 8```

### 输出

```
16```

# AI分析结果

### 题目内容重写

高橋君在路边捡到了一个拼图。  
这个拼图由一个包含 $9$ 个顶点和 $M$ 条边的无向图，以及 $8$ 个棋子组成。

图的 $9$ 个顶点分别称为顶点 $1$、顶点 $2$、……、顶点 $9$，对于 $i = 1, 2, \ldots, M$，第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$。  
$8$ 个棋子分别称为棋子 $1$、棋子 $2$、……、棋子 $8$，对于 $j = 1, 2, \ldots, 8$，棋子 $j$ 被放置在顶点 $p_j$ 上。这里保证所有棋子都放置在不同的顶点上。注意，存在一个没有放置棋子的“空顶点”。

高橋君可以对拼图进行以下操作，操作次数不限（包括 $0$ 次）：

> 选择一个与空顶点相邻的顶点上的棋子，将其移动到空顶点。

高橋君希望通过重复上述操作，将拼图“完成”。拼图在满足以下状态时完成：

> 对于 $j = 1, 2, \ldots, 8$，棋子 $j$ 被放置在顶点 $j$ 上。

请判断高橋君是否能够完成拼图，如果能够完成，输出所需的最少操作次数。

### 算法分类
广度优先搜索 BFS

### 题解分析与结论

本题的核心是通过 BFS 搜索从初始状态到目标状态的最短路径。由于状态数较多（最多 $9!$ 种），需要高效的状态表示和去重。各题解的主要思路是通过字符串或数字表示当前状态，并使用 BFS 进行状态转移。

### 精选题解

#### 1. 作者：M_WC1S_M0 (赞：3)  
**星级：4**  
**关键亮点：**  
- 使用字符串表示状态，简洁直观。
- 通过 BFS 搜索状态空间，使用 `map` 记录状态的最小步数。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
string str="999999999"; //一开始都没有摆棋子
for(int i=1,pos;i<=8;i++){
    cin>>pos;
    str[pos-1]=i+'0'; //读入第 i 个棋子的位置后替换相应位置
}

mp[str]=1;
q.push(str);

while(!q.empty()){
    str=q.front();
    q.pop();

    int u=1;
    for(int i=0;i<9;i++){
        if(str[i]=='9'){
            u+=i; //找到没有棋子的顶点的位置
            break;
        }
    }

    for(auto v:G[u]){
        string n_str=str;
        swap(n_str[u-1],n_str[v-1]);
        
        if(mp[n_str]){
            continue;
        }

        mp[n_str]=mp[str]+1;
        q.push(n_str);
    }
}

if(!mp["123456789"]) cout<<-1<<"\n"; //如果没有走过，就说明无法到达
else cout<<mp["123456789"]-1<<"\n";
```

#### 2. 作者：JWRuixi (赞：0)  
**星级：4**  
**关键亮点：**  
- 使用双向 BFS 优化搜索效率，减少状态扩展次数。
- 使用 `__gnu_pbds::gp_hash_table` 作为哈希表，提高查找效率。
- 代码实现较为高效，适合大规模状态搜索。

**核心代码：**
```cpp
inline int enc () {
	int x = 0;
	for (int i = 1, j = 1; i < 10; i++, j *= 10) x += p[i] * j;
	return x;
}
inline void dec (int x) {
	for (int i = 1; i < 10; i++, x /= 10) p[i] = x % 10;
}

int main() {
	n = read();
	for (int i = 1; i <= n; i++) {
		int u = read(), v = read();
		G[u].emplace_back(v);
		G[v].emplace_back(u);
	}
	for (int i = 1; i < 9; i++) p[read()] = i;
	queue<int> q;
	q.push(enc()), d[enc()] = 0, vis[enc()] = 1;
	q.push(87654321), d[87654321] = 1, vis[87654321] = 2;
	if (enc() == 87654321) return puts("0"), 0;
	while (!q.empty()) {
		int u = q.front(); q.pop();
		dec(u);
		int pos = 0;
		for (int i = 1; i < 10; i++) if (!p[i]) { pos = i; break; }
		for (int v : G[pos]) {
			swap(p[v], p[pos]);
			int x = enc();
			swap(p[v], p[pos]);
			if (vis[x] + vis[u] == 3) return write(d[x] + d[u]), 0;
			else if (vis[x] == vis[u]) continue;
			q.push(x), d[x] = d[u] + 1, vis[x] = vis[u];
		}
	}
	puts("-1");
}
```

#### 3. 作者：loser_seele (赞：0)  
**星级：4**  
**关键亮点：**  
- 使用 `unordered_map` 进行状态记录，提高查找效率。
- 代码简洁，适合快速实现 BFS 搜索。
- 状态转移逻辑清晰，易于理解。

**核心代码：**
```cpp
string s="999999999";
int p;
for(int i=1;i<=8;i++){
    cin>>p;
    s[p-1]=i+'0';
}
queue<string>q;
q.push(s);
unordered_map<string,int>mp;
mp[s]=1;
while(!q.empty()){
    string s=q.front();
    q.pop();
    int u=0;
    for(int i=0;i<9;i++) 
        if(s[i]=='9') 
            u=i+1;
    for (auto v:a[u]){
        string t=s;
        swap(t[u-1],t[v-1]);
        if(mp[t]) 
            continue;
        mp[t]=mp[s]+1;
        q.push(t);
    }
}
if(!mp["123456789"]) 
    cout<<"-1";
else 
    cout<<mp["123456789"]-1;
```

### 最优关键思路与技巧
1. **状态表示**：使用字符串或数字表示当前棋子的位置状态，便于存储和比较。
2. **BFS 搜索**：通过 BFS 搜索从初始状态到目标状态的最短路径，确保找到最小操作次数。
3. **去重优化**：使用 `map` 或 `unordered_map` 记录已访问状态，避免重复扩展。
4. **双向 BFS**：从初始状态和目标状态同时进行 BFS，减少搜索空间，提高效率。

### 拓展思路
类似的问题可以扩展到其他拼图游戏或状态转移问题，如八数码问题、华容道等。关键在于如何高效地表示状态和进行状态转移。

### 推荐题目
1. [P1379 八数码问题](https://www.luogu.com.cn/problem/P1379)
2. [P2324 [SCOI2005] 骑士精神](https://www.luogu.com.cn/problem/P2324)
3. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)

---
处理用时：47.64秒
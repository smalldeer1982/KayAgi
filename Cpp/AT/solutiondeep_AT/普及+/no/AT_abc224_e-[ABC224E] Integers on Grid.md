# 题目信息

# [ABC224E] Integers on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc224/tasks/abc224_e

縦 $ H $ 行、横 $ W $ 列のマス目があります。上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,\ j) $ と呼びます。

それぞれのマスには整数が書かれています。 $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、マス $ (r_i,\ c_i) $ には正整数 $ a_i $ が書かれており、それら以外のマスには $ 0 $ が書かれています。

はじめ、マス $ (R,\ C) $ にコマが置かれています。 高橋君は、コマを「いま置かれているマスから別のマスに移動させる」ことを好きな回数だけ行うことができます。 ただし、コマを移動する際には下記の $ 2 $ つの条件をともに満たさなければなりません。

- 移動先のマスに書かれている整数は、移動前のマスに書かれている整数より真に大きい。
- 移動先のマスは移動前のマスと同じ行にある、または、移動先のマスは移動前のマスと同じ列にある。

$ i\ =\ 1,\ 2,\ \ldots,\ N $ のそれぞれについて、$ (R,\ C)\ =\ (r_i,\ c_i) $ の場合に高橋君がコマの移動を行うことができる回数の最大値を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ \min(2\ \times\ 10^5,\ HW) $
- $ 1\ \leq\ r_i\ \leq\ H $
- $ 1\ \leq\ c_i\ \leq\ W $
- $ 1\ \leq\ a_i\ \leq\ 10^9 $
- $ i\ \neq\ j\ \Rightarrow\ (r_i,\ c_i)\ \neq\ (r_j,\ c_j) $
- 入力はすべて整数

### Sample Explanation 1

マス目に書かれた整数は下記の通りです。 ``` 4 7 0 3 0 5 2 5 5 ``` - $ (R,\ C)\ =\ (r_1,\ c_1)\ =\ (1,\ 1) $ の場合、$ (1,\ 1)\ \rightarrow\ (1,\ 2) $ と移動すると、コマの移動を $ 1 $ 回行うことができます。 - $ (R,\ C)\ =\ (r_2,\ c_2)\ =\ (1,\ 2) $ の場合、一度もコマの移動を行うことができません。 - $ (R,\ C)\ =\ (r_3,\ c_3)\ =\ (2,\ 1) $ の場合、$ (2,\ 1)\ \rightarrow\ (1,\ 1)\ \rightarrow\ (1,\ 2) $ と移動すると、コマの移動を $ 2 $ 回行うことができます。 - $ (R,\ C)\ =\ (r_4,\ c_4)\ =\ (2,\ 3) $ の場合、一度もコマの移動を行うことができません。 - $ (R,\ C)\ =\ (r_5,\ c_5)\ =\ (3,\ 1) $ の場合、$ (3,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (1,\ 1)\ \rightarrow\ (1,\ 2) $ と移動すると、コマの移動を $ 3 $ 回行うことができます。 - $ (R,\ C)\ =\ (r_6,\ c_6)\ =\ (3,\ 2) $ の場合、$ (3,\ 2)\ \rightarrow\ (1,\ 2) $ と移動すると、コマの移動を $ 1 $ 回行うことができます。 - $ (R,\ C)\ =\ (r_7,\ c_7)\ =\ (3,\ 3) $ の場合、一度もコマの移動を行うことができません。

## 样例 #1

### 输入

```
3 3 7

1 1 4

1 2 7

2 1 3

2 3 5

3 1 2

3 2 5

3 3 5```

### 输出

```
1

0

2

0

3

1

0```

## 样例 #2

### 输入

```
5 7 20

2 7 8

2 6 4

4 1 9

1 5 4

2 2 7

5 5 2

1 7 2

4 6 6

1 4 1

2 1 10

5 6 9

5 3 3

3 7 9

3 6 3

4 3 4

3 3 10

4 2 1

3 5 4

1 2 6

4 7 9```

### 输出

```
2

4

1

5

3

6

6

2

7

0

0

4

1

5

3

0

5

2

4

0```

# AI分析结果

### 题目内容重写

#### [ABC224E] Integers on Grid

**题目描述**

有一个 $H$ 行 $W$ 列的网格。从上到下第 $i$ 行、从左到右第 $j$ 列的格子称为格子 $(i, j)$。

每个格子上写有一个整数。对于 $i = 1, 2, \ldots, N$，格子 $(r_i, c_i)$ 上写有正整数 $a_i$，其他格子上写有 $0$。

初始时，棋子在格子 $(R, C)$ 上。高桥君可以将棋子从当前格子移动到另一个格子，移动次数不限。移动时必须满足以下两个条件：

1. 移动到的格子上的整数必须严格大于当前格子上的整数。
2. 移动到的格子必须与当前格子在同一行或同一列。

对于每个 $i = 1, 2, \ldots, N$，当 $(R, C) = (r_i, c_i)$ 时，输出高桥君最多可以进行多少次移动。

**说明/提示**

**约束条件**

- $2 \leq H, W \leq 2 \times 10^5$
- $1 \leq N \leq \min(2 \times 10^5, HW)$
- $1 \leq r_i \leq H$
- $1 \leq c_i \leq W$
- $1 \leq a_i \leq 10^9$
- $i \neq j \Rightarrow (r_i, c_i) \neq (r_j, c_j)$
- 输入均为整数

**样例解释**

网格上的整数如下：

```
4 7 0
3 0 5
2 5 5
```

- 当 $(R, C) = (1, 1)$ 时，可以移动一次：$(1, 1) \rightarrow (1, 2)$。
- 当 $(R, C) = (1, 2)$ 时，无法移动。
- 当 $(R, C) = (2, 1)$ 时，可以移动两次：$(2, 1) \rightarrow (1, 1) \rightarrow (1, 2)$。
- 当 $(R, C) = (2, 3)$ 时，无法移动。
- 当 $(R, C) = (3, 1)$ 时，可以移动三次：$(3, 1) \rightarrow (2, 1) \rightarrow (1, 1) \rightarrow (1, 2)$。
- 当 $(R, C) = (3, 2)$ 时，可以移动一次：$(3, 2) \rightarrow (1, 2)$。
- 当 $(R, C) = (3, 3)$ 时，无法移动。

### 算法分类

**动态规划**

### 题解分析与结论

本题的核心是通过动态规划来计算每个格子最多可以移动的次数。由于移动的条件是必须移动到同一行或同一列且数值更大的格子，因此可以将问题转化为在行和列上分别维护最大值，并通过排序和状态转移来求解。

### 评分较高的题解

#### 1. 作者：M_WC1S_M0 (赞：3)

**星级：4星**

**关键亮点：**

- 使用 `rmax` 和 `cmax` 分别记录每行和每列的最大移动次数。
- 通过排序和状态转移，避免了重复计算，提高了效率。
- 代码简洁，逻辑清晰。

**核心代码：**

```cpp
for(auto p:mp){
    vector<int> now=p.second;
    for(auto v:now){
        f[v]=max(f[v],max(rmax[r[v]],cmax[c[v]]));
    }
    for(auto v:now){
        rmax[r[v]]=max(rmax[r[v]],f[v]+1);
        cmax[c[v]]=max(cmax[c[v]],f[v]+1);
    }
}
```

#### 2. 作者：I_LOVE_MATH (赞：1)

**星级：4星**

**关键亮点：**

- 使用 DAG 上的动态规划，避免了建图的复杂度。
- 通过从大到小排序，消除了后效性。
- 处理了相同数值的情况，确保了正确性。

**核心代码：**

```cpp
for (int i = n; i >= 1; i--) {
    if (q[i].w < c[q[i].x][0]) {
        dp[q[i].id] = a[q[i].x][0] + 1;
        c[q[i].x][1] = c[q[i].x][0];
        c[q[i].x][0] = q[i].w;
        a[q[i].x][1] = a[q[i].x][0];
    } else {
        dp[q[i].id] = a[q[i].x][1] + 1;
    }
    // 列同理
}
```

#### 3. 作者：封禁用户 (赞：1)

**星级：4星**

**关键亮点：**

- 使用 `row` 和 `column` 分别记录每行和每列的最大移动次数。
- 通过延迟更新，避免了重复计算。
- 代码结构清晰，易于理解。

**核心代码：**

```cpp
for(int i=1;i<=n;++i){
    if(mk[i].s==mk[i-1].s){
        f[mk[i].id]=max(row[mk[i].r],column[mk[i].c])+1;
        continue;
    }
    for(int j=last;j<i;++j)
        row[mk[j].r]=max(row[mk[j].r],f[mk[j].id]),
        column[mk[j].c]=max(column[mk[j].c],f[mk[j].id]);
    last=i;
    f[mk[i].id]=max(row[mk[i].r],column[mk[i].c])+1;        
}
```

### 最优关键思路与技巧

1. **动态规划与排序结合**：通过将格子按数值从大到小排序，可以消除后效性，使得动态规划的状态转移更加高效。
2. **行与列的最大值维护**：通过维护每行和每列的最大移动次数，可以避免重复计算，提高效率。
3. **延迟更新**：在处理相同数值的格子时，延迟更新行和列的最大值，确保计算的正确性。

### 可拓展之处

类似的问题可以通过动态规划和排序结合的方式来解决，特别是在需要处理行和列的最大值时。这种思路可以应用于其他需要在网格上进行状态转移的问题。

### 推荐题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)

### 个人心得总结

在处理网格上的动态规划问题时，排序和状态转移的结合是非常有效的。通过维护行和列的最大值，可以避免重复计算，提高效率。同时，延迟更新在处理相同数值的格子时尤为重要，确保计算的正确性。

---
处理用时：47.93秒
# 题目信息

# [ABC225E] フ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc225/tasks/abc225_e

二次元平面上の第一象限上に $ N $ 個のフの字があります。

$ i\ (1\ \leq\ i\ \leq\ N) $ 個目のフの字は、$ (x_i-1,y_i) $ と $ (x_i,y_i) $ を結ぶ線分と $ (x_i,y_i-1) $ と $ (x_i,y_i) $ を結ぶ線分の $ 2 $ つを組み合わせた図形です。

あなたは、$ N $ 個のフの字から $ 0 $ 個以上を選び、削除することができます。

適切に削除するフの字を選んだとき、原点から全体が見えるフの字の個数は最大でいくつになりますか？

ここで、原点からあるフの字（便宜上 $ i $ 個目のフの字とする）の全体が見える必要十分条件は、以下の通りです。

- 原点、$ (x_i-1,y_i) $、$ (x_i,y_i) $、$ (x_i,y_i-1) $ の $ 4 $ 点を頂点とする四角形の内部（境界を除く）と他のフの字が共通部分を持たない。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ x_i,y_i\ \leq\ 10^9 $
- $ (x_i,y_i)\ \neq\ (x_j,y_j)\ (i\ \neq\ j) $
- 入力はすべて整数

### Sample Explanation 1

$ 1 $ 個目のフの字を削除したとき原点からは $ 2 $ 個目のフの字と $ 3 $ 個目のフの字の $ 2 $ つが見えるようになり、これが最大です。 $ 1 $ つのフの字も削除しない場合、原点からは $ 1 $ 個目のフの字のみしか見えません。

### Sample Explanation 2

すべてのフの字を削除せずに残すのが最善です。

## 样例 #1

### 输入

```
3

1 1

2 1

1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
10

414598724 87552841

252911401 309688555

623249116 421714323

605059493 227199170

410455266 373748111

861647548 916369023

527772558 682124751

356101507 249887028

292258775 110762985

850583108 796044319```

### 输出

```
10```

# AI分析结果

### 题目翻译
【题目内容】
# [ABC225E] フ

## 题目描述

在二维平面的第一象限上有 $ N $ 个“フ”字形。

第 $ i\ (1\ \leq\ i\ \leq\ N) $ 个“フ”字形由连接 $ (x_i-1,y_i) $ 和 $ (x_i,y_i) $ 的线段，以及连接 $ (x_i,y_i-1) $ 和 $ (x_i,y_i) $ 的线段组成。

你可以选择删除 $ 0 $ 个或多个“フ”字形。

在适当删除一些“フ”字形后，从原点可以看到的“フ”字形的最大数量是多少？

这里，从原点可以看到第 $ i $ 个“フ”字形的充分必要条件是：

- 由原点、$ (x_i-1,y_i) $、$ (x_i,y_i) $、$ (x_i,y_i-1) $ 四个点组成的四边形内部（不包括边界）与其他“フ”字形没有重叠部分。

## 说明/提示

### 约束条件

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ x_i,y_i\ \leq\ 10^9 $
- $ (x_i,y_i)\ \neq\ (x_j,y_j)\ (i\ \neq\ j) $
- 输入均为整数

### 样例解释 1

删除第 $ 1 $ 个“フ”字形后，从原点可以看到第 $ 2 $ 个和第 $ 3 $ 个“フ”字形，共 $ 2 $ 个，这是最大值。如果不删除任何“フ”字形，从原点只能看到第 $ 1 $ 个“フ”字形。

### 样例解释 2

不删除任何“フ”字形是最佳选择。

## 样例 #1

### 输入

```
3

1 1

2 1

1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
10

414598724 87552841

252911401 309688555

623249116 421714323

605059493 227199170

410455266 373748111

861647548 916369023

527772558 682124751

356101507 249887028

292258775 110762985

850583108 796044319```

### 输出

```
10```

### 算法分类
贪心

### 题解分析与结论
这道题的核心在于如何选择不重叠的“フ”字形，使得从原点可以看到的“フ”字形数量最大化。通过将问题转化为角度的覆盖问题，可以利用贪心算法来解决。具体来说，每个“フ”字形可以看作一个以原点为顶点的角，问题转化为选择尽可能多的不重叠的角。

### 所选题解
1. **Symbolize (4星)**
   - **关键亮点**：将问题转化为角度覆盖问题，利用斜率排序和贪心算法求解。
   - **代码实现**：通过定义结构体 `node` 来表示角度，使用斜率进行排序，然后使用贪心算法选择不重叠的角度。
   ```cpp
   struct node {
       int x,y;
       node(int a=0,int b=0){x=a,y=b;}
       bool operator<(const node &k)const{return x*k.y-y*k.x>0;}
       bool operator<=(const node &k)const{return x*k.y-y*k.x>=0;}
   };
   pair<node,node> a[N];
   signed main() {
       cin>>n;
       rep1(i,1,n) {
           int x, y;
           cin>>x>>y;
           a[i]=make_pair(node(x-1,y),node(x,y-1));
       }
       sort(a+1,a+1+n);
       node last;
       rep1(i,1,n) {
           if(last<=a[i].y) {
               ++ans;
               last=a[i].x;
           }
       }
       cout<<ans<<endl;
       return 0;
   }
   ```

2. **DengDuck (4星)**
   - **关键亮点**：将问题转化为区间覆盖问题，利用斜率排序和贪心算法求解。
   - **代码实现**：通过定义结构体 `num` 和 `node` 来表示角度，使用斜率进行排序，然后使用贪心算法选择不重叠的角度。
   ```cpp
   struct num {
       LL a, b;
   } t = { 0, 1 };
   struct node {
       num l, r;
   } a[N];
   bool comp(num a, num b) { 
       return a.a * b.b <= b.a * a.b; 
   }
   bool comp2(num a, num b) { 
       return a.a * b.b < b.a * a.b; 
   }
   bool cmp(node x, node y) {
       return comp2(x.r, y.r);
   }
   int main() {
       scanf("%lld", &n);
       for (int i = 1; i <= n; i++) {
           scanf("%lld%lld", &x, &y);
           a[i].l = { y - 1, x }, a[i].r = { y, x - 1 };
       }
       sort(a + 1, a + n + 1, cmp);
       for (int i = 1; i <= n; i++) {
           if (comp(t, a[i].l)) t = a[i].r, ans++;
       }
       printf("%lld", ans);
   }
   ```

3. **aeiouaoeiu (4星)**
   - **关键亮点**：将问题转化为角度覆盖问题，利用斜率排序和贪心算法求解。
   - **代码实现**：通过定义结构体 `Vector` 来表示角度，使用斜率进行排序，然后使用贪心算法选择不重叠的角度。
   ```cpp
   struct Vector {
       ll x,y;
       Vector(ll _x=0,ll _y=0) {
           x=_x,y=_y;
       }
       bool operator<(const Vector &o)const{ 
           return x*o.y-y*o.x>0;
       }
       bool operator<=(const Vector &o)const{
           return x*o.y-y*o.x>=0;
       }
   };
   pair<Vector,Vector> a[maxn];
   int main() {
       cin>>n;
       ll x,y;
       for(int i=1;i<=n;i++) {
           cin>>x>>y;
           a[i]=make_pair(Vector(x-1,y),Vector(x,y-1));
       }
       sort(a+1,a+1+n);
       Vector last;
       for(int i=1;i<=n;i++) {
           if(last<=a[i].second) ans++,last=a[i].first;
       }
       cout<<ans;
       return 0;
   }
   ```

### 最优关键思路
将问题转化为角度覆盖问题，利用斜率排序和贪心算法求解。通过定义结构体来表示角度，使用斜率进行排序，然后使用贪心算法选择不重叠的角度。

### 拓展思路
类似的问题可以转化为区间覆盖问题，利用贪心算法求解。例如，选择不重叠的线段或区间，使得选择的线段或区间数量最大化。

### 推荐题目
1. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
2. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得
在处理几何问题时，将问题转化为角度或区间覆盖问题，可以简化问题的复杂度。利用斜率排序和贪心算法，可以高效地解决这类问题。

---
处理用时：47.86秒
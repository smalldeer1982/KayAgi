# 题目信息

# [ABC226E] Just one

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc226/tasks/abc226_e

$ N $ 頂点 $ M $ 辺の無向グラフが与えられます。 頂点は頂点 $ 1 $ ,頂点 $ 2 $ , $ \ldots $ ,頂点 $ N $、辺は辺 $ 1 $ ,辺 $ 2 $ , $ \ldots $ ,辺 $ M $ と番号付けられており、特に辺 $ i $ $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ U_i $ と頂点 $ V_i $ を結んでいます。 また、このグラフは単純であることが保証されます。すなわち、自己ループや多重辺は存在しません。

このグラフの $ M $ 本の辺すべてに向き付けをする方法は $ 2^M $ 通り考えられますが、 そのうち、どの頂点についても、その頂点から他の頂点に向かう辺がちょうど $ 1 $ 本ずつ存在するような向き付けの方法は何通りありますか。 答えは非常に大きくなる可能性があるので、$ 998244353 $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ U_i,V_i\ \leq\ N $
- $ U_i\ \neq\ V_i $
- 入力は全て整数である。
- 与えられるグラフは単純である。

### Sample Explanation 1

条件をみたす辺の向き付けの方法は、 - $ 1\rightarrow\ 2 $ , $ 2\rightarrow\ 3 $ , $ 1\leftarrow\ 3 $ - $ 1\leftarrow\ 2 $ , $ 2\leftarrow\ 3 $ , $ 1\rightarrow\ 3 $ の $ 2 $ 通りです。

### Sample Explanation 2

すべての頂点から $ 1 $ 本ずつ辺が出ているようにすることは明らかに不可能です。

## 样例 #1

### 输入

```
3 3

1 2

1 3

2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
2 1

1 2```

### 输出

```
0```

## 样例 #3

### 输入

```
7 7

1 2

2 3

3 4

4 2

5 6

6 7

7 5```

### 输出

```
4```

# AI分析结果

### 题目内容
$ N $ 个顶点 $ M $ 条边的无向图，顶点编号为 $ 1 $ 到 $ N $，边编号为 $ 1 $ 到 $ M $。每条边连接两个不同的顶点，且图中没有自环和多重边。要求给每条边定向，使得每个顶点恰好有一条出边。求满足条件的定向方案数，结果对 $ 998244353 $ 取模。

### 算法分类
图论

### 题解分析与结论
题目要求每个顶点恰好有一条出边，这意味着图中每个连通块必须是一个基环树（即每个连通块中恰好有一个环）。如果图中存在非基环树的连通块，则无解。对于每个基环树，环上的边有两种定向方式（顺时针或逆时针），因此总方案数为 $ 2^x $，其中 $ x $ 是基环树的数量。

### 精选题解

#### 题解1：AzureHair (4星)
**关键亮点**：
- 通过DFS遍历每个连通块，统计节点数和边数，判断是否为基环树。
- 代码简洁，逻辑清晰，直接判断连通块是否为基环树，并计算方案数。

**核心代码**：
```cpp
void dfs(int x,int fa)
{
	vis[x]=1;cntn++;
	for(int i=head[x];i;i=e[i].next)
	{
		int to=e[i].to;
		cntm++;
		if(to==fa)continue;
		if(vis[to])continue;
		dfs(to,x);
	}
}
```
**实现思想**：
- 使用DFS遍历连通块，统计节点数 `cntn` 和边数 `cntm`。
- 判断每个连通块是否满足 `cntn == cntm / 2`，若满足则为基环树，方案数乘以2。

#### 题解2：_zzzzzzy_ (4星)
**关键亮点**：
- 通过DFS遍历连通块，统计环的数量，判断是否为基环树。
- 代码简洁，逻辑清晰，直接判断连通块是否为基环树，并计算方案数。

**核心代码**：
```cpp
void dfs(int u,int f){
	vis[u]=1;
	for(int v:e[u]){
		if(v!=f){
			if(!vis[v]){
				dfs(v,u);
			}
			else{
				cnt++;
			}
		}
	}
}
```
**实现思想**：
- 使用DFS遍历连通块，统计环的数量 `cnt`。
- 判断每个连通块是否满足 `cnt == 2`，若满足则为基环树，方案数乘以2。

#### 题解3：MspAInt (4星)
**关键亮点**：
- 通过DFS遍历连通块，统计节点数和边数，判断是否为基环树。
- 代码简洁，逻辑清晰，直接判断连通块是否为基环树，并计算方案数。

**核心代码**：
```cpp
void dfs(int u){
    if(!vis[u])D++;else return;
    vis[u]=1;
    for(int v:e[u])if(!vis[v])dfs(v);
    E+=e[u].size();
}
```
**实现思想**：
- 使用DFS遍历连通块，统计节点数 `D` 和边数 `E`。
- 判断每个连通块是否满足 `D == E / 2`，若满足则为基环树，方案数乘以2。

### 最优关键思路
- **基环树判定**：通过DFS遍历连通块，统计节点数和边数，判断是否为基环树。
- **方案数计算**：每个基环树有两种定向方式，总方案数为 $ 2^x $，其中 $ x $ 是基环树的数量。

### 拓展思路
- **类似题目**：可以扩展到其他图论问题，如判断图中是否存在环、计算环的数量等。
- **优化技巧**：使用并查集或Tarjan算法优化连通块的判定过程。

### 推荐题目
1. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
2. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)
3. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)

---
处理用时：30.13秒
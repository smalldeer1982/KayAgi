# 题目信息

# [ABC228E] Integer Sequence Fair

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc228/tasks/abc228_e

整数列を一堂に集めてその優劣を定める、整数列品評会が行われます。 品評会では、$ 1 $ 以上 $ K $ 以下の整数からなる長さ $ N $ の整数列すべてが審査対象となり、 審査対象の数列それぞれに対して $ 1 $ 以上 $ M $ 以下の整数の点数をつけます。

「審査対象の数列それぞれに対して $ 1 $ 以上 $ M $ 以下の整数の点数をつける方法」が何通りあるかを $ 998244353 $ で割ったあまりを出力してください。

ただし、$ 2 $ つの方法が異なるとは「審査対象となるある数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ が存在して、 $ A $ に対してつける点数が $ 2 $ つの方法で異なる」ことを言います。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ K,\ M\ \leq\ 10^{18} $
- $ N,\ K,\ M $ は整数

### Sample Explanation 1

審査対象となる数列は、$ (1,\ 1),\ (1,\ 2),\ (2,\ 1),\ (2,\ 2) $ の $ 4 $ つです。「審査対象の数列それぞれに対して $ 1 $ 以上 $ 2 $ 以下の整数の点数をつける方法」は、以下の $ 16 $ 通りあります。 - $ (1,\ 1) $ に $ 1 $ 点、$ (1,\ 2) $ に $ 1 $ 点、$ (2,\ 1) $ に $ 1 $ 点、$ (2,\ 2) $ に $ 1 $ 点をつける方法 - $ (1,\ 1) $ に $ 1 $ 点、$ (1,\ 2) $ に $ 1 $ 点、$ (2,\ 1) $ に $ 1 $ 点、$ (2,\ 2) $ に $ 2 $ 点をつける方法 - $ (1,\ 1) $ に $ 1 $ 点、$ (1,\ 2) $ に $ 1 $ 点、$ (2,\ 1) $ に $ 2 $ 点、$ (2,\ 2) $ に $ 1 $ 点をつける方法 - $ (1,\ 1) $ に $ 1 $ 点、$ (1,\ 2) $ に $ 1 $ 点、$ (2,\ 1) $ に $ 2 $ 点、$ (2,\ 2) $ に $ 2 $ 点をつける方法 - $ \cdots $ - $ (1,\ 1) $ に $ 2 $ 点、$ (1,\ 2) $ に $ 2 $ 点、$ (2,\ 1) $ に $ 2 $ 点、$ (2,\ 2) $ に $ 2 $ 点をつける方法 よって、$ 16 $ を出力します。

### Sample Explanation 2

$ 998244353 $ で割ったあまりを出力することに注意してください。

## 样例 #1

### 输入

```
2 2 2```

### 输出

```
16```

## 样例 #2

### 输入

```
3 14 15926535```

### 输出

```
109718301```

# AI分析结果

### 题目内容重写
【题目描述】
整数列品评会即将举行，所有由 $1$ 到 $K$ 的整数组成且长度为 $N$ 的整数序列都将被评审。每个序列将被赋予一个 $1$ 到 $M$ 的整数分数。请计算所有可能的评分方法的总数，结果对 $998244353$ 取模。

【说明/提示】
- 两个评分方法不同，当且仅当存在至少一个序列，其在这两种方法下获得的分数不同。
- 输入包含三个整数 $N, K, M$，范围均为 $1$ 到 $10^{18}$。

### 算法分类
数学

### 题解分析与结论
本题的核心在于计算 $M^{K^N} \bmod 998244353$。由于 $N, K, M$ 的范围极大，直接计算不可行。因此，题解普遍采用了费马小定理来简化计算，即利用 $M^{K^N} \equiv M^{K^N \bmod (p-1)} \pmod p$ 的性质，其中 $p=998244353$。此外，还需要特判 $M$ 是否为 $p$ 的倍数。

### 所选题解
#### 1. 作者：FFTotoro (5星)
- **关键亮点**：简洁明了地应用了费马小定理，并使用了 AtCoder 库中的 `pow_mod` 函数，代码简洁高效。
- **代码实现**：
  ```cpp
  #include<atcoder/all>
  #define int long long
  const int mod=998244353;
  using namespace std;
  main(){
      ios::sync_with_stdio(false);
      int n,k,m; cin>>n>>k>>m;
      cout<<(m%mod?atcoder::pow_mod(m,atcoder::pow_mod(k,n,mod-1),mod):0)<<endl;
      return 0;
  }
  ```

#### 2. 作者：zeekliu (4星)
- **关键亮点**：详细解释了费马小定理的应用，并提供了自定义的快速幂函数，代码可读性强。
- **代码实现**：
  ```cpp
  inline long long qpow(long long a,long long b,long long c) {
      if (a==0) return 0;
      long long ans=1;
      while (b) {
          if (b&1) ans=ans*a%c;
          a=a*a%c;
          b>>=1;
      }
      return ans;
  }
  ```

#### 3. 作者：Meickol (4星)
- **关键亮点**：详细推导了费马小定理的应用过程，并指出了在快速幂中底数取模的重要性，代码实现严谨。
- **代码实现**：
  ```cpp
  LL fastpow(LL a,LL n,LL mod){
      a%=mod;
      LL res=1;
      while(n){
          if(n&1) res=res*a%mod;
          a=a*a%mod;
          n>>=1;
      }
      return res;
  }
  ```

### 关键思路与技巧
- **费马小定理**：利用 $M^{K^N} \equiv M^{K^N \bmod (p-1)} \pmod p$ 简化计算。
- **快速幂**：高效计算大指数的模幂运算。
- **特判**：处理 $M$ 为 $p$ 的倍数的情况。

### 拓展与举一反三
- 类似题目：洛谷 P3811 【模板】乘法逆元、洛谷 P1226 【模板】快速幂、洛谷 P2613 【模板】有理数取余。

### 个人心得
- **调试经历**：在快速幂函数中，底数取模是避免溢出的关键。
- **顿悟感想**：费马小定理在处理大指数模运算时非常有效，尤其是在模数为质数的情况下。

---
处理用时：23.66秒
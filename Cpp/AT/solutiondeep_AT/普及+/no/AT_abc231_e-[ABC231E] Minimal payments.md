# 题目信息

# [ABC231E] Minimal payments

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc231/tasks/abc231_e

Atcoder 王国では $ A_1 $ 円, $ A_2 $ 円, $ \ldots $, $ A_N $ 円の $ N $ 種類の硬貨が使用されています。  
 ここで、$ 1=A_1\ <\ \ldots\ <\ A_N $ であり、全ての $ 1\leq\ i\ \leq\ N-1 $ に対し、$ A_{i+1} $ は $ A_i $ の倍数です。

硬貨のみを使って $ X $ 円を支払うとき、支払いに使う硬貨の枚数とお釣りでもらう硬貨の枚数の合計の最小値はいくつですか？

正確には、$ Y $ が $ X $ 以上の整数を自由に動く時、$ Y $ 円ちょうどを表すために必要な硬貨の枚数と、$ Y-X $ 円ちょうどを表すために必要な硬貨の枚数の和の最小値を求めてください。

## 说明/提示

### 制約

- 入力に含まれる値は全て整数である
- $ 1\ \leq\ N\ \leq\ 60 $
- $ 1=A_1\ <\ \ldots\ <\ A_N\ \leq\ 10^{18} $
- 全ての $ 1\leq\ i\ \leq\ N-1 $ で $ A_{i+1} $ は $ A_i $ の倍数である
- $ 1\leq\ X\ \leq\ 10^{18} $

### Sample Explanation 1

$ 100 $ 円硬貨 $ 1 $ 枚で支払いを行い、$ 10 $ 円硬貨 $ 1 $ 枚と $ 1 $ 円硬貨 $ 3 $ 枚をお釣りでもらうと、合計枚数は $ 5 $ 枚になります。

### Sample Explanation 2

$ 7 $ 円硬貨 $ 7 $ 枚で支払いを行うのが最適です。

## 样例 #1

### 输入

```
3 87

1 10 100```

### 输出

```
5```

## 样例 #2

### 输入

```
2 49

1 7```

### 输出

```
7```

## 样例 #3

### 输入

```
10 123456789012345678

1 100 10000 1000000 100000000 10000000000 1000000000000 100000000000000 10000000000000000 1000000000000000000```

### 输出

```
233```

# AI分析结果

### 题目内容重写
Atcoder 王国使用 $N$ 种硬币，面值分别为 $A_1$ 元, $A_2$ 元, $\ldots$, $A_N$ 元。其中 $1 = A_1 < \ldots < A_N$，且对于所有 $1 \leq i \leq N-1$，$A_{i+1}$ 是 $A_i$ 的倍数。

现在需要用这些硬币支付 $X$ 元，求支付和找零的硬币数量的和的最小值。

### 算法分类
贪心、动态规划、搜索

### 题解分析与结论
本题的核心在于如何通过贪心策略和动态规划来最小化支付和找零的硬币数量。由于硬币面值是递增的，并且每个面值都是前一个的倍数，因此可以采用贪心策略，优先使用大面值硬币。同时，由于存在找零的情况，需要结合动态规划或记忆化搜索来避免重复计算。

### 精选题解
#### 1. 作者：ikunTLE (赞：11)
- **星级**：5
- **关键亮点**：使用记忆化搜索，结合贪心策略，分情况讨论不找零和找零的情况，代码简洁高效。
- **个人心得**：强调了不开 `long long` 会导致错误，提醒了记忆化的重要性。

```cpp
int dfs(int x, int i) {
    if (i == n) return x;
    if (f[x][i]) return f[x][i];
    int op1 = x / a[i] + dfs(x % a[i], i + 1); // 不找零
    int op2 = x / a[i] + 1 + dfs(a[i] * (x / a[i] + 1) - x, i + 1); // 找零
    f[x][i] = min(op1, op2); // 取最优解
    return f[x][i];
}
```

#### 2. 作者：PikachuQAQ (赞：6)
- **星级**：4
- **关键亮点**：详细解释了贪心策略和动态规划的结合，代码结构清晰，易于理解。
- **个人心得**：强调了数据特征和贪心的适用性。

```cpp
ll dfs(ll x, ll i) {
    if (!i) return x;
    if (f[x][i]) return f[x][i];
    ll otp = x / a[i] + dfs(x % a[i], i - 1); // 不找零
    ll change = x / a[i] + dfs((x / a[i] + 1) * a[i] - x, i - 1) + 1; // 找零
    f[x][i] = min(otp, change); // 取最优解
    return f[x][i];
}
```

#### 3. 作者：chengning0909 (赞：5)
- **星级**：4
- **关键亮点**：通过进制转换的思路，将问题转化为动态规划，时间复杂度低，思路新颖。
- **个人心得**：强调了题目条件的利用和动态规划的优化。

```cpp
f[i][0] = min(f[i-1][0]+b[i], f[i-1][1]+b[i]+1);
f[i][1] = min(f[i-1][0]+a[i+1]/a[i]-b[i], f[i-1][1]+a[i+1]/a[i]-b[i]-1);
```

### 最优关键思路
1. **贪心策略**：优先使用大面值硬币，减少硬币数量。
2. **记忆化搜索**：通过记忆化避免重复计算，提高效率。
3. **动态规划**：结合贪心策略，分情况讨论不找零和找零的情况，取最小值。

### 拓展思路
类似的问题可以出现在其他货币系统中，尤其是面值有倍数关系的情况。可以通过贪心策略和动态规划的结合来解决。

### 推荐题目
1. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

---
处理用时：24.84秒
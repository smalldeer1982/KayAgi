# 题目信息

# [ABC231F] Jealous Two

## 题目描述

&emsp;滑头君要给他的两个好基友 A、B 每人送一个礼物。\
&emsp;滑头君有 **$ N $ 种**礼物，对于每种礼物，两个好基友都有不同的喜爱值。\
&emsp;两个好基友非常嫉妒。对于任意一个人来说，如果对方收到的礼物对自己的喜爱值比自己的礼物对自己的喜爱值更高，换句话说就是如果有人更喜欢对方的礼物的话，两个人就会打架。\
&emsp;滑头君不想失去他的朋友，于是请你求出共有几种可能的送礼方案。  
**请注意，可以给两个人送同样的礼物。**

## 样例 #1

### 输入

```
3

50 100 150

1 3 2```

### 输出

```
4```

## 样例 #2

### 输入

```
3

123456789 123456 123

987 987654 987654321```

### 输出

```
6```

## 样例 #3

### 输入

```
10

3 1 4 1 5 9 2 6 5 3

2 7 1 8 2 8 1 8 2 8```

### 输出

```
37```

# AI分析结果

### 题目内容
滑头君要给他的两个好基友 A、B 每人送一个礼物。滑头君有 **$ N $ 种**礼物，对于每种礼物，两个好基友都有不同的喜爱值。两个好基友非常嫉妒。对于任意一个人来说，如果对方收到的礼物对自己的喜爱值比自己的礼物对自己的喜爱值更高，换句话说就是如果有人更喜欢对方的礼物的话，两个人就会打架。滑头君不想失去他的朋友，于是请你求出共有几种可能的送礼方案。  
**请注意，可以给两个人送同样的礼物。**

### 样例 #1
#### 输入
```
3
50 100 150
1 3 2
```
#### 输出
```
4
```

### 样例 #2
#### 输入
```
3
123456789 123456 123
987 987654 987654321
```
#### 输出
```
6
```

### 样例 #3
#### 输入
```
10
3 1 4 1 5 9 2 6 5 3
2 7 1 8 2 8 1 8 2 8
```
#### 输出
```
37
```

### 算法分类
树状数组、离散化

### 题解分析与结论
本题的核心是统计满足 $a_i \geq a_j$ 且 $b_i \leq b_j$ 的 $(i,j)$ 对数。多个题解都采用了树状数组和离散化的方法来解决这个问题，整体思路相似，但在实现细节上有所不同。

### 所选高星题解

#### 题解1：作者：allenchoi (4星)
**关键亮点：**
- 使用了容斥原理，先统计不满足条件的对数，再用总数减去不满足条件的对数。
- 通过树状数组和离散化处理，优化了时间复杂度。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
for(int i = 1,j;i <= n;i++)
{
    for(j = i;j <= n && g[j].a == g[i].a;j++)
    {
        g[j].b = lower_bound(p2 + 1,p2 + m + 1,g[j].b) - p2;
        c3 += query(m) - query(g[j].b);
    }
    for(j = i;j <= n && g[j].a == g[i].a;j++) update(g[j].b,1);
    i = j - 1;
}
```
**核心思想：**
- 对 $a$ 和 $b$ 进行离散化处理，使用树状数组统计满足条件的对数。

#### 题解2：作者：Fire_Shadow_Dream (4星)
**关键亮点：**
- 通过归并排序求逆序对，解决了统计问题。
- 处理了 $a$ 和 $b$ 相同的情况，确保了统计的准确性。
- 代码注释详细，便于理解。

**核心代码：**
```cpp
void merge(int l,int mid,int r){
    jp[l-1]=0;
    for(int i=l;i<=mid;i++) L[i]=sum[i],jp[i]=jp[i-1]+sum[i].s;
    for(int i=mid+1;i<=r;i++) R[i]=sum[i];
    int i=l,j=mid+1,tot=0;
    L[mid+1].p=R[r+1].p=INT_MAX;
    while(tot<r-l+1){
        tot++;
        if(L[i].p>=R[j].p) sum[l+tot-1]=R[j],ans+=(jp[mid]-jp[i-1])*R[j].s,j++;
        else sum[l+tot-1]=L[i],i++;
    }
}
```
**核心思想：**
- 使用归并排序统计逆序对，确保统计的准确性。

#### 题解3：作者：VitrelosTia (4星)
**关键亮点：**
- 直接按 $a$ 从大到小排序，使用树状数组维护 $b$ 的统计。
- 处理了 $a$ 相同的情况，通过组合数补充统计。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
for (int i = 1; i <= n; i++) {
    update(x[i].b);
    ans += query(x[i].b);
} 
for (int i = 1, siz; siz = col[i].size(), i <= n; i++) ans += siz * (siz - 1) / 2;
```
**核心思想：**
- 使用树状数组维护 $b$ 的统计，处理 $a$ 相同的情况。

### 最优关键思路与技巧
- **树状数组与离散化**：通过树状数组高效统计满足条件的对数，离散化处理大范围数据。
- **归并排序求逆序对**：适用于统计逆序对问题，确保统计的准确性。
- **组合数补充统计**：处理相同 $a$ 和 $b$ 的情况，确保统计的完整性。

### 可拓展之处
- 类似问题可以通过树状数组或归并排序解决，如统计满足某种条件的对数问题。
- 离散化处理可以应用于大范围数据的统计问题。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)

### 个人心得摘录
- **调试经历**：在处理 $a$ 和 $b$ 相同的情况时，容易遗漏统计，需特别注意。
- **顿悟感想**：通过树状数组和离散化处理，可以高效解决统计问题，代码简洁且逻辑清晰。

---
处理用时：36.96秒
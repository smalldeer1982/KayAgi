# 题目信息

# [ABC232E] Rook Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc232/tasks/abc232_e

縦 $ H $ 行、横 $ W $ 行の $ H\ \times\ W $ マスからなるグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表します。

はじめ、マス $ (x_1,\ y_1) $ にルークが置かれており、高橋君は以下の操作を $ K $ 回行います。

- 現在ルークが置かれているマスと行または列が同じマスにルークを移動させる。ただし、現在ルークが置かれているマスとは異なるマスに移動させる必要がある。

$ K $ 回の操作の後、ルークがマス $ (x_2,\ y_2) $ に置かれているようにする方法は何通りありますか？答えは非常に大きくなることがあるので、$ 998244353 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 10^9 $
- $ 1\ \leq\ K\ \leq\ 10^6 $
- $ 1\ \leq\ x_1,\ x_2\ \leq\ H $
- $ 1\ \leq\ y_1,\ y_2\ \leq\ W $

### Sample Explanation 1

以下の $ 2 $ 通りです。 - $ 1 $ 回目の操作でルークをマス $ (1,\ 2) $ からマス $ (1,\ 1) $ へ動かし、$ 2 $ 回目の操作でルークをマス $ (1,\ 1) $ からマス $ (2,\ 1) $ に動かす。 - $ 1 $ 回目の操作でルークをマス $ (1,\ 2) $ からマス $ (2,\ 2) $ へ動かし、$ 2 $ 回目の操作でルークをマス $ (2,\ 2) $ からマス $ (2,\ 1) $ に動かす。

### Sample Explanation 2

$ 998244353 $ で割った余りを求めなければならないことに注意して下さい。

## 样例 #1

### 输入

```
2 2 2

1 2 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
1000000000 1000000000 1000000

1000000000 1000000000 1000000000 1000000000```

### 输出

```
24922282```

## 样例 #3

### 输入

```
3 3 3

1 3 3 3```

### 输出

```
9```

# AI分析结果

### 题目翻译
有一个 $H \times W$ 的国际象棋棋盘，初始时在 $(x_1, y_1)$ 位置有一个车。高桥君将进行 $K$ 次操作，每次操作将车移动到与当前所在位置同行或同列的任意一个不同位置。求经过 $K$ 次操作后，车恰好位于 $(x_2, y_2)$ 的方案数。由于答案可能非常大，请对 $998244353$ 取模。

### 算法分类
动态规划

### 题解分析与结论
该问题的核心在于通过动态规划优化状态转移，避免直接枚举所有可能的移动路径。由于棋盘的大小可能非常大（$H, W \leq 10^9$），直接记录每个位置的状态是不可行的。因此，题解普遍采用了将状态分类的方法，将车的位置分为四类：
1. 终点位置 $(x_2, y_2)$
2. 与终点同行但不同列的位置
3. 与终点同列但不同行的位置
4. 与终点不同行也不同列的位置

通过这种分类，题解将状态转移方程简化为四类状态之间的转移，从而将时间复杂度降低到 $O(K)$，能够处理 $K \leq 10^6$ 的情况。

### 所选高分题解
#### 1. 作者：沉石鱼惊旋 (5星)
**关键亮点**：
- 状态分类清晰，将车的位置分为四类，简化了状态转移。
- 代码简洁，直接实现了状态转移方程，避免了复杂的逻辑。
- 通过滚动数组优化空间复杂度，仅使用四个变量记录状态。

**核心代码**：
```cpp
for(int i=0;i<k;i++)
{
    ll a1,b1,c1,d1;
    a1=b*(w-1)+c*(h-1);
    b1=b*(w-2)+a+d*(h-1);
    c1=c*(h-2)+a+d*(w-1);
    d1=d*(h+w-4)+b+c;
    a1%=p;
    b1%=p;
    c1%=p;
    d1%=p;
    a=a1;
    b=b1;
    c=c1;
    d=d1;
}
```
**实现思想**：通过四个变量 `a, b, c, d` 分别表示四类状态，每次迭代更新这些变量的值，最终根据车的位置输出对应的状态值。

#### 2. 作者：guanyf (4星)
**关键亮点**：
- 详细解释了状态分类的思路，帮助理解状态转移方程的推导。
- 代码结构清晰，使用了二维数组记录状态，便于调试和理解。

**核心代码**：
```cpp
for (int i = 1; i <= k; i++) { 
    dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % mod;
    dp[i][1] = ((dp[i - 1][3] + dp[i - 1][1] * (w - 2) % mod) % mod + dp[i - 1][0] * (w - 1) % mod) % mod;
    dp[i][2] = ((dp[i - 1][3] + dp[i - 1][2] * (h - 2) % mod) % mod + dp[i - 1][0] * (h - 1) % mod) % mod;
    dp[i][3] = ((dp[i - 1][3] * (h + w - 4) % mod + dp[i - 1][1] * (h - 1) % mod) % mod + dp[i - 1][2] * (w - 1) % mod) % mod;
}
```
**实现思想**：使用二维数组 `dp[i][j]` 记录第 $i$ 步时四类状态的方案数，通过状态转移方程更新每一步的状态。

#### 3. 作者：Laoshan_PLUS (4星)
**关键亮点**：
- 通过图示解释了状态转移的合理性，帮助理解状态分类的必要性。
- 代码简洁，直接实现了状态转移方程，避免了复杂的逻辑。

**核心代码**：
```cpp
for (int i = 1; i <= k; i++) {
    dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % MOD;
    dp[i][1] = ((dp[i - 1][3] + dp[i - 1][1] * (w - 2) % MOD) % MOD + dp[i - 1][0] * (w - 1) % MOD) % MOD;
    dp[i][2] = ((dp[i - 1][3] + dp[i - 1][2] * (h - 2) % MOD) % MOD + dp[i - 1][0] * (h - 1) % MOD) % MOD;
    dp[i][3] = ((dp[i - 1][3] * (h + w - 4) % MOD + dp[i - 1][1] * (h - 1) % MOD) % MOD + dp[i - 1][2] * (w - 1) % MOD) % MOD;
}
```
**实现思想**：通过二维数组 `dp[i][j]` 记录每一步的状态，通过状态转移方程更新每一步的方案数。

### 最优关键思路
通过将车的位置分类为四类状态，避免了直接枚举所有可能的移动路径，极大地简化了状态转移方程。这种分类方法不仅降低了时间复杂度，还使得代码实现更加简洁。

### 拓展思路
类似的状态分类方法可以应用于其他棋盘类问题，尤其是当棋盘规模较大时，通过合理分类状态可以显著降低问题的复杂度。例如，在解决骑士移动、皇后移动等问题时，也可以采用类似的状态分类策略。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

---
处理用时：45.00秒
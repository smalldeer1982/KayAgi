# 题目信息

# [ABC235E] MST + 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc235/tasks/abc235_e

$ N $ 頂点 $ M $ 辺の重み付き無向連結グラフ $ G $ が与えられます。$ G $ には自己ループや多重辺が含まれている可能性があります。  
 頂点には頂点 $ 1 $, 頂点 $ 2 $, $ \dots $, 頂点 $ N $ と番号がついています。  
 辺には辺 $ 1 $, 辺 $ 2 $, $ \dots $, 辺 $ M $ と番号がついています。辺 $ i $ は頂点 $ a_i $ と頂点 $ b_i $ を結ぶ重み $ c_i $ の辺です。ここで、$ 1\ \leq\ i\ \lt\ j\ \leq\ M $ を満たすすべての整数の組 $ (i,\ j) $ について $ c_i\ \neq\ c_j $ が成り立ちます。

以下で説明される $ Q $ 個のクエリに答えてください。  
 $ i $ 番目のクエリでは整数の組 $ (u_i,\ v_i,\ w_i) $ が与えられます。ここで、$ 1\ \leq\ j\ \leq\ M $ を満たすすべての整数 $ j $ について $ w_i\ \neq\ c_j $ が成り立ちます。   
 頂点 $ u_i $ と頂点 $ v_i $ を結ぶ重み $ w_i $ の無向辺を $ e_i $ として、$ G $ に $ e_i $ を追加してできるグラフ $ G_i $ を考えます。 このとき $ G_i $ の最小全域木 $ T_i $ は一意に定まることが証明できますが、$ T_i $ に $ e_i $ は含まれるでしょうか？答えを `Yes` あるいは `No` で出力してください。

ここで、クエリの前後で $ G $ は変化しないことに注意してください。言い換えると、クエリ $ i $ で $ G $ に $ e_i $ を追加したグラフを考えたとしても、他のクエリで出てくる $ G $ に $ e_i $ が追加されていることはありません。

 最小全域木とは？ $ G $ の **全域木** とは、$ G $ に含まれるすべての頂点と $ G $ に含まれる辺の一部からなる木のことを言います。  
 $ G $ の **最小全域木** とは、$ G $ の全域木の中で辺の重みの和が最小である木のことを言います。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N\ -\ 1\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ a_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ b_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ c_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ M) $
- $ c_i\ \neq\ c_j $ $ (1\ \leq\ i\ \lt\ j\ \leq\ M) $
- グラフ $ G $ は連結である。
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ Q) $
- $ 1\ \leq\ v_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ Q) $
- $ 1\ \leq\ w_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ Q) $
- $ w_i\ \neq\ c_j $ $ (1\ \leq\ i\ \leq\ Q,\ 1\ \leq\ j\ \leq\ M) $
- 入力はすべて整数である。

### Sample Explanation 1

以下では頂点 $ u $ と頂点 $ v $ を結ぶ重み $ w $ の無向辺を $ (u,v,w) $ と表します。 $ G $ を図に表したものを以下に挙げます。 !\[image\](https://img.atcoder.jp/ghi/15ac15edee5a8b055f65192d7323d43b.png) たとえばクエリ $ 1 $ では $ G $ に $ e_1\ =\ (1,3,1) $ を追加したグラフ $ G_1 $ を考えます。$ G_1 $ の最小全域木 $ T_1 $ の辺集合は $ \lbrace\ (1,2,2),(1,3,1),(2,4,5),(3,5,8)\ \rbrace $ であり $ e_1 $ を含みます。よって `Yes` を出力します。

## 样例 #1

### 输入

```
5 6 3

1 2 2

2 3 3

1 3 6

2 4 5

4 5 9

3 5 8

1 3 1

3 4 7

3 5 7```

### 输出

```
Yes

No

Yes```

## 样例 #2

### 输入

```
2 3 2

1 2 100

1 2 1000000000

1 1 1

1 2 2

1 1 5```

### 输出

```
Yes

No```

# AI分析结果

### 题目内容重写

给定一个包含 $N$ 个顶点和 $M$ 条边的无向连通图 $G$，每条边都有一个唯一的权重。有 $Q$ 个查询，每个查询给出一个边 $(u_i, v_i, w_i)$，询问如果将这条边添加到图 $G$ 中，新的最小生成树 $T_i$ 是否包含这条边。输出 `Yes` 或 `No`。

### 算法分类
并查集、图论

### 题解分析与结论

本题的核心思路是通过并查集和 Kruskal 算法来高效处理查询。由于每次查询都是独立的，且边权唯一，可以通过离线处理所有边（包括查询边）并按权重排序，然后在构建最小生成树的过程中判断查询边是否会被选中。

### 高星题解

#### 题解1：MinimumSpanningTree (5星)
**关键亮点**：
- 使用离线处理，将所有边（包括查询边）按权重排序。
- 在 Kruskal 算法中，通过并查集判断查询边是否会被选中。
- 代码清晰，逻辑严谨，时间复杂度优化到 $O((M+Q) \log (M+Q))$。

**核心代码**：
```cpp
sort(a+1,a+m+1,cmp); // 按边权排序
for(int i=1;i<=m;i++) {
    if(find1(a[i].x)!=find1(a[i].y)) {
        if(a[i].id) r[a[i].id]=true; // 是查询边，标记为Yes
        else merge1(a[i].x,a[i].y),cnt++; // 是原图边，合并
    }
    if(cnt==n-1) break; // 最小生成树生成完成
}
```

#### 题解2：Enoch006 (4星)
**关键亮点**：
- 同样采用离线处理，将所有边按权重排序。
- 在 Kruskal 算法中，通过并查集判断查询边是否会被选中。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
sort(a+1,a+m+q+1,cmp); // 按边权排序
for(int i=1;i<=m+q;i++) {
    f1=getfa(a[i].x);
    f2=getfa(a[i].y);
    if(f1!=f2) {
        if(a[i].k>m) ans[a[i].k-m]=1; // 是查询边，标记为Yes
        else fa[f1]=f2, k++; // 是原图边，合并
    }
    if(k==n-1) break; // 最小生成树生成完成
}
```

#### 题解3：dlzlj_2010 (4星)
**关键亮点**：
- 离线处理，将所有边按权重排序。
- 在 Kruskal 算法中，通过并查集判断查询边是否会被选中。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
sort(e+1,e+1+m+q,cmp); // 按边权排序
for(int i=1;i<=m+q;i++) {
    int u=e[i].u,v=e[i].v;
    u=find(u),v=find(v);
    if(u==v) continue;
    if(e[i].id>m) ans[e[i].id-m]=1; // 是查询边，标记为Yes
    else unionn(u,v); // 是原图边，合并
}
```

### 最优关键思路或技巧
1. **离线处理**：将所有边（包括查询边）按权重排序，避免多次重复排序。
2. **并查集优化**：通过并查集快速判断两个顶点是否连通，优化 Kruskal 算法的效率。
3. **标记查询边**：在构建最小生成树的过程中，直接标记查询边是否会被选中，避免后续重复查询。

### 可拓展之处
- 类似的问题可以扩展到动态最小生成树，即边权可以动态变化的情况。
- 可以结合 LCA 和树剖分等算法，进一步优化查询效率。

### 推荐题目
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
2. [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)
3. [P4180 【模板】严格次小生成树](https://www.luogu.com.cn/problem/P4180)

---
处理用时：30.14秒
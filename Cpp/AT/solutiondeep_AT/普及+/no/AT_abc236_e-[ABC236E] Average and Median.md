# 题目信息

# [ABC236E] Average and Median

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc236/tasks/abc236_e

$ N $ 枚のカードがあり、$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 番目のカードには整数 $ A_i $ が書かれています。

高橋君は、これらのカードから好きな枚数選びます。ただし、各 $ i\ \,\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ について、$ i $ 番目のカードと $ i\ +\ 1 $ 番目のカードの少なくとも一方を選ぶ必要があります。

以下の値を求めてください。

- 選んだカードに書かれた整数の平均値としてあり得る最大値
- 選んだカードに書かれた整数の中央値としてあり得る最大値

ただし、$ n $ 個の整数の中央値は、それらのうち小さい方から数えて $ \lceil\ \frac{n}{2}\ \rceil $ 番目であるものとします。ここで、$ \lceil\ x\ \rceil $ は $ x $ 以上の最小の整数を表します。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^{9} $
- 入力は全て整数である。

### Sample Explanation 1

$ 2 $ 番目、$ 4 $ 番目、$ 6 $ 番目のカードを選ぶと、書かれた整数の平均は $ \frac{12}{3}\ =\ 4 $ となり、これが最大です。 $ 1 $ 番目、$ 3 $ 番目、$ 5 $ 番目、$ 6 $ 番目のカードを選ぶと、書かれた整数の中央値は $ 2 $ となり、これが最大です。

### Sample Explanation 2

平均値の出力については誤差が認められるので、例えば $ 5.2491 $ と出力しても正答とみなされます。ただし、中央値は正確な値を出力しなければなりません。

## 样例 #1

### 输入

```
6

2 1 2 1 1 10```

### 输出

```
4

2```

## 样例 #2

### 输入

```
7

3 1 4 1 5 9 2```

### 输出

```
5.250000000

4```

# AI分析结果

### 题目内容重写
$ N $ 张卡片排成一列，第 $ i $ 张卡片上写有整数 $ A_i $。高桥君需要从这些卡片中选择若干张，且满足以下条件：对于任意相邻的两张卡片，至少选择其中一张。请计算以下两个值：

1. 所选卡片上整数的平均值的最大可能值。
2. 所选卡片上整数的中位数的最大可能值。

其中，$ n $ 个整数的中位数定义为从小到大排序后第 $ \lceil \frac{n}{2} \rceil $ 个数。

### 算法分类
二分 + 动态规划

### 题解分析与结论
本题的核心思路是通过二分答案结合动态规划来求解平均值和中位数的最大值。所有题解均采用了二分搜索来枚举可能的平均值和中位数，并通过动态规划来验证这些值是否满足条件。具体来说，对于平均值，题解通过将每个数减去二分的中值，转化为求子序列和是否大于等于0的问题；对于中位数，题解通过将数映射为1或-1，转化为求子序列和是否大于0的问题。

### 所选高星题解

#### 题解1：chengning0909 (5星)
**关键亮点**：
- 清晰地解释了二分和动态规划的结合使用。
- 详细说明了如何通过二分搜索和动态规划来验证平均值和中位数的合法性。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
bool check1(double x) {
    for (int i = 1; i <= n; i++) {
        dp[i] = max(dp[i-1], dp[i-2]) + (a[i] - x);
    }
    return max(dp[n], dp[n-1]) >= 0;
}

bool check2(int x) {
    for (int i = 1; i <= n; i++) {
        dp[i] = max(dp[i-1], dp[i-2]) + (a[i] >= x ? 1 : -1);
    }
    return max(dp[n], dp[n-1]) > 0;
}
```

#### 题解2：jerry1717 (4星)
**关键亮点**：
- 提供了详细的二分搜索和动态规划的实现细节。
- 强调了二分搜索的精度控制和动态规划的状态转移。

**核心代码**：
```cpp
bool cheak(double x) {
    memset(f, 0, sizeof(f));
    for (int i = 1; i <= n; i++) {
        f[i][0] = f[i-1][1];
        f[i][1] = max(f[i-1][0] + a[i] - x, f[i-1][1] + a[i] - x);
    }
    return max(f[n][1], f[n][0]) >= 0;
}

bool chaek(int x) {
    memset(f, 0, sizeof(f));
    for (int i = 1; i <= n; i++) {
        if (a[i] >= x) f[i][1] = max(f[i-1][0] + 1, f[i-1][1] + 1);
        else f[i][1] = max(f[i-1][0] - 1, f[i-1][1] - 1);
        f[i][0] = f[i-1][1];
    }
    return max(f[n][1], f[n][0]) >= 1;
}
```

#### 题解3：2huk (4星)
**关键亮点**：
- 详细解释了二分搜索和动态规划的结合使用。
- 提供了清晰的代码实现和状态转移方程。

**核心代码**：
```cpp
bool check1(double x) {
    for (int i = 1; i <= n; i++) {
        dp[i] = max(dp[i-1], dp[i-2]) + (a[i] - x);
    }
    return max(dp[n], dp[n-1]) >= 0;
}

bool check2(int x) {
    for (int i = 1; i <= n; i++) {
        dp[i] = max(dp[i-1], dp[i-2]) + (a[i] >= x ? 1 : -1);
    }
    return max(dp[n], dp[n-1]) > 0;
}
```

### 最优关键思路与技巧
1. **二分搜索**：通过二分搜索来枚举可能的平均值和中位数，结合动态规划验证其合法性。
2. **动态规划**：通过动态规划来计算子序列的最大和，验证二分搜索的结果是否满足条件。
3. **状态转移方程**：对于平均值，状态转移方程为 `dp[i] = max(dp[i-1], dp[i-2]) + (a[i] - x)`；对于中位数，状态转移方程为 `dp[i] = max(dp[i-1], dp[i-2]) + (a[i] >= x ? 1 : -1)`。

### 可拓展之处
类似的问题可以通过二分搜索和动态规划的结合来解决，例如求最大子序列和、最大平均值等问题。此外，这种思路也可以应用于其他需要验证某种条件是否满足的问题。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

---
处理用时：34.09秒
# 题目信息

# [ABC238E] Range Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc238/tasks/abc238_e

高橋くんは秘密の整数列 $ a $ を持っており、現時点で、$ a $ の長さが $ N $ であることは分かっています。

$ a $ の中身を当てたいあなたに対し、高橋くんは以下の $ Q $ 個の情報を追加で与えてくれることを約束しました。

- $ i\ (1\ \leq\ i\ \leq\ Q) $ 個目の情報: $ a_{l_i}+a_{l_i+1}+\cdots+a_{r_i} $ の値

高橋くんが約束を守り、$ Q $ 個の情報すべてが与えられた場合、$ a $ に含まれる全要素の総和 $ a_1+a_2+\cdots+a_N $ を特定することは可能ですか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ \min(2\ \times\ 10^5,\frac{N(N+1)}{2}) $
- $ 1\ \leq\ l_i\ \leq\ r_i\ \leq\ N $
- $ (l_i,r_i)\ \neq\ (l_j,r_j)\ (i\ \neq\ j) $
- 入力はすべて整数

### Sample Explanation 1

$ 1 $ 個目の情報と $ 2 $ 個目の情報から、$ a_1+a_2+a_2+a_3 $ の値が分かります。そこから $ 3 $ 個目の情報によって得られる $ a_2 $ の値を引くと、$ a_1+a_2+a_3 $ の値を特定可能です。

### Sample Explanation 2

$ a $ の先頭 $ 3 $ 項の総和を特定することは可能ですが、全要素の総和を特定することは不可能です。

### Sample Explanation 3

$ 4 $ 個目の情報によって全要素の総和が直接与えられています。

## 样例 #1

### 输入

```
3 3

1 2

2 3

2 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
4 3

1 3

1 2

2 3```

### 输出

```
No```

## 样例 #3

### 输入

```
4 4

1 1

2 2

3 3

1 4```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写
高桥君有一个秘密的整数序列 $a$，已知其长度为 $N$。为了让你猜出这个序列的内容，高桥君承诺会给出 $Q$ 个额外的信息，每个信息表示 $a$ 中某个区间的和。具体来说，第 $i$ 个信息表示 $a_{l_i}+a_{l_i+1}+\cdots+a_{r_i}$ 的值。

问题是：在给出所有 $Q$ 个信息后，能否确定整个序列 $a$ 的总和 $a_1+a_2+\cdots+a_N$？

### 算法分类
并查集

### 题解分析与结论
本题的核心思路是利用前缀和和并查集来判断是否能够通过给定的区间和信息推导出整个序列的总和。具体来说，每个区间和可以转化为前缀和之间的关系，即 $s_r - s_{l-1} = \text{ans}$。通过并查集维护这些关系，最终判断 $s_0$ 和 $s_n$ 是否在同一个连通块中。

### 精选题解
#### 题解1：BLuemoon_ (5星)
**关键亮点**：
- 利用前缀和和并查集的思想，将区间和转化为前缀和之间的关系。
- 通过并查集维护连通性，判断 $s_0$ 和 $s_n$ 是否连通。
- 代码简洁，思路清晰。

**核心代码**：
```cpp
int find(int x) {
  return fa[x]==x?x:fa[x]=find(fa[x]);
}
int main() {
  cin>>n>>q;
  for(int i=0;i<=n+3;i++) fa[i]=i;
  for(int i=1;i<=q;i++) {
    cin>>l>>r;
    fa[find(r)]=find(l-1);
  }
  cout<<(find(0)==find(n)?"Yes":"No")<<'\n';
  return 0;
}
```

#### 题解2：loser_seele (4星)
**关键亮点**：
- 同样利用前缀和和并查集的思想，将区间和转化为前缀和之间的关系。
- 详细解释了如何通过并查集维护连通性。
- 代码实现较为复杂，但思路清晰。

**核心代码**：
```cpp
int find(int x) {
  return fa[x]==x?x:fa[x]=find(fa[x]);
}
int main() {
  cin>>n>>q;
  for(int i=0;i<=n;i++) fa[i]=i;
  while(q--) {
    cin>>l>>r;
    fa[find(l-1)]=find(r);
  }
  if(find(0)==find(n)) cout<<"Yes";
  else cout<<"No";
  return 0;
}
```

#### 题解3：xiezheyuan (4星)
**关键亮点**：
- 利用前缀和和并查集的思想，将区间和转化为前缀和之间的关系。
- 代码简洁，思路清晰，适合初学者理解。

**核心代码**：
```cpp
int find(int x) {
  if(fa[x]==x) return x;
  else return fa[x]=find(fa[x]);
}
int main() {
  cin>>n>>q;
  for(int i=0;i<=n;i++) fa[i]=i;
  for(int i=1;i<=q;i++) {
    int l,r;
    cin>>l>>r;
    fa[find(l-1)]=find(r);
  }
  cout<<(find(0)==find(n)?"Yes":"No")<<'\n';
  return 0;
}
```

### 最优关键思路
利用前缀和和并查集的思想，将区间和转化为前缀和之间的关系，通过并查集维护连通性，最终判断 $s_0$ 和 $s_n$ 是否在同一个连通块中。

### 拓展思路
类似的问题可以通过并查集维护连通性来解决，例如判断两个节点是否连通、合并集合等。并查集在图论、动态连通性等问题中有广泛应用。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)

---
处理用时：28.26秒
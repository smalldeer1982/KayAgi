# 题目信息

# [ABC240F] Sum Sum Max

## 题目描述

有三个数列 $A,B,C$。

其中 $C$ 表示为 $ x_1,\ \dots,\ x_N,\ y_1,\ \dots,\ y_N $ 的形式，意思是前 $y_1$ 个数为 $x_1$,之后 $y_2$ 个数为 $x_2$……最后 $y_N$ 个数为 $x_N$。

$B$ 为 $C$ 的前缀和数组。

$A$ 为 $B$ 的前缀和数组。

求 $A$ 中最大值。

## 说明/提示

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ \sum\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^9 $
- $ |x_i|\ \leq\ 4\ \,\ (1\ \leq\ i\ \leq\ N) $
- $ y_i\ \gt\ 0\ \,\ (1\ \leq\ i\ \leq\ N) $
- $ \sum_{k\ =\ 1}^N\ y_k\ =\ M $

## 样例 #1

### 输入

```
3

3 7

-1 2

2 3

-3 2

10 472

-4 12

1 29

2 77

-1 86

0 51

3 81

3 17

-2 31

-4 65

4 23

1 1000000000

4 1000000000```

### 输出

```
4

53910

2000000002000000000```

# AI分析结果

【题目内容】
# [ABC240F] Sum Sum Max

## 题目描述

有三个数列 $A,B,C$。

其中 $C$ 表示为 $ x_1,\ \dots,\ x_N,\ y_1,\ \dots,\ y_N $ 的形式，意思是前 $y_1$ 个数为 $x_1$,之后 $y_2$ 个数为 $x_2$……最后 $y_N$ 个数为 $x_N$。

$B$ 为 $C$ 的前缀和数组。

$A$ 为 $B$ 的前缀和数组。

求 $A$ 中最大值。

## 说明/提示

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ \sum\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^9 $
- $ |x_i|\ \leq\ 4\ \,\ (1\ \leq\ i\ \leq\ N) $
- $ y_i\ \gt\ 0\ \,\ (1\ \leq\ i\ \leq\ N) $
- $ \sum_{k\ =\ 1}^N\ y_k\ =\ M $

## 样例 #1

### 输入

```
3

3 7

-1 2

2 3

-3 2

10 472

-4 12

1 29

2 77

-1 86

0 51

3 81

3 17

-2 31

-4 65

4 23

1 1000000000

4 1000000000```

### 输出

```
4

53910

2000000002000000000```

【算法分类】  
前缀和

【题解分析与结论】  
该题的核心在于如何高效计算数列 $A$ 的最大值，而 $A$ 是 $B$ 的前缀和，$B$ 又是 $C$ 的前缀和。由于 $C$ 的构造方式特殊，直接模拟计算会导致时间复杂度过高。因此，题解中普遍采用了分段处理的方法，利用等差数列的性质和前缀和的递推关系，避免了不必要的计算。

1. **分段处理**：将 $C$ 分为 $N$ 段，每段的值相同，利用等差数列的性质快速计算 $B$ 和 $A$ 的值。
2. **极值点分析**：由于 $A$ 的最大值可能出现在每段的端点或极值点，因此需要对每段进行极值点分析。
3. **二分优化**：在确定极值点时，使用二分查找来优化计算过程，减少时间复杂度。

【所选高星题解】  
1. **作者：appear_hope (4星)**  
   - **关键亮点**：利用二分查找优化极值点的计算，代码清晰且高效。
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++){
         int l = 0, r = a[i].second;
         while(l < r){
             int mid = (l + r + 1) >> 1;
             b[i - 1] + 1ll * mid * a[i].first >= 0 ? l = mid : r = mid - 1;
         }
         if(b[i - 1] + 1ll * l * a[i].first >= 0 && (i == 1 && l > 1 || i > 1)){
             ans = max(ans, sum + b[i - 1] * l + 1ll * (l + 1) * l / 2 * a[i].first);
         }
         sum += b[i - 1] * a[i].second + (1 + a[i].second) * a[i].second / 2 * a[i].first;
         ans = max(ans, sum);
     }
     ```
   - **个人心得**：通过二分查找优化了极值点的计算，避免了不必要的遍历。

2. **作者：WaterSun (4星)**  
   - **关键亮点**：通过分段处理，利用等差数列的性质快速计算 $A$ 的最大值，代码简洁且高效。
   - **核心代码**：
     ```cpp
     if(x >= 0){
         res += sum * y + x * (y + 1) * y / 2;
         Max = max(Max,res);
     }
     else{
         int l = max(1ll,min(sum / (-x),y));
         int del = sum * l + x * (l + 1) * l / 2;
         Max = max(Max,res + del);
         res += sum * y + x * (y + 1) * y / 2;
         Max = max(Max,res);
     }
     sum += x * y;
     ```
   - **个人心得**：通过分段处理，利用等差数列的性质快速计算 $A$ 的最大值，避免了不必要的遍历。

【最优关键思路】  
- **分段处理**：将 $C$ 分为 $N$ 段，每段的值相同，利用等差数列的性质快速计算 $B$ 和 $A$ 的值。
- **二分优化**：在确定极值点时，使用二分查找来优化计算过程，减少时间复杂度。

【可拓展之处】  
类似的分段处理和二分优化方法可以应用于其他需要处理大规模数据且具有分段性质的问题，如区间求和、区间最大值等。

【推荐题目】  
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)  
2. [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)  
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

---
处理用时：36.53秒
# 题目信息

# [ABC241F] Skate

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc241/tasks/abc241_f

$ H $ 行 $ W $ 列のグリッド型のスケート場があります。上から $ i $ 行目、左から $ j $ 行目のマスを $ (i,j) $ で表します。

スケート場には $ N $ 個の障害物があり、$ i $ 個目の障害物は $ (X_i,Y_i) $ に置かれています。

高橋君は $ 1 $ 回の移動において、上下左右いずれかの方向を選んで、障害物に当たるまで進み続けます。  
 障害物に当たるとその $ 1 $ つ手前のマスで停止します。 なお、スケート場の周りは崖になっており、障害物に当たらないような移動は禁止とします。

高橋君ははじめ $ (s_x,s_y) $ にいて、何回か移動することで $ (g_x,g_y) $ で停止したいと考えています。

$ (g_x,g_y) $ へ辿り着くには最小で何回の移動が必要ですか？辿り着けないときはその旨を伝えてください。

## 说明/提示

### 制約

- $ 1\leq\ H\ \leq\ 10^9 $
- $ 1\leq\ W\ \leq\ 10^9 $
- $ 1\leq\ N\ \leq\ 10^5 $
- $ 1\leq\ s_x,g_x\leq\ H $
- $ 1\leq\ s_y,g_y\leq\ W $
- $ 1\leq\ X_i\ \leq\ H $
- $ 1\leq\ Y_i\ \leq\ W $
- $ (s_x,s_y)\neq\ (g_x,g_y) $
- $ (s_x,s_y)\neq\ (X_i,Y_i) $
- $ (g_x,g_y)\neq\ (X_i,Y_i) $
- $ i\neq\ j $ ならば、$ (X_i,Y_i)\neq\ (X_j,Y_j) $
- 入力は全て整数である

### Sample Explanation 1

!\[\](https://img.atcoder.jp/ghi/c376ca3813eb4c947eb605dea2d30454.png) 図は、$ (s_x,s_y) $ を `S` で、$ (g_x,g_y) $ を `G` で表しています。 $ (3,4)\rightarrow(2,4)\ \rightarrow(2,2)\ \rightarrow(5,2)\ \rightarrow(5,6) $ と移動すると、$ 4 $ 回の移動で $ (g_x,g_y) $ に辿り着くことができます。

### Sample Explanation 2

!\[\](https://img.atcoder.jp/ghi/07ab8a3e7c94525cd52704dd43e43b87.png) $ (g_x,g_y) $ で停止する必要があります。 通過しただけでは $ (g_x,g_y) $ へ辿り着いたとみなされないことに注意してください。

### Sample Explanation 3

!\[\](https://img.atcoder.jp/ghi/a423524262f4a075b94e2ab5f9e61164.png) 左を選んで進むと、高橋君は $ (g_x,g_y) $ を通過したのちに崖に落ちてしまいます。 スケート場の周りは崖になっており、障害物に当たらないような移動は禁止されていることに注意してください。

## 样例 #1

### 输入

```
7 8 7

3 4

5 6

1 4

2 1

2 8

4 5

5 7

6 2

6 6```

### 输出

```
4```

## 样例 #2

### 输入

```
4 6 2

3 2

3 5

4 5

2 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
1 10 1

1 5

1 1

1 7```

### 输出

```
-1```

# AI分析结果

### 题目翻译
**题目描述**

有一个 $H$ 行 $W$ 列的网格型溜冰场。从上到下第 $i$ 行，从左到右第 $j$ 列的格子用 $(i,j)$ 表示。

溜冰场上有 $N$ 个障碍物，第 $i$ 个障碍物位于 $(X_i,Y_i)$。

高桥君每次移动可以选择上下左右任意一个方向，直到碰到障碍物为止，并在障碍物前一个格子停下。由于溜冰场四周是悬崖，因此不能向没有障碍物的方向移动。

高桥君最初位于 $(s_x,s_y)$，希望通过若干次移动到达 $(g_x,g_y)$ 并停下。

问最少需要多少次移动才能到达目标点？如果无法到达，输出 `-1`。

**说明/提示**

- $1 \leq H, W \leq 10^9$
- $1 \leq N \leq 10^5$
- $1 \leq s_x, g_x \leq H$
- $1 \leq s_y, g_y \leq W$
- $1 \leq X_i \leq H$
- $1 \leq Y_i \leq W$
- $(s_x,s_y) \neq (g_x,g_y)$
- $(s_x,s_y)$ 和 $(g_x,g_y)$ 都不是障碍物
- 所有输入均为整数

**样例解释**

样例1中，高桥君可以通过 $(3,4) \rightarrow (2,4) \rightarrow (2,2) \rightarrow (5,2) \rightarrow (5,6)$ 的路径，用4次移动到达目标点。

样例2中，无法到达目标点。

样例3中，高桥君会滑过目标点并掉下悬崖，因此无法到达目标点。

### 算法分类
**广度优先搜索 BFS**

### 题解分析与结论
本题的核心是通过 BFS 找到从起点到终点的最短路径。由于网格非常大（$H, W \leq 10^9$），直接进行普通的 BFS 会超时。因此，题解的关键在于利用障碍物的位置来优化 BFS 的移动过程。

**关键思路：**
1. **障碍物存储与查询**：使用 `map<int, set<int>>` 分别存储每行和每列的障碍物位置。这样可以在 BFS 中快速查询某个方向上最近的障碍物。
2. **二分查找优化**：在 BFS 过程中，通过 `lower_bound` 和 `upper_bound` 快速找到当前点某个方向上最近的障碍物，从而确定移动后的位置。
3. **状态存储**：使用 `map<pair<int, int>, int>` 来存储每个点的距离，避免重复访问。

**难点对比：**
- **卷王** 和 **joe_zxq** 的题解思路相似，都使用了 `map` 和 `set` 来存储障碍物，并通过二分查找优化 BFS 的移动过程。代码简洁且易于理解。
- **Mikran** 的题解通过将障碍物按行和列排序，并在 BFS 中进行二分查找，思路清晰但代码稍显冗长。
- **封禁用户** 的题解使用了优先队列和复杂的二分查找函数，代码复杂度较高，不易于理解。
- **igAC** 和 **AlicX** 的题解思路与卷王和 joe_zxq 类似，但代码实现上略有不同，整体较为简洁。
- **cwxcplh** 的题解思路清晰，代码简洁，适合初学者理解。

### 精选题解
#### 1. 卷王 (5星)
**关键亮点：**
- 使用 `map<int, set<int>>` 存储障碍物，代码简洁且高效。
- 通过 `lower_bound` 和 `upper_bound` 快速找到最近的障碍物，优化 BFS 的移动过程。
- 代码可读性强，适合初学者理解。

**核心代码：**
```cpp
auto it = row[ux].lower_bound(uy);
if (it != row[ux].end()) add(ux, *it - 1, dist + 1);
if (it != row[ux].begin()) add(ux, *(--it) + 1, dist + 1);
```

#### 2. joe_zxq (5星)
**关键亮点：**
- 使用 `map<int, set<int>>` 存储障碍物，并通过 `lower_bound` 和 `upper_bound` 优化 BFS。
- 代码结构清晰，注释详细，易于理解。

**核心代码：**
```cpp
auto it1 = mp1[x].lower_bound(y);
if (it1 != mp1[x].end()) add(x, *it1 - 1, dist + 1);
if (it1 != mp1[x].begin()) add(x, *(--it1) + 1, dist + 1);
```

#### 3. igAC (4星)
**关键亮点：**
- 使用 `map<int, set<int>>` 存储障碍物，并通过 `lower_bound` 优化 BFS。
- 代码简洁，适合快速理解 BFS 的优化思路。

**核心代码：**
```cpp
auto it1 = mp1[x].lower_bound(y);
if (it1 != mp1[x].end()) add(x, *it1 - 1, dist + 1);
if (it1 != mp1[x].begin()) add(x, *(--it1) + 1, dist + 1);
```

### 最优关键思路
- **数据结构选择**：使用 `map<int, set<int>>` 存储每行和每列的障碍物，方便快速查询。
- **二分查找优化**：通过 `lower_bound` 和 `upper_bound` 快速找到最近的障碍物，减少 BFS 的移动次数。
- **状态存储**：使用 `map<pair<int, int>, int>` 存储每个点的距离，避免重复访问。

### 拓展思路
- 类似的问题可以通过 BFS 结合二分查找来优化，尤其是在网格较大但障碍物较少的情况下。
- 可以进一步优化 BFS 的移动过程，例如通过预处理障碍物的位置，减少查询时间。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1131 [ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131)

---
处理用时：44.46秒
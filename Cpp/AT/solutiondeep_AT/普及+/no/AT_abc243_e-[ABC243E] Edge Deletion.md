# 题目信息

# [ABC243E] Edge Deletion

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc243/tasks/abc243_e

$ N $ 頂点 $ M $ 辺の単純連結無向グラフが与えられます。  
 辺 $ i $ は頂点 $ A_i $ と頂点 $ B_i $ を結ぶ長さ $ C_i $ の辺です。

以下の条件を満たすようにいくつかの辺を削除します。削除する辺の数の最大値を求めてください。

- 辺を削除した後のグラフも連結である。
- 全ての頂点対 $ (s,t) $ について、頂点 $ s $ と頂点 $ t $ の間の距離が削除前と削除後で変化しない。

## 说明/提示

### 注釈

単純連結無向グラフとは、単純かつ連結で辺に向きの無いグラフのことをいいます。  
 グラフが単純であるとは、グラフが自己ループや多重辺を含まないことをいいます。  
 グラフが連結であるとは、グラフ上の任意の $ 2 $ 頂点 $ s,\ t $ について $ s $ から $ t $ へ辺をたどって行けることをいいます。  
 頂点 $ s $ と頂点 $ t $ の間の距離とは、頂点 $ s $ と頂点 $ t $ の間の最短路の長さのことをいいます。

### 制約

- $ 2\ \leq\ N\ \leq\ 300 $
- $ N-1\ \leq\ M\ \leq\ \frac{N(N-1)}{2} $
- $ 1\ \leq\ A_i\ \lt\ B_i\ \leq\ N $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- $ i\ \neq\ j $ ならば $ (A_i,\ B_i)\ \neq\ (A_j,\ B_j) $ である。
- 与えられるグラフは連結である。
- 入力はすべて整数である。

### Sample Explanation 1

辺を削除する前の全ての頂点対の距離は次の通りです。 - 頂点 $ 1 $ と頂点 $ 2 $ の距離は $ 2 $ - 頂点 $ 1 $ と頂点 $ 3 $ の距離は $ 5 $ - 頂点 $ 2 $ と頂点 $ 3 $ の距離は $ 3 $ 辺 $ 3 $ を削除しても全ての頂点間の距離は変化しません。また、問題文の条件を満たすように $ 2 $ 本以上の辺を削除することはできないので、答えは $ 1 $ 本になります。

### Sample Explanation 2

どの辺も削除することができません。

## 样例 #1

### 输入

```
3 3

1 2 2

2 3 3

1 3 6```

### 输出

```
1```

## 样例 #2

### 输入

```
5 4

1 3 3

2 3 9

3 5 3

4 5 3```

### 输出

```
0```

## 样例 #3

### 输入

```
5 10

1 2 71

1 3 9

1 4 82

1 5 64

2 3 22

2 4 99

2 5 1

3 4 24

3 5 18

4 5 10```

### 输出

```
5```

# AI分析结果

### 题目内容重写
给定一个 $N$ 个顶点 $M$ 条边的简单连通无向图，边 $i$ 连接顶点 $A_i$ 和 $B_i$，长度为 $C_i$。要求删除一些边，使得删除后的图仍然连通，并且任意两个顶点之间的最短路径长度不变。求最多可以删除多少条边。

### 算法分类
最短路

### 题解分析与结论
本题的核心思路是通过 Floyd 算法计算所有顶点对之间的最短路径，然后判断每条边是否可以被删除。删除边的条件是存在一个中转点 $k$，使得 $u \to k \to v$ 的路径长度不超过 $u \to v$ 的直接边长度。所有题解都基于这一思路，使用 Floyd 算法进行求解。

### 评分较高的题解
1. **作者：ikunTLE**  
   - **星级：5**  
   - **关键亮点**：思路清晰，代码简洁，使用 Floyd 算法计算最短路，并通过标记数组记录哪些边可以被删除。  
   - **核心代码**：
     ```cpp
     for(int k=1;k<=n;++k)
         for(int i=1;i<=n;++i)
             for(int j=1;j<=n;++j){
                 if(i==j||i==k||k==j) continue;
                 if(f[i][j]==f[i][k]+f[k][j]) g[i][j]=true;
                 f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
             }
     ```
   - **个人心得**：通过 Floyd 算法松弛时标记可以删除的边，思路直接且高效。

2. **作者：Zyh_AKer**  
   - **星级：4.5**  
   - **关键亮点**：代码结构清晰，使用 Floyd 算法计算最短路，并通过布尔数组记录哪些边可以被删除。  
   - **核心代码**：
     ```cpp
     for(int k=1;k<=n;k++)
         for(int i=1;i<=n;i++)
             for(int j=1;j<=n;j++){
                 if(g[i][j]==(g[i][k]+g[k][j]) && i!=k && k!=j) d[i][j]=true;
                 g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
             }
     ```
   - **个人心得**：通过 Floyd 算法松弛时标记可以删除的边，思路直接且高效。

3. **作者：Rigel**  
   - **星级：4**  
   - **关键亮点**：使用 Floyd 算法计算最短路，并通过标记数组记录哪些边可以被删除。  
   - **核心代码**：
     ```cpp
     for(int k=1;k<=n;k++)
         for(int i=1;i<=n;i++)
             for(int j=1;j<=n;j++){
                 if(i==j||i==k||k==j) continue;
                 int nw=a[i][k]+a[k][j];
                 if(nw==a[i][j]) f[i][j]=1;
                 if(nw<a[i][j]) a[i][j]=nw;
             }
     ```
   - **个人心得**：通过 Floyd 算法松弛时标记可以删除的边，思路直接且高效。

### 最优关键思路
使用 Floyd 算法计算所有顶点对之间的最短路径，并在松弛过程中标记可以删除的边。通过判断是否存在中转点 $k$，使得 $u \to k \to v$ 的路径长度不超过 $u \to v$ 的直接边长度，来确定边是否可以删除。

### 拓展思路
类似的问题可以通过 Floyd 或 Dijkstra 算法计算最短路，并结合图的连通性进行边的删除或添加。可以进一步探讨在删除边后如何保持图的连通性，或者如何在删除边后重新计算最短路。

### 推荐题目
1. [P1841 重要的城市](https://www.luogu.com.cn/problem/P1841)
2. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
3. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

---
处理用时：28.76秒
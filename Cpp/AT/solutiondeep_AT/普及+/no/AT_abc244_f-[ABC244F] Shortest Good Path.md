# 题目信息

# [ABC244F] Shortest Good Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc244/tasks/abc244_f

$ N $ 個の頂点と $ M $ 本の辺からなる単純（自己ループおよび多重辺を持たない）かつ連結な無向グラフが与えられます。  
 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結びます。

下記の $ 2 $ つの条件をともに満たす整数列 $ (A_1,\ A_2,\ \ldots,\ A_k) $ を長さ $ k $ の**パス**と呼びます。

- すべての $ i\ =\ 1,\ 2,\ \dots,\ k $ について、$ 1\ \leq\ A_i\ \leq\ N $ 。
- すべての $ i\ =\ 1,\ 2,\ \ldots,\ k-1 $ について、頂点 $ A_i $ と頂点 $ A_{i+1} $ は辺で直接結ばれている。

空列も長さ $ 0 $ のパスとみなします。

$ S\ =\ s_1s_2\ldots\ s_N $ を $ 0 $ と $ 1 $ のみからなる長さ $ N $ の文字列とします。 パス $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_k) $ が下記を満たすとき、パス $ A $ を $ S $ に関する**良いパス**と呼びます。

- すべての $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、次を満たす。
  - $ s_i\ =\ 0 $ ならば、$ A $ に含まれる $ i $ の個数は偶数である。
  - $ s_i\ =\ 1 $ ならば、$ A $ に含まれる $ i $ の個数は奇数である。

$ S $ として考えられる文字列（すなわち、$ 0 $ と $ 1 $ のみからなる長さ $ N $ の文字列）は $ 2^N $ 個ありますが、そのすべてにわたる「 $ S $ に関する良いパスのうち最短のものの長さ」の総和を出力してください。

この問題の制約下において、$ 0 $ と $ 1 $ からなる長さ $ N $ のどのような文字列を $ S $ として選んでも、$ S $ に関する良いパスが少なくとも $ 1 $ つ存在することが示せます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 17 $
- $ N-1\ \leq\ M\ \leq\ \frac{N(N-1)}{2} $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 与えられるグラフは単純かつ連結
- 入力はすべて整数

### Sample Explanation 1

\- $ S\ =\ 000 $ のとき、空列 $ () $ は $ S $ に関する最短の良いパスであり、その長さは $ 0 $ です。 - $ S\ =\ 100 $ のとき、$ (1) $ は $ S $ に関する最短の良いパスであり、その長さは $ 1 $ です。 - $ S\ =\ 010 $ のとき、$ (2) $ は $ S $ に関する最短の良いパスであり、その長さは $ 1 $ です。 - $ S\ =\ 110 $ のとき、$ (1,\ 2) $ は $ S $ に関する最短の良いパスであり、その長さは $ 2 $ です。 - $ S\ =\ 001 $ のとき、$ (3) $ は $ S $ に関する最短の良いパスであり、その長さは $ 1 $ です。 - $ S\ =\ 101 $ のとき、$ (1,\ 2,\ 3,\ 2) $ は $ S $ に関する最短の良いパスであり、その長さは $ 4 $ です。 - $ S\ =\ 011 $ のとき、$ (2,\ 3) $ は $ S $ に関する最短の良いパスであり、その長さは $ 2 $ です。 - $ S\ =\ 111 $ のとき、$ (1,\ 2,\ 3) $ は $ S $ に関する最短の良いパスであり、その長さは $ 3 $ です。 よって、求める答えは $ 0\ +\ 1\ +\ 1\ +\ 2\ +\ 1\ +\ 4\ +\ 2\ +\ 3\ =\ 14 $ です。

## 样例 #1

### 输入

```
3 2

1 2

2 3```

### 输出

```
14```

## 样例 #2

### 输入

```
5 5

4 2

2 3

1 3

2 1

1 5```

### 输出

```
108```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个由 $N$ 个顶点和 $M$ 条边组成的简单（无自环和多重边）且连通的无向图。  
对于 $i\ =\ 1,\ 2,\ \ldots,\ M$，第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$。

满足以下两个条件的整数序列 $ (A_1,\ A_2,\ \ldots,\ A_k) $ 称为长度为 $k$ 的**路径**：

- 对于所有 $i\ =\ 1,\ 2,\ \dots,\ k$，$1\ \leq\ A_i\ \leq\ N$。
- 对于所有 $i\ =\ 1,\ 2,\ \ldots,\ k-1$，顶点 $A_i$ 和顶点 $A_{i+1}$ 之间有一条边直接连接。

空序列也被视为长度为 $0$ 的路径。

$S\ =\ s_1s_2\ldots\ s_N$ 是一个由 $0$ 和 $1$ 组成的长度为 $N$ 的字符串。路径 $A\ =\ (A_1,\ A_2,\ \ldots,\ A_k)$ 满足以下条件时，称为 $S$ 的**好路径**：

- 对于所有 $i\ =\ 1,\ 2,\ \ldots,\ N$，满足以下条件：
  - 如果 $s_i\ =\ 0$，则 $A$ 中包含的 $i$ 的个数为偶数。
  - 如果 $s_i\ =\ 1$，则 $A$ 中包含的 $i$ 的个数为奇数。

$S$ 的所有可能字符串（即由 $0$ 和 $1$ 组成的长度为 $N$ 的字符串）共有 $2^N$ 个，求所有 $S$ 的最短好路径长度的总和。

在本题的约束条件下，对于任何由 $0$ 和 $1$ 组成的长度为 $N$ 的字符串 $S$，至少存在一个 $S$ 的好路径。

### 算法分类

广度优先搜索 BFS、位运算、状态压缩

### 题解分析与结论

本题的核心是通过状态压缩和广度优先搜索（BFS）来求解所有可能的 $S$ 的最短好路径长度。各题解均采用了状态压缩的思想，将 $S$ 视为二进制数，并通过 BFS 进行状态转移。难点在于如何高效地表示状态并进行转移，同时保证路径的最短性。

### 所选高分题解

#### 题解1：lyas145 (4星)

**关键亮点**：
- 使用状态压缩表示 $S$，并通过 BFS 进行状态转移。
- 代码清晰，使用了邻接矩阵存储图结构，便于理解。

**核心代码**：
```cpp
void bfs() {
    while (!q.empty()) {
        Node u = q.front();
        q.pop();
        for (int v = 1; v <= n; v++) {
            if (!dis[u.u][v]) continue;
            if (f[v][u.s ^ (1 << (v - 1))] < INF) continue;
            q.push({v, u.s ^ (1 << (v - 1))});
            f[v][u.s ^ (1 << (v - 1))] = f[u.u][u.s] + 1;
        }
    }
}
```
**实现思想**：通过 BFS 遍历所有可能的路径，更新每个状态的最短路径长度。

#### 题解2：loser_seele (4星)

**关键亮点**：
- 采用类似旅行商问题的思路，通过 BFS 预处理距离，最后取最小值。
- 代码简洁，使用了邻接表存储图结构。

**核心代码**：
```cpp
while (q.size()) {
    auto [s, u] = q.front(); q.pop();
    for (auto v : g[u]) {
        int ns = s ^ (1 << v);
        if (dp[ns][v] != 1e9) continue;
        dp[ns][v] = dp[s][u] + 1;
        q.push({ns, v});
    }
}
```
**实现思想**：通过 BFS 遍历所有可能的路径，更新每个状态的最短路径长度。

#### 题解3：appear_hope (4星)

**关键亮点**：
- 状态设计清晰，使用结构体表示状态，便于理解和扩展。
- 代码结构清晰，使用了邻接表存储图结构。

**核心代码**：
```cpp
void Record(int s, int u, int cnt) {
    if (vis[s][u]) return;
    que[++tail] = {s, u, cnt};
    dp[s] = min(dp[s], cnt), vis[s][u] = 1;
}
```
**实现思想**：通过 BFS 遍历所有可能的路径，更新每个状态的最短路径长度。

### 最优关键思路与技巧

1. **状态压缩**：将 $S$ 视为二进制数，便于表示和转移。
2. **广度优先搜索（BFS）**：通过 BFS 遍历所有可能的路径，保证路径的最短性。
3. **邻接表/邻接矩阵**：根据图的大小选择合适的存储结构，提高代码效率。

### 可拓展之处

类似的问题可以通过状态压缩和 BFS 来解决，例如旅行商问题（TSP）等。掌握状态压缩和 BFS 的结合使用，可以解决更多复杂的图论问题。

### 推荐题目

1. [P1171 旅行商问题](https://www.luogu.com.cn/problem/P1171)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 个人心得

在调试过程中，确保状态转移的正确性非常重要。通过打印中间状态，可以更好地理解 BFS 的遍历过程，避免遗漏某些状态。

---
处理用时：37.30秒
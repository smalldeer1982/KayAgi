# 题目信息

# [ABC245E] Wrapping Chocolate

## 题目描述

高桥先生有 $N$ 块巧克力。第 $i$ 块巧克力是长为 $A_i$，宽为 $B_i$ cm 的长方形。高桥先生还有 $M$ 个盒子。第 $i$ 个盒子是长为 $C_i$，宽为 $D_i$ cm 的长方形。

请问是否能在满足以下条件的情况下把所有巧克力放入盒子中。

- 一个盒子中最多放入一块巧克力。
- 当把第 $i$ 块巧克力放入第 $j$ 个盒子的时候，必须满足 $A_i\le C_j$ 并且 $B_i\le D_j$（不允许旋转）。

## 说明/提示

- $1\le N\le M\le 2\times 10^5$
- $1\le A_i,B_i,C_i,D_i\le 10^9$
- 所有数据均为整数。

—— Translated by 2c_s

## 样例 #1

### 输入

```
2 3

2 4

3 2

8 1 5

2 10 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 2

1 1

2 2

100 1

100 1```

### 输出

```
No```

## 样例 #3

### 输入

```
1 1

10

100

100

10```

### 输出

```
No```

## 样例 #4

### 输入

```
1 1

10

100

10

100```

### 输出

```
Yes```

# AI分析结果

【题目内容】
# [ABC245E] Wrapping Chocolate

## 题目描述

高桥先生有 $N$ 块巧克力。第 $i$ 块巧克力是长为 $A_i$，宽为 $B_i$ cm 的长方形。高桥先生还有 $M$ 个盒子。第 $i$ 个盒子是长为 $C_i$，宽为 $D_i$ cm 的长方形。

请问是否能在满足以下条件的情况下把所有巧克力放入盒子中。

- 一个盒子中最多放入一块巧克力。
- 当把第 $i$ 块巧克力放入第 $j$ 个盒子的时候，必须满足 $A_i\le C_j$ 并且 $B_i\le D_j$（不允许旋转）。

## 说明/提示

- $1\le N\le M\le 2\times 10^5$
- $1\le A_i,B_i,C_i,D_i\le 10^9$
- 所有数据均为整数。

—— Translated by 2c_s

## 样例 #1

### 输入

```
2 3

2 4

3 2

8 1 5

2 10 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 2

1 1

2 2

100 1

100 1```

### 输出

```
No```

## 样例 #3

### 输入

```
1 1

10

100

100

10```

### 输出

```
No```

## 样例 #4

### 输入

```
1 1

10

100

10

100```

### 输出

```
Yes```

【算法分类】
贪心

【题解分析与结论】
本题的核心思路是通过排序和贪心策略来匹配巧克力和盒子。大多数题解都采用了将巧克力和盒子合并排序，并使用 `multiset` 来维护可用的盒子，通过 `lower_bound` 查找合适的盒子。这种方法的难点在于如何正确排序和选择盒子，以确保贪心策略的正确性。

【评分较高的题解】
1. **作者：fish_love_cat (5星)**
   - **关键亮点**：详细解释了排序策略和贪心选择的正确性，代码清晰易读。
   - **代码核心思想**：将巧克力和盒子按 `x` 从大到小排序，使用 `multiset` 维护盒子的 `y` 值，通过 `lower_bound` 查找合适的盒子。
   - **代码片段**：
     ```cpp
     sort(a+1,a+n+m+1,cmp);
     for(int i=1;i<=n+m;i++){
         if(a[i].op==1){
             auto it=st.lower_bound(a[i].y);
             if(it==st.end()){
                 cout<<"No";
                 return 0;
             }
             st.erase(it);
         }else{
             st.insert(a[i].y);
         }
     }
     cout<<"Yes";
     ```

2. **作者：hsy8116 (4星)**
   - **关键亮点**：通过图示和详细证明解释了贪心策略的正确性，思路清晰。
   - **代码核心思想**：按 `B` 和 `D` 从大到小排序，使用 `multiset` 维护盒子的 `C` 值，通过 `lower_bound` 查找合适的盒子。
   - **代码片段**：
     ```cpp
     sort(p + 1, p + n + m + 1);
     for (int i = 1; i <= n + m; i ++) {
         if (p[i].t == 2) s.insert(p[i].a);
         else {
             if (s.lower_bound(p[i].a) == s.end()) {
                 puts("No");
                 return 0;
             }
             s.erase(s.lower_bound(p[i].a));
         }
     }
     puts("Yes");
     ```

3. **作者：appear_hope (4星)**
   - **关键亮点**：通过排序消除一维条件，简化问题，代码实现简洁。
   - **代码核心思想**：按 `A` 和 `C` 排序，使用 `multiset` 维护盒子的 `B` 值，通过 `lower_bound` 查找合适的盒子。
   - **代码片段**：
     ```cpp
     sort(a + 1, a + n + m + 1, [](const Node &a, const Node &b){ return a.l < b.l || a.l == b.l && a.id < b.id; });
     for(int i = n + m; i >= 1; i--){
         if(!a[i].id){
             auto it = s.lower_bound(a[i].r);
             if(it == s.end()){
                 cout<<"No";
                 return 0;
             }
             s.erase(it);
         }
         else{
             s.insert(a[i].r);
         }
     }
     cout<<"Yes";
     ```

【最优关键思路或技巧】
- **排序策略**：将巧克力和盒子按 `x` 从大到小排序，若 `x` 相等则按 `y` 从大到小排序，若 `x` 和 `y` 都相等，则盒子排在前面。
- **贪心选择**：使用 `multiset` 维护盒子的 `y` 值，通过 `lower_bound` 查找第一个满足条件的盒子，确保每次选择最合适的盒子。

【可拓展之处】
- 类似问题：二维偏序问题、匹配问题。
- 类似算法：贪心、排序、二分查找。

【推荐题目】
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：34.61秒
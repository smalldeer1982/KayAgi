# 题目信息

# [ABC246E] Bishop 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc246/tasks/abc246_e

ここに、 $ N\ \times\ N $ のチェス盤があります。このチェス盤の上から $ i $ 行目、左から $ j $ 列目にあるマスをマス $ (i,j) $ と呼びます。  
 チェス盤の情報は $ N $ 個の文字列 $ S_i $ として与えられます。  
 文字列 $ S_i $ の $ j $ 文字目である $ S_{i,j} $ には、以下の情報が含まれています。

- $ S_{i,j}= $ `.` のとき マス $ (i,j) $ には何も置かれていない。
- $ S_{i,j}= $ `#` のとき マス $ (i,j) $ には白のポーンが $ 1 $ つ置かれている。このポーンを動かしたり取り除いたりすることはできない。

この盤面のマス $ (A_x,A_y) $ に、白のビショップを $ 1 $ つ置きました。  
 この白のビショップをチェスのルール (注記参照) に従ってマス $ (A_x,A_y) $ からマス $ (B_x,B_y) $ に移動させるために必要な最小の手数を求めてください。  
 ただし、移動できない場合は代わりに `-1` を出力してください。

## 说明/提示

### 注記

マス $ (i,j) $ に置かれている白の [ビショップ](https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B7%E3%83%A7%E3%83%83%E3%83%97) は、 $ 1 $ 手で以下のルールに従って移動することができます。

- 各正整数 $ d $ について、以下の条件を全て満たせばマス $ (i+d,j+d) $ に移動できる。
  
  
  - マス $ (i+d,j+d) $ が盤内に存在する
  - 全ての正整数 $ l\ \le\ d $ について、 $ (i+l,j+l) $ に白のポーンがない
- 各正整数 $ d $ について、以下の条件を全て満たせばマス $ (i+d,j-d) $ に移動できる。
  
  
  - マス $ (i+d,j-d) $ が盤内に存在する
  - 全ての正整数 $ l\ \le\ d $ について、 $ (i+l,j-l) $ に白のポーンがない
- 各正整数 $ d $ について、以下の条件を全て満たせばマス $ (i-d,j+d) $ に移動できる。
  
  
  - マス $ (i-d,j+d) $ が盤内に存在する
  - 全ての正整数 $ l\ \le\ d $ について、 $ (i-l,j+l) $ に白のポーンがない
- 各正整数 $ d $ について、以下の条件を全て満たせばマス $ (i-d,j-d) $ に移動できる。
  
  
  - マス $ (i-d,j-d) $ が盤内に存在する
  - 全ての正整数 $ l\ \le\ d $ について、 $ (i-l,j-l) $ に白のポーンがない

### 制約

- $ 2\ \le\ N\ \le\ 1500 $
- $ 1\ \le\ A_x,A_y\ \le\ N $
- $ 1\ \le\ B_x,B_y\ \le\ N $
- $ (A_x,A_y)\ \neq\ (B_x,B_y) $
- $ S_i $ は `.` および `#` からなる $ N $ 文字の文字列
- $ S_{A_x,A_y}= $ `.`
- $ S_{B_x,B_y}= $ `.`

### Sample Explanation 1

以下のように移動させることで $ 3 $ 手でビショップを $ (1,3) $ から $ (3,5) $ まで移動させることができます。 $ 2 $ 手以内でビショップを $ (1,3) $ から $ (3,5) $ まで移動させることはできません。 - $ (1,3)\ \rightarrow\ (2,2)\ \rightarrow\ (4,4)\ \rightarrow\ (3,5) $

### Sample Explanation 2

どのようにビショップを動かしても $ (3,2) $ から $ (4,2) $ に移動させることはできません。

## 样例 #1

### 输入

```
5

1 3

3 5

....#

...#.

.....

.#...

#....```

### 输出

```
3```

## 样例 #2

### 输入

```
4

3 2

4 2

....

....

....

....```

### 输出

```
-1```

## 样例 #3

### 输入

```
18

18 1

1 18

..................

.####.............

.#..#..####.......

.####..#..#..####.

.#..#..###...#....

.#..#..#..#..#....

.......####..#....

.............####.

..................

..................

.####.............

....#..#..#.......

.####..#..#..####.

.#.....####..#....

.####.....#..####.

..........#..#..#.

.............####.

..................```

### 输出

```
9```

# AI分析结果

### 题目内容重写

【题目描述】

这里有一个 $N \times N$ 的棋盘。棋盘的第 $i$ 行第 $j$ 列的格子称为 $(i,j)$。棋盘的信息由 $N$ 个字符串 $S_i$ 给出。字符串 $S_i$ 的第 $j$ 个字符 $S_{i,j}$ 包含以下信息：

- 如果 $S_{i,j} = $ `.`，则格子 $(i,j)$ 是空的。
- 如果 $S_{i,j} = $ `#`，则格子 $(i,j)$ 有一个白兵，且不能移动或移除。

在棋盘上的格子 $(A_x,A_y)$ 放置了一个白象。按照国际象棋的规则（见注释），求将白象从 $(A_x,A_y)$ 移动到 $(B_x,B_y)$ 所需的最少步数。如果无法到达，则输出 `-1`。

【注释】

白象可以按照以下规则移动：

- 对于每个正整数 $d$，如果满足以下条件，则可以移动到 $(i+d,j+d)$：
  - $(i+d,j+d)$ 在棋盘内。
  - 对于所有正整数 $l \le d$，$(i+l,j+l)$ 没有白兵。
- 对于每个正整数 $d$，如果满足以下条件，则可以移动到 $(i+d,j-d)$：
  - $(i+d,j-d)$ 在棋盘内。
  - 对于所有正整数 $l \le d$，$(i+l,j-l)$ 没有白兵。
- 对于每个正整数 $d$，如果满足以下条件，则可以移动到 $(i-d,j+d)$：
  - $(i-d,j+d)$ 在棋盘内。
  - 对于所有正整数 $l \le d$，$(i-l,j+l)$ 没有白兵。
- 对于每个正整数 $d$，如果满足以下条件，则可以移动到 $(i-d,j-d)$：
  - $(i-d,j-d)$ 在棋盘内。
  - 对于所有正整数 $l \le d$，$(i-l,j-l)$ 没有白兵。

【样例解释】

样例1：可以通过以下步骤将白象从 $(1,3)$ 移动到 $(3,5)$，共需3步。无法在2步内完成。

样例2：无法将白象从 $(3,2)$ 移动到 $(4,2)$。

### 算法分类
广度优先搜索 BFS

### 题解分析与结论

题目要求从起点到终点的最短路径，且路径必须符合国际象棋中象的移动规则。由于棋盘大小较大（$N \le 1500$），直接使用BFS会超时，因此需要使用优化策略。常见的优化方法是使用双端队列（01BFS）来处理不同方向的移动，以减少时间复杂度。

### 所选题解

#### 题解1：DragonForge
- **星级**：4星
- **关键亮点**：使用双端队列实现01BFS，记录每个格子的四个方向，优化了BFS的时间复杂度。
- **代码核心思想**：
  - 使用双端队列存储当前格子的坐标、方向和步数。
  - 如果移动方向与上一步相同，则步数不变，否则步数加1。
  - 最终输出四个方向到达终点的最小步数。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF=1e9,MAXN=1510,kd[5][2]={{},{1,1},{1,-1},{-1,1},{-1,-1}};
char c[MAXN][MAXN];
int d[MAXN][MAXN][5],n,m,sx,sy,ex,ey,t;
deque<array<int,4>> q;

int main(void){
  cin>>n>>sx>>sy>>ex>>ey;
  for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>c[i][j];
  fill(d[0][0],d[n+1][0],INF);
  for(q.push_back({sx,sy,0,0});q.size();){
    auto p=q.front(); q.pop_front();
    if(c[p[0]][p[1]]=='.'&&d[p[0]][p[1]][p[2]]==INF){
      d[p[0]][p[1]][p[2]]=p[3];
      q.push_front({p[0]+kd[p[2]][0],p[1]+kd[p[2]][1],p[2],p[3]});
      for(int i=1;i<=4;i++) q.push_back({p[0],p[1],i,p[3]+1});
    }
  }
  int ans=min({d[ex][ey][1],d[ex][ey][2],d[ex][ey][3],d[ex][ey][4]});
  cout<<(ans==INF?-1:ans);
  return 0;
}
```

#### 题解2：chengning0909
- **星级**：4星
- **关键亮点**：同样使用双端队列实现01BFS，但代码结构更清晰，且处理了方向变化的步数更新。
- **代码核心思想**：
  - 使用双端队列存储当前格子的坐标和方向。
  - 如果移动方向与上一步相同，则步数不变，否则步数加1。
  - 最终输出四个方向到达终点的最小步数。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1510;
const int dx[] = {1, 1, -1, -1};
const int dy[] = {1, -1, 1, -1};
int n, sx, sy, fx, fy, d[N][N][4];
char c[N][N];
struct Node { int x, y, dir; };
deque<Node> que;

void Record(int x, int y, int dis, int dir, int nowd) {
  if (x < 1 || x > n || y < 1 || y > n || c[x][y] == '#' || d[x][y][nowd] <= dis + (nowd != dir)) return;
  d[x][y][nowd] = dis;
  if (nowd == dir) que.push_front({x, y, nowd});
  else { d[x][y][nowd]++; que.push_back({x, y, nowd}); }
}

void bfs() {
  for (Record(sx, sy, 0, 4, 4); !que.empty(); ) {
    Node u = que.front(); que.pop_front();
    for (int i = 0; i < 4; i++) Record(u.x + dx[i], u.y + dy[i], d[u.x][u.y][u.dir], u.dir, i);
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> sx >> sy >> fx >> fy;
  for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> c[i][j], d[i][j][0] = d[i][j][1] = d[i][j][2] = d[i][j][3] = 1e9;
  bfs();
  int ans = 1e9;
  for (int i = 0; i < 4; i++) if (d[fx][fy][i] != 1e9) ans = min(ans, d[fx][fy][i]);
  cout << (ans == 1e9 ? -1 : ans);
  return 0;
}
```

### 最优关键思路
使用双端队列（01BFS）来处理不同方向的移动，优化了BFS的时间复杂度。通过记录每个格子的四个方向，减少重复计算，确保在较大棋盘上也能高效运行。

### 可拓展之处
类似的问题可以扩展到其他棋子的移动规则，如马的移动（L形移动）或车的移动（直线移动），都可以通过类似的优化策略来解决。

### 推荐题目
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

---
处理用时：53.45秒
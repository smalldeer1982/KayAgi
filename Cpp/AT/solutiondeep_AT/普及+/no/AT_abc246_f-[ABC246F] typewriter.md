# 题目信息

# [ABC246F] typewriter

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc246/tasks/abc246_f

$ N $ 段からなるタイプライターがあります。このうち、上から $ i $ 段目のキーでは文字列 $ S_i $ に含まれる文字が打てます。

このキーボードを使って、以下のルールで文字列をひとつ入力することを考えます。

- まず、整数 $ 1\ \le\ k\ \le\ N $ を選択する。
- その後、空文字列から始めて、上から $ k $ 段目にあるキーだけを使ってちょうど $ L $ 文字の文字列を入力する。

このルールに従って入力可能な $ L $ 文字の文字列は何通りありますか？ 答えは非常に大きくなる場合があるので $ 998244353 $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ N,L $ は整数
- $ 1\ \le\ N\ \le\ 18 $
- $ 1\ \le\ L\ \le\ 10^9 $
- $ S_i $ は `abcdefghijklmnopqrstuvwxyz` の(連続とは限らない)空でない部分列

### Sample Explanation 1

入力可能な文字列は `aa`, `ab`, `ac`, `ba`, `bb`, `ca`, `cc` の $ 7 $ つです。

### Sample Explanation 3

答えを $ 998244353 $ で割った余りを出力してください。

## 样例 #1

### 输入

```
2 2

ab

ac```

### 输出

```
7```

## 样例 #2

### 输入

```
4 3

abcdefg

hijklmnop

qrstuv

wxyz```

### 输出

```
1352```

## 样例 #3

### 输入

```
5 1000000000

abc

acde

cefg

abcfh

dghi```

### 输出

```
346462871```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个由 $N$ 段组成的打字机。从上到下第 $i$ 段的按键可以打出字符串 $S_i$ 中包含的字符。

使用这个打字机，按照以下规则输入一个字符串：

1. 首先选择一个整数 $1 \le k \le N$。
2. 然后从空字符串开始，仅使用第 $k$ 段的按键，输入一个恰好 $L$ 个字符的字符串。

按照这个规则，可以输入多少种不同的 $L$ 字符的字符串？由于答案可能非常大，请输出对 $998244353$ 取模的结果。

#### 说明/提示

##### 约束

- $N$ 和 $L$ 是整数。
- $1 \le N \le 18$
- $1 \le L \le 10^9$
- $S_i$ 是 `abcdefghijklmnopqrstuvwxyz` 的（不一定连续的）非空子集。

##### 样例解释 1

输入可能的字符串有 `aa`, `ab`, `ac`, `ba`, `bb`, `ca`, `cc` 共 $7$ 个。

##### 样例解释 3

输出答案对 $998244353$ 取模的结果。

#### 样例 #1

##### 输入

```
2 2

ab

ac
```

##### 输出

```
7
```

#### 样例 #2

##### 输入

```
4 3

abcdefg

hijklmnop

qrstuv

wxyz
```

##### 输出

```
1352
```

#### 样例 #3

##### 输入

```
5 1000000000

abc

acde

cefg

abcfh

dghi
```

##### 输出

```
346462871
```

### 算法分类

组合数学、容斥原理、位运算

### 题解分析与结论

#### 综合分析

本题的核心在于计算所有可能的字符串组合数，考虑到字符集的选择和交集的影响，容斥原理是一个自然的解决方案。所有题解都采用了容斥原理，并通过状态压缩和位运算来高效地计算字符集的交集。

#### 最优关键思路

1. **容斥原理**：通过枚举所有可能的字符集组合，计算它们的交集，并根据组合的大小（奇偶性）决定是加还是减。
2. **状态压缩**：将每个字符集表示为一个26位的二进制数，方便快速计算交集。
3. **快速幂**：由于 $L$ 可能很大，使用快速幂计算 $cnt^L$。

#### 推荐题解

1. **作者：e4fsrc2e4fsrc2 (赞：3)**  
   - **星级**：4.5  
   - **关键亮点**：代码简洁，使用 `__builtin_popcount()` 高效计算二进制中1的个数，快速幂实现清晰。
   - **代码核心**：
     ```cpp
     for(R i=1; i<(1<<n); i++){
         R x=i,cnt=1,cn=f(i);ll y=(1<<26)-1;
         while(x){
             if(x&1)y&=a[cnt];
             x>>=1,cnt++;
         }
         if(cn&1)ans=(ans+qpow(f(y),l))%mod;
         else ans=(ans-qpow(f(y),l)+mod)%mod;
     }
     ```

2. **作者：Zhao_daodao (赞：1)**  
   - **星级**：4  
   - **关键亮点**：思路清晰，代码结构良好，快速幂和位运算实现得当。
   - **代码核心**：
     ```cpp
     for(int h=1;h<(1<<n);h++)
     {
         int now=(1<<27)-1;
         for(int i=1;i<=n;i++){
             if(h&(1<<(i-1)))
                 now&=a[i];
         }
         sum=qpow(__builtin_popcount(now),l);
         if(__builtin_popcount(h)&1)
             ans=(ans+sum)%mod;
         else
             ans=(ans-sum+mod)%mod;
     }
     ```

3. **作者：Tsawke (赞：0)**  
   - **星级**：4  
   - **关键亮点**：代码结构清晰，使用 `__builtin_popcount()` 和快速幂，注释详细。
   - **代码核心**：
     ```cpp
     for(int S = Smx; S; S = (S - 1) & Smx){
         int cnt = __builtin_popcount(S);
         int tot((1 << 26) - 1);
         for(int i = 0; i <= N - 1; ++i)
             if((1 << i) & S)tot &= str[i + 1];
         ans = (ans + qpow(__builtin_popcount(tot), L) * ((cnt & 1) ? 1 : -1) + MOD) % MOD;
     }
     ```

### 扩展思路与推荐题目

#### 扩展思路

- **类似问题**：可以扩展到多个字符集的并集问题，或者考虑字符集的排列组合问题。
- **优化技巧**：进一步优化状态压缩和快速幂的实现，或者考虑并行计算。

#### 推荐题目

1. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972) - 考察位运算和状态压缩。
2. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811) - 快速幂和模运算的应用。
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383) - 数学和组合问题的结合。

---
处理用时：35.98秒
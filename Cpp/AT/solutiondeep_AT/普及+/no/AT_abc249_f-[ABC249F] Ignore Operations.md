# 题目信息

# [ABC249F] Ignore Operations

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc249/tasks/abc249_f

高橋君は整数 $ x $ を持っています。はじめ、$ x\ =\ 0 $ です。

$ N $ 個の操作があります。$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 個目の操作は整数 $ t_i,\ y_i $ を用いて以下のように表されます。

- $ t_i\ =\ 1 $ のとき、$ x $ を $ y_i $ で置き換える。
- $ t_i\ =\ 2 $ のとき、$ x $ を $ x\ +\ y_i $ で置き換える。

高橋君は $ 0 $ 個以上 $ K $ 個以下の好きな個数の操作を無視することができます。残った操作を一度ずつ順序を変えずに行ったとき、最終的な $ x $ の値としてあり得る最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ K\ \leq\ N $
- $ t_i\ \in\ \{1,2\}\ \,\ (1\ \leq\ i\ \leq\ N) $
- $ |y_i|\ \leq\ 10^9\ \,\ (1\ \leq\ i\ \leq\ N) $
- 入力は全て整数

### Sample Explanation 1

$ 5 $ 個目の操作を無視すると、$ x $ は $ 0\ \rightarrow\ 4\ \rightarrow\ 1\ \rightarrow\ 2\ \rightarrow\ 3 $ と変化し、最終的な $ x $ の値は $ 3 $ となります。これが最大です。

## 样例 #1

### 输入

```
5 1
2 4
2 -3
1 2
2 1
2 -3```

### 输出

```
3```

## 样例 #2

### 输入

```
1 0
2 -1000000000```

### 输出

```
-1000000000```

## 样例 #3

### 输入

```
10 3
2 3
2 -1
1 4
2 -1
2 5
2 -9
2 2
1 -6
2 5
2 -3```

### 输出

```
15```

# AI分析结果

### 题目内容重写
高桥君有一个整数 $x$，初始时 $x = 0$。给定 $N$ 个操作，第 $i$ 个操作由两个整数 $t_i, y_i$ 描述：

- 如果 $t_i = 1$，将 $x$ 替换为 $y_i$。
- 如果 $t_i = 2$，将 $x$ 替换为 $x + y_i$。

高桥君可以忽略 $0$ 到 $K$ 个操作，执行剩余的操作后，求 $x$ 的最大值。

### 算法分类
贪心

### 题解分析与结论
该题的核心在于如何通过贪心策略选择忽略哪些操作以最大化最终结果。由于操作类型分为赋值和加法，且赋值操作会覆盖之前的所有操作，因此从后往前处理操作可以避免重复计算。通过使用优先队列（堆）来维护需要忽略的负值操作，可以有效地选择对结果影响最小的操作进行忽略。

### 所选高星题解
#### 题解1：作者：liangbowen (赞：7)
- **星级**：5星
- **关键亮点**：从后往前处理操作，使用优先队列维护需要忽略的负值操作，分类讨论赋值和加法操作的处理方式，代码简洁且思路清晰。
- **代码核心思想**：
  - 从后往前遍历操作，使用优先队列存储负值操作。
  - 对于赋值操作，更新最大答案并减少忽略次数。
  - 对于加法操作，正数直接累加，负数加入优先队列，当队列大小超过忽略次数时，弹出最大值并累加。

```cpp
priority_queue <int> q;
int n, k; long long ans = -9e18, sum = 0;
scanf("%d%d", &n, &k), op[0] = 1;
for (int i = 1; i <= n; i++) scanf("%d%d", &op[i], &a[i]);

for (int i = n; i && k >= 0; i--) {
    if (op[i] == 1) ans = max(ans, a[i] + sum), k--;
    else if (op[i] == 2) {
        if (a[i] >= 0) sum += a[i];
        else q.push(a[i]);
    }
    while ((int)q.size() > k && !q.empty()) sum += q.top(), q.pop();
}
if (k >= 0) ans = max(ans, sum);
cout << ans;
```

#### 题解2：作者：Hovery (赞：4)
- **星级**：4星
- **关键亮点**：从后往前处理操作，使用 `multiset` 存储负值操作，通过贪心策略选择忽略哪些操作，代码实现较为清晰。
- **代码核心思想**：
  - 从后往前遍历操作，使用 `multiset` 存储负值操作。
  - 对于赋值操作，更新最大答案并减少忽略次数。
  - 对于加法操作，正数直接累加，负数加入 `multiset`，当 `multiset` 大小超过忽略次数时，弹出最大值并累加。

```cpp
multiset<int> _1;
for (int i = n; ~i ;i--)
    if (a[i].first == 1) {
        if (k < 0) continue;
        ans = max(ans, a[i].second + now);
        k--;
        while (_1.size() > k) {
            now += *_1.rbegin();
            _1.erase(prev(_1.end()));
        }
    }
    else {
        now += a[i].second;
        if (a[i].second < 0 && _1.size() < k) {
            now -= a[i].second;
            _1.insert(a[i].second);
        }
    }
```

#### 题解3：作者：yinbe (赞：2)
- **星级**：4星
- **关键亮点**：从后往前处理操作，使用优先队列维护需要忽略的负值操作，分类讨论赋值和加法操作的处理方式，代码简洁且思路清晰。
- **代码核心思想**：
  - 从后往前遍历操作，使用优先队列存储负值操作。
  - 对于赋值操作，更新最大答案并减少忽略次数。
  - 对于加法操作，正数直接累加，负数加入优先队列，当队列大小超过忽略次数时，弹出最大值并累加。

```cpp
priority_queue<int> pq;
for (int i = n; i >= 1 && m >= 0; i--) {
    if (v[i].x == 1) ans = max(ans, sum + v[i].y), m--;
    else {
        if (v[i].y >= 0) sum += v[i].y;
        else pq.push(v[i].y);
    }
    while (pq.size() > m && !pq.empty())
        sum += pq.top(), pq.pop();
}
```

### 最优关键思路
1. **从后往前处理操作**：避免重复计算，确保赋值操作覆盖前面的操作。
2. **使用优先队列维护负值操作**：通过贪心策略选择忽略哪些负值操作，以最大化最终结果。
3. **分类讨论赋值和加法操作**：分别处理赋值和加法操作，确保逻辑清晰且高效。

### 可拓展之处
类似的问题可以通过贪心策略结合优先队列来解决，特别是在需要选择忽略某些操作以优化最终结果的情况下。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

---
处理用时：36.51秒
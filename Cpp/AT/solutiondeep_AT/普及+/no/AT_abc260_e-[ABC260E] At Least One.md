# 题目信息

# [ABC260E] At Least One

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc260/tasks/abc260_e

整数 $ M $ および $ N $ 個の整数の組 $ (A_1,\ B_1),\ (A_2,\ B_2),\ \dots,\ (A_N,\ B_N) $ が与えられます。  
 すべての $ i $ について $ 1\ \leq\ A_i\ \lt\ B_i\ \leq\ M $ が成り立っています。

次の条件を満たす数列 $ S $ を**良い数列**と呼びます。

- $ S $ は数列 $ (1,2,3,...,\ M) $ の連続部分列である。
- すべての $ i $ について $ S $ は $ A_i,\ B_i $ の少なくとも一方を含んでいる。

長さ $ k $ の良い数列としてあり得るものの個数を $ f(k) $ とします。  
 $ f(1),\ f(2),\ \dots,\ f(M) $ を列挙してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 2\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \lt\ B_i\ \leq\ M $
- 入力される値はすべて整数

### Sample Explanation 1

良い数列としてあり得るものを列挙すると次のようになります。 - $ (1,2) $ - $ (1,2,3) $ - $ (2,3,4) $ - $ (3,4,5) $ - $ (1,2,3,4) $ - $ (2,3,4,5) $ - $ (1,2,3,4,5) $

## 样例 #1

### 输入

```
3 5

1 3

1 4

2 5```

### 输出

```
0 1 3 2 1```

## 样例 #2

### 输入

```
1 2

1 2```

### 输出

```
2 1```

## 样例 #3

### 输入

```
5 9

1 5

1 7

5 6

5 8

2 6```

### 输出

```
0 0 1 2 4 4 3 2 1```

# AI分析结果

### 题目内容重写
给定整数 $M$ 和 $N$ 个整数对 $(A_1, B_1), (A_2, B_2), \dots, (A_N, B_N)$，其中 $1 \leq A_i < B_i \leq M$。定义一个数列 $S$ 为“好的数列”，当且仅当满足以下条件：
- $S$ 是数列 $(1, 2, 3, \dots, M)$ 的连续子序列。
- 对于所有 $i$，$S$ 包含 $A_i$ 或 $B_i$ 中的至少一个。

定义 $f(k)$ 为长度为 $k$ 的“好的数列”的个数，要求输出 $f(1), f(2), \dots, f(M)$。

### 算法分类
差分

### 题解分析与结论
本题的核心在于如何高效地统计满足条件的连续子序列的数量。由于直接枚举所有可能的子序列会超时，因此需要利用差分的性质来优化计算。通过双指针或单调性优化，可以有效地减少时间复杂度。

### 所选高星题解
1. **作者：wnsyou**  
   - **星级：5星**  
   - **关键亮点**：利用双指针和差分优化，时间复杂度为 $O(n + m)$，代码简洁且高效。  
   - **核心实现思想**：通过预处理每个左端点的最小右端点，利用差分数组统计每个长度的合法子序列数量。  
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= mr; i++) {
         c[i] = max({c[i - 1], c[i], i}); // 前缀最大值
         ans[c[i] - i + 1]++, ans[m - i + 2]--; // 差分
     }
     ```

2. **作者：Meickol**  
   - **星级：4星**  
   - **关键亮点**：使用双指针和差分，思路清晰，代码可读性强。  
   - **核心实现思想**：通过枚举左端点，利用双指针找到最小的右端点，并用差分数组记录贡献。  
   - **代码片段**：
     ```cpp
     while(tot<n && j<m){
         ++j;
         for(auto x:v[j]){
             if(!cnt[x]) tot++; // 之前第 x 个整数对还没被配对上过
             cnt[x]++;
         }
     }
     ```

3. **作者：Exp10re**  
   - **星级：4星**  
   - **关键亮点**：通过预处理和差分，时间复杂度为 $O(N)$，思路清晰。  
   - **核心实现思想**：预处理每个左端点的最小右端点，利用差分数组统计每个长度的合法子序列数量。  
   - **代码片段**：
     ```cpp
     for(i=1;i<=m;i++){
         a[i+1]=max(a[i+1],a[i]-1);
     }
     ```

### 最优关键思路与技巧
- **双指针优化**：通过双指针维护当前区间的合法性，减少不必要的枚举。
- **差分数组**：利用差分数组高效地记录每个长度的合法子序列数量，避免重复计算。
- **预处理**：通过预处理每个左端点的最小右端点，进一步优化时间复杂度。

### 可拓展之处
- **类似问题**：可以扩展到其他需要统计满足特定条件的子序列数量的问题，如统计包含某些特定元素的子序列。
- **算法套路**：双指针+差分的组合在统计区间数量问题时非常常见，可以应用于其他类似场景。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)

---
处理用时：31.30秒
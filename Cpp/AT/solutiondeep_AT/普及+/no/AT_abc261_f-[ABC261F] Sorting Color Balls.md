# 题目信息

# [ABC261F] Sorting Color Balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc261/tasks/abc261_f

$ N $ 個の球が左右一列に並んでいます。 左から $ i $ 番目の球の色は色 $ C_i $ であり、整数 $ X_i $ が書かれています。

高橋君の目標は球を左から右に見た時に書かれている数が非減少になるように球を並べ替えることです。 言い換えれば、高橋君の目標は、任意の $ 1\leq\ i\leq\ N-1 $ について、左から $ i+1 $ 番目の球に書かれている数 が左から $ i $ 番目に書かれている数以上であるようにすることです。

高橋君は目標を達成するために、次の操作を好きなだけ（ $ 0 $ 回でも良い ）繰り返すことができます。

> $ 1\leq\ i\leq\ N-1 $ をみたす整数 $ i $ を選ぶ。  
>  左から $ i $ 番目の球と $ i+1 $ 番目の球の色が異なっているならば、コストを $ 1 $ 支払う。 （色が等しいならばコストを支払う必要は無い。）  
>  左から $ i $ 番目の球と $ i+1 $ 番目の球を入れ替える。

高橋君が目標を達成するために支払う必要のあるコストの最小値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 3\times\ 10^5 $
- $ 1\leq\ C_i\leq\ N $
- $ 1\leq\ X_i\leq\ N $
- 入力は全て整数

### Sample Explanation 1

球の情報を $ (色,\ 整数) $ で表すとします。 最初の状態は $ (1,3) $, $ (5,2) $, $ (2,1) $, $ (2,2) $, $ (1,1) $ です。 例えば、高橋君は次のように操作を行うことができます。 - 左から $ 1 $ 番目の球 (色 $ 1 $) と $ 2 $ 番目の球 (色 $ 5 $) を入れ替える。 球は左から $ (5,2) $, $ (1,3) $, $ (2,1) $, $ (2,2) $, $ (1,1) $ となる。 - 左から $ 2 $ 番目の球 (色 $ 1 $) と $ 3 $ 番目の球 (色 $ 2 $) を入れ替える。 球は左から $ (5,2) $, $ (2,1) $, $ (1,3) $, $ (2,2) $, $ (1,1) $ となる。 - 左から $ 3 $ 番目の球 (色 $ 1 $) と $ 4 $ 番目の球 (色 $ 2 $) を入れ替える。 球は左から $ (5,2) $, $ (2,1) $, $ (2,2) $, $ (1,3) $, $ (1,1) $ となる。 - 左から $ 4 $ 番目の球 (色 $ 1 $) と $ 5 $ 番目の球 (色 $ 1 $) を入れ替える。 球は左から $ (5,2) $, $ (2,1) $, $ (2,2) $, $ (1,1) $, $ (1,3) $ となる。 - 左から $ 3 $ 番目の球 (色 $ 2 $) と $ 4 $ 番目の球 (色 $ 1 $) を入れ替える。 球は左から $ (5,2) $, $ (2,1) $, $ (1,1) $, $ (2,2) $, $ (1,3) $ となる。 - 左から $ 1 $ 番目の球 (色 $ 5 $) と $ 2 $ 番目の球 (色 $ 2 $) を入れ替える。 球は左から $ (2,1) $, $ (5,2) $, $ (1,1) $, $ (2,2) $, $ (1,3) $ となる。 - 左から $ 2 $ 番目の球 (色 $ 5 $) と $ 3 $ 番目の球 (色 $ 1 $) を入れ替える。 球は左から $ (2,1) $, $ (1,1) $, $ (5,2) $, $ (2,2) $, $ (1,3) $ となる。 最後の操作の後で球に書かれている数は左から順に $ 1,1,2,2,3 $ となっているため、高橋君は目的を達成しています。 $ 1,2,3,5,6,7 $ 回目の操作にコストが $ 1 $ ずつかかるため、 このとき合計でコストは $ 6 $ かかり、このときが最小となります。 $ 4 $ 回目の操作では、入れ替えた球の色がともに色 $ 1 $ であるためコストがかからないことに注意してください。

### Sample Explanation 2

すべての球の色は同じであるため、球の入れ替えにコストがかかることはありません。

### Sample Explanation 3

高橋君は一度も操作を行わずとも、目的を達成できています。

## 样例 #1

### 输入

```
5

1 5 2 2 1

3 2 1 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
3

1 1 1

3 2 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3

3 1 2

1 1 2```

### 输出

```
0```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

有 $N$ 个球排成一列，从左到右第 $i$ 个球的颜色为 $C_i$，球上写有一个整数 $X_i$。高桥君的目标是通过交换相邻的球，使得从左到右的球上的数字非递减。每次交换相邻的两个球时，如果它们的颜色不同，则需要支付 $1$ 的代价；如果颜色相同，则不需要支付代价。求高桥君达成目标所需的最小代价。

#### 输入格式

- 第一行输入一个整数 $N$，表示球的数量。
- 第二行输入 $N$ 个整数 $C_i$，表示每个球的颜色。
- 第三行输入 $N$ 个整数 $X_i$，表示每个球上的数字。

#### 输出格式

输出一个整数，表示高桥君达成目标所需的最小代价。

#### 样例

**输入样例 1：**
```
5
1 5 2 2 1
3 2 1 2 1
```
**输出样例 1：**
```
6
```

**输入样例 2：**
```
3
1 1 1
3 2 1
```
**输出样例 2：**
```
0
```

**输入样例 3：**
```
3
3 1 2
1 1 2
```
**输出样例 3：**
```
0
```

#### 说明/提示

- $2 \leq N \leq 3 \times 10^5$
- $1 \leq C_i \leq N$
- $1 \leq X_i \leq N$
- 输入均为整数

---

### 算法分类
排序、树状数组

---

### 题解分析与结论

本题的核心思路是通过计算逆序对的数量来求解最小代价。具体来说，如果不考虑颜色，最小代价就是序列中逆序对的数量。考虑到颜色限制，同颜色的逆序对不需要支付代价，因此最终的最小代价等于总的逆序对数量减去同颜色的逆序对数量。

#### 最优思路总结
1. **逆序对计算**：使用归并排序或树状数组来计算序列中的逆序对数量。
2. **颜色限制处理**：对于每种颜色，单独计算该颜色内部的逆序对数量，并从总逆序对中减去。
3. **数据结构优化**：使用树状数组或归并排序来高效计算逆序对，确保时间复杂度为 $O(n \log n)$。

---

### 高星题解推荐

#### 题解1：ZBH_123 (4星)
**关键亮点**：
- 使用归并排序计算逆序对，并在合并过程中减去同颜色的逆序对。
- 通过预处理颜色相同的元素数量，优化了时间复杂度。

**核心代码**：
```cpp
void msort(int l,int r){
    if(l==r) return;
    int mid=(l+r)/2;
    msort(l,mid);
    msort(mid+1,r);
    for(int i=l;i<=r;i++) cnt[b[i]]=0;
    for(int i=l;i<=mid;i++) cnt[b[i]]++;
    int i=l,j=mid+1,k=l;
    while(i<=mid&&j<=r){
        if(a[i]<=a[j]){
            cnt[b[i]]--;
            tmp[k++]=i++;
        }
        else{
            ans+=mid-i+1-cnt[b[j]];
            tmp[k++]=j++;
        }
    }
    while(i<=mid) tmp[k++]=i++;
    while(j<=r) tmp[k++]=j++;        
    for(int i=l;i<=r;i++){
        temp1[i]=b[i],temp2[i]=a[i];
    }
    for(int i=l;i<=r;i++){
        a[i]=temp2[tmp[i]],b[i]=temp1[tmp[i]];
    }
}
```

#### 题解2：Gaode_Sean (4星)
**关键亮点**：
- 使用树状数组计算逆序对，并分别计算总逆序对和同颜色逆序对。
- 通过动态数组存储每种颜色的球，简化了同颜色逆序对的计算。

**核心代码**：
```cpp
int ask(int x){
    int cnt=0;
    for(;x;x-=x&-x) cnt+=c[x];
    return cnt;
}
void add(int x){for(;x<=n;x+=x&-x) c[x]++;}
```

#### 题解3：WaterSun (4星)
**关键亮点**：
- 使用树状数组计算逆序对，并通过 `vector` 存储每种颜色的球，简化了同颜色逆序对的计算。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
inline int solve(vector<int> a){
    int res = 0;
    int n = a.size();
    for (re int i = n - 1;~i;i--){
        res += tree.query(a[i] - 1);
        tree.modify(a[i],1);
    }
    for (re int i = n - 1;~i;i--) tree.modify(a[i],-1);
    return res;
}
```

---

### 关键思路与技巧
1. **逆序对计算**：使用归并排序或树状数组来计算逆序对，时间复杂度为 $O(n \log n)$。
2. **颜色限制处理**：通过预处理或动态数组存储每种颜色的球，单独计算同颜色的逆序对。
3. **数据结构优化**：树状数组在处理逆序对问题时具有较高的效率，适合大规模数据。

---

### 拓展与举一反三
1. **类似题目**：
   - [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
   - [P1774 最接近神的人](https://www.luogu.com.cn/problem/P1774)
   - [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)

2. **调试心得**：
   - 在处理颜色限制时，确保同颜色的逆序对计算准确，避免重复或遗漏。
   - 使用树状数组时，注意数组大小的设置，避免越界或内存溢出。

---
处理用时：41.37秒
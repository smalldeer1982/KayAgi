# 题目信息

# [ABC262E] Red and Blue Graph

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc262/tasks/abc262_e

$ N $ 頂点 $ M $ 辺の単純無向グラフが与えられます。頂点は $ 1,\ \dots,\ N $ と番号付けられ、$ i\ \,\ (1\ \leq\ i\ \leq\ M) $ 番目の辺は頂点 $ U_i,\ V_i $ を結んでいます。

それぞれの頂点を赤または青で塗る方法は全部で $ 2^N $ 通りあります。これらのうち、以下の条件を全て満たすものの総数を $ 998244353 $ で割った余りを求めてください。

- 赤く塗られた頂点がちょうど $ K $ 個ある
- 異なる色で塗られた頂点を結ぶ辺の本数は偶数である

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ K\ \leq\ N $
- $ 1\ \leq\ U_i\ \lt\ V_i\ \leq\ N\ \,\ (1\ \leq\ i\ \leq\ M) $
- $ (U_i,\ V_i)\ \neq\ (U_j,\ V_j)\ \,\ (i\ \neq\ j) $
- 入力は全て整数

### Sample Explanation 1

以下の $ 2 $ 通りが条件を満たします。 - 頂点 $ 1,\ 2 $ を赤く、頂点 $ 3,\ 4 $ を青く塗る。 - 頂点 $ 3,\ 4 $ を赤く、頂点 $ 1,\ 2 $ を青く塗る。 上記の塗り方について、異なる色で塗られた頂点を結ぶ辺は $ 2 $ 番目の辺と $ 3 $ 番目の辺です。

## 样例 #1

### 输入

```
4 4 2

1 2

1 3

2 3

3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
10 10 3

1 2

2 4

1 5

3 6

3 9

4 10

7 8

9 10

5 9

3 4```

### 输出

```
64```

# AI分析结果

### 题目内容重写
给定一个包含 $N$ 个顶点和 $M$ 条边的简单无向图。顶点编号为 $1$ 到 $N$，第 $i$ 条边连接顶点 $U_i$ 和 $V_i$。每个顶点可以被涂成红色或蓝色，共有 $2^N$ 种涂色方法。要求满足以下条件的涂色方法的总数，并对结果取模 $998244353$：
1. 恰好有 $K$ 个顶点被涂成红色。
2. 连接不同颜色顶点的边的数量为偶数。

### 算法分类
组合数学

### 题解分析与结论
本题的核心在于通过组合数学的方法，统计满足条件的涂色方案数。题解们普遍采用了以下思路：
1. **度数奇偶性分析**：通过分析顶点度数的奇偶性，将问题转化为选择偶数个度数为奇数的顶点。
2. **组合数计算**：利用组合数公式，计算从度数为奇数和偶数的顶点中选择一定数量的顶点的方案数。
3. **预处理优化**：通过预处理阶乘和逆元，优化组合数的计算效率。

### 高星题解推荐

#### 1. 作者：MrcFrst (5星)
**关键亮点**：
- 清晰地分析了度数奇偶性对结果的影响，提出了选择偶数个度数为奇数的顶点的思路。
- 代码结构清晰，预处理了阶乘和逆元，优化了组合数的计算。
**核心代码**：
```cpp
int C(int n,int m){
	if(n<m)return 0;
	return fac[n]*invfac[m]%mod*invfac[n-m]%mod;
}
```
**个人心得**：
作者通过逐步分析，发现选择偶数个度数为奇数的顶点可以满足条件，这一思路简洁且高效。

#### 2. 作者：FFTotoro (5星)
**关键亮点**：
- 通过快速幂和逆元优化了组合数的计算，代码简洁高效。
- 清晰地解释了选择偶数个度数为奇数的顶点的必要性。
**核心代码**：
```cpp
int com(int n,int m){return m?inv(f[n],f[m]*f[n-m]%mod):1;}
```
**个人心得**：
作者通过快速幂和逆元的预处理，大大提高了组合数的计算效率，代码实现简洁明了。

#### 3. 作者：Register_int (4星)
**关键亮点**：
- 通过枚举度数为奇数的顶点的数量，利用组合数公式计算方案数。
- 代码结构清晰，预处理了阶乘和逆元，优化了组合数的计算。
**核心代码**：
```cpp
ll c(int n, int m) {
	if (n < 0 || m < 0 || n < m) return 0;
	ll ans = fac[n] * ifac[m] % mod * ifac[n - m] % mod;
	return ans;
}
```
**个人心得**：
作者通过枚举度数为奇数的顶点的数量，结合组合数公式，清晰地解决了问题。

### 最优关键思路
通过分析顶点度数的奇偶性，将问题转化为选择偶数个度数为奇数的顶点，利用组合数公式计算方案数，并通过预处理阶乘和逆元优化计算效率。

### 可拓展之处
类似的问题可以通过分析顶点度数的奇偶性，转化为组合数学问题，利用组合数公式进行计算。预处理阶乘和逆元是优化组合数计算的常用技巧。

### 推荐题目
1. [P1357 花园](https://www.luogu.com.cn/problem/P1357)
2. [P1446 [HNOI2008]Cards](https://www.luogu.com.cn/problem/P1446)
3. [P2606 [ZJOI2010]排列计数](https://www.luogu.com.cn/problem/P2606)

---
处理用时：24.93秒
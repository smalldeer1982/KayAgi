# 题目信息

# [ABC263E] Sugoroku 3

## 题目描述

一共有 $N$ 个格子编号 $1$ 到 $N$。有一个人站在 $1$ 号格子。

对于 $\forall i \in [1,N-1]$ 号格子有一个 $A_i + 1$ 面的骰子，写有 $0$ 到 $A_i$ 这些数。如果 ta 掷到了 $k$，他将往前走 $k$ 格，走到 $i+k$ 号方格。

求走到 $N$ 号方格的期望次数。对 $998244353$ 取模。

## 说明/提示

$2\leq N\leq 2\times 10^5$

$\forall i \in [1,N-1],1\leq A_i\leq N-i$

## 样例 #1

### 输入

```
3

1 1```

### 输出

```
4```

## 样例 #2

### 输入

```
5

3 1 2 1```

### 输出

```
332748122```

# AI分析结果

### 题目内容重写
【题目描述】  
一共有 $N$ 个格子，编号从 $1$ 到 $N$。有一个人站在 $1$ 号格子。  
对于每个格子 $i$（$1 \leq i \leq N-1$），有一个 $A_i + 1$ 面的骰子，骰子上写有 $0$ 到 $A_i$ 这些数。如果掷到了 $k$，他将往前走 $k$ 格，走到 $i+k$ 号格子。  
求走到 $N$ 号格子的期望次数。对 $998244353$ 取模。

【说明/提示】  
$2 \leq N \leq 2 \times 10^5$  
对于所有 $i \in [1, N-1]$，$1 \leq A_i \leq N-i$

【样例 #1】  
输入：  
```
3  
1 1  
```  
输出：  
```
4  
```

【样例 #2】  
输入：  
```
5  
3 1 2 1  
```  
输出：  
```
332748122  
```

### 算法分类
动态规划、概率论

### 题解分析与结论
本题的核心是通过动态规划（DP）计算从每个格子走到终点的期望步数。由于直接顺推难以处理，题解普遍采用倒推的方式，即从终点向前递推，利用后缀和优化求和过程，并通过逆元处理除法取模问题。

### 精选题解
#### 1. 作者：Ginger_he (5星)
**关键亮点**：  
- 采用倒推法，定义 $dp_i$ 为从 $i$ 走到 $n$ 的期望步数。
- 通过后缀和优化求和，时间复杂度为 $O(n)$。
- 代码简洁，逻辑清晰，逆元预处理优化了计算效率。

**核心代码**：
```cpp
for(int i=n-1;i>=1;i--) {
    dp[i]=(((s[i+1]-s[i+a[i]+1])%p+p)%p+a[i]+1)%p*inv[a[i]]%p;
    s[i]=(s[i+1]+dp[i])%p;
}
```
**核心思想**：  
通过后缀和数组 $s$ 快速计算 $\sum_{k=i+1}^{i+a_i} dp_k$，避免了重复计算，提升了效率。

#### 2. 作者：ZBH_123 (4星)
**关键亮点**：  
- 详细推导了状态转移方程，并解释了如何通过移项消除 $dp_i$ 的自我引用。
- 使用后缀和优化求和，并通过逆元处理除法取模问题。

**核心代码**：
```cpp
for(int i=n-1;i>=1;i--) {
    dp[i]=(a[i]+1+(sum[i+1]-sum[i+a[i]+1]+mod)%mod)%mod*inv[a[i]]%mod;
    sum[i]=(sum[i+1]+dp[i])%mod;
}
```
**核心思想**：  
通过后缀和数组 $sum$ 快速计算 $\sum_{j=i+1}^{i+a_i} dp_j$，并通过逆元处理除法，确保取模运算的正确性。

#### 3. 作者：VitrelosTia (4星)
**关键亮点**：  
- 详细解释了倒推法的合理性，并通过移项消除 $dp_i$ 的自我引用。
- 使用后缀和优化求和，并通过逆元处理除法取模问题。

**核心代码**：
```cpp
for(int i=n-1;i>=1;i--) {
    f[i]=(1+(1+s[i+1]-s[i+a[i]+1]+mod)%mod*inv(a[i])%mod)%mod;
    s[i]=(s[i+1]+f[i])%mod;
}
```
**核心思想**：  
通过后缀和数组 $s$ 快速计算 $\sum_{j=i+1}^{i+a_i} f_j$，并通过逆元处理除法，确保取模运算的正确性。

### 最优关键思路与技巧
1. **倒推法**：从终点向前递推，避免顺推时难以处理的状态转移。
2. **后缀和优化**：通过后缀和数组快速计算区间和，避免重复计算，提升效率。
3. **逆元处理除法**：在模运算中，通过逆元将除法转换为乘法，确保取模运算的正确性。

### 可拓展之处
- 类似的问题可以通过倒推法和后缀和优化来解决，尤其是在涉及期望值和区间求和的题目中。
- 逆元的使用在模运算中非常常见，尤其是在需要处理除法的情况下。

### 推荐题目
1. [P1291 [SHOI2002] 百事世界杯之旅](https://www.luogu.com.cn/problem/P1291)
2. [P1850 [NOIP2016 提高组] 换教室](https://www.luogu.com.cn/problem/P1850)
3. [P4316 绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)

---
处理用时：35.56秒
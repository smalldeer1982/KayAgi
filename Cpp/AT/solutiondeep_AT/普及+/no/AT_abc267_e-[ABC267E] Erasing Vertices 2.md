# 题目信息

# [ABC267E] Erasing Vertices 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc267/tasks/abc267_e

$ N $ 頂点 $ M $ 辺の単純無向グラフ（すなわち、自己辺も多重辺もない無向グラフ）が与えられます。$ i $ 本目の辺は頂点 $ U_i $ と頂点 $ V_i $ を結んでいます。頂点 $ i $ には正整数 $ A_i $ が書かれています。

あなたは、以下の操作を $ N $ 回繰り返します。

- まだ削除されていない頂点 $ x $ を選び、「頂点 $ x $ 」と「頂点 $ x $ を端点に持つ辺全て」を削除する。この操作のコストは、頂点 $ x $ と辺で直接結ばれていて、かつまだ削除されていない頂点に書かれている整数の総和である。

$ N $ 回の操作全体のコストを、$ 1 $ 回ごとの操作におけるコストのうちの最大値として定めます。操作全体のコストとして取り得る値の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 0\ \le\ M\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
- $ 1\ \le\ U_i,V_i\ \le\ N $
- 与えられるグラフは単純。
- 入力は全て整数。

### Sample Explanation 1

以下のように操作を行うことにより、$ N $ 回の操作のコストのうちの最大値を $ 3 $ にすることができます。 - 頂点 $ 3 $ を選ぶ。コストは $ A_1=3 $ である。 - 頂点 $ 1 $ を選ぶ。コストは $ A_2+A_4=3 $ である。 - 頂点 $ 2 $ を選ぶ。コストは $ 0 $ である。 - 頂点 $ 4 $ を選ぶ。コストは $ 0 $ である。 $ N $ 回の操作のコストのうちの最大値を $ 2 $ 以下にすることはできないため、解は $ 3 $ です。

## 样例 #1

### 输入

```
4 3

3 1 4 2

1 2

1 3

4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
7 13

464 661 847 514 74 200 188

5 1

7 1

5 7

4 1

4 5

2 4

5 2

1 3

1 6

3 5

1 2

4 6

2 7```

### 输出

```
1199```

# AI分析结果

### 题目内容重写
#### [ABC267E] Erasing Vertices 2

**题目描述**

给定一个包含 $N$ 个顶点和 $M$ 条边的简单无向图（即没有自环和多重边的无向图）。第 $i$ 条边连接顶点 $U_i$ 和顶点 $V_i$。顶点 $i$ 上写有一个正整数 $A_i$。

你需要进行以下操作 $N$ 次：

- 选择一个尚未被删除的顶点 $x$，删除顶点 $x$ 以及所有与 $x$ 相连的边。这次操作的代价为与 $x$ 直接相连且尚未被删除的顶点上的整数之和。

整个操作的代价定义为每次操作代价的最大值。你需要求出整个操作代价的最小可能值。

**说明/提示**

- $1 \le N \le 2 \times 10^5$
- $0 \le M \le 2 \times 10^5$
- $1 \le A_i \le 10^9$
- $1 \le U_i, V_i \le N$
- 给定的图是简单无向图。
- 输入均为整数。

**样例解释 1**

按照以下方式操作，可以使 $N$ 次操作的代价最大值为 $3$：
- 选择顶点 $3$，代价为 $A_1=3$。
- 选择顶点 $1$，代价为 $A_2 + A_4=3$。
- 选择顶点 $2$，代价为 $0$。
- 选择顶点 $4$，代价为 $0$。

无法使 $N$ 次操作的代价最大值小于 $3$，因此答案为 $3$。

**样例 #1**

输入：
```
4 3
3 1 4 2
1 2
1 3
4 1
```

输出：
```
3
```

**样例 #2**

输入：
```
7 13
464 661 847 514 74 200 188
5 1
7 1
5 7
4 1
4 5
2 4
5 2
1 3
1 6
3 5
1 2
4 6
2 7
```

输出：
```
1199
```

### 算法分类
二分、贪心

### 题解分析与结论
该题的核心在于如何最小化每次删除操作的最大代价。题解中主要采用了两种思路：二分答案和贪心算法。

1. **二分答案**：通过二分查找确定最小可能的最大代价，然后通过 BFS 或类似方法验证该代价是否可行。这种方法的优势在于其时间复杂度较低，适合大规模数据。
2. **贪心算法**：每次选择当前代价最小的顶点进行删除，并动态更新其邻接顶点的代价。这种方法直观且易于实现，但需要维护一个优先队列来高效地选择最小代价顶点。

### 评分较高的题解
#### 题解1：Erica_N_Contina (赞：3)
**星级：4**
**关键亮点**：
- 使用了贪心算法，每次选择代价最小的顶点删除。
- 通过优先队列维护顶点的代价，确保每次都能快速找到最小代价顶点。
- 代码清晰，逻辑简洁，易于理解。

**核心代码**：
```cpp
priority_queue<pair<int,int> > pq;
int sum[N];

void add(int a,int b){
    e[a].push_back(b);
    sum[a]+=w[b];
}

signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>w[i];
    }
    for(int i=1;i<=m;i++){
        cin>>a>>b;
        add(a,b);add(b,a);
    }
    for(int i=1;i<=n;i++){
        pq.push(make_pair(-sum[i],i));
    }
    while(pq.size()){
        int u=pq.top().second;
        pq.pop();
        if(vis[u])continue;
        ans=max(ans,sum[u]);
        vis[u]=1;
        for(int i=0;i<e[u].size();i++){
            int v=e[u][i];
            if(!vis[v]){
                sum[v]-=w[u];
                pq.push(make_pair(-sum[v],v));
            }
        }
    }
    cout<<ans;
}
```

#### 题解2：chengning0909 (赞：0)
**星级：4**
**关键亮点**：
- 采用了二分答案的思路，通过 BFS 验证每个可能的代价。
- 代码结构清晰，逻辑严谨，适合大规模数据处理。
- 详细解释了二分答案的实现过程，易于理解。

**核心代码**：
```cpp
bool Check(ll x) {
    queue<int> que;
    int c = 0; 
    for (int i = 1; i <= n; i++) {
        s[i] = f[i] = 0;
        for (int j : g[i]) {
            s[i] += a[j];
        }
        if (s[i] <= x) {
            que.push(i), f[i] = 1;
        }
    }
    while (!que.empty()) {
        int u = que.front();
        que.pop(), c++;
        for (int v : g[u]) {
            s[v] -= a[u];
            if (s[v] <= x && !f[v]) {
                que.push(v), f[v] = 1;
            }
        }
    }
    return c == n;
}
```

### 最优关键思路或技巧
1. **优先队列的使用**：在贪心算法中，优先队列能够高效地找到当前代价最小的顶点，确保每次删除操作的代价最小化。
2. **二分答案的验证**：通过 BFS 验证每个可能的代价，确保二分答案的正确性和高效性。

### 可拓展之处
- 类似的问题可以扩展到有向图或带权图，处理方法类似，但需要考虑更多的约束条件。
- 可以结合其他算法如动态规划，进一步优化时间复杂度。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)

---
处理用时：41.65秒
# 题目信息

# [ABC270D] Stones

## 题目描述

#### 题目翻译
Takahashi 和 Aoki 在玩一个取石子的游戏。

刚开始，有 $N$ 个石子，还有一个长度为 $K$ 的序列 $A = \{A_1,A_2,\cdots,A_K\}$。

现在，他们要按照以下规则轮流取石子：

* 对于每次操作，他可以选择一个 $i$（$1 \leq i \leq K$），这时他会取走 $A_i$ 块石子。

* 当一个人没法取石子时，游戏结束。

现在，Takahashi 先取石子，Aoki 后取石子。
他们都想尽可能的最大化他们自己取走的石子数量。

若他们都以最优策略取石子，最后 Takahashi 会取走多少块石子？

## 说明/提示

对于 $100\%$ 的数据，保证：
* $1 \leq N \leq 10^4$
* $1 \leq K \leq 100$
* $1 = A_1 < A_2 < \cdots < A_K \leq N$

## 样例 #1

### 输入

```
10 2
1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
11 4
1 2 3 6```

### 输出

```
8```

## 样例 #3

### 输入

```
10000 10
1 2 4 8 16 32 64 128 256 512```

### 输出

```
5136```

# AI分析结果

【题目内容】
# [ABC270D] Stones

## 题目描述

#### 题目翻译
Takahashi 和 Aoki 在玩一个取石子的游戏。

刚开始，有 $N$ 个石子，还有一个长度为 $K$ 的序列 $A = \{A_1,A_2,\cdots,A_K\}$。

现在，他们要按照以下规则轮流取石子：

* 对于每次操作，他可以选择一个 $i$（$1 \leq i \leq K$），这时他会取走 $A_i$ 块石子。

* 当一个人没法取石子时，游戏结束。

现在，Takahashi 先取石子，Aoki 后取石子。
他们都想尽可能的最大化他们自己取走的石子数量。

若他们都以最优策略取石子，最后 Takahashi 会取走多少块石子？

## 说明/提示

对于 $100\%$ 的数据，保证：
* $1 \leq N \leq 10^4$
* $1 \leq K \leq 100$
* $1 = A_1 < A_2 < \cdots < A_K \leq N$

## 样例 #1

### 输入

```
10 2
1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
11 4
1 2 3 6```

### 输出

```
8```

## 样例 #3

### 输入

```
10000 10
1 2 4 8 16 32 64 128 256 512```

### 输出

```
5136```

【算法分类】
动态规划

【题解分析与结论】
本题的核心是通过动态规划来解决博弈论中的取石子问题。所有题解都采用了动态规划的思路，设 $dp_i$ 表示当前石子数量为 $i$ 时，先手能取到的最大石子数。转移方程为 $dp_i = \max \{i - dp_{i - a_j}\}$，其中 $a_j$ 是可取的石子数量。这种方法的时间复杂度为 $O(NK)$，能够有效解决问题。

【评分较高的题解】
1. **作者：lottle1212 (赞：14)**
   - **星级：5星**
   - **关键亮点：** 详细解释了为什么贪心算法不适用，并通过动态规划的转移方程清晰地展示了如何计算先手的最优解。
   - **代码实现：**
     ```cpp
     for (int i = 1; i <= n; ++i)
         for (int j = 1; j <= k; ++j) {
             if (i < a[j]) break;
             dp[i] = max(dp[i], i - dp[i - a[j]]);
         }
     ```

2. **作者：DengDuck (赞：8)**
   - **星级：4星**
   - **关键亮点：** 简洁明了地给出了动态规划的转移方程，并提供了清晰的代码实现。
   - **代码实现：**
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = 1; j <= k; j++) {
             if (i < a[j]) break;
             f[i] = max(f[i], i - f[i - a[j]]);
         }
     }
     ```

3. **作者：Mingrui_Yang (赞：0)**
   - **星级：4星**
   - **关键亮点：** 通过状态转移方程清晰地展示了如何计算先手的最优解，代码简洁易懂。
   - **代码实现：**
     ```cpp
     for (int i = 1; i <= n; i ++ )
         for (int j = 1; j <= k; j ++ )
             if (i >= a[j])
                 f[i] = max(f[i], i - f[i - a[j]]);
     ```

【最优关键思路】
通过动态规划，设 $dp_i$ 表示当前石子数量为 $i$ 时，先手能取到的最大石子数。转移方程为 $dp_i = \max \{i - dp_{i - a_j}\}$，其中 $a_j$ 是可取的石子数量。这种方法能够有效解决问题，且时间复杂度为 $O(NK)$。

【可拓展之处】
类似的问题可以使用动态规划来解决，尤其是涉及博弈论和最优策略的问题。例如，取石子问题的变种、硬币问题等。

【推荐题目】
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)

【个人心得】
- **lottle1212** 提到贪心算法在某些情况下会失效，这提醒我们在解决类似问题时，不能盲目使用贪心算法，而应该考虑更全面的动态规划方法。
- **DengDuck** 的代码简洁明了，适合初学者理解和学习动态规划的基本思路。

---
处理用时：33.72秒
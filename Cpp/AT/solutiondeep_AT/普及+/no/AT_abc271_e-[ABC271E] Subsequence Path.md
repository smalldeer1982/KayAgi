# 题目信息

# [ABC271E] Subsequence Path

## 题目描述

某地区有 $N$ 个城镇，编号为 1 到 $N$ ，并且由 $M$ 条公路连接，编号 1 到 $M$ 。

每条公路都是有向的；而且编号为 $i(1 \le i \le M)$ 的道路将带领你从编号 $A_i$ 的城镇到编号为 $B_i$ 的城镇去,它的长度为 $C_i$。

现在给你一个长度为 $K$ 的正整数序列 $E=(E_1,E_2,...,E_K)$ 且 $\forall i \in [1,K],E_i \in [1,M]$ 。我们说一条由一些连通的公路组成的路径为“**好路**”，当且仅当满足以下条件：

+ 这条路径的起点为 1 ，终点为 $N$ 。
+ 按经过顺序组成这条路径的公路的编号组成的序列是 $E$ 的子序列。

**注意**，若序列 $S$ 是长度为 $L$ 的数列 $T$ 的**子序列**，则 $S$ 是数列 $T$ 删除任意 $i\ (i\in [0,L])$ 个元素得到的。

现在你要找到最短的“**好路**”。如果没有，输出 ```-1``` 。

## 说明/提示

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M,\ K\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N,\ A_i\ \neq\ B_i\ \,\ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ C_i\ \leq\ 10^9\ \,\ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ E_i\ \leq\ M\ \,\ (1\ \leq\ i\ \leq\ K) $
+ 所有输入都是整数

#### 样例解释

对于**样例1**，有两条好路：

+ 选择编号为 $4$ 的公路。在这种情况下，“**好路**”的长度是 $5$ 。
+ 依次选择编号为 $1$ 和 $2$ 的公路。在这种情况下，“**好路**”的长度就变为了 $2+2=4$ 。

因此，输出的期望值为 $4$ 。

对于**样例2**，没有“**好路**”，输出 ``` -1 ``` 。

## 样例 #1

### 输入

```
3 4 4

1 2 2

2 3 2

1 3 3

1 3 5

4 2 1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
3 2 3

1 2 1

2 3 1

2 1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 4 5

3 2 2

1 3 5

2 4 7

3 4 10

2 4 1 4 3```

### 输出

```
14```

# AI分析结果

### 题目内容重写

某地区有 $N$ 个城镇，编号为 1 到 $N$，并且由 $M$ 条公路连接，编号 1 到 $M$。每条公路都是有向的；而且编号为 $i(1 \le i \le M)$ 的道路将带领你从编号 $A_i$ 的城镇到编号为 $B_i$ 的城镇去，它的长度为 $C_i$。

现在给你一个长度为 $K$ 的正整数序列 $E=(E_1,E_2,...,E_K)$ 且 $\forall i \in [1,K],E_i \in [1,M]$。我们说一条由一些连通的公路组成的路径为“**好路**”，当且仅当满足以下条件：

+ 这条路径的起点为 1，终点为 $N$。
+ 按经过顺序组成这条路径的公路的编号组成的序列是 $E$ 的子序列。

**注意**，若序列 $S$ 是长度为 $L$ 的数列 $T$ 的**子序列**，则 $S$ 是数列 $T$ 删除任意 $i\ (i\in [0,L])$ 个元素得到的。

现在你要找到最短的“**好路**”。如果没有，输出 ```-1```。

### 算法分类
动态规划

### 题解分析与结论

本题的核心思路是通过动态规划（DP）来求解最短路径。由于路径的边序列必须是给定序列 $E$ 的子序列，因此不能直接使用传统的最短路算法（如Dijkstra或Bellman-Ford）。题解中普遍采用了DP的思想，定义 $f_i$ 表示从起点1到点 $i$ 的最短“好路”长度，然后通过遍历序列 $E$ 中的边进行状态转移。

### 精选题解

#### 题解1：2020luke (5星)
**关键亮点**：
- 思路清晰，直接定义 $f_i$ 为从1到 $i$ 的最短“好路”长度。
- 代码简洁，直接通过遍历序列 $E$ 中的边进行状态转移。
- 使用了 `memset` 初始化数组，代码可读性强。

**核心代码**：
```cpp
memset(f, 0x3f, sizeof(f));
f[1] = 0;
for(int i = 1; i <= k; i++) {
    cin >> e;
    f[b[e]] = min(f[b[e]], f[a[e]] + c[e]);
}
if(f[n] < 1e18) {
    cout << f[n];
} else {
    cout << -1;
}
```

#### 题解2：_GW_ (4星)
**关键亮点**：
- 使用了自定义结构体存储图的信息，代码结构清晰。
- 初始化 $f$ 数组为极大值，避免了不必要的计算。
- 代码简洁，直接通过遍历序列 $E$ 中的边进行状态转移。

**核心代码**：
```cpp
for(int i = 2; i <= n; i++) f[i] = 0x3f3f3f3f3f3f3f3f;
for(int i = 1; i <= k; i++) {
    cin >> u;
    f[a[u].y] = min(f[a[u].y], f[a[u].x] + a[u].z);
}
if(f[n] == 4557430888798830399) cout << -1 << endl;
else cout << f[n] << endl;
```

#### 题解3：littlebug (4星)
**关键亮点**：
- 强调了序列 $E$ 中边可能重复的情况，避免了直接使用最短路算法的误区。
- 代码简洁，直接通过遍历序列 $E$ 中的边进行状态转移。
- 使用了 `memset` 初始化数组，代码可读性强。

**核心代码**：
```cpp
memset(f, 0x3f, sizeof(f));
f[1] = 0;
rep(i,1,k) f[e[a[i]].v] = min(f[e[a[i]].v], f[e[a[i]].u] + e[a[i]].w);
write(f[n]==inf ? -1ll : f[n]);
```

### 最优关键思路与技巧
1. **状态定义**：定义 $f_i$ 为从起点1到点 $i$ 的最短“好路”长度。
2. **状态转移**：通过遍历序列 $E$ 中的边，更新 $f_{b_e} = \min(f_{b_e}, f_{a_e} + c_e)$。
3. **初始化**：将 $f$ 数组初始化为极大值，$f_1$ 初始化为0。
4. **输出结果**：根据 $f_n$ 的值判断是否存在最短“好路”，并输出结果。

### 可拓展之处
- **类似题目**：可以扩展到其他需要按特定顺序选择边的图论问题，如按特定顺序选择边的最小生成树问题。
- **算法优化**：可以考虑使用优先队列（堆）来优化状态转移，但需要结合具体问题分析。

### 推荐题目
1. [P1552](https://www.luogu.com.cn/problem/P1522) - 考察动态规划与图论结合的问题。
2. [P1522](https://www.luogu.com.cn/problem/P1522) - 考察动态规划与图论结合的问题。
3. [P1523](https://www.luogu.com.cn/problem/P1523) - 考察动态规划与图论结合的问题。

### 个人心得摘录
- **调试经历**：在初始化 $f$ 数组时，需要注意将其初始化为极大值，避免影响后续计算。
- **踩坑教训**：直接使用最短路算法会导致无法满足序列 $E$ 的子序列要求，因此需要采用DP的思路。
- **顿悟感想**：通过遍历序列 $E$ 中的边进行状态转移，可以有效地保证路径的边序列是 $E$ 的子序列。

---
处理用时：38.49秒
# 题目信息

# [ABC272E] Add and Mex

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc272/tasks/abc272_e

長さ $ N $ の整数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられます。

以下の操作を $ M $ 回行ってください。

- 各 $ i\ (1\leq\ i\ \leq\ N) $ について、 $ A_i $ に $ i $ を加算する。その後 $ A $ に含まれない最小の非負整数を求める。

## 说明/提示

### 制約

- $ 1\leq\ N,M\ \leq\ 2\times\ 10^5 $
- $ -10^9\leq\ A_i\leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

$ 1 $ 回目の操作では、数列 $ A $ は $ (-1\ +\ 1,\ -1\ +2\ ,-6+3)\ =\ (0,1,-3) $ になります。 $ A $ に含まれない最小の非負整数は $ 2 $ です。 $ 2 $ 回目の操作では、数列 $ A $ は $ (0\ +\ 1,\ 1\ +2\ ,-3+3)\ =\ (1,3,0) $ になります。 $ A $ に含まれない最小の非負整数は $ 2 $ です。 $ 3 $ 回目の操作では、数列 $ A $ は $ (1\ +\ 1,\ 3\ +2\ ,0+3)\ =\ (2,5,3) $ になります。 $ A $ に含まれない最小の非負整数は $ 0 $ です。

## 样例 #1

### 输入

```
3 3
-1 -1 -6```

### 输出

```
2
2
0```

## 样例 #2

### 输入

```
5 6
-2 -2 -5 -7 -15```

### 输出

```
1
3
2
0
0
0```

# AI分析结果

### 题目翻译

**题目描述**

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\ldots,A_N)$。

你需要进行 $M$ 次操作，每次操作如下：

- 对于每个 $i\ (1\leq\ i\ \leq\ N)$，将 $A_i$ 加上 $i$。然后求出 $A$ 中不包含的最小非负整数。

**说明/提示**

**约束条件**

- $1\leq\ N,M\ \leq\ 2\times\ 10^5$
- $-10^9\leq\ A_i\leq\ 10^9$
- 输入均为整数

**样例解释**

- 样例1：
  - 第一次操作后，$A$ 变为 $(0,1,-3)$，不包含的最小非负整数是 $2$。
  - 第二次操作后，$A$ 变为 $(1,3,0)$，不包含的最小非负整数是 $2$。
  - 第三次操作后，$A$ 变为 $(2,5,3)$，不包含的最小非负整数是 $0$。

### 算法分类
模拟、调和级数

### 题解分析与结论

本题的核心在于如何高效地计算每次操作后的 $\text{mex}$。由于 $\text{mex}$ 的值一定在 $[0, N]$ 之间，因此可以忽略那些不在这个范围内的数。通过调和级数的性质，可以证明每个数对 $\text{mex}$ 的贡献次数是有限的，总时间复杂度为 $O(N \log N)$。

### 精选题解

#### 题解1：作者：linxuanrui (赞：3)
**星级：4.5**
**关键亮点：**
- 利用调和级数分析时间复杂度，确保算法效率。
- 通过预处理每个数的贡献区间，减少不必要的计算。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
for(int i = 1;i <= n;i++){
    lst1 = (a[i] >= 0 ? 0ll : (-a[i] + i - 1) / i),lst2 = max((n - a[i]) / i,0ll);
    for(int j = max(lst1,0ll);j <= lst2 && j <= m;j++){
        v[j].push_back(a[i] + j * i);
    }
}
for(int i = 1;i <= m;i++){
    sort(v[i].begin(),v[i].end());
    int now = 0;
    for(int j = 0;j < v[i].size();j++){
        if(v[i][j] == now){
            now++;
        }
    }
    cout << now << endl;
}
```

#### 题解2：作者：Register_int (赞：2)
**星级：4**
**关键亮点：**
- 通过暴力记录状态，简化了问题复杂度。
- 使用 `set` 维护可能的值，确保 $\text{mex}$ 计算的准确性。
- 代码简洁，易于理解。

**核心代码：**
```cpp
for(int i = 1;i <= n;i++){
    int k = max((-a[i] - 1) / i, 0) + 1; a[i] += k * i;
    for(int j = k;j <= m;j++){
        if(a[i] >= n) break;
        v[j].push_back(a[i]), a[i] += i;
    }
}
for(int i = 1;i <= m;i++){
    for(auto x : v[i]) vis[x] = 1;
    for(int j = 0;j <= n;j++){
        if(!vis[j]) { p = j; break; }
    }
    for(auto x : v[i]) vis[x] = 0;
    printf("%d\n", p);
}
```

#### 题解3：作者：CQ_Bob (赞：1)
**星级：4**
**关键亮点：**
- 通过二分查找优化了预处理过程。
- 使用 `map` 维护状态，确保 $\text{mex}$ 计算的准确性。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
for(int i = 1;i <= n;i++){
    int l = 1,r = m,tim = m + 1;
    while(l <= r){
        int mid = l + r >> 1;
        if(a[i] + mid * i >= 0) tim = mid, r = mid - 1;
        else l = mid + 1;
    }
    a[i] += (tim - 1) * i;
    for(;tim <= m;tim++){
        a[i] += i; if(a[i] > n) break;
        vis[tim][a[i]] = 1;
    }
}
for(int i = 1;i <= m;i++)
    for(int j = 0;j <= n;j++)
        if(!vis[i][j]){ cout << j << "\n"; break; }
```

### 最优关键思路
- **调和级数优化**：通过调和级数的性质，确保每个数对 $\text{mex}$ 的贡献次数有限，总时间复杂度为 $O(N \log N)$。
- **预处理贡献区间**：通过预处理每个数的贡献区间，减少不必要的计算，提高算法效率。
- **使用高效数据结构**：如 `set` 或 `map`，确保 $\text{mex}$ 计算的准确性和高效性。

### 可拓展之处
- **类似题目**：可以扩展到其他需要计算 $\text{mex}$ 的问题，如区间 $\text{mex}$ 查询等。
- **优化技巧**：调和级数优化和预处理贡献区间的思路可以应用于其他需要高效计算的问题中。

### 推荐题目
1. [P4137 Rmq Problem / mex](https://www.luogu.com.cn/problem/P4137)
2. [P5494 【模板】线段树](https://www.luogu.com.cn/problem/P5494)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

---
处理用时：43.85秒
# 题目信息

# [ABC274E] Booster

## 题目描述

在平面直角坐标系中，有 $n$ 个城镇和 $m$ 个箱子。

你现在在 $(0,0)$，速度为 $1$，你需要走遍所有城镇后回到 $(0,0)$。

你可以选择走到箱子所处的位置，如果你第一次走到这个箱子，你可以吞下箱子里仅剩的一颗能量球，然后你的速度就翻倍了。

求从 $(0,0)$ 走遍所有城镇后回到 $(0,0)$ 所需的最短时间。

## 说明/提示

样例一：路径为 $O-Chest_1-Town_1-Town_2-O$。  
样例二：路径为 $O-Town_1-Town_2-O$。


对于所有数据，$1\leq n\leq 12,0\leq m\leq 5,0\leq |x_i|,|y_i|,|p_i|,|q_i|\leq 10^9$。

Translate by Zek3L.

## 样例 #1

### 输入

```
2 1
1 1
0 1
1 0```

### 输出

```
2.5000000000```

## 样例 #2

### 输入

```
2 1
1 1
0 1
100 0```

### 输出

```
3.4142135624```

## 样例 #3

### 输入

```
1 2
4 4
1 0
0 1```

### 输出

```
4.3713203436```

# AI分析结果

【题目内容】
# [ABC274E] Booster

## 题目描述

在平面直角坐标系中，有 $n$ 个城镇和 $m$ 个箱子。

你现在在 $(0,0)$，速度为 $1$，你需要走遍所有城镇后回到 $(0,0)$。

你可以选择走到箱子所处的位置，如果你第一次走到这个箱子，你可以吞下箱子里仅剩的一颗能量球，然后你的速度就翻倍了。

求从 $(0,0)$ 走遍所有城镇后回到 $(0,0)$ 所需的最短时间。

## 说明/提示

样例一：路径为 $O-Chest_1-Town_1-Town_2-O$。  
样例二：路径为 $O-Town_1-Town_2-O$。


对于所有数据，$1\leq n\leq 12,0\leq m\leq 5,0\leq |x_i|,|y_i|,|p_i|,|q_i|\leq 10^9$。

Translate by Zek3L.

## 样例 #1

### 输入

```
2 1
1 1
0 1
1 0```

### 输出

```
2.5000000000```

## 样例 #2

### 输入

```
2 1
1 1
0 1
100 0```

### 输出

```
3.4142135624```

## 样例 #3

### 输入

```
1 2
4 4
1 0
0 1```

### 输出

```
4.3713203436```

【算法分类】
动态规划

【综合分析】
本题的核心是通过状压 DP 来记录经过的城镇和箱子的状态，并计算最短时间。难点在于如何有效地处理速度的变化以及如何将状态转移方程设计得简洁高效。各题解都采用了类似的思路，即将城镇和箱子的状态压缩到一个二进制数中，通过枚举状态和转移点来计算最小时间。不同题解在代码实现和优化上有所差异，但整体思路一致。

【评分较高的题解】

1. **作者：蒟蒻炒扇贝 (赞：4)**
   - **星级：4**
   - **关键亮点**：代码简洁，状态转移方程清晰，使用了 `__builtin_popcount` 来快速计算速度倍率。
   - **代码核心**：
     ```cpp
     for(int s=1;s<=(1<<(n+m))-1;s++) {
         ld v=(1ll<<(__builtin_popcount(s>>n)));
         for(int i=1;i<=n+m;i++) {
             if(!(s&(1<<(i-1))))continue;
             for(int j=1;j<=n+m;j++)if(!(s&(1<<(j-1))))f[j][s|(1<<(j-1))]=min(f[j][s|(1<<(j-1))],f[i][s]+dis(x[i],y[i],x[j],y[j])/v);
         }
     }
     ```

2. **作者：Register_int (赞：4)**
   - **星级：4**
   - **关键亮点**：状态转移方程设计合理，代码结构清晰，使用了 `popcnt` 函数来计算速度倍率。
   - **代码核心**：
     ```cpp
     for(int s=1;s<1<<t;s++) {
         for(int i=0;i<t;i++) {
             if(~s&1<<i)continue;
             for(int j=0,x;j<t;j++) {
                 if(~s&1<<j||i==j)continue;
                 x=s^(1<<i);
                 dp[i][s]=min(dp[i][s],dp[j][x]+dist(i,j)/(1<<popcnt(x&mst)));
             }
         }
     }
     ```

3. **作者：Iratis (赞：2)**
   - **星级：3**
   - **关键亮点**：状态转移方程清晰，代码结构较为简洁，但未使用 `__builtin_popcount`，而是自定义了 `popcnt` 函数。
   - **代码核心**：
     ```cpp
     for(int w=1;w<=n+m-1;w++) {
         for(int mask:v[w]) {
             for(int x=1;x<=n+m;x++) {
                 if(!((mask>>(x-1))&1))continue;
                 for(int y=1;y<=n+m;y++) {
                     if((mask>>(y-1))&1)continue; 
                     int no=mask|(1<<(y-1));
                     f[y][no]=min(f[y][no],f[x][mask]+dis(a[x],a[y])/nu[mask]);
                 }
             }
         }
     }
     ```

【最优关键思路】
1. **状态压缩**：将城镇和箱子的状态压缩到一个二进制数中，前 $n$ 位表示城镇，后 $m$ 位表示箱子。
2. **速度计算**：通过 `__builtin_popcount` 或自定义的 `popcnt` 函数快速计算当前速度倍率。
3. **状态转移**：枚举当前状态和转移点，更新最小时间。

【拓展思路】
类似的问题可以通过状压 DP 来解决，尤其是在状态数较少且需要记录多个状态的情况下。例如，旅行商问题（TSP）也可以通过状压 DP 来求解。

【推荐题目】
1. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
2. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

【个人心得】
在调试过程中，发现速度倍率的计算是关键，使用 `__builtin_popcount` 可以显著提高代码效率。此外，状态转移方程的设计需要仔细考虑，确保所有可能的状态都被覆盖。

---
处理用时：41.06秒
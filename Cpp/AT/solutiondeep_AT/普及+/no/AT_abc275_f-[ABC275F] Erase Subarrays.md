# 题目信息

# [ABC275F] Erase Subarrays

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc275/tasks/abc275_f

正整数列 $ A=(a_1,a_2,\ldots,a_N) $ が与えられます。  
あなたは次の操作を $ 0 $ 回以上何度でも繰り返せます。

- $ A $ から（空でない）連続する部分列を選び、削除する。

$ x=1,2,\ldots,M $ に対し、次の問題を解いてください。

- $ A $ の要素の総和をちょうど $ x $ にするために必要な操作回数の最小値を求めてください。ただし、どのように操作を行っても $ A $ の要素の総和をちょうど $ x $ にできない場合は代わりに `-1` と出力してください。

なお、$ A $ が空である時、$ A $ の要素の総和は $ 0 $ であるとします。

## 说明/提示

### 制約

- $ 1\ \leq\ N,M\ \leq\ 3000 $
- $ 1\ \leq\ a_i\ \leq\ 3000 $
- 入力はすべて整数

### Sample Explanation 1

操作回数が最小である操作の例を以下に示します。 - $ x=1 $ について、$ a_2,a_3,a_4 $ に対して操作をすることで $ A $ の要素の総和が $ x $ になります。 - $ x=2 $ について、$ a_3,a_4 $ に対して操作をした後、$ a_1 $ に対して操作をすることで $ A $ の要素の総和が $ x $ になります。 - $ x=3 $ について、$ a_3,a_4 $ に対して操作をすることで $ A $ の要素の総和が $ x $ になります。 - $ x=4 $ について、$ a_1,a_2,a_3 $ に対して操作をすることで $ A $ の要素の総和が $ x $ になります。 - $ x=5 $ について、$ a_2,a_3 $ に対して操作をすることで $ A $ の要素の総和が $ x $ になります。

## 样例 #1

### 输入

```
4 5
1 2 3 4```

### 输出

```
1
2
1
1
1```

## 样例 #2

### 输入

```
1 5
3```

### 输出

```
-1
-1
0
-1
-1```

## 样例 #3

### 输入

```
12 20
2 5 6 5 2 1 7 9 7 2 5 5```

### 输出

```
2
1
2
2
1
2
1
2
2
1
2
1
1
1
2
2
1
1
1
1```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个正整数列 $ A=(a_1,a_2,\ldots,a_N) $。你可以进行以下操作任意次（包括零次）：

- 从 $ A $ 中选择一个非空的连续子序列并删除它。

对于 $ x=1,2,\ldots,M $，请解决以下问题：

- 找到使 $ A $ 的元素总和恰好为 $ x $ 所需的最小操作次数。如果无论如何操作都无法使 $ A $ 的元素总和恰好为 $ x $，则输出 `-1`。

注意，当 $ A $ 为空时，$ A $ 的元素总和为 $ 0 $。

#### 说明/提示

##### 约束条件

- $ 1\ \leq\ N,M\ \leq\ 3000 $
- $ 1\ \leq\ a_i\ \leq\ 3000 $
- 输入均为整数

##### 样例解释

操作次数最少的操作示例如下：

- 对于 $ x=1 $，删除 $ a_2,a_3,a_4 $，使 $ A $ 的元素总和为 $ x $。
- 对于 $ x=2 $，先删除 $ a_3,a_4 $，然后删除 $ a_1 $，使 $ A $ 的元素总和为 $ x $。
- 对于 $ x=3 $，删除 $ a_3,a_4 $，使 $ A $ 的元素总和为 $ x $。
- 对于 $ x=4 $，删除 $ a_1,a_2,a_3 $，使 $ A $ 的元素总和为 $ x $。
- 对于 $ x=5 $，删除 $ a_2,a_3 $，使 $ A $ 的元素总和为 $ x $。

### 算法分类

动态规划

### 题解分析与结论

#### 综合分析

本题的核心是通过动态规划（DP）来求解最小操作次数。所有题解都采用了 DP 的思路，但在状态定义和转移方式上有所不同。主要难点在于如何高效地处理删除子序列的操作，避免时间复杂度过高。

#### 精选题解

1. **作者：Magic_World (赞：13)**  
   - **星级：5**  
   - **关键亮点**：通过维护一个辅助数组 $g[j]$ 来优化状态转移，将时间复杂度从 $O(n^2m)$ 降低到 $O(nm)$。代码简洁且高效。  
   - **核心代码**：
     ```cpp
     rep(i,1,n) {
         rep(j,0,m) {
             if(j>=a[i]) f[i][j] = f[i-1][j-a[i]];
             f[i][j] = min(f[i][j],g[j]+1);
             g[j] = min(g[j],f[i][j]);
         }
     }
     ```

2. **作者：weirdoX (赞：2)**  
   - **星级：4**  
   - **关键亮点**：使用三维 DP 状态 $f[i][j][k]$ 来记录是否选择当前元素，状态转移清晰，但代码复杂度较高。  
   - **核心代码**：
     ```cpp
     for(int i = 2; i <= n; i++)
         for(int j = 0; j <= m; j++) {
             dp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][j][1]);
             if(j >= a[i])
                 dp[i][j][1] = min(dp[i - 1][j - a[i]][0] + 1, dp[i - 1][j - a[i]][1]);
         }
     ```

3. **作者：TemplateClass (赞：0)**  
   - **星级：4**  
   - **关键亮点**：通过维护一个 $min[j]$ 数组来优化删除操作的转移，思路清晰，代码简洁。  
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; ++i) {
         for(int j = 0; j <= m; ++j) {
             if(j >= a[i]) dp[i][j] = dp[i - 1][j - a[i]];
             dp[i][j] = std::min(dp[i][j], min[j] + 1);
             min[j] = std::min(min[j], dp[i][j]);
         }
     }
     ```

### 最优关键思路与技巧

1. **状态定义**：使用 $f[i][j]$ 表示前 $i$ 个元素中，总和为 $j$ 的最小操作次数。
2. **优化转移**：通过维护一个辅助数组 $g[j]$ 或 $min[j]$ 来记录当前的最小操作次数，避免重复计算。
3. **边界处理**：初始化 $f[0][0] = 0$，并处理 $j < a[i]$ 的情况。

### 可拓展之处

类似的问题可以通过维护辅助数组来优化状态转移，适用于需要频繁查询最小或最大值的 DP 问题。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)  
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)  
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

### 个人心得

- **调试经历**：在优化 DP 状态转移时，维护辅助数组是常见的优化手段，可以有效降低时间复杂度。
- **踩坑教训**：在处理边界条件时，务必注意数组越界问题，尤其是在 $j < a[i]$ 的情况下。
- **顿悟感想**：通过维护辅助数组，可以将复杂的转移问题简化为线性时间复杂度的查询，极大提高代码效率。

---
处理用时：36.90秒
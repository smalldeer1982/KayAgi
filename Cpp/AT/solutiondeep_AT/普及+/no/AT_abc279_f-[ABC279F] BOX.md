# 题目信息

# [ABC279F] BOX

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc279/tasks/abc279_f

$ N $ 個の箱 $ 1,2,\dots,N $ と、 $ 10^{100} $ 個のボール $ 1,2,\dots,10^{100} $ があります。 最初、箱 $ i $ にはボール $ i $ のみが入っています。

ここに以下の操作が合計 $ Q $ 回行われるので、処理してください。

操作にはタイプ $ 1,2,3 $ の $ 3 $ 種類があります。

タイプ $ 1 $ : 箱 $ X $ に箱 $ Y $ の中身を全て入れる。 この操作では $ X\ \neq\ Y $ が保証される。

> 1 $ X $ $ Y $

タイプ $ 2 $ : 現在いずれかの箱に入っているボールの数の合計を $ k $ とすると、箱 $ X $ にボール $ k+1 $ を入れる。

> 2 $ X $

タイプ $ 3 $ : ボール $ X $ が入っている箱の番号を答える。

> 3 $ X $

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ 1\ \le\ Q\ \le\ 3\ \times\ 10^5 $
- タイプ $ 1 $ の操作について、 $ 1\ \le\ X,Y\ \le\ N $ かつ $ X\ \neq\ Y $
- タイプ $ 2 $ の操作について、 $ 1\ \le\ X\ \le\ N $
- タイプ $ 3 $ の操作について、その時点でボール $ X $ がいずれかの箱に入っている
- タイプ $ 3 $ の操作が少なくとも $ 1 $ つ与えられる

### Sample Explanation 1

この入力は $ 10 $ 個の操作を含みます。 - $ 1 $ 回目の操作はタイプ $ 3 $ です。ボール $ 5 $ は箱 $ 5 $ に入っています。 - $ 2 $ 回目の操作はタイプ $ 1 $ です。箱 $ 1 $ に箱 $ 4 $ の中身を全て入れます。 - 箱 $ 1 $ の中身はボール $ 1,4 $ 、箱 $ 4 $ の中身は空になります。 - $ 3 $ 回目の操作はタイプ $ 2 $ です。箱 $ 1 $ にボール $ 6 $ を入れます。 - $ 4 $ 回目の操作はタイプ $ 2 $ です。箱 $ 4 $ にボール $ 7 $ を入れます。 - $ 5 $ 回目の操作はタイプ $ 3 $ です。ボール $ 7 $ は箱 $ 4 $ に入っています。 - $ 6 $ 回目の操作はタイプ $ 1 $ です。箱 $ 3 $ に箱 $ 1 $ の中身を全て入れます。 - 箱 $ 3 $ の中身はボール $ 1,3,4,6 $ 、箱 $ 1 $ の中身は空になります。 - $ 7 $ 回目の操作はタイプ $ 3 $ です。ボール $ 4 $ は箱 $ 3 $ に入っています。 - $ 8 $ 回目の操作はタイプ $ 1 $ です。箱 $ 1 $ に箱 $ 4 $ の中身を全て入れます。 - 箱 $ 1 $ の中身はボール $ 7 $ 、箱 $ 4 $ の中身は空になります。 - $ 9 $ 回目の操作はタイプ $ 3 $ です。ボール $ 7 $ は箱 $ 1 $ に入っています。 - $ 10 $ 回目の操作はタイプ $ 3 $ です。ボール $ 6 $ は箱 $ 3 $ に入っています。

## 样例 #1

### 输入

```
5 10
3 5
1 1 4
2 1
2 4
3 7
1 3 1
3 4
1 1 4
3 7
3 6```

### 输出

```
5
4
3
1
3```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $N$ 个箱子 $1,2,\dots,N$ 和 $10^{100}$ 个球 $1,2,\dots,10^{100}$。最初，箱子 $i$ 中只包含球 $i$。

现在有 $Q$ 次操作，操作分为三种类型：

1. **类型 1**：将箱子 $Y$ 中的所有球倒入箱子 $X$。保证 $X \neq Y$。
   - 格式：`1 X Y`
2. **类型 2**：在当前所有箱子中的球的总数为 $k$ 时，将球 $k+1$ 放入箱子 $X$。
   - 格式：`2 X`
3. **类型 3**：查询球 $X$ 所在的箱子编号。
   - 格式：`3 X`

### 算法分类

并查集

### 题解分析与结论

#### 综合分析

本题的核心在于如何处理箱子和球的合并与查询操作。由于涉及到集合的合并与查询，并查集是最合适的算法。各题解均采用了并查集的思想，但在具体实现上有所不同。

#### 最优关键思路

1. **新建节点**：在合并操作时，为了避免后续操作对已合并集合的影响，新建一个节点来表示被清空的箱子。这样可以确保后续操作不会影响到之前的合并结果。
2. **路径压缩**：使用路径压缩优化并查集的查询操作，确保查询的时间复杂度为 $O(\alpha(n))$。
3. **映射关系**：通过维护 `id` 和 `ans` 数组，记录每个球或箱子对应的并查集节点及其最终的箱子编号。

#### 题解评分与亮点

1. **liangbowen (5星)**
   - **亮点**：详细解释了新建节点的必要性，并通过图示展示了合并操作的过程，代码清晰且易于理解。
   - **代码核心**：
     ```cpp
     void solve() {
         int n, q;
         scanf("%d%d", &n, &q);
         int cnt_ball = n, cnt_box = n + q;
         for (int i = 1, mx = n + 2 * q; i <= mx; i++) fa[i] = id[i] = ans[i] = i;
         while (q--) {
             int op, x, y;
             scanf("%d%d", &op, &x);
             if (op == 1) {
                 scanf("%d", &y);
                 merge(id[x], id[y]);
                 cnt_box++, id[y] = cnt_box, ans[cnt_box] = y;
             }
             else if (op == 2) merge(id[x], ++cnt_ball);
             else printf("%d\n", ans[get(x)]);
         }
     }
     ```

2. **DaydreamWarrior (4星)**
   - **亮点**：简洁明了地解释了并查集的实现，代码简洁且高效。
   - **代码核心**：
     ```cpp
     int main() {
         cin >> n >> q;
         for (int k = 1; k <= n; k++) fa[k] = ans[k] = c[k] = w[k] = k;
         int siz = n, idx = n;
         while (q--) {
             int ops;
             cin >> ops;
             if (ops == 1) {
                 int x, y;
                 cin >> x >> y;
                 fa[c[y]] = c[x];
                 c[y] = ++idx;
                 fa[idx] = idx;
                 ans[idx] = y;
             }
             else if (ops == 2) {
                 int x;
                 cin >> x;
                 w[++siz] = c[x];
             }
             else {
                 int x;
                 cin >> x;
                 cout << ans[find(w[x])] << endl;
             }
         }
         return 0;
     }
     ```

3. **rui_er (4星)**
   - **亮点**：通过维护 `rt` 和 `id` 数组，清晰地记录了每个集合的根节点和对应的箱子编号，代码结构清晰。
   - **代码核心**：
     ```cpp
     void merge(int x, int y) {
         if (!rt[y]) return;
         if (!rt[x]) {
             id[rt[y]] = x;
             rt[x] = rt[y];
             rt[y] = 0;
             return;
         }
         id[rt[y]] = 0;
         fa[rt[y]] = rt[x];
         rt[y] = 0;
     }
     ```

### 扩展思路

1. **启发式合并**：可以考虑使用启发式合并来优化合并操作的时间复杂度，特别是在集合大小差异较大的情况下。
2. **动态维护**：可以通过动态维护每个箱子的球的数量，进一步优化查询操作。

### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)

---
处理用时：35.57秒
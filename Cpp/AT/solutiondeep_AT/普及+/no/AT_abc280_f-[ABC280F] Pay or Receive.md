# 题目信息

# [ABC280F] Pay or Receive

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc280/tasks/abc280_f

$ 1,\ldots,N $ の番号がついた $ N $ 個の街と、$ 1,\ldots,M $ の番号がついた $ M $ 本の道路があります。

道路 $ i $ は街 $ A_i $ と $ B_i $ を結んでいます。道路を通行すると、所持している **ポイント** が次の通り増減します。

- 道路 $ i $ を使って、街 $ A_i $ から街 $ B_i $ に移動するときにはポイントが $ C_i $ 増加し、街 $ B_i $ から街 $ A_i $ に移動するときにはポイントが $ C_i $ 減少する。
 
所持しているポイントは負にもなりえます。

次の $ Q $ 個の質問に答えてください。

- 所持しているポイントが $ 0 $ である状態で街 $ X_i $ から移動を始めたとき、街 $ Y_i $ にいる状態で所持しているポイントの最大値を出力せよ。  
   ただし、街 $ X_i $ から街 $ Y_i $ に到達できないときは `nan`、街 $ Y_i $ にいる状態で所持しているポイントをいくらでも増やせるときは `inf` を代わりに出力せよ。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 10^5 $
- $ 0\leq\ M\ \leq\ 10^5 $
- $ 1\leq\ Q\ \leq\ 10^5 $
- $ 1\leq\ A_i,B_i,X_i,Y_i\ \leq\ N $
- $ 0\leq\ C_i\ \leq\ 10^9 $
- 入力は全て整数である
 
### Sample Explanation 1

$ 1 $ 番目の質問では、道路 $ 5 $ を使って街 $ 5 $ から街 $ 3 $ に移動すると、ポイントを $ -2 $ 所持している状態で街 $ 3 $ にいることができます。 これ以上ポイントを大きくすることはできないので答えは $ -2 $ になります。 $ 2 $ 番目の質問では、「道路 $ 2 $ を使って街 $ 1 $ から街 $ 2 $ に移動し、道路 $ 1 $ を使って街 $ 2 $ から街 $ 1 $ に移動する」 という行動を好きなだけ繰り返したあと、道路 $ 2 $ を使って街 $ 1 $ から街 $ 2 $ に移動することで、 街 $ 2 $ にいる状態で所持しているポイントをいくらでも増やすことができます。 $ 3 $ 番目の質問では、街 $ 3 $ から移動を始めて街 $ 1 $ へ到達することはできません。

### Sample Explanation 2

始点と終点が同じ街である道路や、始点と終点が同じ街である質問が含まれることもあります。

## 样例 #1

### 输入

```
5 5 3

1 2 1

1 2 2

3 4 1

4 5 1

3 5 2

5 3

1 2

3 1```

### 输出

```
-2

inf

nan```

## 样例 #2

### 输入

```
2 1 1

1 1 1

1 1```

### 输出

```
inf```

## 样例 #3

### 输入

```
9 7 5

3 1 4

1 5 9

2 6 5

3 5 8

9 7 9

3 2 3

8 4 6

2 6

4 3

3 8

3 2

7 9```

### 输出

```
inf

nan

nan

inf

-9```

# AI分析结果

### 题目内容重写

#### 题目描述

有编号为 $1,\ldots,N$ 的 $N$ 个城市和编号为 $1,\ldots,M$ 的 $M$ 条道路。道路 $i$ 连接城市 $A_i$ 和 $B_i$。通过道路时，所持有的**点数**会按照以下规则增减：

- 使用道路 $i$ 从城市 $A_i$ 移动到城市 $B_i$ 时，点数增加 $C_i$；
- 使用道路 $i$ 从城市 $B_i$ 移动到城市 $A_i$ 时，点数减少 $C_i$。

点数可以为负数。

接下来有 $Q$ 个询问，每个询问要求回答：从城市 $X_i$ 出发，初始点数为 $0$，到达城市 $Y_i$ 时，所持有的点数的最大值。如果无法从 $X_i$ 到达 $Y_i$，则输出 `nan`；如果可以在 $Y_i$ 时持有无限大的点数，则输出 `inf`。

#### 输入格式

第一行包含三个整数 $N, M, Q$，表示城市数量、道路数量和询问数量。接下来 $M$ 行，每行包含三个整数 $A_i, B_i, C_i$，表示一条道路。最后 $Q$ 行，每行包含两个整数 $X_i, Y_i$，表示一个询问。

#### 输出格式

对于每个询问，输出一个整数或字符串，表示答案。

#### 数据范围

- $2 \leq N \leq 10^5$
- $0 \leq M \leq 10^5$
- $1 \leq Q \leq 10^5$
- $1 \leq A_i, B_i, X_i, Y_i \leq N$
- $0 \leq C_i \leq 10^9$

#### 样例

**样例 1**

输入：
```
5 5 3
1 2 1
1 2 2
3 4 1
4 5 1
3 5 2
5 3
1 2
3 1
```

输出：
```
-2
inf
nan
```

**样例 2**

输入：
```
2 1 1
1 1 1
1 1
```

输出：
```
inf
```

### 算法分类

图论

### 题解分析与结论

该题的核心在于判断两点之间的路径是否存在，以及是否存在正环。如果两点不在同一个连通块中，则输出 `nan`；如果两点在同一个连通块中且存在正环，则输出 `inf`；否则，输出两点之间的路径权值。

#### 关键思路

1. **连通性判断**：使用并查集或 DFS 判断两点是否在同一个连通块中。
2. **正环判断**：通过 DFS 遍历连通块，若发现某点的距离不唯一，则说明存在正环。
3. **路径权值计算**：若不存在正环，则两点之间的路径权值唯一，可以通过 DFS 计算得到。

#### 最优思路

- **DFS 遍历**：通过 DFS 遍历每个连通块，记录每个点的距离。若发现某点的距离不唯一，则标记该连通块存在正环。
- **并查集**：用于快速判断两点是否在同一个连通块中。

### 精选题解

#### 题解 1：CarroT1212 (5星)

**关键亮点**：
- 通过 DFS 遍历连通块，记录每个点的距离，并判断是否存在正环。
- 使用并查集快速判断两点是否在同一个连通块中。
- 代码简洁，思路清晰。

**核心代码**：
```cpp
void dfs(ll pos) {
    co[pos] = coid; // 记连通块编号
    for (pll i : v[pos]) {
        ll x = i.first, y = i.second;
        if (!vis[x]) dis[x] = dis[pos] + y, vis[x] = 1, dfs(x);
        else if (dis[x] != dis[pos] + y) isnf[coid] = 1; // 存在不相等路径，则有正环
    }
}
```

#### 题解 2：StudyingFather (4星)

**关键亮点**：
- 利用图的特殊性质，简化了正环的判断。
- 通过 DFS 记录每个点的距离，并判断是否存在正环。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
void dfs(int u) {
    vis[u] = true;
    for (auto ed : e[u]) {
        int v = ed.first, w = ed.second;
        if (vis[v]) {
            if (dis[v] != dis[u] + w) inf[ds.find(u)] = true;
        } else {
            dis[v] = dis[u] + w;
            dfs(v);
        }
    }
}
```

#### 题解 3：PineappleSummer (4星)

**关键亮点**：
- 通过 DFS 遍历连通块，记录每个点的距离，并判断是否存在正环。
- 使用并查集快速判断两点是否在同一个连通块中。
- 代码简洁，思路清晰。

**核心代码**：
```cpp
void dfs(int u) {
    c[u] = col;
    for (auto [v, w] : G[u]) {
        if (!vis[v]) dis[v] = dis[u] + w, vis[v] = 1, dfs(v);
        else if (dis[v] != dis[u] + w) f[col] = 1;
    }
}
```

### 关键思路总结

- **DFS 遍历**：通过 DFS 遍历连通块，记录每个点的距离，并判断是否存在正环。
- **并查集**：用于快速判断两点是否在同一个连通块中。
- **正环判断**：若发现某点的距离不唯一，则标记该连通块存在正环。

### 拓展思路

- **类似题目**：可以扩展到其他图论问题，如最短路径、负环判断等。
- **优化**：可以考虑使用 Tarjan 算法进行强连通分量分解，进一步优化正环的判断。

### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)
3. [P2863 [USACO06JAN]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)

---
处理用时：51.95秒
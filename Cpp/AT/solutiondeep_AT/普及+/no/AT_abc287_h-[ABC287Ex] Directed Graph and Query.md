# 题目信息

# [ABC287Ex] Directed Graph and Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc287/tasks/abc287_h

$ N $ 頂点 $ M $ 辺の有向グラフがあります。頂点には $ 1 $ から $ N $ までの番号が付いており、$ i $ 番目の有向辺は頂点 $ a_i $ から頂点 $ b_i $ へと結ばれています。

また、このグラフ上の経路について、コストを次のように定めます。

- 経路上の頂点(始点・終点を含む)の番号の最大値
 
$ x=1,2,\ldots,Q $ に対して次の問題を解いてください。

- 頂点 $ s_x $ から頂点 $ t_x $ への経路のコストの最小値を求めよ。ただし、そのような経路が一つも存在しない場合は代わりに `-1` と出力せよ。
 
なお、入力の量が多くなる場合があるので、高速な方法で入出力を行うことを推奨します。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2000 $
- $ 0\ \leq\ M\ \leq\ N(N-1) $
- $ 1\ \leq\ a_i,b_i\ \leq\ N $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば $ (a_i,b_i)\ \neq\ (a_j,b_j) $
- $ 1\ \leq\ Q\ \leq\ 10^4 $
- $ 1\ \leq\ s_i,t_i\ \leq\ N $
- $ s_i\ \neq\ t_i $
- 入力はすべて整数
 
### Sample Explanation 1

$ x=1 $ に対しては、$ 1 $ 番目の辺を通って頂点 $ 1 $ から頂点 $ 2 $ へ行く経路のコストが $ 2 $ であり、これが最小です。 $ x=2 $ に対しては、$ 2 $ 番目の辺を通って頂点 $ 2 $ から頂点 $ 3 $ へ、そして $ 3 $ 番目の辺を通って頂点 $ 3 $ から頂点 $ 1 $ へ行く経路のコストが $ 3 $ であり、これが最小です。 $ x=3 $ に対しては、頂点 $ 1 $ から頂点 $ 4 $ への経路が存在しないため `-1` と出力します。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 1

4 3

3

1 2

2 1

1 4```

### 输出

```
2

3

-1```

# AI分析结果

### 题目翻译

#### [ABC287Ex] 有向图与查询

#### 题目描述

给定一个包含 $N$ 个顶点和 $M$ 条边的有向图。顶点编号从 $1$ 到 $N$，第 $i$ 条有向边连接顶点 $a_i$ 到顶点 $b_i$。

此外，定义路径的**成本**为路径上所有顶点（包括起点和终点）编号的最大值。

对于 $x=1,2,\ldots,Q$，回答以下问题：

- 找到从顶点 $s_x$ 到顶点 $t_x$ 的路径的最小成本。如果不存在这样的路径，则输出 `-1`。

由于输入量可能较大，建议使用快速的方法进行输入输出。

#### 说明/提示

##### 约束条件

- $2 \leq N \leq 2000$
- $0 \leq M \leq N(N-1)$
- $1 \leq a_i, b_i \leq N$
- $a_i \neq b_i$
- 如果 $i \neq j$，则 $(a_i, b_i) \neq (a_j, b_j)$
- $1 \leq Q \leq 10^4$
- $1 \leq s_i, t_i \leq N$
- $s_i \neq t_i$
- 输入均为整数

##### 样例解释 1

对于 $x=1$，路径 $1 \rightarrow 2$ 的成本为 $2$，这是最小的。  
对于 $x=2$，路径 $2 \rightarrow 3 \rightarrow 1$ 的成本为 $3$，这是最小的。  
对于 $x=3$，不存在从 $1$ 到 $4$ 的路径，因此输出 `-1`。

##### 样例输入

```
4 4

1 2

2 3

3 1

4 3

3

1 2

2 1

1 4
```

##### 样例输出

```
2

3

-1
```

### 算法分类
图论

### 题解分析与结论

#### 综合分析

本题的核心问题是在有向图中找到从 $s_x$ 到 $t_x$ 的路径，且路径上顶点的最大编号最小。这是一个典型的图论问题，涉及到路径的最优化和传递闭包的计算。

#### 题解对比

1. **rui_er (4星)**：
   - **关键亮点**：使用Floyd算法结合bitset优化传递闭包，外层循环枚举中转点 $k$，并在每次更新后检查询问是否首次连通。
   - **代码实现**：通过bitset优化传递闭包，复杂度为 $O(\frac{n^3}{\omega})$。
   - **个人心得**：无。

2. **CmsMartin (4星)**：
   - **关键亮点**：同样使用Floyd算法和bitset优化，外层枚举 $k$，并在每次更新后检查询问是否首次连通。
   - **代码实现**：与rui_er类似，复杂度为 $O(\frac{n^3}{\omega} + nq)$。
   - **个人心得**：无。

3. **small_john (4星)**：
   - **关键亮点**：思路清晰，使用Floyd算法和bitset优化，外层枚举 $k$，并在每次更新后检查询问是否首次连通。
   - **代码实现**：与前述题解类似，复杂度为 $O(\frac{n^3}{\omega} + nq)$。
   - **个人心得**：无。

#### 最优关键思路

- **Floyd算法**：通过枚举中转点 $k$，逐步更新传递闭包，确保路径上顶点的最大编号最小。
- **bitset优化**：利用bitset的高效位运算，显著降低传递闭包的计算复杂度。

#### 可拓展之处

- **类似问题**：可以扩展到无向图或带权图的最短路径问题，结合不同的优化策略。
- **算法套路**：Floyd算法结合bitset优化，适用于需要计算传递闭包或全源最短路的场景。

#### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)

### 核心代码片段

```cpp
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        if (e[i].test(k)) e[i] |= e[k];
    }
    for (int i = 1; i <= q; i++) {
        if (e[s[i]].test(t[i]) && ans[i] == -1) ans[i] = max({s[i], t[i], k});
    }
}
```

这段代码实现了Floyd算法的核心逻辑，结合bitset优化，逐步更新传递闭包，并在每次更新后检查询问是否首次连通，从而得到最小成本。

---
处理用时：38.36秒
# 题目信息

# [ABC290E] Make it Palindrome

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc290/tasks/abc290_e

数列 $ X $ に対し、 $ f(X)\ = $ ( $ X $ を回文にするために変更する必要のある要素の個数の最小値 ) とします。

与えられた長さ $ N $ の数列 $ A $ の全ての **連続** 部分列 $ X $ に対する $ f(X) $ の総和を求めてください。

但し、長さ $ m $ の数列 $ X $ が回文であるとは、全ての $ 1\ \le\ i\ \le\ m $ を満たす整数 $ i $ について、 $ X $ の $ i $ 項目と $ m+1-i $ 項目が等しいことを指します。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ N $
 
### Sample Explanation 1

\- $ f(5)\ =\ 0 $ - $ f(2)\ =\ 0 $ - $ f(1)\ =\ 0 $ - $ f(2)\ =\ 0 $ - $ f(2)\ =\ 0 $ - $ f(5,2)\ =\ 1 $ - $ f(2,1)\ =\ 1 $ - $ f(1,2)\ =\ 1 $ - $ f(2,2)\ =\ 0 $ - $ f(5,2,1)\ =\ 1 $ - $ f(2,1,2)\ =\ 0 $ - $ f(1,2,2)\ =\ 1 $ - $ f(5,2,1,2)\ =\ 2 $ - $ f(2,1,2,2)\ =\ 1 $ - $ f(5,2,1,2,2)\ =\ 1 $ 以上より、求める答えは $ 9 $ です。

## 样例 #1

### 输入

```
5

5 2 1 2 2```

### 输出

```
9```

# AI分析结果

【题目翻译】
# [ABC290E] 使其成为回文

## 题目描述

对于数列 $X$，定义 $f(X)$ 为使 $X$ 成为回文序列所需的最小修改次数。

给定一个长度为 $N$ 的数列 $A$，求其所有**连续**子序列 $X$ 的 $f(X)$ 的总和。

其中，长度为 $m$ 的数列 $X$ 是回文的，当且仅当对于所有 $1 \le i \le m$，$X$ 的第 $i$ 项与第 $m+1-i$ 项相等。

## 说明/提示

### 约束

- 输入均为整数
- $1 \le N \le 2 \times 10^5$
- $1 \le A_i \le N$

### 样例解释 1

- $f(5) = 0$
- $f(2) = 0$
- $f(1) = 0$
- $f(2) = 0$
- $f(2) = 0$
- $f(5,2) = 1$
- $f(2,1) = 1$
- $f(1,2) = 1$
- $f(2,2) = 0$
- $f(5,2,1) = 1$
- $f(2,1,2) = 0$
- $f(1,2,2) = 1$
- $f(5,2,1,2) = 2$
- $f(2,1,2,2) = 1$
- $f(5,2,1,2,2) = 1$

因此，答案为 $9$。

## 样例 #1

### 输入

```
5
5 2 1 2 2
```

### 输出

```
9
```

【算法分类】
数学、双指针

【题解分析与结论】
该题的核心思路是通过双指针和数学优化，计算所有连续子序列的回文修改次数总和。大多数题解都采用了“正难则反”的策略，即先计算所有可能的贡献，再减去不需要修改的部分（即相同元素对的贡献）。

【高星题解】
1. **作者：_JellyFish_ (5星)**
   - **关键亮点**：通过双指针和数学公式优化，将时间复杂度降低到 $O(n)$，代码简洁且高效。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=n;i++){
         ans+=(n-i+1)*(i/2); // 计算所有线的数量
         int l=0,r=V[i].size()-1;
         while(l<r){
             ans-=(r-l)*min(V[i][l],n+1-V[i][r]); // 减去好线的数量
             (V[i][l]<(n+1-V[i][r]))?l++:r--; // 双指针移动
         }
     }
     ```

2. **作者：ダ月 (4星)**
   - **关键亮点**：详细解释了双指针的移动策略，并通过数学推导优化了计算过程。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=n;i++){
         int l=0,r=b[i].size()-1;
         while(l<r){
             if(b[i][l]<n+1-b[i][r]) ans+=(r-l)*b[i][l],l++;
             else ans+=(r-l)*(n+1-b[i][r]),r--;
         }
     }
     ```

3. **作者：2huk (4星)**
   - **关键亮点**：通过双指针和前缀和优化，详细解释了如何计算好线对答案的贡献。
   - **代码核心**：
     ```cpp
     for(auto e : s){
         int l = 0, r = v[e].size() - 1;
         while(l < r){
             int ll = v[e][l], rr = v[e][r];
             int x = ll, y = n - rr + 1;
             if(x < y){
                 res -= (r - l) * x;
                 l++;
             } else {
                 res -= (r - l) * y;
                 r--;
             }
         }
     }
     ```

【最优关键思路】
1. **双指针优化**：通过双指针快速计算相同元素对的贡献，避免了暴力枚举的低效。
2. **数学公式**：利用数学公式计算所有可能的贡献，再减去不需要修改的部分，简化了问题。

【拓展思路】
类似的问题可以通过双指针和数学优化来解决，例如计算数组中所有子数组的某种性质的总和。

【推荐题目】
1. [洛谷 P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [洛谷 P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [洛谷 P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：36.81秒
# 题目信息

# [ABC291F] Teleporter and Closed off

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc291/tasks/abc291_f

$ N $ 個の都市があり、都市 $ 1 $, 都市 $ 2 $, $ \ldots $, 都市 $ N $ と番号づけられています。  
いくつかの異なる都市の間は一方通行のテレポーターによって移動できます。 都市 $ i $ $ (1\leq\ i\leq\ N) $ からテレポーターによって直接移動できる都市は `0` と `1` からなる長さ $ M $ の文字列 $ S_i $ によって表されます。具体的には、$ 1\leq\ j\leq\ N $ に対して、

- $ 1\leq\ j-i\leq\ M $ かつ $ S_i $ の $ (j-i) $ 文字目が `1` ならば、都市 $ i $ から都市 $ j $ に直接移動できる。
- そうでない時、都市 $ i $ から都市 $ j $ へは直接移動できない。

$ k=2,3,\ldots,\ N-1 $ に対して次の問題を解いてください。

> テレポータを繰り返し使用することによって、**都市 $ k $ を通らずに**都市 $ 1 $ から 都市 $ N $ へ移動できるか判定し、 できるならばそのために必要なテレポーターの使用回数の最小値を、 できないならば $ -1 $ を出力せよ。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 10^5 $
- $ 1\leq\ M\leq\ 10 $
- $ M\ <\ N $
- $ S_i $ は `0` と `1` のみからなる長さ $ M $ の文字列
- $ i+j\ >\ N $ ならば $ S_i $ の $ j $ 文字目は `0`
- $ N,M $ は整数

### Sample Explanation 1

テレポータによって各都市からはそれぞれ以下の都市へ直接移動する事ができます。 - 都市 $ 1 $ からは都市 $ 2,3 $ へ移動できる。 - 都市 $ 2 $ からは都市 $ 4 $ へ移動できる。 - 都市 $ 3 $ からは都市 $ 4,5 $ へ移動できる。 - 都市 $ 4 $ からは都市 $ 5 $ へ移動できる。 - 都市 $ 5 $ から移動できる都市は存在しない。 よって、都市 $ 1 $ から都市 $ 5 $ へ移動する方法は、 - 経路 $ 1 $ : 都市 $ 1 $ $ \to $ 都市 $ 2 $ $ \to $ 都市 $ 4 $ $ \to $ 都市 $ 5 $ - 経路 $ 2 $ : 都市 $ 1 $ $ \to $ 都市 $ 3 $ $ \to $ 都市 $ 4 $ $ \to $ 都市 $ 5 $ - 経路 $ 3 $ : 都市 $ 1 $ $ \to $ 都市 $ 3 $ $ \to $ 都市 $ 5 $ の $ 3 $ つがあり、 - 都市 $ 2 $ を通らない経路は経路 $ 2 $, 経路 $ 3 $ の $ 2 $つであり、そのうちテレポーターの使用回数が最小となるのは経路 $ 3 $ で、この時 $ 2 $ 回使用する。 - 都市 $ 3 $ を通らない経路は経路 $ 1 $ のみであり、この時テレポーターは $ 3 $ 回使用する。 - 都市 $ 4 $ を通らない経路は経路 $ 3 $ のみであり、この時テレポーターは $ 2 $ 回使用する。 となります。よって、$ 2,3,2 $ をこの順に空白区切りで出力します。

### Sample Explanation 2

都市 $ 1 $ から都市 $ 6 $ へ移動する方法は、都市 $ 1 $ $ \to $ 都市 $ 2 $ $ \to $ 都市 $ 5 $ $ \to $ 都市 $ 6 $ のみであるため、 $ k=2,5 $ の場合には都市 $ k $ を通らずに都市 $ 1 $ から都市 $ 6 $ へ移動する方法は存在せず、 $ k=3,4 $ の場合には上の方法が条件をみたし、テレポーターを $ 3 $ 回使用します。 よって、$ -1,3,3,-1 $ をこの順に空白区切りで出力します。 テレポーターは一方通行であるため、 都市 $ 3 $ から都市 $ 4 $ へはテレポーターによって移動できますが、 都市 $ 4 $ から都市 $ 3 $ へは移動できず、 都市 $ 1 $ $ \to $ 都市 $ 4 $ $ \to $ 都市 $ 3 $ $ \to $ 都市 $ 6 $ のような移動はできない事に注意してください。

## 样例 #1

### 输入

```
5 2
11
01
11
10
00```

### 输出

```
2 3 2```

## 样例 #2

### 输入

```
6 3
101
001
101
000
100
000```

### 输出

```
-1 3 3 -1```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $N$ 个城市，编号为 $1, 2, \ldots, N$。  
某些不同的城市之间可以通过单向的传送器进行移动。城市 $i$（$1 \leq i \leq N$）可以通过传送器直接移动到其他城市的信息由一个长度为 $M$ 的由 `0` 和 `1` 组成的字符串 $S_i$ 表示。具体来说，对于 $1 \leq j \leq N$：

- 如果 $1 \leq j - i \leq M$ 且 $S_i$ 的第 $(j - i)$ 个字符为 `1`，则可以从城市 $i$ 直接移动到城市 $j$。
- 否则，不能从城市 $i$ 直接移动到城市 $j$。

对于 $k = 2, 3, \ldots, N - 1$，请解决以下问题：

> 通过重复使用传送器，**不经过城市 $k$** 从城市 $1$ 移动到城市 $N$ 是否可行？如果可行，输出所需的最少传送器使用次数；如果不可行，输出 $-1$。

#### 说明/提示

##### 约束

- $3 \leq N \leq 10^5$
- $1 \leq M \leq 10$
- $M < N$
- $S_i$ 是由 `0` 和 `1` 组成的长度为 $M$ 的字符串
- 如果 $i + j > N$，则 $S_i$ 的第 $j$ 个字符为 `0`
- $N, M$ 是整数

### 算法分类

最短路

### 题解分析与结论

#### 综合分析

题目要求对于每个 $k$，找到从城市 $1$ 到城市 $N$ 的最短路径，且该路径不经过城市 $k$。由于 $N$ 的范围较大（$10^5$），直接使用暴力搜索或动态规划会超时。因此，需要利用 $M$ 较小的特点进行优化。

#### 题解对比

1. **iiiiiyang 的题解**（5星）
   - **亮点**：通过 BFS 预处理从 $1$ 到每个城市的最短路径和从每个城市到 $N$ 的最短路径，然后枚举不经过 $k$ 的路径，时间复杂度为 $O(nm^2)$，利用 $M$ 较小的特点进行优化。
   - **代码实现**：使用 BFS 进行预处理，然后枚举 $j$ 和 $k$ 计算最短路径。

2. **CrTsIr400 的题解**（4星）
   - **亮点**：采用 DP 思想，预处理从 $1$ 到每个城市的最短路径和从每个城市到 $N$ 的最短路径，然后枚举不经过 $k$ 的路径，时间复杂度为 $O(nm^2)$。
   - **代码实现**：使用 DP 进行预处理，然后枚举 $j$ 和 $k$ 计算最短路径。

3. **mi_Y13c 的题解**（4星）
   - **亮点**：预处理从 $1$ 到每个城市的最短路径和从每个城市到 $N$ 的最短路径，然后枚举不经过 $k$ 的路径，时间复杂度为 $O(nm^2)$。
   - **代码实现**：使用 DP 进行预处理，然后枚举 $j$ 和 $k$ 计算最短路径。

#### 最优关键思路

1. **预处理最短路径**：通过 BFS 或 DP 预处理从 $1$ 到每个城市的最短路径和从每个城市到 $N$ 的最短路径。
2. **枚举不经过 $k$ 的路径**：利用 $M$ 较小的特点，枚举 $j$ 和 $k$ 计算最短路径，时间复杂度为 $O(nm^2)$。

#### 代码实现

```cpp
// BFS 预处理
void bfs(int dir) {
    if (!dir) q.push(1), dis[1][0] = 0;
    else q.push(n), dis[n][1] = 0;
    while (!q.empty()) {
        int now = q.front(); q.pop();
        for (int i = head[now]; i; i = e[i].nex) {
            int to = e[i].to;
            if (dis[to][dir] > dis[now][dir] + 1)
                dis[to][dir] = dis[now][dir] + 1, q.push(to);
        }
    }
}

// 计算不经过 k 的最短路径
for (int i = 2; i < n; ++i) {
    ans = INF;
    for (int j = max(1ll, i - m + 1); j < i; ++j)
        for (int k = 1; k <= m; ++k)
            if (j + k > i && s[j][k - 1] == '1')
                ans = min(ans, dis[j][0] + dis[j + k][1] + 1);
    if (ans == INF) cout << -1 << " ";
    else cout << ans << " ";
}
```

#### 拓展思路

类似的问题可以出现在图论中的最短路径问题，尤其是需要排除某些节点或边的情况。可以通过预处理和枚举的方式优化时间复杂度。

#### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

#### 个人心得

- **调试经历**：在预处理时需要注意边界条件，特别是 $j + k > i$ 的情况，避免数组越界。
- **顿悟感想**：利用 $M$ 较小的特点进行优化，可以显著降低时间复杂度，适合处理大规模数据。

---
处理用时：41.97秒
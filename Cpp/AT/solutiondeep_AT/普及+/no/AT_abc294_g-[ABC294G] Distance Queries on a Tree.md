# 题目信息

# [ABC294G] Distance Queries on a Tree

## 题目描述

给定一颗有 $n$ 个节点的树，带边权，要进行 $Q$ 次操作，操作有两种：

`1 i w`：将第 $i$ 条边的边权改为 $w$。  
`2 u v`：询问 $u,v$ 两点的距离。

## 说明/提示

$1\le n,Q\le 2\times10^5，1\le w_i\le 10^9$

## 样例 #1

### 输入

```
5
1 2 3
1 3 6
1 4 9
4 5 10
4
2 2 3
2 1 5
1 3 1
2 1 5```

### 输出

```
9
19
11```

## 样例 #2

### 输入

```
7
1 2 1000000000
2 3 1000000000
3 4 1000000000
4 5 1000000000
5 6 1000000000
6 7 1000000000
3
2 1 6
1 1 294967296
2 1 6```

### 输出

```
5000000000
4294967296```

## 样例 #3

### 输入

```
1
1
2 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
8
1 2 105
1 3 103
2 4 105
2 5 100
5 6 101
3 7 106
3 8 100
18
2 2 8
2 3 6
1 4 108
2 3 4
2 3 5
2 5 5
2 3 1
2 4 3
1 1 107
2 3 1
2 7 6
2 3 8
2 1 5
2 7 6
2 4 7
2 1 7
2 5 3
2 8 6```

### 输出

```
308
409
313
316
0
103
313
103
525
100
215
525
421
209
318
519```

# AI分析结果

### 题目翻译
# [ABC294G] 树上的距离查询

## 题目描述

给定一颗有 $n$ 个节点的树，带边权，要进行 $Q$ 次操作，操作有两种：

`1 i w`：将第 $i$ 条边的边权改为 $w`。  
`2 u v`：询问 $u,v$ 两点的距离。

## 说明/提示

$1\le n,Q\le 2\times10^5，1\le w_i\le 10^9$

### 算法分类
树状数组

### 综合分析与结论
该题目要求在一棵树上进行边权修改和两点距离查询操作。由于树的结构特性，路径唯一，因此可以通过维护每个点到根节点的距离来实现快速查询。常用的方法包括树链剖分、DFS序+树状数组等。题解中主要采用了DFS序结合树状数组的方法，通过将子树转化为区间，利用树状数组进行区间修改和单点查询，从而高效地处理操作。

### 所选高分题解
#### 题解1：rui_er (5星)
**关键亮点**：
- 使用DFS序将子树转化为区间，利用树状数组维护每个点的深度。
- 通过LCA计算两点距离，公式为 `dis(u,v) = dep(u) + dep(v) - 2 * dep(LCA(u,v))`。
- 代码简洁高效，时间复杂度为 `O((n+q)log n)`。

**核心代码**：
```cpp
void dfs(int u, int f) {
    fa[u][0] = f;
    rep(i, 1, 18) fa[u][i] = fa[fa[u][i-1]][i-1];
    dis[u] = dis[f] + 1;
    dfn[u] = ++tms;
    sz[u] = 1;
    for(auto i : e[u]) {
        ll v, w, id;
        tie(v, w, id) = i;
        if(v != f) {
            dfs(v, u);
            sz[u] += sz[v];
            bottom[id] = v;
            bit.add(dfn[v], w);
            bit.add(dfn[v]+sz[v], -w);
        }
    }
}
```

#### 题解2：Pengzt (4星)
**关键亮点**：
- 使用DFS序将树转化为序列，利用线段树维护深度。
- 通过LCA计算两点距离，思路清晰，代码结构良好。
- 时间复杂度为 `O(n log n + q log n)`。

**核心代码**：
```cpp
void dfs(int u, int f) {
    fa[u][0] = f;
    rep(i, 1, 18) fa[u][i] = fa[fa[u][i-1]][i-1];
    dis[u] = dis[f] + 1;
    dfn[u] = ++tms;
    sz[u] = 1;
    for(auto i : e[u]) {
        ll v, w, id;
        tie(v, w, id) = i;
        if(v != f) {
            dfs(v, u);
            sz[u] += sz[v];
            bottom[id] = v;
            bit.add(dfn[v], w);
            bit.add(dfn[v]+sz[v], -w);
        }
    }
}
```

#### 题解3：dayz_break404 (4星)
**关键亮点**：
- 使用树剖+线段树维护边权，将边权转化为点权。
- 通过树剖实现路径查询，代码结构清晰，易于理解。
- 时间复杂度为 `O(q log^2 n)`。

**核心代码**：
```cpp
void dfs1(int x, int f) {
    fa[x] = f;
    dep[x] = dep[f] + 1;
    siz[x] = 1;
    int big = 0;
    for(int i = head[x]; i; i = edg[i].nxt) {
        int y = edg[i].to;
        if(y == f) continue;
        dfs1(y, x);
        siz[x] += siz[y];
        if(siz[y] > big) {
            big = siz[y];
            son[x] = y;
        }
    }
}
```

### 关键思路与技巧
1. **DFS序+树状数组**：通过DFS序将子树转化为区间，利用树状数组进行区间修改和单点查询，适用于子树操作。
2. **LCA计算距离**：通过LCA计算两点距离，公式为 `dis(u,v) = dep(u) + dep(v) - 2 * dep(LCA(u,v))`，适用于树结构中的路径查询。
3. **树剖+线段树**：将边权转化为点权，通过树剖实现路径查询，适用于复杂树结构操作。

### 拓展与举一反三
1. **类似题目**：
   - [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
   - [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
   - [P3038 [USACO11DEC]Grass Planting G](https://www.luogu.com.cn/problem/P3038)

2. **调试与顿悟**：
   - **调试经历**：在实现树剖时，容易忽略边权转点权的细节，导致查询结果错误。通过仔细检查每个节点的权值赋值，确保正确性。
   - **顿悟感想**：树剖虽然代码较长，但在处理复杂树结构时非常高效，尤其是路径查询和修改操作。

### 个人心得
- **调试经历**：在实现树剖时，容易忽略边权转点权的细节，导致查询结果错误。通过仔细检查每个节点的权值赋值，确保正确性。
- **顿悟感想**：树剖虽然代码较长，但在处理复杂树结构时非常高效，尤其是路径查询和修改操作。

---
处理用时：42.75秒
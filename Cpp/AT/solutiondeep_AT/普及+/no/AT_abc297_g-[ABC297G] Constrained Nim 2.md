# 题目信息

# [ABC297G] Constrained Nim 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc297/tasks/abc297_g

$ N $ 個の石の山があり、はじめ $ i $ 番目の山には石が $ A_i $ 個あります。これらの山を使って先手太郎君と後手次郎君でゲームをします。

先手太郎君と後手次郎君は、先手太郎君が先手で交互に以下の操作を行います。

- 石の山を一つ選び、そこから $ L $ 個以上 $ R $ 個以下の石を取り除く。

操作が行えなくなった方が負けで、負けなかった方が勝ちです。両者が勝ちを目指して最適な行動を取るとき、どちらが勝つか判定してください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ L\ \leq\ R\ \leq\ 10^9 $
- $ 1\leq\ A_i\ \leq\ 10^9 $
- 入力はすべて整数である。

### Sample Explanation 1

先手太郎君が最初に $ 1 $ 番目の山の石を $ 2 $ 個取り除くことで、必ず勝つことができます。

## 样例 #1

### 输入

```
3 1 2
2 3 3```

### 输出

```
First```

## 样例 #2

### 输入

```
5 1 1
3 1 4 1 5```

### 输出

```
Second```

## 样例 #3

### 输入

```
7 3 14
10 20 30 40 50 60 70```

### 输出

```
First```

# AI分析结果

### 题目内容重写
【题目描述】
有 $N$ 堆石子，初始时第 $i$ 堆有 $A_i$ 个石子。先手太郎君和后手次郎君轮流进行操作，每次可以从一堆石子中取走 $L$ 到 $R$ 个石子。无法进行操作的一方输掉游戏，另一方获胜。双方都采取最优策略，判断谁会获胜。

【输入格式】
第一行包含三个整数 $N, L, R$，表示石子的堆数和每次取石子的范围。
第二行包含 $N$ 个整数 $A_i$，表示每堆石子的初始数量。

【输出格式】
输出 "First" 或 "Second"，表示先手或后手获胜。

【样例】
```
3 1 2
2 3 3
```
输出：
```
First
```

【说明/提示】
- $1 \leq N \leq 2 \times 10^5$
- $1 \leq L \leq R \leq 10^9$
- $1 \leq A_i \leq 10^9$

### 算法分类
数学、组合数学

### 题解分析与结论
该题的核心在于计算每堆石子的SG函数，并通过异或操作判断最终胜负。题解中给出的SG函数公式为：
$$\operatorname{SG}(X) = \left\lfloor\dfrac{X \bmod \left(L + R\right)}{L}\right\rfloor$$

该公式的推导基于对石子数量的周期性分析，通过模运算和除法操作，简化了SG函数的计算。最终，将所有堆的SG值异或起来，若结果大于0，则先手必胜，否则后手必胜。

### 题解评分与亮点
#### 题解：User_Authorized
- **星级**：5星
- **关键亮点**：
  - 详细推导了SG函数的公式，并通过数学归纳法证明了其正确性。
  - 代码简洁高效，直接应用了推导出的公式，避免了复杂的计算。
  - 提供了清晰的思路和完整的证明过程，易于理解。

### 核心代码实现
```cpp
#include <bits/stdc++.h>

typedef long long valueType;
typedef std::vector<valueType> ValueVector;

int main() {
    valueType N, L, R;

    std::cin >> N >> L >> R;

    valueType SG = 0;

    for (valueType i = 0; i < N; ++i) {
        valueType A;

        std::cin >> A;

        SG ^= (A % (L + R)) / L;
    }

    if (SG > 0)
        std::cout << "First" << std::endl;
    else
        std::cout << "Second" << std::endl;

    return 0;
}
```

### 关键思路与技巧
- **SG函数的周期性**：通过模运算将石子数量限制在一个周期内，简化了SG函数的计算。
- **异或操作**：将所有堆的SG值异或起来，快速判断胜负。
- **数学归纳法**：通过归纳法证明了SG函数的正确性，确保了算法的可靠性。

### 拓展思路
- **类似题目**：可以扩展到其他取石子游戏，如每次取石子的范围不同，或者有多个取石子的规则。
- **优化思路**：对于更大的数据范围，可以考虑进一步优化SG函数的计算，或者使用更高效的算法。

### 推荐题目
1. [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)
2. [P1288 取石子游戏](https://www.luogu.com.cn/problem/P1288)
3. [P1290 取石子游戏](https://www.luogu.com.cn/problem/P1290)

---
处理用时：23.96秒
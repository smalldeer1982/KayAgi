# 题目信息

# [ABC298E] Unfair Sugoroku

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc298/tasks/abc298_e

高橋君と青木君がすごろくをします。  
 高橋君ははじめ地点 $ A $、青木君ははじめ地点 $ B $ にいて、交互にサイコロを振ります。  
 高橋君が振るサイコロは $ 1,\ 2,\ \ldots,\ P $ の出目が一様ランダムに出るサイコロで、青木君が振るサイコロは $ 1,\ 2,\ \ldots,\ Q $ の出目が一様ランダムに出るサイコロです。  
 地点 $ x $ にいるときに自分の振ったサイコロの出目が $ i $ であるとき、地点 $ \min(x\ +\ i,\ N) $ に進みます。  
 地点 $ N $ に先に着いた人をすごろくの勝者とします。  
 高橋君が先にサイコロを振るとき、高橋君が勝つ確率を $ \text{mod\ }998244353 $ で求めてください。

 確率 $ \text{mod\ }998244353 $ とは この問題で求める確率は必ず有理数になることが証明できます。また、この問題の制約下では、求める確率を既約分数 $ \frac{y}{x} $ で表したときに $ x $ が $ 998244353 $ で割り切れないことが保証されます。  
 このとき $ xz\ \equiv\ y\ \pmod\ {998244353} $ を満たすような $ 0 $ 以上 $ 998244352 $ 以下の整数 $ z $ が一意に定まります。この $ z $ を答えてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ A,\ B\ <\ N $
- $ 1\ \leq\ P,\ Q\ \leq\ 10 $
- 入力はすべて整数
 
### Sample Explanation 1

高橋君が最初の手番で $ 2 $ あるいは $ 3 $ の出目を出すと、高橋君は地点 $ 4 $ に進んで高橋君が勝利します。 高橋君が最初の手番で $ 1 $ の出目を出すと、高橋君は地点 $ 3 $ に進み、青木君は次の手番で必ず地点 $ 4 $ に進んで青木君が勝利します。 よって、高橋君が勝つ確率は $ \frac{2}{3} $ です。

### Sample Explanation 2

サイコロの出目は常に $ 1 $ です。 このとき高橋君が地点 $ 5 $ に進み、次いで青木君が地点 $ 3 $ に進み、次いで高橋君が地点 $ 6 $ に進むので、高橋君は必ず勝ちます。

## 样例 #1

### 输入

```
4 2 3 3 2```

### 输出

```
665496236```

## 样例 #2

### 输入

```
6 4 2 1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
100 1 1 10 10```

### 输出

```
264077814```

# AI分析结果

### 题目内容重写
高桥君和青木君在玩一个不公平的骰子游戏。高桥君初始位于位置 $A$，青木君初始位于位置 $B$，两人轮流掷骰子。高桥君的骰子有 $P$ 个面，分别标有 $1, 2, \ldots, P$，青木君的骰子有 $Q$ 个面，分别标有 $1, 2, \ldots, Q$。每次掷骰子后，玩家会移动到 $\min(x + i, N)$ 的位置，其中 $x$ 是当前位置，$i$ 是骰子的点数。先到达位置 $N$ 的玩家获胜。高桥君先掷骰子，求高桥君获胜的概率，结果对 $998244353$ 取模。

### 算法分类
动态规划、概率论

### 题解综合分析与结论
本题的核心是使用动态规划（DP）来计算高桥君获胜的概率。由于游戏的状态由两人的位置和当前轮到谁掷骰子决定，因此大多数题解都采用了三维DP的状态表示，即 $dp_{i,j,k}$，其中 $i$ 和 $j$ 分别表示高桥君和青木君的位置，$k$ 表示当前轮到谁掷骰子。转移方程则根据骰子的点数进行概率加权。

### 所选高星题解

#### 题解1：作者：liangbowen (5星)
**关键亮点**：
- 使用了三维DP状态 $dp_{t,i,j}$，表示第 $t$ 回合时高桥君在 $i$ 位置，青木君在 $j$ 位置的概率。
- 通过刷表法进行状态转移，代码清晰易读。
- 使用了逆元来处理概率的除法运算，避免了浮点数精度问题。

**核心代码**：
```cpp
int dp[105][105][105]; //dp[t][i][j] : 第t回合，Tak在i位置，Aok在j位置，概率 
int main() {
    int n, a, b, p, q, ans = 0;
    cin >> n >> a >> b >> p >> q;
    int inv = 1ll * qpow(p) * qpow(q) % mod;
    
    dp[0][a][b] = 1;
    for (int t = 1; t <= n; t++)
        for (int i = a; i < n; i++)
            for (int j = b; j < n; j++)
                for (int sti = 1; sti <= p; sti++)
                    for (int stj = 1; stj <= q; stj++)
                        dp[t][min(n, i + sti)][min(n, j + stj)] = (dp[t][min(n, i + sti)][min(n, j + stj)] + 1ll * inv * dp[t - 1][i][j] % mod) % mod;
    for (int t = 1; t <= n; t++)
            for (int j = b; j <= n; j++)
                ans = (ans + dp[t][n][j]) % mod;
    cout << ans;
    return 0;
}
```

#### 题解2：作者：_Ad_Astra_ (4星)
**关键亮点**：
- 使用了二维DP状态 $dp_{i,j}$，表示高桥君在 $i$ 位置，青木君在 $j$ 位置的概率。
- 通过枚举骰子的点数进行状态转移，代码简洁。
- 同样使用了逆元来处理概率的除法运算。

**核心代码**：
```cpp
int dp[110][110], ans;
int main() {
    cin >> n >> a >> b >> p >> q;
    dp[a][b] = 1;
    for (int i = a; i < n; i++)
        for (int j = b; j < n; j++)
            for (int l1 = 1; l1 <= p; l1++)
                for (int l2 = 1; l2 <= q; l2++)
                    dp[min(i + l1, n)][min(j + l2, n)] = (dp[min(i + l1, n)][min(j + l2, n)] + dp[i][j] * quickpow(p, mod - 2) % mod * quickpow(q, mod - 2) % mod) % mod;
    for (int i = 1; i <= n; i++) ans = (ans + dp[n][i]) % mod;
    cout << ans;
    return 0;
}
```

#### 题解3：作者：六楼溜刘 (4星)
**关键亮点**：
- 使用了三维DP状态 $dp_{i,j,k}$，表示高桥君在 $i$ 位置，青木君在 $j$ 位置，且当前轮到谁掷骰子的概率。
- 通过倒序DP进行状态转移，避免了重复计算。
- 使用了逆元来处理概率的除法运算。

**核心代码**：
```cpp
ll dp[N][N][2];
int main() {
    n=read();a=read();b=read();p=read();q=read();
    dp[a][b][1]=1;
    ll invp=ksm(p,mod-2),invq=ksm(q,mod-2);
    forup(i,a,n-1){
        forup(j,b,n-1){
            forup(k,0,1){
                if(dp[i][j][k]==0) continue;
                if(k){
                    forup(num,1,p){
                        dp[min(i+num,n)][j][0]=(dp[min(i+num,n)][j][0]+dp[i][j][1]*invp%mod)%mod;
                    }
                }else{
                    forup(num,1,q){
                        dp[i][min(j+num,n)][1]=(dp[i][min(j+num,n)][1]+dp[i][j][0]*invq%mod)%mod;
                    }
                }
            }
        }
    }
    int ans=0;
    forup(i,b,n){
        ans=(ans+dp[n][i][0])%mod;
    }
    printf("%lld",ans);
}
```

### 最优关键思路或技巧
1. **三维DP状态**：使用 $dp_{i,j,k}$ 来表示游戏状态，其中 $k$ 表示当前轮到谁掷骰子，这样可以避免状态混乱。
2. **逆元处理概率**：在模运算下，使用逆元来处理概率的除法运算，避免了浮点数精度问题。
3. **倒序DP**：通过倒序DP进行状态转移，可以避免重复计算，提高效率。

### 可拓展之处
类似的问题可以扩展到多个玩家或多个骰子的情况，或者骰子的点数分布不均匀的情况。此外，可以结合其他概率论知识，如期望值计算，来进一步扩展问题。

### 推荐题目
1. [P1654 OSU!](https://www.luogu.com.cn/problem/P1654)
2. [P1850 换教室](https://www.luogu.com.cn/problem/P1850)
3. [P2473 [SCOI2008]奖励关](https://www.luogu.com.cn/problem/P2473)

---
处理用时：49.98秒
# 题目信息

# [ABC298F] Rook Score

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc298/tasks/abc298_f

縦 $ 10^9 $ マス、横 $ 10^9 $ マスのマス目があります。上から $ i $ 番目、左から $ j $ 番目のマスを $ (i,j) $ と表記します。

$ i=1,2,\ldots,N $ に対し $ (r_i,c_i) $ には正整数 $ x_i $ が、他の $ 10^{18}-N $ 個のマスには $ 0 $ が書かれています。

あなたはあるマス $ (R,C) $ を選び、 $ (R,C) $ と行または列が同じ $ 2\ \times\ 10^9\ -\ 1 $ 個のマスに書かれた整数の総和 $ S $ を求めました。

$ S $ として考えられる最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ r_i,c_i,x_i\ \leq\ 10^9 $
- $ i\ \neq\ j $ ならば $ (r_i,c_i)\ \neq\ (r_j,c_j) $
- 入力はすべて整数

### Sample Explanation 1

$ (R,C) $ として $ (2,2) $ を選ぶと $ S $ が $ 20 $ となります。これが最大値です。

## 样例 #1

### 输入

```
4
1 1 2
1 2 9
2 1 8
3 2 3```

### 输出

```
20```

## 样例 #2

### 输入

```
1
1 1000000000 1```

### 输出

```
1```

## 样例 #3

### 输入

```
15
158260522 877914575 602436426
24979445 861648772 623690081
433933447 476190629 262703497
211047202 971407775 628894325
731963982 822804784 450968417
430302156 982631932 161735902
880895728 923078537 707723857
189330739 910286918 802329211
404539679 303238506 317063340
492686568 773361868 125660016
650287940 839296263 462224593
492601449 384836991 191890310
576823355 782177068 404011431
818008580 954291757 160449218
155374934 840594328 164163676```

### 输出

```
1510053068```

# AI分析结果

### 题目内容重写
#### [ABC298F] Rook Score

**题目描述**

有一个 $10^9 \times 10^9$ 的网格。$(r_i, c_i)$ 的位置上写着 $x_i$，其余位置为 $0$。

找到一个点 $(x, y)$，使得 $x$ 行的数字与 $y$ 行的数字之和最大（重复计算的要只算一次）。求出最大值。

**样例输入输出**

```input1
4
1 1 2
1 2 9
2 1 8
3 2 3
```

```output1
20
```

**数据范围**

$1 \le N \le 2 \times 10^5,\ 1 \le r_i,c_i,x_i \le 10^9$

### 算法分类
贪心

### 题解分析与结论

#### 综合分析
本题的核心在于如何高效地计算每一行和每一列的总和，并找到一个点 $(R, C)$，使得该点所在行和列的总和减去该点的值最大。由于数据范围较大，直接暴力枚举会超时，因此需要采用贪心策略和高效的数据结构来优化。

#### 关键思路与技巧
1. **数据结构选择**：使用 `unordered_map` 来存储每一行和每一列的总和，使用 `map` 来存储每个点的值。
2. **贪心策略**：将行和列的总和从大到小排序，优先选择总和较大的行和列。如果在某个点 $(R, C)$ 的值为 $0$，则可以直接更新答案并跳出循环，因为后续的行和列的总和不会更大。
3. **优化**：通过排序和贪心策略，减少不必要的枚举，提高算法效率。

#### 所选高分题解
1. **作者：2huk (赞：6)**
   - **星级：5星**
   - **关键亮点**：详细介绍了如何使用 `unordered_map` 和 `map` 来存储数据，并通过排序和贪心策略优化算法。代码清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     for (auto _r : r)
         for (auto _c : c)
             if (mp.find({_r.second, _c.second}) == mp.end())
             {
                 ans = max(ans, _r.first + _c.first);
                 break;
             }
             else ans = max(ans, _r.first + _c.first - mp[{_r.second, _c.second}]);
     ```
   - **个人心得**：通过贪心策略和排序，大大减少了枚举的次数，提高了算法的效率。

2. **作者：Meickol (赞：0)**
   - **星级：4星**
   - **关键亮点**：通过降序排序行和列的总和，优先选择较大的总和，并在遇到值为 $0$ 的点时跳出循环，优化了算法。
   - **核心代码**：
     ```cpp
     for (auto x : vecx) {
         for (auto y : vecy) {
             LL t = x.first + y.first - p[x.second][y.second];
             ans = max(ans, t);
             if (!p[x.second][y.second]) break;
         }
     }
     ```
   - **个人心得**：通过贪心策略和排序，减少了不必要的枚举，提高了算法的效率。

3. **作者：RedStoneShark (赞：1)**
   - **星级：4星**
   - **关键亮点**：使用 `unordered_map` 和 `map` 来存储数据，并通过排序和贪心策略优化算法。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     for (auto [x,y] : vel) {
         for (auto [xx,yy] : vec) {
             if (mp.find({y,yy}) == mp.end()) { ans = max(ans, x + xx); break; }
             else ans = max(ans, x + xx - mp[{y,yy}]);
         }
     }
     ```
   - **个人心得**：通过贪心策略和排序，减少了不必要的枚举，提高了算法的效率。

### 拓展思路
类似的问题可以通过贪心策略和高效的数据结构来优化，例如在计算矩阵中的最大值或最小值时，可以采用类似的思路。此外，对于大规模数据的处理，排序和贪心策略是非常有效的优化手段。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

---
处理用时：31.74秒
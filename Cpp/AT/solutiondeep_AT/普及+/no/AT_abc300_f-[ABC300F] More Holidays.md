# 题目信息

# [ABC300F] More Holidays

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc300/tasks/abc300_f

`o` と `x` からなる長さ $ N $ の文字列 $ S $ と、整数 $ M,K $ が与えられます。  
$ S $ には少なくとも $ 1 $ つの `x` が含まれることが保証されます。

$ S $ を $ M $ 個連結して得られる長さ $ NM $ の文字列を $ T $ とします。 $ T $ に含まれる `x` のうち丁度 $ K $ 個を選んで `o` に変えることを考えます。  
あなたの目標は、変更後の $ T $ に `o` のみからなるできるだけ長い連続部分文字列が含まれるようにすることです。  
`o` のみからなる連続部分文字列の長さとして達成可能な最大値を求めてください。

## 说明/提示

### 制約

- $ N,M,K $ は整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ 1\ \le\ M\ \le\ 10^9 $
- $ x $ を文字列 $ T $ に含まれる `x` の総数としたとき、 $ 1\ \le\ K\ \le\ x $
- $ S $ は `o` と `x` からなる長さ $ N $ の文字列
- $ S $ には少なくとも $ 1 $ つの `x` が含まれる

### Sample Explanation 1

$ S= $ `ooxxooooox` 、 $ T= $ `ooxxooooox` です。 $ 3 $ 文字目と $ 4 $ 文字目の `x` を `o` に変更することにより、変更後の $ T= $ `ooooooooox` となります。 このとき `o` のみからなる長さ $ 9 $ の連続部分文字列が得られ、これが達成可能な最大値です。

### Sample Explanation 2

$ S= $ `oxxox` 、 $ T= $ `oxxoxoxxoxoxxox` です。 $ 5,7,8,10 $ 文字目の `x` を `o` に変更することにより、変更後の $ T= $ `oxxooooooooxxox` となります。 このとき `o` のみからなる長さ $ 8 $ の連続部分文字列が得られ、これが達成可能な最大値です。

## 样例 #1

### 输入

```
10 1 2
ooxxooooox```

### 输出

```
9```

## 样例 #2

### 输入

```
5 3 4
oxxox```

### 输出

```
8```

## 样例 #3

### 输入

```
30 1000000000 9982443530
oxoxooxoxoxooxoxooxxxoxxxooxox```

### 输出

```
19964887064```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个由字符 `o` 和 `x` 组成的长度为 $N$ 的字符串 $S$，以及整数 $M$ 和 $K$。  
$S$ 中至少包含一个 `x`。

将 $S$ 重复连接 $M$ 次，得到长度为 $NM$ 的字符串 $T$。考虑将 $T$ 中恰好 $K$ 个 `x` 替换为 `o`，目标是使得替换后的 $T$ 中包含尽可能长的由 `o` 组成的连续子串。  
求这个最长连续子串的长度。

**说明/提示**

**约束条件**

- $N, M, K$ 是整数
- $1 \le N \le 3 \times 10^5$
- $1 \le M \le 10^9$
- $x$ 为字符串 $T$ 中 `x` 的总数，且 $1 \le K \le x$
- $S$ 是由 `o` 和 `x` 组成的长度为 $N$ 的字符串
- $S$ 中至少包含一个 `x`

**样例解释**

**样例 1**

输入：
```
10 1 2
ooxxooooox
```
输出：
```
9
```
解释：$S= $ `ooxxooooox`，$T= $ `ooxxooooox`。将第 3 和第 4 个字符 `x` 替换为 `o`，得到 $T= $ `ooooooooox`，此时最长的连续 `o` 子串长度为 9。

**样例 2**

输入：
```
5 3 4
oxxox
```
输出：
```
8
```
解释：$S= $ `oxxox`，$T= $ `oxxoxoxxoxoxxox`。将第 5、7、8、10 个字符 `x` 替换为 `o`，得到 $T= $ `oxxooooooooxxox`，此时最长的连续 `o` 子串长度为 8。

### 算法分类
二分、前缀和

### 题解分析与结论

#### 综合分析
本题的核心问题是在一个由 $S$ 重复 $M$ 次得到的字符串 $T$ 中，通过替换 $K$ 个 `x` 为 `o`，使得 $T$ 中最长的连续 `o` 子串尽可能长。由于 $M$ 可能非常大，直接处理 $T$ 是不可行的，因此需要利用 $S$ 的重复特性进行优化。

大多数题解都采用了二分查找和前缀和的思路，通过枚举左端点，利用二分查找确定右端点的最大位置，使得该区间内的 `x` 数量不超过 $K$。部分题解还使用了双指针优化，进一步提高了效率。

#### 最优关键思路
1. **前缀和优化**：通过预处理 $S$ 的前缀和，快速计算任意区间内的 `x` 数量。
2. **二分查找**：枚举左端点，利用二分查找确定右端点的最大位置，使得区间内的 `x` 数量不超过 $K$。
3. **双指针优化**：在二分查找的基础上，利用双指针进一步优化时间复杂度。

#### 可拓展之处
- 类似的问题可以扩展到其他字符替换或区间查询的场景。
- 前缀和和二分查找的组合在字符串处理中非常常见，可以用于解决多种区间查询问题。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3382 【模板】线段树 1](https://www.luogu.com.cn/problem/P3382)

### 高星题解

#### 题解1：linyihdfj (5星)
**关键亮点**：
- 使用了双指针优化，将时间复杂度从 $O(n \log n)$ 降低到 $O(n)$。
- 详细解释了如何通过拼接 $S$ 来处理前缀和后缀的问题。

**代码核心实现**：
```cpp
for(int l=1,r = 1; l<=n; l++){
    while(r + 1 <= 2 * n && pre[r + 1] <= k + pre[l-1]) ++r;
    if(m == 1) tmp = max(tmp,min(r,n) - l + 1);
    else if(m > 1) tmp = max(tmp,r - l + 1);
}
```
**核心思想**：通过双指针维护一个窗口，使得窗口内的 `x` 数量不超过 $K$，并更新最大长度。

#### 题解2：xpz0525 (4星)
**关键亮点**：
- 通过预处理 $S$ 的前缀和，快速计算任意区间内的 `x` 数量。
- 详细解释了如何通过二分查找确定右端点的最大位置。

**代码核心实现**：
```cpp
ll pre(ll p){
    ll count = p/n;
    return count*ps[n] + ps[p%n];
}
```
**核心思想**：通过前缀和快速计算任意位置之前的 `x` 数量，结合二分查找确定最大右端点。

#### 题解3：Genius_Star (4星)
**关键亮点**：
- 使用了滑动窗口的思路，结合二分查找确定最大长度。
- 详细解释了如何通过滑动窗口维护区间内的 `x` 数量。

**代码核心实现**：
```cpp
for(int i=1;i<=n;i++){
    ll pos=(k-(ps[n]-ps[i-1]) + ps[n]-1)/ps[n]+1;
    ll l=i, r=m*n, res;
    while(l<=r){
        ll mid=(l+r)/2;
        ll xcnt=pre(mid)-pre(i-1);
        if(xcnt<k) l=mid+1;
        else if(xcnt>k) r=mid-1;
        else res=mid, l=mid+1;
    }
    ans=max(ans,res-i+1);
}
```
**核心思想**：通过二分查找确定右端点的最大位置，使得区间内的 `x` 数量不超过 $K$，并更新最大长度。

---
处理用时：37.43秒
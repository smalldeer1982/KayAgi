# 题目信息

# [ABC302F] Merge Set

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc302/tasks/abc302_f

黒板に $ 1 $ 以上 $ M $ 以下の整数からなる集合 $ N $ 個 $ S_1,S_2,\dots,S_N $ が書かれています。ここで、$ S_i\ =\ \lbrace\ S_{i,1},S_{i,2},\dots,S_{i,A_i}\ \rbrace $ です。

あなたは、以下の操作を好きな回数（$ 0 $ 回でもよい）行うことが出来ます。

- $ 1 $ 個以上の共通した要素を持つ $ 2 $ 個の集合 $ X,Y $ を選ぶ。$ X,Y $ の $ 2 $ 個を黒板から消し、新たに $ X\cup\ Y $ を黒板に書く。
 
ここで、$ X\cup\ Y $ とは $ X $ か $ Y $ の少なくともどちらかに含まれている要素のみからなる集合を意味します。

$ 1 $ と $ M $ が両方含まれる集合を作ることが出来るか判定してください。出来るならば、必要な操作回数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 2\ \le\ M\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ \sum_{i=1}^{N}\ A_i\ \le\ 5\ \times\ 10^5 $
- $ 1\ \le\ S_{i,j}\ \le\ M(1\ \le\ i\ \le\ N,1\ \le\ j\ \le\ A_i) $
- $ S_{i,j}\ \neq\ S_{i,k}(1\ \le\ j\ <\ k\ \le\ A_i) $
- 入力は全て整数である。
 
### Sample Explanation 1

まず、$ \lbrace\ 1,2\ \rbrace $ と $ \lbrace\ 2,3\ \rbrace $ を選んで消し、$ \lbrace\ 1,2,3\ \rbrace $ を追加します。 そして、$ \lbrace\ 1,2,3\ \rbrace $ と $ \lbrace\ 3,4,5\ \rbrace $ を選んで消し、$ \lbrace\ 1,2,3,4,5\ \rbrace $ を追加します。 すると $ 2 $ 回の操作で $ 1 $ と $ M $ を両方含む集合を作ることが出来ます。$ 1 $ 回の操作では目標を達成できないため、答えは $ 2 $ です。

### Sample Explanation 2

始めから $ S_1 $ が $ 1,M $ を共に含むため、必要な操作回数の最小値は $ 0 $ 回です。

## 样例 #1

### 输入

```
3 5

2

1 2

2

2 3

3

3 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
1 2

2

1 2```

### 输出

```
0```

## 样例 #3

### 输入

```
3 5

2

1 3

2

2 4

3

2 4 5```

### 输出

```
-1```

## 样例 #4

### 输入

```
4 8

3

1 3 5

2

1 2

3

2 4 7

4

4 6 7 8```

### 输出

```
2```

# AI分析结果

### 题目重写
#### [ABC302F] Merge Set

**题目描述**

黑板上写有 $N$ 个集合 $S_1, S_2, \dots, S_N$，每个集合包含 $1$ 到 $M$ 之间的整数。其中，$S_i = \{ S_{i,1}, S_{i,2}, \dots, S_{i,A_i} \}$。

你可以进行以下操作任意次（包括零次）：

- 选择两个有至少一个共同元素的集合 $X$ 和 $Y$，将它们从黑板上擦去，并新写上一个集合 $X \cup Y$。

这里，$X \cup Y$ 表示包含 $X$ 或 $Y$ 中至少一个元素的所有元素的集合。

请判断是否能够创建一个同时包含 $1$ 和 $M$ 的集合。如果可以，请计算所需的最小操作次数。

**说明/提示**

**约束条件**

- $1 \le N \le 2 \times 10^5$
- $2 \le M \le 2 \times 10^5$
- $1 \le \sum_{i=1}^{N} A_i \le 5 \times 10^5$
- $1 \le S_{i,j} \le M$（$1 \le i \le N$, $1 \le j \le A_i$）
- $S_{i,j} \neq S_{i,k}$（$1 \le j < k \le A_i$）
- 输入均为整数。

**样例解释 1**

首先，选择 $\{1, 2\}$ 和 $\{2, 3\}$ 进行合并，得到 $\{1, 2, 3\}$。然后，选择 $\{1, 2, 3\}$ 和 $\{3, 4, 5\}$ 进行合并，得到 $\{1, 2, 3, 4, 5\}$。这样，经过两次操作，得到了一个同时包含 $1$ 和 $M$ 的集合。由于一次操作无法达成目标，因此答案为 $2$。

**样例解释 2**

初始时，$S_1$ 已经同时包含 $1$ 和 $M$，因此所需的最小操作次数为 $0$。

**样例 #1**

**输入**

```
3 5

2

1 2

2

2 3

3

3 4 5
```

**输出**

```
2
```

**样例 #2**

**输入**

```
1 2

2

1 2
```

**输出**

```
0
```

**样例 #3**

**输入**

```
3 5

2

1 3

2

2 4

3

2 4 5
```

**输出**

```
-1
```

**样例 #4**

**输入**

```
4 8

3

1 3 5

2

1 2

3

2 4 7

4

4 6 7 8
```

**输出**

```
2
```

### 算法分类
图论、最短路

### 题解分析与结论
该题的核心思路是将集合和元素之间的关系转化为图论中的最短路问题。通过将集合和元素分别作为图中的节点，并建立相应的边，最终通过求解从包含元素 $1$ 的集合到包含元素 $M$ 的集合的最短路径来得到最小操作次数。

### 精选题解
1. **作者：2huk (赞：11)**  
   **星级：5星**  
   **关键亮点：**  
   - 将集合和元素分别作为图中的节点，构建二分图，通过 BFS 求解最短路。
   - 详细解释了如何通过二分图优化建图，避免了直接建图的高复杂度。
   - 代码简洁，思路清晰，优化程度高。

   **核心代码：**
   ```cpp
   // 建图部分
   for (int i = 1; i <= n; i++) {
       int len; cin >> len;
       while (len--) {
           int x; cin >> x;
           add(i, n + x, 0);
           add(n + x, i, 1);
       }
   }
   // BFS 求解最短路
   int bfs(int s, int t) {
       queue<int> q;
       q.push(s);
       memset(dis, 0x3f, sizeof(dis));
       dis[s] = 0;
       while (!q.empty()) {
           int u = q.front(); q.pop();
           for (int i = h[u]; i; i = nxt[i]) {
               int v = to[i], w = val[i];
               if (dis[v] > dis[u] + w) {
                   dis[v] = dis[u] + w;
                   q.push(v);
               }
           }
       }
       return dis[t];
   }
   ```

2. **作者：Svemit (赞：8)**  
   **星级：4星**  
   **关键亮点：**  
   - 使用 Dijkstra 算法求解最短路，代码实现较为规范。
   - 通过边权为 0 和 1 的边来模拟集合合并的过程，思路清晰。

   **核心代码：**
   ```cpp
   void dijkstra(int s) {
       for(int i = 1;i <= n + m;i ++) dist[i] = INF, st[i] = false;
       priority_queue<PII, vector<PII>, greater<PII> > q;
       dist[s] = 0;
       q.push({0, s});
       while(q.size()) {
           int u = q.top().second; q.pop();
           if(st[u]) continue;
           st[u] = true;
           for(int i = h[u];i;i = nxt[i]) {
               int v = to[i], w = val[i];
               if(dist[v] > dist[u] + w) {
                   dist[v] = dist[u] + w;
                   q.push({dist[v], v});
               }
           }
       }
   }
   ```

3. **作者：Leaper_lyc (赞：5)**  
   **星级：4星**  
   **关键亮点：**  
   - 使用菊花结构优化建图，避免了直接建图的高复杂度。
   - 通过边权为 0 和 1 的边来模拟集合合并的过程，思路清晰。

   **核心代码：**
   ```cpp
   void dij(int s) {
       while (!q.empty()) q.pop();
       memset(dis, 0x3f, sizeof(dis));
       dis[s] = 0; q.push(make_pair(0, s));
       while (!q.empty()) {
           int u = q.top().second; q.pop();
           for (int i = 0, v, w; i < (int)g[u].size(); i++) {
               v = g[u][i].first, w = g[u][i].second;
               if (dis[v] > dis[u] + w) {
                   dis[v] = dis[u] + w;
                   q.push(make_pair(-dis[v], v));
               }
           }
       }
   }
   ```

### 最优关键思路
1. **二分图建模**：将集合和元素分别作为图中的节点，通过边权为 0 和 1 的边来模拟集合合并的过程，避免了直接建图的高复杂度。
2. **最短路算法**：通过 BFS 或 Dijkstra 算法求解从包含元素 $1$ 的集合到包含元素 $M$ 的集合的最短路径，得到最小操作次数。

### 拓展思路
类似的问题可以通过图论中的最短路算法来解决，尤其是在涉及到集合合并、元素覆盖等场景时，二分图建模是一个常用的优化手段。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得总结
- **调试经历**：在实现过程中，需要注意边权的设置，确保边权的分配能够正确反映集合合并的代价。
- **踩坑教训**：直接建图会导致时间复杂度过高，因此需要通过二分图建模来优化。
- **顿悟感想**：通过将集合和元素分别作为图中的节点，可以有效地将问题转化为图论中的最短路问题，从而简化问题的求解过程。

---
处理用时：56.37秒
# 题目信息

# [ABC302G] Sort from 1 to 4

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc302/tasks/abc302_g

全ての要素が $ 1 $ 以上 $ 4 $ 以下の整数である、長さ $ N $ の数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられます。

高橋君は次の操作を何回でも ($ 0 $ 回でも良い) 繰り返し行う事ができます。

- $ 1\leq\ i\ <\ j\leq\ N $ をみたす整数の組 $ (i,j) $ を選び、$ A_i $ と $ A_j $ を交換する。
 
数列 $ A $ を広義単調増加にするために必要な操作回数の最小値を求めてください。  
 ただし、数列 $ A $ が広義単調増加であるとは、$ 1\leq\ i\leq\ N-1 $ をみたすすべての整数について $ A_i\leq\ A_{i+1} $ が成り立つことをさします。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 4 $
- 入力はすべて整数
 
### Sample Explanation 1

次のようにして $ 3 $ 回の操作で $ A $ を広義単調増加にすることができます。 - $ (i,j)=(2,3) $ を選び、$ A_2 $ と $ A_3 $ を交換する。$ A=(3,1,4,1,2,4) $ となる。 - $ (i,j)=(1,4) $ を選び、$ A_1 $ と $ A_4 $ を交換する。$ A=(1,1,4,3,2,4) $ となる。 - $ (i,j)=(3,5) $ を選び、$ A_3 $ と $ A_5 $ を交換する。$ A=(1,1,2,3,4,4) $ となる。 $ 2 $ 回以下の操作で $ A $ を広義単調増加にすることはできないため、このとき操作回数が最小となります。 よって、$ 3 $ を出力します。

## 样例 #1

### 输入

```
6

3 4 1 1 2 4```

### 输出

```
3```

## 样例 #2

### 输入

```
4

2 3 4 1```

### 输出

```
3```

# AI分析结果

### 题目重写
给定一个长度为 \( N \) 的数列 \( A=(A_1,A_2,\ldots,A_N) \)，其中每个元素都是介于 \( 1 \) 到 \( 4 \) 之间的整数。高桥君可以进行任意次数的交换操作，每次操作可以选择两个位置 \( i \) 和 \( j \) 并交换 \( A_i \) 和 \( A_j \)。问最少需要多少次交换操作才能使数列 \( A \) 变为非递减序列。

### 算法分类
贪心、排序

### 题解分析与结论
该题的核心思路是通过统计每个数在最终序列中的位置，然后通过交换操作将数列调整为非递减序列。大多数题解都采用了贪心的策略，优先处理能够通过一次交换解决两个位置问题的情形，然后处理需要多次交换的情形。

### 评分较高的题解

#### 题解1：Ratio_Y (5星)
**关键亮点**：
- 通过统计每个数在最终序列中的位置，构建了一个二维数组 \( to[i][j] \) 表示数 \( i \) 应该出现在数 \( j \) 的位置的次数。
- 优先处理大小为2的环（即两个数互相占据对方的位置），然后处理大小为3和4的环。
- 通过找环的方式，将问题转化为图论中的环分解问题，优化了交换次数。

**核心代码**：
```cpp
for(int i=1;i<=4;i++) for(int j=i+1;j<=4;j++)
{
    int sum=min(to[i][j],to[j][i]);
    ans+=sum,to[i][j]-=sum,to[j][i]-=sum;
}
```

#### 题解2：zhengchenxi414 (4星)
**关键亮点**：
- 将序列划分为四个部分，分别统计每个部分中每个数的个数。
- 通过优先处理两两配对的情况，逐步将数列调整为非递减序列。
- 通过逐步归位的方式，减少了交换次数。

**核心代码**：
```cpp
for(int i=1;i<=4;i++)
{
    for(int j=1;j<=4;j++)
    {
        if(i==j) continue;
        if(s[i].cnt[j]&&s[j].cnt[i])
        {
            int x=min(s[i].cnt[j],s[j].cnt[i]);
            ans+=x;
            s[i].cnt[j]-=x; s[j].cnt[i]-=x;
            s[i].cnt[i]+=x; s[j].cnt[j]+=x;
        }
    }
}
```

#### 题解3：chlchl (4星)
**关键亮点**：
- 通过统计每个数在最终序列中的位置，构建了一个二维数组 \( cnt[i][j] \) 表示数 \( i \) 应该出现在数 \( j \) 的位置的次数。
- 优先处理两两交换的情况，然后处理三元交换和四元交换的情况。
- 通过逐步减少错误位置的数量，优化了交换次数。

**核心代码**：
```cpp
for(int i=1;i<=4;i++){
    for(int j=1;j<=4;j++){
        if(i == j) continue;
        while(cnt[i][j] && cnt[j][i])
            ++ans, tot -= 2, --cnt[i][j], --cnt[j][i];
    }
}
```

### 最优关键思路或技巧
1. **贪心策略**：优先处理能够通过一次交换解决两个位置问题的情形，然后处理需要多次交换的情形。
2. **环分解**：将问题转化为图论中的环分解问题，通过找环的方式优化交换次数。
3. **逐步归位**：通过逐步将数列调整为非递减序列，减少交换次数。

### 可拓展之处
类似的问题可以扩展到更大的数值范围或更复杂的交换规则，例如允许交换多个位置的元素或限制交换次数。

### 推荐题目
1. [P1459 三值的排序](https://www.luogu.com.cn/problem/P1459)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)

### 个人心得摘录
- **Ratio_Y**：通过找环的方式将问题转化为图论中的环分解问题，优化了交换次数。
- **zhengchenxi414**：通过逐步归位的方式，减少了交换次数，代码实现较为简洁。
- **chlchl**：优先处理两两交换的情况，然后处理三元交换和四元交换的情况，思路清晰。

---
处理用时：30.25秒
# 题目信息

# [ABC310D] Peaceful Teams

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc310/tasks/abc310_d

$ N $ 人のスポーツ選手がいます。

$ N $ 人の選手たちには互いに相性の悪い選手のペアが $ M $ 組あり、相性の悪い組のうち $ i\ (1\leq\ i\leq\ M) $ 組目は $ A\ _\ i $ 番目の選手と $ B\ _\ i $ 番目の選手です。

あなたは、選手を $ T $ チームに分けます。 どの選手もちょうど一つのチームに属さなければならず、どのチームにも少なくとも一人の選手が属さなければなりません。 さらに、どの $ i=1,2,\ldots,M $ についても、 $ A\ _\ i $ 番目の選手と $ B\ _\ i $ 番目の選手が同じチームに属していてはいけません。

この条件を満たすチーム分けの方法は何通りあるか求めてください。 ただし、チーム分けの方法が異なるとは、ある二人が存在して、彼らが一方のチーム分けでは同じチームに所属し、もう一方では異なるチームに所属することをいいます。

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ N\leq10 $
- $ 0\leq\ M\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ A\ _\ i\lt\ B\ _\ i\leq\ N\ (1\leq\ i\leq\ M) $
- $ (A\ _\ i,B\ _\ i)\neq\ (A\ _\ j,B\ _\ j)\ (1\leq\ i\lt\ j\leq\ M) $
- 入力はすべて整数
 
### Sample Explanation 1

次の $ 4 $ 通りのチーム分けが条件を満たします。 !\[\](https://img.atcoder.jp/abc310/b92c2629f68d56350fe18e6d0a8fa060.png) 他に条件を満たすチーム分けは存在しないので、$ 4 $ を出力してください。

### Sample Explanation 2

条件を満たすチーム分けがひとつも存在しないこともあります。

### Sample Explanation 3

相性の悪いペアがひとつも存在しないこともあります。

## 样例 #1

### 输入

```
5 2 2

1 3

3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
5 1 2

1 3

3 4```

### 输出

```
0```

## 样例 #3

### 输入

```
6 4 0```

### 输出

```
65```

## 样例 #4

### 输入

```
10 6 8

5 9

1 4

3 8

1 6

4 10

5 7

5 6

3 7```

### 输出

```
8001```

# AI分析结果

### 题目内容
$ N $ 名运动员需要被分成 $ T $ 个队伍。有 $ M $ 对运动员之间关系不好，不能分在同一队。求满足条件的分队方案数。

### 算法分类
搜索、剪枝

### 综合分析与结论
本题的核心是通过搜索枚举所有可能的分队方案，并利用剪枝优化搜索过程。由于 $ N $ 和 $ T $ 的范围较小（$1 \leq T \leq N \leq 10$），直接暴力搜索是可行的，但需要剪枝来减少不必要的枚举。以下是各题解的主要思路和优化点：

1. **剪枝优化**：大多数题解都采用了“剩余人数小于空队伍数时直接返回”的剪枝策略，有效减少了搜索空间。
2. **去重处理**：由于队伍是无序的，很多题解通过固定队伍的顺序或最后除以 $ T! $ 来避免重复计算。
3. **状态记录**：部分题解通过记录每个队伍的成员或使用状压来避免重复搜索。

### 所选高分题解

#### 题解1：Coffee_zzz (5星)
**关键亮点**：
- 使用了“剩余人数小于空队伍数”的剪枝策略，有效减少了搜索空间。
- 通过记录每个队伍的成员数来判断是否满足条件，代码简洁清晰。
- 最后通过除以 $ T! $ 来去除重复计算。

**核心代码**：
```cpp
void dfs(int pos, int now) {
    if (n - pos + 1 < t - now) return; // 剪枝
    if (pos == n + 1) {
        for (int i = 1; i <= m; i++) 
            if (num[a[i]] == num[b[i]]) return; // 检查冲突
        ans++;
        return;
    }
    for (int i = 1; i <= t; i++) {
        if (cnt[i]) {
            cnt[i]++;
            num[pos] = i;
            dfs(pos + 1, now);
            cnt[i]--;
        } else {
            cnt[i]++;
            num[pos] = i;
            dfs(pos + 1, now + 1);
            cnt[i]--;
        }
    }
}
```

#### 题解2：Lucky_Cloud (4星)
**关键亮点**：
- 使用了状压来记录队伍分配情况，避免了重复搜索。
- 通过优先选择度数较高的运动员进行分配，进一步优化了搜索顺序。

**核心代码**：
```cpp
void dfs(int x, int tm, ll num) {
    if (x == n + 1 && tm == t && !mps[num]) {
        ans++;
        mps[num] = 1;
        return;
    }
    if (t - tm < n - x + 1 && tm != 0) {
        for (int i = 1; i <= tm; i++) {
            if (!mp[i][x]) {
                for (int j = 0; j < v[x].size(); j++) mp[i][v[x][j]]++;
                num = num * 10 + i - 1;
                dfs(x + 1, tm, num);
                for (int j = 0; j < v[x].size(); j++) mp[i][v[x][j]]--;
                num /= 10;
            }
        }
    }
    if (tm == t) return;
    ++tm;
    for (int i = 0; i < v[x].size(); i++) mp[tm][v[x][i]]++;
    num = num * 10 + tm - 1;
    dfs(x + 1, tm, num);
    for (int i = 0; i < v[x].size(); i++) mp[tm][v[x][i]]--;
    num /= 10;
}
```

### 最优关键思路
- **剪枝策略**：在搜索过程中，如果剩余人数不足以填满空队伍，直接返回，避免无效搜索。
- **去重处理**：通过固定队伍顺序或最后除以 $ T! $ 来避免重复计算。

### 可拓展之处
- 类似的分组问题可以通过搜索加剪枝的方式解决，如分组背包、集合划分等。
- 状压DP也可以用于解决类似问题，尤其是在状态数较少的情况下。

### 推荐题目
1. [P1118 [USACO06FEB]Backward Digit Sums G/S](https://www.luogu.com.cn/problem/P1118)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1463 [POI2001][HAOI2007]反素数](https://www.luogu.com.cn/problem/P1463)

---
处理用时：29.86秒
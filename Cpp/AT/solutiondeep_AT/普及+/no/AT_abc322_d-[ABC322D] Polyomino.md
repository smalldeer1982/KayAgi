# 题目信息

# [ABC322D] Polyomino

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc322/tasks/abc322_d

いくつかの正方形を辺でつなげてできる、連結な多角形の形をしたパズルのピースのことを **ポリオミノ** と呼びます。

縦 $ 4 $ マス、横 $ 4 $ マスのグリッドと、グリッドに収まる大きさの $ 3 $ 個のポリオミノがあります。  
 $ i $ 番目のポリオミノの形は $ 16 $ 個の文字 $ P_{i,j,k} $ ($ 1\ \leq\ j,\ k\ \leq\ 4 $) によって表されます。$ P_{i,\ j,\ k} $ は何も置かれていないグリッドに $ i $ 番目のポリオミノを置いたときの状態を意味して、$ P_{i,\ j,\ k} $ が `#` の場合は上から $ j $ 行目、左から $ k $ 列目のマスにポリオミノが置かれていることを、`.` の場合は置かれていないことを意味します。(入出力例 $ 1 $ の図も参考にしてください。)

あなたは次の条件を全て満たすように $ 3 $ 個のポリオミノ全てをグリッドに敷き詰めることにしました。

- グリッドの全てのマスはポリオミノで覆われている。
- ポリオミノ同士が重なるように置くことはできない。
- ポリオミノがグリッドからはみ出るように置くことはできない。
- ポリオミノの平行移動と回転は自由に行うことができるが、裏返すことはできない。
 
条件を満たすようにグリッドにポリオミノを敷き詰めることは可能ですか？

## 说明/提示

### 制約

- $ P_{i,\ j,\ k} $ は `#` または `.`
- 与えられるポリオミノは連結である。つまり、ポリオミノを構成する正方形同士は、正方形のみを上下左右に辿って互いに行き来できる
- 与えられるポリオミノは空でない
 
### Sample Explanation 1

入力例 $ 1 $ に対応するポリオミノの形は次の図のようになります。 !\[image1\](https://img.atcoder.jp/abc322/f0e25c2abcdbeade76fcb12eaee39f23.jpg) この場合、次の図のようにポリオミノを配置することで、問題文の条件を満たすようにグリッドにポリオミノを敷き詰めることができます。 !\[image2\](https://img.atcoder.jp/abc322/81e983f85e958e0d612063adcc455c71.jpg) よって答えは `Yes` になります。

### Sample Explanation 2

入力例 $ 2 $ の $ 1 $ 番目のポリオミノのように、ポリオミノは穴の空いた多角形の形をしている場合があります。

### Sample Explanation 3

ポリオミノを敷き詰めるときに、ポリオミノを裏返してはならないのに注意してください。

## 样例 #1

### 输入

```
....

###.

.#..

....

....

.###

.##.

....

..#.

.##.

.##.

.##.```

### 输出

```
Yes```

## 样例 #2

### 输入

```
###.

#.#.

##..

....

....

..#.

....

....

####

##..

#...

#...```

### 输出

```
Yes```

## 样例 #3

### 输入

```
##..

#..#

####

....

....

##..

.##.

....

.#..

.#..

.#..

.#..```

### 输出

```
No```

## 样例 #4

### 输入

```
....

..#.

....

....

....

..#.

....

....

....

..#.

....

....```

### 输出

```
No```

## 样例 #5

### 输入

```
....

####

#...

#...

....

####

...#

..##

....

..##

..#.

..##```

### 输出

```
No```

## 样例 #6

### 输入

```
###.

.##.

..#.

.###

....

...#

..##

...#

....

#...

#...

#...```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写（中文）

有一个四行四列的网格，其中有三个适合于网格的多米诺骨牌。第 $i$ 个多米诺骨牌的形状由 $16$ 个字符 $P_{i,j,k}(1 \le j,k \le 4)$ 表示。它们描述了在将第 $i$ 个多米诺骨牌放置在网格上时的网格状态。如果 $P_{i,j,k}$ 是 `#`，则表示多米诺骨牌占据从上往下数第 $j$ 行、从左往右数第 $k$ 列的方格；如果是 `.`，则表示该方格未被占据。  
你想要用这三个多米诺骨牌填满网格，同时满足以下条件：
- 网格的所有方格都被多米诺骨牌覆盖。
- 多米诺骨牌之间不能重叠。
- 多米诺骨牌不能超出网格。
- 可以自由地平移和旋转多米诺骨牌，但不能翻转。

求是否可以用多米诺骨牌填满网格并满足这些条件？

### 算法分类
搜索、模拟

### 题解分析与结论

该题目要求将三个多米诺骨牌通过平移和旋转操作填充到一个4x4的网格中，且不能重叠或超出网格。由于网格较小，且多米诺骨牌的形状和位置有限，大多数题解采用了暴力搜索或枚举的方法。以下是对各题解的总结与对比：

1. **Tang_poetry_syndrome** 的题解通过深度优先搜索（DFS）枚举每个多米诺骨牌的旋转和平移位置，并检查是否满足条件。该题解思路清晰，代码简洁，但未进行明显的优化。
2. **small_john** 的题解同样采用DFS，但增加了对旋转和平移的详细处理，代码较为冗长，但逻辑清晰。
3. **Miss_SGT** 的题解通过状态压缩和位运算，将每个多米诺骨牌的状态预处理，最后通过枚举所有状态来判断是否满足条件。该题解思路新颖，代码简洁且高效。

### 评分较高的题解

#### 1. **Miss_SGT**（评分：5星）
- **关键亮点**：使用状态压缩和位运算，将每个多米诺骨牌的状态预处理，最后通过枚举所有状态来判断是否满足条件。代码简洁且高效。
- **个人心得**：通过状态压缩，大大减少了搜索空间，提高了效率。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x){
	int f=1;x=0;char c=getchar();
	while((c<'0'||'9'<c)&&c^'-') c=getchar();
	if(c=='-') f=-1,c=getchar();
	while('0'<=c&&c<='9') x=(x<<1)+(x<<3)+c-48,c=getchar();
	x*=f;
}
char s[3][5][5];
int z[3][100],cnt[3];
inline bool q_bit(int x,int y,int z){return (z>>((x-1)*4+y-1))&1;}
inline int g_bit(int x,int y){return 1<<((x-1)*4+y-1);}
inline int fan(int x){
	int ans=0;
	for(int i=1;i<=4;i++)
	for(int j=1;j<=4;j++)
		if(q_bit(i,j,x)) ans+=g_bit(j,5-i);
	return ans;
}
inline bool Ok(int x,int y){return 0<x&&x<=4&&0<y&&y<=4;}
void print(int x){
	for(int i=1;i<=4;i++,cout<<'\n')
	for(int j=1;j<=4;j++)
		cout<<q_bit(i,j,x);
}
inline void find(int k){
	bool ok;int h;
	for(int x=-3;x<=3;x++)
	for(int y=-3;y<=3;y++){
		ok=1;h=0;
		for(int i=1;i<=4&&ok;i++)
		for(int j=1;j<=4&&ok;j++)
			if(s[k][i][j]=='#'&&!Ok(i+x,j+y)) ok=0;
			else if(s[k][i][j]=='#') h+=g_bit(i+x,j+y);
		if(!ok) continue;
		for(int f=0;f<4;f++){
			z[k][++cnt[k]]=h;
			h=fan(h);
		}
	}
}
int main(){
	for(int i=0;i<3;i++)
	for(int j=1;j<=4;j++)
		scanf("%s",s[i][j]+1);
	for(int i=0;i<3;i++) find(i);
	for(int i=1;i<=cnt[0];i++)
	for(int j=1;j<=cnt[1];j++)
	for(int k=1;k<=cnt[2];k++){
		if(!(z[0][i]&z[1][j])&&!(z[1][j]&z[2][k])&&!(z[0][i]&z[2][k])&&
			((z[0][i]|z[1][j]|z[2][k])==(1<<16)-1)){
			puts("Yes");
			return 0;	
		}
	}
	puts("No");
	return 0;
}
```

#### 2. **Tang_poetry_syndrome**（评分：4星）
- **关键亮点**：通过DFS枚举每个多米诺骨牌的旋转和平移位置，并检查是否满足条件。代码简洁，思路清晰。
- **个人心得**：虽然未进行明显的优化，但代码逻辑清晰，易于理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define f(i,j,k) for(register int i=j;i<=k;++i)
#define g(i,j,k) for(register int i=j;i>=k;--i)
#define ll long long
const int N=1e5+10,INF=INT_MAX,Mod=998244353;
char x,mp[20][20];
bool ans=false;
int num,a[12][4][4],c[4][4];
void change(ll t){//将多米诺骨牌转向
	ll i,j;
	for(i=0;i<4;i++)for(j=0;j<4;j++)c[i][j]=a[t][j][3-i];
	for(i=0;i<4;i++)for(j=0;j<4;j++)a[t][i][j]=c[i][j];
}
void dfs(int step)
{
	if(step==3)
	{
		f(i,4,7)f(j,4,7)if(mp[i][j]!=1)return ;
		cout<<"Yes";
		exit(0);		
	}
	f(i,0,3)
	{
		f(j,1,7)f(k,1,7)
		{
			f(g,0,3)f(h,0,3)mp[j+g][k+h]+=a[step][g][h];
			dfs(step+1);
			f(g,0,3)f(h,0,3)mp[j+g][k+h]-=a[step][g][h];
		}
		change(step);
	}
		
		
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    f(i,0,2)
    	f(j,0,3)
    		f(k,0,3)
    			cin>>x,num+=a[i][j][k]=(x=='#');
    if(num==16)dfs(0);
    cout<<"No";
	return 0;
}
```

### 最优关键思路或技巧
- **状态压缩与位运算**：通过将每个多米诺骨牌的状态用二进制表示，可以大大减少搜索空间，提高效率。
- **DFS与剪枝**：通过深度优先搜索枚举所有可能的旋转和平移位置，并结合剪枝策略，可以有效减少不必要的计算。

### 可拓展之处
- **类似题目**：可以扩展到更大的网格或更多的多米诺骨牌，或者允许翻转操作。
- **优化思路**：可以进一步优化DFS的剪枝策略，或者使用启发式搜索来提高效率。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

---
处理用时：57.67秒
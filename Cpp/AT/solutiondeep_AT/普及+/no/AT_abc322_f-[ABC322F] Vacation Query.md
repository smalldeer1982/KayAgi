# 题目信息

# [ABC322F] Vacation Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc322/tasks/abc322_f

`0`, `1` からなる長さ $ N $ の文字列 $ S $ が与えられます。$ S $ の $ i $ 文字目を $ S_i $ とします。

$ Q $ 個のクエリを与えられた順に処理してください。  
 クエリは $ 3 $ 個の整数の組 $ (c,\ L,\ R) $ で表されて、$ c $ の値によってクエリの種類が異なります。

- $ c=1 $ のとき : $ L\ \leq\ i\ \leq\ R $ を満たす整数 $ i $ について、$ S_i $ が `1` ならば `0` に、`0` ならば `1` に変更する。
- $ c=2 $ のとき : $ S $ の $ L $ 文字目から $ R $ 文字目までを取り出して出来る文字列を $ T $ とする。$ T $ に含まれる連続する `1` の長さの最大値を出力する。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ S $ は長さ $ N $ の `0`, `1` からなる文字列
- $ c\ \in\ \lbrace\ 1,\ 2\ \rbrace $
- $ 1\ \leq\ L\ \leq\ R\ \leq\ N $
- $ N,\ Q,\ c,\ L,\ R $ は全て整数
 
### Sample Explanation 1

クエリを順に処理すると次のようになります。 - はじめ、$ S= $ `1101110` です。 - $ 1 $ 番目のクエリについて、$ T\ = $ `1101110` です。$ T $ に含まれる連続する `1` の中で最も長いものは、$ T $ の $ 4 $ 文字目から $ 6 $ 文字目からなる `111` なので、答えは $ 3 $ になります。 - $ 2 $ 番目のクエリについて、$ T\ = $ `101` です。$ T $ に含まれる連続する `1` の中で最も長いものは、$ T $ の $ 1 $ 文字目あるいは $ 3 $ 文字目の `1` なので、答えは $ 1 $ になります。 - $ 3 $ 番目のクエリについて、操作後の $ S $ は `1110000` です。 - $ 4 $ 番目のクエリについて、$ T\ = $ `00` です。$ T $ に `1` は含まれないので答えは $ 0 $ になります。 - $ 5 $ 番目のクエリについて、操作後の $ S $ は `1111111` です。 - $ 6 $ 番目のクエリについて、$ T\ = $ `1111111` です。$ T $ に含まれる連続する `1` の中で最も長いものは、$ T $ の $ 1 $ 文字目から $ 7 $ 文字目からなる `1111111` なので、答えは $ 7 $ になります。

## 样例 #1

### 输入

```
7 6

1101110

2 1 7

2 2 4

1 3 6

2 5 6

1 4 7

2 1 7```

### 输出

```
3

1

0

7```

# AI分析结果

### 题目内容翻译

#### [ABC322F] Vacation Query

**题目描述**

给定一个由 `0` 和 `1` 组成的长度为 $N$ 的字符串 $S$。$S$ 的第 $i$ 个字符记为 $S_i$。

你需要按顺序处理 $Q$ 个查询。每个查询由三个整数 $(c, L, R)$ 组成，$c$ 的值决定了查询的类型：

- 当 $c=1$ 时：对于满足 $L \leq i \leq R$ 的所有整数 $i$，将 $S_i$ 从 `1` 变为 `0`，从 `0` 变为 `1`。
- 当 $c=2$ 时：从 $S$ 的第 $L$ 个字符到第 $R$ 个字符中提取出一个子字符串 $T$，输出 $T$ 中最长的连续 `1` 的长度。

**说明/提示**

**约束条件**

- $1 \leq N \leq 5 \times 10^5$
- $1 \leq Q \leq 10^5$
- $S$ 是一个长度为 $N$ 的由 `0` 和 `1` 组成的字符串
- $c \in \{1, 2\}$
- $1 \leq L \leq R \leq N$
- $N, Q, c, L, R$ 都是整数

**样例解释**

初始时，$S =$ `1101110`。

- 第一个查询：$T =$ `1101110`，最长的连续 `1` 是 `111`，长度为 $3$。
- 第二个查询：$T =$ `101`，最长的连续 `1` 是 `1`，长度为 $1$。
- 第三个查询：操作后的 $S =$ `1110000`。
- 第四个查询：$T =$ `00`，没有 `1`，长度为 $0$。
- 第五个查询：操作后的 $S =$ `1111111`。
- 第六个查询：$T =$ `1111111`，最长的连续 `1` 是 `1111111`，长度为 $7$。

**样例输入**

```
7 6

1101110

2 1 7

2 2 4

1 3 6

2 5 6

1 4 7

2 1 7
```

**样例输出**

```
3

1

0

7
```

### 算法分类
线段树

### 题解分析与结论

本题的核心在于处理区间修改和区间查询，且需要高效地维护区间内最长连续 `1` 的长度。线段树是解决此类问题的经典数据结构，能够支持区间修改和查询操作。

### 精选题解

#### 题解1：lzyqwq (5星)
**关键亮点**：
- 使用线段树维护区间内最长连续 `1` 和 `0` 的长度，支持区间翻转操作。
- 通过维护多个信息（如左起最长连续 `1`、右起最长连续 `1` 等）来实现高效的区间合并。
- 代码结构清晰，注释详细，易于理解。

**核心代码**：
```cpp
struct node {
    int l0, l1, r0, r1, len0, len1, len; bool ept;
    node() { ept = 1; }
    node operator+(const node &o) const {
        if (ept) return o; if (o.ept) return *this;
        node ret; ret.ept = 0; ret.len = len + o.len;
        ret.l0 = l0 + (l0 == len ? o.l0 : 0);
        ret.r0 = o.r0 + (o.r0 == o.len ? r0 : 0);
        ret.l1 = l1 + (l1 == len ? o.l1 : 0);
        ret.r1 = o.r1 + (o.r1 == o.len ? r1 : 0);
        ret.len0 = max({len0, o.len0, r0 + o.l0});
        ret.len1 = max({len1, o.len1, r1 + o.l1}); return ret;
    }
};
```

#### 题解2：Genius_Star (4星)
**关键亮点**：
- 详细解释了线段树节点维护的信息及其合并方式。
- 通过维护区间内最长连续 `1` 和 `0` 的长度，支持区间翻转操作。
- 代码实现较为简洁，适合初学者理解。

**核心代码**：
```cpp
struct Node{
    ll l,r;
    ll t,k; //t 为区间取反，k 为区间长度 
    ll M1,M2; //M1 为 0 的区间最长、M2 为 1 的区间最长 
    ll z1,y1;
    ll z2,y2;
}X[N<<2];
```

#### 题解3：small_john (4星)
**关键亮点**：
- 通过维护区间内最长连续 `1` 和 `0` 的长度，支持区间翻转操作。
- 代码结构清晰，注释详细，易于理解。
- 提供了详细的合并逻辑解释。

**核心代码**：
```cpp
struct node{
    int mx0,mx1,ml,mr;
    bool tag,all,lc,rc;
    friend node operator + (node x,node y) {
        node res;
        res.mx0 = max({x.mx0,y.mx0,(x.rc==0)*x.mr+(y.lc==0)*y.ml});
        res.mx1 = max({x.mx1,y.mx1,(x.rc==1)*x.mr+(y.lc==1)*y.ml});
        res.ml = x.ml+(x.rc==y.lc)*x.all*y.ml;
        res.mr = y.mr+(x.rc==y.lc)*y.all*x.mr;
        res.all = x.all&&y.all&&(x.rc==y.lc);
        res.lc = x.lc;
        res.rc = y.rc;
        return res;
    }
};
```

### 最优关键思路
使用线段树维护区间内最长连续 `1` 和 `0` 的长度，通过维护多个信息（如左起最长连续 `1`、右起最长连续 `1` 等）来实现高效的区间合并。区间翻转操作通过交换 `0` 和 `1` 的信息来实现。

### 可拓展之处
类似的问题可以通过线段树或其他数据结构（如树状数组）来解决，特别是在需要支持区间修改和查询的场景下。例如，区间求和、区间最大值等问题都可以通过类似的方法解决。

### 推荐题目
1. [P2572 [SCOI2010] 序列操作](https://www.luogu.com.cn/problem/P2572)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)

---
处理用时：48.59秒
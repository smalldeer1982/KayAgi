# 题目信息

# [ABC324F] Beautiful Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc324/tasks/abc324_f

$ N $ 個の頂点と $ M $ 本の辺からなる有向グラフがあります。各辺には**美しさ**と**コスト**の $ 2 $ つの正整数値が定められています。

$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ から頂点 $ v_i $ への有向辺であり、その美しさは $ b_i $ 、コストは $ c_i $ です。 ここで、$ u_i\ \lt\ v_i $ が制約として保証されます。

頂点 $ 1 $ から頂点 $ N $ へのパス $ P $ を $ 1 $ つ選んだときの、下記の値としてあり得る最大値を求めてください。

- $ P $ 上のすべての辺の美しさの総和を、$ P $ 上のすべての辺のコストの総和で割った値
 
ここで、与えられるグラフにおいて頂点 $ 1 $ から頂点 $ N $ へのパスが $ 1 $ 個以上存在することが制約として保証されます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i\ \lt\ v_i\ \leq\ N $
- $ 1\ \leq\ b_i,\ c_i\ \leq\ 10^4 $
- 頂点 $ 1 $ から頂点 $ N $ へのパスが存在する
- 入力される値はすべて整数
 
### Sample Explanation 1

パス $ P $ として、 $ 2,\ 6,\ 7 $ 番目の辺をこの順に通り頂点 $ 1\ \rightarrow\ 3\ \rightarrow\ 4\ \rightarrow\ 5 $ とたどるバスを選んだとき、「 $ P $ 上のすべての辺の美しさの総和を $ P $ 上のすべての辺のコストの総和で割った値」 は、 $ (b_2\ +\ b_6\ +\ b_7)\ /\ (c_2\ +\ c_6\ +\ c_7)\ =\ (9\ +\ 4\ +\ 2)\ /\ (5\ +\ 8\ +\ 7)\ =\ 15\ /\ 20\ =\ 0.75 $ であり、これがあり得る最大値です。

## 样例 #1

### 输入

```
5 7

1 2 3 6

1 3 9 5

2 3 1 5

2 4 5 3

2 5 1 9

3 4 4 8

4 5 2 7```

### 输出

```
0.7500000000000000```

## 样例 #2

### 输入

```
3 3

1 3 1 1

1 3 2 1

1 3 3 1```

### 输出

```
3.0000000000000000```

## 样例 #3

### 输入

```
10 20

3 4 1 2

7 9 4 5

2 4 4 5

4 5 1 4

6 9 4 1

9 10 3 2

6 10 5 5

5 6 1 2

5 6 5 2

2 3 2 3

6 10 4 4

4 6 3 4

4 8 4 1

3 5 3 2

2 4 3 2

3 5 4 2

1 5 3 4

1 2 4 2

3 7 2 2

7 8 1 3```

### 输出

```
1.8333333333333333```

# AI分析结果

### 题目内容重写
#### [ABC324F] Beautiful Path

**题目描述**

给定一个包含 $N$ 个顶点和 $M$ 条边的有向图。每条边有两个属性：**美しさ**（美丽值）和**コスト**（成本值）。对于第 $i$ 条边，它从顶点 $u_i$ 指向顶点 $v_i$，美丽值为 $b_i$，成本值为 $c_i$。保证 $u_i < v_i$。

要求从顶点 $1$ 到顶点 $N$ 的路径中，选择一条路径 $P$，使得路径上所有边的美丽值之和除以成本值之和的值最大。

**输入格式**

第一行包含两个整数 $N$ 和 $M$，表示顶点数和边数。接下来 $M$ 行，每行包含四个整数 $u_i, v_i, b_i, c_i$，表示一条边的起点、终点、美丽值和成本值。

**输出格式**

输出一个浮点数，表示最大比值，保留小数点后 15 位。

**样例输入 1**

```
5 7
1 2 3 6
1 3 9 5
2 3 1 5
2 4 5 3
2 5 1 9
3 4 4 8
4 5 2 7
```

**样例输出 1**

```
0.7500000000000000
```

**样例输入 2**

```
3 3
1 3 1 1
1 3 2 1
1 3 3 1
```

**样例输出 2**

```
3.0000000000000000
```

**样例输入 3**

```
10 20
3 4 1 2
7 9 4 5
2 4 4 5
4 5 1 4
6 9 4 1
9 10 3 2
6 10 5 5
5 6 1 2
5 6 5 2
2 3 2 3
6 10 4 4
4 6 3 4
4 8 4 1
3 5 3 2
2 4 3 2
3 5 4 2
1 5 3 4
1 2 4 2
3 7 2 2
7 8 1 3
```

**样例输出 3**

```
1.8333333333333333
```

### 算法分类
二分、图论

### 题解分析与结论
该题的核心思路是利用二分法结合图论中的最长路算法来求解最大比值。具体来说，通过二分答案，将问题转化为判断是否存在一条路径，使得路径上的边权（美丽值减去成本值乘以二分答案）之和大于等于零。由于图是 DAG（有向无环图），可以使用拓扑排序或动态规划来求解最长路。

### 评分较高的题解
#### 1. 作者：不知名用户 (赞：7)
**星级：5**
**关键亮点：**
- 使用了二分法和 0/1 分数规划的思想，将问题转化为判断是否存在一条路径使得边权和大于等于零。
- 利用 DAG 的性质，直接使用动态规划求解最长路，避免了复杂的图算法。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
bool check(lf mid) {
    for(int i=1;i<=n;i++) h[i] = 0, f[i] = -1e15;
    idx = 0;
    for(int i=1;i<=m;i++)
        add(u[i],v[i],(lf)1.0*b[i]-mid*c[i]);
    f[1] = 0;
    for(int i=1;i<=n;i++) {
        for(int x=h[i];x;x=e[x].ne) {
            int to = e[x].e;
            lf l = e[x].l;
            if(f[i]+l>f[to]) f[to] = f[i] + l;
        }
    }
    return f[n] > -eps;
}
```

#### 2. 作者：CrTsIr400 (赞：6)
**星级：4**
**关键亮点：**
- 同样使用了二分法和 0/1 分数规划，但使用了拓扑排序来求解最长路。
- 代码实现较为简洁，逻辑清晰，适合对拓扑排序熟悉的读者。

**核心代码：**
```cpp
bool pd(DB mid){
    fo(x,1,n)for(auto&i:e[x])i.second=i.first[1]-i.first[2]*mid;
    ql=1;qr=0;
    fo(i,1,n){
        ind[i]=d[i];
        if(!ind[i])q[++qr]=i;}
    for(;ql<=qr;++ql){I x=q[ql];
        for(auto&i:e[x]){
            I y=i.first[0];
            if((--ind[y])==0)q[++qr]=y;}}
    fo(i,1,n)f[i]=-1e30;
    f[1]=0;
    fo(k,1,qr){
        I x=q[k];
        for(auto&i:e[x]){
            I y=i.first[0];DB z=i.second;
            f[y]=max(f[y],f[x]+z);}}
    return f[n]>0;}
```

#### 3. 作者：MornStar (赞：5)
**星级：4**
**关键亮点：**
- 使用了二分法和 0/1 分数规划，结合拓扑排序求解最长路。
- 代码结构清晰，注释详细，适合初学者理解。

**核心代码：**
```cpp
bool check(double x){
    for(int i=1;i<=n;i++){
        k[i].clear();
        for(auto it:e[i]){
            k[i].push_back({it.to,it.b-it.c*x,it.c});
        }
    }
    get();
    return dis[n]>=0;
}
```

### 最优关键思路或技巧
1. **二分法结合 0/1 分数规划**：通过二分答案，将问题转化为判断是否存在一条路径满足特定条件。
2. **利用 DAG 性质**：由于图是 DAG，可以使用动态规划或拓扑排序求解最长路，避免了复杂的图算法。
3. **边权转换**：将边权转换为美丽值减去成本值乘以二分答案，简化了问题的求解。

### 可拓展之处
该题的思路可以拓展到其他类似的比值最大化问题，例如在图中寻找某种路径，使得某种属性的比值最大。类似的算法套路可以应用于其他图论问题，如最短路径、最大流等。

### 推荐题目
1. [P2868 [USACO07DEC]Sightseeing Cows](https://www.luogu.com.cn/problem/P2868)
2. [P3199 [HNOI2009]最小圈](https://www.luogu.com.cn/problem/P3199)
3. [P1768 天路](https://www.luogu.com.cn/problem/P1768)

---
处理用时：49.25秒
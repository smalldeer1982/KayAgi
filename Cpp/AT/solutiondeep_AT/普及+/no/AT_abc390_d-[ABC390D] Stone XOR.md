# 题目信息

# [ABC390D] Stone XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc390/tasks/abc390_d

袋 $ 1 $, 袋 $ 2 $, $ \ldots $, 袋 $ N $ と番号づけられた $ N $ 個の袋があります。  
 袋 $ i $ $ (1\leq\ i\leq\ N) $ には $ A_i $ 個の石が入っています。

高橋君は次の操作を好きなだけ（$ 0 $ 回でも良い）繰り返すことができます。

> $ 2 $ つの袋 A, B を選び、袋 A に入っている石を **すべて** 袋 B に入れる。

操作を繰り返した後の状態における次の値としてあり得るものが何個あるか求めてください。

- 袋 $ i $ に入っている石の個数を $ B_i $ として、$ B_1\oplus\ B_2\oplus\cdots\oplus\ B_N $ の値。  
   ただし、$ \oplus $ は排他的論理和を表す。
 
  排他的論理和とは 非負整数 $ a,b $ の排他的論理和 $ a\ \oplus\ b $ は、以下のように定義されます。 > $ a\ \oplus\ b $ を二進表記した際の $ 2^k $ $ (k\ \geq\ 0) $ の位の数は、 $ a $, $ b $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $ 、 そうでなければ $ 0 $ である。

 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります（二進表記すると $ 011\ \oplus\ 101\ =\ 110 $）。  
 一般に $ k $ 個の非負整数 $ x_1,\ x_2,\ \ldots,\ x_k $ の排他的論理和 $ x_1\oplus\ x_2\oplus\cdots\oplus\ x_k $ は $ (\cdots((x_1\ \oplus\ x_2)\ \oplus\ x_3)\ \oplus\ \cdots\ \oplus\ x_k) $ と定義され、 これは $ x_1,\ x_2,\ \ldots,\ x_k $ の順番によらないことが証明できます。 なお、問題の制約下において、操作を繰り返した後の状態における上記の値としてあり得るものが有限個しかないことが証明できます。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 12 $
- $ 1\leq\ A_i\ \leq\ 10^{17} $
- 入力はすべて整数
 
### Sample Explanation 1

例えば、高橋君が袋 A, B として袋 $ 1 $, $ 3 $ を選び、操作を行ったとすると、袋 $ 1,2,3 $ に入っている石はそれぞれ $ 0,5,9 $ となります。 ここで高橋君が操作を終了したとき、この状態における、袋に入っている石の個数の排他的論理和は $ 0\oplus\ 5\oplus\ 9=12 $ となります。 他に、高橋君が操作を繰り返した後の状態における、袋に入っている石の個数の排他的論理和としてあり得るものは $ 0,14 $ があります。 よって、あり得る値は $ 0,12,14 $ の $ 3 $ 個であるため、$ 3 $ を出力します。

## 样例 #1

### 输入

```
3

2 5 7```

### 输出

```
3```

## 样例 #2

### 输入

```
2

100000000000000000 100000000000000000```

### 输出

```
2```

## 样例 #3

### 输入

```
6

71 74 45 34 31 60```

### 输出

```
84```

# AI分析结果

### 题目内容
袋 $1$, 袋 $2$, $\ldots$, 袋 $N$ 和编号为 $N$ 的 $N$ 个袋子。  
袋 $i$ $(1\leq\ i\leq\ N)$ 中有 $A_i$ 个石头。

高桥君可以进行以下操作任意次数（包括 $0$ 次）：

> 选择两个袋子 A 和 B，将袋 A 中的所有石头全部放入袋 B 中。

操作结束后，求以下值可能的不同取值的个数：

- 袋 $i$ 中的石头数量为 $B_i$，$B_1\oplus\ B_2\oplus\cdots\oplus\ B_N$ 的值。  
   其中，$\oplus$ 表示按位异或。

### 算法分类
搜索、剪枝、位运算

### 题解分析与结论
该问题的核心是通过搜索和剪枝来枚举所有可能的石头分配方式，并计算每种分配方式下的异或和。由于 $N \leq 12$，直接暴力搜索的复杂度较高，因此需要通过剪枝和优化来减少搜索空间。

大多数题解采用了深度优先搜索（DFS）的策略，并通过以下优化手段：
1. **剪枝**：在搜索过程中，避免重复计算和无效状态。例如，当某个袋子的石头数量为0时，不再将其作为目标袋子。
2. **位运算优化**：在计算异或和时，利用异或的性质（如 $x \oplus x = 0$）来减少计算量。
3. **数据结构优化**：使用 `unordered_map` 或 `unordered_set` 来存储和去重异或和，避免使用 `map` 或 `set` 带来的额外时间复杂度。

### 高星题解推荐

#### 题解1：作者：_JF_ (赞：12)
- **星级**：★★★★★
- **关键亮点**：
  - 通过剪枝和优化，将搜索复杂度从 $O(n^n)$ 降低到 $O(n!)$，并通过进一步优化减少重复计算。
  - 使用 `unordered_map` 进行去重，避免了 `map` 的额外时间复杂度。
  - 边搜索边计算异或和，减少了最终计算的时间。
- **个人心得**：
  - 通过逐步优化，最终将搜索复杂度降低到可接受的范围，展示了剪枝和位运算优化的重要性。

```cpp
void dfs(int dis, int preans) {
    if (dis == n + 1) {
        if (!mp.count(preans)) Ans++, mp[preans] = true;
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (Now[i] == 0 && Now[i - 1] == 0) break;
        int lst = preans;
        preans ^= Now[i], Now[i] += a[dis], preans ^= Now[i];
        dfs(dis + 1, preans);
        Now[i] -= a[dis], preans = lst;
    }
}
```

#### 题解2：作者：Emplace (赞：3)
- **星级**：★★★★
- **关键亮点**：
  - 采用 DFS 策略，通过枚举每个石头的分配方式来计算异或和。
  - 使用 `unordered_map` 进行去重，确保计算效率。
  - 代码简洁，易于理解。
- **个人心得**：
  - 通过简单的 DFS 和去重，成功解决了问题，展示了搜索算法的基本应用。

```cpp
void dfs(int x, int m) {
    if (x == n + 1) {
        int x_or = 0;
        for (int i = 1; i <= m; i++) x_or ^= b[i];
        if (!mm.count(x_or)) mm[x_or] = 1, ans++;
        return;
    }
    for (int i = 1; i <= m; i++) {
        b[i] += a[x];
        dfs(x + 1, m);
        b[i] -= a[x];
    }
    b[m + 1] = a[x];
    dfs(x + 1, m + 1);
}
```

#### 题解3：作者：pengluochen1227 (赞：3)
- **星级**：★★★★
- **关键亮点**：
  - 通过 DFS 枚举所有可能的石头分配方式，并使用 `unordered_map` 进行去重。
  - 代码结构清晰，易于理解和实现。
- **个人心得**：
  - 通过简单的 DFS 和去重，成功解决了问题，展示了搜索算法的基本应用。

```cpp
void dfs(int s, int cnt, int v) {
    if (s > n) {
        mp[v] = 1;
        return;
    }
    for (int i = 1; i < cnt; i++) {
        int now = v ^ b[i];
        b[i] += a[s];
        dfs(s + 1, cnt, now ^ b[i]);
        b[i] -= a[s];
    }
    b[cnt] = a[s];
    dfs(s + 1, cnt + 1, v ^ a[s]);
    b[cnt] = 0;
}
```

### 最优关键思路与技巧
1. **剪枝优化**：在搜索过程中，通过限制搜索范围（如只搜索到第一个为0的袋子）来减少无效状态的计算。
2. **位运算优化**：利用异或的性质（如 $x \oplus x = 0$）来减少计算量，并在搜索过程中实时更新异或和。
3. **数据结构优化**：使用 `unordered_map` 或 `unordered_set` 进行去重，避免使用 `map` 或 `set` 带来的额外时间复杂度。

### 可拓展之处
该问题的解法可以推广到类似的搜索问题中，尤其是需要枚举所有可能状态并计算某种值的问题。通过剪枝和位运算优化，可以有效减少搜索空间，提高算法效率。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：40.10秒
# 题目信息

# [ABC390F] Double Sum 3

## 题目描述

给你一个长为 $N$ 的整数序列 $A=(A_1,A_2, \dots A_N)$。\
定义 $f(L,R)$ 如下
- 从一块空黑板开始。在黑板上依次写下 $R−L+1$ 个整数 $A_L,A_{l+1}, \dots,A_R$
- 重复下面的操作，直到擦去黑板上的所有整数：
	- 选择 $l,r(l \le r)$ 使得**数值**在 $[l,r]$ 的每个整数都至少在黑板上出现一次。然后，擦除所有**数值**在 $[l,r]$ 之间的整数。
- 设 $f(L,R)$ 是擦除黑板上所有整数所需的最少次数。

求出 $\displaystyle \sum_{L=1}^N \sum_{R=L}^N f(L,R)$。

## 样例 #1

### 输入

```
4
1 3 1 4```

### 输出

```
16```

## 样例 #2

### 输入

```
5
3 1 4 2 4```

### 输出

```
23```

## 样例 #3

### 输入

```
10
5 1 10 9 2 5 6 9 1 6```

### 输出

```
129```

# AI分析结果

### 题目翻译

#### 题目描述

给你一个长度为 $N$ 的整数序列 $A=(A_1,A_2, \dots A_N)$。  
定义 $f(L,R)$ 如下：  
- 从一块空黑板开始。在黑板上依次写下 $R−L+1$ 个整数 $A_L,A_{L+1}, \dots,A_R$。  
- 重复下面的操作，直到擦去黑板上的所有整数：  
  - 选择 $l,r(l \le r)$ 使得**数值**在 $[l,r]$ 的每个整数都至少在黑板上出现一次。然后，擦除所有**数值**在 $[l,r]$ 之间的整数。  
- 设 $f(L,R)$ 是擦除黑板上所有整数所需的最少次数。

求出 $\displaystyle \sum_{L=1}^N \sum_{R=L}^N f(L,R)$。

#### 样例 #1

##### 输入

```
4
1 3 1 4
```

##### 输出

```
16
```

#### 样例 #2

##### 输入

```
5
3 1 4 2 4
```

##### 输出

```
23
```

#### 样例 #3

##### 输入

```
10
5 1 10 9 2 5 6 9 1 6
```

##### 输出

```
129
```

### 算法分类
动态规划、组合数学

### 题解分析与结论

本题的核心在于计算所有子区间的 $f(L,R)$ 值之和，其中 $f(L,R)$ 表示将区间 $[L,R]$ 中的数划分为最少连续整数段的个数。大多数题解通过统计每个数对答案的贡献来优化计算，避免了直接枚举所有子区间的高复杂度。

#### 关键思路：
1. **贡献统计**：每个数 $A_i$ 对答案的贡献取决于它是否作为某个连续整数段的起点。具体来说，如果 $A_i$ 是某个连续整数段的起点，那么它会对所有包含 $A_i$ 但不包含 $A_i-1$ 的子区间产生贡献。
2. **预处理**：通过预处理每个数的前驱和后继位置，快速计算每个数对答案的贡献。具体来说，$pre_i$ 表示 $A_i$ 前第一个等于 $A_i$ 或 $A_i-1$ 的位置，$nxt_i$ 表示 $A_i$ 后第一个等于 $A_i+1$ 的位置。
3. **乘法原理**：每个数 $A_i$ 的贡献为 $(i - pre_i) \times (nxt_i - i)$，即左端点的选择范围乘以右端点的选择范围。

#### 最优题解：

1. **作者：rui_er (5星)**
   - **关键亮点**：通过预处理 $pre_i$ 和 $nxt_i$，使用乘法原理快速计算每个数的贡献，代码简洁高效。
   - **核心代码**：
     ```cpp
     rep(i, 1, n) {
         pre[i] = max(pos[a[i]], pos[a[i] + 1]);
         pos[a[i]] = i;
     }
     rep(i, 1, n + 1) pos[i] = n + 1;
     per(i, n, 1) {
         nxt[i] = pos[a[i] + 1];
         pos[a[i]] = i;
     }
     rep(i, 1, n) ans += (nxt[i] - i) * (i - pre[i]);
     ```

2. **作者：__little__Cabbage__ (4星)**
   - **关键亮点**：通过统计每个数作为连续整数段起点的贡献，避免了重复计算，思路清晰。
   - **核心代码**：
     ```cpp
     rep(i, 1, n) {
         p[i] = last[a[i]];
         pre[i] = last[a[i] + 1];
         last[a[i]] = i;
     }
     rep(i, 0, n + 1) last[i] = n + 1;
     rpe(i, n, 1) {
         nxt[i] = last[a[i] + 1];
         last[a[i]] = i;
     }
     int ans = 0;
     rep(i, 1, n) ans += (i - max(p[i], pre[i])) * (nxt[i] - i);
     ```

3. **作者：2huk (4星)**
   - **关键亮点**：通过预处理每个数的前驱和后继位置，使用乘法原理计算贡献，代码简洁。
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= n; ++i) {
         p[i] = pos[a[i]];
         pre[i] = pos[a[i] - 1];
         pos[a[i]] = i;
     }
     pos.clear();
     for (int i = n; i; --i) {
         suf[i] = !pos.count(a[i] - 1) ? n + 1 : pos[a[i] - 1];
         pos[a[i]] = i;
     }
     int res = 0;
     for (int i = 1; i <= n; ++i) {
         res += (i - max(p[i], pre[i])) * (suf[i] - i);
     }
     ```

### 扩展思路与推荐题目

#### 扩展思路：
- **类似问题**：本题可以扩展到其他需要统计子区间贡献的问题，如统计子区间中某个特定条件的元素个数、子区间的最值等。
- **优化技巧**：通过预处理和乘法原理，可以避免直接枚举所有子区间，从而大幅降低时间复杂度。

#### 推荐题目：
1. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)
3. [P4113 [HEOI2012] 采花](https://www.luogu.com.cn/problem/P4113)

---
处理用时：39.85秒
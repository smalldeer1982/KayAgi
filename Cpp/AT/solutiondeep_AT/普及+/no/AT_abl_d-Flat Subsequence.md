# 题目信息

# Flat Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abl/tasks/abl_d

数列 $ A_1,\ A_2,\ ...,\ A_N $ と整数 $ K $ が与えられます。

以下の条件を満たす数列 $ B $ の長さとして考えられる最大値を出力してください。

- $ B $ は $ A $ の (連続とは限らない) 部分列である。
- どの $ B $ の隣り合う要素の差の絶対値も $ K $ 以下である。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 300,000 $
- $ 0\ \leq\ A_i\ \leq\ 300,000 $
- $ 0\ \leq\ K\ \leq\ 300,000 $
- 入力は全て整数である。

### Sample Explanation 1

たとえば、 $ B\ =\ (1,\ 4,\ 3,\ 6,\ 9,\ 7,\ 4) $ は条件を満たします。 - これは $ A\ =\ (1,\ 5,\ 4,\ 3,\ 8,\ 6,\ 9,\ 7,\ 2,\ 4) $ の部分列です。 - 全ての隣り合う要素の差の絶対値 ($ |1-4|,\ |4-3|,\ |3-6|,\ |6-9|,\ |9-7|,\ |7-4| $) は $ K\ =\ 3 $ 以下です。

## 样例 #1

### 输入

```
10 3

1

5

4

3

8

6

9

7

2

4```

### 输出

```
7```

# AI分析结果

### 题目内容重写
**题目描述**

给定一个数列 $A_1,\ A_2,\ ...,\ A_N$ 和一个整数 $K$，求满足以下条件的数列 $B$ 的最大长度：

- $B$ 是 $A$ 的（不一定连续的）子序列。
- $B$ 中任意两个相邻元素的差的绝对值不超过 $K$。

**说明/提示**

- 数据范围：$1 \leq N \leq 300,000$，$0 \leq A_i \leq 300,000$，$0 \leq K \leq 300,000$。
- 输入均为整数。

**样例解释**

例如，$B = (1,\ 4,\ 3,\ 6,\ 9,\ 7,\ 4)$ 满足条件：
- 它是 $A = (1,\ 5,\ 4,\ 3,\ 8,\ 6,\ 9,\ 7,\ 2,\ 4)$ 的子序列。
- 所有相邻元素的差的绝对值（$|1-4|,\ |4-3|,\ |3-6|,\ |6-9|,\ |9-7|,\ |7-4|$）均不超过 $K = 3$。

**样例输入**
```
10 3
1
5
4
3
8
6
9
7
2
4
```

**样例输出**
```
7
```

### 算法分类
动态规划

### 题解分析与结论
本题的核心是通过动态规划求解满足条件的最长子序列。由于直接暴力动态规划的复杂度为 $O(n^2)$，无法通过大数据量的测试，因此需要优化。大多数题解采用了线段树优化动态规划的思路，将复杂度降低到 $O(n \log n)$。

### 精选题解
#### 1. 作者：Genius_Star (5星)
**关键亮点**：
- 使用线段树优化动态规划，复杂度为 $O(n \log n)$。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
void add(ll k,ll i,ll v){
    if(X[k].l==i&&i==X[k].r){
        X[k].Max=max(X[k].Max,v);
        return ;
    }
    ll mid=(X[k].l+X[k].r)>>1;
    if(i<=mid)
        add(k<<1,i,v);
    else
        add(k<<1|1,i,v);
    pushup(k);
}
```
**实现思想**：通过线段树维护区间最大值，动态更新每个位置的最长子序列长度。

#### 2. 作者：xiaomuyun (5星)
**关键亮点**：
- 详细解释了线段树优化动态规划的思路。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
void update(int o,int l,int r,int x,int v){
    if(l==r){
        t[o]=max(t[o],v);
        return ;
    }
    int mid=l+(r-l)/2;
    if(x<=mid) update(o*2,l,mid,x,v);
    else update(o*2+1,mid+1,r,x,v);
    t[o]=max(t[o*2],t[o*2+1]);
}
```
**实现思想**：通过线段树单点更新和区间查询，优化动态规划的转移过程。

#### 3. 作者：Milthm (4星)
**关键亮点**：
- 代码简洁，直接使用线段树优化动态规划。
- 强调了边界条件的处理。

**核心代码**：
```cpp
void update(int x,int l,int r,int k,int qwq){
    if(l==r){
        a[x]=max(a[x],qwq);return;
    }
    int mid=(l+r)>>1;
    if(k<=mid)update(x*2,l,mid,k,qwq);
    else update(x*2+1,mid+1,r,k,qwq);
    a[x]=max(a[x*2],a[x*2+1]);
}
```
**实现思想**：通过线段树维护区间最大值，动态更新每个位置的最长子序列长度。

### 最优思路总结
最优的思路是使用线段树优化动态规划，将复杂度从 $O(n^2)$ 降低到 $O(n \log n)$。通过维护区间最大值，快速查询和更新每个位置的最长子序列长度。

### 拓展思路
类似的问题可以通过线段树、树状数组等数据结构优化动态规划的转移过程，适用于需要区间查询和单点更新的场景。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)

### 个人心得摘录
- **调试经历**：在处理边界条件时，需要特别注意 $a_i - K$ 和 $a_i + K$ 是否超出值域范围。
- **踩坑教训**：线段树的更新操作需要取最大值，而不是直接赋值，以避免重复元素的影响。

---
处理用时：35.59秒
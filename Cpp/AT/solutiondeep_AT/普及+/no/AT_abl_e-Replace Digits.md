# 题目信息

# Replace Digits

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abl/tasks/abl_e

長さ $ N $ の文字列 $ S $ があります。 最初は $ S $ のすべての文字が `1` です。

クエリを $ Q $ 回処理します。 $ i $ 番目のクエリでは、整数 $ L_i,\ R_i $ と文字 (数字) $ D_i $ が与えられます。 $ L_i $ 番目から $ R_i $ 番目までの全ての文字を $ D_i $ に書き換えてください。

各クエリの後、$ S $ を十進法で書かれた整数とみなし、その値を $ 998,244,353 $ でわった余りを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 200,000 $
- $ 1\ \leq\ L_i\ \leq\ R_i\ \leq\ N $
- $ 1\ \leq\ D_i\ \leq\ 9 $
- 入力は全て整数である。

### Sample Explanation 2

あまりをとるのを忘れないでください。

## 样例 #1

### 输入

```
8 5

3 6 2

1 4 7

3 8 3

2 2 2

4 5 1```

### 输出

```
11222211

77772211

77333333

72333333

72311333```

## 样例 #2

### 输入

```
200000 1

123 456 7```

### 输出

```
641437905```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个长度为 $N$ 的字符串 $S$。最初，$S$ 的所有字符都是 `1`。

你需要处理 $Q$ 次查询。在第 $i$ 次查询中，你会得到整数 $L_i$、$R_i$ 和字符（数字）$D_i$。你需要将 $S$ 中从第 $L_i$ 个字符到第 $R_i$ 个字符的所有字符都修改为 $D_i$。

在每次查询后，将 $S$ 视为一个十进制整数，输出其值除以 $998,244,353$ 的余数。

#### 说明/提示

##### 约束

- $1 \leq N, Q \leq 200,000$
- $1 \leq L_i \leq R_i \leq N$
- $1 \leq D_i \leq 9$
- 输入均为整数。

##### 样例解释

不要忘记取模。

##### 样例 #1

###### 输入

```
8 5

3 6 2

1 4 7

3 8 3

2 2 2

4 5 1
```

###### 输出

```
11222211

77772211

77333333

72333333

72311333
```

##### 样例 #2

###### 输入

```
200000 1

123 456 7
```

###### 输出

```
641437905
```

### 算法分类
线段树

### 题解分析与结论

本题的核心在于处理区间修改和全局查询，且需要高效地维护一个字符串的数值表示。由于数据规模较大（$N, Q \leq 200,000$），直接暴力修改和计算是不可行的。因此，线段树成为解决此类问题的首选数据结构。

#### 题解对比

1. **Rigel 的题解**：
   - **思路**：使用线段树维护每个区间的权值，预处理每个区间的权值，并在修改时通过懒标记进行区间更新。每次修改后查询整个区间的值。
   - **亮点**：详细解释了线段树的维护方式，特别是如何通过预处理权值来简化计算。代码结构清晰，时间复杂度为 $O(Q \log N)$。
   - **评分**：5星

2. **Bamboo_Day 的题解**：
   - **思路**：使用线段树维护每个区间的十进制数，通过预处理 $10$ 的幂次方和连续 $1$ 的数值来简化计算。修改时通过懒标记进行区间更新。
   - **亮点**：详细解释了线段树的维护方式，特别是如何通过预处理来简化计算。代码结构清晰，时间复杂度为 $O(Q \log N)$。
   - **评分**：4星

3. **xiaoPanda 的题解**：
   - **思路**：使用线段树维护每个区间的十进制数，通过预处理 $10$ 的幂次方和连续 $1$ 的数值来简化计算。修改时通过懒标记进行区间更新。
   - **亮点**：详细解释了线段树的维护方式，特别是如何通过预处理来简化计算。代码结构清晰，时间复杂度为 $O(Q \log N)$。
   - **评分**：4星

#### 最优关键思路

1. **预处理权值**：通过预处理每个区间的权值（即 $10^{n-i}$），可以在修改时直接通过乘法计算新的值，避免了每次修改时的重复计算。
2. **懒标记**：使用懒标记来延迟更新，只有在需要时才进行实际的修改操作，从而减少不必要的计算。
3. **线段树维护**：通过线段树维护每个区间的值，可以在 $O(\log N)$ 的时间内完成区间修改和全局查询。

#### 可拓展之处

类似的问题可以通过线段树或其他高效的数据结构（如树状数组）来解决。例如，处理区间修改和区间查询的问题，或者需要高效维护区间统计信息的问题。

#### 推荐题目

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

### 精选题解

#### 题解1：Rigel 的题解

**星级**：5星  
**关键亮点**：详细解释了线段树的维护方式，特别是如何通过预处理权值来简化计算。代码结构清晰，时间复杂度为 $O(Q \log N)$。

**核心代码**：
```cpp
void push_up(int now){
    t[now]=(t[now<<1]+t[(now<<1)|1])%TT;
}
void push_down(int now){
    if(!tag[now])return;
    int lson=now<<1,rson=(now<<1)|1;
    tag[lson]=tag[now],tag[rson]=tag[now];
    t[lson]=tag[now]*tw[lson]%TT,t[rson]=tag[now]*tw[rson]%TT;
    tag[now]=0;
}
void Build(int now,int l,int r){
    if(l==r){
        tw[now]=w[l];
        return;
    }
    int lson=now<<1,rson=(now<<1)|1,mid=(l+r)>>1;
    Build(lson,l,mid),Build(rson,mid+1,r);
    tw[now]=(tw[lson]+tw[rson])%TT;
}
```

**核心实现思想**：通过 `push_up` 和 `push_down` 函数维护线段树的更新，`Build` 函数预处理每个区间的权值。

---
处理用时：40.21秒
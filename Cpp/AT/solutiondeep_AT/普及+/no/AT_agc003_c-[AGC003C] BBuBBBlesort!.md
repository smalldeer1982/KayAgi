# 题目信息

# [AGC003C] BBuBBBlesort!

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc003/tasks/agc003_c

高橋君は、誕生日に長さ $ N $ の数列をもらいました。$ i(1\ ≦\ i\ ≦\ N) $ 番目の要素は整数 $ A_i $ です。どの $ 2 $ つの要素も、互いに異なります。 高橋君はこの数列を単調増加になるように並べ替えたいです。 高橋君は超能力者なので、以下の $ 2 $ つの操作が任意のタイミングでできます。

- 操作$ 1 $: 数列の連続する $ 2 $ つの要素を選び、その $ 2 $ つの順番を反転する。
- 操作$ 2 $: 数列の連続する $ 3 $ つの要素を選び、その $ 3 $ つの順番を反転する。

高橋君は操作$ 2 $は好きですが、操作$ 1 $は嫌いです。この $ 2 $ 種類の操作を使って数列を単調増加になるように並び替えるときの、操作$ 1 $の最小回数を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 0\ ≦\ A_i\ ≦\ 10^9 $
- $ i\ ≠\ j $ ならば $ A_i\ ≠\ A_j $
- 入力はすべて整数である。

### Sample Explanation 1

以下の操作で、単調増加な数列にすることができます。 - まず、後ろの $ 3 $ つの要素を反転する。数列は $ 2,1,3,4 $ となる。 - 次に、前の $ 2 $ つの要素を反転する。数列は $ 1,2,3,4 $ となる。 この操作列において、連続する $ 2 $ つの要素を入れ替える操作の回数は $ 1 $ です。これより少ない回数で単調増加な数列は作れないので、$ 1 $ を出力します。

## 样例 #1

### 输入

```
4

2

4

3

1```

### 输出

```
1```

## 样例 #2

### 输入

```
5

10

8

5

3

2```

### 输出

```
0```

# AI分析结果

【题目翻译】
# [AGC003C] BBuBBBlesort!

## 题目描述

高橋君收到了一个长度为 $N$ 的数列作为生日礼物。数列的第 $i$ 个元素是整数 $A_i$，且所有元素互不相同。高橋君希望将这个数列按单调递增的顺序排列。他拥有超能力，可以随时进行以下两种操作：

- 操作1：选择数列中连续的两个元素，交换它们的位置。
- 操作2：选择数列中连续的三个元素，反转它们的顺序。

高橋君喜欢操作2，但不喜欢操作1。现在要求使用这两种操作将数列排序，并使得操作1的使用次数最少。请输出操作1的最小使用次数。

## 说明/提示

### 约束条件

- $1 \leq N \leq 10^5$
- $0 \leq A_i \leq 10^9$
- 如果 $i \neq j$，则 $A_i \neq A_j$
- 输入均为整数。

### 样例解释1

通过以下操作可以将数列排序为单调递增：
1. 反转后三个元素，数列变为 $2,1,3,4$。
2. 反转前两个元素，数列变为 $1,2,3,4$。

在这个过程中，操作1的使用次数为1，这是最小的操作次数，因此输出1。

## 样例 #1

### 输入

```
4

2

4

3

1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5

10

8

5

3

2
```

### 输出

```
0
```

【算法分类】  
离散化、排序

【题解分析与结论】  
该题的核心思路是通过离散化和排序来确定每个元素的最终位置，然后通过操作2（不影响下标奇偶性）和操作1（改变下标奇偶性）来最小化操作1的使用次数。具体来说，操作2只能交换下标奇偶性相同的元素，而操作1可以交换下标奇偶性不同的元素。因此，只需统计需要改变奇偶性的元素数量，并将其除以2即可得到操作1的最小使用次数。

【评分较高的题解】  
1. **作者：installb (5星)**  
   - 关键亮点：清晰解释了操作2的等价性，并通过离散化和奇偶性统计来简化问题，代码简洁且高效。
   - 代码核心思想：离散化后统计奇偶性不匹配的元素数量，最终输出结果除以2。
   ```cpp
   for(LL i = 1;i <= n;i ++) if((a[i] & 1) != (i & 1)) ans ++;
   ans >>= 1;
   cout << ans << endl;
   ```

2. **作者：Tipsy_bamboo (4星)**  
   - 关键亮点：思路清晰，代码简洁，使用了`lower_bound`进行离散化，并通过奇偶性统计来求解。
   - 代码核心思想：离散化后统计奇偶性不匹配的元素数量，最终输出结果除以2。
   ```cpp
   for(int i = 1; i <= n; i++) a[i] = lower_bound(b + 1 , b + 1 + n, a[i]) - b;
   for(int i = 1; i <= n; i++) if(a[i] % 2 != i % 2) ns++;
   printf("%d ", ns / 2);
   ```

3. **作者：Chydz (4星)**  
   - 关键亮点：思路清晰，代码简洁，通过离散化和奇偶性统计来求解，代码实现简洁。
   - 代码核心思想：离散化后统计奇偶性不匹配的元素数量，最终输出结果除以2。
   ```cpp
   for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+1+n,a[i])-b;
   for(int i=1;i<=n;i++)if((a[i]&1)!=(i&1))ans++;
   cout<<ans/2;
   ```

【最优关键思路】  
通过离散化和排序确定每个元素的最终位置，然后统计需要改变奇偶性的元素数量，最终将结果除以2即可得到操作1的最小使用次数。这一思路充分利用了操作2的特性，避免了不必要的操作1，达到了最优解。

【拓展与举一反三】  
类似的问题可以通过离散化和奇偶性分析来简化，尤其是在涉及到元素位置交换和排序的题目中。例如，可以通过离散化将元素映射到固定范围内，然后通过奇偶性或其他属性来进一步优化操作。

【推荐题目】  
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
2. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)  
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

---
处理用时：31.98秒
# 题目信息

# [AGC004B] Colorful Slimes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc004/tasks/agc004_b

高橋君は異世界に住んでいます。 この世界には $ N $ 色のスライムがいます。 最初、高橋君はどの色のスライムも飼っていません。 高橋君の目標は、全色のスライムを一緒に飼うことです。

高橋君は次の $ 2 $ 種類の操作を行えます。

- 今飼っていないスライムの色 $ i $ ($ 1\ <\ =i\ <\ =N $) をひとつ選ぶ。 色 $ i $ のスライムを捕まえて飼う。 この操作には $ a_i $ 秒掛かる。
- 魔法を唱える。 すると、今飼っている各スライムについて、色 $ i $ ($ 1\ <\ =i\ <\ =N-1 $) のスライムは色 $ i+1 $ へ変色する。 ただし、色 $ N $ のスライムは色 $ 1 $ へ変色する。 この操作には $ x $ 秒掛かる。

高橋君が全色のスライムを一緒に飼うためには、最短で合計何秒掛かるかを求めてください。

## 说明/提示

### 制約

- $ 2\ <\ =N\ <\ =2,000 $
- $ a_i $ は整数である。
- $ 1\ <\ =a_i\ <\ =10^9 $
- $ x $ は整数である。
- $ 1\ <\ =x\ <\ =10^9 $

### Sample Explanation 1

次のように操作を行えばよいです。 - 色 $ 1 $ のスライムを捕まえて飼う。 $ 1 $ 秒掛かる。 - 魔法を唱える。 スライムの色が $ 1 $ → $ 2 $ と変わる。 $ 10 $ 秒掛かる。 - 色 $ 1 $ のスライムを捕まえて飼う。 $ 1 $ 秒掛かる。

### Sample Explanation 2

次のように操作を行えばよいです。 - 色 $ 2 $ のスライムを捕まえて飼う。 $ 1 $ 秒掛かる。 - 魔法を唱える。 スライムの色が $ 2 $ → $ 3 $ と変わる。 $ 10 $ 秒掛かる。 - 色 $ 2 $ のスライムを捕まえて飼う。 $ 1 $ 秒掛かる。 - 魔法を唱える。 スライムの色が $ 3 $ → $ 1 $，$ 2 $ → $ 3 $ とそれぞれ変わる。 $ 10 $ 秒掛かる。 - 色 $ 2 $ のスライムを捕まえて飼う。 $ 1 $ 秒掛かる。

### Sample Explanation 3

次のように操作を行えばよいです。 - 色 $ 1 $ のスライムを捕まえて飼う。 $ 1 $ 秒掛かる。 - 色 $ 2 $ のスライムを捕まえて飼う。 $ 2 $ 秒掛かる。 - 色 $ 3 $ のスライムを捕まえて飼う。 $ 3 $ 秒掛かる。 - 色 $ 4 $ のスライムを捕まえて飼う。 $ 4 $ 秒掛かる。

## 样例 #1

### 输入

```
2 10

1 100```

### 输出

```
12```

## 样例 #2

### 输入

```
3 10

100 1 100```

### 输出

```
23```

## 样例 #3

### 输入

```
4 10

1 2 3 4```

### 输出

```
10```

# AI分析结果

### 题目内容重写
高橋君住在异世界，这个世界有 $N$ 种颜色的史莱姆。最初，高橋君没有饲养任何颜色的史莱姆。他的目标是饲养所有颜色的史莱姆。

高橋君可以进行以下两种操作：
1. 选择一个未饲养的颜色 $i$（$1 \leq i \leq N$），花费 $a_i$ 秒捕捉并饲养该颜色的史莱姆。
2. 使用魔法，花费 $x$ 秒，将所有已饲养的史莱姆的颜色 $i$ 变为 $i+1$（颜色 $N$ 变为 $1$）。

求高橋君饲养所有颜色的史莱姆所需的最短时间。

### 算法分类
动态规划

### 题解分析与结论
该题的核心思路是通过枚举魔法使用次数，结合动态规划或贪心策略，计算每种情况下捕捉史莱姆的最小代价。大多数题解采用了动态规划的思路，通过预处理区间最小值或使用单调栈等数据结构来优化计算。

### 精选题解
#### 1. 作者：Goodenough (赞：6)
- **星级**：4.5
- **关键亮点**：使用动态规划预处理每个史莱姆在不同魔法次数下的最小捕捉代价，思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      dp[i][0]=a[i];
      for(int j=1;j<n;j++){
          int k=i-j;
          if(k<=0) k+=n;
          dp[i][j]=min(dp[i][j-1],a[k]);
      }
  }
  for(int i=0;i<n;i++){
      sum=x*i;
      for(int j=1;j<=n;j++)
          sum+=dp[j][i];
      ans=min(ans,sum);
  }
  ```
  **实现思想**：通过动态规划预处理每个史莱姆在不同魔法次数下的最小捕捉代价，最后枚举魔法次数，计算总代价并取最小值。

#### 2. 作者：封禁用户 (赞：4)
- **星级**：4
- **关键亮点**：优化了动态规划的空间复杂度，通过滚动数组减少内存使用，代码可读性较好。
- **核心代码**：
  ```cpp
  rep(j,0,n-1){//压维
      int s=0;
      rep(i,0,n-1){
          dp[i]=std::min(dp[i],a[(i-j+n)%n]);
          s+=dp[i];
      }
      ans=std::min(ans,x*j+s);//统计答案
  }
  ```
  **实现思想**：通过滚动数组优化空间复杂度，枚举魔法次数，动态更新每个史莱姆的最小捕捉代价，最后计算总代价。

#### 3. 作者：ningago (赞：2)
- **星级**：4
- **关键亮点**：通过枚举魔法次数，结合动态规划计算每个史莱姆的最小捕捉代价，思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  for(int j = 1;j < n;j++){
      for(int i = 1;i <= n;i++){
          int last = i - 1 == 0 ? n : i - 1;
          dp[i][j] = std::min(dp[last][j - 1],a[i]);
      }
  }
  for(int j = 0;j < n;j++){
      int now = j * X;
      for(int i = 1;i <= n;i++)
          now += dp[i][j];
      res = std::min(now,res);
  }
  ```
  **实现思想**：通过动态规划预处理每个史莱姆在不同魔法次数下的最小捕捉代价，最后枚举魔法次数，计算总代价并取最小值。

### 最优关键思路
通过枚举魔法使用次数，结合动态规划预处理每个史莱姆在不同魔法次数下的最小捕捉代价，最后计算总代价并取最小值。这种方法既保证了时间复杂度，又简化了问题的复杂度。

### 拓展思路
类似的问题可以通过枚举关键参数，结合动态规划或贪心策略来优化计算。例如，在区间最小值问题中，可以使用单调栈或滑动窗口来优化时间复杂度。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

---
处理用时：31.48秒
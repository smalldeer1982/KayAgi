# 题目信息

# [AGC012B] Splatter Painting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc012/tasks/agc012_b

イカはグラフの頂点に色を塗るのが好きです。

$ 1 $ から $ N $ までの番号がついた $ N $ 個の頂点と $ M $ 本の辺からなる単純無向グラフが与えられます。 全ての頂点ははじめ、色 $ 0 $ で塗られています。$ i $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を双方向につなぐ長さ $ 1 $ の辺です。

イカはこのグラフに対して $ Q $ 回の操作を行いました。 $ i $ 回目の操作では、頂点 $ v_i $ から距離 $ d_i $ 以内にあるような頂点たち全ての色を色 $ c_i $ で上書きしました。

$ Q $ 回の操作後において、各頂点がどの色で塗られているか調べてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N,M,Q\ ≦\ 10^5 $
- $ 1\ ≦\ a_i,b_i,v_i\ ≦\ N $
- $ a_i\ ≠\ b_i $
- $ 0\ ≦\ d_i\ ≦\ 10 $
- $ 1\ ≦\ c_i\ ≦10^5 $
- $ d_i,\ c_i $ いずれも整数
- 与えられるグラフに自己ループや多重辺は存在しない

### 部分点

- $ 1\ ≦\ N,M,Q\ ≦\ 2{,}000 $ を満たすデータセットに正解した場合は、部分点として $ 200 $ 点が与えられる。

### Sample Explanation 1

はじめ、各頂点は色 $ 0 $ で塗られています。 $ 1 $ 回目の操作により、頂点 $ 5,6 $ が色 $ 1 $ で塗られます。 $ 2 $ 回目の操作により、頂点 $ 1,2,3,4,5 $ が色 $ 2 $ で塗られます。 !\[2ab7e180230b159d42d35ea7e555b3b0.png\](https://atcoder.jp/img/agc012/2ab7e180230b159d42d35ea7e555b3b0.png)

### Sample Explanation 2

与えられるグラフは連結とは限りません。

## 样例 #1

### 输入

```
7 7

1 2

1 3

1 4

4 5

5 6

5 7

2 3

2

6 1 1

1 2 2```

### 输出

```
2

2

2

2

2

1

0```

## 样例 #2

### 输入

```
14 10

1 4

5 7

7 11

4 10

14 7

14 3

6 14

8 11

5 13

8 3

8

8 6 2

9 7 85

6 9 3

6 7 5

10 3 1

12 9 4

9 6 6

8 2 3```

### 输出

```
1

0

3

1

5

5

3

3

6

1

3

4

5

3```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个包含 $N$ 个顶点和 $M$ 条边的无向图，所有顶点初始颜色为 $0$。接下来进行 $Q$ 次操作，每次操作给定一个顶点 $v_i$、距离 $d_i$ 和颜色 $c_i$，表示将与顶点 $v_i$ 距离不超过 $d_i$ 的所有顶点染成颜色 $c_i$。最终输出每个顶点的颜色。

**说明/提示**

- 顶点编号从 $1$ 到 $N$。
- 每条边连接两个不同的顶点，且没有自环和多重边。
- $1 \leq N, M, Q \leq 10^5$，$0 \leq d_i \leq 10$，$1 \leq c_i \leq 10^5$。

### 算法分类

**图论**

### 题解分析与结论

这道题的核心在于如何高效地处理多次染色操作，避免重复染色。以下是各题解的要点总结：

1. **zhylj 的题解**：通过维护每个顶点在不同距离下的最晚操作编号，利用 BFS 的思想进行转移，最终确定每个顶点的颜色。时间复杂度为 $O(d \cdot (n + m))$。
2. **曾爷爷的题解**：采用倒序处理操作，利用 DFS 进行染色，并通过剪枝避免重复染色。时间复杂度为 $O(q \cdot (n + m))$。
3. **CHHC 的题解**：同样采用倒序处理操作，通过维护每个顶点的最大染色距离来剪枝，避免重复染色。时间复杂度为 $O(q \cdot (n + m))$。

### 高星题解推荐

1. **zhylj 的题解（5星）**
   - **关键亮点**：通过维护每个顶点在不同距离下的最晚操作编号，利用 BFS 的思想进行转移，避免了重复染色，时间复杂度较低。
   - **核心代码**：
     ```cpp
     for(int k = 10; k; --k) 
         for(int i = 1; i <= n; ++i)
             for(auto v : E[i])
                 t[v][k - 1] = std::max(t[i][k], t[v][k - 1]);
     ```

2. **曾爷爷的题解（4星）**
   - **关键亮点**：倒序处理操作，利用 DFS 进行染色，并通过剪枝避免重复染色，思路清晰。
   - **核心代码**：
     ```cpp
     void dfs(int x, int col, int dis) {
         if (!ans[x]) ans[x] = col;
         if (!dis || Dis[x] >= dis) return;
         Dis[x] = dis;
         for (int i = hed[x]; i; i = nxt[i])
             dfs(ver[i], col, dis - 1);
     }
     ```

3. **CHHC 的题解（4星）**
   - **关键亮点**：倒序处理操作，通过维护每个顶点的最大染色距离来剪枝，避免重复染色，代码简洁。
   - **核心代码**：
     ```cpp
     void f(int v, int d, int c) {
         if (d <= maxd[v]) return;
         maxd[v] = d;
         if (colour[v] == 0) colour[v] = c;
         for (int i = 0; i < edge[v].size(); i++)
             f(edge[v][i], d - 1, c);
     }
     ```

### 最优关键思路

**倒序处理操作**：由于后面的操作会覆盖前面的操作，因此倒序处理可以避免重复染色，减少不必要的计算。

**剪枝优化**：通过维护每个顶点的最大染色距离，可以在 DFS 或 BFS 过程中进行剪枝，避免重复访问已经染色的顶点。

### 可拓展之处

类似的问题可以扩展到有向图、带权图等场景，或者操作次数更多、距离更大的情况。可以通过分层图、动态规划等方法来进一步优化。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
3. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)

### 个人心得摘录

- **曾爷爷**：倒着考虑操作，直接得到最终状态，避免了重复染色。
- **CHHC**：模拟是一切的基础，但需要优化避免重复处理。
- **Aw顿顿**：正难则反，倒序处理操作可以减少冗余操作。

---
处理用时：31.52秒
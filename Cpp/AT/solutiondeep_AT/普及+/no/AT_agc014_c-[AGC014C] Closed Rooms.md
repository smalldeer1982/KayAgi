# 题目信息

# [AGC014C] Closed Rooms

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc014/tasks/agc014_c

高橋君は建物の中に閉じ込められてしまいました。

この建物は $ H $ 行 $ W $ 列に並んだ $ H×W $ 個の部屋からなり、上から $ i $ 行目、左から $ j $ 列目の部屋は $ (i,j) $ で表され、その部屋の状態は $ A_{i,j} $ で表されています。 $ A_{i,j}= $ `#` の場合は、この部屋は閉じられており、$ A_{i,j}= $ `.` の場合は、この部屋には自由に出入りできます。 そして、 $ A_{i,j}= $ `S` となる部屋が高橋君の今いる部屋です。ただし、高橋君が今いる部屋も自由に出入りできる部屋です。

また、$ 1 $ 行目、$ 1 $ 列目、$ H $ 行目、$ W $ 列目のいずれかに含まれる部屋は建物の外につながっており、 それ以外の各部屋 $ (i,j) $ は $ 4 $ つの部屋 $ (i-1,j) $ $ , $ $ (i+1,j) $ $ , $ $ (i,j-1) $ $ , $ $ (i,j+1) $ と隣接しています。

高橋君はこの建物から脱出するために魔法を使うことにしました。一回の魔法で高橋君は以下の操作ができます。

- 高橋君は今いる部屋から隣り合う部屋に移動することを $ K $ 回まで繰り返す。ただし、閉じられている部屋には移動することはできない。
- その後、閉じられている部屋を $ K $ 個まで選び、それらを開いた状態にする。それらの部屋は以降自由に出入りできるようになる。

ただし、これらの操作では、全く動かなかったり、閉じられている部屋があっても開かなかったりしてもよいです。

高橋君の目標は建物の外につながっている部屋のいずれかにたどり着くことです。そのために必要な魔法の回数の最小値を求めてください。

ただし、はじめに高橋君がいる部屋は建物の外とはつながっていないことが保証されています。

## 说明/提示

### 制約

- $ 3\ ≦\ H\ ≦\ 800 $
- $ 3\ ≦\ W\ ≦\ 800 $
- $ 1\ ≦\ K\ ≦\ H×W $
- $ A_{i,j} $ は `#` , `.` , `S` のいずれかである。
- $ A_{i,j}= $ `S` となる $ (i,j) $ は一意に存在し、$ 2\ ≦\ i\ ≦\ H-1\ ,\ 2\ ≦\ j\ ≦\ W-1 $ を満たす。

### Sample Explanation 1

高橋君は最初の魔法で部屋 $ (1,2) $ に移動することができるので、$ 1 $ 回の魔法で十分です。

### Sample Explanation 2

高橋君は最初の魔法では移動することができないですが、部屋 $ (1,2) $ を $ 1 $ 回目の魔法で開けることができます。 そして、次の魔法で部屋 $ (1,2) $ に移動することで、$ 2 $ 回の魔法で目標を達成できます。

## 样例 #1

### 输入

```
3 3 3

#.#

#S.

###```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3 3

###

#S#

###```

### 输出

```
2```

## 样例 #3

### 输入

```
7 7 2

#######

#######

##...##

###S###

##.#.##

###.###

#######```

### 输出

```
2```

# AI分析结果

### 题目内容重写

高橋君被困在一座建筑物中。这座建筑物由 $H$ 行 $W$ 列的 $H×W$ 个房间组成，从上到下第 $i$ 行、从左到右第 $j$ 列的房间表示为 $(i,j)$，其状态由 $A_{i,j}$ 表示。$A_{i,j}=$ `#` 表示该房间被锁，$A_{i,j}=$ `.` 表示该房间可以自由出入，$A_{i,j}=$ `S` 表示高橋君当前所在的房间。高橋君所在的房间也可以自由出入。

此外，第 $1$ 行、第 $1$ 列、第 $H$ 行、第 $W$ 列的房间与外界相连，其他房间 $(i,j)$ 与四个相邻房间 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 相连。

高橋君决定使用魔法逃脱。每次魔法可以进行以下操作：

1. 高橋君可以从当前房间移动到相邻房间，最多移动 $K$ 次。被锁的房间无法进入。
2. 之后，高橋君可以选择最多 $K$ 个被锁的房间，将其解锁。这些房间之后可以自由出入。

高橋君的目标是到达与外界相连的房间。求最少需要多少次魔法才能实现目标。

### 算法分类
**广度优先搜索 (BFS)**

### 题解分析与结论

#### 核心思路
1. **第一轮操作**：高橋君只能移动 $K$ 步，无法解锁任何房间。因此，第一轮的目标是尽可能靠近边界。
2. **后续操作**：每轮魔法可以解锁 $K$ 个房间并移动 $K$ 步，因此后续操作可以视为无障碍移动。
3. **BFS 搜索**：通过 BFS 搜索，找到在第一轮操作中高橋君能够到达的离边界最近的位置。然后计算从该位置到边界所需的轮数。

#### 关键技巧
- **BFS 优化**：在 BFS 过程中，记录每个位置到起点的步数，确保不超过 $K$ 步。
- **边界距离计算**：在 BFS 过程中，实时更新当前位置到边界的最小距离。

#### 最优题解
1. **作者：installb (5星)**
   - **亮点**：思路清晰，代码简洁，直接通过 BFS 找到离边界最近的位置，并计算所需轮数。
   - **代码核心**：
     ```cpp
     void bfs(LL x,LL y){
         t.x = x; t.y = y; t.stp = 0; q.push(t);
         while(!q.empty()){
             h = q.front(); q.pop();
             if(h.stp > k) continue;
             vis[h.x][h.y] = 1;
             ans = min(ans,min(min(h.x - 1,h.y - 1),min(n - h.x,m - h.y)));
             for(LL i = 0;i < 4;i ++){
                 LL tx = h.x + dx[i],ty = h.y + dy[i];
                 if(!tx || !ty || tx > n || ty > m) continue;
                 if(vis[tx][ty] || ch[tx][ty] == '#') continue;
                 vis[tx][ty] = 1;
                 t.x = tx; t.y = ty; t.stp = h.stp + 1;
                 q.push(t);
             }
         }
     }
     ```

2. **作者：huhexuan (4星)**
   - **亮点**：思路明确，代码实现较为规范，通过 BFS 计算第一轮操作后到边界的最小距离。
   - **代码核心**：
     ```cpp
     void bfs(int x,int y,int step){
         q.push({x,y,step});
         while(!q.empty()){
             node h=q.front();
             q.pop();
             if(h.step>k) continue;
             cnt=min(cnt,min(n-h.x,m-h.y));
             cnt=min(cnt,min(h.x-1,h.y-1));
             vis[h.x][h.y]=1;
             for(int i=0;i<4;i++){
                 int fx=dx[i]+h.x,fy=dy[i]+h.y;
                 if(fx>=1&&fy>=1&&fx<=n&&fy<=m&&!vis[fx][fy]&&a[fx][fy]!='#'){
                     q.push({fx,fy,h.step+1});
                     vis[fx][fy]=1;
                 }
             }
         }
     }
     ```

3. **作者：_FL_ (4星)**
   - **亮点**：代码结构清晰，BFS 实现简洁，通过实时更新最小距离来优化计算。
   - **代码核心**：
     ```cpp
     void BFS() {
         while (!q1.empty()) {
             int x = q1.front().Xi;
             int y = q1.front().Yi;
             int dis = q1.front().DIS;
             q1.pop();
             minn = min(minn, min(min(x - 1, n - x), min(y - 1, m - y)));
             if (dis >= k1) continue;
             for (int i = 0; i < 4; i++) {
                 int tx = x + dx[i], ty = y + dy[i];
                 if (tx < 1 || ty < 1 || tx > n || ty > m || vis[tx][ty] || str1[tx][ty] == '#') continue;
                 vis[tx][ty] = 1;
                 q1.push((Node){tx, ty, dis + 1});
             }
         }
     }
     ```

### 扩展思路
- **类似题目**：可以考虑在更复杂的网格图中进行类似的 BFS 搜索，或者结合其他算法（如动态规划）来优化路径选择。
- **优化方向**：可以进一步优化 BFS 的剪枝策略，减少不必要的搜索。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1131 [ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131)

---
处理用时：43.81秒
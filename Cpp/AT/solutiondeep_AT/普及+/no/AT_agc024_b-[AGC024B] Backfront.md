# 题目信息

# [AGC024B] Backfront

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc024/tasks/agc024_b

$ 1 $ 以上 $ N $ 以下の整数を並び替えてできる数列 $ (P_1,P_2,...,P_N) $ が与えられます。 次の操作を繰り返してこの列を昇順に並び替えるとき、操作の回数の最小値を求めてください。

- 数列の要素を $ 1 $ つ選び、その要素を列の先頭または末尾のうち好きなほうに移動する

なお、この操作によって与えられた列を昇順に並び替えられることは証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ (P_1,P_2,...,P_N) $ は $ (1,2,...,N) $ の並び替えである
- 入力はすべて整数である

### Sample Explanation 1

例えば、以下の操作によって列を昇順に並び替えることができます。 - $ 2 $ を先頭に移動する。新しい数列は $ (2,1,3,4) $ となる。 - $ 1 $ を先頭に移動する。新しい数列は $ (1,2,3,4) $ となる。

## 样例 #1

### 输入

```
4

1

3

2

4```

### 输出

```
2```

## 样例 #2

### 输入

```
6

3

2

5

1

4

6```

### 输出

```
4```

## 样例 #3

### 输入

```
8

6

3

1

2

7

4

8

5```

### 输出

```
5```

# AI分析结果

### 题目翻译
给定一个由 $1$ 到 $N$ 的整数排列而成的数列 $ (P_1,P_2,...,P_N) $，要求通过以下操作将数列升序排列，求操作的最小次数。

- 每次操作可以选择数列中的一个元素，将其移动到数列的开头或末尾。

### 算法分类
动态规划

### 题解分析与结论
本题的核心思路是找出数列中最长的连续递增子序列（LIS），然后用数列的长度减去这个子序列的长度，即为所需的最小操作次数。这是因为最长的连续递增子序列已经是有序的，不需要移动，而其他元素则需要通过操作移动到正确的位置。

### 精选题解
#### 题解1：作者：_32bit_Silentnight (赞：5)
- **星级**：5星
- **关键亮点**：通过极端样例分析，提出最长连续递增子序列的思路，并给出了简洁的代码实现。
- **代码核心**：
  ```cpp
  int a, b[200001] = {0}, i, m = -1, k = 0, x;
  scanf("%d", &a);
  for (i = 1; i <= a; i++) {
      cin >> x;
      b[x] = b[x - 1] + 1;
      m = max(m, b[x]);
  }
  cout << a - m;
  ```
  **核心思想**：通过数组 `b` 记录每个数字所在的位置，并利用 `b[x] = b[x - 1] + 1` 来计算以 `x` 结尾的最长连续递增子序列的长度。

#### 题解2：作者：tanghairong (赞：4)
- **星级**：4星
- **关键亮点**：详细分析了如何通过移动元素来排序，并提出了求最长连续递增子序列的方法。
- **代码核心**：
  ```cpp
  int n, k, s = 1, ans, p[200005];
  cin >> n;
  for (int i = 1; i <= n; i++) {
      cin >> k;
      p[k] = i;
  }
  for (int i = 1; i < n; i++) {
      if (p[i + 1] > p[i]) s++;
      else {
          ans = max(ans, s);
          s = 1;
      }
  }
  ans = max(ans, s);
  cout << n - ans;
  ```
  **核心思想**：通过数组 `p` 记录每个数字的位置，然后遍历数组，找到最长的连续递增子序列。

#### 题解3：作者：SalN (赞：2)
- **星级**：4星
- **关键亮点**：通过动态规划的思路，直接计算每个数字结尾的最长连续递增子序列的长度。
- **代码核心**：
  ```cpp
  int n, a[MN], f[MN], qwq;
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) {
      scanf("%d", a + i);
      f[a[i]] = f[a[i] - 1] + 1;
      qwq = max(f[a[i]], qwq);
  }
  printf("%d\n", n - qwq);
  ```
  **核心思想**：利用 `f[x] = f[x - 1] + 1` 来计算以 `x` 结尾的最长连续递增子序列的长度，并记录最大值。

### 最优关键思路
通过动态规划的思想，利用 `f[x] = f[x - 1] + 1` 来计算以 `x` 结尾的最长连续递增子序列的长度，然后用数列的长度减去这个子序列的长度，即为所需的最小操作次数。

### 拓展思路
类似的问题可以通过寻找最长连续递增子序列来解决，例如在排列中寻找最长的有序子序列，或者在其他需要最小化操作次数的场景中应用。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

---
处理用时：28.99秒
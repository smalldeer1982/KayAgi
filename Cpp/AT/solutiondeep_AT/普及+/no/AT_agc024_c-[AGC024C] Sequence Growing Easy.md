# 题目信息

# [AGC024C] Sequence Growing Easy

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc024/tasks/agc024_c

長さ $ N $ の数列 $ X $ があり、最初はすべての要素が $ 0 $ です。$ X $ の $ i $ 項目を $ X_i $ で表すことにします。

長さ $ N $ の数列 $ A $ が与えられます。$ A $ の $ i $ 項目は $ A_i $ です。 以下の操作を繰り返すことで $ X $ を $ A $ と等しくすることができるかどうか判定し、できるなら最小の操作回数を求めてください。

- $ 1\leq\ i\leq\ N-1 $ なる整数 $ i $ を選ぶ。$ X_{i+1} $ の値を $ X_i $ の値に $ 1 $ を足したもので置き換える。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9(1\leq\ i\leq\ N) $
- 入力はすべて整数である

### Sample Explanation 1

次のようにして、$ X $ を $ A $ と等しくすることができます。 - $ i=2 $ に対して操作する。$ X $ は $ (0,0,1,0) $ となる。 - $ i=1 $ に対して操作する。$ X $ は $ (0,1,1,0) $ となる。 - $ i=3 $ に対して操作する。$ X $ は $ (0,1,1,2) $ となる。

## 样例 #1

### 输入

```
4

0

1

1

2```

### 输出

```
3```

## 样例 #2

### 输入

```
3

1

2

1```

### 输出

```
-1```

## 样例 #3

### 输入

```
9

0

1

1

0

1

2

2

1

2```

### 输出

```
8```

# AI分析结果

### 题目重写
**题目描述**

有一个长度为 $N$ 的数列 $X$，最初所有元素都为 $0$。$X$ 的第 $i$ 个元素记为 $X_i$。

给定一个长度为 $N$ 的数列 $A$，其第 $i$ 个元素为 $A_i$。通过以下操作，判断是否可以将 $X$ 变为 $A$，如果可以，求出最小操作次数。

- 选择一个整数 $i$（$1 \leq i \leq N-1$），将 $X_{i+1}$ 的值替换为 $X_i + 1$。

**说明/提示**

**约束条件**

- $1 \leq N \leq 2 \times 10^5$
- $0 \leq A_i \leq 10^9$（$1 \leq i \leq N$）
- 输入均为整数

**样例解释 1**

通过以下操作，可以将 $X$ 变为 $A$：
- 选择 $i=2$ 进行操作，$X$ 变为 $(0,0,1,0)$。
- 选择 $i=1$ 进行操作，$X$ 变为 $(0,1,1,0)$。
- 选择 $i=3$ 进行操作，$X$ 变为 $(0,1,1,2)$。

**样例 #1**

**输入**

```
4
0
1
1
2
```

**输出**

```
3
```

**样例 #2**

**输入**

```
3
1
2
1
```

**输出**

```
-1
```

**样例 #3**

**输入**

```
9
0
1
1
0
1
2
2
1
2
```

**输出**

```
8
```

### 算法分类
**贪心**

### 题解分析与结论
该题的核心逻辑是通过贪心策略来判断是否可以将初始为 $0$ 的数列 $X$ 通过一系列操作变为给定的数列 $A$，并求出最小操作次数。题解中主要涉及以下要点：

1. **无解情况的判断**：
   - 如果 $A_1 \neq 0$，则无解，因为 $X_1$ 无法被改变。
   - 如果存在 $A_i - A_{i-1} > 1$，则无解，因为每次操作只能使 $X_{i+1}$ 比 $X_i$ 大 $1$。

2. **有解情况的操作次数计算**：
   - 当 $A_i = A_{i-1} + 1$ 时，操作次数增加 $1$。
   - 当 $A_i \leq A_{i-1}$ 时，操作次数增加 $A_i$。

3. **优化与实现**：
   - 大多数题解都采用了从前往后遍历数列 $A$ 的方式，根据上述规则计算操作次数。
   - 部分题解还提到了倒序遍历或利用数组记录某些信息来优化计算。

### 精选题解
#### 题解1：作者：ytb2024 (赞：6)
**星级：5星**
**关键亮点**：
- 清晰的无解判断逻辑。
- 简洁的操作次数计算方式。
- 代码可读性强，使用了 `long long` 类型避免溢出。

**核心代码**：
```cpp
if(a[1]!=0){cout<<-1;return;}
for(int i=2;i<=n;i++)if(a[i]>=a[i-1]+2){cout<<-1;return;}
for(int i=2;i<=n;i++)if(a[i]==a[i-1]+1)ans++;else ans+=a[i];
cout<<ans;
```

#### 题解2：作者：FFTotoro (赞：4)
**星级：4星**
**关键亮点**：
- 提供了详细的样例分析，帮助理解操作过程。
- 代码简洁，使用了 `auto` 关键字简化输入处理。

**核心代码**：
```cpp
if(v[0]){cout<<-1<<endl; return 0;}
for(int i=1;i<n;i++){
    if(v[i]>v[i-1]+1){cout<<-1<<endl; return 0;}
    c+=v[i]>v[i-1]?1:v[i];
}
cout<<c<<endl;
```

#### 题解3：作者：gyh20 (赞：4)
**星级：4星**
**关键亮点**：
- 提出了倒序遍历的思路，优化了操作次数的计算。
- 利用数组记录信息，减少了重复计算。

**核心代码**：
```cpp
for(re int i=1;i<=n;++i){
    a[i]=read();
    if(a[i]>a[i-1]+1)return puts("-1"),0;
    if(a[i])ans+=i-L[a[i]-i+n];
    L[0-i+n]=L[a[i]-i+n]=i;
}
printf("%lld",ans);
```

### 最优关键思路
1. **无解判断**：首先检查 $A_1$ 是否为 $0$，然后检查相邻元素的差值是否大于 $1$。
2. **操作次数计算**：根据 $A_i$ 与 $A_{i-1}$ 的关系，分别累加操作次数。
3. **优化**：倒序遍历或利用数组记录信息，减少重复计算。

### 拓展思路
类似的问题可以考察如何通过有限的操作将一个初始状态变为目标状态，通常涉及贪心或动态规划策略。例如，可以通过类似的操作将一个数组变为另一个数组，或者通过某些规则生成目标序列。

### 推荐题目
1. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)

---
处理用时：38.44秒
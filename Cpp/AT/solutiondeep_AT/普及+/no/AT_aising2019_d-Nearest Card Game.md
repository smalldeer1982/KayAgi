# 题目信息

# Nearest Card Game

## 题目描述

## 题面描述
现在高桥和青木有N张卡片，每张卡片上有一个整数 $ A_i $ ，并且**任意2张卡片**上的整数都不相同

高桥和青木决定用这些卡玩下面这个游戏：

- 首先青木决定了一个整数 $ x $ 。
- **从高桥开始**，每人轮流拿一张卡。此时，取的卡如下选择。
	- 高桥取**剩下**的卡片中写的整数**最大**的卡片。
	- 青木取**剩下**的卡片中写的整数**最接近** $ x $ 的卡片。但是，在有多张这样的卡的情况下，取它们中写的整数**最小**的卡。
	- 剩下的卡数量为零（也就是全被拿走了）时游戏结束。

对于 $ x $ 的值，你将获得 $ Q $ 个候选值：$ X_1,\ X_2,\ ...,\ X_Q $ 。对于每个 $ i $ （ $ 1\ \leq\ i\ \leq\ Q $ ），请找出**当青木所选的 $ x $ 值为 $ X_i $ 时**，高桥所选的所有卡片上整数的和。

## 样例 #1

### 输入

```
5 5

3 5 7 11 13

1

4

9

10

13```

### 输出

```
31

31

27

23

23```

## 样例 #2

### 输入

```
4 3

10 20 30 40

2

34

34```

### 输出

```
70

60

60```

# AI分析结果

### 题目内容
# 最近卡片游戏

## 题目描述

现在高桥和青木有N张卡片，每张卡片上有一个整数 $ A_i $ ，并且**任意2张卡片**上的整数都不相同。

高桥和青木决定用这些卡玩下面这个游戏：

- 首先青木决定了一个整数 $ x $ 。
- **从高桥开始**，每人轮流拿一张卡。此时，取的卡如下选择。
	- 高桥取**剩下**的卡片中写的整数**最大**的卡片。
	- 青木取**剩下**的卡片中写的整数**最接近** $ x $ 的卡片。但是，在有多张这样的卡的情况下，取它们中写的整数**最小**的卡。
	- 剩下的卡数量为零（也就是全被拿走了）时游戏结束。

对于 $ x $ 的值，你将获得 $ Q $ 个候选值：$ X_1,\ X_2,\ ...,\ X_Q $ 。对于每个 $ i $ （ $ 1\ \leq\ i\ \leq\ Q $ ），请找出**当青木所选的 $ x $ 值为 $ X_i $ 时**，高桥所选的所有卡片上整数的和。

## 样例 #1

### 输入

```
5 5

3 5 7 11 13

1

4

9

10

13```

### 输出

```
31

31

27

23

23```

## 样例 #2

### 输入

```
4 3

10 20 30 40

2

34

34```

### 输出

```
70

60

60```

### 算法分类
模拟

### 题解分析与结论
本题的核心在于模拟游戏过程，根据青木选择的 $ x $ 值，模拟高桥和青木轮流取卡的过程，最终计算高桥所取卡片上整数的和。由于每张卡片上的整数唯一，且青木取卡时有明确的规则（最接近 $ x $，若有多张则取最小），因此可以通过排序和模拟来实现。

### 通用建议与扩展思路
1. **排序**：首先对卡片进行排序，方便高桥取最大卡片和青木取最接近 $ x $ 的卡片。
2. **模拟**：模拟游戏过程，轮流取卡，直到所有卡片被取完。
3. **优化**：可以通过预处理或二分查找来优化青木取卡的过程，减少时间复杂度。

### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

### 关键思路与技巧
1. **排序**：对卡片进行排序，方便后续操作。
2. **模拟**：通过循环模拟游戏过程，轮流取卡。
3. **二分查找**：在青木取卡时，使用二分查找快速找到最接近 $ x $ 的卡片。

### 核心代码片段
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int N, Q;
    cin >> N >> Q;
    vector<int> A(N);
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
    }
    sort(A.begin(), A.end());
    
    for (int q = 0; q < Q; ++q) {
        int x;
        cin >> x;
        vector<int> cards = A;
        int sum = 0;
        bool takahashi_turn = true;
        while (!cards.empty()) {
            if (takahashi_turn) {
                sum += cards.back();
                cards.pop_back();
            } else {
                auto it = lower_bound(cards.begin(), cards.end(), x);
                if (it == cards.end()) {
                    --it;
                } else if (it != cards.begin() && abs(*it - x) >= abs(*(it - 1) - x)) {
                    --it;
                }
                cards.erase(it);
            }
            takahashi_turn = !takahashi_turn;
        }
        cout << sum << endl;
    }
    return 0;
}
```

### 代码实现思想
1. **输入与排序**：首先读取卡片数量和候选值数量，然后读取卡片并排序。
2. **模拟游戏**：对于每个候选值 $ x $，模拟游戏过程，轮流取卡，计算高桥所取卡片上整数的和。
3. **输出结果**：输出每个候选值对应的结果。

---
处理用时：30.03秒
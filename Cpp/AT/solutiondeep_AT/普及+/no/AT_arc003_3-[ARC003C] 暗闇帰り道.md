# 题目信息

# [ARC003C] 暗闇帰り道

## 题目描述

## 漆黑归家路



高桥君一个人走夜路从学校回家。



他所居住的城市是一个被分为小格的长方形。高桥君一秒只能向东、南、西、北方向移动一格。



输入给出格子$i,j$的阳光值$c_i,_j$，$t$秒时，该格子的明亮度为$0.99^t×c_i,_j$$（出发时间为$0$秒）。



从学校回到家的路径明亮度为路线所经格子的明亮度的**最小值**。



高桥君有黑暗恐惧症，会尽可能地选择**明亮度大**的路径。



请求出他回家路径中的最大明亮度。

## 说明/提示

- 時刻0: 从学校$(1,1)$出发。

- 時刻1: 移动到$(2,1) $。时间 $t=1$, 阳光值$=7$ 、$(2,1)$ 的明亮度为$6.93$。

- 時刻2: 移动到$(2,2)$ 。时间 $t=2$, 阳光值$=4$ 、$(2,2)$的明亮度为$3.9204$。

- 時刻3: 移动到$(2,3)$ 。时间 $t=3$, 阳光值$=3$、$(2,3)$的明亮度为$2.910897$。

- 時刻4: 回到家$(3,3)$了 。当前最小的明亮值是时间 $t=3$时的$(2,3)$的明亮度为$2.910897$，答案也就是$2.910897$。

![样例1](https://cdn.luogu.org/upload/pic/39444.png)



样例2



输入

```

4 6

g31784

621415

627914

7451s3

```



输出



```

2.97

```



![样例2](https://cdn.luogu.org/upload/pic/39446.png)



不需要解释。

# AI分析结果

### 题目内容重写
高桥君一个人走夜路从学校回家。他所居住的城市是一个被分为小格的长方形。高桥君一秒只能向东、南、西、北方向移动一格。输入给出格子$i,j$的阳光值$c_i,_j$，$t$秒时，该格子的明亮度为$0.99^t×c_i,_j$（出发时间为$0$秒）。从学校回到家的路径明亮度为路线所经格子的明亮度的**最小值**。高桥君有黑暗恐惧症，会尽可能地选择**明亮度大**的路径。请求出他回家路径中的最大明亮度。

### 算法分类
二分 + 广度优先搜索 (BFS)

### 题解分析与结论
本题的核心在于寻找一条从起点到终点的路径，使得路径上所有格子的明亮度的最小值最大。由于明亮度随时间衰减，且路径的选择需要考虑时间的影响，直接使用BFS或DFS难以处理。因此，二分法结合BFS成为一种有效的解决方案。

#### 题解对比
1. **Fijian_Bus的题解**：
   - **思路**：从终点开始反向BFS，记录每个格子的明亮度，并取最小值。
   - **难点**：需要处理明亮度随时间衰减的问题，且路径选择需要考虑时间的影响。
   - **评分**：3星。思路较为直接，但代码实现较为复杂，且未充分利用二分法的优势。

2. **阿丑的题解**：
   - **思路**：使用二分法确定最大明亮度，结合BFS判断是否存在满足条件的路径。
   - **难点**：二分法的应用需要精确判断路径的可行性，且BFS的实现需要考虑时间的影响。
   - **评分**：4星。思路清晰，充分利用了二分法的优势，代码实现较为简洁。

### 最优关键思路
二分法结合BFS是解决本题的关键。通过二分法确定最大明亮度，再利用BFS判断是否存在满足条件的路径，能够有效处理明亮度随时间衰减的问题。

### 可拓展之处
类似的问题可以应用于其他需要考虑时间衰减或路径选择的场景，如资源分配、路径规划等。

### 推荐题目
1. [P1462 通往奥格瑞玛的道路](https://www.luogu.com.cn/problem/P1462)
2. [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)
3. [P1948 [USACO08OPEN]Telephone Lines G](https://www.luogu.com.cn/problem/P1948)

### 个人心得
阿丑的题解中提到，二分法的应用需要精确判断路径的可行性，这一点在实际编码中尤为重要。通过预处理每个时刻的明亮度变化，可以简化后续的计算过程，提高代码的可读性和效率。

### 核心代码片段
```cpp
bool bfs(double a) {
    Q.push(s);
    while(!Q.empty()) Q.pop();
    for(int i=1; i<=n; ++i) for(int j=1; j<=m; ++j) vis[i][j]=0;
    while(!Q.empty()) {
        point p=Q.front(); Q.pop();
        for(int d=0; d<4; ++d) {
            point q=p;
            ++q.t, q.x+=dx[d], q.y+=dy[d];
            if(q.x==g.x && q.y==g.y) return 1;
            if(!vis[q.x][q.y] && mp[q.x][q.y]*db[q.t]>=a) Q.push(q), vis[q.x][q.y]=1;
        }
    }
    return 0;
}
```
这段代码实现了二分法结合BFS的核心逻辑，通过判断是否存在满足条件的路径来确定最大明亮度。

---
处理用时：24.95秒
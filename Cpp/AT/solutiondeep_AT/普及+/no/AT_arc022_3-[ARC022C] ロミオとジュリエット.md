# 题目信息

# [ARC022C] ロミオとジュリエット

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc022/tasks/arc022_3

高橋王国には $ N $ 個の村があり、$ 1 $ から $ N $ の番号がついています。$ N-1 $ 組の村の間は道で繋がっていて、どの村と村の間も道をいくつか辿ることによって移動できるようになっています。

高橋王国に住んでいるロミオさんとジュリエット君が引っ越しをすることになりました。$ 2 $ 人はとても仲が悪いので出来るだけ離れた村に引っ越したいと思っています。あなたは、$ 2 $ 人がそれぞれどの村に引っ越せば $ 2 $ 人の住む村の間の距離が最大になるのかを計算してあげてください。ただし「村の間の距離」とは、片方の村からもう片方の村まで行くために通る必要のある道の本数であるとします。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ N\ ≦\ 1,000 $ を満たすテストケースすべてに正解した場合は $ 40 $ 点が与えられる。

### Sample Explanation 1

!\[\](/img/arc/022/3-1.png) この入力では、高橋王国は図のような構造をしている。 「10 5」と出力しても正解である。

### Sample Explanation 2

!\[\](/img/arc/022/3-2.png) この入力では、高橋王国は図のような構造をしている。 「2 3」「3 2」「2 4」「4 2」「3 4」と出力しても正解である。

## 样例 #1

### 输入

```
10

7 6

3 2

2 4

4 5

8 9

1 8

1 6

1 2

9 10```

### 输出

```
5 10```

## 样例 #2

### 输入

```
4

1 2

1 3

1 4```

### 输出

```
4 3```

# AI分析结果

### 题目内容重写

高桥王国中有 $N$ 个村庄，编号从 $1$ 到 $N$。这些村庄之间通过 $N-1$ 条道路相连，使得任意两个村庄之间都可以通过若干条道路相互到达。

高桥王国中的罗密欧和朱丽叶决定搬家。由于他们关系非常不好，因此希望尽可能远离对方。你需要计算他们分别应该搬到哪个村庄，使得他们之间的村庄距离最大。这里的“村庄距离”指的是从一个村庄到另一个村庄需要经过的道路数量。

### 算法分类
图论、深度优先搜索（DFS）、广度优先搜索（BFS）

### 题解分析与结论
由于题目描述的是一个树结构，要求找到树中距离最远的两个节点（即树的直径）。解决这类问题的经典方法是两次BFS或两次DFS：

1. 第一次BFS/DFS：从任意一个节点出发，找到距离最远的节点A。
2. 第二次BFS/DFS：从节点A出发，找到距离最远的节点B。
3. 节点A和节点B之间的路径即为树的直径。

这种方法的时间复杂度为 $O(N)$，适合处理大规模数据。

### 通用建议与扩展思路
1. **树的直径**：理解并掌握树的直径的定义及其求解方法，是解决此类问题的关键。
2. **BFS与DFS的选择**：在树结构中，BFS和DFS都可以用来求解树的直径，但BFS通常更容易实现且不易出错。
3. **拓展应用**：树的直径问题可以扩展到其他图论问题，如最短路径、中心节点等。

### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)
3. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

### 关键代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
vector<int> adj[MAXN];
int dist[MAXN];

void bfs(int start) {
    memset(dist, -1, sizeof(dist));
    queue<int> q;
    q.push(start);
    dist[start] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
}

int main() {
    int N;
    cin >> N;
    for (int i = 1; i < N; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    bfs(1);
    int farthest = max_element(dist + 1, dist + N + 1) - dist;
    
    bfs(farthest);
    int diameter = *max_element(dist + 1, dist + N + 1);
    int end = max_element(dist + 1, dist + N + 1) - dist;
    
    cout << farthest << " " << end << endl;
    return 0;
}
```

### 代码核心思想
1. **BFS函数**：从给定的起点出发，计算每个节点到起点的距离。
2. **主函数**：首先从任意节点（如1）进行BFS，找到距离最远的节点；然后从该节点再次进行BFS，找到最远的节点，这两个节点即为树的直径的两端。

---
处理用时：25.35秒
# 题目信息

# [ARC024B] 赤と黒の木

## 题目描述

在红黑岛上生长着一种奇特的树，它们的颜色会在红色和黑色之间变化。这些树以一个圆圈的形式排列在岛上。

这种树具有独特的“平衡”特性：如果一棵树和它相邻的两棵树颜色相同，那么第二天这棵树的颜色会改变。具体来说，假设有三棵连续的树 $A, B, C$，它们的颜色分别为 $C_A, C_B, C_C$。如果当天三棵树的颜色都为红色，即 $C_A = C_B = C_C = $ 红色，那么第二天 $C_B$ 的颜色会变为黑色，反之亦然。

需要注意的是，这些树在“平衡”时，只根据当天自己的颜色情况来做决定，而不考虑邻居的变化。因此，即便经过一天，也可能出现三个连续的同色树（请参见示例）。在这种情况下，第二天也会继续“平衡”。

作为研究者，你已经观察到了由 $N$ 棵树组成的这个群体第一天的颜色分布。请你计算出经过多少天这些树的颜色才不再变化。

## 说明/提示

### 示例解释

#### 示例 1
如图所示，变化停留在第二天。
- 第一天，第 3 棵树与其相邻的树颜色相同，因此颜色改变。
- 从第二天开始，颜色不再变化。

#### 示例 2
如图所示。注意第 6 棵树和第 1 棵树是相邻的。
- 第一天，第 1、5 和 6 棵树因为与相邻树相同颜色，因此颜色改变。
- 第二天，第 6 棵树颜色改变。
- 从第三天开始，颜色不再变化。

#### 示例 3
所有树仅在全黑或全红两种状态间交替。


 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5

0

1

1

1

0```

### 输出

```
2```

## 样例 #2

### 输入

```
6

1

1

0

1

1

1```

### 输出

```
3```

## 样例 #3

### 输入

```
3

1

1

1```

### 输出

```
-1```

# AI分析结果

### 题目内容重写
在红黑岛上生长着一种奇特的树，它们的颜色会在红色和黑色之间变化。这些树以一个圆圈的形式排列在岛上。

这种树具有独特的“平衡”特性：如果一棵树和它相邻的两棵树颜色相同，那么第二天这棵树的颜色会改变。具体来说，假设有三棵连续的树 $A, B, C$，它们的颜色分别为 $C_A, C_B, C_C$。如果当天三棵树的颜色都为红色，即 $C_A = C_B = C_C = $ 红色，那么第二天 $C_B$ 的颜色会变为黑色，反之亦然。

需要注意的是，这些树在“平衡”时，只根据当天自己的颜色情况来做决定，而不考虑邻居的变化。因此，即便经过一天，也可能出现三个连续的同色树（请参见示例）。在这种情况下，第二天也会继续“平衡”。

作为研究者，你已经观察到了由 $N$ 棵树组成的这个群体第一天的颜色分布。请你计算出经过多少天这些树的颜色才不再变化。

### 算法分类
模拟

### 题解分析与结论
该题的核心在于模拟树的颜色变化过程，直到颜色不再变化为止。难点在于如何处理循环排列的树，以及如何高效地模拟颜色的变化。

#### 题解1：残阳如血
**星级：4.5**
**关键亮点：**
1. **破环成链**：通过复制序列并找到分界线，将循环序列转化为线性序列，简化了问题。
2. **分块处理**：将序列分为多个颜色相同的块，分别计算每个块的稳定天数，最后取最大值。
3. **公式推导**：通过分析块长度的奇偶性，推导出稳定天数的公式，提高了计算效率。

**个人心得：**
- 强调了数组大小的重要性，提醒数组要开到两倍大小，避免越界问题。
- 通过图示直观地展示了颜色变化的过程，帮助理解问题。

**核心代码：**
```cpp
int main() {
    std::cin >> n;
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i], a[i + n] = a[i]; // 复制并放到后面
        if (i > 1 && a[i] != a[i - 1]) p = i; // 找到分界线
    }
    if (!p) return std::cout << "-1\n", 0; // 找不到分界线
    
    for (int i = p + 1; i <= n + p; ++i) {
        if (i > p && a[i] == a[i - 1]) ++cnt; // 在同一个块中
        else ans = std::max(ans, cnt + 1 >> 1), cnt = 1; // 统计答案，重置计数器
    }
    
    std::cout << ans << std::endl;
    return 0;
}
```

### 最优关键思路
1. **破环成链**：通过复制序列并找到分界线，将循环序列转化为线性序列，简化了问题。
2. **分块处理**：将序列分为多个颜色相同的块，分别计算每个块的稳定天数，最后取最大值。
3. **公式推导**：通过分析块长度的奇偶性，推导出稳定天数的公式，提高了计算效率。

### 可拓展之处
类似的问题可以通过分块处理和公式推导来解决，例如处理循环数组中的连续相同元素问题。此外，模拟类问题中，通过复制序列来简化循环处理也是一种常见技巧。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)

---
处理用时：28.44秒
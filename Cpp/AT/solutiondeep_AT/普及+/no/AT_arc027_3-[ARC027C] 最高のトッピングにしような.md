# 题目信息

# [ARC027C] 最高のトッピングにしような

## 题目描述

在我常去的一家餐馆里，用餐可以获得兑换券。

兑换券有两种类型：一种是提供额外功能的“特殊兑换券”，另一种是“普通兑换券”。

这家餐馆提供 $N$ 种配料，你可以用 $t_i$ 张票券换得每种配料 $i$。在组合兑换中，同一种配料不可重复获取。兑换时，尽管两种类型的兑换券等值，但需保证每种配料的兑换至少包含一张“特殊兑换券”。例如，若某种配料需要 4 张票券，有以下 4 种兑换组合：

- 1 张特殊兑换券和 3 张普通兑换券。
- 2 张特殊兑换券和 2 张普通兑换券。
- 3 张特殊兑换券和 1 张普通兑换券。
- 全用 4 张特殊兑换券。

每种配料都有各自的“快乐值”，用 $h_i$ 表示获取配料 $i$ 时的快乐值。

今天是个特别的日子，我希望通过合理利用现有的兑换券，最大化兑换配料带来的总快乐值。请设计一个程序，计算出在当前的票券和配料信息下，能够获取的最大快乐值。

## 说明/提示

### 部分得分

题目设有部分得分：

- 对于数据集 1，满足条件 $X \leq 50$，$Y \leq 50$，$N \leq 50$，$t_i \leq 100$ 的正确解答可以获得 30 分。
- 对于没有额外限制的通用数据集 2，正确解答可以获得 70 分。

### 样例解释

- 初始有 3 张特殊兑换券和 5 张普通兑换券。通过以下组合可以得到最大快乐值 100（即40 + 60）：
  - 使用 1 张特殊兑换券和 2 张普通兑换券兑换配料 2（需 3 张票券），获得快乐值 40。
  - 使用 2 张特殊兑换券和 3 张普通兑换券兑换配料 3（需 5 张票券），获得快乐值 60。
  这个组合用掉了 3 张特殊和 5 张普通兑换券，是可行的。

- 最优选择是获取配料 1 和配料 2。

- 选择配料 3，并留下一张票券，是最优解。

- 可以获取所有的配料。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 5

4

3 30

3 40

5 60

7 80```

### 输出

```
100```

## 样例 #2

### 输入

```
3 3

4

3 30

3 40

5 60

7 80```

### 输出

```
70```

## 样例 #3

### 输入

```
1 5

4

3 30

3 40

5 60

7 80```

### 输出

```
60```

## 样例 #4

### 输入

```
6 12

4

3 30

3 40

5 60

7 80```

### 输出

```
210```

# AI分析结果

### 题目内容重写

【题目描述】

在我常去的一家餐馆里，用餐可以获得兑换券。

兑换券有两种类型：一种是提供额外功能的“特殊兑换券”，另一种是“普通兑换券”。

这家餐馆提供 $N$ 种配料，你可以用 $t_i$ 张票券换得每种配料 $i$。在组合兑换中，同一种配料不可重复获取。兑换时，尽管两种类型的兑换券等值，但需保证每种配料的兑换至少包含一张“特殊兑换券”。例如，若某种配料需要 4 张票券，有以下 4 种兑换组合：

- 1 张特殊兑换券和 3 张普通兑换券。
- 2 张特殊兑换券和 2 张普通兑换券。
- 3 张特殊兑换券和 1 张普通兑换券。
- 全用 4 张特殊兑换券。

每种配料都有各自的“快乐值”，用 $h_i$ 表示获取配料 $i$ 时的快乐值。

今天是个特别的日子，我希望通过合理利用现有的兑换券，最大化兑换配料带来的总快乐值。请设计一个程序，计算出在当前的票券和配料信息下，能够获取的最大快乐值。

### 算法分类

动态规划

### 题解分析与结论

该题目是一个典型的动态规划问题，核心在于如何合理分配特殊兑换券和普通兑换券，以最大化快乐值。题解中使用了三维动态规划的思路，通过滚动数组优化空间复杂度。

### 所选高分题解

#### 题解作者：ycy1124 (赞：2)

**星级：4星**

**关键亮点：**
1. 使用了三维动态规划的思路，状态定义为 `dp[i][j][k]`，表示到第 $i$ 个配料，使用了 $j$ 张特殊兑换券和 $k$ 张总兑换券时的最大快乐值。
2. 通过滚动数组优化空间复杂度，减少了内存使用。
3. 代码结构清晰，逻辑严密，易于理解。

**核心代码实现思想：**
```cpp
int dp[2][305][605];
for(int i=1;i<=n;i++){
    int t,h;
    cin>>h>>t;
    sum+=h;
    for(int j=min(i,x);j>=0;j--){
        for(int k=min(sum,x+y);k>=0;k--){
            if(j<=0||k<h){
                dp[i%2][j][k]=max(dp[i%2][j][k],dp[i%2^1][j][k]);
                continue;
            }
            dp[i%2][j][k]=max(dp[i%2^1][j-1][k-h]+t,max(dp[i%2][j][k],dp[i%2^1][j][k]));
            ans=max(dp[i%2][j][k],ans);
        }
    }
}
```

**个人心得：**
作者在调试过程中发现，如果不使用滚动数组，内存会超出限制。通过优化，成功解决了这一问题。

### 最优关键思路或技巧

1. **三维动态规划**：通过定义 `dp[i][j][k]` 状态，合理分配特殊兑换券和普通兑换券，确保每种配料至少包含一张特殊兑换券。
2. **滚动数组优化**：通过滚动数组减少空间复杂度，避免内存超限。
3. **边界条件处理**：在处理边界条件时，确保不会出现负数索引，避免程序崩溃。

### 可拓展之处

1. **类似问题**：可以拓展到其他资源分配问题，如背包问题、任务调度问题等。
2. **优化技巧**：滚动数组优化技巧可以应用于其他需要减少空间复杂度的动态规划问题。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的背包问题，与本题类似。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 资源分配问题，与本题类似。
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164) - 动态规划问题，与本题类似。

---
处理用时：29.70秒
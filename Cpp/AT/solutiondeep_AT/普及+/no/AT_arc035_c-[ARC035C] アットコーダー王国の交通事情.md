# 题目信息

# [ARC035C] アットコーダー王国の交通事情

## 题目描述

高桥君是 Atcoder 王国的国王。Atcoder 王国包括$N$个城市（编号$1$~$N$）和$m$条双向的道路。每条道路都有长度。对于 Atcoder 王国中的任意城市 [A,B]，都可以保证从$A$到$B$有多条道路。



高桥君认为，Atcoder人的幸福在很大程度上取决于交通的便利性。为了找出人们的幸福程度，他想找到所有可能城市之间最短路径长度的总和$S$。



如果城市i和j之间的最短路径的长度为 D(i,j)，则



![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT1215/c6cb071ff4a2960ab2be46d08083e517ddb9f45e.png)



高桥先生正计划建造K条新道路作为公共项目。这样的建设可能会导致多于两条或两条直接连接城市的道路，在这种情况下，现有道路将不会被拆除，而是会被增加。



您的任务是按照给定的顺序建造一条新路，并编写一个程序来计算上述每种施工的S。

## 样例 #1

### 输入

```
4 3

1 2 1

2 3 1

3 4 10

2

3 4 1

1 4 1```

### 输出

```
10

8```

## 样例 #2

### 输入

```
8 16

8 7 38

2 8 142

5 2 722

8 6 779

4 6 820

1 3 316

1 7 417

8 3 41

1 4 801

3 2 126

4 2 71

8 4 738

4 3 336

7 5 717

5 6 316

2 1 501

10

6 1 950

6 1 493

1 6 308

3 4 298

2 5 518

1 5 402

4 7 625

7 6 124

3 8 166

2 4 708```

### 输出

```
13649

12878

11954

11954

11280

11058

11058

8099

8099

8099```

# AI分析结果

### 题目内容重写
高桥君是 Atcoder 王国的国王。Atcoder 王国包括$N$个城市（编号$1$~$N$）和$m$条双向的道路。每条道路都有长度。对于 Atcoder 王国中的任意城市 [A,B]，都可以保证从$A$到$B$有多条道路。

高桥君认为，Atcoder人的幸福在很大程度上取决于交通的便利性。为了找出人们的幸福程度，他想找到所有可能城市之间最短路径长度的总和$S$。

如果城市i和j之间的最短路径的长度为 D(i,j)，则

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT1215/c6cb071ff4a2960ab2be46d08083e517ddb9f45e.png)

高桥先生正计划建造K条新道路作为公共项目。这样的建设可能会导致多于两条或两条直接连接城市的道路，在这种情况下，现有道路将不会被拆除，而是会被增加。

您的任务是按照给定的顺序建造一条新路，并编写一个程序来计算上述每种施工的S。

### 样例 #1

#### 输入
```
4 3
1 2 1
2 3 1
3 4 10
2
3 4 1
1 4 1
```

#### 输出
```
10
8
```

### 样例 #2

#### 输入
```
8 16
8 7 38
2 8 142
5 2 722
8 6 779
4 6 820
1 3 316
1 7 417
8 3 41
1 4 801
3 2 126
4 2 71
8 4 738
4 3 336
7 5 717
5 6 316
2 1 501
10
6 1 950
6 1 493
1 6 308
3 4 298
2 5 518
1 5 402
4 7 625
7 6 124
3 8 166
2 4 708
```

#### 输出
```
13649
12878
11954
11954
11280
11058
11058
8099
8099
8099
```

### 算法分类
最短路

### 题解分析与结论
本题的核心问题是在动态添加边的情况下，维护所有城市对之间的最短路径，并计算其总和。两个题解分别使用了 SPFA 和 Floyd 算法来解决这个问题。

1. **_Kenma_ 的题解**：
   - 使用 SPFA 算法，每次添加新边后，从两个端点出发重新计算最短路径。
   - 通过优化，使得每次松弛操作的复杂度为线性，总体复杂度为 $O(n^2k)$。
   - 代码实现较为简洁，但 SPFA 算法在最坏情况下可能退化为 $O(nm)$。

2. **AkeuchiTsuzuri 的题解**：
   - 使用 Floyd 算法预处理所有城市对之间的最短路径，然后在每次添加新边时，通过松弛操作更新最短路径。
   - 总体复杂度为 $O(n^3 + k \times n^2)$，对于题目给定的数据范围完全可行。
   - 代码实现清晰，Floyd 算法在稠密图中表现良好。

### 评分与关键亮点
- **_Kenma_ 的题解**：4星
  - 关键亮点：使用 SPFA 算法，并通过优化使得每次松弛操作的复杂度为线性。
  - 个人心得：提到每次写 Floyd 都会写假，因此选择 SPFA。

- **AkeuchiTsuzuri 的题解**：5星
  - 关键亮点：使用 Floyd 算法预处理，并在每次添加新边时通过松弛操作更新最短路径，代码清晰且效率高。

### 最优关键思路或技巧
- **Floyd 算法**：在预处理阶段计算所有城市对之间的最短路径，然后在每次添加新边时，通过松弛操作更新最短路径。这种方法在稠密图中表现良好，且代码实现简洁。
- **SPFA 算法**：通过优化使得每次松弛操作的复杂度为线性，适用于稀疏图，但在最坏情况下可能退化为 $O(nm)$。

### 可拓展之处
- 类似的问题可以扩展到其他图论算法，如 Dijkstra 算法、Bellman-Ford 算法等。
- 在实际应用中，可以根据图的稀疏程度选择合适的算法，以平衡时间复杂度和空间复杂度。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得摘录
- **_Kenma_ 的题解**：提到每次写 Floyd 都会写假，因此选择 SPFA。这表明在实际编程中，选择熟悉的算法可以提高代码的正确性和效率。
- **AkeuchiTsuzuri 的题解**：通过 Floyd 算法预处理，并在每次添加新边时通过松弛操作更新最短路径，代码清晰且效率高。这表明在稠密图中，Floyd 算法是一个可靠的选择。

---
处理用时：36.37秒
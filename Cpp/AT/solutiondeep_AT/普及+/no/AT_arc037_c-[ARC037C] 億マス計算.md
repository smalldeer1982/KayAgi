# 题目信息

# [ARC037C] 億マス計算

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc037/tasks/arc037_c

高橋君は「$ N^2 $マス計算」で計算力をつけることにした。「$ N^2 $マス計算」は $ N $ 行 $ N $ 列の表を用意して行う。 $ i $ 行目の左端のマスのさらに左には数 $ a_i $ が書かれており、 $ j $ 列目の上端のマスのさらに上には数 $ b_j $ が書かれている。高橋君はこの表の $ i $ 行 $ j $ 列目 に $ a_i\ ×\ b_j $ の値を計算して書き込む。

すぐに解き終わってしまい退屈したので、高橋君は自分が書き込んだ $ N^2 $ 個の値を昇順に並べ替えることにした。並べ替えた結果小さい方から $ K $ 番目 ($ 1 $ 番から数える) に位置する値を求めよ。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 5 $ 点分のテストケースは $ 1 $ $ ≦ $ $ N $ $ ≦ $ $ 10 $ を満たす。

### Sample Explanation 1

!\[\](http://arc037.contest.atcoder.jp/img/arc/037/ljlefijfewkjfwefk/C\_sample1.png) 高橋君が書き込んだ値を昇順に並べ替えると $ 6,\ 9,\ 10,\ 15 $ となり、小さい方から $ 3 $ 番目の値は $ 10 $ となる。

### Sample Explanation 2

!\[\](http://arc037.contest.atcoder.jp/img/arc/037/ljlefijfewkjfwefk/C\_sample2.png) 高橋君が書き込んだ値を昇順に並べ替えると $ 1,\ 1,\ 2,\ 2,\ 2,\ 2,\ 2,\ 4,\ 4 $ となり、小さい方から $ 7 $ 番目の値は $ 2 $ となる。

## 样例 #1

### 输入

```
2 3

2 3

3 5```

### 输出

```
10```

## 样例 #2

### 输入

```
3 7

1 2 1

2 1 2```

### 输出

```
2```

## 样例 #3

### 输入

```
4 8

701687787 500872619 516391519 599949380

458299111 633119409 377269575 717229869```

### 输出

```
317112176525562171```

# AI分析结果

### 题目内容重写
高橋君为了提升计算能力，决定进行“$N^2$ マス計算”。他准备了一个 $N$ 行 $N$ 列的表。第 $i$ 行最左边的格子左侧写有数字 $a_i$，第 $j$ 列最上方的格子上方写有数字 $b_j$。高橋君在表的第 $i$ 行第 $j$ 列的格子中填入 $a_i \times b_j$ 的值。

高橋君很快完成了计算，觉得无聊，于是决定将填入的 $N^2$ 个值按升序排列，并找出第 $K$ 小的值。

### 算法分类
二分

### 题解分析与结论
所有题解均采用了二分查找的思路，结合对数组的排序和二分查找来优化时间复杂度。主要思路是通过二分答案，然后利用二分查找在 $b$ 数组中统计满足条件的元素个数，最终确定第 $K$ 小的值。

### 所选高星题解
#### 题解1：yzx3195 (4星)
**关键亮点**：
- 使用二分答案结合二分查找，思路清晰。
- 代码结构简洁，易于理解。
- 通过 `check` 函数统计满足条件的元素个数，逻辑明确。

**核心代码**：
```cpp
bool check(int midl) {
    int cnt = 0;
    for(int i = 1; i <= n; i++) {
        int l = 1, r = n, lim = midl / a[i];
        while(l <= r) {
            int mid = (l + r) >> 1;
            if(lim >= b[mid]) l = mid + 1;
            else r = mid - 1;
        }
        cnt += (r);
    }
    return cnt >= k;
}
```

#### 题解2：_czy (4星)
**关键亮点**：
- 使用 `upper_bound` 简化了二分查找的实现。
- 代码简洁，逻辑清晰。
- 通过 `check` 函数快速统计满足条件的元素个数。

**核心代码**：
```cpp
bool check(ll x){
    int s=0;
    for(int i=1;i<=n;i++){
        s+=upper_bound(b+1,b+n+1,x/a[i])-b-1;
    }
    return s>=k;
}
```

#### 题解3：UnfortunatelyDead (4星)
**关键亮点**：
- 使用 `upper_bound` 优化了二分查找的实现。
- 代码结构清晰，逻辑明确。
- 通过 `check` 函数快速统计满足条件的元素个数。

**核心代码**：
```cpp
auto check = [&](int x) -> bool {
    int cnt = 0;
    for (int i = 1; i <= n; ++i) cnt += upper_bound(b + 1, b + 1 + n, x / a[i]) - b - 1;
    return cnt >= k;
};
```

### 最优关键思路或技巧
- **二分答案**：通过二分查找确定第 $K$ 小的值，结合二分查找在 $b$ 数组中统计满足条件的元素个数。
- **排序优化**：对 $b$ 数组进行排序，利用其单调性进行二分查找，提升效率。
- **代码简洁性**：使用 `upper_bound` 等 STL 函数简化代码实现，提高可读性。

### 可拓展之处
- 类似问题可以扩展到多维数组或更复杂的计算场景，依然可以通过二分查找和排序优化来解决。
- 可以进一步优化二分查找的边界条件，减少不必要的计算。

### 推荐题目
1. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)
3. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)

---
处理用时：26.58秒
# 题目信息

# [ARC041C] ウサギ跳び

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc041/tasks/arc041_c

$ L $ 個のマスが横一列に並んでいる。 マスの上には $ N $ 匹のウサギがいる。 $ i $ ($ 1≦i≦N $) 番目のウサギは、左から $ x_i $ 番目のマスにいる。 ただし、$ 1≦x_1\ <\ x_2\ <\ ..\ <\ x_N≦L $ を満たす。 また、ウサギはそれぞれ左向きまたは右向きである。

それぞれのウサギは、自分の $ 1 $ つ前にマスが存在し、そこに他のウサギがいなければ、ジャンプして自分の $ 1 $ つ前のマスへ移動できる。

ウサギがジャンプする順番を自由に選べるとき、ジャンプの総回数の最大値を求めよ。

## 说明/提示

### Sample Explanation 1

図のようにジャンプすればよい。 !\[\](https://arc041.contest.atcoder.jp/img/arc/041/qawsedrftgyhujikolp/rabbit\_1.png)

### Sample Explanation 2

図のようにジャンプすればよい。 !\[\](https://arc041.contest.atcoder.jp/img/arc/041/qawsedrftgyhujikolp/rabbit\_2.png)

### Sample Explanation 3

どのウサギもジャンプできない。

## 样例 #1

### 输入

```
1 5

1 R```

### 输出

```
4```

## 样例 #2

### 输入

```
4 5

1 R

3 L

4 L

5 L```

### 输出

```
3```

## 样例 #3

### 输入

```
4 10

1 L

5 R

6 L

10 R```

### 输出

```
0```

# AI分析结果

### 题目内容重写

#### [ARC041C] ウサギ跳び

**题目描述**

有 $L$ 个格子排成一列。格子上有 $N$ 只兔子。第 $i$ ($1 \leq i \leq N$) 只兔子位于从左数第 $x_i$ 个格子上。且满足 $1 \leq x_1 < x_2 < \dots < x_N \leq L$。每只兔子要么朝左，要么朝右。

每只兔子如果前方有一个格子且该格子上没有其他兔子，那么它可以跳跃到前方的格子上。

当可以自由选择兔子跳跃的顺序时，求跳跃总次数的最大值。

**样例解释**

- **样例1**：通过跳跃可以得到最大跳跃次数。
- **样例2**：通过跳跃可以得到最大跳跃次数。
- **样例3**：没有兔子可以跳跃。

**样例输入输出**

- **样例1**：
  - 输入：
    ```
    1 5
    1 R
    ```
  - 输出：
    ```
    4
    ```

- **样例2**：
  - 输入：
    ```
    4 5
    1 R
    3 L
    4 L
    5 L
    ```
  - 输出：
    ```
    3
    ```

- **样例3**：
  - 输入：
    ```
    4 10
    1 L
    5 R
    6 L
    10 R
    ```
  - 输出：
    ```
    0
    ```

### 算法分类

**贪心**

### 综合分析与结论

该题的核心在于如何安排兔子的跳跃顺序，使得跳跃总次数最大化。由于每只兔子的跳跃行为会影响到其他兔子的跳跃机会，因此需要一种策略来最大化整体的跳跃次数。

由于题目中没有给出具体的题解，我们可以通过分析题目的性质来推导出解题思路。

### 关键思路

1. **贪心策略**：为了使跳跃次数最大化，应该优先让那些能够跳跃的兔子先跳跃，这样可以减少对其他兔子的影响。具体来说，可以按照兔子的位置和方向进行排序，优先让那些能够跳跃的兔子先跳跃。

2. **模拟跳跃过程**：可以通过模拟兔子的跳跃过程来计算最大跳跃次数。具体来说，可以遍历所有兔子，检查每只兔子是否可以跳跃，如果可以则跳跃，并更新其他兔子的位置信息。

3. **跳跃顺序的选择**：跳跃顺序的选择对结果有重要影响。应该优先让那些跳跃后不会影响其他兔子跳跃的兔子先跳跃。

### 通用建议与扩展思路

- **模拟与贪心结合**：在实际编程中，可以通过模拟跳跃过程并结合贪心策略来实现。具体来说，可以维护一个数组记录每只兔子的位置和方向，然后按照一定的顺序进行跳跃。

- **优化跳跃顺序**：可以通过优化跳跃顺序来进一步提高效率。例如，可以优先让那些跳跃后不会影响其他兔子跳跃的兔子先跳跃。

### 推荐题目

1. **洛谷 P1007 独木桥**：考察贪心策略和模拟过程。
2. **洛谷 P1012 拼数**：考察贪心策略和排序。
3. **洛谷 P1090 合并果子**：考察贪心策略和优先队列的使用。

### 个人心得

在解决这类问题时，贪心策略往往能够提供一种简单而有效的解决方案。通过优先处理那些能够带来最大收益的操作，可以有效地减少问题的复杂性。同时，模拟过程可以帮助我们更好地理解问题的本质，并验证我们的策略是否正确。

### 核心代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int L, N;
    cin >> L >> N;
    vector<pair<int, char>> rabbits(N);
    for (int i = 0; i < N; ++i) {
        cin >> rabbits[i].first >> rabbits[i].second;
    }

    int jumps = 0;
    while (true) {
        bool moved = false;
        for (int i = 0; i < N; ++i) {
            int pos = rabbits[i].first;
            char dir = rabbits[i].second;
            if (dir == 'R' && pos < L) {
                bool canJump = true;
                for (int j = 0; j < N; ++j) {
                    if (j != i && rabbits[j].first == pos + 1) {
                        canJump = false;
                        break;
                    }
                }
                if (canJump) {
                    rabbits[i].first++;
                    jumps++;
                    moved = true;
                }
            } else if (dir == 'L' && pos > 1) {
                bool canJump = true;
                for (int j = 0; j < N; ++j) {
                    if (j != i && rabbits[j].first == pos - 1) {
                        canJump = false;
                        break;
                    }
                }
                if (canJump) {
                    rabbits[i].first--;
                    jumps++;
                    moved = true;
                }
            }
        }
        if (!moved) break;
    }

    cout << jumps << endl;
    return 0;
}
```

**核心实现思想**：通过模拟每只兔子的跳跃过程，检查每只兔子是否可以跳跃，如果可以则跳跃，并更新跳跃次数。重复这个过程直到没有兔子可以跳跃为止。

---
处理用时：38.25秒
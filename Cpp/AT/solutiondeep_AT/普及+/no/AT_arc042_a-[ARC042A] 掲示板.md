# 题目信息

# [ARC042A] 掲示板

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc042/tasks/arc042_a

$ 1 $ から $ N $ までの番号がついたスレッドのある掲示板があります。 スレッドは書き込みがあると一番上に来ます。 書き込み前のスレッドは上から順に $ 1 $ から $ N $ の順に並んでいました。 $ M $ 個の書き込みが書き込まれた順で与えられるので、全ての書き込みが終わった後のスレッドの順番を出力してください。

例えば、$ 3 $ 個のスレッドがある掲示板に $ 2 $、$ 3 $、$ 1 $ の順で書き込みがあると、以下のようになります。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc042_a/bac8cb43a2c36713e87d6142d247ade9a4ca302d.png)

従って、書き込み後のスレッドの順番は $ 1 $、$ 3 $、$ 2 $ となります。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1\ ≦\ N\ ≦\ 100,\ 1\ ≦\ M\ ≦\ 100 $ を満たすデータセットに正解した場合は $ 30 $ 点が与えられる。

### Sample Explanation 1

$ 1 $ つめの書き込みの後、スレッドは上から $ 2 $、$ 1 $、$ 3 $ の順で並んでいる。 $ 2 $ つめの書き込みの後、スレッドは上から $ 3 $、$ 2 $、$ 1 $ の順で並んでいる。 $ 3 $ つめの書き込みの後、スレッドは上から $ 1 $、$ 3 $、$ 2 $ の順で並んでいる。

### Sample Explanation 2

元から $ 1 $ 番上にあったスレッド $ 1 $ にしか書き込みがなかったので、スレッドの順番は変わらない。

## 样例 #1

### 输入

```
3 3

2

3

1```

### 输出

```
1

3

2```

## 样例 #2

### 输入

```
3 3

1

1

1```

### 输出

```
1

2

3```

## 样例 #3

### 输入

```
10 10

3

1

4

1

5

9

2

6

5

3```

### 输出

```
3

5

6

2

9

1

4

7

8

10```

# AI分析结果

### 题目内容重写
题目描述：  
有一个从1到N编号的线程的公告板。当有新的帖子发布时，线程会被移动到最前面。在发布帖子之前，线程是按1到N的顺序排列的。给出M个按发布顺序排列的帖子，请输出所有帖子发布后线程的顺序。

例如，有3个线程的公告板，按2、3、1的顺序发布帖子，结果如下：  
![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc042_a/bac8cb43a2c36713e87d6142d247ade9a4ca302d.png)  
因此，发布后的线程顺序是1、3、2。

### 算法分类
模拟

### 题解分析与结论
该题的核心逻辑是模拟线程的移动过程，即每次有新的帖子发布时，将该线程移动到最前面。题解中主要有以下几种思路：
1. **倒序输出法**：从最后一个帖子开始倒序输出，使用标记数组记录已经输出的线程，最后按顺序输出未标记的线程。
2. **链表法**：使用链表模拟线程的移动过程，每次将指定线程移动到链表头部。
3. **栈法**：利用栈的后进先出特性，将帖子按顺序压入栈中，然后依次弹出并输出，最后按顺序输出未处理的线程。

这些方法的共同点是都利用了“后发布的线程在前”的特性，通过不同的数据结构实现模拟。倒序输出法简单直观，链表法虽然复杂但更贴近实际场景，栈法则利用了数据结构的特性。

### 评分较高的题解
1. **作者：Harry27182 (5星)**  
   - **关键亮点**：思路清晰，代码简洁，使用倒序输出法和标记数组，避免了重复输出。
   - **核心代码**：
     ```cpp
     for(int i=m;i>=1;i--) {
         if(b[a[i]]==true) continue;
         b[a[i]]= true;
         cout<<a[i]<<endl;
     }
     for(int i=1;i<=n;i++) {
         if(b[i]==true) continue;
         cout<<i<<endl;
     }
     ```

2. **作者：MZY666 (4星)**  
   - **关键亮点**：思路与Harry27182类似，但代码更详细，适合初学者理解。
   - **核心代码**：
     ```cpp
     for(i=m;i>=1;i--) {
         if(!used[a[i]]) {
             printf("%d\n",a[i]);
             used[a[i]]=true;
         }
     }
     for(i=1;i<=n;i++) {
         if(!used[i]) printf("%d\n",i);
     }
     ```

3. **作者：Kevin_Zhen (4星)**  
   - **关键亮点**：使用链表模拟线程移动，虽然代码复杂但更贴近实际场景。
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= m; ++i) {
         int k = readInt();
         a[a[k].next].prev = a[k].prev;
         a[a[k].prev].next = a[k].next;
         a[k].next = a[0].next;
         a[k].prev = 0;
         a[a[0].next].prev = k;
         a[0].next = k;
     }
     ```

### 最优关键思路
倒序输出法是最优的解决方案，因为它简单直观，代码量少，且时间复杂度为O(N+M)，适合大规模数据处理。

### 拓展思路
类似的问题可以扩展到其他需要模拟“后进先出”或“最近访问优先”的场景，如缓存淘汰策略（LRU）、任务调度等。

### 推荐题目
1. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)  
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)  
3. [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)

---
处理用时：28.95秒
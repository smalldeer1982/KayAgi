# 题目信息

# [ARC051C] 掛け算

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc051/tasks/arc051_c

$ N $ 個の整数 $ a_1,\ a_2,\ ...,\ a_N $ が与えられるので、一番小さいものを $ A $ 倍する、という操作を $ B $ 回行います。

この結果できた整数たちを昇順に並べ、順番に出力してください。

ただし出力するときは、出力したい数を $ 10^9\ +\ 7 $ で割ったあまりを出力するようにしてください。

なお、$ 10^9+7 $ で割ったあまりを昇順に並べる、というわけではないことに注意してください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 50 $
- $ 1\ ≦\ a_i\ ≦\ 1,000,000,000 $
- $ 1\ ≦\ A,\ B\ ≦\ 1,000,000,000 $
- $ A $ は整数である

### Sample Explanation 2

操作の結果、$ 20000,\ 10000200001 $ の $ 2 $ つの整数ができます。$ 10^9+7 $ で割ったあまりを出力することに注意してください。

## 样例 #1

### 输入

```
3 10 3

1 99 10```

### 输出

```
99

100

100```

## 样例 #2

### 输入

```
2 100001 2

1 200000```

### 输出

```
200000

199931```

## 样例 #3

### 输入

```
10 123 1000000000

394632992 714094234 84420 5 3439891 3395 35 58 5001 730```

### 输出

```
954804718

385989482

948741792

268211139

100694402

492858064

955116743

68100851

154525400

479209143```

# AI分析结果

### 题目重写
#### [ARC051C] 掛け算

**题目描述**

给定 $N$ 个整数 $a_1,\ a_2,\ ...,\ a_N$，进行 $B$ 次操作，每次操作将其中最小的数乘以 $A$。最终将得到的整数按升序排列并输出，输出时每个数需要对 $10^9 + 7$ 取模。

**说明/提示**

**约束条件**
- $1 \leq N \leq 50$
- $1 \leq a_i \leq 1,000,000,000$
- $1 \leq A,\ B \leq 1,000,000,000$
- $A$ 是整数

**样例解释**

**样例 #1**
输入：
```
3 10 3
1 99 10
```
输出：
```
99
100
100
```

**样例 #2**
输入：
```
2 100001 2
1 200000
```
输出：
```
200000
199931
```

**样例 #3**
输入：
```
10 123 1000000000
394632992 714094234 84420 5 3439891 3395 35 58 5001 730
```
输出：
```
954804718
385989482
948741792
268211139
100694402
492858064
955116743
68100851
154525400
479209143
```

### 算法分类
**模拟**

### 题解分析与结论

#### 题解1：wwwwwza
**评分：4星**
**关键亮点：**
1. 分类讨论 $A=1$ 的情况，直接排序输出。
2. 当 $A \neq 1$ 时，模拟操作直到最小数乘以 $A$ 大于最大数，然后进行周期性模拟。
3. 使用快速幂计算最终结果，避免了重复计算。

**核心代码：**
```cpp
while(b&&p[1]*a<=p[n]){//按题意模拟至可循环计算的状态 
    p[1]*=a;b--;
    sort(p+1,p+1+n);
} 
int c=b/n,d=b%n;
//计算答案 
for(int i=1;i<=n;i++)p[i]=p[i]*ksm(a,c+(i<=d))%mod;
//输出答案 
for(int i=d+1;i<=n;i++)cout <<p[i]<<endl;
for(int i=1;i<=d;i++)cout <<p[i]<<endl;
```

#### 题解2：e4fsrc2e4fsrc2
**评分：3星**
**关键亮点：**
1. 使用小根堆维护序列，记录每个数的初始值和乘 $A$ 的次数。
2. 通过快速幂计算最终结果。
3. 优化了模拟过程，考虑了周期性规律。

**核心代码：**
```cpp
while(b>0){
    if(cnt==n)break;
    node f=q.top();q.pop();
    if(!vis[f.id])vis[f.id]=1,cntt++;
    _cnt++,cnt[f.id]++,b--;
    q.push({f.x,f.id,f.cnt+1});
}
```

### 最优关键思路或技巧
1. **分类讨论**：当 $A=1$ 时，直接排序输出，避免了不必要的计算。
2. **模拟优化**：当 $A \neq 1$ 时，模拟操作直到最小数乘以 $A$ 大于最大数，然后进行周期性模拟，减少了模拟次数。
3. **快速幂**：使用快速幂计算最终结果，提高了计算效率。

### 可拓展之处
1. **周期性模拟**：在处理类似问题时，可以考虑周期性规律，减少模拟次数。
2. **快速幂**：在处理大指数幂运算时，快速幂是一个高效的算法。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：25.15秒
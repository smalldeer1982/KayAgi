# 题目信息

# [ABC059C] Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc059/tasks/arc072_a

長さ $ N $ の数列があり、$ i $ 番目の数は $ a_i $ です。 あなたは $ 1 $ 回の操作でどれか $ 1 $ つの項の値を $ 1 $ だけ増やすか減らすことができます。

以下の条件を満たすために必要な操作回数の最小値を求めてください。

- すべての$ i\ (1≦i≦n) $ に対し、第 $ 1 $ 項から第 $ i $ 項までの和は $ 0 $ でない
- すべての$ i\ (1≦i≦n-1) $ に対し、$ i $ 項までの和と $ i+1 $ 項までの和の符号が異なる

## 说明/提示

### 制約

- $ 2≦\ n\ ≦\ 10^5 $
- $ |a_i|\ ≦\ 10^9 $
- $ a_i $ は整数

### Sample Explanation 1

例えば、数列を $ 1,\ -2,\ 2,\ -2 $ に $ 4 $ 回の操作で変更することができます。この数列は $ 1,\ 2,\ 3,\ 4 $ 項までの和がそれぞれ $ 1,\ -1,\ 1,\ -1 $ であるため、条件を満たしています。

### Sample Explanation 2

はじめから条件を満たしています。

## 样例 #1

### 输入

```
4

1 -3 1 0```

### 输出

```
4```

## 样例 #2

### 输入

```
5

3 -6 4 -5 7```

### 输出

```
0```

## 样例 #3

### 输入

```
6

-1 4 3 2 -5 4```

### 输出

```
8```

# AI分析结果

### 题目内容重写
【题目描述】  
给定一个长度为 $N$ 的数列，第 $i$ 个数为 $a_i$。你可以通过一次操作将任意一个元素的值增加或减少 1。要求通过最少的操作次数，使得以下条件成立：
1. 对于所有 $i\ (1 \leq i \leq n)$，前 $i$ 项的和不为 0。
2. 对于所有 $i\ (1 \leq i \leq n-1)$，前 $i$ 项的和与前 $i+1$ 项的和的符号相反。

【输入格式】  
第一行输入一个整数 $N$，表示数列的长度。  
第二行输入 $N$ 个整数，表示数列 $a$。

【输出格式】  
输出一个整数，表示满足条件所需的最少操作次数。

【样例 1】  
输入：  
```
4
1 -3 1 0
```  
输出：  
```
4
```

【样例 2】  
输入：  
```
5
3 -6 4 -5 7
```  
输出：  
```
0
```

【样例 3】  
输入：  
```
6
-1 4 3 2 -5 4
```  
输出：  
```
8
```

### 算法分类
贪心

### 题解分析与结论
该题的核心思路是通过贪心策略，分别考虑前缀和序列的两种可能符号模式（正负交替或负正交替），并计算每种模式下所需的最小操作次数，最终取两者中的较小值。难点在于如何处理前缀和为 0 的情况，以及如何通过贪心策略将前缀和调整为 1 或 -1 以最小化操作次数。

### 高星题解推荐
#### 题解 1：作者：tyr_04 (赞：3)
- **星级**：4.5
- **关键亮点**：清晰地分析了前缀和符号的两种模式，并通过贪心策略将前缀和调整为 1 或 -1，代码简洁且易于理解。
- **代码核心思想**：分别计算前缀和为正负交替和负正交替时的操作次数，取最小值。
```cpp
long long a[100005],ans1=0,ans2=0,l=0;
bool z;
int main()
{
    long long n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    z=0;
    for(int i=1;i<=n;i++)
    {
        l+=a[i];
        if(l>=0&&z==1) ans1+=l+1, l=-1;
        else if(l<=0&&z==0) ans1+=1-l, l=1;
        z=!z;
    }
    z=1;
    l=0;
    for(int i=1;i<=n;i++)
    {
        l+=a[i];
        if(l>=0&&z==1) ans2+=l+1, l=-1;
        else if(l<=0&&z==0) ans2+=1-l, l=1;
        z=!z;
    }
    cout<<min(ans1,ans2);
    return 0;
}
```

#### 题解 2：作者：mayike (赞：0)
- **星级**：4
- **关键亮点**：通过简洁的代码实现了贪心策略，并强调了将前缀和调整为 1 或 -1 的重要性，代码可读性高。
- **代码核心思想**：分别计算前缀和为正负交替和负正交替时的操作次数，取最小值。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;long sum1,sum2,ans1,ans2;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x;sum1+=x;sum2+=x;
        if(i%2){
            if(sum1<=0)ans1+=1-sum1,sum1=1;
            if(sum2>=0)ans2+=sum2+1,sum2=-1;
        }
        else{
            if(sum1>=0)ans1+=sum1+1,sum1=-1;
            if(sum2<=0)ans2+=1-sum2,sum2=1;
        }
    }cout<<min(ans1,ans2)<<'\n';
    return 0;
}
```

#### 题解 3：作者：Withers (赞：0)
- **星级**：4
- **关键亮点**：通过函数封装了贪心策略的实现，代码结构清晰，便于扩展和复用。
- **代码核心思想**：通过函数分别计算前缀和为正负交替和负正交替时的操作次数，取最小值。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010];
bool k=0;
long long run(bool k)
{
    long long pre=0,ans=0;
    for(int i=1;i<=n;i++)
    {
        pre+=a[i];
        if(pre>=0&&k==0) ans+=(pre+1), pre=-1;
        else if(pre<=0&&k==1) ans+=(-pre+1), pre=1;
        k=!k;
    }
    return ans;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    cout<<min(run(0),run(1));
}
```

### 最优关键思路或技巧
1. **贪心策略**：通过将前缀和调整为 1 或 -1，确保每次操作的最小代价。
2. **符号模式**：分别考虑前缀和序列的两种符号模式（正负交替或负正交替），并计算每种模式下的最小操作次数。
3. **处理前缀和为 0**：当前缀和为 0 时，根据前一个前缀和的符号进行调整，确保符号交替。

### 可拓展之处
该题的贪心策略可以推广到其他需要调整序列以满足特定符号条件的题目中，例如要求序列的某些性质（如单调性、周期性等）时，可以通过类似的贪心策略进行优化。

### 推荐相似题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：43.86秒
# 题目信息

# [ABC074D] Restoring Road Network

## 题目描述

#### 题面翻译
曾经存在的高桥王国有N个城市，城市与城市之间用长度为正整数的无向道路连接。

现有一考古学家找到了一张N×N的表A，这张表代表了这N座城市两两之间的最短路。即表中的第u行第v列的值代表了从城市u到v的最短路长度。

问能否根据这张表，求出高桥王国的最小道路长度总和。

## 样例 #1

### 输入

```
3

0 1 3

1 0 2

3 2 0```

### 输出

```
3```

## 样例 #2

### 输入

```
3

0 1 3

1 0 1

3 1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
5

0 21 18 11 28

21 0 13 10 26

18 13 0 23 13

11 10 23 0 17

28 26 13 17 0```

### 输出

```
82```

## 样例 #4

### 输入

```
3

0 1000000000 1000000000

1000000000 0 1000000000

1000000000 1000000000 0```

### 输出

```
3000000000```

# AI分析结果

### 题目内容重写
曾经存在的高桥王国有N个城市，城市与城市之间用长度为正整数的无向道路连接。

现有一考古学家找到了一张N×N的表A，这张表代表了这N座城市两两之间的最短路。即表中的第u行第v列的值代表了从城市u到v的最短路长度。

问能否根据这张表，求出高桥王国的最小道路长度总和。

### 算法分类
最短路

### 题解分析与结论
本题的核心是通过给定的最短路表，判断是否存在一个合理的道路网络，并求出最小道路长度总和。所有题解均采用了Floyd算法来处理最短路问题，并通过标记和判断来优化计算。以下是各题解的要点总结：

1. **Floyd算法的应用**：所有题解都使用了Floyd算法来遍历和验证最短路表。Floyd算法的时间复杂度为O(n^3)，适合本题的数据范围（N ≤ 300）。
2. **标记与优化**：大部分题解通过标记某些边是否可以被其他路径替代，从而避免重复计算。例如，如果a[i][j] == a[i][k] + a[k][j]，则标记a[i][j]为不需要直接计算。
3. **无解判断**：如果发现a[i][j] > a[i][k] + a[k][j]，则说明给定的最短路表不合法，输出-1。
4. **无向图处理**：由于道路是无向的，最终结果需要除以2。

### 评分较高的题解
1. **作者：fls233666 (4星)**
   - **关键亮点**：思路清晰，代码简洁，详细解释了Floyd算法的应用和优化思路。
   - **核心代码**：
     ```cpp
     for(k=1;k<=n;k++)      
         for(i=1;i<=n;i++)
             for(j=1;j<=n;j++){
                 if(k!=j&&k!=i&&i!=j){
                     if(a[i][j]==a[i][k]+a[k][j])
                         p[i][j]=1;  //标记
                     if(a[i][j]>a[i][k]+a[k][j]){
                         cout<<"-1"<<endl;  //不是最短路，无解
                         return 0;
                     }
                 }
             }
     ```

2. **作者：Misserina (4星)**
   - **关键亮点**：代码结构清晰，逻辑严谨，详细解释了无解判断和优化计算的过程。
   - **核心代码**：
     ```cpp
     for (int i=1;i<=n;i++) {
         for (int j=i+1;j<=n;j++) {
             for (int mid=1;mid<=n;mid++) {
                 if (mid!=i && mid!=j && arr[i][j]==arr[i][mid]+arr[mid][j]) direct[i][j]=direct[j][i]=0;
             }
             res+=direct[i][j]*arr[i][j];
         }
     }
     ```

3. **作者：taojinchen (4星)**
   - **关键亮点**：代码简洁，逻辑清晰，详细解释了Floyd算法的应用和优化思路。
   - **核心代码**：
     ```cpp
     for(k=1;k<=n;k++){
         for(i=1;i<=n;i++){
             for(j=1;j<=n;j++){
                 f[i][j]=min(f[i][j],f[i][k]+f[k][j]);//最短路
             }
         }
     }
     ```

### 最优关键思路或技巧
1. **Floyd算法的应用**：通过Floyd算法遍历和验证最短路表，确保所有路径的最短性。
2. **标记优化**：通过标记某些边是否可以被其他路径替代，避免重复计算，优化结果。
3. **无解判断**：在遍历过程中，如果发现a[i][j] > a[i][k] + a[k][j]，则直接输出-1，确保结果的合法性。

### 可拓展之处
本题可以拓展到其他最短路问题，如Dijkstra算法、Bellman-Ford算法等。类似题目包括：
1. [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)
2. [P2910 灾后重建](https://www.luogu.com.cn/problem/P2910)
3. [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)

### 个人心得摘录
- **fls233666**：通过Floyd算法的应用，详细解释了如何通过标记优化计算，避免重复计算。
- **Misserina**：强调了无解判断的重要性，确保结果的合法性。
- **taojinchen**：通过Floyd算法的应用，详细解释了如何通过标记优化计算，避免重复计算。

---
处理用时：36.80秒
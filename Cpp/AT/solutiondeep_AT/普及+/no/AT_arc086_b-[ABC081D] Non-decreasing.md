# 题目信息

# [ABC081D] Non-decreasing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc081/tasks/arc086_b

すぬけ君は長さ $ N $ の数列 $ a $ を持っています。$ a $ の ($ 1 $-indexedでの) $ i $ 番目の数は $ a_{i} $ です。

すぬけ君は以下の操作を何度でも行うことができます。

- 操作：$ 1 $ 以上 $ N $ 以下の整数 $ x,y $ を選び、$ a_y $ に $ a_x $ を加算する。

すぬけ君はこの操作を $ 0 $ 回以上 $ 2N $ 回以下行って $ a $ が下記の条件を満たすようにしたいです。そのような操作手順の一例を示してください。 なお、この問題の制約下で、条件を満たすような操作の手順が必ず存在することが証明できます。

- 条件：$ a_1\ \leq\ a_2\ \leq\ ...\ \leq\ a_{N} $

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 50 $
- $ -10^{6}\ \leq\ a_i\ \leq\ 10^{6} $
- 与えられる入力は全て整数

### Sample Explanation 1

\- $ 1 $ 番目の操作により $ a\ =\ (-2,5,4) $ となります - $ 2 $ 番目の操作により $ a\ =\ (-2,5,8) $ となり、条件を満たします

### Sample Explanation 2

\- $ 1 $ 番目の操作により $ a\ =\ (-4,-3) $ となり、条件を満たします

### Sample Explanation 3

\- すでに条件を満たしています

## 样例 #1

### 输入

```
3

-2 5 -1```

### 输出

```
2

2 3

3 3```

## 样例 #2

### 输入

```
2

-1 -3```

### 输出

```
1

2 1```

## 样例 #3

### 输入

```
5

0 0 0 0 0```

### 输出

```
0```

# AI分析结果

### 题目内容重写
【题目名称】Non-decreasing

【题目描述】
すぬけ君有一个长度为 $N$ 的数列 $a$。$a$ 的（1-indexed）第 $i$ 个数是 $a_i$。

すぬけ君可以进行以下操作任意次：

- 操作：选择 $1$ 到 $N$ 之间的整数 $x, y$，将 $a_y$ 加上 $a_x$。

すぬけ君希望通过最多 $2N$ 次操作，使得数列 $a$ 满足以下条件。请给出一个满足条件的操作序列。可以证明，在本题的限制下，满足条件的操作序列一定存在。

- 条件：$a_1 \leq a_2 \leq \dots \leq a_N$。

【说明/提示】
### 限制
- $2 \leq N \leq 50$
- $-10^6 \leq a_i \leq 10^6$
- 输入均为整数

### 样例解释
#### 样例 #1
输入：
```
3
-2 5 -1
```
输出：
```
2
2 3
3 3
```
解释：
- 第一次操作后，$a = (-2, 5, 4)$
- 第二次操作后，$a = (-2, 5, 8)$，满足条件

#### 样例 #2
输入：
```
2
-1 -3
```
输出：
```
1
2 1
```
解释：
- 第一次操作后，$a = (-4, -3)$，满足条件

#### 样例 #3
输入：
```
5
0 0 0 0 0
```
输出：
```
0
```
解释：
- 已经满足条件

### 算法分类
构造

### 题解分析与结论
这两条题解的核心思路都是通过构造操作序列，使得数列最终变为非降序。主要思路如下：

1. **npqenqpve 的题解**：
   - 通过找到绝对值最大的数，将其加到其他数上，使得数列变为全非负或全非正。
   - 然后通过前缀和或后缀和的方式，使数列变为非降序。
   - 操作次数最多为 $2N-2$ 次。

2. **灵茶山艾府 的题解**：
   - 同样通过找到最大值和最小值，判断是否可以通过将最大值加到所有负数上，或者将最小值加到所有正数上，使得数列变为全非负或全非正。
   - 然后通过前缀和或后缀和的方式，使数列变为非降序。
   - 操作次数最多为 $2N-2$ 次。

### 题解评分与亮点
#### npqenqpve 的题解（4星）
- **亮点**：思路清晰，代码实现简洁，通过排序找到绝对值最大的数，然后分情况处理。
- **代码核心**：
  ```cpp
  if(abs(p[1].v)<=p[n].v)
  {
      for(int i=1;i<=n;i++)
      {
          if(i!=p[n].id) cout<<p[n].id<<" "<<i<<"\n";
      }
      for(int i=2;i<=n;i++) cout<<i-1<<" "<<i<<"\n";
  }
  else 
  {
      for(int i=1;i<=n;i++)
      {
          if(i!=p[1].id) cout<<p[1].id<<" "<<i<<"\n";
      }
      for(int i=n;i>=2;i--) cout<<i<<" "<<i-1<<"\n";
  }
  ```

#### 灵茶山艾府 的题解（4星）
- **亮点**：思路清晰，代码实现简洁，通过遍历找到最大值和最小值，然后分情况处理。
- **代码核心**：
  ```go
  if a[maxI] > -a[minI] {
      for i, v := range a {
          if v < 0 {
              ans = append(ans, []int{maxI + 1, i + 1})
          }
      }
  } else {
      for i, v := range a {
          if v > 0 {
              ans = append(ans, []int{minI + 1, i + 1})
          }
      }
      d = 0
  }
  ```

### 最优关键思路
- **关键思路**：通过找到绝对值最大的数，将其加到其他数上，使得数列变为全非负或全非正，然后通过前缀和或后缀和的方式，使数列变为非降序。
- **操作次数**：最多为 $2N-2$ 次。

### 拓展思路
- 类似题目可以考察如何通过有限的操作次数，将数列变为满足某种特定条件的序列，如非增序、全正数等。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得摘录
- **npqenqpve**：通过排序找到绝对值最大的数，然后分情况处理，思路清晰，代码简洁。
- **灵茶山艾府**：通过遍历找到最大值和最小值，然后分情况处理，代码实现简洁，思路清晰。

---
处理用时：31.25秒
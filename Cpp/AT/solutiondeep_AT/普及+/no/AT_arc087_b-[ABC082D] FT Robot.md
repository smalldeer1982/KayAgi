# 题目信息

# [ABC082D] FT Robot

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc082/tasks/arc087_b

二次元平面の原点にロボットが置かれています。 最初、ロボットは $ x $ 軸の正の向きを向いています。

このロボットに命令列 $ s $ が与えられます。 $ s $ は次の $ 2 $ 文字のみからなり、先頭から末尾まで順に実行されます。

- `F` : 今向いている向きに長さ $ 1 $ だけ移動する。
- `T` : 時計回りまたは反時計回りの好きな方向に $ 90 $ 度だけ向きを変える。

ロボットの目標は、命令列をすべて実行し終わった後に座標 $ (x,\ y) $ にいることです。 この目標が達成可能か判定してください。

## 说明/提示

### 制約

- $ s $ は `F`, `T` のみからなる。
- $ 1\ \leq\ |s|\ \leq\ 8\ 000 $
- $ x $, $ y $ は整数である。
- $ |x|,\ |y|\ \leq\ |s| $

### Sample Explanation 1

$ 1 $ 番目の `T` で反時計周りに $ 90 $ 度だけ向きを変え、$ 2 $ 番目の `T` で時計周りに $ 90 $ 度だけ向きを変えればよいです。

### Sample Explanation 2

$ 1 $ 番目の `T` で時計周りに $ 90 $ 度だけ向きを変え、$ 2 $ 番目の `T` で時計周りに $ 90 $ 度だけ向きを変えればよいです。

### Sample Explanation 5

例えば、$ 1 $ 番目の `T` で反時計周りに $ 90 $ 度だけ向きを変え、$ 2 $ 番目の `T` で反時計周りに $ 90 $ 度だけ向きを変えればよいです。

## 样例 #1

### 输入

```
FTFFTFFF

4 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
FTFFTFFF

-2 -2```

### 输出

```
Yes```

## 样例 #3

### 输入

```
FF

1 0```

### 输出

```
No```

## 样例 #4

### 输入

```
TF

1 0```

### 输出

```
No```

## 样例 #5

### 输入

```
FFTTFF

0 0```

### 输出

```
Yes```

## 样例 #6

### 输入

```
TTTT

1 0```

### 输出

```
No```

# AI分析结果

### 题目内容重写

#### [ABC082D] FT Robot

**题目描述**

在二维平面的原点放置了一个机器人。最初，机器人面向 $x$ 轴的正方向。

给机器人一个命令序列 $s$。$s$ 仅由以下两种字符组成，并按顺序执行：

- `F`：向当前方向移动长度为 $1$ 的距离。
- `T`：顺时针或逆时针旋转 $90$ 度。

机器人的目标是在执行完所有命令后，位于坐标 $(x, y)$。请判断是否可以实现这一目标。

**说明/提示**

**约束**

- $s$ 仅由 `F` 和 `T` 组成。
- $1 \leq |s| \leq 8,000$
- $x$ 和 $y$ 是整数。
- $|x|, |y| \leq |s|$

**样例解释**

**样例 1**

输入：
```
FTFFTFFF
4 2
```
输出：
```
Yes
```

**样例 2**

输入：
```
FTFFTFFF
-2 -2
```
输出：
```
Yes
```

**样例 3**

输入：
```
FF
1 0
```
输出：
```
No
```

**样例 4**

输入：
```
TF
1 0
```
输出：
```
No
```

**样例 5**

输入：
```
FFTTFF
0 0
```
输出：
```
Yes
```

**样例 6**

输入：
```
TTTT
1 0
```
输出：
```
No
```

### 算法分类
动态规划

### 题解分析与结论

#### 综合分析

该题的核心在于如何高效地处理命令序列，并判断机器人是否能够到达目标坐标。由于命令序列的长度可能达到 8000，直接模拟或搜索的复杂度会非常高。因此，大多数题解采用了动态规划的思路，将问题分解为横向和纵向的独立问题，并通过 `bitset` 优化来降低时间复杂度。

#### 最优思路与技巧

1. **命令序列的压缩**：将连续的 `F` 命令压缩为一个整体，减少处理次数。
2. **方向的性质**：根据 `T` 的个数奇偶性，确定机器人当前的运动方向（横向或纵向）。
3. **动态规划与 `bitset` 优化**：使用动态规划来记录机器人可能到达的位置，并通过 `bitset` 优化转移过程，降低时间复杂度。
4. **坐标偏移**：由于坐标可能为负数，通过加上一个偏移量来保证数组下标为正。

### 精选题解

#### 题解1：作者 0xyz (赞：11)

**星级**：★★★★★

**关键亮点**：
- 使用 `bitset` 优化动态规划，代码简洁且高效。
- 通过奇偶性判断方向，简化了问题的复杂度。
- 代码可读性强，逻辑清晰。

**核心代码**：
```cpp
#include<bits/stdc++.h>
#define z 16005
using namespace std;
int n,X,Y,p,c,w;
string s;
bitset<z*2>x,y;
int main(){
    x[z]=y[z]=1;
    cin>>s>>X>>Y;s+="T";n=s.size();
    for(int i=0;i<n;i++)
        if(s[i]=='T'){
            if(!c)X-=i;
            else if(w=i-1-p){
                if(c&1)y=y<<w|y>>w;
                else x=x<<w|x>>w;
            }
            p=i;c++;
        }
    if(x[z+X]&&y[z+Y])cout<<"Yes\n";
    else cout<<"No\n";
    return 0;
}
```

#### 题解2：作者 Mysterious_Cat (赞：8)

**星级**：★★★★☆

**关键亮点**：
- 详细解释了命令序列的压缩和方向判断。
- 使用动态规划分别处理横向和纵向的移动。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int NR = 8005;

bool dpx[NR / 2][NR * 2], dpy[NR / 2][NR * 2];
int n[3], w[3][NR];

int main()
{
    int x, y, len = 0, id = 1;
    string s;
    cin >> s >> x >> y;
    s += 'T';
    for(int i = 0; i < s.size(); i++)
    {
        if(s[i] == 'T')
        {
            n[id]++;
            w[id][n[id]] = len;
            len = 0;
            id = 3 - id;
        }
        else len++;
    }
    dpx[1][w[1][1] + NR] = true;
    for(int i = 2; i <= n[1]; i++)
        for(int j = -8000; j <= 8000; j++)
        {
            if(j - w[1][i] > -8000) dpx[i][j + NR] |= dpx[i - 1][j + NR - w[1][i]];
            if(j + w[1][i] < 8000) dpx[i][j + NR] |= dpx[i - 1][j + NR + w[1][i]];
        }
    dpy[0][0 + NR] = true;
    for(int i = 1; i <= n[2]; i++)
        for(int j = -8000; j <= 8000; j++)
        {
            if(j - w[2][i] > -8000) dpy[i][j + NR] |= dpy[i - 1][j + NR - w[2][i]];
            if(j + w[2][i] < 8000) dpy[i][j + NR] |= dpy[i - 1][j + NR + w[2][i]];
        }
    if(dpx[n[1]][x + NR] && dpy[n[2]][y + NR]) printf("Yes");
    else printf("No");
    
    return 0;
}
```

#### 题解3：作者 Rnfmabj (赞：2)

**星级**：★★★★☆

**关键亮点**：
- 使用 `bitset` 优化动态规划，代码简洁高效。
- 详细解释了横向和纵向移动的独立性。
- 代码逻辑清晰，易于理解。

**核心代码**：
```cpp
const ll maxn=8e3+5;

char c[maxn];//读入指令

bitset<16005>f[2];

ll a[2][maxn],cnt[2];//0为横向，1为纵向

ll s;

void solve(){

    cin>>(c+1);

    ll n=strlen(c+1)+1;

    c[n]='T';//设置不存在的最后一位为转向，便于统计

    ll x=R,y=R;

    ll p=1;

    while(c[p]!='T')p++;//预处理出固定方向的第一个指令。这个的方向不受我们控制，所以要特判。（其实后面的操作取个反就行了，影响不大）

    s=p-1;

    bool cur=0;

    ll tmp=0;

    for(ll i=p;i<=n;i++){

        if(c[i]=='T'){

            a[cur][++cnt[cur]]=tmp;

            tmp=0;

            cur^=1;//改变方向

        }

        else tmp++;

    }

    f[0][s+(ll)8e3]=1;//注意是从预处理出的起点开始而不是原点

    //加上8e3是为了处理负数坐标，做一个水平平移

    for(ll i=1;i<=cnt[0];i++){

        f[1].reset();//清空当前

        f[1]=(f[0]<<a[0][i])|(f[0]>>a[0][i]);//转移

        f[0]=f[1];//滚动

    }

    if(!f[0][x+(ll)8e3]){

        puts("No");//横向已经挂掉了就已经不可能了

        return ;

    }

    f[0].reset();//清空，接着做纵向

    f[0][(ll)8e3]=1;//纵向就是从原点开始了

    for(ll i=1;i<=cnt[1];i++){

        f[1].reset();

        f[1]=(f[0]<<a[1][i])|(f[0]>>a[1][i]);

        f[0]=f[1];

    }//同上

    if(!f[0][y+(ll)8e3]){

        puts("No");

        return ;

    }

    puts("Yes");

    return ;

}
```

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：62.37秒
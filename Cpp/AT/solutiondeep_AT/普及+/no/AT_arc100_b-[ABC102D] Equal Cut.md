# 题目信息

# [ABC102D] Equal Cut

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc102/tasks/arc100_b

すぬけ君は、長さ $ N $ の整数列 $ A $ を持っています。

すぬけ君は $ A $ を $ 3 $ 箇所で切って、$ 4 $ つの（空でない）連続する部分列 $ B,C,D,E $ に分解します。 切る位置は自由に選ぶことができます。

ここで、整数列 $ B,C,D,E $ について、その要素の総和をそれぞれ $ P,Q,R,S $ とおきます。 すぬけ君は、$ P,Q,R,S $ の最大値と最小値の差の絶対値が小さいほど嬉しいです。 $ P,Q,R,S $ の最大値と最小値の差の絶対値としてあり得る最も小さい値を求めてください。

## 说明/提示

### 制約

- $ 4\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力はすべて整数である。

### Sample Explanation 1

$ B,C,D,E=(3),(2),(4),(1,2) $ と分割すれば、$ P=3,Q=2,R=4,S=1+2=3 $ となります。 このとき、$ P,Q,R,S $ の最大値は $ 4 $、最小値は $ 2 $ で、その差の絶対値は $ 2 $ です。 最大値と最小値の差の絶対値を $ 2 $ 未満にすることは出来ないため、$ 2 $ が答えになります。

## 样例 #1

### 输入

```
5

3 2 4 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
10

10 71 84 33 6 47 23 25 52 64```

### 输出

```
36```

## 样例 #3

### 输入

```
7

1 2 3 1000000000 4 5 6```

### 输出

```
999999994```

# AI分析结果

### 题目翻译

#### 题目描述

すぬけ君有一个长度为 $N$ 的整数序列 $A$。

すぬけ君将 $A$ 在三个位置切开，将其分解为四个（非空的）连续子序列 $B, C, D, E$。切的位置可以自由选择。

对于整数序列 $B, C, D, E$，分别设它们的元素总和为 $P, Q, R, S$。すぬけ君希望 $P, Q, R, S$ 的最大值与最小值的差的绝对值尽可能小。请找出 $P, Q, R, S$ 的最大值与最小值的差的绝对值的最小可能值。

#### 说明/提示

##### 约束条件

- $4 \leq N \leq 2 \times 10^5$
- $1 \leq A_i \leq 10^9$
- 输入中的所有值都是整数。

##### 样例解释 1

将 $B, C, D, E$ 分割为 $(3), (2), (4), (1, 2)$，则 $P=3, Q=2, R=4, S=1+2=3$。此时，$P, Q, R, S$ 的最大值为 $4$，最小值为 $2$，差的绝对值为 $2$。无法使最大与最小值的差的绝对值小于 $2$，因此答案为 $2$。

##### 样例 #1

###### 输入

```
5
3 2 4 1 2
```

###### 输出

```
2
```

##### 样例 #2

###### 输入

```
10
10 71 84 33 6 47 23 25 52 64
```

###### 输出

```
36
```

##### 样例 #3

###### 输入

```
7
1 2 3 1000000000 4 5 6
```

###### 输出

```
999999994
```

### 算法分类

前缀和 + 双指针

### 题解分析与结论

本题的核心思想是通过枚举中间分割点 $j$，然后利用双指针优化找到左右分割点 $i$ 和 $k$，使得四段子序列的和尽可能平衡。由于 $j$ 的枚举是单调递增的，$i$ 和 $k$ 的移动也是单调的，因此时间复杂度为 $O(n)$。

### 所选高分题解

#### 题解1：Kelin (赞：9)

**星级：★★★★★**

**关键亮点：**
- 使用前缀和简化计算。
- 通过双指针优化，确保 $i$ 和 $k$ 的移动是单调的，从而将时间复杂度降低到 $O(n)$。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
for (int i = 1, j = 2, k = 3; j < n; ++j) {
    while (i + 1 < j && abs(a[j] - 2 * a[i]) > abs(a[j] - 2 * a[i + 1])) ++i;
    while (k + 1 < n && abs(a[n] + a[j] - 2 * a[k]) > abs(a[n] + a[j] - 2 * a[k + 1])) ++k;
    Ans = min(Ans, max({a[i], a[j] - a[i], a[k] - a[j], a[n] - a[k]}) -
                   min({a[i], a[j] - a[i], a[k] - a[j], a[n] - a[k]}));
}
```

#### 题解2：Hoks (赞：4)

**星级：★★★★**

**关键亮点：**
- 思路与Kelin类似，同样使用前缀和和双指针优化。
- 代码风格简洁，易于理解。

**核心代码：**
```cpp
for (int i = 1, j = 2, k = 3; j < n; j++) {
    while (i + 1 < j && abs(a[j] - 2 * a[i]) > abs(a[j] - 2 * a[i + 1])) i++;
    while (k + 1 < n && abs(a[n] + a[j] - 2 * a[k]) > abs(a[n] + a[j] - 2 * a[k + 1])) k++;
    ans = min(ans, max({a[i], a[j] - a[i], a[k] - a[j], a[n] - a[k]}) -
                   min({a[i], a[j] - a[i], a[k] - a[j], a[n] - a[k]}));
}
```

#### 题解3：_ZML_ (赞：2)

**星级：★★★★**

**关键亮点：**
- 同样使用前缀和和双指针优化，思路清晰。
- 代码实现简洁，逻辑明确。

**核心代码：**
```cpp
for (int i = 1, j = 2, k = 3; j < n; j++) {
    while (i + 1 < j && abs(sum[j] - 2 * sum[i]) > abs(sum[j] - 2 * sum[i + 1])) i++;
    while (k + 1 < n && abs(sum[n] - 2 * sum[k] + sum[j]) > abs(sum[n] - 2 * sum[k + 1] + sum[j])) k++;
    ans = min(ans, max(sum[i], sum[j] - sum[i], sum[k] - sum[j], sum[n] - sum[k]) -
                   min(sum[i], sum[j] - sum[i], sum[k] - sum[j], sum[n] - sum[k]));
}
```

### 最优关键思路或技巧

1. **前缀和**：通过预处理前缀和，快速计算任意区间的和。
2. **双指针优化**：在枚举中间分割点 $j$ 时，利用双指针快速找到左右分割点 $i$ 和 $k$，使得四段子序列的和尽可能平衡。
3. **单调性**：由于 $j$ 的枚举是单调递增的，$i$ 和 $k$ 的移动也是单调的，从而保证了时间复杂度为 $O(n)$。

### 拓展思路

类似的问题可以通过前缀和和双指针优化来解决，尤其是在需要将序列分割为多个子序列并求极差最小的情况下。例如，将序列分割为两段、三段等，都可以采用类似的思路。

### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)

---
处理用时：44.56秒
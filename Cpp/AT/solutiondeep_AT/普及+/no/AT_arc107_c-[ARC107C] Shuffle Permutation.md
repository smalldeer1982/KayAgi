# 题目信息

# [ARC107C] Shuffle Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc107/tasks/arc107_c

$ N\ \times\ N $ の行列と、整数 $ K $ が与えられます。この行列の $ i $ 行目、$ j $ 列目の値を $ a_{i,\ j} $ とします。この行列は、 $ 1,\ 2,\ \dots,\ N^2 $ をちょうど一つずつ要素に含みます。

sigma くんは、以下の $ 2 $ 種類の操作を、好きな順序で **好きな回数** 行えます。

- 全ての $ i $ ($ 1\ \leq\ i\ \leq\ N $) について $ a_{i,\ x}\ +\ a_{i,\ y}\ \leq\ K $ を満たす $ x,\ y(1\ \leq\ x\ <\ y\ \leq\ N) $ を選び、行列の $ x,\ y $ 列目をswapする。
- 全ての $ i $ ($ 1\ \leq\ i\ \leq\ N $) について $ a_{x,\ i}\ +\ a_{y,\ i}\ \leq\ K $ を満たす $ x,\ y(1\ \leq\ x\ <\ y\ \leq\ N) $ を選び、行列の $ x,\ y $ 行目をswapする。

最終的に得られる行列は何種類存在するでしょうか？ $ \bmod\ 998244353 $ で答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ 1\ \leq\ K\ \leq\ 2\ \times\ N^2 $
- $ a_{i,\ j} $ は $ 1,\ 2,\ \dots,\ N^2 $ の並び替え
- 入力される数は全て整数である。

### Sample Explanation 1

例えば $ x\ =\ 1,\ y\ =\ 2 $ として列ベクトルを swap でき、以下のようになります。 ``` 2 3 7 8 4 9 6 1 5 ``` その後更に $ x\ =\ 1,\ y\ =\ 3 $ として行ベクトルを swap でき、以下のようになります。 ``` 6 1 5 8 4 9 2 3 7 ```

## 样例 #1

### 输入

```
3 13

3 2 7

4 8 9

1 6 5```

### 输出

```
12```

## 样例 #2

### 输入

```
10 165

82 94 21 65 28 22 61 80 81 79

93 35 59 85 96 1 78 72 43 5

12 15 97 49 69 53 18 73 6 58

60 14 23 19 44 99 64 17 29 67

24 39 56 92 88 7 48 75 36 91

74 16 26 10 40 63 45 76 86 3

9 66 42 84 38 51 25 2 33 41

87 54 57 62 47 31 68 11 83 8

46 27 55 70 52 98 20 77 89 34

32 71 30 50 90 4 37 95 13 100```

### 输出

```
348179577```

# AI分析结果

### 题目内容重写

给定一个 $N \times N$ 的矩阵和一个整数 $K$。矩阵中的每个元素 $a_{i,j}$ 都是 $1, 2, \dots, N^2$ 的一个排列。你可以进行以下两种操作，顺序和次数不限：

1. 对于所有 $i$ ($1 \leq i \leq N$)，如果 $a_{i,x} + a_{i,y} \leq K$，则可以选择交换矩阵的第 $x$ 列和第 $y$ 列。
2. 对于所有 $i$ ($1 \leq i \leq N$)，如果 $a_{x,i} + a_{y,i} \leq K$，则可以选择交换矩阵的第 $x$ 行和第 $y$ 行。

最终可以得到多少种不同的矩阵？答案对 $998244353$ 取模。

### 算法分类
并查集、组合数学

### 题解分析与结论

所有题解的核心思路都是将行和列的操作分开处理，利用并查集来维护可以互相交换的行和列，最后通过组合数学计算总的排列方式。具体来说，行和列的操作互不影响，因此可以分别计算行和列的排列方式，然后将两者相乘得到最终结果。

### 所选高星题解

#### 1. 作者：MinimumSpanningTree (4星)
**关键亮点**：
- 使用并查集维护可以互相交换的行和列。
- 分别计算行和列的排列方式，最后相乘得到结果。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
int set_find(int x) {
    return x == fa[x] ? x : fa[x] = set_find(fa[x]);
}

void set_merge(int x, int y) {
    int gx = set_find(x), gy = set_find(y);
    if (gx != gy) fa[gx] = gy;
}

for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        if (check_hang(i, j)) set_merge(i, j);
    }
}
```

#### 2. 作者：_Spectator_ (4星)
**关键亮点**：
- 详细解释了行和列操作互不影响的原理。
- 使用并查集合并可以互相交换的行和列。
- 预处理阶乘，优化计算。

**核心代码**：
```cpp
DSU sr(n), sc(n);
rep(i, 1, n) rep(j, i + 1, n) {
    bool flag1 = 1, flag2 = 1;
    rep(k, 1, n) {
        if (a[i][k] + a[j][k] > m) flag1 = 0;
        if (a[k][i] + a[k][j] > m) flag2 = 0;
    }
    if (flag1) sr.merge(i, j);
    if (flag2) sc.merge(i, j);
}
```

#### 3. 作者：Laoshan_PLUS (4星)
**关键亮点**：
- 通过并查集处理行和列的交换关系。
- 预处理阶乘，简化计算。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
int find(int x) {
    if (f[x] != x) f[x] = find(f[x]);
    return f[x];
}

for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        for (int x = 1; x <= n; x++) if (a[i][x] + a[j][x] > K) goto fu;
        fx = find(i), fy = find(j);
        if (fx != fy) f[fy] = fx, cnt[fx] += cnt[fy];
        fu:;
    }
}
```

### 最优关键思路
1. **并查集的应用**：通过并查集维护可以互相交换的行和列，确保不重不漏地计算排列方式。
2. **组合数学**：利用阶乘计算每个连通块的排列方式，最终将所有连通块的排列方式相乘得到结果。

### 可拓展之处
类似的问题可以通过并查集和组合数学来解决，例如在图的连通性问题中，计算连通块的排列方式。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1491 集合位置](https://www.luogu.com.cn/problem/P1491)
3. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)

---
处理用时：29.21秒
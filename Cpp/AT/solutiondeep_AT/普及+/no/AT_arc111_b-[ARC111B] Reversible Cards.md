# 题目信息

# [ARC111B] Reversible Cards

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc111/tasks/arc111_b

$ 1 $ から $ N $ の番号がついた $ N $ 枚のカードがあり、各カードの両面には正整数で表される色がついています。

カード $ i $ の片面の色は $ a_i $, もう片面の色は $ b_i $ です。

各カードについてどちらの面を表にするか自由に選べるとき、表側に見える色の種類数の最大値はいくつになるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 200000 $
- $ 1\ \leq\ a_i,b_i\ \leq\ 400000 $
- 入力される数はすべて整数

### Sample Explanation 1

それぞれ、$ 1 $,$ 3 $,$ 4 $,$ 2 $ の側を表にすることで $ 4 $ 色を達成できます。

### Sample Explanation 2

そもそも一色しか使われていません。

## 样例 #1

### 输入

```
4

1 2

1 3

4 2

2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
2

111 111

111 111```

### 输出

```
1```

## 样例 #3

### 输入

```
12

5 2

5 6

1 2

9 7

2 7

5 5

4 2

6 7

2 2

7 8

9 7

1 8```

### 输出

```
8```

# AI分析结果

【题目内容】
# [ARC111B] Reversible Cards

## 题目描述

有 $1$ 到 $N$ 编号的 $N$ 张卡片，每张卡片的两面都标有一个正整数表示的颜色。

卡片 $i$ 的一面颜色为 $a_i$，另一面颜色为 $b_i$。

对于每张卡片，可以选择任意一面朝上。求在所有可能的选择中，朝上的颜色种类数的最大值。

## 说明/提示

### 制約

- $1\ \leq\ N\ \leq\ 200000 $
- $1\ \leq\ a_i,b_i\ \leq\ 400000 $
- 输入的所有数都是整数

### 样例解释 1

分别选择 $1$、$3$、$4$、$2$ 的一面朝上，可以达到 $4$ 种颜色。

### 样例解释 2

只有一种颜色被使用。

## 样例 #1

### 输入

```
4

1 2

1 3

4 2

2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
2

111 111

111 111```

### 输出

```
1```

## 样例 #3

### 输入

```
12

5 2

5 6

1 2

9 7

2 7

5 5

4 2

6 7

2 2

7 8

9 7

1 8```

### 输出

```
8```

【算法分类】  
图论

【题解分析与结论】  
本题的核心是将每张卡片的两个颜色视为图中的两个节点，并将卡片视为连接这两个节点的边。问题转化为在图中为每条边选择一个端点，使得被选择的节点总数最大。通过分析连通块的性质，可以得出以下结论：

1. 对于每个连通块，如果它是一个树结构（无环），则最多可以选择 $n-1$ 个节点。
2. 如果连通块中存在环，则可以选择所有 $n$ 个节点。

最优解的关键在于判断每个连通块是否有环，并统计每个连通块的最大可选节点数。

【评分较高的题解】  
1. **作者：rui_er**  
   - **星级：5**  
   - **关键亮点**：通过图论中的连通块分析，将问题转化为对每个连通块的处理，并给出了详细的证明和代码实现。  
   - **代码核心思想**：使用DFS遍历每个连通块，统计节点数和边数，判断是否有环，并根据连通块的性质计算最大可选节点数。  
   ```cpp
   void dfs(int u) {
       vis[u] = 1;
       ++cntV;
       for(int v : e[u]) {
           if(!vis[v]) dfs(v);
           ++cntE;
       }
   }
   ```

2. **作者：CJerryR**  
   - **星级：4**  
   - **关键亮点**：使用并查集处理连通块，通过判断是否有环来确定每个连通块的最大可选节点数。  
   - **代码核心思想**：使用并查集合并节点，并记录每个连通块的大小和是否有环，最后根据连通块的性质计算答案。  
   ```cpp
   int findfa(int x) {
       return x == fa[x] ? x : fa[x] = findfa(fa[x]);
   }
   ```

3. **作者：f_hxr_**  
   - **星级：4**  
   - **关键亮点**：通过并查集判断连通块是否有环，并给出了详细的构造方法。  
   - **代码核心思想**：使用并查集合并节点，并记录每个连通块的大小和是否有环，最后根据连通块的性质计算答案。  
   ```cpp
   int getf(int v) {
       if(f[v]==v) return v;
       return f[v] = getf(f[v]);
   }
   ```

【最优关键思路】  
通过将问题转化为图论中的连通块处理，判断每个连通块是否有环，并根据连通块的性质（树或环）计算最大可选节点数。使用DFS或并查集实现连通块的遍历和环的判断。

【可拓展之处】  
类似的问题可以通过图论中的连通块分析来解决，特别是涉及到边与节点的选择问题。可以进一步扩展到更复杂的图结构，如多重图、有向图等。

【推荐题目】  
1. [P1640 连续攻击游戏](https://www.luogu.com.cn/problem/P1640)  
2. [P3387 缩点](https://www.luogu.com.cn/problem/P3387)  
3. [P3376 网络最大流](https://www.luogu.com.cn/problem/P3376)

---
处理用时：34.07秒
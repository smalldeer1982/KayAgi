# 题目信息

# [ARC113D] Sky Reflector

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc113/tasks/arc113_d

縦 $ N $ マス横 $ M $ マスのマス目の各マスに $ 1 $ 以上 $ K $ 以下の整数をひとつずつ書き込み、列 $ A,B $ を以下のように定義します。

- $ i=1,\dots,\ N $ に対し、$ A_i $ は $ i $ 行目のマスに書かれた整数の最小値
- $ j=1,\dots,\ M $ に対し、$ B_j $ は $ j $ 列目のマスに書かれた整数の最大値

$ N,M,K $ が与えられるので、列対 $ (A,B) $ としてありうる相異なるものの個数を $ 998244353 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,M,K\ \leq\ 2\times\ 10^5 $
- 入力はすべて整数である

### Sample Explanation 1

$ (A_1,A_2,B_1,B_2) $ としてありうるものは、$ (1,1,1,1),(1,1,1,2),(1,1,2,1),(1,1,2,2),(1,2,2,2),(2,1,2,2),(2,2,2,2) $ の $ 7 $ 通りです。

## 样例 #1

### 输入

```
2 2 2```

### 输出

```
7```

## 样例 #2

### 输入

```
1 1 100```

### 输出

```
100```

## 样例 #3

### 输入

```
31415 92653 58979```

### 输出

```
469486242```

# AI分析结果

【题目内容】
# [ARC113D] Sky Reflector

## 题目描述

在一个 $N$ 行 $M$ 列的方格中，每个方格填入 $1$ 到 $K$ 之间的整数。定义两个序列 $A$ 和 $B$：

- $A_i$ 表示第 $i$ 行中所有数的最小值。
- $B_j$ 表示第 $j$ 列中所有数的最大值。

给定 $N, M, K$，求所有可能的 $(A, B)$ 序列对的数量，结果对 $998244353$ 取模。

## 说明/提示

### 制約

- $1 \leq N, M, K \leq 2 \times 10^5$
- 输入均为整数

### 样例解释 1

对于输入 `2 2 2`，可能的 $(A_1, A_2, B_1, B_2)$ 序列对有 $7$ 种。

## 样例 #1

### 输入

```
2 2 2```

### 输出

```
7```

## 样例 #2

### 输入

```
1 1 100```

### 输出

```
100```

## 样例 #3

### 输入

```
31415 92653 58979```

### 输出

```
469486242```

【算法分类】
组合数学

【题解分析与结论】
本题的核心在于通过组合数学的方法计算满足条件的 $(A, B)$ 序列对的数量。主要思路是枚举 $A$ 序列的最大值 $p$，并计算 $A$ 序列最大值为 $p$ 时的方案数，再乘以 $B$ 序列的方案数，最后将所有可能的结果相加。

【精选题解】
1. **作者：__log__ (赞：4)**
   - **星级：5**
   - **关键亮点：**
     - 通过枚举 $A$ 序列的最大值 $p$，利用组合数学公式计算方案数。
     - 使用快速幂和线性筛优化计算，时间复杂度为 $O(k \log n)$。
     - 提供了详细的数学证明和构造方法，确保思路的严谨性。
   - **个人心得：**
     - 强调了在模拟赛中因数组开太大导致的内存问题，提醒了代码优化的重要性。
   - **核心代码：**
     ```cpp
     void init(int p, int q) {
         a[1] = 1; b[1] = 1;
         for(ll i = 2; i <= k; ++i) {
             if(!vis[i]) a[i] = qp(i, p), b[i] = qp(i, q), pri[++tot] = i;
             for(int j = 1; j <= tot && 1ll * i * pri[j] <= k; ++j) {
                 a[i * pri[j]] = 1ll * a[i] * a[pri[j]] % mod;
                 b[i * pri[j]] = 1ll * b[i] * b[pri[j]] % mod;
                 vis[i * pri[j]] = 1;
                 if(i % pri[j] == 0) break;
             }
         }
     }
     ```

2. **作者：max666dong123 (赞：1)**
   - **星级：4**
   - **关键亮点：**
     - 通过反证法证明了 $\max \{ A_i \} \le \min \{B_j \}$，简化了问题。
     - 使用快速幂计算方案数，代码简洁易懂。
   - **核心代码：**
     ```cpp
     int f(int a,int b){
         if(a==0)return 0;
         if(b==0)return 1;
         int ans=f(a,b/2);
         ans=ans*ans%MOD;
         if(b&1)ans=ans*a%MOD;
         return ans;
     }
     ```

3. **作者：AzusidNya (赞：0)**
   - **星级：4**
   - **关键亮点：**
     - 通过构造矩阵证明了满足条件的 $(A, B)$ 序列对的存在性。
     - 详细解释了枚举 $A$ 序列最大值的思路，并给出了清晰的数学表达式。
   - **核心代码：**
     ```cpp
     int ksm(int u, int v){
         int ret = 1;
         while(v){
             if(v & 1) ret = ret * u % modd;
             u = u * u % modd, v >>= 1;
         }
         return ret;
     }
     ```

【最优关键思路】
- 枚举 $A$ 序列的最大值 $p$，利用组合数学公式计算方案数。
- 使用快速幂和线性筛优化计算，确保时间复杂度在可接受范围内。

【可拓展之处】
- 类似的问题可以通过枚举关键变量并利用组合数学公式进行计算。
- 快速幂和线性筛是优化组合数学问题的常用技巧。

【推荐题目】
1. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)
2. [P1495 【模板】快速幂](https://www.luogu.com.cn/problem/P1495)
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

---
处理用时：37.73秒
# 题目信息

# [ARC125C] LIS to Original Sequence

## 题目描述

# [ARC125C] LIS to Original Sequence


[problemUrl]: https://atcoder.jp/contests/arc125/tasks/arc125_c

给定一个长度为 $k$ 的序列 $A_1,A_2,\cdots,A_n$，试求出长度为 $n$ 的序列 $P$，使得 $P$ 的最长上升子序列为 $A_1,A_2,\cdots,A_n$，且 $P$ 的字典序最小。


## 样例 #1

### 样例输入 #1

```
3 2
2 3
```

### 样例输出 #1

```
2 1 3
```

## 样例 #2

### 样例输入 #2

```
5 1
4
```

### 样例输出 #2

```
5 4 3 2 1
```

## 说明/提示

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_1\ <\ A_2\ <\ \cdots\ <\ A_K\ \leq\ N $
- 输入的所有值均为整数。

### 样例一解释

当 $P=（2，1，3）$ 或 $（2，3，1）$ 时，$P$ 的最长上升子序列与 $A$ 一样。 其中，$（2，1，3）$的字典序最小。

## 样例 #1

### 输入

```
3 2

2 3```

### 输出

```
2 1 3```

## 样例 #2

### 输入

```
5 1

4```

### 输出

```
5 4 3 2 1```

# AI分析结果

### 题目重写

给定一个长度为 $k$ 的序列 $A_1,A_2,\cdots,A_n$，试求出长度为 $n$ 的序列 $P$，使得 $P$ 的最长上升子序列为 $A_1,A_2,\cdots,A_n$，且 $P$ 的字典序最小。

### 样例 #1

#### 样例输入 #1

```
3 2
2 3
```

#### 样例输出 #1

```
2 1 3
```

### 样例 #2

#### 样例输入 #2

```
5 1
4
```

#### 样例输出 #2

```
5 4 3 2 1
```

### 说明/提示

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_1\ <\ A_2\ <\ \cdots\ <\ A_K\ \leq\ N $
- 输入的所有值均为整数。

### 样例一解释

当 $P=（2，1，3）$ 或 $（2，3，1）$ 时，$P$ 的最长上升子序列与 $A$ 一样。 其中，$（2，1，3）$的字典序最小。

### 算法分类

贪心、构造

### 题解分析与结论

1. **核心思路**：所有题解都围绕如何在保证最长上升子序列（LIS）为给定序列 $A$ 的前提下，构造字典序最小的序列 $P$。主要思路是通过贪心策略，在 $A$ 的每个元素后面插入尽可能小的数，以保持字典序最小。

2. **难点对比**：
   - **int_R** 的题解通过将不在 $A$ 中的数按升序插入，最后处理 $A_k$ 时降序输出剩余的数，保证了字典序最小。
   - **under_the_time** 的题解通过维护一个集合 $B$，动态查找并插入最小数，最后将剩余数降序输出，思路清晰且代码简洁。
   - **5k_sync_closer** 的题解通过暴力模拟小数据，总结出规律，直接构造序列，代码简洁但思路较为直接。

3. **最优关键思路**：在 $A$ 的每个元素后面插入尽可能小的数，最后将剩余数降序输出，以保证字典序最小且不破坏 LIS。

### 高星题解推荐

#### 1. under_the_time (5星)
- **关键亮点**：通过维护一个集合 $B$，动态查找并插入最小数，最后将剩余数降序输出，思路清晰且代码简洁。
- **代码核心**：
```cpp
for (int i = 1; i < k; i ++) {
    p[++ pos] = a[i];
    if (findL() < a[i])
        add(p[++ pos] = findL());
}
for (; findR() > a[k]; add(p[++ pos] = findR()));
for (p[++ pos] = a[k]; findR() > 0; add(p[++ pos] = findR()));
```

#### 2. int_R (4星)
- **关键亮点**：通过将不在 $A$ 中的数按升序插入，最后处理 $A_k$ 时降序输出剩余的数，保证了字典序最小。
- **代码核心**：
```cpp
for(register int i=1;i<k;++i)
{
    cout<<a[i]<<' ';
    if(cur<=tot&&q[cur]<a[i]) cout<<q[cur++]<<' ';
}
q[++tot]=a[k];sort(q+cur,q+tot+1);
while(tot>=cur) cout<<q[tot--]<<' ';
```

#### 3. 5k_sync_closer (4星)
- **关键亮点**：通过暴力模拟小数据，总结出规律，直接构造序列，代码简洁但思路较为直接。
- **代码核心**：
```cpp
for (int i = 1, x, p = 1; i < k; ++i)
{
    scanf("%d", &x);
    printf("%d ", x);
    b[x] = 1;
    while (b[p])
        ++p;
    if (p < x)
        printf("%d ", p), b[p] = 1;
}
for (int i = n; i; --i)
    if (!b[i])
        printf("%d ", i);
```

### 拓展思路

类似题目可以通过贪心策略构造序列，保证特定条件（如 LIS）的同时，优化其他属性（如字典序）。推荐题目：
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

---
处理用时：34.72秒
# 题目信息

# [ARC126B] Cross-free Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc126/tasks/arc126_b

座標平面上に、$ x $ 座標が $ 1,\ 2,\ \ldots,\ N $、$ y $ 座標が $ 0 $ または $ 1 $ であるような合計 $ 2N $ 個の頂点 $ (1,\ 0),\ldots,\ (N,0),\ (1,1),\ \ldots,\ (N,1) $ があります。 これらのうちの $ 2 $ 頂点を結ぶ線分が $ M $ 個あり、$ i $ 番目の線分は $ (a_i,\ 0) $ と $ (b_i,\ 1) $ を結んでいます。

これら $ M $ 個の線分から $ K $ 個の線分を選び、選んだ線分のうちどの $ 2 $ 個の線分も同一の点を含まないようにすることを考えます。ただし、線分の両端点も線分に含まれる点として扱います。可能な $ K $ の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N,\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ a_i,\ b_i\leq\ N $
- $ i\neq\ j $ ならば、$ a_i\neq\ a_j $ または $ b_i\neq\ b_j $

### Sample Explanation 1

$ 1,\ 2 $ 番目の線分を選ぶことが、最適解のひとつです。 例えば $ 1 $ 番目の線分と $ 3 $ 番目の線分は同一の点 $ \left(\frac53,\ \frac23\right) $ を含むため、同時に選ぶことはできません。 !\[\](https://img.atcoder.jp/arc126/3e4cb12392855ea49b7ed0b643ebd370.png)

### Sample Explanation 2

$ 1,\ 3,\ 5 $ 番目の線分を選ぶことが、最適解のひとつです。 例えば $ 1 $ 番目の線分と $ 2 $ 番目の線分は同一の点 $ (1,\ 1) $ を含むため、同時に選ぶことはできません。 !\[\](https://img.atcoder.jp/arc126/416681cace776c87fac353e0acb9c4a1.png)

### Sample Explanation 3

!\[\](https://img.atcoder.jp/arc126/2436c39ccc0fa35fc57d35647bce9f08.png)

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5

1 1

2 1

2 2

3 2

3 3```

### 输出

```
3```

## 样例 #3

### 输入

```
7 5

1 7

7 1

3 4

2 6

5 2```

### 输出

```
1```

# AI分析结果

### 题目内容重写
在坐标平面上，有 $x$ 坐标为 $1, 2, \ldots, N$，$y$ 坐标为 $0$ 或 $1$ 的 $2N$ 个顶点 $(1, 0), \ldots, (N, 0), (1, 1), \ldots, (N, 1)$。这些顶点之间有 $M$ 条线段，第 $i$ 条线段连接 $(a_i, 0)$ 和 $(b_i, 1)$。现在需要从这 $M$ 条线段中选出 $K$ 条，使得选出的线段之间没有交点（包括端点）。求 $K$ 的最大值。

### 算法分类
贪心、排序、最长上升子序列（LIS）

### 题解分析与结论
#### 题解1：fush
- **星级**：4星
- **关键亮点**：通过排序和最长上升子序列（LIS）巧妙地解决了问题，代码简洁且高效。
- **核心思路**：首先对线段按照 $a_x$ 升序排序，若 $a_x$ 相同则按 $b_y$ 降序排序。然后对 $b_y$ 求最长上升子序列（LIS），LIS 的长度即为所求的最大 $K$。
- **代码实现**：
  ```cpp
  sort(a + 1, a + 1 + m, [](A&i, A&j){return (i.x ^ j.x) ? (i.x < j.x) : (i.y > j.y);});
  f[tot = 1] = a[1].y;
  for(int i = 1; i <= m; i++){
      if(a[i].y > f[tot])f[++tot] = a[i].y;
      else f[find(a[i].y)] = a[i].y;
  }
  ```

#### 题解2：SlyCharlotte
- **星级**：4星
- **关键亮点**：同样使用了排序和 LIS，但使用了单调栈来维护上升子序列，代码结构清晰。
- **核心思路**：对线段按照 $a_x$ 升序排序，若 $a_x$ 相同则按 $b_y$ 降序排序。然后使用单调栈来维护 $b_y$ 的上升子序列，栈的长度即为所求的最大 $K$。
- **代码实现**：
  ```cpp
  sort(a, a + m);
  for (int i = 0; i < m; i ++ ){
      if (!top || a[i].y > stk[top]) stk[++ top] = a[i].y;
      else *lower_bound(stk + 1, stk + 1 + top, a[i].y) = a[i].y;
  }
  ```

### 最优关键思路或技巧
1. **排序策略**：对线段按照 $a_x$ 升序排序，若 $a_x$ 相同则按 $b_y$ 降序排序，这样可以避免线段之间的交叉。
2. **最长上升子序列（LIS）**：通过 LIS 来求解最大不相交线段数，LIS 的长度即为所求的最大 $K$。

### 可拓展之处
类似的问题可以扩展到更高维度的匹配问题，或者在有其他约束条件下的匹配问题。例如，在三维空间中的线段匹配，或者在有容量限制的匹配问题中，可以使用类似的排序和 LIS 技巧。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)

### 个人心得
在调试过程中，发现排序策略的正确性对最终结果影响很大。特别是在 $a_x$ 相同的情况下，$b_y$ 的排序顺序需要特别注意，否则可能会导致错误的 LIS 结果。

---
处理用时：26.18秒
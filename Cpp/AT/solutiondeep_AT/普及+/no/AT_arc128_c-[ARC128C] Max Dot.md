# 题目信息

# [ARC128C] Max Dot

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc128/tasks/arc128_c

整数 $ N,M,S $，及び長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます．

次の条件をすべて満たす長さ $ N $ の非負**実数**列 $ x=(x_1,x_2,\cdots,x_N) $ を作ることを考えます．

- $ 0\ \leq\ x_1\ \leq\ x_2\ \leq\ \cdots\ \leq\ x_N\ \leq\ M $
- $ \sum_{1\ \leq\ i\ \leq\ N}\ x_i=S $

ここで，$ x $ のスコアを $ \sum_{1\ \leq\ i\ \leq\ N}\ A_i\ \times\ x_i $ と定義します． $ x $ のスコアとしてありうる最大の値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5000 $
- $ 1\ \leq\ M\ \leq\ 10^6 $
- $ 1\ \leq\ S\ \leq\ \min(N\ \times\ M,10^6) $
- $ 1\ \leq\ A_i\ \leq\ 10^6 $
- 入力される値はすべて整数である

### Sample Explanation 1

$ x=(0,1,2) $ とするのが最適です．

### Sample Explanation 2

$ x=(2/3,2/3,2/3) $ とするのが最適です．

## 样例 #1

### 输入

```
3 2 3

1 2 3```

### 输出

```
8.00000000000000000000```

## 样例 #2

### 输入

```
3 3 2

5 1 1```

### 输出

```
4.66666666666666666667```

## 样例 #3

### 输入

```
10 234567 1000000

353239 53676 45485 617014 886590 423581 172670 928532 312338 981241```

### 输出

```
676780145098.25000000000000000000```

# AI分析结果

### 题目翻译
#### [ARC128C] Max Dot

**题目描述**

给定整数 $N, M, S$ 以及长度为 $N$ 的整数序列 $A=(A_1, A_2, \cdots, A_N)$。要求构造一个长度为 $N$ 的非负**实数**序列 $x=(x_1, x_2, \cdots, x_N)$，满足以下条件：

- $0 \leq x_1 \leq x_2 \leq \cdots \leq x_N \leq M$
- $\sum_{1 \leq i \leq N} x_i = S$

定义 $x$ 的得分为 $\sum_{1 \leq i \leq N} A_i \times x_i$。求 $x$ 的最大可能得分。

**说明/提示**

**约束条件**

- $1 \leq N \leq 5000$
- $1 \leq M \leq 10^6$
- $1 \leq S \leq \min(N \times M, 10^6)$
- $1 \leq A_i \leq 10^6$
- 输入的所有值均为整数

**样例解释**

**样例 1**

输入：
```
3 2 3
1 2 3
```
输出：
```
8.00000000000000000000
```
解释：$x=(0,1,2)$ 是最优解。

**样例 2**

输入：
```
3 3 2
5 1 1
```
输出：
```
4.66666666666666666667
```
解释：$x=(2/3,2/3,2/3)$ 是最优解。

**样例 3**

输入：
```
10 234567 1000000
353239 53676 45485 617014 886590 423581 172670 928532 312338 981241
```
输出：
```
676780145098.25000000000000000000
```

### 算法分类
贪心

### 题解分析与结论

#### 综合分析
本题的核心在于如何分配 $S$ 到序列 $x$ 中，使得 $\sum A_i x_i$ 最大化。由于 $x$ 需要满足单调不减且不超过 $M$，因此需要找到一个贪心策略来分配 $S$。

#### 题解对比
1. **ZillionX 的题解**：
   - **思路**：通过维护一个单调栈来找到最优的后缀，使得 $S$ 可以均匀分配到这个后缀上。如果 $S$ 无法完全分配，则递归处理剩余部分。
   - **亮点**：使用单调栈优化了时间复杂度，从 $O(n^2)$ 降低到 $O(n)$。
   - **评分**：5星

2. **Sampson_YW 的题解**：
   - **思路**：通过选择性价比最高的后缀，将 $S$ 均匀分配到该后缀上。如果 $S$ 无法完全分配，则将该后缀填满 $M$，并递归处理剩余部分。
   - **亮点**：思路清晰，代码简洁。
   - **评分**：4星

3. **skyskyCCC 的题解**：
   - **思路**：通过差分和贪心策略，找到最优的分配方式。使用贪心选择最大的 $\frac{y_i}{n-i+1}$ 进行分配。
   - **亮点**：结合差分和贪心，思路较为新颖。
   - **评分**：4星

#### 最优思路与技巧
- **单调栈优化**：通过维护一个单调栈，可以高效地找到最优的后缀进行分配，从而将时间复杂度从 $O(n^2)$ 降低到 $O(n)$。
- **贪心策略**：选择性价比最高的后缀进行分配，确保每次分配都能最大化得分。

#### 扩展思路
- 类似的问题可以在分配资源时使用贪心策略，结合单调栈或其他数据结构进行优化。
- 可以扩展到多维度的资源分配问题，使用类似的贪心策略进行求解。

#### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 关键代码片段
```cpp
const int N=5e3+5; 
int n,m,S,a[N];
int tp;
pi st[N];
signed main() {
	scanf("%lld%lld%lld",&n,&m,&S);
	int mx=0;
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for (int i=1;i<=n;i++) {
		if (!tp || (db)st[tp].fi/st[tp].se<a[i]) st[++tp]=mp(a[i],1);
		else {
			st[tp].fi+=a[i],st[tp].se++;
			while (tp>1 && (db)st[tp].fi/st[tp].se<=(db)st[tp-1].fi/st[tp-1].se) {
				st[tp-1].fi+=st[tp].fi;
				st[tp-1].se+=st[tp].se;
				tp--;
			}
		}
	}
	db ans=0;
	while (tp) {
		if (S<=st[tp].se*m) {
			ans+=((db)st[tp].fi/st[tp].se)*S;
			break;
		}
		else ans+=((db)st[tp].fi)*m,S-=m*st[tp].se;
		tp--;
	}
	printf("%.10lf",ans); 
	return 0;
}
```
**核心实现思想**：通过单调栈维护一个平均值单调上升的区间序列，每次选择最优的后缀进行分配，确保每次分配都能最大化得分。

---
处理用时：37.19秒
# 题目信息

# [ARC138C] Rotate and Play Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc138/tasks/arc138_c

$ N $ 枚のカードがあり，$ 1 $ から $ N $ までの番号がついています． カード $ i $ には整数 $ A_i $ が書かれています． なお，ここで $ N $ は偶数です．

これから，すぬけ君と最小太郎君がゲームをします． ゲームは $ N $ ターンからなり，すぬけ君から始めて二人が交互にターンをプレイします． 各ターンでは，以下の操作を行います．

- すぬけ君のターン：まだ誰にも取られていないカードのうち，好きなものを一つ選び，取る．
- 最小太郎君のターン：まだ誰にも取られていないカードのうち，**番号**が最小のものを一つ選び，取る．

すぬけ君のスコアは，すぬけ君が取ったカードに書かれた整数の総和になります． すぬけ君はスコアを最大化するように最適に行動します．

ところで，すぬけ君の大ファンであるあなたは，とある不正を行うことでスコアを最大化しようと考えています． 具体的には，ゲームの開始前に，あなたは以下の行動を一回行います．

- 整数 $ k $ ($ 0\ \leq\ k\ \leq\ N-1 $) を選び，カードに書かれている整数を $ k $ 個左に cyclic-shift する． つまり，カード $ 1,2,\cdots,N $ に書かれている数を，$ A_{k+1},A_{k+2},\cdots,A_N,A_1,\cdots,A_k $ に置き換える．

スコアを最大化するためにあなたが選ぶべき $ k $ の値，およびその $ k $ を選んだ場合のスコアを求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は偶数
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

$ k=1 $ を選ぶと，カード $ 1,2,3,4 $ に書かれた整数は $ 4,1,2,3 $ になります． その後，ゲームは以下のように進行します． - すぬけ君がカード $ 1 $ を取る． - 最小太郎君がカード $ 2 $ を取る． - すぬけ君がカード $ 4 $ を取る． - 最小太郎君がカード $ 3 $ を取る． このときのすぬけ君のスコアは $ 7 $ になります． なお，この例では $ k=2,3 $ でも正解になります．

## 样例 #1

### 输入

```
4

3 4 1 2```

### 输出

```
1 7```

## 样例 #2

### 输入

```
2

1 1```

### 输出

```
0 1```

## 样例 #3

### 输入

```
10

716893678 779607519 555600775 393111963 950925400 636571379 912411962 44228139 15366410 2063694```

### 输出

```
7 3996409938```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $N$ 张卡片，编号从 $1$ 到 $N$。卡片 $i$ 上写有一个整数 $A_i$。注意，$N$ 是偶数。

接下来，Snuke 和 Mr.Min 将进行一个游戏。游戏共有 $N$ 轮，Snuke 先开始，两人交替进行。每轮的操作如下：

- Snuke 的回合：从尚未被取走的卡片中选择任意一张卡片并取走。
- Mr.Min 的回合：从尚未被取走的卡片中选择编号最小的一张卡片并取走。

Snuke 的得分是他取走的卡片上整数的总和。Snuke 会采取最优策略以最大化他的得分。

作为 Snuke 的忠实粉丝，你决定通过某种作弊手段来最大化他的得分。具体来说，在游戏开始前，你可以进行一次操作：

- 选择一个整数 $k$（$0 \leq k \leq N-1$），并将卡片上的整数向左循环移动 $k$ 个位置。即，将卡片 $1,2,\cdots,N$ 上的数替换为 $A_{k+1},A_{k+2},\cdots,A_N,A_1,\cdots,A_k$。

请找出你应该选择的 $k$ 值，以及在该 $k$ 值下 Snuke 的最大得分。

#### 说明/提示

##### 约束

- $2 \leq N \leq 2 \times 10^5$
- $N$ 是偶数
- $1 \leq A_i \leq 10^9$
- 输入的所有值都是整数

##### 样例解释 1

选择 $k=1$ 后，卡片 $1,2,3,4$ 上的整数变为 $4,1,2,3$。游戏进行如下：

- Snuke 取走卡片 $1$。
- Mr.Min 取走卡片 $2$。
- Snuke 取走卡片 $4$。
- Mr.Min 取走卡片 $3$。

此时 Snuke 的得分为 $7$。注意，$k=2,3$ 也是正确答案。

#### 样例 #1

##### 输入

```
4
3 4 1 2
```

##### 输出

```
1 7
```

#### 样例 #2

##### 输入

```
2
1 1
```

##### 输出

```
0 1
```

#### 样例 #3

##### 输入

```
10
716893678 779607519 555600775 393111963 950925400 636571379 912411962 44228139 15366410 2063694
```

##### 输出

```
7 3996409938
```

### 算法分类
贪心

### 题解分析与结论

#### 题解对比

1. **TillTheEnd 的题解**：
   - **思路**：通过观察样例，猜测 Snuke 可以取到最大的 $n/2$ 个数，并通过折线图的方法找到合适的 $k$。
   - **难点**：折线图的理解与应用，如何确保 Snuke 取到最大的 $n/2$ 个数。
   - **评分**：4星
   - **亮点**：通过折线图直观地解释了如何选择 $k$，思路清晰。

2. **XYQ_102 的题解**：
   - **思路**：将问题转化为前缀和问题，通过滑动窗口或 ST 表找到合适的 $k$。
   - **难点**：前缀和的处理与滑动窗口的实现。
   - **评分**：4星
   - **亮点**：利用前缀和和滑动窗口高效地解决了问题，代码实现较为简洁。

3. **Phartial 的题解**：
   - **思路**：通过枚举偏移量，使用线段树维护每个 $1$ 的 $b_i$ 值，确保每个 $1$ 都满足 $c_0 \ge c_1$。
   - **难点**：线段树的实现与维护。
   - **评分**：3星
   - **亮点**：使用线段树进行全局维护，思路较为复杂但实现完整。

4. **Inui_Sana 的题解**：
   - **思路**：通过证明 Snuke 一定能取到前 $n/2$ 大的数，并利用差分找到合适的 $k$。
   - **难点**：证明过程的理解与差分的应用。
   - **评分**：3星
   - **亮点**：提供了详细的证明过程，但代码实现较为复杂。

#### 最优关键思路

- **贪心策略**：Snuke 应该尽可能取到最大的 $n/2$ 个数，通过循环移动卡片顺序来确保这一点。
- **前缀和与滑动窗口**：通过计算前缀和并使用滑动窗口或 ST 表来快速找到合适的 $k$。

#### 可拓展之处

- **类似问题**：可以扩展到其他需要最大化或最小化某些值的贪心问题，尤其是在有交互或轮换操作的情况下。
- **数据结构**：滑动窗口、ST 表、线段树等数据结构在处理类似问题时非常有用。

#### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P1047 装箱问题](https://www.luogu.com.cn/problem/P1047)

#### 个人心得摘录

- **TillTheEnd**：通过折线图直观地理解了如何选择 $k$，思路清晰且易于理解。
- **XYQ_102**：利用前缀和和滑动窗口高效地解决了问题，代码实现简洁且高效。
- **Phartial**：使用线段树进行全局维护，思路较为复杂但实现完整，适合深入学习线段树的同学。

### 所选高分题解

#### TillTheEnd 的题解
- **星级**：4星
- **关键亮点**：通过折线图直观地解释了如何选择 $k$，思路清晰。
- **代码核心思想**：
  ```cpp
  // 通过折线图找到最高点，选择从该点开始循环移动
  int k = findHighestPoint();
  cout << k << ' ' << calculateScore(k) << endl;
  ```

#### XYQ_102 的题解
- **星级**：4星
- **关键亮点**：利用前缀和和滑动窗口高效地解决了问题，代码实现简洁且高效。
- **代码核心思想**：
  ```cpp
  // 计算前缀和并使用滑动窗口找到合适的 k
  int k = findKUsingSlidingWindow();
  cout << k << ' ' << calculateScore(k) << endl;
  ```

### 核心代码片段

#### XYQ_102 的题解
```cpp
#include <bits/stdc++.h>
#define il inline
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
using namespace std;

using ll = long long;
const int maxn = 2e5 + 5;
int n, st[20][maxn << 1], lg[maxn << 1];

struct Node {
    ll val; int id;
} a[maxn << 1];

int main() {
    cin >> n;
    FOR(i, 1, n) cin >> a[i].val, a[i].id = i;
    sort(a + 1, a + n + 1, [](const Node &a, const Node &b) {return a.val > b.val;});
    ll sum = 0, tmp = a[n >> 1].val;
    FOR(i, 1, n >> 1) sum += a[i].val, a[i].val = 1;
    FOR(i, (n >> 1) + 1, n) a[i].val = -1;
    sort(a + 1, a + n + 1, [](const Node &a, const Node &b) {return a.id < b.id;});
    FOR(i, 1, n) a[n + i] = a[i];
    lg[0] = -1;
    FOR(i, 1, n << 1) st[0][i] = st[0][i - 1] + a[i].val, lg[i] = lg[i >> 1] + 1;
    FOR(j, 1, 19) FOR(i, 1, (n << 1) - (1 << j) + 1) st[j][i] = max(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
    const int s = 31 - __builtin_clz(n);
    FOR(i, 1, n) if (a[i].val == 1) {
        int ret = max(st[s][i], st[s][i + n - (1 << s)]);
        if (ret <= st[0][i]) return cout << i - 1 << ' ' << sum << endl, 0;
    }
    return 0;
}
```

---
处理用时：59.25秒
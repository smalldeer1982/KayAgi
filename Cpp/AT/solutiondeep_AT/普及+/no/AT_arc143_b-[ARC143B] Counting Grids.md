# 题目信息

# [ARC143B] Counting Grids

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc143/tasks/arc143_b

$ N\ \times\ N $ のマス目の各マスに $ 1 $ から $ N^2 $ までの整数を $ 1 $ つずつ書き込む方法であって， どのマスも以下の条件のうち少なくとも一方を満たすようなものの個数を $ 998244353 $ で割ったあまりを求めてください．

- そのマスに書かれている数より大きい数が書かれているマスが同じ列に存在する．
- そのマスに書かれている数より小さい数が書かれているマスが同じ行に存在する．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 500 $

### Sample Explanation 1

例えば，以下のような書き込み方は条件を満たします． ``` 13 42 ``` この場合，左上のマスは左下のマスに書かれている数より小さい数が書かれているので， $ 1 $ つ目の条件を満たします．ただし，$ 2 $ つ目の条件は満たしません．

## 样例 #1

### 输入

```
2```

### 输出

```
8```

## 样例 #2

### 输入

```
5```

### 输出

```
704332752```

## 样例 #3

### 输入

```
100```

### 输出

```
927703658```

# AI分析结果

### 题目内容重写
#### [ARC143B] Counting Grids

**题目描述**

给定一个 $N \times N$ 的网格，每个格子中填入 $1$ 到 $N^2$ 的整数，且每个整数只能使用一次。要求填法满足以下条件之一：

- 该格子所在的列中存在比它大的数。
- 该格子所在的行中存在比它小的数。

求满足条件的填法总数，结果对 $998244353$ 取模。

**说明/提示**

**约束条件**

- $1 \leq N \leq 500$

**样例解释 1**

例如，以下填法满足条件：
```
1 3
4 2
```
左上角的格子（1）所在列中存在比它大的数（4），因此满足第一个条件。虽然它不满足第二个条件，但整体方案仍然合法。

**样例 #1**

**输入**
```
2
```

**输出**
```
8
```

**样例 #2**

**输入**
```
5
```

**输出**
```
704332752
```

**样例 #3**

**输入**
```
100
```

**输出**
```
927703658
```

### 算法分类
组合数学

### 题解分析与结论
本题的核心思路是通过“正难则反”的方法，计算不合法的方案数，然后用总方案数减去不合法方案数得到合法方案数。所有题解都基于以下关键结论：**不合法的方案中，有且仅有一个格子不满足条件**。这一结论通过反证法得到，即假设存在两个不合法格子会导致矛盾。

各题解的主要思路是枚举不合法格子的位置和值，计算该情况下的方案数，最后用总方案数减去这些不合法方案数。计算不合法方案数时，涉及到排列组合的计算，特别是阶乘和逆元的预处理。

### 精选题解

#### 题解1：作者 TKXZ133
**星级：4.5**
**关键亮点：**
- 详细解释了“正难则反”的思路，并给出了不合法方案数的计算公式。
- 代码中预处理了阶乘和逆元，优化了计算效率。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
int fac[N], inv[N];
int n, ans;

int q_pow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

int A(int n, int m) {
    if (n < m) return 0;
    return fac[n] * inv[n - m] % mod;
}

signed main() {
    scanf("%lld", &n);
    int n2 = n * n;
    fac[0] = 1;
    for (int i = 1; i <= n2; i++) fac[i] = fac[i - 1] * i % mod;
    inv[n2] = q_pow(fac[n2], mod - 2);
    for (int i = n2; i >= 1; i--) inv[i - 1] = inv[i] * i % mod;
    for (int i = n; i <= n2 - n + 1; i++) 
        ans = (ans + A(n2 - i, n - 1) * A(i - 1, n - 1) % mod) % mod;
    ans = (ans * fac[(n - 1) * (n - 1)] % mod) * n2 % mod;
    ans = (fac[n * n] - ans + mod) % mod;
    cout << ans << '\n';
    return 0;
}
```

#### 题解2：作者 copper_ingot
**星级：4**
**关键亮点：**
- 简洁明了地解释了不合法方案的计算方法。
- 代码中同样预处理了阶乘和逆元，优化了计算效率。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
int n, fac[300001] = {1}, inv[300001], invf[300001] = {1}, ans;
int A(int n, int m) { return fac[n] * invf[n - m] % mod; }

signed main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n * n; i++) {
        fac[i] = fac[i - 1] * i % mod;
        inv[i] = (i == 1 ? i : (mod - mod / i) * inv[mod % i] % mod);
        invf[i] = invf[i - 1] * inv[i] % mod;
    }
    for (int i = n; i <= n * n - n + 1; i++)
        ans = (ans + A(n * n - i, n - 1) * A(i - 1, n - 1) % mod) % mod;
    ans = (ans * fac[(n - 1) * (n - 1)] % mod * n * n % mod);
    printf("%lld\n", (fac[n * n] - ans + mod) % mod);
    return 0;
}
```

#### 题解3：作者 CCX_CoolMint
**星级：4**
**关键亮点：**
- 详细解释了不合法方案的计算方法，并给出了不合法方案数的计算公式。
- 代码中预处理了阶乘和逆元，优化了计算效率。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
ll n, fac[1001000], ans;
ll ksm(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
ll A(ll x, ll y) {
    return fac[x] * ksm(fac[x - y], mod - 2) % mod;
}
int main() {
    cin >> n;
    fac[0] = 1;
    for (int i = 1; i <= n * n; i++) fac[i] = fac[i - 1] * i % mod;
    for (int i = n; i <= n * n - n + 1; i++) {
        ans += A(n * n - i, n - 1) * A(i - 1, n - 1) % mod;
        ans %= mod;
    }
    ans = ans * fac[(n - 1) * (n - 1)] % mod * n % mod * n % mod;
    ans = (fac[n * n] - ans + mod) % mod;
    cout << ans;
    return 0;
}
```

### 最优关键思路或技巧
1. **正难则反**：通过计算不合法方案数，再用总方案数减去不合法方案数，得到合法方案数。
2. **排列组合计算**：通过预处理阶乘和逆元，优化排列组合的计算效率。
3. **枚举不合法格子的位置和值**：通过枚举不合法格子的位置和值，计算不合法方案数。

### 可拓展之处
类似的问题可以通过“正难则反”的思路来解决，特别是当直接计算合法方案数较为复杂时，可以考虑计算不合法方案数，再用总方案数减去不合法方案数。

### 推荐题目
1. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)
2. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)
3. [P2602 [ZJOI2010]数字计数](https://www.luogu.com.cn/problem/P2602)

---
处理用时：48.80秒
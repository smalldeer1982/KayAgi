# 题目信息

# [ARC143C] Piles of Pebbles

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc143/tasks/arc143_c

小石の山が $ N $ 個あります．最初，$ i $ 番目の山には $ A_i $ 個の小石があります．

これらを用いて，高橋君と青木君がゲームをします． 高橋君から始めて，交互に次の操作を行い，操作を行えなくなった方が負けとなります．

- 山を $ 1 $ つ以上選び，選んだそれぞれの山から，高橋君の操作の場合は $ X $ 個ずつ，青木君の操作の場合は $ Y $ 個ずつ小石を取り除く． ただし，小石の個数が足りない山を選ぶことはできない．

二人が最適に行動したとき，どちらがゲームに勝つかを求めてください.

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ X,\ Y\ \leq\ 10^9 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $

### Sample Explanation 1

例えば，以下のようなゲームの進行が考えられます． - 高橋君が両方の山から石を $ 1 $ つ取り除く． - 青木君が $ 1 $ 番目の山から石を $ 1 $ つ取り除く． - 高橋君が $ 1 $ 番目の山から石を $ 1 $ つ取り除く． - 青木君が $ 2 $ 番目の山から石を $ 1 $ つ取り除く． - 高橋君が $ 2 $ 番目の山から石を $ 1 $ つ取り除く． 青木君がどのように操作を行っても高橋君が勝つことができるので，答えは `First` です．

## 样例 #1

### 输入

```
2 1 1

3 3```

### 输出

```
First```

## 样例 #2

### 输入

```
2 1 2

3 3```

### 输出

```
Second```

# AI分析结果

### 题目翻译

**题目描述**

有 $N$ 堆石子。最初，第 $i$ 堆有 $A_i$ 个石子。

高桥君和青木君用这些石子进行游戏。高桥君先开始，两人轮流进行以下操作，无法进行操作的一方输掉游戏。

- 选择至少一堆石子，对于选中的每一堆，高桥君的操作中取走 $X$ 个石子，青木君的操作中取走 $Y$ 个石子。注意，不能选择石子数量不足的堆。

当两人都采取最优策略时，判断谁会获胜。

**说明/提示**

**约束条件**

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq X, Y \leq 10^9$
- $1 \leq A_i \leq 10^9$

**样例解释 1**

例如，游戏可能按以下方式进行：
- 高桥君从两堆中各取走 1 个石子。
- 青木君从第 1 堆中取走 1 个石子。
- 高桥君从第 1 堆中取走 1 个石子。
- 青木君从第 2 堆中取走 1 个石子。
- 高桥君从第 2 堆中取走 1 个石子。

无论青木君如何操作，高桥君都能获胜，因此答案是 `First`。

**样例 #1**

**输入**

```
2 1 1

3 3
```

**输出**

```
First
```

**样例 #2**

**输入**

```
2 1 2

3 3
```

**输出**

```
Second
```

### 算法分类
数学

### 题解分析与结论

这道题的核心在于通过模运算将问题简化，并利用博弈论中的基本策略来判断胜负。所有题解都采用了将石子数对 $x+y$ 取模的策略，然后根据模结果和 $x$、$y$ 的大小关系来判断先手或后手的胜负。

### 精选题解

#### 题解1：AIskeleton (5星)
**关键亮点**：
- 思路清晰，详细分析了不同情况下的胜负判断。
- 代码简洁，逻辑明确，易于理解。

**核心代码**：
```cpp
int main(){
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n,x,y;
  cin>>n>>x>>y;

  vector<int>a(n);
  bool f=0;
  for(int &i:a){
    cin>>i;
    i%=(x+y);
    f|=(i>=x);
  }

  if(!f){
    cout<<"Second\n";
  }
  else if(x<=y){
    cout<<"First\n";
  }
  else{
    f=0;
    for(int i:a){
      f|=(i>=y&&i<x);
    }
    if(!f){
      cout<<"First\n";
    }
    else{
      cout<<"Second\n";
    }
  }
  return 0;
}
```

#### 题解2：TempestMiku (4星)
**关键亮点**：
- 详细解释了模运算的意义和博弈策略。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int main(void){
    n=read(),x=read(),y=read();
    for(register int i=1;i<=n;i++){
        a[i]=read();
        a[i]%=(x+y);
        if(a[i]>=x){
            flag=true;
        }
    }
    if(!flag){
        puts("Second");
        return 0;
    }
    if(x<=y){
        puts("First");
        return 0;
    }
    flag=false;
    for(register int i=1;i<=n;i++){
        if(a[i]<x&&a[i]>=y){
            puts("Second");
            return 0;
        }
    }
        puts("First");
    return 0;
}
```

#### 题解3：DengDuck (4星)
**关键亮点**：
- 详细分析了不同情况下的胜负判断，逻辑清晰。
- 代码简洁，易于理解。

**核心代码**：
```cpp
int main()
{
	cin>>n>>x>>y;
	LL mx=0;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]%=x+y;
		mx=max(a[i],mx);
	}
	if(mx<x)
	{
		puts("Second");
		return 0;
	}
	if(x<=y)
	{
		puts("First");
		return 0;
	}
	LL flg=0;
	for(int i=1;i<=n;i++)
	{
		flg|=(a[i]<x&&a[i]>=y);
	}
	if(!flg)puts("First");
	else puts("Second");
}
```

### 最优关键思路或技巧
1. **模运算简化问题**：将石子数对 $x+y$ 取模，简化问题规模。
2. **博弈策略分析**：根据模结果和 $x$、$y$ 的大小关系，判断先手或后手的胜负。
3. **分情况讨论**：详细分析不同情况下的胜负判断，确保逻辑严谨。

### 可拓展之处
- 类似问题可以通过模运算和博弈策略分析来解决，如取石子游戏的变种。
- 可以进一步研究博弈论中的其他经典问题，如Nim游戏、Grundy数等。

### 推荐题目
1. [P1247 取石子游戏](https://www.luogu.com.cn/problem/P1247)
2. [P2197 Nim游戏](https://www.luogu.com.cn/problem/P2197)
3. [P1488 取石子游戏](https://www.luogu.com.cn/problem/P1488)

---
处理用时：37.61秒
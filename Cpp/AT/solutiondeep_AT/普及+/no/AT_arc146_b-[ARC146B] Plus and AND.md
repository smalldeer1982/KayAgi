# 题目信息

# [ARC146B] Plus and AND

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc146/tasks/arc146_b

長さ $ N $ の非負整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。あなたは以下の操作を $ M $ 回以下行うことができます。($ 1 $ 回も行わなくてもよいです。)

- $ 1\ \le\ i\ \le\ N $ を満たす整数 $ i $ を選び、$ A_i $ を $ 1 $ 増やす。

その後、$ A $ の中から $ K $ 要素を選びます。

選んだ $ K $ 要素のビット単位 $ \mathrm{AND} $ の最大値を求めてください。

  ビット単位 $ \mathrm{AND} $ 演算とは  整数 $ A,\ B $ のビット単位 $ \mathrm{AND} $、$ A\ \mathrm{AND}\ B $ は以下のように定義されます。

- $ A\ \mathrm{AND}\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち両方が $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \mathrm{AND}\ 5\ =\ 1 $ となります (二進表記すると: $ 011\ \mathrm{AND}\ 101\ =\ 001 $)。  
 一般に $ k $ 個の整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 $ \mathrm{AND} $ は $ (\dots\ ((p_1\ \mathrm{AND}\ p_2)\ \mathrm{AND}\ p_3)\ \mathrm{AND}\ \dots\ \mathrm{AND}\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots\ p_k $ の順番によらないことが証明できます。 ​

## 说明/提示

### 制約

- $ 1\ \le\ K\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 0\ \le\ M\ <\ 2^{30} $
- $ 0\ \le\ A_i\ <\ 2^{30} $
- 入力は全て整数である。

### Sample Explanation 1

以下のような手順を踏むことで 選んだ $ 2 $ 要素の $ \mathrm{AND} $ として $ 10 $ を達成できます。 - $ A_3 $ を選ぶ操作を $ 6 $ 回行う。$ A_3\ =\ 10 $ となる。 - $ A_4 $ を選ぶ操作を $ 2 $ 回行う。$ A_4\ =\ 10 $ となる。 - $ A_3,A_4 $ を選ぶ。$ 2 $ 要素の $ \mathrm{AND} $ は $ 10 $ である。 選んだ $ 2 $ 要素の $ \mathrm{AND} $ を $ 11 $ 以上にすることはできないので、解は $ 10 $ です。

## 样例 #1

### 输入

```
4 8 2

1 2 4 8```

### 输出

```
10```

## 样例 #2

### 输入

```
5 345 3

111 192 421 390 229```

### 输出

```
461```

# AI分析结果

### 题目内容重写

给定一个长度为 $N$ 的非负整数序列 $A=(A_1,A_2,\dots,A_N)$。你可以进行最多 $M$ 次操作（可以不进行操作），每次操作可以选择一个 $1 \le i \le N$ 的整数 $i$，并将 $A_i$ 增加 $1$。之后，从 $A$ 中选择 $K$ 个元素，求这 $K$ 个元素的按位与（$\mathrm{AND}$）的最大值。

按位与运算的定义如下：对于两个整数 $A$ 和 $B$，它们的按位与 $A\ \mathrm{AND}\ B$ 是一个整数，其二进制表示中的每一位 $2^k$（$k \ge 0$）为 $1$ 当且仅当 $A$ 和 $B$ 的二进制表示中该位都为 $1$，否则为 $0$。例如，$3\ \mathrm{AND}\ 5\ =\ 1$（二进制表示为 $011\ \mathrm{AND}\ 101\ =\ 001$）。

对于 $k$ 个整数 $p_1,\ p_2,\ p_3,\ \dots,\ p_k$，它们的按位与定义为 $(\dots\ ((p_1\ \mathrm{AND}\ p_2)\ \mathrm{AND}\ p_3)\ \mathrm{AND}\ \dots\ \mathrm{AND}\ p_k)$，并且这个结果与 $p_1,\ p_2,\ p_3,\ \dots\ p_k$ 的顺序无关。

### 算法分类
贪心、位运算

### 题解分析与结论

#### 题解1：Phartial
**星级：4星**
**关键亮点：**
1. **按位贪心**：从最高位开始逐位确定答案的二进制表示，确保每次选择的位尽可能大。
2. **代价计算**：通过计算将每个数的某一位变为1的代价，选择代价最小的前 $K$ 个数进行操作。
3. **剪枝优化**：在确定某一位为1后，删除那些该位为0的数，减少后续计算量。

**核心代码：**
```cpp
for (int i = 31; i >= 0 && n >= k; --i) {
    for (int j = 1; j <= n; ++j) {
        d[j] = j;
        b[j] = max(0LL, (1LL << i) - (a[j] & ((1LL << i + 1) - 1)));  // 计算代价
    }
    sort(d + 1, d + n + 1, [](int i, int j) { return b[i] < b[j]; });
    LL s = 0;
    for (int j = 1; j <= k; ++j) {  // 选代价前 k 小的数
        s += b[d[j]];
    }
    if (s <= m) {                     // 如果可行
        m -= s, ans |= 1 << i;          // 将答案的这一位设为 1
        for (int j = 1; j <= k; ++j) {  // 修改对应的数
            a[d[j]] += b[d[j]];
        }
        int _n = 0;
        for (int j = 1; j <= n; ++j) {  // 删掉不能选的数
            if (a[j] >> i & 1) {
                _a[++_n] = a[j];
            }
        }
        copy_n(_a + 1, n = _n, a + 1);
    }
}
```

**个人心得：**
- **调试经历**：在实现过程中，发现代价计算部分容易出错，特别是在处理二进制位时，需要仔细检查位运算的正确性。
- **顿悟感想**：通过逐位确定答案的二进制表示，能够有效地减少问题的复杂度，这种贪心策略在处理位运算相关问题时非常有效。

### 最优关键思路或技巧
1. **按位贪心**：从最高位开始逐位确定答案的二进制表示，确保每次选择的位尽可能大。
2. **代价计算与选择**：通过计算将每个数的某一位变为1的代价，选择代价最小的前 $K$ 个数进行操作，确保总代价不超过 $M$。
3. **剪枝优化**：在确定某一位为1后，删除那些该位为0的数，减少后续计算量。

### 可拓展之处
- **类似问题**：在处理位运算相关的问题时，按位贪心是一种常见的策略。例如，求最大异或和、最小按位或等问题都可以采用类似的思路。
- **算法套路**：按位贪心结合代价计算和剪枝优化，可以应用于多种位运算相关的问题。

### 推荐题目
1. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)
2. [P4551 [POI2017]Tree](https://www.luogu.com.cn/problem/P4551)
3. [P4310 [NOI2010]超级钢琴](https://www.luogu.com.cn/problem/P4310)

这些题目都涉及到位运算和贪心策略，能够帮助进一步理解和掌握相关技巧。

---
处理用时：33.99秒
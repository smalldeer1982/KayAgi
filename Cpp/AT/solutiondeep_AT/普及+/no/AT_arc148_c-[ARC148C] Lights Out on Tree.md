# 题目信息

# [ARC148C] Lights Out on Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc148/tasks/arc148_c

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の根付き木があります。頂点 $ 1 $ が根で、頂点 $ i $ $ (2\ \leq\ i\ \leq\ N) $ の親は頂点 $ P_i $ です。  
 表裏のあるコインが $ N $ 枚あります。コインは全ての頂点の上に $ 1 $ 枚ずつ載っています。  
 また、$ 1 $ から $ N $ までの番号がついた $ N $ 個のボタンがあります。ボタン $ n $ を押すと $ n $ を根とする部分木に含まれる頂点に載っている全てのコインが裏返ります。

以下で説明するクエリを $ Q $ 個処理してください。

$ i $ 番目のクエリではサイズ $ M_i $ の頂点集合 $ S_i\ =\ \lbrace\ v_{i,1},\ v_{i,2},\dots,\ v_{i,M_i}\ \rbrace $ が与えられます。  
 今、$ S_i $ に含まれる頂点の上に載っているコインは表を、それ以外のコインは裏を向いています。ボタンを $ 1 $ つ選んで押すことを繰り返して、$ N $ 枚のコイン全てを裏向きにするには、最小で何回ボタンを押す必要がありますか？答えを出力してください。ただし、どのようにボタンを押しても $ N $ 枚のコイン全てが裏向きにならない場合は $ -1 $ を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ P_i\ \lt\ i $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M_i $
- $ \displaystyle\ \sum_{i=1}^Q\ M_i\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ v_{i,j}\ \leq\ N $
- $ v_{i,1},\ v_{i,2},\dots,v_{i,M_i} $ は互いに異なる
- 入力される値はすべて整数

### Sample Explanation 1

$ 1 $ 番目のクエリについて、以下に説明するようにボタンを $ 1 $ 回押すことで条件を満たすことができて、これが最小です。 - ボタン $ 1 $ を押す。頂点 $ 1,2,3,4,5,6 $ に載っているコインが裏返る。 $ 2 $ 番目のクエリについて、以下に説明するようにボタンを $ 2 $ 回押すことで条件を満たすことができて、これが最小です。 - ボタン $ 4 $ を押す。頂点 $ 4 $ に載っているコインが裏返る。 - ボタン $ 2 $ を押す。頂点 $ 2,4,5,6 $ に載っているコインが裏返る。

## 样例 #1

### 输入

```
6 6

1 1 2 2 5

6 1 2 3 4 5 6

3 2 5 6

1 3

3 1 2 3

3 4 5 6

4 2 3 4 5```

### 输出

```
1

2

1

3

2

3```

# AI分析结果

### 题目内容重写

**题目描述**

给定一棵有 $N$ 个节点的根树，根节点为 $1$。每个节点上有一枚硬币，初始状态为正面朝上。有 $N$ 个按钮，按下按钮 $n$ 会翻转以节点 $n$ 为根的子树中所有节点的硬币状态。

现在有 $Q$ 个查询，每个查询给出一个节点集合 $S_i$，要求将 $S_i$ 中的节点上的硬币翻转为正面朝上，其余节点上的硬币翻转为反面朝上。问最少需要按下多少次按钮，才能将所有硬币翻转为反面朝上。如果无法实现，则输出 $-1$。

**说明/提示**

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq Q \leq 2 \times 10^5$
- $\sum_{i=1}^Q M_i \leq 2 \times 10^5$

### 算法分类
**树状数组**

### 题解分析与结论

该问题的核心在于如何高效地处理树上的翻转操作，并快速计算每个查询的最小操作次数。题解中主要采用了以下几种思路：

1. **线段树优化**：通过 BFS 对树进行编号，使得同一深度的节点编号连续，从而可以利用线段树高效地进行区间翻转操作。
2. **贪心策略**：通过分析每个节点的翻转操作对子树的影响，利用贪心策略确定最小操作次数。
3. **虚树优化**：通过构建虚树，减少需要处理的节点数量，从而优化时间复杂度。

### 所选高分题解

#### 题解1：mlvx (赞：8) - 5星
**关键亮点**：
- 使用 BFS 对树进行编号，使得同一深度的节点编号连续，便于线段树操作。
- 通过线段树实现区间翻转操作，高效处理每个查询。

**核心代码**：
```cpp
void bfs(int rt){
    queue<int>q;q.push(rt);
    while(!q.empty()){
        int t=q.front();q.pop(),id[t]=++cnt;
        for(int i:g[t])q.push(i);
    }
}
```
**核心实现思想**：
通过 BFS 对树进行编号，使得同一深度的节点编号连续，便于后续的线段树操作。

#### 题解2：ccxswl (赞：3) - 4星
**关键亮点**：
- 通过贪心策略，直接计算每个查询的最小操作次数，避免了复杂的树结构处理。
- 利用预处理每个节点的儿子数量，快速计算每个查询的答案。

**核心代码**：
```cpp
for(int i=1;i<=m;i++){
    if(!color[fa[in[i]]]) ans++;
    else ans--;
    ans += son[in[i]];
}
```
**核心实现思想**：
通过预处理每个节点的儿子数量，快速计算每个查询的最小操作次数。

#### 题解3：AqrDAD (赞：1) - 4星
**关键亮点**：
- 通过虚树优化，减少需要处理的节点数量，从而优化时间复杂度。
- 利用动态规划的思想，计算每个查询的最小操作次数。

**核心代码**：
```cpp
void dp_(int x){
    for(int i=0;i<ve[x].size();i++){
        int y=ve[x][i];dp_(y);
        if(vis[x]==1){
            if(f[y][0]==x)
                fg[x]+=fg[y]-1,dp[x]+=fg[y]-1;
            else fg[x]+=dp[y],dp[x]+=dp[y];
            continue;
        }dp[x]+=dp[y];fg[x]+=dp[y];
    }if(vis[x]==1){
        dp[x]+=g[x].size();
        fg[x]+=g[x].size();
        dp[x]+=1;
    }else fg[x]+=1;
}
```
**核心实现思想**：
通过虚树优化，减少需要处理的节点数量，利用动态规划计算每个查询的最小操作次数。

### 最优关键思路或技巧
- **线段树优化**：通过 BFS 对树进行编号，使得同一深度的节点编号连续，便于线段树操作。
- **贪心策略**：通过预处理每个节点的儿子数量，快速计算每个查询的最小操作次数。
- **虚树优化**：通过构建虚树，减少需要处理的节点数量，从而优化时间复杂度。

### 可拓展之处
- 类似问题可以扩展到更复杂的树结构，如多叉树或带权树。
- 可以结合其他数据结构，如树状数组或分块，进一步优化时间复杂度。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P2146 [NOI2015] 软件包管理器](https://www.luogu.com.cn/problem/P2146)

### 个人心得摘录
- **mlvx**：通过 BFS 对树进行编号，使得同一深度的节点编号连续，便于线段树操作。
- **ccxswl**：通过预处理每个节点的儿子数量，快速计算每个查询的最小操作次数。
- **AqrDAD**：通过虚树优化，减少需要处理的节点数量，从而优化时间复杂度。

---
处理用时：43.08秒
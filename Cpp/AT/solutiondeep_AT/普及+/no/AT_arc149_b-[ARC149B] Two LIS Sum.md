# 题目信息

# [ARC149B] Two LIS Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc149/tasks/arc149_b

数列 $ P\ =\ (P_1,\ \ldots,\ P_N) $ に対し，その最長増加部分列の長さを $ \mathrm{LIS}(P) $ と書くことにします．

$ 1 $ 以上 $ N $ 以下の整数からなる順列 $ A\ =\ (A_1,\ \ldots,\ A_N) $ および $ B\ =\ (B_1,\ \ldots,\ B_N) $ が与えられます．これらの数列に対して，以下の操作を何度でも行うことができます（$ 0 $ 回でもよいです）．

- $ 1\leq\ i\leq\ N-1 $ となる整数 $ i $ をひとつ選ぶ．$ A_i $ と $ A_{i+1} $ をスワップし，$ B_i $ と $ B_{i+1} $ をスワップする．

操作結果の $ \mathrm{LIS}(A)\ +\ \mathrm{LIS}(B) $ としてありうる最大値を答えてください．

 最長増加部分列とは 数列の部分列とは，数列から $ 0 $ 個以上の要素を取り除いた後，残りの要素を元の順序で連結して得られる数列のことをいいます． 例えば，$ (10,30) $ は $ (10,20,30) $ の部分列ですが，$ (20,10) $ は $ (10,20,30) $ の部分列ではありません．

 数列の最長増加部分列とは，数列の狭義単調増加な部分列のうち，長さが最大のもののことをいいます．

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 3\times\ 10^5 $
- $ 1\leq\ A_i\leq\ N $
- $ 1\leq\ B_i\leq\ N $
- $ i\neq\ j $ ならば $ A_i\neq\ A_j $ かつ $ B_i\neq\ B_j $

### Sample Explanation 1

例えば次のように操作を行うことで，$ \mathrm{LIS}(A)\ +\ \mathrm{LIS}(B)\ =\ 8 $ を達成できます． - $ i\ =\ 2 $ として操作を行う．$ A\ =\ (5,1,2,4,3) $, $ B\ =\ (3,2,1,5,4) $ となる． - $ i\ =\ 1 $ として操作を行う．$ A\ =\ (1,5,2,4,3) $, $ B\ =\ (2,3,1,5,4) $ となる． - $ i\ =\ 4 $ として操作を行う．$ A\ =\ (1,5,2,3,4) $, $ B\ =\ (2,3,1,4,5) $ となる． このとき $ A $ は最長増加部分列 $ (1,2,3,4) $ を持ち，$ \mathrm{LIS}(A)=4 $ が成り立ちます．$ B $ は最長増加部分列 $ (2,3,4,5) $ を持ち，$ \mathrm{LIS}(B)=4 $ が成り立ちます．

### Sample Explanation 2

操作を $ 1 $ 度も行わないことにより，$ \mathrm{LIS}(A)\ +\ \mathrm{LIS}(B)\ =\ 10 $ を達成できます．

## 样例 #1

### 输入

```
5

5 2 1 4 3

3 1 2 5 4```

### 输出

```
8```

## 样例 #2

### 输入

```
5

1 2 3 4 5

1 2 3 4 5```

### 输出

```
10```

# AI分析结果

### 题目内容重写

【题目描述】

数列 $ P\ =\ (P_1,\ \ldots,\ P_N) $ 的最长递增子序列的长度记为 $ \mathrm{LIS}(P) $。

给定两个由 $ 1 $ 到 $ N $ 的整数组成的排列 $ A\ =\ (A_1,\ \ldots,\ A_N) $ 和 $ B\ =\ (B_1,\ \ldots,\ B_N) $。你可以对这两个数列进行任意次数的以下操作（包括不进行任何操作）：

- 选择一个整数 $ i $，满足 $ 1\leq\ i\leq\ N-1 $。交换 $ A_i $ 和 $ A_{i+1} $，同时交换 $ B_i $ 和 $ B_{i+1} $。

请计算操作后 $ \mathrm{LIS}(A)\ +\ \mathrm{LIS}(B) $ 的最大可能值。

【说明/提示】

- 最长递增子序列（LIS）是指数列中严格递增的子序列，且长度最大。
- 操作可以多次进行，且每次操作必须同时交换 $ A $ 和 $ B $ 中的对应元素。

【样例解释】

例如，通过以下操作可以使 $ \mathrm{LIS}(A)\ +\ \mathrm{LIS}(B)\ =\ 8 $：
- 选择 $ i\ =\ 2 $ 进行操作，$ A\ =\ (5,1,2,4,3) $, $ B\ =\ (3,2,1,5,4) $。
- 选择 $ i\ =\ 1 $ 进行操作，$ A\ =\ (1,5,2,4,3) $, $ B\ =\ (2,3,1,5,4) $。
- 选择 $ i\ =\ 4 $ 进行操作，$ A\ =\ (1,5,2,3,4) $, $ B\ =\ (2,3,1,4,5) $。

此时 $ A $ 的最长递增子序列为 $ (1,2,3,4) $，$ \mathrm{LIS}(A)=4 $；$ B $ 的最长递增子序列为 $ (2,3,4,5) $，$ \mathrm{LIS}(B)=4 $。

### 算法分类

**排序**、**动态规划**

### 题解分析与结论

本题的核心思路是通过排序和动态规划来最大化 $ \mathrm{LIS}(A) + \mathrm{LIS}(B) $。所有题解都提到了将 $ A $ 排序后，计算 $ B $ 的最长递增子序列（LIS），最终答案为 $ n + \mathrm{LIS}(B) $。这一思路的关键在于，当 $ A $ 有序时，任何交换操作都不会再增加 $ \mathrm{LIS}(A) $，而 $ \mathrm{LIS}(B) $ 的最大值可以通过排序后的 $ B $ 来计算。

### 评分较高的题解

1. **作者：_zzzzzzy_ (赞：4)**
   - **星级：4.5**
   - **关键亮点**：思路清晰，代码简洁，直接通过排序和二分查找计算 LIS，时间复杂度为 $ O(n \log n) $。
   - **核心代码**：
     ```cpp
     for (int i = 2; i <= n; i++) {
         if (b[i] > dp[len]) {
             dp[++len] = b[i];
         } else {
             dp[lower_bound(dp + 1, dp + len + 1, b[i]) - dp] = b[i];
         }
     }
     ```

2. **作者：mlvx (赞：4)**
   - **星级：4.0**
   - **关键亮点**：使用线段树维护 LIS，虽然复杂度相同，但代码稍复杂，适合对线段树熟悉的读者。
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         T.update(1, n, a[i].b, (a[i].b != 1 ? T.query(1, n, 1, a[i].b - 1, 1) : 0) + 1, 1);
     }
     ```

3. **作者：jzcrq (赞：2)**
   - **星级：4.0**
   - **关键亮点**：思路清晰，代码简洁，直接通过排序和二分查找计算 LIS，时间复杂度为 $ O(n \log n) $。
   - **核心代码**：
     ```cpp
     rep(i,1,n)
         if (A[i].second > f[top]) f[++top] = A[i].second;
         else *lower_bound(f+1,f+top+1,A[i].second) = A[i].second;
     ```

### 最优关键思路

1. **排序优化**：将 $ A $ 排序后，$ \mathrm{LIS}(A) $ 达到最大值 $ n $，此时只需计算 $ B $ 的 LIS。
2. **二分查找优化**：在计算 LIS 时，使用二分查找来维护当前的最长递增子序列，时间复杂度为 $ O(n \log n) $。

### 拓展思路

类似的问题可以通过排序和动态规划来解决，尤其是在需要最大化某些序列性质时。例如，最大化两个序列的某种组合性质，通常可以通过排序和动态规划来优化。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

---
处理用时：37.30秒
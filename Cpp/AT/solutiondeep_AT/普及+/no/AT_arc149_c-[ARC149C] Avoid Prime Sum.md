# 题目信息

# [ARC149C] Avoid Prime Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc149/tasks/arc149_c

正整数 $ N $ が与えられます．

$ N $ 行 $ N $ 列からなるマス目の各マスに $ N^2 $ 以下の正整数を $ 1 $ つずつ書き込んで，以下の条件がすべて成り立つようにしてください．

- 上下左右の $ 4 $ 方向いずれかに隣接する $ 2 $ マスに書き込まれた正整数の和は，どれも素数ではない．
- $ N^2 $ 以下の正整数はすべてどれかのマスに $ 1 $ 度ずつ書き込まれている．

なお本問題の制約のもと，このような書き込み方が必ず存在することが証明できます．

## 说明/提示

### 制約

- $ 3\leq\ N\leq\ 1000 $

### Sample Explanation 1

このマス目には $ 1 $ 以上 $ 16 $ 以下の正整数がすべて $ 1 $ 度ずつ書き込まれています．また隣接する $ 2 $ マスに書き込まれた正整数の和には $ 15+11=26 $, $ 11+16=27 $, $ 15+13=28 $ などがありますが，これらはすべて素数ではありません．

## 样例 #1

### 输入

```
4```

### 输出

```
15 11 16 12

13 3 6 9

14 7 8 1

4 2 10 5```

# AI分析结果

### 题目内容重写
#### 题目描述
给定一个正整数 \( N \)。

要求在一个 \( N \) 行 \( N \) 列的网格中，每个格子填入一个不超过 \( N^2 \) 的正整数，且满足以下条件：
1. 上下左右相邻的两个格子中的数之和都不是素数。
2. 所有不超过 \( N^2 \) 的正整数都必须被填入且每个数只能使用一次。

可以证明，在本题的约束下，这样的填法一定存在。

#### 说明/提示
- 约束条件：\( 3 \leq N \leq 1000 \)

#### 样例 #1
##### 输入
```
4
```
##### 输出
```
15 11 16 12
13 3 6 9
14 7 8 1
4 2 10 5
```

### 算法分类
构造

### 题解分析与结论
本题的核心在于构造一个满足条件的 \( N \times N \) 矩阵，使得相邻的两个数之和都不是素数。大多数题解都采用了将奇数和偶数分开填充的策略，以减少相邻数之和为素数的可能性。具体来说，奇数和奇数相加、偶数和偶数相加的结果都是偶数，而偶数中只有 2 是素数，因此只需确保相邻的奇数和偶数之和不为素数。

#### 关键思路与技巧
1. **奇偶分离**：将奇数和偶数分别填充到矩阵的上半部分和下半部分，减少奇数和偶数相邻的情况。
2. **边界处理**：对于奇数和偶数相邻的边界，确保它们的和为合数。常用的方法是让这些数都是 3 的倍数，这样它们的和也是 3 的倍数，从而保证是合数。
3. **特殊情况处理**：对于 \( N = 3 \) 等小规模情况，直接手动构造矩阵。

#### 推荐题解
1. **作者：APJifengc (赞：4)**  
   - **星级**：4.5  
   - **关键亮点**：通过随机化方法快速找到符合条件的奇偶配对，代码简洁且高效。对于 \( N = 3 \) 的情况直接手动构造，避免了随机化的失败。
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         int a = Rand() % (n * n) + 1, b = Rand() % (n * n) + 1;
         while (a % 2 == 0 || b % 2 == 1 || vis[a] || vis[b] || isprime[a + b]) {
             a = Rand() % (n * n) + 1, b = Rand() % (n * n) + 1;
         }
         vis[a] = vis[b] = 1;
         ans[n / 2][i] = a, ans[n / 2 + 1][i] = b;
     }
     ```

2. **作者：Jasonshan10 (赞：0)**  
   - **星级**：4  
   - **关键亮点**：通过构造 3 的倍数来确保边界上的奇数和偶数之和为合数，思路清晰且易于理解。
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= n; ++i) {
         a[n / 2][i] = now;
         s1.insert(now);
         now = now + 6;
     }
     ```

3. **作者：NobodyThere (赞：0)**  
   - **星级**：4  
   - **关键亮点**：通过构造数对使得它们的和为合数，适用于 \( N \) 为奇数和偶数的情况，思路新颖且实现简洁。
   - **核心代码**：
     ```cpp
     void oper(int x, int i, int j) {
         int y = s - x; vis[x] = vis[y] = 1;
         if(x & 1) a[i][j] = x, a[i + 1][j] = y;
         else a[i][j] = y, a[i + 1][j] = x;
     }
     ```

### 可拓展之处
本题的构造思路可以推广到其他需要满足特定条件的矩阵填充问题，例如要求相邻数的差为某个特定值，或者要求某些特定位置的数满足某种关系。类似的题目可以通过奇偶分离、边界处理等策略来解决。

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

---
处理用时：31.69秒
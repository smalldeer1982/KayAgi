# 题目信息

# [ARC150B] Make Divisible

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc150/tasks/arc150_b

正整数 $ A,\ B $ が与えられます。

非負整数 $ X,\ Y $ であって、 $ B+Y $ が $ A+X $ の倍数となるようなものに対する $ X+Y $ の最小値を求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 100 $
- $ 1\ \leq\ A,\ B\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

$ 1 $ 個目のテストケースについて、$ X=1,\ Y=1 $ とすると $ B+Y=24 $ は $ A+X=12 $ の倍数になります。このとき $ X+Y=2 $ であり、$ X+Y $ はこれより小さくすることはできないので答えは $ 2 $ です。 $ 2 $ 個目のテストケースについて、$ X=0,\ Y=0 $ とすると $ B+Y=16 $ は $ A+X=8 $ の倍数になります。

## 样例 #1

### 输入

```
5

11 23

8 16

4394 993298361

95392025 569922442

8399283 10293```

### 输出

```
2

0

65

2429708

8388990```

# AI分析结果

### 题目内容重写

#### [ARC150B] Make Divisible

##### 题目描述

给定两个正整数 $A$ 和 $B$。

找到非负整数 $X$ 和 $Y$，使得 $B+Y$ 是 $A+X$ 的倍数，并且 $X+Y$ 的值最小。

$T$ 个测试用例将被给出，每个测试用例需要输出对应的最小 $X+Y$ 值。

##### 说明/提示

###### 约束

- $1 \leq T \leq 100$
- $1 \leq A, B \leq 10^9$
- 输入的所有值均为整数

###### 样例解释

第一个测试用例中，$X=1$ 和 $Y=1$ 使得 $B+Y=24$ 是 $A+X=12$ 的倍数，此时 $X+Y=2$，且无法使 $X+Y$ 更小，因此答案为 $2$。

第二个测试用例中，$X=0$ 和 $Y=0$ 使得 $B+Y=16$ 是 $A+X=8$ 的倍数。

##### 样例输入

```
5

11 23

8 16

4394 993298361

95392025 569922442

8399283 10293
```

##### 样例输出

```
2

0

65

2429708

8388990
```

### 算法分类

数学

### 题解分析与结论

本题的核心在于找到满足条件的 $X$ 和 $Y$，使得 $B+Y$ 是 $A+X$ 的倍数，并且 $X+Y$ 最小。各题解主要采用了**根号分治**和**数论分块**的思路，通过枚举 $X$ 或 $A+X$ 的值来优化计算。

### 精选题解

#### 题解1：作者：NobodyThere (赞：7)

**星级：5星**

**关键亮点：**
- 使用了**根号分治**的思路，将问题分为 $a \leq \sqrt{b}$ 和 $a > \sqrt{b}$ 两种情况，分别进行处理。
- 通过枚举 $x$ 和 $d'$ 来优化计算，复杂度为 $\mathcal{O}(\sqrt{b})$。
- 代码清晰，逻辑严谨，处理了边界情况。

**核心代码：**
```cpp
int udiv(const int x, const int y) {return (x + y - 1) / y;}
int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d %d", &a, &b);
        if(a >= b) {
            printf("%d\n", a - b);
            continue;
        }
        s = sqrt(b); ans = std::min(b - a, ((a - b) % a + a) % a);
        if(a <= s) {
            for(int i = 1; i <= a; i++) {
                int x = a + i;
                ans = std::min(ans, i + ((x - b) % x + x) % x);
            }
        } else {
            for(int i = 2; i <= a; i++) {
                int x = udiv(b, i);
                if(x < a) break;
                ans = std::min(ans, x - a + ((x - b) % x + x) % x);
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

#### 题解2：作者：cmrhhh (赞：2)

**星级：4星**

**关键亮点：**
- 采用了**数论分块**的思路，通过枚举 $A+X$ 的值来优化计算。
- 通过感性理解和数学推导，得出了每个块的左端点为最优值的结论。
- 代码实现较为简洁，但部分细节处理不够完善。

**核心代码：**
```cpp
for(ll l=a;l<=b-1;l=r+1){
    r=min(b-1,(b-1)/((b-1)/l));
    ans=min(ans,(l-a)+(1+(b-1)/l)*l-b);
}r++;
ans=min(ans,(r-a)+(1+(b-1)/r)*r-b);
```

#### 题解3：作者：Miraik (赞：2)

**星级：4星**

**关键亮点：**
- 通过**整除分块**的思路，枚举 $a+i$ 的值来优化计算。
- 得出了每个块的左端点为最优值的结论，并通过数学证明进行了验证。
- 代码实现较为简洁，但部分细节处理不够完善。

**核心代码：**
```cpp
for(int i=(b+a-1)/a,l=a;i>1;l=(b+i-2)/(i-1),i=(b+l-1)/l) 
    if(b%l==0) ans=min(ans,l-a);
    else ans=min(ans,(l-a)+l-b%l);
```

### 最优关键思路与技巧

1. **根号分治**：将问题分为 $a \leq \sqrt{b}$ 和 $a > \sqrt{b}$ 两种情况，分别进行处理，可以有效降低复杂度。
2. **数论分块**：通过枚举 $A+X$ 的值，利用整除分块的性质，减少枚举次数，优化计算。
3. **左端点最优**：在数论分块中，每个块的左端点通常为最优值，可以通过数学推导进行验证。

### 可拓展之处

- 类似的问题可以通过**根号分治**或**数论分块**的思路进行优化，尤其是在涉及到整除和模运算的情况下。
- 可以进一步研究**向上取整整除分块**的应用场景，以及如何通过数学推导优化枚举过程。

### 推荐题目

1. [P2261 [CQOI2007]余数求和](https://www.luogu.com.cn/problem/P2261)
2. [P2260 [清华集训2012]模积和](https://www.luogu.com.cn/problem/P2260)
3. [P2262 [HNOI2007]最小公倍数计数](https://www.luogu.com.cn/problem/P2262)

---
处理用时：36.85秒
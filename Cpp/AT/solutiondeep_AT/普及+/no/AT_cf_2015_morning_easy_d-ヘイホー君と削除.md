# 题目信息

# ヘイホー君と削除

## 题目描述

一个字符串重复两次会得到一个平方字符串。例如，`abcabc`、`abababab`都是平方字符串；而`abc`和`ababab`都不是平方字符串；长度为0的字符串，也是平方字符串。



一天，ヘイホー君得到了一个只包含小写英文字母的字符串，他想让你删除任意P个字符后变成平方字符串。



求P（也就是删除次数）的最小值。

## 样例 #1

### 输入

```
8

abacbabc```

### 输出

```
2```

## 样例 #2

### 输入

```
8

abababab```

### 输出

```
0```

## 样例 #3

### 输入

```
5

abcde```

### 输出

```
5```

## 样例 #4

### 输入

```
26

codefestivaltwozeroonefive```

### 输出

```
14```

# AI分析结果

### 题目内容重写

# ヘイホー君与删除

## 题目描述

一个字符串重复两次会得到一个平方字符串。例如，`abcabc`、`abababab`都是平方字符串；而`abc`和`ababab`都不是平方字符串；长度为0的字符串，也是平方字符串。

一天，ヘイホー君得到了一个只包含小写英文字母的字符串，他想让你删除任意P个字符后变成平方字符串。

求P（也就是删除次数）的最小值。

## 样例 #1

### 输入

```
8

abacbabc```

### 输出

```
2```

## 样例 #2

### 输入

```
8

abababab```

### 输出

```
0```

## 样例 #3

### 输入

```
5

abcde```

### 输出

```
5```

## 样例 #4

### 输入

```
26

codefestivaltwozeroonefive```

### 输出

```
14```

### 算法分类
动态规划

### 题解分析与结论

由于题目要求通过删除字符使字符串变为平方字符串，并且需要最小化删除次数，这可以转化为寻找字符串中最长的子序列，使得该子序列可以分成两个相同的部分。这实际上是一个典型的动态规划问题，可以通过寻找字符串的最长公共子序列（LCS）来解决。

### 最优关键思路
1. **动态规划**：通过构建一个二维DP数组，记录字符串中不同位置的字符匹配情况，从而找到最长的子序列。
2. **分割字符串**：将字符串分割成两部分，分别作为平方字符串的两个部分，通过比较这两部分的字符来找到最长的匹配子序列。

### 推荐题目
1. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 核心代码实现
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int minDeletionsToSquare(string s) {
    int n = s.length();
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s[i - 1] == s[j - 1] && i != j) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return n - dp[n][n];
}

int main() {
    string s;
    cin >> s;
    cout << minDeletionsToSquare(s) << endl;
    return 0;
}
```

### 代码说明
- **动态规划数组**：`dp[i][j]`表示字符串`s`的前`i`个字符和前`j`个字符的最长公共子序列长度。
- **状态转移**：如果`s[i-1] == s[j-1]`且`i != j`，则`dp[i][j] = dp[i-1][j-1] + 1`；否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
- **结果计算**：最终结果为字符串长度减去`dp[n][n]`，即需要删除的字符数。

### 总结
通过动态规划的方法，可以有效地找到字符串中最长的子序列，使得该子序列可以分成两个相同的部分，从而计算出需要删除的最小字符数。这种方法的时间复杂度为O(n^2)，适用于中等长度的字符串。

---
处理用时：23.97秒
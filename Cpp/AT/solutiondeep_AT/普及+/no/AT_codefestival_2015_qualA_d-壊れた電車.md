# 题目信息

# 壊れた電車

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2015-quala/tasks/codefestival_2015_qualA_d

高橋鉄道では、$ N $ 両編成の電車の一部が壊れてしまったため、$ M $ 人の整備士が点検をすることになりました。

$ i $ 人目の整備士ははじめ、$ X_i $ 両目の車両にいます。それぞれの整備士は、今いる車両を点検することと、隣の車両に移動することができます。車両の点検には時間はかかりませんが、隣の車両に移動するには $ 1 $ 分かかります。

全ての車両を少なくとも $ 1 $ 人の整備士が点検した状態になると点検作業は終了となります。点検作業は最短何分で終了させることができるでしょうか。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ N\ ≦\ 100 $ を満たすデータセットに正解した場合は、$ 20 $ 点が与えられる。
- $ N\ ≦\ 500,000 $ を満たすデータセットに正解した場合は、上記とは別に $ 60 $ 点が与えられる。
- 追加の制約のないデータセットに正解した場合は、上記とは別に $ 20 $ 点が与えられる。

### Sample Explanation 1

下の図のように整備士が移動すれば $ 3 $ 分で点検作業を終了させることができます。 !\[figure1\](https://code-festival-2015-quala.contest.atcoder.jp/img/other/code\_festival\_2015\_quala/BrokenDensya.png)

## 样例 #1

### 输入

```
17 5

1

5

10

15

16```

### 输出

```
3```

## 样例 #2

### 输入

```
66 10

8

9

16

23

37

47

51

52

53

64```

### 输出

```
8```

# AI分析结果

### 题目内容重写

**题目描述**

高橋鉄道有一列由 $N$ 节车厢组成的电车，其中部分车厢损坏了。现在有 $M$ 名维修工需要进行检修。

第 $i$ 名维修工最初位于第 $X_i$ 节车厢。每名维修工可以检修当前所在的车厢，或者移动到相邻的车厢。检修车厢不需要时间，但移动到相邻车厢需要花费 $1$ 分钟。

当所有车厢都至少被一名维修工检修过时，检修工作结束。请问检修工作最短需要多少分钟才能完成？

**说明/提示**

### 部分点

- $N\ ≦\ 100$ 的数据集，正确解答可获得 $20$ 分。
- $N\ ≦\ 500,000$ 的数据集，正确解答可获得 $60$ 分。
- 无额外限制的数据集，正确解答可获得 $20$ 分。

**样例 #1**

输入：
```
17 5
1
5
10
15
16
```

输出：
```
3
```

**样例 #2**

输入：
```
66 10
8
9
16
23
37
47
51
52
53
64
```

输出：
```
8
```

### 算法分类
二分

### 题解分析与结论

该问题的核心在于通过二分查找确定最短时间，并通过贪心策略判断在给定时间内是否能够完成所有车厢的检修。难点在于如何高效地判断在给定时间内是否能够覆盖所有车厢。

### 所选题解

#### 题解1：nkrqzjc_zzz
**星级：4**
**关键亮点：**
- 使用二分查找确定最短时间。
- 通过贪心策略判断在给定时间内是否能够覆盖所有车厢。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
bool check(long long cet){
    long long dn=1;
    for(long long i=1;i<=m;i++){
        if(dn>n)return 1;
        if(a[i]-dn>cet)return 0;
        else if(a[i]-dn>0){
            dn=a[i]+std::max(cet-2*a[i]+2*dn,(cet-a[i]+dn)/2)+1;
        }
        else dn=a[i]+cet+1;
    }
    return dn>n;
}
```

#### 题解2：_Flame_
**星级：4**
**关键亮点：**
- 使用二分查找确定最短时间。
- 详细解释了贪心策略的实现细节。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
bool check(int mid){
    int cnt=1;
    for(int i=1;i<=m;i++){
        if(cnt>n)return 1;
        int l=a[i]-cnt;
        if(l>mid)return 0;
        else if(l>0){
            cnt=a[i]+max(mid-2*l,(mid-l)/2)+1;
        }
        else{
            cnt=a[i]+mid+1;
        }
    }
    return cnt>n;
}
```

#### 题解3：gdf_yhm
**星级：4**
**关键亮点：**
- 使用二分查找确定最短时间。
- 通过贪心策略判断在给定时间内是否能够覆盖所有车厢。
- 代码实现较为简洁，逻辑清晰。

**核心代码：**
```cpp
bool check(int x){
    int lst=1;
    for(int i=1;i<=m;i++){
        if(lst==a[i]){
            lst=a[i]+x+1;
            lst=min(lst,a[i+1]);
        }
        else{
            if(a[i]-lst>x)return false;
            lst=max(a[i]+(x-(a[i]-lst))/2+1,a[i]+x-(a[i]-lst)*2+1);
            lst=min(lst,a[i+1]);
        }
    }
    if(lst<=n)return false;
    return true;
}
```

### 最优关键思路与技巧
- **二分查找**：通过二分查找确定最短时间，时间复杂度为 $O(\log n)$。
- **贪心策略**：在给定时间内，每个维修工尽可能多地覆盖车厢，减少后续工作量。
- **边界处理**：注意处理维修工位置与车厢边界的关系，确保覆盖所有车厢。

### 可拓展之处
- 类似问题：可以通过二分查找和贪心策略解决其他覆盖问题，如区间覆盖、任务分配等。
- 优化思路：可以进一步优化贪心策略的实现，减少不必要的计算。

### 推荐题目
1. [P1083 借教室](https://www.luogu.com.cn/problem/P1083)
2. [P1316 丢瓶盖](https://www.luogu.com.cn/problem/P1316)
3. [P1843 奶牛晒衣服](https://www.luogu.com.cn/problem/P1843)

### 个人心得
- **调试经历**：注意输出格式，如换行符，避免因格式错误导致WA。
- **踩坑教训**：二分查找时，注意边界条件的处理，避免遗漏或重复计算。
- **顿悟感想**：通过二分查找和贪心策略的结合，可以有效解决复杂问题，提高代码效率。

---
处理用时：33.59秒
# 题目信息

# Exactly N points

## 题目描述

[problemUrl]: https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_b

ある年のCODE FESTIVALの決勝では $ N $ 問の問題が出題されました。

$ i\ (1≦i≦N) $ 番目の問題の配点は $ i $ 点です。

高橋くんは、このコンテストでちょうど $ N $ 点を取りたいと思い、そのために解く問題の集合をどうするかを考えています。

配点が高い問題は難しいので、解く問題の配点のうちの最大値が最小になるようにしようと考えました。

高橋くんが解くべき問題の集合を求めてください。

## 说明/提示

### 制約

- $ 1≦N≦10^7 $

### 部分点

- $ 1≦N≦1000 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。
- 追加制約のないデータセットに正解した場合は、上記とは別に $ 100 $ 点が与えられる。

### Sample Explanation 1

$ 4 $ 番目の問題のみを解いた場合もちょうど $ 4 $ 点が得られますが、$ 1,3 $ 番目の問題を解く方が配点の最大値が小さくなります。

### Sample Explanation 2

$ \{3,4\} $ という集合も考えられます。

## 样例 #1

### 输入

```
4```

### 输出

```
1

3```

## 样例 #2

### 输入

```
7```

### 输出

```
1

2

4```

## 样例 #3

### 输入

```
1```

### 输出

```
1```

# AI分析结果

【题目内容】
# Exactly N points

## 题目描述

某年的CODE FESTIVAL的决赛中出了 $ N $ 道题目。

第 $ i\ (1≦i≦N) $ 道题目的分值是 $ i $ 分。

高桥君希望在这场比赛中恰好得到 $ N $ 分，因此他正在考虑应该选择哪些题目来解答。

由于高分题目难度较大，他希望所选题目中分值最大的题目尽可能小。

请帮助高桥君找出他应该解答的题目集合。

## 说明/提示

### 制約

- $ 1≦N≦10^7 $

### 部分点

- $ 1≦N≦1000 $ 的数据集正确解答将获得 $ 200 $ 分。
- 无额外限制的数据集正确解答将获得 $ 100 $ 分。

### Sample Explanation 1

如果只解答第 $ 4 $ 道题目，可以得到恰好 $ 4 $ 分，但解答第 $ 1 $ 和第 $ 3 $ 道题目时，所选题目中分值最大的题目更小。

### Sample Explanation 2

也可以选择解答第 $ 3 $ 和第 $ 4 $ 道题目。

## 样例 #1

### 输入

```
4```

### 输出

```
1

3```

## 样例 #2

### 输入

```
7```

### 输出

```
1

2

4```

## 样例 #3

### 输入

```
1```

### 输出

```
1```

【算法分类】  
数学

【题解分析与结论】  
本题的核心是通过数学推导找到一组互不相同的正整数，使其和恰好为 $ N $，并且这组数中的最大值尽可能小。各题解主要通过等差数列求和公式和二分查找等数学方法来解决这一问题。以下是各题解的主要思路和对比：

1. **ZolaWatle**：通过等差数列求和公式找到最小的 $ k $ 使得 $ S = \frac{k(k+1)}{2} \geq N $，然后通过减去一个数来得到恰好 $ N $ 的和。代码实现清晰，时间复杂度为 $ O(\sqrt{N}) $。
2. **喵仔牛奶**：使用二分查找来确定最大的 $ x $，使得 $ \frac{x(x+1)}{2} \geq N $，然后通过递归输出结果。代码简洁，时间复杂度为 $ O(\log N) $。
3. **Cuiyi_SAI**：通过数学公式直接计算最大数 $ x $，然后递归求解剩余部分。代码实现较为复杂，但时间复杂度为 $ O(\sqrt{N}) $。

【评分较高的题解】  
1. **喵仔牛奶**（5星）
   - 关键亮点：使用二分查找优化了时间复杂度，代码简洁明了。
   - 核心代码：
     ```cpp
     void print(ll i) {
         if (i >= n) cout << n << '\n';
         else n -= i, print(i - 1), cout << i << '\n';
     }
     int main() {
         cin >> n, l = 1, r = n;
         while (l <= r) {
             ll mid = (l + r) / 2;
             if (mid * (mid + 1) / 2 < n) l = mid + 1;
             else ans = mid, r = mid - 1;
         }
         print(ans);
         return 0;
     }
     ```

2. **ZolaWatle**（4星）
   - 关键亮点：通过等差数列求和公式找到解，思路清晰，代码实现较为直接。
   - 核心代码：
     ```cpp
     while(k*(k+1)/2<=n) {
         k++;
         if(k*(k+1)/2==n) {
             for(re i=1;i<=k;i++) std::cout<<i<<endl;
             return 0;
         }
     }
     s=k*(k+1)/2;
     for(re i=1;i<=k;i++)
         if(s-i==n) {
             for(re j=1;j<=k;j++)
                 if(j!=i) std::cout<<j<<endl;
             return 0;
         }
     ```

【最优关键思路】  
通过等差数列求和公式 $ S = \frac{k(k+1)}{2} $ 找到最小的 $ k $ 使得 $ S \geq N $，然后通过减去一个数来得到恰好 $ N $ 的和。使用二分查找可以进一步优化时间复杂度。

【拓展思路】  
类似的问题可以通过数学公式和二分查找来解决，例如在组合数学中寻找满足特定条件的数列。

【推荐题目】  
1. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

---
处理用时：35.37秒
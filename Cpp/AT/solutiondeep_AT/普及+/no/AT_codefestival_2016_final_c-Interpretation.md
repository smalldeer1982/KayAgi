# 题目信息

# Interpretation

## 题目描述

用 $1$ 到 $m$ 这 $m$ 个正整数为 $m$ 种语言编号。现在有 $n$ 个人，他们的编号依次为 $1,2,...,n$。第 $i$ 个人会说这 $m$ 种语言中的 $k_i$ 种，它们的编号分别为 $l_{i,1},l_{i,2},...,l_{i,k_i}$。

现在，如果说编号 $a$ 和编号 $b$ 的两个人是“可以交流的”，当且仅当两人存在以下两种模式中的至少一种：

- 当 $a$ 和 $b$ 可以直接交流时，满足：存在至少一种语言，$a$ 和 $b$ 都会。
- 当 $a$ 和 $b$ 可以间接交流时，满足：存在一个人 $x$，他（她）可以分别与 $a$ 和 $b$ 直接交流。

请问：每个人是否都能和其他人中的任意一个直接或间接地交流？

## 说明/提示

#### 输入输出样例 #1 说明

（为了简便，每个人直接用其编号代替，样例 $ \#2 $ 解释同）

任意两个人都可以交流，如下：

- $1$ 和 $2$ 都会说语言 $2$；
- $2$ 和 $3$ 都会说语言 $4$；
- $1$ 和 $3$ 可以通过 $2$ 间接交流；
- $3$ 和 $4$ 都会说语言 $6$；
- $2$ 和 $4$ 可以通过 $3$ 间接交流；
- $1$ 和 $4$ 可以通过 $2$ 间接交流。（这里请注意，$1$ 和 $4$ 是通过 $1-2-3-4$ 的链条来间接交流的）

#### 输入输出样例 #2 说明

例如，$1$ 和 $3$ 不能交流。

#### 数据规模与约定

所有输入数据保证：

- $2 \le n \le 10^5$，$1 \le m \le 10^5$，$1 \le k_i \le m$，且所有 $k_i$ 之和 $\le 10^5$；
- $1 \le l_{i,j} \le m$，且对于同一个 $i$ 来说，$l_{i,j}$ 互不相同。

## 样例 #1

### 输入

```
4 6

3 1 2 3

2 4 2

2 4 6

1 6```

### 输出

```
YES```

## 样例 #2

### 输入

```
4 4

2 1 2

2 1 2

1 3

2 4 3```

### 输出

```
NO```

# AI分析结果

### 题目内容重写

用 $1$ 到 $m$ 这 $m$ 个正整数为 $m$ 种语言编号。现在有 $n$ 个人，他们的编号依次为 $1,2,...,n$。第 $i$ 个人会说这 $m$ 种语言中的 $k_i$ 种，它们的编号分别为 $l_{i,1},l_{i,2},...,l_{i,k_i}$。

现在，如果说编号 $a$ 和编号 $b$ 的两个人是“可以交流的”，当且仅当两人存在以下两种模式中的至少一种：

- 当 $a$ 和 $b$ 可以直接交流时，满足：存在至少一种语言，$a$ 和 $b$ 都会。
- 当 $a$ 和 $b$ 可以间接交流时，满足：存在一个人 $x$，他（她）可以分别与 $a$ 和 $b$ 直接交流。

请问：每个人是否都能和其他人中的任意一个直接或间接地交流？

### 算法分类
并查集

### 题解分析与结论

#### 题解1：Leaper_lyc
- **星级**：4
- **关键亮点**：使用并查集将每个人和其所会的语言合并到同一个集合中，最后检查所有人是否在同一个集合中。思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      scanf("%d", &k);
      for (int j = 1; j <= k; j++) {
          scanf("%d", &l);
          fa[find(i)] = find(l + n);
      }
  }
  for (int i = 1; i <= n; i++)
      if (find(i) != find(1)) return puts("NO"), 0;
  puts("YES");
  ```

#### 题解2：Kvaratskhelia
- **星级**：4
- **关键亮点**：同样使用并查集，详细解释了并查集的基本操作，代码结构清晰，适合初学者理解。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      scanf("%d", &k);
      for (int j = 1; j <= k; j++) {
          scanf("%d", &l);
          f[find(i)] = find(l + n);
      }
  }
  for (int i = 1; i <= n; i++)
      if (find(1) != find(i)) {cout<<"NO"<<endl;return 0;}
  cout<<"YES"<<endl;
  ```

### 最优关键思路或技巧
- **并查集的应用**：通过将每个人和其所会的语言合并到同一个集合中，利用并查集的高效查找和合并操作，快速判断所有人是否在同一个集合中。
- **集合合并策略**：将每个人与其所会的语言合并，确保直接或间接交流的人都在同一个集合中。

### 可拓展之处
- **同类型题**：可以扩展到其他需要判断连通性的问题，如社交网络中的朋友关系、图中的连通分量等。
- **类似算法套路**：并查集在解决连通性问题时非常高效，可以应用于各种需要快速合并和查找集合的场景。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1892 [BOI2003]团伙](https://www.luogu.com.cn/problem/P1892)

---
处理用时：23.30秒
# 题目信息

# Gr-idian MST

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2016-qualb/tasks/codefestival_2016_qualB_c

$ xy $平面上の$ 0\ ≦\ x\ ≦\ W,\ 0\ ≦\ y\ ≦\ H $をみたす領域にある$ x,y $ともに整数である点すべてに、ひとつずつ家があります。

$ x $座標が等しく$ y $座標の差が$ 1 $であるか、$ y $座標が等しく$ x $座標の差が$ 1 $であるような$ 2 $点の組のうち、両方の点に家が存在するような全てのものに対し、その$ 2 $点の間には舗装されていない道路があります。

座標$ (i,j) $と$ (i+1,j) $にある家の間の道路を舗装するのには$ j $の値にかかわらずコストが$ p_i $、 座標$ (i,j) $と$ (i,j+1) $にある家の間の道路を舗装するのには$ i $の値にかかわらずコストが$ q_j $かかります。

高橋君は、このうちいくつかの道路を舗装し、舗装された道路のみを通って任意の$ 2 $つの家の間を行き来できるようにしたいです。 かかるコストの総和の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ W,H\ ≦\ 10^5 $
- $ 1\ ≦\ p_i\ ≦\ 10^8(0\ ≦\ i\ ≦\ W-1) $
- $ 1\ ≦\ q_j\ ≦\ 10^8(0\ ≦\ j\ ≦\ H-1) $
- $ p_i(0\ ≦\ i\ ≦\ W-1) $は整数である
- $ q_j(0\ ≦\ j\ ≦\ H-1) $は整数である

### Sample Explanation 1

次の$ 8 $本の道路を舗装すればよいです。 - $ (0,0) $と$ (0,1) $にある家を結ぶ道路 - $ (0,1) $と$ (1,1) $にある家を結ぶ道路 - $ (0,2) $と$ (1,2) $にある家を結ぶ道路 - $ (1,0) $と$ (1,1) $にある家を結ぶ道路 - $ (1,0) $と$ (2,0) $にある家を結ぶ道路 - $ (1,1) $と$ (1,2) $にある家を結ぶ道路 - $ (1,2) $と$ (2,2) $にある家を結ぶ道路 - $ (2,0) $と$ (2,1) $にある家を結ぶ道路

## 样例 #1

### 输入

```
2 2

3

5

2

7```

### 输出

```
29```

## 样例 #2

### 输入

```
4 3

2

4

8

1

2

9

3```

### 输出

```
60```

# AI分析结果

### 题目内容重写（中文）

在 $xy$ 平面上，满足 $0 \leq x \leq W$，$0 \leq y \leq H$ 的区域内，所有 $x$ 和 $y$ 都为整数的点上都有一个家。

对于 $x$ 坐标相同且 $y$ 坐标差为 $1$，或者 $y$ 坐标相同且 $x$ 坐标差为 $1$ 的两点组，如果这两点上都有家，则它们之间有一条未铺装的道路。

连接 $(i,j)$ 和 $(i+1,j)$ 的道路的铺装成本为 $p_i$，连接 $(i,j)$ 和 $(i,j+1)$ 的道路的铺装成本为 $q_j$。

高桥君希望铺装一些道路，使得任意两个家之间都可以通过铺装的道路互相到达。求最小的总铺装成本。

### 算法分类
贪心

### 题解分析与结论

本题的核心是通过贪心策略选择最小成本的边来构建最小生成树。由于直接使用 Kruskal 或 Prim 算法会因边数过多而超时，因此需要利用网格图的特殊性质进行优化。

各题解的思路大致相同，都是通过排序后选择最小成本的边，并根据已选的行列数动态调整每次选择的边数。以下是评分较高的题解：

#### 题解1：作者：Rigel (赞：9)
- **星级**：5
- **关键亮点**：思路清晰，代码简洁，通过双指针实现贪心选择，时间复杂度为 $O(H \log H)$。
- **核心实现思想**：对 $p$ 和 $q$ 排序后，使用双指针选择最小成本的边，并根据已选的行列数动态调整每次选择的边数。
- **代码片段**：
  ```cpp
  int i=1,j=1;
  while(i<=H&&j<=W){
      if(p[i]<=q[j])ans+=p[i++]*(W-j+2);
      else ans+=q[j++]*(H-i+2);
  }
  while(i<=H)ans+=p[i++]*(W-j+2);
  while(j<=W)ans+=q[j++]*(H-i+2);
  ```

#### 题解2：作者：清烛 (赞：1)
- **星级**：4
- **关键亮点**：通过维护未合并的行列数，利用排序不等式选择最小成本的边，思路清晰。
- **核心实现思想**：对 $p$ 和 $q$ 排序后，每次选择最小成本的边，并根据未合并的行列数动态调整每次选择的边数。
- **代码片段**：
  ```cpp
  int a = h + 1, b = w + 1;
  for (auto now : p) {
      if (now.second == 1) {
          if (a) --a, ans += now.first * b;
      } else {
          if (b) --b, ans += now.first * a;
      }
  }
  ```

#### 题解3：作者：_299817_ (赞：0)
- **星级**：4
- **关键亮点**：通过二分查找和前缀和优化计算，思路清晰，代码可读性高。
- **核心实现思想**：对 $p$ 和 $q$ 排序后，使用二分查找确定每列或每行选择的边数，并通过前缀和快速计算总成本。
- **代码片段**：
  ```cpp
  for(int i = 1; i <= n; i++){
      int now = lower_bound(b + 1, b + 1 + m, a[i]) - b - 1;
      ans += sum[now];
      ans += (m - now) * a[i];
  }
  ```

### 最优关键思路与技巧
1. **排序与贪心**：对 $p$ 和 $q$ 进行排序，每次选择最小成本的边。
2. **动态调整边数**：根据已选的行列数动态调整每次选择的边数，避免形成环。
3. **双指针与二分查找**：使用双指针或二分查找优化选择过程，减少时间复杂度。

### 可拓展之处
类似的问题可以推广到更高维度的网格图，或者边权不完全相同的情况。贪心策略在这些问题中依然适用，但需要根据具体情况进行调整。

### 推荐题目
1. [P5687 [CSP-S2019 江西] 网格图](https://www.luogu.com.cn/problem/P5687)
2. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
3. [P1195 【模板】最小生成树](https://www.luogu.com.cn/problem/P1195)

---
处理用时：27.32秒
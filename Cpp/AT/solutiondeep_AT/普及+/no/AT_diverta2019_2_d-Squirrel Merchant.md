# 题目信息

# Squirrel Merchant

## 题目描述

松鼠直大君有 $N$ 个橡子。一天，为了获得更多的橡子，他决定去几家贵金属交易所做几笔交易。

他计划这么做：

1. 拿着 $N$ 个橡子离开巢穴；
2. 到交易所 $A$ 做几笔交易；
3. 到交易所 $B$ 做几笔交易；
4. 再到交易所 $A$ 做几笔交易；
5. 回巢穴。

在交易所 $X$ $(X\ =\ A,\ B)$，他可以以任意顺序完成任意整数笔（可能为零）如下的交易：

- 花费 $g_{X}$ 个橡子买来 $1$ 克金；
- 花费 $1$ 克金买来 $g_{X}$ 个橡子；
- 花费 $s_{X}$ 个橡子买来 $1$ 克银；
- 花费 $1$ 克银买来 $s_{X}$ 个橡子；
- 花费 $b_{X}$ 个橡子买来 $1$ 克铜；
- 花费 $1$ 克铜买来 $b_{X}$ 个橡子。

当然，他不能在橡子不够时购买金、银或铜；也不能在金、银或铜不够时购买橡子。

请求出他最多能带多少橡子回巢穴。注意，金、银或铜即使被带回巢穴也是无意义的，因为他只是一只松鼠。

## 说明/提示

- $1\ \leq\ N\ \leq\ 5000$
- $1\ \leq\ g_{X}\ \leq\ 5000$
- $1\ \leq\ s_{X}\ \leq\ 5000$
- $1\ \leq\ b_{X}\ \leq\ 5000$
- 所有输入的值都是整数。

### 样例 #1 解释

他可以拿 $46$ 个橡子回巢穴：

- 在交易所 $A$，用 $23$ 个橡子买 $23$ 克金。{ 橡子，金，银，铜 }={ $0,23,0,0$ }
- 在交易所 $B$，用 $23$ 克金买 $46$ 个橡子。{ 橡子，金，银，铜 }={ $46,0,0,0$ }
- 在交易所 $A$，不做任何交易。{ 橡子，金，银，铜 }={ $46,0,0,0$ }

他不能得到 $47$ 个或更多橡子，因此答案是 $46$。

## 样例 #1

### 输入

```
23

1 1 1

2 1 1```

### 输出

```
46```

# AI分析结果

### 题目内容重写

松鼠直大君有 $N$ 个橡子。一天，为了获得更多的橡子，他决定去几家贵金属交易所做几笔交易。

他计划这么做：

1. 拿着 $N$ 个橡子离开巢穴；
2. 到交易所 $A$ 做几笔交易；
3. 到交易所 $B$ 做几笔交易；
4. 再到交易所 $A$ 做几笔交易；
5. 回巢穴。

在交易所 $X$ $(X\ =\ A,\ B)$，他可以以任意顺序完成任意整数笔（可能为零）如下的交易：

- 花费 $g_{X}$ 个橡子买来 $1$ 克金；
- 花费 $1$ 克金买来 $g_{X}$ 个橡子；
- 花费 $s_{X}$ 个橡子买来 $1$ 克银；
- 花费 $1$ 克银买来 $s_{X}$ 个橡子；
- 花费 $b_{X}$ 个橡子买来 $1$ 克铜；
- 花费 $1$ 克铜买来 $b_{X}$ 个橡子。

当然，他不能在橡子不够时购买金、银或铜；也不能在金、银或铜不够时购买橡子。

请求出他最多能带多少橡子回巢穴。注意，金、银或铜即使被带回巢穴也是无意义的，因为他只是一只松鼠。

### 算法分类
动态规划

### 题解分析与结论

#### 题解1：Lvlinxi2010
- **星级**：4
- **关键亮点**：使用动态规划，分两次处理交易所A和B的交易，分别计算最大橡子数。代码清晰，思路明确。
- **核心代码**：
  ```cpp
  FL(i,0,n){
      f[i]=i;
      FL(j,1,3) if(i>=a[j].l) f[i]=max(f[i],f[i-a[j].l]+a[j].r);
  }
  n=f[n];
  FL(i,0,n){
      dp[i]=i;
      FL(j,1,3) if(i>=a[j].r) dp[i]=max(dp[i],dp[i-a[j].r]+a[j].l);
  }
  printf("%lld\n",dp[n]);
  ```
- **总结**：通过两次动态规划，分别处理交易所A和B的交易，最终得到最大橡子数。代码简洁，逻辑清晰。

#### 题解2：cosf
- **星级**：4
- **关键亮点**：通过枚举每种可能的交易组合，计算最大橡子数。虽然复杂度较高，但在给定范围内可行。
- **核心代码**：
  ```cpp
  if (up == 1) {
      int bs = n / c[1];
      n -= c[1] * bs;
      n += d[1] * bs;
  }
  else if (up == 2) {
      int rn = 0;
      for (int i = 0; i * c[1] <= n; i++) {
          int cn = n - c[1] * i;
          int bs = cn / c[2];
          rn = max(rn, cn - c[2] * bs + d[2] * bs + i * d[1]);
      }
      n = rn;
  }
  else if (up == 3) {
      int rn = 0;
      for (int i = 0; i * c[1] <= n; i++) {
          int cn = n - c[1] * i;
          for (int j = 0; j * c[2] <= cn; j++) {
              int dn = cn - c[2] * j;
              int bs = dn / c[3];
              rn = max(rn, dn - c[3] * bs + i * d[1] + j * d[2] + bs * d[3]);
          }
      }
      n = rn;
  }
  ```
- **总结**：通过枚举每种可能的交易组合，计算最大橡子数。虽然复杂度较高，但在给定范围内可行。

#### 题解3：Acheron_RBM
- **星级**：4
- **关键亮点**：使用动态规划，分两次处理交易所A和B的交易，分别计算最大橡子数。代码简洁，逻辑清晰。
- **核心代码**：
  ```cpp
  for(int i=0;i<=n;i++) {
      dp[i]=i;
      for (int j=0;j<3;j++) {
          if(i>=a[0][j]) {
              dp[i]=max(dp[i],dp[i-a[0][j]]+a[1][j]);
          }
      }
  }
  n=dp[n];
  dp.assign(n+1,0);
  for(int i=0;i<=n;i++) {
      dp[i]=i;
      for(int j=0;j<3;j++) {
          if(i>=a[1][j]) {
              dp[i]=max(dp[i],dp[i-a[1][j]]+a[0][j]);
          }
      }
  }
  cout<<dp[n];
  ```
- **总结**：通过两次动态规划，分别处理交易所A和B的交易，最终得到最大橡子数。代码简洁，逻辑清晰。

### 最优关键思路或技巧
- **动态规划**：通过两次动态规划，分别处理交易所A和B的交易，计算最大橡子数。
- **枚举**：通过枚举每种可能的交易组合，计算最大橡子数。

### 可拓展之处
- **类似问题**：可以扩展到更多的交易所或更多的交易类型，增加问题的复杂性。
- **算法优化**：可以尝试使用更高效的算法或数据结构来优化计算过程。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：40.04秒
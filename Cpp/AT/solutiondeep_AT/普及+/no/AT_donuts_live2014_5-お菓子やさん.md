# 题目信息

# お菓子やさん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/donuts-live2014/tasks/donuts_live2014_5

幼少のパンチくんは、全部で $ N $ 店あるお菓子やさんを巡ろうとしています。

このうちのいくつかの店では、スタンプをカードに押してもらえます。その店のスタンプがあると、さらに別のいくつかの店で、ボーナスのお菓子がもらえるというシステムです。

ただし、パンチくんは一度行った店には $ 2 $ 回行きたくありません。そのため、例えば

- 店 $ A $ のスタンプがあると、店 $ B $ でお菓子が $ 3 $ 個もらえる
- 店 $ B $ のスタンプがあると、店 $ A $ でお菓子が $ 2 $ 個もらえる

という $ 2 $ つの条件が重なっている場合 、どちらかのお菓子を諦めなければいけません。この場合、後者を諦めて、前者の $ 3 $ 個のお菓子をもらうのが得です。

パンチくんがもらえるお菓子の最大値はいくらでしょうか。

## 说明/提示

### 部分点

$ 1\ ≦\ N\ ≦\ 8 $ を満たすテストケースに正解した場合、部分点として $ 130 $ 点が与えられる。

### Sample Explanation 1

問題文に記載されている例です。

### Sample Explanation 2

全てのお菓子をもらうことが出来ます。

### Sample Explanation 3

$ 10 $ 個のお菓子を諦めることで、最大値を得ます。

### Sample Explanation 4

同じ店に $ 2 $ 回行くことはできないので、お菓子はもらえません。また、このスタンプサービスと関係ない店がいくつかあることもあります。

## 样例 #1

### 输入

```
2 2

1 2 3

2 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3

1 2 10

1 3 20

1 4 30```

### 输出

```
60```

## 样例 #3

### 输入

```
3 3

1 2 20

2 3 30

3 1 10```

### 输出

```
50```

## 样例 #4

### 输入

```
16 1

4 4 1000```

### 输出

```
0```

## 样例 #5

### 输入

```
4 6

4 1 3

1 3 3

4 2 3

3 4 2

2 3 3

2 2 10```

### 输出

```
12```

# AI分析结果

### 题目内容重写

#### 题目描述

幼小的帕奇君想要拜访全部 $N$ 家糖果店。其中一些店提供在卡片上盖章的服务，拥有这些店的印章后，可以在其他一些店获得额外的糖果奖励。然而，帕奇君不想重复拜访同一家店。例如：

- 如果拥有店 $A$ 的印章，可以在店 $B$ 获得 $3$ 个糖果。
- 如果拥有店 $B$ 的印章，可以在店 $A$ 获得 $2$ 个糖果。

在这种情况下，帕奇君必须放弃其中一个奖励。显然，放弃后者而选择前者可以获得更多的糖果。请问帕奇君最多能获得多少糖果？

#### 说明/提示

##### 部分点

对于满足 $1 \leq N \leq 8$ 的测试用例，如果答案正确，将获得 $130$ 分的部分分。

##### 样例解释

1. 样例1对应题目描述中的例子。
2. 样例2中，帕奇君可以获得所有糖果。
3. 样例3中，放弃 $10$ 个糖果可以获得最大收益。
4. 样例4中，由于不能重复拜访同一家店，无法获得任何糖果。此外，有些店可能不参与此奖励系统。

#### 样例

##### 样例1

输入：
```
2 2
1 2 3
2 1 2
```
输出：
```
3
```

##### 样例2

输入：
```
4 3
1 2 10
1 3 20
1 4 30
```
输出：
```
60
```

##### 样例3

输入：
```
3 3
1 2 20
2 3 30
3 1 10
```
输出：
```
50
```

##### 样例4

输入：
```
16 1
4 4 1000
```
输出：
```
0
```

##### 样例5

输入：
```
4 6
4 1 3
1 3 3
4 2 3
3 4 2
2 3 3
2 2 10
```
输出：
```
12
```

### 算法分类

动态规划、位运算

### 题解分析与结论

该题的核心在于如何通过动态规划和位运算来高效地计算帕奇君能够获得的最大糖果数。题解中使用了状态压缩的技巧，将每个商店的访问状态表示为一个二进制数，并通过动态规划来逐步计算每个状态下的最大糖果数。

### 题解评分与亮点

#### 题解：Elairin176

**星级：4星**

**关键亮点：**
1. 使用了状态压缩的动态规划方法，将每个商店的访问状态表示为一个二进制数，极大地减少了状态空间。
2. 通过反向建图的方式，方便地计算每个商店的额外糖果贡献。
3. 详细解释了状态转移的过程，并处理了自环（即奖励制度指向自己的情况）。

**核心代码实现思想：**
```cpp
int dp[1 << 16];
vector<int> bonus[16];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        bonus[b - 1].push_back({a - 1, c});
    }
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                int prev_mask = mask ^ (1 << i);
                int sum = dp[prev_mask];
                for (auto &p : bonus[i]) {
                    if (prev_mask & (1 << p.first)) {
                        sum += p.second;
                    }
                }
                dp[mask] = max(dp[mask], sum);
            }
        }
    }
    cout << dp[(1 << n) - 1] << endl;
    return 0;
}
```
**核心代码解释：**
1. `dp[mask]` 表示当前状态为 `mask` 时的最大糖果数。
2. `bonus[i]` 存储了所有指向商店 `i` 的奖励制度。
3. 对于每个状态 `mask`，遍历所有可能的商店 `i`，如果 `i` 被访问过，则计算从 `prev_mask`（即去掉 `i` 的状态）转移到 `mask` 时的糖果数，并更新 `dp[mask]`。

### 最优关键思路或技巧

1. **状态压缩**：将每个商店的访问状态压缩为一个二进制数，极大地减少了状态空间，使得动态规划变得可行。
2. **反向建图**：通过反向建图，方便地计算每个商店的额外糖果贡献，避免了正向建图时的复杂计算。
3. **动态规划转移**：通过遍历所有可能的状态转移，逐步计算每个状态下的最大糖果数，确保最终结果的正确性。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要状态压缩和动态规划的问题，如旅行商问题（TSP）、子集和问题等。
2. **优化技巧**：可以进一步优化状态转移的过程，例如使用位运算加速状态转移，或者使用记忆化搜索减少重复计算。

### 推荐题目

1. [P1171 旅行商问题](https://www.luogu.com.cn/problem/P1171)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

---
处理用时：36.67秒
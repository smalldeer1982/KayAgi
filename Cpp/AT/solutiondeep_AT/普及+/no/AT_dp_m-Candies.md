# 题目信息

# Candies

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_m

$ N $ 人の子供たちがいます。 子供たちには $ 1,\ 2,\ \ldots,\ N $ と番号が振られています。

子供たちは $ K $ 個の飴を分け合うことにしました。 このとき、各 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について、子供 $ i $ が受け取る飴の個数は $ 0 $ 以上 $ a_i $ 以下でなければなりません。 また、飴が余ってはいけません。

子供たちが飴を分け合う方法は何通りでしょうか？ $ 10^9\ +\ 7 $ で割った余りを求めてください。 ただし、$ 2 $ 通りの方法が異なるとは、ある子供が存在し、その子供が受け取る飴の個数が異なることを言います。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 100 $
- $ 0\ \leq\ K\ \leq\ 10^5 $
- $ 0\ \leq\ a_i\ \leq\ K $

### Sample Explanation 1

子供たちが飴を分け合う方法は、次の $ 5 $ 通りです。 各数列において、$ i $ 番目の要素は子供 $ i $ が受け取る飴の個数を表します。 - $ (0,\ 1,\ 3) $ - $ (0,\ 2,\ 2) $ - $ (1,\ 0,\ 3) $ - $ (1,\ 1,\ 2) $ - $ (1,\ 2,\ 1) $

### Sample Explanation 2

子供たちが飴を分け合う方法が存在しない場合もあります。

### Sample Explanation 3

子供たちが飴を分け合う方法は、次の $ 1 $ 通りです。 - $ (0,\ 0) $

### Sample Explanation 4

答えを $ 10^9\ +\ 7 $ で割った余りを出力することを忘れずに。

## 样例 #1

### 输入

```
3 4

1 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
1 10

9```

### 输出

```
0```

## 样例 #3

### 输入

```
2 0

0 0```

### 输出

```
1```

## 样例 #4

### 输入

```
4 100000

100000 100000 100000 100000```

### 输出

```
665683269```

# AI分析结果

### 题目内容重写
**题目描述**

有 $N$ 个孩子，编号为 $1, 2, \ldots, N$。他们需要分配 $K$ 个糖果。每个孩子 $i$ 可以得到的糖果数量必须在 $0$ 到 $a_i$ 之间，并且所有糖果必须被分配完。求分配方案的总数，结果对 $10^9 + 7$ 取模。

**说明/提示**

- 输入均为整数。
- $1 \leq N \leq 100$
- $0 \leq K \leq 10^5$
- $0 \leq a_i \leq K$

**样例解释**

- 样例1：输入 `3 4` 和 `1 2 3`，输出 `5`，表示有5种分配方案。
- 样例2：输入 `1 10` 和 `9`，输出 `0`，表示没有可行的分配方案。
- 样例3：输入 `2 0` 和 `0 0`，输出 `1`，表示只有一种分配方案。
- 样例4：输入 `4 100000` 和 `100000 100000 100000 100000`，输出 `665683269`，结果对 $10^9 + 7$ 取模。

### 算法分类
动态规划、前缀和

### 题解分析与结论
题目要求计算在给定约束下分配糖果的方案数，属于典型的动态规划问题。各题解均采用了动态规划的思路，并通过前缀和优化来降低时间复杂度。

### 所选高星题解
1. **作者：FelFa_1414666 (5星)**
   - **关键亮点**：详细解释了动态规划的状态转移方程，并通过前缀和优化将时间复杂度从 $O(nk^2)$ 降低到 $O(nk)$。代码清晰，注释详细。
   - **代码核心思想**：使用前缀和数组 `sum` 来快速计算区间和，优化动态规划的转移过程。
   ```cpp
   ll getsum(int l,int r) {
       return (l==0?sum[r]:(sum[r]+MOD-sum[l-1])%MOD);
   }
   for(int i=1;i<=n;i++) {
       sum[0]=dp[i-1][0];
       for(int k=1;k<=m;k++) sum[k]=(sum[k-1]+dp[i-1][k])%MOD;
       for(int j=0;j<=m;j++) dp[i][j]=getsum(max(0,j-a[i-1]),j);
   }
   ```

2. **作者：云浅知处 (4星)**
   - **关键亮点**：同样使用前缀和优化动态规划，代码简洁，逻辑清晰。特别强调了边界条件的处理。
   - **代码核心思想**：通过前缀和数组 `sum` 来优化状态转移，确保每次转移的时间复杂度为 $O(1)$。
   ```cpp
   for(int i=2;i<=n;i++) {
       dp[i][0]=sum[i][0]=1;
       for(int j=1;j<=K;j++) {
           if(j<=a[i]) dp[i][j]=sum[i-1][j]%mod;
           else dp[i][j]=(sum[i-1][j]-sum[i-1][j-a[i]-1]+mod)%mod;
           sum[i][j]=(sum[i][j-1]+dp[i][j])%mod;
       }
   }
   ```

3. **作者：chlchl (4星)**
   - **关键亮点**：通过前缀和优化动态规划，代码简洁，逻辑清晰。特别强调了边界条件的处理。
   - **代码核心思想**：使用前缀和数组 `sum` 来优化状态转移，确保每次转移的时间复杂度为 $O(1)$。
   ```cpp
   for(int i=1;i<=n;i++) {
       sum[0] = f[0];
       for(int j=1;j<=k;j++) sum[j] = (sum[j - 1] + f[j]) % MOD;
       for(int j=0;j<=k;j++) f[j] = ((sum[j] - (j <= a[i] ? 0 : sum[j - a[i] - 1])) % MOD + MOD) % MOD;
   }
   ```

### 最优关键思路或技巧
- **动态规划**：定义状态 $dp(i,j)$ 表示前 $i$ 个孩子分配 $j$ 个糖果的方案数。
- **前缀和优化**：通过预处理前缀和数组，将每次转移的时间复杂度从 $O(k)$ 降低到 $O(1)$，从而将总时间复杂度从 $O(nk^2)$ 降低到 $O(nk)$。

### 可拓展之处
- 类似的问题可以出现在资源分配、背包问题等场景中，前缀和优化是一种常见的降低时间复杂度的方法。
- 可以进一步探讨如何在更复杂的约束条件下进行优化，例如多个限制条件或更复杂的转移方程。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

### 个人心得摘录
- **FelFa_1414666**：通过前缀和优化，成功将时间复杂度从 $O(nk^2)$ 降低到 $O(nk)$，代码实现时需要注意边界条件的处理。
- **云浅知处**：前缀和优化是一种非常有效的优化手段，特别是在需要频繁计算区间和的情况下。
- **chlchl**：前缀和的使用不仅优化了时间复杂度，还简化了代码逻辑，使得代码更易于理解和维护。

---
处理用时：34.45秒
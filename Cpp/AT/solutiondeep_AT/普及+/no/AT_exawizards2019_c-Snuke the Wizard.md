# 题目信息

# Snuke the Wizard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/exawizards2019/tasks/exawizards2019_c

左から右に向かって $ 1 $ から $ N $ の番号がついた $ N $ 個のマスがあります。 各マスには文字が書かれており、マス $ i $ には文字 $ s_i $ が書かれています。また、各マスにははじめ $ 1 $ 体のゴーレムがいます。

すぬけ君は $ Q $ 回呪文を唱え、ゴーレムたちを移動させました。

$ i $ 番目の呪文は文字 $ t_i $ と $ d_i $ からなり、$ d_i $ は `L` か `R` のいずれかです。 すぬけ君がこの呪文を唱えると、$ t_i $ が書かれた全てのマスについて、そのマスにいる全てのゴーレムが隣接するマスに移動します。移動する方向は $ d_i $ が `L` ならば左、`R` ならば右です。

ただし、マス $ 1 $ から左に移動しようとしたゴーレムと、マス $ N $ から右に移動しようとしたゴーレムは消滅します。

$ Q $ 回の呪文詠唱後に消滅していないゴーレムの総数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,Q\ \leq\ 2\ \times\ 10^{5} $
- $ |s|\ =\ N $
- $ s_i,t_i $ は英大文字
- $ d_i $ は `L` または `R`

### Sample Explanation 1

\- はじめ、各マスに $ 1 $ 体のゴーレムがいます。 - $ 1 $ 番目の呪文では、マス $ 1 $ にいるゴーレムが左に移動しようとし、消滅します。 - $ 2 $ 番目の呪文では、マス $ 2 $ にいるゴーレムが左に移動します。 - $ 3 $ 番目の呪文では、移動するゴーレムはいません。 - $ 4 $ 番目の呪文では、マス $ 1 $ にいるゴーレムが右に移動します。 - $ 4 $ 回の呪文詠唱後、マス $ 2 $ に $ 1 $ 体、マス $ 3 $ に $ 1 $ 体のゴーレムがいるため、消滅していないゴーレムは $ 2 $ 体です。

### Sample Explanation 2

\- $ 3 $ 回の呪文詠唱後、マス $ 2 $ に $ 1 $ 体、マス $ 4 $ に $ 2 $ 体、マス $ 6 $ に $ 2 $ 体のゴーレムがいるため、消滅していないゴーレムは $ 5 $ 体です。 - $ 1 $ つの呪文で複数のゴーレムが移動しうることに注意してください。

## 样例 #1

### 输入

```
3 4

ABC

A L

B L

B R

A R```

### 输出

```
2```

## 样例 #2

### 输入

```
8 3

AABCBDBA

A L

B R

A R```

### 输出

```
5```

## 样例 #3

### 输入

```
10 15

SNCZWRCEWB

B R

R R

E R

W R

Z L

S R

Q L

W L

B R

C L

A L

N L

E R

Z L

S L```

### 输出

```
3```

# AI分析结果

### 题目内容重写

从左到右有编号为 $1$ 到 $N$ 的 $N$ 个方格，每个方格上有一个字符 $s_i$。初始时，每个方格上有一个魔像。

Snuke 进行了 $Q$ 次咒语操作，每次操作由字符 $t_i$ 和方向 $d_i$ 组成，$d_i$ 是 `L` 或 `R`。每次操作时，所有字符为 $t_i$ 的方格上的魔像会向 $d_i$ 指定的方向移动一格。如果魔像从第 $1$ 个方格向左移动或从第 $N$ 个方格向右移动，则魔像会消失。

求 $Q$ 次操作后，未消失的魔像的总数。

### 算法分类
二分

### 题解分析与结论

#### 题解1：Kvaratskhelia
**星级：4**
**关键亮点：**
1. 通过二分查找确定最终会消失的魔像的边界。
2. 使用 `check` 函数模拟魔像的移动过程，判断某个位置的魔像是否会消失。
3. 时间复杂度为 $\mathcal{O}(Q \log N)$，适合大规模数据。

**核心代码：**
```cpp
int check(int x) {
    for(int i=1;i<=m;i++) {
        if(st[x-1]==a[i]) {
            if(b[i]=='R') x++;
            else x--;
        }
        if(x>n) return -1;
        if(x<1) return 1;
    }
    return 0;
}
```
**实现思想：**
通过二分查找确定最左边和最右边会消失的魔像的位置，然后计算未消失的魔像数量。

### 最优关键思路或技巧
1. **二分查找**：通过二分查找确定魔像消失的边界，减少时间复杂度。
2. **模拟移动**：使用 `check` 函数模拟魔像的移动过程，判断其是否会消失。

### 可拓展之处
1. **类似问题**：可以扩展到其他涉及移动和边界判断的问题，如粒子运动、机器人移动等。
2. **优化思路**：可以考虑使用更高效的数据结构或算法来进一步优化时间复杂度。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得
通过二分查找和模拟移动的结合，能够高效地解决大规模数据的问题。在实际编码中，需要注意边界条件的处理，确保算法的正确性。

---
处理用时：17.16秒
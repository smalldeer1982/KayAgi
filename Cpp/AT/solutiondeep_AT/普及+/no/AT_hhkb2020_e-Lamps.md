# 题目信息

# Lamps

## 题目描述

[problemUrl]: https://atcoder.jp/contests/hhkb2020/tasks/hhkb2020_e

縦 $ H $ 行、横 $ W $ 列からなるマス目があり、それぞれのマスは散らかっているか散らかっていないかのどちらかです。

今からあなたはこのマス目のうち $ 0 $ 個以上の散らかっていないマスに照明を置きます。

照明は置かれたマスの上下左右の $ 4 $ 方向に、マス目の端もしくは最初に散らかっているマスにぶつかる直前まで照らします (散らかっているマスは照らされません)。照明は、置かれたマス自身も照らします。

整数 $ H,\ W $ と $ H $ 個の長さ $ W $ の文字列 $ S_i $ が与えられます。 $ S_i $ の $ j $ 文字目が `.` のとき、上から $ i $ 行目、左から $ j $ 列目のマスは散らかっていません。$ S_i $ の $ j $ 文字目が `#` のとき、上から $ i $ 行目、左から $ j $ 列目のマスは散らかっています。

散らかっていないマスの個数を $ K $ 個だとすると、照明の置き方は全部で $ 2^K $ 通りあります。 この $ 2^K $ 通りそれぞれについて、$ 1 $ 個以上の照明によって照らされるマスの個数を計算したときの総和を $ 1,000,000,007 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 2000 $
- $ 1\ \leq\ W\ \leq\ 2000 $
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列

### Sample Explanation 1

全部で照明の置き方は $ 16 $ 通りあります。 - このうち $ 9 $ 通り (左から $ 1 $ 番目か $ 2 $ 番目の少なくとも一方に照明が置かれている、かつ左から $ 4 $ 番目か $ 5 $ 番目の少なくとも一方に照明が置かれている) では、$ 4 $ マスが照らされます。 - このうち $ 3 $ 通り (左から $ 1 $ 番目か $ 2 $ 番目の少なくとも一方に照明が置かれている、かつ左から $ 4 $ 番目と $ 5 $ 番目のどちらにも照明が置かれていない) では、$ 2 $ マスが照らされます。 - このうち $ 3 $ 通り (左から $ 4 $ 番目か $ 5 $ 番目の少なくとも一方に照明が置かれている、かつ左から $ 1 $ 番目と $ 2 $ 番目のどちらにも照明が置かれていない) では、$ 2 $ マスが照らされます。 - このうち $ 1 $ 通り (照明が $ 1 $ つも置かれていない) では、$ 0 $ マスが照らされます。 求める総和は $ 4\ \times\ 9\ +\ 2\ \times\ 3\ +\ 2\ \times\ 3\ +\ 0\ \times\ 1\ =\ 48 $ となります。

## 样例 #1

### 输入

```
1 5

..#..```

### 输出

```
48```

## 样例 #2

### 输入

```
2 3

..#

#..```

### 输出

```
52```

# AI分析结果

### 题目内容重写

**题目描述**

有一个由 $H$ 行 $W$ 列组成的网格，每个格子要么是整洁的，要么是杂乱的。现在你可以在这个网格中的任意一个或多个整洁的格子上放置照明灯。照明灯会照亮其所在格子的上下左右四个方向，直到遇到网格的边界或第一个杂乱的格子为止（杂乱的格子不会被照亮）。照明灯也会照亮其所在的格子。

给定整数 $H$、$W$ 和 $H$ 个长度为 $W$ 的字符串 $S_i$。如果 $S_i$ 的第 $j$ 个字符是 `.`，则表示第 $i$ 行第 $j$ 列的格子是整洁的；如果 $S_i$ 的第 $j$ 个字符是 `#`，则表示第 $i$ 行第 $j$ 列的格子是杂乱的。

假设整洁的格子共有 $K$ 个，那么照明灯的放置方式共有 $2^K$ 种。对于每一种放置方式，计算被至少一盏灯照亮的格子数，并将所有放置方式的结果求和，最后对 $1,000,000,007$ 取模。

**说明/提示**

**约束条件**

- $1 \leq H \leq 2000$
- $1 \leq W \leq 2000$
- $S_i$ 是由 `.` 和 `#` 组成的长度为 $W$ 的字符串

**样例解释**

**样例 #1**

输入：
```
1 5
..#..
```
输出：
```
48
```

**样例 #2**

输入：
```
2 3
..#
#..
```
输出：
```
52
```

### 算法分类
组合数学

### 题解分析与结论

**综合分析**

这道题的核心在于如何高效地计算每个格子在所有照明灯放置方案中被照亮的次数。由于直接枚举所有 $2^K$ 种方案不可行，题解们普遍采用了“贡献法”，即计算每个格子对最终答案的贡献。

**关键思路与技巧**

1. **贡献法**：通过计算每个格子被照亮的方案数，来间接计算总答案。
2. **容斥原理**：计算一个格子被照亮的方案数时，使用“全集 - 一个都没有”的容斥思想。
3. **预处理**：预处理每个格子能被照亮的格子数，通常通过四个方向的递推来实现。

**题解评分与亮点**

1. **robinyqc (4星)**
   - **亮点**：使用了贡献法和容斥原理，代码简洁且高效。
   - **关键代码**：
     ```rust
     let mut ans = Mint::new(0);
     let pwk = pw2[k];
     for i in &p {
         for j in i {
             if *j != 0 {
                 ans += pwk - pw2[k + 3 - *j as usize];
             }
         }
     }
     ```
   - **核心思想**：通过预处理每个格子能被照亮的格子数，然后使用容斥原理计算贡献。

2. **_RainCappuccino_ (4星)**
   - **亮点**：详细解释了贡献法的思路，代码结构清晰。
   - **关键代码**：
     ```cpp
     int cnt = l[i][j] + r[i][j] + d[i][j] + u[i][j] + 1;
     ans += (fac[cnt] - 1 + mod) % mod * fac[k - cnt] % mod;
     ans %= mod;
     ```
   - **核心思想**：通过预处理每个格子能被照亮的格子数，然后使用乘法原理计算贡献。

3. **wcyQwQ (4星)**
   - **亮点**：详细解释了容斥原理的应用，代码实现较为完整。
   - **关键代码**：
     ```cpp
     int p = (j - l[i][j] - 1) + (r[i][j] - j - 1) + (i - u[i][j] - 1) + (d[i][j] - i - 1) + 1;
     res = (res + get_mod(qpow(2, k) - qpow(2, k - p))) % mod;
     ```
   - **核心思想**：通过预处理每个格子能被照亮的格子数，然后使用容斥原理计算贡献。

**最优关键思路**

最优的思路是使用贡献法和容斥原理，通过预处理每个格子能被照亮的格子数，然后计算每个格子对最终答案的贡献。这种方法避免了直接枚举所有方案，大大降低了时间复杂度。

**可拓展之处**

这种贡献法和容斥原理的组合在组合数学问题中非常常见，尤其是在需要计算所有方案的总贡献时。类似的题目可以通过类似的方法来解决。

**推荐题目**

1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)
3. [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)

**个人心得**

- **调试经历**：在处理边界条件时，容易出错，需要仔细检查预处理部分。
- **踩坑教训**：在计算贡献时，注意取模运算的顺序，避免溢出。
- **顿悟感想**：贡献法和容斥原理的结合可以大大简化复杂问题的计算。

---
处理用时：35.61秒
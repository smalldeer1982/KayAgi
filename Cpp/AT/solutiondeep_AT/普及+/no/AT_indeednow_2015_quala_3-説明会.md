# 题目信息

# 説明会

## 题目描述

[problemUrl]: https://atcoder.jp/contests/indeednow-quala/tasks/indeednow_2015_quala_3

ある企業は、説明会に参加する学生の選抜コンテストを行いました。 説明会を行おうとしている会場の最大収容可能人数が決まっているため、コンテスト担当者はボーダーラインを何点にするかを悩んでいます。

選抜方法を説明します。

- ボーダーラインが $ x $ 点のとき、正の点数を取っている学生のうち $ x $ 点以上の得点を得た学生を全て選抜する。
- つまり、$ 0 $ 点の学生は会場の最大収容可能人数に関わらず選抜しない。

あなたには、選抜コンテストにおける $ N $ 人の学生の点数が与えられます。 また、会場の候補が $ Q $ 個あります。そして、会場の最大収容可能人数はそれぞれ $ k_1,k_2,…,k_Q $ です。 ある企業は、説明会をこれらの会場の候補のうちいずれかで開催しようとしています。

あなたの仕事は、それぞれの会場候補で説明会を行う場合について、最小のボーダーラインを出力しなければなりません。 具体的には、$ i\ (1≦i≦Q) $ 番目の会場候補で説明会を行うと仮定したとき、上記の方法に基づいて選抜した学生の数が $ k_i $ 人以下となるようなボーダーラインのうち $ 0 $ 以上かつ最小のものを出力してください。

## 说明/提示

### Sample Explanation 1

とんでもないケースですが、$ 1 $ 番目の会場の最大収容可能人数は $ 0 $ なので、誰も通過させたくありません。それを達成するボーダーラインで最小のものは $ 11 $ 点です。 $ 2 $ 番目の会場の最大収容可能人数は $ 4 $ 人なので、選抜する人数がそれ以下になるようなボーダーラインを設定しなければなりません。 もしボーダーラインを $ 6 $ 点に設定した場合、$ 6 $ 人通過してしまい会場の最大収容可能人数をオーバーしてしまいます。$ 7 $ 点に設定した場合は $ 3 $ 人のみ通過し、会場に収容可能でき、これが最小のボーダーラインです。 $ 3 $ 番目の会場の最大収容可能人数は $ 12 $ 人ですが、ボーダーラインは $ 0 $ 点にします。なぜならば、選抜方法より $ 0 $ 点の学生は通過できないので、正の点数を取った $ 12 $ 人のみが通過するからです。

### Sample Explanation 3

全員が $ 0 $ 点のケースもありえます。 この場合は、どんなボーダーラインに設定しても誰も通過しないので、会場の最大収容可能人数に関わらずボーダーラインは $ 0 $ 点にします。

## 样例 #1

### 输入

```
15

0

0

0

1

1

2

3

4

5

6

6

6

8

9

10

3

0

4

12```

### 输出

```
11

7

0```

## 样例 #2

### 输入

```
9

3

3

3

2

2

2

1

1

1

1

4```

### 输出

```
3```

## 样例 #3

### 输入

```
4

0

0

0

0

1

0```

### 输出

```
0```

# AI分析结果

### 题目内容重写
某企业举办了一场选拔学生参加说明会的比赛。由于说明会会场的最大容纳人数有限，比赛负责人需要确定一个分数线。选拔规则如下：
- 当分数线为 $x$ 分时，所有得分大于等于 $x$ 分且得分不为零的学生将被选中。
- 得分为零的学生无论会场容量如何都不会被选中。

给定 $N$ 名学生的得分和 $Q$ 个会场的最大容纳人数 $k_1, k_2, \dots, k_Q$，你需要为每个会场确定一个最小的分数线，使得被选中的学生人数不超过该会场的最大容纳人数。

### 算法分类
排序

### 题解分析与结论
所有题解的核心思路都是通过排序和二分查找来确定最小分数线。具体步骤如下：
1. 过滤掉得分为零的学生，只保留得分不为零的学生。
2. 将得分不为零的学生按得分从小到大排序。
3. 对于每个会场的最大容纳人数 $k$，如果 $k$ 大于等于得分不为零的学生人数，则分数线为 $0$；否则，分数线为第 $t-k$ 名学生的得分加 $1$。

### 所选高星题解
#### 题解作者：kkk_dex (4星)
**关键亮点**：
- 代码简洁明了，逻辑清晰。
- 直接使用 `sort` 函数进行排序，代码可读性强。
- 通过 `t-k` 直接找到分数线，避免了复杂的二分查找。

**核心代码**：
```cpp
sort(a+1,a+t+1); // 按分数从小到大排序
for(int i=1;i<=m;i++) {
    cin>>k;
    if(k>=t) cout<<0<<endl;
    else cout<<a[t-k]+1<<endl;
}
```

#### 题解作者：LeiZeProMax (4星)
**关键亮点**：
- 使用了快读函数，提高了输入效率。
- 代码结构清晰，注释详细。
- 通过 `num-k` 直接找到分数线，逻辑简单明了。

**核心代码**：
```cpp
sort(a+1,a+num+1); // 将学生的分数从小到大排序
for(int i=1;i<=q;++i) {
    k=read();
    if(k>=num) puts("0");
    else printf("%d\n",a[num-k]+1);
}
```

#### 题解作者：Wy_x (4星)
**关键亮点**：
- 提供了归并排序的实现，适合对排序算法有更高要求的场景。
- 详细解释了排序和分数线确定的逻辑。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
sort(a+1,a+tot+1); // sort默认由小到大排序
for(int i=1;i<=q;i++) {
    cin>>k;
    if(k>=tot) cout<<0<<endl;
    else cout<<a[tot-k]+1<<endl;
}
```

### 最优关键思路或技巧
1. **过滤零分学生**：首先过滤掉得分为零的学生，只保留得分不为零的学生，简化问题。
2. **排序**：将得分不为零的学生按得分从小到大排序，便于后续查找。
3. **直接查找**：通过 `t-k` 或 `num-k` 直接找到分数线，避免了复杂的二分查找，提高效率。

### 可拓展之处
- **类似问题**：可以通过排序和二分查找来解决类似的选择问题，如选择前 $k$ 个最大或最小的元素。
- **优化输入**：在处理大规模数据时，可以使用快读函数提高输入效率。

### 推荐题目
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

---
处理用时：27.40秒
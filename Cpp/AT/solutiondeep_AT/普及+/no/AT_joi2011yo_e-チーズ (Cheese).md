# 题目信息

# チーズ (Cheese)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2011yo/tasks/joi2011yo_e

今年も JOI 町のチーズ工場がチーズの生産を始め，ねずみが巣から顔を出した．JOI 町は東西南北に区画整理されていて，各区画は巣，チーズ工場，障害物，空き地のいずれかである．ねずみは巣から出発して全てのチーズ工場を訪れチーズを $ 1 $ 個ずつ食べる．

この町には，$ N $ 個のチーズ工場があり，どの工場も $ １ $ 種類のチーズだけを生産している．チーズの硬さは工場によって異なっており，硬さ $ 1 $ から $ N $ までのチーズを生産するチーズ工場がちょうど $ 1 $ つずつある．

ねずみの最初の体力は $ 1 $ であり，チーズを $ 1 $ 個食べるごとに体力が $ 1 $ 増える．ただし，ねずみは自分の体力よりも硬いチーズを食べることはできない．

ねずみは，東西南北に隣り合う区画に $ 1 $ 分で移動することができるが，障害物の区画には入ることができない．チーズ工場をチーズを食べずに通り過ぎることもできる．すべてのチーズを食べ終えるまでにかかる最短時間を求めるプログラムを書け．ただし，ねずみがチーズを食べるのにかかる時間は無視できる．

- - - - - -

## 说明/提示

### Sample Explanation 1

\- - - - - -

### Sample Explanation 2

\- - - - - -

## 样例 #1

### 输入

```
3 3 1
S..
...
..1```

### 输出

```
4```

## 样例 #2

### 输入

```
4 5 2
.X..1
....X
.XX.S
.2.X.```

### 输出

```
12```

## 样例 #3

### 输入

```
10 10 9
.X...X.S.X
6..5X..X1X
...XXXX..X
X..9X...X.
8.X2X..X3X
...XX.X4..
XX....7X..
X..X..XX..
X...X.XX..
..X.......```

### 输出

```
91```

# AI分析结果

### 题目翻译

**题目名称：チーズ (Cheese)**

**题目描述：**

今年，JOI 町的奶酪工厂开始生产奶酪，老鼠从巢穴中探出头来。JOI 町被划分为东西南北的区划，每个区划可能是巢穴、奶酪工厂、障碍物或空地。老鼠从巢穴出发，访问所有的奶酪工厂，并依次吃掉每个工厂的奶酪。

这个町有 $N$ 个奶酪工厂，每个工厂只生产一种奶酪。奶酪的硬度因工厂而异，硬度从 $1$ 到 $N$ 的奶酪工厂各有一个。

老鼠的初始体力为 $1$，每吃一个奶酪，体力增加 $1$。但是，老鼠不能吃比当前体力更硬的奶酪。

老鼠可以在东西南北相邻的区划中每分钟移动一次，但不能进入障碍物区划。老鼠可以经过奶酪工厂而不吃奶酪。请编写一个程序，计算老鼠吃完所有奶酪所需的最短时间。吃奶酪的时间可以忽略不计。

**样例 #1**

输入：
```
3 3 1
S..
...
..1
```

输出：
```
4
```

**样例 #2**

输入：
```
4 5 2
.X..1
....X
.XX.S
.2.X.
```

输出：
```
12
```

**样例 #3**

输入：
```
10 10 9
.X...X.S.X
6..5X..X1X
...XXXX..X
X..9X...X.
8.X2X..X3X
...XX.X4..
XX....7X..
X..X..XX..
X...X.XX..
..X.......
```

输出：
```
91
```

### 算法分类
**广度优先搜索 BFS**

### 题解分析与结论

该题的核心思路是通过多次 BFS 搜索，依次从当前奶酪工厂位置到下一个奶酪工厂位置的最短路径。由于老鼠必须按照奶酪硬度的顺序吃奶酪，因此每次 BFS 的起点是上一个奶酪工厂的位置，终点是下一个奶酪工厂的位置。最终的总时间即为所有 BFS 搜索得到的最短路径之和。

### 精选题解

#### 题解1：Blue_wonders (4星)
**关键亮点：**
- 使用结构体存储队列元素，简化了代码。
- 每次 BFS 前清空 `vis` 数组，确保每次搜索的独立性。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
void bfs(int c, int u, int o) {
    int tail = 1, head = 0;
    h[0] = (point){u, o, 0};
    while (head <= tail) {
        vis[u][o] = 1;
        int x = h[head].x, y = h[head].y, step = h[head].dep;
        head++;
        if (a[x][y] == c) {
            ax = x;
            ay = y;
            s += step;
            return;
        }
        for (int i = 1; i <= 4; i++) {
            int x0 = x + kx[i], y0 = y + ky[i];
            if (x0 > 0 && x0 <= n && y0 > 0 && y0 <= m && a[x0][y0] != -1 && vis[x0][y0] == 0) {
                vis[x0][y0] = 1;
                h[tail] = (point){x0, y0, step + 1};
                tail++;
            }
        }
    }
}
```

#### 题解2：细数繁星 (4星)
**关键亮点：**
- 使用 `queue` 代替数组实现 BFS，代码更加简洁。
- 强调了 `vis` 数组每次需要清空的重要性。
- 代码逻辑清晰，易于理解。

**核心代码：**
```cpp
void bfs(int end) {
    memset(vis, 0, sizeof vis);
    queue<node> q;
    q.push({starti, startj, 0});
    vis[starti][startj] = true;
    while (q.size()) {
        node now = q.front();
        q.pop();
        if (arr[now.x][now.y] == end) {
            ans += now.step;
            starti = now.x;
            startj = now.y;
            return;
        }
        int dxy[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        repq(i, 0, 4) {
            int dx = now.x + dxy[i][0], dy = now.y + dxy[i][1];
            if (dx < 1 || dx > n || dy < 1 || dy > m || vis[dx][dy] || arr[dx][dy] < 0) continue;
            vis[dx][dy] = true;
            q.push({dx, dy, now.step + 1});
        }
    }
}
```

#### 题解3：Aisaka_Taiga (4星)
**关键亮点：**
- 使用 `queue` 实现 BFS，代码简洁高效。
- 强调了 `vis` 数组每次需要清空的重要性。
- 代码逻辑清晰，易于理解。

**核心代码：**
```cpp
void bfs(int w, int u, int v) {
    queue<sb> q;
    q.push((sb){u, v, 0});
    while (!q.empty()) {
        vis[u][v] = 1;
        sb qwq = q.front(); q.pop();
        int x = qwq.x, y = qwq.y, step = qwq.dep;
        if (a[x][y] == w) {
            ax = x;
            ay = y;
            s += step;
            return;
        }
        for (int i = 0; i <= 3; i++) {
            int x0 = x + dx[i], y0 = y + dy[i];
            if (x0 <= 0 || x0 > n || y0 <= 0 || y0 > m || a[x0][y0] == -1 || vis[x0][y0]) continue;
            vis[x0][y0] = 1;
            q.push((sb){x0, y0, step + 1});
        }
    }
}
```

### 最优关键思路
- **多次 BFS**：由于老鼠必须按照奶酪硬度的顺序吃奶酪，因此需要多次 BFS 搜索，每次从上一个奶酪工厂的位置到下一个奶酪工厂的位置。
- **清空 `vis` 数组**：每次 BFS 前必须清空 `vis` 数组，确保每次搜索的独立性。
- **使用 `queue` 实现 BFS**：`queue` 可以简化 BFS 的实现，代码更加简洁高效。

### 可拓展之处
- 类似题目可以考察在复杂地图中寻找最短路径的问题，通常可以使用 BFS 或 Dijkstra 算法解决。
- 可以拓展到动态规划或 A* 算法，进一步优化路径搜索的效率。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

### 个人心得
- **调试经历**：多次 BFS 时，忘记清空 `vis` 数组导致错误，提醒了每次 BFS 前必须清空 `vis` 数组。
- **踩坑教训**：输出时忘记换行导致 WA，强调了输出格式的重要性。

---
处理用时：54.07秒
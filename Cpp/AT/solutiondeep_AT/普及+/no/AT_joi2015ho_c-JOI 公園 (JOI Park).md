# 题目信息

# JOI 公園 (JOI Park)

## 题目描述

# 「JOI 2014/2015 决赛」JOI 公园

**译自 [JOI 2014/2015 决赛](https://www.ioi-jp.org/joi/2014/2015-ho/index.html) T3「[JOI 公園](https://www.ioi-jp.org/joi/2014/2015-ho/2015-ho.pdf)」**

时值 $ 20\text{XX} $ 年， IOI 国为了给办奥赛做准备，将要修缮 IOI 国中的 JOI 公园。 JOI 公园里有 $ N $ 个广场，这些广场从 $ 1 $ 到 $ N $ 编号。有 $ M $ 条道路连接各个广场，这些道路从 $ 1 $ 到 $ M $ 编号。第 $ i(1 \leq i \leq M) $ 条道路是一条连接第 $ A_i $ 和第 $ B_i $ 个广场的双向边，长度为 $ D_i $ 。任意两个广场间一定有道路（直接或间接）相连。

修缮计划如下：首先，选择一个**自然数**  $ X $ ，将和第一个广场距离等于 $ X $ 或在 $ X $ 以下的所有广场（含第一个广场）相互之间连结一条地下通道。广场 $ i $ 和广场 $ j $ 的距离指，从广场 $ i $ 到广场 $ j $ 经过的道路长度总和的最小值。定义 $ C $ 为一个与修筑地下通道花费有关的量（ $ C $ 是整数）。修筑所有地下通道的花费为 $ C\times X $ 。

接下来，撤去已经通过地下通道连接的广场之间的道路。撤去道路的花费不计。

最后，将没有被撤去的道路进行修补，长为 $ d $ 的道路修补的花费为 $ d $ 。

修缮计划实施之前， JOI 公园没有地下通道。请求出 JOI 公园修缮花费总和的最小值。

#### 任务
给出 JOI 公园的广场间道路的情况和 $ C $ 的值，请编写程序求出修缮 JOI 公园的花费总和的最小值。

## 说明/提示

对于输入样例 $1$， $ X=3 $ 也就是说，和广场 $ 1 $ 的距离在 $ 3 $ 或以下的广场（广场 $ 1 $ ，广场 $ 2 $ ，广场 $ 3 $ ）互相之间连接一条地下通道。修缮总花费为 $ 2\times 3+3+5=14 $ 。这就是最小值。
#### 输入样例 2
```plain
5 4 10
1 2 3
2 3 4
3 4 3
4 5 5
```
#### 输出样例 2
```plain
15
```
对于输入样例 $ 2 $ ，$ X=0 $ 时修缮总花费最小。
#### 输入样例 3
```plain
6 5 2
1 2 2
1 3 4
1 4 3
1 5 1
1 6 5
```
#### 输出样例 3
```plain
10
```
对于输入样例 $3$，$ X=5 $ 时所有广场相互间都会连接一条地下通道，此时修缮的花费最小。

对于 $ 15\% $ 的分值：
- $ N \leq 100 $
- $ M \leq 200 $
- $ C \leq 100 $
- $ D_i \leq 10 (1 \leq i \leq M) $

对于另 $ 45\% $ 的分值：
- $ N \leq 100 $
- $ M \leq 4000 $

对于 $ 100\% $ 的分值，所以输入数据满足以下条件：
- $ 2 \leq N \leq 10^5 $
- $ 1 \leq M \leq 2\times 10^5 $
- $ 1 \leq C \leq 10^5 $
- $ 1 \leq A_i,B_i \leq N (1 \leq i \leq M) $
- $ A_i\not = B_i (1 \leq i \leq M) $
- $ (A_i,B_i)\not =(A_j,B_j) $ 而且 $ (A_i,B_i)\not =(B_j,A_j) (1 \leq i\lt j \leq M) $
- $ 1 \leq D_i \leq 10^5 (1 \leq i \leq M) $
- 输入数据保证任意两个广场之间一定有道路连接（直接或间接）。

感谢@ミク 提供的翻译

## 样例 #1

### 输入

```
5 5 2
2 3 1
3 1 2
2 4 3
1 2 4
2 5 5```

### 输出

```
14```

## 样例 #2

### 输入

```
5 4 10
1 2 3
2 3 4
3 4 3
4 5 5```

### 输出

```
15```

## 样例 #3

### 输入

```
6 5 2
1 2 2
1 3 4
1 4 3
1 5 1
1 6 5```

### 输出

```
10```

# AI分析结果

### 题目翻译

**题目描述**

时值 $20\text{XX}$ 年，IOI 国为了给办奥赛做准备，将要修缮 IOI 国中的 JOI 公园。JOI 公园里有 $N$ 个广场，这些广场从 $1$ 到 $N$ 编号。有 $M$ 条道路连接各个广场，这些道路从 $1$ 到 $M$ 编号。第 $i(1 \leq i \leq M)$ 条道路是一条连接第 $A_i$ 和第 $B_i$ 个广场的双向边，长度为 $D_i$。任意两个广场间一定有道路（直接或间接）相连。

修缮计划如下：首先，选择一个**自然数** $X$，将和第一个广场距离等于 $X$ 或在 $X$ 以下的所有广场（含第一个广场）相互之间连结一条地下通道。广场 $i$ 和广场 $j$ 的距离指，从广场 $i$ 到广场 $j$ 经过的道路长度总和的最小值。定义 $C$ 为一个与修筑地下通道花费有关的量（$C$ 是整数）。修筑所有地下通道的花费为 $C \times X$。

接下来，撤去已经通过地下通道连接的广场之间的道路。撤去道路的花费不计。

最后，将没有被撤去的道路进行修补，长为 $d$ 的道路修补的花费为 $d$。

修缮计划实施之前，JOI 公园没有地下通道。请求出 JOI 公园修缮花费总和的最小值。

#### 任务
给出 JOI 公园的广场间道路的情况和 $C$ 的值，请编写程序求出修缮 JOI 公园的花费总和的最小值。

### 算法分类
最短路、贪心

### 题解分析与结论

该题的核心思路是通过最短路算法（如 Dijkstra 或 SPFA）计算每个广场到第一个广场的最短距离，然后根据这些距离选择合适的 $X$ 值，使得总花费最小。大多数题解都采用了类似的方法，即先计算最短路，然后枚举可能的 $X$ 值，计算对应的总花费，并取最小值。

#### 关键思路：
1. **最短路计算**：使用 Dijkstra 或 SPFA 算法计算每个广场到第一个广场的最短距离。
2. **枚举 $X$**：由于 $X$ 只能是某个广场到第一个广场的最短距离，因此可以枚举这些距离作为 $X$ 的候选值。
3. **贪心策略**：在枚举 $X$ 时，维护一个变量表示当前未被删除的道路的总长度，每次更新 $X$ 时，减去那些被地下通道覆盖的道路的长度，从而计算当前的总花费。

#### 优化点：
- **排序**：将广场按照到第一个广场的最短距离排序，方便枚举 $X$。
- **维护边权**：在枚举 $X$ 时，通过标记已经被地下通道覆盖的广场，快速计算需要删除的道路的长度。

### 精选题解

#### 题解1：ZAGER (5星)
**关键亮点**：
- 使用了 Dijkstra 算法计算最短路，并通过排序和贪心策略枚举 $X$。
- 代码清晰，逻辑严谨，优化了边的处理，避免了重复计算。

**核心代码**：
```cpp
void dijkstra(int s) {
    for (int i = 1; i <= n; i++) dist[i] = INF;
    priority_queue<pli, vector<pli>, greater<pli>> q;
    q.push({0, s});
    dist[s] = 0;
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto &e : G[u]) {
            int v = e.first, w = e.second;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                q.push({dist[v], v});
            }
        }
    }
}
```

#### 题解2：Rusalka (4星)
**关键亮点**：
- 使用了 Dijkstra 算法，并通过排序和贪心策略枚举 $X$。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码**：
```cpp
void dijkstra(int s) {
    for (int i = 1; i <= n; i++) dis[i] = INF;
    priority_queue<pli, vector<pli>, greater<pli>> q;
    q.push({0, s});
    dis[s] = 0;
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto &e : G[u]) {
            int v = e.first, w = e.second;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push({dis[v], v});
            }
        }
    }
}
```

#### 题解3：cjh20090318 (4星)
**关键亮点**：
- 使用了 Dijkstra 算法，并通过排序和贪心策略枚举 $X$。
- 代码结构清晰，注释详细，适合进阶学习。

**核心代码**：
```cpp
void dj(const int S) {
    memset(dis, 0x3f, sizeof(LL) * (n + 1));
    priority_queue<PLI, vector<PLI>, greater<PLI>> Q;
    Q.emplace(dis[S] = 0, S);
    while (!Q.empty()) {
        int u = Q.top().second;
        Q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (const PII &V : G[u]) {
            int v = V.first, w = V.second;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                Q.emplace(dis[v], v);
            }
        }
    }
}
```

### 最优关键思路
1. **最短路计算**：使用 Dijkstra 或 SPFA 算法计算每个广场到第一个广场的最短距离。
2. **贪心策略**：枚举每个广场到第一个广场的最短距离作为 $X$，计算对应的总花费，并取最小值。
3. **维护边权**：在枚举 $X$ 时，通过标记已经被地下通道覆盖的广场，快速计算需要删除的道路的长度。

### 拓展思路
该题的思路可以拓展到其他需要基于最短路径进行决策的问题，例如在网络中选择某些节点进行优化，或者在图中选择某些边进行删除或保留。类似的问题可以通过最短路算法和贪心策略的结合来解决。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得
- **调试经历**：在实现过程中，确保最短路算法的正确性非常重要，特别是在处理大规模数据时，优先队列的使用可以显著提高效率。
- **踩坑教训**：在枚举 $X$ 时，注意处理相同最短距离的广场，避免重复计算或遗漏某些情况。
- **顿悟感想**：通过贪心策略结合最短路算法，可以有效地解决一些复杂的图论问题，关键在于如何合理地选择枚举的顺序和维护相关的变量。

---
处理用时：53.25秒
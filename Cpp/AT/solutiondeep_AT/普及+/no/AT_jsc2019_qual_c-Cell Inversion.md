# 题目信息

# Cell Inversion

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_c

$ 2N $ 個のマスが左右一列に並んでおり、各マスの色を表す長さ $ 2N $ の文字列 $ S $ が与えられます。

左から $ i $ 番目のマスの色は、$ S $ の $ i $ 文字目が `B` のとき黒色で、`W` のとき白色です。

あなたは異なる $ 2 $ マスを選んで、それらのマスおよびそれらの間にあるマスの色を反転する操作をちょうど $ N $ 回行います。 ここで、マスの色を反転するとは、そのマスの色が黒色なら白色に、白色なら黒色にすることです。

ただし、操作を通して同じマスを $ 2 $ 回以上選ぶことはできません。 つまり、各マスがちょうど $ 1 $ 回ずつ選ばれることになります。

$ N $ 回の操作終了後に全てのマスを白色にする方法が何通りあるかを $ 10^9+7 $ で割った余りを求めてください。

ここで、条件を満たす $ 2 $ つの方法が異なるとは、$ 1 $ つ目の方法で $ i $ 番目に選んだ $ 2 $ つのマスの組と $ 2 $ つ目の方法で $ i $ 番目に選んだ $ 2 $ つのマスの組が異なるような $ i $ $ (1\ \leq\ i\ \leq\ N) $ が存在することをいいます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ |S|\ =\ 2N $
- $ S $ の各文字は `B` または `W` である。

### Sample Explanation 1

全てのマスを白色にする方法は次の $ 4 $ 通りあります。 - 最初の操作では $ 1,\ 3 $ 番目のマスを選び、次の操作では $ 2,\ 4 $ 番目のマスを選びます。 - 最初の操作では $ 2,\ 4 $ 番目のマスを選び、次の操作では $ 1,\ 3 $ 番目のマスを選びます。 - 最初の操作では $ 1,\ 4 $ 番目のマスを選び、次の操作では $ 2,\ 3 $ 番目のマスを選びます。 - 最初の操作では $ 2,\ 3 $ 番目のマスを選び、次の操作では $ 1,\ 4 $ 番目のマスを選びます。

## 样例 #1

### 输入

```
2

BWWB```

### 输出

```
4```

## 样例 #2

### 输入

```
4

BWBBWWWB```

### 输出

```
288```

## 样例 #3

### 输入

```
5

WWWWWWWWWW```

### 输出

```
0```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $2N$ 个格子排成一列，每个格子的颜色由长度为 $2N$ 的字符串 $S$ 表示。从左到右第 $i$ 个格子的颜色为黑色（`B`）或白色（`W`），由 $S$ 的第 $i$ 个字符决定。

你需要进行恰好 $N$ 次操作，每次操作选择两个不同的格子，将这两个格子及其之间的所有格子的颜色反转（黑色变白色，白色变黑色）。要求每个格子必须恰好被选择一次。

最终要求所有格子的颜色都变为白色，求满足条件的操作方案数，结果对 $10^9+7$ 取模。

#### 说明/提示

##### 约束

- $1 \leq N \leq 10^5$
- $|S| = 2N$
- $S$ 的每个字符为 `B` 或 `W`

##### 样例解释

样例1：  
输入：  
```
2
BWWB
```  
输出：  
```
4
```  
解释：有4种操作方案可以使所有格子最终变为白色。

样例2：  
输入：  
```
4
BWBBWWWB
```  
输出：  
```
288
```

样例3：  
输入：  
```
5
WWWWWWWWWW
```  
输出：  
```
0
```

### 算法分类

组合数学

### 题解分析与结论

#### 题解1：HD0X（树状数组版 & 差分版）

**星级：4.5**  
**关键亮点：**
1. **思路清晰**：通过分析每个格子的反转次数，提出了一种基于差分或树状数组的解决方案。
2. **优化程度高**：使用并查集思想维护未选位置的查找，时间复杂度为 $O(n \log n)$，完全可接受。
3. **代码可读性较好**：虽然代码较长，但逻辑清晰，注释详细。

**核心实现思想：**
- 使用差分或树状数组记录每个格子的反转次数。
- 通过并查集思想查找下一个未选的相同字符且下标差为偶数的位置。
- 统计答案时，乘上每个区间的覆盖次数和全排列 $A_{n}^{n}$。

**核心代码片段：**
```cpp
int find(int x, int u) {
    if (vis[x]) {
        return nxt[x][u][1] = find(nxt[x][u][1], u);
    } else return x;
}
```

#### 题解2：qzhwlzy

**星级：4**  
**关键亮点：**
1. **思路简洁**：通过确定每个格子作为左端点或右端点，简化了问题。
2. **数学推导严谨**：通过归纳法确定每个格子的选择方式，并计算方案数。
3. **代码简洁**：代码量较少，逻辑清晰。

**核心实现思想：**
- 通过归纳法确定每个格子作为左端点或右端点。
- 计算每个右端点的可选左端点数量，并累乘得到方案数。
- 最终方案数为 $n! \times \prod_{i=1}^n (p_i - i + 1)$。

**核心代码片段：**
```cpp
if (a[i] != numl % 2) { numl++; totl++; }
else { numl--; numr++; ans = (ans * (totl - numr + 1) % mod) % mod; }
```

### 最优关键思路或技巧

1. **差分与树状数组**：通过差分或树状数组记录每个格子的反转次数，确保每个格子被反转的次数符合要求。
2. **并查集思想**：使用并查集思想维护未选位置的查找，优化查找效率。
3. **归纳法与组合数学**：通过归纳法确定每个格子的选择方式，并结合组合数学计算方案数。

### 可拓展之处

1. **类似问题**：可以拓展到更多关于格子反转的问题，如反转次数不固定、反转范围不连续等。
2. **数据结构优化**：在其他需要高效查找和更新的问题中，可以考虑使用树状数组或差分数组。

### 推荐题目

1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

---
处理用时：27.94秒
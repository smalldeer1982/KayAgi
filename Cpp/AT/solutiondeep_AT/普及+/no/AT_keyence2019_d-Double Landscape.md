# 题目信息

# Double Landscape

## 题目描述

[problemUrl]: https://atcoder.jp/contests/keyence2019/tasks/keyence2019_d

$ N $ 行 $ M $ 列のグリッドに，$ 1 $ から $ N\ \times\ M $ までの整数を重複のないように $ 1 $ つずつ書き込むことを考えます． ここで，普通に書き込むのでは面白くないと思った高橋君は，以下の条件を満たすように数を書き込むことにしました．

- $ i $ 行目に書き込まれている値のうち，最大の値は $ A_i $ $ (1\ \leq\ i\ \leq\ N) $
- $ j $ 列目に書き込まれている値のうち，最大の値は $ B_j $ $ (1\ \leq\ j\ \leq\ M) $

高橋君のために，この条件を満たすような書き込み方の個数を $ 10^9\ +\ 7 $ で割ったあまりを求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ M\ \leq\ 1000 $
- $ 1\ \leq\ A_i\ \leq\ N\ \times\ M $
- $ 1\ \leq\ B_j\ \leq\ N\ \times\ M $
- $ A_i,\ B_j $ は整数

### Sample Explanation 1

$ (A_1,\ A_2)\ =\ (4,\ 3) $，$ (B_1,\ B_2)\ =\ (3,\ 4) $ であり，この場合は以下の $ 2 $ 通りの書き込み方があります． - $ 1 $ 行 $ 1 $ 列目に $ 1 $，$ 1 $ 行 $ 2 $ 列目に $ 4 $，$ 2 $ 行 $ 1 $ 列目に $ 3 $，$ 2 $ 行 $ 2 $ 列目に $ 2 $ - $ 1 $ 行 $ 1 $ 列目に $ 2 $，$ 1 $ 行 $ 2 $ 列目に $ 4 $，$ 2 $ 行 $ 1 $ 列目に $ 3 $，$ 2 $ 行 $ 2 $ 列目に $ 1 $

### Sample Explanation 2

どのような書き込み方をしても条件を満たすことができないので，$ 0 $ を出力します．

## 样例 #1

### 输入

```
2 2

4 3

3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

5 9 7

3 6 9```

### 输出

```
0```

## 样例 #3

### 输入

```
2 2

4 4

4 4```

### 输出

```
0```

## 样例 #4

### 输入

```
14 13

158 167 181 147 178 151 179 182 176 169 180 129 175 168

181 150 178 179 167 180 176 169 182 177 175 159 173```

### 输出

```
343772227```

# AI分析结果

### 题目翻译

#### Double Landscape

#### 题目描述

在一个 $N$ 行 $M$ 列的网格中，将 $1$ 到 $N \times M$ 的整数不重复地填入每个格子。高桥君希望满足以下条件：

- 第 $i$ 行中填入的最大值是 $A_i$ $(1 \leq i \leq N)$
- 第 $j$ 列中填入的最大值是 $B_j$ $(1 \leq j \leq M)$

请计算满足条件的填数方案数，结果对 $10^9 + 7$ 取模。

#### 说明/提示

##### 制約

- $1 \leq N \leq 1000$
- $1 \leq M \leq 1000$
- $1 \leq A_i \leq N \times M$
- $1 \leq B_j \leq N \times M$
- $A_i, B_j$ 是整数

### 算法分类
组合数学

### 题解分析与结论

#### 题解1：Natori

**星级：4星**

**关键亮点：**
- 从大到小填数的思路清晰，利用了最大值不会被后续填数影响的特性。
- 分类讨论当前数的填法，逻辑严谨。
- 代码实现简洁，时间复杂度为 $\mathcal{O}(nm)$，适合大规模数据。

**个人心得：**
- 调试过程中发现变量名有些奇怪，但不影响整体逻辑。
- 通过从大到小填数的方式，避免了后续填数对最大值的影响，简化了问题。

**核心代码：**
```cpp
for(int i=n;i>=1;i--)
    for(int j=m;j>=1;j--){
        val=1ll*((i-1)*m+j);
        if(pn[val]!=-1&&pm[val]!=-1){
            nn++;
            mm++;
        }
        else if(pn[val]!=-1){
            if(mm==0){
                printf("0");
                return 0;
            }
            (ans*=mm)%=mod;
            nn++;
        }
        else if(pm[val]!=-1){
            if(nn==0){
                printf("0");
                return 0;
            }
            (ans*=nn)%=mod;
            mm++;
        }
        else{
            if(nn*mm-al==0){
                printf("0");
                return 0;
            }
            (ans*=(nn*mm-al))%=mod;
        }
        al++;
    }
```

### 最优关键思路
从大到小填数，利用最大值不会被后续填数影响的特性，分类讨论当前数的填法，逻辑严谨且时间复杂度低。

### 可拓展之处
类似的问题可以通过从大到小或从小到大的顺序填数，利用已填数对后续填数的影响来简化问题。例如，某些需要满足特定条件的排列组合问题。

### 推荐题目
1. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

---
处理用时：20.35秒
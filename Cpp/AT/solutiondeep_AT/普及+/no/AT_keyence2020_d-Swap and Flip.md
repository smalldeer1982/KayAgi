# 题目信息

# Swap and Flip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/keyence2020/tasks/keyence2020_d

$ N $ 枚のカードがあり、$ 1,\ 2,\ ...,\ N $ の番号がついています。 カード $ i $ ($ 1\ \leq\ i\ \leq\ N $) の片方の面には赤い文字で整数 $ A_i $ が、 もう片方の面には青い文字で整数 $ B_i $ が書かれています。 最初、これらのカードは赤い文字が書かれた面を表にして 左から右に番号順に一列に並んでいます。

以下の操作を繰り返すことで、カードの表側の面に書かれた整数の列が左から右に広義単調増加となる （すなわち、各 $ i $ ($ 1\ \leq\ i\ \leq\ N\ -\ 1 $) に対して、左から $ i\ +\ 1 $ 枚目のカードの表側の面に書かれた整数が $ i $ 枚目のカードの表側の面に書かれた整数以上である） ようにすることが可能かどうか判定してください。 さらに、可能である場合、必要な操作の回数の最小値を求めてください。

- 整数 $ i $ ($ 1\ \leq\ i\ \leq\ N\ -\ 1 $) を一つ選ぶ。 左から $ i $ 番目のカードと $ i\ +\ 1 $ 番目のカードの位置を入れ替え、さらにこれら $ 2 $ 枚のカードを裏返す。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 18 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 50 $ ($ 1\ \leq\ i\ \leq\ N $)
- 入力値はすべて整数である。

### Sample Explanation 1

$ i\ =\ 1 $ として操作を $ 1 $ 回行うと、 カードの表側の面に書かれた整数の列は $ [2,\ 3,\ 3] $ となり、単調増加となります。

### Sample Explanation 2

何回操作を行っても、 カードの表側の面に書かれた整数の列は $ [2,\ 1] $ のままであり、これは単調増加ではありません。

### Sample Explanation 3

操作を行う必要がない場合もあります。

## 样例 #1

### 输入

```
3

3 4 3

3 2 3```

### 输出

```
1```

## 样例 #2

### 输入

```
2

2 1

1 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
4

1 2 3 4

5 6 7 8```

### 输出

```
0```

## 样例 #4

### 输入

```
5

28 15 22 43 31

20 22 43 33 32```

### 输出

```
-1```

## 样例 #5

### 输入

```
5

4 46 6 38 43

33 15 18 27 37```

### 输出

```
3```

# AI分析结果

### 题目翻译

#### 题目描述

有 $N$ 张卡片，编号为 $1, 2, ..., N$。卡片 $i$（$1 \leq i \leq N$）的一面用红色字体写着整数 $A_i$，另一面用蓝色字体写着整数 $B_i$。最初，这些卡片以红色字体朝上的方式从左到右按编号顺序排列。

通过重复以下操作，判断是否可以使卡片朝上的数字从左到右非递减（即对于每个 $i$（$1 \leq i \leq N - 1$），从左数第 $i + 1$ 张卡片朝上的数字不小于第 $i$ 张卡片朝上的数字）。如果可能，求出所需的最小操作次数。

- 选择一个整数 $i$（$1 \leq i \leq N - 1$）。交换从左数第 $i$ 张和第 $i + 1$ 张卡片的位置，并将这两张卡片翻转。

#### 说明/提示

##### 约束条件

- $1 \leq N \leq 18$
- $1 \leq A_i, B_i \leq 50$（$1 \leq i \leq N$）
- 输入值均为整数。

##### 样例解释

- 样例1：选择 $i = 1$ 进行一次操作，卡片朝上的数字变为 $[2, 3, 3]$，满足非递减。
- 样例2：无论如何操作，卡片朝上的数字始终为 $[2, 1]$，不满足非递减。
- 样例3：无需操作，卡片朝上的数字已经满足非递减。

### 算法分类

枚举、排序、模拟

### 题解分析与结论

#### 题解1：cosf

**星级：4.5**

**关键亮点：**
1. 通过枚举每张卡片的翻转状态（$B$ 面朝上或 $A$ 面朝上），并结合奇偶性进行排序。
2. 使用两次排序来确定卡片的最终位置，并通过模拟冒泡排序计算最小操作次数。
3. 时间复杂度为 $O(2^n n^2)$，在 $N \leq 18$ 的范围内可行。

**核心代码：**
```cpp
for (int s = 0; s < (1 << n); s++) {
    if (popcount(s) & 1) continue;
    sort(p + 1, p + n + 1, [s](int x, int y) {
        int vx = a[x][(x ^ (s >> (x - 1))) & 1];
        int vy = a[y][(y ^ (s >> (y - 1))) & 1];
        if (vx != vy) return vx < vy;
        else return x < y;
    });
    // 二次排序和冒泡模拟
}
```

#### 题解2：封禁用户

**星级：4**

**关键亮点：**
1. 使用状态压缩枚举每张卡片的翻转状态，并通过奇偶性判断合法性。
2. 通过匹配卡片的位置和翻转状态，计算最小操作次数。
3. 时间复杂度为 $O(2^n n^2)$，与题解1类似。

**核心代码：**
```cpp
int solve(int s) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if ((s >> i) & 1) {
            cnt++;
            pre[i] = mkp(b[i], 1);
            after[i] = pre[i];
        } else {
            pre[i] = mkp(a[i], 0);
            after[i] = pre[i];
        }
    }
    if (cnt & 1) return inf;
    // 匹配和逆序数计算
}
```

### 最优关键思路

1. **枚举翻转状态**：通过枚举每张卡片的翻转状态（$A$ 面或 $B$ 面朝上），并结合奇偶性进行合法性判断。
2. **排序与匹配**：通过两次排序确定卡片的最终位置，并通过模拟冒泡排序计算最小操作次数。
3. **状态压缩与优化**：利用状态压缩和奇偶性判断，减少不必要的计算，提高效率。

### 可拓展之处

1. **类似问题**：可以扩展到更多卡片或更复杂的翻转规则，如多面翻转或不同翻转操作。
2. **优化思路**：进一步优化排序和匹配算法，减少时间复杂度，适用于更大的 $N$。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 枚举与状态压缩
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 动态规划与状态压缩
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 排序与模拟

### 个人心得

- **调试经历**：在实现过程中，需要特别注意奇偶性的判断和排序的顺序，否则容易导致错误的结果。
- **顿悟感想**：通过枚举和状态压缩，可以有效地解决看似复杂的问题，关键在于如何合理地减少状态空间。

---
处理用时：30.64秒
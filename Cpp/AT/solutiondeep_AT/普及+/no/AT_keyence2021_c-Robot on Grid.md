# 题目信息

# Robot on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/keyence2021/tasks/keyence2021_c

$ H $ 行 $ W $ 列のマス目があります。上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,j) $ と書くことにします。 それぞれのマスには `R`, `D`, `X` のいずれかの文字を書き込むことができます。はじめ、どのマスにも文字は書き込まれていません。

すぬけ君は $ K $ 個のマスを選んで文字を書き込みました。 $ i $ 番目に文字を書き込んだマスは $ (h_i,w_i) $ で、書き込んだ文字は $ c_i $ でした。

残りのマスへの文字の書き込み方は $ 3^{HW-K} $ 通りあります。それぞれの場合について以下の問題の答えを計算し、その総和を $ 998244353 $ で割ったあまりを求めてください。

> 上記のマス目上を移動可能なロボットがあります。 ロボットは $ (i,j) $ にいるとき、$ (i+1,j),(i,j+1) $ のいずれかに移動することができます。 ただし、$ (i,j) $ に `R` と書かれていた場合は $ (i,j+1) $ にのみ、`D` と書かれていた場合は $ (i+1,j) $ にのみ移動することができます。`X` と書かれていた場合はどちらにも移動可能です。
> 
> ロボットを $ (1,1) $ に設置したとき、ロボットがマス目の外に出ずに $ (H,W) $ に到達するようなロボットの移動経路は何通りありますか？ただし、ロボットは $ (H,W) $ に到達した時点で停止するものとします。
> 
> ここで、$ 2 $ つの移動経路が異なるとはロボットが通ったマスの集合が異なることをいいます。

## 说明/提示

### 制約

- $ 2\ \leq\ H,W\ \leq\ 5000 $
- $ 0\ \leq\ K\ \leq\ \min(HW,2\ \times\ 10^5) $
- $ 1\ \leq\ h_i\ \leq\ H $
- $ 1\ \leq\ w_i\ \leq\ W $
- $ i\ \neq\ j $ ならば $ (h_i,w_i)\ \neq\ (h_j,w_j) $
- $ c_i $ は `R`, `D`, `X` のいずれか

### Sample Explanation 1

\- $ (1,2) $ のみまだ文字が書き込まれていません。 - `R` を書いたとき、ロボットが $ (H,W) $ に到達するようなロボットの移動経路は $ 1 $ 通りです。 - `D` を書いたとき、ロボットが $ (H,W) $ に到達するようなロボットの移動経路は $ 2 $ 通りです。 - `X` を書いたとき、ロボットが $ (H,W) $ に到達するようなロボットの移動経路は $ 2 $ 通りです。 - これらの総和である $ 5 $ を出力してください。

### Sample Explanation 3

\- $ 998244353 $ で割ったあまりを求めるのを忘れずに。

## 样例 #1

### 输入

```
2 2 3

1 1 X

2 1 R

2 2 R```

### 输出

```
5```

## 样例 #2

### 输入

```
3 3 5

2 3 D

1 3 D

2 1 D

1 2 X

3 1 R```

### 输出

```
150```

## 样例 #3

### 输入

```
5000 5000 10

585 1323 R

2633 3788 X

1222 4989 D

1456 4841 X

2115 3191 R

2120 4450 X

4325 2864 X

222 3205 D

2134 2388 X

2262 3565 R```

### 输出

```
139923295```

# AI分析结果

### 题目翻译

#### 题目描述

有一个 $H$ 行 $W$ 列的网格。从上到下第 $i$ 行，从左到右第 $j$ 列的格子记为 $(i,j)$。每个格子可以写入 `R`、`D`、`X` 中的任意一个字符。初始时，所有格子都没有写入字符。

你选择了 $K$ 个格子并写入了字符。第 $i$ 个写入字符的格子是 $(h_i,w_i)$，写入的字符是 $c_i$。剩下的格子写入字符的方式有 $3^{HW-K}$ 种。对于每一种情况，计算以下问题的答案，并求其总和除以 $998244353$ 的余数。

> 有一个可以在网格上移动的机器人。当机器人在 $(i,j)$ 时，可以移动到 $(i+1,j)$ 或 $(i,j+1)$。但是，如果 $(i,j)$ 上写有 `R`，则只能移动到 $(i,j+1)$；如果写有 `D`，则只能移动到 $(i+1,j)$；如果写有 `X`，则可以移动到任意一个方向。
>
> 将机器人放置在 $(1,1)$，求机器人不离开网格且到达 $(H,W)$ 的移动路径数。机器人到达 $(H,W)$ 时停止。

### 算法分类
动态规划

### 题解分析与结论

#### 题解对比

1. **Crazyouth 的题解**：
   - **思路**：使用动态规划，`dp[i][j]` 表示从 $(1,1)$ 到 $(i,j)$ 的方案数。对于未写入字符的格子，方案数乘以 $\frac{2}{3}$。
   - **难点**：处理未写入字符的格子时，需要根据转移方向确定字符的选择。
   - **评分**：4星
   - **亮点**：简洁明了，直接处理未写入字符的格子，代码清晰。

2. **irris 的题解**：
   - **思路**：通过魔改方格取数，将路径上的未写入字符的格子贡献系数单独处理，优化为 $O(nm)$。
   - **难点**：将路径上的未写入字符的格子贡献系数与路径外的分开处理。
   - **评分**：4星
   - **亮点**：优化思路清晰，代码简洁。

3. **11400F 的题解**：
   - **思路**：初始值设置为 $3^{HW-K}$，处理未写入字符的格子时，转移值乘以 $\frac{2}{3}$。
   - **难点**：处理未写入字符的格子时，需要根据转移方向确定字符的选择。
   - **评分**：4星
   - **亮点**：代码简洁，处理未写入字符的格子思路清晰。

#### 最优关键思路
- **动态规划**：使用 `dp[i][j]` 表示从 $(1,1)$ 到 $(i,j)$ 的方案数。
- **未写入字符的格子处理**：对于未写入字符的格子，根据转移方向确定字符的选择，方案数乘以 $\frac{2}{3}$。

#### 可拓展之处
- **类似题目**：可以扩展到其他网格路径问题，如带有障碍物的路径计数问题。

#### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1077 摆花](https://www.luogu.com.cn/problem/P1077)

### 重点代码片段

```cpp
// Crazyouth 的代码片段
for(int i=1;i<=n;i++)
for(int j=1;j<=m;j++)
{
    if(i+j==2) continue;
    dp[i][j]=(a[i-1][j]!=(int)('R'))*dp[i-1][j]+(a[i][j-1]!=(int)('D'))*dp[i][j-1];
    dp[i][j]%=mod;
    if(!a[i][j]) dp[i][j]*=665496236;
    dp[i][j]%=mod;
}
```

```cpp
// irris 的代码片段
for(int i=1;i<=N;i++) for(int j=1;j<=M;j++) if(i!=1||j!=1) {
    if(m[i][j-1]!='D') dp[i][j]+=dp[i][j-1];
    if(m[i-1][j]!='R') dp[i][j]+=dp[i-1][j];
    if(m[i][j]=='?') dp[i][j]*=P;
}
```

```cpp
// 11400F 的代码片段
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(s[i][j]=='D'){
            ans[i+1][j]=add(ans[i+1][j],ans[i][j]);
        }else if(s[i][j]=='R'){
            ans[i][j+1]=add(ans[i][j+1],ans[i][j]);
        }else if(s[i][j]=='X'){
            ans[i+1][j]=add(ans[i+1][j],ans[i][j]);
            ans[i][j+1]=add(ans[i][j+1],ans[i][j]);
        }else{
            ans[i][j+1]=add(ans[i][j+1],ans[i][j]*inv3mul2%mod);
            ans[i+1][j]=add(ans[i+1][j],ans[i][j]*inv3mul2%mod);
        }
    }
}
```

---
处理用时：38.30秒
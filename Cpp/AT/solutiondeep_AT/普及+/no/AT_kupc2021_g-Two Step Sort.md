# 题目信息

# Two Step Sort

## 题目描述

有 $N$ 个盒子和 $N$ 个球，编号为 1 到 $N$。最初，第 $i$ 个盒子里装着编号为 $P_i$ 的球。每个盒子只能装一个球，开始时所有盒子都是关闭的，可以打开盒子。

接下来将进行两次球的移动操作，每次操作遵循以下步骤：

1. 选择若干盒子打开，每个盒子都有固定的打开成本。
2. 在打开的盒子之间随意移动球，操作完成时，每个盒子必须有一个球。
3. 将所有打开的盒子再次关闭。

第一次操作时，打开第 $i$ 个盒子的成本为 $A_i$；第二次操作时，打开第 $i$ 个盒子的成本为 $B_i$。经过两次操作后，要求第 $i$ 个盒子里装有第 $i$ 个球。请计算达到目标的最低总成本。

## 说明/提示

- $1 \leq N \leq 10^5$
- $1 \leq P_i \leq N$
- 当 $i \neq j$ 时，$P_i \neq P_j$
- $1 \leq A_i \leq 10^9$
- $1 \leq B_i \leq 10^9$
- 所有输入均为整数

### 示例解释

在第一个移动事件中，打开盒子 2 和 4，把球 1 放入盒子 2，把球 4 放入盒子 4，这样的操作成本是 8。在第二次移动事件中，打开盒子 1、2、3 和 5，把球 1、2、3 和 5 放入相应的盒子中，操作成本为 20。整个过程的总成本为 28，这是满足条件的最小成本。

有时候，初始状态已经满足要求，意味着不需要进行任何移动。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5

2 4 5 1 3

11 5 3 3 8

4 6 7 9 3```

### 输出

```
28```

## 样例 #2

### 输入

```
1

1

1000000000

1000000000```

### 输出

```
0```

# AI分析结果

### 题目重写
# 两步排序

## 题目描述

有 $N$ 个盒子和 $N$ 个球，编号为 1 到 $N$。最初，第 $i$ 个盒子里装着编号为 $P_i$ 的球。每个盒子只能装一个球，开始时所有盒子都是关闭的，可以打开盒子。

接下来将进行两次球的移动操作，每次操作遵循以下步骤：

1. 选择若干盒子打开，每个盒子都有固定的打开成本。
2. 在打开的盒子之间随意移动球，操作完成时，每个盒子必须有一个球。
3. 将所有打开的盒子再次关闭。

第一次操作时，打开第 $i$ 个盒子的成本为 $A_i$；第二次操作时，打开第 $i$ 个盒子的成本为 $B_i$。经过两次操作后，要求第 $i$ 个盒子里装有第 $i$ 个球。请计算达到目标的最低总成本。

## 说明/提示

- $1 \leq N \leq 10^5$
- $1 \leq P_i \leq N$
- 当 $i \neq j$ 时，$P_i \neq P_j$
- $1 \leq A_i \leq 10^9$
- $1 \leq B_i \leq 10^9$
- 所有输入均为整数

### 示例解释

在第一个移动事件中，打开盒子 2 和 4，把球 1 放入盒子 2，把球 4 放入盒子 4，这样的操作成本是 8。在第二次移动事件中，打开盒子 1、2、3 和 5，把球 1、2、3 和 5 放入相应的盒子中，操作成本为 20。整个过程的总成本为 28，这是满足条件的最小成本。

有时候，初始状态已经满足要求，意味着不需要进行任何移动。

### 算法分类
动态规划

### 题解分析与结论
所有题解都基于将问题转化为图论中的环结构，并通过动态规划（DP）来解决。核心思路是将每个环独立处理，通过DP计算每个环的最小成本。难点在于如何将环拆分为链并进行DP转移，同时处理环的首尾连接问题。

### 评分较高的题解
1. **作者：ran_qwq (赞：5)**
   - **星级：5**
   - **关键亮点：** 通过枚举环的首尾状态，将环拆分为链进行DP，代码简洁且高效。
   - **核心代码：**
     ```cpp
     void sol(int x,int y) {
         for(int i=1;i<=m;i++) mst(f[i],0x3f);
         f[1][x][y]=(ll)(x?a[ps[1]]:0)+(y?a[ps[m]]:0)+(!x||!y?b[ps[m]]:0);
         for(int i=2;i<m;i++) for(int p=0;p<2;p++) for(int q=0;q<2;q++) for(int r=0;r<2;r++)
             cminll(f[i][p][q],f[i-1][q][r]+(p?a[ps[i]]:0)+(!p||!q?b[ps[i-1]]:0));
         for(int p=0;p<2;p++) for(int q=0;q<2;q++) cminll(mn,f[m-1][p][q]+(!p||!y?b[ps[m-1]]:0));
     }
     ```

2. **作者：HYXLE (赞：2)**
   - **星级：4**
   - **关键亮点：** 通过断环为链，枚举链的首尾状态进行DP，思路清晰。
   - **核心代码：**
     ```cpp
     inline void solve(int u){
         v.clear();
         while(!vis[u]){v.emplace_back(u);vis[u]=1;u=fa[u];}
         int len=v.size();
         if(len==1)return;
         ll nw=inf;
         for(R int i=0;i<len;++i){
             sum[i+1]=sum[i]+a[to[v[i]]];
         }
         for(R int i=1;i<=len;++i)f[i][0]=f[i][1]=inf;
         f[1][0]=b[to[v[0]]];f[1][1]=inf;
         for(R int i=1;i<len;++i){
             f[i+1][0]=min(f[i][0],f[i][1])+b[to[v[i]]];
             f[i+1][1]=calc2(1,i+1)+b[to[v[0]]];
             f[i+1][1]=min({f[i+1][1],f[i][0]+b[to[v[i]]]+a[to[v[i]]],f[i][1]+a[to[v[i]]]});
         }
         nw=min(f[len][1],f[len][0]);
         for(R int i=1;i<=len;++i)f[i][0]=f[i][1]=inf;
         f[1][0]=inf;f[1][1]=a[to[v[0]]];
         for(R int i=1;i<len;++i){
             f[i+1][0]=min(f[i][0],f[i][1])+b[to[v[i]]];
             f[i+1][1]=calc2(1,i+1)+b[to[v[0]]];
             f[i+1][1]=min({f[i+1][1],f[i][0]+b[to[v[i]]]+a[to[v[i]]],f[i][1]+a[to[v[i]]]});
         }
         nw=min({nw,f[len][1],f[len][0]+b[to[v[0]]]});
         res+=nw;
     }
     ```

3. **作者：VitrelosTia (赞：1)**
   - **星级：4**
   - **关键亮点：** 通过DFS将环转化为序列，进行DP，代码结构清晰。
   - **核心代码：**
     ```cpp
     void dp() {
         for (int i = 2; i <= tot; i++) {
             f[i][0] = min(f[i - 1][0], f[i - 1][1] + a[c[i]]) + b[c[i]];
             f[i][1] = min(f[i - 1][0], f[i - 1][1]) + a[c[i]];
         }
     }
     ```

### 最优关键思路
将问题转化为图论中的环结构，通过动态规划（DP）计算每个环的最小成本。通过枚举环的首尾状态，将环拆分为链进行DP，处理环的首尾连接问题。

### 可拓展之处
类似的问题可以扩展到更复杂的图结构，如多环、带权图等。DP的思路可以应用于其他需要分段处理的问题，如区间DP、树形DP等。

### 推荐题目
1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)

### 个人心得摘录
- **ran_qwq：** 注意初始化不能用 memset，以及特判一下环长为 1 的情况。
- **HYXLE：** 不难发现若第一次要对点 $i$ 进行操作，则一定不会将其与除了 $pre_i$ 与 $aft_i$ 的点进行交换，易证这是不优的。
- **VitrelosTia：** 细节是如果第一个第一次不选，最后一个第一次选，要加上 $a_1$。

---
处理用时：51.45秒
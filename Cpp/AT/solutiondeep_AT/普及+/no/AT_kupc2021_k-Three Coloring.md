# 题目信息

# Three Coloring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/kupc2021/tasks/kupc2021_k

$ N $ 個の壁があります。各壁を赤、緑、青のいずれか $ 1 $ 色で塗ることを考えます。

$ M $ 個の条件が与えられます。$ i $ 番目の条件は、整数 $ a_i,b_i $ と文字 $ x_i,y_i $ が与えられ、

- 壁 $ a_i $ を 色 $ x_i $ で塗ったとき、壁 $ b_i $ を 色 $ y_i $ で塗ってはならない

ことを表しています。ただし、 $ x_i,y_i $ はそれぞれ文字 `R` , `G` , `B` のいずれかであり、 `R` のとき赤を、`G` のとき緑を、 `B` のとき青を表しています。

$ M $ 個全ての条件を満たす色の塗り方が何通りあるかを答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 22 $
- $ 0\ \leq\ M\ \leq\ 9\ \times\ \frac{N(N-1)}{2} $
- $ 1\ \leq\ a_i\ <\ b_i\ \leq\ N $
- $ x_i,y_i $ はそれぞれ文字 `R` , `G` , `B` のいずれかである。
- $ i\ \neq\ j $ のとき、$ (a_i,x_i,b_i,y_i)\ \neq\ (a_j,x_j,b_j,y_j) $
- $ N,M,a_i,b_i $ はいずれも整数

### Sample Explanation 1

壁 $ 1 $ を赤色で塗る場合、壁 $ 2 $ は緑色または青色で塗ることができます。 壁 $ 1 $ を緑色で塗る場合、壁 $ 2 $ は緑色または青色で塗ることができます。 壁 $ 1 $ を青色で塗る場合、壁 $ 2 $ は赤色または青色で塗ることができます。 よって、合計で $ 6 $ 通りの塗り方があります。

### Sample Explanation 2

壁 $ 1 $ をどの色で塗っても条件を満たします。

### Sample Explanation 3

オーバーフローに注意してください。

## 样例 #1

### 输入

```
2 3

1 R 2 R

1 G 2 R

1 B 2 G```

### 输出

```
6```

## 样例 #2

### 输入

```
1 0```

### 输出

```
3```

## 样例 #3

### 输入

```
22 0```

### 输出

```
31381059609```

## 样例 #4

### 输入

```
4 12

2 R 3 R

1 B 2 B

2 R 3 B

3 R 4 R

1 B 4 G

1 R 3 B

3 G 4 B

2 G 3 G

1 B 2 R

1 G 2 R

1 R 3 G

1 G 3 B```

### 输出

```
13```

# AI分析结果

### 题目内容重写

**三色涂色**

#### 题目描述

有 $N$ 个墙壁。考虑将每个墙壁涂成红色、绿色或蓝色中的一种颜色。

给出 $M$ 个条件。第 $i$ 个条件由整数 $a_i, b_i$ 和字符 $x_i, y_i$ 给出，表示：

- 如果墙壁 $a_i$ 被涂成颜色 $x_i$，那么墙壁 $b_i$ 不能被涂成颜色 $y_i$。

其中，$x_i, y_i$ 分别是字符 `R`, `G`, `B` 之一，分别表示红色、绿色和蓝色。

请计算满足所有 $M$ 个条件的涂色方案的总数。

#### 说明/提示

##### 约束条件

- $1 \leq N \leq 22$
- $0 \leq M \leq 9 \times \frac{N(N-1)}{2}$
- $1 \leq a_i < b_i \leq N$
- $x_i, y_i$ 分别是字符 `R`, `G`, `B` 之一。
- 当 $i \neq j$ 时，$(a_i, x_i, b_i, y_i) \neq (a_j, x_j, b_j, y_j)$
- $N, M, a_i, b_i$ 都是整数

##### 样例解释

**样例 1**

如果墙壁 $1$ 被涂成红色，那么墙壁 $2$ 可以被涂成绿色或蓝色。如果墙壁 $1$ 被涂成绿色，那么墙壁 $2$ 可以被涂成绿色或蓝色。如果墙壁 $1$ 被涂成蓝色，那么墙壁 $2$ 可以被涂成红色或蓝色。因此，总共有 $6$ 种涂色方案。

**样例 2**

墙壁 $1$ 可以被涂成任何颜色，且满足所有条件。

**样例 3**

注意溢出问题。

**样例 4**

见题目描述。

### 算法分类

**搜索 + 剪枝**

### 题解分析与结论

#### 题解 1：happy_dengziyue

**星级：4星**

**关键亮点：**
- 使用深度优先搜索（DFS）结合剪枝策略，有效减少了搜索空间。
- 通过预处理和位运算优化了条件检查，提高了效率。
- 利用随机化处理输入顺序，进一步优化了搜索过程。

**核心代码片段：**
```cpp
void dfs(int x, int now3, int now2) {
    if (x > n) {
        ans += pw3[now3] * pw2[now2];
        return;
    }
    bool have[4] = {0, 0, 0};
    bool can[4] = {1, 1, 1};
    for (int w = 0; w <= 2; ++w) {
        if (!((gc[x] >> w) & 1)) {
            can[w] = false;
            continue;
        }
        for (auto u : g[x][w]) {
            if (x < u.first) have[w] = true;
            else if (col[u.first] == u.second) can[w] = false;
        }
    }
    if (!have[0] && !have[1] && !have[2] && can[0] && can[1] && can[2]) {
        dfs(x + 1, now3 + 1, now2);
        return;
    }
    for (int i = 0; i <= 2; ++i) {
        for (int j = i + 1; j <= 2; ++j) {
            if (!have[i] && !have[j] && can[i] && can[j]) {
                dfs(x + 1, now3, now2 + 1);
                can[i] = can[j] = false;
            }
        }
    }
    for (col[x] = 0; col[x] <= 2; ++col[x]) {
        if (can[col[x]]) dfs(x + 1, now3, now2);
    }
    col[x] = -1;
}
```

**个人心得：**
- 通过随机化处理输入顺序，减少了搜索的深度和复杂度。
- 位运算的使用使得条件检查更加高效。

### 最优关键思路或技巧

- **剪枝策略**：在DFS过程中，通过预处理和位运算，提前排除不符合条件的涂色方案，减少搜索空间。
- **随机化处理**：通过随机化处理输入顺序，优化了搜索路径，进一步提高了效率。
- **位运算优化**：利用位运算快速检查颜色是否满足条件，提高了代码的执行效率。

### 可拓展之处

- 类似的问题可以扩展到更多颜色或更复杂的条件，使用类似的剪枝和优化策略。
- 可以尝试使用其他搜索算法，如广度优先搜索（BFS）或启发式搜索，进一步优化性能。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

---
处理用时：33.13秒
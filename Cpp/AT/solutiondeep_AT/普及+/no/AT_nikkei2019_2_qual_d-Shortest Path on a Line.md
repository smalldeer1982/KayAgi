# 题目信息

# Shortest Path on a Line

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_d

一直線上に $ N $ 個の点があり、順に $ 1 $ から $ N $ までの番号がついています。

高橋君はこれらの点を頂点として無向グラフを作ることにしました。 はじめはグラフに辺はないですが、$ M $ 回の操作によって辺を追加します。 $ i $ 回目の操作では次のように辺を追加します。

- $ 1 $ 以上 $ N $ 以下の整数 $ L_i $, $ R_i $ 及び正整数 $ C_i $ を用いる。 $ L_i\ ≦\ s\ <\ t\ ≦\ R_i $ なる整数の組 $ (s,t) $ すべてに対し、頂点 $ s $ と頂点 $ t $ の間に長さ $ C_i $ の辺を追加する。

ただし、$ L_1,...,L_M $, $ R_1,...,R_M $, $ C_1,...,C_M $ はすべて入力で与えられます。

高橋君は最終的に得られたグラフ上で最短路問題を解きたいです。得られたグラフ上での頂点 $ 1 $ から頂点 $ N $ までの最短路の長さを求めてください。

## 说明/提示

### 制約

- $ 2\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ M\ ≦\ 10^5 $
- $ 1\ ≦\ L_i\ <\ R_i\ ≦\ N $
- $ 1\ ≦\ C_i\ ≦\ 10^9 $

### Sample Explanation 1

頂点 $ 1 $ と頂点 $ 2 $ の間に長さ $ 2 $ の辺があり、頂点 $ 2 $ と頂点 $ 4 $ の間に長さ $ 3 $ の辺があるので、頂点 $ 1 $ と頂点 $ 4 $ の間に長さ $ 5 $ のパスが存在します。

## 样例 #1

### 输入

```
4 3

1 3 2

2 4 3

1 4 6```

### 输出

```
5```

## 样例 #2

### 输入

```
4 2

1 2 1

3 4 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 7

1 5 18

3 4 8

1 3 5

4 7 10

5 9 8

6 10 5

8 10 3```

### 输出

```
28```

# AI分析结果

### 题目内容重写

#### 题目描述

一直线上有 $N$ 个点，依次编号为 $1$ 到 $N$。高桥君将这些点作为顶点构建一个无向图。初始时图中没有边，但通过 $M$ 次操作添加边。第 $i$ 次操作如下：

- 使用三个整数 $L_i$, $R_i$ 和正整数 $C_i$，对于所有满足 $L_i \leq s < t \leq R_i$ 的整数对 $(s,t)$，在顶点 $s$ 和顶点 $t$ 之间添加一条长度为 $C_i$ 的边。

最终，高桥君希望在得到的图上求解最短路问题，即求顶点 $1$ 到顶点 $N$ 的最短路径长度。

#### 说明/提示

##### 约束条件

- $2 \leq N \leq 10^5$
- $1 \leq M \leq 10^5$
- $1 \leq L_i < R_i \leq N$
- $1 \leq C_i \leq 10^9$

##### 样例解释

**样例 1**

顶点 $1$ 和顶点 $2$ 之间有一条长度为 $2$ 的边，顶点 $2$ 和顶点 $4$ 之间有一条长度为 $3$ 的边，因此顶点 $1$ 和顶点 $4$ 之间存在一条长度为 $5$ 的路径。

**样例 2**

顶点 $1$ 和顶点 $2$ 之间有一条长度为 $1$ 的边，顶点 $3$ 和顶点 $4$ 之间有一条长度为 $2$ 的边，因此顶点 $1$ 和顶点 $4$ 之间没有路径。

**样例 3**

顶点 $1$ 到顶点 $10$ 的最短路径长度为 $28$。

### 算法分类

最短路

### 题解分析与结论

#### 题解对比与总结

1. **zjc5 的题解**（4星）
   - **关键亮点**：通过添加 $0$ 权边来优化建图，减少了边的数量，从而降低了最短路算法的时间复杂度。
   - **代码实现**：使用堆优化的 Dijkstra 算法，时间复杂度为 $O((N+M)\log N)$。
   - **个人心得**：通过添加 $0$ 权边，将区间内的点连接到区间的边界点，从而减少了边的数量。

2. **Rem_CandleFire 的题解**（3星）
   - **关键亮点**：使用线段树优化 DP，避免了直接建图，时间复杂度为 $O(N\log N)$。
   - **代码实现**：通过线段树维护区间最小值，实现了 DP 的优化。
   - **个人心得**：通过线段树优化 DP，避免了直接建图的高复杂度。

3. **lunjiahao 的题解**（3星）
   - **关键亮点**：同样使用线段树优化 DP，但排序方式不同，时间复杂度为 $O(N\log N)$。
   - **代码实现**：通过线段树维护区间最小值，实现了 DP 的优化。
   - **个人心得**：通过线段树优化 DP，避免了直接建图的高复杂度。

#### 最优关键思路

通过添加 $0$ 权边，将区间内的点连接到区间的边界点，从而减少了边的数量，优化了最短路算法的时间复杂度。

#### 可拓展之处

类似的问题可以通过添加辅助边或使用数据结构（如线段树）来优化建图或 DP 过程。例如，在处理区间操作时，线段树或差分数组是常用的优化手段。

### 推荐题目

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

### 个人心得摘录

- **zjc5**：通过添加 $0$ 权边，将区间内的点连接到区间的边界点，从而减少了边的数量。
- **Rem_CandleFire**：通过线段树优化 DP，避免了直接建图的高复杂度。
- **lunjiahao**：通过线段树优化 DP，避免了直接建图的高复杂度。

### 核心代码片段

```cpp
void add(int x,int y,int z){
    e[++tot]=y;
    l[tot]=z;
    ne[tot]=head[x];
    head[x]=tot;
}

int Dijkstra(){
    memset(dis,0x3f,sizeof(dis));
    dis[1]=0;
    priority_queue<pii, vector<pii>, greater<pii> >q;
    q.push({0,1});
    while(q.size()){
        auto t=q.top();
        int a=t.first,b=t.second;
        q.pop();
        if(st[b]) continue;
        st[b]=true;
        for(int i=head[b];i;i=ne[i]){
            v=e[i];
            if(a+l[i]<dis[v]) {
                dis[v]=a+l[i];
                q.push({dis[v],v});
            }
        }
    }
    if(dis[n]==dis[0]) return -1;
    return dis[n];
}
```

这段代码实现了堆优化的 Dijkstra 算法，通过添加 $0$ 权边来优化建图，从而减少了边的数量，降低了算法的时间复杂度。

---
处理用时：34.39秒
# 题目信息

# Restore the Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_d

$ N $ 頂点の根付き木 (注記を参照) があり、その頂点には $ 1 $ から $ N $ までの番号が振られています。 根以外の各頂点には、その親から一本の有向辺が伸びています。 なお、根は頂点 $ 1 $ とは限りません。

高橋くんは、このグラフに $ M $ 本の新たな有向辺を書き加えました。 書き足された各辺 $ u\ \rightarrow\ v $ は、ある頂点 $ u $ からその子孫であるような頂点 $ v $ に向かって伸びています。

高橋くんが辺を書き加えたあとの $ N $ 頂点 $ N-1+M $ 辺の有向グラフが与えられます。 より具体的には、$ N-1+M $ 組の整数のペア $ (A_1,\ B_1),\ ...,\ (A_{N-1+M},\ B_{N-1+M}) $ が与えられ、これらは $ i $ 番目の辺が頂点 $ A_i $ から頂点 $ B_i $ に向かって伸びていることを表します。

元の根付き木を復元してください。

## 说明/提示

### 注記

「木」や関連するグラフ理論の用語に関しては、[Wikipediaの記事](https://ja.wikipedia.org/wiki/%E6%9C%A8_(%E6%95%B0%E5%AD%A6))などをご覧ください。

### 制約

- $ 3\ \leq\ N $
- $ 1\ \leq\ M $
- $ N\ +\ M\ \leq\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N $
- $ A_i\ \neq\ B_i $
- $ i\ \neq\ j $ ならば $ (A_i,\ B_i)\ \neq\ (A_j,\ B_j) $
- 入力されるグラフは、$ N $ 頂点の根付き木に問題文中の条件を満たす $ M $ 本の辺を書き足すことで得られる。

### Sample Explanation 1

入力されたグラフは次のようなものです。 !\[\](https://img.atcoder.jp/nikkei2019-qual/ee05880ceecf703f656dd50bf22c573f.png) これは、$ 1\ \rightarrow\ 2\ \rightarrow\ 3 $ という根付き木に辺 $ 1\ \rightarrow\ 3 $ を書き足したものであると考えられます。

## 样例 #1

### 输入

```
3 1

1 2

1 3

2 3```

### 输出

```
0

1

2```

## 样例 #2

### 输入

```
6 3

2 1

2 3

4 1

4 2

6 1

2 6

4 6

6 5```

### 输出

```
6

4

2

0

6

2```

# AI分析结果

### 题目内容
#### 恢复树

**题目描述**

给定一个包含 $N$ 个节点的有根树（根节点不一定是节点 $1$），每个节点编号从 $1$ 到 $N$。除了根节点外，每个节点都有一个父节点，并且从父节点到该节点有一条有向边。高桥同学在这个树上添加了 $M$ 条新的有向边，每条新边从一个节点 $u$ 指向其某个后代节点 $v$。现在给定这个包含 $N$ 个节点和 $N-1+M$ 条边的有向图，要求恢复出原来的树结构，即输出每个节点的父节点，根节点输出 $0$。

**输入格式**

第一行包含两个整数 $N$ 和 $M$，表示节点数和新增的边数。接下来 $N-1+M$ 行，每行包含两个整数 $A_i$ 和 $B_i$，表示一条从 $A_i$ 指向 $B_i$ 的有向边。

**输出格式**

输出 $N$ 行，每行一个整数，表示每个节点的父节点，根节点输出 $0$。

**样例输入 1**

```
3 1
1 2
1 3
2 3
```

**样例输出 1**

```
0
1
2
```

**样例输入 2**

```
6 3
2 1
2 3
4 1
4 2
6 1
2 6
4 6
6 5
```

**样例输出 2**

```
6
4
2
0
6
2
```

### 算法分类
图论

### 题解分析与结论
本题的核心是通过给定的有向图恢复出原始的树结构。所有题解都基于拓扑排序的思想，通过找到根节点（入度为0的节点），然后按照拓扑顺序确定每个节点的父节点。

### 所选题解
1. **作者：igAC (5星)**
   - **关键亮点**：思路清晰，代码简洁，通过拓扑排序直接确定每个节点的父节点。
   - **代码核心**：使用拓扑排序，从根节点开始遍历，记录每个节点的父节点。
   - **核心代码**：
     ```cpp
     void topo(){
         queue<int>q;
         for(int i=1;i<=n;++i){
             if(!in[i]){
                 q.push(i);
                 fa[i]=0;
             }
         }
         while(!q.empty()){
             int x=q.front();q.pop();
             for(int i=head[x];i;i=e[i].nxt){
                 int y=e[i].to;
                 if(!(--in[y])){
                     q.push(y);
                     fa[y]=x;
                 }
             }
         }
     }
     ```

2. **作者：Heldivis (4星)**
   - **关键亮点**：通过深度计算和拓扑排序结合，确定每个节点的父节点。
   - **代码核心**：在拓扑排序过程中记录每个节点的父节点。
   - **核心代码**：
     ```cpp
     while (q.size()) {
         int x = q.front(); q.pop();
         for (const int &y : e[x])
             if (!--deg[y]) p[y] = x, q.push(y);
     }
     ```

3. **作者：_Flame_ (4星)**
   - **关键亮点**：通过拓扑排序从根节点开始遍历，确定每个节点的父节点。
   - **代码核心**：在拓扑排序过程中记录每个节点的父节点。
   - **核心代码**：
     ```cpp
     while (!q.empty()) {
         int x = q.front(); q.pop();
         for (int y : e[x]) {
             if (!--deg[y]) {
                 fa[y] = x;
                 q.push(y);
             }
         }
     }
     ```

### 最优关键思路
通过拓扑排序确定每个节点的父节点，根节点是唯一入度为0的节点，拓扑排序过程中最后一个访问的节点即为当前节点的父节点。

### 可拓展之处
类似的问题可以通过拓扑排序解决，如确定DAG的拓扑序、判断图中是否存在环等。

### 推荐题目
1. [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)
2. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)
3. [P1113 杂务](https://www.luogu.com.cn/problem/P1113)

---
处理用时：29.61秒
# 题目信息

# Broken Skateboard

## 题目描述

编码员 E869120 正在考虑去溜冰场，溜冰场的大小为 $H \times W$ 。左上角单元格为 $(1,1)$ ，右下角单元格为 $(H,W)$ 。  
溜冰场由 $1$ 个球门单元格、一些冰单元格和一些混凝土单元格组成。

溜冰场的特征如下：

- 滑冰者在冰格上移动时方向一致。
- 滑冰者只有在停止时才能改变方向。
- 如果滑冰者滑到了球门单元，他/她就完成了比赛。但是，如果滑冰者来到滑冰场外，则无法完成游戏。

此外，他的滑板坏了，因此移动速度会发生如下变化：

- 移动一个格子需要 $k$ 秒。最初， $k$ 为 $1$ 。
- 如果滑板滑到水泥格上， $k$ 将增加 $1$ 。
- 他只能向 4 个方向移动：上、下、左、右。

他想知道每个起始格完成游戏所需的最短时间。  
请写出代替 E869120 的程序。

## 说明/提示

- $1 \leq H \leq 777$ .
- $1 \leq W \leq 777$ .
- 具体单元的数量不超过 $7 \ 777$ 。
- 目标单元的数量正好是 $1$ 。

## 样例 #1

### 输入

```
6 6

......

.#....

......

......

......

...#.G```

### 输出

```
-1 -1 -1 9 -1 5

-1 -1 -1 8 -1 4

-1 -1 -1 7 -1 3

-1 -1 -1 6 -1 2

-1 -1 -1 5 -1 1

7 6 5 2 1 0```

## 样例 #2

### 输入

```
1 8

#####G##```

### 输出

```
15 10 6 3 1 0 1 3```

## 样例 #3

### 输入

```
9 9

....#..#.

#........

....#....

.#......#

...###...

##....#.#

....#...#

#....#...

.#.#..#.G```

### 输出

```
54 37 52 29 38 38 17 53 18

43 36 60 28 37 37 16 65 17

40 35 38 27 26 36 15 39 16

35 22 21 20 19 18 14 16 10

28 27 26 16 16 25 13 36 9

28 17 16 15 14 13 7 9 5

18 17 16 14 8 7 6 5 2

41 22 52 13 15 37 5 51 1

22 14 13 7 6 5 2 1 0```

# AI分析结果

### 题目重写
# 损坏的滑板

## 题目描述

编码员 E869120 正在考虑去溜冰场，溜冰场的大小为 $H \times W$ 。左上角单元格为 $(1,1)$ ，右下角单元格为 $(H,W)$ 。  
溜冰场由 $1$ 个球门单元格、一些冰单元格和一些混凝土单元格组成。

溜冰场的特征如下：

- 滑冰者在冰格上移动时方向一致。
- 滑冰者只有在停止时才能改变方向。
- 如果滑冰者滑到了球门单元，他/她就完成了比赛。但是，如果滑冰者来到滑冰场外，则无法完成游戏。

此外，他的滑板坏了，因此移动速度会发生如下变化：

- 移动一个格子需要 $k$ 秒。最初， $k$ 为 $1$ 。
- 如果滑板滑到水泥格上， $k$ 将增加 $1$ 。
- 他只能向 4 个方向移动：上、下、左、右。

他想知道每个起始格完成游戏所需的最短时间。  
请写出代替 E869120 的程序。

## 说明/提示

- $1 \leq H \leq 777$ .
- $1 \leq W \leq 777$ .
- 具体单元的数量不超过 $7 \ 777$ 。
- 目标单元的数量正好是 $1$ 。

### 算法分类
搜索、广度优先搜索 BFS

### 题解分析与结论
题目要求计算每个起始点到终点的最短时间，涉及到滑冰者在冰格上移动的特殊规则以及滑板损坏导致的移动速度变化。题解中主要采用了广度优先搜索（BFS）的方法，从终点开始反向搜索，记录每个点的最短时间，并处理水泥格对移动速度的影响。

### 所选题解
#### 题解1：COsm0s (赞：0)
**星级：4星**
**关键亮点：**
- 从终点开始反向搜索，简化了问题。
- 通过记录当前点到终点的边数，处理水泥格对移动速度的影响。
- 使用 BFS 进行搜索，确保找到最短路径。

**核心代码：**
```cpp
struct State {
  int x, y, d;
  int c;
  int w;
};
void Solve() {
  int H, W;
  cin >> H >> W;
  int gx, gy;
  for (int i = 0; i < H; i++) {
    cin >> S[i];
    for (int j = 0; j < W; j++) {
      if (S[i][j] == 'G') {
        gx = i;
        gy = j;
      }
    }
  }
  queue<State> qu;
  State cur;
  cur.x = gx;
  cur.y = gy;
  cur.c = 0;
  cur.w = 0;
  for (int k = 0; k < 4; k++) {
    cur.d = k;
    qu.push(cur);
  }
  State ne;
  while (qu.size()) {
    cur = qu.front();
    qu.pop();
    if (cur.x < 0 || cur.x >= H || cur.y < 0 || cur.y >= W) continue;
    if (len[cur.x][cur.y][cur.d] > cur.w) {
      len[cur.x][cur.y][cur.d] = cur.w;
      if (S[cur.x][cur.y] != '#') {
        ne.x = cur.x + dx[cur.d];
        ne.y = cur.y + dy[cur.d];
        ne.d = cur.d;
        ne.w = cur.w + 1;
        ne.c = cur.c + 1;
        qu.push(ne);
      } else {
        for (int k = 0; k < 4; k++)
          len[cur.x][cur.y][k] = min(len[cur.x][cur.y][k], cur.w);
        ne.w = cur.w + cur.c + 1;
        ne.c = cur.c + 1;
        for (int k = 0; k < 4; k++) {
          if ((k + cur.d != 3)) {
            ne.x = cur.x + dx[k];
            ne.y = cur.y + dy[k];
            ne.d = k;
            qu.push(ne);
          }
        }
      }
    }
  }
}
```

### 最优关键思路或技巧
- 从终点开始反向搜索，简化了路径计算。
- 通过记录当前点到终点的边数，处理水泥格对移动速度的影响。
- 使用 BFS 确保找到最短路径。

### 可拓展之处
类似的问题可以扩展到其他需要计算最短路径的场景，如迷宫问题、图的最短路径问题等。

### 推荐题目
1. P1141 01迷宫
2. P1162 填涂颜色
3. P1443 马的遍历

---
处理用时：31.20秒
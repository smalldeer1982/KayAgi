# 题目信息

# Ordinary Beauty

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-qual/tasks/soundhound2018_summer_qual_c

数列 $ (a_1,...\ ,a_n) $ の *美しさ* を、隣り合う $ 2 $ 項の組であって、 差の絶対値が $ d $ であるものの個数として定義します。 例えば、$ d=1 $ であるとき、数列 $ (3,\ 2,\ 3,\ 10,\ 9) $ の美しさは $ 3 $ です。

各要素が $ 1 $ 以上 $ n $ 以下の整数である長さ $ m $ の数列は全部で $ n^m $ 通り存在します。 この $ n^m $ 通りの数列すべてに対して美しさを求めて、 それらの平均を出力してください。

## 说明/提示

### 制約

- $ 0\ \leq\ d\ <\ n\ \leq\ 10^9 $
- $ 2\ \leq\ m\ \leq\ 10^9 $
- 入力はすべて整数

### Sample Explanation 1

$ (1,1,1) $ の美しさは $ 0 $ です。 $ (1,1,2) $ の美しさは $ 1 $ です。 $ (1,2,1) $ の美しさは $ 2 $ です。 $ (1,2,2) $ の美しさは $ 1 $ です。 $ (2,1,1) $ の美しさは $ 1 $ です。 $ (2,1,2) $ の美しさは $ 2 $ です。 $ (2,2,1) $ の美しさは $ 1 $ です。 $ (2,2,2) $ の美しさは $ 0 $ です。 これらの平均である、 $ (0+1+2+1+1+2+1+0)/8=1 $ が答えとなります。

## 样例 #1

### 输入

```
2 3 1```

### 输出

```
1.0000000000```

## 样例 #2

### 输入

```
1000000000 180707 0```

### 输出

```
0.0001807060```

# AI分析结果

### 题目内容重写

#### 题目描述

数列 $(a_1, a_2, \dots, a_n)$ 的**美しさ**（美丽度）定义为相邻两项的组中，差值的绝对值为 $d$ 的组数。例如，当 $d=1$ 时，数列 $(3, 2, 3, 10, 9)$ 的美丽度为 $3$。

每个元素为 $1$ 到 $n$ 之间的整数，长度为 $m$ 的数列共有 $n^m$ 种可能。求这 $n^m$ 种数列的美丽度的平均值。

#### 说明/提示

##### 约束条件

- $0 \leq d < n \leq 10^9$
- $2 \leq m \leq 10^9$
- 输入均为整数

##### 样例解释 1

对于输入 `2 3 1`，输出为 `1.0000000000`。

##### 样例解释 2

对于输入 `1000000000 180707 0`，输出为 `0.0001807060`。

### 算法分类

概率论

### 题解分析与结论

#### 题解对比与总结

1. **共同点**：
   - 所有题解都基于概率论，通过计算相邻两个数差值为 $d$ 的概率，再乘以相邻对数 $m-1$ 来得到期望值。
   - 都考虑了 $d=0$ 的特殊情况，此时概率为 $\frac{1}{n}$，否则概率为 $\frac{2(n-d)}{n^2}$。

2. **不同点**：
   - **_H17_** 的题解通过公式推导详细解释了 $d=0$ 和 $d \neq 0$ 的情况，并提供了两个版本的代码实现，代码可读性较好。
   - **Orange1015** 的题解同样详细推导了公式，并提供了代码实现，代码简洁且使用了 `fixed` 和 `setprecision` 来控制输出精度。
   - **Crazyouth** 的题解思路清晰，代码简洁，直接根据 $d$ 的值进行分类计算。
   - **Register_int** 的题解详细解释了每个步骤的逻辑，推导过程清晰，代码实现简洁。

3. **难点**：
   - 主要难点在于理解期望的计算方法，特别是 $d=0$ 时的特殊情况处理。
   - 代码实现中需要注意浮点数精度问题，确保输出格式正确。

#### 评分较高的题解

1. **_H17_ (4星)**
   - **关键亮点**：详细推导了公式，提供了两个版本的代码实现，代码可读性较好。
   - **代码实现**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     int n,m,d;
     int main(){
         cin>>n>>m>>d;
         double ans=2.0*(n-d)*(m-1)/(1.0*n*n);
         if(!d)
             ans/=2;
         printf("%.10lf",ans);
         return 0;
     }
     ```

2. **Orange1015 (4星)**
   - **关键亮点**：详细推导了公式，代码简洁且使用了 `fixed` 和 `setprecision` 来控制输出精度。
   - **代码实现**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     #define int long long
     int n,m,d;
     signed main(){
         std::ios::sync_with_stdio(false);
         cin.tie(0);
         cout.tie(0);
         cin >> n >> m >> d;
         if(d==0){
             cout << fixed << setprecision(10) << (m-1.0)/n;
         }
         else{
             cout << fixed << setprecision(10) << 2.0*(m-1.0)*(n-d)/(n*n);
         }
         return 0;
     }
     ```

3. **Crazyouth (4星)**
   - **关键亮点**：思路清晰，代码简洁，直接根据 $d$ 的值进行分类计算。
   - **代码实现**：
     ```cpp
     #include <bits/stdc++.h>
     using namespace std;
     int main()
     {
         long double n,m,d;
         cin>>n>>m>>d;
         if(!d) cout<<fixed<<setprecision(7)<<(m-1.0l)/n; 
         else cout<<fixed<<setprecision(7)<<2.0l*(n-d)*(m-1.0l)/n/n;
         return 0;
     }
     ```

#### 最优关键思路或技巧

- **期望计算**：通过计算相邻两个数差值为 $d$ 的概率，再乘以相邻对数 $m-1$ 来得到期望值。
- **特殊情况处理**：$d=0$ 时的概率为 $\frac{1}{n}$，否则概率为 $\frac{2(n-d)}{n^2}$。
- **精度控制**：使用 `fixed` 和 `setprecision` 来控制输出精度。

#### 可拓展之处

- 类似题目可以考察其他概率期望问题，如随机变量的期望值计算、条件概率等。
- 可以进一步扩展到多维情况，如二维数组中的相邻元素差值问题。

#### 推荐题目

1. [P3802 小魔女帕琪](https://www.luogu.com.cn/problem/P3802)
2. [P1297 [国家集训队]单选错位](https://www.luogu.com.cn/problem/P1297)
3. [P1654 OSU!](https://www.luogu.com.cn/problem/P1654)

#### 个人心得摘录

- **_H17_**：在推导公式时，发现 $d=0$ 时需要特殊处理，否则会导致结果错误。
- **Orange1015**：通过 `fixed` 和 `setprecision` 控制输出精度，避免了浮点数精度问题。
- **Crazyouth**：直接根据 $d$ 的值进行分类计算，代码简洁且易于理解。

---
处理用时：39.27秒
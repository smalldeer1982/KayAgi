# 题目信息

# 天下一後入れ先出しデータ構造

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tenka1-2013-qualb/tasks/tenka1_2013_qualB_b

 スタックは最も基本的なデータ構造の1つであり、データを後入れ先出し (Last In First Out) の構造で保持するものである。スタックは最初は空で、要素の追加と取り出しができるが、取り出しは追加されたのが遅い順に行われる。

 ある日、天下一株式会社に務めるユウヤ君は、スタックになりきるという仕事を言い渡された。唖然とするユウヤ君を心配するあなたは、以下の形式の入力で与えられる命令の列をユウヤ君の代わりに処理して、後述のような出力を行うプログラムを作成することにした。

- - - - - -

 入力は以下の形式で標準入力から与えられる。

> $ Q $ $ L $ $ query_1 $ $ query_2 $ $ ... $ $ query_Q $

- $ 1 $ 行目は、与えられる命令の数 $ Q $ ($ 1\ \leq\ Q\ \leq\ 10^5 $) と スタックのサイズ $ L $ ($ 1\ \leq\ L\ \leq\ 2147483647 $) が空白区切りで与えられる。
- $ 2 $ 行目から $ Q+1 $ 行目までの $ Q $ 行は、$ i $ ($ 1\ \leq\ i\ \leq\ Q $) 番目の 命令が与えられる。

 各命令は、以下 $ 4 $ 種類のうちいずれかに該当する。

1. Push $ N $ $ M $

- スタックに要素 $ M $ を $ N $ 個追加する。出力は行わない。

10. Pop $ N $
- スタックから要素を $ N $ 個取り出す。出力は行わない。

12. Top
- スタックの先頭要素を $ 1 $ 行で出力する。この命令でスタックを構成する要素は変更されない。

14. Size
- スタックの要素数を $ 1 $ 行で出力する。

$ N $, $ M $ はそれぞれ整数で、 $ 1\ \leq\ N\ \leq\ 10^5 $, $ -2^{20}\ \leq\ M\ \leq\ 2^{20} $ をみたす。

ただし、スタックの先頭要素とは、スタックの要素のうちで最後に追加されたものであり、もしそのときPop $ 1 $を行ったとすると取り出される要素である。

- $ Q\ \leq\ 50 $, $ N\ \leq\ 50 $ の入力に正解すると、$ 60 $ 点満点に対して部分点として、$ 30 $ 点が与えられる。

 上記のとおり、与えられた命令を順番に処理していき、Top、またはSizeの入力が与えられた際に出力を行う。

 ただし、以下の $ 3 $ つの場合、スタックは例外を投げて止まってしまう。

- Push $ N $ $ M $ を要素数が $ L-N $ より大きいスタックに対して行った場合
- Pop $ N $を要素数が $ N $ 未満のスタックに対して行った場合
- Top を空のスタックに対して行った場合

 スタックが投げる例外は以下の通りである。

- Push による例外でプログラムが終了した場合は `FULL`
- Pop または Top による例外でプログラムが終了した場合は `EMPTY`

 これらの例外は $ 1 $ 行で出力され、例外を投げた後のスタックはそれ以降の命令を放棄する。  
 スタックは最後まで正常に命令を処理できた場合、 `SAFE` を $ 1 $ 行で出力して終了する。

 ```

7 20
Push 2 3
Push 4 5
Top
Size
Pop 5
Top
Size
```

 ```

5
6
3
1
SAFE
```

 ```

1 10
Push 40 40
```

 ```

FULL
```

 ```

5 10
Push 1 2
Top
Pop 1
Top
Size
```

 ```

2
EMPTY
```

 ```

4 10
Top
Size
Push 1 1
Top
```

 ```

EMPTY
```

# AI分析结果

### 题目内容重写

**天下一後入れ先出しデータ構造**

**题目描述**

栈是最基本的数据结构之一，它以“后进先出”（Last In First Out）的方式存储数据。栈最初是空的，可以进行元素的添加和移除，但移除操作是按照最后添加的元素最先移除的顺序进行的。

某天，在天下一株式会社工作的ユウヤ君被要求模拟栈的操作。为了帮助ユウヤ君，你需要编写一个程序，按照给定的命令序列处理栈操作，并根据要求输出结果。

**输入格式**

输入从标准输入读取，格式如下：

> $ Q $ $ L $ $ query_1 $ $ query_2 $ $ ... $ $ query_Q $

- 第一行包含两个整数 $ Q $ ($ 1\ \leq\ Q\ \leq\ 10^5 $) 和 $ L $ ($ 1\ \leq\ L\ \leq\ 2147483647 $)，分别表示命令的数量和栈的大小。
- 接下来的 $ Q $ 行，每行包含一个命令。

**命令类型**

1. **Push $ N $ $ M $**
   - 将 $ M $ 元素 $ N $ 次压入栈中。不输出任何内容。

2. **Pop $ N $**
   - 从栈中移除 $ N $ 个元素。不输出任何内容。

3. **Top**
   - 输出栈顶元素。栈的内容不变。

4. **Size**
   - 输出栈中当前元素的数量。

**异常处理**

在以下情况下，栈会抛出异常并停止执行后续命令：

- **Push $ N $ $ M $**：如果栈的大小超过 $ L-N $，抛出 `FULL` 异常。
- **Pop $ N $**：如果栈中的元素数量小于 $ N $，抛出 `EMPTY` 异常。
- **Top**：如果栈为空，抛出 `EMPTY` 异常。

**输出**

对于每个 `Top` 或 `Size` 命令，输出相应的结果。如果栈抛出异常，输出 `FULL` 或 `EMPTY`。如果所有命令都成功执行，输出 `SAFE`。

**示例**

```
7 20
Push 2 3
Push 4 5
Top
Size
Pop 5
Top
Size
```

```
5
6
3
1
SAFE
```

```
1 10
Push 40 40
```

```
FULL
```

```
5 10
Push 1 2
Top
Pop 1
Top
Size
```

```
2
EMPTY
```

```
4 10
Top
Size
Push 1 1
Top
```

```
EMPTY
```

### 算法分类

**模拟**

### 题解分析与结论

该题的核心是模拟栈的操作，并处理可能的异常情况。由于栈的大小和命令数量都可能非常大，因此需要高效的实现。

**题解1：fourGS**

**星级：4**

**关键亮点：**
- 使用两个数组 `st` 和 `num` 分别存储栈中的元素和每个元素的数量，避免了逐个处理元素的低效操作。
- 使用 `depth` 变量记录栈的深度，`size` 变量记录栈中元素的总数，简化了栈的管理。
- 在处理 `Pop` 命令时，通过减少 `num` 数组中的值来模拟移除元素，避免了频繁的内存操作。

**核心代码片段：**

```c
if(query == "Push"){
    if(size + N > L){ fin = 2; continue; }
    st[depth] = M;
    num[depth] = N;
    size += N;
    depth++;
} else if(query == "Pop"){
    if(size < N){ fin = 1; continue; }
    size -= N;
    while(N && num[depth-1] <= N){
        N -= num[depth-1];
        depth--;
    }
    if(N) num[depth-1] -= N;
} else if(query == "Top"){
    if(size==0){ fin=1; continue; }
    printf("%d\n",st[depth-1]);
} else if(query == "Size"){
    printf("%d\n", size);
}
```

**总结：**

该题解通过优化栈的存储和操作方式，有效地处理了大规模数据的问题。使用 `st` 和 `num` 数组来管理栈的元素和数量，避免了逐个处理元素的低效操作，提高了程序的执行效率。

### 拓展思路

该题的解法可以推广到其他需要高效管理大量数据的场景，例如队列、优先队列等。在处理类似问题时，可以考虑使用类似的数据结构优化方法，减少内存操作，提高程序性能。

### 推荐题目

1. [洛谷 P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)
2. [洛谷 P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [洛谷 P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)

这些题目都涉及到栈的使用和模拟操作，适合进一步练习和巩固相关知识。

---
处理用时：34.42秒
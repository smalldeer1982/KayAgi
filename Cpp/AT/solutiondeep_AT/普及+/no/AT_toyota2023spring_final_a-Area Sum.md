# 题目信息

# Area Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/toyota2023spring-final/tasks/toyota2023spring_final_a

$ N $ 行 $ M $ 列からなる盤面があり，各マス目には row-major 順に $ 1 $ から $ N\ \times\ M $ までの整数が書かれています． つまり，上から $ i $ 行目，左から $ j $ 列目のマスに書かれている整数を $ A_{i,j} $ で表すことにすると， $ A_{i,j}=(i-1)\ \times\ M\ +\ j $ です．

この盤面の部分長方形であって，その内部に書かれた値の総和がちょうど $ V $ になるものの個数を数えてください．

より厳密に言えば，整数の $ 4 $ つ組 $ (a,b,c,d) $ ($ 1\ \leq\ a\ \leq\ b\ \leq\ N $, $ 1\ \leq\ c\ \leq\ d\ \leq\ M $) であって，$ \sum_{a\ \leq\ i\ \leq\ b,\ c\ \leq\ j\ \leq\ d}\ A_{i,j}=V $ を満たすものの個数を数えてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M\ \leq\ 5000 $
- $ 1\ \leq\ V\ \leq\ 10^{15} $
- 入力される値はすべて整数である

### Sample Explanation 1

盤面には以下のように整数が書き込まれています． ``` 12 34 ``` 条件を満たす部分長方形は，$ (a,b,c,d)=(1,1,1,2),(2,2,1,1) $ の $ 2 $ つです．

## 样例 #1

### 输入

```
2 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
2 2 5```

### 输出

```
0```

## 样例 #3

### 输入

```
13 8 1032```

### 输出

```
5```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个 $N$ 行 $M$ 列的棋盘，每个格子按行优先顺序从 $1$ 到 $N \times M$ 编号。具体来说，第 $i$ 行第 $j$ 列的格子编号为 $A_{i,j} = (i-1) \times M + j$。

要求统计所有满足条件的子矩形的个数，这些子矩形的内部格子编号之和恰好等于 $V$。

更严格地说，统计所有满足条件的四元组 $(a,b,c,d)$，其中 $1 \leq a \leq b \leq N$，$1 \leq c \leq d \leq M$，且 $\sum_{a \leq i \leq b, c \leq j \leq d} A_{i,j} = V$。

#### 说明/提示

##### 约束条件

- $1 \leq N, M \leq 5000$
- $1 \leq V \leq 10^{15}$
- 输入值均为整数

##### 样例解释 1

棋盘上的数字如下：
```
1 2
3 4
```
满足条件的子矩形有两个：$(a,b,c,d)=(1,1,1,2)$ 和 $(2,2,1,1)$。

##### 样例 #1

###### 输入
```
2 2 3
```

###### 输出
```
2
```

##### 样例 #2

###### 输入
```
2 2 5
```

###### 输出
```
0
```

##### 样例 #3

###### 输入
```
13 8 1032
```

###### 输出
```
5
```

### 算法分类
二分、数学

### 题解分析与结论

该题解通过数学公式快速计算子矩阵的和，并利用二分查找来优化搜索过程。具体来说，题解首先推导出子矩阵和的公式，然后通过枚举子矩阵的长和宽，结合二分查找来确定满足条件的子矩阵的左上角坐标。为了进一步优化，题解在每次二分查找前进行范围判断，以减少不必要的计算。

### 所选题解

#### 题解作者：FFTotoro (赞：3)

##### 星级：4星

##### 关键亮点
1. **数学公式推导**：通过数学推导快速计算子矩阵的和，避免了直接遍历计算的高时间复杂度。
2. **二分查找优化**：利用二分查找在行和列两个维度上进行优化，大大减少了搜索空间。
3. **范围判断优化**：在每次二分查找前进行范围判断，进一步减少了不必要的计算，提高了效率。

##### 个人心得
题解中提到，通过范围判断优化，可以将常数大大减小，最终控制在 $1500\,\mathrm{ms}$ 内通过题目。这表明在实际编码中，优化细节对性能提升的重要性。

##### 核心代码
```cpp
function<int(int,int,int,int)> f=[&](int a,int b,int c,int d){
    return (c-a+1)*(d*(d+1)-b*(b-1)>>1)+m*(d-b+1)*(c*(c-1)-(a-1)*(a-2)>>1);
}; // 快速计算子矩阵和
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        int xl=1,xr=n-i+1;
        if(f(1,i,1,j)<=v&&v<=f(xr,n,m-j+1,m)){ // 优化，内层同理
            bool b=false;
            do{
                int xm=xl+xr>>1,yl=1,yr=m-j+1;
                int l=f(xm,1,xm+i-1,j),r=f(xm,yr,xm+i-1,yr+j-1);
                if(l<=v&&v<=r){
                    do{
                        int ym=yl+yr>>1;
                        int s=f(xm,ym,xm+i-1,ym+j-1);
                        if(s==v)b=true; // 找到解
                        if(s>v)yr=ym-1;
                        else yl=ym+1;
                    }while(yl<=yr&&!b);
                }
                if(l>v)xr=xm-1;
                else xl=xm+1;
            }while(xl<=xr&&!b); // 外层二分
            if(b)c++;
        }
    }
```

### 最优关键思路或技巧
1. **数学公式推导**：通过数学公式快速计算子矩阵的和，避免了直接遍历计算的高时间复杂度。
2. **二分查找优化**：利用二分查找在行和列两个维度上进行优化，大大减少了搜索空间。
3. **范围判断优化**：在每次二分查找前进行范围判断，进一步减少了不必要的计算，提高了效率。

### 可拓展之处
该题的思路可以拓展到其他需要快速计算子矩阵和的问题，例如在图像处理中计算某个区域的特征值，或者在数据分析中快速计算某个子集的总和。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3382 【模板】线段树 1](https://www.luogu.com.cn/problem/P3382)

---
处理用时：34.64秒
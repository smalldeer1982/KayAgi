# 题目信息

# 直径

## 题目描述

### 题目背景
鳗鱼王国有一个名为鱼鳗王国的邻国。这两个王国都有许多的大城市，这些城市之间有一些道路相连。然而现在，鳗鱼王国和鱼鳗王国之间没有互通的道路。所以，鳗鱼王国的国王殿下为了和鱼鳗王国构筑友好关系，打算在两个城市间建设一条道路，因为有很多条可以建设的道路，对运费很敏感的国王殿下想知道两两城市间最短距离的最大值。
给出顶点数 $n_1$，边数 $m_1$ 的无向图 $G_1$ 和顶点数 $n_2$，边数 $m_2$ 的无向图 $G_2$。每个图都是连通图。换句话说，对于每张图来说，任意的两个顶点间都有直接或间接的道路连接。请回答出在两张图之间任加一条边后构成的图形中，最远的两个顶点的距离（称为图形的直径）的最小值和最大值。

## 说明/提示

输入中的各变量满足以下条件。
- $1 \leq n_{1},n_{2} \leq 1000(=10^4)$
- $0 \leq m_{1},m_{2} \leq 10000(=10^5)$
- $0 \leq a_i,b_i<n_1$
- $0\leq c_i,d_i<n_2$
- 每张图为连通图
- 每张图为简单图，也就是说没有重边与自环。

对于 $50\%$ 的数据，$1\leq n_1,n_2\leq20$。

#### 样例解释
【样例解释 1】

直径为 $3$ 及直径为 $5$ 的情况见下图：

![样例解释1](https://img.atcoder.jp/other/utpc2013/C_sample_1.png)

【样例解释 2】

直径为 $7$ 及直径为 $11$ 的情况见下图：

![样例解释2](https://img.atcoder.jp/other/utpc2013/C_sample_2.png)

【样例解释 3】

请注意此处的最小值。

## 样例 #1

### 输入

```
4 5
0 1
0 2
0 3
1 2
2 3
4 5
0 1
0 2
0 3
1 2
2 3
```

### 输出

```
3 5
```

## 样例 #2

### 输入

```
6 5
0 1
1 2
2 3
3 4
4 5
6 5
0 1
1 2
2 3
3 4
4 5
```

### 输出

```
7 11
```

## 样例 #3

### 输入

```
7 6
0 1
1 2
2 3
3 4
4 5
5 6
2 1
0 1
```

### 输出

```
6 8
```

# AI分析结果

### 题目内容重写
鳗鱼王国有一个名为鱼鳗王国的邻国。这两个王国都有许多大城市，这些城市之间有一些道路相连。然而，现在鳗鱼王国和鱼鳗王国之间没有互通的道路。因此，鳗鱼王国的国王殿下为了与鱼鳗王国建立友好关系，打算在两个城市间建设一条道路。由于有很多条可以建设的道路，对运费很敏感的国王殿下想知道两两城市间最短距离的最大值。

给出顶点数 $n_1$，边数 $m_1$ 的无向图 $G_1$ 和顶点数 $n_2$，边数 $m_2$ 的无向图 $G_2$。每个图都是连通图。换句话说，对于每张图来说，任意的两个顶点间都有直接或间接的道路连接。请回答出在两张图之间任加一条边后构成的图形中，最远的两个顶点的距离（称为图形的直径）的最小值和最大值。

### 算法分类
图论、广度优先搜索 BFS

### 题解综合分析与结论
该题的核心在于计算两个连通图在添加一条边后的直径的最小值和最大值。题解主要通过 BFS 来计算每个图中每个点到其他点的最短距离，然后通过枚举所有可能的边连接方式，计算新图的直径。主要难点在于如何高效地计算每个点的最远距离，并且确保最小直径不小于原图的直径。

### 所选高分题解

#### 题解1：作者：bmyjacks (赞：10)
**星级：5星**
**关键亮点：**
1. 详细解释了直径的定义及求法，使用两遍 BFS 来求解。
2. 提出了新图直径的计算公式，并详细说明了最小直径的计算方法。
3. 代码结构清晰，注释详细，易于理解。

**个人心得：**
作者提到在求最小直径时需要注意其必须大于原图的直径，这一点在样例3中得到了验证。

**核心代码：**
```cpp
void bfs(const int from = 1) {
    queue<Edge> que;
    que.push(Edge{from, 0});
    while (!que.empty()) {
        Edge now = que.front();
        que.pop();
        for (int i = 0; i < G[now.from].size(); ++i) {
            Edge edge = G[now.from][i];
            if (dis[edge.to] > dis[edge.from] + 1) {
                dis[edge.to] = dis[edge.from] + 1;
                que.push(Edge{edge.to, 0});
            }
        }
    }
}
```

#### 题解2：作者：SfumatoCannon_ (赞：4)
**星级：4星**
**关键亮点：**
1. 通过 BFS 求解每个点的最远距离，并枚举所有可能的边连接方式。
2. 详细说明了如何计算新图的最大和最小直径。
3. 代码简洁，逻辑清晰。

**核心代码：**
```cpp
void work(int start) {
    queue<int> Q;
    for (int i = 1; i <= n; i++) dis[i] = inf;
    dis[start] = 0;
    Q.push(start);
    while (!Q.empty()) {
        int k = Q.front();
        Q.pop();
        for (int i = h[k]; i; i = bian[i].next) {
            if (dis[k] + 1 < dis[bian[i].to]) {
                dis[bian[i].to] = dis[k] + 1;
                Q.push(bian[i].to);
            }
        }
    }
}
```

#### 题解3：作者：tjtdrxxz (赞：11)
**星级：4星**
**关键亮点：**
1. 使用 BFS 预处理每个点的最远距离，并通过枚举所有可能的边连接方式计算新图的直径。
2. 代码结构清晰，注释详细，易于理解。

**核心代码：**
```cpp
int bfs(int s) {
    int ret = 0;
    q.push(s);
    vis[s] = 1;
    dis[s] = 0;
    while (!q.empty()) {
        register int u = q.front(); q.pop();
        for (int i = 0; i < e[u].size(); i++) {
            register int v = e[u][i].v;
            if (dis[v] > dis[u] + 1) {
                dis[v] = dis[u] + 1;
                ret = max(ret, dis[v]);
                q.push(e[u][i].v);
            }
        }
    }
    return ret;
}
```

### 最优关键思路或技巧
1. **两遍 BFS 求直径**：首先从任意点出发进行 BFS，找到最远的点，然后从该点再次进行 BFS，找到的直径即为图的直径。
2. **预处理每个点的最远距离**：通过 BFS 预处理每个点到其他点的最短距离，便于后续计算新图的直径。
3. **枚举所有可能的边连接方式**：通过枚举所有可能的边连接方式，计算新图的最大和最小直径。

### 可拓展之处
该题的思路可以拓展到其他图论问题中，例如在多个连通图之间添加多条边后的直径计算，或者在有向图中计算直径等。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)
3. [P1395 会议](https://www.luogu.com.cn/problem/P1395)

### 个人心得总结
在计算最小直径时，必须确保其不小于原图的直径，这一点在样例3中得到了验证。此外，使用 BFS 预处理每个点的最远距离可以大大提高计算效率。

---
处理用时：35.89秒
# 题目信息

# 潜入

## 题目描述

[problemUrl]: https://atcoder.jp/contests/zone2021/tasks/zone2021_e

$ 2 $ 次元平面があり、あなたは今いる座標 $ (1,\ 1) $ から UFO のある座標 $ (R,\ C) $ に移動したいです。  
 あなたが $ (r,\ c) $ にいるとき、あなたは以下の $ 4 $ 種類の移動を行うことができます。

- $ (r,\ c) $ から $ (r,\ c\ +\ 1) $ に移動する。$ A_{r,\ c} $ のコストがかかる。この移動は $ c\ <\ C $ のとき使える。
- $ (r,\ c) $ から $ (r,\ c\ -\ 1) $ に移動する。$ A_{r,\ c\ -\ 1} $ のコストがかかる。この移動は $ c\ >\ 1 $ のとき使える。
- $ (r,\ c) $ から $ (r\ +\ 1,\ c) $ に移動する。$ B_{r,\ c} $ のコストがかかる。この移動は $ r\ <\ R $ のとき使える。
- $ 1\ <\ =\ i\ <\ r $ を満たす整数 $ i $ を $ 1 $ つ選び、$ (r,\ c) $ から $ (r\ -\ i,\ c) $ に移動する。$ 1\ +\ i $ のコストがかかる。

$ (1,\ 1) $ から $ (R,\ C) $ に移動するために必要な最小のコストを求めてください。

## 说明/提示

### ストーリー

暗号解読を進めていると、仲間のムーアが突如 UFO に吸い込まれ、連れ去られてしまった。 ムーアは UFO との通信システムをほぼ 1 人で開発していたため、このままでは UFO と交信することができない！  
 デスマーチが横行していたブラックスタートアップ時代を思い出す。 バス係数$ {}\ =\ 1 $ のチームはいつだって脆いものだ。  
 仕方がない、UFO 内に乗り込んで直接話すしかなさそうだ。 上空を見上げると、UFO から梯子のようなものが下されている。  
 だがよく見るとボロボロで所々腐り落ちているようだ。 どうにかしてうまい登り方を考えなければ。

### 制約

- 入力は全て整数
- $ 2\ <\ =\ R,\ C\ <\ =\ 500 $
- $ 0\ <\ =\ A_{i,j}\ <\ 10^3 $
- $ 0\ <\ =\ B_{i,j}\ <\ 10^3 $

### Sample Explanation 1

以下のように移動するとコスト $ 9 $ が達成できます。 - $ (1,\ 1) $ から $ (2,\ 1) $ に移動する。コストが $ 1 $ かかる。 - $ (2,\ 1) $ から $ (3,\ 1) $ に移動する。コストが $ 1 $ かかる。 - $ (3,\ 1) $ から $ (3,\ 2) $ に移動する。コストが $ 1 $ かかる。 - $ (3,\ 2) $ から $ (1,\ 2) $ に移動する。コストが $ 3 $ かかる。 - $ (1,\ 2) $ から $ (1,\ 3) $ に移動する。コストが $ 1 $ かかる。 - $ (1,\ 3) $ から $ (2,\ 3) $ に移動する。コストが $ 1 $ かかる。 - $ (2,\ 3) $ から $ (3,\ 3) $ に移動する。コストが $ 1 $ かかる。

## 样例 #1

### 输入

```
3 3

10 1

10 10

1 10

1 10 1

1 10 1```

### 输出

```
9```

## 样例 #2

### 输入

```
7 11

42 77 94 76 40 66 43 28 66 23

27 34 41 31 83 13 64 69 81 82

23 81 0 22 39 51 4 37 84 43

62 37 82 86 26 67 45 78 85 2

79 18 72 62 68 84 69 88 19 48

0 27 21 51 71 13 87 45 39 11

74 57 32 0 97 41 87 96 17 98

69 58 76 32 51 16 38 68 86 82 64

53 47 33 7 51 75 43 14 96 86 70

80 58 12 76 94 50 59 2 1 54 25

14 14 62 28 12 43 15 70 65 44 41

56 50 50 54 53 34 16 3 2 59 88

27 85 50 79 48 86 27 81 78 78 64```

### 输出

```
498```

## 样例 #3

### 输入

```
4 4

0 0 0

0 0 0

0 0 0

0 0 0

0 0 0 0

0 0 0 0

0 0 0 0```

### 输出

```
0```

# AI分析结果

### 题目内容重写
给定一个二维平面，你从坐标 $(1, 1)$ 出发，目标是到达 UFO 所在的坐标 $(R, C)$。在位置 $(r, c)$ 时，你可以进行以下四种移动：

1. 从 $(r, c)$ 移动到 $(r, c + 1)$，花费为 $A_{r, c}$。此移动仅在 $c < C$ 时可用。
2. 从 $(r, c)$ 移动到 $(r, c - 1)$，花费为 $A_{r, c - 1}$。此移动仅在 $c > 1$ 时可用。
3. 从 $(r, c)$ 移动到 $(r + 1, c)$，花费为 $B_{r, c}$。此移动仅在 $r < R$ 时可用。
4. 选择一个整数 $i$ 满足 $1 \leq i < r$，从 $(r, c)$ 移动到 $(r - i, c)$，花费为 $1 + i$。

求从 $(1, 1)$ 到 $(R, C)$ 的最小花费。

### 算法分类
最短路

### 题解分析与结论
该题目要求从起点到终点的最小花费，属于典型的最短路问题。题解中大多数采用了 Dijkstra 算法，并结合优先队列进行优化。部分题解还通过分层图的思想，将第四种操作转化为更易处理的形式，从而降低了时间复杂度。

### 评分较高的题解

#### 1. 作者：Nightsky_Stars (5星)
**关键亮点**：
- 使用优先队列优化的 Dijkstra 算法，直接处理四种移动方式。
- 通过剪枝优化，提前返回结果，减少不必要的计算。

**核心代码**：
```cpp
void bfs(int x, int y) {
    memset(d, 0x3f3f3f3f, sizeof(d));
    q.push(make_pair(0, make_pair(x, y)));
    d[x][y] = 0;
    while (!q.empty()) {
        int tx = q.top().second.first, ty = q.top().second.second;
        q.pop();
        if (tx == r && ty == c) return; // 剪枝
        if (vis[tx][ty]) continue;
        vis[tx][ty] = 1;
        // 处理四种移动方式
        if (ty < c && d[tx][ty + 1] > d[tx][ty] + a[tx][ty]) {
            d[tx][ty + 1] = d[tx][ty] + a[tx][ty];
            q.push(make_pair(-d[tx][ty + 1], make_pair(tx, ty + 1)));
        }
        // 其他移动方式类似
    }
}
```

#### 2. 作者：lovely_codingcow (4星)
**关键亮点**：
- 通过分层图的思想，将第四种操作转化为更易处理的形式。
- 使用优先队列优化的 Dijkstra 算法，代码结构清晰。

**核心代码**：
```cpp
void bfs(int x, int y) {
    memset(dis, 63, sizeof dis);
    pq.push({0, {x, y}});
    dis[x][y] = 0;
    while (!pq.empty()) {
        int fx = pq.top().second.first, fy = pq.top().second.second;
        pq.pop();
        if (fx == r && fy == c) return; // 剪枝
        if (vis[fx][fy]) continue;
        vis[fx][fy] = true;
        // 处理四种移动方式
        if (fy < c && dis[fx][fy + 1] > dis[fx][fy] + a[fx][fy]) {
            dis[fx][fy + 1] = dis[fx][fy] + a[fx][fy];
            pq.push({-dis[fx][fy + 1], {fx, fy + 1}});
        }
        // 其他移动方式类似
    }
}
```

#### 3. 作者：_WHITE_NIGHT_ (4星)
**关键亮点**：
- 将第四种操作转化为每次移动一格，简化了处理逻辑。
- 使用优先队列优化的 Dijkstra 算法，代码简洁明了。

**核心代码**：
```cpp
void Record(int x, int y, int sum) {
    if (x < 1 || x > n || y < 1 || y > m || sum >= dist[x][y]) return;
    dist[x][y] = sum, heap.push({x, y, sum});
}

int main() {
    // 初始化
    Record(1, 1, 0);
    while (!heap.empty()) {
        Node q = heap.top();
        heap.pop();
        if (vis[q.x][q.y]) continue;
        if (q.x == n && q.y == m) break; // 剪枝
        vis[q.x][q.y] = 1;
        // 处理四种移动方式
        Record(q.x, q.y + 1, q.sum + a[q.x][q.y]);
        // 其他移动方式类似
    }
    cout << dist[n][m];
    return 0;
}
```

### 最优关键思路
1. **优先队列优化 Dijkstra**：通过优先队列处理最小花费，确保每次扩展的节点都是当前花费最小的。
2. **剪枝优化**：在找到目标节点后立即返回，减少不必要的计算。
3. **分层图思想**：将第四种操作转化为更易处理的形式，降低时间复杂度。

### 可拓展之处
该题的最短路问题可以扩展到其他类似的网格图问题，如迷宫问题、路径规划等。类似的算法优化思路也可以应用于其他需要处理多种移动方式的最短路问题。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

---
处理用时：40.72秒
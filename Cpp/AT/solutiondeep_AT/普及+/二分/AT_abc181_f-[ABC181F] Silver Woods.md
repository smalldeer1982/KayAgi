# 题目信息

# [ABC181F] Silver Woods

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc181/tasks/abc181_f

$ xy $ 平面上に $ 2 $ 直線 $ y=-100,\ y=100 $ で囲まれた通路があります。

この通路の中の $ -100\ <\ x\ <\ 100 $ の部分に $ N $ 本の大きさの無視できる釘が打たれており、 $ i $ 本目の釘の座標は $ (x_i,\ y_i) $ です。

高橋くんは実数 $ r\ (0\ <\ r\ \leq\ 100) $ を $ 1 $ つ選び、半径 $ r $ の円を中心が $ (-10^9,\ 0) $ に位置するように置きます。

その後、円を $ (-10^9,\ 0) $ から $ (10^9,\ 0) $ まで移動させます。

このとき、円は通路の境界や釘が円の内部に入らないような範囲で連続的に動かすことができるものとします。

円を $ (10^9,\ 0) $ まで動かせるような最大の $ r $ を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 1\ \leq\ N\ \leq\ 100 $
- $ |x_i|,\ |y_i|\ <\ 100 $
- $ i\ \neq\ j $ ならば $ (x_i,\ y_i)\ \neq\ (x_j,\ y_j) $

### Sample Explanation 1

!\[\](https://img.atcoder.jp/ghi/493d8b75d6dd331fcc0f3949f12262b3.jpg) $ r=40 $ の円を図のように $ y=0 $ に沿って動かすと、 $ (-10^9,\ 0) $ から $ (10^9,\ 0) $ まで移動させることができます。 $ x=0 $ のときにちょうど $ 2 $ つの点と接しますが、円の内部には入っていないため問題ありません。 $ r $ を $ 40 $ より大きくすると、円の中心を $ (10^9,\ 0) $ まで動かすことができなくなるため、 $ r=40 $ が最大になります。

## 样例 #1

### 输入

```
2

0 -40

0 40```

### 输出

```
40```

## 样例 #2

### 输入

```
4

0 -10

99 10

0 91

99 -91```

### 输出

```
50.5```

## 样例 #3

### 输入

```
10

-90 40

20 -30

0 -90

10 -70

80 70

-90 30

-20 -80

10 90

50 30

60 -70```

### 输出

```
33.541019662496845446```

## 样例 #4

### 输入

```
10

65 -90

-34 -2

62 99

42 -13

47 -84

84 87

16 -78

56 35

90 8

90 19```

### 输出

```
35.003571246374276203```

# AI分析结果

### 题目内容重写

在 $xy$ 平面上，有两条直线 $y=-100$ 和 $y=100$ 围成的通道。在这个通道中，$-100 < x < 100$ 的区域内有 $N$ 个大小可以忽略的钉子，第 $i$ 个钉子的坐标是 $(x_i, y_i)$。

高桥君选择一个实数 $r$（$0 < r \leq 100$），并将一个半径为 $r$ 的圆放置在中心为 $(-10^9, 0)$ 的位置。然后，他将圆从 $(-10^9, 0)$ 移动到 $(10^9, 0)$。在移动过程中，圆不能进入通道的边界或钉子的内部。求能够将圆移动到 $(10^9, 0)$ 的最大 $r$。

### 题解综合分析

本题的核心是通过二分查找确定最大半径 $r$，并结合并查集判断圆是否能通过通道。难点在于如何判断圆是否能通过钉子和边界的阻挡。大多数题解采用了二分查找结合并查集的思路，通过判断钉子和边界之间的连通性来确定圆是否能通过。

### 所选高星题解

#### 题解1：作者：ikunTLE (5星)
**关键亮点：**
- 使用二分查找确定最大半径 $r$。
- 通过并查集判断钉子和边界之间的连通性。
- 代码清晰，逻辑严谨，处理了精度问题。

**核心代码：**
```cpp
bool check(double r){
    _init();
    for(int i=1;i<=n;++i){
        for(int j=i+1;j<=n;++j)
            if(4*r*r>calc(x[i],x[j],y[i],y[j]))
                _merge(i,j);
        if(100-y[i]<=2*r)
            _merge(i,L);
        if(y[i]+100<=2*r)
            _merge(i,R);
    }
    return _find(L)!=_find(R);
}
```
**实现思想：**
- 初始化并查集，遍历所有钉子对，如果两个钉子之间的距离小于 $2r$，则将它们合并。
- 检查钉子与上下边界的距离，如果小于 $2r$，则将钉子与边界合并。
- 最后检查上下边界是否连通，如果不连通则圆可以通过。

#### 题解2：作者：Rnfmabj (4星)
**关键亮点：**
- 同样使用二分查找和并查集，但增加了对边界点的处理。
- 代码结构清晰，处理了精度误差。

**核心代码：**
```cpp
bool check(db lim){
    for(ll i=1;i<=tot;i++)fa[i]=i;
    for(ll i=1;i<=tot;i++){
        for(ll j=1;j<=tot;j++){
            if(i==j)continue;
            if(cmp(calc(a[i],a[j]),lim)==2)continue;
            merge(i,j);
        }
    }
    for(ll i=1;i<=tot;i++){
        if(a[i].y!=100&&a[i].y!=-100)continue;
        for(ll j=i+1;j<=tot;j++){
            if(a[i].y+a[j].y)continue;
            if(find(i)==find(j))return 0;
        }
    }
    return 1;
}
```
**实现思想：**
- 初始化并查集，遍历所有点对，如果两点之间的距离小于 $lim$，则将它们合并。
- 检查上下边界是否连通，如果连通则圆不能通过。

#### 题解3：作者：dengchengyu (4星)
**关键亮点：**
- 使用二分查找和并查集，代码简洁，逻辑清晰。
- 处理了钉子与边界的连接问题。

**核心代码：**
```cpp
bool check(ld r){
    fo(i,1,n+2)fa[i]=i;
    fo(i,1,n){
        fo(j,i+1,n){
            if(4*r*r>(X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j])){
                int u=getfa(i),v=getfa(j);
                if(u!=v)fa[u]=v;
            }
        }
        if(2*r>100-Y[i]){
            int u=getfa(n+1),v=getfa(i);
            if(u!=v)fa[u]=v;
        }
        if(2*r>Y[i]+100){
            int u=getfa(n+2),v=getfa(i);
            if(u!=v)fa[u]=v;
        }
    }
    return getfa(n+1)!=getfa(n+2);
}
```
**实现思想：**
- 初始化并查集，遍历所有钉子对，如果两个钉子之间的距离小于 $2r$，则将它们合并。
- 检查钉子与上下边界的距离，如果小于 $2r$，则将钉子与边界合并。
- 最后检查上下边界是否连通，如果不连通则圆可以通过。

### 最优关键思路与技巧

1. **二分查找**：通过二分查找确定最大半径 $r$，利用单调性逐步缩小范围。
2. **并查集**：通过并查集维护钉子和边界的连通性，判断圆是否能通过。
3. **精度处理**：在二分查找和距离计算中，注意处理精度问题，避免误差影响结果。

### 可拓展之处

- 类似的问题可以扩展到三维空间，或者考虑更复杂的障碍物形状。
- 可以使用其他数据结构如图论中的最短路径算法来解决类似问题。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
3. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

### 个人心得摘录

- **调试经历**：在处理精度问题时，多次调整二分查找的终止条件，确保结果准确。
- **踩坑教训**：在并查集的初始化中，忘记重置父节点，导致结果错误。
- **顿悟感想**：通过二分查找和并查集的结合，能够高效解决复杂的几何问题。

---
处理用时：49.05秒
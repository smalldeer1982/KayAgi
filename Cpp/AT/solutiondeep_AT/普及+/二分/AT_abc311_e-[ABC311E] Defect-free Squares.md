# 题目信息

# [ABC311E] Defect-free Squares

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc311/tasks/abc311_e

縦 $ H $ 行, 横 $ W $ 列のグリッドがあります。グリッドの上から $ i $ 行目, 左から $ j $ 列目のマスを $ (i,\ j) $ と呼びます。  
 グリッドの各マスは穴の空いたマスとそうでないマスのどちらかです。穴が空いたマスは $ (a_1,\ b_1),\ (a_2,\ b_2),\ \dots,\ (a_N,\ b_N) $ のちょうど $ N $ マスです。

正整数の組 $ (i,\ j,\ n) $ が次の条件を満たすとき、$ (i,\ j) $ を左上隅, $ (i\ +\ n\ -\ 1,\ j\ +\ n\ -\ 1) $ を右下隅とする正方形領域を **穴のない正方形** と呼びます。

- $ i\ +\ n\ -\ 1\ \leq\ H $
- $ j\ +\ n\ -\ 1\ \leq\ W $
- $ 0\ \leq\ k\ \leq\ n\ -\ 1,\ 0\ \leq\ l\ \leq\ n\ -\ 1 $ を満たす全ての非負整数の組 $ (k,\ l) $ に対して、$ (i\ +\ k,\ j\ +\ l) $ は穴が空いていないマスである。
 
グリッド内に穴のない正方形は何個ありますか？

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 3000 $
- $ 0\ \leq\ N\ \leq\ \min(H\ \times\ W,\ 10^5) $
- $ 1\ \leq\ a_i\ \leq\ H $
- $ 1\ \leq\ b_i\ \leq\ W $
- $ (a_i,\ b_i) $ は互いに異なる
- 入力される値は全て整数
 
### Sample Explanation 1

穴のない正方形は全部で $ 6 $ 個あります。 それらを列挙すると次の通りです。このうちはじめの $ 5 $ 個は $ n\ =\ 1 $ の場合であり、領域の左上隅のマスと右下隅のマスが一致します。 - $ (1,\ 1) $ を左上隅かつ右下隅とする正方形領域 - $ (1,\ 2) $ を左上隅かつ右下隅とする正方形領域 - $ (1,\ 3) $ を左上隅かつ右下隅とする正方形領域 - $ (2,\ 1) $ を左上隅かつ右下隅とする正方形領域 - $ (2,\ 2) $ を左上隅かつ右下隅とする正方形領域 - $ (1,\ 1) $ を左上隅, $ (2,\ 2) $ を右下隅とする正方形領域

### Sample Explanation 2

穴のない正方形が存在しない場合もあります。

### Sample Explanation 3

穴のない正方形がグリッド全体と一致する場合もあります。

## 样例 #1

### 输入

```
2 3 1

2 3```

### 输出

```
6```

## 样例 #2

### 输入

```
3 2 6

1 1

1 2

2 1

2 2

3 1

3 2```

### 输出

```
0```

## 样例 #3

### 输入

```
1 1 0```

### 输出

```
1```

## 样例 #4

### 输入

```
3000 3000 0```

### 输出

```
9004500500```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个 $H$ 行 $W$ 列的网格，网格中的某些格子是“有洞”的。具体来说，有 $N$ 个格子是“有洞”的，其余格子是“无洞”的。现在要求统计网格中所有“无洞正方形”的数量。所谓“无洞正方形”，是指以某个格子为左上角，边长为 $n$ 的正方形区域，且该区域内所有格子都是“无洞”的。

【输入格式】

第一行输入三个整数 $H, W, N$，分别表示网格的行数、列数以及“有洞”格子的数量。

接下来 $N$ 行，每行输入两个整数 $a_i, b_i$，表示第 $i$ 个“有洞”格子的位置。

【输出格式】

输出一个整数，表示网格中“无洞正方形”的总数。

【样例输入1】

```
2 3 1
2 3
```

【样例输出1】

```
6
```

【样例输入2】

```
3 2 6
1 1
1 2
2 1
2 2
3 1
3 2
```

【样例输出2】

```
0
```

【样例输入3】

```
1 1 0
```

【样例输出3】

```
1
```

【样例输入4】

```
3000 3000 0
```

【样例输出4】

```
9004500500
```

### 题解分析与结论

本题的核心问题是如何高效地统计网格中所有“无洞正方形”的数量。由于网格的大小可能达到 $3000 \times 3000$，直接暴力枚举所有可能的正方形会导致时间复杂度过高，因此需要采用更高效的算法。

#### 关键思路与技巧

1. **动态规划（DP）**：通过动态规划的方法，记录以每个格子为右下角的“无洞正方形”的最大边长，进而统计所有可能的正方形数量。这种方法的时间复杂度为 $O(H \times W)$，是最优的解决方案。

2. **二维前缀和**：通过预处理二维前缀和，可以快速判断某个正方形区域内是否包含“有洞”的格子。这种方法在二分查找边长时非常有用，可以将时间复杂度优化到 $O(H \times W \log H)$。

3. **二分查找**：对于每个格子，通过二分查找确定以该格子为左上角的最大“无洞正方形”的边长。结合二维前缀和，可以快速判断某个正方形是否满足条件。

#### 最优题解

**题解作者：EmptyAlien**  
**星级：5星**  
**关键亮点**：  
- 使用动态规划（DP）方法，时间复杂度为 $O(H \times W)$，是最优的解决方案。  
- 状态转移方程清晰，代码简洁易懂。  
- 通过二维前缀和预处理，快速判断正方形是否包含“有洞”格子。

**核心代码**：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 3005;
int n, m, k, a[MAXN][MAXN];
long long f[MAXN][MAXN], ans;
int main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= k; i++) {
        int x, y;
        cin >> x >> y;
        a[x][y] = 1;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j]) {
                continue;
            }
            f[i][j] = min({f[i][j - 1], f[i - 1][j], f[i - 1][j - 1]}) + 1;
            ans += f[i][j];
        }
    }
    cout << ans << endl;
    return 0;
}
```

**实现思想**：  
- 使用二维数组 `a` 记录“有洞”格子的位置。  
- 使用二维数组 `f` 记录以每个格子为右下角的“无洞正方形”的最大边长。  
- 通过状态转移方程 `f[i][j] = min({f[i][j - 1], f[i - 1][j], f[i - 1][j - 1]}) + 1` 计算每个格子的 `f` 值。  
- 最终累加所有 `f[i][j]` 的值，得到“无洞正方形”的总数。

### 推荐题目

1. **P1387 最大正方形**：与本题类似，要求找到矩阵中最大的全1正方形。
2. **P2004 二维前缀和**：学习二维前缀和的应用，为本题的优化提供基础。
3. **P2216 理想的正方形**：通过滑动窗口和二维前缀和解决正方形相关问题。

### 个人心得

- **调试经历**：在实现动态规划时，需要注意边界条件的处理，特别是当 `i` 或 `j` 为1时，`f[i][j]` 的值应直接为1。
- **踩坑教训**：在预处理二维前缀和时，要确保数组下标从1开始，避免越界问题。
- **顿悟感想**：通过动态规划的方法，可以将问题的时间复杂度从 $O(n^3)$ 优化到 $O(n^2)$，极大地提高了算法的效率。

---
处理用时：38.18秒
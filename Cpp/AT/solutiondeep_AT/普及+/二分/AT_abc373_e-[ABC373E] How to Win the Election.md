# 题目信息

# [ABC373E] How to Win the Election

## 题目描述

现在正在举行一场选举，有 $N$ 位候选人，编号为 $1, 2, \ldots, N$。目前已经有 $K$ 张选票，其中一些已经被计入。

到目前为止，第 $i$ 位候选人已经获得了 $A_i$ 票。

在所有选票被计完后，如果某位候选人的得票数比他们多的候选人数少于 $M$，那么该候选人将被当选。可能会有多位候选人同时当选。

对于每个候选人，求出他们需要从剩余的选票中获得的最少票数，以确保无论其他候选人获得多少票，他们都能当选。

具体来说，对于每个 $i = 1, 2, \ldots, N$，解决以下问题：

确定是否存在一个非负整数 $X$，其不超过 $K - \displaystyle{\sum_{i=1}^{N}} A_i$，并满足以下条件。如果存在，找出满足条件的最小 $X$。

- 如果候选人 $i$ 获得了 $X$ 张额外选票，那么候选人 $i$ 将始终当选。

## 说明/提示

- $1 \leq M \leq N \leq 2 \times 10^5$。
- $1 \leq K \leq 10^{12}$。
- $0 \leq A_i \leq 10^{12}$。
- $\displaystyle{\sum_{i=1}^{N} A_i} \leq K$。

## 样例 #1

### 输入

```
5 2 16
3 1 4 1 5```

### 输出

```
2 -1 1 -1 0```

## 样例 #2

### 输入

```
12 1 570
81 62 17 5 5 86 15 7 79 26 6 28```

### 输出

```
79 89 111 117 117 74 112 116 80 107 117 106```

# AI分析结果

### 题目内容重写

现在正在举行一场选举，有 $N$ 位候选人，编号为 $1, 2, \ldots, N$。目前已经有 $K$ 张选票，其中一些已经被计入。

到目前为止，第 $i$ 位候选人已经获得了 $A_i$ 票。

在所有选票被计完后，如果某位候选人的得票数比他们多的候选人数少于 $M$，那么该候选人将被当选。可能会有多位候选人同时当选。

对于每个候选人，求出他们需要从剩余的选票中获得的最少票数，以确保无论其他候选人获得多少票，他们都能当选。

具体来说，对于每个 $i = 1, 2, \ldots, N$，解决以下问题：

确定是否存在一个非负整数 $X$，其不超过 $K - \displaystyle{\sum_{i=1}^{N}} A_i$，并满足以下条件。如果存在，找出满足条件的最小 $X$。

- 如果候选人 $i$ 获得了 $X$ 张额外选票，那么候选人 $i$ 将始终当选。

### 题解分析与结论

本题的核心思路是通过二分查找来确定每个候选人需要的最小额外票数，以确保他们能够当选。难点在于如何高效地计算每个候选人在获得额外票数后，是否能够保证当选。大多数题解都采用了二分查找结合贪心策略，通过排序和前缀和优化来减少计算复杂度。

### 精选题解

#### 题解1：作者：dayz_break404 (赞：10)
**星级：★★★★★**
**关键亮点：**
- 使用二分查找结合贪心策略，通过排序和前缀和优化，减少了计算复杂度。
- 详细解释了如何通过二分查找确定每个候选人需要的最小额外票数，并处理了特殊情况（如 $N=M$）。
- 代码清晰，逻辑严谨，易于理解。

**核心代码：**
```cpp
bool check(int id, ll mid) {
    ll now = k - sum[n] - mid;
    int x = upper_bound(a + 1, a + 1 + n, b[id] + mid) - a - 1;
    int y = n - m + 1;
    if (n == m) return 1;
    if (n - x >= m) return 0;
    if (a[y] > b[id]) return 1ll * (x - y + 1) * (b[id] + mid + 1) - (sum[x] - sum[y - 1]) > now;
    return 1ll * (x - y + 1) * (b[id] + mid + 1) - (sum[x] - sum[y - 2] - b[id]) > now;
}
```

#### 题解2：作者：HasNoName (赞：2)
**星级：★★★★**
**关键亮点：**
- 同样采用二分查找和贪心策略，通过排序和前缀和优化。
- 详细解释了如何通过二分查找确定每个候选人需要的最小额外票数，并处理了特殊情况（如 $N=M$）。
- 代码逻辑清晰，易于理解。

**核心代码：**
```cpp
bool ok(int k, ll x) {
    if (a[k].a + x < a[m].a) return 0;
    ll l = 1, r = m, mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (a[k].a + x >= a[mid].a) r = mid;
        else l = mid + 1;
    }
    return (a[k].a + x + 1) * (m - l + 1) - (f[m] - f[l - 1]) + (k <= m && m < n) * (a[k].a + x + 1 - a[m + 1].a - x - 1) > p - x;
}
```

#### 题解3：作者：shanxinhan (赞：2)
**星级：★★★★**
**关键亮点：**
- 使用二分查找结合贪心策略，通过排序和前缀和优化。
- 详细解释了如何通过二分查找确定每个候选人需要的最小额外票数，并处理了特殊情况（如 $N=M$）。
- 代码逻辑清晰，易于理解。

**核心代码：**
```cpp
bool check(int x, int mid) {
    int pos = lower_bound(b + 1, b + 1 + n, x + mid + 1) - b - 1;
    if (pos < n - m) return 0;
    return (x + mid + 1) * (pos - n + m) - (sum[pos] - sum[n - m - 1] - max(x, b[n - m])) > k - mid;
}
```

### 最优关键思路或技巧
- **二分查找**：通过二分查找确定每个候选人需要的最小额外票数，确保他们能够当选。
- **贪心策略**：在计算每个候选人需要的最小额外票数时，优先将票数分配给与当前候选人票数差距较小的候选人，以确保当前候选人能够当选。
- **排序和前缀和优化**：通过排序和前缀和优化，减少了计算复杂度，提高了算法的效率。

### 可拓展之处
- 类似的问题可以扩展到其他需要确定最小资源分配的场景，如任务调度、资源分配等。
- 可以进一步优化算法，减少时间复杂度，适用于更大规模的数据。

### 推荐题目
1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结
- **调试经历**：在处理特殊情况（如 $N=M$）时，容易忽略边界条件，导致代码出错。需要仔细检查边界条件，确保代码的正确性。
- **踩坑教训**：在计算前缀和时，需要注意数组的索引范围，避免数组越界。
- **顿悟感想**：通过二分查找和贪心策略，可以高效地解决复杂的资源分配问题，提高算法的效率。

---
处理用时：49.82秒
# 题目信息

# [ABC379F] Buildings 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc379/tasks/abc379_f

ビル $ 1 $, ビル $ 2 $, $ \ldots $, ビル $ N $ の $ N $ 棟がこの順で東西に一列に並んでおり、ビル $ 1 $ が最も西に、ビル $ N $ が最も東に建っています。ビル $ i\ (1\leq\ i\leq\ N) $ の高さは $ H_i $ です。

整数の組 $ (i,j)\ (1\leq\ i\lt\ j\leq\ N) $ に対して、以下の条件を満たすとき ビル $ i $ からビル $ j $ を見ることができます。

- ビル $ i $ とビル $ j $ の間にビル $ j $ より高いビルが存在しない。すなわち、$ H_k\gt\ H_j $ を満たす整数 $ k\ (i\lt\ k\lt\ j) $ が存在しない。

$ Q $ 個の質問に答えてください。$ i $ 番目の質問では整数の組 $ (l_i,r_i)\ (l_i\lt\ r_i) $ が与えられるので、ビル $ r_i $ より東にあるビル（ビル $ r_i+1 $, ビル $ r_i+2 $,$ \ldots $,ビル $ N $ ）のうちビル $ l_i $ とビル $ r_i $ の両方から見ることができるものの個数を答えてください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ Q\leq\ 2\times\ 10^5 $
- $ 1\leq\ H_i\leq\ N $
- $ H_i\neq\ H_j\ (i\neq\ j) $
- $ 1\leq\ l_i\lt\ r_i\leq\ N $
- 入力は全て整数

### Sample Explanation 1

\- $ 1 $ つ目の質問について、ビル $ 2 $ より東にあるビルのうち ビル $ 1 $ とビル $ 2 $ の両方から見ることができるものはビル $ 3,5 $ の $ 2 $ つです。 - $ 2 $ つ目の質問について、ビル $ 5 $ より東にあるビルは存在しません。 - $ 3 $ つ目の質問について、ビル $ 4 $ より東にあるビルのうち、ビル $ 1,4 $ の両方から見ることができるビルはビル $ 5 $ の $ 1 $ つです。

## 样例 #1

### 输入

```
5 3
2 1 4 3 5
1 2
3 5
1 4```

### 输出

```
2
0
1```

## 样例 #2

### 输入

```
10 10
2 1 5 3 4 6 9 8 7 10
3 9
2 5
4 8
5 6
3 8
2 10
7 8
6 7
8 10
4 10```

### 输出

```
1
3
1
2
1
0
1
1
0
0```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $N$ 栋建筑按顺序从西向东排列，建筑 $1$ 位于最西边，建筑 $N$ 位于最东边。建筑 $i$ 的高度为 $H_i$。

对于整数对 $(i,j)$（$1 \leq i < j \leq N$），如果建筑 $i$ 和建筑 $j$ 之间没有比建筑 $j$ 更高的建筑，即不存在 $k$（$i < k < j$）满足 $H_k > H_j$，则称建筑 $i$ 可以看到建筑 $j$。

现在有 $Q$ 个询问，每个询问给出一个整数对 $(l_i, r_i)$（$l_i < r_i$），要求回答在建筑 $r_i$ 东侧（即建筑 $r_i+1, r_i+2, \ldots, N$）中，有多少栋建筑同时可以被建筑 $l_i$ 和建筑 $r_i$ 看到。

#### 输入格式

第一行包含两个整数 $N$ 和 $Q$，表示建筑的数量和询问的数量。

第二行包含 $N$ 个整数 $H_1, H_2, \ldots, H_N$，表示每栋建筑的高度。

接下来 $Q$ 行，每行包含两个整数 $l_i$ 和 $r_i$，表示一个询问。

#### 输出格式

对于每个询问，输出一个整数，表示满足条件的建筑数量。

#### 样例输入 1

```
5 3
2 1 4 3 5
1 2
3 5
1 4
```

#### 样例输出 1

```
2
0
1
```

#### 样例输入 2

```
10 10
2 1 5 3 4 6 9 8 7 10
3 9
2 5
4 8
5 6
3 8
2 10
7 8
6 7
8 10
4 10
```

#### 样例输出 2

```
1
3
1
2
1
0
1
1
0
0
```

#### 数据范围

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq Q \leq 2 \times 10^5$
- $1 \leq H_i \leq N$
- $H_i$ 互不相同

---

### 题解分析与结论

#### 综合分析与结论

本题的核心问题是如何高效地处理多个询问，找出满足条件的建筑数量。题解中主要采用了以下几种思路：

1. **单调栈**：用于预处理每个建筑左侧第一个比它高的建筑，或者维护一个从右向左的单调递减栈，用于快速查询某个建筑右侧能被看到的建筑。
2. **离线处理**：将询问按照右端点排序，从右向左处理，利用单调栈和树状数组等数据结构快速回答询问。
3. **树状数组/线段树**：用于维护某个区间内的建筑数量，支持快速查询和更新。
4. **二分查找**：在单调栈或预处理的数据上进行二分查找，快速定位满足条件的建筑。

#### 最优关键思路或技巧

1. **单调栈预处理**：通过单调栈预处理每个建筑左侧第一个比它高的建筑，或者维护一个从右向左的单调递减栈，能够快速回答每个询问。
2. **离线处理与树状数组结合**：将询问离线处理，按照右端点排序，从右向左处理，利用树状数组维护满足条件的建筑数量，能够高效回答每个询问。
3. **二分查找优化**：在单调栈或预处理的数据上进行二分查找，能够快速定位满足条件的建筑，减少时间复杂度。

#### 推荐题目

1. **洛谷 P1908 逆序对**：考察树状数组的应用，与本题中的树状数组维护思路相似。
2. **洛谷 P3374 线段树 1**：考察线段树的基本操作，与本题中的线段树维护思路相似。
3. **洛谷 P3865 ST 表**：考察 ST 表的应用，与本题中的区间最大值查询思路相似。

---

### 所选高星题解

#### 题解 1：PineappleSummer（★★★★☆）

**关键亮点**：
- 使用单调栈从右向左维护每个建筑能看到的建筑，离线处理询问，利用二分查找快速回答。
- 代码简洁，思路清晰，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
for (int i = n; i; --i) {
    for (auto [j, id] : query[i]) {
        int l = 1, r = tot;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (st[mid] > j) l = mid;
            else r = mid - 1;
        }
        if (st[l] <= j) ans[id] = 0;
        else ans[id] = l;
    }
    while (tot && a[st[tot]] < a[i]) --tot;
    st[++tot] = i;
}
```

**个人心得**：
- 单调栈的维护顺序和二分查找的结合使得代码效率较高，适合处理大规模数据。

#### 题解 2：small_lemon_qwq（★★★★☆）

**关键亮点**：
- 使用单调栈预处理每个建筑左侧第一个比它高的建筑，离线处理询问，利用树状数组维护满足条件的建筑数量。
- 代码结构清晰，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
for (int i = n; i >= 1; --i) {
    for (auto [l, id] : q[i]) {
        ans[id] = bit.query(l);
    }
    bit.add(pre[i], 1);
}
```

**个人心得**：
- 树状数组的使用使得查询和更新操作非常高效，适合处理大规模数据。

#### 题解 3：Conan15（★★★★☆）

**关键亮点**：
- 使用单调栈预处理每个建筑左侧第一个比它高的建筑，利用可持久化线段树维护满足条件的建筑数量，支持在线回答询问。
- 代码结构清晰，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
for (int i = n; i >= 1; --i) {
    change(root[i], root[i + 1], 0, n, pre[i]);
}
```

**个人心得**：
- 可持久化线段树的使用使得在线回答询问成为可能，适合需要动态处理的场景。

---
处理用时：52.57秒
# 题目信息

# [ABC385D] Santa Claus 2

## 题目描述

在二次元平面上有 $N$ 个点 $(X_1,Y_1),\ldots,(X_N,Y_N)$ 建有房子。

最初，圣诞老人在点 $(S_x,S_y)$。圣诞老人将按照序列 $(D_1,C_1),\ldots,(D_M,C_M)$ 进行以下行动：

- 对于 $i=1,2,\ldots,M$，按顺序进行以下移动：
  - 设 $(x,y)$ 为他当前所在的点。
      - 如果 $D_i$ 是 `U`，则从 $(x,y)$ 沿直线移动到 $(x,y+C_i)$。
      - 如果 $D_i$ 是 `D`，则从 $(x,y)$ 沿直线移动到 $(x,y-C_i)$。
      - 如果 $D_i$ 是 `L`，则从 $(x,y)$ 沿直线移动到 $(x-C_i,y)$。
      - 如果 $D_i$ 是 `R`，则从 $(x,y)$ 沿直线移动到 $(x+C_i,y)$。

请找出他完成所有行动后所在的点，以及他在行动过程中经过或到达的不同房子的数量。如果多次经过同一个房子，只计数一次。

## 说明/提示

- $1 \leq N \leq 2\times 10^5$
- $1 \leq M \leq 2\times 10^5$
- $-10^9 \leq X_i,Y_i \leq 10^9$
- $(X_i,Y_i)$ 互不相同
- $-10^9 \leq S_x,S_y \leq 10^9$
- 点 $(S_x,S_y)$ 没有房子
- 每个 $D_i$ 是 `U`、`D`、`L`、`R` 之一
- $1 \leq C_i \leq 10^9$
- 所有给定数字均为整数

**【样例 #1 解释】**

圣诞老人的行动如下图所示：

![](https://img.atcoder.jp/abc385/f3d0f313d3b20c135af60ca6eb04900d.png)

- $D_1=$ `L`，所以他从 $(3,2)$ 直线移动到 $(3-2,2)$。在此期间，他经过 $(2,2)$ 处的房子。
- $D_2=$ `D`，所以他从 $(1,2)$ 直线移动到 $(1,2-1)$。
- $D_3=$ `R`，所以他从 $(1,1)$ 直线移动到 $(1+1,1)$。在此期间，他经过 $(2,1)$ 处的房子。
- $D_4=$ `U`，所以他从 $(2,1)$ 直线移动到 $(2,1+2)$。在此期间，他经过 $(2,2)$ 处的房子，但该房子已经被经过。

他在行动期间经过或到达的房子数量为 $2$。

**【样例 #2 解释】**

小心溢出。

## 样例 #1

### 输入

```
3 4 3 2
2 2
3 3
2 1
L 2
D 1
R 1
U 2```

### 输出

```
2 3 2```

## 样例 #2

### 输入

```
1 3 0 0
1 1
R 1000000000
R 1000000000
R 1000000000```

### 输出

```
3000000000 0 0```

# AI分析结果

### 题目内容重写
在二维平面上有 $N$ 个点 $(X_1,Y_1),\ldots,(X_N,Y_N)$ 建有房子。最初，圣诞老人在点 $(S_x,S_y)$。圣诞老人将按照序列 $(D_1,C_1),\ldots,(D_M,C_M)$ 进行以下行动：

- 对于 $i=1,2,\ldots,M$，按顺序进行以下移动：
  - 设 $(x,y)$ 为他当前所在的点。
      - 如果 $D_i$ 是 `U`，则从 $(x,y)$ 沿直线移动到 $(x,y+C_i)$。
      - 如果 $D_i$ 是 `D`，则从 $(x,y)$ 沿直线移动到 $(x,y-C_i)$。
      - 如果 $D_i$ 是 `L`，则从 $(x,y)$ 沿直线移动到 $(x-C_i,y)$。
      - 如果 $D_i$ 是 `R`，则从 $(x,y)$ 沿直线移动到 $(x+C_i,y)$。

请找出他完成所有行动后所在的点，以及他在行动过程中经过或到达的不同房子的数量。如果多次经过同一个房子，只计数一次。

### 题解分析与结论
本题的核心难点在于如何高效地统计圣诞老人在移动过程中经过的不同房子的数量。由于坐标范围较大（$-10^9$ 到 $10^9$），直接遍历或暴力计算是不可行的。因此，大多数题解都采用了基于 `map` 和 `set` 的数据结构来优化查询和删除操作。

### 精选题解

#### 1. 作者：Drifty (赞：11)
**星级：★★★★★**
**关键亮点：**
- 使用 `map<int, set<int>>` 来存储房子的坐标，分别按 $x$ 和 $y$ 进行索引。
- 通过 `lower_bound` 和 `upper_bound` 快速找到需要删除的房子，并在 `set` 中进行删除操作。
- 时间复杂度为 $O((m + n)\log n)$，效率较高。

**核心代码：**
```cpp
void work (i64 x, i64 y, i64 u, i64 v, Map &i, Map &j) {
    if (!(!i[x].empty() && abs(x) <= (int)1e9 && abs(y) <= (int)1e9)) return ;
    temp.clear(); auto bg = i[x].lower_bound(y + u), ed = i[x].upper_bound(y + v);
    for (auto it = bg; it != ed; ++ it) ans ++, temp.push_back((* it));
    for (auto p : temp) j[p].erase(x), i[x].erase(p);
}
```
**个人心得：**
- 通过 `map` 和 `set` 的结合，实现了高效的坐标查询和删除操作，避免了重复计算。

#### 2. 作者：hanhoudedidue (赞：5)
**星级：★★★★**
**关键亮点：**
- 采用扫描线算法，将问题转化为求矩形面积并的问题。
- 通过容斥原理，先计算路径的面积，再减去与房子重叠的部分，得到最终结果。
- 时间复杂度为 $O(n \log n)$，适合大规模数据处理。

**核心代码：**
```cpp
int solve(int nn){
    xx[0]=yy[0]=0;int mm;int res=0;
    for(int i=1;i<=nn;i++){
        xx[++xx[0]]=a[i].x;xx[++xx[0]]=a[i].X;
        yy[++yy[0]]=a[i].y;yy[++yy[0]]=a[i].Y;
    }
    sort(xx+1,xx+xx[0]+1);sort(yy+1,yy+yy[0]+1);
    xx[0]=unique(xx+1,xx+xx[0]+1)-xx-1;yy[0]=unique(yy+1,yy+yy[0]+1)-yy-1;
    mm=2*nn;
    for(int i=1;i<=nn;i++){
        a[i].x=lower_bound(xx+1,xx+xx[0]+1,a[i].x)-xx;
        a[i].y=lower_bound(yy+1,yy+yy[0]+1,a[i].y)-yy;
        a[i].X=lower_bound(xx+1,xx+xx[0]+1,a[i].X)-xx;
        a[i].Y=lower_bound(yy+1,yy+yy[0]+1,a[i].Y)-yy;
        li[i*2-1]=line{a[i].y,a[i].x,a[i].X,1};
        li[i*2]=line{a[i].Y,a[i].x,a[i].X,-1};
    }
    sort(li+1,li+mm+1,cmp);
    build(1,1,xx[0]-1);
    add(1,li[1].x,li[1].X-1,1);
    for(int i=2;i<=mm;i++){
        res+=(yy[li[i].y]-yy[li[i-1].y])*t[1].sum;
        add(1,li[i].x,li[i].X-1,li[i].flag);
    }
    return res;
}
```
**个人心得：**
- 通过扫描线算法，将问题转化为求矩形面积并的问题，避免了直接处理大规模坐标的复杂性。

#### 3. 作者：ARIS2_0 (赞：3)
**星级：★★★★**
**关键亮点：**
- 使用二分查找和差分数组来标记经过的房子，避免了重复计算。
- 通过两个 `map` 分别存储按 $x$ 和 $y$ 排序的房子坐标，优化查询效率。
- 时间复杂度为 $O(n \log n)$，适合大规模数据处理。

**核心代码：**
```cpp
void add(int l,int r,int pos){
    if(l==0)return;
    if(l>r)return;
    if(l>n)return;
    tree[l]+=pos;
    if(r<n)tree[r+1]-=pos;
}
```
**个人心得：**
- 通过二分查找和差分数组的结合，实现了高效的区间标记和查询操作，避免了重复计算。

### 最优关键思路或技巧
- **数据结构优化**：使用 `map<int, set<int>>` 来存储房子的坐标，分别按 $x$ 和 $y$ 进行索引，优化查询和删除操作。
- **二分查找**：通过 `lower_bound` 和 `upper_bound` 快速找到需要删除的房子，并在 `set` 中进行删除操作。
- **扫描线算法**：将问题转化为求矩形面积并的问题，通过容斥原理计算最终结果。

### 可拓展之处
- **类似问题**：处理大规模网格图问题时，可以使用类似的数据结构优化方法，如 `map` 和 `set` 的结合。
- **算法套路**：在处理区间查询和删除操作时，二分查找和差分数组是常用的优化手段。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)
3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

---
处理用时：62.30秒
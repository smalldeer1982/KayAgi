# 题目信息

# [AGC039B] Graph Partition

## 题目描述

给定一张 $N$ 个顶点，$M$ 条边的无向连通图。  
顶点以 $1\ldots N$ 编号，边以仅包含 $\texttt{0/1}$ 的邻接矩阵的形式给出。

请判断是否能够将顶点分为 $k$ 个非空集合 $V_1,\ldots,V_k$，使得其满足以下条件。若可以，则最大化 $k$：
 - 对于每条边 $(i,j)$，存在 $1 \le t \le k-1$ 满足 $i \in V_t, j \in V_{t+1}$ 或 $i \in V_{t+1}, j \in V_t$。

## 说明/提示

### 数据限制
- $N \in [2,200] \bigcap \mathbb Z$。
- 邻接矩阵仅由 $\texttt0$ 与 $\texttt1$ 组成。
- 邻接矩阵关于主对角线对称。
- 邻接矩阵主对角线均为 $\texttt0$（无自环）。
- 图一定连通。

#### 样例解释 #1
可以分别将顶点 $1,2$ 分入 $V_1,V_2$。

## 样例 #1

### 输入

```
2

01

10```

### 输出

```
2```

## 样例 #2

### 输入

```
3

011

101

110```

### 输出

```
-1```

## 样例 #3

### 输入

```
6

010110

101001

010100

101000

100000

010000```

### 输出

```
4```

# AI分析结果

### 题目内容重写
给定一张 $N$ 个顶点，$M$ 条边的无向连通图。  
顶点以 $1\ldots N$ 编号，边以仅包含 $\texttt{0/1}$ 的邻接矩阵的形式给出。

请判断是否能够将顶点分为 $k$ 个非空集合 $V_1,\ldots,V_k$，使得其满足以下条件。若可以，则最大化 $k$：
 - 对于每条边 $(i,j)$，存在 $1 \le t \le k-1$ 满足 $i \in V_t, j \in V_{t+1}$ 或 $i \in V_{t+1}, j \in V_t$。

### 说明/提示
#### 数据限制
- $N \in [2,200] \bigcap \mathbb Z$。
- 邻接矩阵仅由 $\texttt0$ 与 $\texttt1$ 组成。
- 邻接矩阵关于主对角线对称。
- 邻接矩阵主对角线均为 $\texttt0$（无自环）。
- 图一定连通。

#### 样例解释 #1
可以分别将顶点 $1,2$ 分入 $V_1,V_2$。

### 样例 #1
#### 输入
```
2
01
10
```
#### 输出
```
2
```

### 样例 #2
#### 输入
```
3
011
101
110
```
#### 输出
```
-1
```

### 样例 #3
#### 输入
```
6
010110
101001
010100
101000
100000
010000
```
#### 输出
```
4
```

### 题解分析与结论
#### 题解1：Rushroom
**星级：4**
**关键亮点：**
- 使用二分图染色判断图的可行性，若染色失败则输出 `-1`。
- 使用 Floyd 算法计算所有点对之间的最短路径，通过枚举两个端点找到最长的路径，从而确定最大的 $k$。

**核心代码：**
```cpp
void dfs(int k) {
    rep(i, v[k].size()) {
        int x = v[k][i];
        if (col[x] == -1) {
            col[x] = 1 - col[k];
            dfs(x);
        }
        else if (col[x] != 1 - col[k])fail = 1;
    }
}
```
**实现思想：**
- 通过 DFS 进行二分图染色，若相邻节点颜色相同则染色失败。
- 使用 Floyd 算法计算所有点对之间的最短路径，找到最长的路径作为 $k$。

#### 题解2：wowwowwow
**星级：4**
**关键亮点：**
- 使用二分图染色判断图的可行性。
- 以每个点为起点进行 BFS，记录每个点的集合编号，取所有方案中的最大值作为 $k$。

**核心代码：**
```cpp
int BFS(int st){
    for(int i = 1; i <= n; i++) t[i] = 0, vis[i] = 0;
    q.push(st); t[st] = 1; vis[st] = 1;
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int v : g[u])
            if(!vis[v]){
                vis[v] = 1;
                t[v] = t[u] + 1;
                q.push(v);
            }
    }
    int maxn = 0;
    for(int i = 1; i <= n; i++){
        maxn = max(maxn, t[i]);
    } 
    return maxn;
}
```
**实现思想：**
- 通过 BFS 记录每个点的集合编号，确保相邻节点的集合编号差为 1。
- 取所有 BFS 结果中的最大值作为 $k$。

#### 题解3：GTAyin
**星级：4**
**关键亮点：**
- 使用二分图染色判断图的可行性。
- 对每个点使用 SPFA 算法计算最短路，取所有最短路中的最大值作为 $k$。

**核心代码：**
```cpp
void spfa(int s){
    queue<int> p;
    for(int i=1;i<=n;i++){
        dis[i]=inf;
        bk[i]=false;
    }
    p.push(s);
    dis[s]=0;
    bk[s]=true;
    while(!p.empty()){
        int k=p.front();
        p.pop();
        bk[k]=false;
        for(int i=head[k];i;i=e[i].Next){
            int v=e[i].To;
            if(dis[v]>dis[k]+1){
                dis[v]=dis[k]+1;
                if(!bk[v]){
                    p.push(v);
                    bk[v]=true;
                }
            }
        }
    }
}
```
**实现思想：**
- 通过 SPFA 算法计算每个点的最短路，确保路径上相邻节点的集合编号差为 1。
- 取所有最短路中的最大值作为 $k$。

### 最优关键思路或技巧
- **二分图染色**：用于判断图是否满足条件，若染色失败则输出 `-1`。
- **最短路径算法**：通过 Floyd、BFS 或 SPFA 等算法计算最长路径，确定最大的 $k$。

### 可拓展之处
- 类似问题可以扩展到有向图或不连通图的情况，需要调整算法以适应不同的图结构。
- 可以结合其他图论算法，如 Dijkstra 或 Bellman-Ford，来解决类似的最长路径问题。

### 推荐题目
1. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)
2. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
3. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

---
处理用时：46.67秒
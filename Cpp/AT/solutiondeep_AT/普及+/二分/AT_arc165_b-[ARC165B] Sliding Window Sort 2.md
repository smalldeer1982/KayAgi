# 题目信息

# [ARC165B] Sliding Window Sort 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc165/tasks/arc165_b

$ 1 $ から $ N $ までの整数からなる順列 $ P=(P_1,P_2,\dots,P_N) $ と整数 $ K $ が与えられます。

順列 $ P $ に対して以下のような操作を考えます。

- $ 1\ \leq\ i\ \leq\ N-K+1 $ を満たす整数 $ i $ を $ 1 $ つ選び、 $ P_i,P_{i+1},\dots,P_{i+K-1} $ を昇順に並び替える。すなわち、$ P_i,P_{i+1},\dots,P_{i+K-1} $ を小さい方から順に並べたものを $ (x_1,x_2,\dots,x_K) $ としたとき、各 $ 1\ \leq\ j\ \leq\ K $ に対して $ P_{i+j-1} $ を $ x_j $ で置き換える。
 
$ P $ に対して上記の操作をちょうど $ 1 $ 回行うことで得られる順列のうち、辞書式順序最大のものを求めてください。

  数列の辞書順とは？数列 $ S\ =\ (S_1,S_2,\ldots,S_{|S|}) $ が数列 $ T\ =\ (T_1,T_2,\ldots,T_{|T|}) $ より**辞書順で小さい**とは、下記の 1. と 2. のどちらかが成り立つことを言います。 ここで、$ |S|,\ |T| $ はそれぞれ $ S,\ T $ の長さを表します。

1. $ |S|\ \lt\ |T| $ かつ $ (S_1,S_2,\ldots,S_{|S|})\ =\ (T_1,T_2,\ldots,T_{|S|}) $。
2. ある整数 $ 1\ \leq\ i\ \leq\ \min\lbrace\ |S|,\ |T|\ \rbrace $ が存在して、下記の $ 2 $ つがともに成り立つ。 
  - $ (S_1,S_2,\ldots,S_{i-1})\ =\ (T_1,T_2,\ldots,T_{i-1}) $
  - $ S_i $ が $ T_i $ より（数として）小さい。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ P_i\ \leq\ N $
- $ (P_1,P_2,\dots,P_N) $ は $ 1 $ から $ N $ までの整数からなる順列
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i=1 $ として操作を行うと $ (P_1,P_2,P_3)=(2,1,4) $ であり、これを昇順に並び替えると $ (1,2,4) $ となります。よって操作によって $ P_1,P_2,P_3 $ はそれぞれ $ 1,2,4 $ に置き換えられ、 $ P=(1,2,4,3) $ となります。同様に $ i=2 $ として操作を行うと $ P $ は $ (2,1,3,4) $ となります。 これらのうち辞書式順序で大きいのは $ (2,1,3,4) $ であるため、答えは $ (2,1,3,4) $ となります。

## 样例 #1

### 输入

```
4 3

2 1 4 3```

### 输出

```
2 1 3 4```

## 样例 #2

### 输入

```
5 1

3 1 4 2 5```

### 输出

```
3 1 4 2 5```

## 样例 #3

### 输入

```
20 7

9 4 3 1 11 12 13 15 17 7 2 5 6 20 19 18 8 16 14 10```

### 输出

```
9 4 3 1 11 12 13 15 17 7 2 5 6 8 18 19 20 16 14 10```

# AI分析结果

### 题目内容重写

#### [ARC165B] Sliding Window Sort 2

**题目描述**

给定一个由1到N的整数组成的排列 \( P = (P_1, P_2, \dots, P_N) \) 和一个整数 \( K \)。

对排列 \( P \) 进行如下操作：

- 选择一个满足 \( 1 \leq i \leq N - K + 1 \) 的整数 \( i \)，将 \( P_i, P_{i+1}, \dots, P_{i+K-1} \) 升序排序。即，将 \( P_i, P_{i+1}, \dots, P_{i+K-1} \) 替换为它们按升序排列后的结果。

要求对 \( P \) 进行恰好一次上述操作，得到的所有可能排列中，字典序最大的那个排列。

**数列的字典序定义**

数列 \( S = (S_1, S_2, \ldots, S_{|S|}) \) 比数列 \( T = (T_1, T_2, \ldots, T_{|T|}) \) **字典序小**，当且仅当以下条件之一成立：

1. \( |S| < |T| \) 且 \( (S_1, S_2, \ldots, S_{|S|}) = (T_1, T_2, \ldots, T_{|S|}) \)。
2. 存在整数 \( 1 \leq i \leq \min\{ |S|, |T| \} \)，使得：
   - \( (S_1, S_2, \ldots, S_{i-1}) = (T_1, T_2, \ldots, T_{i-1}) \)，
   - \( S_i < T_i \)。

**输入格式**

第一行输入两个整数 \( N \) 和 \( K \)，第二行输入排列 \( P \)。

**输出格式**

输出操作后字典序最大的排列。

**样例**

输入：
```
4 3
2 1 4 3
```
输出：
```
2 1 3 4
```

### 题解分析与结论

#### 综合分析与结论

本题的核心在于如何在一次排序操作后，使得排列的字典序最大化。由于排序操作会将选定的区间升序排列，因此排序后的排列字典序不会比原排列更大。因此，如果原排列中存在一个长度为 \( K \) 的递增子序列，那么直接输出原排列即可。否则，我们需要找到一个排序区间，使得排序后排列的字典序尽可能大。

各题解的思路主要集中在以下几点：

1. **贪心策略**：尽量选择靠后的区间进行排序，以保留尽可能长的前缀不变。
2. **单调性分析**：通过分析区间内的单调性，找到最优的排序区间。
3. **数据结构优化**：使用线段树、ST表等数据结构来快速查询区间最小值，优化时间复杂度。

#### 所选高星题解

1. **作者：EuphoricStar (4星)**
   - **关键亮点**：通过分析排序后排列的字典序变化，提出了一种贪心策略，利用前缀最小值和单调递增子段来找到最优的排序区间。代码实现简洁，时间复杂度为 \( O(n) \)。
   - **代码核心**：
     ```cpp
     // 找出以 n - k 为右端点的最长递增子段
     for (int i = n - k, la = N; i >= 1; --i) 
         if (a[i] > la) { pos = i + 1; break; } else la = a[i];
     // 找出最小的 l，对 [l, l + k - 1] 排序
     for (int i = pos; i <= n - k; ++i) 
         if (pre[i + k - 1] > a[n - k]) { ans = i; break; }
     sort(a + ans, a + ans + k);
     ```

2. **作者：lzyqwq (4星)**
   - **关键亮点**：通过维护前缀最小值和单调递增子段，找到最优的排序区间。代码实现清晰，时间复杂度为 \( O(n) \)。
   - **代码核心**：
     ```cpp
     // 找出最小的 l，对 [l, l + k - 1] 排序
     for (int i = n - k; i >= 1; --i) 
         if (a[i] > a[i + 1]) break;
         else if (a[n - k] < pre[i + k - 1]) ans = i;
     sort(a + ans, a + ans + k);
     ```

3. **作者：__Star_Sky (4星)**
   - **关键亮点**：通过贪心策略和单调性分析，找到最优的排序区间。代码实现简洁，时间复杂度为 \( O(n \log n) \)。
   - **代码核心**：
     ```cpp
     // 找出最小的 l，对 [l, l + k - 1] 排序
     for (int i = n - k; i >= 1; --i) 
         if (a[i] > a[i + 1]) break;
         else if (a[n - k] < get_min(n - k + 1, i + k - 1)) ans = i;
     sort(a + ans, a + ans + k);
     ```

### 最优关键思路与技巧

1. **贪心策略**：尽量选择靠后的区间进行排序，以保留尽可能长的前缀不变。
2. **单调性分析**：通过分析区间内的单调性，找到最优的排序区间。
3. **数据结构优化**：使用线段树、ST表等数据结构来快速查询区间最小值，优化时间复杂度。

### 拓展与举一反三

类似题目：
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得摘录

- **EuphoricStar**：赛时代码赛后被 hack 了，发现对子段排序不会使排列的字典序变大。
- **lzyqwq**：场上吃了九发，发现数据很水，各种奇怪解法都能过。
- **Flandres**：赛时挂了无数发，赛后又被加的数据 hack 了，发现贪心策略需要更细致的分析。

总结：在竞赛中，贪心策略和单调性分析是解决此类问题的关键，但需要注意细节，避免被 hack。

---
处理用时：51.33秒
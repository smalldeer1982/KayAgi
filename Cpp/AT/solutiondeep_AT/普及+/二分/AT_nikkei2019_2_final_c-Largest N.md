# 题目信息

# Largest N

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-2-final/tasks/nikkei2019_2_final_c

$ H $ 行 $ W $ 列 のマス目があり、それぞれのマスは黒または白で塗られています。上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,\ j) $ と呼びます。

マス $ (a_i,\ b_i)\ (1\ \leq\ i\ \leq\ K) $ は白で塗られており、それ以外の $ H\ \times\ W\ -\ K $ マスは黒で塗られています。

$ 1 $ 以上の整数 $ k $ に対してマス目がサイズ $ k $ の `N` を含むとは、次の条件をみたす整数 $ i,\ j $ が存在することを言います。

- マス $ (i\ +\ t,\ j)\ (0\ \leq\ t\ <\ k) $ がすべて黒
- マス $ (i\ +\ t,\ j\ +\ t)\ (0\ \leq\ t\ <\ k) $ がすべて黒
- マス $ (i\ +\ t,\ j\ +\ k\ -\ 1)\ (0\ \leq\ t\ <\ k) $ がすべて黒

ただし、この条件に関わる全てのマスが $ H $ 行 $ W $ 列のマス目に含まれなければなりません。

このマス目に含まれる `N` のサイズの最大値を求めてください。ただし、どのサイズの `N` も含まない場合は、$ 0 $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 3000 $
- $ 0\ \leq\ K\ \leq\ \mathrm{min}(H\ \times\ W,\ 2\ \times\ 10^5) $
- $ 1\ \leq\ a_i\ \leq\ H $
- $ 1\ \leq\ b_i\ \leq\ W $
- $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j)\ (i\ \neq\ j) $
- 入力は全て整数である

### Sample Explanation 1

マス目は以下の状態になっています。(`#` が黒、`.` が白で塗られていることを表しています) ``` ##.# #### ##.# ``` このとき、$ i\ =\ 1,\ j\ =\ 2 $ とすれば $ k\ =\ 3 $ に対して条件を満たすのでこのマス目はサイズ $ 3 $ の `N` を含み、これが最大です。

### Sample Explanation 2

マス目は以下の状態になっています。 ``` .. .. ``` どのサイズの `N` も含まれないので、$ 0 $ を出力してください。

### Sample Explanation 3

マス目は以下の状態になっています。 ``` .# #. ``` $ i\ =\ 2,\ j\ =\ 1 $ または $ i\ =\ 1,\ j\ =\ 2 $ とすれば $ k\ =\ 1 $ に対して条件を満たします。

### Sample Explanation 4

マス目は以下の状態になっています。 ``` ##.# ##.# #.## #..# ```

## 样例 #1

### 输入

```
3 4 2

1 3

3 3```

### 输出

```
3```

## 样例 #2

### 输入

```
2 2 4

2 1

1 1

1 2

2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
2 2 2

1 1

2 2```

### 输出

```
1```

## 样例 #4

### 输入

```
4 4 5

2 3

1 3

4 2

4 3

3 2```

### 输出

```
4```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个 $H$ 行 $W$ 列的矩阵，矩阵中的每个格子被涂成黑色或白色。其中，$K$ 个格子 $(a_i, b_i)$（$1 \leq i \leq K$）被涂成白色，其余 $H \times W - K$ 个格子被涂成黑色。

对于正整数 $k$，若矩阵中包含一个大小为 $k$ 的 `N` 形，则满足以下条件：

1. 格子 $(i + t, j)$（$0 \leq t < k$）全部为黑色。
2. 格子 $(i + t, j + t)$（$0 \leq t < k$）全部为黑色。
3. 格子 $(i + t, j + k - 1)$（$0 \leq t < k$）全部为黑色。

其中，所有涉及的格子必须在矩阵范围内。

求矩阵中包含的 `N` 形的最大大小。若不存在任何 `N` 形，则输出 $0$。

#### 说明/提示

##### 约束

- $1 \leq H, W \leq 3000$
- $0 \leq K \leq \min(H \times W, 2 \times 10^5)$
- $1 \leq a_i \leq H$
- $1 \leq b_i \leq W$
- $(a_i, b_i) \neq (a_j, b_j)$（$i \neq j$）
- 输入均为整数

##### 样例解释

**样例1**  
输入：  
```
3 4 2
1 3
3 3
```  
输出：  
```
3
```  
解释：  
矩阵如下：  
```
##.#
####
##.#
```  
当 $i=1, j=2$ 时，$k=3$ 满足条件。

**样例2**  
输入：  
```
2 2 4
2 1
1 1
1 2
2 2
```  
输出：  
```
0
```  
解释：  
矩阵如下：  
```
..
..
```  
不存在任何 `N` 形。

**样例3**  
输入：  
```
2 2 2
1 1
2 2
```  
输出：  
```
1
```  
解释：  
矩阵如下：  
```
.#
#.
```  
当 $i=2, j=1$ 或 $i=1, j=2$ 时，$k=1$ 满足条件。

**样例4**  
输入：  
```
4 4 5
2 3
1 3
4 2
4 3
3 2
```  
输出：  
```
4
```

### 题解分析与结论

#### 题解对比

1. **nueryim 的题解**
   - **思路**：预处理每个格子向上和斜向左上方的连续黑色格子数，然后枚举 `N` 形的右下角，并检查是否满足条件。
   - **优化**：通过预处理减少重复计算，时间复杂度为 $O(n^3)$，但实际运行较快。
   - **评分**：4星
   - **关键亮点**：预处理技巧，减少重复计算。

2. **phil071128 的题解**
   - **思路**：枚举 `N` 形的左上角，使用二分和线段树来找到满足条件的最大 `k`。
   - **优化**：使用线段树进行区间查询和更新，时间复杂度为 $O(nm \log m)$。
   - **评分**：3星
   - **关键亮点**：线段树的应用，但代码复杂度较高。

3. **a_blue_cell 的题解**
   - **思路**：预处理每个格子向下和斜向右下方的连续黑色格子数，然后枚举 `N` 形的左上角，并检查是否满足条件。
   - **优化**：通过预处理减少重复计算，时间复杂度为 $O(n^3)$。
   - **评分**：3星
   - **关键亮点**：预处理技巧，但代码复杂度较高。

#### 最优关键思路

- **预处理技巧**：通过预处理每个格子的连续黑色格子数，减少重复计算，提高效率。
- **枚举与检查**：枚举 `N` 形的右下角或左上角，并通过预处理结果快速检查是否满足条件。

#### 扩展思路

- **动态规划**：可以考虑使用动态规划来进一步优化时间复杂度。
- **二分查找**：在枚举 `k` 时，可以使用二分查找来减少不必要的计算。

#### 推荐题目

1. **洛谷 P1880 [NOI1995]石子合并**（题号：P1880）
2. **洛谷 P1040 加分二叉树**（题号：P1040）
3. **洛谷 P1020 导弹拦截**（题号：P1020）

### 精选题解

#### nueryim 的题解

**星级**：4星  
**关键亮点**：预处理技巧，减少重复计算。

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int read()
{
    int res = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = -1;
    for (; isdigit(ch); ch = getchar())
        res = (res << 3) + (res << 1) + (ch - '0');
    return res * f;
}

const int N = 3005;

int n, m, k, ans;
int up[N][N], sli[N][N];
bool mp[N][N];

int main()
{
    n = read(), m = read(), k = read();
    for (int i = 1, x, y; i <= k; i ++)
    {
        x = read(), y = read();
        mp[x][y] = 1;
    }
    //预处理
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
            if (!mp[i][j])
            {
                up[i][j] = up[i - 1][j] + 1;
                sli[i][j] = sli[i - 1][j - 1] + 1;
            }
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
        {
            int tmp = min(up[i][j], sli[i][j]);
            if (mp[i][j] || tmp <= ans)
                continue;
            //只枚举能够对答案有贡献的k
            for (int k = ans; k <= tmp && j - k + 1 >= 1 && i - k + 1 >= 1; k ++)
                if (up[i][j - k + 1] >= k)
                    ans = max(ans, k);
        }
    printf("%d\n", ans);

    return 0;
}
```

**核心实现思想**：预处理每个格子的向上和斜向左上方的连续黑色格子数，然后枚举 `N` 形的右下角，并检查是否满足条件。

---
处理用时：61.29秒
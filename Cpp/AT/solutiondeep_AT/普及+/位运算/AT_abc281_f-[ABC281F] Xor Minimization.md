# 题目信息

# [ABC281F] Xor Minimization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc281/tasks/abc281_f

非負整数列 $ A=(a_1,\ldots,a_N) $ が与えられます。

$ A $ に対して次の操作をちょうど $ 1 $ 回行います。

- 非負整数 $ x $ を選ぶ。そして、$ i=1,\ldots,N $ すべてに対し、$ a_i $ の値を「$ a_i $ と $ x $ のビット単位 xor」に置き換える。
 
操作後の $ A $ に含まれる値の最大値を $ M $ とします。$ M $ の最小値を求めてください。

 ビット単位 xor とは 非負整数 $ A,\ B $ のビット単位 xor 、$ A\ \oplus\ B $ は、以下のように定義されます。 - $ A\ \oplus\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。

 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \oplus\ 101\ =\ 110 $)。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1.5\ \times\ 10^5 $
- $ 0\ \leq\ a_i\ \lt\ 2^{30} $
- 入力はすべて整数
 
### Sample Explanation 1

$ x=2 $ として操作をすると、操作後の数列は $ (12\ \oplus\ 2,18\ \oplus\ 2,\ 11\ \oplus\ 2)\ =\ (14,16,9) $ となり、最大値 $ M $ は $ 16 $ となります。 $ M $ を $ 16 $ より小さくすることは出来ないため、この値が答えです。

## 样例 #1

### 输入

```
3

12 18 11```

### 输出

```
16```

## 样例 #2

### 输入

```
10

0 0 0 0 0 0 0 0 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
5

324097321 555675086 304655177 991244276 9980291```

### 输出

```
805306368```

# AI分析结果

### 题目翻译
给定一个非负整数序列 $A=(a_1,\ldots,a_N)$。
对 $A$ 恰好执行一次以下操作：
- 选择一个非负整数 $x$。然后，对于所有的 $i = 1,\ldots,N$，将 $a_i$ 的值替换为 $a_i$ 与 $x$ 的按位异或结果。

设操作后 $A$ 中包含的值的最大值为 $M$，请求出 $M$ 的最小值。

按位异或的定义：非负整数 $A$ 和 $B$ 的按位异或 $A \oplus B$ 定义如下：在 $A \oplus B$ 的二进制表示中，$2^k$（$k \geq 0$）位上的数字，若 $A$ 和 $B$ 的二进制表示中 $2^k$ 位上的数字只有一个为 $1$，则该位为 $1$；否则为 $0$。

例如，$3 \oplus 5 = 6$（二进制表示：$011 \oplus 101 = 110$）。

### 综合分析与结论
这些题解主要围绕如何选择合适的 $x$ 使操作后序列的最大值最小展开，核心思路都是按位考虑，利用异或运算的性质和分治思想。
- **思路**：均从高位到低位逐位分析序列中各数该位的情况，若该位全为 0 或全为 1，可使结果该位为 0；若有 0 有 1，则结果该位为 1，并分情况递归处理。
- **算法要点**：多数采用分治算法，通过递归处理不同情况；部分使用 01 - Trie 树存储和处理数据，便于判断某一位的 0 和 1 分布。
- **解决难点**：关键在于处理某一位有 0 有 1 的情况，通过分情况递归，取两种情况的最小值更新结果。

### 所选题解
- **Pengzt（5 星）**
    - **关键亮点**：思路清晰，详细阐述按位考虑的两种情况，并提出优化传递数组的方法，时间复杂度分析准确。
    - **核心代码**：
```cpp
// 未给出完整代码，但思路核心是从高位到低位考虑每一位
// 若当前位全 0 或全 1，结果该位为 0；否则分情况递归
```
- **Zhaohongrui（4 星）**
    - **关键亮点**：使用 01 - Trie 树解决问题，代码实现简洁，对不同节点情况的处理逻辑清晰。
    - **核心代码**：
```cpp
int query(int x, int dep) {
    if (!son[x][0] &&!son[x][1]) return 0;
    if (!son[x][0]) return query(son[x][1], dep - 1);
    if (!son[x][1]) return query(son[x][0], dep - 1);
    return min(query(son[x][0], dep - 1),query(son[x][1], dep - 1)) | 1 << dep;
}
```
- **EternalHeart1314（4 星）**
    - **关键亮点**：思路清晰，代码使用 `vector` 存储数据，递归实现分治，注释详细，便于理解。
    - **核心代码**：
```cpp
int dfs(VI a, int bit) {
    if(!bit) {
        return 0;
    }
    -- bit;
    VI b, c;
    for(auto i : a) {
        if(i >> bit & 1) {
            b.push_back(i);
        } else {
            c.push_back(i);
        }
    }
    if(b.empty()) {
        return dfs(c, bit);
    } else if(c.empty()) {
        return dfs(b, bit);
    }
    return min(dfs(b, bit), dfs(c, bit)) + (1 << bit);
}
```

### 最优关键思路或技巧
- **按位分治**：按位从高到低考虑，利用异或运算性质分情况处理，降低问题复杂度。
- **01 - Trie 树**：存储和处理二进制数据，方便判断某一位的 0 和 1 分布，提高查找和处理效率。

### 拓展思路
同类型题可考虑其他位运算操作，如按位与、按位或等，或结合其他算法，如动态规划、贪心算法等。类似算法套路可用于解决其他需要按位处理的问题，如寻找满足特定位运算条件的最大/最小值等。

### 推荐题目
1. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)
2. [P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865)（结合位运算和 RMQ 问题）
3. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)

### 个人心得摘录与总结
- **Zhaohongrui**：萌新第一篇题解求过，体现新手分享题解的积极态度。
- **_JF_**：最初考虑贪心有缺陷，后转换思路用 dp 解决，说明遇到问题时可尝试不同思路。 

---
处理用时：29.49秒
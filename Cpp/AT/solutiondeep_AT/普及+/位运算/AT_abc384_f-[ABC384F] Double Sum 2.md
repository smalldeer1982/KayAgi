# 题目信息

# [ABC384F] Double Sum 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_f

正整数 $ x $ に対して $ f(x) $ を「 $ x $ が偶数である間 $ x $ を $ 2 $ で割り続けたときの、最終的な $ x $ の値」として定義します。例えば $ f(4)=f(2)=f(1)=1 $ 、 $ f(12)=f(6)=f(3)=3 $ です。

長さ $ N $ の整数列 $ A=(A_1,A_2,\ldots,\ A_N) $ が与えられるので、 $ \displaystyle\ \sum_{i=1}^N\ \sum_{j=i}^N\ f(A_i+A_j) $ を求めてください。

## 说明/提示

### 制約

- $ 1\le\ N\le\ 2\times\ 10^5 $
- $ 1\le\ A_i\le\ 10^7 $
- 入力は全て整数
 
### Sample Explanation 1

$ f(A_1+A_1)=f(8)=1 $ 、 $ f(A_1+A_2)=f(12)=3 $ 、 $ f(A_2+A_2)=f(16)=1 $ です。したがって、 $ 1+3+1=5 $ を出力してください。

## 样例 #1

### 输入

```
2

4 8```

### 输出

```
5```

## 样例 #2

### 输入

```
3

51 44 63```

### 输出

```
384```

## 样例 #3

### 输入

```
8

577752 258461 183221 889769 278633 577212 392309 326001```

### 输出

```
20241214```

# AI分析结果

### 题目中文重写
#### [ABC384F] Double Sum 2

### 题目描述
对于正整数 $x$，定义 $f(x)$ 为「当 $x$ 为偶数时，持续将 $x$ 除以 $2$，最终得到的 $x$ 的值」。例如，$f(4)=f(2)=f(1)=1$，$f(12)=f(6)=f(3)=3$。

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\ldots,A_N)$，请计算 $\displaystyle\ \sum_{i=1}^N\ \sum_{j=i}^N\ f(A_i+A_j)$。

### 说明/提示
#### 制约束
- $1\leq N\leq 2\times 10^5$
- $1\leq A_i\leq 10^7$
- 输入均为整数

#### 样例解释 1
$f(A_1 + A_1)=f(8)=1$，$f(A_1 + A_2)=f(12)=3$，$f(A_2 + A_2)=f(16)=1$。因此，应输出 $1 + 3 + 1 = 5$。

### 样例 #1
#### 输入
```
2
4 8
```
#### 输出
```
5
```

### 样例 #2
#### 输入
```
3
51 44 63
```
#### 输出
```
384
```

### 样例 #3
#### 输入
```
8
577752 258461 183221 889769 278633 577212 392309 326001
```
#### 输出
```
20241214
```

### 综合分析与结论
这些题解大多采用“正难则反”的思路，通过容斥原理，先计算总和，再减去多余部分。具体做法上，各题解围绕枚举 $2$ 的幂次 $2^k$，统计满足 $2^k\mid (A_i + A_j)$ 的数对 $(i, j)$ 的和，进而求出答案。部分题解使用桶、`map` 或字典树等数据结构辅助计算。

### 所选题解
- **作者：KazamaRuri（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过枚举末尾 $0$ 的个数，利用桶和差分计算贡献，时间复杂度为 $O(n\log V)$。
    - **核心代码**：
```cpp
for(int k=24;~k;k--){
    ll s=(1<<k)-1;
    for(int i=1;i<=n;i++){
        t[a[i]&s]+=a[i],c[a[i]&s]++,
        f[k]+=t[inv(a[i],s)]+c[inv(a[i],s)]*a[i];
    }
    for(int i=1;i<=n;i++) t[a[i]&s]=c[a[i]&s]=0;
    ans+=f[k]-f[k+1]>>k;
}
```
    - **核心实现思想**：枚举末尾 $0$ 的个数 $k$，用 $t$ 数组记录模 $2^k$ 相同的数的和，$c$ 数组记录个数。通过 $inv$ 函数计算互补的余数，累加贡献到 $f[k]$ 中。最后通过差分得到恰好有 $k$ 个末尾 $0$ 的和，右移 $k$ 位后累加到答案中。

- **作者：2022dyx（4星）**
    - **关键亮点**：思路独特，从函数 $f(x)$ 的性质出发，将需要减去的部分转化为 $\displaystyle \sum _ {k = 1} ^ {y} \frac {1} {2 ^ k} $，通过 `map` 记录每一个权值下的个数与权值和来计算。
    - **核心代码**：
```cpp
for (int i = 2; i < 2e7; i <<= 1) {
    int now = 0;
    for (int j = 1; j <= n; ++j) {
        ++cnt[a[j] % i];
        mp[a[j] % i] += a[j];
        now += mp[(i - a[j] % i) % i] + a[j] * cnt[(i - a[j] % i) % i];
    }
    for (int j = 1; j <= n; ++j) {
        --cnt[a[j] % i];
        mp[a[j] % i] -= a[j];
    }
    ans -= now / i;
}
```
    - **核心实现思想**：枚举 $2$ 的幂次 $i$，用 `cnt` 数组记录模 $i$ 相同的数的个数，`mp` 数组记录和。遍历数组 $A$，统计满足 $i\mid (A_i + A_j)$ 的数对 $(i, j)$ 的和 $now$，最后从答案中减去 $now / i$。

- **作者：Moya_Rao（4星）**
    - **关键亮点**：思路详细，适合初学者，通过具体例子解释了如何利用余数判断两个数的和是否为 $2^k$ 的倍数，避免了 $O(N^2)$ 的枚举。
    - **核心代码**：
```cpp
for(int k=2;k<=mx*2;k*=2){
    memset(cnt,0,sizeof(cnt));
    memset(sum,0,sizeof(sum));
    for(int i=1;i<=n;i++){
        int zm=a[i]%k,fm=(k-a[i]%k)%k;
        if(cnt[fm])ans-=(sum[fm]+cnt[fm]*a[i])/k;
        cnt[zm]++,sum[zm]+=a[i];
    }
}
```
    - **核心实现思想**：枚举 $2$ 的幂次 $k$，用 $cnt$ 数组记录模 $k$ 相同的数的个数，$sum$ 数组记录和。遍历数组 $A$，计算与当前数相加为 $k$ 的倍数的数的贡献，从答案中减去。

### 最优关键思路或技巧
- **正难则反**：直接计算 $f(A_i + A_j)$ 较困难，通过容斥原理，先计算总和，再减去多余部分。
- **枚举 $2$ 的幂次**：通过枚举 $2^k$，统计满足 $2^k\mid (A_i + A_j)$ 的数对 $(i, j)$ 的和，进而求出答案。
- **利用余数判断倍数关系**：避免了 $O(N^2)$ 的枚举，通过余数判断两个数的和是否为 $2^k$ 的倍数。

### 可拓展之处
同类型题可考虑其他函数 $f(x)$ 的计算，如 $f(x)$ 为 $x$ 抹去二进制末尾连续的 $1$ 后的结果。类似算法套路可用于处理涉及数论函数和求和的问题，通过枚举特定因子或幂次，利用余数和桶等数据结构优化计算。

### 洛谷推荐题目
- [P1463 [POI2002][HAOI2007]反素数](https://www.luogu.com.cn/problem/P1463)：涉及数论函数和枚举因子。
- [P2152 [SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)：涉及数论和高精度计算。
- [P2568 GCD](https://www.luogu.com.cn/problem/P2568)：涉及数论函数和求和。

### 个人心得摘录与总结
- **作者：Moya_Rao**：原本不会做此题，看题解也看不懂，经过自己一整天的琢磨，终于想透了做法。总结出“正难则反”的思路，通过容斥原理解决问题。这表明遇到难题时，要多思考，尝试不同的思路，同时可以结合具体例子帮助理解。

---
处理用时：48.62秒
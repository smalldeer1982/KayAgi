# 题目信息

# [AGC020C] Median Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc020/tasks/agc020_c

$ N $ 個の整数 $ A_1 $, $ A_2 $, ..., $ A_N $ が与えられます。

$ A $ のすべての空でない部分列について、それぞれの和を考えます。このような和は $ 2^N\ -\ 1 $ 個存在し、この個数は奇数です。

これらの和を昇順に並べたものを $ S_1 $, $ S_2 $, ..., $ S_{2^N\ -\ 1} $ とします。

これらの中央値、$ S_{2^{N-1}} $ を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2000 $
- $ 1\ \leq\ A_i\ \leq\ 2000 $
- 入力値はすべて整数である。

### Sample Explanation 1

この場合、$ S\ =\ (1,\ 1,\ 2,\ 2,\ 3,\ 3,\ 4) $ となり、中央値は $ S_4\ =\ 2 $ です。

### Sample Explanation 2

この場合、$ S\ =\ (58) $ となります。

## 样例 #1

### 输入

```
3

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
1

58```

### 输出

```
58```

# AI分析结果

### 题目内容中文重写
# [AGC020C] 中位数和

## 题目描述
[problemUrl]: https://atcoder.jp/contests/agc020/tasks/agc020_c

给定 $N$ 个整数 $A_1$，$A_2$，...，$A_N$。

考虑 $A$ 的所有非空子集的元素和。这样的和共有 $2^N - 1$ 个，且这个数量是奇数。

将这些和按升序排列，记为 $S_1$，$S_2$，...，$S_{2^N - 1}$。

请求出这些和的中位数 $S_{2^{N - 1}}$。

## 说明/提示

### 限制条件
- $1 \leq N \leq 2000$
- $1 \leq A_i \leq 2000$
- 输入值均为整数。

### 示例解释 1
在这种情况下，$S = (1, 1, 2, 2, 3, 3, 4)$，中位数是 $S_4 = 2$。

### 示例解释 2
在这种情况下，$S = (58)$。

## 样例 #1

### 输入
```
3
1 2 1
```

### 输出
```
2
```

## 样例 #2

### 输入
```
1
58
```

### 输出
```
58
```

### 综合分析与结论
- **思路**：大部分题解都利用了子集和的对称性。设所有数的总和为 $sum$，对于任意一个权值为 $x$ 的子序列，一定存在一个权值为 $sum - x$ 的子序列。因此，所有子序列的权值在 $\lfloor \frac{sum}{2}\rfloor$ 左右两边是对称的。由于不考虑空序列，中位数一定是权值大于等于 $\lceil \frac{sum}{2}\rceil$ 的子序列中权值最小的那一个。
- **算法要点**：采用 01 背包的思想，设 $f[j]$ 表示是否可以用给定的数组成和为 $j$。状态转移方程为 $f[j] = f[j] | f[j - a[i]]$，可以用 `bitset` 进行优化，将时间复杂度从 $O(ns)$ 优化到 $O(\frac{ns}{64})$。
- **解决难点**：本题的难点在于如何高效地找出所有非空子序列的和，并利用其对称性找到中位数。使用 `bitset` 可以在常数时间内完成状态转移，避免了普通数组的遍历，从而提高了效率。

### 所选题解
- **作者：紫题 (赞：14)，4星**
    - **关键亮点**：思路清晰，代码简洁，直接使用 `bitset` 进行 01 背包的状态转移，通过对称性快速找到中位数。
```cpp
#include<iostream>
#include<bitset>
using namespace std;
int n,x,sum;
bitset<2000007>f;
int main(){
    cin>>n;
    f[0]=1;
    for(int i=1;i<=n;i++){
        cin>>x;
        f|=f<<x;
        sum+=x;
    }
    for(int i=(sum+1)/2;i<=sum;i++){
        if(f[i]) {cout<<i<<endl;break;}
    }
    return 0;
}
```
核心实现思想：首先将 `f[0]` 初始化为 1，表示可以组成和为 0。然后遍历每个数 $x$，将 `f` 左移 $x$ 位并与原 `f` 进行按位或操作，更新 `f` 数组。最后从 $\lceil \frac{sum}{2}\rceil$ 开始遍历，找到第一个可以组成的和即为中位数。

- **作者：ezoixx130 (赞：7)，4星**
    - **关键亮点**：详细解释了题意和思路，代码规范，同样利用 `bitset` 优化 01 背包，通过对称性找到中位数。
```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 2010

bitset<2000010> f;
int a[MAXN],n,sum;

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%d",a+i),sum+=a[i];
    f[0]=1;
    for(int i=n;i>=1;--i)f|=f<<a[i];
    for(int i=(sum+1)>>1;i<=sum;++i)
        if(f[i])
        {
            printf("%d\n",i);
            return 0;
        }
}
```
核心实现思想：先读取输入并计算总和 $sum$，将 `f[0]` 初始化为 1。然后从后往前遍历每个数，更新 `f` 数组。最后从 $\lceil \frac{sum}{2}\rceil$ 开始遍历，找到第一个可以组成的和即为中位数。

- **作者：Push_Y (赞：1)，4星**
    - **关键亮点**：对 `bitset` 的使用进行了详细解释，使用快读提高输入效率，代码简洁明了。
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gin(){
    char c=getchar();
    int s=0,f=1;
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        s=(s<<3)+(s<<1)+(c^48);
        c=getchar();
    }
    return s*f;
}

bitset<2000005>f;
int n,sum;

int main(){
    n=gin();
    f[0]=1;
    for(int i=1;i<=n;i++){
        int x=gin();
        sum+=x;
        f|=f<<x;
    }
    for(int i=(sum+1)>>1;i<=sum;i++)
        if(f[i]){
            printf("%d\n",i);
            return 0;
        }
    return 0;
}
```
核心实现思想：使用快读读取输入，将 `f[0]` 初始化为 1。遍历每个数 $x$，更新 `f` 数组并计算总和 $sum$。最后从 $\lceil \frac{sum}{2}\rceil$ 开始遍历，找到第一个可以组成的和即为中位数。

### 最优关键思路或技巧
- **思维方式**：利用子集和的对称性，将问题转化为找到第一个大于等于 $\lceil \frac{sum}{2}\rceil$ 的可组成的和。
- **算法优化**：使用 `bitset` 优化 01 背包的状态转移，将时间复杂度从 $O(ns)$ 优化到 $O(\frac{ns}{64})$。
- **代码实现技巧**：使用位运算 `|` 和 `<<` 进行状态转移，简洁高效。

### 可拓展之处
同类型题或类似算法套路：
- 子集和问题：判断是否可以从给定的数中选出若干个数，使得它们的和等于目标值。
- 多重背包问题：每个物品有多个数量，求在一定容量限制下的最大价值。
- 01 背包问题的变种：如二维 01 背包、分组 01 背包等。

### 推荐洛谷题目
- P1048 [NOIP2005 普及组] 采药
- P1164 小A点菜
- P1734 最大约数和

### 个人心得摘录与总结
- **作者：华为2X**：提到这道题是毕克讲的毒瘤题目之一，说明本题有一定难度。
- **作者：小木虫**：认为这道题是屑题，但很少有题解讲得具体，自己来写一篇详细的题解，体现了对题解质量的关注。

---
处理用时：44.89秒
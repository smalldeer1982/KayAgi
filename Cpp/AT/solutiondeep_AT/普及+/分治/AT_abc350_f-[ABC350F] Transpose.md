# 题目信息

# [ABC350F] Transpose

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc350/tasks/abc350_f

英大小文字と `(` 、 `)` からなる文字列 $ S=S_1\ S_2\ S_3\ \dots\ S_{|S|} $ が与えられます。  
 文字列 $ S $ 中の括弧は、対応が取れています。

次の操作を、操作ができなくなるまで繰り返します。

- まず、以下の条件を全て満たす整数組 $ (l,r) $ をひとつ選択する。
  - $ l\ <\ r $
  - $ S_l\ = $ `(`
  - $ S_r\ = $ `)`
  - $ S_{l+1},S_{l+2},\dots,S_{r-1} $ は全て英大文字または英小文字である
- $ T=\overline{S_{r-1}S_{r-2}\ \dots\ S_{l+1}} $ とする。
  - 但し、 $ \overline{x} $ は $ x $ の大文字と小文字を反転させた文字列を指す。
- その後、 $ S $ の $ l $ 文字目から $ r $ 文字目までを削除し、削除した位置に $ T $ を挿入する。
 
詳細は入出力例を参照してください。

上記の操作を使って全ての `(` と `)` を除去することができ、最終的な文字列は操作の方法や順序によらないことが証明できます。  
 このとき、最終的な文字列を求めてください。

  「 $ S $ 中の括弧の対応が取れている」とは? まず、正しい括弧列を次の通り定義します。 - 正しい括弧列とは、以下のいずれかの条件を満たす文字列です。
- 空文字列
- ある正しい括弧列 $ A $ が存在して、 `(`, $ A $, `)` をこの順に連結した文字列
- ある空でない正しい括弧列 $ A,B $ が存在して、 $ A,B $ をこの順に連結した文字列
 
 
 $ S $ 中の括弧の対応が取れているとは、 $ S $ 中の `(` と `)` を順序を保って抜き出した時、それが正しい括弧列となることを指す。

## 说明/提示

### 制約

- $ 1\ \le\ |S|\ \le\ 5\ \times\ 10^5 $
- $ S $ は英大小文字と `(` 、 `)` からなる
- $ S $ 中の括弧は対応が取れている
 
### Sample Explanation 1

$ S= $ `((A)y)x` に対して操作を行います。 - $ l=2,r=4 $ を選択します。このとき削除される文字列は `(A)` で、代わりに `a` が挿入されます。 - この操作の結果、 $ S= $ `(ay)x` となります。 - $ l=1,r=4 $ を選択します。このとき削除される文字列は `(ay)` で、代わりに `YA` が挿入されます。 - この操作の結果、 $ S= $ `YAx` となります。 括弧を除去した結果、文字列は `YAx` となったので、これを出力してください。

### Sample Explanation 2

$ S= $ `((XYZ)n(X(y)Z))` に対して操作を行います。 - $ l=10,r=12 $ を選択します。このとき削除される文字列は `(y)` で、代わりに `Y` が挿入されます。 - この操作の結果、 $ S= $ `((XYZ)n(XYZ))` となります。 - $ l=2,r=6 $ を選択します。このとき削除される文字列は `(XYZ)` で、代わりに `zyx` が挿入されます。 - この操作の結果、 $ S= $ `(zyxn(XYZ))` となります。 - $ l=6,r=10 $ を選択します。このとき削除される文字列は `(XYZ)` で、代わりに `zyx` が挿入されます。 - この操作の結果、 $ S= $ `(zyxnzyx)` となります。 - $ l=1,r=9 $ を選択します。このとき削除される文字列は `(zyxnzyx)` で、代わりに `XYZNXYZ` が挿入されます。 - この操作の結果、 $ S= $ `XYZNXYZ` となります。 括弧を除去した結果、文字列は `XYZNXYZ` となったので、これを出力してください。

### Sample Explanation 3

操作結果が空文字列になる場合もあります。

## 样例 #1

### 输入

```
((A)y)x```

### 输出

```
YAx```

## 样例 #2

### 输入

```
((XYZ)n(X(y)Z))```

### 输出

```
XYZNXYZ```

## 样例 #3

### 输入

```
(((()))(()))(())```

### 输出

```
```

## 样例 #4

### 输入

```
dF(qT(plC())NnnfR(GsdccC))PO()KjsiI((ysA)eWW)ve```

### 输出

```
dFGsdccCrFNNnplCtQPOKjsiIwwEysAve```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个由英文字母（大小写）和 `(`、`)` 组成的字符串 $S = S_1 S_2 S_3 \dots S_{|S|}$。字符串 $S$ 中的括号是匹配的。

重复以下操作，直到无法再进行操作为止：

1. 选择一个满足以下条件的整数对 $(l, r)$：
   - $l < r$
   - $S_l = `(`$
   - $S_r = `)`$
   - $S_{l+1}, S_{l+2}, \dots, S_{r-1}$ 都是英文字母（大小写）。
2. 定义 $T = \overline{S_{r-1} S_{r-2} \dots S_{l+1}}$，其中 $\overline{x}$ 表示将 $x$ 的大小写反转后的字符串。
3. 删除 $S$ 中从第 $l$ 个字符到第 $r$ 个字符的部分，并在删除的位置插入 $T$。

最终，所有 `(` 和 `)` 都会被删除，且最终字符串与操作顺序无关。请输出最终字符串。

【说明/提示】

- 字符串中的括号是匹配的，即 `(` 和 `)` 成对出现且顺序正确。
- 最终字符串可能为空。

### 样例

#### 样例 1
**输入：**
```
((A)y)x
```
**输出：**
```
YAx
```

#### 样例 2
**输入：**
```
((XYZ)n(X(y)Z))
```
**输出：**
```
XYZNXYZ
```

#### 样例 3
**输入：**
```
(((()))(()))(())
```
**输出：**
```
```

### 题解分析与结论

#### 综合分析

本题的核心在于处理字符串中的括号对，并对括号内的字符进行反转和大小写转换。由于操作顺序不影响最终结果，我们可以通过递归或栈的方式来处理括号对。以下是各题解的要点总结：

1. **递归处理括号对**：通过递归函数处理每个括号对，递归时记录当前是正序还是倒序输出，并在遇到括号时进行反转。
2. **栈处理括号匹配**：使用栈来匹配括号对，并在匹配到括号对时进行区间翻转和大小写转换。
3. **文艺平衡树**：使用平衡树来处理区间翻转和大小写转换，适合处理大规模数据。

#### 最优关键思路

1. **递归处理**：通过递归函数处理括号对，递归时记录当前输出顺序（正序或倒序），并在遇到括号时进行反转。这种方法思路清晰，代码简洁，适合处理中等规模的数据。
2. **栈处理**：使用栈来匹配括号对，并在匹配到括号对时进行区间翻转和大小写转换。这种方法效率较高，适合处理大规模数据。
3. **文艺平衡树**：使用平衡树来处理区间翻转和大小写转换，适合处理大规模数据，但实现较为复杂。

### 推荐题解

#### 题解1：作者：_Weslie_ (赞：5)
**星级：5**
**关键亮点**：
- 使用递归处理括号对，思路清晰，代码简洁。
- 通过预处理记录每个左括号对应的右括号，实现 $O(1)$ 的区间跳转。
- 通过递归函数 `dfs(l, r, f)` 处理区间 $[l, r]$，并根据 $f$ 的值决定正序或倒序输出。

**核心代码：**
```cpp
void dfs(int l, int r, int f) {
    if(f == 1) {
        for(int i = l; i <= r; i++) {
            if(s[i] == '(') {
                dfs(i + 1, ld[i] - 1, -1);
                i = ld[i];
            } else {
                cout << s[i];
            }
        }
    } else {
        for(int i = r; i >= l; i--) {
            if(s[i] == ')') {
                dfs(rd[i] + 1, i - 1, 1);
                i = rd[i];
            } else {
                if('a' <= s[i] && s[i] <= 'z') cout << char(s[i] - 'a' + 'A');
                else cout << char(s[i] - 'A' + 'a');
            }
        }
    }
}
```

#### 题解2：作者：guanyf (赞：2)
**星级：4**
**关键亮点**：
- 使用分治思想处理括号对，记录每个括号的匹配位置。
- 通过递归函数 `fz(l, r, c)` 处理区间 $[l, r]$，并根据 $c$ 的值决定正序或倒序输出。
- 使用差分数组记录每个字符的大小写反转次数。

**核心代码：**
```cpp
void fz(int l, int r, int c) {
    if(l > r) return;
    if(c) {
        for(int i = r; i >= l; i--) {
            if(it[i]) {
                fz(it[i] + 1, i - 1, c ^ 1);
                i = it[i];
            } else {
                cout << s[i];
            }
        }
    } else {
        for(int i = l; i <= r; i++) {
            if(it[i]) {
                fz(i + 1, it[i] - 1, c ^ 1);
                i = it[i];
            } else {
                cout << s[i];
            }
        }
    }
}
```

#### 题解3：作者：UniGravity (赞：0)
**星级：4**
**关键亮点**：
- 使用文艺平衡树处理区间翻转和大小写转换。
- 通过栈处理括号匹配，并在匹配到括号对时进行区间翻转。
- 使用平衡树维护区间翻转和大小写转换，适合处理大规模数据。

**核心代码：**
```cpp
inline void pushdown(int x) {
    if (!lazy[x]) return;
    lazy[x] = 0, lazy[ch[x][0]] ^= 1, lazy[ch[x][1]] ^= 1;
    val[x] = -val[x]; // 多加的一行
    swap(ch[x][0], ch[x][1]); 
}
```

### 扩展思路与推荐题目

#### 扩展思路
- **递归与分治**：在处理括号匹配问题时，递归和分治是常用的方法，能够有效处理嵌套结构。
- **栈的应用**：栈在处理括号匹配、表达式求值等问题中非常有用，能够高效地处理嵌套结构。
- **文艺平衡树**：在处理大规模数据的区间翻转和大小写转换时，平衡树是一种高效的数据结构。

#### 推荐题目
1. **P3391 文艺平衡树**：考察区间翻转操作，适合练习平衡树的使用。
2. **P1040 表达式求值**：考察栈在处理表达式中的应用，适合练习栈的使用。
3. **P1220 括号匹配**：考察括号匹配问题，适合练习递归和栈的使用。

---
处理用时：55.21秒
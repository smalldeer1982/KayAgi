# 题目信息

# [ABC366E] Manhattan Multifocal Ellipse

## 题目描述

二维平面上有 $N$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$，给你一个正整数 $D$，求有多少组 $(x,y)$ 满足 

$$\sum\limits^N_{i=1}(|x-x_i|+|y-y_i|) \leq D$$

## 说明/提示

- $1 \leq N \leq 2 \times 10^5$

- $0 \leq D \leq 10^6$

- $-10^6 \leq x_i,y_i \leq 10^6$

- 保证对于所有的 $i \ne j$，$(x_i,y_i) \ne (x_j,y_j)$。

- 所有输入均为整数。

## 样例 #1

### 输入

```
2 3

0 0

1 0```

### 输出

```
8```

## 样例 #2

### 输入

```
2 0

0 0

2 0```

### 输出

```
0```

## 样例 #3

### 输入

```
6 100

9 -6

10 -1

2 10

-1 7

-7 5

-1 -4```

### 输出

```
419```

# AI分析结果

### 题目重写
二维平面上有 $N$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$，给你一个正整数 $D$，求有多少组 $(x,y)$ 满足 

$$\sum\limits^N_{i=1}(|x-x_i|+|y-y_i|) \leq D$$

### 说明/提示
- $1 \leq N \leq 2 \times 10^5$
- $0 \leq D \leq 10^6$
- $-10^6 \leq x_i,y_i \leq 10^6$
- 保证对于所有的 $i \ne j$，$(x_i,y_i) \ne (x_j,y_j)$。
- 所有输入均为整数。

### 样例 #1
#### 输入
```
2 3
0 0
1 0
```
#### 输出
```
8
```

### 样例 #2
#### 输入
```
2 0
0 0
2 0
```
#### 输出
```
0
```

### 样例 #3
#### 输入
```
6 100
9 -6
10 -1
2 10
-1 7
-7 5
-1 -4
```
#### 输出
```
419
```

---

### 综合分析与结论
本题的核心是将曼哈顿距离的求和公式拆分为 $x$ 和 $y$ 两个独立的维度，分别计算每个维度上的距离和，然后通过枚举或双指针等技巧来统计满足条件的 $(x, y)$ 对。大多数题解都采用了这一思路，但具体实现上有所不同，主要区别在于如何高效计算每个维度的距离和以及如何优化统计过程。

### 所选高分题解

#### 1. 作者：_ZML_ (★★★★★)
**关键亮点**：
- 详细解释了如何将问题拆分为 $x$ 和 $y$ 两个独立的维度，并给出了清晰的数学推导。
- 使用前缀和和桶排序来优化计算，确保时间复杂度为 $O(V)$，其中 $V$ 是枚举的范围。
- 提供了直观的图示帮助理解距离和的变化。

**核心代码**：
```cpp
for (int i = -2e6; i <= 2e6; i++) {
    now += l, now -= r;
    if (now <= d) cnt[now]++;
    l += mpy[i + 2000000], r -= mpy[i + 2000000];
}
```
**实现思想**：通过维护当前 $x$ 或 $y$ 的左右点数，动态更新距离和，并统计满足条件的点。

#### 2. 作者：Him_shu (★★★★☆)
**关键亮点**：
- 将问题分解为 $x$ 和 $y$ 两个独立的维度，分别计算距离和。
- 使用排序和二分查找来优化统计过程，时间复杂度为 $O(N \log N)$。
- 提供了详细的代码实现和注释，便于理解。

**核心代码**：
```cpp
for (int i = mi; i <= mx; i++) {
    int k = upper_bound(x + 1, x + n + 1, i) - x;
    ax.push_back(i * (k - 1) - xp[k - 1] + xs[k] - i * (n - k + 1));
}
```
**实现思想**：通过二分查找确定当前 $x$ 或 $y$ 的位置，利用前缀和快速计算距离和。

#### 3. 作者：PineappleSummer (★★★★☆)
**关键亮点**：
- 提出了一种自然的思路，将问题拆分为 $x$ 和 $y$ 两个独立的维度。
- 使用排序和前缀和来优化计算，时间复杂度为 $O(V \log N)$。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (int i = Mi; i <= Ma; i++) {
    int l = lower_bound(x + 1, x + n + 1, i) - x;
    X[i] = bx[l] - i * (n - l + 1) + i * (l - 1) - fx[l - 1];
}
```
**实现思想**：通过二分查找确定当前 $x$ 或 $y$ 的位置，利用前缀和快速计算距离和。

### 最优关键思路或技巧
1. **问题拆分**：将曼哈顿距离的求和公式拆分为 $x$ 和 $y$ 两个独立的维度，分别计算距离和。
2. **前缀和与二分查找**：通过排序和前缀和优化计算，利用二分查找快速确定当前 $x$ 或 $y$ 的位置。
3. **双指针与桶排序**：使用双指针或桶排序来统计满足条件的 $(x, y)$ 对，确保时间复杂度在可接受范围内。

### 可拓展之处
- 类似的问题可以扩展到更高维度的空间，如三维或更高维的曼哈顿距离计算。
- 可以结合其他优化技巧，如滑动窗口、动态规划等，进一步优化统计过程。

### 推荐题目
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880) - 考察区间DP和前缀和的应用。
2. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048) - 考察动态规划和背包问题。
3. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090) - 考察贪心算法和优先队列的应用。

---
处理用时：45.62秒
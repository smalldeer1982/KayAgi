# 题目信息

# [AGC015C] Nuske vs Phantom Thnook

## 题目描述

Nuske 现在有一个 $N\times M(N,M\le 2000)$ 的矩阵 $S$，若 $S_{i,j}=1$，那么该处为蓝色，否则为白色，保证所有蓝色格子构成的连通块都是树。

给出 $Q(Q\le 200000)$ 次询问, 每次询问一个子矩阵中蓝色连通块的个数。

## 样例 #1

### 输入

```
3 4 4

1101

0110

1101

1 1 3 4

1 1 3 1

2 2 3 4

1 2 2 4```

### 输出

```
3

2

2

2```

## 样例 #2

### 输入

```
5 5 6

11010

01110

10101

11101

01010

1 1 5 5

1 2 4 5

2 3 3 4

3 3 3 3

3 1 3 5

1 1 3 4```

### 输出

```
3

2

1

1

3

2```

# AI分析结果

### 题目内容重写
Nuske 现在有一个 $N\times M(N,M\le 2000)$ 的矩阵 $S$，若 $S_{i,j}=1$，那么该处为蓝色，否则为白色，保证所有蓝色格子构成的连通块都是树。

给出 $Q(Q\le 200000)$ 次询问, 每次询问一个子矩阵中蓝色连通块的个数。

### 样例 #1

#### 输入

```
3 4 4

1101

0110

1101

1 1 3 4

1 1 3 1

2 2 3 4

1 2 2 4```

#### 输出

```
3

2

2

2```

### 样例 #2

#### 输入

```
5 5 6

11010

01110

10101

11101

01010

1 1 5 5

1 2 4 5

2 3 3 4

3 3 3 3

3 1 3 5

1 1 3 4```

#### 输出

```
3

2

1

1

3

2```

### 题解综合分析与结论
所有题解的核心思路都是利用树的性质：树的连通块数量等于点数减去边数。通过维护二维前缀和来快速计算子矩阵内的点数和边数，从而实现 $O(1)$ 的查询。难点在于如何正确计算边数，特别是如何处理边界情况。

### 所选高星题解

#### 1. 作者：Limit (赞：11)  
**星级：5星**  
**关键亮点：**  
- 详细解释了树的性质与问题的转化思路，清晰易懂。
- 代码实现简洁，二维前缀和的计算逻辑清晰，边界处理得当。
- 提供了完整的代码实现，便于理解与复现。

**核心代码：**
```cpp
int answer=sum[lx][ly]-sum[lx][fy-1]-sum[fx-1][ly]+sum[fx-1][fy-1];
answer-=suml[lx][ly]+suml[fx][fy-1]-suml[lx][fy-1]-suml[fx][ly];
answer-=sumr[lx][ly]+sumr[fx-1][fy]-sumr[lx][fy]-sumr[fx-1][ly];
```
**实现思想：**  
通过二维前缀和计算子矩阵内的点数，再减去竖边和横边的数量，得到连通块的数量。

#### 2. 作者：cyffff (赞：4)  
**星级：4星**  
**关键亮点：**  
- 思路清晰，详细解释了如何通过点数与边数的关系来求解问题。
- 代码实现较为简洁，二维前缀和的计算逻辑清晰。

**核心代码：**
```cpp
int point(int a1,int b1,int a2,int b2){
    return pr1[a2][b2]-pr1[a2][b1-1]-pr1[a1-1][b2]+pr1[a1-1][b1-1];
}
int edge(int a1,int b1,int a2,int b2){
    return pr2[a2][b2]-pr2[a2][b1-1]-pr2[a1-1][b2]+pr2[a1-1][b1-1]-lin[a2][b1]+lin[a1-1][b1]-row[a1][b2]+row[a1][b1-1];
}
```
**实现思想：**  
通过二维前缀和计算子矩阵内的点数与边数，再通过点数减去边数得到连通块的数量。

#### 3. 作者：M_CI (赞：3)  
**星级：4星**  
**关键亮点：**  
- 思路清晰，详细解释了如何通过点数与边数的关系来求解问题。
- 代码实现简洁，二维前缀和的计算逻辑清晰。

**核心代码：**
```cpp
int work (int x1,int y1,int x2,int y2) {
    return (s[x2][y2][0]-s[x1-1][y2][0]-s[x2][y1-1][0]+s[x1-1][y1-1][0])-
           (s[x2][y2][1]-s[x1][y2][1]-s[x2][y1-1][1]+s[x1][y1-1][1])-
           (s[x2][y2][2]-s[x1-1][y2][2]-s[x2][y1][2]+s[x1-1][y1][2]);
}
```
**实现思想：**  
通过二维前缀和计算子矩阵内的点数与边数，再通过点数减去边数得到连通块的数量。

### 最优关键思路或技巧
1. **树的性质应用：** 利用树的连通块数量等于点数减去边数的性质，将问题转化为计算子矩阵内的点数与边数。
2. **二维前缀和：** 通过二维前缀和快速计算子矩阵内的点数与边数，实现 $O(1)$ 的查询。
3. **边界处理：** 在处理边数时，特别注意边界情况，确保计算的准确性。

### 可拓展之处
- **类似问题：** 类似的问题可以出现在其他需要计算子矩阵内某种性质的题目中，如计算子矩阵内某种颜色的连通块数量等。
- **算法套路：** 二维前缀和的应用广泛，可以用于解决各种子矩阵查询问题。

### 推荐题目
1. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)
2. [P3397 地毯](https://www.luogu.com.cn/problem/P3397)
3. [P2280 [HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)

### 个人心得摘录
- **调试经历：** 在处理边数时，边界情况容易出错，需要仔细检查。
- **顿悟感想：** 通过树的性质将问题转化为点数与边数的计算，大大简化了问题的复杂度。

---
处理用时：46.49秒
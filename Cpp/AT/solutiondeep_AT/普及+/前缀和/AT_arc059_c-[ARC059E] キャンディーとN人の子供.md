# 题目信息

# [ARC059E] キャンディーとN人の子供

## 题目描述

AtCoder 幼儿园里有 $N$ 个小朋友，编号 $1\sim N$，Evi 先生要把 $C$ 颗糖果分给他们。

小朋友可以得到任意多颗糖果。如果第 $i$ 个小朋友得到了 $a$ 颗糖，那么他会得到 $x_i^a$ 的愉悦度，其中 $x_i$ 是第 $i$ 个小朋友的兴奋度。幼儿园活跃指数定义为 $N$         个小朋友愉悦度的乘积。

令 $f(x_1,x_2,\cdots,x_N)$ 表示所有分糖果的方案对应的幼儿园活跃指数的和。

现在给出 $A_i,B_i(1\le i\le N)$，求 $\sum_{x_1=A_1}^{B_1} \sum_{x_2=A_2}^{B_2} \cdots \sum_{x_N=A_N}^{B_N} f(x_1,x_2,...,x_N)$，对 $10 ^ 9 + 7$ 取模。

## 样例 #1

### 输入

```
2 3

1 1

1 1```

### 输出

```
4```

## 样例 #2

### 输入

```
1 2

1

3```

### 输出

```
14```

## 样例 #3

### 输入

```
2 3

1 1

2 2```

### 输出

```
66```

## 样例 #4

### 输入

```
4 8

3 1 4 1

3 1 4 1```

### 输出

```
421749```

## 样例 #5

### 输入

```
3 100

7 6 5

9 9 9```

### 输出

```
139123417```

# AI分析结果

### 题目内容重写
AtCoder 幼儿园里有 $N$ 个小朋友，编号 $1\sim N$，Evi 先生要把 $C$ 颗糖果分给他们。

小朋友可以得到任意多颗糖果。如果第 $i$ 个小朋友得到了 $a$ 颗糖，那么他会得到 $x_i^a$ 的愉悦度，其中 $x_i$ 是第 $i$ 个小朋友的兴奋度。幼儿园活跃指数定义为 $N$ 个小朋友愉悦度的乘积。

令 $f(x_1,x_2,\cdots,x_N)$ 表示所有分糖果的方案对应的幼儿园活跃指数的和。

现在给出 $A_i,B_i(1\le i\le N)$，求 $\sum_{x_1=A_1}^{B_1} \sum_{x_2=A_2}^{B_2} \cdots \sum_{x_N=A_N}^{B_N} f(x_1,x_2,...,x_N)$，对 $10 ^ 9 + 7$ 取模。

### 题解分析与结论
各题解的核心思路均为动态规划（DP），通过状态转移方程计算前 $i$ 个小朋友分 $j$ 颗糖果的活跃指数和。难点在于如何处理 $\sum_{x=A_i}^{B_i} x^k$ 的计算，多数题解通过预处理前缀和来优化时间复杂度。

### 精选题解
1. **作者：Sangber (赞：6)**  
   **星级：★★★★★**  
   **关键亮点：**  
   - 使用 DP 状态 $f[i][j]$ 表示前 $i$ 个小朋友分 $j$ 颗糖果的活跃指数和。
   - 通过预处理 $pw[i][j]$ 存储 $i^j$ 的前缀和，优化了 $\sum_{x=A_i}^{B_i} x^k$ 的计算。
   - 代码清晰，注释详细，易于理解。

   **核心代码：**
   ```cpp
   for (rg int i = 1; i <= n; ++i)
       for (rg int j = 0; j <= c; ++j)
           for (rg int k = 0; k <= j; ++k)
               f[i][j] = (f[i][j] + 1ll * f[i - 1][j - k] * (pw[b[i]][k] - pw[a[i] - 1][k] + p) % p) % p;
   ```

2. **作者：Caicz (赞：4)**  
   **星级：★★★★**  
   **关键亮点：**  
   - 同样使用 DP，状态转移方程清晰。
   - 通过预处理 $sum[i][k]$ 存储 $\sum_{x=A_i}^{B_i} x^k$，进一步优化了计算。
   - 代码结构简洁，易于实现。

   **核心代码：**
   ```cpp
   for (register int i = 1; i <= n; ++i)
       for (register int j = 1; j <= m; ++j)
           for (register int k = 0; k <= j; ++k)
               dp[i][j] = (dp[i][j] + (dp[i - 1][j - k] * sum[i][k]) % mod) % mod;
   ```

3. **作者：henry_y (赞：4)**  
   **星级：★★★★**  
   **关键亮点：**  
   - 使用 DP 状态 $f[i][j]$，并通过前缀和优化 $\sum_{x=A_i}^{B_i} x^k$ 的计算。
   - 代码简洁，注释清晰，易于理解。

   **核心代码：**
   ```cpp
   for (int i = 1; i <= n; i ++)
       for (int j = 0; j <= m; j ++)
           for (int k = 0; k <= j; k ++)
               f[i][j] = (f[i][j] + (1ll * f[i - 1][j - k] * (sum[b[i]][k] - sum[a[i] - 1][k]) % mod + mod) % mod) % mod;
   ```

### 最优关键思路
- **动态规划（DP）：** 使用 DP 状态 $f[i][j]$ 表示前 $i$ 个小朋友分 $j$ 颗糖果的活跃指数和。
- **前缀和优化：** 通过预处理 $\sum_{x=A_i}^{B_i} x^k$ 的前缀和，优化了时间复杂度。

### 可拓展之处
- **类似问题：** 类似的问题可以通过 DP 和前缀和优化来解决，尤其是在需要计算区间和的情况下。
- **算法套路：** 这种类型的题目通常可以通过预处理和 DP 来优化时间复杂度，适用于数据范围较大的情况。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)

### 个人心得
- **调试经历：** 多数题解提到在调试过程中需要注意取模运算，尤其是在减法操作中，避免出现负数。
- **踩坑教训：** 预处理时需要注意边界条件，确保前缀和计算的正确性。
- **顿悟感想：** 通过预处理和 DP 的结合，可以有效地优化复杂问题的计算效率。

---
处理用时：42.47秒
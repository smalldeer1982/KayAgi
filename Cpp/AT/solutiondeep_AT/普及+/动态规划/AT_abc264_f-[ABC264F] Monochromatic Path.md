# 题目信息

# [ABC264F] Monochromatic Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc264/tasks/abc264_f

各マスが白または黒で塗られた $ H $ 行 $ W $ 列のグリッドがあります。 $ 1\ \leq\ i\ \leq\ H $ かつ $ 1\ \leq\ j\ \leq\ W $ を満たす整数の組 $ (i,\ j) $ について、 グリッドの上から $ i $ 行目、左から $ j $ 行目のマス（以下、単にマス $ (i,\ j) $ と呼ぶ）の色は $ A_{i,\ j} $ で表されます。 $ A_{i,\ j}\ =\ 0 $ のときマス $ (i,\ j) $ は白色、$ A_{i,\ j}\ =\ 1 $ のときマス $ (i,\ j) $ は黒色です。

「下記の $ 2 $ つの操作のどちらかを行うこと」を好きなだけ（ $ 0 $ 回でも良い）繰り返すことができます。

- $ 1\ \leq\ i\ \leq\ H $ を満たす整数を選び、$ R_i $ 円払った後、グリッドの上から $ i $ 行目にあるそれぞれのマスの色を反転させる（白色のマスは黒色に、黒色のマスは白色に塗り替える）。
- $ 1\ \leq\ j\ \leq\ W $ を満たす整数を選び、$ C_j $ 円払った後、グリッドの左から $ j $ 列目にあるそれぞれのマスの色を反転させる。

下記の条件を満たすようにするためにかかる合計費用の最小値を出力して下さい。

- マス $ (1,\ 1) $ から「現在いるマスの右隣もしくは下隣のマスに移動する」 ことを繰り返してマス $ (H,\ W) $ まで移動する経路であって、通るマス（マス $ (1,\ 1) $ とマス $ (H,\ W) $ も含む）の色がすべて同じであるようなものが存在する。

本問題の制約下において、有限回の操作によって上記の条件を満たすようにすることが可能であることが証明できます。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ 1\ \leq\ R_i\ \leq\ 10^9 $
- $ 1\ \leq\ C_j\ \leq\ 10^9 $
- $ A_{i,\ j}\ \in\ \lbrace\ 0,\ 1\rbrace $
- 入力はすべて整数

### Sample Explanation 1

白色のマスを `0` 、黒色のマスを `1` で表します。 初期状態のグリッドに対し、$ R_2\ =\ 3 $ 円払って上から $ 2 $ 行目にあるそれぞれのマスを反転させると、 ``` 0100 0100 1010 ``` となります。さらに、$ C_2\ =\ 6 $ 円払って左から $ 2 $ 列目にあるそれぞれのマスを反転させると、 ``` 0000 0000 1110 ``` となり、マス $ (1,\ 1) $ からマス $ (3,\ 4) $ への移動経路であって通るマスの色がすべて同じであるようなものが存在する状態になります（例えば $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (2,\ 4)\ \rightarrow\ (3,\ 4) $ という経路）。 かかった合計費用は $ 3+6\ =\ 9 $ 円であり、このときが考えられる中で最小です。

## 样例 #1

### 输入

```
3 4

4 3 5

2 6 7 4

0100

1011

1010```

### 输出

```
9```

## 样例 #2

### 输入

```
15 20

29 27 79 27 30 4 93 89 44 88 70 75 96 3 78

39 97 12 53 62 32 38 84 49 93 53 26 13 25 2 76 32 42 34 18

01011100110000001111

10101111100010011000

11011000011010001010

00010100011111010100

11111001101010001011

01111001100101011100

10010000001110101110

01001011100100101000

11001000100101011000

01110000111011100101

00111110111110011111

10101111111011101101

11000011000111111001

00011101011110001101

01010000000001000000```

### 输出

```
125```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

有一个 $H$ 行 $W$ 列的网格，每个格子被涂成白色或黑色。对于满足 $1 \leq i \leq H$ 且 $1 \leq j \leq W$ 的整数对 $(i, j)$，网格中从上往下第 $i$ 行、从左往右第 $j$ 列的格子（以下简称格子 $(i, j)$）的颜色由 $A_{i,j}$ 表示。当 $A_{i,j} = 0$ 时，格子 $(i, j)$ 是白色；当 $A_{i,j} = 1$ 时，格子 $(i, j)$ 是黑色。

你可以进行以下两种操作任意次（包括零次）：

- 选择一个满足 $1 \leq i \leq H$ 的整数，支付 $R_i$ 元后，将网格中第 $i$ 行的所有格子的颜色反转（白色变为黑色，黑色变为白色）。
- 选择一个满足 $1 \leq j \leq W$ 的整数，支付 $C_j$ 元后，将网格中第 $j$ 列的所有格子的颜色反转。

你需要满足以下条件，并输出所需的最小总费用：

- 存在一条从格子 $(1, 1)$ 出发，只能向右或向下移动，最终到达格子 $(H, W)$ 的路径，且路径上的所有格子（包括起点和终点）的颜色都相同。

在本问题的约束下，可以证明通过有限次操作可以满足上述条件。

#### 说明/提示

##### 约束

- $2 \leq H, W \leq 2000$
- $1 \leq R_i \leq 10^9$
- $1 \leq C_j \leq 10^9$
- $A_{i,j} \in \{0, 1\}$
- 输入均为整数

### 题解分析与结论

#### 综合分析

本题的核心是通过行和列的反转操作，使得从起点到终点的路径上的所有格子颜色相同。由于操作顺序不影响最终结果，且每行或每列最多只需要反转一次，因此可以使用动态规划（DP）来解决。

#### 关键思路

1. **状态设计**：设 `dp[i][j][x][y]` 表示走到格子 $(i, j)$ 时，第 $i$ 行是否反转（$x$），第 $j$ 列是否反转（$y$）的最小费用。
2. **转移方程**：根据当前格子和下一个格子的颜色是否相同，决定是否需要反转行或列，并更新费用。
3. **初始化**：起点的四种状态（行和列是否反转）分别初始化为相应的费用。
4. **最终答案**：在终点的四种状态中取最小值。

#### 最优题解

##### 题解1：作者：allenchoi (5星)

**关键亮点**：
- 清晰的状态设计和转移方程。
- 代码简洁，逻辑清晰，易于理解。
- 通过异或操作简化了颜色判断。

**核心代码**：
```cpp
for(int i = 2;i <= n;i++)
    for(int x = 0;x <= 1;x++)
        for(int y = 0;y <= 1;y++)
            if((A[i][1] ^ x ^ y) == (A[i - 1][1] ^ y)) dp[i][1][x][y] = dp[i - 1][1][0][y] + a[i] * x;
            else dp[i][1][x][y] = dp[i - 1][1][1][y] + a[i] * x;
```

##### 题解2：作者：KazamaRuri (4星)

**关键亮点**：
- 详细的状态转移解释，适合初学者理解。
- 代码结构清晰，易于扩展。

**核心代码**：
```cpp
for(int i = 1;i <= n;i++)
    for(int j = 1;j <= m;j++){
        if(i==1&&j==1) continue;
        for(int p=0;p<2;p++) for(int q=0;q<2;q++)
        for(int u=0;u<2;u++) for(int v=0;v<2;v++){
            if(q==v&&(a[i][j]^p)==(a[i-1][j]^u))
                f[i][j][p][q]=_min(f[i][j][p][q],f[i-1][j][u][v]+p*r[i]);
            if(p==u&&(a[i][j]^q)==(a[i][j-1]^v))
                f[i][j][p][q]=_min(f[i][j][p][q],f[i][j-1][u][v]+q*c[j]);
        }
    }
```

##### 题解3：作者：Tsawke (4星)

**关键亮点**：
- 详细的状态转移解释，适合初学者理解。
- 代码结构清晰，易于扩展。

**核心代码**：
```cpp
for(int i = 1; i <= H; ++i)
    for(int j = 1; j <= W; ++j)
        for(int x = 0; x <= 1; ++x)
            for(int y = 0; y <= 1; ++y){
                if((G[i][j] ^ x ^ y )== (G[i + 1][j] ^ y))dp[i + 1][j][0][y] = min(dp[i + 1][j][0][y], dp[i][j][x][y]);
                else dp[i + 1][j][1][y] = min(dp[i + 1][j][1][y], dp[i][j][x][y] + R[i + 1]);
                if((G[i][j] ^ x ^ y) == (G[i][j + 1] ^ x))dp[i][j + 1][x][0] = min(dp[i][j + 1][x][0], dp[i][j][x][y]);
                else dp[i][j + 1][x][1] = min(dp[i][j + 1][x][1], dp[i][j][x][y] + C[j + 1]);
            }
```

### 最优关键思路与技巧

1. **状态设计**：通过 `dp[i][j][x][y]` 表示当前格子的行和列是否反转，简化了问题的复杂度。
2. **转移方程**：通过异或操作判断颜色是否一致，决定是否需要反转行或列。
3. **初始化**：起点的四种状态分别初始化为相应的费用，确保后续转移的正确性。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要路径颜色一致的问题，如路径上的格子颜色交替等。
2. **优化**：可以通过滚动数组优化空间复杂度，减少内存使用。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

### 个人心得总结

- **调试经历**：在实现过程中，初始状态的设置非常重要，容易忽略起点的四种状态。
- **踩坑教训**：在转移方程中，容易混淆行和列的反转操作，导致结果错误。
- **顿悟感想**：通过异或操作简化了颜色判断，使得代码更加简洁高效。

---
处理用时：54.94秒
# 题目信息

# [ABC265E] Warp

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc265/tasks/abc265_e

$ 2 $ 次元平面の原点に高橋君がいます。  
 高橋君はこれから、ワープを $ N $ 回繰り返します。各ワープでは、以下の $ 3 $ つのうちいずれか $ 1 $ つを行います。

- 現在いる座標 $ (x,y) $ から $ (x+A,y+B) $ に移動する
- 現在いる座標 $ (x,y) $ から $ (x+C,y+D) $ に移動する
- 現在いる座標 $ (x,y) $ から $ (x+E,y+F) $ に移動する

平面上の $ M $ 箇所 $ (X_1,Y_1),\ldots,(X_M,Y_M) $ には障害物があり、これらの座標に移動することはできません。

$ N $ 回のワープによる移動経路として考えられるものは何通りですか？ $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 300 $
- $ 0\ \leq\ M\ \leq\ 10^5 $
- $ -10^9\ \leq\ A,B,C,D,E,F\ \leq\ 10^9 $
- $ (A,B),(C,D),(E,F) $ は相異なる
- $ -10^9\ \leq\ X_i,Y_i\ \leq\ 10^9 $
- $ (X_i,Y_i)\neq(0,0) $
- $ (X_i,Y_i) $ は相異なる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

以下の $ 5 $ 通りが考えられます。 - $ (0,0)\to(1,1)\to(2,3) $ - $ (0,0)\to(1,1)\to(2,4) $ - $ (0,0)\to(1,3)\to(2,4) $ - $ (0,0)\to(1,3)\to(2,5) $ - $ (0,0)\to(1,3)\to(2,6) $

## 样例 #1

### 输入

```
2 2

1 1 1 2 1 3

1 2

2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
10 3

-1000000000 -1000000000 1000000000 1000000000 -1000000000 1000000000

-1000000000 -1000000000

1000000000 1000000000

-1000000000 1000000000```

### 输出

```
0```

## 样例 #3

### 输入

```
300 0

0 0 1 0 0 1```

### 输出

```
292172978```

# AI分析结果

### 题目重写
【题目内容】
# [ABC265E] Warp

## 题目描述

在二维平面的原点处有一个高桥君。高桥君将进行 $N$ 次传送，每次传送可以选择以下三种方式之一：

- 从当前坐标 $(x,y)$ 传送到 $(x+A,y+B)$
- 从当前坐标 $(x,y)$ 传送到 $(x+C,y+D)$
- 从当前坐标 $(x,y)$ 传送到 $(x+E,y+F)$

平面上有 $M$ 个障碍物，坐标为 $(X_1,Y_1),\ldots,(X_M,Y_M)$，高桥君不能传送到这些位置。

问高桥君进行 $N$ 次传送后，可能的路径有多少种？答案对 $998244353$ 取模。

## 说明/提示

### 约束条件

- $1 \leq N \leq 300$
- $0 \leq M \leq 10^5$
- $-10^9 \leq A,B,C,D,E,F \leq 10^9$
- $(A,B),(C,D),(E,F)$ 互不相同
- $-10^9 \leq X_i,Y_i \leq 10^9$
- $(X_i,Y_i) \neq (0,0)$
- $(X_i,Y_i)$ 互不相同
- 输入中的所有值均为整数

### 样例解释 1

以下是可能的 5 种路径：
- $(0,0) \to (1,1) \to (2,3)$
- $(0,0) \to (1,1) \to (2,4)$
- $(0,0) \to (1,3) \to (2,4)$
- $(0,0) \to (1,3) \to (2,5)$
- $(0,0) \to (1,3) \to (2,6)$

## 样例 #1

### 输入

```
2 2

1 1 1 2 1 3

1 2

2 2
```

### 输出

```
5
```

## 样例 #2

### 输入

```
10 3

-1000000000 -1000000000 1000000000 1000000000 -1000000000 1000000000

-1000000000 -1000000000

1000000000 1000000000

-1000000000 1000000000
```

### 输出

```
0
```

## 样例 #3

### 输入

```
300 0

0 0 1 0 0 1
```

### 输出

```
292172978
```

### 题解分析与结论

#### 综合分析
本题的核心在于如何高效地计算高桥君在 $N$ 次传送后的可能路径数，同时避免障碍物。由于坐标范围极大（$10^9$），直接使用二维 DP 会超出内存限制。因此，大多数题解采用了三维 DP 的思路，记录每种传送方式的使用次数，并通过计算当前坐标来判断是否遇到障碍物。

#### 关键思路与技巧
1. **三维 DP 设计**：通过记录三种传送方式的使用次数 $i, j, k$，可以计算出当前坐标 $(i*A + j*C + k*E, i*B + j*D + k*F)$，从而避免直接存储坐标。
2. **障碍物处理**：使用 `map` 或 `unordered_map` 来存储障碍物坐标，判断当前坐标是否为障碍物。
3. **状态转移**：从 $dp[i-1][j][k]$, $dp[i][j-1][k]$, $dp[i][j][k-1]$ 转移过来，确保每次只增加一种传送方式的使用次数。
4. **优化**：通过限制 $i+j+k \leq n$ 来减少不必要的计算。

#### 推荐题解
1. **作者：flying_man (5星)**
   - **亮点**：清晰的三维 DP 设计，使用 `map` 处理障碍物，代码简洁易读。
   - **代码核心**：
     ```cpp
     dp[0][0][0] = 1;
     for(int i = 0; i <= n; i++){
         for(int j = 0; j <= n-i; j++){
             for(int k = 0; k <= n-i-j; k++){
                 ll nx = i*A+j*C+k*E;
                 ll ny = i*B+j*D+k*F;
                 if(p[{nx,ny}] == 1) continue;
                 if(i) dp[i][j][k] += dp[i-1][j][k];
                 if(j) dp[i][j][k] += dp[i][j-1][k];
                 if(k) dp[i][j][k] += dp[i][j][k-1];
                 dp[i][j][k] %= mod;
                 if(i+j+k == n) ans = (ans+dp[i][j][k])%mod;
             }
         }
     }
     ```

2. **作者：FFTotoro (4星)**
   - **亮点**：使用记忆化搜索，思路清晰，代码简洁。
   - **代码核心**：
     ```cpp
     int dfs(int x, int y, int z){
         int x0 = a*x + c*y + e*z, y0 = b*x + d*y + f*z;
         if(s.find({x0, y0}) != s.end()) return 0;
         if(x + y + z == n) return 1;
         if(g[x][y][z]) return g[x][y][z];
         return g[x][y][z] = (dfs(x+1, y, z) + dfs(x, y+1, z) + dfs(x, y, z+1)) % 998244353;
     }
     ```

3. **作者：xiaoPanda (4星)**
   - **亮点**：详细解释了 DP 设计思路，使用 `set` 处理障碍物，代码清晰。
   - **代码核心**：
     ```cpp
     for(int i = 0; i <= n; i++){
         for(int j = 0; j <= n-i; j++){
             for(int k = 0; k <= n-i-j; k++){
                 int x = i*A + j*C + k*E, y = i*B + j*D + k*F;
                 if(s.find({x, y}) != s.end()) continue;
                 if(i) dp[i][j][k] += dp[i-1][j][k];
                 if(j) dp[i][j][k] += dp[i][j-1][k];
                 if(k) dp[i][j][k] += dp[i][j][k-1];
                 dp[i][j][k] %= mod;
             }
         }
     }
     ```

### 扩展思路与推荐题目
1. **扩展思路**：本题的 DP 设计可以推广到其他类似的路径计数问题，尤其是当坐标范围较大时，可以通过记录操作次数来避免直接存储坐标。
2. **推荐题目**：
   - [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)：类似的 DP 设计，记录每种操作的使用次数。
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的背包问题，与本题的 DP 思路有相似之处。
   - [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)：多维 DP 的应用，与本题的三维 DP 设计有相似之处。

---
处理用时：55.70秒
# 题目信息

# [ABC301E] Pac-Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc301/tasks/abc301_e

$ H $ 行 $ W $ 列のグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,j) $ と表します。 グリッドの各マスはスタートマス、ゴールマス、空マス、壁マス、お菓子マスのいずれかです。 $ (i,j) $ が何のマスであるかは文字 $ A_{i,j} $ によって表され、$ A_{i,j}= $ `S` のときスタートマス、 $ A_{i,j}= $ `G` のときゴールマス、 $ A_{i,j}= $ `.` のとき空マス、 $ A_{i,j}= $ `#` のとき壁マス、 $ A_{i,j}= $ `o` のときお菓子マスです。 ここで、スタートマスとゴールマスはちょうど $ 1 $ つずつあり、お菓子マスは **$ 18 $ 個以下**であることが保証されます。

高橋くんは現在スタートマスにいます。 高橋くんは、上下左右に隣接するマスであって壁マスでないマスに移動することを繰り返し行えます。 高橋くんは今から $ T $ 回以下の移動によってゴールマスに到達したいです。 そのようなことは可能かどうか判定してください。 可能な場合は、最終的にゴールマスにいるという条件のもとで、移動の途中に訪れるお菓子マスの数の最大値を求めてください。 ただし、$ 1 $ つのお菓子マスに複数回訪れた場合でも、カウントするのは $ 1 $ 回のみです。

## 说明/提示

### 制約

- $ 1\leq\ H,W\ \leq\ 300 $
- $ 1\ \leq\ T\ \leq\ 2\times\ 10^6 $
- $ H,W,T $ は整数
- $ A_{i,j} $ は `S`, `G`, `.`, `#`, `o` のいずれか
- $ A_{i,j}= $ `S` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `G` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `o` を満たす $ (i,j) $ の組は **$ 18 $ 個以下**
 
### Sample Explanation 1

$ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3)\ \rightarrow\ (1,3) $ と $ 4 $ 回移動すると、 $ 1 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることができます。 $ 5 $ 回以下の移動で $ 2 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることはできないので、$ 1 $ が答えです。 なお、$ (1,1)\ \rightarrow\ (2,1)\ \rightarrow\ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3) $ と移動すると $ 5 $ 回の移動で $ 2 $ 個のお菓子マスを訪れることができますが、最終的にゴールマスにいないため無効であることに注意してください。

### Sample Explanation 2

$ 1 $ 回以下の移動でゴールマスに到達することはできません。

## 样例 #1

### 输入

```
3 3 5

S.G

o#o

.#.```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3 1

S.G

.#o

o#.```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G```

### 输出

```
18```

# AI分析结果

### 题目内容重写

#### [ABC301E] Pac-Takahashi

**题目描述**

有一个 $H$ 行 $W$ 列的网格。从上到下第 $i$ 行、从左到右第 $j$ 列的格子表示为 $(i,j)$。网格中的每个格子是起点、终点、空地、墙壁或糖果之一。$(i,j)$ 的格子类型由字符 $A_{i,j}$ 表示，$A_{i,j}=$ `S` 表示起点，$A_{i,j}=$ `G` 表示终点，$A_{i,j}=$ `.` 表示空地，$A_{i,j}=$ `#` 表示墙壁，$A_{i,j}=$ `o` 表示糖果。起点和终点各有一个，糖果的数量不超过 $18$ 个。

高桥君现在位于起点。他可以通过上下左右移动到相邻的非墙壁格子。高桥君希望在不超过 $T$ 次移动的情况下到达终点。判断是否可能，如果可能，在最终到达终点的条件下，求途中经过的糖果的最大数量。注意，即使多次经过同一个糖果，也只计一次。

**说明/提示**

**约束条件**

- $1\leq H,W\leq 300$
- $1\leq T\leq 2\times 10^6$
- $H,W,T$ 是整数
- $A_{i,j}$ 是 `S`, `G`, `.`, `#`, `o` 之一
- 满足 $A_{i,j}=$ `S` 的 $(i,j)$ 恰好有一个
- 满足 $A_{i,j}=$ `G` 的 $(i,j)$ 恰好有一个
- 满足 $A_{i,j}=$ `o` 的 $(i,j)$ 不超过 $18$ 个

**样例解释**

**样例 1**

输入：

```
3 3 5

S.G

o#o

.#.```

输出：

```
1```

**样例 2**

输入：

```
3 3 1

S.G

.#o

o#.```

输出：

```
-1```

**样例 3**

输入：

```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G```

输出：

```
18```

### 题解分析与结论

#### 综合分析

本题的核心在于如何在给定的移动次数内，从起点到终点，并尽可能多地经过糖果。由于糖果的数量最多为 $18$ 个，因此可以通过状压 DP 来解决。具体思路如下：

1. **预处理**：首先通过 BFS 预处理所有关键点（起点、终点和糖果）之间的最短距离。
2. **状压 DP**：使用状压 DP 来记录在某个状态下，经过某些糖果的最短路径。通过状态转移，更新每个状态的最短路径。
3. **结果计算**：在所有满足条件的路径中，找到经过糖果数量最多的路径。

#### 最优关键思路

1. **预处理最短路径**：通过 BFS 预处理所有关键点之间的最短路径，为后续的 DP 提供基础数据。
2. **状压 DP**：使用状态压缩 DP 来记录经过某些糖果的最短路径，通过状态转移更新路径。
3. **剪枝优化**：在 DP 过程中，通过剪枝优化，减少不必要的计算，提高算法效率。

#### 推荐题目

1. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
2. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 所选高分题解

#### 题解1：DengDuck (赞：9)

**星级**：★★★★★

**关键亮点**：
- 通过 BFS 预处理所有关键点之间的最短路径，为后续的 DP 提供基础数据。
- 使用状压 DP 记录经过某些糖果的最短路径，通过状态转移更新路径。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码**：

```cpp
LL work(LL i,LL j)//求距离
{
    LL sx=pt[i].XX,sy=pt[i].YY,ex=pt[j].XX,ey=pt[j].YY;
    while(!q.empty())q.pop();
    q.push({sx,sy,0});
    memset(vis,0,sizeof(vis));
    while(!q.empty())
    {
        LL tx=q.front().x,ty=q.front().y,num=q.front().num;
        q.pop();
        for(int i=0;i<4;i++)
        {
            LL xx=tx+dx[i],yy=ty+dy[i];
            if(xx<1||n<xx||yy<1||m<yy||a[xx][yy]==1||vis[xx][yy]==1)continue;
            vis[xx][yy]=1;
            q.push({xx,yy,num+1});
            if(xx==ex&&yy==ey)return num+1;
        }
    }
    return INT_MAX;
}
```

#### 题解2：Kylin_ZHH (赞：5)

**星级**：★★★★

**关键亮点**：
- 通过 BFS 预处理所有关键点之间的最短路径，为后续的 DP 提供基础数据。
- 使用状压 DP 记录经过某些糖果的最短路径，通过状态转移更新路径。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码**：

```cpp
int bfs(int sx,int sy,int tx,int ty) {
    memset(d, 0, sizeof d);
    d[sx][sy] = 1;
    static PII f[4] = {{1,0},{0,1},{-1,0},{0,-1}}; 
    queue<PII> q;
    q.push({sx,sy});
    
    while(!q.empty()) {
        auto u = q.front(); q.pop();
        for(const auto& p:f) {
            int nx = u[0] + p[0], ny = u[1] + p[1];
            if(!valid(nx,ny) || d[nx][ny]) continue;
            d[nx][ny] = d[u[0]][u[1]] + 1;
            if(nx==tx && ny==ty) return d[tx][ty] - 1; 
            q.push({nx, ny});
        }
    }
    return 1e7;
}
```

#### 题解3：sunzz3183 (赞：5)

**星级**：★★★★

**关键亮点**：
- 通过 BFS 预处理所有关键点之间的最短路径，为后续的 DP 提供基础数据。
- 使用状压 DP 记录经过某些糖果的最短路径，通过状态转移更新路径。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码**：

```cpp
void bfs(int id){
    e[id][id]=0;
    memset(vis,0,sizeof(vis));
    vis[a[id].x][a[id].y]=1;
    q.push({a[id].x,a[id].y,0});
    while(!q.empty()){
        int x=q.front().x,y=q.front().y,w=q.front().w;q.pop();
        for(int i=0;i<4;i++){
            int tx=x+nxt[i][0],ty=y+nxt[i][1];
            if(tx<1||tx>n||ty<1||ty>m)continue;
            if(c[tx][ty]=='#')continue;
            if(vis[tx][ty])continue;
            vis[tx][ty]=1;
            if(pos[tx][ty]>=0)e[id][pos[tx][ty]]=w+1;
            q.push({tx,ty,w+1});
        }
    }
    return;
}
```

---
处理用时：55.87秒
# 题目信息

# [ABC314E] Roulettes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc314/tasks/abc314_e

$ N $ 台のルーレットがあります。 $ i $ 番目 $ (1\leq\ i\leq\ N) $ のルーレットには $ P\ _\ i $ 個の整数 $ S\ _\ {i,1},S\ _\ {i,2},\ldots,S\ _\ {i,P\ _\ i} $ が書かれており、$ C\ _\ i $ 円支払うことで $ 1 $ 回プレイできます。 $ i $ 番目のルーレットを $ 1 $ 回プレイすると、$ 1 $ 以上 $ P\ _\ i $ 以下の整数 $ j $ が一様ランダムに選ばれ、$ S\ _\ {i,j} $ ポイントを得ることができます。

ルーレットで得られるポイントは、過去の結果と独立に決まります。

高橋くんは、ポイントを $ M $ ポイント以上獲得したいです。 高橋くんは、$ M $ ポイント以上獲得するまでに支払う金額をなるべく小さくするように行動します。 ただし、高橋くんはルーレットをプレイするたびこれまでのルーレットの結果を見て次にプレイするルーレットを選ぶことができます。

高橋くんがポイントを $ M $ ポイント以上獲得するまでに支払う金額の期待値を求めてください。

より厳密な定義より厳密には、次のようになります。 高橋くんがルーレットを選ぶ戦略を決めるごとに、その戦略で $ M $ ポイント以上獲得するまでに支払う金額の期待値 $ E $ が次のように定義されます。

- 自然数 $ X $ に対して、その戦略に従って高橋くんが $ M $ ポイント以上獲得するか、ルーレットを $ X $ 回プレイするまでに支払う金額の期待値を $ f(X) $ とする。$ E=\displaystyle\lim\ _\ {X\to+\infty}f(X) $ とする。

この問題の条件のもとで、高橋くんがどのような戦略をとっても $ \displaystyle\lim\ _\ {X\to+\infty}f(X) $ が有限の値になることが証明できます。 高橋くんが $ E $ を最小にするような戦略をとったときの $ E $ の値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 100 $
- $ 1\leq\ M\leq\ 100 $
- $ 1\leq\ C\ _\ i\leq\ 10\ ^\ 4\ (1\leq\ i\leq\ N) $
- $ 1\leq\ P\ _\ i\leq\ 100\ (1\leq\ i\leq\ N) $
- $ 0\leq\ S\ _\ {i,j}\leq\ M\ (1\leq\ i\leq\ N,1\leq\ j\leq\ P\ _\ i) $
- $ \displaystyle\sum\ _\ {j=1}^{P\ _\ i}S\ _\ {i,j}\gt0\ (1\leq\ i\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

例えば、高橋くんはルーレットを次のようにプレイすることができます。 - $ 50 $ 円を支払ってルーレット $ 2 $ をプレイする。$ S\ _\ {2,4}=8 $ ポイントを得る。 - $ 50 $ 円を支払ってルーレット $ 2 $ をプレイする。$ S\ _\ {2,1}=1 $ ポイントを得る。 - $ 100 $ 円を支払ってルーレット $ 1 $ をプレイする。$ S\ _\ {1,1}=5 $ ポイントを得る。得たポイントの合計が $ 8+1+5\geq14 $ ポイントとなったため、終了する。 この例では、$ 14 $ ポイントを得るまでに $ 200 $ 円を支払っています。 出力と真の値の相対誤差もしくは絶対誤差が $ 10\ ^\ {-5} $ 以下のとき正答と判定されるため、`215.9112` や `215.9155` などと出力しても正解になります。

### Sample Explanation 2

$ 100 $ ポイントが出るまでルーレット $ 2 $ を回し続けるのが最適です。

## 样例 #1

### 输入

```
3 14
100 2 5 9
50 4 1 2 4 8
70 5 2 4 2 8 8```

### 输出

```
215.913355350494384765625```

## 样例 #2

### 输入

```
2 100
1 2 1 2
10 6 0 0 0 0 0 100```

### 输出

```
60```

## 样例 #3

### 输入

```
20 90
3252 9 0 4 2 7 3 2 3 2 4
2147 1 1
4033 8 0 4 1 7 5 2 5 0
3795 6 6 6 2 3 2 2
3941 7 2 4 4 7 2 0 5
2815 6 2 1 0 5 2 2
3020 2 3 6
3858 9 4 2 7 3 0 4 4 6 5
4533 10 3 6 4 0 6 4 4 2 7 7
4198 8 6 7 0 6 3 6 5 6
3739 8 2 7 1 5 1 4 4 7
2465 4 1 4 0 1
4418 9 7 6 2 4 6 1 5 0 7
5450 12 0 4 4 7 7 4 4 5 4 5 3 7
4196 9 1 6 5 5 7 2 3 6 3
4776 9 2 2 7 3 6 6 1 6 6
2286 3 3 5 6
3152 3 4 1 5
3509 7 0 6 7 0 1 0 3
2913 6 0 1 5 0 5 6```

### 输出

```
45037.072314895291126319493887599716```

# AI分析结果

### 题目内容重写

有 $N$ 个转盘。第 $i$ 个转盘上有 $P_i$ 个整数 $S_{i,1}, S_{i,2}, \ldots, S_{i,P_i}$，每次转一次第 $i$ 个转盘需要支付 $C_i$ 元。当你转第 $i$ 个转盘一次，转盘会等概率地出现 $1, 2, \ldots, P_i$ 中的一个整数 $j$，然后你获得 $S_{i,j}$ 分。每次转转盘的得分是相互独立的。现在有一个人想要至少获得 $M$ 分。在获得至少 $M$ 分之前，这个人的策略是最小化他支付的总钱数。在每次转转盘过后，他会根据已有的得分结果选择转哪个转盘。请求出这个人至少获得 $M$ 分所需支付的钱数的期望。

### 题解分析与结论

本题的核心是期望 DP，难点在于如何处理 $S_{i,j} = 0$ 的情况，因为这会导致状态转移时出现自环。大多数题解通过将 $S_{i,j} = 0$ 的情况单独处理，调整期望值，从而避免自环问题。以下是几条较为优秀的题解：

---

### 精选题解

#### 1. 作者：AC_love (★★★★★)
**关键亮点**：
- 详细解释了贪心策略的局限性，并引入了动态规划的正确解法。
- 通过将 $S_{i,j} = 0$ 的情况单独处理，避免了自环问题。
- 代码清晰，逻辑严谨，易于理解。

**核心代码**：
```cpp
for(int i = 1; i <= m; i = i + 1) {
    double d;
    dp[i] = 1145141919810;
    for(int j = 1; j <= n; j = j + 1) {
        d = 0;
        int z = 0;
        for(int k = 1; k <= p[j]; k = k + 1) {
            if(s[j][k] == 0) z++;
            else d += dp[max(0, i - s[j][k])];
        }
        d /= (p[j] - z);
        d += c[j] * p[j] / double(p[j] - z);
        dp[i] = min(dp[i], d);
    }
}
```
**核心思想**：通过计算每个转盘的有效期望值，并调整 $S_{i,j} = 0$ 的情况，最终得到最小期望值。

---

#### 2. 作者：zac2010 (★★★★☆)
**关键亮点**：
- 简洁明了地解释了如何处理 $S_{i,j} = 0$ 的情况。
- 通过调整 $C_i$ 和 $P_i$，将问题转化为无自环的期望 DP。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
FL(i, 1, m) {
    FL(j, 1, n) if(p[j]) {
        double cost = c[j];
        for(int &x: s[j])
            cost += f[max(0, i - x)] / p[j];
        f[i] = min(f[i], cost);
    }
}
```
**核心思想**：通过调整 $C_i$ 和 $P_i$，将 $S_{i,j} = 0$ 的情况转化为无自环的期望 DP 问题。

---

#### 3. 作者：Eibon (★★★★☆)
**关键亮点**：
- 通过数学推导，将 $S_{i,j} = 0$ 的情况转化为无自环的期望 DP。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int j = m - 1; j >= 0; j--) {
    for(int i = 1; i <= n; i++) {
        sum = 1.0 * c[i] * p[i] / (p[i] - cnt[i]);
        for(int k = 1; k <= p[i]; k++) {
            if(a[i][k] != 0) {
                sum += 1.0 * dp[j + a[i][k]] / (p[i] - cnt[i]);
            }
        }
        dp[j] = min(dp[j], sum);
    }
}
```
**核心思想**：通过数学推导，将 $S_{i,j} = 0$ 的情况转化为无自环的期望 DP 问题。

---

### 最优关键思路与技巧

1. **期望 DP 的应用**：本题的核心是期望 DP，通过状态转移方程计算最小期望值。
2. **处理自环问题**：通过将 $S_{i,j} = 0$ 的情况单独处理，避免了自环问题。
3. **调整期望值**：通过调整 $C_i$ 和 $P_i$，将问题转化为无自环的期望 DP 问题。

### 可拓展之处

- **类似题目**：可以扩展到其他期望 DP 问题，如概率游戏、随机过程等。
- **优化技巧**：在处理期望 DP 时，可以通过数学推导或调整参数来简化问题。

### 推荐题目

1. [P1850 换教室](https://www.luogu.com.cn/problem/P1850)
2. [P4550 收集邮票](https://www.luogu.com.cn/problem/P4550)
3. [P2473 奖励关](https://www.luogu.com.cn/problem/P2473)

### 个人心得摘录

- **AC_love**：通过贪心策略的失败，意识到期望 DP 的重要性，最终通过调整期望值解决了问题。
- **zac2010**：通过调整 $C_i$ 和 $P_i$，将问题转化为无自环的期望 DP，简化了问题。
- **Eibon**：通过数学推导，将 $S_{i,j} = 0$ 的情况转化为无自环的期望 DP，解决了问题。

---
处理用时：52.92秒
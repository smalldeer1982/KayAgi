# 题目信息

# [ABC315F] Shortcuts

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_f

座標平面上でチェックポイント $ 1,2,\dots,N $ をこの順に通るレースが行われます。  
チェックポイント $ i $ の座標は $ (X_i,Y_i) $ であり、すべてのチェックポイントの座標は異なります。

チェックポイント $ 1,N $ 以外のチェックポイントは、通過を省略することもできます。  
ただし、通らなかったチェックポイントの個数を $ C $ として、以下の通りペナルティが課せられます。

- $ C\ >\ 0 $ なら $ \displaystyle\ 2^{C−1} $
- $ C=0 $ なら $ 0 $

チェックポイント $ 1 $ からチェックポイント $ N $ までの総移動距離（ユークリッド距離）とペナルティの和を $ s $ とします。  
このとき、 $ s $ として達成可能な最小の値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ \le\ N\ \le\ 10^4 $
- $ 0\ \le\ X_i,Y_i\ \le\ 10^4 $
- $ i\ \neq\ j $ ならば $ (X_i,Y_i)\ \neq\ (X_j,Y_j) $

### Sample Explanation 1

チェックポイント $ 1,2,5,6 $ を通過し、 $ 3,4 $ の通過を省略することを考えます。 - チェックポイント $ 1\ \rightarrow\ 2 $ に移動する。 $ 2 $ 点間の距離は $ \sqrt{2} $ である。 - チェックポイント $ 2\ \rightarrow\ 5 $ に移動する。 $ 2 $ 点間の距離は $ 1 $ である。 - チェックポイント $ 5\ \rightarrow\ 6 $ に移動する。 $ 2 $ 点間の距離は $ \sqrt{2} $ である。 - 通らなかったチェックポイントは $ 2 $ つであり、このとき科せられるペナルティは $ 2 $ である。 以上のようにして、 $ s\ =\ 3\ +\ 2\sqrt{2}\ \approx\ 5.828427 $ を達成できます。 $ s $ をこの値より小さくすることはできません。

## 样例 #1

### 输入

```
6
0 0
1 1
2 0
0 1
1 0
2 1```

### 输出

```
5.82842712474619009753```

## 样例 #2

### 输入

```
10
1 8
3 7
9 4
4 9
6 1
7 5
0 0
1 3
6 8
6 4```

### 输出

```
24.63441361516795872523```

## 样例 #3

### 输入

```
10
34 24
47 60
30 31
12 97
87 93
64 46
82 50
14 7
17 24
3 78```

### 输出

```
110.61238353245736230207```

# AI分析结果

### 题目内容重写

在坐标平面上，按顺序通过检查点 $1,2,\dots,N$ 进行一场比赛。检查点 $i$ 的坐标为 $(X_i,Y_i)$，且所有检查点的坐标都不同。

除了检查点 $1$ 和 $N$，其他检查点可以选择跳过。如果跳过的检查点个数为 $C$，则会有以下惩罚：

- 如果 $C > 0$，惩罚为 $2^{C-1}$；
- 如果 $C = 0$，惩罚为 $0$。

从检查点 $1$ 到检查点 $N$ 的总移动距离（欧几里得距离）与惩罚的和为 $s$。求 $s$ 的最小值。

### 题解分析与结论

各题解均采用动态规划（DP）的思路，核心思想是通过状态转移来计算从起点到终点的最小代价。主要难点在于如何优化状态转移，避免 $O(n^3)$ 的复杂度。题解中普遍利用了惩罚的指数增长特性，将跳过的点数限制在 30 个以内，从而将复杂度降低到 $O(n^2)$ 或更低。

### 所选高分题解

#### 题解1：LiaoYF（★★★★★）

**关键亮点：**
- 简洁的 DP 状态定义和转移方程。
- 通过限制跳过的点数（最多 25 个）来优化复杂度。
- 代码清晰，易于理解。

**核心代码：**
```cpp
double f[10005][30];
double dis(int i, int j) {
    return sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> x[i] >> y[i];
        for (int j = 0; j <= 25; j++) f[i][j] = 1e9;
    }
    f[1][0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < min(i, 25); j++) f[i][j] = min(f[i][j], f[i-1][j] + dis(i, i-1));
        for (int j = 1; j < i-1; j++) {
            for (int k = i-j-1; k <= 25; k++) {
                f[i][k] = min(f[i][k], f[j][k-(i-j-1)] + dis(i, j));
            }
        }
    }
    double ans = f[n][0];
    for (int i = 1; i <= 25; i++) {
        ans = min(ans, f[n][i] + pow(2, i-1));
    }
    printf("%.6lf", ans);
    return 0;
}
```

#### 题解2：CarroT1212（★★★★☆）

**关键亮点：**
- 通过限制跳过的点数（最多 30 个）来优化复杂度。
- 代码结构清晰，转移方程简洁。

**核心代码：**
```cpp
ld dp[N][M];
ld dist(ld xa, ld ya, ld xb, ld yb) {
    return sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb));
}
int main() {
    scanf("%lld", &n);
    for (ll i = 1; i <= n; i++) scanf("%Lf%Lf", &x[i], &y[i]);
    for (ll i = 0; i < N; i++) for (ll j = 0; j < M; j++) dp[i][j] = 1e18;
    dp[1][0] = 0;
    for (ll i = 2; i <= n; i++) {
        for (ll j = 0; j < min(i, M-1); j++) {
            for (ll k = 0; k < min(i-j, M-1); k++) {
                if (k+j < M) dp[i][k+j] = min(dp[i][k+j], dp[i-j-1][k] + dist(x[i-j-1], y[i-j-1], x[i], y[i]));
            }
        }
    }
    ld ans = 1e18;
    for (ll i = 0; i < M; i++) ans = min(ans, dp[n][i] + (i ? 1ll << i-1 : 0));
    printf("%.15Lf", ans);
    return 0;
}
```

#### 题解3：robertuu（★★★★☆）

**关键亮点：**
- 通过限制跳过的点数（最多 30 个）来优化复杂度。
- 代码简洁，转移方程清晰。

**核心代码：**
```cpp
double dp[10001][40];
double dis(point x, point y) {
    return sqrt(1.0*(x.x-y.x)*(x.x-y.x) + 1.0*(x.y-y.y)*(x.y-y.y));
}
int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d%d", &a[i].x, &a[i].y);
    for (int i = 1; i <= n; i++) for (int j = 0; j <= 30; j++) dp[i][j] = 1e10;
    dp[1][0] = 0;
    for (int i = 2; i <= n; i++) {
        for (int j = max(1, i-30); j < i; j++) {
            for (int k = 0; k <= min(30, i-1); k++) {
                if (k-i+j+1 < 0) continue;
                dp[i][k] = min(dp[i][k], dp[j][k-i+j+1] + dis(a[i], a[j]));
            }
        }
    }
    double ans = dp[n][0];
    for (int i = 1; i <= 30; i++) ans = min(ans, dp[n][i] + pow(2, i-1));
    printf("%.7f\n", ans);
    return 0;
}
```

### 最优关键思路与技巧

1. **DP 状态定义**：定义 $f_{i,k}$ 表示到达第 $i$ 个点，跳过了 $k$ 个点的最小代价。
2. **状态转移优化**：通过限制跳过的点数（最多 30 个），将复杂度从 $O(n^3)$ 降低到 $O(n^2)$。
3. **惩罚处理**：利用惩罚的指数增长特性，确保跳过的点数不会过多。

### 可拓展之处

类似的问题可以通过限制某些参数的范围来优化复杂度，尤其是在涉及指数增长的惩罚或代价时。这种思路可以应用于其他动态规划问题中，如最短路径、背包问题等。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的背包问题，适合练习动态规划。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 动态规划与贪心结合的问题。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 动态规划在序列问题中的应用。

### 个人心得总结

在调试过程中，发现跳过的点数限制是关键，通过合理限制跳过的点数，可以大幅降低复杂度。此外，状态转移方程的清晰定义和边界条件的处理也是实现中的重点。

---
处理用时：65.93秒
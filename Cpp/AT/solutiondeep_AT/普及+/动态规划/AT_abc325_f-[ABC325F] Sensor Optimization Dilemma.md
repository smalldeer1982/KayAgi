# 题目信息

# [ABC325F] Sensor Optimization Dilemma

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_f

キーエンスの工場長であるあなたは、ベルトコンベア上のいくつかの区間をセンサーによって監視したいと考えています。 あなたが監視したい区間は全部で $ N $ 個あり、$ i $ 個目の区間の長さは $ D_i $ メートルです。

センサーには $ 2 $ 種類の候補があり、それぞれのセンサーに関する情報は以下の通りです。

- センサー $ j\ (1\leq\ j\ \leq\ 2) $ : 長さ $ L_j $ メートルの区間を監視できる。 価格は $ 1 $ 個あたり $ C_j $ であり、全体で最大 $ K_j $ 個まで使用することができる。

$ 1 $ つの区間をいくつかの区間に分割して監視することもできます。 また、センサーが監視する区間が重なっていたり、監視したい区間の長さより余分に監視していたりしても問題はありません。 例えば、$ L_1=4,L_2=2 $ であるとき、センサー $ 1 $ を $ 1 $ つ使って長さ $ 3 $ メートルの区間を監視したり、センサー $ 1,2 $ を $ 1 $ つずつ使って長さ $ 5 $ メートルの区間を監視したりすることが可能です。

$ N $ 個の区画をすべて監視することが可能であるか判定し、可能ならば必要なセンサーの価格の総和の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 100 $
- $ 1\leq\ D_i,L_j\ \leq\ 10^5 $
- $ 1\leq\ C_j\ \leq\ 10^9 $
- $ 1\leq\ K_j\ \leq\ 10^3 $
- 入力は全て整数

### Sample Explanation 1

以下のようにすることで、センサー $ 1 $ を $ 3 $ つ、センサー $ 2 $ を $ 4 $ つ使ってすべての区間を監視できます。 - センサー $ 1 $ を $ 1 $ つ使って $ 1 $ 個目の区間を監視する。 - センサー $ 1,2 $ を $ 1 $ つずつ使って $ 2 $ 個目の区間を監視する。 - センサー $ 1 $ を $ 1 $ つ、センサー $ 2 $ を $ 3 $ つ使って $ 3 $ 個目の区間を監視する。 このとき、必要なセンサーの価格の総和は $ 3\times\ 3\ +\ 2\times\ 4\ =\ 17 $ であり、これが最小です。

### Sample Explanation 3

$ 1 $ つも使わない種類のセンサーがあっても構いません。

## 样例 #1

### 输入

```
3
3 5 10
4 3 3
2 2 6```

### 输出

```
17```

## 样例 #2

### 输入

```
3
3 5 10
4 3 3
2 2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
2
4 8
3 1 100
4 10000 100```

### 输出

```
5```

# AI分析结果

### 题目内容重写

#### [ABC325F] Sensor Optimization Dilemma

**题目描述**

Keyence的工厂长希望用传感器监控传送带上的几个区间。需要监控的区间共有 \( N \) 个，第 \( i \) 个区间的长度为 \( D_i \) 米。

传感器有两种候选，每种传感器的信息如下：

- 传感器 \( j\ (1\leq j \leq 2) \)：可以监控长度为 \( L_j \) 米的区间。每个传感器的价格为 \( C_j \)，最多可以使用 \( K_j \) 个。

一个区间可以被分割成多个子区间进行监控。此外，传感器监控的区间可以重叠，或者监控的区间长度超过需要监控的区间长度也是允许的。例如，当 \( L_1=4, L_2=2 \) 时，可以使用1个传感器1来监控长度为3米的区间，或者使用1个传感器1和1个传感器2来监控长度为5米的区间。

请判断是否能够监控所有 \( N \) 个区间，如果可以，求所需传感器的最小总价格。

**说明/提示**

**约束条件**

- \( 1\leq N \leq 100 \)
- \( 1\leq D_i, L_j \leq 10^5 \)
- \( 1\leq C_j \leq 10^9 \)
- \( 1\leq K_j \leq 10^3 \)
- 输入均为整数

**样例解释1**

以下方式可以使用3个传感器1和4个传感器2来监控所有区间：
- 使用1个传感器1监控第1个区间。
- 使用1个传感器1和1个传感器2监控第2个区间。
- 使用1个传感器1和3个传感器2监控第3个区间。
此时，所需传感器的总价格为 \( 3\times 3 + 2\times 4 = 17 \)，这是最小的。

**样例解释3**

即使某种传感器一个也不使用，也是可以的。

**样例输入1**

```
3
3 5 10
4 3 3
2 2 6
```

**样例输出1**

```
17
```

**样例输入2**

```
3
3 5 10
4 3 3
2 2 3
```

**样例输出2**

```
-1
```

**样例输入3**

```
2
4 8
3 1 100
4 10000 100
```

**样例输出3**

```
5
```

---

### 题解综合分析与结论

本题的核心是通过动态规划（DP）来解决传感器的最优选择问题。大多数题解采用了类似的DP思路，即通过状态转移方程来计算在给定传感器数量的情况下，监控所有区间所需的最小成本。不同的题解在状态设计和优化上有所差异，部分题解通过单调队列优化将复杂度降低到 \(O(nk)\)，而其他题解则采用了较为朴素的 \(O(nk^2)\) 方法。

### 评分较高的题解

#### 题解1：___OccDreamer___ (赞：7)

**星级：★★★★★**

**关键亮点：**
1. 提供了两种解法，其中一种通过单调队列优化将复杂度降低到 \(O(nk)\)。
2. 详细推导了状态转移方程，并通过分情况讨论和单调队列优化来减少计算量。
3. 代码实现清晰，逻辑严谨。

**核心代码：**
```cpp
for(int i=1;i<=n;i++) {
    hd=1,tl=0;
    ll minn=inf;
    for(int j=0;j<=a.k;j++) {
        int s=max(0LL,(j*a.l-d[i]+a.l-1)/a.l);
        while(hd<=tl&&q[hd]<s) minn=min(minn,1LL*f[i-1][q[hd]]),hd++;
        while(hd<=tl&&1LL*f[i-1][q[tl]]*b.l+q[tl]*a.l>=1LL*f[i-1][j]*b.l+j*a.l) tl--;
        q[++tl]=j;
        f[i][j]=min(minn,(1LL*f[i-1][q[hd]]*b.l+q[hd]*a.l+d[i]-j*a.l+b.l-1)/b.l);
    }
}
```

**核心思想：**
通过单调队列优化，将状态转移方程中的最小值计算从 \(O(k)\) 降低到 \(O(1)\)，从而将整体复杂度从 \(O(nk^2)\) 降低到 \(O(nk)\)。

#### 题解2：_Ink (赞：4)

**星级：★★★★**

**关键亮点：**
1. 采用朴素的DP方法，状态转移方程清晰易懂。
2. 通过枚举传感器数量来计算最小成本，代码实现简洁。
3. 提供了详细的解释和状态转移方程的推导。

**核心代码：**
```cpp
for(int i = 2; i <= n; i ++)
    for(int j = 0; j <= ka; j ++)
        for(int k = 0; k <= j; k ++)
            dp[i][j] = min(dp[i][j], dp[i - 1][j - k] + (max(d[i] - k * la, 0) + (lb - 1)) / lb);
```

**核心思想：**
通过三重循环枚举传感器1和传感器2的使用数量，计算监控所有区间所需的最小成本。

#### 题解3：_Kenma_ (赞：0)

**星级：★★★★**

**关键亮点：**
1. 采用了状态设计优化，将三维DP优化为二维DP。
2. 通过将传感器2的数量作为DP值，减少了状态数。
3. 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
for(int i=1;i<=n;i++){
    for(int j=0;j<=k1;j++){
        for(int a=0;a<=j;a++){
            f[i][j]=min(f[i][j],f[i-1][j-a]+(d[i]>a*l1?((d[i]-a*l1)/l2+(bool)((d[i]-a*l1)%l2)):0));
        }
    }
}
```

**核心思想：**
通过将传感器2的数量作为DP值，减少了状态数，从而优化了DP的计算效率。

### 最优关键思路或技巧

1. **状态设计优化**：通过将传感器2的数量作为DP值，减少了状态数，从而优化了DP的计算效率。
2. **单调队列优化**：通过单调队列优化，将状态转移方程中的最小值计算从 \(O(k)\) 降低到 \(O(1)\)，从而将整体复杂度从 \(O(nk^2)\) 降低到 \(O(nk)\)。
3. **枚举与分情况讨论**：通过枚举传感器数量并结合分情况讨论，简化了状态转移方程的计算。

### 可拓展之处

1. **类似问题**：可以扩展到更多类型的传感器或更多约束条件的监控问题。
2. **算法套路**：类似的DP优化思路可以应用于其他资源分配问题，如背包问题、任务调度等。

### 推荐题目

1. **洛谷P1048 [NOIP2005 普及组] 采药**：考察背包问题的经典题目。
2. **洛谷P1064 [NOIP2006 提高组] 金明的预算方案**：考察多维背包问题的优化。
3. **洛谷P1541 [NOIP2010 提高组] 乌龟棋**：考察状态设计和DP优化的经典题目。

---
处理用时：59.84秒
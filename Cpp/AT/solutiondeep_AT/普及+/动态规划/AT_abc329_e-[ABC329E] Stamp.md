# 题目信息

# [ABC329E] Stamp

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc329/tasks/abc329_e

英大文字からなる長さ $ N $ の文字列 $ S $ と、英大文字からなる長さ $ M\ (\leq\ N) $ の文字列 $ T $ が与えられます。

`#` のみからなる長さ $ N $ の文字列 $ X $ があります。 以下の操作を好きな回数行うことで、$ X $ を $ S $ に一致させることができるか判定してください。

- $ X $ の中から連続する $ M $ 文字を選び、$ T $ で置き換える。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min(N, $ $ 5 $$ ) $
- $ S $ は英大文字からなる長さ $ N $ の文字列
- $ T $ は英大文字からなる長さ $ M $ の文字列

### Sample Explanation 1

以下、$ X $ の $ l $ 文字目から $ r $ 文字目までの部分を $ X[l:r] $ と表記します。 次のように操作を行うことで、$ X $ を $ S $ に一致させることができます。 1. $ X[3:5] $ を $ T $ で置き換える。$ X= $ `##ABC##` になる。 2. $ X[1:3] $ を $ T $ で置き換える。$ X= $ `ABCBC##` になる。 3. $ X[5:7] $ を $ T $ で置き換える。$ X= $ `ABCBABC` になる。

### Sample Explanation 2

どのように操作を行っても、$ X $ を $ S $ に一致させることはできません。

## 样例 #1

### 输入

```
7 3
ABCBABC
ABC```

### 输出

```
Yes```

## 样例 #2

### 输入

```
7 3
ABBCABC
ABC```

### 输出

```
No```

## 样例 #3

### 输入

```
12 2
XYXXYXXYYYXY
XY```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写

#### [ABC329E] Stamp

**题目描述**

给定一个由大写字母组成的长度为 \( N \) 的字符串 \( S \)，以及一个由大写字母组成的长度为 \( M \)（\( M \leq N \)）的字符串 \( T \)。

你有一个长度为 \( N \) 的字符串 \( X \)，它仅由字符 `#` 组成。你可以进行任意次数的操作，每次操作选择 \( X \) 中连续的 \( M \) 个字符，并用 \( T \) 替换它们。问是否可以通过这些操作使 \( X \) 与 \( S \) 完全一致。

**说明/提示**

**约束条件**

- \( 1 \leq N \leq 2 \times 10^5 \)
- \( 1 \leq M \leq \min(N, 5) \)
- \( S \) 是由大写字母组成的长度为 \( N \) 的字符串
- \( T \) 是由大写字母组成的长度为 \( M \) 的字符串

**样例解释 1**

输入：
```
7 3
ABCBABC
ABC
```
输出：
```
Yes
```
解释：可以通过以下操作使 \( X \) 与 \( S \) 一致：
1. 将 \( X[3:5] \) 替换为 \( T \)，\( X \) 变为 `##ABC##`。
2. 将 \( X[1:3] \) 替换为 \( T \)，\( X \) 变为 `ABCBC##`。
3. 将 \( X[5:7] \) 替换为 \( T \)，\( X \) 变为 `ABCBABC`。

**样例解释 2**

输入：
```
7 3
ABBCABC
ABC
```
输出：
```
No
```
解释：无论如何操作，都无法使 \( X \) 与 \( S \) 一致。

**样例解释 3**

输入：
```
12 2
XYXXYXXYYYXY
XY
```
输出：
```
Yes
```

### 题解综合分析与结论

本题的核心在于判断是否可以通过多次覆盖操作将初始为 `#` 的字符串 \( X \) 转化为目标字符串 \( S \)。由于 \( M \) 的长度较小（\( M \leq 5 \)），许多题解采用了动态规划（DP）或搜索的方法来解决。

#### 最优关键思路与技巧

1. **动态规划（DP）**：大多数题解采用了 DP 的思路，定义状态 \( dp_{i,j} \) 表示 \( S \) 的前 \( i \) 个字符与 \( T \) 的前 \( j \) 个字符是否匹配。通过状态转移方程来判断是否可以通过覆盖操作将 \( X \) 转化为 \( S \)。

2. **逆向思维**：部分题解采用了逆向思维，从 \( S \) 出发，通过“撕贴纸”的方式将 \( S \) 中的字符逐步替换为 `#`，最终判断是否可以将 \( S \) 完全转化为 `#`。

3. **搜索与剪枝**：一些题解使用了搜索的方法，通过枚举可能的覆盖位置，并结合剪枝策略来优化搜索过程。

#### 推荐题解

1. **作者：hjqhs (赞：15)**  
   - **星级：★★★★★**  
   - **关键亮点**：采用了清晰的 DP 思路，状态转移方程简洁明了，代码可读性强。  
   - **核心代码**：
     ```cpp
     rep (i, 1, n) {
         rep (j, 1, m) {
             if (s[i] == t[j]) f[i][j] |= f[i - 1][j - 1] | f[i - 1][m];
             if (s[i] == t[1]) f[i][1] |= f[i - 1][j];
         }
     }
     ```
   - **个人心得**：作者提到这是砍掉 Ex 后第一次切六题，表达了对题目的深刻理解。

2. **作者：FL_sleake (赞：11)**  
   - **星级：★★★★☆**  
   - **关键亮点**：采用了逆向思维，通过搜索的方式逐步将 \( S \) 转化为 `#`，思路新颖。  
   - **核心代码**：
     ```cpp
     void dfs(int l) {
         for(int i=l;i<=min(n-m+1,l+m);i++) if(check(i)) dfs(i);
         for(int i=l;i>=max(1ll,l-m);i--) if(check(i)) dfs(i);
     }
     ```
   - **个人心得**：作者提到“涨芝士了”，表达了对题目解法的深刻理解。

3. **作者：Genius_Star (赞：6)**  
   - **星级：★★★★☆**  
   - **关键亮点**：详细解释了 DP 的状态转移方程，并提供了完整的代码实现。  
   - **核心代码**：
     ```cpp
     for(int i=2;i<=n;i++){
         for(int j=1;j<=m;j++){
             if(s1[i]!=s2[j]) continue;
             dp[i][j]=dp[i-1][j-1]|dp[i-1][m];
             if(j==1){
                 for(int k=1;k<=m;k++)
                     dp[i][j]|=dp[i-1][k];
             }
         }
     }
     ```
   - **个人心得**：作者详细解释了 DP 的状态转移方程，表达了对题目的深刻理解。

### 扩展思路与推荐题目

1. **扩展思路**：本题的 DP 思路可以推广到其他字符串匹配问题，尤其是涉及多次覆盖或替换操作的问题。逆向思维也可以用于类似的“逆向操作”问题。

2. **推荐题目**：
   - [P1279 字符串距离](https://www.luogu.com.cn/problem/P1279)
   - [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)
   - [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)

这些题目都涉及字符串匹配与操作，可以帮助进一步巩固相关算法与技巧。

---
处理用时：45.97秒
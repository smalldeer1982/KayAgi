# 题目信息

# [ABC338F] Negative Traveling Salesman

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc338/tasks/abc338_f

$ N $ 頂点 $ M $ 辺の重み付き単純有向グラフがあります。 頂点には $ 1 $ から $ N $ までの番号が付けられていて、$ i $ 本目の辺は頂点 $ U_i $ から頂点 $ V_i $ に伸びる重み $ W_i $ の辺です。 ここで、重みは負の値を取ることもありますが、負閉路は存在しません。

全ての頂点を一度以上通るようなウォークが存在するかどうか判定し、存在するならば通る辺の重みの総和の最小値を求めてください。 ただし、同じ辺を複数回通る場合、その辺の重みは通った回数分加算されるものとします。

なお、「全ての頂点を一度以上通るようなウォーク」とは、頂点の列 $ v_1,v_2,\dots,v_k $ であって以下の条件を共に満たすもののことを言います。

- すべての $ i\ (1\leq\ i\leq\ k-1) $ について、頂点 $ v_i $ から頂点 $ v_{i+1} $ に伸びる辺が存在する
- すべての $ j\ (1\leq\ j\leq\ N) $ について、$ v_i=j $ を満たす $ i\ (1\leq\ i\leq\ k) $ が存在する

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 20 $
- $ 1\leq\ M\ \leq\ N(N-1) $
- $ 1\leq\ U_i,V_i\ \leq\ N $
- $ U_i\ \neq\ V_i $
- $ (U_i,V_i)\ \neq\ (U_j,V_j)\ (i\neq\ j) $
- $ -10^6\leq\ W_i\ \leq\ 10^6 $
- 与えられるグラフに負閉路は存在しない
- 入力は全て整数
 
### Sample Explanation 1

頂点 $ 2\rightarrow\ 1\rightarrow\ 2\rightarrow\ 3 $ の順に辿ると、全ての頂点を一度以上通ることができ、通る辺の重みの総和は $ (-3)+5+(-4)=-2 $ になります。 これが最小です。

### Sample Explanation 2

全ての頂点を一度以上通るようなウォークは存在しません。

## 样例 #1

### 输入

```
3 4

1 2 5

2 1 -3

2 3 -4

3 1 100```

### 输出

```
-2```

## 样例 #2

### 输入

```
3 2

1 2 0

2 1 0```

### 输出

```
No```

## 样例 #3

### 输入

```
5 9

1 2 -246288

4 5 -222742

3 1 246288

3 4 947824

5 2 -178721

4 3 -947824

5 4 756570

2 5 707902

5 1 36781```

### 输出

```
-449429```

# AI分析结果

### 题目翻译
# [ABC338F] Negative Traveling Salesman

## 题目描述

给定一个包含 $N$ 个顶点和 $M$ 条边的带权有向图。顶点编号为 $1$ 到 $N$，第 $i$ 条边从顶点 $U_i$ 指向顶点 $V_i$，权重为 $W_i$。权重可以为负，但图中不存在负权回路。

判断是否存在一条路径，使得该路径经过所有顶点至少一次。如果存在，求经过的边权重总和的最小值。注意，如果一条边被多次经过，其权重会被累加多次。

“经过所有顶点至少一次的路径”是指一个顶点序列 $v_1, v_2, \dots, v_k$，满足以下条件：
- 对于所有 $i\ (1 \leq i \leq k-1)$，存在从 $v_i$ 到 $v_{i+1}$ 的边。
- 对于所有 $j\ (1 \leq j \leq N)$，存在某个 $i\ (1 \leq i \leq k)$ 使得 $v_i = j$。

## 说明/提示

### 约束

- $2 \leq N \leq 20$
- $1 \leq M \leq N(N-1)$
- $1 \leq U_i, V_i \leq N$
- $U_i \neq V_i$
- $(U_i, V_i) \neq (U_j, V_j)\ (i \neq j)$
- $-10^6 \leq W_i \leq 10^6$
- 给定的图中不存在负权回路
- 输入均为整数

### 样例解释 1

顶点 $2 \rightarrow 1 \rightarrow 2 \rightarrow 3$ 的路径经过所有顶点至少一次，且边权重总和为 $(-3) + 5 + (-4) = -2$。这是最小值。

### 样例解释 2

不存在经过所有顶点至少一次的路径。

---

### 综合分析与结论

这道题的核心是要求一个经过所有顶点的路径，且路径的总权重最小。由于顶点数 $N \leq 20$，且图中可能存在负权边，因此可以采用**状压DP**来解决。状压DP的状态表示当前经过的顶点集合和当前所在的顶点，转移时枚举下一个顶点，并更新状态和总权重。

### 题解评分与亮点

1. **Genius_Star (5星)**
   - **亮点**：使用了Floyd算法预处理所有顶点对之间的最短路径，结合状压DP进行状态转移，思路清晰，代码简洁。
   - **关键代码**：
     ```cpp
     for(int i=1;i<(1<<n);i++){
         for(int x=1;x<=n;x++){
             if(!(i&(1<<(x-1)))) continue;
             for(int y=1;y<=n;y++){
                 if(!(i&(1<<(y-1)))||x==y||dp[i^(1<<(x-1))][y]==INF||f[y][x]==INF)
                   continue;
                 dp[i][x]=min(dp[i][x],dp[i^(1<<(x-1))][y]+f[y][x]);
             }
         }
     }
     ```

2. **Shunpower (4星)**
   - **亮点**：详细解释了为什么需要多次转移，并给出了数学证明，确保路径的最优性。
   - **关键代码**：
     ```cpp
     for(int st=1;st<(1<<n);st++){
         for(int pl=0;pl<n;pl++) if(st>>pl&1){
             for(int to=0;to<n;to++){
                 dp[st|(1<<to)][to]=min(dp[st|(1<<to)][to],dp[st][pl]+dis[pl][to]);
             }
         }
     }
     ```

3. **donaldqian (4星)**
   - **亮点**：代码结构清晰，使用了Floyd算法预处理最短路，状压DP的状态转移方程简洁明了。
   - **关键代码**：
     ```cpp
     for(int i=1;i<(1<<n);i++){
         for(int j=1;j<=n;j++){
             if(!(i&(1<<(j-1)))) continue;
             for(int k=1;k<=n;k++){
                 if(k==j) continue;
                 if(((i>>(k-1))&1)) continue;
                 f[i|(1<<(k-1))][k]=min(f[i][j]+dis[j][k],f[i|(1<<(k-1))][k]);
             }
         }
     }
     ```

### 最优关键思路与技巧

1. **Floyd算法预处理**：由于图中可能存在负权边，使用Floyd算法预处理所有顶点对之间的最短路径，确保后续DP转移的正确性。
2. **状压DP**：使用二进制状态表示经过的顶点集合，结合当前所在的顶点进行状态转移，确保所有顶点都被访问到。
3. **多次转移**：在某些情况下，路径可能需要经过某些顶点多次，因此需要多次转移以确保路径的最优性。

### 可拓展之处

- **类似问题**：可以扩展到无向图、带权无向图等问题，思路类似，但需要注意无向图的对称性。
- **优化**：对于更大的顶点数，可以考虑使用启发式搜索或其他优化算法。

### 推荐题目

1. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
2. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

### 个人心得摘录

- **Genius_Star**：提到赛时没有使用Floyd算法，导致思路受阻，提醒我们在比赛中要灵活运用算法。
- **Shunpower**：详细解释了为什么需要多次转移，提醒我们在设计算法时要考虑所有可能的情况。

---
处理用时：41.56秒
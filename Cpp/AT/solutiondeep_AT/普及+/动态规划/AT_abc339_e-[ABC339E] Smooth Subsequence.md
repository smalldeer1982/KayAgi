# 题目信息

# [ABC339E] Smooth Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc339/tasks/abc339_e

長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ が与えられます。

$ A $ の部分列であって、隣接する $ 2 $ 項の差の絶対値が $ D $ 以下であるようなものの長さの最大値を求めてください。

ただし、数列 $ A $ の部分列とは、$ A $ の要素を $ 0 $ 個以上選んで削除し、残った要素を元の順序を保って並べた数列のことを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 0\ \leq\ D\ \leq\ 5\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 5\ \times\ 10^5 $
- 入力される数値はすべて整数
 
### Sample Explanation 1

$ A $ の部分列 $ (3,\ 1,\ 2) $ は隣接する $ 2 $ 項の差の絶対値が $ 2 $ 以下です。

## 样例 #1

### 输入

```
4 2

3 5 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
5 10

10 20 100 110 120```

### 输出

```
3```

## 样例 #3

### 输入

```
11 7

21 10 3 19 28 12 11 3 3 15 16```

### 输出

```
6```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个长度为 \( N \) 的数列 \( A = (A_1, A_2, \ldots, A_N) \)。请找出 \( A \) 的一个子序列，使得该子序列中相邻两项的差的绝对值不超过 \( D \)，并求该子序列的最大长度。

**说明/提示**

- 子序列的定义：从原序列中删除零个或多个元素，并保持剩余元素的顺序不变。
- 数据范围：
  - \( 1 \leq N \leq 5 \times 10^5 \)
  - \( 0 \leq D \leq 5 \times 10^5 \)
  - \( 1 \leq A_i \leq 5 \times 10^5 \)

**样例**

**样例1**

输入：
```
4 2
3 5 1 2
```
输出：
```
3
```
解释：子序列 \( (3, 1, 2) \) 满足相邻两项的差的绝对值不超过 2。

**样例2**

输入：
```
5 10
10 20 100 110 120
```
输出：
```
3
```

**样例3**

输入：
```
11 7
21 10 3 19 28 12 11 3 3 15 16
```
输出：
```
6
```

### 题解分析与结论

本题的核心是求一个子序列，使得相邻两项的差的绝对值不超过 \( D \)，并求该子序列的最大长度。题解中普遍采用了动态规划（DP）的思路，结合线段树优化，将时间复杂度从 \( O(n^2) \) 降低到 \( O(n \log n) \)。

### 精选题解

#### 题解1：作者：_JF_ (赞：9)

**星级：5星**

**关键亮点：**
- 使用动态规划结合线段树优化，思路清晰，代码简洁。
- 通过线段树维护值域区间内的最大值，实现了高效的区间查询和单点更新。

**核心代码：**
```cpp
int main(){
    cin>>n>>D;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++){
        dp[i]=max(dp[i],Query(max(1,a[i]-D),min(a[i]+D,500000),1,500000,1))+1;
        update(a[i],a[i],1,500000,1,dp[i]);
        ans=max(ans,dp[i]);
    }
    cout<<ans<<endl;
}
```
**实现思想：**
- 使用线段树维护值域区间内的最大值，每次查询 \( [a_i - D, a_i + D] \) 区间内的最大值，并更新当前点的 DP 值。

#### 题解2：作者：cjh20090318 (赞：9)

**星级：5星**

**关键亮点：**
- 动态规划状态设计合理，转移方程清晰。
- 通过线段树优化，实现了高效的区间查询和单点更新。

**核心代码：**
```cpp
int main(){
    scanf("%d%d",&n,&d);
    for(int i=1,a;i<=n;i++)
        scanf("%d",&a),update(1,1,A,a,query(1,1,A,max(a-d,1),min(a+d,A))+1);
    printf("%d\n",query(1,1,A,1,A));
    return 0;
}
```
**实现思想：**
- 使用线段树维护值域区间内的最大值，每次查询 \( [a_i - D, a_i + D] \) 区间内的最大值，并更新当前点的 DP 值。

#### 题解3：作者：_determination_ (赞：3)

**星级：4星**

**关键亮点：**
- 动态规划结合线段树优化，思路清晰，代码简洁。
- 通过线段树维护值域区间内的最大值，实现了高效的区间查询和单点更新。

**核心代码：**
```cpp
int main(){
    cin>>n>>d;
    for(int i=1;i<=n;i++) cin>>a[i];
    sg.build(1,5e5);
    int ans=0;
    for(int i=1;i<=n;i++){
        int cur=1;
        cur=max(cur,sg.query(max(1ll,a[i]-d),min(500000ll,a[i]+d))+1);
        sg.change(a[i],cur);
        ans=max(ans,cur);
    }
    cout<<ans<<'\n';
}
```
**实现思想：**
- 使用线段树维护值域区间内的最大值，每次查询 \( [a_i - D, a_i + D] \) 区间内的最大值，并更新当前点的 DP 值。

### 最优关键思路与技巧

1. **动态规划结合线段树优化**：通过线段树维护值域区间内的最大值，实现了高效的区间查询和单点更新，将时间复杂度从 \( O(n^2) \) 降低到 \( O(n \log n) \)。
2. **状态设计**：设 \( dp_i \) 表示以第 \( i \) 个数结尾的最长子序列长度，转移方程为 \( dp_i = \max_{|a_i - a_j| \leq D} dp_j + 1 \)。
3. **线段树实现**：通过线段树维护值域区间内的最大值，每次查询 \( [a_i - D, a_i + D] \) 区间内的最大值，并更新当前点的 DP 值。

### 可拓展之处

1. **类似题目**：可以拓展到其他需要区间查询和单点更新的动态规划问题，如最长上升子序列（LIS）等。
2. **其他数据结构**：可以考虑使用其他数据结构如树状数组（Fenwick Tree）来实现类似的优化。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)

---
处理用时：47.72秒
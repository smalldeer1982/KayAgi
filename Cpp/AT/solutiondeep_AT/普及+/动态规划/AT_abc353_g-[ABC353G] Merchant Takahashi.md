# 题目信息

# [ABC353G] Merchant Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc353/tasks/abc353_g

AtCoder 王国には町 $ 1, $ 町 $ 2,\ldots, $ 町 $ N $ の $ N $ 個の町があります。 町 $ i $ から町 $ j $ まで移動するには通行料が $ C\times|i-j| $ 円かかります。

商人である高橋君は、これから開催される $ M $ 回の市場のうち $ 0 $ 回以上に参加しようと思っています。

$ i $ 回目 $ (1\leq\ i\leq\ M) $ の市場の情報は整数の組 $ (T\ _\ i,P\ _\ i) $ で表され、$ i $ 回目の市場が町 $ T\ _\ i $ で行われ、高橋君が参加すると $ P\ _\ i $ 円が得られることを意味します。

すべての $ 1\leq\ i\lt\ M $ について、$ i $ 回目の市場が終了してから $ i+1 $ 回目の市場が開始します。 高橋君が移動するのにかかる時間は無視できるものとします。

高橋君は、はじめ $ 10\ ^\ {10\ ^\ {100}} $ 円持っており、町 $ 1 $ にいます。 参加する市場をうまく選び、うまく移動することによって高橋君が得られる儲けの最大値を求めてください。

厳密には、$ M $ 回の市場が終わったあとの所持金を最大化するように高橋君が行動した場合の最終的な高橋君の所持金を $ 10\ ^\ {10\ ^\ {100}}+X $ として、$ X $ を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ C\leq10\ ^\ 9 $
- $ 1\leq\ M\leq2\times10\ ^\ 5 $
- $ 1\leq\ T\ _\ i\leq\ N\ (1\leq\ i\leq\ M) $
- $ 1\leq\ P\ _\ i\leq10\ ^\ {13}\ (1\leq\ i\leq\ M) $
- 入力はすべて整数
 
### Sample Explanation 1

たとえば、高橋君が次のように行動することで、所持金を $ 49 $ 円増やすことができます。 - 町 $ 5 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}-12 $ 円になる。 - $ 1 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+18 $ 円になる。 - 町 $ 4 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}+15 $ 円になる。 - $ 3 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+40 $ 円になる。 - 町 $ 2 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}+34 $ 円になる。 - $ 4 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+49 $ 円になる。 所持金を $ 10\ ^\ {10\ ^\ {100}}+50 $ 円以上にすることはできないため、`49` を出力してください。

### Sample Explanation 2

通行料が高すぎるので、高橋君は町 $ 1 $ から動かないのが最適です。

### Sample Explanation 4

出力すべき値が $ 32\operatorname{bit} $ 整数の範囲に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
6 3

4

5 30

2 10

4 25

2 15```

### 输出

```
49```

## 样例 #2

### 输入

```
6 1000000000

4

5 30

2 10

4 25

2 15```

### 输出

```
0```

## 样例 #3

### 输入

```
50 10

15

37 261

28 404

49 582

19 573

18 633

3 332

31 213

30 377

50 783

17 798

4 561

41 871

15 525

16 444

26 453```

### 输出

```
5000```

## 样例 #4

### 输入

```
50 1000000000

15

30 60541209756

48 49238708511

1 73787345006

24 47221018887

9 20218773368

34 40025202486

14 28286410866

24 82115648680

37 62913240066

14 92020110916

24 20965327730

32 67598565422

39 79828753874

40 52778306283

40 67894622518```

### 输出

```
606214471001```

# AI分析结果

### 题目内容重写
AtCoder 王国有 $N$ 个城镇，编号为 $1$ 到 $N$。从城镇 $i$ 到城镇 $j$ 移动需要支付 $C \times |i - j|$ 日元的通行费。

商人高桥君计划参加 $M$ 次市场活动中的 $0$ 次或更多次。第 $i$ 次市场活动的信息由整数对 $(T_i, P_i)$ 表示，表示第 $i$ 次市场活动在城镇 $T_i$ 举行，高桥君参加可以获得 $P_i$ 日元。

所有市场活动按顺序举行，高桥君的移动时间可以忽略不计。高桥君初始拥有 $10^{10^{100}}$ 日元，并且位于城镇 $1$。通过选择参加哪些市场活动以及如何移动，求高桥君最终能够获得的最大利润。

严格来说，高桥君在 $M$ 次市场活动结束后的持有金额为 $10^{10^{100}} + X$，求 $X$ 的最大值。

### 题解分析与结论

#### 题解整理与对比
1. **elbissoPtImaerD (5星)**
   - **关键亮点**：使用动态规划（DP）结合树状数组（BITS）优化转移，拆解绝对值，维护前后缀最大值。
   - **难点解决**：通过拆解绝对值，将转移分为两部分，分别用树状数组维护，时间复杂度为 $O(M \log N)$。
   - **代码实现**：使用两颗树状数组分别维护 $f_{i,j} + jC$ 和 $f_{i,j} - jC$ 的最大值，转移时分别查询前缀和后缀最大值。

2. **yemuzhe (4星)**
   - **关键亮点**：使用动态规划结合树状数组优化转移，拆解绝对值，维护前后缀最大值。
   - **难点解决**：通过拆解绝对值，将转移分为两部分，分别用树状数组维护，时间复杂度为 $O(M \log N)$。
   - **代码实现**：使用两颗树状数组分别维护 $f_j + C \cdot j$ 和 $f_j - C \cdot j$ 的最大值，转移时分别查询前缀和后缀最大值。

3. **sunkuangzheng (4星)**
   - **关键亮点**：使用动态规划结合线段树优化转移，拆解绝对值，维护前后缀最大值。
   - **难点解决**：通过拆解绝对值，将转移分为两部分，分别用线段树维护，时间复杂度为 $O(M \log N)$。
   - **代码实现**：使用两颗线段树分别维护 $f_i + c \cdot i$ 和 $f_i - c \cdot i$ 的最大值，转移时分别查询前缀和后缀最大值。

#### 最优关键思路
1. **拆解绝对值**：将转移方程中的绝对值拆解为两部分，分别处理 $j \leq T_i$ 和 $j > T_i$ 的情况。
2. **数据结构优化**：使用树状数组或线段树维护前后缀最大值，优化转移过程，将时间复杂度从 $O(MN)$ 降低到 $O(M \log N)$。
3. **动态规划状态定义**：定义 $f_i$ 表示参加第 $i$ 次市场活动后的最大收益，通过优化转移方程实现高效计算。

#### 可拓展之处
- **类似问题**：类似的问题可以通过拆解绝对值、使用数据结构优化转移来解决，如区间查询、区间更新等。
- **其他应用**：树状数组和线段树在动态规划优化中广泛应用，特别是在需要维护区间最大值或最小值的情况下。

#### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

#### 个人心得
- **调试经历**：在实现树状数组或线段树时，注意初始化值和边界条件的处理，避免出现错误。
- **踩坑教训**：在拆解绝对值时，确保转移方程的正确性，避免遗漏某些情况。
- **顿悟感想**：通过拆解绝对值和数据结构优化，可以大幅提高动态规划的效率，特别是在大规模数据下。

### 核心代码片段
```cpp
// 树状数组维护最大值
void get_mx1(int p, long long c) {
    for (; p <= n; p += p & -p) tr1[p] = max(tr1[p], c);
}

long long ask1(int p) {
    long long res = -inf;
    for (; p; p &= p - 1) res = max(res, tr1[p]);
    return res;
}

// 转移方程
for (int i = 1, x; i <= m; i++) {
    scanf("%d%lld", &x, &y);
    long long t1 = ask1(x) - (long long) x * c;
    long long t2 = ask2(x) + (long long) x * c;
    f[i] = max(t1, t2) + y, ans = max(ans, f[i]);
    get_mx1(x, f[i] + (long long) x * c);
    get_mx2(x, f[i] - (long long) x * c);
}
```

---
处理用时：52.45秒
# 题目信息

# [ABC354F] Useless for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_f

長さ $ N $ の整数列 $ A $ が与えられます。

$ t\ =\ 1,\ 2,\ \dots\ ,N $ について、 $ A_t $ が $ A $ の最長増加部分列に含まれることがあるか判定してください。

$ A_t $ が $ A $ の最長増加部分列に含まれることがあるとは、以下のことをいいます。

- 最長増加部分列の長さを $ L $ とする。各要素が $ 1 $ 以上 $ N $ 以下の単調増加な整数列 $ i\ =\ (i_1,\ i_2,\ \dots\ ,i_L)\ (i_1\ であって以下をすべて満たすものが存在する。 $
  
  
  - $ A_{i_1} $
  - ある $ k\ (1\ \leq\ k\ \leq\ L) $ が存在して $ i_k\ =\ t $ である

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

最長増加部分列とは？列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下

### Sample Explanation 1

最長増加部分列の $ 1 $ つは $ (2,\ 4,\ 5) $ で、長さは $ 3 $ です。$ (1,\ 4,\ 5) $ も最長増加部分列の $ 1 $ つです。しかし、 $ A_5 $ を含む最長増加部分列はありません。 よって、 $ 1,\ 2,\ 3,\ 4 $ を出力します。

## 样例 #1

### 输入

```
1
5
2 1 4 5 3```

### 输出

```
4
1 2 3 4```

## 样例 #2

### 输入

```
2
6
2 5 3 4 3 4
5
10000 1000 100 1 10```

### 输出

```
5
1 3 4 5 6
2
4 5```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个长度为 $N$ 的整数序列 $A$。

对于 $t = 1, 2, \dots, N$，判断 $A_t$ 是否可能包含在 $A$ 的最长递增子序列（LIS）中。

$A_t$ 可能包含在 $A$ 的最长递增子序列中，当且仅当存在一个长度为 $L$ 的最长递增子序列，且该子序列包含 $A_t$。

**说明/提示**

- **最长递增子序列**：序列 $A$ 的最长递增子序列是指从 $A$ 中选出若干个元素，保持原顺序排列，且这些元素严格递增的最长子序列。

**输入格式**

- 第一行输入一个整数 $T$，表示测试用例的数量。
- 每个测试用例的第一行输入一个整数 $N$，表示序列 $A$ 的长度。
- 第二行输入 $N$ 个整数，表示序列 $A$。

**输出格式**

对于每个测试用例，输出一个整数，表示可能包含在最长递增子序列中的元素个数，然后输出这些元素的下标。

**样例输入**

```
1
5
2 1 4 5 3
```

**样例输出**

```
4
1 2 3 4
```

### 题解分析与结论

#### 综合分析

该问题的核心是判断序列中的每个元素是否可能包含在某个最长递增子序列中。题解普遍采用以下思路：

1. **正向和反向LIS**：首先计算以每个元素结尾的正向LIS长度，然后计算以每个元素开头的反向LIS长度。
2. **拼接判断**：对于每个元素，如果其正向LIS长度加上反向LIS长度减一等于整个序列的LIS长度，则该元素可能包含在某个最长递增子序列中。
3. **优化**：使用二分查找或树状数组优化LIS的计算，确保时间复杂度为 $O(n \log n)$。

#### 最优关键思路

- **正向和反向LIS**：通过计算正向和反向的LIS长度，可以快速判断每个元素是否可能包含在某个最长递增子序列中。
- **树状数组优化**：使用树状数组优化LIS的计算，确保在大数据量下的高效性。

#### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 考察LIS的应用。
2. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439) - 考察LCS与LIS的结合。
3. [P2782 最长上升子序列](https://www.luogu.com.cn/problem/P2782) - 直接考察LIS的求解。

### 高星题解展示

#### 题解1：fuxiheng (★★★★★)

**关键亮点**：
- 使用正向和反向LIS，结合二分查找优化，代码简洁高效。
- 详细解释了拼接判断的逻辑，思路清晰。

**核心代码**：
```cpp
for(int i = 1;i <= n;i++){
    f[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
    p[f[i]] = a[i];
    Max = max(Max, f[i]);
}
for(int i = n;i;i--){
    g[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
    p[g[i]] = a[i];
}
for(int i = 1;i <= n;i++){
    if(f[i] + g[i] - 1 == Max){
        inc[++ans] = i;
    }
}
```

#### 题解2：Keroshi (★★★★☆)

**关键亮点**：
- 使用树状数组优化LIS的计算，代码结构清晰。
- 提供了树状数组的实现细节，便于理解。

**核心代码**：
```cpp
FOR(i, 1, n) {
    f[i] = t1.query(a[i] - 1);
    t1.modify(a[i], f[i] + 1);
}
ROF(i, n, 1) {
    g[i] = t2.query(n - a[i] + 1 - 1);
    t2.modify(n - a[i] + 1, g[i] + 1);
}
```

#### 题解3：rhn7 (★★★★☆)

**关键亮点**：
- 使用二分查找优化LIS的计算，代码简洁。
- 提供了详细的拼接判断逻辑，思路清晰。

**核心代码**：
```cpp
for(int i = 1;i <= n;i++){
    int l = 0, r = ans, s;
    while(l <= r){
        int mid = (l + r) / 2;
        if(dp[mid] < a[i]){
            s = mid;
            l = mid + 1;
        }else{
            r = mid - 1;
        }
    }
    dp[s + 1] = a[i];
    f[i] = s + 1;
    ans = max(ans, s + 1);
}
```

### 个人心得总结

- **调试经历**：在实现树状数组时，注意数组下标从1开始，避免越界问题。
- **踩坑教训**：在拼接判断时，注意减去重复计算的元素，确保逻辑正确。
- **顿悟感想**：通过正向和反向LIS的结合，可以快速判断每个元素是否可能包含在某个最长递增子序列中，思路非常巧妙。

---
处理用时：42.92秒
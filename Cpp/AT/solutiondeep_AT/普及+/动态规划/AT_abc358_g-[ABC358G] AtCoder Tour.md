# 题目信息

# [ABC358G] AtCoder Tour

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc358/tasks/abc358_g

AtCoder Land は $ H $ 行 $ W $ 列のグリッドで表されます。上から $ i $ 番目、左から $ j $ 番目のマスを $ (i,\ j) $ と表記します。

高橋君ははじめマス $ (S_i,\ S_j) $ におり、以下の行動を $ K $ 回繰り返します。

- 高橋君は現在いるマスに留まるか、隣のマスに移動する。その後の時点で高橋君がいるマスを $ (i,\ j) $ として $ A_{i,\ j} $ の楽しさを得る。
 
高橋君が得ることのできる楽しさの合計の最大値を求めてください。

ただし、マス $ (x',\ y') $ がマス $ (x,\ y) $ の隣のマスであるとは $ |x\ -\ x'|\ +\ |y\ -\ y'|\ =\ 1 $ であることを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 50 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ S_i\ \leq\ H $
- $ 1\ \leq\ S_j\ \leq\ W $
- $ 1\ \leq\ A_{i,\ j}\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

高橋君は以下のように行動することで楽しさの合計を $ 14 $ にすることができます。 - はじめ、高橋君は $ (1,\ 2) $ にいる。 - 高橋君はマス $ (2,\ 2) $ に移動する。その後、$ A_{2,\ 2}\ =\ 4 $ の楽しさを得る。 - 高橋君はマス $ (2,\ 3) $ に移動する。その後、$ A_{2,\ 3}\ =\ 5 $ の楽しさを得る。 - 高橋君はマス $ (2,\ 3) $ に留まる。その後、$ A_{2,\ 3}\ =\ 5 $ の楽しさを得る。 高橋君は楽しさの合計を $ 14 $ より大きくすることはできないため、$ 14 $ を出力します。

## 样例 #1

### 输入

```
2 3 3

1 2

2 1 2

3 4 5```

### 输出

```
14```

## 样例 #2

### 输入

```
2 2 1000000000

2 1

100 100

100 99```

### 输出

```
100000000000```

# AI分析结果

### 题目翻译

AtCoder Land 是一个由 $H$ 行 $W$ 列组成的网格。从上到下第 $i$ 行、从左到右第 $j$ 列的格子记为 $(i, j)$。

高桥君最初位于格子 $(S_i, S_j)$，他将重复以下操作 $K$ 次：

- 高桥君可以选择留在当前格子，或者移动到相邻的格子。操作结束后，高桥君所在的格子 $(i, j)$ 将获得 $A_{i, j}$ 的乐趣值。

请计算高桥君能够获得的最大乐趣值总和。

相邻格子的定义是：如果格子 $(x', y')$ 与格子 $(x, y)$ 满足 $|x - x'| + |y - y'| = 1$，则称它们为相邻格子。

### 说明/提示

#### 约束条件

- $1 \leq H, W \leq 50$
- $1 \leq K \leq 10^9$
- $1 \leq S_i \leq H$
- $1 \leq S_j \leq W$
- $1 \leq A_{i, j} \leq 10^9$
- 输入的所有值均为整数

### 样例 #1

#### 输入

```
2 3 3

1 2

2 1 2

3 4 5
```

#### 输出

```
14
```

### 样例 #2

#### 输入

```
2 2 1000000000

2 1

100 100

100 99
```

#### 输出

```
100000000000
```

---

### 题解分析与结论

#### 关键思路总结

1. **最优策略**：高桥君的最优策略是先移动到某个格子，然后一直停留在该格子。这是因为移动后停留在高乐趣值的格子比继续移动更有利。
2. **状态转移**：使用动态规划（DP）来记录每一步的最大乐趣值。设 $f_{i,j,k}$ 表示在第 $k$ 步时位于 $(i,j)$ 的最大乐趣值。转移时考虑从当前格子移动到相邻格子或停留在原地。
3. **步数优化**：由于 $K$ 可能很大，但网格大小有限，因此只需考虑最多 $H \times W$ 步的移动，之后的步数可以直接停留在某个格子。

#### 最优题解推荐

1. **题解作者：沉石鱼惊旋**  
   - **星级**：★★★★★  
   - **关键亮点**：详细分析了最优策略，并提出了两种解法，分别基于动态规划和最短路算法。代码清晰，思路严谨。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= min(n * m, k); i++) {
         for (int x = 1; x <= n; x++) {
             for (int y = 1; y <= m; y++) {
                 for (int _ = 0; _ < 4; _++) {
                     int tx = x + dx[_];
                     int ty = y + dy[_];
                     if (!in(tx, ty)) continue;
                     chkmx(dis[i][tx][ty], dis[i - 1][x][y] + a[tx][ty]);
                 }
             }
         }
         for (int x = 1; x <= n; x++)
             for (int y = 1; y <= m; y++)
                 chkmx(ans, dis[i][x][y] + a[x][y] * (k - i));
     }
     ```
   - **个人心得**：作者提到“赛时看了一眼就会了，关键结论有点典，DP 部分也比较基础”，说明该题解的思路较为直观，适合快速理解。

2. **题解作者：ttq012**  
   - **星级**：★★★★☆  
   - **关键亮点**：通过分层图的思想，递推求出每个格子在 $k \leq n \times m$ 步后的最大价值，最后枚举停留的格子计算答案。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= min(n * m, k); i++) {
         for (int j = 1; j <= n; j++) {
             for (int k = 1; k <= m; k++) {
                 f[i][j][k] = f[i - 1][j][k] + a[j][k];
                 for (int d = 0; d < 4; d++) {
                     int nx = j + dx[d], ny = k + dy[d];
                     if (nx >= 1 && nx <= n && ny >= 1 && ny <= m)
                         f[i][nx][ny] = max(f[i][nx][ny], f[i - 1][j][k] + a[nx][ny]);
                 }
             }
         }
     }
     ```
   - **个人心得**：作者通过反证法证明了“至多走 $n \times m$ 步之后就会停留在一个格子里”的结论，增强了题解的说服力。

3. **题解作者：incra**  
   - **星级**：★★★★☆  
   - **关键亮点**：通过 DP 记录每一步的最大乐趣值，并在最后处理停留问题。代码简洁，思路清晰。  
   - **核心代码**：
     ```cpp
     for (int s = 0; s <= min(n * m, k); s++) {
         for (int i = 1; i <= n; i++) {
             for (int j = 1; j <= m; j++) {
                 for (int d = 0; d < 4; d++) {
                     int ni = i + dx[d], nj = j + dy[d];
                     tomax(f[s + 1][ni][nj], f[s][i][j] + a[ni][nj]);
                 }
                 tomax(ans, f[s][i][j] + (LL)(k - s) * a[i][j]);
             }
         }
     }
     ```
   - **个人心得**：作者提到“性质感觉挺显然的~~但是我不会证~~”，说明该题解的思路较为直观，适合快速理解。

### 推荐题目

1. **洛谷 P1219 [USACO1.5]八皇后 Checker Challenge**  
   - **题号**：P1219  
   - **相似知识点**：回溯算法、状态转移

2. **洛谷 P1433 吃奶酪**  
   - **题号**：P1433  
   - **相似知识点**：动态规划、状态压缩

3. **洛谷 P1048 [NOIP2005 普及组] 采药**  
   - **题号**：P1048  
   - **相似知识点**：动态规划、背包问题

---
处理用时：50.89秒
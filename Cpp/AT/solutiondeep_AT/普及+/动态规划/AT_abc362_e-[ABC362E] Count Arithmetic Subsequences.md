# 题目信息

# [ABC362E] Count Arithmetic Subsequences

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc362/tasks/abc362_e

長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。各 $ k=1,2,\dots,N $ について、$ A $ の長さ $ k $ の（連続するとは限らない）部分列であって等差数列であるようなものの個数を $ 998244353 $ で割ったあまりを求めてください。ただし、$ 2 $ つの部分列が列として同じでも、取り出す位置が異なるならば区別するものとします。

部分列とは数列 $ A $ の部分列とは、$ A $ の要素を $ 0 $ 個以上選んで削除し、残った要素を元の順序を保って並べた数列のことを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 80 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力はすべて整数

### Sample Explanation 1

\- 長さ $ 1 $ の部分列は全部で $ 5 $ 個あり、これらはすべて長さ $ 1 $ の等差数列です。 - 長さ $ 2 $ の部分列は全部で $ 10 $ 個あり、これらはすべて長さ $ 2 $ の等差数列です。 - 長さ $ 3 $ の部分列であって等差数列であるものは、$ (A_1,A_2,A_3),(A_1,A_2,A_5),(A_1,A_4,A_5) $ の $ 3 $ つです。 - 長さ $ 4 $ 以上の部分列であって等差数列であるものは存在しません。

## 样例 #1

### 输入

```
5
1 2 3 2 3```

### 输出

```
5 10 3 0 0```

## 样例 #2

### 输入

```
4
1 2 3 4```

### 输出

```
4 6 2 1```

## 样例 #3

### 输入

```
1
100```

### 输出

```
1```

# AI分析结果

### 题目内容重写
#### [ABC362E] 统计等差子序列

**题目描述**

给定一个长度为 $N$ 的数列 $A=(A_1,A_2,\dots,A_N)$。对于每个 $k=1,2,\dots,N$，求 $A$ 中长度为 $k$ 的（不一定是连续的）子序列中，满足等差数列条件的子序列的个数，结果对 $998244353$ 取模。注意，如果两个子序列的元素相同但选取的位置不同，则视为不同的子序列。

子序列的定义是：从数列 $A$ 中删除任意数量的元素（可以是零个），并保持剩余元素的顺序不变所得到的数列。

**说明/提示**

- 约束条件：
  - $1 \leq N \leq 80$
  - $1 \leq A_i \leq 10^9$
  - 输入均为整数

**样例解释**

- 样例1：
  - 输入：
    ```
    5
    1 2 3 2 3
    ```
  - 输出：
    ```
    5 10 3 0 0
    ```
  - 解释：
    - 长度为1的子序列共有5个，均为等差数列。
    - 长度为2的子序列共有10个，均为等差数列。
    - 长度为3的子序列中，等差数列有 $(A_1,A_2,A_3)$、$(A_1,A_2,A_5)$、$(A_1,A_4,A_5)$ 共3个。
    - 长度为4及以上的子序列中没有等差数列。

### 题解分析与结论

#### 题解1：_determination_ (4星)
- **关键亮点**：使用三维DP数组 $f_{i,j,k}$ 表示长度为 $i$，最后两项为 $a_j$ 和 $a_k$ 的方案数，复杂度为 $O(n^4)$。
- **代码实现**：
  ```cpp
  for ( int i = 3 ; i <= n ; i++ )
  {
      for ( int j = i-1 ; j <= n ; j++ )
      {
          for ( int k = j+1 ; k <= n ; k++ )
          {
              for ( int l = i-2 ; l < j ; l++ )
              {
                  if(a[j]-a[l]==a[k]-a[j])
                      f[i][j][k]=(f[i][j][k]+f[i-1][l][j])%mod;
              }
              ans[i]+=f[i][j][k];
          }
      }
  }
  ```
- **总结**：思路清晰，代码简洁，但复杂度较高，适合小规模数据。

#### 题解2：MightZero (4星)
- **关键亮点**：使用DP状态 $dp_{i,len,d}$ 表示以 $i$ 结尾，长度为 $len$，公差为 $d$ 的方案数，通过离散化公差优化复杂度至 $O(n^3 \log n)$。
- **代码实现**：
  ```cpp
  loop(i,1,n)loop(len,2,i)loop(j,1,i-1)
  {
      ll dpos=lower_bound(d.begin(),d.end(),a[i]-a[j])-d.begin();
      (dp[i][len][dpos]+=dp[j][len-1][dpos])%=MOD;
  }
  ```
- **总结**：通过离散化优化了公差处理，思路清晰，代码可读性较好。

#### 题解3：Po7ed (4星)
- **关键亮点**：结合爆搜和数学优化，通过预处理 $d=0$ 的情况，避免全1数据的爆炸情况，复杂度较低。
- **代码实现**：
  ```cpp
  for(auto x:cnt)
  {
      for(int l=1;l<=x.second;l++)
      {
          ans[l]=(ans[l]+C(x.second,l))%mod;
      }
  }
  ```
- **总结**：通过数学优化避免了爆搜的极端情况，思路新颖，代码实现简洁。

### 最优关键思路
- **离散化公差**：通过离散化公差，减少状态空间，优化复杂度。
- **数学优化**：对于特殊情况的处理（如全1数据），通过数学公式直接计算，避免不必要的搜索。
- **DP状态设计**：合理设计DP状态，如使用三维数组记录长度、最后两项等，确保状态转移的正确性。

### 可拓展之处
- **类似问题**：可以拓展到其他子序列计数问题，如等比数列子序列、斐波那契子序列等。
- **优化技巧**：离散化、滚动数组等优化技巧在其他DP问题中也有广泛应用。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得摘录
- **Po7ed**：通过随机数据测试发现爆搜在极端情况下会TLE，因此结合数学优化避免了这种情况。
- **MightZero**：使用离散化优化了公差处理，减少了状态空间，提高了效率。

---
处理用时：38.50秒
# 题目信息

# [ABC366F] Maximum Composition

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc366/tasks/abc366_f

$ N $ 個の一次関数 $ f_1,f_2,\ldots,f_N $ が与えられます。$ f_i(x)=A_i\ x+B_i $ です。

$ 1 $ 以上 $ N $ 以下の**相異なる** $ K $ 個の整数からなる長さ $ K $ の数列 $ p=(p_1,p_2,\ \ldots\ p_K) $ について、$ f_{p_1}(f_{p_2}(\ldots\ f_{p_K}(1)\ldots\ )) $ としてありえる最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^{5} $
- $ 1\ \leq\ K\ \leq\ \text{min}(N,10) $
- $ 1\ \leq\ A_i,B_i\ \leq\ 50 $ $ (1\ \leq\ i\ \leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

ありえるすべての $ p $ とそれに対応する $ f_{p_1}(f_{p_2}(1)) $ の値は以下の通りです。 - $ p=\ (\ 1,2\ ) $ : $ f_1(f_2(1))=15 $ - $ p=\ (\ 1,3\ ) $ : $ f_1(f_3(1))=15 $ - $ p=\ (\ 2,1\ ) $ : $ f_2(f_1(1))=10 $ - $ p=\ (\ 2,3\ ) $ : $ f_2(f_3(1))=11 $ - $ p=\ (\ 3,1\ ) $ : $ f_3(f_1(1))=22 $ - $ p=\ (\ 3,2\ ) $ : $ f_3(f_2(1))=26 $ よって、 $ 26 $ と出力します。

## 样例 #1

### 输入

```
3 2
2 3
1 5
4 2```

### 输出

```
26```

## 样例 #2

### 输入

```
10 3
48 40
34 22
24 37
45 40
48 31
49 44
45 40
44 6
35 22
39 28```

### 输出

```
216223```

# AI分析结果

### 题目内容重写

**题目描述**

给定 $N$ 个一次函数 $f_1, f_2, \ldots, f_N$，其中 $f_i(x) = A_i x + B_i$。从 $1$ 到 $N$ 中选择 $K$ 个**互不相同**的整数，构成一个长度为 $K$ 的序列 $p = (p_1, p_2, \ldots, p_K)$，求 $f_{p_1}(f_{p_2}(\ldots f_{p_K}(1) \ldots ))$ 的最大可能值。

**说明/提示**

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq K \leq \min(N, 10)$
- $1 \leq A_i, B_i \leq 50$ $(1 \leq i \leq N)$
- 输入均为整数

**样例解释 1**

所有可能的 $p$ 及其对应的 $f_{p_1}(f_{p_2}(1))$ 的值如下：
- $p = (1, 2)$ : $f_1(f_2(1)) = 15$
- $p = (1, 3)$ : $f_1(f_3(1)) = 15$
- $p = (2, 1)$ : $f_2(f_1(1)) = 10$
- $p = (2, 3)$ : $f_2(f_3(1)) = 11$
- $p = (3, 1)$ : $f_3(f_1(1)) = 22$
- $p = (3, 2)$ : $f_3(f_2(1)) = 26$

因此，输出 $26$。

### 题解分析与结论

#### 综合分析
1. **排序与贪心**：大多数题解都提到了通过排序来确定函数的嵌套顺序，使得最终结果最大化。具体来说，通过比较两个函数 $f_i$ 和 $f_j$ 的嵌套结果 $f_i(f_j(x))$ 和 $f_j(f_i(x))$，推导出排序规则。
2. **动态规划**：在确定了排序规则后，使用动态规划来选择最优的 $K$ 个函数。通常设 $dp_{i,j}$ 表示前 $i$ 个函数中选择 $j$ 个函数的最大值，转移方程为 $dp_{i,j} = \max(dp_{i-1,j}, dp_{i-1,j-1} \times A_i + B_i)$。
3. **优化与实现**：部分题解提到了使用前缀最大值优化，或者通过状压 DP 来加速计算。

#### 最优思路总结
- **排序规则**：按照 $\frac{A_i - 1}{B_i}$ 从大到小排序，确保嵌套顺序最优。
- **动态规划**：使用二维 DP 数组 $dp_{i,j}$ 记录前 $i$ 个函数中选择 $j$ 个函数的最大值，转移时考虑是否选择当前函数。
- **优化技巧**：使用前缀最大值优化，减少重复计算。

#### 推荐题解
1. **作者：lzyqwq (赞：54)**
   - **星级：5星**
   - **关键亮点**：详细推导了排序规则，并通过动态规划实现了最优解。代码清晰，逻辑严谨。
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = 1; j <= k; j++) {
             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] * a[i] + b[i]);
         }
     }
     ```

2. **作者：JuRuoOIer (赞：9)**
   - **星级：4星**
   - **关键亮点**：提出了两种做法，一种是状压 DP，另一种是贪心+全排列。代码实现简洁，适合快速理解。
   - **代码片段**：
     ```cpp
     for (int S = 1; S < (1 << n); S++) {
         if (__builtin_popcount(S) <= k) {
             for (int i = 0; i < n; i++) {
                 if (((S >> i) & 1) == 1) {
                     int T = S ^ (1 << i);
                     f[S] = max(f[S], line[i].a * f[T] + line[i].b);
                 }
             }
         }
     }
     ```

3. **作者：WerChange (赞：8)**
   - **星级：4星**
   - **关键亮点**：通过贪心+DP 的思路，详细解释了排序规则和 DP 转移方程。代码实现清晰，易于理解。
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = 1; j <= k; j++) {
             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] * a[i] + b[i]);
         }
     }
     ```

### 扩展思路与推荐题目
- **扩展思路**：类似的问题可以通过排序+DP 的方式解决，尤其是涉及到选择最优子序列的问题。此外，可以考虑使用更高效的 DP 优化技巧，如滚动数组、前缀最大值等。
- **推荐题目**：
  1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
  2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
  3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)

### 个人心得摘录
- **作者：lzyqwq**：通过数学归纳法和一次函数的单调性证明了排序规则的正确性，强调了排序规则的重要性。
- **作者：JuRuoOIer**：提出了“人类智慧”的做法，通过状压 DP 和贪心+全排列的方式快速解决问题，强调了灵活运用不同算法的重要性。
- **作者：WerChange**：详细解释了贪心+DP 的思路，强调了排序规则和 DP 转移方程的推导过程，帮助读者更好地理解问题。

---
处理用时：52.53秒
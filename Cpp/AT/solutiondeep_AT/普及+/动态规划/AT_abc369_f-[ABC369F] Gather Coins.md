# 题目信息

# [ABC369F] Gather Coins

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc369/tasks/abc369_f

縦 $ H $ 行、横 $ W $ 列のグリッドがあります。 このグリッドの上から $ i $ 行目、左から $ j $ 列目にあるマスのことを $ (i,j) $ と表記します。

このグリッド上には $ N $ 枚のコインが落ちており、$ i $ 個目のコインはマス $ (R_i,C_i) $ を通ることで拾うことができます。

あなたの目標は、マス $ (1,1) $ から始めて下か右に $ 1 $ マス移動することを繰り返し、できるだけ多くのコインを拾いながらマス $ (H,W) $ まで行くことです。

あなたが拾うことのできるコインの枚数の最大値、およびそれを達成するための移動経路を $ 1 $ つ求めてください。

## 说明/提示

### 制約

- $ 2\leq\ H,W\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ N\ \leq\ \min(HW-2,\ 2\times\ 10^5) $
- $ 1\leq\ R_i\ \leq\ H $
- $ 1\leq\ C_i\ \leq\ W $
- $ (R_i,C_i)\neq\ (1,1) $
- $ (R_i,C_i)\neq\ (H,W) $
- $ (R_i,C_i) $ は互いに相異なる
- 入力は全て整数
 
### Sample Explanation 1

!\[\](https://img.atcoder.jp/abc369/8c45374379376c75b6cfd44cb8efeaf8.png) 上図のように $ (1,1)\rightarrow\ (2,1)\rightarrow\ (2,2)\rightarrow\ (2,3)\rightarrow\ (3,3)\rightarrow\ (3,4) $ と移動することで、$ (2,1),(2,3),(3,3) $ にある $ 3 $ 枚のコインを拾うことができます。

### Sample Explanation 2

`RD` という移動経路も正解となります。

## 样例 #1

### 输入

```
3 4 4

3 3

2 1

2 3

1 4```

### 输出

```
3

DRRDR```

## 样例 #2

### 输入

```
2 2 2

2 1

1 2```

### 输出

```
1

DR```

## 样例 #3

### 输入

```
10 15 8

2 7

2 9

7 9

10 3

7 11

8 12

9 6

8 1```

### 输出

```
5

DRRRRRRRRDDDDDRRDRDDRRR```

# AI分析结果

### 题目翻译

#### 题目描述

给定一个 $H$ 行 $W$ 列的网格。网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子记为 $(i,j)$。

在这个网格上有 $N$ 枚硬币，第 $i$ 枚硬币位于格子 $(R_i, C_i)$。你可以通过移动到这个格子来拾取这枚硬币。

你的目标是从 $(1,1)$ 出发，每次只能向下或向右移动一个格子，最终到达 $(H,W)$，并且在移动过程中尽可能多地拾取硬币。

请找出你能够拾取的最大硬币数，并输出一条能够达到最大值的移动路径。

#### 输入格式

- 第一行包含三个整数 $H, W, N$，分别表示网格的行数、列数和硬币的数量。
- 接下来 $N$ 行，每行包含两个整数 $R_i, C_i$，表示第 $i$ 枚硬币的位置。

#### 输出格式

- 第一行输出一个整数，表示能够拾取的最大硬币数。
- 第二行输出一个字符串，表示移动路径。其中 `D` 表示向下移动，`R` 表示向右移动。

#### 样例

**样例 1**

输入：
```
3 4 4
3 3
2 1
2 3
1 4
```

输出：
```
3
DRRDR
```

**样例 2**

输入：
```
2 2 2
2 1
1 2
```

输出：
```
1
DR
```

### 题解分析与结论

#### 综合分析

本题的核心在于如何在网格中找到一条从 $(1,1)$ 到 $(H,W)$ 的路径，使得路径上经过的硬币数量最多。由于每次只能向下或向右移动，因此路径上的点必须满足行号和列号都非严格递增。这可以转化为一个二维偏序问题，即寻找一个序列，使得每个点的行号和列号都大于等于前一个点。

大多数题解采用了动态规划（DP）结合树状数组或线段树的优化方法。首先将硬币按照行号排序，然后对列号进行最长不下降子序列（LIS）的求解。为了输出路径，题解中通常会记录每个点的前驱，最后通过回溯得到路径。

#### 最优关键思路

1. **排序与LIS**：将硬币按照行号排序，然后对列号进行LIS求解，这样可以保证行号和列号都满足非严格递增的条件。
2. **树状数组优化**：使用树状数组或线段树来维护列号的前缀最大值，从而将DP的复杂度从 $O(n^2)$ 优化到 $O(n \log n)$。
3. **路径记录**：在DP过程中记录每个点的前驱，最后通过回溯得到路径。

#### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 考察最长不下降子序列的经典问题。
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 类似于LIS的变形问题。
3. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439) - 考察LIS的应用。

### 精选题解

#### 题解1：__Allen_123__ (4星)

**关键亮点**：
- 将问题转化为二维偏序问题，使用树状数组优化DP。
- 详细解释了如何通过排序和LIS来解决问题，并记录了路径。

**核心代码**：
```cpp
void add(int x, int p, int k) {
    for(; x <= N-10; x += lb(x)) {
        if(k > f[x].se) f[x] = {p, k};
    }
}

pair<int,int> query(int x) {
    int res = 0, p = 0;
    for(; x; x -= lb(x)) {
        if(f[x].se > res) res = f[x].se, p = f[x].fi;
    }
    return make_pair(res, p);
}
```

#### 题解2：cjh20090318 (4星)

**关键亮点**：
- 使用树状数组优化DP，并详细解释了如何记录路径。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
void add(int x, int p, int k) {
    for(; x <= w; x += lb(x)) {
        if(k > f[x].se) f[x] = {p, k};
    }
}

pair<int,int> query(int x) {
    int res = 0, p = 0;
    for(; x; x -= lb(x)) {
        if(f[x].se > res) res = f[x].se, p = f[x].fi;
    }
    return {res, p};
}
```

#### 题解3：Dtw_ (4星)

**关键亮点**：
- 使用树状数组维护前缀最大值，并详细解释了如何通过排序和LIS来解决问题。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
void add(int x, int p, int k) {
    for(; x <= N-10; x += lb(x)) {
        if(k > f[x].se) f[x] = {p, k};
    }
}

pair<int,int> query(int x) {
    int res = 0, p = 0;
    for(; x; x -= lb(x)) {
        if(f[x].se > res) res = f[x].se, p = f[x].fi;
    }
    return {res, p};
}
```

### 总结

本题的核心在于将二维偏序问题转化为LIS问题，并通过树状数组或线段树优化DP。通过记录前驱，可以方便地回溯得到路径。推荐的三道题目可以帮助巩固LIS和DP的相关知识。

---
处理用时：60.23秒
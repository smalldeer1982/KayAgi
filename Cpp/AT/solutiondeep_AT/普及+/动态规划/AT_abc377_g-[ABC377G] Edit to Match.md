# 题目信息

# [ABC377G] Edit to Match

## 题目描述

给你 $N$ 个字符串 $S_1,S_2,\ldots,S_N$ 。每个字符串都由小写英文字母组成。

对于每一个 $k=1,2,\ldots,N$，解决下列问题：

一开始将一个字符串 $T$ 赋为 $S_k$。

接下来，你可以在下列操作中二选一，并可以操作无限次。但每一次操作都会花费 $1$ 的代价。

- 当 $T$ 不为空时，删除 $T$ 的最后一个字符。
- 在 $T$ 后面加上一个任意的小写字母。

求使 $T$ 要么为空，要么与 $S_1,S_2,\ldots,S_{k-1}$ 中的一个匹配所需的最小代价。

## 说明/提示

- $1\le N\le 2\times10^5$
- $\sum\limits_{i=1}^N|S_i|\le2\times10^5$

## 样例 #1

### 输入

```
3
snuke
snuki
snuuk```

### 输出

```
5
2
4```

## 样例 #2

### 输入

```
3
abc
arc
agc```

### 输出

```
3
3
3```

## 样例 #3

### 输入

```
8
at
atatat
attat
aatatatt
attattat
ttatta
tta
tt```

### 输出

```
2
4
3
8
3
6
3
1```

# AI分析结果

### 题目内容重写

#### [ABC377G] Edit to Match

**题目描述**

给你 $N$ 个字符串 $S_1,S_2,\ldots,S_N$。每个字符串都由小写英文字母组成。

对于每一个 $k=1,2,\ldots,N$，解决下列问题：

一开始将一个字符串 $T$ 赋为 $S_k$。

接下来，你可以在下列操作中二选一，并可以操作无限次。但每一次操作都会花费 $1$ 的代价。

- 当 $T$ 不为空时，删除 $T$ 的最后一个字符。
- 在 $T$ 后面加上一个任意的小写字母。

求使 $T$ 要么为空，要么与 $S_1,S_2,\ldots,S_{k-1}$ 中的一个匹配所需的最小代价。

**说明/提示**

- $1\le N\le 2\times10^5$
- $\sum\limits_{i=1}^N|S_i|\le2\times10^5$

**样例 #1**

**输入**

```
3
snuke
snuki
snuuk
```

**输出**

```
5
2
4
```

**样例 #2**

**输入**

```
3
abc
arc
agc
```

**输出**

```
3
3
3
```

**样例 #3**

**输入**

```
8
at
atatat
attat
aatatatt
attattat
ttatta
tta
tt
```

**输出**

```
2
4
3
8
3
6
3
1
```

---

### 题解分析与结论

#### 综合分析

本题的核心在于如何高效地计算每个字符串 $S_k$ 通过删除和添加操作后，与之前的字符串匹配的最小代价。题解中主要采用了以下几种思路：

1. **前缀匹配与哈希**：通过枚举字符串的前缀，利用哈希表记录每个前缀的最小代价，从而快速计算匹配的最小代价。
2. **Trie树**：利用Trie树存储所有字符串的前缀，并在插入过程中动态更新每个节点的最小匹配代价。
3. **动态规划**：通过维护一个哈希表或Trie树，记录每个前缀的最小代价，并在插入新字符串时更新这些值。

#### 最优思路与技巧

- **前缀匹配与哈希**：通过枚举字符串的前缀，利用哈希表记录每个前缀的最小代价，这种方法在时间复杂度上较为优秀，且代码实现相对简洁。
- **Trie树**：Trie树在处理字符串前缀匹配问题时具有天然的优势，尤其是在需要频繁查询和更新前缀代价的场景下，Trie树能够提供较高的效率。

#### 可拓展之处

- **字符串匹配问题**：类似的问题可以通过前缀匹配、哈希表或Trie树来解决，尤其是在需要动态维护字符串集合的场景下。
- **动态规划与哈希结合**：在处理字符串匹配问题时，动态规划与哈希表的结合可以有效地减少时间复杂度，适用于大规模数据处理。

#### 推荐题目

1. [P8306 字典树](https://www.luogu.com.cn/problem/P8306)
2. [P3370 字符串哈希](https://www.luogu.com.cn/problem/P3370)
3. [P3796 AC自动机（简单版）](https://www.luogu.com.cn/problem/P3796)

---

### 高星题解

#### 题解1：作者：PineappleSummer (赞：7)

**星级**：★★★★★

**关键亮点**：
- 通过枚举字符串的前缀，利用哈希表记录每个前缀的最小代价，思路清晰且代码简洁。
- 使用 `unordered_map` 存储哈希值，提高了查询效率。

**代码核心思想**：
```cpp
for (int i = 1; i <= len; ++i) {
    hsh = hsh * 13331 + s[i];
    if (f.count(hsh))
        res = min(res, f[hsh] + len - i), f[hsh] = min(f[hsh], len - i);
    else
        f[hsh] = len - i;
}
```

#### 题解2：作者：Redamancy_Lydic (赞：4)

**星级**：★★★★

**关键亮点**：
- 使用Trie树存储所有字符串的前缀，并在插入过程中动态更新每个节点的最小匹配代价。
- 通过Trie树的遍历，快速找到每个前缀的最小匹配代价。

**代码核心思想**：
```cpp
int insert(char c[]) {
    int m = strlen(c), now = 0, p = 0, ans;
    for (int i = 0; i < m; i++) {
        int &to = trie[now][c[i] - 'a'];
        if (!to) to = ++tot, f[tot] = 0x7fffffff;
        f[to] = min(f[to], f[now] + 1);
        now = to;
        res[++p] = now;
    }
    ans = f[now];
    f[now] = 0;
    for (int i = p - 1; i >= 1; i--) f[res[i]] = min(f[res[i]], f[res[i + 1]] + 1);
    return ans;
}
```

#### 题解3：作者：Heldivis (赞：2)

**星级**：★★★★

**关键亮点**：
- 通过枚举字符串的前缀，利用哈希表记录每个前缀的最小代价，思路清晰且代码简洁。
- 使用 `unordered_map` 存储哈希值，提高了查询效率。

**代码核心思想**：
```cpp
for (int i = 1; i <= len; ++i) {
    hsh = hsh * 13331 + s[i];
    if (f.count(hsh))
        res = min(res, f[hsh] + len - i), f[hsh] = min(f[hsh], len - i);
    else
        f[hsh] = len - i;
}
```

---

### 个人心得

- **调试经历**：在处理字符串匹配问题时，哈希表的冲突可能会导致错误，因此在选择哈希函数时需要特别注意。
- **踩坑教训**：在Trie树的实现中，节点的初始化与更新顺序非常重要，否则可能会导致错误的匹配结果。
- **顿悟感想**：通过前缀匹配与哈希表的结合，可以有效地减少时间复杂度，尤其是在处理大规模数据时，这种方法的优势更加明显。

---
处理用时：47.82秒
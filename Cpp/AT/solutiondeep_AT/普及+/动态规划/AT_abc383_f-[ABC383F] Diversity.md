# 题目信息

# [ABC383F] Diversity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc383/tasks/abc383_f

店で $ N $ 個の商品が売られています。 $ i $ 個目の商品の価格は $ P_i $ 円、効用は $ U_i $ 、色は $ C_i $ です。

あなたは、これらの $ N $ 個の商品から何個か( $ 0 $ 個でもよい)を選んで購入します。 このとき、購入した品物の合計価格は $ X $ 円以下でなければなりません。

あなたの満足度は、購入した商品の効用の合計を $ S $、購入した商品の色の種類数を $ T $ としたとき、$ S+T\ \times\ K $ です。 ここで、$ K $ は入力で与えられる定数です。

あなたの満足度を最大化するように購入する商品を選んだとき、満足度を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ X\ \leq\ 50000 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ P_i\ \leq\ X $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ U_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ C_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N) $
- 入力は全て整数
 
### Sample Explanation 1

$ 1 $ 個目、$ 2 $ 個目の商品を購入したとき、効用の合計 $ S $ は $ 7 $ で、色の種類数 $ T $ は $ 2 $ です。よって、満足度は $ 7+2\ \times\ 5\ =\ 17 $ です。また、満足度が $ 18 $ 以上になるような購入の仕方は存在しないため、答えは $ 17 $ です。

### Sample Explanation 2

$ 2 $ 個目、$ 3 $ 個目、$ 4 $ 個目の商品を購入したとき、効用の合計 $ S $ は $ 35 $ で、色の種類数 $ T $ は $ 3 $ です。よって、満足度は $ 35+3\ \times\ 3\ =\ 44 $ です。また、満足度が $ 45 $ 以上になるような購入の仕方は存在しないため、答えは $ 44 $ です。

## 样例 #1

### 输入

```
3 10 5

1 3 1

7 4 2

4 5 1```

### 输出

```
17```

## 样例 #2

### 输入

```
5 30 3

5 4 3

11 20 1

9 10 4

7 5 2

16 15 4```

### 输出

```
44```

## 样例 #3

### 输入

```
22 75 6426

9 309 9

5 470 5

17 481 12

27 352 14

1 191 18

7 353 20

9 99 15

20 401 17

46 434 19

11 459 22

10 317 19

15 440 18

17 438 19

25 461 22

5 320 22

1 476 21

11 315 3

8 112 9

11 438 13

19 362 8

10 422 13

10 152 21```

### 输出

```
67717```

# AI分析结果

### 题目内容重写

#### 题目描述

商店里有 $N$ 个商品在售。第 $i$ 个商品的价格为 $P_i$ 元，效用为 $U_i$，颜色为 $C_i$。

你可以从这 $N$ 个商品中选择若干个（可以不选）进行购买。要求购买的商品总价格不超过 $X$ 元。

你的满意度由购买商品的效用总和 $S$ 和购买商品的颜色种类数 $T$ 决定，计算公式为 $S + T \times K$，其中 $K$ 是给定的常数。

请选择购买的商品，使得满意度最大化，并输出最大满意度。

#### 输入格式

第一行包含三个整数 $N$、$X$、$K$，分别表示商品数量、预算上限和常数 $K$。

接下来 $N$ 行，每行包含三个整数 $P_i$、$U_i$、$C_i$，分别表示第 $i$ 个商品的价格、效用和颜色。

#### 输出格式

输出一个整数，表示最大满意度。

#### 样例 #1

**输入：**

```
3 10 5
1 3 1
7 4 2
4 5 1
```

**输出：**

```
17
```

#### 样例 #2

**输入：**

```
5 30 3
5 4 3
11 20 1
9 10 4
7 5 2
16 15 4
```

**输出：**

```
44
```

#### 说明/提示

**数据范围：**

- $1 \leq N \leq 500$
- $1 \leq X \leq 50000$
- $1 \leq K \leq 10^9$
- $1 \leq P_i \leq X$ $(1 \leq i \leq N)$
- $1 \leq U_i \leq 10^9$ $(1 \leq i \leq N)$
- $1 \leq C_i \leq N$ $(1 \leq i \leq N)$
- 输入均为整数

### 题解分析与结论

#### 综合分析

本题是一个典型的背包问题变种，难点在于如何将颜色种类数 $T$ 的影响纳入动态规划的状态转移中。大多数题解采用了将颜色分组处理的策略，通过排序和分组来简化状态转移。核心思路是将颜色作为状态的一部分，或者在转移时考虑颜色的首次选择带来的额外收益。

#### 最优关键思路

1. **颜色分组与排序**：将商品按颜色分组，并在组内进行背包问题的动态规划。这样可以确保在转移时能够正确处理颜色的首次选择带来的额外收益。
2. **状态转移优化**：通过引入前缀最大值或滚动数组等技巧，优化状态转移过程，减少时间复杂度。
3. **多维状态设计**：在动态规划中引入额外的状态维度，记录是否已经选择了某种颜色，从而在转移时能够正确处理颜色的首次选择。

#### 推荐题解

1. **作者：gesong**
   - **星级：5**
   - **关键亮点**：清晰的状态转移设计，通过将颜色分组并在组内进行背包问题的动态规划，简化了状态转移过程。代码可读性强，优化程度高。
   - **核心代码：**
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = 0; j <= m; j++)
             f[i][j] = f[i - 1][j];
         for (auto xx : a[i]) {
             int p = xx.first, u = xx.second;
             for (int j = m; j >= p; j--)
                 f[i][j] = max(f[i][j], f[i - 1][j - p] + u + k, f[i][j - p] + u);
         }
     }
     ```

2. **作者：wangyizhi**
   - **星级：4.5**
   - **关键亮点**：通过引入前缀最大值优化状态转移，减少了时间复杂度。代码结构清晰，逻辑严谨。
   - **核心代码：**
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = x; j >= a[i].p; j--) {
             dp[c][j] = max(dp[c][j], dp[c][j - a[i].p] + a[i].w);
             dp[c][j] = max(dp[c][j], pre[c - 1][j - a[i].p] + a[i].w + k);
         }
         for (int j = x; j >= 0; j--)
             pre[c][j] = max(pre[c - 1][j], dp[c][j]);
     }
     ```

3. **作者：mayike**
   - **星级：4**
   - **关键亮点**：通过滚动数组优化空间复杂度，代码简洁高效。状态转移设计合理，易于理解。
   - **核心代码：**
     ```cpp
     for (int i = 1; i <= n; i++) {
         if (i == 1 || a[i].c != a[i - 1].c) {
             for (int j = 0; j <= x; j++) g[j][0] = f[j];
         }
         for (int j = x; j >= a[i].p; j--)
             g[j][1] = max({g[j][1], g[j - a[i].p][1] + a[i].u, g[j - a[i].p][0] + k + a[i].u});
         if (i == n || a[i].c != a[i + 1].c) {
             for (int j = 0; j <= x; j++) {
                 f[j] = max(g[j][0], g[j][1]);
                 g[j][0] = g[j][1] = 0;
             }
         }
     }
     ```

#### 个人心得

- **调试经历**：在处理颜色分组时，需要注意颜色编号的连续性，避免出现颜色编号跳跃导致的错误。
- **踩坑教训**：在状态转移时，需要确保每次转移都正确处理颜色的首次选择，避免重复计算或不必要的转移。
- **顿悟感想**：通过引入前缀最大值优化状态转移，可以显著减少时间复杂度，提高代码效率。

### 推荐题目

1. **P1048 [NOIP2005 普及组] 采药** - 考察背包问题的基本应用。
2. **P1064 [NOIP2006 提高组] 金明的预算方案** - 考察多维背包问题的应用。
3. **P2014 [CTSC1997] 选课** - 考察树形背包问题的应用。

---
处理用时：54.55秒
# 题目信息

# [AGC031B] Reversi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc031/tasks/agc031_b

$ N $ 個の石が一列に並んでいて、左から $ i $ 個目の石は色 $ C_i $ で塗られています。

すぬけ君は、以下の操作を $ 0 $ 回以上の任意の回数行います。

- 同じ色で塗られている $ 2 $ つの石を選ぶ。それらの石の間に置かれている石をすべて、選んだ石と同じ色で塗りかえる。

最終的な石の色の列としてありうるものの個数を $ 10^9+7 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ C_i\ \leq\ 2\times\ 10^5(1\leq\ i\leq\ N) $
- 入力はすべて整数である

### Sample Explanation 1

以下の $ 3 $ 通りの石の色の列を作ることができます。 - 操作を行わないことで、$ (1,2,1,2,2) $ - $ 1,3 $ 番目の石を選んで操作を行うことで、$ (1,1,1,2,2) $ - $ 2,4 $ 番目の石を選んで操作を行うことで、$ (1,2,2,2,2) $

## 样例 #1

### 输入

```
5

1

2

1

2

2```

### 输出

```
3```

## 样例 #2

### 输入

```
6

4

2

5

4

2

4```

### 输出

```
5```

## 样例 #3

### 输入

```
7

1

3

1

2

3

3

2```

### 输出

```
5```

# AI分析结果

### 题目内容重写
[AGC031B] Reversi

#### 题目描述
$ N $ 个石头排成一列，左起第 $ i $ 个石头的颜色为 $ C_i $。

すぬけ君可以进行以下操作任意次数（包括0次）：

- 选择两个颜色相同的石头，将它们之间的所有石头都染成与这两个石头相同的颜色。

求最终可能的石头颜色序列的个数，结果对 $ 10^9+7 $ 取模。

#### 说明/提示
##### 制約
- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ C_i\ \leq\ 2\times\ 10^5(1\leq\ i\leq\ N) $
- 输入均为整数

##### 样例解释1
有以下3种可能的石头颜色序列：
- 不进行操作，得到 $ (1,2,1,2,2) $
- 选择第1和第3个石头进行操作，得到 $ (1,1,1,2,2) $
- 选择第2和第4个石头进行操作，得到 $ (1,2,2,2,2) $

#### 样例 #1
##### 输入
```
5
1
2
1
2
2
```
##### 输出
```
3
```

#### 样例 #2
##### 输入
```
6
4
2
5
4
2
4
```
##### 输出
```
5
```

#### 样例 #3
##### 输入
```
7
1
3
1
2
3
3
2
```
##### 输出
```
5
```

### 题解综合分析与结论
本题的核心是通过动态规划（DP）来计算所有可能的石头颜色序列的个数。大多数题解都采用了类似的思路：使用DP数组 `f[i]` 表示前 `i` 个石头的方案数，并通过维护一个数组 `pre` 来记录每个颜色上一次出现的位置。转移方程主要分为两种情况：
1. 如果当前石头的颜色与前一个石头相同，则直接继承前一个石头的方案数。
2. 如果当前石头的颜色与前一个石头不同，则方案数为前一个石头的方案数加上与当前石头颜色相同的上一个石头的方案数。

### 评分较高的题解
#### 题解1：AmamiyaYuuko (4星)
**关键亮点**：
- 使用了桶（`s[a[i]]`）来维护每个颜色的方案数，避免了重复计算。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
int main() {
    read(n);
    f[0] = 1;
    for (int i = 1; i <= n; ++i) {
        read(a[i]);
        f[i] = f[i - 1];
        if (a[i] != a[i - 1]) {
            f[i] += s[a[i]], f[i] %= mod;
            s[a[i]] += f[i - 1], s[a[i]] %= mod;
        }
    }
    printf("%lld\n", f[n]);
    return 0;
}
```

#### 题解2：concert_B (4星)
**关键亮点**：
- 使用了 `fa[a[i]]` 来记录每个颜色上一次出现的位置，避免了重复计算。
- 代码结构清晰，转移方程明确。

**核心代码**：
```cpp
signed main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(0),std::cout.tie(0);
    std::cin>>n;
    for(int i=1;i<=n;i++){
        int a;
        std::cin>>a;
        dp[i]=i==1?1:dp[i-1];
        dp[i]+=fa[a]==i-1?0:dp[fa[a]];
        dp[i]%=mod;
        fa[a]=i;
    }
    std::cout<<dp[n];
    return 0;
}
```

#### 题解3：Dream__Sky (4星)
**关键亮点**：
- 使用了 `vis[a[i]]` 来记录每个颜色上一次出现的位置，避免了重复计算。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    f[0]=1;
    for(int i=1;i<=n;i++)
    {
        f[i]=f[i-1];
        if(vis[a[i]]&&vis[a[i]]!=i-1) f[i]=(f[i]+f[vis[a[i]]])%MOD;
        vis[a[i]]=i;
    }
    
    cout<<f[n];
    return 0;
}
```

### 最优关键思路或技巧
1. **动态规划**：使用DP数组 `f[i]` 来记录前 `i` 个石头的方案数。
2. **维护颜色上一次出现的位置**：通过 `pre` 或 `vis` 数组来记录每个颜色上一次出现的位置，避免重复计算。
3. **转移方程**：根据当前石头颜色与前一个石头颜色是否相同，分别进行不同的转移。

### 可拓展之处
- **类似题目**：可以扩展到其他需要维护状态的问题，如区间染色、区间合并等。
- **优化技巧**：可以通过预处理或哈希表来进一步优化时间复杂度。

### 推荐题目
1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)

### 个人心得摘录
- **调试经历**：在处理颜色相同的情况时，容易忽略直接继承前一个石头的方案数，导致重复计算。
- **踩坑教训**：在维护颜色上一次出现的位置时，需要注意边界条件，避免数组越界。
- **顿悟感想**：通过维护颜色上一次出现的位置，可以大大简化问题的复杂度，提高代码的可读性和效率。

---
处理用时：51.21秒
# 题目信息

# [AGC054B] Greedy Division

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc054/tasks/agc054_b

みかんが $ N $ 個あり，$ 1 $ から $ N $ までの番号がついています． みかん $ i $ の重さは $ W_i $ です． 高橋くんと青木くんがこれらを以下のようにして分けます．

- $ (1,2,\cdots,N) $ の順列 $ (p_1,\ p_2,\ \cdots,\ p_N) $ を選ぶ．
- $ i\ =\ 1,\ 2,\ \cdots,\ N $ について，この順に以下のことを行う
  
  
  - 高橋くんがすでにとったみかんの重さの合計が，青木くんがすでにとったみかんの重さの合計以下なら，みかん $ p_i $ を高橋くんがとる． そうでないならみかん $ p_i $ を青木くんが取る．

最終的に二人が取るみかんの重さの合計が等しくなるような順列 $ p $ が何通りあるかを $ 998244353 $ で割った余りを求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ W_i\ \leq\ 100 $
- 入力される値はすべて整数

### Sample Explanation 1

条件を満たす $ p $ は，$ (1,3,2),(2,3,1),(3,1,2),(3,2,1) $ の $ 4 $ 通りです． 例えば，$ p=(3,2,1) $ の時は，以下のように進行します． - $ i=1 $: 高橋くんがすでにとったみかんの重さの合計は $ 0 $ で，青木くんがすでにとったみかんの重さの合計は $ 0 $ である． 高橋くんがみかん $ p_i=3 $ をとる． - $ i=2 $: 高橋くんがすでにとったみかんの重さの合計は $ 2 $ で，青木くんがすでにとったみかんの重さの合計は $ 0 $ である． 青木くんがみかん $ p_i=2 $ をとる． - $ i=3 $: 高橋くんがすでにとったみかんの重さの合計は $ 2 $ で，青木くんがすでにとったみかんの重さの合計は $ 1 $ である． 青木くんがみかん $ p_i=1 $ をとる． よって $ p=(3,2,1) $ は条件を満たす順列です．

## 样例 #1

### 输入

```
3

1 1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
4

1 2 3 8```

### 输出

```
0```

## 样例 #3

### 输入

```
20

2 8 4 7 5 3 1 2 4 1 2 5 4 3 3 8 1 7 8 2```

### 输出

```
373835282```

# AI分析结果

### 题目内容重写

**题目描述**

有 $N$ 个橘子，编号从 $1$ 到 $N$。第 $i$ 个橘子的重量为 $W_i$。高桥和青木将按照以下方式分配这些橘子：

1. 选择一个 $(1,2,\cdots,N)$ 的排列 $(p_1,\ p_2,\ \cdots,\ p_N)$。
2. 对于 $i\ =\ 1,\ 2,\ \cdots,\ N$，依次执行以下操作：
   - 如果高桥已经拿到的橘子的总重量不超过青木已经拿到的橘子的总重量，那么高桥拿走第 $p_i$ 个橘子；否则，青木拿走第 $p_i$ 个橘子。

最终，如果两人拿到的橘子的总重量相等，求满足条件的排列 $p$ 的数量，结果对 $998244353$ 取模。

**说明/提示**

- $2\ \leq\ N\ \leq\ 100$
- $1\ \leq\ W_i\ \leq\ 100$
- 输入的所有值都是整数

**样例解释**

样例1中，满足条件的排列有 $(1,3,2),(2,3,1),(3,1,2),(3,2,1)$ 共4种。

### 题解综合分析

本题的核心在于理解排列与分配过程之间的双射关系，即每个合法的分配方案唯一对应一个排列。通过这一性质，问题可以转化为一个背包问题，即从所有橘子中选择一些橘子，使得它们的总重量等于总重量的一半。然后，通过动态规划计算满足条件的方案数，并考虑排列的顺序。

### 所选高分题解

#### 题解1：作者：gxp123 (评分：5星)

**关键亮点：**
- 通过证明排列与分配方案的双射关系，简化了问题。
- 使用动态规划（背包问题）计算满足条件的方案数。
- 通过滚动数组优化空间复杂度。

**核心代码：**
```cpp
int f[2][maxN][maxN * maxN];
int n,a[maxN],jc[maxN];

int main(){
    scanf("%d",&n);
    int sumh = 0;
    jc[0] = 1;
    for(int i = 1 ; i <= n ; ++i){
        scanf("%d",a + i);
        sumh += a[i];
        jc[i] = 1ll * jc[i - 1] * i % mod;
    }
    if(sumh & 1){
        puts("0");
        return 0;
    }
    sumh = sumh >> 1;
    f[0][0][0] = 1;
    for(int i = 1,op,opt ; i <= n ; ++i){
        op = i & 1;
        opt = op ^ 1;
        for(int j = 0 ; j <= i ; ++j){
            for(int k = 0 ; k <= sumh ; ++k){
                f[op][j][k] = f[opt][j][k];
                if(j > 0 && k >= a[i])
                    f[op][j][k] = (f[op][j][k] + f[opt][j - 1][k - a[i]]) % mod;
            }
        }
    }
    long long ans = 0;
    int op = n & 1;
    for(int i = 1 ; i <= n ; ++i){
        ans = (1ll * jc[i] * jc[n - i] % mod * f[op][i][sumh] % mod + ans) % mod;
    }
    cout << ans << endl;
    return 0;
}
```

#### 题解2：作者：卷王 (评分：4.5星)

**关键亮点：**
- 简洁明了地解释了双射关系。
- 使用背包+滚动数组优化，代码简洁高效。

**核心代码：**
```cpp
int dp[107][5007];
int fac[107];

inline void init(){
    fac[0]=1;
    for(int i=1;i<=100;i++)
        fac[i]=fac[i-1]*i%mod;
}

signed main(){
    init();
    n=read();
    for(int i=1;i<=n;i++) a[i]=read(),sum+=a[i];
    if(sum&1){ printf("0\n"); return 0; }
    dp[0][0]=1;
    for(int i=1;i<=n;i++)
        for(int j=n;j>=1;j--)
            for(int k=sum/2;k>=a[i];k--)
                dp[j][k]=(dp[j][k]+dp[j-1][k-a[i]])%mod;
    
    for(int i=1;i<=n;i++)
        ans=(ans+fac[i]*fac[n-i]%mod*dp[i][sum/2]%mod)%mod;
    printf("%lld\n",ans);
    return 0;
}
```

#### 题解3：作者：Jsxts_ (评分：4星)

**关键亮点：**
- 通过背包问题解决，代码简洁。
- 详细解释了排列与分配方案的双射关系。

**核心代码：**
```cpp
int f[110][10010],jc[110];

int main() {
    n = read();
    for (int i = 1;i <= n;i ++ ) a[i] = read(), m += a[i];
    if (m % 2) puts("0"), exit(0);
    f[0][0] = 1;
    m /= 2;
    for (int i = 1;i <= n;i ++ )
        for (int k = n;k;k -- )
            for (int j = m;j >= a[i];j -- )
                f[k][j] = (f[k][j] + f[k - 1][j - a[i]]) % mod;
    int ans = 0;jc[0] = 1;
    for (int i = 1;i <= n;i ++ ) jc[i] = 1ll * jc[i - 1] * i % mod;
    for (int i = 1;i <= n;i ++ ) {
        ans = (ans + 1ll * jc[i] * jc[n - i] % mod * f[i][m] % mod) % mod;
    }
    cout << ans;
    return 0;
}
```

### 最优关键思路与技巧

1. **双射关系**：理解排列与分配方案之间的唯一对应关系，将问题转化为背包问题。
2. **动态规划**：使用背包问题计算满足条件的方案数，并通过滚动数组优化空间复杂度。
3. **排列顺序**：在计算方案数时，考虑排列的顺序，通过阶乘计算排列数。

### 可拓展之处

类似的问题可以通过双射关系转化为背包问题，如分配物品、选择子集等。动态规划是解决这类问题的常用方法，尤其是当问题涉及选择和排列时。

### 推荐题目

1. [P1466 [USACO2.2] 集合 Subset Sums](https://www.luogu.com.cn/problem/P1466)
2. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 [NOIP2006 提高组] 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

---
处理用时：62.62秒
# 题目信息

# [AGC060A] No Majority

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc060/tasks/agc060_a

英小文字からなる文字列 $ x $ が以下の条件を満たすとき，$ x $ を**よい**文字列と呼ぶことにします．

- $ x $ の長さ $ 2 $ 以上の (連続する) 部分文字列は，すべて以下の条件を満たす．
  - その部分文字列内で過半数を占める文字が存在しない．
 
例えば，`acbca` はよい文字列ではありません． これは，部分文字列 `cbc` のなかで `c` が過半数を占めているからです．

英小文字と `?` からなる長さ $ N $ の文字列 $ S $ が与えられます． それぞれの `?` を好きな英小文字に置き換ることで，$ S $ をよい文字列にしたいです． $ S $ をよい文字列にする方法が何通りあるかを $ 998244353 $ で割ったあまりを求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ S $ は英小文字と `?` からなる長さ $ N $ の文字列
 
### Sample Explanation 1

`aab`, `abb` 以外の方法が条件を満たします．

## 样例 #1

### 输入

```
3

a?b```

### 输出

```
24```

## 样例 #2

### 输入

```
3

a?a```

### 输出

```
0```

## 样例 #3

### 输入

```
20

ugsyakganihodnwmktgi```

### 输出

```
1```

## 样例 #4

### 输入

```
20

??a???h?m?y?ts???tl?```

### 输出

```
444225229```

# AI分析结果

### 题目翻译
给定一个由小写字母和 `?` 组成的长度为 $N$ 的字符串 $S$，要求将 `?` 替换为任意小写字母，使得替换后的字符串 $S$ 满足以下条件：

- $S$ 的所有长度大于等于 2 的连续子串中，没有任何一个字符的出现次数超过子串长度的一半。

求满足条件的替换方案数，结果对 $998244353$ 取模。

### 样例解释
- 样例 1：`a?b` 可以替换为 `aab` 或 `abb` 以外的 24 种方案，输出 `24`。
- 样例 2：`a?a` 无法满足条件，输出 `0`。
- 样例 3：`ugsyakganihodnwmktgi` 已经满足条件，输出 `1`。
- 样例 4：`??a???h?m?y?ts???tl?` 有 444225229 种方案，输出 `444225229`。

### 题解分析与结论
各题解的核心思路是通过动态规划（DP）来解决问题，主要关注长度为 2 和 3 的子串是否合法。以下是各题解的要点总结：

1. **核心思路**：所有题解都采用了 DP 的思路，状态定义为 $dp_{i,j,k}$，表示前 $i$ 个字符中，第 $i-1$ 位为 $j$，第 $i$ 位为 $k$ 的合法方案数。
2. **转移方式**：通过枚举当前字符和前两个字符，确保没有连续三个字符中有两个相同。
3. **优化**：部分题解通过预处理或容斥优化了时间复杂度，从 $O(n \times 26^3)$ 优化到 $O(n \times 26^2)$。

### 评分较高的题解
#### 题解1：_JellyFish_ (4星)
- **关键亮点**：思路清晰，代码简洁，直接通过三重循环枚举字符进行转移，适合初学者理解。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++)
      for(int j=0;j<=26;j++)
          for(int k=0;k<=26;k++)
              if(dp[i-1][j][k])
                  for(int l=0;l<26;l++)
                      if((s[i]=='?'||s[i]==l+'a')&&l!=j&&l!=k)
                          dp[i][k][l]=(dp[i][k][l]+dp[i-1][j][k])%mod;
  ```

#### 题解2：ZLCT (4星)
- **关键亮点**：通过预处理优化了时间复杂度，从 $O(n \times 26^3)$ 优化到 $O(n \times 26^2)$，适合追求效率的读者。
- **核心代码**：
  ```cpp
  for(int i=3;i<=n;++i){
      for(int j=0;j<26;++j){
          pre[j]=0;
          for(int k=0;k<26;++k){
              if(j==k)continue;
              pre[j]+=f[i-1][k][j];
              pre[j]%=mod;
          }
      }
      for(int nc=0;nc<26;++nc){
          if(s[i]!='?'&&s[i]-'a'!=nc)continue;
          for(int lc=0;lc<26;++lc){
              if(lc==nc)continue;
              f[i][lc][nc]=(pre[lc]-f[i-1][nc][lc]+mod)%mod;
          }
      }
  }
  ```

### 最优关键思路
- **核心思想**：通过 DP 记录前两个字符的状态，确保没有连续三个字符中有两个相同。
- **优化技巧**：通过预处理或容斥优化时间复杂度，减少不必要的枚举。

### 拓展思路
- **类似题目**：可以扩展到更长的子串或更复杂的字符限制，如要求长度为 4 的子串中没有三个相同字符。
- **算法套路**：类似的 DP 思路可以应用于其他字符串问题，如最长回文子串、字符串匹配等。

### 推荐题目
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1279 字串距离](https://www.luogu.com.cn/problem/P1279)

---
处理用时：40.18秒
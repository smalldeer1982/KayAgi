# 题目信息

# [ARC157C] YY Square

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc157/tasks/arc157_c

$ H $ 行 $ W $ 列のマス目の各マスに `X`, `Y` のいずれかの文字が書かれています． 上から $ i $ 行目，左から $ j $ 列目のマスを $ (i,\ j) $ で表します． マス目に書かれている文字は $ H $ 個の文字列 $ S_1,\ S_2,\ \dots,\ S_H $ によって与えられ，$ S_i $ の $ j $ 文字目がマス $ (i,\ j) $ に書かれた文字を表します．

下または右に隣接するマスへの移動を繰り返してマス $ (1,\ 1) $ からマス $ (H,\ W) $ に至る経路 $ P $ に対して，

- 「 $ P $ で通るマスに書かれた文字を順に並べて得られる長さ $ (H\ +\ W\ -\ 1) $ の文字列」を $ \mathrm{str}(P) $ とし，
- 「 $ \mathrm{str}(P) $ 中で `Y` 同士が隣り合う箇所の**個数の $ 2 $ 乗**」を $ P $ の**スコア**と定義します．
 
そのような経路 $ P $ としてあり得るものは $ \displaystyle\binom{H\ +\ W\ -\ 2}{H\ -\ 1} $ 通りありますが，その全てに対するスコアの総和を $ 998244353 $ で割った余りを求めてください．

  $ \binom{N}{K} $ の意味 $ \displaystyle\binom{N}{K} $ は，$ N $ 個の相異なる要素から $ K $ 個を選ぶ場合の数を表す二項係数です．

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 2000 $
- $ 1\ \leq\ W\ \leq\ 2000 $
- $ S_i\ (1\ \leq\ i\ \leq\ H) $ は `X`, `Y` からなる長さ $ W $ の文字列である．
 
### Sample Explanation 1

経路 $ P $ としてあり得るものは $ (1,\ 1)\ \to\ (1,\ 2)\ \to\ (2,\ 2) $ と $ (1,\ 1)\ \to\ (2,\ 1)\ \to\ (2,\ 2) $ の $ 2 $ 通りです． - $ (1,\ 1)\ \to\ (1,\ 2)\ \to\ (2,\ 2) $ の場合，$ \mathrm{str}(P)\ =\ {} $`YYY` であり，$ 1,\ 2 $ 文字目と $ 2,\ 3 $ 文字目の $ 2 $ 箇所で `Y` 同士が隣り合っているので，スコアは $ 2^2\ =\ 4 $ です． - $ (1,\ 1)\ \to\ (2,\ 1)\ \to\ (2,\ 2) $ の場合，$ \mathrm{str}(P)\ =\ {} $`YXY` であり，`Y` 同士が隣り合う箇所は無いので，スコアは $ 0^2\ =\ 0 $ です． したがって，求める総和は $ 4\ +\ 0\ =\ 4 $ となります．

### Sample Explanation 2

$ 2 $ 通りのいずれの経路の場合も $ \mathrm{str}(P)\ =\ {} $`XYY` であり，スコアは $ 1^2\ =\ 1 $ です．

### Sample Explanation 3

スコアの総和を $ 998244353 $ で割った余りを出力してください．

## 样例 #1

### 输入

```
2 2

YY

XY```

### 输出

```
4```

## 样例 #2

### 输入

```
2 2

XY

YY```

### 输出

```
2```

## 样例 #3

### 输入

```
10 20

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY```

### 输出

```
423787835```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个 $H$ 行 $W$ 列的网格，每个格子中写有字符 `X` 或 `Y`。从上到下第 $i$ 行，从左到右第 $j$ 列的格子表示为 $(i, j)$。网格中的字符由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \dots, S_H$ 给出，$S_i$ 的第 $j$ 个字符表示格子 $(i, j)$ 中的字符。

从格子 $(1, 1)$ 出发，每次只能向下或向右移动，到达格子 $(H, W)$ 的路径 $P$ 的权值定义为：路径 $P$ 所经过的格子中的字符按顺序组成的字符串中，`Y` 相邻出现的次数的平方。

求所有可能的路径的权值之和，结果对 $998244353$ 取模。

#### 说明/提示

- $1 \leq H \leq 2000$
- $1 \leq W \leq 2000$
- $S_i$ 是由 `X` 和 `Y` 组成的长度为 $W$ 的字符串。

#### 样例解释

**样例 1**  
输入：
```
2 2
YY
XY
```
输出：
```
4
```
解释：  
路径 $P$ 有两种可能：
1. $(1, 1) \to (1, 2) \to (2, 2)$，字符串为 `YYY`，`Y` 相邻出现 2 次，权值为 $2^2 = 4$。
2. $(1, 1) \to (2, 1) \to (2, 2)$，字符串为 `YXY`，`Y` 相邻出现 0 次，权值为 $0^2 = 0$。  
总权值为 $4 + 0 = 4$。

**样例 2**  
输入：
```
2 2
XY
YY
```
输出：
```
2
```
解释：  
两条路径的字符串均为 `XYY`，`Y` 相邻出现 1 次，权值为 $1^2 = 1$。  
总权值为 $1 + 1 = 2$。

**样例 3**  
输入：
```
10 20
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
YYYYYYYYYYYYYYYYYYYY
```
输出：
```
423787835
```

### 题解分析与结论

本题的核心在于如何高效计算所有路径的权值之和，且权值是 `Y` 相邻出现次数的平方。由于直接计算平方和较为复杂，大多数题解采用了动态规划（DP）的思路，通过拆解平方和的计算过程，逐步递推得到最终结果。

#### 关键思路与技巧

1. **平方和的拆解**：大多数题解利用了 $(a+1)^2 = a^2 + 2a + 1$ 的公式，将平方和的递推转化为对 $a^2$、$a$ 和常数项的维护。这种拆解方式使得问题可以通过 DP 逐步解决。
  
2. **多维状态维护**：为了计算平方和，题解中通常维护多个状态，如路径数、`Y` 相邻出现的次数和平方和。通过多维状态的转移，能够有效地计算出最终的平方和。

3. **组合数的预处理**：部分题解通过预处理组合数来快速计算路径数，从而在 DP 转移时能够快速更新状态。

4. **边界条件处理**：在处理边界条件时，题解通常会对起点和终点进行特殊处理，确保 DP 的初始状态正确。

#### 最优题解推荐

1. **作者：naoliaok_lovely**  
   - **星级**：4.5  
   - **关键亮点**：通过拆解平方和的公式，维护了三个状态（路径数、`Y` 相邻出现的次数和平方和），并利用组合数预处理优化了路径数的计算。代码清晰，思路明确。
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++)
         for(int j = 1; j <= m; j++)
             if(c[i][j] == 'X') {
                 f[1][i][j] = (f[1][i - 1][j] + f[1][i][j - 1]) % mod;
                 f[2][i][j] = (f[2][i - 1][j] + f[2][i][j - 1]) % mod;
             } else {
                 f[1][i][j] = (f[1][i - 1][j] + f[1][i][j - 1] + (c[i - 1][j] == 'Y' ? C(i + j - 3, i - 2) : 0) + (c[i][j - 1] == 'Y' ? C(i + j - 3, i - 1) : 0)) % mod;
                 f[2][i][j] = (f[2][i - 1][j] + f[2][i][j - 1] + (c[i - 1][j] == 'Y' ? C(i + j - 3, i - 2) + 2 * f[1][i - 1][j] : 0) + (c[i][j - 1] == 'Y' ? C(i + j - 3, i - 1) + 2 * f[1][i][j - 1] : 0)) % mod;
             }
     ```

2. **作者：Cure_Wing**  
   - **星级**：4.0  
   - **关键亮点**：通过维护路径数、`Y` 相邻出现的次数和平方和三个状态，利用 DP 逐步递推，代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++)
         for(int j = 1; j <= m; j++)
             if(s[i][j] == 'X') {
                 for(int k = 0; k <= 2; k++) {
                     f[i][j][0] = (f[i][j][0] + (f[i - 1][j][k] + f[i][j - 1][k]) % p) % p;
                     t[i][j][0] = (t[i][j][0] + (t[i - 1][j][k] + t[i][j - 1][k]) % p) % p;
                     c[i][j][0] = (c[i][j][0] + (c[i - 1][j][k] + c[i][j - 1][k]) % p) % p;
                 }
             } else {
                 f[i][j][1] = (f[i - 1][j][0] + f[i][j - 1][0]) % p;
                 t[i][j][1] = (t[i - 1][j][0] + t[i][j - 1][0]) % p;
                 c[i][j][1] = (c[i - 1][j][0] + c[i][j - 1][0]) % p;
                 c[i][j][2] = ((c[i][j - 1][2] + c[i - 1][j][2]) % p + (c[i][j - 1][1] + c[i - 1][j][1]) % p) % p;
                 t[i][j][2] = ((t[i][j - 1][2] + t[i - 1][j][2]) % p + (t[i][j - 1][1] + t[i - 1][j][1]) % p) % p;
                 f[i][j][2] = (((f[i][j - 1][1] + f[i - 1][j][1]) % p + (f[i][j - 1][2] + f[i - 1][j][2]) % p) % p + (2 * t[i][j][2] % p + c[i][j][2]) % p) % p;
                 t[i][j][2] = (t[i][j][2] + c[i][j][2]) % p;
             }
     ```

3. **作者：Z1qqurat**  
   - **星级**：4.0  
   - **关键亮点**：通过拆解平方和的公式，维护了三个状态（路径数、`Y` 相邻出现的次数和平方和），并利用 DP 逐步递推，代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++)
         for(int j = 1; j <= m; j++) {
             if(i == 1 && j == 1) continue;
             for(int k = 0; k < 2; k++) {
                 int x = i + dx[k], y = j + dy[k];
                 if(x < 1 || y < 1) continue;
                 f[0][i][j] = (f[0][i][j] + f[0][x][y]) % P;
                 if(b[x][y] && b[i][j]) {
                     f[1][i][j] = (f[1][i][j] + f[1][x][y] + f[0][x][y]) % P;
                     f[2][i][j] = (f[2][i][j] + f[2][x][y] + 2ll * f[1][x][y] + f[0][x][y]) % P;
                 } else {
                     f[1][i][j] = (f[1][i][j] + f[1][x][y]) % P;
                     f[2][i][j] = (f[2][i][j] + f[2][x][y]) % P;
                 }
             }
         }
     ```

### 扩展思路与推荐题目

1. **扩展思路**：本题的平方和拆解思路可以推广到其他涉及平方和的问题，如路径权值的平方和、序列中某些特征的平方和等。通过拆解平方和，可以将复杂问题转化为多个简单状态的维护。

2. **推荐题目**：
   - [P1654 OSU!](https://www.luogu.com.cn/problem/P1654)：考察平方和的递推计算。
   - [CF235B Let's Play Osu!](https://www.luogu.com.cn/problem/CF235B)：与本题类似，涉及平方和的计算。
   - [ABC277G](https://www.luogu.com.cn/problem/AT_abc277_g)：涉及平方和的递推计算，与本题思路相似。

### 个人心得总结

- **调试经历**：在处理边界条件时，部分题解在初始化时容易忽略起点和终点的特殊处理，导致 DP 状态转移错误。建议在编写代码时，特别注意边界条件的处理。
- **顿悟感想**：通过拆解平方和的公式，将复杂问题转化为多个简单状态的维护，是解决此类问题的关键。这种思路不仅适用于本题，还可以推广到其他涉及平方和的问题中。

---
处理用时：85.24秒
# 题目信息

# [ARC160C] Power Up

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc160/tasks/arc160_c

正整数からなる $ N $ 要素の多重集合 $ A=\lbrace\ A_1,A_2,\dots,A_N\ \rbrace $ が与えられます。

あなたは、以下の操作を好きな回数 ( $ 0 $ 回でもよい) 繰り返すことが出来ます。

- $ A $ に $ 2 $ 個以上含まれる正整数 $ x $ を選ぶ。$ A $ から $ x $ を $ 2 $ 個削除し、$ A $ に $ x+1 $ を $ 1 $ 個加える。
 
最終的な $ A $ としてあり得るものの個数を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 2\ \times\ 10^5 $
 
### Sample Explanation 1

最終的な $ A $ としてあり得るものは、$ \lbrace\ 1,1,2,4\ \rbrace,\lbrace\ 2,2,4\ \rbrace,\lbrace\ 3,4\ \rbrace $ の $ 3 $ 個があります。 $ \lbrace\ 3,4\ \rbrace $ は以下のようにして作ることが出来ます。 - $ x $ として $ 1 $ を選ぶ。$ A $ から $ 1 $ を $ 2 $ 個削除し、$ 2 $ を $ 1 $ 個加える。$ A=\lbrace\ 2,2,4\ \rbrace $ となる。 - $ x $ として $ 2 $ を選ぶ。$ A $ から $ 2 $ を $ 2 $ 個削除し、$ 3 $ を $ 1 $ 個加える。$ A=\lbrace\ 3,4\ \rbrace $ となる。

## 样例 #1

### 输入

```
4

1 1 2 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5

1 2 3 4 5```

### 输出

```
1```

## 样例 #3

### 输入

```
13

3 1 4 1 5 9 2 6 5 3 5 8 9```

### 输出

```
66```

# AI分析结果

### 题目重写
【题目内容】
# [ARC160C] Power Up

## 题目描述

给定一个由正整数组成的多重集合 $A=\lbrace\ A_1,A_2,\dots,A_N\ \rbrace$。

你可以执行以下操作任意次（包括0次）：

- 选择 $A$ 中出现次数大于等于2的正整数 $x$，从 $A$ 中删除2个 $x$，并向 $A$ 中添加1个 $x+1$。

求最终可能的 $A$ 的集合个数，结果对 $998244353$ 取模。

## 说明/提示

### 制約

- $1\ \le\ N\ \le\ 2\ \times\ 10^5$
- $1\ \le\ A_i\ \le\ 2\ \times\ 10^5$

### 样例解释1

最终可能的 $A$ 有 $\lbrace\ 1,1,2,4\ \rbrace,\lbrace\ 2,2,4\ \rbrace,\lbrace\ 3,4\ \rbrace$ 三种。

## 样例 #1

### 输入

```
4

1 1 2 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5

1 2 3 4 5```

### 输出

```
1```

## 样例 #3

### 输入

```
13

3 1 4 1 5 9 2 6 5 3 5 8 9```

### 输出

```
66```

---

### 题解分析与结论

本题的核心是通过动态规划（DP）来计算最终可能的集合个数。由于操作的性质，我们可以从小到大地处理每个数，避免后效性。难点在于如何高效地设计状态转移，并优化空间和时间复杂度。

#### 关键思路：
1. **从小到大的处理顺序**：为了避免后效性，从小到大处理每个数，确保每个数的操作不会影响到已经处理过的数。
2. **状态压缩与优化**：通过分析，发现状态数实际上是线性的，因此可以使用滚动数组或向量来存储状态，避免空间爆炸。
3. **后缀和优化**：在状态转移时，使用后缀和优化，将时间复杂度从 $O(n^2)$ 降低到 $O(n)$。

#### 最优题解：
1. **作者：Mars_Dingdang (5星)**
   - **亮点**：清晰地定义了状态转移方程，并使用后缀和优化，代码简洁且高效。
   - **代码核心**：
     ```cpp
     vector<int> f[maxn];
     rep(i, 1, 200050) {
         f[i].resize((num[i] + f[i - 1].size()) / 2 + 1);
         for(int j = 0; j < f[i - 1].size(); ++ j)
             (f[i][(j + num[i]) / 2] += f[i - 1][j]) %= mod;
         for(int j = f[i].size() - 2; j >= 0; -- j)
             (f[i][j] += f[i][j + 1]) %= mod;
     }
     ```
   - **心得**：通过后缀和优化，成功将时间复杂度降低到线性。

2. **作者：TernaryTree (4星)**
   - **亮点**：通过数学推导证明了状态数的线性性质，并使用了滚动数组优化空间。
   - **代码核心**：
     ```cpp
     for (int i = 2; i <= m; i++) {
         for (int j = 0; ; j++) {
             int l = max(j * 2 - cnt[i - 1], 0ll);
             if (l < f[i - 1].size()) {
                 f[i].push_back(g[i - 1][l]);
                 continue;
             }
             break;
         }
         g[i] = f[i];
         for (int j = (int) g[i].size() - 2; ~j; j--) (g[i][j] += g[i][j + 1]) %= mod;
     }
     ```
   - **心得**：通过数学推导，简化了状态转移的复杂度。

3. **作者：xqh07 (4星)**
   - **亮点**：通过滚动数组和后缀和优化，实现了线性时间复杂度的DP。
   - **代码核心**：
     ```cpp
     for(int i = mn + 1; i <= mx + 50; i++) {
         y = a[i] + (y / 2);
         for(int j = 0; j < a[i]; j++) dp[j] = 0;
         for(int j = a[i]; j <= y; j++) dp[j] = s[(j - a[i]) * 2];
         s[y] = dp[y];
         for(int j = y - 1; j >= 0; j--) s[j] = (s[j + 1] + dp[j]) % mod;
     }
     ```
   - **心得**：通过滚动数组和后缀和优化，成功降低了空间和时间复杂度。

#### 通用建议：
- **状态压缩**：在处理大规模数据时，尽量通过数学推导或状态压缩来减少状态数。
- **后缀和优化**：在DP中，如果转移方程涉及区间求和，考虑使用前缀和或后缀和优化。

#### 推荐题目：
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典DP问题，适合练习状态转移。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 背包问题的变种，适合练习DP优化。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 双序列DP问题，适合练习状态设计。

---
处理用时：47.39秒
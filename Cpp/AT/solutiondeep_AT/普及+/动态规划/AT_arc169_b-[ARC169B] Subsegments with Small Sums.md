# 题目信息

# [ARC169B] Subsegments with Small Sums

## 题目描述

给定一个正整数 $S$。对于正整数序列 $x$ ，我们定义函数 $f(x)$ 如下:

- 将 $x$ 分解为几个连续的子序列。对于每个连续子序列，其元素之和最多为 $S$。$f(x)$ 是在这样的要求下分解成的连续子序列的最小数目。

现在给定一个长度为 $N$ 的正整数序列 $A=(A_1,A_2,\cdots,A_N)$，请求出 $\sum_{1 \leq l \leq r \leq N} f((A_l,A_{l+1},\cdots,A_r))$。

## 说明/提示

$1 \leq N \leq 250000$，$1 \leq S \leq 10^{15}$，$1 \leq A_i \leq \min(S,10^9)$，所有输入都是整数。

样例一解释：

样例中 $x=(1,2,3)$。分解方案 $(1,2),(3)$ 满足条件，可以证明没有分解成少于两个连续子序列的方案满足条件，所以 $f((1,2,3))=2$。

下面显示的是可能的 $l,r$ 和对应的 $f$ 值:

-  $(l,r)=(1,1)$：$f((1))=1$
-  $(l,r)=(1,2)$：$f((1,2))=1$
-  $(l,r)=(1,3)$：$f((1,2,3))=2$
-  $(l,r)=(2,2)$：$f((2))=1$
-  $(l,r)=(2,3)$：$f((2,3))=2$
-  $(l,r)=(3,3)$：$f((3))=1$

因此，答案是$1+1+2+1+2+1=8$。

## 样例 #1

### 输入

```
3 3

1 2 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5 1

1 1 1 1 1```

### 输出

```
35```

## 样例 #3

### 输入

```
5 15

5 4 3 2 1```

### 输出

```
15```

## 样例 #4

### 输入

```
20 1625597454

786820955 250480341 710671229 946667801 19271059 404902145 251317818 22712439 520643153 344670307 274195604 561032101 140039457 543856068 521915711 857077284 499774361 419370025 744280520 249168130```

### 输出

```
588```

# AI分析结果

### 题目翻译
# [ARC169B] 小子段和

## 题目描述

给定一个正整数 $S$。对于正整数序列 $x$，我们定义函数 $f(x)$ 如下：

- 将 $x$ 分解为几个连续的子序列。对于每个连续子序列，其元素之和最多为 $S$。$f(x)$ 是在这样的要求下分解成的连续子序列的最小数目。

现在给定一个长度为 $N$ 的正整数序列 $A=(A_1,A_2,\cdots,A_N)$，请求出 $\sum_{1 \leq l \leq r \leq N} f((A_l,A_{l+1},\cdots,A_r))$。

## 说明/提示

$1 \leq N \leq 250000$，$1 \leq S \leq 10^{15}$，$1 \leq A_i \leq \min(S,10^9)$，所有输入都是整数。

样例一解释：

样例中 $x=(1,2,3)$。分解方案 $(1,2),(3)$ 满足条件，可以证明没有分解成少于两个连续子序列的方案满足条件，所以 $f((1,2,3))=2$。

下面显示的是可能的 $l,r$ 和对应的 $f$ 值：

-  $(l,r)=(1,1)$：$f((1))=1$
-  $(l,r)=(1,2)$：$f((1,2))=1$
-  $(l,r)=(1,3)$：$f((1,2,3))=2$
-  $(l,r)=(2,2)$：$f((2))=1$
-  $(l,r)=(2,3)$：$f((2,3))=2$
-  $(l,r)=(3,3)$：$f((3))=1$

因此，答案是$1+1+2+1+2+1=8$。

## 样例 #1

### 输入

```
3 3

1 2 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5 1

1 1 1 1 1```

### 输出

```
35```

## 样例 #3

### 输入

```
5 15

5 4 3 2 1```

### 输出

```
15```

## 样例 #4

### 输入

```
20 1625597454

786820955 250480341 710671229 946667801 19271059 404902145 251317818 22712439 520643153 344670307 274195604 561032101 140039457 543856068 521915711 857077284 499774361 419370025 744280520 249168130```

### 输出

```
588```

### 题解分析与结论

本题的核心在于如何高效计算所有子区间的 $f$ 值之和。大多数题解采用了动态规划（DP）的思路，通过预处理和二分查找来优化时间复杂度。以下是几个关键点：

1. **DP状态定义**：大多数题解定义 $F(l)$ 为以 $l$ 为左端点的所有子区间的 $f$ 值之和。
2. **二分查找优化**：通过二分查找找到满足 $\sum_{i=l}^r a_i \leq S$ 的最大 $r$，从而将问题分解为两部分：$[l, r]$ 和 $[r+1, n]$。
3. **递推公式**：$F(l) = r - l + 1 + F(r+1) + n - r$，通过倒序求解或记忆化搜索实现。
4. **时间复杂度**：由于使用了二分查找，时间复杂度为 $O(n \log n)$。

### 精选题解

#### 题解1：2huk (★★★★★)
**关键亮点**：
- 使用了记忆化搜索来优化递推过程，代码简洁且高效。
- 通过二分查找找到满足条件的 $r$，并利用递推公式计算 $F(l)$。

**核心代码**：
```cpp
int F(int l) {
    if (l > n) return 0;
    if (dp[l] != -1) return dp[l];
    int r = upper_bound(sum + l, sum + n + 1, sum[l - 1] + s) - sum - 1;
    return dp[l] = (n - l + 1) + F(r + 1);
}
```

#### 题解2：fcy20180201 (★★★★☆)
**关键亮点**：
- 使用了双指针和拓扑排序的思想，进一步优化了时间复杂度。
- 通过记录每个后缀的第一段位置，避免了重复计算。

**核心代码**：
```cpp
for (int l = 1, r = 0; l <= n; l++) {
    while (r < n && a[r + 1] + sum <= s) sum += a[++r];
    ed[r].push_back(l);
    sum -= a[l];
    if (r == n) q.push(l), ans[l] = (n - l + 1);
}
```

#### 题解3：CQ_Bab (★★★★☆)
**关键亮点**：
- 使用了前缀和和二分查找，思路清晰且易于理解。
- 通过递推公式 $dp_i = dp_{r+1} + n - i + 1$，实现了高效的求解。

**核心代码**：
```cpp
rep1(i, n - 1, 1) {
    int id = upper_bound(sum + 1, sum + 1 + n, sum[i] + s - a[i]) - sum - 1;
    f[i] = f[id + 1] + n - i + 1;
}
```

### 最优关键思路与技巧
1. **二分查找优化**：通过二分查找快速找到满足条件的 $r$，减少了时间复杂度。
2. **递推公式**：通过递推公式将问题分解为更小的子问题，避免了重复计算。
3. **记忆化搜索**：通过记忆化搜索优化了递归过程，提高了代码效率。

### 拓展思路
类似的问题可以通过以下方法解决：
1. **双指针优化**：在满足单调性的情况下，使用双指针可以减少时间复杂度。
2. **前缀和预处理**：通过预处理前缀和，可以快速计算任意区间的和。
3. **动态规划**：通过定义合适的状态和递推公式，可以高效解决复杂的区间问题。

### 推荐题目
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)

---
处理用时：55.96秒
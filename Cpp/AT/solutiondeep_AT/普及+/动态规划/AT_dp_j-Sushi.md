# 题目信息

# Sushi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_j

$ N $ 枚の皿があります。 皿には $ 1,\ 2,\ \ldots,\ N $ と番号が振られています。 最初、各 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について、皿 $ i $ には $ a_i $ ($ 1\ \leq\ a_i\ \leq\ 3) $ 個の寿司が置かれています。

すべての寿司が無くなるまで、太郎君は次の操作を繰り返し行います。

- $ 1,\ 2,\ \ldots,\ N $ の目が等確率で出るサイコロを振り、出目を $ i $ とする。 皿 $ i $ に寿司がある場合、皿 $ i $ の寿司を $ 1 $ 個食べる。 皿 $ i $ に寿司が無い場合、何も行わない。

すべての寿司が無くなるまでの操作回数の期待値を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ a_i\ \leq\ 3 $

### Sample Explanation 1

$ 1 $ 個目の寿司を食べるまでの操作回数の期待値は $ 1 $ です。 その後、$ 2 $ 個目の寿司を食べるまでの操作回数の期待値は $ 1.5 $ です。 その後、$ 3 $ 個目の寿司を食べるまでの操作回数の期待値は $ 3 $ です。 よって、全体の操作回数の期待値は $ 1\ +\ 1.5\ +\ 3\ =\ 5.5 $ です。

### Sample Explanation 2

例えば、`3.00`, `3.000000003`, `2.999999997` などを出力しても正解となります。

## 样例 #1

### 输入

```
3

1 1 1```

### 输出

```
5.5```

## 样例 #2

### 输入

```
1

3```

### 输出

```
3```

## 样例 #3

### 输入

```
2

1 2```

### 输出

```
4.5```

## 样例 #4

### 输入

```
10

1 3 2 3 3 2 3 2 1 3```

### 输出

```
54.48064457488221```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $N$ 个盘子，编号为 $1, 2, \ldots, N$。最初，每个盘子 $i$ 上有 $a_i$ 个寿司，其中 $1 \leq a_i \leq 3$。

在所有寿司被吃完之前，太郎君会重复以下操作：

- 掷一个等概率出现 $1, 2, \ldots, N$ 的骰子，得到的结果为 $i$。如果盘子 $i$ 上有寿司，则吃掉一个寿司；如果盘子 $i$ 上没有寿司，则什么都不做。

求所有寿司被吃完所需的操作次数的期望值。

#### 说明/提示

##### 约束

- 输入均为整数。
- $1 \leq N \leq 300$
- $1 \leq a_i \leq 3$

##### 样例解释 1

第一个寿司被吃掉的期望操作次数为 $1$。接着，第二个寿司被吃掉的期望操作次数为 $1.5$。最后，第三个寿司被吃掉的期望操作次数为 $3$。因此，总操作次数的期望值为 $1 + 1.5 + 3 = 5.5$。

##### 样例解释 2

例如，输出 `3.00`, `3.000000003`, `2.999999997` 等都被认为是正确的。

### 题解综合分析与结论

本题的核心是计算期望值，涉及到动态规划（DP）和状态转移。由于每个盘子的寿司数量最多为3，且盘子的顺序不影响结果，因此可以通过合并等价状态来优化DP。大多数题解都采用了三维DP，分别表示当前有1、2、3个寿司的盘子数量，并通过状态转移方程计算期望值。

### 所选高星题解

#### 题解1：作者：Haphyxlos (赞：63)

**星级：5星**

**关键亮点：**
1. **状态合并**：通过合并等价状态，将问题从四维DP优化为三维DP，大大减少了状态数量。
2. **状态转移方程**：详细推导了状态转移方程，并通过移项简化了计算。
3. **代码实现**：代码简洁明了，逻辑清晰，易于理解。

**核心代码：**
```cpp
double f[305][305][305];
int a[5],n; 
int main(int argc,char const *argv[]){
    scanf("%d",&n);
    for(int i=1,x;i<=n;++i){
        scanf("%d",&x);
        a[x]++;
    }    
    for(int k=0;k<=n;++k){
        for(int j=0;j<=n;++j){
            for(int i=0;i<=n;++i){
                if(i||j||k){
                    if(i)f[i][j][k]+=f[i-1][j][k]*i/(i+j+k);
                    if(j)f[i][j][k]+=f[i+1][j-1][k]*j/(i+j+k);
                    if(k)f[i][j][k]+=f[i][j+1][k-1]*k/(i+j+k);
                    f[i][j][k]+=(double)n/(i+j+k);
                }
            }
        }
    }
    printf("%.15lf\n",f[a[1]][a[2]][a[3]]);
    return 0;
}
```

#### 题解2：作者：FelFa_1414666 (赞：19)

**星级：4星**

**关键亮点：**
1. **记忆化搜索**：使用记忆化搜索实现DP，避免了循环转移的复杂性。
2. **状态转移方程**：详细解释了状态转移方程的推导过程，帮助理解期望DP的基本原理。

**核心代码：**
```cpp
double dfs(int i,int j,int k){
    if (i==0&&j==0&&k==0) return 0.0;
    if (mem[i][j][k]!=0.0) return mem[i][j][k];
    double res=(n*1.0)/((i+j+k)*1.0);
    if (i>0)res+=(dfs(i-1,j,k))*(i*1.0/((i+j+k)*1.0));
    if (j>0)res+=(dfs(i+1,j-1,k))*(j*1.0/((i+j+k)*1.0));
    if (k>0)res+=(dfs(i,j+1,k-1))*(k*1.0/((i+j+k)*1.0));
    return mem[i][j][k]=res;
}
```

#### 题解3：作者：cmk666 (赞：17)

**星级：4星**

**关键亮点：**
1. **循环转移**：通过合理的循环顺序（先枚举k，再枚举j，最后枚举i），确保状态转移的无后效性。
2. **状态转移方程**：通过移项简化了状态转移方程，减少了计算复杂度。

**核心代码：**
```cpp
For(k, 0, n) For(j, 0, n) For(i, 0, n){
    if ( !i && !j && !k ) continue;
    f[i][j][k] = n;
    if ( i ) f[i][j][k] += i * f[i - 1][j][k];
    if ( j ) f[i][j][k] += j * f[i + 1][j - 1][k];
    if ( k ) f[i][j][k] += k * f[i][j + 1][k - 1];
    f[i][j][k] /= i + j + k;
}
```

### 最优关键思路与技巧

1. **状态合并**：通过合并等价状态，将问题从四维DP优化为三维DP，减少了状态数量，提高了计算效率。
2. **状态转移方程**：通过移项简化状态转移方程，避免了复杂的计算。
3. **循环顺序**：合理的循环顺序确保了状态转移的无后效性，避免了重复计算。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到更多种类的盘子或更多的寿司数量，但需要注意状态数量的增加。
2. **其他优化**：可以考虑使用记忆化搜索或滚动数组进一步优化空间复杂度。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)

### 个人心得摘录

- **调试经历**：在调试过程中，发现状态转移方程的正确性非常重要，尤其是在移项和简化时，需要仔细检查每一步的计算。
- **踩坑教训**：在循环转移时，循环顺序的选择非常重要，错误的顺序会导致状态转移的错误。
- **顿悟感想**：通过合并等价状态，大大减少了状态数量，使得问题变得可解，这是DP优化中的一个重要技巧。

---
处理用时：66.21秒
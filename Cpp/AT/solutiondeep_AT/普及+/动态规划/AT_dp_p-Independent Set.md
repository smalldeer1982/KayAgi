# 题目信息

# Independent Set

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_p

$ N $ 頂点の木があります。 頂点には $ 1,\ 2,\ \ldots,\ N $ と番号が振られています。 各 $ i $ ($ 1\ \leq\ i\ \leq\ N\ -\ 1 $) について、$ i $ 番目の辺は頂点 $ x_i $ と $ y_i $ を結んでいます。

太郎君は、各頂点を白または黒で塗ることにしました。 ただし、隣り合う頂点どうしをともに黒で塗ってはいけません。

頂点の色の組合せは何通りでしょうか？ $ 10^9\ +\ 7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ x_i,\ y_i\ \leq\ N $
- 与えられるグラフは木である。

### Sample Explanation 1

頂点の色の組合せは次図の $ 5 $ 通りです。 !\[\](https://img.atcoder.jp/dp/indep\_0\_muffet.png)

### Sample Explanation 2

頂点の色の組合せは次図の $ 9 $ 通りです。 !\[\](https://img.atcoder.jp/dp/indep\_1\_muffet.png)

## 样例 #1

### 输入

```
3

1 2

2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
4

1 2

1 3

1 4```

### 输出

```
9```

## 样例 #3

### 输入

```
1```

### 输出

```
2```

## 样例 #4

### 输入

```
10

8 5

10 8

6 5

1 5

4 8

2 10

3 6

9 2

1 7```

### 输出

```
157```

# AI分析结果

### 题目内容重写

**独立集**

**题目描述**

给定一棵有 $N$ 个顶点的树。顶点编号为 $1, 2, \ldots, N$。对于每个 $i$（$1 \leq i \leq N - 1$），第 $i$ 条边连接顶点 $x_i$ 和 $y_i$。

太郎君决定将每个顶点涂成白色或黑色。但是，相邻的顶点不能同时被涂成黑色。

求顶点涂色的总方案数，结果对 $10^9 + 7$ 取模。

**说明/提示**

**约束**

- 输入均为整数。
- $1 \leq N \leq 10^5$
- $1 \leq x_i, y_i \leq N$
- 给定的图是一棵树。

**样例解释**

**样例 1**

输入：
```
3
1 2
2 3
```
输出：
```
5
```

**样例 2**

输入：
```
4
1 2
1 3
1 4
```
输出：
```
9
```

**样例 3**

输入：
```
1
```
输出：
```
2
```

**样例 4**

输入：
```
10
8 5
10 8
6 5
1 5
4 8
2 10
3 6
9 2
1 7
```
输出：
```
157
```

### 题解分析与结论

#### 题解对比

1. **EnofTaiPeople (5星)**
   - **关键亮点**：清晰的树形DP思路，简洁的代码实现，使用了邻接表存储树结构，状态转移方程明确。
   - **代码核心**：通过DFS遍历树，计算每个节点的染色方案数，最终结果为根节点的黑白方案数之和。
   - **个人心得**：强调了树形DP的基础知识，适合新手学习。

2. **喵仔牛奶 (4星)**
   - **关键亮点**：与“没有上司的舞会”问题类比，分类讨论清晰，代码结构良好。
   - **代码核心**：使用DFS遍历树，计算每个节点的黑白方案数，最终结果为根节点的黑白方案数之和。
   - **个人心得**：提醒了输入中父子节点的不确定性，需要加双向边。

3. **Hehe_0 (3星)**
   - **关键亮点**：树形DP的基本思路，代码实现较为基础。
   - **代码核心**：通过DFS遍历树，计算每个节点的黑白方案数，最终结果为根节点的黑白方案数之和。
   - **个人心得**：强调了树形DP的入门性质，适合初学者。

4. **Phartial (3星)**
   - **关键亮点**：记忆化搜索的应用，代码结构清晰。
   - **代码核心**：通过DFS遍历树，计算每个节点的黑白方案数，最终结果为根节点的黑白方案数之和。
   - **个人心得**：强调了记忆化搜索的优势，适合有一定基础的读者。

#### 最优关键思路

- **树形DP**：通过DFS遍历树，计算每个节点的黑白方案数，最终结果为根节点的黑白方案数之和。
- **状态转移方程**：
  - $dp[a][0] = \prod\limits_{b \in a}(dp[b][0] + dp[b][1])$
  - $dp[a][1] = \prod\limits_{b \in a}dp[b][0]$
- **邻接表**：用于存储树结构，便于DFS遍历。

#### 可拓展之处

- **类似问题**：如“没有上司的舞会”问题，也是通过树形DP解决。
- **算法套路**：树形DP是解决树结构问题的常用方法，适用于多种场景。

#### 推荐题目

1. **P1352 没有上司的舞会**（树形DP）
2. **P2015 二叉苹果树**（树形DP）
3. **P2014 选课**（树形DP）

### 所选高星题解

#### EnofTaiPeople (5星)

**关键亮点**：清晰的树形DP思路，简洁的代码实现，使用了邻接表存储树结构，状态转移方程明确。

**代码核心**：
```cpp
void DFS(int a,int pre){
    int siz=edge[a].size();
    dp[a][0]=dp[a][1]=1;
    register int i,y;
    for(i=0;i<siz;++i){
        y=edge[a][i];
        if(y==pre)continue;
        DFS(y,a);
        dp[a][0]=(dp[a][0]*(dp[y][0]+dp[y][1]))%M;
        dp[a][1]=(dp[a][1]*dp[y][0])%M;
    }
    return;
}
```

**个人心得**：强调了树形DP的基础知识，适合新手学习。

#### 喵仔牛奶 (4星)

**关键亮点**：与“没有上司的舞会”问题类比，分类讨论清晰，代码结构良好。

**代码核心**：
```cpp
void dfs(int u) {
    f[u][0] = f[u][1] = 1;
    for (int v : G[u]) 
        if (!vis[v]) {
            vis[v] = true, dfs(v);
            f[u][0] *= f[v][0] + f[v][1], f[u][0] %= mod;
            f[u][1] *= f[v][0], f[u][1] %= mod;
        }
}
```

**个人心得**：提醒了输入中父子节点的不确定性，需要加双向边。

---
处理用时：43.98秒
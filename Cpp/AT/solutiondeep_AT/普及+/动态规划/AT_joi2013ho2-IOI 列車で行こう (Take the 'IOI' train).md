# 题目信息

# IOI 列車で行こう (Take the 'IOI' train)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2013ho/tasks/joi2013ho2

IOI 国ではこのたび新たに鉄道を敷設した．IOI 国の鉄道を走る列車はいくつかの車両が連結されたものであり，車両には `I`，`O` の $ 2 $ 種類がある．車両はそれぞれ異なる種類の車両としか連結できない．また，列車に運転席を設ける関係上，列車の両端の車両は種類 `I` でなければならない．列車は車両の種類を表す文字を順につなげた文字列で表され，列車の長さはその文字列の長さであるとする．たとえば， `IOIOI` の順に車両を連結すると長さ $ 5 $ の列車を編成でき，また車両 `I` は単独で長さ $ 1 $ の列車である．車両を `OIOI` や `IOOI` といった順に並べても列車を編成することはできない．

いくつかの車両が $ 2 $ つの車庫に格納されている．それぞれの車庫の中には車両が一列に並んでいる．列車を編成するときは車庫から車両を出してきて車庫前で連結していく．車庫から出せる車両は最も車庫の入り口に近い車両のみであるが，どちらの車庫から車両を出すかの順番については自由である．

列車を編成する前に，車両を好きなだけ車庫から出して別の待機用レールに移すことができる．一度待機用レールに移した車両は今後列車を編成するために使うことはできない．また，一度列車の編成を始めるとその編成が終わるまでの間は車両を車庫から待機用レールに移すことはできない．

列車を編成するとき，車庫内の全ての車両を使い切る必要はない．すなわち，列車の編成を終えた後，車庫内に使われなかった車両が残っていても構わない．

IOI 国では鉄道に乗る人がとてもたくさんいると考えられているので，できるだけ長い列車を編成したい．

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_joi2013ho2/e7f0a1c5c92198e9f99bd34c7f7c4549df9732c2.png)列車を編成している途中であり，このとき車庫にある車両を待機用レールに移すことはできない．この図は入出力例 $ 1 $ に対応している．

## 说明/提示

### 課題

車庫に格納された車両の情報が与えられたとき，編成できる列車の長さの最大値を求めるプログラムを作成せよ．それぞれの車庫に格納された車両の列は $ 2 $ 種類の文字 `I`，`O` のみからなる文字列で表され，$ 2 $ つの車庫の情報はそれぞれ長さ $ M $ の文字列 $ S $ および長さ $ N $ の文字列 $ T $ として与えられる．各文字が $ 1 $ つの車両を表し，その文字は車両の種類と同じである．文字列の $ 1 $ 文字目は最も車庫の入り口に近い車両を表し，末尾の文字が車庫の最も奥にある車両を表す．

### 制限

$ 1\ \leqq\ M\ \leqq\ 2\,000 $ 文字列 $ S $ の長さ$ 1\ \leqq\ N\ \leqq\ 2\,000 $ 文字列 $ T $ の長さ- - - - - -

### 採点基準

採点用データのうち，配点の $ 20 $ %分については，$ M\ \leqq\ 10 $，$ N\ \leqq\ 10 $ を満たす．

採点用データのうち，配点の $ 50 $ %分については，$ M\ \leqq\ 50 $，$ N\ \leqq\ 50 $ を満たす．

- - - - - -

### Sample Explanation 1

$ S $ によって表される車庫を車庫 S とし，$ T $ によって表される車庫を車庫 T としよう．このとき，たとえば車庫 S から最初の $ 1 $ 車両，車庫 T から最初の $ 2 $ 車両を出して待機させた後，車庫 S，車庫 S，車庫 T，車庫 S，車庫 S，車庫 T，車庫 T の順番に車両を出せば，長さ $ 7 $ の列車 `IOIOIOI` を編成できる． 他にも，車庫 S から最初の $ 1 $ 車両，車庫 T から最初の $ 2 $ 車両を出して待機させた後，車庫 T，車庫 T，車庫 S，車庫 S，車庫 T，車庫 S，車庫 S の順番に車両を出すことでも長さ $ 7 $ の列車を編成できる．これより長い列車を編成することはできないので $ 7 $ を出力する． - - - - - -

### Sample Explanation 2

$ 1 $ つの車両のみからなる列車 `I` も列車としての条件を満たすことに注意せよ．

## 样例 #1

### 输入

```
5 5
OIOOI
OOIOI```

### 输出

```
7```

## 样例 #2

### 输入

```
5 9
IIIII
IIIIIIIII```

### 输出

```
1```

# AI分析结果

### 题目内容重写
#### 题目描述
IOI 国最近新建了一条铁路。IOI 国的铁路列车由若干节车厢连接而成，车厢有两种类型：`I` 和 `O`。车厢只能与不同类型的车厢连接。此外，由于列车需要设置驾驶室，列车的两端必须是 `I` 型车厢。列车可以用车厢类型的字符串表示，列车的长度即为字符串的长度。例如，`IOIOI` 表示长度为 5 的列车，而 `I` 单独表示长度为 1 的列车。像 `OIOI` 或 `IOOI` 这样的车厢排列无法组成合法的列车。

车厢被存放在两个车库中，每个车库中的车厢按顺序排列。编组列车时，只能从车库的入口处取出车厢，但可以选择从哪个车库取出车厢。在编组列车之前，可以将任意数量的车厢从车库移到待机轨道上，但一旦开始编组列车，就不能再将车厢移到待机轨道上。编组列车时，不一定要用完所有车厢，车库中可能剩余未使用的车厢。

IOI 国的铁路乘客非常多，因此希望编组尽可能长的列车。

### 题解分析与结论
#### 综合分析
本题的核心是通过动态规划（DP）来解决列车编组问题。所有题解都采用了 DP 的思路，但状态设计和转移方程有所不同。主要的难点在于如何设计状态转移方程，确保列车的合法性和最大化列车的长度。

#### 最优关键思路
1. **状态设计**：大多数题解使用三维 DP 状态 `dp[i][j][k]`，表示从第一个车库取出 `i` 个车厢，从第二个车库取出 `j` 个车厢，且当前列车的末尾为 `k`（`0` 表示 `O`，`1` 表示 `I`）时的最大列车长度。
2. **转移方程**：根据当前车厢的类型和前一个车厢的类型，进行状态转移。特别注意，列车的末尾必须是 `I`，因此在转移时需要确保合法性。
3. **边界条件**：处理车库为空的情况，以及列车必须以 `I` 开头和结尾的约束。

#### 推荐题解
1. **作者：Allan_Xu (4星)**
   - **关键亮点**：状态设计清晰，转移方程简洁，代码可读性高。
   - **代码核心**：
     ```cpp
     for(int i=0;i<=n;i++){
         for(int j=0;j<=m;j++){
             if(i&&a[i]=='O'&&f[i-1][j][1]>0)f[i][j][0]=max(f[i][j][0],f[i-1][j][1]+1);
             if(i&&a[i]=='I')f[i][j][1]=max(f[i][j][1],f[i-1][j][0]+1);
             if(j&&b[j]=='O'&&f[i][j-1][1]>0)f[i][j][0]=max(f[i][j][0],f[i][j-1][1]+1);
             if(j&&b[j]=='I')f[i][j][1]=max(f[i][j][1],f[i][j-1][0]+1);
             maxn=max(maxn,f[i][j][1]);
         }
     }
     ```
   - **个人心得**：作者强调了边界条件的处理，特别是当车库为空时的状态转移。

2. **作者：charleshe (4星)**
   - **关键亮点**：通过后缀 DP 的思路，简化了状态转移，代码结构清晰。
   - **代码核心**：
     ```cpp
     for(int i=n;i>=0;i--){
         for(int j=m;j>=0;j--){
             if((a[i]=='O'&&b[j]=='I')||(a[i]=='I'&&b[j]=='O')) g[i][j]=max(g[i][j],g[i+1][j+1]+2);
             if(a[i]=='O'&&a[i+1]=='I') g[i][j]=max(g[i][j],g[i+2][j]+2);
             if(b[j]=='O'&&b[j+1]=='I') g[i][j]=max(g[i][j],g[i][j+2]+2);
         }
     }
     ```
   - **个人心得**：作者提到从后往前 DP 的思路，使得状态转移更加直观。

3. **作者：Cells (4星)**
   - **关键亮点**：状态设计简洁，转移方程清晰，代码可读性高。
   - **代码核心**：
     ```cpp
     rep(i, 0, n){
         rep(j, 0, m){
             if(i && s1[i] == 'I') dp[i][j][1] = dp[i - 1][j][0] + 1;
             else if(i) dp[i][j][0] = dp[i - 1][j][1] + (dp[i - 1][j][1] != 0);
             if(j && s2[j] == 'I') dp[i][j][1] = max(dp[i][j][1], dp[i][j - 1][0] + 1);
             else if(j) dp[i][j][0] = max(dp[i][j][0], dp[i][j - 1][1] + (dp[i][j - 1][1] != 0));
             ans = max(ans, dp[i][j][1]);
         }
     }
     ```
   - **个人心得**：作者强调了列车必须以 `I` 结尾的约束，并在转移方程中进行了处理。

### 推荐题目
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

这些题目都涉及到动态规划的应用，适合进一步巩固 DP 技巧。

---
处理用时：43.98秒
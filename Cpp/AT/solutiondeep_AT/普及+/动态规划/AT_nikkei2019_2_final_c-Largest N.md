# 题目信息

# Largest N

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-2-final/tasks/nikkei2019_2_final_c

$ H $ 行 $ W $ 列 のマス目があり、それぞれのマスは黒または白で塗られています。上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,\ j) $ と呼びます。

マス $ (a_i,\ b_i)\ (1\ \leq\ i\ \leq\ K) $ は白で塗られており、それ以外の $ H\ \times\ W\ -\ K $ マスは黒で塗られています。

$ 1 $ 以上の整数 $ k $ に対してマス目がサイズ $ k $ の `N` を含むとは、次の条件をみたす整数 $ i,\ j $ が存在することを言います。

- マス $ (i\ +\ t,\ j)\ (0\ \leq\ t\ <\ k) $ がすべて黒
- マス $ (i\ +\ t,\ j\ +\ t)\ (0\ \leq\ t\ <\ k) $ がすべて黒
- マス $ (i\ +\ t,\ j\ +\ k\ -\ 1)\ (0\ \leq\ t\ <\ k) $ がすべて黒

ただし、この条件に関わる全てのマスが $ H $ 行 $ W $ 列のマス目に含まれなければなりません。

このマス目に含まれる `N` のサイズの最大値を求めてください。ただし、どのサイズの `N` も含まない場合は、$ 0 $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 3000 $
- $ 0\ \leq\ K\ \leq\ \mathrm{min}(H\ \times\ W,\ 2\ \times\ 10^5) $
- $ 1\ \leq\ a_i\ \leq\ H $
- $ 1\ \leq\ b_i\ \leq\ W $
- $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j)\ (i\ \neq\ j) $
- 入力は全て整数である

### Sample Explanation 1

マス目は以下の状態になっています。(`#` が黒、`.` が白で塗られていることを表しています) ``` ##.# #### ##.# ``` このとき、$ i\ =\ 1,\ j\ =\ 2 $ とすれば $ k\ =\ 3 $ に対して条件を満たすのでこのマス目はサイズ $ 3 $ の `N` を含み、これが最大です。

### Sample Explanation 2

マス目は以下の状態になっています。 ``` .. .. ``` どのサイズの `N` も含まれないので、$ 0 $ を出力してください。

### Sample Explanation 3

マス目は以下の状態になっています。 ``` .# #. ``` $ i\ =\ 2,\ j\ =\ 1 $ または $ i\ =\ 1,\ j\ =\ 2 $ とすれば $ k\ =\ 1 $ に対して条件を満たします。

### Sample Explanation 4

マス目は以下の状態になっています。 ``` ##.# ##.# #.## #..# ```

## 样例 #1

### 输入

```
3 4 2

1 3

3 3```

### 输出

```
3```

## 样例 #2

### 输入

```
2 2 4

2 1

1 1

1 2

2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
2 2 2

1 1

2 2```

### 输出

```
1```

## 样例 #4

### 输入

```
4 4 5

2 3

1 3

4 2

4 3

3 2```

### 输出

```
4```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个 $H$ 行 $W$ 列的矩阵，矩阵中的每个格子要么是黑色，要么是白色。矩阵中标记了 $K$ 个格子为白色，其余格子为黑色。定义“大小为 $k$ 的 `N`”为满足以下条件的格子集合：

1. 从某个格子 $(i, j)$ 开始，向下延伸 $k$ 个格子，这些格子必须全部为黑色。
2. 从 $(i, j)$ 开始，向右下对角线延伸 $k$ 个格子，这些格子必须全部为黑色。
3. 从 $(i, j)$ 开始，向右延伸 $k$ 个格子，这些格子必须全部为黑色。

要求找到矩阵中包含的最大 `N` 的大小，如果不存在则输出 $0$。

**说明/提示**

- $1 \leq H, W \leq 3000$
- $0 \leq K \leq \min(H \times W, 2 \times 10^5)$
- 输入的所有坐标都是唯一的。

### 题解分析与结论

#### 综合分析与结论

本题的核心在于如何在矩阵中高效地找到满足条件的最大 `N`。由于矩阵规模较大（$H, W \leq 3000$），直接暴力枚举所有可能的 `N` 会导致时间复杂度过高，因此需要优化。

**关键思路：**
1. **预处理**：通过预处理，计算每个格子向上和向左上对角线延伸的最大连续黑色格子数，分别存储在 `up` 和 `sli` 数组中。
2. **枚举右下角**：枚举 `N` 的右下角 $(i, j)$，然后根据预处理的结果，计算可能的 `N` 的大小 $k$，并检查是否满足条件。
3. **剪枝优化**：在枚举 $k$ 时，从当前已知的最大值开始枚举，避免无效计算。

**难点对比：**
- **nueryim** 的题解通过预处理和剪枝优化，将时间复杂度降低到 $O(n^3)$，但在实际运行中由于剪枝效果较好，能够通过题目。
- **phil071128** 的题解使用了线段树进行优化，时间复杂度为 $O(nm \log m)$，虽然理论复杂度较低，但实现较为复杂。
- **a_blue_cell** 的题解通过预处理和枚举，时间复杂度为 $O(n^3)$，但代码实现较为简洁，易于理解。

**最优思路：**
nueryim 的题解通过预处理和剪枝优化，既保证了代码的可读性，又通过剪枝有效降低了时间复杂度，是较为优秀的解法。

### 所选题解

#### 题解1：nueryim (4星)

**关键亮点：**
- 通过预处理 `up` 和 `sli` 数组，快速计算每个格子向上和向左上对角线延伸的最大连续黑色格子数。
- 在枚举 `N` 的大小时，从当前已知的最大值开始枚举，避免无效计算，显著提高了效率。

**核心代码：**
```cpp
for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= m; j ++)
    {
        int tmp = min(up[i][j], sli[i][j]);
        if (mp[i][j] || tmp <= ans)
            continue;
        for (int k = ans; k <= tmp && j - k + 1 >= 1 && i - k + 1 >= 1; k ++)
            if (up[i][j - k + 1] >= k)
                ans = max(ans, k);
    }
```

**个人心得：**
通过预处理和剪枝优化，成功将时间复杂度降低到可接受的范围，实际运行效果良好。

#### 题解2：a_blue_cell (4星)

**关键亮点：**
- 通过预处理 `pre_a` 和 `pre_b` 数组，快速计算每个格子向下和向右下对角线延伸的最大连续黑色格子数。
- 在枚举 `N` 的大小时，从当前已知的最大值开始枚举，避免无效计算。

**核心代码：**
```cpp
for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= m; j ++)
        for (int k = ans; i + k - 1 <= n && j + k - 1 <= m && k <= pre_a[i][j] && k <= pre_b[i][j]; k ++)
            if (pre_a[i][j + k - 1] >= k)
                ans = max(ans, k);
```

**个人心得：**
通过预处理和剪枝优化，代码实现简洁，易于理解，且运行效率较高。

### 最优关键思路或技巧

1. **预处理**：通过预处理计算每个格子向上和向左上对角线延伸的最大连续黑色格子数，避免在枚举时重复计算。
2. **剪枝优化**：在枚举 `N` 的大小时，从当前已知的最大值开始枚举，避免无效计算，显著提高效率。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他形状的矩阵匹配，如 `Z` 形、`L` 形等，预处理和剪枝优化的思路同样适用。
- **数据结构优化**：可以进一步使用线段树等数据结构进行优化，降低时间复杂度。

### 推荐题目

1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

这些题目都涉及到矩阵或序列的处理，预处理和剪枝优化的思路在这些题目中同样适用。

---
处理用时：50.64秒
# 题目信息

# イウィ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tdpc/tasks/tdpc_iwi

入力は以下の形式で標準入力から与えられる。

> $ s $

 答えを一行に出力せよ。 ```

iwiwii
```

```

2
```

```

iwiwwwiiiwiwiwiiwii
```

```

5
```

## 说明/提示

### Constraints

 $ s $ は i と w からなる文字列である。すぬけ君は、この中から連続する三文字が "iwi" となっている部分を取り除く操作を繰り返すことができる。(iwi を取り除くと、その左側と右側にあった文字列が連結され、長さが三文字短い新しい文字列ができる。) 操作を行うことのできる回数の最大値を求めよ。

- - - - - -

- $ 1\ <\ =\ |s|\ <\ =\ 300 $
- Each character in $ s $ will be either 'i' or 'w'.

# AI分析结果

### 题目内容重写

#### 题目描述

输入一个由字符 `i` 和 `w` 组成的字符串 `s`。你可以进行多次操作，每次操作可以选择字符串中连续的三字符子串 `iwi` 并将其删除。删除后，子串的左侧和右侧会连接在一起，形成一个新的字符串。求可以进行的最多操作次数。

#### 输入格式

输入为一个字符串 `s`。

#### 输出格式

输出一个整数，表示可以进行的最多操作次数。

#### 样例

输入1：
```
iwiwii
```
输出1：
```
2
```

输入2：
```
iwiwwwiiiwiwiwiiwii
```
输出2：
```
5
```

#### 说明/提示

- 字符串 `s` 的长度满足 `1 ≤ |s| ≤ 300`。
- 字符串 `s` 仅由字符 `i` 和 `w` 组成。

### 题解分析与结论

本题的核心是通过删除连续的 `iwi` 子串，求最大操作次数。题解主要采用了区间动态规划（DP）的思路，部分题解还提供了贪心策略的解法。

#### 最优思路总结

1. **区间动态规划**：定义 `dp[i][j]` 表示字符串 `s` 的子串 `s[i..j]` 可以进行的最大操作次数。通过枚举区间内的分割点 `k`，将问题分解为两个子问题 `dp[i][k]` 和 `dp[k+1][j]`，并取最大值。此外，如果 `s[i]` 和 `s[j]` 都是 `i`，且 `s[k]` 是 `w`，并且中间的两个子串可以被完全删除，那么整个区间 `s[i..j]` 也可以被完全删除，此时 `dp[i][j]` 的值为区间长度。

2. **贪心策略**：部分题解采用了贪心策略，先删除所有可能的 `iwii` 和 `iiwi` 子串中的 `iwi`，然后再删除剩余的 `iwi`。这种策略虽然简单，但在某些情况下可能无法得到最优解。

#### 推荐题解

1. **题解作者：Nightsky_Stars (5星)**
   - **关键亮点**：采用了标准的区间动态规划思路，代码清晰，转移方程明确，且考虑了特殊情况（即整个区间可以被完全删除的情况）。
   - **核心代码**：
     ```cpp
     for(int len=2;len<=n;len++){
         for(int j=1;j<=n-len+1;j++){
             int i=j+len-1;
             for(int k=j;k<i;k++){
                 dp[j][i]=max(dp[j][i],dp[j][k]+dp[k+1][i]);
                 if(s[j]=='i'&&s[i]=='i'&&s[k]=='w'&&dp[j+1][k-1]==k-j-1&&dp[k+1][i-1]==i-k-1){
                     dp[j][i]=i-j+1;
                 }
             }
         }
     }
     ```

2. **题解作者：Obviathy (4星)**
   - **关键亮点**：同样采用了区间动态规划，代码简洁，逻辑清晰，且对特殊情况进行了详细解释。
   - **核心代码**：
     ```cpp
     for(int len=2;len<=n;len++){
         for(int i=1;i+len-1<=n;i++){
             int j=i+len-1;
             for(int k=i;k<j;k++){
                 f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]);
                 if(s[i]=='i'&&s[j]=='i'&&s[k]=='w'&&f[i+1][k-1]==k-i-1&&f[k+1][j-1]==j-1-k)f[i][j]=j-i+1;
             }
         }
     }
     ```

3. **题解作者：Proxima_Centauri (4星)**
   - **关键亮点**：代码结构清晰，对区间动态规划的转移方程进行了详细解释，适合初学者理解。
   - **核心代码**：
     ```cpp
     for(int len=2;len<=n;len++){
         for(int i=1;i<=n-len+1;i++){
             int j=i+len-1;
             for(int k=i;k<j;k++){
                 f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]);
                 if(s[i]=='i'&&s[j]=='i'&&s[k]=='w'&&f[i+1][k-1]==k-i-1&&f[k+1][j-1]==j-1-k)f[i][j]=j-i+1;
             }
         }
     }
     ```

### 扩展思路与推荐题目

1. **扩展思路**：本题的区间动态规划思路可以推广到其他类似的字符串删除问题，例如删除特定的子串或模式。此外，贪心策略在某些特定情况下也可以作为辅助手段。

2. **推荐题目**：
   - [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)：区间动态规划的经典题目。
   - P1063 能量项链：区间动态规划的应用。
   - P1880 [NOI1995]石子合并：区间动态规划的典型问题。

### 个人心得摘录

- **调试经历**：部分题解提到在实现区间动态规划时，需要特别注意边界条件和特殊情况，例如整个区间可以被完全删除的情况。
- **踩坑教训**：贪心策略虽然简单，但在某些情况下可能无法得到最优解，因此需要谨慎使用。

### 结论

区间动态规划是解决本题的最优方法，通过枚举区间内的分割点并考虑特殊情况，可以得到最大操作次数。贪心策略虽然简单，但在某些情况下可能无法得到最优解。

---
处理用时：45.15秒
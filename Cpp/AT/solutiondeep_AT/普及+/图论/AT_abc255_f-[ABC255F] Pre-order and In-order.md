# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果

### 题目翻译
#### [ABC255F] 前序遍历和中序遍历

##### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

考虑一棵有 $N$ 个顶点，编号为 $1, 2, \ldots, N$ 的**二叉树**。这里，二叉树是指每个顶点最多有 $2$ 个子节点的有根树。更具体地说，二叉树的每个顶点最多有 $1$ 个**左子节点**和最多 $1$ 个**右子节点**。

请判断是否存在以顶点 $1$ 为根，且满足以下条件的二叉树。若存在，则给出一个例子。
- 所有顶点按深度优先搜索的[**前序遍历**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)排列的序列为 $(P_1, P_2, \ldots, P_N)$。
- 所有顶点按深度优先搜索的[**中序遍历**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)排列的序列为 $(I_1, I_2, \ldots, I_N)$。

##### 说明/提示
- **限制条件**
  - $2 \leq N \leq 2 \times 10^5$
  - $N$ 是整数
  - $(P_1, P_2, \ldots, P_N)$ 是 $(1, 2, \ldots, N)$ 的排列
  - $(I_1, I_2, \ldots, I_N)$ 是 $(1, 2, \ldots, N)$ 的排列
- **样例解释 1**
  下图所示的以顶点 $1$ 为根的二叉树满足题目中的条件。
  !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)
- **样例解释 2**
  不存在满足题目条件的以顶点 $1$ 为根的二叉树。因此输出 $-1$。

##### 样例 #1
- **输入**
```
6
1 3 5 6 4 2
3 5 1 4 6 2
```
- **输出**
```
3 6
0 0
0 5
0 0
0 0
4 2
```

##### 样例 #2
- **输入**
```
2
2 1
1 2
```
- **输出**
```
-1
```

### 综合分析与结论
这些题解的核心思路都是利用前序遍历和中序遍历的性质来构造二叉树。前序遍历的第一个元素是根节点，通过在中序遍历中找到根节点的位置，可以划分出左右子树，进而递归构建左右子树。同时，各题解都考虑了无解的情况，如前序遍历的第一个元素不是 $1$ 或者在递归过程中根节点在中序遍历中的位置超出范围。

算法要点主要包括：
1. 利用数组记录每个元素在中序遍历中的位置，避免在递归中重复查找，降低时间复杂度。
2. 递归构建二叉树，通过左右子树的节点数量确定前序遍历中左右子树的范围。

解决的难点在于：
1. 准确处理递归的边界条件，避免越界。
2. 正确判断无解的情况，确保程序的正确性。

### 所选题解
- **program_xwl（4星）**
  - **关键亮点**：思路清晰，通过图示直观展示了利用前序和中序遍历构建二叉树的过程。代码注释详细，易于理解。
  - **重点代码**：
```cpp
struct node {int l,r;} tree[200005];//用来存储答案
int n,a[200005],b[200005],mp[200005];//a数组用于存储树的前序遍历，b数组用于存储树的中序遍历，mp用于记录a的元素在b数组中的对应点。

void dfs(int l1,int r1,int l2,int r2)//从左到右的依次为当前a数组左端点，当前a数组右端点，当前b数组左端点，当前b数组右端点。
{
    if(l1 >= r1) return;//只有一个元素说明到叶子节点了
    int root = mp[a[l1]],sizl = root-l2,sizr = r2-root;//root代表在b数组中当前子树的根的位置，sizl是左子树大小，sizr是右子树大小
    if(root < l2 || root > r2)//说明前序和中序遍历不对应，无解
    {
        cout << -1;
        exit(0);
    }
    tree[a[l1]] = {a[l1+1],a[l1+sizl+1]};//更新答案
    if(sizl == 0) tree[a[l1]].l = 0;//如果左子树为空就设为0
    if(sizr == 0) tree[a[l1]].r = 0;//如果右子树为空也设为0
    dfs(l1+1,l1+sizl,l2,root-1);//递归左子树
    dfs(l1+sizl+1,r1,root+1,r1);//递归右子树
    return;
}
```
  - **核心实现思想**：通过 `dfs` 函数递归构建二叉树。首先根据前序遍历的第一个元素确定根节点，然后在中序遍历中找到根节点的位置，划分左右子树。根据左右子树的节点数量确定前序遍历中左右子树的范围，继续递归构建左右子树。

- **Tsawke（4星）**
  - **关键亮点**：详细解释了先序和中序遍历的意义，以及如何利用它们来构建二叉树。代码结构清晰，有一定的注释。
  - **重点代码**：
```cpp
int dfs(int lp = 1, int rp = N, int li = 1, int ri = N){
    if(lp > rp)return 0;
    int rt = Pre[lp];
    if(posI[rt] < li || posI[rt] > ri)puts("-1"), exit(0);
    if(lp == rp)return rt;
    int lsiz = (posI[rt] - 1) - li + 1;
    son[rt].first = dfs(lp + 1, lp + lsiz, li, posI[rt] - 1);
    son[rt].second = dfs(lp + lsiz + 1, rp, posI[rt] + 1, ri);
    return rt;
}
```
  - **核心实现思想**：`dfs` 函数通过维护前序和中序遍历的区间来递归构建二叉树。根据前序遍历的第一个元素确定根节点，在中序遍历中找到根节点的位置，计算左右子树的大小，然后递归构建左右子树。

### 最优关键思路或技巧
1. **利用数组记录位置**：使用数组记录每个元素在中序遍历中的位置，避免在递归中重复查找，将查找根节点位置的时间复杂度从 $O(n)$ 降低到 $O(1)$。
2. **递归构建**：通过递归的方式，不断将问题分解为更小的子问题，利用前序和中序遍历的性质构建二叉树。

### 拓展思路
同类型题目通常围绕二叉树的遍历展开，如已知中序和后序遍历构建二叉树，或者根据构建的二叉树求其他遍历序列等。解题的关键仍然是利用不同遍历方式的性质，通过递归或迭代的方式解决问题。

### 推荐题目
1. [P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030)
2. [P1827 [USACO3.4] 美国血统 American Heritage](https://www.luogu.com.cn/problem/P1827)
3. [P4015 运输问题](https://www.luogu.com.cn/problem/P4015)

### 个人心得摘录与总结
- **feizhu_QWQ**：提到在中序遍历中找根时不能循环，否则会超时，所以用数组记录每个节点在中序遍历中的位置。总结：在处理需要频繁查找元素位置的问题时，使用数组记录位置可以有效降低时间复杂度。
- **Ascnbeta**：指出直接在 `dfs` 中遍历区间寻找根节点位置会 TLE，所以在读入中序遍历时就储存每个编号的位置。总结：提前预处理数据，避免在递归中进行重复的查找操作，可以优化程序性能。

---
处理用时：55.25秒
# 题目信息

# [ABC257F] Teleporter Setting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc257/tasks/abc257_f

$ N $ 個の町と $ M $ 個のテレポーターがあり、 町は町 $ 1 $, 町 $ 2 $, $ \ldots $, 町$ N $ と番号づけられています。  
 それぞれのテレポーターは $ 2 $ つの町を双方向に結んでおり、テレポーターを使用する事によってその $ 2 $ つの町の間を $ 1 $ 分で移動することができます。

$ i $ 番目のテレポーターは町 $ U_i $ と町 $ V_i $ を双方向に結んでいますが、 いくつかのテレポーターについては結ぶ町の片方が決まっておらず、 $ U_i=0 $ のときそのテレポーターが結ぶ町の片方は町 $ V_i $ であるが、 もう片方が未定であることを意味します。

$ i=1,2,\ldots,N $ それぞれについて、次の問題を解いてください。

> 結ぶ町の片方が未定となっているテレポーターの結ぶ先をすべて町 $ i $ とする。 この時に町 $ 1 $ から町 $ N $ まで移動するのに最小で何分かかるか求めよ。 町 $ 1 $ から町 $ N $ までテレポーターのみを使って移動するのが不可能な場合は $ -1 $ を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 3\times\ 10^5 $
- $ 1\leq\ M\leq\ 3\times\ 10^5 $
- $ 0\leq\ U_i\ <\ V_i\leq\ N $
- $ i\ \neq\ j $ ならば $ (U_i,V_i)\neq\ (U_j,V_j) $
- 入力は全て整数

### Sample Explanation 1

結ぶ先が未定となっているテレポーターの結び先を町 $ 1 $ としたとき、 $ 1 $ 番目と $ 2 $ 番目のテレポーターはともに町 $ 1 $ と町 $ 2 $ を結びます。 このとき、町 $ 1 $ から町 $ 3 $ への移動はできません。 結ぶ先が未定となっているテレポーターの結び先を町 $ 2 $ としたとき、 $ 1 $ 番目のテレポーターは町 $ 2 $ 同士を、 $ 2 $ 番目のテレポーターは町 $ 1 $ と町 $ 2 $ を結びます。 このときもやはり、町 $ 1 $ から町 $ 3 $ への移動はできません。 結ぶ先が未定となっているテレポーターの結び先を町 $ 3 $ としたとき、 $ 1 $ 番目のテレポーターは町 $ 3 $ と町 $ 2 $ を、 $ 2 $ 番目のテレポーターは町 $ 1 $ と町 $ 2 $ を結びます。 この時、次のようにして町 $ 1 $ から町 $ 3 $ へ $ 2 $ 分で移動できます。 - $ 2 $ 番目のテレポーターを使用し、町 $ 1 $ から町 $ 2 $ まで移動する。 - $ 1 $ 番目のテレポーターを使用し、町 $ 2 $ から町 $ 3 $ まで移動する。 よって、$ -1,-1,2 $ をこの順に出力します。 結ぶ先が未定となっているテレポーターの結び先によっては、 同じ町同士を結ぶテレポーターが存在する可能性や、 ある $ 2 $ つの町を結ぶテレポーターが複数存在する可能性がある事に注意してください。

## 样例 #1

### 输入

```
3 2

0 2

1 2```

### 输出

```
-1 -1 2```

## 样例 #2

### 输入

```
5 5

1 2

1 3

3 4

4 5

0 2```

### 输出

```
3 3 3 3 2```

# AI分析结果

### 题目翻译
有 $N$ 个城镇和 $M$ 个传送门，城镇编号为城镇 $1$、城镇 $2$、$\cdots$、城镇 $N$。
每个传送门双向连接两个城镇，使用传送门可以在 $1$ 分钟内往返于这两个城镇之间。
第 $i$ 个传送门双向连接城镇 $U_i$ 和城镇 $V_i$，但部分传送门连接的其中一个城镇尚未确定。当 $U_i = 0$ 时，表示该传送门连接的其中一个城镇是城镇 $V_i$，而另一个城镇待定。
对于 $i = 1, 2, \cdots, N$，分别求解以下问题：
> 将所有连接城镇待定的传送门的另一端都设为城镇 $i$。此时，从城镇 $1$ 到城镇 $N$ 最少需要多少分钟？如果仅使用传送门无法从城镇 $1$ 到达城镇 $N$，则输出 $-1$。

### 综合分析与结论
#### 思路对比
- **超级源点思路**：多位作者（mz2022、_ldyex_、Tsawke、xukehg、linbaicheng2022）提出建立一个超级源点（通常设为 $0$ 号点），将所有不确定的边连接到该点。通过从 $1$ 号点和 $N$ 号点分别进行单源最短路计算，得到 $1$ 到各点和 $N$ 到各点的最短距离。对于每个 $i$，答案为 $1$ 到 $N$ 的最短路、$1$ 到超级源点再到 $i$ 再到 $N$ 的最短路、$1$ 到 $i$ 再到超级源点再到 $N$ 的最短路这三种情况的最小值。
- **菊花图思路**：qiliu 提出将新增的边和所连的点看作菊花图，考虑最短路的四种形成情况：不走新增的边、从新增边到 $i$ 再走原边到 $N$、从原边到 $i$ 再经新增边到 $N$、从新增边到 $i$ 再经新增边到 $N$。通过预处理出 $1$ 到各点和 $N$ 到各点的距离，以及菊花图叶子节点到 $1$ 和 $N$ 的最小距离，$O(1)$ 统计答案。
- **枚举情况思路**：FreedomKing、CQ_Bob 等作者考虑不经过点 $i$ 以及经过 $i$ 的不同情况，通过预处理 $1$ 到各点和 $N$ 到各点的最短路，对每种情况取最小值得到答案。

#### 算法要点
- **单源最短路算法**：大部分题解使用了 Dijkstra 算法（如 mz2022、xukehg、jjy2023、linbaicheng2022）或 BFS 算法（如 qiliu、FreedomKing、_ldyex_、Tsawke）来计算单源最短路。
- **预处理**：先不考虑不确定的边，计算出 $1$ 到各点和 $N$ 到各点的最短距离，再根据不同思路处理不确定边的影响。

#### 解决难点
- **处理不确定边**：通过建立超级源点或考虑菊花图等方式，将不确定边的影响转化为可计算的情况。
- **避免重复计算**：通过预处理单源最短路，避免对每个 $i$ 都重新计算最短路，降低时间复杂度。

#### 题解评分
| 作者 | 评分 | 理由 |
| --- | --- | --- |
| mz2022 | 4星 | 思路清晰，代码结构良好，详细说明了三种答案情况。 |
| qiliu | 4星 | 思路独特，将新增边看作菊花图，代码有注释，便于理解。 |
| FreedomKing | 3星 | 思路明确，但代码中包含较多模板，可读性稍差。 |
| __YSC__ | 3星 | 思路简洁，但代码中 `dist` 数组含义解释不够清晰。 |
| Frictional | 3星 | 思路可行，但代码中模板部分过长，核心逻辑不够突出。 |
| _ldyex_ | 3星 | 思路与 mz2022 类似，但代码中部分变量命名不够清晰。 |
| Tsawke | 3星 | 思路清晰，但代码中包含较多自定义函数和模板，增加了理解难度。 |
| Robin_kool | 2星 | 思路有一定分析，但错解部分未详细说明如何修正。 |
| xukehg | 3星 | 思路和代码都比较常规，但代码中 `dijkstra2` 函数与 `dijkstra` 函数重复度较高。 |
| jjy2023 | 2星 | 思路简单直接，但代码中变量命名不够规范，可读性较差。 |
| CQ_Bob | 2星 | 思路有一定分析，但未给出完整代码，仅提供链接。 |
| linbaicheng2022 | 3星 | 思路清晰，代码结构良好，但代码中 `dijkstra2` 函数与 `dijkstra1` 函数重复度较高。 |

### 所选题解
- **mz2022（4星）**
    - **关键亮点**：思路清晰，通过建立超级源点简化问题，详细说明了三种答案情况。
    - **核心代码**：
```cpp
void d1() {
    memset(vis, 0, sizeof(vis));
    memset(dis1, 0x3f, sizeof(dis1));
    q.push(make_pair(0, 1));
    dis1[1] = 0;
    while (!q.empty()) {
        int now = q.top().second;
        q.pop();
        if (vis[now])
            continue;
        vis[now] = 1;
        for (int i = head[now]; i; i = e[i].next)
            if (dis1[now] + e[i].w < dis1[e[i].to]) {
                dis1[e[i].to] = dis1[now] + e[i].w;
                q.push(make_pair(dis1[e[i].to], e[i].to));
            }
    }
}
void d2() {
    memset(vis, 0, sizeof(vis));
    memset(dis2, 0x3f, sizeof(dis2));
    q.push(make_pair(0, n));
    dis2[n] = 0;
    while (!q.empty()) {
        int now = q.top().second;
        q.pop();
        if (vis[now])
            continue;
        vis[now] = 1;
        for (int i = head[now]; i; i = e[i].next)
            if (dis2[now] + e[i].w < dis2[e[i].to]) {
                dis2[e[i].to] = dis2[now] + e[i].w;
                q.push(make_pair(dis2[e[i].to], e[i].to));
            }
    }
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v, 1);
        add(v, u, 1);
    }
    d1();
    d2();
    for (int i = 1; i <= n; i++) {
        int ans = min({dis1[n], dis1[0] + dis2[i], dis1[i] + dis2[0]});
        if (ans == 0x3f3f3f3f) cout << -1 << " ";
        else cout << ans << " ";
    }
    return 0;
}
```
    - **核心实现思想**：通过 `d1` 和 `d2` 函数分别计算从 $1$ 号点和 $N$ 号点出发的单源最短路，然后对于每个 $i$，取三种情况的最小值作为答案。

- **qiliu（4星）**
    - **关键亮点**：思路独特，将新增边看作菊花图，代码有注释，便于理解。
    - **核心代码**：
```cpp
void get_dis(int S, int *dis) {
    queue<int>q;
    for(int i = 1; i <= n; i++) dis[i] = INF;
    dis[S] = 0; q.push(S);
    while(!q.empty()) {
        int now = q.front(); q.pop();
        for(int i = 0, to; i < a[now].size(); i++) {to = a[now][i];
            if(dis[to] > dis[now] + 1) dis[to] = dis[now] + 1, q.push(to);
        }
    }
    return;
}
signed main() {
    n = rd(), m = rd();
    for(int i = 1; i <= m; i++) {
        int u = rd(), v = rd();
        if(u == 0) leaf.push_back(v);
        else a[u].push_back(v), a[v].push_back(u);
    }
    get_dis(1, dis1), get_dis(n, disn);
    int minn_of_dis1 = INF, minn_of_disn = INF, dis1_min = -1, disn_min = -1;
    for(auto x : leaf) {
        if(minn_of_dis1 > dis1[x])  minn_of_dis1 = dis1[x], dis1_min = x;
        if(minn_of_disn > disn[x])  minn_of_disn = disn[x], disn_min = x;
    }
    for(int i = 1; i <= n; i++) {
        int ans = min({dis1[n],
                    (dis1_min == -1 || disn_min == -1? INF : dis1[dis1_min] + 2 + disn[disn_min]),
                    (disn_min == -1? INF : dis1[i] + 1 + disn[disn_min]),
                    (dis1_min == -1? INF : dis1[dis1_min] + 1 + disn[i])});
        wt(ans < INF? ans : -1), putchar(' ');
    }
    return 0;
}
```
    - **核心实现思想**：通过 `get_dis` 函数计算单源最短路，然后找出菊花图叶子节点到 $1$ 和 $N$ 的最小距离，最后对于每个 $i$，根据四种情况取最小值作为答案。

### 最优关键思路或技巧
- **建立超级源点**：将所有不确定的边连接到一个超级源点，将问题转化为常规的图论问题，便于处理不确定边的影响。
- **预处理单源最短路**：通过一次预处理，避免对每个 $i$ 都重新计算最短路，降低时间复杂度。

### 可拓展之处
- **同类型题**：涉及图的最短路问题，且图中存在一些可变边或可变条件的题目。例如，动态规划与最短路结合的问题，在图的基础上增加时间、费用等限制条件。
- **类似算法套路**：在处理复杂图论问题时，可以通过建立虚拟节点或边来简化问题；对于多次查询的情况，考虑预处理以减少重复计算。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察最短路算法和路径计数。
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：基础的单源最短路问题，可用于练习 Dijkstra 或 BFS 算法。
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：加强版的单源最短路问题，需要使用堆优化的 Dijkstra 算法。

### 个人心得摘录与总结
- **Robin_kool**：一开始的错解未考虑 $0$ 号点，导致预处理的最短路可能不准确。总结为在处理图论问题时，要充分考虑所有节点和边的影响，避免遗漏关键信息。

---
处理用时：65.44秒
# 题目信息

# [ABC377E] Permute K times 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc377/tasks/abc377_e

$ (1,2,\ldots,N) $ の並べ替え $ P=(P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が与えられます。

次の操作を $ K $ 回行います。

- $ i=1,2,\ldots,N $ に対して**同時に** $ P\ _\ i $ を $ P\ _\ {P\ _\ i} $ で更新する
 
すべての操作を終えたあとの $ P $ を出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10^5 $
- $ 1\leq\ K\leq10^{18} $
- $ 1\leq\ P\ _\ i\leq\ N\ (1\leq\ i\leq\ N) $
- $ P\ _\ i\neq\ P\ _\ j\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

それぞれの操作によって、$ P $ は次のように変化します。 - $ 1 $ 回目の操作の結果、$ P=(2,4,3,5,6,1) $ となります。 - $ 2 $ 回目の操作の結果、$ P=(4,5,3,6,1,2) $ となります。 - $ 3 $ 回目の操作の結果、$ P=(6,1,3,2,4,5) $ となります。 よって、`6 1 3 2 4 5` を出力してください。

### Sample Explanation 2

$ P\ _\ i=i $ なので、何度操作を行っても $ P $ は変化しません。

## 样例 #1

### 输入

```
6 3

5 6 3 1 2 4```

### 输出

```
6 1 3 2 4 5```

## 样例 #2

### 输入

```
5 1000000000000000000

1 2 3 4 5```

### 输出

```
1 2 3 4 5```

## 样例 #3

### 输入

```
29 51912426

7 24 8 23 6 1 4 19 11 18 20 9 17 28 22 27 15 2 12 26 10 13 14 25 5 29 3 21 16```

### 输出

```
18 23 16 24 21 10 2 27 19 7 12 8 13 5 15 26 17 4 3 9 1 22 25 14 28 11 29 6 20```

# AI分析结果

### 题目内容中文重写
# [ABC377E] 进行 K 次排列操作 2

## 题目描述
[problemUrl]: https://atcoder.jp/contests/abc377/tasks/abc377_e

给定一个 $ (1,2,\ldots,N) $ 的排列 $ P=(P_1,P_2,\ldots,P_N) $。

进行以下操作 $ K $ 次：
- 对于 $ i = 1,2,\ldots,N $，**同时**将 $ P_i $ 更新为 $ P_{P_i} $。

请输出所有操作结束后的 $ P $。

## 说明/提示
### 制約
- $ 1\leq N\leq2\times10^5 $
- $ 1\leq K\leq10^{18} $
- $ 1\leq P_i\leq N\ (1\leq i\leq N) $
- $ P_i\neq P_j\ (1\leq i\lt j\leq N) $
- 输入均为整数

### 样例解释 1
每次操作后，$ P $ 的变化如下：
 - 第 1 次操作后，$ P=(2,4,3,5,6,1) $。
 - 第 2 次操作后，$ P=(4,5,3,6,1,2) $。
 - 第 3 次操作后，$ P=(6,1,3,2,4,5) $。
因此，请输出 `6 1 3 2 4 5`。

### 样例解释 2
由于 $ P_i = i $，无论进行多少次操作，$ P $ 都不会改变。

## 样例 #1
### 输入
```
6 3
5 6 3 1 2 4
```
### 输出
```
6 1 3 2 4 5
```

## 样例 #2
### 输入
```
5 1000000000000000000
1 2 3 4 5
```
### 输出
```
1 2 3 4 5
```

## 样例 #3
### 输入
```
29 51912426
7 24 8 23 6 1 4 19 11 18 20 9 17 28 22 27 15 2 12 26 10 13 14 25 5 29 3 21 16
```
### 输出
```
18 23 16 24 21 10 2 27 19 7 12 8 13 5 15 26 17 4 3 9 1 22 25 14 28 11 29 6 20
```

### 综合分析与结论
这些题解的核心思路都是通过建图找出排列中的环，利用环的性质来解决问题。由于 $K$ 非常大，直接模拟操作会超时，所以关键在于发现每次操作相当于在环上走 $2^K$ 步（部分题解认为是 $2^K - 1$ 步），然后使用快速幂对环长取模来减少计算量。

### 所选题解
- **Sih_qwq（5星）**
    - **关键亮点**：思路清晰，详细描述了手摸样例找规律的过程，代码注释丰富，易于理解。
    - **个人心得**：手摸了一个晚上，一天后才敲的代码，最后肚子痛，一只手捂着肚子另一只手把题过了。
- **FFTotoro（4星）**
    - **关键亮点**：从排列复合的角度进行分析，理论性较强，代码简洁。
- **panxz2009（4星）**
    - **关键亮点**：思路简洁明了，代码结构清晰，易于实现。

### 重点代码
#### Sih_qwq 的核心代码
```cpp
// dfs 求环
void dfs(int x, int fa, int dep, int _id) {
    bel[x] = _id;              // 每个数属于第 _id 个环
    hu[_id][++len[_id]] = x;   // 记录第 _id 个环上每个点，len 是每个环的长度
    pos[x] = len[_id];         // 记录当前第 x 个点在环上的位置
    if (vis[x]) return ;
    vis[x] = 1;   // 标记以访问
    for (int y : g[x])
        if (!vis[y]) dfs(y, x, dep + 1, _id);
}
// 快速幂
ll fast_pow(ll base, ll power, ll _p) {
    ll res = 1;
    for (; power; power >>= 1, base = base * base % _p)
        if (power & 1) res = res * base % _p;
    return res % _p;
}
```
**核心实现思想**：`dfs` 函数用于找出图中的环，记录每个点所属的环、在环上的位置以及环的长度。`fast_pow` 函数用于计算 $2^K$ 对环长取模的结果。

#### FFTotoro 的核心代码
```cpp
inline int qpow(int a,int b,int m){
    int r=1;
    while(b){
        if(b&1)(r*=a)%=m;
        (a*=a)%=m,b>>=1;
    }
    return r;
}
main(){
    ios::sync_with_stdio(false);
    int n,k; cin>>n>>k;
    vector<int> p(n),r(n);
    for(auto &i:p)cin>>i,i--;
    vector<bool> b(n);
    for(int i=0;i<n;i++)
        if(!b[i]){
            vector<int> v;
            for(int x=i;!b[x];x=p[x])
                b[x]=true,v.emplace_back(x);
            int d=qpow(2,k,v.size());
            for(int i=0;i<v.size();i++)
                r[v[i]]=v[(i+d)%v.size()];
        }
    for(int i:r)cout<<i+1<<' ';
    cout<<endl;
    return 0;
}
```
**核心实现思想**：`qpow` 函数实现快速幂。主函数中通过遍历未访问的点找出环，计算 $2^K$ 对环长取模的结果，然后更新答案。

#### panxz2009 的核心代码
```cpp
void dfs(int x) {
    vis[x] = 1;
    cir[cnt].push_back(x);
    for(int y : G[x]) {
        if(vis[y]) continue;
        dfs(y);
    }
}
int qpow(int a, LL b, int mod) {
    int ans = 1;
    while(b) {
        if(b & 1) ans = 1ll * ans * a % mod;
        a = 1ll * a * a % mod;
        b >>= 1;
    }
    return ans;
}
```
**核心实现思想**：`dfs` 函数用于找出图中的环，`qpow` 函数用于计算快速幂。

### 最优关键思路或技巧
- **建图找环**：通过连边 $i \to P_i$ 建图，利用排列的性质可知图由若干个环组成，将问题转化为环上的操作。
- **快速幂优化**：由于 $K$ 很大，使用快速幂计算 $2^K$ 对环长取模的结果，减少计算量。

### 可拓展之处
同类型题或类似算法套路：
- 涉及排列变换的问题，如循环移位、置换等，可以考虑建图找环的方法。
- 处理大规模幂运算时，使用快速幂进行优化。

### 推荐洛谷题目
- [P1967 [NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967)
- [P2607 [ZJOI2008] 骑士](https://www.luogu.com.cn/problem/P2607)
- [P1368 工艺](https://www.luogu.com.cn/problem/P1368)

---
处理用时：48.83秒
# 题目信息

# [AGC035B] Even Degrees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_b

$ N $ 頂点 $ M $ 辺の単純連結無向グラフが与えられます。頂点には $ 1 $ から $ N $ までの番号がついており、$ i $ 本目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。 高橋君は、与えられたグラフのすべての辺にどちらかの向きをつけて有向グラフを作ります。 どの頂点から出る辺の本数も偶数になるような有向グラフを作ることが可能かどうか判定し、可能ならそのような例をひとつ構成してください。

## 说明/提示

### ノート

無向グラフが単純であるとは、自己ループと多重辺を含まないことを指します。

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N\ (1\leq\ i\leq\ M) $
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

このように向き付けることで、頂点 $ 1,3 $ からは $ 2 $ 本、頂点 $ 2,4 $ からは $ 0 $ 本の辺が出るようになります。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 1```

### 输出

```
1 2

1 4

3 2

3 4```

## 样例 #2

### 输入

```
5 5

1 2

2 3

3 4

2 5

4 5```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个包含 $N$ 个顶点和 $M$ 条边的简单连通无向图。顶点编号为 $1$ 到 $N$，第 $i$ 条边连接顶点 $A_i$ 和 $B_i$。高桥君需要将图中的每条边定向，使得每个顶点的出度都是偶数。请判断是否存在这样的定向方案，如果存在，请输出一种可能的方案。

#### 说明/提示

- 简单图：图中没有自环和多重边。
- 约束条件：
  - $2 \leq N \leq 10^5$
  - $N-1 \leq M \leq 10^5$
  - $1 \leq A_i, B_i \leq N$（$1 \leq i \leq M$）
  - 给定的图是简单且连通的。

#### 样例 #1

##### 输入
```
4 4
1 2
2 3
3 4
4 1
```

##### 输出
```
1 2
1 4
3 2
3 4
```

#### 样例 #2

##### 输入
```
5 5
1 2
2 3
3 4
2 5
4 5
```

##### 输出
```
-1
```

### 题解分析与结论

#### 综合分析

本题的核心问题是将无向图的边定向，使得每个顶点的出度都是偶数。题解中普遍提到，当边数 $M$ 为奇数时，由于每条边贡献一个出度，总出度必然为奇数，因此无法满足所有顶点出度为偶数的条件，直接输出 `-1`。当 $M$ 为偶数时，题解主要采用生成树和树上差分的思路来解决问题。

#### 最优关键思路

1. **生成树与树上差分**：通过生成树将问题转化为树上的问题，利用树上差分来调整边的方向，使得每个顶点的出度满足条件。
2. **递归处理子树**：对于每个顶点，先递归处理其子树，再根据当前顶点的出度奇偶性调整其与父节点的边方向。
3. **总出度偶数性**：由于总出度为偶数，且除了根节点外的所有顶点出度均为偶数，因此根节点的出度也必然为偶数。

#### 推荐题解

1. **ForgotMe (5星)**
   - **关键亮点**：通过生成树和递归处理子树的方式，清晰地解决了问题。代码结构清晰，逻辑严谨。
   - **代码核心思想**：先通过 DFS 生成树，然后递归处理每个子树，最后根据出度奇偶性调整边方向。
   - **核心代码**：
     ```cpp
     void solve(int u){
         for(int i=0;i<g[u].size();i++){
             int v=g[u][i];
             solve(v);
         }
         if(u!=1){
             if(du[u]%2==1)printf("%d %d\n",u,f[u]);
             else printf("%d %d\n",f[u],u),du[f[u]]++;
         } 
     }
     ```

2. **Azazеl (4星)**
   - **关键亮点**：通过树上差分和路径翻转的思路，巧妙地解决了问题。代码实现较为复杂，但思路清晰。
   - **代码核心思想**：先随意定向，然后通过树上差分调整路径上的边方向，使得所有顶点的出度满足条件。
   - **核心代码**：
     ```cpp
     void dfs2(int u){
         vis[u]=true;
         for(int i=0;i<G[u].size();i++){
             int v=G[u][i].first;
             if(vis[v]) continue;
             dfs2(v);
             cf[u]+=cf[v];
         }
     }
     ```

3. **251Sec (4星)**
   - **关键亮点**：通过生成树和树上差分的思路，简洁地解决了问题。代码实现较为简洁，逻辑清晰。
   - **代码核心思想**：先通过生成树处理树边，再处理非树边，最后通过树上差分调整边方向。
   - **核心代码**：
     ```cpp
     void DFS(int u, int fa) {
         for (int i = head[u]; i; i = e[i].next) {
             int v = e[i].to;
             if (v == fa) continue;
             DFS(v, u);
             deg[u] ^= (rev[i >> 1] = deg[v]);
         }
     }
     ```

### 可拓展之处

- **类似问题**：类似的问题可以出现在需要调整图的性质（如度数、连通性等）的题目中，通常可以通过生成树和树上差分等技巧来解决。
- **算法套路**：生成树、树上差分、递归处理子树等技巧在图的定向、度数调整等问题中非常常见，掌握这些技巧可以帮助解决更多类似问题。

### 推荐题目

1. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P3128 [USACO15DEC]Max Flow P](https://www.luogu.com.cn/problem/P3128)

---
处理用时：44.38秒
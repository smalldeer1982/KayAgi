# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写
在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

### 综合分析与结论
本题的核心在于判断给定的多组距离约束是否自洽，即是否存在一组坐标满足所有约束条件。题解中主要采用了以下几种方法：
1. **带权并查集**：通过维护每个节点到其祖先的距离，快速判断约束是否冲突。
2. **DFS判负环**：通过DFS遍历图，判断是否存在冲突的路径。
3. **差分约束+SPFA**：通过SPFA算法判断是否存在负环，从而判断约束是否自洽。

### 所选高分题解

#### 题解1：Doraven (★★★★★)
**关键亮点**：
- 使用带权并查集，简洁高效。
- 通过维护`dis`数组记录节点到祖先的距离，快速判断约束是否冲突。

**核心代码**：
```cpp
int find(int x){
    if(fa[x]!=x){
        int nf=fa[x];
        fa[x]=find(fa[x]);
        dis[x]+=dis[nf];
    }
    return fa[x];
}
```
**个人心得**：
- 通过带权并查集，避免了复杂的图遍历，代码简洁且高效。

#### 题解2：CreeperLordVader (★★★★)
**关键亮点**：
- 使用DFS判负环，思路清晰。
- 通过`vis`和`use`数组标记访问状态，避免重复访问。

**核心代码**：
```cpp
bool dfs(int fa){
    vis[fa]=1;
    use[fa]=1;
    for(int i=0;i<v[fa].size();i++){
        int y=v[fa][i];
        int z=e[fa][i];
        if(d[y]>d[fa]+z){
            if(vis[y])return 1;
            d[y]=d[fa]+z;
            if(dfs(y))return 1;
        }
    }
    vis[fa]=0;
    return 0;
}
```
**个人心得**：
- DFS判负环的方法虽然不如并查集高效，但思路清晰，适合理解图的结构。

#### 题解3：Wen_kr (★★★★)
**关键亮点**：
- 使用差分约束+SPFA，标准模板。
- 通过SPFA判断是否存在负环，适用于大规模数据。

**核心代码**：
```cpp
bool spfa(int st){
    que.push(st);
    inq[st]=true;
    dist[st]=0;
    while(!que.empty()){
        int u=que.front();
        que.pop();
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].v;
            if(dist[v]==12345678987654321){
                dist[v]=dist[u]+e[i].w;
                vis[v]=1;
                if(!inq[v])que.push(v);
            }
            else if(dist[v]!=dist[u]+e[i].w)
                return false;
        }
        inq[u]=false;
    }
    return true;
}
```
**个人心得**：
- SPFA算法虽然不如Dijkstra稳定，但在本题中表现良好，适合处理大规模数据。

### 最优关键思路
- **带权并查集**：通过维护节点到祖先的距离，快速判断约束是否冲突，代码简洁高效。
- **DFS判负环**：通过DFS遍历图，判断是否存在冲突的路径，思路清晰。
- **差分约束+SPFA**：通过SPFA算法判断是否存在负环，适用于大规模数据。

### 可拓展之处
- **带权并查集**：适用于处理类似的距离约束问题，如判断图是否连通、是否存在环等。
- **DFS判负环**：适用于处理图的遍历问题，如判断图中是否存在负环、路径是否冲突等。
- **差分约束+SPFA**：适用于处理差分约束系统，如判断是否存在满足所有约束的解。

### 推荐题目
1. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)
2. [P1266 差分约束系统](https://www.luogu.com.cn/problem/P1266)
3. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

### 个人心得总结
- **带权并查集**：通过维护节点到祖先的距离，快速判断约束是否冲突，代码简洁高效。
- **DFS判负环**：通过DFS遍历图，判断是否存在冲突的路径，思路清晰。
- **差分约束+SPFA**：通过SPFA算法判断是否存在负环，适用于大规模数据。

---
处理用时：39.79秒
# 题目信息

# [ARC189B] Minimize Sum

## 题目描述

数轴上有 $N$ 个棋子，最初所有棋子都放置在不同的坐标上，第 $i$ 个棋子放置在坐标 $X_i$ 上。

你可以进行以下操作若干次（可以为 $0$ 次）：

- 选择一个 $i$ 满足 $1\le i\le N-3$，并设 $M$ 为 $X_i$ 与 $X_{i+3}$ 的中点坐标。

- 然后，分别将坐标为 $X_{i+1}$ 与 $X_{i+2}$ 的两颗棋子放在原坐标关于 $M$ 对称的坐标，最后，使坐标较小的棋子的坐标为 $X_{i+1}$，另外一个棋子的坐标为 $X_{i+2}$。

- 可以证明无论如何重复操作，所有的棋子都放置在不同的坐标处。

请找出若干次操作后，$\sum_{i=1}^N X_i$ 的最小值。

## 样例 #1

### 输入

```
4

1 5 7 10```

### 输出

```
21```

## 样例 #2

### 输入

```
6

0 1 6 10 14 16```

### 输出

```
41```

# AI分析结果

### 题目翻译
【题目内容】
# [ARC189B] Minimize Sum

## 题目描述

数轴上有 $N$ 个棋子，最初所有棋子都放置在不同的坐标上，第 $i$ 个棋子放置在坐标 $X_i$ 上。

你可以进行以下操作若干次（可以为 $0$ 次）：

- 选择一个 $i$ 满足 $1\le i\le N-3$，并设 $M$ 为 $X_i$ 与 $X_{i+3}$ 的中点坐标。

- 然后，分别将坐标为 $X_{i+1}$ 与 $X_{i+2}$ 的两颗棋子放在原坐标关于 $M$ 对称的坐标，最后，使坐标较小的棋子的坐标为 $X_{i+1}$，另外一个棋子的坐标为 $X_{i+2}$。

- 可以证明无论如何重复操作，所有的棋子都放置在不同的坐标处。

请找出若干次操作后，$\sum_{i=1}^N X_i$ 的最小值。

## 样例 #1

### 输入

```
4

1 5 7 10```

### 输出

```
21```

## 样例 #2

### 输入

```
6

0 1 6 10 14 16```

### 输出

```
41```

### 题解分析与结论

#### 综合分析与结论
本题的核心在于通过操作改变棋子的位置，使得所有棋子的坐标之和最小。通过分析操作的性质，可以发现操作的本质是交换差分数组中相隔两个位置的元素。因此，问题转化为如何通过交换差分数组中的元素，使得最终的坐标和最小。

关键思路：
1. **差分数组的奇偶分离**：将差分数组的奇数位和偶数位分别排序，这样可以确保较小的差分值尽可能靠前，从而最小化坐标和。
2. **贪心策略**：通过将差分数组的奇数位和偶数位分别排序，可以保证前面的差分值尽可能小，从而减少后续坐标的累加和。

#### 评分较高的题解
1. **作者：ARIS2_0 (赞：9)**
   - **星级：5**
   - **关键亮点**：详细分析了操作对差分数组的影响，并通过奇偶分离排序的方式实现了最小化坐标和。代码实现清晰，逻辑严谨。
   - **个人心得**：作者在比赛中通过思考差分数组的性质，最终找到了问题的解决方案，虽然比赛已经结束，但通过复盘依然获得了宝贵的经验。

2. **作者：dingxiongyue (赞：1)**
   - **星级：4**
   - **关键亮点**：通过数学推导证明了操作对差分数组的影响，并提出了奇偶分离排序的策略。代码简洁，逻辑清晰。
   - **个人心得**：作者通过手玩样例，发现了操作对差分数组的影响，最终得出了解决方案。

3. **作者：A2_Zenith (赞：0)**
   - **星级：4**
   - **关键亮点**：通过分析差分数组的性质，提出了奇偶分离排序的策略，并给出了详细的代码实现。代码可读性强，逻辑清晰。
   - **个人心得**：作者通过脑电波对上了问题的思路，最终成功解决了问题。

#### 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int inf=1e16,maxn=2e5+10;
int a[maxn],p[maxn],p1[maxn],p2[maxn];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n;cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;i++)p[i]=a[i+1]-a[i];
	for(int i=1;i<n;i++){
		if(i%2)p1[(i+1)/2]=p[i];
		else p2[i/2]=p[i];
	}
	sort(p1,p1+(int)ceil((n-1)*1.0/2)+1);
	sort(p2,p2+(n-1)/2+1);
	for(int i=1;i<n;i++){
		if(i%2)p[i]=p1[(i+1)/2];
		else p[i]=p2[i/2];
	}
	int ans=a[1];
	for(int i=2;i<=n;i++)a[i]=a[i-1]+p[i-1],ans+=a[i];
	cout<<ans;
	return 0;
}
```

#### 拓展思路
类似的问题可以通过分析差分数组的性质来解决，尤其是在需要对序列进行多次操作时，差分数组往往能够简化问题的复杂度。例如，在区间修改和查询问题中，差分数组也是一个常用的工具。

#### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

这些题目都涉及到对序列的修改和查询，差分数组或类似的数据结构可以帮助简化问题的解决过程。

---
处理用时：41.52秒
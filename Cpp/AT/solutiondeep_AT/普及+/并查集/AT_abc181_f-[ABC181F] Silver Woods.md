# 题目信息

# [ABC181F] Silver Woods

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc181/tasks/abc181_f

$ xy $ 平面上に $ 2 $ 直線 $ y=-100,\ y=100 $ で囲まれた通路があります。

この通路の中の $ -100\ <\ x\ <\ 100 $ の部分に $ N $ 本の大きさの無視できる釘が打たれており、 $ i $ 本目の釘の座標は $ (x_i,\ y_i) $ です。

高橋くんは実数 $ r\ (0\ <\ r\ \leq\ 100) $ を $ 1 $ つ選び、半径 $ r $ の円を中心が $ (-10^9,\ 0) $ に位置するように置きます。

その後、円を $ (-10^9,\ 0) $ から $ (10^9,\ 0) $ まで移動させます。

このとき、円は通路の境界や釘が円の内部に入らないような範囲で連続的に動かすことができるものとします。

円を $ (10^9,\ 0) $ まで動かせるような最大の $ r $ を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 1\ \leq\ N\ \leq\ 100 $
- $ |x_i|,\ |y_i|\ <\ 100 $
- $ i\ \neq\ j $ ならば $ (x_i,\ y_i)\ \neq\ (x_j,\ y_j) $

### Sample Explanation 1

!\[\](https://img.atcoder.jp/ghi/493d8b75d6dd331fcc0f3949f12262b3.jpg) $ r=40 $ の円を図のように $ y=0 $ に沿って動かすと、 $ (-10^9,\ 0) $ から $ (10^9,\ 0) $ まで移動させることができます。 $ x=0 $ のときにちょうど $ 2 $ つの点と接しますが、円の内部には入っていないため問題ありません。 $ r $ を $ 40 $ より大きくすると、円の中心を $ (10^9,\ 0) $ まで動かすことができなくなるため、 $ r=40 $ が最大になります。

## 样例 #1

### 输入

```
2

0 -40

0 40```

### 输出

```
40```

## 样例 #2

### 输入

```
4

0 -10

99 10

0 91

99 -91```

### 输出

```
50.5```

## 样例 #3

### 输入

```
10

-90 40

20 -30

0 -90

10 -70

80 70

-90 30

-20 -80

10 90

50 30

60 -70```

### 输出

```
33.541019662496845446```

## 样例 #4

### 输入

```
10

65 -90

-34 -2

62 99

42 -13

47 -84

84 87

16 -78

56 35

90 8

90 19```

### 输出

```
35.003571246374276203```

# AI分析结果

### 题目重写
【题目内容】
# [ABC181F] Silver Woods

## 题目描述

$ xy $ 平面上有两条直线 $ y=-100 $ 和 $ y=100 $ 围成的通道。

在这个通道中，$ -100 < x < 100 $ 的部分有 $ N $ 个大小可以忽略的钉子，第 $ i $ 个钉子的坐标是 $ (x_i, y_i) $。

高桥君选择一个实数 $ r $（$ 0 < r \leq 100 $），并将一个半径为 $ r $ 的圆放在中心位于 $ (-10^9, 0) $ 的位置。

然后，他将圆从 $ (-10^9, 0) $ 移动到 $ (10^9, 0) $。

在这个过程中，圆必须连续移动，且不能进入通道的边界或钉子的内部。

求能够将圆移动到 $ (10^9, 0) $ 的最大 $ r $。

## 说明/提示

### 约束

- 输入均为整数
- $ 1 \leq N \leq 100 $
- $ |x_i|, |y_i| < 100 $
- 如果 $ i \neq j $，则 $ (x_i, y_i) \neq (x_j, y_j) $

### 样例解释 1

$ r=40 $ 的圆可以沿着 $ y=0 $ 移动，从 $ (-10^9, 0) $ 到 $ (10^9, 0) $。当 $ x=0 $ 时，圆刚好与两个点接触，但圆内部没有进入，因此没有问题。如果 $ r $ 大于 $ 40 $，则圆无法移动到 $ (10^9, 0) $，因此 $ r=40 $ 是最大值。

## 样例 #1

### 输入

```
2

0 -40

0 40```

### 输出

```
40```

## 样例 #2

### 输入

```
4

0 -10

99 10

0 91

99 -91```

### 输出

```
50.5```

## 样例 #3

### 输入

```
10

-90 40

20 -30

0 -90

10 -70

80 70

-90 30

-20 -80

10 90

50 30

60 -70```

### 输出

```
33.541019662496845446```

## 样例 #4

### 输入

```
10

65 -90

-34 -2

62 99

42 -13

47 -84

84 87

16 -78

56 35

90 8

90 19```

### 输出

```
35.003571246374276203```

### 题解分析与结论
本题的核心思路是通过二分法确定最大半径 $ r $，并结合并查集来判断圆是否能通过给定的钉子布局。难点在于如何有效地判断圆是否能通过，即如何判断上下边界是否被钉子连通。

### 所选高分题解
1. **作者：ikunTLE (赞：11)**  
   - **星级：5**  
   - **关键亮点**：使用并查集和二分法，思路清晰，代码简洁，处理精度问题巧妙。  
   - **核心代码**：
     ```cpp
     bool check(double r){
         _init();
         for(int i=1;i<=n;++i){
             for(int j=i+1;j<=n;++j)
                 if(4*r*r>calc(x[i],x[j],y[i],y[j]))
                     _merge(i,j);
             if(100-y[i]<=2*r)
                 _merge(i,L);
             if(y[i]+100<=2*r)
                 _merge(i,R);
         }
         return _find(L)!=_find(R);
     }
     ```
   - **个人心得**：通过将距离比较转化为平方比较，避免了浮点数精度问题。

2. **作者：Rnfmabj (赞：5)**  
   - **星级：4**  
   - **关键亮点**：详细解释了二分法的应用，并查集的实现清晰，代码结构良好。  
   - **核心代码**：
     ```cpp
     bool check(db lim){
         for(ll i=1;i<=tot;i++)fa[i]=i;
         for(ll i=1;i<=tot;i++){
             for(ll j=1;j<=tot;j++){
                 if(i==j)continue;
                 if(cmp(calc(a[i],a[j]),lim)==2)continue;
                 merge(i,j);
             }
         }
         for(ll i=1;i<=tot;i++){
             if(a[i].y!=100&&a[i].y!=-100)continue;
             for(ll j=i+1;j<=tot;j++){
                 if(a[i].y+a[j].y)continue;
                 if(find(i)==find(j))return 0;
             }
         }
         return 1;
     }
     ```
   - **个人心得**：通过额外添加上下边界点，简化了边界判断的逻辑。

3. **作者：dengchengyu (赞：2)**  
   - **星级：4**  
   - **关键亮点**：并查集的应用简洁明了，二分法的实现逻辑清晰，代码可读性强。  
   - **核心代码**：
     ```cpp
     bool check(ld r){
         fo(i,1,n+2)fa[i]=i;
         fo(i,1,n){
             fo(j,i+1,n){
                 if(4*r*r>(X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j])){
                     int u=getfa(i),v=getfa(j);
                     if(u!=v)fa[u]=v;
                 }
             }
             if(2*r>100-Y[i]){
                 int u=getfa(n+1),v=getfa(i);
                 if(u!=v)fa[u]=v;
             }
             if(2*r>Y[i]+100){
                 int u=getfa(n+2),v=getfa(i);
                 if(u!=v)fa[u]=v;
             }
         }
         return getfa(n+1)!=getfa(n+2);
     }
     ```
   - **个人心得**：通过将上下边界与钉子合并，简化了连通性判断。

### 最优关键思路
1. **二分法**：利用答案的单调性，通过二分法确定最大半径 $ r $。
2. **并查集**：通过并查集判断上下边界是否被钉子连通，从而判断圆是否能通过。
3. **精度处理**：通过将距离比较转化为平方比较，避免浮点数精度问题。

### 可拓展之处
类似的问题可以通过二分法结合并查集来解决，例如判断某些点是否连通、路径是否被阻塞等。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P3387 【模板】二分图匹配](https://www.luogu.com.cn/problem/P3387)
3. [P3371 【模板】单源最短路径](https://www.luogu.com.cn/problem/P3371)

---
处理用时：53.15秒
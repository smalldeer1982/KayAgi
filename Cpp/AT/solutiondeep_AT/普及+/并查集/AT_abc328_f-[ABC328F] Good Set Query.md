# 题目信息

# [ABC328F] Good Set Query

## 题目描述

### 题目内容

给定 $Q$ 个三元组 $(a_1,b_1,d_1),(a_2,b_2,d_2),...,(a_Q,b_Q,d_Q)$ 。

集合 ${1,2,...,Q}$ 的一个子集 $S$ 被定义为**好的子集**，当且仅当存在一个长度为 $N$ 的序列 $(X_1,X_2,...,X_N)$ 满足以下条件：

> 对于所有 $i\in S$ ， $X_{a_i}-X_{b_i}=d_i$ 。

将 $S$ 初始化为空集，对于 $i=1,2,...,Q$ 依次进行以下操作：

> 如果 $S\cup \{i\}$ 是一个好的集合，那么将 $S$ 替换成 $S\cup \{i\}$ 。

以**升序**输出 $S$ 中的所有元素。

## 说明/提示

* 所有输入元素为整数。
* $1\le N,Q\le 2\times 10^5$
* $1\le a_i,b_i\le N$
* $-10^9\le d_i\le 10^9$

## 样例 #1

### 输入

```
3 5

1 2 2

3 2 -3

2 1 -1

3 3 0

1 3 5```

### 输出

```
1 2 4 5```

## 样例 #2

### 输入

```
200000 1

1 1 1```

### 输出

```
```

## 样例 #3

### 输入

```
5 20

4 2 125421359

2 5 -191096267

3 4 -42422908

3 5 -180492387

3 3 174861038

2 3 -82998451

3 4 -134761089

3 1 -57159320

5 2 191096267

2 4 -120557647

4 2 125421359

2 3 142216401

4 5 -96172984

3 5 -108097816

1 5 -50938496

1 2 140157771

5 4 65674908

4 3 35196193

4 4 0

3 4 188711840```

### 输出

```
1 2 3 6 8 9 11 14 15 16 17 19```

# AI分析结果

### 题目内容重写
给定 $Q$ 个三元组 $(a_1,b_1,d_1),(a_2,b_2,d_2),...,(a_Q,b_Q,d_Q)$。集合 ${1,2,...,Q}$ 的一个子集 $S$ 被定义为**好的子集**，当且仅当存在一个长度为 $N$ 的序列 $(X_1,X_2,...,X_N)$ 满足以下条件：

> 对于所有 $i\in S$ ， $X_{a_i}-X_{b_i}=d_i$ 。

将 $S$ 初始化为空集，对于 $i=1,2,...,Q$ 依次进行以下操作：

> 如果 $S\cup \{i\}$ 是一个好的集合，那么将 $S$ 替换成 $S\cup \{i\}$ 。

以**升序**输出 $S$ 中的所有元素。

### 题解综合分析
本题的核心在于如何高效地维护和判断三元组之间的约束关系。大多数题解采用了**带权并查集**来解决这个问题，通过维护每个节点到其根节点的距离来判断是否满足约束条件。部分题解还结合了**启发式合并**来优化时间复杂度。

### 评分较高的题解

#### 1. 作者：Genius_Star (5星)
**关键亮点**：
- 使用了带权并查集，通过维护 `dis` 数组来记录每个节点到根节点的距离。
- 在路径压缩时更新 `dis` 数组，确保查询时能够快速得到节点间的相对距离。
- 代码简洁且高效，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
ll Find(ll x){
    if(fa[x]!=x){
        ll t=fa[x];
        fa[x]=Find(fa[x]);
        dis[x]+=dis[t];
    }
    return fa[x];
}
```

#### 2. 作者：liuhl_weifang (4星)
**关键亮点**：
- 详细解释了带权并查集的工作原理，并通过图示帮助理解。
- 在合并两个集合时，通过公式推导更新根节点之间的距离，确保约束关系的正确性。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
int find(int x){
	if(p[x]!=x){
		int k = find(p[x]);
		w[x] += w[p[x]];
		p[x] = k;
	}
	return p[x];
}
```

#### 3. 作者：WaterSun (4星)
**关键亮点**：
- 使用了带权并查集，并详细解释了如何通过 `val` 数组维护节点间的相对距离。
- 在合并时，通过公式推导更新根节点之间的距离，确保约束关系的正确性。
- 代码简洁且高效，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
int find(int x){
	if (f[x] != x){
		int pf = f[x];
		f[x] = find(f[x]);
		val[x] += val[pf];
	}
	return f[x];
}
```

### 最优关键思路与技巧
- **带权并查集**：通过维护每个节点到根节点的距离，可以快速判断两个节点之间的相对距离是否满足约束条件。
- **路径压缩与启发式合并**：在路径压缩时更新距离，确保查询时能够快速得到节点间的相对距离。启发式合并可以优化时间复杂度，避免最坏情况下的性能问题。

### 可拓展之处
- **类似问题**：类似的问题可以通过带权并查集来解决，如判断图中的约束关系是否满足、维护节点间的相对距离等。
- **优化技巧**：启发式合并、路径压缩等技巧可以应用于其他需要高效维护集合关系的场景。

### 推荐题目
1. [P4079 [SDOI2016] 齿轮](https://www.luogu.com.cn/problem/P4079)
2. [P3302 森林](https://www.luogu.com.cn/problem/P3302)
3. [P1196 [NOI2002] 银河英雄传说](https://www.luogu.com.cn/problem/P1196)

### 个人心得摘录
- **调试经历**：部分题解提到在调试过程中发现路径压缩时未正确更新距离，导致结果错误。通过仔细检查路径压缩的实现，最终解决了问题。
- **顿悟感想**：通过带权并查集，可以高效地维护节点间的相对距离，避免了复杂的图遍历操作，大大简化了问题的解决过程。

---
处理用时：33.49秒
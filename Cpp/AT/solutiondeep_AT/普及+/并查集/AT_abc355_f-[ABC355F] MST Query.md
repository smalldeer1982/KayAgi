# 题目信息

# [ABC355F] MST Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc355/tasks/abc355_f

頂点に $ 1 $ から $ N $ の番号が、辺に $ 1 $ から $ N-1 $ の番号が付いた $ N $ 頂点 $ N-1 $ 辺の重み付き無向連結グラフ $ G $ が与えられます。辺 $ i $ は頂点 $ a_i $ と頂点 $ b_i $ を結んでおり、その重みは $ c_i $ です。

$ Q $ 個のクエリが与えられるので順に処理してください。$ i $ 番目のクエリは以下で説明されます。

- 整数 $ u_i,v_i,w_i $ が与えられる。$ G $ の頂点 $ u_i,v_i $ の間に重み $ w_i $ の辺を追加する。その後、$ G $ の最小全域木に含まれる辺の重みの和を出力する。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 2\ \times\ 10^5 $
- $ 1\leq\ Q\leq\ 2\ \times\ 10^5 $
- $ 1\leq\ a_i\lt\ b_i\leq\ N $
- $ 1\leq\ u_i\lt\ v_i\leq\ N $
- $ 1\leq\ c_i,w_i\leq\ 10 $
- クエリを処理する前のグラフは連結
- 入力はすべて整数
 
### Sample Explanation 1

各クエリで辺を追加した後のグラフを示しています。最小全域木に含まれる辺は赤色で塗られています。 !\[\](https://img.atcoder.jp/abc355/4e83a6e54750f138ecada66dd93b2b67.png)

## 样例 #1

### 输入

```
4 4

1 2 6

2 3 5

2 4 4

1 3 3

1 2 3

1 4 10

3 4 1```

### 输出

```
12

10

10

7```

## 样例 #2

### 输入

```
8 6

1 8 8

1 6 10

1 5 8

2 6 6

6 7 6

1 3 9

2 4 7

1 3 4

1 6 7

3 4 6

1 5 1

7 8 4

3 5 3```

### 输出

```
49

46

45

38

34

33```

# AI分析结果

### 题目内容翻译

**题目描述**

给定一个带有 $N$ 个顶点和 $N-1$ 条边的无向连通图 $G$，顶点编号为 $1$ 到 $N$，边编号为 $1$ 到 $N-1$。每条边 $i$ 连接顶点 $a_i$ 和 $b_i$，且具有权重 $c_i$。

接下来给出 $Q$ 个查询，要求按顺序处理每个查询。第 $i$ 个查询描述如下：

- 给定整数 $u_i, v_i, w_i$，在 $G$ 的顶点 $u_i$ 和 $v_i$ 之间添加一条权重为 $w_i$ 的边。然后输出 $G$ 的最小生成树中包含的边的权重之和。

**说明/提示**

**约束条件**

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq Q \leq 2 \times 10^5$
- $1 \leq a_i < b_i \leq N$
- $1 \leq u_i < v_i \leq N$
- $1 \leq c_i, w_i \leq 10$
- 处理查询前的图是连通的
- 输入均为整数

**样例解释 1**

每个查询中，添加边后的图如下所示。最小生成树中包含的边用红色标记。

### 题解分析与结论

本题的核心是动态维护最小生成树（MST），并在每次添加边后快速计算 MST 的权重和。由于边权的范围很小（$1 \leq w_i \leq 10$），许多题解都利用了这一点进行优化。

#### 最优思路与技巧

1. **并查集分层优化**：通过建立多个并查集，每个并查集维护边权小于等于某个值的边的连通性。这种方法利用了边权范围小的特点，减少了时间复杂度。
2. **LCT（Link-Cut Tree）**：LCT 是一种动态树结构，能够高效处理动态加边、删边和查询路径最大值等操作。虽然实现复杂，但在动态维护 MST 的场景下非常有效。
3. **贪心策略**：在每次添加边时，通过贪心策略决定是否替换 MST 中的边，确保 MST 的权重和最小。

#### 推荐题解

1. **2022liaojianxiang (5星)**
   - **亮点**：利用并查集分层优化，通过维护多个并查集来快速计算 MST 的权重和。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(long long j=z;j<10;j++) {
         long long fx=find(x,j),fy=find(y,j);
         if(fx!=fy) {ans--,fa[j][fy]=fx;}
         else break;
     }
     ```
   - **个人心得**：通过分层并查集，大大减少了时间复杂度，适合边权范围小的场景。

2. **Iceturky (4星)**
   - **亮点**：同样利用并查集分层优化，但通过维护每个并查集的边数来计算 MST 的权重和，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i=w;i<=10;i++) D[i].merge(u,v);
     int ans=D[1].cnt;
     for(int i=2;i<=10;i++) ans+=(D[i].cnt-D[i-1].cnt)*i;
     ```
   - **个人心得**：通过维护边数，避免了重复计算，进一步优化了时间复杂度。

3. **Otue (4星)**
   - **亮点**：结合并查集分层优化和贪心策略，通过差分计算 MST 的权重和，代码简洁高效。
   - **核心代码**：
     ```cpp
     for(int j=w;j<=10;j++) tr[j].merge(u,v);
     int res = tr[1].cnt;
     for(int j=2;j<=10;j++) res += (tr[j].cnt - tr[j - 1].cnt) * j;
     ```
   - **个人心得**：通过差分计算，减少了不必要的计算步骤，适合大规模数据处理。

### 扩展思路与推荐题目

1. **扩展思路**：在处理动态 MST 问题时，如果边权范围较大，可以考虑使用 LCT 或其他动态树结构。此外，如果边权范围较小，分层并查集是一种非常高效的优化方法。
2. **推荐题目**：
   - [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
   - [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)
   - [P4180 [BJWC2010]次小生成树](https://www.luogu.com.cn/problem/P4180)

这些题目都涉及到最小生成树的相关知识，适合进一步巩固和拓展本题的解题思路。

---
处理用时：36.60秒
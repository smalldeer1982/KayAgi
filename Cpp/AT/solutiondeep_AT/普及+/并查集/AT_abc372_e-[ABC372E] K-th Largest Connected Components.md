# 题目信息

# [ABC372E] K-th Largest Connected Components

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc372/tasks/abc372_e

$ N $ 頂点 $ 0 $ 辺の無向グラフがあります。頂点には $ 1 $ から $ N $ の番号がつけられています。

$ Q $ 個のクエリが与えられるので、与えられた順に処理してください。各クエリは以下の $ 2 $ 種類のいずれかです。

- タイプ $ 1 $ : `1 u v` の形式で与えられる。頂点 $ u $ と頂点 $ v $ の間に辺を追加する。
- タイプ $ 2 $ : `2 v k` の形式で与えられる。頂点 $ v $ と連結な頂点の中で、$ k $ 番目に頂点番号が大きいものを出力する。ただし、頂点 $ v $ と連結な頂点が $ k $ 個未満のときは `-1` を出力する。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\leq\ 2\times\ 10^5 $
- タイプ $ 1 $ のクエリにおいて、$ 1\leq\ u\lt\ v\leq\ N $
- タイプ $ 2 $ のクエリにおいて、$ 1\leq\ v\leq\ N,\ 1\leq\ k\leq\ 10 $
- 入力は全て整数
 
### Sample Explanation 1

\- $ 1 $ 個目のクエリについて、頂点 $ 1 $ と頂点 $ 2 $ の間に辺が追加されます。 - $ 2 $ 個目のクエリについて、頂点 $ 1 $ と連結な頂点は $ 1,2 $ の $ 2 $ つです。この中で $ 1 $ 番目に大きい $ 2 $ を出力します。 - $ 3 $ 個目のクエリについて、頂点 $ 1 $ と連結な頂点は $ 1,2 $ の $ 2 $ つです。この中で $ 2 $ 番目に大きい $ 1 $ を出力します。 - $ 4 $ 個目のクエリについて、頂点 $ 1 $ と連結な頂点は $ 1,2 $ の $ 2 $ つです。$ 3 $ 個未満なので `-1` を出力します。 - $ 5 $ 個目のクエリについて、頂点 $ 1 $ と頂点 $ 3 $ の間に辺が追加されます。 - $ 6 $ 個目のクエリについて、頂点 $ 2 $ と頂点 $ 3 $ の間に辺が追加されます。 - $ 7 $ 個目のクエリについて、頂点 $ 3 $ と頂点 $ 4 $ の間に辺が追加されます。 - $ 8 $ 個目のクエリについて、頂点 $ 1 $ と連結な頂点は $ 1,2,3,4 $ の $ 4 $ つです。この中で $ 1 $ 番目に大きい $ 4 $ を出力します。 - $ 9 $ 個目のクエリについて、頂点 $ 1 $ と連結な頂点は $ 1,2,3,4 $ の $ 4 $ つです。この中で $ 3 $ 番目に大きい $ 2 $ を出力します。 - $ 10 $ 個目のクエリについて、頂点 $ 1 $ と連結な頂点は $ 1,2,3,4 $ の $ 4 $ つです。$ 5 $ 個未満なので `-1` を出力します。

## 样例 #1

### 输入

```
4 10

1 1 2

2 1 1

2 1 2

2 1 3

1 1 3

1 2 3

1 3 4

2 1 1

2 1 3

2 1 5```

### 输出

```
2

1

-1

4

2

-1```

## 样例 #2

### 输入

```
6 20

1 3 4

1 3 5

2 1 1

2 3 1

1 1 5

2 6 9

2 1 3

2 6 1

1 4 6

2 2 1

2 6 2

2 4 7

1 1 4

2 6 2

2 3 4

1 2 5

2 4 1

1 1 6

2 3 3

2 1 3```

### 输出

```
1

5

-1

3

6

2

5

-1

5

3

6

4

4```

# AI分析结果

### 题目内容重写

#### [ABC372E] K-th Largest Connected Components

##### 题目描述

有一个包含 $N$ 个顶点和 $0$ 条边的无向图。顶点编号为 $1$ 到 $N$。

给定 $Q$ 个查询，按顺序处理每个查询。每个查询是以下两种类型之一：

- 类型 $1$：以 `1 u v` 的形式给出。在顶点 $u$ 和顶点 $v$ 之间添加一条边。
- 类型 $2$：以 `2 v k` 的形式给出。输出与顶点 $v$ 相连的顶点中，第 $k$ 大的顶点编号。如果与顶点 $v$ 相连的顶点少于 $k$ 个，则输出 `-1`。

##### 说明/提示

###### 约束

- $1 \leq N, Q \leq 2 \times 10^5$
- 在类型 $1$ 的查询中，$1 \leq u < v \leq N$
- 在类型 $2$ 的查询中，$1 \leq v \leq N$, $1 \leq k \leq 10$
- 输入均为整数

### 题解分析与结论

#### 综合分析

本题的核心在于动态维护连通块，并在查询时快速找到第 $k$ 大的顶点编号。由于 $k$ 的限制（$k \leq 10$），许多题解都利用了这一点，通过维护每个连通块的前 $10$ 大顶点编号来优化查询效率。

#### 最优关键思路

1. **并查集**：用于高效管理连通块的合并与查询。
2. **启发式合并**：在合并两个连通块时，将较小的集合合并到较大的集合中，以减少时间复杂度。
3. **维护前 $k$ 大元素**：由于 $k \leq 10$，可以通过 `set` 或 `vector` 维护每个连通块的前 $10$ 大顶点编号，避免维护过多无用信息。

#### 可拓展之处

- **类似问题**：可以扩展到维护更多信息，如连通块的大小、连通块的直径等。
- **其他数据结构**：可以使用平衡树（如 `pb_ds` 库中的 `tree`）来维护更复杂的查询。

#### 推荐题目

1. [P3224 [HNOI2012] 永无乡](https://www.luogu.com.cn/problem/P3224)
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
3. [P3391 【模板】文艺平衡树](https://www.luogu.com.cn/problem/P3391)

### 精选题解

#### 题解1：作者：Ratio_Y (赞：3)

##### 星级：★★★★☆

##### 关键亮点

- **启发式合并**：通过将较小的 `set` 合并到较大的 `set` 中，优化了合并操作的时间复杂度。
- **维护前 $10$ 大元素**：利用 $k \leq 10$ 的条件，只维护每个连通块的前 $10$ 大顶点编号，减少了空间和时间开销。

##### 核心代码

```cpp
void merge(int u, int v) {
    int fu = find(u), fv = find(v);
    if (fu == fv) return;
    if (st[fu].size() > st[fv].size()) swap(fu, fv);
    fx[fu] = fv;
    st[fv].insert(st[fu].begin(), st[fu].end());
    while (st[fv].size() > 10) st[fv].erase(st[fv].begin());
}
```

##### 个人心得

作者提到，由于 $k \leq 10$，可以通过只维护前 $10$ 大元素来避免不必要的计算，从而优化了代码性能。

#### 题解2：作者：Hurraciny (赞：3)

##### 星级：★★★★☆

##### 关键亮点

- **启发式合并**：在合并时，将较小的连通块合并到较大的连通块中，减少了合并操作的时间复杂度。
- **维护前 $10$ 大元素**：通过 `set` 维护每个连通块的前 $10$ 大顶点编号，优化了查询效率。

##### 核心代码

```cpp
void add_set(vector<set<int> >& to, int u, int v) {
    if (to[u].size() < 10)
        to[u].insert(v);
    else {
        if (*(to[u].begin()) < v) {
            to[u].erase(to[u].begin());
            to[u].insert(v);
        }
    }
}
```

##### 个人心得

作者提到，由于 $k \leq 10$，可以通过只维护前 $10$ 大元素来避免不必要的计算，从而优化了代码性能。

#### 题解3：作者：small_lemon_qwq (赞：3)

##### 星级：★★★★☆

##### 关键亮点

- **启发式合并**：在合并时，将较小的连通块合并到较大的连通块中，减少了合并操作的时间复杂度。
- **维护前 $10$ 大元素**：通过 `vector` 维护每个连通块的前 $10$ 大顶点编号，优化了查询效率。

##### 核心代码

```cpp
void update(int u, int v) {
    int i = 1, j = 1;
    memcpy(tmp, g[v], sizeof(tmp));
    for (int k = 1; k <= 10; k++) {
        if (g[u][i] > tmp[j]) {
            g[v][k] = g[u][i];
            i++;
        } else {
            g[v][k] = tmp[j];
            j++;
        }
    }
}
```

##### 个人心得

作者提到，由于 $k \leq 10$，可以通过只维护前 $10$ 大元素来避免不必要的计算，从而优化了代码性能。

---
处理用时：44.45秒
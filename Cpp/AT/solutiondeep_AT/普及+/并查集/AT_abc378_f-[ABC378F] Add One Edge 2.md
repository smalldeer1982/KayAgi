# 题目信息

# [ABC378F] Add One Edge 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc378/tasks/abc378_f

$ N $ 頂点の木が与えられます。$ i $ 番目の辺 $ (1\leq\ i\leq\ N-1) $ は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結んでいます。

与えられた木に無向辺を一本追加して得られるグラフは、必ずちょうど一つの閉路を含みます。

そのようなグラフのうち、以下の条件を全て満たすものの個数を求めてください。

- グラフは単純グラフ
- グラフの閉路に含まれる頂点の次数は全て $ 3 $

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\leq\ u_i,v_i\leq\ N $
- 与えられるグラフは木である
- 入力される数値は全て整数
 
### Sample Explanation 1

頂点 $ 2 $ と頂点 $ 4 $ を結ぶ辺を追加して得られるグラフは単純グラフであり、閉路に含まれる頂点の次数は全て $ 3 $ なので条件を満たします。

### Sample Explanation 2

条件を満たすグラフが存在しない場合もあります。

## 样例 #1

### 输入

```
6

1 2

2 3

3 4

4 5

3 6```

### 输出

```
1```

## 样例 #2

### 输入

```
7

1 2

2 7

3 5

7 3

6 2

4 7```

### 输出

```
0```

## 样例 #3

### 输入

```
15

1 15

11 14

2 10

1 7

9 8

6 9

4 12

14 5

4 9

8 11

7 4

1 13

3 6

11 10```

### 输出

```
6```

# AI分析结果

### 题目重写
#### [ABC378F] Add One Edge 2

**题目描述**

给定一棵 $N$ 个顶点的树。第 $i$ 条边 $(1 \leq i \leq N-1)$ 双向连接顶点 $u_i$ 和顶点 $v_i$。

在给定的树中添加一条无向边后，得到的图必定包含恰好一个环。

求满足以下所有条件的图的数量：

- 图是简单图。
- 图中环上所有顶点的度数均为 $3$。

**说明/提示**

**约束条件**

- $3 \leq N \leq 2 \times 10^5$
- $1 \leq u_i, v_i \leq N$
- 给定的图是树。
- 输入的所有数值均为整数。

**样例解释 1**

在顶点 $2$ 和顶点 $4$ 之间添加一条边后得到的图是简单图，且环上所有顶点的度数均为 $3$，因此满足条件。

**样例解释 2**

有时可能不存在满足条件的图。

**样例 #1**

**输入**

```
6
1 2
2 3
3 4
4 5
3 6
```

**输出**

```
1
```

**样例 #2**

**输入**

```
7
1 2
2 7
3 5
7 3
6 2
4 7
```

**输出**

```
0
```

**样例 #3**

**输入**

```
15
1 15
11 14
2 10
1 7
9 8
6 9
4 12
14 5
4 9
8 11
7 4
1 13
3 6
11 10
```

**输出**

```
6
```

---

### 题解分析与结论

#### 综合分析
本题的核心在于通过添加一条边，使得图中形成一个环，且环上所有顶点的度数均为 $3$。题解的主要思路是找到所有度数为 $3$ 的连通块，并统计与这些连通块相邻的度数为 $2$ 的点的数量，然后通过组合数计算满足条件的边数。

#### 最优关键思路
1. **连通块统计**：通过并查集或 DFS 统计所有度数为 $3$ 的连通块，并记录每个连通块相邻的度数为 $2$ 的点的数量。
2. **组合数计算**：对于每个连通块，计算其相邻的度数为 $2$ 的点数 $cnt$，贡献为 $cnt \times (cnt - 1) / 2$。
3. **避免重复计算**：通过标记已访问的点，确保每个连通块只被处理一次。

#### 推荐题解
1. **作者：gesong (5星)**
   - **关键亮点**：通过 DFS 和 BFS 结合，清晰地统计了每个连通块的贡献，代码结构清晰，逻辑严谨。
   - **代码核心**：
     ```cpp
     void dfs(int u, int fa) {
         for (auto v : a[u]) {
             if (v != fa) dfs(v, u);
             w[u] += (d[v] == 2);
         }
     }
     int bfs(int sx) {
         queue<int> q;
         q.push(sx);
         int ans = 0;
         while (!q.empty()) {
             int u = q.front();
             q.pop();
             ans += w[u];
             d[u] = 0;
             for (auto v : a[u]) {
                 if (d[v] != 3) continue;
                 q.push(v);
             }
         }
         return ans;
     }
     ```

2. **作者：DarkClever (4星)**
   - **关键亮点**：使用并查集维护连通块，并统计相邻的度数为 $2$ 的点数，思路清晰，代码简洁。
   - **代码核心**：
     ```cpp
     void dfs1(int x, int f) {
         for (int xx : e[x]) {
             if (xx != f) {
                 dfs1(xx, x);
                 if (ds[x] == 2 && ds[xx] == 3) sz[find(xx)]++;
                 else if (ds[xx] == 2 && ds[x] == 3) sz[find(x)]++;
                 if (ds[x] == 3 && ds[xx] == 3) {
                     sz[find(x)] += sz[find(xx)];
                     fa[find(xx)] = find(x);
                 }
             }
         }
     }
     ```

3. **作者：qfy123 (4星)**
   - **关键亮点**：通过并查集维护连通块，并统计相邻的度数为 $2$ 的点数，代码结构清晰，逻辑严谨。
   - **代码核心**：
     ```cpp
     void dfs(int x, int ff) {
         repl(i, head[x], i, e[i].nxt) {
             int v = e[i].to;
             if (v == ff) continue;
             dfs(v, x);
             int fx = find(x), fy = find(v);
             if (deg[x] == 3 && deg[v] == 2) siz[fx]++;
             else if (deg[x] == 2 && deg[v] == 3) siz[fy]++;
             else if (deg[x] == 3 && deg[v] == 3) {
                 siz[fx] += siz[fy];
                 fa[fy] = fx;
             }
         }
     }
     ```

#### 个人心得
- **调试经历**：在处理连通块时，确保每个连通块只被处理一次，避免重复计算。
- **踩坑教训**：在统计相邻的度数为 $2$ 的点时，注意不要遗漏或重复计数。

#### 扩展思路
- **类似题目**：可以考虑其他涉及树的性质和图的环的问题，如树的直径、最小生成树等。
- **算法优化**：在处理大规模数据时，可以考虑使用更高效的并查集实现，如路径压缩和按秩合并。

#### 推荐题目
1. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)

---
处理用时：48.18秒
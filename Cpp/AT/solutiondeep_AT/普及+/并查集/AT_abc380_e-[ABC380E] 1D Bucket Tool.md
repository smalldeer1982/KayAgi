# 题目信息

# [ABC380E] 1D Bucket Tool

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc380/tasks/abc380_e

$ 1 $ から $ N $ の番号がついた $ N $ 個のマスが一列に並んでいます。  
$ 1\ \leq\ i\ <\ N $ について、マス $ i $ とマス $ i+1 $ は隣接しています。

最初、マス $ i $ は色 $ i $ で塗られています。

クエリが $ Q $ 個与えられるので、順に処理してください。クエリは次の $ 2 $ 種類のいずれかです。

- `1 x c`: マス $ x $ から始めて「いまいるマスと同じ色に塗られている隣接するマス」への移動を繰り返すことで到達可能なマスを全て色 $ c $ に塗り替える
- `2 c`: 色 $ c $ で塗られているマスの個数を答える

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\times\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 2\times\ 10^5 $
- $ 1 $ 種類目のクエリにおいて、$ 1\ \leq\ x\ \leq\ N $
- $ 1,2 $ 種類目のクエリにおいて、$ 1\ \leq\ c\ \leq\ N $
- $ 2 $ 種類目のクエリが少なくとも $ 1 $ つ存在する
- 入力は全て整数である

### Sample Explanation 1

クエリにより、マスの色は図のように塗り替えられていきます。 
![図](https://img.atcoder.jp/abc380/c3bf3eec819a7b7fcbfd21065c06bab2.png)

## 样例 #1

### 输入

```
5 6
1 5 4
1 4 2
2 2
1 3 2
1 2 3
2 3```

### 输出

```
3
4```

# AI分析结果

### 题目内容重写
题目描述：  
编号为 $1$ 到 $N$ 的 $N$ 个格子排成一列，初始时第 $i$ 个格子的颜色为 $i$。  
现在有 $Q$ 个操作，操作分为两种：  
1. `1 x c`：从第 $x$ 个格子开始，将所有与 $x$ 颜色相同且相邻的格子全部涂成颜色 $c$。  
2. `2 c`：查询当前有多少个格子的颜色为 $c$。

### 题解分析与结论
本题的核心在于如何高效地处理区间染色和查询操作。大多数题解采用了并查集（DSU）来维护连续同色区间，通过合并相邻同色区间来优化操作。部分题解还使用了线段树或珂朵莉树等其他数据结构，但并查集的实现更为简洁且效率较高。

### 精选题解
1. **作者：liluhexuan**  
   - **星级：4.5**  
   - **关键亮点**：使用并查集维护连续同色区间，通过维护区间的左右端点和颜色信息，高效处理染色和查询操作。代码清晰，逻辑严谨，且通过引入 `mn` 和 `mx` 数组解决了合并时的边界问题。  
   - **个人心得**：作者提到在合并区间时遇到边界问题，通过引入 `mn` 和 `mx` 数组成功解决，体现了调试过程中的思考与优化。  
   - **核心代码**：
     ```cpp
     void join(int x, int y) {
         x = find(x), y = find(y);
         if (x != y) sum[x] += sum[y], p[y] = x;
         mx[x] = max(mx[x], mx[y]);
         mn[x] = min(mn[x], mn[y]);
     }
     ```

2. **作者：Moya_Rao**  
   - **星级：4**  
   - **关键亮点**：通过并查集维护连通块，记录每个连通块的颜色、左右端点和大小，简化了染色和查询操作。代码结构清晰，注释详细，适合初学者理解。  
   - **核心代码**：
     ```cpp
     void merge(int x, int y) {
         x = find(x), y = find(y);
         if (x == y) return;
         fa[y] = x;
         l[x] = min(l[x], l[y]);
         r[x] = max(r[x], r[y]);
     }
     ```

3. **作者：Aegleseeker_**  
   - **星级：4**  
   - **关键亮点**：使用并查集维护连通块，通过维护每个连通块的颜色、左右端点和大小，简化了染色和查询操作。代码简洁，逻辑清晰，适合快速实现。  
   - **核心代码**：
     ```cpp
     void merge(int x, int y) {
         x = find(x), y = find(y);
         if (x == y) return;
         fa[y] = x;
         l[x] = min(l[x], l[y]);
         r[x] = max(r[x], r[y]);
     }
     ```

### 最优关键思路与技巧
- **并查集维护连续区间**：通过并查集维护连续同色区间，记录每个区间的左右端点和颜色信息，简化了染色和查询操作。
- **合并优化**：在染色操作后，检查相邻区间是否同色，若同色则合并，减少区间数量，提高后续操作效率。
- **颜色计数**：通过维护每个颜色的格子数量，查询操作可以 $O(1)$ 完成。

### 可拓展之处
- **类似问题**：区间染色、区间查询问题，如线段树、珂朵莉树等数据结构也可以用于解决类似问题。
- **优化思路**：可以考虑使用更高效的数据结构（如动态树）来进一步优化合并和查询操作。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)  
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)  
3. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)

---
处理用时：38.19秒
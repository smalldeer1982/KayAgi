# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写
在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

### 题解分析与结论

#### 综合分析
本题的核心是判断给定的 $m$ 条信息是否自洽，即是否存在一组坐标 $x$ 满足所有信息。题解中主要采用了以下几种方法：
1. **带权并查集**：通过维护每个节点到其祖先的距离，判断信息是否冲突。
2. **DFS判负环**：通过DFS遍历图，判断是否存在负环或冲突。
3. **差分约束与SPFA**：通过差分约束系统，使用SPFA算法判断是否存在矛盾。

#### 最优关键思路
- **带权并查集**：通过维护每个节点到其祖先的距离，判断信息是否冲突。这种方法在时间复杂度上较为优秀，且代码实现简洁。
- **DFS判负环**：通过DFS遍历图，判断是否存在负环或冲突。这种方法适合图较小的情况，但时间复杂度较高。
- **差分约束与SPFA**：通过差分约束系统，使用SPFA算法判断是否存在矛盾。这种方法适合处理大规模数据，但实现较为复杂。

### 所选高分题解

#### 题解1：Doraven (5星)
**关键亮点**：
- 使用带权并查集，维护每个节点到其祖先的距离，判断信息是否冲突。
- 代码简洁，时间复杂度优秀。

**核心代码**：
```cpp
int find(int x){
    if(fa[x]!=x){
        int nf=fa[x];
        fa[x]=find(fa[x]);
        dis[x]+=dis[nf];
    }
    return fa[x];
}

int rl=find(l),rr=find(r);
if(rl==rr&&dis[l]-dis[r]!=d)
    ok=0;
if(rl!=rr){
    fa[rl]=rr;
    dis[rl]=d+dis[r]-dis[l];
}
```

#### 题解2：Wen_kr (4星)
**关键亮点**：
- 使用差分约束系统，通过SPFA算法判断是否存在矛盾。
- 处理大规模数据时表现良好。

**核心代码**：
```cpp
bool spfa(int st){
    que.push(st);
    inq[st] = true;
    dist[st] = 0;
    while(!que.empty()){
        int u = que.front();
        que.pop();
        for(int i = head[u];i;i = e[i].nxt){
            int v = e[i].v;
            if(dist[v] == 12345678987654321){
                dist[v] = dist[u] + e[i].w;
                vis[v] = 1;
                if(!inq[v])
                    que.push(v);
            }
            else if(dist[v] != dist[u] + e[i].w)
                return false;
        }
        inq[u] = false;
    }
    return true;
}
```

#### 题解3：Error_666 (4星)
**关键亮点**：
- 使用DFS遍历图，判断是否存在负环或冲突。
- 代码实现简单，适合小规模数据。

**核心代码**：
```cpp
void dfs(int x){
    if(flag) return;
    vis[x] = 1;
    for(int i = h[x]; i != 0; i = e[i].next){
        int t = pos[x] + e[i].dis;
        if(pos[e[i].to] == inf) pos[e[i].to] = t, dfs(e[i].to);
        else if(t != pos[e[i].to]) {flag = 1; return;}
    }
}
```

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
3. [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)

### 个人心得总结
- **调试经历**：在实现带权并查集时，需要注意路径压缩和距离更新的顺序，否则容易导致错误。
- **踩坑教训**：在使用DFS判负环时，需要注意图的连通性，避免漏判某些节点。
- **顿悟感想**：差分约束系统在处理大规模数据时表现良好，但实现较为复杂，需要仔细调试。

---
处理用时：38.59秒
# 题目信息

# [ABC251F] Two Spanning Trees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc251/tasks/abc251_f

$ N $ 頂点 $ M $ 辺の無向グラフ $ G $ が与えられます。 $ G $ は**単純**（自己ループおよび多重辺を持たない）かつ**連結**です。

$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結ぶ無向辺 $ \lbrace\ u_i,\ v_i\ \rbrace $ です。

下記の $ 2 $ つの条件をともに満たすような $ G $ の $ 2 $ つの全域木 $ T_1,T_2 $ を $ 1 $ 組構成してください。（ $ T_1 $ と $ T_2 $ は異なる全域木である必要はありません。）

- $ T_1 $ は下記を満たす。
  
  > $ T_1 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_1 $ に含まれないすべての辺 $ \lbrace\ u,\ v\ \rbrace $ について、$ u $ と $ v $ は $ T_1 $ において祖先と子孫の関係にある。
- $ T_2 $ は下記を満たす。
  
  > $ T_2 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_2 $ に含まれない辺 $ \lbrace\ u,\ v\ \rbrace $ であって、$ u $ と $ v $ が $ T_2 $ において祖先と子孫の関係にあるようなものは存在しない。

ここで、「根付き木 $ T $ において頂点 $ u $ と頂点 $ v $ が祖先と子孫の関係にある」とは、「 $ T $ において $ u $ が $ v $ の祖先である」と「 $ T $ において $ v $ が $ u $ の祖先である」のうちどちらかが成り立つことをいいます。

本問題の制約下において上記の条件を満たす $ T_1 $ と $ T_2 $ は必ず存在することが示せます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \min\lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 入力はすべて整数
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

上記の出力例において、$ T_1 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 4,\ 3\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 4,\ 2\ \rbrace,\ \lbrace\ 6,\ 2\ \rbrace $ を持つ $ G $ の全域木です。この $ T_1 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_1 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 5,\ 1\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 5 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 2\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 2 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 6\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 6 $ の祖先です。 また、$ T_2 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 5\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 2,\ 1\ \rbrace,\ \lbrace\ 1,\ 6\ \rbrace $ を持つ $ G $ の全域木です。この $ T_2 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_2 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 4,\ 3\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 3 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 2,\ 6\ \rbrace $ について、頂点 $ 2 $ と頂点 $ 6 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 4,\ 2\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 2 $ は祖先と子孫の関係にありません。

### Sample Explanation 2

$ 3 $ 本の辺 $ \lbrace\ 1,\ 2\rbrace,\ \lbrace\ 1,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace $ を持つ木 $ T $ が $ G $ の唯一の全域木です。 $ G $ の辺のうちこの木 $ T $ に含まれない辺は存在しないので、明らかに、$ T $ は $ T_1 $ の条件と $ T_2 $ の条件をともに満たします。

## 样例 #1

### 输入

```
6 8

5 1

4 3

1 4

3 5

1 2

2 6

1 6

4 2```

### 输出

```
1 4

4 3

5 3

4 2

6 2

1 5

5 3

1 4

2 1

1 6```

## 样例 #2

### 输入

```
4 3

3 1

1 2

1 4```

### 输出

```
1 2

1 3

1 4

1 4

1 3

1 2```

# AI分析结果

### 题目内容重写

给定一个 $N$ 个顶点 $M$ 条边的无向图 $G$，图 $G$ 是**简单**（没有自环和多重边）且**连通**的。

对于 $i = 1, 2, \ldots, M$，第 $i$ 条边是连接顶点 $u_i$ 和顶点 $v_i$ 的无向边 $\{u_i, v_i\}$。

请构造两棵满足以下条件的生成树 $T_1$ 和 $T_2$（$T_1$ 和 $T_2$ 可以相同）：

- $T_1$ 满足：将 $T_1$ 视为以顶点 $1$ 为根的根树时，$G$ 中所有不在 $T_1$ 中的边 $\{u, v\}$ 满足 $u$ 和 $v$ 在 $T_1$ 中是祖先和后代的关系。
- $T_2$ 满足：将 $T_2$ 视为以顶点 $1$ 为根的根树时，$G$ 中所有不在 $T_2$ 中的边 $\{u, v\}$ 满足 $u$ 和 $v$ 在 $T_2$ 中**不**是祖先和后代的关系。

在本题的约束下，满足条件的 $T_1$ 和 $T_2$ 必定存在。

### 样例解释

#### 样例 1

输入：
```
6 8
5 1
4 3
1 4
3 5
1 2
2 6
1 6
4 2
```

输出：
```
1 4
4 3
5 3
4 2
6 2
1 5
5 3
1 4
2 1
1 6
```

#### 样例 2

输入：
```
4 3
3 1
1 2
1 4
```

输出：
```
1 2
1 3
1 4
1 4
1 3
1 2
```

### 题解分析与结论

#### 综合分析

题目要求构造两棵生成树 $T_1$ 和 $T_2$，分别满足不同的条件。通过分析样例和题解，可以发现：

1. **$T_1$ 的构造**：使用深度优先搜索（DFS）生成树。DFS 的性质保证了所有非树边都是返祖边，即连接的两个节点在树中是祖先和后代的关系。
2. **$T_2$ 的构造**：使用广度优先搜索（BFS）生成树。BFS 的性质保证了所有非树边连接的两个节点在树中不是祖先和后代的关系。

#### 最优关键思路

- **DFS 生成树**：DFS 遍历时，优先深入访问子节点，确保非树边为返祖边。
- **BFS 生成树**：BFS 遍历时，按层次访问节点，确保非树边连接的两个节点不在同一祖先路径上。

#### 推荐题解

1. **作者：Nahida_Buer (5星)**
   - **关键亮点**：详细解释了 DFS 和 BFS 生成树的性质，并给出了清晰的证明。
   - **代码实现**：使用 `bitset` 记录访问状态，代码简洁高效。
   - **核心代码**：
     ```cpp
     void dfs(int u) {
         for(int v : h[u]) {
             if(pd[(v<<1)-1]) continue;
             pd[(v<<1)-1] = 1;
             printf("%d %d\n", u, v);
             dfs(v);
         }
     }
     void bfs() {
         queue<int> q;
         q.push(1);
         while(!q.empty()) {
             int u = q.front();
             q.pop();
             for(int v : h[u]) {
                 if(pd[v<<1]) continue;
                 pd[v<<1] = 1;
                 printf("%d %d\n", u, v);
                 q.push(v);
             }
         }
     }
     ```

2. **作者：Pengzt (4星)**
   - **关键亮点**：结合 Tarjan 算法的思想，解释了 DFS 和 BFS 生成树的合理性。
   - **代码实现**：直接使用 DFS 和 BFS 生成树，代码简洁明了。
   - **核心代码**：
     ```cpp
     void dfs(int u) {
         vis[u] = true;
         for(int v : e[u]) {
             if(vis[v]) continue;
             cout << u << " " << v << "\n";
             vis[v] = 1;
             dfs(v);
         }
     }
     void bfs(int s) {
         queue<int> q;
         q.push(s);
         vis[s] = 1;
         while(q.size()) {
             int u = q.front();
             q.pop();
             for(int v : e[u]) {
                 if(vis[v]) continue;
                 cout << u << " " << v << "\n";
                 vis[v] = 1;
                 q.push(v);
             }
         }
     }
     ```

3. **作者：ZBH_123 (4星)**
   - **关键亮点**：详细分析了 BFS 和 DFS 生成树的性质，并给出了清晰的证明。
   - **代码实现**：使用 `vector` 存储树边，代码结构清晰。
   - **核心代码**：
     ```cpp
     void dfs(int x, int e) {
         vis[x] = true;
         for(int i = head[x]; i; i = edge[i].next) {
             if(i != (e^1) || e == 0) {
                 if(!vis[edge[i].to]) {
                     t1.push_back(make_pair(x, edge[i].to));
                     dfs(edge[i].to, i);
                 }
             }
         }
     }
     void bfs() {
         queue<int> q;
         q.push(1);
         vis[1] = true;
         while(!q.empty()) {
             int u = q.front();
             q.pop();
             for(int i = head[u]; i; i = edge[i].next) {
                 int v = edge[i].to;
                 if(!vis[v]) {
                     t2.push_back(make_pair(u, v));
                     q.push(v);
                     vis[v] = true;
                 }
             }
         }
     }
     ```

### 拓展与推荐题目

#### 拓展思路

- **DFS 生成树**：适用于需要保证非树边为返祖边的场景，如 Tarjan 算法中的强连通分量分解。
- **BFS 生成树**：适用于需要保证非树边连接的两个节点不在同一祖先路径上的场景，如最短路径问题。

#### 推荐题目

1. **P3379 【模板】最近公共祖先（LCA）**：考察树的遍历和祖先关系。
2. **P3388 【模板】割点（割顶）**：考察图的连通性和 DFS 的应用。
3. **P3916 图的遍历**：考察图的遍历和生成树的性质。

---
处理用时：58.52秒
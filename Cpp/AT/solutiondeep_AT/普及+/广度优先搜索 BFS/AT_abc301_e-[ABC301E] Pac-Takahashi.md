# 题目信息

# [ABC301E] Pac-Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc301/tasks/abc301_e

$ H $ 行 $ W $ 列のグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,j) $ と表します。 グリッドの各マスはスタートマス、ゴールマス、空マス、壁マス、お菓子マスのいずれかです。 $ (i,j) $ が何のマスであるかは文字 $ A_{i,j} $ によって表され、$ A_{i,j}= $ `S` のときスタートマス、 $ A_{i,j}= $ `G` のときゴールマス、 $ A_{i,j}= $ `.` のとき空マス、 $ A_{i,j}= $ `#` のとき壁マス、 $ A_{i,j}= $ `o` のときお菓子マスです。 ここで、スタートマスとゴールマスはちょうど $ 1 $ つずつあり、お菓子マスは **$ 18 $ 個以下**であることが保証されます。

高橋くんは現在スタートマスにいます。 高橋くんは、上下左右に隣接するマスであって壁マスでないマスに移動することを繰り返し行えます。 高橋くんは今から $ T $ 回以下の移動によってゴールマスに到達したいです。 そのようなことは可能かどうか判定してください。 可能な場合は、最終的にゴールマスにいるという条件のもとで、移動の途中に訪れるお菓子マスの数の最大値を求めてください。 ただし、$ 1 $ つのお菓子マスに複数回訪れた場合でも、カウントするのは $ 1 $ 回のみです。

## 说明/提示

### 制約

- $ 1\leq\ H,W\ \leq\ 300 $
- $ 1\ \leq\ T\ \leq\ 2\times\ 10^6 $
- $ H,W,T $ は整数
- $ A_{i,j} $ は `S`, `G`, `.`, `#`, `o` のいずれか
- $ A_{i,j}= $ `S` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `G` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `o` を満たす $ (i,j) $ の組は **$ 18 $ 個以下**
 
### Sample Explanation 1

$ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3)\ \rightarrow\ (1,3) $ と $ 4 $ 回移動すると、 $ 1 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることができます。 $ 5 $ 回以下の移動で $ 2 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることはできないので、$ 1 $ が答えです。 なお、$ (1,1)\ \rightarrow\ (2,1)\ \rightarrow\ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3) $ と移動すると $ 5 $ 回の移動で $ 2 $ 個のお菓子マスを訪れることができますが、最終的にゴールマスにいないため無効であることに注意してください。

### Sample Explanation 2

$ 1 $ 回以下の移動でゴールマスに到達することはできません。

## 样例 #1

### 输入

```
3 3 5

S.G

o#o

.#.```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3 1

S.G

.#o

o#.```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G```

### 输出

```
18```

# AI分析结果

### 题目重写

#### [ABC301E] Pac-Takahashi

**题目描述**

给定一个 $H$ 行 $W$ 列的网格。从上到下第 $i$ 行，从左到右第 $j$ 列的格子记为 $(i,j)$。网格中的每个格子可能是起点、终点、空地、墙壁或糖果。$(i,j)$ 的格子类型由字符 $A_{i,j}$ 表示，$A_{i,j}=$ `S` 表示起点，$A_{i,j}=$ `G` 表示终点，$A_{i,j}=$ `.` 表示空地，$A_{i,j}=$ `#` 表示墙壁，$A_{i,j}=$ `o` 表示糖果。起点和终点各有一个，糖果的数量不超过 $18$ 个。

高桥君从起点出发，每次可以移动到上下左右相邻的非墙壁格子。他希望在不超过 $T$ 次移动的情况下到达终点。如果可能，求在到达终点的前提下，途中经过的糖果的最大数量。每个糖果只计算一次。

**说明/提示**

**约束条件**

- $1 \leq H, W \leq 300$
- $1 \leq T \leq 2 \times 10^6$
- $H, W, T$ 是整数
- $A_{i,j}$ 是 `S`, `G`, `.`, `#`, `o` 之一
- 起点和终点各有一个
- 糖果的数量不超过 $18$ 个

**样例解释**

**样例 1**

输入：
```
3 3 5

S.G

o#o

.#.
```
输出：
```
1
```

**样例 2**

输入：
```
3 3 1

S.G

.#o

o#.
```
输出：
```
-1
```

**样例 3**

输入：
```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G
```
输出：
```
18
```

### 题解分析与结论

#### 综合分析

这道题的核心在于如何在给定的步数限制内，从起点出发到达终点，并尽可能多地经过糖果。由于糖果的数量最多为 $18$ 个，且网格大小较大，直接进行搜索或动态规划会超时。因此，大多数题解都采用了以下思路：

1. **预处理距离**：使用 BFS 预处理所有关键点（起点、终点、糖果）之间的最短距离。
2. **状态压缩动态规划**：利用状态压缩 DP 来枚举所有可能的糖果收集顺序，计算在步数限制内的最大糖果数量。

#### 最优思路与技巧

1. **BFS 预处理**：通过 BFS 计算所有关键点之间的最短距离，避免了在 DP 过程中重复计算。
2. **状态压缩 DP**：使用二进制状态表示哪些糖果已经被收集，通过 DP 状态转移来枚举所有可能的路径。
3. **剪枝优化**：在 DP 过程中，通过剪枝减少不必要的计算，例如提前判断某些状态是否可能达到最优解。

#### 推荐题解

1. **作者：DengDuck (赞：9)**
   - **星级：5**
   - **关键亮点**：思路清晰，代码结构良好，详细解释了 BFS 预处理和状态压缩 DP 的实现过程。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=cnt;i++) {
         for(int j=i+1;j<=cnt;j++) {
             dis[i][j]=dis[j][i]=work(i,j);
         }
     }
     memset(f,127,sizeof(f));
     f[cnt-1][1<<(cnt-2)]=0;
     for(int i=(1<<(cnt-2));i<=(1<<cnt)-1;i++) {
         for(int j=1;j<=cnt;j++) {
             if(((i>>(j-1))&1)==0)continue;
             for(int k=1;k<=cnt;k++) {
                 f[k][i|(1<<(k-1))]=min(f[k][i|(1<<(k-1))],f[j][i]+dis[j][k]);
             }
         }
     }
     ```

2. **作者：Kylin_ZHH (赞：5)**
   - **星级：4**
   - **关键亮点**：代码简洁，使用了 BFS 和状态压缩 DP，思路清晰。
   - **代码核心**：
     ```cpp
     for(int i=0;i<=cnt;++i){
         for(int j=0;j<(1<<cnt+1);++j){
             f[i][j]=INF;
         }
     }
     f[0][1]=0;
     for(int s=0;s<(1<<cnt+1);++s){
         for(int i=0;i<=cnt;++i){
             if(f[i][s]<=k){
                 for(int j=0;j<=cnt;++j){
                     f[j][s|(1<<j)]=min(f[j][s|(1<<j)],f[i][s]+d[i][j]);
                 }
             }
         }
     }
     ```

3. **作者：sunzz3183 (赞：5)**
   - **星级：4**
   - **关键亮点**：详细解释了状态压缩 DP 的实现过程，代码结构清晰。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=cnt;i++)
         bfs(i);
     memset(f,0x3f,sizeof(f));
     f[0][0]=0;
     for(int i=1;i<=cnt;i++)f[1<<(i-1)][i]=e[0][i];
     for(int i=1;i<1<<cnt;i++)
         vt[getsum(i)].push_back(i);
     for(int szz=1;szz<=cnt;szz++)
     for(int cyl=0;cyl<vt[szz].size();cyl++){
         int i=vt[szz][cyl];
         for(int j=1;j<=cnt;j++)
             if((i>>(j-1)&1)&&f[i][j]<inf)
                 for(int l=1;l<=cnt;l++)
                     if((!(i>>(l-1)&1))&&(e[j][l]<inf))
                         f[i|(1<<(l-1))][l]=min(f[i|(1<<(l-1))][l],f[i][j]+e[j][l]);
     }
     ```

### 关键代码实现

以 **DengDuck** 的题解为例，核心代码片段如下：

```cpp
for(int i=1;i<=cnt;i++) {
    for(int j=i+1;j<=cnt;j++) {
        dis[i][j]=dis[j][i]=work(i,j);
    }
}
memset(f,127,sizeof(f));
f[cnt-1][1<<(cnt-2)]=0;
for(int i=(1<<(cnt-2));i<=(1<<cnt)-1;i++) {
    for(int j=1;j<=cnt;j++) {
        if(((i>>(j-1))&1)==0)continue;
        for(int k=1;k<=cnt;k++) {
            f[k][i|(1<<(k-1))]=min(f[k][i|(1<<(k-1))],f[j][i]+dis[j][k]);
        }
    }
}
```

**核心思想**：通过 BFS 预处理所有关键点之间的最短距离，然后使用状态压缩 DP 枚举所有可能的路径，计算在步数限制内的最大糖果数量。

### 扩展思路与推荐题目

1. **扩展思路**：本题的状态压缩 DP 和 BFS 预处理技巧可以应用于其他类似的路径规划问题，尤其是当关键点数量较少时。
2. **推荐题目**：
   - [P2831 愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)：状态压缩 DP 的应用。
   - [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)：状态压缩 DP 与图论结合。
   - [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：状态压缩 DP 与路径规划。

### 个人心得摘录

- **DengDuck**：通过 BFS 预处理距离，避免了在 DP 过程中重复计算，大大提高了效率。
- **Kylin_ZHH**：状态压缩 DP 的剪枝优化是关键，减少了不必要的计算，使得算法能够在时间限制内完成。

这些心得强调了预处理和剪枝在算法优化中的重要性，值得在实际编程中加以应用。

---
处理用时：68.08秒
# 题目信息

# [AGC041B] Voting Judges

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc041/tasks/agc041_b

あるコンテストの開催に向けて $ N $ 問の問題が提案されました。はじめ、問題 $ i $ のスコアは整数 $ A_i $ です。

これから、$ M $ 人のジャッジが好きな問題に投票します。各ジャッジは、他のジャッジとは独立にちょうど $ V $ 問を選び、それらの問題のスコアを $ 1 $ ずつ上げます。

$ M $ 人のジャッジ全員が投票を行ったあと、$ N $ 問の問題がスコアの降順に並べられ、最初の $ P $ 問がコンテストの問題セットに採用されます。 同スコアの問題間の順序は、ジャッジ長が任意に決定します。

$ N $ 問のうち、問題セットに採用される可能性を持つ問題は何問あるでしょうか？

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 10^5 $
- $ 1\ \le\ M\ \le\ 10^9 $
- $ 1\ \le\ V\ \le\ N\ -\ 1 $
- $ 1\ \le\ P\ \le\ N\ -\ 1 $
- $ 0\ \le\ A_i\ \le\ 10^9 $

### Sample Explanation 1

$ 1 $ 人しかいないジャッジが問題 $ 2,5 $ に投票した場合、各問のスコアは $ 2 $ $ 2 $ $ 1 $ $ 3 $ $ 1 $ $ 2 $ となり、問題 $ 4 $、そして問題 $ 1,2,6 $ のうちの $ 1 $ 問が採用されます。 ジャッジが問題 $ 3,4 $ に投票した場合、各問のスコアは $ 2 $ $ 1 $ $ 2 $ $ 4 $ $ 0 $ $ 2 $ となり、問題 $ 4 $、そして問題 $ 1,3,6 $ のうちの $ 1 $ 問が採用されます。 よって、問題 $ 1,2,3,4,6 $ には採用される可能性があります。一方で、問題 $ 5 $ には採用される可能性はありません。

### Sample Explanation 2

採用される可能性があるのは問題 $ 1,4,6 $ のみです。

## 样例 #1

### 输入

```
6 1 2 2

2 1 1 3 0 2```

### 输出

```
5```

## 样例 #2

### 输入

```
6 1 5 2

2 1 1 3 0 2```

### 输出

```
3```

## 样例 #3

### 输入

```
10 4 8 5

7 2 3 6 1 6 5 4 6 5```

### 输出

```
8```

# AI分析结果

### 题目翻译
在一场即将举办的比赛中，共提出了 $N$ 道题目。最初，第 $i$ 道题目的分数是整数 $A_i$。

接下来，$M$ 名评委将对他们喜欢的题目进行投票。每名评委独立地选择恰好 $V$ 道题目，并将这些题目的分数各加 $1$。

在 $M$ 名评委全部投票结束后，$N$ 道题目将按照分数从高到低排序，排名前 $P$ 的题目将被选入比赛题目集。分数相同的题目之间的顺序由裁判长任意决定。

那么，在这 $N$ 道题目中，有多少道题目有被选入题目集的可能性呢？

### 综合分析与结论
- **思路对比**：两位作者思路基本一致，都先对数组从大到小排序，确定前 $P$ 位的题目肯定能入选，再对 $P$ 位之后的题目进行判断，考虑让其尽可能争取第 $P$ 个位置的最优投票方案。
- **算法要点**：都是通过遍历 $P$ 位之后的题目，根据条件判断是否能入选，关键在于计算剩余投票机会的分配以及判断是否能超过第 $P$ 位的分数。
- **解决难点**：核心难点在于如何合理分配投票机会，判断 $P$ 位之后的题目是否有机会进入前 $P$ 名。两位作者都采用了先给前面 $P - 1$ 位和当前判断的题目投票，再处理剩余投票机会的策略。

### 题解评分
- **123456zmy**：4星。思路清晰，代码简洁，关键步骤有注释，能较好地实现算法。
- **Erica_N_Contina**：3星。思路解释详细，但代码中定义了较多不必要的常量，影响代码简洁性。

### 所选题解
- **123456zmy（4星）**：
  - **关键亮点**：思路清晰，代码简洁，直接实现了核心算法。

### 重点代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,v,p,a[100001],ans,a1;
bool cmp(int i,int j){return i>j;}
signed main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&v,&p);
    ans=p;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    sort(a+1,a+n+1,cmp);
    for(int i=p+1;i<=n;i++)
    {
        if(a[i]+m<a[p])break;
        if(v<=p+n-i)++ans;
        else if(((v-p-n+i)*m-a1-1)/(i-p)+1+a[p]<=a[i]+m)++ans;
        a1+=a[p]-a[i];
    }
    printf("%lld",ans);
    return 0;
 } 
```
**核心实现思想**：先读取输入，对数组排序，前 $P$ 位题目肯定入选。然后遍历 $P$ 位之后的题目，若加上 $m$ 次投票都赶不上第 $P$ 位的分数则直接跳出；若剩余投票机会能合理分配使得该题目能进入前 $P$ 名则入选。

### 最优关键思路或技巧
- **排序预处理**：先对数组从大到小排序，方便后续处理。
- **贪心策略**：对于 $P$ 位之后的题目，采用每次优先给前面 $P - 1$ 位和当前题目投票，再处理剩余投票机会的贪心策略。

### 可拓展之处
同类型题目可能会改变投票规则或题目入选规则，类似算法套路是先对数据进行排序，再根据规则采用贪心或动态规划的方法进行处理。

### 洛谷相似题目推荐
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得
两位作者均未在题解中包含个人心得。

---
处理用时：26.49秒
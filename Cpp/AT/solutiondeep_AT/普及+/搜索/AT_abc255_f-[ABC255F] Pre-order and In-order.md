# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个编号为 $1, 2, \ldots, N$ 的 $N$ 个节点的**二叉树**。二叉树是指每个节点最多有两个子节点的有根树。更具体地说，二叉树的每个节点最多有一个**左子节点**和一个**右子节点**。

给定一个以节点 $1$ 为根的二叉树，判断是否存在满足以下条件的二叉树，如果存在，请输出一个满足条件的二叉树。

- 所有节点的**前序遍历**（pre-order）序列为 $(P_1, P_2, \ldots, P_N)$。
- 所有节点的**中序遍历**（in-order）序列为 $(I_1, I_2, \ldots, I_N)$。

【说明/提示】

### 约束条件

- $2 \leq N \leq 2 \times 10^5$
- $N$ 是整数
- $(P_1, P_2, \ldots, P_N)$ 是 $(1, 2, \ldots, N)$ 的一个排列
- $(I_1, I_2, \ldots, I_N)$ 是 $(1, 2, \ldots, N)$ 的一个排列

### 样例解释 1

下图所示的以节点 $1$ 为根的二叉树满足题目中的条件。

![示例图](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### 样例解释 2

不存在满足条件的以节点 $1$ 为根的二叉树，因此输出 $-1$。

### 样例 #1

#### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2
```

#### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2
```

### 样例 #2

#### 输入

```
2
2 1
1 2
```

#### 输出

```
-1
```

---

### 题解综合分析

本题的核心是通过前序遍历和中序遍历来重建二叉树，并判断是否存在满足条件的二叉树。所有题解都采用了递归的思路，利用前序遍历确定根节点，再通过中序遍历划分左右子树。难点在于如何处理无解情况以及如何高效地找到根节点在中序遍历中的位置。

### 精选题解

#### 1. 作者：program_xwl (★★★★☆)
**关键亮点**：
- 通过递归实现二叉树的构建，代码简洁明了。
- 使用 `mp` 数组记录中序遍历中每个节点的位置，避免了在中序遍历中查找根节点的线性时间复杂度。
- 无解情况的处理清晰，包括前序遍历的第一个节点不为 $1$ 的情况。

**核心代码**：
```cpp
void dfs(int l1, int r1, int l2, int r2) {
    if (l1 >= r1) return;
    int root = mp[a[l1]], sizl = root - l2, sizr = r2 - root;
    if (root < l2 || root > r2) {
        cout << -1;
        exit(0);
    }
    tree[a[l1]] = {a[l1 + 1], a[l1 + sizl + 1]};
    if (sizl == 0) tree[a[l1]].l = 0;
    if (sizr == 0) tree[a[l1]].r = 0;
    dfs(l1 + 1, l1 + sizl, l2, root - 1);
    dfs(l1 + sizl + 1, r1, root + 1, r2);
}
```

#### 2. 作者：Tsawke (★★★★☆)
**关键亮点**：
- 递归参数设计合理，清晰地表示了当前子树在前序和中序遍历中的区间。
- 无解情况的处理包括根节点不为 $1$ 和根节点在中序遍历中的位置超出当前区间的情况。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
int dfs(int lp = 1, int rp = N, int li = 1, int ri = N) {
    if (lp > rp) return 0;
    int rt = Pre[lp];
    if (posI[rt] < li || posI[rt] > ri) puts("-1"), exit(0);
    if (lp == rp) return rt;
    int lsiz = (posI[rt] - 1) - li + 1;
    son[rt].first = dfs(lp + 1, lp + lsiz, li, posI[rt] - 1);
    son[rt].second = dfs(lp + lsiz + 1, rp, posI[rt] + 1, ri);
    return rt;
}
```

#### 3. 作者：ATION001 (★★★★☆)
**关键亮点**：
- 递归实现简洁，无解情况处理得当。
- 使用 `mp` 数组记录中序遍历中每个节点的位置，提高了查找效率。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
int dfs(int l1, int r1, int l2, int r2) {
    if (l1 > r1) return 0;
    int P = mp[qian[l1]];
    if (P < l2 || P > r2) {
        cout << -1;
        exit(0);
    }
    l[qian[l1]] = dfs(l1 + 1, l1 + (P - l2), l2, P - 1);
    r[qian[l1]] = dfs(l1 + (P - l2) + 1, r1, P + 1, r2);
    return qian[l1];
}
```

### 最优关键思路与技巧

1. **递归构建二叉树**：通过前序遍历确定根节点，再通过中序遍历划分左右子树，递归处理左右子树。
2. **无解情况处理**：包括前序遍历的第一个节点不为 $1$，以及根节点在中序遍历中的位置超出当前区间的情况。
3. **高效查找根节点位置**：使用数组记录中序遍历中每个节点的位置，避免线性查找，提高效率。

### 可拓展之处

- **类似问题**：可以通过后序遍历和中序遍历重建二叉树，思路类似，只是根节点的位置在后序遍历的末尾。
- **其他应用**：类似思路可以用于解决其他树结构的问题，如多叉树的遍历与重建。

### 推荐题目

1. [P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030)
2. [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)
3. [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)

### 个人心得总结

- **调试经历**：在处理无解情况时，容易忽略根节点在中序遍历中的位置超出当前区间的情况，导致程序错误。
- **踩坑教训**：在中序遍历中查找根节点时，如果使用线性查找，会导致时间复杂度增加，应使用数组记录位置以提高效率。
- **顿悟感想**：递归是解决树结构问题的有力工具，合理设计递归参数和边界条件可以大大简化问题。

---
处理用时：49.76秒
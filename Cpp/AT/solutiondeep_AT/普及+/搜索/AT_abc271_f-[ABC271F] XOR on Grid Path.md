# 题目信息

# [ABC271F] XOR on Grid Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc271/tasks/abc271_f

$ N $ 行 $ N $ 列のマス目があり、上から $ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 行目、左から $ j\ \,\ (1\ \leq\ j\ \leq\ N) $ 列目のマスを $ (i,\ j) $ と表します。  
 マス $ (i,\ j) $ には非負整数 $ a_{i,\ j} $ が書かれています。

マス $ (i,\ j) $ にいるとき、マス $ (i+1,\ j),\ (i,\ j+1) $ のいずれかに移動することができます。ただし、マス目の外に出るような移動はできません。

マス $ (1,\ 1) $ から移動を繰り返してマス $ (N,\ N) $ にたどり着く方法であって、通ったマス（マス $ (1,\ 1),\ (N,\ N) $ を含む）に書かれた整数の排他的論理和が $ 0 $ となるようなものの総数を求めてください。

 排他的論理和とは 整数 $ a,\ b $ の排他的論理和 $ a\ \oplus\ b $ は、以下のように定義されます。 - $ a\ \oplus\ b $ を二進表記した際の $ 2^k\ \,\ (k\ \geq\ 0) $ の位の数は、$ a,\ b $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。

 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります（二進表記すると $ 011\ \oplus\ 101\ =\ 110 $）。  
 一般に $ k $ 個の整数 $ p_1,\ \dots,\ p_k $ の排他的論理和は $ (\cdots\ ((p_1\ \oplus\ p_2)\ \oplus\ p_3)\ \oplus\ \cdots\ \oplus\ p_k) $ と定義され、これは $ p_1,\ \dots,\ p_k $ の順番によらないことが証明できます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 20 $
- $ 0\ \leq\ a_{i,\ j}\ \lt\ 2^{30}\ \,\ (1\ \leq\ i,\ j\ \leq\ N) $
- 入力は全て整数

### Sample Explanation 1

次の二通りの方法が条件を満たします。 - $ (1,\ 1)\ \rightarrow\ (1,\ 2)\ \rightarrow\ (1,\ 3)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3) $ - $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3) $

## 样例 #1

### 输入

```
3

1 5 2

7 0 5

4 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
2

1 2

2 1```

### 输出

```
0```

## 样例 #3

### 输入

```
10

1 0 1 0 0 1 0 0 0 1

0 0 0 1 0 1 0 1 1 0

1 0 0 0 1 0 1 0 0 0

0 1 0 0 0 1 1 0 0 1

0 0 1 1 0 1 1 0 1 0

1 0 0 0 1 0 0 1 1 0

1 1 1 0 0 0 1 1 0 0

0 1 1 0 0 1 1 0 1 0

1 0 1 1 0 0 0 0 0 0

1 0 1 1 0 0 1 1 1 0```

### 输出

```
24307```

# AI分析结果

### 题目内容重写

**题目描述**

有一个 $N$ 行 $N$ 列的网格，从上到下第 $i$ 行、从左到右第 $j$ 列的格子记为 $(i, j)$。每个格子 $(i, j)$ 上写有一个非负整数 $a_{i, j}$。

从格子 $(i, j)$ 出发，可以移动到 $(i+1, j)$ 或 $(i, j+1)$，但不能移动到网格外。

从 $(1, 1)$ 出发，经过若干次移动到达 $(N, N)$，求所有路径中，经过的格子上的整数异或和为 $0$ 的路径数量。

**说明/提示**

- 异或和的定义：$a \oplus b$ 表示 $a$ 和 $b$ 的二进制位逐位异或，结果为 $1$ 当且仅当对应位不同。
- 例如，$3 \oplus 5 = 6$（二进制：$011 \oplus 101 = 110$）。
- 一般地，$k$ 个整数的异或和定义为 $((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k$，且与顺序无关。

**约束**

- $2 \leq N \leq 20$
- $0 \leq a_{i, j} < 2^{30}$（$1 \leq i, j \leq N$）
- 输入均为整数

**样例解释**

样例1中有两条路径满足条件：
1. $(1,1) \rightarrow (1,2) \rightarrow (1,3) \rightarrow (2,3) \rightarrow (3,3)$
2. $(1,1) \rightarrow (2,1) \rightarrow (2,2) \rightarrow (2,3) \rightarrow (3,3)$

### 题解分析与结论

#### 综合分析

本题的核心是计算从 $(1,1)$ 到 $(N,N)$ 的所有路径中，异或和为 $0$ 的路径数量。由于 $N$ 的最大值为 $20$，直接暴力搜索的复杂度为 $O(2^{2n})$，无法通过。因此，大多数题解采用了 **Meet in the Middle** 的优化策略，将搜索过程分为两部分：从起点 $(1,1)$ 出发，搜索到对角线；从终点 $(N,N)$ 出发，搜索到对角线，并在对角线处合并结果。这种方法将复杂度降低到 $O(2^n)$，显著提高了效率。

#### 最优关键思路

1. **Meet in the Middle**：将搜索过程分为两部分，分别从起点和终点出发，搜索到对角线，并在对角线处合并结果。
2. **异或性质**：利用 $x \oplus x = 0$ 的性质，将两条异或和相等的路径合并为一条异或和为 $0$ 的路径。
3. **数据结构**：使用 `map` 或 `unordered_map` 来存储和查询路径的异或和，确保查询效率。

#### 推荐题解

1. **作者：Felix72 (赞：6)**  
   **星级：5**  
   **关键亮点**：  
   - 清晰地解释了 Meet in the Middle 的思路，并提供了简洁的代码实现。
   - 使用 `map` 存储路径的异或和，确保查询效率。
   - 代码结构清晰，易于理解。

   **核心代码**：
   ```cpp
   void dfs1(long long x, long long y, long long cur) {
       cur = cur ^ a[x][y];
       if(x + y == n + 1) {
           ++mp[{{x, y}, cur}];
           return ;
       }
       dfs1(x + 1, y, cur);
       dfs1(x, y + 1, cur);
   }

   void dfs2(long long x, long long y, long long cur) {
       if(x + y == n + 1) {
           ans += mp[{{x, y}, cur}];
           return ;
       }
       cur = cur ^ a[x][y];
       dfs2(x - 1, y, cur);
       dfs2(x, y - 1, cur);
   }
   ```

2. **作者：翼德天尊 (赞：3)**  
   **星级：4**  
   **关键亮点**：  
   - 详细解释了 Meet in the Middle 的原理，并提供了具体的实现细节。
   - 使用 `map` 存储路径的异或和，确保查询效率。
   - 代码结构清晰，易于理解。

   **核心代码**：
   ```cpp
   void dfs1(int x, int y, int now) {
       if (x + y == n) {
           ma[x][now]++;
           return;
       }
       dfs1(x + 1, y, now ^ a[x + 1][y]);
       dfs1(x, y + 1, now ^ a[x][y + 1]);
   }

   void dfs2(int x, int y, int now) {
       if (x + y == n) {
           ans += ma[x][now];
           return;
       }
       dfs2(x - 1, y, now ^ a[x][y]);
       dfs2(x, y - 1, now ^ a[x][y]);
   }
   ```

3. **作者：xiaoPanda (赞：0)**  
   **星级：4**  
   **关键亮点**：  
   - 清晰地解释了 Meet in the Middle 的思路，并提供了简洁的代码实现。
   - 使用 `map` 存储路径的异或和，确保查询效率。
   - 代码结构清晰，易于理解。

   **核心代码**：
   ```cpp
   void dfs1(int x, int y, int v) {
       v ^= a[x][y];
       if(x + y == n + 1) return p[x][y][v]++, void();
       if(x <= n) dfs1(x + 1, y, v);
       if(y <= n) dfs1(x, y + 1, v);
   }

   void dfs2(int x, int y, int v) {
       if(x + y == n + 1) return ans += p[x][y][v], void();
       v ^= a[x][y];
       if(x >= 1) dfs2(x - 1, y, v);
       if(y >= 1) dfs2(x, y - 1, v);
   }
   ```

### 扩展思路与推荐题目

#### 扩展思路

- **类似算法套路**：Meet in the Middle 不仅适用于路径搜索问题，还可以用于其他需要减少搜索空间的问题，如子集和问题、排列组合问题等。
- **数据结构优化**：在处理大规模数据时，可以考虑使用更高效的数据结构（如 `unordered_map`）来进一步优化查询效率。

#### 推荐题目

1. **洛谷 P1074 靶形数独**（难度：提高+/省选-）  
   **知识点**：DFS、剪枝、Meet in the Middle

2. **洛谷 P1092 虫食算**（难度：提高+/省选-）  
   **知识点**：DFS、剪枝、Meet in the Middle

3. **洛谷 P1379 八数码难题**（难度：提高+/省选-）  
   **知识点**：BFS、状态压缩、Meet in the Middle

---
处理用时：58.62秒
# 题目信息

# [ABC301E] Pac-Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc301/tasks/abc301_e

$ H $ 行 $ W $ 列のグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,j) $ と表します。 グリッドの各マスはスタートマス、ゴールマス、空マス、壁マス、お菓子マスのいずれかです。 $ (i,j) $ が何のマスであるかは文字 $ A_{i,j} $ によって表され、$ A_{i,j}= $ `S` のときスタートマス、 $ A_{i,j}= $ `G` のときゴールマス、 $ A_{i,j}= $ `.` のとき空マス、 $ A_{i,j}= $ `#` のとき壁マス、 $ A_{i,j}= $ `o` のときお菓子マスです。 ここで、スタートマスとゴールマスはちょうど $ 1 $ つずつあり、お菓子マスは **$ 18 $ 個以下**であることが保証されます。

高橋くんは現在スタートマスにいます。 高橋くんは、上下左右に隣接するマスであって壁マスでないマスに移動することを繰り返し行えます。 高橋くんは今から $ T $ 回以下の移動によってゴールマスに到達したいです。 そのようなことは可能かどうか判定してください。 可能な場合は、最終的にゴールマスにいるという条件のもとで、移動の途中に訪れるお菓子マスの数の最大値を求めてください。 ただし、$ 1 $ つのお菓子マスに複数回訪れた場合でも、カウントするのは $ 1 $ 回のみです。

## 说明/提示

### 制約

- $ 1\leq\ H,W\ \leq\ 300 $
- $ 1\ \leq\ T\ \leq\ 2\times\ 10^6 $
- $ H,W,T $ は整数
- $ A_{i,j} $ は `S`, `G`, `.`, `#`, `o` のいずれか
- $ A_{i,j}= $ `S` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `G` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `o` を満たす $ (i,j) $ の組は **$ 18 $ 個以下**
 
### Sample Explanation 1

$ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3)\ \rightarrow\ (1,3) $ と $ 4 $ 回移動すると、 $ 1 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることができます。 $ 5 $ 回以下の移動で $ 2 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることはできないので、$ 1 $ が答えです。 なお、$ (1,1)\ \rightarrow\ (2,1)\ \rightarrow\ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3) $ と移動すると $ 5 $ 回の移動で $ 2 $ 個のお菓子マスを訪れることができますが、最終的にゴールマスにいないため無効であることに注意してください。

### Sample Explanation 2

$ 1 $ 回以下の移動でゴールマスに到達することはできません。

## 样例 #1

### 输入

```
3 3 5

S.G

o#o

.#.```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3 1

S.G

.#o

o#.```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G```

### 输出

```
18```

# AI分析结果

### 题目内容重写

#### [ABC301E] Pac-Takahashi

**题目描述**

有一个 $H$ 行 $W$ 列的网格。从上到下第 $i$ 行、从左到右第 $j$ 列的格子用 $(i,j)$ 表示。网格中的每个格子可能是起点、终点、空地、墙壁或糖果。$(i,j)$ 的格子类型由字符 $A_{i,j}$ 表示，$A_{i,j}=$ `S` 表示起点，$A_{i,j}=$ `G` 表示终点，$A_{i,j}=$ `.` 表示空地，$A_{i,j}=$ `#` 表示墙壁，$A_{i,j}=$ `o` 表示糖果。起点和终点各有一个，糖果的数量不超过 $18$ 个。

高桥君现在位于起点。他可以通过上下左右移动，每次移动到相邻的非墙壁格子。高桥君希望在不超过 $T$ 次移动的情况下到达终点。请判断是否可能，如果可能，求在最终到达终点的条件下，途中经过的糖果数量的最大值。注意，即使多次经过同一个糖果，也只计数一次。

**说明/提示**

**约束条件**

- $1 \leq H, W \leq 300$
- $1 \leq T \leq 2 \times 10^6$
- $H, W, T$ 是整数
- $A_{i,j}$ 是 `S`, `G`, `.`, `#`, `o` 之一
- 存在唯一一个 $(i,j)$ 满足 $A_{i,j}=$ `S`
- 存在唯一一个 $(i,j)$ 满足 $A_{i,j}=$ `G`
- 满足 $A_{i,j}=$ `o` 的 $(i,j)$ 不超过 $18$ 个

**样例解释**

**样例 1**

输入：

```
3 3 5

S.G

o#o

.#.
```

输出：

```
1
```

解释：$(1,1) \rightarrow (1,2) \rightarrow (1,3) \rightarrow (2,3) \rightarrow (1,3)$，经过 4 次移动，最终到达终点，途中经过 1 个糖果。

**样例 2**

输入：

```
3 3 1

S.G

.#o

o#.
```

输出：

```
-1
```

解释：无法在 1 次移动内到达终点。

**样例 3**

输入：

```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G
```

输出：

```
18
```

### 题解分析与结论

#### 综合分析

本题的核心在于如何在给定的步数限制内，从起点到达终点，并尽可能多地经过糖果。由于糖果的数量最多为 18 个，且网格的大小为 300x300，直接暴力搜索是不可行的。因此，大多数题解采用了以下思路：

1. **预处理距离**：通过 BFS 预处理所有关键点（起点、终点、糖果）之间的最短距离。
2. **状态压缩 DP**：利用状态压缩 DP 来枚举所有可能的糖果访问顺序，计算在步数限制内能否到达终点，并记录最大糖果数。

#### 最优思路与技巧

1. **预处理距离**：通过 BFS 预处理所有关键点之间的最短距离，减少后续计算的复杂度。
2. **状态压缩 DP**：利用状态压缩 DP 来枚举所有可能的糖果访问顺序，结合预处理的距离信息，计算在步数限制内能否到达终点，并记录最大糖果数。
3. **剪枝优化**：在 DP 过程中，通过剪枝减少不必要的计算，提高算法效率。

#### 推荐题目

1. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)：类似的状态压缩 DP 问题，要求在一定步数内吃掉所有奶酪。
2. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)：经典的旅行商问题，要求找到最短路径。
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)：通过 DP 解决树形结构中的最优问题。

### 所选高分题解

#### 题解1：作者：DengDuck (5星)

**关键亮点**：
- 使用 BFS 预处理所有关键点之间的最短距离。
- 利用状态压缩 DP 枚举所有可能的糖果访问顺序，计算在步数限制内能否到达终点，并记录最大糖果数。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
LL work(LL i,LL j)//求距离
{
    LL sx=pt[i].XX,sy=pt[i].YY,ex=pt[j].XX,ey=pt[j].YY;
    while(!q.empty())q.pop();
    q.push({sx,sy,0});
    memset(vis,0,sizeof(vis));
    while(!q.empty())
    {
        LL tx=q.front().x,ty=q.front().y,num=q.front().num;
        q.pop();
        for(int i=0;i<4;i++)
        {
            LL xx=tx+dx[i],yy=ty+dy[i];
            if(xx<1||n<xx||yy<1||m<yy||a[xx][yy]==1||vis[xx][yy]==1)continue;
            vis[xx][yy]=1;
            q.push({xx,yy,num+1});
            if(xx==ex&&yy==ey)return num+1;
        }
    }
    return INT_MAX;
}
```

#### 题解2：作者：Kylin_ZHH (4星)

**关键亮点**：
- 使用 BFS 预处理所有关键点之间的最短距离。
- 利用位 DP 解决旅行商问题，计算在步数限制内能否到达终点，并记录最大糖果数。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
int bfs(int sx,int sy,int tx,int ty) {
    memset(d, 0, sizeof d);
    d[sx][sy] = 1;
    static PII f[4] = {{1,0},{0,1},{-1,0},{0,-1}}; 
    queue<PII> q;
    q.push({sx,sy});
    
    while(!q.empty()) {
        auto u = q.front(); q.pop();
        for(const auto& p:f) {
            int nx = u[0] + p[0], ny = u[1] + p[1];
            if(!valid(nx,ny) || d[nx][ny]) continue;
            d[nx][ny] = d[u[0]][u[1]] + 1;
            if(nx==tx && ny==ty) return d[tx][ty] - 1; 
            q.push({nx, ny});
        }
    }
    return 1e7;
}
```

#### 题解3：作者：sunzz3183 (4星)

**关键亮点**：
- 使用 BFS 预处理所有关键点之间的最短距离。
- 利用状态压缩 DP 枚举所有可能的糖果访问顺序，计算在步数限制内能否到达终点，并记录最大糖果数。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
void bfs(int id){
    e[id][id]=0;
    memset(vis,0,sizeof(vis));
    vis[a[id].x][a[id].y]=1;
    q.push({a[id].x,a[id].y,0});
    while(!q.empty()){
        int x=q.front().x,y=q.front().y,w=q.front().w;q.pop();
        for(int i=0;i<4;i++){
            int tx=x+nxt[i][0],ty=y+nxt[i][1];
            if(tx<1||tx>n||ty<1||ty>m)continue;
            if(c[tx][ty]=='#')continue;
            if(vis[tx][ty])continue;
            vis[tx][ty]=1;
            if(pos[tx][ty]>=0)e[id][pos[tx][ty]]=w+1;
            q.push({tx,ty,w+1});
        }
    }
    return;
}
```

### 总结

本题的核心思路是通过 BFS 预处理所有关键点之间的最短距离，然后利用状态压缩 DP 枚举所有可能的糖果访问顺序，计算在步数限制内能否到达终点，并记录最大糖果数。这种方法在处理类似问题时具有较高的效率和通用性。

---
处理用时：65.76秒
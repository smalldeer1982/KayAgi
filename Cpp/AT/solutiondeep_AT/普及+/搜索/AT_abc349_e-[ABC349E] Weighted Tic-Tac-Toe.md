# 题目信息

# [ABC349E] Weighted Tic-Tac-Toe

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc349/tasks/abc349_e

$ 3\ \times\ 3 $ のマス目があります。上から $ i $ 行目、左から $ j $ 列目 $ (1\ \leq\ i,j\ \leq\ 3) $ のマスをマス $ (i,j) $ と表します。マス $ (i,j) $ には整数 $ A_{i,j} $ が書かれています。ここで、 $ \sum_{i=1}^3\ \sum_{j=1}^3\ A_{i,j} $ は奇数であることが保証されます。また、すべてのマスははじめ白で塗られています。

高橋君と青木君が、このマス目を使ってゲームを行います。ゲームでは、高橋君を先手として、二人が交互に以下の操作を行います。

- 白で塗られているマス $ (i,j)\,(1\leq\ i,j\ \leq\ 3) $ を選ぶ（操作が行われる時点で、そのようなマスは必ず存在することが示せる）。操作をしているプレイヤーが得点 $ A_{i,j} $ を得る。次に、操作をしているプレイヤーが高橋君ならば、マス $ (i,j) $ を赤で、青木君ならば青で塗る。
 
各操作のあと、次の判定を行います。

- 赤または青の同じ色で塗られたマスが縦・横・斜めのいずれかの方向に $ 3 $ つ連続する箇所があるか判定する。そのような箇所があれば、その時点でゲームを終了し、赤が $ 3 $ つ連続しているならば高橋君が、青が $ 3 $ つ連続しているならば青木君が勝利する。
- 白で塗られているマスが存在するか判定する。存在しなければ、その時点でゲームを終了し、その時点までに獲得した累計の得点が高い方のプレイヤーが勝利する。
 
ゲームは必ず有限回の操作で終了し、高橋君または青木君の一方が勝利することが示せます。両者が勝ちを目指して最適に行動するとき、どちらが勝つか判定してください。

## 说明/提示

### 制約

- $ |A_{i,j}|\ \leq\ 10^9 $
- $ \sum_{i=1}^3\ \sum_{j=1}^3\ A_{i,j} $ は奇数
- 入力はすべて整数
 
### Sample Explanation 1

高橋君が最初の手番で $ (2,2) $ を選択すると、その後どのように青木君が行動しても、高橋君が適切に行動することで、青で塗られたマスが $ 3 $ つ連続しないようにすることができます。赤で塗られたマスが $ 3 $ つ連続した場合は高橋君が勝ちます。赤で塗られたマスが $ 3 $ つ連続せずにゲームが終了した場合、その時点で高橋君は $ 1 $ 点、青木君は $ 0 $ 点を獲得しているため、どちらにせよ高橋君が勝ちます。

## 样例 #1

### 输入

```
0 0 0

0 1 0

0 0 0```

### 输出

```
Takahashi```

## 样例 #2

### 输入

```
-1 1 0

-4 -2 -5

-4 -1 -5```

### 输出

```
Aoki```

# AI分析结果

### 题目内容重写（中文）

有一个 $3\times3$ 的网格。$(i,j)$ 表示从顶部数第 $i$ 行、从左数第 $j$ 列的单元格 $(1\le i,j\le 3)$。单元格 $(i,j)$ 包含一个整数 $A_{i,j}$。可以保证 $\sum_{i=1}^3 \sum_{j=1}^3 A_{i,j}$ 是奇数。此外，所有单元格最初都是白色的。

Takahashi 和 Aoki 将使用这个网格进行游戏。Takahashi 先走，他们轮流执行以下操作：

选择一个仍然为白色的单元格 $(i,j)(1\le i,j\le3)$（可以证明这样的单元格在操作时总是存在的）。执行操作的玩家获得 $A_{i,j}$ 分。然后，如果玩家是 Takahashi，他将单元格 $(i,j)$ 涂成红色；如果玩家是 Aoki，他将其涂成蓝色。

每次操作后，都会进行以下检查：

- 检测是否存在三个连续的单元格被涂成相同的颜色（红色或蓝色）在任何行、列或对角线上。如果存在这样的序列，游戏立即结束，并且其颜色形成该序列的玩家获胜。

- 检查是否有白色单元格剩余。如果没有白色单元格剩余，游戏结束，得分较高的玩家获胜。

可以证明游戏将在有限次数的操作后结束，并且 Takahashi 或 Aoki 将获胜。确定如果双方的操作都是最佳的，哪位玩家会获胜。

### 题解综合分析与结论

这道题目是一个典型的博弈论问题，结合了井字棋和加权得分的规则。所有题解的核心思路都是通过深度优先搜索（DFS）来模拟游戏的进行，并在每一步中判断当前玩家是否有必胜策略。由于网格只有 $3\times3$，状态数较少，DFS 是可行的。

#### 关键思路与技巧：
1. **DFS 搜索**：通过递归模拟每一步的选择，并在每一步中判断当前玩家是否有必胜策略。
2. **博弈论思维**：如果当前玩家存在一种选择使得对手必败，则当前玩家必胜；否则，当前玩家必败。
3. **状态回溯**：在 DFS 过程中，每次选择后需要回溯状态，确保不影响后续的选择。
4. **剪枝优化**：在 DFS 中可以提前判断是否已经有三连或是否已经填满，减少不必要的递归。

#### 题解评分与亮点：
1. **Drest 的题解（4星）**
   - **亮点**：代码结构清晰，使用了 `end()` 函数来判断游戏是否结束，逻辑简洁明了。
   - **个人心得**：提醒了不开 `long long` 可能会导致错误，强调了状态回溯的重要性。
   - **核心代码**：
     ```cpp
     bool dfs(bool now, int num1, int num2) {
         int endif = end();
         if (endif != 0) {
             if (endif == 1)  return true;           // 如果先手赢，返回 true
             if (endif == 2)  return false;          // 如果后手赢，返回 false
             if (endif == -1) return num1 > num2;    // 比较双方得分
         }
         if (now) { // 先手在走
             for (int i = 1; i <= 3; i++) {
                 for (int j = 1; j <= 3; j++) {
                     if (vis[i][j] == 0) {
                         vis[i][j] = 1;
                         if (dfs(false, num1 + a[i][j], num2)) {
                             vis[i][j] = 0; // 记得重置状态
                             return true;
                         }
                         vis[i][j] = 0;
                     }
                 }
             }
             return false; // 先手不必牲
         } else { // 后手在走
             for (int i = 1; i <= 3; i++) {
                 for (int j = 1; j <= 3; j++) {
                     if (vis[i][j] == 0) {
                         vis[i][j] = 2;
                         if (!dfs(true, num1, num2 + a[i][j])) {
                             vis[i][j] = 0;
                             return false;
                         }
                         vis[i][j] = 0;
                     }
                 }
             }
             return true; // 先手必胜
         }
         return true; // 防止 linux 系统下 RE
     }
     ```

2. **KSCD_ 的题解（4星）**
   - **亮点**：代码简洁，直接通过 DFS 枚举所有可能的选择，逻辑清晰。
   - **核心代码**：
     ```cpp
     bool dfs(int st, int tak, int aok, int who) {
         int now = st % 2 + 1, la = (st + 1) % 2 + 1;
         if (v[1][1] == la && v[1][2] == la && v[1][3] == la) return 0;
         // ... 其他判断条件
         if (st == 9) return tak > aok;
         for (int i = 1; i <= 3; i++) for (int j = 1; j <= 3; j++) {
             if (v[i][j]) continue;
             v[i][j] = now;
             bool tf = dfs(st + 1, tak + (now == 1) * a[i][j], aok + (now == 2) * a[i][j], 3 - who);
             v[i][j] = 0;
             if (!tf) return true;
         }
         return false;
     }
     ```

3. **CuteChat 的题解（4星）**
   - **亮点**：代码简洁，逻辑清晰，直接通过 DFS 枚举所有可能的选择，并在每一步中判断当前玩家是否有必胜策略。
   - **核心代码**：
     ```cpp
     bool dfs(int x, int y, int s1, int s2) {
         if (p[2][2] && (p[1][1] == p[2][2] && p[2][2] == p[3][3] || p[1][3] == p[2][2] && p[2][2] == p[3][1] || p[2][1] == p[2][2] && p[2][2] == p[2][3] || p[1][2] == p[2][2] && p[2][2] == p[3][2])) return p[2][2] == y;
         if (x > 9) return s1 <= s2;
         bool f = 0;
         for (int i = 1; i <= 3; i++) for (int j = 1; j <= 3; j++) {
             if (!p[i][j]) {
                 p[i][j] = y;
                 f |= !dfs(x + 1, 3 - y, s1 + (y == 1) * a[i][j], s2 + (y == 2) * a[i][j]);
                 p[i][j] = 0;
             }
         }
         return f;
     }
     ```

### 推荐题目
1. [P1005 三子棋](https://www.luogu.com.cn/problem/P1005)
2. [P1043 黑白棋](https://www.luogu.com.cn/problem/P1043)
3. [P1052 井字棋](https://www.luogu.com.cn/problem/P1052)

### 总结
这道题目的核心在于通过 DFS 模拟游戏的进行，并结合博弈论的思维判断当前玩家是否有必胜策略。代码实现中需要注意状态回溯和剪枝优化，以提高效率。

---
处理用时：62.52秒
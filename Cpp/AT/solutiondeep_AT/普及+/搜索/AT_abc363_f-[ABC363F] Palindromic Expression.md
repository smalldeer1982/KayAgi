# 题目信息

# [ABC363F] Palindromic Expression

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_f

整数 $ N $ が与えられます。 次の条件を全て満たす文字列 $ S $ としてあり得るものを $ 1 $ 個出力してください。そのような文字列が存在しなければ `-1` を出力してください。

- $ S $ は `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9` および `*` (乗算記号) からなる長さ $ 1 $ 以上 $ 1000 $ 以下の文字列である。
- $ S $ は回文である。
- $ S $ の先頭の文字は数字である。
- $ S $ を式として評価した値が $ N $ と一致する。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^{12} $
- $ N $ は整数
 
### Sample Explanation 1

$ S\ = $ `11\*3\*11` は問題文の条件を満たします。他に条件を満たす文字列として $ S= $ `363` があります。

### Sample Explanation 2

$ S $ は `0` を含んではいけない点に注意してください。

## 样例 #1

### 输入

```
363```

### 输出

```
11*3*11```

## 样例 #2

### 输入

```
101```

### 输出

```
-1```

## 样例 #3

### 输入

```
3154625100```

### 输出

```
2*57*184481*75*2```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个整数 \( N \)。请输出一个满足以下所有条件的字符串 \( S \)。如果不存在这样的字符串，请输出 `-1`。

- \( S \) 是由 `1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9` 以及 `*`（乘法符号）构成的长度 \( l(1 \le l \le 1000) \) 的字符串。
- \( S \) 是回文。
- \( S \) 开头的字符是数字。
- \( S \) 作为表达式计算的值等于 \( N \)。

#### 输入格式

输入以以下形式由标准输入给出：
> \( N \)

#### 输出格式

如果存在满足条件的字符串，则输出该字符串，否则输出 `-1`。

#### 提示

##### 约束条件
- \( 1 \le N \le 10^{12} \)
- \( N \) 为整数

##### 样例 #1 解释
\( S = `11*3*11` \) 满足问题语句的条件。其他符合条件的字符串还有 \( S = `363` \)。

##### 样例 #2 解释
请注意 \( S \) 不能包含 `0`。

### 题解综合分析与结论

本题的核心在于找到一个回文的乘法表达式，其计算结果等于给定的整数 \( N \)，且表达式中不能包含数字 `0`。大多数题解都采用了递归或深度优先搜索（DFS）的方法，通过枚举 \( N \) 的因数，并检查其反转数是否也是因数，从而构建回文表达式。

### 所选高分题解

#### 题解1：作者：Mugino_Shizuri (赞：6)  
**评分：4.5星**  
**关键亮点：**  
- 使用DFS递归分解 \( N \)，枚举因数并检查其反转数是否也是因数。
- 通过 `check0` 和 `check` 函数分别检查数字是否包含 `0` 和是否为回文数。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码：**
```cpp
void dfs(int dep, int s) {
    if (check(s) && check0(s)) { print(dep - 1, s); exit(0); }
    for (int i = 2; i * i <= s; ++i) {
        if ((s % (i * rever(i)) == 0) && check0(i) && check0(rever(i))) {
            sum[dep] = i; dfs(dep + 1, s / i / rever(i));
        }
    }
}
```

#### 题解2：作者：OIer_Hhy (赞：5)  
**评分：4星**  
**关键亮点：**  
- 使用递归分解 \( N \)，并利用 `to_string` 和 `reverse` 函数处理字符串反转。
- 通过 `nozero` 函数检查数字是否包含 `0`。
- 代码结构清晰，适合有一定编程基础的学习者。

**核心代码：**
```cpp
string dfs(int n) {
    if (nozero(n) && n == rev(n)) return to_string(n);
    for (int x = 2; x * x <= n; x++) {
        if (n % x == 0 && nozero(x)) {
            int y = rev(x);
            string ret = dfs(n / x / y);
            if (n / x % y == 0 && ret.size())
                return to_string(x) + "*" + ret + "*" + to_string(y);
        }
    }
    return "";
}
```

#### 题解3：作者：Zhao_daodao (赞：0)  
**评分：4星**  
**关键亮点：**  
- 预处理所有可能的因数对，并利用递归搜索构建回文表达式。
- 通过 `nozero` 和 `ishui` 函数分别检查数字是否包含 `0` 和是否为回文数。
- 代码逻辑严谨，适合进阶学习者。

**核心代码：**
```cpp
bool solve(ll n) {
    if (ishui(n)) { leftans = n; return true; }
    for (int i = 2; i <= g[0] && g[i] * fan[g[i]] <= n; ++i)
        if (n % (g[i] * fan[g[i]]) == 0) {
            if (solve(n / (g[i] * fan[g[i]]))) {
                a[++a[0]] = g[i]; return true;
            }
        }
    return false;
}
```

### 最优关键思路与技巧

1. **递归分解**：通过递归分解 \( N \)，枚举其因数并检查其反转数是否也是因数，从而构建回文表达式。
2. **回文检查**：通过字符串反转或数字反转的方式检查数字是否为回文数。
3. **零检查**：确保表达式中不包含数字 `0`，避免非法输入。

### 可拓展之处

- **类似题目**：可以扩展到其他类型的回文表达式问题，如加法、减法等。
- **优化思路**：可以通过记忆化搜索或动态规划优化递归过程，减少重复计算。

### 推荐题目

1. [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

### 个人心得摘录

- **调试经历**：在处理大数时，注意数据类型的选择，避免溢出。
- **踩坑教训**：在检查回文数时，确保字符串反转的正确性，避免逻辑错误。
- **顿悟感想**：通过递归分解问题，可以简化复杂问题的处理，提高代码的可读性和可维护性。

---
处理用时：48.83秒
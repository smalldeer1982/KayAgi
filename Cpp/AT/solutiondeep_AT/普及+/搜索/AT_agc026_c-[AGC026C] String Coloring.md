# 题目信息

# [AGC026C] String Coloring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc026/tasks/agc026_c

長さ $ 2N $ の，英小文字のみからなる文字列 $ S $ が与えられます。

$ S $ の各文字を赤色か青色かに塗り分ける方法は $ 2^{2N} $ 通りありますが，このうち以下の条件を満たす塗り分け方は何通りですか？

- 赤色に塗られた文字を**左から右に**読んだ文字列と，青色に塗られた文字を**右から左に**読んだ文字列が一致する

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 18 $
- $ S $ の長さは $ 2N $ である
- $ S $ は英小文字のみからなる

### Sample Explanation 1

以下の $ 4 $ 通りの塗り分け方が存在します。 - cabaacba - cabaacba - cabaacba - cabaacba

### Sample Explanation 4

答えは32bit整数型で表せないこともあります。

## 样例 #1

### 输入

```
4

cabaacba```

### 输出

```
4```

## 样例 #2

### 输入

```
11

mippiisssisssiipsspiim```

### 输出

```
504```

## 样例 #3

### 输入

```
4

abcdefgh```

### 输出

```
0```

## 样例 #4

### 输入

```
18

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa```

### 输出

```
9075135300```

# AI分析结果

### 题目内容重写
给定一个长度为 $2N$ 的由小写字母组成的字符串 $S$。对 $S$ 的每个字符进行红蓝染色，求满足以下条件的染色方案数：
- 红色字符从左到右读取的字符串与蓝色字符从右到左读取的字符串相同。

### 题解分析与结论
本题的核心难点在于如何高效地枚举所有可能的染色方案，并快速判断是否满足条件。由于直接枚举的复杂度为 $O(2^{2N})$，对于 $N \leq 18$ 的情况来说是不可行的。因此，大多数题解采用了**折半搜索**的策略，将问题分为前后两半，分别枚举染色方案，并通过哈希或字符串匹配来合并结果。

### 精选题解

#### 1. 作者：Hadtsti (5星)
**关键亮点**：
- 详细解释了折半搜索的原理，并推导了前后半段红蓝字符串的关系。
- 使用了字符串哈希来存储和匹配前后半段的染色方案，哈希冲突概率低。
- 代码简洁高效，使用了 `unsigned long long` 自然溢出作为哈希值，避免了取模运算的开销。

**核心代码**：
```cpp
void dfs(int x,ull hs1,ull hs2,bool fg) 
{
	if(x>n) 
	{
		if(fg)
			ans+=mp[{hs1,hs2}];
		else
			mp[{hs2,hs1}]++; 
		return;
	} 
	dfs(x+1,hs1*131ull+s[fg][x-1],hs2,fg);
	dfs(x+1,hs1,hs2*131ull+s[fg][x-1],fg);
}
```

#### 2. 作者：Ezio__Auditore (4星)
**关键亮点**：
- 通过严谨的数学推导，证明了前后半段红蓝字符串的反转关系。
- 使用了双向搜索的思路，前半段正着搜，后半段反着搜，减少了搜索的复杂度。
- 代码结构清晰，使用了 `map` 来存储哈希值，便于后续匹配。

**核心代码**：
```cpp
void dfs(int x, ll hs1, ll hs2, int d) {
  if (d == 1 && x > n) {
    map[std::make_pair(hs1, hs2)]++;
    return;
  } 
  if (d == -1 && x <= n) {
    ans += map[std::make_pair(hs1, hs2)];
    return;
  }
  dfs(x + d, shift(hs1, s[x]), hs2, d);
  dfs(x + d, hs1, shift(hs2, s[x]), d);
}
```

#### 3. 作者：Chillturtle (4星)
**关键亮点**：
- 详细介绍了折半搜索的背景和适用场景，适合初学者理解。
- 使用了简单的哈希函数，并通过 `map` 存储前后半段的哈希值，便于匹配。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
void dfs(int k,int red,int blue,bool flag){
	if(k>n){
		if(flag==1){
			ans+=mp[{red,blue}];
		}else{
			mp[{red,blue}]++;
		}
		return;
	}
	dfs(k+1,red*hsh+s[flag][k-1],blue,flag);
	dfs(k+1,red,blue*hsh+s[flag][k-1],flag);
}
```

### 最优关键思路与技巧
1. **折半搜索**：将问题分为前后两半，分别枚举染色方案，最后通过哈希或字符串匹配合并结果，将复杂度从 $O(2^{2N})$ 降低到 $O(2^N)$。
2. **字符串哈希**：通过将字符串映射为哈希值，快速判断前后半段的染色方案是否匹配。
3. **双向搜索**：前半段正着搜，后半段反着搜，减少搜索的复杂度。

### 可拓展之处
- **类似问题**：可以应用于其他需要枚举大量状态的问题，如子集和问题、背包问题等。
- **哈希优化**：可以尝试使用双哈希或多哈希来进一步降低哈希冲突的概率。

### 推荐题目
1. [P1463 [POI2001] 子集和问题](https://www.luogu.com.cn/problem/P1463)
2. [P2327 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P2327)
3. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得摘录
- **调试经历**：在实现哈希时，发现直接使用 `unsigned long long` 自然溢出比取模运算更快，且冲突概率低。
- **踩坑教训**：在折半搜索时，前半段和后半段的哈希值存储方式需要一致，否则会导致匹配失败。

---
处理用时：43.17秒
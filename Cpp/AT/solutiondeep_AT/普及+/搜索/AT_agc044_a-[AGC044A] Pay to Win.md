# 题目信息

# [AGC044A] Pay to Win

## 题目描述

# [AGC044A] Pay to Win


你有一个数字$0$ ，你希望得到数字$N$。

你可以通过以下操作更改数字，需要支付一定数量的硬币：

- 将当前数乘$2$，需要$A$硬币。
- 将当前数乘$3$，需要$B$硬币。
- 将当前数乘$5$，需要$C$硬币。
- 将当前数加$1$或减$1$，需要$D$硬币。

你可以按任意顺序和任意次数执行这些操作。

最少需要多少硬币才能得到$N$？

你需要解决$T$组测试用例。

## 说明/提示

### 约束

- $ 1\ \le\ T\ \le\ 10 $
- $ 1\ \le\ N\ \le\ 10^{18} $
- $ 1\ \le\ A,\ B,\ C,\ D\ \le\ 10^9 $
- $ N,\ A,\ B,\ C,\ D $ 都是整数。

### Sample Explanation 1

对于第一个测试用例，达到最低成本$20$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$1$个硬币使其乘$2(x = 4)$
- 用$2$个硬币使其乘$3(x = 12)$
- 用$8$个硬币使其减$1(x = 11)$

对于第二个测试用例，达到最低成本$19$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$2$个硬币使其乘$5(x = 10)$
- 用$8$个硬币使其减$1(x = 11)$

## 样例 #1

### 输入

```
5

11 1 2 4 8

11 1 2 2 8

32 10 8 5 4

29384293847243 454353412 332423423 934923490 1

900000000000000000 332423423 454353412 934923490 987654321```

### 输出

```
20

19

26

3821859835

23441258666```

# AI分析结果

### 题目内容重写

你有一个数字$0$，你希望得到数字$N$。

你可以通过以下操作更改数字，需要支付一定数量的硬币：

- 将当前数乘$2$，需要$A$硬币。
- 将当前数乘$3$，需要$B$硬币。
- 将当前数乘$5$，需要$C$硬币。
- 将当前数加$1$或减$1$，需要$D$硬币。

你可以按任意顺序和任意次数执行这些操作。

最少需要多少硬币才能得到$N$？

你需要解决$T$组测试用例。

### 说明/提示

#### 约束

- $ 1\ \le\ T\ \le\ 10 $
- $ 1\ \le\ N\ \le\ 10^{18} $
- $ 1\ \le\ A,\ B,\ C,\ D\ \le\ 10^9 $
- $ N,\ A,\ B,\ C,\ D $ 都是整数。

### 题解分析与结论

本题的核心是通过DFS结合记忆化搜索来求解最小花费。由于$N$的范围很大（$10^{18}$），直接DFS会超时，因此需要使用记忆化搜索来优化。所有题解都采用了类似的方法，即从$N$开始，通过除以2、3、5并加上相应的花费，逐步缩小问题规模，直到$N$变为0或1。

### 所选高星题解

#### 题解1：作者：suzhikz (赞：5)
- **星级**：5星
- **关键亮点**：
  - 使用DFS结合记忆化搜索，从$N$开始逐步缩小问题规模。
  - 通过将$N$调整为最近的2、3、5的倍数，减少了不必要的计算。
  - 使用`map`进行记忆化，避免了重复计算。
- **代码核心思想**：
  - 通过DFS递归计算最小花费，每次尝试将$N$调整为最近的2、3、5的倍数，并加上相应的花费。

```cpp
if(m[x])return m[x];
	if(x==0)return 0;
	if(x==1)return d;
	ll ans=min((__int128)1e18,(__int128)x*d);
	ll l,r;
	{
		l=x/2*2;
		ans=min(ans,(x-l)*d+a+dfs(l/2));
		r=(x+1)/2*2;
		ans=min(ans,(r-x)*d+a+dfs(r/2));
	}
	{
		l=x/3*3;
		ans=min(ans,(x-l)*d+b+dfs(l/3));
		r=(x+2)/3*3;
		ans=min(ans,(r-x)*d+b+dfs(r/3));
	}
	{
		l=x/5*5;
		ans=min(ans,(x-l)*d+c+dfs(l/5));
		r=(x+4)/5*5;
		ans=min(ans,(r-x)*d+c+dfs(r/5));
	}
```

#### 题解2：作者：IkunTeddy (赞：2)
- **星级**：4星
- **关键亮点**：
  - 详细分析了DFS的时间复杂度，并指出通过记忆化搜索可以大幅优化。
  - 代码结构清晰，易于理解。
- **代码核心思想**：
  - 通过DFS递归计算最小花费，每次尝试将$N$调整为最近的2、3、5的倍数，并加上相应的花费。

```cpp
int dfs(int n){
	if(mp.count(n))return mp[n];
	int l1=(n/2)*2,r1=((n+1)/2)*2;
	int l2=(n/3)*3,r2=((n+2)/3)*3;
	int l3=(n/5)*5,r3=((n+4)/5)*5;
	int ans=(n<(int)1e18/d)?n*d:(int)1e18;
	ans=min(ans,(n-l1)*d+dfs(l1/2)+a);
	ans=min(ans,(r1-n)*d+dfs(r1/2)+a);
	ans=min(ans,(n-l2)*d+dfs(l2/3)+b);
	ans=min(ans,(r2-n)*d+dfs(r2/3)+b);
	ans=min(ans,(n-l3)*d+dfs(l3/5)+c);
	ans=min(ans,(r3-n)*d+dfs(r3/5)+c);
	return mp[n]=ans;
}
```

#### 题解3：作者：墨笙_Mooos (赞：0)
- **星级**：4星
- **关键亮点**：
  - 详细解释了从$N$开始逐步缩小问题规模的思路，并给出了数学上的证明。
  - 代码实现简洁，逻辑清晰。
- **代码核心思想**：
  - 通过DFS递归计算最小花费，每次尝试将$N$调整为最近的2、3、5的倍数，并加上相应的花费。

```cpp
int dfs(int x){
	if(mp.count(x)) return mp[x];
	int ans=x*d;
	
	if(x%2) ans=min(ans,min(dfs((x-x%2)/2),dfs((x+2-x%2)/2))+a+d);
	else ans=min(ans,dfs(x/2)+a);
	
	if(x%3) ans=min(ans,min(dfs((x-x%3)/3)+(x%3)*d,dfs((x+3-x%3)/3)+(3-x%3)*d)+b);
	else ans=min(ans,dfs(x/3)+b);
	
	if(x%5) ans=min(ans,min(dfs((x-x%5)/5)+(x%5)*d,dfs((x+5-x%5)/5)+(5-x%5)*d)+c);
	else ans=min(ans,dfs(x/5)+c);
	
	mp[x]=ans;
	return ans;
}
```

### 最优关键思路与技巧

1. **DFS结合记忆化搜索**：通过DFS递归计算最小花费，使用`map`进行记忆化，避免重复计算。
2. **问题规模缩小**：每次将$N$调整为最近的2、3、5的倍数，逐步缩小问题规模，直到$N$变为0或1。
3. **数学优化**：通过数学上的证明，确保每次调整后的$N$是最优的，减少了不必要的计算。

### 可拓展之处

类似的问题可以通过DFS结合记忆化搜索来解决，尤其是在问题规模较大时，记忆化搜索可以大幅优化时间复杂度。例如，求解最短路径、最小花费等问题时，都可以采用类似的方法。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

### 个人心得摘录

- **调试经历**：在实现DFS时，最初没有使用记忆化搜索，导致超时。通过引入`map`进行记忆化，大幅优化了性能。
- **踩坑教训**：在处理大数时，需要注意数据类型的范围，避免溢出。
- **顿悟感想**：通过将问题规模逐步缩小，可以有效地减少计算量，提高算法的效率。

---
处理用时：57.48秒
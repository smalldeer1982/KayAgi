# 题目信息

# [ABC067D] Fennec VS. Snuke

## 题目描述

$Fennec$ 和 $Snuke$ 正在玩棋盘游戏。

在这个游戏中，有 $n$ 个格子和 $n-1$ 条道路， 编号为 $a_i$ 和 $b_i$ 的格子通过第 $i$ 条边相连。这些格子和边组成了一棵树。

第 $1$ 个格子是黑色，第 $n$ 个格子是白色，其他格子没有颜色。先手 $Fennec$ 和后手 $Snuke$ 交替给格子涂色，两人依次执行以下操作：

   $Fennec$：将一个与黑色格子相邻且未被涂色的格子涂成黑色。
   
   $Snuke$：将一个与白色格子相邻且未被涂色的格子涂成白色。

如果当前行动的玩家无法涂色，他将输掉游戏。请你写一个程序，判断当 $Fennec$ 和 $Snuke$ 都采取最佳策略时，谁能获胜。

## 样例 #1

### 输入

```
7

3 6

1 2

3 1

7 4

5 7

1 4```

### 输出

```
Fennec```

## 样例 #2

### 输入

```
4

1 4

4 2

2 3```

### 输出

```
Snuke```

# AI分析结果

### 题目内容重写

**题目描述**

Fennec 和 Snuke 正在玩棋盘游戏。

在这个游戏中，有 $n$ 个格子和 $n-1$ 条道路，编号为 $a_i$ 和 $b_i$ 的格子通过第 $i$ 条边相连。这些格子和边组成了一棵树。

第 $1$ 个格子是黑色，第 $n$ 个格子是白色，其他格子没有颜色。先手 Fennec 和后手 Snuke 交替给格子涂色，两人依次执行以下操作：

   Fennec：将一个与黑色格子相邻且未被涂色的格子涂成黑色。
   
   Snuke：将一个与白色格子相邻且未被涂色的格子涂成白色。

如果当前行动的玩家无法涂色，他将输掉游戏。请你写一个程序，判断当 Fennec 和 Snuke 都采取最佳策略时，谁能获胜。

**样例 #1**

### 输入

```
7

3 6

1 2

3 1

7 4

5 7

1 4```

### 输出

```
Fennec```

**样例 #2**

### 输入

```
4

1 4

4 2

2 3```

### 输出

```
Snuke```

---

### 题解综合分析与结论

这道题的核心是通过树的遍历（DFS或BFS）来计算每个点到起点和终点的距离，然后根据距离判断每个点的归属，最终统计双方能够占领的格子数量，决定胜负。大多数题解都采用了类似的思路，但在实现细节和代码优化上有所不同。

### 所选高星题解

#### 题解1：作者：tanghg (赞：7)
- **星级**：★★★★★
- **关键亮点**：
  - 使用DFS遍历树，计算每个点到起点和终点的距离。
  - 通过比较距离决定每个点的归属，思路清晰，代码简洁。
  - 利用了先手优势，当距离相等时，优先归属先手。
- **代码核心**：
  ```cpp
  void dfs(ll u,ll f,ll id){
      dis[id][u]=dis[id][f]+1;
      for(int i:a[u]){
          if(i==f) continue;
          dfs(i,u,id);
      }
  }
  ```
  - **核心思想**：通过DFS遍历树，记录每个点到起点和终点的距离。

#### 题解2：作者：_hxh (赞：1)
- **星级**：★★★★
- **关键亮点**：
  - 使用DFS分别计算每个点到起点和终点的距离。
  - 通过比较距离决定每个点的归属，代码实现较为清晰。
  - 强调了先手优势，当距离相等时，优先归属先手。
- **代码核心**：
  ```cpp
  void white(int u,int v){
      w[u] = w[v] + 1;
      for (auto i : vec[u])
          if (i != v)
              white(i,u);
  }
  ```
  - **核心思想**：通过DFS遍历树，记录每个点到起点和终点的距离。

#### 题解3：作者：Juanzhang (赞：1)
- **星级**：★★★★
- **关键亮点**：
  - 使用BFS进行染色，模拟双方的涂色过程。
  - 通过BFS遍历树，记录每个点的归属，代码实现较为直观。
  - 强调了先手优势，当控制区域相同时，根据树的奇偶性决定胜负。
- **代码核心**：
  ```cpp
  while(!que.empty()) {
      auto u=que.front().second,op=que.front().first;
      que.pop();
      if(m[u]) continue;
      m[u]=1;
      ans[op]++;
      for(auto v:vec[u]) {
          que.push(make_pair(op,v));
      }
  }
  ```
  - **核心思想**：通过BFS遍历树，模拟双方的涂色过程，记录每个点的归属。

### 最优关键思路与技巧

1. **树的遍历**：无论是DFS还是BFS，遍历树的核心思想都是计算每个点到起点和终点的距离，然后根据距离决定归属。
2. **先手优势**：当距离相等时，优先归属先手，这是决定胜负的关键。
3. **统计归属**：通过比较距离，统计双方能够占领的格子数量，最终决定胜负。

### 可拓展之处

- **类似问题**：可以扩展到其他博弈问题，如双方在图中争夺资源，或者在其他数据结构（如网格图）中进行博弈。
- **优化思路**：可以考虑使用更高效的遍历算法，或者在遍历过程中进行剪枝，减少不必要的计算。

### 推荐题目

1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352) - 树形DP问题，考察树的遍历和状态转移。
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040) - 树的遍历与动态规划结合，考察树的构造与优化。
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014) - 树形DP问题，考察树的遍历与资源分配。

### 个人心得摘录

- **调试经历**：在实现DFS时，需要注意避免重复遍历父节点，否则会导致栈溢出或错误结果。
- **踩坑教训**：在统计归属时，需要明确距离相等的处理方式，否则可能导致错误的胜负判断。
- **顿悟感想**：通过树的遍历和距离比较，可以清晰地判断每个点的归属，这是解决此类博弈问题的关键。

---
处理用时：48.79秒
# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写
在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

### 题解分析与结论
本题的核心是判断给定的距离约束是否一致，可以通过并查集、DFS或差分约束等方法来解决。以下是各题解的要点总结：

1. **Doraven的题解**：使用带权并查集，通过维护每个节点到其祖先的距离来判断约束是否一致。该方法简洁高效，适合大规模数据。
2. **CreeperLordVader的题解**：采用DFS判断负环，通过深度优先搜索检查是否存在矛盾的距离约束。该方法适合小规模数据，但代码复杂度较高。
3. **Wen_kr的题解**：使用差分约束和SPFA算法，通过最短路算法判断约束是否一致。该方法适合中等规模数据，但实现较为复杂。

### 精选题解
1. **Doraven的题解**（5星）
   - **关键亮点**：使用带权并查集，代码简洁高效，适合大规模数据。
   - **核心代码**：
     ```cpp
     int find(int x){
         if(fa[x]!=x){
             int nf=fa[x];
             fa[x]=find(fa[x]);
             dis[x]+=dis[nf];
         }
         return fa[x];
     }
     ```
   - **个人心得**：通过维护每个节点到其祖先的距离，可以高效判断约束是否一致。

2. **Wen_kr的题解**（4星）
   - **关键亮点**：使用差分约束和SPFA算法，适合中等规模数据。
   - **核心代码**：
     ```cpp
     bool spfa(int st){
         que.push(st);
         inq[st] = true;
         dist[st] = 0;
         while(!que.empty()){
             int u = que.front();
             que.pop();
             for(int i = head[u];i;i = e[i].nxt){
                 int v = e[i].v;
                 if(dist[v] == 12345678987654321){
                     dist[v] = dist[u] + e[i].w;
                     vis[v] = 1;
                     if(!inq[v]) que.push(v);
                 }
                 else if(dist[v] != dist[u] + e[i].w) return false;
             }
             inq[u] = false;
         }
         return true;
     }
     ```
   - **个人心得**：通过最短路算法判断约束是否一致，实现较为复杂但效果良好。

### 最优关键思路
使用带权并查集是解决本题的最优方法，通过维护每个节点到其祖先的距离，可以高效判断约束是否一致。该方法代码简洁，适合大规模数据。

### 拓展思路
类似的问题可以通过并查集、DFS或差分约束等方法解决。对于大规模数据，带权并查集是最优选择；对于小规模数据，DFS可能更为简便。

### 推荐题目
1. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)
2. [P1266 差分约束系统](https://www.luogu.com.cn/problem/P1266)
3. [P2294 [HNOI2005]狡猾的商人](https://www.luogu.com.cn/problem/P2294)

---
处理用时：28.05秒
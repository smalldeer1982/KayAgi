# 题目信息

# [ABC151E] Max-Min Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc151/tasks/abc151_e

有限個の整数からなる集合 $ X $ に対し $ f(X)=\max\ X\ -\ \min\ X $ と定義します。

$ N $ 個の整数 $ A_1,...,A_N $ が与えられます。

このうち $ K $ 個を選び、それらからなる集合を $ S $ とします。同じ値であっても添字が異なる要素を区別すると、そのような選び方は $ {}_N\ C_K $ 通りありますが、その全てについての $ f(S) $ の合計を求めてください。

答えは非常に大きくなる可能性があるので、$ \bmod\ 10^9+7 $ で出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

$ S $ の選び方は $ \{1,1\},\{1,3\},\{1,4\},\{1,3\},\{1,4\},\{3,4\} $ の $ 6 $ 通りあり (ふたつの $ 1 $ は区別します)、$ f(S) $ はそれぞれ $ 0,2,3,2,3,1 $ となるので、合計は $ 11 $ です。

### Sample Explanation 2

$ S $ の選び方は $ 20 $ 通りあり、そのうち $ 18 $ 通りで $ f(S)=20 $、$ 2 $ 通りで $ f(S)=0 $ となります。

### Sample Explanation 4

合計は $ \bmod\ 10^9+7 $ で出力してください。

## 样例 #1

### 输入

```
4 2

1 1 3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
6 3

10 10 10 -10 -10 -10```

### 输出

```
360```

## 样例 #3

### 输入

```
3 1

1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 6

1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0```

### 输出

```
999998537```

# AI分析结果

### 题目内容重写

给定一个包含 $N$ 个整数的集合 $A$，从中选出 $K$ 个元素构成子集 $S$。定义 $f(S) = \max(S) - \min(S)$，求所有可能的子集 $S$ 的 $f(S)$ 之和，并对 $10^9+7$ 取模。

### 样例解释

**样例1**  
输入：
```
4 2
1 1 3 4
```
输出：
```
11
```
解释：共有6种选法，$f(S)$ 分别为 $0,2,3,2,3,1$，总和为 $11$。

**样例2**  
输入：
```
6 3
10 10 10 -10 -10 -10
```
输出：
```
360
```
解释：共有20种选法，其中18种 $f(S)=20$，2种 $f(S)=0$，总和为 $360$。

### 题解分析与结论

#### 题解1：TonyYin (4星)
- **关键亮点**：通过排序后计算每个数作为最大值和最小值的贡献，利用组合数统计每个数的出现次数，避免了暴力枚举。
- **代码实现**：使用逆元预处理组合数，排序后分别计算最大值和最小值的贡献，最后相减得到结果。
- **核心代码**：
```cpp
for(int i = k; i <= n; i++) { //算一遍最大值
    ans = (ans + a[i] * C(i - 1, k - 1) % mod) % mod;
}
for(int i = 1; i <= n - k + 1; i++) { //算一遍最小值
    ans = (ans - a[i] * C(n - i, k - 1) % mod) % mod;
}
```

#### 题解2：_determination_ (4星)
- **关键亮点**：简洁明了地处理了每个数作为最大值和最小值的贡献，代码结构清晰，易于理解。
- **代码实现**：同样使用逆元预处理组合数，排序后分别计算最大值和最小值的贡献，最后相减得到结果。
- **核心代码**：
```cpp
for ( int i = m ; i <= n ; i++ ) {
    ans1=(ans1+c(i-1,m-1)*a[i]%mod)%mod;
}
for ( int i = 1 ; i <= n-m+1 ; i++ ) {
    ans2=(ans2+c(n-i,m-1)*a[i]%mod)%mod;
}
```

#### 题解3：WaterSun (4星)
- **关键亮点**：详细解释了每个数作为最大值和最小值的贡献计算过程，代码实现清晰，适合初学者理解。
- **代码实现**：使用逆元预处理组合数，排序后分别计算最大值和最小值的贡献，最后相减得到结果。
- **核心代码**：
```cpp
for (re int i = 1; i <= n; i++) {
    a = Add(a, Mul(C(n - i, k - 1), arr[i]));
    b = Add(b, Mul(C(i - 1, k - 1), arr[i]));
}
```

### 最优关键思路与技巧
1. **排序与组合数**：通过排序后计算每个数作为最大值和最小值的贡献，利用组合数统计每个数的出现次数，避免了暴力枚举。
2. **逆元预处理**：使用逆元预处理组合数，避免重复计算，提高效率。
3. **贡献分离**：将最大值和最小值的贡献分开计算，最后相减得到结果，简化了问题。

### 可拓展之处
- **类似问题**：可以扩展到求其他统计量（如中位数、众数等）的贡献和。
- **优化思路**：对于更大的数据范围，可以考虑使用更高效的组合数计算方法，如Lucas定理。

### 推荐题目
1. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)
2. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)
3. [P1495 【模板】组合数](https://www.luogu.com.cn/problem/P1495)

### 个人心得总结
- **调试经历**：在处理组合数时，需要注意边界条件，如 $C(n, 0) = 1$ 和 $C(n, n) = 1$。
- **踩坑教训**：在计算贡献时，确保每个数的贡献计算正确，避免重复或遗漏。
- **顿悟感想**：通过排序和组合数的结合，可以将复杂的问题简化为简单的贡献计算，极大地提高了效率。

---
处理用时：37.15秒
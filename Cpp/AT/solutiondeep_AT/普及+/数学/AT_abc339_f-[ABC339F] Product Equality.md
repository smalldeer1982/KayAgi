# 题目信息

# [ABC339F] Product Equality

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc339/tasks/abc339_f

$ N $ 個の整数 $ A_1,A_2,\dots,A_N $ が与えられます。  
 以下の条件を満たす整数の組 $ (i,j,k) $ の個数を求めてください。

- $ 1\ \le\ i,j,k\ \le\ N $
- $ A_i\ \times\ A_j\ =\ A_k $

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 1000 $
- $ \color{red}{1\ \le\ A_i\ <\ 10^{1000}} $
 
### Sample Explanation 1

問題文中の条件を満たす $ (i,j,k) $ の組は以下の $ 6 $ 通りです。 - $ (1,2,3) $ - $ (1,3,4) $ - $ (1,4,5) $ - $ (2,1,3) $ - $ (3,1,4) $ - $ (4,1,5) $

### Sample Explanation 2

各整数 $ A_i $ の値が非常に大きくなりうることに注意してください。

### Sample Explanation 3

$ A_i $ の値に重複がありうることに注意してください。

## 样例 #1

### 输入

```
5

2

3

6

12

24```

### 输出

```
6```

## 样例 #2

### 输入

```
11

1

2

3

4

5

6

123456789123456789

123456789123456789

987654321987654321

987654321987654321

121932631356500531347203169112635269```

### 输出

```
40```

## 样例 #3

### 输入

```
9

4

4

4

2

2

2

1

1

1```

### 输出

```
162```

# AI分析结果

### 题目内容重写

给定 $N$ 个整数 $A_1,A_2,\dots,A_N$，求满足以下条件的整数三元组 $(i,j,k)$ 的个数：

- $1\ \le\ i,j,k\ \le\ N$
- $A_i\ \times\ A_j\ =\ A_k$

### 说明/提示

#### 约束

- $1\ \le\ N\ \le\ 1000$
- $1\ \le\ A_i\ <\ 10^{1000}$

### 样例 #1

#### 输入

```
5
2
3
6
12
24
```

#### 输出

```
6
```

### 样例 #2

#### 输入

```
11
1
2
3
4
5
6
123456789123456789
123456789123456789
987654321987654321
987654321987654321
121932631356500531347203169112635269
```

#### 输出

```
40
```

### 样例 #3

#### 输入

```
9
4
4
4
2
2
2
1
1
1
```

#### 输出

```
162
```

---

### 综合分析与结论

本题的核心难点在于处理大数乘法，由于 $A_i$ 的范围可能达到 $10^{1000}$，直接进行高精度乘法会导致时间复杂度过高。因此，大多数题解采用了哈希的思路，通过取模运算将大数转化为较小的数值，从而降低计算复杂度。哈希方法的关键在于选择合适的模数，以避免哈希冲突。

### 精选题解

#### 题解1：作者：apiad (赞：5)
- **星级**：★★★★★
- **关键亮点**：单哈希法，选择了一个较大的模数 $11451419198101111$，成功通过了测试数据。虽然单哈希在某些情况下可能不够稳定，但该题解通过选择合适的模数，避免了哈希冲突。
- **代码核心思想**：
  ```cpp
  const int mod = 11451419198101111;
  map<int, int> mp;
  for (int i = 1; i <= n; ++i) {
      string s; cin >> s;
      int hash = 0;
      for (char c : s) hash = (hash * 10 + (c - '0')) % mod;
      mp[hash]++;
  }
  for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= n; ++j) {
          ans += mp[(a[i] * a[j]) % mod];
      }
  }
  ```
  **核心思想**：通过哈希将大数转化为较小的数值，利用 `map` 统计哈希值的出现次数，最后枚举所有可能的 $(i,j)$ 组合，计算满足条件的 $k$ 的数量。

#### 题解2：作者：Elairin176 (赞：3)
- **星级**：★★★★
- **关键亮点**：双哈希法，使用两个不同的模数 $998244353$ 和 $1000000993$，进一步降低了哈希冲突的概率。通过 `map` 存储双哈希值，提高了算法的稳定性。
- **代码核心思想**：
  ```cpp
  const ll p1 = 998244353, p2 = 1000000993;
  map<ll, ll> mp;
  for (int i = 1; i <= n; ++i) {
      string s; cin >> s;
      ll hash1 = 0, hash2 = 0;
      for (char c : s) {
          hash1 = (hash1 * 10 + (c - '0')) % p1;
          hash2 = (hash2 * 10 + (c - '0')) % p2;
      }
      mp[hash1 * (p2 + 10) + hash2]++;
  }
  for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= n; ++j) {
          ans += mp[(a[i] * a[j] % p1) * (p2 + 10) + (a[i] * a[j] % p2)];
      }
  }
  ```
  **核心思想**：通过双哈希法，进一步降低哈希冲突的概率，利用 `map` 存储双哈希值，最后枚举所有可能的 $(i,j)$ 组合，计算满足条件的 $k$ 的数量。

#### 题解3：作者：Milthm (赞：2)
- **星级**：★★★★
- **关键亮点**：使用 `__int128` 类型，选择了一个接近 $10^{18}$ 的模数，避免了哈希冲突。通过 `map` 存储哈希值，最后枚举所有可能的 $(i,j)$ 组合，计算满足条件的 $k$ 的数量。
- **代码核心思想**：
  ```cpp
  const int mod = (int)(1e18) + 3;
  map<int, long long> mp;
  for (int i = 1; i <= n; ++i) {
      string s; cin >> s;
      int hash = 0;
      for (char c : s) hash = (hash * 10 + (c - '0')) % mod;
      mp[hash]++;
  }
  for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= n; ++j) {
          ans += mp[(a[i] * a[j]) % mod];
      }
  }
  ```
  **核心思想**：通过 `__int128` 类型处理大数乘法，选择了一个较大的模数，避免了哈希冲突，利用 `map` 存储哈希值，最后枚举所有可能的 $(i,j)$ 组合，计算满足条件的 $k$ 的数量。

### 最优关键思路或技巧

1. **哈希法**：通过取模运算将大数转化为较小的数值，降低计算复杂度。
2. **双哈希**：使用两个不同的模数，进一步降低哈希冲突的概率。
3. **选择合适的模数**：模数的选择对哈希法的稳定性至关重要，较大的模数可以有效避免哈希冲突。

### 可拓展之处

1. **多哈希法**：可以尝试使用更多的模数，进一步提高哈希法的稳定性。
2. **其他哈希函数**：可以尝试使用其他哈希函数，如多项式哈希等，进一步优化算法。

### 推荐题目

1. [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)
2. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
3. [P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)

### 个人心得

- **调试经历**：在选择模数时，尝试了多个不同的模数，最终选择了较大的模数，成功通过了测试数据。
- **踩坑教训**：单哈希在某些情况下可能不够稳定，建议使用双哈希或多哈希法，以提高算法的稳定性。
- **顿悟感想**：哈希法在处理大数问题时非常有效，选择合适的模数是关键。

---
处理用时：57.02秒
# 题目信息

# [ABC374E] Sensor Optimization Dilemma 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_e

ある製品の製造には $ 1,2,\dots,N $ の番号が付いた $ N $ 個の工程が必要です。

各工程 $ i $ について、それを処理する $ 2 $ 種類の機械 $ S_i,T_i $ が売られています。

- 機械 $ S_i $ : $ 1 $ 台につき $ 1 $ 日あたり製品 $ A_i $ 個分の処理ができ、 $ 1 $ 台 $ P_i $ 円で導入できる
- 機械 $ T_i $ : $ 1 $ 台につき $ 1 $ 日あたり製品 $ B_i $ 個分の処理ができ、 $ 1 $ 台 $ Q_i $ 円で導入できる

それぞれの機械は $ 0 $ 台以上何台でも導入できます。

機械の導入の結果、工程 $ i $ を $ 1 $ 日あたり製品 $ W_i $ 個分処理できるようになったとします。  
このとき、製造能力を $ W $ の最小値、すなわち $ \displaystyle\ \min^{N}_{i=1}\ W_i $ と定義します。

全体の予算が $ X $ 円のとき、達成可能な製造能力の最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 100 $
- $ 1\ \le\ A_i,B_i\ \le\ 100 $
- $ 1\ \le\ P_i,Q_i,X\ \le\ 10^7 $

### Sample Explanation 1

例えば、次の通り機械を導入することで製造能力を $ 4 $ にすることができ、これが達成可能な最大値です。 - 工程 $ 1 $ に対し機械 $ S_1 $ を $ 2 $ 台導入する。 - $ 1 $ 日あたり製品 $ 4 $ 個分の処理に相当し、導入に合計 $ 10 $ 円かかる。 - 工程 $ 2 $ に対し機械 $ S_2 $ を $ 1 $ 台導入する。 - $ 1 $ 日あたり製品 $ 1 $ 個分の処理に相当し、導入に合計 $ 1 $ 円かかる。 - 工程 $ 2 $ に対し機械 $ T_2 $ を $ 1 $ 台導入する。 - $ 1 $ 日あたり製品 $ 3 $ 個分の処理に相当し、導入に合計 $ 3 $ 円かかる。 - 工程 $ 3 $ に対し機械 $ T_3 $ を $ 2 $ 台導入する。 - $ 1 $ 日あたり製品 $ 4 $ 個分の処理に相当し、導入に合計 $ 8 $ 円かかる。

### Sample Explanation 3

正の製造能力が得られない場合もあります。

## 样例 #1

### 输入

```
3 22
2 5 3 6
1 1 3 3
1 3 2 4```

### 输出

```
4```

## 样例 #2

### 输入

```
1 10000000
100 1 100 1```

### 输出

```
1000000000```

## 样例 #3

### 输入

```
1 1
1 10000000 1 10000000```

### 输出

```
0```

## 样例 #4

### 输入

```
10 7654321
8 6 9 1
5 6 4 3
2 4 7 9
7 8 9 1
7 9 1 6
4 8 9 1
2 2 8 9
1 6 2 6
4 2 3 4
6 6 5 2```

### 输出

```
894742```

# AI分析结果

### 题目内容重写

【题目描述】

某产品的制造需要编号为 $1,2,\dots,N$ 的 $N$ 个工序。每个工序 $i$ 有两种机器 $S_i$ 和 $T_i$ 可供选择：

- 机器 $S_i$：每台每天可以处理 $A_i$ 个产品，每台价格为 $P_i$ 元。
- 机器 $T_i$：每台每天可以处理 $B_i$ 个产品，每台价格为 $Q_i$ 元。

每种机器可以购买任意数量（包括 0 台）。假设通过购买机器，工序 $i$ 每天可以处理 $W_i$ 个产品。定义制造能力为 $W$ 的最小值，即 $\displaystyle\ \min^{N}_{i=1}\ W_i$。

在总预算为 $X$ 元的情况下，求可以达到的最大制造能力。

【说明/提示】

### 制約

- 输入均为整数
- $1\ \le\ N\ \le\ 100$
- $1\ \le\ A_i,B_i\ \le\ 100$
- $1\ \le\ P_i,Q_i,X\ \le\ 10^7$

### 样例解释 1

例如，可以通过以下方式购买机器，使制造能力达到 $4$，这是可以达到的最大值：
- 工序 $1$ 购买 $2$ 台 $S_1$，每天处理 $4$ 个产品，总花费 $10$ 元。
- 工序 $2$ 购买 $1$ 台 $S_2$，每天处理 $1$ 个产品，总花费 $1$ 元。
- 工序 $2$ 购买 $1$ 台 $T_2$，每天处理 $3$ 个产品，总花费 $3$ 元。
- 工序 $3$ 购买 $2$ 台 $T_3$，每天处理 $4$ 个产品，总花费 $8$ 元。

### 样例解释 3

有时可能无法获得正的制造能力。

### 题解分析与结论

本题的核心是通过二分答案和贪心策略来求解最大制造能力。以下是各题解的要点总结：

1. **二分答案**：几乎所有题解都采用了二分答案的思路，通过二分制造能力 $W$，判断是否可以在预算 $X$ 内达到该制造能力。
2. **贪心策略**：在判断某个 $W$ 是否可行时，题解普遍采用了贪心策略，优先选择性价比更高的机器，并通过枚举少量机器的购买数量来优化计算。
3. **优化技巧**：部分题解通过限制枚举数量（如最多枚举 100 台）来减少计算量，确保在时间限制内完成。

### 最优关键思路

1. **二分答案**：通过二分制造能力 $W$，将问题转化为判断是否可以在预算内达到该制造能力。
2. **贪心策略**：在判断 $W$ 是否可行时，优先选择性价比更高的机器，并通过枚举少量机器的购买数量来优化计算。
3. **枚举优化**：由于 $A_i$ 和 $B_i$ 的值较小（$\le 100$），可以通过限制枚举数量（如最多枚举 100 台）来减少计算量。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)：考察二分答案和贪心策略。
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)：考察动态规划和贪心策略。
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：考察背包问题和贪心策略。

### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现二分上界设置过大导致爆 `long long`，提醒我们在二分时要注意上界的合理设置。
- **顿悟感想**：通过枚举少量机器的购买数量，可以在保证正确性的同时大幅减少计算量，这种优化思路值得借鉴。

### 所选高星题解

#### 题解1：作者：Binah_cyc (5星)

**关键亮点**：
- 通过二分答案和贪心策略，优先选择性价比更高的机器，并通过枚举少量机器的购买数量来优化计算。
- 代码简洁，逻辑清晰，优化思路明确。

**核心代码**：
```cpp
bool check(int mid) {
    int cnt = 0;
    for (int i = 1; i <= n; i++) cnt += work(i, mid);
    return cnt <= X;
}
```

#### 题解2：作者：zzk2010 (4星)

**关键亮点**：
- 通过二分答案和贪心策略，优先选择性价比更高的机器，并通过枚举少量机器的购买数量来优化计算。
- 详细解释了贪心策略的合理性，代码可读性强。

**核心代码**：
```cpp
bool check(int x) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        int res = 1e15;
        for (int j = 0; j < a[i]; j++) {
            if (j * b[i] > x) break;
            int tmp = x - j * b[i];
            res = min(res, j * q[i] + (tmp + a[i] - 1) / a[i] * p[i]);
        }
        sum += res;
    }
    return sum <= X;
}
```

#### 题解3：作者：lunjiahao (4星)

**关键亮点**：
- 通过二分答案和贪心策略，优先选择性价比更高的机器，并通过枚举少量机器的购买数量来优化计算。
- 详细解释了枚举数量的合理性，代码逻辑清晰。

**核心代码**：
```cpp
bool check(int mid) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        int s = INF;
        for (int j = mid / a[i] + 1; j >= max(mid / a[i] - 100, 0ll); j--) {
            int y = max(0ll, mid - j * a[i] + b[i] - 1);
            s = min(s, j * p[i] + y / b[i] * q[i]);
        }
        sum += s;
    }
    return sum <= x;
}
```

---
处理用时：47.53秒
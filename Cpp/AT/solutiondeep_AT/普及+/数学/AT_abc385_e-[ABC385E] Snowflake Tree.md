# 题目信息

# [ABC385E] Snowflake Tree

## 题目描述

"雪花树"是通过以下步骤生成的树：

1. 选择正整数 $x,y$。
2. 准备一个顶点。
3. 再准备 $x$ 个顶点，并将它们每个都与步骤 2 中准备的顶点相连。
4. 对于步骤 3 中准备的每个 $x$ 个顶点，为其连接 $y$ 个叶子节点。

下图展示了一个 $x=4,y=2$ 的雪花树。在步骤 2、3、4 中准备的顶点分别用红色、蓝色和绿色表示。

![](https://img.atcoder.jp/abc385/b836ca95b1add288731cbe63816da3b1.png)

给定一个有 $N$ 个顶点的树 $T$。顶点编号从 1 到 $N$，第 $i$ 条边（$i=1,2,\dots,N-1$）连接顶点 $u_i$ 和 $v_i$。

考虑删除 $T$ 中零个或多个顶点及其相邻的边，使得剩余图形成为一个雪花树。求必须删除的最少顶点数。在本题的约束条件下，总是可以将 $T$ 转换为雪花树。

## 说明/提示

- $3 \leq N \leq 3 \times 10^5$
- $1 \leq u_i < v_i \leq N$
- 给定图是一棵树
- 所有输入值均为整数

## 样例 #1

### 输入

```
8

1 3

2 3

3 4

4 5

5 6

5 7

4 8```

### 输出

```
1```

## 样例 #2

### 输入

```
3

1 2

2 3```

### 输出

```
0```

## 样例 #3

### 输入

```
10

1 3

1 2

5 7

6 10

2 8

1 6

8 9

2 7

1 4```

### 输出

```
3```

# AI分析结果

### 题目重写
#### [ABC385E] 雪花树

**题目描述**

"雪花树"是通过以下步骤生成的树：

1. 选择正整数 $x,y$。
2. 准备一个顶点。
3. 再准备 $x$ 个顶点，并将它们每个都与步骤 2 中准备的顶点相连。
4. 对于步骤 3 中准备的每个 $x$ 个顶点，为其连接 $y$ 个叶子节点。

下图展示了一个 $x=4,y=2$ 的雪花树。在步骤 2、3、4 中准备的顶点分别用红色、蓝色和绿色表示。

![](https://img.atcoder.jp/abc385/b836ca95b1add288731cbe63816da3b1.png)

给定一个有 $N$ 个顶点的树 $T$。顶点编号从 1 到 $N$，第 $i$ 条边（$i=1,2,\dots,N-1$）连接顶点 $u_i$ 和 $v_i$。

考虑删除 $T$ 中零个或多个顶点及其相邻的边，使得剩余图形成为一个雪花树。求必须删除的最少顶点数。在本题的约束条件下，总是可以将 $T$ 转换为雪花树。

**说明/提示**

- $3 \leq N \leq 3 \times 10^5$
- $1 \leq u_i < v_i \leq N$
- 给定图是一棵树
- 所有输入值均为整数

**样例 #1**

输入：
```
8
1 3
2 3
3 4
4 5
5 6
5 7
4 8
```

输出：
```
1
```

**样例 #2**

输入：
```
3
1 2
2 3
```

输出：
```
0
```

**样例 #3**

输入：
```
10
1 3
1 2
5 7
6 10
2 8
1 6
8 9
2 7
1 4
```

输出：
```
3
```

### 题解分析与结论

#### 综合分析
本题的核心在于如何通过删除最少的节点，将给定的树转换为雪花树。雪花树的结构要求有一个中心节点，中心节点连接若干个二级节点，每个二级节点再连接若干个叶子节点。题解中常见的思路是枚举每个节点作为中心节点，然后计算其周围节点的度数，通过排序和贪心策略来确定最优的雪花树结构。

#### 题解评分与亮点
1. **作者：yy0707**  
   - **评分：4星**  
   - **关键亮点**：通过枚举每个节点作为中心节点，并对其邻接节点的度数进行排序，利用贪心策略计算最大保留节点数。思路清晰，代码简洁。  
   - **代码核心**：对每个节点的邻接节点按度数排序，计算最大保留节点数。  
   ```cpp
   for(int i=1;i<=n;i++){
       sort(g[i].begin(),g[i].end(),[](int a,int b){return g[a].size()<g[b].size();});
       for(int j=0;j<g[i].size();j++){
           ans=max(ans,(g[g[i][j]].size()-1)*(g[i].size()-j)+(g[i].size()-j)+1);
       }
   }
   ```

2. **作者：Conan15**  
   - **评分：4星**  
   - **关键亮点**：使用树状数组维护后缀和，优化了枚举中心节点和计算最大保留节点数的过程。思路新颖，时间复杂度较低。  
   - **代码核心**：利用树状数组维护每个节点的度数信息，快速计算符合条件的节点数。  
   ```cpp
   for(int u=1;u<=n;u++){
       for(int i=h[u];~i;i=ne[i]){
           int v=e[i];
           change(deg[v],1);
       }
       for(int i=h[u];~i;i=ne[i]){
           int v=e[i];
           ans=max(ans,1+query(deg[v])*1ll*deg[v]);
       }
       for(int i=h[u];~i;i=ne[i]){
           int v=e[i];
           change(deg[v],-1);
       }
   }
   ```

3. **作者：hwc2011**  
   - **评分：4星**  
   - **关键亮点**：通过枚举每个节点作为中心节点，对其邻接节点的度数进行排序，利用贪心策略计算最大保留节点数。思路清晰，代码简洁。  
   - **代码核心**：对每个节点的邻接节点按度数排序，计算最大保留节点数。  
   ```cpp
   for(int i=1;i<=n;i++){
       int tot=0;
       for(auto j:e[i]) a[++tot]=e[j].size();
       sort(a+1,a+1+tot);
       for(int j=1;j<=tot;j++) ans=max(ans,a[tot-j+1]*j+1);
   }
   ```

#### 最优关键思路
最优的思路是枚举每个节点作为中心节点，对其邻接节点的度数进行排序，利用贪心策略计算最大保留节点数。这种方法的时间复杂度为 $O(n \log n)$，能够有效处理大规模数据。

#### 可拓展之处
类似的问题可以扩展到其他树形结构的优化问题，如最小生成树、最大匹配等。通过枚举中心节点并利用贪心策略，可以解决多种树形结构的优化问题。

#### 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
3. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)

#### 个人心得
在调试过程中，发现枚举中心节点时，排序邻接节点的度数是关键。通过优化排序和计算过程，可以显著提高代码的效率。

---
处理用时：42.97秒
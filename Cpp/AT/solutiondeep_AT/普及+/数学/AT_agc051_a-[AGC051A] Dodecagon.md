# 题目信息

# [AGC051A] Dodecagon

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc051/tasks/agc051_a

すぬけ君は、正方形のタイルと正三角形のタイルを無限枚持っています。タイルの辺の長さは全て $ 1 $ です。 これらを使って、辺の長さが $ d $ の正 $ 12 $ 角形を作る方法は何通りあるでしょうか。 この答えを $ 998,244,353 $ で割った余りを計算してください。

厳密に述べると、

- タイルを使う枚数に制限はありません。
- 使ったタイルのうち、どの $ 2 $ 枚も重なっていてはいけません。
- 使ったタイルが覆う領域の和集合は、穴のない正 $ 12 $ 角形でなければなりません。
- 二つの作り方について、一方に回転と平行移動を施す (鏡映は不可) ことでもう一方を得られる、すなわち一方における各タイルがもう一方における同種のタイルと完全に一致するとき、これらの作り方を同一とみなします。

## 说明/提示

### 制約

- $ 1\ \leq\ d\ \leq\ 10^6 $
- 入力中の全ての値は整数である。

### Sample Explanation 1

唯一の作り方を以下の図に示します。 !\[\](https://img.atcoder.jp/agc051/dad0de5f2e5c47119aa1a0da8ed28808.png)

## 样例 #1

### 输入

```
1```

### 输出

```
1```

# AI分析结果

### 题目翻译

すぬけ君有无限个边长为 $1$ 的正方形和正三角形瓷砖。有多少种不同的方法可以用这些瓷砖组成一个边长为 $d$ 的正十二边形？请计算方案数并对 $998,244,353$ 取模。

具体地说：
- 可以使用任意数量的瓷砖。
- 方案中没有两块瓷砖是重叠的。
- 瓷砖所填充的区域必须是一个无孔的正十二边形。
- 如果我们可以将一种方案通过旋转和平移得到另一种方案，则这两个方案是相同的。

输入共一行，一个正整数 $d$，表示正十二边形的边长。

输出共一行，一个正整数，表示方案数对 $998,244,353$ 取模后的结果。

对于 $100\%$ 的数据，$1 \le d \le 10^{6}$。

### 题解分析与结论

#### 综合分析与结论

本题的核心在于如何通过正方形和正三角形瓷砖的组合来构建一个正十二边形，并计算其方案数。通过分析正十二边形的内角和瓷砖的角度关系，可以将问题转化为组合数学中的路径计数问题。

#### 最优关键思路或技巧

1. **角度分析**：正十二边形的内角为 $150^\circ$，恰好是 $90^\circ$（正方形）和 $60^\circ$（正三角形）的和，因此每个角必须由一个正方形和一个正三角形组成。
2. **分层填充**：从外向内逐层填充，每层填充的边长为 $d$，每填充一层，边长减少 $1$，直到边长为 $0$。
3. **组合数学**：将问题转化为从 $(d, d)$ 到 $(0, 0)$ 的路径计数问题，方案数为组合数 $C_{2d}^d$，由于旋转对称性，最终答案为 $\frac{1}{2}C_{2d}^d$。

#### 所选高星题解

##### 题解1：墨笙_Mooos (5星)
- **关键亮点**：详细分析了正十二边形的内角与瓷砖的角度关系，通过分层填充将问题转化为组合数学问题，思路清晰，代码简洁。
- **代码核心**：
  ```cpp
  inline ll fstpow (ll a, ll b, ll p = mod) {
      a %= p; ll Ans = 1;
      while (b) {
          if (b & 1) Ans = Ans * a % p;
          a = a * a % p, b >>= 1;
      }
      return Ans;
  }
  inline ll GetInv (ll x) { return fstpow (x, mod - 2); }
  int main () {
      cin >> d, Fac = Ans = 1;
      For (i, 1, d) Fac = Fac * i % mod;
      Inv = GetInv (Fac), Fac = 1;
      For (i, d + 1, d + d) Fac = Fac * i % mod;
      Ans = Ans * Fac % mod * Inv % mod;
      cout << Ans * GetInv (2) % mod << endl;
      return 0;
  }
  ```

##### 题解2：_Life_ (4星)
- **关键亮点**：通过手玩和图形分析，得出了每层填充的规律，并将问题转化为组合数学问题，思路清晰，代码实现简洁。
- **代码核心**：
  ```cpp
  int qpow(int a,int b) {
      int ans=1;
      for(;b;a=a*a%mod,b>>=1)
          if(b&1)ans=ans*a%mod;
      return ans;
  }
  int C(int n,int m) {
      if(n<m)return 0;
      return fac[n]*inv[m]%mod*inv[n-m]%mod;
  }
  signed main() {
      fac[0]=1;
      rep(i,1,2000000)fac[i]=fac[i-1]*i%mod;
      inv[2000000]=qpow(fac[2000000],mod-2);
      per(i,2000000,1)inv[i-1]=inv[i]*i%mod;
      read(d);
      write(C(2*d,d)*qpow(2,mod-2)%mod);
  }
  ```

### 拓展与推荐题目

#### 可拓展之处
- **类似问题**：类似的问题可以通过角度分析和组合数学来解决，例如使用不同形状的瓷砖构建其他多边形。
- **优化思路**：对于大范围的组合数计算，可以预处理阶乘和逆元，提高计算效率。

#### 推荐题目
1. [P1357 花园](https://www.luogu.com.cn/problem/P1357)
2. [P1976 组合数问题](https://www.luogu.com.cn/problem/P1976)
3. [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)

这些题目涉及组合数学和路径计数问题，与本题的解题思路相似，有助于巩固相关知识。

---
处理用时：37.16秒
# 题目信息

# [AGC051B] Bowling

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc051/tasks/agc051_b

> 平面上にボウリングのピンが何本か立っており、それを $ 4 $ 人の人が異なる角度から眺めています。 $ 1 $ 人にだけ他の人より遥かに多くのピンが見えることはあるでしょうか。

ピンを単純に $ xy $ 平面上の点集合とみなしましょう。 $ 4 $ 人の位置を以下の図に示します。 厳密には、

- **A** さんから見ると、$ y $ 座標が等しい $ 2 $ 本のピンは重なって見えます。
- **B** さんから見ると、($ x $ 座標 - $ y $ 座標) が等しい $ 2 $ 本のピンは重なって見えます。
- **C** さんから見ると、$ x $ 座標が等しい $ 2 $ 本のピンは重なって見えます。
- **D** さんから見ると、($ x $ 座標 + $ y $ 座標) が等しい $ 2 $ 本のピンは重なって見えます。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc051_b/cf17bb504667e73875a26607be26bad6c893bba0.png)

**A**, **B**, **C**, **D** さんに見えるピンの数をそれぞれ $ a,\ b,\ c,\ d $ とします。

以下の条件を全て満たすような何らかのピンの配置を構成してください。

- $ d\ \geq\ 10\ \cdot\ \max\ \{\ a,\ b,\ c\ \} $
- ピンの本数は $ 1 $ 本以上 $ 10^5 $ 本以下である。
- ピンの座標は全て $ 0 $ 以上 $ 10^9 $ 以下の整数である。
- $ 2 $ 本のピンが同じ位置にあることはない。

## 说明/提示

### Sample Explanation 1

\*\*この出力例は出力形式を例示するものであり、正解ではありません。\*\* この出力は問題文中の図に対応し、$ d\ =\ 8,\ a\ =\ b\ =\ c\ =\ 7 $ です。頑張りましたが、AC には届きません。

## 样例 #1

### 输入

```
```

### 输出

```
9

1 1

1 5

2 7

4 4

5 3

6 8

7 5

8 2

8 7```

# AI分析结果

### 题目内容重写
平面上有一些保龄球瓶，四个人从不同的角度观察它们。对于每个人来说，如果两个瓶子的某些坐标值相同，那么它们会被视为重叠。具体来说：

- **A** 从左往右观察，所有 $y$ 坐标相同的瓶子视为重叠。
- **B** 从左下往右上观察，所有 $x$ 坐标与 $y$ 坐标相减的值相同的瓶子视为重叠。
- **C** 从下往上观察，所有 $x$ 坐标相同的瓶子视为重叠。
- **D** 从右下往左上观察，所有 $x$ 坐标与 $y$ 坐标相加的值相同的瓶子视为重叠。

令 $a, b, c, d$ 分别为 **A, B, C, D** 看到的瓶子数量，要求构造一组瓶子的位置，满足以下条件：

1. $d \geq 10 \times \max\{a, b, c\}$
2. 瓶子的数量在 $1$ 到 $10^5$ 之间。
3. 瓶子的坐标均为 $[0, 10^9]$ 内的整数。
4. 不存在两个瓶子坐标相同。

### 题解分析与结论

#### 题解1：墨笙_Mooos (4星)
**关键亮点**：
- 通过构造向量集合，确保 **A, B, C** 视角中大部分点被遮挡，而 **D** 视角能看到所有点。
- 使用十进制分解法确保集合中的点不重复，思路清晰且实现简洁。

**核心代码**：
```cpp
A = 1, B = 100, C = 10;
For (i, 0, 9) For (j, 0, 9) For (k, 0, 9)
    P.emplace_back (A * i + B * j, B * j + C * k);
cout << P.size () << endl;
for (auto& Now : P) cout << Now.first << ' ' << Now.second << endl;
```

#### 题解2：User_Unauthorized (4星)
**关键亮点**：
- 通过随机生成坐标和增量，确保 **A, B, C** 视角中大部分点被遮挡，而 **D** 视角能看到所有点。
- 使用随机数生成器确保点不重复，代码简洁且易于理解。

**核心代码**：
```cpp
constexpr valueType N = 40, V = 5e8;
Engine engine(seed);
Distribution distribution(0, V);
ValueVector X(N), Y(N), D(N);
for (valueType i = 0; i < N; ++i) {
    X[i] = distribution(engine);
    Y[i] = distribution(engine);
    D[i] = distribution(engine);
}
for (auto const &x: X)
    for (auto const &y: Y)
        for (auto const &d: D)
            print(x + d, y + d);
```

### 最优关键思路
1. **构造向量集合**：通过构造与 **A, B, C** 视角平行的向量集合，确保大部分点在这些视角中被遮挡，而 **D** 视角能看到所有点。
2. **随机生成坐标**：通过随机生成坐标和增量，确保点不重复，且满足 **D** 视角的条件。

### 可拓展之处
- 类似的问题可以通过构造特定方向的向量集合或随机生成坐标来解决，确保某些视角中的点被遮挡，而其他视角能看到更多点。

### 推荐题目
1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)
3. [P3384 【模板】轻重链剖分](https://www.luogu.com.cn/problem/P3384)

---
处理用时：30.49秒
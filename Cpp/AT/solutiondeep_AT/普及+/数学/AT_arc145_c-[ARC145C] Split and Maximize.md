# 题目信息

# [ARC145C] Split and Maximize

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc145/tasks/arc145_c

$ (1,2,\ldots,2N) $ の順列 $ P=(P_1,P_2,\ldots,P_{2N}) $ に対し、スコアを以下で定義します。

> $ P $ を順序を保ったまま二つの長さ $ N $ の（連続するとは限らない）部分列 $ A\ =\ (A_1,A_2,\ldots,A_N),B\ =\ (B_1,B_2,\ldots,B_N) $ に分割する。分割を行ったときに得られる $ \displaystyle\sum_{i=1}^{N}A_i\ B_i $ の最大値をスコアとする。

$ (1,2,\ldots,2N) $ の順列全てについてスコアを計算し、それらの最大値を $ M $ とします。 $ (1,2,\ldots,2N) $ の順列のうち、スコアが $ M $ であるものの個数を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- 入力は全て整数

### Sample Explanation 1

考えられる順列 $ 24 $ 通りの中で、スコアの最大値 $ M $ は $ 14 $ です。スコアが $ 14 $ となる順列は $ 16 $ 通りあります。 例えば、順列 $ (1,2,3,4) $ は $ A=(1,3),\ B=(2,4) $ と分割することで、$ \sum\ _{i=1}^{N}A_i\ B_i\ =\ 14 $ となります。

### Sample Explanation 2

$ 998244353 $ で割ったあまりを答えてください。

## 样例 #1

### 输入

```
2```

### 输出

```
16```

## 样例 #2

### 输入

```
10000```

### 输出

```
391163238```

# AI分析结果

### 题目内容重写

#### [ARC145C] Split and Maximize

**题目描述**

对于 $ (1,2,\ldots,2N) $ 的排列 $ P=(P_1,P_2,\ldots,P_{2N}) $，定义其得分为：

> 将 $ P $ 保持顺序不变地分割成两个长度为 $ N $ 的（不一定连续的）子序列 $ A\ =\ (A_1,A_2,\ldots,A_N),B\ =\ (B_1,B_2,\ldots,B_N) $，得分为 $ \displaystyle\sum_{i=1}^{N}A_i\ B_i $ 的最大值。

对于所有 $ (1,2,\ldots,2N) $ 的排列，计算其得分，并设最大得分为 $ M $。求所有排列中得分为 $ M $ 的排列个数，结果对 $ 998244353 $ 取模。

**说明/提示**

**约束条件**

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- 输入均为整数

**样例解释 1**

对于 $ N=2 $，所有可能的排列有 $ 24 $ 种，其中最大得分 $ M $ 为 $ 14 $。得分为 $ 14 $ 的排列有 $ 16 $ 种。例如，排列 $ (1,2,3,4) $ 可以分割为 $ A=(1,3),\ B=(2,4) $，此时得分为 $ \sum\ _{i=1}^{N}A_i\ B_i\ =\ 14 $。

**样例解释 2**

输出结果需要对 $ 998244353 $ 取模。

**样例输入 1**

```
2
```

**样例输出 1**

```
16
```

**样例输入 2**

```
10000
```

**样例输出 2**

```
391163238
```

### 题解分析与结论

#### 综合分析

本题的核心在于如何将排列 $ P $ 分割成两个子序列 $ A $ 和 $ B $，使得 $ \sum_{i=1}^{N}A_iB_i $ 最大化。通过分析，最优的分割方式是将相邻的两个数配对，即 $ (1,2), (3,4), \ldots, (2N-1,2N) $，这样可以最大化每对数的乘积之和。

进一步分析发现，满足条件的排列个数可以通过卡特兰数、阶乘和幂运算的组合来计算。具体来说，答案可以表示为 $ 2^n \times n! \times \text{Catalan}(n) $，其中 $ \text{Catalan}(n) $ 是第 $ n $ 个卡特兰数。

#### 题解评分与亮点

1. **作者：liangbowen (★★★★★)**
   - **亮点**：提供了详细的证明过程，解释了为什么相邻配对是最优的，并通过卡特兰数、阶乘和幂运算的组合给出了最终的答案公式。代码实现简洁高效，时间复杂度为 $ O(n) $。
   - **代码核心思想**：计算阶乘、逆元和卡特兰数，最终通过公式 $ 2^n \times n! \times \text{Catalan}(n) $ 计算答案。

2. **作者：hhhqx (★★★★)**
   - **亮点**：通过感性理解解释了最优分割方式，并引入了卡特兰数的概念。虽然缺少严格的证明，但思路清晰，代码实现也较为简洁。
   - **代码核心思想**：计算阶乘、逆元和卡特兰数，最终通过公式 $ 2^n \times n! \times \text{Catalan}(n) $ 计算答案。

3. **作者：liyixin0514 (★★★★)**
   - **亮点**：通过将问题转化为括号序列的合法匹配，引入了卡特兰数的概念，并详细解释了答案的推导过程。代码实现简洁，时间复杂度为 $ O(n) $。
   - **代码核心思想**：计算阶乘、逆元和卡特兰数，最终通过公式 $ 2^n \times n! \times \text{Catalan}(n) $ 计算答案。

#### 最优关键思路与技巧

1. **相邻配对最优**：通过分析相邻两个数的乘积，证明了相邻配对是最优的分割方式。
2. **卡特兰数应用**：将问题转化为括号序列的合法匹配，利用卡特兰数计算满足条件的排列个数。
3. **阶乘与幂运算**：通过阶乘和幂运算的组合，计算最终的排列个数。

#### 可拓展之处

类似的问题可以通过分析最优分割方式，并结合组合数学中的卡特兰数、阶乘等概念来解决。例如，可以考虑其他类型的排列分割问题，或者将问题转化为其他组合数学问题。

#### 推荐题目

1. [P3200 [HNOI2009]有趣的数列](https://www.luogu.com.cn/problem/P3200)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P2532 [AHOI2012]树屋阶梯](https://www.luogu.com.cn/problem/P2532)

#### 个人心得摘录

- **liangbowen**：通过观察样例和简单的数学推导，得出了最优分割方式，并利用卡特兰数解决了问题。这种通过观察和推导得出结论的方法在解决组合数学问题时非常有效。
- **hhhqx**：虽然缺少严格的证明，但通过感性理解快速得出了结论，并利用卡特兰数解决了问题。这种方法在时间有限的情况下非常实用。
- **liyixin0514**：将问题转化为括号序列的合法匹配，利用卡特兰数解决了问题。这种将问题转化为已知模型的方法在解决复杂问题时非常有用。

### 核心代码片段

```cpp
// 计算阶乘和逆元
fac[0] = ifac[0] = 1;
for(int i = 1; i <= 4e5; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = qpow(fac[i], mod - 2);

// 计算卡特兰数
LL Catalan(int A){ return (C(A, A + A) - C(A - 1, A + A) + mod) % mod; }

// 最终答案计算
cout << qpow(2, n) * fac[n] % mod * Catalan(n) % mod;
```

这段代码的核心思想是通过预处理阶乘和逆元，计算卡特兰数，并最终通过公式 $ 2^n \times n! \times \text{Catalan}(n) $ 计算答案。

---
处理用时：50.53秒
# 题目信息

# [ARC156B] Mex on Blackboard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc156/tasks/arc156_b

有限個の非負整数からなる多重集合 $ S $ にたいして、$ \mathrm{mex}(S) $ を、$ S $ に含まれない最小の非負整数と定義します。例えば、$ \mathrm{mex}(\lbrace\ 0,0,\ 1,3\rbrace\ )\ =\ 2,\ \mathrm{mex}(\lbrace\ 1\ \rbrace)\ =\ 0,\ \mathrm{mex}(\lbrace\ \rbrace)\ =\ 0 $ です。

黒板に $ N $ 個の非負整数が書かれており、$ i $ 番目の非負整数は $ A_i $ です。

あなたは、以下の操作をちょうど $ K $ 回行います。

- 黒板に書かれている非負整数を $ 0 $ 個以上選ぶ。選んだ非負整数からなる多重集合を $ S $ として、$ \mathrm{mex}(S) $ を黒板に $ 1 $ 個書き込む。
 
最終的に黒板に書かれている非負整数の多重集合としてありうるものの個数を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,K\ \leq\ 2\times\ 10^5 $
- $ 0\leq\ A_i\leq\ 2\times\ 10^5 $
- 入力される数値は全て整数
 
### Sample Explanation 1

操作後に得られる多重集合は、以下の $ 3 $ 通りです。 - $ \lbrace\ 0,0,1,3\ \rbrace $ - $ \lbrace\ 0,1,1,3\rbrace $ - $ \lbrace\ 0,1,2,3\ \rbrace $ 例えば、$ \lbrace\ 0,1,1,3\rbrace $ は黒板に書かれている $ 0 $ を選び、$ S=\lbrace\ 0\rbrace $ として操作をすることで得られます。

### Sample Explanation 2

操作後に得られる多重集合は、以下の $ 2 $ 通りです。 - $ \lbrace\ 0,0,0\ \rbrace $ - $ \lbrace\ 0,0,1\rbrace $ 操作で選ぶ整数は $ 0 $ 個でも良いことに注意してください。

## 样例 #1

### 输入

```
3 1

0 1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
2 1

0 0```

### 输出

```
2```

## 样例 #3

### 输入

```
5 10

3 1 4 1 5```

### 输出

```
7109```

# AI分析结果

### 题目内容重写
【题目描述】
有限个非负整数构成的多重集合 $S$，定义 $\mathrm{mex}(S)$ 为 $S$ 中不包含的最小非负整数。例如，$\mathrm{mex}(\lbrace\ 0,0,\ 1,3\rbrace\ )\ =\ 2$，$\mathrm{mex}(\lbrace\ 1\ \rbrace)\ =\ 0$，$\mathrm{mex}(\lbrace\ \rbrace)\ =\ 0$。

黑板上写有 $N$ 个非负整数，第 $i$ 个非负整数为 $A_i$。你可以进行恰好 $K$ 次操作，每次操作从黑板上选择任意个非负整数，构成多重集合 $S$，并将 $\mathrm{mex}(S)$ 写入黑板。求最终黑板上可能出现的多重集合的个数，结果对 $998244353$ 取模。

### 题解分析与结论
1. **关键思路**：所有题解的核心思路都是通过枚举最终集合中的最大数 $m$，并计算在 $K$ 次操作后能够形成的多重集合的个数。通过插板法或组合数学的方法，计算在 $0$ 到 $m$ 之间分配 $K$ 次操作的方案数。
2. **难点对比**：不同题解在枚举最大数 $m$ 时的处理方式略有不同，有的题解通过逐步增加 $m$ 并计算贡献，有的则通过预处理阶乘和逆元来优化组合数的计算。
3. **最优思路**：最优的思路是通过枚举最大数 $m$，并利用组合数学中的插板法计算方案数，同时通过预处理阶乘和逆元来优化组合数的计算。

### 所选高星题解
#### 题解1：作者：heaksicn (4星)
- **关键亮点**：通过枚举最大数 $m$，并利用插板法计算方案数，代码简洁且时间复杂度为 $O(k)$。
- **代码核心**：
  ```cpp
  int ans = 0;
  for(int i=1;i<=k;i++){
      ans=(ans+C(g[i]+k-i,k-i+1))%mod; 
  }
  ans++;
  ```
  **核心思想**：通过枚举 $i$ 次操作后，计算在 $0$ 到 $m$ 之间分配剩余 $k-i$ 次操作的方案数。

#### 题解2：作者：Otue (4星)
- **关键亮点**：通过枚举最大数 $x$，并利用组合数学中的插板法计算方案数，代码清晰且时间复杂度为 $O(n \log n)$。
- **代码核心**：
  ```cpp
  int res = 0;
  for(int i = 0; i <= N - 5; i++) {
      if(vis[i] == 0) cnt++;
      if(vis[i + 1]) continue;
      if(cnt > k) break;
      res = (res + C(k - cnt + i, i)) % mod;
  }
  ```
  **核心思想**：通过枚举最大数 $x$，并计算在 $0$ 到 $x$ 之间分配 $k-cnt$ 次操作的方案数。

#### 题解3：作者：I_like_magic (4星)
- **关键亮点**：通过枚举最大数 $m$，并利用组合数学中的插板法计算方案数，代码简洁且时间复杂度为 $O(n \log n)$。
- **代码核心**：
  ```cpp
  int ans = 0;
  for(int i = 0; ; i ++) {
      if(f[i]) sum ++;
      if(sum < i) break;
      if(f[i + 1]) continue;
      ans += C(sum - 1, i);
      ans %= P;
  }
  ```
  **核心思想**：通过枚举最大数 $m$，并计算在 $0$ 到 $m$ 之间分配 $K$ 次操作的方案数。

### 最优关键思路
1. **枚举最大数**：通过枚举最终集合中的最大数 $m$，并计算在 $0$ 到 $m$ 之间分配 $K$ 次操作的方案数。
2. **插板法**：利用组合数学中的插板法计算方案数，公式为 $C_{m+K-1}^{K-1}$。
3. **预处理优化**：通过预处理阶乘和逆元来优化组合数的计算，减少时间复杂度。

### 可拓展之处
1. **类似问题**：类似的问题可以通过枚举关键变量，并利用组合数学中的插板法或容斥原理来计算方案数。
2. **优化技巧**：预处理阶乘和逆元是优化组合数计算的常用技巧，适用于需要频繁计算组合数的问题。

### 推荐题目
1. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)
2. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)
3. [P1495 【模板】中国剩余定理](https://www.luogu.com.cn/problem/P1495)

---
处理用时：41.36秒
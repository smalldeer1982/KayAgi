# 题目信息

# [ARC157C] YY Square

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc157/tasks/arc157_c

$ H $ 行 $ W $ 列のマス目の各マスに `X`, `Y` のいずれかの文字が書かれています． 上から $ i $ 行目，左から $ j $ 列目のマスを $ (i,\ j) $ で表します． マス目に書かれている文字は $ H $ 個の文字列 $ S_1,\ S_2,\ \dots,\ S_H $ によって与えられ，$ S_i $ の $ j $ 文字目がマス $ (i,\ j) $ に書かれた文字を表します．

下または右に隣接するマスへの移動を繰り返してマス $ (1,\ 1) $ からマス $ (H,\ W) $ に至る経路 $ P $ に対して，

- 「 $ P $ で通るマスに書かれた文字を順に並べて得られる長さ $ (H\ +\ W\ -\ 1) $ の文字列」を $ \mathrm{str}(P) $ とし，
- 「 $ \mathrm{str}(P) $ 中で `Y` 同士が隣り合う箇所の**個数の $ 2 $ 乗**」を $ P $ の**スコア**と定義します．
 
そのような経路 $ P $ としてあり得るものは $ \displaystyle\binom{H\ +\ W\ -\ 2}{H\ -\ 1} $ 通りありますが，その全てに対するスコアの総和を $ 998244353 $ で割った余りを求めてください．

  $ \binom{N}{K} $ の意味 $ \displaystyle\binom{N}{K} $ は，$ N $ 個の相異なる要素から $ K $ 個を選ぶ場合の数を表す二項係数です．

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 2000 $
- $ 1\ \leq\ W\ \leq\ 2000 $
- $ S_i\ (1\ \leq\ i\ \leq\ H) $ は `X`, `Y` からなる長さ $ W $ の文字列である．
 
### Sample Explanation 1

経路 $ P $ としてあり得るものは $ (1,\ 1)\ \to\ (1,\ 2)\ \to\ (2,\ 2) $ と $ (1,\ 1)\ \to\ (2,\ 1)\ \to\ (2,\ 2) $ の $ 2 $ 通りです． - $ (1,\ 1)\ \to\ (1,\ 2)\ \to\ (2,\ 2) $ の場合，$ \mathrm{str}(P)\ =\ {} $`YYY` であり，$ 1,\ 2 $ 文字目と $ 2,\ 3 $ 文字目の $ 2 $ 箇所で `Y` 同士が隣り合っているので，スコアは $ 2^2\ =\ 4 $ です． - $ (1,\ 1)\ \to\ (2,\ 1)\ \to\ (2,\ 2) $ の場合，$ \mathrm{str}(P)\ =\ {} $`YXY` であり，`Y` 同士が隣り合う箇所は無いので，スコアは $ 0^2\ =\ 0 $ です． したがって，求める総和は $ 4\ +\ 0\ =\ 4 $ となります．

### Sample Explanation 2

$ 2 $ 通りのいずれの経路の場合も $ \mathrm{str}(P)\ =\ {} $`XYY` であり，スコアは $ 1^2\ =\ 1 $ です．

### Sample Explanation 3

スコアの総和を $ 998244353 $ で割った余りを出力してください．

## 样例 #1

### 输入

```
2 2

YY

XY```

### 输出

```
4```

## 样例 #2

### 输入

```
2 2

XY

YY```

### 输出

```
2```

## 样例 #3

### 输入

```
10 20

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY

YYYYYYYYYYYYYYYYYYYY```

### 输出

```
423787835```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个 $H$ 行 $W$ 列的网格，每个格子中写有字符 `X` 或 `Y`。从上到下第 $i$ 行，从左到右第 $j$ 列的格子记为 $(i, j)$。网格中的字符由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \dots, S_H$ 给出，$S_i$ 的第 $j$ 个字符表示格子 $(i, j)$ 中的字符。

从格子 $(1, 1)$ 出发，每次只能向下或向右移动到相邻的格子，最终到达格子 $(H, W)$ 的路径 $P$ 的得分定义为：

- 将路径 $P$ 中经过的格子中的字符按顺序连接成一个长度为 $H + W - 1$ 的字符串 $\mathrm{str}(P)$。
- 得分为 $\mathrm{str}(P)$ 中相邻的两个 `Y` 的个数的平方。

求所有可能的路径 $P$ 的得分之和，结果对 $998244353$ 取模。

#### 说明/提示

- $1 \leq H \leq 2000$
- $1 \leq W \leq 2000$
- $S_i$ 是由 `X` 和 `Y` 组成的长度为 $W$ 的字符串。

### 题解综合分析与结论

该题目要求计算所有从 $(1, 1)$ 到 $(H, W)$ 的路径中，相邻 `Y` 对个数的平方和。由于直接计算平方和较为复杂，大多数题解采用了动态规划（DP）的思路，通过维护多个状态来逐步计算平方和。

#### 关键思路与技巧

1. **平方和的拆分**：通过将平方和拆分为线性部分和常数部分，简化了状态转移。例如，$(a+1)^2 = a^2 + 2a + 1$，这使得我们可以通过维护路径的权值和路径的平方和来逐步计算最终结果。
  
2. **状态设计**：大多数题解设计了多个状态来分别维护路径的权值、权值的平方和以及路径的条数。通过这种方式，可以在转移时方便地计算新增的贡献。

3. **组合数预处理**：部分题解使用了组合数来预处理路径的条数，从而在转移时快速计算新增的贡献。

4. **边界处理**：在处理边界条件时，需要特别注意路径的起点和终点的状态转移，确保不会出现越界或重复计算的情况。

### 所选高星题解

#### 题解1：作者：naoliaok_lovely (4星)

**关键亮点**：
- 通过拆分平方和，维护了路径的权值、权值的平方和以及路径的条数。
- 使用了组合数预处理，优化了路径条数的计算。
- 代码结构清晰，状态转移方程明确。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
        if(c[i][j] == 'X') {
            f[1][i][j] = (f[1][i - 1][j] + f[1][i][j - 1]) % mod;
            f[2][i][j] = (f[2][i - 1][j] + f[2][i][j - 1]) % mod;
        } else {
            f[1][i][j] = (f[1][i - 1][j] + f[1][i][j - 1] + (c[i - 1][j] == 'Y' ? C(i + j - 3, i - 2) : 0) + (c[i][j - 1] == 'Y' ? C(i + j - 3, i - 1) : 0)) % mod;
            f[2][i][j] = (f[2][i - 1][j] + f[2][i][j - 1] + (c[i - 1][j] == 'Y' ? C(i + j - 3, i - 2) + 2 * f[1][i - 1][j] : 0) + (c[i][j - 1] == 'Y' ? C(i + j - 3, i - 1) + 2 * f[1][i][j - 1] : 0)) % mod;
        }
```

#### 题解2：作者：Cure_Wing (4星)

**关键亮点**：
- 通过维护路径的权值、权值的平方和以及路径的条数，实现了状态转移。
- 使用了组合数预处理，优化了路径条数的计算。
- 代码结构清晰，状态转移方程明确。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++) {
        if(c[i - 1][j] == 'Y' && c[i][j] == 'Y' && i > 1) {
            f[i][j] = (f[i][j] + f[i - 1][j] + 2 * g[i - 1][j] + C(i + j - 3, i - 2)) % mod;
            g[i][j] = (g[i][j] + g[i - 1][j] + C(i + j - 3, i - 2)) % mod;
        } else {
            f[i][j] = (f[i][j] + f[i - 1][j]) % mod;
            g[i][j] = (g[i][j] + g[i - 1][j]) % mod;
        }
        if(c[i][j - 1] == 'Y' && c[i][j] == 'Y' && j > 1) {
            f[i][j] = (f[i][j] + f[i][j - 1] + 2 * g[i][j - 1] + C(i + j - 3, j - 2)) % mod;
            g[i][j] = (g[i][j] + g[i][j - 1] + C(i + j - 3, j - 2)) % mod;
        } else {
            f[i][j] = (f[i][j] + f[i][j - 1]) % mod;
            g[i][j] = (g[i][j] + g[i][j - 1]) % mod;
        }
    }
```

#### 题解3：作者：HappyJaPhy (4星)

**关键亮点**：
- 通过维护路径的权值、权值的平方和以及路径的条数，实现了状态转移。
- 使用了组合数预处理，优化了路径条数的计算。
- 代码结构清晰，状态转移方程明确。

**核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++) {
        if(i == 1 && j == 1) continue;
        for(int k = 0; k < 2; k++) {
            int x = i + dx[k], y = j + dy[k];
            if(x < 1 || y < 1) continue;
            f[0][i][j] = (f[0][i][j] + f[0][x][y]) % P;
            if(b[x][y] && b[i][j]) {
                f[1][i][j] = (f[1][i][j] + f[1][x][y] + f[0][x][y]) % P;
                f[2][i][j] = (f[2][i][j] + f[2][x][y] + 2ll * f[1][x][y] + f[0][x][y]) % P;
            } else {
                f[1][i][j] = (f[1][i][j] + f[1][x][y]) % P;
                f[2][i][j] = (f[2][i][j] + f[2][x][y]) % P;
            }
        }
    }
```

### 推荐题目

1. **P1654 OSU!** - 考察平方和的动态规划计算。
2. **CF235B Let's Play Osu!** - 类似的计算平方和的动态规划问题。
3. **P2731 [USACO3.3] 骑马修栅栏** - 考察路径规划和状态转移的经典问题。

---
处理用时：73.45秒
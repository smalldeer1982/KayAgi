# 题目信息

# [ARC163C] Harmonic Mean

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc163/tasks/arc163_c

以下の条件を全て満たす長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ が存在するか判定し、存在するならば一つ構築してください。

- $ \sum_{i=1}^{N}\ \frac{1}{A_i}\ =\ 1 $
- $ A $ の要素は全て相異なる。
- $ 1\ \le\ A_i\ \le\ 10^9(1\ \le\ i\ \le\ N) $
 
$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 500 $
- $ 1\ \le\ N\ \le\ 500 $
 
### Sample Explanation 1

$ 1 $ 個目のテストケースでは、$ N=3 $ です。 $ A=(2,3,6) $ は、$ \frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{6}\ =\ 1 $ かつ他の条件も全て満たすため正当です。 $ 2 $ 個目のテストケースでは、$ N=5 $ です。 $ A=(3,4,5,6,20) $ は、$ \frac{1}{3}\ +\ \frac{1}{4}\ +\ \frac{1}{5}\ +\ \frac{1}{6}\ +\ \frac{1}{20}\ =\ 1 $ かつ他の条件も全て満たすため正当です。 例えば、$ A=(5,5,5,5,5) $ は、$ 1,3 $ 個目の条件を満たしていますが同じ要素が存在するため不適であることに注意してください。

## 样例 #1

### 输入

```
2

3

5```

### 输出

```
Yes

2 3 6 

Yes

3 4 5 6 20```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个整数 \( N \)，判断是否存在一个长度为 \( N \) 的正整数序列 \( A = (A_1, A_2, \dots, A_N) \)，满足以下条件：

1. \( \sum_{i=1}^{N} \frac{1}{A_i} = 1 \)
2. \( A \) 的所有元素互不相同。
3. \( 1 \leq A_i \leq 10^9 \)（\( 1 \leq i \leq N \)）

给定 \( T \) 个测试用例，要求对每个测试用例进行判断，并输出相应的结果。

【说明/提示】

- 约束条件：
  - \( 1 \leq T \leq 500 \)
  - \( 1 \leq N \leq 500 \)

【样例解释】

- 第一个测试用例中，\( N = 3 \)。序列 \( A = (2, 3, 6) \) 满足 \( \frac{1}{2} + \frac{1}{3} + \frac{1}{6} = 1 \)，且其他条件也满足，因此是合法的。
- 第二个测试用例中，\( N = 5 \)。序列 \( A = (3, 4, 5, 6, 20) \) 满足 \( \frac{1}{3} + \frac{1}{4} + \frac{1}{5} + \frac{1}{6} + \frac{1}{20} = 1 \)，且其他条件也满足，因此是合法的。

### 题解分析与结论

本题的核心在于如何构造一个满足条件的序列，使得所有元素的倒数之和为1，并且所有元素互不相同。题解中主要采用了以下几种思路：

1. **裂项相消法**：利用分数拆分的性质，将 \( \frac{1}{n} \) 拆分为 \( \frac{1}{n+1} + \frac{1}{n(n+1)} \)，通过不断拆分来构造序列。
2. **贪心策略**：每次选择当前序列中最小的元素进行拆分，确保序列中的元素尽可能小，避免超过 \( 10^9 \) 的限制。
3. **预处理与动态规划**：通过预处理生成所有可能的序列，然后根据输入的 \( N \) 直接输出结果。

### 评分较高的题解

#### 题解1：作者：syzxzqy (赞：7)

**星级：★★★★★**

**关键亮点：**
- 使用了裂项相消法，通过不断拆分最小的元素来构造序列。
- 采用小根堆来维护序列中的元素，确保每次拆分的最小元素不会重复。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
priority_queue<int,vector<int>,greater<int> > q;
a[t=1]=2;q.push(3);q.push(6);
for(i=1;i<=n-3;){
    x=q.top();q.pop();
    if(q.top()==x+1) {a[++t]=x;;continue;}
    x1=x+1;x2=x*(x+1);
    q.push(x1);q.push(x2);++i;
}
while(t--) q.push(a[t+1]);
while(!q.empty()) cout<<q.top()<<" ",q.pop();
```

#### 题解2：作者：robinyqc (赞：4)

**星级：★★★★**

**关键亮点：**
- 使用贪心策略，每次选择最大的元素进行拆分，确保序列中的元素尽可能小。
- 通过预处理生成所有可能的序列，减少了每次查询的计算量。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
set<int> ans[501];
void pret() {
    ans[3].insert({2,3,6});
    for(int i=3;i<500;i++) {
        int x;
        for(int j:ans[i]) if(!ans[i].count(j+1)&&!ans[i].count(j*(j+1))) {x=j; break;}
        for(int j:ans[i]) if(j!=x) ans[i+1].insert(j);
        ans[i+1].insert(x+1);
        ans[i+1].insert(x*(x+1));
    }
}
```

#### 题解3：作者：rui_er (赞：3)

**星级：★★★★**

**关键亮点：**
- 采用裂项相消法，并结合贪心策略，确保序列中的元素不重复。
- 通过维护两个集合 `bases` 和 `ans`，分别存储可继续拆分的元素和最终结果。
- 代码实现较为复杂，但思路清晰。

**核心代码：**
```cpp
set<ll> bases, ans;
rep(i, 1, 28) bases.insert(1LL << i);
bases.insert((1LL << 28) * 3);
bases.insert((1LL << 27) * 3);
ans = bases;
while(!bases.empty() && (ll)ans.size() < n) {
    ll u = *bases.rbegin();
    bases.erase(u);
    if(u % 2 == 0 && u * 3 <= 1000000000 && !ans.count(u * 3) && !ans.count(u / 2 * 3)) {
        bases.insert(u * 3);
        bases.insert(u / 2 * 3);
        ans.erase(u);
        ans.insert(u * 3);
        ans.insert(u / 2 * 3);
    }
}
```

### 最优关键思路与技巧

1. **裂项相消法**：通过将 \( \frac{1}{n} \) 拆分为 \( \frac{1}{n+1} + \frac{1}{n(n+1)} \)，可以不断扩展序列，确保所有元素的倒数之和为1。
2. **贪心策略**：每次选择当前序列中最小的元素进行拆分，确保序列中的元素尽可能小，避免超过 \( 10^9 \) 的限制。
3. **预处理与动态规划**：通过预处理生成所有可能的序列，然后根据输入的 \( N \) 直接输出结果，减少了每次查询的计算量。

### 可拓展之处

本题的思路可以拓展到其他需要构造特定性质的序列的问题中，例如构造满足特定和或积的序列。类似的算法套路还包括贪心策略、动态规划等。

### 推荐题目

1. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)
2. [P1045 糖果传递](https://www.luogu.com.cn/problem/P1045)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

### 个人心得总结

在本题的解决过程中，裂项相消法和贪心策略的结合是关键。通过不断拆分最小的元素，可以确保序列中的元素不重复，并且满足倒数之和为1的条件。此外，预处理和动态规划的思路也大大减少了计算量，提高了算法的效率。

---
处理用时：49.33秒
# 题目信息

# [ARC171B] Chmax

## 题目描述

对于一个 $1$ 到 $N$ 的排列 $P=(P_1,P_2,\cdots,P_N)$，如下定义 $F(P)$：

- 初始序列 $B=(1,2,\cdots,N)$。只要有一个整数 $i$ 令 $B_i<P_{B_i}$ 存在，就进行下面的操作：
    - 找到最小的满足 $B_j<P_{B_j}$ 的整数 $j$，则将 $B_j$ 替换为 $P_{B_j}$。
  
  将 $F(P)$ 定义为这一过程结束时的 $B$（可以证明这个过程会在有限步数后终止）。

给你一个长度为 $N$ 的序列 $A=(A_1,A_2,\cdots,A_N)$，请问有多少个 $1$ 到 $N$ 的排列 $P$ 满足 $F(P) = A$？答案对 $998244353$ 取模。

## 说明/提示

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq A_i \leq N$
- 所有的输入都是整数。

## 样例 #1

### 输入

```
4

3 3 3 4```

### 输出

```
1```

## 样例 #2

### 输入

```
4

2 2 4 3```

### 输出

```
0```

## 样例 #3

### 输入

```
8

6 6 8 4 5 6 8 8```

### 输出

```
18```

# AI分析结果

### 题目内容重写
对于一个 $1$ 到 $N$ 的排列 $P=(P_1,P_2,\cdots,P_N)$，如下定义 $F(P)$：

- 初始序列 $B=(1,2,\cdots,N)$。只要有一个整数 $i$ 令 $B_i<P_{B_i}$ 存在，就进行下面的操作：
    - 找到最小的满足 $B_j<P_{B_j}$ 的整数 $j$，则将 $B_j$ 替换为 $P_{B_j}$。
  
  将 $F(P)$ 定义为这一过程结束时的 $B$（可以证明这个过程会在有限步数后终止）。

给你一个长度为 $N$ 的序列 $A=(A_1,A_2,\cdots,A_N)$，请问有多少个 $1$ 到 $N$ 的排列 $P$ 满足 $F(P) = A$？答案对 $998244353$ 取模。

### 说明/提示
- $1 \leq N \leq 2 \times 10^5$
- $1 \leq A_i \leq N$
- 所有的输入都是整数。

### 样例 #1
#### 输入
```
4
3 3 3 4
```
#### 输出
```
1
```

### 样例 #2
#### 输入
```
4
2 2 4 3
```
#### 输出
```
0
```

### 样例 #3
#### 输入
```
8
6 6 8 4 5 6 8 8
```
#### 输出
```
18
```

### 题解分析与结论
本题的核心在于理解操作 $F(P)$ 的本质，即将排列 $P$ 中的某些元素进行替换，最终得到序列 $A$。通过分析可以发现，$A$ 中的每个元素必须满足一定的条件，否则无解。具体来说，$A_i$ 必须大于等于 $i$，且 $A_i$ 必须等于 $A_{A_i}$。此外，$A$ 中的元素必须形成若干条链，链的起点和终点需要满足特定的条件。

### 所选高星题解
#### 题解1：作者：rui_er (4星)
**关键亮点**：
- 通过将问题转化为图论问题，将排列 $P$ 中的元素连边，形成若干条链。
- 通过判断 $A$ 中的元素是否满足链的条件，快速判断无解情况。
- 使用乘法原理统计合法排列的数量，代码简洁高效。

**核心代码**：
```cpp
mint cnt = 0, ans = 1;
rep(i, 1, n) {
    cnt += !vis[i];
    if(i == a[i]) {
        ans *= cnt;
        --cnt;
    }
}
cout << ans << endl;
```
**核心思想**：通过维护未使用的起点数量，使用乘法原理计算合法排列的数量。

#### 题解2：作者：是青白呀 (4星)
**关键亮点**：
- 通过图论建模，将排列 $P$ 中的元素连边，形成若干条链和环。
- 通过判断 $A$ 中的元素是否满足链的条件，快速判断无解情况。
- 使用双指针维护未使用的起点数量，计算合法排列的数量。

**核心代码**：
```cpp
int cnt = 0;
rep(i, 1, n) {
    if(st[i]) cnt++;
    if(a[i] == i) ans = ans * cnt % mo, cnt--;
}
printf("%lld\n", ans);
```
**核心思想**：通过维护未使用的起点数量，使用乘法原理计算合法排列的数量。

#### 题解3：作者：GI录像机 (4星)
**关键亮点**：
- 通过打表观察，发现 $A$ 中满足 $i = A_i$ 的元素是关键。
- 通过判断 $A$ 中的元素是否满足链的条件，快速判断无解情况。
- 使用乘法原理统计合法排列的数量，代码简洁高效。

**核心代码**：
```cpp
int cnt = 0;
for(int i = 1; i <= n; i++) {
    if(!vis[a[i]] && maxn[a[i]]) cnt++;
    vis[a[i]] = 1;
    if(a[i] == i) ans = (1ll * (cnt--) * ans) % MOD;
}
write(ans);
```
**核心思想**：通过维护未使用的起点数量，使用乘法原理计算合法排列的数量。

### 最优关键思路与技巧
1. **图论建模**：将排列 $P$ 中的元素连边，形成若干条链或环，便于分析操作 $F(P)$ 的影响。
2. **无解判断**：通过判断 $A$ 中的元素是否满足链的条件，快速排除无解情况。
3. **乘法原理**：通过维护未使用的起点数量，使用乘法原理计算合法排列的数量。

### 可拓展之处
1. **类似问题**：可以拓展到其他排列相关的图论问题，如排列的环分解、排列的逆序对等。
2. **算法套路**：图论建模与乘法原理的结合，适用于多种排列与图论相关的问题。

### 推荐题目
1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)

### 个人心得总结
- **调试经历**：在判断无解条件时，容易遗漏某些特殊情况，如 $A_i < i$ 或 $A_i \neq A_{A_i}$，需仔细检查。
- **顿悟感想**：通过图论建模，将排列问题转化为图论问题，能够更清晰地分析问题的本质。

---
处理用时：49.81秒
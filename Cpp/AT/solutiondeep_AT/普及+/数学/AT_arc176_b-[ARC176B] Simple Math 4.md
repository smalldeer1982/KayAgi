# 题目信息

# [ARC176B] Simple Math 4

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc176/tasks/arc176_b

$ 2^N $ を $ 2^M\ -\ 2^K $ で割ったあまりの $ 1 $ の位を求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ N\ \le\ 10^{18} $
- $ 1\ \le\ K\ <\ M\ \le\ 10^{18} $
- $ N,M,K $ は整数
 
### Sample Explanation 1

$ 1 $ 個目のテストケースについて、$ 2^9 $ を $ 2^6\ -\ 2^2 $ で割ったあまりは $ 32 $ です。よって $ 32 $ の $ 1 $ の位の $ 2 $ が答えです。

## 样例 #1

### 输入

```
5

9 6 2

123 84 50

95 127 79

1000000007 998244353 924844033

473234053352300580 254411431220543632 62658522328486675```

### 输出

```
2

8

8

8

4```

# AI分析结果

### 题目内容重写
# [ARC176B] Simple Math 4

## 题目描述

给定 $T$ 个测试用例，每个测试用例包含三个整数 $N, M, K$，要求计算 $2^N$ 除以 $2^M - 2^K$ 的余数的个位数。

### 说明/提示

#### 约束条件
- $1 \le T \le 2 \times 10^5$
- $1 \le N \le 10^{18}$
- $1 \le K < M \le 10^{18}$
- $N, M, K$ 是整数

#### 样例解释
对于第一个测试用例，$2^9$ 除以 $2^6 - 2^2$ 的余数是 $32$，因此个位数是 $2$。

### 样例输入
```
5
9 6 2
123 84 50
95 127 79
1000000007 998244353 924844033
473234053352300580 254411431220543632 62658522328486675
```

### 样例输出
```
2
8
8
8
4
```

---

### 题解综合分析与结论

本题的核心在于计算 $2^N \mod (2^M - 2^K)$ 的个位数。由于 $N, M, K$ 的范围非常大（$10^{18}$），直接计算 $2^N$ 是不现实的。因此，需要通过数学性质来简化问题。

#### 关键思路：
1. **模运算性质**：利用模运算的性质，将 $2^N \mod (2^M - 2^K)$ 转化为 $2^{N - (M - K)} \mod (2^M - 2^K)$，直到 $N < M$。
2. **特殊情况处理**：当 $M = K + 1$ 时，$2^M - 2^K = 2^K$，此时若 $N \ge K$，余数为 $0$；否则余数为 $2^N$。
3. **个位数规律**：$2^N$ 的个位数具有周期性，每4次循环一次（2, 4, 8, 6），因此可以通过 $N \mod 4$ 快速得到个位数。

#### 最优技巧：
- **循环减模**：通过不断减去 $(M - K)$，将 $N$ 降到 $M$ 以下，避免了直接计算大数幂。
- **个位数预计算**：利用 $2^N$ 的个位数周期性，提前存储结果，实现 $O(1)$ 查询。

---

### 高星题解推荐

#### 题解1：Register_int (★★★★★)
**关键亮点**：
- 通过循环减模的方式，将 $N$ 降到 $M$ 以下，避免了直接计算大数幂。
- 代码简洁，逻辑清晰，处理了特殊情况 $M = K + 1$。

**核心代码**：
```cpp
if (m - 1 == k) { printf("%d\n", m - 1 <= n ? 0 : qpow(2, n)); continue; }
if (n < m) { printf("%d\n", qpow(2, n)); continue; }
n = n - ((n - m) / (m - k) + 1) * (m - k);
printf("%d\n", qpow(2, n));
```

#### 题解2：xuezhiyu (★★★★☆)
**关键亮点**：
- 详细分析了不同情况下的处理方法，特别是 $M = K + 1$ 和 $M \ne K + 1$ 的情况。
- 利用二进制表示和带余数除法的性质，进一步简化了问题。

**核心代码**：
```cpp
if (m == k + 1) {
    if (n >= k) puts("0");
    else cout << mods2[n % 4] << endl;
} else if (n < m) {
    cout << mods2[n % 4] << endl;
} else {
    cout << (((mods2[((n - k) % (m - k)) % 4]) * mods2[k % 4]) % 10) << endl;
}
```

#### 题解3：hejianxing (★★★★☆)
**关键亮点**：
- 通过构造 $2^n \equiv 2^{n - (m - k)} \pmod {(2^m - 2^k)}$，简化了问题。
- 代码实现简洁，处理了特殊情况 $M = K + 1$。

**核心代码**：
```cpp
if (m - k == 1) {
    if (n >= k) printf("0\n");
    else printf("%lld\n", qpow(2, n, 10));
    continue;
}
if (n >= m) n -= (n - m) / (m - k) * (m - k);
if (n >= m) n -= (m - k);
printf("%lld\n", qpow(2, n, 10));
```

---

### 最优关键思路与技巧
1. **循环减模**：通过不断减去 $(M - K)$，将 $N$ 降到 $M$ 以下，避免了直接计算大数幂。
2. **个位数预计算**：利用 $2^N$ 的个位数周期性，提前存储结果，实现 $O(1)$ 查询。
3. **特殊情况处理**：当 $M = K + 1$ 时，直接判断 $N$ 与 $K$ 的关系，避免不必要的计算。

---

### 可拓展之处
- **类似问题**：可以扩展到其他幂次的模运算问题，如 $3^N \mod (3^M - 3^K)$。
- **循环节优化**：对于其他基数的幂次，也可以利用循环节的性质进行优化。

---

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)
3. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965)

---

### 个人心得摘录
- **调试经历**：在处理 $M = K + 1$ 的情况时，容易忽略 $N \ge K$ 时的余数为 $0$，导致错误。
- **顿悟感想**：通过观察 $2^N$ 的个位数周期性，发现可以大大简化问题，避免了复杂的计算。

---
处理用时：48.07秒
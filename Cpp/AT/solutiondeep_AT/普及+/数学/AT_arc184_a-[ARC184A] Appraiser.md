# 题目信息

# [ARC184A] Appraiser

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc184/tasks/arc184_a

この問題は **インタラクティブ** な問題であり、 **ジャッジは適応的(adaptive)** です。詳しくは注意点を参照してください。  
**また、問題文中のパラメータは $ N=1000,M=10,Q=950 $ で固定されています。**

硬貨が $ N $ 枚あり、 $ 1,2,\dots,N $ の番号が付けられています。  
これらの硬貨のうち、丁度 $ M $ 枚が偽物です。

鑑定士は $ 1 $ 度の鑑定で $ 2 $ つの硬貨が同種か異種かを判定できます。厳密には、

- $ 2 $ つの硬貨が「双方とも本物」「双方とも偽物」のどちらかであれば、同種と判定する。
- そうでないとき、異種と判定する。

$ Q $ 回以下の鑑定で、全ての偽物の硬貨を特定してください。

### Input &amp; Output Format

この問題はインタラクティブな問題です。  
最初に、 $ N,M,Q $ を標準入力から受け取ってください。

> $ N $ $ M $ $ Q $

次に、以下の流れで鑑定を $ 0 $ 回以上 $ Q $ 回以下行ってください。

まず、次の形式で標準出力に出力することで、硬貨 $ x,y $ を鑑定することを表します。 (末尾に改行を入れること。)

> ? $ x $ $ y $

ここで、 $ x,y $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。

これに対するジャッジシステムの応答は、以下の $ 3 $ 通りです。

```
0
```

応答が `0` であるとき、硬貨 $ x,y $ が同種であることを表します。

```
1
```

応答が `1` であるとき、硬貨 $ x,y $ が異種であることを表します。

```
-1
```

応答が `-1` であるとき、不当な鑑定であることを表します。具体的には

- 出力した $ x,y $ が制約を満たさなかった
- $ Q $ 回を超えて鑑定が行われた

の少なくともひとつが満たされた際にこの応答を行います。  
この応答を受け取った場合、プログラムはすでに不正解とみなされています。直ちにプログラムを終了してください。

最後に、次の形式で標準出力に出力することで、硬貨 $ A_1,A_2,\dots,A_{M} $ が偽物であると解答します。 (末尾に改行を入れること。)

> ! $ A_1 $ $ A_2 $ $ \dots $ $ A_{M} $

ここで、 $ A_i $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。  
この出力の後、直ちにプログラムを終了してください。

なお、全ての出力について、出力が指定された形式を満たさなかった場合もプログラムが不正解とみなされます。 その後 `-1` が返答されるので、その場合も直ちにプログラムを終了してください。

## 说明/提示

### 制約

- $ \color{red}{N\ =\ 1000} $
- $ \color{red}{M\ =\ 10} $
- $ \color{red}{Q\ =\ 950} $

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。** そうしなかった場合、ジャッジ結果が TLE や WA となる可能性があります。
- 解答を出力したら (または `-1` を受け取ったら) ただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください。
- **この問題のジャッジシステムは、適応的(adaptive)です。** つまり、ジャッジシステムは、任意のタイミングにおいて、整合性がとれる限り、偽物の硬貨として想定しているものを変更する可能性があります。詳しくは入出力例も参照してください。

### 入出力例

この入力では $ N=5,M=2,Q=10 $ であり、ジャッジシステムは最初硬貨 $ 1,2 $ が偽物であると想定しています。

なお、この例は制約を満たさないので、ジャッジには含まれないことに注意してください。

入力出力説明`5 2 10`$ N,M,Q $ が与えられます。`? 1 2`硬貨 $ 1,2 $ について鑑定を行います。`0`硬貨 $ 1,2 $ は同種だと判定します。`? 1 3`硬貨 $ 1,3 $ について鑑定を行います。`1`硬貨 $ 1,3 $ は異種だと判定します。`? 1 4`硬貨 $ 1,4 $ について鑑定を行います。`1`硬貨 $ 1,4 $ は異種だと判定します。`! 1 2`硬貨 $ 1,2 $ が偽物だと解答します。確かに硬貨 $ 1,2 $ は偽物だと想定されていますが、硬貨 $ 3,4 $ を偽物であると想定しても整合性が取れます。  
よって、ジャッジシステムは偽物の硬貨として想定しているものを硬貨 $ 3,4 $ に変更できます。  
これにより、ジャッジシステムは不正解の判定を下すこともあります。

# AI分析结果

### 题目内容重写

#### [ARC184A] Appraiser

**题目描述**

这个问题是一个**交互式**问题，**评测系统是自适应的**。详细信息请参考注意事项。  
**此外，问题中的参数固定为 $N=1000, M=10, Q=950$。**

有 $N$ 枚硬币，编号为 $1,2,\dots,N$。  
这些硬币中，恰好有 $M$ 枚是假币。

鉴定师每次鉴定可以判断两枚硬币是否同种。具体来说：

- 如果两枚硬币“都是真币”或“都是假币”，则判定为同种。
- 否则，判定为异种。

在不超过 $Q$ 次鉴定的情况下，找出所有假币。

**输入输出格式**

这个问题是交互式的。  
首先，从标准输入读取 $N, M, Q$。

> $N$ $M$ $Q$

接下来，按照以下流程进行最多 $Q$ 次鉴定。

首先，通过以下格式向标准输出输出，表示对硬币 $x, y$ 进行鉴定。（末尾需换行。）

> ? $x$ $y$

这里，$x, y$ 必须是 $1$ 到 $N$ 之间的不同整数。

评测系统的响应有以下三种：

```
0
```

响应为 `0` 时，表示硬币 $x, y$ 是同种。

```
1
```

响应为 `1` 时，表示硬币 $x, y$ 是异种。

```
-1
```

响应为 `-1` 时，表示鉴定无效。具体来说：

- 输出的 $x, y$ 不满足约束条件
- 鉴定次数超过 $Q$ 次

当收到 `-1` 响应时，程序已被判定为错误。请立即终止程序。

最后，通过以下格式向标准输出输出，表示硬币 $A_1, A_2,\dots,A_{M}$ 是假币。（末尾需换行。）

> ! $A_1$ $A_2$ $ \dots $ $A_{M}$

这里，$A_i$ 必须是 $1$ 到 $N$ 之间的不同整数。  
输出后，请立即终止程序。

**注意事项**

- **每次输出后，请确保在末尾换行并刷新标准输出。** 否则，评测结果可能会是 TLE 或 WA。
- 输出答案后（或收到 `-1` 响应后），请立即终止程序。否则，评测结果不确定。
- 多余的换行会被视为无效输出。
- **评测系统是自适应的。** 即，评测系统可以在任何时刻，在保持一致性的前提下，改变假币的设定。详细信息请参考输入输出示例。

### 题解分析与结论

#### 题解对比与评分

1. **作者：wmrqwq (赞：6)**
   - **评分：4星**
   - **关键亮点**：提出了分组策略，通过将硬币分为每组11个，利用假币数量有限的特性，减少了鉴定次数。通过找到一组全为真币的组，进一步减少了鉴定次数。
   - **代码实现**：通过分组鉴定，记录每组硬币的真假关系，最后通过已知的真币确定所有假币。
   - **个人心得**：通过分组策略，成功将鉴定次数从999次减少到919次，优化了算法效率。

2. **作者：zdd6310 (赞：4)**
   - **评分：4星**
   - **关键亮点**：提出了将硬币分为每组10个的策略，通过比较组内硬币的真假关系，进一步减少了鉴定次数。通过找到一组全为真币的组，确定假币的位置。
   - **代码实现**：通过分组鉴定，记录每组硬币的真假关系，最后通过已知的真币确定所有假币。
   - **个人心得**：通过分组策略，成功将鉴定次数从999次减少到910次，优化了算法效率。

3. **作者：WZWZWZWY (赞：2)**
   - **评分：4星**
   - **关键亮点**：提出了将硬币分为每组11个的策略，通过比较组内硬币的真假关系，进一步减少了鉴定次数。通过找到一组全为真币的组，确定假币的位置。
   - **代码实现**：通过分组鉴定，记录每组硬币的真假关系，最后通过已知的真币确定所有假币。
   - **个人心得**：通过分组策略，成功将鉴定次数从999次减少到920次，优化了算法效率。

#### 最优关键思路与技巧

1. **分组策略**：将硬币分为若干组，每组包含固定数量的硬币，通过比较组内硬币的真假关系，减少鉴定次数。
2. **利用假币数量有限的特性**：由于假币数量有限，可以通过找到一组全为真币的组，进一步减少鉴定次数。
3. **通过已知的真币确定假币**：通过找到一组全为真币的组，利用已知的真币与其他组的硬币进行比较，确定假币的位置。

#### 可拓展之处

1. **类似问题**：在需要减少交互次数的交互式问题中，分组策略和利用已知信息减少鉴定次数的思路可以广泛应用。
2. **优化思路**：在分组时，可以通过调整每组的大小，进一步优化鉴定次数。

#### 推荐题目

1. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

#### 个人心得总结

- **调试经历**：在实现分组策略时，需要注意组内硬币的真假关系记录，避免遗漏或错误。
- **踩坑教训**：在分组时，组的大小选择需要谨慎，过大或过小都会影响鉴定次数。
- **顿悟感想**：通过分组策略，成功将鉴定次数从999次减少到919次，优化了算法效率。

### 核心代码片段

```cpp
#include <bits/stdc++.h>
using namespace std;

bool zs[1005]; // 记录与组头是否相同 
vector <int> un, ans; // 包含假币的组，假币的具体位置 

int main() {
	int n, m, q, x; cin >> n >> m >> q;
	
	int gr_size = 11, gr = 90, rel; // 每一组的大小，组数，rel记录一个真币 
	
	for (int i = 1; i <= gr; i++) {
		int st = gr_size * (i - 1) + 1; // 组头 
		bool t = 1; // 是否11个全相同 
		for (int j = 1; j < gr_size; j++) {
			cout << "? " << st << " " << st + j << endl;
			cin >> x;
			zs[st + j] = zs[st] ^ x;
			if (x == 1) t = 0;
		}
		if (t) rel = st; // 如果11个全相同，必定都是真币。记录一个真币 
		else un.push_back(st); // 否则一定有假币，加入un 
	}
	
	for (int i : un) {
		cout << "? " << i << " " << rel << endl;
		cin >> x;
		for (int j = 0; j < gr_size; j++) 
			if (zs[i + j] ^ x) ans.push_back(i + j);
	}
	
	int st = gr * gr_size; // 剩下的10个单独询问，st是组头 
	for (int i = 1; i <= 10; i++) {
		cout << "? " << rel << " " << st + i << endl;
		cin >> x;
		if (x) ans.push_back(st + i);
	}
	
	cout << "!";
	for (int i : ans) cout << " " << i;
	cout << endl;
}
```

**核心实现思想**：通过分组鉴定，记录每组硬币的真假关系，最后通过已知的真币确定所有假币。

---
处理用时：69.71秒
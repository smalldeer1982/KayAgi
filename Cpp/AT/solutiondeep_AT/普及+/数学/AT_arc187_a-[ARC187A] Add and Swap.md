# 题目信息

# [ARC187A] Add and Swap

## 题目描述

给定两个整数 $N,K$ 与一个长度为 $N$ 的数列 $A=(A_1,\dots,A_N)$。

问是否能对 $A$ 执行不超过 $500000$ 次以下的操作，使 $A$ 变为单调不减数列：

- 选择一个 $i$ 满足 $1\le i<N$，将 $A_{i+1}+k \to A_i$ 且 $A_{i}\to A_{i+1}$，注意两种操作同时进行。

如果可以，请输出具体方案。

## 说明/提示

输入的所有数字均为整数。

$2\le N\le 50$

$1\le K\le 50$

$1\le A_i\le 50$

Translated by @[ARIS2_0](https://www.luogu.com.cn/user/1340759)

## 样例 #1

### 输入

```
3 2
3 6 4```

### 输出

```
Yes
1
2```

## 样例 #2

### 输入

```
3 3
1 5 8```

### 输出

```
Yes
2
2 2```

# AI分析结果

### 题目内容重写

#### [ARC187A] Add and Swap

**题目描述**

给定两个整数 $N,K$ 与一个长度为 $N$ 的数列 $A=(A_1,\dots,A_N)$。

问是否能对 $A$ 执行不超过 $500000$ 次以下的操作，使 $A$ 变为单调不减数列：

- 选择一个 $i$ 满足 $1\le i<N$，将 $A_{i+1}+k \to A_i$ 且 $A_{i}\to A_{i+1}$，注意两种操作同时进行。

如果可以，请输出具体方案。

**说明/提示**

输入的所有数字均为整数。

$2\le N\le 50$

$1\le K\le 50$

$1\le A_i\le 50$

**样例 #1**

**输入**

```
3 2
3 6 4
```

**输出**

```
Yes
1
2
```

**样例 #2**

**输入**

```
3 3
1 5 8
```

**输出**

```
Yes
2
2 2
```

### 题解综合分析与结论

本题的核心在于通过有限次数的操作使数列变为单调不减。操作的本质是交换相邻元素并将其中一个元素加上 $K$。题解中常见的思路是通过对某个位置连续操作两次，使得相邻两个元素同时增加 $K$，从而逐步调整数列的顺序。

#### 最优关键思路与技巧

1. **连续操作两次**：通过对某个位置连续操作两次，可以使得相邻两个元素同时增加 $K$，从而在不改变相对顺序的情况下调整数列。
2. **分段处理**：将数列分为前 $n-1$ 个元素和最后一个元素，分别处理。前 $n-1$ 个元素通过连续操作两次调整顺序，最后一个元素通过特殊操作处理。
3. **特判 $n=2$**：当 $n=2$ 时，无法通过连续操作两次调整顺序，需要单独处理。

#### 可拓展之处

- **类似操作**：类似的操作可以应用于其他需要调整数列顺序的问题，尤其是涉及交换和增量操作的题目。
- **分段处理**：在处理复杂问题时，可以将问题分解为多个子问题，分别处理，最后合并结果。

### 推荐题目

1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 所选高星题解

#### 题解1：GoldSpade (5星)

**关键亮点**：
- 通过连续操作两次调整数列顺序，思路清晰。
- 详细分析了 $n=2$ 的特殊情况，处理得当。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for (int i = 2; i < n; i++) {
    while (a[i] < a[i - 1]) {
        a[i] += K, a[i + 1] += K;
        res.push_back(i), res.push_back(i);
    }
}
```

#### 题解2：Hadtsti (4星)

**关键亮点**：
- 通过差分序列分析，提出了一种新的调整方法。
- 详细分析了操作对差分序列的影响，思路新颖。
- 代码实现简洁，操作次数控制得当。

**核心代码**：
```cpp
for (int i = 1; i < n; i++) {
    while (a[i] < 0) {
        for (int j = n - 1; j >= i; j--) ans.push_back(j);
        for (int j = i; j < n; j++) ans.push_back(j);
        a[i] += k;
        a[n] += (n - i - 1) * k;
    }
}
```

#### 题解3：Binah_cyc (4星)

**关键亮点**：
- 通过分段处理，分别调整前 $n-1$ 个元素和最后一个元素，思路清晰。
- 详细分析了 $n=2$ 的特殊情况，处理得当。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for (int i = 2; i < n; i++) {
    if (a[i] < a[i - 1]) {
        int delta = (a[i - 1] - a[i] + k - 1) / k;
        for (int t = 1; t <= delta; t++) print(i), print(i);
        a[i] += delta * k, a[i + 1] += delta * k;
    }
}
```

### 个人心得总结

- **调试经历**：在处理 $n=2$ 的情况时，需要特别注意操作次数的限制，避免无限循环。
- **踩坑教训**：在调整数列顺序时，需要确保操作次数不超过限制，否则会导致超时。
- **顿悟感想**：通过连续操作两次，可以有效地调整数列顺序，这种方法在类似问题中也可以应用。

---
处理用时：40.59秒
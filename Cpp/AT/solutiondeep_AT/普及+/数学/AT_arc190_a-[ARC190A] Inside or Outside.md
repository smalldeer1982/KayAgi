# 题目信息

# [ARC190A] Inside or Outside

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc190/tasks/arc190_a

整数列 $ x\ =\ (x_1,\ \ldots,\ x_N) $ があり，$ x_1=\cdots=x_N=0 $ で初期化されています．

あなたはこの整数列について，$ M $ 回の操作を行います．$ i $ 回目の操作では，$ 1\leq\ L_i\leq\ R_i\leq\ N $ を満たす整数の組 $ (L_i,\ R_i) $ が与えられるので，以下の $ 3 $ つのうち**ちょうど** $ 1 $ つを行います．

- 操作 $ 0 $：何もしない．この操作にはコストが $ 0 $ かかる．
- 操作 $ 1 $：$ 1\leq\ j\leq\ N $ を満たす各整数 $ j $ に対して，$ L_i\leq\ j\leq\ R_i $ を**満たす**ならば $ x_j=1 $ と定める．この操作にはコストが $ 1 $ かかる．
- 操作 $ 2 $：$ 1\leq\ j\leq\ N $ を満たす各整数 $ j $ に対して，$ L_i\leq\ j\leq\ R_i $ を**満たさない**ならば $ x_j=1 $ と定める．この操作にはコストが $ 1 $ かかる．

あなたの目標は，最終的に $ x_1=\cdots=x_N=1 $ が成り立つようにすることです．この目標が達成できるか否かを判定してください．目標が達成可能な場合には，そのような方法のうち操作にかかるコストの総和が最小となるものをひとつ答えてください．

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 1000000 $
- $ 1\leq\ M\leq\ 200000 $
- $ 1\leq\ L_i\leq\ R_i\leq\ N $
- 入力される値はすべて整数

### Sample Explanation 1

出力例では $ x $ は次のように変化します． - はじめ $ x=(0,0,0,0,0) $ である． - $ 1 $ 回目の操作で操作 $ 2 $ を行う．$ x_1,x_5 $ が $ 1 $ になり，$ x=(1,0,0,0,1) $ になる． - $ 2 $ 回目の操作で操作 $ 0 $ を行う．$ x=(1,0,0,0,1) $ になる． - $ 3 $ 回目の操作で操作 $ 1 $ を行う．$ x_1,x_2,x_3,x_4 $ が $ 1 $ になり，$ x=(1,1,1,1,1) $ になる． - $ 4 $ 回目の操作で操作 $ 0 $ を行う．$ x=(1,1,1,1,1) $ になる．

## 样例 #1

### 输入

```
5 4
2 4
3 5
1 4
2 5```

### 输出

```
2
2 0 1 0```

## 样例 #2

### 输入

```
5 4
1 3
1 5
2 4
3 5```

### 输出

```
1
0 1 0 0```

## 样例 #3

### 输入

```
5 2
1 3
2 5```

### 输出

```
2
1 1```

## 样例 #4

### 输入

```
5 2
1 3
2 4```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

#### [ARC190A] Inside or Outside

**题目描述**

给定一个长度为 $N$ 的整数序列 $x = (x_1, \ldots, x_N)$，初始时所有元素均为 $0$。你需要对这个序列进行 $M$ 次操作，每次操作给定一个区间 $[L_i, R_i]$，并选择以下三种操作之一：

- **操作 0**：不进行任何操作，成本为 $0$。
- **操作 1**：将区间 $[L_i, R_i]$ 内的所有元素设为 $1$，成本为 $1$。
- **操作 2**：将区间 $[L_i, R_i]$ 外的所有元素设为 $1$，成本为 $1$。

你的目标是通过这些操作使得最终所有元素都为 $1$，并且总成本最小。如果无法实现目标，输出 `-1`。

**输入格式**

第一行包含两个整数 $N$ 和 $M$，表示序列的长度和操作次数。接下来 $M$ 行，每行包含两个整数 $L_i$ 和 $R_i$，表示每次操作的区间。

**输出格式**

如果目标可以实现，输出最小成本和对应的操作序列；否则输出 `-1`。

**样例解释**

**样例 1**

输入：
```
5 4
2 4
3 5
1 4
2 5
```
输出：
```
2
2 0 1 0
```

**样例 2**

输入：
```
5 4
1 3
1 5
2 4
3 5
```
输出：
```
1
0 1 0 0
```

**样例 3**

输入：
```
5 2
1 3
2 5
```
输出：
```
2
1 1
```

**样例 4**

输入：
```
5 2
1 3
2 4
```
输出：
```
-1
```

### 题解分析与结论

#### 综合分析

本题的核心在于通过最少的操作使得整个序列的所有元素都变为 $1$。由于每次操作可以选择对区间内或区间外的元素进行修改，因此需要仔细分析区间的覆盖情况。所有题解都采用了分类讨论的策略，根据不同的区间覆盖情况来决定如何选择操作。

#### 最优关键思路

1. **分类讨论**：根据区间的覆盖情况，分为以下几种情况：
   - 存在一个区间覆盖整个序列 $[1, N]$，直接选择操作 1，成本为 $1$。
   - 存在两个区间不相交，分别选择操作 2，成本为 $2$。
   - 存在两个区间有包含关系，选择操作 1 和操作 2，成本为 $2$。
   - 存在两个区间可以拼接成整个序列，选择操作 1，成本为 $2$。
   - 如果以上情况都不满足，且 $M \geq 3$，则选择三个区间，分别进行操作 1、操作 2、操作 1，成本为 $3$。
   - 如果 $M \leq 2$ 且无法满足上述条件，则输出 `-1`。

2. **排序与贪心**：为了快速判断区间的覆盖情况，通常需要对区间进行排序，然后通过贪心策略选择最优的操作序列。

#### 题解评分与亮点

1. **作者：ARIS2_0**（5星）
   - **亮点**：详细分类讨论，涵盖了所有可能的情况，并且通过排序和贪心策略优化了判断过程。
   - **代码实现**：代码结构清晰，逻辑严谨，易于理解。

2. **作者：RAYMOND_7**（4星）
   - **亮点**：思路清晰，分类讨论较为全面，代码实现简洁。
   - **代码实现**：通过排序和贪心策略快速判断区间的覆盖情况，代码可读性较好。

3. **作者：Jerrywang09**（4星）
   - **亮点**：分类讨论较为全面，代码实现简洁，逻辑清晰。
   - **代码实现**：通过排序和贪心策略快速判断区间的覆盖情况，代码可读性较好。

#### 核心代码片段

```cpp
// 作者：ARIS2_0
for(int i=1;i<=m;i++){
    a[i].id=i,cin>>a[i].l>>a[i].r;
    if(a[i].l==1 and a[i].r==n){
        cout<<"1\n";
        for(int j=1;j<=m;j++){
            cout<<(i==j?1:0)<<" ";
        }
        return 0;
    }
}
sort(a+1,a+m+1);
int id=1, pid=1;
for(int i=2;i<=m;i++){
    if(a[id].r<a[i].l){ // 无交
        cout<<"2\n";
        for(int j=1;j<=m;j++){
            if(a[id].id==j or a[i].id==j)cout<<"2 ";
            else cout<<"0 ";
        }
        return 0;
    }
    if(a[pid].r>=a[i].r){ // 包含
        cout<<"2\n";
        for(int j=1;j<=m;j++){
            if(a[pid].id==j)cout<<"1 ";
            else if(a[i].id==j)cout<<"2 ";
            else cout<<"0 ";
        }
        return 0;
    }
    if(a[i].l==a[i-1].l){ // 包含
        cout<<"2\n";
        for(int j=1;j<=m;j++){
            if(a[i-1].id==j)cout<<"2 ";
            else if(a[i].id==j)cout<<"1 ";
            else cout<<"0 ";
        }
        return 0;
    }
    if(a[id].r>a[i].r)id=i;
    if(a[pid].r<a[i].r)pid=i;
}
if(a[1].l==1 and a[m].r==n){ // 并集为 [1,n]
    cout<<"2\n";
    for(int i=1;i<=m;i++){
        if(a[1].id==i or a[m].id==i)cout<<"1 ";
        else cout<<"0 ";
    }
    return 0;
}
if(m<=2){
    cout<<"-1";return 0;
}
int mid=ceil(m*1.0/2);
cout<<"3\n";
for(int i=1;i<=m;i++){
    if(a[mid].id==i)cout<<"2 ";
    else if(a[mid-1].id==i or a[mid+1].id==i)cout<<"1 ";
    else cout<<"0 ";
}
```

#### 可拓展之处

本题的解题思路可以推广到类似的区间覆盖问题，尤其是需要通过最少的操作覆盖整个区间的情况。类似的题目可以通过分类讨论和贪心策略来解决。

#### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

---
处理用时：55.31秒
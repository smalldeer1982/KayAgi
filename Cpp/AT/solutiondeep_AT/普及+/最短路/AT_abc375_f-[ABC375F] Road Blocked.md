# 题目信息

# [ABC375F] Road Blocked

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc375/tasks/abc375_f

AtCoder国には $ 1 $ から $ N $ の番号がついた $ N $ 個の都市と、$ 1 $ から $ M $ の番号がついた $ M $ 本の道路があります。  
 道路 $ i $ は都市 $ A_i $ と都市 $ B_i $ を双方向に結び長さは $ C_i $ です。

$ Q $ 個のクエリが与えられるので順に処理してください。クエリは以下の $ 2 $ 種類のどちらかです。

- `1 i`：道路 $ i $ が通行止めとなる。
- `2 x y`：通行止めでない道路のみを通るときの都市 $ x $ から都市 $ y $ への最短距離を出力する。都市 $ x $ から都市 $ y $ に到達できないときは代わりに `-1` を出力する。
 
なお、$ 1 $ 種類目のクエリはテストケースごとに $ 300 $ 回以下であることが保証されます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 300 $
- $ 0\ \leq\ M\ \leq\ \frac{N(N-1)}{2} $
- $ 1\leq\ A_i\ <\ B_i\ \leq\ N $
- $ (A_i,B_i) $ は相異なる
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- $ 1\ \leq\ Q\ \leq\ 2\times\ 10^5 $
- $ 1 $ 種類目のクエリにおいて、$ 1\leq\ i\ \leq\ M $
- $ 1 $ 種類目のクエリにおいて与えられる道路は、その時点で通行止めでない
- $ 1 $ 種類目のクエリは $ 300 $ 回以下である
- $ 2 $ 種類目のクエリにおいて、$ 1\leq\ x\ <\ y\ \leq\ N $
- 入力は全て整数である
 
### Sample Explanation 1

\- $ 1 $ 番目のクエリでは、都市 $ 1 $ から都市 $ 3 $ への最短距離である $ 10 $ を出力します。 - $ 2 $ 番目のクエリにより、道路 $ 2 $ が通行止めとなりました。 - $ 3 $ 番目のクエリでは、都市 $ 1 $ から都市 $ 3 $ への最短距離である $ 11 $ を出力します。 - $ 4 $ 番目のクエリにより、道路 $ 1 $ が通行止めとなりました。 - $ 5 $ 番目のクエリでは、都市 $ 1 $ から都市 $ 3 $ には到達できないので、`-1` を出力します。

## 样例 #1

### 输入

```
3 3 5

1 2 5

1 3 10

2 3 6

2 1 3

1 2

2 1 3

1 1

2 1 3```

### 输出

```
10

11

-1```

## 样例 #2

### 输入

```
4 6 6

2 3 1

2 4 1

3 4 1

1 2 1

1 3 1

1 4 1

1 4

1 5

1 6

2 1 2

2 1 3

2 1 4```

### 输出

```
-1

-1

-1```

# AI分析结果

### 题目内容翻译
在 AtCoder 国，有编号从 $1$ 到 $N$ 的 $N$ 个城市，以及编号从 $1$ 到 $M$ 的 $M$ 条道路。道路 $i$ 双向连接城市 $A_i$ 和城市 $B_i$，长度为 $C_i$。

给定 $Q$ 个查询，请依次处理它们。查询分为以下两种类型：
- `1 i`：道路 $i$ 变为禁止通行。
- `2 x y`：输出仅通过未禁止通行的道路时，从城市 $x$ 到城市 $y$ 的最短距离。如果无法从城市 $x$ 到达城市 $y$，则输出 `-1`。

此外，保证每种测试用例中，第一种类型的查询不超过 $300$ 次。

### 综合分析与结论
- **思路对比**：所有题解均采用将删边操作逆序转化为加边操作的思路，先对初始未删边的图使用 Floyd 算法求出全源最短路，之后在加边时更新最短路。
- **算法要点**：核心算法为 Floyd 算法求全源最短路，加边时枚举所有点对，考虑经过新边的最短路径并更新。部分题解提到可以使用 Dijkstra 算法，但 Floyd 算法代码更简洁。
- **解决难点**：主要难点在于删边操作不好处理，通过逆序操作将其转化为加边操作，降低了问题复杂度。同时，由于第一种操作次数不超过 300 次，枚举点对更新最短路的时间复杂度可以接受。

### 高评分题解
- **作者：cjh20090318（5星）**
    - **关键亮点**：思路清晰，详细分析了加边时最短路径的三种情况，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
for(int _=q,i;_>0;--_){
    if(Q[_].op==1){
        i=Q[_].x,add(e[i].u,e[i].v,e[i].w),add(e[i].v,e[i].u,e[i].w);
        for(int u=1;u<=n;u++)for(int v=1;v<=n;v++) 
            d[u][v]=min({d[u][v],d[u][e[i].u]+e[i].w+d[e[i].v][v],d[u][e[i].v]+e[i].w+d[e[i].u][v]});
    }
    else ans[_]=d[Q[_].x][Q[_].y];
}
```
核心思想是逆序处理操作，遇到加边操作时枚举所有点对更新最短路，遇到查询操作则直接获取答案。

- **作者：Binah_cyc（4星）**
    - **关键亮点**：对思路和操作过程描述详细，代码结构清晰，对无法到达的情况有明确判断。
    - **核心代码**：
```cpp
for(int i=q;i>=1;i--)
{
    if(x[i].id==1)
    {
        if(dis[edge[x[i].x].x][edge[x[i].x].y]>edge[x[i].x].val)
        {
            dis[edge[x[i].x].x][edge[x[i].x].y]=edge[x[i].x].val;
            for(int t=1;t<=n;t++)
                for(int y=1;y<=n;y++)
                    dis[t][y]=min({dis[t][y],dis[t][edge[x[i].x].x]+dis[edge[x[i].x].y][y]+edge[x[i].x].val,dis[t][edge[x[i].x].y]+dis[edge[x[i].x].x][y]+edge[x[i].x].val});
        }
    }
    else ans[i]=dis[x[i].x][x[i].y];
}
```
核心思想与上一题解类似，逆序处理操作，加边时更新最短路，查询时记录答案。

- **作者：卡卡卡卡卡卡（4星）**
    - **关键亮点**：明确指出时间复杂度，代码简洁，逻辑清晰。
    - **核心代码**：
```cpp
for(long long i=q;i>=1;i--) 
{
    if (op[i]==1) 
    {
        for(long long x=1;x<=n;x++)
            for(long long y=1;y<=n;y++) 
            {
                dis[x][y]=min(dis[x][y],dis[x][a[l[i]]]+dis[b[l[i]]][y]+c[l[i]]);
                dis[x][y]=min(dis[x][y],dis[x][b[l[i]]]+dis[a[l[i]]][y]+c[l[i]]);
            }
    } 
    else ans[i]=dis[l[i]][r[i]];
}
```
同样是逆序处理操作，加边更新最短路，查询记录答案。

### 最优关键思路或技巧
- **思维方式**：将删边问题逆序转化为加边问题，简化了问题处理难度。
- **算法选择**：使用 Floyd 算法求全源最短路，代码实现简单，适合处理小规模图。
- **代码实现**：加边时枚举所有点对，考虑经过新边的最短路径并更新，确保最短路信息的正确性。

### 可拓展之处
同类型题如动态图的最短路问题，可通过类似的逆序处理操作，将删边转化为加边，结合不同的最短路算法（如 Dijkstra、Bellman-Ford 等）解决。

### 洛谷推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：与本题思路相似，涉及动态更新图的最短路。
- [P3905 道路重建](https://www.luogu.com.cn/problem/P3905)：同样是图的修改和最短路查询问题。
- [P2934 [USACO09JAN]Safe Travel G](https://www.luogu.com.cn/problem/P2934)：涉及图的修改和最短路计算，可通过类似思路解决。

### 个人心得
部分题解提到通常不用 Floyd 算法跑最短路，但本题由于数据规模小且删边次数有限，Floyd 算法得以发挥作用，提醒我们在解题时要根据数据范围和问题特点选择合适的算法。 

---
处理用时：38.08秒
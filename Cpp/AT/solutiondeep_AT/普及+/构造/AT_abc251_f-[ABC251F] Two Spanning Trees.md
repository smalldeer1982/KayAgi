# 题目信息

# [ABC251F] Two Spanning Trees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc251/tasks/abc251_f

$ N $ 頂点 $ M $ 辺の無向グラフ $ G $ が与えられます。 $ G $ は**単純**（自己ループおよび多重辺を持たない）かつ**連結**です。

$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結ぶ無向辺 $ \lbrace\ u_i,\ v_i\ \rbrace $ です。

下記の $ 2 $ つの条件をともに満たすような $ G $ の $ 2 $ つの全域木 $ T_1,T_2 $ を $ 1 $ 組構成してください。（ $ T_1 $ と $ T_2 $ は異なる全域木である必要はありません。）

- $ T_1 $ は下記を満たす。
  
  > $ T_1 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_1 $ に含まれないすべての辺 $ \lbrace\ u,\ v\ \rbrace $ について、$ u $ と $ v $ は $ T_1 $ において祖先と子孫の関係にある。
- $ T_2 $ は下記を満たす。
  
  > $ T_2 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_2 $ に含まれない辺 $ \lbrace\ u,\ v\ \rbrace $ であって、$ u $ と $ v $ が $ T_2 $ において祖先と子孫の関係にあるようなものは存在しない。

ここで、「根付き木 $ T $ において頂点 $ u $ と頂点 $ v $ が祖先と子孫の関係にある」とは、「 $ T $ において $ u $ が $ v $ の祖先である」と「 $ T $ において $ v $ が $ u $ の祖先である」のうちどちらかが成り立つことをいいます。

本問題の制約下において上記の条件を満たす $ T_1 $ と $ T_2 $ は必ず存在することが示せます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \min\lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 入力はすべて整数
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

上記の出力例において、$ T_1 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 4,\ 3\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 4,\ 2\ \rbrace,\ \lbrace\ 6,\ 2\ \rbrace $ を持つ $ G $ の全域木です。この $ T_1 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_1 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 5,\ 1\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 5 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 2\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 2 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 6\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 6 $ の祖先です。 また、$ T_2 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 5\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 2,\ 1\ \rbrace,\ \lbrace\ 1,\ 6\ \rbrace $ を持つ $ G $ の全域木です。この $ T_2 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_2 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 4,\ 3\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 3 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 2,\ 6\ \rbrace $ について、頂点 $ 2 $ と頂点 $ 6 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 4,\ 2\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 2 $ は祖先と子孫の関係にありません。

### Sample Explanation 2

$ 3 $ 本の辺 $ \lbrace\ 1,\ 2\rbrace,\ \lbrace\ 1,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace $ を持つ木 $ T $ が $ G $ の唯一の全域木です。 $ G $ の辺のうちこの木 $ T $ に含まれない辺は存在しないので、明らかに、$ T $ は $ T_1 $ の条件と $ T_2 $ の条件をともに満たします。

## 样例 #1

### 输入

```
6 8

5 1

4 3

1 4

3 5

1 2

2 6

1 6

4 2```

### 输出

```
1 4

4 3

5 3

4 2

6 2

1 5

5 3

1 4

2 1

1 6```

## 样例 #2

### 输入

```
4 3

3 1

1 2

1 4```

### 输出

```
1 2

1 3

1 4

1 4

1 3

1 2```

# AI分析结果

### 题目中文重写
# [ABC251F] 两棵生成树

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc251/tasks/abc251_f

给定一个具有 $N$ 个顶点和 $M$ 条边的无向图 $G$。图 $G$ 是**简单图**（没有自环和重边）且**连通**。

对于 $i = 1, 2, \ldots, M$，第 $i$ 条边是连接顶点 $u_i$ 和顶点 $v_i$ 的无向边 $\{ u_i, v_i \}$。

请构造一组满足以下两个条件的图 $G$ 的两棵生成树 $T_1$ 和 $T_2$。（$T_1$ 和 $T_2$ 不必是不同的生成树。）

- $T_1$ 满足以下条件：
  > 将 $T_1$ 视为以顶点 $1$ 为根的有根树时，对于图 $G$ 中不在 $T_1$ 中的所有边 $\{ u, v \}$，$u$ 和 $v$ 在 $T_1$ 中具有祖先 - 子孙关系。
- $T_2$ 满足以下条件：
  > 将 $T_2$ 视为以顶点 $1$ 为根的有根树时，图 $G$ 中不在 $T_2$ 中的边 $\{ u, v \}$ 中，不存在 $u$ 和 $v$ 在 $T_2$ 中具有祖先 - 子孙关系的边。

这里，“在有根树 $T$ 中顶点 $u$ 和顶点 $v$ 具有祖先 - 子孙关系” 指的是 “在 $T$ 中 $u$ 是 $v$ 的祖先” 或 “在 $T$ 中 $v$ 是 $u$ 的祖先” 这两种情况中的任意一种成立。

在本题的约束条件下，可以证明一定存在满足上述条件的 $T_1$ 和 $T_2$。

## 说明/提示

### 约束条件

- $2 \leq N \leq 2 \times 10^5$
- $N - 1 \leq M \leq \min\{ 2 \times 10^5, N(N - 1)/2 \}$
- $1 \leq u_i, v_i \leq N$
- 输入均为整数
- 给定的图是简单且连通的

### 样例解释 1

在上述输出示例中，$T_1$ 是具有 5 条边 $\{ 1, 4 \}, \{ 4, 3 \}, \{ 5, 3 \}, \{ 4, 2 \}, \{ 6, 2 \}$ 的图 $G$ 的生成树。这个 $T_1$ 满足问题描述中的条件。实际上，对于图 $G$ 中不在 $T_1$ 中的每条边：
 - 对于边 $\{ 5, 1 \}$，顶点 $1$ 是顶点 $5$ 的祖先。
 - 对于边 $\{ 1, 2 \}$，顶点 $1$ 是顶点 $2$ 的祖先。
 - 对于边 $\{ 1, 6 \}$，顶点 $1$ 是顶点 $6$ 的祖先。

此外，$T_2$ 是具有 5 条边 $\{ 1, 5 \}, \{ 5, 3 \}, \{ 1, 4 \}, \{ 2, 1 \}, \{ 1, 6 \}$ 的图 $G$ 的生成树。这个 $T_2$ 满足问题描述中的条件。实际上，对于图 $G$ 中不在 $T_2$ 中的每条边：
 - 对于边 $\{ 4, 3 \}$，顶点 $4$ 和顶点 $3$ 不具有祖先 - 子孙关系。
 - 对于边 $\{ 2, 6 \}$，顶点 $2$ 和顶点 $6$ 不具有祖先 - 子孙关系。
 - 对于边 $\{ 4, 2 \}$，顶点 $4$ 和顶点 $2$ 不具有祖先 - 子孙关系。

### 样例解释 2

具有 3 条边 $\{ 1, 2 \}, \{ 1, 3 \}, \{ 1, 4 \}$ 的树 $T$ 是图 $G$ 的唯一生成树。由于图 $G$ 中不存在不在这棵树 $T$ 中的边，显然，$T$ 同时满足 $T_1$ 和 $T_2$ 的条件。

## 样例 #1

### 输入
```
6 8
5 1
4 3
1 4
3 5
1 2
2 6
1 6
4 2
```

### 输出
```
1 4
4 3
5 3
4 2
6 2
1 5
5 3
1 4
2 1
1 6
```

## 样例 #2

### 输入
```
4 3
3 1
1 2
1 4
```

### 输出
```
1 2
1 3
1 4
1 4
1 3
1 2
```

### 综合分析与结论
这些题解的核心思路都是通过深度优先搜索（DFS）和广度优先搜索（BFS）来构造满足条件的两棵生成树。对于 $T_1$，利用 DFS 的特性，使得非树边连接的节点具有祖先 - 子孙关系；对于 $T_2$，利用 BFS 的特性，使得非树边连接的节点不具有祖先 - 子孙关系。

### 所选题解
- **Nahida_Buer（4星）**
  - 关键亮点：思路清晰，对 DFS 和 BFS 满足条件的证明较为详细，代码中使用了快读优化输入。
- **MMXIandCCXXII（4星）**
  - 关键亮点：思路阐述明确，通过反证法证明了 DFS 和 BFS 满足条件，代码结构清晰。
- **Pengzt（4星）**
  - 关键亮点：简洁地指出了 DFS 和 BFS 与题目条件的关系，提到了 Tarjan 算法相关知识。

### 重点代码
#### Nahida_Buer 的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int read(){//快读
	int x=0;char ch=getchar();
	while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x;
}
int n,m;
bitset<400005>pd;//2*i和2*i-1分别代表i节点在广搜和深搜中是否遍历过了
vector<int>h[200005];
void dfs(int u){
	for(int v:h[u]){
		if(pd[(v<<1)-1])continue;
		pd[(v<<1)-1]=1;
		printf("%d %d\n",u,v);
		dfs(v);
	}
}
void bfs(){
	queue<int>q;
	q.push(1);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int v:h[u]){
			if(pd[v<<1])continue;
			pd[v<<1]=1;
			printf("%d %d\n",u,v);
			q.push(v);
		}
	}
}
int main(){
	n=read();m=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		h[u].push_back(v);
		h[v].push_back(u);
	}
	pd[1]=pd[2]=1;
	dfs(1);
	bfs();
}
```
**核心实现思想**：使用 `read` 函数进行快读输入，用 `bitset` 记录节点在 DFS 和 BFS 中的访问状态。`dfs` 函数进行深度优先搜索，`bfs` 函数进行广度优先搜索，分别输出满足条件的生成树的边。

#### MMXIandCCXXII 的代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 200010;

vector <int> v[N];
bool vis[N];

void dfs(int u)
{
	vis[u] = true;
	for (int i = 0; i < v[u].size(); i++)
	{
		int j = v[u][i];
		if (vis[j]) continue;
		cout << u << " " << j << endl;
		dfs (j);
	}
}

queue <int> q;

void bfs()
{
	q.push (1);
	vis[1] = true;
	while (q.size())
	{
		int x = q.front();
		q.pop();
		for (int i = 0; i < v[x].size(); i++)
		{
			int j = v[x][i];
			if (vis[j]) continue;
			vis[j] = true;
			cout << x << " " << j << endl;
			q.push (j);
		}
	}
}

int main()
{
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		int x, y;
		cin >> x >> y;
		v[x].push_back (y);
		v[y].push_back (x);
	}
	dfs (1);
	memset (vis, false, sizeof vis);
	bfs ();
	return 0;
}
```
**核心实现思想**：使用 `vector` 存储图的邻接表，`vis` 数组记录节点的访问状态。`dfs` 函数进行深度优先搜索，`bfs` 函数进行广度优先搜索，分别输出满足条件的生成树的边。

#### Pengzt 的思路
先 DFS 一遍得到满足没有横叉边的生成树（即 $T_1$），因为遇到横叉边时优先走这条边可变为树边或返祖边；再 BFS 一遍得到满足没有返祖边的生成树（即 $T_2$），因为 BFS 优先连离根近的边。

### 最优关键思路或技巧
- **思维方式**：通过分析样例和图的遍历特性，猜测并证明 DFS 和 BFS 能满足题目要求，这种从特殊到一般的思维方式很重要。
- **算法选择**：利用 DFS 和 BFS 的特性来构造生成树，避免了复杂的图论算法。

### 可拓展之处
同类型题目可能会对生成树的条件进行变化，例如要求生成树的边权和最小、最大等，或者在有向图中构造满足特定条件的生成树。类似算法套路可以是利用不同的图遍历方式（如拓扑排序、Dijkstra 等）来构造满足条件的子图。

### 推荐洛谷题目
1. [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)：考察最小生成树的构造。
2. [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)：涉及最小生成树和图的连通性。
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)：经典的最小生成树模板题。

### 个人心得摘录与总结
部分题解提到遇到没思路的题先研究样例、画出图，这种从具体例子入手分析问题的方法有助于找到解题思路。通过对样例的观察和分析，能够发现问题的规律和特点，从而猜测并验证解题方法。

---
处理用时：66.40秒
# 题目信息

# [ABC282F] Union of Two Sets

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc282/tasks/abc282_f

この問題は **インタラクティブな問題**（あなたが作成したプログラムとジャッジプログラムが標準入出力を介して対話を行う形式の問題）です。

あなたとジャッジは下記の手順を行います。 手順はフェイズ $ 1 $ とフェイズ $ 2 $ からなり、まずフェイズ $ 1 $ を行った直後、続けてフェイズ $ 2 $ を行います。

（フェイズ $ 1 $ ）

- ジャッジから整数 $ N $ が与えられる。
- あなたは $ 1 $ 以上 $ 50000 $ 以下の整数 $ M $ を出力する。
- さらにあなたは、すべての $ i\ =\ 1,\ 2,\ \ldots,\ M $ について $ 1\ \leq\ l_i\ \leq\ r_i\ \leq\ N $ を満たす、$ M $ 個の整数の組 $ (l_1,\ r_1),\ (l_2,\ r_2),\ \ldots,\ (l_M,\ r_M) $ を出力する（$ M $ 個の整数の組が相異なる必要はない）。

（フェイズ $ 2 $ ）

- ジャッジから整数 $ Q $ が与えられる。
- その後、あなたとジャッジは下記の手順を $ Q $ 回繰り返す。
  - ジャッジからクエリとして $ 2 $ つの整数 $ L,\ R $ が与えられる。
  - それに対する応答として、あなたは $ 1 $ 以上 $ M $ 以下の $ 2 $ つの整数 $ a,\ b $ を出力する（ $ a\ =\ b $ でもよい）。 このとき、$ a $ と $ b $ は下記の条件を満たさなければならない。もし満たさなかった場合は不正解となる。
      - 集合 $ \lbrace\ l_a,\ l_a+1,\ \ldots,\ r_a\rbrace $ と集合 $ \lbrace\ l_b,\ l_b+1,\ \ldots,\ r_b\rbrace $ の和集合が、集合 $ \lbrace\ L,\ L+1,\ \ldots,\ R\rbrace $ と一致する。

上記の手順を行った後、直ちにプログラムを終了することで正解となります。

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたが作成したプログラムとジャッジプログラムが標準入出力を介して対話を行う形式の問題）です。

（フェイズ $ 1 $ ）

- まず、$ N $ が入力から与えられます。
- 次に、$ 1 $ 以上 $ 50000 $ 以下の整数 $ M $ を出力してください。
- その後、$ M $ 回にわたって $ (l_1,\ r_1),\ (l_2,\ r_2),\ \ldots,\ (l_M,\ r_M) $ を出力してください。 具体的には、$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 回目の出力では $ (l_i,\ r_i) $ を下記の形式で出力してください。

> $ l_i $ $ r_i $

（フェイズ $ 2 $ ）

- まず、$ Q $ が入力から与えられます。
- 各クエリでは、クエリを表す整数 $ L,\ R $ が下記の形式で与えられます。

> $ L $ $ R $

- 各クエリに対する応答では、$ 2 $ つの整数 $ a,\ b $ を下記の形式で出力してください。

> $ a $ $ b $

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 4000 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ 1\ \leq\ L\ \leq\ R\ \leq\ N $
- 入力はすべて整数

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で不正な出力を行った、あるいはプログラムが途中で終了した場合のジャッジ結果は不定です。** 特に、プログラムの実行中に実行時エラーが起こった場合に、ジャッジ結果が RE ではなく WA や TLE になる可能性があることに注意してください。
- フェイズ $ 2 $ を終了したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- フェイズ $ 2 $ で与えられる $ L,\ R $ は、あなたがフェイズ $ 1 $ で出力した $ (l_1,\ r_1),\ (l_2,\ r_2),\ \ldots,\ (l_M,\ r_M) $ に応じて決定されます。

### 入出力例

以下は、$ N\ =\ 4,\ Q\ =\ 4 $ の場合の入出力例です。

入力出力説明`4`$ N $ が与えられます。`6`$ M $ を出力します。`3 3`$ (l_1,\ r_1)\ =\ (3,\ 3) $ を出力します。`4 4`$ (l_2,\ r_2)\ =\ (4,\ 4) $ を出力します。`1 1`$ (l_3,\ r_3)\ =\ (1,\ 1) $ を出力します。`2 4`$ (l_4,\ r_4)\ =\ (2,\ 4) $ を出力します。`1 3`$ (l_5,\ r_5)\ =\ (1,\ 3) $ を出力します。`2 2`$ (l_6,\ r_6)\ =\ (2,\ 2) $ を出力します。`4`$ Q $ が与えられます。`1 3`$ 1 $ 個目のクエリとして $ L\ =\ 1,\ R\ =\ 3 $ が与えられます。`1 5`$ 1 $ 個目のクエリに対する応答として $ a\ =\ 1,\ b\ =\ 5 $ を出力します。`3 4`$ 2 $ 個目のクエリとして $ L\ =\ 3,\ R\ =\ 4 $ が与えられます。`2 1`$ 2 $ 個目のクエリに対する応答として $ a\ =\ 2,\ b\ =\ 1 $ を出力します。`2 4`$ 3 $ 個目のクエリとして $ L\ =\ 2,\ R\ =\ 4 $ が与えられます。`4 4`$ 3 $ 個目のクエリに対する応答として $ a\ =\ 4,\ b\ =\ 4 $ を出力します。`1 1`$ 4 $ 個目のクエリとして $ L\ =\ 1,\ R\ =\ 1 $ が与えられます。`3 3`$ 4 $ 個目のクエリに対する応答として $ a\ =\ 3,\ b\ =\ 3 $ を出力します。

# AI分析结果

### 题目翻译
这是一道交互式问题（你编写的程序和评测程序通过标准输入输出来进行交互的问题）。

你和评测程序将按以下步骤进行操作。步骤分为阶段 1 和阶段 2，首先进行阶段 1，紧接着进行阶段 2。

（阶段 1）
- 评测程序会给出一个整数 $N$。
- 你需要输出一个 $1$ 到 $50000$ 之间的整数 $M$。
- 此外，对于所有的 $i = 1, 2, \ldots, M$，你需要输出 $M$ 个满足 $1 \leq l_i \leq r_i \leq N$ 的整数对 $(l_1, r_1), (l_2, r_2), \ldots, (l_M, r_M)$（这些整数对不需要各不相同）。

（阶段 2）
- 评测程序会给出一个整数 $Q$。
- 之后，你和评测程序会将以下步骤重复 $Q$ 次：
  - 评测程序会给出两个整数 $L$ 和 $R$ 作为查询。
  - 作为响应，你需要输出两个 $1$ 到 $M$ 之间的整数 $a$ 和 $b$（$a$ 可以等于 $b$）。此时，$a$ 和 $b$ 必须满足以下条件，若不满足则判定为错误答案：
    - 集合 $\{ l_a, l_a + 1, \ldots, r_a \}$ 和集合 $\{ l_b, l_b + 1, \ldots, r_b \}$ 的并集必须与集合 $\{ L, L + 1, \ldots, R \}$ 相等。

完成上述步骤后，立即结束程序即可判定为正确答案。

#### 输入与输出格式
这是一道交互式问题（你编写的程序和评测程序通过标准输入输出来进行交互的问题）。

（阶段 1）
- 首先，从输入中读取 $N$。
- 接着，输出一个 $1$ 到 $50000$ 之间的整数 $M$。
- 然后，分 $M$ 次输出 $(l_1, r_1), (l_2, r_2), \ldots, (l_M, r_M)$。具体来说，对于 $i = 1, 2, \ldots, M$，第 $i$ 次输出时，以如下格式输出 $(l_i, r_i)$：
  > $l_i$ $r_i$

（阶段 2）
- 首先，从输入中读取 $Q$。
- 在每个查询中，会以如下格式给出表示查询的整数 $L$ 和 $R$：
  > $L$ $R$
- 对于每个查询的响应，以如下格式输出两个整数 $a$ 和 $b$：
  > $a$ $b$

#### 说明/提示
##### 限制条件
- $1 \leq N \leq 4000$
- $1 \leq Q \leq 10^5$
- $1 \leq L \leq R \leq N$
- 所有输入均为整数

##### 注意事项
- **每次输出后，要在末尾添加换行符并刷新标准输出。否则，评测结果可能会是超时（TLE）。**
- **在交互过程中，如果输出格式错误或者程序中途终止，评测结果是不确定的。** 特别要注意，程序运行过程中如果出现运行时错误，评测结果可能是错误答案（WA）或超时（TLE），而不一定是运行时错误（RE）。
- 阶段 2 结束后，请立即结束程序。否则，评测结果不确定。
- 阶段 2 中给出的 $L$ 和 $R$ 会根据你在阶段 1 中输出的 $(l_1, r_1), (l_2, r_2), \ldots, (l_M, r_M)$ 来确定。

##### 输入输出示例
以下是 $N = 4, Q = 4$ 时的输入输出示例。

| 输入输出说明 | 输入/输出内容 |
| --- | --- |
| $N$ 被给出 | `4` |
| 输出 $M$ | `6` |
| 输出 $(l_1, r_1) = (3, 3)$ | `3 3` |
| 输出 $(l_2, r_2) = (4, 4)$ | `4 4` |
| 输出 $(l_3, r_3) = (1, 1)$ | `1 1` |
| 输出 $(l_4, r_4) = (2, 4)$ | `2 4` |
| 输出 $(l_5, r_5) = (1, 3)$ | `1 3` |
| 输出 $(l_6, r_6) = (2, 2)$ | `2 2` |
| $Q$ 被给出 | `4` |
| 第一个查询，$L = 1, R = 3$ | `1 3` |
| 对第一个查询的响应，$a = 1, b = 5$ | `1 5` |
| 第二个查询，$L = 3, R = 4$ | `3 4` |
| 对第二个查询的响应，$a = 2, b = 1$ | `2 1` |
| 第三个查询，$L = 2, R = 4$ | `2 4` |
| 对第三个查询的响应，$a = 4, b = 4$ | `4 4` |
| 第四个查询，$L = 1, R = 1$ | `1 1` |
| 对第四个查询的响应，$a = 3, b = 3$ | `3 3` |

### 综合分析与结论
这些题解大多运用了 ST 表的思想来解决问题。核心思路是构造一系列区间，使得对于任意给定的查询区间 $[L, R]$，都能找到两个构造好的区间，它们的并集等于 $[L, R]$。

不同题解的差异主要体现在构造区间的方式和实现细节上。部分题解直接使用标准的 ST 表构造方法，即构造长度为 $2^k$ 的区间；而 yuyc 的题解提出了一种改进的构造方法，每次将区间长度乘 $2$ 再加 $1$，相比标准 ST 表能减少一些区间的构造。

### 所选题解
- **yuyc（4星）**
  - **关键亮点**：提出了一种不同于标准 ST 表的构造方法，能在 $n = 4000$ 时相比 ST 表少构造将近 $4000$ 个区间，优化了空间复杂度。
- **StudyingFather（4星）**
  - **关键亮点**：思路清晰，详细阐述了 ST 表原理与本题任务的对应关系，代码简洁明了。
- **minVan（4星）**
  - **关键亮点**：提前预处理 $\log_2x$ ，减少了 $\log$ 函数的调用，优化了时间复杂度。

### 重点代码
#### yuyc 的核心代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4e3 + 5;
vector<int> v[N];
int s[N],lth[N];
int main(){
    int n,cnt = 0;
    cin>>n;
    for(int len = 1;len <= n;len = len * 2 + 1){
        cnt++;
        lth[cnt] = len;
        for(int l = 1;l + len - 1 <= n;l++){
            v[cnt].push_back(l);
        }
        s[cnt] = s[cnt - 1] + v[cnt].size();
    }
    cout<<s[cnt]<<endl;
    for(int i=1;i<=cnt;i++){
        for(int j : v[i]){
            cout<<j<<' '<<j + lth[i] - 1<<endl;
        }
    }
    int q;
    cin>>q;
    while(q--){
        int l,r;
        cin>>l>>r;
        int len = r - l + 1;
        int t = upper_bound(lth,lth + cnt + 1,len) - lth - 1;
        cout<<s[t - 1] + l<<" "<<s[t - 1] + l + len - lth[t]<<endl;
    }
    return 0;
}
```
**核心实现思想**：通过循环构造区间，区间长度每次乘 $2$ 再加 $1$。对于每个查询区间 $[l, r]$，找到合适的两个构造区间的编号输出。

#### StudyingFather 的核心代码
```cpp
#include <cmath>
#include <iostream>
using namespace std;
int f[4005][15];
int main() {
    ios::sync_with_stdio(false);
    int n, cnt = 0;
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 0; i + (1 << j) - 1 <= n; j++) f[i][j] = ++cnt;
    cout << cnt << endl;
    for (int i = 1; i <= n; i++)
        for (int j = 0; i + (1 << j) - 1 <= n; j++)
            cout << i << ' ' << i + (1 << j) - 1 << endl;
    int q;
    cin >> q;
    while (q--) {
        int l, r;
        cin >> l >> r;
        int k = log2(r - l + 1);
        cout << f[l][k] << ' ' << f[r - (1 << k) + 1][k] << endl;
    }
    return 0;
}
```
**核心实现思想**：利用 ST 表的思想，构造长度为 $2^k$ 的区间并编号。对于查询区间 $[l, r]$，找到对应的两个区间编号输出。

#### minVan 的核心代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 4005;
int n, f[N][15], h[N];
int main() {
    cin >> n;
    for(int i = 2; i <= n; i++) {
        h[i] = h[i >> 1] + 1;
    }
    int cnt = 0;
    for(int i = 1; i <= n; i++) {
        for(int j = 0; i + (1 << j) - 1 <= n; j++) {
            f[i][j] = ++cnt;
        }
    }
    cout << cnt << '\n';
    for(int i = 1; i <= n; i++) {
        for(int j = 0; i + (1 << j) - 1 <= n; j++) {
            cout << i << ' ' << i + (1 << j) - 1 << '\n';
        }
    }
    int q;
    cin >> q;
    while(q--) {
        int l, r;
        cin >> l >> r;
        cout << f[l][h[r - l + 1]] << ' ' << f[r - (1 << h[r - l + 1]) + 1][h[r - l + 1]] << '\n';
    }
    return 0;
}
```
**核心实现思想**：提前预处理 $\log_2x$ 存于数组 $h$ 中，减少 $\log$ 函数的调用。构造长度为 $2^k$ 的区间并编号，对于查询区间 $[l, r]$，利用预处理的 $\log$ 值找到对应区间编号输出。

### 最优关键思路或技巧
- **ST 表思想**：利用 ST 表的倍增思想，构造长度为 $2^k$ 的区间，能在 $O(n\log n)$ 的时间内预处理，$O(1)$ 的时间内回答查询。
- **区间构造优化**：如 yuyc 的题解，通过每次将区间长度乘 $2$ 再加 $1$ 的方式构造区间，减少了区间的构造数量。
- **预处理优化**：如 minVan 的题解，提前预处理 $\log_2x$ ，减少了 $\log$ 函数的调用，优化了时间复杂度。

### 拓展思路
同类型题目通常会涉及区间查询、区间合并等问题，可使用 ST 表、线段树、树状数组等数据结构来解决。类似的算法套路包括倍增、分治等。

### 推荐题目
- [P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865)
- [P2880 [USACO07JAN] Balanced Lineup G](https://www.luogu.com.cn/problem/P2880)
- [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)

### 个人心得摘录与总结
- **Hoks**：提到使用快读和 scanf 会挂，只能用关流 cin，提醒在交互题中要注意输入输出方式，避免出现意外错误。

---
处理用时：70.09秒
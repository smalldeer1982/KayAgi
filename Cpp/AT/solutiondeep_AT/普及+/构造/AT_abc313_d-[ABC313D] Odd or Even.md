# 题目信息

# [ABC313D] Odd or Even

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc313/tasks/abc313_d

この問題は **インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

整数 $ N $ および $ N $ 未満の **奇数** $ K $ が与えられます。  
ジャッジシステムは、$ 0 $ および $ 1 $ からなる長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ を隠し持っています。

あなたは数列 $ A $ の要素の値を直接知ることはできません。  
その代わりに、ジャッジシステムに対して以下の質問を $ N $ 回まで行うことができます。

- $ 1 $ 以上 $ N $ 以下の相異なる整数 $ x_1,\ x_2,\ \dots,\ x_K $ を選ぶ。そして、$ A_{x_1}\ +\ A_{x_2}\ +\ \dots\ +\ A_{x_K} $ の偶奇を聞く。

$ N $ 回以下の質問で $ (A_1,\ A_2,\ \dots,\ A_N) $ を全て特定して、答えを出力してください。  
ただし、**ジャッジは適応的です**。言い換えると、ジャッジシステムは今までの質問の回答に矛盾しない範囲で$ A $ の内容を自由に変更することができます。  
そのため、出力が次の条件を満たす場合にあなたの作成したプログラムは正解とみなされます。それ以外の場合は不正解とみなされます。

- ここまでの質問の回答と矛盾しないような数列が一意に定まっており、かつそれがプログラムが出力した数列と一致している。

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

最初に、$ N $ および $ K $ を標準入力から受け取ってください。

> $ N $ $ K $

次に、$ (A_1,\ A_2,\ \dots,\ A_N) $ を全て特定できるまで質問を繰り返してください。  
質問は、以下の形式で標準出力に出力してください。ここで $ x_1,\ x_2,\ \dots,\ x_K $ は $ 1 $ 以上 $ N $ 以下の相異なる $ K $ 個の整数です。

> $ ? $ $ x_1 $ $ x_2 $ $ \dots $ $ x_K $

これに対する応答は、次の形式で標準入力から与えられます。

> $ T $

ここで、$ T $ は質問に対する答えで、

- $ T $ が `0` である場合は $ A_{x_1}\ +\ A_{x_2}\ +\ \dots\ +\ A_{x_K} $ は偶数であることを、
- $ T $ が `1` である場合は $ A_{x_1}\ +\ A_{x_2}\ +\ \dots\ +\ A_{x_K} $ は奇数であることを意味します。

ただし、$ x_1,\ x_2,\ \dots,\ x_K $ が制約を満たしていないか、質問の回数が $ N $ 回を超えた場合は $ T $ は `-1` となります。

ジャッジが `-1` を返した場合、プログラムはすでに不正解とみなされています。この場合、ただちにプログラムを終了してください。

$ A $ の要素を全て特定できたら、特定した $ A $ の要素を以下の形式で出力してください。その後、ただちにプログラムを終了してください。

> $ ! $ $ A_1 $ $ A_2 $ $ \dots $ $ A_N $

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \lt\ N\ \leq\ 1000 $
- $ K $ は奇数
- $ A_i $ は $ 0 $ または $ 1 $

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で誤った出力形式による出力を行った、あるいはプログラムが途中で終了した場合のジャッジ結果は不定です。**
- 解答を出力したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- ジャッジは適応的です。言い換えると、ジャッジシステムは今までの質問の回答に矛盾しない範囲で $ A $ の内容を変更することができます。

### 入出力例

以下の入出力例は $ N=5,\ K=3 $ の場合の入出力例です。**この入出力例の通りに出力するとジャッジ結果は WA になることに注意してください。**  
入出力例では、プログラムが出力した $ A\ =\ (1,\ 0,\ 1,\ 1,\ 0) $ はここまでの質問の回答に矛盾しない数列ですが、例えば $ (0,\ 0,\ 1,\ 0,\ 0) $ もここまでの質問の回答に矛盾しない数列であるため、数列 $ A $ は一意に定まっていません。そのため、このプログラムは不正解とみなされます。

  入力 出力 説明    `5 3`  まず整数 $ N $ および $ K $ が与えられます。   `? 2 4 1 `  $ (x_1,\ x_2,\ x_3)\ =\ (2,\ 4,\ 1) $ として質問を行います。  `0`  質問の答えは $ 0 $ なので、ジャッジはその値を返します。   `? 5 3 2` $ (x_1,\ x_2,\ x_3)\ =\ (5,\ 3,\ 2) $ として質問を行います。   `1`  質問の答えは $ 1 $ なので、ジャッジはその値を返します。   `! 1 0 1 1 0` $ A $ の答えとして $ (1,\ 0,\ 1,\ 1,\ 0) $ を出力します。$ A $ を一意に特定できていないのでジャッジ結果は WA になります。

# AI分析结果

### 题目内容中文重写
这是一道**交互式问题**（你编写的程序和评测系统通过输入输出来进行交互的问题）。

给定整数 $N$ 以及小于 $N$ 的**奇数** $K$。评测系统隐藏着一个由 $0$ 和 $1$ 组成的长度为 $N$ 的数列 $A = (A_1, A_2, \dots, A_N)$。

你无法直接得知数列 $A$ 中元素的值。不过，你可以向评测系统提出以下询问，询问次数最多为 $N$ 次：
- 选择 $1$ 到 $N$ 之间互不相同的整数 $x_1, x_2, \dots, x_K$，然后询问 $A_{x_1} + A_{x_2} + \dots + A_{x_K}$ 的奇偶性。

请在 $N$ 次以内的询问中确定 $(A_1, A_2, \dots, A_N)$ 的所有值并输出答案。需要注意的是，**评测是自适应的**。也就是说，评测系统可以在不与之前询问的回答产生矛盾的范围内自由更改 $A$ 的内容。因此，当你的程序输出满足以下条件时，会被判定为正确，否则判定为错误：
- 到目前为止，根据询问的回答能够唯一确定一个数列，并且该数列与程序输出的数列一致。

#### 输入与输出格式
这是一道交互式问题（你编写的程序和评测系统通过输入输出来进行交互的问题）。

首先，从标准输入读取 $N$ 和 $K$：
> $N$ $K$

接着，不断进行询问，直到能够确定 $(A_1, A_2, \dots, A_N)$ 的所有值。询问需按照以下格式输出到标准输出，其中 $x_1, x_2, \dots, x_K$ 是 $1$ 到 $N$ 之间互不相同的 $K$ 个整数：
> $?$ $x_1$ $x_2$ $\dots$ $x_K$

评测系统会按照以下格式从标准输入给出响应：
> $T$

这里，$T$ 是询问的答案：
- 若 $T$ 为 `0`，表示 $A_{x_1} + A_{x_2} + \dots + A_{x_K}$ 是偶数；
- 若 $T$ 为 `1`，表示 $A_{x_1} + A_{x_2} + \dots + A_{x_K}$ 是奇数。

但是，如果 $x_1, x_2, \dots, x_K$ 不满足约束条件，或者询问次数超过 $N$ 次，$T$ 将为 `-1`。

当评测系统返回 `-1` 时，程序已被判定为错误，请立即终止程序。

当能够确定 $A$ 的所有元素后，请按照以下格式输出确定的 $A$ 的元素，然后立即终止程序：
> $!$ $A_1$ $A_2$ $\dots$ $A_N$

#### 说明/提示
##### 约束条件
- $1 \leq K < N \leq 1000$
- $K$ 是奇数
- $A_i$ 为 $0$ 或 $1$

##### 注意事项
- **每次输出时，请在末尾添加换行符并刷新标准输出。否则，评测结果可能为 TLE。**
- **在交互过程中，如果输出格式错误，或者程序中途终止，评测结果将不确定。**
- 输出答案后，请立即终止程序。否则，评测结果将不确定。
- 评测是自适应的。也就是说，评测系统可以在不与之前询问的回答产生矛盾的范围内更改 $A$ 的内容。

##### 输入输出示例
以下输入输出示例是 $N = 5, K = 3$ 的情况。请注意，按照此输入输出示例进行输出，评测结果将为 WA。
在输入输出示例中，程序输出的 $A = (1, 0, 1, 1, 0)$ 与之前询问的回答不矛盾，但例如 $(0, 0, 1, 0, 0)$ 也与之前询问的回答不矛盾，因此数列 $A$ 并非唯一确定。所以，该程序将被判定为错误。

| 输入 | 输出 | 说明 |
| --- | --- | --- |
| `5 3` |  | 首先给出整数 $N$ 和 $K$。 |
|  | `? 2 4 1` | 以 $(x_1, x_2, x_3) = (2, 4, 1)$ 进行询问。 |
| `0` |  | 询问的答案是 $0$，评测系统返回该值。 |
|  | `? 5 3 2` | 以 $(x_1, x_2, x_3) = (5, 3, 2)$ 进行询问。 |
| `1` |  | 询问的答案是 $1$，评测系统返回该值。 |
|  | `! 1 0 1 1 0` | 输出 $A$ 的答案为 $(1, 0, 1, 1, 0)$。由于 $A$ 未被唯一确定，评测结果为 WA。 |

### 综合分析与结论
这些题解的核心思路大多是先解决 $n = k + 1$ 的特殊情况，再将其推广到一般情况。在 $n = k + 1$ 时，通过巧妙构造询问，利用奇偶性和异或运算的性质来确定数列前 $k + 1$ 个元素的值。对于一般情况，在确定前 $k + 1$ 个元素后，通过每次询问包含一个未知元素和 $k - 1$ 个已知元素的组合，逐步确定剩余元素的值。

不同题解的算法要点主要围绕询问的构造和异或运算的运用，难点在于如何利用 $k$ 为奇数这一条件，通过合理的询问组合来唯一确定数列元素。部分题解还采用了假设和检验的方法，通过先假设某个元素的值，最后进行验证来确定整个数列。

### 所选题解
- **作者：Fire_flame（5星）**
    - **关键亮点**：思路清晰，先对特殊情况 $k = 1$ 进行处理，再详细推导 $n = k + 1$ 时的解法，并将其推广到一般情况，代码实现简洁明了。
    - **核心代码**：
```cpp
if(k == 1){
    for(int i = 1;i <= n;i ++){
        cout << "? " << i << endl;
        a[i] = read();
    }
} else {
    for(int i = 1;i <= k + 1;i ++){
        cout << "? ";
        for(int j = 1;j <= k + 1;j ++){
            if(i == j)continue;
            cout << j << " ";
        }
        cout << endl;
        cin >> b[i];
    }
    int op = b[k + 1];
    for(int i = 2;i <= k;i += 2)
        op ^= b[i] ^ b[i + 1];
    a[1] = op;
    for(int i = 2;i <= k + 1;i ++)
        a[i] = a[i - 1] ^ b[i - 1] ^ b[i];
    for(int i = k + 2;i <= n;i ++){
        int tmp = 0;
        cout << "? ";
        for(int j = 1;j < k;j ++){
            cout << j << " ";
            tmp ^= a[j];
        }
        cout << i << endl;
        cin >> a[i];
        a[i] ^= tmp;
    }
}
```
    - **核心实现思想**：当 $k = 1$ 时，直接询问每个元素。当 $k > 1$ 时，先通过询问除 $a_i$ 外的元素和的奇偶性得到 $b_i$，利用异或运算求出 $a_1$，再根据 $b_i$ 之间的关系依次求出 $a_2$ 到 $a_{k + 1}$。最后，对于 $a_{k + 2}$ 到 $a_n$，每次询问包含一个未知元素和 $k - 1$ 个已知元素，通过异或运算确定未知元素的值。

- **作者：_liuyi_（4星）**
    - **关键亮点**：详细推导了 $n = k + 1$ 时的情况，利用求和与取模的关系确定元素值，代码结构清晰，注释详细。
    - **核心代码**：
```cpp
rep(i,1,k+1){
    rep(j,1,k+1)
        if(i!=j) a.pb(j);
    ans[i]=query(a);
    ans[i]%=2;
    sum+=ans[i];
    a.clear();
}
sum%=2;
rep(i,1,k+1) ans[i]=(ans[i]+sum)%2;
sum=0;
a.clear();
rep(i,1,k-1){ 
    sum+=ans[i];
    a.pb(i);
}
sum%=2;
rep(i,k+2,n){
    a.pb(i);
    ans[i]=sum^query(a);
    a.pop_back();
}
```
    - **核心实现思想**：在 $n = k + 1$ 时，第 $i$ 次询问不包含 $i$ 的序列，根据 $k$ 为奇数，得出 $\sum_{i = 1}^{k + 1}S_i \equiv \sum_{i = 1}^{k + 1}a_i \pmod{2}$，从而求出 $a_1$ 到 $a_{k + 1}$。对于 $a_{k + 2}$ 到 $a_n$，每次询问包含一个未知元素和 $k - 1$ 个已知元素，通过异或运算确定未知元素的值。

- **作者：ggwj（4星）**
    - **关键亮点**：结合具体例子详细说明 $n = k + 1$ 时的解法，将问题推广到一般情况的思路清晰，代码实现简洁规范。
    - **核心代码**：
```cpp
{
    int r = 0;
    for (int i = 0; i < K + 1; i++) {
        vector<int> v;
        for (int j = 0; j < K + 1; j++)
            if (i!= j) v.push_back(j);
        ans[i] = send(v);
        r ^= ans[i];
    }
    for (int i = 0; i < K + 1; i++) ans[i] ^= r;
}
{
    vector<int> v(K);
    int s = 0;
    for (int i = 0; i < K - 1; i++) v[i] = i, s ^= ans[i];
    for (int i = K + 1; i < N; i++) {
        v.back() = i;
        int t = send(v);
        ans[i] = s ^ t;
    }
}
```
    - **核心实现思想**：在 $n = k + 1$ 时，通过询问除 $a_i$ 外的元素和的奇偶性得到 $ans[i]$，利用异或运算求出整个序列的异或和 $r$，再通过 $r$ 与 $ans[i]$ 的异或得到 $a_1$ 到 $a_{k + 1}$。对于 $a_{k + 2}$ 到 $a_n$，每次询问包含一个未知元素和 $k - 1$ 个已知元素，通过异或运算确定未知元素的值。

### 最优关键思路与技巧
- **特殊情况入手**：先解决 $n = k + 1$ 这种简单情况，再将其推广到一般情况，降低问题的复杂度。
- **异或运算的运用**：利用异或运算的性质（如 $x \oplus x = 0$），通过巧妙构造询问和运算，确定数列元素的值。
- **逐步推导**：在确定部分元素的值后，利用已知元素和新的询问逐步确定剩余元素的值。

### 可拓展之处
同类型的题目可能会改变询问的规则或数列元素的取值范围，解题的关键仍然是通过合理的询问构造和数学运算来确定未知信息。类似的算法套路包括利用奇偶性、异或运算、模运算等性质，通过逐步推导和假设检验来解决问题。

### 推荐题目
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：涉及数据的动态维护和中位数的求解，需要运用合适的数据结构和算法。
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：可以使用归并排序等算法来统计逆序对的数量，考察对算法的理解和应用。
3. [P2068 统计和](https://www.luogu.com.cn/problem/P2068)：需要根据给定的条件进行统计和计算，锻炼逻辑思维和编程能力。

### 个人心得摘录与总结
- **作者：CarroT1212**：赛时想到了两个关键性质，但没有将它们结合起来使用，导致题目未做出。这提醒我们在解题时要综合运用所想到的思路和方法，尝试将不同的性质和技巧结合起来。
- **作者：Neil_Qian**：这是第一次做出交互题，强调了转化思想的重要性，即把询问结果转化为异或值来处理。这表明在解决新类型的题目时，要善于寻找问题的本质，通过合理的转化将问题简化。 

---
处理用时：73.45秒
# 题目信息

# [AGC006B] Median Pyramid Easy

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc006/tasks/agc006_b

$ N $ 段のピラミッドがあります。 段は上から順に $ 1 $, $ 2 $, $ ... $, $ N $ と番号が振られています。 各 $ 1\ <\ =i\ <\ =N $ について、$ i $ 段目には $ 2i-1 $ 個のブロックが横一列に並んでいます。 また、各段の中央のブロックに注目すると、これらは縦一列に並んでいます。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc006_b/a992c42b0e9b0597f104bf82a0adc1131324bb4f.png)$ N=4 $ 段のピラミッド

 

すぬけ君は $ N $ 段目のブロックに ($ 1 $, $ 2 $, $ ... $, $ 2N-1 $) を並べ替えたもの（順列）を書き込みました。 さらに、次のルールに従い、残りすべてのブロックに整数を書き込みました。

- あるブロックに書き込まれる整数は、そのブロックの左下、真下、右下のブロックに書き込まれた整数の中央値である。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc006_b/545e109d7af3caf92b1a8f9ac80715efa6c3d3db.png)ブロックに整数を書き込む例

 

その後、すぬけ君はすべてのブロックに書き込まれた整数を消してしまいました。 すぬけ君は、$ 1 $ 段目のブロックに書き込まれた整数が $ x $ であったことだけを覚えています。

$ N $ 段目のブロックに書き込まれた順列としてあり得るものが存在するか判定し、存在するならばひとつ求めてください。

## 说明/提示

### 制約

- $ 2\ <\ =N\ <\ =10^5 $
- $ 1\ <\ =x\ <\ =2N-1 $

### Sample Explanation 1

問題文中の図の例です。

### Sample Explanation 2

$ N $ 段目のブロックにどのような順列を書き込んでも、$ 1 $ 段目のブロックに書き込まれる整数は $ 2 $ となります。

## 样例 #1

### 输入

```
4 4```

### 输出

```
Yes

1

6

3

7

4

5

2```

## 样例 #2

### 输入

```
2 1```

### 输出

```
No```

# AI分析结果

### 题目中文重写
有一个 $N$ 层的金字塔。层从上到下依次编号为 $1, 2,..., N$。对于每个 $1 \leq i \leq N$，第 $i$ 层有 $2i - 1$ 个方块排成一行。此外，当关注每层中央的方块时，这些方块排成一列。

![$N = 4$ 层的金字塔](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc006_b/a992c42b0e9b0597f104bf82a0adc1131324bb4f.png)

すぬけ君在第 $N$ 层的方块上写下了 $(1, 2,..., 2N - 1)$ 的一个排列。然后，他按照以下规则在其余所有方块上写下整数：

- 某个方块上写下的整数是其左下、正下、右下三个方块上所写整数的中位数。

![方块上写整数的示例](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc006_b/545e109d7af3caf92b1a8f9ac80715efa6c3d3db.png)

之后，すぬけ君把所有方块上写的整数都擦掉了。他只记得第 $1$ 层方块上写的整数是 $x$。

判断第 $N$ 层方块上所写排列是否存在，如果存在则求出一个这样的排列。

### 综合分析与结论
这些题解整体围绕如何根据顶层数字 $x$ 构造出第 $N$ 层的排列展开。

#### 思路对比
- 多数题解的核心思路是在第 $N$ 层中间构造出能保证 $x$ 成为顶层数字的组合，如将 $x - 1$、$x$、$x + 1$ 放在中间位置。
- 部分题解通过观察规律、分析三元组传递特性等方式来确定构造方法。

#### 算法要点对比
- 各题解都先判断无解情况，即 $x = 1$ 或 $x = 2N - 1$。
- 在构造排列时，多数题解采用将特定数字放在中间，其余数字按顺序填充剩余位置的方法。

#### 难点解决对比
- 对于 $x = 2$ 或接近边界值的情况，部分题解进行了特判处理。
- 部分题解通过打表找规律来辅助构造排列。

### 题解评分与选择
- **cqbzjyh（4星）**：思路清晰，通过证明 $x$ 能一直处于中间来确定构造方法，代码简洁易懂。关键亮点在于清晰的证明过程和简洁的代码实现。
- **wheneveright（4星）**：从暴力思路入手，通过观察例子和三元组传递特性得出构造思路，考虑了多种特殊情况。关键亮点是从暴力到构造的思路引导和对特殊情况的详细处理。
- **Enderturtle（4星）**：思路与多数题解类似，但通过分析柱子贡献来证明构造的正确性，代码简洁规范。关键亮点是从柱子贡献角度证明构造的正确性。

### 最优关键思路或技巧
- **构造特定组合**：在第 $N$ 层中间构造出 $x - 1$、$x$、$x + 1$ 的组合，能保证 $x$ 成为顶层数字。
- **利用三元组特性**：观察形如 $x\ x\ y$ 的三元组，其向上传递时结果为 $x$，可用于确定构造方法。
- **特判边界情况**：对 $x = 1$、$x = 2N - 1$ 以及 $x = 2$ 等边界情况进行特判处理。

### 可拓展之处
同类型题可能会改变金字塔的构造规则或数字范围，类似算法套路是先分析规则，找出关键数字组合，再根据边界情况进行特判。

### 洛谷相似题目推荐
- [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)
- [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)

### 个人心得摘录与总结
- **PosVII**：提到这是道简单的构造题，但需要思考较久且有很多小坑点，考场上爆搜可骗分。总结：构造题需深入思考，注意细节，在考场上可采用部分得分策略。
- **ZCETHAN**：指出构造时要考虑两种构造方法的适用性以及无解情况。总结：构造题要全面考虑各种情况，避免遗漏。

### 重点代码
#### cqbzjyh
```cpp
#include <cstdio>
int a[200005], tot = 1;
int main() {
    int n, x;
    scanf("%d %d", &n, &x);
    if (x == 1 || x == 2 * n - 1) {
        printf("No");
        return 0;
    }
    printf("Yes\n");
    a[n - 1] = x - 1, a[n] = x, a[n + 1] = x + 1;
    for (int i = 1; i <= n - 2;) {
        if (tot == x - 1 || tot == x || tot == x + 1) tot++;
        else a[i] = tot, tot++, i++;
    }
    for (int i = n + 2; i <= 2 * n - 1;) {
        if (tot == x - 1 || tot == x || tot == x + 1) tot++;
        else a[i] = tot, tot++, i++;
    }
    for (int i = 1; i <= 2 * n - 1; i++) {
        printf("%d\n", a[i]);
    }
    return 0;
}
```
核心实现思想：先判断无解情况，若有解则将 $x - 1$、$x$、$x + 1$ 放在中间位置，然后按顺序填充其余位置。

#### wheneveright
```cpp
cin >> N >> K;
if (K == 1 || K == 2 * N - 1) {printf ("No\n"); return 0;}
if (N == 2 && K == 2) {printf ("Yes\n1 2 3\n"); return 0;}
if (N == 2) {printf ("No\n"); return 0;}
printf("Yes\n");
A[N] = K; A[N - 1] = K - 1; A[N + 1] = K + 1; A[N + 2] = K - 2;
for (register int i = 1, j = 1; i <= N * 2 - 1; i++){
    if (i == N - 1) i = N + 3;
    if (j == K - 2) j = K + 2;
    A[i] = j++;
}
```
核心实现思想：先处理特殊情况，若有解则将特定数字放在中间位置，然后按顺序填充其余位置。

#### Enderturtle
```cpp
n=read();x=read();
if(x==1 || x==(2*n-1)) puts("No");
else{
    puts("Yes");
    rep(i,1,n-2){
        while(now==x || now==x-1 || now==x+1) ++now;
        printf("%d\n",now);
        ++now;
    }
    printf("%d\n%d\n%d\n",x-1,x,x+1);
    rep(i,1,n-2){
        while(now==x || now==x-1 || now==x+1) ++now;
        printf("%d\n",now);
        ++now;			
    }
}
```
核心实现思想：先判断无解情况，若有解则先填充中间位置前的数字，再填充中间的 $x - 1$、$x$、$x + 1$，最后填充中间位置后的数字。 

---
处理用时：45.83秒
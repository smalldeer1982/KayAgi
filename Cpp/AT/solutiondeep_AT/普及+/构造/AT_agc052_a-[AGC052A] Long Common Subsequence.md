# 题目信息

# [AGC052A] Long Common Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc052/tasks/agc052_a

$ 3 $ つの $ 01 $ 文字列 $ S_1,\ S_2,\ S_3 $ が与えられます。これらはそれぞれ、`0` と `1` を $ N $ 個ずつ含みます。

長さ $ 2N+1 $ の $ 01 $ 文字列であって、$ S_1\ +\ S_1,\ S_2\ +\ S_2,\ S_3\ +\ S_3 $ のいずれの部分列でもあるものを $ 1 $ つ求めてください（$ s+t $ は文字列 $ s,\ t $ をこの順に連結したものを表します）。この問題の制約の下では、そのような文字列が常に存在することが保証されます。

ここで、文字列 $ B $ が文字列 $ A $ の部分列であるとは、$ A $ から $ 0 $ 文字以上を取り除き、残りの文字を順番を変えずに連結することで $ B $ を得ることができることを意味します。

テストケースは $ T $ 個与えられるので、それぞれを解いてください。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 10^5 $
- $ 1\le\ N\ \le\ 10^5 $
- $ S_i $ は `0` と `1` を $ N $ 個ずつ含む $ 01 $ 文字列である。
- 全テストケースにおける $ N $ の総和は $ 10^5 $ 以下である。

### Sample Explanation 1

$ 1 $ 個目のケースでは、`010` は `0101`, `0101`, `1010` の部分列です。 $ 2 $ 個目のケースでは、`11011` は `01010101`, `00110011`, `11001100` の部分列です。

## 样例 #1

### 输入

```
2

1

01

01

10

2

0101

0011

1100```

### 输出

```
010

11011```

# AI分析结果

### 题目翻译
给定三个 01 字符串 $S_1$、$S_2$、$S_3$。这些字符串各自包含 $N$ 个 `0` 和 $N$ 个 `1`。

请找出一个长度为 $2N + 1$ 的 01 字符串，使其同时为 $S_1 + S_1$、$S_2 + S_2$、$S_3 + S_3$ 的子序列（$s + t$ 表示将字符串 $s$ 和 $t$ 按此顺序连接）。在本题的约束条件下，保证这样的字符串一定存在。

共有 $T$ 组测试用例，请分别求解。

### 综合分析与结论
这些题解大多围绕构造一个满足条件的长度为 $2N + 1$ 的 01 字符串展开。多数题解采用的构造方法是 $N$ 个 $0$、$N$ 个 $1$、$1$ 个 $0$，并通过分析原字符串中 $0$ 的位置在拼接后的变化来证明其可行性。部分题解还提到了其他构造方法。整体思路较为一致，主要区别在于证明过程的详细程度和代码实现的风格。

### 题解评分
- Xssion37_XY：4星。思路清晰，代码简单易懂，有明确的分析过程。
- xiaoshumiao：4星。简洁明了地给出结论和证明，代码规范。
- nkrqzjc_zzz：3星。提出多种构造方法，但证明过程依赖图片，不够直观，且有多余的表述。
- YangXiaopei：3星。思路和证明较清晰，但代码可读性一般。
- Magus：3星。构造方法和证明常规，代码片段不完整。
- FFTotoro：3星。思路和代码都比较常规，无明显亮点。
- PDAST：3星。强调读题要点，思路和代码简单。
- skyskyCCC：3星。题意解释详细，证明和代码中规中矩。
- MurataHimeko：2星。构造方法较复杂，未给出代码实现。

### 所选题解
- Xssion37_XY（4星）
  - 关键亮点：思路清晰，代码简单易懂，有明确的分析过程。
  - 重点代码：
```cpp
#include <iostream>
using namespace std;
int n, T;
string a[3];
int main() {
    cin >> T;
    while (T--) {
        cin >> n;
        for (int i = 0; i < 3; i++) {
            cin >> a[i];
        }
        for (int i = 0; i <= n - 1; i++) {
            cout << 0;
        }
        for (int i = 0; i <= n - 1; i++) {
            cout << 1;
        }
        cout << 0 << endl;
    }
    return 0;
}
```
核心实现思想：先读取测试用例的数量 $T$，对于每个测试用例，读取 $N$ 和三个字符串，然后直接输出 $N$ 个 $0$、$N$ 个 $1$、$1$ 个 $0$。

- xiaoshumiao（4星）
  - 关键亮点：简洁明了地给出结论和证明，代码规范。
  - 重点代码：
```cpp
#include<cstdio>
using namespace std;
const int N=1000010;
char s[N];
int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d %s %s %s",&n,s,s,s);
        for(int i=1;i<=n;i++)
            printf("0");
        for(int i=1;i<=n;i++)
            printf("1");
        printf("0\n");
    }
    return 0;
}
```
核心实现思想：使用 `scanf` 读取输入，对于每个测试用例，输出 $N$ 个 $0$、$N$ 个 $1$、$1$ 个 $0$。

### 最优关键思路或技巧
- **构造法**：通过分析原字符串中 $0$ 的位置在拼接后的变化，构造出满足条件的字符串。
- **位置分析**：设原字符串中 $0$ 的位置为 $a_1,a_2,\dots,a_n$，则拼接后位置为 $a_1,a_2,\dots,a_n,a_1+2n,a_2+2n,\dots ,a_n+2n$，利用这些位置关系证明构造的可行性。

### 拓展思路
同类型题可能会改变字符串的数量、字符的种类或子序列的长度要求等。类似算法套路通常是通过分析字符串的特征（如字符的位置、数量等）来构造满足条件的字符串。

### 推荐题目
- [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：考察动态规划和子序列相关知识。
- [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)：涉及背包问题和子序列的思想。
- [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)：需要考虑字符串的子序列和字典序等问题。

### 个人心得摘录与总结
- PDAST：强调读题的重要性，指出本题要注意是子序列而不是子串，重新审题后问题变得简单。总结：读题时要仔细，明确题目要求的关键信息。 

---
处理用时：33.20秒
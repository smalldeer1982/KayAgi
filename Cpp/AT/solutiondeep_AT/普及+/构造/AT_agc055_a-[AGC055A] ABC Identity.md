# 题目信息

# [AGC055A] ABC Identity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc055/tasks/agc055_a

長さ $ 3N $ の文字列 $ S $ が与えられます。$ S $ は `A`, `B`, `C` をそれぞれちょうど $ N $ 個ずつ含みます。

文字 `A`, `B`, `C` からなる文字列 $ T $ が次の条件を満たすとき、$ T $ を **良い** 文字列であると呼びます。

- $ T $ の長さは $ 3 $ で割り切れる。この長さを $ 3K $ とする。
- $ T_1\ =\ T_2\ =\ \ldots\ =\ T_K $
- $ T_{K+1}\ =\ T_{K+2}\ =\ \ldots\ =\ T_{2K} $
- $ T_{2K+1}\ =\ T_{2K+2}\ =\ \ldots\ =\ T_{3K} $
- 文字 $ T_1,\ T_{K+1},\ T_{2K+1} $ は互いに異なる。

良い文字列の例を挙げると、`ABC`, `BBAACC`, `AAACCCBBB` です。

$ S $ を **$ 6 $ 個以下**の（連続とは限らない）部分列に分解する方法であって、各部分列が良い文字列であるような方法を一つ見つけてください。

これは、この問題の制約下で必ず可能であることが証明できます。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\cdot\ 10^5 $
- 文字列 $ S $ は、文字 `A`, `B`, `C` を $ N $ 個ずつ含む。

### Sample Explanation 1

$ S $ が部分列 `ABC`, `CBA` に分割されており、これらはそれぞれ良い文字列です。

### Sample Explanation 2

$ 1 $ の位置に対応する部分列は `AABBCC`、$ 2 $ の位置に対応する部分列は `CAB`、$ 4 $ の位置に対応する部分列は `ACB` であり、これらは全て良い文字列です。

## 样例 #1

### 输入

```
2

ABCCBA```

### 输出

```
111222```

## 样例 #2

### 输入

```
4

AABCBCAACBCB```

### 输出

```
111211241244```

# AI分析结果

### 题目翻译
给定一个长度为 $3N$ 的字符串 $S$，字符串 $S$ 中字符 `A`、`B`、`C` 的数量均为 $N$ 个。

当由字符 `A`、`B`、`C` 组成的字符串 $T$ 满足以下条件时，称 $T$ 为**好的**字符串：
- $T$ 的长度能被 $3$ 整除，设该长度为 $3K$。
- $T_1 = T_2 = \cdots = T_K$
- $T_{K + 1} = T_{K + 2} = \cdots = T_{2K}$
- $T_{2K + 1} = T_{2K + 2} = \cdots = T_{3K}$
- 字符 $T_1$、$T_{K + 1}$、$T_{2K + 1}$ 互不相同。

好的字符串的例子有：`ABC`、`BBAACC`、`AAACCCBBB`。

请找出一种将 $S$ 分解为**不超过 6 个**（不一定连续）子序列的方法，使得每个子序列都是好的字符串。

可以证明，在本题的约束条件下，这样的分解方法一定存在。

### 综合分析与结论
这些题解的核心思路一致，都是通过枚举 `ABC` 的 6 种排列，将原字符串分成等长的 3 段，在每段中选取当前排列对应位置的字符，选取数量为三段中对应字符数量的最小值，标记这些字符属于当前枚举的排列。

| 作者 | 思路清晰度 | 代码可读性 | 优化程度 | 评分 |
| ---- | ---- | ---- | ---- | ---- |
| Autumn_Rain | 思路有一定阐述，但缺乏代码，不够清晰 | 无代码 | 无优化体现 | 2 星 |
| MurataHimeko | 思路清晰，结合代码说明 | 代码结构较清晰 | 无明显优化 | 4 星 |
| hfjh | 思路详细，代码注释较丰富 | 代码可读性高 | 无明显优化 | 4 星 |

### 所选题解
- **MurataHimeko（4 星）**
    - 关键亮点：思路清晰，代码结构明确，通过函数封装更新操作。
- **hfjh（4 星）**
    - 关键亮点：思路详细，代码注释丰富，可读性高。

### 重点代码
#### MurataHimeko
```cpp
const int N = 2e5 + 5;
int a[N*3], ans[N*3];
char s[N*3];
int n, lc;
int num[3][3];
int b[7][3];

void upd (int id, int lim) {
    ++lc;
    rep(k, 0, 2) {
        int now = lim;
        rep(i, k*n+1, (k+1)*n) {
            if(!now) break;
            if(!ans[i] && a[i] == b[id][k]) {
                ans[i] = lc;
                --now;
            }
        }
    }
}

int main () {
    scanf("%d %s", &n, s + 1);
    re(i, n*3) a[i] = s[i] - 'A';
    rep(k, 0, 2) {
        rep(i, k*n+1, (k+1)*n) {
            ++num[k][a[i]];
        }
    } 
    b[1][0] = 0, b[1][1] = 1, b[1][2] = 2;
    // 省略其他排列赋值
    re(i, 6) {
        int res = min({num[0][b[i][0]], num[1][b[i][1]], num[2][b[i][2]]});
        if(res) upd(i, res);
        num[0][b[i][0]] -= res;
        num[1][b[i][1]] -= res;
        num[2][b[i][2]] -= res;
    }
    re(i, n*3) io << ans[i];
}
```
核心实现思想：先统计每段中 `A`、`B`、`C` 的数量，枚举 6 种排列，计算每段对应字符数量的最小值，调用 `upd` 函数标记字符，更新数量。

#### hfjh
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 6e5 + 9;
int n,l,r,mid,ans[N];
char a[N],ck[7][4]={{'0','0','0'},
{'A','B','C'},{'A','C','B'},
{'B','A','C'},{'B','C','A'},
{'C','A','B'},{'C','B','A'}};
int t[4][4];

void input(){
    cin>>n>>a + 1;
    for(int i = 0; i <= 2; ++i){
        for(int j = i * n + 1; j <= (i + 1) * n; ++j){
            ++t[i][a[j] - 'A']; 
        }
    }
}

void cg(int num, int cd){
    for(int i = 0; i <= 2; ++i){
        int now = num;
        for(int j = i * n + 1; j <= (i + 1) * n && now; ++j){
            if(ck[cd][i] == a[j] && (!ans[j]))
                ans[j] = cd, --now;
        }
    }
}

void op(){
    for(int i = 1; i <= 6; ++i){
        int num = min(t[0][ck[i][0] - 'A'], min(t[1][ck[i][1] - 'A'], t[2][ck[i][2] - 'A']));
        cg(num, i);
        t[0][ck[i][0] - 'A'] -= num;
        t[1][ck[i][1] - 'A'] -= num;
        t[2][ck[i][2] - 'A'] -= num;
    }
}

int main(){
    cin.tie(0)->sync_with_stdio(0);
    input();
    op();
    for(int i = 1; i <= 3 * n; ++i)
        cout<<ans[i];
}
```
核心实现思想：通过 `input` 函数统计每段字符数量，`op` 函数枚举 6 种排列，计算最小值，调用 `cg` 函数标记字符，更新数量。

### 最优关键思路或技巧
- 枚举 `ABC` 的 6 种排列，利用贪心策略，每次选取三段中对应字符数量的最小值，保证能不重不漏地划分字符串。
- 使用桶来记录每段中 `A`、`B`、`C` 的数量，方便统计和更新。

### 拓展思路
同类型题或类似算法套路：
- 字符串划分问题，可考虑枚举所有可能的排列或组合，结合贪心策略进行求解。
- 利用桶来统计字符数量，方便后续操作。

### 洛谷推荐题目
- P1003 [铺地毯](https://www.luogu.com.cn/problem/P1003)
- P1047 [校门外的树](https://www.luogu.com.cn/problem/P1047)
- P1091 [合唱队形](https://www.luogu.com.cn/problem/P1091)

### 个人心得摘录与总结
**Autumn_Rain**：提到学校月赛样例 1 输出 `121212` 被判定错误而感到恼火，推测在做此类题目时要注意输出格式和具体要求，避免因理解偏差导致错误。 

---
处理用时：41.01秒
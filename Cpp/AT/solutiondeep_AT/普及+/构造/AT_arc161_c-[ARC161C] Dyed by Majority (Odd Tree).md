# 题目信息

# [ARC161C] Dyed by Majority (Odd Tree)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc161/tasks/arc161_c

$ N $ 頂点の木が与えられます． 頂点には $ 1 $ から $ N $ までの番号が付いており，$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます． また，すべての頂点について，**接続する辺の本数は奇数**です．

与えられた木の各頂点を黒 ( `B` ) か白 ( `W` ) のいずれかの色で塗ります． このとき，「各頂点の色（ `B` または `W` ）を頂点の番号順に並べて得られる文字列」を**色の列**と呼びます．

色の列 $ S $ が与えられます． すべての頂点に色が塗られた状態で以下の操作を $ 1 $ 回行った結果，色の列が $ S $ となることがあり得るかどうかを判定し，あり得るなら操作を行う前の色の列として適切なものを $ 1 $ つ求めてください．

**操作:** 各頂点 $ k\ =\ 1,\ 2,\ \dots,\ N $ に対して，辺で結ばれた頂点の色のうち過半数を占めるものを $ C_k $ とする． すべての頂点について同時に，頂点 $ k $ の色を $ C_k $ に塗り替える．

$ T $ 個のテストケースが与えられるので，それぞれについて答えてください．

## 说明/提示

### 制約

- $ T\ \geq\ 1 $
- $ N\ \geq\ 2 $
- $ 1 $ つの入力に含まれるテストケースについて，$ N $ の総和は $ 2\ \times\ 10^5 $ 以下である．
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N\ (1\ \leq\ i\ \leq\ N\ -\ 1) $
- 与えられる辺 $ (A_i,\ B_i)\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ は木をなす．
- 各頂点 $ k\ (1\ \leq\ k\ \leq\ N) $ は $ A_i,\ B_i\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ として**合計奇数回**現れる．
- $ S $ は `B`, `W` からなる長さ $ N $ の文字列である．
 
### Sample Explanation 1

$ 1 $ つ目のテストケースについて，操作を行う前の色の列が `WBBW` であったとします． このとき， - 頂点 $ 1 $ について，辺で結ばれた頂点 $ 2,\ 3,\ 4 $ の色はそれぞれ `B`, `B`, `W` であり，過半数を占めるのは $ C_1\ =\ {} $`B`， - 頂点 $ 2 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_2\ =\ {} $`W`， - 頂点 $ 3 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_3\ =\ {} $`W`， - 頂点 $ 4 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_4\ =\ {} $`W` となります． したがって，操作後の色の列は `BWWW` となり，条件を満たします． 同様に，操作前の色の列が `WBBB`, `WBWB`, `WWBB` であった場合にも，操作後の色の列は `BWWW` となり，これらのうちどれを出力しても正答と見なされます。 $ 2 $ つ目のテストケースについて，入力された木において操作を行った結果，色の列が `BBWW` となることはあり得ません．

## 样例 #1

### 输入

```
2

4

1 2

1 3

1 4

BWWW

4

1 2

1 3

1 4

BBWW```

### 输出

```
WBBW

-1```

# AI分析结果

### 题目翻译
## [ARC161C] 多数染色（奇数树）

### 题目描述
[problemUrl]: https://atcoder.jp/contests/arc161/tasks/arc161_c

给定一棵有 $N$ 个顶点的树。顶点的编号从 $1$ 到 $N$，第 $i$ 条边连接顶点 $A_i$ 和顶点 $B_i$。此外，所有顶点的连接边数均为奇数。

给这棵树的每个顶点涂上黑色（`B`）或白色（`W`）中的一种颜色。此时，将“各顶点的颜色（`B` 或 `W`）按顶点编号顺序排列得到的字符串”称为**颜色序列**。

给定颜色序列 $S$。判断在所有顶点都已染色的状态下进行一次以下操作后，颜色序列是否有可能变为 $S$，如果可能，则求出一个操作前合适的颜色序列。

**操作**：对于每个顶点 $k = 1, 2, \dots, N$，设与其通过边相连的顶点中占多数的颜色为 $C_k$。同时将所有顶点 $k$ 的颜色都改为 $C_k$。

给定 $T$ 个测试用例，请分别给出答案。

### 说明/提示
#### 限制条件
- $T \geq 1$
- $N \geq 2$
- 对于一个输入中包含的测试用例，$N$ 的总和不超过 $2 \times 10^5$。
- $1 \leq A_i < B_i \leq N\ (1 \leq i \leq N - 1)$
- 给定的边 $(A_i, B_i)\ (1 \leq i \leq N - 1)$ 构成一棵树。
- 每个顶点 $k\ (1 \leq k \leq N)$ 在 $A_i, B_i\ (1 \leq i \leq N - 1)$ 中总共出现奇数次。
- $S$ 是由 `B` 和 `W` 组成的长度为 $N$ 的字符串。

#### 示例解释 1
对于第一个测试用例，假设操作前的颜色序列为 `WBBW`。此时：
 - 对于顶点 $1$，与其通过边相连的顶点 $2$、$3$、$4$ 的颜色分别为 `B`、`B`、`W`，占多数的颜色是 $C_1 =$ `B`；
 - 对于顶点 $2$，与其通过边相连的顶点 $1$ 的颜色是 `W`，占多数的颜色是 $C_2 =$ `W`；
 - 对于顶点 $3$，与其通过边相连的顶点 $1$ 的颜色是 `W`，占多数的颜色是 $C_3 =$ `W`；
 - 对于顶点 $4$，与其通过边相连的顶点 $1$ 的颜色是 `W`，占多数的颜色是 $C_4 =$ `W`。

因此，操作后的颜色序列为 `BWWW`，满足条件。同样，当操作前的颜色序列为 `WBBB`、`WBWB`、`WWBB` 时，操作后的颜色序列也为 `BWWW`，输出其中任何一个都被视为正确答案。

对于第二个测试用例，在输入的树中进行操作后，颜色序列不可能变为 `BBWW`。

### 样例 #1
#### 输入
```
2

4

1 2

1 3

1 4

BWWW

4

1 2

1 3

1 4

BBWW
```

#### 输出
```
WBBW

-1
```

### 综合分析与结论
这些题解的核心思路都是基于贪心策略，从叶子节点开始逐步确定节点颜色。
- **思路**：均是利用叶子节点的特性，先确定叶子节点及其父亲节点的颜色，再逐步向上处理其他节点，通过比较子节点中与目标颜色相同的数量来判断是否能满足条件，若无法满足则无解。
- **算法要点**：主要通过深度优先搜索（DFS）遍历树，在遍历过程中统计子节点的颜色信息，根据颜色数量关系确定节点颜色。
- **解决难点**：处理节点颜色数量相等的情况，以及根节点颜色无法确定时的处理。

### 题解评分与选择
- **良心WA题人**：4星。思路清晰，代码简洁易懂，对问题的分析和处理步骤明确。
- **luohanzhao**：3星。思路有一定创新性，将节点分类讨论，但代码相对复杂，可读性稍差。
- **Lucyna_Kushinada**：4星。思路和代码与“良心WA题人”相似，解释详细，便于理解。
- **CrTsIr400**：3星。思路有一定启发，但代码可读性较差，部分表述不够清晰。

选择评分较高的题解：
- **良心WA题人**：4星。关键亮点是思路清晰，代码简洁，直接从叶子节点开始处理，逐步向上确定颜色，通过DFS实现。
- **Lucyna_Kushinada**：4星。关键亮点是对节点状态进行明确分类，通过判断节点是否固定来确定颜色，同样使用DFS实现。

### 重点代码
#### 良心WA题人
```cpp
bool dfs(int u,int fa)
{
    int cnt=0;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(v==fa)
            continue;
        if(!dfs(v,u))
            return false;
        if(!col[v])
            col[v]=s[u];
        if(col[v]==s[u])
            cnt++;
    }
    if(cnt<g[u].size()/2)
        return false;
    if(cnt==g[u].size()/2)
    {
        if(!fa||col[fa]&&col[fa]!=s[u])
            return false;
        col[fa]=s[u];
    }
    return true;
}
```
**核心实现思想**：通过DFS遍历树，统计子节点中与目标颜色相同的数量，若数量不足则无解，若数量相等则将父亲节点颜色设为目标颜色。

#### Lucyna_Kushinada
```cpp
inline bool dfs(int k,int fa){
    int siz=e[k].size(),cnt=0;

    for(int x:e[k]){
        if(x==fa){
            continue;
        }

        if(!dfs(x,k)){
            return 0;
        }

        if(!ans[x]){
            ans[x]=a[k];
        }

        if(ans[x]==a[k]){
            cnt++;
        }
    }

    if(cnt<siz/2){
        return 0;
    }

    if(cnt==siz/2){
        if(!fa||(ans[fa]&&ans[fa]!=a[k])){
            return 0;
        }

        ans[fa]=a[k];
    }

    return 1;
}
```
**核心实现思想**：与“良心WA题人”的思路类似，通过DFS遍历树，根据子节点颜色数量关系确定节点颜色，若不满足条件则返回无解。

### 最优关键思路或技巧
- **贪心策略**：从叶子节点开始处理，利用叶子节点的特性逐步确定节点颜色，减少问题的复杂度。
- **深度优先搜索**：通过DFS遍历树，方便统计子节点信息，实现颜色的确定过程。

### 可拓展之处
同类型题或类似算法套路：
- 树的染色问题，根据不同的染色规则和条件，使用类似的贪心和DFS思路解决。
- 图的节点状态更新问题，通过局部信息逐步确定全局状态。

### 推荐洛谷题目
- [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)
- [P1122 最大子树和](https://www.luogu.com.cn/problem/P1122)
- [P2016 战略游戏](https://www.luogu.com.cn/problem/P2016)

### 个人心得摘录与总结
- **luohanzhao**：赛场上多测清空清错了。总结：在处理多测试用例时，要确保所有变量都正确清空，避免因变量残留导致错误。

---
处理用时：46.07秒
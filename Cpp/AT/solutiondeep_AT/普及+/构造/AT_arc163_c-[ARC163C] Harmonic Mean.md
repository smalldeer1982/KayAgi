# 题目信息

# [ARC163C] Harmonic Mean

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc163/tasks/arc163_c

以下の条件を全て満たす長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ が存在するか判定し、存在するならば一つ構築してください。

- $ \sum_{i=1}^{N}\ \frac{1}{A_i}\ =\ 1 $
- $ A $ の要素は全て相異なる。
- $ 1\ \le\ A_i\ \le\ 10^9(1\ \le\ i\ \le\ N) $
 
$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 500 $
- $ 1\ \le\ N\ \le\ 500 $
 
### Sample Explanation 1

$ 1 $ 個目のテストケースでは、$ N=3 $ です。 $ A=(2,3,6) $ は、$ \frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{6}\ =\ 1 $ かつ他の条件も全て満たすため正当です。 $ 2 $ 個目のテストケースでは、$ N=5 $ です。 $ A=(3,4,5,6,20) $ は、$ \frac{1}{3}\ +\ \frac{1}{4}\ +\ \frac{1}{5}\ +\ \frac{1}{6}\ +\ \frac{1}{20}\ =\ 1 $ かつ他の条件も全て満たすため正当です。 例えば、$ A=(5,5,5,5,5) $ は、$ 1,3 $ 個目の条件を満たしていますが同じ要素が存在するため不適であることに注意してください。

## 样例 #1

### 输入

```
2

3

5```

### 输出

```
Yes

2 3 6 

Yes

3 4 5 6 20```

# AI分析结果

### 题目内容中文重写
#### [ARC163C] 调和平均数

#### 题目描述
[problemUrl]: https://atcoder.jp/contests/arc163/tasks/arc163_c

判断是否存在满足以下所有条件的长度为 $N$ 的正整数序列 $A=(A_1,A_2,\dots,A_N)$，若存在则构造出一个这样的序列。
- $\sum_{i=1}^{N}\ \frac{1}{A_i}\ =\ 1$
- $A$ 的所有元素都互不相同。
- $1\ \le\ A_i\ \le\ 10^9(1\ \le\ i\ \le\ N)$

给定 $T$ 个测试用例，请分别求出每个测试用例的答案。

#### 说明/提示
##### 限制条件
- $1\ \le\ T\ \le\ 500$
- $1\ \le\ N\ \le\ 500$

##### 样例解释 1
第一个测试用例中，$N = 3$。$A=(2,3,6)$ 满足 $\frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{6}\ =\ 1$ 且满足其他所有条件，因此是有效的。第二个测试用例中，$N = 5$。$A=(3,4,5,6,20)$ 满足 $\frac{1}{3}\ +\ \frac{1}{4}\ +\ \frac{1}{5}\ +\ \frac{1}{6}\ +\ \frac{1}{20}\ =\ 1$ 且满足其他所有条件，因此是有效的。例如，$A=(5,5,5,5,5)$ 满足第 1、3 个条件，但存在相同元素，因此是不适合的，请务必注意。

#### 样例 #1
##### 输入
```
2
3
5
```
##### 输出
```
Yes
2 3 6 
Yes
3 4 5 6 20
```

### 综合分析与结论
这些题解大多围绕构造满足条件的正整数序列展开，核心在于利用分数拆分公式 $\frac{1}{n}=\frac{1}{n + 1}+\frac{1}{n(n + 1)}$ 或裂项相消公式 $\frac{1}{n}-\frac{1}{n + 1}=\frac{1}{n(n + 1)}$ 来构造序列。
- **思路对比**：部分题解从已知的简单解（如 $n = 3$ 时的 $\{2, 3, 6\}$）出发，通过不断拆分分数来扩展序列；部分题解则利用裂项相消公式直接构造序列，但需处理可能出现的重复项。
- **算法要点**：多数题解使用了优先队列、集合等数据结构来维护序列，方便进行元素的查找、插入和删除操作。
- **解决难点**：主要难点在于避免构造的序列中出现重复元素，以及保证序列中的元素不超过 $10^9$。不同题解采用了不同的方法来解决这些问题，如选择合适的拆分元素、特判特殊情况等。

### 所选题解
- **syzxzqy（5星）**
    - **关键亮点**：思路清晰，详细分析了 $n$ 的三种情况，代码实现简洁明了，使用小根堆和数组来维护序列，有效避免了重复元素的出现。
    - **个人心得**：作者提到注意输出末尾的换行，否则会多次出错。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10,M=1e3+10;
int T,n,t,x,x1,x2,s,i,a[N];
priority_queue<int,vector<int>,greater<int> > q;
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>T;
    while(T--){
        cin>>n;
        if(n==1){cout<<"Yes\n1\n";continue;}
        if(n==2){cout<<"No\n";continue;}
        cout<<"Yes\n";
        a[t=1]=2;q.push(3);q.push(6);
        for(i=1;i<=n-3;){
            x=q.top();q.pop();
            if(q.top()==x+1) {a[++t]=x;;continue;}
            x1=x+1;x2=x*(x+1);
            q.push(x1);q.push(x2);++i;
        }
        while(t--) q.push(a[t+1]);
        while(!q.empty()) cout<<q.top()<<" ",q.pop();
        cout<<"\n";
    } 
}
```
核心实现思想：先特判 $n = 1$ 和 $n = 2$ 的情况，对于 $n > 2$ 的情况，从已知的解 $\{2, 3, 6\}$ 开始，使用小根堆维护可拆分的数，每次取出最小的数进行拆分，若拆分后会出现重复元素，则将该数加入数组，直到序列长度达到 $n$。

- **robinyqc（4星）**
    - **关键亮点**：采用 set + 贪心的预处理方法，思路简单易懂，通过贪心选择合适的元素进行拆分，保证了序列中元素的最大值增长较慢。
    - **核心代码**：
```cpp
set<int> ans[501];

void pret() {
    ans[3].insert({2,3,6});
    for(int i=3;i<500;i++) {
        int x;
        for(int j:ans[i]) if(!ans[i].count(j+1)&&
           !ans[i].count(j*(j+1))) {x=j; break;}
        for(int j:ans[i]) if(j!=x) ans[i+1].insert(j);
        ans[i+1].insert(x+1);
        ans[i+1].insert(x*(x+1));
    }
}
```
核心实现思想：先初始化 $n = 3$ 时的解，然后通过贪心的方法，每次选择一个可以拆分且拆分后不会出现重复元素的数进行拆分，将拆分后的元素加入新的集合中，直到预处理出所有 $n$ 的解。

- **_Ad_Astra_（4星）**
    - **关键亮点**：利用裂项相消的方法构造序列，思路独特，对于出现重复元素的情况，通过选择合适的元素进行拆分来解决，时间复杂度为 $O(n)$。
    - **个人心得**：作者提醒要特判 $n = 2$ 的情况，否则会一直挂点。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
void solve()
{	
    cin>>n;
    if(n==2)
    {
        cout<<"No"<<endl;
        return;
    }
    for(int i=1;i*i<=n;i++)
        if(i*(i+1)==n)
        {
            cout<<"Yes"<<endl;
            int d;
            d=min(n-2,24LL);
            for(int j=1;j<d;j++)cout<<j*(j+1)<<' ';
            cout<<n-1<<' '<<d*(d+1)+1<<' '<<d*(d+1)*(d*(d+1)+1)<<" ";
            for(int j=d+1;j<=n-2;j++)cout<<j*(j+1)<<" ";
            cout<<endl;
            return;
        }
    cout<<"Yes"<<endl;
    for(int i=1;i<n;i++)cout<<i*(i+1)<<' ';
    cout<<n<<endl;
    return;
}
signed main()
{
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```
核心实现思想：先特判 $n = 2$ 的情况，对于一般情况，利用裂项相消公式构造序列，若 $n$ 可以表示为 $k(k + 1)$ 的形式，则选择一个合适的元素进行拆分，避免出现重复元素。

### 最优关键思路或技巧
- **分数拆分公式**：$\frac{1}{n}=\frac{1}{n + 1}+\frac{1}{n(n + 1)}$ 是构造序列的关键，通过不断拆分分数可以扩展序列。
- **裂项相消**：利用 $\frac{1}{n}-\frac{1}{n + 1}=\frac{1}{n(n + 1)}$ 可以直接构造序列，但需要处理可能出现的重复项。
- **数据结构的使用**：优先队列、集合等数据结构可以方便地维护序列，进行元素的查找、插入和删除操作。

### 可拓展之处
同类型题可能会改变序列的长度范围、元素的取值范围或分数和的目标值，解题思路仍然可以围绕分数拆分和裂项相消展开，需要根据具体情况调整构造方法。类似算法套路还可以应用于其他构造类问题，如构造满足特定条件的数组、矩阵等。

### 推荐题目
- [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)：考察连续自然数的求和与构造。
- [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)：涉及数组元素的调整和构造。
- [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：需要构造满足特定条件的数字三角形。

### 个人心得总结
- syzxzqy：注意输出末尾的换行，否则会多次出错。
- _Ad_Astra_：要特判 $n = 2$ 的情况，否则会一直挂点。

---
处理用时：56.94秒
# 题目信息

# [ARC176A] 01 Matrix Again

## 题目描述

给定一个 $N \times N$ 的矩阵，你需要向其中填入 $0$ 或 $1$，使其满足以下条件：

- $(A_1,B_1),(A_2,B_2),...,(A_M,B_M)$ 处的值为 $1$。
- 第 $i$ 行的所有数字之和为 $M$ $(1 \le i \le N)$。
- 第 $i$ 列的所有数字之和为 $M$ $(1 \le i \le N)$。

## 样例 #1

### 输入

```
4 2

1 4

3 2```

### 输出

```
8

1 2

1 4

2 1

2 4

3 2

3 3

4 1

4 3```

## 样例 #2

### 输入

```
3 3

3 1

2 3

1 3```

### 输出

```
9

1 1

1 2

1 3

2 1

2 2

2 3

3 1

3 2

3 3```

## 样例 #3

### 输入

```
7 3

1 7

7 6

6 1```

### 输出

```
21

1 6

2 4

4 1

7 3

3 6

4 5

6 1

1 7

7 6

3 5

2 2

6 3

6 7

5 4

5 2

2 5

5 3

1 4

7 1

4 7

3 2```

# AI分析结果

### 题目内容翻译
给定一个 $N \times N$ 的矩阵，你需要向其中填入 $0$ 或 $1$，使其满足以下条件：
- $(A_1,B_1),(A_2,B_2),\cdots,(A_M,B_M)$ 处的值为 $1$。
- 第 $i$ 行的所有数字之和为 $M$ $(1 \leq i \leq N)$。
- 第 $i$ 列的所有数字之和为 $M$ $(1 \leq i \leq N)$。

### 综合分析与结论
这些题解主要围绕如何构造满足条件的 $01$ 矩阵展开，不同题解思路各有特色。大部分题解利用了矩阵中斜线的性质，即选满足 $i + j \equiv k \pmod{n}$ 的所有 $(i, j)$ （$k$ 为定值）填上 $1$，可使每行每列都有一个 $1$，选 $m$ 个不同的 $k$ 就能满足每行每列有 $m$ 个 $1$，同时保证给定位置为 $1$。部分题解采用贪心、随机化等策略。

| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| XYQ_102 | 行列从 $0$ 开始，以 $(i + j) \bmod n$ 的值给每个格子编号，任选 $m$ 种编号的位置填 $1$，先填输入给定格子所在编号，不够再补充 | 用 `vector<bool>` 标记编号是否使用，最后输出结果 | 确定哪些编号的位置填 $1$ | 4星 |
| Creeper_l | 选满足 $i + j \equiv k \pmod{n}$ 的所有 $(i, j)$ （$k$ 为定值）填 $1$，选 $m$ 个不同的 $k$，保证给定 $(a_i, b_i)$ 对应 $k$ 被选 | 用 `bool` 数组标记 $k$ 是否被选，输出结果 | 满足给定位置为 $1$ 且每行每列和为 $m$ | 4星 |
| 未来姚班zyl | 将矩阵位置分成若干不相交组，选对角线 $x = y$ 及其循环上下移动得到的 $n$ 条斜线，任意选 $m$ 根，钦定的点确定对角线 | 用 `vector` 存储选择的线，输出结果 | 利用矩阵特性构造满足条件的矩阵 | 3星 |
| Shadow_T | 先将必加的点加入矩阵，统计每行每列还差多少，组合不够的行列，若出现冲突则随机化置换 | 用数组维护行和列的和，用 `map` 标记点是否被使用 | 解决组合时的冲突问题 | 2星 |
| aeiouaoeiu | 当 $m = 1$ 时，标记强制格列号，确定“主格子”，$m > 1$ 时，给“主格子”向左延一格，记录列间距并补充 | 用数组和 `vector` 存储信息，输出结果 | 拓展到 $m > 1$ 的情况 | 2星 |
| I_will_AKIOI | 按行考虑，优先处理有强制格子的行，用 `set` 维护和最小的列，放置 $m$ 个数 | 用 `map` 标记格子是否被使用，`set` 维护列和 | 防止放置时出现冲突 | 2星 |
| ben090302 | 斜线构造，从每个给定点出发跑斜线，找出第一行的点，少了就补充 | 用数组标记点是否被使用，输出结果 | 实现斜线构造 | 3星 |

### 所选题解
- **XYQ_102（4星）**
  - 关键亮点：思路清晰，利用格子编号的性质构造矩阵，代码简洁易读。
- **Creeper_l（4星）**
  - 关键亮点：分析透彻，利用同余性质选 $k$ 构造矩阵，时间复杂度低。

### 重点代码
#### XYQ_102
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
    cin>>n>>m;
    vector<bool> vis(n);
    for(int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        x--,y--;
        vis[(x+y)%n]=1;
    }
    vector<int> ans;
    for(int i=0;i<n;i++) if(vis[i]) ans.push_back(i);
    for(int i=0;i<n;i++) if(!vis[i]&&ans.size()<m) ans.push_back(i);
    cout<<n*m<<endl;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            int x=i,y=(ans[j]-i+n)%n;
            cout<<x+1<<" "<<y+1<<endl;
        }
    }
    return 0;
}
```
核心实现思想：先标记输入给定格子所在的编号，再补充编号使总数达到 $m$，最后根据编号输出矩阵中填 $1$ 的位置。

#### Creeper_l
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 2e5 + 10;
int n,m,sum;
bool vis[MAXN];
signed main() {
    cin >> n >> m;
    for(int i = 1,a,b;i <= m;i++) {
        cin >> a >> b;
        if(!vis[(a + b) % n])
            vis[(a + b) % n] = 1,sum++;
    } printf("%lld\n",n * m);
    for(int i = 0;i < n;i++) {
        if(vis[i] || sum < m) {
            if(vis[i] == false) sum++;
            for(int j = 1;j <= n;j++)
                printf("%lld %lld\n",j,(i - j + 2 * n - 1) % n + 1);
        }
    } return 0;
}
```
核心实现思想：标记给定位置对应的 $k$ 值，若 $k$ 值数量不足 $m$ 则补充，输出满足条件的矩阵位置。

### 最优关键思路或技巧
利用矩阵中斜线的性质，即选满足 $i + j \equiv k \pmod{n}$ 的所有 $(i, j)$ （$k$ 为定值）填上 $1$，可使每行每列都有一个 $1$，选 $m$ 个不同的 $k$ 就能满足每行每列有 $m$ 个 $1$，同时保证给定位置为 $1$。

### 可拓展之处
同类型题可考虑其他矩阵构造问题，如构造满足特定条件的幻方、拉丁方阵等。类似算法套路可用于解决一些图论中的构造问题，如构造满足特定度数条件的图。

### 洛谷题目推荐
- P1219 [USACO1.5]八皇后 Checker Challenge
- P1008 三连击
- P1618 三连击（升级版）

### 个人心得摘录与总结
- **未来姚班zyl**：没怎么做过构造题，导致这道构造题卡了 40 min，别人打假算都能速通，导致 perf 没上橙。总结：需要多做构造题，积累经验，抓住题目暗示特征进行构造。
- **Shadow_T**：一开始写了最多随机 15 次，赛时过了，后来过不去 after_contest，换成直接置换到查找到合适的交换对象为止就过了。总结：随机化算法要注意随机次数的选择，可能存在数据卡掉随机化，要保证算法的正确性。 

---
处理用时：52.63秒
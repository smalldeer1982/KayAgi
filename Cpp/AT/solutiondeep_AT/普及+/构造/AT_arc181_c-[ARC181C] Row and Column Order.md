# 题目信息

# [ARC181C] Row and Column Order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc181/tasks/arc181_c

$ (1,2,\dots,N) $ の順列 $ P=(P_1,P_2,\dots,P_N),\ Q=(Q_1,Q_2,\dots,Q_N) $ が与えられます。

$ N $ 行 $ N $ 列からなるマス目の各マスに文字 `0`, `1` のいずれかを書き込み、以下の条件がすべて成り立つようにしてください。

- $ i $ 行目のマスに書かれている文字を、 $ 1,2,\dots,N $ 列目の順につなげて得られる文字列を $ S_i $ としたとき、辞書順で $ S_{P_1}\ <\ S_{P_2}\ <\ \dots\ <\ S_{P_N} $ が成り立つ
- $ i $ 列目のマスに書かれている文字を、 $ 1,2,\dots,N $ 行目の順につなげて得られる文字列を $ T_i $ としたとき、辞書順で $ T_{Q_1}\ <\ T_{Q_2}\ <\ \dots\ <\ T_{Q_N} $ が成り立つ
 
なお、どのような $ P,Q $ に対しても、条件をすべて満たす書き込み方が $ 1 $ つ以上あることが証明できます。

  辞書順で $ X\ が成り立つとは？ $文字列 $ X=X_1X_2\dots\ X_{|X|} $ と $ Y\ =\ Y_1Y_2\dots\ Y_{|Y|} $ について、**辞書順で $ X\ が成り立つ $**とは、下記の 1. と 2. のどちらかが成り立つことを言います。 ここで、$ |X|,\ |Y| $ はそれぞれ $ X,\ Y $ の長さを表します。

1. $ |X|\ \lt\ |Y| $ かつ $ X_1X_2\ldots\ X_{|X|}\ =\ Y_1Y_2\ldots\ Y_{|X|} $。
2. ある整数 $ 1\ \leq\ i\ \leq\ \min\lbrace\ |X|,\ |Y|\ \rbrace $ が存在して、下記の $ 2 $ つがともに成り立つ。 
  - $ X_1X_2\ldots\ X_{i-1}\ =\ Y_1Y_2\ldots\ Y_{i-1} $
  - $ X_i $ が $ Y_i $ より小さい。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 500 $
- $ P,Q $ は $ (1,2,\dots,N) $ の順列
- 入力はすべて整数
 
### Sample Explanation 1

この入出力例の場合、 $ S_1= $`001` $ ,\ S_2= $`101` $ ,\ S_3= $`110` であり、 $ T_1= $`011` $ ,\ T_2= $`001` $ ,\ T_3= $`110` です。よって $ S_1\ <\ S_2\ <\ S_3 $ かつ $ T_2\ <\ T_1\ <\ T_3 $ が成り立ち、条件を満たします。

## 样例 #1

### 输入

```
3

1 2 3

2 1 3```

### 输出

```
001

101

110```

## 样例 #2

### 输入

```
15

8 15 10 2 4 3 1 13 5 12 9 6 14 11 7

4 1 5 14 3 12 13 7 11 8 6 2 9 15 10```

### 输出

```
010001111110101

001000000101001

010001001100010

010000011110010

010011101101101

100101110100000

111100011001000

000001001100000

100011011000101

000111101011110

101010101010101

011010101011110

010011000010011

100110010110101

000101101100100```

# AI分析结果

### 题目内容中文重写
给定一个长度为 $N$ 的排列 $P=(P_1,P_2,\dots,P_N)$ 和 $Q=(Q_1,Q_2,\dots,Q_N)$。

需要在一个 $N$ 行 $N$ 列的网格的每个格子中写入字符 `0` 或 `1`，使得以下条件全部成立：
- 设将第 $i$ 行的格子中所写的字符按第 $1,2,\dots,N$ 列的顺序连接起来得到的字符串为 $S_i$，则字典序上满足 $S_{P_1}\ <\ S_{P_2}\ <\ \dots\ <\ S_{P_N}$。
- 设将第 $i$ 列的格子中所写的字符按第 $1,2,\dots,N$ 行的顺序连接起来得到的字符串为 $T_i$，则字典序上满足 $T_{Q_1}\ <\ T_{Q_2}\ <\ \dots\ <\ T_{Q_N}$。

可以证明，对于任何 $P$ 和 $Q$，都至少存在一种满足所有条件的写入方式。

### 综合分析与结论
这些题解的核心思路大多围绕将字典序的比较转化为包含关系，通过巧妙的构造来满足行和列的字典序要求。主要的构造方法有以下几种：
1. **逐行递增构造**：让第 $i$ 行比第 $i - 1$ 行多一个 $1$，保证行的字典序递增，再按特定顺序填充列来满足列的字典序要求。
2. **特殊矩阵变换**：先构造一个满足 $P_i = Q_i = i$ 的特殊矩阵，然后通过交换行和列来满足给定的排列 $P$ 和 $Q$。
3. **人类智慧构造**：通过矩阵相加、数值转换等方式构造出满足条件的矩阵。

难点在于如何在满足行的字典序要求的同时，保证列的字典序也满足条件。不同的题解采用了不同的方法来解决这个问题，如通过控制 $1$ 的数量和位置、利用矩阵的特殊性质等。

### 所选题解
- **作者：mayike (赞：10)  4星**
    - **关键亮点**：思路清晰，详细解释了如何通过逐行递增构造矩阵来满足行和列的字典序要求，代码简洁易懂。
    - **个人心得**：作者表示自己是看了题解才会做这道题，认为这是一道很有意义的构造题。
- **作者：Register_int (赞：10)  4星**
    - **关键亮点**：直接指出将 $A < B$ 转化为 $A \subset B$ 的思路，简洁明了，代码实现简单。
- **作者：MarSer020 (赞：4)  4星**
    - **关键亮点**：将字典序关系转化为包含关系的思路很巧妙，对构造过程的解释清晰。

### 重点代码
#### 作者：mayike
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
int n,a[N][2],b[N][N];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int j=0;j<=1;j++)
        for(int i=1;i<=n;i++)cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=n-i+1;j<=n;j++)b[a[i][0]][a[j][1]]=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)cout<<b[i][j];
        cout<<"\n";
    }
    return 0;
}
```
**核心实现思想**：先读取排列 $P$ 和 $Q$，然后对于第 $i$ 行，将第 $n - i + 1$ 到 $n$ 列对应的 $Q$ 排列中的列位置置为 $1$，最后输出矩阵。

#### 作者：Register_int
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 5e2 + 10;
int n, a[MAXN], b[MAXN]; char s[MAXN][MAXN];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) s[i][j] = '0';
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) s[a[i]][b[n - j + 1]] = '1';
    }
    for (int i = 1; i <= n; i++) printf("%s\n", s[i] + 1);
}
```
**核心实现思想**：先将矩阵初始化为全 $0$，然后对于第 $i$ 行，将第 $n - j + 1$ 列对应的 $Q$ 排列中的列位置置为 $1$，最后输出矩阵。

#### 作者：MarSer020
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[505],b[505];
bool c[505][505];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        cin>>b[i];
    for(int i=1;i<=n;i++)
        for(int j=n-i+1;j<=n;j++)
            c[a[i]][b[j]]=1;
    for(int i=1;i<=n;i++,cout<<'\n')
        for(int j=1;j<=n;j++)
            cout<<c[i][j];
    return 0;
}
```
**核心实现思想**：先读取排列 $P$ 和 $Q$，然后对于第 $i$ 行，将第 $n - i + 1$ 到 $n$ 列对应的 $Q$ 排列中的列位置置为 $1$，最后输出矩阵。

### 最优关键思路或技巧
将字典序的比较转化为包含关系是解决本题的关键思路。通过让某一行（列）的 $1$ 是另一行（列）的 $1$ 的真子集，就可以保证字典序的大小关系。这种转化使得问题的解决变得更加直观和简单。

### 可拓展之处
同类型的题目可能会有更多的限制条件，如矩阵元素的取值范围更广、有更多的排序要求等。类似的算法套路可以应用在需要构造满足特定条件的矩阵或序列的问题中，关键在于找到一种合适的构造方法，将复杂的条件转化为易于处理的形式。

### 推荐洛谷题目
1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)：考察动态规划和矩阵构造。
2. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)：涉及矩阵的路径规划和数值计算。
3. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)：需要构造满足条件的路径，与本题的构造思想有相似之处。

### 个人心得摘录与总结
- **作者：mayike**：表示自己是看了题解才会做这道题，认为这是一道很有意义的构造题，体现了构造题需要一定的思维启发和学习。
- **作者：Hadtsti**：吐槽自己在比赛中状态不好，B 题忘记判断无解情况，C 题赛后才会，提醒大家要多练习，保持良好的做题状态。

---
处理用时：47.92秒
# 题目信息

# [ARC184A] Appraiser

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc184/tasks/arc184_a

この問題は **インタラクティブ** な問題であり、 **ジャッジは適応的(adaptive)** です。詳しくは注意点を参照してください。  
**また、問題文中のパラメータは $ N=1000,M=10,Q=950 $ で固定されています。**

硬貨が $ N $ 枚あり、 $ 1,2,\dots,N $ の番号が付けられています。  
これらの硬貨のうち、丁度 $ M $ 枚が偽物です。

鑑定士は $ 1 $ 度の鑑定で $ 2 $ つの硬貨が同種か異種かを判定できます。厳密には、

- $ 2 $ つの硬貨が「双方とも本物」「双方とも偽物」のどちらかであれば、同種と判定する。
- そうでないとき、異種と判定する。

$ Q $ 回以下の鑑定で、全ての偽物の硬貨を特定してください。

### Input &amp; Output Format

この問題はインタラクティブな問題です。  
最初に、 $ N,M,Q $ を標準入力から受け取ってください。

> $ N $ $ M $ $ Q $

次に、以下の流れで鑑定を $ 0 $ 回以上 $ Q $ 回以下行ってください。

まず、次の形式で標準出力に出力することで、硬貨 $ x,y $ を鑑定することを表します。 (末尾に改行を入れること。)

> ? $ x $ $ y $

ここで、 $ x,y $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。

これに対するジャッジシステムの応答は、以下の $ 3 $ 通りです。

```
0
```

応答が `0` であるとき、硬貨 $ x,y $ が同種であることを表します。

```
1
```

応答が `1` であるとき、硬貨 $ x,y $ が異種であることを表します。

```
-1
```

応答が `-1` であるとき、不当な鑑定であることを表します。具体的には

- 出力した $ x,y $ が制約を満たさなかった
- $ Q $ 回を超えて鑑定が行われた

の少なくともひとつが満たされた際にこの応答を行います。  
この応答を受け取った場合、プログラムはすでに不正解とみなされています。直ちにプログラムを終了してください。

最後に、次の形式で標準出力に出力することで、硬貨 $ A_1,A_2,\dots,A_{M} $ が偽物であると解答します。 (末尾に改行を入れること。)

> ! $ A_1 $ $ A_2 $ $ \dots $ $ A_{M} $

ここで、 $ A_i $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。  
この出力の後、直ちにプログラムを終了してください。

なお、全ての出力について、出力が指定された形式を満たさなかった場合もプログラムが不正解とみなされます。 その後 `-1` が返答されるので、その場合も直ちにプログラムを終了してください。

## 说明/提示

### 制約

- $ \color{red}{N\ =\ 1000} $
- $ \color{red}{M\ =\ 10} $
- $ \color{red}{Q\ =\ 950} $

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。** そうしなかった場合、ジャッジ結果が TLE や WA となる可能性があります。
- 解答を出力したら (または `-1` を受け取ったら) ただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください。
- **この問題のジャッジシステムは、適応的(adaptive)です。** つまり、ジャッジシステムは、任意のタイミングにおいて、整合性がとれる限り、偽物の硬貨として想定しているものを変更する可能性があります。詳しくは入出力例も参照してください。

### 入出力例

この入力では $ N=5,M=2,Q=10 $ であり、ジャッジシステムは最初硬貨 $ 1,2 $ が偽物であると想定しています。

なお、この例は制約を満たさないので、ジャッジには含まれないことに注意してください。

入力出力説明`5 2 10`$ N,M,Q $ が与えられます。`? 1 2`硬貨 $ 1,2 $ について鑑定を行います。`0`硬貨 $ 1,2 $ は同種だと判定します。`? 1 3`硬貨 $ 1,3 $ について鑑定を行います。`1`硬貨 $ 1,3 $ は異種だと判定します。`? 1 4`硬貨 $ 1,4 $ について鑑定を行います。`1`硬貨 $ 1,4 $ は異種だと判定します。`! 1 2`硬貨 $ 1,2 $ が偽物だと解答します。確かに硬貨 $ 1,2 $ は偽物だと想定されていますが、硬貨 $ 3,4 $ を偽物であると想定しても整合性が取れます。  
よって、ジャッジシステムは偽物の硬貨として想定しているものを硬貨 $ 3,4 $ に変更できます。  
これにより、ジャッジシステムは不正解の判定を下すこともあります。

# AI分析结果

### 题目内容中文重写
这是一道交互式问题，并且评测是自适应的。详细内容请参考注意事项。
另外，题目中的参数固定为 $N = 1000$，$M = 10$，$Q = 950$。

有 $N$ 枚硬币，编号为 $1, 2, \dots, N$。在这些硬币中，恰好有 $M$ 枚是假币。

鉴定师一次鉴定可以判断两枚硬币是同种还是异种。具体来说：
- 如果两枚硬币都是真币或者都是假币，判定为同种。
- 否则，判定为异种。

请在 $Q$ 次以内的鉴定中，找出所有的假币。

#### 输入与输出格式
这是一道交互式问题。首先，从标准输入读取 $N$、$M$、$Q$。
> $N$ $M$ $Q$

接下来，按照以下流程进行 $0$ 次到 $Q$ 次的鉴定。
首先，以如下格式输出到标准输出，表示对硬币 $x$ 和 $y$ 进行鉴定（末尾要换行）。
>? $x$ $y$
这里，$x$ 和 $y$ 必须是 $1$ 到 $N$ 之间的不同整数。

评测系统的响应有以下三种情况：
```
0
```
响应为 `0` 时，表示硬币 $x$ 和 $y$ 是同种。
```
1
```
响应为 `1` 时，表示硬币 $x$ 和 $y$ 是异种。
```
-1
```
响应为 `-1` 时，表示鉴定不合法。具体而言，当以下至少一种情况满足时会给出此响应：
- 输出的 $x$ 和 $y$ 不满足约束条件。
- 鉴定次数超过了 $Q$ 次。
当收到此响应时，程序已被视为错误解答，请立即终止程序。

最后，以如下格式输出到标准输出，表示硬币 $A_1, A_2, \dots, A_{M}$ 是假币（末尾要换行）。
>! $A_1$ $A_2$ $\dots$ $A_{M}$
这里，$A_i$ 必须是 $1$ 到 $N$ 之间的不同整数。输出此内容后，请立即终止程序。

需要注意的是，对于所有输出，如果不满足指定格式，程序也会被视为错误解答。之后会返回 `-1`，此时也请立即终止程序。

#### 说明/提示
##### 约束条件
- $N = 1000$
- $M = 10$
- $Q = 950$

##### 注意事项
- 每次输出时，请在末尾换行并刷新标准输出。否则，评测结果可能为 TLE 或 WA。
- 输出答案后（或收到 `-1` 后），请立即终止程序。否则，评测结果不确定。
- 请注意，多余的换行将被视为格式错误的输出。
- 本题的评测系统是自适应的。也就是说，评测系统在任意时刻，只要保持一致性，就有可能更改所认为的假币。详细内容也请参考输入输出示例。

##### 输入输出示例
在此输入中，$N = 5$，$M = 2$，$Q = 10$，评测系统最初认为硬币 $1$ 和 $2$ 是假币。
请注意，此示例不满足约束条件，因此不会出现在评测中。

| 输入输出 | 说明 |
| --- | --- |
| `5 2 10` | 给出 $N$、$M$、$Q$。 |
| `? 1 2` | 对硬币 $1$ 和 $2$ 进行鉴定。 |
| `0` | 判定硬币 $1$ 和 $2$ 是同种。 |
| `? 1 3` | 对硬币 $1$ 和 $3$ 进行鉴定。 |
| `1` | 判定硬币 $1$ 和 $3$ 是异种。 |
| `? 1 4` | 对硬币 $1$ 和 $4$ 进行鉴定。 |
| `1` | 判定硬币 $1$ 和 $4$ 是异种。 |
| `! 1 2` | 回答硬币 $1$ 和 $2$ 是假币。虽然确实最初认为硬币 $1$ 和 $2$ 是假币，但假设硬币 $3$ 和 $4$ 是假币也能保持一致性。因此，评测系统可以将所认为的假币更改为硬币 $3$ 和 $4$。这样，评测系统也可能判定为错误解答。 |

### 综合分析与结论
这些题解的核心思路都是通过分组的方式减少询问次数，利用真币数量远多于假币（$M = 10$）这一特性来确定真币，进而找出所有假币。不同题解的分组方式和后续判断方法有所不同。
- **分组方式**：常见的分组长度有 $11$、$10$、$19$、$20$、$21$ 等。分组长度为 $11$ 时，若一组内硬币全部相同则可确定为真币；分组长度为 $19$ 或 $20$ 时，可通过比较组内两部分的大小来判断真假。
- **确定真币**：通过分组比较，找出全为真币的组，从中选取一个真币作为基准，用于后续判断其他组的硬币真假。
- **判断假币**：用确定的真币与可能含有假币的组中的硬币进行比较，根据比较结果确定该组内硬币的真假。

### 所选题解
- **wmrqwq（5星）**
    - **关键亮点**：思路清晰，详细给出了 $Q = 999$ 和 $Q = 919$ 两种情况下的解法，并提供了完整代码，代码注释丰富。
    - **核心代码**：
```cpp
forll(i,1,990,11)
{
    K++;
    G[K][1].pb(i);
    forl(j,i+1,i+10)
    {
        if(!ask(i,j))
            G[K][1].pb(j);
        else
            G[K][0].pb(j),
            bl[K]=1;
    }
    if(!bl[K])
        _real=i;
}
forl(i,991,1000)
    if(ask(i,_real))
        ans.pb(i);
K=0;
forll(i,1,990,11)
    if(bl[++K])
    {
        if(ask(_real,G[K][1][0]))
            for(auto i:G[K][1])
                ans.pb(i);
        else
            for(auto i:G[K][0])
                ans.pb(i);
    }
```
    - **核心实现思想**：将前 $990$ 个硬币每 $11$ 个分为一组，共 $90$ 组。对于每组，将第一个硬币与组内其他硬币比较，若全相同则该组全为真币，记录一个真币的位置。然后用这个真币判断最后 $10$ 个硬币的真假，再判断可能含有假币的组内硬币的真假。
- **Register_int（4星）**
    - **关键亮点**：不断优化分组长度，从 $21$ 优化到 $20$ 再到 $19$，最终得到最优解，思路具有启发性。
    - **核心代码**：
```cpp
for (int i = 0, l, r; i < 90; i++) {
    l = i * 11 + 1, r = i * 11 + 11;
    if (i == 89) r = 1000;
    for (int j = l; j < r; j++) c[j + 1] = c[j] ^ ask(j, j + 1);
    int c0 = 0, c1 = 0;
    for (int j = l; j <= r; j++) c[j]? ++c1 : ++c0;
    if (c1 > 10) { for (int j = l; j <= r; j++) c[j] ^= 1; swap(c0, c1); }
    if (c0 > 10) { for (int j = l; j <= r; j++) if (c[j]) ans.emplace_back(j); }
    else p[tp++] = i;
}
if (tp) {
    for (int i = 0; i < tp; i++) {
        int l = p[i] * 11 + 1, r = p[i] * 11 + 11;
        for (int j = l; j <= r; j++) c[j]? ++t1[i] : ++t0[i];
    }
    for (int s = 0, x; s < 1 << tp; s++) {
        x = 0;
        for (int i = 0; i < 10; i++) x += (s >> i & 1)? t1[i] : t0[i];
        if (x == 10 - ans.size()) {
            for (int i = 0; i < tp; i++) {
                if (s >> i & 1) continue;
                int l = p[i] * 11 + 1, r = p[i] * 11 + 11;
                for (int j = l; j <= r; j++) c[j] ^= 1;
            }
            break;
        }
    }
    for (int i = 0; i < tp; i++) {
        int l = p[i] * 11 + 1, r = p[i] * 11 + 11;
        for (int j = l; j <= r; j++) if (c[j]) ans.emplace_back(j);
    }
    sort(ans.begin(), ans.end());
}
```
    - **核心实现思想**：将 $1000$ 个硬币分成 $89$ 个长度为 $11$ 的段和 $1$ 个长度为 $21$ 的段。通过段内比较确定段内两种硬币的数量，若一种硬币数量大于 $10$ 则为真币。对于可能存在假币的段，通过枚举确定假币。
- **I_will_AKIOI（4星）**
    - **关键亮点**：先提出简单思路，再逐步优化分组长度，解决了分组后无法判断真假的问题，代码实现清晰。
    - **核心代码**：
```cpp
tot=(n-1)/19;
for(int i=1;i<=tot;i++) L[i]=(i-1)*19+1,R[i]=i*19;
R[tot]=n;
for(int i=1;i<=tot;i++)
{
    v1[i].push_back(L[i]);
    for(int j=L[i]+1;j<=R[i];j++)
    {
        cout<<"? "<<L[i]<<" "<<j<<endl;
        int res;
        cin>>res;
        if(res==-1) while(1);
        if(res==0) v1[i].push_back(j);
        else v2[i].push_back(j);
    }
    if(v1[i].size()==10&&v2[i].size()==9||v1[i].size()==9&&v2[i].size()==10) pos=i;
}
if(pos==0)
{
    for(int i=1;i<=tot;i++)
    {
        if(v1[i].size()>v2[i].size()) for(int now:v2[i]) vis[now]=1; 
        else for(int now:v1[i]) vis[now]=1; 
    }
}
else
{
    bool check=0;
    for(int i=1;i<=tot;i++)
    {
        if(v1[i].size()==1||v2[i].size()==1)
        {
            check=1;
            break;
        }
    }
    if(check)
    {
        for(int i=1;i<=tot;i++)
        {
            if(v1[i].size()>v2[i].size()) for(int now:v2[i]) vis[now]=1; 
            else for(int now:v1[i]) vis[now]=1; 
        }
    }
    else
    {
        for(int i=1;i<=tot;i++)
        {
            if(i==pos) continue;
            if(v1[i].size()>v2[i].size()) for(int now:v2[i]) vis[now]=1; 
            else for(int now:v1[i]) vis[now]=1; 
        }
        if(v1[pos].size()==10) for(int now:v1[pos]) vis[now]=1; 
        else for(int now:v2[pos]) vis[now]=1; 
    }
}
```
    - **核心实现思想**：将 $1000$ 个硬币分成每组 $19$ 个的块。对于每个块，将第一个硬币与其他硬币比较，将硬币分成两部分。若出现两部分大小分别为 $10$ 和 $9$ 的情况，通过查找其他块中是否有大小为 $1$ 的部分来判断真假。

### 最优关键思路或技巧
- **分组思想**：通过合理分组，减少不必要的询问次数。利用假币数量较少的特点，在分组中确定真币组，进而确定真币。
- **逐步优化**：不断尝试不同的分组长度，根据分组结果调整判断方法，以达到最优的询问次数。

### 可拓展之处
同类型题可能会改变硬币总数、假币数量或询问次数的限制，解题思路仍然可以采用分组的方法，根据具体条件调整分组长度和判断策略。类似算法套路还可应用于其他需要通过有限次询问来确定元素属性的问题。

### 洛谷相似题目推荐
- [P2615 神奇的幻方](https://www.luogu.com.cn/problem/P2615)：通过一定规则构造幻方，需要根据规则进行逐步推导，与本题通过有限操作确定结果的思路类似。
- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：需要根据给定的地毯信息，判断某个点被哪些地毯覆盖，需要合理处理信息，与本题分组处理信息的思路有一定相似性。
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：通过给定的区间信息，计算剩余的树的数量，需要对区间进行处理，与本题处理分组信息的思路有相通之处。

### 个人心得摘录与总结
- **_WRYYY_**：强调不要读错题，如看错 $1$ 和 $0$ 的意义，否则会花费大量时间调试。总结为解题时要仔细审题，避免因粗心导致错误。
- **I_will_AKIOI**：表示先提出简单思路，再逐步优化，遇到问题不断尝试调整。总结为解题可先从简单思路入手，再根据问题进行优化。 

---
处理用时：79.02秒
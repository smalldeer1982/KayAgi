# 题目信息

# [ABC257E] Addition and Multiplication 2

## 题目描述

高桥君有一个整数 $x$ 。一开始的时候， $x=0$ 。

高桥君可以无限执行以下操作：

- 选择一个整数 $i$ （ $1 \leq i \leq 9$ ）。支付 $C_i$ 日元，把 $x$ 变为 $10x+i$ 。

高桥君有 $N$ 日元，问 $x$ 最大是多少？

### 约束 ###

$1 \leq N \leq 10^6$

$1 \leq C_i \leq N$

保证 $N,C_i$ 都是整数。

## 样例 #1

### 输入

```
5
5 4 3 3 2 5 3 5 3```

### 输出

```
95```

## 样例 #2

### 输入

```
20
1 1 1 1 1 1 1 1 1```

### 输出

```
99999999999999999999```

# AI分析结果

### 题目翻译
高桥君有一个整数 $x$ 。一开始的时候， $x = 0$ 。

高桥君可以无限执行以下操作：

- 选择一个整数 $i$ （ $1 \leq i \leq 9$ ）。支付 $C_i$ 日元，把 $x$ 变为 $10x + i$ 。

高桥君有 $N$ 日元，问 $x$ 最大是多少？

### 约束
$1 \leq N \leq 10^6$

$1 \leq C_i \leq N$

保证 $N, C_i$ 都是整数。

### 样例 #1
#### 输入
```
5
5 4 3 3 2 5 3 5 3
```
#### 输出
```
95
```

### 样例 #2
#### 输入
```
20
1 1 1 1 1 1 1 1 1
```
#### 输出
```
99999999999999999999
```

### 综合分析与结论
这些题解主要围绕贪心算法和动态规划算法展开，其中贪心算法是主流思路。贪心算法的核心在于先确定能得到的最大位数，再从高位到低位，尽可能选择大的数字填充，同时要保证剩余的钱足够填充后面的位数。动态规划算法则通过定义状态和状态转移方程来求解。

### 题解对比
|作者|思路|算法要点|解决难点|评分|
|----|----|----|----|----|
|ikunTLE|先求最大位数，再从高位到低位枚举，优先选大数字|计算最大位数 $L=\lfloor\frac{N}{\min\{C_i\}}\rfloor$，逐位枚举选择满足条件的最大数字|保证在剩余钱数下能填满剩余位数|4星|
|DengDuck|先求最大位数，逐位比对选最大数字，确保后面能填数|同ikunTLE|判断当前数字选择是否合法|4星|
|沉石鱼惊旋|先确定最大位数，用剩余钱置换高位数字|计算最大位数，用剩余钱从大到小置换数字|合理利用剩余钱置换数字|3星|
|Hacker_Cracker|贪心原则是先最大化长度，再最大化各位值|同ikunTLE|判断填充数字的条件|4星|
|songtaoran|先求最大位数，逐位从大到小枚举选数字|同ikunTLE|判断数字选择条件|4星|
|fyn1234|先算位数，再逐位从大到小枚举选数字|同ikunTLE|保证位数和选择最大数字|3星|
|iranai|先求最大长度，用剩余钱从高位换大数字|计算最大长度，用剩余钱置换高位数字|判断能否置换数字|3星|
|Meickol|用完全背包解决，先贪心处理优先用大数字|定义 $f_j$ 表示 $j$ 元能凑出的数字个数，贪心处理后DP求解|DP求解和回溯方案|2星|
|xmy201315|贪心一位一位放数字，从高位往低位填|同ikunTLE|判断数字能否放置|3星|
|run_away|先求最大长度，从左逐位用大数字替换|计算最大长度，用大数字替换小数字|判断能否替换数字|3星|
|Luxingguang|先算最多位数，再让前面数字更大|同ikunTLE|确定数字选择|3星|
|Disjoint_cat|先选最便宜的确定位数，再尝试替换前面的位|同沉石鱼惊旋|判断替换条件|3星|
|Bulyly|贪心选最小数确定位数，再逐位选大数字|同ikunTLE|选择合适数字|3星|
|binbin_200811|用背包思想，存每个状态数字个数|定义 $dp_i$ 表示剩余 $i$ 容量时的最大值，比较状态大小更新|状态表示和比较|2星|
|G1yu|先求最大数位，用剩余金额从高位换大数字|计算最大数位，用剩余金额置换数字|判断置换条件|3星|

### 高评分题解
- **ikunTLE（4星）**
    - **关键亮点**：思路清晰，代码简洁，准确实现了贪心算法的核心步骤。
    - **核心代码**：
```cpp
int a[15];
int main(){
    int n=read(),minn=INT_MAX;
    for(int i=1;i<=9;++i){
        a[i]=read();
        minn=min(minn,a[i]);
    }
    int l=n/minn;
    for(int i=1;i<=l;++i)
        for(int j=9;j>=1;--j)
            if(n-a[j]>=(l-i)*minn){
                printf("%d",j);
                n-=a[j];
                break;
            }
    printf("\n");
    return 0;
}
```
- **DengDuck（4星）**
    - **关键亮点**：思路解释详细，代码可读性高。
    - **核心代码**：
```cpp
long long n, c[10], mn = 1e9, len;
int main() {
    cin >> n;
    for (int i = 1; i <= 9; i++) {
        cin >> c[i];
        mn = min(mn, c[i]);
    }
    len = n / mn;
    for (int i = 1; i <= len; i++) {
        for (int j = 9; j >= 1; j--) {
            if ((n - c[j]) >= (len - i) * mn) {
                cout << j;
                n -= c[j];
                break;
            }
        }
    }
}
```
- **Hacker_Cracker（4星）**
    - **关键亮点**：对贪心思路和判断条件解释清晰。
    - **核心代码**：
```cpp
int c[15],mn=1e9,n,len;
int main(){
    cin>>n;
    for(int i=1;i<=9;i++) cin>>c[i],mn=min(mn,c[i]);
    len=n/mn;
    for(int i=1;i<=len;i++){
        for(int j=9;j>=1;j--){
            if(mn*(len-i)<=n-c[j]){
                cout<<j;
                n-=c[j];
                break;
            }
        }
    }
    cout<<endl; 
    return 0;
}
```

### 最优关键思路或技巧
- **贪心策略**：先确定最大位数，再从高位到低位，在满足剩余钱数能填满剩余位数的条件下，优先选择大的数字。
- **判断条件**：对于第 $i$ 位选择数字 $j$，判断条件为 $N - C_j \geq (Len - i) \times \min\{C_i\}$，其中 $Len$ 为最大位数。

### 可拓展之处
同类型题可能会改变操作方式或约束条件，如增加数字选择范围、改变花费规则等，但核心思路仍可围绕贪心或动态规划展开。类似算法套路可用于解决一些资源分配问题，在满足一定条件下，最大化某个目标值。

### 推荐题目
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得摘录与总结
- **binbin_200811**：一开始排除动态规划想到贪心，又回到动态规划，最后想出正解。但因忘记判断位数，考试丢分。总结为在解题时思路可能会反复，要仔细考虑各种边界条件。 

---
处理用时：47.43秒
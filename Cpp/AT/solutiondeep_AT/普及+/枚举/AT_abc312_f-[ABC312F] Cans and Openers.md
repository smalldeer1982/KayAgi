# 题目信息

# [ABC312F] Cans and Openers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc312/tasks/abc312_f

$ N $ 個の品物があります。  
 これらはそれぞれ、缶切りが不要な缶・缶切りが必要な缶・缶切りのいずれかです。  
 $ i $ 個目の品物は、整数の組 $ (T_i,\ X_i) $ により次のように表されます。

- $ T_i\ =\ 0 $ ならば、$ i $ 個目の品物は缶切りが不要な缶で、入手すると満足度 $ X_i $ を得る。
- $ T_i\ =\ 1 $ ならば、$ i $ 個目の品物は缶切りが必要な缶で、入手した上で缶切りを使うと満足度 $ X_i $ を得る。
- $ T_i\ =\ 2 $ ならば、$ i $ 個目の品物は缶切りで、$ X_i $ 個までの缶に対して使用できる。
 
$ N $ 個の品物から $ M $ 個を選んで入手するとき、得られる満足度の合計としてあり得る最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ T_i $ は $ 0,1,2 $ のいずれか
- $ 1\ \leq\ X_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ 1,\ 2,\ 5,\ 7 $ 個目の品物を入手し、$ 7 $ 個目の品物である缶切りを $ 5 $ 個目の品物に対して使用すると、満足度 $ 6\ +\ 6\ +\ 15\ =\ 27 $ を得ます。 満足度が $ 28 $ 以上になる品物の入手方法は存在しませんが、上記の例において $ 7 $ 個目の品物のかわりに $ 6 $ 個目の品物や $ 8 $ 個目の品物を選んでも満足度 $ 27 $ を得ることができます。

## 样例 #1

### 输入

```
8 4

0 6

0 6

1 3

1 5

1 15

2 1

2 10

2 100```

### 输出

```
27```

## 样例 #2

### 输入

```
5 5

1 5

1 5

1 5

1 5

1 5```

### 输出

```
0```

## 样例 #3

### 输入

```
12 6

2 2

0 1

0 9

1 3

1 5

1 3

0 4

2 1

1 8

2 1

0 1

0 4```

### 输出

```
30```

# AI分析结果

### 题目中文重写
有 $N$ 个物品。这些物品分别是不需要开罐器的罐头、需要开罐器的罐头、开罐器中的某一种。
第 $i$ 个物品由整数对 $(T_i, X_i)$ 表示，具体如下：
- 若 $T_i = 0$，则第 $i$ 个物品是不需要开罐器的罐头，获取它可得到满足度 $X_i$。
- 若 $T_i = 1$，则第 $i$ 个物品是需要开罐器的罐头，获取并使用开罐器打开它可得到满足度 $X_i$。
- 若 $T_i = 2$，则第 $i$ 个物品是开罐器，可用于打开最多 $X_i$ 个罐头。

从 $N$ 个物品中选择 $M$ 个获取时，求可得到的满足度总和的可能最大值。

### 综合分析与结论
这些题解的核心思路都是通过枚举某一类物品的数量，结合贪心和二分查找等方法来求解最大满足度。各题解的主要区别在于枚举的物品类型不同，以及处理开罐器和罐头关系的方式有所差异。
- **思路对比**：多数题解采用枚举某一类物品数量的方式，如枚举不需要开罐器的罐头、需要开罐器的罐头或开罐器的数量。然后根据所选物品数量确定其他两类物品的可选数量，通过贪心策略选择价值大的物品，并利用二分查找确定最少需要的开罐器数量。
- **算法要点**：普遍会对三类物品按价值或开罐能力从大到小排序，使用前缀和数组快速计算部分物品的总价值，结合枚举和二分查找来优化时间复杂度。
- **解决难点**：关键在于处理开罐器和需要开罐器的罐头之间的关系，确保在选择物品时满足开罐条件且总物品数不超过 $M$。

### 评分较高的题解
1. **作者：Engulf（4星）**
    - **关键亮点**：思路清晰，代码可读性高，详细注释了关键步骤。通过枚举需要开罐器的罐头个数，利用二分查找确定最少开罐器数量，贪心选择不需要开罐器的罐头。
    - **核心代码**：
```cpp
for (int i = 0; i < b.size(); i++) {
    int l = 0, r = c.size() - 1, res = -1;
    while (l <= r) {
        int mid = l + r >> 1;
        if (c[mid] >= i + 1) res = mid, r = mid - 1;
        else l = mid + 1;
    }
    if (res == -1) continue;
    int remain = m - (i + 1) - (res + 1);
    if (remain >= 0)
        ans = max(ans, b[i] + (remain? a[min((int)a.size() - 1, remain - 1)] : 0));
}
```
2. **作者：Fire_flame（4星）**
    - **关键亮点**：同样枚举需要开罐器的罐头个数，二分查找最少开罐器数量，代码简洁明了。
    - **核心代码**：
```cpp
for(int i = 0;i <= cnt2;i ++){
    if(i > s3[cnt3])break;
    int h = lower_bound(s3 + 1, s3 + cnt3 + 1, i) - s3;
    if(i == 0)h = 0;
    if(h + i > m)break;
    ans = max(ans, s2[i] + s1[m - i - h]);
}
```
3. **作者：Neil_Qian（4星）**
    - **关键亮点**：枚举不需要开罐器的罐头个数，维护可选择需要开罐器的罐头数量，利用二分查找优化判断过程。
    - **核心代码**：
```cpp
for(ll i = 0;i <= (ll)w.size()&&i <= m;i ++){
    nw = 0;
    if(i&&w.size())nw = w[i - 1];
    while(have&&have+(lower_bound(buy.begin(), buy.end(), have)-
        buy.begin() + 1)>m - i)have--;
    if(have&&lmw.size())nw += lmw[min(have, (ll)lmw.size()) - 1];
    ans = max(ans, nw);
}
```

### 最优关键思路与技巧
- **枚举与贪心结合**：通过枚举某一类物品的数量，固定部分选择，再利用贪心策略选择其他物品，简化问题。
- **二分查找优化**：在处理开罐器和需要开罐器的罐头关系时，使用二分查找快速确定最少需要的开罐器数量，将时间复杂度从 $O(n)$ 优化到 $O(\log n)$。
- **前缀和数组**：对物品价值进行前缀和预处理，可快速计算部分物品的总价值，提高计算效率。

### 拓展思路
同类型题目通常涉及多种资源的分配和选择，通过枚举、贪心和二分查找等方法求解最优解。例如，在资源有限的情况下选择不同类型的任务以获得最大收益，或者在不同类型的工具和目标之间进行匹配以达到最优效果。

### 洛谷相似题目推荐
1. [P1208 [USACO1.3]混合牛奶 Mixing Milk](https://www.luogu.com.cn/problem/P1208)：涉及贪心策略，根据不同供应商的价格和供应量选择最优购买方案。
2. [P1094 [NOIP2007 普及组] 纪念品分组](https://www.luogu.com.cn/problem/P1094)：通过贪心算法对物品进行分组，使分组数量最少。
3. [P2240 【深基12.例1】部分背包问题](https://www.luogu.com.cn/problem/P2240)：使用贪心策略解决部分背包问题，选择单位价值高的物品。

### 个人心得摘录与总结
- **Neil_Qian**：在初始化 `have` 时出错导致 WA，提醒我们在处理边界条件和初始值时要格外小心。
- **WanderingTrader**：一开始忘记在打开一个需要开罐器的罐头后进行 `--rem` 操作，却通过了部分测试点，说明测试数据可能不够全面，同时也提醒我们在调试代码时要仔细检查逻辑的完整性。

---
处理用时：37.44秒
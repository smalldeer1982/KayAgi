# 题目信息

# [ABC315D] Magical Cookies

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_d

$ H\ \times\ W $ 枚のクッキーが $ H $ 行 $ W $ 列に並んでいます。  
上から $ i $ 行目・左から $ j $ 列目のクッキーの色は英小文字 $ c_{i,j} $ で表されます。

これから、以下の手続きを行います。

1\. 各行に対して次の操作を行う : その行に $ 2 $ 枚以上のクッキーが残っており、それらの色がすべて同じならば、それらに印をつける。

2\. 各列に対して次の操作を行う : その列に $ 2 $ 枚以上のクッキーが残っており、それらの色がすべて同じならば、それらに印をつける。

3\. 印のついたクッキーがあればそれらをすべて取り除いて 1. に戻り、なければ手続きを終了する。

手続きを終了した時点で残っているクッキーの枚数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ c_{i,j} $ は英小文字である

### Sample Explanation 1

以下で示す順で手続きを行います。 - 1. により、$ 1,\ 2 $ 行目のクッキーに印をつける。 - 2. により、$ 1 $ 列目のクッキーに印をつける。 - 3. により、印を付けたクッキーを取り除く。 この時点でクッキーは以下のようになっています。ただし、クッキーを取り除いた箇所は `.` で表しています。 ``` ... ... .bc .bd ``` - 1. により、何もしない。 - 2. により、$ 2 $ 列目のクッキーに印をつける。 - 3. により、印を付けたクッキーを取り除く。 この時点でクッキーは以下のようになっています。ただし、クッキーを取り除いた箇所は `.` で表しています。 ``` ... ... ..c ..d ``` - 1. により、何もしない。 - 2. により、何もしない。 - 3. により、印がついているクッキーが存在しないので手続きを終了する。 最終的に残っているクッキーの枚数は $ 2 $ 枚です。

## 样例 #1

### 输入

```
4 3
aaa
aaa
abc
abd```

### 输出

```
2```

## 样例 #2

### 输入

```
2 5
aaaaa
abcde```

### 输出

```
4```

## 样例 #3

### 输入

```
3 3
ooo
ooo
ooo```

### 输出

```
0```

# AI分析结果

### 题目内容中文重写
# [ABC315D] 魔法饼干

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_d

有 $ H\times W $ 块饼干排成 $ H $ 行 $ W $ 列。
从上往下第 $ i $ 行、从左往右第 $ j $ 列的饼干颜色用小写英文字母 $ c_{i,j} $ 表示。

现在，进行以下操作：
1. 对每一行进行如下操作：若该行剩余 2 块及以上的饼干，且它们的颜色都相同，则给它们做上标记。
2. 对每一列进行如下操作：若该列剩余 2 块及以上的饼干，且它们的颜色都相同，则给它们做上标记。
3. 若有做标记的饼干，则将它们全部移除并回到步骤 1；若没有，则结束操作。

请计算操作结束后剩余的饼干数量。

## 说明/提示

### 限制条件
- $ 2\leq H, W\leq 2000 $
- $ c_{i,j} $ 是小写英文字母

### 样例解释 1
按以下顺序进行操作：
- 步骤 1：给第 1、2 行的饼干做标记。
- 步骤 2：给第 1 列的饼干做标记。
- 步骤 3：移除做标记的饼干。此时饼干状态如下，移除饼干的位置用 `.` 表示。
```
...
...
.bc
.bd
```
- 步骤 1：不进行任何操作。
- 步骤 2：给第 2 列的饼干做标记。
- 步骤 3：移除做标记的饼干。此时饼干状态如下，移除饼干的位置用 `.` 表示。
```
...
...
..c
..d
```
- 步骤 1：不进行任何操作。
- 步骤 2：不进行任何操作。
- 步骤 3：由于没有做标记的饼干，结束操作。
最终剩余的饼干数量为 2 块。

## 样例 #1
### 输入
```
4 3
aaa
aaa
abc
abd
```
### 输出
```
2
```

## 样例 #2
### 输入
```
2 5
aaaaa
abcde
```
### 输出
```
4
```

## 样例 #3
### 输入
```
3 3
ooo
ooo
ooo
```
### 输出
```
0
```

### 综合分析与结论
这些题解的核心思路都是模拟饼干的删除过程，通过优化判断每行每列是否可删除的方法来降低时间复杂度。

#### 思路对比
- **暴力模拟**：直接按操作步骤逐行逐列判断是否可删除，时间复杂度 $O(n^3)$，会超时。
- **桶优化**：使用桶数组记录每行每列每种字母的出现次数，将判断是否可删除的时间复杂度从 $O(n)$ 优化到 $O(26)$，整体时间复杂度降为 $O(n^2)$ 或 $O(26n^2)$。

#### 算法要点
- **初始化**：读入饼干矩阵，同时用桶数组记录每行每列每种字母的出现次数。
- **循环判断**：不断循环，每次判断每行每列是否可删除，记录可删除的行和列。
- **更新操作**：删除可删除的行和列，并更新桶数组。
- **结束条件**：当没有可删除的行和列时，结束循环，统计剩余饼干数量。

#### 解决难点
- **避免误判**：在删除过程中，要注意避免因为提前更新桶数组而导致误判某些行或列是否可删除。部分题解使用临时数组记录要删除的元素，在标记完所有可删除的行和列后再统一更新桶数组。
- **复杂度优化**：通过桶数组将判断是否可删除的时间复杂度从 $O(n)$ 优化到 $O(26)$，避免了 $O(n^3)$ 的时间复杂度。

### 所选题解
- **作者：_zzzzzzy_ (赞：5)，4星**
    - **关键亮点**：思路清晰，代码简洁，使用桶数组优化判断过程，复杂度为 $O((n + m)^2)$。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2050;
int n, m, st1[maxn][26], st2[maxn][26];
char mp[maxn][maxn];
bool vis1[maxn], vis2[maxn];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mp[i][j];
        }
        for (int j = 1; j <= m; j++) {
            st1[i][mp[i][j] - 'a']++;
            st2[j][mp[i][j] - 'a']++;
        }
    }
    while(1) {
        vector<int> r, c;
        for (int i = 1; i <= n; i++) {
            if (!vis1[i]) {
                int cnt = 0, tot = 0;
                for (int j = 0; j < 26; j++) {
                    cnt += st1[i][j] > 0;
                    tot += st1[i][j];
                }
                if (cnt == 1 && tot > 1) {
                    r.push_back(i);
                }
            }
        }
        for (int i = 1; i <= m; i++) {
            if (!vis2[i]) {
                int cnt = 0, tot = 0;
                for (int j = 0; j < 26; j++) {
                    cnt += st2[i][j] > 0;
                    tot += st2[i][j];
                }
                if (cnt == 1 && tot > 1) {
                    c.push_back(i);
                }
            }
        }
        for (int x : r) {
            vis1[x] = 1;
            for (int j = 1; j <= m; j++) {
                if (mp[x][j] != '.') {
                    st1[x][mp[x][j] - 'a']--;
                    st2[j][mp[x][j] - 'a']--;
                }
                mp[x][j] = '.';
            }
        }
        for (int x : c) {
            vis2[x] = 1;
            for (int j = 1; j <= n; j++) {
                if (mp[j][x] != '.') {
                    st1[j][mp[j][x] - 'a']--;
                    st2[x][mp[j][x] - 'a']--;
                }
                mp[j][x] = '.';
            }
        }
        if (!r.size() && !c.size()) {
            break;
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            ans += (mp[i][j] != '.');
        }
    }
    cout << ans << "\n";
    return 0;
}
```
核心实现思想：使用 `st1` 和 `st2` 数组分别记录每行每列每种字母的出现次数，通过循环判断每行每列是否可删除，将可删除的行和列记录在 `r` 和 `c` 数组中，最后统一删除并更新数组，直到没有可删除的行和列。

- **作者：banned_xiejiayun (赞：4)，4星**
    - **关键亮点**：详细解释了使用临时数组记录删除元素的原因，避免了误判，复杂度为 $O(n^2)$。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m;
int x, y;
bool h_flag[2010], l_flag[2010];//标记每一行是否删除
int h_c[2010][30], l_c[2010][30];//每一行（列）的字母统计
int h_c_tmp[2010][30], l_c_tmp[2010][30];//每一行（列）每个字母删除的个数
char c;
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> c;
            h_c[i][c - 'a']++;
            l_c[j][c - 'a']++;//初始统计
        }
    }
    int nn = n, mm = m, ans = n * m;
    //nn mm 是现在矩阵的长和宽
    //ans 默认是一个也没删除
    while (1) {
        if (nn < 2 && mm < 2)break;//这种情况下已经不可能再删了
        x = 0;
        y = 0;
        memset(h_c_tmp, 0, sizeof(h_c_tmp));
        memset(l_c_tmp, 0, sizeof(l_c_tmp));
        bool flag_n = 0, flag_m = 0;//标记是否有删除一个行
        int nn__ = nn; //临时的nn__
        if (mm >= 2) {
            //行内元素>=2
            for (int i = 1; i <= n; i++) {
                if (h_flag[i])continue;//如果已经被删过了，就跳过
                for (int j = 0; j < 26; j++) {
                    if (h_c[i][j]) {
                        if (h_c[i][j] == mm) {//如果这个字母占了整一行
                            if (!flag_n)flag_n = 1;
                            ans -= mm;
                            x++;//删除的行++
                            h_flag[i] = 1;//标记为已删
                            nn__--;//长度--
                            for (int k = 1; k <= m; k++) {
                                l_c_tmp[k][j]++;//记录这一行
                            }
                        } else break;
                        //如果这个字母有，但是不是全部，就代表这一行不可能全相等
                    }
                }
            }
        }
        
        //删列和删行一个道理：
        int mm__ = mm;
        if (nn >= 2) {
            for (int i = 1; i <= m; i++) {
                if (l_flag[i])continue;
                for (int j = 0; j < 26; j++) {
                    if (l_c[i][j]) {
                        if (l_c[i][j] == nn) {
                            if (!flag_m)flag_m = 1;
                            ans -= nn;
                            y++;
                            l_flag[i] = 1;
                            mm__--;
                            for (int k = 1; k <= n; k++) {
                                h_c_tmp[k][j]++;
                            }
                        } else break;
                    }
                }
            }
        }
        if (!flag_m && !flag_n)break;//如果两个都没删成，就没得删除
        for (int i = 1; i <= m; i++)
            for (int j = 0; j < 26; j++) {
                l_c[i][j] -= l_c_tmp[i][j];
            }
        for (int i = 1; i <= n; i++)
            for (int j = 0; j < 26; j++) {
                h_c[i][j] -= h_c_tmp[i][j];
            }
        ans += x * y;//删除了x行y列，中间会重复删x*y个，加回来。
        nn = nn__;
        mm = mm__;
    }
    cout << ans;
    return 0;
}
```
核心实现思想：使用 `h_c` 和 `l_c` 数组记录每行每列每种字母的出现次数，使用 `h_c_tmp` 和 `l_c_tmp` 数组记录要删除的元素，避免在标记过程中更新数组导致误判，最后统一更新数组。

### 最优关键思路或技巧
- **桶数组优化**：使用桶数组记录每行每列每种字母的出现次数，将判断是否可删除的时间复杂度从 $O(n)$ 优化到 $O(26)$。
- **避免误判**：使用临时数组记录要删除的元素，在标记完所有可删除的行和列后再统一更新桶数组，避免提前更新导致误判。

### 拓展思路
同类型题或类似算法套路：
- **矩阵操作类问题**：涉及矩阵的行和列的操作，如矩阵的旋转、删除、填充等，可使用类似的模拟和优化方法。
- **状态更新类问题**：在操作过程中需要不断更新状态，可使用数组记录状态，避免重复计算。

### 推荐洛谷题目
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：涉及矩阵的路径规划，需要模拟和状态更新。
- [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)：模拟比赛过程，需要不断更新比赛状态。
- [P1098 字符串的展开](https://www.luogu.com.cn/problem/P1098)：模拟字符串的展开过程，需要处理各种情况。

### 个人心得摘录与总结
- **作者：Zi_Gao**：第一次在比赛上切这么高评分的题，感觉题目不难但很多人现场没切出来。分析了暴力做法的复杂度并进行优化，通过开桶数组记录字母出现次数将复杂度从 $O(n^3)$ 优化到 $O(n^2)$。
- **作者：banned_xiejiayun**：解释了使用临时数组记录删除元素的原因，避免在循环过程中直接删除元素导致误判，如示例 `aaa aaa bbc`，直接删除可能会导致错误删除 `b` 列。 

---
处理用时：80.94秒
# 题目信息

# [ABC321E] Complete Binary Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc321/tasks/abc321_e

$ 1 $ から $ N $ までの番号が付けられた $ N $ 頂点からなる木があります。 各 $ i\ (2\ \leq\ i\ \leq\ N) $ について、頂点 $ i $ と頂点 $ \lfloor\ \frac{i}{2}\ \rfloor $ を結ぶ辺が張られています。 逆に、これら以外の辺は存在しません。

この木において、頂点 $ X $ との距離が $ K $ である頂点の数を求めてください。 ただし、$ 2 $ 頂点 $ u,v $ の距離は、頂点 $ u,v $ を結ぶ単純パスに含まれる辺の個数として定義されます。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\leq\ T\ \leq\ 10^5 $
- $ 1\leq\ N\ \leq\ 10^{18} $
- $ 1\leq\ X\ \leq\ N $
- $ 0\leq\ K\ \leq\ N-1 $
- 入力は全て整数
 
### Sample Explanation 1

$ N=10 $ のとき、木は以下の図のようになります。 !\[\](https://img.atcoder.jp/abc321/0d1a718458ffcf25a6bc26d11b3a7641.png) このとき、 - 頂点 $ 2 $ との距離が $ 0 $ である頂点は $ 2 $ の $ 1 $ つです。 - 頂点 $ 2 $ との距離が $ 1 $ である頂点は $ 1,4,5 $ の $ 3 $ つです。 - 頂点 $ 2 $ との距離が $ 2 $ である頂点は $ 3,8,9,10 $ の $ 4 $ つです。 - 頂点 $ 2 $ との距離が $ 3 $ である頂点は $ 6,7 $ の $ 2 $ つです。 - 頂点 $ 2 $ との距離が $ 4 $ である頂点は存在しません。

## 样例 #1

### 输入

```
5

10 2 0

10 2 1

10 2 2

10 2 3

10 2 4```

### 输出

```
1

3

4

2

0```

## 样例 #2

### 输入

```
10

822981260158260522 52 20

760713016476190629 2314654 57

1312150450968417 1132551176249851 7

1000000000000000000 1083770654 79

234122432773361868 170290518806790 23

536187734191890310 61862 14

594688604155374934 53288633578 39

1000000000000000000 120160810 78

89013034180999835 14853481725739 94

463213054346948152 825589 73```

### 输出

```
1556480

140703128616960

8

17732923532771328

65536

24576

2147483640

33776997205278720

7881299347898368

27021597764222976```

# AI分析结果

### 题目中文重写
有一棵由编号从 $1$ 到 $N$ 的 $N$ 个顶点组成的树。对于每个 $i\ (2\ \leq\ i\ \leq\ N)$，存在一条连接顶点 $i$ 和顶点 $\lfloor\ \frac{i}{2}\ \rfloor$ 的边。相反，不存在其他边。

在这棵树中，请求出与顶点 $X$ 距离为 $K$ 的顶点的数量。这里，两个顶点 $u$ 和 $v$ 的距离定义为连接顶点 $u$ 和 $v$ 的简单路径中包含的边的数量。

给定 $T$ 个测试用例，请分别求出每个测试用例的答案。

### 综合分析与结论
这些题解的核心都是基于完全二叉树的性质来求解与给定节点距离为 $K$ 的节点数量。主要思路是将问题拆分为向下走和向上走两部分，向下走通过确定目标层最左和最右节点编号来计算节点数，向上走则遍历祖先节点并减去重复路径的影响。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|Genius_Star|先计算向下走 $k$ 条边能到的点数，再遍历祖先节点，计算其向下走 $k - p$ 条边的点数并减去重复部分|利用完全二叉树性质找目标层最左和最右节点，遍历祖先节点|处理边界情况，避免重复计算|4星|
|sunzz3183|通过一步步往上跳，判断子树的第 $k - temp$ 层是否为最后一层，计算该层节点数|根据节点层数和剩余步数判断情况，计算节点数|判断子树层数与整棵树层数的关系|4星|
|不知名用户|枚举 $X$ 和目标节点的 LCA，计算 LCA 子树中符合条件的节点数，处理 LCA 后代走向 LCA 路径的情况|枚举 LCA，强制 LCA 向另一边子节点走一步|避免 LCA 后代走回 LCA 路径|3星|
|robertuu|将距离 $x$ 为 $k$ 的点分为几部分，不断向上跳并更新答案，分三种情况处理|向上跳更新答案，分情况计算节点数|处理变量溢出和半满层情况|3星|
|OIerBoy|一层一层计算贡献，计算子树第 $i$ 层节点数时判断是否存在和是否满层|逐层计算贡献，判断子树层数情况|处理子树层数细节|3星|
|happybob|枚举 LCA，转化为求点 $u$ 子树中到 $u$ 距离为 $k$ 的点的数量|枚举 LCA，计算子树中符合条件的节点数|无明显难点|3星|
|rainygame|将答案分为 $x$ 子树内和子树外两部分，分别处理|设置指针向下走，向上走化为子树内问题|处理最后一层节点数统计|3星|
|liyujia|枚举 LCA，特判 LCA 符合条件的情况，递归处理子树|枚举 LCA，递归处理子树|递归处理子树情况|3星|
|small_john|求节点 $u$ 的 $k$ 层儿子个数，逐层往上找距离 $u$ 为 $k$ 的点|计算 $k$ 层儿子最左和最右节点编号，逐层往上找|处理节点编号越界|3星|
|wizardMarshall|枚举往上走的步数，避免走回头路，计算子树中符合条件的节点数|枚举往上走步数，往另一个儿子走一步再计算|避免走回头路和处理位运算越界|3星|
|Hellsing_Alucard|将答案分为儿子和其他节点两部分，分别暴力计算|暴力枚举儿子节点，向上爬查找其他节点|处理节点编号越界|3星|

### 所选题解
- **Genius_Star（4星）**
    - **关键亮点**：思路清晰，代码简洁，对向下走和向上走的情况分别处理，有效避免重复计算。
    - **核心代码**：
```cpp
ll F(ll x,ll n,ll k){ //计算 x 号点向下走 k 条边能走到的点数
    if(k<0)
        return 0;
    ll l=x,r=x;
    for(int i=0;i<k;i++){
        l<<=1ll;
        r=r<<1ll|1ll;
        if(l>n)  //如果最左边点都超过 n 了，那么没有贡献
            return 0;
    }
    return min(r,n)-l+1ll;
}
int main(){
    T=read();
    while(T--){
        n=read(),x=read(),k=read();
        ans=F(x,n,k);
        while(x/2ll){ //遍历 x 的祖先
            k--;
            ans+=F(x/2,n,k)-F(x,n,k-1);
            x>>=1ll;
        }   
        write(ans);
        putchar('\n');
    }
    return 0;
}
```
    - **核心实现思想**：`F` 函数用于计算从节点 $x$ 向下走 $k$ 条边能到达的节点数，通过不断将 $x$ 乘以 $2$ 得到最左节点，乘以 $2$ 加 $1$ 得到最右节点，取最右节点和 $n$ 的最小值计算节点数。主函数中先计算向下走的节点数，再遍历祖先节点，计算其向下走的节点数并减去重复部分。

- **sunzz3183（4星）**
    - **关键亮点**：通过一步步往上跳的方式，清晰地处理了子树层数与整棵树层数的关系，代码注释详细。
    - **核心代码**：
```cpp
void solve(int u,int temp,int lst){
    if(!u)return;//跳到终点
    if(temp==k){ans++;return;}//无法跳跃
    int sonl=u<<1,sonr=u<<1|1;//左右儿子
    if(sonl!=lst){//判断，不能往回计算
        int dep=floor(log2(sonl))+1,len=k-temp-1;//该儿子的层数，还能走的步数（注意这里到儿子的步数是 temp+1）
        if(dep+len<d)//不到最后一层
            ans+=1ll<<len;
        else if(dep+len==d){//是最后一层
            int l=sonl<<len;//看解释
            int r=(l-1)+(1ll<<len);
            r=min(n,r);
            if(l<=r)ans+=r-l+1;
        }//还有超过最后一层，因为为 0，所以不考虑
    }
    //同上
    if(sonr!=lst){
        int dep=floor(log2(sonr))+1,len=k-temp-1;
        if(dep+len<d)
            ans+=1ll<<len;
        else if(dep+len==d){
            int l=sonr<<len;
            int r=(l-1)+(1ll<<len);
            r=min(n,r);
            if(l<=r)ans+=r-l+1;
        }
    }
    solve(u>>1,temp+1,u);//向上跳跃
    return;
}
```
    - **核心实现思想**：`solve` 函数通过递归的方式，从节点 $u$ 开始，判断左右儿子节点是否可走，根据儿子节点的层数和剩余步数判断情况，计算节点数，然后向上跳跃继续处理。

### 最优关键思路或技巧
- 利用完全二叉树的性质，通过节点编号的运算（如乘以 $2$ 和乘以 $2$ 加 $1$）快速找到目标层的最左和最右节点。
- 枚举 LCA 或向上跳的步数，将问题转化为计算子树中符合条件的节点数，避免重复计算。
- 处理边界情况，如节点编号越界和最后一层节点数的统计。

### 拓展思路
同类型题可以是在其他特殊树结构（如满二叉树、线段树等）中求与给定节点距离为 $K$ 的节点数量，或者是在图中求最短路径为 $K$ 的节点数量。类似算法套路包括枚举 LCA、递归处理子树、利用树的性质进行节点编号运算等。

### 洛谷题目推荐
1. [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)：在树中求到所有节点距离之和最小的节点。
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)：求树中两个节点的最近公共祖先。
3. [P4180 [BJWC2010]严格次小生成树](https://www.luogu.com.cn/problem/P4180)：在图中求严格次小生成树，涉及树的路径查询。

### 个人心得摘录与总结
- **OIerBoy**：考场没调出来，考完赶紧写发题解祭奠一下。总结：考试时可能因为细节问题导致代码无法通过，考完后要及时总结经验。
- **rainygame**：最后二十分钟终于过了 E……总结：在考试最后阶段也不要放弃，坚持调试可能会通过题目。 

---
处理用时：63.76秒
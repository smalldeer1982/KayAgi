# 题目信息

# [AGC001C] Shorten Diameter

## 题目描述

给你一棵 $N$ 个点的无向树，定义点 $u$ 和 $v$ 之间的距离是从 $u$ 到 $v$ 的简单路径上的边数。

你需要删除一些点，使树的直径小于等于 $K$，当且仅当删除某点不会对树的联通性产生影响时才可以删除。问至少删除多少点才可以满足要求。

## 说明/提示

$2≤N≤2000$，$1≤K≤N-1$，保证给出的图是一棵树。

## 样例 #1

### 输入

```
6 2

1 2

3 2

4 2

1 6

5 6```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2

3 2

4 2

1 6

5 6```

### 输出

```
0```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕如何通过删除最少的叶子节点，使树的直径不超过给定值 $k$ 展开。思路上大多采用对 $k$ 的奇偶性进行分类讨论的方法，具体实现上有枚举直径中点（偶数情况）或中间边（奇数情况），再通过深度优先搜索（DFS）计算可保留的节点数；也有采用贪心和动态规划的思路。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|hhoppitree|对 $k$ 奇偶讨论，偶数枚举直径中点，奇数枚举直径中间边，用 DFS 计算可保留节点数|奇偶分类，DFS|确定枚举对象和计算可保留节点数|4星|
|jyz666|与 hhoppitree 类似，分情况讨论，用 DFS 计算可保留节点数|奇偶分类，DFS|确定枚举对象和计算可保留节点数|3星|
|LinkZelda|贪心思路，每次找出直径，删去能到达距离 $>k$ 的点个数较大的端点|贪心，找直径|贪心策略的正确性证明|3星|
|AsunderSquall|对 $k$ 奇偶讨论，偶数枚举直径中点，奇数枚举直径中间边，用 DFS 计算可保留节点数|奇偶分类，DFS|注意奇数情况的 $vis$ 数组处理|3星|
|dcmfqw|动态规划，记 $dp_{i,j}$ 表示以 $i$ 节点为根的子树中相关状态下的最大点数|动态规划，状态转移|状态转移方程的推导和优化|3星|
|foreverlasting|暴力枚举每一种有根树，将深度超过 $k/2$ 的点删掉|暴力枚举，DFS|枚举的实现和深度计算|3星|
|huayucaiji|对 $k$ 奇偶讨论，偶数枚举直径中点，奇数枚举直径中间边，用 DFS 计算需删除节点数|奇偶分类，DFS|确定枚举对象和计算需删除节点数|3星|
|ImmortalWatcher|对 $k$ 奇偶讨论，枚举中心，计算贡献|奇偶分类，DFS|确定枚举对象和计算贡献|3星|
|Fengxiang008|对 $k$ 奇偶讨论，偶数枚举点，奇数枚举边，用 DFS 计算需删除节点数|奇偶分类，DFS|确定枚举对象和计算需删除节点数|3星|
|Priori_Incantatem|对 $k$ 奇偶讨论，枚举点或边作为直径中点，计算可保留节点数|奇偶分类，DFS|确定枚举对象和计算可保留节点数|3星|

### 所选题解
- **hhoppitree（4星）**
    - **关键亮点**：思路清晰，代码简洁，对 $k$ 的奇偶性分类讨论明确，DFS 实现简单易懂。
    - **核心代码**：
```cpp
void dfs(int x,int p,int fa=-1){
    vis[x]=1;
    ++cnt;
    if(!p){
        return;
    }
    for(register int i=0;i<G[x].size();++i){
        int v=G[x][i];
        if(v==fa||vis[v]){
            continue;
        }
        dfs(v,p-1,x);
    }
    return;
}
// ...
if(!(k&1)){
    for(register int i=1;i<=n;++i){
        memset(vis,0,sizeof(vis));
        cnt=0;
        dfs(i,k/2);
        ans=min(ans,n-cnt);
    }
}
else{
    for(register int i=1;i<=n;++i){
        for(register int j=0;j<G[i].size();++j){
            int v=G[i][j];
            memset(vis,0,sizeof(vis));
            cnt=0;
            dfs(i,k/2,v),dfs(v,k/2,i);
            ans=min(ans,n-cnt);
        }
    }
}
```
    - **核心实现思想**：对于偶数 $k$，枚举每个点作为直径中点，用 DFS 计算距离该点不超过 $k/2$ 的节点数；对于奇数 $k$，枚举每条边，对边的两端分别进行 DFS，计算距离两端点不超过 $k/2$ 的节点数，最后取最小的删除节点数。

### 最优关键思路或技巧
- **奇偶分类讨论**：根据 $k$ 的奇偶性，分别枚举直径的中点（偶数情况）或中间边（奇数情况），简化问题。
- **DFS 计算节点数**：通过深度优先搜索，计算距离特定点或边不超过一定距离的节点数，从而确定可保留的节点数。

### 可拓展之处
同类型题或类似算法套路：
- 树的相关问题，如树的重心、树的直径的其他应用。
- 图的删点或删边问题，通过分类讨论和搜索算法解决。

### 推荐题目
- [P1395 会议](https://www.luogu.com.cn/problem/P1395)：涉及树的重心相关知识。
- [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)：与树的直径和距离相关。
- [P2986 [USACO10MAR]Great Cow Gathering G](https://www.luogu.com.cn/problem/P2986)：树的路径和节点权值相关问题。

### 个人心得摘录与总结
- **jyz666**：考试时想复杂了，试图从直径两头删点，包含大量特殊情况，走入死路。总结：遇到问题要从整体考虑，避免陷入复杂的特殊情况处理。
- **Fengxiang008**：K 为奇数时走了弯路，一开始只是以为在偶数情况基础上扩展一个点，结果半天没调过。总结：对于不同情况要深入分析，不能简单类推。

---
处理用时：36.05秒
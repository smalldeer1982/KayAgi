# 题目信息

# [AGC005B] Minimum Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc005/tasks/agc005_b

すぬけ君はある日友人から長さ $ N $ の順列 $ a_1,\ a_2,\ ...,\ a_N $ を貰いました。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc005_b/7385c80af4629f5f6d11fed58e1b38d3c006d06d.png)

を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 200,000 $
- $ (a_1,\ a_2,\ ...,\ a_N) $ は $ (1,\ 2,\ ...,\ N) $ を並び替えたものである

## 样例 #1

### 输入

```
3

2 1 3```

### 输出

```
9```

## 样例 #2

### 输入

```
4

1 3 2 4```

### 输出

```
19```

## 样例 #3

### 输入

```
8

5 4 8 1 2 6 7 3```

### 输出

```
85```

# AI分析结果

### 题目翻译
有一天，苏努克君从朋友那里得到了一个长度为 $N$ 的排列 $a_1, a_2, ..., a_N$ 。

请计算

（此处缺少具体的计算公式，原题目中为图片形式）

### 综合分析与结论
这些题解的核心思路都是计算每个数对答案的贡献，即找出每个数作为最小值的区间个数，再乘以该数的值，最后将所有数的贡献相加。不同题解采用了不同的算法来实现这一思路，主要有单调栈、平衡树、并查集、悬线法、分治等。

| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| Leianha | 用单调栈求出每个数左右第一个比它小的值的位置，进而计算其作为最小值的区间个数 | 维护单调栈，栈顶元素被弹出时记录右边第一个小值位置，当前元素入栈时记录左边第一个小值位置 | 避免只处理单边位置导致时间复杂度退化 | 4星 |
| _jimmywang_ | 用平衡树按数从小到大的顺序处理，计算每个数包含但不包含更小值的子段数 | 利用平衡树的前驱和后驱找到合法子段区间 | 平衡树的实现和子段数的计算 | 3星 |
| rui_er | 将数列抽象成链，按边权从大到小排序，用并查集合并连通块计算边的贡献 | 边按权值排序，合并连通块时根据大小计算贡献 | 理解边的贡献计算和并查集的使用 | 3星 |
| Fuko_Ibuki | 利用已求出的答案辅助计算每个数左右最远比它大的位置，进而计算区间个数 | 顺序和逆序遍历数组，利用前面的结果更新当前位置 | 理解如何利用前面的结果优化计算 | 3星 |
| peterwuyihong | 悬线法，记录每个数扩展的左右边界，利用已算信息更新边界 | 顺序和逆序遍历更新左右边界 | 理解悬线法的思想和边界更新 | 3星 |
| 流逝丶 | 单调栈求出每个数左右第一个比它小的位置，乘法原理计算区间个数，处理重复数 | 维护单调栈，左右边界一个小于一个小于等于 | 重复数的处理 | 3星 |
| Otomachi_Una_ | 用优先队列记录未分配答案的数值和位置，更新左右区间 | 优先队列判断队首和新元素大小关系更新区间 | 优先队列的使用和区间更新 | 3星 |
| Starlight_Glimmer | 倒序枚举元素，更新其他数的影响区间，计算区间个数 | 倒序枚举，更新左右端点 | 理解影响区间的更新 | 3星 |
| AsunderSquall | 分治求解，用st表 $\mathcal{O}(1)$ 处理区间最小值，递归计算贡献 | 分治处理区间，st表预处理 | 分治的实现和st表的使用 | 3星 |
| WuhenGSL | 以数字为边权建链，从大到小遍历边，用并查集维护连通块计算边的贡献 | 边排序，合并连通块计算贡献 | 理解边的贡献和并查集的使用 | 3星 |

### 所选题解
- **Leianha（4星）**
    - **关键亮点**：思路清晰，详细解释了单调栈的使用和时间复杂度分析，给出了超时和满分代码对比。
    - **重点代码**：
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
int n,top,minn;
const int N=1000010;
int a[N],zhan[N],r[N],l[N];
long long ans;
signed main()
{
    cin>>n;
    for(int i=1;i<=n;++i)scanf("%lld",&a[i]);
    for(int i=1;i<=n;++i)r[i]=n+1,l[i]=0;
    for(int i=1;i<=n;++i)
    {
        while(top&&a[zhan[top]]>a[i])r[zhan[top--]]=i;
        l[i]=zhan[top];
        zhan[++top]=i;
    }
    for(int i=1;i<=n;++i)ans+=(r[i]-i)*(i-l[i])*a[i];
    cout<<ans;
    return 0;
}
```
    - **核心实现思想**：通过单调栈维护一个递增的序列，栈顶元素被弹出时，记录其右边第一个比它小的元素位置；当前元素入栈时，记录其左边第一个比它小的元素位置。最后根据左右位置计算每个数的贡献。

### 最优关键思路或技巧
- **单调栈**：可以在 $\mathcal{O}(n)$ 时间内求出每个数左右第一个比它小的值的位置，避免了暴力枚举的 $\mathcal{O}(n^2)$ 复杂度。
- **拆贡献思想**：将问题转化为计算每个数的贡献，简化了问题的求解。

### 拓展思路
同类型题或类似算法套路：
- 计算矩形面积、直方图最大矩形面积等问题，可使用单调栈求解。
- 涉及区间最值和贡献计算的问题，可考虑拆贡献的思想。

### 推荐洛谷题目
- P2659 [SCOI2010]股票交易
- P1725 琪露诺
- P3467 [POI2008]PLA-Postering

### 个人心得摘录与总结
- **Leianha**：提到只处理单边位置（r[i]）在精心构造的数据下会导致时间复杂度飙升到 $O(n^2)$，最好同时处理 l[i] 和 r[i]，避免超时。总结就是在使用单调栈时要注意全面处理左右信息，防止复杂度退化。 

---
处理用时：37.43秒
# 题目信息

# [ABC253F] Operations on a Matrix

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc253/tasks/abc253_f

縦 $ N $ 行、横 $ M $ 列の行列があり、はじめ全ての成分は $ 0 $ です。

以下のいずれかの形式で表されるクエリを $ Q $ 個処理してください。

- `1 l r x` : $ l $ 列目、$ l+1 $ 列目、$ \ldots $、$ r $ 列目の成分全てに $ x $ を足す。
- `2 i x` : $ i $ 行目の成分全てを $ x $ で置き換える。
- `3 i j` : $ (i,\ j) $ 成分を出力する。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M,\ Q\ \leq\ 2\ \times\ 10^5 $
- `1 l r x` の形式のクエリについて、$ 1\ \leq\ l\ \leq\ r\ \leq\ M $ かつ $ 1\ \leq\ x\ \leq\ 10^9 $
- `2 i x` の形式のクエリについて、$ 1\ \leq\ i\ \leq\ N $ かつ $ 1\ \leq\ x\ \leq\ 10^9 $
- `3 i j` の形式にクエリについて、$ 1\ \leq\ i\ \leq\ N $ かつ $ 1\ \leq\ j\ \leq\ M $
- `3 i j` の形式のクエリが一個以上与えられる
- 入力は全て整数

### Sample Explanation 1

行列は次のように変化します。 $ \begin{pmatrix}\ 0\ &amp;\ 0\ &amp;\ 0\ \\ 0\ &amp;\ 0\ &amp;\ 0\ \\ 0\ &amp;\ 0\ &amp;\ 0\ \\ \end{pmatrix}\ \rightarrow\ \begin{pmatrix}\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 1\ &amp;\ 1\ &amp;\ 0\ \\ \end{pmatrix}\ \rightarrow\ \begin{pmatrix}\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 2\ &amp;\ 2\ &amp;\ 2\ \\ \end{pmatrix}\ \rightarrow\ \begin{pmatrix}\ 1\ &amp;\ 4\ &amp;\ 3\ \\ 1\ &amp;\ 4\ &amp;\ 3\ \\ 2\ &amp;\ 5\ &amp;\ 5\ \\ \end{pmatrix} $

## 样例 #1

### 输入

```
3 3 9

1 1 2 1

3 2 2

2 3 2

3 3 3

3 3 1

1 2 3 3

3 3 2

3 2 3

3 1 2```

### 输出

```
1

2

2

5

3

4```

## 样例 #2

### 输入

```
1 1 10

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

3 1 1```

### 输出

```
9000000000```

## 样例 #3

### 输入

```
10 10 10

1 1 8 5

2 2 6

3 2 1

3 4 7

1 5 9 7

3 3 2

3 2 8

2 8 10

3 8 8

3 1 10```

### 输出

```
6

5

5

13

10

0```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个 $N$ 行 $M$ 列的矩阵，初始时所有元素均为 $0$。需要处理 $Q$ 个操作，操作分为以下三种形式：

1. `1 l r x`：将第 $l$ 列到第 $r$ 列的所有元素加上 $x$。
2. `2 i x`：将第 $i$ 行的所有元素替换为 $x$。
3. `3 i j`：输出矩阵中第 $i$ 行第 $j$ 列的元素值。

### 题解分析与结论
本题的核心难点在于如何处理操作2（行替换）对操作1（列加）的影响。各题解主要通过离线处理、树状数组（BIT）或主席树等数据结构来解决这一问题。

### 所选高星题解
#### 题解1：XYQ_102 (4星)
**关键亮点**：
- 使用树状数组（BIT）维护列的区间加操作。
- 离线处理查询，记录每个查询的上一次行替换操作，并通过BIT计算区间和。

**核心代码**：
```cpp
void add(int x, int c) {
    for(int i = x; i <= m; i += lowbit(i)) tr[i] += c;
}

LL sum(int x) {
    LL res = 0;
    for(int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}
```
**实现思想**：
通过BIT维护列的区间加操作，离线处理查询时，记录每个查询的上一次行替换操作，并通过BIT计算区间和，最终输出结果。

#### 题解2：Tsawke (4星)
**关键亮点**：
- 使用BIT维护列的区间加操作，并通过离线处理查询。
- 通过记录每个查询的上一次行替换操作，计算区间和。

**核心代码**：
```cpp
void Modify(int x, int v) {
    while(x <= M) tr[x] += v, x += lowbit(x);
}

ll Query(int x) {
    ll ret(0); while(x) ret += tr[x], x -= lowbit(x); return ret;
}
```
**实现思想**：
通过BIT维护列的区间加操作，离线处理查询时，记录每个查询的上一次行替换操作，并通过BIT计算区间和，最终输出结果。

#### 题解3：Pt_crN (4星)
**关键亮点**：
- 使用BIT维护列的区间加操作，并通过离线处理查询。
- 通过记录每个查询的上一次行替换操作，计算区间和。

**核心代码**：
```cpp
void update(int x, int y) {
    while(x <= q) {
        tr[x] += y;
        x += lowbit(x);
    }
}

ll query(int x) {
    if(!x) return 0;
    ll ret = 0;
    while(x) {
        ret += tr[x];
        x -= lowbit(x);
    }
    return ret;
}
```
**实现思想**：
通过BIT维护列的区间加操作，离线处理查询时，记录每个查询的上一次行替换操作，并通过BIT计算区间和，最终输出结果。

### 最优关键思路
1. **离线处理**：通过离线处理查询，记录每个查询的上一次行替换操作，避免实时处理的复杂性。
2. **树状数组（BIT）**：使用BIT维护列的区间加操作，高效计算区间和。
3. **区间和计算**：通过记录每个查询的上一次行替换操作，计算区间和，最终输出结果。

### 可拓展之处
类似的问题可以通过离线处理和树状数组（BIT）来解决，特别是涉及到区间修改和单点查询的问题。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得
在处理类似问题时，离线处理和树状数组（BIT）的结合可以大大提高效率，特别是在处理大规模数据时。通过记录每个查询的上一次行替换操作，可以避免实时处理的复杂性，简化问题。

---
处理用时：33.05秒
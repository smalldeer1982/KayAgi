# 题目信息

# [ABC285F] Substring of Sorted String

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc285/tasks/abc285_f

英小文字からなる長さ $ N $ の文字列 $ S $ と $ Q $ 個のクエリが与えられます。クエリを順に処理してください。

クエリは以下の $ 2 $ 種類です。

- `1 x c` ： $ S $ の $ x $ 文字目を文字 $ c $ に置き換える
- `2 l r` ： $ S $ を文字の昇順に並び替えて得られる文字列を $ T $ とする。$ S $ の $ l $ 文字目から $ r $ 文字目までからなる文字列が $ T $ の部分文字列であるとき `Yes`、部分文字列でないとき `No` を出力する
 
 部分文字列とは？ $ S $ の**部分文字列**とは、$ S $ の先頭から $ 0 $ 文字以上、末尾から $ 0 $ 文字以上削除して得られる文字列のことをいいます。 例えば、`ab` は `abc` の部分文字列ですが、`ac` は `abc` の部分文字列ではありません。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 10^5 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ 1 $ 種類目のクエリにおいて、$ 1\ \leq\ x\ \leq\ N $
- $ 1 $ 種類目のクエリにおいて、$ c $ は英小文字
- $ 2 $ 種類目のクエリにおいて、$ 1\ \leq\ l\ \leq\ r\ \leq\ N $
 
### Sample Explanation 1

\- $ 1 $ 番目のクエリにおいて、$ S $ を文字の昇順に並び替えて得られる文字列 $ T $ は `abccdf` です。 $ S $ の $ 1 $ 文字目から $ 3 $ 文字目までからなる文字列は `abc` であり $ T $ の部分文字列です。よって `Yes` を出力します。 - $ 2 $ 番目のクエリにおいて、$ S $ を文字の昇順に並び替えて得られる文字列 $ T $ は `abccdf` です。 $ S $ の $ 2 $ 文字目から $ 6 $ 文字目までからなる文字列は `bcdcf` であり $ T $ の部分文字列ではありません。よって `No` を出力します。 - $ 3 $ 番目のクエリにより、$ S $ の $ 5 $ 文字目が `e` に置き換えられ、$ S $ は `abcdef` となります。 - $ 4 $ 番目のクエリにおいて、$ S $ を文字の昇順に並び替えて得られる文字列 $ T $ は `abcdef` です。 $ S $ の $ 2 $ 文字目から $ 6 $ 文字目までからなる文字列は `bcdef` であり $ T $ の部分文字列です。よって `Yes` を出力します。

## 样例 #1

### 输入

```
6

abcdcf

4

2 1 3

2 2 6

1 5 e

2 2 6```

### 输出

```
Yes

No

Yes```

# AI分析结果

### 题目内容重写
给定一个由小写字母组成的长度为 $N$ 的字符串 $S$，以及 $Q$ 个查询。每个查询是以下两种类型之一：

1. `1 x c`：将 $S$ 的第 $x$ 个字符替换为字符 $c$。
2. `2 l r`：将 $S$ 按字母升序排列得到字符串 $T$，判断 $S$ 的第 $l$ 到第 $r$ 个字符组成的子串是否是 $T$ 的子串。如果是，输出 `Yes`，否则输出 `No`。

### 综合分析与结论
本题的核心在于如何高效处理字符串的单点修改和区间查询操作，特别是判断某个子串是否是排序后字符串的子串。大多数题解采用了线段树或树状数组来维护字符的出现次数和字符串的单调性。以下是各题解的思路和难点对比：

1. **线段树维护字符出现次数和单调性**：通过线段树维护每个字符的出现次数，并判断区间是否单调递增。难点在于如何高效合并区间信息和处理字符替换操作。
2. **树状数组维护字符出现次数和逆序对**：通过树状数组维护字符的出现次数和逆序对数量，判断区间是否单调递增且字符出现次数符合要求。难点在于如何处理字符替换对逆序对的影响。
3. **Set 维护字符位置和单调性**：通过 Set 维护字符的位置和单调性，判断区间是否单调递增且字符出现次数符合要求。难点在于如何高效处理字符替换对 Set 的影响。

### 所选高分题解

#### 题解1：TKXZ133 (4星)
**关键亮点**：
- 使用线段树维护字符出现次数和区间单调性。
- 通过合并区间信息判断子串是否是排序后字符串的子串。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
struct STn{int l,r,is;char lz,rz;int cnt[30];};
void merge(STn &res,STn a,STn b){
    res.lz=a.lz;
    res.rz=b.rz;
    res.is=(a.is&&b.is)&&(a.rz<=b.lz);
    for(int i=1;i<=26;i++)
        res.cnt[i]=a.cnt[i]+b.cnt[i];
}
```
**实现思想**：通过线段树维护每个区间的字符出现次数和单调性，合并区间时判断是否满足条件。

#### 题解2：FL_sleake (4星)
**关键亮点**：
- 使用 Set 维护字符位置和单调性。
- 通过 Set 判断区间是否单调递增且字符出现次数符合要求。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
set<int> x,id[30];
for(int i=2;i<s.size();i++) if(s[i]<s[i-1]) x.insert(i);
for(int i=1;i<s.size();i++) id[s[i]-'a'].insert(i);
```
**实现思想**：通过 Set 维护字符位置和单调性，判断区间是否单调递增且字符出现次数符合要求。

#### 题解3：incra (4星)
**关键亮点**：
- 使用树状数组维护字符出现次数和逆序对数量。
- 通过树状数组判断区间是否单调递增且字符出现次数符合要求。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int c[N];
int cnt[26][N];
void modify(int c[],int x,int d){
    for(int i=x;i<=n;i+=lowbit(i)) c[i]+=d;
}
int query(int c[],int x){
    int ans=0;
    for(int i=x;i;i-=lowbit(i)) ans+=c[i];
    return ans;
}
```
**实现思想**：通过树状数组维护字符出现次数和逆序对数量，判断区间是否单调递增且字符出现次数符合要求。

### 最优关键思路与技巧
1. **线段树/树状数组维护字符出现次数**：通过维护每个字符的出现次数，可以快速判断区间内的字符是否符合排序后字符串的要求。
2. **单调性判断**：通过维护区间的单调性，可以快速判断子串是否是排序后字符串的子串。
3. **高效处理字符替换**：通过高效处理字符替换操作，确保数据结构能够快速更新。

### 可拓展之处
1. **类似题目**：可以扩展到处理其他类型的字符串操作，如区间反转、区间排序等。
2. **数据结构优化**：可以进一步优化数据结构，如使用更高效的区间查询和更新方法。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

### 个人心得总结
1. **调试经历**：在处理字符替换操作时，需要注意更新数据结构中的所有相关信息，避免遗漏。
2. **踩坑教训**：在处理区间查询时，需要注意边界条件，避免越界访问。
3. **顿悟感想**：通过合理的数据结构设计，可以大大简化问题的复杂度，提高代码的可读性和效率。

---
处理用时：45.94秒
# 题目信息

# [ABC331F] Palindrome Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc331/tasks/abc331_f

英小文字からなる長さ $ N $ の文字列 $ S $ が与えられます。  
 以下で説明されるクエリを与えられる順に $ Q $ 個処理してください。  
 クエリは次の $ 2 $ 種類のいずれかです。

- `1 x c` : $ S $ の $ x $ 文字目を英小文字 $ c $ に変更する。
- `2 L R` : $ S $ の $ L $ 文字目から $ R $ 文字目までからなる部分文字列が回文であるならば `Yes` を、そうでないならば `No` を出力する。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^6 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
- $ 1\ \leq\ x\ \leq\ N $
- $ c $ は英小文字
- $ 1\ \leq\ L\ \leq\ R\ \leq\ N $
- $ N,\ Q,\ x,\ L,\ R $ は整数
 
### Sample Explanation 1

はじめ、$ S\ = $ `abcbacb` です。 $ 1 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 5 $ 文字目までからなる文字列は `abcba` で、これは回文です。よって `Yes` を出力します。 $ 2 $ 番目のクエリについて、$ S $ の $ 4 $ 文字目から $ 7 $ 文字目までからなる文字列は `bacb` で、これは回文ではありません。よって `No` を出力します。 $ 3 $ 番目のクエリについて、$ S $ の $ 2 $ 文字目から $ 2 $ 文字目までからなる文字列は `b` で、これは回文です。よって `Yes` を出力します。 $ 4 $ 番目のクエリについて、$ S $ の $ 5 $ 文字目を `c` に変更します。$ S $ は `abcbccb` になります。 $ 5 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 5 $ 文字目までからなる文字列は `abcbc` で、これは回文ではありません。よって `No` を出力します。 $ 6 $ 番目のクエリについて、$ S $ の $ 4 $ 文字目から $ 7 $ 文字目までからなる文字列は `bccb` で、これは回文です。よって `Yes` を出力します。 $ 7 $ 番目のクエリについて、$ S $ の $ 4 $ 文字目を `c` に変更します。$ S $ は `abccccb` になります。 $ 8 $ 番目のクエリについて、$ S $ の $ 3 $ 文字目から $ 6 $ 文字目までからなる文字列は `cccc` で、これは回文です。よって `Yes` を出力します。

## 样例 #1

### 输入

```
7 8

abcbacb

2 1 5

2 4 7

2 2 2

1 5 c

2 1 5

2 4 7

1 4 c

2 3 6```

### 输出

```
Yes

No

Yes

No

Yes

Yes```

# AI分析结果

### 题目内容重写
给定一个长度为 $N$ 的由小写字母组成的字符串 $S$，处理 $Q$ 个查询，查询分为两种类型：
1. `1 x c`：将 $S$ 的第 $x$ 个字符修改为小写字母 $c$。
2. `2 L R`：判断 $S$ 的第 $L$ 到第 $R$ 个字符组成的子串是否为回文串，如果是则输出 `Yes`，否则输出 `No`。

### 题解综合分析
本题的核心问题是如何高效地处理字符串的修改和查询操作，特别是判断子串是否为回文串。大多数题解采用了字符串哈希结合线段树的思路，通过维护正反两个方向的哈希值来判断回文串。以下是各题解的主要思路和优化点：

1. **字符串哈希与线段树结合**：大多数题解使用线段树维护字符串的正向和反向哈希值，通过比较这两个哈希值来判断子串是否为回文串。这种方法的优势在于可以高效地进行单点修改和区间查询，时间复杂度为 $O(\log N)$。
  
2. **哈希函数的优化**：部分题解使用了双哈希或自然溢出哈希来减少哈希冲突的概率，提高判断的准确性。

3. **代码实现技巧**：一些题解通过重载运算符或使用结构体来简化线段树的合并操作，提高了代码的可读性和可维护性。

### 评分较高的题解

#### 1. 作者：Register_int (5星)
**关键亮点**：
- 使用线段树维护正反哈希值，通过合并操作高效地处理区间查询。
- 代码结构清晰，使用了结构体和运算符重载，便于理解。

**核心代码**：
```cpp
struct node {
    int l, r; ull h1, h2;
    node operator + (const node &rhs) const {
        return { l, rhs.r, 
        h1 * p[rhs.r - rhs.l + 1] + rhs.h1, 
        h2 + rhs.h2 * p[r - l + 1] };
    }
};
```
**实现思想**：通过线段树维护正反哈希值，合并时根据区间长度调整哈希值，最终通过比较正反哈希值判断回文串。

#### 2. 作者：SSER_ZRQ (4星)
**关键亮点**：
- 提出了新的哈希定义方式，通过逆元计算哈希值，简化了区间修改操作。
- 使用树状数组优化了区间修改和查询的时间复杂度。

**核心代码**：
```cpp
void modify(int k, int x, int p) {
    if (t[p].l == t[p].r) return t[p].h1 = t[p].h2 = x, void();
    int mid = t[p].l + t[p].r >> 1;
    modify(k, x, p << 1 | k > mid), pushup(p);
}
```
**实现思想**：通过树状数组维护哈希值，利用逆元计算哈希值，简化了区间修改操作。

#### 3. 作者：SunsetLake (4星)
**关键亮点**：
- 详细解释了线段树合并时哈希值的计算方法，强调了哈希值的更新方式。
- 代码结构清晰，使用了模运算和快速幂优化哈希计算。

**核心代码**：
```cpp
void pushup(int p){
    tr[p].lnum=(tr[ls].lnum+(pw[tr[ls].r-tr[ls].l+1]*tr[rs].lnum)%mod)%mod;
    tr[p].rnum=(tr[rs].rnum+(pw[tr[rs].r-tr[rs].l+1]*tr[ls].rnum)%mod)%mod;
}
```
**实现思想**：通过线段树维护正反哈希值，合并时根据区间长度调整哈希值，最终通过比较正反哈希值判断回文串。

### 最优关键思路
- **字符串哈希结合线段树**：通过维护正反两个方向的哈希值，利用线段树高效处理区间查询和单点修改操作，时间复杂度为 $O(\log N)$。
- **双哈希或自然溢出哈希**：使用双哈希或自然溢出哈希减少哈希冲突，提高判断的准确性。

### 可拓展之处
- **其他字符串问题**：类似的思路可以应用于其他字符串问题，如最长回文子串、字符串匹配等。
- **动态区间查询**：线段树和哈希结合的方法可以扩展到其他需要动态区间查询的问题，如区间最值、区间和等。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3805 【模板】Manacher算法](https://www.luogu.com.cn/problem/P3805)
3. [P3808 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3808)

### 个人心得摘录
- **调试经历**：部分题解提到在调试过程中遇到线段树合并时哈希值计算错误的问题，通过详细检查区间长度和哈希值的更新方式解决了问题。
- **踩坑教训**：一些题解提到在实现双哈希时，忽略了逆元的计算，导致哈希值不准确，最终通过引入逆元解决了问题。

---
处理用时：44.51秒
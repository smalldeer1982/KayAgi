# 题目信息

# [ABC351F] Double Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_f

整数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ が与えられます。  
 次の式を計算してください。

$ \displaystyle\ \sum_{i=1}^N\ \sum_{j=i+1}^N\ \max(A_j\ -\ A_i,\ 0) $

なお、制約下において答えが $ 2^{63} $ 未満となることは保証されています。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 4\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^8 $
- 入力される値は全て整数
 
### Sample Explanation 1

$ (i,\ j)\ =\ (1,\ 2) $ のとき $ \max(A_j\ -\ A_i,\ 0)\ =\ \max(3,\ 0)\ =\ 3 $ です。 $ (i,\ j)\ =\ (1,\ 3) $ のとき $ \max(A_j\ -\ A_i,\ 0)\ =\ \max(1,\ 0)\ =\ 1 $ です。 $ (i,\ j)\ =\ (2,\ 3) $ のとき $ \max(A_j\ -\ A_i,\ 0)\ =\ \max(-2,\ 0)\ =\ 0 $ です。 これらを足し合わせた $ 3\ +\ 1\ +\ 0\ =\ 4 $ が答えとなります。

## 样例 #1

### 输入

```
3

2 5 3```

### 输出

```
4```

## 样例 #2

### 输入

```
10

5 9 3 0 4 8 7 5 4 0```

### 输出

```
58```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个整数序列 $A = (A_1, A_2, \dots, A_N)$，计算以下表达式的值：

$$
\sum_{i=1}^N \sum_{j=i+1}^N \max(A_j - A_i, 0)
$$

在给定的约束条件下，答案保证小于 $2^{63}$。

#### 说明/提示

##### 约束条件

- $2 \leq N \leq 4 \times 10^5$
- $0 \leq A_i \leq 10^8$
- 输入的所有值均为整数

##### 样例解释 1

对于 $(i, j) = (1, 2)$，$\max(A_j - A_i, 0) = \max(3, 0) = 3$。  
对于 $(i, j) = (1, 3)$，$\max(A_j - A_i, 0) = \max(1, 0) = 1$。  
对于 $(i, j) = (2, 3)$，$\max(A_j - A_i, 0) = \max(-2, 0) = 0$。  
将这些值相加，得到 $3 + 1 + 0 = 4$，即为答案。

##### 样例 #1

###### 输入

```
3
2 5 3
```

###### 输出

```
4
```

##### 样例 #2

###### 输入

```
10
5 9 3 0 4 8 7 5 4 0
```

###### 输出

```
58
```

### 题解分析与结论

#### 综合分析与结论

本题的核心是计算所有满足 $j > i$ 且 $A_j > A_i$ 的 $(i, j)$ 对的 $A_j - A_i$ 之和。由于 $N$ 的范围较大（$4 \times 10^5$），直接使用双重循环会导致时间复杂度过高，因此需要优化。

大多数题解采用了**树状数组**或**线段树**来维护前缀和或后缀和，通过排序和离散化处理，将时间复杂度降低到 $O(N \log N)$。部分题解还使用了**平衡树**或**动态开点线段树**来处理较大的值域。

#### 评分较高的题解

1. **作者：xxgirlxx (5星)**
   - **关键亮点**：通过巧妙的数学变形，将原问题转化为计算排序后的前缀和和后缀和，避免了复杂的数据结构操作，代码简洁且高效。
   - **核心代码**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     long long n,ans,a[400010];
     int main(){
         cin>>n;
         for(int i=1;i<=n;i++)cin>>a[i],ans+=a[i]*(i-1);
         sort(a+1,a+n+1);
         for(int i=1;i<=n;i++)ans-=a[i]*(n-i);
         cout<<ans;
         return 0;
     }
     ```
   - **核心思想**：先计算所有 $A_j$ 的贡献，然后通过排序和前缀和计算 $\min(A_i, A_j)$ 的贡献。

2. **作者：Ace_FutureDream (4星)**
   - **关键亮点**：通过数学变形，将问题转化为计算排序后的前缀和和后缀和，避免了复杂的数据结构操作，代码简洁且高效。
   - **核心代码**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     long long a[400010],s,ans,n;
     signed main(){
         cin>>n;
         for(int i=1;i<=n;i++)cin>>a[i],ans+=(i-1)*a[i]-s,s+=a[i];
         sort(a+1,a+n+1);
         for(int i=n;i>=2;i--)s-=a[i],ans+=(i-1)*a[i]-s;
         cout<<ans/2<<'\n';
         return 0;
     }
     ```
   - **核心思想**：通过数学变形，将问题转化为计算排序后的前缀和和后缀和，避免了复杂的数据结构操作。

3. **作者：__ryp__ (4星)**
   - **关键亮点**：通过从后往前扫描，使用树状数组维护后缀和，避免了复杂的排序操作，代码简洁且高效。
   - **核心代码**：
     ```cpp
     #include <bits/stdc++.h>
     using namespace std;
     #define int long long
     const int MAX = 4e5 + 5;
     int n, a[MAX], tree[MAX], ans;
     int lowbit(int x) { return x & -x; }
     void update(int x, int v) {
         for (; x <= n; x += lowbit(x)) tree[x] += v;
     }
     int query(int x) {
         int res = 0;
         for (; x; x -= lowbit(x)) res += tree[x];
         return res;
     }
     signed main() {
         cin >> n;
         for (int i = 1; i <= n; i++) cin >> a[i];
         for (int i = n; i >= 1; i--) {
             ans += query(n) - query(a[i]);
             update(a[i], 1);
         }
         cout << ans;
         return 0;
     }
     ```
   - **核心思想**：从后往前扫描，使用树状数组维护后缀和，避免了复杂的排序操作。

#### 最优关键思路与技巧

1. **数学变形**：通过数学变形，将原问题转化为计算排序后的前缀和和后缀和，避免了复杂的数据结构操作。
2. **树状数组/线段树**：使用树状数组或线段树维护前缀和或后缀和，通过排序和离散化处理，将时间复杂度降低到 $O(N \log N)$。
3. **从后往前扫描**：从后往前扫描，使用树状数组维护后缀和，避免了复杂的排序操作。

#### 可拓展之处

- **逆序对问题**：本题与逆序对问题类似，可以使用类似的思路和数据结构来解决。
- **动态开点线段树**：对于值域较大的问题，可以使用动态开点线段树来处理。

#### 推荐题目

1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

#### 个人心得总结

- **调试经历**：在处理较大数据时，注意数据类型的溢出问题，使用 `long long` 或 `__int128` 来避免溢出。
- **踩坑教训**：在排序和离散化处理时，注意去重和边界条件的处理。
- **顿悟感想**：通过数学变形，可以将复杂的问题转化为简单的计算问题，避免复杂的数据结构操作。

---
处理用时：53.82秒
# 题目信息

# [ABC354F] Useless for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_f

長さ $ N $ の整数列 $ A $ が与えられます。

$ t\ =\ 1,\ 2,\ \dots\ ,N $ について、 $ A_t $ が $ A $ の最長増加部分列に含まれることがあるか判定してください。

$ A_t $ が $ A $ の最長増加部分列に含まれることがあるとは、以下のことをいいます。

- 最長増加部分列の長さを $ L $ とする。各要素が $ 1 $ 以上 $ N $ 以下の単調増加な整数列 $ i\ =\ (i_1,\ i_2,\ \dots\ ,i_L)\ (i_1\ であって以下をすべて満たすものが存在する。 $
  
  
  - $ A_{i_1} $
  - ある $ k\ (1\ \leq\ k\ \leq\ L) $ が存在して $ i_k\ =\ t $ である

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

最長増加部分列とは？列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下

### Sample Explanation 1

最長増加部分列の $ 1 $ つは $ (2,\ 4,\ 5) $ で、長さは $ 3 $ です。$ (1,\ 4,\ 5) $ も最長増加部分列の $ 1 $ つです。しかし、 $ A_5 $ を含む最長増加部分列はありません。 よって、 $ 1,\ 2,\ 3,\ 4 $ を出力します。

## 样例 #1

### 输入

```
1
5
2 1 4 5 3```

### 输出

```
4
1 2 3 4```

## 样例 #2

### 输入

```
2
6
2 5 3 4 3 4
5
10000 1000 100 1 10```

### 输出

```
5
1 3 4 5 6
2
4 5```

# AI分析结果

### 题目内容重写
给定一个长度为 $N$ 的整数序列 $A$，对于每个 $t = 1, 2, \dots, N$，判断 $A_t$ 是否可能出现在 $A$ 的最长递增子序列（LIS）中。

$A_t$ 可能出现在 LIS 中的定义是：存在一个 LIS，其长度为 $L$，且存在一个位置 $k$，使得 $A_{i_k} = A_t$。

### 综合分析与结论
本题的核心问题是如何高效地判断每个元素是否可能出现在 LIS 中。大多数题解采用了以下思路：

1. **正向和反向LIS计算**：首先计算以每个元素结尾的正向LIS长度 $f_i$，然后计算以每个元素开头的反向LIS长度 $g_i$。如果 $f_i + g_i - 1$ 等于整个序列的LIS长度，则该元素可能出现在LIS中。

2. **优化方法**：使用树状数组或二分查找来优化LIS的计算，确保时间复杂度为 $O(n \log n)$。

3. **离散化处理**：由于 $A_i$ 的范围较大，通常需要对序列进行离散化处理，以便在树状数组中使用。

### 所选高星题解

#### 题解1：作者：fuxiheng (赞：7)
- **星级**：★★★★★
- **关键亮点**：代码简洁，思路清晰，使用树状数组优化LIS计算，正向和反向LIS的计算逻辑明确。
- **核心代码**：
```cpp
for(int i = 1;i <= n;i++){
    f[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
    p[f[i]] = a[i];
    Max = max(Max, f[i]);
}
for(int i = n;i;i--){
    g[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
    p[g[i]] = a[i];
}
```
- **实现思想**：通过二分查找和树状数组计算正向和反向LIS，最后判断 $f_i + g_i - 1$ 是否等于整个序列的LIS长度。

#### 题解2：作者：Keroshi (赞：3)
- **星级**：★★★★
- **关键亮点**：详细解释了树状数组的使用，代码结构清晰，适合理解树状数组优化LIS的读者。
- **核心代码**：
```cpp
FOR(i, 1, n) {
    f[i] = t1.query(a[i] - 1);
    t1.modify(a[i], f[i] + 1);
}
ROF(i, n, 1) {
    g[i] = t2.query(n - a[i] + 1 - 1);
    t2.modify(n - a[i] + 1, g[i] + 1);
}
```
- **实现思想**：使用树状数组计算正向和反向LIS，并通过 $f_i + g_i + 1$ 判断元素是否可能出现在LIS中。

#### 题解3：作者：rhn7 (赞：1)
- **星级**：★★★★
- **关键亮点**：代码实现简洁，使用二分查找优化LIS计算，适合熟悉二分查找的读者。
- **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int l=0,r=ans,s;
    while(l<=r){
        int mid=(l+r)/2;
        if(dp[mid]<a[i]){
            s=mid;
            l=mid+1;
        }else{
            r=mid-1;
        }
    }
    dp[s+1]=a[i];
    f[i]=s+1;
}
```
- **实现思想**：通过二分查找计算正向LIS，反向LIS同理，最后判断 $f_i + g_i - 1$ 是否等于整个序列的LIS长度。

### 最优关键思路与技巧
1. **正向和反向LIS结合**：通过计算正向和反向LIS长度，可以高效判断每个元素是否可能出现在LIS中。
2. **树状数组优化**：树状数组在计算LIS时能够将时间复杂度优化到 $O(n \log n)$，适合处理大规模数据。
3. **离散化处理**：对于大范围的数据，离散化处理是必要的，能够有效减少树状数组的空间复杂度。

### 可拓展之处
1. **类似问题**：可以扩展到求解最长不下降子序列（LNDS）或最长递减子序列（LDS）的问题。
2. **其他优化方法**：除了树状数组，还可以使用线段树或其他数据结构来优化LIS的计算。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)
3. [P2782 最长公共上升子序列](https://www.luogu.com.cn/problem/P2782)

---
处理用时：38.89秒
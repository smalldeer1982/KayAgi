# 题目信息

# [ABC369F] Gather Coins

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc369/tasks/abc369_f

縦 $ H $ 行、横 $ W $ 列のグリッドがあります。 このグリッドの上から $ i $ 行目、左から $ j $ 列目にあるマスのことを $ (i,j) $ と表記します。

このグリッド上には $ N $ 枚のコインが落ちており、$ i $ 個目のコインはマス $ (R_i,C_i) $ を通ることで拾うことができます。

あなたの目標は、マス $ (1,1) $ から始めて下か右に $ 1 $ マス移動することを繰り返し、できるだけ多くのコインを拾いながらマス $ (H,W) $ まで行くことです。

あなたが拾うことのできるコインの枚数の最大値、およびそれを達成するための移動経路を $ 1 $ つ求めてください。

## 说明/提示

### 制約

- $ 2\leq\ H,W\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ N\ \leq\ \min(HW-2,\ 2\times\ 10^5) $
- $ 1\leq\ R_i\ \leq\ H $
- $ 1\leq\ C_i\ \leq\ W $
- $ (R_i,C_i)\neq\ (1,1) $
- $ (R_i,C_i)\neq\ (H,W) $
- $ (R_i,C_i) $ は互いに相異なる
- 入力は全て整数
 
### Sample Explanation 1

!\[\](https://img.atcoder.jp/abc369/8c45374379376c75b6cfd44cb8efeaf8.png) 上図のように $ (1,1)\rightarrow\ (2,1)\rightarrow\ (2,2)\rightarrow\ (2,3)\rightarrow\ (3,3)\rightarrow\ (3,4) $ と移動することで、$ (2,1),(2,3),(3,3) $ にある $ 3 $ 枚のコインを拾うことができます。

### Sample Explanation 2

`RD` という移動経路も正解となります。

## 样例 #1

### 输入

```
3 4 4

3 3

2 1

2 3

1 4```

### 输出

```
3

DRRDR```

## 样例 #2

### 输入

```
2 2 2

2 1

1 2```

### 输出

```
1

DR```

## 样例 #3

### 输入

```
10 15 8

2 7

2 9

7 9

10 3

7 11

8 12

9 6

8 1```

### 输出

```
5

DRRRRRRRRDDDDDRRDRDDRRR```

# AI分析结果

### 题目内容重写（中文）

**题目描述**

有一个 $H$ 行 $W$ 列的网格。用 $(i,j)$ 表示从上往下数第 $i$ 行，从左往右数第 $j$ 列的单元格。

在这个网格中有 $N$ 枚硬币，通过 $(R_i,C_i)$ 单元格可以拾取第 $i$ 枚硬币。

你的目标是从 $(1,1)$ 单元格开始，反复向下或向右移动一个单元格，到达 $(H,W)$ 单元格，同时尽可能多地拾取硬币。

请找出您能拾取的最大硬币数以及能达到最大值的路径之一。

**说明/提示**

**约束条件**

- $2 \leq H, W \leq 2 \times 10^5$
- $1 \leq N \leq \min(HW-2, 2 \times 10^5)$
- $1 \leq R_i \leq H$
- $1 \leq C_i \leq W$
- $(R_i,C_i) \neq (1,1)$
- $(R_i,C_i) \neq (H,W)$
- $(R_i,C_i)$ 互不相同
- 输入均为整数

**样例解释**

样例1中，可以通过路径 $(1,1) \rightarrow (2,1) \rightarrow (2,2) \rightarrow (2,3) \rightarrow (3,3) \rightarrow (3,4)$ 拾取3枚硬币。

样例2中，路径 `RD` 也是正确的。

### 题解分析与结论

该题目要求从网格的左上角 $(1,1)$ 出发，只能向下或向右移动，最终到达右下角 $(H,W)$，并在此过程中尽可能多地拾取硬币。由于网格的大小可能非常大（$H, W \leq 2 \times 10^5$），直接使用动态规划会超出时间限制。因此，题解大多采用了二维偏序优化或树状数组/线段树来优化动态规划的转移过程。

#### 关键思路与技巧

1. **二维偏序优化**：将硬币按行排序，然后对列进行最长不下降子序列（LIS）的计算。这样可以将二维问题转化为一维问题，从而使用树状数组或线段树进行优化。
2. **树状数组/线段树**：用于维护前缀最大值，优化动态规划的转移过程。通过树状数组或线段树，可以在 $O(\log N)$ 的时间内找到满足条件的最优转移点。
3. **路径记录**：在动态规划过程中，记录每个硬币的前驱节点，最后通过前驱节点逆推出路径。

#### 推荐题解

1. **作者：cjh20090318 (赞：14)**  
   **星级：5星**  
   **关键亮点**：使用树状数组优化动态规划，代码简洁且高效。通过记录前驱节点，能够轻松输出路径。  
   **代码核心思想**：
   ```cpp
   fenwick_tree<PII> T(w);
   for(int i=1;i<=n;i++){
       PII r=T.sum(a[i].y);
       p[i]=r.second;
       T.add(a[i].y,PII(r.first+1,i));
   }
   ```
   **完整代码**：
   ```cpp
   // 树状数组优化DP
   fenwick_tree<PII> T(w);
   for(int i=1;i<=n;i++){
       PII r=T.sum(a[i].y);
       p[i]=r.second;
       T.add(a[i].y,PII(r.first+1,i));
   }
   ```

2. **作者：Dtw_ (赞：4)**  
   **星级：4星**  
   **关键亮点**：使用树状数组维护前缀最大值，转移时记录前驱节点，最后逆推出路径。  
   **代码核心思想**：
   ```cpp
   void add(int x, int p, int k){
       for(; x<=N-10; x+=lb(x)){
           if(k > f[x].se) f[x] = {p, k};
       }
   }
   ```
   **完整代码**：
   ```cpp
   // 树状数组维护前缀最大值
   void add(int x, int p, int k){
       for(; x<=N-10; x+=lb(x)){
           if(k > f[x].se) f[x] = {p, k};
       }
   }
   ```

3. **作者：__Allen_123__ (赞：43)**  
   **星级：4星**  
   **关键亮点**：将问题转化为二维偏序问题，使用树状数组优化动态规划，思路清晰且代码可读性强。  
   **代码核心思想**：
   ```cpp
   dp_i = max(dp_j + 1) where C_j <= C_i
   ```
   **完整代码**：
   ```cpp
   // 树状数组优化DP
   for(int i=1;i<=n;i++){
       dp[i] = query(a[i].y) + 1;
       add(a[i].y, dp[i]);
   }
   ```

### 最优关键思路

1. **二维偏序优化**：将问题转化为二维偏序问题，通过排序和树状数组/线段树优化动态规划的转移过程。
2. **树状数组/线段树**：用于维护前缀最大值，优化动态规划的转移过程，时间复杂度为 $O(N \log N)$。
3. **路径记录**：在动态规划过程中记录前驱节点，最后通过前驱节点逆推出路径。

### 可拓展之处

该题的思路可以拓展到其他二维偏序问题，如最长上升子序列、二维平面上的路径优化等。类似的题目可以通过排序和树状数组/线段树进行优化。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)  
   考察最长不下降子序列及其优化。
   
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
   考察树状数组的应用，适合练习树状数组的基本操作。
   
3. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)  
   树状数组的模板题，适合练习树状数组的基本操作。

---
处理用时：48.35秒
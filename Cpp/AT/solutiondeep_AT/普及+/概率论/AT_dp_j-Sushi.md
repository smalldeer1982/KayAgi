# 题目信息

# Sushi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_j

$ N $ 枚の皿があります。 皿には $ 1,\ 2,\ \ldots,\ N $ と番号が振られています。 最初、各 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について、皿 $ i $ には $ a_i $ ($ 1\ \leq\ a_i\ \leq\ 3) $ 個の寿司が置かれています。

すべての寿司が無くなるまで、太郎君は次の操作を繰り返し行います。

- $ 1,\ 2,\ \ldots,\ N $ の目が等確率で出るサイコロを振り、出目を $ i $ とする。 皿 $ i $ に寿司がある場合、皿 $ i $ の寿司を $ 1 $ 個食べる。 皿 $ i $ に寿司が無い場合、何も行わない。

すべての寿司が無くなるまでの操作回数の期待値を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ a_i\ \leq\ 3 $

### Sample Explanation 1

$ 1 $ 個目の寿司を食べるまでの操作回数の期待値は $ 1 $ です。 その後、$ 2 $ 個目の寿司を食べるまでの操作回数の期待値は $ 1.5 $ です。 その後、$ 3 $ 個目の寿司を食べるまでの操作回数の期待値は $ 3 $ です。 よって、全体の操作回数の期待値は $ 1\ +\ 1.5\ +\ 3\ =\ 5.5 $ です。

### Sample Explanation 2

例えば、`3.00`, `3.000000003`, `2.999999997` などを出力しても正解となります。

## 样例 #1

### 输入

```
3

1 1 1```

### 输出

```
5.5```

## 样例 #2

### 输入

```
1

3```

### 输出

```
3```

## 样例 #3

### 输入

```
2

1 2```

### 输出

```
4.5```

## 样例 #4

### 输入

```
10

1 3 2 3 3 2 3 2 1 3```

### 输出

```
54.48064457488221```

# AI分析结果

### 题目内容中文重写
# 寿司

## 题目描述
[题目链接]: https://atcoder.jp/contests/dp/tasks/dp_j

有 $N$ 个盘子，盘子编号为 $1, 2, \ldots, N$。最初，对于每个 $i$（$1 \leq i \leq N$），盘子 $i$ 上放有 $a_i$（$1 \leq a_i \leq 3$）个寿司。

在所有寿司都被吃完之前，太郎君会重复进行以下操作：
- 掷一个等概率出现 $1, 2, \ldots, N$ 点数的骰子，设掷出的点数为 $i$。若盘子 $i$ 上有寿司，则吃掉盘子 $i$ 上的 1 个寿司；若盘子 $i$ 上没有寿司，则不进行任何操作。

请计算所有寿司都被吃完所需操作次数的期望值。

## 说明/提示
### 限制条件
- 输入的所有值均为整数。
- $1 \leq N \leq 300$
- $1 \leq a_i \leq 3$

### 示例解释 1
吃掉第 1 个寿司所需操作次数的期望值为 1。之后，吃掉第 2 个寿司所需操作次数的期望值为 1.5。再之后，吃掉第 3 个寿司所需操作次数的期望值为 3。因此，总的操作次数期望值为 $1 + 1.5 + 3 = 5.5$。

### 示例解释 2
例如，输出 `3.00`、`3.000000003`、`2.999999997` 等也被视为正确答案。

## 样例 #1
### 输入
```
3
1 1 1
```
### 输出
```
5.5
```

## 样例 #2
### 输入
```
1
3
```
### 输出
```
3
```

## 样例 #3
### 输入
```
2
1 2
```
### 输出
```
4.5
```

## 样例 #4
### 输入
```
10
1 3 2 3 3 2 3 2 1 3
```
### 输出
```
54.48064457488221
```

### 综合分析与结论
这些题解均围绕期望动态规划（期望 DP）来解决寿司问题。
- **思路**：都利用状态压缩思想，考虑到盘子位置对结果无影响，仅关注不同寿司数量的盘子个数，用三维数组表示状态。
- **算法要点**：核心是推导状态转移方程，依据选择不同寿司数量盘子的概率列出方程，再移项化简。
- **解决难点**：原状态方程含循环依赖，通过移项消除；状态数多，利用盘子总数不变减少一维。

### 所选题解
- **作者：Haphyxlos (赞：63)，4星**
    - **关键亮点**：思路清晰，详细阐述暴力 dp、合并状态、消除无用状态的优化过程，代码可读性高。
- **作者：FelFa_1414666 (赞：19)，4星**
    - **关键亮点**：对期望 dp 概念解释清晰，转移方程推导详细，提供记忆化搜索实现。
- **作者：紊莫 (赞：0)，4星**
    - **关键亮点**：重点解释状态转移方程各项含义，有助于理解期望 dp 本质。

### 重点代码
#### Haphyxlos 的代码
```cpp
double f[305][305][305];
int a[5],n; 
int main(int argc,char const *argv[]){
    scanf("%d",&n);
    for(int i=1,x;i<=n;++i){
        scanf("%d",&x);
        a[x]++;
    }	
    for(int k=0;k<=n;++k){
        for(int j=0;j<=n;++j){
            for(int i=0;i<=n;++i){
                if(i||j||k){
                    if(i)f[i][j][k]+=f[i-1][j][k]*i/(i+j+k);
                    if(j)f[i][j][k]+=f[i+1][j-1][k]*j/(i+j+k);
                    if(k)f[i][j][k]+=f[i][j+1][k-1]*k/(i+j+k);
                    f[i][j][k]+=(double)n/(i+j+k);
                }
            }
        }
    }
    printf("%.15lf\n",f[a[1]][a[2]][a[3]]);
    return 0;
}
```
**核心思想**：先统计不同寿司数量的盘子个数，然后通过三重循环遍历所有状态，根据转移方程更新状态值，最后输出初始状态的期望步数。

#### FelFa_1414666 的代码
```cpp
int n,cnt[5];//计数
double mem[305][305][305];//dp 数组
double dfs(int i,int j,int k)//记忆化搜索
{
    if (i==0&&j==0&&k==0)
        return 0.0;
    if (mem[i][j][k]!=0.0)
        return mem[i][j][k];
    double res=(n*1.0)/((i+j+k)*1.0);
    if (i>0)res+=(dfs(i-1,j,k))*(i*1.0/((i+j+k)*1.0));
    if (j>0)res+=(dfs(i+1,j-1,k))*(j*1.0/((i+j+k)*1.0));
    if (k>0)res+=(dfs(i,j+1,k-1))*(k*1.0/((i+j+k)*1.0));
    return mem[i][j][k]=res;
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int a;
        cin>>a;
        cnt[a]++;
    }
    double ans=dfs(cnt[1],cnt[2],cnt[3]);
    printf("%.10f\n",ans);
    return 0;
}
```
**核心思想**：使用记忆化搜索实现期望 dp，先统计盘子个数，然后递归计算状态值，利用数组记录已计算的状态避免重复计算。

#### 紊莫的代码
```cpp
const int N=305,M=(N<<1),inf=0x3f3f3f3f;
double f[N][N][N];
double dp(int i,int j,int k){
    if(i==0&&j==0&&k==0) return 0;
    if(f[i][j][k]) return f[i][j][k];
    double p=n*1.0/(i+j+k);
    if(i) p+=i*1.0/(i+j+k)*dp(i-1,j,k);
    if(j) p+=j*1.0/(i+j+k)*dp(i+1,j-1,k);
    if(k) p+=k*1.0/(i+j+k)*dp(i,j+1,k-1);
    return f[i][j][k]=p;
}
int main(){
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int n,x,c[4]={0};cin>>n;
    for(int i = 1; i <= n; i++){
        cin>>x;
        c[x]++;
    }
    cout<<fixed<<setprecision(10)<<dp(c[1],c[2],c[3]);
    return 0;
}
```
**核心思想**：同样采用记忆化搜索，先统计盘子个数，递归计算状态值，根据转移方程更新状态，最后输出结果。

### 最优关键思路或技巧
- **状态压缩**：利用盘子位置不影响结果，仅记录不同寿司数量的盘子个数，将高维状态压缩为三维。
- **方程移项化简**：处理含循环依赖的状态转移方程，通过移项消除依赖。
- **记忆化搜索**：避免重复计算，提高效率。

### 可拓展之处
同类型题多为期望 dp 问题，如涉及随机事件、状态转移的问题。类似算法套路是先确定状态表示，依据概率推导转移方程，再处理方程中的循环依赖。

### 推荐题目
- [P1850 换教室](https://www.luogu.com.cn/problem/P1850)
- [P4316 绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)
- [P3232 [HNOI2013]游走](https://www.luogu.com.cn/problem/P3232)

### 个人心得摘录与总结
- **紊莫**：一开始没理解状态转移方程，通过详细分析各项含义，理解到方程中加一表示当前操作步数，以及不同项对应不同选择的概率和状态转移。总结是对于复杂的状态转移方程，需深入分析各项含义来理解本质。 

---
处理用时：52.44秒
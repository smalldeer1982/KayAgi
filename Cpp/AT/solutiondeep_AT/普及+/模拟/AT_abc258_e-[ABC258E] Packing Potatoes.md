# 题目信息

# [ABC258E] Packing Potatoes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc258/tasks/abc258_e

ベルトコンベアに載って $ 10^{100} $ 個のじゃがいもが $ 1 $ 個ずつ流れてきます。流れてくるじゃがいもの重さは長さ $ N $ の数列 $ W\ =\ (W_0,\ \dots,\ W_{N-1}) $ で表され、$ i\ \,\ (1\ \leq\ i\ \leq\ 10^{100}) $ 番目に流れてくるじゃがいもの重さは $ W_{(i-1)\ \bmod\ N} $ です。ここで、$ (i-1)\ \bmod\ N $ は $ i\ -\ 1 $ を $ N $ で割った余りを表します。

高橋君は、まず空の箱を用意し、次のルールに従ってじゃがいもを順番に箱に詰めていきます。

- じゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和が $ X $ 以上になったら、その箱には蓋をし、新たに空の箱を用意する。

$ Q $ 個のクエリが与えられます。$ i\ \,\ (1\ \leq\ i\ \leq\ Q) $ 番目のクエリでは、正整数 $ K_i $ が与えられるので、$ K_i $ 番目に蓋をされた箱に入っているじゃがいもの個数を求めてください。問題の制約下で、蓋をされた箱が $ K_i $ 個以上存在することが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ X\ \leq\ 10^9 $
- $ 1\ \leq\ W_i\ \leq\ 10^9\ \,\ (0\ \leq\ i\ \leq\ N\ -\ 1) $
- $ 1\ \leq\ K_i\ \leq\ 10^{12}\ \,\ (1\ \leq\ i\ \leq\ Q) $
- 入力は全て整数

### Sample Explanation 1

$ 2 $ つの箱に蓋をするまでの高橋くんの行動は以下の通りです。 - 空の箱を用意する。 - $ 1 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 3 $ である。 - $ 2 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 3\ +\ 4\ =\ 7 $ であり、$ X\ =\ 5 $ 以上になったのでこの箱には蓋をする。 - 新たに空の箱を用意する。 - $ 3 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 1 $ である。 - $ 4 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 1\ +\ 3\ =\ 4 $ である。 - $ 5 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 1\ +\ 3\ +\ 4\ =\ 8 $ であり、$ X\ =\ 5 $ 以上になったのでこの箱には蓋をする。 $ 1 $ 番目に蓋をされた箱には $ 2 $ つのじゃがいもが入っており、$ 2 $ 番目に蓋をされた箱には $ 3 $ つのじゃがいもが入っています。

## 样例 #1

### 输入

```
3 2 5
3 4 1
1
2```

### 输出

```
2
3```

## 样例 #2

### 输入

```
10 5 20
5 8 5 9 8 7 4 4 8 2
1
1000
1000000
1000000000
1000000000000```

### 输出

```
4
5
5
5
5```

# AI分析结果

### 题目翻译
有一个传送带上依次传送着 $10^{100}$ 个土豆。传送来的土豆的重量由长度为 $N$ 的数列 $W = (W_0, \dots, W_{N - 1})$ 表示，第 $i\ (1 \leq i \leq 10^{100})$ 个传送来的土豆的重量是 $W_{(i - 1) \bmod N}$。这里，$(i - 1) \bmod N$ 表示 $i - 1$ 除以 $N$ 的余数。

高桥君首先准备一个空箱子，然后按照以下规则依次将土豆装进箱子里：
- 将土豆放入箱子。当箱子里土豆的总重量达到 $X$ 及以上时，给这个箱子盖上盖子，并准备一个新的空箱子。

给定 $Q$ 个查询。第 $i\ (1 \leq i \leq Q)$ 个查询会给出一个正整数 $K_i$，请你求出第 $K_i$ 个盖上盖子的箱子里装的土豆的数量。在问题的约束条件下，可以证明存在 $K_i$ 个及以上盖上盖子的箱子。

### 综合分析与结论
#### 思路对比
这些题解的核心思路都是先找出循环节，再根据循环节来回答查询。具体来说，各题解都利用了从每个土豆位置开始装土豆，其下一个开始装的位置是固定的这一特性，从而确定循环节。不同之处在于找循环节和处理查询的具体实现方式。
#### 算法要点
- **前缀和与二分查找**：所有题解都使用了前缀和来快速计算区间内土豆的总重量，并通过二分查找确定每个箱子装的土豆数量和下一个箱子的起始位置。
- **循环节查找**：通过模拟装土豆的过程，记录每个起始位置的访问情况，找到循环节的起始位置和长度。
#### 解决难点
- **处理 $X$ 较大的情况**：当 $X$ 大于所有土豆的总重量时，需要对 $X$ 取模，并计算完整循环的次数。
- **循环节的确定**：要准确找到循环节的起始位置和长度，避免错误计算。

### 题解选择
- **xqh07（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过前缀和和二分查找预处理每个位置的信息，然后利用抽屉原理找到循环节，最后 $O(1)$ 回答查询。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; i++)
{
    int y = s[n] - s[i - 1], z = x;
    if(y >= x)
    {
        int pos = lower_bound(s + 1, s + n + 1, s[i - 1] + x) - s;
        nxt[i] = pos % n + 1;
        ans[i] = pos - i + 1;
    }
    else
    {
        ans[i] += n - i + 1;
        z -= y;
        ans[i] += n * (z / s[n]);
        z %= s[n];
        int pos = lower_bound(s + 1, s + n + 1, z) - s;
        ans[i] += pos;
        nxt[i] = pos % n + 1;
    }
}
int i = 1;
vis[1] = rve[1] = cnt = 1;
while(1)
{
    i = nxt[i];
    ++cnt;
    if(vis[i])
    {
        st = vis[i], cyc = cnt - vis[i];
        break;
    }
    vis[i] = cnt, rve[cnt] = i;
}
```
- **FXT1110011010OI（4星）**
    - **关键亮点**：思路直观，通过模拟 $n$ 次找出循环节，每次用二分查找终点位置，代码实现较为清晰。
    - **核心代码**：
```cpp
for (LL i = 0; i < n; i ++ )
{
    xh[i] = x / sum * n; // x > s
    LL t; // 终点位置
    if (x % sum) t = lower_bound(s + now, s + n * 2, (now == 0? x % sum : s[now - 1] + x % sum)) - s;
    else t = now - 1;
    xh[i] += t - now + 1;
    now = (t + 1) % n; // 更新起点
}
tmp = now; // 此时的now必与之前的某个起点相同
while (1)
{
    res[cnt] = x / sum * n;
    LL t;
    if (x % sum) t = lower_bound(s + now, s + n * 2, (now == 0? x % sum : s[now - 1] + x % sum)) - s;
    else t = now - 1;
    res[cnt ++ ] += t - now + 1;
    now = (t + 1) % n;
    if (tmp == now) break;
}
```
- **xzy090626（4星）**
    - **关键亮点**：先证明循环节长度为 $O(n)$，然后断环为链，通过前缀和和二分查找快速求循环节，代码简洁易懂。
    - **核心代码**：
```cpp
for(int i=1;!s[p];++i,++len){//找循环节
    // p 是每个箱子中第一个土豆
    s[p] = i;//s[p] 代表以 p 为第一个土豆的箱子的编号
    int d = lower_bound(w,w+2*n+1,w[p-1]+x%w[n])-w; //找到右端点的土豆位置
    a[i] = d - p + 1 + x/w[n]*n;//每个箱子装的数量
    p = d % n + 1;
}
int l = len - s[p], h = s[p];
// l 是循环节的长度
// h 是进入循环前面的箱子数量，它们只会出现一次
```

### 最优关键思路或技巧
- **前缀和与二分查找**：通过前缀和预处理土豆的重量，利用二分查找快速确定每个箱子装的土豆数量和下一个箱子的起始位置，将时间复杂度从暴力模拟的 $O(Q \times 10^{100})$ 降低到 $O(n \log n + Q)$。
- **循环节的利用**：根据抽屉原理，最多模拟 $n + 1$ 次就能找到循环节，通过记录循环节的起始位置和长度，可以 $O(1)$ 回答查询。

### 拓展思路
同类型题或类似算法套路：
- 循环节问题：如约瑟夫环问题、循环小数问题等，都可以通过找出循环节来优化时间复杂度。
- 前缀和与二分查找：在处理区间和问题、查找满足条件的区间等场景中经常使用。

### 洛谷相似题目推荐
- [P1198 [JSOI2008] 最大数](https://www.luogu.com.cn/problem/P1198)
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)
- [P3808 [模板]  AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808)

### 个人心得摘录与总结
部分题解提到了这道题的细节较多，如处理 $X$ 较大的情况、循环节的确定等，需要仔细考虑各种边界条件，避免出错。在实现过程中，可以先写出暴力模拟的代码，再逐步优化，同时结合代码进行调试，确保逻辑的正确性。

---
处理用时：42.68秒
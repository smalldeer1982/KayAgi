# 题目信息

# [ABC264F] Monochromatic Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc264/tasks/abc264_f

各マスが白または黒で塗られた $ H $ 行 $ W $ 列のグリッドがあります。 $ 1\ \leq\ i\ \leq\ H $ かつ $ 1\ \leq\ j\ \leq\ W $ を満たす整数の組 $ (i,\ j) $ について、 グリッドの上から $ i $ 行目、左から $ j $ 行目のマス（以下、単にマス $ (i,\ j) $ と呼ぶ）の色は $ A_{i,\ j} $ で表されます。 $ A_{i,\ j}\ =\ 0 $ のときマス $ (i,\ j) $ は白色、$ A_{i,\ j}\ =\ 1 $ のときマス $ (i,\ j) $ は黒色です。

「下記の $ 2 $ つの操作のどちらかを行うこと」を好きなだけ（ $ 0 $ 回でも良い）繰り返すことができます。

- $ 1\ \leq\ i\ \leq\ H $ を満たす整数を選び、$ R_i $ 円払った後、グリッドの上から $ i $ 行目にあるそれぞれのマスの色を反転させる（白色のマスは黒色に、黒色のマスは白色に塗り替える）。
- $ 1\ \leq\ j\ \leq\ W $ を満たす整数を選び、$ C_j $ 円払った後、グリッドの左から $ j $ 列目にあるそれぞれのマスの色を反転させる。

下記の条件を満たすようにするためにかかる合計費用の最小値を出力して下さい。

- マス $ (1,\ 1) $ から「現在いるマスの右隣もしくは下隣のマスに移動する」 ことを繰り返してマス $ (H,\ W) $ まで移動する経路であって、通るマス（マス $ (1,\ 1) $ とマス $ (H,\ W) $ も含む）の色がすべて同じであるようなものが存在する。

本問題の制約下において、有限回の操作によって上記の条件を満たすようにすることが可能であることが証明できます。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ 1\ \leq\ R_i\ \leq\ 10^9 $
- $ 1\ \leq\ C_j\ \leq\ 10^9 $
- $ A_{i,\ j}\ \in\ \lbrace\ 0,\ 1\rbrace $
- 入力はすべて整数

### Sample Explanation 1

白色のマスを `0` 、黒色のマスを `1` で表します。 初期状態のグリッドに対し、$ R_2\ =\ 3 $ 円払って上から $ 2 $ 行目にあるそれぞれのマスを反転させると、 ``` 0100 0100 1010 ``` となります。さらに、$ C_2\ =\ 6 $ 円払って左から $ 2 $ 列目にあるそれぞれのマスを反転させると、 ``` 0000 0000 1110 ``` となり、マス $ (1,\ 1) $ からマス $ (3,\ 4) $ への移動経路であって通るマスの色がすべて同じであるようなものが存在する状態になります（例えば $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (2,\ 4)\ \rightarrow\ (3,\ 4) $ という経路）。 かかった合計費用は $ 3+6\ =\ 9 $ 円であり、このときが考えられる中で最小です。

## 样例 #1

### 输入

```
3 4

4 3 5

2 6 7 4

0100

1011

1010```

### 输出

```
9```

## 样例 #2

### 输入

```
15 20

29 27 79 27 30 4 93 89 44 88 70 75 96 3 78

39 97 12 53 62 32 38 84 49 93 53 26 13 25 2 76 32 42 34 18

01011100110000001111

10101111100010011000

11011000011010001010

00010100011111010100

11111001101010001011

01111001100101011100

10010000001110101110

01001011100100101000

11001000100101011000

01110000111011100101

00111110111110011111

10101111111011101101

11000011000111111001

00011101011110001101

01010000000001000000```

### 输出

```
125```

# AI分析结果

### 题目翻译
有一个 $H$ 行 $W$ 列的网格，每个格子被涂成白色或黑色。对于满足 $1 \leq i \leq H$ 且 $1 \leq j \leq W$ 的整数对 $(i, j)$，网格中从上往下第 $i$ 行、从左往右第 $j$ 列的格子（以下简称为格子 $(i, j)$）的颜色用 $A_{i, j}$ 表示。当 $A_{i, j} = 0$ 时，格子 $(i, j)$ 为白色；当 $A_{i, j} = 1$ 时，格子 $(i, j)$ 为黑色。

可以任意次数（可以为 0 次）重复执行以下两种操作之一：
- 选择一个满足 $1 \leq i \leq H$ 的整数，支付 $R_i$ 日元后，将网格中从上往下第 $i$ 行的每个格子的颜色反转（白色格子变为黑色，黑色格子变为白色）。
- 选择一个满足 $1 \leq j \leq W$ 的整数，支付 $C_j$ 日元后，将网格中从左往右第 $j$ 列的每个格子的颜色反转。

请输出满足以下条件所需的总费用的最小值：
- 存在一条从格子 $(1, 1)$ 出发，通过不断“移动到当前格子的右邻或下邻格子”最终到达格子 $(H, W)$ 的路径，且该路径上经过的格子（包括格子 $(1, 1)$ 和格子 $(H, W)$）的颜色全部相同。

在本题的约束条件下，可以证明通过有限次操作能够满足上述条件。

### 综合分析与结论
这些题解均采用动态规划（DP）来解决问题。思路要点在于发现同一行或列最多反转一次，因为两次反转相当于未操作。通过设计四维状态 $dp_{i,j,x,y}$ （$x,y\in[0,1]$），表示走到 $(i,j)$ 时第 $i$ 行和第 $j$ 列是否反转的最小花费。转移时根据当前格子与上一个格子颜色是否相同来决定是否需要额外花费进行反转操作，最后从 $dp_{n,m,0,0},dp_{n,m,0,1},dp_{n,m,1,0},dp_{n,m,1,1}$ 中取最小值得到答案。

### 所选题解
- **作者：allenchoi (赞：6)  ★★★★**
    - **关键亮点**：思路清晰，对操作性质和状态转移的解释详细，代码实现规范，注释较少但逻辑易懂。
    - **核心代码**：
```cpp
long long INF = 1e17;
int n,m,a[2010],b[2010],A[2010][2010];
long long dp[2010][2010][2][2];
// ... 输入部分省略 ...
dp[1][1][0][0] = 0,dp[1][1][1][0] = a[1],dp[1][1][0][1] = b[1],dp[1][1][1][1] = a[1] + b[1];
for(int j = 2;j <= m;j++)
    for(int x = 0;x <= 1;x++)
        for(int y = 0;y <= 1;y++)
            if((A[1][j] ^ x ^ y) == (A[1][j - 1] ^ x)) dp[1][j][x][y] = dp[1][j - 1][x][0] + b[j] * y;
            else dp[1][j][x][y] = dp[1][j - 1][x][1] + b[j] * y;
// ... 其他行和列的转移部分省略 ...
printf("%lld\n",min(min(dp[n][m][0][0],dp[n][m][0][1]),min(dp[n][m][1][0],dp[n][m][1][1])));
```
核心思想：先初始化起点的四种状态，然后分第一行、第一列和其他情况进行状态转移，转移时根据当前格子与上一个格子颜色是否相同来决定是否需要额外花费进行反转操作，最后取四种终点状态的最小值。

- **作者：KazamaRuri (赞：4)  ★★★★**
    - **关键亮点**：对状态设计和转移的分析简洁明了，代码中自定义了取最小值的函数，逻辑清晰。
    - **核心代码**：
```cpp
#define _min(x,y) (x>y?y:x)
using ll= long long;
const int N=2005;
int n,m,r[N],c[N]; ll f[N][N][2][2]; char a[N][N];
// ... 输入部分省略 ...
memset(f,0x3f,sizeof(f));
for(int i=0;i<2;i++)
    for(int j=0;j<2;j++)
        f[1][1][i][j]=i*r[1]+j*c[1];
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        if(i==1&&j==1) continue;
        for(int p=0;p<2;p++) for(int q=0;q<2;q++)
        for(int u=0;u<2;u++) for(int v=0;v<2;v++){
            if(q==v&&(a[i][j]^p)==(a[i-1][j]^u))
                f[i][j][p][q]=_min(f[i][j][p][q],f[i-1][j][u][v]+p*r[i]);
            if(p==u&&(a[i][j]^q)==(a[i][j-1]^v))
                f[i][j][p][q]=_min(f[i][j][p][q],f[i][j-1][u][v]+q*c[j]);
        }
    }
ll ans=0x3f3f3f3f3f3f3f3f;
for(int i=0;i<2;i++)
    for(int j=0;j<2;j++)
        ans=min(ans,f[n][m][i][j]);
return !printf("%lld",ans);
```
核心思想：先将状态数组初始化为无穷大，然后初始化起点的四种状态，接着进行状态转移，转移时根据同行或同列的颜色是否相同来决定是否需要额外花费进行反转操作，最后取四种终点状态的最小值。

- **作者：Tsawke (赞：3)  ★★★★**
    - **关键亮点**：对状态转移方程的推导详细，代码中使用了自定义的读取函数，逻辑完整。
    - **核心代码**：
```cpp
int H, W;
ll R[2100], C[2100];
ll dp[2100][2100][2][2];
bitset < 2100 > G[2100];
// ... 输入部分省略 ...
memset(dp, 0x3f, sizeof dp);
dp[1][1][0][0] = 0, dp[1][1][1][0] = R[1], dp[1][1][0][1] = C[1], dp[1][1][1][1] = R[1] + C[1];
for(int i = 1; i <= H; ++i)
    for(int j = 1; j <= W; ++j)
        for(int x = 0; x <= 1; ++x)
            for(int y = 0; y <= 1; ++y){
                if((G[i][j] ^ x ^ y )== (G[i + 1][j] ^ y))dp[i + 1][j][0][y] = min(dp[i + 1][j][0][y], dp[i][j][x][y]);
                else dp[i + 1][j][1][y] = min(dp[i + 1][j][1][y], dp[i][j][x][y] + R[i + 1]);
                if((G[i][j] ^ x ^ y) == (G[i][j + 1] ^ x))dp[i][j + 1][x][0] = min(dp[i][j + 1][x][0], dp[i][j][x][y]);
                else dp[i][j + 1][x][1] = min(dp[i][j + 1][x][1], dp[i][j][x][y] + C[j + 1]);
            }
ll ans(LONG_LONG_MAX);
for(int x = 0; x <= 1; ++x)for(int y = 0; y <= 1; ++y)ans = min(ans, dp[H][W][x][y]);
printf("%lld\n", ans);
```
核心思想：先将状态数组初始化为无穷大，然后初始化起点的四种状态，接着进行状态转移，转移时根据当前格子与下一个格子颜色是否相同来决定是否需要额外花费进行反转操作，最后取四种终点状态的最小值。

### 最优关键思路或技巧
- **状态设计**：通过四维状态 $dp_{i,j,x,y}$ 记录走到 $(i,j)$ 时第 $i$ 行和第 $j$ 列是否反转的最小花费，巧妙地将行列的操作状态融入状态中。
- **异或运算**：利用异或运算判断格子颜色是否相同，简化了颜色反转的判断过程。
- **操作性质**：发现同一行或列最多反转一次的性质，减少了不必要的状态枚举。

### 可拓展之处
同类型题目可能会有不同的操作规则或约束条件，例如可以向其他方向移动、增加更多的操作类型等。类似算法套路可以是在动态规划中考虑状态的组合和转移，结合题目中的操作性质进行优化。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的 0 - 1 背包问题，考察动态规划的基本思想。
- [P1216 [USACO1.5] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：简单的线性动态规划问题，帮助理解状态转移。
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)：考察动态规划在序列问题中的应用。

### 个人心得
题解中未包含个人心得。 

---
处理用时：58.13秒
# 题目信息

# [ABC315D] Magical Cookies

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_d

$ H\ \times\ W $ 枚のクッキーが $ H $ 行 $ W $ 列に並んでいます。  
上から $ i $ 行目・左から $ j $ 列目のクッキーの色は英小文字 $ c_{i,j} $ で表されます。

これから、以下の手続きを行います。

1\. 各行に対して次の操作を行う : その行に $ 2 $ 枚以上のクッキーが残っており、それらの色がすべて同じならば、それらに印をつける。

2\. 各列に対して次の操作を行う : その列に $ 2 $ 枚以上のクッキーが残っており、それらの色がすべて同じならば、それらに印をつける。

3\. 印のついたクッキーがあればそれらをすべて取り除いて 1. に戻り、なければ手続きを終了する。

手続きを終了した時点で残っているクッキーの枚数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ c_{i,j} $ は英小文字である

### Sample Explanation 1

以下で示す順で手続きを行います。 - 1. により、$ 1,\ 2 $ 行目のクッキーに印をつける。 - 2. により、$ 1 $ 列目のクッキーに印をつける。 - 3. により、印を付けたクッキーを取り除く。 この時点でクッキーは以下のようになっています。ただし、クッキーを取り除いた箇所は `.` で表しています。 ``` ... ... .bc .bd ``` - 1. により、何もしない。 - 2. により、$ 2 $ 列目のクッキーに印をつける。 - 3. により、印を付けたクッキーを取り除く。 この時点でクッキーは以下のようになっています。ただし、クッキーを取り除いた箇所は `.` で表しています。 ``` ... ... ..c ..d ``` - 1. により、何もしない。 - 2. により、何もしない。 - 3. により、印がついているクッキーが存在しないので手続きを終了する。 最終的に残っているクッキーの枚数は $ 2 $ 枚です。

## 样例 #1

### 输入

```
4 3
aaa
aaa
abc
abd```

### 输出

```
2```

## 样例 #2

### 输入

```
2 5
aaaaa
abcde```

### 输出

```
4```

## 样例 #3

### 输入

```
3 3
ooo
ooo
ooo```

### 输出

```
0```

# AI分析结果

### 题目中文重写
# [ABC315D] 魔法饼干

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_d

有 $ H\ \times\ W $ 块饼干排列成 $ H $ 行 $ W $ 列。
从上往下数第 $ i $ 行、从左往右数第 $ j $ 列的饼干颜色用小写英文字母 $ c_{i,j} $ 表示。

接下来，进行以下操作：
1. 对每一行进行如下操作：若该行剩余 2 块及以上的饼干，且它们的颜色都相同，则给它们做上标记。
2. 对每一列进行如下操作：若该列剩余 2 块及以上的饼干，且它们的颜色都相同，则给它们做上标记。
3. 若有做标记的饼干，则将它们全部移除，然后回到步骤 1；若没有，则结束操作。

请计算操作结束后剩余的饼干数量。

## 说明/提示

### 限制条件
- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ c_{i,j} $ 为小写英文字母

### 样例解释 1
按以下顺序进行操作：
- 步骤 1：给第 1、2 行的饼干做上标记。
- 步骤 2：给第 1 列的饼干做上标记。
- 步骤 3：移除做标记的饼干。此时饼干状态如下，移除饼干的位置用 `.` 表示。
```
...
...
.bc
.bd
```
- 步骤 1：不进行任何操作。
- 步骤 2：给第 2 列的饼干做上标记。
- 步骤 3：移除做标记的饼干。此时饼干状态如下，移除饼干的位置用 `.` 表示。
```
...
...
..c
..d
```
- 步骤 1：不进行任何操作。
- 步骤 2：不进行任何操作。
- 步骤 3：由于没有做标记的饼干，结束操作。
最终剩余的饼干数量为 2 块。

## 样例 #1
### 输入
```
4 3
aaa
aaa
abc
abd
```
### 输出
```
2
```

## 样例 #2
### 输入
```
2 5
aaaaa
abcde
```
### 输出
```
4
```

## 样例 #3
### 输入
```
3 3
ooo
ooo
ooo
```
### 输出
```
0
```

### 综合分析与结论
这些题解的核心思路都是模拟饼干删除的过程，通过不同方式优化时间复杂度。由于直接暴力模拟复杂度为 $O(n^3)$ 会超时，所以各题解均采用桶来记录每行和每列中每个字母的出现次数，将判断是否删除的复杂度从 $O(n)$ 优化到 $O(26)$，整体复杂度优化到 $O(n^2)$ 或 $O(26n^2)$。

各题解的主要区别在于代码实现细节，如标记已删除的行和列、更新桶的方式等。部分题解还考虑了特殊情况，如删除行和列的顺序对结果的影响。

### 所选题解
- **_zzzzzzy_（5星）**
    - **关键亮点**：思路清晰，代码简洁，通过 `vis1` 和 `vis2` 数组标记已删除的行和列，使用 `vector` 记录待删除的行和列，逻辑清晰。
    - **核心代码**：
```cpp
while(1) {
    vector<int> r, c;
    // 判断哪些行可以删除
    for (int i = 1; i <= n; i++) {
        if (!vis1[i]) {
            int cnt = 0, tot = 0;
            for (int j = 0; j < 26; j++) {
                cnt += st1[i][j] > 0;
                tot += st1[i][j];
            }
            if (cnt == 1 && tot > 1) {
                r.push_back(i);
            }
        }
    }
    // 判断哪些列可以删除
    for (int i = 1; i <= m; i++) {
        if (!vis2[i]) {
            int cnt = 0, tot = 0;
            for (int j = 0; j < 26; j++) {
                cnt += st2[i][j] > 0;
                tot += st2[i][j];
            }
            if (cnt == 1 && tot > 1) {
                c.push_back(i);
            }
        }
    }
    // 删除行
    for (int x : r) {
        vis1[x] = 1;
        for (int j = 1; j <= m; j++) {
            if (mp[x][j] != '.') {
                st1[x][mp[x][j] - 'a']--;
                st2[j][mp[x][j] - 'a']--;
            }
            mp[x][j] = '.';
        }
    }
    // 删除列
    for (int x : c) {
        vis2[x] = 1;
        for (int j = 1; j <= n; j++) {
            if (mp[j][x] != '.') {
                st1[j][mp[j][x] - 'a']--;
                st2[x][mp[j][x] - 'a']--;
            }
            mp[j][x] = '.';
        }
    }
    if (!r.size() && !c.size()) {
        break;
    }
}
```
- **banned_xiejiayun（4星）**
    - **关键亮点**：详细解释了使用 `h_c_tmp` 和 `l_c_tmp` 数组的原因，避免了在循环中删除元素导致的误判问题。
    - **核心代码**：
```cpp
while (1) {
    if (nn < 2 && mm < 2) break;
    x = 0;
    y = 0;
    memset(h_c_tmp, 0, sizeof(h_c_tmp));
    memset(l_c_tmp, 0, sizeof(l_c_tmp));
    bool flag_n = 0, flag_m = 0;
    int nn__ = nn;
    if (mm >= 2) {
        for (int i = 1; i <= n; i++) {
            if (h_flag[i]) continue;
            for (int j = 0; j < 26; j++) {
                if (h_c[i][j]) {
                    if (h_c[i][j] == mm) {
                        if (!flag_n) flag_n = 1;
                        ans -= mm;
                        x++;
                        h_flag[i] = 1;
                        nn__--;
                        for (int k = 1; k <= m; k++) {
                            l_c_tmp[k][j]++;
                        }
                    } else break;
                }
            }
        }
    }
    int mm__ = mm;
    if (nn >= 2) {
        for (int i = 1; i <= m; i++) {
            if (l_flag[i]) continue;
            for (int j = 0; j < 26; j++) {
                if (l_c[i][j]) {
                    if (l_c[i][j] == nn) {
                        if (!flag_m) flag_m = 1;
                        ans -= nn;
                        y++;
                        l_flag[i] = 1;
                        mm__--;
                        for (int k = 1; k <= n; k++) {
                            h_c_tmp[k][j]++;
                        }
                    } else break;
                }
            }
        }
    }
    if (!flag_m && !flag_n) break;
    for (int i = 1; i <= m; i++)
        for (int j = 0; j < 26; j++) {
            l_c[i][j] -= l_c_tmp[i][j];
        }
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < 26; j++) {
            h_c[i][j] -= h_c_tmp[i][j];
        }
    ans += x * y;
    nn = nn__;
    mm = mm__;
}
```
- **FBW2010（4星）**
    - **关键亮点**：使用 `f1` 和 `f2` 数组标记已删除的行和列，逻辑清晰，代码可读性高。
    - **核心代码**：
```cpp
while(1){
    int f = 1;
    // 判断哪些行可以删除
    for(int i = 1; i <= h; i++){
        if(f1[i] == 2) continue;
        int cnt = 0;
        for(int j = 0; j < 26; j++){
            if(b1[i][j]){
                cnt++;
                if(cnt > 1 || b1[i][j] < 2){
                    cnt = 2;
                    break;
                }
            }
        }
        if(cnt == 1){
            f = 0;
            f1[i] = 1;
        }
    }
    // 判断哪些列可以删除
    for(int i = 1; i <= w; i++){
        if(f2[i] == 2) continue;
        int cnt = 0;
        for(int j = 0; j < 26; j++){
            if(b2[i][j]){
                cnt++;
                if(cnt > 1 || b2[i][j] < 2){
                    cnt = 2;
                    break;
                }
            }
        }
        if(cnt == 1){
            f = 0;
            f2[i] = 1;
        }
    }
    if(f) break;
    // 删除行
    for(int i = 1; i <= h; i++){
        if(f1[i] == 1){
            f1[i] = 2;
            for(int j = 1; j <= w; j++){
                if(f2[j] != 2){
                    b1[i][a[i][j] - 'a']--;
                    b2[j][a[i][j] - 'a']--;
                    ans--;
                }
            }
        }
    }
    // 删除列
    for(int i = 1; i <= w; i++){
        if(f2[i] == 1){
            f2[i] = 2;
            for(int j = 1; j <= h; j++){
                if(f1[j] != 2){
                    b1[j][a[j][i] - 'a']--;
                    b2[i][a[j][i] - 'a']--;
                    ans--;
                }
            }
        }
    }
}
```

### 最优关键思路或技巧
- **桶的使用**：使用二维数组记录每行和每列中每个字母的出现次数，将判断是否删除的复杂度从 $O(n)$ 优化到 $O(26)$。
- **标记已删除的行和列**：使用数组标记已删除的行和列，避免重复判断。
- **延迟删除**：先标记所有需要删除的行和列，再统一删除，避免在循环中删除元素导致的误判问题。

### 可拓展之处
同类型题目可能会有不同的删除规则或条件，如删除部分相同的行或列、删除满足特定条件的元素等。解题思路仍然是模拟操作过程，并通过合适的数据结构优化时间复杂度。

### 推荐洛谷题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：模拟过河卒的行走路径，需要考虑边界条件和障碍物。
2. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)：模拟乒乓球比赛的计分过程，需要处理不同的赛制。
3. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)：模拟多项式的输出过程，需要考虑系数和指数的特殊情况。

### 个人心得摘录与总结
- **banned_xiejiayun**：解释了使用 `l_c_tmp` 和 `h_c_tmp` 数组的原因，避免在循环中删除元素导致的误判问题，提醒在模拟过程中要注意操作顺序对结果的影响。
- **Zi_Gao**：分享了自己第一次在比赛上切高评分题的经历，认为题目不难但很多人现场没切出来，强调了对题目的分析和优化的重要性。

---
处理用时：66.60秒
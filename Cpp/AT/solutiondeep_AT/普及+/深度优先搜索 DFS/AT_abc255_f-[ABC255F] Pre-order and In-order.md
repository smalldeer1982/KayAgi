# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个包含 $1, 2, \ldots, N$ 编号的 $N$ 个顶点的**二分树**。二分树是指每个顶点最多有两个子节点的有根树。具体来说，二分树的每个顶点最多有一个**左子节点**和一个**右子节点**。

要求构造一棵以顶点 $1$ 为根的二分树，满足以下条件：

- 所有顶点按照深度优先搜索的**前序遍历**（pre-order）顺序排列为 $(P_1, P_2, \ldots, P_N)$。
- 所有顶点按照深度优先搜索的**中序遍历**（in-order）顺序排列为 $(I_1, I_2, \ldots, I_N)$。

如果存在这样的二分树，请输出其结构；否则输出 `-1`。

**说明/提示**

- $2 \leq N \leq 2 \times 10^5$
- $N$ 是整数
- $(P_1, P_2, \ldots, P_N)$ 是 $(1, 2, \ldots, N)$ 的排列
- $(I_1, I_2, \ldots, I_N)$ 是 $(1, 2, \ldots, N)$ 的排列

### 题解综合分析

本题的核心是通过前序遍历和中序遍历构造二叉树，并判断是否存在以 $1$ 为根的二叉树。所有题解都采用了递归的思路，利用前序遍历确定根节点，中序遍历划分左右子树，并通过递归构建树结构。以下是各题解的要点对比：

1. **递归思路**：所有题解都采用了递归的方法，通过前序遍历的第一个节点确定根节点，然后在中序遍历中找到根节点的位置，划分左右子树，继续递归构建。
2. **无解判断**：大部分题解都提到了无解的情况，如前序遍历的第一个节点不是 $1$，或者在中序遍历中找不到对应的根节点。
3. **优化**：部分题解通过预处理中序遍历中每个节点的位置，避免了在递归中重复查找，提升了效率。

### 评分较高的题解

#### 题解1：作者：program_xwl (4星)

**关键亮点**：
- 思路清晰，代码结构简洁。
- 通过预处理中序遍历中每个节点的位置，避免了重复查找，提升了效率。
- 无解判断明确，代码可读性高。

**核心代码**：
```cpp
void dfs(int l1, int r1, int l2, int r2) {
    if (l1 >= r1) return;
    int root = mp[a[l1]], sizl = root - l2, sizr = r2 - root;
    if (root < l2 || root > r2) {
        cout << -1;
        exit(0);
    }
    tree[a[l1]] = {a[l1 + 1], a[l1 + sizl + 1]};
    if (sizl == 0) tree[a[l1]].l = 0;
    if (sizr == 0) tree[a[l1]].r = 0;
    dfs(l1 + 1, l1 + sizl, l2, root - 1);
    dfs(l1 + sizl + 1, r1, root + 1, r1);
}
```

#### 题解2：作者：Tsawke (4星)

**关键亮点**：
- 思路清晰，代码结构简洁。
- 通过预处理中序遍历中每个节点的位置，避免了重复查找，提升了效率。
- 无解判断明确，代码可读性高。

**核心代码**：
```cpp
int dfs(int lp = 1, int rp = N, int li = 1, int ri = N) {
    if (lp > rp) return 0;
    int rt = Pre[lp];
    if (posI[rt] < li || posI[rt] > ri) puts("-1"), exit(0);
    if (lp == rp) return rt;
    int lsiz = (posI[rt] - 1) - li + 1;
    son[rt].first = dfs(lp + 1, lp + lsiz, li, posI[rt] - 1);
    son[rt].second = dfs(lp + lsiz + 1, rp, posI[rt] + 1, ri);
    return rt;
}
```

#### 题解3：作者：ATION001 (4星)

**关键亮点**：
- 思路清晰，代码结构简洁。
- 通过预处理中序遍历中每个节点的位置，避免了重复查找，提升了效率。
- 无解判断明确，代码可读性高。

**核心代码**：
```cpp
int dfs(int l1, int r1, int l2, int r2) {
    if (l1 > r1) return 0;
    int P = mp[qian[l1]];
    if (P < l2 || P > r2) {
        cout << -1;
        exit(0);
    }
    l[qian[l1]] = dfs(l1 + 1, l1 + (P - l2), l2, P - 1);
    r[qian[l1]] = dfs(l1 + (P - l2) + 1, r1, P + 1, r2);
    return qian[l1];
}
```

### 最优关键思路

1. **递归构建树**：通过前序遍历的第一个节点确定根节点，然后在中序遍历中找到根节点的位置，划分左右子树，继续递归构建。
2. **预处理中序遍历**：通过预处理中序遍历中每个节点的位置，避免了在递归中重复查找，提升了效率。
3. **无解判断**：前序遍历的第一个节点不是 $1$，或者在中序遍历中找不到对应的根节点时，直接输出 `-1`。

### 拓展思路

- **类似题目**：可以通过前序遍历和中序遍历构造二叉树的题目，如 [P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030)。
- **其他遍历组合**：可以考虑通过中序遍历和后序遍历构造二叉树，或者通过前序遍历和后序遍历构造二叉树。

### 推荐题目

1. [P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030)
2. [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)
3. [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)

---
处理用时：46.10秒
# 题目信息

# [ABC362E] Count Arithmetic Subsequences

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc362/tasks/abc362_e

長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。各 $ k=1,2,\dots,N $ について、$ A $ の長さ $ k $ の（連続するとは限らない）部分列であって等差数列であるようなものの個数を $ 998244353 $ で割ったあまりを求めてください。ただし、$ 2 $ つの部分列が列として同じでも、取り出す位置が異なるならば区別するものとします。

部分列とは数列 $ A $ の部分列とは、$ A $ の要素を $ 0 $ 個以上選んで削除し、残った要素を元の順序を保って並べた数列のことを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 80 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力はすべて整数

### Sample Explanation 1

\- 長さ $ 1 $ の部分列は全部で $ 5 $ 個あり、これらはすべて長さ $ 1 $ の等差数列です。 - 長さ $ 2 $ の部分列は全部で $ 10 $ 個あり、これらはすべて長さ $ 2 $ の等差数列です。 - 長さ $ 3 $ の部分列であって等差数列であるものは、$ (A_1,A_2,A_3),(A_1,A_2,A_5),(A_1,A_4,A_5) $ の $ 3 $ つです。 - 長さ $ 4 $ 以上の部分列であって等差数列であるものは存在しません。

## 样例 #1

### 输入

```
5
1 2 3 2 3```

### 输出

```
5 10 3 0 0```

## 样例 #2

### 输入

```
4
1 2 3 4```

### 输出

```
4 6 2 1```

## 样例 #3

### 输入

```
1
100```

### 输出

```
1```

# AI分析结果

### 题目翻译
【题目内容】
# [ABC362E] 统计等差子序列

## 题目描述

给定一个长度为 $N$ 的数列 $A=(A_1,A_2,\dots,A_N)$。对于每个 $k=1,2,\dots,N$，求 $A$ 中长度为 $k$ 的（不一定连续的）子序列中，等差数列的个数，结果对 $998244353$ 取模。注意，两个子序列即使元素相同，但如果选取的位置不同，也视为不同的子序列。

子序列是指从数列 $A$ 中删除零个或多个元素后，按原顺序排列的数列。

## 说明/提示

### 约束条件

- $1\ \leq\ N\ \leq\ 80$
- $1\ \leq\ A_i\ \leq\ 10^9$
- 输入均为整数

### 样例解释 1

- 长度为 $1$ 的子序列共有 $5$ 个，它们都是长度为 $1$ 的等差数列。
- 长度为 $2$ 的子序列共有 $10$ 个，它们都是长度为 $2$ 的等差数列。
- 长度为 $3$ 的等差数列子序列有 $(A_1,A_2,A_3),(A_1,A_2,A_5),(A_1,A_4,A_5)$ 共 $3$ 个。
- 长度为 $4$ 及以上的等差数列子序列不存在。

## 样例 #1

### 输入

```
5
1 2 3 2 3```

### 输出

```
5 10 3 0 0```

## 样例 #2

### 输入

```
4
1 2 3 4```

### 输出

```
4 6 2 1```

## 样例 #3

### 输入

```
1
100```

### 输出

```
1```

### 题解分析与结论

#### 综合分析
本题的核心是统计所有可能的等差子序列的数量。由于 $N$ 的范围较小（$N \leq 80$），可以采用动态规划（DP）的方法来解决。不同的题解在状态定义和转移方式上有所不同，但基本思路都是通过枚举子序列的最后几个元素来递推计算。

#### 关键思路与技巧
1. **状态定义**：大多数题解采用了类似的状态定义，即 $f_{i,j,k}$ 表示长度为 $i$，最后两个元素为 $a_j$ 和 $a_k$ 的等差子序列的数量。
2. **转移方式**：通过枚举倒数第三个元素来进行状态转移，确保子序列的等差性质。
3. **优化**：部分题解通过离散化公差或使用数学优化（如组合数计算）来减少计算量。

#### 评分较高的题解
1. **作者：_determination_ (赞：9)**  
   - **星级**：4.5  
   - **关键亮点**：状态定义清晰，转移逻辑简洁，代码可读性高。  
   - **核心代码**：
     ```cpp
     for ( int i = 3 ; i <= n ; i++ )
     {
         for ( int j = i-1 ; j <= n ; j++ )
         {
             for ( int k = j+1 ; k <= n ; k++ )
             {
                 for ( int l = i-2 ; l < j ; l++ )
                 {
                     if(a[j]-a[l]==a[k]-a[j])
                         f[i][j][k]=(f[i][j][k]+f[i-1][l][j])%mod;
                 }
                 ans[i]+=f[i][j][k];
             }
         }
     }
     ```
   - **个人心得**：通过枚举倒数第三个元素，确保了状态转移的正确性。

2. **作者：MightZero (赞：6)**  
   - **星级**：4  
   - **关键亮点**：通过离散化公差，减少了状态空间，提高了效率。  
   - **核心代码**：
     ```cpp
     loop(i,1,n)loop(len,2,i)loop(j,1,i-1)
     {
         ll dpos=lower_bound(d.begin(),d.end(),a[i]-a[j])-d.begin();
         (dp[i][len][dpos]+=dp[j][len-1][dpos])%=MOD;
     }
     ```
   - **个人心得**：离散化公差后，状态转移更加高效，适合处理较大的公差范围。

3. **作者：Po7ed (赞：2)**  
   - **星级**：4  
   - **关键亮点**：结合爆搜与数学优化，处理了 $d=0$ 的特殊情况，提升了效率。  
   - **核心代码**：
     ```cpp
     for(auto x:cnt)
     {
         for(int l=1;l<=x.second;l++)
         {
             ans[l]=(ans[l]+C(x.second,l))%mod;
         }
     }
     ```
   - **个人心得**：通过数学优化处理了全等数列的情况，减少了不必要的搜索。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 考察动态规划与序列处理。
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040) - 涉及树形DP与序列处理。
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057) - 动态规划与状态转移的应用。

---
处理用时：40.21秒
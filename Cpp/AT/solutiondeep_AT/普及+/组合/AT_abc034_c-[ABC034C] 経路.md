# 题目信息

# [ABC034C] 経路

## 题目描述

有一个 $W$ 行 $H$ 列的网格图（$2 \leq W,H \leq 10^5$），其中第 $i$ 行第 $j$ 列的坐标为 $(i,j)$。

现在有一个人想从起点 $(1,1)$ 走到终点 $(W,H)$，已知他每次可以从网格 $(i,j)$ 走向 $(i+1,j)$ 或 $(i,j+1)$。现在请你求出，他从起点走到终点的路线个数为多少。

由于这个数可能很大，因此你只要输出路线个数对 $10^9 + 7$ 取模的结果即可。

## 样例 #1

### 输入

```
4 3```

### 输出

```
10```

## 样例 #2

### 输入

```
123 456```

### 输出

```
210368064```

# AI分析结果

### 题目翻译
## [ABC034C] 路径

### 题目描述
有一个 $W$ 行 $H$ 列的网格图（$2 \leq W,H \leq 10^5$），其中第 $i$ 行第 $j$ 列的坐标为 $(i,j)$。

现在有一个人想从起点 $(1,1)$ 走到终点 $(W,H)$，已知他每次可以从网格 $(i,j)$ 走向 $(i+1,j)$ 或 $(i,j+1)$。现在请你求出，他从起点走到终点的路线个数为多少。

由于这个数可能很大，因此你只要输出路线个数对 $10^9 + 7$ 取模的结果即可。

### 样例 #1
#### 输入
```
4 3
```
#### 输出
```
10
```

### 样例 #2
#### 输入
```
123 456
```
#### 输出
```
210368064
```

### 综合分析与结论
- **思路**：各题解均将从 $(1, 1)$ 走到 $(W, H)$ 的问题转化为组合数学问题。从起点到终点需走 $W + H - 2$ 步，其中向下走 $W - 1$ 步（或向右走 $H - 1$ 步），问题等价于从 $W + H - 2$ 步中选 $W - 1$ 步向下走（或 $H - 1$ 步向右走）的组合数 $C_{W + H - 2}^{W - 1}$（或 $C_{W + H - 2}^{H - 1}$）。
- **算法要点**：先预处理阶乘及其逆元，再根据组合数公式 $C_n^m=\frac{n!}{m!(n - m)!}$ 计算组合数，由于涉及除法取模，需用逆元将除法转化为乘法，部分题解用费马小定理 $a^{p - 2}\equiv a^{-1}\pmod p$（$p$ 为质数）求逆元。
- **解决难点**：核心难点是处理组合数计算中的除法取模问题，通过引入逆元解决。

### 所选题解
- **残阳如血（5星）**
    - **关键亮点**：思路清晰，详细解释了组合数的推导和逆元的使用，代码结构清晰，注释明确。
    - **核心代码**：
```cpp
const int N = 2e5 + 10;
const int MOD = 1e9 + 7;
lint n, m, inv[N], fact[N], inv_fact[N];

void init() {
    inv[0] = inv[1] = 1;
    for (int i = 2; i < N; ++i)
        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
    fact[0] = inv_fact[0] = 1;
    for (int i = 1; i < N; ++i) {
        fact[i] = fact[i - 1] * i % MOD;
        inv_fact[i] = inv_fact[i - 1] * inv[i] % MOD;
    }
}

lint C(int n, int m) {
    if (m > n) return 0;
    if (m == n) return 1;
    return fact[n] * inv_fact[m] % MOD * inv_fact[n - m] % MOD;
}
```
    - **核心实现思想**：`init` 函数预处理逆元、阶乘及其逆元，`C` 函数根据组合数公式计算组合数。
- **jzjr（4星）**
    - **关键亮点**：详细解释了逆元的概念和费马小定理求逆元的方法，代码实现完整。
    - **核心代码**：
```cpp
LL jc[200005],ni[200005],mod=1e9+7;
LL H,W;
LL ksm(LL x,LL y,LL mod){
    LL ans=1;
    while(y){
        if(y&1)ans=ans*x%mod;
        x=x*x%mod;y=y>>1;
    }
    return ans;
}
void asd(){
    int tot=W+H;
    jc[0]=ni[0]=1;
    for(LL i=1;i<=tot;i++)jc[i]=jc[i-1]*i%mod;
    ni[tot]=ksm(jc[tot],mod-2,mod);
    for(int i=tot-1;i>0;i--)ni[i]=ni[i+1]*(i+1)%mod;
}
LL C(LL n,LL m){
    return jc[n]*ni[m]%mod*ni[n-m]%mod;
}
```
    - **核心实现思想**：`ksm` 函数实现快速幂，`asd` 函数预处理阶乘及其逆元，`C` 函数计算组合数。
- **zjinze（4星）**
    - **关键亮点**：思路简洁，代码实现清晰，明确指出可从向下或向右走的角度思考。
    - **核心代码**：
```cpp
const int mod=1e9+7;
const int N=2e5+7;
int n,m,jc[N],inv[N];
int ksm(int a,int b){
    int tmp=1;
    a%=mod;
    while(b){
        if(b&1){
            tmp=tmp*a;
            tmp%=mod;
        }
        a*=a;
        a%=mod;
        b>>=1;
    }
    return tmp;
}
int C(int m,int n){
    return (((jc[n]*inv[m])%mod)*inv[n-m])%mod;
}
```
    - **核心实现思想**：`ksm` 函数实现快速幂求逆元，`C` 函数计算组合数。

### 最优关键思路或技巧
- **组合数学建模**：将网格路径问题转化为组合数问题，简化计算。
- **逆元处理除法取模**：利用逆元将组合数计算中的除法取模转化为乘法取模，避免精度问题。

### 可拓展之处
同类型题如在网格中增加障碍物，需排除经过障碍物的路径；或改变移动规则，如可斜向移动等。类似算法套路可用于解决其他排列组合计数问题，如排队问题、分配问题等。

### 洛谷推荐题目
- P1865 《A % B Problem》：涉及质数筛和组合数取模。
- P3807 《【模板】卢卡斯定理》：考察卢卡斯定理计算大组合数。
- P2671 《求和》：综合运用组合数和数学推导。

### 个人心得
题解中未包含个人心得。 

---
处理用时：29.17秒
# 题目信息

# [ABC151E] Max-Min Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc151/tasks/abc151_e

有限個の整数からなる集合 $ X $ に対し $ f(X)=\max\ X\ -\ \min\ X $ と定義します。

$ N $ 個の整数 $ A_1,...,A_N $ が与えられます。

このうち $ K $ 個を選び、それらからなる集合を $ S $ とします。同じ値であっても添字が異なる要素を区別すると、そのような選び方は $ {}_N\ C_K $ 通りありますが、その全てについての $ f(S) $ の合計を求めてください。

答えは非常に大きくなる可能性があるので、$ \bmod\ 10^9+7 $ で出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

$ S $ の選び方は $ \{1,1\},\{1,3\},\{1,4\},\{1,3\},\{1,4\},\{3,4\} $ の $ 6 $ 通りあり (ふたつの $ 1 $ は区別します)、$ f(S) $ はそれぞれ $ 0,2,3,2,3,1 $ となるので、合計は $ 11 $ です。

### Sample Explanation 2

$ S $ の選び方は $ 20 $ 通りあり、そのうち $ 18 $ 通りで $ f(S)=20 $、$ 2 $ 通りで $ f(S)=0 $ となります。

### Sample Explanation 4

合計は $ \bmod\ 10^9+7 $ で出力してください。

## 样例 #1

### 输入

```
4 2

1 1 3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
6 3

10 10 10 -10 -10 -10```

### 输出

```
360```

## 样例 #3

### 输入

```
3 1

1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 6

1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0```

### 输出

```
999998537```

# AI分析结果

### 题目翻译
对于由有限个整数组成的集合 $X$，定义 $f(X)=\max\ X - \min\ X$。

给定 $N$ 个整数 $A_1,\cdots,A_N$。

从中选取 $K$ 个整数，将这些整数组成的集合记为 $S$。即使值相同，但只要下标不同，就将这些元素视为不同元素，这样的选取方法共有 $ {}_N\ C_K $ 种。请计算所有这些选取方法对应的 $f(S)$ 的总和。

由于答案可能非常大，因此请将结果对 $10^9 + 7$ 取模后输出。

### 综合分析与结论
- **思路对比**：大部分题解思路一致，都是先对数组排序，然后分别计算每个数作为最大值和最小值出现的次数，最后将最大值的贡献总和减去最小值的贡献总和得到结果。Lynkcat 的题解思路较为独特，考虑长度为 $x(k\leq x)$ 的区间在序列中滑动，通过差分计算贡献。
- **算法要点**：各题解都使用了组合数，在计算组合数时，均采用逆元的方法，利用快速幂求逆元，以满足取模要求。
- **解决难点**：本题的难点在于如何高效地计算每个数作为最大值和最小值的出现次数，以及处理组合数取模的问题。各题解通过排序和组合数公式巧妙地解决了这些问题。

### 所选题解
- **TonyYin（5星）**
    - **关键亮点**：思路清晰，详细解释了计算每个数作为最大值和最小值次数的方法，并给出了完整的代码和取模处理，还提供了关于组合数取模的博客链接。
- **_determination_（4星）**
    - **关键亮点**：简单明了地阐述了组合数学的思路，代码结构清晰，注释详细。
- **WaterSun（4星）**
    - **关键亮点**：提供了更好的阅读体验，使用了宏定义简化代码，对组合数的计算和取模处理进行了封装。

### 重点代码
以下是 TonyYin 题解的核心代码：
```cpp
#include <bits/stdc++.h>
#define int long long
#define MAXN 100008
using namespace std;
int mod = 1e9 + 7;
int n, k, a[MAXN], fac[MAXN], ans = 0;
int power(int x, int k, int p) {
    int ret = 1;
    while(k) {
        if(k & 1) ret = ret * x % p;
        k >>= 1;
        x = x * x % p;
    }
    return ret % p;
}
int inv(int x, int p) {//求x关于模p的逆元
    return power(x, p - 2, p) % mod;
}
int C(int a, int b) {//直接用逆元求解组合数C(a, b)
    return fac[a] * inv(fac[b], mod) % mod * inv(fac[a - b], mod) % mod;
}
signed main() {
    scanf("%lld%lld", &n, &k);
    for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    fac[0] = 1;
    for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;
    sort(a + 1, a + n + 1); //升序排序
    //对于每个数，计算在多少种个子集中，这个数能作为最大值/最小值
    //作为最大值的可能情况是C(i - 1, k - 1)，最小值类似
    for(int i = k; i <= n; i++) { //算一遍最大值
        ans = (ans + a[i] * C(i - 1, k - 1) % mod) % mod;
    }
    for(int i = 1; i <= n - k + 1; i++) { //算一遍最小值
        ans = (ans - a[i] * C(n - i, k - 1) % mod) % mod;
    }
    cout << (ans % mod + mod) % mod << endl;
    return 0;
}
```
**核心实现思想**：先对输入的数组进行排序，然后预处理阶乘数组 `fac`。通过 `power` 函数实现快速幂，`inv` 函数求逆元，`C` 函数计算组合数。最后分别遍历数组，计算每个数作为最大值和最小值的贡献，将最大值的贡献累加，最小值的贡献累减，最后对结果进行取模处理。

### 最优关键思路或技巧
- **排序优化**：利用集合的无序性，对数组进行排序，方便计算每个数作为最大值和最小值的出现次数。
- **组合数逆元**：在数据范围较大的情况下，使用逆元求组合数，避免大数运算和取模的问题。

### 拓展思路
同类型题或类似算法套路：
- 计算组合数相关的题目，如计算满足某些条件的组合方案数。
- 统计元素贡献的题目，通过分析每个元素的贡献来求解问题。

### 推荐题目
- [P1869 愚蠢的组合数](https://www.luogu.com.cn/problem/P1869)
- [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)
- [P2822 [NOIP2016 提高组] 组合数问题](https://www.luogu.com.cn/problem/P2822)

### 个人心得
部分题解作者提到本题是简单组合数学题，如 _determination_ 表示“简单组合数学，五分钟秒了”，这提醒我们在遇到类似问题时，要善于从组合数学的角度思考，尝试分析每个元素的贡献，从而找到解题思路。同时，对于组合数取模的问题，要掌握逆元的计算方法，以避免大数运算和取模的问题。

---
处理用时：35.91秒
# 题目信息

# [ABC371E] I Hate Sigma Problems

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_e

長さ $ N $ の整数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられます。また、$ f(l,r) $ を以下で定義します。

- $ (A_l,A_{l+1},\ldots,A_{r-1},A_{r}) $ に含まれる値の種類数
 
次の式の値を求めてください。

 $ \displaystyle\ \sum_{i=1}^{N}\sum_{j=i}^N\ f(i,j) $

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\leq\ N $
- 入力される数値は全て整数
 
### Sample Explanation 1

$ f(1,2) $ について考えます。$ (A_1,A_2)=(1,2) $ に含まれる値の種類数は $ 2 $ なので $ f(1,2)=2 $ です。 $ f(2,3) $ について考えます。$ (A_2,A_3)=(2,2) $ に含まれる値の種類数は $ 1 $ なので $ f(2,3)=1 $ です。 $ f $ の総和は $ 8 $ となります。

## 样例 #1

### 输入

```
3

1 2 2```

### 输出

```
8```

## 样例 #2

### 输入

```
9

5 4 2 2 3 2 4 4 1```

### 输出

```
111```

# AI分析结果

### 题目内容中文重写
## [ABC371E] 我讨厌求和问题

### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_e

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\ldots,A_N)$。另外，定义 $f(l,r)$ 如下：
- $(A_l,A_{l + 1},\ldots,A_{r - 1},A_{r})$ 中包含的值的种类数

请计算以下式子的值：
$\displaystyle\ \sum_{i = 1}^{N}\sum_{j = i}^N\ f(i,j)$

### 说明/提示
#### 制约束
- $1\leq N\leq 2\times 10^5$
- $1\leq A_i\leq N$
- 输入的所有数值均为整数

#### 样例解释 1
考虑 $f(1,2)$。因为 $(A_1,A_2)=(1,2)$ 中包含的值的种类数是 $2$，所以 $f(1,2)=2$。考虑 $f(2,3)$。因为 $(A_2,A_3)=(2,2)$ 中包含的值的种类数是 $1$，所以 $f(2,3)=1$。$f$ 的总和为 $8$。

### 样例 #1
#### 输入
```
3
1 2 2
```
#### 输出
```
8
```

### 样例 #2
#### 输入
```
9
5 4 2 2 3 2 4 4 1
```
#### 输出
```
111
```

### 综合分析与结论
这些题解的核心思路都是避免直接枚举所有区间（因为 $O(n^2)$ 复杂度会超时），而是从每个数对答案的贡献角度来计算结果。主要通过记录每个数上一次出现的位置，来确定该数能对哪些区间产生贡献，进而计算出所有区间不同值个数的总和。

### 所选题解
- **作者：small_lemon_qwq (赞：20)，4星**
  - **关键亮点**：思路清晰，代码简洁，直接利用公式计算每个数的贡献，容易理解和实现。
  - **代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[200005],ans;
unordered_map<int,int>mp;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        ans+=(i-mp[a[i]])*(n-i+1);
        mp[a[i]]=i;
    }
    cout<<ans;
    return 0;
}
```
  - **核心实现思想**：设 $j$ 为满足 $a_j = a_i$ 且 $j < i$ 的最大值（若不存在为 $0$），那么 $a_i$ 的贡献就是 $(i - j)\times(n - i + 1)$，其中 $(i - j)$ 为左端点的可能数，$(n - i + 1)$ 为右端点的可能数。通过遍历数组，不断更新每个数上一次出现的位置，并累加每个数的贡献到答案中。

- **作者：_ayaka_ (赞：2)，4星**
  - **关键亮点**：将题目中的值形象地称为“颜色”，通过具体例子解释每个点的贡献计算方法，思路易懂。
  - **代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[200005],last[200005],ans;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>a[i];
        ans+=(n-i+1)*(i-last[a[i]]);
        last[a[i]]=i;//更新last
    }
    cout<<ans;
}
```
  - **核心实现思想**：用 $last_i$ 表示第 $i$ 个颜色上次出现的下标，只要左端点在 $last_{a_i}+1$ 到 $i$ 之间，右端点在 $i$ 到 $n$ 之间，第 $i$ 个点就有贡献，其贡献为 $(n - i + 1)\times(i - last_{a_i})$，遍历数组计算并累加每个点的贡献。

- **作者：under_the_time (赞：0)，4星**
  - **关键亮点**：采用动态规划的思想，通过状态转移方程从 $g(i - 1)$ 转移到 $g(i)$ 来计算答案，思路新颖。
  - **代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
int a[maxn], g[maxn], n;
#define ll long long
ll f[maxn];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
        scanf("%d", &a[i]);
    f[1] = 1, g[a[1]] = 1; ll ans = f[1];
    for (int i = 2; i <= n; i ++) 
        f[i] = f[i - 1] + i - g[a[i]], g[a[i]] = i, ans += f[i];
    return printf("%lld\n", ans), 0;
}
```
  - **核心实现思想**：令 $g(i)$ 表示 $\sum_{j\le i} f(j,i)$ 的值，用一个数组记录每个值最近一次出现的位置。对于 $i$，它的值有贡献当且仅当 $j\in (t_{a_i},i]$，这样的区间有 $i - t_{a_i}$ 个，状态转移方程为 $g(i)=g(i - 1)+i - t_{a_i}$，边转移边更新记录位置的数组，答案取 $\sum g(i)$。

### 最优关键思路或技巧
- **转换思维**：从直接枚举所有区间计算不同值个数，转换为考虑每个数对答案的贡献，大大降低了时间复杂度。
- **记录位置**：通过记录每个数上一次出现的位置，能准确确定该数对哪些区间有贡献，避免重复计算。

### 可拓展之处
同类型题可能会有不同的约束条件或问题变种，例如序列元素范围变化、对区间的定义变化等。类似算法套路可以应用在求区间内不同元素相关的问题中，如求区间内不同元素的最大/最小数量等。

### 推荐洛谷题目
- [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)
- [P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)
- [P2468 [SDOI2010] 粟粟的书架](https://www.luogu.com.cn/problem/P2468)

### 个人心得摘录与总结
- **作者：__Allen_123__**：回忆了自己作为 OIer 的经历，有攻克难题的快乐，也有失败的悲伤，感慨 OI 的发展和自己的无奈。
- **作者：csgpx**：赛时把 `v[i]` 打成 `v[a[i]]`，赛后一分钟才通过，提醒我们编程时要仔细检查代码。
- **作者：Orange_qwq**：赛时没想出来，感叹自己智力堪忧，说明在竞赛中可能会遇到思路受阻的情况，需要不断提高自己的思维能力。 

---
处理用时：43.15秒
# 题目信息

# [ABC034C] 経路

## 题目描述

有一个 $W$ 行 $H$ 列的网格图（$2 \leq W,H \leq 10^5$），其中第 $i$ 行第 $j$ 列的坐标为 $(i,j)$。

现在有一个人想从起点 $(1,1)$ 走到终点 $(W,H)$，已知他每次可以从网格 $(i,j)$ 走向 $(i+1,j)$ 或 $(i,j+1)$。现在请你求出，他从起点走到终点的路线个数为多少。

由于这个数可能很大，因此你只要输出路线个数对 $10^9 + 7$ 取模的结果即可。

## 样例 #1

### 输入

```
4 3```

### 输出

```
10```

## 样例 #2

### 输入

```
123 456```

### 输出

```
210368064```

# AI分析结果

### 题目翻译
有一个 $W$ 行 $H$ 列的网格图（$2 \leq W,H \leq 10^5$），其中第 $i$ 行第 $j$ 列的坐标为 $(i,j)$。

现在有一个人想从起点 $(1,1)$ 走到终点 $(W,H)$，已知他每次可以从网格 $(i,j)$ 走向 $(i+1,j)$ 或 $(i,j+1)$。现在请你求出，他从起点走到终点的路线个数为多少。

由于这个数可能很大，因此你只要输出路线个数对 $10^9 + 7$ 取模的结果即可。

### 综合分析与结论
这些题解思路基本一致，都是将从 $(1,1)$ 走到 $(W,H)$ 的路径问题转化为组合数学问题。从起点到终点需走 $W + H - 2$ 步，其中向下走 $W - 1$ 步（或向右走 $H - 1$ 步），所以总方案数为 $C_{W + H - 2}^{W - 1}$（或 $C_{W + H - 2}^{H - 1}$）。在计算组合数时，由于涉及除法取模，都使用了乘法逆元来解决。

### 题解选择
- **残阳如血（5星）**
    - **关键亮点**：思路清晰，详细解释了组合数的推导过程，并给出了逆元的学习链接；代码结构清晰，注释明确。
    - **核心代码**：
```cpp
const int N = 2e5 + 10;
const int MOD = 1e9 + 7;
lint n, m, inv[N], fact[N], inv_fact[N];

void init() {
    inv[0] = inv[1] = 1;
    for (int i = 2; i < N; ++i)
        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
    fact[0] = inv_fact[0] = 1;
    for (int i = 1; i < N; ++i) {
        fact[i] = fact[i - 1] * i % MOD;
        inv_fact[i] = inv_fact[i - 1] * inv[i] % MOD;
    }
}

lint C(int n, int m) {
    if (m > n) return 0;
    if (m == n) return 1;
    return fact[n] * inv_fact[m] % MOD * inv_fact[n - m] % MOD;
}
```
    - **核心思想**：先预处理出 $1$ 到 $N$ 每个数的逆元、阶乘及其逆元，然后根据组合数公式 $C_{n}^{m}=\frac{n!}{m!(n - m)!}\equiv n! (m!)^{-1}((n - m)!)^{-1} \pmod{MOD}$ 计算组合数。
- **jzjr（4星）**
    - **关键亮点**：详细解释了逆元的概念和费马小定理求逆元的方法；代码简洁，易于理解。
    - **核心代码**：
```cpp
LL jc[200005],ni[200005],mod=1e9+7;
LL H,W;

LL ksm(LL x,LL y,LL mod){
    LL ans=1;
    while(y){
        if(y&1)ans=ans*x%mod;
        x=x*x%mod;y=y>>1;
    }
    return ans;
}

void asd(){
    int tot=W+H;
    jc[0]=ni[0]=1;
    for(LL i=1;i<=tot;i++)jc[i]=jc[i-1]*i%mod;
    ni[tot]=ksm(jc[tot],mod-2,mod);
    for(int i=tot-1;i>0;i--)ni[i]=ni[i+1]*(i+1)%mod;
}

LL C(LL n,LL m){
    return jc[n]*ni[m]%mod*ni[n-m]%mod;
}
```
    - **核心思想**：先预处理出阶乘数组 `jc`，然后用快速幂求出最大阶乘的逆元，再递推求出其他阶乘的逆元，最后根据组合数公式计算结果。
- **zjinze（4星）**
    - **关键亮点**：思路简洁明了，代码实现规范；使用快速幂求逆元。
    - **核心代码**：
```cpp
const int mod=1e9+7;
const int N=2e5+7;
int n,m,jc[N],inv[N];

int ksm(int a,int b){
    int tmp=1;
    a%=mod;
    while(b){
        if(b&1){
            tmp=tmp*a;
            tmp%=mod;
        }
        a*=a;
        a%=mod;
        b>>=1;
    }
    return tmp;
}

int C(int m,int n){
    return (((jc[n]*inv[m])%mod)*inv[n-m])%mod;
}
```
    - **核心思想**：预处理阶乘数组 `jc` 和阶乘的逆元数组 `inv`，利用快速幂求逆元，最后根据组合数公式计算结果。

### 最优关键思路或技巧
- **组合数学转化**：将网格路径问题转化为组合数问题，大大降低了问题的复杂度。
- **乘法逆元**：在处理组合数公式中的除法取模时，使用乘法逆元将除法转化为乘法，避免了直接除法取模的错误。

### 拓展思路
同类型题或类似算法套路：
- 网格图中添加障碍物，求从起点到终点的路径数，可在组合数学基础上结合容斥原理求解。
- 改变移动规则，如可以斜着走，可使用动态规划或更复杂的组合数学方法求解。

### 推荐题目
- [P1044 栈](https://www.luogu.com.cn/problem/P1044)：考察卡特兰数，与组合数学相关。
- [P1641 生成字符串](https://www.luogu.com.cn/problem/P1641)：涉及组合数和逆元的应用。
- [P2679 子串](https://www.luogu.com.cn/problem/P2679)：结合了动态规划和组合数学的知识。

### 个人心得
题解中未包含个人心得内容。

---
处理用时：36.84秒
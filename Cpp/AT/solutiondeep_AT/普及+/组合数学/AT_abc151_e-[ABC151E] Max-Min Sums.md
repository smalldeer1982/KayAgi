# 题目信息

# [ABC151E] Max-Min Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc151/tasks/abc151_e

有限個の整数からなる集合 $ X $ に対し $ f(X)=\max\ X\ -\ \min\ X $ と定義します。

$ N $ 個の整数 $ A_1,...,A_N $ が与えられます。

このうち $ K $ 個を選び、それらからなる集合を $ S $ とします。同じ値であっても添字が異なる要素を区別すると、そのような選び方は $ {}_N\ C_K $ 通りありますが、その全てについての $ f(S) $ の合計を求めてください。

答えは非常に大きくなる可能性があるので、$ \bmod\ 10^9+7 $ で出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

$ S $ の選び方は $ \{1,1\},\{1,3\},\{1,4\},\{1,3\},\{1,4\},\{3,4\} $ の $ 6 $ 通りあり (ふたつの $ 1 $ は区別します)、$ f(S) $ はそれぞれ $ 0,2,3,2,3,1 $ となるので、合計は $ 11 $ です。

### Sample Explanation 2

$ S $ の選び方は $ 20 $ 通りあり、そのうち $ 18 $ 通りで $ f(S)=20 $、$ 2 $ 通りで $ f(S)=0 $ となります。

### Sample Explanation 4

合計は $ \bmod\ 10^9+7 $ で出力してください。

## 样例 #1

### 输入

```
4 2

1 1 3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
6 3

10 10 10 -10 -10 -10```

### 输出

```
360```

## 样例 #3

### 输入

```
3 1

1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 6

1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0```

### 输出

```
999998537```

# AI分析结果

### 题目翻译
#### [ABC151E] 最大 - 最小和

##### 题目描述
对于由有限个整数组成的集合 $X$，定义 $f(X) = \max\ X - \min\ X$。

给定 $N$ 个整数 $A_1, \cdots, A_N$。

从中选取 $K$ 个整数，设这些整数组成的集合为 $S$。即使值相同，但只要下标不同的元素也视为不同元素，这样的选取方式共有 $ {}_N\ C_K $ 种。请计算所有这些选取方式下 $f(S)$ 的总和。

由于答案可能非常大，请对 $10^9 + 7$ 取模后输出。

##### 说明/提示
- **限制条件**
  - $1 \leq N \leq 10^5$
  - $1 \leq K \leq N$
  - $|A_i| \leq 10^9$
- **样例解释 1**
$S$ 的选取方式有 $\{1, 1\}, \{1, 3\}, \{1, 4\}, \{1, 3\}, \{1, 4\}, \{3, 4\}$ 共 $6$ 种（两个 $1$ 视为不同元素），对应的 $f(S)$ 分别为 $0, 2, 3, 2, 3, 1$，因此总和为 $11$。
- **样例解释 2**
$S$ 的选取方式有 $20$ 种，其中 $18$ 种情况下 $f(S) = 20$，$2$ 种情况下 $f(S) = 0$。
- **样例解释 4**
请对答案取模 $10^9 + 7$ 后输出。

##### 样例
- **样例 #1**
  - **输入**
```
4 2
1 1 3 4
```
  - **输出**
```
11
```
- **样例 #2**
  - **输入**
```
6 3
10 10 10 -10 -10 -10
```
  - **输出**
```
360
```
- **样例 #3**
  - **输入**
```
3 1
1 1 1
```
  - **输出**
```
0
```
- **样例 #4**
  - **输入**
```
10 6
1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0
```
  - **输出**
```
999998537
```

### 综合分析与结论
这些题解的核心思路基本一致，都是通过排序后分别计算每个数作为最大值和最小值的贡献，再相减得到结果。算法要点在于利用组合数计算每个数成为最大值或最小值的方案数，同时使用逆元来处理组合数取模问题。解决的难点主要是组合数的计算和取模运算，以及避免负数取模带来的错误。

### 所选题解
- **作者：TonyYin（5星）**
  - **关键亮点**：思路清晰，详细解释了如何计算每个数作为最大值和最小值的次数，代码规范且有注释，还提供了逆元求组合数的博客链接。
  - **核心代码**
```cpp
for(int i = k; i <= n; i++) { //算一遍最大值
    ans = (ans + a[i] * C(i - 1, k - 1) % mod) % mod;
}
for(int i = 1; i <= n - k + 1; i++) { //算一遍最小值
    ans = (ans - a[i] * C(n - i, k - 1) % mod) % mod;
}
```
核心实现思想：先对数组排序，然后遍历数组，对于每个数，计算它作为最大值和最小值的贡献并累加到答案中。

- **作者：_determination_（4星）**
  - **关键亮点**：思路简洁明了，代码结构清晰，注释丰富，方便理解。
  - **核心代码**
```cpp
for ( int i = m ; i <= n ; i++ )
{
    ans1=(ans1+c(i-1,m-1)*a[i]%mod)%mod;
}
for ( int i = 1 ; i <= n-m+1 ; i++ )
{
    ans2=(ans2+c(n-i,m-1)*a[i]%mod)%mod;
}
cout << (ans1-ans2+mod)%mod;
```
核心实现思想：分别计算每个数作为最大值和最小值的贡献，存储在 `ans1` 和 `ans2` 中，最后相减并取模输出。

- **作者：WaterSun（4星）**
  - **关键亮点**：使用宏定义简化取模运算，代码简洁高效，还提供了更好的阅读体验链接。
  - **核心代码**
```cpp
for (re int i = 1;i <= n;i++){
    a = Add(a,Mul(C(n - i,k - 1),arr[i]));
    b = Add(b,Mul(C(i - 1,k - 1),arr[i]));
}
printf("%lld",Sub(b,a));
```
核心实现思想：遍历数组，同时计算每个数作为最大值和最小值的贡献，最后相减并取模输出。

### 最优关键思路或技巧
- **思维方式**：利用集合的无序性，将问题转化为计算每个数作为最大值和最小值的贡献，避免了暴力枚举子集的高复杂度。
- **算法优化**：使用逆元来计算组合数取模，避免了除法运算带来的精度问题。
- **代码实现技巧**：使用宏定义简化取模运算，提高代码的可读性和可维护性。

### 可拓展之处
同类型题目可能会改变集合的选取规则或函数 $f(X)$ 的定义，但核心思路仍然是分析每个元素的贡献。类似的算法套路包括排序后利用组合数计算方案数，以及处理取模运算。

### 洛谷推荐题目
- [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)：考察组合数和快速幂取模。
- [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)：需要分析元素的贡献并结合组合数计算。
- [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)：涉及组合数学和容斥原理。

### 个人心得
无。

---
处理用时：36.93秒
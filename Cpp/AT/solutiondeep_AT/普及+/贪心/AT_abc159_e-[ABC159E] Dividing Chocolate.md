# 题目信息

# [ABC159E] Dividing Chocolate

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc159/tasks/abc159_e

縦 $ H $ マス、横 $ W $ マスのグリッドに区切られたチョコレートがあります。

上から $ i $ 行目、左から $ j $ 列目にあるマス $ (i,j) $ のチョコレートは、$ S_{i,j} $ が `0` のとき普通のチョコレートであり、`1` のときホワイトチョコレートです。

このチョコレートに対して、マスの境界に沿った直線によってグリッド全体の端から端まで割る操作を何度か行い、いくつかのブロックに分割します。

分割後のどのブロックにもホワイトチョコレートのマスが $ K $ マス以下しか含まれないようにするためには、最小で操作を何回行う必要があるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 10 $
- $ 1\ \leq\ W\ \leq\ 1000 $
- $ 1\ \leq\ K\ \leq\ H\ \times\ W $
- $ S_{i,j} $ は `0` か `1`

### Sample Explanation 1

例えば左の図のように $ 1 $ 行目と $ 2 $ 行目の間と、$ 3 $ 列目と $ 4 $ 列目の間の $ 2 $ か所で割ればよいです。 右の2つの図のような割り方はできないことに注意してください。 !\[図\](https://img.atcoder.jp/ghi/ac90dd542639c04402125403b1c319d7.png)

### Sample Explanation 2

操作を行う必要はありません。

## 样例 #1

### 输入

```
3 5 4

11100

10001

00111```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5 8

11100

10001

00111```

### 输出

```
0```

## 样例 #3

### 输入

```
4 10 4

1110010010

1000101110

0011101001

1101000111```

### 输出

```
3```

# AI分析结果

### 题目翻译

有一个 $H \times W$ 的矩阵，切若干次，使得每一块中 $1$ 的个数 $\leq K$，只能一切到底，问最少用几刀。

### 题目思路

直接暴力枚举每一行每一列绝对不行，复杂度 $\mathcal O(2^{H+W})$。

我们发现 $H$ 很小，我们可以枚举 $H$ 在哪里切割，复杂度 $\mathcal O(2^H)$。其实最多只有 $H-1$ 刀，为了方便描述，统一用 $H$。

接着，我们对于 $W$ 考虑贪心，每一块有尽量多的 $1$，最后肯定花费最小，也是可以证明的。

综上所述，我们枚举 $2^H$ 种方案，接着扫一遍 $W$ 确定切割次数。

时间复杂度 $\mathcal O(2^H \times W \times H)$，可以通过此题。

但是还不完美，如果 $H \leq 15, W \leq 10^6$，明显是会炸掉的。

我们扫 $W$ 时，这里 $1$ 的个数肯定是单调不增的，可以考虑进行二分或者倍增来找。这一段的时间复杂度一下子变成了 $\mathcal O(\log W)$，总时间复杂度 $\mathcal O(2^H \times \log W \times H)$。

但上述做法在面对全是 $1$ 时，每次只能前进一步，实际上会退化成 $\mathcal O(W)$。其余数据效果比最初做法时间上较佳。

### 样例解释

例如左图所示，$1$ 行目和 $2$ 行目之间，以及 $3$ 列目和 $4$ 列目之间的 $2$ 处切割即可。右图所示的切割方式不可行。

### 样例输入输出

#### 样例 1

输入：
```
3 5 4

11100

10001

00111
```
输出：
```
2
```

#### 样例 2

输入：
```
3 5 8

11100

10001

00111
```
输出：
```
0
```

#### 样例 3

输入：
```
4 10 4

1110010010

1000101110

0011101001

1101000111
```
输出：
```
3
```

---

### 题解分析与结论

#### 综合分析与结论

本题的核心思路是利用 $H$ 的范围较小（$H \leq 10$），通过二进制枚举所有可能的横向切割方式，然后对每种切割方式贪心地处理纵向切割。由于 $W$ 的范围较大（$W \leq 1000$），纵向切割的处理需要高效，通常使用前缀和来快速计算每个区域的 $1$ 的个数。

#### 关键思路与技巧

1. **二进制枚举**：由于 $H$ 的范围较小，可以通过二进制枚举所有可能的横向切割方式。
2. **贪心算法**：对于每种横向切割方式，从左到右贪心地处理纵向切割，确保每个区域的 $1$ 的个数不超过 $K$。
3. **前缀和优化**：使用二维前缀和快速计算每个区域的 $1$ 的个数，避免重复计算。

#### 可拓展之处

- **二分或倍增优化**：在处理纵向切割时，可以通过二分或倍增来进一步优化时间复杂度，尤其是在 $W$ 较大时。
- **动态规划**：可以考虑使用动态规划来优化某些特殊情况，例如当 $H$ 较大时。

#### 推荐题目

1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 [NOIP2006 提高组] 开心的金明](https://www.luogu.com.cn/problem/P1060)

#### 个人心得摘录

- **调试经历**：在枚举横向切割时，需要注意切割的位置是否合法，避免出现无效切割。
- **踩坑教训**：在处理纵向切割时，如果某一列的 $1$ 的个数已经超过 $K$，则该切割方式无效，需要及时跳过。
- **顿悟感想**：通过二进制枚举和贪心算法的结合，可以有效地解决此类组合优化问题。

---

### 精选题解

#### 题解1：banned_xiejiayun (4星)

**关键亮点**：
- 使用二进制枚举横向切割，贪心处理纵向切割。
- 代码清晰，逻辑严谨，时间复杂度分析准确。

**核心代码**：
```cpp
int cnt(){
	int _ans=0;
	int tot=1;
	for(int i=1;i<=m;i++){
		int check=0;
		for(int j=1;j<=n;j++){
			check+=s[j][i]-s[j][tot-1];
			if(tot==i&&check>k){
				return 0x7ffffff;
			}
			if(check>k){
				_ans++;
				tot=i;
				check=0;
			}
			if(flag[j]){
				check=0;
			}
		}
	}
	return _ans;
}
```

#### 题解2：lihongqian__int128 (4星)

**关键亮点**：
- 使用二维前缀和优化计算，贪心处理纵向切割。
- 代码结构清晰，时间复杂度分析准确。

**核心代码**：
```cpp
void dfs(int step , int sum)
{
    if(step == h)
    {
    	p[h] = 1 ;
        int lw = 0 ;
        int cnt = 0 ;
        for(int j = 1 ; j <= w ; j++)
        {
        	int lr = 0 ;
            for(int i = 1 ; i <= h ; i++)
            {
                if(p[i])
                {
			int c = s[i][j] - s[i][lw] - s[lr][j] + s[lr][lw] ;
			if(c > k)
			{
				if(j == lw + 1)	return ;
				else
				{
					cnt++ ;
					lw = j - 1 ;
					break ;
				}
			}
			lr = i ;
		}
            }
        }
        minn = min(minn , cnt + sum) ;
        return ;
    }
    p[step] = 1 ;
    dfs(step + 1 , sum + 1) ;
    p[step] = 0 ;
    dfs(step + 1 , sum) ;
}
```

#### 题解3：ctq1999 (4星)

**关键亮点**：
- 使用二进制枚举横向切割，贪心处理纵向切割。
- 代码结构清晰，时间复杂度分析准确。

**核心代码**：
```cpp
int count(int sta) {
	memset(b, 0, sizeof(b));
	memset(s, 0, sizeof(s));
	int now = 1, res = 0;
	for (int i = 0; i < n; i++) {
		b[i + 1] = now;
		if ((sta >> i) & 1) ++now;
	}
	
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) s[b[j]] += a[j][i];
		bool f = 1;
		for (int j = 1; j <= n; j++)
			if (s[b[j]] > k) {
				res++;
				f = 0;
				break;
			}
		if (!f) {
			memset(s, 0, sizeof(s));
			for (int j = 1; j <= n; j++) {
				s[b[j]] += a[j][i];
				if (s[b[j]] > k) return n + m;
			}	
		}
	}
	return res;
}
```

---

### 总结

本题的核心在于利用 $H$ 的范围较小，通过二进制枚举所有可能的横向切割方式，然后对每种切割方式贪心地处理纵向切割。使用前缀和优化可以快速计算每个区域的 $1$ 的个数，确保算法的高效性。

---
处理用时：61.81秒
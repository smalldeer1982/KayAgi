# 题目信息

# [ABC252F] Bread

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc252/tasks/abc252_f

長さ $ L $ のパンが $ 1 $ つあり、これを $ N $ 人の子供たちに切り分けます。 $ i $ 番目 $ (1\leq\ i\leq\ N) $ の子供は長さ $ A_i $ のパンを欲しがっています。

そこで、高橋君は次の操作を繰り返して、長さ $ A_1,A_2,\ldots,A_N $ のパンを切り出して配ることにしました。

> 長さ $ k $ のパン $ 1 $ つと $ 1 $ 以上 $ k-1 $ 以下の整数 $ x $ を選ぶ。選んだパンを長さ $ x $ のパンと 長さ $ k-x $ のパンに切り分ける。   
> このとき、$ x $ の値によらずコストが $ k $ かかる。

それぞれの子供に配るパンは長さがちょうど $ A_i $ のパン $ 1 $ つである必要がありますが、誰にも配られずに余るパンがいくつあっても構いません。

このとき、全ての子供たちにパンを配るために必要な最小のコストを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\leq\ 10^9 $
- $ A_1+A_2+\cdots+A_N\leq\ L\leq\ 10^{15} $
- 入力は全て整数

### Sample Explanation 1

高橋君は次のようにしてパンを切り分けて配ることができます。 - 長さ $ 7 $ のパンと整数 $ x=3 $ を選ぶ。パンは長さ $ 3 $ のパンと長さ $ 4 $ のパンに切り分けられる。 (コスト $ 7 $ ) - 長さ $ 3 $ のパンと整数 $ x=1 $ を選ぶ。パンは長さ $ 1 $ のパンと長さ $ 2 $ のパンに切り分けられる。前者を $ 1 $ 番目の子供に配る。 (コスト $ 3 $ ) - 長さ $ 2 $ のパンと整数 $ x=1 $ を選ぶ。パンは長さ $ 1 $ のパン $ 2 $ つに切り分けられる。これを $ 3,5 $ 番目の子供に配る。 (コスト $ 2 $ ) - 長さ $ 4 $ のパンと整数 $ x=2 $ を選ぶ。パンは長さ $ 2 $ のパン $ 2 $ つに切り分けられる。これを $ 2,4 $ 番目の子供に配る。 (コスト $ 4 $ ) このとき、コストは $ 7+3+2+4=16 $ かかり、これが最小です。 また、余るパンはありません。

### Sample Explanation 2

それぞれの子供に配るパンの長さはちょうど $ A_i $ でなければならない事に注意してください。

## 样例 #1

### 输入

```
5 7
1 2 1 2 1```

### 输出

```
16```

## 样例 #2

### 输入

```
3 1000000000000000
1000000000 1000000000 1000000000```

### 输出

```
1000005000000000```

# AI分析结果

### 题目内容重写

**题目描述**

有一根长度为 $L$ 的面包，需要将其切成 $N$ 块分给 $N$ 个孩子。第 $i$ 个孩子需要一块长度为 $A_i$ 的面包。每次切割操作可以选择一块长度为 $k$ 的面包，并将其切成长度为 $x$ 和 $k-x$ 的两块，切割的代价为 $k$。要求每个孩子分到的面包长度必须恰好为 $A_i$，但允许有剩余的面包。求将所有面包分给孩子们的最小总代价。

**说明/提示**

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq A_i \leq 10^9$
- $A_1 + A_2 + \cdots + A_N \leq L \leq 10^{15}$
- 输入均为整数

### 题解分析与结论

本题的核心思路是将切割操作转化为合并操作，利用贪心策略每次合并最小的两块面包，从而最小化总代价。所有题解均采用了这一思路，并使用了优先队列（小根堆）来实现。以下是各题解的要点总结：

1. **逆向思维**：将切割操作转化为合并操作，每次合并两块面包的代价为它们的长度之和。
2. **贪心策略**：每次选择最小的两块面包进行合并，确保总代价最小。
3. **剩余面包处理**：如果总长度 $L$ 大于所有孩子需求的总和，将剩余的面包也视为一块需要合并的面包。

### 评分较高的题解

#### 题解1：作者：沉石鱼惊旋 (赞：7)
**星级：5星**
**关键亮点**：
- 思路清晰，直接将问题转化为合并果子的经典问题。
- 代码简洁，使用了 `multiset` 来实现优先队列，逻辑清晰。

**核心代码**：
```cpp
multiset<long long>s;
long long n,l,ss=0;
cin>>n>>l;
for(int i=1;i<=n;i++) {
    long long x;
    cin>>x;
    s.insert(x);
    ss+=x;
}
if(l-ss!=0)s.insert(l-ss);
long long sum=0;    
while(s.size()>1) {
    long long x=*s.begin();
    s.erase(s.begin());
    long long y=*s.begin();
    s.erase(s.begin());
    s.insert(x+y);
    sum+=x+y;
}
cout<<sum<<endl;
```

#### 题解2：作者：fish_love_cat (赞：3)
**星级：4星**
**关键亮点**：
- 详细解释了贪心策略的证明过程，帮助理解为何每次合并最小的两块面包是最优的。
- 使用了 `priority_queue` 来实现小根堆，代码可读性高。

**核心代码**：
```cpp
priority_queue<long long,vector<long long>,greater<long long> >q;
long long ans;
int main(){
    long long n,f;
    cin>>n>>f;
    for(long long i=0;i<n;i++){
        long long s;
        cin>>s;
        f-=s;
        q.push(s);
    }
    if(f!=0){
        q.push(f);
        n++;
    }
    for(long long i=1;i<n;i++){
        long long sum=0;
        sum+=q.top();
        q.pop();
        sum+=q.top();
        q.pop();
        q.push(sum);
        ans+=sum;
    }
    cout<<ans;
    return 0;
}
```

#### 题解3：作者：_dijkstra_ (赞：0)
**星级：4星**
**关键亮点**：
- 思路简洁明了，直接类比合并果子问题。
- 代码实现简洁，使用了 `priority_queue` 并处理了剩余面包的情况。

**核心代码**：
```cpp
priority_queue <ll, vector <ll>, greater <ll> > q;
int n;
ll sum, ans = 0;
scanf("%d%lld", &n, &sum);
for (int i = 1; i <= n; i++) {
    int x; scanf("%d", &x);
    q.push(x), sum -= x;
}
if (sum != 0) q.push(sum);
while (q.size() != 1) {
    ll u = q.top(); q.pop();
    ll v = q.top(); q.pop();
    ans += (u + v), q.push(u + v);
}
cout << ans;
```

### 最优关键思路与技巧

1. **逆向思维**：将切割问题转化为合并问题，简化了问题的复杂度。
2. **贪心策略**：每次合并最小的两块面包，确保总代价最小。
3. **优先队列**：使用小根堆（`priority_queue` 或 `multiset`）来高效地获取和合并最小的两块面包。

### 可拓展之处

本题的贪心策略与合并果子问题（P1090）非常相似，都是通过每次合并最小的两个元素来最小化总代价。类似的问题还有 Huffman 编码、最小生成树等，都可以通过类似的贪心策略来解决。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1334 瑞瑞的木板](https://www.luogu.com.cn/problem/P1334)
3. [P2168 [NOI2015] 荷马史诗](https://www.luogu.com.cn/problem/P2168)

---
处理用时：43.20秒
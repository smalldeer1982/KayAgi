# 题目信息

# [ABC281F] Xor Minimization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc281/tasks/abc281_f

非負整数列 $ A=(a_1,\ldots,a_N) $ が与えられます。

$ A $ に対して次の操作をちょうど $ 1 $ 回行います。

- 非負整数 $ x $ を選ぶ。そして、$ i=1,\ldots,N $ すべてに対し、$ a_i $ の値を「$ a_i $ と $ x $ のビット単位 xor」に置き換える。
 
操作後の $ A $ に含まれる値の最大値を $ M $ とします。$ M $ の最小値を求めてください。

 ビット単位 xor とは 非負整数 $ A,\ B $ のビット単位 xor 、$ A\ \oplus\ B $ は、以下のように定義されます。 - $ A\ \oplus\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。

 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \oplus\ 101\ =\ 110 $)。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1.5\ \times\ 10^5 $
- $ 0\ \leq\ a_i\ \lt\ 2^{30} $
- 入力はすべて整数
 
### Sample Explanation 1

$ x=2 $ として操作をすると、操作後の数列は $ (12\ \oplus\ 2,18\ \oplus\ 2,\ 11\ \oplus\ 2)\ =\ (14,16,9) $ となり、最大値 $ M $ は $ 16 $ となります。 $ M $ を $ 16 $ より小さくすることは出来ないため、この値が答えです。

## 样例 #1

### 输入

```
3

12 18 11```

### 输出

```
16```

## 样例 #2

### 输入

```
10

0 0 0 0 0 0 0 0 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
5

324097321 555675086 304655177 991244276 9980291```

### 输出

```
805306368```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个非负整数序列 $A=(a_1,\ldots,a_N)$，对 $A$ 执行以下操作恰好一次：

- 选择一个非负整数 $x$，然后将 $A$ 中的每个元素 $a_i$ 替换为 $a_i$ 与 $x$ 的按位异或值。

操作后，$A$ 中的最大值记为 $M$，求 $M$ 的最小值。

**说明/提示**

- 按位异或的定义：对于非负整数 $A$ 和 $B$，$A \oplus B$ 的二进制表示中，第 $k$ 位为 $1$ 当且仅当 $A$ 和 $B$ 的第 $k$ 位不同。
- 例如，$3 \oplus 5 = 6$（二进制：$011 \oplus 101 = 110$）。

**输入输出样例**

**样例 #1**

输入：
```
3
12 18 11
```
输出：
```
16
```

**样例 #2**

输入：
```
10
0 0 0 0 0 0 0 0 0 0
```
输出：
```
0
```

**样例 #3**

输入：
```
5
324097321 555675086 304655177 991244276 9980291
```
输出：
```
805306368
```

### 题解综合分析

该题目要求通过选择 $x$ 使得序列 $A$ 中所有元素与 $x$ 异或后的最大值最小。由于按位异或的性质，我们可以从高位到低位逐位考虑，通过分治或 Trie 树等数据结构来优化搜索过程。

### 所选高星题解

#### 题解1：Zhaohongrui (5星)

**关键亮点：**
- 使用 Trie 树来存储和处理每个数的二进制位，从高位到低位进行递归查询。
- 通过 Trie 树的节点信息，快速判断当前位是否可以通过异或操作变为 $0$，从而减少搜索空间。
- 代码简洁，逻辑清晰，时间复杂度为 $O(n \log a)$，适合大规模数据处理。

**核心代码：**
```cpp
int query(int x, int dep) {
    if (!son[x][0] && !son[x][1]) return 0;
    if (!son[x][0]) return query(son[x][1], dep - 1);
    if (!son[x][1]) return query(son[x][0], dep - 1);
    return min(query(son[x][0], dep - 1), query(son[x][1], dep - 1)) | 1 << dep;
}
```

**个人心得：**
- 通过 Trie 树的结构，可以有效地减少递归深度，避免重复计算，提升算法效率。

#### 题解2：EternalHeart1314 (4星)

**关键亮点：**
- 从高位到低位逐位考虑，通过分治策略将问题分解为子问题。
- 使用 vector 存储当前需要考虑的数，根据当前位的值进行分组，递归求解。
- 代码实现较为直观，适合理解分治思想的初学者。

**核心代码：**
```cpp
int dfs(VI a, int bit) {
    if (!bit) return 0;
    VI b, c;
    for (auto i : a) {
        if (i >> bit & 1) b.push_back(i);
        else c.push_back(i);
    }
    if (b.empty()) return dfs(c, bit - 1);
    if (c.empty()) return dfs(b, bit - 1);
    return min(dfs(b, bit - 1), dfs(c, bit - 1)) + (1 << bit);
}
```

**个人心得：**
- 通过分治策略，将问题分解为更小的子问题，简化了问题的复杂度，适合处理大规模数据。

#### 题解3：linch (4星)

**关键亮点：**
- 使用贪心策略，从高位到低位逐位考虑，通过递归处理当前位的不同情况。
- 通过排序和二分查找，优化了分治过程中的搜索效率。
- 代码实现较为简洁，适合理解贪心算法的应用。

**核心代码：**
```cpp
ll gao(int dep, vector<int> q) {
    if (dep < 0) return 0;
    int cnt[2] = {0};
    for (int i = 0; i < q.size(); ++i) cnt[q[i] >> dep & 1]++;
    if (!cnt[0] || !cnt[1]) return gao(dep - 1, q);
    vector<int> nex[2];
    for (int i = 0; i < q.size(); ++i) nex[q[i] >> dep & 1].push_back(q[i]);
    return (1 << dep) | min(gao(dep - 1, nex[0]), gao(dep - 1, nex[1]));
}
```

**个人心得：**
- 通过贪心策略，可以有效地减少搜索空间，提升算法效率，适合处理大规模数据。

### 最优关键思路与技巧

1. **从高位到低位逐位考虑**：由于高位对结果的影响更大，优先处理高位可以减少后续的计算量。
2. **分治策略**：将问题分解为子问题，通过递归处理每个子问题，最终合并结果。
3. **Trie 树的应用**：通过 Trie 树存储和处理每个数的二进制位，可以有效地减少搜索空间，提升算法效率。

### 可拓展之处

- 类似的问题可以通过分治、贪心或 Trie 树等数据结构来解决，例如最大异或对问题、最小异或值问题等。
- 可以进一步优化分治策略，结合动态规划或其他优化技术，提升算法效率。

### 推荐相似题目

1. [P4735 最大异或对](https://www.luogu.com.cn/problem/P4735)
2. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)
3. [P4592 [TJOI2018]异或](https://www.luogu.com.cn/problem/P4592)

---
处理用时：53.94秒
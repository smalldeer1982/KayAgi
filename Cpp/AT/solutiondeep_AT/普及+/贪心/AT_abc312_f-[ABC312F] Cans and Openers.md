# 题目信息

# [ABC312F] Cans and Openers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc312/tasks/abc312_f

$ N $ 個の品物があります。  
 これらはそれぞれ、缶切りが不要な缶・缶切りが必要な缶・缶切りのいずれかです。  
 $ i $ 個目の品物は、整数の組 $ (T_i,\ X_i) $ により次のように表されます。

- $ T_i\ =\ 0 $ ならば、$ i $ 個目の品物は缶切りが不要な缶で、入手すると満足度 $ X_i $ を得る。
- $ T_i\ =\ 1 $ ならば、$ i $ 個目の品物は缶切りが必要な缶で、入手した上で缶切りを使うと満足度 $ X_i $ を得る。
- $ T_i\ =\ 2 $ ならば、$ i $ 個目の品物は缶切りで、$ X_i $ 個までの缶に対して使用できる。
 
$ N $ 個の品物から $ M $ 個を選んで入手するとき、得られる満足度の合計としてあり得る最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ T_i $ は $ 0,1,2 $ のいずれか
- $ 1\ \leq\ X_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ 1,\ 2,\ 5,\ 7 $ 個目の品物を入手し、$ 7 $ 個目の品物である缶切りを $ 5 $ 個目の品物に対して使用すると、満足度 $ 6\ +\ 6\ +\ 15\ =\ 27 $ を得ます。 満足度が $ 28 $ 以上になる品物の入手方法は存在しませんが、上記の例において $ 7 $ 個目の品物のかわりに $ 6 $ 個目の品物や $ 8 $ 個目の品物を選んでも満足度 $ 27 $ を得ることができます。

## 样例 #1

### 输入

```
8 4

0 6

0 6

1 3

1 5

1 15

2 1

2 10

2 100```

### 输出

```
27```

## 样例 #2

### 输入

```
5 5

1 5

1 5

1 5

1 5

1 5```

### 输出

```
0```

## 样例 #3

### 输入

```
12 6

2 2

0 1

0 9

1 3

1 5

1 3

0 4

2 1

1 8

2 1

0 1

0 4```

### 输出

```
30```

# AI分析结果

### 题目内容重写

【题目描述】

有 $N$ 个物品，每个物品是以下三种之一：

1. 缶切りが不要な缶（不需要开罐器的罐头）：获得 $X_i$ 的满满足度。
2. 缶切りが必要な缶（需要开罐器的罐头）：获得 $X_i$ 的满满足度，但需要使用开罐器。
3. 缶切り（开罐器）：可以打开最多 $X_i$ 个需要开罐器的罐头。

现在需要从这 $N$ 个物品中选择 $M$ 个，求可以获得的最大满满足度。

### 题解分析与结论

本题的核心在于如何合理地选择三种类型的物品，以最大化满满足度。由于物品之间存在依赖关系（需要开罐器的罐头必须与开罐器配对使用），因此需要综合考虑选择策略。

#### 关键思路与技巧

1. **分类处理**：将三种类型的物品分别存储，并按满满足度或开罐能力从大到小排序，便于后续贪心选择。
2. **前缀和优化**：通过计算前缀和，快速获取前 $k$ 个物品的总满满足度，减少重复计算。
3. **枚举与二分结合**：通过枚举某种类型物品的数量，结合二分查找确定其他类型物品的最优选择。
4. **贪心策略**：优先选择满满足度高的物品，确保每次选择都能带来最大的收益。

#### 最优题解推荐

1. **作者：elbissoPtImaerD (4星)**
   - **关键亮点**：通过枚举一种类型物品的数量，结合贪心策略和前缀和优化，实现高效求解。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i=m,x=-1,y=-1;~i;--i)
         cx(ans,(~x?a[1][x]:0)+(i?a[0][i-1]:0)),x+1<(~y?a[2][y]:-1)?x+1<a[1].size()?++x:7:y+1<a[2].size()?++y:7;
     ```
   - **实现思想**：枚举 $a_0$ 的长度，动态调整 $a_1$ 和 $a_2$ 的选择，确保每次选择都能最大化满满足度。

2. **作者：Engulf (4星)**
   - **关键亮点**：通过枚举普通罐头的数量，结合二分查找确定开罐器的最优选择，实现高效求解。代码结构清晰，细节处理到位。
   - **核心代码**：
     ```cpp
     for(int i = 0; i < b.size(); i++) {
         int l = 0, r = c.size() - 1, res = -1;
         while(l <= r) {
             int mid = l + r >> 1;
             if(c[mid] >= i + 1) res = mid, r = mid - 1;
             else l = mid + 1;
         }
         if(res == -1) continue;
         int remain = m - (i + 1) - (res + 1);
         if(remain >= 0)
             ans = max(ans, b[i] + (remain ? a[min((int)a.size() - 1, remain - 1)] : 0));
     }
     ```
   - **实现思想**：枚举普通罐头的数量，通过二分查找确定最少需要的开罐器数量，并计算剩余物品的满满足度。

3. **作者：FL_sleake (4星)**
   - **关键亮点**：通过枚举第2类物品的数量，结合前缀和和二分查找，实现高效求解。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i=0;i<=cnt1;i++){
         if(i>num2[cnt2]) continue;
         int it=lower_bound(num2+1,num2+cnt2+1,i)-num2;
         if(i==0) it=0;
         if(i+it>m) continue;
         int Max=min(m-i-it,cnt0);
         ans=max(ans,num1[i]+num0[Max]);
     }
     ```
   - **实现思想**：枚举第2类物品的数量，通过二分查找确定需要的开罐器数量，并计算剩余物品的满满足度。

### 可拓展之处

本题的解法可以拓展到类似的资源分配问题，如背包问题、任务调度问题等。通过分类处理、前缀和优化、枚举与二分结合等技巧，可以有效解决类似的优化问题。

### 推荐题目

1. **洛谷 P1048 [NOIP2005 普及组] 采药**：考察背包问题的基本解法。
2. **洛谷 P1064 [NOIP2006 提高组] 金明的预算方案**：考察资源分配与优化问题。
3. **洛谷 P2014 [CTSC1997] 选课**：考察树形DP与资源分配问题。

### 个人心得摘录

- **调试经历**：在枚举某种类型物品的数量时，需要注意边界条件的处理，避免越界或无效选择。
- **踩坑教训**：在计算前缀和时，确保数组下标从1开始，避免出现未定义行为。
- **顿悟感想**：通过枚举与二分结合，可以大大减少计算量，提高算法效率。

---
处理用时：42.46秒
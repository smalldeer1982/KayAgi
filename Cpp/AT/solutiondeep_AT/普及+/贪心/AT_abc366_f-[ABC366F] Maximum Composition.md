# 题目信息

# [ABC366F] Maximum Composition

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc366/tasks/abc366_f

$ N $ 個の一次関数 $ f_1,f_2,\ldots,f_N $ が与えられます。$ f_i(x)=A_i\ x+B_i $ です。

$ 1 $ 以上 $ N $ 以下の**相異なる** $ K $ 個の整数からなる長さ $ K $ の数列 $ p=(p_1,p_2,\ \ldots\ p_K) $ について、$ f_{p_1}(f_{p_2}(\ldots\ f_{p_K}(1)\ldots\ )) $ としてありえる最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^{5} $
- $ 1\ \leq\ K\ \leq\ \text{min}(N,10) $
- $ 1\ \leq\ A_i,B_i\ \leq\ 50 $ $ (1\ \leq\ i\ \leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

ありえるすべての $ p $ とそれに対応する $ f_{p_1}(f_{p_2}(1)) $ の値は以下の通りです。 - $ p=\ (\ 1,2\ ) $ : $ f_1(f_2(1))=15 $ - $ p=\ (\ 1,3\ ) $ : $ f_1(f_3(1))=15 $ - $ p=\ (\ 2,1\ ) $ : $ f_2(f_1(1))=10 $ - $ p=\ (\ 2,3\ ) $ : $ f_2(f_3(1))=11 $ - $ p=\ (\ 3,1\ ) $ : $ f_3(f_1(1))=22 $ - $ p=\ (\ 3,2\ ) $ : $ f_3(f_2(1))=26 $ よって、 $ 26 $ と出力します。

## 样例 #1

### 输入

```
3 2
2 3
1 5
4 2```

### 输出

```
26```

## 样例 #2

### 输入

```
10 3
48 40
34 22
24 37
45 40
48 31
49 44
45 40
44 6
35 22
39 28```

### 输出

```
216223```

# AI分析结果

### 题目内容重写
#### 题目描述
给定 $N$ 个一次函数 $f_1, f_2, \ldots, f_N$，其中 $f_i(x) = A_i x + B_i$。从这些函数中选择 $K$ 个不同的函数，构成一个长度为 $K$ 的序列 $p = (p_1, p_2, \ldots, p_K)$，求 $f_{p_1}(f_{p_2}(\ldots f_{p_K}(1) \ldots ))$ 的最大值。

#### 说明/提示
- **约束条件**：
  - $1 \leq N \leq 2 \times 10^5$
  - $1 \leq K \leq \min(N, 10)$
  - $1 \leq A_i, B_i \leq 50$（$1 \leq i \leq N$）
  - 输入均为整数

#### 样例输入
```
3 2
2 3
1 5
4 2
```

#### 样例输出
```
26
```

### 题解综合分析与结论
本题的核心在于如何选择 $K$ 个函数并确定它们的嵌套顺序，使得最终的计算结果最大。大多数题解都采用了**排序 + 动态规划**的思路，具体步骤如下：

1. **排序规则**：通过比较两个函数的嵌套顺序，推导出排序规则。具体来说，对于两个函数 $f_i$ 和 $f_j$，若 $A_i B_j + B_i < A_j B_i + B_j$，则 $f_i$ 应该嵌套在 $f_j$ 的内层。基于此，可以对所有函数进行排序。
2. **动态规划**：在排序后，使用动态规划来选择 $K$ 个函数。设 $dp_{i,j}$ 表示前 $i$ 个函数中选择 $j$ 个函数的最大值，转移方程为 $dp_{i,j} = \max(dp_{i-1,j}, dp_{i-1,j-1} \times A_i + B_i)$。

### 评分较高的题解
#### 1. 作者：lzyqwq (5星)
**关键亮点**：
- 详细推导了排序规则，并通过数学归纳法证明了其正确性。
- 使用动态规划进行状态转移，并优化了空间复杂度。
- 代码简洁且高效，时间复杂度为 $O(n(\log n + k))$。

**个人心得**：
- 通过观察和数学推导，发现了排序规则，并将其应用于动态规划中，最终解决了问题。

**核心代码**：
```cpp
sort(a + 1, a + n + 1, [](const Line &a, const Line &b) {
    return a.b * (b.a - 1) > b.b * (a.a - 1);
});
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] * a[i].a + a[i].b);
    }
}
```

#### 2. 作者：WerChange (4.5星)
**关键亮点**：
- 通过贪心思想推导出排序规则，并结合动态规划进行求解。
- 代码实现清晰，逻辑严谨，易于理解。

**核心代码**：
```cpp
sort(p + 1, p + n + 1, [](const func &a, const func &b) {
    return a.a * b.b + a.b < b.a * a.b + b.b;
});
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
        f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] * p[i].a + p[i].b);
    }
}
```

#### 3. 作者：cancan123456 (4星)
**关键亮点**：
- 提供了正统做法和乱搞做法，展示了不同的解题思路。
- 正统做法通过排序和动态规划解决问题，乱搞做法则通过启发式排序和状压 DP 实现。

**核心代码**：
```cpp
sort(line + 1, line + n + 1, [](const Line &a, const Line &b) {
    return a.b * (b.a - 1) > b.b * (a.a - 1);
});
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
        f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] * line[i].a + line[i].b);
    }
}
```

### 最优关键思路或技巧
1. **排序规则**：通过比较两个函数的嵌套顺序，推导出排序规则，确保嵌套顺序最优。
2. **动态规划**：在排序后，使用动态规划选择 $K$ 个函数，确保最终结果最大。
3. **空间优化**：通过滚动数组或前缀最大值优化，减少空间复杂度。

### 可拓展之处
- 类似的问题可以通过排序和动态规划的组合来解决，尤其是在需要选择子序列并确定顺序的情况下。
- 可以考虑将排序规则推广到其他类型的函数或更复杂的嵌套结构中。

### 推荐题目
1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1064 [NOIP2006 提高组] 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

---
处理用时：52.53秒
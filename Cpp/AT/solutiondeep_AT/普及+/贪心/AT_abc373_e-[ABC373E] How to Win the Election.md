# 题目信息

# [ABC373E] How to Win the Election

## 题目描述

现在正在举行一场选举，有 $N$ 位候选人，编号为 $1, 2, \ldots, N$。目前已经有 $K$ 张选票，其中一些已经被计入。

到目前为止，第 $i$ 位候选人已经获得了 $A_i$ 票。

在所有选票被计完后，如果某位候选人的得票数比他们多的候选人数少于 $M$，那么该候选人将被当选。可能会有多位候选人同时当选。

对于每个候选人，求出他们需要从剩余的选票中获得的最少票数，以确保无论其他候选人获得多少票，他们都能当选。

具体来说，对于每个 $i = 1, 2, \ldots, N$，解决以下问题：

确定是否存在一个非负整数 $X$，其不超过 $K - \displaystyle{\sum_{i=1}^{N}} A_i$，并满足以下条件。如果存在，找出满足条件的最小 $X$。

- 如果候选人 $i$ 获得了 $X$ 张额外选票，那么候选人 $i$ 将始终当选。

## 说明/提示

- $1 \leq M \leq N \leq 2 \times 10^5$。
- $1 \leq K \leq 10^{12}$。
- $0 \leq A_i \leq 10^{12}$。
- $\displaystyle{\sum_{i=1}^{N} A_i} \leq K$。

## 样例 #1

### 输入

```
5 2 16
3 1 4 1 5```

### 输出

```
2 -1 1 -1 0```

## 样例 #2

### 输入

```
12 1 570
81 62 17 5 5 86 15 7 79 26 6 28```

### 输出

```
79 89 111 117 117 74 112 116 80 107 117 106```

# AI分析结果

### 题目内容重写
现在正在举行一场选举，有 $N$ 位候选人，编号为 $1, 2, \ldots, N$。目前已经有 $K$ 张选票，其中一些已经被计入。

到目前为止，第 $i$ 位候选人已经获得了 $A_i$ 票。

在所有选票被计完后，如果某位候选人的得票数比他们多的候选人数少于 $M$，那么该候选人将被当选。可能会有多位候选人同时当选。

对于每个候选人，求出他们需要从剩余的选票中获得的最少票数，以确保无论其他候选人获得多少票，他们都能当选。

具体来说，对于每个 $i = 1, 2, \ldots, N$，解决以下问题：

确定是否存在一个非负整数 $X$，其不超过 $K - \displaystyle{\sum_{i=1}^{N}} A_i$，并满足以下条件。如果存在，找出满足条件的最小 $X$。

- 如果候选人 $i$ 获得了 $X$ 张额外选票，那么候选人 $i$ 将始终当选。

### 题解综合分析
本题的核心思路是通过二分答案来确定每个候选人需要的最小额外票数，确保他们能够当选。难点在于如何高效地检查某个候选人在获得额外票数后是否能够当选。大多数题解都采用了二分答案结合贪心的策略，通过排序和前缀和优化来快速计算所需票数。

### 精选题解

#### 题解1：作者：dayz_break404 (赞：10)
**星级：5星**
**关键亮点：**
- 使用二分答案结合贪心策略，通过排序和前缀和优化来快速计算所需票数。
- 详细解释了如何处理区间包含当前候选人的情况，确保计算正确。
- 代码清晰，逻辑严谨，处理了边界情况。

**核心代码：**
```cpp
inline int check(int id,ll mid){
    ll now=k-sum[n]-mid;
    int x=upper_bound(a+1,a+1+n,b[id]+mid)-a-1;
    int y=n-m+1;
    if(n==m) return 1;
    if(n-x>=m) return 0;
    if(a[y]>b[id]) return 1ll*(x-y+1)*(b[id]+mid+1)-(sum[x]-sum[y-1])>now;
    return 1ll*(x-y+1)*(b[id]+mid+1)-(sum[x]-sum[y-2]-b[id])>now;
}
```

#### 题解2：作者：SkyWave (赞：0)
**星级：4星**
**关键亮点：**
- 通过二分答案和前缀和优化，快速计算所需票数。
- 详细解释了如何处理特殊情况（如 $N=M$），确保代码的鲁棒性。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
auto check = [=](int x, ll mid) {
    ll tar = a[x] + mid + 1;
    if (lower_bound(b + 1, b + n + 1, a[x]) - b <= n - m) {
        int idx = (int)(lower_bound(b + n - m + 1, b + n + 1, tar) - b - 1);
        return 1ll * (idx - (n - m)) * tar - (pre[idx] - pre[n - m]) > rem - mid;
    }
    int idx = (int)(lower_bound(b + n - m, b + n + 1, tar) - b - 1);
    return 1ll * (idx - (n - m - 1)) * tar - (pre[idx] - pre[n - m - 1]) - max(tar - a[x], 0ll) > rem - mid;
};
```

#### 题解3：作者：_WRYYY_ (赞：0)
**星级：4星**
**关键亮点：**
- 使用二分答案和前缀和优化，快速计算所需票数。
- 详细解释了如何通过排序和二分查找来优化计算过程。
- 代码逻辑清晰，处理了边界情况。

**核心代码：**
```cpp
int solve(int l, int r, ll w)
{
    int mid, ans = r;
    while (l <= r)
    {
        mid = l + r >> 1;
        if (p[mid].first > w)
        {
            ans = mid - 1;
            r = mid - 1;
        }
        else
            l = mid + 1;
    }
    return ans;
}
```

### 最优关键思路或技巧
1. **二分答案**：通过二分法快速确定每个候选人需要的最小额外票数。
2. **贪心策略**：优先将剩余票数分配给与当前候选人票数差距较小的候选人，确保计算效率。
3. **前缀和优化**：通过前缀和快速计算区间和，减少时间复杂度。
4. **排序**：通过排序数组，便于二分查找和区间计算。

### 可拓展之处
- 类似问题可以扩展到其他需要确定最小资源分配的场景，如资源调度、任务分配等。
- 可以进一步优化二分查找和前缀和的计算，减少时间复杂度。

### 推荐题目
1. [P3382 【模板】三分法](https://www.luogu.com.cn/problem/P3382)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

### 个人心得总结
- **调试经历**：在处理边界情况时，需要特别注意数组越界和特殊情况（如 $N=M$）的处理。
- **踩坑教训**：在计算区间和时，确保区间范围正确，避免重复计算或遗漏。
- **顿悟感想**：通过二分答案和前缀和优化，可以大幅提高计算效率，减少时间复杂度。

---
处理用时：44.90秒
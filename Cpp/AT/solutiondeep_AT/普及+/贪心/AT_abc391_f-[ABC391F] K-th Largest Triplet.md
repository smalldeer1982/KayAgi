# 题目信息

# [ABC391F] K-th Largest Triplet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc391/tasks/abc391_f

長さ $ N $ の整数列 $ A=(A_1,A_2,\ldots,A_N),\ B=(B_1,B_2,\ldots,B_N),C=(C_1,C_2,\ldots,C_N) $ および整数 $ K $ が与えられます。

$ 1\leq\ i,j,k\leq\ N $ を満たす整数 $ i,j,k $ の選び方 $ N^3 $ 通りそれぞれに対して $ A_iB_j+B_jC_k+C_kA_i $ の値を計算したとき、その中で大きい方から $ K $ 番目の値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ K\leq\ \min(N^3,5\times\ 10^5) $
- $ 1\leq\ A_i,B_i,C_i\leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

$ N^3=8 $ 個の整数の値は以下の通りです。 - $ (i,j,k)=(1,1,1) $ : $ A_1B_1+B_1C_1+C_1A_1=1\times\ 3+3\times\ 5+5\times\ 1=23 $ - $ (i,j,k)=(1,1,2) $ : $ A_1B_1+B_1C_2+C_2A_1=1\times\ 3+3\times\ 6+6\times\ 1=27 $ - $ (i,j,k)=(1,2,1) $ : $ A_1B_2+B_2C_1+C_1A_1=1\times\ 4+4\times\ 5+5\times\ 1=29 $ - $ (i,j,k)=(1,2,2) $ : $ A_1B_2+B_2C_2+C_2A_1=1\times\ 4+4\times\ 6+6\times\ 1=34 $ - $ (i,j,k)=(2,1,1) $ : $ A_2B_1+B_1C_1+C_1A_2=2\times\ 3+3\times\ 5+5\times\ 2=31 $ - $ (i,j,k)=(2,1,2) $ : $ A_2B_1+B_1C_2+C_2A_2=2\times\ 3+3\times\ 6+6\times\ 2=36 $ - $ (i,j,k)=(2,2,1) $ : $ A_2B_2+B_2C_1+C_1A_2=2\times\ 4+4\times\ 5+5\times\ 2=38 $ - $ (i,j,k)=(2,2,2) $ : $ A_2B_2+B_2C_2+C_2A_2=2\times\ 4+4\times\ 6+6\times\ 2=44 $ これらを値の降順に並べ替えると $ (44,38,36,34,31,29,27,23) $ となるため、 大きい方から $ 5 $ 番目の値は $ 31 $ です。

## 样例 #1

### 输入

```
2 5
1 2
3 4
5 6```

### 输出

```
31```

## 样例 #2

### 输入

```
3 10
100 100 100
100 100 100
100 100 100```

### 输出

```
30000```

## 样例 #3

### 输入

```
5 54
800516877 573289179 26509423 168629803 696409999
656737335 915059758 201458890 931198638 185928366
140174496 254538849 830992027 305186313 322164559```

### 输出

```
689589940713840351```

# AI分析结果

### 题目内容重写
给定长度为 $N$ 的整数序列 $A=(A_1,A_2,\ldots,A_N)$、$B=(B_1,B_2,\ldots,B_N)$、$C=(C_1,C_2,\ldots,C_N)$ 以及整数 $K$。对于所有满足 $1\leq i,j,k\leq N$ 的整数 $i,j,k$，计算 $A_iB_j+B_jC_k+C_kA_i$ 的值，并找出其中第 $K$ 大的值。

### 题解综合分析
本题的核心问题是如何高效地找到所有可能的三元组 $(i,j,k)$ 对应的 $A_iB_j+B_jC_k+C_kA_i$ 值中的第 $K$ 大值。由于直接枚举所有 $N^3$ 种组合的复杂度太高，题解中主要采用了以下几种优化思路：

1. **排序与剪枝**：将 $A$、$B$、$C$ 从大到小排序，利用单调性剪枝，减少不必要的计算。
2. **优先队列（堆）**：通过优先队列维护当前最大的值，逐步扩展找到第 $K$ 大的值。
3. **二分查找**：结合二分查找，通过判断某个值是否可能为第 $K$ 大值来优化搜索。

### 精选题解
#### 题解1：abensyl (4星)
**关键亮点**：
- 通过排序和剪枝，将问题复杂度从 $O(N^3)$ 降低到 $O(N \log^2 N)$。
- 使用 `nth_element` 快速找到第 $K$ 大的值，代码简洁高效。

**核心代码**：
```cpp
for(int i=1;i<=k&&i<=n;++i) {
    for(int j=1;i*j<=k&&j<=n;++j) {
        for(int l=1;i*j*l<=k&&l<=n;++l) {
            v.push_back(a[i]*b[j]+b[j]*c[l]+c[l]*a[i]);
        }
    }
}
nth_element(v.begin(),v.begin()+k-1,v.end(),cmp);
cout<<v[k-1]<<'\n';
```

#### 题解2：Double_Light (4星)
**关键亮点**：
- 采用二分查找结合剪枝，将复杂度优化到 $O(K \log \text{ans})$。
- 通过提前判断是否可能达到第 $K$ 大值，减少不必要的计算。

**核心代码**：
```cpp
bool check(int x){
    int cnt=0;
    for(int i=1;i<=n;i++){
        if(a[i]*b[1]+b[1]*c[1]+c[1]*a[i]<x)break;
        for(int j=1;j<=n;j++){
            if(a[i]*b[j]+b[j]*c[1]+c[1]*a[i]<x)break;
            for(int l=1;l<=n;l++){
                if(a[i]*b[j]+b[j]*c[l]+c[l]*a[i]>=x)cnt++;
                else break;
                if(cnt>=k)return 1;
            }
        }
    }
    return 0;
}
```

#### 题解3：nightwatch.ryan (4星)
**关键亮点**：
- 使用优先队列（堆）结合广度优先搜索（BFS）的思路，逐步扩展找到第 $K$ 大的值。
- 通过 `map` 去重，避免重复计算。

**核心代码**：
```cpp
priority_queue<Node> q;
map<Node, int> vis;
q.push({1, 1, 1, calc(1, 1, 1)});
int cnt = 0;
while(cnt < k){
    Node cur = q.top(); q.pop();
    if(!vis[cur]){
        vis[cur] = 1; cnt++;
        if(cnt == k) return cout << cur.val << endl, 0;
        if(cur.i < n) q.push({cur.i + 1, cur.j, cur.k, calc(cur.i + 1, cur.j, cur.k)});
        if(cur.j < n) q.push({cur.i, cur.j + 1, cur.k, calc(cur.i, cur.j + 1, cur.k)});
        if(cur.k < n) q.push({cur.i, cur.j, cur.k + 1, calc(cur.i, cur.j, cur.k + 1)});
    }
}
```

### 最优关键思路与技巧
1. **排序与剪枝**：通过将数组排序，利用单调性剪枝，减少不必要的计算。
2. **优先队列（堆）**：通过优先队列维护当前最大的值，逐步扩展找到第 $K$ 大的值。
3. **二分查找**：结合二分查找，通过判断某个值是否可能为第 $K$ 大值来优化搜索。

### 可拓展之处
- **类似问题**：类似的问题可以通过排序、剪枝、优先队列等技巧进行优化，如寻找第 $K$ 大的子数组和、第 $K$ 大的矩阵元素等。
- **算法套路**：优先队列调整法、二分查找结合剪枝是解决第 $K$ 大问题的常用套路。

### 推荐题目
1. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
2. [P1923 第k小的数](https://www.luogu.com.cn/problem/P1923)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得摘录
- **调试经历**：在使用优先队列时，需要注意去重，避免重复计算。通过 `map` 或 `set` 记录已经访问过的状态，可以有效避免重复。
- **踩坑教训**：在二分查找中，判断条件的设计非常重要，错误的判断条件可能导致无法正确找到第 $K$ 大的值。
- **顿悟感想**：通过排序和剪枝，可以将问题的复杂度大大降低，这在处理大规模数据时尤为重要。

---
处理用时：49.70秒
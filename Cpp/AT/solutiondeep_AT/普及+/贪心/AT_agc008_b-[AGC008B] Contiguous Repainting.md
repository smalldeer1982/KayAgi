# 题目信息

# [AGC008B] Contiguous Repainting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc008/tasks/agc008_b

$ N $ 個のマスが横一列に並んでいます。 左から $ i $ 番目のマスには整数 $ a_i $ が書かれています。

最初、すべてのマスは白色です。 すぬけ君は次の操作を好きな回数だけ繰り返します。

- 連続する $ K $ 個のマスを選び、それらすべてを白く塗るか、それらすべてを黒く塗る。 このとき、各マスの色は上書きされる。

すぬけ君が操作を終えた後、黒いマスに書かれた整数の総和がスコアになります。 考えられるスコアの最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =N\ <\ =10^5 $
- $ 1\ <\ =K\ <\ =N $
- $ a_i $ は整数である。
- $ |a_i|\ <\ =10^9 $

### Sample Explanation 1

左から $ 2 $, $ 3 $, $ 4 $ 番目のマスを黒く塗ればよいです。

### Sample Explanation 2

たとえば、次のように操作を行えばよいです。 - 左から $ 1 $, $ 2 $ 番目のマスを黒く塗る。 - 左から $ 3 $, $ 4 $ 番目のマスを黒く塗る。 - 左から $ 2 $, $ 3 $ 番目のマスを白く塗る。

## 样例 #1

### 输入

```
5 3

-10 10 -10 10 -10```

### 输出

```
10```

## 样例 #2

### 输入

```
4 2

10 -10 -10 10```

### 输出

```
20```

## 样例 #3

### 输入

```
1 1

-10```

### 输出

```
0```

## 样例 #4

### 输入

```
10 5

5 -4 -5 -8 -4 7 2 -4 0 7```

### 输出

```
17```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $N$ 个格子排成一列，从左到右第 $i$ 个格子上写有一个整数 $a_i$。最初，所有格子都是白色的。你可以进行以下操作任意次：

- 选择连续的 $K$ 个格子，将它们全部涂成白色或黑色。每次操作会覆盖这些格子之前的颜色。

操作结束后，黑色格子上数字的总和就是你的得分。求最大可能的得分。

#### 说明/提示

- $1 \leq N \leq 10^5$
- $1 \leq K \leq N$
- $a_i$ 是整数，且 $|a_i| \leq 10^9$

#### 样例输入输出

**样例 1**

输入：
```
5 3
-10 10 -10 10 -10
```
输出：
```
10
```

**样例 2**

输入：
```
4 2
10 -10 -10 10
```
输出：
```
20
```

**样例 3**

输入：
```
1 1
-10
```
输出：
```
0
```

**样例 4**

输入：
```
10 5
5 -4 -5 -8 -4 7 2 -4 0 7
```
输出：
```
17
```

---

### 题解综合分析与结论

本题的核心思路是通过最后一次操作确定一段长度为 $K$ 的区间的颜色，而其他部分的颜色可以通过多次操作任意调整。因此，问题的关键在于如何枚举所有可能的长度为 $K$ 的区间，并计算在这些区间被固定为黑色或白色时的最大得分。

#### 关键思路：
1. **最后一次操作的影响**：最后一次操作会固定一段长度为 $K$ 的区间的颜色，其他部分的颜色可以通过多次操作任意调整。
2. **贪心策略**：对于非固定区间的格子，如果其值为正数，则将其涂黑；如果为负数，则将其涂白。
3. **前缀和优化**：通过前缀和快速计算固定区间内外的正数和，避免重复计算。

#### 最优技巧：
- **前缀和的应用**：通过前缀和快速计算区间和，减少时间复杂度。
- **枚举区间**：枚举所有可能的长度为 $K$ 的区间，计算每种情况下的最大得分。

---

### 精选题解

#### 题解1：作者：zljhenry (赞：6)

**星级：★★★★★**

**关键亮点：**
- 清晰地分析了最后一次操作的影响，提出通过枚举长度为 $K$ 的区间来计算最大得分。
- 使用前缀和优化计算，代码简洁高效。

**核心代码：**
```cpp
for(ll i=1;i<=n-k+1;i++){
    ll A=sum1[i-1];
    ll B=sum2[i+k];
    ll C=sum3[i+k-1]-sum3[i-1];
    if(C<0) C=0;
    ans=max(ans,A+B+C);
}
```
**核心思想：** 枚举每个长度为 $K$ 的区间，计算该区间内外的正数和，取最大值。

---

#### 题解2：作者：Acheron_RBM (赞：2)

**星级：★★★★**

**关键亮点：**
- 明确提出了贪心策略，通过前缀和和后缀和优化计算。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
for(int i=1;i<=n-k+1;i++){
    ret=max(ret,l[i-1]+l1[i+k]+max(0ll,r[i+k-1]-r[i-1]));
}
```
**核心思想：** 通过前缀和和后缀和快速计算固定区间内外的正数和，取最大值。

---

#### 题解3：作者：fish_love_cat (赞：1)

**星级：★★★★**

**关键亮点：**
- 详细解释了如何通过覆盖操作调整非固定区间的颜色。
- 使用前缀和优化计算，代码简洁。

**核心代码：**
```cpp
for(int i=1;i<=n-k+1;i++){
    ans=max(ans,max((long long)0,qzh1[i+k-1]-qzh1[i-1])+qzh2[n]-(qzh2[i+k-1]-qzh2[i-1]));
}
```
**核心思想：** 枚举每个长度为 $K$ 的区间，计算该区间内外的正数和，取最大值。

---

### 推荐题目

1. **洛谷 P1115 最大子段和**  
   题目链接：https://www.luogu.com.cn/problem/P1115  
   考察知识点：前缀和、贪心

2. **洛谷 P1886 滑动窗口**  
   题目链接：https://www.luogu.com.cn/problem/P1886  
   考察知识点：滑动窗口、单调队列

3. **洛谷 P1714 切蛋糕**  
   题目链接：https://www.luogu.com.cn/problem/P1714  
   考察知识点：前缀和、滑动窗口

---
处理用时：38.37秒
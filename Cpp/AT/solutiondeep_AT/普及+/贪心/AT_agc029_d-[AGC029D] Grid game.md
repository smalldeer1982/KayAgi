# 题目信息

# [AGC029D] Grid game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc029/tasks/agc029_d

高橋君と青木君は $ H $ 行 $ W $ 列のマス目を使ってゲームをします。 このマス目上には $ N $ 個の障害物があり、$ i $ 番目の障害物は $ (X_i,Y_i) $ にあります。 ただし、$ i $ 行 $ j $ 列目 $ (1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W) $ にあるマスを $ (i,j) $ で表すことにします。 また、どの障害物も $ (1,1) $ にはなく、$ (1,1) $ には $ 1 $ つの駒が置いてあります。

そこで、高橋君と青木君は高橋君から始めて、交互に以下の行動のいずれかを行います。

- 駒を隣り合うマスに動かす。 ただし、駒の位置を $ (x,y) $ としたとき、高橋君は $ (x+1,y) $ にのみ、青木君は $ (x,y+1) $ にのみ駒を動かすことができる。 また、動かすことのできるマスが存在しない、もしくは、動かす予定のマス目に障害物がある場合はこの行動をとることはできない。
- 駒を動かさず、マス目を元の状態のまま行動を終える。

$ 2 $ 回連続で駒が動かされなかった場合、そこでゲームを終了します。

高橋君はできるだけ多くの回数の行動 (駒を動かさないのも含む) を行ってゲームを終えたいですが、 青木君はできるだけ少ない回数の行動を行ってゲームを終えたいです。 このとき、高橋君が行うことになる行動の回数は何回か求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ X_i\ \leq\ H $
- $ 1\ \leq\ Y_i\ \leq\ W $
- $ i\ \neq\ j $ のとき $ (X_i,Y_i)\ \neq\ (X_j,Y_j) $
- $ (X_i,Y_i)\ \neq\ (1,1) $
- $ X_i,Y_i $ は整数

### Sample Explanation 1

ゲームの一例は以下のようになります。 - 高橋君が駒を (2,1) に動かす。 - 青木君が駒を動かさない。 - 高橋君が駒を (3,1) に動かす。 - 青木君が駒を動かさない。 - 高橋君が駒を動かさない。 この場合は高橋君は $ 3 $ 回の行動を行いますが、 両者が最適に行動すれば $ 2 $ 回しか高橋君は行動せずにゲームが終了します。

## 样例 #1

### 输入

```
3 3 1

3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
10 10 14

4 3

2 2

7 3

9 10

7 7

8 1

10 10

5 4

3 4

2 8

6 4

4 4

5 8

9 2```

### 输出

```
6```

## 样例 #3

### 输入

```
100000 100000 0```

### 输出

```
100000```

# AI分析结果

### 题目内容重写

高桥君和青木君使用一个 $H$ 行 $W$ 列的网格进行游戏。网格上有 $N$ 个障碍物，第 $i$ 个障碍物位于 $(X_i, Y_i)$。网格的 $(i,j)$ 表示第 $i$ 行第 $j$ 列的格子 $(1 \leq i \leq H, 1 \leq j \leq W)$。初始时，$(1,1)$ 上有一个棋子，且 $(1,1)$ 上没有障碍物。

高桥君和青木君轮流进行以下操作之一：

1. 将棋子移动到相邻的格子。高桥君只能将棋子从 $(x,y)$ 移动到 $(x+1,y)$，青木君只能将棋子从 $(x,y)$ 移动到 $(x,y+1)$。如果目标格子不存在或含有障碍物，则不能进行此操作。
2. 不移动棋子，保持当前状态。

如果连续两次操作都没有移动棋子，游戏结束。

高桥君希望尽可能多地进行操作（包括不移动），而青木君希望尽可能少地进行操作。求高桥君最终会进行多少次操作。

### 题解分析与结论

#### 综合分析与结论

这道题的核心在于模拟高桥君和青木君的最优策略。高桥君会尽可能移动棋子，而青木君则会尽可能将棋子引导到障碍物上，以限制高桥君的移动。通过贪心策略，我们可以模拟棋子的移动路径，并找到高桥君的最优操作次数。

#### 所选题解

1. **作者：Acheron_RBM (4星)**
   - **关键亮点**：通过贪心策略模拟棋子的移动路径，统计符合特定条件的障碍物，计算高桥君的操作次数。
   - **核心实现思想**：使用二维数组记录障碍物，模拟高桥君和青木君的移动策略，统计符合条件的障碍物并更新答案。

   ```cpp
   bool mp[200001][200001]; // 存图
   pair<long long, long long> a[555555]; // 障碍物的位置
   long long col[555555] = {0, 1}; // 第i行有几个可到达的列
   long long ret;
   int main() {
       int n, m, k;
       cin >> n >> m >> k;
       ret = n;
       for (int i = 1; i <= k; i++) {
           cin >> a[i].first >> a[i].second; // 障碍物的位置
           mp[a[i].first][a[i].second] = true;
       }
       long long sum = 1;
       for (int i = 2; i <= n; i++) {
           if (!mp[i][sum + 1] && sum < m) { // 高木最优策略
               sum++;
           }
           col[i] = sum;
       }
       for (int i = 1; i <= k; i++) {
           if (col[a[i].first] >= a[i].second) {
               ret = min(ret, a[i].first - 1); // 统计答案
           }
       }
       cout << ret;
       return 0;
   }
   ```

2. **作者：Krimson (4星)**
   - **关键亮点**：通过排序障碍物并模拟移动过程，计算高桥君的操作次数。
   - **核心实现思想**：使用 `set` 记录障碍物，模拟高桥君和青木君的移动策略，更新答案。

   ```cpp
   #include<bits/stdc++.h>
   using namespace std;
   #define pii pair<int, int>
   set<pii> s;
   int up;
   const int MAXN = 2e5 + 7;
   pii p[MAXN];
   int h, w, n;
   int main() {
       h = read(), w = read(), n = read();
       for (int i = 1; i <= n; ++i) p[i].first = read(), p[i].second = read();
       p[++n] = (pii){h + 1, 1};
       sort(p + 1, p + n + 1);
       up = 1;
       for (int i = 1, j = 1; i <= n; ++i) {
           while (j + 1 < p[i].first) {
               ++j;
               if (s.find((pii){j, up + 1}) == s.end()) ++up;
           }
           if (up >= p[i].second && s.find((pii){j, up}) == s.end()) {
               print(j);
               return 0;
           }
           s.insert(p[i]);
       }
       return 0;
   }
   ```

3. **作者：Texas_the_Omertosa (4星)**
   - **关键亮点**：通过贪心策略模拟棋子的移动路径，统计符合条件的障碍物，计算高桥君的操作次数。
   - **核心实现思想**：使用 `map` 记录障碍物，模拟高桥君和青木君的移动策略，统计符合条件的障碍物并更新答案。

   ```cpp
   #include <bits/stdc++.h>
   #define int long long
   #define linf LLONG_MAX
   #define iinf INT_MAX
   #define ios ios::sync_with_stdio(0);cin.tie(0);
   #define N 500005
   #define M 300005
   #define mod 1000000007
   #define pint pair<int, int>
   #define mp make_pair
   using namespace std;
   map<int, bool> ma[N]; // 记录障碍物
   struct point {
       int x;
       int y;
   };
   point a[N];
   int col[N] = {0, 1}; // col[i] 表示到第 i 行最多可到达的列数。
   signed main() {
       ios;
       int n, m, k, ans, c = 1;
       cin >> n >> m >> k;
       ans = n;
       for (int i = 1; i <= k; i++) {
           cin >> a[i].x >> a[i].y;
           ma[a[i].x][a[i].y] = 1; // 标记障碍物
       }
       for (int i = 2; i <= n; i++) {
           if (c < m && !ma[i][c + 1]) { // 如果可以往右走
               c++;
           }
           col[i] = c;
       }
       for (int i = 1; i <= k; i++) {
           if (col[a[i].x] >= a[i].y) { // 如果到了这一行刚好到或超过这一列
               ans = min(ans, a[i].x - 1); // 可以到达，记录答案。
           }
       }
       cout << ans << '\n';
       return 0;
   }
   ```

### 最优关键思路与技巧

1. **贪心策略**：高桥君会尽可能移动棋子，而青木君则会尽可能将棋子引导到障碍物上，以限制高桥君的移动。
2. **模拟移动路径**：通过模拟棋子的移动路径，统计符合条件的障碍物，计算高桥君的操作次数。
3. **数据结构优化**：使用 `map` 或 `set` 记录障碍物，提高查找和更新的效率。

### 可拓展之处

1. **类似问题**：可以扩展到其他类型的网格游戏，如不同移动规则或更多玩家参与。
2. **算法优化**：可以进一步优化数据结构，如使用更高效的哈希表或区间树来记录障碍物。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

---
处理用时：59.93秒
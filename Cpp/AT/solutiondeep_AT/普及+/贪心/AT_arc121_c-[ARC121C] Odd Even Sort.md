# 题目信息

# [ARC121C] Odd Even Sort

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc121/tasks/arc121_c

$ (1,2,\ \ldots,\ N) $ を並び替えた数列 $ p $ が与えられます。 はじめ、$ p $ の第 $ n $ 項は $ p_{n} $ です。

あなたの目的は $ N^2 $ 回以下 *操作* を行い $ p $ を昇順に並び替えることです。 あなたは操作により以下のように $ p $ を変更することができます。

- **奇数** 回目の操作では $ 1 $ 以上 $ N-1 $ 以下の **奇数** $ n $ を選んで $ p_n $ と $ p_{n+1} $ を入れ替えます。
- **偶数** 回目の操作では $ 2 $ 以上 $ N-1 $ 以下の **偶数** $ n $ を選んで $ p_n $ と $ p_{n+1} $ を入れ替えます。

この問題の制約下で必ず目的を達成できることが証明できます。 そのような操作列を $ 1 $ つ求めてください。

$ T $ 個のテストケースが与えられるのでそれぞれについて答えを求めてください。

## 说明/提示

### 制約

- 与えられる入力は全て整数
- $ 1\ \leq\ T\ \leq\ 250 $
- $ 2\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ p_i\ \leq\ N $
- $ p $ は $ (1,2,\ldots,N) $ を並び替えて得られる。
- $ 1 $ つの入力ファイルにおいて $ N $ の総和は $ 500 $ を超えない。

### Sample Explanation 1

\- $ 1 $ つ目のテストケースについて説明します。 - $ 1 $ 回目の操作で $ 1 $ を選ぶと $ p $ は $ (1,2,3,5,4) $ となります。 - $ 2 $ 回目の操作で $ 4 $ を選ぶと $ p $ は $ (1,2,3,4,5) $ となります。 - $ (1,4) $ は操作列として正しいですが、$ (4,1) $ は操作列として正しくないことに注意してください。 - 操作を $ 1 $ 度も行わなくともよいこと、操作回数を最小にする必要はないことに注意してください。

## 样例 #1

### 输入

```
2

5

2 1 3 5 4

2

1 2```

### 输出

```
2

1 4

0```

# AI分析结果

### 题目翻译
# [ARC121C] 奇偶排序

## 题目描述

给定一个由 $ (1,2,\ \ldots,\ N) $ 排列而成的数列 $ p $。初始时，$ p $ 的第 $ n $ 项为 $ p_{n} $。

你的目标是在最多 $ N^2 $ 次操作内将 $ p $ 按升序排列。每次操作可以按以下方式修改 $ p $：

- **奇数** 次操作时，选择 $ 1 $ 以上 $ N-1 $ 以下的 **奇数** $ n $，交换 $ p_n $ 和 $ p_{n+1} $。
- **偶数** 次操作时，选择 $ 2 $ 以上 $ N-1 $ 以下的 **偶数** $ n $，交换 $ p_n $ 和 $ p_{n+1} $。

在题目约束下，可以证明总能达到目标。请输出一个满足条件的操作序列。

给定 $ T $ 个测试用例，分别输出每个用例的答案。

## 说明/提示

### 制約

- 所有输入均为整数
- $ 1\ \leq\ T\ \leq\ 250 $
- $ 2\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ p_i\ \leq\ N $
- $ p $ 是 $ (1,2,\ldots,N) $ 的一个排列
- 单个输入文件中 $ N $ 的总和不超过 $ 500 $

### 样例解释 1

\- 第一个测试用例的解释：  
- 第 $ 1 $ 次操作选择 $ 1 $，$ p $ 变为 $ (1,2,3,5,4) $。  
- 第 $ 2 $ 次操作选择 $ 4 $，$ p $ 变为 $ (1,2,3,4,5) $。  
- 操作序列 $ (1,4) $ 是正确的，但 $ (4,1) $ 不正确。  
- 注意：可以不进行操作，且操作次数不需要最小化。

## 样例 #1

### 输入

```
2

5

2 1 3 5 4

2

1 2```

### 输出

```
2

1 4

0```

### 题解分析与结论

#### 题解对比与评分
1. **lmy_2011 (2星)**：
   - 思路：使用类似冒泡排序的方法，通过维护一个下标 $cur$ 来避免浪费步数。
   - 难点：代码复杂，逻辑不够清晰，且未完全解决奇偶步数限制的问题。
   - 评分：2星，代码可读性较差，优化不足。

2. **promise_ (1星)**：
   - 思路：分别处理奇数位置和偶数位置的元素，类似于冒泡排序。
   - 难点：未考虑奇偶步数的限制，思路过于简单，无法保证正确性。
   - 评分：1星，思路不完整，无法通过所有测试用例。

3. **_luanyi_ (4星)**：
   - 思路：通过选择排序的思路，逐步将元素移动到正确位置，并通过浪费步数来调整奇偶性。
   - 难点：解决了奇偶步数限制的问题，代码实现较为清晰。
   - 评分：4星，思路清晰，代码可读性较好，优化程度较高。

4. **wzt2012 (3星)**：
   - 思路：通过递归和浪费步数的方法，逐步将元素移动到正确位置。
   - 难点：代码较为复杂，但解决了奇偶步数限制的问题。
   - 评分：3星，思路较好，但代码可读性一般。

#### 最优关键思路
- **奇偶步数调整**：通过浪费步数来调整奇偶性，确保在奇数次操作时交换奇数位置，偶数次操作时交换偶数位置。
- **逐步移动元素**：采用选择排序的思路，逐步将元素移动到正确位置，避免重复操作。

#### 代码实现
```cpp
void solve(int x){
    if(x == n - 2){
        while(!(p[n - 2] < p[n - 1] && p[n - 1] < p[n])){
			if(nw){
				swap(p[ji], p[ji + 1]);
				ans.push_back(ji);
			}else{
				swap(p[ou], p[ou + 1]);
				ans.push_back(ou);
			}
            nw ^= 1;
        }
        return;
    }
    for(int i = x; i <= n; i ++)
        if(p[i] == x){
        	if(i == x){
				solve(x + 1);
				return;
			}
            if(i % 2 == nw){
            	if(i == n){
            		swap(p[n - 2], p[n - 1]);
					ans.push_back(n - 2);
            		nw ^= 1;
				}else{
					swap(p[i], p[i + 1]);
					ans.push_back(i);
	            	swap(p[i - 1], p[i]);
					ans.push_back(i - 1);
	            	i ++;
				}
            }
            for(int j = i - 1; j >= x; j --){
                swap(p[j], p[j + 1]);
                ans.push_back(j);
				nw ^= 1;
            }
            solve(x + 1);
            return;
        }
}
```

#### 拓展思路
- **类似问题**：可以考虑其他需要调整奇偶性的排序问题，如奇偶交替排序等。
- **优化方向**：可以进一步优化步数，减少不必要的浪费操作。

#### 推荐题目
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

#### 个人心得
- **调试经历**：在实现过程中，奇偶步数的调整是关键，需要通过浪费步数来确保操作的合法性。
- **顿悟感想**：选择排序的思路虽然简单，但在特定条件下（如奇偶步数限制）仍然可以高效解决问题。

---
处理用时：47.86秒
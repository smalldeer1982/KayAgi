# 题目信息

# [ARC130C] Digit Sum Minimization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc130/tasks/arc130_c

正の整数 $ a,\ b $ が与えられます。ただし、$ a,\ b $ のどの桁も $ 0 $ ではありません。

$ a+b $ の各桁の和が最小になるように、$ a $, $ b $ のそれぞれの桁を並べ替えてください。

## 说明/提示

### 制約

- $ 1\leq\ a,\ b\ <\ 10^{100000} $
- $ a,\ b $ のどの桁も $ 0 $ ではない

### Sample Explanation 1

$ 532\ +\ 268\ =\ 800 $ で、その各桁の和は $ 8+0+0=8 $ となります。 他にも、$ (a,\ b)\ =\ (325,\ 682) $ を出力しても正解となります。

### Sample Explanation 2

$ 435+565=1000 $ で、その各桁の和は $ 1+0+0+0=1 $ となります。

### Sample Explanation 3

$ 312\ +\ 799788\ =\ 800100 $ で、その各桁の和は $ 8+0+0+1+0+0=9 $ となります。

## 样例 #1

### 输入

```
253

286```

### 输出

```
532

268```

## 样例 #2

### 输入

```
345

556```

### 输出

```
435

565```

## 样例 #3

### 输入

```
123

987987```

### 输出

```
312

799788```

## 样例 #4

### 输入

```
11111111111111111111

111111111111111111111111111111```

### 输出

```
11111111111111111111

111111111111111111111111111111```

# AI分析结果

### 题目内容重写

**题目描述**

给定两个正整数 $a$ 和 $b$，且它们的每一位都不为 $0$。请将 $a$ 和 $b$ 的每一位重新排列，使得 $a + b$ 的各位数字之和最小。

**说明/提示**

**约束条件**

- $1 \leq a, b < 10^{100000}$
- $a$ 和 $b$ 的每一位都不为 $0$

**样例解释**

**样例 1**

输入：
```
253
286
```
输出：
```
532
268
```
解释：$532 + 268 = 800$，其各位数字之和为 $8 + 0 + 0 = 8$。其他如 $(a, b) = (325, 682)$ 也是正确答案。

**样例 2**

输入：
```
345
556
```
输出：
```
435
565
```
解释：$435 + 565 = 1000$，其各位数字之和为 $1 + 0 + 0 + 0 = 1$。

**样例 3**

输入：
```
123
987987
```
输出：
```
312
799788
```
解释：$312 + 799788 = 800100$，其各位数字之和为 $8 + 0 + 0 + 1 + 0 + 0 = 9$。

**样例 4**

输入：
```
11111111111111111111
111111111111111111111111111111
```
输出：
```
11111111111111111111
111111111111111111111111111111
```

### 题解分析与结论

#### 题解1：XYQ_102
**评分：4星**
- **关键亮点**：通过枚举个位数的组合，确保至少有一个进位，然后尽量多的产生9的进位。代码实现清晰，逻辑简单。
- **核心思想**：枚举个位数的组合，确保其和大于等于10，然后尽量多的产生9的进位。
- **代码实现**：
  ```cpp
  inline pip calc(int a,int b){
      for(int i=1;i<=9;i++)ts[i]=cs[i],tt[i]=ct[i];
      string S(1,a+'0'),T(1,b+'0');int res=1;
      for(int i=1;i<=9;i++)
          for(int j=1;j<=9;j++)if(i+j>=9){
              int c=min(ts[i],tt[j]);
              ts[i]-=c;tt[j]-=c;res+=c;
              S+=str(c,i+'0'),T+=str(c,j+'0');
          }
      res+=max(ts[9],tt[9]);
      for(int i=9;i>=1;i--)
          S+=str(ts[i],i+'0'),T+=str(tt[i],i+'0');
      reverse(S.begin(),S.end());
      reverse(T.begin(),T.end());
      return mkp(res,mkp(S,T));
  }
  ```

#### 题解2：EuphoricStar
**评分：3星**
- **关键亮点**：分类讨论，优先选择非9的数字以产生更多进位。代码实现较为复杂，但思路清晰。
- **核心思想**：优先选择非9的数字以产生更多进位，确保每一位的和尽可能大。
- **代码实现**：未提供完整代码，但思路清晰，适合进一步优化。

### 最优关键思路或技巧
- **关键思路**：通过枚举个位数的组合，确保至少有一个进位，然后尽量多的产生9的进位。这种方法简单且有效，能够确保最终的各位数字之和最小。
- **优化技巧**：在枚举个位数组合时，优先选择能够产生进位的组合，这样可以减少后续的进位操作。

### 可拓展之处
- **类似题目**：可以扩展到多个数字的加法，或者扩展到其他进制下的数字和最小化问题。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)
3. [P1019 单词接龙](https://www.luogu.com.cn/problem/P1019)

### 个人心得
- **调试经历**：在枚举个位数组合时，确保至少有一个进位是关键，否则可能会导致后续的进位操作无法进行。
- **顿悟感想**：通过枚举个位数的组合，可以简化问题，使得后续的进位操作更加容易处理。

---
处理用时：37.87秒
# 题目信息

# [ARC157B] XYYYX

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc157/tasks/arc157_b

`X`, `Y` からなる長さ $ N $ の文字列 $ S $ が与えられます． $ S $ 中の相異なる位置にある $ K $ 文字を選び，選んだ文字が `X` であれば `Y` に，`Y` であれば `X` にそれぞれ置き換えます． 置き換えた後の文字列中で `Y` 同士が隣り合う箇所は最大でいくつになるかを求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ K\ \leq\ N $
- $ S $ は `X`, `Y` からなる長さ $ N $ の文字列である．
 
### Sample Explanation 1

選ぶのは $ 1 $ 文字だけです． - $ 1 $ 文字目を選ぶと，置き換えた後の文字列は `YYXYX` となり，$ 1,\ 2 $ 文字目の $ 1 $ 箇所で `Y` 同士が隣り合っています． - $ 2 $ 文字目を選ぶと，置き換えた後の文字列は `XXXYX` となり，`Y` 同士が隣り合っている箇所はありません． - $ 3 $ 文字目を選ぶと，置き換えた後の文字列は `XYYYX` となり，$ 2,\ 3 $ 文字目と $ 3,\ 4 $ 文字目の $ 2 $ 箇所で `Y` 同士が隣り合っています． - $ 4 $ 文字目を選ぶと，置き換えた後の文字列は `XYXXX` となり，`Y` 同士が隣り合っている箇所はありません． - $ 5 $ 文字目を選ぶと，置き換えた後の文字列は `XYXYY` となり，$ 4,\ 5 $ 文字目の $ 1 $ 箇所で `Y` 同士が隣り合っています． 以上より，求める最大値は $ 2 $ です．

### Sample Explanation 2

$ 1,\ 2,\ 3,\ 5 $ 文字目を選んで `YXYYY` とするか，$ 1,\ 3,\ 4,\ 5 $ 文字目を選んで `YYYXY` とするのが最適です． 同じ位置にある文字を複数回選ぶことはできないことに注意してください．

## 样例 #1

### 输入

```
5 1

XYXYX```

### 输出

```
2```

## 样例 #2

### 输入

```
5 4

XYXYX```

### 输出

```
2```

# AI分析结果

### 题目内容重写
#### [ARC157B] XYYYX

**题目描述**

给定一个由 `X` 和 `Y` 组成的长度为 $N$ 的字符串 $S$。你需要选择 $S$ 中 $K$ 个不同位置的字符进行翻转，即如果选中的字符是 `X`，则将其变为 `Y`；如果是 `Y`，则将其变为 `X`。翻转后的字符串中，`Y` 相邻的个数最多有多少？

**说明/提示**

**约束条件**

- $1 \leq N \leq 2 \times 10^5$
- $0 \leq K \leq N$
- $S$ 是由 `X` 和 `Y` 组成的长度为 $N$ 的字符串。

**样例解释**

**样例 1**

输入：
```
5 1
XYXYX
```
输出：
```
2
```

**样例 2**

输入：
```
5 4
XYXYX
```
输出：
```
2
```

### 题解综合分析与结论

通过对多条题解的分析，可以发现题解的核心思路主要集中在如何通过翻转字符来最大化 `Y` 相邻的个数。主要的解决思路包括：

1. **分类讨论**：根据 `X` 的数量与 $K$ 的关系进行分类讨论，分别处理 $K \leq cnt_X$ 和 $K > cnt_X$ 的情况。
2. **优先翻转策略**：在 $K \leq cnt_X$ 时，优先翻转相邻 `Y` 之间的 `X`，以最大化 `Y` 相邻的个数；在 $K > cnt_X$ 时，优先翻转边界 `Y`，以减少 `Y` 相邻的损失。
3. **排序与贪心**：通过排序相邻 `Y` 之间的 `X` 数量，优先翻转数量较少的 `X`，以最大化每次翻转的贡献。

### 所选高分题解

#### 题解1：I_like_magic (4星)

**关键亮点**：
- 清晰地将问题分为 $K \leq cnt_X$ 和 $K > cnt_X$ 两种情况，并分别处理。
- 通过排序相邻 `Y` 之间的 `X` 数量，优先翻转数量较少的 `X`，使用贪心策略最大化每次翻转的贡献。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码**：
```cpp
vector<int> dis; // 两个相邻 Y 之间 X 个数的序列
sort(dis.begin(), dis.end()); // 从小到大排序
for(int i : dis) { // 遍历序列
    if(k >= i) {
        k -= i; // 使用 i 次翻转
        ans += 1 + i; // 对答案造成 i + 1 的贡献
    }
}
ans += k; // 使用剩下的 k 次翻转，对答案造成 k 的贡献
```

#### 题解2：Erica_N_Contina (4星)

**关键亮点**：
- 详细讨论了 $K \leq cnt_X$ 和 $K > cnt_X$ 两种情况下的最优策略。
- 在 $K > cnt_X$ 时，优先翻转边界 `Y`，以减少 `Y` 相邻的损失，思路清晰。
- 代码实现较为简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i = 1 ; i <= n && k ;++i){
    while(len[i] && k){
        if (i <= k) 
            ans += i + 1, k -= i, len[i] --;
        else 
            ans += k , k = 0;
    }
}
ans += k;
```

### 最优关键思路与技巧

1. **分类讨论**：根据 `X` 的数量与 $K$ 的关系进行分类讨论，分别处理 $K \leq cnt_X$ 和 $K > cnt_X$ 的情况。
2. **贪心策略**：通过排序相邻 `Y` 之间的 `X` 数量，优先翻转数量较少的 `X`，以最大化每次翻转的贡献。
3. **边界处理**：在 $K > cnt_X$ 时，优先翻转边界 `Y`，以减少 `Y` 相邻的损失。

### 可拓展之处

- **类似问题**：可以考虑类似的问题，如通过翻转字符来最大化或最小化某种字符的相邻个数。
- **贪心算法**：在其他需要最大化或最小化某种指标的题目中，贪心策略是一种常见的优化手段。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

这些题目都涉及到贪心策略的应用，可以帮助进一步理解和掌握贪心算法的使用。

---
处理用时：82.33秒
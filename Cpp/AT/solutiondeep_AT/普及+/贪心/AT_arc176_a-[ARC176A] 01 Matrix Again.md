# 题目信息

# [ARC176A] 01 Matrix Again

## 题目描述

给定一个 $N \times N$ 的矩阵，你需要向其中填入 $0$ 或 $1$，使其满足以下条件：

- $(A_1,B_1),(A_2,B_2),...,(A_M,B_M)$ 处的值为 $1$。
- 第 $i$ 行的所有数字之和为 $M$ $(1 \le i \le N)$。
- 第 $i$ 列的所有数字之和为 $M$ $(1 \le i \le N)$。

## 样例 #1

### 输入

```
4 2

1 4

3 2```

### 输出

```
8

1 2

1 4

2 1

2 4

3 2

3 3

4 1

4 3```

## 样例 #2

### 输入

```
3 3

3 1

2 3

1 3```

### 输出

```
9

1 1

1 2

1 3

2 1

2 2

2 3

3 1

3 2

3 3```

## 样例 #3

### 输入

```
7 3

1 7

7 6

6 1```

### 输出

```
21

1 6

2 4

4 1

7 3

3 6

4 5

6 1

1 7

7 6

3 5

2 2

6 3

6 7

5 4

5 2

2 5

5 3

1 4

7 1

4 7

3 2```

# AI分析结果

### 题目内容重写
给定一个 $N \times N$ 的矩阵，你需要向其中填入 $0$ 或 $1$，使其满足以下条件：

- $(A_1,B_1),(A_2,B_2),...,(A_M,B_M)$ 处的值为 $1$。
- 第 $i$ 行的所有数字之和为 $M$ $(1 \le i \le N)$。
- 第 $i$ 列的所有数字之和为 $M$ $(1 \le i \le N)$。

### 样例 #1
#### 输入
```
4 2
1 4
3 2
```
#### 输出
```
8
1 2
1 4
2 1
2 4
3 2
3 3
4 1
4 3
```

### 样例 #2
#### 输入
```
3 3
3 1
2 3
1 3
```
#### 输出
```
9
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
```

### 样例 #3
#### 输入
```
7 3
1 7
7 6
6 1
```
#### 输出
```
21
1 6
2 4
4 1
7 3
3 6
4 5
6 1
1 7
7 6
3 5
2 2
6 3
6 7
5 4
5 2
2 5
5 3
1 4
7 1
4 7
3 2
```

### 题解分析与结论
本题的核心在于构造一个满足条件的 $N \times N$ 的 $01$ 矩阵，且每行每列的和均为 $M$。多个题解都采用了类似的思路，即通过斜线构造来满足每行每列的和为 $M$，并确保给定的点必须为 $1$。以下是各题解的要点总结：

1. **斜线构造法**：大多数题解都利用了斜线构造的思想，即选择满足 $i+j \equiv k \pmod{n}$ 的点填 $1$，这样可以确保每行每列的和为 $1$。通过选择 $m$ 个不同的 $k$，可以满足每行每列的和为 $m$。
2. **处理给定点**：所有题解都强调了必须确保给定的点必须为 $1$，并且这些点的 $k$ 值必须被选中。如果给定的点不足 $m$ 个，则需要额外选择其他 $k$ 值。
3. **时间复杂度**：大多数题解的时间复杂度为 $O(nm)$，能够满足题目要求。

### 精选题解
#### 题解1：XYQ_102 (5星)
**关键亮点**：
- 思路清晰，代码简洁，易于理解。
- 通过 $(i+j) \mod n$ 的方式给每个格子编号，确保每行每列的和为 $m$。
- 处理给定点的方式简单直接，代码实现高效。

**核心代码**：
```cpp
vector<bool> vis(n);
for(int i=1;i<=m;i++){
    int x,y;
    cin>>x>>y;
    x--,y--;
    vis[(x+y)%n]=1;
}
vector<int> ans;
for(int i=0;i<n;i++) if(vis[i]) ans.push_back(i);
for(int i=0;i<n;i++) if(!vis[i]&&ans.size()<m) ans.push_back(i);
cout<<n*m<<endl;
for(int i=0;i<n;i++){
    for(int j=0;j<m;j++){
        int x=i,y=(ans[j]-i+n)%n;
        cout<<x+1<<" "<<y+1<<endl;
    }
}
```

#### 题解2：Creeper_l (4星)
**关键亮点**：
- 详细解释了斜线构造的思路，并给出了时间复杂度分析。
- 代码实现较为清晰，处理给定点的方式与题解1类似。

**核心代码**：
```cpp
for(int i = 1,a,b;i <= m;i++) {
    cin >> a >> b;
    if(!vis[(a + b) % n])
        vis[(a + b) % n] = 1,sum++;
} printf("%lld\n",n * m);
for(int i = 0;i < n;i++) {
    if(vis[i] || sum < m) {
        if(vis[i] == false) sum++;
        for(int j = 1;j <= n;j++)
            printf("%lld %lld\n",j,(i - j + 2 * n - 1) % n + 1);
    }
}
```

#### 题解3：未来姚班zyl (4星)
**关键亮点**：
- 通过分析题目特征，提出了斜线构造的思路，并详细解释了如何选择 $m$ 条斜线。
- 代码实现较为复杂，但思路清晰。

**核心代码**：
```cpp
for(auto k:p){
    repn(i)ans.pb({(i+k-1)%n+1,i});
}
cout <<n*m<<'\n';
for(auto y:ans)cout <<y.x<<' '<<y.y<<'\n';
```

### 最优关键思路与技巧
1. **斜线构造法**：通过选择满足 $i+j \equiv k \pmod{n}$ 的点填 $1$，确保每行每列的和为 $m$。
2. **处理给定点**：确保给定的点必须为 $1$，并通过选择其他 $k$ 值来补足 $m$ 个。
3. **时间复杂度优化**：大多数题解的时间复杂度为 $O(nm)$，能够高效解决问题。

### 拓展思路
类似的问题可以通过斜线构造法来解决，尤其是在需要每行每列的和为某个固定值的情况下。这种方法可以推广到其他矩阵构造问题中。

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
3. [P1010 过河卒](https://www.luogu.com.cn/problem/P1010)

### 个人心得总结
- **调试经历**：部分题解提到了在赛时通过随机化或置换来解决冲突问题，但最终发现斜线构造法更为高效。
- **踩坑教训**：在处理给定点时，必须确保这些点的 $k$ 值被选中，否则无法满足条件。
- **顿悟感想**：通过斜线构造法，可以轻松解决每行每列和为固定值的矩阵构造问题，思路清晰且代码简洁。

---
处理用时：54.25秒
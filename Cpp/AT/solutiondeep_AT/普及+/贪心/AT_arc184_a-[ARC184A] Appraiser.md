# 题目信息

# [ARC184A] Appraiser

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc184/tasks/arc184_a

この問題は **インタラクティブ** な問題であり、 **ジャッジは適応的(adaptive)** です。詳しくは注意点を参照してください。  
**また、問題文中のパラメータは $ N=1000,M=10,Q=950 $ で固定されています。**

硬貨が $ N $ 枚あり、 $ 1,2,\dots,N $ の番号が付けられています。  
これらの硬貨のうち、丁度 $ M $ 枚が偽物です。

鑑定士は $ 1 $ 度の鑑定で $ 2 $ つの硬貨が同種か異種かを判定できます。厳密には、

- $ 2 $ つの硬貨が「双方とも本物」「双方とも偽物」のどちらかであれば、同種と判定する。
- そうでないとき、異種と判定する。

$ Q $ 回以下の鑑定で、全ての偽物の硬貨を特定してください。

### Input &amp; Output Format

この問題はインタラクティブな問題です。  
最初に、 $ N,M,Q $ を標準入力から受け取ってください。

> $ N $ $ M $ $ Q $

次に、以下の流れで鑑定を $ 0 $ 回以上 $ Q $ 回以下行ってください。

まず、次の形式で標準出力に出力することで、硬貨 $ x,y $ を鑑定することを表します。 (末尾に改行を入れること。)

> ? $ x $ $ y $

ここで、 $ x,y $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。

これに対するジャッジシステムの応答は、以下の $ 3 $ 通りです。

```
0
```

応答が `0` であるとき、硬貨 $ x,y $ が同種であることを表します。

```
1
```

応答が `1` であるとき、硬貨 $ x,y $ が異種であることを表します。

```
-1
```

応答が `-1` であるとき、不当な鑑定であることを表します。具体的には

- 出力した $ x,y $ が制約を満たさなかった
- $ Q $ 回を超えて鑑定が行われた

の少なくともひとつが満たされた際にこの応答を行います。  
この応答を受け取った場合、プログラムはすでに不正解とみなされています。直ちにプログラムを終了してください。

最後に、次の形式で標準出力に出力することで、硬貨 $ A_1,A_2,\dots,A_{M} $ が偽物であると解答します。 (末尾に改行を入れること。)

> ! $ A_1 $ $ A_2 $ $ \dots $ $ A_{M} $

ここで、 $ A_i $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。  
この出力の後、直ちにプログラムを終了してください。

なお、全ての出力について、出力が指定された形式を満たさなかった場合もプログラムが不正解とみなされます。 その後 `-1` が返答されるので、その場合も直ちにプログラムを終了してください。

## 说明/提示

### 制約

- $ \color{red}{N\ =\ 1000} $
- $ \color{red}{M\ =\ 10} $
- $ \color{red}{Q\ =\ 950} $

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。** そうしなかった場合、ジャッジ結果が TLE や WA となる可能性があります。
- 解答を出力したら (または `-1` を受け取ったら) ただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください。
- **この問題のジャッジシステムは、適応的(adaptive)です。** つまり、ジャッジシステムは、任意のタイミングにおいて、整合性がとれる限り、偽物の硬貨として想定しているものを変更する可能性があります。詳しくは入出力例も参照してください。

### 入出力例

この入力では $ N=5,M=2,Q=10 $ であり、ジャッジシステムは最初硬貨 $ 1,2 $ が偽物であると想定しています。

なお、この例は制約を満たさないので、ジャッジには含まれないことに注意してください。

入力出力説明`5 2 10`$ N,M,Q $ が与えられます。`? 1 2`硬貨 $ 1,2 $ について鑑定を行います。`0`硬貨 $ 1,2 $ は同種だと判定します。`? 1 3`硬貨 $ 1,3 $ について鑑定を行います。`1`硬貨 $ 1,3 $ は異種だと判定します。`? 1 4`硬貨 $ 1,4 $ について鑑定を行います。`1`硬貨 $ 1,4 $ は異種だと判定します。`! 1 2`硬貨 $ 1,2 $ が偽物だと解答します。確かに硬貨 $ 1,2 $ は偽物だと想定されていますが、硬貨 $ 3,4 $ を偽物であると想定しても整合性が取れます。  
よって、ジャッジシステムは偽物の硬貨として想定しているものを硬貨 $ 3,4 $ に変更できます。  
これにより、ジャッジシステムは不正解の判定を下すこともあります。

# AI分析结果

### 题目内容重写

#### [ARC184A] Appraiser

**题目描述**

这是一个**交互式**问题，**评测系统是自适应的**。详情请参见注意事项。  
**此外，问题中的参数固定为 $N=1000, M=10, Q=950$。**

有 $N$ 枚硬币，编号为 $1,2,\dots,N$。  
这些硬币中，恰好有 $M$ 枚是假币。

鉴定师每次可以鉴定两枚硬币是否为同种类型。具体来说：

- 如果两枚硬币“都是真币”或“都是假币”，则鉴定为同种。
- 否则，鉴定为异种。

在不超过 $Q$ 次鉴定的情况下，找出所有假币。

**输入输出格式**

这是一个交互式问题。  
首先，从标准输入读取 $N, M, Q$。

> $N$ $M$ $Q$

接下来，进行不超过 $Q$ 次鉴定。每次鉴定时，输出以下格式：

> ? $x$ $y$

其中，$x, y$ 是 $1$ 到 $N$ 之间的不同整数。

评测系统的响应有以下三种：

```
0
```

响应为 `0` 时，表示硬币 $x, y$ 是同种。

```
1
```

响应为 `1` 时，表示硬币 $x, y$ 是异种。

```
-1
```

响应为 `-1` 时，表示鉴定无效。具体原因可能是：

- 输出的 $x, y$ 不符合要求
- 鉴定次数超过 $Q$ 次

收到 `-1` 后，程序应立即终止。

最后，输出以下格式以提交答案：

> ! $A_1$ $A_2$ $\dots$ $A_{M}$

其中，$A_i$ 是 $1$ 到 $N$ 之间的不同整数。  
输出后，程序应立即终止。

**注意事项**

- **每次输出后，必须换行并刷新输出缓冲区。** 否则可能导致 TLE 或 WA。
- 提交答案后（或收到 `-1` 后），程序应立即终止。
- 多余的换行会被视为无效输出。
- **评测系统是自适应的。** 即，评测系统可以在任何时刻调整假币的分布，只要保持一致性。

### 题解分析与结论

#### 综合分析与结论

该问题的核心在于如何在有限的鉴定次数内高效地找出所有假币。由于假币数量较少（$M=10$），且总硬币数较大（$N=1000$），直接逐个鉴定显然不可行。因此，题解大多采用分组策略，通过比较组内硬币的性质来减少鉴定次数。

**关键思路与技巧：**
1. **分组策略**：将硬币分成若干组，每组通过少量鉴定确定组内硬币的性质。常见的分组大小为 $11$，因为假币数量较少，可以确保每组中至少有一个真币。
2. **基准比较**：通过找到一个已知的真币，作为基准与其他硬币进行比较，从而确定其他硬币的真伪。
3. **自适应处理**：由于评测系统是自适应的，题解需要考虑如何在假币分布可能变化的情况下，依然能够正确找出所有假币。

**最优策略总结：**
- 将硬币分成 $90$ 组，每组 $11$ 枚硬币，剩余 $10$ 枚单独处理。
- 每组通过 $10$ 次鉴定确定组内硬币的性质。
- 利用已知的真币作为基准，与其他组的硬币进行比较，确定假币的位置。
- 总鉴定次数不超过 $920$ 次，满足 $Q=950$ 的限制。

### 高星题解推荐

#### 题解1：作者：WuMin4 (4星)

**关键亮点：**
- 采用分组策略，每组 $11$ 枚硬币，通过 $10$ 次鉴定确定组内性质。
- 利用已知的真币作为基准，与其他组的硬币进行比较，确定假币的位置。
- 代码简洁，逻辑清晰，鉴定次数控制在 $919$ 次以内。

**核心代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,q,nst;
bool ys[1005][1005],ist[1005];
vector<int> fk;
bool cp;
signed main() {
    cin>>n>>m>>q;
    for(int i=1;i<=1000;i+=11){
        for(int x,j=i+1;j<=min(1000,i+10);j++){
            cout<<"? "<<i<<" "<<j<<endl;
            cin>>x;
            if(x==1)
                ys[i][j]=true,ist[i]=true,cp=true;
        }
        if(!ist[i])
            nst=i;
    }
    if(!cp){
        cout<<"! ";
        for(int i=991;i<=1000;i++)
            cout<<i<<" ";
        cout<<endl;
        return 0;
    }
    for(int x,i=1;i<=1000;i+=11){
        if(!ist[i]) continue;
        cout<<"? "<<nst<<" "<<i<<endl;
        cin>>x;
        if(x) fk.push_back(i);
        for(int j=i+1;j<=min(1000,i+10);j++){
            if(ys[i][j]^x)
                fk.push_back(j);
        }
    }
    cout<<"! ";
    for(int v:fk)
        cout<<v<<" ";
    cout<<endl;
    return 0; 
}
```

#### 题解2：作者：MrPython (4星)

**关键亮点：**
- 采用分组策略，每组 $11$ 枚硬币，通过 $10$ 次鉴定确定组内性质。
- 利用已知的真币作为基准，与其他组的硬币进行比较，确定假币的位置。
- 代码结构清晰，鉴定次数控制在 $920$ 次以内。

**核心代码：**
```cpp
#include <bits/extc++.h>
using namespace std;
namespace pbds = __gnu_pbds;
istream& fin = cin;
ostream& fout = cout;
using ui = unsigned int;
using uli = unsigned long long int;
using li = long long int;
bool ask(size_t x, size_t y) {
  fout << "? " << x + 1 << ' ' << y + 1 << endl;
  bool res;
  fin >> res;
  return res;
}
int main(void) {
  ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
  size_t n, m, q;
  fin >> n >> m >> q;
  size_t target = ~0;
  vector<vector<bool>> d;
  vector<size_t> special;
  for (ui i = 0; i + m + 1 <= n; i += m + 1) {
    d.emplace_back();
    for (ui j = 0; j < m; ++j) d.back().emplace_back(ask(i + j, i + j + 1));
    if (count(d.back().begin(), d.back().end(), true))
      special.emplace_back(d.size() - 1);
    else
      target = i;
  }
  vector<size_t> ans;
  for (size_t i : special) {
    bool lst = ask(i * (m + 1), target);
    if (lst) ans.emplace_back(i * (m + 1));
    for (size_t j = 0; j < m; ++j)
      if (lst ^= d[i][j]) ans.emplace_back(i * (m + 1) + j + 1);
  }
  for (size_t i = n - n % (m + 1); i < n; ++i)
    if (ask(target, i)) ans.emplace_back(i);
  assert(ans.size() == m);
  fout << "! ";
  for (size_t i : ans) fout << i + 1 << ' ';
  return 0;
}
```

### 推荐题目

1. **洛谷 P1003 铺地毯** - 考察分组与覆盖问题。
2. **洛谷 P1048 采药** - 考察动态规划与资源分配。
3. **洛谷 P1060 开心的金明** - 考察贪心与优化策略。

### 个人心得总结

- **调试经历**：在处理交互式问题时，输出格式和缓冲区刷新是关键，否则容易导致 TLE 或 WA。
- **踩坑教训**：自适应评测系统意味着假币分布可能随时变化，因此在设计算法时需要考虑这一点，确保算法的鲁棒性。
- **顿悟感想**：分组策略在处理大规模数据时非常有效，尤其是在数据分布不均匀的情况下，可以显著减少计算量。

---
处理用时：70.05秒
# 题目信息

# 長いだけのネクタイ (Just Long Neckties)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_a

あなたは Just Odd Inventions 社を知っているだろうか？この会社の業務は「ただ奇妙な発明 (just odd inventions)」をすることである．ここでは略して JOI 社と呼ぶ．

JOI 社は新商品「長いだけのネクタイ」を開発した．ネクタイは $ N\ +\ 1 $ 種類あり，各種類には $ 1 $ から $ N\ +\ 1 $ までの番号がついている．$ i $ 番目 ($ 1\ \leqq\ i\ \leqq\ N\ +\ 1 $) の種類のネクタイの長さは $ A_i $ である．

JOI 社は社員を集め，ネクタイの試着会を行うことにした．試着会には $ N $ 人の社員が参加し，$ j $ 人目 ($ 1\ \leqq\ j\ \leqq\ N $) の社員がはじめに付けているネクタイの長さは $ B_j $ である．

試着会は以下の手順で行われる予定である．

1. まず，試着会で使わないネクタイを $ 1 $ 種類選ぶ．
2. 次に，各社員はそれ以外のネクタイから試着するネクタイを $ 1 $ 種類選ぶ．ただし，どの $ 2 $ 人も同じ種類のネクタイを選ばないようにする．
3. 最後に，各社員は今付けているネクタイを外し，先ほど選んだネクタイを試着する．

長さ $ b $ のネクタイを付けていた社員が，長さ $ a $ のネクタイを試着すると大きさ $ \max\{a\ −\ b,\ 0\} $ の奇妙さを感じる．(ここで，$ \max\{a\ −\ b,\ 0\} $ は，$ a\ -\ b $ と $ 0 $ のうち小さくない方を表す．) 試着会において各社員の感じる奇妙さの最大値を，その試着会の**奇妙さ**とする．

試着会で使わないネクタイが $ k $ 番目の種類のネクタイのとき，試着会の奇妙さとして考えられる最小の値を $ C_k $ とする．

各種類のネクタイの長さ，各社員がはじめに付けているネクタイの長さが与えられた時，$ C_1,\ C_2,\ \ldots,\ C_{N\ +\ 1} $ の値を求めるプログラムを作成せよ．

- - - - - -

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 200\,000 $.
- $ 1\ \leqq\ A_i\ \leqq\ 1\,000\,000\,000 $ ($ 1\ \leqq\ i\ \leqq\ N\ +\ 1 $)．
- $ 1\ \leqq\ B_j\ \leqq\ 1\,000\,000\,000 $ ($ 1\ \leqq\ j\ \leqq\ N $)．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 10 $.
2. ($ 8 $ 点) $ N\ \leqq\ 2\,000 $.
3. ($ 91 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

例えば，試着会は次のように行われる． - $ 4 $ 番目の種類のネクタイを使わないことにする． - 社員 $ 1 $ が $ 1 $ 番目の，社員 $ 2 $ が $ 2 $ 番目の，社員 $ 3 $ が $ 3 $ 番目の種類のネクタイを選ぶ． - 各社員が試着する． このとき，各社員が感じる奇妙さは順に $ 2,\ 0,\ 3 $ となるから，この試着会の奇妙さは $ 3 $ である． 社員が選ぶネクタイを変えることで、試着会の奇妙さを $ 1 $ にすることができる．例えば，試着会を次のように行うとする． - $ 4 $ 番目の種類のネクタイを使わないことにする． - 社員 $ 1 $ が $ 2 $ 番目の，社員 $ 2 $ が $ 3 $ 番目の，社員 $ 3 $ が $ 1 $ 番目の種類のネクタイを選ぶ． - 各社員が試着する． このとき，各社員が感じる奇妙さは順に $ 1,\ 1,\ 0 $ となるから，この試着会の奇妙さは $ 1 $ である． これが $ 4 $ 番目の種類のネクタイを使わない場合の試着会の奇妙さの最小値なので，$ C_4\ =\ 1 $ である． - - - - - -

## 样例 #1

### 输入

```
3
4 3 7 6
2 6 4```

### 输出

```
2 2 1 1```

## 样例 #2

### 输入

```
5
4 7 9 10 11 12
3 5 7 9 11```

### 输出

```
4 4 3 2 2 2```

# AI分析结果

### 题目内容重写（中文）

**题目描述**

你听说过 Just Odd Inventions 公司吗？这家公司的业务是“仅仅进行奇妙的发明”（just odd inventions）。我们简称它为 JOI 公司。

JOI 公司开发了一款新产品“仅仅很长的领带”。领带有 $N + 1$ 种类型，每种类型都有一个从 $1$ 到 $N + 1$ 的编号。第 $i$ 种类型（$1 \leq i \leq N + 1$）的领带长度为 $A_i$。

JOI 公司召集了员工，准备举办一场领带试戴会。试戴会有 $N$ 名员工参加，第 $j$ 名员工（$1 \leq j \leq N$）最初佩戴的领带长度为 $B_j$。

试戴会按以下步骤进行：

1. 首先，选择一种不用于试戴的领带类型。
2. 然后，每位员工从剩下的领带中选择一种进行试戴。要求任何两位员工不能选择同一种领带。
3. 最后，每位员工取下当前佩戴的领带，试戴刚才选择的领带。

如果一位员工原本佩戴的领带长度为 $b$，试戴的领带长度为 $a$，那么他会感受到大小为 $\max\{a - b, 0\}$ 的“奇妙感”。（这里 $\max\{a - b, 0\}$ 表示 $a - b$ 和 $0$ 中的较大值。）试戴会的“奇妙感”定义为所有员工感受到的奇妙感的最大值。

假设不用于试戴的领带类型为第 $k$ 种，试戴会的“奇妙感”最小可能值为 $C_k$。

给定各种领带的长度和每位员工最初佩戴的领带长度，请编写程序计算 $C_1, C_2, \ldots, C_{N + 1}$ 的值。

### 题解分析与结论

#### 综合分析与结论

该题的核心是通过贪心策略，将 $A$ 数组和 $B$ 数组排序后，通过前缀最大值和后缀最大值的预处理，快速计算每次去掉一个 $A_i$ 后的最小“奇妙感”。大多数题解都采用了类似的思路，即通过排序和预处理来优化计算过程。

#### 最优关键思路与技巧

1. **排序与贪心**：将 $A$ 和 $B$ 数组排序后，通过贪心策略使得 $A_i$ 和 $B_i$ 的差值最小化，从而减少“奇妙感”。
2. **前缀最大值与后缀最大值**：通过预处理前缀最大值和后缀最大值，快速计算去掉某个 $A_i$ 后的最小“奇妙感”。
3. **结构体记录原始索引**：由于排序后需要恢复原始顺序，使用结构体记录原始索引，方便最终输出。

#### 可拓展之处

该题的思路可以拓展到其他需要优化匹配或分配的问题，例如任务分配、资源调度等。类似的问题可以通过排序和预处理来优化计算。

### 推荐题目

1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

### 精选题解

#### 题解1：作者：DgNeHzL7777 (赞：1)

**星级：4.5**

**关键亮点**：
- 通过结构体记录原始索引，方便排序后恢复顺序。
- 使用前缀最大值和后缀最大值进行快速计算。
- 代码清晰，注释详细，易于理解。

**核心代码**：
```cpp
for(int i=1; i<=n; ++i) {
    d[i]=a[i+1].d-b[i];
    maxx[i]=max(maxx[i-1],a[i].d-b[i]);
}
ans[a[n+1].id]=maxx[n];
maxxx=d[n];
for(int i=n; i>=1; --i) {
    ans[a[i].id]=max(maxxx,maxx[i-1]);
    maxxx=max(maxxx,d[i-1]);
}
```

#### 题解2：作者：Wan__Ye__Chu (赞：0)

**星级：4**

**关键亮点**：
- 通过排序和贪心策略，优化了计算过程。
- 使用前缀最大值和后缀最大值进行快速计算。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1; i<=n; i++) {
    c[i]=max(c[i-1],a[i]-b[i]);
    d[n-i+1]=max(d[n-i+2],a[n-i+2]-b[n-i+1]);	
}
for(int i=1; i<=n+1; i++) {
    int qwq=max(c[i-1],d[i]);
    QAQ[i]=max(qwq,0);
}
```

#### 题解3：作者：IkunTeddy (赞：0)

**星级：4**

**关键亮点**：
- 通过结构体记录原始索引，方便排序后恢复顺序。
- 使用前缀最大值和后缀最大值进行快速计算。
- 代码逻辑清晰，易于理解。

**核心代码**：
```cpp
for(int i=1; i<=n; i++) {
    int j=n-i+1;
    pre[i]=max(pre[i-1],a[i].v-b[i]);
    next[j]=max(next[j+1],a[j+1].v-b[j]);
}
for(int i=1; i<=n+1; i++) {
    ans[a[i].id]=max(pre[i-1],next[i]);
}
```

### 个人心得

- **调试经历**：在处理前缀最大值和后缀最大值时，需要注意边界条件，避免数组越界。
- **顿悟感想**：通过排序和预处理，可以大大减少计算复杂度，贪心策略在此类问题中非常有效。

---
处理用时：46.71秒
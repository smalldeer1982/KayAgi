# 题目信息

# [ABC321E] Complete Binary Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc321/tasks/abc321_e

$ 1 $ から $ N $ までの番号が付けられた $ N $ 頂点からなる木があります。 各 $ i\ (2\ \leq\ i\ \leq\ N) $ について、頂点 $ i $ と頂点 $ \lfloor\ \frac{i}{2}\ \rfloor $ を結ぶ辺が張られています。 逆に、これら以外の辺は存在しません。

この木において、頂点 $ X $ との距離が $ K $ である頂点の数を求めてください。 ただし、$ 2 $ 頂点 $ u,v $ の距離は、頂点 $ u,v $ を結ぶ単純パスに含まれる辺の個数として定義されます。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\leq\ T\ \leq\ 10^5 $
- $ 1\leq\ N\ \leq\ 10^{18} $
- $ 1\leq\ X\ \leq\ N $
- $ 0\leq\ K\ \leq\ N-1 $
- 入力は全て整数
 
### Sample Explanation 1

$ N=10 $ のとき、木は以下の図のようになります。 !\[\](https://img.atcoder.jp/abc321/0d1a718458ffcf25a6bc26d11b3a7641.png) このとき、 - 頂点 $ 2 $ との距離が $ 0 $ である頂点は $ 2 $ の $ 1 $ つです。 - 頂点 $ 2 $ との距離が $ 1 $ である頂点は $ 1,4,5 $ の $ 3 $ つです。 - 頂点 $ 2 $ との距離が $ 2 $ である頂点は $ 3,8,9,10 $ の $ 4 $ つです。 - 頂点 $ 2 $ との距離が $ 3 $ である頂点は $ 6,7 $ の $ 2 $ つです。 - 頂点 $ 2 $ との距離が $ 4 $ である頂点は存在しません。

## 样例 #1

### 输入

```
5

10 2 0

10 2 1

10 2 2

10 2 3

10 2 4```

### 输出

```
1

3

4

2

0```

## 样例 #2

### 输入

```
10

822981260158260522 52 20

760713016476190629 2314654 57

1312150450968417 1132551176249851 7

1000000000000000000 1083770654 79

234122432773361868 170290518806790 23

536187734191890310 61862 14

594688604155374934 53288633578 39

1000000000000000000 120160810 78

89013034180999835 14853481725739 94

463213054346948152 825589 73```

### 输出

```
1556480

140703128616960

8

17732923532771328

65536

24576

2147483640

33776997205278720

7881299347898368

27021597764222976```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个由 $1$ 到 $N$ 编号的 $N$ 个顶点的树。对于每个 $i\ (2\ \leq\ i\ \leq\ N)$，顶点 $i$ 和顶点 $\lfloor\ \frac{i}{2}\ \rfloor$ 之间有一条边相连。除此之外，没有其他边。

在这棵树中，求与顶点 $X$ 的距离为 $K$ 的顶点的数量。其中，两个顶点 $u,v$ 之间的距离定义为连接 $u,v$ 的简单路径上的边的数量。

给定 $T$ 个测试用例，请对每个测试用例输出答案。

#### 说明/提示

##### 约束

- $1\leq\ T\ \leq\ 10^5$
- $1\leq\ N\ \leq\ 10^{18}$
- $1\leq\ X\ \leq\ N$
- $0\leq\ K\ \leq\ N-1$
- 输入均为整数

##### 样例解释 1

当 $N=10$ 时，树的结构如下图所示：

![](https://img.atcoder.jp/abc321/0d1a718458ffcf25a6bc26d11b3a7641.png)

此时：
- 与顶点 $2$ 距离为 $0$ 的顶点是 $2$，共 $1$ 个。
- 与顶点 $2$ 距离为 $1$ 的顶点是 $1,4,5$，共 $3$ 个。
- 与顶点 $2$ 距离为 $2$ 的顶点是 $3,8,9,10$，共 $4$ 个。
- 与顶点 $2$ 距离为 $3$ 的顶点是 $6,7$，共 $2$ 个。
- 与顶点 $2$ 距离为 $4$ 的顶点不存在。

##### 样例 #1

###### 输入

```
5

10 2 0

10 2 1

10 2 2

10 2 3

10 2 4
```

###### 输出

```
1

3

4

2

0
```

##### 样例 #2

###### 输入

```
10

822981260158260522 52 20

760713016476190629 2314654 57

1312150450968417 1132551176249851 7

1000000000000000000 1083770654 79

234122432773361868 170290518806790 23

536187734191890310 61862 14

594688604155374934 53288633578 39

1000000000000000000 120160810 78

89013034180999835 14853481725739 94

463213054346948152 825589 73
```

###### 输出

```
1556480

140703128616960

8

17732923532771328

65536

24576

2147483640

33776997205278720

7881299347898368

27021597764222976
```

### 题解分析与结论

#### 综合分析

该题目要求在一棵完全二叉树中，找到与给定节点 $X$ 距离为 $K$ 的节点数量。由于 $N$ 的范围非常大（$10^{18}$），直接暴力搜索不可行。因此，所有题解都采用了基于二叉树性质的数学计算方法，通过递归或迭代的方式，逐步向上或向下遍历节点，计算符合条件的节点数量。

#### 关键思路与技巧

1. **完全二叉树性质**：利用完全二叉树的性质，节点 $i$ 的左子节点为 $2i$，右子节点为 $2i+1$，父节点为 $\lfloor i/2 \rfloor$。
2. **分层计算**：通过计算节点 $X$ 的子树中第 $K$ 层的节点数量，以及向上遍历祖先节点的子树中符合条件的节点数量。
3. **边界处理**：在处理子树时，需要判断节点是否超出 $N$ 的范围，避免无效计算。
4. **递归与迭代**：部分题解采用递归方式遍历子树，另一部分采用迭代方式，逐步向上遍历祖先节点。

#### 评分较高的题解

1. **Genius_Star (5星)**
   - **关键亮点**：通过递归和迭代结合的方式，清晰地处理了向下和向上遍历的节点计算，代码结构清晰，边界处理得当。
   - **代码核心**：
     ```cpp
     ll F(ll x,ll n,ll k){ //计算 x 号点向下走 k 条边能走到的点数
         if(k<0) return 0;
         ll l=x,r=x;
         for(int i=0;i<k;i++){
             l<<=1ll;
             r=r<<1ll|1ll;
             if(l>n) return 0;
         }
         return min(r,n)-l+1ll;
     }
     ```

2. **sunzz3183 (4星)**
   - **关键亮点**：通过分层计算子树中符合条件的节点数量，处理了满二叉树和普通完全二叉树的情况，代码逻辑清晰。
   - **代码核心**：
     ```cpp
     int solve(int u,int dis){
         if(u>n) return 0;
         int depu = get_dep(u);
         if(dis>dep-depu) return 0;
         int mn = u*qpow(2,dis),mx = mn+qpow(2,dis)-1;
         if(mx>n) mx = n; 
         if(mn>n||mx<mn) return 0;
         int res = mx-mn+1;
         return res;
     }
     ```

3. **liyujia (4星)**
   - **关键亮点**：通过递归处理子树中符合条件的节点数量，代码简洁，逻辑清晰，处理了边界情况。
   - **代码核心**：
     ```cpp
     int sub(int x, int k){//x 子树离 x 恰好 k 的点个数
         int l = n;
         if(x > n || k < 0) return 0;
         if(k == 0) return 1;
         if(x * 2 > n) return 0;
         for(int i = 1; i <= 61; i++)
             if(l == x)
                 return sub(x * 2, k - 1) + sub(x * 2 + 1, k - 1);
             else l /= 2;
         l = x;
         int dc = 0;
         while(l * 2 <= n) l *= 2, dc++;
         if(dc < k) return 0;
         return 1ll << k;
     }
     ```

### 最优关键思路总结

1. **利用完全二叉树的性质**：通过节点编号的规律，快速计算子节点和父节点。
2. **分层计算**：通过计算子树中第 $K$ 层的节点数量，结合向上遍历祖先节点的子树，确保不重复计算。
3. **边界处理**：在处理子树时，判断节点是否超出 $N$ 的范围，避免无效计算。

### 可拓展之处

1. **类似问题**：可以扩展到其他类型的树结构，如二叉搜索树、平衡二叉树等，计算距离为 $K$ 的节点数量。
2. **算法优化**：可以通过预处理或动态规划的方式，进一步优化计算过程，减少重复计算。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

### 个人心得摘录

- **Genius_Star**：通过递归和迭代结合的方式，清晰地处理了向下和向上遍历的节点计算，代码结构清晰，边界处理得当。
- **sunzz3183**：通过分层计算子树中符合条件的节点数量，处理了满二叉树和普通完全二叉树的情况，代码逻辑清晰。
- **liyujia**：通过递归处理子树中符合条件的节点数量，代码简洁，逻辑清晰，处理了边界情况。

---
处理用时：57.74秒
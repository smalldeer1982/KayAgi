# 题目信息

# [ABC159E] Dividing Chocolate

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc159/tasks/abc159_e

縦 $ H $ マス、横 $ W $ マスのグリッドに区切られたチョコレートがあります。

上から $ i $ 行目、左から $ j $ 列目にあるマス $ (i,j) $ のチョコレートは、$ S_{i,j} $ が `0` のとき普通のチョコレートであり、`1` のときホワイトチョコレートです。

このチョコレートに対して、マスの境界に沿った直線によってグリッド全体の端から端まで割る操作を何度か行い、いくつかのブロックに分割します。

分割後のどのブロックにもホワイトチョコレートのマスが $ K $ マス以下しか含まれないようにするためには、最小で操作を何回行う必要があるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 10 $
- $ 1\ \leq\ W\ \leq\ 1000 $
- $ 1\ \leq\ K\ \leq\ H\ \times\ W $
- $ S_{i,j} $ は `0` か `1`

### Sample Explanation 1

例えば左の図のように $ 1 $ 行目と $ 2 $ 行目の間と、$ 3 $ 列目と $ 4 $ 列目の間の $ 2 $ か所で割ればよいです。 右の2つの図のような割り方はできないことに注意してください。 !\[図\](https://img.atcoder.jp/ghi/ac90dd542639c04402125403b1c319d7.png)

### Sample Explanation 2

操作を行う必要はありません。

## 样例 #1

### 输入

```
3 5 4

11100

10001

00111```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5 8

11100

10001

00111```

### 输出

```
0```

## 样例 #3

### 输入

```
4 10 4

1110010010

1000101110

0011101001

1101000111```

### 输出

```
3```

# AI分析结果

### 题目翻译
有一个被划分为纵向 $H$ 格、横向 $W$ 格的巧克力。

从上往下第 $i$ 行、从左往右第 $j$ 列的格子 $(i, j)$ 中的巧克力，当 $S_{i, j}$ 为 `0` 时是普通巧克力，为 `1` 时是白巧克力。

对于这块巧克力，沿着格子的边界用直线从网格的一端切到另一端，进行若干次切割操作，将其分割成若干个小块。

为了使分割后的每个小块中白巧克力的格子数量不超过 $K$ 个，最少需要进行多少次切割操作？

### 综合分析与结论
这些题解的核心思路都是利用数据范围 $H$ 较小（$1 \leq H \leq 10$）的特点，先枚举所有横向切割的可能情况（时间复杂度 $O(2^H)$），再针对每种横向切割情况，使用贪心算法确定纵向切割的最少次数（时间复杂度 $O(W \times H)$），最终取所有情况中的最小切割次数作为答案。

算法要点主要包括：
1. **二进制枚举**：利用二进制来表示横向切割的所有可能组合。
2. **贪心算法**：在确定纵向切割时，尽可能让每一块包含更多的列，直到白巧克力数量超过 $K$ 时再进行切割。
3. **前缀和优化**：使用前缀和数组来快速计算某个区域内白巧克力的数量。

解决的难点在于：
1. **判断无解情况**：如果某一列单独存在时白巧克力数量就超过 $K$，则该横向切割方案无解。
2. **处理不同区域的白巧克力数量**：在纵向扫描时，需要准确统计每个横向切割区域内的白巧克力数量。

### 所选题解
- **作者：banned_xiejiayun（5星）**
    - **关键亮点**：思路清晰，详细阐述了二进制枚举和贪心算法的结合，代码注释丰富，时间复杂度分析准确。
    - **核心代码**：
```cpp
int cnt(){
    int _ans=0;//对于这种方案的纵向切割
    int tot=1;//上一次切割的位置+1
    for(int i=1;i<=m;i++){
        int check=0;//检验变量，统计每个区域 1 的个数
        for(int j=1;j<=n;j++){
            check+=s[j][i]-s[j][tot-1];
            if(tot==i&&check>k){
                return 0x7ffffff;
                //如果但是这一列都超出了 k 的大小的话，就没戏了
            }
            if(check>k){
                _ans++;
                tot=i;
                check=0;//注意归零
            }
            if(flag[j]){
                check=0;//从下一行开始，就不属于这个区域了
            }
        }
    }
    return _ans;
}
signed main(){
    // ... 输入处理 ...
    //子集枚举：
    int U=1<<(n-1);
    for(int i=0;i<U;i++){
        int ii=i,now=n-1,sum=0;
        memset(flag,0,sizeof(flag));
        while(ii){
            if(ii%2){
                flag[now]=1;//标记那些位置切了一刀
                sum++;//统计横向切了几刀
            }
            ii/=2;now--;
        }
        ans=min(ans,cnt()+sum);
    }
    cout<<ans;
    return 0;
}
```
- **作者：lihongqian__int128（4星）**
    - **关键亮点**：使用深度优先搜索（DFS）枚举横向切割情况，结合二维前缀和计算区域内白巧克力数量，代码结构清晰。
    - **核心代码**：
```cpp
void dfs(int step , int sum)
{
    if(step == h)
    {
        p[h] = 1;
        int lw = 0;
        int cnt = 0;
        for(int j = 1 ; j <= w ; j++)
        {
            int lr = 0;
            for(int i = 1 ; i <= h ; i++)
            {
                if(p[i])
                {
                    int c = s[i][j] - s[i][lw] - s[lr][j] + s[lr][lw];
                    if(c > k)
                    {
                        if(j == lw + 1) return ;
                        else
                        {
                            cnt++ ;
                            lw = j - 1 ;
                            break ;
                        }
                    }
                    lr = i ;
                }
            }
        }
        minn = min(minn , cnt + sum) ;
        return ;
    }
    p[step] = 1 ;
    dfs(step + 1 , sum + 1) ;
    p[step] = 0 ;
    dfs(step + 1 , sum) ;
}
```
- **作者：Scintilla（4星）**
    - **关键亮点**：使用前缀和数组统计白巧克力数量，在枚举横向切割情况时，通过贪心算法确定纵向切割次数，代码简洁。
    - **核心代码**：
```cpp
int Get(int c, int l, int r) {
    return sum[r][c] - sum[l - 1][c];
}
int main() {
    // ... 输入处理 ...
    int MAX = (1 << (h - 1)) - 1;
    Rep(i, 0, MAX) {
        memset(now, 0, sizeof(now));
        tot = 0; int tp_ans = 0;
        Rep(j, 0, h - 2) {
            if (i & (1 << j)) pos[++tot] = j + 1;
        }
        tp_ans = tot, pos[++tot] = h;
        bool failed = false;
        Rep(j, 1, w) {
            Rep(k, 1, tot) {
                tp[k] = Get(j, pos[k - 1] + 1, pos[k]);
                if (tp[k] > K) {failed = true; break;}
            }
            if (failed) break;
            Rep(k, 1, tot) {
                now[k] += tp[k];
                if (now[k] > K) {
                    Rep(l, 1, tot) now[l] = tp[l];
                    ++tp_ans; break;
                }
            }
        }
        if (failed) continue;
        ans = min(ans, tp_ans);
    } 
    return printf("%d", ans) & 0;
}
```

### 最优关键思路或技巧
1. **二进制枚举**：利用二进制的特性，将横向切割的所有可能组合用二进制数表示，方便枚举。
2. **贪心算法**：在纵向切割时，每次尽可能让更多的列包含在当前块中，直到白巧克力数量超过 $K$ 才进行切割，保证切割次数最少。
3. **前缀和优化**：使用前缀和数组可以在 $O(1)$ 时间内计算出某个区域内白巧克力的数量，提高效率。

### 可拓展之处
同类型题或类似算法套路：
1. 二维矩阵的分割问题，如将矩阵分割成若干个小块，要求每个小块满足一定的条件（如元素和、元素个数等）。
2. 枚举与贪心结合的问题，先枚举所有可能的情况，再针对每种情况使用贪心算法求解最优解。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：考察贪心算法和动态规划。
2. [P1216 [USACO1.5] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：考察动态规划和递推。
3. [P1002 [NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)：考察动态规划和路径计数。

### 个人心得摘录与总结
- **君のNOIP。**：考场因为没特判无解的情况，22个点WA了2个导致暴零。总结：在解题时，一定要考虑到所有可能的边界情况，特别是无解的情况，避免因细节问题丢分。

---
处理用时：48.60秒
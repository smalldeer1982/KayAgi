# 题目信息

# [ABC313E] Duplicate

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc313/tasks/abc313_e

`1` から `9` までの数字からなる文字列 $ S $ に対して、 $ f(S) $ を次の手順によって得られる文字列 $ T $ とします。($ S_i $ は $ S $ の $ i $ 番目の文字を意味します)

- 文字列 $ T $ がある。はじめ、$ T $ は空文字列である。
- $ i=1,\ 2,\ \dots,\ |S|\ -\ 1 $ の順に次の操作を行う。 
  - $ S_{i+1} $ を整数として解釈したときの値を $ n $ とする。$ T $ の末尾に $ S_i $ を $ n $ 個追加する。

例えば $ S\ = $ `313` のとき、以下の手順によって $ f(S)\ = $ `3111` に決まります。

- はじめ $ T $ は空文字列である。
- $ i=1 $ のとき $ n\ =\ 1 $ である。$ T $ に `3` を $ 1 $ 個追加する。$ T $ は `3` になる。
- $ i=2 $ のとき $ n\ =\ 3 $ である。$ T $ に `1` を $ 3 $ 個追加する。$ T $ は `3111` になる。
- 操作を終了する。$ T $ として `3111` を得る。

`1` から `9` までの数字からなる長さ $ N $ の文字列 $ S $ が与えられます。  
あなたは「$ S $ を $ f(S) $ に置き換える」という操作を $ S $ の長さが $ 1 $ になるまで繰り返します。  
操作が終了するまでに行う操作を行う回数を $ 998244353 $ で割った余りを求めてください。ただし、操作が無限に続く場合は `-1` を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^6 $
- $ S $ は `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9` からなる長さ $ N $ の文字列

### Sample Explanation 1

$ S\ = $ `313` の場合、操作を $ 4 $ 回行うと $ S $ の長さが $ 1 $ になります。 
- $ f(S)\ = $ `3111` である。$ S $ を `3111` に置き換える。 
- $ f(S)\ = $ `311` である。$ S $ を `311` に置き換える。 
- $ f(S)\ = $ `31` である。$ S $ を `31` に置き換える。 
- $ f(S)\ = $ `3` である。$ S $ を `3` に置き換える。 
- $ S $ の長さが $ 1 $ になったので操作を終了する。

### Sample Explanation 2

$ S\ = $ `123456789` の場合、操作が無限に続きます。この場合は `-1` を出力してください。

## 样例 #1

### 输入

```
3
313```

### 输出

```
4```

## 样例 #2

### 输入

```
9
123456789```

### 输出

```
-1```

## 样例 #3

### 输入

```
2
11```

### 输出

```
1```

# AI分析结果

### 题目翻译
#### [ABC313E] 重复操作

#### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc313/tasks/abc313_e

对于一个由 `1` 到 `9` 组成的字符串 $S$，定义 $f(S)$ 为通过以下步骤得到的字符串 $T$（$S_i$ 表示 $S$ 的第 $i$ 个字符）：
- 有一个字符串 $T$，初始时，$T$ 为空字符串。
- 按 $i = 1, 2, \dots, |S| - 1$ 的顺序依次执行以下操作：
  - 设将 $S_{i + 1}$ 按整数解释时的值为 $n$，在 $T$ 的末尾添加 $n$ 个 $S_i$。

例如，当 $S =$ `313` 时，通过以下步骤可确定 $f(S) =$ `3111`：
- 初始时，$T$ 为空字符串。
- 当 $i = 1$ 时，$n = 1$，向 $T$ 中添加 $1$ 个 `3`，此时 $T$ 变为 `3`。
- 当 $i = 2$ 时，$n = 3$，向 $T$ 中添加 $3$ 个 `1`，此时 $T$ 变为 `3111`。
- 操作结束，得到 $T$ 为 `3111`。

给定一个由 `1` 到 `9` 组成的长度为 $N$ 的字符串 $S$，你需要重复执行“将 $S$ 替换为 $f(S)$”的操作，直到 $S$ 的长度变为 $1$。请计算操作结束前执行的操作次数，并将结果对 $998244353$ 取模后输出。如果操作会无限进行下去，则输出 `-1`。

#### 说明/提示
##### 限制条件
- $2 \leq N \leq 10^6$
- $S$ 是一个由 `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9` 组成的长度为 $N$ 的字符串

##### 样例解释 1
当 $S =$ `313` 时，执行 $4$ 次操作后 $S$ 的长度变为 $1$：
- $f(S) =$ `3111`，将 $S$ 替换为 `3111`。
- $f(S) =$ `311`，将 $S$ 替换为 `311`。
- $f(S) =$ `31`，将 $S$ 替换为 `31`。
- $f(S) =$ `3`，将 $S$ 替换为 `3`。
- 由于 $S$ 的长度变为 $1$，操作结束。

##### 样例解释 2
当 $S =$ `123456789` 时，操作会无限进行下去，此时应输出 `-1`。

#### 样例 #1
##### 输入
```
3
313
```
##### 输出
```
4
```

#### 样例 #2
##### 输入
```
9
123456789
```
##### 输出
```
-1
```

#### 样例 #3
##### 输入
```
2
11
```
##### 输出
```
1
```

### 综合分析与结论
这些题解的核心思路都是先判断操作是否会无限进行（即无解情况），再计算有解时将字符串长度变为 1 所需的操作次数。
- **无解判断**：所有题解都指出，当字符串中存在相邻两个字符都大于 `1` 时，操作会无限进行，此时输出 `-1`。
- **有解计算**：多数题解采用倒推的方法，从字符串的末尾开始，考虑每个字符对操作次数的贡献。对于每个大于 `1` 的字符，它会使前面连续 `1` 的数量增加，进而影响操作次数。

### 所选题解
1. **作者：FFTotoro（5星）**
    - **关键亮点**：思路清晰，详细分析了有解和无解的情况，并给出了具体的计数方法。代码简洁，注释清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n,c=0; string s; cin>>n>>s;
  for(int i=1;i<n;i++)
    if(min(s[i],s[i-1])>49)
      cout<<"-1\n",exit(0); // 判断无解
  int r=n-1;
  while(r>0){
    if(r>0&&s[r]>49){
      (++c)%=mod; // 加上删除它本身一位的贡献
      int x=0,d=s[r]-48; r--;
      while(r>0&&s[r]==49)r--,x++; // 找极长 1 连续段
      (c+=c*(d-1)%mod+x%mod)%=mod; // 算贡献
    }
    else while(r>0&&s[r]==49)r--,(++c)%=mod; // 特判
  }
  cout<<c<<endl;
  return 0;
}
```
    - **核心实现思想**：先判断无解情况，然后从右往左扫描字符串。遇到大于 `1` 的字符时，计算其对操作次数的贡献，同时找到前面的连续 `1` 段并计算其贡献；遇到连续 `1` 时，直接增加操作次数。

2. **作者：_liuyi_（5星）**
    - **关键亮点**：明确给出递推式，思路简洁明了。代码使用了常见的宏定义，提高了代码的可读性。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for(int i=a;i<=n;i++)
#define per(i,a,n) for(int i=n;i>=a;i--)
// 省略部分宏定义
const int N=1e6+10;
const int mod=998244353;
ll n,ans;
char s[N];
int main(){
	scanf("%lld%s",&n,s+1);
	rep(i,1,n-1){
		if(s[i]!='1'&&s[i+1]!='1'){
			puts("-1");
			return 0;
		}
	}
	per(i,2,n) ans=(ans+1)%mod*((int)s[i]-'0')%mod;
	printf("%lld\n",ans);
	return 0;
}
```
    - **核心实现思想**：先判断无解情况，然后从后往前遍历字符串，根据递推式 `ans=(ans+1) * S_i` 计算操作次数。

3. **作者：Crazyouth（4星）**
    - **关键亮点**：通过模拟样例分析无解情况，思路直观。代码结构清晰，易于理解。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=998244353;
int check(string s)//是否有解
{
	for(int i=1;i<s.size();i++) if(s[i]>'1'&&s[i-1]>'1') return 0;
	return 1;
}
int main()
{
	int n;
	cin>>n;
	string s;
	cin>>s;
	if(!check(s)) 
	{
		cout<<-1;
		return 0;
	}
	long long ans=0;
	for(int i=s.size()-1;i>0;i--)
	{
		ans++;//删自己
		ans+=ans*(s[i]-'1');//删多出来的1
		ans%=mod; //取模
	}
	cout<<ans;
	return 0;
}
```
    - **核心实现思想**：先使用 `check` 函数判断是否有解，若有解则从后往前遍历字符串，计算删除每个字符及其产生的额外 `1` 所需的操作次数。

### 最优关键思路或技巧
- **无解判断技巧**：通过观察发现，当字符串中存在相邻两个大于 `1` 的字符时，操作会无限进行，这是判断无解的关键。
- **倒推思想**：从字符串的末尾开始倒推，考虑每个字符对操作次数的贡献，将复杂的操作过程简化为递推计算。

### 可拓展之处
同类型题目可能会改变操作规则或增加额外的限制条件，例如改变字符串的字符范围、修改操作的具体方式等。解题时仍可采用类似的思路，先判断是否有解，再通过递推或模拟的方法计算结果。

### 洛谷相似题目推荐
1. [P1044 栈](https://www.luogu.com.cn/problem/P1044)：考察递推思想和栈的应用。
2. [P1226 快速幂取模运算](https://www.luogu.com.cn/problem/P1226)：涉及取模运算和快速幂算法，与本题的取模操作有相似之处。
3. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：可以通过模拟或递推的方法解决，锻炼逻辑思维和代码实现能力。

### 个人心得
题解中未包含个人心得相关内容。

---
处理用时：53.46秒
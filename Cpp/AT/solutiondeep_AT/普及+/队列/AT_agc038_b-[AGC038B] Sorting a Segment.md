# 题目信息

# [AGC038B] Sorting a Segment

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc038/tasks/agc038_b

すぬけくんは、$ (0,1,\cdots,N-1) $ の順列 $ (P_0,P_1,\cdots,P_{N-1}) $ を持っています。

すぬけくんは、以下の操作を**ちょうど $ 1 $ 回**だけ行います。

- $ P $ の連続する $ K $ 要素を選び、それらを昇順に並び替える。

操作後の $ P $ としてありうる順列の個数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 200000 $
- $ 2\ \leq\ K\ \leq\ N $
- $ 0\ \leq\ P_i\ \leq\ N-1 $
- $ P_0,P_1,\cdots,P_{N-1} $ はすべて異なる。
- 入力される値はすべて整数である。

### Sample Explanation 1

操作後の $ P $ としてありうる順列は、$ (0,1,2,4,3),(0,2,1,3,4) $ の $ 2 $ 個です。

## 样例 #1

### 输入

```
5 3

0 2 1 4 3```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4

0 1 2 3```

### 输出

```
1```

## 样例 #3

### 输入

```
10 4

2 0 1 3 7 5 4 6 8 9```

### 输出

```
6```

# AI分析结果

### 题目内容重写

#### 题目描述

すぬけくん有一个由 $0$ 到 $N-1$ 组成的排列 $P = (P_0, P_1, \cdots, P_{N-1})$。他可以进行**恰好一次**操作：

- 选择 $P$ 中连续的 $K$ 个元素，并将它们按升序排列。

求操作后 $P$ 可能的不同排列的个数。

#### 说明/提示

##### 约束

- $2 \leq N \leq 200000$
- $2 \leq K \leq N$
- $0 \leq P_i \leq N-1$
- $P_0, P_1, \cdots, P_{N-1}$ 互不相同。
- 输入的所有值均为整数。

##### 样例解释

**样例 1**  
输入：  
```
5 3
0 2 1 4 3
```  
输出：  
```
2
```  
解释：操作后的 $P$ 可能为 $(0,1,2,4,3)$ 或 $(0,2,1,3,4)$，共 $2$ 种。

**样例 2**  
输入：  
```
4 4
0 1 2 3
```  
输出：  
```
1
```  
解释：操作后的 $P$ 仍为 $(0,1,2,3)$，只有 $1$ 种。

**样例 3**  
输入：  
```
10 4
2 0 1 3 7 5 4 6 8 9
```  
输出：  
```
6
```

---

### 题解分析与结论

#### 综合分析与结论

本题的核心在于计算对长度为 $K$ 的连续子数组进行升序排序后，可能产生的不同排列的个数。由于直接枚举所有可能的子数组并排序会导致超时，因此需要优化。以下是各题解的要点总结：

1. **去重策略**：所有题解都提到了需要去重，主要分为两种情况：
   - 子数组本身已经是有序的，排序后不改变原数组。
   - 相邻的两个子数组排序后结果相同，即前一个子数组的最小值和后一个子数组的最大值分别位于子数组的边界。

2. **单调队列优化**：多个题解使用单调队列来高效计算子数组的最小值和最大值，从而判断是否需要去重。

3. **前缀和优化**：部分题解使用前缀和来快速判断子数组是否已经有序。

4. **并查集优化**：一个题解使用并查集来合并重复的情况，进一步优化了去重过程。

#### 最优关键思路

- **单调队列**：用于高效计算子数组的最小值和最大值，判断是否需要去重。
- **前缀和**：用于快速判断子数组是否已经有序。
- **并查集**：用于合并重复的排序结果，进一步优化去重。

#### 推荐题解

1. **作者：红尘万李 (赞：6)**  
   - **星级：4.5**  
   - **关键亮点**：详细分析了去重的两种情况，并使用单调队列和前缀和优化了计算过程。代码结构清晰，注释详细。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) {
         while(!q.empty()&&a[q.back()]<a[i]) q.pop_back();
         q.push_back(i);
         if(i>k) while(!q.empty()&&q.front()<i-k+1) q.pop_front();
         maxa[i]=a[q.front()]<=a[i];
     }
     ```

2. **作者：Limit (赞：4)**  
   - **星级：4**  
   - **关键亮点**：使用单调队列处理子数组的最小值和最大值，并通过前缀和判断子数组是否有序。代码简洁，逻辑清晰。
   - **核心代码**：
     ```cpp
     REP(i,1,n) {
         while(head<=tail&&arr[que[tail]]<arr[i]) --tail;
         que[++tail]=i;
         while(head<=tail&&k<i-que[head]) ++head;
         maxr[i]=arr[que[head]]<=arr[i];
     }
     ```

3. **作者：feecle6418 (赞：1)**  
   - **星级：4**  
   - **关键亮点**：使用单调栈和并查集优化了去重过程，代码简洁且高效。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n-K;i++) if(fl[i+K]<=i&&fr[i]>=i+K) Merge(i,i+1);
     ```

#### 推荐题目

1. **P1886 滑动窗口**：考察单调队列的应用，与本题的去重思路类似。
2. **P3374 树状数组 1**：考察前缀和的应用，与本题的前缀和优化思路相关。
3. **P3367 并查集**：考察并查集的应用，与本题的并查集优化思路相关。

#### 个人心得摘录

- **红尘万李**：通过图示详细解释了去重的两种情况，帮助理解单调队列的应用。
- **Limit**：强调了单调队列和前缀和的结合使用，使得代码更加简洁高效。
- **feecle6418**：通过并查集优化了去重过程，展示了如何将数据结构与算法结合使用。

---
处理用时：39.86秒
# 题目信息

# [ABC011C] 123引き算

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc011/tasks/abc011_3

あなたは、友人から、一人用のゲームを紹介されました。

最初に、数字 $ N $ が与えられます。 $ 1 $ , $ 2 $ , $ 3 $ の中から好きな数字を選び、 与えられた数字に対し、引き算を行う、という処理を行うことできます。

この処理は $ 100 $ 回まで行うことが可能であり、最終的に数字を $ 0 $ にすることが目標のゲームです。

しかし、計算途中でなってはいけないNG数字が $ 3 $ つ与えられており、 この数字に一時的にでもなってしまった瞬間、このゲームは失敗となります。 NG数字が $ N $ と同じ場合も失敗となります。

NG数字が $ N $ と同じ場合について、正しい判定が行われていませんでした。リジャッジを行いました。

あなたは、このゲームが、目標達成可能なゲームとなっているか調べたいです。

目標達成可能な場合は`YES`、そうでない場合は`NO`と出力してください。

## 说明/提示

### Sample Explanation 1

$ 2 $ を $ 1 $ 回引くことにより、 $ 0 $ を作ることが出来ます。

### Sample Explanation 2

最初に $ 2 $ を引き、次に $ 3 $ を引くことで、$ 5 $ → $ 3 $ → $ 0 $ と変化し、目標を達成することが出来ます。

### Sample Explanation 3

$ 100 $ 回連続で $ 3 $ を引かなければ、目標を達成することはできません。 しかし、 $ 3 $ だけを引き続けていると、途中でNG数字である $ 57 $ になってしまいます。

## 样例 #1

### 输入

```
2

1

7

15```

### 输出

```
YES```

## 样例 #2

### 输入

```
5

1

4

2```

### 输出

```
YES```

## 样例 #3

### 输入

```
300

57

121

244```

### 输出

```
NO```

# AI分析结果

### 题目内容重写
【题目描述】

你被介绍了一个单人游戏。游戏开始时，你会得到一个数字 $N$。你可以从 $1$、$2$、$3$ 中选择一个数字，并对 $N$ 进行减法操作。这个操作最多可以进行 $100$ 次，目标是将 $N$ 变为 $0$。

然而，游戏中有三个NG数字，如果在计算过程中 $N$ 变为任何一个NG数字，游戏就会失败。如果 $N$ 本身就是一个NG数字，游戏也会失败。

你需要判断这个游戏是否能够成功完成。如果能够成功，输出 `YES`，否则输出 `NO`。

### 算法分类
模拟

### 题解分析与结论
这道题的核心是通过模拟减法操作来判断是否能在100步内将 $N$ 变为 $0$，同时避免在过程中触及NG数字。题解中主要有以下几种思路：

1. **广度优先搜索（BFS）**：通过BFS遍历所有可能的减法操作，记录每一步的状态，避免重复搜索和负数状态。这种方法虽然思路清晰，但实现较为复杂，且时间复杂度较高。

2. **贪心算法**：优先减去最大的数（3），如果不行则尝试减去2，最后减去1。这种方法简单高效，且能够快速判断是否能够在100步内完成任务。

3. **动态规划（DP）**：通过状态转移方程记录每一步的可能性，判断是否能够在100步内将 $N$ 变为 $0$。这种方法虽然理论上可行，但实现较为复杂，且对于此题来说，贪心算法更为简洁。

4. **深度优先搜索（DFS）**：通过DFS遍历所有可能的减法操作，结合记忆化剪枝来减少重复计算。这种方法虽然能够解决问题，但实现起来较为复杂。

综合来看，贪心算法是最简洁且高效的解决方案，适合此题的要求。

### 所选高星题解
#### 题解1：CZQ_King (5星)
**关键亮点**：
- 使用贪心算法，优先减去最大的数（3），如果不行则尝试减去2，最后减去1。
- 代码简洁高效，逻辑清晰。
- 特判了初始状态是否在NG数字上，避免了不必要的计算。

**核心代码**：
```cpp
#include<bits/stdc++.h>
#define f(x) n-x!=a&&n-x!=b&&n-x!=c
#define die {puts("NO");return 0;}
using namespace std;
int n,a,b,c,p=100;
int main(){
    cin>>n>>a>>b>>c;
    if(f(0)){
        while(p&&n>0){
            p--;
            if(f(3))n-=3;
            else if(f(2))n-=2;
            else if(f(1))n-=1;
            else die
        }
        if(n>0)die
        else puts("YES");
    }else die
}
```

#### 题解2：liangbowen (4星)
**关键亮点**：
- 同样使用贪心算法，优先减去3，其次2，最后1。
- 代码结构清晰，易于理解。
- 特判了初始状态是否在NG数字上。

**核心代码**：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, g1, g2, g3;
void Error() { printf("NO\n"); exit(0); }
void OK() { printf("YES\n"); exit(0); }
bool chk(int x) {
    int t = n - x;
    if (t < 0) return false;
    if (t == g1 || t == g2 || t == g3) return false;
    return true;
}
int main() {
    scanf("%d%d%d%d", &n, &g1, &g2, &g3);
    if (!chk(0)) Error();
    for (int i = 1; i <= 100; i++) {
        if (chk(3)) n -= 3;
        else if (chk(2)) n -= 2;
        else if (chk(1)) n -= 1;
        else Error();
        if (n == 0) OK();
    }
    Error();
}
```

#### 题解3：Smoggy (4星)
**关键亮点**：
- 使用贪心算法，优先减去3，其次2，最后1。
- 代码简洁，逻辑清晰。
- 特判了初始状态是否在NG数字上。

**核心代码**：
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
int N, Ng1, Ng2, Ng3;
int main() {
    cin >> N >> Ng1 >> Ng2 >> Ng3;
    if ( N == Ng1 || N == Ng2 || N == Ng3 )
        {printf("NO\n"); return(0);}
    int Count = 0;
    while ( Count < 100 and N > 0 ) {
        if ( N - 3 != Ng1 and N - 3 != Ng2 and N - 3 != Ng3 ) N -= 3;
        else if ( N - 2 != Ng1 and N - 2 != Ng2 and N - 2 != Ng3 ) N -= 2;
        else if ( N - 1 != Ng1 and N - 1 != Ng2 and N - 1 != Ng3 ) N -= 1;
        else  {printf("NO\n");return(0);}
        Count++;
    }
    if ( N <= 0 ) printf("YES\n");
    else printf("NO\n");
    return (0);
}
```

### 最优关键思路
贪心算法是此题的最优解，优先减去最大的数（3），如果不行则尝试减去2，最后减去1。这种方法简单高效，且能够快速判断是否能够在100步内完成任务。

### 可拓展之处
此题可以拓展为更多步数或更多可选数字的情况，贪心算法依然适用。类似的问题还包括在有限步数内通过某种操作达到目标状态，且需要避免某些中间状态。

### 推荐题目
1. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

---
处理用时：36.78秒
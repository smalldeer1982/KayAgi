# 题目信息

# [ABC021B] 嘘つきの高橋くん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc021/tasks/abc021_b

あなたと高橋君は、AtCoder 王国に住んでいます。AtCoder 王国には、$ N $ 個の町と、町同士を結ぶ何本かの道路が存在し、道路は双方向に移動可能です。 $ N $ 個の町はそれぞれ 町 $ 1 $,町 $ 2 $,…,町 $ N $ と呼ばれています。

高橋君はあなたの家に遊びに行くことにしました。そして、高橋君は町 $ a $ から出発して、ちょうど $ K $ 回 AtCoder 王国のどこかの町を経由して町 $ b $ にあるあなたの家に到着しました。

高橋君は町 $ a $ から町 $ b $ まで最短経路で移動してきたと主張していますが、あなたには彼が嘘をついているよう思えます。 しかし、あなたは具体的に町同士を結ぶ道路がどのような構成になっているか全く知らないため、高橋君が辿った経路が本当に最短経路なのかどうか判定できません。

あなたは高橋君がどの順番で町を経由したかを聞き出すことに成功しました。ただし、この情報には出発/到着地点である町 $ a $ と町 $ b $ が含まれません。

あなたはこの情報を元に、高橋君が最短経路で移動していた可能性があるかどうかを出力するプログラムを書くことにしました。 町 $ a $ から町 $ b $ への最短経路とは、町 $ a $ から町 $ b $ への移動経路において道路を通る回数が最小となるような経路のことを言います。

高橋君が辿った経路が最短経路となるような町と道路の構成が $ 1 $ つでも存在する場合、最短経路で移動した可能性があると言えます。一方、そのような構成がない場合、その可能性は無いと言えます。

## 说明/提示

### Sample Explanation 1

たとえば以下のような道路の構成を考えると $ 1→3→4→2→5 $ という経路が最短経路となります。 !\[\](http://abc021.contest.atcoder.jp/img/abc/021/enJQfEfKt-baQEUDjCrVFLSw/B\_sample1.png)

### Sample Explanation 2

$ 1→2→4→2→7→3 $ という経路が最短経路となるような道路の構成は存在しません。 どのような道路の構成においても、一度訪れた町に再び訪れるような移動は必ず省略できるからです。 !\[\](http://abc021.contest.atcoder.jp/img/abc/021/enJQfEfKt-baQEUDjCrVFLSw/B\_sample2.png)

### Sample Explanation 3

$ 1→2→1→3→4 $ と移動しています。一度出発地点に戻っていますが、そのような移動をしてしまうと最短経路を達成することはできません。

### Sample Explanation 4

$ 1→2→4→3→4 $ と移動しています。今度は到着地点に一度辿り着いたのにも関わらず移動しています。

## 样例 #1

### 输入

```
5

1 5

3

3 4 2```

### 输出

```
YES```

## 样例 #2

### 输入

```
7

1 3

4

2 4 2 7```

### 输出

```
NO```

## 样例 #3

### 输入

```
4

1 4

3

2 1 3```

### 输出

```
NO```

## 样例 #4

### 输入

```
4

1 4

3

2 4 3```

### 输出

```
NO```

## 样例 #5

### 输入

```
20

1 4

12

2 3 5 7 8 9 10 11 12 15 13 14```

### 输出

```
YES```

# AI分析结果

### 题目内容重写

#### [ABC021B] 说谎的高桥君

**题目描述**

你和高桥君住在AtCoder王国。AtCoder王国有$N$个城镇，以及连接这些城镇的若干条双向道路。$N$个城镇分别称为城镇$1$、城镇$2$、…、城镇$N$。

高桥君决定去你家玩。他从城镇$a$出发，经过恰好$K$次城镇的访问，最终到达城镇$b$，即你家所在的地方。

高桥君声称他是沿着最短路径从城镇$a$到城镇$b$的，但你怀疑他在说谎。然而，你并不知道城镇之间的道路具体是如何连接的，因此无法判断高桥君的路径是否真的是最短路径。

你成功地从高桥君那里得知了他经过的城镇的顺序，但这个信息中不包含出发和到达的城镇$a$和$b$。

你需要根据这个信息，编写一个程序来判断高桥君是否有可能沿着最短路径移动。从城镇$a$到城镇$b$的最短路径是指在所有可能的路径中，经过的道路数量最少的路径。

如果存在一种城镇和道路的构成，使得高桥君的路径是最短路径，那么他有可能沿着最短路径移动。否则，这种可能性不存在。

**说明/提示**

**样例解释1**

例如，考虑以下道路构成，路径$1→3→4→2→5$是最短路径。

**样例解释2**

路径$1→2→4→2→7→3$不可能是最短路径，因为在任何道路构成中，重复访问同一个城镇的路径都可以被优化。

**样例解释3**

路径$1→2→1→3→4$不可能是最短路径，因为出发城镇被重复访问。

**样例解释4**

路径$1→2→4→3→4$不可能是最短路径，因为到达城镇被重复访问。

**样例输入1**

```
5
1 5
3
3 4 2
```

**样例输出1**

```
YES
```

**样例输入2**

```
7
1 3
4
2 4 2 7
```

**样例输出2**

```
NO
```

**样例输入3**

```
4
1 4
3
2 1 3
```

**样例输出3**

```
NO
```

**样例输入4**

```
4
1 4
3
2 4 3
```

**样例输出4**

```
NO
```

**样例输入5**

```
20
1 4
12
2 3 5 7 8 9 10 11 12 15 13 14
```

**样例输出5**

```
YES
```

### 算法分类

**图论**

### 题解分析与结论

题目要求判断高桥君的路径是否可能是最短路径。最短路径的定义是经过的道路数量最少，因此我们需要检查高桥君的路径是否满足以下条件：

1. **路径中没有重复访问的城镇**：如果路径中某个城镇被访问了多次，那么这条路径肯定不是最短路径，因为可以通过优化去掉重复访问的部分。
2. **路径的长度等于$K$**：高桥君声称他经过了$K$个城镇，因此路径的长度必须等于$K$。

如果高桥君的路径满足以上两个条件，那么存在一种道路构成，使得这条路径是最短路径；否则，这种可能性不存在。

### 通用建议与扩展思路

1. **路径的唯一性**：最短路径可能不唯一，但只要高桥君的路径满足上述条件，就存在一种道路构成使得这条路径是最短路径。
2. **图的性质**：题目中并没有给出具体的道路连接情况，因此我们无法通过具体的图算法（如Dijkstra或BFS）来计算最短路径。我们只能通过路径的性质来判断。
3. **重复访问的检测**：可以通过哈希表或集合来检测路径中是否有重复访问的城镇。

### 推荐题目

1. **洛谷 P1144 最短路计数**：考察最短路径的计数问题，与本题的最短路径判断相关。
2. **洛谷 P3371 【模板】单源最短路径（弱化版）**：考察最短路径的基本算法，与本题的图论背景相关。
3. **洛谷 P4779 【模板】单源最短路径（标准版）**：进一步考察最短路径的算法实现，与本题的图论背景相关。

### 关键代码实现

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

int main() {
    int N, a, b, K;
    cin >> N >> a >> b >> K;
    vector<int> path(K);
    for (int i = 0; i < K; ++i) {
        cin >> path[i];
    }
    
    unordered_set<int> visited;
    visited.insert(a);
    visited.insert(b);
    for (int town : path) {
        if (visited.count(town)) {
            cout << "NO" << endl;
            return 0;
        }
        visited.insert(town);
    }
    
    cout << "YES" << endl;
    return 0;
}
```

**核心实现思想**：通过哈希表记录已经访问过的城镇，如果路径中有重复访问的城镇，则输出"NO"；否则输出"YES"。

---
处理用时：34.70秒
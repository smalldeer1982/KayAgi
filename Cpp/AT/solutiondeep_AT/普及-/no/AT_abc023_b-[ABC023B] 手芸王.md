# 题目信息

# [ABC023B] 手芸王

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc023/tasks/abc023_b

高橋君は趣味でアクセサリーを作っている。

アクセサリーは `a`, `b`, `c` のいずれか $ 1 $ 文字が書かれたブロックを横 $ 1 $ 列に並べることで作成できる。

高橋君は、以下の手順でアクセサリーの作成を行う：

- 手順 $ 0 $ : 高橋君は `b` $ 1 $ 文字からなるアクセサリーを作成する。

以降の手順では、既にあるアクセサリーの両端にブロックを $ 1 $ つずつ追加することでアクセサリーを改造する。

- 手順 $ 3n\ +\ 1\ (n\ ≧\ 0) $ : 手順 $ 3n $ で完成したアクセサリーの左端に文字 `a` が書かれたブロックを、右端に文字 `c` が書かれたブロックを付け足す。
- 手順 $ 3n\ +\ 2\ (n\ ≧\ 0) $ : 手順 $ 3n+1 $ で完成したアクセサリーの左端に文字 `c` が書かれたブロックを、右端に文字 `a` が書かれたブロックを付け足す。
- 手順 $ 3n\ (n\ ≧\ 1) $ : 手順 $ 3n-1 $ で完成したアクセサリーの左端に文字 `b` が書かれたブロックを、右端に文字 `b` が書かれたブロックを付け足す。

高橋君はアクセサリーの作成を好きな手順の直後に終了することができる。終了した場合、アクセサリーには、アクセサリーを構成するブロックに書かれた文字を左から右に読んだものと同じ名前が付けられる。

例えば、手順 $ 0 $, $ 1 $, $ 2 $, $ 3 $ それぞれの直後にアクセサリーの作成を終了した場合、アクセサリーの名前は順に、`b`, `abc`, `cabca`, `bcabcab` となる。

文字列 $ S $ が与えられるので、その文字列がアクセサリーの名前として考えられるかを判定し、考えられるなら何番目の手順の直後にアクセサリーの作成を終了したのかを求めよ。

## 说明/提示

### Sample Explanation 1

\- 手順 $ 1 $ の直後にアクセサリーの作成を終了したときのアクセサリーの名前は `abc` となる。

### Sample Explanation 2

\- 文字列 `abcabc` はアクセサリーの名前として考えられない。

### Sample Explanation 3

\- 文字列 $ S $ には `a`, `b`, `c` 以外の文字が入ることがある。

## 样例 #1

### 输入

```
3

abc```

### 输出

```
1```

## 样例 #2

### 输入

```
6

abcabc```

### 输出

```
-1```

## 样例 #3

### 输入

```
7

atcoder```

### 输出

```
-1```

## 样例 #4

### 输入

```
19

bcabcabcabcabcabcab```

### 输出

```
9```

# AI分析结果

### 题目内容重写

#### [ABC023B] 手芸王

**题目描述**

高桥君喜欢制作饰品。饰品由 `a`, `b`, `c` 中的任意一个字符写在方块上，并将这些方块横向排列而成。

高桥君按照以下步骤制作饰品：

- 步骤 0：高桥君制作一个由 `b` 一个字符组成的饰品。

之后的步骤中，通过在现有饰品的两端各添加一个方块来改造饰品。

- 步骤 $3n + 1$（$n \geq 0$）：在步骤 $3n$ 完成的饰品的左端添加字符 `a`，右端添加字符 `c`。
- 步骤 $3n + 2$（$n \geq 0$）：在步骤 $3n + 1$ 完成的饰品的左端添加字符 `c`，右端添加字符 `a`。
- 步骤 $3n$（$n \geq 1$）：在步骤 $3n - 1$ 完成的饰品的左端添加字符 `b`，右端添加字符 `b`。

高桥君可以在任意步骤后停止制作饰品。停止后，饰品的名称即为从左到右读取方块上的字符所组成的字符串。

例如，在步骤 0、1、2、3 后停止，饰品的名称分别为 `b`, `abc`, `cabca`, `bcabcab`。

给定一个字符串 $S$，判断它是否可以作为饰品的名称，如果可以，输出停止时的步骤编号。

**说明/提示**

- 样例 1：步骤 1 后停止，饰品名称为 `abc`。
- 样例 2：字符串 `abcabc` 不能作为饰品的名称。
- 样例 3：字符串 $S$ 可能包含 `a`, `b`, `c` 以外的字符。

**样例 #1**

输入：
```
3
abc
```
输出：
```
1
```

**样例 #2**

输入：
```
6
abcabc
```
输出：
```
-1
```

**样例 #3**

输入：
```
7
atcoder
```
输出：
```
-1
```

**样例 #4**

输入：
```
19
bcabcabcabcabcabcab
```
输出：
```
9
```

### 算法分类
模拟

### 题解分析与结论

该题的核心是通过模拟饰品的生成过程，判断给定的字符串是否可以通过特定的步骤生成。由于步骤的顺序和添加的字符是固定的，因此可以通过模拟每一步的生成过程来验证字符串是否符合规则。

### 评分较高的题解

#### 作者：亦枫 (4星)

**关键亮点：**
- 直接模拟每一步的生成过程，代码简洁明了。
- 通过特判处理特殊情况（如步骤0）。

**核心代码：**
```cpp
for(int i=1; i<=n; i++) {
    if(i%3==1)s='a'+s+'c';
    else if(i%3==2)s='c'+s+'a';
    else s='b'+s+'b';
    if(s.size()>n)break;
    if(s==a) {
        printf("%d\n",i);
        return 0;
    }
}
```

#### 作者：伟大的王夫子 (4星)

**关键亮点：**
- 通过暴力枚举每一步，代码实现简单。
- 在中途累加时判断字符串长度，提前结束无效操作。

**核心代码：**
```cpp
for (register int i = 1; i <= 10000; ++i) {
    if (b == a) {
        printf("%d\n", i - 1);
        return 0;
    }
    if (b.size() > n) break;
    if (i % 3 == 1) b = 'a' + b + 'c';
    if (i % 3 == 2) b = 'c' + b + 'a'; 
    if (i % 3 == 0) b = 'b' + b + 'b';
}
```

#### 作者：cff_0102 (4星)

**关键亮点：**
- 直接模拟每一步的生成过程，代码简洁。
- 在最后判断一次字符串是否匹配，确保不遗漏。

**核心代码：**
```cpp
for(int i=1;i<=n;i++){
    if(s==a){
        cout<<i-1<<endl;
        exit(0);
    }
    if(i%3==0){
        s="b"+s+"b";
    }else if(i%3==1){
        s="a"+s+"c";
    }else{
        s="c"+s+"a";
    }
}
```

### 最优关键思路或技巧

1. **模拟生成过程**：通过模拟每一步的生成过程，逐步构建字符串并与目标字符串进行比较。
2. **提前终止**：在模拟过程中，如果生成的字符串长度超过目标字符串长度，提前终止，避免无效操作。
3. **特判处理**：对于特殊情况（如步骤0），进行特判处理，确保程序的正确性。

### 可拓展之处

该题的思路可以拓展到其他类似的字符串生成问题，特别是那些通过固定规则逐步构建字符串的题目。例如，可以通过类似的方法解决某些递归生成字符串的问题。

### 推荐题目

1. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
2. [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)
3. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)

### 个人心得摘录

- **亦枫**：在模拟过程中，通过特判处理特殊情况，确保程序的正确性。
- **伟大的王夫子**：通过暴力枚举每一步，挖掘问题的本质，避免过度复杂的解法。
- **cff_0102**：在最后判断一次字符串是否匹配，确保不遗漏任何可能的情况。

---
处理用时：31.29秒
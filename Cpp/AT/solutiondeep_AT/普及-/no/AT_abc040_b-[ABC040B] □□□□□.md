# 题目信息

# [ABC040B] □□□□□

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc040/tasks/abc040_b

高橋君は大きさ $ 1 $ メートル四方のタイルを $ n $ 枚持っています。

高橋君はこれらのタイルのうちいくつかを、重ならないように隙間なく並べて大きな長方形を作ろうとしています。

出来上がる長方形はできるだけ正方形に近いほうがよいですが、同時に、使わずに余るタイルの枚数ができるだけ少なくなるようにしたいと考えています。

長方形の縦と横の長さの差の絶対値と、余ったタイルの枚数の和を最小でいくつにできるでしょうか。

## 说明/提示

### 制約

- $ 1\ ≦\ n\ ≦\ 100,000 $

### Sample Explanation 1

$ 5\ \times\ 5 $ の正方形になるように並べると、縦横の長さの差が $ 0 $ で、余るタイルの枚数が $ 1 $ となり、その和は $ 1 $ です。 $ 26 $ 枚のタイルを余らせることなく使い正方形を作ることはできないので、答えは $ 1 $ となります。

### Sample Explanation 2

この場合、$ 5\ \times\ 8 $ の長方形を作ってタイルを $ 1 $ 枚余らせるのが最適です。

## 样例 #1

### 输入

```
26```

### 输出

```
1```

## 样例 #2

### 输入

```
41```

### 输出

```
4```

## 样例 #3

### 输入

```
100000```

### 输出

```
37```

# AI分析结果

【题目内容】
# [ABC040B] □□□□□

## 题目描述

高橋君有 $n$ 块大小为 $1$ 米见方的瓷砖。他打算用这些瓷砖拼成一个长方形，要求长方形尽可能接近正方形，并且剩余的瓷砖数量尽可能少。求长方形长和宽的差的绝对值与剩余瓷砖数量的和的最小值。

## 说明/提示

### 制約

- $1 \leq n \leq 100,000$

### 样例解释

#### 样例1
输入：26  
输出：1  
解释：拼成 $5 \times 5$ 的正方形，长宽差为 $0$，剩余瓷砖为 $1$，和为 $1$。

#### 样例2
输入：41  
输出：4  
解释：拼成 $5 \times 8$ 的长方形，长宽差为 $3$，剩余瓷砖为 $1$，和为 $4$。

#### 样例3
输入：100000  
输出：37  
解释：拼成 $316 \times 316$ 的正方形，长宽差为 $0$，剩余瓷砖为 $37$，和为 $37$。

【算法分类】  
枚举

【题解分析与结论】  
题目要求通过枚举长方形的长和宽，找到长宽差的绝对值与剩余瓷砖数量的和的最小值。由于 $n$ 的范围较大（$1 \leq n \leq 100,000$），直接双重循环枚举会导致时间复杂度过高，因此需要优化。

### 题解对比与评分
1. **frostanubis 的题解**  
   - **星级：4**  
   - **关键亮点**：通过单层循环枚举长方形的长，利用长方形的性质计算宽，从而降低时间复杂度。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(register int i=1;i<=a;i++) {
         s=a/i;
         ans=min(ans,(a-i*s)+abs(i-s));
     }
     ```
   - **个人心得**：使用寄存器变量加速循环，虽然对于这种题目影响不大，但体现了对性能的考虑。

2. **BeetyX 的题解**  
   - **星级：3**  
   - **关键亮点**：与 frostanubis 的题解类似，通过单层循环枚举长方形的长，计算宽并更新最小值。代码简洁，但缺乏优化细节。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=a;i++) {
         b=a/i;
         ans=min(ans,(a-i*b)+abs(i-b));
     }
     ```
   - **个人心得**：无特别心得，代码较为常规。

3. **RioBlu 的题解**  
   - **星级：2**  
   - **关键亮点**：使用双重循环枚举长和宽，虽然逻辑正确，但时间复杂度较高，不适用于大范围数据。
   - **核心代码**：
     ```cpp
     for(int s=1;s<=a;s++) {
         for(int v=1;v<=a;v++) {
             if(a<s*v) break;
             ans=min(ans,a-s*v+abs(s-v));
         }
     }
     ```
   - **个人心得**：无特别心得，代码效率较低。

【最优关键思路】  
通过单层循环枚举长方形的长，利用长方形的性质计算宽，从而将时间复杂度从 $O(n^2)$ 降低到 $O(n)$。这种方法既保证了效率，又简化了代码实现。

【拓展思路】  
类似的问题可以通过数学优化进一步减少计算量，例如通过平方根计算接近正方形的长和宽，减少枚举次数。

【推荐题目】  
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)  
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)  
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

---
处理用时：25.64秒
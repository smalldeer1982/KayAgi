# 题目信息

# [ABC061C] Big Array

## 题目描述

## 题目翻译
有一个数组S，一开始是空的。接下来对这个数组进行N次插入操作.
第ii次操作会向数组中加入$b_i$
 个整数$a_i$
 ，然后将整个数组从小到大排一次序。
求N次操作后, 数组中的第K个数。
例如S=\{1,2,2,3,3,3\}时, 从小到大排序后第4个数是3。

## 说明/提示

*  	1≦N≦$10^5$ 
*  	1≦$a_i$ ,$b_i$ ≦$10^5$ 
*  	1≦K≦$b_1$+...+$b_n$
*	所有输入值都是整数。
------------
题目翻译者UID：370640

## 样例 #1

### 输入

```
3 4

1 1

2 2

3 3```

### 输出

```
3```

## 样例 #2

### 输入

```
10 500000

1 100000

1 100000

1 100000

1 100000

1 100000

100000 100000

100000 100000

100000 100000

100000 100000

100000 100000```

### 输出

```
1```

# AI分析结果

【题目内容】
# [ABC061C] Big Array

## 题目描述

有一个数组S，一开始是空的。接下来对这个数组进行N次插入操作.
第ii次操作会向数组中加入$b_i$
 个整数$a_i$
 ，然后将整个数组从小到大排一次序。
求N次操作后, 数组中的第K个数。
例如S=\{1,2,2,3,3,3\}时, 从小到大排序后第4个数是3。

## 说明/提示

*  	1≦N≦$10^5$ 
*  	1≦$a_i$ ,$b_i$ ≦$10^5$ 
*  	1≦K≦$b_1$+...+$b_n$
*	所有输入值都是整数。
------------
题目翻译者UID：370640

## 样例 #1

### 输入

```
3 4

1 1

2 2

3 3```

### 输出

```
3```

## 样例 #2

### 输入

```
10 500000

1 100000

1 100000

1 100000

1 100000

1 100000

100000 100000

100000 100000

100000 100000

100000 100000

100000 100000```

### 输出

```
1```

【算法分类】
模拟

【题解分析与结论】
本题的核心思路是通过模拟操作来找到第K小的数，而不需要真正构建整个数组。所有题解都采用了类似的思路：通过记录每个数字的出现次数，然后依次减去这些次数，直到找到第K小的数。这种方法避免了直接构建和排序大数组，大大提高了效率。

【评分较高的题解】

1. **作者：Texas_the_Omertosa (赞：11)**
   - **星级：5**
   - **关键亮点**：代码简洁，直接使用数组记录每个数字的出现次数，并通过循环找到第K小的数。提醒了不开long long会导致WA的问题。
   - **核心代码**：
     ```cpp
     int t[100005];
     signed main() {
         ios::sync_with_stdio(0);
         cin.tie(0);
         cout.tie(0);
         cin>>n>>k;
         for(int i=1;i<=n;i++) {
             cin>>a>>b;
             t[a]+=b;
         }
         while(k>0) {
             ++num;
             k-=t[num];
         }
         cout<<num<<'\n';
         return 0;
     }
     ```

2. **作者：沉石鱼惊旋 (赞：5)**
   - **星级：4**
   - **关键亮点**：使用`pair`记录数字和出现次数，并通过排序和遍历找到第K小的数。提醒了k的最大值可能很大，需要开long long。
   - **核心代码**：
     ```cpp
     vector<pair<ll,ll>>v;
     int main() {
         ll n,k;
         cin>>n>>k;
         for(int i=1;i<=n;i++) {
             int a,b;
             cin>>a>>b;
             v.push_back(make_pair(a,b));
         }
         sort(v.begin(),v.end());
         for(int i=0;i<(int)v.size();i++) {
             k-=v[i].second;
             if(k<=0){cout<<v[i].first<<endl;return 0;}
         }
         return 0;
     }
     ```

3. **作者：makerlife (赞：1)**
   - **星级：4**
   - **关键亮点**：使用桶的思想，通过数组记录每个数字的出现次数，并通过循环找到第K小的数。提醒了不开long long会导致WA的问题。
   - **核心代码**：
     ```cpp
     ll t[100010],ans=0;
     int main() {
         scanf("%lld%lld",&n,&k);
         for(int i=1;i<=n;i++) {
             scanf("%lld%lld",&a,&b);
             t[a]+=b;
         }
         while(k>0) {
             k-=t[++ans];
         }
         printf("%lld\n",ans);
         return 0;
     }
     ```

【最优关键思路或技巧】
- **桶排序思想**：通过记录每个数字的出现次数，避免了直接构建和排序大数组，大大提高了效率。
- **long long的使用**：由于k的最大值可能很大，必须使用long long来避免溢出。

【可拓展之处】
- **类似题目**：可以扩展到其他需要处理大量数据的题目，如统计数字出现次数、查找第K小的数等。
- **优化思路**：在数据量更大的情况下，可以考虑使用更高效的数据结构，如平衡树或哈希表。

【推荐题目】
1. P1097 [NOIP2007 提高组] 统计数字
2. P3368 【模板】树状数组 2
3. P3374 【模板】树状数组 1

【个人心得】
- **调试经历**：很多题解都提到了不开long long会导致WA的问题，这是在实际编程中常见的错误，提醒我们在处理大数时要注意数据类型的选择。
- **踩坑教训**：直接构建和排序大数组会导致超时，因此需要寻找更高效的算法来解决问题。

---
处理用时：29.33秒
# 题目信息

# [ABC068B] Break Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc068/tasks/abc068_b

高橋君は $ 2 $ で割れる数が好きです。

正整数 $ N $ が与えられるので、$ 1 $ 以上 $ N $ 以下の整数のうち、最も $ 2 $ で割れる回数が多いものを求めてください。答えは必ず $ 1 $ つに定まります。

なお、$ 2 $ で割っていき、何回あまりが出ずに割れるかを、$ 2 $ で割れる回数と呼ぶことにします。

例えば

- $ 6 $ ならば、$ 6 $ -&gt; $ 3 $で、$ 1 $ 回 $ 2 $ で割れます。
- $ 8 $ ならば、$ 8 $ -&gt; $ 4 $ -&gt; $ 2 $ -&gt; $ 1 $で、$ 3 $ 回 $ 2 $ で割れます。
- $ 3 $ ならば、$ 0 $ 回 $ 2 $ で割れます。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 100 $

### Sample Explanation 1

$ 4 $ は $ 2 $ 回 $ 2 $ で割ることができ、これは $ 1 $, $ 2 $, ..., $ 7 $ の中で最も多いです。

## 样例 #1

### 输入

```
7```

### 输出

```
4```

## 样例 #2

### 输入

```
32```

### 输出

```
32```

## 样例 #3

### 输入

```
1```

### 输出

```
1```

## 样例 #4

### 输入

```
100```

### 输出

```
64```

# AI分析结果

### 题目重写
高橋君喜欢能被2整除的数。

给定一个正整数$N$，求在$1$到$N$之间的整数中，能被2整除次数最多的数。答案必定唯一。

注意，我们将一个数不断除以2，直到不能整除为止的次数称为“能被2整除的次数”。

例如：
- $6$可以整除2一次，因为$6 \rightarrow 3$。
- $8$可以整除2三次，因为$8 \rightarrow 4 \rightarrow 2 \rightarrow 1$。
- $3$不能整除2，次数为0。

### 算法分类
枚举

### 题解分析与结论
题目要求找出在$1$到$N$之间能被2整除次数最多的数。由于$N$的范围很小（$1 \leq N \leq 100$），可以直接枚举所有可能的2的幂次方，找到小于等于$N$的最大值。

### 评分较高的题解

#### 题解1：作者：A_Plus_Gu (赞：0)
**星级：4星**
**关键亮点：**
- 使用打表法，预先列出100以内所有2的幂次方。
- 通过从大到小遍历表，快速找到小于等于$N$的最大2的幂次方。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
#include<iostream>
using namespace std;
int main(){
    long long a[8]={0,1,2,4,8,16,32,64};//打表
    long long n;
    cin>>n;//输入
    for(int i=7;i;i--){//从大到小遍历
        if(a[i]<=n){
            cout<<a[i]<<endl;
            return 0;//直接结束程序
        }
    }
}
```

#### 题解2：作者：Raw_Aya9285 (赞：0)
**星级：4星**
**关键亮点：**
- 使用while循环，不断乘以2，直到超过$N$。
- 最后输出前一次的结果，确保是小于等于$N$的最大2的幂次方。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
#include<iostream>
using namespace std;
int main(){
    int a,nd=1; //nd用来保存输出的数字
    cin>>a; //输入
    while(nd<=a){ //当2的幂不大于给出的数
        nd*=2; //就乘2
    }
    cout<<nd/2<<endl; //由于最后多乘了一次，所以除以2，记得换行
    return 0; //好习惯
}
```

#### 题解3：作者：青蛙王子 (赞：0)
**星级：4星**
**关键亮点：**
- 使用for循环，不断乘以2，直到超过$N$。
- 通过标记判断$N$是否恰好是2的幂次方。
- 代码逻辑清晰，处理边界情况较好。

**核心代码：**
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,i,f;//f是标记
int main()
{
    cin>>n;
    for(i=1;i<=n;i*=2)//列举2^i
      if(i==n)  {f=1;break;}//如果n恰好是2的i次方，就做个标记
    if(!f)
      cout<<i/2<<endl;//这个就是2^(i-1)
    else  cout<<i<<endl;//这个就是有标记的输出
    return 0;
}
```

### 最优关键思路
1. **打表法**：预先列出所有可能的2的幂次方，然后从大到小遍历，找到小于等于$N$的最大值。
2. **循环乘法**：通过不断乘以2，直到超过$N$，然后输出前一次的结果。

### 可拓展之处
类似的问题可以扩展到其他幂次方，如3的幂次方、5的幂次方等。也可以扩展到更大的范围，使用二分查找来优化查找过程。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)

---
处理用时：25.88秒
# 题目信息

# [ABC096C] Grid Repainting 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc096/tasks/abc096_c

$ H $ 行 $ W $ 列のマス目で表されるキャンバスがあります. 上から $ i $ 番目, 左から $ j $ 番目のマスを $ (i,\ j) $ と表します.  
 最初, すべてのマス目は白色です. square1001 君は, 黒い絵の具を使って絵を描きたいと思いました. 具体的には, square1001 君の目標は, $ s_{i,\ j}= $ `#` のときマス $ (i,\ j) $ を黒色, $ s_{i,\ j}= $ `.` のときマス $ (i,\ j) $ を白色にすることです.  
 しかし, 彼は絵を描くことが得意ではないので, 何回か ($ 0 $ 回でもよい)「上下左右に隣接する $ 2 $ つのマスを選び, 両方黒く塗る」ことしかできません. ただし, すでに黒く塗られているマスを選ぶこともでき, この場合マスの色は黒のまま変わりません.   
 square1001 君が目標を達成することができるか判定してください.

## 说明/提示

### 制約

- $ H $ は $ 1 $ 以上 $ 50 $ 以下の整数
- $ W $ は $ 1 $ 以上 $ 50 $ 以下の整数
- すべての $ (i,\ j)\ (1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W) $ に対して, $ s_{i,\ j} $ は `#` または `.`

### Sample Explanation 1

目標を達成する手順の一例として, 下の図の方法が挙げられます. この図では, 「次に黒く塗るマス」を「☆」で表しています. !\[ \](https://img.atcoder.jp/abc096/18f94b6627ec5dc8aa4f6d99ae1c8fca.png)

### Sample Explanation 2

square1001 君は目標を達成することができません.

## 样例 #1

### 输入

```
3 3

.#.

###

.#.```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5 5

#.#.#

.#.#.

#.#.#

.#.#.

#.#.#```

### 输出

```
No```

## 样例 #3

### 输入

```
11 11

...#####...

.##.....##.

#..##.##..#

#..##.##..#

#.........#

#...###...#

.#########.

.#.#.#.#.#.

##.#.#.#.##

..##.#.##..

.##..#..##.```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个由 $H$ 行 $W$ 列组成的网格画布。从上到下第 $i$ 行，从左到右第 $j$ 列的格子表示为 $(i, j)$。  
最初，所有格子都是白色的。square1001 君想用黑色颜料画一幅画。具体来说，他的目标是：当 $s_{i,j}=$ `#` 时，将格子 $(i, j)$ 涂成黑色；当 $s_{i,j}=$ `.` 时，将格子 $(i, j)$ 保持白色。  
然而，他并不擅长绘画，因此只能进行以下操作：选择上下左右相邻的两个格子，并将它们都涂成黑色。操作可以进行多次（包括零次），且已经涂黑的格子可以再次被选中，但颜色不会改变。  
请判断 square1001 君是否能够实现他的目标。

#### 说明/提示

##### 约束条件

- $H$ 是 $1$ 到 $50$ 之间的整数。
- $W$ 是 $1$ 到 $50$ 之间的整数。
- 对于所有 $(i, j)\ (1 \leq i \leq H, 1 \leq j \leq W)$，$s_{i,j}$ 是 `#` 或 `.`。

#### 样例

##### 样例 1

输入：
```
3 3

.#.

###

.#.```

输出：
```
Yes```

##### 样例 2

输入：
```
5 5

#.#.#

.#.#.

#.#.#

.#.#.

#.#.#```

输出：
```
No```

##### 样例 3

输入：
```
11 11

...#####...

.##.....##.

#..##.##..#

#..##.##..#

#.........#

#...###...#

.#########.

.#.#.#.#.#.

##.#.#.#.##

..##.#.##..

.##..#..##.```

输出：
```
Yes```

### 算法分类

模拟

### 题解分析与结论

#### 题解对比

1. **Trump__Biden** 的题解：
   - **思路**：遍历整个网格，检查每个黑色格子是否至少有一个相邻的黑色格子。如果没有，则输出 `No`，否则输出 `Yes`。
   - **难点**：关键在于如何高效地检查每个黑色格子的相邻格子。
   - **评分**：4星。思路清晰，代码简洁，但缺少对边界条件的详细说明。

2. **Ninelife_Cat** 的题解：
   - **思路**：与 Trump__Biden 类似，遍历网格，检查每个黑色格子是否有相邻的黑色格子。
   - **难点**：同样是如何高效地检查相邻格子。
   - **评分**：3星。代码可读性较好，但使用了较多的宏定义和不必要的变量声明，略显冗余。

3. **μηδσ** 的题解：
   - **思路**：使用坐标偏移数组来检查每个黑色格子的相邻格子。
   - **难点**：如何正确地使用坐标偏移数组来简化代码。
   - **评分**：4星。代码结构清晰，使用了坐标偏移数组来简化相邻格子的检查，思路较为优化。

#### 最优关键思路

- **核心思想**：由于每次操作必须涂黑两个相邻的格子，因此任何黑色格子必须至少有一个相邻的黑色格子。否则，该黑色格子无法通过任何操作被涂黑。
- **实现技巧**：使用坐标偏移数组来简化相邻格子的检查，避免重复代码。

#### 可拓展之处

- 类似的问题可以扩展到三维网格或其他更复杂的图形结构，核心思想仍然是检查每个目标点是否可以通过某种操作被实现。
- 该问题也可以与图论中的连通性问题结合，进一步分析网格的连通性。

#### 推荐题目

1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1131 字符识别](https://www.luogu.com.cn/problem/P1131)

### 所选高分题解

#### 题解 1：Trump__Biden (4星)

**关键亮点**：
- 思路清晰，直接遍历网格并检查每个黑色格子的相邻格子。
- 代码简洁，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=n;++i)
{
    for(int j=1;j<=m;++j)
    {
        if(a[i][j]=='#')
            if(a[i][j-1]!='#'&&a[i][j+1]!='#'&&a[i-1][j]!='#'&&a[i+1][j]!='#')
            {
                printf("No\n");
                return 0;
            }
    }
}
printf("Yes\n");
```

#### 题解 3：μηδσ (4星)

**关键亮点**：
- 使用坐标偏移数组来简化相邻格子的检查，代码结构清晰。
- 思路优化，减少了重复代码。

**核心代码**：
```cpp
for(int i = 1;i <= n;i++)
{
    for(int j = 1;j <= m;j++)
    {
        if(s[i][j]=='#')
        {
            bool flag = false;
            for(int k = 0;k < 4;k++)
            {
                int nx = i + dx[k];
                int ny = j + dy[k];
                if((nx > 0) && (nx <= n) && (ny > 0) && (ny <= m) && (s[nx][ny] == '#'))
                {
                    flag = true;
                    break;
                }
            }
            if(flag == false)
            {
                cout << "No";
                return 0;
            }
        }
    }
}
cout << "Yes";
```

### 总结

通过对比多个题解，可以发现该问题的核心在于检查每个黑色格子是否至少有一个相邻的黑色格子。使用坐标偏移数组可以有效地简化代码，并提高代码的可读性和可维护性。推荐在类似的问题中使用这种技巧来优化代码结构。

---
处理用时：34.73秒
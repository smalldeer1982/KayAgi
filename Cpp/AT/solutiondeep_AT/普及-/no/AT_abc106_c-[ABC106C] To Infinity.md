# 题目信息

# [ABC106C] To Infinity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc106/tasks/abc106_c

Mr. Infinity は, `1` から `9` までの数字からなる文字列 $ S $ を持っている. この文字列は, 日付が変わるたびに次のように変化する.

- 文字列 $ S $ に含まれるそれぞれの `2` が `22`, `3` が `333`, `4` が `4444`, `5` が `55555`, `6` が `666666`, `7` が `7777777`, `8` が `88888888`, `9` が `999999999` に置き換わる. `1` は `1` のまま残る.

例えば, $ S $ が `1324` の場合, 翌日には `1333224444` になり, 翌々日には `133333333322224444444444444444` になる.  
 あなたは $ 5000 $ 兆日後に文字列がどのようになっているか知りたい. $ 5000 $ 兆日後の文字列の左から $ K $ 文字目は何か？

## 说明/提示

### 制約

- $ S $ は $ 1 $ 文字以上 $ 100 $ 文字以下の文字列.
- $ K $ は $ 1 $ 以上 $ 10^{18} $ 以下の整数.
- $ 5000 $ 兆日後の文字列の長さは $ K $ 文字以上である.

### Sample Explanation 1

文字列 $ S $ は次のように変化していく. - 現在: `1214` - $ 1 $ 日後: `12214444` - $ 2 $ 日後: `1222214444444444444444` - $ 3 $ 日後: `12222222214444444444444444444444444444444444444444444444444444444444444444` $ 5000 $ 兆日後の文字列の最初 $ 5 $ 文字は `12222` となる. $ K=4 $ なので, $ 4 $ 文字目の `2` を出力すればよい.

### Sample Explanation 2

文字列ははじめ `3` である. $ 5000 $ 兆日経ったとき, 文字列は `3` だけで構成される.

## 样例 #1

### 输入

```
1214

4```

### 输出

```
2```

## 样例 #2

### 输入

```
3

157```

### 输出

```
3```

## 样例 #3

### 输入

```
299792458

9460730472580800```

### 输出

```
2```

# AI分析结果

### 题目内容重写

Mr. Infinity 拥有一个由数字 `1` 到 `9` 组成的字符串 $ S $。这个字符串在每天结束时会发生如下变化：

- 字符串 $ S $ 中的每个 `2` 会被替换为 `22`，`3` 被替换为 `333`，`4` 被替换为 `4444`，`5` 被替换为 `55555`，`6` 被替换为 `666666`，`7` 被替换为 `7777777`，`8` 被替换为 `88888888`，`9` 被替换为 `999999999`。`1` 保持不变。

例如，若 $ S $ 为 `1324`，则第二天会变为 `1333224444`，第三天会变为 `133333333322224444444444444444`。  
你需要知道 $ 5000 $ 兆日后字符串会变成什么样。$ 5000 $ 兆日后的字符串从左数第 $ K $ 个字符是什么？

### 算法分类
数学

### 题解分析与结论

这道题的核心在于理解字符串在经过 $5000$ 兆日后的变化规律。由于 $5000$ 兆日是一个极大的数字，字符串中的非 `1` 字符会迅速膨胀，导致字符串的长度远远超过 $K$。因此，我们只需要关注字符串中第一个非 `1` 的字符，或者如果前 $K$ 个字符都是 `1`，则输出 `1`。

### 所选高分题解

#### 1. 作者：RioBlu (赞：4)
**星级：4.5**  
**关键亮点：**
- 简洁明了地指出了问题的核心：经过 $5000$ 兆日后，非 `1` 字符会无限膨胀，因此只需找到第一个非 `1` 的字符。
- 代码实现简单，直接遍历字符串的前 $K$ 个字符，找到第一个非 `1` 的字符并输出。

**代码核心思想：**
```cpp
for(int s=0;s<a;s++)
{
    if(n[s]!='1')
    {
        cout<<n[s]<<endl;
        return 0;
    }
}
cout<<1<<endl;
```

#### 2. 作者：Otomachi_Una_ (赞：3)
**星级：4.0**  
**关键亮点：**
- 通过举例说明了字符串在几天后的变化，帮助理解问题的本质。
- 代码简洁，直接遍历字符串的前 $K$ 个字符，找到第一个非 `1` 的字符并输出。

**代码核心思想：**
```cpp
for(int i=0;i<k;i++)
    if(s[i]!='1'){
        cout<<s[i]<<endl;
        return 0;
    }
cout<<"1"<<endl;
```

#### 3. 作者：ttq012 (赞：1)
**星级：4.0**  
**关键亮点：**
- 详细分析了问题的数学背景，解释了为什么非 `1` 字符会无限膨胀。
- 代码实现考虑了字符串长度可能小于 $K$ 的情况，增加了代码的鲁棒性。

**代码核心思想：**
```cpp
for (int i = 0; i < k; i ++) {
    if (i >= sz)
        break; // 防止越界
    if (s[i] != '1') {
        idx = s[i] ^ 48;
        break;
    }
}
cout << idx << '\n';
```

### 最优关键思路
- **核心思路**：经过 $5000$ 兆日后，非 `1` 字符会无限膨胀，因此只需找到字符串中第一个非 `1` 的字符，或者如果前 $K$ 个字符都是 `1`，则输出 `1`。
- **实现技巧**：直接遍历字符串的前 $K$ 个字符，找到第一个非 `1` 的字符并输出。

### 可拓展之处
- 类似的问题可以出现在字符串膨胀、字符替换等场景中，理解字符膨胀的规律是关键。
- 可以进一步探讨不同膨胀规则下的字符串变化规律。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

---
处理用时：30.06秒
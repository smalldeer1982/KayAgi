# 题目信息

# [ABC109C] Skip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc109/tasks/abc109_c

数直線上に $ N $ 個の都市があり、$ i $ 番目の都市は座標 $ x_i $ にあります。

あなたの目的は、これら全ての都市を $ 1 $ 度以上訪れることです。

あなたは、はじめに正整数 $ D $ を設定します。

その後、あなたは座標 $ X $ から出発し、以下の移動 $ 1 $、移動 $ 2 $ を好きなだけ行います。

- 移動 $ 1 $: 座標 $ y $ から座標 $ y\ +\ D $ に移動する
- 移動 $ 2 $: 座標 $ y $ から座標 $ y\ -\ D $ に移動する

全ての都市を $ 1 $ 度以上訪れることのできる $ D $ の最大値を求めてください。

ここで、都市を訪れるとは、その都市のある座標に移動することです。

## 说明/提示

### 制約

- 入力はすべて整数である
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ X\ \leq\ 10^9 $
- $ 1\ \leq\ x_i\ \leq\ 10^9 $
- $ x_i $ はすべて異なる
- $ x_1,\ x_2,\ ...,\ x_N\ \neq\ X $

### Sample Explanation 1

$ D\ =\ 2 $ と設定すれば次のように移動を行うことですべての都市を訪れることができ、これが最大です。 - 移動 $ 2 $ を行い、座標 $ 1 $ に移動する - 移動 $ 1 $ を行い、座標 $ 3 $ に移動する - 移動 $ 1 $ を行い、座標 $ 5 $ に移動する - 移動 $ 1 $ を行い、座標 $ 7 $ に移動する - 移動 $ 1 $ を行い、座標 $ 9 $ に移動する - 移動 $ 1 $ を行い、座標 $ 11 $ に移動する

## 样例 #1

### 输入

```
3 3

1 7 11```

### 输出

```
2```

## 样例 #2

### 输入

```
3 81

33 105 57```

### 输出

```
24```

## 样例 #3

### 输入

```
1 1

1000000000```

### 输出

```
999999999```

# AI分析结果

【题目内容】
# [ABC109C] Skip

## 题目描述

数直线上有 $ N $ 个城市，第 $ i $ 个城市位于坐标 $ x_i $。

你的目标是访问所有这些城市至少一次。

你首先设定一个正整数 $ D $。

然后，你从坐标 $ X $ 出发，可以无限次执行以下两种移动：

- 移动 $ 1 $: 从坐标 $ y $ 移动到坐标 $ y + D $
- 移动 $ 2 $: 从坐标 $ y $ 移动到坐标 $ y - D $

求能够访问所有城市至少一次的 $ D $ 的最大值。

访问一个城市意味着移动到该城市所在的坐标。

## 说明/提示

### 制約

- 输入均为整数
- $ 1 \leq N \leq 10^5 $
- $ 1 \leq X \leq 10^9 $
- $ 1 \leq x_i \leq 10^9 $
- $ x_i $ 互不相同
- $ x_1, x_2, ..., x_N \neq X $

### 样例解释 1

设定 $ D = 2 $，则可以通过以下移动访问所有城市，这是最大的 $ D $ 值：
- 移动 $ 2 $，从坐标 $ 3 $ 移动到坐标 $ 1 $
- 移动 $ 1 $，从坐标 $ 1 $ 移动到坐标 $ 3 $
- 移动 $ 1 $，从坐标 $ 3 $ 移动到坐标 $ 5 $
- 移动 $ 1 $，从坐标 $ 5 $ 移动到坐标 $ 7 $
- 移动 $ 1 $，从坐标 $ 7 $ 移动到坐标 $ 9 $
- 移动 $ 1 $，从坐标 $ 9 $ 移动到坐标 $ 11 $

## 样例 #1

### 输入

```
3 3

1 7 11```

### 输出

```
2```

## 样例 #2

### 输入

```
3 81

33 105 57```

### 输出

```
24```

## 样例 #3

### 输入

```
1 1

1000000000```

### 输出

```
999999999```

【算法分类】数学

【题解分析与结论】
该题的核心思路是通过求所有城市与起点距离的最大公约数（GCD）来确定最大的 $ D $ 值。所有题解均采用了这一思路，但在实现细节上有所不同。

【评分较高题解】
1. **亦枫 (4星)**
   - **关键亮点**：直接使用C++自带的 `__gcd` 函数，代码简洁高效。
   - **核心代码**：
     ```cpp
     for(ll i=2;i<=n;i++){
         ans=__gcd(ans,a[i]);
     }
     printf("%d\n",abs(ans));
     ```

2. **zct_sky (4星)**
   - **关键亮点**：自定义了 `gcd` 函数，代码清晰易读。
   - **核心代码**：
     ```cpp
     for(int i=1;i<n;i++)ans=gcd(ans,a[i]); 
     write(abs(ans));
     ```

3. **happybob (4星)**
   - **关键亮点**：使用了 `long long` 类型，避免了可能的溢出问题。
   - **核心代码**：
     ```cpp
     for (int i = 2; i <= n; i++) {
         gcdx = gcd(gcdx, p[i]); 
     }
     printf("%lld\n", abs(gcdx));
     ```

【最优关键思路或技巧】
- **核心思路**：通过求所有城市与起点距离的最大公约数来确定 $ D $ 的最大值。
- **实现技巧**：使用C++自带的 `__gcd` 函数或自定义 `gcd` 函数，确保代码简洁高效。

【可拓展之处】
- **同类型题**：类似的问题可以通过求最大公约数来解决，例如在数轴上移动的最小步数问题。
- **类似算法套路**：在处理与距离或步数相关的问题时，最大公约数是一个常用的数学工具。

【推荐题目】
1. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)
2. [P1087 FBI树](https://www.luogu.com.cn/problem/P1087)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：25.52秒
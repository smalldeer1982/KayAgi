# 题目信息

# [ABC116C] Grand Garden

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc116/tasks/abc116_c

花壇に $ N $ 本の花が咲いており、それぞれ $ 1,2,......,N $ と番号が振られています。最初、全ての花の高さは $ 0 $ です。 数列 $ h=\{h_1,h_2,h_3,......\} $ が入力として与えられます。以下の「水やり」操作を繰り返すことで、すべての $ k(1\ \leqq\ k\ \leqq\ N) $ に対して花 $ k $ の高さを $ h_k $ にしたいです。

- 整数 $ l,r $ を指定する。$ l\ \leqq\ x\ \leqq\ r $ を満たすすべての $ x $ に対して、花 $ x $ の高さを $ 1 $ 高くする。

条件を満たすための最小の「水やり」操作の回数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 100 $
- $ 0\ \leqq\ h_i\ \leqq\ 100 $
- 入力はすべて整数である。

### Sample Explanation 1

「水やり」操作の回数は $ 2 $ 回が最小です。 以下が一つの例です。 - $ (l,r)=(1,3) $ の「水やり」操作を行う。 - $ (l,r)=(2,4) $ の「水やり」操作を行う。

## 样例 #1

### 输入

```
4

1 2 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
5

3 1 2 3 1```

### 输出

```
5```

## 样例 #3

### 输入

```
8

4 23 75 0 23 96 50 100```

### 输出

```
221```

# AI分析结果

### 题目翻译
#### [ABC116C] Grand Garden

**题目描述**

花坛中有 $N$ 朵花，编号为 $1,2,......,N$。最初，所有花的高度均为 $0$。给定一个数列 $h=\{h_1,h_2,h_3,......\}$，通过重复以下「浇水」操作，使得对于所有 $k(1\ \leqq\ k\ \leqq\ N)$，花 $k$ 的高度达到 $h_k$。

- 选择整数 $l,r$，对所有满足 $l\ \leqq\ x\ \leqq\ r$ 的 $x$，将花 $x$ 的高度增加 $1$。

求满足条件的最小「浇水」操作次数。

**说明/提示**

**约束条件**

- $1\ \leqq\ N\ \leqq\ 100$
- $0\ \leqq\ h_i\ \leqq\ 100$
- 输入均为整数。

**样例解释 1**

最小「浇水」操作次数为 $2$ 次。以下为一个示例：
- 进行 $(l,r)=(1,3)$ 的「浇水」操作。
- 进行 $(l,r)=(2,4)$ 的「浇水」操作。

**样例 #1**

**输入**

```
4
1 2 2 1
```

**输出**

```
2
```

**样例 #2**

**输入**

```
5
3 1 2 3 1
```

**输出**

```
5
```

**样例 #3**

**输入**

```
8
4 23 75 0 23 96 50 100
```

**输出**

```
221
```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是通过贪心算法，每次选择连续区间进行「浇水」操作，使得操作次数最小。具体来说，通过遍历花的高度数组，当当前花的高度大于前一个花的高度时，累加两者之间的差值，即为所需的最小操作次数。

### 所选高分题解
#### 题解作者：_easy_ (赞：4)
**星级：4星**
**关键亮点：**
- 简洁明了的贪心思路，直接通过差值累加得到最小操作次数。
- 代码简洁，易于理解。

**核心代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,a[N],ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]>a[i-1]){
            ans+=a[i]-a[i-1];
        }
    }
    cout<<ans;
}
```
**实现思想：**
遍历数组，当当前元素大于前一个元素时，累加两者差值，最终输出累加结果。

#### 题解作者：Maxmilite (赞：0)
**星级：4星**
**关键亮点：**
- 详细解释了贪心策略的正确性，通过图示直观展示了操作过程。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    long long n, a, last(0), ans(0);
    cin >> n;
    for (long long i = 1; i <= n; ++i)
    {
        cin >> a;
        ans += a > last ? (a - last) : 0;
        last = a;
    }
    cout << ans << endl;
    return 0;
}
```
**实现思想：**
遍历数组，当当前元素大于前一个元素时，累加两者差值，最终输出累加结果。

#### 题解作者：leoair (赞：0)
**星级：4星**
**关键亮点：**
- 使用了快读优化输入，提高了代码效率。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
#include <bits/stdc++.h>
#define REP(i, a, b) for (long long i = a; i <= b; ++i)
#define ll long long
#define N 110
using namespace std;

ll n, ans, a[N];

inline ll read(){										//快读 
    ll s = 0, w = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9'){
        if (ch == '-') w *= -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9'){
        s = s * 10 + ch - '0';
        ch = getchar();
    }
    return s * w;
}

int main(){
    n = read();											//有n朵花 
    REP(i, 1, n) a[i] = read();							//最后要求第i朵花的高度 
    REP(i, 1, n)
        if (a[i - 1] < a[i]) ans += a[i] - a[i - 1];	//如果这朵花比前1朵花的矮那就加上这2朵的高度之差 
    printf("%lld\n", ans);
    return 0;
}
```
**实现思想：**
遍历数组，当当前元素大于前一个元素时，累加两者差值，最终输出累加结果。

### 最优关键思路
通过贪心算法，每次选择连续区间进行「浇水」操作，使得操作次数最小。具体实现时，遍历花的高度数组，当当前花的高度大于前一个花的高度时，累加两者之间的差值，即为所需的最小操作次数。

### 可拓展之处
类似的问题可以扩展到其他需要区间操作的场景，如区间赋值、区间求和等。贪心算法在这些问题中也有广泛应用。

### 推荐题目
1. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)
2. [P3078 [USACO13MAR]Poker Hands S](https://www.luogu.com.cn/problem/P3078)
3. [P5019 [NOIP2018 提高组] 铺设道路](https://www.luogu.com.cn/problem/P5019)

---
处理用时：35.77秒
# 题目信息

# [ABC117C] Streamline

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc117/tasks/abc117_c

数直線と $ N $ 個のコマを用いて $ 1 $ 人でゲームを行います。

はじめ、これらのコマをそれぞれ好きな整数座標に置きます。

このとき、同じ座標に複数のコマを置いても構いません。

以下の移動を繰り返して、座標 $ X_1,\ X_2,\ ...,\ X_M $ の $ M $ 個の地点全てをいずれかのコマで訪れることが目的です。

**移動**: コマを $ 1 $ つ選び、そのコマの座標を $ x $ とする。そのコマを座標 $ x+1 $ もしくは座標 $ x-1 $ に移動する。

ただし、最初にコマを置いた座標はその時点で訪れたとみなします。

目的を達成するまでに移動を行う回数の最小値を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ -10^5\ \leq\ X_i\ \leq\ 10^5 $
- $ X_1,\ X_2,\ ...,\ X_M $ は全て異なる。

### Sample Explanation 1

以下の手順で $ 5 $ 回移動を行うと目的を達成でき、このときが最小です。 - はじめに $ 2 $ 個のコマをそれぞれ座標 $ 1 $, 座標 $ 10 $ に置きます。 - 座標 $ 1 $ のコマを座標 $ 2 $ に移動します。 - 座標 $ 10 $ のコマを座標 $ 11 $ に移動します。 - 座標 $ 11 $ のコマを座標 $ 12 $ に移動します。 - 座標 $ 12 $ のコマを座標 $ 13 $ に移動します。 - 座標 $ 13 $ のコマを座標 $ 14 $ に移動します。

## 样例 #1

### 输入

```
2 5

10 12 1 2 14```

### 输出

```
5```

## 样例 #2

### 输入

```
3 7

-10 -3 0 9 -100 2 17```

### 输出

```
19```

## 样例 #3

### 输入

```
100 1

-100000```

### 输出

```
0```

# AI分析结果

### 题目翻译
【题目内容】
# [ABC117C] Streamline

## 题目描述

数直线上有 $N$ 个棋子，初始时可以将这些棋子放置在任意整数坐标上，且允许多个棋子放在同一坐标。目标是通过移动棋子，使得所有 $M$ 个目标点 $X_1, X_2, ..., X_M$ 都被至少一个棋子访问到。每次移动可以选择一个棋子，将其坐标 $x$ 移动到 $x+1$ 或 $x-1$。初始放置棋子的位置视为已经访问过。求达成目标所需的最小移动次数。

## 说明/提示

### 制約

- 输入均为整数。
- $1 \leq N \leq 10^5$
- $1 \leq M \leq 10^5$
- $-10^5 \leq X_i \leq 10^5$
- $X_1, X_2, ..., X_M$ 互不相同。

### 样例解释 1

初始将两个棋子分别放在坐标 $1$ 和 $10$，然后通过 $5$ 次移动即可访问所有目标点，这是最小移动次数。

## 样例 #1

### 输入

```
2 5
10 12 1 2 14
```

### 输出

```
5
```

## 样例 #2

### 输入

```
3 7
-10 -3 0 9 -100 2 17
```

### 输出

```
19
```

## 样例 #3

### 输入

```
100 1
-100000
```

### 输出

```
0
```

### 算法分类
贪心

### 题解分析与结论
所有题解均采用了贪心算法，核心思路是对目标点进行排序，计算相邻点之间的距离，并减去最大的 $N-1$ 个距离，以最小化移动次数。以下是评分较高的题解：

#### 题解1：作者：_dijkstra_ (4星)
**关键亮点**：
- 代码简洁，逻辑清晰。
- 通过排序和贪心策略直接求解，避免了复杂的计算。

**核心代码**：
```cpp
sort(x+1, x+m+1);
int d = x[m] - x[1];
for (int i = 1; i < m; i++) x[i] = x[i+1] - x[i];
sort(x+1, x+m, cmp);
for (int i = 1; i < n; i++) d -= x[i];
printf("%d", d);
```

#### 题解2：作者：wbs200 (4星)
**关键亮点**：
- 详细解释了贪心策略的合理性。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
sort(a + 1, a + m + 1);
for (int i = 1; i <= m - 1; i++) d[i] = a[i + 1] - a[i];
sort(d + 1, d + m, cmp);
int sum = a[m] - a[1];
for (int i = 1; i <= n - 1; i++) sum -= d[i];
cout << sum << endl;
```

#### 题解3：作者：猜一猜我是谁 (4星)
**关键亮点**：
- 代码简洁，直接应用贪心策略。
- 通过样例解释增强了理解。

**核心代码**：
```cpp
sort(a+1, a+m+1);
for (int i=1; i<m; i++) d[i]=a[i+1]-a[i];
sort(d+1, d+m, cmp);
int ans=a[m]-a[1];
for (int i=1; i<n; i++) ans-=d[i];
cout<<ans;
```

### 最优关键思路
1. **排序**：首先对目标点进行排序，便于计算相邻点之间的距离。
2. **贪心策略**：通过减去最大的 $N-1$ 个距离，最小化移动次数。

### 拓展思路
类似题目可以考察如何通过贪心策略优化覆盖问题，如[P1209 [USACO1.3]修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1209)。

### 推荐题目
1. [P1209 [USACO1.3]修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1209)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)

---
处理用时：29.10秒
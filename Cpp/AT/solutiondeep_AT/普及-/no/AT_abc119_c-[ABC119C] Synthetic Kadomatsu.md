# 题目信息

# [ABC119C] Synthetic Kadomatsu

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc119/tasks/abc119_c

あなたは $ N $ 本の竹を持っています。これらの長さはそれぞれ $ l_1,\ l_2,\ ...,\ l_N $ です (単位: センチメートル)。

あなたの目的は、これらの竹のうち何本か (全部でもよい) を使い、長さが $ A,\ B,\ C $ であるような $ 3 $ 本の竹を得ることです。そのために、以下の三種類の魔法を任意の順に何度でも使うことができます。

- 延長魔法: $ 1 $ *MP* (マジックポイント) を消費し、$ 1 $ 本の竹を選んでその長さを $ 1 $ 増やす。
- 短縮魔法: $ 1 $ MP を消費し、$ 1 $ 本の長さ $ 2 $ 以上の竹を選んでその長さを $ 1 $ 減らす。
- 合成魔法: $ 10 $ MP を消費し、$ 2 $ 本の竹を選んで接続し $ 1 $ 本の竹とする。この新たな竹の長さは接続した $ 2 $ 本の竹の長さの合計に等しい。(以後、この竹に対してさらに魔法を使用することもできる。)

目的を達成するには、最小でいくつの MP が必要でしょうか？

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 8 $
- $ 1\ \leq\ C\ <\ B\ <\ A\ \leq\ 1000 $
- $ 1\ \leq\ l_i\ \leq\ 1000 $
- 入力される値はすべて整数である。

### Sample Explanation 1

長さ $ 98,\ 40,\ 30,\ 21,\ 80 $ の $ 5 $ 本の竹から長さ $ 100,\ 90,\ 80 $ の $ 3 $ 本の竹を得ようとしています。長さ $ 80 $ の竹ははじめから持っており、長さ $ 100,\ 90 $ の竹は次のように魔法を使うと合計 $ 23 $ MP を消費することで得られ、これが最適です。 1. 長さ $ 98 $ の竹に延長魔法を $ 2 $ 回使い、長さ $ 100 $ の竹を得る。(消費 MP: $ 2 $) 2. 長さ $ 40,\ 30 $ の竹に合成魔法を使い、長さ $ 70 $ の竹を得る。(消費 MP: $ 10 $) 3. 長さ $ 21 $ の竹に短縮魔法を $ 1 $ 回使い、長さ $ 20 $ の竹を得る。(消費 MP: $ 1 $) 4. 手順 2. で得た長さ $ 70 $ の竹と手順 3. で得た長さ $ 20 $ の竹に合成魔法を使い、長さ $ 90 $ の竹を得る。(消費 MP: $ 10 $)

### Sample Explanation 2

欲しい長さの竹をすでにすべて持っている場合、必要な MP は $ 0 $ です。このように、必ずしもすべての竹を使う必要はありません。

## 样例 #1

### 输入

```
5 100 90 80

98

40

30

21

80```

### 输出

```
23```

## 样例 #2

### 输入

```
8 100 90 80

100

100

90

90

90

80

80

80```

### 输出

```
0```

## 样例 #3

### 输入

```
8 1000 800 100

300

333

400

444

500

555

600

666```

### 输出

```
243```

# AI分析结果

### 题目内容
你拥有 $N$ 根竹子，它们的长度分别为 $l_1, l_2, ..., l_N$（单位：厘米）。你的目标是从这些竹子中选择一些（可以是全部），通过使用以下三种魔法，得到长度分别为 $A, B, C$ 的三根竹子。每种魔法可以任意顺序使用多次：

1. **延長魔法**：消耗 $1$ MP，将一根竹子的长度增加 $1$。
2. **短縮魔法**：消耗 $1$ MP，将一根长度至少为 $2$ 的竹子的长度减少 $1$。
3. **合成魔法**：消耗 $10$ MP，将两根竹子连接成一根，新竹子的长度为两根竹子长度之和。

求达成目标所需的最小 MP。

### 算法分类
深度优先搜索 (DFS)

### 题解分析与结论
本题的核心是通过深度优先搜索 (DFS) 枚举所有可能的竹子组合和魔法使用方式，找到最小 MP 的方案。由于 $N$ 的范围较小（$3 \leq N \leq 8$），DFS 是一种可行的解决方案。

### 题解评分与亮点
1. **题解作者：Otomachi_Una_ (赞：8)**
   - **星级：4.5**
   - **关键亮点**：先合成所有竹子再进行加减操作，简化了问题的复杂度。通过 DFS 枚举所有可能的竹子组合，并在每次递归中更新答案。代码简洁，逻辑清晰。
   - **个人心得**：作者提到在计算答案时需要减去 $30$ MP，因为初始状态不需要魔法点，这一细节处理得当。

2. **题解作者：liangbowen (赞：3)**
   - **星级：4**
   - **关键亮点**：采用暴力搜索的方式，将竹子分配给目标竹子使用，并通过 DFS 枚举所有可能的分配方案。代码效率较高，未做优化但运行时间较短。
   - **个人心得**：作者提到代码效率超出预期，未做优化但运行时间仅为八毫秒，展示了 DFS 在实际应用中的高效性。

### 最优关键思路
- **先合成再调整**：先将竹子通过合成魔法组合成目标竹子的雏形，再通过延长或缩短魔法调整到目标长度，这样可以减少计算复杂度。
- **DFS 枚举**：通过 DFS 枚举所有可能的竹子组合和魔法使用方式，确保找到最小 MP 的方案。

### 可拓展之处
- **类似问题**：类似的问题可以扩展到更多目标竹子或更多魔法类型，DFS 仍然是一种有效的解决方案。
- **优化思路**：可以通过剪枝或记忆化搜索进一步优化 DFS 的效率，减少不必要的递归调用。

### 推荐题目
1. [P1219 八皇后问题](https://www.luogu.com.cn/problem/P1219)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)

### 核心代码片段
```cpp
void dfs(int p, int A, int B, int C, int val) {
    if (A != 0 && B != 0 && C != 0)
        ans = min(ans, abs(A - a) + abs(B - b) + abs(C - c) + val - 30);
    if (p > n) 
        return;
    dfs(p + 1, A + l[p], B, C, val + 10);
    dfs(p + 1, A, B + l[p], C, val + 10);
    dfs(p + 1, A, B, C + l[p], val + 10);
    dfs(p + 1, A, B, C, val);
}
```
这段代码通过 DFS 枚举所有可能的竹子组合，并在每次递归中更新最小 MP 的答案。

---
处理用时：22.61秒
# 题目信息

# [ABC120C] Unification

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc120/tasks/abc120_c

机の上に $ N $ 個のキューブが縦に積まれています。長さ $ N $ の文字列 $ S $ が与えられます。

下から $ i $ 番目のキューブの色は、$ S $ の $ i $ 文字目が `0` のとき赤色、`1` のとき青色です。

あなたは、赤色のキューブと青色のキューブが隣り合っているような部分を選んで、それら $ 2 $ 個のキューブを取り除く操作を何度でも行えます。

このとき、取り除いたキューブの上にあったキューブは真下の物体の上に落下します。

最大で何個のキューブを取り除けるでしょうか。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ |S|\ =\ N $
- $ S $ の各文字は `0` または `1` である。

### Sample Explanation 1

以下の順に操作を行うと $ 4 $ 個全てのキューブを取り除けます。 - 下から $ 2 $ 番目のキューブと $ 3 $ 番目のキューブを取り除きます。その結果、下から $ 4 $ 番目のキューブが下から $ 1 $ 番目のキューブの上に落下します。 - 下から $ 1 $ 番目のキューブと $ 2 $ 番目のキューブを取り除きます。

## 样例 #1

### 输入

```
0011```

### 输出

```
4```

## 样例 #2

### 输入

```
11011010001011```

### 输出

```
12```

## 样例 #3

### 输入

```
0```

### 输出

```
0```

# AI分析结果

### 题目翻译
[ABC120C] Unification

#### 题目描述
桌上有 $N$ 个立方体垂直堆叠在一起。给定一个长度为 $N$ 的字符串 $S$。

从下往上第 $i$ 个立方体的颜色为：如果 $S$ 的第 $i$ 个字符是 `0`，则为红色；如果是 `1`，则为蓝色。

你可以选择相邻的红色和蓝色立方体，并将它们移除。移除后，上面的立方体会落到下面的物体上。

你可以进行任意次数的操作，最多可以移除多少个立方体？

#### 说明/提示
##### 约束
- $1 \leq N \leq 10^5$
- $|S| = N$
- $S$ 的每个字符是 `0` 或 `1`。

##### 样例解释 1
通过以下顺序操作，可以移除所有 4 个立方体：
1. 移除从下往上第 2 和第 3 个立方体。结果，第 4 个立方体落到第 1 个立方体上。
2. 移除从下往上第 1 和第 2 个立方体。

#### 样例 #1
##### 输入
```
0011
```
##### 输出
```
4
```

#### 样例 #2
##### 输入
```
11011010001011
```
##### 输出
```
12
```

#### 样例 #3
##### 输入
```
0
```
##### 输出
```
0
```

### 算法分类
贪心

### 题解分析与结论
这道题的核心思路是统计字符串中 `0` 和 `1` 的数量，然后取两者的最小值乘以 2，即为可以移除的立方体数量。这个思路基于贪心算法，因为每次移除一对 `0` 和 `1` 都会减少两者的数量，最终当其中一种字符的数量为 0 时，无法再进行移除操作。

### 所选高星题解
#### 题解 1：作者：_lzy_ (赞：2)
##### 星级：4
##### 关键亮点
- 思路清晰，直接统计 `0` 和 `1` 的数量，取最小值乘以 2。
- 代码简洁，易于理解。

##### 核心代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[110000];
int x,y;
int main()
{
	cin>>s;
	int l=strlen(s);
	for(int i=0;i<l;i++)if(s[i]=='0')x++;else y++;//统计0和1的数量。
	if(x>y)cout<<y*2;//求完最大值并且输出。
	else cout<<x*2;
	return 0;
}
```

#### 题解 2：作者：XKqwq (赞：0)
##### 星级：4
##### 关键亮点
- 详细解释了为什么取最小值乘以 2 的原因。
- 代码简洁，使用桶排统计字符数量。

##### 核心代码
```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
int cnt[2]; 
int main(){
	cin>>s;
	int l=s.size();
	for(int i=0;i<l;i++) cnt[s[i]-'0']++; //这里用桶排，可以不写判断。
	printf("%d\n", 2* min(cnt[0],cnt[1]) ); // 这里套公式。
	return 0;
}
```

#### 题解 3：作者：_空白_ (赞：0)
##### 星级：4
##### 关键亮点
- 通过分类讨论解释了为什么取最小值乘以 2。
- 代码简洁，直接统计字符数量并输出结果。

##### 核心代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100010]; 
int main()
{
    int n,sumo=0,sumz=0;
    cin>>s;
    int len=strlen(s);
    for(int i=0;i<=len-1;i++)
    {
        if(s[i]=='1') 
            sumo++;
        if(s[i]=='0') 
            sumz++;
    }
    cout<<min(sumo,sumz)*2<<endl;
    return 0;
}
```

### 最优关键思路
统计字符串中 `0` 和 `1` 的数量，取最小值乘以 2，即为可以移除的立方体数量。这个思路基于贪心算法，每次移除一对 `0` 和 `1` 都会减少两者的数量，最终当其中一种字符的数量为 0 时，无法再进行移除操作。

### 可拓展之处
类似的问题可以扩展到其他字符或数字的匹配移除，或者扩展到多维度的匹配移除问题。

### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：29.72秒
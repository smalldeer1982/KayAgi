# 题目信息

# [ABC126C] Dice and Coin

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_c

すぬけ君は $ 1 $ 〜 $ N $ の整数が等確率で出る $ N $ 面サイコロと表と裏が等確率で出るコインを持っています。すぬけ君は、このサイコロとコインを使って今から次のようなゲームをします。

1. まず、サイコロを $ 1 $ 回振り、出た目を現在の得点とする。
2. 得点が $ 1 $ 以上 $ K-1 $ 以下である限り、すぬけ君はコインを振り続ける。表が出たら得点は $ 2 $ 倍になり、裏が出たら得点は $ 0 $ になる。
3. 得点が $ 0 $ になった、もしくは $ K $ 以上になった時点でゲームが終了する。このとき、得点が $ K $ 以上である場合すぬけ君の勝ち、 $ 0 $ である場合すぬけ君の負けである。

$ N $ と $ K $ が与えられるので、このゲームですぬけ君が勝つ確率を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ K\ <\ =\ 10^5 $
- 入力はすべて整数

### Sample Explanation 1

\- サイコロの出た目が $ 1 $ のとき、得点が $ 10 $ 以上になるためには、 $ 4 $ 回コインを振って $ 4 $ 連続で表が出る必要があります。この確率は、 $ \frac{1}{3}\ \times\ (\frac{1}{2})^4\ =\ \frac{1}{48} $ です。 - サイコロの出た目が $ 2 $ のとき、得点が $ 10 $ 以上になるためには、 $ 3 $ 回コインを振って $ 3 $ 連続で表が出る必要があります。この確率は、 $ \frac{1}{3}\ \times\ (\frac{1}{2})^3\ =\ \frac{1}{24} $ です。 - サイコロの出た目が $ 3 $ のとき、得点が $ 10 $ 以上になるためには、 $ 2 $ 回コインを振って $ 2 $ 連続で表が出る必要があります。この確率は、 $ \frac{1}{3}\ \times\ (\frac{1}{2})^2\ =\ \frac{1}{12} $ です。 よって、すぬけ君が勝つ確率は、 $ \frac{1}{48}\ +\ \frac{1}{24}\ +\ \frac{1}{12}\ =\ \frac{7}{48}\ \simeq\ 0.1458333333 $ です。

## 样例 #1

### 输入

```
3 10```

### 输出

```
0.145833333333```

## 样例 #2

### 输入

```
100000 5```

### 输出

```
0.999973749998```

# AI分析结果

### 题目翻译
【题目描述】
すぬけ君有一个 $1$ 到 $N$ 的整数等概率出现的 $N$ 面骰子和一个正反面等概率出现的硬币。すぬけ君将使用这个骰子和硬币进行如下游戏：

1. 首先，掷一次骰子，得到的点数作为当前得分。
2. 如果得分在 $1$ 到 $K-1$ 之间，すぬけ君将继续掷硬币。如果出现正面，得分将翻倍；如果出现反面，得分将变为 $0$。
3. 当得分变为 $0$ 或达到 $K$ 及以上时，游戏结束。如果得分达到 $K$ 及以上，すぬけ君获胜；如果得分为 $0$，すぬけ君失败。

给定 $N$ 和 $K$，求すぬけ君获胜的概率。

### 算法分类
概率论

### 题解分析与结论
所有题解的核心思路都是通过枚举骰子的初始值，计算每个初始值对应的获胜概率，最后将所有概率相加。难点在于如何高效计算每个初始值的获胜概率，尤其是在 $N$ 和 $K$ 较大时。

#### 题解评分与亮点
1. **阿丑 (4星)**
   - **亮点**：详细解释了概率计算的递推关系，并通过图示帮助理解。代码简洁，时间复杂度为 $O(n \log k)$，适合大规模数据。
   - **代码核心**：
     ```cpp
     double p=1;
     while(j<k) {
         j*=2;
         p/=2;
     }
     ans+=p/n;
     ```

2. **xgwpp6710 (4星)**
   - **亮点**：代码结构清晰，直接模拟了游戏过程，易于理解。同样时间复杂度为 $O(n \log k)$。
   - **代码核心**：
     ```cpp
     double p0=1/n;
     while(i0<k) {
         i0*=2;
         p0/=2;
     }
     p+=p0;
     ```

3. **liangbowen (4星)**
   - **亮点**：强调了输出精度的重要性，并提供了详细的注释，适合初学者理解。代码结构清晰，时间复杂度为 $O(n \log k)$。
   - **代码核心**：
     ```cpp
     double ans = 1.0 / n;
     while (true) {
         if (score >= k) break;
         score *= 2;
         ans /= 2;
     }
     return ans;
     ```

### 最优关键思路
通过枚举骰子的初始值，计算每个初始值对应的获胜概率，最后将所有概率相加。核心技巧是利用递推关系 $P(j) = \frac{1}{2} P(2j)$，直到 $2^m j \geq k$，此时 $P(2^m j) = 1$。

### 拓展思路
类似的问题可以扩展到其他概率计算场景，如多阶段决策问题、马尔可夫链等。可以通过动态规划或递推的方法来解决。

### 推荐题目
1. [P1291 期望计算](https://www.luogu.com.cn/problem/P1291)
2. [P1654 期望](https://www.luogu.com.cn/problem/P1654)
3. [P1850 期望](https://www.luogu.com.cn/problem/P1850)

---
处理用时：22.46秒
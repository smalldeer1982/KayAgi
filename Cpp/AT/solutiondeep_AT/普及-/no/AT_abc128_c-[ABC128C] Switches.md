# 题目信息

# [ABC128C] Switches

## 题目描述

有 $n$ 个开关和 $m$ 个灯泡，每个开关都处于“开”和“关”状态中的一种。开关从 $1$ 到 $n$ 编号，灯泡从 $1$ 到 $m$ 编号。

$i$ 号灯泡连接着 $k_i$ 个开关：开关 $s_{i,1}$，$s_{i,2}$，...，$s_{i,k_i}$。当这些开关中，处于“开”状态的开关数量之和模 2 余 $p_i$ 时，这个灯泡就会被点亮。

有多少“开”和“关”的组合，可以点亮所有灯泡？

## 说明/提示

* $1\le N,M \le 10$

* $1 \le k_i \le N$

* $1 \le s_{i,j} \le N$

* $s_{i,a} \neq s_{i,b} (a \neq b)$

* $p_i$ 只能是 $0$ 或 $1$

* 上述所有值都是整数

#### 样例 1/样例 4

* 灯泡 $1$ 当以下开关里开着的总数是偶数时会亮：开关 $1$ 和 $2$。

* 灯泡 $2$ 当以下开关里开着的总数是奇数是会亮：开关 $2$。

开关 $1$ 和 $2$ 一共组成了四种组合：(开，开)，（开，关），（关，开）和（关，关）。其中只有（开，开）满足要求，所以输出 $1$。

#### 样例 2/样例 5

* 灯泡 $1$ 当以下开关里开着的总数是偶数时会亮：开关 $1$ 和 $2$。

* 灯泡 $2$ 当以下开关里开着的总数是偶数时会亮：开关 $1$。

* 灯泡 $3$ 当以下开关里开着的总数是奇数时会亮：开关 $2$。

为了点亮灯泡 $2$，开关 $1$ 必须是关着的；为了点亮灯泡 $3$，开关 $2$ 必须是开着的。但这样灯泡 $1$ 就不能被点亮了。所以，没有组合能让所有灯泡亮起来，故输出 $0$。

## 样例 #1

### 输入

```
2 2

2 1 2

1 2

0 1```

### 输出

```
1```

## 样例 #2

### 输入

```
2 3

2 1 2

1 1

1 2

0 0 1```

### 输出

```
0```

## 样例 #3

### 输入

```
5 2

3 1 2 5

2 2 3

1 0```

### 输出

```
8```

# AI分析结果

【题目内容】
# [ABC128C] Switches

## 题目描述

有 $n$ 个开关和 $m$ 个灯泡，每个开关都处于“开”和“关”状态中的一种。开关从 $1$ 到 $n$ 编号，灯泡从 $1$ 到 $m$ 编号。

$i$ 号灯泡连接着 $k_i$ 个开关：开关 $s_{i,1}$，$s_{i,2}$，...，$s_{i,k_i}$。当这些开关中，处于“开”状态的开关数量之和模 2 余 $p_i$ 时，这个灯泡就会被点亮。

有多少“开”和“关”的组合，可以点亮所有灯泡？

## 说明/提示

* $1\le N,M \le 10$

* $1 \le k_i \le N$

* $1 \le s_{i,j} \le N$

* $s_{i,a} \neq s_{i,b} (a \neq b)$

* $p_i$ 只能是 $0$ 或 $1$

* 上述所有值都是整数

#### 样例 1/样例 4

* 灯泡 $1$ 当以下开关里开着的总数是偶数时会亮：开关 $1$ 和 $2$。

* 灯泡 $2$ 当以下开关里开着的总数是奇数是会亮：开关 $2$。

开关 $1$ 和 $2$ 一共组成了四种组合：(开，开)，（开，关），（关，开）和（关，关）。其中只有（开，开）满足要求，所以输出 $1$。

#### 样例 2/样例 5

* 灯泡 $1$ 当以下开关里开着的总数是偶数时会亮：开关 $1$ 和 $2$。

* 灯泡 $2$ 当以下开关里开着的总数是偶数时会亮：开关 $1$。

* 灯泡 $3$ 当以下开关里开着的总数是奇数时会亮：开关 $2$。

为了点亮灯泡 $2$，开关 $1$ 必须是关着的；为了点亮灯泡 $3$，开关 $2$ 必须是开着的。但这样灯泡 $1$ 就不能被点亮了。所以，没有组合能让所有灯泡亮起来，故输出 $0$。

## 样例 #1

### 输入

```
2 2

2 1 2

1 2

0 1```

### 输出

```
1```

## 样例 #2

### 输入

```
2 3

2 1 2

1 1

1 2

0 0 1```

### 输出

```
0```

## 样例 #3

### 输入

```
5 2

3 1 2 5

2 2 3

1 0```

### 输出

```
8```

【算法分类】
枚举

【题解分析与结论】
本题的核心思路是通过枚举所有可能的开关状态组合，然后检查每种组合是否满足所有灯泡的点亮条件。由于数据范围较小（$n \leq 10$），直接使用深度优先搜索（DFS）或二进制枚举都是可行的。

各题解的思路基本一致，都是通过枚举开关状态，然后逐一检查每个灯泡的点亮条件。主要区别在于实现方式，有的使用DFS递归，有的使用二进制枚举。

【评分较高的题解】
1. **作者：lkjzyd20**（评分：4星）
   - 关键亮点：使用DFS递归枚举开关状态，代码结构清晰，逻辑简单易懂。
   - 个人心得：作者提到数据范围小，DFS的时间复杂度完全可以接受，且代码实现简洁。
   - 核心代码：
     ```cpp
     void dfs(int step){
         if(step>n){
             rep(i,1,m){
                 int sum=0;
                 rep(j,0,num[i]){
                     if(flag[v[i][j]]) ++sum;
                 }
                 if(sum%2!=p[i]) return;
             }
             ++ans;
             return;
         }
         flag[step]=1; dfs(step+1);
         flag[step]=0; dfs(step+1);
     }
     ```

2. **作者：Obviathy**（评分：4星）
   - 关键亮点：使用二进制枚举开关状态，代码简洁且高效，适合对位运算熟悉的读者。
   - 个人心得：作者提到二进制枚举的思路，并给出了位运算优化的代码，进一步提升了效率。
   - 核心代码：
     ```cpp
     for(int i = 0;i <= (1<<n)-1;i ++){
         int f = 0;
         for(int j = 1;j <= m;j ++){
             int cnt = 0;
             f = 0;
             for(int t = 1;t <= k[j];t ++)if((i>>sk[j][t]-1)&1)cnt ++;
             if(cnt % 2 == p[j])f = 1;  
             else break;
         }
         if(f==1)ans++;
     }
     ```

【最优关键思路】
- **DFS递归枚举**：通过递归枚举每个开关的状态，逐步构建所有可能的组合，并在递归结束时检查是否满足所有灯泡的点亮条件。
- **二进制枚举**：利用二进制数的每一位表示开关的状态，通过循环枚举所有可能的二进制数，并检查每种状态是否满足条件。

【可拓展之处】
- 类似的问题可以扩展到更大的数据范围，或者更复杂的条件判断。例如，灯泡的点亮条件可能不仅仅是开关数量的奇偶性，还可能是其他数学关系。
- 对于更大的数据范围，可以考虑使用剪枝优化或动态规划来减少枚举的次数。

【推荐题目】
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
2. [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

---
处理用时：35.09秒
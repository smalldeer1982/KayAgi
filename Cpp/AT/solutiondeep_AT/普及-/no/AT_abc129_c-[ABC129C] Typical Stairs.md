# 题目信息

# [ABC129C] Typical Stairs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc129/tasks/abc129_c

$ N $ 段の階段があります。高橋君は現在、上り口($ 0 $ 段目)にいます。 高橋君は一歩で $ 1 $ 段か $ 2 $ 段上ることができます。

ただし、$ a_1,a_2,a_3,....a_M $ 段目の床は壊れており、その段に足を踏み入れることは危険です。

壊れている床を踏まないようにしながら、最上段($ N $ 段目)にたどりつくまでの移動方法は何通りあるでしょうか？ 総数を $ 1,000,000,007 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 10^5 $
- $ 0\ \leqq\ M\ \leqq\ N-1 $
- $ 1\ \leqq\ a_1\ ... $ $  $

### Sample Explanation 1

移動方法は以下の $ 4 $ 通りです。 - $ 0\ \to\ 1\ \to\ 2\ \to\ 4\ \to\ 5\ \to\ 6 $ - $ 0\ \to\ 1\ \to\ 2\ \to\ 4\ \to\ 6 $ - $ 0\ \to\ 2\ \to\ 4\ \to\ 5\ \to\ 6 $ - $ 0\ \to\ 2\ \to\ 4\ \to\ 6 $

### Sample Explanation 2

壊れている床を踏まないような移動方法がない場合もあります。

### Sample Explanation 3

総数を $ 1,000,000,007 $ で割った余りを出力することに注意して下さい。

## 样例 #1

### 输入

```
6 1

3```

### 输出

```
4```

## 样例 #2

### 输入

```
10 2

4

5```

### 输出

```
0```

## 样例 #3

### 输入

```
100 5

1

23

45

67

89```

### 输出

```
608200469```

# AI分析结果

### 题目内容重写
【题目描述】
有 $N$ 级台阶。高桥君现在位于第 $0$ 级台阶。高桥君每次可以向上走 $1$ 级或 $2$ 级台阶。

然而，第 $a_1, a_2, a_3, \dots, a_M$ 级台阶是坏的，不能踩踏。

在不踩踏坏台阶的情况下，高桥君到达第 $N$ 级台阶的移动方法有多少种？请将结果对 $1,000,000,007$ 取模后输出。

【说明/提示】
### 样例 #1
#### 输入
```
6 1
3
```
#### 输出
```
4
```

### 样例 #2
#### 输入
```
10 2
4
5
```
#### 输出
```
0
```

### 样例 #3
#### 输入
```
100 5
1
23
45
67
89
```
#### 输出
```
608200469
```

### 算法分类
递推

### 题解分析与结论
本题的核心思路是通过递推计算到达每一级台阶的方案数，同时考虑坏台阶的影响。大多数题解都采用了类似的递推公式：$f_i = f_{i-1} + f_{i-2}$，其中 $f_i$ 表示到达第 $i$ 级台阶的方案数。如果第 $i$ 级台阶是坏的，则 $f_i = 0$。初始化时，$f_0 = 1$，表示起点有一种方案。

### 评分较高的题解
#### 1. 作者：Grisses (4星)
**关键亮点**：
- 使用 `unordered_map` 来标记坏台阶，提高了查找效率。
- 代码简洁明了，递推部分逻辑清晰。

**核心代码**：
```cpp
f[0] = 1;
if(M.count(1)==0) f[1]=1;
for(int i=2;i<=n;i++){
    if(M.count(i)==1) f[i]=0;
    else f[i]=(f[i-1]+f[i-2])%mod;
}
```

#### 2. 作者：cqbztz2 (4星)
**关键亮点**：
- 强调了本题是递推而非动态规划，区分了递推与动态规划的区别。
- 代码结构清晰，初始化部分处理得当。

**核心代码**：
```cpp
a[0]=1;
for(int i=1;i<=n;i++){
    if(f[i]) continue;
    a[i]=a[i-1]+a[i-2];
    a[i]%=mod;
}
```

#### 3. 作者：Ender_NaCl (4星)
**关键亮点**：
- 详细解释了递推与动态规划的区别，强调了本题的递推性质。
- 代码中加入了边界值的判断，确保初始化正确。

**核心代码**：
```cpp
if(!bad[0]) f[0] = 1;
if(!bad[1]) f[1] = 1;
for(int i=2;i<=n;i++){
    if(!bad[i]) f[i]=(f[i-1]+f[i-2])%MOD;
}
```

### 最优关键思路或技巧
1. **递推公式**：$f_i = f_{i-1} + f_{i-2}$，结合坏台阶的处理，即 $f_i = 0$。
2. **初始化**：$f_0 = 1$，表示起点有一种方案。
3. **数据结构**：使用 `unordered_map` 或 `bool` 数组来标记坏台阶，提高查找效率。

### 可拓展之处
本题可以拓展为每次可以走 $k$ 级台阶的情况，递推公式变为 $f_i = f_{i-1} + f_{i-2} + \dots + f_{i-k}$。此外，可以增加更多限制条件，如某些台阶只能从特定台阶到达。

### 推荐题目
1. [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)
2. [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)

---
处理用时：26.64秒
# 题目信息

# [ABC135C] City Savers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc135/tasks/abc135_c

$ N+1 $ 個の街があり、$ i $ 番目の街は $ A_i $ 体のモンスターに襲われています。

$ N $ 人の勇者が居て、$ i $ 番目の勇者は $ i $ 番目または $ i+1 $ 番目の街を襲っているモンスターを合計で $ B_i $ 体まで倒すことができます。

$ N $ 人の勇者がうまく協力することで、合計して最大で何体のモンスターを倒せるでしょうか。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $

### Sample Explanation 1

以下のようにモンスターを倒すと、合計 $ 9 $ 体のモンスターを倒すことができ、このときが最大です。 - $ 1 $ 番目の勇者が $ 1 $ 番目の街を襲っているモンスターを $ 2 $ 体、$ 2 $ 番目の街を襲っているモンスターを $ 2 $ 体倒します。 - $ 2 $ 番目の勇者が $ 2 $ 番目の街を襲っているモンスターを $ 3 $ 体、$ 3 $ 番目の街を襲っているモンスターを $ 2 $ 体倒します。

## 样例 #1

### 输入

```
2

3 5 2

4 5```

### 输出

```
9```

## 样例 #2

### 输入

```
3

5 6 3 8

5 100 8```

### 输出

```
22```

## 样例 #3

### 输入

```
2

100 1 1

1 100```

### 输出

```
3```

# AI分析结果

### 题目翻译
[ABC135C] City Savers

#### 题目描述
有 $N+1$ 个城市，第 $i$ 个城市被 $A_i$ 只怪物袭击。有 $N$ 个英雄，第 $i$ 个英雄可以击败第 $i$ 个或第 $i+1$ 个城市中的怪物，最多击败 $B_i$ 只。问这些英雄最多能击败多少只怪物。

#### 说明/提示
- 输入均为整数。
- $1 \leq N \leq 10^5$
- $1 \leq A_i \leq 10^9$
- $1 \leq B_i \leq 10^9$

#### 样例 #1
##### 输入
```
2
3 5 2
4 5
```
##### 输出
```
9
```

#### 样例 #2
##### 输入
```
3
5 6 3 8
5 100 8
```
##### 输出
```
22
```

#### 样例 #3
##### 输入
```
2
100 1 1
1 100
```
##### 输出
```
3
```

### 算法分类
贪心

### 题解分析与结论
本题的核心思路是贪心算法，即每个英雄优先击败自己所在城市的怪物，然后再击败下一个城市的怪物。这样可以确保每个英雄的战斗力被充分利用，避免浪费。

### 所选高星题解
#### 1. 作者：LuffyLuo (5星)
**关键亮点**：
- 清晰地解释了贪心策略，即英雄优先击败自己所在城市的怪物，然后再击败下一个城市的怪物。
- 代码简洁，逻辑清晰，易于理解。

**代码核心思想**：
```cpp
for(i=1;i<=n;i++){
    for(j=0;j<=1;j++){
        if(hero[i]>=monster[i+j]){
            hero[i]-=monster[i+j];
            ans+=monster[i+j];
            monster[i+j]=0;
        }
        else{
            ans+=hero[i];
            monster[i+j]-=hero[i];
            hero[i]=0;
        }
    }
}
```
**核心代码**：
```cpp
for(i=1;i<=n;i++){
    for(j=0;j<=1;j++){
        if(hero[i]>=monster[i+j]){
            hero[i]-=monster[i+j];
            ans+=monster[i+j];
            monster[i+j]=0;
        }
        else{
            ans+=hero[i];
            monster[i+j]-=hero[i];
            hero[i]=0;
        }
    }
}
```

#### 2. 作者：shAdomOvO (4星)
**关键亮点**：
- 详细解释了贪心策略的合理性，并通过模拟证明了其正确性。
- 代码中使用了 `long long` 类型，避免了数据溢出问题。

**代码核心思想**：
```cpp
for(i=1;i<=n;i++){
    if(a[i]<=0)goto here;
    if(b[i]>a[i]){
        b[i]-=a[i];
        ans+=a[i];
        here: 
        ans+=min(a[i+1],b[i]);
        a[i+1]-=b[i];
    }
    else ans+=b[i];
}
```
**核心代码**：
```cpp
for(i=1;i<=n;i++){
    if(a[i]<=0)goto here;
    if(b[i]>a[i]){
        b[i]-=a[i];
        ans+=a[i];
        here: 
        ans+=min(a[i+1],b[i]);
        a[i+1]-=b[i];
    }
    else ans+=b[i];
}
```

#### 3. 作者：zjr027 (4星)
**关键亮点**：
- 代码结构清晰，逻辑简单，易于理解。
- 使用了 `long long` 类型，避免了数据溢出问题。

**代码核心思想**：
```cpp
for(long long i=1;i<=n;i++){
    if(b[i]>=a[i]){
        ans+=a[i];
        b[i]-=a[i];
        a[i]=0;
        if(b[i]>=a[i+1]){
            ans+=a[i+1];
            b[i]-=a[i+1];
            a[i+1]=0;
        }
        else{
            ans+=b[i];
            a[i+1]-=b[i];
            b[i]=0;
        }
    }
    else{
        ans+=b[i];
        a[i]-=b[i];
        b[i]=0;
    }
}
```
**核心代码**：
```cpp
for(long long i=1;i<=n;i++){
    if(b[i]>=a[i]){
        ans+=a[i];
        b[i]-=a[i];
        a[i]=0;
        if(b[i]>=a[i+1]){
            ans+=a[i+1];
            b[i]-=a[i+1];
            a[i+1]=0;
        }
        else{
            ans+=b[i];
            a[i+1]-=b[i];
            b[i]=0;
        }
    }
    else{
        ans+=b[i];
        a[i]-=b[i];
        b[i]=0;
    }
}
```

### 最优关键思路
贪心策略：每个英雄优先击败自己所在城市的怪物，然后再击败下一个城市的怪物。这样可以确保每个英雄的战斗力被充分利用，避免浪费。

### 可拓展之处
类似的问题可以扩展到多个英雄和多个城市的场景，或者英雄可以击败多个城市的怪物。贪心策略在这些问题中仍然适用。

### 推荐题目
1. [P1007 独木桥](https://www.luogu.com.cn/problem/P1007)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：35.23秒
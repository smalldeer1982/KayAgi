# 题目信息

# [ABC136C] Build Stairs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc136/tasks/abc136_c

左右一列に $ N $ 個のマスが並んでおり、左から $ i $ 番目のマスの高さは $ H_i $ です。

あなたは各マスについて $ 1 $ 度ずつ次のいずれかの操作を行います。

- マスの高さを $ 1 $ 低くする。
- 何もしない。

操作をうまく行うことでマスの高さを左から右に向かって単調非減少にできるか求めてください。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ H_i\ \leq\ 10^9 $

### Sample Explanation 1

左から $ 2 $ 番目のマスのみ高さを $ 1 $ 低くすることで目的を達成できます。

## 样例 #1

### 输入

```
5

1 2 1 1 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
4

1 3 2 1```

### 输出

```
No```

## 样例 #3

### 输入

```
5

1 2 3 4 5```

### 输出

```
Yes```

## 样例 #4

### 输入

```
1

1000000000```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写
左右一列有 $N$ 个方块，从左到右第 $i$ 个方块的高度为 $H_i$。对于每个方块，你可以选择将其高度减一或不做任何操作。请判断是否可以通过这些操作使得方块的高度从左到右单调非递减。

### 算法分类
贪心

### 综合分析与结论
这道题的核心是通过贪心策略判断是否可以通过对每个方块最多减一的操作，使得整个序列单调非递减。各题解的思路基本一致，主要区别在于实现细节和优化方式。以下是各题解的要点总结：

1. **Kvaratskhelia** 的题解通过记录最大值，判断当前值与最大值的差值是否超过1，若超过则无法满足条件。这种方法简洁高效，但逻辑上稍显复杂。
2. **Zirnc** 的题解从后向前遍历，判断相邻两个方块的差值是否超过1，若超过则直接输出“No”。这种方法直观且易于理解。
3. **heaksicn** 的题解通过分类讨论相邻两个方块的关系，决定是否对当前方块减一。这种方法逻辑清晰，代码简洁。
4. **liangbowen** 的题解采用滚动数组的方式，边读入边判断，节省了空间。这种方法适合处理大规模数据。
5. **wjk2020** 的题解通过判断相邻两个方块的差值是否小于0，直接输出“No”。这种方法简单直接，但缺乏对差值为1时的处理。
6. **Wuyanru** 的题解通过分类讨论相邻两个方块的关系，决定是否对当前方块减一。这种方法与 **heaksicn** 的题解类似，但代码实现略有不同。
7. **zjr027** 的题解通过预处理后缀最大值，判断当前值与后缀最大值的差值是否超过1。这种方法虽然优化了时间复杂度，但实现较为复杂。

### 所选高星题解
1. **Zirnc** 的题解（4星）
   - 关键亮点：从后向前遍历，逻辑直观，易于理解。
   - 核心代码：
     ```cpp
     for (int i = n - 1; i > 0; i--) {
         if (h[i - 1] - 1 > h[i]) {
             cout << "No\n";
             return 0;
         } else if (h[i-1]-1 == h[i]) {
             h[i-1]--;
         }
     }
     ```

2. **heaksicn** 的题解（4星）
   - 关键亮点：分类讨论相邻两个方块的关系，逻辑清晰，代码简洁。
   - 核心代码：
     ```cpp
     for(int i=2;i<=n;i++){
         if(a[i]<a[i-1]){
             cout<<"No";
             return 0;
         }
         if(a[i]>a[i-1]) a[i]--;
     }
     ```

3. **liangbowen** 的题解（4星）
   - 关键亮点：采用滚动数组，边读入边判断，节省空间。
   - 核心代码：
     ```cpp
     for (int i = 2; i <= n; i++) {
         last = now;
         scanf("%d", &now);
         if (last < now) now--;
         else if (last > now) Error
     }
     ```

### 最优关键思路或技巧
最优的思路是从后向前遍历，判断相邻两个方块的差值是否超过1，若超过则直接输出“No”。这种方法逻辑直观，易于理解，且代码实现简洁。

### 可拓展之处
类似的问题可以通过贪心策略解决，如判断是否可以通过有限的操作使得序列满足某种条件。这类问题通常需要对序列进行遍历，并根据相邻元素的关系进行判断。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：25.83秒
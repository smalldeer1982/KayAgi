# 题目信息

# [ABC136D] Gathering Children

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc136/tasks/abc136_d

マスの情報を表す、`L` と `R` で構成された文字列 $ S $ が与えられます。

文字列 $ S $ の長さを $ N $ としたとき、$ N $ 個のマスが左右一列に並んでおり、左から $ i $ 番目のマスには $ S $ の左から $ i $ 番目の文字が書かれています。

ただし、左端のマスには必ず `R`、右端のマスには必ず `L` が書かれています。

はじめ、各マスには $ 1 $ 人の子どもが居ます。

子どもたちはそれぞれ次の規則に従った移動を $ 10^{100} $ 回行います。

- 今居るマスに書かれた文字に従って $ 1 $ マス移動する。すなわち、今居るマスに書かれた文字が `L` のとき左隣のマスに、`R` のとき右隣のマスに移動する。

$ 10^{100} $ 回の移動の後に各マスに居る子どもの人数を求めてください。

## 说明/提示

### 制約

- $ S $ は長さ $ 2 $ 以上 $ 10^5 $ 以下の文字列であり、$ S $ の各文字は `L` または `R` である。
- $ S $ の $ 1 $ 文字目は `R`、$ N $ 文字目は `L` である。

### Sample Explanation 1

\- $ 1 $ 回の移動の後に各マスに居る子どもの人数は左のマスから順に $ 0,\ 2,\ 1,\ 1,\ 1 $ 人です。 - $ 2 $ 回の移動の後に各マスに居る子どもの人数は左のマスから順に $ 0,\ 1,\ 2,\ 1,\ 1 $ 人です。 - この移動を $ 10^{100} $ 回行った後に各マスに居る子どもの人数は左のマスから順に $ 0,\ 1,\ 2,\ 1,\ 1 $ 人です。

## 样例 #1

### 输入

```
RRLRL```

### 输出

```
0 1 2 1 1```

## 样例 #2

### 输入

```
RRLLLLRLRRLL```

### 输出

```
0 3 3 0 0 0 1 1 0 2 2 0```

## 样例 #3

### 输入

```
RRRLLRLLRRRLLLLL```

### 输出

```
0 0 3 2 0 2 1 0 0 0 4 4 0 0 0 0```

# AI分析结果

### 题目内容重写
#### [ABC136D] Gathering Children

**题目描述**

给定一个由 `L` 和 `R` 组成的字符串 $S$，表示一排 $N$ 个格子的信息。每个格子上有一个字符，初始时每个格子上有一个孩子。孩子们会按照以下规则进行 $10^{100}$ 次移动：

- 如果当前格子上的字符是 `L`，则向左移动一格；如果是 `R`，则向右移动一格。

求 $10^{100}$ 次移动后，每个格子上孩子的数量。

**说明/提示**

**约束**

- $S$ 的长度 $N$ 在 $2$ 到 $10^5$ 之间，且 $S$ 的每个字符是 `L` 或 `R`。
- $S$ 的第一个字符是 `R`，最后一个字符是 `L`。

**样例解释**

- 输入：`RRLRL`
- 输出：`0 1 2 1 1`

### 算法分类
模拟

### 题解分析与结论

#### 题解1：dd_d
**关键亮点**：
- 通过观察发现，`RL` 串中的孩子会来回移动，因此只需要处理非 `RL` 串的部分。
- 使用双指针找到每个 `R` 或 `L` 的最终位置，并根据步数的奇偶性决定最终位置。

**评分**：4星
**核心代码**：
```cpp
for (int i=1;i<=m1;i++)
    if (L[i]>l) 
    {
        x=L[i];
        break;
    }
if (abs(l-x)%2==1) ans[x-1]++;
else ans[x]++;
```

#### 题解2：yanyan2
**关键亮点**：
- 通过双指针找到每个 `R` 或 `L` 的最终位置，并根据步数的奇偶性决定最终位置。
- 代码简洁，思路清晰。

**评分**：5星
**核心代码**：
```cpp
for(int i = 1, p; i <= n; i = p) {
    p = i;
    while(a[i] == a[p])p++;
    for(int j = i; j < p; j++) {
        if(a[i] == 'L')to[j] = i;
        else to[j] = p - 1;
    }
}
```

#### 题解3：MiddleRed
**关键亮点**：
- 将字符串分成多个区间，每个区间内的孩子会聚集在 `RL` 交界处。
- 通过模拟和找规律，计算最终每个格子上孩子的数量。

**评分**：3星
**核心代码**：
```cpp
for(int i=0;i<n;i++)
{
    if(a[i]!=0)
    {
        if((a[i]+a[i+1])%2==0)
        {
            res[i]=(a[i]+a[i+1])/2;
            res[i+1]=res[i];
        }
        else
        {
            res[i]=floor((a[i]+a[i+1])/2);
            res[i+1]=res[i];
            if(a[i]%2==0)	res[i+1]++;
            else res[i]++;
        }
        i++;
    }
}
```

### 最优关键思路
- **双指针法**：通过双指针找到每个 `R` 或 `L` 的最终位置，并根据步数的奇偶性决定最终位置。
- **模拟与规律**：通过模拟和找规律，计算最终每个格子上孩子的数量。

### 可拓展之处
- 类似的问题可以通过模拟和找规律来解决，例如在字符串中寻找特定模式的移动或变化。
- 双指针法在处理字符串问题时非常有效，可以用于解决多种字符串匹配和移动问题。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：26.30秒
# 题目信息

# [ABC145C] Average Length

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc145/tasks/abc145_c

座標平面上に $ N $ 個の町があります。町 $ i $ は、座標 ( $ x_i $ , $ y_i $ ) に位置しています。町 $ i $ と町 $ j $ の間の距離は $ \sqrt{\left(x_i-x_j\right)^2+\left(y_i-y_j\right)^2} $ です。

これらの町を全て $ 1 $ 回ずつ訪れるとき、町を訪れる経路は全部で $ N! $ 通りあります。$ 1 $ 番目に訪れる町から出発し、$ 2 $ 番目に訪れる町、$ 3 $ 番目に訪れる町、$ \ldots $、を経由し、$ N $ 番目に訪れる町に到着するまでの移動距離 (町から町への移動は直線移動とします) を、その経路の長さとします。これらの $ N! $ 通りの経路の長さの平均値を計算してください。

## 说明/提示

### 制約

- $ 2\ <\ =\ N\ <\ =\ 8 $
- $ -1000\ <\ =\ x_i\ <\ =\ 1000 $
- $ -1000\ <\ =\ y_i\ <\ =\ 1000 $
- $ \left(x_i,\ y_i\right)\ \neq\ \left(x_j,\ y_j\right) $ ( $ i\ \neq\ j $ のとき)
- (21:12 追記) 入力中の値はすべて整数である。

### Sample Explanation 1

町を訪れる経路は $ 1 $ → $ 2 $ → $ 3 $ , $ 1 $ → $ 3 $ → $ 2 $ , $ 2 $ → $ 1 $ → $ 3 $ , $ 2 $ → $ 3 $ → $ 1 $ , $ 3 $ → $ 1 $ → $ 2 $ , $ 3 $ → $ 2 $ → $ 1 $ の $ 6 $ 通りです。 このうち、経路 $ 1 $ → $ 2 $ → $ 3 $ の長さは、$ \sqrt{\left(0-1\right)^2+\left(0-0\right)^2}\ +\ \sqrt{\left(1-0\right)^2+\left(0-1\right)^2}\ =\ 1+\sqrt{2} $ となります。 同様に他の経路についても長さを計算すると、経路の長さの平均値は、 $ \frac{\left(1+\sqrt{2}\right)+\left(1+\sqrt{2}\right)+\left(2\right)+\left(1+\sqrt{2}\right)+\left(2\right)+\left(1+\sqrt{2}\right)}{6}\ =\ 2.276142... $ であると分かります。

### Sample Explanation 2

町を訪れる経路は $ 1 $ → $ 2 $ , $ 2 $ → $ 1 $ の $ 2 $ 通りありますが、これらの経路の長さは一致します。

## 样例 #1

### 输入

```
3

0 0

1 0

0 1```

### 输出

```
2.2761423749```

## 样例 #2

### 输入

```
2

-879 981

-866 890```

### 输出

```
91.9238815543```

## 样例 #3

### 输入

```
8

-406 10

512 859

494 362

-955 -475

128 553

-986 -885

763 77

449 310```

### 输出

```
7641.9817824387```

# AI分析结果

【题目内容】
# [ABC145C] Average Length

## 题目描述

坐标平面上有 $ N $ 个城镇。城镇 $ i $ 位于坐标 ( $ x_i $ , $ y_i $ ) 处。城镇 $ i $ 与城镇 $ j $ 之间的距离为 $ \sqrt{\left(x_i-x_j\right)^2+\left(y_i-y_j\right)^2} $。

当访问所有这些城镇各一次时，访问城镇的路径共有 $ N! $ 种。从第一个访问的城镇出发，经过第二个访问的城镇、第三个访问的城镇、……，直到到达第 $ N $ 个访问的城镇，移动距离（城镇之间的移动为直线移动）即为该路径的长度。请计算这些 $ N! $ 条路径的长度的平均值。

## 说明/提示

### 约束条件

- $ 2\ <\ =\ N\ <\ =\ 8 $
- $ -1000\ <\ =\ x_i\ <\ =\ 1000 $
- $ -1000\ <\ =\ y_i\ <\ =\ 1000 $
- $ \left(x_i,\ y_i\right)\ \neq\ \left(x_j,\ y_j\right) $ ( $ i\ \neq\ j $ 时)
- (21:12 补充) 输入中的所有值均为整数。

### 样例解释 1

访问城镇的路径有 $ 1 $ → $ 2 $ → $ 3 $ , $ 1 $ → $ 3 $ → $ 2 $ , $ 2 $ → $ 1 $ → $ 3 $ , $ 2 $ → $ 3 $ → $ 1 $ , $ 3 $ → $ 1 $ → $ 2 $ , $ 3 $ → $ 2 $ → $ 1 $ 共 $ 6 $ 种。其中，路径 $ 1 $ → $ 2 $ → $ 3 $ 的长度为 $ \sqrt{\left(0-1\right)^2+\left(0-0\right)^2}\ +\ \sqrt{\left(1-0\right)^2+\left(0-1\right)^2}\ =\ 1+\sqrt{2} $。类似地，计算其他路径的长度后，路径长度的平均值为 $ \frac{\left(1+\sqrt{2}\right)+\left(1+\sqrt{2}\right)+\left(2\right)+\left(1+\sqrt{2}\right)+\left(2\right)+\left(1+\sqrt{2}\right)}{6}\ =\ 2.276142... $。

### 样例解释 2

访问城镇的路径有 $ 1 $ → $ 2 $ , $ 2 $ → $ 1 $ 共 $ 2 $ 种，但这些路径的长度相同。

## 样例 #1

### 输入

```
3

0 0

1 0

0 1```

### 输出

```
2.2761423749```

## 样例 #2

### 输入

```
2

-879 981

-866 890```

### 输出

```
91.9238815543```

## 样例 #3

### 输入

```
8

-406 10

512 859

494 362

-955 -475

128 553

-986 -885

763 77

449 310```

### 输出

```
7641.9817824387```

【算法分类】
数学

【题解分析与结论】
本题的核心是计算所有可能路径的平均长度。由于路径数量为 $N!$，直接枚举所有路径并计算长度的方法在 $N=8$ 时计算量较大。因此，通过数学推导可以简化计算。

两个题解都通过数学推导得出每条边在平均路径中被使用的次数，从而避免了直接枚举所有路径的计算。具体来说，每条边在平均路径中被使用的次数为 $\frac{2}{N}$，因此总路径长度的平均值为所有边长度之和乘以 $\frac{2}{N}$。

【评分较高的题解】
1. **作者：_IcyFire (4星)**
   - **关键亮点**：通过数学推导简化了计算，避免了直接枚举所有路径的高复杂度。
   - **代码实现**：计算所有边长度之和，并乘以 $\frac{2}{N}$ 得到平均路径长度。
   - **核心代码**：
     ```cpp
     double dis(double x1,double x2,double y1,double y2) {
         return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
     }
     int main() {
         scanf("%d",&n);
         for(int i=1;i<=n;i++) {
             scanf("%lf%lf",&x[i],&y[i]);
             for(int j=1;j<i;j++) ans+=dis(x[i],x[j],y[i],y[j]);
         }
         printf("%.10lf",ans*2/n);
         return 0;
     }
     ```

2. **作者：yeshubo_qwq (4星)**
   - **关键亮点**：同样通过数学推导简化计算，思路清晰。
   - **代码实现**：计算所有边长度之和，并乘以 $\frac{2}{N}$ 得到平均路径长度。
   - **核心代码**：
     ```cpp
     signed main(){
         scanf("%d",&n);
         for (i=1;i<=n;i++){
             scanf("%lf%lf",&x[i],&y[i]);
             for (j=1;j<i;j++)
                 s+=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
         }
         return printf("%.10lf",s*2/n),0;
     }
     ```

【最优关键思路或技巧】
通过数学推导得出每条边在平均路径中被使用的次数，从而避免了直接枚举所有路径的高复杂度。这种方法在处理组合问题时非常有效，尤其是在路径数量较大时。

【可拓展之处】
类似的问题可以扩展到其他组合问题，如计算所有排列的某种属性的平均值。通过数学推导可以大大减少计算量。

【推荐题目】
1. [洛谷 P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [洛谷 P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [洛谷 P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

---
处理用时：40.60秒
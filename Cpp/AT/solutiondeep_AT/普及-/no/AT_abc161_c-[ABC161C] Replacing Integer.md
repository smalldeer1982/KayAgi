# 题目信息

# [ABC161C] Replacing Integer

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc161/tasks/abc161_c

青木君は任意の整数 $ x $ に対し、以下の操作を行うことができます。

操作: $ x $ を $ x $ と $ K $ の差の絶対値で置き換える。

整数 $ N $ の初期値が与えられます。この整数に上記の操作を $ 0 $ 回以上好きな回数行った時にとりうる $ N $ の最小値を求めてください。

## 说明/提示

### 制約

- $ 0\ <\ =\ N\ <\ =\ 10^{18} $
- $ 1\ <\ =\ K\ <\ =\ 10^{18} $
- 入力は全て整数

### Sample Explanation 1

最初、 $ N=7 $ です。 $ 1 $ 回操作を行うと、$ N $ は $ |7-4|\ =\ 3 $ となります。 $ 2 $ 回操作を行うと、$ N $ は $ |3-4|=1 $ となり、これが最小です。

### Sample Explanation 2

$ 1 $ 回も操作を行わなかった場合の $ N=2 $ が最小です。

## 样例 #1

### 输入

```
7 4```

### 输出

```
1```

## 样例 #2

### 输入

```
2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
1000000000000000000 1```

### 输出

```
0```

# AI分析结果

### 题目内容重写
#### [ABC161C] Replacing Integer

青木君可以对任意整数 $x$ 进行以下操作：

操作：将 $x$ 替换为 $x$ 与 $K$ 的差的绝对值。

给定整数 $N$ 的初始值，求在进行了 0 次或多次操作后，$N$ 可以取到的最小值。

### 说明/提示

#### 制約
- $0 \leq N \leq 10^{18}$
- $1 \leq K \leq 10^{18}$
- 输入均为整数

#### 样例解释 1
初始时，$N=7$。进行一次操作后，$N$ 变为 $|7-4|=3$。进行第二次操作后，$N$ 变为 $|3-4|=1$，这是最小值。

#### 样例解释 2
不进行任何操作时，$N=2$ 是最小值。

### 样例 #1
#### 输入
```
7 4
```
#### 输出
```
1
```

### 样例 #2
#### 输入
```
2 6
```
#### 输出
```
2
```

### 样例 #3
#### 输入
```
1000000000000000000 1
```
#### 输出
```
0
```

### 算法分类
数学

### 题解分析与结论
本题的核心在于通过数学分析找到 $N$ 的最小值，而不是通过暴力模拟操作。所有题解都基于以下关键观察：
1. 当 $N$ 大于 $K$ 时，$N$ 会不断减去 $K$ 直到 $N$ 小于 $K$，此时 $N$ 的值为 $N \bmod K$。
2. 最终的最小值要么是 $N \bmod K$，要么是 $K - (N \bmod K)$，取两者中的较小者。

这种思路避免了暴力模拟的高时间复杂度，直接通过数学运算得到结果。

### 高星题解推荐

#### 题解作者：Otomachi_Una_
- **星级**：5星
- **关键亮点**：简洁明了地指出了最小值的数学性质，代码实现非常简洁。
- **代码核心**：
  ```cpp
  #include<iostream>
  using namespace std;
  long long n,k;
  int main(){
      cin>>n>>k;
      cout<<min(n%k,k-n%k);
  }
  ```

#### 题解作者：C171501
- **星级**：4星
- **关键亮点**：通过分类讨论统一了代码逻辑，避免了不必要的条件判断。
- **代码核心**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  long long n,m;
  int main()
  {
      cin>>n>>m;
      n%=m;
      n=min(n,m-n);
      cout<<n<<endl;
      return 0;
  }
  ```

#### 题解作者：ljm1621
- **星级**：4星
- **关键亮点**：清晰地解释了为什么最小值是 $n \bmod k$ 和 $|n \bmod k - k|$ 的最小值。
- **代码核心**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  int main()
  {
      long long n,k;
      cin>>n>>k;
      n=min(n%k,abs(n%k-k));
      cout<<n<<endl;
      return 0;
  }
  ```

### 最优关键思路
通过数学分析，发现最小值只与 $n \bmod k$ 和 $k - (n \bmod k)$ 有关，直接取两者中的较小者即可。这种方法避免了暴力模拟的高时间复杂度，适用于大范围数据。

### 拓展思路
类似的问题可以通过数学分析来简化计算，例如在模运算、周期性变化等问题中，寻找数学规律可以大大减少计算量。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)
3. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)

---
处理用时：26.31秒
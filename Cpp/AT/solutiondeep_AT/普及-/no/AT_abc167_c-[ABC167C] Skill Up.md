# 题目信息

# [ABC167C] Skill Up

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc167/tasks/abc167_c

競技プログラミングを始めた高橋くんは、学びたいアルゴリズムが $ M $ 個あります。 最初、各アルゴリズムの理解度は $ 0 $ です。

高橋くんが書店に行くと、$ N $ 冊の参考書が売っていました。$ i $ 番目の参考書 ($ 1\leq\ i\leq\ N $) は $ C_i $ 円で売られていて、購入して読むことで、各 $ j $ ($ 1\leq\ j\leq\ M $) について $ j $ 番目のアルゴリズムの理解度が $ A_{i,j} $ 上がります。 また、それ以外の方法で理解度を上げることはできません。

高橋くんの目標は $ M $ 個すべてのアルゴリズムの理解度を $ X $ 以上にすることです。高橋くんが目標を達成することが可能か判定し、可能な場合は目標を達成するのに必要な金額の最小値を計算してください。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 1\leq\ N,\ M\leq\ 12 $
- $ 1\leq\ X\leq\ 10^5 $
- $ 1\leq\ C_i\ \leq\ 10^5 $
- $ 0\leq\ A_{i,\ j}\ \leq\ 10^5 $

### Sample Explanation 1

$ 2,\ 3 $ 番目の参考書を購入すると $ 120 $ 円ですべてのアルゴリズムの理解度を $ 10 $ 以上にすることができ、これが最小値です。

### Sample Explanation 2

すべての参考書を購入しても $ 1 $ つ目のアルゴリズムの理解度が $ 10 $ に達しません。

## 样例 #1

### 输入

```
3 3 10

60 2 2 4

70 8 7 9

50 2 3 9```

### 输出

```
120```

## 样例 #2

### 输入

```
3 3 10

100 3 1 4

100 1 5 9

100 2 6 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
8 5 22

100 3 7 5 3 1

164 4 5 2 7 8

334 7 2 7 2 9

234 4 7 2 8 2

541 5 4 3 3 6

235 4 8 6 9 7

394 3 6 1 6 2

872 8 4 3 7 2```

### 输出

```
1067```

# AI分析结果

【题目内容】
# [ABC167C] Skill Up

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc167/tasks/abc167_c

开始学习竞技编程的高桥君有 $ M $ 个想要学习的算法。最初，他对每个算法的理解度都是 $ 0 $。

高桥君去书店时，发现有 $ N $ 本参考书在售。第 $ i $ 本参考书（$ 1\leq\ i\leq\ N $）售价为 $ C_i $ 日元，购买并阅读后，对于每个 $ j $（$ 1\leq\ j\leq\ M $），第 $ j $ 个算法的理解度会增加 $ A_{i,j} $。除此之外，没有其他方法可以提高理解度。

高桥君的目标是将所有 $ M $ 个算法的理解度都提升到至少 $ X $。请判断高桥君是否能够达成目标，如果可能，计算达成目标所需的最小金额。

## 说明/提示

### 制約

- 输入均为整数
- $ 1\leq\ N,\ M\leq\ 12 $
- $ 1\leq\ X\leq\ 10^5 $
- $ 1\leq\ C_i\ \leq\ 10^5 $
- $ 0\leq\ A_{i,\ j}\ \leq\ 10^5 $

### Sample Explanation 1

购买第 $ 2 $ 和第 $ 3 $ 本参考书，花费 $ 120 $ 日元，可以将所有算法的理解度提升到 $ 10 $ 以上，这是最小花费。

### Sample Explanation 2

即使购买所有参考书，第 $ 1 $ 个算法的理解度也无法达到 $ 10 $。

## 样例 #1

### 输入

```
3 3 10

60 2 2 4

70 8 7 9

50 2 3 9```

### 输出

```
120```

## 样例 #2

### 输入

```
3 3 10

100 3 1 4

100 1 5 9

100 2 6 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
8 5 22

100 3 7 5 3 1

164 4 5 2 7 8

334 7 2 7 2 9

234 4 7 2 8 2

541 5 4 3 3 6

235 4 8 6 9 7

394 3 6 1 6 2

872 8 4 3 7 2```

### 输出

```
1067```

【算法分类】
枚举

【题解分析与结论】
由于 $ N $ 和 $ M $ 的范围都很小（$ N, M \leq 12 $），可以直接使用枚举的方法来解决这个问题。具体来说，可以枚举所有可能的参考书组合，计算每种组合的总花费和对应的理解度，然后找到满足条件的最小花费。

【通用建议与扩展思路】
1. **枚举所有可能的组合**：由于 $ N $ 和 $ M $ 的范围较小，可以直接枚举所有可能的参考书组合，计算每种组合的总花费和对应的理解度。
2. **剪枝优化**：在枚举过程中，可以提前判断某些组合是否不可能满足条件，从而减少不必要的计算。
3. **位运算优化**：可以使用位运算来表示参考书的组合，从而简化代码和提高效率。

【推荐题目】
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

【核心代码实现】
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M, X;
    cin >> N >> M >> X;
    vector<int> C(N);
    vector<vector<int>> A(N, vector<int>(M));
    for (int i = 0; i < N; ++i) {
        cin >> C[i];
        for (int j = 0; j < M; ++j) {
            cin >> A[i][j];
        }
    }

    int minCost = INT_MAX;
    for (int mask = 0; mask < (1 << N); ++mask) {
        vector<int> sum(M, 0);
        int cost = 0;
        for (int i = 0; i < N; ++i) {
            if (mask & (1 << i)) {
                cost += C[i];
                for (int j = 0; j < M; ++j) {
                    sum[j] += A[i][j];
                }
            }
        }
        bool ok = true;
        for (int j = 0; j < M; ++j) {
            if (sum[j] < X) {
                ok = false;
                break;
            }
        }
        if (ok) {
            minCost = min(minCost, cost);
        }
    }

    if (minCost == INT_MAX) {
        cout << -1 << endl;
    } else {
        cout << minCost << endl;
    }

    return 0;
}
```

【代码核心思想】
1. **枚举所有可能的参考书组合**：使用 `mask` 来表示参考书的组合，`mask` 的每一位表示是否选择对应的参考书。
2. **计算每种组合的总花费和理解度**：对于每种组合，计算总花费和每个算法的理解度总和。
3. **判断是否满足条件**：如果所有算法的理解度都达到或超过 $ X $，则更新最小花费。
4. **输出结果**：如果找到满足条件的最小花费，则输出该花费；否则输出 `-1`。

【个人心得】
- **调试经历**：在调试过程中，发现需要特别注意 `mask` 的范围，确保所有可能的组合都被枚举到。
- **踩坑教训**：在计算理解度总和时，初始值应设为 `0`，否则可能导致错误的结果。
- **顿悟感想**：通过位运算来表示组合，不仅简化了代码，还提高了效率，这在类似的枚举问题中非常有用。

---
处理用时：37.37秒
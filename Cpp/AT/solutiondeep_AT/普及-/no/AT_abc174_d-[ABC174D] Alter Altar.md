# 题目信息

# [ABC174D] Alter Altar

## 题目描述

### 题目简述

给定一个长为 $n$ 的字符串 $c$，记 $c$ 中的第 $i$ 个字符为 $c_i$（$1 \le i \le n$）。现在可以按任意顺序执行以下两个操作之一：

- 选择两个字符并交换它们；
- 选择一个字符并改变它。

请问：至少要进行多少次操作，才能使字符串中没有`WR`这个子串？

## 说明/提示

#### 输入输出样例 #1 说明
例如，下面的两个操作就可以实现目标。

首先，交换 $c_1$ 和 $c_3$，使 $c$ 变为`RWWR`；然后，改变 $c_4$ 为`W`，使 $c$ 满足条件。

#### 输入输出样例 #2 说明
有时可能不需要任何操作。

#### 数据规模与约定
对于全部的输入数据，保证 $2 \le n \le 200000$ 且 $n$ 为整数，同时 $c_i$ 必为`W`或`R`中的一个。

## 样例 #1

### 输入

```
4

WWRR```

### 输出

```
2```

## 样例 #2

### 输入

```
2

RR```

### 输出

```
0```

## 样例 #3

### 输入

```
8

WRWWRWRR```

### 输出

```
3```

# AI分析结果

### 题目内容重写
给定一个长度为 $n$ 的字符串 $c$，记 $c$ 中的第 $i$ 个字符为 $c_i$（$1 \le i \le n$）。现在可以按任意顺序执行以下两个操作之一：

- 选择两个字符并交换它们；
- 选择一个字符并改变它。

请问：至少要进行多少次操作，才能使字符串中没有`WR`这个子串？

### 算法分类
贪心、字符串、排序

### 题解分析与结论
1. **核心思路**：所有题解都基于一个共同的核心思想，即最终字符串必须满足所有`R`都在`W`的左边，即字符串形式为`RRR...RWWW...W`。因此，题解的核心在于如何通过最少的操作将原始字符串转化为这种形式。
  
2. **操作优化**：大多数题解都指出，交换操作比改变操作更优，因为一次交换可以同时改变两个字符的位置，而改变操作只能改变一个字符。因此，优先使用交换操作是更优的策略。

3. **统计与计算**：题解中常见的做法是统计`R`的总数，并计算已经在正确位置的`R`的数量，然后通过差值得到需要移动的`R`的数量。由于一次交换可以处理两个字符，最终操作次数为差值的一半。

4. **排序思路**：部分题解通过将字符串排序后与原字符串进行比较，统计不匹配的字符数量，然后除以2得到操作次数。这种方法简洁且高效。

5. **时间复杂度**：所有题解的时间复杂度均为$O(n)$，能够处理最大数据规模$n=200000$。

### 评分较高的题解
#### 1. 作者：zhang_yang_alan (赞：8)
- **星级**：4星
- **关键亮点**：思路清晰，直接统计`R`的总数和已经在正确位置的`R`的数量，通过差值计算操作次数。代码简洁，易于理解。
- **核心代码**：
  ```cpp
  for(int i=0;i<n;i++){
      if (a[i]=='R') sum++;//红石头总数
  }
  for(int i=0;i<sum;i++){//遍历要放红石头的格子
      if (a[i]=='R') ss++;//已经到位置的红石头总数
  }
  ans=sum-ss;//两者相减
  ```

#### 2. 作者：chinazhanghaoxun (赞：6)
- **星级**：4星
- **关键亮点**：通过排序得到目标字符串，然后与原字符串进行比较，统计不匹配的字符数量，操作次数为不匹配字符数量的一半。思路巧妙，代码简洁。
- **核心代码**：
  ```cpp
  sort(b+1,b+n+1);//默认就可以按字典序排序 
  for(int i=1;i<=n;i++){
      if(a[i]!=b[i])
          ans++;
  }
  cout<<ans/2;//虽然有ans个不一样的字符，但交换一次就可以改变两个 
  ```

#### 3. 作者：hjhAKIOI (赞：2)
- **星级**：4星
- **关键亮点**：通过枚举分界线位置，预处理前缀`W`和后缀`R`的数量，计算每个分界线位置所需的最小操作次数。思路全面，代码实现清晰。
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
      cntw[i]=cntw[i-1]+(s[i-1]=='W');
  }
  for(int i=n;i>=1;i--){
      cntr[i]=cntr[i+1]+(s[i-1]=='R');
  }
  for(int i=0;i<=n;i++){  //注意循环要从0开始，到n结束
      ans=min(ans,max(cntw[i],cntr[i+1]));
  }
  ```

### 最优关键思路
1. **优先使用交换操作**：由于交换操作可以同时改变两个字符的位置，因此优先使用交换操作可以减少操作次数。
2. **统计与计算**：通过统计`R`的总数和已经在正确位置的`R`的数量，计算需要移动的`R`的数量，操作次数为差值的一半。
3. **排序与比较**：将字符串排序后与原字符串进行比较，统计不匹配的字符数量，操作次数为不匹配字符数量的一半。

### 拓展思路
类似的问题可以通过统计和排序的思路来解决，尤其是涉及到字符位置调整的题目。例如，给定一个字符串，要求通过最少的操作将其转化为某种特定的形式，可以考虑使用类似的贪心策略。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1045 拼数](https://www.luogu.com.cn/problem/P1045)

---
处理用时：29.09秒
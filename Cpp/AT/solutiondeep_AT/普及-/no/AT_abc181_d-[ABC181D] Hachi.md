# 题目信息

# [ABC181D] Hachi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc181/tasks/abc181_d

`1` 〜 `9` の数字のみからなる数字列 $ S $ が与えられます。

蜂の高橋くんは、 $ 8 $ の倍数が好きです。

高橋くんは、数字列 $ S $ を並び替えて $ 8 $ の倍数を作ろうとしています。

$ 8 $ の倍数を作れるかどうか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 2\ \times\ 10^5 $
- $ S $ の各文字は `1` 〜 `9` のいずれか

### Sample Explanation 1

例えば、 $ 1234 $ を並べ替えて $ 1432 $ にすると $ 8 $ の倍数になります。

### Sample Explanation 2

$ 1333 $ をどう並べ替えても $ 8 $ の倍数を作ることはできません。

## 样例 #1

### 输入

```
1234```

### 输出

```
Yes```

## 样例 #2

### 输入

```
1333```

### 输出

```
No```

## 样例 #3

### 输入

```
8```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写

#### [ABC181D] Hachi

**题目描述**

给定一个仅由数字 `1` 到 `9` 组成的数字序列 $ S $。

蜂的高桥君喜欢 $ 8 $ 的倍数。

高桥君希望通过重新排列数字序列 $ S $ 来生成一个 $ 8 $ 的倍数。

请判断是否可以通过重新排列 $ S $ 来生成一个 $ 8 $ 的倍数。

**说明/提示**

**约束条件**

- $ 1\ \leq\ |S|\ \leq\ 2\ \times\ 10^5 $
- $ S $ 的每个字符都是 `1` 到 `9` 之间的数字。

**样例解释 1**

例如，将 $ 1234 $ 重新排列为 $ 1432 $，可以得到一个 $ 8 $ 的倍数。

**样例解释 2**

无论如何重新排列 $ 1333 $，都无法生成一个 $ 8 $ 的倍数。

**样例 #1**

**输入**

```
1234
```

**输出**

```
Yes
```

**样例 #2**

**输入**

```
1333
```

**输出**

```
No
```

**样例 #3**

**输入**

```
8
```

**输出**

```
Yes
```

### 算法分类

**数学**

### 题解分析与结论

由于题目要求通过重新排列数字序列 $ S $ 来生成一个 $ 8 $ 的倍数，我们可以利用 $ 8 $ 的倍数的性质来简化问题。具体来说，一个数是否是 $ 8 $ 的倍数，取决于它的最后三位数是否是 $ 8 $ 的倍数。因此，我们只需要考虑 $ S $ 中数字的排列组合，特别是最后三位数的组合。

### 关键思路与技巧

1. **利用 $ 8 $ 的倍数性质**：只需检查所有可能的三位数组合，判断是否存在一个组合是 $ 8 $ 的倍数。
2. **统计数字频率**：通过统计 $ S $ 中每个数字的出现频率，可以高效地生成所有可能的三位数组合。
3. **优化组合生成**：通过遍历所有可能的三位数组合，并结合数字频率，判断是否存在符合条件的组合。

### 推荐题目

1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
3. [P1013 进制数](https://www.luogu.com.cn/problem/P1013)

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

bool canFormEightMultiple(string s) {
    if (s.length() < 3) {
        int num = stoi(s);
        return num % 8 == 0;
    }
    vector<int> cnt(10, 0);
    for (char c : s) {
        cnt[c - '0']++;
    }
    for (int i = 104; i < 1000; i += 8) {
        vector<int> tempCnt = cnt;
        string num = to_string(i);
        if (num.length() < 3) continue;
        bool valid = true;
        for (char c : num) {
            tempCnt[c - '0']--;
            if (tempCnt[c - '0'] < 0) {
                valid = false;
                break;
            }
        }
        if (valid) return true;
    }
    return false;
}

int main() {
    string s;
    cin >> s;
    if (canFormEightMultiple(s)) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }
    return 0;
}
```

### 代码解释

1. **函数 `canFormEightMultiple`**：判断是否可以通过重新排列 $ S $ 生成一个 $ 8 $ 的倍数。
   - 如果 $ S $ 的长度小于 3，直接判断是否为 $ 8 $ 的倍数。
   - 否则，统计 $ S $ 中每个数字的频率，然后遍历所有可能的三位数组合，检查是否存在一个组合是 $ 8 $ 的倍数且可以由 $ S $ 中的数字组成。
2. **主函数**：读取输入并调用 `canFormEightMultiple` 函数，输出结果。

### 结论

通过利用 $ 8 $ 的倍数性质和统计数字频率，可以高效地判断是否可以通过重新排列数字序列 $ S $ 生成一个 $ 8 $ 的倍数。这种方法在时间和空间复杂度上都非常高效，适用于大规模数据。

---
处理用时：24.88秒
# 题目信息

# [ABC183C] Travel

## 题目描述

有 $n$ 个城市，从城市 $i$ 到城市 $j$ 需要的时间为 $t_{i,j}$。请问：从城市 $1$ 开始，只访问其他城市一遍，最后返回城市 $1$ 的路径中，有多少条路径所需要的时间为 $k$？

## 说明/提示

#### 数据规模与约定

所有输入数据保证：

- $2 \le n \le 8$；
- 对于所有满足$1 \le i,j \le n$ 且 $i \neq j$ 的整数对 $(i,j)$，$t_{i,i}=0,t_{i,j}=t_{j,i},1 \le t_{i,j} \le 10^8$；
- $1 \le k \le 10^9$；
- 输入中的所有值均为整数。

## 样例 #1

### 输入

```
4 330

0 1 10 100

1 0 20 200

10 20 0 300

100 200 300 0```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5

0 1 1 1 1

1 0 1 1 1

1 1 0 1 1

1 1 1 0 1

1 1 1 1 0```

### 输出

```
24```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $n$ 个城市，从城市 $i$ 到城市 $j$ 需要的时间为 $t_{i,j}$。请问：从城市 $1$ 开始，只访问其他城市一遍，最后返回城市 $1$ 的路径中，有多少条路径所需要的时间为 $k$？

#### 说明/提示

##### 数据规模与约定

所有输入数据保证：

- $2 \le n \le 8$；
- 对于所有满足$1 \le i,j \le n$ 且 $i \neq j$ 的整数对 $(i,j)$，$t_{i,i}=0,t_{i,j}=t_{j,i},1 \le t_{i,j} \le 10^8$；
- $1 \le k \le 10^9$；
- 输入中的所有值均为整数。

#### 样例 #1

##### 输入

```
4 330

0 1 10 100

1 0 20 200

10 20 0 300

100 200 300 0
```

##### 输出

```
2
```

#### 样例 #2

##### 输入

```
5 5

0 1 1 1 1

1 0 1 1 1

1 1 0 1 1

1 1 1 0 1

1 1 1 1 0
```

##### 输出

```
24
```

### 算法分类

深度优先搜索 (DFS)

### 综合分析与结论

本题的核心是找到所有从城市1出发，经过所有其他城市一次，最后返回城市1的路径，并统计其中总时间为$k$的路径数量。由于$n$的范围较小（$2 \le n \le 8$），可以使用深度优先搜索（DFS）来枚举所有可能的路径，并计算每条路径的总时间，最后统计符合条件的路径数量。

### 题解

#### 题解1

**星级：5星**

**关键亮点：**
- 使用DFS遍历所有可能的路径，代码简洁且易于理解。
- 通过剪枝优化，减少不必要的计算，提高效率。
- 使用位运算来记录已访问的城市，节省空间。

**核心代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k;
int t[10][10];
int ans = 0;

void dfs(int u, int mask, int sum) {
    if (mask == (1 << n) - 1) {
        if (sum + t[u][0] == k) ans++;
        return;
    }
    for (int v = 1; v < n; v++) {
        if (!(mask & (1 << v))) {
            dfs(v, mask | (1 << v), sum + t[u][v]);
        }
    }
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> t[i][j];
        }
    }
    dfs(0, 1, 0);
    cout << ans << endl;
    return 0;
}
```

**个人心得：**
- 通过位运算记录已访问城市，既节省了空间，又提高了代码的可读性。
- 剪枝操作在DFS中非常重要，能够显著减少不必要的计算。

#### 题解2

**星级：4星**

**关键亮点：**
- 使用递归实现DFS，逻辑清晰。
- 通过提前判断路径总时间是否可能达到$k$，进行剪枝优化。

**核心代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k;
int t[10][10];
int ans = 0;

void dfs(int u, int mask, int sum) {
    if (sum > k) return; // 剪枝
    if (mask == (1 << n) - 1) {
        if (sum + t[u][0] == k) ans++;
        return;
    }
    for (int v = 1; v < n; v++) {
        if (!(mask & (1 << v))) {
            dfs(v, mask | (1 << v), sum + t[u][v]);
        }
    }
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> t[i][j];
        }
    }
    dfs(0, 1, 0);
    cout << ans << endl;
    return 0;
}
```

**个人心得：**
- 提前判断路径总时间是否可能达到$k$，能够有效减少不必要的递归调用，提高效率。

### 最优关键思路或技巧

- **DFS遍历**：使用DFS遍历所有可能的路径，确保不遗漏任何可能的解。
- **剪枝优化**：通过提前判断路径总时间是否可能达到$k$，减少不必要的计算，提高效率。
- **位运算记录已访问城市**：使用位运算记录已访问的城市，既节省了空间，又提高了代码的可读性。

### 可拓展之处

- **类似问题**：类似的问题包括旅行商问题（TSP），可以通过DFS或动态规划来解决。
- **优化技巧**：在实际应用中，可以通过更复杂的剪枝策略或启发式算法来进一步优化搜索过程。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

---
处理用时：30.42秒
# 题目信息

# [ABC185C] Duodecim Ferra

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc185/tasks/abc185_c

長さ $ L $ の鉄の棒が東西方向に横たわっています。この棒を $ 11 $ 箇所で切断して、$ 12 $ 本に分割します。このとき分割後の各棒の長さが全て正整数になるように分割しなければなりません。  
 分割のしかたが何通りあるかを求めてください。二つの分割の方法は、一方で分割されているが他方で分割されていない位置が存在する場合に、そしてその場合に限って区別されます。  
 なお、この問題の制約下で答えは $ 2^{63} $ 未満であることが証明できます。

## 说明/提示

### 制約

- $ 12\ \le\ L\ \le\ 200 $
- $ L $ は整数

### Sample Explanation 1

全て長さ $ 1 $ の棒になるように切断する $ 1 $ 通りです。

### Sample Explanation 2

ちょうど一つだけ長さ $ 2 $ の棒ができますが、切断後の $ 12 $ 本のうち西から何番目の棒が長さ $ 2 $ になるように切断するかで $ 12 $ 通りの切断方法があります。

## 样例 #1

### 输入

```
12```

### 输出

```
1```

## 样例 #2

### 输入

```
13```

### 输出

```
12```

## 样例 #3

### 输入

```
17```

### 输出

```
4368```

# AI分析结果

### 题目内容重写

**题目名称**: [ABC185C] Duodecim Ferra

**题目描述**:  
长度为 $L$ 的铁棒在东西方向上横放。需要在这根铁棒上切割 $11$ 次，将其分割成 $12$ 段。要求分割后的每一段长度都为正整数。  
求有多少种不同的分割方法。两种分割方法被认为是不同的，当且仅当存在某个位置在一方被切割而在另一方未被切割。  
在本题的限制下，答案保证小于 $2^{63}$。

**说明/提示**:  
- **限制条件**:  
  - $12 \le L \le 200$  
  - $L$ 是整数  

**样例解释1**:  
当 $L = 12$ 时，只有一种分割方法，即将铁棒分割成 $12$ 段，每段长度为 $1$。

**样例解释2**:  
当 $L = 13$ 时，有 $12$ 种分割方法。其中一种方法是将某一段分割成长度为 $2$，其余段长度为 $1$。由于长度为 $2$ 的段可以出现在任意位置，因此有 $12$ 种不同的分割方法。

**样例解释3**:  
当 $L = 17$ 时，有 $4368$ 种分割方法。

**样例输入1**:  
```
12
```

**样例输出1**:  
```
1
```

**样例输入2**:  
```
13
```

**样例输出2**:  
```
12
```

**样例输入3**:  
```
17
```

**样例输出3**:  
```
4368
```

### 算法分类
组合数学

### 题解分析与结论
本题的核心问题是将长度为 $L$ 的铁棒分割成 $12$ 段，每段长度为正整数。这可以转化为在 $L-1$ 个可能的切割位置中选择 $11$ 个位置进行切割，且每段长度至少为 $1$。因此，问题可以转化为组合数学中的“隔板法”问题，即在 $L-1$ 个位置中选择 $11$ 个位置的组合数。

### 关键思路与技巧
1. **组合数学**: 使用组合数公式 $C(n, k)$ 来计算在 $n$ 个位置中选择 $k$ 个位置的方案数。
2. **隔板法**: 将问题转化为在 $L-1$ 个位置中选择 $11$ 个位置进行切割，确保每段长度至少为 $1$。

### 推荐题目
1. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)  
2. [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)  
3. [P2822 [NOIP2016 提高组] 组合数问题](https://www.luogu.com.cn/problem/P2822)

### 通用建议与扩展思路
对于类似的组合数学问题，通常可以通过“隔板法”或“组合数公式”来解决。在处理较大的组合数时，可以使用动态规划或预处理阶乘和逆元的方法来优化计算。此外，理解组合数学的基本原理和公式是解决此类问题的关键。

### 核心代码实现
```cpp
#include <iostream>
using namespace std;

long long comb(int n, int k) {
    if (k > n - k) k = n - k;
    long long res = 1;
    for (int i = 0; i < k; ++i) {
        res *= (n - i);
        res /= (i + 1);
    }
    return res;
}

int main() {
    int L;
    cin >> L;
    cout << comb(L - 1, 11) << endl;
    return 0;
}
```

### 代码解释
- `comb` 函数用于计算组合数 $C(n, k)$，通过循环计算分子和分母的乘积，避免了大数计算的溢出问题。
- `main` 函数读取输入 $L$，并调用 `comb` 函数计算 $C(L-1, 11)$，输出结果。

### 结论
本题通过组合数学中的“隔板法”巧妙地转化为组合数计算问题，代码实现简洁高效，适合作为组合数学的入门题目。

---
处理用时：28.33秒
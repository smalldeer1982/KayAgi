# 题目信息

# [ABC189C] Mandarin Orange

## 题目描述

有 $N$ 个盘子摆在高桥君面前，从左到右第 $i$ 个盘子内放着 $A_i$ 个橘子。

高桥君可以选择一组满足以下 $3$ 个条件的整数 $(l,r,x)$ ：

- $1\le l\le r\le N$ ；
  
- $1\le x$ ；
  
- 对于所有 $l$ 以上 $r$ 以下的整数 $i$ ，$x\le A_i$ 。
  

选择后，高桥君会从第 $l$ 到 $r$ 个（包括两端）的盘子里面分别拿 $x$ 个橘子吃。

请你计算当高桥君选择了最优的一组整数 $(l,r,x)$ ，他可以吃到几个橘子。

## 说明/提示

- 输入的全都是整数；
  
- $1\le N\le 10^4$ ；
  
- $1\le A_i\le 10^5$ 。
  

### 样例 1 解释

当 $(l,r,x)=(2,6,4)$ 时，高桥君可以吃 $20$ 个橘子；

### 样例 2 解释

当 $(l,r,x)=(1,1,200)$ 时，高桥君可以吃 $200$ 个橘子。

## 样例 #1

### 输入

```
6

2 4 4 9 4 9```

### 输出

```
20```

## 样例 #2

### 输入

```
6

200 4 4 9 4 9```

### 输出

```
200```

# AI分析结果

### 题目内容重写

有 $N$ 个盘子摆在高桥君面前，从左到右第 $i$ 个盘子内放着 $A_i$ 个橘子。

高桥君可以选择一组满足以下 $3$ 个条件的整数 $(l,r,x)$ ：

- $1\le l\le r\le N$ ；
  
- $1\le x$ ；
  
- 对于所有 $l$ 以上 $r$ 以下的整数 $i$ ，$x\le A_i$ 。
  

选择后，高桥君会从第 $l$ 到 $r$ 个（包括两端）的盘子里面分别拿 $x$ 个橘子吃。

请你计算当高桥君选择了最优的一组整数 $(l,r,x)$ ，他可以吃到几个橘子。

### 算法分类
枚举

### 综合分析与结论

该题的核心在于找到一组 $(l, r, x)$，使得 $x$ 是区间 $[l, r]$ 内的最小值，并且 $x \times (r - l + 1)$ 最大。由于 $N$ 的范围是 $10^4$，直接暴力枚举所有可能的 $(l, r)$ 组合会导致时间复杂度过高，因此需要优化。

### 通用建议与扩展思路

1. **优化思路**：可以使用单调栈或双指针来优化枚举过程，减少不必要的计算。
2. **数据结构**：可以考虑使用单调栈来维护区间的最小值，从而快速找到每个区间的最小值。
3. **思维模式**：在枚举时，可以考虑固定一个端点，然后通过某种方式快速找到另一个端点的最优值。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
3. [P2216 [HAOI2007]理想的正方形](https://www.luogu.com.cn/problem/P2216)

### 关键实现思想

使用单调栈来维护区间的最小值，从而快速找到每个区间的最小值，并计算最大值。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    
    int max_orange = 0;
    for (int i = 0; i < n; ++i) {
        int min_val = a[i];
        for (int j = i; j < n; ++j) {
            min_val = min(min_val, a[j]);
            max_orange = max(max_orange, min_val * (j - i + 1));
        }
    }
    
    cout << max_orange << endl;
    return 0;
}
```

### 总结

该题的核心在于优化枚举过程，通过单调栈或双指针等数据结构来减少时间复杂度。在实际应用中，类似的区间最小值问题可以通过单调栈来高效解决。

---
处理用时：20.32秒
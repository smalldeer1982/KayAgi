# 题目信息

# [ABC199C] IPFL

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc199/tasks/abc199_c

長さ $ 2N $ の文字列 $ S $ があります。  
 この文字列に対して $ Q $ 個のクエリが与えられます。$ i $ 番目のクエリでは $ 3 $ つの整数 $ T_i,\ A_i,\ B_i $ が与えられるので、以下の処理をします。

- $ T_i\ =\ 1 $ のとき : $ S $ の $ A_i $ 文字目と $ B_i $ 文字目を入れ替える
- $ T_i\ =\ 2 $ のとき : $ S $ の前半 $ N $ 文字と後半 $ N $ 文字を入れ替える($ A_i,\ B_i $ の値は用いない)  
   例えば $ S $ が `FLIP` のときにこのクエリを処理すると、$ S $ は `IPFL` となる。

これら $ Q $ 個のクエリを与えられた順に全て処理した後の $ S $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ S $ は長さ $ 2N $ の英大文字のみからなる文字列
- $ 1\ \le\ Q\ \le\ 3\ \times\ 10^5 $
- $ T_i $ は $ 1 $ または $ 2 $
- $ T_i\ =\ 1 $ のとき、$ 1\ \le\ A_i\ \lt\ B_i\ \le\ 2N $
- $ T_i\ =\ 2 $ のとき、$ A_i\ =\ B_i\ =\ 0 $

### Sample Explanation 1

$ 1 $ 番目のクエリでは $ S $ の前半 $ N $ 文字と後半 $ N $ 文字を入れ替えるため、$ S $ は `IPFL` となります。 $ 2 $ 番目のクエリでは $ S $ の $ 1 $ 文字目と $ 4 $ 文字目を入れ替えるため、$ S $ は `LPFI` となります。

## 样例 #1

### 输入

```
2

FLIP

2

2 0 0

1 1 4```

### 输出

```
LPFI```

## 样例 #2

### 输入

```
2

FLIP

6

1 1 3

2 0 0

1 1 2

1 2 3

2 0 0

1 1 4```

### 输出

```
ILPF```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个长度为 $2N$ 的字符串 $S$，以及 $Q$ 个查询。每个查询包含三个整数 $T_i, A_i, B_i$，根据 $T_i$ 的值执行以下操作：

- 如果 $T_i = 1$，交换 $S$ 的第 $A_i$ 个字符和第 $B_i$ 个字符。
- 如果 $T_i = 2$，交换 $S$ 的前半部分和后半部分（即前 $N$ 个字符和后 $N$ 个字符交换位置）。

处理完所有查询后，输出最终的字符串 $S$。

【说明/提示】

### 约束条件

- $1 \le N \le 2 \times 10^5$
- $S$ 是由长度为 $2N$ 的大写字母组成的字符串。
- $1 \le Q \le 3 \times 10^5$
- $T_i$ 是 $1$ 或 $2$。
- 当 $T_i = 1$ 时，$1 \le A_i < B_i \le 2N$。
- 当 $T_i = 2$ 时，$A_i = B_i = 0$。

### 样例解释

**样例 1**

输入：
```
2
FLIP
2
2 0 0
1 1 4
```

输出：
```
LPFI
```

解释：
- 第一个查询交换前半部分和后半部分，$S$ 变为 `IPFL`。
- 第二个查询交换第 $1$ 和第 $4$ 个字符，$S$ 变为 `LPFI`。

**样例 2**

输入：
```
2
FLIP
6
1 1 3
2 0 0
1 1 2
1 2 3
2 0 0
1 1 4
```

输出：
```
ILPF
```

### 算法分类

**模拟**

### 题解分析与结论

由于题目要求处理大量查询（最多 $3 \times 10^5$ 个），并且每次查询可能涉及字符串的交换操作，直接对字符串进行频繁修改会导致时间复杂度过高。因此，优化思路是减少对字符串的直接操作，转而通过标记或间接方式记录交换状态。

### 通用建议与扩展思路

1. **优化思路**：可以使用一个标记变量来记录当前字符串是否被整体交换过（即 $T_i = 2$ 的操作）。这样，在每次 $T_i = 1$ 的操作时，可以根据标记变量来确定实际需要交换的字符位置，而不需要真正修改字符串。

2. **数据结构**：可以使用一个布尔变量 `flipped` 来记录是否进行了整体交换。在每次 $T_i = 2$ 的操作时，只需翻转 `flipped` 的值，而不需要真正交换字符串的前后部分。

3. **时间复杂度**：通过这种方式，每次查询的时间复杂度可以降低到 $O(1)$，整体时间复杂度为 $O(Q)$，能够满足题目要求。

### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375) - 考察字符串匹配算法。
2. [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370) - 考察字符串哈希的应用。
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374) - 考察树状数组的应用，虽然与字符串无关，但可以学习如何处理大量查询操作。

### 核心代码实现

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int N, Q;
    string S;
    cin >> N >> S >> Q;
    
    bool flipped = false;
    while (Q--) {
        int T, A, B;
        cin >> T >> A >> B;
        if (T == 1) {
            if (flipped) {
                A = (A <= N) ? A + N : A - N;
                B = (B <= N) ? B + N : B - N;
            }
            swap(S[A-1], S[B-1]);
        } else {
            flipped = !flipped;
        }
    }
    
    if (flipped) {
        S = S.substr(N) + S.substr(0, N);
    }
    
    cout << S << endl;
    return 0;
}
```

### 代码解释

- `flipped` 变量用于记录是否进行了整体交换。
- 在 $T_i = 1$ 的操作中，根据 `flipped` 的值调整 $A$ 和 $B$ 的位置，然后交换字符。
- 在 $T_i = 2$ 的操作中，只需翻转 `flipped` 的值。
- 最后，如果 `flipped` 为真，则将字符串的前后部分交换后输出。

---
处理用时：27.48秒
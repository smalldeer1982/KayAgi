# 题目信息

# [ABC204C] Tour

## 题目描述

AtCoder国家包括编号 ${1}$ 到 ${N}$ 的 ${N}$ 个城市和编号为 ${M}$ 的 ${M}$ 条道路。

通过道路 ${i}$ 可以从城市 ${A_i}$ 移动到 ${B_i}$ 。从都市 ${B_i}$ 到都市 ${A_i}$ 不能通行。彪马打算从某个城市开始，使用 ${0}$ 条以上的道路移动，制定以某个城市为终点的旅行计划。

作为起点和终点的城市组合，有几种？

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 2```

### 输出

```
7```

## 样例 #2

### 输入

```
3 0```

### 输出

```
3```

## 样例 #3

### 输入

```
4 4

1 2

2 3

3 4

4 1```

### 输出

```
16```

# AI分析结果

### 题目内容重写

AtCoder国家包括编号为1到N的N个城市和编号为M的M条道路。

通过道路i可以从城市A_i移动到城市B_i。从城市B_i到城市A_i不能通行。彪马打算从某个城市开始，使用0条以上的道路移动，制定以某个城市为终点的旅行计划。

作为起点和终点的城市组合，有几种？

### 样例 #1

#### 输入

```
3 3

1 2

2 3

3 2
```

#### 输出

```
7
```

### 样例 #2

#### 输入

```
3 0
```

#### 输出

```
3
```

### 样例 #3

#### 输入

```
4 4

1 2

2 3

3 4

4 1
```

#### 输出

```
16
```

### 算法分类
图论、深度优先搜索（DFS）

### 题解分析与结论

题目要求计算所有可能的起点和终点的组合数，其中起点和终点可以是同一个城市，且路径可以包含0条或更多条道路。由于道路是单向的，我们需要构建一个有向图，并通过DFS或BFS遍历每个城市，找到所有可达的城市。

### 通用建议与扩展思路
1. **图表示**：使用邻接表表示图，便于遍历。
2. **遍历算法**：DFS或BFS均可用于遍历图，找到所有可达节点。
3. **组合计数**：对于每个起点，记录所有可达的终点，最后统计所有组合。

### 推荐题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)
3. [P2865 [USACO06NOV]Roadblocks G](https://www.luogu.com.cn/problem/P2865)

### 关键思路与技巧
1. **邻接表构建**：使用`vector<vector<int>>`存储图，便于遍历。
2. **DFS遍历**：从每个起点出发，使用DFS遍历所有可达节点，并记录结果。
3. **组合统计**：对于每个起点，统计所有可达的终点，最终累加所有组合数。

### 核心代码片段
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> adj;
vector<bool> visited;
int cnt;

void dfs(int u) {
    visited[u] = true;
    cnt++;
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(v);
        }
    }
}

int main() {
    int N, M;
    cin >> N >> M;
    adj.resize(N + 1);
    for (int i = 0; i < M; ++i) {
        int A, B;
        cin >> A >> B;
        adj[A].push_back(B);
    }
    int total = 0;
    for (int i = 1; i <= N; ++i) {
        visited.assign(N + 1, false);
        cnt = 0;
        dfs(i);
        total += cnt;
    }
    cout << total << endl;
    return 0;
}
```

### 代码实现思想
1. **邻接表构建**：读取输入并构建邻接表。
2. **DFS遍历**：从每个城市出发，使用DFS遍历所有可达城市，并计数。
3. **组合统计**：累加所有起点的可达城市数，输出结果。

### 个人心得
- **调试经历**：在构建邻接表时，确保索引从1开始，避免越界错误。
- **踩坑教训**：DFS中需要标记已访问节点，避免重复计数。
- **顿悟感想**：通过DFS遍历图，可以高效地找到所有可达节点，适用于类似问题。

---
处理用时：24.51秒
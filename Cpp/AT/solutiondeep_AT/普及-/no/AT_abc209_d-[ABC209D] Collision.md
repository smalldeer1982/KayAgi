# 题目信息

# [ABC209D] Collision

## 题目描述

给出一张 $n$ 点 $(n-1)$ 边的无向图，第 $i$ 条边连接点 $a_i$ 和点 $b_i$，长度为 $1$。

给出 $q$ 个询问。第 $i$ 个询问给出两个点 $c_i$ 和 $d_i$。请求出两点之间的最短路长度，若为奇数请输出`Road`，若为偶数请输出`Town`。保证图联通。

## 说明/提示

#### 样例 #1 解释

很明显给出的图为一条链（`1-2-3-4-5`）。$1$ 和 $3$ 之间的最短路长度为 $2$，$1$ 和 $5$ 之间的最短路长度为 $4$。它们都是偶数，所以都输出`Town`。

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- 输入的数值均为整数；
- $2\le n\le 10^5$，$1\le q \le 10^5$；
- $1\le a_i,b_i,c_i,d_i\le n$，且对于同一个 $i$，都有 $a_i\lt b_i$，$c_i\lt d_i$。

## 样例 #1

### 输入

```
4 1

1 2

2 3

2 4

1 2```

### 输出

```
Road```

## 样例 #2

### 输入

```
5 2

1 2

2 3

3 4

4 5

1 3

1 5```

### 输出

```
Town

Town```

## 样例 #3

### 输入

```
9 9

2 3

5 6

4 8

8 9

4 5

3 4

1 9

3 7

7 9

2 5

2 6

4 6

2 4

5 8

7 8

3 6

5 6```

### 输出

```
Town

Road

Town

Town

Town

Town

Road

Road

Road```

# AI分析结果

### 题目内容重写

【题目描述】

给出一张由 $n$ 个点和 $(n-1)$ 条边组成的无向图，第 $i$ 条边连接点 $a_i$ 和点 $b_i$，长度为 $1$。

给出 $q$ 个询问。第 $i$ 个询问给出两个点 $c_i$ 和 $d_i$。请求出两点之间的最短路长度，若为奇数请输出`Road`，若为偶数请输出`Town`。保证图是连通的。

【说明/提示】

#### 样例 #1 解释

很明显给出的图为一条链（`1-2-3-4-5`）。$1$ 和 $3$ 之间的最短路长度为 $2$，$1$ 和 $5$ 之间的最短路长度为 $4$。它们都是偶数，所以都输出`Town`。

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- 输入的数值均为整数；
- $2\le n\le 10^5$，$1\le q \le 10^5$；
- $1\le a_i,b_i,c_i,d_i\le n$，且对于同一个 $i$，都有 $a_i\lt b_i$，$c_i\lt d_i$。

【样例 #1】

### 输入

```
4 1

1 2

2 3

2 4

1 2```

### 输出

```
Road```

【样例 #2】

### 输入

```
5 2

1 2

2 3

3 4

4 5

1 3

1 5```

### 输出

```
Town

Town```

【样例 #3】

### 输入

```
9 9

2 3

5 6

4 8

8 9

4 5

3 4

1 9

3 7

7 9

2 5

2 6

4 6

2 4

5 8

7 8

3 6

5 6```

### 输出

```
Town

Road

Town

Town

Town

Town

Road

Road

Road```

### 算法分类

最短路、图论

### 综合分析与结论

本题的核心是求解无向图中任意两点之间的最短路长度，并根据长度的奇偶性输出`Road`或`Town`。由于图是连通的且边权为1，最短路可以通过广度优先搜索（BFS）来求解。由于数据规模较大（$n$和$q$都可能达到$10^5$），需要优化查询效率。

### 通用建议与扩展思路

1. **BFS预处理**：由于图是树结构，可以通过一次BFS预处理出所有节点到根节点的距离，然后利用LCA（最近公共祖先）来快速计算任意两点之间的最短路长度。
2. **LCA优化**：使用倍增法或Tarjan算法来快速求解LCA，从而减少查询时间。
3. **奇偶性判断**：在预处理时，可以直接记录每个节点的深度（距离根节点的距离），然后通过深度的奇偶性来判断最短路长度的奇偶性。

### 推荐题目

1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1395 会议](https://www.luogu.com.cn/problem/P1395)
3. [P2420 让我们异或吧](https://www.luogu.com.cn/problem/P2420)

### 核心代码片段

```cpp
// BFS预处理深度
void bfs(int root) {
    queue<int> q;
    q.push(root);
    depth[root] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (depth[v] == -1) {
                depth[v] = depth[u] + 1;
                q.push(v);
            }
        }
    }
}

// LCA查询
int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);
    for (int i = LOG - 1; i >= 0; i--) {
        if (depth[u] - (1 << i) >= depth[v]) {
            u = up[u][i];
        }
    }
    if (u == v) return u;
    for (int i = LOG - 1; i >= 0; i--) {
        if (up[u][i] != up[v][i]) {
            u = up[u][i];
            v = up[v][i];
        }
    }
    return up[u][0];
}

// 查询最短路长度
int query(int u, int v) {
    int ancestor = lca(u, v);
    return depth[u] + depth[v] - 2 * depth[ancestor];
}
```

### 总结

本题的关键在于通过BFS预处理和LCA优化来快速求解任意两点之间的最短路长度，并根据奇偶性输出结果。这种方法在处理大规模数据时具有较高的效率，适合在竞赛中使用。

---
处理用时：29.24秒
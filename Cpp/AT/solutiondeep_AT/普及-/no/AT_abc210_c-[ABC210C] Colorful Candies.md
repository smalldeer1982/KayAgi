# 题目信息

# [ABC210C] Colorful Candies

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc210/tasks/abc210_c

$ N $ 個のキャンディが左右一列に並んでいます。  
 それぞれのキャンディは、色 $ 1 $、色 $ 2 $、$ \ldots $、色 $ 10^9 $の、$ 10^9 $ 種類の色のうちいずれかの色をしています。  
 $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、左から $ i $ 番目のキャンディの色は色 $ c_i $ です。

高橋君は並んでいるキャンディのうち、連続して並んだ $ K $ 個のキャンディをもらうことができます。  
 すなわち、$ 1\ \leq\ i\ \leq\ N-K+1 $ を満たす整数 $ i $ を選んで、 左から $ i $ 番目、$ i+1 $ 番目、$ i+2 $ 番目、$ \ldots $、$ i+K-1 $ 番目のキャンディをもらうことができます。

高橋君はいろいろな色のキャンディを食べたいので、 もらうキャンディに含まれる色の種類数が多いほどうれしい気持ちになります。  
 高橋君がもらうキャンディに含まれる色の種類数の最大値を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ c_i\ \leq\ 10^9 $
- 入力はすべて整数

### Sample Explanation 1

高橋君が左から $ 3 $ 番目から $ 5 $ 番目のキャンディをもらうと、もらうキャンディに含まれる色は $ 3 $ 種類になり、これが最大です。

### Sample Explanation 2

高橋君は並んでいるすべてのキャンディをもらうことが出来ますが、もらうキャンディに含まれる色は $ 1 $ 種類です。

## 样例 #1

### 输入

```
7 3

1 2 1 2 3 3 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5 5

4 4 4 4 4```

### 输出

```
1```

## 样例 #3

### 输入

```
10 6

304621362 506696497 304621362 506696497 834022578 304621362 414720753 304621362 304621362 414720753```

### 输出

```
4```

# AI分析结果

### 题目内容翻译

**题目描述**

有 $N$ 个糖果排成一列。每个糖果的颜色是 $1$ 到 $10^9$ 中的一种。对于 $i = 1, 2, \ldots, N$，从左到右第 $i$ 个糖果的颜色是 $c_i$。

高桥君可以选择连续 $K$ 个糖果带走。也就是说，他可以选择一个满足 $1 \leq i \leq N-K+1$ 的整数 $i$，然后带走从左到右第 $i$ 到第 $i+K-1$ 个糖果。

高桥君希望带走的糖果中包含的颜色种类尽可能多。请输出他带走的糖果中颜色种类的最大可能值。

**说明/提示**

**约束条件**

- $1 \leq K \leq N \leq 3 \times 10^5$
- $1 \leq c_i \leq 10^9$
- 输入均为整数

**样例解释1**

高桥君选择从左到右第3到第5个糖果时，带走的糖果中有3种颜色，这是最大值。

**样例解释2**

高桥君可以带走所有糖果，但带走的糖果中只有1种颜色。

**样例1**

**输入**

```
7 3
1 2 1 2 3 3 1
```

**输出**

```
3
```

**样例2**

**输入**

```
5 5
4 4 4 4 4
```

**输出**

```
1
```

**样例3**

**输入**

```
10 6
304621362 506696497 304621362 506696497 834022578 304621362 414720753 304621362 304621362 414720753
```

**输出**

```
4
```

### 算法分类

**滑动窗口**

### 题解分析与结论

由于题目要求找到连续 $K$ 个糖果中颜色种类的最大值，且 $N$ 和 $K$ 的范围较大（$N \leq 3 \times 10^5$），因此需要一个高效的算法来解决这个问题。滑动窗口是一种非常适合处理连续子数组问题的算法，能够在 $O(N)$ 的时间复杂度内解决问题。

### 关键思路与技巧

1. **滑动窗口**：通过维护一个窗口，窗口的大小为 $K$，每次移动窗口时，更新窗口内的颜色种类数。
2. **哈希表**：使用哈希表（如 `unordered_map`）来记录窗口内每种颜色的出现次数，从而快速判断颜色的增减。
3. **窗口移动**：当窗口向右移动时，移除窗口最左边的元素，并添加窗口最右边的元素，同时更新哈希表中的计数。

### 核心代码实现

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

int main() {
    int N, K;
    cin >> N >> K;
    vector<int> c(N);
    for (int i = 0; i < N; ++i) {
        cin >> c[i];
    }

    unordered_map<int, int> colorCount;
    int maxColors = 0;
    int uniqueColors = 0;

    for (int i = 0; i < N; ++i) {
        if (i >= K) {
            colorCount[c[i - K]]--;
            if (colorCount[c[i - K]] == 0) {
                uniqueColors--;
            }
        }

        if (colorCount[c[i]] == 0) {
            uniqueColors++;
        }
        colorCount[c[i]]++;

        if (i >= K - 1) {
            maxColors = max(maxColors, uniqueColors);
        }
    }

    cout << maxColors << endl;
    return 0;
}
```

### 代码实现思想

1. **初始化**：读取输入的 $N$ 和 $K$，以及糖果的颜色数组 $c$。
2. **滑动窗口**：使用一个哈希表 `colorCount` 来记录当前窗口内每种颜色的出现次数，并维护 `uniqueColors` 来记录当前窗口内不同颜色的数量。
3. **窗口移动**：每次移动窗口时，更新哈希表中的计数，并相应地更新 `uniqueColors`。
4. **记录最大值**：在每次窗口移动后，记录当前窗口内不同颜色的最大值。

### 拓展思路

类似的问题可以使用滑动窗口来解决，例如：
- 求连续子数组的最大和。
- 求连续子数组的最小长度满足某些条件。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1638 连续子数组的最大和](https://www.luogu.com.cn/problem/P1638)
3. [P1639 最小覆盖子串](https://www.luogu.com.cn/problem/P1639)

这些题目都涉及到滑动窗口的应用，可以帮助进一步理解和掌握这一算法技巧。

---
处理用时：26.79秒
# 题目信息

# [ABC211C] chokudai

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc211/tasks/abc211_c

文字列 $ S $ が与えられます。  
 このうち $ 8 $ 文字を選び下線を引き、下線を引いた文字が左から順に `c` , `h` , `o` , `k` , `u` , `d` , `a` , `i` となるようにする方法は何通りありますか？  
 ただし答えは非常に大きくなる可能性があるので、$ (10^9\ +\ 7) $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 8\ \leq\ |S|\ \leq\ 10^5 $
- $ S $ は英小文字からなる

### Sample Explanation 1

chchokudai chchokudai chchokudai 上の $ 3 $ つが条件を満たします。 chchokudai は、条件を満たさないことに注意してください。

### Sample Explanation 2

答えが $ 0 $ 通りになることもあります。

## 样例 #1

### 输入

```
chchokudai```

### 输出

```
3```

## 样例 #2

### 输入

```
atcoderrr```

### 输出

```
0```

## 样例 #3

### 输入

```
chokudaichokudaichokudai```

### 输出

```
45```

# AI分析结果

### 题目内容重写

给定一个字符串 $ S $。  
从中选择 $ 8 $ 个字符并划下划线，使得划下划线的字符从左到右依次为 `c`、`h`、`o`、`k`、`u`、`d`、`a`、`i`。  
问有多少种选择方法？  
由于答案可能非常大，输出结果对 $ 10^9 + 7 $ 取模。

### 说明/提示

#### 约束

- $ 8 \leq |S| \leq 10^5 $
- $ S $ 由小写英文字母组成

#### 样例解释 1

`chchokudai chchokudai chchokudai` 中的 $ 3 $ 个字符串满足条件。注意，`chchokudai` 本身不满足条件。

#### 样例解释 2

答案可能为 $ 0 $。

### 样例 #1

#### 输入

```
chchokudai
```

#### 输出

```
3
```

### 样例 #2

#### 输入

```
atcoderrr
```

#### 输出

```
0
```

### 样例 #3

#### 输入

```
chokudaichokudaichokudai
```

#### 输出

```
45
```

### 算法分类

动态规划

### 综合分析与结论

本题的核心问题是从字符串 $ S $ 中选择特定顺序的字符组合，且顺序必须为 `c`、`h`、`o`、`k`、`u`、`d`、`a`、`i`。由于字符串长度可能达到 $ 10^5 $，直接暴力枚举显然不可行。因此，动态规划是解决此问题的合适方法。

### 题解分析

由于暂无题解，以下为通用建议与扩展思路：

1. **动态规划思路**：
   - 定义状态 $ dp[i][j] $ 表示前 $ i $ 个字符中匹配到目标字符串的第 $ j $ 个字符的方案数。
   - 初始化 $ dp[0][0] = 1 $，表示空字符串匹配空目标字符串的方案数为 1。
   - 状态转移方程：
     - 如果 $ S[i] == T[j] $，则 $ dp[i][j] = dp[i-1][j-1] + dp[i-1][j] $。
     - 否则，$ dp[i][j] = dp[i-1][j] $。
   - 最终答案为 $ dp[n][8] $，其中 $ n $ 是字符串 $ S $ 的长度。

2. **优化**：
   - 由于 $ dp[i][j] $ 只依赖于 $ dp[i-1][j-1] $ 和 $ dp[i-1][j] $，可以使用滚动数组优化空间复杂度，将二维数组压缩为一维数组。

3. **代码实现**：
   ```cpp
   const int MOD = 1e9 + 7;
   int countWays(string S) {
       string T = "chokudai";
       int n = S.length(), m = T.length();
       vector<int> dp(m + 1, 0);
       dp[0] = 1;
       for (int i = 0; i < n; ++i) {
           for (int j = m - 1; j >= 0; --j) {
               if (S[i] == T[j]) {
                   dp[j + 1] = (dp[j + 1] + dp[j]) % MOD;
               }
           }
       }
       return dp[m];
   }
   ```

### 扩展思路

类似的问题可以扩展到其他字符串匹配问题，如从字符串中匹配任意给定的子序列。动态规划是解决这类问题的通用方法，通过状态转移方程可以高效地计算出结果。

### 推荐题目

1. [P1143 最长公共子序列](https://www.luogu.com.cn/problem/P1143)
2. [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)
3. [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)

这些题目都涉及到字符串匹配或子序列问题，可以通过动态规划的方法解决。

---
处理用时：25.67秒
# 题目信息

# [ABC213C] Reorder Cards

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc213/tasks/abc213_c

$ H $ 行 $ W $ 列の格子状に $ HW $ 枚のカードが並べられています。  
 $ i=1,\ldots,N $ について、上から $ A_i $ 行目、左から $ B_i $ 列目にあるカードには数 $ i $ が書かれており、それ以外の $ HW-N $ 枚のカードには何も書かれていません。

これらのカードに対し、以下の $ 2 $ 種類の操作を可能な限り繰り返します。

- 数の書かれたカードを含まない行が存在するとき、その行のカードを全て取り除き、残りのカードを上へ詰める
- 数の書かれたカードを含まない列が存在するとき、その列のカードを全て取り除き、残りのカードを左へ詰める

操作が終了したとき、数が書かれたカードがそれぞれどこにあるか求めてください。なお、答えは操作の仕方に依らず一意に定まることが証明されます。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 10^9 $
- $ 1\ \leq\ N\ \leq\ \min(10^5,HW) $
- $ 1\ \leq\ A_i\ \leq\ H $
- $ 1\ \leq\ B_i\ \leq\ W $
- $ (A_i,B_i) $ は相異なる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

何も書かれていないカードを `\*` で表すことにします。最初、カードの配置は以下の通りです。 ``` \*\*\*\*\* \*\*\*\*2 \*1\*\*\* \*\*\*\*\* ``` 操作終了後、カードの配置は以下の通りになります。 ``` \*2 1\* ``` $ 1 $ が書かれたカードは上から $ 2 $ 行目、左から $ 1 $ 列目にあり、$ 2 $ が書かれたカードは上から $ 1 $ 行目、左から $ 2 $ 列目にあります。

## 样例 #1

### 输入

```
4 5 2

3 2

2 5```

### 输出

```
2 1

1 2```

## 样例 #2

### 输入

```
1000000000 1000000000 10

1 1

10 10

100 100

1000 1000

10000 10000

100000 100000

1000000 1000000

10000000 10000000

100000000 100000000

1000000000 1000000000```

### 输出

```
1 1

2 2

3 3

4 4

5 5

6 6

7 7

8 8

9 9

10 10```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个 $ H $ 行 $ W $ 列的格子，其中排列着 $ HW $ 张卡片。对于 $ i=1,\ldots,N $，从上数第 $ A_i $ 行、从左数第 $ B_i $ 列的卡片上写有数字 $ i $，其余 $ HW-N $ 张卡片上没有写任何数字。

对这些卡片进行以下两种操作，直到无法继续为止：

1. 如果存在不包含任何数字卡片的行，则移除该行的所有卡片，并将剩余的卡片向上移动以填补空缺。
2. 如果存在不包含任何数字卡片的列，则移除该列的所有卡片，并将剩余的卡片向左移动以填补空缺。

操作结束后，请确定每张写有数字的卡片的位置。注意，答案与操作的顺序无关，且唯一确定。

#### 说明/提示

##### 约束条件

- $ 1 \leq H, W \leq 10^9 $
- $ 1 \leq N \leq \min(10^5, HW) $
- $ 1 \leq A_i \leq H $
- $ 1 \leq B_i \leq W $
- $ (A_i, B_i) $ 互不相同
- 输入中的所有值均为整数

##### 样例解释 1

用 `\*` 表示没有数字的卡片。初始时，卡片的排列如下：

```
\*\*\*\*\*
\*\*\*\*2
\*1\*\*\*
\*\*\*\*\*
```

操作结束后，卡片的排列如下：

```
\*2
1\*
```

写有数字 $ 1 $ 的卡片位于从上数第 $ 2 $ 行、从左数第 $ 1 $ 列，写有数字 $ 2 $ 的卡片位于从上数第 $ 1 $ 行、从左数第 $ 2 $ 列。

##### 样例 #1

###### 输入

```
4 5 2
3 2
2 5
```

###### 输出

```
2 1
1 2
```

##### 样例 #2

###### 输入

```
1000000000 1000000000 10
1 1
10 10
100 100
1000 1000
10000 10000
100000 100000
1000000 1000000
10000000 10000000
100000000 100000000
1000000000 1000000000
```

###### 输出

```
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
10 10
```

### 算法分类

离散化

### 题解分析与结论

由于题目中 $ H $ 和 $ W $ 的范围非常大（$ 10^9 $），直接模拟操作会导致时间和空间复杂度过高。因此，我们需要通过离散化的方法，将原始的行列坐标映射到新的坐标系统中，从而减少计算量。

#### 关键思路

1. **离散化处理**：将所有的 $ A_i $ 和 $ B_i $ 分别进行排序和去重，得到新的行和列的映射关系。
2. **坐标映射**：通过二分查找，将原始的行列坐标映射到新的坐标系统中。
3. **输出结果**：根据映射后的坐标输出每张卡片的位置。

#### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int H, W, N;
    cin >> H >> W >> N;
    vector<int> A(N), B(N);
    for (int i = 0; i < N; ++i) {
        cin >> A[i] >> B[i];
    }

    // 离散化处理
    vector<int> rows = A, cols = B;
    sort(rows.begin(), rows.end());
    sort(cols.begin(), cols.end());
    rows.erase(unique(rows.begin(), rows.end()), rows.end());
    cols.erase(unique(cols.begin(), cols.end()), cols.end());

    // 坐标映射
    for (int i = 0; i < N; ++i) {
        int new_row = lower_bound(rows.begin(), rows.end(), A[i]) - rows.begin() + 1;
        int new_col = lower_bound(cols.begin(), cols.end(), B[i]) - cols.begin() + 1;
        cout << new_row << " " << new_col << endl;
    }

    return 0;
}
```

#### 代码说明

1. **离散化处理**：通过排序和去重，得到唯一的行和列坐标。
2. **坐标映射**：使用 `lower_bound` 函数找到原始坐标在离散化后的新坐标系统中的位置。
3. **输出结果**：根据映射后的坐标输出每张卡片的位置。

### 推荐题目

1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

这些题目都涉及到离散化的应用，可以帮助进一步理解和掌握离散化的技巧。

---
处理用时：28.55秒
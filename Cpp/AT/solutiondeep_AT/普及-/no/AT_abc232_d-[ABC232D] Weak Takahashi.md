# 题目信息

# [ABC232D] Weak Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc232/tasks/abc232_d

縦 $ H $ 行、横 $ W $ 行の $ H\ \times\ W $ マスからなるグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表します。  
 各マスの状態は文字 $ C_{i,\ j} $ で表され、$ C_{i,\ j}\ = $ `.` ならばマス $ (i,\ j) $ は空きマスであり、$ C_{i,\ j}\ = $ `#` ならばマス $ (i,\ j) $ は壁です。

高橋君がグリッド上を歩こうとしています。彼がマス $ (i,\ j) $ にいるとき、マス $ (i,\ j\ +\ 1) $ またはマス $ (i\ +\ 1,\ j) $ に移動することができます。ただし、グリッドの外に出るような移動や、壁のマスへの移動を行うことはできません。高橋君は、移動することのできるマスが無くなった時点で立ち止まります。

高橋君がマス $ (1,\ 1) $ から歩き始めるとき、彼が立ち止まるまでに通ることのできるマスは最大で何マスですか？

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 100 $
- $ H,\ W $ は整数
- $ C_{i,\ j}\ = $ `.` または $ C_{i,\ j}\ = $ `#` $ (1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W) $
- $ C_{1,\ 1}\ = $ `.`

### Sample Explanation 1

例えば $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (3,\ 2) $ と進むことで、$ 4 $ マス通ることができます。 $ 5 $ マス以上通ることはできないので、$ 4 $ と出力します。

## 样例 #1

### 输入

```
3 4

.#..

..#.

..##```

### 输出

```
4```

## 样例 #2

### 输入

```
1 1

.```

### 输出

```
1```

## 样例 #3

### 输入

```
5 5

.....

.....

.....

.....

.....```

### 输出

```
9```

# AI分析结果

【题目内容重写】

# [ABC232D] Weak Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc232/tasks/abc232_d

有一个由 $ H $ 行、$ W $ 列组成的 $ H \times W $ 的网格。从上到下第 $ i $ 行、从左到右第 $ j $ 列的格子表示为 $ (i, j) $。  
每个格子的状态由字符 $ C_{i, j} $ 表示，如果 $ C_{i, j} = $ `.`，则格子 $ (i, j) $ 是空的；如果 $ C_{i, j} = $ `#`，则格子 $ (i, j) $ 是墙壁。

高桥君想在网格上行走。当他位于格子 $ (i, j) $ 时，他可以移动到格子 $ (i, j + 1) $ 或格子 $ (i + 1, j) $。然而，他不能移动到网格外或墙壁所在的格子。高桥君在无法继续移动时会停下来。

高桥君从格子 $ (1, 1) $ 开始行走，问他停下来之前最多可以经过多少个格子？

## 说明/提示

### 约束条件

- $ 1 \leq H, W \leq 100 $
- $ H, W $ 是整数
- $ C_{i, j} = $ `.` 或 $ C_{i, j} = $ `#` $ (1 \leq i \leq H, 1 \leq j \leq W) $
- $ C_{1, 1} = $ `.`

### 样例解释 1

例如，高桥君可以按照 $ (1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (3, 2) $ 的路径行走，经过 $ 4 $ 个格子。他无法经过 $ 5 $ 个或更多的格子，因此输出 $ 4 $。

## 样例 #1

### 输入

```
3 4

.#..

..#.

..##```

### 输出

```
4```

## 样例 #2

### 输入

```
1 1

.```

### 输出

```
1```

## 样例 #3

### 输入

```
5 5

.....

.....

.....

.....

.....```

### 输出

```
9```

【算法分类】  
深度优先搜索 DFS

【题解分析与结论】  
本题的核心是通过深度优先搜索（DFS）或广度优先搜索（BFS）来遍历网格，计算从起点 $ (1, 1) $ 出发能够到达的最远距离。由于网格的大小较小（$ H, W \leq 100 $），DFS 或 BFS 都可以在合理时间内完成。

【通用建议与扩展思路】  
1. **DFS 与 BFS 的选择**：DFS 更适合路径较深的情况，而 BFS 更适合路径较宽的情况。本题中，DFS 和 BFS 都可以使用，但 BFS 更容易实现层次遍历，适合计算最短路径或最大步数。
2. **记忆化优化**：在 DFS 中，可以使用记忆化来避免重复计算，提高效率。
3. **边界处理**：在移动时，需要特别注意边界条件和墙壁的判断，避免越界或进入墙壁。

【推荐题目】  
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)  
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)  
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

【关键思路与技巧】  
1. **DFS 实现**：从起点开始，递归地向右或向下移动，记录当前步数，并更新最大值。
2. **BFS 实现**：使用队列进行层次遍历，每次从队列中取出当前格子，并尝试向右或向下移动，直到无法继续移动。
3. **记忆化优化**：在 DFS 中，使用一个二维数组记录每个格子是否已经访问过，避免重复计算。

【核心代码片段】  
以下是 DFS 的实现代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int H, W;
vector<string> grid;
vector<vector<int>> dp;

int dfs(int i, int j) {
    if (i >= H || j >= W || grid[i][j] == '#') return 0;
    if (dp[i][j] != -1) return dp[i][j];
    int res = 1 + max(dfs(i + 1, j), dfs(i, j + 1));
    return dp[i][j] = res;
}

int main() {
    cin >> H >> W;
    grid.resize(H);
    for (int i = 0; i < H; ++i) cin >> grid[i];
    dp.assign(H, vector<int>(W, -1));
    cout << dfs(0, 0) << endl;
    return 0;
}
```

【总结】  
本题通过 DFS 或 BFS 可以有效地解决，关键在于如何优化遍历过程，避免重复计算。记忆化是 DFS 中常用的优化手段，而 BFS 则更适合层次遍历。

---
处理用时：34.57秒
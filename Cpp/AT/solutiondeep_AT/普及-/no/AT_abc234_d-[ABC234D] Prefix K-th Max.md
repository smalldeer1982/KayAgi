# 题目信息

# [ABC234D] Prefix K-th Max

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc234/tasks/abc234_d

$ (1,2,\ldots,N) $ の順列 $ P=(P_1,P_2,\ldots,P_N) $、および正整数 $ K $ が与えられます。

$ i=K,K+1,\ldots,N $ について、以下を求めてください。

- $ P $ の先頭 $ i $ 項のうち、$ K $ 番目に大きい値

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ (P_1,P_2,\ldots,P_N) $ は $ (1,2,\ldots,N) $ の並び替えによって得られる
- 入力はすべて整数

### Sample Explanation 1

\- $ P $ の先頭 $ 2 $ 項、すなわち $ (P_1,P_2)=(1,2) $ の中で $ K=2 $ 番目に大きい値は $ 1 $ となります。 - $ P $ の先頭 $ 3 $ 項、すなわち $ (P_1,P_2,P_3)=(1,2,3) $ の中で $ K=2 $ 番目に大きい値は $ 2 $ となります。

## 样例 #1

### 输入

```
3 2

1 2 3```

### 输出

```
1

2```

## 样例 #2

### 输入

```
11 5

3 7 2 5 11 6 1 9 8 10 4```

### 输出

```
2

3

3

5

6

7

7```

# AI分析结果

### 题目内容重写

#### [ABC234D] Prefix K-th Max

#### 题目描述

给定一个排列 $ P=(P_1,P_2,\ldots,P_N) $，其中 $ P $ 是 $ (1,2,\ldots,N) $ 的一个排列，以及一个正整数 $ K $。

对于每个 $ i=K,K+1,\ldots,N $，请输出 $ P $ 的前 $ i $ 项中第 $ K $ 大的值。

#### 说明/提示

##### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ (P_1,P_2,\ldots,P_N) $ 是 $ (1,2,\ldots,N) $ 的一个排列
- 输入均为整数

##### 样例解释 1

- $ P $ 的前 $ 2 $ 项，即 $ (P_1,P_2)=(1,2) $ 中第 $ K=2 $ 大的值是 $ 1 $。
- $ P $ 的前 $ 3 $ 项，即 $ (P_1,P_2,P_3)=(1,2,3) $ 中第 $ K=2 $ 大的值是 $ 2 $。

#### 样例 #1

##### 输入

```
3 2

1 2 3
```

##### 输出

```
1

2
```

#### 样例 #2

##### 输入

```
11 5

3 7 2 5 11 6 1 9 8 10 4
```

##### 输出

```
2

3

3

5

6

7

7
```

### 算法分类

排序、优先队列（堆）

### 题解分析与结论

由于题目要求对于每个 $ i=K,K+1,\ldots,N $，输出前 $ i $ 项中第 $ K $ 大的值，直接暴力求解会超时。因此，需要使用一种高效的数据结构来维护前 $ i $ 项中的前 $ K $ 大元素。

#### 最优思路

使用一个最小堆（优先队列）来维护前 $ i $ 项中的前 $ K $ 大元素。每当新元素加入时，如果它比堆顶元素大，则替换堆顶元素，并调整堆。这样，堆顶元素始终是前 $ i $ 项中第 $ K $ 大的值。

#### 关键实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, K;
    cin >> N >> K;
    vector<int> P(N);
    for (int i = 0; i < N; ++i) cin >> P[i];
    
    priority_queue<int, vector<int>, greater<int>> pq;
    for (int i = 0; i < K; ++i) pq.push(P[i]);
    cout << pq.top() << "\n";
    
    for (int i = K; i < N; ++i) {
        if (P[i] > pq.top()) {
            pq.pop();
            pq.push(P[i]);
        }
        cout << pq.top() << "\n";
    }
    
    return 0;
}
```

#### 代码解释

1. 初始化一个最小堆 `pq`，并将前 $ K $ 个元素放入堆中。
2. 对于后续的每个元素，如果它比堆顶元素大，则替换堆顶元素，并调整堆。
3. 每次输出堆顶元素，即前 $ i $ 项中第 $ K $ 大的值。

### 推荐题目

1. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

这些题目都涉及到堆的使用，可以帮助巩固优先队列的相关知识。

---
处理用时：22.26秒
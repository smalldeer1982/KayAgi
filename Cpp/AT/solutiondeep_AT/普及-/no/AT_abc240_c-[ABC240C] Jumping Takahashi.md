# 题目信息

# [ABC240C] Jumping Takahashi

## 题目描述

#### 题意简述：
给定两个大小为 $N$ 的数组 $a$ 与 $b$ ，$N$轮选择，每次从 $a[i]$ 与 $b[i]$ 中任选1个数，如果最后n组选出的数之和可以为 $X$ ，输出“Yes”，否则输出“No”

## 样例 #1

### 输入

```
2 10

3 6

4 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 10

10 100

10 100```

### 输出

```
No```

## 样例 #3

### 输入

```
4 12

1 8

5 7

3 4

2 6```

### 输出

```
Yes```

# AI分析结果

【题目内容】
# [ABC240C] Jumping Takahashi

## 题目描述

#### 题意简述：
给定两个大小为 $N$ 的数组 $a$ 与 $b$ ，$N$轮选择，每次从 $a[i]$ 与 $b[i]$ 中任选1个数，如果最后n组选出的数之和可以为 $X$ ，输出“Yes”，否则输出“No”

## 样例 #1

### 输入

```
2 10

3 6

4 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 10

10 100

10 100```

### 输出

```
No```

## 样例 #3

### 输入

```
4 12

1 8

5 7

3 4

2 6```

### 输出

```
Yes```

【算法分类】
动态规划

【综合分析】
该题的核心问题是在每一轮选择中从两个数中选一个，最终判断是否能达到目标值 $X$。由于每一轮的选择会影响最终结果，因此可以使用动态规划来解决。通过记录每一步可能达到的和，最终判断 $X$ 是否在可能的和集合中。

【通用建议与扩展思路】
1. **动态规划**：使用动态规划记录每一步可能达到的和，最终判断目标值是否在可能的和集合中。
2. **优化空间**：可以使用滚动数组优化空间复杂度，减少内存使用。
3. **剪枝**：在动态规划过程中，如果当前和已经超过 $X$，可以提前剪枝，减少不必要的计算。

【推荐题目】
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 动态规划经典问题，类似于背包问题。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 动态规划问题，涉及选择与和的计算。
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164) - 动态规划问题，涉及选择与和的计算。

【关键思路】
1. **动态规划**：通过记录每一步可能达到的和，最终判断目标值是否在可能的和集合中。
2. **滚动数组**：使用滚动数组优化空间复杂度，减少内存使用。
3. **剪枝**：在动态规划过程中，如果当前和已经超过 $X$，可以提前剪枝，减少不必要的计算。

【核心代码片段】
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, X;
    cin >> N >> X;
    vector<int> a(N), b(N);
    for (int i = 0; i < N; ++i) {
        cin >> a[i] >> b[i];
    }
    
    vector<bool> dp(X + 1, false);
    dp[0] = true;
    
    for (int i = 0; i < N; ++i) {
        vector<bool> new_dp(X + 1, false);
        for (int j = 0; j <= X; ++j) {
            if (dp[j]) {
                if (j + a[i] <= X) new_dp[j + a[i]] = true;
                if (j + b[i] <= X) new_dp[j + b[i]] = true;
            }
        }
        dp = new_dp;
    }
    
    cout << (dp[X] ? "Yes" : "No") << endl;
    return 0;
}
```

【代码实现思想】
1. **初始化**：创建一个大小为 $X+1$ 的布尔数组 `dp`，用于记录每一步可能达到的和。
2. **动态规划**：遍历每一轮选择，更新可能达到的和。
3. **判断结果**：最终检查 `dp[X]` 是否为 `true`，如果是则输出“Yes”，否则输出“No”。

---
处理用时：22.58秒
# 题目信息

# [ABC245C] Choose Elements

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc245/tasks/abc245_c

長さ $ N $ の整数からなる数列 $ A=(A_1,\ldots,A_N),B=(B_1,\ldots,B_N) $ が与えられます。

以下の条件を全て満たす長さ $ N $ の数列 $ X=(X_1,\ldots,X_N) $ が存在するかを判定してください。

- すべての $ i(1\leq\ i\leq\ N) $ について、$ X_i\ =\ A_i $ または $ X_i\ =\ B_i $
- すべての $ i(1\leq\ i\leq\ N-1) $ について、$ |X_i\ -\ X_{i+1}|\ \leq\ K $

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0 \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ A_i,B_i\ \leq\ 10^9 $
- 入力は全て整数である

### Sample Explanation 1

$ X=(9,6,3,7,5) $ が全ての条件を満たします。

### Sample Explanation 2

条件を満たす $ X $ は存在しません。

## 样例 #1

### 输入

```
5 4

9 8 3 7 2

1 6 2 9 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
4 90

1 1 1 100

1 2 3 100```

### 输出

```
No```

## 样例 #3

### 输入

```
4 1000000000

1 1 1000000000 1000000000

1 1000000000 1 1000000000```

### 输出

```
Yes```

# AI分析结果

【题目内容】
# [ABC245C] Choose Elements

## 题目描述

给定长度为 $ N $ 的两个整数数列 $ A=(A_1,\ldots,A_N) $ 和 $ B=(B_1,\ldots,B_N) $。

判断是否存在一个长度为 $ N $ 的数列 $ X=(X_1,\ldots,X_N) $，满足以下所有条件：

- 对于所有的 $ i(1\leq\ i\leq\ N) $，$ X_i\ =\ A_i $ 或 $ X_i\ =\ B_i $。
- 对于所有的 $ i(1\leq\ i\leq\ N-1) $，$ |X_i\ -\ X_{i+1}|\ \leq\ K $。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0 \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ A_i,B_i\ \leq\ 10^9 $
- 输入均为整数

### 样例解释 1

$ X=(9,6,3,7,5) $ 满足所有条件。

### 样例解释 2

不存在满足条件的 $ X $。

## 样例 #1

### 输入

```
5 4

9 8 3 7 2

1 6 2 9 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
4 90

1 1 1 100

1 2 3 100```

### 输出

```
No```

## 样例 #3

### 输入

```
4 1000000000

1 1 1000000000 1000000000

1 1000000000 1 1000000000```

### 输出

```
Yes```

【算法分类】
动态规划

【综合分析与结论】
本题的核心在于判断是否存在一个数列 $ X $，使得每个元素要么来自 $ A $，要么来自 $ B $，并且相邻元素的差的绝对值不超过 $ K $。由于 $ N $ 的最大值为 $ 2 \times 10^5 $，因此需要一个高效的算法来处理这个问题。

动态规划是解决此类问题的有效方法。我们可以通过维护两个状态数组 $ dpA $ 和 $ dpB $，分别表示当前元素选择 $ A $ 或 $ B $ 时是否满足条件。通过遍历数组，逐步更新这两个状态数组，最终判断是否存在满足条件的数列。

【通用建议与扩展思路】
1. **动态规划的应用**：本题展示了如何通过动态规划来处理序列问题，特别是当问题涉及到选择与相邻元素的约束时，动态规划是一个常用的解决方案。
2. **状态转移的优化**：在动态规划中，状态转移方程的设计至关重要。本题中，通过维护两个状态数组，可以有效地减少计算量。
3. **边界条件的处理**：在处理动态规划问题时，边界条件的处理往往容易被忽视，但却是确保算法正确性的关键。

【推荐题目】
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 动态规划经典问题，涉及选择与约束。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 动态规划问题，涉及选择与预算约束。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 动态规划问题，涉及序列的选择与约束。

【关键代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, K;
    cin >> N >> K;
    vector<int> A(N), B(N);
    for (int i = 0; i < N; ++i) cin >> A[i];
    for (int i = 0; i < N; ++i) cin >> B[i];
    
    vector<bool> dpA(N, false), dpB(N, false);
    dpA[0] = true;
    dpB[0] = true;
    
    for (int i = 1; i < N; ++i) {
        if (dpA[i-1]) {
            if (abs(A[i-1] - A[i]) <= K) dpA[i] = true;
            if (abs(A[i-1] - B[i]) <= K) dpB[i] = true;
        }
        if (dpB[i-1]) {
            if (abs(B[i-1] - A[i]) <= K) dpA[i] = true;
            if (abs(B[i-1] - B[i]) <= K) dpB[i] = true;
        }
    }
    
    if (dpA[N-1] || dpB[N-1]) cout << "Yes" << endl;
    else cout << "No" << endl;
    
    return 0;
}
```

【核心实现思想】
- 初始化两个状态数组 `dpA` 和 `dpB`，分别表示当前元素选择 $ A $ 或 $ B $ 时是否满足条件。
- 遍历数组，根据前一个元素的状态更新当前元素的状态。
- 最终判断最后一个元素的状态是否满足条件，输出结果。

---
处理用时：28.55秒
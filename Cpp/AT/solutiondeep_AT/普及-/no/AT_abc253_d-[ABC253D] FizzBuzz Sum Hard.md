# 题目信息

# [ABC253D] FizzBuzz Sum Hard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc253/tasks/abc253_d

$ 1 $ 以上 $ N $ 以下の整数であって、$ A $ の倍数でも $ B $ の倍数でもないものの総和を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ A,B\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

$ 1 $ 以上 $ 10 $ 以下の整数で $ 3 $ の倍数でも $ 5 $ の倍数でもないのは $ 1,2,4,7,8 $ です。それらの総和は $ 1+2+4+7+8\ =22 $ です。

## 样例 #1

### 输入

```
10 3 5```

### 输出

```
22```

## 样例 #2

### 输入

```
1000000000 314 159```

### 输出

```
495273003954006262```

# AI分析结果

【题目内容】
# [ABC253D] FizzBuzz Sum Hard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc253/tasks/abc253_d

求 $1$ 以上 $N$ 以下的整数中，既不是 $A$ 的倍数也不是 $B$ 的倍数的所有整数的总和。

## 说明/提示

### 制約

- $1 \leq N, A, B \leq 10^9$
- 输入均为整数

### 样例解释 1

$1$ 以上 $10$ 以下的整数中，既不是 $3$ 的倍数也不是 $5$ 的倍数的数是 $1,2,4,7,8$。它们的总和是 $1+2+4+7+8 = 22$。

## 样例 #1

### 输入

```
10 3 5
```

### 输出

```
22
```

## 样例 #2

### 输入

```
1000000000 314 159
```

### 输出

```
495273003954006262
```

【算法分类】
数学

【综合分析与结论】
本题的核心在于如何高效计算 $1$ 到 $N$ 之间既不是 $A$ 的倍数也不是 $B$ 的倍数的数的总和。由于 $N$ 的范围可能很大（$10^9$），直接枚举会超时，因此需要利用数学方法进行优化。

【通用建议与扩展思路】
1. **数学公式**：利用容斥原理，计算 $1$ 到 $N$ 的总和，减去 $A$ 的倍数的总和，减去 $B$ 的倍数的总和，再加上 $A$ 和 $B$ 的最小公倍数的倍数的总和。
2. **优化计算**：使用等差数列求和公式来快速计算 $1$ 到 $N$ 的总和，以及 $A$、$B$ 和它们的最小公倍数的倍数的总和。
3. **边界处理**：注意 $N$ 的范围，避免溢出，确保计算结果正确。

【推荐题目】
1. [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001) - 基础数学题，适合练习数学公式的应用。
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002) - 动态规划与数学结合，适合练习数学思维。
3. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 数学与模拟结合，适合练习数学优化。

【关键思路或技巧】
1. **容斥原理**：通过减去 $A$ 和 $B$ 的倍数的总和，再加上它们的最小公倍数的倍数的总和，来得到最终结果。
2. **等差数列求和**：利用公式 $S = \frac{n(a_1 + a_n)}{2}$ 来快速计算 $1$ 到 $N$ 的总和，以及 $A$、$B$ 和它们的最小公倍数的倍数的总和。
3. **最小公倍数计算**：使用公式 $LCM(A, B) = \frac{A \times B}{GCD(A, B)}$ 来计算 $A$ 和 $B$ 的最小公倍数。

【核心代码片段】
```cpp
#include <bits/stdc++.h>
using namespace std;

long long sum(long long n) {
    return n * (n + 1) / 2;
}

long long lcm(long long a, long long b) {
    return a / __gcd(a, b) * b;
}

int main() {
    long long N, A, B;
    cin >> N >> A >> B;
    long long total = sum(N);
    long long sumA = A * sum(N / A);
    long long sumB = B * sum(N / B);
    long long sumLCM = lcm(A, B) * sum(N / lcm(A, B));
    long long result = total - sumA - sumB + sumLCM;
    cout << result << endl;
    return 0;
}
```

【代码实现技巧】
1. **函数封装**：将求和和最小公倍数的计算封装成函数，提高代码的可读性和复用性。
2. **使用内置函数**：利用 `__gcd` 函数快速计算最大公约数，进而计算最小公倍数。
3. **避免溢出**：在计算最小公倍数时，先进行除法运算再乘法，避免溢出。

---
处理用时：23.99秒
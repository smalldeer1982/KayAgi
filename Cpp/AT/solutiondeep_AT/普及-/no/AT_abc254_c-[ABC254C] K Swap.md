# 题目信息

# [ABC254C] K Swap

## 题目描述

## 题目翻译

给出一个长为 $n$ 的数列 $a_1, a_2, \cdots, a_n$。再给一个整数 $k$。

每次可以选一个下标 $i$（$1 \le i \le n - k$），将 $a_i$ 和 $a_{i + k}$ 交换。

问能否通过交换让数列 $a$ 成为升序（任意 $a_i \le a_{i  +1}$）？

translate by @[liangbowen](https://www.luogu.com.cn/user/367488)。

## 说明/提示

$2 \le n \le 2 \times 10^5$；$1 \le k \le n - 1$；$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
5 2

3 4 1 3 4```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5 3

3 4 1 3 4```

### 输出

```
No```

## 样例 #3

### 输入

```
7 5

1 2 3 4 5 5 10```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写

【题目描述】

给出一个长度为 $n$ 的数列 $a_1, a_2, \cdots, a_n$。再给出一个整数 $k$。

每次可以选择一个下标 $i$（$1 \le i \le n - k$），将 $a_i$ 和 $a_{i + k}$ 交换。

问能否通过交换让数列 $a$ 成为升序（即任意 $a_i \le a_{i +1}$）？

【说明/提示】

$2 \le n \le 2 \times 10^5$；$1 \le k \le n - 1$；$1 \le a_i \le 10^9$。

【样例 #1】

### 输入

```
5 2

3 4 1 3 4
```

### 输出

```
Yes
```

【样例 #2】

### 输入

```
5 3

3 4 1 3 4
```

### 输出

```
No
```

【样例 #3】

### 输入

```
7 5

1 2 3 4 5 5 10
```

### 输出

```
Yes
```

### 算法分类

排序

### 题解分析与结论

由于题目要求通过交换操作使数列升序，且每次交换只能交换相隔 $k$ 的元素，因此可以将数列分为 $k$ 个独立的子序列，每个子序列中的元素可以通过交换操作进行排序。最终，如果所有子序列排序后合并得到的数列是升序的，则输出 `Yes`，否则输出 `No`。

### 通用建议与扩展思路

1. **关键思路**：将数列分为 $k$ 个独立的子序列，每个子序列中的元素可以通过交换操作进行排序。最终检查所有子序列排序后合并的数列是否为升序。
2. **优化点**：由于 $n$ 的范围较大，需要确保排序操作的复杂度为 $O(n \log n)$。
3. **扩展思路**：类似的问题可以扩展到其他交换规则，如交换相邻元素、交换特定位置的元素等。

### 推荐题目

1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)

### 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    
    for (int i = 0; i < k; ++i) {
        vector<int> sub;
        for (int j = i; j < n; j += k) {
            sub.push_back(a[j]);
        }
        sort(sub.begin(), sub.end());
        int idx = 0;
        for (int j = i; j < n; j += k) {
            a[j] = sub[idx++];
        }
    }
    
    bool sorted = true;
    for (int i = 1; i < n; ++i) {
        if (a[i] < a[i - 1]) {
            sorted = false;
            break;
        }
    }
    
    cout << (sorted ? "Yes" : "No") << endl;
    return 0;
}
```

### 代码核心思想

1. **分组排序**：将数列分为 $k$ 个独立的子序列，每个子序列中的元素通过交换操作进行排序。
2. **合并检查**：将所有子序列排序后合并，检查最终的数列是否为升序。

### 个人心得

在处理类似问题时，关键在于如何将问题分解为独立的子问题。通过将数列分为 $k$ 个子序列，可以简化问题的复杂度，使得排序操作更加高效。此外，确保排序后的数列是升序的，可以通过简单的遍历检查来实现。

---
处理用时：24.64秒
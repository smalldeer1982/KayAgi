# 题目信息

# [ABC255B] Light It Up

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_b

$ xy $ 平面上に $ N $ 人の人 $ 1,2,\dots,N $ がおり、人 $ i $ は座標 $ (X_i,Y_i) $ にいます。  
 このうち、 $ K $ 人の人 $ A_1,A_2,\dots,A_K $ に同じ強さの明かりを持たせます。  
 座標 $ (x,y) $ にいる人が強さ $ R $ の明かりを持っている時、その明かりによって中心 $ (x,y) $ 、半径 $ R $ の円の内部全体(境界を含む)が照らされます。  
 すべての人が少なくとも $ 1 $ つの明かりによって照らされるために必要な明かりの強さの最小値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K\ <\ N\ \le\ 1000 $
- $ 1\ \le\ A_1\ <\ A_2\ <\ \dots\ <\ A_K\ \le\ N $
- $ |X_i|,|Y_i|\ \le\ 10^5 $
- $ i\ \neq\ j $ ならば $ (X_i,Y_i)\ \neq\ (X_j,Y_j) $

### Sample Explanation 1

この入力では人が $ 4 $ 人おり、そのうち人 $ 2,3 $ が明かりを持ちます。 $ R\ \ge\ \sqrt{5}\ \approx\ 2.236068 $ である時、すべての人が少なくとも $ 1 $ つの明かりによって照らされます。

## 样例 #1

### 输入

```
4 2

2 3

0 0

0 1

1 2

2 0```

### 输出

```
2.23606797749978969```

## 样例 #2

### 输入

```
2 1

2

-100000 -100000

100000 100000```

### 输出

```
282842.712474619009```

## 样例 #3

### 输入

```
8 3

2 6 8

-17683 17993

93038 47074

58079 -57520

-41515 -89802

-72739 68805

24324 -73073

71049 72103

47863 19268```

### 输出

```
130379.280458974768```

# AI分析结果

### 题目内容重写

在 $xy$ 平面上有 $N$ 个人，编号为 $1,2,\dots,N$，第 $i$ 个人位于坐标 $(X_i,Y_i)$。  
在这 $N$ 个人中，选择 $K$ 个人 $A_1,A_2,\dots,A_K$，给他们每人一个相同强度的光源。  
当位于 $(x,y)$ 的人拥有强度为 $R$ 的光源时，该光源会照亮以 $(x,y)$ 为中心、半径为 $R$ 的圆内的所有区域（包括边界）。  
求所有 $N$ 个人都至少被一个光源照亮时，所需的最小光源强度 $R$。

### 说明/提示

#### 约束条件

- 所有输入均为整数
- $1 \le K < N \le 1000$
- $1 \le A_1 < A_2 < \dots < A_K \le N$
- $|X_i|,|Y_i| \le 10^5$
- 如果 $i \neq j$，则 $(X_i,Y_i) \neq (X_j,Y_j)$

#### 样例解释 1

在这个输入中，共有 $4$ 个人，其中第 $2$ 和第 $3$ 个人拥有光源。当 $R \ge \sqrt{5} \approx 2.236068$ 时，所有 $4$ 个人都至少被一个光源照亮。

### 样例 #1

#### 输入

```
4 2

2 3

0 0

0 1

1 2

2 0
```

#### 输出

```
2.23606797749978969
```

### 样例 #2

#### 输入

```
2 1

2

-100000 -100000

100000 100000
```

#### 输出

```
282842.712474619009
```

### 样例 #3

#### 输入

```
8 3

2 6 8

-17683 17993

93038 47074

58079 -57520

-41515 -89802

-72739 68805

24324 -73073

71049 72103

47863 19268
```

#### 输出

```
130379.280458974768
```

### 算法分类

**二分**

### 题解分析与结论

由于题目要求找到最小的光源强度 $R$，使得所有 $N$ 个人都至少被一个光源照亮，因此可以使用**二分搜索**来确定 $R$ 的最小值。具体思路如下：

1. **二分搜索**：通过二分搜索在可能的 $R$ 范围内寻找最小值。$R$ 的范围可以从 $0$ 到最大可能距离（如 $10^5 \times \sqrt{2}$）。
2. **判断函数**：对于每个候选的 $R$，判断是否所有 $N$ 个人都被至少一个光源照亮。可以通过计算每个人到所有光源的距离，判断是否在 $R$ 范围内。
3. **优化**：由于 $N$ 和 $K$ 的最大值为 $1000$，直接暴力计算每个人到所有光源的距离是可行的。

### 关键思路与技巧

- **二分搜索**：通过二分搜索快速缩小 $R$ 的范围，减少计算量。
- **距离计算**：使用欧几里得距离公式计算每个人到光源的距离，判断是否在 $R$ 范围内。
- **边界处理**：注意浮点数精度问题，确保二分搜索的终止条件合理。

### 推荐题目

1. **P2249 【深基13.例1】查找** - 考察二分搜索的基本应用。
2. **P3382 【模板】三分法** - 考察三分搜索的应用，与二分搜索类似。
3. **P1908 逆序对** - 考察分治与二分思想的结合。

### 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const double eps = 1e-9;

double dist(double x1, double y1, double x2, double y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

bool check(double R, vector<pair<int, int>>& people, vector<int>& lights) {
    for (auto& p : people) {
        bool covered = false;
        for (auto& l : lights) {
            if (dist(p.first, p.second, people[l].first, people[l].second) <= R + eps) {
                covered = true;
                break;
            }
        }
        if (!covered) return false;
    }
    return true;
}

double findMinR(vector<pair<int, int>>& people, vector<int>& lights) {
    double left = 0, right = 1e6;
    while (right - left > eps) {
        double mid = (left + right) / 2;
        if (check(mid, people, lights)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    return left;
}

int main() {
    int N, K;
    cin >> N >> K;
    vector<int> lights(K);
    for (int i = 0; i < K; ++i) {
        cin >> lights[i];
        lights[i]--;
    }
    vector<pair<int, int>> people(N);
    for (int i = 0; i < N; ++i) {
        cin >> people[i].first >> people[i].second;
    }
    double R = findMinR(people, lights);
    printf("%.15lf\n", R);
    return 0;
}
```

### 代码说明

- **dist函数**：计算两点之间的欧几里得距离。
- **check函数**：判断当前 $R$ 是否满足所有 $N$ 个人都被至少一个光源照亮。
- **findMinR函数**：通过二分搜索找到最小的 $R$。
- **主函数**：读取输入数据，调用 `findMinR` 函数并输出结果。

---
处理用时：38.26秒
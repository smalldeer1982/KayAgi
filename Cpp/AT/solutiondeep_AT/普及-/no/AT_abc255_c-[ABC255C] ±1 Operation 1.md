# 题目信息

# [ABC255C] ±1 Operation 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_c

整数 $ X $ が与えられます。この $ X $ に以下を施すことを「操作」と呼びます。

- 以下の $ 2 $ つのうちどちらかを選択し、実行する。
  - $ X $ に $ 1 $ を加算する。
  - $ X $ から $ 1 $ を減算する。

初項 $ A $ 、公差 $ D $ 、項数 $ N $ の等差数列 $ S $ に含まれる数を「良い数」と呼びます。  
 「操作」を $ 0 $ 回以上何度でも使って $ X $ を「良い数」にする時、必要な「操作」の最小回数を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ -10^{18}\ \le\ X,A\ \le\ 10^{18} $
- $ -10^6\ \le\ D\ \le\ 10^6 $
- $ 1\ \le\ N\ \le\ 10^{12} $

### Sample Explanation 1

$ A=2,D=3,N=3 $ であるため、 $ S=(2,5,8) $ です。 $ X=6 $ を「良い数」にするためには、 $ X $ から $ 1 $ を減算することを $ 1 $ 度行えば良いです。 $ 0 $ 回の操作で $ X $ を「良い数」にすることはできません。

### Sample Explanation 2

$ D=0 $ である場合もあります。また、操作を $ 1 $ 回も必要としない場合もあります。

## 样例 #1

### 输入

```
6 2 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
0 0 0 1```

### 输出

```
0```

## 样例 #3

### 输入

```
998244353 -10 -20 30```

### 输出

```
998244363```

## 样例 #4

### 输入

```
-555555555555555555 -1000000000000000000 1000000 1000000000000```

### 输出

```
444445```

# AI分析结果

### 题目内容重写

给定一个整数 $X$。对 $X$ 进行以下操作：

- 选择以下两种操作之一并执行：
  - 将 $X$ 加 1。
  - 将 $X$ 减 1。

定义一个等差数列 $S$，其初项为 $A$，公差为 $D$，项数为 $N$。将 $S$ 中的数称为“好数”。通过上述操作（可以执行多次），将 $X$ 变为“好数”时，求所需的最小操作次数。

### 算法分类

数学

### 题解分析与结论

由于题目要求将 $X$ 变为等差数列 $S$ 中的某个数，且操作只能加 1 或减 1，因此问题可以转化为在等差数列 $S$ 中找到与 $X$ 最接近的数，然后计算 $X$ 与该数的差值。

等差数列 $S$ 的第 $k$ 项为 $A + (k-1)D$，其中 $1 \leq k \leq N$。我们需要找到 $k$ 使得 $|X - (A + (k-1)D)|$ 最小。

由于 $N$ 可能很大（$1 \leq N \leq 10^{12}$），直接遍历所有 $k$ 是不可行的。因此，我们可以通过数学方法找到最接近 $X$ 的项。

具体步骤如下：

1. 计算等差数列中的最小值和最大值。
2. 如果 $X$ 小于最小值，则最接近的数为最小值。
3. 如果 $X$ 大于最大值，则最接近的数为最大值。
4. 否则，计算 $X$ 在等差数列中的位置 $k$，然后比较 $k$ 和 $k+1$ 对应的项，找到最接近的项。

### 关键思路与技巧

1. **等差数列的性质**：利用等差数列的通项公式 $A + (k-1)D$ 来快速计算任意项的值。
2. **二分查找**：通过二分查找来快速定位 $X$ 在等差数列中的位置，避免遍历所有项。
3. **边界处理**：处理 $X$ 小于最小值或大于最大值的情况，确保算法的鲁棒性。

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 考察二分查找与贪心算法。
2. [P1045 数的划分](https://www.luogu.com.cn/problem/P1045) - 考察数学与递推思想。
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059) - 考察排序与去重。

### 核心代码实现

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

long long findMinOperations(long long X, long long A, long long D, long long N) {
    if (D == 0) {
        return abs(X - A);
    }
    long long first = A;
    long long last = A + (N - 1) * D;
    if (D < 0) {
        swap(first, last);
        D = -D;
    }
    if (X <= first) {
        return abs(X - first);
    }
    if (X >= last) {
        return abs(X - last);
    }
    long long k = (X - A) / D + 1;
    long long candidate1 = A + (k - 1) * D;
    long long candidate2 = A + k * D;
    return min(abs(X - candidate1), abs(X - candidate2));
}

int main() {
    long long X, A, D, N;
    cin >> X >> A >> D >> N;
    cout << findMinOperations(X, A, D, N) << endl;
    return 0;
}
```

### 代码说明

1. **边界处理**：首先处理 $D = 0$ 的情况，此时等差数列所有项都等于 $A$，直接返回 $|X - A|$。
2. **等差数列的范围**：计算等差数列的最小值和最大值，并根据 $D$ 的符号调整顺序。
3. **位置计算**：通过 $(X - A) / D + 1$ 计算 $X$ 在等差数列中的位置 $k$。
4. **候选数比较**：比较 $k$ 和 $k+1$ 对应的项，找到最接近 $X$ 的数，并返回最小操作次数。

### 总结

本题的核心在于利用等差数列的性质和二分查找的思想，快速找到与 $X$ 最接近的“好数”，从而计算最小操作次数。通过数学方法优化了时间复杂度，避免了不必要的遍历。

---
处理用时：25.91秒
# 题目信息

# [ABC256D] Union of Interval

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc256/tasks/abc256_d

実数 $ L,R $ に対して、$ L $ 以上 $ R $ 未満からなる実数の集合を $ [L,R) $ と表します。このような形で表される集合を右半開区間といいます。

$ N $ 個の右半開区間 $ [L_i,R_i) $ が与えられます。これらの和集合を $ S $ とします。$ S $ を最小の個数の右半開区間の和集合として表してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ L_i\ \lt\ R_i\ \leq\ 2\times\ 10^5 $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

$ 3 $ つの右半開区間 $ [10,20),[20,30),[40,50) $ の和集合は $ 2 $ つの右半開区間 $ [10,30),[40,50) $ の和集合と等しくなります。

### Sample Explanation 2

$ 3 $ つの右半開区間 $ [10,40),[30,60),[20,50) $ の和集合は $ 1 $ つの右半開区間 $ [10,60) $ と等しくなります。

## 样例 #1

### 输入

```
3

10 20

20 30

40 50```

### 输出

```
10 30

40 50```

## 样例 #2

### 输入

```
3

10 40

30 60

20 50```

### 输出

```
10 60```

# AI分析结果

### 题目内容

#### [ABC256D] 区间的并集

**题目描述**

对于实数 $ L,R $，我们将由 $ L $ 以上 $ R $ 未满的实数组成的集合表示为 $ [L,R) $。这种形式的集合称为右半开区间。

给定 $ N $ 个右半开区间 $ [L_i,R_i) $，它们的并集为 $ S $。请将 $ S $ 表示为最小数量的右半开区间的并集。

**说明/提示**

**约束条件**

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ L_i\ \lt\ R_i\ \leq\ 2\times\ 10^5 $
- 输入中的所有值都是整数

**样例解释 1**

$ 3 $ 个右半开区间 $ [10,20),[20,30),[40,50) $ 的并集等于 $ 2 $ 个右半开区间 $ [10,30),[40,50) $ 的并集。

**样例解释 2**

$ 3 $ 个右半开区间 $ [10,40),[30,60),[20,50) $ 的并集等于 $ 1 $ 个右半开区间 $ [10,60) $。

**样例 #1**

**输入**

```
3

10 20

20 30

40 50
```

**输出**

```
10 30

40 50
```

**样例 #2**

**输入**

```
3

10 40

30 60

20 50
```

**输出**

```
10 60
```

### 算法分类

贪心、排序

### 综合分析与结论

本题的核心问题是将多个右半开区间的并集表示为最小数量的右半开区间。解决这个问题的关键在于如何有效地合并重叠或相邻的区间。通常，我们可以通过以下步骤来解决这个问题：

1. **排序**：首先将所有区间按照左端点进行排序。
2. **合并**：遍历排序后的区间，逐个检查当前区间是否与上一个区间重叠或相邻。如果是，则合并它们；否则，将上一个区间加入结果集，并继续处理下一个区间。

这种方法的时间复杂度主要由排序决定，为 $O(N \log N)$，能够很好地处理题目中的约束条件。

### 题解

由于目前没有具体的题解，以下是一个通用的解题思路和代码实现：

#### 关键思路

1. **排序**：将所有区间按照左端点进行升序排序。
2. **合并**：使用一个临时区间来记录当前合并后的区间，遍历所有区间，逐个检查是否需要合并。

#### 核心代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int N;
    cin >> N;
    vector<pair<int, int>> intervals(N);
    for (int i = 0; i < N; ++i) {
        cin >> intervals[i].first >> intervals[i].second;
    }
    
    // 按照左端点排序
    sort(intervals.begin(), intervals.end());
    
    vector<pair<int, int>> merged;
    int start = intervals[0].first, end = intervals[0].second;
    
    for (int i = 1; i < N; ++i) {
        if (intervals[i].first <= end) {
            // 合并区间
            end = max(end, intervals[i].second);
        } else {
            // 当前区间与上一个不重叠，加入结果集
            merged.push_back({start, end});
            start = intervals[i].first;
            end = intervals[i].second;
        }
    }
    // 加入最后一个区间
    merged.push_back({start, end});
    
    // 输出结果
    for (const auto& interval : merged) {
        cout << interval.first << " " << interval.second << endl;
    }
    
    return 0;
}
```

### 扩展思路

类似的问题在区间合并、区间调度等领域中非常常见。例如，给定一组区间，要求找出最大不重叠区间的数量，或者找出覆盖某个范围的最小区间数量等。这些问题都可以通过类似的排序和贪心策略来解决。

### 推荐题目

1. [P1884 区间覆盖](https://www.luogu.com.cn/problem/P1884)
2. [P1255 数区间](https://www.luogu.com.cn/problem/P1255)
3. [P1223 区间调度](https://www.luogu.com.cn/problem/P1223)

这些题目都涉及到区间的合并或调度，可以通过类似的思路来解决。

---
处理用时：28.60秒
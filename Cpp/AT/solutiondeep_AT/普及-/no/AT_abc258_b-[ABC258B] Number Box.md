# 题目信息

# [ABC258B] Number Box

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc258/tasks/abc258_b

正整数 $ N $ が与えられます。

$ N $ 行 $ N $ 列のマス目があり、上から $ i $ 行目、左から $ j $ 列目のマスには数字 $ A_{i,j} $ が書かれています。

このマス目は上下および左右がつながっているものとします。つまり以下が全て成り立ちます。

- $ (1,i) $ の上のマスは $ (N,i) $ であり、$ (N,i) $ の下のマスは $ (1,i) $ である。$ (1\le\ i\le\ N) $
- $ (i,1) $ の左のマスは $ (i,N) $ であり、$ (i,N) $ の右のマスは $ (i,1) $ である。$ (1\le\ i\le\ N) $

高橋君は、上下左右および斜めの $ 8 $ 方向のうちいずれかを初めに選びます。そして、好きなマスから決めた方向に $ 1 $ マス移動することを $ N-1 $ 回繰り返します。

高橋君は $ N $ 個のマス上を移動することになりますが、高橋君が通ったマスに書かれている数字を左から通った順番に並べた整数としてあり得る最大のものを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 10 $
- $ 1\ \le\ A_{i,j}\ \le\ 9 $
- 入力はすべて整数。

### Sample Explanation 1

高橋君が上から $ 2 $ 行目、左から $ 4 $ 列目のマスから出発し、右下に進むことで、通ったマスに書かれた数字を並べ $ 9786 $ を作ることができます。 $ 9786 $ より大きい値を作ることはできないため、$ 9786 $ が解です。

### Sample Explanation 2

32bit整数型に答えが収まるとは限らないことに注意してください。

## 样例 #1

### 输入

```
4
1161
1119
7111
1811```

### 输出

```
9786```

## 样例 #2

### 输入

```
10
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111```

### 输出

```
1111111111```

# AI分析结果

### 中文题目重写

# [ABC258B] Number Box

## 题目描述

给定一个正整数 $ N $。

有一个 $ N $ 行 $ N $ 列的网格，从上到下第 $ i $ 行、从左到右第 $ j $ 列的格子中写有数字 $ A_{i,j} $。

这个网格的上下和左右是相连的。也就是说，以下条件均成立：

- $ (1,i) $ 的上方格子是 $ (N,i) $，而 $ (N,i) $ 的下方格子是 $ (1,i) $。$ (1\le\ i\le\ N) $
- $ (i,1) $ 的左侧格子是 $ (i,N) $，而 $ (i,N) $ 的右侧格子是 $ (i,1) $。$ (1\le\ i\le\ N) $

高桥君首先选择上下左右或斜向的 $ 8 $ 个方向中的一个。然后，他从任意一个格子出发，按照选定的方向移动 $ N-1 $ 次，每次移动一格。

高桥君将经过 $ N $ 个格子，将他经过的格子中的数字按顺序排列成一个整数。请找出这个整数可能的最大值。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 10 $
- $ 1\ \le\ A_{i,j}\ \le\ 9 $
- 输入均为整数。

### 样例解释 1

高桥君从第 $ 2 $ 行、第 $ 4 $ 列的格子出发，向右下方向移动，经过的格子中的数字排列成 $ 9786 $。无法得到比 $ 9786 $ 更大的值，因此 $ 9786 $ 是答案。

### 样例解释 2

注意答案可能超出32位整数范围。

## 样例 #1

### 输入

```
4
1161
1119
7111
1811```

### 输出

```
9786```

## 样例 #2

### 输入

```
10
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111```

### 输出

```
1111111111```

### 算法分类

枚举

### 题解分析与结论

本题的核心在于枚举所有可能的路径，并找到其中数字排列最大的整数。由于网格的尺寸较小（$ N \leq 10 $），可以通过枚举所有可能的起点和方向来解决问题。

### 通用建议与扩展思路

1. **枚举所有起点和方向**：由于网格尺寸较小，可以直接枚举所有起点和8个可能的方向，然后模拟移动过程，记录路径中的数字排列。
2. **处理边界条件**：由于网格是循环的，需要注意移动时超出边界的情况，通过取模运算来处理。
3. **优化比较过程**：在模拟过程中，可以直接将路径中的数字拼接成整数，并与当前最大值进行比较。

### 关键代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<string> grid(N);
    for (int i = 0; i < N; ++i) {
        cin >> grid[i];
    }

    int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
    int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};

    long long max_num = 0;

    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            for (int d = 0; d < 8; ++d) {
                long long num = 0;
                int x = i, y = j;
                for (int k = 0; k < N; ++k) {
                    num = num * 10 + (grid[x][y] - '0');
                    x = (x + dx[d] + N) % N;
                    y = (y + dy[d] + N) % N;
                }
                if (num > max_num) {
                    max_num = num;
                }
            }
        }
    }

    cout << max_num << endl;
    return 0;
}
```

### 关键思路总结

- **枚举所有可能的起点和方向**：通过三重循环枚举所有起点和8个方向，确保覆盖所有可能的路径。
- **模拟移动过程**：在模拟过程中，使用取模运算处理边界条件，确保移动时不会超出网格范围。
- **比较并更新最大值**：在模拟过程中，将路径中的数字拼接成整数，并与当前最大值进行比较，更新最大值。

### 推荐题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 枚举与回溯的结合。
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 枚举与组合的应用。
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 搜索与模拟的结合。

这些题目都涉及到枚举和模拟的思路，与本题的解题方法有相似之处，适合进一步练习和巩固。

---
处理用时：31.55秒
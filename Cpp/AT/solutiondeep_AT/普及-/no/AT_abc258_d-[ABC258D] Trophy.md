# 题目信息

# [ABC258D] Trophy

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc258/tasks/abc258_d

$ N $ 個のステージからなるゲームがあり、$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 番目のステージは $ A_i $ 分間のストーリー映像と $ B_i $ 分間のゲームプレイによって構成されます。

初めて $ i $ 番目のステージをクリアするためにはストーリー映像の視聴とゲームプレイを両方行う必要がありますが、二回目以降はストーリー映像をスキップすることができるので、ゲームプレイのみでクリアすることができます。

初めから遊べるのは $ 1 $ 番目のステージのみですが、$ i\ \,\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ 番目のステージをクリアすることにより、$ i+1 $ 番目のステージも遊べるようになります。

合計 $ X $ 回ステージをクリアするために必要な時間の最小値を求めてください。ただし、同じステージを複数回クリアしたとしても、全てクリア回数に数えられます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9\ \,\ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ X\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

例えば、次のようにして $ 18 $ 分で $ 4 $ 回クリアすることができます。 - ステージ $ 1 $ をクリアする。$ A_1\ +\ B_1\ =\ 7 $ 分かかる。 - ステージ $ 2 $ をクリアする。$ A_2\ +\ B_2\ =\ 5 $ 分かかる。 - ステージ $ 2 $ を再びクリアする。$ B_2\ =\ 3 $ 分かかる。 - ステージ $ 2 $ を再びクリアする。$ B_2\ =\ 3 $ 分かかる。 $ 17 $ 分以内に $ 4 $ 回クリアすることはできません。

## 样例 #1

### 输入

```
3 4

3 4

2 3

4 2```

### 输出

```
18```

## 样例 #2

### 输入

```
10 1000000000

3 3

1 6

4 7

1 8

5 7

9 9

2 4

6 4

5 1

3 1```

### 输出

```
1000000076```

# AI分析结果

### 题目内容重写

**题目描述**

有 $N$ 个关卡的游戏，第 $i$ 个关卡（$1 \leq i \leq N$）由 $A_i$ 分钟的剧情视频和 $B_i$ 分钟的游戏玩法组成。

首次通过第 $i$ 个关卡时，必须观看剧情视频并进行游戏玩法，但第二次及以后可以通过跳过剧情视频，仅进行游戏玩法来通过关卡。

最初只能玩第 1 个关卡，但通过第 $i$ 个关卡（$1 \leq i \leq N - 1$）后，可以解锁第 $i+1$ 个关卡。

求总共通过 $X$ 次关卡所需的最少时间。注意，即使多次通过同一个关卡，每次通过都会计入总次数。

**说明/提示**

**约束条件**

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq A_i, B_i \leq 10^9$（$1 \leq i \leq N$）
- $1 \leq X \leq 10^9$
- 输入均为整数

**样例解释 1**

例如，可以通过以下方式在 18 分钟内通过 4 次关卡：
- 通过第 1 个关卡。花费 $A_1 + B_1 = 7$ 分钟。
- 通过第 2 个关卡。花费 $A_2 + B_2 = 5$ 分钟。
- 再次通过第 2 个关卡。花费 $B_2 = 3$ 分钟。
- 再次通过第 2 个关卡。花费 $B_2 = 3$ 分钟。
无法在 17 分钟内通过 4 次关卡。

**样例 #1**

**输入**

```
3 4

3 4

2 3

4 2
```

**输出**

```
18
```

**样例 #2**

**输入**

```
10 1000000000

3 3

1 6

4 7

1 8

5 7

9 9

2 4

6 4

5 1

3 1
```

**输出**

```
1000000076
```

### 算法分类

贪心

### 题解分析与结论

由于题目要求通过 $X$ 次关卡所需的最少时间，且每次通过关卡的时间取决于是否首次通过，因此可以采用贪心策略。具体思路如下：

1. **首次通过**：首次通过第 $i$ 个关卡需要 $A_i + B_i$ 分钟。
2. **后续通过**：后续通过第 $i$ 个关卡仅需要 $B_i$ 分钟。

为了最小化总时间，应该尽可能多地重复通过某个关卡，因为后续通过的时间更短。因此，可以通过以下步骤求解：

1. **计算前 $k$ 个关卡的首次通过总时间**：即 $\sum_{i=1}^{k} (A_i + B_i)$。
2. **计算通过第 $k$ 个关卡 $X - k$ 次的总时间**：即 $(X - k) \times B_k$。
3. **遍历所有可能的 $k$**，找到最小的总时间。

### 关键思路与技巧

- **贪心策略**：通过尽可能多地重复通过某个关卡来减少总时间。
- **前缀和优化**：使用前缀和快速计算前 $k$ 个关卡的首次通过总时间。
- **遍历优化**：由于 $N$ 和 $X$ 可能很大，需要确保算法的时间复杂度为 $O(N)$。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    int N, X;
    cin >> N >> X;
    vector<ll> A(N), B(N);
    for (int i = 0; i < N; ++i) cin >> A[i] >> B[i];
    
    vector<ll> prefix(N + 1, 0);
    for (int i = 0; i < N; ++i) prefix[i + 1] = prefix[i] + A[i] + B[i];
    
    ll ans = LLONG_MAX;
    for (int k = 1; k <= N; ++k) {
        if (k > X) break;
        ll total = prefix[k] + (X - k) * B[k - 1];
        ans = min(ans, total);
    }
    
    cout << ans << endl;
    return 0;
}
```

### 代码核心思想

1. **前缀和计算**：`prefix` 数组存储前 $k$ 个关卡的首次通过总时间。
2. **遍历 $k$**：对于每个可能的 $k$，计算通过前 $k$ 个关卡的总时间加上通过第 $k$ 个关卡 $X - k$ 次的时间。
3. **取最小值**：遍历所有 $k$，找到最小的总时间。

### 个人心得

- **调试经历**：在实现前缀和时，需要注意数组的索引从 0 开始还是从 1 开始，以避免越界错误。
- **优化思考**：通过贪心策略和前缀和优化，可以将时间复杂度降低到 $O(N)$，适合处理大规模数据。

---
处理用时：30.10秒
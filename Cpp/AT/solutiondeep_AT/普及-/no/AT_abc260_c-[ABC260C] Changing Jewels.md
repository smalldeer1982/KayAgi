# 题目信息

# [ABC260C] Changing Jewels

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc260/tasks/abc260_c

高橋君はレベル $ N $ の赤い宝石を $ 1 $ 個持っています。(他に宝石は持っていません。)   
 高橋君は次の操作を好きなだけ行うことができます。

- レベル $ n $ の赤い宝石 ($ n $ は $ 2 $ 以上) を「レベル $ n-1 $ の赤い宝石 $ 1 $ 個と、レベル $ n $ の青い宝石 $ X $ 個」に変換する。
- レベル $ n $ の青い宝石 ($ n $ は $ 2 $ 以上) を「レベル $ n-1 $ の赤い宝石 $ 1 $ 個と、レベル $ n-1 $ の青い宝石 $ Y $ 個」に変換する。

高橋君はレベル $ 1 $ の青い宝石ができるだけたくさんほしいです。操作によって高橋君はレベル $ 1 $ の青い宝石を最大何個入手できますか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10 $
- $ 1\ \leq\ X\ \leq\ 5 $
- $ 1\ \leq\ Y\ \leq\ 5 $
- 入力される値はすべて整数

### Sample Explanation 1

次のような変換を行うことで、高橋君はレベル $ 1 $ の青い宝石を $ 12 $ 個手に入れることができます。 - まず、レベル $ 2 $ の赤い宝石 $ 1 $ 個を、レベル $ 1 $ の赤い宝石 $ 1 $ 個とレベル $ 2 $ の青い宝石 $ 3 $ 個に変換します。 - 操作後の高橋君は、レベル $ 1 $ の赤い宝石 $ 1 $ 個とレベル $ 2 $ の青い宝石 $ 3 $ 個を持っています。 - 次に、レベル $ 2 $ の青い宝石 $ 1 $ 個を、レベル $ 1 $ の赤い宝石 $ 1 $ 個とレベル $ 1 $ の青い宝石 $ 4 $ 個に変換します。この変換を $ 3 $ 回繰り返します。 - 操作後の高橋君は、レベル $ 1 $ の赤い宝石 $ 4 $ 個とレベル $ 1 $ の青い宝石 $ 12 $ 個を持っています。 - これ以上変換を行うことはできません。 $ 12 $ 個より多くレベル $ 1 $ の青い宝石を手に入れることはできないので、答えは $ 12 $ になります。

### Sample Explanation 2

高橋君がレベル $ 1 $ の青い宝石を $ 1 $ 個も手に入れられない場合もあります。

### Sample Explanation 3

答えが $ 32 $ bit 整数に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
2 3 4```

### 输出

```
12```

## 样例 #2

### 输入

```
1 5 5```

### 输出

```
0```

## 样例 #3

### 输入

```
10 5 5```

### 输出

```
3942349900```

# AI分析结果

### 题目内容重写

高橋君有一个等级为 $N$ 的红色宝石。（他没有其他宝石。）  
高橋君可以执行以下操作任意次数：

- 将一个等级为 $n$ 的红色宝石（$n$ 大于等于 2）转换为“一个等级为 $n-1$ 的红色宝石和 $X$ 个等级为 $n$ 的蓝色宝石”。
- 将一个等级为 $n$ 的蓝色宝石（$n$ 大于等于 2）转换为“一个等级为 $n-1$ 的红色宝石和 $Y$ 个等级为 $n-1$ 的蓝色宝石”。

高橋君希望尽可能多地获得等级为 1 的蓝色宝石。通过操作，高橋君最多可以获得多少个等级为 1 的蓝色宝石？

### 算法分类
动态规划

### 分析与结论
该题的核心是通过递归或动态规划的方式，计算从高等级宝石逐步转换到低等级宝石的过程中，能够获得的最大等级为 1 的蓝色宝石数量。由于题目中的操作具有明确的递推关系，且每一步的选择都会影响最终结果，因此动态规划是解决该问题的最佳选择。

### 通用建议与扩展思路
1. **动态规划**：使用动态规划来记录每个等级的红宝石和蓝宝石能够转换出的等级为 1 的蓝宝石数量。通过递推公式，从高等级向低等级逐步计算。
2. **递归优化**：如果使用递归，可以考虑记忆化搜索来避免重复计算，提高效率。
3. **边界条件**：注意处理等级为 1 的宝石，因为它们无法再进行转换。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 动态规划经典问题，与本题的递推思路相似。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 动态规划问题，涉及资源的最优分配。
3. [P1216 [USACO1.5]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216) - 动态规划问题，涉及路径选择的最优化。

### 关键思路与技巧
1. **递推公式**：通过定义 `dp_red[n]` 和 `dp_blue[n]` 分别表示等级为 `n` 的红宝石和蓝宝石能够转换出的等级为 1 的蓝宝石数量，然后根据题目中的操作规则，建立递推关系。
2. **记忆化搜索**：在递归实现中，使用记忆化来存储已经计算过的结果，避免重复计算，提高效率。

### 核心代码片段
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll dp_red[11], dp_blue[11];
int N, X, Y;

ll dfs_red(int n);
ll dfs_blue(int n);

ll dfs_red(int n) {
    if (n == 1) return 0;
    if (dp_red[n] != -1) return dp_red[n];
    return dp_red[n] = dfs_red(n-1) + X * dfs_blue(n);
}

ll dfs_blue(int n) {
    if (n == 1) return 1;
    if (dp_blue[n] != -1) return dp_blue[n];
    return dp_blue[n] = dfs_red(n-1) + Y * dfs_blue(n-1);
}

int main() {
    cin >> N >> X >> Y;
    memset(dp_red, -1, sizeof(dp_red));
    memset(dp_blue, -1, sizeof(dp_blue));
    cout << dfs_red(N) << endl;
    return 0;
}
```

### 代码实现思想
1. **初始化**：使用 `dp_red` 和 `dp_blue` 数组来存储每个等级的红宝石和蓝宝石能够转换出的等级为 1 的蓝宝石数量，初始值为 -1 表示未计算。
2. **递归函数**：`dfs_red` 和 `dfs_blue` 分别计算红宝石和蓝宝石的转换结果，通过递归调用并利用记忆化避免重复计算。
3. **边界条件**：当等级为 1 时，红宝石无法转换，蓝宝石直接返回 1。
4. **输出结果**：调用 `dfs_red(N)` 计算并输出最终结果。

---
处理用时：24.54秒
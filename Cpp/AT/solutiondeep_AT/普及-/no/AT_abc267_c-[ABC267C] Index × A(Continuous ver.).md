# 题目信息

# [ABC267C] Index × A(Continuous ver.)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc267/tasks/abc267_c

長さ $ N $ の整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。

長さ $ M $ の $ A $ の連続部分列 $ B=(B_1,B_2,\dots,B_M) $ に対する、$ \displaystyle\ \sum_{i=1}^{M}\ i\ \times\ B_i $ の最大値を求めてください。

## 说明/提示

### 注記

数列の**連続部分列**とは、数列の先頭から $ 0 $ 個以上、末尾から $ 0 $ 個以上の要素を削除して得られる列のことをいいます。

例えば $ (2,\ 3) $ や $ (1,\ 2,\ 3) $ は $ (1,\ 2,\ 3,\ 4) $ の連続部分列ですが、$ (1,\ 3) $ や $ (3,2,1) $ は $ (1,\ 2,\ 3,\ 4) $ の連続部分列ではありません。

### 制約

- $ 1\ \le\ M\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ -\ 2\ \times\ 10^5\ \le\ A_i\ \le\ 2\ \times\ 10^5 $
- 入力は全て整数。

### Sample Explanation 1

$ B=(A_3,A_4) $ とした場合、$ \displaystyle\ \sum_{i=1}^{M}\ i\ \times\ B_i\ =\ 1\ \times\ (-1)\ +\ 2\ \times\ 8\ =\ 15 $ となります。$ 16 $ 以上の値を達成することはできないため、解は $ 15 $ です。 $ B=(A_1,A_4) $ などを選ぶことができないことに注意してください。

## 样例 #1

### 输入

```
4 2

5 4 -1 8```

### 输出

```
15```

## 样例 #2

### 输入

```
10 4

-3 1 -4 1 -5 9 -2 6 -5 3```

### 输出

```
31```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$。

求长度为 $M$ 的 $A$ 的连续子序列 $B=(B_1,B_2,\dots,B_M)$ 的最大值，其中最大值定义为 $ \displaystyle\ \sum_{i=1}^{M}\ i\ \times\ B_i $。

**说明/提示**

**注记**

数列的**连续子序列**是指从数列的开头删除 $0$ 个或多个元素，从末尾删除 $0$ 个或多个元素后得到的序列。

例如，$(2,\ 3)$ 和 $(1,\ 2,\ 3)$ 是 $(1,\ 2,\ 3,\ 4)$ 的连续子序列，但 $(1,\ 3)$ 和 $(3,2,1)$ 不是。

**约束条件**

- $1 \le M \le N \le 2 \times 10^5$
- $-2 \times 10^5 \le A_i \le 2 \times 10^5$
- 输入均为整数。

**样例解释 1**

当 $B=(A_3,A_4)$ 时，$ \displaystyle\ \sum_{i=1}^{M}\ i\ \times\ B_i\ =\ 1\ \times\ (-1)\ +\ 2\ \times\ 8\ =\ 15 $。由于无法得到比 $15$ 更大的值，因此答案为 $15$。注意不能选择 $B=(A_1,A_4)$ 等非连续子序列。

**样例 #1**

**输入**

```
4 2

5 4 -1 8
```

**输出**

```
15
```

**样例 #2**

**输入**

```
10 4

-3 1 -4 1 -5 9 -2 6 -5 3
```

**输出**

```
31
```

### 算法分类

**前缀和**

### 题解分析与结论

由于题目要求的是连续子序列的最大值，且需要计算加权和，因此可以使用前缀和来优化计算过程。具体来说，可以通过维护一个滑动窗口来计算每个可能的连续子序列的加权和，并记录最大值。

### 关键思路与技巧

1. **前缀和优化**：通过预处理前缀和数组，可以快速计算任意子序列的和。
2. **滑动窗口**：利用滑动窗口的思想，减少重复计算，提高效率。
3. **加权和计算**：通过调整加权系数，计算每个子序列的加权和。

### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1719 最大加权子段和](https://www.luogu.com.cn/problem/P1719)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    vector<int> A(N);
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
    }
    
    vector<long long> prefixSum(N + 1, 0);
    for (int i = 0; i < N; ++i) {
        prefixSum[i + 1] = prefixSum[i] + A[i];
    }
    
    long long maxSum = LLONG_MIN;
    for (int i = 0; i <= N - M; ++i) {
        long long currentSum = 0;
        for (int j = 0; j < M; ++j) {
            currentSum += (j + 1) * A[i + j];
        }
        if (currentSum > maxSum) {
            maxSum = currentSum;
        }
    }
    
    cout << maxSum << endl;
    return 0;
}
```

**核心实现思想**：
- 首先计算前缀和数组 `prefixSum`，用于快速计算任意子序列的和。
- 然后使用滑动窗口的方法，遍历所有可能的连续子序列，计算其加权和，并记录最大值。

### 总结

通过前缀和和滑动窗口的结合，可以高效地解决该问题。这种方法在类似的子序列求和问题中也非常常见，值得掌握。

---
处理用时：23.58秒
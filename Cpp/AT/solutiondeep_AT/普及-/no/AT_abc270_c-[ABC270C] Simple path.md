# 题目信息

# [ABC270C] Simple path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc270/tasks/abc270_c

$ N $ 頂点の木 $ T $ があり、 $ i $ $ (1\leq\ i\leq\ N-1) $ 番目の辺は頂点 $ U_i $ と頂点 $ V_i $ を結んでいます。

$ T $ 上の相異なる $ 2 $ 頂点 $ X,Y $ が与えられるので、 頂点 $ X $ から頂点 $ Y $ への単純パス上の頂点（端点含む）を順に列挙してください。

ただし、木上の任意の相異なる $ 2 $ 頂点 $ a,b $ について、$ a $ から $ b $ への単純パスがただ一つ存在することが証明できます。

単純パスとは？グラフ $ G $ 上の頂点 $ X,Y $ に対して、頂点列 $ v_1,v_2,\ \ldots,\ v_k $ であって、 $ v_1=X $, $ v_k=Y $ かつ、$ 1\leq\ i\leq\ k-1 $ に対して $ v_i $ と $ v_{i+1} $ が辺で結ばれているようなものを頂点 $ X $ から頂点 $ Y $ への **パス** と呼びます。 さらに、$ v_1,v_2,\ \ldots,\ v_k $ がすべて異なるようなものを頂点 $ X $ から頂点 $ Y $ への **単純パス** と呼びます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ X,Y\leq\ N $
- $ X\neq\ Y $
- $ 1\leq\ U_i,V_i\leq\ N $
- 入力はすべて整数
- 与えられるグラフは木

### Sample Explanation 1

木 $ T $ は以下のような形であり、頂点 $ 2 $ から頂点 $ 5 $への単純パスは 頂点 $ 2 $ $ \to $ 頂点 $ 1 $ $ \to $ 頂点 $ 3 $ $ \to $ 頂点 $ 5 $ となります。 よって、$ 2,1,3,5 $ をこの順に空白区切りで出力します。 !\[\](https://img.atcoder.jp/abc270/4f4278d90219acdbf32e838353b7a55a.png)

### Sample Explanation 2

木 $ T $ は以下のような形です。 !\[\](https://img.atcoder.jp/abc270/3766cc7963f74e28fa0de6ff660b1998.png)

## 样例 #1

### 输入

```
5 2 5
1 2
1 3
3 4
3 5```

### 输出

```
2 1 3 5```

## 样例 #2

### 输入

```
6 1 2
3 1
2 5
1 2
4 1
2 6```

### 输出

```
1 2```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个包含 $N$ 个顶点的树 $T$，其中第 $i$ 条边（$1 \leq i \leq N-1$）连接顶点 $U_i$ 和顶点 $V_i$。

给定树 $T$ 上的两个不同顶点 $X$ 和 $Y$，请输出从顶点 $X$ 到顶点 $Y$ 的简单路径上的所有顶点（包括端点），并按顺序列出。

注意，树上的任意两个不同顶点 $a$ 和 $b$ 之间都存在唯一的一条简单路径。

**简单路径的定义**：对于图 $G$ 上的两个顶点 $X$ 和 $Y$，顶点序列 $v_1, v_2, \ldots, v_k$ 满足 $v_1 = X$，$v_k = Y$，并且对于 $1 \leq i \leq k-1$，$v_i$ 和 $v_{i+1}$ 之间有一条边相连。如果 $v_1, v_2, \ldots, v_k$ 中的所有顶点都不同，则称这条路径为从 $X$ 到 $Y$ 的**简单路径**。

### 算法分类
深度优先搜索 DFS

### 题解分析与结论
本题的核心是找到树上两点之间的唯一路径。由于树的性质，任意两点之间只有一条路径，因此可以通过深度优先搜索（DFS）来找到这条路径。

#### 题解1：SuperCowHorse
- **星级**：4星
- **关键亮点**：
  - 使用链式前向星存图，提高了图的存储和访问效率。
  - 通过DFS从起点开始搜索，直到找到终点，记录路径并输出。
  - 代码简洁，逻辑清晰，适合初学者理解。
- **个人心得**：作者提到使用链式前向星存图可能更快，这表明了对数据结构选择的优化意识。

**核心代码**：
```cpp
void dfs(int u, int fa) {
    if (u == y) {
        for (int i = 1; i < tot; ++i)
            printf("%d ", ans[i]);
        printf("%d", ans[tot]);
        exit(0); // 结束
    }
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if (v == fa) continue;
        ans[++tot] = v; // 统计
        dfs(v, u);
        ans[tot--] = 0;
    }
}
```
**实现思想**：从起点开始DFS，记录路径，当到达终点时输出路径并结束程序。

### 最优关键思路
- **数据结构选择**：使用链式前向星存图，优化了图的存储和访问效率。
- **DFS应用**：通过DFS搜索路径，利用树的性质确保路径的唯一性。
- **代码优化**：通过提前终止DFS（`exit(0)`）来减少不必要的搜索。

### 拓展思路
- **类似题目**：可以扩展到在图中寻找两点之间的所有路径，或者在有向图中寻找路径。
- **算法优化**：可以考虑使用广度优先搜索（BFS）来找到最短路径，或者在更复杂的图中使用Dijkstra算法。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1395 会议](https://www.luogu.com.cn/problem/P1395)
3. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

这些题目都涉及到树的遍历和路径查找，可以帮助巩固DFS和树的相关知识。

---
处理用时：23.21秒
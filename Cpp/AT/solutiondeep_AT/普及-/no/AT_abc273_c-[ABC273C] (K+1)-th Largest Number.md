# 题目信息

# [ABC273C] (K+1)-th Largest Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc273/tasks/abc273_c

長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ が与えられます。 $ K\ =\ 0,\ 1,\ 2,\ \ldots,\ N-1 $ のそれぞれについて、下記の問題を解いてください。

> $ 1 $ 以上 $ N $ 以下の整数 $ i $ であって、次の条件を満たすものの個数を求めよ。
> 
> - $ A $ に含まれる整数のうち $ A_i $ より大きいものはちょうど $ K $ 種類である。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力はすべて整数

### Sample Explanation 1

例として、$ K\ =\ 2 $ の場合の問題の答えを以下で求めます。 - $ A_1\ =\ 2 $ に関して、$ A $ に含まれる整数のうち $ A_1 $ より大きいものは、$ 7,\ 8 $ の $ 2 $ 種類です。 - $ A_2\ =\ 7 $ に関して、$ A $ に含まれる整数のうち $ A_2 $ より大きいものは、$ 8 $ の $ 1 $ 種類です。 - $ A_3\ =\ 1 $ に関して、$ A $ に含まれる整数のうち $ A_3 $ より大きいものは、$ 2,\ 7,\ 8 $ の $ 3 $ 種類です。 - $ A_4\ =\ 8 $ に関して、$ A $ に含まれる整数のうち $ A_4 $ より大きいものは、$ 0 $ 種類です（存在しません）。 - $ A_5\ =\ 2 $ に関して、$ A $ に含まれる整数のうち $ A_5 $ より大きいものは、$ 7,\ 8 $ の $ 2 $ 種類です。 - $ A_6\ =\ 8 $ に関して、$ A $ に含まれる整数のうち $ A_6 $ より大きいものは、$ 0 $ 種類です（存在しません）。 よって、$ A $ に含まれる整数のうち$ A_i $ より大きいものがちょうど $ K\ =\ 2 $ 種類であるような $ i $ は、$ i\ =\ 1 $ と $ i\ =\ 5 $ の $ 2 $ つです。よって、$ K\ =\ 2 $ の場合の答えは $ 2 $ です。

## 样例 #1

### 输入

```
6

2 7 1 8 2 8```

### 输出

```
2

1

2

1

0

0```

## 样例 #2

### 输入

```
1

1```

### 输出

```
1```

## 样例 #3

### 输入

```
10

979861204 57882493 979861204 447672230 644706927 710511029 763027379 710511029 447672230 136397527```

### 输出

```
2

1

2

1

2

1

1

0

0

0```

# AI分析结果

### 题目内容重写

给定一个长度为 $N$ 的数列 $A = (A_1, A_2, \ldots, A_N)$。对于每个 $K = 0, 1, 2, \ldots, N-1$，求解以下问题：

> 找出满足以下条件的整数 $i$（$1 \leq i \leq N$）的个数：
> 
> - 在数列 $A$ 中，比 $A_i$ 大的整数恰好有 $K$ 种。

### 算法分类
离散化、前缀和

### 题解分析与结论

题目要求对于每个 $K$，统计数列中比某个元素大的元素种类数恰好为 $K$ 的元素个数。核心思路是通过离散化和前缀和来高效计算每个元素的贡献。

### 所选题解

#### 题解：Epoch_L
- **星级**：4星
- **关键亮点**：
  - 使用离散化处理大范围数据，降低时间复杂度。
  - 通过前缀和快速计算比当前元素大的元素种类数。
  - 代码结构清晰，逻辑简洁。

#### 核心代码实现
```cpp
void init(){
  for(int i=1;i<=n;i++)b[i]=a[i];
  sort(b+1,b+n+1);
  len=unique(b+1,b+n+1)-b-1;
  for(int i=1;i<=n;i++)
    t[i]=lower_bound(b+1,b+len+1,a[i])-b,s[t[i]]=1;
  for(int i=1;i<=len;i++)s[i]+=s[i-1];
}

main(){
  read(n);
  for(int i=1;i<=n;i++)read(a[i]);
  init();
  for(int i=1;i<=n;i++)
  	ans[s[len]-s[t[i]]]++;
  for(int i=0;i<n;i++)printf("%lld\n",ans[i]);
  return 0;
}
```

### 最优关键思路与技巧
1. **离散化**：将大范围的数值映射到小范围的索引，便于处理。
2. **前缀和**：通过前缀和数组快速计算比当前元素大的元素种类数。
3. **统计贡献**：通过遍历数组，统计每个元素对答案的贡献。

### 可拓展之处
类似的问题可以通过离散化和前缀和来优化计算，特别是在处理大范围数据时。可以尝试解决其他需要统计元素大小关系的题目。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录
无

---
处理用时：17.74秒
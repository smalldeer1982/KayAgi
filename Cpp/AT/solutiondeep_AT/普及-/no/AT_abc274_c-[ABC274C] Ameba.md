# 题目信息

# [ABC274C] Ameba

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc274/tasks/abc274_c

あなたはアメーバの観察記録をつけました。

最初 $ 1 $ 匹のアメーバがおり、番号は $ 1 $ です。

観察記録は時系列順に $ N $ 個あり、$ i $ 番目の観察記録は「番号 $ A_i $ のアメーバが分裂して消滅し、新たに $ 2 $ 匹のアメーバが生まれ、それらにそれぞれ $ 2i,2i+1 $ と番号をつけた」というものです。  
 このとき、アメーバ $ A_i $ を アメーバ $ 2i,2i+1 $ の親と呼びます。

各 $ k=1,\ldots,2N+1 $ について、アメーバ $ k $ から何代親を遡るとアメーバ $ 1 $ になるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- 観察記録は矛盾していない。すなわち
  - $ 1\leq\ A_i\ \leq\ 2i-1 $
  - $ A_i $ は相異なる整数

### Sample Explanation 1

アメーバ $ 1 $ からアメーバ $ 2,3 $ が生まれ、アメーバ $ 2 $ からアメーバ $ 4,5 $ が生まれました。 - アメーバ $ 1 $ は $ 0 $ 代遡るとアメーバ $ 1 $ になります。 - アメーバ $ 2 $ は $ 1 $ 代遡るとアメーバ $ 1 $ になります。 - アメーバ $ 3 $ は $ 1 $ 代遡るとアメーバ $ 1 $ になります。 - アメーバ $ 4 $ は $ 1 $ 代遡るとアメーバ $ 2 $ になり、$ 2 $ 代遡るとアメーバ $ 1 $ になります。 - アメーバ $ 5 $ は $ 1 $ 代遡るとアメーバ $ 2 $ になり、$ 2 $ 代遡るとアメーバ $ 1 $ になります。

## 样例 #1

### 输入

```
2

1 2```

### 输出

```
0

1

1

2

2```

## 样例 #2

### 输入

```
4

1 3 5 2```

### 输出

```
0

1

1

2

2

3

3

2

2```

# AI分析结果

【题目内容重写】
# [ABC274C] 变形虫

## 题目描述

你记录了变形虫的观察结果。

最初有1只变形虫，编号为1。

观察记录按时间顺序有N个，第i个观察记录是“编号为A_i的变形虫分裂并消失，新产生了2只变形虫，分别编号为2i和2i+1”。  
此时，变形虫A_i被称为变形虫2i和2i+1的父代。

对于每个k=1,…,2N+1，求从变形虫k回溯多少代父代会到达变形虫1。

## 说明/提示

### 约束

- 1 ≤ N ≤ 2×10^5
- 观察记录不矛盾。即
  - 1 ≤ A_i ≤ 2i-1
  - A_i是互不相同的整数

### 样例解释1

变形虫1分裂产生变形虫2和3，变形虫2分裂产生变形虫4和5。  
- 变形虫1回溯0代到达变形虫1。  
- 变形虫2回溯1代到达变形虫1。  
- 变形虫3回溯1代到达变形虫1。  
- 变形虫4回溯1代到达变形虫2，回溯2代到达变形虫1。  
- 变形虫5回溯1代到达变形虫2，回溯2代到达变形虫1。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
0
1
1
2
2
```

## 样例 #2

### 输入

```
4
1 3 5 2
```

### 输出

```
0
1
1
2
2
3
3
2
2
```

【算法分类】
递推

【题解分析与结论】
本题的核心是通过观察记录构建变形虫的家族树，并计算每个变形虫到根节点的代数。题解主要分为两种思路：
1. **直接递推**：通过记录每个节点的代数，直接计算其子代的代数。
2. **DFS+记忆化**：通过构建父节点关系，使用DFS遍历并记忆化搜索每个节点的代数。

【评分较高的题解】
1. **JustForYourself (4星)**
   - **关键亮点**：直接使用递推方法，代码简洁高效，时间复杂度为O(N)。
   - **核心代码**：
     ```cpp
     int rnk[400010];
     rnk[1] = 0;
     for (int i = 1; i <= n; i++) {
         int x;
         cin >> x;
         rnk[i * 2] = rnk[x] + 1;
         rnk[i * 2 + 1] = rnk[x] + 1;
     }
     ```
   - **总结**：通过维护一个数组记录每个节点的代数，直接计算子代的代数，思路清晰，代码简洁。

2. **RainSpark (4星)**
   - **关键亮点**：使用DFS+记忆化搜索，虽然复杂度略高，但思路清晰，适合理解树结构的遍历。
   - **核心代码**：
     ```cpp
     int findfa(int x){
         if(x==1) return 0;
         if(f[x]!=-1) return f[x];
         f[x]=1+findfa(fa[x]);
         return f[x];
     }
     ```
   - **总结**：通过构建父节点关系，使用DFS遍历并记忆化搜索每个节点的代数，适合理解树结构的遍历。

【最优关键思路或技巧】
- **直接递推**：通过维护一个数组记录每个节点的代数，直接计算子代的代数，时间复杂度为O(N)，适合大规模数据处理。
- **DFS+记忆化**：通过构建父节点关系，使用DFS遍历并记忆化搜索每个节点的代数，适合理解树结构的遍历。

【可拓展之处】
- 类似问题可以扩展到更复杂的树结构，如多叉树或带权树。
- 可以进一步优化DFS的实现，如使用迭代DFS减少递归深度。

【推荐题目】
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P1395 会议](https://www.luogu.com.cn/problem/P1395)
3. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)

---
处理用时：26.70秒
# 题目信息

# [ABC276B] Adjacency List

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc276/tasks/abc276_b

$ 1,\ \dots,\ N $ と番号付けられた $ N $ 個の都市と、都市間を結ぶ $ M $ 本の道路があります。  
$ i\ \,\ (1\ \leq\ i\ \leq\ M) $ 番目の道路は都市 $ A_i $ と都市 $ B_i $ を結んでいます。

以下の指示に従い、$ N $ 行にわたって出力してください。

- 都市 $ i\ \,\ (1\ \leq\ i\ \leq\ N) $ と道路で直接結ばれた都市が $ d_i $ 個あるとし、それらを**昇順**に都市 $ a_{i,\ 1},\ \dots,\ a_{i,\ d_i} $ とおく。
- $ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 行目には、$ d_i\ +\ 1 $ 個の整数 $ d_i,\ a_{i,\ 1},\ \dots,\ a_{i,\ d_i} $ を、この順番で空白区切りで出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \lt\ B_i\ \leq\ N\ \,\ (1\ \leq\ i\ \leq\ M) $
- $ (i\ \neq\ j) $ ならば $ (A_i,\ B_i)\ \neq\ (A_j,\ B_j) $
- 入力される値は全て整数

### Sample Explanation 1

都市 $ 1 $ と道路で直接結ばれているのは都市 $ 2,\ 3,\ 6 $ です。よって、$ d_1\ =\ 3,\ a_{1,\ 1}\ =\ 2,\ a_{1,\ 2}\ =\ 3,\ a_{1,\ 3}\ =\ 6 $ であるので、$ 1 $ 行目には $ 3,\ 2,\ 3,\ 6 $ をこの順番で空白区切りで出力します。 $ a_{i,\ 1},\ \dots,\ a_{i,\ d_i} $ は昇順に並んでいなければならないことに注意してください。例えば、$ 1 $ 行目に $ 3,\ 3,\ 2,\ 6 $ をこの順番で出力した場合、不正解となります。

## 样例 #1

### 输入

```
6 6
3 6
1 3
5 6
2 5
1 2
1 6```

### 输出

```
3 2 3 6
2 1 5
2 1 6
0
2 2 6
3 1 3 5```

## 样例 #2

### 输入

```
5 10
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
4 5```

### 输出

```
4 2 3 4 5
4 1 3 4 5
4 1 2 4 5
4 1 2 3 5
4 1 2 3 4```

# AI分析结果

### 题目内容重写

**题目描述**

编号为 $1,\ \dots,\ N$ 的 $N$ 个城市之间有 $M$ 条道路连接。第 $i$ 条道路连接城市 $A_i$ 和城市 $B_i$。

请按照以下要求输出 $N$ 行：

- 对于每个城市 $i$，输出与其直接相连的城市数量 $d_i$，然后按升序输出这些城市的编号。

**输入格式**

第一行包含两个整数 $N$ 和 $M$，表示城市数量和道路数量。

接下来 $M$ 行，每行包含两个整数 $A_i$ 和 $B_i$，表示一条道路连接的两个城市。

**输出格式**

输出 $N$ 行，每行先输出一个整数 $d_i$，表示与城市 $i$ 直接相连的城市数量，然后按升序输出这些城市的编号，用空格分隔。

**样例**

输入：
```
6 6
3 6
1 3
5 6
2 5
1 2
1 6
```

输出：
```
3 2 3 6
2 1 5
2 1 6
0
2 2 6
3 1 3 5
```

### 算法分类

图论

### 题解分析与结论

本题的核心是构建邻接表并按要求输出。各题解的主要思路都是使用 `vector` 存储邻接表，然后对每个节点的邻接表进行排序并输出。以下是各题解的对比：

1. **Acit 的题解**：
   - 使用 `vector<int> a[N]` 存储邻接表，`int b[N]` 存储每个节点的度数。
   - 代码简洁，逻辑清晰，直接使用 `sort` 对邻接表排序。
   - 评分：5星

2. **Fire_flame 的题解**：
   - 使用结构体数组存储边，并对其进行排序，然后使用队列存储邻接表。
   - 代码较为复杂，且空间复杂度较高。
   - 评分：3星

3. **李宇涵 的题解**：
   - 使用 `vector<ll> e[100010]` 存储邻接表，逻辑清晰，代码简洁。
   - 评分：4星

4. **xiaohaoaibiancheng66 的题解**：
   - 使用 `vector<int> bian[1000000]` 存储邻接表，代码简洁，逻辑清晰。
   - 评分：4星

5. **sunzz3183 的题解**：
   - 使用优先队列存储邻接表，代码较为复杂，且时间复杂度较高。
   - 评分：2星

6. **hyc1026 的题解**：
   - 使用 `vector<int> a[100001]` 存储邻接表，逻辑清晰，代码简洁。
   - 评分：4星

### 最优关键思路与技巧

- **数据结构**：使用 `vector` 存储邻接表，既节省空间又方便操作。
- **排序**：直接使用 `sort` 对每个节点的邻接表进行排序，简单高效。
- **输出**：遍历邻接表，先输出度数，再输出排序后的邻接节点。

### 可拓展之处

- **图的遍历**：可以进一步拓展为深度优先搜索（DFS）或广度优先搜索（BFS）来遍历图。
- **最短路径**：可以在此基础上实现最短路径算法，如 Dijkstra 或 Floyd-Warshall。

### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)
3. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)

### 个人心得

- **调试经历**：在构建邻接表时，确保双向边的正确存储，避免遗漏或重复。
- **踩坑教训**：注意数组大小，避免越界或内存不足。
- **顿悟感想**：使用 `vector` 和 `sort` 可以大大简化代码，提高效率。

### 核心代码片段

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
vector<int>a[N];
int b[N];
int n,m;
int x,y;
int main() {
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		a[x].push_back(y);
		a[y].push_back(x);
		b[x]++;
		b[y]++;
	}
	for(int i=1;i<=n;i++){
		cout<<b[i]<<' ';
		sort(a[i].begin(),a[i].end());
		for(int j=0;j<a[i].size();j++){
			cout<<a[i][j]<<' ';
		}
		cout<<endl;
	}
	return 0;
}
```

这段代码简洁高效，直接使用 `vector` 存储邻接表，并通过 `sort` 对邻接表进行排序，最后按要求输出。

---
处理用时：27.67秒
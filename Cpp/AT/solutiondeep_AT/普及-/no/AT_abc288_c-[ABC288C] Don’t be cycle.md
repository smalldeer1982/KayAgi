# 题目信息

# [ABC288C] Don’t be cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc288/tasks/abc288_c

$ N $ 頂点 $ M $ 辺の単純無向グラフが与えられます。頂点には $ 1 $ から $ N $ の番号がついており、$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。 このグラフから $ 0 $ 本以上のいくつかの辺を削除してグラフが閉路を持たないようにするとき、削除する辺の本数の最小値を求めてください。

 単純無向グラフとは **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

 閉路とは 単純無向グラフが**閉路**を持つとは、$ i\ \neq\ j $ ならば $ v_i\ \neq\ v_j $ を満たす長さ $ 3 $ 以上の頂点列 $ (v_0,\ v_1,\ \ldots,\ v_{n-1}) $ であって、各 $ 0\ \leq\ i\ に対し\ v_i $ と $ v_{i+1\ \bmod\ n} $ の間に辺が存在するものがあることをいいます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N $
- 与えられるグラフは単純
- 入力はすべて整数
 
### Sample Explanation 1

頂点 $ 1 $ と頂点 $ 2 $ を結ぶ辺・頂点 $ 4 $ と頂点 $ 5 $ を結ぶ辺の $ 2 $ 本を削除するなどの方法でグラフが閉路を持たないようにすることができます。 $ 1 $ 本以下の辺の削除でグラフが閉路を持たないようにすることはできないので、$ 2 $ を出力します。

## 样例 #1

### 输入

```
6 7

1 2

1 3

2 3

4 2

6 5

4 6

4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2

1 2

3 4```

### 输出

```
0```

## 样例 #3

### 输入

```
5 3

1 2

1 3

2 3```

### 输出

```
1```

# AI分析结果

### 题目内容重写

给定一个包含 $N$ 个顶点和 $M$ 条边的简单无向图。顶点编号为 $1$ 到 $N$，第 $i$ 条边连接顶点 $A_i$ 和 $B_i$。要求删除尽可能少的边，使得图中不存在环。求需要删除的边的最小数量。

### 算法分类
并查集、图论

### 题解综合分析与结论

题目要求删除最少的边使得图中不存在环，本质上是求图的生成森林。生成森林的边数为 $N - Q$，其中 $Q$ 是连通块的数量。因此，需要删除的边数为 $M - (N - Q)$。

### 所选题解

#### 1. 作者：Neil_Qian (赞：3)  
**星级：5星**  
**关键亮点：**  
- 使用并查集判断边的两个顶点是否在同一连通块，若在同一连通块则说明该边会形成环，需要删除。
- 代码简洁高效，时间复杂度为 $O(M \cdot \alpha(N))$，其中 $\alpha(N)$ 是反阿克曼函数，接近常数时间。
- 通过递归查找和路径压缩优化了并查集的查找操作。

**核心代码：**
```cpp
int fnd(int x) {
    return (f[x] == x ? x : f[x] = fnd(f[x]));
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) f[i] = i;
    while (m--) {
        scanf("%d%d", &a, &b);
        if (fnd(a) != fnd(b)) f[fnd(a)] = fnd(b);
        else ans++;
    }
    printf("%d\n", ans);
}
```

#### 2. 作者：yinhy09 (赞：0)  
**星级：4星**  
**关键亮点：**  
- 同样使用并查集，思路清晰，代码结构良好。
- 通过并查集的合并操作判断是否需要删除边，逻辑与Neil_Qian的解法一致。

**核心代码：**
```cpp
ll find(ll x) {
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}

bool merge(ll x, ll y) {
    ll fx = find(x), fy = find(y);
    if (fx == fy) return 1;
    fa[fx] = fy;
    return 0;
}

int main() {
    cin >> n >> m;
    ll ans = 0;
    init();
    for (int i = 1; i <= m; i++) {
        cin >> u >> v;
        ans += merge(u, v);
    }
    printf("%lld\n", ans);
}
```

#### 3. 作者：Paris_Commune (赞：0)  
**星级：4星**  
**关键亮点：**  
- 从数学角度分析问题，推导出删除边数的公式 $M - N + Q$，其中 $Q$ 是连通块的数量。
- 思路清晰，提供了理论支持，便于理解问题的本质。

**核心思路：**  
通过计算连通块数量 $Q$，推导出需要删除的边数为 $M - N + Q$。

### 最优关键思路或技巧
使用并查集判断边的两个顶点是否在同一连通块，若在同一连通块则说明该边会形成环，需要删除。通过路径压缩优化并查集的查找操作，确保时间复杂度接近线性。

### 可拓展之处
类似的问题可以扩展到有向图中判断是否存在环，或者求最小生成树等问题。并查集在图论中广泛应用于连通性判断和最小生成树算法。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1196 [NOI2002] 银河英雄传说](https://www.luogu.com.cn/problem/P1196)

---
处理用时：24.53秒
# 题目信息

# [ABC289C] Coverage

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc289/tasks/abc289_c

$ 1 $ 以上 $ N $ 以下の整数からなる集合が $ M $ 個あり、順に $ S_1,\ S_2,\ \dots,\ S_M $ と呼びます。  
$ S_i $ は $ C_i $ 個の整数 $ a_{i,\ 1},\ a_{i,\ 2},\ \dots,\ a_{i,\ C_i} $ からなります。

$ M $ 個の集合から $ 1 $ 個以上の集合を選ぶ方法は $ 2^M-1 $ 通りあります。  
このうち、次の条件を満たす選び方は何通りありますか？

- $ 1\ \leq\ x\ \leq\ N $ を満たす全ての整数 $ x $ に対して、選んだ集合の中に $ x $ を含む集合が少なくとも $ 1 $ 個存在する。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10 $
- $ 1\ \leq\ M\ \leq\ 10 $
- $ 1\ \leq\ C_i\ \leq\ N $
- $ 1\ \leq\ a_{i,1}\ \lt\ a_{i,2}\ \lt\ \dots\ \lt\ a_{i,C_i}\ \leq\ N $
- 入力される値は全て整数

### Sample Explanation 1

入力で与えられている集合はそれぞれ $ S_1\ =\ \lbrace\ 1,\ 2\ \rbrace,\ S_2\ =\ \lbrace\ 1,\ 3\ \rbrace,\ S_3\ =\ \lbrace\ 2\ \rbrace $ です。 問題文の条件を満たす集合の選び方は次の $ 3 $ 通りです。 - $ S_1,\ S_2 $ を選ぶ。 - $ S_1,\ S_2,\ S_3 $ を選ぶ。 - $ S_2,\ S_3 $ を選ぶ。

### Sample Explanation 2

問題文の条件を満たす選び方が存在しない場合もあります。

## 样例 #1

### 输入

```
3 3
2
1 2
2
1 3
1
2```

### 输出

```
3```

## 样例 #2

### 输入

```
4 2
2
1 2
2
1 3```

### 输出

```
0```

## 样例 #3

### 输入

```
6 6
3
2 3 6
3
2 4 6
2
3 6
3
1 5 6
3
1 3 6
2
1 4```

### 输出

```
18```

# AI分析结果

### 题目内容重写

#### [ABC289C] Coverage

**题目描述**

给定 $M$ 个集合，每个集合包含 $1$ 到 $N$ 之间的整数。要求从这 $M$ 个集合中选出若干个集合，使得选出的集合的并集包含 $1$ 到 $N$ 的所有整数。问有多少种选法满足条件。

**说明/提示**

**约束条件**

- $1 \leq N \leq 10$
- $1 \leq M \leq 10$
- $1 \leq C_i \leq N$
- $1 \leq a_{i,1} < a_{i,2} < \dots < a_{i,C_i} \leq N$
- 输入的所有值都是整数

**样例解释**

**样例 1**

输入：
```
3 3
2
1 2
2
1 3
1
2
```
输出：
```
3
```
解释：给定的集合分别是 $S_1 = \{1, 2\}$，$S_2 = \{1, 3\}$，$S_3 = \{2\}$。满足条件的选法有：
- 选择 $S_1$ 和 $S_2$
- 选择 $S_1$、$S_2$ 和 $S_3$
- 选择 $S_2$ 和 $S_3$

**样例 2**

输入：
```
4 2
2
1 2
2
1 3
```
输出：
```
0
```
解释：没有满足条件的选法。

**样例 3**

输入：
```
6 6
3
2 3 6
3
2 4 6
2
3 6
3
1 5 6
3
1 3 6
2
1 4
```
输出：
```
18
```

### 算法分类

**深度优先搜索 DFS**

### 题解分析与结论

本题的核心是通过深度优先搜索（DFS）枚举所有可能的集合选择方式，并检查每种选择是否满足条件。由于 $N$ 和 $M$ 的范围都很小（$1 \leq N, M \leq 10$），因此可以直接使用暴力搜索的方法。

### 所选题解

#### 1. 作者：minVan (赞：3)

**星级：4星**

**关键亮点：**
- 使用 DFS 枚举所有可能的集合选择方式。
- 通过 `check` 函数检查当前选择的集合是否覆盖了 $1$ 到 $N$ 的所有整数。
- 代码结构清晰，易于理解。

**核心代码：**

```cpp
inline void dfs(int x) {
    if(x > m) {
        if(check()) {
            ans++;
        }
        return ;
    }
    vis[x] = 1;
    dfs(x + 1);
    vis[x] = 0;
    dfs(x + 1);
    return ;
}
```

**检查函数：**

```cpp
inline bool check() {
    memset(mp, 0, sizeof(mp));
    for(int i = 1; i <= m; i++) {
        if(vis[i]) {
            for(int j = 1; j <= s[i][0]; j++) {
                mp[s[i][j]] = 1;
            }
        }
    }
    for(int i = 1; i <= n; i++) {
        if(!mp[i]) {
            return 0;
        }
    }
    return 1;
}
```

#### 2. 作者：_dijkstra_ (赞：1)

**星级：4星**

**关键亮点：**
- 使用 DFS 进行集合选择，并在选择时动态更新覆盖情况。
- 通过 `chk` 函数检查当前选择的集合是否覆盖了 $1$ 到 $N$ 的所有整数。
- 代码简洁，逻辑清晰。

**核心代码：**

```cpp
void dfs(int x) {
    if (x > m) {
        if (chk()) ans++;
        return;
    }
    dfs(x + 1);
 
    int ttmp[N] = {};
    for (int i = 1; i <= n; i++) ttmp[i] = tmp[i], tmp[i] |= a[x][i];
    dfs(x + 1);
    for (int i = 1; i <= n; i++) tmp[i] = ttmp[i];
}
```

**检查函数：**

```cpp
bool chk() {
    for (int i = 1; i <= n; i++)
        if (!tmp[i])
            return false;
    return true;
}
```

#### 3. 作者：liangbob (赞：1)

**星级：4星**

**关键亮点：**
- 使用 DFS 进行组合选取，确保选择的集合编号严格递增，避免重复计算。
- 通过 `pded` 数组记录当前选择的集合是否覆盖了 $1$ 到 $N$ 的所有整数。
- 代码结构清晰，逻辑严谨。

**核心代码：**

```cpp
void dfs(int r, int pos) {
	if(pos > r) {
		memset(pded, false, sizeof(pded));
		for(int i = 1;i <= r;i++) {
			for(int j = 1;j <= c[t[i]];j++) {
				pded[a[t[i]][j]] = true;
			}
		}
		bool pd = pded[1];
		for(int i = 2;i <= n;i++) {
			pd = pd && pded[i];
		}
		cnt += int(pd);
		return;
	}
	for(int i = 1;i <= m;i++) {
	 	if(!used[i] && i > t[pos - 1]) {
	 		t[pos] = i;
	 		used[i] = true;
	 		dfs(r, pos + 1);
	 		used[i] = false;
		}
	}
}
```

### 最优关键思路与技巧

- **DFS 枚举所有可能的集合选择方式**：通过 DFS 递归地选择或不选择每个集合，最终检查是否满足条件。
- **检查函数**：在每次选择完成后，通过一个检查函数来判断当前选择的集合是否覆盖了 $1$ 到 $N$ 的所有整数。
- **回溯技巧**：在 DFS 中，通过回溯的方式撤销选择，确保所有可能的组合都被枚举到。

### 可拓展之处

- **状态压缩**：对于更大的 $N$ 和 $M$，可以考虑使用状态压缩来优化搜索过程。
- **剪枝优化**：在 DFS 过程中，可以通过剪枝来减少不必要的搜索，提高效率。

### 推荐题目

1. [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)

---
处理用时：34.64秒
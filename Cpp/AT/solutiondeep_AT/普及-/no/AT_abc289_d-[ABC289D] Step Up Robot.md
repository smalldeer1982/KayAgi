# 题目信息

# [ABC289D] Step Up Robot

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc289/tasks/abc289_d

無限に続く階段があります。 一番下は $ 0 $ 段目で、$ 1 $ 段のぼるごとに $ 1 $ 段目、$ 2 $ 段目と続きます。

$ 0 $ 段目に階段登りロボットがいます。 階段登りロボットは、一回の動作で $ A\ _\ 1,A\ _\ 2,\ldots,A\ _\ N $ 段ぶん階段をのぼることができます。 つまり、階段登りロボットが $ i $ 段目にいるとき、一回動作をした後は $ i+A\ _\ 1 $ 段目、$ i+A\ _\ 2 $ 段目、⋯、$ i+A\ _\ N $ 段目のいずれかにいることができます。 それ以外の段数を一回の動作でのぼることはできません。 階段登りロボットは階段を下ることもできません。

階段の $ B\ _\ 1,B\ _\ 2,\ldots,B\ _\ M $ 段目にはモチが設置されています。 モチが設置されている段へのぼるとロボットは動けなくなり、他の段に移動することができなくなります。

階段登りロボットは階段のちょうど $ X $ 段目にのぼりたいです。 階段登りロボットが階段のちょうど $ X $ 段目にのぼることが可能か判定してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq10 $
- $ 1\leq\ A\ _\ 1\lt\ A\ _\ 2\lt\cdots\lt\ A\ _\ N\leq10^5 $
- $ 1\leq\ M\leq10^5 $
- $ 1\leq\ B\ _\ 1\lt\ B\ _\ 2\lt\cdots\lt\ B\ _\ M\lt\ X\leq10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

例えば、次のようにして $ 15 $ 段目に到達することができます。 - 階段を $ 3 $ 段のぼる。ロボットは $ 3 $ 段目に移動する。 - 階段を $ 4 $ 段のぼる。ロボットは $ 7 $ 段目に移動する。 - 階段を $ 5 $ 段のぼる。ロボットは $ 12 $ 段目に移動する。 - 階段を $ 3 $ 段のぼる。ロボットは $ 15 $ 段目に移動する。

### Sample Explanation 2

どのように移動しても階段登りロボットが階段のちょうど $ 8 $ 段目にいることはできません。

## 样例 #1

### 输入

```
3

3 4 5

4

4 5 6 8

15```

### 输出

```
Yes```

## 样例 #2

### 输入

```
4

2 3 4 5

4

3 4 5 6

8```

### 输出

```
No```

## 样例 #3

### 输入

```
4

2 5 7 8

5

2 9 10 11 19

20```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写

**题目描述**

有一个无限延伸的楼梯，最下面是第0阶，每向上走一步就增加一阶，即第1阶、第2阶，依此类推。

在第0阶有一个机器人，它每次可以向上走$A_1, A_2, \ldots, A_N$阶中的任意一个步数。也就是说，当机器人在第$i$阶时，它可以选择走$A_1$到$A_N$中的任意一个步数，到达第$i+A_1$到$i+A_N$阶中的任意一阶。机器人不能走其他步数，也不能向下走。

在楼梯的第$B_1, B_2, \ldots, B_M$阶上有陷阱，如果机器人走到这些阶，它将无法继续移动。

机器人希望到达第$X$阶，问是否有可能实现。

**输入输出样例**

**样例1**

输入：
```
3
3 4 5
4
4 5 6 8
15
```
输出：
```
Yes
```

**样例2**

输入：
```
4
2 3 4 5
4
3 4 5 6
8
```
输出：
```
No
```

**样例3**

输入：
```
4
2 5 7 8
5
2 9 10 11 19
20
```
输出：
```
Yes
```

### 算法分类
动态规划

### 题解分析与结论

本题的核心是通过动态规划来判断机器人是否能够从第0阶走到第$X$阶，且不踩到陷阱。所有题解都采用了动态规划的思路，但实现方式有所不同。

### 精选题解

#### 题解1：_zzzzzzy_ (4星)
**关键亮点**：
- 使用$dp[i]$表示能否到达第$i$阶，初始化$dp[0] = 1$。
- 通过双重循环遍历所有可能的步数，更新$dp$数组。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=0;i<=x;i++){
    if(dp[i])
        for(int j=1;j<=n;j++){
            if(!vis[i+a[j]])
                dp[i+a[j]]=1;
        }
}
```

#### 题解2：ReeChee (4星)
**关键亮点**：
- 直接从$a[1]$开始枚举，减少不必要的计算。
- 在枚举过程中，如果$f[i]$已经为1，则无需继续枚举，优化了时间复杂度。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
F(i,a[1],x)
    for (int j=1;j<=n&&i-a[j]>=0&&!f[i]&&!isTrap[i];++j)
        f[i]=f[i-a[j]]&1;
```

#### 题解3：Crazyouth (4星)
**关键亮点**：
- 使用$dp_i$表示能否到达第$i$阶，初始化$dp_0 = 1$。
- 通过暴力转移，判断$dp_i$是否为1。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=x;i++)
    for(int j=1;j<=n;j++)
        if(i>=a[j]&&!b[i-a[j]]&&dp[i-a[j]]==1)
            dp[i]=1;
```

### 最优关键思路
- **动态规划**：使用$dp[i]$表示能否到达第$i$阶，初始化$dp[0] = 1$，通过遍历所有可能的步数更新$dp$数组。
- **优化枚举**：从$a[1]$开始枚举，减少不必要的计算，并在枚举过程中如果$f[i]$已经为1，则无需继续枚举。

### 拓展思路
- **类似题目**：可以考虑机器人每次走步数不固定，或者陷阱的位置动态变化的情况。
- **算法优化**：可以通过剪枝或记忆化搜索进一步优化时间复杂度。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：24.14秒
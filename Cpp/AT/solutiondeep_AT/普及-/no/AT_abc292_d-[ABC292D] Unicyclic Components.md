# 题目信息

# [ABC292D] Unicyclic Components

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc292/tasks/abc292_d

頂点に $ 1 $ から $ N $ の番号が、辺に $ 1 $ から $ M $ の番号がついた $ N $ 頂点 $ M $ 辺の無向グラフが与えられます。辺 $ i $ は頂点 $ u_i $ と頂点 $ v_i $ を結んでいます。

このグラフのすべての連結成分が次の条件を満たすかどうかを判定してください。

- その連結成分に含まれる頂点の個数と辺の本数が等しい。

## 说明/提示

### 注釈

**無向グラフ** とは、辺に向きの無いグラフのことをいいます。  
あるグラフの **部分グラフ** とは、元のグラフのいくつかの頂点といくつかの辺を選んでできるグラフのことをいいます。  
グラフが **連結** であるとは、グラフに含まれるすべての頂点同士が辺を経由して互いに行き来できることをいいます。  
**連結成分** とは、連結な部分グラフのうち、そのグラフを含んだより大きい連結な部分グラフが存在しないものをいいます。

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i\ \leq\ v_i\ \leq\ N $
- 入力はすべて整数

### Sample Explanation 1

このグラフには頂点 $ 1 $ のみからなる連結成分と頂点 $ 2,3 $ からなる連結成分があります。 前者には $ 1 $ 本の辺(辺 $ 2 $ )が、後者には $ 2 $ 本の辺(辺 $ 1,3 $ )が含まれており、条件を満たします。

## 样例 #1

### 输入

```
3 3
2 3
1 1
2 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5 5
1 2
2 3
3 4
3 5
1 5```

### 输出

```
Yes```

## 样例 #3

### 输入

```
13 16
7 9
7 11
3 8
1 13
11 11
6 11
8 13
2 11
3 3
8 12
9 11
1 11
5 13
3 12
6 9
1 10```

### 输出

```
No```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个包含 $N$ 个顶点和 $M$ 条边的无向图，判断该图的所有连通分量是否满足以下条件：
- 每个连通分量中的顶点数与边数相等。

【输入格式】
- 第一行包含两个整数 $N$ 和 $M$，分别表示顶点数和边数。
- 接下来的 $M$ 行，每行包含两个整数 $u_i$ 和 $v_i$，表示一条连接顶点 $u_i$ 和 $v_i$ 的边。

【输出格式】
如果所有连通分量都满足条件，输出 `Yes`，否则输出 `No`。

【样例输入】
```
3 3
2 3
1 1
2 3
```
【样例输出】
```
Yes
```

### 算法分类
图论、并查集、深度优先搜索（DFS）、广度优先搜索（BFS）

### 题解分析与结论
该题的核心在于判断每个连通分量中的顶点数与边数是否相等。题解中主要使用了以下几种方法：
1. **BFS/DFS遍历**：通过遍历每个连通分量，统计顶点数和边数，然后进行比较。
2. **并查集**：通过并查集维护连通分量，同时统计每个连通分量的顶点数和边数。

### 高星题解推荐

#### 题解1：zhlzt (5星)
**关键亮点**：
- 使用BFS遍历每个连通分量，统计顶点数和边数。
- 通过给每条无向边的两条有向边赋予相同的编号，避免重复计数。

**核心代码**：
```cpp
bool bfs(int s){
    queue<int>q;
    int fa,sn,id,ans1=0,ans2=0;
    q.push(s),vis[s]=1;
    while(!q.empty()){
        fa=q.front(),q.pop();
        ans1++;//数点
        for(int i=0;i<edge[fa].size();i++){
            sn=edge[fa][i].first,id=edge[fa][i].second;
            if(mp[id]==0) ans2++,mp[id]=1;//数边
            if(vis[sn]==0) q.push(sn),vis[sn]=1;
        }
    }
    return ans1==ans2;//判断点数和边数是否相等 
}
```

#### 题解2：Eleveslaine (4星)
**关键亮点**：
- 使用并查集维护连通分量，统计每个连通分量的顶点数和边数。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=m;++i)
    ++e[find(u[i])];
for(int i=1;i<=n;++i)
    ++siz[find(i)];
for(int i=1;i<=n;++i)
    if(f[i]==i && e[i]!=siz[i])
        No;
Yes;
```

#### 题解3：qwq___qaq (4星)
**关键亮点**：
- 使用DFS遍历每个连通分量，统计顶点数和边数。
- 通过将边数除以2，避免重复计数。

**核心代码**：
```cpp
void dfs(int u){
    if(vis[u])
        return;
    ++cnta;
    vis[u]=1;
    for(auto v:G[u]){
        ++cntb;
        dfs(v);
    }
}
```

### 最优关键思路
- **BFS/DFS遍历**：通过遍历每个连通分量，统计顶点数和边数，确保每个连通分量的顶点数与边数相等。
- **并查集**：通过并查集维护连通分量，同时统计每个连通分量的顶点数和边数，简化了统计过程。

### 可拓展之处
- **类似题目**：可以扩展到判断图的连通性、计算连通分量的数量等问题。
- **算法优化**：可以使用更高效的数据结构（如邻接表）来优化遍历过程。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)
3. [P3388 【模板】割点](https://www.luogu.com.cn/problem/P3388)

### 个人心得
- **调试经历**：在统计边数时，需要注意无向边的重复计数问题，通过给每条无向边的两条有向边赋予相同的编号，可以有效避免重复计数。
- **顿悟感想**：并查集在处理连通性问题时非常高效，尤其是在需要统计连通分量信息的情况下，可以大大简化代码逻辑。

---
处理用时：29.41秒
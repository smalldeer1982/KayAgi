# 题目信息

# [ABC293C] Make Takahashi Happy

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc293/tasks/abc293_c

$ H $ 行 $ W $ 列のマス目があります。 $ 1\ \leq\ i\ \leq\ H $ かつ $ 1\ \leq\ j\ \leq\ W $ を満たす $ 2 $ つの整数 $ i,\ j $ について、 上から $ i $ 行目、左から $ j $ 列目のマス（以下、$ (i,\ j) $ と表す）には、整数 $ A_{i,\ j} $ が書かれています。

いま、高橋君は $ (1,\ 1) $ にいます。 これから高橋君は「いまいるマスから右または下に隣接するマスに移動する」ことを繰り返して、$ (H,\ W) $ まで移動します。 ただし、その過程でマス目の外部に移動することは出来ません。

その結果、高橋君が通ったマス（始点 $ (1,\ 1) $ と終点 $ (H,\ W) $ を含む）に書かれた整数がすべて異なるとき、高橋君は嬉しくなります。 高橋君の移動経路として考えられるもののうち、高橋君が嬉しくなるものの個数を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 10 $
- $ 1\ \leq\ A_{i,\ j}\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

高橋君の移動経路として考えられるものは下記の $ 6 $ 通りです。 - $ (1,\ 1)\ \rightarrow\ (1,\ 2)\ \rightarrow\ (1,\ 3)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3) $：通ったマスに書かれた整数は $ 3,\ 2,\ 2,\ 3,\ 4 $ であり、高橋君は嬉しく\*\*なりません\*\*。 - $ (1,\ 1)\ \rightarrow\ (1,\ 2)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3) $：通ったマスに書かれた整数は $ 3,\ 2,\ 1,\ 3,\ 4 $ であり、高橋君は嬉しく\*\*なりません\*\*。 - $ (1,\ 1)\ \rightarrow\ (1,\ 2)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (3,\ 2)\ \rightarrow\ (3,\ 3) $：通ったマスに書かれた整数は $ 3,\ 2,\ 1,\ 5,\ 4 $ であり、高橋君は嬉しく\*\*なります\*\*。 - $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3) $：通ったマスに書かれた整数は $ 3,\ 2,\ 1,\ 3,\ 4 $ であり、高橋君は嬉しく\*\*なりません\*\*。 - $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (3,\ 2)\ \rightarrow\ (3,\ 3) $：通ったマスに書かれた整数は $ 3,\ 2,\ 1,\ 5,\ 4 $ であり、高橋君は嬉しく\*\*なります\*\*。 - $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (3,\ 1)\ \rightarrow\ (3,\ 2)\ \rightarrow\ (3,\ 3) $：通ったマスに書かれた整数は $ 3,\ 2,\ 1,\ 5,\ 4 $ であり、高橋君は嬉しく\*\*なります\*\*。 よって、高橋君が嬉しくなる移動経路は、上で $ 3,\ 5,\ 6 $ 番目に述べた $ 3 $ 個です。

### Sample Explanation 2

この例では、高橋君は考えられるどの経路を通っても嬉しくなります。

## 样例 #1

### 输入

```
3 3

3 2 2

2 1 3

1 5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
10 10

1 2 3 4 5 6 7 8 9 10

11 12 13 14 15 16 17 18 19 20

21 22 23 24 25 26 27 28 29 30

31 32 33 34 35 36 37 38 39 40

41 42 43 44 45 46 47 48 49 50

51 52 53 54 55 56 57 58 59 60

61 62 63 64 65 66 67 68 69 70

71 72 73 74 75 76 77 78 79 80

81 82 83 84 85 86 87 88 89 90

91 92 93 94 95 96 97 98 99 100```

### 输出

```
48620```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个 $H$ 行 $W$ 列的网格。对于满足 $1 \leq i \leq H$ 且 $1 \leq j \leq W$ 的两个整数 $i, j$，从上往下第 $i$ 行、从左往右第 $j$ 列的格子（记为 $(i, j)$）上写有一个整数 $A_{i, j}$。

现在，高桥君位于 $(1, 1)$。他将通过“从当前格子向右或向下移动到相邻的格子”这一操作，重复移动到 $(H, W)$。在此过程中，他不能移动到网格外部。

如果高桥君经过的所有格子（包括起点 $(1, 1)$ 和终点 $(H, W)$）上的整数都互不相同，那么他会感到开心。请输出高桥君所有可能的移动路径中，能使他感到开心的路径数量。

#### 说明/提示

##### 约束条件

- $2 \leq H, W \leq 10$
- $1 \leq A_{i, j} \leq 10^9$
- 输入均为整数

##### 样例解释 1

高桥君的移动路径有以下 6 种可能：

1. $(1, 1) \rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (3, 3)$：经过的整数为 $3, 2, 2, 3, 4$，高桥君不会感到开心。
2. $(1, 1) \rightarrow (1, 2) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (3, 3)$：经过的整数为 $3, 2, 1, 3, 4$，高桥君不会感到开心。
3. $(1, 1) \rightarrow (1, 2) \rightarrow (2, 2) \rightarrow (3, 2) \rightarrow (3, 3)$：经过的整数为 $3, 2, 1, 5, 4$，高桥君会感到开心。
4. $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (3, 3)$：经过的整数为 $3, 2, 1, 3, 4$，高桥君不会感到开心。
5. $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (3, 2) \rightarrow (3, 3)$：经过的整数为 $3, 2, 1, 5, 4$，高桥君会感到开心。
6. $(1, 1) \rightarrow (2, 1) \rightarrow (3, 1) \rightarrow (3, 2) \rightarrow (3, 3)$：经过的整数为 $3, 2, 1, 5, 4$，高桥君会感到开心。

因此，高桥君感到开心的移动路径有 3 种。

##### 样例解释 2

在这个例子中，高桥君无论选择哪种路径都会感到开心。

#### 样例 #1

##### 输入

```
3 3

3 2 2

2 1 3

1 5 4
```

##### 输出

```
3
```

#### 样例 #2

##### 输入

```
10 10

1 2 3 4 5 6 7 8 9 10

11 12 13 14 15 16 17 18 19 20

21 22 23 24 25 26 27 28 29 30

31 32 33 34 35 36 37 38 39 40

41 42 43 44 45 46 47 48 49 50

51 52 53 54 55 56 57 58 59 60

61 62 63 64 65 66 67 68 69 70

71 72 73 74 75 76 77 78 79 80

81 82 83 84 85 86 87 88 89 90

91 92 93 94 95 96 97 98 99 100
```

##### 输出

```
48620
```

### 算法分类

深度优先搜索 (DFS)

### 综合分析与结论

本题的核心是通过深度优先搜索（DFS）遍历所有可能的路径，并在遍历过程中检查路径上的数字是否互不相同。由于网格的规模较小（$H, W \leq 10$），DFS 是一种可行的解决方案。

### 评分较高的题解

#### 题解 1：作者：zajasi (赞：5)

**星级**：5星  
**关键亮点**：
- 使用 DFS 遍历所有可能的路径。
- 通过 `set` 数据结构来检查路径上的数字是否互不相同。
- 代码简洁且易于理解。

**核心代码**：
```cpp
void dfs(int dep, int x, int y) {
    if (x == n && y == m) {
        p[dep] = a[x][y];
        if (check(dep)) z++;
        return;
    }
    vis[x][y] = 1;
    p[dep] = a[x][y];
    for (int i = 0; i < 2; i++) {
        int tx = x + dx[i];
        int ty = y + dy[i];
        if (tx > 0 && tx <= n && ty > 0 && ty <= m && vis[tx][ty] == 0) dfs(dep + 1, tx, ty);
    }
    vis[x][y] = 0;
}
```

#### 题解 2：作者：Jerry_heng (赞：4)

**星级**：4星  
**关键亮点**：
- 使用 DFS 遍历所有可能的路径。
- 通过 `bool` 数组来记录数字是否已经出现过，避免了使用 `set` 的开销。
- 代码简洁且高效。

**核心代码**：
```cpp
void ss(int x, int y) {
    if (x == n && y == m) {
        ans++;
        return;
    }
    if (x < n && !b[a[x + 1][y]]) {
        b[a[x + 1][y]] = 1;
        ss(x + 1, y);
        b[a[x + 1][y]] = 0;
    }
    if (y < m && !b[a[x][y + 1]]) {
        b[a[x][y + 1]] = 1;
        ss(x, y + 1);
        b[a[x][y + 1]] = 0;
    }
}
```

#### 题解 3：作者：incra (赞：1)

**星级**：4星  
**关键亮点**：
- 使用 DFS 遍历所有可能的路径。
- 通过 `set` 数据结构来检查路径上的数字是否互不相同。
- 代码简洁且易于理解。

**核心代码**：
```cpp
void dfs(int x, int y, set<int> vis) {
    vis.insert(a[x][y]);
    if (x == n && y == m) {
        ans += vis.size() == n + m - 1;
        return;
    }
    if (x + 1 <= n) dfs(x + 1, y, vis);
    if (y + 1 <= m) dfs(x, y + 1, vis);
}
```

### 最优关键思路或技巧

1. **DFS 遍历**：通过 DFS 遍历所有可能的路径，确保不遗漏任何可能的路径。
2. **数据结构选择**：使用 `set` 或 `bool` 数组来记录路径上的数字是否已经出现过，确保路径上的数字互不相同。
3. **回溯**：在 DFS 过程中，及时回溯，避免重复访问和记录。

### 可拓展之处

1. **路径记录**：如果需要输出具体的路径，可以在 DFS 过程中记录路径。
2. **剪枝优化**：在 DFS 过程中，如果发现当前路径已经出现重复数字，可以提前剪枝，减少不必要的计算。

### 推荐题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)

### 个人心得摘录

- **调试经历**：在 DFS 过程中，忘记回溯导致路径记录错误，通过调试发现并修正了问题。
- **顿悟感想**：使用 `set` 数据结构可以方便地检查路径上的数字是否互不相同，简化了代码实现。

---
处理用时：48.95秒
# 题目信息

# [ABC294D] Bank

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc294/tasks/abc294_d

銀行に人 $ 1 $, 人 $ 2 $, $ \dots $, 人 $ N $ が並んでいます。  
 $ Q $ 個のイベントが発生します。イベントは次の $ 3 $ 種類のいずれかです。

- `1` : 受付に呼ばれていない人のうち、最も小さい番号の人が受付に呼ばれる。
- `2 x` : 人 $ x $ が初めて受付に行く。(ここで、人 $ x $ はすでに 1 回以上受付に呼ばれている。)
- `3` : すでに受付に呼ばれているが受付に行っていない人のうち、最も小さい番号の人が再度呼ばれる。
 
$ 3 $ 種類目のイベントで受付に呼ばれる人の番号を呼ばれた順に出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 2\ \leq\ Q\ \leq\ 5\ \times\ 10^5 $
- 全ての人が 1 回以上呼ばれているときに $ 1 $ 種類目のイベントが発生することはない
- $ 2 $ 種類目のイベントについて、人 $ x $ はすでに 1 回以上受付に呼ばれている
- $ 2 $ 種類目のイベントについて、人 $ x $ が 2 回以上受付に行くことはない
- 呼ばれている人が全員すでに受付に行っているときに $ 3 $ 種類目のイベントが発生することはない
- $ 3 $ 種類目のイベントは少なくとも 1 回発生する
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i\ =\ 1,\ 2,\ \dots,\ Q $ について、$ i $ 番目のイベントが起こる前の時点での、受付に呼ばれたが受付に行っていない人の集合を列挙すると次のようになります。 - $ i=1 $ : $ \lbrace\ \rbrace $ - $ i=2 $ : $ \lbrace\ 1\rbrace $ - $ i=3 $ : $ \lbrace\ 1,2\rbrace $ - $ i=4 $ : $ \lbrace\ 1,2\rbrace $ - $ i=5 $ : $ \lbrace\ 2\rbrace $ - $ i=6 $ : $ \lbrace\ 2,3\rbrace $ - $ i=7 $ : $ \lbrace\ 2\rbrace $ - $ i=8 $ : $ \lbrace\ 2\rbrace $ - $ i=9 $ : $ \lbrace\ 2,4\rbrace $ - $ i=10 $ : $ \lbrace\ 4\rbrace $ $ 3 $ 種類目のイベントは $ i=3,7,10 $ のときに発生しているので、その時点での集合のうち番号が最小の人である $ 1,\ 2,\ 4 $ を出力します。

## 样例 #1

### 输入

```
4 10

1

1

3

2 1

1

2 3

3

1

2 2

3```

### 输出

```
1

2

4```

# AI分析结果

### 题目内容重写
银行里有 $N$ 个人，编号分别为 $1, 2, \dots, N$，他们正在排队。接下来会发生 $Q$ 个事件，事件类型有以下三种：

1. `1`：呼叫当前未被呼叫过的人中编号最小的人。
2. `2 x`：编号为 $x$ 的人去前台办理业务（保证 $x$ 已经被呼叫过至少一次）。
3. `3`：呼叫已经被呼叫过但未去前台的人中编号最小的人，并输出其编号。

要求输出所有第 3 种事件中被呼叫的人的编号。

### 算法分类
模拟

### 题解分析与结论
本题的核心在于维护两个集合：一个存储未被呼叫过的人，另一个存储已被呼叫但未去前台的人。由于需要频繁查询和删除最小值，使用 `set` 数据结构是最优选择。大多数题解都采用了 `set` 来维护这两个集合，并通过模拟事件来处理操作。

### 精选题解

#### 题解1：作者 lottle1212 (5星)
**关键亮点**：
- 使用两个 `set` 分别维护未被呼叫的人和已被呼叫但未去前台的人，思路清晰。
- 代码简洁，模拟操作逻辑明确，易于理解。
- 通过 `set` 的自动排序特性，快速获取最小值。

**核心代码**：
```cpp
set<ll> pre, q; // pre: 未被呼叫的人, q: 已被呼叫但未去前台的人
while (T--) {
    op = rd();
    if (op == 1) {
        q.insert(*pre.begin());
        pre.erase(pre.begin());
    } else if (op == 2) {
        x = rd();
        q.erase(x);
    } else {
        cout << *q.begin() << '\n';
    }
}
```

#### 题解2：作者 As_Snow (4星)
**关键亮点**：
- 使用 `set` 维护已被呼叫但未去前台的人，并通过变量 `now` 记录当前未被呼叫的最小编号。
- 代码逻辑清晰，模拟操作处理得当。
- 通过 `set` 的有序性，快速获取最小值。

**核心代码**：
```cpp
set<int> wait; // 已被呼叫但未去前台的人
int now = 1; // 当前未被呼叫的最小编号
while (Q--) {
    cin >> opt;
    if (opt == 1) {
        wait.insert(now++);
    } else if (opt == 3) {
        cout << *wait.begin() << endl;
    } else if (opt == 2) {
        cin >> x;
        wait.erase(x);
    }
}
```

#### 题解3：作者 zajasi (4星)
**关键亮点**：
- 使用两个 `set` 分别维护未被呼叫的人和已被呼叫但未去前台的人，思路清晰。
- 代码简洁，模拟操作逻辑明确，易于理解。
- 通过 `set` 的自动排序特性，快速获取最小值。

**核心代码**：
```cpp
set<int> s1, s2; // s1: 未被呼叫的人, s2: 已被呼叫但未去前台的人
while (m--) {
    cin >> op;
    if (op == 1) {
        s2.insert(*s1.begin());
        s1.erase(*s1.begin());
    } else if (op == 2) {
        cin >> x;
        s2.erase(x);
    } else {
        cout << *s2.begin() << "\n";
    }
}
```

### 最优关键思路
使用 `set` 数据结构维护两个集合：一个存储未被呼叫的人，另一个存储已被呼叫但未去前台的人。通过 `set` 的自动排序特性，可以快速获取最小值，从而高效处理事件。

### 可拓展之处
类似的问题可以通过维护有序集合来处理，如优先队列、平衡树等。这类问题通常涉及频繁的插入、删除和查询最小值操作。

### 推荐题目
1. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：27.98秒
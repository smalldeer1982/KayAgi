# 题目信息

# [ABC300C] Cross

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc300/tasks/abc300_c

縦 $ H $ マス横 $ W $ マスのグリッドがあります。グリッドの上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と呼びます。  
 グリッドの各マスには `#` と `.` のいずれかの文字が書かれています。$ (i,\ j) $ に書かれている文字を $ C[i][j] $ とします。また、整数 $ i,\ j $ が $ 1\ \leq\ i\ \leq\ H $ と $ 1\ \leq\ j\ \leq\ W $ の少なくとも一方を満たさない場合、 $ C[i][j] $ を `.` と定義します。

正整数 $ a,\ b,\ n $ が以下の条件を全て満たす時、$ (a,b) $ および $ (a+d,b+d),(a+d,b-d),(a-d,b+d),(a-d,b-d) $ $ (1\ \leq\ d\ \leq\ n) $ の $ 4n\ +\ 1 $ マスを **$ (a,b) $ を中心とするサイズ $ n $ のバツ印** と呼びます。

- $ C[a][b] $ は `#` である。
- $ 1\ \leq\ d\ \leq\ n $ を満たす整数 $ d $ について、 $ C[a+d][b+d],C[a+d][b-d],C[a-d][b+d],C[a-d][b-d] $ はいずれも `#` である。
- $ C[a+n+1][b+n+1],C[a+n+1][b-n-1],C[a-n-1][b+n+1],C[a-n-1][b-n-1] $ のうち少なくとも 1 つは `.` である。
 
例えば次の図で示された例では、$ (2,\ 2) $ を中心とするサイズ $ 1 $ のバツ印と $ (3,\ 7) $ を中心とするサイズ $ 2 $ のバツ印がグリッド上にあります。

![image](https://img.atcoder.jp/ghi/abc300c_aa5161e20f55652dc61ad221348765bb002e4eed378c352bc0e44c7555148ebc.jpg)

グリッドにはいくつかのバツ印があります。バツ印を構成するマス以外に `#` は書かれていません。  
 また、異なるバツ印を構成するマス同士は頂点を共有しません。以下の 2 つのグリッドは異なるバツ印を構成するマス同士が頂点を共有している例で、**このようなグリッドの状態は入力として与えられません。** 例えば左のグリッドでは $ (3,\ 3) $ と $ (4,\ 4) $ が頂点を共有しているのが条件に反しています。

![image2](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc300_c/af4437e0a6d74885bdf21777218fa90fa4795735.png)

$ N\ =\ \min(H,\ W) $ とします。また、サイズ $ n $ のバツ印の個数を $ S_n $ とします。$ S_1,\ S_2,\ \dots,\ S_N $ を計算してください。

## 说明/提示

### 制約

- $ 3\ \leq\ H,\ W\ \leq\ 100 $
- $ C[i][j] $ は `#` または `.`
- 異なるバツ印を構成するマス同士は頂点を共有しない
- $ H,\ W $ は整数
 
### Sample Explanation 1

問題文に書かれた説明の通り、$ (2,\ 2) $ を中心とするサイズ $ 1 $ のバツ印と $ (3,\ 7) $ を中心とするサイズ $ 2 $ のバツ印が書かれています。

### Sample Explanation 2

バツ印が 1 個も書かれていない場合もあります。

## 样例 #1

### 输入

```
5 9

#.#.#...#

.#...#.#.

#.#...#..

.....#.#.

....#...#```

### 输出

```
1 1 0 0 0```

## 样例 #2

### 输入

```
3 3

...

...

...```

### 输出

```
0 0 0```

## 样例 #3

### 输入

```
3 16

#.#.....#.#..#.#

.#.......#....#.

#.#.....#.#..#.#```

### 输出

```
3 0 0```

## 样例 #4

### 输入

```
15 20

#.#..#.............#

.#....#....#.#....#.

#.#....#....#....#..

........#..#.#..#...

#.....#..#.....#....

.#...#....#...#..#.#

..#.#......#.#....#.

...#........#....#.#

..#.#......#.#......

.#...#....#...#.....

#.....#..#.....#....

........#.......#...

#.#....#....#.#..#..

.#....#......#....#.

#.#..#......#.#....#```

### 输出

```
5 0 1 0 0 0 1 0 0 0 0 0 0 0 0```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个 $H$ 行 $W$ 列的网格。网格的每个单元格中写有字符 `#` 或 `.`。我们定义 $(i, j)$ 为网格中第 $i$ 行第 $j$ 列的单元格，$C[i][j]$ 表示该单元格中的字符。对于不满足 $1 \leq i \leq H$ 或 $1 \leq j \leq W$ 的整数 $i, j$，定义 $C[i][j]$ 为 `.`。

当正整数 $a, b, n$ 满足以下所有条件时，我们称 $(a, b)$ 以及 $(a+d, b+d), (a+d, b-d), (a-d, b+d), (a-d, b-d)$（$1 \leq d \leq n$）这 $4n + 1$ 个单元格为以 $(a, b)$ 为中心的大小为 $n$ 的“十字架”：

1. $C[a][b]$ 是 `#`。
2. 对于所有 $1 \leq d \leq n$，$C[a+d][b+d], C[a+d][b-d], C[a-d][b+d], C[a-d][b-d]$ 都是 `#`。
3. $C[a+n+1][b+n+1], C[a+n+1][b-n-1], C[a-n-1][b+n+1], C[a-n-1][b-n-1]$ 中至少有一个是 `.`。

例如，下图中有以 $(2, 2)$ 为中心的大小为 $1$ 的十字架和以 $(3, 7)$ 为中心的大小为 $2$ 的十字架。

![image](https://img.atcoder.jp/ghi/abc300c_aa5161e20f55652dc61ad221348765bb002e4eed378c352bc0e44c7555148ebc.jpg)

网格中有若干个十字架，且十字架之外的单元格中没有 `#`。此外，不同十字架的单元格之间不会共享顶点。例如，下图中的两个网格不符合条件，因为不同十字架的单元格共享了顶点。

![image2](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc300_c/af4437e0a6d74885bdf21777218fa90fa4795735.png)

设 $N = \min(H, W)$，$S_n$ 表示大小为 $n$ 的十字架的个数。请计算 $S_1, S_2, \dots, S_N$。

#### 输入输出格式

**输入格式**  
第一行包含两个整数 $H$ 和 $W$，表示网格的行数和列数。  
接下来 $H$ 行，每行包含 $W$ 个字符，表示网格中的内容。

**输出格式**  
输出 $N$ 个整数，分别表示 $S_1, S_2, \dots, S_N$。

#### 样例

**样例 1**  
输入：
```
5 9
#.#.#...#
.#...#.#.
#.#...#..
.....#.#.
....#...#
```
输出：
```
1 1 0 0 0
```

**样例 2**  
输入：
```
3 3
...
...
...
```
输出：
```
0 0 0
```

**样例 3**  
输入：
```
3 16
#.#.....#.#..#.#
.#.......#....#.
#.#.....#.#..#.#
```
输出：
```
3 0 0
```

**样例 4**  
输入：
```
15 20
#.#..#.............#
.#....#....#.#....#.
#.#....#....#....#..
........#..#.#..#...
#.....#..#.....#....
.#...#....#...#..#.#
..#.#......#.#....#.
...#........#....#.#
..#.#......#.#......
.#...#....#...#.....
#.....#..#.....#....
........#.......#...
#.#....#....#.#..#..
.#....#......#....#.
#.#..#......#.#....#
```
输出：
```
5 0 1 0 0 0 1 0 0 0 0 0 0 0 0
```

### 算法分类
模拟

### 题解分析与结论

#### 综合分析
本题的核心是通过枚举每个可能的中心点，判断其是否能构成十字架，并统计不同大小的十字架数量。由于网格的大小较小（$H, W \leq 100$），可以直接使用暴力枚举的方法。

#### 题解评分与亮点
1. **CuteChat (5星)**  
   - 亮点：代码结构清晰，使用了方向数组简化了十字架的判断逻辑，且通过 `check` 函数避免了边界条件的重复判断。
   - 关键代码：
     ```cpp
     int cross(int i, int j) {
         if (s[i][j] == '.') return 0;
         int res = 0;
         for (int d = 1; ; ++d) {
             bool ok = 1;
             for (int k = 0; k < 4 && ok; ++k) {
                 int nx = i + d * dir[k][0], ny = j + d * dir[k][1];
                 if (check(nx, ny) && s[nx][ny] == '#');
                 else ok = 0;
             }
             if (ok) res = d;
             else break;
         }
         return res;
     }
     ```

2. **CheZiHe929 (4星)**  
   - 亮点：通过四个方向的独立判断，确保十字架的每个方向都满足条件，且通过 `min` 函数取最小值来确保十字架的大小。
   - 关键代码：
     ```cpp
     while(c[x][y]=='#') {
         x--, y--, m++;
     }
     d = m;
     ```

3. **small_john (4星)**  
   - 亮点：代码简洁，通过 `f` 函数直接计算十字架的最大大小，且通过 `ans` 数组直接统计结果。
   - 关键代码：
     ```cpp
     int f(int x, int y) {
         int ret = 0;
         while(x-ret-1>0 && x+ret+1<=n && y-ret-1>0 && y+ret+1<=m &&
               a[x-ret-1][y-ret-1]=='#' && a[x-ret-1][y+ret+1]=='#' &&
               a[x+ret+1][y-ret-1]=='#' && a[x+ret+1][y+ret+1]=='#') {
             ret++;
         }
         return ret;
     }
     ```

#### 最优关键思路
- **方向数组的使用**：通过定义方向数组 `dir`，简化了十字架四个方向的判断逻辑，避免了重复代码。
- **边界检查**：在枚举时，通过 `check` 函数确保不会越界，避免了对边界条件的重复判断。
- **暴力枚举**：由于网格大小较小，直接枚举每个可能的中心点，并通过循环判断其是否能构成十字架。

#### 可拓展之处
- **优化思路**：如果网格更大，可以考虑使用前缀和或其他优化手段来减少重复计算。
- **类似题目**：可以扩展到其他形状的图案统计，如矩形、菱形等。

#### 推荐题目
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

---
处理用时：44.42秒
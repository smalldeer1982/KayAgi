# 题目信息

# [ABC302D] Impartial Gift

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc302/tasks/abc302_d

高橋君は青木君とすぬけ君に **$ 1 $ つずつ**贈り物を送ることにしました。  
 青木君への贈り物の候補は $ N $ 個あり、 それぞれの価値は $ A_1,\ A_2,\ \ldots,A_N $ です。  
 すぬけ君への贈り物の候補は $ M $ 個あり、 それぞれの価値は $ B_1,\ B_2,\ \ldots,B_M $ です。

高橋君は $ 2 $ 人への贈り物の価値の差が $ D $ 以下になるようにしたいと考えています。

条件をみたすように贈り物を選ぶことが可能か判定し、可能な場合はそのような選び方における贈り物の価値の和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N,M\leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,B_i\leq\ 10^{18} $
- $ 0\leq\ D\ \leq\ 10^{18} $
- 入力はすべて整数
 
### Sample Explanation 1

高橋君は贈り物の価値の差を $ 2 $ 以下にする必要があります。 青木君に価値 $ 3 $, すぬけ君に価値 $ 5 $ の贈り物を渡すと条件をみたし、価値の和としてはこのときが最大となります。 よって、$ 3+5=8 $ を出力します。

### Sample Explanation 2

条件をみたすように贈り物を選ぶことは不可能です。 また、同一人物に対して、同じ価値の贈り物が複数存在することもあります。

### Sample Explanation 3

答えが $ 32 $ bit整数型の範囲に収まらないことがあることに注意してください。

## 样例 #1

### 输入

```
2 3 2

3 10

2 5 15```

### 输出

```
8```

## 样例 #2

### 输入

```
3 3 0

1 3 3

6 2 7```

### 输出

```
-1```

## 样例 #3

### 输入

```
1 1 1000000000000000000

1000000000000000000

1000000000000000000```

### 输出

```
2000000000000000000```

## 样例 #4

### 输入

```
8 6 1

2 5 6 5 2 1 7 9

7 2 5 5 2 4```

### 输出

```
14```

# AI分析结果

### 题目翻译
# [ABC302D] Impartial Gift

## 题目描述

高橋君要给青木君和すぬけ君各送一个礼物。  
青木君的礼物候选有 $N$ 个，每个礼物的价值分别为 $A_1, A_2, \ldots, A_N$。  
すぬけ君的礼物候选有 $M$ 个，每个礼物的价值分别为 $B_1, B_2, \ldots, B_M$。

高橋君希望两人礼物的价值差不超过 $D$。

判断是否可以选择满足条件的礼物，如果可以，求出这种情况下礼物价值之和的最大值。

## 说明/提示

### 约束

- $1 \leq N, M \leq 2 \times 10^5$
- $1 \leq A_i, B_i \leq 10^{18}$
- $0 \leq D \leq 10^{18}$
- 输入均为整数

### 样例解释 1

高橋君需要将礼物的价值差控制在 $2$ 以内。选择价值为 $3$ 的礼物给青木君，价值为 $5$ 的礼物给すぬけ君，满足条件且价值之和最大，输出 $3+5=8$。

### 样例解释 2

无法选择满足条件的礼物，输出 $-1$。

### 样例解释 3

答案可能超出 $32$ 位整数范围。

### 样例 #1

#### 输入

```
2 3 2

3 10

2 5 15
```

#### 输出

```
8
```

### 样例 #2

#### 输入

```
3 3 0

1 3 3

6 2 7
```

#### 输出

```
-1
```

### 样例 #3

#### 输入

```
1 1 1000000000000000000

1000000000000000000

1000000000000000000
```

#### 输出

```
2000000000000000000
```

### 样例 #4

#### 输入

```
8 6 1

2 5 6 5 2 1 7 9

7 2 5 5 2 4
```

#### 输出

```
14
```

### 算法分类
二分

### 题解分析与结论
本题的核心是通过二分查找优化暴力枚举，确保在 $O(n \log m)$ 或 $O(m \log n)$ 的时间复杂度内找到满足条件的最大价值对。大多数题解都采用了排序后二分查找的思路，部分题解还引入了双指针优化。

### 精选题解
1. **作者：FreedomKing**  
   - **星级：4**  
   - **关键亮点**：使用 `lower_bound` 进行二分查找，代码简洁且思路清晰。通过查找第一个大于 $A_i + D$ 的元素的前一个位置，确保找到满足条件的最大 $B_j$。  
   - **核心代码**：
     ```cpp
     int id = lower_bound(b+1, b+m+1, a[i]+D+1) - b - 1;
     if (abs(b[id] - a[i]) <= D) maxn = max(maxn, b[id] + a[i]);
     ```

2. **作者：_7Mr**  
   - **星级：4**  
   - **关键亮点**：提供了二分和双指针两种解法，思路全面。二分部分通过枚举 $B_i$ 并在 $A$ 中二分查找满足条件的 $A_j$，双指针部分则通过从大到小枚举，优化了查找过程。  
   - **核心代码**：
     ```cpp
     int tmp1 = upper_bound(b + 1, b + 1 + m, a[i] + d) - b - 1;
     if (tmp1 && b[tmp1] - a[i] <= d && b[tmp1] - a[i] >= 0) ans = max(ans, a[i] + b[tmp1]);
     ```

3. **作者：ran_qwq**  
   - **星级：4**  
   - **关键亮点**：通过枚举 $B_i$ 并在 $A$ 中二分查找满足条件的 $A_j$，思路清晰且代码简洁。特别强调了二分查找的边界处理，确保找到的最大值满足条件。  
   - **核心代码**：
     ```cpp
     int pos = upper_bound(a + 1, a + 1 + n, x + k) - a - 1;
     if (abs(a[pos] - x) <= k) ans = max(ans, x + a[pos]);
     ```

### 最优关键思路
1. **排序**：首先对两个数组进行排序，确保二分查找的单调性。
2. **二分查找**：通过 `lower_bound` 或 `upper_bound` 查找满足条件的最大或最小值，确保时间复杂度为 $O(n \log m)$ 或 $O(m \log n)$。
3. **边界处理**：特别注意二分查找的边界条件，确保找到的值满足 $|A_i - B_j| \leq D$。

### 可拓展之处
- **双指针优化**：在排序后，可以通过双指针从大到小枚举，进一步优化查找过程。
- **多条件二分**：可以扩展为多个条件的二分查找，如同时满足多个差值范围。

### 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)

### 个人心得摘录
- **调试经历**：部分题解提到在二分查找时需要注意边界条件，特别是当查找的值不存在时，需要正确处理返回值。
- **踩坑教训**：在二分查找时，未排序的数组会导致查找失败，因此排序是二分查找的前提。
- **顿悟感想**：通过二分查找优化暴力枚举，可以大幅减少时间复杂度，适用于大规模数据处理的场景。

---
处理用时：34.95秒
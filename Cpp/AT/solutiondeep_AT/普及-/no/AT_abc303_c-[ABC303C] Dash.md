# 题目信息

# [ABC303C] Dash

## 题目描述

现在高桥在一个二维平面上。初始时他在 $(0,0)$ 处，生命值为 $H$。平面上有 $M$ 个可以恢复生命值的物品，其中第 $i$ 个物品的位置为 $(x_i,y_i)$。

高桥将要进行 $N$ 次移动，第 $i$ 次移动的方式如下：

- 设高桥现在的位置是 $(x,y)$，那么他将会消耗 $1$ 点生命值，同时：
  - 如果 $S_i=\texttt R$，移动到 $(x+1,y)$；
  - 如果 $S_i=\texttt L$，移动到 $(x-1,y)$；
  - 如果 $S_i=\texttt U$，移动到 $(x,y+1)$；
  - 如果 $S_i=\texttt D$，移动到 $(x,y-1)$。
- 如果高桥的生命值降为负数，他就会倒下无法行动；否则，如果当前位置有一个可以恢复生命值的物品，且当前生命值小于 $K$，那么生命值将会恢复到 $K$。

请判断高桥能否进行完所有的移动而不倒下。

#### 数据范围与约定

$1\le N,M,H,K\le2\times10^5$，$|x_i|,|y_i|\le2\times10^5$。

保证 $S$ 是一个只由字符 `R`、`L`、`U`、`D` 构成的长度为 $N$ 的字符串。保证 $(x_i,y_i)$ 两两不同。保证所有输入的数均为整数。

## 样例 #1

### 输入

```
4 2 3 1

RUDL

-1 -1

1 0```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5 2 1 5

LDRLD

0 0

-1 -1```

### 输出

```
No```

# AI分析结果

【题目内容】
# [ABC303C] Dash

## 题目描述

现在高桥在一个二维平面上。初始时他在 $(0,0)$ 处，生命值为 $H$。平面上有 $M$ 个可以恢复生命值的物品，其中第 $i$ 个物品的位置为 $(x_i,y_i)$。

高桥将要进行 $N$ 次移动，第 $i$ 次移动的方式如下：

- 设高桥现在的位置是 $(x,y)$，那么他将会消耗 $1$ 点生命值，同时：
  - 如果 $S_i=\texttt R$，移动到 $(x+1,y)$；
  - 如果 $S_i=\texttt L$，移动到 $(x-1,y)$；
  - 如果 $S_i=\texttt U$，移动到 $(x,y+1)$；
  - 如果 $S_i=\texttt D$，移动到 $(x,y-1)$。
- 如果高桥的生命值降为负数，他就会倒下无法行动；否则，如果当前位置有一个可以恢复生命值的物品，且当前生命值小于 $K$，那么生命值将会恢复到 $K$。

请判断高桥能否进行完所有的移动而不倒下。

#### 数据范围与约定

$1\le N,M,H,K\le2\times10^5$，$|x_i|,|y_i|\le2\times10^5$。

保证 $S$ 是一个只由字符 `R`、`L`、`U`、`D` 构成的长度为 $N$ 的字符串。保证 $(x_i,y_i)$ 两两不同。保证所有输入的数均为整数。

## 样例 #1

### 输入

```
4 2 3 1

RUDL

-1 -1

1 0```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5 2 1 5

LDRLD

0 0

-1 -1```

### 输出

```
No```

【算法分类】
模拟

【题解分析与结论】
本题的核心是模拟高桥的移动过程，并在每一步中检查生命值和是否到达恢复生命值的位置。由于数据范围较大，直接使用二维数组存储恢复物品的位置会导致内存不足，因此需要使用更高效的数据结构来存储和查询恢复物品的位置。

各题解的主要思路是使用 `set` 或 `map` 来存储恢复物品的位置，并在每一步移动后检查当前位置是否有恢复物品。部分题解还使用了二分查找来优化查询效率。

【评分较高的题解】
1. **作者：__Emerald__ (4星)**
   - **关键亮点**：使用 `set` 存储恢复物品的位置，复杂度为 $O(N + M \log M)$，代码简洁且高效。
   - **代码核心**：
     ```cpp
     set<pair<int, int> > st;
     for(int i = 0;i < m;i++){
         int x,y;
         cin >> x >> y;
         st.insert({x, y});
     }
     for(int i = 0;i < n;i++) {
         int dx = 0,dy = 0;
         if(s[i] == 'R') dx = 1;
         if(s[i] == 'L') dx = -1;
         if(s[i] == 'U') dy = 1;
         if(s[i] == 'D') dy = -1;
         nx += dx,ny += dy;
         if(--h < 0) {
             cout << "No\n";
             return 0;
         }
         if(h < k and st.count({nx, ny})) {
             h = k;
             st.erase({nx, ny});
         }
     }
     ```

2. **作者：0xyz (4星)**
   - **关键亮点**：使用 `map` 存储恢复物品的位置，代码结构清晰，逻辑严谨。
   - **代码核心**：
     ```cpp
     map<pair<ll,ll>,bool>a;
     for(ll i=1,X,Y;i<=m;i++){
         cin>>X>>Y;
         a[{X,Y}]=1;
     }
     for(ll i=0;i<n;i++){
         if(s[i]=='U')y++;
         else if(s[i]=='D')y--;
         else if(s[i]=='L')x--;
         else if(s[i]=='R')x++;
         h--;
         if(h<0){
             cout<<"No"<<'\n';
             return 0;
         }
         if(a[{x,y}]&&h<k)h=k,a[{x,y}]=0;
     }
     ```

3. **作者：Crazyouth (4星)**
   - **关键亮点**：使用 `map` 存储恢复物品的位置，代码简洁且易于理解。
   - **代码核心**：
     ```cpp
     map<pair<int,int>,int> mp;
     for(int i=1;i<=m;i++){
         cin>>x>>y;
         mp[{x,y}]=1;
     }
     for(int i=0;i<n;i++){
         if(s[i]=='L')x--;
         else if(s[i]=='R')x++;
         else if(s[i]=='U')y++;
         else if(s[i]=='D')y--;
         h--;
         if(h<0){
             cout<<"No";
             return 0;
         }
         if(mp[{x,y}]&&h<k){
             h=k;
             mp[{x,y}]=0;
         }
     }
     ```

【最优关键思路或技巧】
- 使用 `set` 或 `map` 来存储恢复物品的位置，可以在 $O(\log M)$ 的时间内查询当前位置是否有恢复物品。
- 在每一步移动后，先减少生命值，再检查是否需要恢复生命值，确保逻辑正确。

【可拓展之处】
- 类似的问题可以扩展到三维空间，或者增加更多的条件（如恢复物品的使用次数限制）。
- 可以结合其他算法（如最短路算法）来优化路径选择。

【推荐题目】
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

---
处理用时：32.14秒
# 题目信息

# [ABC304C] Virus

## 题目描述

编号为 $1\sim N$ 的人站在二维平面上，编号为 $i$ 的人在坐标 $(X_i,Y_i)$ 上。

现在编号为 $1$ 的人患上了一种病毒，并可以传染到与感染者距离 $D$ 以内的其它人身上。定义两个点的距离为其直线距离，即两个点 $(a_1,b_1)$ 与 $(a_2,b_2)$ 的距离为 $\sqrt{(a_1-a_2)^2+(b_1-b_2)^2}$。请你判断，在足够的时间之后，每个人是否会被感染。

## 说明/提示

- $1\le N,D\le2000$。
- $-1000\le X_i,Y_y\le 1000$
- 坐标互不相同。
- 输入的所有数据均为整数。

## 样例 #1

### 输入

```
4 5

2 -1

3 1

8 8

0 5```

### 输出

```
Yes

Yes

No

Yes```

## 样例 #2

### 输入

```
3 1

0 0

-1000 -1000

1000 1000```

### 输出

```
Yes

No

No```

## 样例 #3

### 输入

```
9 4

3 2

6 -1

1 6

6 5

-2 -3

5 3

2 -3

2 1

2 6```

### 输出

```
Yes

No

No

Yes

Yes

Yes

Yes

Yes

No```

# AI分析结果

【题目内容】
# [ABC304C] Virus

## 题目描述

编号为 $1\sim N$ 的人站在二维平面上，编号为 $i$ 的人在坐标 $(X_i,Y_i)$ 上。

现在编号为 $1$ 的人患上了一种病毒，并可以传染到与感染者距离 $D$ 以内的其它人身上。定义两个点的距离为其直线距离，即两个点 $(a_1,b_1)$ 与 $(a_2,b_2)$ 的距离为 $\sqrt{(a_1-a_2)^2+(b_1-b_2)^2}$。请你判断，在足够的时间之后，每个人是否会被感染。

## 说明/提示

- $1\le N,D\le2000$。
- $-1000\le X_i,Y_y\le 1000$
- 坐标互不相同。
- 输入的所有数据均为整数。

## 样例 #1

### 输入

```
4 5

2 -1

3 1

8 8

0 5```

### 输出

```
Yes

Yes

No

Yes```

## 样例 #2

### 输入

```
3 1

0 0

-1000 -1000

1000 1000```

### 输出

```
Yes

No

No```

## 样例 #3

### 输入

```
9 4

3 2

6 -1

1 6

6 5

-2 -3

5 3

2 -3

2 1

2 6```

### 输出

```
Yes

No

No

Yes

Yes

Yes

Yes

Yes

No```

【算法分类】
广度优先搜索 BFS

【题解分析与结论】
本题的核心是通过广度优先搜索（BFS）或深度优先搜索（DFS）来模拟病毒的传播过程。由于题目要求判断每个人是否会被感染，且病毒传播的范围是欧几里得距离小于等于 $D$，因此可以使用 BFS 或 DFS 来遍历所有可能被感染的人。

【评分较高的题解】
1. **作者：cjh20090318 (赞：4)**
   - **星级：4**
   - **关键亮点：**
     - 使用 BFS 进行病毒传播的模拟，代码简洁明了。
     - 通过队列实现 BFS，避免了递归可能带来的栈溢出问题。
     - 在判断距离时，直接比较平方值，避免了开方运算，提高了效率。
   - **核心代码：**
     ```cpp
     bool dis(int x,int y,int X,int Y){
         return (X-x)*(X-x)+(Y-y)*(Y-y)<=d*d;
     }
     std::queue<int> Q;
     Q.push(1);
     for(int u;!Q.empty();){
         u=Q.front();Q.pop();
         if(v[u]) continue;
         v[u]=1;
         for(int j=1;j<=n;j++)
             if(j!=u && dis(xx[u],yy[u],xx[j],yy[j]) && !v[j])
                 Q.push(j);
     }
     ```

2. **作者：DengDuck (赞：0)**
   - **星级：4**
   - **关键亮点：**
     - 使用 BFS 进行病毒传播的模拟，代码结构清晰。
     - 通过队列实现 BFS，避免了递归可能带来的栈溢出问题。
     - 在判断距离时，直接比较平方值，避免了开方运算，提高了效率。
   - **核心代码：**
     ```cpp
     LL cal(LL i,LL j){
         return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
     }
     queue<LL>q;
     q.push(1);
     while(!q.empty()){
         LL t=q.front();
         q.pop();
         for(int i=1;i<=n;i++){
             if(!vis[i] && cal(t,i)<=d*d){
                 vis[i]=1;
                 q.push(i);
             }
         }
     }
     ```

3. **作者：CheZiHe929 (赞：0)**
   - **星级：4**
   - **关键亮点：**
     - 提供了 BFS 和 DFS 两种实现方式，代码结构清晰。
     - 在判断距离时，直接比较平方值，避免了开方运算，提高了效率。
     - 通过栈和队列分别实现 DFS 和 BFS，展示了两种不同的搜索方式。
   - **核心代码：**
     ```cpp
     double distance=sqrt(pow(x[now]-x[i],2)+pow(y[now]-y[i],2));
     if(i!=now&&!vis[i]&&distance<=d){
         vis[i]=1;
         s.push(i);
     }
     ```

【最优关键思路或技巧】
- **避免开方运算：** 在判断两个点之间的距离时，直接比较平方值，而不是计算平方根，这样可以提高代码的效率。
- **使用队列实现 BFS：** 通过队列实现 BFS，可以避免递归可能带来的栈溢出问题，并且代码结构更加清晰。
- **标记已访问节点：** 在 BFS 或 DFS 过程中，及时标记已访问的节点，避免重复访问，提高算法效率。

【可拓展之处】
- **类似算法套路：** 类似的传播问题（如信息传播、疾病传播等）都可以使用 BFS 或 DFS 来模拟传播过程。
- **图论中的应用：** 本题可以看作是一个图的连通性问题，BFS 和 DFS 是解决这类问题的常用方法。

【推荐题目】
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

---
处理用时：33.39秒
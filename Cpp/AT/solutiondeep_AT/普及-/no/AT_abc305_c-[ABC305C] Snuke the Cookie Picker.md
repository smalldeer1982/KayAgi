# 题目信息

# [ABC305C] Snuke the Cookie Picker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc305/tasks/abc305_c

縦 $ H $ マス, 横 $ W $ マスのグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と呼びます。  
 はじめ、グリッド上には、ある **縦横 $ 2 $ マス以上** の部分長方形の内部にあるマスにクッキーが 1 枚ずつ置かれていて、それ以外のマスにはクッキーが置かれていません。  
 形式的に説明すると、以下の条件を全て満たす 4 つの整数の組 $ (a,b,c,d) $ がただ 1 つ存在します。

- $ 1\ \leq\ a\ \lt\ b\ \leq\ H $
- $ 1\ \leq\ c\ \lt\ d\ \leq\ W $
- グリッド上のマスのうち、$ a\ \leq\ i\ \leq\ b,\ c\ \leq\ j\ \leq\ d $ を満たす全てのマス $ (i,\ j) $ にはクッキーが 1 枚ずつ置かれていて、それ以外のマスにはクッキーが置かれていない。
 
ところが、すぬけ君がグリッド上のクッキーのどれか 1 枚を取って食べてしまいました。  
 すぬけ君がクッキーを取ったマスは、クッキーが置かれていない状態に変わります。

すぬけ君がクッキーを食べた後のグリッドの状態が入力として与えられます。  
 マス $ (i,\ j) $ の状態は文字 $ S_{i,j} $ として与えられて、`#` はクッキーが置かれているマスを, `.` はクッキーが置かれていないマスを意味します。  
 すぬけ君が食べたクッキーが元々置かれていたマスを答えてください。(答えは一意に定まります。)

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 500 $
- $ S_{i,j} $ は `#` または `.`
 
### Sample Explanation 1

はじめ、クッキーは $ (2,\ 3) $ を左上、$ (4,\ 5) $ を右下とする部分長方形の内部にあるマスに置かれていて、すぬけ君は $ (2,\ 4) $ にあるクッキーを食べたことがわかります。よって $ (2,\ 4) $ を出力します。

### Sample Explanation 2

はじめ、クッキーは $ (1,\ 1) $ を左上、$ (3,\ 2) $ を右下とする部分長方形の内部にあるマスに置かれていて、すぬけ君は $ (1,\ 2) $ にあるクッキーを食べたことがわかります。

## 样例 #1

### 输入

```
5 6

......

..#.#.

..###.

..###.

......```

### 输出

```
2 4```

## 样例 #2

### 输入

```
3 2

#.

##

##```

### 输出

```
1 2```

## 样例 #3

### 输入

```
6 6

..####

..##.#

..####

..####

..####

......```

### 输出

```
2 5```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个高度为 $H$，宽度为 $W$ 的网格。从上到下第 $i$ 行，从左到右第 $j$ 列的格子记为 $(i, j)$。  
最初，网格上有一个 **至少 $2 \times 2$** 的内部矩形区域，其中每个格子上都有一块饼干，其他格子上没有饼干。  
形式化地说，存在唯一的四元组 $(a, b, c, d)$，满足以下条件：

- $1 \leq a < b \leq H$
- $1 \leq c < d \leq W$
- 网格中所有满足 $a \leq i \leq b$ 且 $c \leq j \leq d$ 的格子 $(i, j)$ 上都有一块饼干，其他格子上没有饼干。

然而，Snuke 从网格中取走了一块饼干，该格子变为空。  
现在给出 Snuke 取走饼干后的网格状态，请找出 Snuke 取走的饼干所在的格子。（答案唯一）

#### 输入格式

输入的第一行包含两个整数 $H$ 和 $W$，表示网格的高度和宽度。  
接下来 $H$ 行，每行包含 $W$ 个字符，表示网格的状态。字符 `#` 表示有饼干，字符 `.` 表示没有饼干。

#### 输出格式

输出 Snuke 取走的饼干所在的格子的坐标 $(i, j)$。

#### 样例

**样例 1**

输入：
```
5 6

......

..#.#.

..###.

..###.

......
```

输出：
```
2 4
```

**样例 2**

输入：
```
3 2

#.

##

##
```

输出：
```
1 2
```

**样例 3**

输入：
```
6 6

..####

..##.#

..####

..####

..####

......
```

输出：
```
2 5
```

### 算法分类
模拟

### 题解分析与结论

本题的核心是通过模拟网格中的饼干分布，找到被取走的饼干所在的格子。由于原饼干区域是一个至少 $2 \times 2$ 的矩形，且被取走的饼干位于该矩形内部，因此可以通过以下步骤解决：

1. **确定矩形边界**：通过遍历网格，找到所有有饼干的格子的最小和最大行、列坐标，确定矩形的边界。
2. **查找缺失的饼干**：在确定的矩形范围内，遍历每个格子，找到唯一一个没有饼干的格子，即为被取走的饼干所在的位置。

### 评分较高的题解

#### 题解1：_Ad_Astra_ (5星)
**关键亮点**：
- 通过遍历网格确定矩形边界，思路清晰。
- 代码简洁，时间复杂度为 $O(H \times W)$，适合大规模数据。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        cin>>mp[i][j];
        if(mp[i][j]=='#')a=min(a,i),b=max(b,i),c=min(c,j),d=max(d,j);
    }
for(int i=a;i<=b;i++)
    for(int j=c;j<=d;j++)
        if(mp[i][j]=='.')
            cout<<i<<" "<<j;
```

#### 题解2：WhxStar2024 (4星)
**关键亮点**：
- 通过标记周围有饼干的格子，判断被取走的饼干位置。
- 思路新颖，代码实现简单。

**核心代码**：
```cpp
for(int i=1;i<=h;i++)
    for(int j=1;j<=w;j++)
        if(a[i][j]=='#')
        {
            b[i+1][j]++;
            b[i-1][j]++;
            b[i][j+1]++;
            b[i][j-1]++;
        }
for(int i=1;i<=h;i++)
    for(int j=1;j<=w;j++)
        if(a[i][j]=='.' && b[i][j]>=2)
        {
            cout<<i<<" "<<j;
            return 0;
        }
```

#### 题解3：_Kamisato_Ayaka_ (4星)
**关键亮点**：
- 通过判断周围有饼干的格子数量，快速定位被取走的饼干位置。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if((mp[i+1][j]=='#')+(mp[i-1][j]=='#')+(mp[i][j-1]=='#')+(mp[i][j+1]=='#')>=2 && mp[i][j]=='.')
        {
            cout<<i<<" "<<j<<endl;
            return 0;
        }
```

### 最优关键思路
通过遍历网格确定矩形边界，然后在边界内查找唯一一个没有饼干的格子，即为被取走的饼干所在的位置。这种方法时间复杂度低，适合大规模数据。

### 可拓展之处
类似的问题可以通过确定边界或标记周围状态来解决，例如在图像处理中查找缺失的像素点，或在矩阵中查找特定模式的缺失部分。

### 推荐题目
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

---
处理用时：33.24秒
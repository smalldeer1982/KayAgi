# 题目信息

# [ABC306D] Poisonous Full-Course

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc306/tasks/abc306_d

高橋くんはレストランで、 $ N $ 品からなる奇妙なフルコースを楽しむことにしました。  
 このコースのうち $ i $ 番目の料理は以下の通りです。

- $ X_i=0 $ の場合、美味しさが $ Y_i $ の **解毒剤入り** の料理
- $ X_i=1 $ の場合、美味しさが $ Y_i $ の **毒入り** の料理
 
高橋くんが料理を食べると、高橋くんの状態は以下のように変化します。

- 最初、高橋くんはお腹を壊していない。
- 高橋くんが **お腹を壊していない** 時、
  - **解毒剤入り** の料理を食べても、高橋くんは **お腹を壊していないまま** である。
  - **毒入り** の料理を食べると、高橋くんは **お腹を壊す** 。
- 高橋くんが **お腹を壊している** 時、
  - **解毒剤入り** の料理を食べると、高橋くんは **お腹を壊していない状態になる** 。
  - **毒入り** の料理を食べると、高橋くんは **死ぬ** 。
 
コースは以下の流れで進行します。

- $ i\ =\ 1,\ \ldots,\ N $ についてこの順に、以下の処理を繰り返す。
  - まず、 $ i $ 番目の料理が高橋くんに提供される。
  - 次に、 高橋くんはこの料理に対し「食べる」か「下げてもらう」かを選択する。
      - 「食べる」を選択した場合、高橋くんは $ i $ 番目の料理を食べる。食べた料理に応じて高橋くんの状態も変化する。
      - 「下げてもらう」を選択した場合、高橋くんは $ i $ 番目の料理を食べない。この料理を後で提供してもらったり何らかの手段で保存したりすることはできない。
  - 最後に、 (状態が変化するなら変化後の時点で) 高橋くんが死んでいない場合、
      - $ i\ \neq\ N $ なら次の料理に進む。
      - $ i\ =\ N $ なら高橋くんは生きて退店する。
 
高橋くんはこのあと重要な仕事があるため、高橋くんは生きて退店しなければなりません。  
 この条件の下で高橋くんが各料理に対し「食べる」「下げてもらう」を選択したとき、高橋くんが **食べた料理の美味しさの総和として考えられる最大値** ( 但し、何も食べなかった場合は $ 0 $ ) を出力してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ X_i\ \in\ \{0,1\} $
  - つまり、 $ X_i $ は $ 0,1 $ のどちらかである。
- $ -10^9\ \le\ Y_i\ \le\ 10^9 $
 
### Sample Explanation 1

以下のように選択することで食べた料理の美味しさの総和を $ 600 $ にでき、これが考えられる最大値です。 - $ 1 $ 番目の料理を下げてもらう。高橋くんはお腹を壊していません。 - $ 2 $ 番目の料理を食べる。高橋くんはお腹を壊し、食べた料理の美味しさの総和は $ 300 $ となります。 - $ 3 $ 番目の料理を食べる。高橋くんはお腹を壊していない状態に戻り、食べた料理の美味しさの総和は $ 100 $ となります。 - $ 4 $ 番目の料理を食べる。高橋くんはお腹を壊し、食べた料理の美味しさの総和は $ 600 $ となります。 - $ 5 $ 番目の料理を下げてもらう。高橋くんはお腹を壊しています。 - 最終的に高橋くんは死んでいないので、高橋くんは生きて退店する。

### Sample Explanation 2

この入力の場合何も食べないことが最善ですが、この場合答えは $ 0 $ となります。

### Sample Explanation 3

答えが $ 32 $ bit 符号付き整数に収まらない可能性があります。

## 样例 #1

### 输入

```
5

1 100

1 300

0 -200

1 500

1 300```

### 输出

```
600```

## 样例 #2

### 输入

```
4

0 -1

1 -2

0 -3

1 -4```

### 输出

```
0```

## 样例 #3

### 输入

```
15

1 900000000

0 600000000

1 -300000000

0 -700000000

1 200000000

1 300000000

0 -600000000

1 -900000000

1 600000000

1 -100000000

1 -400000000

0 900000000

0 200000000

1 -500000000

1 900000000```

### 输出

```
4100000000```

# AI分析结果

### 题目内容重写

高桥君在一家餐厅享用一顿由 $N$ 道菜组成的特别菜单。每道菜有以下定义：

- 如果 $X_i=0$，那么是一道有着 $Y_i$ 美味度的解毒菜。
- 如果 $X_i=1$，那么是一道有着 $Y_i$ 美味度的有毒菜。

当高桥君吃一道菜时，他的状态会发生以下变化：

初始状态下，高桥君的胃很健康。

- 当他的胃很健康时，如果他吃了一道解毒菜，他的胃仍然很健康。如果他吃了一道有毒菜，他的胃会不舒服。
- 当他的胃不舒服时，如果他吃了一道解毒菜，他的胃会变得健康。如果他吃了一道有毒菜，他会死亡。

就餐时按照顺序重复以下过程，对于 $i=1,2,3,\dots N$：

1. 首先，第 $i$ 道菜被端到高桥君面前。
2. 然后，他选择是否“吃下”或“跳过”这道菜。
   - 如果他选择“吃下”，他会吃掉第 $i$ 道菜。
   - 如果他选择“跳过”，他不会吃掉第 $i$ 道菜。

**他的状态也会根据所吃的菜而改变。**

求进行 $N$ 轮后，没有死亡的高桥君能吃到的最大美味值。

### 算法分类

动态规划

### 题解分析与结论

本题的核心在于通过动态规划来模拟高桥君在每道菜选择吃或不吃后的状态变化，并计算最大美味值。各题解均采用了动态规划的思路，但实现细节和优化程度有所不同。

### 评分较高的题解

#### 题解1：作者：c1ampy (赞：10)
- **星级：5星**
- **关键亮点**：
  - 详细解释了动态规划的三要素（阶段、状态、决策）如何与题目对应。
  - 提供了状态转移方程的详细推导，并进一步优化了空间复杂度，使用滚动数组将空间复杂度优化到 $O(1)$。
  - 代码简洁且高效，易于理解。

```cpp
#include <iostream>
using namespace std;

int main() {
    long long healthy = 0, upset = 0;
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        long long type, tastiness;
        scanf("%lld %lld", &type, &tastiness);
        if (type) {
            upset = max(upset, healthy + tastiness);
        } else {
            healthy = max(healthy, max(upset, healthy) + tastiness);
        }
    }
    printf("%lld\n", max(upset, healthy));
    return 0;
}
```

#### 题解2：作者：hellolin (赞：1)
- **星级：4星**
- **关键亮点**：
  - 采用了经典的二维动态规划，状态转移方程清晰。
  - 代码结构清晰，易于理解，但未进行空间优化。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

constexpr static int N=3e5+11;
int n;
bool x;
int y;
int dp[N][2];
void solve(){
    cin >> n;
    for(int i=1; i<=n; i++){
        cin >> x >> y;
        if(!x) {
            dp[i][0]=max({dp[i-1][0]+y,dp[i-1][0],dp[i-1][1]+y});
            dp[i][1]=dp[i-1][1];
        } else {
            dp[i][0]=dp[i-1][0];
            dp[i][1]=max({dp[i-1][0]+y,dp[i-1][1]});
        }
    }
    cout << max(dp[n][0], dp[n][1]) << endl;
}

int32_t main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    solve();
    return 0;
}
```

#### 题解3：作者：_7Mr (赞：1)
- **星级：4星**
- **关键亮点**：
  - 同样采用了二维动态规划，状态转移方程清晰。
  - 代码结构清晰，但未进行空间优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define INF 0x3fff
using namespace std;
const int maxn=3e5+5;
int n;
struct node {
	int x,y;
} a[maxn];
int dp[5][maxn];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i].x>>a[i].y;
	for(int i=1; i<=n; i++) {
		if(a[i].x==0) {
			dp[0][i]=max(dp[0][i-1],max(dp[0][i-1]+a[i].y,dp[1][i-1]+a[i].y));
			dp[1][i]=dp[1][i-1];
		} else {
			dp[1][i]=max(dp[0][i-1]+a[i].y,dp[1][i-1]);
			dp[0][i]=dp[0][i-1];
		}
	}
	if(max(dp[1][n],dp[0][n])>=0) cout<<max(dp[1][n],dp[0][n])<<endl;
	else cout<<0<<endl;
	return 0;
}
```

### 最优关键思路与技巧

1. **动态规划状态设计**：通过设计 $dp[i][j]$ 表示在第 $i$ 道菜后，高桥君的状态为 $j$（0表示健康，1表示不适）时的最大美味值。
2. **状态转移方程**：根据菜的类型（解毒或有毒）和当前状态，推导出不同的状态转移方程。
3. **空间优化**：使用滚动数组将空间复杂度优化到 $O(1)$，减少内存使用。

### 可拓展之处

类似的状态转移问题在动态规划中非常常见，例如背包问题、最长公共子序列等。掌握状态设计和转移方程的推导是解决这类问题的关键。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)

---
处理用时：35.19秒
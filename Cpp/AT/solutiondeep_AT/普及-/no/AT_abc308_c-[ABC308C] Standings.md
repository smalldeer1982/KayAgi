# 题目信息

# [ABC308C] Standings

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc308/tasks/abc308_c

$ 1 $ から $ N $ の番号が付いた $ N $ 人がコイントスを何回かしました。人 $ i $ は $ A_i $ 回表を出し、$ B_i $ 回裏を出したこと分かっています。

人 $ i $ のコイントスの **成功率** は $ \displaystyle\frac{A_i}{A_i+B_i} $ で定義されます。人 $ 1,\ldots,N $ の番号を、成功率の高い順に並び替えてください。成功率が同じ人が複数いる場合、その中では人の番号が小さい順になるように並び替えてください。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\leq\ A_i,\ B_i\leq\ 10^9 $
- $ A_i+B_i\ \geq\ 1 $
- 入力される数値は全て整数
 
### Sample Explanation 1

人 $ 1 $ の成功率は $ 0.25 $、人 $ 2 $ の成功率は $ 0.75 $、人 $ 3 $ の成功率は $ 0.5 $ です。 成功率の高い順に並び替えると出力例の順番になります。

### Sample Explanation 2

人 $ 1,2 $ は成功率が同じなので、番号の昇順に出力することに注意してください。

## 样例 #1

### 输入

```
3

1 3

3 1

2 2```

### 输出

```
2 3 1```

## 样例 #2

### 输入

```
2

1 3

2 6```

### 输出

```
1 2```

## 样例 #3

### 输入

```
4

999999999 1000000000

333333333 999999999

1000000000 999999997

999999998 1000000000```

### 输出

```
3 1 4 2```

# AI分析结果

### 题目内容重写

【题目描述】

有编号从 $1$ 到 $N$ 的 $N$ 个人进行了若干次抛硬币。已知第 $i$ 个人抛出了 $A_i$ 次正面和 $B_i$ 次反面。

第 $i$ 个人的**成功率**定义为 $ \displaystyle\frac{A_i}{A_i+B_i} $。请将编号为 $1$ 到 $N$ 的人按照成功率从高到低的顺序排序。如果成功率相同，则按照编号从小到大的顺序排序。

【说明/提示】

#### 约束条件

- $2 \leq N \leq 2 \times 10^5$
- $0 \leq A_i, B_i \leq 10^9$
- $A_i + B_i \geq 1$
- 输入的所有数值都是整数

#### 样例解释 1

第 $1$ 个人的成功率是 $0.25$，第 $2$ 个人的成功率是 $0.75$，第 $3$ 个人的成功率是 $0.5$。按照成功率从高到低排序，输出顺序如样例所示。

#### 样例解释 2

第 $1$ 和第 $2$ 个人的成功率相同，因此按照编号升序输出。

#### 样例 #1

##### 输入

```
3
1 3
3 1
2 2
```

##### 输出

```
2 3 1
```

#### 样例 #2

##### 输入

```
2
1 3
2 6
```

##### 输出

```
1 2
```

#### 样例 #3

##### 输入

```
4
999999999 1000000000
333333333 999999999
1000000000 999999997
999999998 1000000000
```

##### 输出

```
3 1 4 2
```

### 算法分类

排序

### 题解分析与结论

该题的核心逻辑是对一组数据进行自定义排序，排序的依据是成功率（$\frac{A_i}{A_i+B_i}$），若成功率相同则按编号升序排列。由于涉及到浮点数计算，需要注意精度问题。

### 所选高分题解

#### 题解1：Elairin176 (赞：0)

**星级：4星**

**关键亮点：**
- 使用结构体存储每个人的编号和成功率，便于排序。
- 使用 `long double` 提高计算精度，避免浮点数误差。
- 自定义比较函数，实现按成功率降序和编号升序的排序。

**代码核心实现：**
```cpp
struct Person {
    int id;
    long double rate;
};

bool cmp(const Person &a, const Person &b) {
    if (a.rate != b.rate) return a.rate > b.rate;
    return a.id < b.id;
}

int main() {
    int n;
    cin >> n;
    vector<Person> people(n);
    for (int i = 0; i < n; ++i) {
        int a, b;
        cin >> a >> b;
        people[i].id = i + 1;
        people[i].rate = (long double)a / (a + b);
    }
    sort(people.begin(), people.end(), cmp);
    for (int i = 0; i < n; ++i) {
        cout << people[i].id << " ";
    }
    return 0;
}
```

**个人心得：**
- 强调了浮点数计算的精度问题，提醒使用 `long double` 来避免误差。
- 结构体的使用使得代码更加清晰和易于维护。

### 最优关键思路或技巧

1. **结构体存储数据**：使用结构体将每个人的编号和成功率存储在一起，便于排序。
2. **高精度浮点数**：使用 `long double` 提高计算精度，避免浮点数误差。
3. **自定义比较函数**：通过自定义比较函数实现复杂的排序规则。

### 拓展思路

类似的自定义排序问题在竞赛中非常常见，通常涉及到多个排序条件。掌握结构体的使用和自定义比较函数的编写是解决这类问题的关键。

### 推荐题目

1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)

---
处理用时：24.57秒
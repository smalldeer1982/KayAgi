# 题目信息

# [ABC309C] Medicine

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc309/tasks/abc309_c

高橋君は医者のすぬけ君から $ N $ 種類の薬を処方されました。$ i $ 種類目の薬は(処方された日を含めて) $ a_i $ 日間、毎日 $ b_i $ 錠ずつ飲む必要があります。また、高橋君はこれ以外の薬を飲む必要がありません。

薬を処方された日を $ 1 $ 日目とします。$ 1 $ 日目以降で、初めて高橋君がその日に飲む必要がある薬が $ K $ 錠以下になるのは何日目かを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 0\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ a_i,b_i\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1 $ 日目には、高橋君は $ 1,2,3,4 $ 種類目の薬をそれぞれ $ 3,5,9,2 $ 錠飲む必要があります。よってこの日は $ 19 $ 錠飲む必要があり、$ K(=8) $ 錠以下ではありません。 $ 2 $ 日目には、高橋君は $ 1,2,4 $ 種類目の薬をそれぞれ $ 3,5,2 $ 錠飲む必要があります。よってこの日は $ 10 $ 錠飲む必要があり、$ K(=8) $ 錠以下ではありません。 $ 3 $ 日目には、高橋君は $ 1,4 $ 種類目の薬をそれぞれ $ 3,2 $ 錠飲む必要があります。よってこの日は $ 5 $ 錠飲む必要があり、初めて $ K(=8) $ 錠以下になります。 以上より、$ 3 $ が答えです。

## 样例 #1

### 输入

```
4 8

6 3

2 5

1 9

4 2```

### 输出

```
3```

## 样例 #2

### 输入

```
4 100

6 3

2 5

1 9

4 2```

### 输出

```
1```

## 样例 #3

### 输入

```
15 158260522

877914575 2436426

24979445 61648772

623690081 33933447

476190629 62703497

211047202 71407775

628894325 31963982

822804784 50968417

430302156 82631932

161735902 80895728

923078537 7723857

189330739 10286918

802329211 4539679

303238506 17063340

492686568 73361868

125660016 50287940```

### 输出

```
492686569```

# AI分析结果

### 题目内容
高橋君は医者のすぬけ君から $ N $ 種類の薬を処方されました。$ i $ 種類目の薬は(処方された日を含めて) $ a_i $ 日間、毎日 $ b_i $ 錠ずつ飲む必要があります。また、高橋君はこれ以外の薬を飲む必要がありません。

薬を処方された日を $ 1 $ 日目とします。$ 1 $ 日目以降で、初めて高橋君がその日に飲む必要がある薬が $ K $ 錠以下になるのは何日目かを求めてください。

### 算法分类
排序、模拟

### 题解分析与结论
本题的核心思路是通过排序和模拟来找到第一个满足条件的日期。大多数题解都采用了以下步骤：
1. **排序**：将药物按照 $a_i$ 升序排序，这样可以方便地模拟药物的停止服用。
2. **模拟**：从第一天开始，逐步减少药物的服用量，直到满足条件。

### 评分较高的题解

#### 1. 作者：Molina (5星)
**关键亮点**：
- 使用了结构体存储药物信息，代码结构清晰。
- 通过排序和模拟的方式，逐步减少药物的服用量，直到满足条件。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
struct cz{
    int x,y;
}a[N];
bool cmp(cz a,cz b){
    return a.x < b.x ;
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i].x>>a[i].y;
        sum+=a[i].y;
    }
    if(sum<=k){
        cout<<1;
        return 0;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        sum-=a[i].y;
        if(sum<=k){
            cout<<a[i].x+1;
            return 0;
        }
    }
    return 0;
}
```

#### 2. 作者：minVan (4星)
**关键亮点**：
- 使用了二分查找的方法，虽然时间复杂度稍高，但思路清晰。
- 通过二分查找来快速定位满足条件的日期。

**核心代码**：
```cpp
inline int check(int x) {
    int sum = 0;
    for(int i = 1; i <= n; i++) {
        if(x <= a[i].x) {
            sum += a[i].y;
        }
    }
    return sum;
}
signed main() {
    cin >> n >> k;
    for(int i = 1; i <= n; i++) {
        cin >> a[i].x >> a[i].y;
    }
    sort(a + 1, a + n + 1, cmp);
    int l = 1, r = a[n].x + 1, ans;
    while(l <= r) {
        int mid = (l + r) >> 1;
        if(check(mid) <= k) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    cout << ans;
    return 0;
}
```

#### 3. 作者：hellolin (4星)
**关键亮点**：
- 使用了 `pair` 来存储药物信息，代码简洁。
- 通过排序和模拟的方式，逐步减少药物的服用量，直到满足条件。

**核心代码**：
```cpp
pair<ll,ll> a[300010];
void solve() {
    cin >> n >> k;
    for(ll i=1; i<=n; i++) {
        cin >> a[i].first >> a[i].second;
        now += a[i].second;
    }
    sort(a+1, a+1+n);
    if(now <= k) {
        cout << 1 << endl;
        return;
    }
    for(ll i=1; i<=n; i++) {
        now -= a[i].second;
        if(now <= k) {
            cout << a[i].first + 1 << endl;
            return;
        }
    }
}
```

### 最优关键思路
通过排序和模拟的方式，逐步减少药物的服用量，直到满足条件。这种方法的时间复杂度为 $O(n \log n)$，适合处理大规模数据。

### 可拓展之处
类似的问题可以通过排序和模拟的方式来解决，例如在时间序列中寻找满足特定条件的第一个时间点。

### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

---
处理用时：26.16秒
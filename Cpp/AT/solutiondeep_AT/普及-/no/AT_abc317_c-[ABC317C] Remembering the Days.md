# 题目信息

# [ABC317C] Remembering the Days

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_c

ある地方に、$ 1 $ から $ N $ の番号がついた $ N $ 個の街と、$ 1 $ から $ M $ の番号がついた $ M $ 本の道路があります。

$ i $ 番目の道路は街 $ A_i $ と街 $ B_i $ を双方向に結び、長さは $ C_i $ です。

好きな街からスタートして同じ街を二度以上通らずに別の街へ移動するときの、通る道路の長さの和としてありえる最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10 $
- $ 1\ \leq\ M\ \leq\ \frac{N(N-1)}{2} $
- $ 1\leq\ A_i\ <\ B_i\ \leq\ N $
- $ (A_i,B_i) $ は相異なる
- $ 1\leq\ C_i\ \leq\ 10^8 $
- 入力は全て整数である
 
### Sample Explanation 1

$ 4\to\ 1\to\ 3\to\ 2 $ と移動すると、通る道路の長さの和は $ 1110 $ となります。

### Sample Explanation 2

道路と繋がっていない街が存在するかもしれません。

### Sample Explanation 3

!\[図\](https://img.atcoder.jp/abc317/06ac62d13dd1c4b2b469a524a60eb093.png)

## 样例 #1

### 输入

```
4 4

1 2 1

2 3 10

1 3 100

1 4 1000```

### 输出

```
1110```

## 样例 #2

### 输入

```
10 1

5 9 1```

### 输出

```
1```

## 样例 #3

### 输入

```
10 13

1 2 1

1 10 1

2 3 1

3 4 4

4 7 2

4 8 1

5 8 1

5 9 3

6 8 1

6 9 5

7 8 1

7 9 4

9 10 3```

### 输出

```
20```

# AI分析结果

### 题目内容重写
某地区有编号为 $1$ 至 $N$ 的 $N$ 个城镇和编号为 $1$ 至 $M$ 的 $M$ 条道路。第 $i$ 条道路双向连接城镇 $A_i$ 和城镇 $B_i$，长度为 $C_i$。你可以选择任意一个城镇作为起点出发，到达另一个城镇时，在不多次经过同一城镇的情况下，求你所经过的道路的最大可能总长度。

### 算法分类
深度优先搜索 DFS

### 题解分析与结论
本题的核心是通过深度优先搜索（DFS）遍历所有可能的路径，并找到其中边权和最大的路径。由于 $N$ 的范围较小（$2 \leq N \leq 10$），直接暴力搜索是可行的。所有题解都采用了DFS的思路，但在实现细节上有所不同。

### 精选题解
#### 1. 作者：LiJoQiao (赞：2)
**星级：4星**
**关键亮点：**
- 使用链式前向星存储图结构，优化了空间复杂度。
- 通过超级源点简化了主函数的调用，只需调用一次DFS即可。
- 代码结构清晰，注释详细，易于理解。

**核心代码：**
```cpp
int dfs(int u) {
    vis[u] = 1;
    int ret = 0;
    for(int i = head[u]; i; i = edge[i].nxt) {
        int v = edge[i].v, w = edge[i].w;
        if(!vis[v]) ret = max(ret, dfs(v) + w);
    }
    vis[u] = 0;
    return ret;
}
```
**实现思想：**
从当前节点 `u` 开始，遍历所有未访问的邻接节点 `v`，递归计算从 `v` 出发的最大路径和，并加上当前边的权值 `w`，最终返回最大值。

#### 2. 作者：HEzzz (赞：1)
**星级：4星**
**关键亮点：**
- 使用邻接矩阵存储图，简化了图的表示。
- 通过全局变量 `ans` 记录最大路径和，减少了函数参数传递。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码：**
```cpp
void dfs(int u, int s) {
    vis[u] = 1;
    ans = max(ans, s);
    _rep(i, 1, n) if(!vis[i] && e[u][i] != 0) dfs(i, s + e[u][i]);
    vis[u] = 0;
}
```
**实现思想：**
从当前节点 `u` 开始，遍历所有未访问的邻接节点 `i`，递归计算从 `i` 出发的路径和，并更新全局最大路径和 `ans`。

#### 3. 作者：sunkuangzheng (赞：1)
**星级：4星**
**关键亮点：**
- 使用链式前向星存储图，优化了空间复杂度。
- 通过全局变量 `res` 记录最大路径和，减少了函数参数传递。
- 代码结构清晰，注释详细，易于理解。

**核心代码：**
```cpp
void dfs(int u) {
    res = max(ans, res);
    for(int i = head[u], v; v = e[i].to, i; i = e[i].nxt) {
        if(vis[v]) continue;
        ans += e[i].w, vis[v] = 1, dfs(v), ans -= e[i].w, vis[v] = 0;
    }
}
```
**实现思想：**
从当前节点 `u` 开始，遍历所有未访问的邻接节点 `v`，递归计算从 `v` 出发的路径和，并更新全局最大路径和 `res`。

### 最优关键思路或技巧
1. **DFS回溯**：在DFS过程中，使用 `vis` 数组标记已访问的节点，并在回溯时取消标记，确保每个节点只被访问一次。
2. **超级源点**：通过添加一个超级源点，简化主函数的调用，只需调用一次DFS即可。
3. **链式前向星**：使用链式前向星存储图结构，优化了空间复杂度。

### 可拓展之处
1. **剪枝优化**：在DFS过程中，可以加入剪枝策略，提前终止不可能得到更优解的路径。
2. **记忆化搜索**：对于较大的图，可以使用记忆化搜索来避免重复计算。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)

---
处理用时：23.92秒
# 题目信息

# [ABC326C] Peak

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc326/tasks/abc326_c

高橋くんは数直線上に $ N $ 個のプレゼントを置きました。そのうち $ i $ 個目のプレゼントは座標 $ A_i $ に置かれました。

あなたは数直線上の長さ $ M $ の半開区間 $ [x,x+M) $ を選び、そこに含まれるプレゼントを全て獲得します。  
 より詳しくは、以下の手順でプレゼントを獲得します。

- まず、実数 $ x $ をひとつ選択する。
- その後、プレゼントのうち置かれている座標が $ x\ \le\ A_i\ <\ x+M $ を満たすものを全て獲得する。
 
最大でいくつのプレゼントを獲得することができますか?

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ 1\ \le\ M\ \le\ 10^9 $
- $ 0\ \le\ A_i\ \le\ 10^9 $
 
### Sample Explanation 1

例えば、半開区間 $ [1.5,7.5) $ を指定します。 このとき、座標 $ 2,3,5,7 $ にある $ 4 $ つのプレゼントを全て獲得することができ、これが獲得可能な最大の個数です。

### Sample Explanation 2

同一の座標に複数のプレゼントが置いてあることもあります。

## 样例 #1

### 输入

```
8 6

2 3 5 7 11 13 17 19```

### 输出

```
4```

## 样例 #2

### 输入

```
10 1

3 1 4 1 5 9 2 6 5 3```

### 输出

```
2```

## 样例 #3

### 输入

```
10 998244353

100000007 0 1755647 998244353 495 1000000000 1755648 503 1755649 998244853```

### 输出

```
7```

# AI分析结果

### 题目内容重写

高橋君在数直线上放置了 $N$ 个礼物。其中第 $i$ 个礼物放置在坐标 $A_i$ 处。

你需要在数直线上选择一个长度为 $M$ 的半开区间 $[x, x+M)$，并获得其中包含的所有礼物。  
更详细地说，按照以下步骤获得礼物：

- 首先，选择一个实数 $x$。
- 然后，获得所有满足 $x \le A_i < x+M$ 的礼物。

问：最多可以获得多少个礼物？

### 算法分类
双指针、二分

### 题解分析与结论

本题的核心是找到一个长度为 $M$ 的半开区间，使得其中包含的礼物数量最多。由于礼物的坐标可能很大，直接枚举所有可能的区间是不可行的。因此，题解中主要采用了双指针和二分的方法来优化搜索过程。

#### 关键思路与技巧
1. **排序**：首先对礼物的坐标进行排序，便于后续的区间搜索。
2. **双指针**：使用双指针维护一个滑动窗口，窗口的长度不超过 $M$，通过移动指针来找到包含最多礼物的区间。
3. **二分查找**：对于每个礼物的坐标，使用二分查找来确定区间内最后一个满足条件的礼物位置，从而快速计算区间内的礼物数量。

#### 最优题解

**题解作者：rainygame**  
**评分：5星**  
**关键亮点**：  
- 使用了双指针的技巧，通过维护一个滑动窗口来高效地找到包含最多礼物的区间。
- 代码简洁，逻辑清晰，时间复杂度为 $O(n)$，非常高效。

**核心代码**：
```cpp
sort(a+1, a+n+1);
a[n+1] = INT_MAX;
for (int i(1); i<=n; ++i){
    while (r <= n+1 && a[i]+m > a[r]) ++r;
    ans = max(ans, r-i);
}
```
**实现思想**：  
首先对礼物坐标进行排序，然后使用双指针维护一个滑动窗口。右指针 $r$ 不断向右移动，直到区间长度超过 $M$，然后更新最大礼物数量。

---

**题解作者：kimidonatsu**  
**评分：4星**  
**关键亮点**：  
- 使用了双指针和滑动窗口的思路，代码结构清晰。
- 通过设置一个极大值来避免边界问题，代码鲁棒性较强。

**核心代码**：
```cpp
sort(a+1, a+n+1);
a[n+1] = INF;
for (int i=1; i<=n; i++) {
    while (a[r] < a[i] + m) r++;
    ans = max(ans, r - i);
}
```
**实现思想**：  
同样使用双指针维护滑动窗口，右指针 $r$ 不断向右移动，直到区间长度超过 $M$，然后更新最大礼物数量。

---

**题解作者：xxr___**  
**评分：4星**  
**关键亮点**：  
- 使用了二分查找的方法，通过 `lower_bound` 快速找到区间内的礼物数量。
- 代码简洁，逻辑清晰，时间复杂度为 $O(n \log n)$。

**核心代码**：
```cpp
sort(a+1, a+n+1);
for (int i=1; i<=n; ++i) {
    int pos = lower_bound(a+1, a+n+1, a[i]+m) - a - i;
    maxn = max(maxn, pos);
}
```
**实现思想**：  
对礼物坐标进行排序后，使用 `lower_bound` 查找第一个不小于 $a[i]+m$ 的位置，从而计算出区间内的礼物数量。

### 可拓展之处
本题的双指针和二分查找方法可以推广到其他类似的区间搜索问题，如寻找满足某种条件的最小区间、最大区间等。类似的问题可以通过排序和滑动窗口的技巧来优化搜索过程。

### 推荐题目
1. [P1638 滑动窗口](https://www.luogu.com.cn/problem/P1638)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1719 最大子矩阵](https://www.luogu.com.cn/problem/P1719)

### 个人心得
在调试过程中，双指针的边界条件需要特别注意，尤其是在右指针移动时，要确保不会越界。此外，使用二分查找时，排序是必不可少的步骤，否则查找结果将不准确。

---
处理用时：29.54秒
# 题目信息

# [ABC329D] Election Quick Report

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc329/tasks/abc329_d

$ 1,\ 2,\ \ldots,\ N $ の番号のついた $ N $ 人の候補者から当選者を $ 1 $ 人選ぶ選挙において、$ M $ 票の投票がありました。

各票ではそれぞれちょうど $ 1 $ 人が投票先として選ばれており、$ i $ 票目の投票先は候補者 $ A_i $ です。

これから $ 1 $ 票目から順に開票を行い、 $ 1 $ 票ごとにその時点で開票が終了した場合の当選者を更新して表示します。

開票された票において最も得票数が多かった候補者が当選となります。ただし、最も得票数が多かった候補者が複数いる場合は、その中で最も番号の小さい候補者が当選となります。

各 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ 1,\ 2,\ \ldots,\ i $ 票目のみを開票した場合の当選者を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,M\ \leq\ 200000 $
- $ 1\ \leq\ A_i\ \leq\ N $
- 入力される数値はすべて整数
 
### Sample Explanation 1

候補者 $ i $ の得票数を $ C_i $ で表すこととします。 - $ 1 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 0,\ 0) $ なので当選者は $ 1 $ です。 - $ 2 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 1,\ 0) $ なので当選者は $ 1 $ です。 - $ 3 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 2,\ 0) $ なので当選者は $ 2 $ です。 - $ 4 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (1,\ 2,\ 1) $ なので当選者は $ 2 $ です。 - $ 5 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (2,\ 2,\ 1) $ なので当選者は $ 1 $ です。 - $ 6 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (2,\ 2,\ 2) $ なので当選者は $ 1 $ です。 - $ 7 $ 票目までが開票された時点では、$ (C_1,\ C_2,\ C_3)\ =\ (2,\ 2,\ 3) $ なので当選者は $ 3 $ です。

## 样例 #1

### 输入

```
3 7

1 2 2 3 1 3 3```

### 输出

```
1

1

2

2

1

1

3```

## 样例 #2

### 输入

```
100 5

100 90 80 70 60```

### 输出

```
100

90

80

70

60```

## 样例 #3

### 输入

```
9 8

8 8 2 2 8 8 2 2```

### 输出

```
8

8

8

2

8

8

8

2```

# AI分析结果

### 题目重写
[ABC329D] 快速选举报告

### 题目描述
在编号为 $1, 2, \ldots, N$ 的 $N$ 位候选人中选出一位当选者，共有 $M$ 张选票。每张选票都投给了其中一位候选人，第 $i$ 张选票投给了候选人 $A_i$。从第 $1$ 张选票开始依次开票，每开一张票后，输出当前开票结果中的当选者。当选者是当前得票数最多的候选人，如果有多位候选人得票数相同，则选择编号最小的候选人。

### 说明/提示
#### 约束
- $1 \leq N, M \leq 200000$
- $1 \leq A_i \leq N$
- 所有输入均为整数

### 样例解释
#### 样例 1
输入：
```
3 7
1 2 2 3 1 3 3
```
输出：
```
1
1
2
2
1
1
3
```

#### 样例 2
输入：
```
100 5
100 90 80 70 60
```
输出：
```
100
90
80
70
60
```

#### 样例 3
输入：
```
9 8
8 8 2 2 8 8 2 2
```
输出：
```
8
8
8
2
8
8
8
2
```

### 算法分类
模拟

### 题解分析与结论
题目要求每开一张票后，实时更新并输出当前得票数最多的候选人。由于数据范围较大，需要高效的数据结构来维护候选人的得票数和当前当选者。

#### 题解1：rainbow_cat
**星级：4**
**关键亮点：**
- 使用优先队列（堆）来维护当前得票数最多的候选人。
- 在得票数相同的情况下，通过循环取编号最小的候选人。
- 代码简洁，思路清晰。

**核心代码：**
```cpp
priority_queue<pair<int,int>>q;
for(int i=1;i<=m;i++) {
    cin>>a[i];
    ++num[a[i]];
    q.push({num[a[i]],a[i]});
    int maxn=q.top().first,ans=q.top().second;
    while(q.size()&&q.top().first==maxn) {
        ans=min(ans,q.top().second);
        q.pop();
    }
    q.push({maxn,ans});
    cout<<ans<<'\n';
}
```
**实现思想：**
- 使用 `num` 数组记录每个候选人的得票数。
- 每次开票后，更新候选人的得票数，并将其插入优先队列。
- 通过循环确保在得票数相同的情况下，选择编号最小的候选人。

### 最优关键思路
- **优先队列的使用**：通过优先队列高效维护当前得票数最多的候选人，确保每次查询的复杂度为 $O(\log N)$。
- **编号最小处理**：在得票数相同的情况下，通过循环取编号最小的候选人，确保符合题目要求。

### 拓展思路
- **类似题目**：可以扩展到多轮选举、加权投票等场景，进一步考察数据结构的灵活使用。
- **优化方向**：可以考虑使用更高效的数据结构，如平衡树，来进一步优化查询和更新操作。

### 推荐题目
1. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

这些题目都涉及到优先队列的使用，可以帮助进一步掌握堆的应用和优化技巧。

---
处理用时：22.05秒
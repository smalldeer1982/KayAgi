# 题目信息

# [ABC330D] Counting Ls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc330/tasks/abc330_d

$ N\ \times\ N $ のマス目が与えられます。このうち上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,j) $ と書きます。  
 各マスの状態を表す $ N $ 個の長さ $ N $ の文字列 $ S_1,S_2,\dots,S_N $ が以下の形式で与えられます。

- $ S_i $ の $ j $ 文字目が `o` であるとき、 $ (i,j) $ には `o` が書かれている。
- $ S_i $ の $ j $ 文字目が `x` であるとき、 $ (i,j) $ には `x` が書かれている。
 
以下の条件を全て満たすマスの三つ組の個数を求めてください。

- 組に含まれる $ 3 $ マスは相異なる。
- $ 3 $ マス全てに `o` が書かれている。
- マスのうち、丁度 $ 2 $ つが同じ行にある。
- マスのうち、丁度 $ 2 $ つが同じ列にある。
 
但し、ふたつの三つ組は、丁度一方に含まれるマスが存在する場合のみ区別します。

## 说明/提示

### 制約

- $ N $ は $ 2 $ 以上 $ 2000 $ 以下の整数
- $ S_i $ は長さ $ N $ の `o` と `x` からなる文字列
 
### Sample Explanation 1

以下の $ 4 $ つの三つ組が条件を満たします。 - $ (1,1),(1,2),(2,1) $ - $ (1,1),(1,3),(2,1) $ - $ (1,1),(1,3),(3,3) $ - $ (1,2),(1,3),(3,3) $

## 样例 #1

### 输入

```
3

ooo

oxx

xxo```

### 输出

```
4```

## 样例 #2

### 输入

```
4

oxxx

xoxx

xxox

xxxo```

### 输出

```
0```

## 样例 #3

### 输入

```
15

xooxxooooxxxoox

oxxoxoxxxoxoxxo

oxxoxoxxxoxoxxx

ooooxooooxxoxxx

oxxoxoxxxoxoxxx

oxxoxoxxxoxoxxo

oxxoxooooxxxoox

xxxxxxxxxxxxxxx

xooxxxooxxxooox

oxxoxoxxoxoxxxo

xxxoxxxxoxoxxoo

xooxxxooxxoxoxo

xxxoxxxxoxooxxo

oxxoxoxxoxoxxxo

xooxxxooxxxooox```

### 输出

```
2960```

# AI分析结果

### 题目内容重写（中文）

给定一个 $N \times N$ 的网格，每个格子中要么是 `o`，要么是 `x`。要求找出满足以下条件的三元组数量：

1. 三元组中的三个格子各不相同。
2. 三个格子中都为 `o`。
3. 恰好有两个格子在同一行。
4. 恰好有两个格子在同一列。

### 算法分类
组合数学

### 题解分析与结论

本题的核心是通过预处理每行和每列的 `o` 的数量，然后枚举每个 `o`，计算其作为“拐点”时能组成的三元组数量。所有题解都采用了这一思路，但部分题解在代码实现上更为简洁和优化。

### 所选高星题解

#### 题解1：yhx0322（5星）
**关键亮点**：
- 代码简洁，逻辑清晰。
- 使用预处理和乘法原理，时间复杂度为 $O(N^2)$。
- 通过 `a1` 和 `a2` 数组分别记录每行和每列的 `o` 的数量，避免重复计算。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (s[i][j] != 'o') continue;
        ans += ((a1[i] - 1) * (a2[j] - 1));
    }
}
```

#### 题解2：Pink_Cut_Tree（4星）
**关键亮点**：
- 思路清晰，解释详细。
- 使用 `row` 和 `col` 数组记录每行和每列的 `o` 的数量，并通过枚举每个 `o` 计算贡献。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (c[i][j] == 'o') {
            ans += (row[j] - 1) * (col[i] - 1);
        }
    }
}
```

#### 题解3：Register_int（4星）
**关键亮点**：
- 代码简洁，直接使用预处理数组 `x` 和 `y` 记录每行和每列的 `o` 的数量。
- 通过枚举每个 `o`，直接计算贡献。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) if (s[i][j] == 'o') {
        ans += (x[i] - 1) * (y[j] - 1);
    }
}
```

### 最优关键思路
预处理每行和每列的 `o` 的数量，然后枚举每个 `o`，利用乘法原理计算其作为“拐点”时能组成的三元组数量。这种方法避免了重复计算，时间复杂度为 $O(N^2)$。

### 可拓展之处
类似的问题可以通过预处理和组合数学的方法来解决，例如统计满足某些条件的四元组或更多元组的数量。

### 推荐题目
1. [P1984 [NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1984)
2. [P1966 [NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1966)
3. [P1970 [NOIP2013 提高组] 花匠](https://www.luogu.com.cn/problem/P1970)

### 个人心得摘录
- **yhx0322**：通过预处理和乘法原理，避免了重复计算，代码简洁且高效。
- **Pink_Cut_Tree**：详细解释了每个步骤，适合初学者理解。
- **Register_int**：代码简洁，直接使用预处理数组，适合快速实现。

---
处理用时：25.26秒
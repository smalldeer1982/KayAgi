# 题目信息

# [ABC333C] Repunit Trio

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_c

十進法ですべての桁の数字が $ 1 $ である整数をレピュニットと呼びます。レピュニットを小さい順に並べると $ 1,11,111,\ldots $ です。

ちょうど $ 3 $ つのレピュニットの和として表せる整数のうち $ N $ 番目に小さいものを求めてください。

## 说明/提示

### 制約

- $ N $ は $ 1 $ 以上 $ 333 $ 以下の整数
 
### Sample Explanation 1

ちょうど $ 3 $ つのレピュニットの和として表せる整数を小さい順に並べると $ 3,13,23,33,113,\ldots $ です。例えば $ 113 $ は $ 113=1+1+111 $ と表せます。 $ 3 $ つのレピュニットは相異ならなくてもよいことに注意してください。

## 样例 #1

### 输入

```
5```

### 输出

```
113```

## 样例 #2

### 输入

```
19```

### 输出

```
2333```

## 样例 #3

### 输入

```
333```

### 输出

```
112222222233```

# AI分析结果

### 题目内容
# [ABC333C] Repunit Trio

## 题目描述

在十进制中，所有数字位都是 $1$ 的整数被称为“Repunit”。按升序排列的 Repunit 序列为 $1,11,111,\ldots$。

请找出恰好由 $3$ 个 Repunit 相加得到的整数中第 $N$ 小的数。

## 说明/提示

### 约束

- $N$ 是 $1$ 以上 $333$ 以下的整数
 
### 样例解释 1

恰好由 $3$ 个 Repunit 相加得到的整数按升序排列为 $3,13,23,33,113,\ldots$。例如，$113$ 可以表示为 $113=1+1+111$。注意，$3$ 个 Repunit 可以相同。

## 样例 #1

### 输入

```
5```

### 输出

```
113```

## 样例 #2

### 输入

```
19```

### 输出

```
2333```

## 样例 #3

### 输入

```
333```

### 输出

```
112222222233```

### 算法分类
枚举

### 题解分析与结论
本题的核心思路是通过枚举所有可能的三个 Repunit 数的组合，计算它们的和，然后排序并去重，最终找到第 $N$ 小的数。由于 $N$ 的最大值为 $333$，且 Repunit 数的位数最多为 $12$ 位，因此枚举的复杂度是可接受的。

### 所选高分题解
#### 题解作者：XXh0919 (4星)
**关键亮点**：
1. 使用三重循环枚举所有可能的 Repunit 组合，确保不遗漏任何情况。
2. 使用 `set` 数据结构自动去重，简化了代码逻辑。
3. 通过预处理 Repunit 数，减少了重复计算，提高了效率。

**核心代码**：
```cpp
set<int>st;
for(int i=1;i<=18;i++){
    for(int j=1;j<=18;j++){
        for(int k=1;k<=18;k++){
            st.insert(a[i]+a[j]+a[k]);
        }	
    }
}
```
**实现思想**：通过三重循环枚举所有可能的 Repunit 组合，将它们的和插入到 `set` 中，自动去重后排序，最后输出第 $N$ 个元素。

#### 题解作者：A_R_O_N_A (4星)
**关键亮点**：
1. 使用 `vector` 存储所有可能的和，便于后续排序和去重。
2. 通过预处理 Repunit 数，减少了重复计算，提高了效率。
3. 代码结构清晰，易于理解。

**核心代码**：
```cpp
vector<ll>v;
for(int i=1;i<=17;i++){
    for(int j=1;j<=17;j++){
        for(int k=1;k<=17;k++){
            res=a[i]+a[j]+a[k];
            v.push_back(res);
        }
    }
}
sort(v.begin(),v.end());
unique(v.begin(),v.end());
```
**实现思想**：通过三重循环枚举所有可能的 Repunit 组合，将它们的和存储到 `vector` 中，排序并去重后输出第 $N$ 个元素。

#### 题解作者：Hughpig (4星)
**关键亮点**：
1. 通过观察 Repunit 数的性质，优化了枚举的范围，减少了不必要的计算。
2. 使用 `sort` 和 `unique` 函数进行排序和去重，代码简洁高效。
3. 代码结构清晰，易于理解。

**核心代码**：
```cpp
for(int i=1;i<=13;i++){
    for(int j=i;j<=13;j++){
        for(int k=j;k<=13;k++){
            x=qwq[i]+qwq[j]+qwq[k];
            s[++cnt]=x;
        }
    }
}
sort(s+1,s+cnt+1);
```
**实现思想**：通过三重循环枚举所有可能的 Repunit 组合，将它们的和存储到数组中，排序后输出第 $N$ 个元素。

### 最优关键思路
1. **预处理 Repunit 数**：通过预处理生成所有可能的 Repunit 数，减少重复计算。
2. **枚举所有组合**：通过三重循环枚举所有可能的 Repunit 组合，确保不遗漏任何情况。
3. **去重与排序**：使用 `set` 或 `vector` 结合 `sort` 和 `unique` 函数进行去重和排序，简化代码逻辑。

### 可拓展之处
1. **类似题目**：可以扩展到更多个 Repunit 数的组合，或者扩展到其他类型的数字组合问题。
2. **优化思路**：可以通过剪枝或动态规划进一步优化枚举过程，减少不必要的计算。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 枚举与剪枝的结合。
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 枚举与组合的结合。
3. [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149) - 枚举与数学的结合。

---
处理用时：32.14秒
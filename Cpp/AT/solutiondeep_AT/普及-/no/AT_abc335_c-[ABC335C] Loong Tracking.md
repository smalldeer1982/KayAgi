# 题目信息

# [ABC335C] Loong Tracking

## 题目描述

## 题意翻译
Takahashi 创造了一款游戏，游戏中玩家可以在坐标平面上控制一条“龙”。

一条“龙”包含 $N$ 个编号为 $1$ 到 $N$ 的部位，而部位 $1$ 被叫做“头”。

初始状态下，第 $i$ 个部位位于坐标（$i$ , $0$）。下面你需要回答 $Q$ 个询问。

- `1 C`：向方向 $C$ 将编号为 $1$ 的头移动一个单位长度。$C$ 可能是 `R`、`L`、`U`、`D` 中的一个字母，分别代表 $x$ 轴正方向、$x$ 轴负方向、$y$ 轴正方向、$y$ 轴负方向。其他的所有部位都会跟随上一个部位移动。形式化地，编号为 $i$ 的部位会移动到编号为 $i-1$ 的部位先前所在的位置。
- `2 p`：输出部位 $p$ 的坐标。

你需要对所有询问 `2` 做出回答。

## 样例 #1

### 输入

```
5 9
2 3
1 U
2 3
1 R
1 D
2 3
1 L
2 1
2 5```

### 输出

```
3 0
2 0
1 1
1 0
1 0```

# AI分析结果

### 题目翻译
Takahashi 创造了一款游戏，游戏中玩家可以在坐标平面上控制一条“龙”。

一条“龙”包含 $N$ 个编号为 $1$ 到 $N$ 的部位，而部位 $1$ 被叫做“头”。

初始状态下，第 $i$ 个部位位于坐标（$i$ , $0$）。下面你需要回答 $Q$ 个询问。

- `1 C`：向方向 $C$ 将编号为 $1$ 的头移动一个单位长度。$C$ 可能是 `R`、`L`、`U`、`D` 中的一个字母，分别代表 $x$ 轴正方向、$x$ 轴负方向、$y$ 轴正方向、$y$ 轴负方向。其他的所有部位都会跟随上一个部位移动。形式化地，编号为 $i$ 的部位会移动到编号为 $i-1$ 的部位先前所在的位置。
- `2 p`：输出部位 $p$ 的坐标。

你需要对所有询问 `2` 做出回答。

### 算法分类
模拟

### 题解分析与结论
本题的核心在于模拟龙的移动过程。由于每次移动头部后，其他部位会跟随移动，因此需要高效地记录每个部位的位置变化。直接模拟每次移动会导致时间复杂度较高，因此需要优化。

#### 关键思路：
1. **记录头部移动历史**：通过记录头部每次移动后的坐标，其他部位的位置可以通过头部历史位置推导出来。
2. **使用队列或数组存储历史位置**：通过队列或数组存储头部每次移动后的坐标，查询时直接根据历史位置计算。

#### 优化技巧：
- **历史位置存储**：使用数组或队列存储头部每次移动后的坐标，避免重复计算。
- **逆序存储**：部分题解采用逆序存储历史位置，便于查询时直接访问。

### 评分较高的题解

#### 题解1：作者：wsx248 (5星)
**关键亮点**：
- 通过记录头部每次移动后的坐标，其他部位的位置可以通过头部历史位置推导出来。
- 使用数组存储历史位置，查询时直接输出对应位置的坐标。

**核心代码**：
```cpp
int ops;
int x[N*2], y[N*2];

int main()
{
    cin>>n>>q;
    for(int i=1;i<=n;i++)
        x[i] = n-i+1, y[i] = 0;
    ops = n;

    while(q--)
    {
        int op;
        cin>>op;
        if(op==1)
        {
            char s;
            cin>>s;
            ops++;
            if(s=='U')
                x[ops] = x[ops-1], y[ops] = y[ops-1] + 1;
            else if(s=='D')
                x[ops] = x[ops-1], y[ops] = y[ops-1] - 1;
            else if(s=='L')
                x[ops] = x[ops-1] - 1, y[ops] = y[ops-1];
            else
                x[ops] = x[ops-1] + 1, y[ops] = y[ops-1];
        }
        else
        {
            int p;
            cin>>p;
            cout<<x[ops-p+1]<<" "<<y[ops-p+1]<<endl;
        }
    }
    return 0;
}
```

#### 题解2：作者：XXh0919 (4星)
**关键亮点**：
- 使用双向队列存储每个部位的位置，移动时更新队列头部，查询时直接输出对应位置的坐标。
- 代码简洁，易于理解。

**核心代码**：
```cpp
deque<pair<int,int>>dq;

signed main(){
    scanf("%lld%lld",&n,&q);
    for(int i=1;i<=n;++i)
       dq.emplace_back(i,0);
    while(q--){
        int op;
        scanf("%lld ",&op);
        if(op==1){
            dq.push_front(dq.front());
            dq.pop_back();
            char cc;
            scanf("%c",&cc);
            if(cc=='L')dq.front().x--;
            if(cc=='R')dq.front().x++;    
            if(cc=='U')dq.front().y++;
            if(cc=='D')dq.front().y--;
        }else{
            int k;
            scanf("%lld",&k);
            printf("%lld %lld\n",dq[k-1].x,dq[k-1].y);
        }
    }
    return 0;
}
```

### 推荐题目
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)

### 个人心得
- **调试经历**：部分题解提到在调试过程中发现编译器不支持某些操作符，导致代码无法正常运行，提醒我们在编写代码时要注意编译器的兼容性。
- **顿悟感想**：通过记录头部历史位置来推导其他部位的位置，大大简化了问题的复杂度，这种思路在处理类似问题时非常有效。

---
处理用时：28.14秒
# 题目信息

# [ABC337D] Cheating Gomoku Narabe

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc337/tasks/abc337_d

$ H $ 行 $ W $ 列のグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,\ j) $ と呼びます。

各マスには `o` 、`x` 、`.` のうちいずれかの文字が書かれています。 各マスに書かれた文字は $ H $ 個の長さ $ W $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_H $ で表され、 マス $ (i,\ j) $ に書かれた文字は、文字列 $ S_i $ の $ j $ 文字目と一致します。

このグリッドに対して、下記の操作を $ 0 $ 回以上好きな回数だけ繰り返します。

- `.` が書かれているマスを $ 1 $ 個選び、そのマスに書かれた文字を `o` に変更する。
 
その結果、縦方向または横方向に連続した $ K $ 個のマスであってそれらに書かれた文字がすべて `o` であるようなものが存在する（ すなわち、下記の $ 2 $ つの条件のうち**少なくとも一方**を満たす）ようにすることが可能かを判定し、可能な場合はそのために行う操作回数の最小値を出力してください。

- $ 1\ \leq\ i\ \leq\ H $ かつ $ 1\ \leq\ j\ \leq\ W-K+1 $ を満たす整数の組 $ (i,\ j) $ であって、マス $ (i,\ j),\ (i,\ j+1),\ \ldots,\ (i,\ j+K-1) $ に書かれた文字が `o` であるものが存在する。
- $ 1\ \leq\ i\ \leq\ H-K+1 $ かつ $ 1\ \leq\ j\ \leq\ W $ を満たす整数の組 $ (i,\ j) $ であって、マス $ (i,\ j),\ (i+1,\ j),\ \ldots,\ (i+K-1,\ j) $ に書かれた文字が `o` であるものが存在する。

## 说明/提示

### 制約

- $ H,\ W,\ K $ は整数
- $ 1\ \leq\ H $
- $ 1\ \leq\ W $
- $ H\ \times\ W\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ \max\lbrace\ H,\ W\ \rbrace $
- $ S_i $ は `o` 、`x` 、`.` のみからなる長さ $ W $ の文字列
 
### Sample Explanation 1

操作を $ 2 $ 回行って、例えばマス $ (2,\ 1) $ とマス $ (2,\ 2) $ に書かれた文字をそれぞれ `o` に変更することで問題文中の条件を満たすことができ、これが最小の操作回数です。

### Sample Explanation 2

操作を一度も行わなくても問題文中の条件を満たします。

### Sample Explanation 3

問題文中の条件を満たすことは不可能なので、`-1` を出力します。

## 样例 #1

### 输入

```
3 4 3

xo.x

..o.

xx.o```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2 3

.o

.o

.o

.o```

### 输出

```
0```

## 样例 #3

### 输入

```
3 3 3

x..

..x

.x.```

### 输出

```
-1```

## 样例 #4

### 输入

```
10 12 6

......xo.o..

x...x.....o.

x...........

..o...x.....

.....oo.....

o.........x.

ox.oox.xx..x

....o...oox.

..o.....x.x.

...o........```

### 输出

```
3```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个 $H$ 行 $W$ 列的网格，每个格子中可能包含字符 `o`、`x` 或 `.`。你可以进行多次操作，每次操作可以选择一个包含 `.` 的格子，将其字符改为 `o`。问是否可以通过这些操作，使得网格中存在一行或一列中连续 $K$ 个格子都包含 `o`。如果可以，输出最少的操作次数；否则输出 `-1`。

【输入格式】
第一行包含三个整数 $H$、$W$ 和 $K$，表示网格的行数、列数和要求的连续 `o` 的数量。
接下来 $H$ 行，每行包含一个长度为 $W$ 的字符串，表示网格的内容。

【输出格式】
输出一个整数，表示最少的操作次数。如果无法满足条件，输出 `-1`。

【样例输入】
```
3 4 3
xo.x
..o.
xx.o
```

【样例输出】
```
2
```

【样例解释】
通过将第 2 行的第 1 和第 2 列的 `.` 改为 `o`，可以满足条件。

### 算法分类
前缀和、滑动窗口

### 题解分析与结论
该题的核心在于如何在网格中快速找到满足条件的连续 $K$ 个 `o` 的行或列，并计算最少的操作次数。题解中主要采用了以下几种思路：
1. **前缀和优化**：通过维护前缀和数组，快速计算某一行或某一列中连续 $K$ 个格子中 `x` 和 `.` 的数量，从而判断是否满足条件。
2. **滑动窗口**：使用滑动窗口技术，动态维护窗口内的 `x` 和 `.` 的数量，避免重复计算。
3. **双指针**：通过双指针技术，维护一个长度为 $K$ 的窗口，判断窗口内是否满足条件。

### 精选题解
1. **作者：_xxxxx_ (5星)**
   - **关键亮点**：使用了前缀和和滑动窗口的结合，代码清晰且高效，避免了重复计算，时间复杂度为 $O(HW)$。
   - **代码核心思想**：通过维护两个计数器 `cnt1` 和 `cnt2`，分别记录当前窗口内 `.` 和 `x` 的数量，当窗口内没有 `x` 时，更新最小操作次数。
   - **代码片段**：
     ```cpp
     for(int i = 1; i <= n; i++) {
         int cnt1 = 0, cnt2 = 0;
         for(int j = 1; j <= m; j++) {
             if(a[i][j] == '.') cnt1++;
             if(a[i][j] == 'x') cnt2++;
             if(j > k) {
                 if(a[i][j - k] == '.') cnt1--;
                 if(a[i][j - k] == 'x') cnt2--;
             }
             if(j >= k && cnt2 == 0) {
                 minn = min(minn, cnt1);
             }
         }
     }
     ```

2. **作者：Lame_Joke (4星)**
   - **关键亮点**：使用了前缀和数组，分别统计行和列中 `x` 和 `.` 的数量，代码简洁且易于理解。
   - **代码核心思想**：通过二维前缀和数组，快速计算任意子矩阵中 `x` 和 `.` 的数量，判断是否满足条件。
   - **代码片段**：
     ```cpp
     for(int i = 1; i <= h; i++) {
         for(int j = 1; j <= w; j++) {
             sum1[i][j] = sum1[i][j - 1] + (s[i][j] == 'x');
             sum3[i][j] = sum3[i][j - 1] + (s[i][j] == '.');
         }
     }
     ```

3. **作者：tallnut (4星)**
   - **关键亮点**：使用了队列维护滑动窗口，思路新颖且代码实现清晰。
   - **代码核心思想**：通过队列维护当前窗口内的字符，动态更新窗口内的 `.` 和 `x` 的数量，判断是否满足条件。
   - **代码片段**：
     ```cpp
     for(int i = 1; i <= n; i++) {
         queue<char> q;
         int cnt = 0, x_cnt = 0;
         for(int j = 1; j <= m; j++) {
             if(a[i][j] == 'x') {
                 while(!q.empty()) q.pop();
                 cnt = x_cnt = 0;
             } else {
                 q.push(a[i][j]);
                 if(a[i][j] == '.') cnt++;
                 if(q.size() > k) {
                     if(q.front() == '.') cnt--;
                     q.pop();
                 }
                 if(q.size() == k && x_cnt == 0) {
                     ans = min(ans, cnt);
                 }
             }
         }
     }
     ```

### 最优关键思路
1. **前缀和与滑动窗口的结合**：通过前缀和快速计算窗口内的 `x` 和 `.` 的数量，结合滑动窗口技术，避免重复计算，时间复杂度为 $O(HW)$。
2. **双指针与队列的结合**：使用双指针和队列维护窗口内的字符，动态更新窗口内的 `.` 和 `x` 的数量，判断是否满足条件。

### 拓展思路
类似的问题可以扩展到二维矩阵中的其他操作，如寻找最大全 `1` 子矩阵、最小操作次数等。可以通过前缀和、滑动窗口、双指针等技术进行优化。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)
3. [P2216 [HAOI2007]理想的正方形](https://www.luogu.com.cn/problem/P2216)

---
处理用时：36.12秒
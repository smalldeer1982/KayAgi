# 题目信息

# [ABC389C] Snake Queue

## 题目描述

### 题目大意

有一个空的蛇队列。

有 $Q$ 个查询，查询有三种类型：

- 类型 $1$：以 `1 l` 的形式给出。一条长度为 $l$ 的蛇被添加到队列的末尾。如果添加前队列为空，则新加入的蛇的头部位置为 $0$ ；否则，它的头部位置是队列中最后一条蛇的头部坐标与该蛇长度的总和。
- 类型 $2$：以 `2` 的形式给出。队列最前面的蛇离开队列。保证此时队列不是空的。假设 $m$ 是离开队列的蛇的长度，那么队列中剩余的每条蛇的头部坐标都会减少 $m$。
- 类型 $3$：以 `3 k` 的形式给出。输出第 $k$ 条蛇的蛇头坐标。

## 说明/提示

- $1 \leq Q \leq 3 \times 10^{5}$
- 对于 $1$ 查询，$1 \leq l \leq 10^{9}$，保证队列不为空。
- 对于 $2$ 查询，保证队列不为空。
- 对于 $3$ 查询，假设 $n$ 是队列中的蛇的数量，那么 $1 \leq k \leq n$。
- 所有输入均为整数。

## 样例 #1

### 输入

```
7
1 5
1 7
3 2
1 3
1 4
2
3 3```

### 输出

```
5
10```

## 样例 #2

### 输入

```
3
1 1
2
1 3```

### 输出

```
```

## 样例 #3

### 输入

```
10
1 15
1 10
1 5
2
1 5
1 10
1 15
2
3 4
3 2```

### 输出

```
20
5```

# AI分析结果

### 题目内容翻译

#### 题目描述

有一个空的蛇队列。

有 $Q$ 个查询，查询有三种类型：

- **类型 1**：以 `1 l` 的形式给出。一条长度为 $l$ 的蛇被添加到队列的末尾。如果添加前队列为空，则新加入的蛇的头部位置为 $0$；否则，它的头部位置是队列中最后一条蛇的头部坐标与该蛇长度的总和。
- **类型 2**：以 `2` 的形式给出。队列最前面的蛇离开队列。保证此时队列不是空的。假设 $m$ 是离开队列的蛇的长度，那么队列中剩余的每条蛇的头部坐标都会减少 $m$。
- **类型 3**：以 `3 k` 的形式给出。输出第 $k$ 条蛇的蛇头坐标。

#### 说明/提示

- $1 \leq Q \leq 3 \times 10^{5}$
- 对于 $1$ 查询，$1 \leq l \leq 10^{9}$，保证队列不为空。
- 对于 $2$ 查询，保证队列不为空。
- 对于 $3$ 查询，假设 $n$ 是队列中的蛇的数量，那么 $1 \leq k \leq n$。
- 所有输入均为整数。

#### 样例 #1

##### 输入

```
7
1 5
1 7
3 2
1 3
1 4
2
3 3
```

##### 输出

```
5
10
```

#### 样例 #2

##### 输入

```
3
1 1
2
1 3
```

##### 输出

```

```

#### 样例 #3

##### 输入

```
10
1 15
1 10
1 5
2
1 5
1 10
1 15
2
3 4
3 2
```

##### 输出

```
20
5
```

### 算法分类
模拟、队列、前缀和

### 题解分析与结论

本题的核心是模拟一个蛇队列的操作，涉及到队列的插入、删除和查询操作。由于操作次数较多（$Q \leq 3 \times 10^5$），直接暴力模拟会导致超时，因此需要优化。

大多数题解都采用了前缀和的思想，通过维护一个前缀和数组来快速计算蛇的头部坐标。具体来说，当删除队头的蛇时，记录其长度，并在查询时减去这些长度的总和，从而避免了对整个队列的修改。

### 评分较高的题解

#### 题解1：ryf2011 (5星)

**关键亮点**：
- 使用结构体数组模拟队列，维护每条蛇的头部坐标和长度。
- 通过变量 `jian` 记录删除的蛇的总长度，查询时直接减去该值，避免了频繁修改队列。
- 代码简洁，思路清晰，时间复杂度为 $O(Q)$。

**核心代码**：
```cpp
struct node{
    int head,len;
} que[310005]; //结构体，用来模拟队列 

signed main(){
    scanf("%lld",&q);
    for(int i=1;i<=q;i++){
        scanf("%lld",&type);
        if(type==1){
            scanf("%lld",&l);
            quel++;
            que[quel].head=(quel==quehead?0:(que[quel-1].head+que[quel-1].len)); //如果当前加入的 snake 是第一个，将头部位置设为 0，其余不变 
            que[quel].len=l;
        }
        else if(type==2){
            quehead++; //模拟队列弹出首个的过程 
            jian+=que[quehead-1].len; //要减去的值加上当前离开的 snake 的长度，即 len 
        }
        else{
            scanf("%lld",&k);
            printf("%lld\n",(que[k+quehead-1].head-jian)); //由于之前可能有离开的 snake，所以要先找到 k 真正所指的位置，再减去应减的值，注意不能直接在原数上减，因为这样会使数据改变，影响后面的计算 
        }
    }
    return 0;
}
```

#### 题解2：xk2013 (5星)

**关键亮点**：
- 使用前缀和数组 `sum` 来维护蛇的长度总和，查询时通过前缀和快速计算。
- 通过变量 `w` 记录删除的蛇的总长度，查询时减去该值。
- 代码简洁，时间复杂度为 $O(Q)$。

**核心代码**：
```cpp
const int N = 3e5 + 5;
typedef long long int ll;
ll w, q, x, y, head = 1, tail = 1, queue[N], sum[N];

int main(void)
{
    scanf("%lld", &q);
    while (q--)
    {
        scanf("%lld", &x);
        if (x == 1)
        {
            scanf("%lld", &y);
            queue[tail++] = y;
            sum[tail] = sum[tail - 1] + y; // 计算前缀和
        }
        else if (x == 2)
        {
            w += queue[head]; // 累加
            head++;
        }
        else if (x == 3)
        {
            ll s = 0;
            scanf("%lld", &y);
            printf("%lld\n", sum[head + y - 1] - w); // 记得减去
        }
    }
    return 0;
}
```

#### 题解3：fengzhaoyu (4星)

**关键亮点**：
- 使用数组 `a` 和 `ah` 分别记录每条蛇的长度和头部坐标。
- 通过变量 `add` 记录删除的蛇的总长度，查询时减去该值。
- 代码简洁，时间复杂度为 $O(Q)$。

**核心代码**：
```cpp
const int N=3e5+5;
int a[N],cnt,len,ah[N],gout;// a 存每条蛇长度，ah存头坐标，len是总长度，其他的如上面所说
int add;
signed main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int opt,k;
        cin>>opt;
        if(opt==1)
        {
            cin>>k;
            a[++cnt]=k;
            ah[cnt]=len;
            len+=k;
        }
        if(opt==2)
        {
            ++gout;
            add+=a[gout];
        }          
        if(opt==3)
        {
            cin>>k;
            cout<<ah[gout+k]-add<<endl;
        }
    }
    return 0;
}
```

### 最优关键思路或技巧

1. **前缀和优化**：通过维护前缀和数组，避免在删除操作时对队列进行频繁修改，从而将时间复杂度从 $O(Q^2)$ 降低到 $O(Q)$。
2. **懒标记思想**：通过记录删除的蛇的总长度，查询时直接减去该值，避免了实时修改队列中的蛇的头部坐标。

### 可拓展之处

- **类似问题**：类似的问题可以扩展到其他需要维护队列或序列的场景，如滑动窗口、动态区间和等。
- **数据结构**：可以使用双端队列（`deque`）来进一步优化代码的可读性和效率。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录

- **ryf2011**：在删除操作时，通过记录删除的蛇的总长度，避免了频繁修改队列，提高了效率。
- **xk2013**：前缀和的思想在查询时非常有用，尤其是在需要频繁计算区间和的场景中。
- **fengzhaoyu**：通过懒标记的思想，避免了实时修改队列中的蛇的头部坐标，简化了代码逻辑。

---
处理用时：55.49秒
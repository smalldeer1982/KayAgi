# 题目信息

# [ABC390C] Paint to make a rectangle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc390/tasks/abc390_c

$ H $ 行 $ W $ 列のマス目が与えられます。  
 以下、上から $ i $ 行目 $ (1\leq\ i\leq\ H) $ かつ左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ で表します。  
 マス目の状態は $ H $ 個の長さ $ W $ の文字列 $ S_1,S_2,\ \ldots,\ S_H $ によって以下のように表されます。

- $ S_i $ の $ j $ 文字目が `#` のとき、マス $ (i,j) $ は黒く塗られている。
- $ S_i $ の $ j $ 文字目が `.` のとき、マス $ (i,j) $ は白く塗られている。
- $ S_i $ の $ j $ 文字目が `?` のとき、マス $ (i,j) $ は塗られていない。
 
高橋君はまだ塗られていないマスをそれぞれ白または黒で塗ることで、黒マス全体が長方形をなすようにしたいです。  
 より具体的には、ある $ 4 $ つの整数の組 $ (a,b,c,d) $ ($ 1\leq\ a\leq\ b\leq\ H $, $ 1\leq\ c\leq\ d\leq\ W $) が存在して、次が成り立つようにしたいです。

> マス $ (i,j) $ ($ 1\leq\ i\leq\ H $, $ 1\leq\ j\leq\ W $) は、 $ a\leq\ i\leq\ b $ かつ $ c\leq\ j\leq\ d $ をみたすとき、黒く塗られている。  
>  そうでないとき、白く塗られている。

そのようなことが可能か判定してください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ H $, $ W $ は整数
- $ S_i $ は `#`, `.`, `?` のみからなる長さ $ W $ の文字列
- 黒く塗られたマスが $ 1 $ つ以上存在する。
 
### Sample Explanation 1

マス目は以下の状態になっています。`?` のマスがまだ塗られていないマスです。 !\[\](https://img.atcoder.jp/abc390/85b372e4c19d09eb4f842736d40de3b9.png) マス $ (1,3) $, $ (2,2) $, $ (2,4) $ を黒く塗り、マス $ (3,1) $, $ (3,5) $ を白く塗ることで、 以下のように黒マス全体が長方形をなすようにできます。 !\[\](https://img.atcoder.jp/abc390/535404bb0565608276c41ef49d8f2336.png) よって、`Yes` を出力します。

### Sample Explanation 2

黒マス全体が長方形をなすためには、少なくともマス $ (2,2) $ を黒く塗る必要がありますがすでに白く塗られています。 よって、黒マス全体が長方形をなすようにマス目を塗ることはできないため、`No` を出力します。

## 样例 #1

### 输入

```
3 5

.#?#.

.?#?.

?...?```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

?##

#.#

##?```

### 输出

```
No```

## 样例 #3

### 输入

```
1 1

#```

### 输出

```
Yes```

# AI分析结果

【题目内容翻译】
给定一个 $H$ 行 $W$ 列的网格，每个单元格的状态由字符 `#`、`.` 或 `?` 表示。`#` 表示黑色，`.` 表示白色，`?` 表示未涂色。要求将所有未涂色的单元格涂成黑色或白色，使得所有黑色单元格构成一个矩形。判断是否存在这样的涂色方案。

【算法分类】
模拟

【题解分析与结论】
所有题解的核心思路都是通过遍历网格，找到所有黑色单元格的最小和最大行、列坐标，确定一个矩形区域，然后检查该区域内是否没有白色单元格。如果有白色单元格，则无法通过涂色使黑色单元格构成矩形；否则，可以通过将未涂色单元格涂成黑色来满足条件。

【评分较高的题解】
1. **作者：ikunTLE (5星)**
   - **关键亮点**：思路清晰，代码简洁，直接通过遍历找到黑色单元格的边界，并检查矩形区域内是否有白色单元格。
   - **核心代码**：
     ```cpp
     int u=INT_MAX,d=INT_MIN,l=INT_MAX,r=INT_MIN;
     for(int i=1;i<=n;++i)
         for(int j=1;j<=m;++j)
             if(s[i][j]=='#'){
                 u=min(u,i),d=max(d,i);
                 l=min(l,j),r=max(r,j);
             }
     for(int i=u;i<=d;++i)
         for(int j=l;j<=r;++j)
             if(s[i][j]=='.')
                 return printf("No\n"),0;
     printf("Yes\n");
     ```

2. **作者：ryf2011 (4星)**
   - **关键亮点**：思路与ikunTLE类似，代码结构清晰，变量命名合理，易于理解。
   - **核心代码**：
     ```cpp
     int mincol=2147483647,maxcol,minrow=2147483647,maxrow;
     for(int i=1;i<=h;i++)
         for(int j=1;j<=w;j++)
             if(s[i][j]=='#'){
                 minrow=min(minrow,i),maxrow=max(maxrow,i);
                 mincol=min(mincol,j),maxcol=max(maxcol,j);
             }
     for(int i=minrow;i<=maxrow;i++)
         for(int j=mincol;j<=maxcol;j++)
             if(s[i][j]=='.'){
                 printf("No\n");
                 return 0;
             }
     printf("Yes\n");
     ```

3. **作者：lijingqi228 (4星)**
   - **关键亮点**：代码简洁，直接通过遍历找到黑色单元格的边界，并检查矩形区域内是否有白色单元格。
   - **核心代码**：
     ```cpp
     int minx=2147483647,miny=2147483647,maxx=0,maxy=0;
     for(int i=0;i<n;i++)
         for(int j=0;j<m;j++)
             if(a[i][j]=='#'){
                 minx=min(minx,i),miny=min(miny,j);
                 maxx=max(maxx,i),maxy=max(maxy,j);
             }
     for(int i=minx;i<=maxx;i++)
         for(int j=miny;j<=maxy;j++)
             if(a[i][j]=='.'){
                 cout<<"No";
                 return 0;
             }
     cout<<"Yes";
     ```

【最优关键思路】
通过遍历网格找到所有黑色单元格的最小和最大行、列坐标，确定一个矩形区域，然后检查该区域内是否没有白色单元格。如果没有白色单元格，则可以通过将未涂色单元格涂成黑色来满足条件。

【可拓展之处】
类似的问题可以扩展到三维空间，或者要求黑色单元格构成其他形状（如正方形、圆形等）。此外，可以考虑优化算法，减少遍历次数。

【推荐题目】
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1506 拯救oibh总部](https://www.luogu.com.cn/problem/P1506)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

---
处理用时：25.92秒
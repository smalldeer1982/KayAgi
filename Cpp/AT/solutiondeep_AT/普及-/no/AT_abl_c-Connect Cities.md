# 题目信息

# Connect Cities

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abl/tasks/abl_c

$ N $ 個の都市 ($ 1 $ 番から $ N $ 番まで) と $ M $ 個の双方向道路 ($ 1 $ 番から $ M $ 番まで) があります。 道路 $ i $ は都市 $ A_i $ と都市 $ B_i $ を結びます。

すぬけ君は、以下の操作を $ 0 $ 回以上行うことができます。

- 道路で直接結ばれていない二つの異なる都市を選び、間に道路を作る。

操作を終えた後、どの都市からどの都市へも (場合によっては複数回) 道路をたどることで到達できるようになっていなければいけません。

目的を達成するために、最低何個の道路を作ればよいですか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100,000 $
- $ 1\ \leq\ M\ \leq\ 100,000 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- どの二つの道路も同じ都市のペアを結ばない。
- 入力は全て整数である。

### Sample Explanation 1

最初に、都市が三つあり、都市 $ 1 $ と都市 $ 2 $ の間に道があります。 すぬけ君は、たとえば都市 $ 1 $ と都市 $ 3 $ の間に道を作ることによって目的を達成できます。 道を作った後、 - 都市 $ 1 $ と $ 2 $ の間を直接旅行できます。 - 都市 $ 1 $ と $ 3 $ の間を直接旅行できます。 - 都市 $ 2 $ と $ 3 $ の間を両方の道を通ることで旅行できます。 ($ 2 $ - $ 1 $ - $ 3 $)

## 样例 #1

### 输入

```
3 1

1 2```

### 输出

```
1```

# AI分析结果

### 题目内容重写

#### 连接城市

##### 题目描述

有 $ N $ 个城市（编号从 $ 1 $ 到 $ N $）和 $ M $ 条双向道路（编号从 $ 1 $ 到 $ M $）。第 $ i $ 条道路连接城市 $ A_i $ 和城市 $ B_i $。

你可以进行以下操作任意次（包括零次）：

- 选择两个未被道路直接连接的不同城市，并在它们之间修建一条道路。

操作完成后，必须满足从任意一个城市到任意另一个城市都可以通过道路到达（可能需要经过多个城市）。

问：为了达到目标，最少需要修建多少条道路？

##### 说明/提示

###### 约束条件

- $ 2\ \leq\ N\ \leq\ 100,000 $
- $ 1\ \leq\ M\ \leq\ 100,000 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- 任意两条道路不会连接相同的城市对。
- 输入均为整数。

###### 样例解释 1

初始时，有三个城市，城市 $ 1 $ 和城市 $ 2 $ 之间有一条道路。你可以选择在城市 $ 1 $ 和城市 $ 3 $ 之间修建一条道路，从而达到目标。修建道路后：

- 城市 $ 1 $ 和 $ 2 $ 之间可以直接通行。
- 城市 $ 1 $ 和 $ 3 $ 之间可以直接通行。
- 城市 $ 2 $ 和 $ 3 $ 之间可以通过两条道路通行。（$ 2 $ - $ 1 $ - $ 3 $）

##### 样例 #1

###### 输入

```
3 1

1 2
```

###### 输出

```
1
```

### 算法分类

并查集

### 题解分析与结论

该问题的核心是判断图中的连通分量数量，并计算将这些连通分量连接成一个连通图所需的最少边数。使用并查集（Disjoint Set Union, DSU）数据结构可以高效地管理连通分量，并快速判断两个节点是否属于同一个连通分量。

### 通用建议与扩展思路

1. **并查集优化**：在实现并查集时，使用路径压缩和按秩合并可以显著提高效率。
2. **连通分量计数**：通过遍历所有节点，统计并查集中不同根节点的数量，即为连通分量的数量。
3. **最少边数计算**：若有 $ k $ 个连通分量，则最少需要 $ k - 1 $ 条边将它们连接成一个连通图。

### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)

### 关键代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> parent;

int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]); // 路径压缩
    }
    return parent[x];
}

void unite(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) {
        parent[rootX] = rootY; // 按秩合并
    }
}

int main() {
    int N, M;
    cin >> N >> M;
    parent.resize(N + 1);
    for (int i = 1; i <= N; ++i) {
        parent[i] = i;
    }
    for (int i = 0; i < M; ++i) {
        int A, B;
        cin >> A >> B;
        unite(A, B);
    }
    int components = 0;
    for (int i = 1; i <= N; ++i) {
        if (find(i) == i) {
            components++;
        }
    }
    cout << components - 1 << endl;
    return 0;
}
```

### 代码解释

1. **初始化并查集**：`parent` 数组用于存储每个节点的父节点，初始时每个节点的父节点是它自己。
2. **查找操作**：`find` 函数通过路径压缩优化查找效率，确保每次查找的时间复杂度接近 $ O(1) $。
3. **合并操作**：`unite` 函数将两个节点所在的集合合并，使用按秩合并策略优化合并操作。
4. **统计连通分量**：遍历所有节点，统计并查集中不同根节点的数量，即为连通分量的数量。
5. **计算最少边数**：若有 $ k $ 个连通分量，则最少需要 $ k - 1 $ 条边将它们连接成一个连通图。

### 总结

通过并查集数据结构，可以高效地解决该问题。关键在于如何优化并查集的查找和合并操作，以及如何统计连通分量的数量。这类问题在图论中非常常见，掌握并查集的使用可以解决许多类似的连通性问题。

---
处理用时：30.86秒
# 题目信息

# [AGC002B] Box and Ball

## 题目描述

# [AGC002B] Box and Ball


有 $n$ 个盒子。起初每个盒子里有 $1$ 个球， $1$ 号盒子里的球是红色的，其余都是白色的。

现在给定 $m$ 个操作，每次给出二元组 $(x_i,y_i)$ 表示从 $x_i$ 中随机拿出一个球放进 $y_i$。

求在操作结束后有多少个盒子里**可能**装着红色小球。

——翻译 By 冬天的雨

# AI分析结果

### 题目内容重写
有 $n$ 个盒子。起初每个盒子里有 $1$ 个球，$1$ 号盒子里的球是红色的，其余都是白色的。

现在给定 $m$ 个操作，每次给出二元组 $(x_i,y_i)$ 表示从 $x_i$ 中随机拿出一个球放进 $y_i$。

求在操作结束后有多少个盒子里**可能**装着红色小球。

### 算法分类
模拟

### 综合分析与结论
本题的核心是通过模拟操作过程，跟踪红球可能的位置。题解的关键在于如何高效地维护每个盒子中是否有红球的可能性，以及如何处理盒子中球的数量变化。

### 所选高星题解
#### 题解1：作者：tony123456 (赞：2)
- **星级**：4星
- **关键亮点**：使用两个数组分别记录每个盒子是否有红球的可能性以及盒子中的球的数量，思路清晰，代码简洁。
- **核心实现思想**：通过遍历每个操作，更新红球可能的位置和盒子中的球的数量。如果某个盒子中的球被全部移出，则标记该盒子不再可能有红球。
- **核心代码片段**：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
bool a[100000];
int b[100000];
int main(){
    a[1]=1;//红球开始在1中
    int n,m;
    cin>>n>>m;//输入
    for(int i=1;i<=n;i++){
        b[i]=1;//赋初始值
    }
    for(int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        if(a[x]==1) {//判断红球有没有可能在原来的盒子中
            a[y]=1;
            if(b[x]==1) a[x]=0;//特判红球不能留在原来的盒子中
        }
        b[y]++;
        b[x]--;
    }
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=a[i];//统计可能有红球的盒子
    }
    cout<<sum;//输出
}
```

### 最优关键思路或技巧
- **数据结构**：使用两个数组分别记录每个盒子是否有红球的可能性以及盒子中的球的数量。
- **算法优化**：通过遍历操作，实时更新红球可能的位置和盒子中的球的数量，确保每次操作后都能准确反映红球的位置信息。
- **思维方式**：通过模拟操作过程，逐步排除不可能有红球的盒子，最终统计可能含有红球的盒子数量。

### 可拓展之处
- **同类型题**：类似的问题可以扩展到多个颜色的球，或者多个球在不同盒子之间的移动。
- **类似算法套路**：这种通过模拟操作过程，实时更新状态的思路可以应用于其他需要跟踪状态的题目，如状态机、事件驱动等。

### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)
3. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)

---
处理用时：17.53秒
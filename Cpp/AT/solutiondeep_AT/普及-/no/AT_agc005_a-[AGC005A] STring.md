# 题目信息

# [AGC005A] STring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc005/tasks/agc005_a

文字列 $ X $ が与えられます。$ X $ の長さは偶数であり、半分は `S` 、もう半分は `T` からなります。

高橋君は `ST` という文字列が苦手です。なので以下の操作を $ 10^{10000} $ 回行うことにしました。

- $ X $ の(連続な)部分文字列で `ST` となるもののうち、最も左側にあるものを取り除く。存在しないならば何もしない。

最終的に $ X $ は何文字になるかを求めてください。

## 说明/提示

### 制約

- $ 2\ ≦\ |X|\ ≦\ 200,000 $
- $ X $ の長さは偶数
- $ X $ を構成する文字のうち半分は `S` であり、もう半分は `T` である

### 部分点

- $ 200 $ 点分のデータセットでは $ |X|\ ≦\ 200 $ が成り立つ

### Sample Explanation 1

$ 1 $ 回目の操作では `TSTTSS` の $ 2,3 $ 文字目が `ST` なので取り除きます。 $ X $ は `TTSS` になり、もう `ST` はないため残り $ 10^{10000}-1 $ 回は何もしません。 よって答えは $ 4 $ となります。

### Sample Explanation 2

`SSTTST` ⇒ `STST` ⇒ `ST` ⇒ `` となり、最終的に空文字列になります。

### Sample Explanation 3

`TSSTTTSS` ⇒ `TSTTSS` ⇒ `TTSS` となります。

## 样例 #1

### 输入

```
TSTTSS```

### 输出

```
4```

## 样例 #2

### 输入

```
SSTTST```

### 输出

```
0```

## 样例 #3

### 输入

```
TSSTTTSS```

### 输出

```
4```

# AI分析结果

### 题目内容重写
给定一个字符串 $X$，其长度为偶数，且由一半的 `S` 和一半的 `T` 组成。高桥君不喜欢 `ST` 这个子串，因此他会进行 $10^{10000}$ 次操作，每次操作会删除 $X$ 中最左边的 `ST` 子串。如果不存在 `ST` 子串，则不进行任何操作。最终，求 $X$ 的剩余长度。

### 算法分类
字符串、模拟、栈

### 题解分析与结论
本题的核心问题是如何高效地删除字符串中的所有 `ST` 子串。由于操作次数极大（$10^{10000}$），直接模拟删除操作会导致超时。因此，题解主要集中在如何通过一次遍历或使用栈来模拟删除过程。

#### 题解对比
1. **栈的使用**：大多数题解都采用了栈的思想，通过遍历字符串，遇到 `S` 时压入栈，遇到 `T` 时检查栈顶是否为 `S`，如果是则弹出栈顶，表示删除一个 `ST` 子串。这种方法的时间复杂度为 $O(n)$，非常高效。
2. **统计删除次数**：部分题解通过统计 `S` 和 `T` 的匹配次数来计算最终剩余的字符数，而不是直接模拟删除过程。这种方法同样高效，且代码实现简单。
3. **其他方法**：个别题解尝试使用 `erase` 或链表等方法，但这些方法在时间效率上不如栈或统计法。

### 高星题解推荐
1. **作者：HanPi（5星）**
   - **关键亮点**：使用栈模拟删除过程，代码简洁高效，递归实现栈操作。
   - **代码核心**：
     ```c
     char st[200009];
     int sz;
     int main()
     {
         char c=getchar();
         if(c=='\r'||c=='\n')
         {
             printf("%d",sz);
             exit(0);
         }
         if(sz)
         {
             if(c=='T'&&st[sz-1]=='S')
             {
                 st[sz--]=0;
                 main();
             }
         }
         st[sz++]=c;
         main();
         return 0;
     }
     ```
   - **个人心得**：通过递归实现栈操作，代码简洁但可读性稍差。

2. **作者：happybob（4星）**
   - **关键亮点**：使用两个栈分别存储 `S` 和 `T`，逻辑清晰，代码可读性强。
   - **代码核心**：
     ```cpp
     stack<char> st, st2;
     int main()
     {
         ios::sync_with_stdio(false);
         cin.tie(0);
         cout.tie(0);
         string s;
         cin >> s;
         int len = s.length() - 1;
         for(register int i = 0; i <= len; i++)
         {
             if(s[i] == 'S') st.push('S');
             else if(s[i] == 'T' && !st.empty()) st.pop();
             else st2.push('T');
         }
         cout << st.size() + st2.size() << endl;
         return 0;
     }
     ```
   - **个人心得**：使用两个栈分别处理 `S` 和 `T`，逻辑清晰但代码稍显冗长。

3. **作者：TRZ_2007（4星）**
   - **关键亮点**：通过统计 `S` 和 `T` 的匹配次数来计算最终剩余字符数，代码简洁高效。
   - **代码核心**：
     ```cpp
     string S;
     int sums,sumt;
     int main()
     {
         cin>>S;
         for(int i=0;i<S.size();i++)
         {
             if(S[i] == 'S') sums++;
             if((sums)&&(S[i]=='T'))
             {
                 sums--;
                 sumt+=2;
             }
         }
         cout<<S.size()-sumt<<"\n";
     }
     ```
   - **个人心得**：通过统计匹配次数来计算剩余字符数，代码简洁且高效。

### 最优关键思路
使用栈或统计法来模拟删除 `ST` 子串的过程，避免直接模拟删除操作带来的时间开销。栈法通过压栈和弹栈操作来模拟删除过程，统计法则通过记录 `S` 和 `T` 的匹配次数来计算最终结果。

### 拓展思路
类似的问题可以扩展到其他需要删除特定子串的场景，如括号匹配、删除特定字符对等。栈在处理这类问题时非常高效，且代码实现简洁。

### 推荐题目
1. [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)
2. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
3. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)

### 个人心得摘录
- **HanPi**：通过递归实现栈操作，代码简洁但可读性稍差。
- **happybob**：使用两个栈分别处理 `S` 和 `T`，逻辑清晰但代码稍显冗长。
- **TRZ_2007**：通过统计匹配次数来计算剩余字符数，代码简洁且高效。

---
处理用时：32.07秒
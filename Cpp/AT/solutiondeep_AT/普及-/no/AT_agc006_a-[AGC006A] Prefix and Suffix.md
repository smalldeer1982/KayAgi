# 题目信息

# [AGC006A] Prefix and Suffix

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc006/tasks/agc006_a

すぬけ君は次の条件を満たす文字列に興味があります。

- 長さ $ N $ 以上である。
- 先頭 $ N $ 文字が文字列 $ s $ に一致する。
- 末尾 $ N $ 文字が文字列 $ t $ に一致する。

条件を満たす文字列のうち、最も短いものの長さを求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =N\ <\ =100 $
- $ s $, $ t $ は長さ $ N $ である。
- $ s $, $ t $ は英小文字のみからなる。

### Sample Explanation 1

最も短い文字列は `abcde` です。

### Sample Explanation 2

最も短い文字列は `az` です。

### Sample Explanation 3

最も短い文字列は `expr` です。

## 样例 #1

### 输入

```
3

abc

cde```

### 输出

```
5```

## 样例 #2

### 输入

```
1

a

z```

### 输出

```
2```

## 样例 #3

### 输入

```
4

expr

expr```

### 输出

```
4```

# AI分析结果

### 题目内容重写
#### 题目描述
すぬけ君对满足以下条件的字符串感兴趣：
- 长度至少为 $N$。
- 前 $N$ 个字符与字符串 $s$ 相同。
- 后 $N$ 个字符与字符串 $t$ 相同。

请找出满足条件的最短字符串的长度。

#### 说明/提示
##### 约束
- $1 \leq N \leq 100$
- $s$ 和 $t$ 的长度均为 $N$。
- $s$ 和 $t$ 仅由小写字母组成。

##### 样例解释
1. 最短字符串为 `abcde`。
2. 最短字符串为 `az`。
3. 最短字符串为 `expr`。

#### 样例 #1
##### 输入
```
3
abc
cde
```
##### 输出
```
5
```

#### 样例 #2
##### 输入
```
1
a
z
```
##### 输出
```
2
```

#### 样例 #3
##### 输入
```
4
expr
expr
```
##### 输出
```
4
```

### 算法分类
字符串

### 题解分析与结论
#### 题解对比
1. **Karry5307** 的题解：
   - **思路**：通过哈希优化，计算 $s$ 的后缀哈希值和 $t$ 的前缀哈希值，寻找最长的匹配部分。
   - **难点**：哈希值的计算和匹配部分的优化。
   - **评分**：4星。思路清晰，代码可读性较好，但哈希优化在实际应用中可能存在碰撞问题。

2. **Super_Cube** 的题解：
   - **思路**：直接暴力匹配 $s$ 的后缀和 $t$ 的前缀，寻找最长的重合部分。
   - **难点**：暴力匹配的时间复杂度较高，但在此题中由于 $N$ 较小，可以接受。
   - **评分**：4星。思路简单直接，代码易于理解，适合初学者。

3. **猜一猜我是谁** 的题解：
   - **思路**：通过枚举 $s$ 的每一位，寻找与 $t$ 开头匹配的部分，计算重合长度。
   - **难点**：枚举过程中需要确保匹配的连续性。
   - **评分**：3星。思路较为简单，但代码实现稍显繁琐。

#### 最优关键思路
通过寻找 $s$ 的后缀和 $t$ 的前缀的最长匹配部分，可以有效地减少字符串的总长度。具体实现可以通过哈希优化或暴力匹配来完成。

#### 可拓展之处
类似的问题可以扩展到更复杂的字符串匹配问题，如多字符串的前后缀匹配、带通配符的匹配等。

#### 推荐题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)
3. [P3371 【模板】AC自动机](https://www.luogu.com.cn/problem/P3371)

### 所选高分题解
#### 题解1：Karry5307
**星级**：4星
**关键亮点**：使用哈希优化，时间复杂度较低，代码结构清晰。
**核心代码**：
```cpp
for(register int i=0,j=length-1;i<length;i++,j--)
{
    if(suffix[i]==prefix[j])
    {
        return printf("%d\n",(length<<1)-j-1),0;
    }
}
```
**实现思想**：通过计算 $s$ 的后缀哈希值和 $t$ 的前缀哈希值，寻找最长的匹配部分，从而减少字符串的总长度。

#### 题解2：Super_Cube
**星级**：4星
**关键亮点**：直接暴力匹配，思路简单直接，代码易于理解。
**核心代码**：
```cpp
for(i=0;i<n;++i){
    k=i;j=0;
    while(k<n&&a[k]==b[j])++k,++j;//开始寻找重合部分
    if(k==n&&t<j)t=j;//能找到就更新最大值
}printf("%d",(n<<1)-t);
```
**实现思想**：通过暴力匹配 $s$ 的后缀和 $t$ 的前缀，寻找最长的重合部分，从而减少字符串的总长度。

---
处理用时：24.87秒
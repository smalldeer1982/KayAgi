# 题目信息

# [AGC014A] Cookie Exchanges

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc014/tasks/agc014_a

高橋君と青木君とすぬけ君はそれぞれクッキーを $ A,B,C $ 個持っています。

この $ 3 $ 人はお互いにクッキーを交換することにしました。具体的には、以下の操作を繰り返します。

- $ 3 $ 人は同時に、各々が持っているクッキーを半分ずつに分けて、残りの $ 2 $ 人にそれぞれ一方を渡す。

ただし、誰かの持っているクッキーの個数が奇数個になったら、そこで操作を繰り返すのをやめます。

さて、クッキーの交換は何回行うことができるでしょうか。 ただし、無限に続けられる場合もあることに注意してください。

## 说明/提示

### 制約

- $ 1\ ≦\ A,B,C\ ≦\ 10^9 $

### Sample Explanation 1

はじめ、高橋君と青木君とすぬけ君はそれぞれクッキーを $ 4,12,20 $ 個持っており、 - $ 1 $ 回目の操作後は、高橋君と青木君とすぬけ君はそれぞれクッキーを $ 16,12,8 $ 個持っている。 - $ 2 $ 回目の操作後は、高橋君と青木君とすぬけ君はそれぞれクッキーを $ 10,12,14 $ 個持っている。 - $ 3 $ 回目の操作後は、高橋君と青木君とすぬけ君はそれぞれクッキーを $ 13,12,11 $ 個持っている。 $ 3 $ 回目の操作後に高橋君とすぬけ君の持っているクッキーの個数が奇数個になるので、求める回数は $ 3 $ 回となります。

## 样例 #1

### 输入

```
4 12 20```

### 输出

```
3```

## 样例 #2

### 输入

```
14 14 14```

### 输出

```
-1```

## 样例 #3

### 输入

```
454 414 444```

### 输出

```
1```

# AI分析结果

### 题目内容翻译

#### [AGC014A] Cookie Exchanges

**题目描述**

高桥君、青木君和すぬけ君分别持有 $A, B, C$ 个饼干。他们决定互相交换饼干，具体操作如下：

- 三人同时将自己持有的饼干分成两半，然后将其中一半分别给另外两个人。

如果在某次操作后，任何一个人持有的饼干数量为奇数，则停止操作。

问：他们可以进行多少次这样的交换？注意，有可能无限进行下去。

**说明/提示**

**约束条件**

- $1 \leq A, B, C \leq 10^9$

**样例解释1**

初始时，高桥君、青木君和すぬけ君分别持有 $4, 12, 20$ 个饼干。

- 第一次操作后，他们分别持有 $16, 12, 8$ 个饼干。
- 第二次操作后，他们分别持有 $10, 12, 14$ 个饼干。
- 第三次操作后，他们分别持有 $13, 12, 11$ 个饼干。

在第三次操作后，高桥君和すぬけ君持有的饼干数量为奇数，因此操作次数为 $3$ 次。

**样例1**

**输入**

```
4 12 20
```

**输出**

```
3
```

**样例2**

**输入**

```
14 14 14
```

**输出**

```
-1
```

**样例3**

**输入**

```
454 414 444
```

**输出**

```
1
```

### 算法分类
数学、模拟

### 题解分析与结论

#### 题解1：Seauy (4星)

**关键亮点**
- 通过数学推导证明了操作次数最多为 $O(\log v)$ 次，其中 $v$ 是饼干数量的最大值。
- 使用递推公式分析了操作过程中饼干数量的变化，证明了在有限步数内会达到 $A=B=C$ 或出现奇数的情况。
- 代码简洁，直接模拟操作过程，复杂度为 $O(\log v)$。

**核心代码**
```cpp
while(1)
{
    if(a&1 || b&1 || c&1) break;
    if(a==b && b==c) return printf("-1\n"),0;
    ll A=a,B=b,C=c;
    a=(B+C)>>1;
    b=(A+C)>>1;
    c=(A+B)>>1;
    ++ans;
}
printf("%d\n",ans);
```

**实现思想**
- 通过循环模拟每次操作，检查是否有奇数出现或达到 $A=B=C$ 的情况。

#### 题解2：火车司机 (3星)

**关键亮点**
- 使用暴力搜索的方法，通过 `map` 记录状态，避免无限循环。
- 通过排序和 `map` 记录状态来判断是否进入循环。

**核心代码**
```cpp
for (ri i = 1, ta, tb, tc;; ++i)
{
    ta = a >> 1, tb = b >> 1, tc = c >> 1;
    a = tb + tc, b = ta + tc, c = ta + tb;
    if ((a & 1) || (b & 1) || (c & 1))
    {
        print(i);
        return 0;
    }
    if (a > b) a ^= b ^= a ^= b;
    if (a > c) a ^= c ^= a ^= c;
    if (b > c) b ^= c ^= b ^= c;
    t = (node){a, b, c};
    if (mp[t])
    {
        puts("-1");
        return 0;
    }
    mp[t] = 1;
}
```

**实现思想**
- 通过 `map` 记录每次操作后的状态，判断是否进入循环，避免无限操作。

### 最优关键思路
- 通过数学推导证明操作次数最多为 $O(\log v)$ 次，直接模拟操作过程即可。
- 使用 `map` 记录状态可以避免无限循环，但复杂度较高，不如数学推导的方法高效。

### 可拓展之处
- 类似的问题可以通过数学推导来减少复杂度，避免暴力搜索。
- 在模拟过程中，可以通过数学性质来优化操作次数。

### 推荐题目
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036)

### 个人心得
- 通过数学推导可以大大减少问题的复杂度，避免不必要的暴力搜索。
- 在模拟过程中，注意边界条件和状态记录，避免无限循环。

---
处理用时：29.14秒
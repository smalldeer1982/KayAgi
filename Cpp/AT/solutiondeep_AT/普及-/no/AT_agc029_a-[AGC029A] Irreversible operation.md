# 题目信息

# [AGC029A] Irreversible operation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc029/tasks/agc029_a

$ N $ 個のオセロの石が一列に並んでいます。 それぞれの石の状態は長さ $ N $ の文字列 $ S $ によって表されており、 $ S_i= $`B` のとき左から $ i $ 番目の石の表面は黒色、 $ S_i= $`W` のとき左から $ i $ 番目の石の表面は白色となっています。

ここで、以下の操作を行うことを考えます。

- 左から $ i $ 番目の石の表面が黒色、左から $ i+1 $ 番目の石の表面が白色であるような $ i $ ($ 1\ \leq\ i\ <\ N $) を一つ選び、 その $ 2 $ つの石をともに裏返す。つまり、左から $ i $ 番目の石の表面が白色、左から $ i+1 $ 番目の石の表面が黒色になるようにする。

最大で何回この操作を行うことができるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 2\times\ 10^5 $
- $ S_i= $`B` または `W`

### Sample Explanation 1

以下のようにして $ 2 $ 回の操作を行うことができます。 - 左から $ 2 $ 番目、$ 3 $ 番目の石を裏返す。 - 左から $ 1 $ 番目、$ 2 $ 番目の石を裏返す。

## 样例 #1

### 输入

```
BBW```

### 输出

```
2```

## 样例 #2

### 输入

```
BWBWBW```

### 输出

```
6```

# AI分析结果

### 题目内容翻译
给定一个长度为 $N$ 的字符串 $S$，表示一列奥赛罗石的状态。$S_i$ 为 `B` 表示第 $i$ 个石头的表面是黑色，$S_i$ 为 `W` 表示第 $i$ 个石头的表面是白色。你可以进行以下操作：

- 选择一个 $i$（$1 \leq i < N$），使得第 $i$ 个石头为黑色且第 $i+1$ 个石头为白色，然后将这两个石头翻转，即第 $i$ 个石头变为白色，第 $i+1$ 个石头变为黑色。

问最多可以进行多少次这样的操作。

### 算法分类
排序（逆序对）

### 题解分析与结论
本题的核心思路是将问题转化为求逆序对的数量。每次操作相当于减少一个逆序对，因此最大操作次数就是字符串中逆序对的总数。由于字符串中只有 `B` 和 `W` 两种字符，可以通过遍历字符串，记录每个 `W` 前面 `B` 的数量来快速计算逆序对的总数。

### 高星题解
#### 1. 作者：CQ_Bab (5星)
**关键亮点**：思路清晰，代码简洁，直接通过倒序遍历字符串计算逆序对的数量，时间复杂度为 $O(n)$。

**核心代码**：
```cpp
int B = 0, W = 0;
string s;
cin >> s;
for(int i = s.size() - 1; i >= 0; i--){
    if(s[i] == 'W') W++;
    else B += W;
}
cout << B << endl;
```

#### 2. 作者：Fr0sTy (4星)
**关键亮点**：通过正序遍历字符串，记录每个 `W` 前面 `B` 的数量，思路清晰，代码简洁。

**核心代码**：
```cpp
string str; long long sum_b = 0, ans = 0;
cin >> str;
for(int i = 0; i < str.size(); i++) {
    if(str[i] == 'B') sum_b++;
    if(str[i] == 'W') ans += sum_b;
}
printf("%lld", ans);
```

#### 3. 作者：Leasier (4星)
**关键亮点**：通过正序遍历字符串，记录每个 `W` 前面 `B` 的数量，代码简洁，思路清晰。

**核心代码**：
```cpp
char s[200007];
int len, t = 0;
ll ans = 0;
scanf("%s", s);
len = strlen(s);
for (int i = 0; i < len; i++){
    if (s[i] == 'B') t++;
    else ans += t;
}
printf("%lld", ans);
```

### 最优关键思路
通过遍历字符串，记录每个 `W` 前面 `B` 的数量，累加得到逆序对的总数。这种方法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$，非常高效。

### 可拓展之处
类似的问题可以通过转化为逆序对的数量来解决，例如某些排序问题或交换操作的最小次数问题。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)
3. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)

---
处理用时：20.27秒
# 题目信息

# [ARC021A] DEAD END

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc021/tasks/arc021_1

あなたは友人の高橋君からとあるゲームを熱烈にオススメされている。

このゲームは $ 4\ \times\ 4 $ のグリッド状に区切られた $ 16 $ 個のセルと、その上に置かれた数が書かれたタイルを使ってプレーする。$ 1 $ 回の操作では上下左右の $ 4 $ 方向のうちいずれかを指定することができ、指定した方向に向かってセル上のタイルが滑っていく。このとき、同じ数の書かれたタイル $ 2 $ 枚がぶつかるとその $ 2 $ 枚はグリッド上から取り除かれ、代わりに数を $ 2 $ 倍した別のタイルが $ 1 $ 枚新たに置かれる。

次の図は盤面の状態と、そこから右に向かって $ 1 $ 回操作を行った後の盤面の例である。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc021_1/bc1076be37559526a99cf6453c91f645c5d9b10f.png)

上下左右のどの方向を指定してもタイルがまったく滑ることができず、同じ数のタイルをぶつけることもできなくなったらゲームオーバーで、それまでに出来るだけ大きい数の書かれたタイルを作るのが目的だ。

このゲームは確かに非常に面白そうだと思ったが、まだ慣れていないからか、グリッド上がタイルでいっぱいになったときにゲームオーバーなのかをなかなか判別できない。そこで、グリッド上のタイルの情報が与えられたときにゲームオーバーの状態なのかどうかを判定するようなプログラムを書くことにした。

## 说明/提示

### Sample Explanation 1

上下にはタイルを動かすことができませんが、左右に動かせば $ 2 $ が書かれたタイルどうしや $ 8 $ が書かれたタイルどうしをぶつけることが可能です。

### Sample Explanation 2

どの方向に動かそうとしても同じ数の書かれたタイルをぶつけることができません。

## 样例 #1

### 输入

```
2 8 2 2

32 2 8 8

4 64 2 128

2 8 4 2```

### 输出

```
CONTINUE```

## 样例 #2

### 输入

```
2 4 16 4

8 32 128 8

2 64 16 2

32 4 32 4```

### 输出

```
GAMEOVER```

## 样例 #3

### 输入

```
2 4 2 4

4 2 4 2

2 4 2 4

4 2 4 2```

### 输出

```
GAMEOVER```

# AI分析结果

### 题目内容重写
#### [ARC021A] DEAD END

**题目描述**

你被朋友高桥君强烈推荐了一款游戏。这个游戏在一个4×4的网格上进行，网格上有16个单元格，每个单元格上有一个带有数字的方块。每次操作中，你可以选择上下左右四个方向之一，指定方向后，所有方块会向该方向滑动。如果两个相同数字的方块相撞，它们会被移除，并在该位置生成一个数字为原来两倍的新方块。

下图展示了棋盘状态以及向右滑动一次后的棋盘状态。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc021_1/bc1076be37559526a99cf6453c91f645c5d9b10f.png)

当无法再滑动方块或无法合并相同数字的方块时，游戏结束。游戏的目标是在游戏结束前尽可能生成更大的数字。

你还不熟悉这个游戏，无法判断棋盘是否已经满了且无法再进行操作。因此，你需要编写一个程序，根据棋盘上的方块信息，判断游戏是否已经结束。

**输入格式**

输入包含4行，每行4个整数，表示棋盘上每个方块的数字。

**输出格式**

如果游戏可以继续，输出"CONTINUE"；否则输出"GAMEOVER"。

**样例解释**

**样例1**  
上下无法滑动，但左右可以滑动，使得数字为2或8的方块相撞，因此输出"CONTINUE"。

**样例2**  
无论向哪个方向滑动，都无法使相同数字的方块相撞，因此输出"GAMEOVER"。

**样例3**  
无论向哪个方向滑动，都无法使相同数字的方块相撞，因此输出"GAMEOVER"。

### 算法分类
模拟

### 题解分析与结论
该题的核心逻辑是判断在4×4的棋盘上是否存在相邻的相同数字的方块。如果存在，游戏可以继续；否则，游戏结束。所有题解都采用了模拟的思路，通过遍历棋盘并检查每个方块的上下左右是否存在相同数字的方块来判断游戏是否结束。

### 评分较高的题解
#### 1. 作者：stry (4星)
**关键亮点**：代码简洁，直接遍历棋盘并检查每个方块的上下左右是否存在相同数字的方块，一旦发现立即输出"CONTINUE"并结束程序，否则输出"GAMEOVER"。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110][110];
int main()
{
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
        {
            cin>>a[i][j];
            if(a[i-1][j]==a[i][j]||a[i+1][j]==a[i][j]||a[i][j-1]==a[i][j]||a[i][j+1]==a[i][j])
            {
                cout<<"CONTINUE"<<endl; 
                return 0;
            }
        }
    cout<<"GAMEOVER"<<endl;
    return 0;
}
```

#### 2. 作者：百里亦守约 (4星)
**关键亮点**：边输入边判断，只检查当前方块的上方和左方是否存在相同数字的方块，减少了不必要的判断，提高了效率。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105][105];
int main()
{
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
        {
            cin>>a[i][j]; //边输入边做
            if(a[i-1][j]==a[i][j] || a[i][j-1]==a[i][j]) //判断它的前面和后面是否相等
            {
                cout<<"CONTINUE"<<endl; //输出
                return 0;
            }
        }
    cout<<"GAMEOVER"<<endl; //否则输出
    return 0;
}
```

#### 3. 作者：zoobidubi (4星)
**关键亮点**：代码结构清晰，遍历棋盘并检查每个方块的上下左右是否存在相同数字的方块，一旦发现立即输出"CONTINUE"并结束程序，否则输出"GAMEOVER"。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[11][11];
int main()
{
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            cin>>a[i][j];//简单的读入不解释（printf也是可以的）
    for(int i=1;i<=4;i++)
    {
        for(int j=1;j<=4;j++)
        {
            if(a[i][j+1]==a[i][j]||a[i][j-1]==a[i][j]||a[i-1][j]==a[i][j]||a[i+1][j]==a[i][j])//判断是否边上是否有能够消的
            {
                cout<<"CONTINUE";//如果有一个的话就直接输出并结束程序
                return 0;    
            }
        }
    }
    cout<<"GAMEOVER";//如果都没有能消的就游戏结束
    return 0;//好习惯。。。
}
```

### 最优关键思路
最优的思路是边输入边判断，只检查当前方块的上方和左方是否存在相同数字的方块，这样可以减少不必要的判断，提高效率。

### 可拓展之处
该题可以拓展到更大的棋盘或不同的滑动规则，例如允许对角线滑动或不同数字的方块合并。类似的问题还包括判断棋盘是否可解或寻找最优滑动路径。

### 推荐题目
1. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
2. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)
3. [P1088 火星人](https://www.luogu.com.cn/problem/P1088)

---
处理用时：32.68秒
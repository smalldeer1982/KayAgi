# 题目信息

# [ARC059C] いっしょ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc059/tasks/arc059_a

$ N $ 個の整数 $ a_1,a_2,..,a_N $ が与えられます。えび君はこれらを書き換えて全て同じ**整数**にしようとしています。各$ a_i\ (1≦i≦N) $は高々一回しか書き換えられません(書き換えなくても良い)。整数$ x $を整数$ y $に書き換えるとき、コストが$ (x-y)^2 $かかります。仮に$ a_i=a_j\ (i≠j) $だとしても、ひとつ分のコストで同時に書き換えることは出来ません(入出力例$ 2 $ を参照)。えび君が目的を達成するのに必要なコストの総和の最小値を求めてください。

## 说明/提示

### 制約

- $ 1≦N≦100 $
- $ -100≦a_i≦100 $

### Sample Explanation 1

全てを$ 6 $に書き換えると、コストの総和は$ (4-6)^2+(8-6)^2=8 $となり、これが最小です。

### Sample Explanation 2

全てを$ 2 $に書き換えると$ (1-2)^2+(1-2)^2+(3-2)^2=3 $となります。各$ a_i $ごとに書き換えるので、二つの$ 1 $を一度にコスト$ (1-2)^2 $で書き換えられるわけではないことに注意してください。

### Sample Explanation 3

$ 4 $は書き換えずに、$ 2 $と$ 5 $を共に$ 4 $に書き換えることで$ (2-4)^2+(5-4)^2=5 $が達成できて、これが最小です。

### Sample Explanation 4

何も書き換えなくともえび君は目的を達成しています。よってこの場合コストは$ 0 $です。

## 样例 #1

### 输入

```
2

4 8```

### 输出

```
8```

## 样例 #2

### 输入

```
3

1 1 3```

### 输出

```
3```

## 样例 #3

### 输入

```
3

4 2 5```

### 输出

```
5```

## 样例 #4

### 输入

```
4

-100 -100 -100 -100```

### 输出

```
0```

# AI分析结果

### 题目翻译
# [ARC059C] いっしょ

## 题目描述

给定 $N$ 个整数 $a_1,a_2,..,a_N$。你需要将这些数改写为相同的整数。每个 $a_i\ (1≦i≦N)$ 最多只能改写一次（也可以不改写）。将整数 $x$ 改写为整数 $y$ 时，需要花费 $(x-y)^2$ 的代价。即使 $a_i=a_j\ (i≠j)$，也不能用一个代价同时改写它们（参见样例2）。你需要求出将所有数改写为相同整数所需的最小总代价。

## 说明/提示

### 约束

- $1≦N≦100$
- $-100≦a_i≦100$

### 样例解释

#### 样例1
输入：
```
2
4 8
```
输出：
```
8
```
解释：将所有数改写为6，总代价为 $(4-6)^2+(8-6)^2=8$，这是最小的。

#### 样例2
输入：
```
3
1 1 3
```
输出：
```
3
```
解释：将所有数改写为2，总代价为 $(1-2)^2+(1-2)^2+(3-2)^2=3$。注意，两个1不能用一个代价同时改写。

#### 样例3
输入：
```
3
4 2 5
```
输出：
```
5
```
解释：将2和5改写为4，总代价为 $(2-4)^2+(5-4)^2=5$，这是最小的。

#### 样例4
输入：
```
4
-100 -100 -100 -100
```
输出：
```
0
```
解释：所有数已经相同，不需要改写，总代价为0。

### 算法分类
枚举

### 题解分析与结论
本题的核心思想是通过枚举所有可能的整数作为目标值，计算将数组中所有数改写为该目标值所需的总代价，并找到最小代价。由于数组中的数范围较小（-100到100），可以直接暴力枚举所有可能的整数作为目标值。

### 所选题解
#### 题解1：作者：encore (赞：6)
- **星级**：5星
- **关键亮点**：通过枚举数组中最小值和最大值之间的所有整数作为目标值，计算总代价，找到最小值。代码简洁，思路清晰。
- **个人心得**：作者提到在调试过程中发现即使答案为0也需要输出，这是一个容易被忽略的细节。

```cpp
#include<iostream>
#include<cmath>
#define f(x) (x)*(x)

using namespace std;

int n;
int a[1001];
int cnt;
int ans;
int tt=0x7fffffff;

int main()
{
	cin>>n;
	int mi=tt,ma=-tt;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		cnt+=a[i];
		if(a[i]<mi) mi=a[i];
		if(a[i]>ma) ma=a[i];
	}
	int t=cnt/n;
	for(int k=mi;k<=ma;k++)
	{
		ans=0;
		for(int i=1;i<=n;i++)
		{
			ans+=f(a[i]-k);
		}
		if(ans<tt) tt=ans;
	}
	cout<<tt;
	return 0;
}
```

#### 题解2：作者：PrincessQi (赞：2)
- **星级**：4星
- **关键亮点**：通过数学推导，证明目标值应尽可能接近数组的平均值，从而减少枚举范围。代码简洁，数学推导清晰。
- **个人心得**：作者通过数学公式推导出目标值的选择策略，减少了枚举的范围。

```python
n=int(input())
s=input()
s.split(" ")
S=0
SS=0
for i in range(0,n-1):
    S=S+int(s[i])
    SS=SS+int(s[i])*int(s[i])
print(int(SS+n*(S/n-round(S/n))*(S/n-round(S/n))-S*S/n/n))
```

#### 题解3：作者：Cocoly1990 (赞：0)
- **星级**：4星
- **关键亮点**：通过枚举数组中最小值和最大值之间的所有整数作为目标值，计算总代价，找到最小值。代码简洁，思路清晰。
- **个人心得**：作者提到在调试过程中发现即使答案为0也需要输出，这是一个容易被忽略的细节。

```cpp
#include<bits/stdc++.h>
using namespace std ;
long long n , a[100007] , _max = -0x7ffffff , _min = 0x7ffffff, s , sum , ans = 0x7ffffff;
int main()
{
    cin >> n ;
    for(int i = 1 ; i <= n ; i ++)
    {
        cin >> a[i] ;
        _max = max(_max , a[i]) ;
        _min = min(_min , a[i]) ;
    }
    for(int j = _min ; j <= _max ; j ++)
        {
            sum = 0 ;
            for(int i = 1 ; i <= n ; i ++)
            {
            sum += (a[i] - j) * (a[i] - j) ;
            }
            if(sum < ans) ans = sum ;
        }


    cout << ans ;
    //system("pause") ;
    return 0 ;
    
}
```

### 最优关键思路或技巧
1. **枚举法**：由于数组中的数范围较小，可以直接枚举所有可能的整数作为目标值，计算总代价，找到最小值。
2. **数学优化**：通过数学推导，证明目标值应尽可能接近数组的平均值，从而减少枚举范围。

### 可拓展之处
类似的问题可以通过枚举法或数学优化来解决，尤其是在数据范围较小的情况下。例如，求数组中所有数到某个目标值的最小距离和等问题。

### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)

### 个人心得总结
在调试过程中，发现即使答案为0也需要输出，这是一个容易被忽略的细节。通过数学推导可以减少枚举范围，提高代码效率。

---
处理用时：34.93秒
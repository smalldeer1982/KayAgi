# 题目信息

# [ABC053D] Card Eater

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc053/tasks/arc068_b

すぬけくんはカードゲームで遊ぶことにしました。 $ N $ 枚からなるカードの山があり、上から $ i $ 枚目のカードには整数 $ A_i $ が書かれています。

すぬけくんはこのカードの山に対し $ 0 $ 回以上、以下の操作を行い、残ったカードに書かれた値が互いに異なるようにしたいです。最大で何枚のカードを残すことが可能か求めなさい。なお、$ N $ は奇数であり、少なくとも $ 1 $ 枚のカードを残すことが可能であることが保証されます。

操作：カードの山から任意の $ 3 $ 枚のカードを抜き出す。抜き出したカードのうち書かれた値が最大であるようなカード $ 1 $ 枚と最小であるようなカード $ 1 $ 枚の合計 $ 2 $ 枚を選んで食べる。その後残った $ 1 $ 枚をカードの山に戻す。

## 说明/提示

### 制約

- $ 3\ ≦\ N\ ≦\ 10^{5} $
- $ N $ は奇数
- $ 1\ ≦\ A_i\ ≦\ 10^{5} $
- $ A_i $ は整数

### Sample Explanation 1

操作を $ 1 $ 回行って $ 1,1,2 $ を取り出すというのが最適な操作手順の $ 1 $ つです。最大値である $ 2 $ と書かれたカードで最小値である $ 1 $ と書かれたカードがそれぞれ $ 1 $ 枚ずつ食べられ、残った $ 1 $ と書かれたカードがカードの山に戻されます。カードの山に残っているカードは $ 1,3,7 $ となり、これらは互いに異なります。

## 样例 #1

### 输入

```
5

1 2 1 3 7```

### 输出

```
3```

## 样例 #2

### 输入

```
15

1 3 5 2 1 3 2 8 8 6 2 6 11 1 1```

### 输出

```
7```

# AI分析结果

### 题目内容重写

**题目描述**

すぬけくん决定玩一个卡牌游戏。有一堆由 $N$ 张卡牌组成的牌堆，从上到下第 $i$ 张卡牌上写有一个整数 $A_i$。

すぬけくん可以对这堆卡牌进行以下操作任意次（包括零次），使得最终剩下的卡牌上的数字互不相同。求最多可以剩下多少张卡牌。注意，$N$ 是奇数，并且至少可以剩下一张卡牌。

**操作**：从牌堆中任意取出 $3$ 张卡牌，然后吃掉其中数字最大的卡牌和数字最小的卡牌，最后将剩下的 $1$ 张卡牌放回牌堆。

**说明/提示**

- 约束条件：$3 \leq N \leq 10^5$，$N$ 是奇数，$1 \leq A_i \leq 10^5$，$A_i$ 是整数。

**样例 #1**

输入：
```
5
1 2 1 3 7
```
输出：
```
3
```

**样例 #2**

输入：
```
15
1 3 5 2 1 3 2 8 8 6 2 6 11 1 1
```
输出：
```
7
```

### 算法分类
贪心

### 题解分析与结论

该题的核心思路是通过贪心策略，尽可能多地保留不重复的卡牌。所有题解都提到了统计重复卡牌的数量，并根据重复数量的奇偶性决定最终保留的卡牌数量。主要思路如下：

1. **统计重复卡牌数量**：通过排序或使用哈希表（如布尔数组）统计每种卡牌的重复次数。
2. **处理重复卡牌**：如果重复卡牌的数量是奇数，则需要多删除一张卡牌（因为每次操作删除两张卡牌）。
3. **计算最终结果**：总卡牌数减去删除的卡牌数即为最终保留的卡牌数。

### 评分较高的题解

#### 题解1：MZY666 (5星)
**关键亮点**：
- 使用布尔数组统计重复卡牌数量，代码简洁高效。
- 详细解释了如何处理奇数个重复卡牌的情况。
- 代码可读性强，注释清晰。

**核心代码**：
```cpp
bool a[100005]; // a[i]表示是否有i这么一张牌，初始值为false
int main(){
    ll n,k,i,again=0; // k用于暂存输入，again记录重复的次数。
    scanf("%lld",&n); // 输入n
    for(i=1;i<=n;i++){
        scanf("%lld",&k);
        if(a[k]) again++; // 如果这个数之前有过,again++
        else a[k]=true; // 否则将此数标记为true
    }
    again+=again%2; // 处理奇数个重复卡牌的情况
    printf("%lld",n-again); // 输出剩余的牌数
    return 0;
}
```

#### 题解2：ZolaWatle (4星)
**关键亮点**：
- 详细分析了题目操作的本质，简化了问题。
- 提供了两种统计重复卡牌数量的方法，并给出了代码实现。
- 解释了如何处理奇数个重复卡牌的情况。

**核心代码**：
```cpp
bool a[100001]={0}; // 定义只需用bool型
for(re i=1;i<=n;i++) { // 从1到n依次扫描
    std::cin>>tmp; // 对于这一种方法，没有开数组的必要
    if(!a[tmp]) a[tmp]=1; // 相当于if(a[tmp]==0)，没有出现过
    else cnt++; // 如果出现过，计数器加一
}
if(cnt%2==1) cnt++; // 多出来的牌是奇数，多牺牲一张已经满足题目要求的牌
cnt=n-cnt; // 把最少删去转化为最多剩余
std::cout<<cnt; // 输出
```

#### 题解3：梦游的小雪球 (4星)
**关键亮点**：
- 简化了题目描述，直接指出每次操作相当于删除两张卡牌。
- 代码简洁，逻辑清晰。
- 提供了排序和统计重复卡牌数量的方法。

**核心代码**：
```cpp
sort(a+1,a+1+n);
for(int i=2;i<=n;i++)
    if(a[i]==a[i-1]) s++;
if(s%2) s++;
cout<<n-s<<endl;
```

### 最优关键思路与技巧
- **统计重复卡牌数量**：使用布尔数组或排序后遍历统计重复卡牌数量。
- **处理奇数个重复卡牌**：如果重复卡牌数量为奇数，则需多删除一张卡牌。
- **贪心策略**：尽可能多地保留不重复的卡牌，通过删除重复卡牌来达到目标。

### 可拓展之处
- 类似问题可以扩展到其他需要去重或统计重复元素的场景，如字符串处理、数组去重等。
- 可以进一步优化统计重复卡牌数量的方法，如使用哈希表或位运算。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得摘录
- **MZY666**：通过布尔数组统计重复卡牌数量，代码简洁高效，处理奇数个重复卡牌的情况时思路清晰。
- **ZolaWatle**：详细分析了题目操作的本质，简化了问题，提供了两种统计重复卡牌数量的方法，代码实现清晰。
- **梦游的小雪球**：简化了题目描述，直接指出每次操作相当于删除两张卡牌，代码简洁，逻辑清晰。

---
处理用时：32.31秒
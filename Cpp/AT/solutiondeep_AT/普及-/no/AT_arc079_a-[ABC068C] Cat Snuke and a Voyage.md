# 题目信息

# [ABC068C] Cat Snuke and a Voyage

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc068/tasks/arc079_a

高橋キングダムには、高橋諸島という、$ N $ 個の島からなる諸島があります。 便宜上、これらの島を島 $ 1 $、島 $ 2 $、 ...、島 $ N $ と呼ぶことにします。

これらの諸島の間では、船の定期便が $ M $ 種類運行されています。 定期便はそれぞれ $ 2 $ つの島の間を行き来しており、$ i $ 種類目の定期便を使うと、 島 $ a_i $ と島 $ b_i $ の間を行き来する事ができます。

すぬけくんは今島 $ 1 $ にいて、島 $ N $ に行きたいと思っています。 しかし、島 $ 1 $ から島 $ N $ への定期便は存在しないことがわかりました。 なので、定期便を $ 2 $ つ使うことで、島 $ N $ に行けるか調べたいと思っています。

これを代わりに調べてあげてください。

## 说明/提示

### 制約

- $ 3\ ≦\ N\ ≦\ 200,000 $
- $ 1\ ≦\ M\ ≦\ 200,000 $
- $ 1\ ≦\ a_i\ <\ b_i\ ≦\ N $
- $ (a_i,\ b_i)\ \neq\ (1,\ N) $
- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $

### Sample Explanation 2

島 $ 4 $ へ行くには、定期便を $ 3 $ つ使う必要があります。

### Sample Explanation 4

島 $ 1 $、島 $ 4 $、島 $ 5 $ と移動すれば $ 2 $ つの定期便で移動可能です。

## 样例 #1

### 输入

```
3 2

1 2

2 3```

### 输出

```
POSSIBLE```

## 样例 #2

### 输入

```
4 3

1 2

2 3

3 4```

### 输出

```
IMPOSSIBLE```

## 样例 #3

### 输入

```
100000 1

1 99999```

### 输出

```
IMPOSSIBLE```

## 样例 #4

### 输入

```
5 5

1 3

4 5

2 3

2 4

1 4```

### 输出

```
POSSIBLE```

# AI分析结果

### 题目内容重写
高橋王国有一个由 $N$ 个岛屿组成的高橋诸岛，这些岛屿分别称为岛 $1$、岛 $2$、...、岛 $N$。这些岛屿之间有 $M$ 种定期船服务，每种服务连接两个岛屿，第 $i$ 种服务可以让你在岛 $a_i$ 和岛 $b_i$ 之间往返。

Snuke 现在在岛 $1$，他想去岛 $N$。然而，他发现没有直接从岛 $1$ 到岛 $N$ 的定期船。因此，他想知道是否可以通过乘坐两次定期船从岛 $1$ 到达岛 $N$。

### 算法分类
图论

### 题解分析与结论
题目要求判断是否可以通过两次船程从岛 $1$ 到达岛 $N$。核心思路是找到是否存在一个中间岛 $c$，使得存在从岛 $1$ 到岛 $c$ 的船程，以及从岛 $c$ 到岛 $N$ 的船程。

### 所选题解
#### 作者：zybnxy (4星)
**关键亮点**：
- 使用两个数组 `a` 和 `b` 分别记录从岛 $1$ 出发的船程终点和到达岛 $N$ 的船程起点。
- 通过遍历数组 `a` 和 `b`，检查是否存在一个岛 $c$ 同时出现在 `a` 和 `b` 中。
- 时间复杂度为 $O(N)$，代码简洁高效。

**核心代码**：
```cpp
#include<cstdio>
int a[1000001],b[1000001];
int main()
{
	int n,m,i;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		int st,ed;
		scanf("%d%d",&st,&ed);
		if(st==1)a[ed]=1;//记录第一次坐船的终点 
		if(ed==n)b[st]=1;//记录第二次坐船的起点 
	}
	for(i=1;i<=m;i++)
		if(a[i]&&b[i])//等价于a[i]==1&&b[1]==1 
		{
			printf("POSSIBLE\n");return 0;//若有，直接退出 
		}
	printf("IMPOSSIBLE\n");
	return 0;
}
```

#### 作者：loceaner (4星)
**关键亮点**：
- 使用两个数组 `arr` 和 `brr` 分别记录从岛 $1$ 出发的船程终点和到达岛 $N$ 的船程起点。
- 对数组 `arr` 和 `brr` 进行排序，然后使用双指针法查找是否存在一个岛 $c$ 同时出现在 `arr` 和 `brr` 中。
- 时间复杂度为 $O(M \log M)$，代码较长但思路清晰。

**核心代码**：
```cpp
#include<bits/stdc++.h>
#define N 200010
using namespace std;

int arr[N];
int brr[N];
int p=0,q=0;
int n,m;

int main() {
	cin>>n>>m;
	for(int i=0; i<m; i++) {
		int a,b;
		cin>>a>>b;
		if(a==1) arr[p++]=b;
		if(b==n) brr[q++]=a;
	}
	if(p==0||q==0) {
		cout<<"IMPOSSIBLE";
		return 0;
	}
	sort(arr,arr+p);
	sort(brr,brr+q);
	int i,j=1;
	for(i=0; i<p; i++) {
		j--;
		for(j; j<q; j++) {
			if(arr[i]==brr[j]) {
				break;
			}
			if(arr[i]<brr[j])
				break;
		}
		if(arr[i]==brr[j])
			break;
	}
	if(arr[i]==brr[j]&&i!=p)
		cout<<"POSSIBLE";
	else
		cout<<"IMPOSSIBLE";
	return 0;
}
```

### 最优关键思路或技巧
- **数组记录法**：通过两个数组分别记录从起点和终点的船程，然后检查是否存在交集。
- **双指针法**：在排序后的数组中，使用双指针法快速查找是否存在交集。

### 可拓展之处
- 类似的问题可以扩展到多次船程的判断，如判断是否可以通过三次船程到达目的地。
- 可以使用图论中的广度优先搜索（BFS）或深度优先搜索（DFS）来解决更复杂的路径问题。

### 推荐题目
1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
3. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得
- **调试经历**：在实现双指针法时，需要注意指针的初始化和边界条件，避免数组越界。
- **顿悟感想**：通过数组记录法，可以简化问题，避免复杂的图论算法，提高代码的可读性和效率。

---
处理用时：31.20秒
# 题目信息

# [ABC072C] Together

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc072/tasks/arc082_a

長さ $ N $ の整数列 $ a_1,a_2,...,a_N $ が与えられます。

各 $ 1\ <\ =i\ <\ =N $ に対し、$ a_i $ に $ 1 $ 足すか、$ 1 $ 引くか、なにもしないかの三つの操作からどれか一つを選んで行います。

この操作の後、ある整数 $ X $ を選んで、$ a_i=X $ となる $ i $ の個数を数えます。

うまく操作を行い、$ X $ を選ぶことで、この個数を最大化してください。

## 说明/提示

### 制約

- $ 1\ <\ =N\ <\ =10^5 $
- $ 0\ <\ =a_i\ <\ 10^5\ (1\ <\ =i\ <\ =N) $
- $ a_i $ は整数

### Sample Explanation 1

例えば操作後の数列を $ 2,2,3,2,6,9,2 $ とすることができて、$ X=2 $ とすると $ 4 $ を得ることができ、これが最大です。

## 样例 #1

### 输入

```
7

3 1 4 1 5 9 2```

### 输出

```
4```

## 样例 #2

### 输入

```
10

0 1 2 3 4 5 6 7 8 9```

### 输出

```
3```

## 样例 #3

### 输入

```
1

99999```

### 输出

```
1```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个长度为 $N$ 的整数序列 $a_1, a_2, ..., a_N$。

对于每个 $1 \leq i \leq N$，可以对 $a_i$ 进行以下三种操作之一：加1、减1、或保持不变。

操作后，选择一个整数 $X$，统计满足 $a_i = X$ 的 $i$ 的个数。

请通过合理的操作和选择 $X$，使得这个个数最大化。

【说明/提示】

### 约束

- $1 \leq N \leq 10^5$
- $0 \leq a_i < 10^5$ （$1 \leq i \leq N$）
- $a_i$ 是整数

### 样例解释

例如，操作后的序列可以是 $2, 2, 3, 2, 6, 9, 2$，选择 $X=2$ 时，可以得到4个满足条件的 $i$，这是最大的可能值。

### 样例输入输出

**样例 #1**

输入：
```
7
3 1 4 1 5 9 2
```
输出：
```
4
```

**样例 #2**

输入：
```
10
0 1 2 3 4 5 6 7 8 9
```
输出：
```
3
```

**样例 #3**

输入：
```
1
99999
```
输出：
```
1
```

### 算法分类
枚举

### 题解分析与结论

本题的核心思路是通过枚举每个数可能的操作结果，统计每个可能的 $X$ 的频次，最终选择频次最大的 $X$。由于每个数只能进行加1、减1或保持不变的操作，因此每个数最多只能影响到其本身、加1和减1三个位置。通过使用桶计数的方法，可以高效地统计每个 $X$ 的频次。

### 所选高分题解

#### 1. 作者：信息向阳花木 (4星)
**关键亮点**：
- 使用桶计数的方法，简洁高效。
- 代码清晰，逻辑明确。

**核心代码**：
```cpp
int n, maxx, ans;
int x, b[100010]; // b 是桶
int main() {
    scanf("%d", &n);
    for(int i=1; i<=n; i++){
        cin >> x;
        maxx = max(x, maxx); // 记录最大范围
        b[x]++; b[x-1]++; b[x+1]++;
    }
    for(int i=0; i<=maxx+1; i++){ // 最大的数也有可能进行加1操作
        ans = max(b[i], ans); // 注意求的不是x而是有多少a[i]等于x
    }
    cout << ans;
    return 0;
}
```

#### 2. 作者：亦枫 (4星)
**关键亮点**：
- 使用桶计数，代码简洁。
- 使用 `max_element` 函数简化最大值查找。

**核心代码**：
```cpp
int n, a[100005], cnt[100005], ans;
int main() {
    scanf("%d", &n);
    for(register int i=1; i<=n; i++) scanf("%d", &a[i]), cnt[a[i]]++, cnt[a[i]+1]++, cnt[a[i]-1]++;
    printf("%d\n", *max_element(cnt, cnt+100000)); // 找到最大值
    return 0;
}
```

#### 3. 作者：liangbowen (4星)
**关键亮点**：
- 在计数过程中实时更新最大值，减少了一次遍历。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
int box[100005];
int main() {
    int n, maxn = -1;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        int x;
        scanf("%d", &x);
        box[x-1]++, maxn = max(maxn, box[x-1]);  // 一边走一边判断
        box[x]++, maxn = max(maxn, box[x]);
        box[x+1]++, maxn = max(maxn, box[x+1]);
    }
    printf("%d\n", maxn);   // 勿忘祖传换行
    return 0;
}
```

### 最优关键思路与技巧

1. **桶计数法**：通过桶数组统计每个数及其相邻数的频次，避免重复计算。
2. **实时更新最大值**：在计数过程中实时更新最大值，减少一次遍历，优化时间复杂度。
3. **边界处理**：注意处理数组边界，避免越界访问。

### 可拓展之处

类似的问题可以通过桶计数或哈希表来统计频次，适用于需要统计某个值或某个范围内值的频次的场景。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

### 个人心得摘录

- **信息向阳花木**：通过桶计数的方法，简洁高效地解决了问题。
- **liangbowen**：在计数过程中实时更新最大值，减少了一次遍历，优化了时间复杂度。

这些心得强调了代码优化和逻辑清晰的重要性，值得学习。

---
处理用时：34.63秒
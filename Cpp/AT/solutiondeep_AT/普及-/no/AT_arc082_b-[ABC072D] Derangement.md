# 题目信息

# [ABC072D] Derangement

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc072/tasks/arc082_b

$ 1,2,..,N $ からなる順列 $ p_1,p_2,..,p_N $ が与えられます。 次の操作を何回か ($ 0 $回でもよい) 行うことが出来ます。

操作: 順列で**隣り合う**二つの数を選んでスワップする。

何回か操作を行って、任意の $ 1\ <\ =i\ <\ =N $ に対して $ p_i\ ≠\ i $ となるようにしたいです。 必要な操作の最小回数を求めてください。

## 说明/提示

### 制約

- $ 2\ <\ =N\ <\ =10^5 $
- $ p_1,p_2,..,p_N $ は $ 1,2,..,N $ の順列である。

### Sample Explanation 1

$ 1 $ と $ 4 $ を入れ替え、その後 $ 1 $ と $ 3 $ を入れ替えることで $ p $ は $ 4,3,1,5,2 $ となり、これは条件を満たします。 これが最小回数なので、答えは $ 2 $ となります。

### Sample Explanation 2

$ 1 $ と $ 2 $ を入れ替えれば条件を満たします。

### Sample Explanation 3

初めから条件を満たしています。

## 样例 #1

### 输入

```
5

1 4 3 5 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2

1 2```

### 输出

```
1```

## 样例 #3

### 输入

```
2

2 1```

### 输出

```
0```

## 样例 #4

### 输入

```
9

1 2 4 9 5 8 7 3 6```

### 输出

```
3```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个由 $1,2,..,N$ 组成的排列 $p_1,p_2,..,p_N$。你可以进行以下操作任意次（包括0次）：

**操作**：选择排列中**相邻**的两个数并交换它们。

通过若干次操作后，希望对于任意 $1 \leq i \leq N$，都有 $p_i \neq i$。求达成这一目标所需的最小操作次数。

#### 说明/提示

##### 约束

- $2 \leq N \leq 10^5$
- $p_1,p_2,..,p_N$ 是 $1,2,..,N$ 的排列。

#### 样例

##### 样例 #1

**输入**

```
5
1 4 3 5 2
```

**输出**

```
2
```

##### 样例 #2

**输入**

```
2
1 2
```

**输出**

```
1
```

##### 样例 #3

**输入**

```
2
2 1
```

**输出**

```
0
```

##### 样例 #4

**输入**

```
9
1 2 4 9 5 8 7 3 6
```

**输出**

```
3
```

### 算法分类

贪心

### 题解分析与结论

#### 题解对比

1. **makerlife** (4星)
   - **关键亮点**：从前到后遍历数组，当 $p_i = i$ 时，交换 $p_i$ 和 $p_{i+1}$，并累加操作次数。思路清晰，代码简洁。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=n;i++) {
         if(p[i]==i) {
             ans++;
             swap(p[i],p[i+1]);
         }
     }
     ```

2. **Krimson** (4星)
   - **关键亮点**：同样采用从前到后遍历的策略，当 $p_i = i$ 时，交换 $p_i$ 和 $p_{i+1}$。代码简洁，逻辑清晰。
   - **代码核心**：
     ```cpp
     for(ri i=1;i<=n;++i) {
         if(a[i]==i) {
             swap(a[i+1],a[i]);
             ++ans;
         }
     }
     ```

3. **Fire_Raku** (4星)
   - **关键亮点**：在遍历时，如果 $p_i = i$，交换 $p_i$ 和 $p_{i+1}$，并跳过 $p_{i+1}$ 的检查。代码简洁，逻辑清晰。
   - **代码核心**：
     ```cpp
     for(int i=1;i<n;i++) {
         if(a[i]==i) {
             ans++;
             swap(a[i],a[i+1]);
             i++;
         }
     }
     ```

#### 最优关键思路

- **贪心策略**：从前到后遍历数组，当发现 $p_i = i$ 时，立即交换 $p_i$ 和 $p_{i+1}$。这样可以确保每次交换都能解决当前问题，并且不会影响后续的检查。
- **代码实现**：通过简单的 `swap` 操作和累加操作次数，代码简洁且高效。

#### 可拓展之处

- **类似问题**：可以考虑在更复杂的排列问题中应用类似的贪心策略，例如在需要满足多个条件的情况下进行交换操作。
- **算法优化**：如果数据规模更大，可以考虑并行处理或进一步优化遍历策略。

### 推荐题目

1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得总结

- **调试经历**：在实现时，需要注意数组越界问题，尤其是在交换 $p_i$ 和 $p_{i+1}$ 时，确保 $i+1$ 不超过数组范围。
- **顿悟感想**：贪心策略在解决这类问题时非常有效，尤其是在需要最小化操作次数的情况下，通过局部最优解可以达到全局最优解。

---
处理用时：24.49秒
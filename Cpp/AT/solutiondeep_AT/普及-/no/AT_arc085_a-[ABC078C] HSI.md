# 题目信息

# [ABC078C] HSI

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc078/tasks/arc085_a

高橋くんはプログラミングコンテストに出ていますが， `YES` か `NO` で答える問題でTLEしてしまいました。

提出の詳細を見ると，テストケースは全てで $ N $ ケースあり，そのうち $ M $ ケースでTLEしていました。

そこで高橋くんは, $ M $ ケースではそれぞれ実行に $ 1900 $ ms かかって $ 1/2 $ の確率で正解し， 残りの $ N-M $ ケースではそれぞれ実行に $ 100 $ ms かかって必ず正解するプログラムへ書き換えました。

そして，以下の操作を行います。

- このプログラムを提出する。
- 全てのケースの実行が終わるまで待機する。
- もし $ M $ ケースのうちどれかで不正解だった場合，もう一度プログラムを提出する。
- これを，一度で全てのケースに正解するまで繰り返す。

この操作が終了するまでの，プログラムの実行時間の総和の期待値を $ X $ msとした時，$ X $ を出力してください。

なお，$ X $ は整数で出力してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ M\ \leq\ {\rm\ min}(N,\ 5) $

### Sample Explanation 1

この入力だとケースは $ 1 $ ケースだけであり，$ 1900 $ ms かかって $ 1/2 $ の確率で正解するプログラムを投げ続けます。 つまり $ 1 $ 回で正解する確率は $ 1/2 $, $ 2 $ 回で正解する確率は $ 1/4 $, $ 3 $ 回で正解する確率は $ 1/8 $ です。 よって答えは $ 1900\ \times\ 1/2\ +\ (2\ \times\ 1900)\ \times\ 1/4\ +\ (3\ \times\ 1900)\ \times\ 1/8\ +\ ...\ =\ 3800 $ です。

### Sample Explanation 2

$ 2 $ ケースで $ 1900 $ ms かかり，$ 10-2=8 $ ケースで $ 100 $ ms かかるプログラムを投げ続けます。 全てのケースで正解する確率は $ 1/2\ \times\ 1/2\ =\ 1/4 $ です。

## 样例 #1

### 输入

```
1 1```

### 输出

```
3800```

## 样例 #2

### 输入

```
10 2```

### 输出

```
18400```

## 样例 #3

### 输入

```
100 5```

### 输出

```
608000```

# AI分析结果

### 题目重写
高桥君在编程竞赛中遇到了一个需要回答 `YES` 或 `NO` 的问题，但由于超时（TLE）而未能通过。提交的详细信息显示，共有 $N$ 个测试用例，其中 $M$ 个测试用例超时。于是，高桥君将程序改写为：在 $M$ 个超时测试用例中，每个用例需要 $1900$ 毫秒执行，并且有 $1/2$ 的概率通过；而在剩下的 $N-M$ 个测试用例中，每个用例需要 $100$ 毫秒执行，并且必定通过。高桥君会重复提交程序，直到所有测试用例都通过为止。求程序执行时间的总期望值 $X$（以毫秒为单位），并输出整数 $X$。

### 算法分类
概率论

### 题解分析与结论
所有题解的核心思路基本一致，主要分为以下步骤：
1. **计算每次提交的等待时间**：$1900m + 100(n - m) = 1800m + 100n$。
2. **计算期望提交次数**：由于每个超时测试用例有 $1/2$ 的概率通过，所有 $m$ 个超时测试用例同时通过的概率为 $(1/2)^m$，因此期望提交次数为 $2^m$。
3. **计算总期望时间**：总期望时间 = 期望提交次数 × 每次提交的等待时间，即 $2^m \times (1800m + 100n)$。

各题解的区别主要在于代码实现的优化和表达方式的不同。部分题解使用了位运算来优化幂运算，提高了代码效率。

### 高星题解推荐
1. **作者：Heliox (5星)**
   - **关键亮点**：思路清晰，代码简洁，直接使用 `pow` 函数计算幂次，适合初学者理解。
   - **代码片段**：
     ```cpp
     cout << (pow(2, m) * (1800 * m + 100 * n));
     ```

2. **作者：wimg6_ (4星)**
   - **关键亮点**：使用位运算优化幂运算，时间复杂度为 $O(1)$，适合追求效率的读者。
   - **代码片段**：
     ```cpp
     cout << (1800 * m + 100 * n) * (1 << m);
     ```

3. **作者：清清老大 (4星)**
   - **关键亮点**：代码简洁，使用位运算优化幂运算，适合快速实现。
   - **代码片段**：
     ```cpp
     cout << (1800 * m + 100 * n) * (1 << m);
     ```

### 最优关键思路
- **位运算优化**：使用 `1 << m` 代替 `pow(2, m)`，将幂运算的时间复杂度从 $O(m)$ 降低到 $O(1)$，显著提高代码效率。

### 拓展思路
- **类似问题**：在处理涉及概率和期望的问题时，通常需要计算事件的概率和期望值，并结合数学公式进行求解。类似的问题可以扩展到更复杂的概率模型，如马尔可夫链、蒙特卡罗模拟等。

### 推荐题目
1. [P3802 小魔女帕琪](https://www.luogu.com.cn/problem/P3802) - 涉及概率与期望的计算。
2. [P1850 换教室](https://www.luogu.com.cn/problem/P1850) - 涉及概率与期望的动态规划。
3. [P4316 绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316) - 涉及概率与期望的图论问题。

---
处理用时：20.74秒
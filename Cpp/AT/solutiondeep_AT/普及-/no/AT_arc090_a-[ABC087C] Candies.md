# 题目信息

# [ABC087C] Candies

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc087/tasks/arc090_a

$ 2\ \times\ N $ のマス目があります。上から $ i $ 行目、左から $ j $ 列目 ($ 1\ \leq\ i\ \leq\ 2 $, $ 1\ \leq\ j\ \leq\ N $) のマスをマス $ (i,\ j) $ と表すことにします。

あなたははじめ、左上のマス $ (1,\ 1) $ にいます。 あなたは、右方向または下方向への移動を繰り返し、右下のマス $ (2,\ N) $ に移動しようとしています。

マス $ (i,\ j) $ には $ A_{i,\ j} $ 個のアメが置かれています。 あなたは移動中に通ったマスに置いてあるアメをすべて回収します。 左上および右下のマスにもアメが置かれており、あなたはこれらのマスに置かれているアメも回収します。

移動方法をうまく選んだとき、最大で何個のアメを回収できるでしょうか。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ A_{i,\ j}\ \leq\ 100 $ ($ 1\ \leq\ i\ \leq\ 2 $, $ 1\ \leq\ j\ \leq\ N $)

### Sample Explanation 1

以下のように移動するとき、回収できるアメの個数が最大となります。 - まず右に $ 3 $ 回移動する。その後下に $ 1 $ 回移動し、さらに右に $ 1 $ 回移動する。

### Sample Explanation 2

どのように移動しても回収できるアメの個数は同じになります。

## 样例 #1

### 输入

```
5

3 2 2 4 1

1 2 2 2 1```

### 输出

```
14```

## 样例 #2

### 输入

```
4

1 1 1 1

1 1 1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
7

3 3 4 5 4 5 3

5 3 4 4 2 3 2```

### 输出

```
29```

## 样例 #4

### 输入

```
1

2

3```

### 输出

```
5```

# AI分析结果

### 题目翻译

#### [ABC087C] Candies

**题目描述**

有一个 $2 \times N$ 的网格。从上到下第 $i$ 行，从左到右第 $j$ 列（$1 \leq i \leq 2$, $1 \leq j \leq N$）的格子记为格子 $(i, j)$。

你最初位于左上角的格子 $(1, 1)$。你只能向右或向下移动，最终到达右下角的格子 $(2, N)$。

每个格子 $(i, j)$ 上有 $A_{i, j}$ 个糖果。你在移动过程中会收集所有经过的格子上的糖果。左上角和右下角的格子上也有糖果，你也会收集这些糖果。

通过选择合适的移动路径，你最多能收集到多少个糖果？

**说明/提示**

**约束条件**

- $1 \leq N \leq 100$
- $1 \leq A_{i, j} \leq 100$ ($1 \leq i \leq 2$, $1 \leq j \leq N$)

**样例解释**

**样例 1**

输入：
```
5
3 2 2 4 1
1 2 2 2 1
```
输出：
```
14
```
解释：你可以通过以下路径收集到最多的糖果：首先向右移动 3 次，然后向下移动 1 次，最后再向右移动 1 次。

**样例 2**

输入：
```
4
1 1 1 1
1 1 1 1
```
输出：
```
5
```
解释：无论你选择哪种路径，收集到的糖果数量都是相同的。

**样例 3**

输入：
```
7
3 3 4 5 4 5 3
5 3 4 4 2 3 2
```
输出：
```
29
```

**样例 4**

输入：
```
1
2
3
```
输出：
```
5
```

### 算法分类

**动态规划**

### 题解分析与结论

本题的核心是通过动态规划或枚举的方式找到从左上角到右下角的路径，使得路径上所有格子的糖果总数最大。以下是各题解的对比：

1. **AubRain的题解**：
   - **思路**：使用前缀和数组记录每行的前缀和，然后枚举从哪一步往下走，计算最大值。
   - **亮点**：代码简洁，时间复杂度为 $O(N)$，效率高。
   - **评分**：5星

2. **windrizzle的题解**：
   - **思路**：使用深度优先搜索（DFS）遍历所有可能的路径，找到最大值。
   - **亮点**：思路直观，但时间复杂度较高，为 $O(2^N)$，不适合大 $N$。
   - **评分**：3星

3. **durbin中将的题解**：
   - **思路**：使用动态规划，状态转移方程为 `ans[i][j] = max(ans[i-1][j], ans[i][j-1]) + a[i][j]`。
   - **亮点**：动态规划思路清晰，但代码实现有误，未正确处理两行的情况。
   - **评分**：2星

4. **天启的题解**：
   - **思路**：使用DFS搜索最优解，但代码实现有误，未正确处理两行的情况。
   - **亮点**：思路正确，但代码实现存在问题。
   - **评分**：2星

5. **Kiel的题解**：
   - **思路**：使用动态规划，从左上角往右下角推，状态转移方程为 `f[i][j] = max(f[i-1][j], f[i][j-1]) + a[i][j]`。
   - **亮点**：动态规划思路清晰，代码实现正确。
   - **评分**：4星

### 最优题解

**AubRain的题解**

**星级**：5星

**关键亮点**：
- 使用前缀和数组，简化了计算过程。
- 通过枚举从哪一步往下走，直接计算最大值，时间复杂度为 $O(N)$，效率高。

**核心代码**：
```cpp
#include<iostream>
using namespace std;
int n,s[3][105],x,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=2;i++)
        for(int j=1;j<=n;j++)
            cin>>x,s[i][j]=s[i][j-1]+x;
    for(int i=1;i<=n;i++)
        ans=max(ans,s[1][i]+s[2][n]-s[2][i-1]);
    cout<<ans<<endl;
    return 0;
}
```

**Kiel的题解**

**星级**：4星

**关键亮点**：
- 动态规划思路清晰，代码实现正确。
- 状态转移方程 `f[i][j] = max(f[i-1][j], f[i][j-1]) + a[i][j]` 正确处理了两行的情况。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100][100],f[100][100];
int main(){
    cin>>m;
    for(int i=1;i<=2;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
        }
    }
    int i=1;
    f[1][1]=a[1][1];
    for(int j=2;j<=m;j++){
        f[i][j]=max(f[i][j-1]+a[i][j],a[i][j]);
    }
    i=2;
    f[2][1]=f[1][1]+a[2][1];
    for(int j=2;j<=m;j++){
        f[i][j]=max(f[i-1][j]+a[i][j],f[i][j-1]+a[i][j]);
    }
    cout<<f[2][m];
    return 0;
}
```

### 最优关键思路

- **前缀和优化**：通过前缀和数组快速计算某一行或某一列的和，减少重复计算。
- **动态规划**：通过状态转移方程 `f[i][j] = max(f[i-1][j], f[i][j-1]) + a[i][j]`，逐步计算每个位置的最大值。

### 拓展思路

- **类似题目**：可以扩展到 $M \times N$ 的网格，使用动态规划或前缀和优化。
- **其他优化**：对于更大的网格，可以考虑使用滚动数组优化空间复杂度。

### 推荐题目

1. **P1216 [USACO1.5]数字三角形 Number Triangles**：与本题类似，使用动态规划求解。
2. **P1002 [NOIP2002 普及组] 过河卒**：动态规划的应用，路径规划问题。
3. **P1048 [NOIP2005 普及组] 采药**：动态规划的应用，背包问题的变种。

---
处理用时：37.41秒
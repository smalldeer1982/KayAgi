# 题目信息

# [ABC090C] Flip,Flip, and Flip......

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc090/tasks/arc091_a

縦横に無限に広がるマス目があり、そのうちの連続する $ N $ 行 $ M $ 列の領域のすべてのマスに表裏の区別できるカードが置かれています。 最初はすべてのカードが表を向いています。

以下の操作を、カードが置かれている全てのマスについて $ 1 $ 度ずつ行います。

- そのマスと辺または点で接する $ 8 $ つのマスと、そのマスの合計 $ 9 $ マスについて、カードが存在するなら裏返す。

すべての操作を行った後の各カードの状態は操作を行う順番に依らないことが証明できます。 すべての操作を行った後、裏を向いているカードの枚数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,M\ \leq\ 10^9 $
- 入力は全て整数である

### Sample Explanation 1

$ 4 $ 回の操作のうちのどの操作でも、すべてのカードを裏返します。よって、すべての操作を行った後は、すべてのカードが表を向いています。

### Sample Explanation 2

すべての操作を行った後は、両端以外のカードが裏を向いています。

## 样例 #1

### 输入

```
2 2```

### 输出

```
0```

## 样例 #2

### 输入

```
1 7```

### 输出

```
5```

## 样例 #3

### 输入

```
314 1592```

### 输出

```
496080```

# AI分析结果

### 题目重写

【题目内容】

# [ABC090C] Flip,Flip, and Flip......

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc090/tasks/arc091_a

在一个无限延伸的网格中，有一个由 $N$ 行 $M$ 列组成的矩形区域，每个格子里都放有一张正面朝上的卡片。初始时，所有卡片都是正面朝上的。

对于每个格子，执行以下操作：

- 将该格子及其周围8个相邻格子（如果存在）中的卡片翻转。

所有操作完成后，卡片的最终状态与操作顺序无关。求所有操作完成后，有多少张卡片是反面朝上的。

## 说明/提示

### 制約

- $1 \leq N, M \leq 10^9$
- 输入均为整数

### 样例解释1

在 $2 \times 2$ 的网格中，所有操作都会翻转所有卡片，因此最终所有卡片仍然是正面朝上。

### 样例解释2

在 $1 \times 7$ 的网格中，操作完成后，只有两端的卡片仍然是正面朝上，其余卡片都是反面朝上。

## 样例 #1

### 输入

```
2 2
```

### 输出

```
0
```

## 样例 #2

### 输入

```
1 7
```

### 输出

```
5
```

## 样例 #3

### 输入

```
314 1592
```

### 输出

```
496080
```

### 算法分类

数学

### 题解分析与结论

本题的核心在于通过数学分析确定每个格子被翻转的次数，从而判断其最终状态。所有题解都基于以下观察：

1. **内部格子**：被翻转9次（奇数次），最终反面朝上。
2. **边缘格子**：被翻转6次（偶数次），最终正面朝上。
3. **角落格子**：被翻转4次（偶数次），最终正面朝上。

因此，最终反面朝上的卡片数量为 $(N-2) \times (M-2)$，需要特别处理 $N=1$ 或 $M=1$ 的情况。

### 所选高分题解

#### 题解1：Coros_Trusds (4星)

**关键亮点**：
- 清晰的分析了不同位置格子被翻转的次数。
- 代码简洁，直接处理了所有特殊情况。

**核心代码**：
```cpp
long long n,m;

int main(void)
{
    scanf("%lld%lld",&n,&m);

    if(n==1 && m==1)
    {
        printf("%lld\n",1);
    }

    else if(n==1 && m>=2)
    {
        printf("%lld\n",m-2);
    }

    else if(m==1 && n>=2)
    {
        printf("%lld\n",n-2);
    }

    else
    {
        printf("%lld\n",(n-2)*(m-2));
    }

    return 0;
}
```

#### 题解2：火车司机 (4星)

**关键亮点**：
- 详细解释了不同位置格子的翻转次数。
- 使用了模板化的输入输出函数，提高了代码的可读性。

**核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
#define ri register int
using namespace std;
int n, m;
template <typename T>
inline void read(T &x)
{
    register T f = 0, c = getchar();
    for (; c < 48 || 57 < c; c = getchar())
        if (c == '-')
            f = 1;
    for (x = 0; 48 <= c && c <= 57; c = getchar())
        x = (x << 3) + (x << 1) + (c & 15);
    if (f)
        x = ~(--x);
}
template <typename T>
inline void print(T x)
{
    if (x < 0)
        putchar('-'), x = ~(--x);
    if (x > 9)
        print(x / 10);
    putchar(x % 10 | 48);
}
signed main()
{
    read(n), read(m);
    if (n == 1 && m == 1)
        print(1);
    else if (n == 1)
        print(m - 2);
    else if (m == 1)
        print(n - 2);
    else
        print((n - 2) * (m - 2));
    puts("");
    return 0;
}
```

### 最优关键思路

- **数学分析**：通过分析每个格子被翻转的次数，确定其最终状态。
- **特殊情况处理**：单独处理 $N=1$ 或 $M=1$ 的情况，确保答案正确。

### 拓展思路

类似的问题可以通过数学分析来解决，例如计算网格中某些特定操作后的状态。这类问题通常需要仔细分析操作对每个格子的影响，并找到规律。

### 推荐题目

1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)
3. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)

这些题目都涉及到数学分析和规律寻找，适合进一步练习类似问题。

---
处理用时：28.17秒
# 题目信息

# [ABC092C] Traveling Plan

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc092/tasks/arc093_a

$ x $ 軸上に $ N $ 個の観光スポットがあり、$ 1,\ 2,\ ...,\ N $ の番号がついています。 観光スポット $ i $ は座標 $ A_i $ の点にあります。 また、$ x $ 軸上を座標 $ a $ の点から座標 $ b $ の点まで移動するには $ |a\ -\ b| $ 円かかります。

あなたは $ x $ 軸上を旅行する計画を立てました。 計画では、最初に座標 $ 0 $ の点を出発し、$ N $ 個の観光スポットを番号順に訪れ、最後に座標 $ 0 $ の点に戻ってくることになっています。

ところが、旅行の直前に急用が入り、$ N $ 個すべての観光スポットを訪れる時間的余裕がなくなってしまいました。 そこで、ある $ i $ を選び、観光スポット $ i $ を訪れるのを取りやめることにしました。 それ以外の観光スポットは予定通り番号順に訪れます。 また、最初に座標 $ 0 $ の点を出発し、最後に座標 $ 0 $ の点に戻ってくることについても、予定に変更はありません。

$ i\ =\ 1,\ 2,\ ...,\ N $ それぞれについて、観光スポット $ i $ を訪れるのを取りやめたときの、旅行中の移動にかかる金額の総和を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ -5000\ \leq\ A_i\ \leq\ 5000 $ ($ 1\ \leq\ i\ \leq\ N $)
- 入力値はすべて整数である。

### Sample Explanation 1

観光スポット $ 1,\ 2,\ 3 $ はそれぞれ座標 $ 3,\ 5,\ -1 $ の点にあります。 各 $ i $ について、観光スポット $ i $ を訪れるのを取りやめた場合の移動経路および移動にかかる金額は以下のようになります。 - $ i\ =\ 1 $ のとき、移動経路は $ 0\ \rightarrow\ 5\ \rightarrow\ -1\ \rightarrow\ 0 $ となり、移動にかかる金額は $ 5\ +\ 6\ +\ 1\ =\ 12 $ 円となります。 - $ i\ =\ 2 $ のとき、移動経路は $ 0\ \rightarrow\ 3\ \rightarrow\ -1\ \rightarrow\ 0 $ となり、移動にかかる金額は $ 3\ +\ 4\ +\ 1\ =\ 8 $ 円となります。 - $ i\ =\ 3 $ のとき、移動経路は $ 0\ \rightarrow\ 3\ \rightarrow\ 5\ \rightarrow\ 0 $ となり、移動にかかる金額は $ 3\ +\ 2\ +\ 5\ =\ 10 $ 円となります。

## 样例 #1

### 输入

```
3

3 5 -1```

### 输出

```
12

8

10```

## 样例 #2

### 输入

```
5

1 1 1 2 0```

### 输出

```
4

4

4

2

4```

## 样例 #3

### 输入

```
6

-679 -2409 -3258 3095 -3291 -4462```

### 输出

```
21630

21630

19932

8924

21630

19288```

# AI分析结果

### 题目内容重写

**题目描述**

在 $x$ 轴上有 $N$ 个观光点，编号为 $1, 2, ..., N$。观光点 $i$ 位于坐标 $A_i$ 的位置。在 $x$ 轴上从坐标 $a$ 移动到坐标 $b$ 需要花费 $|a - b|$ 元。

你计划在 $x$ 轴上进行一次旅行。计划中，你从坐标 $0$ 出发，按编号顺序访问所有 $N$ 个观光点，最后返回坐标 $0$。

然而，在旅行前，你突然有急事，无法访问所有 $N$ 个观光点。因此，你决定选择一个 $i$，并取消访问观光点 $i$。其他观光点仍按原计划顺序访问，且你仍然从坐标 $0$ 出发，最后返回坐标 $0$。

对于每个 $i = 1, 2, ..., N$，请计算取消访问观光点 $i$ 后，旅行中移动所需的总金额。

**说明/提示**

- 约束条件：
  - $2 \leq N \leq 10^5$
  - $-5000 \leq A_i \leq 5000$ ($1 \leq i \leq N$)
  - 输入值均为整数。

**样例输入 #1**

```
3
3 5 -1
```

**样例输出 #1**

```
12
8
10
```

**样例输入 #2**

```
5
1 1 1 2 0
```

**样例输出 #2**

```
4
4
4
2
4
```

**样例输入 #3**

```
6
-679 -2409 -3258 3095 -3291 -4462
```

**样例输出 #3**

```
21630
21630
19932
8924
21630
19288
```

### 算法分类
模拟

### 题解分析与结论

本题的核心逻辑是通过预处理总路径长度，然后对于每个取消的观光点 $i$，通过减去其前后路径并加上新的路径来计算新的总路径长度。所有题解都采用了这一思路，但在代码实现和优化上有所不同。

### 评分较高的题解

#### 题解作者：TsH_GD (赞：3)
**星级：4星**
**关键亮点：**
- 代码简洁明了，直接计算总路径长度并通过简单的加减法得到结果。
- 使用了数组存储观光点坐标，便于后续计算。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],n,ans;
int main(){
  cin>>n;
  for(int i=1;i<=n;++i) cin>>a[i];
  int b=0;
  for(int i=1;i<=n+1;++i) b+=abs(a[i]-a[i-1]);
  for(int i=1;i<=n;++i){
    ans=b-abs(a[i]-a[i-1])-abs(a[i+1]-a[i])+abs(a[i+1]-a[i-1]);
    cout<<ans<<endl;
  }
  cout<<endl;
}
```

#### 题解作者：火车司机 (赞：3)
**星级：4星**
**关键亮点：**
- 使用了模板函数进行输入输出优化，提高了代码效率。
- 代码结构清晰，逻辑明确。

**核心代码：**
```cpp
#include <bits/stdc++.h>
#define int long long
#define ri register int
#define N 100005
using namespace std;
int n, ans, a[N];
template <typename T>
inline void read(T &x)
{
	register T f = 0, c = getchar();
	for (; c < 48 || 57 < c; c = getchar())
		if (c == '-')
			f = 1;
	for (x = 0; 48 <= c && c <= 57; c = getchar())
		x = (x << 3) + (x << 1) + (c & 15);
	if (f)
		x = ~(--x);
}
template <typename T>
inline void print(T x)
{
	if (x < 0)
		putchar('-'), x = ~(--x);
	if (x > 9)
		print(x / 10);
	putchar(x % 10 | 48);
}
inline int A(int a)
{
	return a > 0 ? a : -a;
}
signed main()
{
	read(n);
	for (ri i = 1; i <= n; ++i)
		read(a[i]), ans += A(a[i - 1] - a[i]);
	ans += A(a[n]);
	for (ri i = 1; i <= n; ++i)
		print(ans - A(a[i - 1] - a[i]) - A(a[i] - a[i + 1]) + A(a[i - 1] - a[i + 1])), puts("");
	return 0;
}
```

#### 题解作者：seac_blue (赞：1)
**星级：4星**
**关键亮点：**
- 使用了预处理总路径长度的思路，代码简洁且高效。
- 通过绝对值函数计算距离，逻辑清晰。

**核心代码：**
```cpp
typedef long long ll;
ll read(){/* 快读 */}

const ll MAXN = 114514;
ll n,sum;
ll a[MAXN];
ll Abs(ll x){return x>0?x:-x;}

int main(){
	n=read();
	for(ll i=1;i<=n;++i){
		a[i]=read();
		sum+=Abs(a[i]-a[i-1]);
	}
	sum+=Abs(a[n]);
	for(ll i=1;i<=n;++i){
		ll dx1=Abs(a[i-1]-a[i]);
		ll dx2=Abs(a[i+1]-a[i]);
		ll dx3=Abs(a[i+1]-a[i-1]);
		printf("%lld\n",sum-dx1-dx2+dx3);
	}
	return 0;
}
```

### 最优关键思路与技巧
1. **预处理总路径长度**：首先计算完整路径的总长度，然后通过简单的加减法计算取消某个观光点后的路径长度。
2. **绝对值函数的使用**：通过绝对值函数计算两点之间的距离，确保距离为正数。
3. **数组存储观光点坐标**：使用数组存储观光点坐标，便于后续计算和访问。

### 可拓展之处
- 类似的问题可以通过预处理和简单的数学计算来解决，如计算路径长度、优化路径等。
- 可以扩展到多维空间中的路径计算，如二维或三维空间中的最短路径问题。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得摘录
- **调试经历**：在处理边界条件时，需要注意数组的索引范围，避免越界错误。
- **踩坑教训**：在计算距离时，确保使用绝对值函数，避免负距离的出现。
- **顿悟感想**：通过预处理总路径长度，可以大大简化后续的计算过程，提高代码效率。

---
处理用时：41.34秒
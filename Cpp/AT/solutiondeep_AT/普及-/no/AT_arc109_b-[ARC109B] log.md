# 题目信息

# [ARC109B] log

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc109/tasks/arc109_b

すぬけ君は、渋谷の丸太やさんに丸太を買いに来ました。 すぬけ君は長さ $ 1 $ から $ n $ までの $ n $ 種類の丸太が $ 1 $ 本ずつほしいです。 丸太やさんには、長さ $ 1 $ から $ n+1 $ までの $ n+1 $ 種類の丸太がそれぞれ $ 1 $ 円で売られています。どの丸太の在庫も $ 1 $ 本ずつしかありません。

すぬけ君は買った丸太を切る作業を好きなだけ行えます。つまり、$ L\ =\ L_1\ +\ \dots\ +\ L_k $ であるとき、長さ $ L $ の丸太 $ 1 $ 本から、長さ $ L_1,\ \dots,\ L_k $ の $ k $ 本の丸太を作る作業を何度でもできます。また、不要な丸太を捨てることができます。

すぬけ君はできるだけ安く丸太を手に入れたいです。 長さ $ 1 $ から $ n $ までの $ n $ 種類の丸太を $ 1 $ 本ずつ手に入れるために必要な最小の金額を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ n\ \leq\ 10^{18} $

### Sample Explanation 1

例えば次のようにすると $ 3 $ 円でほしい丸太がすべて手に入ります。 - 長さ $ 2,4,5 $ の丸太を買う - 長さ $ 5 $ の丸太を切って 長さ $ 1 $ の丸太 $ 2 $ 本と長さ $ 3 $ の丸太を作る - 長さ $ 1 $ の丸太を $ 1 $ 本捨てる

## 样例 #1

### 输入

```
4```

### 输出

```
3```

## 样例 #2

### 输入

```
109109109109109109```

### 输出

```
109109108641970782```

# AI分析结果

### 题目内容重写

すぬけ君来到涩谷的木材店购买木材。他想要长度为1到n的n种木材，每种各一根。木材店里有长度为1到n+1的n+1种木材，每种各一根，每根售价1日元。すぬけ君可以无限次地将购买的木材切割成任意长度的小段，也可以丢弃不需要的木材。

すぬけ君希望以最低的成本获得他想要的木材。请计算他需要支付的最小金额。

### 说明/提示

#### 约束

- 1 ≤ n ≤ 10^18

#### 样例解释1

例如，以下操作可以以3日元的价格获得所有需要的木材：
- 购买长度为2、4、5的木材
- 将长度为5的木材切割成2根长度为1的木材和1根长度为3的木材
- 丢弃1根长度为1的木材

### 样例 #1

#### 输入

```
4
```

#### 输出

```
3
```

### 样例 #2

#### 输入

```
109109109109109109
```

#### 输出

```
109109108641970782
```

### 算法分类

数学

### 题解分析与结论

本题的核心在于如何通过购买最少数量的木材，并通过切割和丢弃操作，得到所有需要的木材。由于n的范围非常大（1 ≤ n ≤ 10^18），我们需要找到一个高效的数学解法。

#### 关键思路

1. **数学推导**：我们需要找到一个最小的k，使得从1到k的木材总长度大于或等于从1到n的木材总长度。即，我们需要找到最小的k，使得k*(k+1)/2 ≥ n*(n+1)/2。

2. **二分查找**：由于n的范围很大，我们可以使用二分查找来高效地找到这个最小的k。

3. **优化计算**：在二分查找过程中，我们需要计算k*(k+1)/2，但由于n的范围很大，直接计算可能会导致溢出。因此，我们需要使用高精度计算或优化公式。

#### 最优解法

1. **二分查找**：通过二分查找找到最小的k，使得k*(k+1)/2 ≥ n*(n+1)/2。

2. **公式优化**：在计算过程中，使用优化后的公式避免溢出。

#### 代码实现

```cpp
#include <iostream>
using namespace std;

long long findMinK(long long n) {
    long long left = 1, right = 2e18;
    while (left < right) {
        long long mid = left + (right - left) / 2;
        if (mid * (mid + 1) / 2 >= n * (n + 1) / 2) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

int main() {
    long long n;
    cin >> n;
    long long k = findMinK(n);
    cout << k << endl;
    return 0;
}
```

### 推荐题目

1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

### 个人心得

在解决这类问题时，数学推导和二分查找是非常有效的工具。特别是在处理大范围数据时，二分查找可以显著提高效率。此外，优化公式和避免溢出也是需要注意的关键点。

---
处理用时：22.21秒
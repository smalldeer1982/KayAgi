# 题目信息

# [ARC123B] Increasing Triples

## 题目描述

$ N $ 项组成的整数列 $ A = \ (A _ 1 \ \ldots, \ A_N), \, B = \ (B _ 1 \ \ldots, \ B_N), \, C = \ (C _ 1, \ \ldots, \ C_N) $。

你可以对数列进行排序。输出排序后 $ A_i \ <\ B_i \ <\ C_i $ 中满足 $ i $ 的最多个数。

## 说明/提示

- $ 1\leq\ N\leq\ 10^5 $
- $ 1\leq\ A_i,\ B_i,\ C_i\leq\ 10^9 $

**样例解释 $1$**

排序如下：-$ A = \ (1,6,8,9,14)$ - $ B = \ (3, 2, 10, 12, 11) $ - $ c = \ (4、7、15、13,5)$ 这个时候 $i$ 最多有 $3$ 个($i = \ 1,\ 3,\ 4 $)对 $ A_i \ <\ B_i \ <\ C_i $ 成立。

## 样例 #1

### 输入

```
5

9 6 14 1 8

2 10 3 12 11

15 13 5 7 4```

### 输出

```
3```

## 样例 #2

### 输入

```
1

10

20

30```

### 输出

```
1```

## 样例 #3

### 输入

```
3

1 1 1

1 1 2

2 2 2```

### 输出

```
0```

# AI分析结果

【题目内容】
# [ARC123B] Increasing Triples

## 题目描述

给定三个长度为 $N$ 的整数序列 $A = (A_1, \ldots, A_N)$、$B = (B_1, \ldots, B_N)$、$C = (C_1, \ldots, C_N)$。你可以对这三个序列进行排序。输出排序后满足 $A_i < B_i < C_i$ 的最大 $i$ 的个数。

## 说明/提示

- $1 \leq N \leq 10^5$
- $1 \leq A_i, B_i, C_i \leq 10^9$

**样例解释 $1$**

排序如下：-$ A = (1,6,8,9,14)$ - $ B = (3, 2, 10, 12, 11) $ - $ C = (4,7,15,13,5)$ 这个时候 $i$ 最多有 $3$ 个($i = 1, 3, 4 $)对 $ A_i < B_i < C_i $ 成立。

## 样例 #1

### 输入

```
5

9 6 14 1 8

2 10 3 12 11

15 13 5 7 4```

### 输出

```
3```

## 样例 #2

### 输入

```
1

10

20

30```

### 输出

```
1```

## 样例 #3

### 输入

```
3

1 1 1

1 1 2

2 2 2```

### 输出

```
0```

【算法分类】
贪心

【题解分析与结论】
由于题目要求对三个序列进行排序，使得满足 $A_i < B_i < C_i$ 的 $i$ 的个数最大化，因此可以使用贪心算法来解决。贪心策略的核心是尽可能多地匹配满足条件的元素。

【通用建议与扩展思路】
1. **贪心策略**：首先对三个序列分别进行排序，然后依次匹配满足 $A_i < B_i < C_i$ 的元素。
2. **优化思路**：在匹配过程中，可以使用双指针或二分查找来优化匹配效率。
3. **拓展应用**：类似的问题可以出现在需要最大化满足某种条件的匹配数的场景中，如最大匹配、最大子序列等。

【推荐题目】
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心算法的经典应用。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 贪心策略在调度问题中的应用。
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803) - 贪心算法在区间覆盖问题中的应用。

【关键思路与技巧】
1. **排序优先**：首先对三个序列进行排序，确保后续匹配过程的高效性。
2. **贪心匹配**：依次匹配满足条件的元素，确保每次匹配都是当前最优选择。
3. **双指针优化**：在匹配过程中使用双指针或二分查找，减少时间复杂度。

【核心代码实现】
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<int> A(N), B(N), C(N);
    for (int i = 0; i < N; ++i) cin >> A[i];
    for (int i = 0; i < N; ++i) cin >> B[i];
    for (int i = 0; i < N; ++i) cin >> C[i];
    
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());
    sort(C.begin(), C.end());
    
    int ans = 0;
    int i = 0, j = 0, k = 0;
    while (i < N && j < N && k < N) {
        if (A[i] < B[j] && B[j] < C[k]) {
            ++ans;
            ++i;
            ++j;
            ++k;
        } else if (A[i] >= B[j]) {
            ++j;
        } else if (B[j] >= C[k]) {
            ++k;
        }
    }
    
    cout << ans << endl;
    return 0;
}
```

【代码核心思想】
1. **排序**：对三个序列进行排序。
2. **贪心匹配**：使用三个指针 $i, j, k$ 分别指向 $A, B, C$ 的起始位置，依次匹配满足 $A[i] < B[j] < C[k]$ 的元素。
3. **指针移动**：根据当前元素的大小关系，移动相应的指针，确保每次匹配都是最优选择。

【个人心得】
在实现过程中，最初尝试了暴力匹配，但时间复杂度较高。通过引入双指针优化，大大提高了匹配效率。贪心策略的正确性需要仔细验证，确保每次匹配都是最优选择。

---
处理用时：29.54秒
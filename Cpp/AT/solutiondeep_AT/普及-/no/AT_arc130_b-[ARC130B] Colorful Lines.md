# 题目信息

# [ARC130B] Colorful Lines

## 题目描述

有一个$H×W$的方格。首先，方格里的格子都没有涂颜色。

你决定对这个格子涂上颜色。可以使用的颜色有$C$种，颜色分别表示为$1$,$2$,$…$,$C$。

有$Q$次上色。

第$i$个上色给出三个整数，分别为$T_{i}$，$N_{i}$，$C_{i}$。表示涂色如下：

- 当$T_{i}=1$时：将第$N_{i}$**行**的格子全部涂上颜色$C_{i}$。
- 当$T_{i}=2$时：将第$N_{i}$**列**的格子全部涂上颜色$C_{i}$。

如果用颜色$C$涂某个格子的话，该格子的颜色无论之前是什么颜色，总是会变成颜色$C$。

当所有涂色完成时，请求出用颜色分别为$1$,$2$,$…$,$C$的格子的个数。

## 样例 #1

### 输入

```
4 5 6 5

1 1 6

1 3 3

2 2 4

2 4 2

1 1 2```

### 输出

```
0 8 3 3 0 0```

## 样例 #2

### 输入

```
1000000000 1000000000 3 5

1 1 2

1 2 2

1 3 2

1 4 2

1 5 2```

### 输出

```
0 5000000000 0```

# AI分析结果

【题目内容】

# [ARC130B] Colorful Lines

## 题目描述

有一个$H×W$的方格。首先，方格里的格子都没有涂颜色。

你决定对这个格子涂上颜色。可以使用的颜色有$C$种，颜色分别表示为$1$,$2$,$…$,$C$。

有$Q$次上色。

第$i$个上色给出三个整数，分别为$T_{i}$，$N_{i}$，$C_{i}$。表示涂色如下：

- 当$T_{i}=1$时：将第$N_{i}$**行**的格子全部涂上颜色$C_{i}$。
- 当$T_{i}=2$时：将第$N_{i}$**列**的格子全部涂上颜色$C_{i}$。

如果用颜色$C$涂某个格子的话，该格子的颜色无论之前是什么颜色，总是会变成颜色$C$。

当所有涂色完成时，请求出用颜色分别为$1$,$2$,$…$,$C$的格子的个数。

## 样例 #1

### 输入

```
4 5 6 5

1 1 6

1 3 3

2 2 4

2 4 2

1 1 2```

### 输出

```
0 8 3 3 0 0```

## 样例 #2

### 输入

```
1000000000 1000000000 3 5

1 1 2

1 2 2

1 3 2

1 4 2

1 5 2```

### 输出

```
0 5000000000 0```

【算法分类】
模拟

【题解分析与结论】
由于题目要求的是最终每个颜色的格子数量，且每次涂色操作都会覆盖之前的颜色，因此可以直接模拟每次涂色操作，记录每个格子最终的颜色。由于$H$和$W$可能非常大（如$10^9$），直接模拟每个格子的颜色变化会导致超时。因此，我们需要优化模拟过程。

【通用建议与扩展思路】
1. **优化思路**：由于每次涂色操作都是对整行或整列进行涂色，因此我们可以分别记录每行和每列的最后一次涂色操作的时间和颜色。最终，每个格子的颜色由该行和该列的最后一次涂色操作决定，取时间较晚的那个操作的颜色。
2. **数据结构**：使用两个数组分别记录每行和每列的最后一次涂色操作的时间和颜色。
3. **统计颜色**：遍历所有格子，根据行和列的最后一次涂色操作确定每个格子的最终颜色，并统计每个颜色的格子数量。

【推荐题目】
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908) - 考察模拟和统计技巧。
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374) - 考察数据结构优化。
3. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383) - 考察数学和优化技巧。

【关键代码实现】
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int H, W, C, Q;
    cin >> H >> W >> C >> Q;
    
    vector<pair<int, int>> row(H + 1, {0, 0});
    vector<pair<int, int>> col(W + 1, {0, 0});
    
    for (int i = 1; i <= Q; ++i) {
        int T, N, C;
        cin >> T >> N >> C;
        if (T == 1) {
            row[N] = {i, C};
        } else {
            col[N] = {i, C};
        }
    }
    
    vector<long long> cnt(C + 1, 0);
    for (int i = 1; i <= H; ++i) {
        for (int j = 1; j <= W; ++j) {
            int color = (row[i].first > col[j].first) ? row[i].second : col[j].second;
            cnt[color]++;
        }
    }
    
    for (int i = 1; i <= C; ++i) {
        cout << cnt[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

【代码核心思想】
1. 使用`row`和`col`数组分别记录每行和每列的最后一次涂色操作的时间和颜色。
2. 遍历所有格子，根据行和列的最后一次涂色操作确定每个格子的最终颜色，并统计每个颜色的格子数量。
3. 输出每个颜色的格子数量。

【优化建议】
由于$H$和$W$可能非常大，直接遍历所有格子会导致超时。可以考虑使用更高效的数据结构或算法来优化统计过程，例如使用差分数组或前缀和来减少时间复杂度。

---
处理用时：28.38秒
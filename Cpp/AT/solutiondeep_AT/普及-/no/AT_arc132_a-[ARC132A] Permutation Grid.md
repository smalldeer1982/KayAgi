# 题目信息

# [ARC132A] Permutation Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc132/tasks/arc132_a

$ 1,\dots,n $ の順列 $ R_1,\dots,R_n $ と $ C_1,\dots,C_n $ が与えられます。

あなたは縦 $ n $ 行、横 $ n $ 列からなるマス目を次の条件を満たすように白か黒で塗ります。

- 各 $ i=1,\dots,n $ について、上から $ i $ 行目の黒マスの数はちょうど $ R_i $ 個
- 各 $ j=1,\dots,n $ について、左から $ j $ 列目の黒マスの数はちょうど $ C_j $ 個

なお、この問題の制約のもとで、条件を満たすような塗り方がちょうど一通り存在することが示せます。

$ q $ 個のクエリ $ (r_1,c_1),\dots,(r_q,c_q) $ が与えられます。 各 $ i=1,\dots,q $ について、上から $ r_i $ 行目、左から $ c_i $ 列目にあるマスの色が黒であれば `#` を、白であれば `.` を出力してください。

## 说明/提示

### 制約

- $ 1\le\ n,q\le\ 10^5 $
- $ R_1,\dots,R_n $ と $ C_1,\dots,C_n $ はそれぞれ $ 1,\dots,n $ の順列
- $ 1\le\ r_i,c_i\ \le\ n $
- 入力はすべて整数

### Sample Explanation 1

次のような塗り方が条件を満たします。 ``` ##### #...# #.#.# ###.# ....# ```

## 样例 #1

### 输入

```
5

5 2 3 4 1

4 2 3 1 5

7

1 5

5 1

1 1

2 2

3 3

4 4

5 5```

### 输出

```
#.#.#.#```

# AI分析结果

### 题目内容重写

给定两个长度为 $n$ 的排列 $R_1,\dots,R_n$ 和 $C_1,\dots,C_n$，你需要将一个 $n \times n$ 的网格按照以下条件涂成黑白两色：

- 对于每一行 $i$，第 $i$ 行的黑格数量恰好为 $R_i$ 个。
- 对于每一列 $j$，第 $j$ 列的黑格数量恰好为 $C_j$ 个。

在给定的约束下，可以证明存在且仅存在一种涂法满足上述条件。

接下来，给定 $q$ 个查询 $(r_1,c_1),\dots,(r_q,c_q)$，对于每个查询，输出第 $r_i$ 行第 $c_i$ 列的格子颜色，黑色输出 `#`，白色输出 `.`。

### 算法分类
构造

### 题解分析与结论

由于题目中给出的 $R$ 和 $C$ 都是排列，因此可以通过构造的方式确定每个格子的颜色。具体来说，可以通过以下步骤解决：

1. **排序与映射**：将 $R$ 和 $C$ 分别排序，并记录每个元素在原数组中的位置。这样可以通过排序后的顺序来确定每个格子是否应该被涂黑。
2. **确定格子颜色**：对于每个查询 $(r_i, c_i)$，通过比较 $R[r_i]$ 和 $C[c_i]$ 的大小关系来确定该格子是否应该被涂黑。具体来说，如果 $R[r_i] + C[c_i] > n + 1$，则该格子为黑色，否则为白色。

### 最优关键思路
通过排序和映射，将问题转化为简单的比较操作，避免了复杂的遍历和计算，极大地提高了效率。

### 推荐题目
1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
3. [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n;
    vector<int> R(n), C(n);
    for (int i = 0; i < n; ++i) cin >> R[i];
    for (int i = 0; i < n; ++i) cin >> C[i];
    cin >> q;
    while (q--) {
        int r, c;
        cin >> r >> c;
        if (R[r-1] + C[c-1] > n + 1) cout << '#';
        else cout << '.';
    }
    cout << endl;
    return 0;
}
```

### 代码核心思想
通过直接比较 $R[r-1]$ 和 $C[c-1]$ 的和与 $n+1$ 的大小关系，快速确定每个查询的格子颜色。这种方法避免了复杂的遍历和计算，时间复杂度为 $O(q)$，非常高效。

---
处理用时：17.93秒
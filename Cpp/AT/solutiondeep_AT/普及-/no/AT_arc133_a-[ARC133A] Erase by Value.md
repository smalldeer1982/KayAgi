# 题目信息

# [ARC133A] Erase by Value

## 题目描述

给定一个整数序列 $A$，其中包含 $N$ 个元素 $A_1,A_2 \cdots A_N$ 。

小 S 现在要从 $A$ 中选择一个值 $x$。然后，他会按照元素在 $A$ 中的原始顺序，将不等于 $x$ 的元素组成一个新的整数序列 $a$。

请找出所有可能的 $a$ 序列中，字典序最小的那一个。

## 说明/提示

#### 制约
- $ 1\ \leq\ N\ \leq\ 200000 $
- $ 1\ \leq\ A_i\ \leq\ N $
- 所有的输入都是整数
#### 样例 1 解释
在这个样例中，如果选择 $x=2$，则 $a=(4,4,1)$。此外，如果选择 $x=4$，则 $a=(2,1,2)$，这时字典序是最小的。
#### 样例 2 解释
如果选择 $x=1$，则 $a$ 将为空，这显然是字典序最小的。另外，输出中可以包含额外的空格或换行符，不影响结果。

## 样例 #1

### 输入

```
5

2 4 4 1 2```

### 输出

```
2 1 2```

## 样例 #2

### 输入

```
3

1 1 1```

### 输出

```
```

## 样例 #3

### 输入

```
5

1 1 2 3 3```

### 输出

```
1 1 2```

# AI分析结果

### 题目内容重写
给定一个整数序列 $A$，其中包含 $N$ 个元素 $A_1,A_2 \cdots A_N$。

小 S 现在要从 $A$ 中选择一个值 $x$。然后，他会按照元素在 $A$ 中的原始顺序，将不等于 $x$ 的元素组成一个新的整数序列 $a$。

请找出所有可能的 $a$ 序列中，字典序最小的那一个。

### 算法分类
贪心

### 题解分析与结论
本题的核心在于如何选择删除的值 $x$，使得最终序列的字典序最小。大多数题解都采用了贪心策略，即从前往后遍历序列，找到第一个比其后一个元素大的元素，删除该元素及其所有相同值。这种策略的合理性在于，字典序的比较是从前往后进行的，因此尽早删除较大的元素可以确保序列的字典序最小。

### 评分较高的题解

#### 题解1：David_yang (5星)
**关键亮点**：  
- 详细解释了贪心策略的合理性，特别是为什么删除第一个比其后一个元素大的元素可以保证字典序最小。
- 代码简洁明了，注释清晰，易于理解。

**代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005],t;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",a+i);
    }
    for(int i=0;i<n;i++)
    {
        if(i==n-1)
        {
            t=a[i];
            break;
        }
        if(a[i]>a[i+1])
        {
            t=a[i];
            break;
        }
    }
    for(int i=0;i<n;i++)
    {
        if(a[i]!=t)
        {
            printf("%d ",a[i]);
        }
    }
    printf("\n");
    return 0;
}
```

#### 题解2：CleverPenguin (4星)
**关键亮点**：  
- 提供了贪心策略的严格证明，增强了题解的可信度。
- 代码简洁，逻辑清晰。

**代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(a[i-1]>a[i])
        {
            ans=a[i-1];
            for(int j=1;j<=n;j++)
            {
                if(a[j]==ans)
                {
                    continue;
                }
                else
                {
                    cout<<a[j]<<" ";
                }
            }
            return 0;
        }
    }
    ans=a[n];
    for(int i=1;i<=n;i++)
    {
        if(a[i]==ans)
        {
            continue;
        }
        else
        {
            cout<<a[i]<<" ";
        }
    }
    return 0;
}
```

#### 题解3：_hsk121212_ (4星)
**关键亮点**：  
- 通过设置 `a[n+1]=-inf` 来处理纯上升序列的情况，避免了额外的判断。
- 代码简洁，逻辑清晰。

**代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x7fffffff
long long a[200002];
int n,ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)    cin>>a[i];
    a[n+1]=-inf;
    for(int i=1;i<=n;i++)
        if(a[i]>a[i+1]){
            ans=a[i];
            break;
        }
    for(int i=1;i<=n;i++)
        if(a[i]!=ans)
            cout<<a[i]<<" ";
    cout<<endl;
    return 0;
}
```

### 最优关键思路
贪心策略的核心在于尽早删除较大的元素，以确保序列的字典序最小。具体实现时，可以从前往后遍历序列，找到第一个比其后一个元素大的元素，删除该元素及其所有相同值。

### 拓展思路
类似的问题可以通过贪心策略解决，特别是在需要优化某种顺序或选择的情况下。例如，选择某些元素以最小化或最大化某种指标时，贪心策略往往是一个有效的选择。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：31.04秒
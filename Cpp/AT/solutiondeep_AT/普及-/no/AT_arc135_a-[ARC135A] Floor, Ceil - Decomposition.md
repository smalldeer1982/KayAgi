# 题目信息

# [ARC135A] Floor, Ceil - Decomposition

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc135/tasks/arc135_a

黒板にひとつの整数 $ X $ が書かれています。あなたは次の操作を、何度でも行うことができます（一度も行わなくてもよいです）。

- 黒板に書かれている整数 $ x $ をひとつ選ぶ。
- $ x $ をひとつ黒板から消去し、新たに $ \lfloor\ \frac{x}{2}\rfloor $ と $ \lceil\ \frac{x}{2}\rceil $ をひとつずつ黒板に書く。

操作後の黒板に書かれている整数すべての積としてありうる最大値を、$ 998244353 $ で割った余りを答えてください。

  $ \lfloor\ \frac{x}{2}\rfloor $，$ \lceil\ \frac{x}{2}\rceil $ とは？ 実数 $ x $ に対して，$ x $ 以下の最大の整数を $ \lfloor\ x\rfloor $、$ x $ 以上の最小の整数を $ \lceil\ x\rceil $ と書きます。したがって例えば以下が成り立ちます。

- $ x\ =\ 2 $ のとき、$ \lfloor\ \frac{x}{2}\rfloor\ =\ 1 $, $ \lceil\ \frac{x}{2}\rceil\ =\ 1 $。
- $ x\ =\ 3 $ のとき、$ \lfloor\ \frac{x}{2}\rfloor\ =\ 1 $, $ \lceil\ \frac{x}{2}\rceil\ =\ 2 $。

## 说明/提示

### 制約

- $ 1\leq\ X\ \leq\ 10^{18} $

### Sample Explanation 1

例えば次のように操作を行うことで、黒板に書かれている整数すべての積を $ 192 $ にすることが可能です。 - はじめ、黒板は次の状態です：$ (15) $。 - $ x\ =\ 15 $ として操作を行うことで、黒板は次の状態に変化します：$ (7,\ 8) $。 - $ x\ =\ 7 $ として操作を行うことで、黒板は次の状態に変化します：$ (8,\ 3,\ 4) $。 - $ x\ =\ 4 $ として操作を行うことで、黒板は次の状態に変化します：$ (8,\ 3,\ 2,\ 2) $。 - $ x\ =\ 8 $ として操作を行うことで、黒板は次の状態に変化します：$ (3,\ 2,\ 2,\ 4,\ 4) $。 このとき、黒板に書かれている整数すべての積は $ 3\times\ 2\times\ 2\times\ 4\times\ 4\ =\ 192 $ です。

### Sample Explanation 2

操作を一度も行わないことで、黒板に書かれている整数すべての積を $ 3 $ にすることが可能です。

### Sample Explanation 3

操作後の黒板に書かれている整数すべての積としてありうる最大値は、$ 5856458868470016 $ です。これを $ 998244353 $ で割った余りを出力します。

## 样例 #1

### 输入

```
15```

### 输出

```
192```

## 样例 #2

### 输入

```
3```

### 输出

```
3```

## 样例 #3

### 输入

```
100```

### 输出

```
824552442```

# AI分析结果

### 题目内容重写

【题目描述】

黑板上写有一个整数 $ X $。你可以进行以下操作任意次（也可以不进行）：

- 选择黑板上写的一个整数 $ x $。
- 从黑板上擦除 $ x $，并在黑板上写下 $ \lfloor\ \frac{x}{2}\rfloor $ 和 $ \lceil\ \frac{x}{2}\rceil $。

操作结束后，黑板上所有整数的乘积的最大值是多少？请输出该最大值对 $ 998244353 $ 取模的结果。

$ \lfloor\ \frac{x}{2}\rfloor $ 和 $ \lceil\ \frac{x}{2}\rceil $ 分别表示对 $ x $ 除以 2 后向下取整和向上取整。例如：

- 当 $ x = 2 $ 时，$ \lfloor\ \frac{x}{2}\rfloor = 1 $，$ \lceil\ \frac{x}{2}\rceil = 1 $。
- 当 $ x = 3 $ 时，$ \lfloor\ \frac{x}{2}\rfloor = 1 $，$ \lceil\ \frac{x}{2}\rceil = 2 $。

【说明/提示】

### 约束

- $ 1 \leq X \leq 10^{18} $

### 样例解释 1

例如，通过以下操作可以将黑板上所有整数的乘积变为 192：

- 初始状态：$ (15) $。
- 对 $ x = 15 $ 进行操作，黑板变为：$ (7, 8) $。
- 对 $ x = 7 $ 进行操作，黑板变为：$ (8, 3, 4) $。
- 对 $ x = 4 $ 进行操作，黑板变为：$ (8, 3, 2, 2) $。
- 对 $ x = 8 $ 进行操作，黑板变为：$ (3, 2, 2, 4, 4) $。

此时，黑板上所有整数的乘积为 $ 3 \times 2 \times 2 \times 4 \times 4 = 192 $。

### 样例解释 2

不进行任何操作，黑板上所有整数的乘积为 3。

### 样例解释 3

操作后黑板上所有整数的乘积的最大值为 $ 5856458868470016 $。输出该值对 $ 998244353 $ 取模的结果。

【样例 #1】

### 输入

```
15
```

### 输出

```
192
```

【样例 #2】

### 输入

```
3
```

### 输出

```
3
```

【样例 #3】

### 输入

```
100
```

### 输出

```
824552442
```

### 算法分类

**递归** 或 **动态规划**

### 题解分析与结论

由于题目要求最大化黑板上所有整数的乘积，并且可以通过递归地将一个整数拆分为两个较小的整数，因此可以使用递归或动态规划来解决。核心思想是对于每个整数 $ x $，计算将其拆分为 $ \lfloor\ \frac{x}{2}\rfloor $ 和 $ \lceil\ \frac{x}{2}\rceil $ 后的乘积，并与不拆分的情况进行比较，选择较大的值。

### 关键思路与技巧

1. **递归与记忆化**：由于 $ X $ 的范围很大（$ 1 \leq X \leq 10^{18} $），直接递归会导致栈溢出或超时。因此，需要使用记忆化来避免重复计算。
2. **边界条件**：当 $ x \leq 4 $ 时，不拆分的情况通常比拆分后的乘积更大，因此可以直接返回 $ x $。
3. **模运算**：由于结果需要对 $ 998244353 $ 取模，需要在每一步计算中都进行模运算，避免数值溢出。

### 推荐题目

1. [P1044 栈](https://www.luogu.com.cn/problem/P1044) - 考察递归与动态规划的结合。
2. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028) - 类似于本题的递归拆分问题。
3. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095) - 动态规划与贪心的结合，考察状态转移与优化。

### 通用建议与扩展思路

对于这类问题，通常可以通过递归或动态规划来解决。关键在于如何定义状态和状态转移方程，以及如何优化递归的深度（如使用记忆化）。此外，模运算的处理也是这类问题的常见难点，需要在每一步计算中都进行模运算，避免数值溢出。

### 核心代码片段

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
unordered_map<long long, long long> memo;

long long dfs(long long x) {
    if (x <= 4) return x;
    if (memo.count(x)) return memo[x];
    long long left = x / 2;
    long long right = (x + 1) / 2;
    long long res = (dfs(left) * dfs(right)) % MOD;
    memo[x] = res;
    return res;
}

int main() {
    long long X;
    cin >> X;
    cout << dfs(X) << endl;
    return 0;
}
```

### 代码实现思想

1. **记忆化**：使用 `unordered_map` 来存储已经计算过的结果，避免重复计算。
2. **递归拆分**：对于每个 $ x $，计算将其拆分为 $ \lfloor\ \frac{x}{2}\rfloor $ 和 $ \lceil\ \frac{x}{2}\rceil $ 后的乘积，并与不拆分的情况进行比较，选择较大的值。
3. **模运算**：在每一步计算中都进行模运算，避免数值溢出。

---
处理用时：36.17秒
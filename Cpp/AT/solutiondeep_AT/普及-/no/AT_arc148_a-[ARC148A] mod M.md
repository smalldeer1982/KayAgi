# 题目信息

# [ARC148A] mod M

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc148/tasks/arc148_a

数列 $ A\ =\ (A_1,\ A_2,\ ...,\ A_N) $ が与えられます。  
 あなたは次の操作をちょうど $ 1 $ 回行うことができます。

- $ 2 $ 以上の整数 $ M $ を $ 1 $ つ選ぶ。その後、$ 1\ \leq\ i\ \leq\ N $ を満たすすべての整数 $ i $ に対して、 $ A_i $ を 「$ A_i $ を $ M $ で割ったあまり」に置き換える。

例えば $ A\ =\ (2,\ 7,\ 4) $ で $ M\ =\ 4 $ を選んだ時、操作後の $ A $ は $ (2\ \bmod\ 4,\ 7\ \bmod\ 4,\ 4\ \bmod\ 4)\ =\ (2,\ 3,\ 0) $ になります。

操作を行った後の $ A $ に含まれる要素の種類数は最小で何種類になりますか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

操作で $ M\ =\ 3 $ を選ぶと $ A\ =\ (1\ \bmod\ 3,\ 4\ \bmod\ 3,\ 8\ \bmod\ 3)\ =\ (1,\ 1,\ 2) $ になり、操作後の $ A $ の要素の種類数は $ 2 $ 種類になります。 $ A $ の要素の種類数を $ 1 $ 種類にすることはできないので $ 2 $ が答えです。

### Sample Explanation 2

操作で $ M\ =\ 5 $ を選ぶと $ A\ =\ (0,\ 0,\ 0,\ 0) $ になり、これが最適です。

## 样例 #1

### 输入

```
3

1 4 8```

### 输出

```
2```

## 样例 #2

### 输入

```
4

5 10 15 20```

### 输出

```
1```

## 样例 #3

### 输入

```
10

3785 5176 10740 7744 3999 3143 9028 2822 4748 6888```

### 输出

```
1```

# AI分析结果

### 题目内容重写

#### [ARC148A] mod M

**题目描述**

给定一个数列 $ A\ =\ (A_1,\ A_2,\ ...,\ A_N) $。  
你可以进行恰好一次操作：

- 选择一个大于等于2的整数 $ M $。然后，对于所有满足 $ 1\ \leq\ i\ \leq\ N $ 的整数 $ i $，将 $ A_i $ 替换为 $ A_i $ 除以 $ M $ 的余数。

例如，若 $ A\ =\ (2,\ 7,\ 4) $ 且选择 $ M\ =\ 4 $，操作后的 $ A $ 为 $ (2\ \bmod\ 4,\ 7\ \bmod\ 4,\ 4\ \bmod\ 4)\ =\ (2,\ 3,\ 0) $。

操作后的 $ A $ 中包含的元素种类数最小为多少？

**说明/提示**

**约束条件**

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9 $
- 输入的所有值均为整数

**样例解释1**

选择 $ M\ =\ 3 $ 时，$ A\ =\ (1\ \bmod\ 3,\ 4\ \bmod\ 3,\ 8\ \bmod\ 3)\ =\ (1,\ 1,\ 2) $，操作后的 $ A $ 的元素种类数为 $ 2 $。无法将 $ A $ 的元素种类数减少到 $ 1 $，因此答案为 $ 2 $。

**样例解释2**

选择 $ M\ =\ 5 $ 时，$ A\ =\ (0,\ 0,\ 0,\ 0) $，这是最优解。

**样例 #1**

**输入**

```
3

1 4 8```

**输出**

```
2```

**样例 #2**

**输入**

```
4

5 10 15 20```

**输出**

```
1```

**样例 #3**

**输入**

```
10

3785 5176 10740 7744 3999 3143 9028 2822 4748 6888```

**输出**

```
1```

### 算法分类

数学

### 题解分析与结论

#### 题解1：rai1gun

**要点提炼：**
- 当 $M=2$ 时，$a_i$ 的取值只能是 $0$ 或 $1$，因此答案最多为 $2$。
- 如果相邻两数的差值的最小公约数不为 $1$，则可以选择该公约数作为 $M$，使得所有元素变为 $0$，从而种类数为 $1$。

**难点对比：**
- 该题解直接指出了当 $M=2$ 时的情况，但没有详细说明如何计算相邻两数的差值的最小公约数。

**评分：3星**
- 思路清晰，但缺乏具体实现细节。

#### 题解2：SuperCowHorse

**要点提炼：**
- 答案非 $1$ 即 $2$。
- 通过计算相邻两数的差值的最小公约数来判断是否可以使种类数为 $1$。
- 如果最小公约数为 $1$，则种类数为 $2$，否则为 $1$。

**难点对比：**
- 该题解详细说明了如何通过排序和计算差分数组的最小公约数来判断种类数，并给出了具体的代码实现。

**评分：4星**
- 思路清晰，代码可读性强，优化程度高。

### 最优关键思路或技巧

- **排序与差分**：通过排序后计算相邻元素的差值，可以简化最小公约数的计算。
- **最小公约数**：通过计算差分数组的最小公约数，可以判断是否可以使所有元素变为 $0$，从而最小化种类数。

### 可拓展之处

- **类似问题**：类似的问题可以通过计算差分数组的最小公约数来解决，例如在数组中寻找最小的 $M$ 使得所有元素模 $M$ 后相等。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
3. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)

### 核心代码片段

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2e5+5;
int n,a[maxn],del[maxn];
signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)
        scanf("%lld",&a[i]);
    sort(a+1,a+1+n);
    for(int i=1;i<n;++i)
        del[i]=a[i+1]-a[i];
    int gcd=del[1];
    for(int i=2;i<n;++i){
        if(del[i]!=0)
            gcd=__gcd(gcd,del[i]);
        if(gcd==1){
            putchar('2');
            return 0;
        }
    }
    putchar(gcd!=1?'1':'2');
    return 0;
}
```

**核心实现思想：**
- 排序数组，计算相邻元素的差值。
- 计算差值数组的最小公约数，若为 $1$，则种类数为 $2$，否则为 $1$。

---
处理用时：30.08秒
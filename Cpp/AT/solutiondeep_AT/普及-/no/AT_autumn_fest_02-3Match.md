# 题目信息

# 3Match

## 题目描述

有 $H$ 行 $W$ 列的矩阵，每一个矩阵都有一个数字填充。我们需要找出**连续**的横着 $3$ 个及以上或竖着 $3$ 个及以上的，由**同一数字**构成的长方形，如图：

![](https://i.bmp.ovh/imgs/2021/05/f6ceeb02fde0a293.png)

但是，这有可能会连通。那么，这些连通的**只会**变成一个。如图：
![](https://i.bmp.ovh/imgs/2021/05/87dff1f17fcc326d.png)

需要求出长方形的个数（连通的只算一个）

## 说明/提示

$3 \le H, W \le 100$。

# AI分析结果

【题目内容】
# 3Match

## 题目描述

有 $H$ 行 $W$ 列的矩阵，每一个矩阵都有一个数字填充。我们需要找出**连续**的横着 $3$ 个及以上或竖着 $3$ 个及以上的，由**同一数字**构成的长方形，如图：

![](https://i.bmp.ovh/imgs/2021/05/f6ceeb02fde0a293.png)

但是，这有可能会连通。那么，这些连通的**只会**变成一个。如图：
![](https://i.bmp.ovh/imgs/2021/05/87dff1f17fcc326d.png)

需要求出长方形的个数（连通的只算一个）

## 说明/提示

$3 \le H, W \le 100$。

【算法分类】
深度优先搜索 DFS

【题解分析与结论】
该题目要求找出矩阵中由同一数字构成的连续长方形，并且连通的只算一个。题解中主要采用了深度优先搜索（DFS）来解决该问题。DFS用于遍历矩阵中的每个点，并标记已经访问过的点，从而避免重复计算连通的长方形。题解中的难点在于如何判断长方形是否连通，以及如何高效地遍历矩阵。

【精选题解】
1. **作者：Strelitzia_ (赞：3)**
   - **星级：4**
   - **关键亮点：**
     - 使用 `bool` 数组记录每个点是否在长方形内，通过枚举每个点的左右或上下三个点来判断是否构成长方形。
     - 使用 DFS 来处理连通情况，将连通的长方形标记为 `false`，避免重复计算。
     - 代码简洁，逻辑清晰，易于理解。
   - **核心代码：**
     ```cpp
     void dfs(int x,int y,char c){
         if(!x||!y||x>n||y>m||!f[x][y]||a[x][y]!=c) return;
         f[x][y]=false;
         dfs(x+1,y,c);
         dfs(x-1,y,c);
         dfs(x,y+1,c);
         dfs(x,y-1,c);
     }
     ```

2. **作者：Nygglatho (赞：3)**
   - **星级：4**
   - **关键亮点：**
     - 使用二维数组 `tf` 标记所有符合条件的长方形，然后通过 DFS 遍历连通的长方形。
     - 代码结构清晰，逻辑严谨，处理连通情况的方法简单有效。
   - **核心代码：**
     ```cpp
     void DFS(int x, int y, char ch) {
         if (x == 0 || y == 0 || x > n || y > m || !tf[x][y] || st[x][y] != ch) return;
         tf[x][y] = false;
         DFS(x, y - 1, ch);
         DFS(x, y + 1, ch);
         DFS(x - 1, y, ch);
         DFS(x + 1, y, ch);
     }
     ```

3. **作者：Texas_the_Omertosa (赞：2)**
   - **星级：4**
   - **关键亮点：**
     - 使用 `bool` 数组标记符合条件的长方形，并通过 DFS 进行染色，确保连通的长方形只计算一次。
     - 代码实现简洁，逻辑清晰，处理连通情况的方法简单有效。
   - **核心代码：**
     ```cpp
     void dfs(int x,int y,char num){
         if(x<1||y<1||x>n||y>m||a[x][y]!=num) return;
         f[x][y]=0;
         dfs(x+1,y,num);
         dfs(x-1,y,num);
         dfs(x,y+1,num);
         dfs(x,y-1,num);
     }
     ```

【最优关键思路或技巧】
- 使用 DFS 遍历矩阵中的每个点，并标记已经访问过的点，从而避免重复计算连通的长方形。
- 通过枚举每个点的左右或上下三个点来判断是否构成长方形，并使用 `bool` 数组记录符合条件的点。

【可拓展之处】
- 类似的问题可以扩展到其他形状的连通区域，如圆形、三角形等。
- 可以进一步优化算法，使用并查集（Union-Find）来处理连通情况，减少时间复杂度。

【推荐题目】
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

---
处理用时：26.27秒
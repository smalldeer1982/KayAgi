# 题目信息

# 主菜と副菜

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2015-relay/tasks/cf_2015_relay_g

$ N $ 種類の主菜と $ M $ 種類の副菜から料理を選んでコースを作ります。 主菜は $ 1 $ 種類しか選ぶことができませんが、副菜は何種類でも選ぶことができます。 また、副菜は $ 1 $ つも選ばなくても構いません。 主菜・副菜ともにコースに入れられるのは $ 1 $ 種類につき $ 1 $ つまでです。

- $ i $ 番目の主菜は値段が $ A_i $ で、お客さんの評価が $ B_i $ です。
- $ i $ 番目の副菜は値段が $ C_i $ で、お客さんの評価が $ D_i $ です。

コース全体の値段と評価は、主菜と副菜の合計で決まります。 コースの値段を $ L $ 以下にする時、コースの評価は最大でいくつになるか求めてください。

## 样例 #1

### 输入

```
2 2 10

2 3

3 6

3 5

5 5```

### 输出

```
13```

## 样例 #2

### 输入

```
3 3 10

1 1

2 3

3 5

4 8

5 10

6 12```

### 输出

```
19```

## 样例 #3

### 输入

```
3 3 10

1 1

11 11

11 11

11 11

11 11

11 11```

### 输出

```
1```

# AI分析结果

### 题目内容重写
$ N $ 种类の主菜と $ M $ 种类の副菜から料理を选んでコースを作ります。 主菜は $ 1 $ 种类しか选ぶことができませんが、副菜は何种类でも选ぶことができます。 また、副菜は $ 1 $ つも选ばなくても构いません。 主菜・副菜ともにコースに入れられるのは $ 1 $ 种类につき $ 1 $ つまでです。

- $ i $ 番目の主菜は値段が $ A_i $ で、お客さんの評価が $ B_i $ です。
- $ i $ 番目の副菜は値段が $ C_i $ で、お客さんの評価が $ D_i $ です。

コース全体の値段と評価は、主菜と副菜の合計で决まります。 コースの値段を $ L $ 以下にする时、コースの評価は最大でいくつになるか求めてください。

### 样例 #1
#### 输入
```
2 2 10

2 3

3 6

3 5

5 5
```
#### 输出
```
13
```

### 样例 #2
#### 输入
```
3 3 10

1 1

2 3

3 5

4 8

5 10

6 12
```
#### 输出
```
19
```

### 样例 #3
#### 输入
```
3 3 10

1 1

11 11

11 11

11 11

11 11

11 11
```
#### 输出
```
1
```

### 算法分类
动态规划

### 题解分析与结论
该题目是一个典型的01背包问题，主菜必须选且只能选一个，副菜可以选多个。核心思路是先用01背包处理副菜，然后枚举主菜，找到在预算限制下的最大美味值。

### 所选高星题解
#### 1. 作者：Samhu07 (4星)
**关键亮点**：
- 使用01背包处理副菜，优化了时间复杂度。
- 枚举主菜时，直接更新最大值，代码简洁高效。

**核心代码**：
```cpp
for(int i=1;i<=m;i++)
    for(int j=0;j<=l-minn;j++)
        if(j >= side_dish[i].w)
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-side_dish[i].w]+side_dish[i].v);
        else dp[i][j]=dp[i-1][j];
for(int i=1;i<=n;i++)
    if(l >= main_course[i].w)
        ans = max(ans,dp[m][l-main_course[i].w]+main_course[i].v);
```

#### 2. 作者：虫洞吞噬者 (4星)
**关键亮点**：
- 使用一维数组优化空间复杂度。
- 直接在主菜枚举时计算最大值，思路清晰。

**核心代码**：
```cpp
for(int i=1;i<=s;i++)
    for(int j=m;j>=c2[i];j--)
        f[j]=max(f[j],f[j-c2[i]]+v2[i]);
ll ans=0;
for(int i=1;i<=n;i++)
    if(m>=c1[i])ans=max(ans,f[m-c1[i]]+v1[i]);
```

#### 3. 作者：sz_wsy (4星)
**关键亮点**：
- 使用01背包模板处理副菜，代码规范。
- 在主菜枚举时直接计算最大值，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=m;i++)
    for(int j=L;j>=c2[i];j--)
        dp[j]=max(dp[j],dp[j-c2[i]]+w2[i]);
int ans=-1;
for(int i=1;i<=n;i++){
    if(c1[i]<=L) ans=max(ans,dp[L-c1[i]]+w1[i]);
}
```

### 最优关键思路
- 使用01背包处理副菜，优化时间复杂度。
- 枚举主菜时，直接计算在预算限制下的最大美味值。

### 可拓展之处
- 类似问题可以扩展到多个限制条件，如多个主菜或多个副菜。
- 可以结合其他算法如贪心或二分查找进一步优化。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：26.85秒
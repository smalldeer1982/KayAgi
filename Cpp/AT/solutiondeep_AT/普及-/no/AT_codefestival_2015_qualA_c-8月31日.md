# 题目信息

# 8月31日

## 题目描述

高桥君注意到虽然今天暑假已经结束了，但是作业完全没有做完。

做作业的时间还有 $T$ 分钟。而且高桥君必须要做的作业有 $N$ 个。第 $i$ 个作业高桥君要解的话需要 $A_i$ 分钟，高桥君的朋友青木君做的作业全部抄下来的话，$B_i$ 分钟就可以完成了。但是抄朋友的作业是不太好的，所以高桥想尽量**不抄写**。为了在规定时间之前完成所有作业，请求出高桥君需要抄写的作业个数的最小值。但是，如果无法按时完成作业的话，请输出 `-1`。

## 样例 #1

### 输入

```
5 7

1 0

3 0

5 0

2 0

4 0```

### 输出

```
2```

## 样例 #2

### 输入

```
1 1000000000

5 0```

### 输出

```
0```

## 样例 #3

### 输入

```
1 0

100 99```

### 输出

```
-1```

## 样例 #4

### 输入

```
3 11

5 2

6 4

7 3```

### 输出

```
2```

## 样例 #5

### 输入

```
6 92

31 4

15 9

26 5

35 8

97 9

32 3```

### 输出

```
3```

# AI分析结果

### 题目重写
高桥君注意到虽然今天暑假已经结束了，但是作业完全没有做完。

做作业的时间还有 $T$ 分钟。而且高桥君必须要做的作业有 $N$ 个。第 $i$ 个作业高桥君要解的话需要 $A_i$ 分钟，高桥君的朋友青木君做的作业全部抄下来的话，$B_i$ 分钟就可以完成了。但是抄朋友的作业是不太好的，所以高桥想尽量**不抄写**。为了在规定时间之前完成所有作业，请求出高桥君需要抄写的作业个数的最小值。但是，如果无法按时完成作业的话，请输出 `-1`。

### 算法分类
贪心

### 题解分析与结论
这道题的核心思路是通过贪心算法来最小化抄写作业的数量。首先，我们需要判断是否有可能在规定时间内完成所有作业。如果所有作业都抄写都无法完成，则输出 `-1`。否则，我们可以通过计算每个作业自己完成和抄写的时间差，并按照差值从小到大排序，优先选择差值较大的作业进行抄写，以减少抄写作业的数量。

### 精选题解
#### 题解1：Kaidora (5星)
**关键亮点**：
- 清晰的贪心思路，通过计算每个作业自己完成和抄写的时间差，并排序后选择差值较大的作业进行抄写。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int N, T;
int A[100006];
int B[100006];
int sum;
int ans;

int main()
{
    cin >> N >> T;
    sum = 0;
    ans = N;
    for(int n = 1; n <= N; ++n) {
        cin >> A[n] >> B[n];
        sum += B[n];
        A[n] -= B[n];
    }
    if(sum > T) {
        puts("-1");
        return 0;
    }
    sort(A + 1, A + 1 + N);
    for(int n = 1; n <= N; ++n) {
        if(sum + A[n] > T)
            break;
        sum += A[n];
        --ans;
    }
    cout << ans << endl;
    return 0;
}
```

#### 题解2：Griseo_nya (4星)
**关键亮点**：
- 通过维护两个总时间（抄写和完成）来判断是否有可能完成作业。
- 使用结构体存储作业信息，并按差值排序，减少了代码的复杂度。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,ans,tot1,tot2;					//tot1是抄作业的总时间，tot2是自己写的总时间
const int maxn=1e5+1;
struct work{
    int copy,delta,finish;				//分别是抄作业的时间、自己写的时间和两个时间的差
}home[maxn];
bool cmp(work a,work b){
    return a.delta>b.delta;				//比较差值，差值大的靠前
}
int main(){
    ios::sync_with_stdio(false);		//读入优化
    cin>>n>>t;
    for(int i=1;i<=n;i++){
        cin>>home[i].finish>>home[i].copy;	
        home[i].delta=home[i].finish-home[i].copy;//维护两个时间之差
        tot1+=home[i].copy;				//维护tot1(抄作业的时间和)
        tot2+=home[i].finish;			//维护tot2(写作业的时间和)
        if(tot1>t){						//如果抄作业都抄不完就直接退出
            cout<<-1<<endl;
            return 0;
        }
    }
    if(tot2<=t){						//如果正常写可以写完就不用抄了
        cout<<0<<endl;
        return 0;
    }
    sort(home+1,home+n+1,cmp);			//按差值从大往小排序
    int pos=1;							//进行到哪一个作业了
    while(tot2>t){						
        tot2-=home[pos++].delta;		//减去差值，位置+1
        ans++;							//给ans+1
    }
    cout<<ans<<endl;					//输出答案
    return 0;
}
```

### 最优关键思路
通过计算每个作业自己完成和抄写的时间差，并按照差值从小到大排序，优先选择差值较大的作业进行抄写，以减少抄写作业的数量。

### 拓展思路
类似的问题可以扩展到其他资源分配问题，如任务调度、背包问题等，都可以通过贪心算法来优化资源的使用。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：31.46秒
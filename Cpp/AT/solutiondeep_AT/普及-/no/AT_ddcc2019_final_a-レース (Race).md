# 题目信息

# レース (Race)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/ddcc2019-final/tasks/ddcc2019_final_a

高橋君はペンギンのレース場を作りました。

レース場は $ N $ 個の正方形のマスが西から東に一列に並んだ形状をしています。  
 これらのマスの状態は文字列 $ S $ により表され、西から $ i $ 番目のマスの状態は $ S $ の $ i $ 文字目が `-` なら「雪」、`>` なら「氷」です。  
 また、スタート地点は西端のマスの西の端、ゴール地点は東端のマスの東の端です。

高橋くんのペンギンが、スタート地点からゴール地点を目指して東に進みます。  
 ペンギンは、雪マスを $ 1 $ マス通過するのに $ 1 $ 秒、氷マスを $ 1 $ マス通過するのに $ 1/(k+2) $ 秒の時間を要します。  
 ここで、$ k $ はその氷マスの直前に連続して存在する氷マスの個数です。  
 例えば、雪マスの直後に氷マスが $ 2 $ つ存在する場合、$ 1 $ つ目の氷マスは $ 1/2 $ 秒、$ 2 $ つ目の氷マスは $ 1/3 $ 秒で通過します。

ペンギンがスタートする前に、高橋君は雪マスのうち $ 1 $ つを氷マスに変えることができます。  
 ペンギンがスタート地点を出発してからゴール地点に到達するまでに最小で何秒かかるでしょうか？

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 100\ 000 $
- $ S $ は `-`, `>` で構成される長さ $ N $ の文字列
- $ S_1\ =\ S_2\ =\ S_{N-1}\ =\ S_N\ = $ `-`
- **$ S $ において、`-` は必ず別の `-` と隣接して現れる**

### Sample Explanation 1

西から $ 4 $ 番目のマスを雪マスから氷マスに変えると、レース場は `--&gt;&gt;-` となります。 このとき、ペンギンは西から $ 1,\ 2,\ 3,\ 4,\ 5 $ 番目のマスの通過にそれぞれ $ 1,\ 1,\ 1/2,\ 1/3,\ 1 $ 秒、合計で $ 23/6\ =\ 3.83333333... $ 秒を要し、これが最短です。

### Sample Explanation 2

どのマスを雪マスから氷マスに変えても、ペンギンは $ 13/2\ =\ 6.5 $ 秒でゴールします。

### Sample Explanation 3

西から $ 2 $ 番目または $ 6 $ 番目のマスを雪マスから氷マスに変えると、ペンギンは $ 407/60\ =\ 6.783333333... $ 秒でゴールすることができます。

## 样例 #1

### 输入

```
5

-->--```

### 输出

```
3.83333333333333```

## 样例 #2

### 输入

```
7

-------```

### 输出

```
6.5```

## 样例 #3

### 输入

```
10

-->>>-->--```

### 输出

```
6.78333333333333```

# AI分析结果

### 题目内容重写（中文）

高橋君为企鹅建造了一个赛道。

赛道由 $N$ 个正方形方格组成，这些方格从西向东排成一列。  
这些方格的状态由字符串 $S$ 表示，字符串的第 $i$ 个字符表示第 $i$ 个方格的状态：`-` 表示“雪”，`>` 表示“冰”。  
起点位于最西端方格的西侧，终点位于最东端方格的东侧。

高橋君的企鹅从起点出发，向东移动，目标是到达终点。  
企鹅通过一个雪方格需要 $1$ 秒，通过一个冰方格需要 $1/(k+2)$ 秒，其中 $k$ 是该冰方格之前连续存在的冰方格数量。  
例如，如果雪方格后面有 $2$ 个冰方格，那么第一个冰方格需要 $1/2$ 秒，第二个冰方格需要 $1/3$ 秒。

在企鹅出发之前，高橋君可以将一个雪方格变为冰方格。  
问企鹅从起点出发到终点所需的最短时间是多少？

### 算法分类
贪心

### 题解分析与结论

题目要求通过将一个雪方格变为冰方格，使得企鹅通过赛道的时间最短。核心思路是贪心：通过延长最长的连续冰方格序列，可以最大化减少通过时间。具体来说，将雪方格变为冰方格后，应该将其放置在最长连续冰方格序列的末尾，这样可以使得通过该冰方格的时间最小化。

### 精选题解

#### 1. 作者：Maisie586_ (4星)
**关键亮点**：
- 通过遍历字符串，计算基础时间，并记录最长连续冰方格的长度。
- 使用 `printf("%.15g", time)` 确保输出精度，避免四舍五入问题。

**代码核心思想**：
```cpp
for (int i = 1; i <= n; i++) {
    if (s[i] == '>') {
        cur++;
        time += 1.0 / (cur + 1);
    } else {
        mx = max(mx, cur);
        cur = 0;
        time += 1;
    }
}
time -= 1;
time += 1.0 / (mx + 2);
printf("%.15g", time);
```

#### 2. 作者：David_yang (4星)
**关键亮点**：
- 通过遍历字符串，计算总时间，并记录最长连续冰方格的长度。
- 使用 `printf("%.15lf", sum)` 确保输出精度。

**代码核心思想**：
```cpp
for (int i = 0; i < s.length(); i++) {
    if (s[i] == '-') {
        sum += 1.0;
        mmax = max(mmax, cnt);
        cnt = 0;
    } else {
        sum += (double)(1.0 / (cnt + 2.0));
        cnt++;
    }
}
printf("%.15lf", sum - 1.0 + (1.0 / (mmax + 2.0)));
```

#### 3. 作者：A_grasser (4星)
**关键亮点**：
- 通过遍历字符串，计算总时间，并记录最长连续冰方格的长度。
- 使用 `cout << fixed << setprecision(15) << ans` 确保输出精度。

**代码核心思想**：
```cpp
for (int i = 0; i < s.size(); i++) {
    if (s[i] == '>') {
        ans += (1.0 / (il + 2));
        il++;
    } else {
        ans += 1;
        mx = max(mx, il);
        il = 0;
    }
}
cout << fixed << setprecision(15) << ans - 1 + (1.0 / (mx + 2));
```

### 最优关键思路
贪心策略：将雪方格变为冰方格后，将其放置在最长连续冰方格序列的末尾，以最小化通过时间。

### 可拓展之处
类似的问题可以通过贪心策略优化，例如在最短路径问题中，通过选择最优的局部决策来达到全局最优。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

### 个人心得
- **调试经历**：在处理输出精度时，使用 `printf` 或 `cout` 的格式化输出可以避免四舍五入问题。
- **顿悟感想**：贪心策略在优化问题中非常有效，尤其是在局部最优决策能够导致全局最优解的情况下。

---
处理用时：29.58秒
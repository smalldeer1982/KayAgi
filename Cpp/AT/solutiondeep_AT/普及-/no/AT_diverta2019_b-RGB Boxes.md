# 题目信息

# RGB Boxes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/diverta2019/tasks/diverta2019_b

すぬけ君はボールが入った箱を売っている店に行きました。 売っている箱は以下の $ 3 $ 種類です。

- $ R $ 個のボールが入った赤色の箱
- $ G $ 個のボールが入った緑色の箱
- $ B $ 個のボールが入った青色の箱

すぬけ君は赤色の箱を $ r $ 個、緑色の箱を $ g $ 個、青色の箱を $ b $ 個買うことで合計でちょうど $ N $ 個のボールが手に入るようにしたいです。 これを達成する非負整数の組 $ (r,g,b) $ はいくつありますか？

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ R,G,B,N\ \leq\ 3000 $

### Sample Explanation 1

条件を満たすのは以下の $ 4 $ 通りです。 - $ (4,0,0) $ - $ (2,1,0) $ - $ (1,0,1) $ - $ (0,2,0) $

## 样例 #1

### 输入

```
1 2 3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
13 1 4 3000```

### 输出

```
87058```

# AI分析结果

### 题目内容重写

#### RGB Boxes

##### 题目描述

すぬけ君去了一家卖装有球的箱子的商店。商店出售的箱子有以下三种：

- 装有 $R$ 个球的红色箱子
- 装有 $G$ 个球的绿色箱子
- 装有 $B$ 个球的蓝色箱子

すぬけ君希望通过购买 $r$ 个红色箱子、$g$ 个绿色箱子和 $b$ 个蓝色箱子，使得总共恰好得到 $N$ 个球。请问有多少组非负整数 $(r,g,b)$ 可以满足这个条件？

##### 说明/提示

###### 制約

- 输入均为整数
- $1 \leq R,G,B,N \leq 3000$

###### 样例解释 1

满足条件的有以下 $4$ 组：
- $(4,0,0)$
- $(2,1,0)$
- $(1,0,1)$
- $(0,2,0)$

##### 样例 #1

###### 输入

```
1 2 3 4
```

###### 输出

```
4
```

##### 样例 #2

###### 输入

```
13 1 4 3000
```

###### 输出

```
87058
```

### 算法分类
枚举

### 题解分析与结论

#### 题解1：Gokix
- **星级**：4
- **关键亮点**：通过枚举 $r$ 和 $g$，然后计算 $b$ 的值，并确保 $b$ 为非负整数。优化了时间复杂度为 $O(n^2)$。
- **个人心得**：在调试过程中发现剩余球数可能为负，导致错误，因此增加了 $u/b \geq 0$ 的判断。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long r,g,b,n,ans;
int main()
{
    long long i,j,u,v;
    cin>>r>>g>>b>>n;
    for(i=0;i<=n;i++)
    {
        for(j=0;j<=n;j++)
        {
            u=n-(i*r)-(j*g);
            if(u%b==0 && u/b>=0)
            {
                ans++;
            }
        }
    }
    cout<<ans<<endl;
    return(0);
}
```

#### 题解2：caoxuran
- **星级**：4
- **关键亮点**：同样采用枚举 $r$ 和 $g$，然后计算 $b$ 的值，并确保 $b$ 为非负整数。代码简洁明了。
- **个人心得**：吐槽了题目中使用 RGB 颜色的选择，但最终回归正题，强调了 $k$ 必须为非负数的判断。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int R,G,B,n;
    cin>>R>>G>>B>>n;
    
    int sum=0;
    for(int i=0;i<=n;i++)
        for(int j=0;j<=n;j++)
        {
            int k=n-i*R-j*G;
            if(k%B==0 && k>=0)
                sum++;
        }
    
    cout<<sum<<endl;
    return 0;
}
```

### 最优关键思路或技巧
- **枚举优化**：通过枚举两个变量，计算第三个变量，减少时间复杂度。
- **边界条件**：确保计算得到的第三个变量为非负整数，避免错误。

### 可拓展之处
- **类似问题**：可以扩展到更多类型的箱子或更多约束条件的问题。
- **算法套路**：枚举两个变量，计算第三个变量，适用于类似的多变量约束问题。

### 推荐题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：22.36秒
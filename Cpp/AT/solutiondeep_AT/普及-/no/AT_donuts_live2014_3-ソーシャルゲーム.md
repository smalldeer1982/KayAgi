# 题目信息

# ソーシャルゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/donuts-live2014/tasks/donuts_live2014_3

ソーシャルゲームを運営するためには、日々のユーザ数の増減を観察することが欠かせません。

ゲーム会社を運営しているパンチくんは、最もユーザが増加した期間に、何人ユーザが増加したかを調べようとしています。

日々のユーザの増減数 $ a_1,\ a_2,\ …,\ a_N $ が与えられるので、ユーザ数の増減数が最大となる期間のユーザの増減数を求めて下さい。

## 说明/提示

### 部分点

$ 1\ ≦\ N\ ≦\ 3000 $ を満たすテストケースに正解した場合、部分点として $ 40 $ 点が与えられる。

### Sample Explanation 1

$ 3 $ 日目から $ 6 $ 日目までの、 $ (2,\ 3,\ -1,\ 2) $ の増加数 $ 6 $ が最大です。

### Sample Explanation 2

全期間が、ユーザの増減数が最大となる期間となります。

### Sample Explanation 3

出力はマイナスとなることがあります。 出力対象となる期間は $ 1 $ 日以上であることに注意して下さい。

## 样例 #1

### 输入

```
7

3 -4 2 3 -1 2 -1```

### 输出

```
6```

## 样例 #2

### 输入

```
3

10 20 30```

### 输出

```
60```

## 样例 #3

### 输入

```
3

-4 -2 -5```

### 输出

```
-2```

# AI分析结果

### 中文题目重写

**题目描述**

为了运营社交游戏，观察每日用户数量的增减是必不可少的。

运营游戏公司的帕奇君想要调查用户数量增长最多的时期，用户数量增加了多少。

给定每日用户的增减数 $a_1,\ a_2,\ …,\ a_N$，请找出用户数量增减数最大的时期，并输出该时期的用户增减数。

**说明/提示**

### 部分点

$ 1\ ≦\ N\ ≦\ 3000 $ 的测试用例正确时，将获得部分分 40 分。

### 样例解释 1

从第 3 天到第 6 天，用户增减数为 $ (2,\ 3,\ -1,\ 2) $，增量为 6，这是最大的。

### 样例解释 2

整个期间是用户增减数最大的时期。

### 样例解释 3

输出可能为负数。注意，目标期间必须至少为 1 天。

**样例 #1**

输入：

```
7

3 -4 2 3 -1 2 -1
```

输出：

```
6
```

**样例 #2**

输入：

```
3

10 20 30
```

输出：

```
60
```

**样例 #3**

输入：

```
3

-4 -2 -5
```

输出：

```
-2
```

### 算法分类

动态规划

### 题解分析与结论

所有题解都采用了动态规划的思路，核心思想是通过维护一个状态变量来记录当前的最大子段和，并在遍历数组时不断更新这个状态。具体来说，状态转移方程为：

$$
dp_i = \max(dp_{i-1} + a_i, a_i)
$$

其中，$dp_i$ 表示以第 $i$ 个元素结尾的最大子段和。最终，所有 $dp_i$ 中的最大值即为所求的最大子段和。

### 评分较高的题解

#### 1. 作者：David_yang (赞：4)

**星级：5**

**关键亮点：**
- 简洁明了的状态转移方程解释。
- 代码实现简洁，易于理解。
- 初始值设置合理，避免了边界问题。

**代码核心实现：**
```cpp
int n,a,f,ans=-10005;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&a);
        f=max(f+a,a);
        ans=max(f,ans);
    }
    printf("%d",ans);
    return 0;
}
```

#### 2. 作者：Hughpig (赞：2)

**星级：4**

**关键亮点：**
- 详细解释了状态转移方程的两种选择。
- 代码结构清晰，易于扩展。

**代码核心实现：**
```cpp
int a[100005],f[100005],mx,n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    f[1]=mx=a[1];
    for(int i=2;i<=n;i++)
    {
        f[i]=max(f[i-1]+a[i],a[i]);
        mx=max(mx,f[i]);
    }
    cout<<mx<<'\n';
    return 0;
}
```

#### 3. 作者：qi__ (赞：1)

**星级：4**

**关键亮点：**
- 直接列出状态转移方程，清晰易懂。
- 代码实现简洁，初始值设置合理。

**代码核心实现：**
```cpp
int n,a[MAXN],dp[MAXN],sum=-114514;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        dp[i]=max(a[i],dp[i-1]+a[i]);
        sum=max(dp[i],sum);
    }
    cout<<sum;
    return 0;
}
```

### 最优关键思路或技巧

- **状态转移方程**：$dp_i = \max(dp_{i-1} + a_i, a_i)$ 是解决最大子段和问题的核心。
- **初始值设置**：合理设置初始值（如 `ans=-10005` 或 `sum=-114514`）可以避免边界问题。
- **空间优化**：通过使用单个变量来维护当前的最大子段和，可以将空间复杂度优化到 $O(1)$。

### 可拓展之处

- **类似问题**：最大子矩阵和、最大子数组乘积等问题都可以通过类似的动态规划思路解决。
- **优化思路**：在处理大规模数据时，可以考虑进一步优化空间复杂度，或者使用并行计算来加速。

### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1719 最大子矩阵和](https://www.luogu.com.cn/problem/P1719)
3. [P1527 最大子数组乘积](https://www.luogu.com.cn/problem/P1527)

---
处理用时：27.28秒
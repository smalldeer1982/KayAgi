# 题目信息

# Frog 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_b

$ N $ 個の足場があります。 足場には $ 1,\ 2,\ \ldots,\ N $ と番号が振られています。 各 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について、足場 $ i $ の高さは $ h_i $ です。

最初、足場 $ 1 $ にカエルがいます。 カエルは次の行動を何回か繰り返し、足場 $ N $ まで辿り着こうとしています。

- 足場 $ i $ にいるとき、足場 $ i\ +\ 1,\ i\ +\ 2,\ \ldots,\ i\ +\ K $ のどれかへジャンプする。 このとき、ジャンプ先の足場を $ j $ とすると、コスト $ |h_i\ -\ h_j| $ を支払う。

カエルが足場 $ N $ に辿り着くまでに支払うコストの総和の最小値を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ 100 $
- $ 1\ \leq\ h_i\ \leq\ 10^4 $

### Sample Explanation 1

足場 $ 1 $ → $ 2 $ → $ 5 $ と移動すると、コストの総和は $ |10\ -\ 30|\ +\ |30\ -\ 20|\ =\ 30 $ となります。

### Sample Explanation 2

足場 $ 1 $ → $ 2 $ → $ 3 $ と移動すると、コストの総和は $ |10\ -\ 20|\ +\ |20\ -\ 10|\ =\ 20 $ となります。

### Sample Explanation 3

足場 $ 1 $ → $ 2 $ と移動すると、コストの総和は $ |10\ -\ 10|\ =\ 0 $ となります。

### Sample Explanation 4

足場 $ 1 $ → $ 4 $ → $ 8 $ → $ 10 $ と移動すると、コストの総和は $ |40\ -\ 70|\ +\ |70\ -\ 70|\ +\ |70\ -\ 60|\ =\ 40 $ となります。

## 样例 #1

### 输入

```
5 3

10 30 40 50 20```

### 输出

```
30```

## 样例 #2

### 输入

```
3 1

10 20 10```

### 输出

```
20```

## 样例 #3

### 输入

```
2 100

10 10```

### 输出

```
0```

## 样例 #4

### 输入

```
10 4

40 10 20 70 80 10 20 70 80 60```

### 输出

```
40```

# AI分析结果

### 题目内容
#### Frog 2

**题目描述**

有 $N$ 个足场，编号为 $1, 2, \ldots, N$。每个足场 $i$ 的高度为 $h_i$。一只青蛙最初位于足场 $1$，它希望通过跳跃到达足场 $N$。每次跳跃时，青蛙可以从足场 $i$ 跳到足场 $i+1, i+2, \ldots, i+K$ 中的任意一个，跳跃到足场 $j$ 的代价为 $|h_i - h_j|$。求青蛙到达足场 $N$ 的最小总代价。

**说明/提示**

- 输入均为整数。
- $2 \leq N \leq 10^5$
- $1 \leq K \leq 100$
- $1 \leq h_i \leq 10^4$

### 算法分类
动态规划

### 题解分析与结论
所有题解均采用了动态规划的思路，核心思想是定义 $dp[i]$ 表示跳到第 $i$ 个足场的最小代价，并通过状态转移方程 $dp[i] = \min(dp[j] + |h_i - h[j]|)$ 来更新 $dp[i]$，其中 $j$ 的取值范围为 $i-K$ 到 $i-1$。

### 评分较高的题解

#### 1. 作者：Doqin07 (5星)
**关键亮点**：
- 简洁明了地定义了状态和转移方程。
- 代码实现清晰，直接使用双重循环进行状态转移。
- 初始化 $dp$ 数组为极大值，确保最小值的正确更新。

**核心代码**：
```cpp
dp[1] = 0;
for(int i = 2; i <= n; ++i)
    for(int j = max(1, i - k); j < i; ++j)
        dp[i] = min(dp[i], dp[j] + abs(h[i] - h[j]));
```

#### 2. 作者：GZY007 (4星)
**关键亮点**：
- 使用了类似的双重循环结构，但代码中加入了更多的注释，便于理解。
- 初始化 $dp$ 数组为极大值，确保最小值的正确更新。

**核心代码**：
```cpp
dp[1] = 0;
for(int j = 1; j <= m - 1; ++j)
    for(int x = 1; x <= k; ++x)
        dp[j + x] = min(dp[j + x], dp[j] + abs(h[j] - h[j + x]));
```

#### 3. 作者：chenxia25 (4星)
**关键亮点**：
- 代码结构清晰，直接使用双重循环进行状态转移。
- 初始化 $dp$ 数组为极大值，确保最小值的正确更新。

**核心代码**：
```cpp
dp[1] = 0;
for(int i = 2; i <= n; ++i) {
    dp[i] = inf;
    for(int j = max(1, i - m); j < i; ++j)
        dp[i] = min(dp[i], dp[j] + abs(a[i] - a[j]));
}
```

### 最优关键思路
- **状态定义**：$dp[i]$ 表示跳到第 $i$ 个足场的最小代价。
- **状态转移**：$dp[i] = \min(dp[j] + |h_i - h[j]|)$，其中 $j$ 的取值范围为 $i-K$ 到 $i-1$。
- **初始化**：$dp[1] = 0$，其余 $dp[i]$ 初始化为极大值。

### 可拓展之处
- 类似的问题可以扩展到更复杂的跳跃规则，如每次跳跃的步数不固定或跳跃代价与距离的平方成正比。
- 可以结合其他算法如优先队列来优化时间复杂度，特别是在 $K$ 较大的情况下。

### 推荐题目
1. [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)
2. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：22.64秒
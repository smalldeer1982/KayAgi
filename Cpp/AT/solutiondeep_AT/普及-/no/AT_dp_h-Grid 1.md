# 题目信息

# Grid 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_h

縦 $ H $ 行、横 $ W $ 列のグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ で表します。

各 $ i,\ j $ ($ 1\ \leq\ i\ \leq\ H $, $ 1\ \leq\ j\ \leq\ W $) について、マス $ (i,\ j) $ の情報が文字 $ a_{i,\ j} $ によって与えられます。 $ a_{i,\ j} $ が `.` ならばマス $ (i,\ j) $ は空マスであり、$ a_{i,\ j} $ が `#` ならばマス $ (i,\ j) $ は壁のマスです。 マス $ (1,\ 1) $ および $ (H,\ W) $ は空マスであることが保証されています。

太郎君は、マス $ (1,\ 1) $ から出発し、右または下に隣り合う空マスへの移動を繰り返すことで、マス $ (H,\ W) $ まで辿り着こうとしています。

マス $ (1,\ 1) $ から $ (H,\ W) $ までの太郎君の経路は何通りでしょうか？ 答えは非常に大きくなりうるので、$ 10^9\ +\ 7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ H $ および $ W $ は整数である。
- $ 2\ \leq\ H,\ W\ \leq\ 1000 $
- $ a_{i,\ j} $ は `.` または `#` である。
- マス $ (1,\ 1) $ および $ (H,\ W) $ は空マスである。

### Sample Explanation 1

経路は次図の $ 3 $ 通りです。 !\[\](https://img.atcoder.jp/dp/grid\_0\_0\_muffet.png)

### Sample Explanation 2

経路が存在しない場合もあります。

### Sample Explanation 4

答えを $ 10^9\ +\ 7 $ で割った余りを出力することを忘れずに。

## 样例 #1

### 输入

```
3 4

...#

.#..

....```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2

..

#.

..

.#

..```

### 输出

```
0```

## 样例 #3

### 输入

```
5 5

..#..

.....

#...#

.....

..#..```

### 输出

```
24```

## 样例 #4

### 输入

```
20 20

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................

....................```

### 输出

```
345263555```

# AI分析结果

### 题目内容重写
**题目描述**

有一个高度为 $H$ 行，宽度为 $W$ 列的网格。从上到下第 $i$ 行，从左到右第 $j$ 列的格子表示为 $(i, j)$。每个格子 $(i, j)$ 的信息由字符 $a_{i,j}$ 给出，如果 $a_{i,j}$ 是 `.`，则该格子是空的；如果 $a_{i,j}$ 是 `#`，则该格子是墙。保证起点 $(1, 1)$ 和终点 $(H, W)$ 都是空的。

太郎君从 $(1, 1)$ 出发，只能向右或向下移动到相邻的空格子，最终到达 $(H, W)$。问太郎君有多少种不同的路径可以到达终点？由于答案可能非常大，请输出答案对 $10^9 + 7$ 取模的结果。

**说明/提示**

- $H$ 和 $W$ 是整数，且 $2 \leq H, W \leq 1000$。
- $a_{i,j}$ 是 `.` 或 `#`。
- 起点 $(1, 1)$ 和终点 $(H, W)$ 是空的。

**样例**

输入：
```
3 4
...#
.#..
....
```
输出：
```
3
```

### 算法分类
动态规划

### 题解分析与结论
这道题的核心思路是使用动态规划（DP）来计算从起点到终点的路径数。由于只能向右或向下移动，因此每个格子的路径数只能从其上方或左方的格子转移而来。通过状态转移方程 $dp[i][j] = dp[i-1][j] + dp[i][j-1]$，可以逐步计算出每个格子的路径数。需要注意的是，如果当前格子是墙，则路径数为0。

### 评分较高的题解
1. **作者：_ZhouYuHan_ (5星)**
   - **关键亮点**：思路清晰，代码简洁，直接使用动态规划的核心思想，状态转移方程明确，代码可读性高。
   - **代码核心**：
     ```cpp
     for(int i=1; i<=n; i++)
         for(int j=1; j<=m; j++)
             if(ch[i][j]=='.')
                 a[i][j]=(a[i-1][j]+a[i][j-1])%1000000007;
     ```

2. **作者：Haphyxlos (4星)**
   - **关键亮点**：代码结构清晰，状态转移方程明确，且对起点进行了特殊处理，避免了重复计算。
   - **代码核心**：
     ```cpp
     for(int i=1; i<=n; i++)
         for(int j=1; j<=m; j++)
             if(c[i][j]=='.')
                 f[i][j]=(f[i-1][j]+f[i][j-1])%mod;
     ```

3. **作者：WHJ___ (4星)**
   - **关键亮点**：代码简洁，状态转移方程明确，且对障碍物进行了特殊处理，逻辑清晰。
   - **代码核心**：
     ```cpp
     dp[i][j]=mapp[i][j]=='#'?0:(dp[i-1][j]+dp[i][j-1])%zzh;
     ```

### 最优关键思路或技巧
- **动态规划**：通过状态转移方程 $dp[i][j] = dp[i-1][j] + dp[i][j-1]$，逐步计算每个格子的路径数。
- **障碍物处理**：如果当前格子是墙，则路径数为0，避免无效计算。
- **取模运算**：由于答案可能非常大，每次计算后都对 $10^9 + 7$ 取模，防止溢出。

### 可拓展之处
- **类似题目**：可以扩展到三维网格或其他移动规则（如对角线移动）的路径计数问题。
- **优化**：可以使用滚动数组优化空间复杂度，减少内存使用。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

---
处理用时：27.25秒
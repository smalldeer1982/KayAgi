# 题目信息

# 2525文字列分解

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dwacon2018-prelims/tasks/dwacon2018_prelims_b

dwango社員のニワンゴくんは2525SNSという新しいSNSを開発しています。 2525SNSは2525文字列のみ投稿可能な画期的なSNSです。

この問題において、`25` の $ 1 $ 回以上の繰り返しで表される文字列を2525文字列と呼びます。 例えば、`25`,`2525`,`2525252525252525` などは2525文字列ですが、空文字列や `2255`,`2552`,`252` などは2525文字列ではありません。

まず、ニワンゴくんは2525文字列をいくつか作ることにしました。 ニワンゴくんは手元にあった文字列 $ s $ を $ 1 $ つ以上の部分列に分解し、分解された部分列それぞれが2525文字列となるようにしたいです。

最小でいくつの部分列に分解すればこれを達成可能ですか？どのように分解しても達成不可能な場合は `-1` を出力してください。分解についてはサンプル $ 1 $ の説明も参照してください。

## 说明/提示

### 制約

- $ 1\ \leq\ |s|\ \leq\ 2{,}525 $
- $ s $ は `2` と `5` のみからなる

### Sample Explanation 1

\- $ 1 $ つの部分列に分解した場合、`225525` は2525文字列ではないため条件を満たしません。 - その他の分解としては例えば $ ( $`25`,`2525`$ ) $ となるような分解と $ ( $`25`,`25`,`25`$ ) $ となるような分解が考えられます。それぞれについて正しい分解の例とそうでない例を示します。各部分列内において、$ s $ における相対的な出現順序が守られるように分解する必要があることに注意してください。 - $ ( $`25`,`2525`$ ) $ となるように $ 2 $ つの部分列に分解することで、それぞれの部分列が2525文字列となるように分解できます。 !\[062c9a95edb82917811ef52962f98a3e.png\](https://img.atcoder.jp/dwacon2018-prelims/062c9a95edb82917811ef52962f98a3e.png)

### Sample Explanation 2

\- 分解方法は $ 2 $ 通りありますが、それぞれの部分列が2525文字列となるように分解することはできません。 - `5` と `2` に分解したのち、それぞれの順序を入れ替えて `25` を作ることは不可能なことに注意してください。

## 样例 #1

### 输入

```
225525```

### 输出

```
2```

## 样例 #2

### 输入

```
52```

### 输出

```
-1```

## 样例 #3

### 输入

```
2255252252222555552522255255```

### 输出

```
5```

## 样例 #4

### 输入

```
25252```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

**题目描述**

dwango社员的ニワンゴくん正在开发一个名为2525SNS的新SNS。2525SNS只能发布2525字符串，这是一个划时代的SNS。

在这个问题中，`25` 的 $1$ 次以上的重复所表示的字符串被称为2525字符串。例如，`25`、`2525`、`2525252525252525` 等都是2525字符串，但空字符串、`2255`、`2552`、`252` 等不是2525字符串。

首先，ニワンゴくん决定制作一些2525字符串。他有一个字符串 $s$，希望将其分解为 $1$ 个以上的子序列，使得每个子序列都是2525字符串。请问最少需要将 $s$ 分解成多少个子序列才能实现这一目标？如果无论如何分解都无法实现，则输出 `-1`。

**说明/提示**

**约束条件**

- $1 \leq |s| \leq 2,525$
- $s$ 仅由 `2` 和 `5` 组成

**样例解释**

**样例1**

输入：`225525`

输出：`2`

解释：将字符串分解为 `25` 和 `2525` 两个子序列，每个子序列都是2525字符串。

**样例2**

输入：`52`

输出：`-1`

解释：无法将字符串分解为2525字符串。

**样例3**

输入：`2255252252222555552522255255`

输出：`5`

**样例4**

输入：`25252`

输出：`-1`

### 算法分类

**字符串**

### 题解分析与结论

本题的核心是判断字符串 $s$ 是否可以分解为若干个2525字符串，并找出最小的分解数。2525字符串的定义是 `25` 的重复，因此我们需要确保字符串中的 `2` 和 `5` 能够成对出现，并且 `2` 必须在 `5` 之前。

#### 题解对比

1. **Carotrl 的题解**
   - **思路**：通过统计字符串中 `2` 和 `5` 的数量差，判断是否满足条件，并找出最大差值作为最小分解数。
   - **优点**：思路清晰，代码简洁，时间复杂度为 $O(n)$。
   - **缺点**：没有详细解释为什么最大差值就是最小分解数。
   - **评分**：4星

2. **大头leo 的题解**
   - **思路**：与Carotrl的题解类似，通过统计 `2` 和 `5` 的数量差，判断是否满足条件，并找出最大差值。
   - **优点**：代码简洁，时间复杂度为 $O(n)$。
   - **缺点**：没有详细解释为什么最大差值就是最小分解数。
   - **评分**：4星

3. **_Ayanami_ 的题解**
   - **思路**：提供了两种方法，第一种是模拟匹配 `2` 和 `5`，第二种是统计 `2` 和 `5` 的数量差。
   - **优点**：提供了两种不同的思路，代码实现较为详细。
   - **缺点**：第一种方法的时间复杂度较高，为 $O(n \times ans)$。
   - **评分**：3星

#### 最优关键思路

最优的思路是通过统计字符串中 `2` 和 `5` 的数量差，判断是否满足条件，并找出最大差值作为最小分解数。这种方法的时间复杂度为 $O(n)$，效率较高。

#### 关键代码实现

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int s,n,ans;
char a[3000];
int main(){
    scanf("%s",a);
    n=strlen(a);
    if(n&1){ //判断无解
        printf("-1");
        return 0;
    }
    for(int i=0;i<n;i++){
        s+=(a[i]=='2');
        s-=(a[i]=='5');
        if(s<0){ //判断无解
            printf("-1");
            return 0;
        }
        ans=max(s,ans);//区间最大值
    }
    printf("%d\n",ans);
    return 0;
}
```

#### 拓展思路

类似的问题可以扩展到其他字符串匹配问题，例如判断字符串是否可以分解为特定的模式串。这类问题通常可以通过统计字符数量或使用贪心算法来解决。

#### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)
3. [P3371 【模板】字符串的最小表示法](https://www.luogu.com.cn/problem/P3371)

这些题目都涉及到字符串的处理和匹配，可以帮助进一步理解和掌握相关算法。

---
处理用时：26.41秒
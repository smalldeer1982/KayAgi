# 题目信息

# North North West

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jag2014autumn/tasks/icpc2014autumn_a

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个由 `north` 和 `west` 组成的字符串，表示方向的组合。要求计算这些方向组合对应的角度，并输出最简分数形式的角度值。输入以 `#` 结束。

### 算法分类
模拟

### 题解分析与结论

#### 题解对比

1. **Nygglatho 的题解**
   - **思路**：从字符串的末尾开始遍历，根据 `north` 和 `west` 的出现情况，逐步计算分子和分母，最后进行约分。
   - **难点**：从右往左遍历字符串，并根据 `north` 和 `west` 的长度调整遍历指针。
   - **优化**：使用 `gcd` 函数进行约分，代码简洁。
   - **评分**：4星

2. **abensyl 的题解**
   - **思路**：与 Nygglatho 类似，但约分方法不同，利用分母为 $2^k$ 的特性，直接去除分子中的 $2$ 因子。
   - **难点**：同样需要从右往左遍历字符串，并根据 `north` 和 `west` 的长度调整遍历指针。
   - **优化**：约分方法独特，但代码稍显冗长。
   - **评分**：3星

3. **AirQwQ 的题解**
   - **思路**：从字符串的末尾开始遍历，根据 `north` 和 `west` 的出现情况，逐步计算分子和分母，最后进行约分。
   - **难点**：从右往左遍历字符串，并根据 `north` 和 `west` 的长度调整遍历指针。
   - **优化**：使用 `__gcd` 函数进行约分，代码简洁。
   - **评分**：4星

#### 最优关键思路
- **从右往左遍历字符串**：由于方向组合的顺序影响角度的计算，从右往左遍历可以更直观地处理方向组合的顺序。
- **逐步计算分子和分母**：根据 `north` 和 `west` 的出现情况，逐步更新分子和分母的值，最后进行约分。
- **约分技巧**：使用 `gcd` 或 `__gcd` 函数进行约分，确保输出为最简分数形式。

#### 可拓展之处
- **类似题目**：处理方向组合的题目，可以考虑从右往左遍历，逐步计算角度或位置。
- **算法套路**：模拟题中，处理顺序问题时常采用从右往左或从后往前的遍历方式，以确保逻辑的正确性。

### 推荐题目
1. [P1026 方向](https://www.luogu.com.cn/problem/P1026)
2. [P1027 方向2](https://www.luogu.com.cn/problem/P1027)
3. [P1028 方向3](https://www.luogu.com.cn/problem/P1028)

### 个人心得摘录
- **AirQwQ**：从后到前的顺序（因为这点我改了 $ 20 $ 分钟）。面对分数时，因为分母都是 $2^n$ 所以分子乘以二加减九十，分母直接乘以二就行啦。
- **Nygglatho**：从右往左读取的第一段其分子也需要乘以 $2^n$，第二段也要乘以 $2^{n - 1}$，以此类推，和原来加上或减去的分数相等。最后再约分一下就行。

### 核心代码片段
```cpp
// Nygglatho 的代码片段
for (t = str.size() - 1; t >= 0; ) {
    if (str[t] == 'h') ans = max(ans * 2 - 90, 0), t -= 5;
    else ans = max(ans * 2 + 90, 0), t -= 4;
    pw *= 2;
}
q = gcd(ans, pw);
fz = ans / q; fm = pw / q;
if (fm == 1) cout << fz << endl;
else cout << fz << '/' << fm << endl;
```

```cpp
// AirQwQ 的代码片段
for(;i>=0;){
    if(a[i]=='t'){
        fenz=fenz*2+90;
        fenm*=2;
        i-=4;
    }
    else{
        fenz=fenz*2-90;
        fenm*=2;
        i-=5;
    }
}
if(fenm==0)
    cout<<fenz<<endl;
else if(abs(fenm/__gcd(fenz,fenm))==1)
    cout<<abs(fenz/__gcd(fenz,fenm))<<endl;
else 
    cout<<abs(fenz/__gcd(fenz,fenm))<<'/'<<abs(fenm/__gcd(fenz,fenm))<<endl;
```

### 结论
Nygglatho 和 AirQwQ 的题解思路清晰，代码简洁，且都采用了从右往左遍历字符串的方法，逐步计算分子和分母，最后进行约分。推荐使用这两种方法来解决类似的方向组合问题。

---
处理用时：33.56秒
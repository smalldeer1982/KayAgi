# 题目信息

# Change a Password

## 题目描述

JAG 办公室的密码是一个由 $N$ 位数字组成的，会定期更改。密码修改规则如下。

1. 新密码的位数与旧密码的位数一样，均为 $N$ 位。同时，新密码的每一个数字最多出现 $1$ 次（旧密码可能存在重复的数字）。
2. 在上述约束下，使得新密码与旧密码的差异最大化（密码之间的差异的定义如下所述）。
3. 如果有两个或两个以上的新密码符合条件，选择最小的密码。

两个密码 $a,b$ 之间的差异是至指 $\min(\vert a-b\vert ,10^{N}-\vert a-b\vert )$，其中 $N$ 为密码的位数。例如，$11$ 和 $42$ 的差异为 $31$，$987$ 和 $012$ 的差异为 $25$。

# AI分析结果

### 题目内容重写
# 更改密码

## 题目描述

JAG 办公室的密码是一个由 $N$ 位数字组成的，会定期更改。密码修改规则如下。

1. 新密码的位数与旧密码的位数一样，均为 $N$ 位。同时，新密码的每一个数字最多出现 $1$ 次（旧密码可能存在重复的数字）。
2. 在上述约束下，使得新密码与旧密码的差异最大化（密码之间的差异的定义如下所述）。
3. 如果有两个或两个以上的新密码符合条件，选择最小的密码。

两个密码 $a,b$ 之间的差异是指 $\min(\vert a-b\vert ,10^{N}-\vert a-b\vert )$，其中 $N$ 为密码的位数。例如，$11$ 和 $42$ 的差异为 $31$，$987$ 和 $012$ 的差异为 $25$。

### 算法分类
深度优先搜索 (DFS)

### 题解分析与结论
两道题解均采用了深度优先搜索（DFS）的方法来枚举所有可能的新密码，并在满足条件的情况下选择与旧密码差异最大的密码。两者的核心思路相似，都是通过回溯来避免重复使用数字，并在搜索过程中更新最大差异值。

#### 题解1：sjr3065335594
- **星级**：4星
- **关键亮点**：
  - 使用了回溯法来枚举所有可能的密码组合。
  - 通过`bool b[15]`数组来标记数字是否被使用，避免重复。
  - 处理了前导零的问题，确保输出的密码位数正确。
  - 代码结构清晰，注释详细，便于理解。

#### 题解2：Nygglatho
- **星级**：4星
- **关键亮点**：
  - 同样使用回溯法，代码简洁明了。
  - 通过`q[i]`数组来标记数字是否被使用。
  - 在搜索过程中直接计算差异值，并更新最大差异值。
  - 代码逻辑清晰，易于实现。

### 最优关键思路或技巧
- **回溯法**：通过递归和回溯来枚举所有可能的密码组合，避免重复使用数字。
- **差异计算**：在搜索过程中计算新密码与旧密码的差异，并更新最大差异值。
- **前导零处理**：确保输出的密码位数正确，处理前导零的情况。

### 可拓展之处
- **剪枝优化**：在搜索过程中，可以加入剪枝策略，减少不必要的搜索，提高效率。
- **其他约束条件**：可以扩展题目，增加更多的约束条件，如密码必须包含某些特定数字等。

### 推荐题目
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)

### 个人心得摘录
- **sjr3065335594**：提到了处理前导零的问题，并详细解释了如何通过字符串处理来确保密码位数正确。
- **Nygglatho**：强调了回溯法的核心思想，并通过代码展示了如何实现这一过程。

### 核心代码片段
#### 题解1：sjr3065335594
```cpp
void find(ll n, int dep) {
    if(dep >= len) {
        if(min(abs(n-a), pow10(len) - abs(n-a)) > maxn)
            maxn = min(abs(n-a), pow10(len) - abs(n-a)), ans = n;
        return;
    }
    for(int i = 0;i <= 9;i++) {
        if(!b[i]) {
            b[i] = 1;
            find(n * 10 + i, dep + 1);
            b[i] = 0;
        }
    }
}
```

#### 题解2：Nygglatho
```cpp
void DFS(int t, long long p) {
    if (t == sz) {
        if (min(pw - abs(x - p), abs(x - p)) > maxx) {
            y = p;
            maxx = min(pw - abs(x - p), abs(x - p));
        }
    } else {
        for (int i = 0; i <= 9; ++i) {
            if (!q[i]) {
                q[i] = true;
                DFS(t + 1, p * 10 + i);
                q[i] = false;
            }
        }
    }
}
```

---
处理用时：28.23秒
# 题目信息

# Optimal Recommendations

## 题目描述

[problemUrl]: https://atcoder.jp/contests/indeednow-finala-open/tasks/indeednow_2015_finala_c

 求職者と求人会社のマッチングを手助けしている Indeed 社は、求職者に最適な求人を提示するサービスを開発することにした。  
 Indeed 社のデータベースには、独自テストで得られた、各求職者の技術力、語学力、コミュニケーション力が保存されている。  
 またそのデータベースには、各求人会社が応募条件として要求した、それら $ 3 $ つの力の最低限必要な値とその会社の年収も保存されている。  
 データベースのデータがすべて与えられるので、各求職者ごとに、その人が応募可能な会社の中で一番高い年収を示しなさい。

## 样例 #1

### 输入

```
3 6

1 2 3 3

3 3 3 6

4 4 4 8

3 4 3

4 4 4

100 100 1

2 3 4

0 0 0

100 100 100```

### 输出

```
6

8

0

3

0

8```

# AI分析结果

### 题目内容重写
**最优推荐**

**题目描述**

Indeed 公司正在开发一个帮助求职者找到最合适工作的服务。Indeed 公司的数据库中存储了每位求职者的技术力、语学力、沟通力，这些数据是通过公司内部的测试获得的。此外，数据库中还存储了每家公司在招聘时对这三项能力的最低要求以及该公司的年收入。给定数据库中的所有数据，请为每位求职者找到他们可以应聘的公司中，年收入最高的公司。

**样例 #1**

### 输入

```
3 6

1 2 3 3

3 3 3 6

4 4 4 8

3 4 3

4 4 4

100 100 1

2 3 4

0 0 0

100 100 100
```

### 输出

```
6

8

0

3

0

8
```

### 算法分类
**递推**

### 题解分析与结论
本题的核心在于如何高效地为每位求职者找到符合条件的公司中的最高年收入。由于数据范围较大（$N, M \le 50000$），直接暴力枚举会超时。因此，大多数题解采用了递推的方法，通过预处理来优化查询效率。

### 精选题解

#### 1. 作者：Struggle_ong (赞：4)
**星级：4**
**关键亮点：**
- 使用三维数组 `dp` 来存储每个能力组合的最大年收入。
- 通过三重循环递推，补全 `dp` 数组，确保每个 `dp[i][j][k]` 存储的是所有能力不超过 `(i, j, k)` 的公司中的最大年收入。
- 代码简洁，思路清晰。

**核心代码：**
```cpp
int dp[110][110][110];
int main() {
    int n, m, a, b, c, x, y, z, w;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a >> b >> c >> w;
        dp[a][b][c] = max(dp[a][b][c], w);
    }
    for (int i = 0; i <= 100; i++) {
        for (int j = 0; j <= 100; j++) {
            for (int k = 0; k <= 100; k++) {
                if (i != 0) dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j][k]);
                if (j != 0) dp[i][j][k] = max(dp[i][j - 1][k], dp[i][j][k]);
                if (k != 0) dp[i][j][k] = max(dp[i][j][k - 1], dp[i][j][k]);
            }
        }
    }
    for (int i = 1; i <= m; i++) {
        cin >> x >> y >> z;
        cout << dp[x][y][z] << '\n';
    }
    return 0;
}
```

#### 2. 作者：Symbolize (赞：4)
**星级：4**
**关键亮点：**
- 与 Struggle_ong 的思路类似，但使用了更详细的注释和状态转移方程的推导。
- 强调了从 0 开始循环时的边界处理。
- 代码可读性强，适合初学者理解。

**核心代码：**
```cpp
int f[105][105][105];
int main() {
    int n, m, a, b, c, x, y, z, w;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a >> b >> c >> w;
        f[a][b][c] = max(f[a][b][c], w);
    }
    for (int i = 0; i <= 100; i++) {
        for (int j = 0; j <= 100; j++) {
            for (int k = 0; k <= 100; k++) {
                if (i) f[i][j][k] = max(f[i][j][k], f[i - 1][j][k]);
                if (j) f[i][j][k] = max(f[i][j][k], f[i][j - 1][k]);
                if (k) f[i][j][k] = max(f[i][j][k], f[i][j][k - 1]);
            }
        }
    }
    for (int i = 1; i <= m; i++) {
        cin >> x >> y >> z;
        cout << f[x][y][z] << endl;
    }
    return 0;
}
```

#### 3. 作者：Nygglatho (赞：2)
**星级：3**
**关键亮点：**
- 提供了递推思路的详细证明，确保算法的正确性。
- 强调了代码的常数优化，避免 TLE。
- 代码实现较为复杂，适合有一定经验的程序员。

**核心代码：**
```cpp
int f[105][105][105];
int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        int x, y, z, w;
        cin >> x >> y >> z >> w;
        f[x][y][z] = max(f[x][y][z], w);
    }
    for (int i = 0; i <= 100; ++i) {
        for (int j = 0; j <= 100; ++j) {
            for (int k = 0; k <= 100; ++k) {
                if (i) f[i][j][k] = max(f[i - 1][j][k], f[i][j][k]);
                if (j) f[i][j][k] = max(f[i][j - 1][k], f[i][j][k]);
                if (k) f[i][j][k] = max(f[i][j][k - 1], f[i][j][k]);
            }
        }
    }
    for (int i = 1; i <= m; ++i) {
        int x, y, z;
        cin >> x >> y >> z;
        cout << f[x][y][z] << endl;
    }
}
```

### 最优关键思路
使用三维数组存储每个能力组合的最大年收入，并通过递推补全数组，确保每个 `dp[i][j][k]` 存储的是所有能力不超过 `(i, j, k)` 的公司中的最大年收入。这种方法将查询复杂度降低到 $O(1)$，非常适合大规模数据处理。

### 拓展思路
类似的问题可以通过预处理和递推来优化查询效率，尤其是在数据范围较大但查询条件有限的情况下。例如，在处理多维数据时，可以考虑使用多维数组进行预处理。

### 推荐题目
1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

---
处理用时：43.50秒
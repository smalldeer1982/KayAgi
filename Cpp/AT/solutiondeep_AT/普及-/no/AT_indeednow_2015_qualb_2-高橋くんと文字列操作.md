# 题目信息

# 高橋くんと文字列操作

## 题目描述

[problemUrl]: https://atcoder.jp/contests/indeednow-qualb/tasks/indeednow_2015_qualb_2

高橋くんは文字列 $ s $ を持っており、文字列 $ t $ を作りたいと思っています。 高橋くんは、文字列の末尾の $ 1 $ 文字を先頭に追加し、末尾の $ 1 $ 文字を削除するという操作を文字列 $ s $ に行うことで、文字列 $ s $ を文字列 $ t $ にしたいと考えています。

最小で何回この操作を行えば、文字列 $ s $ を文字列 $ t $ にできるでしょうか？最小の操作回数を出力するプログラムを書いてください。この操作では文字列 $ s $ を文字列 $ t $ に変換することができない場合、$ -1 $ と出力してください。

## 说明/提示

### Sample Explanation 1

`abcd` の末尾の文字を先頭に追加すると、 `dabcd` となり、ここから末尾の文字を削除すると、 `dabc` となります。 よって、$ 1 $ 回の操作で $ s $ は $ t $ に等しくなります。

### Sample Explanation 2

問題文中の操作を $ s $ に $ 2 $ 回行うと $ t $ と等しくなります。 $ 5 $ 回、$ 8 $ 回行っても $ t $ と等しくなりますが、最小のものを求める必要があります。

## 样例 #1

### 输入

```
abcd

dabc```

### 输出

```
1```

## 样例 #2

### 输入

```
abcabcabc

bcabcabca```

### 输出

```
2```

## 样例 #3

### 输入

```
aaa

a```

### 输出

```
-1```

## 样例 #4

### 输入

```
cab

cab```

### 输出

```
0```

# AI分析结果

### 题目内容重写

高橋くん有一个字符串 $s$，他希望通过一系列操作将其转换为字符串 $t$。每次操作，他可以将字符串 $s$ 的最后一个字符移动到最前面，并删除最后一个字符。请问最少需要多少次操作才能将 $s$ 转换为 $t$？如果无法通过操作将 $s$ 转换为 $t$，则输出 $-1$。

### 算法分类
字符串、模拟

### 题解分析与结论

题目要求通过特定的操作将字符串 $s$ 转换为字符串 $t$，操作次数最少。核心思路是通过模拟操作过程，逐步将 $s$ 转换为 $t$，并记录操作次数。如果操作次数超过字符串长度仍未匹配，则输出 $-1$。

### 所选高星题解

#### 题解1：作者：Fcersoka (赞：5)
**星级：4.5星**
**关键亮点：**
- 使用循环模拟操作过程，代码简洁易懂。
- 通过 `pd` 函数判断字符串是否匹配，逻辑清晰。
- 操作次数限制在字符串长度内，避免无限循环。

**核心代码：**
```cpp
void cz(){ //进行操作的函数
    char temp=a[a.length()-1];//先用一个字符变量储存字符串中最后一个字符
    for(int i=a.length()-1;i>=0;i--)
        swap(a[i],a[i+1]);//把第2个字符与倒数第2个字符之间的所有字符往后移
    a[0]=temp;//把最后一个字符放到第一个字符的位置
}
```

#### 题解2：作者：Blikewsr (赞：3)
**星级：4星**
**关键亮点：**
- 详细说明了操作步骤，代码结构清晰。
- 使用 `string_bool` 函数判断字符串是否相等，逻辑明确。
- 操作次数限制在字符串长度内，避免无限循环。

**核心代码：
```cpp
void string_do(){                                // 执行的函数                  
    for(int i=1;i<s1.size();i++){                // 最多只有 s1.size()-1 次操作             
        ans++;                                   // 操作次数加 1                
        c=s1[s1.size()-1];                       // 先把最后一个字符保存下来            
        for(int j=s1.size()-1;j>=0;j--)          // 最最后一字符开始直到第二个字符           
            s1[j]=s1[j-1];                       // 每个字符都改成它的前一个字符                      
        s1[0]=c;                                 // 再把第一个字符改成之前保存下来的字符                    
        if(string_bool(s1,s2)){                  // 判断两个字符串是否相同              
            cout<<ans<<'\n';                     // 如果一样 ， 就直接输出次数        
            return ;	                         // 并且结束                  
        }
    }
    cout<<(-1)<<'\n';                            // 其他的情况 ， 就说明无法完成 ， 就输出 -1                      
    return ;
}
```

#### 题解3：作者：Kevin_Zhen (赞：3)
**星级：4星**
**关键亮点：**
- 详细解释了操作过程，代码结构清晰。
- 使用 `insert` 和 `erase` 函数实现字符移动，代码简洁。
- 操作次数限制在字符串长度内，避免无限循环。

**核心代码：
```cpp
while (a != b && cnt < lena) {
    char t = a[lena - 1];
    a.insert(a.begin(), t);
    a.erase(a.end() - 1);
    ++cnt;
}
```

### 最优关键思路与技巧
- **模拟操作过程**：通过循环模拟每次操作，逐步将 $s$ 转换为 $t$。
- **操作次数限制**：操作次数限制在字符串长度内，避免无限循环。
- **字符串匹配判断**：通过逐个字符比较或直接比较字符串，判断是否匹配。

### 拓展思路
- **类似题目**：可以考虑其他字符串操作问题，如字符串旋转、字符串匹配等。
- **优化思路**：可以通过预处理或哈希表等方法优化字符串匹配过程，减少时间复杂度。

### 推荐题目
1. [P1032 字符串变换](https://www.luogu.com.cn/problem/P1032)
2. [P1090 字符串的展开](https://www.luogu.com.cn/problem/P1090)
3. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)

---
处理用时：24.58秒
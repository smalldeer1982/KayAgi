# 题目信息

# 通学経路

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2007yo/tasks/joi2007yo_f

太郎君の住んでいる JOI 市は，南北方向にまっすぐに伸びる $ a $ 本の道路と，東西方向にまっすぐに伸びる $ b $ 本の道路により，碁盤の目の形に区分けされている．

南北方向の $ a $ 本の道路には，西から順に $ 1,\ 2,\ \ldots,\ a $ の番号が付けられている．また，東西方向の $ b $ 本の道路には，南から順に $ 1,\ 2,\ \ldots,\ b $ の番号が付けられている．西から $ i $ 番目の南北方向の道路と，南から $ j $ 番目の東西方向の道路が交わる交差点を $ (i,\ j) $ で表す．

太郎君は，交差点 ($ 1,\ 1 $) の近くに住んでおり，交差点 ($ a,\ b $) の近くの JOI 高校に自転車で通っている．自転車は道路に沿ってのみ移動することができる．太郎君は，通学時間を短くするため，東または北にのみ向かって移動して通学している．

現在，JOI 市では，$ n $ 個の交差点 $ (x_1,\ y_1),\ (x_2,\ y_2),\ \ldots,\ (x_n,\ y_n) $ で工事を行っている．太郎君は工事中の交差点を通ることができない．

太郎君が交差点 $ (1,\ 1) $ から交差点 $ (a,\ b) $ まで，工事中の交差点を避けながら，東または北にのみ向かって移動して通学する方法は何通りあるだろうか．太郎君の通学経路の個数 $ m $ を求めるプログラムを作成せよ．

- - - - - -

## 说明/提示

### Sample Explanation 1

下図は $ a\ =\ 5,\ b\ =\ 4,\ n\ =\ 3 $ で，工事中の交差点が $ (2,\ 2),\ (2,\ 3),\ (4,\ 2) $ の場合を表している． !\[route-fig1.png\](https://img.atcoder.jp/joi2007yo/route-fig1.png) この場合，通学経路は $ m\ =\ 5 $ 通りある．$ 5 $ 通りの通学経路を全て図示すると，以下の通り． !\[route-fig2.png\](https://img.atcoder.jp/joi2007yo/route-fig2.png)

## 样例 #1

### 输入

```
5 4
3
2 2
2 3
4 2```

### 输出

```
5```

# AI分析结果

### 题目内容
太郎君住在JOI市，该市由南北方向的$a$条道路和东西方向的$b$条道路组成，形成了一个棋盘状的网格。南北方向的道路从西到东依次编号为$1, 2, \ldots, a$，东西方向的道路从南到北依次编号为$1, 2, \ldots, b$。交点$(i, j)$表示西起第$i$条南北道路与南起第$j$条东西道路的交点。

太郎君住在交点$(1, 1)$附近，每天骑自行车去交点$(a, b)$附近的JOI高中上学。自行车只能沿着道路移动，且太郎君只能向东或向北移动。目前，JOI市有$n$个交点$(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)$正在施工，太郎君无法通过这些交点。求太郎君从$(1, 1)$到$(a, b)$的合法路径数$m$。

### 算法分类
动态规划

### 题解分析与结论
本题的核心是动态规划，通过递推的方式计算从起点到终点的路径数。难点在于如何处理障碍点，并确保路径只能向东或向北移动。大多数题解都采用了类似的思路，即通过二维数组记录每个点的路径数，并根据是否遇到障碍点进行状态转移。

### 评分较高的题解

#### 1. 作者：ZnHF (4星)
**关键亮点**：
- 清晰的动态规划思路，状态转移方程明确。
- 代码简洁，易于理解。
- 通过二维数组`maze`标记障碍点，避免了重复计算。

**核心代码**：
```cpp
int n,m,a,maze[20][20],f[200][200];
int main(){
    cin>>n>>m>>a;
    int t1,t2;
    for(int i=0;i<a;i++){
        cin>>t1>>t2;
        maze[t1][t2]=-1;
    }
    f[1][1]=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(i!=1 && maze[i-1][j]!=-1) f[i][j]+=f[i-1][j];
            if(j!=1 && maze[i][j-1]!=-1) f[i][j]+=f[i][j-1];
        }
    }
    cout<<f[n][m]<<endl;
    return 0;
}
```

#### 2. 作者：朱屹帆 (4星)
**关键亮点**：
- 使用了`bool`数组标记障碍点，逻辑清晰。
- 递推式简洁，直接通过`if`语句判断是否遇到障碍点。
- 代码结构清晰，易于扩展。

**核心代码**：
```cpp
const long long N = 1e4+5;
long long s[N][N]; //记录方案数
bool judge[N][N]={false}; //判断障碍
long long a,b,n,x,y;
int main(){
    cin>>a>>b>>n;
    for(int i=1;i<=n;i++){
        cin>>x>>y;
        judge[x][y]=true; //设置障碍 
    }
    s[1][1]=1; //递推初始
    for(int i=1;i<=a;i++){
        for(int j=1;j<=b;j++){
            if(i==1&&j==1)continue; //(1,1)方案数1
            if(judge[i][j]==true)continue; //有障碍
            s[i][j]=(s[i][j-1]+s[i-1][j]); //递推式 
        }
    }
    cout<<s[a][b]<<endl; //输出答案
    return 0;
}
```

#### 3. 作者：Shadow_T (4星)
**关键亮点**：
- 使用了`bool`数组标记障碍点，逻辑清晰。
- 递推式简洁，直接通过`if`语句判断是否遇到障碍点。
- 代码结构清晰，易于扩展。

**核心代码**：
```cpp
int a,b,n,x,y,f[41][41];
bool st[41][41];
int main(){
    cin>>a>>b>>n;
    for(int i=0;i<n;i++){
        cin>>x>>y;
        st[x][y]=1;
    }
    f[0][1]=1;
    for(int i=1;i<=a;i++)
    for(int j=1;j<=b;j++)
    if(!st[i][j]) f[i][j]=f[i-1][j]+f[i][j-1];
    cout<<f[a][b]<<"\n";
    return 0;
}
```

### 最优关键思路
- **动态规划**：通过二维数组记录每个点的路径数，状态转移方程为`f[i][j] = f[i-1][j] + f[i][j-1]`，遇到障碍点时直接跳过。
- **障碍点处理**：使用`bool`数组或`int`数组标记障碍点，避免重复计算。
- **边界条件**：起点`(1, 1)`的路径数为1，遇到障碍点时路径数为0。

### 可拓展之处
- **类似题目**：如[P1002 过河卒](https://www.luogu.com.cn/problem/P1002)，同样是动态规划与障碍点处理的结合。
- **优化思路**：可以通过记忆化搜索或滚动数组优化空间复杂度。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1958 上学路径](https://www.luogu.com.cn/problem/P1958)
3. [P1191 矩形](https://www.luogu.com.cn/problem/P1191)

---
处理用时：31.44秒
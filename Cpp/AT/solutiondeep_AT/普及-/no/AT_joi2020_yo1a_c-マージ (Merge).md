# 题目信息

# マージ (Merge)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020yo1a/tasks/joi2020_yo1a_c

長さ $ N $ の正整数列 $ A=(A_1,\ A_2,\ \ldots,\ A_N) $ と，長さ $ M $ の正整数列 $ B=(B_1,\ B_2,\ \ldots,\ B_M) $ が与えられる． これらの数列は，共に広義単調増加数列である．つまり，$ A_1\ \leqq\ A_2\ \leqq\ \cdots\ \leqq\ A_N $, $ B_1\ \leqq\ B_2\ \leqq\ \cdots\ \leqq\ B_M $ を満たす．

以下のアルゴリズムを用いて，これらの数列から，長さ $ N+M $ の正整数列 $ C=(C_1,\ C_2,\ \ldots,\ C_{N+M}) $ を生成する．

1. はじめ $ C $ は空とする．
2. $ A $ と $ B $ がどちらも空の場合，終了する．
3. $ A $ と $ B $ のどちらかが空の場合，そうでない数列を $ t $ とおく．どちらも空でない場合，先頭の要素が小さい数列を $ t $ とおく．ただし，$ A $ と $ B $ の先頭の要素が同じ値のときは $ A $ を $ t $ とおく．
4. $ t $ の先頭の要素を $ C $ の末尾に追加する．
5. $ t $ の先頭の要素を削除する．
6. 2. に戻る．

広義単調増加な正整数列 $ A $, $ B $ が与えられたとき，このアルゴリズムにより生成される正整数列 $ C $ を出力するプログラムを作成せよ．

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 500 $．
- $ 1\ \leqq\ M\ \leqq\ 500 $．
- $ 1\ \leqq\ A_1\ \leqq\ A_2\ \leqq\ \cdots\ \leqq\ A_N\ \leqq\ 2000 $．
- $ 1\ \leqq\ B_1\ \leqq\ B_2\ \leqq\ \cdots\ \leqq\ B_M\ \leqq\ 2000 $．

### Sample Explanation 1

アルゴリズムを行う前，$ A=(1,2),\ B=(2) $ である． 以下のように数列 $ C $ が生成される． - 数列 $ A $ の先頭の要素は $ 1 $，数列 $ B $ の先頭の要素は $ 2 $ なので，数列 $ A $ の先頭の要素を数列 $ C $ に追加しこれを数列 $ A $ から削除する． - 数列 $ A $ の先頭の要素は $ 2 $，数列 $ B $ の先頭の要素は $ 2 $ なので，数列 $ A $ の先頭の要素を数列 $ C $ に追加しこれを数列 $ A $ から削除する． - 数列 $ A $ は空なので，数列 $ B $ の先頭の要素を数列 $ C $ に追加しこれを数列 $ B $ から削除する． - 数列 $ A $ も数列 $ B $ も空なので，アルゴリズムを終了する． アルゴリズムが終了した後，数列 $ C=(1,2,2) $ である．

## 样例 #1

### 输入

```
2 1

1 2

2```

### 输出

```
1

2

2```

## 样例 #2

### 输入

```
3 8

1 3 8

3 3 4 5 6 7 8 9```

### 输出

```
1

3

3

3

4

5

6

7

8

8

9```

# AI分析结果

### 题目内容重写

#### 题目描述

给定长度为 $N$ 的正整数序列 $A=(A_1,\ A_2,\ \ldots,\ A_N)$ 和长度为 $M$ 的正整数序列 $B=(B_1,\ B_2,\ \ldots,\ B_M)$。这两个序列都是广义单调递增的，即 $A_1\ \leqq\ A_2\ \leqq\ \cdots\ \leqq\ A_N$ 和 $B_1\ \leqq\ B_2\ \leqq\ \cdots\ \leqq\ B_M$。

使用以下算法生成一个长度为 $N+M$ 的正整数序列 $C=(C_1,\ C_2,\ \ldots,\ C_{N+M})$：

1. 初始时 $C$ 为空。
2. 如果 $A$ 和 $B$ 都为空，则结束。
3. 如果 $A$ 和 $B$ 中有一个为空，则将非空的序列设为 $t$。如果两个都不为空，则将先头元素较小的序列设为 $t$。如果 $A$ 和 $B$ 的先头元素相同，则将 $A$ 设为 $t$。
4. 将 $t$ 的先头元素添加到 $C$ 的末尾。
5. 删除 $t$ 的先头元素。
6. 返回步骤 2。

编写一个程序，根据给定的广义单调递增的正整数序列 $A$ 和 $B$，输出由该算法生成的正整数序列 $C$。

### 算法分类
排序

### 题解分析与结论

题目要求将两个已排序的序列合并为一个新的排序序列。虽然可以直接使用 `sort` 函数，但更高效的解法是利用双指针法，直接合并两个已排序的序列。大多数题解选择了直接使用 `sort` 函数，虽然简单但效率较低。少数题解尝试了其他方法，如冒泡排序，但效率同样不高。

### 评分较高的题解

#### 题解1：Ray662 (4星)
- **关键亮点**：使用 `vector` 容器，代码简洁，直接使用 `sort` 函数，虽然效率不高但代码可读性强。
- **代码核心**：
  ```cpp
  vector<int> v;
  _for (i, 1, n)  cin >> x, v.push_back(x);
  _for (i, 1, m)  cin >> x, v.push_back(x);
  sort(v.begin(), v.end());
  for (int i : v)  cout << i << endl;
  ```

#### 题解2：Colorful_Unicorn (4星)
- **关键亮点**：使用数组存储合并后的序列，代码清晰，直接使用 `sort` 函数，虽然效率不高但代码简洁。
- **代码核心**：
  ```cpp
  int n,m,a[1000005],b[1000005],c[1000005],cnt;
  for (int i=1;i<=n;i++) c[++cnt]=a[i];
  for (int i=1;i<=m;i++) c[++cnt]=b[i];
  sort(c+1,c+cnt+1);
  for (int i=1;i<=n+m;i++) cout << c[i] << "\n";
  ```

#### 题解3：Huhu12346 (4星)
- **关键亮点**：使用数组存储合并后的序列，代码简洁，直接使用 `sort` 函数，虽然效率不高但代码清晰。
- **代码核心**：
  ```cpp
  int ss[10005],n,m;
  for(int i=1;i<=n+m;i++) cin>>ss[i];
  sort(ss+1,ss+n+m+1);
  for(int i=1;i<=n+m;i++) cout<<ss[i]<<endl;
  ```

### 最优关键思路
使用双指针法直接合并两个已排序的序列，时间复杂度为 $O(N+M)$，效率最高。虽然大多数题解选择了直接使用 `sort` 函数，但双指针法更适合本题。

### 可拓展之处
类似的问题可以扩展到合并多个已排序的序列，或者处理更复杂的排序规则。双指针法在合并多个序列时仍然适用。

### 推荐题目
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：25.64秒
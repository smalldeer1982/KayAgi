# 题目信息

# 最長昇順連続部分列 (Longest Ascending Contiguous Subsequence)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020yo1c/tasks/joi2020_yo1c_c

長さ $ N $ の正整数列 $ A=(A_1,\ A_2,\ \ldots,\ A_N) $ が与えられる．正整数列 $ A $ の連続部分列の中で昇順に並んでいるもののうち，最長のものの長さを求めよ．

すなわち，$ A_l\ \leqq\ A_{l+1}\ \leqq\ \cdots\ \leqq\ A_r $ を満たすような $ 2 $ つの整数 $ l,\ r $ ( $ 1\ \leqq\ l\ \leqq\ r\ \leqq\ N $ ) について，$ r-l+1 $ の最大値を求めよ．

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 100 $．
- $ 1\ \leqq\ A_i\ \leqq\ 2020 $ ($ 1\ \leqq\ i\ \leqq\ N $)．

### Sample Explanation 1

正整数列 $ A $ の $ 4 $ 項目から $ 6 $ 項目までに対応する連続部分列は $ 1,\ 5,\ 9 $ であり，これは昇順である．これより長い昇順な連続部分列は存在しない．

### Sample Explanation 2

正整数列 $ A $ の $ 5 $ 項目から $ 6 $ 項目までに対応する連続部分列は $ 5,\ 5 $ であり，これは昇順である．これより長い昇順な連続部分列は存在しない．

## 样例 #1

### 输入

```
10

3 1 4 1 5 9 2 6 5 3```

### 输出

```
3```

## 样例 #2

### 输入

```
10

9 8 7 6 5 5 4 3 2 1```

### 输出

```
2```

## 样例 #3

### 输入

```
9

1 2 2 12 120 210 202 1010 2020```

### 输出

```
6```

# AI分析结果

### 题目内容重写

**最长升序连续子序列 (Longest Ascending Contiguous Subsequence)**

**题目描述**

给定一个长度为 $N$ 的正整数序列 $A=(A_1,\ A_2,\ \ldots,\ A_N)$，求该序列中连续子序列的最长升序长度。即找到满足 $A_l \leq A_{l+1} \leq \cdots \leq A_r$ 的两个整数 $l,\ r$（$1 \leq l \leq r \leq N$），使得 $r-l+1$ 最大。

**说明/提示**

**约束条件**

- $1 \leq N \leq 100$。
- $1 \leq A_i \leq 2020$（$1 \leq i \leq N$）。

**样例解释**

**样例1**

输入：

```
10
3 1 4 1 5 9 2 6 5 3
```

输出：

```
3
```

解释：序列中第4到第6个元素（1, 5, 9）是升序的，且没有更长的升序连续子序列。

**样例2**

输入：

```
10
9 8 7 6 5 5 4 3 2 1
```

输出：

```
2
```

解释：序列中第5到第6个元素（5, 5）是升序的，且没有更长的升序连续子序列。

**样例3**

输入：

```
9
1 2 2 12 120 210 202 1010 2020
```

输出：

```
6
```

### 算法分类

**枚举**

### 题解分析与结论

本题的核心是通过遍历数组，找到最长的连续升序子序列。两个题解都采用了类似的思路：遍历数组，记录当前升序子序列的长度，并在遇到降序时更新最大长度。

**题解1：封禁用户**

- **思路**：遍历数组，如果当前元素小于等于下一个元素，则增加当前升序子序列的长度；否则，更新最大长度并重置当前长度。
- **代码实现**：
  ```cpp
  for(int i=1;i<=n;i++)
  {
      if(a[i]<=a[i+1])
      {
          ans++;
      }
      else
      {
          maxx=max(maxx,ans+1);
          ans=0;
      }
  }
  ```
- **评分**：3星
- **亮点**：代码简洁，逻辑清晰。
- **不足**：未处理数组边界情况，可能导致越界。

**题解2：NOI_AK_dreeeam**

- **思路**：与题解1类似，但在数组末尾添加了一个哨兵元素，避免了边界处理问题。
- **代码实现**：
  ```cpp
  a[n+1]=a[n]-1; // 边界处理
  for(int i=1;i<=n;i++){
      sum++;
      if(a[i]>a[i+1]){
          ans=max(sum,ans);
          sum=0;
      }
  }
  ```
- **评分**：4星
- **亮点**：通过添加哨兵元素，避免了边界处理问题，代码更加健壮。
- **个人心得**：通过添加哨兵元素，简化了边界条件的处理，提高了代码的鲁棒性。

### 最优关键思路

- **哨兵元素**：在数组末尾添加一个哨兵元素，可以简化边界条件的处理，避免越界问题。
- **遍历与更新**：通过遍历数组，记录当前升序子序列的长度，并在遇到降序时更新最大长度。

### 可拓展之处

- **类似问题**：可以扩展到寻找最长降序连续子序列，或者寻找满足其他条件的连续子序列。
- **算法优化**：对于更大的数据集，可以考虑使用动态规划等更高效的算法。

### 推荐题目

1. **最长连续递增序列** - [LeetCode 674](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)
2. **最长递增子序列** - [LeetCode 300](https://leetcode.cn/problems/longest-increasing-subsequence/)
3. **最长连续序列** - [LeetCode 128](https://leetcode.cn/problems/longest-consecutive-sequence/)

### 结论

题解2通过添加哨兵元素，简化了边界条件的处理，代码更加健壮，值得推荐。对于类似问题，可以考虑使用类似的思路，通过遍历和更新来找到满足条件的连续子序列。

---
处理用时：24.73秒
# 题目信息

# 共通要素 (Common Elements)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2021yo1a/tasks/joi2021_yo1a_c

長さ $ N $ の整数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ と長さ $ M $ の整数列 $ B\ =\ (B_1,\ B_2,\ \ldots,\ B_M) $ が与えられる．$ A $ と $ B $ の両方に出現する整数をすべて，$ 1 $ 個ずつ昇順で出力せよ．

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 100 $．
- $ 1\ \leqq\ M\ \leqq\ 100 $．
- $ 1\ \leqq\ A_i\ \leqq\ 100 $ ($ 1\ \leqq\ i\ \leqq\ N $)．
- $ 1\ \leqq\ B_j\ \leqq\ 100 $ ($ 1\ \leqq\ j\ \leqq\ M $)．

### Sample Explanation 1

$ 6 $ は $ A $ の $ 3 $ 番目，$ B $ の $ 4 $ 番目に出現する．また，$ 12 $ は $ A $ の $ 6 $ 番目，$ B $ の $ 2 $ 番目に出現する．$ 6 $ と $ 12 $ 以外に $ A,\ B $ の両方に出現する整数は存在しない．したがって，$ 6,\ 12 $ を昇順に改行区切りで出力する．

### Sample Explanation 2

$ 100 $ は $ A,\ B $ の両方に出現する．$ 100 $ 以外に $ A,\ B $ に出現する整数は存在しない．したがって，$ 100 $ を出力する．

### Sample Explanation 3

$ A,\ B $ の両方に出現する整数は存在しない．したがって，何も出力しない．

## 样例 #1

### 输入

```
6 5

2 4 6 8 10 12

15 12 9 6 3```

### 输出

```
6

12```

## 样例 #2

### 输入

```
3 5

100 100 100

100 100 100 100 100```

### 输出

```
100```

## 样例 #3

### 输入

```
1 1

2

5```

### 输出

```
```

## 样例 #4

### 输入

```
10 10

76 91 98 7 98 7 98 10 63 91

70 71 10 10 91 70 65 10 63 76```

### 输出

```
10

63

76

91```

# AI分析结果

### 题目内容重写
# 共通要素 (Common Elements)

## 题目描述

给定长度为 $N$ 的整数列 $A\ =\ (A_1,\ A_2,\ \ldots,\ A_N)$ 和长度为 $M$ 的整数列 $B\ =\ (B_1,\ B_2,\ \ldots,\ B_M)$。输出 $A$ 和 $B$ 中共同出现的整数，每个整数只输出一次，并按升序排列。

## 说明/提示

### 制約

- $1\ \leqq\ N\ \leqq\ 100$．
- $1\ \leqq\ M\ \leqq\ 100$．
- $1\ \leqq\ A_i\ \leqq\ 100$ ($1\ \leqq\ i\ \leqq\ N$)．
- $1\ \leqq\ B_j\ \leqq\ 100$ ($1\ \leqq\ j\ \leqq\ M$)．

### 样例解释

**样例1**  
$6$ 在 $A$ 的第 $3$ 个位置和 $B$ 的第 $4$ 个位置出现。$12$ 在 $A$ 的第 $6$ 个位置和 $B$ 的第 $2$ 个位置出现。除了 $6$ 和 $12$，$A$ 和 $B$ 中没有其他共同出现的整数。因此，输出 $6$ 和 $12$，按升序排列。

**样例2**  
$100$ 在 $A$ 和 $B$ 中都出现。除了 $100$，$A$ 和 $B$ 中没有其他共同出现的整数。因此，输出 $100$。

**样例3**  
$A$ 和 $B$ 中没有共同出现的整数。因此，不输出任何内容。

### 算法分类
排序

### 题解分析与结论
本题的核心是找出两个数组中共同出现的元素，并按升序输出。由于数组长度和元素范围都很小，因此可以采用多种方法解决，包括桶排序、暴力枚举、双指针等。

### 所选高分题解
#### 1. 作者：Moon_Traveller (4星)
**关键亮点**：使用桶排序的思想，通过两个数组记录每个数字出现的次数，然后遍历1到100的范围，输出在两个数组中均出现的数字。代码简洁且高效。
**代码片段**：
```cpp
int visa[105], visb[105];
for(int i = 1; i <= n; i++) visa[a[i]]++;
for(int i = 1; i <= m; i++) visb[b[i]]++;
for(int i = 1; i <= 100; i++) {
    if(visa[i] >= 1 && visb[i] >= 1) cout << i << endl;
}
```

#### 2. 作者：wdgm4 (4星)
**关键亮点**：提供了三种解法，包括桶排序、暴力枚举和双指针。双指针解法在排序后通过移动指针来寻找共同元素，避免了重复遍历。
**代码片段**：
```cpp
sort(a+1, a+n+1);
sort(b+1, b+m+1);
int i=1, j=1;
while(i <= n && j <= m) {
    if(a[i] == b[j]) {
        if(!vis[a[i]]) cout << a[i] << endl;
        vis[a[i]] = 1;
        i++; j++;
    } else if(a[i] > b[j]) j++;
    else i++;
}
```

#### 3. 作者：NOI_AK_dreeeam (4星)
**关键亮点**：使用暴力枚举法，通过排序后遍历两个数组，找出共同元素，并使用一个数组记录是否已经输出过该元素，避免重复输出。
**代码片段**：
```cpp
sort(a+1, a+n+1);
sort(b+1, b+m+1);
for(int i=1; i<=n; i++) {
    for(int j=1; j<=m; j++) {
        if(a[i] == b[j] && !c[a[i]]) {
            cout << a[i] << "\n";
            c[a[i]] = 1;
        }
    }
}
```

### 最优关键思路或技巧
1. **桶排序**：利用数组记录每个数字出现的次数，适用于元素范围较小的情况。
2. **双指针**：在排序后通过移动指针来寻找共同元素，避免了重复遍历，适用于需要排序的场景。
3. **暴力枚举**：虽然时间复杂度较高，但在数据范围较小的情况下仍然可行，且代码实现简单。

### 可拓展之处
类似的问题可以扩展到更大的数据范围或更复杂的条件，如多个数组的交集、动态更新数组等。此时可以考虑使用哈希表或更高效的算法如二分查找。

### 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P2141 珠心算测验](https://www.luogu.com.cn/problem/P2141)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

---
处理用时：30.89秒
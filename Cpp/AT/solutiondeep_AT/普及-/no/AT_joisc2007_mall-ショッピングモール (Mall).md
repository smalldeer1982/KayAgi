# 题目信息

# ショッピングモール (Mall)

## 题目描述

### 题目简述

有一个 $n\times m$ 的网格 $c$，你需要在其中选择一个 $b\times a$ 的长方形（不可旋转），使得它满足：

- 长方形内任何一个格子里的数非负；
- 长方形内所有格子的数之和最小。

求出和的最小值。

## 说明/提示

#### 样例 #1 解释

$31+2+4+100+26+21=184$。

### 数据规模与约定

$1\le m,n\le 1000$，$1\le a,b\le 1000$，$-1\le c_{i,j}\le 100$。

# AI分析结果

### 题目内容重写

#### 题目描述

##### 题目简述

有一个 $n\times m$ 的网格 $c$，你需要在其中选择一个 $b\times a$ 的长方形（不可旋转），使得它满足：

- 长方形内任何一个格子里的数非负；
- 长方形内所有格子的数之和最小。

求出和的最小值。

#### 说明/提示

##### 样例 #1 解释

$31+2+4+100+26+21=184$。

##### 数据规模与约定

$1\le m,n\le 1000$，$1\le a,b\le 1000$，$-1\le c_{i,j}\le 100$。

### 算法分类

前缀和

### 题解分析与结论

所有题解均采用了二维前缀和的思路，通过预处理前缀和数组来快速计算任意子矩阵的和，并通过另一个数组记录负数的个数来判断子矩阵是否满足条件。这种方法的时间复杂度为 $O(nm)$，能够有效处理题目中的数据规模。

### 最优关键思路或技巧

1. **二维前缀和**：通过预处理二维前缀和数组，可以在 $O(1)$ 时间内计算任意子矩阵的和。
2. **负数判断**：通过另一个前缀和数组记录负数的个数，可以在 $O(1)$ 时间内判断子矩阵是否包含负数。
3. **枚举优化**：通过枚举所有可能的子矩阵，并结合前缀和快速计算和判断，最终找到满足条件的最小和。

### 推荐题目

1. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)
2. [P2280 [HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)
3. [P2216 [HAOI2007]理想的正方形](https://www.luogu.com.cn/problem/P2216)

### 题解评分与亮点

#### 题解1：作者：limbus (赞：3)

**评分：4星**

**关键亮点：**
- 详细解释了二维前缀和的推导公式。
- 代码清晰，注释详细，易于理解。
- 通过两个数组分别记录前缀和和负数个数，逻辑清晰。

**核心代码：**
```cpp
for(long long i = b; i <= m;i++) {
    for(long long j = a; j <= n;j++) {
        long long sum1 = sum[i][j] - sum[i][j - a] - sum[i - b][j] + sum[i - b][j - a];
        if(pos[i][j] - pos[i][j - a] - pos[i - b][j] + pos[i - b][j - a] == 0) {
            ans = min(sum1,ans);
        }
    }
}
```

#### 题解2：作者：Alice2012 (赞：1)

**评分：4星**

**关键亮点：**
- 使用了二维前缀和的模板，代码简洁。
- 通过两个数组分别记录前缀和和负数个数，逻辑清晰。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
for(int i=1;i+a-1<=n;i++){
    for(int j=1;j+b-1<=m;j++){
        int x=i+a-1,y=j+b-1;
        if(c[x][y]-c[x][j-1]-c[i-1][y]+c[i-1][j-1])continue;
        ans=min(ans,s[x][y]-s[x][j-1]-s[i-1][y]+s[i-1][j-1]);
    }
}
```

#### 题解3：作者：3Luby3 (赞：1)

**评分：4星**

**关键亮点：**
- 详细解释了二维前缀和的推导过程，适合初学者理解。
- 通过两个数组分别记录前缀和和负数个数，逻辑清晰。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
for(int i=b;i<=m;i++){
    for(int j=a;j<=n;j++){
        int fanwei=sum[i][j]-sum[i][j-a]-sum[i-b][j]+sum[i-b][j-a];
        if(sum2[i][j]-sum2[i][j-a]-sum2[i-b][j]+sum2[i-b][j-a]==0) minn=min(fanwei,minn);
    }
}
```

### 个人心得总结

- **调试经历**：在处理二维前缀和时，注意边界条件的处理，避免数组越界。
- **踩坑教训**：在计算子矩阵和时，确保前缀和公式的正确性，避免重复计算或遗漏。
- **顿悟感想**：通过预处理前缀和数组，可以大幅提升计算效率，适用于类似的大规模数据处理问题。

---
处理用时：27.49秒
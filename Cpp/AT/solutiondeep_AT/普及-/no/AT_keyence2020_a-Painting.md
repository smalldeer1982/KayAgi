# 题目信息

# Painting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/keyence2020/tasks/keyence2020_a

$ H $ 行 $ W $ 列の マス目があり、最初すべてのマスは白色です。

あなたは、このマス目に何回かペイント操作を施すことにしました。 $ 1 $ 回のペイント操作では、以下の $ 2 $ 種類の作業のうちいずれか $ 1 $ つが行えます。

- 行をひとつ選び、その行に含まれるマスをすべて黒く塗る。
- 列をひとつ選び、その列に含まれるマスをすべて黒く塗る。

黒く塗られているマスの個数が $ N $ 個以上となるようにするためには、最小で何回のペイント操作が必要ですか。 なお、制約の項で記述される条件のもとで、何回かペイント操作を行うことで 黒く塗られているマスの個数が $ N $ 個以上となるようにできることが保証されます。

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 100 $
- $ 1\ \leq\ W\ \leq\ 100 $
- $ 1\ \leq\ N\ \leq\ H\ \times\ W $
- 入力値はすべて整数である。

### Sample Explanation 1

「行をひとつ選び、その行に含まれるマスをすべて黒く塗る」という操作を異なる行に対して $ 1 $ 回ずつ、 合計 $ 2 $ 回行うことで、黒く塗られているマスの個数を $ 14 $ にできます。

## 样例 #1

### 输入

```
3

7

10```

### 输出

```
2```

## 样例 #2

### 输入

```
14

12

112```

### 输出

```
8```

## 样例 #3

### 输入

```
2

100

200```

### 输出

```
2```

# AI分析结果

### 题目翻译
#### 题目描述
有一个 $H$ 行 $W$ 列的网格，初始时所有格子都是白色的。你可以对这个网格进行若干次涂色操作。每次涂色操作可以选择以下两种操作之一：
1. 选择一行，将该行中的所有格子涂黑。
2. 选择一列，将该列中的所有格子涂黑。

为了使涂黑的格子数量至少为 $N$ 个，最少需要进行多少次涂色操作？在给定的约束条件下，保证通过若干次涂色操作可以使涂黑的格子数量达到 $N$ 个以上。

#### 说明/提示
##### 约束条件
- $1 \leq H \leq 100$
- $1 \leq W \leq 100$
- $1 \leq N \leq H \times W$
- 输入值均为整数。

##### 样例解释 1
通过选择两行进行涂色操作，可以将涂黑的格子数量增加到 14 个。

### 算法分类
贪心

### 题解分析与结论
该题的核心思路是通过贪心策略，每次选择涂色操作中能涂黑最多格子的行或列进行操作，从而在最少次数内达到目标。具体来说，每次选择行或列中较大的一个进行涂色，然后计算需要多少次操作才能达到或超过 $N$ 个涂黑的格子。

#### 最优关键思路
1. **贪心策略**：每次选择行或列中较大的一个进行涂色，确保每次操作能涂黑最多的格子。
2. **向上取整**：通过计算 $N / \max(H, W)$ 并向上取整，得到最少操作次数。

### 评分较高的题解
#### 题解1：作者：A_Đark_Horcrux (赞：5)
**星级**：★★★★★  
**关键亮点**：简洁明了地实现了贪心策略，代码简洁且高效。  
**核心代码**：
```cpp
#include<cstdio>
int main(){
    int a,b,n; scanf("%d %d %d",&a,&b,&n),printf("%d",n/(a>b?a:b)+(n%(a>b?a:b)!=0));
    return 0;
}
```
**实现思想**：通过比较行和列的大小，选择较大的一个进行涂色操作，然后计算需要多少次操作才能达到或超过 $N$ 个涂黑的格子。

#### 题解2：作者：xgwpp6710 (赞：0)
**星级**：★★★★  
**关键亮点**：通过向上取整的方式避免了使用 `if` 语句，代码简洁且高效。  
**核心代码**：
```cpp
#include<iostream>
using namespace std;
int main(){
    int a,b,c,d; cin>>a>>b>>c;
    d=max(a,b); 
    cout<<(c+d-1)/d; 
    return 0;
}
```
**实现思想**：通过 `(c + d - 1) / d` 的方式实现向上取整，避免了使用 `if` 语句，代码更加简洁。

#### 题解3：作者：WHJ___ (赞：0)
**星级**：★★★★  
**关键亮点**：通过手写 `max` 函数和快速读入函数，优化了代码的执行效率。  
**核心代码**：
```cpp
#include<bits/stdc++.h>
#define I long long
#define RI register int
#define il inline
#define INF 0x7fffffff
using namespace std;
const int N=1e+7;

il I Max(I a,I b){
    if(a>b)return a;
    else return b;
}

il I read(){
    I x=0,f=1;
    char c=0;
    while(!isdigit(c=getchar()))f-=(c=='-')*2;
    while(isdigit(c)){x=(x<<1)+(x<<3)+f*(c-48);c=getchar();}
    return x;
}

signed main()
{
    RI i,j;
    I paint=Max(read(),read());
    cout<<ceil(read()*1.0/paint);
    return 0;
}
```
**实现思想**：通过手写 `max` 函数和快速读入函数，优化了代码的执行效率，同时使用 `ceil` 函数实现向上取整。

### 扩展思路
该题的贪心策略可以推广到类似的问题中，例如在资源分配或任务调度中，每次选择能带来最大收益的操作，从而在最少步骤内达到目标。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---
处理用时：28.79秒
# 题目信息

# Robot Arms

## 题目描述

## 题意描述

有n个区间,第i个区间的范围是[ x[i]-l[i],x[i]+l[i] ]。要求选择若干区间使其不重叠。求最多可以选择多少区间。

## 说明/提示

1<=n<=100000

0<=x[i]<=1000000000(10亿)

0<l[i]<=1000000000

## 样例 #1

### 输入

```
4

2 4

4 3

9 3

100 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2

8 20

1 10```

### 输出

```
1```

## 样例 #3

### 输入

```
5

10 1

2 1

4 1

6 1

8 1```

### 输出

```
5```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

有n个区间，第i个区间的范围是[ x[i]-l[i],x[i]+l[i] ]。要求选择若干区间使其不重叠。求最多可以选择多少区间。

#### 说明/提示

1<=n<=100000

0<=x[i]<=1000000000(10亿)

0<l[i]<=1000000000

#### 样例 #1

##### 输入

```
4

2 4

4 3

9 3

100 5
```

##### 输出

```
3
```

#### 样例 #2

##### 输入

```
2

8 20

1 10
```

##### 输出

```
1
```

#### 样例 #3

##### 输入

```
5

10 1

2 1

4 1

6 1

8 1
```

##### 输出

```
5
```

### 算法分类
贪心

### 题解分析与结论

该题的核心思路是通过贪心算法选择尽可能多的不重叠区间。所有题解都采用了按区间的右端点进行排序的策略，以确保每次选择的区间右端点尽可能小，从而为后续选择留下更多空间。这种贪心策略的正确性在于，右端点较小的区间不会对后续区间的选择造成过多的限制。

### 所选高星题解

#### 题解1：作者：Astatinear (赞：4)

**星级：4星**

**关键亮点：**
- 思路清晰，直接指出按右端点排序的贪心策略。
- 代码简洁，结构体排序实现直观。

**核心代码：**
```cpp
struct node {
    int l, r;
    bool operator <(const node &n)const {
        return r < n.r; // 按照右端点进行排序
    }
} arr[100005];

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> x[i] >> p[i];
        arr[i].l = x[i] - p[i]; // 储存左端点
        arr[i].r = x[i] + p[i]; // 储存右端点
    }
    sort(arr + 1, arr + n + 1); // 排序
    int now = INT_MIN, ans = 0;
    for (int i = 1; i <= n; ++i) {
        if (arr[i].l >= now) // 判断是否可以放下这个区间
            ans++, now = arr[i].r;
    }
    cout << ans << endl; // 输出答案
}
```

#### 题解2：作者：幻之陨梦 (赞：4)

**星级：4星**

**关键亮点：**
- 详细解释了按右端点排序的原因，逻辑清晰。
- 代码实现简洁，使用了快速读入优化。

**核心代码：**
```cpp
struct node {
    int st, ed;
    bool operator < (const node &x)const {
        return ed < x.ed; // 按照右端点从小到大排序
    }
} a[100010];

int main() {
    n = read();
    for (int i = 0; i < n; i++) {
        int x = read(), l = read();
        a[i].st = x - l; // 左端点
        a[i].ed = x + l; // 右端点
    }
    sort(a, a + n); // 排序
    int t = a[0].ed, ans = 1;
    for (int i = 1; i < n; i++) {
        if (a[i].st >= t) { // 如果下一个区间的开头大于当前区间结尾
            ans++; // 计数器++
            t = a[i].ed; // 更新结束位置
        }
    }
    printf("%d\n", ans); // 输出答案
}
```

#### 题解3：作者：eEfiuys (赞：1)

**星级：4星**

**关键亮点：**
- 代码简洁，结构体排序实现直观。
- 详细解释了贪心策略的正确性。

**核心代码：**
```cpp
struct node {
    int a, b;
} s[N];

bool cmp(node x, node y) {
    return x.b < y.b; // 按照右端点排序
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x, l;
        cin >> x >> l;
        s[i].a = (x - l);
        s[i].b = (x + l);
    }
    sort(s + 1, s + n + 1, cmp); // 按照右端点排序
    int r = -1e9, ans = 0;
    for (int i = 1; i <= n; i++) {
        if (s[i].a >= r) { // 不重叠
            ans++;
            r = s[i].b;
        }
    }
    cout << ans;
}
```

### 最优关键思路或技巧
- **按右端点排序**：这是该题的核心贪心策略，确保每次选择的区间右端点尽可能小，从而为后续选择留下更多空间。
- **结构体排序**：通过结构体存储区间的左右端点，并重载比较运算符，简化排序过程。

### 可拓展之处
- **类似题目**：该题的贪心策略可以应用于其他需要选择不重叠区间的问题，如活动安排问题、任务调度问题等。

### 推荐题目
1. [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)
2. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：33.97秒
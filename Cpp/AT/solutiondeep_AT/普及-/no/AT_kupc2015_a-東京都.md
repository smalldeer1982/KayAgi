# 题目信息

# 東京都

## 题目描述

[problemUrl]: https://atcoder.jp/contests/kupc2015/tasks/kupc2015_a

KUPC2015は[東京](https://atnd.org/events/70910)と[京都](https://atnd.org/events/70909)の二箇所でオンサイトが開催されている． あなたはKUPCの告知を手伝うことにした． 英小文字からなる文字列が印字されたテープがある．あなたはこのテープを文字同士の間でのみ好きなだけ自由に切ってもよい． あなたは`tokyo`か`kyoto`のいずれかの文字列を含むテープをなるべくたくさん作りたい．ただし，一旦切ったテープを後でくっつけることはできないものとする． 作る事ができる`tokyo`もしくは`kyoto`を含むテープの数の最大値を出力せよ．

## 说明/提示

### Sample Explanation 1

`higashikyoto`と書かれたテープは`kyoto`を含んでいるので，そのまま切り分けなくても目的のテープが $ 1 $ つ得られる． `kupconsitetokyotokyoto`と書かれたテープを{`kupconsitetokyo`, `to`, `kyoto`}と切り分けると，目的のテープが $ 2 $ つ得られる． どう切り分けても目的のテープが得られない場合も存在しうる．

## 样例 #1

### 输入

```
3

higashikyoto

kupconsitetokyotokyoto

goodluckandhavefun```

### 输出

```
1

2

0```

# AI分析结果

### 题目内容重写

#### 题目描述

KUPC2015在东京和京都两地进行现场比赛。你需要帮助宣传KUPC。有一条印有英文字母的磁带，你可以在字符之间任意切割磁带。你希望尽可能多地制作包含“tokyo”或“kyoto”字符串的磁带。一旦切割，磁带不能重新拼接。输出可以制作的最大数量。

#### 样例解释

- 输入：`higashikyoto`，输出：`1`（因为包含“kyoto”）。
- 输入：`kupconsitetokyotokyoto`，输出：`2`（可以切割为`kupconsitetokyo`和`kyoto`）。
- 输入：`goodluckandhavefun`，输出：`0`（不包含“tokyo”或“kyoto”）。

### 算法分类

枚举

### 题解分析与结论

题目要求在一个字符串中找出所有不重叠的“tokyo”或“kyoto”子串，并统计其最大数量。所有题解都采用了枚举的思路，逐个字符检查是否匹配目标子串，并通过指针跳跃避免重复计数。

### 精选题解

#### 题解1：老彩笔（4星）

**关键亮点：**
- 使用两个布尔变量`c1`和`c2`来标记是否匹配“tokyo”或“kyoto”。
- 通过指针跳跃（`i+=4`）避免重复计数。
- 优化了判断条件，提前退出不匹配的情况。

**核心代码：**
```cpp
for(int i=0;i<s.length();i++) {
    if(i>s.length()-5)break;
    c1=0,c2=0;k=0;
    for(int j=i;j<i+5;j++) {
        if(s[j]!=s1[k])c1=1;
        if(s[j]!=s2[k])c2=1;
        if(c1&&c2)break;
        k++;
    }
    if(!c1) { ans++; i+=4; }
    else if(!c2) { ans++; i+=4; }
}
```

#### 题解2：Blue_wonders（4星）

**关键亮点：**
- 直接逐个字符检查是否匹配“tokyo”或“kyoto”。
- 通过指针跳跃（`j+=4`）避免重复计数。
- 代码简洁，易于理解。

**核心代码：**
```cpp
for(int j=0;j<p;j++) {
    if(s[j]=='t'&&s[j+1]=='o'&&s[j+2]=='k'&&s[j+3]=='y'&&s[j+4]=='o') {
        j=j+4; m++;
    } else if(s[j]=='k'&&s[j+1]=='y'&&s[j+2]=='o'&&s[j+3]=='t'&&s[j+4]=='o') {
        j=j+4; m++;
    }
}
```

#### 题解3：Siyuan（4星）

**关键亮点：**
- 使用`substr`函数截取子串进行匹配。
- 通过指针跳跃（`i+=4`）避免重复计数。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
for(int i=0;i<len;i++) {
    if((s[i]=='t'&&s[i+1]=='o'&&s[i+2]=='k'&&s[i+3]=='y'&&s[i+4]=='o')||(s[i]=='k'&&s[i+1]=='y'&&s[i+2]=='o'&&s[i+3]=='t'&&s[i+4]=='o')) {
        ans++; i+=4;
    }
}
```

### 最优关键思路

- **枚举匹配**：逐个字符检查是否匹配目标子串。
- **指针跳跃**：匹配成功后，指针跳跃以避免重复计数。
- **优化判断**：提前退出不匹配的情况，减少不必要的比较。

### 可拓展之处

类似的问题可以扩展到查找多个不同长度的子串，或者允许子串重叠的情况。可以进一步优化匹配算法，如使用KMP算法提高匹配效率。

### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3805 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3805)
3. [P3376 【模板】AC自动机（加强版）](https://www.luogu.com.cn/problem/P3376)

---
处理用时：26.33秒
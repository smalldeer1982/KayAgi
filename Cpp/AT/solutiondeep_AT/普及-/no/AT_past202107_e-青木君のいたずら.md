# 题目信息

# 青木君のいたずら

## 题目描述

有一个初始值为 $1$ 的变量 $x$，高桥决定进行 $30$ 次将 $x$ 乘以 $3$ 的操作。但是青木君却做了一个恶作剧。他选择了一个满足 $1\le k \le30$ 的整数 $k$，在高桥进行完第 $k$ 次操作后将 $x$ 加上了 $1$ 。直到高桥完成了全部操作后他才发现了不对劲。他想让你帮帮他，求出青木选择的 $k$ 的值是多少？但还有一种可能，那就是青木在高桥完成所有操作后直接把 $x$ 换成了另一个数。如果是这样，请输出 $-1$。

## 说明/提示

**数据规模与约定**

$1 \le n \le 10^{15}$，$n \neq 3^{30}$，且 $n$ 为整数。

## 样例 #1

### 输入

```
205894618879050```

### 输出

```
10```

## 样例 #2

### 输入

```
314159265358979```

### 输出

```
-1```

# AI分析结果

### 题目内容
# 青木君のいたずら

## 题目描述

有一个初始值为 $1$ 的变量 $x$，高桥决定进行 $30$ 次将 $x$ 乘以 $3$ 的操作。但是青木君却做了一个恶作剧。他选择了一个满足 $1\le k \le30$ 的整数 $k$，在高桥进行完第 $k$ 次操作后将 $x$ 加上了 $1$ 。直到高桥完成了全部操作后他才发现了不对劲。他想让你帮帮他，求出青木选择的 $k$ 的值是多少？但还有一种可能，那就是青木在高桥完成所有操作后直接把 $x$ 换成了另一个数。如果是这样，请输出 $-1$。

## 说明/提示

**数据规模与约定**

$1 \le n \le 10^{15}$，$n \neq 3^{30}$，且 $n$ 为整数。

## 样例 #1

### 输入

```
205894618879050```

### 输出

```
10```

## 样例 #2

### 输入

```
314159265358979```

### 输出

```
-1```

### 算法分类
数学

### 题解分析与结论
本题的核心思路是通过倒推法，从最终结果 $x$ 逐步还原操作过程，判断是否在某个步骤中加上了 $1$，并确定这个步骤的位置 $k$。如果无法还原到初始值 $1$，或者出现不符合条件的情况（如 $x \bmod 3 = 2$ 或多次 $x \bmod 3 = 1$），则输出 $-1$。

### 所选高分题解

#### 1. 作者：CleverRaccoon (5星)
**关键亮点**：
- 思路清晰，详细解释了倒推法的逻辑。
- 代码简洁，使用了标记变量 `flag` 来记录是否出现过 $x \bmod 3 = 1$ 的情况。
- 处理了所有可能的异常情况，如 $x \bmod 3 = 2$ 或多次 $x \bmod 3 = 1$。

**核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main() {
    ll x;
    cin >> x;
    bool flag = false;
    int ans = -1;
    for(int i = 30; i >= 1; --i, x /= 3) {
        if(x % 3 == 2) {
            puts("-1");
            return 0;
        }
        if(x % 3 == 1) {
            if(flag) {
                puts("-1");
                return 0;
            }
            ans = i;
            --x;
            flag = true;
        }
    }
    printf("%d", x == 1ll ? ans : -1);
    return 0;
}
```

#### 2. 作者：回声之歌 (4星)
**关键亮点**：
- 详细解释了倒推法的每一步逻辑，特别是如何处理 $x \bmod 3 = 1$ 的情况。
- 代码结构清晰，使用了 `exit(0)` 来提前结束程序，避免不必要的计算。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f;
long long x, ans;
int main() {
    scanf("%lld", &x);
    for (int i = 30; i >= 1; i--) {
        if (x % 3 == 2)printf("-1"), exit(0);
        else if (x % 3 == 1) {
            if (f)printf("-1"), exit(0);
            ans = i, f = 1, x--;
        }
        x /= 3;
    }
    if (x == 1)printf("%lld", ans);
    else printf("-1");
    return 0;
}
```

#### 3. 作者：Pink_Cut_Tree (4星)
**关键亮点**：
- 代码简洁，直接模拟了倒推过程。
- 使用了 `return 0` 来提前结束程序，避免了不必要的计算。

**核心代码**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
    bool flag=false;
    long long x; long long ans=-1;
    scanf("%lld",&x);
    for(long long i=30;i>=1;i--){
        if(x%3==2){
            printf("-1\n"); return 0;
        }
        else if(x%3==1){
            if(flag){
                printf("-1\n"); return 0;
            }
            ans=i; x--; flag=true;
        }
        x/=3;
    }
    if(x==1){
        printf("%lld",ans);
    }
    else{
        printf("-1\n");
    }
    return 0;
}
```

### 最优关键思路
- **倒推法**：从最终结果 $x$ 逐步除以 $3$，判断是否在某个步骤中加上了 $1$，并记录该步骤的位置 $k$。
- **异常处理**：如果 $x \bmod 3 = 2$ 或多次 $x \bmod 3 = 1$，则输出 $-1$。
- **标记变量**：使用 `flag` 来记录是否出现过 $x \bmod 3 = 1$ 的情况，确保只处理一次加 $1$ 的操作。

### 可拓展之处
- 类似的问题可以通过倒推法来解决，特别是涉及到多次操作后结果还原的问题。
- 可以扩展到其他进制或不同的操作序列，如乘 $2$ 或加 $2$ 等。

### 推荐题目
1. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)

### 个人心得
- **调试经历**：在处理 $x \bmod 3 = 1$ 的情况时，需要特别注意只处理一次，否则会导致错误结果。
- **顿悟感想**：倒推法在处理类似问题时非常有效，尤其是在操作步骤较多且需要还原的情况下。

---
处理用时：34.71秒
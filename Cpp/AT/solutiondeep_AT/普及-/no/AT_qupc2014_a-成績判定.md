# 题目信息

# 成績判定

## 题目描述

[problemUrl]: https://atcoder.jp/contests/qupc2014/tasks/qupc2014_a

あなたはある試験の採点者です。 この試験ではいくつかの科目が存在し、その科目のうち、既定の数の科目に合格すると、試験に合格できます。 この試験では合格人数が初めからきめられているため、科目の合格点を採点結果を見て調整しなければなりません。 調整は面倒なので、採点結果を入力すると合格点を表示するプログラムを作ることにしました。また、科目ごとに調整するのは面倒なので、すべておなじです。 合格人数が最低合格人数以上になる、最大の合格点を出力してください。 ある科目で合格するとは、獲得した点数が、合格点以上になることとします。 入力は以下の形式で与えられる。

> $ A $ $ B $ $ C $ $ D $ $ E_{(0,0)} $ ・・・・$ E_{(0,A-1)} $ ・ ・ ・ ・ $ E_{(C-1,0)} $ ・・・・$ E_{(C-1,A-1)} $

 科目数$ A $、 合格に必要な科目数$ B $、 人数$ C $、 最低合格人数$ D $、 また得点の表$ E_{(i,j)} $ $ E_{(i,j)} $は$ i $番目の人の、$ j $番目の科目についての得点である。 入力中は各変数はすべて整数である。また、以下の制約を満たす。 - $ 2≦A,C≦10 $
- $ 1≦B≦A $
- $ 1≦D≦C $
- $ 0≦E_{(i,j)}≦100 $
 
 調整した点数を整数１行で出力してください ```
<pre class="prettyprint linenums">
4 3 3 2
10 15 25 30
5 20 20 30
40 100 100 100
```

 ```
<pre class="prettyprint linenums">
20
```

# AI分析结果

### 题目翻译

你是一位老师。学校有一个规则：学生们考试时，只要有B门科目的成绩比分数线高或“卡在线上”就算OK了。但是这个考试OK的人数（D）被可恶的校长固定了，~~也就是说，总有点人OK不了~~，但是这个可恶的校长又脑子不好，不知道如果想让OK的人数大于等于D的话，那么制定的分数线应该是多少。于是请到了你这位又会编程又敬业的老师，让你编一个程序，输出这条难算的分数线。~~其实不难，就是枚举~~

### 输入格式
```
A B C D E
E[0][0] E[0][1] ... E[0][A-1]
E[1][0] E[1][1] ... E[1][A-1]

***

E[C-1][0] E[C-1][1] ... E[C-1][A-1]
```
A：科目数 B：上面解释过 C：总人数 D：前面也解释过，~~仔细看！~~

### 输出格式
```
Answer
```

### 样例数据
```
4 3 3 2
10 15 25 30
5 20 20 30
40 100 100 100
```
```
20
```

### 数据范围
$2≦A,C≦10$

$1≦B≦A$

$1≦D≦C$

$0≦E[i][j]≦100$

### 算法分类
排序、枚举

### 题解分析与结论

题目要求找到一个最大的分数线，使得至少有D个人在B门科目上达到或超过该分数线。由于数据范围较小，可以采用枚举或排序的方法来解决。

#### 题解对比
1. **MZY666的题解**：通过对每个学生的成绩进行排序，找到每个学生达到合格要求的最低分数，再对这些分数进行排序，找到第D大的分数。思路清晰，代码简洁。
2. **MarchKid_Joe的题解**：从100到0枚举分数线，计算每个分数线下合格的人数，找到第一个满足条件的分数线。虽然思路简单，但效率较低。
3. **Edmundino的题解**：通过排序找到每个学生第B大的分数，再对这些分数进行排序，找到第D大的分数。思路与MZY666类似，但代码实现稍有不同。

#### 最优思路
最优思路是通过排序找到每个学生第B大的分数，再对这些分数进行排序，找到第D大的分数。这种方法时间复杂度较低，且代码实现简洁。

#### 关键代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int e[15],maxi[15];
int main(){
    int a,b,c,d,i,j;
    scanf("%d%d%d%d",&a,&b,&c,&d);
    for(i=1;i<=c;i++){
        for(j=1;j<=a;j++)scanf("%d",&e[j]);
        sort(e+1,e+a+1);
        maxi[i]=e[a-b+1];
    }
    sort(maxi+1,maxi+c+1);
    printf("%d\n",maxi[c-d+1]);
    return 0;
}
```

#### 拓展思路
类似的问题可以扩展到更大规模的数据，此时可以考虑使用二分查找来优化枚举的效率。

#### 推荐题目
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
2. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

#### 个人心得
MZY666提到“由于作者自愿禁言了，如果有建议请私信。否则将**无法**回复您哦！”，这表明作者在解题过程中可能遇到了一些沟通上的问题，提醒我们在解题时要注意细节和沟通。

---
处理用时：22.50秒
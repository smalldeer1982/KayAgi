# 题目信息

# Sushi 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/s8pc-5/tasks/s8pc_5_a

E869120 は, AtCoder 回転寿司という店に行った.  
 この店には, $ N $ 個の寿司がある. 寿司にはそれぞれ $ 1,\ 2,\ 3,\ \cdots,\ N $ の番号がつけられている. 寿司 $ i $ は, 彼が来店してから $ a_i+kT $ 秒後 ($ k $ は $ 0 $ 以上の整数) のみに取ることができる.

彼は, 寿司 $ 1 $ → 寿司 $ 2 $ → … → 寿司 $ N $ という順番で食べたいと思っている. しかし, 彼は貪欲なので, 寿司を一度取ってしまうとすぐに食べてしまう. 彼が $ N $ 個の寿司を食べ終わるまで, 来店してから最短何秒かかるか求めよ. ただし, 寿司を取る時間・食べる時間は無視して良いものとし, 彼は来店して $ 0 $ 秒後に来る寿司も取ることができるものとする.

## 说明/提示

### 制約

- $ N $ は $ 1 $ 以上 $ 100 $ 以下の整数.
- $ T $ は $ 1 $ 以上 $ 100 $ 以下の整数.
- $ a_i $ は $ 0 $ 以上 $ T-1 $ 以下の整数 $ (1\ \leq\ i\ \leq\ N) $.
- $ 1\ \leq\ i\ <\ j\ \leq\ N $ に対し, $ a_i\ \neq\ a_j $.

### 小課題

小課題 $ 1 $ \[$ 100 $ 点\]

- $ N\ =\ 1 $.

小課題 $ 2 $ \[$ 100 $ 点\]

- 追加の制約はない.

### Sample Explanation 1

この場合, 寿司 $ 1 $ は来店してから $ 4,\ 10,\ 16,\ 22,\ 28,\ \cdots $ 秒後に取ることができる. 一番早いのは $ 4 $ 秒後である.

### Sample Explanation 2

寿司 $ 1,\ 2,\ 3 $ をそれぞれ $ 3,\ 7,\ 12 $ 秒後に取るのが最短である.

## 样例 #1

### 输入

```
1 6

4```

### 输出

```
4```

## 样例 #2

### 输入

```
3 10

3 7 2```

### 输出

```
12```

## 样例 #3

### 输入

```
6 15

8 6 9 1 2 0```

### 输出

```
45```

# AI分析结果

### 题目翻译
E869120 去了一个名为 AtCoder 的旋转寿司店。这家店有 $N$ 种寿司。每个寿司都被标记了从 $1$ 到 $N$ 的编号。寿司 $i$ 只能在他来到店里的时候，以及他来到店里的 $a_i+kT$ 秒后 ($k\geq 0$) 才能取。

他想要按照从寿司 $1$ 到寿司 $N$ 的顺序来吃寿司。但是他很贪心，所以他一旦拿到寿司，就会立刻把它吃掉。请计算他至少需要多久才能吃完 $N$ 种寿司。注意，您可以忽略获取和吃掉寿司所需的时间，并认为他可以在来到店里的 $0$ 秒就拿起寿司。

### 算法分类
模拟

### 题解分析与结论
这道题的核心思路是通过模拟来计算按顺序吃寿司的最短时间。由于寿司的取用时间必须按照顺序递增，因此需要计算每个寿司的取用时间，并确保后一个寿司的取用时间不小于前一个寿司的取用时间。大多数题解都采用了统计逆序对的方法来计算所需的 $k$ 值，最终输出 $a_n + kT$。

### 精选题解
#### 题解1：作者：__UrFnr__ (赞：4)
**星级：4.5**
**关键亮点：**
- 简洁明了地解释了逆序对的概念，并将其与题目中的 $k$ 值联系起来。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, t, a[110], ans;
signed main () {
    cin >> n >> t;
    for (int i = 1; i <= n; i ++) 
        cin >> a[i];
    for (int i = 1; i < n; i ++) 
        if (a[i] > a[i + 1]) 
            ans ++;
    cout << a[n] + ans * t;
}
```

#### 题解2：作者：__XU__ (赞：3)
**星级：4.0**
**关键亮点：**
- 详细解释了逆序对的计算过程，并提供了代码实现。
- 代码中使用了 `cmp` 函数来比较寿司的取用时间，增加了代码的可读性。

**核心代码：**
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=105;
int n,t;
int cnt,sum;
int a[N];
bool cmp(int a,int b){
	if(a<b){
		return true;
	}
	else{
		return false;
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);//加速 
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		if(cmp(a[i],a[i-1])==true){
			cnt++;
		}
		sum=cnt*t;
	}
	cout<<sum+a[n];
	return 0;
}
```

#### 题解3：作者：goIdie (赞：2)
**星级：4.0**
**关键亮点：**
- 简洁地解释了逆序对的概念，并直接应用于代码中。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,a[101],sum;
int main(){
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
		if(a[i]>a[i+1]){
			sum++;
		}
	}
	cout<<a[n]+t*sum;
}
```

### 最优关键思路或技巧
- **逆序对统计**：通过统计数组中逆序对的数量，可以快速计算出所需的 $k$ 值，从而简化问题。
- **模拟过程**：通过模拟寿司的取用过程，确保后一个寿司的取用时间不小于前一个寿司的取用时间。

### 可拓展之处
- **类似问题**：类似的问题可以出现在需要按顺序处理事件，并且每个事件的处理时间有周期性限制的场景中。
- **算法优化**：可以进一步优化逆序对的计算方法，例如使用归并排序来统计逆序对的数量。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得
- **调试经历**：在调试过程中，发现逆序对的计算是关键，确保每个寿司的取用时间不小于前一个寿司的取用时间。
- **顿悟感想**：通过逆序对的概念，可以快速计算出所需的 $k$ 值，从而简化问题。

---
处理用时：28.45秒
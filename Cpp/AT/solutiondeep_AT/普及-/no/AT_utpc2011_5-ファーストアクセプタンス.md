# 题目信息

# ファーストアクセプタンス

## 题目描述

# 问题描述

你参加了一个编程比赛，一共有 $N$ 题。你解决第 $i$ 个问题需要 $A_{i}$ 分钟，而别人则需要 $B_{i}$ 分钟。现在你需要安排你的做题顺序，使得拿到题目的一血数量最多(即第一个完成)。注意，当你开始做一道题，你就只能做这道题直到解决。最后只要给出最多一血数即可。

## 说明/提示

-  $1 \le N \le 1000$ 

-  $1 \le A_{i},B_{i} \le 10^{6}(1 \le i \le N)$ 

感谢@常暗踏阴 提供的翻译

# AI分析结果

### 题目重写

**题目描述**

你参加了一个编程比赛，一共有 $N$ 题。你解决第 $i$ 个问题需要 $A_{i}$ 分钟，而别人则需要 $B_{i}$ 分钟。现在你需要安排你的做题顺序，使得拿到题目的一血数量最多（即第一个完成）。注意，当你开始做一道题，你就只能做这道题直到解决。最后只要给出最多一血数即可。

**说明/提示**

- $1 \le N \le 1000$
- $1 \le A_{i},B_{i} \le 10^{6}(1 \le i \le N)$

### 算法分类

贪心

### 题解分析与结论

本题的核心是通过贪心策略来最大化一血数量。各题解的思路基本一致，主要区别在于实现细节和代码风格。以下是各题解的要点和难点对比：

1. **btng_smith666** 的题解使用了 `vector` 和 `priority_queue` 来实现贪心策略，思路清晰，代码可读性较好。通过排序和优先队列来动态调整做题顺序，确保一血数量最大化。
2. **千城_Dhmc** 的题解提供了两种实现方式，一种是直接排序后比较，另一种是使用优先队列。两种方法都较为简洁，但第一种方法的代码略显冗余。
3. **eEfiuys** 的题解与 **btng_smith666** 的思路类似，但代码更为简洁，直接使用 `pair` 和 `priority_queue` 来实现。
4. **Buried_Dream** 的题解思路较为简单，直接排序后比较，但未使用优先队列，导致代码不够优化。
5. **jijidawang** 的题解引入了动态规划的思路，虽然理论上可行，但实现复杂度较高，且代码未完全展示。
6. **奆奆的蒟蒻** 的题解使用了 Perl 语言，代码简洁但可读性较差，且未详细解释算法思路。

### 评分较高的题解

1. **btng_smith666** (★★★★☆)
   - **关键亮点**：使用 `vector` 和 `priority_queue` 实现贪心策略，代码清晰，思路明确。
   - **代码核心**：
     ```cpp
     sort(v.begin(),v.end());
     for(int i=0;i<n;i++) {
         tmp+=v[i].second;
         p.push(v[i].second);
         if(tmp>v[i].first) {
             tmp-=p.top();
             p.pop();
         }
     }
     printf("%d\n",p.size());
     ```

2. **eEfiuys** (★★★★☆)
   - **关键亮点**：代码简洁，直接使用 `pair` 和 `priority_queue` 实现贪心策略。
   - **代码核心**：
     ```cpp
     sort(p+1,p+n+1);
     for(int i=1;i<=n;i++) {
         tim+=p[i].a;
         q.push(p[i].a);
         if(tim>p[i].b) {
             tim-=q.top();
             q.pop();
         }
     }
     cout<<q.size()<<endl;
     ```

3. **千城_Dhmc** (★★★☆☆)
   - **关键亮点**：提供了两种实现方式，代码较为简洁，但第一种方法略显冗余。
   - **代码核心**：
     ```cpp
     sort(b,b+n,cmp);
     sort(a,a+n);
     for(int i=0;i<n;i++) {
         if(a[i]<=b[i]) {
             cnt++;
         }
     }
     cout<<cnt<<endl;
     ```

### 最优关键思路

1. **贪心策略**：通过排序和优先队列来动态调整做题顺序，确保一血数量最大化。
2. **数据结构**：使用 `vector` 和 `priority_queue` 来高效管理做题顺序和时间。

### 拓展思路

类似的问题可以扩展到其他资源分配或任务调度场景，如任务调度中的最小化总完成时间或最大化资源利用率等。

### 推荐题目

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

---
处理用时：25.56秒
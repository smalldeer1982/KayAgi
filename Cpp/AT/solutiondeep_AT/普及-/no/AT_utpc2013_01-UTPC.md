# 题目信息

# UTPC

## 题目描述

### 题目背景
鳗鱼王国的国王计划举办一场名为 Unagi The synthesis Programming Contest（简称UTPC）的比赛。因此，国王征集了一个很酷的 UTPC 标志。然而，国王的眼睛非常不好，只能通过字母中孔的数量来区分字符串。
给定一个由大写字母组成且长度为 $4$ 的字符串 $s$。回答 $s$ 是否与字符串"UTPC"在“孔的数量意义上相等”。"孔的数量意义上相等"指的是，对应位置的 $2$ 个字母的孔的数量相等。其中，孔的数量为 $0$ 的字母是 `CEFGHIJKLMNSTUVWXYZ`，孔的数量为 $1$ 的字母是 `ADOPQR`，孔的数量为 $2$ 的字母是 `B`。

## 样例 #1

### 输入

```
KUPC
```

### 输出

```
yes
```

## 样例 #2

### 输入

```
UTPC
```

### 输出

```
yes
```

## 样例 #3

### 输入

```
UTBC
```

### 输出

```
no
```

# AI分析结果

【题目内容】
# UTPC

## 题目描述

### 题目背景
鳗鱼王国的国王计划举办一场名为 Unagi The synthesis Programming Contest（简称UTPC）的比赛。因此，国王征集了一个很酷的 UTPC 标志。然而，国王的眼睛非常不好，只能通过字母中孔的数量来区分字符串。
给定一个由大写字母组成且长度为 $4$ 的字符串 $s$。回答 $s$ 是否与字符串"UTPC"在“孔的数量意义上相等”。"孔的数量意义上相等"指的是，对应位置的 $2$ 个字母的孔的数量相等。其中，孔的数量为 $0$ 的字母是 `CEFGHIJKLMNSTUVWXYZ`，孔的数量为 $1$ 的字母是 `ADOPQR`，孔的数量为 $2$ 的字母是 `B`。

## 样例 #1

### 输入

```
KUPC
```

### 输出

```
yes
```

## 样例 #2

### 输入

```
UTPC
```

### 输出

```
yes
```

## 样例 #3

### 输入

```
UTBC
```

### 输出

```
no
```

【算法分类】
模拟

【题解分析与结论】
本题的核心逻辑是通过模拟字母的孔数来判断字符串是否与"UTPC"在孔数意义上相等。题解主要集中在如何高效地判断每个字母的孔数，并与"UTPC"对应位置的字母孔数进行比较。

【评分较高的题解】

1. **作者：LiveZoom (赞：3)**
   - **星级：4**
   - **关键亮点：**
     - 使用数组打表，高效存储每个字母的孔数。
     - 代码简洁，逻辑清晰，直接比较输入字符串与"UTPC"的孔数。
   - **核心代码：**
     ```cpp
     int a[26] = {1,2,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0};
     string s = "UTPC";
     int main() {
         for (int i = 0; i < 4; i++) {
             char c = getchar();
             if (a[c - 'A'] != a[s[i] - 'A']) {puts("no"); return 0;}
         }
         puts("yes");
         return 0;
     }
     ```

2. **作者：EtOH_Lewis (赞：0)**
   - **星级：4**
   - **关键亮点：**
     - 使用数组打表，并通过函数返回字母的孔数，代码结构清晰。
     - 直接比较输入字符串与"UTPC"的孔数，逻辑简单明了。
   - **核心代码：**
     ```cpp
     int a[27]={1,2,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0};
     int dong(char x) {
         return a[int(x-65)];
     }
     int main() {
         string s;cin>>s;
         if(dong(s[0])==0 && dong(s[1])==0 && dong(s[2])==1 && dong(s[3])==0)
             cout<<"yes"<<endl;
         else cout<<"no"<<endl;
     }
     ```

3. **作者：Dream_hjf (赞：0)**
   - **星级：4**
   - **关键亮点：**
     - 使用数组打表，并通过数组存储每个字母的孔数，逻辑清晰。
     - 直接比较输入字符串与"UTPC"的孔数，代码简洁。
   - **核心代码：**
     ```cpp
     int a[26]={1,2,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0};
     int main(){
         string d;getline(cin,d);
         int cnt[4]={0};
         for(int i=0;i<4;++i) cnt[i]+=a[d[i]-'A'];
         if(cnt[2]==1&&cnt[0]==0&&cnt[1]==0&&cnt[3]==0) cout<<"yes"<<endl;
         else cout<<"no"<<endl;
         return 0;
     }
     ```

【最优关键思路或技巧】
- **打表法**：通过数组存储每个字母的孔数，可以快速查询和比较，提高代码效率。
- **直接比较**：逐个比较输入字符串与"UTPC"对应位置的字母孔数，逻辑简单明了。

【可拓展之处】
- 类似题目可以扩展到更长的字符串或不同的孔数规则，打表法依然适用。
- 可以进一步优化代码，如使用位运算或更高效的数据结构来存储和查询孔数。

【推荐题目】
1. P1042 字符统计
2. P1056 字符串的展开
3. P1061 字符串的展开

【个人心得摘录】
- **LiveZoom**：打表法是最直接和高效的方式，避免了复杂的判断逻辑。
- **Dream_hjf**：注意题目要求每个字母的孔数都要与"UTPC"对应，不能只比较总和。

---
处理用时：29.53秒
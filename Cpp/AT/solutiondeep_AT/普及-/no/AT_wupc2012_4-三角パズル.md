# 题目信息

# 三角パズル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/wupc2012/tasks/wupc2012_4

 そうこうしているうちに，圧縮ファイルの解凍が終わったようだ．中を見ると，今度は直角三角形状に並んだ数列を含むテキストファイルを見つけた．  
  
 7  
 2 3  
 1 5 4  
  
 どうやら，一番上の頂点からはじめて，一段下の直下か右下かを選び底辺まで下っていったとき，その経路中の数値の合計の最大値を求める問題のようだ．それなら簡単．上の例の場合，7 -&gt; 3 -&gt; 5 と選ぶのが最適で，合計は 15 となる．しかし，このようなファイルはたくさんあり，中には100段に及ぶデータもあった．これを解かなきゃ参加資格はないってことか…？  
 いやまて，これはプログラミングコンテストへの招待状だ．数列を入力として与えた時，最大値を求めるプログラムを作ってしまえばいい．おそらく，招待状を送った人物はそれを期待している．  
 以下のように直角三角形上に並んだ数列が与えられる．頂点から初めて一段下の直下か右下を選び，底辺まで下ったときの経路中の数値の合計の最大値を求めよ．  
 例えば，以下のような数列が与えられたとすると，  
  
 3  
 7 4  
 2 4 6  
 8 5 9 3  
  
 正しく選択した場合，  
  
**3**  
**7** 4  
 2 **4** 6  
 8 5 **9** 3  
  
 であり，合計値は 3 + 7 + 4 + 9 = 23 となる． 入力は以下の形式で標準入力から与えられる．

> $ N $ $ a_{1,1} $ $ a_{2,1}　a_{2,2} $ $ a_{3,1}　a_{3,2}　a_{3,3} $ $ ... $ $ a_{i,1}　a_{i,2}　...　a_{i,i} $ $ ... $ $ a_{N,1}　a_{N,2}　...　a_{N,N} $

- $ 1 $ 行目には直角三角形の高さ $ N $($ 1\ ≦\ N\ ≦\ 100 $) が与えられる．
- $ i $ 行目($ 2\ ≦\ i\ ≦\ N+1 $)には数字が半角スペース区切りで $ i-1 $ 個与えられる．
- 数列に含まれる数は $ 0\ ≦\ a_{i,j}\ ≦\ 100 $($ 1\ ≦\ j\ ≦\ i\ ≦\ N $) を満たす．
 
 数値の合計の最大値を標準出力に $ 1 $ 行で出力せよ．  
 100点満点中，50点分については，$ N\ ≦\ 20 $ を満たす．

# AI分析结果

### 题目内容重写

【题目描述】

在解压文件的过程中，发现了一个包含直角三角形状排列的数列的文本文件。例如：

```
7  
2 3  
1 5 4  
```

从最上面的顶点开始，每次可以选择向下或向右下移动，直到到达底边。求经过路径中数值之和的最大值。例如，上面的例子中，选择 `7 -> 3 -> 5` 是最优路径，和为 15。

然而，这样的文件有很多，有些甚至包含 100 层的数列。这似乎是编程竞赛的邀请函，要求编写一个程序，输入数列后输出最大路径和。

输入格式如下：

> $ N $ $ a_{1,1} $ $ a_{2,1}　a_{2,2} $ $ a_{3,1}　a_{3,2}　a_{3,3} $ $ ... $ $ a_{i,1}　a_{i,2}　...　a_{i,i} $ $ ... $ $ a_{N,1}　a_{N,2}　...　a_{N,N} $

- 第 1 行给出三角形的高度 $ N $（$ 1\ ≦\ N\ ≦\ 100 $）。
- 第 $ i $ 行（$ 2\ ≦\ i\ ≦\ N+1 $）给出 $ i-1 $ 个数字，用空格分隔。
- 数列中的数字满足 $ 0\ ≦\ a_{i,j}\ ≦\ 100 $（$ 1\ ≦\ j\ ≦\ i\ ≦\ N $）。

输出最大路径和。

### 算法分类
动态规划

### 题解分析与结论

该题的核心思路是使用动态规划（DP）来求解最大路径和。从三角形的顶部开始，逐层向下计算每个位置的最大路径和，最终在底层找到最大值。

### 所选题解

#### 题解作者：_Qer (赞：2)
- **星级：4星**
- **关键亮点**：
  - 使用动态规划从顶部到底部逐层计算每个位置的最大路径和。
  - 代码简洁，逻辑清晰，易于理解。
  - 通过 `maxn[i][j] = max(maxn[i-1][j], maxn[i-1][j-1]) + num[i][j]` 实现核心 DP 逻辑。

```cpp
#include<bits/stdc++.h>
using namespace std;
int num[1010][1010],n;
int maxn[1010][1010];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=i;++j){
            scanf("%d",&num[i][j]);
            maxn[i][j]=-1;
            if(i==1){
                maxn[i][j]=num[i][j];
                break;
            }
            maxn[i][j]=max(maxn[i-1][j],maxn[i-1][j-1])+num[i][j];
        }
    }
    int ans=-1;
    for(int i=1;i<=n;++i){
        ans=max(ans,maxn[n][i]);
    }
    cout<<ans<<endl;
    return 0;
}
```

### 关键思路与技巧
- **动态规划**：从顶部开始，逐层计算每个位置的最大路径和，最终在底层找到最大值。
- **状态转移方程**：`maxn[i][j] = max(maxn[i-1][j], maxn[i-1][j-1]) + num[i][j]`，表示当前位置的最大路径和为其正上方和左上方路径和中的较大值加上当前位置的值。

### 可拓展之处
- 类似的问题可以扩展到其他形状的路径问题，如矩形网格中的最大路径和。
- 可以尝试使用滚动数组优化空间复杂度。

### 推荐题目
1. [P1216 数字三角形](https://www.luogu.org/problemnew/show/P1216)
2. [P1002 过河卒](https://www.luogu.org/problemnew/show/P1002)
3. [P1048 采药](https://www.luogu.org/problemnew/show/P1048)

---
处理用时：22.93秒
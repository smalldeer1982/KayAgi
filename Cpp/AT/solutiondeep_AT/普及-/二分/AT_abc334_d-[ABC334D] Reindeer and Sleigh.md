# 题目信息

# [ABC334D] Reindeer and Sleigh

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_d

$ N $ 台のソリがあり、各ソリには $ 1,2,\ldots,\ N $ の番号がつけられています。

ソリ $ i $ を引くために必要なトナカイは $ R_i $ 匹です。

また、各トナカイが引けるソリは高々 $ 1 $ 台です。より厳密には、$ m $ 台のソリ $ i_1,\ i_2,\ \ldots,\ i_m $ を引くために必要なトナカイは $ \sum_{k=1}^{m}\ R_{i_k} $ 匹です。

以下の形式のクエリが $ Q $ 個与えられるので、答えを求めてください。

- 整数 $ X $ が与えられる。トナカイが $ X $ 匹いるときに最大で何台のソリを引けるか求めよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ R_i\ \leq\ 10^9 $
- $ 1\ \leq\ X\ \leq\ 2\ \times\ 10^{14} $
- 入力される数値はすべて整数
 
### Sample Explanation 1

トナカイが $ 16 $ 匹いるとき、ソリ $ 1,2,4 $ を引くことができます。 $ 16 $ 匹のトナカイで $ 4 $ 台のソリを引くことはできないので、クエリ $ 1 $ の答えは $ 3 $ となります。

## 样例 #1

### 输入

```
4 3

5 3 11 8

16

7

1000```

### 输出

```
3

1

4```

## 样例 #2

### 输入

```
6 6

1 2 3 4 5 6

1

2

3

4

5

6```

### 输出

```
1

1

2

2

2

3```

## 样例 #3

### 输入

```
2 2

1000000000 1000000000

200000000000000

1```

### 输出

```
2

0```

# AI分析结果

### 题目内容重写

#### [ABC334D] 驯鹿与雪橇

**题目描述**

有 $N$ 台雪橇，每台雪橇编号为 $1,2,\ldots,N$。拉第 $i$ 台雪橇需要 $R_i$ 只驯鹿。每只驯鹿最多只能拉一台雪橇。更严格地说，拉 $m$ 台雪橇 $i_1, i_2, \ldots, i_m$ 需要 $\sum_{k=1}^{m} R_{i_k}$ 只驯鹿。

给定 $Q$ 个查询，每个查询给出一个整数 $X$，表示有 $X$ 只驯鹿，问最多能拉多少台雪橇。

**说明/提示**

- $1 \leq N, Q \leq 2 \times 10^5$
- $1 \leq R_i \leq 10^9$
- $1 \leq X \leq 2 \times 10^{14}$
- 所有输入均为整数

**样例 #1**

输入：
```
4 3
5 3 11 8
16
7
1000
```
输出：
```
3
1
4
```

**样例 #2**

输入：
```
6 6
1 2 3 4 5 6
1
2
3
4
5
6
```
输出：
```
1
1
2
2
2
3
```

**样例 #3**

输入：
```
2 2
1000000000 1000000000
200000000000000
1
```
输出：
```
2
0
```

### 题解分析与结论

#### 综合分析

所有题解的核心思路都是基于贪心算法和二分查找。具体步骤如下：

1. **排序**：将雪橇所需的驯鹿数量从小到大排序。
2. **前缀和**：计算排序后的数组的前缀和，方便快速查询。
3. **二分查找**：对于每个查询，使用二分查找在前缀和数组中找到最后一个小于等于 $X$ 的位置，即为最多能拉的雪橇数量。

#### 最优关键思路

- **贪心策略**：为了最大化拉雪橇的数量，优先选择所需驯鹿数量较少的雪橇。
- **前缀和优化**：通过前缀和数组快速计算前 $k$ 台雪橇所需的驯鹿总数。
- **二分查找**：利用二分查找在 $O(\log N)$ 时间内找到最大满足条件的雪橇数量。

#### 推荐题解

1. **作者：xz001**
   - **星级**：4.5
   - **关键亮点**：代码简洁，思路清晰，使用了标准库函数进行排序和二分查找，代码可读性高。
   - **核心代码**：
     ```cpp
     sort(a + 1, a + n + 1);
     for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + a[i];
     while (q--) {
         int x;
         scanf("%lld", &x);
         int l = 0, r = n, ans;
         while (l <= r) {
             int mid = (l + r) >> 1;
             if (sum[mid] <= x) {
                 ans = mid;
                 l = mid + 1;
             } else {
                 r = mid - 1;
             }
         }
         printf("%lld\n", ans);
     }
     ```

2. **作者：CheZiHe929**
   - **星级**：4.5
   - **关键亮点**：使用了 `upper_bound` 函数进行二分查找，代码简洁且高效。
   - **核心代码**：
     ```cpp
     sort(r + 1, r + n + 1);
     for (int i = 1; i <= n; i++) r[i] += r[i - 1];
     while (q--) {
         cin >> x;
         int ans = upper_bound(r + 1, r + n + 1, x) - r - 1;
         cout << ans << endl;
     }
     ```

3. **作者：aaron0919**
   - **星级**：4
   - **关键亮点**：代码结构清晰，使用了模板函数进行输出，便于调试和扩展。
   - **核心代码**：
     ```cpp
     sort(a + 1, a + 1 + n);
     for (int i = 1; i <= n; i++) a[i] += a[i - 1];
     while (q--) {
         cin >> x;
         int l = 0, r = n;
         while (l < r) {
             int mid = (l + r + 1) / 2;
             if (a[mid] <= x) l = mid;
             else r = mid - 1;
         }
         out(l);
     }
     ```

### 拓展思路与推荐题目

- **拓展思路**：类似的问题可以扩展到其他资源分配问题，如背包问题、任务调度等。贪心算法和二分查找的结合在这些问题中也有广泛应用。
- **推荐题目**：
  1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
  2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
  3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

这些题目都涉及到资源的最优分配，可以通过类似的贪心策略和二分查找进行优化。

---
处理用时：43.34秒
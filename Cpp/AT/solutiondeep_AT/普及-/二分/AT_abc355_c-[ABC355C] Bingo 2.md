# 题目信息

# [ABC355C] Bingo 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc355/tasks/abc355_c

縦 $ N $ 行、横 $ N $ 列のマス目があり、上から $ i $ 行目、左から $ j $ 列目のマスには整数 $ N\times\ (i-1)+j $ が書かれています。

今から $ T $ ターンにわたって相異なる整数が宣言されます。$ i $ ターン目には $ A_i $ が宣言され、$ A_i $ が書かれたマスに印をつけます。初めてビンゴを達成するのは何ターン目か求めてください。ただし、$ T $ ターンの中でビンゴを達成しない場合は `-1` を出力してください。

ここで、ビンゴを達成するとは以下のいずれかのうち少なくとも一つ満たされることを言います。

- マス目の横の列であって、列に含まれる $ N $ 個のマスすべてに印がついているものが存在する
- マス目の縦の列であって、列に含まれる $ N $ 個のマスすべてに印がついているものが存在する
- マス目の対角線の列であって、列に含まれる $ N $ 個のマスすべてに印がついているものが存在する

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 2\times\ 10^3 $
- $ 1\leq\ T\leq\ \min(N^2,2\times\ 10^5) $
- $ 1\leq\ A_i\leq\ N^2 $
- $ i\neq\ j $ ならば $ A_i\neq\ A_j $
- 入力は全て整数
 
### Sample Explanation 1

マス目の状態は以下のように変化します。初めてビンゴを達成するのは $ 4 $ ターン目です。 !\[\](https://img.atcoder.jp/abc355/85614db45da7c299bcc5551fc45092a7.png)

### Sample Explanation 2

$ 5 $ ターンの中でビンゴを達成できないので `-1` を出力してください。

## 样例 #1

### 输入

```
3 5

5 1 8 9 7```

### 输出

```
4```

## 样例 #2

### 输入

```
3 5

4 2 9 7 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 12

13 9 6 5 2 7 16 14 8 3 10 11```

### 输出

```
9```

# AI分析结果

### 题目内容重写
题目描述：给定一个 $N \times N$ 的网格，从上到下第 $i$ 行，从左到右第 $j$ 列的格子中写有整数 $N \times (i-1) + j$。接下来进行 $T$ 次操作，每次操作给定一个整数 $A_i$，并将网格中对应数字的格子标记。要求找出第一次满足“Bingo”条件的操作次数，若没有则输出 `-1`。

“Bingo”条件定义为：
- 某一行所有格子均被标记。
- 某一列所有格子均被标记。
- 某条对角线所有格子均被标记。

### 题解分析与结论
通过对多条题解的分析，主要思路可以分为以下几类：
1. **暴力模拟**：每次操作后检查所有行、列、对角线是否满足条件，时间复杂度较高，不适用于大规模数据。
2. **二分查找**：通过二分查找最小的操作次数，每次检查是否满足条件，时间复杂度为 $O(N^2 \log T)$。
3. **优化统计**：通过维护每行、每列、对角线的标记数量，每次操作后仅更新相关统计量，时间复杂度为 $O(T)$。

### 精选题解
#### 1. **题解作者：XXh0919**
- **星级**：★★★★★
- **关键亮点**：通过维护每行、每列、对角线的标记数量，每次操作后仅更新相关统计量，时间复杂度为 $O(T)$，适合大规模数据。
- **核心代码**：
```cpp
int n,t,a[N],h[N],l[N],x1,x2;
signed main(){
    ios::sync_with_stdio(0);
    cin>>n>>t;
    rep(i,1,n)h[i]=l[i]=n;
    x1=x2=n;
    rep(i,1,t){
        cin>>a[i];
        int ll=a[i]%n;
        ll==0?ll=n:ll=ll;
        int hh=(a[i]-ll)/n+1;
        --h[hh];
        --l[ll];
        if(ll==hh)--x1;
        if(ll+hh==n+1)--x2;
        if(!x1||!x2||!h[hh]||!l[ll]){
            cout<<i<<endl;
            return 0;
        }
    }
    cout<<-1<<endl;
    return 0;
}
```
- **个人心得**：通过观察发现，每次操作后只需更新相关行、列、对角线的统计量，避免了不必要的重复检查，大大提高了效率。

#### 2. **题解作者：MinimumSpanningTree**
- **星级**：★★★★
- **关键亮点**：通过维护每行、每列、对角线的标记数量，每次操作后仅更新相关统计量，时间复杂度为 $O(T)$，代码简洁易读。
- **核心代码**：
```cpp
int n,t,a,cx[N],cy[N],dg1,dg2,x,y;
int main(){
    scanf("%d%d",&n,&t);
    for(int i=1;i<=t;i++){
        scanf("%d",&a);
        x=(a-1)/n+1,y=a%n;
        if(!y) y=n;
        cx[x]++,cy[y]++;
        if(x==y) dg1++;
        if(x+y==n+1) dg2++;
        if(cx[x]==n||cy[y]==n||dg1==n||dg2==n) {
            printf("%d",i);
            return 0;
        }
    }
    printf("-1");
    return 0;
}
```
- **个人心得**：通过简单的数学公式快速定位数字对应的行和列，减少了计算量，代码实现简洁高效。

#### 3. **题解作者：I_Love_DS**
- **星级**：★★★★
- **关键亮点**：通过二分查找最小的操作次数，每次检查是否满足条件，时间复杂度为 $O(N^2 \log T)$，适合中等规模数据。
- **核心代码**：
```cpp
bool check(int x){
    for(int i=1;i<=n;i++){
        bool flag=true;
        for(int j=1;j<=n;j++){
            if(wrt[i][j]>x||wrt[i][j]==0){
                flag=false;
                break;
            }
        }
        if(flag) return true;
    }
    // 检查列和对角线...
}
```
- **个人心得**：通过二分查找优化了暴力模拟的时间复杂度，虽然不如直接统计高效，但在中等规模数据下表现良好。

### 最优关键思路
1. **优化统计**：通过维护每行、每列、对角线的标记数量，每次操作后仅更新相关统计量，时间复杂度为 $O(T)$，适合大规模数据。
2. **二分查找**：通过二分查找最小的操作次数，每次检查是否满足条件，时间复杂度为 $O(N^2 \log T)$，适合中等规模数据。

### 拓展思路
1. **类似题目**：可以考虑扩展到更高维度的网格，或者更复杂的标记规则。
2. **算法套路**：类似的问题可以通过维护统计量来优化时间复杂度，避免不必要的重复计算。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

---
处理用时：51.63秒
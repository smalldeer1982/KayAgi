# 题目信息

# [ABC358D] Souvenirs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc358/tasks/abc358_d

AtCoder Land のお土産屋に $ N $ 個の箱が売られています。

箱には $ 1,\ 2,\ \ldots,\ N $ の番号が付いており、箱 $ i $ の価格は $ A_i $ 円であり、$ A_i $ 個のお菓子が入っています。

高橋君は $ N $ 個の箱のうち $ M $ 個の箱を選んで買って帰り、$ 1,\ 2,\ \ldots,\ M $ の名前が付いた $ M $ 人の人に $ 1 $ つずつ箱を渡そうとしています。

ただし、高橋君は以下の条件を満たすことができるように箱を買いたいです。

- 各 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、人 $ i $ には $ B_i $ 個以上のお菓子が入った箱を渡す
 
$ 1 $ 人に $ 2 $ 個以上の箱を渡すことや同じ箱を複数人に渡すことはできないことに注意してください。

適切に箱を $ M $ 個買うことで条件を満たすことができるか判定し、条件を満たすことができる場合は高橋君が支払う金額の合計の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

高橋君は箱 $ 1,\ 4 $ を買い、箱 $ 1 $ を人 $ 1 $、箱 $ 4 $ を人 $ 2 $ に渡すことで条件を満たすことができます。 このとき高橋君が支払う金額の合計は $ 7 $ 円であり、支払う金額が $ 7 $ 円未満のときは条件を満たすことはできないため、$ 7 $ を出力します。

## 样例 #1

### 输入

```
4 2

3 4 5 4

1 4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3

1 1 1

1000000000 1000000000 1000000000```

### 输出

```
-1```

## 样例 #3

### 输入

```
7 3

2 6 8 9 5 1 11

3 5 7```

### 输出

```
19```

# AI分析结果

### 题目内容重写
AtCoder Land 的纪念品店有 $N$ 个盒子出售。盒子编号为 $1,\ 2,\ \ldots,\ N$，盒子 $i$ 的价格为 $A_i$ 元，并且里面有 $A_i$ 个糖果。高桥君想从这 $N$ 个盒子中选出 $M$ 个盒子买回家，并将这些盒子分别送给 $1,\ 2,\ \ldots,\ M$ 这 $M$ 个人。每个人 $i$ 必须得到一个至少有 $B_i$ 个糖果的盒子。注意，不能将同一个盒子给多个人，也不能给一个人多个盒子。请判断是否能够满足条件，如果可以，输出高桥君需要支付的最小金额；否则输出 `-1`。

### 题解分析与结论
这些题解大多采用了贪心策略，结合排序和双指针或二分查找来解决问题。主要思路是先将盒子和需求分别排序，然后为每个需求找到满足条件的最小盒子，确保总花费最小。难点在于如何高效地找到满足条件的盒子，同时避免重复使用。

### 精选题解

#### 题解1：stripe_python (5星)
**关键亮点**：
- 使用 `std::multiset` 来存储盒子，利用其自动排序和快速查找的特性。
- 通过 `lower_bound` 快速找到满足条件的最小盒子，并删除已使用的盒子，避免重复。
- 代码简洁高效，时间复杂度为 $O(m \log n)$。

**核心代码**：
```cpp
multiset<int> st;
for (int i = 1; i <= n; i++) st.emplace(a[i]);
long long tot = 0;
for (int i = 1; i <= m; i++) {
    auto it = st.lower_bound(b[i]);
    if (it == st.end()) return cout << -1, 0;
    tot += *it;
    st.erase(it);
}
cout << tot;
```

#### 题解2：luukluuk (4星)
**关键亮点**：
- 使用二分查找结合倍增法来找到满足条件的盒子，避免重复使用。
- 通过 `vis` 数组记录盒子的使用情况，确保每个盒子只被使用一次。
- 时间复杂度为 $O(n \log n)$，代码实现较为复杂但思路清晰。

**核心代码**：
```cpp
int k = lower_bound(a + 1, a + 1 + n, b[i]) - a;
int t = 1;
while (vis[k] && t) {
    while (t && vis[k + t] == 0) t >>= 1;
    k += t;
    t <<= 1;
}
if (vis[k]) k++;
if (k == n + 1) { ans = -1; break; }
ans += a[k];
vis[k] = 1;
```

#### 题解3：Cosine_Func (4星)
**关键亮点**：
- 采用二分查找结合贪心策略，确保每次找到满足条件的最小盒子。
- 代码简洁，时间复杂度为 $O(n \log n)$，适合初学者理解。
- 强调了开 `long long` 的重要性，避免溢出问题。

**核心代码**：
```cpp
sort(a + 1, a + 1 + n);
sort(b + 1, b + 1 + m);
for (int i = 1; i <= m; i++) {
    int k = lower_bound(a + 1, a + 1 + n, b[i]) - a;
    if (k == n + 1) { ans = -1; break; }
    ans += a[k];
    a[k] = -1; // 标记已使用
}
```

### 最优关键思路
1. **贪心策略**：为每个需求找到满足条件的最小盒子，确保总花费最小。
2. **排序与查找**：通过排序和二分查找或双指针来高效找到满足条件的盒子。
3. **避免重复使用**：通过删除或标记已使用的盒子，确保每个盒子只被使用一次。

### 可拓展之处
- 类似问题可以扩展到其他资源分配场景，如任务调度、资源分配等。
- 可以使用其他数据结构如优先队列来优化查找过程。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得摘录
- **stripe_python**：使用 `multiset` 的自动排序和快速查找功能，大大简化了代码实现。
- **Cosine_Func**：强调了开 `long long` 的重要性，避免因溢出导致的错误。
- **luukluuk**：通过倍增法优化查找过程，确保在复杂情况下仍能高效找到满足条件的盒子。

---
处理用时：40.28秒
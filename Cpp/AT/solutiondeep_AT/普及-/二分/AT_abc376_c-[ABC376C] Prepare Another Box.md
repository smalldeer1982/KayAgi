# 题目信息

# [ABC376C] Prepare Another Box

## 题目描述

有 $N$ 个玩具，编号从 $1$ 到 $N$ ，以及 $N-1$个箱子，编号从 $1$ 到 $N-1$。玩具 $i$ 的大小为$A_i$，箱子 $i$ 的大小为$B_i$。高桥君想把所有玩具分别放入不同的箱子中。他计划按以下步骤操作：

- 选择任意正整数 $x$，购买一个大小为 $x$ 的箱子。

- 将 $N$ 个玩具分别放入 $N$ 个箱子（包括原有的箱子和新购买的箱子）中，但每个玩具只能放入大小不小于该玩具的箱子，且每个箱子只能放一个玩具。

高桥君想通过购买合适大小的箱子来完成第 $2$ 步，但箱子越大价格越高，因此他想尽可能购买小箱子。请判断是否存在能满足条件的 $x$ 值，如果存在，请输出最小值；如果不存在，请输出 $-1$。

## 样例 #1

### 输入

```
4

5 2 3 7

6 2 8```

### 输出

```
3```

## 样例 #2

### 输入

```
4

3 7 2 5

8 1 6```

### 输出

```
-1```

## 样例 #3

### 输入

```
8

2 28 17 39 57 56 37 32

34 27 73 28 76 61 27```

### 输出

```
37```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

有 $N$ 个玩具，编号从 $1$ 到 $N$，以及 $N-1$ 个箱子，编号从 $1$ 到 $N-1$。玩具 $i$ 的大小为 $A_i$，箱子 $i$ 的大小为 $B_i$。高桥君想把所有玩具分别放入不同的箱子中。他计划按以下步骤操作：

1. 选择任意正整数 $x$，购买一个大小为 $x$ 的箱子。
2. 将 $N$ 个玩具分别放入 $N$ 个箱子（包括原有的箱子和新购买的箱子）中，但每个玩具只能放入大小不小于该玩具的箱子，且每个箱子只能放一个玩具。

高桥君想通过购买合适大小的箱子来完成第 $2$ 步，但箱子越大价格越高，因此他想尽可能购买小箱子。请判断是否存在能满足条件的 $x$ 值，如果存在，请输出最小值；如果不存在，请输出 $-1$。

#### 样例 #1

##### 输入

```
4

5 2 3 7

6 2 8
```

##### 输出

```
3
```

#### 样例 #2

##### 输入

```
4

3 7 2 5

8 1 6
```

##### 输出

```
-1
```

#### 样例 #3

##### 输入

```
8

2 28 17 39 57 56 37 32

34 27 73 28 76 61 27
```

##### 输出

```
37
```

### 题解综合分析与结论

本题的核心问题是如何通过购买一个最小大小的箱子，使得所有玩具都能被放入箱子中。大多数题解采用了贪心或二分查找的思路，通过排序玩具和箱子的大小，然后进行匹配或二分查找来确定最小的 $x$ 值。

#### 关键思路与技巧

1. **贪心策略**：将玩具和箱子从大到小排序，尽可能将最大的玩具放入最大的箱子中，如果无法放入，则需要购买一个新的箱子。
2. **二分查找**：由于答案具有单调性，可以通过二分查找来确定最小的 $x$ 值，每次检查是否可以将所有玩具放入箱子中。
3. **排序与匹配**：通过排序玩具和箱子的大小，可以方便地进行匹配，减少时间复杂度。

### 评分较高的题解

#### 题解1：作者：huangrenheluogu (赞：3)

**星级**：4星  
**关键亮点**：采用贪心策略，将玩具和箱子从大到小排序，尽可能将最大的玩具放入最大的箱子中，如果无法放入，则购买一个新的箱子。思路清晰，代码简洁。

**核心代码**：
```cpp
sort(a + 1, a + n + 1), sort(b + 1, b + n);
reverse(a + 1, a + n + 1), reverse(b + 1, b + n);
ans = a[n];
for(int i = 1; i <= n; i++){
    if(a[i] > b[i]){
        ans = a[i];
        for(int j = i + 1, k = i; j <= n; j++, k++){
            if(a[j] > b[k]){
                puts("-1");
                return 0;
            }
        }
        printf("%d\n", ans);
        return 0;
    }
}
```

#### 题解2：作者：MLE_Automaton (赞：3)

**星级**：4星  
**关键亮点**：采用二分查找的思路，通过二分答案在 $a$ 中的下标，检查是否可以将所有玩具放入箱子中。代码实现较为简洁，思路清晰。

**核心代码**：
```cpp
bool check(int x)
{
    rep(i, 1, n)
    {
        if (i == x) continue;
        if (a[i] > b[i - (i > x)]) return 0;
    }
    return 1;
}
```

#### 题解3：作者：Cosine_Func (赞：2)

**星级**：4星  
**关键亮点**：采用二分答案的思路，通过二分查找确定最小的 $x$ 值，检查是否可以将所有玩具放入箱子中。代码实现较为简洁，思路清晰。

**核心代码**：
```cpp
bool check(int x){
    int j=upper_bound(b.begin(),b.end(),x)-b.begin();
    for(int i=0;i<n;i++){
        int u;
        if(i<j)u=b[i];
        else if(i==j)u=x;
        else u=b[i-1];
        if(u<a[i])return 0;
    }
    return 1;
}
```

### 最优关键思路或技巧

1. **贪心策略**：将玩具和箱子从大到小排序，尽可能将最大的玩具放入最大的箱子中，如果无法放入，则购买一个新的箱子。这种方法简单直观，时间复杂度较低。
2. **二分查找**：通过二分查找确定最小的 $x$ 值，检查是否可以将所有玩具放入箱子中。这种方法适用于答案具有单调性的问题，时间复杂度较低。

### 可拓展之处

1. **类似问题**：类似的问题可以扩展到多个箱子或多个玩具的匹配问题，或者扩展到不同大小的箱子与玩具的匹配问题。
2. **算法套路**：贪心策略和二分查找是解决这类问题的常见套路，可以应用于其他类似的匹配或优化问题。

### 推荐题目

1. [P1048 装箱问题](https://www.luogu.com.cn/problem/P1048)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得总结

在调试过程中，发现排序的顺序和匹配的顺序对结果有较大影响，尤其是从大到小排序后，贪心策略的效果更好。此外，二分查找的实现需要注意边界条件的处理，避免出现死循环或错误结果。

---
处理用时：46.38秒
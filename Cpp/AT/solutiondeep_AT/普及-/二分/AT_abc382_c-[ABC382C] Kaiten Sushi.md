# 题目信息

# [ABC382C] Kaiten Sushi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_c

とある回転寿司に、$ 1 $ から $ N $ までの番号が付けられた $ N $ 人の人が訪れています。 人 $ i $ の **美食度** は $ A_i $ です。

今からベルトコンベア上を $ M $ 個の寿司が流れます。 $ j $ 番目に流れる寿司の **美味しさ** は $ B_j $ です。 それぞれの寿司は、人 $ 1,2,\dots,N $ の前をこの順に流れていきます。 それぞれの人は、美味しさが自分の美食度以上である寿司が自分の前に流れてきたときはその寿司を取って食べ、それ以外のときは何もしません。 人 $ i $ が取って食べた寿司は、人 $ j\ (j\ >\ i) $ の前にはもう流れてきません。

$ M $ 個の寿司それぞれについて、その寿司を誰が食べるか、あるいは誰も食べないかどうかを求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N,M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,B_i\ \leq\ 2\times\ 10^5 $
- 入力は全て整数
 
### Sample Explanation 1

\- $ 1 $ 番目の寿司について、 - まず人 $ 1 $ の前を流れます。$ B_1\ \geq\ A_1 $ なので、人 $ 1 $ はこれを取って食べます。 - 人 $ 2,3 $ の前にはこの寿司は流れてきません。 - $ 2 $ 番目の寿司について、 - まず人 $ 1 $ の前を流れます。$ B_2\ <\ A_1 $ なので、人 $ 1 $ は何もしません。 - 次に人 $ 2 $ の前を流れます。$ B_2\ <\ A_2 $ なので、人 $ 2 $ は何もしません。 - 最後に人 $ 3 $ の前を流れます。$ B_2\ \geq\ A_3 $ なので、人 $ 3 $ はこれを取って食べます。 - $ 3 $ 番目の寿司について、 - まず人 $ 1 $ の前を流れます。$ B_3\ <\ A_1 $ なので、人 $ 1 $ は何もしません。 - 次に人 $ 2 $ の前を流れます。$ B_3\ <\ A_2 $ なので、人 $ 2 $ は何もしません。 - 最後に人 $ 3 $ の前を流れます。$ B_3\ <\ A_3 $ なので、人 $ 3 $ は何もしません。 - よって、誰もこの寿司を食べません。

## 样例 #1

### 输入

```
3 3

3 8 2

5 2 1```

### 输出

```
1

3

-1```

## 样例 #2

### 输入

```
3 3

1 1 1

1 1 1```

### 输出

```
1

1

1```

## 样例 #3

### 输入

```
10 5

60 83 76 45 70 91 37 58 94 22

70 39 52 33 18```

### 输出

```
1

7

4

10

-1```

# AI分析结果

### 题目翻译

有 $N$ 个人，编号从 $1$ 到 $N$，他们正在访问一家传送带寿司餐厅。第 $i$ 个人的美食级别是 $A_i$。

现在，将会有 $M$ 份寿司放置在传送带上。第 $j$ 份寿司的美味度为 $B_j$。每份寿司将按照顺序经过编号为 $1$，$2$，$\dots$，$N$ 的人。每个人在看到美味度不低于他们美食级别的寿司经过时，会拿走并吃掉那份寿司；否则，他们什么也不做。一旦第 $i$ 个人拿走并吃掉了寿司，那份寿司就不会再经过编号大于 $i$ 的人。

对于每份 $M$ 份寿司中的一份，请确定是谁吃掉了那份寿司，或者是否没有人吃掉它。

### 约束条件：
$1\le N$，$M\le2\times10^5$

$1\le A_i$，$B_i\le2\times10^5$

所有输入值均为整数。

### 样例 #1

#### 输入

```
3 3

3 8 2

5 2 1
```

#### 输出

```
1

3

-1
```

### 样例 #2

#### 输入

```
3 3

1 1 1

1 1 1
```

#### 输出

```
1

1

1
```

### 样例 #3

#### 输入

```
10 5

60 83 76 45 70 91 37 58 94 22

70 39 52 33 18
```

#### 输出

```
1

7

4

10

-1
```

### 题解分析与结论

#### 综合分析

本题的核心在于如何高效地找到每个寿司被哪个人吃掉。由于直接暴力枚举会超时，大多数题解都采用了前缀最小值和二分查找的思路来优化时间复杂度。

#### 最优关键思路

1. **前缀最小值**：通过计算 $A$ 数组的前缀最小值，可以保证前缀最小值数组是单调递减的，从而可以使用二分查找来快速定位第一个满足条件的人。
2. **二分查找**：利用前缀最小值的单调性，使用二分查找来快速确定每个寿司被哪个人吃掉，时间复杂度为 $O(M \log N)$。

#### 推荐题解

1. **作者：FlowerAccepted**  
   - **星级**：★★★★★  
   - **关键亮点**：思路清晰，代码简洁，使用了前缀最小值和二分查找，时间复杂度优化到 $O(M \log N)$。  
   - **代码片段**：
     ```cpp
     int main() {
         int n, m;
         cin >> n >> m;
         for (int i = 1; i <= n; i ++) {
             cin >> a[i];
             c[i] = min(a[i], c[i - 1]); // 计算前缀最小值
         }
         for (int i = 1; i <= m; i ++) {
             cin >> b;
             auto it = lower_bound(c + 1, c + n + 1, b, greater<int>()); // lower_bound指针
             if (it - c - 1 < n) { // 判断是否找到
                 cout << it - c << '\n';
             } else {
                 cout << "-1\n";
             }
         }
         return 0;
     }
     ```

2. **作者：Lian_zy**  
   - **星级**：★★★★  
   - **关键亮点**：思路清晰，代码简洁，使用了前缀最小值和二分查找，时间复杂度优化到 $O(M \log N)$。  
   - **代码片段**：
     ```cpp
     int main(){
         cin>>n>>m;
         p[0]=0x3f3f3f3f;
         for(int i=1;i<=n;i++){
             cin>>a[i];
             p[i]=min(p[i-1],a[i]);
         }
         for(int i=1;i<=m;i++)cin>>b[i];
         for(int i=1;i<=m;i++){
             int l=1,r=n,ans=-1;
             while(l<=r){
                 int mid=l+r>>1;
                 if(p[mid]<=b[i]){
                     ans=mid;
                     r=mid-1;
                 }else l=mid+1;
             }
             cout<<ans<<endl;
         }
         return 0;
     }
     ```

3. **作者：hjyowl**  
   - **星级**：★★★★  
   - **关键亮点**：思路清晰，代码简洁，使用了前缀最小值和二分查找，时间复杂度优化到 $O(M \log N)$。  
   - **代码片段**：
     ```cpp
     int main(){
         ios::sync_with_stdio(false);
         cin.tie(0),cout.tie(0);
         cin >> n >> m;
         s[0] = 1e18;
         for (long long i = 1; i <= n; i ++ ){
             cin >> a[i];
             s[i] = min(s[i - 1],a[i]);
         }
         for (long long i = 1; i <= m; i ++ ){
             cin >> b[i];
             long long l = 1,r = n;
             while (l < r){
                 long long mid = l + r >> 1;
                 if (b[i] >= s[mid]){
                     r = mid;
                 }
                 else{
                     l = mid + 1;
                 }
             }
             if (b[i] >= s[l]){
                 cout << l << endl;
             }
             else{
                 cout << -1 << endl; 
             }
         }
         return 0;
     }
     ```

### 扩展思路

1. **类似题目**：
   - [P3382 【模板】二分查找](https://www.luogu.com.cn/problem/P3382)
   - [P3368 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3368)
   - [P3374 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3374)

2. **个人心得**：
   - **调试经历**：在实现二分查找时，注意边界条件的处理，避免死循环或漏判。
   - **踩坑教训**：在计算前缀最小值时，确保初始值设置正确，避免影响后续计算。
   - **顿悟感想**：通过前缀最小值和二分查找的结合，可以大大优化时间复杂度，适用于类似需要快速查找第一个满足条件的元素的场景。

---
处理用时：56.29秒
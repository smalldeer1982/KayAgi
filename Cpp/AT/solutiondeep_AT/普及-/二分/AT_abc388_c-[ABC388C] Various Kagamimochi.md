# 题目信息

# [ABC388C] Various Kagamimochi

## 题目描述

有 $N$ 个大小不一的饼。第 $i$ 个饼的大小为 $a_i$（$1 \le i \le N$）。

对于任意两个大小分别为 $a$ 和 $b$ 的饼 $A$ 和 $B$，如果 $a$ 小于或等于 $b$ 的一半，即 $a\le \frac{b}{2}$，则可以将饼 $A$ 放在饼 $B$ 上制作一个“镜饼”。

从 $N$ 个饼中任选两个，使得其中一个饼放在另一个饼上制作一个“镜饼”。

需要求出可以制作多少种不同的“镜饼”。

此外，即使构成镜饼的饼的大小相同，只要至少有一个是不同的饼，就可以算作是另一种类型的镜饼。

**Translate by [chinazhanghaoxun](https://luogu.com.cn/user/684848)。**

## 样例 #1

### 输入

```
6

2 3 4 4 7 10```

### 输出

```
8```

## 样例 #2

### 输入

```
3

387 388 389```

### 输出

```
0```

## 样例 #3

### 输入

```
32

1 2 4 5 8 10 12 16 19 25 33 40 50 64 87 101 149 175 202 211 278 314 355 405 412 420 442 481 512 582 600 641```

### 输出

```
388```

# AI分析结果

### 题目内容重写
【题目描述】
有 $N$ 个大小不一的饼。第 $i$ 个饼的大小为 $a_i$（$1 \le i \le N$）。

对于任意两个大小分别为 $a$ 和 $b$ 的饼 $A$ 和 $B$，如果 $a$ 小于或等于 $b$ 的一半，即 $a\le \frac{b}{2}$，则可以将饼 $A$ 放在饼 $B$ 上制作一个“镜饼”。

从 $N$ 个饼中任选两个，使得其中一个饼放在另一个饼上制作一个“镜饼”。

需要求出可以制作多少种不同的“镜饼”。

此外，即使构成镜饼的饼的大小相同，只要至少有一个是不同的饼，就可以算作是另一种类型的镜饼。

### 题解分析与结论
本题的核心在于如何高效地统计满足条件的饼对数量。由于饼的大小范围较大，直接暴力枚举会超时，因此需要使用更高效的算法。以下是各题解的主要思路和优化点：

1. **双指针法**：通过排序后使用双指针，时间复杂度为 $O(N)$，主要优化了查找满足条件的饼对的过程。
2. **二分查找法**：通过排序后使用二分查找，时间复杂度为 $O(N \log N)$，适用于查找满足条件的饼对。
3. **暴力优化**：通过减少循环次数来优化暴力解法，但时间复杂度仍然较高，不适用于大规模数据。

### 精选题解
#### 题解1：双指针法（作者：ikunTLE）
**星级：★★★★★**
**关键亮点**：
- 使用双指针法，时间复杂度为 $O(N)$，效率高。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
sort(a+1,a+n+1);
int ans=0;
for(int i=1,j=1;i<=n;++i){
    while(j<=n&&a[i]*2>a[j])
        ++j;
    ans+=n-j+1;
}
printf("%lld\n",ans);
```
**核心思想**：排序后使用双指针，$i$ 指向较小的饼，$j$ 指向较大的饼，统计满足条件的饼对数量。

#### 题解2：二分查找法（作者：IronMen）
**星级：★★★★☆**
**关键亮点**：
- 使用二分查找，时间复杂度为 $O(N \log N)$，适用于大规模数据。
- 代码实现简单，逻辑清晰。

**核心代码**：
```cpp
for(int i=0;i<n;i++){
    pos = lower_bound(a, a + n, a[i] * 2) - a;
    res += n - pos;
}
cout << res << '\n';
```
**核心思想**：排序后使用二分查找，找到第一个满足条件的饼，统计满足条件的饼对数量。

#### 题解3：双指针法（作者：FlowerAccepted）
**星级：★★★★☆**
**关键亮点**：
- 使用双指针法，时间复杂度为 $O(N)$，效率高。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
sort(a + 1, a + n + 1, greater<int>());
for(int i=1,j=1;j<=n;){
    if(a[j] * 2 > a[i]){
        j++;
    } else {
        ans += n - j + 1;
        i++;
    }
}
cout << ans;
```
**核心思想**：排序后使用双指针，$i$ 指向较大的饼，$j$ 指向较小的饼，统计满足条件的饼对数量。

### 最优关键思路
- **双指针法**：通过排序后使用双指针，时间复杂度为 $O(N)$，是最优的解决方案。
- **二分查找法**：通过排序后使用二分查找，时间复杂度为 $O(N \log N)$，适用于大规模数据。

### 可拓展之处
- 类似的问题可以使用双指针或二分查找来解决，如统计满足某种条件的数对数量。
- 可以扩展到多维数据，使用类似的思路进行优化。

### 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

---
处理用时：39.10秒
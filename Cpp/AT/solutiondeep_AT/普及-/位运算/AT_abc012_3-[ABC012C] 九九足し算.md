# 题目信息

# [ABC012C] 九九足し算

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc012/tasks/abc012_3

高橋君は、先日、九九の表を全て暗記することに成功しました。

九九で物足りなくなった高橋君は、 $ 1 $ × $ 1 $ から $ 9 $ × $ 9 $ までの値を、全て足してみることにしました。

高橋君は、九九のうちの一つの答えを忘れてしまったので、その計算を後回しにして、残りの和を求めたところ、$ N $ になりました。

しかし、高橋君は、後回しにした問題がどれだか解らなくなってしまいました。

高橋君が後回しにしてしまった問題として、あり得るものを辞書順で全て出力しなさい。

## 说明/提示

### Sample Explanation 1

高橋君の求めた値は、本来の値より $ 12 $ 少ないものです。 よって、答えが $ 12 $ となる、 $ 2 $ × $ 6 $、 $ 3 $ × $ 4 $、 $ 4 $ × $ 3 $、 $ 6 $ × $ 2 $ の $ 4 $ つが答えとなります。

## 样例 #1

### 输入

```
2013```

### 输出

```
2 x 6

3 x 4

4 x 3

6 x 2```

## 样例 #2

### 输入

```
2024```

### 输出

```
1 x 1```

# AI分析结果

### 题目翻译
高桥同学前些日子成功记住了九九乘法表的所有内容。

对九九乘法表感到不满足的高桥同学，决定将从 1×1 到 9×9 的所有结果相加。

高桥同学忘记了九九乘法表中的一个结果，于是他把这个计算先放一放，计算其余结果的和，得到了 N。

然而，高桥同学忘记了他搁置的是哪道题。

请按字典序输出所有可能是高桥同学搁置的题目。

### 综合分析与结论
这些题解的核心思路都是找出用两个小于 10 的正整数的乘积表示 `2025 - N` 的所有形式，并按字典序输出。主要区别在于实现方式和复杂度的优化。
- **思路对比**：大部分题解采用双重循环暴力枚举的方式，时间复杂度为 $O(n^2)$；部分题解通过数学关系优化为一重循环，时间复杂度降为 $O(n)$；还有题解使用打表的方式。
- **算法要点**：双重循环枚举时，遍历所有小于 10 的正整数组合，判断乘积是否等于 `2025 - N`；一重循环优化时，通过已知一个乘数，计算另一个乘数并判断其是否小于 10；打表则是提前计算好所有结果存储在数组中。
- **解决难点**：主要难点在于输出格式的正确性，如乘号两边的空格和换行。

### 所选题解
- **作者：Reywmp (4星)**
  - **关键亮点**：思路清晰，先给出双重循环的暴力解法，后提及优化到 $O(n)$ 的思路并推荐了其他题解。
  - **个人心得**：作者表示自己没有一遍 AC，说明即使是简单题也可能出现失误。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<iostream>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    n-=2025;
    n=abs(n);
    for(int i=1;i<=9;i++)
    {
        for(int j=9;j>=1;j--)
        {
            if(i*j==n){printf("%d x %d",i,j);printf("\n");}
        }
    }
    return 0;
}
```
- **作者：_Qer (4星)**
  - **关键亮点**：代码简洁，使用一重循环优化，时间复杂度为 $O(n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a;
int main(){
    cin>>a;
    a=2025-a;
    for(int i=1;i<=a&&i<10;++i){
        int j=a/i;
        if(i*j==a&&j<10){
            cout<<i<<" x "<<j<<endl;
        }
    }
    return 0;
}
```
- **作者：liangqiaoshen (4星)**
  - **关键亮点**：进一步优化，利用结果的对称性，只循环 $\sqrt{n}$ 次，减少不必要的计算。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,l=1;
struct ans{
    int x,y;
}b[10001];
int main()
{
    cin>>a;
    a=2025-a;
    for(int i=1;i<=sqrt(a);i++)
    {
        int j=a/i;
        if(i*j==a&&j<10)
        {
            cout<<i<<" x "<<j<<endl;
            b[l].x=j,b[l].y=i;
            l++;
        }
    }
    if(l%2==1)l--;
    for(;l>0;l--)
    {
        if(b[l].x!=b[l].y&&b[l].y!=0&&b[l].x!=0)
            cout<<b[l].x<<" x "<<b[l].y<<endl;
    }        
    return 0;
}
```

### 最优关键思路或技巧
- **数学优化**：通过数学关系，将双重循环优化为一重循环，减少时间复杂度。
- **对称性利用**：利用结果的对称性，只计算一半的结果，另一半直接倒序输出，进一步减少计算量。

### 可拓展之处
同类型题可能会改变数字范围或条件，如将小于 10 改为小于其他数，或者要求输出满足条件的组合个数等。类似算法套路可用于解决因数分解、组合枚举等问题。

### 推荐洛谷题目
- [P1035 级数求和](https://www.luogu.com.cn/problem/P1035)
- [P1046 陶陶摘苹果](https://www.luogu.com.cn/problem/P1046)
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

### 个人心得摘录与总结
- **Reywmp**：简单题也可能出现失误，需要仔细检查。
- **代码小白白**：注意输出格式，格式错误可能导致零分，要仔细检查。
- **北雪2009**：暴力枚举可能会超时，需要通过数学优化来降低时间复杂度。 

---
处理用时：29.53秒
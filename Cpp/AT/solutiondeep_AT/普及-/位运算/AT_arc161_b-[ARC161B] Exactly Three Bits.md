# 题目信息

# [ARC161B] Exactly Three Bits

## 题目描述

对于一个正整数 $X$，定义 $f(X)$ 为 $X$ 在二进制表示下 $1$ 的个数，比如，因为 $6=110_{(2)}$，$11=1101_{(2)}$，$16=10000_{(2)}$，所以 $f(6)=2$，$f(11)=3$，$f(16)=1$。

现在给定你一个正整数 $N$，问是否存在一个小于等于 $N$ 的正整数 $X$，满足 $f(X)=3$。如果存在，请输出满足条件的最大的 $X$，否则输出 `-1`。

本题有多组数据。

## 样例 #1

### 输入

```
4

16

161

4

1000000000000000000```

### 输出

```
14

161

-1

936748722493063168```

# AI分析结果

### 题目内容（已为中文，无需翻译）
对于一个正整数 $X$，定义 $f(X)$ 为 $X$ 在二进制表示下 $1$ 的个数，比如，因为 $6=110_{(2)}$，$11=1101_{(2)}$，$16=10000_{(2)}$，所以 $f(6)=2$，$f(11)=3$，$f(16)=1$。

现在给定你一个正整数 $N$，问是否存在一个小于等于 $N$ 的正整数 $X$，满足 $f(X)=3$。如果存在，请输出满足条件的最大的 $X$，否则输出 `-1`。

本题有多组数据。

### 综合分析与结论
这些题解的核心都是围绕找出小于等于给定正整数 $N$ 且二进制表示中恰有 3 个 1 的最大数。思路主要分为两类：
1. **预处理枚举法**：先枚举所有二进制表示中恰有 3 个 1 的数，排序后对每个输入的 $N$ 进行二分查找，找到小于等于 $N$ 的最大数。如 Su777、XYTZ、escapist404、aeiouaoeiu 的题解。
2. **分类讨论法**：根据 $N$ 的二进制表示中 1 的个数进行分类讨论，通过修改 $N$ 的二进制表示得到满足条件的最大数。如良心WA题人、FreedomKing、shinzanmono、Empty_Dream、LiJinLin_AFO、code_hyx 的题解。

难点在于如何高效地处理多组数据以及对不同情况进行准确的分类讨论。预处理枚举法的难点在于理解组合数的计算和二分查找的运用；分类讨论法的难点在于准确分析各种情况并进行正确的二进制操作。

### 所选题解
- **Su777（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用 `upper_bound` 进行二分查找，提高了查找效率。
    - **核心代码**：
```cpp
for (lint i = 0; i < 60; i ++) {
    for (lint j = i + 1; j < 60; j ++) {
        for (lint k = j + 1; k < 60; k ++) {
            lint value = (1ll << i) + (1ll << j) + (1ll << k);
            arr.push_back(value);
        }
    }
}
sort(arr.begin(), arr.end());
while (T--) {
    lint n;
    cin >> n;
    if (n < 7) {
        cout << "-1\n";
        continue;
    }
    cout << *prev(upper_bound(arr.begin(), arr.end(), n)) << endl;
}
```
核心实现思想：先通过三重循环枚举所有二进制表示中恰有 3 个 1 的数，存储在 `arr` 数组中并排序。对于每个输入的 $n$，若 $n < 7$ 则输出 `-1`，否则使用 `upper_bound` 找到第一个大于 $n$ 的数，再取前一个数即为小于等于 $n$ 的最大数。

- **良心WA题人（4星）**
    - **关键亮点**：详细分析了不同情况下的处理方法，逻辑严谨。
    - **核心代码**：
```cpp
while(T--) {
    ll n;
    scanf("%lld",&n);
    if(n<7) {
        puts("-1");
        continue;
    }
    int cnt=0,a[104],m=0;
    ll x=n;
    while(x) {
        if(x&1)
            cnt++;
        a[m++]=x%2;
        x/=2;
    }
    if(cnt>=3) {
        int t=0;
        ll ans=0;
        for(int i=m-1;~i;i--)
            if(t<3&&a[i]) {
                ans+=1ll<<i;
                t++;
            }
        printf("%lld\n",ans);
    } else {
        bool flag=false;
        for(int i=m-2;i>=2;i--)
            flag|=a[i];
        if(!flag) {
            int t=0;
            ll ans=0;
            for(int i=m-2;~i;i--)
                if(t<3) {
                    ans+=1ll<<i;
                    t++;
                }
            printf("%lld\n",ans);
        } else {
            int t=1;
            bool flag=false;
            ll ans=1ll<<m-1;
            for(int i=m-2;~i;i--) {
                if(flag&&t<3) {
                    ans+=1ll<<i;
                    t++;
                } else
                    flag|=a[i];
            }
            printf("%lld\n",ans);
        }
    }
}
```
核心实现思想：先将 $n$ 转换为二进制数组，统计 1 的个数 `cnt`。若 `cnt >= 3`，则保留最高位的 3 个 1；若 `cnt < 3`，根据是否存在非最高位的 1 且后面能填两个 1 进行不同处理。

- **FreedomKing（4星）**
    - **关键亮点**：使用 `bitset` 容器方便地处理二进制操作，分情况讨论清晰。
    - **核心代码**：
```cpp
while(t--) {
    cin>>n;
    if(n<=6) {
        cout<<"-1\n";
        continue;
    }
    bitset<64>f(n);
    k=0;
    for(int i=0;i<f.size();i++) if(f[i]==1) k++;
    if(k==3) cout<<n<<'\n';
    if(k>3) {
        int x=0;
        while(k>3) {
            if(f[x]==1) {
                k--;
                f[x]=0;
            }
            x++;
        }
        cout<<f.to_ullong()<<'\n';
    }
    if(k<3) {
        int x=0;
        while(f[x]==0) {
            f[x]=1;
            x++;
        }
        f[x]=0;
        k=0;
        for(int i=0;i<f.size();i++) if(f[i]==1) k++;
        // 多次重复上述操作
        x=0;
        while(k>3) {
            if(f[x]==1) {
                k--;
                f[x]=0;
            }
            x++;
        }
        cout<<f.to_ullong()<<'\n';
    }
}
```
核心实现思想：将 $n$ 存入 `bitset` 中，统计 1 的个数 $k$。若 $k = 3$，则直接输出 $n$；若 $k > 3$，则将低位的 1 变为 0 直到 $k = 3$；若 $k < 3$，则多次将 $f - 1$ 直到 $k \geq 3$，再将低位多余的 1 变为 0。

### 最优关键思路或技巧
- **预处理枚举与二分查找**：通过预处理枚举所有满足条件的数，排序后使用二分查找可以高效地处理多组数据，时间复杂度为 $O(C \log C + T \log C)$，其中 $C$ 为满足条件的数的个数。
- **使用 `bitset` 容器**：`bitset` 容器可以方便地进行二进制操作，如统计 1 的个数、修改二进制位等。

### 可拓展之处
同类型题可以是求小于等于 $N$ 的正整数中二进制表示中恰有 $k$ 个 1 的最大数，思路类似，只需将三重循环改为 $k$ 重循环进行枚举。

### 推荐洛谷题目
1. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：涉及二进制相关的计算和递推。
2. [P1464 Function](https://www.luogu.com.cn/problem/P1464)：需要对函数进行递归计算，与递归思路有关。
3. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)：涉及高精度计算和二进制幂运算。

### 个人心得
题解中未包含个人心得相关内容。

---
处理用时：48.35秒
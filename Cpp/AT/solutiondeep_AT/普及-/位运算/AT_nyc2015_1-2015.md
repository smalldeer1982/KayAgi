# 题目信息

# 2015

## 题目描述

[problemUrl]: https://atcoder.jp/contests/NYC2015/tasks/nyc2015_1

入力は以下の形式で標準入力から与えられる。

> $ N $

 `Yes` または `No` と出力せよ。 ```

2015
```

 ```

Yes
```

 ```

2016
```

 ```

No
```

## 说明/提示

### Constraints

すぬけ君は、$ 2015 $ を $ 2 $ 進数で表すと `11111011111` となり回文になっていることに気づいた。 整数 $ N $ を (余計な $ 0 $ をつけない) $ 2 $ 進数で表したとき、回文になっているかどうか判定せよ。 ただし、左から呼んでも右から読んでも同じ文字列を回文という。

- - - - - -

- $ 1\ \leq\ N\ \leq\ 10^9 $

# AI分析结果

### 题目中文重写
## 题目描述
[problemUrl]: https://atcoder.jp/contests/NYC2015/tasks/nyc2015_1

输入将以以下形式从标准输入给出。

> $ N $

请输出 `Yes` 或 `No`。
```
2015
```
```
Yes
```
```
2016
```
```
No
```

## 说明/提示
### 约束条件
すぬけ君注意到，将 $ 2015 $ 用二进制表示时为 `11111011111`，是一个回文。请判断整数 $ N $ 用（不添加多余 $ 0 $ 的）二进制表示时是否为回文。这里，从左往右读和从右往左读都相同的字符串称为回文。

- - - - - -

- $ 1\ \leq\ N\ \leq\ 10^9 $

### 综合分析与结论
这些题解的核心思路都是先将输入的十进制数转换为二进制表示，然后判断该二进制表示是否为回文。不同题解在实现二进制转换和回文判断的方式上有所不同。
|作者|思路|算法要点|解决难点|评分|
|---|---|---|---|---|
|fa_555|使用 `std::bitset` 进行二进制转换，再用 `std::string` 处理并判断回文|`std::bitset` 与 `unsigned long` 和 `std::string` 的转换，去除高位多余的 `0`|处理高位补齐的 `0`|4星|
|Null_Cat|利用位运算 `x&1` 逐位获取二进制位，存储在 `std::string` 中，再用 `std::reverse` 判断回文|位运算获取二进制位|无|3星|
|做梦想Peach|手动将十进制数转换为二进制数组，然后直接判断数组是否为回文|手动转换二进制，数组下标的处理|数组下标从 0 开始，转换后长度的处理|3星|
|3water|利用栈和队列的特性，将二进制位分别存入栈和队列，比较栈顶和队列头判断回文|栈和队列的特性|无|3星|
|时律|将十进制数转换为二进制字符串，反转字符串后比较判断回文|字符串的操作|无|3星|
|CZQ_King|先求出小于 $N$ 的最大的 $2$ 的幂的二进制位数，再用普通回文判断法逐位比较|二分法求二进制位数，位运算获取二进制位|二分法求二进制位数的实现|3星|
|Anguei|Python 题解，一种用自带进制转换函数，一种用位运算手写进制转换，再判断回文|Python 的进制转换和字符串操作|无|3星|
|Zirnc|将十进制数转换为二进制字符串，反转字符串后比较判断回文|字符串的操作|无|2星|
|_lyc233|Pascal 题解，将十进制数转换为二进制字符串，再判断回文|字符串的操作|无|2星|
|Jinyeke|Pascal 题解，将十进制数转换为二进制字符串，再判断回文|字符串的操作|无|2星|
|_Qer|用 `bool` 数组存储二进制位，再进行回文匹配|`bool` 数组存储二进制位|无|3星|

### 所选题解
- fa_555（4星）
  - 关键亮点：使用 `std::bitset` 简化二进制转换，利用其与 `std::string` 的转换方便处理。
  - 核心代码：
```cpp
#include<algorithm>
#include<bitset>
#include<cmath>
#include<iostream>
#include<string>

using namespace std;

int N;
bitset<32> bit; // N <= 10^9，不少于 30 位 
string s, r;

int main() {
    cin >> N;
    bit = (unsigned)N;
    s = r = bit.to_string().substr(32 - log2(N));
    reverse(r.begin(), r.end());
    cout << (s == r ? "Yes" : "No") << '\n';
    return 0;
}
```
核心实现思想：先将输入的数赋值给 `bitset`，再将其转换为 `std::string` 并去除高位多余的 `0`，最后反转字符串比较判断是否为回文。

### 最优关键思路或技巧
- 使用 `std::bitset` 可以方便地进行二进制转换和处理，避免手动逐位处理的复杂性。
- 利用栈和队列的特性可以快速判断回文。

### 可拓展之处
同类型题可能会要求判断其他进制下的数是否为回文，或者判断一个字符串是否为回文等。类似算法套路可以是先进行进制转换或字符串处理，再用双指针或反转字符串的方法判断回文。

### 推荐题目
- P1217 [USACO1.5]回文质数 Prime Palindromes
- P1307 数字反转
- P1015 [NOIP1999 普及组] 回文数

### 个人心得摘录与总结
- Null_Cat：写完后发现没有用 `std::reverse` 函数求解的，看到用 `bitset` 后觉得自己很菜。总结：要多学习和使用 STL 库中的工具。
- 做梦想Peach：认为题目难度最多是橙题，删去快读和没用的头文件代码很简洁。总结：要注意代码的简洁性，去除不必要的部分。

---
处理用时：33.79秒
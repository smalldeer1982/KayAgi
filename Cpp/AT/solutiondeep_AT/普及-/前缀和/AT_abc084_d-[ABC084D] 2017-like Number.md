# 题目信息

# [ABC084D] 2017-like Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc084/tasks/abc084_d

「$ N $ も $ (N+1)÷2 $ も素数」を満たす奇数 $ N $ を **2017に似た数** とします。

$ Q $ 個のクエリが与えられます。

クエリ $ i(1≦i≦Q) $ では奇数 $ l_i $,$ r_i $ が与えられるので、$ l_i≦x≦r_i $ かつ **2017に似た数** となる奇数 $ x $ の個数を求めてください。

## 说明/提示

### 制約

- $ 1≦Q≦10^5 $
- $ 1≦l_i≦r_i≦10^5 $
- $ l_i $,$ r_i $ は奇数
- 入力は全て整数

### Sample Explanation 1

\- $ 3 $ も $ (3+1)÷2=2 $ も素数であるため、$ 3 $ は \*\*2017に似た数\*\* です。 - $ 5 $ も $ (5+1)÷2=3 $ も素数であるため、$ 5 $ は \*\*2017に似た数\*\* です。 - $ 7 $ は素数ですが、 $ (7+1)÷2=4 $ は素数ではないため、$ 7 $ は \*\*2017に似た数\*\* ではありません。 よって、クエリ $ 1 $ の答えは $ 2 $ 個です。

### Sample Explanation 2

$ 2017 $ も \*\*2017に似た数\*\* であることに注意してください。

## 样例 #1

### 输入

```
1

3 7```

### 输出

```
2```

## 样例 #2

### 输入

```
4

13 13

7 11

7 11

2017 2017```

### 输出

```
1

0

0

1```

## 样例 #3

### 输入

```
6

1 53

13 91

37 55

19 51

73 91

13 49```

### 输出

```
4

4

1

1

1

2```

# AI分析结果

### 题目重写

**题目描述**

「$ N $ 和 $ (N+1)÷2 $ 都是素数」的奇数 $ N $ 被称为 **2017-like Number**。

给定 $ Q $ 个查询，每个查询给出两个奇数 $ l_i $ 和 $ r_i $，要求计算在 $ l_i \leq x \leq r_i $ 范围内且满足 **2017-like Number** 的奇数 $ x $ 的个数。

**说明/提示**

- 约束条件：
  - $ 1 \leq Q \leq 10^5 $
  - $ 1 \leq l_i \leq r_i \leq 10^5 $
  - $ l_i $ 和 $ r_i $ 是奇数
  - 输入均为整数

**样例解释**

- 样例1：
  - 输入：`1 3 7`
  - 输出：`2`
  - 解释：3 和 5 都是 **2017-like Number**，而 7 不是。

- 样例2：
  - 输入：`4 13 13 7 11 7 11 2017 2017`
  - 输出：`1 0 0 1`
  - 解释：13 和 2017 是 **2017-like Number**，而 7 和 11 不是。

### 题解分析与结论

#### 综合分析

该题的核心问题是如何高效地判断一个数是否为 **2017-like Number**，并且在多个查询中快速计算区间内的满足条件的数的个数。由于查询次数较多（$ Q \leq 10^5 $），直接暴力枚举会超时，因此需要预处理和优化。

#### 关键思路与技巧

1. **素数筛法**：使用埃氏筛或欧拉筛预处理出所有素数，以便快速判断一个数是否为素数。
2. **前缀和**：预处理一个前缀和数组，记录从1到每个数中满足 **2017-like Number** 的数的个数，从而在查询时可以通过 $ O(1) $ 的时间复杂度得到结果。
3. **优化查询**：通过前缀和数组，查询时只需计算 $ sum[r] - sum[l-1] $ 即可得到结果。

#### 最优题解

**题解作者：FP·荷兰猪 (赞：4)**

**星级：★★★★★**

**关键亮点**：
- 使用埃氏筛预处理素数，时间复杂度为 $ O(n \log \log n) $。
- 使用前缀和数组优化查询，使得每个查询的时间复杂度为 $ O(1) $。
- 代码简洁明了，逻辑清晰。

**核心代码**：

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[100009],f[100009];
main()
{
    p[1]=1;
 
    for (int i=2; i<=100000; i++)
    {
        for (int j=2*i; j<=100000; j+=i)
            p[j]=1;
    }
    p[2]=0;
    for (int i=1; i<=100000; i++)
    {
        if(p[i]==0 && p[(i+1)/2]==0 && i!=2)
            {
                f[i]=f[i-1]+1;
            }
        else f[i]=f[i-1];
    }
    int q;
    cin>>q;
    while(q--)
    {
        int l,r;
        cin>>l>>r;
        cout<<f[r]-f[l-1]<<endl;
    }
}
```

**个人心得**：
- 通过预处理和前缀和的结合，大大减少了查询的时间复杂度，避免了重复计算。

### 推荐题目

1. **洛谷 P3383 【模板】线性筛素数** - 考察素数筛法的基本应用。
2. **洛谷 P3374 【模板】树状数组 1** - 考察前缀和的应用。
3. **洛谷 P3919 【模板】可持久化线段树 1** - 考察区间查询的优化方法。

### 总结

通过预处理和前缀和的结合，可以高效地解决多次区间查询的问题。该题解展示了如何利用埃氏筛和前缀和优化查询，代码简洁且高效，是解决类似问题的经典方法。

---
处理用时：31.39秒
# 题目信息

# [ABC318C] Blue Spring

## 题目描述

**题意简述**

高桥君要进行 $N$ 天的旅行，第 $i$ 天的费用为 $A_i$ 。他还可以使用优惠券，可以免除 $D$ 天的费用，价格为 $P$。如果剩余 $2$ 天，优惠券的作用是 $3$ 天，那么依然可以使用。

求这 $N$ 天旅行的最小费用。

## 说明/提示

- $1 \le N \le 2 \times 10^5$
- $1 \le D \le 2 \times 10^5$
- $1 \le P \le 10^9$
- $1 \le F_i \le 10^9$

**样例一解释**

使用一张优惠券免除 $1,3$ 天的费用，总费用为 $1+3+6+10=20$。

**样例三解释**

使用 $3$ 张优惠券，费用为 $3 \times 1000000000=3000000000$

## 样例 #1

### 输入

```
5 2 10
7 1 6 3 6```

### 输出

```
20```

## 样例 #2

### 输入

```
3 1 10
1 2 3```

### 输出

```
6```

## 样例 #3

### 输入

```
8 3 1000000000
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
3000000000```

# AI分析结果

### 题目内容
高桥君要进行 $N$ 天的旅行，第 $i$ 天的费用为 $A_i$ 。他还可以使用优惠券，可以免除 $D$ 天的费用，价格为 $P$。如果剩余 $2$ 天，优惠券的作用是 $3$ 天，那么依然可以使用。

求这 $N$ 天旅行的最小费用。

### 说明/提示
- $1 \le N \le 2 \times 10^5$
- $1 \le D \le 2 \times 10^5$
- $1 \le P \le 10^9$
- $1 \le F_i \le 10^9$

### 样例 #1
#### 输入
```
5 2 10
7 1 6 3 6
```
#### 输出
```
20
```

### 样例 #2
#### 输入
```
3 1 10
1 2 3
```
#### 输出
```
6
```

### 样例 #3
#### 输入
```
8 3 1000000000
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
```
#### 输出
```
3000000000
```

---

### 题解分析与结论

#### 综合分析
本题的核心思路是贪心算法，通过将每天的旅行费用从大到小排序，然后尽可能多地使用优惠券来减少总费用。优惠券的使用条件是：连续 $D$ 天的费用总和大于 $P$ 时，使用优惠券更划算。因此，题解的核心在于如何高效地计算和比较这些区间的费用。

#### 最优思路与技巧
1. **排序与贪心**：将每天的旅行费用从大到小排序，确保每次使用优惠券时都能覆盖最贵的 $D$ 天，从而最大化节省费用。
2. **前缀和优化**：通过计算前缀和，可以快速计算任意区间的费用总和，避免重复计算。
3. **边界处理**：在处理最后不足 $D$ 天的区间时，需要特别判断是否使用优惠券。

#### 推荐题解
1. **作者：robertuu (4星)**
   - **关键亮点**：代码简洁明了，排序后直接计算每 $D$ 天的费用和，判断是否使用优惠券，最后处理不足 $D$ 天的部分。
   - **代码核心**：
     ```cpp
     sort(a+1,a+1+n,greater<int>());
     long long ans = 0,cnt = 0;
     for(int i = 1;i <= n;i++) {
         cnt += a[i];
         if(i % d == 0) {
             ans += min(cnt,p);
             cnt = 0;
         }
     }
     ans += min(cnt,p);
     ```

2. **作者：Submerge_TA (4星)**
   - **关键亮点**：使用前缀和优化区间计算，代码结构清晰，逻辑严谨。
   - **代码核心**：
     ```cpp
     sort(a,a+n,cmp);
     int i = 0;
     while(i < n) {
         st = 0;
         for(int j = i;j < i+d && j < n;j++) st += a[j];
         i += d;
         if(st <= p) s += st;
         else s += p; 
     }
     ```

3. **作者：lrx___ (4星)**
   - **关键亮点**：通过前缀和计算每个长度为 $D$ 的区间的总和，并处理不满 $D$ 天的区间，代码优化较好。
   - **代码核心**：
     ```cpp
     sort(a+1,a+n+1,cmp);
     for(i = 1;i <= n+d;i++) a[i] += a[i-1];
     for(i = d;i-d <= n;i += d) s += min(a[i]-a[i-d],p);
     ```

#### 个人心得
- **调试经历**：在处理最后不足 $D$ 天的区间时，容易忽略边界条件，导致结果错误。通过增加对最后区间的判断，可以有效避免这一问题。
- **顿悟感想**：贪心算法的关键在于如何选择最优的局部解，本题通过排序和前缀和优化，使得贪心策略更加高效。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

这些题目都涉及到贪心算法的应用，适合进一步巩固贪心算法的理解和应用。

---
处理用时：34.62秒
# 题目信息

# [ABC328C] Consecutive

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc328/tasks/abc328_c

英小文字のみからなる長さ $ N $ の文字列 $ S\ =\ S_1S_2\ldots\ S_N $ が与えられます。

また、$ S $ に関する $ Q $ 個の質問が与えられます。 $ i\ =\ 1,\ 2,\ \ldots,\ Q $ について、$ i $ 番目の質問は $ 2 $ つの整数 $ l_i,\ r_i $ で表される下記の質問です。

> $ S $ の $ l_i $ 文字目から $ r_i $ 文字目までからなる部分文字列 $ S_{l_i}S_{l_i+1}\ldots\ S_{r_i} $ において、 同じ英小文字が $ 2 $ つ隣りあう箇所は何個ありますか？ すなわち、$ l_i\ \leq\ p\ \leq\ r_i-1 $ かつ $ S_p\ =\ S_{p+1} $を満たす整数 $ p $ は何個ありますか？

$ Q $ 個の質問それぞれの答えを出力してください。

## 说明/提示

### 制約

- $ N,\ Q $ は整数
- $ 1\ \leq\ N,\ Q\ \leq\ 3\ \times\ 10^5 $
- $ S $ は英小文字のみからなる長さ $ N $ の文字列
- $ l_i,\ r_i $ は整数
- $ 1\ \leq\ l_i\ \leq\ r_i\ \leq\ N $
 
### Sample Explanation 1

$ 4 $ 個の質問それぞれに対する答えは下記の通りです。 - $ 1 $ 個目の質問に関して、$ S_3S_4\ldots\ S_9\ = $ `ssissip` で同じ英小文字が隣り合う箇所は、$ S_3S_4\ = $ `ss` と $ S_6S_7\ = $ `ss` の $ 2 $ 個です。 - $ 2 $ 個目の質問に関して、$ S_4S_5\ldots\ S_{10}\ = $ `sissipp` で同じ英小文字が隣り合う箇所は、$ S_6S_7\ = $ `ss` と $ S_9S_{10}\ = $ `pp` の $ 2 $ 個です。 - $ 3 $ 個目の質問に関して、$ S_4S_5S_6\ = $ `sis` で同じ英小文字が隣り合う箇所は $ 0 $ 個です。 - $ 4 $ 個目の質問に関して、$ S_7\ = $ `s` で同じ英小文字が隣り合う箇所は $ 0 $ 個です。

### Sample Explanation 2

$ S_1S_2\ldots\ S_5\ = $ `aaaaa` で同じ英小文字が隣り合う箇所は、 $ S_1S_2\ = $ `aa` 、$ S_2S_3\ = $ `aa` 、$ S_3S_4\ = $ `aa` 、$ S_4S_5\ = $ `aa` の $ 4 $ 個です。

## 样例 #1

### 输入

```
11 4

mississippi

3 9

4 10

4 6

7 7```

### 输出

```
2

2

0

0```

## 样例 #2

### 输入

```
5 1

aaaaa

1 5```

### 输出

```
4```

# AI分析结果

### 题目内容重写

给定一个长度为 $N$ 的字符串 $S$，由小写字母组成。有 $Q$ 次询问，每次询问给定两个整数 $l_i$ 和 $r_i$，要求输出在 $S$ 的子串 $S_{l_i}S_{l_i+1}\ldots S_{r_i}$ 中，相邻两个字符相同的个数。

### 题目分析

该题目要求快速查询字符串中任意子串内相邻字符相同的次数。由于 $N$ 和 $Q$ 的最大值均为 $3 \times 10^5$，直接暴力查询会超时，因此需要采用预处理的方式优化查询。

### 题解对比与总结

#### 共同思路
所有题解都采用了**前缀和**的预处理方法，通过一次遍历字符串，记录每个位置之前相邻字符相同的次数，然后在查询时通过前缀和的差值快速得到结果。这种方法的时间复杂度为 $O(N + Q)$，能够满足题目要求。

#### 关键优化点
1. **前缀和预处理**：通过一次遍历，记录每个位置之前相邻字符相同的次数，存储在数组 `d` 或 `sum` 中。
2. **查询优化**：查询时直接通过 `d[r-1] - d[l-1]` 得到结果，时间复杂度为 $O(1)$。

#### 最优思路
最优的思路是使用前缀和预处理，并在查询时直接通过前缀和的差值得到结果。这种方法简洁高效，代码实现也较为简单。

### 精选题解

#### 题解1：zhangboyong (4星)
**关键亮点**：
- 代码简洁，逻辑清晰。
- 使用了前缀和预处理，查询时直接输出差值。

**核心代码**：
```cpp
for(int i = 1;i<len;i++){
    if(s[i]==s[i-1]) d[i]++;
} 
for(int i = 1;i<len;i++) d[i] += d[i-1];
while(q--){
    int l,r;
    cin >> l >> r;
    cout << d[r-1]-d[l-1] << endl;
}
```

#### 题解2：ACtheQ (4星)
**关键亮点**：
- 详细解释了前缀和的预处理过程。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for(int i=1;i<n;i++) {
    if(s[i]==s[i-1]) a[i]=1;
}
for(int i=1;i<n;i++) b[i]=b[i-1]+a[i];
while(q--) {
    int l,r;
    cin>>l>>r; 
    l--;
    r--;
    cout<<b[r]-b[l]<<endl;
}
```

#### 题解3：CEFqwq (4星)
**关键亮点**：
- 代码简洁，使用了 `s[0]` 作为哨兵值，避免了边界问题。
- 查询时直接输出 `qz[r] - qz[l]`，逻辑清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++) qz[i]=qz[i-1]+(int)(s[i]==s[i-1]);
while(t-->0){
    int l,r;
    cin>>l>>r;
    cout<<qz[r]-qz[l]<<"\n";
}
```

### 最优关键思路
使用前缀和预处理，记录每个位置之前相邻字符相同的次数，查询时通过前缀和的差值快速得到结果。这种方法简洁高效，时间复杂度为 $O(N + Q)$。

### 拓展思路
类似的问题可以使用前缀和、差分、滑动窗口等技巧进行优化。例如，区间求和、区间最大值等问题都可以通过预处理来优化查询。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)

### 个人心得摘录
- **调试经历**：在处理边界问题时，使用哨兵值（如 `s[0]`）可以有效避免数组越界问题。
- **踩坑教训**：在计算前缀和时，注意数组下标从 0 还是 1 开始，避免混淆。
- **顿悟感想**：前缀和不仅适用于求和问题，还可以用于统计满足特定条件的元素个数，灵活运用可以解决多种区间查询问题。

---
处理用时：33.28秒
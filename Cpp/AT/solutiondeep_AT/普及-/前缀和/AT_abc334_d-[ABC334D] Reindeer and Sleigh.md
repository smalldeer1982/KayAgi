# 题目信息

# [ABC334D] Reindeer and Sleigh

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_d

$ N $ 台のソリがあり、各ソリには $ 1,2,\ldots,\ N $ の番号がつけられています。

ソリ $ i $ を引くために必要なトナカイは $ R_i $ 匹です。

また、各トナカイが引けるソリは高々 $ 1 $ 台です。より厳密には、$ m $ 台のソリ $ i_1,\ i_2,\ \ldots,\ i_m $ を引くために必要なトナカイは $ \sum_{k=1}^{m}\ R_{i_k} $ 匹です。

以下の形式のクエリが $ Q $ 個与えられるので、答えを求めてください。

- 整数 $ X $ が与えられる。トナカイが $ X $ 匹いるときに最大で何台のソリを引けるか求めよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ R_i\ \leq\ 10^9 $
- $ 1\ \leq\ X\ \leq\ 2\ \times\ 10^{14} $
- 入力される数値はすべて整数
 
### Sample Explanation 1

トナカイが $ 16 $ 匹いるとき、ソリ $ 1,2,4 $ を引くことができます。 $ 16 $ 匹のトナカイで $ 4 $ 台のソリを引くことはできないので、クエリ $ 1 $ の答えは $ 3 $ となります。

## 样例 #1

### 输入

```
4 3

5 3 11 8

16

7

1000```

### 输出

```
3

1

4```

## 样例 #2

### 输入

```
6 6

1 2 3 4 5 6

1

2

3

4

5

6```

### 输出

```
1

1

2

2

2

3```

## 样例 #3

### 输入

```
2 2

1000000000 1000000000

200000000000000

1```

### 输出

```
2

0```

# AI分析结果

### 题目内容重写

#### [ABC334D] 驯鹿和雪橇

**题目描述**

有 $N$ 台雪橇，每台雪橇编号为 $1,2,\ldots,\ N$。

拉动第 $i$ 台雪橇需要 $R_i$ 只驯鹿。

每只驯鹿最多只能拉一台雪橇。更严格地说，拉动 $m$ 台雪橇 $i_1,\ i_2,\ \ldots,\ i_m$ 所需的驯鹿数量为 $\sum_{k=1}^{m}\ R_{i_k}$。

给定 $Q$ 个查询，每个查询给出一个整数 $X$，表示有 $X$ 只驯鹿时，最多能拉动多少台雪橇。

**说明/提示**

### 约束

- $1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5$
- $1\ \leq\ R_i\ \leq\ 10^9$
- $1\ \leq\ X\ \leq\ 2\ \times\ 10^{14}$
- 输入的所有数值均为整数

### 样例解释

**样例 1**

输入：
```
4 3
5 3 11 8
16
7
1000
```

输出：
```
3
1
4
```

解释：
当有 16 只驯鹿时，可以拉动雪橇 1、2、4。无法拉动 4 台雪橇，因此第一个查询的答案是 3。

**样例 2**

输入：
```
6 6
1 2 3 4 5 6
1
2
3
4
5
6
```

输出：
```
1
1
2
2
2
3
```

**样例 3**

输入：
```
2 2
1000000000 1000000000
200000000000000
1
```

输出：
```
2
0
```

### 题解分析与结论

#### 综合分析

所有题解都采用了相似的思路：将雪橇所需的驯鹿数量从小到大排序，然后计算前缀和，最后通过二分查找来确定在给定驯鹿数量下最多能拉动多少台雪橇。这种思路的核心在于贪心算法和二分查找的结合，确保在每次查询时能够高效地找到答案。

#### 最优关键思路

1. **贪心算法**：为了最大化拉动的雪橇数量，优先选择所需驯鹿数量较少的雪橇。
2. **前缀和**：通过计算前缀和，可以快速确定拉动前 $k$ 台雪橇所需的驯鹿总数。
3. **二分查找**：利用二分查找在前缀和数组中快速定位满足条件的最大雪橇数量。

#### 推荐题解

1. **作者：xz001**  
   **星级：4**  
   **关键亮点**：代码简洁明了，使用了二分查找和前缀和的经典组合，处理查询时效率高。  
   **代码片段**：
   ```cpp
   sort(a + 1, a + n + 1);
   for (int i = 1; i <= n; ++ i) sum[i] = sum[i - 1] + a[i];
   while (q -- ) {
       int x;
       scanf("%lld", &x);
       int l = 0, r = n, ans; 
       while (l <= r) {
           int mid = (l + r) >> 1;
           if (sum[mid] <= x) {
               ans = mid;
               l = mid + 1;
           } else {
               r = mid - 1;
           }
       }
       printf("%lld\n", ans);
   }
   ```

2. **作者：jubingkun**  
   **星级：4**  
   **关键亮点**：使用了 `upper_bound` 函数简化二分查找的实现，代码更加简洁。  
   **代码片段**：
   ```cpp
   sort(a + 1, a + n + 1);
   for (int i = 1; i <= n; ++i) pre[i] = pre[i - 1] + a[i];
   while (q--) {
       cin >> x;
       if (x >= sum) cout << n << "\n";
       else {
           int b = upper_bound(pre + 1, pre + n + 1, x) - pre;
           cout << b - 1 << "\n";
       }
   }
   ```

3. **作者：CheZiHe929**  
   **星级：4**  
   **关键亮点**：代码结构清晰，使用了 `upper_bound` 函数，并且在二分查找中正确处理了边界条件。  
   **代码片段**：
   ```cpp
   sort(r + 1, r + n + 1);
   for (int i = 1; i <= n; i++) r[i] += r[i - 1];
   while (q--) {
       cin >> x;
       int ans = upper_bound(r + 1, r + n + 1, x) - r - 1;
       cout << ans << endl;
   }
   ```

#### 扩展思路

1. **类似题目**：  
   - [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)  
   - [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)  
   - [P1843 奶牛晒衣服](https://www.luogu.com.cn/problem/P1843)

2. **调试与优化**：在实际编码中，二分查找的边界条件容易出错，建议在编写代码时仔细检查边界条件，确保代码的正确性。此外，使用 `upper_bound` 等 STL 函数可以简化代码并提高可读性。

---
处理用时：39.48秒
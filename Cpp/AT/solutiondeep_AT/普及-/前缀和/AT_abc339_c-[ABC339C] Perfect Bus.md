# 题目信息

# [ABC339C] Perfect Bus

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc339/tasks/abc339_c

一台のバスが走っています。バスの乗客の数は常に非負整数です。

このバスにはある時点で $ 0 $ 人以上の乗客が乗っており、その時点から現在までに $ N $ 回停車しました。このうち $ i $ 回目の停車では乗客が差し引き $ A_i $ 人増えました。$ A_i $ は負の値であることもあり、その場合は乗客が差し引き $ -A_i $ 人減ったことを意味しています。また、停車時以外には乗客の乗り降りはありませんでした。

与えられた情報に矛盾しない現在のバスの乗客の数として考えられる最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ -10^9\ \leq\ A_i\ \leq\ 10^9 $
- 入力される数値はすべて整数
 
### Sample Explanation 1

はじめに乗っている乗客の人数が $ 2 $ 人であるとき、現在の乗客の人数は $ 2\ +\ 3\ +\ (-5)\ +\ 7\ +\ (-4)\ =\ 3 $ 人であり、さらにバスの乗客の人数は常に非負整数となります。

## 样例 #1

### 输入

```
4

3 -5 7 -4```

### 输出

```
3```

## 样例 #2

### 输入

```
5

0 0 0 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
4

-1 1000000000 1000000000 1000000000```

### 输出

```
3000000000```

# AI分析结果

### 题目内容重写

【题目描述】

一辆公交车在行驶过程中，乘客数量始终为非负整数。公交车在某个时刻有0人以上的乘客，从该时刻到当前时刻共停靠了N次。第i次停靠时，乘客数量增加了A_i人（A_i可能为负，表示乘客减少了A_i人）。停靠时以外没有乘客上下车。

请根据给定的信息，求出当前公交车乘客数量的最小可能值。

【说明/提示】

- 1 ≤ N ≤ 2 × 10^5
- -10^9 ≤ A_i ≤ 10^9
- 所有输入均为整数

【样例解释1】

如果初始乘客数量为2人，那么当前乘客数量为2 + 3 + (-5) + 7 + (-4) = 3人，且公交车上的乘客数量始终为非负整数。

【样例1】

输入：
```
4
3 -5 7 -4
```
输出：
```
3
```

【样例2】

输入：
```
5
0 0 0 0 0
```
输出：
```
0
```

【样例3】

输入：
```
4
-1 1000000000 1000000000 1000000000
```
输出：
```
3000000000
```

---

### 题解分析与结论

#### 1. 题解思路对比

- **贪心法**：大多数题解采用了贪心策略，通过计算乘客数量的前缀和，找到最小值。如果最小值为负，则初始乘客数量需要至少为最小值的绝对值，否则初始乘客数量可以为0。这种方法时间复杂度为O(N)，适合大规模数据。
  
- **二分法**：部分题解使用了二分法，通过二分初始乘客数量，检查是否满足所有时刻乘客数量为非负。这种方法时间复杂度为O(N log N)，虽然稍慢，但思路清晰，适合理解二分法的应用。

#### 2. 最优思路总结

最优思路是**贪心法**，通过计算前缀和的最小值来确定初始乘客数量。这种方法简单高效，适合大规模数据处理。关键点在于：
- 计算前缀和，找到最小值。
- 如果最小值为负，初始乘客数量为最小值的绝对值；否则初始乘客数量为0。
- 最终乘客数量为初始乘客数量加上所有A_i的和。

#### 3. 推荐题解

1. **Genius_Star (4星)**
   - **关键亮点**：思路清晰，代码简洁，使用贪心法直接求解，时间复杂度为O(N)。
   - **核心代码**：
     ```cpp
     ll n,sum,Min=0;
     ll a[N];
     int main(){
         n=read();
         for(int i=1;i<=n;i++){
             a[i]=read();
             sum+=a[i];
             Min=min(Min,sum);
         }
         if(Min<0)
           write(abs(Min)+sum);
         else
           write(sum);
         return 0;
     }
     ```

2. **XXh0919 (4星)**
   - **关键亮点**：代码简洁，使用贪心法，直接通过前缀和的最小值求解，时间复杂度为O(N)。
   - **核心代码**：
     ```cpp
     int n,sum,ans;
     int a[N];
     signed main(){
         cin>>n;
         for(int i=1;i<=n;++i){
             cin>>a[i];
             sum+=a[i];
             ans=min(sum,ans);
         }
         cout<<sum-ans<<'\n';
         return 0;
     }
     ```

3. **SJZ2010 (4星)**
   - **关键亮点**：思路清晰，使用前缀和的最小值求解，代码简洁，时间复杂度为O(N)。
   - **核心代码**：
     ```cpp
     ll tmp(0), mi(0), ans;
     for (int i = 1; i <= n; i++) {
         tmp += a[i];
         mi = std::min(tmp, mi);
     }
     ans = -mi + tmp;
     printf("%lld\n", ans);
     ```

#### 4. 关键实现技巧

- **前缀和计算**：通过累加A_i得到前缀和，找到最小值。
- **贪心策略**：根据前缀和的最小值决定初始乘客数量，确保所有时刻乘客数量为非负。

#### 5. 可拓展之处

- **类似问题**：可以扩展到其他需要维护最小值的场景，如滑动窗口最小值、区间最小值等。
- **算法套路**：贪心法在解决类似问题时非常有效，尤其是在需要维护某个变量的最小值或最大值的场景。

#### 6. 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

#### 7. 个人心得总结

- **调试经历**：部分题解提到在二分法中上界设置过小导致无法找到正确解，提醒我们在二分法中要合理设置上下界。
- **顿悟感想**：贪心法在解决这类问题时往往能提供简洁高效的解决方案，尤其是在需要维护某个变量的最小值或最大值的场景。

---
处理用时：39.58秒
# 题目信息

# 投票 (Voting)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joig2022-open/tasks/joig2022_c

JOI 高校において，ある議題に関して「賛成」か「反対」かを問う採決が行われ，$ N $ 人の生徒が順番に投票を行った．生徒は自分の投票前に，それまでに投票した他の生徒がどちらに投票したかを知ることができた．

$ i $ 番目 ($ 1\ \leqq\ i\ \leqq\ N $) に投票した生徒は，次の条件を満たしたとき「賛成」に投票し，満たさなかったとき「反対」に投票した．

- 直前に投票した $ X_i $ 人の生徒，すなわち $ i-1,i-2,...,i-X_i $ 番目に投票した生徒のうち，$ Y_i $ 人以上が「賛成」に投票した．

ただし， $ Y_i=0 $ のときは他の生徒の投票に関わらず「賛成」に投票し，$ Y_i=X_i+1 $ のときは他の生徒の投票に関わらず「反対」に投票したとする．

各生徒の投票についての情報が与えられたとき，「賛成」に投票した生徒の人数を求めるプログラムを作成せよ．

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 500\,000 $．
- $ 0\ \leqq\ X_i\ \leqq\ i-1 $ ($ 1\ \leqq\ i\ \leqq\ N $)．
- $ 0\ \leqq\ Y_i\ \leqq\ X_i+1 $ ($ 1\ \leqq\ i\ \leqq\ N $)．
- 入力される値はすべて整数である．

### 小課題

1. ($ 28 $ 点) $ N\ \leqq\ 3\,000 $．
2. ($ 32 $ 点) $ X_i\ =\ i-1 $ ($ 1\ \leqq\ i\ \leqq\ N $)．
3. ($ 40 $ 点) 追加の制約はない．

### 採点に関する注意

すべての提出はジャッジシステム上で採点される．

提出されたソースコードは，小課題に対応するすべての採点用入力データについて正しい結果を返したとき，その小課題について正解と認められる．

各提出の得点は，提出されたソースコードについて正解と認められた小課題の得点の合計である．

この課題の得点は，**この課題に対するすべての提出の得点の最大値**である．

現在の得点は「提出結果」タブの「自分の得点状況」から確認できる．

### Sample Explanation 1

投票は，以下のように $ 4 $ 人の生徒によって順番に行われた． 1. $ 1 $ 番目に投票した生徒は，$ Y_1=X_1+1 $ であるため，「反対」に投票した． 2. $ 2 $ 番目に投票した生徒は，$ Y_2=0 $ であるため，「賛成」に投票した． 3. 直前に投票した $ X_3(=1) $ 人の生徒のうち「賛成」に投票したのは $ 1 $ 人で，これは $ Y_3(=1) $ 人以上である．そのため，$ 3 $ 番目に投票した生徒は「賛成」に投票した． 4. 直前に投票した $ X_4(=3) $ 人の生徒のうち「賛成」に投票したのは $ 2 $ 人で，これは $ Y_4(=3) $ 人以上ではない．そのため，$ 4 $ 番目に投票した生徒は「反対」に投票した． 「賛成」に投票した生徒は $ 2 $ 人である．したがって，$ 2 $ を出力する． この入力例は小課題 $ 1,3 $ の制約を満たす．

### Sample Explanation 2

この入力例はすべての小課題の制約を満たす．

### Sample Explanation 3

この入力例は小課題 $ 1,3 $ の制約を満たす．

## 样例 #1

### 输入

```
4

0 1

1 0

1 1

3 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5

0 0

1 1

2 3

3 1

4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10

0 0

1 2

1 1

1 0

3 1

2 3

1 1

5 3

8 4

7 2```

### 输出

```
4```

# AI分析结果

### 题目内容重写

#### 题目描述

JOI 高校进行了一次关于某个议题的投票，决定是“赞成”还是“反对”。共有 $N$ 名学生依次进行了投票。每名学生在投票前，可以知道之前所有学生的投票结果。

第 $i$ 名（$1 \leq i \leq N$）投票的学生，如果满足以下条件，则投“赞成”，否则投“反对”：

- 在之前投票的 $X_i$ 名学生中，即第 $i-1, i-2, \dots, i-X_i$ 名学生中，有至少 $Y_i$ 名学生投了“赞成”。

特别地，如果 $Y_i = 0$，则该学生无论如何都会投“赞成”；如果 $Y_i = X_i + 1$，则该学生无论如何都会投“反对”。

给定每名学生的投票信息，求最终投“赞成”的学生人数。

#### 说明/提示

##### 约束

- $1 \leq N \leq 500,000$。
- $0 \leq X_i \leq i-1$（$1 \leq i \leq N$）。
- $0 \leq Y_i \leq X_i + 1$（$1 \leq i \leq N$）。
- 输入的所有值都是整数。

##### 小任务

1. （28 分）$N \leq 3,000$。
2. （32 分）$X_i = i-1$（$1 \leq i \leq N$）。
3. （40 分）无额外约束。

##### 样例解释

**样例 1**：

输入：
```
4
0 1
1 0
1 1
3 3
```
输出：
```
2
```
解释：
1. 第 1 名学生由于 $Y_1 = X_1 + 1$，投“反对”。
2. 第 2 名学生由于 $Y_2 = 0$，投“赞成”。
3. 第 3 名学生检查前 1 名学生的投票，发现有 1 人投“赞成”，满足 $Y_3 = 1$，投“赞成”。
4. 第 4 名学生检查前 3 名学生的投票，发现有 2 人投“赞成”，不满足 $Y_4 = 3$，投“反对”。
最终有 2 名学生投“赞成”。

**样例 2**：

输入：
```
5
0 0
1 1
2 3
3 1
4 3
```
输出：
```
4
```
解释：
所有小任务的约束都满足。

**样例 3**：

输入：
```
10
0 0
1 2
1 1
1 0
3 1
2 3
1 1
5 3
8 4
7 2
```
输出：
```
4
```
解释：
小任务 1 和 3 的约束满足。

### 题解分析与结论

#### 题解对比与评分

1. **__hqt__ 的题解**
   - **星级**：4.5
   - **关键亮点**：从暴力解法（$O(n^2)$）优化到前缀和（$O(n)$），思路清晰，代码简洁。
   - **个人心得**：通过前缀和优化，将时间复杂度从 $O(n^2)$ 降低到 $O(n)$，解决了超时问题。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) {
         if(z[i-1]-z[i-x[i]-1]>=y[i]) z[i]=z[i-1]+1;
         else z[i]=z[i-1];
     }
     ```

2. **CEFqwq 的题解**
   - **星级**：4
   - **关键亮点**：使用前缀和在线处理，代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i=0;i<n;i++) {
         a[i+1]=a[i];
         if(a[i]-a[i-x]>=y) a[i+1]++;
     }
     ```

3. **duanfeitong 的题解**
   - **星级**：4
   - **关键亮点**：前缀和的应用，代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) {
         if(sum[i]-sum[i-x]>=y) sum[i+1]=sum[i]+1;
         else sum[i+1]=sum[i];
     }
     ```

#### 最优关键思路与技巧

- **前缀和优化**：通过维护一个前缀和数组，快速计算任意区间内的“赞成”人数，将时间复杂度从 $O(n^2)$ 降低到 $O(n)$。
- **在线处理**：在输入时直接处理数据，避免二次遍历，进一步优化性能。

#### 可拓展之处

- **类似题目**：可以扩展到其他需要快速计算区间和的题目，如滑动窗口、区间查询等。
- **数据结构**：前缀和可以与其他数据结构（如树状数组、线段树）结合，解决更复杂的区间问题。

#### 推荐题目

1. **洛谷 P3374 【模板】树状数组 1**：考察前缀和与树状数组的结合应用。
2. **洛谷 P3368 【模板】树状数组 2**：进一步考察区间修改与查询。
3. **洛谷 P1886 滑动窗口**：考察滑动窗口与前缀和的结合应用。

#### 个人心得总结

- **调试经历**：通过暴力解法发现超时问题，进而思考优化方法，最终通过前缀和解决。
- **踩坑教训**：大数组应定义为全局变量，避免栈溢出。
- **顿悟感想**：前缀和的应用可以大幅降低时间复杂度，是解决区间问题的利器。

---
处理用时：41.42秒
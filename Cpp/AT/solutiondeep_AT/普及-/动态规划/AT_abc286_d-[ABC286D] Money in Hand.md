# 题目信息

# [ABC286D] Money in Hand

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc286/tasks/abc286_d

高橋君は $ N $ 種類の硬貨をそれぞれ何枚か持っており、 具体的には、$ 1\leq\ i\leq\ N $ について $ A_i $ 円硬貨を $ B_i $ 枚持っています。

高橋君が現在持っている硬貨を用いて、（お釣りが出ないように）ちょうど $ X $ 円を支払うことができるか判定してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 50 $
- $ 1\leq\ X\leq\ 10^4 $
- $ 1\leq\ A_i\leq\ 100 $
- $ 1\leq\ B_i\leq\ 50 $
- $ A_i $ はすべて異なる。
- 入力はすべて整数
 
### Sample Explanation 1

高橋君は $ 2 $ 円硬貨を $ 3 $ 枚、$ 5 $ 円硬貨を $ 6 $ 枚持っています。 このうち、$ 2 $ 円硬貨を $ 2 $ 枚、$ 5 $ 円硬貨を $ 3 $ 枚用いることでちょうど $ 2\times\ 2+5\times\ 3=19 $ 円を支払うことができます。 よって、`Yes` を出力します。

### Sample Explanation 2

持っている硬貨をどのように組み合わせてもちょうど $ 18 $ 円を支払うことはできません。 よって、`No` を出力します。

### Sample Explanation 3

$ 1 $ 枚も使用しない硬貨が存在しても構いません。

## 样例 #1

### 输入

```
2 19

2 3

5 6```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 18

2 3

5 6```

### 输出

```
No```

## 样例 #3

### 输入

```
3 1001

1 1

2 1

100 10```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写

**题目描述**

高橋君有 $N$ 种硬币，每种硬币的面值为 $A_i$ 元，他持有 $B_i$ 枚这种硬币。请判断高橋君是否可以用他持有的硬币正好支付 $X$ 元（不找零）。

**说明/提示**

- 约束条件：
  - $1 \leq N \leq 50$
  - $1 \leq X \leq 10^4$
  - $1 \leq A_i \leq 100$
  - $1 \leq B_i \leq 50$
  - $A_i$ 互不相同。
  - 输入均为整数。

**样例解释**

- 样例1：高橋君有 2 元硬币 3 枚，5 元硬币 6 枚。他可以用 2 元硬币 2 枚和 5 元硬币 3 枚支付 19 元，输出 `Yes`。
- 样例2：无法用持有的硬币支付 18 元，输出 `No`。
- 样例3：高橋君有 1 元硬币 1 枚，2 元硬币 1 枚，100 元硬币 10 枚。他可以用 100 元硬币 10 枚支付 1001 元，输出 `Yes`。

### 题解综合分析与结论

本题是一个典型的多重背包问题，核心思路是通过动态规划来判断是否可以用给定的硬币组合支付目标金额。各题解均采用了动态规划的思路，但在实现细节和优化上有所不同。

### 所选高分题解

#### 题解1：作者：__Allen_123__ (5星)

**关键亮点：**
- 详细解释了动态规划的状态转移过程，思路清晰。
- 代码结构清晰，易于理解。
- 使用了三重循环实现状态转移，时间复杂度为 $O(n \times b_i \times x)$，符合题目要求。

**核心代码：**
```cpp
bool dp[MAXN][MAXX]; // 第 1 维最大下标为 n，第 2 维最大下标为 x
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> x;
    for(int i = 1;i <= n;i++){
        cin >> a[i] >> b[i];
    }
    dp[0][0] = 1; // 设计初始状态
    for(int i = 1;i <= n;i++){
        for(int j = 0;j <= b[i];j++){
            for(int k = 0;k <= x;k++){
                if(k >= a[i] * j && dp[i - 1][k - a[i] * j]){
                    dp[i][k] = 1;
                }
            }
        }
    }
    if(dp[n][x]){ // 求出最终答案
        Yes;
    }
    else{
        No;
    }
    return 0;
}
```

#### 题解2：作者：yemuzhe (4星)

**关键亮点：**
- 使用了倒序循环优化空间复杂度，减少了内存使用。
- 代码简洁，逻辑清晰。
- 时间复杂度为 $O(x \sum B_i)$，空间复杂度为 $O(x)$。

**核心代码：**
```cpp
int f[M] = {1}; // f[0] = 1
int main (){
    scanf ("%d%d", &n, &m);
    while (n --){
        scanf ("%d%d", &a, &b);
        while (b --){
            for (int i = m; i >= a; i --){
                f[i] |= f[i - a];
            }
        }
    }
    puts (f[m] ? "Yes" : "No");
    return 0;
}
```

#### 题解3：作者：Neil_Qian (4星)

**关键亮点：**
- 提出了二进制优化的思路，虽然本题不需要，但为类似问题提供了优化方向。
- 代码简洁，逻辑清晰。
- 时间复杂度为 $O(n \times b \times x)$。

**核心代码：**
```cpp
bool dp[10002]; // dp数组
int main(){
    scanf("%d%d",&n,&x),dp[0]=1; // 初始化
    while(n--){
        scanf("%d%d",&a,&b); // 读入
        while(b--)for(int j=x;j>=a;j--)dp[j]|=dp[j-a]; // 变成b个->转移
    }
    return printf("%s\n",(dp[x]?"Yes":"No")),0; // 输出
}
```

### 最优关键思路或技巧

- **动态规划**：通过状态转移方程 $dp[i][j] = dp[i-1][j - a_i \times k]$ 来判断是否可以用前 $i$ 种硬币支付 $j$ 元。
- **倒序循环**：优化空间复杂度，避免重复使用硬币。
- **二进制优化**：将多重背包问题转化为01背包问题，减少时间复杂度。

### 拓展思路

- **类似问题**：多重背包问题、01背包问题、完全背包问题。
- **优化方向**：二进制优化、单调队列优化等。

### 推荐题目

1. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)

### 个人心得摘录

- **调试经历**：在实现动态规划时，初始状态的设置非常重要，确保 $dp[0][0] = 1$。
- **踩坑教训**：倒序循环可以有效避免重复使用硬币，正序循环会导致错误。
- **顿悟感想**：二进制优化可以将多重背包问题转化为01背包问题，大大减少时间复杂度。

---
处理用时：43.31秒
# 题目信息

# [ABC385C] Illuminate Buildings

## 题目描述

## 翻译  
这里有 $N$ 栋建筑等距排成一行。记 $H_i$ 为第 $i$ 栋建筑的高度。

你想要给一些建筑装上灯光，有 2 个前提：   
1.选择的建筑都有相同的高度。  
2.选择的建筑以相等的间隔排列。  

请问你可以选择最多多少栋建筑？我们认为只选择一栋建筑是满足条件的。

## 样例 #1

### 输入

```
8

5 7 5 7 7 5 7 7```

### 输出

```
3```

## 样例 #2

### 输入

```
10

100 200 300 400 500 600 700 800 900 1000```

### 输出

```
1```

## 样例 #3

### 输入

```
32

3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5```

### 输出

```
3```

# AI分析结果

### 题目内容重写
【题目描述】  
这里有 $N$ 栋建筑等距排成一行。记 $H_i$ 为第 $i$ 栋建筑的高度。

你想要给一些建筑装上灯光，有 2 个前提：  
1. 选择的建筑都有相同的高度。  
2. 选择的建筑以相等的间隔排列。  

请问你可以选择最多多少栋建筑？我们认为只选择一栋建筑是满足条件的。

### 题解综合分析与结论
本题的核心是寻找一个子序列，满足序列中的元素高度相同且间隔相等。大多数题解采用了动态规划（DP）的思路，通过定义状态 $dp[i][j]$ 表示到第 $i$ 个建筑时，间隔为 $j$ 的最长子序列长度。状态转移方程通常为：
- 如果 $H[i] = H[i-j]$，则 $dp[i][j] = dp[i-j][j] + 1$。
- 否则，$dp[i][j] = 1$。

部分题解还通过枚举间隔或使用哈希表来优化时间复杂度。整体来看，DP 是解决该问题的核心方法，时间复杂度为 $O(n^2)$。

### 评分较高的题解

#### 题解1：作者：Tomwsc (4星)
**关键亮点**：  
- 使用了经典的 DP 思路，状态定义清晰，转移方程简洁。
- 代码实现较为规范，初始化部分处理得当。

**核心代码**：
```cpp
for(register int i = 1;i <= n;i ++) {
    for(register int j = 1;j <= i;j ++) {
        dp[i][j] = 1;
        if(h[i] == h[i - j])
            dp[i][j] = dp[i - j][j] + 1;
        ans = max(ans , dp[i][j]);
    }
}
```

#### 题解2：作者：Even_If (4星)
**关键亮点**：  
- 借鉴了最长等差子序列的 DP 思路，状态转移方程清晰。
- 初始化部分处理得当，代码结构简洁。

**核心代码**：
```cpp
for (int i = 1; i <= n; i ++) {
    for (int j = 1; i + j <= n; j ++) {
        if(a[i] == a[i + j]) {
            f[i + j][j] = max(f[i][j] + 1, f[i + j][j]);
        }
    }
}
```

#### 题解3：作者：hytallenxu (4星)
**关键亮点**：  
- DP 状态定义清晰，转移方程简洁明了。
- 初始化部分处理得当，代码结构简洁。

**核心代码**：
```cpp
for (int i = 1; i <= n; i ++) {
    for (int j = 1; j < i; j ++) {
        if(a[i] == a[i - j]) {
            dp[i][j] = dp[i - j][j] + 1;
        }
        ans = max(ans, dp[i][j]);
    }
}
```

### 最优关键思路或技巧
1. **动态规划**：通过定义状态 $dp[i][j]$ 表示到第 $i$ 个建筑时，间隔为 $j$ 的最长子序列长度，利用状态转移方程求解。
2. **初始化**：每个 $dp[i][j]$ 初始化为 1，因为每个建筑本身就是一个合法的子序列。
3. **枚举间隔**：通过枚举间隔 $j$ 来寻找满足条件的子序列。

### 可拓展之处
- **类似题目**：可以拓展到其他需要寻找子序列的问题，如最长等差子序列、最长回文子序列等。
- **优化思路**：可以考虑使用哈希表或其他数据结构来优化时间复杂度，尤其是在数据规模较大的情况下。

### 推荐题目
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)
3. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)

---
处理用时：30.24秒
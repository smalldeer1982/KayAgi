# 题目信息

# [AGC007A] Shik and Stone

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc007/tasks/agc007_a

縦 $ H $ 行、横 $ W $ 列のマス目に区切られた盤面があります。 はじめ、駒が左上隅のマスに置かれていました。 シックはこの駒を $ 1 $ マスずつ上下左右に動かし、右下隅のマスに移動させました。 このとき、駒が同じマスを複数回通った可能性もあります（左上隅や右下隅のマスも含む）。

縦横に並んだ文字 $ a_{ij} $ ($ 1\ \leq\ i\ \leq\ H $, $ 1\ \leq\ j\ \leq\ W $) が与えられます。 $ a_{ij} $ が `#` のとき、駒が移動する過程で $ i $ 行 $ j $ 列目のマスを一度以上通ったことを表します（左上隅や右下隅のマスは必ず通ったものとして扱います）。 $ a_{ij} $ が `.` のとき、駒が $ i $ 行 $ j $ 列目のマスを一度も通らなかったことを表します。 移動する過程で、駒が常に右または下に動いていた可能性があるか判定してください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 8 $
- $ a_{i,j} $ は `#` または `.` である。
- 問題文および $ a $ で与えられる情報と整合するような駒の動き方が存在する。

### Sample Explanation 1

右、下、右、下、右、下、右と駒が動くと、通るマスが与えられた情報と合致します。

## 样例 #1

### 输入

```
4 5

##...

.##..

..##.

...##```

### 输出

```
Possible```

## 样例 #2

### 输入

```
5 3

###

..#

###

#..

###```

### 输出

```
Impossible```

## 样例 #3

### 输入

```
4 5

##...

.###.

.###.

...##```

### 输出

```
Impossible```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个纵 $ H $ 行、横 $ W $ 列的棋盘。开始时，棋盘的左上角有一个棋子。Shik 将这个棋子每次移动一格，上下左右移动，最终将其移动到右下角。在这个过程中，棋子可能会多次经过同一个格子（包括左上角和右下角的格子）。

给定一个由字符 $ a_{ij} $ ($ 1\ \leq\ i\ \leq\ H $, $ 1\ \leq\ j\ \leq\ W $) 组成的矩阵。如果 $ a_{ij} $ 是 `#`，表示棋子至少经过该格子一次（左上角和右下角的格子必定经过）。如果 $ a_{ij} $ 是 `.`，表示棋子没有经过该格子。请判断是否存在一种移动方式，使得棋子每次移动都只向右或向下。

#### 说明/提示

- $ 2\ \leq\ H,\ W\ \leq\ 8 $
- $ a_{i,j} $ 是 `#` 或 `.`
- 输入数据保证存在一种合法的移动方式。

### 题解分析与结论

#### 题解思路对比

1. **Yu_343 的题解**：通过统计 `#` 的数量，判断是否等于 $H + W - 1$。这个思路基于路径长度的数学推导，简单高效。
2. **zjyqwq 的题解**：同样基于 `#` 的数量判断，但使用了 Pascal 语言实现，思路与 Yu_343 类似。
3. **wimg6_ 的题解**：提出了两种算法，第一种是暴力搜索，第二种是基于 `#` 数量的数学判断，与 Yu_343 的思路一致。
4. **Daniel_yao 的题解**：通过统计 `#` 的数量，判断是否等于 $H + W - 1$，思路与 Yu_343 一致。
5. **零殇 的题解**：使用 BFS 搜索路径，并检查是否经过所有 `#`，思路较为复杂。
6. **智子·起源 的题解**：使用 BFS 搜索路径，并确保每次只选择一种移动方向，思路较为复杂。
7. **lzxhdxx 的题解**：使用 BFS 搜索路径，并确保每次只选择一种移动方向，思路较为复杂。
8. **七夜 的题解**：通过判断每个点的上下左右是否有 `#`，思路较为复杂。
9. **N0othing 的题解**：使用 DFS 搜索路径，并检查是否经过所有 `#`，思路较为复杂。
10. **Texas_the_Omertosa 的题解**：通过统计 `#` 的数量，判断是否等于 $H + W - 1$，思路与 Yu_343 一致。
11. **cjZYZtcl 的题解**：通过统计 `#` 的数量，判断是否等于 $H + W - 1$，思路与 Yu_343 一致。

#### 最优关键思路

最简洁高效的思路是 **Yu_343 的题解**，通过统计 `#` 的数量，判断是否等于 $H + W - 1$。这个思路基于路径长度的数学推导，避免了复杂的搜索算法，代码实现简单且时间复杂度低。

#### 代码实现

```cpp
#include <cstdio>

int main() {
    int h, w;
    scanf("%d %d", &h, &w);
    int cnt = 0;
    for (int i = 1; i <= h; ++i) {
        getchar();
        for (int j = 1; j <= w; ++j) {
            char ch = getchar();
            if (ch == '#') ++cnt;
        }
    }
    puts((cnt == h + w - 1) ? "Possible" : "Impossible");
    return 0;
}
```

#### 拓展思路

这种基于路径长度的数学推导思路可以应用于类似的网格路径问题，特别是当路径有特定方向限制时（如只能向右或向下）。类似的问题可以通过统计关键点的数量或路径长度来简化问题。

#### 推荐题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

#### 个人心得

Yu_343 的题解中提到，这个思路虽然简单，但并不是他第一个想到的，说明在算法竞赛中，简单的数学推导往往能带来高效的解决方案。

---
处理用时：35.29秒
# 题目信息

# [ARC174A] A Multiply

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc174/tasks/arc174_a

長さ $ N $ の整数列 $ A=(A_1,A_2,\dots,A_N) $ と整数 $ C $ が与えられます。  
 以下の操作を **高々 $ 1 $ 度** 行って達成できる $ A $ の全要素の総和の最大値を求めてください。

- $ 1\ \le\ l\ \le\ r\ \le\ N $ を満たす整数 $ l,r $ を指定し、 $ A_l,A_{l+1},\dots,A_r $ の全ての要素を $ C $ 倍する。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ -10^6\ \le\ C\ \le\ 10^6 $
- $ -10^6\ \le\ A_i\ \le\ 10^6 $
 
### Sample Explanation 1

この入力では、 $ A=(-10,10,20,30,-20),\ C=2 $ です。 $ l=2,r=4 $ と指定して操作を $ 1 $ 度行うことで、操作後の $ A $ を $ (-10,20,40,60,-20) $ とすることができます。 このとき $ A $ の全要素の総和は $ 90 $ となり、これが達成可能な最大値です。

### Sample Explanation 2

この入力では、 $ A=(-1,-2,-3,-4,-5),\ C=1000000 $ です。 操作を一度も行わないとき $ A $ の全要素の総和は $ -15 $ となり、これが達成可能な最大値です。

## 样例 #1

### 输入

```
5 2

-10 10 20 30 -20```

### 输出

```
90```

## 样例 #2

### 输入

```
5 1000000

-1 -2 -3 -4 -5```

### 输出

```
-15```

## 样例 #3

### 输入

```
9 -1

-9 9 -8 2 -4 4 -3 5 -3```

### 输出

```
13```

# AI分析结果

### 题目内容重写
**题目描述**

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$ 和一个整数 $C$。  
你可以进行**最多一次**操作，选择两个整数 $l$ 和 $r$（满足 $1 \le l \le r \le N$），将 $A_l,A_{l+1},\dots,A_r$ 的所有元素都乘以 $C$。  
求经过操作后，序列 $A$ 的所有元素的总和的最大值。

**说明/提示**

**约束条件**
- 所有输入均为整数。
- $1 \le N \le 3 \times 10^5$
- $-10^6 \le C \le 10^6$
- $-10^6 \le A_i \le 10^6$

**样例解释**
- 样例1：$A=(-10,10,20,30,-20),\ C=2$，选择 $l=2,r=4$，操作后 $A=(-10,20,40,60,-20)$，总和为 $90$。
- 样例2：$A=(-1,-2,-3,-4,-5),\ C=1000000$，不进行操作，总和为 $-15$。

### 题解综合分析
本题的核心思路是根据 $C$ 的正负性，选择最大子段和或最小子段和进行乘法操作，从而最大化序列的总和。具体来说：
- 当 $C > 0$ 时，选择最大子段和进行乘法操作。
- 当 $C \leq 0$ 时，选择最小子段和进行乘法操作。

### 所选高星题解
#### 1. 作者：___Furina___ (5星)
**关键亮点**：
- 清晰地区分了 $C$ 的正负情况，分别处理最大子段和和最小子段和。
- 提供了详细的证明，解释了为什么选择最大子段和或最小子段和是最优的。
- 代码简洁高效，使用了动态规划来求解最大子段和和最小子段和。

**核心代码**：
```cpp
int maxn=-1e16,ans,suma,sumb,minn=1e16,c,sum;
signed main(){
    int n;
    cin>>n>>c;
    for(int i=1,x;i<=n;i++){
        cin>>x,suma=max(suma+x,x),sumb=min(sumb+x,x),sum+=x;
        maxn=max(maxn,suma),minn=min(minn,sumb);
    }
    cout<<max(sum,max(maxn*c+sum-maxn,minn*c+sum-minn));
    return 0;
}
```

#### 2. 作者：qw1234321 (4星)
**关键亮点**：
- 强调了 $C$ 的正负性对选择子段和的影响。
- 提到子段和可以为空，进一步优化了结果。
- 代码简洁，使用了动态规划求解最大子段和和最小子段和。

**核心代码**：
```cpp
if(c>0){
    long long ans=-1e9;
    for(int i=1;i<=n;i++){
        f[i]=max(f[i-1]+a[i],a[i]);
        ans=max(ans,f[i]);
    }
    cout<<max(s+ans*(c-1),s);
}
else {
    long long ans=1e9;
    for(int i=1;i<=n;i++){
        f[i]=min(f[i-1]+a[i],a[i]);
        ans=min(ans,f[i]);
    }    
    cout<<max(s+ans*(c-1),s);
}
```

#### 3. 作者：zzhbpyy (4星)
**关键亮点**：
- 详细讨论了 $C$ 的正负性对选择子段和的影响。
- 提供了动态规划的转移方程，清晰地解释了如何求解最大子段和和最小子段和。
- 代码简洁，易于理解。

**核心代码**：
```cpp
if(c>0){
    for(int i=1;i<=n;i++){
        dp[i]=max(dp[i-1],0LL)+a[i];
        ans=max(ans,dp[i]);
    }
}
else{
    for(int i=1;i<=n;i++){
        dp[i]=min(dp[i-1],0LL)+a[i];
        ans=min(ans,dp[i]);
    }
}
cout<<ch+(c-1)*ans;
```

### 最优关键思路
1. **分类讨论**：根据 $C$ 的正负性，分别选择最大子段和或最小子段和进行乘法操作。
2. **动态规划**：使用动态规划高效求解最大子段和和最小子段和。
3. **边界处理**：考虑子段和为空的情况，确保结果的最优性。

### 可拓展之处
- **类似题目**：可以扩展到多次操作的情况，或者选择多个区间进行乘法操作。
- **算法套路**：动态规划求解最大子段和和最小子段和的思路可以应用于其他类似问题，如最大乘积子数组等。

### 推荐题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1121 环状最大子段和](https://www.luogu.com.cn/problem/P1121)
3. [P1359 租用游艇](https://www.luogu.com.cn/problem/P1359)

### 个人心得总结
- **调试经历**：在处理 $C$ 为负数时，容易忽略最小子段和的选择，导致结果不优。
- **踩坑教训**：在动态规划求解子段和时，需要特别注意边界条件，避免数组越界或结果错误。
- **顿悟感想**：通过分类讨论和动态规划的结合，可以高效解决复杂问题，提升代码的可读性和效率。

---
处理用时：48.79秒
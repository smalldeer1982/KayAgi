# 题目信息

# ニコニコレベル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dwacon2017-prelims/tasks/dwango2017qual_b

ニコニコ文字列とは、`25` を $ 0 $ 回以上繰り返した文字列のことをいいます。たとえば `25` や `252525` や空文字列はニコニコ文字列ですが、`123` や `225` はニコニコ文字列ではありません。

ある文字列 $ S $ がその連続した部分文字列として含む最長のニコニコ文字列の長さを $ S $ の **ニコニコレベル** といいます。 たとえば `52525`, `25025`, `12151` のニコニコレベルはそれぞれ $ 4 $, $ 2 $, $ 0 $ です。

ニワンゴくんは `0` から `9` の数字と `?` からなる文字列 $ T $ を持っており、それぞれの `?` を好きな数字に置き換えることで、数字のみからなる文字列 $ T' $ を作ろうとしています。ニワンゴくんが作ることのできる文字列 $ T' $ のニコニコレベルの最大値を求めて下さい。

## 说明/提示

### 制約

- $ 1\ ≦\ |T|\ ≦\ 10^5 $
- $ T $ の文字は $ 0 $ から $ 9 $ の数字か `?` のいずれかである。

### Sample Explanation 1

`?` を前から順に `5` と `2` に置き換えて `1252567890` とすると、$ 2 $ 文字目から $ 5 $ 文字目が `2525` となり、ニコニコレベル $ 4 $ の文字列を作ることができます。

### Sample Explanation 3

`25` が全く現れない文字列はニコニコレベル $ 0 $ になります。

## 样例 #1

### 输入

```
12??567890```

### 输出

```
4```

## 样例 #2

### 输入

```
65?5?4?```

### 输出

```
2```

## 样例 #3

### 输入

```
314159265358979```

### 输出

```
0```

## 样例 #4

### 输入

```
2???5????```

### 输出

```
8```

## 样例 #5

### 输入

```
52```

### 输出

```
0```

# AI分析结果

### 题目内容翻译

**题目名称：ニコニコレベル**

**题目描述：**

ニコニコ文字列是指由 `25` 重复 $0$ 次或多次组成的字符串。例如，`25`、`252525` 和空字符串都是ニコニコ文字列，但 `123` 和 `225` 不是。

对于一个字符串 $S$，其最长的连续子串中作为ニコニコ文字列的长度称为 $S$ 的 **ニコニコレベル**。例如，`52525`、`25025`、`12151` 的ニコニコレベル分别为 $4$、$2$、$0$。

ニワンゴくん有一个由 `0` 到 `9` 的数字和 `?` 组成的字符串 $T$，他可以将每个 `?` 替换为任意数字，生成一个只包含数字的字符串 $T'$。请计算 $T'$ 的最大可能的ニコニコレベル。

**说明/提示：**

**约束条件：**

- $1 \leq |T| \leq 10^5$
- $T$ 中的字符是 `0` 到 `9` 的数字或 `?`。

**样例解释1：**

将 `?` 依次替换为 `5` 和 `2`，得到 `1252567890`，其中从第 $2$ 到第 $5$ 个字符为 `2525`，因此可以生成ニコニコレベル为 $4$ 的字符串。

**样例解释3：**

如果字符串中完全不出现 `25`，则其ニコニコレベル为 $0$。

### 综合分析与结论

本题的核心是通过动态规划（DP）来求解字符串中最大可能的ニコニコレベル。多个题解都采用了类似的DP思路，主要区别在于状态定义和转移方程的细节处理。以下是各题解的要点总结：

1. **DP状态定义**：大多数题解都使用了两个状态数组 `dp2[i]` 和 `dp5[i]`，分别表示在第 $i$ 个位置填入 `2` 或 `5` 时的最大ニコニコレベル。
2. **状态转移**：如果当前字符是 `2` 或 `?`，则 `dp2[i] = dp5[i-1] + 1`；如果当前字符是 `5` 或 `?`，且前一个字符是 `2`，则 `dp5[i] = dp2[i-1] + 1`。
3. **答案计算**：最终的答案是所有 `dp5[i]` 中的最大值，因为ニコニコ文字列必须以 `5` 结尾。

### 评分较高的题解

#### 题解1：Stone_Xz (4星)

**关键亮点：**
- 状态定义清晰，直接使用 `dp2[i]` 和 `dp5[i]` 表示当前字符为 `2` 或 `5` 时的最大ニコニコレベル。
- 状态转移方程简洁明了，代码可读性高。

**核心代码：**
```cpp
for(int i = 1; i <= len; i++) {
    if(s[i] == '?' || s[i] == '2')
        dp_2[i] = dp_5[i - 1] + 1;
    if((s[i] == '?' || s[i] == '5') && dp_2[i - 1] >= 1)
        dp_5[i] = dp_2[i - 1] + 1;
}
```

#### 题解2：__owowow__ (4星)

**关键亮点：**
- 状态转移方程与题解1类似，但代码实现更加简洁。
- 强调了空字符串也是ニコニコ文字列，处理了边界情况。

**核心代码：**
```cpp
for(int i=0;i<s.size();i++) {
    if(s[i]=='2'||s[i]=='?') f2[i]=f5[i-1]+1;
    if((s[i]=='5'||s[i]=='?')&&f2[i-1]>=1) f5[i]=f2[i-1]+1;
}
```

#### 题解3：Kvaratskhelia (4星)

**关键亮点：**
- 使用了二维数组 `f[i][1]` 和 `f[i][2]` 来表示当前字符为 `2` 或 `5` 时的最大ニコニコレベル。
- 状态转移方程与题解1和题解2类似，但代码实现略有不同。

**核心代码：**
```cpp
for(int i=0;i<int(st.size());i++) {
    if(st[i]=='2'||st[i]=='?') f[i+1][1]=f[i][2]+1;
    if(st[i]=='5'||st[i]=='?') 
        if(f[i][1]>0) f[i+1][2]=f[i][1]+1;
    ans=max(ans,f[i+1][2]);
}
```

### 最优关键思路与技巧

1. **DP状态定义**：使用两个状态数组 `dp2[i]` 和 `dp5[i]` 分别表示当前字符为 `2` 或 `5` 时的最大ニコニコレベル。
2. **状态转移**：根据当前字符是否为 `2` 或 `5` 以及前一个字符的状态，进行状态转移。
3. **边界处理**：注意处理空字符串的情况，确保 `dp2[0]` 和 `dp5[0]` 的初始值正确。

### 拓展思路

本题的DP思路可以推广到其他类似的字符串匹配问题，例如寻找最长的特定模式子串。类似的题目可以通过定义合适的状态和转移方程来解决。

### 推荐题目

1. **洛谷 P1040**：最长公共子序列（LCS）
2. **洛谷 P1091**：最长回文子串
3. **洛谷 P1143**：最长上升子序列（LIS）

这些题目都涉及到字符串或序列的最长子串问题，可以通过类似的DP思路来解决。

---
处理用时：53.40秒
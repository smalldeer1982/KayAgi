# 题目信息

# 雨上がり

## 题目描述

[problemUrl]: https://atcoder.jp/contests/wupc2nd/tasks/wupc_02

 雨が上がった．そろそろ大学に行こう． 僕の家から大学までは一本道の道路で結ばれている．道路は区間に分けることができ，ここでは，道路を一行の文字列で表すことにする．各文字が1つの区間に相当し，1文字目が家の前の区間，最後の文字が大学の前の区間を表している．  
  
 ここで，各文字の意味は次のとおりである．

```

 . : 普通の区間
 X : 水たまりのある区間
```

 僕は家の前の区間からスタートし大学へ向かう．僕は現在位置から$ 1 $つ，$ 2 $つ，もしくは$ 3 $つ先の区間(大学のある方向)へ進むことができる．もし，移動した先の区間に水たまりがある場合，僕は水たまりを踏むはめになる．買ったばかりの靴を汚したくないので，なるだけ水たまりを避けたい．また，大学の前の道路を超えて移動するようなことはできない．  
  
 家の前の道路から大学の前の道路まで適切な進み方で向かうとき，最低限踏まなければならない水たまりの数を求めてほしい．  
 入力は以下の形式で標準入力から与えられる． > $ N $ $ S $

- $ 1 $ 行目に区間の数を表す $ N $($ 3\ ≦\ N\ ≦\ 100 $) が与えられる．
- $ 2 $ 行目には，$ N $ 文字の文字列 $ S $ が与えられる．これらは道路の区間のデータである．
- $ S $ に出現する文字は '.', 'X' のいずれかであり，意味は上に記した通りである．
- $ S $ の最初と最後の文字は必ず '.' である．
 
 最低限踏まなければならない水たまりの数を標準出力に $ 1 $ 行で出力せよ．  
 なお、最後には改行を出力せよ． ```
<pre class="prettyprint linenums">
5
.XXX.
```

 ```
<pre class="prettyprint linenums">
1
```

 ```
<pre class="prettyprint linenums">
10
.X.XXXXXX.
```

 ```
<pre class="prettyprint linenums">
2
```

 ```
<pre class="prettyprint linenums">
7
.......
```

 ```
<pre class="prettyprint linenums">
0
```

# AI分析结果

### 题目内容重写（中文）

**题目描述**

雨停了，该去大学了。从我家到大学有一条直路，这条路可以分成若干段，每段用一个字符表示。第一个字符表示家前的路段，最后一个字符表示大学前的路段。

每个字符的含义如下：

- `.`：普通路段
- `X`：有水坑的路段

我从家前的路段出发，前往大学。我可以从当前位置向前移动1、2或3段（向大学方向）。如果移动到的路段有水坑，我就会踩到水坑。我不想弄脏新买的鞋子，所以尽可能避免踩水坑。另外，我不能越过大学前的路段。

请计算从家到大学的路线上，最少需要踩多少个水坑。

**输入格式**

- 第一行：路段数 $N$（$3 \leq N \leq 100$）
- 第二行：长度为 $N$ 的字符串 $S$，表示路段情况。$S$ 中只包含 `.` 和 `X`，且第一个和最后一个字符必为 `.`

**输出格式**

输出最少需要踩的水坑数，末尾换行。

**样例输入1**

```
5
.XXX.
```

**样例输出1**

```
1
```

**样例输入2**

```
10
.X.XXXXXX.
```

**样例输出2**

```
2
```

**样例输入3**

```
7
.......
```

**样例输出3**

```
0
```

---

### 题解分析与结论

#### 综合分析与结论

本题的核心是计算从起点到终点的路径中，最少需要踩多少个水坑。由于每次可以移动1、2或3步，因此可以使用动态规划（DP）或贪心策略来解决。

- **动态规划**：通过状态转移方程 `f[i] = (S[i] == 'X') + min(f[i-1], f[i-2], f[i-3])` 来计算每个位置的最小水坑数。
- **贪心策略**：通过模拟行走过程，尽可能选择不踩水坑的路径，或者在必须踩水坑时选择踩最少的水坑。

#### 所选高星题解

1. **题解作者：_Qer（4星）**
   - **关键亮点**：使用动态规划，状态转移方程清晰，代码简洁。
   - **代码核心**：
     ```cpp
     for(int i=3;i<n;++i){
         f[i]=(road[i]=='X')+min(f[i-3],min(f[i-2],f[i-1]));
     }
     ```
   - **个人心得**：动态规划是解决此类问题的最优选择，状态转移方程的设计是关键。

2. **题解作者：田所浩二仙贝（4星）**
   - **关键亮点**：动态规划实现，代码结构清晰，初始化部分处理得当。
   - **代码核心**：
     ```cpp
     for(int i=3;i<=n-1;i++){
         if(s[i]=='.'){
             dp[i]=min(min(dp[i-1],dp[i-2]),dp[i-3]);
         } else {
             dp[i]=min(min(dp[i-1],dp[i-2]),dp[i-3])+1;
         }
     }
     ```
   - **个人心得**：动态规划的初始化非常重要，前三个位置需要单独处理。

3. **题解作者：zzhhf（4星）**
   - **关键亮点**：动态规划实现，状态转移方程简洁，代码可读性强。
   - **代码核心**：
     ```cpp
     for(i=2;i<=n;i++) {
         if(ch[i]=='X') dp[i]=min(min(dp[i-3],dp[i-2]),dp[i-1])+1;
         else dp[i]=min(min(dp[i-3],dp[i-2]),dp[i-1]);
     }
     ```
   - **个人心得**：动态规划的递推式设计要准确，避免越界。

#### 最优关键思路

- **动态规划**：通过状态转移方程计算每个位置的最小水坑数，确保每一步都选择最优路径。
- **初始化**：前三个位置需要单独处理，避免越界。
- **状态转移**：根据当前位置是否为水坑，决定是否增加水坑数。

#### 可拓展之处

- **类似题目**：可以扩展到每次移动步数不固定的情况，或者路径中有其他障碍物的情况。
- **算法套路**：动态规划适用于类似的路径优化问题，如最短路径、最少代价等。

#### 推荐题目

1. **洛谷 P1219 [八皇后问题](https://www.luogu.com.cn/problem/P1219)**：考察回溯与动态规划的结合。
2. **洛谷 P1048 [采药](https://www.luogu.com.cn/problem/P1048)**：经典的背包问题，与动态规划相关。
3. **洛谷 P1091 [合唱队形](https://www.luogu.com.cn/problem/P1091)**：考察动态规划在序列问题中的应用。

---
处理用时：41.18秒
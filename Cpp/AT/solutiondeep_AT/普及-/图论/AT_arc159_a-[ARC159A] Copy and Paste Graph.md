# 题目信息

# [ARC159A] Copy and Paste Graph

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc159/tasks/arc159_a

$ N $ 行 $ N $ 列の行列 $ A=(a_{i,j}) $ が与えられます。ここで、$ a_{i,j}\ \in\ \{0,1\} $ が成り立ちます。

また、以下のような有向グラフがあります。

- 頂点数は $ NK $ で、各頂点には $ 1,2,\ldots,NK $ と番号が付けられている。
- 辺は $ A $ を縦 $ K $ 行横 $ K $ 列に並べて得られる $ NK $ 行 $ NK $ 列の行列 $ X=(x_{i,j}) $ によって表される(入出力例1にて $ A,\ K $ に対応する $ X $ が示されている)。具体的には、$ x_{i,j}=1 $ ならば頂点 $ i $ から頂点 $ j $ への有向辺が存在し、$ x_{i,j}=0 $ ならば存在しない。
 
$ i=1,2,\ldots,Q $ に対し、次の問題に答えてください。

- 頂点 $ s_i $ から頂点 $ t_i $ への経路の長さ(辺の本数)の最小値を求めよ。ただし、そのような経路が存在しない場合は代わりに `-1` と出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ a_{i,j}\ \in\ \{0,1\} $
- $ 1\ \leq\ Q\ \leq\ 100 $
- $ 1\ \leq\ s_i,t_i\ \leq\ NK $
- $ s_i\ \neq\ t_i $
- 入力はすべて整数
 
### Sample Explanation 1

この例において、辺を表す行列 $ X $ は以下のようになります。 ``` 1 1 1 1 1 1 1 1 0 1 1 0 0 1 0 0 1 0 1 1 1 1 1 1 1 1 0 1 1 0 0 1 0 0 1 0 ```

### Sample Explanation 2

辺が $ 1 $ 本も存在しません。

## 样例 #1

### 输入

```
3 2

1 1 1

1 1 0

0 1 0

4

1 2

1 4

1 6

6 3```

### 输出

```
1

1

1

3```

## 样例 #2

### 输入

```
4 1000000000

0 0 0 0

0 0 0 0

0 0 0 0

0 0 0 0

1

1 4000000000```

### 输出

```
-1```

# AI分析结果

### 题目中文重写
## [ARC159A] 复制粘贴图

### 题目描述
给定一个 $N$ 行 $N$ 列的矩阵 $A=(a_{i,j})$，其中 $a_{i,j} \in \{0,1\}$。

此外，有一个如下的有向图：
- 顶点数为 $NK$，每个顶点编号为 $1,2,\ldots,NK$。
- 边由将 $A$ 纵向重复 $K$ 行、横向重复 $K$ 列得到的 $NK$ 行 $NK$ 列矩阵 $X=(x_{i,j})$ 表示（在输入输出示例 1 中展示了与 $A$、$K$ 对应的 $X$）。具体而言，若 $x_{i,j}=1$，则存在从顶点 $i$ 到顶点 $j$ 的有向边；若 $x_{i,j}=0$，则不存在。

对于 $i = 1,2,\ldots,Q$，请回答以下问题：
- 求从顶点 $s_i$ 到顶点 $t_i$ 的路径长度（边的数量）的最小值。若不存在这样的路径，则输出 `-1`。

### 说明/提示
#### 约束条件
- $1 \leq N \leq 100$
- $1 \leq K \leq 10^9$
- $a_{i,j} \in \{0,1\}$
- $1 \leq Q \leq 100$
- $1 \leq s_i,t_i \leq NK$
- $s_i \neq t_i$
- 所有输入均为整数

#### 示例解释 1
在此示例中，表示边的矩阵 $X$ 如下：
```
1 1 1 1 1 1 1 1
0 1 1 0 0 1 0 0
1 0 1 1 1 1 1 1
1 1 0 1 1 0 0 1
0 0 1 0
```

#### 示例解释 2
不存在任何边。

### 样例 #1
#### 输入
```
3 2
1 1 1
1 1 0
0 1 0
4
1 2
1 4
1 6
6 3
```

#### 输出
```
1
1
1
3
```

### 样例 #2
#### 输入
```
4 1000000000
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
1
1 4000000000
```

#### 输出
```
-1
```

### 综合分析与结论
这些题解的核心思路均是利用图由 $n\times n$ 邻接矩阵复制 $k^2$ 次构成的特性，将原问题转化为在 $n\times n$ 邻接矩阵中求最短路问题，普遍采用 Floyd 算法预处理任意两点间的最短路。

- **思路**：大家都发现了大矩阵的重复性，将询问的顶点编号通过取模操作映射到小矩阵内，再用小矩阵的最短路信息回答询问。不过，lzqy_ 的题解还额外考虑了不能默认 $kn + b \to kn + b$ 的情况，增加了遍历能直接到达目标点的点来更新最短路的步骤。
- **算法要点**：主要是 Floyd 算法的运用，通过三重循环更新任意两点间的最短距离。
- **解决难点**：关键在于理解大矩阵和小矩阵的关系，以及如何处理顶点编号的映射。部分题解还需处理映射后同一点但原顶点不同的情况。

### 题解评分
| 作者 | 评分 | 理由 |
| ---- | ---- | ---- |
| Xy_top | 4星 | 思路清晰，代码注释较详细，能让读者快速理解解题过程。 |
| KidzzZip | 4星 | 对代码关键部分有详细解释，适合初学者学习。 |
| 良心WA题人 | 4星 | 不仅给出解题思路和代码，还对方法的正确性进行了证明，逻辑严谨。 |
| _Gabriel_ | 3星 | 思路和代码常规，但缺乏一些必要的注释。 |
| FyFive | 3星 | 思路基本正确，但代码中多次重复 Floyd 循环，可能是调试遗留，影响代码质量。 |
| lzqy_ | 3星 | 考虑了一些特殊情况，但代码复杂度稍高，且思路解释不够清晰。 |
| james1BadCreeper | 3星 | 思路和代码简洁，但解释较少。 |
| Federico2903 | 3星 | 思路清晰，但代码中有自定义函数 `read` 和 `rep` 未给出定义，影响代码可读性。 |

### 所选题解
- **Xy_top（4星）**
    - **关键亮点**：思路清晰，代码注释丰富，便于理解。
    - **核心代码**：
```cpp
for (int l = 1; l <= n; l ++) {
    for (int i = 1; i <= n; i ++) {
        for (int j = 1; j <= n; j ++) {
            f[i][j] = min (f[i][j], f[i][l] + f[l][j]);
        }
    }
}
while (q --) {
    cin >> x >> y;
    x %= n;
    y %= n;
    if (x == 0) x += n;
    if (y == 0) y += n;
    if (f[x][y]) {
        if (f[x][y] >= 100000000) cout << -1;
        else cout << f[x][y];
    }
    cout << "\n";
}
```
    - **核心思想**：先用 Floyd 算法预处理小矩阵中任意两点间的最短路，再对每次询问的顶点编号取模映射到小矩阵内，根据预处理结果输出答案。
- **KidzzZip（4星）**
    - **关键亮点**：对代码关键部分有详细解释，适合初学者。
    - **核心代码**：
```cpp
for(int f=1;f<=n;f++) {
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=n;j++) {
            dis[i][j]=min(dis[i][j],dis[i][f]+dis[f][j]);
        }
    }
}
for(int i=1;i<=q;i++) {
    scanf("%lld%lld",&x,&y);
    printf("%lld\n",dis[(x%n==0)?n:x%n][(y%n==0)?n:y%n]!=1e9?dis[(x%n==0)?n:x%n][(y%n==0)?n:y%n]:-1); 
}
```
    - **核心思想**：同样使用 Floyd 算法预处理，询问时对顶点编号取模，根据小矩阵的最短路信息输出结果。
- **良心WA题人（4星）**
    - **关键亮点**：对方法的正确性进行了证明，逻辑严谨。
    - **核心代码**：
```cpp
for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
while(q--)
{
    long long u,v;
    scanf("%lld%lld",&u,&v);
    u=(u-1)%n+1,v=(v-1)%n+1;
    printf("%d\n",f[u][v]==0x3f3f3f3f?-1:f[u][v]);
}
```
    - **核心思想**：Floyd 预处理后，对询问的顶点编号进行取模映射，根据结果输出最短路或 -1。

### 最优关键思路与技巧
- **思维方式**：通过观察大矩阵由小矩阵复制得到的特点，将复杂的大矩阵问题转化为简单的小矩阵问题，降低问题难度。
- **算法优化**：使用 Floyd 算法预处理任意两点间的最短路，使每次询问的时间复杂度降为 $O(1)$。
- **代码实现技巧**：利用取模运算将顶点编号映射到小矩阵内，简洁高效地处理大矩阵的顶点编号。

### 拓展思路
同类型题或类似算法套路：
- 矩阵重复拼接构成新图，求图的连通性或最短路径问题。
- 具有周期性或重复性结构的图论问题，可通过提取基本单元进行处理。

### 洛谷推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法在动态图中的应用。
- [P2910 [USACO08OPEN]Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910)：经典的 Floyd 算法求最短路问题。
- [P2934 [USACO09JAN]Safe Travel G](https://www.luogu.com.cn/problem/P2934)：在图中求最短路径相关问题，可加深对图论算法的理解。

### 个人心得摘录与总结
- **良心WA题人**：赛时没证明直接凭感觉做题，后来补充证明。这提醒我们做题时可以先凭直觉尝试，但赛后要完善证明，确保方法的正确性。

---
处理用时：55.46秒
# 题目信息

# [ARC009B] おとぎの国の高橋君

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc009/tasks/arc009_2

高橋君の住むAtCoder国では、私達が普段使用する数字と同様に $ 10 $ 個のアラビア数字 $ (0-9) $ の $ 10 $ 進数が使われています。  
 しかし、私達が普段使用する数字は大小関係が $ 0\ の順になっているのに対して、

AtCoder国の数字ではその大小関係が異なっています。

例えば、AtCoder国の数字では\ 0\ の順になっている場合、AtCoder国では\ 9 $ よりも $ 8 $ の方が大きいことになります。また、$ 97 $ よりも $ 72 $ の方が大きいことになります。  
  
 AtCoder国の数字の大小関係といくつかの数が与えられるので、AtCoder国の数字の大小関係で昇順に並び替えてください。  
 なお、私達が普段使用する数字同様、AtCoder国で最も小さい数字は $ 0 $ であることは決まっています。 入力は以下の形式で標準入力から与えられる。

> $ b_0 $ $ b_1 $ ‥‥ $ b_9 $ $ N $ $ a_0 $ $ a_1 $ : : $ a_{N-1} $

- 入力は $ N+2 $ 行ある。
- $ 1 $ 行目には、AtCoder国での $ 1 $ 桁の数字の大小関係が与えられる。 
  - AtCoder国では $ b_0\ であることを表している。 $
  - $ b_0 $ は必ず $ 0 $ である。
  - 重複する数字は存在せず、$ 0 $ から $ 9 $ までの数字が $ 1 $ 度ずつ現れる。
- $ 2 $ 行目には並び替える数の個数を表す整数 $ N(1≦N≦777) $ が与えられる。
- $ 3 $ 行目からの $ N $ 行には、$ j+3 $ 行目に並び替える数を表す整数 $ a_j(1≦a_j≦777,777,777) $ が与えられる。
 
 与えられた数をAtCoder国の数字の大小関係にあわせて昇順に並び替え、標準出力に $ 1 $ 行に $ 1 $ つの数字ずつ出力せよ。  
 なお、最後には改行を出力せよ。 ```

0 8 1 3 5 4 9 7 6 2
10
1
2
3
4
5
6
7
8
9
10
```

 ```

8
1
3
5
4
9
7
6
2
10
```

- AtCoder国ではこの大小関係の場合、$ 0,\ 8,\ 1,\ 3,\ 5,\ 4,\ 9,\ 7,\ 6,\ 2,\ 80,\ 88,\ 81,\ 83,\ ...,\ 86,\ 82,\ 10,\ 18,\ 11,\ ... $ の順に大きくなるので、答えは上記の順になります。
 
```

0 9 8 7 6 5 4 3 2 1
3
13467932
98738462
74392
```

 ```

74392
98738462
13467932
```

- $ 5 $ 桁の数は $ 8 $ 桁の数よりも小さいので、$ 1 $ 番は $ 74392 $ になります。
- $ 98738462 $ と $ 13467932 $ では最上位の $ 9 $ は$ 1 $ より小さいので、$ 98738462 $ が $ 2 $ 番目、$ 13467932 $ が $ 3 $ 番目になります。
 
```

0 1 2 3 4 5 6 7 8 9
4
643
1234
43
909
```

 ```

43
643
909
1234
```

- 私達の普段使用する数と同じ大小関係に昇順に並べます。
 
```

0 7 4 3 9 5 6 2 1 8
2
333
333
```

 ```

333
333
```

 ```

0 2 4 6 8 1 3 5 7 9
1
10
```

 ```

10
```

# AI分析结果

### 题目翻译
高桥君居住的 AtCoder 国，和我们平时使用的情况一样，采用包含 10 个阿拉伯数字（0 - 9）的十进制数。
然而，我们平时使用的数字大小关系是 0 < 1 < 2 < … < 9，而 AtCoder 国的数字大小关系与此不同。

例如，在 AtCoder 国的数字大小关系为 0 < 8 < 1 < 3 < 5 < 4 < 9 < 7 < 6 < 2 时，在 AtCoder 国 8 比 9 大，97 比 72 小。

现在给定 AtCoder 国数字的大小关系以及一些数，请按照 AtCoder 国数字的大小关系将这些数按升序排列。
需要注意的是，和我们平时使用的数字一样，AtCoder 国最小的数字确定是 0。输入将以以下形式从标准输入给出：

> $ b_0 $ $ b_1 $ … $ b_9 $ $ N $ $ a_0 $ $ a_1 $ … $ a_{N - 1} $

- 输入共有 $ N + 2 $ 行。
- 第一行给出 AtCoder 国一位数字的大小关系。
  - 表示在 AtCoder 国 $ b_0 < b_1 < … < b_9 $。
  - $ b_0 $ 必定为 0。
  - 数字不会重复，0 到 9 的数字各出现一次。
- 第二行给出要排序的数的个数 $ N(1 ≤ N ≤ 777) $。
- 从第三行开始的 $ N $ 行中，第 $ j + 3 $ 行给出要排序的数 $ a_j(1 ≤ a_j ≤ 777,777,777) $。

请将给定的数按照 AtCoder 国数字的大小关系升序排列，并将结果按每行一个数字的形式输出到标准输出。最后要输出换行符。

### 综合分析与结论
这些题解的核心都是对给定的数字按照 AtCoder 国的数字大小关系进行排序。不同题解采用了不同的排序算法和实现方式。

| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| CZQ_King | 类似基数排序，从个位到最高位依次处理，将数字放入对应的桶中再取出 | 定义结构体存储桶信息，使用队列简化操作 | 处理不同大小关系的数字排序 | 4星 |
| MattL | 使用 `sort` 函数，自定义 `cmp` 比较函数 | 比较时先看位数，再逐位比较 | 实现自定义的比较逻辑 | 4星 |
| LiveZoom | 使用 `sort` 函数，用二维数组存储数字大小关系 | 先存储大小关系，再在比较函数中使用 | 存储和使用大小关系 | 3星 |
| monstersqwq | 使用 `sort` 函数，用数组记录大小关系，将字符串转换为对应数值比较 | 转换字符串为数值进行比较 | 转换过程的实现 | 3星 |
| happybob | 使用类和运算符重载，先使用 `to_string` 转换，后优化为字符串和友元函数 | 运算符重载实现比较逻辑 | 运算符重载和友元函数的使用 | 3星 |
| _Ayanami_ | 用字符串处理，将数字转换为正常数字后排序 | 替换字符后排序 | 字符替换的实现 | 3星 |
| 智子·起源 | 用结构体排序，记录数字本身和其在新规则下的大小 | 结构体排序和大小计算 | 计算数字在新规则下的大小 | 3星 |
| RioBlu | 使用选择排序，用字符串存储数字，用数组记录权值 | 选择排序和比较函数 | 选择排序的实现 | 2星 |

### 所选题解
- **CZQ_King（4星）**
  - 关键亮点：使用类似基数排序的方法，从个位到最高位依次处理，通过队列存储数字，实现排序。
```cpp
struct S{
    int num;
    queue<int>q;
}x[10];
int main(){
    for(int i=0;i<10;i++)cin>>x[i].num;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
        len=max(len,(int)log10(a[i])+1);
    }
    for(int i=1;i<=len;i++){
        int po=pow(10,i-1),k=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<10;j++){
                if(a[i]/po%10==x[j].num){
                    x[j].q.push(a[i]);
                    break;
                }
            }
        }
        for(int i=0;i<10;i++){
            while(!x[i].q.empty()){
                a[k++]=x[i].q.front();
                x[i].q.pop();
            }
        }
    }
    for(int i=0;i<n;i++)cout<<a[i]<<endl;
}
```
- **MattL（4星）**
  - 关键亮点：使用 `sort` 函数，自定义 `cmp` 比较函数，简洁高效。
```cpp
inline bool cmp(string a,string b)
{
    if(a.size()!=b.size())return a.size()<b.size();
    for (int i = 0; i < a.size(); ++i) {
        if(a[i]!=b[i])return c[a[i]-'0']<c[b[i]-'0'];
    }
    return false;
}
int main() {
    for (int i = 0; i <10; ++i) {
        c[read()]=i;
    }
    n=read();
    for (int i = 0; i < n; ++i) {
        cin>>b[i];
    }
    sort(b,b+n,cmp);
    for (int i = 0; i < n; ++i) {
        cout<<b[i]<<endl;
    }
    return 0;
}
```

### 最优关键思路或技巧
- 使用 `sort` 函数并自定义比较函数是比较简洁高效的方法，能方便地处理不同的排序规则。
- 用数组或结构体记录数字的大小关系，在比较时直接使用，能快速判断数字的大小。

### 可拓展之处
同类型题可能会有不同的排序规则，如按照字符的字典序、自定义的字符优先级等进行排序。类似算法套路可以是根据不同的规则自定义比较函数，然后使用排序算法进行排序。

### 推荐洛谷题目
- P1177 【模板】快速排序
- P1093 奖学金
- P1068 分数线划定

### 个人心得摘录与总结
- **happybob**：原代码使用 `to_string()` 效率低，因为每次转 `string` 很慢，优化为直接使用 `string` 并结合友元函数进行运算符重载，速度提升了几十毫秒。总结：在处理字符串相关问题时，要注意避免频繁的类型转换，选择合适的数据类型和实现方式可以提高效率。 

---
处理用时：42.96秒
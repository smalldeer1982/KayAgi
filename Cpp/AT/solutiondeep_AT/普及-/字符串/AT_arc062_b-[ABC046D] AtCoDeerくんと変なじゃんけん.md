# 题目信息

# [ABC046D] AtCoDeerくんと変なじゃんけん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc046/tasks/arc062_b

シカのAtCoDeerくんは友達のTopCoDeerくんとあるゲームをして対戦しています。 このゲームは $ N $ ターンからなります。各ターンではそれぞれのプレイヤーはじゃんけんのグーかパーを出します。ただし、各プレイヤーは次の条件を満たす必要があります。

(※) 各ターンの後で、(今までにパーを出した回数)$ ≦ $(今までにグーを出した回数) を満たす

このゲームでの各プレイヤーの得点は、(勝ったターンの数) $ - $ (負けたターンの数) です。 AtCoDeerくんは特殊能力を持っているので、ゲームが始まる前にTopCoDeerくんの出す $ N $ ターンの手を全て知ることが出来ました。 AtCoDeerくんの各ターンでの手を決めて、AtCoDeerくんの得点を最大化してください。 TopCoDeerくんの出す手の情報は文字列 $ s $ で与えられます。 $ s $ の $ i(1≦i≦N) $ 文字目が `g`のときは $ i $ ターン目でTopCoDeerくんがグーを出すことを、 `p`のときはパーを出すことを表します。

## 说明/提示

### 制約

- $ 1≦N≦10^5 $
- $ N=|s| $
- $ s $ の各文字は`g`か`p`
- $ s $ で表される手は、条件(※)を満たしている

### Sample Explanation 1

常に相手とあいこになるように手を出すことで、$ 0 $点を取ることができて、これが最大値です。

### Sample Explanation 2

例えばグー,パー,グー,パー,グー,グー,パー,パー,グー,パー と出すことで、 $ 3 $回勝って$ 1 $回負けているので得点は$ 2 $点になり、これが最大値です。

## 样例 #1

### 输入

```
gpg```

### 输出

```
0```

## 样例 #2

### 输入

```
ggppgggpgg```

### 输出

```
2```

# AI分析结果

### 题目翻译
### [ABC046D] AtCoDeer 君与奇怪的猜拳

#### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc046/tasks/arc062_b

鹿 AtCoDeer 君正在和他的朋友 TopCoDeer 君进行一场游戏对战。这个游戏由 $N$ 轮组成。在每一轮中，每个玩家都要出石头或布。不过，每个玩家都需要满足以下条件：
(※) 每一轮结束后，（到目前为止出布的次数）$ \leq $（到目前为止出石头的次数）

这个游戏中每个玩家的得分是（赢的轮数）$ - $（输的轮数）。AtCoDeer 君拥有特殊能力，所以在游戏开始前，他就能知道 TopCoDeer 君在 $N$ 轮中出的所有手势。请确定 AtCoDeer 君每一轮的手势，以使 AtCoDeer 君的得分最大化。TopCoDeer 君的出拳信息用字符串 $s$ 表示。当 $s$ 的第 $i(1\leq i\leq N)$ 个字符为 `g` 时，表示第 $i$ 轮 TopCoDeer 君出石头；当为 `p` 时，表示出布。

#### 说明/提示
##### 限制条件
- $ 1\leq N\leq 10^5 $
- $ N = |s| $
- $ s $ 的每个字符为 `g` 或 `p`
- $ s $ 表示的手势满足条件(※)

##### 样例解释 1
总是和对手出相同的手势，这样可以得 $0$ 分，这就是最大值。

##### 样例解释 2
例如，按石头、布、石头、布、石头、石头、布、布、石头、布的顺序出拳，赢了 $3$ 次，输了 $1$ 次，所以得分为 $2$ 分，这就是最大值。

#### 样例 #1
##### 输入
```
gpg
```
##### 输出
```
0
```

#### 样例 #2
##### 输入
```
ggppgggpgg
```
##### 输出
```
2
```

### 综合分析与结论
这些题解大多采用贪心算法，核心思路是“能出布就出布”，因为出布要么平局，要么赢，而石头可能输。需要注意满足“出布次数小于等于出石头次数”这一条件。

### 题解评分与分析
| 作者 | 评分 | 思路要点 | 代码可读性 | 优化程度 | 亮点 |
| --- | --- | --- | --- | --- | --- |
| QwQ蒟蒻wjr | 4星 | 模拟过程，记录石头和布的数量，根据对手出拳和条件更新得分 | 较好 | 一般 | 思路清晰，代码结构完整 |
| 精神小伙！ | 4星 | 遵循“能出布就出布”原则，注意石头数量要大于等于布的数量 | 好 | 一般 | 代码简洁易懂 |
| zcl1024 | 4星 | 贪心策略，根据条件判断出拳，更新得分 | 好 | 一般 | 同时给出了 C++ 和 Pascal 代码 |

### 所选题解
- **QwQ蒟蒻wjr（4星）**
    - 关键亮点：思路清晰，代码结构完整，有自定义的输入函数。
    - 核心代码：
```cpp
#include<cstdio>
#include<cstring>
#define re register
using namespace std;
template<typename T>
inline void read(T&x)
{
    x=0;
    char s=getchar();
    bool f=false;
    while(!(s>='0'&&s<='9'))
    {
        if(s=='-')
            f=true;
        s=getchar();
    }
    while(s>='0'&&s<='9')
    {
        x=(x<<1)+(x<<3)+s-'0';
        s=getchar();
    }
    if(f)
        x=(~x)+1;
}
char s[1000010],len;
long long ans,sum_1,sum_2;
bool col[1000010];
int main()
{
    scanf("%s",s+1);
    len=strlen(s+1);
    for(int i=1; i<=len; ++i)
    {
        if(s[i]=='p')
        {
            if(sum_1<sum_2)
                sum_1++;
            else
            {
                sum_2++;
                ans--;
            }
        }
        else
        {
            if(sum_1<sum_2)
            {
                sum_1++;
                ans++;
            }
            else
                sum_2++;
        }
    }
    printf("%lld\n",ans);
}
```
核心实现思想：通过遍历对手的出拳字符串，根据当前石头和布的数量关系以及对手的出拳情况，决定出石头还是布，并更新得分。

- **精神小伙！（4星）**
    - 关键亮点：代码简洁易懂，注释清晰。
    - 核心代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;
string s;
int main()
{
    int ans=0;
    int x=0;//石头的数量 
    int y=0;//布的数量
    cin>>s;
    int len=s.size();
    for(int i=0;i<len;++i)
    {
        if(x==y)//题目规定，石头的数量大于等于布的数量，这时只能出石头
        {
            x++;
            if(s[i]=='p') ans--; //如果对手出布就减一分
            continue;
        } 
        y++;
        if(s[i]=='g') ans++;//如果对手出石头就加一分 
    } 
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：同样遍历对手出拳字符串，当石头和布数量相等时出石头，否则出布，根据对手出拳更新得分。

- **zcl1024（4星）**
    - 关键亮点：同时给出了 C++ 和 Pascal 代码，方便不同语言的学习者。
    - 核心代码（C++）：
```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string a;
    cin>>a;
    int len=a.size();
    int i;
    int x=0,y=0,ans=0;
    for (i=0;i<len;i++){
        if (x==y){//根据规定，这时候只能出石头
            x++;
            if (a[i]=='p') ans--;//如果对方出布，就扣分
        }
        else{
            y++;
            if (a[i]=='g') ans++;//如果对方出石头，就加分
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
核心实现思想：与前面题解类似，根据石头和布数量关系以及对手出拳更新得分。

### 最优关键思路或技巧
- **贪心策略**：能出布就出布，因为布的收益更高。
- **条件判断**：注意出布次数不能超过出石头次数，在满足条件的情况下出布。

### 可拓展之处
同类型题目可能会增加更多的出拳种类，或者改变得分规则，解题时依然可以考虑贪心策略，根据不同出拳的收益来决定最优选择。

### 推荐题目
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心算法的经典题目，通过合理安排顺序使总等待时间最短。
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：利用贪心思想进行分组，使分组数量最少。
- [P2240 食草的奶牛](https://www.luogu.com.cn/problem/P2240)：贪心选择每头牛的吃草区间，使总覆盖时间最长。

### 个人心得摘录与总结
部分作者认为题目难度被高估，实际是一道简单的贪心题，关键在于理解“能出布就出布”的贪心策略以及满足出布次数限制的条件。 

---
处理用时：48.77秒
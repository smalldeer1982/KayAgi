# 题目信息

# 2015

## 题目描述

[problemUrl]: https://atcoder.jp/contests/NYC2015/tasks/nyc2015_1

入力は以下の形式で標準入力から与えられる。

> $ N $

 `Yes` または `No` と出力せよ。 ```

2015
```

 ```

Yes
```

 ```

2016
```

 ```

No
```

## 说明/提示

### Constraints

すぬけ君は、$ 2015 $ を $ 2 $ 進数で表すと `11111011111` となり回文になっていることに気づいた。 整数 $ N $ を (余計な $ 0 $ をつけない) $ 2 $ 進数で表したとき、回文になっているかどうか判定せよ。 ただし、左から呼んでも右から読んでも同じ文字列を回文という。

- - - - - -

- $ 1\ \leq\ N\ \leq\ 10^9 $

# AI分析结果

### 题目中文重写
#### 题目描述
输入将以以下形式从标准输入给出：
> $ N $

请输出 `Yes` 或 `No`。

示例：
```
2015
```
```
Yes
```
```
2016
```
```
No
```

#### 说明/提示
#### 约束条件
すぬけ君发现，将 $ 2015 $ 用二进制表示为 `11111011111`，它是一个回文。请判断整数 $ N $ 用（不添加多余 $ 0 $）二进制表示时是否为回文。这里，从左向右读和从右向左读都相同的字符串称为回文。

- $ 1 \leq N \leq 10^9 $

### 综合分析与结论
这些题解的核心思路都是将输入的十进制数转换为二进制，然后判断该二进制数是否为回文。不同题解在实现二进制转换和回文判断的方式上各有不同，有的借助 STL 容器，有的使用位运算，还有的用字符串处理。

### 所选题解
- **fa_555（4星）**
    - **关键亮点**：使用 `std::bitset` 进行二进制转换，实现了与 `unsigned long` 和 `std::string` 之间的类型转换，代码简洁且时空复杂度为 $O(\frac{n}{64})$。
    - **核心代码**：
```cpp
#include<algorithm>
#include<bitset>
#include<cmath>
#include<iostream>
#include<string>

using namespace std;

int N;
bitset<32> bit;
string s, r;

int main() {
    cin >> N;
    bit = (unsigned)N;
    s = r = bit.to_string().substr(32 - log2(N));
    reverse(r.begin(), r.end());
    cout << (s == r ? "Yes" : "No") << '\n';
    return 0;
}
```
核心实现思想：利用 `bitset` 存储输入数的二进制形式，通过 `to_string()` 方法将其转换为字符串，去除高位多余的 `0` 后，反转字符串并与原字符串比较判断是否为回文。

- **做梦想Peach（4星）**
    - **关键亮点**：使用快读优化输入，代码简洁，通过简单的循环将十进制数转换为二进制数组，然后直接判断数组是否为回文。
    - **核心代码**：
```cpp
int read () {
    int s=0,w=1;
    char ch=getchar();
    while (ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
    while (ch>='0' && ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return s*w;
}
int n,s[50],x,i;
int main () {
    n=read();
    while (n>=1) {
        s[x]=n%2;
        n/=2;
        x++;
    }
    x--;
    for (i=0;i<=x/2;i++)
        if (s[i]!=s[x-i]) {
            puts ("No");
            return 0;
        }
    puts ("Yes");
    return 0;
}
```
核心实现思想：通过快读读取输入，将十进制数转换为二进制数组，然后从数组两端向中间比较元素是否相等来判断是否为回文。

- **3water（4星）**
    - **关键亮点**：利用栈和队列的特性，栈是“后进先出”，队列是“先进先出”，将二进制位分别存入栈和队列，比较栈顶和队列头元素判断是否为回文。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,len;
stack<int>s1;
queue<int>s2;
int main() {
    cin >> n;
    while (n) {
        s1.push(n & 1);
        s2.push(n & 1);
        n >>= 1;
    }
    len = s1.size() / 2;
    while (len--) {
        if (s1.top() != s2.front()) {
            cout << "No\n";
            return 0;
        }
        s1.pop();
        s2.pop();
    }
    cout << "Yes\n";
    return 0;
}
```
核心实现思想：利用位运算将十进制数转换为二进制位，分别存入栈和队列，比较栈顶和队列头元素，若不同则不是回文，若全部相同则是回文。

### 最优关键思路或技巧
- **使用 `std::bitset`**：可以方便地进行二进制转换和类型转换，简化代码实现。
- **位运算**：如 `n & 1` 可以快速获取二进制的末位，`n >>= 1` 可以快速右移一位，提高效率。
- **栈和队列**：利用栈和队列的特性，可以快速判断回文。

### 可拓展之处
同类型题目可能会要求判断其他进制下的数是否为回文，或者判断一个字符串是否为回文等。类似算法套路可以是先进行进制转换或字符串处理，然后使用双指针、栈和队列等方法判断是否为回文。

### 推荐洛谷题目
- P1015 [NOIP1999 普及组] 回文数
- P1307 数字反转
- P5738 [深基7.例4] 歌唱比赛

### 个人心得摘录与总结
- **Null_Cat**：写完题解后发现没有用 STL 的 `reverse` 函数求解的，看到别人用 `bitset` 觉得自己很菜，体现了对不同解题方法的认识和学习他人优秀思路的感悟。
- **做梦想Peach**：认为题目难度最多是橙题，强调删去快读和没用的头文件后代码简洁，体现了对题目难度的看法和对代码简洁性的追求。
- **Anguei**：发出“人生苦短，我用 Python”的感慨，体现了对 Python 语言简洁性的认可。

---
处理用时：38.06秒
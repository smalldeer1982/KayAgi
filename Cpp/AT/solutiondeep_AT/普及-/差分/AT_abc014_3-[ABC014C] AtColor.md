# 题目信息

# [ABC014C] AtColor

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc014/tasks/abc014_3

 AtColor社は，$ 0 $ から $ 1,000,000 $ まで $ 1,000,001 $ 通りの濃さがある灰色の絵の具を販売することにしました．$ 0 $ が最も黒く，$ 1,000,000 $ が最も白い絵の具です．

 しかし，途方も無い数の濃さのバリエーションがある一方，消費者には細かい違いが分からないということが判明しました．これを知ったAtColor社は，売れない濃さの絵の具を生産するのはやめて，最も人気のある濃さの色の絵の具1つだけを販売することにしました．

 AtColor社は上記を達成するために，最も人気な絵の具がどのくらい売れるかをアンケート調査で調べることにしました． AtColor社がどの範囲の濃さの絵の具なら購入したいかというアンケートを消費者に対して行ったところ， 「$ a\ ≦\ x\ ≦\ b $ を満たす濃さ $ x $ の絵の具ならば購入する」という形式の情報が $ n $ 件得られました．

 あなたの仕事は，これらの情報から，最も多くの消費者に購入される濃さの絵の具について，その絵の具を購入する消費者の数を出力するプログラムを作ることです．

## 说明/提示

### 部分点

この問題には2つのデータセットがあり，データセット毎に部分点が設定されている．

- $ 1≦n≦2,000 $ を満たすデータセット 1 に正解した場合は $ 30 $ 点が与えられる．
- 追加制約のないデータセット 2 に正解した場合は，上記のデータセットとは別に $ 70 $ 点が与えられる．

### Sample Explanation 1

\- 濃さ $ 0,1,4,5,6 $ の絵の具は，1人の消費者によって購入してもらえます． - 濃さ $ 2 $ の絵の具は，3人の消費者によって購入してもらえます． - 濃さ $ 3 $ の絵の具は，2人の消費者によって購入してもらえます． - 他の濃さの絵の具は誰にも購入してもらえません． よって，$ 3 $ を出力します．

## 样例 #1

### 输入

```
4

0 2

2 3

2 4

5 6```

### 输出

```
3```

## 样例 #2

### 输入

```
4

1000000 1000000

1000000 1000000

0 1000000

1 1000000```

### 输出

```
4```

# AI分析结果

### 题目内容重写

AtColor社销售从0到1,000,000共1,000,001种不同深浅的灰色颜料。0表示最黑，1,000,000表示最白。然而，消费者无法分辨过于细微的差异，因此AtColor社决定只生产并销售最受欢迎的颜料。为了确定最受欢迎的颜料，AtColor社进行了消费者调查，收集了n条信息，每条信息表示消费者愿意购买的颜色范围[a, b]。你的任务是编写程序，找出被最多消费者选择的颜色，并输出选择该颜色的消费者数量。

### 样例输入输出

#### 样例1
**输入：**
```
4
0 2
2 3
2 4
5 6
```
**输出：**
```
3
```

#### 样例2
**输入：**
```
4
1000000 1000000
1000000 1000000
0 1000000
1 1000000
```
**输出：**
```
4
```

### 题解分析与结论

本题的核心是通过差分数组来高效处理区间修改问题。差分数组可以在O(1)时间内完成区间修改，并通过前缀和恢复原数组，最终找出最大值。这种方法将时间复杂度从O(n^2)优化到O(n)，适用于大规模数据处理。

### 精选题解

#### 题解1：Grisses (★★★★★)
**关键亮点：**
- 使用差分数组进行区间修改，时间复杂度为O(1)。
- 通过前缀和恢复原数组，最终找出最大值。
- 代码简洁明了，易于理解。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,ans,x[1000005];
signed main()
{
    scanf("%d",&n);
    while(n--){
        scanf("%d%d",&a,&b);
        x[a]++;
        x[b+1]--;
    }
    ans=x[0];
    for(int i=1;i<=1000000;i++)x[i]+=x[i-1],ans=max(ans,x[i]);
    printf("%d\n",ans);
    return 0;
}
```

#### 题解2：zjyqwq (★★★★☆)
**关键亮点：**
- 详细解释了差分数组的原理和应用。
- 提供了Pascal代码，适合不同编程语言的学习者。
- 通过优化记录最大区间编号，减少不必要的计算。

**核心代码：**
```Pascal
var
n,i,x,y,j,ans,m:longint;
a,s:Array[-10..10000000]of longint;
begin
  readln(n);m:=0;
  for i:=1 to n do 
   begin
    readln(x,y);
    a[x]:=a[x]+1;a[y+1]:=a[y+1]-1;
    if y+1>m then m:=y+1;
   end;
  for i:=0 to m do
  begin
   a[i]:=a[i-1]+a[i];
   if a[i]>ans then ans:=a[i];
  end;
  writeln(ans);
end.
```

#### 题解3：tZEROちゃん (★★★★☆)
**关键亮点：**
- 详细解释了差分数组与前缀和的关系。
- 提供了模板代码，便于理解和应用。
- 强调了差分数组在区间修改中的高效性。

**核心代码：**
```cpp
for(int i = 1; i <= n; i++) {
  scanf("%d", &d[i]);
}
for(int i = 1; i <= m; i++) {
  int l, r, k;
  cin >> l >> r >> k;
  b[l] += k;
  b[r + 1] -= k;
}
for (int i = 1; i <= n; i++) {
  a[i] = a[i - 1] + b[i];
}
for (int i = 1; i <= n; i++) {
  s[i] = d[i] + a[i];
}
```

### 最优关键思路与技巧

- **差分数组**：通过差分数组在O(1)时间内完成区间修改，再通过前缀和恢复原数组，最终找出最大值。
- **前缀和**：利用前缀和快速计算区间和，适用于大规模数据处理。
- **优化记录**：通过记录最大区间编号，减少不必要的计算，提高效率。

### 拓展与举一反三

- **类似题目**：P3368 【模板】树状数组 1、P3374 【模板】树状数组 2、P1908 逆序对。
- **算法套路**：差分数组适用于区间修改问题，前缀和适用于区间求和问题，两者结合可以高效处理大规模数据。

### 推荐题目

1. P3368 【模板】树状数组 1
2. P3374 【模板】树状数组 2
3. P1908 逆序对

### 个人心得总结

- **调试经历**：在实现差分数组时，需要注意区间边界处理，特别是右边界加1的操作。
- **踩坑教训**：未记录最大区间编号会导致不必要的计算，影响程序效率。
- **顿悟感想**：差分数组与前缀和的结合，能够高效处理区间修改和求和问题，是算法设计中的重要技巧。

---
处理用时：41.36秒
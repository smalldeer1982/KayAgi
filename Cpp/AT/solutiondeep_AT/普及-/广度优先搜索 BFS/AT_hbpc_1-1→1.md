# 题目信息

# 1→1

## 题目描述

$m$表示变化规则的数量，$n$表示要生成$1$的数量。

对于生成规则$a_{i},b_{i}$而言，它表示可以将原字符串中的$a_{i}$个$1$变为$b_{i}$个$1$。例如，$a_{i}=2,b_{i}=3$，表示原字符串中$11$可以变为$111$

现在，原字符串中只有$1$个$1$，要求你使用最少的变化次数将字符串变成$n$个$1$。

## 说明/提示

- $1≤m≤300^{2}$
- $1≤n≤10000$
- $1≤a_{i},b_{i}≤300$
- 当$i≠j$时保证$a_{i}≠a_{j}$且$b_{i}≠b_{j}$


### 样例$1$

规则为：

$1->11$

$111->11111$

那么一个$1$变成$11111$需要经过下面这些步骤：

1->11

11->111

111->1111

变化次数为$3$，故答案为$4$。

### 样例$2$

规则为：

$1->111$

$11111->111$

那么一个$1$不可能变成$111111$，故答案为$-1$。

# AI分析结果

### 题目内容重写（中文）
$m$表示变化规则的数量，$n$表示要生成$1$的数量。

对于生成规则$a_{i},b_{i}$而言，它表示可以将原字符串中的$a_{i}$个$1$变为$b_{i}$个$1$。例如，$a_{i}=2,b_{i}=3$，表示原字符串中$11$可以变为$111$。

现在，原字符串中只有$1$个$1$，要求你使用最少的变化次数将字符串变成$n$个$1$。

### 说明/提示
- $1≤m≤300^{2}$
- $1≤n≤10000$
- $1≤a_{i},b_{i}≤300$
- 当$i≠j$时保证$a_{i}≠a_{j}$且$b_{i}≠b_{j}$

### 样例$1$
规则为：
$1->11$
$111->11111$

那么一个$1$变成$11111$需要经过下面这些步骤：
1->11
11->111
111->1111

变化次数为$3$，故答案为$4$。

### 样例$2$
规则为：
$1->111$
$11111->111$

那么一个$1$不可能变成$111111$，故答案为$-1$。

---

### 综合分析与结论
本题的核心是通过广度优先搜索（BFS）来寻找从初始状态（1个1）到目标状态（n个1）的最短路径。由于题目要求最少的变化次数，BFS是最合适的算法，因为它能够逐层扩展，确保找到的路径是最短的。

### 题解对比与评分
1. **翼德天尊**（评分：4星）
   - **关键亮点**：详细解释了BFS的原理及其在本题中的应用，代码结构清晰，注释详细。
   - **个人心得**：作者提到刚开始误将300²看成300，导致多次提交失败，提醒了读者在审题时要仔细。

2. **风急风也清**（评分：4星）
   - **关键亮点**：提供了BFS的详细思路，代码简洁明了，逻辑清晰。
   - **个人心得**：强调了输出必须换行，提醒了读者注意题目细节。

3. **EuphoricStar**（评分：4星）
   - **关键亮点**：代码简洁，使用了剪枝优化，避免了不必要的状态扩展。
   - **个人心得**：作者提到输出记得换行，提醒了读者注意题目要求。

### 最优关键思路与技巧
- **BFS逐层扩展**：通过队列逐层扩展状态，确保找到的路径是最短的。
- **剪枝优化**：通过限制状态的范围（如`n+300`），避免无效状态的扩展，提高算法效率。
- **状态标记**：使用`vis`数组记录已经访问过的状态，避免重复访问。

### 可拓展之处
- **类似算法套路**：BFS广泛应用于最短路径问题，如迷宫问题、图的最短路径等。
- **优化思路**：可以通过排序规则，提前终止无效的搜索路径，进一步优化算法。

### 推荐题目
1. **P1141 01迷宫**（题号：1141）
2. **P1443 马的遍历**（题号：1443）
3. **P1162 填涂颜色**（题号：1162）

### 核心代码片段
```cpp
#include <bits/stdc++.h>
using namespace std;
int m, n, a[90001], b[90001], v[20000];
struct node { int l, x; };
queue<node> q;

int main() {
    scanf("%d %d", &m, &n);
    for (int i = 1; i <= m; i++) scanf("%d %d", &a[i], &b[i]);
    if (n == 1) { printf("1\n"); return 0; }
    q.push({1, 1}); v[1] = 1;
    while (!q.empty()) {
        node no = q.front(); q.pop();
        for (int i = 1; i <= m; i++) {
            if (no.x >= a[i]) {
                node noo = {no.l + 1, no.x - a[i] + b[i]};
                if (v[noo.x] == 0 && noo.x <= n + 300) {
                    if (noo.x == n) { printf("%d\n", noo.l); return 0; }
                    v[noo.x] = 1; q.push(noo);
                }
            }
        }
    }
    printf("-1\n");
    return 0;
}
```

### 个人心得总结
- **审题要仔细**：如翼德天尊提到的误将300²看成300，导致多次提交失败，提醒了读者在审题时要仔细。
- **输出格式**：多位作者提到输出必须换行，提醒了读者注意题目细节。

---
处理用时：81.65秒
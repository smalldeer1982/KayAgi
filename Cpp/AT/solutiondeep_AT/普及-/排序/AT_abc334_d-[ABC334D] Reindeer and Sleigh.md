# 题目信息

# [ABC334D] Reindeer and Sleigh

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_d

$ N $ 台のソリがあり、各ソリには $ 1,2,\ldots,\ N $ の番号がつけられています。

ソリ $ i $ を引くために必要なトナカイは $ R_i $ 匹です。

また、各トナカイが引けるソリは高々 $ 1 $ 台です。より厳密には、$ m $ 台のソリ $ i_1,\ i_2,\ \ldots,\ i_m $ を引くために必要なトナカイは $ \sum_{k=1}^{m}\ R_{i_k} $ 匹です。

以下の形式のクエリが $ Q $ 個与えられるので、答えを求めてください。

- 整数 $ X $ が与えられる。トナカイが $ X $ 匹いるときに最大で何台のソリを引けるか求めよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ R_i\ \leq\ 10^9 $
- $ 1\ \leq\ X\ \leq\ 2\ \times\ 10^{14} $
- 入力される数値はすべて整数
 
### Sample Explanation 1

トナカイが $ 16 $ 匹いるとき、ソリ $ 1,2,4 $ を引くことができます。 $ 16 $ 匹のトナカイで $ 4 $ 台のソリを引くことはできないので、クエリ $ 1 $ の答えは $ 3 $ となります。

## 样例 #1

### 输入

```
4 3

5 3 11 8

16

7

1000```

### 输出

```
3

1

4```

## 样例 #2

### 输入

```
6 6

1 2 3 4 5 6

1

2

3

4

5

6```

### 输出

```
1

1

2

2

2

3```

## 样例 #3

### 输入

```
2 2

1000000000 1000000000

200000000000000

1```

### 输出

```
2

0```

# AI分析结果

### 题目翻译
有 $N$ 辆雪橇，每辆雪橇编号为 $1,2,\ldots,N$。

拉动第 $i$ 辆雪橇需要 $R_i$ 头驯鹿。

此外，每头驯鹿最多只能拉一辆雪橇。更严格地说，拉动 $m$ 辆雪橇 $i_1,i_2,\ldots,i_m$ 需要 $\sum_{k = 1}^{m}R_{i_k}$ 头驯鹿。

现给出 $Q$ 个以下形式的查询，请给出答案。
- 给定整数 $X$。当有 $X$ 头驯鹿时，最多能拉动多少辆雪橇？

### 综合分析与结论
- **思路**：所有题解思路一致，为使拉动雪橇数量最多，需优先选择所需驯鹿少的雪橇。因此先将每辆雪橇所需驯鹿数量从小到大排序，再计算前缀和，最后通过二分查找前缀和数组，找到满足条件的最大雪橇数量。
- **算法要点**：排序、前缀和计算、二分查找。
- **解决难点**：在给定驯鹿数量下，快速确定最多能拉动的雪橇数量。通过排序和前缀和预处理，结合二分查找，将每次查询的时间复杂度从暴力枚举的 $O(n)$ 优化到 $O(\log n)$。

### 所选题解
- **作者：xz001（5星）**
    - **关键亮点**：思路清晰，代码注释详细，对输入输出进行了封装，提高了代码的可读性和复用性。
    - **核心代码**：
```cpp
sort(a + 1, a + n + 1);  //排序
for (int i = 1; i <= n; ++ i) sum[i] = sum[i - 1] + a[i]; //前缀和
while (q -- ) {
    int x;
    scanf("%lld", &x);
    int l = 0, r = n, ans; 
    while (l <= r) {   // 二分
        int mid = (l + r) >> 1;
        if (sum[mid] <= x) {  //若能拉至少 mid 辆车子
            ans = mid;
            l = mid + 1;
        } else {  
            r = mid - 1;
        }
    }
    printf("%lld\n", ans);
}
```
- **作者：jubingkun（4星）**
    - **关键亮点**：对暴力解法进行了分析，并指出其超时原因，进而提出优化思路，使用 `upper_bound` 函数简化二分查找过程。
    - **核心代码**：
```cpp
sort(a + 1, a + n + 1);
for (int i = 1; i <= n; ++i)
    pre[i] = pre[i - 1] + a[i];
while (q--) {
    cin >> x;
    if (x >= sum)	cout << n << "\n";
    else {
        int b = upper_bound(pre + 1, pre + n + 1, x) - pre;
        cout << b - 1 << "\n";
    }
}
```
- **作者：CheZiHe929（4星）**
    - **关键亮点**：代码简洁，使用 `#define int long long` 避免了数据类型转换的问题，同时使用 `std::upper_bound` 函数进行二分查找，提高了代码的简洁性。
    - **核心代码**：
```cpp
std::sort(r+1,r+n+1);//排序
for(int i=1;i<=n;i++)r[i]+=r[i-1];//前缀和
while(q--){
    std::cin>>x;
    int ans=std::upper_bound(r+1,r+n+1,x)-r-1;//二分
    std::cout<<ans<<endl;
}
```

### 最优关键思路或技巧
- **贪心策略**：优先选择所需驯鹿少的雪橇，保证在给定驯鹿数量下能拉动最多的雪橇。
- **前缀和优化**：通过预处理前缀和数组，快速计算拉动前 $i$ 辆雪橇所需的驯鹿总数。
- **二分查找**：利用前缀和数组的单调性，使用二分查找在 $O(\log n)$ 时间内找到满足条件的最大雪橇数量。

### 拓展思路
同类型题目通常涉及贪心策略和二分查找，例如在资源有限的情况下，选择价值最大或数量最多的物品。类似算法套路还包括排序、前缀和、二分查找的组合使用，可用于解决区间查询、最值问题等。

### 洛谷推荐题目
- [P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)：考察二分查找的基本应用。
- [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)：涉及二分查找和贪心策略。
- [P2678 [NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)：结合二分查找和贪心思想解决问题。

### 个人心得
题解中未包含个人心得。

---
处理用时：31.46秒
# 题目信息

# [ABC354C] AtCoder Magics

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_c

高橋くんは、カードゲーム「AtCoder Magics」のカードを $ N $ 枚持っています。$ i $ 番目のカードをカード $ i $ と呼ぶことにします。各カードには強さとコストのパラメーターがあり、カード $ i $ の強さは $ A_i $ で、コストは $ C_i $ です。

高橋くんは、弱いカードは要らないので捨てることにしました。具体的には、以下の操作をできなくなるまで繰り返します。

- $ 2 $ つのカード $ x,\ y $ であって、 $ A_x\ >\ A_y $ かつ $ C_x\ <\ C_y $ であるようなものを選ぶ。カード $ y $ を捨てる。

操作ができなくなったとき、捨てられなかったカードの集合は一意に定まることが証明できます。これを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ C_i\ \leq\ 10^9 $
- $ A_1,\ A_2,\ \dots\ ,A_N $ は全て異なる
- $ C_1,\ C_2,\ \dots\ ,C_N $ は全て異なる
- 入力はすべて整数

### Sample Explanation 1

カード $ 1,\ 3 $ に注目すると、 $ A_1\ <\ A_3 $ かつ $ C_1\ >\ C_3 $ なのでカード $ 1 $ を捨てることができます。 それ以上操作をすることはできません。このときカード $ 2,\ 3 $ が残っているので、これらを出力します。

### Sample Explanation 2

この場合、どのカードも捨てることができません。

## 样例 #1

### 输入

```
3
2 4
1 1
3 2```

### 输出

```
2
2 3```

## 样例 #2

### 输入

```
5
1 1
10 2
100 3
1000 4
10000 5```

### 输出

```
5
1 2 3 4 5```

## 样例 #3

### 输入

```
6
32 101
65 78
2 29
46 55
103 130
52 40```

### 输出

```
4
2 3 5 6```

# AI分析结果

### 题目翻译
### [ABC354C] AtCoder魔法

#### 题目描述
高桥君持有 $N$ 张卡牌游戏「AtCoder魔法」的卡片。我们将第 $i$ 张卡片称为卡片 $i$。每张卡片都有强度和成本这两个参数，卡片 $i$ 的强度是 $A_i$，成本是 $C_i$。

高桥君觉得弱的卡片没有用，于是决定将它们丢弃。具体来说，他会不断重复以下操作，直到无法再进行为止：
- 选择两张卡片 $x$ 和 $y$，满足 $A_x > A_y$ 且 $C_x < C_y$，然后丢弃卡片 $y$。

可以证明，当操作无法继续进行时，未被丢弃的卡片集合是唯一确定的。请你求出这个集合。

#### 说明/提示
##### 限制条件
- $2 \leq N \leq 2 \times 10^5$
- $1 \leq A_i, C_i \leq 10^9$
- $A_1, A_2, \cdots, A_N$ 均互不相同
- $C_1, C_2, \cdots, C_N$ 均互不相同
- 输入的所有值均为整数

##### 样例解释 1
关注卡片 $1$ 和 $3$，由于 $A_1 < A_3$ 且 $C_1 > C_3$，所以可以丢弃卡片 $1$。之后无法再进行其他操作。此时卡片 $2$ 和 $3$ 被保留下来，因此输出这两张卡片。

##### 样例解释 2
在这种情况下，无法丢弃任何卡片。

#### 样例 #1
##### 输入
```
3
2 4
1 1
3 2
```
##### 输出
```
2
2 3
```

#### 样例 #2
##### 输入
```
5
1 1
10 2
100 3
1000 4
10000 5
```
##### 输出
```
5
1 2 3 4 5
```

#### 样例 #3
##### 输入
```
6
32 101
65 78
2 29
46 55
103 130
52 40
```
##### 输出
```
4
2 3 5 6
```

### 综合分析与结论
这些题解的核心思路都是通过排序将问题简化，把二维属性（强度和成本）的比较转化为一维的比较。主要分为两种排序方式：按成本排序和按强度排序。
- **按成本排序**：将卡片按成本从小到大排序，遍历过程中维护当前强度的最大值，若当前卡片强度小于最大值，则该卡片会被丢弃。
- **按强度排序**：将卡片按强度从大到小排序，遍历过程中维护当前成本的最小值，若当前卡片成本大于最小值，则该卡片会被丢弃。

### 所选题解
- **hjyowl（5星）**
    - **关键亮点**：思路清晰，详细分析了暴力解法的不可行性，并给出了正解思路及可行性分析，代码注释详细，可读性高。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long N = 100010;
long long n;
struct owl{
    long long x,y,id;
}a[N];
bool cmp(owl a,owl b){
    return a.y < b.y;
}
int main(){
    cin >> n;
    set<int>st;
    for (long long i = 1; i <= n; i ++ ){
        cin >> a[i].x >> a[i].y;
        st.insert(i);
        a[i].id = i;
    }
    sort(a + 1,a + 1 + n,cmp);
    long long mx = -1e9;
    for (long long i = 1; i <= n; i ++ ){
        mx = max(mx,a[i].x);
        if (a[i].x!= mx){
            st.erase(a[i].id);
        }
    }
    cout << st.size() << endl;
    set<int>::iterator it;
    for (it = st.begin(); it!= st.end(); it ++ ){
        cout << *it << " ";
    }
    return 0;
}
```
    - **核心实现思想**：先按成本对卡片排序，然后遍历卡片，维护当前最大强度，若当前卡片强度不是最大，则从集合中删除该卡片。

- **forever_nope（4星）**
    - **关键亮点**：对解题思路进行了详细的证明，逻辑严谨，代码简洁，使用了自定义的输入输出流重载，提高了代码的复用性。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
template<typename tp>
istream& operator >>(istream &in, vector<tp> &a) {
    for (tp &t : a) in >> t;
    return in;
}
template<typename tp>
ostream& operator <<(ostream &out, vector<tp> &a) {
    for (auto i : a) out << i << " ";
    return out;
}
constexpr int N = 2e5 + 10;
int a[N], c[N];
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n; vector<int> id(n);
    for (int i = 0; i < n; ++i) cin >> a[i] >> c[i], id[i] = i;
    sort(id.begin(), id.end(), [] (int i, int j) { return a[i] > a[j]; });
    int mx = 2e9; vector<int> ans;
    for (int i : id) if (c[i] < mx) mx = c[i], ans.push_back(i + 1);
    sort(ans.begin(), ans.end());
    cout << ans.size() << endl << ans << endl;
    return 0;
}
```
    - **核心实现思想**：按强度对卡片编号排序，遍历过程中维护最小成本，若当前卡片成本小于最小成本，则加入结果集。

### 最优关键思路或技巧
- **排序优化**：通过排序将二维属性的比较转化为一维比较，降低了问题的复杂度。
- **维护最值**：在遍历过程中维护当前的最大强度或最小成本，方便判断卡片是否需要丢弃。

### 可拓展之处
同类型题目可能会增加卡片的属性，或者改变丢弃卡片的规则。解题的关键仍然是通过排序和维护最值来简化问题。

### 洛谷相似题目推荐
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：通过排序和优先队列维护最小值，解决合并果子的最优方案问题。
- [P1104 生日](https://www.luogu.com.cn/problem/P1104)：对人物信息进行排序，根据特定规则输出结果。
- [P1271 选举学生会](https://www.luogu.com.cn/problem/P1271)：对候选人的票数进行排序，输出排名靠前的候选人。

### 个人心得摘录与总结
- **Ryzen_9_7950X**：赛时脑抽，赛后1分钟才调出来。总结：比赛时要保持冷静，避免因紧张而犯错。
- **nightwatch.ryan**：未提及具体心得，但使用优先队列维护最小成本，是一种值得借鉴的思路。 

---
处理用时：47.81秒
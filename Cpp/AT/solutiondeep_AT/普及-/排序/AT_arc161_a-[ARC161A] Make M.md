# 题目信息

# [ARC161A] Make M

## 题目描述

$N$ 是一个正奇数。我们称一个长度为 $N$ 的序列 $S$ 是 **M 型**序列，当前仅当对于所有的 $i=2,4,6,\dots,N-1$（即偶数位），都有 $S_{i-1}<S_{i}$ 且 $S_{i}>S_{i+1}$。

现在给定你一个长度为 $N$ 的序列 $A$，请你判断能否通过将 $A$ 序列里的元素打乱位置使其变为一个 **M 型**序列。

## 样例 #1

### 输入

```
5

1 2 3 4 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5

1 6 1 6 1```

### 输出

```
Yes```

## 样例 #3

### 输入

```
5

1 6 6 6 1```

### 输出

```
No```

# AI分析结果

### 题目内容（已为中文，无需翻译）
$N$ 是一个正奇数。我们称一个长度为 $N$ 的序列 $S$ 是 **M 型**序列，当前仅当对于所有的 $i=2,4,6,\dots,N - 1$（即偶数位），都有 $S_{i - 1}<S_{i}$ 且 $S_{i}>S_{i + 1}$。

现在给定你一个长度为 $N$ 的序列 $A$，请你判断能否通过将 $A$ 序列里的元素打乱位置使其变为一个 **M 型**序列。

### 综合分析与结论
- **思路对比**：
    - 良心WA题人：先排序，判断跨越中间的数是否相等且大于一半，若满足则无法构造 M 型序列。
    - FreedomKing：排序后将数间隔分布构造序列，再判断构造出的序列是否合法。
    - 几何微粒子：解法 I 是排序后按特定规则插入结果序列，再判断是否为 M 型序列；解法 II 是统计重复最多的数字，根据数量和是否最小判断能否构造。
    - 梦应归于何处：先将数组从大到小排序，统计前 $N\div2$ 个数中比 $A_{N\div2}$ 大的数的个数，以及除前 $N\div2$ 个数外和 $A_{N\div2}$ 相等的数的个数，比较两者大小判断能否构造。
- **算法要点**：都涉及排序操作，部分题解使用了计数统计。
- **解决难点**：核心难点在于判断给定序列能否通过重排得到 M 型序列，不同题解从不同角度解决该问题，如判断中间数情况、构造序列后验证、统计特定数字数量等。

### 题解评分及选择
- **良心WA题人**：4星。思路清晰，代码简洁，直接抓住关键判断条件。
- **FreedomKing**：3星。思路直观，但构造和判断过程代码稍显冗余。
- **几何微粒子**：解法 I 3星，构造过程较常规；解法 II 4星，从重复数字特性分析，思路较巧妙。
- **梦应归于何处**：3星。思路较复杂，代码理解难度稍大。

### 所选题解
- **良心WA题人（4星）**
    - **关键亮点**：思路简洁，直接判断关键条件，代码实现简单高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN = 2e5 + 4;
int a[NN];
int main()
{
    int n;
    scanf("%d", &n);
    map<int, int> mp;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        mp[a[i]]++;
    }
    sort(a + 1, a + 1 + n);
    if (a[n / 2 + 1] == a[n / 2 + 2] && mp[a[n / 2 + 1]] > n / 2)
        printf("No");
    else
        printf("Yes");
    return 0;
}
```
核心思想：先统计每个数字的出现次数，排序后判断中间两个数是否相等且该数出现次数大于一半，若是则无法构造 M 型序列。

- **几何微粒子（解法 II，4星）**
    - **关键亮点**：从重复数字的特性出发，分析其在 M 型序列中的放置情况，思路巧妙。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
int a[N];
int n;
int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
    }
    sort(a + 1, a + 1 + n);
    int last, maxlast = -0x7f7f, num;
    for (int i = 1; i <= n; i++){
        if (a[i] == a[i - 1]){
            last++;
            if (last >= maxlast){
                maxlast = last;
                num = i;
            }
        }
        else{
            last = 0;
        }
    }
    if (maxlast > n / 2 + 1)
        printf("No");
    else if (maxlast == n / 2 + 1 && num!= a[1])
        printf("No");
    else
        printf("Yes");
    return 0;
}
```
核心思想：排序后统计重复最多的数字的出现次数和位置，根据其数量和是否最小判断能否构造 M 型序列。

### 最优关键思路或技巧
判断中间数的情况或统计重复最多的数字的特性，避免了复杂的序列构造和判断过程，提高了效率。

### 可拓展之处
同类型题可考虑改变序列的构造规则，如改变奇数位和偶数位的大小关系，或增加更多的限制条件。类似算法套路可用于判断其他特殊序列的构造可行性，通过分析关键元素的特性来简化判断过程。

### 推荐洛谷题目
- P1093 [NOIP2007 普及组] 奖学金
- P1271 [深基9.例1] 选举学生会
- P1104 生日

### 个人心得摘录与总结
- **良心WA题人**：“打的时候结论是猜的，所以这是前四道题里最难的一道题（确信）”。总结：做题时可能先通过猜测得到结论，再进行验证和实现。 

---
处理用时：32.57秒
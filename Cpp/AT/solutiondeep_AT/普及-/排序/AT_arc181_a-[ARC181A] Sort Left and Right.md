# 题目信息

# [ARC181A] Sort Left and Right

## 题目描述

给你一个 $(1,2,\dots,N)$ 的排列 $P=(P_1,P_2,\dots,P_N)$。

你要通过执行以下操作零次或多次来满足所有 $i=1,2,\dots,N$ 的 $P_i=i$：

- 选择一个整数 $k$，使得 $1 \leq k \leq N$。如果是 $k \geq 2$，把第 $1$ 项到第 $(k-1)$ 项的 $P$ 按升序排序。然后，如果是 $k \leq N-1$，把 $P$ 的第 $(k+1)$ 项到第 $N$ 项按升序排序。

可以证明，在这个问题的约束条件下，对于任意 $P$，都可以用有限次的运算满足所有 $i=1,2,\dots,N$ 的 $P_i=i$。请求解所需的最小运算次数。

## 说明/提示

**样例解释**

对于第一个测试用例：

- 对 $k=1$ 执行操作后，$P$ 变成了 $(2,1,3,4,5)$。
    
- 执行 $k=2$ 操作后，$P$ 变为 $(2,1,3,4,5)$。
    
- 与 $k=3$ 进行运算，结果是 $P$ 变为 $(1,2,3,4,5)$。
    
- 与 $k=4$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    
- 与 $k=5$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    

具体来说，对 $k=3$ 进行运算的结果是 $P$ 满足所有 $i=1,2,\dots,5$ 的 $P_i=i$。因此，所需的最少运算次数为 $1$。

在第三个测试用例中，先执行 $k=4$ 操作，再执行 $k=3$ 操作，结果 $P$ 变为 $(3,2,1,7,5,6,4) \rightarrow (1,2,3,7,4,5,6) \rightarrow (1,2,3,4,5,6,7)$ 。


对于 $100\%$ 的测试数据，保证 $1 \leq T \leq 10^5$，$3 \leq N \leq 2 \times 10^5$，$P$ 是 $(1,2,\dots,N)$ 的排列。

## 样例 #1

### 输入

```
3

5

2 1 3 5 4

3

1 2 3

7

3 2 1 7 5 6 4```

### 输出

```
1

0

2```

# AI分析结果

### 题目中文重写
#### [ARC181A] 对左右部分排序

#### 题目描述
给你一个 $(1,2,\dots,N)$ 的排列 $P=(P_1,P_2,\dots,P_N)$。

你要通过执行以下操作零次或多次来满足所有 $i = 1,2,\dots,N$ 的 $P_i = i$：

- 选择一个整数 $k$，使得 $1 \leq k \leq N$。如果是 $k \geq 2$，把第 $1$ 项到第 $(k - 1)$ 项的 $P$ 按升序排序。然后，如果是 $k \leq N - 1$，把 $P$ 的第 $(k + 1)$ 项到第 $N$ 项按升序排序。

可以证明，在这个问题的约束条件下，对于任意 $P$，都可以用有限次的运算满足所有 $i = 1,2,\dots,N$ 的 $P_i = i$。请求解所需的最小运算次数。

#### 说明/提示
**样例解释**

对于第一个测试用例：

- 对 $k = 1$ 执行操作后，$P$ 变成了 $(2,1,3,4,5)$。
    
- 执行 $k = 2$ 操作后，$P$ 变为 $(2,1,3,4,5)$。
    
- 与 $k = 3$ 进行运算，结果是 $P$ 变为 $(1,2,3,4,5)$。
    
- 与 $k = 4$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    
- 与 $k = 5$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。

具体来说，对 $k = 3$ 进行运算的结果是 $P$ 满足所有 $i = 1,2,\dots,5$ 的 $P_i = i$。因此，所需的最少运算次数为 $1$。

在第三个测试用例中，先执行 $k = 4$ 操作，再执行 $k = 3$ 操作，结果 $P$ 变为 $(3,2,1,7,5,6,4) \rightarrow (1,2,3,7,4,5,6) \rightarrow (1,2,3,4,5,6,7)$ 。

对于 $100\%$ 的测试数据，保证 $1 \leq T \leq 10^5$，$3 \leq N \leq 2 \times 10^5$，$P$ 是 $(1,2,\dots,N)$ 的排列。

#### 样例 #1
##### 输入
```
3
5
2 1 3 5 4
3
1 2 3
7
3 2 1 7 5 6 4
```
##### 输出
```
1
0
2
```

### 综合分析与结论
这些题解的核心思路都是通过分类讨论来确定将排列 $P$ 变为有序序列所需的最小操作次数，且都发现答案最大为 3。具体分类如下：
1. **操作 0 次**：原排列已经有序。
2. **操作 1 次**：存在一个位置 $i$，使得 $i$ 左边的数都小于它，右边的数都大于它。
3. **操作 2 次**：不满足操作 1 次的条件，且 $P_1 \neq n$ 或 $P_n \neq 1$。
4. **操作 3 次**：$P_1 = n$ 且 $P_n = 1$。

算法要点主要是通过遍历排列，使用前缀最大值、后缀最小值、前缀和等方法来判断每个位置是否满足操作 1 次的条件。难点在于证明操作次数的上限为 3，以及准确判断操作 1 次的情况。

### 所选题解
- **作者：Register_int（5 星）**
    - **关键亮点**：思路清晰，代码简洁，对每种情况的判断逻辑明确，使用前缀最大值和后缀最小值数组高效判断操作 1 次的情况。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 10;
int T, n, a[MAXN]; bool f = 0;
int pre[MAXN], suf[MAXN];
int main() {
    for (scanf("%d", &T); T--;) {
        scanf("%d", &n), f = 1, suf[n + 1] = n + 1;
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
        for (int i = 1; i <= n; i++) if (a[i]!= i) f = 0;
        if (f) { puts("0"); continue; }
        for (int i = 1; i <= n; i++) pre[i] = max(pre[i - 1], a[i]);
        for (int i = n; i; i--) suf[i] = min(suf[i + 1], a[i]);
        for (int i = 1; i <= n; i++) {
            if (pre[i] == i && suf[i] == i && a[i] == i) { f = 1; break; }
        }
        if (f) { puts("1"); continue; }
        puts(a[1] == n && a[n] == 1? "3" : "2"); 
    }
}
```
核心实现思想：先判断原排列是否有序，若有序则操作次数为 0。然后计算前缀最大值数组 `pre` 和后缀最小值数组 `suf`，遍历排列，若存在一个位置 $i$ 满足 `pre[i] == i` 且 `suf[i] == i` 且 `a[i] == i`，则操作次数为 1。最后判断 $P_1$ 和 $P_n$ 的值，若 $P_1 = n$ 且 $P_n = 1$，则操作次数为 3，否则为 2。

- **作者：include13_fAKe（4 星）**
    - **关键亮点**：思路清晰，对每种情况的举例说明有助于理解，代码简洁易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int p[2*114514];
int max1;
bool f1=true;
void solve(){
    f1=true;
    max1=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>p[i];
        if(p[i]!=i) f1=false;
    }
    if(f1){
        puts("0");
        return;
    }
    for(int i=1;i<=n;i++){
        max1=max(max1,p[i]);
        if(p[i]==i&&max1==i){
            puts("1");
            return;
        }
    } 
    if(p[1]==n&&p[n]==1){
        puts("3");
        return;
    }
    puts("2");
    return;
}
int T;
int main(){
    cin>>T;
    while(T--) solve();
    return 0;
}
```
核心实现思想：先判断原排列是否有序，若有序则操作次数为 0。然后遍历排列，记录前缀最大值 `max1`，若存在一个位置 $i$ 满足 `p[i] == i` 且 `max1 == i`，则操作次数为 1。最后判断 $P_1$ 和 $P_n$ 的值，若 $P_1 = n$ 且 $P_n = 1$，则操作次数为 3，否则为 2。

- **作者：paper_（4 星）**
    - **关键亮点**：对每种情况的分析详细，代码逻辑清晰，易于理解。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[200010];
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); 
    int T;cin >> T;
    while (T -- ) {
        int n;cin >> n;
        int ans = 0, ma = 0, can = 0;
        for (int i = 1; i <= n; i ++ ) {
            cin >> a[i];ma = max(ma, a[i]);
            if (a[i] == i) ans ++;
            if (a[i] == i && a[i] == ma) can = 1;
        }
        if (a[1] == n && a[n] == 1) cout << 3 << '\n';
        else if (ans == n) cout << 0 << '\n';
        else if (can) cout << 1 << '\n';
        else cout << 2 << '\n';
    }
    return 0;
}
```
核心实现思想：先统计排列中在正确位置的元素个数 `ans` 和前缀最大值 `ma`，若 `ans == n`，则原排列有序，操作次数为 0。若存在一个位置 $i$ 满足 `a[i] == i` 且 `a[i] == ma`，则操作次数为 1。最后判断 $P_1$ 和 $P_n$ 的值，若 $P_1 = n$ 且 $P_n = 1$，则操作次数为 3，否则为 2。

### 最优关键思路或技巧
- **分类讨论**：将问题分为操作 0 次、1 次、2 次、3 次四种情况，分别进行判断，使问题简化。
- **前缀最大值和后缀最小值**：使用前缀最大值和后缀最小值数组可以高效判断一个位置是否满足操作 1 次的条件。

### 可拓展之处
同类型题或类似算法套路：可以拓展到其他排列排序问题，通过有限次操作将排列变为有序，关键在于分析操作的性质，找出最少操作次数的规律。

### 洛谷相似题目推荐
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
2. [P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)
3. [P1093 [NOIP2007 普及组] 奖学金](https://www.luogu.com.cn/problem/P1093)

### 个人心得摘录与总结
- **作者：scp020**：赛时糖丸了，吃了 5 发罚时才过。总结：在比赛中要保持冷静，仔细分析问题，避免因粗心导致罚时。
- **作者：zhlzt**：简单分讨竟然在赛时卡了我 30 多分钟。总结：即使是简单的分类讨论题，也需要认真思考，理清每种情况的判断条件，避免在比赛中浪费过多时间。

---
处理用时：64.06秒
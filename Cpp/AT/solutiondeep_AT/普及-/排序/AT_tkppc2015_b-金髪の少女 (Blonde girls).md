# 题目信息

# 金髪の少女 (Blonde girls)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tkppc/tasks/tkppc2015_b

妹の宿題を手伝って疲れたので、joisinoお姉ちゃんは少しテレビを見ることにした。

しかし、ふと気がつくとjoisinoお姉ちゃんはイギリスのような町にいた。  
 どうやら知らない間に違う世界にやってきてしまったようだ。

そこには$ N $人の金髪の少女がいたが、joisinoお姉ちゃんは金髪の少女が大好きなので、彼女たちを抱きしめたいと思った。  
 しかし、人数が多いので、すべての少女を抱きしめることはできない。  
 そこで、joisinoお姉ちゃんは彼女たちの中でもっとも金髪の美しさが大きい少女を抱きしめることにした。  
 このとき、少女$ i(1\ ≦\ i\ ≦\ N) $の金髪の美しさは$ A_i $である。

しかし、少女の数があまりにも多いので、joisinoお姉ちゃんは最も美しい金髪を持つ少女を探すプログラムを書こうと思った。

## 说明/提示

### 配点

この問題に部分点はない。 正解すると40点を得られる。

### Sample Explanation 1

この場合、少女は$ 2 $人いて、$ 1 $番目の少女の金髪の美しさは$ 123 $、$ 2 $番目の少女の金髪の美しさは$ 146 $なので、$ 2 $番目の少女がもっとも美しい金髪を持つ。

### Sample Explanation 2

\### 出力例2 ``` 3 ``` この場合、少女は$ 4 $人いて、$ 3 $番目と$ 4 $番目の少女がもっとも美しい金髪を持っているので、より番号が小さい3を出力する。

## 样例 #1

### 输入

```
2

123

146```

### 输出

```
2```

## 样例 #2

### 输入

```
4

124

23

145

145```

### 输出

```
3
```

## 样例 #3

### 输入

```
10

41

467

334

0

169

224

478

358

462

464```

### 输出

```
7
```

# AI分析结果

### 题目翻译
# 金发少女 (Blonde girls)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tkppc/tasks/tkppc2015_b

帮妹妹做完作业后累坏了的joisino姐姐决定看一会儿电视。

然而，当她回过神来，joisino姐姐发现自己身处一个类似英国的小镇。
看来她在不知不觉中来到了另一个世界。

那里有 $N$ 个金发少女，由于joisino姐姐非常喜欢金发少女，她想拥抱她们。
但人数太多了，她无法拥抱所有少女。
于是，joisino姐姐决定拥抱金发最美的少女。
此时，少女 $i(1 \leq i \leq N)$ 的金发美丽程度为 $A_i$。

然而，少女的数量太多了，joisino姐姐打算编写一个程序来找出拥有最美金发的少女。

## 说明/提示

### 配点
本题没有部分分。答对可得40分。

### 样例解释1
在这种情况下，有2个少女，第1个少女的金发美丽程度为123，第2个少女的金发美丽程度为146，所以第2个少女拥有最美的金发。

### 样例解释2
### 输出样例2
```
3
```
在这种情况下，有4个少女，第3个和第4个少女拥有最美的金发，所以输出编号较小的3。

## 样例 #1
### 输入
```
2
123
146
```
### 输出
```
2
```

## 样例 #2
### 输入
```
4
124
23
145
145
```
### 输出
```
3
```

## 样例 #3
### 输入
```
10
41
467
334
0
169
224
478
358
462
464
```
### 输出
```
7
```

### 综合分析与结论
- **思路对比**：
    - Murasoishi的题解思路是直接遍历数组，用两个变量分别记录最大值和最大值的下标，在遍历过程中更新这两个变量。
    - agicy的题解思路是使用结构体存储每个元素的值和其位置，然后对结构体数组进行排序，最后输出排序后第一个元素的位置。
- **算法要点**：
    - Murasoishi的题解主要是利用一次遍历和条件判断来找出最大值的下标，时间复杂度为 $O(n)$。
    - agicy的题解主要是使用结构体和排序算法，排序的时间复杂度通常为 $O(n log n)$。
- **解决难点**：
    - 两个题解都需要处理当有多个相同最大值时输出位置最靠前的那个的问题。Murasoishi通过在判断最大值时不加等号来解决；agicy通过自定义结构体的比较函数，当值相等时比较位置来解决。

### 题解选择
- **Murasoishi的题解（5星）**：
    - **关键亮点**：思路清晰直接，代码简洁易懂，时间复杂度低，仅需一次遍历数组。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,id,maxn=-1;
int main() {
    cin>>n;
    for(int i=1;i<=n;i++){
        int a;cin>>a;
        if(maxn<a)maxn=a,id=i;
    }
    cout<<id<<endl;
    return 0;
}
```
核心实现思想：通过一次遍历数组，不断更新最大值 `maxn` 和最大值的下标 `id`，最终输出 `id`。

- **agicy的题解（3星）**：
    - **关键亮点**：使用结构体存储元素和位置，通过排序解决问题，代码结构清晰。但时间复杂度相对较高。
    - **核心代码**：
```cpp
struct Node{
    int ID,val;
    bool operator<(Node &a)const{
        return (val!=a.val)?(val>a.val):(ID<a.ID);
    }
};
//...
sort(a+1,a+n+1);
printf("%d\n",a[1].ID);
```
核心实现思想：定义结构体 `Node` 存储元素的值和位置，自定义比较函数，对结构体数组排序后输出第一个元素的位置。

### 最优关键思路或技巧
Murasoishi的题解中，使用两个变量直接记录最大值和最大值的下标，一次遍历数组完成查找，时间复杂度低，代码简洁，是本题的最优思路。

### 可拓展之处
同类型题可以是在数组中找最小值、次大值等，或者在二维数组、链表等数据结构中找最值。类似算法套路是通过遍历和比较更新最值信息。

### 洛谷相似题目推荐
1. P1046 [NOIP2005 普及组] 陶陶摘苹果
2. P1427 小鱼的数字游戏
3. P5718 【深基4.例2】找最小值

---
处理用时：29.81秒
# 题目信息

# [ABC325C] Sensors

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_c

$ H $ 行 $ W $ 列のマス目の上に $ 0 $ 個以上のセンサが配置されています。上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,\ j) $ と表記します。   
 センサが配置されているマス目の情報は長さ $ W $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_H $ によって与えられ、$ S_i $ の $ j $ 文字目が `#` のとき、またそのときに限り $ (i,\ j) $ にセンサが配置されています。  
 このセンサは上下左右斜めに隣接しているマス目に存在する他のセンサと連動し、一つのセンサとして動作します。 ただし、マス目 $ (x,\ y) $ と $ (x',\ y') $ が上下左右斜めに隣接しているとは、$ \max(|x-x'|,|y-y'|)\ =\ 1 $ であることを指します。  
 また、センサ $ A $ とセンサ $ B $ が連動し、センサ $ A $ とセンサ $ C $ が連動しているとき、センサ $ B $ とセンサ $ C $ も連動することに注意してください。

連動するセンサを一つのセンサと見なしたとき、このマス目の上にあるセンサの個数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 1000 $
- $ H,\ W $ は整数
- $ S_i $ は各文字が `#` または `.` である長さ $ W $ の文字列
 
### Sample Explanation 1

連動しているセンサを一つのセンサと見なしたとき、 - $ (1,2),(1,3),(2,4),(3,5),(3,6) $ にあるセンサが連動したもの - $ (4,1) $ にあるセンサ - $ (4,3),(5,3) $ にあるセンサが連動したもの の $ 3 $ つのセンサが存在します。

## 样例 #1

### 输入

```
5 6

.##...

...#..

....##

#.#...

..#...```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3

#.#

.#.

#.#```

### 输出

```
1```

## 样例 #3

### 输入

```
4 2

..

..

..

..```

### 输出

```
0```

## 样例 #4

### 输入

```
5 47

.#..#..#####..#...#..#####..#...#...###...#####

.#.#...#.......#.#...#......##..#..#...#..#....

.##....#####....#....#####..#.#.#..#......#####

.#.#...#........#....#......#..##..#...#..#....

.#..#..#####....#....#####..#...#...###...#####```

### 输出

```
7```

# AI分析结果

### 题目翻译
题目描述：  
给定一个 $H$ 行 $W$ 列的网格，网格上有若干个传感器。网格中的每个单元格用 $(i, j)$ 表示，其中 $i$ 表示行号，$j$ 表示列号。传感器的位置由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 给出，如果 $S_i$ 的第 $j$ 个字符是 `#`，则表示 $(i, j)$ 位置有一个传感器。  
传感器之间如果上下左右或斜向相邻，则它们会连动，视为一个传感器。具体来说，两个传感器 $(x, y)$ 和 $(x', y')$ 相邻的条件是 $\max(|x-x'|, |y-y'|) = 1$。  
如果传感器 $A$ 和 $B$ 连动，且 $A$ 和 $C$ 连动，那么 $B$ 和 $C$ 也会连动。  
求连动后的传感器数量。

### 题解分析与结论
本题的核心是求网格中连通块的数量，每个连通块由相邻的传感器组成。题解中主要使用了深度优先搜索（DFS）和广度优先搜索（BFS）两种方法来解决该问题。以下是对各题解的总结与评分：

1. **xxr___ 的题解**  
   - **评分：4星**  
   - **亮点**：提供了DFS和BFS两种实现，代码清晰，注释详细，适合初学者理解。  
   - **核心代码**：
     ```cpp
     void bfs(int x, int y) {
         queue<pair<int, int>> q;
         q.push({x, y});
         while (q.size()) {
             auto v = q.front(); q.pop();
             for (int i = 0; i < 8; i++) {
                 int xx = v.first + dx[i], yy = v.second + dy[i];
                 if (ch[xx][yy] == '#' && xx > 0 && xx <= n && yy > 0 && yy <= m) {
                     ch[xx][yy] = '.';
                     q.push({xx, yy});
                 }
             }
         }
     }
     ```
     **实现思想**：使用BFS遍历每个连通块，将访问过的传感器标记为 `.`，避免重复访问。

2. **SunSkydp 的题解**  
   - **评分：4星**  
   - **亮点**：使用DFS实现，代码简洁，逻辑清晰，适合快速实现。  
   - **核心代码**：
     ```cpp
     void dfs(int x, int y) {
         for (int i = 0; i < 8; i++) {
             int xx = x + xy[i][0], yy = y + xy[i][1];
             if (init(xx, yy) && c[xx][yy] == '#' && !a[xx][yy]) {
                 a[xx][yy] = cnt;
                 dfs(xx, yy);
             }
         }
     }
     ```
     **实现思想**：使用DFS遍历每个连通块，并给每个连通块赋予一个编号，最终统计编号数量。

3. **SiriusIV 的题解**  
   - **评分：4星**  
   - **亮点**：使用DFS实现，代码简洁，注释详细，适合快速实现。  
   - **核心代码**：
     ```cpp
     void dfs(int x, int y) {
         int fx, fy;
         for (int i = 0; i < 8; i++) {
             fx = dir[i][0] + x;
             fy = dir[i][1] + y;
             if (fx >= 1 && fx <= n && fy >= 1 && fy <= m && mp[fx][fy] == '#') {
                 mp[fx][fy] = '.';
                 dfs(fx, fy);
             }
         }
     }
     ```
     **实现思想**：使用DFS遍历每个连通块，将访问过的传感器标记为 `.`，避免重复访问。

### 最优关键思路与技巧
- **DFS/BFS遍历**：通过DFS或BFS遍历每个连通块，标记已访问的传感器，避免重复访问。
- **方向数组**：使用方向数组简化八个方向的遍历，代码更简洁。
- **边界检查**：在遍历时进行边界检查，防止数组越界。

### 可拓展之处
- **同类型题目**：类似题目包括求矩阵中的连通块数量、岛屿数量等，如 [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)。
- **算法优化**：对于更大规模的数据，可以考虑使用并查集（Union-Find）来优化连通块的合并与查询。

### 推荐题目
1. [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

### 个人心得摘录
- **调试经历**：在DFS实现中，忘记进行边界检查导致数组越界，调试时发现并修复。
- **踩坑教训**：在BFS实现中，未及时标记已访问的传感器，导致重复访问，增加了时间复杂度。
- **顿悟感想**：通过本题深刻理解了DFS和BFS在连通块问题中的应用，掌握了方向数组的使用技巧。

---
处理用时：42.29秒
# 题目信息

# [ABC333D] Erase Leaves

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_d

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる木が与えられます。 $ i $ 番目 $ (1\leq\ i\lt\ N) $ の辺は頂点 $ u\ _\ i $ と $ v\ _\ i $ を結んでいます。

次の操作を好きな回数繰り返すことを考えます。

- 葉である頂点 $ v $ を $ 1 $ つ選び、頂点 $ v $ およびそれに接続する辺をすべて削除する。
 
頂点 $ 1 $ を削除するまでに最小で操作を何回行う必要があるか求めてください。

 木とは？ 木とは、無向グラフのうち連結であって閉路がないものです。 詳しくはこちらをご覧ください: [Wikipedia「木 (数学)」](https://ja.wikipedia.org/wiki/%E6%9C%A8_(%E6%95%B0%E5%AD%A6))  葉とは？ 木の葉とは、木の頂点のうち次数がたかだか $ 1 $ であるものです。

## 说明/提示

### 制約

- $ 2\leq\ N\leq3\times10^5 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\lt\ N) $
- 与えられるグラフは木
- 入力はすべて整数
 
### Sample Explanation 1

与えられるグラフは次のようになります。 !\[\](https://img.atcoder.jp/abc333/6089239ee0c331bec4cd4472c032d197.png) たとえば、頂点 $ 9,8,7,6,1 $ の順に選んで操作を行うことで、$ 5 $ 回の操作で頂点 $ 1 $ を削除することができます。 !\[\](https://img.atcoder.jp/abc333/7dba9a660bfabdd403fe6882dac4e8ab.png) $ 4 $ 回以下の操作では頂点 $ 1 $ を削除することはできないため、$ 5 $ を出力してください。

### Sample Explanation 2

与えられたグラフにおいて、頂点 $ 1 $ は葉です。 よって、$ 1 $ 回目の操作で頂点 $ 1 $ を選んで削除することができます。

## 样例 #1

### 输入

```
9

1 2

2 3

2 4

2 5

1 6

6 7

7 8

7 9```

### 输出

```
5```

## 样例 #2

### 输入

```
6

1 2

2 3

2 4

3 5

3 6```

### 输出

```
1```

## 样例 #3

### 输入

```
24

3 6

7 17

7 20

7 11

14 18

17 21

6 19

5 22

9 24

11 14

6 23

8 17

9 12

4 17

2 15

1 17

3 9

10 16

7 13

2 16

1 16

5 7

1 3```

### 输出

```
12```

# AI分析结果

### 题目内容重写
给定一棵由 $N$ 个顶点组成的树，顶点编号为 $1$ 到 $N$。第 $i$ 条边连接顶点 $u_i$ 和 $v_i$。你可以进行以下操作任意次：

- 选择一个叶子顶点 $v$，删除 $v$ 及其所有连接的边。

问：删除顶点 $1$ 所需的最小操作次数是多少？

### 题解分析与结论

#### 关键思路总结
1. **问题转化**：要删除顶点 $1$，必须使其成为叶子节点，即只保留一个子树。因此，问题转化为如何最小化删除其他子树的代价。
2. **贪心策略**：保留顶点 $1$ 的最大子树，删除其他子树。这样可以使删除的节点数最小化。
3. **DFS计算子树大小**：通过DFS遍历树，计算每个子树的大小，找出顶点 $1$ 的最大子树，最终答案为总节点数减去最大子树的大小。

#### 最优题解推荐

1. **作者：Hughpig (4星)**
   - **关键亮点**：思路清晰，代码简洁，直接通过DFS计算子树大小，并利用贪心策略保留最大子树。
   - **核心代码**：
     ```cpp
     void calc(int u, int fa) {
         sz[u] = 1;
         for (int v : G[u]) {
             if (v == fa) continue;
             calc(v, u);
             sz[u] += sz[v];
         }
     }
     ```
   - **个人心得**：作者提到“如果 $1$ 号节点是叶子节点，直接输出 $1$”，这种边界情况的处理值得学习。

2. **作者：BLuemoon_ (4星)**
   - **关键亮点**：通过DFS计算子树大小，并直接输出总节点数减去最大子树的大小，代码简洁高效。
   - **核心代码**：
     ```cpp
     void S(int x, int fa) {
         cnt++;
         for (int i : g[x]) {
             if (i != fa) {
                 S(i, x);
             }
         }
     }
     ```
   - **个人心得**：作者提到“每一颗子树都会对 $1$ 节点的度作出 $1$ 的贡献”，这种直观的解释有助于理解问题。

3. **作者：2huk (4星)**
   - **关键亮点**：思路清晰，代码简洁，直接通过DFS计算子树大小，并利用贪心策略保留最大子树。
   - **核心代码**：
     ```cpp
     void dfs(int u, int fa) {
         siz[u] = 1;
         for (int v : e[u]) {
             if (v != fa) {
                 dfs(v, u);
                 siz[u] += siz[v];
             }
         }
     }
     ```
   - **个人心得**：作者提到“删掉一个大小为 $s$ 的子树需要删 $s$ 次”，这种直观的解释有助于理解问题。

### 拓展思路与类似题目
1. **类似题目**：
   - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：树形DP，选择或不选择某个节点。
   - [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形DP，选择子树中的节点。
   - [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)：树形DP，保留子树中的边。

2. **拓展思路**：
   - 对于树形问题，DFS遍历是常见的手段，结合贪心策略可以解决许多问题。
   - 在处理树形问题时，注意边界情况的处理，如叶子节点的特殊情况。

---
处理用时：33.38秒
# 题目信息

# [ABC358C] Popcorn

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc358/tasks/abc358_c

AtCoder Land には $ 1 $ から $ N $ までの番号が付けられた $ N $ 個のポップコーン売り場があります。 売られているポップコーンの味には味 $ 1,2,\dots,M $ の $ M $ 種類がありますが、すべての売り場ですべての味のポップコーンを売っているわけではありません。

高橋君は、それぞれのポップコーン売り場でどの味のポップコーンを売っているかの情報を入手しました。 この情報は $ N $ 個の長さ $ M $ の文字列 $ S_1,S_2,\dots,S_N $ によって表され、$ S_i $ の $ j $ 文字目が `o` であるとき売り場 $ i $ が味 $ j $ のポップコーンを売っていることを、 `x` であるとき売っていないことを示します。 どの売り場も最低 $ 1 $ 種類の味のポップコーンを売っており、どの味のポップコーンも最低 $ 1 $ つの売り場で売られています。

高橋君は全種類のポップコーンを食べたがっていますが、あまり何度も移動はしたくありません。 高橋君がすべての味のポップコーンを購入するためには最低何個の売り場を訪れる必要があるか求めてください。

## 说明/提示

### 制約

- $ N,M $ は整数
- $ 1\leq\ N,M\ \leq\ 10 $
- $ S_i $ は `o` および `x` からなる長さ $ M $ の文字列
- すべての $ i\ (1\leq\ i\leq\ N) $ について、$ S_i $ の中には `o` が $ 1 $ つ以上存在する
- すべての $ j\ (1\leq\ j\leq\ M) $ について、$ S_i $ の $ j $ 文字目が `o` であるような $ i $ が $ 1 $ つ以上存在する
 
### Sample Explanation 1

$ 1 $ つめの売り場と $ 3 $ つめの売り場を訪れることで、すべての味のポップコーンを購入することができます。 $ 1 $ つの売り場ですべての味のポップコーンを購入することはできないので、答えは $ 2 $ です。

## 样例 #1

### 输入

```
3 5

oooxx

xooox

xxooo```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2

oo

ox

xo```

### 输出

```
1```

## 样例 #3

### 输入

```
8 6

xxoxxo

xxoxxx

xoxxxx

xxxoxx

xxoooo

xxxxox

xoxxox

oxoxxo```

### 输出

```
3```

# AI分析结果

### 题目内容重写

在 AtCoder Land 中，有编号从 1 到 N 的 N 个爆米花摊位。爆米花有 M 种不同的口味，编号为 1 到 M。每个摊位不一定出售所有口味的爆米花。

高桥君获得了每个摊位出售的爆米花口味信息，这些信息由 N 个长度为 M 的字符串 S1, S2, ..., SN 表示。其中，S_i 的第 j 个字符为 'o' 表示摊位 i 出售口味 j 的爆米花，为 'x' 则表示不出售。每个摊位至少出售一种口味的爆米花，且每种口味的爆米花至少在一个摊位出售。

高桥君希望品尝所有口味的爆米花，但不想频繁移动。请问他至少需要访问多少个摊位才能买到所有口味的爆米花？

### 样例解释

**样例 1**  
输入：  
```
3 5
oooxx
xooox
xxooo
```  
输出：  
```
2
```  
解释：访问第一个和第三个摊位可以买到所有口味的爆米花。

**样例 2**  
输入：  
```
3 2
oo
ox
xo
```  
输出：  
```
1
```  
解释：访问第一个摊位即可买到所有口味的爆米花。

### 题解分析与结论

本题的难点在于如何高效地枚举所有可能的摊位组合，并找到能够覆盖所有口味的最小摊位数量。由于 N 和 M 的范围都很小（1 ≤ N, M ≤ 10），因此可以采用暴力搜索或状态压缩的方法来解决。

#### 关键思路与技巧

1. **暴力搜索（DFS）**：通过递归枚举每个摊位的选择情况，记录已经购买的口味，最终找到满足条件的最小摊位数量。DFS 的优点是思路清晰，易于实现，但需要注意回溯时的状态恢复。
   
2. **状态压缩**：将每个摊位的出售情况用二进制表示，然后枚举所有可能的摊位组合，通过位运算快速判断是否覆盖了所有口味。这种方法在代码实现上较为简洁，且时间复杂度较低。

3. **剪枝优化**：在 DFS 过程中，如果当前选择的摊位数量已经超过了已知的最小值，可以直接剪枝，避免不必要的计算。

#### 推荐题解

1. **作者：stripe_python (赞：4)**  
   - **星级**：★★★★☆  
   - **关键亮点**：使用 DFS 进行暴力搜索，通过 `vis` 数组记录已经购买的口味，`p` 数组记录选择的摊位，并在回溯时恢复状态。代码结构清晰，易于理解。  
   - **核心代码**：
     ```cpp
     void dfs(int step) {
         if (check()) return res = min(res, step), void();
         for (int i = 1; i <= n; i++) {
             if (p[i]) continue;
             p[i] = true;
             unordered_set<int> st;
             for (int j = 1; j <= m; j++) {
                 if (s[i][j] == 'o' && !vis[j]) vis[j] = true, st.emplace(j);
             }
             dfs(step + 1);
             p[i] = false;
             for (int j = 1; j <= m; j++) {
                 if (s[i][j] == 'o' && st.count(j)) vis[j] = false;
             }
         }
     }
     ```

2. **作者：zhujiangyuan (赞：4)**  
   - **星级**：★★★★☆  
   - **关键亮点**：同样使用 DFS，但采用了更简洁的递归结构，通过 `vis` 数组记录已经购买的口味，并在每次递归时更新状态。代码简洁，易于实现。  
   - **核心代码**：
     ```cpp
     void dfs(int k, int cnt) {
         if (k == n + 1) {
             bool flag = 0;
             for (int i = 1; i <= m; i++) if (!vis[i]) flag = 1;
             if (!flag) ans = min(ans, cnt);
             return;
         }
         for (int i = 1; i <= m; i++) vis[i] += (s[k][i] == 'o');
         dfs(k + 1, cnt + 1);
         for (int i = 1; i <= m; i++) vis[i] -= (s[k][i] == 'o');
         dfs(k + 1, cnt);
     }
     ```

3. **作者：LuukLuuk (赞：1)**  
   - **星级**：★★★★☆  
   - **关键亮点**：使用状态压缩的方法，将每个摊位的出售情况用二进制表示，并通过位运算快速判断是否覆盖了所有口味。代码简洁且高效。  
   - **核心代码**：
     ```cpp
     for (int i = 1; i <= (1 << n) - 1; i++) {
         int p = i, cnt = 0;
         char f[15] = {0};
         for (int j = 1; j <= n; j++) {
             if (p & 1) {
                 cnt++;
                 for (int k = 1; k <= m; k++) if (c[j][k] == 'o') f[k] = 'o';
             }
             p >>= 1;
         }
         bool flag = 1;
         for (int j = 1; j <= m; j++) if (f[j] != 'o') flag = 0;
         if (flag) minn = min(minn, cnt);
     }
     ```

### 通用建议与扩展思路

- **状态压缩的应用**：在数据范围较小的情况下，状态压缩是一种非常有效的优化手段，能够显著减少代码复杂度并提高运行效率。
  
- **剪枝优化**：在暴力搜索中，合理的剪枝可以大幅减少不必要的计算，尤其是在数据范围较大的情况下。

- **类似题目**：可以尝试解决一些类似的子集枚举问题，如背包问题、集合覆盖问题等。

### 推荐题目

1. [P1463 [POI2001] 反素数](https://www.luogu.com.cn/problem/P1463)
2. [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)
3. [P2622 关灯问题II](https://www.luogu.com.cn/problem/P2622)

---
处理用时：50.63秒
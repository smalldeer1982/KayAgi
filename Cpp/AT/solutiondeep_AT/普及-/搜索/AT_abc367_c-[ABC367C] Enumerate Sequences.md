# 题目信息

# [ABC367C] Enumerate Sequences

## 题目描述

给定长度为 $n$ 的正整数序列 $(r_1, \ldots, r_n)$ 和正整数 $k$。

以字典序从小到大的顺序输出所有满足 $1 \le a_i \le r_i$ 且 $a_1 + \cdots + a_n$ 是 $k$ 的倍数的长度为 $n$ 的整数序列 $(a_1, \ldots, a_n)$。

数据范围：$n \le 8$，$1 \le r_i \le 5$，$2 \le k \le 10$。

## 样例 #1

### 输入

```
3 2

2 1 3```

### 输出

```
1 1 2

2 1 1

2 1 3```

## 样例 #2

### 输入

```
1 2

1```

### 输出

```
```

## 样例 #3

### 输入

```
5 5

2 3 2 3 2```

### 输出

```
1 1 1 1 1

1 2 2 3 2

1 3 1 3 2

1 3 2 2 2

1 3 2 3 1

2 1 2 3 2

2 2 1 3 2

2 2 2 2 2

2 2 2 3 1

2 3 1 2 2

2 3 1 3 1

2 3 2 1 2

2 3 2 2 1```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

给定长度为 $n$ 的正整数序列 $(r_1, \ldots, r_n)$ 和正整数 $k$。

以字典序从小到大的顺序输出所有满足 $1 \le a_i \le r_i$ 且 $a_1 + \cdots + a_n$ 是 $k$ 的倍数的长度为 $n$ 的整数序列 $(a_1, \ldots, a_n)$。

数据范围：$n \le 8$，$1 \le r_i \le 5$，$2 \le k \le 10$。

#### 样例 #1

##### 输入

```
3 2

2 1 3
```

##### 输出

```
1 1 2

2 1 1

2 1 3
```

#### 样例 #2

##### 输入

```
1 2

1
```

##### 输出

```
```

#### 样例 #3

##### 输入

```
5 5

2 3 2 3 2
```

##### 输出

```
1 1 1 1 1

1 2 2 3 2

1 3 1 3 2

1 3 2 2 2

1 3 2 3 1

2 1 2 3 2

2 2 1 3 2

2 2 2 2 2

2 2 2 3 1

2 3 1 2 2

2 3 1 3 1

2 3 2 1 2

2 3 2 2 1
```

---

### 题解分析与结论

本题的核心是通过暴力搜索（DFS）枚举所有可能的序列，并判断其和是否为 $k$ 的倍数。由于数据范围较小（$n \le 8$，$r_i \le 5$），直接暴力搜索是可行的。所有题解都采用了DFS的思路，但在代码实现和优化上有所不同。

#### 最优思路与技巧

1. **DFS暴力搜索**：通过递归枚举每个位置的可能取值，并在递归结束时判断序列和是否为 $k$ 的倍数。
2. **字典序输出**：由于DFS是按从小到大的顺序枚举，因此输出的序列自然满足字典序要求。
3. **回溯优化**：在DFS过程中，及时回溯以减少不必要的计算。

#### 可拓展之处

- **剪枝优化**：虽然本题数据范围较小，但在类似问题中，可以通过剪枝（如提前判断和是否可能为 $k$ 的倍数）来进一步优化。
- **动态规划**：如果问题规模更大，可以考虑使用动态规划来优化时间复杂度。

#### 推荐题目

1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - 考察全排列的生成，与本题的DFS思路类似。
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 考察DFS与组合数的生成。
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 考察DFS与回溯的应用。

---

### 精选题解

#### 题解1：OGCoder（4星）

**关键亮点**：
- 代码简洁，逻辑清晰。
- 使用DFS直接枚举所有可能的序列，并在递归结束时判断和是否为 $k$ 的倍数。

**核心代码**：
```cpp
void dfs(int u, int sum = 0) {
    if (u == n + 1) {
        if (sum % k != 0) return;
        for (int i = 1; i < u; i++) cout << b[i] << ' ';
        cout << endl;
        return;
    }
    for (int i = 1; i <= r[u]; i++) {
        b[u] = i;
        dfs(u + 1, sum + i);
        b[u] = 0;
    }
}
```

#### 题解2：chinazhanghaoxun（4星）

**关键亮点**：
- 代码结构清晰，注释详细。
- 使用DFS枚举所有可能的序列，并在递归结束时判断和是否为 $k$ 的倍数。

**核心代码**：
```cpp
void dfs(int ns) {
    if (ns > n) {
        if (sum % k == 0) {
            for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
            cout << endl;
        }
        return;
    }
    for (int i = 1; i <= r[ns]; i++) {
        ans[ns] = i;
        sum += i;
        dfs(ns + 1);
        sum -= i;
    }
}
```

#### 题解3：linch（4星）

**关键亮点**：
- 代码简洁，逻辑清晰。
- 使用DFS枚举所有可能的序列，并在递归结束时判断和是否为 $k$ 的倍数。

**核心代码**：
```cpp
void dfs(int dep, int sum) {
    if (dep > n) {
        if (sum % k == 0) {
            for (int i = 1; i <= n; i++) cout << a[i] << " ";
            cout << "\n";
        }
        return;
    }
    for (int i = 1; i <= r[dep]; i++) {
        a[dep] = i;
        dfs(dep + 1, sum + i);
    }
}
```

---

### 总结

本题的核心在于通过DFS暴力搜索所有可能的序列，并判断其和是否为 $k$ 的倍数。所有题解都采用了这一思路，但在代码实现和优化上有所不同。推荐的题解代码简洁、逻辑清晰，适合初学者理解和掌握DFS的应用。

---
处理用时：52.05秒
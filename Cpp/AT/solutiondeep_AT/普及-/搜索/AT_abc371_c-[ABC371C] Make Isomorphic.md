# 题目信息

# [ABC371C] Make Isomorphic

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_c

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる単純無向グラフ $ G,H $ が与えられます。 $ G $ には $ M\ _\ G $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ G) $ の辺は頂点 $ u\ _\ i $ と頂点 $ v\ _\ i $ を結んでいます。 $ H $ には $ M\ _\ H $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ H) $ の辺は頂点 $ a\ _\ i $ と頂点 $ b\ _\ i $ を結んでいます。

あなたは、グラフ $ H $ に対して次の操作を $ 0 $ 回以上の好きな回数繰り返すことができます。

- $ 1\leq\ i\lt\ j\leq\ N $ を満たす整数の組 $ (i,j) $ をひとつ選ぶ。$ A\ _\ {i,j} $ 円を支払って、頂点 $ i $ と頂点 $ j $ を結ぶ辺がなければ追加し、あれば取り除く。

$ G $ と $ H $ を同型にするために少なくとも何円支払う必要があるか求めてください。

単純無向グラフとは？ **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

グラフの同型とは？ $ N $ 頂点のグラフ $ G $ と $ H $ が**同型**であるとは、ある $ (1,2,\ldots,N) $ の並べ替え $ (P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が存在して、どの $ 1\leq\ i\lt\ j\leq\ N $ に対しても

- $ G $ に頂点 $ i, $ 頂点 $ j $ を結ぶ辺が存在するとき、かつそのときに限り $ H $ に頂点 $ P\ _\ i, $ 頂点 $ P\ _\ j $ を結ぶ辺が存在する

が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq8 $
- $ 0\leq\ M\ _\ G\leq\dfrac{N(N-1)}2 $
- $ 0\leq\ M\ _\ H\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ G) $
- $ (u\ _\ i,v\ _\ i)\neq(u\ _\ j,v\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ G) $
- $ 1\leq\ a\ _\ i\lt\ b\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ H) $
- $ (a\ _\ i,b\ _\ i)\neq(a\ _\ j,b\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ H) $
- $ 1\leq\ A\ _\ {i,j}\leq\ 10\ ^\ 6\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

与えられたグラフはそれぞれ以下のようになります。 !\[\](https://img.atcoder.jp/abc371/fbdb304dc71eecd7ddec97276a9c7040.png) たとえば、$ H $ に対して次のような $ 4 $ つの操作を順に行うことで、$ 9 $ 円を支払って$ G $ と $ H $ を同型にすることができます。 - $ (i,j)=(1,3) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(2,5) $ として操作を行う。$ H $ には頂点 $ 2 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 2 $ 円を支払ってこれを追加する。 - $ (i,j)=(1,5) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 5 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(3,5) $ として操作を行う。$ H $ には頂点 $ 3 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 5 $ 円を支払ってこれを追加する。 操作の結果、$ H $ は以下のようになります。 !\[\](https://img.atcoder.jp/abc371/68a56da8ec89b769989ae7d07bf163cd.png) 支払う金額を $ 8 $ 円以下にして $ G $ と $ H $ を同型にすることはできないため、`9` を出力してください。

### Sample Explanation 2

たとえば、$ (i,j)=(2,3),(2,4),(3,4) $ とした $ 3 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 3

たとえば、$ (i,j)=(4,5) $ とした $ 1 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 4

$ G $ や $ H $ には辺が含まれていないこともあります。 また、一度も操作をする必要がないこともあります。

## 样例 #1

### 输入

```
5
4
1 2
2 3
3 4
4 5
4
1 2
1 3
1 4
1 5
3 1 4 1
5 9 2
6 5
3```

### 输出

```
9```

## 样例 #2

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
9 1 1 1
1 1 1
1 1
9```

### 输出

```
3```

## 样例 #3

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
5 4 4 4
4 4 4
4 4
5```

### 输出

```
5```

## 样例 #4

### 输入

```
2
0
0
371```

### 输出

```
0```

## 样例 #5

### 输入

```
8
13
1 8
5 7
4 6
1 5
7 8
1 6
1 2
5 8
2 6
5 6
6 7
3 7
4 8
15
3 5
1 7
4 6
3 8
7 8
1 2
5 6
1 6
1 5
1 4
2 8
2 6
2 4
4 7
1 3
7483 1694 5868 3296 9723 5299 4326
5195 4088 5871 1384 2491 6562
1149 6326 2996 9845 7557
4041 7720 1554 5060
8329 8541 3530
4652 3874
3748```

### 输出

```
21214```

# AI分析结果

### 题目翻译
【题目内容】
# [ABC371C] 使图同构

## 题目描述

给定两个简单无向图 $G$ 和 $H$，每个图都有 $N$ 个顶点。$G$ 有 $M_G$ 条边，$H$ 有 $M_H$ 条边。你可以对 $H$ 进行任意次数的操作，每次操作选择两个顶点 $i$ 和 $j$，支付 $A_{i,j}$ 日元，添加或删除连接 $i$ 和 $j$ 的边。求使 $G$ 和 $H$ 同构的最小花费。

## 说明/提示

### 制約
- $1 \leq N \leq 8$
- $0 \leq M_G \leq \frac{N(N-1)}{2}$
- $0 \leq M_H \leq \frac{N(N-1)}{2}$
- $1 \leq u_i < v_i \leq N$ ($1 \leq i \leq M_G$)
- $(u_i, v_i) \neq (u_j, v_j)$ ($1 \leq i < j \leq M_G$)
- $1 \leq a_i < b_i \leq N$ ($1 \leq i \leq M_H$)
- $(a_i, b_i) \neq (a_j, b_j)$ ($1 \leq i < j \leq M_H$)
- $1 \leq A_{i,j} \leq 10^6$ ($1 \leq i < j \leq N$)
- 输入均为整数

### 样例解释
样例1：给定两个图，通过4次操作使它们同构，最小花费为9日元。

样例2：通过3次操作使两个图同构，最小花费为3日元。

样例3：通过1次操作使两个图同构，最小花费为5日元。

样例4：两个图都没有边，不需要操作，花费为0日元。

样例5：通过多次操作使两个图同构，最小花费为21214日元。

### 综合分析与结论
本题的核心是通过对图 $H$ 进行边添加或删除操作，使其与图 $G$ 同构。由于 $N \leq 8$，可以通过枚举所有可能的顶点排列（全排列）来找到最小花费。每个排列对应一种顶点映射关系，计算在这种映射下，$G$ 和 $H$ 的边是否一致，不一致则累加相应边的操作花费。最终取所有排列中的最小花费。

### 题解评分与亮点
1. **作者：Him_shu (赞：14)**  
   - **星级：4.5**  
   - **亮点：** 使用DFS生成全排列，代码结构清晰，注释详细，易于理解。通过邻接矩阵存储图，方便比较边的一致性。
   - **核心代码：**
     ```cpp
     void dfs(int pos){
         if(pos>n){
             for(int i=1;i<=m1;i++){
                 h[hg[u1[i]]][hg[v1[i]]]=h[hg[v1[i]]][hg[u1[i]]]=1;
             }
             int sum=0;
             for(int i=1;i<n;i++){
                 for(int j=i+1;j<=n;j++){
                     if(h[i][j]==g[i][j]) continue;
                     sum+=a[i][j];
                 }
             }
             ans=min(ans,sum);
             memset(h,0,sizeof(h));
             return;
         }
         for(int i=1;i<=n;i++){
             if(!hg[i]){
                 hg[i]=pos;
                 dfs(pos+1);
                 hg[i]=0;
             }
         }
     }
     ```

2. **作者：small_lemon_qwq (赞：13)**  
   - **星级：4**  
   - **亮点：** 使用 `next_permutation` 生成全排列，代码简洁，逻辑清晰。通过邻接矩阵存储图，方便比较边的一致性。
   - **核心代码：**
     ```cpp
     void dfs(int x){
         if(x>n){
             int cnt=0;
             for(int i=1;i<=n;i++){
                 for(int j=i+1;j<=n;j++){
                     if(f[p[i]][p[j]]!=g[i][j]) cnt+=a[i][j];
                 }
             }
             ans=min(ans,cnt);
         }else{
             for(int i=1;i<=n;i++){
                 if(!vis[i]){
                     p[x]=i;
                     vis[i]=1;
                     dfs(x+1);
                     vis[i]=0;
                 }
             }
         }
     }
     ```

3. **作者：RedStoneShark (赞：10)**  
   - **星级：4**  
   - **亮点：** 使用 `next_permutation` 生成全排列，代码简洁，逻辑清晰。通过邻接矩阵存储图，方便比较边的一致性。
   - **核心代码：**
     ```cpp
     void dfs(int pos){
         if(pos>n){
             for(int i=1;i<=m1;i++){
                 h[hg[u1[i]]][hg[v1[i]]]=h[hg[v1[i]]][hg[u1[i]]]=1;
             }
             int sum=0;
             for(int i=1;i<n;i++){
                 for(int j=i+1;j<=n;j++){
                     if(h[i][j]==g[i][j]) continue;
                     sum+=a[i][j];
                 }
             }
             ans=min(ans,sum);
             memset(h,0,sizeof(h));
             return;
         }
         for(int i=1;i<=n;i++){
             if(!hg[i]){
                 hg[i]=pos;
                 dfs(pos+1);
                 hg[i]=0;
             }
         }
     }
     ```

### 最优关键思路
1. **全排列枚举**：由于 $N \leq 8$，直接枚举所有可能的顶点排列，计算每种排列下的花费，取最小值。
2. **邻接矩阵存储图**：通过邻接矩阵存储图，方便比较边的一致性，计算操作花费。
3. **DFS或`next_permutation`生成排列**：DFS或STL中的`next_permutation`函数均可用于生成全排列，选择适合的实现方式。

### 拓展思路
- **类似题目**：可以考虑更复杂的图同构问题，如带权图、有向图等。
- **优化思路**：对于更大的 $N$，可以考虑剪枝或启发式搜索来减少排列数量。

### 推荐题目
1. [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)

### 个人心得
- **调试经历**：在生成全排列时，注意排列的初始化和边界条件，避免重复计算。
- **踩坑教训**：在比较边的一致性时，确保邻接矩阵的初始化正确，避免遗漏或错误计算。
- **顿悟感想**：通过全排列枚举，可以有效地解决小规模图同构问题，但对于大规模问题需要更高效的算法。

---
处理用时：64.77秒
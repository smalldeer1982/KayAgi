# 题目信息

# [ABC374C] Separated Lunch

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_c

キーエンス本社に勤務する人数が増えてきたので、本社に存在する部署を $ 2 $ つのグループに分け、昼休みの時間帯を分けることにしました。

キーエンス本社には $ N $ 個の部署が存在し、$ i $ 番目 $ (1\leq\ i\leq\ N) $ の部署に所属する人数は $ K_i $ 人です。

それぞれの部署をグループ $ A $, $ B $ のいずれか一方に割り当て、グループごとに同時に昼休みをとり、 かつグループ $ A $, $ B $ の昼休みの時間が重ならないようにしたとき、同時に昼休みをとる最大人数としてあり得る最小の値を求めてください。  
 すなわち、グループ $ A $ に割り当てられた部署に所属する人数の合計とグループ $ B $ に割り当てられた部署に所属する人数の合計 のうち大きい方の値としてあり得る最小の値を求めてください。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 20 $
- $ 1\leq\ K_i\ \leq\ 10^8 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1,2,5 $ 番目の部署をグループ $ A $ に、$ 3,4 $ 番目の部署をグループ $ B $ に割り当てたとき、 グループ $ A $ に割り当てられた部署に所属する人数の合計は $ 2+3+12=17 $ 、 グループ $ B $ に割り当てられた部署に所属する人数の合計は $ 5+10=15 $ となり、 このとき同時に昼休みを取る最大人数は $ 17 $ となります。 一方で、グループ $ A,B $ それぞれに割り当てられた部署に所属する人数の合計がいずれも $ 16 $ 以下になるように 部署を割り当てることはできないため、$ 17 $ を出力します。

### Sample Explanation 2

同一人数の部署が複数存在する可能性もあります。

### Sample Explanation 3

例えば、$ 1,4,5 $ 番目の部署をグループ $ A $ に、$ 2,3,6 $ 番目の部署をグループ $ B $ に割り当てたとき同時に昼休みを取る最大人数は $ 89 $ となります。

## 样例 #1

### 输入

```
5

2 3 5 10 12```

### 输出

```
17```

## 样例 #2

### 输入

```
2

1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
6

22 25 26 45 22 31```

### 输出

```
89```

# AI分析结果

### 题目重写
# [ABC374C] 分开的午餐

## 题目描述

由于Keyence总部的工作人员数量增加，决定将总部内的部门分为两个组，并分开午餐时间。

Keyence总部有 $N$ 个部门，第 $i$ 个部门（$1\leq\ i\leq\ N$）有 $K_i$ 人。

将每个部门分配到组 $A$ 或组 $B$，使得两个组的午餐时间不重叠，且同时午餐的最大人数尽可能小。即，求组 $A$ 和组 $B$ 中人数较多的那个组的人数的可能最小值。

## 说明/提示

### 制約

- $2\leq\ N\ \leq\ 20$
- $1\leq\ K_i\ \leq\ 10^8$
- 输入均为整数

### 样例解释

样例1：将第1、2、5个部门分配到组 $A$，第3、4个部门分配到组 $B$，组 $A$ 的人数为17，组 $B$ 的人数为15，此时最大人数为17。无法使两组人数都小于或等于16，因此输出17。

样例2：可能存在多个部门人数相同的情况。

样例3：例如，将第1、4、5个部门分配到组 $A$，第2、3、6个部门分配到组 $B$，此时最大人数为89。

### 样例 #1

#### 输入

```
5
2 3 5 10 12
```

#### 输出

```
17
```

### 样例 #2

#### 输入

```
2
1 1
```

#### 输出

```
1
```

### 样例 #3

#### 输入

```
6
22 25 26 45 22 31
```

#### 输出

```
89
```

### 题解分析与结论

#### 综合分析
题目要求将 $N$ 个部门分成两组，使得两组中人数较多的那组的人数尽可能小。由于 $N$ 的范围很小（$2 \leq N \leq 20$），可以直接使用暴力枚举或深度优先搜索（DFS）来遍历所有可能的分组情况，计算每组的人数并取最小值。

#### 题解评分与亮点
1. **作者：A_R_O_N_A (赞：6)**
   - **星级：4.5**
   - **关键亮点**：使用状压DP的思想，通过二进制数表示分组状态，代码简洁且思路清晰。时间复杂度为 $O(2^n \times n)$，适合小规模数据。
   - **代码核心**：
     ```cpp
     for(int i=0;i<(1<<n);i++){
         for(int j=0;j<n;j++){
             if(i&(1<<j)) dp[i]+=a[j];
         }
     }
     for(int i=0;i<(1<<n);i++){
         ans=min(ans,max(dp[i],sum-dp[i]));
     }
     ```

2. **作者：fishing_cat (赞：4)**
   - **星级：4**
   - **关键亮点**：使用DFS进行分组，代码简洁易懂，时间复杂度为 $O(2^n)$，适合小规模数据。
   - **代码核心**：
     ```cpp
     void dfs(ll id, ll now) {
         if (id > n) {
             ans = min(ans,max(now, z - now));
             return ;
         }
         dfs(id+1, now + k[id]);
         dfs(id+1, now);
     }
     ```

3. **作者：Bobxing (赞：3)**
   - **星级：4**
   - **关键亮点**：使用DFS进行分组，代码简洁且易于理解，时间复杂度为 $O(2^n)$，适合小规模数据。
   - **代码核心**：
     ```cpp
     void dfs(int now, int asum, int bsum) {
         if (now == n + 1) {
             ans = min(ans, max(asum, bsum));
             return;
         }
         dfs(now + 1, asum + a[now], bsum);
         dfs(now + 1, asum, bsum + a[now]);
     }
     ```

#### 最优关键思路
- **暴力枚举**：由于 $N$ 的范围很小，直接枚举所有可能的分组情况，计算每组的人数并取最小值。
- **DFS优化**：通过DFS进行分组，减少代码复杂度，适合小规模数据。

#### 可拓展之处
- **类似题目**：可以扩展到更大规模的 $N$，此时需要使用更高效的算法，如动态规划或贪心算法。
- **同类型题**：如背包问题、子集和问题等。

#### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1466 集合 Subset Sums](https://www.luogu.com.cn/problem/P1466)

#### 个人心得
- **调试经历**：在DFS中，记录当前分组的人数和总人数，避免重复计算。
- **踩坑教训**：注意边界条件的处理，如 $N$ 的最大值和最小值。
- **顿悟感想**：小规模数据可以直接暴力枚举，无需复杂算法。

---
处理用时：39.37秒
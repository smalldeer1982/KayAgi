# 题目信息

# [ABC378D] Count Simple Paths

## 题目描述

给定一个 $H$ 行 $W$ 列的网格；令 $(i, j)$ 为网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子。 

当 $ S_{i,j} $ 为 `.` 时，格子为空格；当 $ S_{i,j} $ 为 `#` 时，格子为障碍物。

请计算从某个空格出发，经过 $K$ 次移动（上下左右），不经过障碍物且不重复经过同一个格子的路径数。

具体地，统计满足以下条件的，长度为 $K+1$ 的序列 $((i_0,j_0),(i_1,j_1),\dots,(i_K,j_K))$

- 对于每个 $ 0\ \leq\ k\ \leq\ K $，都有 $ 1\ \leq\ i_k\ \leq\ H,\ 1\ \leq\ j_k\ \leq\ W $，且 $ S_{i_k,j_k} $ 为 `.`。
- 对于每个 $ 0\ \leq\ k\ \leq\ K-1 $，有 $ |i_{k+1}-i_k|\ +\ |j_{k+1}-j_k|\ =\ 1 $。
- 对于每个 $ 0\ \leq\ k\ <\ l\ \leq\ K $，有 $ (i_k,j_k)\neq\ (i_l,j_l) $。

## 说明/提示

-  $1 \leq H, W \leq 10$
-  $1 \leq K \leq 11$
-  $H$, $W$, 和 $K$ 均为整数。
-  每个 $S_{i,j}$ 均为 `.` 或 `#`。
-  网格中至少存在一个格子为空格。

## 样例 #1

### 输入

```
2 2 2
.#
..```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 1
.#.
#.#```

### 输出

```
0```

## 样例 #3

### 输入

```
10 10 11
....#..#..
.#.....##.
..#...##..
...#......
......##..
..#......#
#........#
..##......
.###....#.
...#.....#```

### 输出

```
218070```

# AI分析结果

### 题目内容重写

给定一个 $H$ 行 $W$ 列的网格；令 $(i, j)$ 为网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子。 

当 $ S_{i,j} $ 为 `.` 时，格子为空格；当 $ S_{i,j} $ 为 `#` 时，格子为障碍物。

请计算从某个空格出发，经过 $K$ 次移动（上下左右），不经过障碍物且不重复经过同一个格子的路径数。

具体地，统计满足以下条件的，长度为 $K+1$ 的序列 $((i_0,j_0),(i_1,j_1),\dots,(i_K,j_K))$

- 对于每个 $ 0\ \leq\ k\ \leq\ K $，都有 $ 1\ \leq\ i_k\ \leq\ H,\ 1\ \leq\ j_k\ \leq\ W $，且 $ S_{i_k,j_k} $ 为 `.`。
- 对于每个 $ 0\ \leq\ k\ \leq\ K-1 $，有 $ |i_{k+1}-i_k|\ +\ |j_{k+1}-j_k|\ =\ 1 $。
- 对于每个 $ 0\ \leq\ k\ <\ l\ \leq\ K $，有 $ (i_k,j_k)\neq\ (i_l,j_l) $。

### 题解综合分析与结论

本题的题解大多采用了深度优先搜索（DFS）的方法，部分题解尝试了广度优先搜索（BFS），但由于BFS在处理回溯时较为复杂，因此DFS更为合适。所有题解的核心思路都是从每个空格出发，进行K步的搜索，并记录不重复经过的路径数。DFS的实现中，关键在于回溯时清除访问标记，以确保每个路径的独立性。

### 所选高星题解

#### 题解1：作者：zaolong (4星)
**关键亮点**：
- 使用DFS进行搜索，代码简洁明了。
- 通过双重循环枚举每个出发点，确保所有可能的路径都被考虑到。
- 回溯时清除访问标记，保证路径的唯一性。

**核心代码**：
```cpp
void dfs(int x, int y, int s){
    if(s==k+1){
        ans++;
        return;
    }
    for(int i=0;i<4;i++){
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(bj[xx][yy]==0&&1<=xx&&xx<=n&&1<=yy&&yy<=m){
            bj[xx][yy]=1;
            dfs(xx,yy,s+1);
            bj[xx][yy]=0;
        }
    }
}
```

#### 题解2：作者：sjh0626 (4星)
**关键亮点**：
- 使用DFS，代码结构清晰，易于理解。
- 通过`vis`数组记录访问状态，确保路径不重复。
- 在DFS中直接累加路径数，逻辑简单。

**核心代码**：
```cpp
void dfs(int x, int y, int step){
    if(step==k){
        ans++;
        return;
    }
    vis[x][y]=1;
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&g[nx][ny]=='.'&&vis[nx][ny]==0){
            vis[nx][ny]=1;
            dfs(nx,ny,step+1);
            vis[nx][ny]=0;
        }
    }
    vis[x][y]=0;
}
```

#### 题解3：作者：superLouis (4星)
**关键亮点**：
- 使用DFS，代码风格良好，注释详细。
- 通过`dis`数组记录步数，确保路径长度为K。
- 在DFS中直接累加路径数，逻辑清晰。

**核心代码**：
```cpp
void dfs(int x, int y, int stx, int sty) {
    if (dis[x][y] == k) { ans++; return; }
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (inb(nx, ny) && a[nx][ny] == '.' && !dis[nx][ny] && !(nx == stx && ny == sty)) {
            dis[nx][ny] = dis[x][y] + 1; dfs(nx, ny, stx, sty); dis[nx][ny] = 0;
        }
    }
}
```

### 最优关键思路与技巧

1. **DFS回溯**：在DFS中，每次访问一个格子后标记为已访问，回溯时清除标记，确保路径的唯一性。
2. **枚举起点**：通过双重循环枚举每个空格作为起点，确保所有可能的路径都被考虑到。
3. **步数控制**：在DFS中记录当前步数，当步数达到K时，累加路径数。

### 可拓展之处

本题的DFS回溯思路可以应用于其他类似的路径搜索问题，如迷宫问题、棋盘问题等。类似的题目可以通过调整搜索方向和步数限制来扩展。

### 推荐相似题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得摘录

- **调试经历**：部分题解提到在实现BFS时遇到困难，最终选择DFS实现，说明在处理回溯问题时，DFS更为直观和易于实现。
- **踩坑教训**：在DFS中，回溯时清除访问标记是关键，否则会导致路径重复计数。
- **顿悟感想**：通过枚举每个起点并控制步数，可以有效地解决路径搜索问题，这种思路在类似问题中具有通用性。

---
处理用时：55.96秒
# 题目信息

# [ABC383C] Humidifier 3

## 题目描述

给你一个 $H$ 行 $W$ 列的矩阵，如果为 `#` 代表为障碍物，`.` 为空地， `H` 为喷水器。   
定义一个地方是湿的，当且仅当有从一个喷水器可以通过最多 $D$ 步移动（四联通）到达这个地方。   
**注意，喷水器所在的地方也是湿的。**   
求有多少个湿的地方。

## 说明/提示

$1\le H,W\le1000$   
$1\le D\le H\times W$

## 样例 #1

### 输入

```
3 4 1

H...

#..H

.#.#```

### 输出

```
5```

## 样例 #2

### 输入

```
5 6 2

##...H

H.....

..H.#.

.HH...

.###..```

### 输出

```
21```

## 样例 #3

### 输入

```
1 6 3

...#..```

### 输出

```
0```

# AI分析结果

### 题目内容重写

【题目描述】

给你一个 $H$ 行 $W$ 列的矩阵，如果为 `#` 代表为障碍物，`.` 为空地，`H` 为喷水器。   
定义一个地方是湿的，当且仅当有从一个喷水器可以通过最多 $D$ 步移动（四联通）到达这个地方。   
**注意，喷水器所在的地方也是湿的。**   
求有多少个湿的地方。

【说明/提示】

$1\le H,W\le1000$   
$1\le D\le H\times W$

【样例 #1】

### 输入

```
3 4 1

H...

#..H

.#.#```

### 输出

```
5```

【样例 #2】

### 输入

```
5 6 2

##...H

H.....

..H.#.

.HH...

.###..```

### 输出

```
21```

【样例 #3】

### 输入

```
1 6 3

...#..```

### 输出

```
0```

### 题解分析与结论

本题的核心是通过多源 BFS 来计算每个点到最近的喷水器的距离，并统计距离不超过 $D$ 的点的数量。以下是各题解的要点总结：

1. **多源 BFS**：大多数题解都采用了多源 BFS 的思路，即将所有喷水器的位置作为起点，同时进行 BFS，这样可以避免重复计算，时间复杂度为 $O(HW)$。
2. **记忆化优化**：部分题解通过记忆化优化，避免了重复访问，进一步提高了效率。
3. **代码实现**：大多数题解的代码实现较为清晰，使用了队列和方向数组来简化 BFS 的实现。

### 评分较高的题解

#### 题解1：作者：ikunTLE (赞：12)

**评分：4.5星**

**关键亮点：**
- 使用了记忆化搜索，避免了重复计算，优化了 BFS 的效率。
- 代码结构清晰，使用了方向数组简化了 BFS 的实现。

**核心代码：**
```cpp
void bfs(int sx, int sy){
    while(!q.empty())
        q.pop();
    q.push({sx,sy,0});
    while(!q.empty()){
        node u=q.front();q.pop();
        int x=u.x,y=u.y,step=u.step;
        if(step>=d)
            continue;
        for(int i=1;i<=4;++i){
            int xx=x+dx[i],yy=y+dy[i];
            if(xx>=1&&xx<=h&&yy>=1&&yy<=w&&s[xx][yy]!='#'&&f[x][y]+1<f[xx][yy]){
                f[xx][yy]=f[x][y]+1;
                q.push({xx,yy,step+1});
            }
        }
    }
    return;
}
```

#### 题解2：作者：xk2013 (赞：6)

**评分：4星**

**关键亮点：**
- 将所有喷水器放入同一个队列进行 BFS，简化了多源 BFS 的实现。
- 代码简洁，易于理解。

**核心代码：**
```cpp
void bfs(void){
    while (!q.empty()){
        Node f = q.front();
        q.pop();
        if (f.step > d) continue;
        if (map[f.x][f.y] == '.') map[f.x][f.y] = '!';
        for (int i = 0; i < 4; i++){
            int tx = f.x + dir[i][0], ty = f.y + dir[i][1];
            if (0 <= tx && tx < h && 0 <= ty && ty < w && map[tx][ty] != '#' && !vis[tx][ty]){
                vis[tx][ty] = true;
                q.push(Node{tx, ty, f.step + 1});
            }
        }
    }
}
```

#### 题解3：作者：4041nofoundGeoge (赞：4)

**评分：4星**

**关键亮点：**
- 使用了 BFS 的模板，代码结构清晰，易于理解。
- 通过标记数组避免了重复访问，优化了 BFS 的效率。

**核心代码：**
```cpp
void bfs(int x, int y){
    queue<pair<int, int>> q;
    q.push({x, y});
    while (!q.empty()){
        auto u = q.front();
        q.pop();
        if (vis[u.first][u.second]) continue;
        vis[u.first][u.second] = true;
        if (u.second == d) continue;
        for (int i = 0; i < 4; i++){
            int nx = u.first + dx[i], ny = u.second + dy[i];
            if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] == '.' && !vis[nx][ny]){
                q.push({nx, ny});
            }
        }
    }
}
```

### 最优关键思路与技巧

1. **多源 BFS**：将所有喷水器作为起点同时进行 BFS，避免重复计算，时间复杂度为 $O(HW)$。
2. **记忆化优化**：通过记忆化数组记录每个点的最小距离，避免重复访问，进一步优化了 BFS 的效率。
3. **方向数组**：使用方向数组简化了 BFS 的实现，代码更加简洁。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
   - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
   - [P1131 最小生成树](https://www.luogu.com.cn/problem/P1131)

2. **拓展思路**：
   - 可以进一步优化 BFS 的实现，例如使用双向 BFS 或 A* 算法来减少搜索空间。
   - 对于更大的数据规模，可以考虑使用并行计算或 GPU 加速来进一步提高效率。

---
处理用时：52.89秒
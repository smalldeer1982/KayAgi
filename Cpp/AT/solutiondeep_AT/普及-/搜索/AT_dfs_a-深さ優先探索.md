# 题目信息

# 深さ優先探索

## 题目描述

[problemUrl]: https://atcoder.jp/contests/atc001/tasks/dfs_a

この問題は、講座用問題です。ページ下部に解説が掲載されています。

高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。

高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。

## 说明/提示

### 解説

  **[深さ優先探索による塗りつぶし](https://www.slideshare.net/secret/lyag9AlTOMIY2J "深さ優先探索による塗りつぶし")**  from **[AtCoder Inc.](http://www.slideshare.net/chokudai)** 

### Sample Explanation 1

高橋君は、魚屋にたどり着くことができません。

## 样例 #1

### 输入

```
4 5

s####

....#

#####

#...g```

### 输出

```
No```

## 样例 #2

### 输入

```
4 4

...s

....

....

.g..```

### 输出

```
Yes```

## 样例 #3

### 输入

```
10 10

s.........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

g.#.#.#.#.

#.#.#.#.#.

###.#.#.#.

#.....#...```

### 输出

```
No```

## 样例 #4

### 输入

```
10 10

s.........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

g.#.#.#.#.

#.#.#.#.#.

#.#.#.#.#.

#.....#...```

### 输出

```
Yes```

## 样例 #5

### 输入

```
1 10

s..####..g```

### 输出

```
No```

# AI分析结果

### 题目内容重写（中文）

高桥君住的街区是长方形的，被划分为多个格子。每个格子要么是道路，要么是墙壁。高桥君可以在道路上向东西南北四个方向移动，但不能斜着走，也不能穿过墙壁。给定一个地图，判断高桥君是否能够从起点（'s'）出发，不破坏墙壁的情况下到达鱼店（'g'）。

### 样例输入输出

#### 样例 #1
**输入：**
```
4 5

s####

....#

#####

#...g
```
**输出：**
```
No
```

#### 样例 #2
**输入：**
```
4 4

...s

....

....

.g..
```
**输出：**
```
Yes
```

### 题解分析与结论

#### 题解对比与评分
1. **作者：hhhwg07 (赞：68)**  
   - **星级：4.5**  
   - **亮点：** 使用DFS进行搜索，通过二维数组`g`表示可走区域，并巧妙地将地图外围设置为不可走区域，避免越界问题。代码简洁，逻辑清晰，且通过`check`变量优化了搜索过程。  
   - **核心代码：**
     ```cpp
     void dfs(int x,int y){
         if(check) return;
         if(ex==x&&ey==y){
             check=true;
             return;
         }
         for(int i=0;i<4;i++){
             int nowx=x+dx[i],nowy=y+dy[i];
             if(g[nowx][nowy]){
                 g[x][y]=false;
                 dfs(nowx,nowy);
             }
         }
     }
     ```

2. **作者：mcyqwq (赞：22)**  
   - **星级：4**  
   - **亮点：** 使用BFS进行搜索，通过队列实现广度优先搜索，首次搜索到目标节点即可输出结果，避免了不必要的搜索。代码结构清晰，适合BFS初学者。  
   - **核心代码：**
     ```cpp
     while(head!=tail){
         head++;
         for(int i=0;i<4;i++){
             int x=a[head]+dx[i], y=b[head]+dy[i];
             if(x<=n&&x>0&&y<=m&&y>0&&!map[x][y]){
                 tail++;
                 a[tail]=x; b[tail]=y;
                 map[x][y]=-1;
                 if(x==ex&&y==ey) check=1;
             }
         }
         if(check) break;
     }
     ```

3. **作者：uiuili (赞：11)**  
   - **星级：4**  
   - **亮点：** 提供了DFS和BFS两种解法，代码结构清晰，适合对比学习两种搜索算法。DFS部分通过`vis`数组标记已访问节点，避免重复搜索。  
   - **核心代码：**
     ```cpp
     bool dfs(int x,int y){
         if(maze[x][y]=='g') return true;
         vis[x][y]=1;
         for(int i=0;i<4;i++){
             int tx=x+dir[i][0], ty=y+dir[i][1];
             if(in(tx,ty) && maze[tx][ty]!='#' && !vis[tx][ty]){
                 if(dfs(tx,ty)) return true;
             }
         }
         return false;
     }
     ```

#### 最优关键思路与技巧
- **DFS优化：** 使用`check`变量提前终止搜索，避免不必要的递归调用。  
- **BFS优势：** 首次搜索到目标节点即可输出结果，适合最短路径问题。  
- **避免越界：** 通过将地图外围设置为不可走区域，简化边界判断。  
- **状态标记：** 使用`vis`数组或修改地图标记已访问节点，避免重复搜索。

#### 可拓展之处
- **类似题目：** 可以扩展到其他搜索问题，如迷宫最短路径、连通区域问题等。  
- **算法优化：** 可以结合A*算法或双向BFS进一步优化搜索效率。

#### 推荐题目
1. **P1141 01迷宫**  
2. **P1443 马的遍历**  
3. **P1162 填涂颜色**

#### 个人心得摘录
- **hhhwg07：** “将小区外面围一圈false之后，妈妈就再也不会担心我越界了！”  
- **mcyqwq：** “BFS在第一次搜索到目标节点时即可输出答案，无需继续进行后面的循环。”  
- **uiuili：** “从(x,y)无法到达终点，则从其他点到达(x,y)之后也无法到达终点，故无需回溯。”

---
处理用时：43.73秒
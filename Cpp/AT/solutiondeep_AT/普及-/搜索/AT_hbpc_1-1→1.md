# 题目信息

# 1→1

## 题目描述

$m$表示变化规则的数量，$n$表示要生成$1$的数量。

对于生成规则$a_{i},b_{i}$而言，它表示可以将原字符串中的$a_{i}$个$1$变为$b_{i}$个$1$。例如，$a_{i}=2,b_{i}=3$，表示原字符串中$11$可以变为$111$

现在，原字符串中只有$1$个$1$，要求你使用最少的变化次数将字符串变成$n$个$1$。

## 说明/提示

- $1≤m≤300^{2}$
- $1≤n≤10000$
- $1≤a_{i},b_{i}≤300$
- 当$i≠j$时保证$a_{i}≠a_{j}$且$b_{i}≠b_{j}$


### 样例$1$

规则为：

$1->11$

$111->11111$

那么一个$1$变成$11111$需要经过下面这些步骤：

1->11

11->111

111->1111

变化次数为$3$，故答案为$4$。

### 样例$2$

规则为：

$1->111$

$11111->111$

那么一个$1$不可能变成$111111$，故答案为$-1$。

# AI分析结果

### 题目内容重写

**题目描述**

给定$m$表示变化规则的数量，$n$表示要生成$1$的数量。

对于生成规则$a_{i},b_{i}$而言，它表示可以将原字符串中的$a_{i}$个$1$变为$b_{i}$个$1$。例如，$a_{i}=2,b_{i}=3$，表示原字符串中$11$可以变为$111$。

现在，原字符串中只有$1$个$1$，要求你使用最少的变化次数将字符串变成$n$个$1$。

**说明/提示**

- $1≤m≤300^{2}$
- $1≤n≤10000$
- $1≤a_{i},b_{i}≤300$
- 当$i≠j$时保证$a_{i}≠a_{j}$且$b_{i}≠b_{j}$

### 题解分析与结论

#### 综合分析

所有题解均采用了广度优先搜索（BFS）算法来解决该问题。BFS适用于寻找最短路径的问题，本题中从初始状态（1个1）到目标状态（n个1）的最少变化次数可以通过BFS逐层扩展状态来实现。题解中的主要思路包括：

1. **状态表示**：使用结构体或pair来表示当前1的个数和变化次数。
2. **队列管理**：使用队列来存储待扩展的状态，确保按层扩展。
3. **剪枝优化**：通过标记已访问的状态和限制状态的范围（如n+300）来减少不必要的计算。
4. **特判处理**：当n=1时直接输出1，避免不必要的搜索。

#### 评分较高的题解

1. **作者：翼德天尊 (5星)**
   - **关键亮点**：代码结构清晰，注释详细，剪枝优化合理，特判处理得当。
   - **代码核心思想**：使用BFS逐层扩展状态，通过标记已访问的状态和限制状态范围来优化搜索。
   - **核心代码片段**：
     ```cpp
     while (!q.empty()){
         node no=q.front();//提取队列第一项
         q.pop();//删除
         for (int i=1;i<=m;i++){//循环每一个变化规则
             if (no.x>=a[i]){//现有的1的数量要大于该变化规则至少需要的1的数量
                 node noo;//新建一个结构体
                 noo.l=no.l+1;
                 noo.x=no.x-a[i]+b[i]; //放入下一个点的数据
                 if (v[noo.x]==0&&noo.x<=n+300){//如果将要演变的点未走过且在范围内
                     if (noo.x==n){//如果符合就输出
                         printf("%d\n",noo.l);
                         return 0;
                     }
                     v[noo.x]=1;//标记
                     q.push(noo);//推入
                 }
             }
         }
     }
     ```

2. **作者：FlyfishO25 (4星)**
   - **关键亮点**：提供了两种版本的代码，其中第二种版本参考了其他题解的优化思路，代码结构清晰，优化思路明确。
   - **代码核心思想**：使用BFS逐层扩展状态，通过排序规则和限制状态范围来优化搜索。
   - **核心代码片段**：
     ```cpp
     while(!Q.empty()){
         one tmp = Q.front();
         Q.pop();
         for(int i = 1;i <= m;++i){
             if(tmp.x >= c[i].first){
                 one tp;
                 tp.change_time = tmp.change_time + 1;
                 tp.x = tmp.x-c[i].first+c[i].second;
                 if(!vis[tp.x] && tp.x < n+300){
                     if(tp.x == n){
                         cout<<tp.change_time<<endl;
                         return 0;
                     }
                     vis[tp.x] = true;
                     Q.push(tp);
                 }
             }
             else{
                 break;
             }
         }
     }
     ```

3. **作者：Max_Leo (4星)**
   - **关键亮点**：代码简洁，优化思路明确，特判处理得当。
   - **代码核心思想**：使用BFS逐层扩展状态，通过标记已访问的状态和限制状态范围来优化搜索。
   - **核心代码片段**：
     ```cpp
     while(!Q.empty()){
         node u=Q.front();
         Q.pop();
         for(int i=1;i<=m;i++){
             if(u.len<p[i].a)continue;
             node v;
             v.len=u.len-p[i].a+p[i].b;
             v.step=u.step+1;
             if(v.len>n+300)continue;
             if(used[v.len])continue;
             if(v.len==n){
                 printf("%d\n",v.step);
                 return 0;
             }
             Q.push(v);
             used[v.len]=1;
         }
     }
     ```

### 最优关键思路与技巧

1. **BFS逐层扩展**：通过队列逐层扩展状态，确保找到最短路径。
2. **剪枝优化**：通过标记已访问的状态和限制状态范围（如n+300）来减少不必要的计算。
3. **特判处理**：当n=1时直接输出1，避免不必要的搜索。

### 可拓展之处

1. **类似问题**：可以扩展到其他状态转换问题，如最短路径、最少操作次数等。
2. **优化思路**：可以考虑使用双向BFS或其他启发式搜索算法来进一步优化搜索效率。

### 推荐题目

1. **P1137 旅行计划**：考察BFS在最短路径问题中的应用。
2. **P1162 填涂颜色**：考察BFS在图形填充问题中的应用。
3. **P1443 马的遍历**：考察BFS在棋盘问题中的应用。

### 个人心得总结

- **调试经历**：部分题解提到在调试过程中遇到的错误，如初始状态的特判处理不当，导致程序无法正确输出结果。
- **踩坑教训**：在BFS中，剪枝和状态标记非常重要，否则容易导致超时或死循环。
- **顿悟感想**：通过BFS逐层扩展状态，可以有效地找到最短路径，剪枝和优化是提高算法效率的关键。

---
处理用时：55.37秒
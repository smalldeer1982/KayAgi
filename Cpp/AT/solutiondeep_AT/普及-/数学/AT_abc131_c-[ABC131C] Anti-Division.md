# 题目信息

# [ABC131C] Anti-Division

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc131/tasks/abc131_c

整数 $ A,B,C,D $ が与えられます。$ A $ 以上 $ B $ 以下の整数のうち、$ C $ でも $ D $ でも割り切れないものの個数を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ A\leq\ B\leq\ 10^{18} $
- $ 1\leq\ C,D\leq\ 10^9 $
- 入力はすべて整数である

### Sample Explanation 1

$ 5,7 $ が条件を満たします。

## 样例 #1

### 输入

```
4 9 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
10 40 6 8```

### 输出

```
23```

## 样例 #3

### 输入

```
314159265358979323 846264338327950288 419716939 937510582```

### 输出

```
532105071133627368```

# AI分析结果

【题目内容】
# [ABC131C] Anti-Division

## 题目描述

给定整数 $A,B,C,D$。求 $A$ 以上 $B$ 以下的整数中，既不能被 $C$ 整除，也不能被 $D$ 整除的数的个数。

## 说明/提示

### 制約

- $1\leq\ A\leq\ B\leq\ 10^{18}$
- $1\leq\ C,D\leq\ 10^9$
- 输入均为整数

### 样例解释

#### 样例 #1

输入：
```
4 9 2 3
```
输出：
```
2
```
解释：$5,7$ 满足条件。

#### 样例 #2

输入：
```
10 40 6 8
```
输出：
```
23
```

#### 样例 #3

输入：
```
314159265358979323 846264338327950288 419716939 937510582
```
输出：
```
532105071133627368
```

---

【题解分析与结论】

### 综合分析

所有题解都基于**容斥原理**，通过计算区间内能被 $C$ 或 $D$ 整除的数的个数，再通过总数减去这些数来得到结果。核心难点在于如何高效计算区间内能被某个数整除的数的个数，以及如何处理 $C$ 和 $D$ 的最小公倍数。

### 最优思路与技巧

1. **容斥原理**：通过计算能被 $C$ 整除的数的个数、能被 $D$ 整除的数的个数，以及能被 $C$ 和 $D$ 的最小公倍数整除的数的个数，最终得到结果。
2. **最小公倍数的计算**：使用公式 $\text{lcm}(C,D) = \frac{C \times D}{\gcd(C,D)}$ 计算最小公倍数。
3. **区间内整除数的计算**：通过 $\lfloor \frac{B}{x} \rfloor - \lfloor \frac{A-1}{x} \rfloor$ 计算区间 $[A,B]$ 内能被 $x$ 整除的数的个数。

### 推荐题解

#### 1. 作者：苏联小渣 (5星)
**关键亮点**：
- 代码简洁，直接使用容斥原理公式。
- 通过 `__gcd` 函数计算最小公倍数，代码高效。
- 使用等差数列公式计算区间内能被整除的数的个数，逻辑清晰。

**核心代码**：
```cpp
int calc(int p){
    int l = x + p - (x%p==0?p:x%p), r = y - y % p;
    return (r - l) / p + 1;
}
signed main(){
    scanf ("%lld%lld%lld%lld", &x, &y, &z, &w);
    printf ("%lld\n", y - x + 1 - calc(z) - calc(w) + calc(z*w/(__gcd(z, w))));
    return 0;
}
```

#### 2. 作者：seac_blue (4星)
**关键亮点**：
- 详细解释了容斥原理的应用。
- 通过 `fix` 变量处理 $A$ 是否能被整除的情况，逻辑严谨。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
ll f(ll div){
    ll rval=b/div;
    ll lval=a/div;
    ll fix=0;
    if(!(a%div))fix=1;
    return rval-lval+fix;
}
int main(){
    a=read();b=read();c=read();d=read();
    ll g=gcd(c,d);
    printf("%lld\n",b-a+1-f(c)-f(d)+f(c*d/g));
    return 0;
}
```

#### 3. 作者：RBI_GL (4星)
**关键亮点**：
- 代码简洁，直接使用容斥原理公式。
- 通过 `gcd` 和 `lcm` 函数计算最小公倍数，逻辑清晰。
- 代码结构简单，易于实现。

**核心代码**：
```cpp
int lcm(int p, int q) {
    return p * q / gcd(p, q);
}
int main() {
    cin >> a >> b >> c >> d;
    ans = (b - a + 1) - (b / c - (a - 1) / c) - (b / d - (a - 1) / d) + (b / lcm(c, d) - (a - 1) / lcm(c, d));
    cout << ans << endl; 
    return 0;
}
```

---

【拓展与推荐】

### 拓展思路

- **容斥原理的扩展**：可以扩展到更多条件的情况，如三个或更多数的整除问题。
- **区间问题的优化**：在处理大区间问题时，可以考虑使用数学公式优化计算，避免暴力枚举。

### 推荐题目

1. [P2522 [HAOI2011]Problem b](https://www.luogu.com.cn/problem/P2522) - 区间内满足条件的数的个数问题。
2. [P2568 GCD](https://www.luogu.com.cn/problem/P2568) - 区间内最大公约数问题。
3. [P2261 [CQOI2007]余数求和](https://www.luogu.com.cn/problem/P2261) - 区间内余数求和问题。

---
处理用时：42.53秒
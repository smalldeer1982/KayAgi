# 题目信息

# [ABC369C] Count Arithmetic Subarrays

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc369/tasks/abc369_c

長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。

$ 1\leq\ l\leq\ r\leq\ N $ を満たす整数の組 $ (l,r) $ であって、数列 $ (A_l,A_{l+1},\dots,A_r) $ が等差数列であるようなものが何通りあるか求めてください。

なお、数列 $ (x_1,x_2,\dots,x_{|x|}) $ が等差数列であるとは、ある $ d $ が存在して $ x_{i+1}-x_i=d\ (1\leq\ i\ <\ |x|) $ であることをいいます。 特に、長さ $ 1 $ の数列は常に等差数列です。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

条件を満たす整数の組 $ (l,r) $ は $ (1,1),(2,2),(3,3),(4,4),(1,2),(2,3),(3,4),(1,3) $ の $ 8 $ 通りです。 実際、$ (l,r)=(1,3) $ のとき $ (A_l,\dots,A_r)=(3,6,9) $ は等差数列なので条件を満たしますが、 $ (l,r)=(2,4) $ のとき $ (A_l,\dots,A_r)=(6,9,3) $ は等差数列ではないので条件を満たしません。

### Sample Explanation 2

すべての整数の組 $ (l,r)\ (1\leq\ l\leq\ r\leq\ 5) $ が条件を満たします。

## 样例 #1

### 输入

```
4

3 6 9 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5

1 1 1 1 1```

### 输出

```
15```

## 样例 #3

### 输入

```
8

87 42 64 86 72 58 44 30```

### 输出

```
22```

# AI分析结果

### 题目翻译
给定一个长度为 $N$ 的正整数序列 $A=(A_1,A_2,\dots,A_N)$。求满足 $1\leq l\leq r\leq N$ 的整数对 $(l,r)$ 的数量，使得子序列 $(A_l,A_{l+1},\dots,A_r)$ 是等差数列。  
等差数列的定义是：存在一个公差 $d$，使得 $x_{i+1}-x_i=d$ 对所有 $1\leq i < |x|$ 成立。特别地，长度为 $1$ 的序列总是等差数列。

### 样例解释
#### 样例 #1
输入：
```
4
3 6 9 3
```
输出：
```
8
```
解释：满足条件的整数对 $(l,r)$ 有 $(1,1),(2,2),(3,3),(4,4),(1,2),(2,3),(3,4),(1,3)$ 共 $8$ 种。

#### 样例 #2
输入：
```
5
1 1 1 1 1
```
输出：
```
15
```
解释：所有整数对 $(l,r)$ 都满足条件。

#### 样例 #3
输入：
```
8
87 42 64 86 72 58 44 30
```
输出：
```
22
```

### 题解分析与结论

#### 最优思路总结
1. **双指针法**：通过维护一个左指针和右指针，遍历序列，找到最长的等差数列子串，然后利用等差数列的性质计算子串的数量。
2. **差分数组**：通过计算相邻元素的差值，判断是否构成等差数列，从而减少重复计算。
3. **动态规划**：记录以每个位置结尾的等差数列长度，利用前一个状态更新当前状态，最终累加所有可能的等差数列数量。

#### 评分较高的题解
1. **PineappleSummer 的题解**（评分：4星）
   - **亮点**：使用动态规划的思路，记录以每个位置结尾的等差数列长度，思路清晰，代码简洁。
   - **代码核心**：
     ```cpp
     for (int i = 3; i <= n; i++) {
         if (a[i] - a[i - 1] == a[i - 1] - a[i - 2])
             b[i] = b[i - 1] + 1;
         else b[i] = 2;
     }
     for (int i = 1; i <= n; i++) ans += b[i];
     ```
   - **个人心得**：通过记录每个位置的等差数列长度，避免了重复计算，时间复杂度为 $O(n)$。

2. **ikunTLE 的题解**（评分：4星）
   - **亮点**：使用双指针法，结合等差数列求和公式，优化了计算过程，代码实现较为高效。
   - **代码核心**：
     ```cpp
     for (int i = 2; i <= n; i++)
         if (i > 2 && a[i] - a[i - 1] == a[i - 1] - a[i - 2])
             ++cnt;
         else {
             ans += (long long)cnt * (cnt - 1) / 2;
             cnt = 2;
         }
     ```
   - **个人心得**：通过双指针法，减少了不必要的计算，时间复杂度为 $O(n)$。

3. **woden 的题解**（评分：4星）
   - **亮点**：使用双指针法，结合等差数列的性质，通过维护左指针和右指针，找到最长的等差数列子串，计算其子串数量。
   - **代码核心**：
     ```cpp
     while (r <= n) {
         if (a[r] - a[r - 1] == d) r++;
         else {
             int len = r - l;
             sum += (len + 1) * len / 2;
             l = r - 1;
             d = a[r] - a[l];
             sum--;
         }
     }
     ```
   - **个人心得**：通过双指针法，避免了重复计算，时间复杂度为 $O(n)$。

### 推荐题目
1. **洛谷 P1102**：求等差数列的子序列数量。
2. **洛谷 P1118**：求等差数列的个数。
3. **洛谷 P1120**：求等差数列的子序列数量。

### 总结
本题的核心思路是通过双指针法或动态规划，结合等差数列的性质，高效地计算满足条件的子序列数量。双指针法适合处理连续子序列问题，而动态规划则适合处理状态转移问题。在实际应用中，可以根据问题的特点选择合适的算法。

---
处理用时：39.69秒
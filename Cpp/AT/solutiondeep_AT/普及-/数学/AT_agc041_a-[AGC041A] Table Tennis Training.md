# 题目信息

# [AGC041A] Table Tennis Training

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc041/tasks/agc041_a

$ 2N $ 人の卓球選手が、$ 1 $ から $ N $ までの番号がついた $ N $ 台の卓で実戦練習を行います。

練習は複数の *ラウンド* からなります。 各ラウンドでは、選手たちは $ 1 $ 卓につき $ 1 $ ペアの合計 $ N $ ペアに分かれます。 そして、各ペアの選手同士で試合を行い、$ 1 $ 人が勝利してもう $ 1 $ 人が敗北します。

卓 $ X $ で勝利した選手は、次のラウンドでは卓 $ X-1 $ で試合を行います。 ただし、卓 $ 1 $ で勝利した選手は卓 $ 1 $ に留まります。

同様に、卓 $ X $ で敗北した選手は、次のラウンドでは卓 $ X+1 $ で試合を行います。 ただし、卓 $ N $ で敗北した選手は卓 $ N $ に留まります。

ある $ 2 $ 人の選手は友達同士で、最初のラウンドの試合を異なる卓 $ A,\ B $ で行います。 彼らは十分な腕前を持ち、各試合での自分の勝敗を自由に操れるとします。 この $ 2 $ 人同士で試合を行えるまでに、最小で何回のラウンドが必要でしょうか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^{18} $
- $ 1\ \leq\ A\ <\ B\ \leq\ N $
- 入力中のすべての値は整数である。

### Sample Explanation 1

最初のラウンドで $ 1 $ 人目が敗北して $ 2 $ 人目が勝利すると、$ 2 $ 人とも卓 $ 3 $ に移動し、次のラウンドでは彼ら同士で試合を行えます。

### Sample Explanation 2

$ 2 $ 人とも $ 2 $ 連続で勝利すれば、両者とも卓 $ 1 $ に移れます。

## 样例 #1

### 输入

```
5 2 4```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2 3```

### 输出

```
2```

# AI分析结果

### 题目内容重写

#### 题目描述

有 $2N$ 名乒乓球选手，编号从 $1$ 到 $N$ 的 $N$ 张乒乓球桌进行实战练习。

练习由多个**轮次**组成。每个轮次中，选手们被分配到 $N$ 对中，每张桌子一对。然后，每对选手进行比赛，一人获胜，另一人失败。

在桌子 $X$ 获胜的选手，下一轮将在桌子 $X-1$ 比赛。但是，桌子 $1$ 获胜的选手将留在桌子 $1$。

同样，在桌子 $X$ 失败的选手，下一轮将在桌子 $X+1$ 比赛。但是，桌子 $N$ 失败的选手将留在桌子 $N$。

有两位选手是朋友，他们最初分别在不同的桌子 $A$ 和 $B$ 进行比赛。他们可以自由控制每场比赛的胜负。求这两位选手最少需要多少轮才能在同一张桌子比赛。

### 题解分析与结论

#### 综合分析

1. **问题核心**：两位选手通过控制比赛的胜负，使得他们最终在同一张桌子比赛。关键在于如何通过移动桌子的策略，使得两人尽快相遇。
2. **解题思路**：
   - 如果两位选手的初始位置差为偶数，则他们可以直接向中间移动，所需轮数为 $(B-A)/2$。
   - 如果初始位置差为奇数，则需要其中一人移动到边界（桌子 $1$ 或 $N$），然后再向中间移动，所需轮数为 $\min(N-B+1, A) + (B-A-1)/2$。
3. **难点**：处理初始位置差为奇数的情况，需要计算移动到边界所需的额外轮数。

#### 精选题解

1. **作者：_farawaystar_ (4星)**
   - **关键亮点**：清晰地将问题分为两种情况处理，代码简洁且高效，使用了三目运算符简化条件判断。
   - **代码核心**：
     ```cpp
     (b-a)%2==1?cout<<min(n-b+1,a)+(b-a-1)/2:cout<<(b-a)/2;
     ```
   - **个人心得**：通过分类讨论，简化了问题的复杂性，代码实现简洁明了。

2. **作者：123456zmy (4星)**
   - **关键亮点**：将问题抽象为两人在队列中移动，思路清晰，代码简洁，使用了位运算优化判断。
   - **代码核心**：
     ```cpp
     if((b-a)&1)printf("%lld",min((unsigned long long)((n<<1)-a-b+1),(unsigned long long)(a+b-1))>>1);
     else printf("%lld",b-a>>1);
     ```
   - **个人心得**：通过奇偶性判断，简化了问题的处理，代码实现高效。

3. **作者：shenmadongdong (4星)**
   - **关键亮点**：详细分析了奇偶性不同的情况，给出了清晰的公式推导，代码简洁且高效。
   - **代码核心**：
     ```cpp
     if (b-a&1ll) std::cout<<std::min(2*n+1-b-a>>1,b+a>>1);
     else std::cout<<(b-a>>1);
     ```
   - **个人心得**：通过公式推导，简化了问题的处理，代码实现简洁明了。

### 最优关键思路与技巧

1. **分类讨论**：将问题分为初始位置差为偶数和奇数两种情况，分别处理。
2. **边界处理**：对于初始位置差为奇数的情况，需要计算移动到边界所需的额外轮数。
3. **代码优化**：使用位运算和三目运算符简化条件判断，提高代码效率。

### 拓展思路与类似题目

1. **类似题目**：
   - [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
   - [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)
   - [P1011 车站](https://www.luogu.com.cn/problem/P1011)

2. **拓展思路**：在处理类似的移动问题时，可以考虑分类讨论和边界处理，通过公式推导简化问题，提高代码效率。

---
处理用时：38.35秒
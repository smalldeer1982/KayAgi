# 题目信息

# [ARC051B] 互除法

## 题目描述

高桥君学习了欧几里得算法，他很好奇它能以多快的速度运行。

因此，他写了以下代码。

```cpp
#include <stdio.h>

int counter = 0;
int gcd(int a, int b) {
   if (b == 0) return a;
   counter++;
   return gcd(b, a%b);
}

int main() {
   int a, b;
   scanf("%d %d", &a, &b);
   gcd(a, b);
   printf("%d\n", counter);
}
```

这个代码输入两个整数，然后用欧几里得计算它们的 $\gcd$，然后输出它递归了多少次的代码。 你想让这个程序输出各种各样的值。

具体来说，输入一个 $K$，输出一组可以使得这个程序的输出为 $K$ 的 $A$、$B$。

## 说明/提示

对于 $30\%$ 的数据，$1\le K \le 10$；

对于 $100\%$ 的数据，$1\le K \le 40$。

只输出其中一种可能的解即可。

## 样例 #1

### 输入

```
1```

### 输出

```
1 1```

## 样例 #2

### 输入

```
3```

### 输出

```
4 5```

## 样例 #3

### 输入

```
12```

### 输出

```
314159265 358979323```

# AI分析结果

### 题目内容重写

高桥君学习了欧几里得算法，他很好奇它能以多快的速度运行。

因此，他写了以下代码。

```cpp
#include <stdio.h>

int counter = 0;
int gcd(int a, int b) {
   if (b == 0) return a;
   counter++;
   return gcd(b, a%b);
}

int main() {
   int a, b;
   scanf("%d %d", &a, &b);
   gcd(a, b);
   printf("%d\n", counter);
}
```

这个代码输入两个整数，然后用欧几里得算法计算它们的 $\gcd$，然后输出它递归了多少次的代码。 你想让这个程序输出各种各样的值。

具体来说，输入一个 $K$，输出一组可以使得这个程序的输出为 $K$ 的 $A$、$B$。

### 说明/提示

对于 $30\%$ 的数据，$1\le K \le 10$；

对于 $100\%$ 的数据，$1\le K \le 40$。

只输出其中一种可能的解即可。

### 样例 #1

#### 输入

```
1```

#### 输出

```
1 1```

### 样例 #2

#### 输入

```
3```

#### 输出

```
4 5```

### 样例 #3

#### 输入

```
12```

#### 输出

```
314159265 358979323```

### 题解分析与结论

#### 综合分析与结论

本题的核心是通过构造一组数对 $(A, B)$，使得欧几里得算法的递归次数恰好为给定的 $K$。通过分析欧几里得算法的递归过程，可以发现斐波那契数列的相邻两项 $(F_{n-1}, F_n)$ 恰好满足递归次数为 $n$。因此，构造斐波那契数列的相邻两项是解决本题的关键。

#### 所选高星题解

1. **作者：Aw顿顿 (赞：10)**  
   - **星级：5星**  
   - **关键亮点**：详细解释了为什么斐波那契数列的相邻两项能够满足递归次数为 $n$，并通过表格展示了递归次数的规律。  
   - **个人心得**：通过数学归纳法证明了斐波那契数列的相邻两项能够满足递归次数为 $n$，思路清晰，解释透彻。

2. **作者：_ZhouYuHan_ (赞：4)**  
   - **星级：4星**  
   - **关键亮点**：提供了完整的代码实现，简洁明了，易于理解。  
   - **核心代码**：
     ```cpp
     long long fib[42]={0,1,1};//斐波那契数列
     int k;
     int main(){
         cin>>k;
         for(int i=3;i<=41;i++)
             fib[i]=fib[i-1]+fib[i-2];//求斐波那契数列第i项 
         cout<<fib[k]<<" "<<fib[k+1]<<"\n";//输出 
         return 0; 
     }
     ```

3. **作者：xgwpp6710 (赞：0)**  
   - **星级：4星**  
   - **关键亮点**：通过倒推的方式构造解，思路新颖，代码简洁。  
   - **核心代码**：
     ```cpp
     long long a[100009],b[100009],k;
     int main()
     {
         cin>>k;
         a[1]=b[1]=1;
         for(int i=2;i<=k;i++)
         {
             a[i]=b[i-1];
             b[i]=a[i-1]+b[i-1];//这里b大于a，使得一开始需要做一部换a和b的操作。容易验证这样的解满足要求。
         }
         cout<<a[k]<<" "<<b[k]<<endl;
         return 0;
     }
     ```

### 最优关键思路或技巧

- **斐波那契数列的应用**：通过斐波那契数列的相邻两项 $(F_{n-1}, F_n)$ 构造解，使得欧几里得算法的递归次数恰好为 $n$。
- **数学归纳法**：通过数学归纳法证明斐波那契数列的相邻两项能够满足递归次数为 $n$。

### 可拓展之处

- **类似算法套路**：在需要构造特定递归次数的算法中，可以考虑使用斐波那契数列或其他类似的数列来构造解。
- **扩展阅读**：可以进一步研究欧几里得算法的复杂度分析，了解其在最坏情况下的表现。

### 推荐题目

1. [P1447 斐波那契数列](https://www.luogu.com.cn/problem/P1447)
2. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)
3. [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)

---
处理用时：37.89秒
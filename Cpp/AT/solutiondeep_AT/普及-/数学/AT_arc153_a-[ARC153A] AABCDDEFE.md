# 题目信息

# [ARC153A] AABCDDEFE

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc153/tasks/arc153_a

正整数 $ x $ が**美しい整数**であるとは，$ x $ が $ 9 $ 桁の整数であり，その $ 10 $ 進法表記 $ S_1\ldots\ S_9 $ （$ S_i $ は $ x $ の $ 10 $ 進法表記の $ i $ 文字目）が以下の条件をすべて満たすことをいいます：

- $ S_1 $ は `0` ではない
- $ S_1\ =\ S_2 $
- $ S_5\ =\ S_6 $
- $ S_7\ =\ S_9 $
 
例えば $ 998244353 $ や $ 333333333 $ は美しい整数です．$ 111112222 $ は $ S_5\ \neq\ S_6 $ であるため美しい整数ではありません．

正の整数 $ N $ が与えられます．小さい方から数えて $ N $ 番目の美しい整数を答えてください．

## 说明/提示

### 制約

- $ N $ は正の整数
- 美しい整数が $ N $ 個以上存在する
 
### Sample Explanation 1

美しい整数を小さい順に並べると，$ 110000000,\ 110000010,\ 110000020,\ \ldots $ となります．

## 样例 #1

### 输入

```
3```

### 输出

```
110000020```

## 样例 #2

### 输入

```
882436```

### 输出

```
998244353```

## 样例 #3

### 输入

```
2023```

### 输出

```
110200222```

# AI分析结果

### 题目翻译

【题目内容】
# [ARC153A] AABCDDEFE

## 题目描述

正整数 $ x $ 被称为**美しい整数**（美丽整数），当且仅当 $ x $ 是一个 $ 9 $ 位整数，并且其十进制表示 $ S_1\ldots\ S_9 $ （$ S_i $ 是 $ x $ 的十进制表示的第 $ i $ 位数字）满足以下所有条件：

- $ S_1 $ 不是 `0`；
- $ S_1\ =\ S_2 $；
- $ S_5\ =\ S_6 $；
- $ S_7\ =\ S_9 $。

例如，$ 998244353 $ 和 $ 333333333 $ 是美丽整数。而 $ 111112222 $ 由于 $ S_5\ \neq\ S_6 $，因此不是美丽整数。

给定一个正整数 $ N $，请输出从小到大的第 $ N $ 个美丽整数。

## 说明/提示

### 约束

- $ N $ 是一个正整数；
- 美丽整数的数量至少为 $ N $ 个。

### 样例解释 1

美丽整数按从小到大的顺序排列为：$ 110000000,\ 110000010,\ 110000020,\ \ldots $。

## 样例 #1

### 输入

```
3```

### 输出

```
110000020```

## 样例 #2

### 输入

```
882436```

### 输出

```
998244353```

## 样例 #3

### 输入

```
2023```

### 输出

```
110200222```

---

### 题解分析与结论

本题的核心是生成满足特定条件的9位数，并找到第N个符合条件的数。题解中主要分为以下几种思路：

1. **暴力枚举**：通过多重循环枚举所有可能的数字组合，统计符合条件的数，直到找到第N个。这种方法虽然简单直观，但时间复杂度较高，适合小规模数据。
2. **数学优化**：通过观察题目条件，发现某些位数的数字是固定的，从而将问题转化为更简单的形式。例如，将9位数转化为6位数，再通过数学公式生成最终结果。这种方法时间复杂度低，适合大规模数据。
3. **数位DP**：通过动态规划的方法，统计符合条件的数的数量，结合二分查找快速定位第N个数。这种方法适用于更复杂的数位问题，但实现较为复杂。

### 评分较高的题解

#### 1. 作者：U_star (赞：3) - 4星
**关键亮点**：通过观察题目条件，将9位数问题转化为6位数问题，大大降低了时间复杂度。代码简洁，思路清晰。
**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	string s=to_string(n+99999);
	cout<<s[0]<<s[0]<<s[1]<<s[2]<<s[3]<<s[3]<<s[4]<<s[5]<<s[4];
   	return 0; 
}
```
**核心思想**：将N转化为6位数，再通过字符串拼接生成最终的9位数。

#### 2. 作者：chlchl (赞：3) - 4星
**关键亮点**：使用数位DP结合二分查找，快速定位第N个符合条件的数。虽然实现较为复杂，但适用于更复杂的数位问题。
**核心代码**：
```cpp
int dp(int len, int op, int lst1, int lst2){
	if(!len) return 1;
	if(~f[len][op][lst1][lst2]) return f[len][op][lst1][lst2];
	int k = (op ? dgt[len] : 9);
	int cnt = 0;
	for(int d=0;d<=k;d++){
		if(len == 9 && d == 0) continue;
		if(len == 8 && d != lst1) continue;
		if(len == 4 && d != lst1) continue;
		if(len == 1 && d != lst2) continue;
		cnt += dp(len - 1, op & (d == k), d, lst1);
	}
	return f[len][op][lst1][lst2] = cnt;
}
```
**核心思想**：通过数位DP统计符合条件的数的数量，结合二分查找快速定位第N个数。

#### 3. 作者：FyFive (赞：0) - 4星
**关键亮点**：通过数学公式直接生成结果，时间复杂度为O(1)，代码简洁高效。
**核心代码**：
```cpp
int main()
{
    cin>>n;
    --n;
    n+=100000;
    ans=101*(n%100/10);
    ans+=10*(n%10);
    ans+=11000*(n%1000/100);
    ans+=100000*(n%10000/1000);
    ans+=1000000*(n%100000/10000);
    ans+=110000000*(n/100000);
    cout<<ans;
    return 0;
}
```
**核心思想**：通过数学公式直接生成第N个美丽整数，避免了复杂的循环和条件判断。

### 最优关键思路与技巧

1. **数学优化**：通过观察题目条件，将9位数问题转化为6位数问题，大大降低了时间复杂度。这种方法适用于类似的条件约束问题。
2. **数位DP**：对于更复杂的数位问题，数位DP结合二分查找是一种高效的解决方案。虽然实现较为复杂，但适用于大规模数据。

### 可拓展之处

1. **类似题目**：可以拓展到更多位数的数位问题，或者更复杂的条件约束问题。
2. **算法套路**：数位DP和数学优化是解决数位问题的常用套路，可以应用于其他类似的题目。

### 推荐题目

1. [P2657 [SCOI2009] windy数](https://www.luogu.com.cn/problem/P2657)
2. [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)
3. [P4127 [AHOI2009] 同类分布](https://www.luogu.com.cn/problem/P4127)

### 个人心得

- **调试经历**：在实现数位DP时，需要注意状态的转移和边界条件的处理，调试过程中容易遗漏某些条件。
- **顿悟感想**：通过观察题目条件，将问题转化为更简单的形式，可以大大降低时间复杂度，这是一种非常有效的解题思路。

---
处理用时：56.87秒
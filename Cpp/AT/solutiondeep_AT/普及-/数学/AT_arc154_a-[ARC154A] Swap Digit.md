# 题目信息

# [ARC154A] Swap Digit

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc154/tasks/arc154_a

先頭の桁が $ 0 $ でない $ N $ 桁の正整数 $ A,B $ が与えられます。

あなたは、以下の操作を好きな回数（$ 0 $ 回でもよい）繰り返すことができます。

- $ 0\ \le\ i\ \le\ N-1 $ を満たす整数 $ i $ を選び、$ A,B $ の $ 10^{i} $ の位の数字を交換する。
 
操作を終えたときの $ A\ \times\ B $ の最小値を $ 998244353 $ で割ったあまりを求めてください。

$ A\ \times\ B $ を $ 998244353 $ で割ったあまりの最小値を求めるのではないことに注意してください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 200000 $
- $ A,B $ は先頭の桁が $ 0 $ でない $ N $ 桁の正整数
 
### Sample Explanation 1

以下のように $ 1 $ 回操作を行うと $ A\ \times\ B $ を $ 276 $ にすることが出来ます。 - $ i=0 $ を選び、$ A,B $ の $ 1 $ の位の数字を交換する。$ A=12,B=23 $ となる。 $ A\ \times\ B $ を $ 275 $ 以下にすることは出来ないので、答えは $ 276 $ です。

### Sample Explanation 2

$ 998244353 $ で割ったあまりを求めてください。

## 样例 #1

### 输入

```
2

13

22```

### 输出

```
276```

## 样例 #2

### 输入

```
8

20220122

21002300```

### 输出

```
54558365```

# AI分析结果

【题目内容】
# [ARC154A] Swap Digit

## 题目描述

给定两个首位不为0的N位正整数A和B。你可以进行以下操作任意次（包括0次）：

- 选择一个满足0 ≤ i ≤ N-1的整数i，交换A和B的第i位数字。

操作结束后，求A × B的最小值，并将结果对998244353取模。

注意：要求的是A × B的最小值，而不是A × B对998244353取模的最小值。

## 说明/提示

### 约束条件

- 1 ≤ N ≤ 200000
- A和B是首位不为0的N位正整数

### 样例解释1

通过一次操作，可以将A × B的值变为276。具体操作为选择i=0，交换A和B的个位数字，得到A=12，B=23。无法将A × B的值变为275或更小，因此答案为276。

### 样例解释2

需要将结果对998244353取模。

## 样例 #1

### 输入

```
2

13

22```

### 输出

```
276```

## 样例 #2

### 输入

```
8

20220122

21002300```

### 输出

```
54558365```

【题解分析与结论】

### 综合分析

本题的核心思路是通过交换A和B的各位数字，使得A和B的差值最大化，从而使得A × B的值最小化。由于A和B的和在交换过程中保持不变，因此根据数学原理，当两个数的和固定时，它们的差值越大，乘积越小。

### 最优关键思路

1. **贪心策略**：对于每一位数字，将较大的数字分配给A，较小的数字分配给B，这样可以最大化A和B的差值。
2. **模运算处理**：由于N可能很大（最大200000），直接计算A和B的值会导致溢出，因此需要在计算过程中对每一步进行模运算。

### 题解评分与亮点

1. **作者：Register_int (5星)**
   - **亮点**：代码简洁明了，直接应用贪心策略，并在计算过程中进行模运算，避免了溢出问题。
   - **代码核心思想**：遍历每一位数字，将较大的数字分配给A，较小的数字分配给B，然后在计算A和B的值时进行模运算。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 2e5 + 10;
const int mod = 998244353;
int n; char a[MAXN], b[MAXN];
ll x, y;
int main() {
	scanf("%d%s%s", &n, a, b);
	for (int i = 0; i < n; i++) if (a[i] < b[i]) swap(a[i], b[i]);
	for (int i = 0; i < n; i++) x = (x * 10 + a[i] - '0') % mod, y = (y * 10 + b[i] - '0') % mod;
	printf("%lld", x * y % mod);
}
```

2. **作者：Iniaugoty (4星)**
   - **亮点**：详细证明了“和一定差小积大”的数学原理，增强了题解的理论基础。
   - **代码核心思想**：与Register_int类似，应用贪心策略并在计算过程中进行模运算。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
int n,a,b;
string A,B;
signed main(){
	scanf("%lld",&n);
	cin>>A>>B;
	for(int i=0;i<n;i++){
		if(A[i]<B[i])
			swap(A[i],B[i]);
		a=(a*10+A[i]-'0')%mod;
		b=(b*10+B[i]-'0')%mod;
	}
	printf("%lld",a*b%mod);
	return 0;
}
```

3. **作者：Crazyouth (4星)**
   - **亮点**：代码结构清晰，详细解释了每一步的操作，适合初学者理解。
   - **代码核心思想**：同样应用贪心策略，并在计算过程中进行模运算。

```cpp
#include <iostream>
#include <string>
using namespace std;
const long long MOD=998244353;
int main()
{
	long long n,x,y;
	string s1,s2;
	cin>>n>>s1>>s2;
	for(int i=0;i<n;i++)
	{
		if(s1[i]<s2[i]) swap(s1[i],s2[i]);
	}
   	x=s1[0]-'0';
   	y=s2[0]-'0';
	for(int i=1;i<n;i++)
	{
		x=x*10%MOD+(s1[i]-'0');
		y=y*10%MOD+(s2[i]-'0');
		x%=MOD;
		y%=MOD;
	}
    cout<<x*y%MOD;
	return 0;
}
```

### 拓展思路

本题的贪心策略可以推广到其他类似问题中，例如在给定两个数的和的情况下，如何通过调整数字的位置来最大化或最小化它们的乘积。类似的问题可以通过类似的思路来解决。

### 推荐题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1045 麦森数](https://www.luogu.com.cn/problem/P1045)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

### 个人心得总结

在解决类似问题时，理解数学原理（如和一定差小积大）是非常重要的，这可以帮助我们快速找到问题的解决方案。同时，在处理大数问题时，模运算是一个非常有用的技巧，可以避免溢出问题。

---
处理用时：47.67秒
# 题目信息

# [ARC156A] Non-Adjacent Flip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc156/tasks/arc156_a

$ 1 $ から $ N $ の番号がついた、表裏が区別できるコインが $ N $ 枚あります。コインの表裏は長さ $ N $ の文字列 $ S $ で表され、$ S $ の $ i $ 番目の文字が `1` のときコイン $ i $ は表を向いており、`0` のときコイン $ i $ は裏を向いています。

あなたは、以下の操作を $ 0 $ 回以上好きな回数繰り返すことができます。

- $ 1\leq\ i\ <\ j\leq\ N $ かつ $ j-i\geq\ \bm{2} $ を満たす整数組 $ (i,j) $ を選ぶ。コイン $ i $ とコイン $ j $ を裏返す。
 
操作によって $ N $ 枚のコイン全てを裏向きにできるか判定し、可能な場合必要な操作の回数の最小値を求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\times\ 10^5 $
- $ 3\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ S $ は `0`, `1` からなる長さ $ N $ の文字列
- 入力される数値は全て整数
- $ 1 $ つの入力に含まれるテストケースについて、$ N $ の総和は $ 2\times\ 10^5 $ 以下
 
### Sample Explanation 1

$ 1 $ 番目のテストケースについては、$ (i,j)=(1,3) $ として操作を $ 1 $ 回行うと、$ 1 $ 回の操作でコインを全て裏向きにできます。 $ 2 $ 番目のテストケースについては、$ (i,j)=(1,3) $ として操作を $ 1 $ 回行い、$ (i,j)=(4,6) $ として操作を $ 1 $ 回行うと、$ 2 $ 回の操作でコインを全て裏向きにできます。 $ 3 $ 番目のテストケースについては、コインを全て裏向きにできないことが証明できるので、`-1` を出力してください。 $ 4 $ 番目のテストケースについては、コインは既に全て裏向きなので、操作は必要ありません。

## 样例 #1

### 输入

```
5

3

101

6

101101

5

11111

6

000000

30

111011100110101100101000000111```

### 输出

```
1

2

-1

0

8```

# AI分析结果

### 题目重写
题目描述：

有 $N$ 枚硬币，编号从 $1$ 到 $N$，每枚硬币有正反两面。硬币的状态用一个长度为 $N$ 的字符串 $S$ 表示，$S$ 的第 $i$ 个字符为 `1` 表示第 $i$ 枚硬币正面朝上，为 `0` 表示反面朝上。

你可以进行以下操作任意次：

- 选择两个整数 $i$ 和 $j$，满足 $1 \leq i < j \leq N$ 且 $j - i \geq 2$，然后将第 $i$ 枚和第 $j$ 枚硬币翻转。

问是否可以通过若干次操作将所有硬币都翻转到反面朝上，如果可以，输出所需的最少操作次数；否则输出 `-1`。

共有 $T$ 组测试用例，每组测试用例给出一个字符串 $S$，要求输出对应的答案。

### 题解分析与结论

#### 综合分析
1. **核心思路**：所有题解都基于一个共同的核心思想——当硬币正面朝上的个数为奇数时，无法通过操作将所有硬币翻转到反面朝上，输出 `-1`。当正面朝上的个数为偶数时，进一步分类讨论：
   - 如果只有两个相邻的正面朝上的硬币，需要特判；
   - 其他情况下，操作次数为正面朝上的硬币个数除以 2。

2. **难点**：题目的难点在于处理两个相邻的正面朝上的硬币的情况。由于操作要求翻转的两个硬币不能相邻，因此当两个正面朝上的硬币相邻时，无法直接翻转，需要通过间接操作来实现。

3. **优化**：大部分题解通过记录正面朝上的硬币的位置，并分类讨论来优化判断过程，避免重复计算。

#### 评分与题解选择
1. **LegendaryGrandmaster (4星)**
   - **关键亮点**：清晰地将问题分为奇数、偶数情况，并对特殊情况（如 `110`、`0110`）进行了详细解释。
   - **代码实现**：通过记录正面朝上的硬币的位置，分类讨论并输出结果。
   - **核心代码**：
     ```cpp
     void slove() {
         int n;
         string st;
         cin >> n >> st;
         int ans = 0;
         for (int i = 0; i < st.size(); i++)
             if (st[i] == '1') ans++, a[ans] = i + 1;
         if (ans & 1 || st == "110" || st == "011") cout << "-1\n";
         else if (st == "0110") cout << "3\n";
         else if (ans == 2 && a[1] + 1 == a[2]) cout << "2\n";
         else cout << ans / 2 << '\n';
     }
     ```

2. **hellolin (4星)**
   - **关键亮点**：详细解释了特殊情况（如 `0110`）的处理方法，并提供了具体的翻转步骤。
   - **代码实现**：通过遍历字符串，统计正面朝上的硬币个数，并判断是否需要特判。
   - **核心代码**：
     ```cpp
     void solve() {
         cin >> n >> s;
         ans = 0;
         f = 0;
         for (int i = 0; i < s.length() - 1; i++) {
             ans += (s[i] == '1');
             if (i && (s[i] == '1' && s[i - 1] == '1')) f = 1;
         }
         if ((ans == 2) && f) {
             if (s == "11" || s == "011" || s == "110") cout << (-1) << endl;
             else if (s == "0110") cout << 3 << endl;
             else cout << 2 << endl;
         } else if (ans % 2) cout << (-1) << endl;
         else cout << ans / 2 << endl;
     }
     ```

3. **Jasonshan10 (4星)**
   - **关键亮点**：简洁明了地处理了所有情况，并提供了具体的翻转步骤。
   - **代码实现**：通过记录正面朝上的硬币的位置，分类讨论并输出结果。
   - **核心代码**：
     ```cpp
     int main() {
         int T;
         scanf("%d", &T);
         while (T--) {
             int n, ans = 0;
             scanf("%d", &n);
             cin >> s;
             for (int i = 0; i < s.size(); ++i) {
                 if (s[i] == '1') a[++ans] = i + 1;
             }
             if (ans & 1 || s == "011" || s == "110") printf("-1\n");
             else if (s == "0110") printf("3\n");
             else if (ans == 2 && a[1] + 1 == a[2]) printf("2\n");
             else printf("%d\n", ans / 2);
         }
     }
     ```

### 最优关键思路与技巧
1. **奇偶性判断**：首先判断正面朝上的硬币个数是否为偶数，奇数直接输出 `-1`。
2. **特殊情况处理**：对于两个相邻的正面朝上的硬币，需要特判处理，如 `0110` 需要 3 次操作。
3. **一般情况**：其他情况下，操作次数为正面朝上的硬币个数除以 2。

### 拓展与举一反三
1. **类似题目**：
   - [P1144 硬币翻转](https://www.luogu.com.cn/problem/P1144)
   - [P1441 硬币问题](https://www.luogu.com.cn/problem/P1441)
   - [P1451 硬币游戏](https://www.luogu.com.cn/problem/P1451)

2. **调试与顿悟**：在处理两个相邻的正面朝上的硬币时，通过间接操作（如先翻转不相邻的硬币）来实现目标，这一思路在类似问题中也有广泛应用。

---
处理用时：54.83秒
# 题目信息

# [ARC177B] Puzzle of Lamps

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc177/tasks/arc177_b

AtCoder さんは、左から右へ一列に並べられた $ N $ 個の豆電球と、$ 2 $ 種類のスイッチ A, B で構成された装置を作りました。各豆電球は、`0` (OFF) と `1` (ON) の $ 2 $ 種類の状態をとります。各スイッチを押すと、以下のことが起こります。

- スイッチ A を押すと、`0` の状態の豆電球のうち一番左のものが `1` になる。
- スイッチ B を押すと、`1` の状態の豆電球のうち一番左のものが `0` になる。
 
なお、該当する豆電球が存在しない場合はスイッチを押せません。

最初、すべての豆電球は `0` の状態になっています。AtCoder さんは、左の豆電球から順に状態が $ S_1,\ S_2,\ \dots,\ S_N $ になっている状態にしたいです。そのためにスイッチをどの順番で何回押せばいいのかを答えてください。ここで、必ずしもスイッチを押す回数を最小化する必要はありませんが、操作を現実的な時間で終わらせるために、スイッチを押す回数は $ 10^6 $ 回以下にしてください。なお、この問題の制約下では、答えが存在することが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 30 $
- $ S_1,\ S_2,\ \dots,\ S_N $ は `0` または `1`
- $ S_1,\ S_2,\ \dots,\ S_N $ がすべて `0` であることはない
- $ N $ は整数
 
### Sample Explanation 1

この出力例で答えているのは、スイッチ A, A, A, B の順に押す操作方法です。以下の図のように、豆電球を目的の状態にすることができます。 !\[ \](https://img.atcoder.jp/arc177/76af43b23a9e1158288d5f3162174c42.png) 別の方法として、スイッチ A, A, B, A, A, B の順に押しても、豆電球を目的の状態にすることができます。これに対応する以下の出力をした場合でも正解になります。 ``` 6 AABAAB ```

## 样例 #1

### 输入

```
5

01100```

### 输出

```
4

AAAB```

# AI分析结果

### 题目内容中文重写
AtCoder 先生制作了一个由从左到右排成一列的 $N$ 个小电灯泡，以及 A、B 两种开关组成的装置。每个小电灯泡有 `0`（关闭）和 `1`（开启）两种状态。按下每个开关时，会发生以下情况：
- 按下开关 A 时，处于 `0` 状态的小电灯泡中最左边的那个会变为 `1`。
- 按下开关 B 时，处于 `1` 状态的小电灯泡中最左边的那个会变为 `0`。

请注意，如果不存在对应的小电灯泡，则无法按下开关。

最初，所有小电灯泡都处于 `0` 状态。AtCoder 先生希望使小电灯泡从左到右的状态依次变为 $S_1, S_2, \dots, S_N$。请回答为了达到这个目的，应该按照什么顺序按下开关以及按下多少次。这里，不一定要使按下开关的次数最少，但为了在现实时间内完成操作，请将按下开关的次数控制在 $10^6$ 次以下。在这个问题的约束条件下，可以证明答案是存在的。

### 制 约
- $1 \leq N \leq 30$
- $S_1, S_2, \dots, S_N$ 为 `0` 或 `1`
- $S_1, S_2, \dots, S_N$ 不会全部为 `0`
- $N$ 为整数

### 样例解释 1
这个输出示例给出的操作方法是按开关 A、A、A、B 的顺序进行。如下图所示，可以将小电灯泡调整到目标状态。
![ ](https://img.atcoder.jp/arc177/76af43b23a9e1158288d5f3162174c42.png)
另一种方法是按开关 A、A、B、A、A、B 的顺序按下，也可以将小电灯泡调整到目标状态。如果给出与此对应的以下输出，同样会被判定为正确。
```
6
AABAAB
```

### 样例 #1
#### 输入
```
5
01100
```
#### 输出
```
4
AAAB
```

### 综合分析与结论
这些题解的核心思路基本一致，都是从后往前遍历目标序列，通过模拟开关操作将初始的全 `0` 序列转换为目标序列。主要原因是从前往后遍历会导致前面已经修改好的部分被后续操作覆盖。

#### 思路对比
- **单字符处理**：大部分题解是遇到目标序列中的 `1` 时，先进行 $i + 1$ 次 A 操作将前 $i$ 位都变为 `1`，再进行 $i$ 次 B 操作将前 $i - 1$ 位变回 `0`，这样就只改变了第 $i$ 位为 `1`。
- **连续段处理**：部分题解将序列分为一个个 `1` 的连续段，对于每个连续段 $[l, r]$，先执行 $r$ 次 A 操作让 $1$ 到 $r$ 都是 `1`，再执行 $l - 1$ 次 B 操作去掉多余的 `1`。

#### 算法要点
- **倒序遍历**：为了避免后续操作影响前面已经修改好的部分，所有题解都采用了从后往前遍历目标序列的方法。
- **模拟操作**：根据当前位置的目标状态和当前状态，模拟按下开关 A 或 B 的操作，并记录操作步骤。

#### 解决难点
- **后效性问题**：从前往后遍历会导致前面已经修改好的部分被后续操作覆盖，通过倒序遍历解决了这个问题。
- **操作次数限制**：由于 $N$ 最大为 30，即使采用较暴力的模拟方法，操作次数也不会超过 $10^6$ 次。

### 题解评分
- **xQWQx**：4星。思路清晰，代码简洁易懂，详细解释了从后往前遍历的原因和操作方法。
- **xuchuhan**：3星。思路详细，通过具体例子说明了从后往前遍历的必要性，但代码稍显复杂。
- **__Toator__**：3星。思路直接，代码简洁，但解释相对较少。

### 最优关键思路或技巧
- **倒序遍历**：这是解决本题的关键，避免了后续操作对前面已经修改好的部分的影响。
- **模拟操作**：根据目标状态和当前状态，模拟按下开关 A 或 B 的操作，简单直接。

### 拓展思路
同类型题或类似算法套路：
- **状态转换问题**：涉及状态转换的问题，通常需要考虑操作的顺序和后效性，倒序处理是一种常见的解决方法。
- **构造问题**：对于构造类问题，需要根据题目要求和约束条件，找到一种可行的构造方法。

### 推荐题目
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：涉及状态的填充和转换，需要考虑操作的顺序和边界条件。
- [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)：需要通过合理的操作和路径选择，达到目标状态。
- [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)：需要根据题目规则构造出符合要求的二叉树，涉及状态的转移和计算。

### 个人心得摘录与总结
- **x1489631649**：比赛时没有看到最下方的样例解释，先从前往后枚举，浪费了 3 次提交次数。总结是要仔细看题，特别是样例解释。

### 重点代码
以下是 xQWQx 的核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char t='0';
string s;
queue<char> ans;
int main(){
    cin>>n;
    cin>>s;
    for(int i=n-1;i>=0;i--){
        if(s[i]!=t){
            for(int j=1;j<=i+1;j++){
                if(t=='1') ans.push('B');
                else ans.push('A');
            }
            if(t=='1') t='0';
            else t='1';
        }
    }
    cout<<ans.size()<<endl;
    while(ans.size()){
        cout<<ans.front();
        ans.pop();
    }
    return 0;
}
```
核心实现思想：从后往前遍历目标序列，遇到与当前状态不同的字符时，根据当前状态进行相应的操作（A 或 B），并更新当前状态。最后输出操作次数和操作步骤。

---
处理用时：39.66秒
# 题目信息

# [ABC012C] 九九足し算

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc012/tasks/abc012_3

高橋君は、先日、九九の表を全て暗記することに成功しました。

九九で物足りなくなった高橋君は、 $ 1 $ × $ 1 $ から $ 9 $ × $ 9 $ までの値を、全て足してみることにしました。

高橋君は、九九のうちの一つの答えを忘れてしまったので、その計算を後回しにして、残りの和を求めたところ、$ N $ になりました。

しかし、高橋君は、後回しにした問題がどれだか解らなくなってしまいました。

高橋君が後回しにしてしまった問題として、あり得るものを辞書順で全て出力しなさい。

## 说明/提示

### Sample Explanation 1

高橋君の求めた値は、本来の値より $ 12 $ 少ないものです。 よって、答えが $ 12 $ となる、 $ 2 $ × $ 6 $、 $ 3 $ × $ 4 $、 $ 4 $ × $ 3 $、 $ 6 $ × $ 2 $ の $ 4 $ つが答えとなります。

## 样例 #1

### 输入

```
2013```

### 输出

```
2 x 6

3 x 4

4 x 3

6 x 2```

## 样例 #2

### 输入

```
2024```

### 输出

```
1 x 1```

# AI分析结果

### 题目中文重写
# [ABC012C] 九九加法

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc012/tasks/abc012_3

高桥君前些日子成功记住了九九乘法表的所有内容。

觉得九九乘法不过瘾的高桥君，决定把从 $1$ × $1$ 到 $9$ × $9$ 的所有结果相加。

高桥君忘记了九九乘法表中的一个答案，于是他把这一项的计算先放一放，计算其余项的和，结果为 $N$。

然而，高桥君忘记了他搁置的是哪一项。

请按字典序输出所有可能被高桥君搁置的题目。

## 说明/提示

### 示例解释 1

高桥君计算的值比原本的总和少了 $12$。 因此，答案为 $12$ 的 $2$ × $6$、 $3$ × $4$、 $4$ × $3$、 $6$ × $2$ 这 $4$ 项就是答案。

## 样例 #1

### 输入
```
2013
```

### 输出
```
2 x 6
3 x 4
4 x 3
6 x 2
```

## 样例 #2

### 输入
```
2024
```

### 输出
```
1 x 1
```

### 综合分析与结论
这些题解主要围绕找出两个小于 10 的正整数 $a$ 和 $b$，使得 $a\times b = 2025 - N$ 展开。思路主要分为暴力枚举和优化枚举两种。
- **暴力枚举**：使用双重循环遍历 $1$ 到 $9$ 的所有数对 $(a, b)$，判断 $a\times b$ 是否等于 $2025 - N$，时间复杂度为 $O(9\times9)$。
- **优化枚举**：通过单重循环，找到 $2025 - N$ 的小于 10 的因子 $i$，并判断对应的另一个因子 $j = \frac{2025 - N}{i}$ 是否也小于 10，时间复杂度为 $O(9)$。部分题解还利用了乘积的对称性，只循环 $\sqrt{2025 - N}$ 次，进一步减少计算量。

### 所选题解
- **Reywmp（5星）**
    - **关键亮点**：思路清晰，不仅给出了暴力枚举的代码，还提及了 $O(n)$ 的优化思路，并引导读者参考其他代码。
    - **个人心得**：作者表示自己没有一遍通过，体现了即使是简单题目也可能出现失误。
    - **核心代码**：
```cpp
scanf("%d",&n);
n-=2025;
n=abs(n);
for(int i=1;i<=9;i++)
{
    for(int j=9;j>=1;j--)
    {
        if(i*j==n){printf("%d x %d",i,j);printf("\n");}
    }
}
```
- **_Qer（4星）**
    - **关键亮点**：代码简洁，使用单重循环进行优化枚举，时间复杂度为 $O(9)$。
    - **核心代码**：
```cpp
cin>>a;
a=2025-a;
for(int i=1;i<=a&&i<10;++i){
    int j=a/i;
    if(i*j==a&&j<10){
        cout<<i<<" x "<<j<<endl;
    }
}
```
- **liangqiaoshen（4星）**
    - **关键亮点**：利用乘积的对称性，只循环 $\sqrt{2025 - N}$ 次，减少了不必要的计算。
    - **核心代码**：
```cpp
cin>>a;
a=2025-a;
for(int i=1;i<=sqrt(a);i++)
{
    int j=a/i;
    if(i*j==a&&j<10)
    {
        cout<<i<<" x "<<j<<endl;
        b[l].x=j,b[l].y=i;
        l++;
    }
}
if(l%2==1)l--;
for(;l>0;l--)
{
    if(b[l].x!=b[l].y&&b[l].y!=0&&b[l].x!=0)
        cout<<b[l].x<<" x "<<b[l].y<<endl;
}
```

### 最优关键思路或技巧
- 对于此类寻找两个数乘积等于某值的问题，可以使用单重循环枚举其中一个因子，通过除法计算另一个因子，将时间复杂度从 $O(n^2)$ 优化到 $O(n)$。
- 利用乘积的对称性，只循环到 $\sqrt{2025 - N}$，可以进一步减少计算量。

### 拓展思路
同类型题目可能会改变数字范围、增加条件限制等。例如，可能会要求找出三个数的乘积等于某值，或者要求找出满足乘积条件且其他条件（如和最小）的组合。解题思路仍然可以从枚举和优化枚举入手。

### 推荐题目
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：考察组合枚举和数论知识。
- [P1217 [USACO1.5] 回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要对质数和回文数进行枚举和判断。
- [P1463 [POI2002][HAOI2007]反素数](https://www.luogu.com.cn/problem/P1463)：涉及因数个数的计算和枚举。

### 个人心得摘录与总结
- **Reywmp**：表示自己没有一遍通过简单题目，提醒大家即使题目看似简单，也不能掉以轻心，要认真对待每一个细节。
- **代码小白白**：零分代码是因为输出格式问题，后来加了空格才通过。这提示我们在做题时要注意输出格式的要求，避免因小失大。
- **北雪2009**：最初的暴力枚举代码超时，经过多次修改才通过。这说明在遇到超时问题时，要思考如何优化算法，减少不必要的计算。

---
处理用时：35.70秒
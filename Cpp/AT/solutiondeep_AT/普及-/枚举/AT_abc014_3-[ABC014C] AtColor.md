# 题目信息

# [ABC014C] AtColor

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc014/tasks/abc014_3

 AtColor社は，$ 0 $ から $ 1,000,000 $ まで $ 1,000,001 $ 通りの濃さがある灰色の絵の具を販売することにしました．$ 0 $ が最も黒く，$ 1,000,000 $ が最も白い絵の具です．

 しかし，途方も無い数の濃さのバリエーションがある一方，消費者には細かい違いが分からないということが判明しました．これを知ったAtColor社は，売れない濃さの絵の具を生産するのはやめて，最も人気のある濃さの色の絵の具1つだけを販売することにしました．

 AtColor社は上記を達成するために，最も人気な絵の具がどのくらい売れるかをアンケート調査で調べることにしました． AtColor社がどの範囲の濃さの絵の具なら購入したいかというアンケートを消費者に対して行ったところ， 「$ a\ ≦\ x\ ≦\ b $ を満たす濃さ $ x $ の絵の具ならば購入する」という形式の情報が $ n $ 件得られました．

 あなたの仕事は，これらの情報から，最も多くの消費者に購入される濃さの絵の具について，その絵の具を購入する消費者の数を出力するプログラムを作ることです．

## 说明/提示

### 部分点

この問題には2つのデータセットがあり，データセット毎に部分点が設定されている．

- $ 1≦n≦2,000 $ を満たすデータセット 1 に正解した場合は $ 30 $ 点が与えられる．
- 追加制約のないデータセット 2 に正解した場合は，上記のデータセットとは別に $ 70 $ 点が与えられる．

### Sample Explanation 1

\- 濃さ $ 0,1,4,5,6 $ の絵の具は，1人の消費者によって購入してもらえます． - 濃さ $ 2 $ の絵の具は，3人の消費者によって購入してもらえます． - 濃さ $ 3 $ の絵の具は，2人の消費者によって購入してもらえます． - 他の濃さの絵の具は誰にも購入してもらえません． よって，$ 3 $ を出力します．

## 样例 #1

### 输入

```
4

0 2

2 3

2 4

5 6```

### 输出

```
3```

## 样例 #2

### 输入

```
4

1000000 1000000

1000000 1000000

0 1000000

1 1000000```

### 输出

```
4```

# AI分析结果

### 题目翻译
AtColor 公司决定销售 1000001 种不同灰度的灰色颜料，灰度范围从 0 到 1000000。其中，0 代表最黑的颜料，1000000 代表最白的颜料。

然而，事实证明，尽管有大量不同灰度的颜料可供选择，但消费者却难以区分细微的差异。得知这一情况后，AtColor 公司决定停止生产滞销的灰度颜料，转而只销售最受欢迎的一种灰度颜料。

为了实现这一目标，AtColor 公司决定通过问卷调查来了解最受欢迎的颜料预计能销售多少。公司对消费者进行了一项调查，询问他们愿意购买哪些灰度范围的颜料。结果，公司获得了 n 条信息，每条信息的形式为“如果颜料的灰度 x 满足 $a \leq x \leq b$，那么我愿意购买”。

你的任务是根据这些信息，编写一个程序，输出最受消费者欢迎的灰度颜料的预计购买人数。

### 综合分析与结论
- **思路对比**：大部分题解都采用差分算法，通过维护差分数组来实现区间修改，最后求前缀和得到每个点的覆盖次数，找出最大值。部分题解一开始尝试暴力枚举，但因时间复杂度高（$O(N^2)$）会超时，而差分算法能将时间复杂度优化到 $O(N)$。
- **算法要点**：差分算法的核心是，对于原数组 $a$，其差分数组 $b$ 满足 $b_i = a_i - a_{i - 1}$，若要将区间 $[l, r]$ 内的元素都加上 $k$，只需将差分数组 $b_l$ 加上 $k$，$b_{r + 1}$ 减去 $k$，最后对差分数组求前缀和就能得到修改后的原数组。
- **解决难点**：主要难点在于如何高效处理区间修改，暴力枚举时间复杂度高，而差分算法通过巧妙的区间端点操作，将单次区间修改的时间复杂度从 $O(n)$ 降低到 $O(1)$。

### 评分较高的题解
1. **作者：Grisses (赞：7)，5星**
    - **关键亮点**：思路清晰，代码简洁，直接给出了差分算法的核心实现，对差分的解释简洁明了。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,ans,x[1000005];//x是差分数组
signed main()
{
    scanf("%d",&n);
    while(n--){
        scanf("%d%d",&a,&b);
        x[a]++;
        x[b+1]--;//修改
    }
    ans=x[0];
    for(int i=1;i<=1000000;i++)x[i]+=x[i-1],ans=max(ans,x[i]);//求值，去max
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：先根据输入的区间修改差分数组，再对差分数组求前缀和得到每个点的覆盖次数，同时找出最大值。

2. **作者：tZEROちゃん (赞：4)，4星**
    - **关键亮点**：对差分的概念解释详细，通过可爱的表述让读者更容易理解，还给出了差分的通用模板。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; i++) {
  scanf("%d", &d[i]); // 原数组
}

for(int i = 1; i <= m; i++) {
  int l, r, k; // 将 d[l] ~ d[r] 元素值加上 k
  cin >> l >> r >> k; 
// 差分数组 b
  b[l] += k;
  b[r + 1] -= k;
}

// 前缀和数组 a
for (int i = 1; i <= n; i++) {
  a[i] = a[i - 1] + b[i];
}
// 累加结果
for (int i = 1; i <= n; i++) {
  s[i] = d[i] + a[i];
}
```
核心实现思想：先读取原数组，再根据输入的区间和增量修改差分数组，接着求差分数组的前缀和得到修改后的数组，最后与原数组相加得到最终结果。

3. **作者：zjyqwq (赞：7)，4星**
    - **关键亮点**：不仅给出了错误的暴力解法，还详细说明了如何从暴力解法优化到差分算法，对差分的运用解释清晰。
    - **核心代码**：
```Pascal
var
n,i,x,y,j,ans,m:longint;
a,s:Array[-10..10000000]of longint;//定义部分，不多讲
 begin
  readln(n);m:=0;
  for i:=1 to n do 
   begin
    readln(x,y);//输入
    a[x]:=a[x]+1;a[y+1]:=a[y+1]-1;//进行差分，要注意这里是y+1。
    if y+1>m then m:=y+1;//一个小优化，记录最大的区间编号。
   end;
  for i:=0 to m do
  begin
   a[i]:=a[i-1]+a[i];//还原数组
   if a[i]>ans then ans:=a[i];//比较大小
  end;
  writeln(ans);//输出
 end.
```
核心实现思想：根据输入的区间修改差分数组，记录最大区间编号，对差分数组求前缀和得到每个点的覆盖次数，同时找出最大值。

### 最优关键思路或技巧
- **差分算法**：利用差分数组进行区间修改，将单次区间修改的时间复杂度从 $O(n)$ 降低到 $O(1)$，最后通过求前缀和得到修改后的原数组。
- **记录最大区间编号**：在处理区间时，记录最大的区间右端点，避免不必要的遍历，提高效率。

### 可拓展之处
同类型题如区间染色问题、区间增减问题等都可以使用差分算法解决。类似算法套路还有线段树、树状数组等，它们也可以高效处理区间修改和查询问题。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)

### 个人心得摘录与总结
- **szkzyc**：一开始使用暴力枚举超时，意识到需要寻找 $O(N)$ 的解法，学习差分算法解决问题，同时提到因为输出未换行导致 WA 两次，提醒要注意输出格式。
- **Cambridge**：尝试纯暴力算法超时后，采用前缀和（差分）算法解决问题，说明暴力算法在数据规模大时不可行，要考虑优化算法。
- **jxbe6666**：指出差分模板题要注意差分范围和输出换行符的坑点，提醒做题时要仔细。 

---
处理用时：45.15秒
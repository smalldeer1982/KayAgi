# 题目信息

# [ABC060B] Choose Integers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc060/tasks/abc060_b

あなたは、正の整数をいくつか選び、それらの総和を求めます。

選ぶ数の上限や、選ぶ整数の個数に制限はありません。 どんなに大きな整数を選んでもよいですし、整数を $ 5000 $ 兆個選んでもよいです。 ただし、選ぶ数はすべて $ A $ の倍数でなくてはいけません。 また、少なくとも $ 1 $ つは整数を選ばなくてはいけません。

そして総和を $ B $ で割ったあまりが $ C $ となるようにしたいです。 こうなるように整数を選ぶことが出来るか判定してください。

出来るならば `YES`、そうでないならば `NO` を出力してください。

## 说明/提示

### 制約

- $ 1\ ≦\ A\ ≦\ 100 $
- $ 1\ ≦\ B\ ≦\ 100 $
- $ 0\ ≦\ C $

### Sample Explanation 1

たとえば $ 7,\ 14 $ を選ぶと総和は $ 21 $ となり、これを $ 5 $ で割ったあまりは $ 1 $ となります。

### Sample Explanation 2

偶数をいくつ足したとしても、けっして奇数になることはありません。

### Sample Explanation 3

$ 1 $ の倍数、つまりすべての整数が選べるので、$ 97 $ を選べば良いです。

## 样例 #1

### 输入

```
7 5 1```

### 输出

```
YES```

## 样例 #2

### 输入

```
2 2 1```

### 输出

```
NO```

## 样例 #3

### 输入

```
1 100 97```

### 输出

```
YES```

## 样例 #4

### 输入

```
40 98 58```

### 输出

```
YES```

## 样例 #5

### 输入

```
77 42 36```

### 输出

```
NO```

# AI分析结果

### 题目翻译
你可以选择一些正整数，并求出它们的总和。

选择的数字上限以及选择的整数个数没有限制。你可以选择任意大的整数，也可以选择 5000 兆个整数。不过，所选的数字都必须是 $A$ 的倍数，并且至少要选择一个整数。

然后，你希望这些数字的总和除以 $B$ 的余数为 $C$。请判断是否能够这样选择整数。

如果可以，输出 `YES`；否则，输出 `NO`。

### 综合分析与结论
这些题解主要围绕判断是否存在 $A$ 的倍数，使得其总和除以 $B$ 的余数为 $C$ 展开，主要思路可分为暴力枚举和利用最大公约数两种。

#### 暴力枚举思路
通过枚举 $A$ 的倍数，计算其除以 $B$ 的余数，判断是否等于 $C$。不同题解的区别在于枚举的范围，部分题解通过数学证明得出只需枚举到 $B$ 即可，而部分题解则选择枚举到 100 或 1000。

#### 最大公约数思路
利用裴蜀定理，将问题转化为判断 $C$ 是否能被 $\gcd(A, B)$ 整除。

### 所选题解
- **作者：MZY666 (赞：15)  4星**
    - **关键亮点**：思路清晰，对枚举范围到 $B$ 进行了详细的数学证明，代码注释完善。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a,b,c;
    scanf("%d%d%d",&a,&b,&c);
    for(int i=1;i<=b;i++){
        if((a*i)%b==c){
            printf("YES\n");
            return 0;
        }
    }
    printf("NO\n");
    return 0;
}
```
- **作者：詹詹tv__詹詹 (赞：3)  4星**
    - **关键亮点**：采用最大公约数的方法解题，给出了详细的数学证明，思路独特。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int gcd(int x , int y){
    while(x % y){
        int r = x % y;
        x = y;
        y = r;
    }
    return y;
}
int main(){
    int a , b , c;
    cin >> a >> b >> c;
    if(c % gcd(a , b) == 0){
        cout << "YES";
    }else{
        cout << "NO";
    }
    return 0;
}
```
- **作者：Juvenile (赞：0)  4星**
    - **关键亮点**：同样利用最大公约数解题，给出了数学证明，代码简洁。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,c;
int gcd(int a,int b)
{
    while(b^=a^=b^=a%=b);
    return a;
}
int main()
{
    scanf("%d%d%d",&a,&b,&c);
    int l=gcd(a,b);
    if(c%l!=0) printf("NO");
    else printf("YES");
}
```

### 最优关键思路或技巧
- **枚举范围优化**：通过数学推导得出只需枚举 $A$ 的 $1$ 到 $B$ 倍，可减少不必要的计算。
- **最大公约数应用**：利用裴蜀定理，将问题转化为判断 $C$ 是否能被 $\gcd(A, B)$ 整除，避免了枚举，时间复杂度更低。

### 拓展思路
同类型题目可能会涉及更多的数学知识，如线性同余方程、扩展欧几里得算法等。对于此类问题，可先尝试将问题转化为数学方程，再利用相关定理和算法求解。

### 推荐题目
- [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)
- [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)
- [P2421 荒岛野人](https://www.luogu.com.cn/problem/P2421)

### 个人心得摘录与总结
- **詹詹tv__詹詹**：认为大家都用枚举方法解题，而本题是一道很好的最大公约数的题目，体现了从不同角度思考问题的重要性。
- **艾恩葛朗特**：开始没思路，看了题解后茅塞顿开，说明参考他人思路有助于拓宽自己的思维。

---
处理用时：27.22秒
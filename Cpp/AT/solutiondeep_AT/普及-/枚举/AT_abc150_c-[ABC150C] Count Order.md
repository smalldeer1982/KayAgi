# 题目信息

# [ABC150C] Count Order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc150/tasks/abc150_c

大きさ $ N $ の順列 ($ (1,~2,~...,~N) $ を並び替えてできる数列) $ P,~Q $ があります。

大きさ $ N $ の順列は $ N! $ 通り考えられます。このうち、$ P $ が辞書順で $ a $ 番目に小さく、$ Q $ が辞書順で $ b $ 番目に小さいとして、$ |a\ -\ b| $ を求めてください。

## 说明/提示

### 注記

$ 2 $ つの数列 $ X,~Y $ について、ある整数 $ k $ が存在して $ X_i\ =\ Y_i~(1\ \leq\ i\ <\ k) $ かつ $ X_k\ <\ Y_k $ が成り立つとき、$ X $ は $ Y $ より辞書順で小さいと定義されます。

### 制約

- $ 2\ \leq\ N\ \leq\ 8 $
- $ P,~Q $ は大きさ $ N $ の順列である。
- 入力は全て整数である。

### Sample Explanation 1

大きさ $ 3 $ の順列は、$ (1,~2,~3) $、$ (1,~3,~2) $、$ (2,~1,~3) $、$ (2,~3,~1) $、$ (3,~1,~2) $、$ (3,~2,~1) $ の $ 6 $ 個あります。このうち $ (1,~3,~2) $ は辞書順で $ 2 $ 番目、$ (3,~1,~2) $ は辞書順で $ 5 $ 番目なので、答えは $ |2\ -\ 5|\ =\ 3 $ です。

## 样例 #1

### 输入

```
3

1 3 2

3 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
8

7 3 5 4 2 1 6 8

3 8 2 5 4 6 7 1```

### 输出

```
17517```

## 样例 #3

### 输入

```
3

1 2 3

1 2 3```

### 输出

```
0```

# AI分析结果

### 题目翻译
## [ABC150C] 排列顺序计数

### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc150/tasks/abc150_c

有两个长度为 $N$ 的排列（将 $(1, 2,..., N)$ 重新排列得到的数列）$P$ 和 $Q$。

长度为 $N$ 的排列共有 $N!$ 种。其中，若 $P$ 在字典序中是第 $a$ 小的，$Q$ 在字典序中是第 $b$ 小的，请计算 $|a - b|$。

### 说明/提示
#### 注记
对于两个数列 $X$ 和 $Y$，若存在整数 $k$ 使得 $X_i = Y_i~(1 \leq i < k)$ 且 $X_k < Y_k$，则定义 $X$ 在字典序上小于 $Y$。

#### 限制条件
- $2 \leq N \leq 8$
- $P$ 和 $Q$ 是长度为 $N$ 的排列。
- 输入均为整数。

#### 样例解释 1
长度为 $3$ 的排列有 $(1, 2, 3)$、$(1, 3, 2)$、$(2, 1, 3)$、$(2, 3, 1)$、$(3, 1, 2)$、$(3, 2, 1)$ 这 $6$ 种。其中 $(1, 3, 2)$ 在字典序中是第 $2$ 小的，$(3, 1, 2)$ 在字典序中是第 $5$ 小的，所以答案是 $|2 - 5| = 3$。

### 样例 #1
#### 输入
```
3
1 3 2
3 1 2
```
#### 输出
```
3
```

### 样例 #2
#### 输入
```
8
7 3 5 4 2 1 6 8
3 8 2 5 4 6 7 1
```
#### 输出
```
17517
```

### 样例 #3
#### 输入
```
3
1 2 3
1 2 3
```
#### 输出
```
0
```

### 综合分析与结论
各题解主要围绕求两个排列在字典序中的排名差展开，思路各有不同：
- **暴力枚举思路**：利用 `next_permutation` 函数或 DFS 枚举全排列，逐一比较找到 $P$ 和 $Q$ 的排名，如 DengDuck、_huangyicheng_、codemap 的题解。该思路简单直接，但时间复杂度为 $O(n\times n!)$。
- **康托展开思路**：通过计算排列的康托展开值得到排名，如 Karry5307 的题解。该思路复杂度为 $O(n^2)$，可进一步用树状数组优化到 $O(n\log n)$。
- **树状数组优化思路**：定义数组记录排名，用树状数组优化排名计算过程，如 peppaking8 的题解，复杂度为 $O(n\log n)$。

### 所选题解
- **peppaking8（5星）**
    - **关键亮点**：提供了三种不同复杂度的思路，详细阐述了优化过程，代码实现清晰，使用树状数组将复杂度优化到 $O(n\log n)$。
    - **核心代码**：
```cpp
//树状数组基本三件套
int lowbit(int x){
    return x&(-x);
}
void add(int pos){
    for(int i=pos;i<=n;i+=lowbit(i))
        t[i]++;
}
int query(int pos){
    int ret=0;
    for(int i=pos;i>=1;i-=lowbit(i))
        ret+=t[i];
    return ret;
}
// 主函数部分核心代码
for(int i=1;i<=n;i++){
    scanf("%d",&a[i]);
    add(a[i]);
    int prev=query(a[i]-1);
    a[i]-=prev;
}
memset(t,0,sizeof(t));
for(int i=1;i<=n;i++){
    scanf("%d",&b[i]);
    add(b[i]);
    int prev=query(b[i]-1);
    b[i]-=prev;
}
cal[0]=1;
for(int i=1;i<=n;i++) cal[i]=cal[i-1]*i;
for(int i=1;i<=n;i++){
    ans+=(a[i]-b[i])*cal[n-i];
}
printf("%d\n",abs(ans));
```
核心思想：用树状数组维护每个数在其后面数中的排名，预处理阶乘，通过公式更新答案。
- **Karry5307（4星）**
    - **关键亮点**：详细解释了康托展开的原理和证明过程，给出了 $O(n^2)$ 和 $O(n\log n)$ 两种复杂度的思路。
    - **核心代码（$O(n\log n)$ 部分）**：可参考 peppaking8 题解中树状数组优化部分，原理相同。
    - **核心思想**：根据康托展开公式计算排列排名，用树状数组优化统计比当前数小的数的个数。

### 最优关键思路或技巧
- **树状数组优化**：在计算每个数在其后面数中的排名时，使用树状数组将时间复杂度从 $O(n^2)$ 优化到 $O(n\log n)$。
- **康托展开**：通过公式计算排列在字典序中的排名，避免了暴力枚举全排列。

### 拓展思路
同类型题可涉及更大范围的排列排名计算，或要求根据排名还原排列，类似算法套路可用于处理组合计数、字典序相关问题。

### 洛谷题目推荐
1. [P1088 火星人](https://www.luogu.com.cn/problem/P1088)：考察全排列和 `next_permutation` 的使用。
2. [P3182 [HAOI2016]放棋子](https://www.luogu.com.cn/problem/P3182)：涉及排列组合和康托展开的应用。
3. [P5367 【模板】康托展开](https://www.luogu.com.cn/problem/P5367)：直接考察康托展开的实现。

### 个人心得
本题解中未包含个人心得内容。 

---
处理用时：34.75秒
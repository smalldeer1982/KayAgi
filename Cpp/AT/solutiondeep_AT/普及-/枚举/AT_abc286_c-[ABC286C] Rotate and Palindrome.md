# 题目信息

# [ABC286C] Rotate and Palindrome

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc286/tasks/abc286_c

長さ $ N $ の文字列 $ S $ が与えられます。$ S_i\ (1\leq\ i\ \leq\ N) $ を $ S $ の左から $ i $ 番目の文字とします。

あなたは以下の $ 2 $ 種類の操作を好きな順番で $ 0 $ 回以上好きな回数行うことができます。

- $ A $ 円払う。 $ S $ の左端の文字を右端に移動する。すなわち、$ S_1S_2\ldots\ S_N $ を $ S_2\ldots\ S_NS_1 $ に変える。
- $ B $ 円払う。 $ 1 $ 以上 $ N $ 以下の整数 $ i $ を選び、 $ S_i $ を好きな英小文字で置き換える。
 
$ S $ を回文にするためには最低で何円必要ですか？

 回文とは ある文字列 $ T $ について、 $ T $ の長さを $ |T| $ として、全ての整数 $ i $ ($ 1\ \le\ i\ \le\ |T| $) について、 $ T $ の前から $ i $ 文字目と後ろから $ i $ 文字目が同じであるとき、またそのときに限って、 $ T $ は回文です。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 5000 $
- $ 1\leq\ A,B\leq\ 10^9 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
- $ S $ 以外の入力は全て整数
 
### Sample Explanation 1

最初に $ 2 $ 番目の操作を $ 1 $ 回行います。$ 2 $ 円払い、$ i=5 $ として $ S_5 $ を `e` で置き換えます。 $ S $ は `rrefe` となります。 次に $ 1 $ 番目の操作を $ 1 $ 回行います。$ 1 $ 円払い、$ S $ は `refer` となります。これは回文です。 よって $ 3 $ 円払うことで $ S $ を回文にすることができました。 $ 2 $ 円以下払うことで $ S $ を回文にすることは不可能なので、これが答えです。

### Sample Explanation 2

答えは $ 32 $ bit 整数に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
5 1 2

rrefa```

### 输出

```
3```

## 样例 #2

### 输入

```
8 1000000000 1000000000

bcdfcgaa```

### 输出

```
4000000000```

# AI分析结果

### 题目翻译
#### [ABC286C] Rotate and Palindrome
#### 题目描述
给定一个长度为 $N$ 的字符串 $S$。设 $S_i\ (1\leq i\leq N)$ 为 $S$ 从左数第 $i$ 个字符。

你可以按任意顺序进行以下两种操作任意次数（包括 0 次）：
- 支付 $A$ 日元。将 $S$ 最左边的字符移到最右边。即，将 $S_1S_2\ldots S_N$ 变为 $S_2\ldots S_NS_1$。
- 支付 $B$ 日元。选择一个 $1$ 到 $N$ 之间的整数 $i$，将 $S_i$ 替换为任意小写英文字母。

要使 $S$ 成为回文串，最少需要支付多少日元？

回文串是指对于某个字符串 $T$，设其长度为 $|T|$，对于所有整数 $i$（$1\leq i\leq |T|$），$T$ 的第 $i$ 个字符和倒数第 $i$ 个字符都相同的字符串。

#### 说明/提示
##### 限制条件
- $1\leq N\leq 5000$
- $1\leq A,B\leq 10^9$
- $S$ 是由小写英文字母组成的长度为 $N$ 的字符串
- 除 $S$ 外，所有输入均为整数

##### 样例解释 1
首先进行一次第二种操作。支付 2 日元，选择 $i = 5$，将 $S_5$ 替换为 `e`。此时 $S$ 变为 `rrefe`。接着进行一次第一种操作。支付 1 日元，$S$ 变为 `refer`，这是一个回文串。因此，支付 3 日元可以使 $S$ 成为回文串。由于支付 2 日元或更少无法使 $S$ 成为回文串，所以这就是答案。

##### 样例解释 2
请注意，答案可能无法用 32 位整数表示。

#### 样例 #1
##### 输入
```
5 1 2
rrefa
```
##### 输出
```
3
```

#### 样例 #2
##### 输入
```
8 1000000000 1000000000
bcdfcgaa
```
##### 输出
```
4000000000
```

### 综合分析与结论
这些题解的核心思路都是通过枚举操作 1 的次数，再计算每次操作后将字符串变为回文串所需操作 2 的次数，从而得到总花费，最后取最小值。

#### 思路对比
- 大部分题解采用将字符串复制一份接在后面的方法，通过截取子串模拟操作 1，如 _xEr_、Coffee_zzz、makerlife、qinmingze 的题解。
- 部分题解通过循环移动字符串元素来模拟操作 1，如 tZEROちゃん、lfxxx 的题解。

#### 算法要点
- 枚举操作 1 的次数，范围是 $0$ 到 $n - 1$。
- 对于每次操作 1 的结果，检查字符串是否为回文，统计不同字符的对数，每对不同字符需要进行一次操作 2。
- 计算总花费，即操作 1 的花费（操作次数乘以 $A$）加上操作 2 的花费（不同字符对数乘以 $B$）。
- 取所有总花费中的最小值作为最终答案。

#### 解决难点
- **操作 1 的模拟**：通过复制字符串或循环移动元素来实现。
- **回文判断**：使用双指针法，从字符串两端向中间遍历，比较对应位置的字符。
- **数据类型**：由于答案可能很大，需要使用 `long long` 类型。

### 高评分题解
#### 作者：_xEr_ (5星)
- **关键亮点**：思路清晰，通过图示解释了复制字符串模拟操作 1 的方法，代码简洁易懂。
```cpp
#include<iostream>
using namespace std;
long long n,a,b;
unsigned long long ans=1e35,now;
string s;
int main(){
    cin>>n>>a>>b>>s;
    s=s+s;//复制并连接
    for(int i=0;i<n;i++){
        int l=i,r=i+n-1;//分别从左右扫来检查对称
        now=i*a;
        for(;l<r;l++,r--)
            now+=b*(s[l]!=s[r]);//记录代价
        ans=ans>now?now:ans;//更新最小值
    }
    cout<<ans;
}
```
核心实现思想：先将字符串复制一份接在后面，然后枚举操作 1 的次数 $i$，对于每次操作，使用双指针从左右两端检查子串是否对称，统计不同字符的对数，计算总花费并更新最小值。

#### 作者：qinmingze (4星)
- **关键亮点**：详细解释了代码思路，包括如何将字符串构成环来方便操作，以及如何更新答案。
```cpp
#include<bits/stdc++.h>

using namespace std;

int main(){
    long long n, a, b;
    string s;
    cin >> n >> a >> b >> s;
    s += s;//构成一个环，方便操作
    long long ans = 1e18;//保存答案
    for(int i = 0; i < n; i++){//n次A操作
        long long sum = a * i;//A操作花费的钱
        for(int j = 0; j < n / 2; j++){//B号操作
            int l = i + j;//左点坐标
            int r = i + n - 1 - j;//右点坐标（左点的对称点）
            if(s[l]!= s[r])sum += b;//如果两个字符不一样，增加钱数
        }
        ans = min(ans, sum);//更新答案
    }
    cout << ans << endl;
    return 0;
}
```
核心实现思想：将字符串复制一份接在后面构成环，枚举操作 1 的次数 $i$，计算操作 1 的花费，再通过双指针检查对称位置的字符，统计不同字符的对数，计算操作 2 的花费，更新总花费的最小值。

#### 作者：makerlife (4星)
- **关键亮点**：详细解释了操作 1 和操作 2 的实现方法，给出了回文判断部分的代码，还提到了一些小细节。
```cpp
#include<cstdio>
#include<string>
#include<iostream>
#define INF 1ll<<62
#define ll long long
#define int ll
using namespace std;
int n,a,b;
int ans=INF;
string s;
signed main()
{
    scanf("%lld%lld%lld",&n,&a,&b);
    cin>>s;
    s+=s;
    for(int i=0;i<n;i++)
    {
        int t=a*i;
        for(int j=0;j<n/2;j++)
        {
            int x=i+j;
            int y=n+i-1-j;
            if(s[x]!=s[y])
            {
                t+=b;
            }
        }
        ans=min(ans,t);
    }
    printf("%lld\n",ans);
    return 0;
}
```
核心实现思想：将字符串复制一份接在后面，枚举操作 1 的次数 $i$，计算操作 1 的花费，通过双指针判断截取的子串是否为回文，统计不同字符的对数，计算操作 2 的花费，更新总花费的最小值。

### 最优关键思路或技巧
- **复制字符串**：将字符串复制一份接在后面，通过截取子串可以方便地模拟操作 1，避免了循环移动元素的复杂操作。
- **双指针法**：在判断回文串时，使用双指针从字符串两端向中间遍历，时间复杂度为 $O(n)$。

### 拓展思路
同类型题或类似算法套路：
- 字符串操作与状态枚举：可以通过枚举字符串的不同状态，结合一些基本操作（如替换、移动等），计算达到目标状态的最小代价。
- 回文串判断：双指针法是判断回文串的常用方法，可以应用于各种与回文串相关的问题。

### 推荐题目
- [P1015 [NOIP1999 普及组] 回文数](https://www.luogu.com.cn/problem/P1015)
- [P1308 [NOIP2011 普及组] 统计单词数](https://www.luogu.com.cn/problem/P1308)
- [P5733 【深基6.例1】自动修正](https://www.luogu.com.cn/problem/P5733)

### 个人心得摘录与总结
部分题解提到了一些注意事项，如开 `long long` 类型以避免答案溢出，以及特判全部执行操作 2 的花费等，这些都是在实际编程中容易忽略的细节，需要特别注意。

---
处理用时：49.29秒
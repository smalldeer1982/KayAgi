# 题目信息

# [ABC315C] Flavors

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_c

$ N $ カップのアイスクリームがあります。  
 $ i $ カップ目の味は $ F_i $ 、美味しさは $ S_i $ ( $ S_i $ は偶数 ) です。

あなたは、 $ N $ 個のカップの中から $ 2 $ つを選んで食べることにしました。  
 このときの満足度は次のように定義されます。

- 食べたアイスクリームの美味しさを $ s,t $ ( 但し、 $ s\ \ge\ t $ ) とする。
  - $ 2 $ つのカップの味が異なるなら、満足度は $ \displaystyle\ s+t $ である。
  - そうでないなら、満足度は $ \displaystyle\ s\ +\ \frac{t}{2} $ である。
 
満足度として達成可能な最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ 1\ \le\ F_i\ \le\ N $
- $ 2\ \le\ S_i\ \le\ 10^9 $
- $ S_i $ は偶数
 
### Sample Explanation 1

$ 2 $ カップ目と $ 4 $ カップ目のアイスを食べることを考えます。 - $ 2 $ カップ目の味は $ 2 $ 、美味しさは $ 10 $ です。 - $ 4 $ カップ目の味は $ 3 $ 、美味しさは $ 6 $ です。 - 両者の味は異なるので、満足度は $ 10+6=16 $ です。 以上より、満足度 $ 16 $ を達成できます。 満足度を $ 16 $ より大きくすることはできません。

### Sample Explanation 2

$ 1 $ カップ目と $ 4 $ カップ目のアイスを食べることを考えます。 - $ 1 $ カップ目の味は $ 4 $ 、美味しさは $ 10 $ です。 - $ 4 $ カップ目の味は $ 4 $ 、美味しさは $ 12 $ です。 - 両者の味は同じなので、満足度は $ 12+\frac{10}{2}=17 $ です。 以上より、満足度 $ 17 $ を達成できます。 満足度を $ 17 $ より大きくすることはできません。

## 样例 #1

### 输入

```
4

1 4

2 10

2 8

3 6```

### 输出

```
16```

## 样例 #2

### 输入

```
4

4 10

3 2

2 4

4 12```

### 输出

```
17```

# AI分析结果

### 题目翻译
有 $N$ 杯冰淇淋。第 $i$ 杯冰淇淋的口味是 $F_i$，美味度是 $S_i$（$S_i$ 是偶数）。

你决定从这 $N$ 个杯子中选择 $2$ 个来吃。此时的满意度定义如下：

- 设你吃的冰淇淋的美味度为 $s$ 和 $t$（其中 $s \geq t$）。
  - 如果两个杯子的口味不同，满意度为 $s + t$。
  - 否则，满意度为 $s+\frac{t}{2}$。

请求出可以达到的最大满意度。

### 综合分析与结论
这些题解主要围绕贪心算法展开，通过不同的方式来确定选择哪两个冰淇淋能使满意度最大。各题解的思路和要点如下：
1. **排序后调整法**：先按美味度排序，选取最大美味度的冰淇淋，将同口味的冰淇淋美味度减半后重新排序，取前两个之和。如 lrx___ 的题解。
2. **排序后分类讨论**：按美味度排序，若最大和次大的口味不同，直接相加；否则，找到第一个不同口味的与最大的计算。如 Elairin176 的题解。
3. **枚举比较法**：枚举所有可能的组合，按规则计算满意度并取最大值。如封禁用户的题解。
4. **按口味分组法**：将同种口味的冰淇淋存入 `vector` 数组，记录最大值和次大值，比较不同情况的结果。如 Failure_Terminator 的题解。

难点在于如何高效地找出最大满意度的组合，避免不必要的计算。不同题解在时间复杂度和代码实现上有所差异，排序和贪心策略是解决本题的关键。

### 所选题解
- **lrx___（5星）**：
    - **关键亮点**：思路清晰，代码简洁，通过两次排序巧妙地解决了问题。先按美味度排序，选取最大美味度的冰淇淋，将同口味的冰淇淋美味度减半后重新排序，取前两个之和。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
#include<utility>
using namespace std;
typedef pair<int,int> pii;
const int N=3e5+5;
pii a[N];
bool cmp(pii x,pii y){
    return x.second>y.second;
}
int main(){
    int n,i,f;
    scanf("%d",&n);
    for(i=0;i^n;i++){
        scanf("%d%d",&a[i].first,&a[i].second);
    }
    sort(a,a+n,cmp);
    f=a[0].first;
    for(i=1;i^n;i++){
        if(a[i].first==f){
            a[i].second>>=1;
        }
    }
    sort(a,a+n,cmp);
    printf("%d\n",a[0].second+a[1].second);
    return 0;
}
```
- **Elairin176（4星）**：
    - **关键亮点**：思路简洁明了，先按美味度排序，然后根据最大和次大的口味情况分类讨论，时间复杂度 $O(n\log n)$。
    - **核心思路**：按美味度排序后，若最大和次大的口味不同，结果就是这两个的美味度和；反之，计算最大和次大的美味度，再找到第一个不同口味的与最大的计算。
- **Miyamizu_Mitsuha（4星）**：
    - **关键亮点**：不仅给出了代码实现，还对贪心算法的正确性进行了证明，有助于理解算法的本质。
    - **核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
struct Ic {
    int fl;
    int ta;
};
bool cmp(const Ic &a, const Ic &b) {
    return a.ta > b.ta; 
}
int main() {
    int n;
    cin >> n;
    vector<Ic> icr(n);
    for (int i = 1; i <= n; i++) {
        cin >> icr[i].fl >> icr[i].ta;
    }
    sort(icr.begin(), icr.end(), cmp);
    int maxFl = icr[0].fl;
    int maxTa = icr[0].ta;
    int ans = -1e10; 
    for (int i = 2; i <= n; i++) {
        if (icr[i].fl!= maxFl) {
            ans = max(ans, maxTa + icr[i].ta);
        } else {
            ans = max(ans, maxTa + icr[i].ta / 2);
        }
    }
    cout << ans ;
    return 0;
}
```

### 最优关键思路或技巧
- **贪心策略**：先确定美味度最大的冰淇淋必选，再根据口味情况选择另一个冰淇淋，通过比较不同组合的满意度来确定最大值。
- **排序优化**：对冰淇淋按美味度排序，减少不必要的枚举，提高算法效率。

### 拓展思路
同类型题可能会改变物品的属性和选择规则，如增加物品的数量、改变满意度的计算方式等。解题时可以借鉴本题的贪心思想，先确定关键元素，再根据规则进行选择和比较。

### 推荐题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得摘录与总结
Miyamizu_Mitsuha 给出了贪心算法正确性的证明，通过举例说明最大美味度的组合一定包含美味度最大的冰淇淋，帮助理解算法的本质。这种对算法正确性的思考和证明有助于提高解题的准确性和自信心。 

---
处理用时：36.85秒
# 题目信息

# [ABC323C] World Tour Finals

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_c

$ N $ 人のプレイヤーが参加するプログラミングコンテスト World Tour Finals が行われており、競技時間の半分が過ぎました。 このコンテストでは $ M $ 問の問題が出題されており、問題 $ i $ の点数 $ A_i $ は $ 500 $ 以上 $ 2500 $ 以下の $ 100 $ の倍数です。

各 $ i\ =\ 1,\ \ldots,\ N $ について、プレイヤー $ i $ がどの問題を既に解いたかを表す文字列 $ S_i $ が与えられます。 $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列で、$ S_i $ の $ j $ 文字目が `o` のときプレイヤー $ i $ は問題 $ j $ を既に解いており、`x` のときまだ解いていません。 ただし、どのプレイヤーもまだ全ての問題を解いてはいません。

プレイヤー $ i $ の総合得点は、解いた問題の点数の合計に、**ボーナス点** $ i $ 点を加えた点数として計算されます。  
さて、各 $ i\ =\ 1,\ \ldots,\ N $ について以下の質問に答えてください。

- プレイヤー $ i $ がまだ解いていない問題を少なくとも何問解くことで、プレイヤー $ i $ の総合得点が他のプレイヤー全員の現在の総合得点を上回ることができますか？

なお、問題文中の条件と制約から、プレイヤー $ i $ が全ての問題を解くことで、他のプレイヤー全員の現在の総合得点を上回ることができることが証明できます。 このことから、答えは常に定義されることに注意してください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 100 $
- $ 1\leq\ M\leq\ 100 $
- $ 500\leq\ A_i\leq\ 2500 $
- $ A_i $ は $ 100 $ の倍数
- $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列
- $ S_i $ には `x` が一個以上含まれる
- 入力される数値は全て整数

### Sample Explanation 1

競技時間の半分の経過時の各プレイヤーの総合得点は、プレイヤー $ 1 $ が $ 2001 $ 点、プレイヤー $ 2 $ が $ 1502 $ 点、プレイヤー $ 3 $ が $ 1703 $ 点です。 プレイヤー $ 1 $ は $ 1 $ 問も解かずとも、他のプレイヤー全員の総合得点を上回っています。 プレイヤー $ 2 $ は、例えば問題 $ 4 $ を解けば総合得点が $ 3502 $ 点となり、他のプレイヤー全員の総合得点を上回ります。 プレイヤー $ 3 $ も、例えば問題 $ 4 $ を解けば総合得点が $ 3703 $ 点となり、他のプレイヤー全員の総合得点を上回ります。

## 样例 #1

### 输入

```
3 4
1000 500 700 2000
xxxo
ooxx
oxox```

### 输出

```
0
1
1```

## 样例 #2

### 输入

```
5 5
1000 1500 2000 2000 2500
xxxxx
oxxxx
xxxxx
oxxxx
oxxxx```

### 输出

```
1
1
1
1
0```

## 样例 #3

### 输入

```
7 8
500 500 500 500 500 500 500 500
xxxxxxxx
oxxxxxxx
ooxxxxxx
oooxxxxx
ooooxxxx
oooooxxx
ooooooxx```

### 输出

```
7
6
5
4
3
2
0```

# AI分析结果

### 题目翻译
# [ABC323C] 世界巡回总决赛

## 题目描述
[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_c

有 $N$ 名选手参加编程竞赛“世界巡回总决赛”，比赛时间已经过半。这场竞赛共有 $M$ 道题目，题目 $i$ 的分值 $A_i$ 是 $500$ 以上 $2500$ 以下的 $100$ 的倍数。

对于每个 $i = 1, \ldots, N$，会给出表示选手 $i$ 已经解出哪些题目的字符串 $S_i$。$S_i$ 是由 `o` 和 `x` 组成的长度为 $M$ 的字符串，当 $S_i$ 的第 $j$ 个字符为 `o` 时，表示选手 $i$ 已经解出了题目 $j$；当为 `x` 时，表示还未解出。不过，没有选手已经解出了所有题目。

选手 $i$ 的总得分是已解出题目分值的总和加上**奖励分** $i$ 分。

现在，请回答每个 $i = 1, \ldots, N$ 的以下问题：
- 选手 $i$ 至少要解出多少道尚未解出的题目，才能使自己的总得分超过其他所有选手当前的总得分？

根据题目中的条件和限制，可以证明选手 $i$ 解出所有题目后，能够超过其他所有选手当前的总得分。因此，请注意答案总是有定义的。

## 说明/提示
### 限制条件
- $2\leq N\leq 100$
- $1\leq M\leq 100$
- $500\leq A_i\leq 2500$
- $A_i$ 是 $100$ 的倍数
- $S_i$ 是由 `o` 和 `x` 组成的长度为 $M$ 的字符串
- $S_i$ 中至少包含一个 `x`
- 输入的所有数值均为整数

### 示例解释 1
比赛时间过半时，各选手的总得分分别为：选手 $1$ 得 $2001$ 分，选手 $2$ 得 $1502$ 分，选手 $3$ 得 $1703$ 分。选手 $1$ 即使一道题也不解，其总得分也已经超过了其他所有选手。选手 $2$ 例如解出题目 $4$ 后，总得分将变为 $3502$ 分，超过其他所有选手。选手 $3$ 同样，例如解出题目 $4$ 后，总得分将变为 $3703$ 分，超过其他所有选手。

## 样例 #1
### 输入
```
3 4
1000 500 700 2000
xxxo
ooxx
oxox
```
### 输出
```
0
1
1
```

## 样例 #2
### 输入
```
5 5
1000 1500 2000 2000 2500
xxxxx
oxxxx
xxxxx
oxxxx
oxxxx
```
### 输出
```
1
1
1
1
0
```

## 样例 #3
### 输入
```
7 8
500 500 500 500 500 500 500 500
xxxxxxxx
oxxxxxxx
ooxxxxxx
oooxxxxx
ooooxxxx
oooooxxx
ooooooxx
```
### 输出
```
7
6
5
4
3
2
0
```

### 综合分析与结论
这些题解的核心思路都是贪心算法。先计算出每个选手当前的总得分，找到最高分，然后对于每个选手，贪心选择未做过的题目中分值最高的题目，直到其总得分超过当前最高分。

### 算法要点对比
- **A_R_O_N_A**：使用结构体存储选手和题目信息，通过排序找出最高分，后续优化去掉了对选手的排序，直接在线求最大值。
- **没见过AC**：用数组记录题目分数和选手得分，将做过的题分数置为0，每次找剩余题目中分数最高的题。
- **无钩七不改名**：记录分数最大值和最大值的人数，若当前选手是最大值且人数为1则无需做题，否则贪心选未做过的高分题。
- **hellolin**：直接找出最大得分，对于非最大得分的选手，将未做过的题目按分数从大到小排序后贪心选择。
- **xiaomuyun**：先计算每个选手当前得分，再计算每个选手至少需要多少分数才能超过其他人，最后贪心选择高分题目。

### 解决难点对比
- **A_R_O_N_A**：原代码对选手排序较复杂，优化后去掉了这一步，减少了时间复杂度。
- **没见过AC**：通过将做过的题分数置为0，简化了选择未做过题的过程。
- **无钩七不改名**：考虑了最大值人数的情况，避免了重复做题。
- **hellolin**：利用 `std::max_element` 快速找到最大得分。
- **xiaomuyun**：通过 `max` 函数处理了分数相等时的情况。

### 评分
- **A_R_O_N_A**：4星。思路清晰，有代码优化过程，代码可读性较好。
- **没见过AC**：3星。思路简单直接，但代码中变量命名不够清晰。
- **无钩七不改名**：3星。考虑了一些特殊情况，但代码结构稍显复杂。
- **hellolin**：4星。代码简洁，使用了标准库函数，提高了代码的可读性。
- **xiaomuyun**：3星。思路明确，但代码中有一些冗余的空间浪费。

### 所选题解
- **A_R_O_N_A**（4星）：关键亮点在于对代码进行了优化，去掉了对选手的排序，减少了时间复杂度。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
    int x=0,w=1;
    char ch=0;
    while(ch<'0'||ch>'9'){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+(ch-'0');
        ch=getchar();
    }
    return x*w;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    static int sta[35];
    int top=0;
    do{
        sta[top++]=x%10,x/=10;
    }while(x);
    while(top)putchar(sta[--top]+'0');
}
struct node{
    int sum,num;
    string s;
};
struct problem{
    int point;
    map<int,bool>mp; 
}pro[105];
node a[105];
int n,m,maxx=-1;
bool cmp(problem x,problem y){
    return x.point>y.point;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
        pro[i].point=read();
    }
    for(int i=1;i<=n;i++){
        cin>>a[i].s;
        a[i].num=i;
        a[i].sum=i;
        for(int j=0;j<a[i].s.size();j++){
            if(a[i].s[j]=='o'){
                a[i].sum+=pro[j+1].point;
                pro[j+1].mp[a[i].num]=true;
            }
        }
        maxx=max(maxx,a[i].sum);
    }
    sort(pro+1,pro+1+m,cmp);
    for(int i=1;i<=n;i++){
        if(a[i].sum==maxx){
        	puts("0");
			continue;
		}
		int anss=0;
        for(int j=1;j<=m;j++){
            if(a[i].sum>maxx)break;
            if(pro[j].mp[a[i].num]==false){
                a[i].sum+=pro[j].point;
                anss++;
            }
        }
        write(anss);
        puts("");
    }
    return 0;
}
```
核心实现思想：先读取输入，计算每个选手的当前得分并找出最大值，对题目按分值从大到小排序，然后对于每个非最高分的选手，贪心选择未做过的高分题目，直到其得分超过最高分。

- **hellolin**（4星）：关键亮点是代码简洁，使用了标准库函数。
```cpp
constexpr int N = 200;
int n, m;
int a[N], r[N], ans, mx;
str s[N];
void solve() {
    std::cin >> n >> m;
    rep(i, m) std::cin >> a[i];
    rep(i, n) {
        std::cin >> s[i];
        s[i] = '#' + s[i];
        rep(j, m) {
            if (s[i][j] == 'o')
                r[i] += a[j];
        }
        r[i] += i;
    }
    mx = *std::max_element(r + 1, r + 1 + n);
    rep(i, n) {
        if(r[i] == mx) {
            std::cout << 0 << '\n';
            continue;
        }
        ans = 0;
        vec<int> wt;
        rep(j, m) if (s[i][j] == 'x')
            wt.pb(a[j]);
        std::sort(wt.begin(), wt.end(), std::greater<int>());
        for (auto &j : wt) {
            ++ans;
            if ((r[i] += j) > mx) break;
        }
        std::cout << ans << '\n';
    }
}
```
核心实现思想：读取输入，计算每个选手的当前得分，使用 `std::max_element` 找出最大得分，对于非最大得分的选手，将未做过的题目按分数从大到小排序后贪心选择。

### 最优关键思路或技巧
- **贪心策略**：每次选择未做过的题目中分值最高的题目，以最少的题目数超过最高分。
- **在线求最大值**：避免对选手进行排序，直接在计算得分时找出最大值，减少时间复杂度。
- **使用标准库函数**：如 `std::max_element` 可以快速找到最大值，提高代码的可读性和效率。

### 可拓展之处
同类型题目可能会有不同的条件变化，如题目分值范围变化、奖励分规则变化等，但核心思路还是贪心算法。类似的算法套路还有在资源分配问题中，优先选择价值高的资源以达到最优解。

### 洛谷相似题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)

### 个人心得
题解中未包含个人心得内容。

---
处理用时：64.51秒
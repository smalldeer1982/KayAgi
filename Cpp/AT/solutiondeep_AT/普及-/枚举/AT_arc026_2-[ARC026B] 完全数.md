# 题目信息

# [ARC026B] 完全数

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc026/tasks/arc026_2

高橋君は完全なものが大好きです。

自然数には、完全数というものがあります。 完全数というのは、自分以外の約数の総和が自分と等しくなる自然数のことです。 例えば $ 6 $ の場合 $ 1\ +\ 2\ +\ 3\ =\ 6 $となるので完全数です。 それに対して、自分以外の約数の総和が自分より小さくなる場合は不足数と言い、大きくなる場合は過剰数と言います。

高橋君には今気になっている自然数があります。高橋君のために、それが完全数なのか不足数なのか過剰数なのか判定してください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1\ ≦\ N\ ≦\ 10^5 $を満たすデータセットに正解した場合は $ 50 $ 点が与えられる。
- $ 1\ ≦\ N\ ≦\ 10^{10} $を満たすデータセットに正解した場合はさらに $ 50 $ 点が与えられる。合計で$ 100 $点となる。

### Sample Explanation 1

$ 1\ +\ 2\ +\ 3\ =\ 6 $なので$ 6 $は完全数です。

### Sample Explanation 2

$ 1\ +\ 2\ +\ 3\ +\ 4\ +\ 6\ +\ 8\ +\ 12\ >\ 24 $なので$ 24 $は過剰数です。

### Sample Explanation 3

$ 1\ +\ 3\ +\ 9\ <\ 27 $なので$ 27 $は不足数です。

## 样例 #1

### 输入

```
6```

### 输出

```
Perfect```

## 样例 #2

### 输入

```
24```

### 输出

```
Abundant```

## 样例 #3

### 输入

```
27```

### 输出

```
Deficient```

## 样例 #4

### 输入

```
945```

### 输出

```
Abundant```

# AI分析结果

### 题目翻译
### [ARC026B] 完全数

#### 题目描述
高桥君非常喜欢完美的东西。

在自然数中，有一类被称为完全数的数。完全数指的是除自身以外的所有约数之和等于它本身的自然数。例如，对于数字 6，因为 1 + 2 + 3 = 6，所以 6 是完全数。相反，如果一个数除自身以外的约数之和小于它本身，那么这个数被称为不足数；如果约数之和大于它本身，则被称为过剩数。

高桥君现在有一个他很在意的自然数。请帮高桥君判断这个数是完全数、不足数还是过剩数。

#### 说明/提示
##### 部分点
本题设置了部分分。
- 若能正确解答满足 1 ≤ N ≤ 10^5 的数据集，将获得 50 分。
- 若能正确解答满足 1 ≤ N ≤ 10^10 的数据集，将额外获得 50 分，总分达到 100 分。

##### 样例解释 1
因为 1 + 2 + 3 = 6，所以 6 是完全数。

##### 样例解释 2
因为 1 + 2 + 3 + 4 + 6 + 8 + 12 > 24，所以 24 是过剩数。

##### 样例解释 3
因为 1 + 3 + 9 < 27，所以 27 是不足数。

#### 样例 #1
##### 输入
```
6
```
##### 输出
```
Perfect
```

#### 样例 #2
##### 输入
```
24
```
##### 输出
```
Abundant
```

#### 样例 #3
##### 输入
```
27
```
##### 输出
```
Deficient
```

#### 样例 #4
##### 输入
```
945
```
##### 输出
```
Abundant
```

### 综合分析与结论
- **思路**：各题解核心思路一致，均是求出给定数除自身外的约数之和，再与该数比较，判断是完全数、不足数还是过剩数。
- **算法要点**：
    - 多数题解采用从 1 到 $\sqrt{n}$ 枚举约数的方法，利用约数成对出现的特性，提高效率。
    - 部分题解先直接枚举到 n 或 n/2，之后再进行优化。
- **解决难点**：
    - **数据范围**：由于数据最大到 $10^{10}$，普通 int 类型会溢出，需使用 long long 类型。
    - **时间复杂度**：直接枚举到 n 会超时，通过枚举到 $\sqrt{n}$ 优化。
    - **特殊情况处理**：1 需特判，完全平方数的约数会被重复统计，要进行去重处理。

### 所选题解
1. **作者：EtOH_Lewis (5星)**
    - **关键亮点**：详细展示了代码从最初版本逐步优化的过程，对每种优化的原因和效果分析清晰，适合学习思路。
    - **个人心得**：在解题过程中，先提交代码发现问题，如数据溢出、超时等，然后逐步分析并优化，如将 int 改为 long long，优化约数枚举范围，最终通过开根法结合特殊情况处理得到正确结果。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum(long long x)
{
    long long counter=1;
    double k=sqrt(x);
    for(int i=2;i<=k;i++)
    {
        if(x%i==0) counter+=(i+x/i);
    }
    return counter;
}
int main()
{
    long long n,m;cin>>n;m=sum(n);
    if(m==n)cout<<"Perfect"<<endl;
    if(m<n)cout<<"Deficient"<<endl;
    if(m>n) cout<<"Abundant"<<endl;
    return 0;
}
```
2. **作者：LJC00111 (4星)**
    - **关键亮点**：代码简洁，思路清晰，对特殊情况（如 1 和完全平方数）的处理明确。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n,ans=1;
    cin>>n;
    if(n==1)
    {
        cout<<"Deficient"<<endl;
        return 0;
    }
    for(int i=2;i<=sqrt(n);i++)
    {
        if(n%i==0)
        {
            ans=ans+i;
            ans=ans+n/i;
        }
        if(i==sqrt(n)&&n%i==0)
        {
            ans=ans-i;
        }
    }
    if(ans==n)
        cout<<"Perfect"<<endl;
    else if(ans<n)
        cout<<"Deficient"<<endl;
    else 
        cout<<"Abundant"<<endl;
    return 0;
}
```
3. **作者：tiaotiao (4星)**
    - **关键亮点**：思路清晰，对解题要点和注意事项说明详细，代码规范。
    - **个人心得**：强调了本题容易在输出格式（需换行）和时间复杂度（枚举到 $\sqrt{n}$）上出错。
    - **核心代码**：
```cpp
#include <cstdio>
#include <cmath>
int main()
{
    long long n;
    scanf("%lld",&n);
    long long sum=0;
    if(n==1)
    {
        printf("Deficient\n");
        return 0;
    }
    for(long long i=1;i<=sqrt(n);i++)
    {
        if(n%i==0)
        {
            sum+=i;sum+=n/i;
        }
    }
    sum-=n;
    long long sqn=sqrt(n);
    if(sqn*sqn==n)sum-=sqn;
    if(sum==n)printf("Perfect\n");
    if(sum<n)printf("Deficient\n");
    if(sum>n)printf("Abundant\n");
    return 0;
}
```

### 最优关键思路或技巧
- **约数成对枚举**：利用约数成对出现的特性，只需枚举到 $\sqrt{n}$，可将时间复杂度从 $O(n)$ 优化到 $O(\sqrt{n})$。
- **数据类型选择**：根据数据范围选择合适的数据类型，本题使用 long long 避免溢出。
- **特殊情况处理**：对 1 和完全平方数进行特判，避免结果错误。

### 可拓展之处
同类型题如判断一个数是否为半完全数（一个数的部分真约数之和等于它本身）、判断一个数是否为伪完全数（一个数的部分真约数之和等于它本身，但不包含所有真约数）等，都可以采用类似的约数枚举和判断思路。

### 洛谷推荐题目
1. [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)
2. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
3. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)

### 个人心得总结
- **EtOH_Lewis**：解题过程中要逐步分析问题，如发现数据溢出就更换数据类型，发现超时就优化算法，不断改进代码。
- **tiaotiao**：要注意题目细节，如输出格式，同时在算法上要考虑时间复杂度，避免超时。
- **dmslhy**：要注意因数和计算时的特殊情况，如 1 的特判和完全平方数的去重。
- **勘探员·引魂人**：对于难题可以先从部分分入手，采用枚举和暴力的方法解决部分问题。
- **zzhz**：注意题目要求，如本题要求输出换行，避免因细节问题出错。 

---
处理用时：44.21秒
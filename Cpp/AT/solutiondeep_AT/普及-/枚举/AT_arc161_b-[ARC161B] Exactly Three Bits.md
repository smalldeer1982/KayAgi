# 题目信息

# [ARC161B] Exactly Three Bits

## 题目描述

对于一个正整数 $X$，定义 $f(X)$ 为 $X$ 在二进制表示下 $1$ 的个数，比如，因为 $6=110_{(2)}$，$11=1101_{(2)}$，$16=10000_{(2)}$，所以 $f(6)=2$，$f(11)=3$，$f(16)=1$。

现在给定你一个正整数 $N$，问是否存在一个小于等于 $N$ 的正整数 $X$，满足 $f(X)=3$。如果存在，请输出满足条件的最大的 $X$，否则输出 `-1`。

本题有多组数据。

## 样例 #1

### 输入

```
4

16

161

4

1000000000000000000```

### 输出

```
14

161

-1

936748722493063168```

# AI分析结果

【题目内容】
### [ARC161B] 恰好三个二进制位为1

#### 题目描述
对于一个正整数 $X$，定义 $f(X)$ 为 $X$ 在二进制表示下 $1$ 的个数。例如，因为 $6 = 110_{(2)}$，$11 = 1101_{(2)}$，$16 = 10000_{(2)}$，所以 $f(6) = 2$，$f(11) = 3$，$f(16) = 1$。

现在给定一个正整数 $N$，询问是否存在一个小于等于 $N$ 的正整数 $X$，满足 $f(X) = 3$。如果存在，请输出满足条件的最大的 $X$，否则输出 `-1`。

本题有多组数据。

#### 样例 #1
##### 输入
```
4

16

161

4

1000000000000000000
```
##### 输出
```
14

161

-1

936748722493063168
```

【综合分析与结论】
这些题解主要围绕找出小于等于给定正整数 $N$ 且二进制表示中恰好有三个 $1$ 的最大数展开，若不存在则输出 `-1`。各题解思路大致可分为预处理枚举和分类讨论两种。
- **预处理枚举思路**：由于 $n \leq 10^{18}$，二进制表达不超 $60$ 位，满足条件的数有 $C_{60}^3 = 34220$ 个。先预处理出这些数，排序后对每个询问二分查找小于等于 $N$ 的最大数。
- **分类讨论思路**：先判断 $n \leq 6$ 时无解，再根据 $n$ 的二进制表示中 $1$ 的个数分类讨论，通过调整二进制位得到满足条件的最大数。

各题解的难点在于如何高效地找出满足条件的最大数，不同思路在处理方式上有所不同。预处理枚举思路的难点在于预处理和二分查找的实现；分类讨论思路的难点在于对不同情况的准确判断和二进制位的调整。

【所选的题解】
- **作者：Su777 (赞：4)，4星**
  - **关键亮点**：思路清晰，先预处理出所有满足条件的数，排序后用二分查找，代码简洁，可读性高。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long lint;

vector<lint> arr;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);    
    lint T;
    cin >> T;
    for (lint i = 0; i < 60; i ++) {
        for (lint j = i + 1; j < 60; j ++) {
            for (lint k = j + 1; k < 60; k ++) {
                lint value = (1ll << i) + (1ll << j) + (1ll << k);
                arr.push_back(value);
            }
        }
    }
    sort(arr.begin(), arr.end()); 
    while (T--) {
        lint n;
        cin >> n;
        if (n < 7) {
            cout << "-1\n"; 
            continue;
        }
        cout << *prev(upper_bound(arr.begin(), arr.end(), n)) << endl;
    }
    return 0;
}
```
  - **核心实现思想**：通过三重循环预处理出所有二进制表示中恰好有三个 $1$ 的数，存储在 `vector` 中并排序。对于每个询问，若 $n < 7$ 则输出 `-1`，否则用 `upper_bound` 找到第一个大于 $n$ 的数，再取前一个数即为答案。

- **作者：良心WA题人 (赞：2)，4星**
  - **关键亮点**：通过分类讨论直接对 $n$ 的二进制表示进行处理，逻辑严谨，代码实现较为巧妙。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        ll n;
        scanf("%lld",&n);
        if(n<7)
        {
            puts("-1");
            continue;
        }
        int cnt=0,a[104],m=0;
        ll x=n;
        while(x)
        {
            if(x&1)
                cnt++;
            a[m++]=x%2;
            x/=2;
        }
        if(cnt>=3)
        {
            int t=0;
            ll ans=0;
            for(int i=m-1;~i;i--)
                if(t<3&&a[i])
                {
                    ans+=1ll<<i;
                    t++;
                }
            printf("%lld\n",ans);
        }
        else
        {
            bool flag=false;
            for(int i=m-2;i>=2;i--)
                flag|=a[i];
            if(!flag)
            {
                int t=0;
                ll ans=0;
                for(int i=m-2;~i;i--)
                    if(t<3)
                    {
                        ans+=1ll<<i;
                        t++;
                    }
                printf("%lld\n",ans);
            }
            else
            {
                int t=1;
                bool flag=false;
                ll ans=1ll<<m-1;
                for(int i=m-2;~i;i--)
                {
                    if(flag&&t<3)
                    {
                        ans+=1ll<<i;
                        t++;
                    }
                    else
                        flag|=a[i];
                }
                printf("%lld\n",ans);
            }
        }
    }
    return 0;
}
```
  - **核心实现思想**：先将 $n$ 转换为二进制并统计 $1$ 的个数。若 $1$ 的个数大于等于 $3$，则保留高位的三个 $1$；若小于 $3$，根据是否存在非最高位的 $1$ 且后面能填两个 $1$ 进行不同处理。

- **作者：FreedomKing (赞：2)，4星**
  - **关键亮点**：使用 `bitset` 容器简化二进制操作，通过分类讨论逐步调整二进制位得到答案，思路直观。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
const int N=1e6+5;
int a[N],n,m,t,k;
signed main(){
    cin>>t;
    while(t--){
        cin>>n;
        if(n<=6){
            cout<<"-1\n";
            continue;
        }
        bitset<64>f(n);
        k=0;
        for(int i=0;i<f.size();i++) if(f[i]==1) k++;
        if(k==3) cout<<n<<'\n';
        if(k>3){
            int x=0;
            while(k>3){
                if(f[x]==1){
                    k--;
                    f[x]=0;
                }
                x++;
            }
            cout<<f.to_ullong()<<'\n';
        }
        if(k<3){
            int x=0;
            while(f[x]==0){
                f[x]=1;
                x++;
            }
            f[x]=0;
            k=0;
            for(int i=0;i<f.size();i++) if(f[i]==1) k++;
            if(k<3){
                // 重复上述操作多次
            }
            x=0;
            while(k>3){
                if(f[x]==1){
                    k--;
                    f[x]=0;
                }
                x++;
            }
            cout<<f.to_ullong()<<'\n';
        }
    }
    return 0;
}
```
  - **核心实现思想**：将 $n$ 存入 `bitset` 中，统计 $1$ 的个数。若 $1$ 的个数等于 $3$，则 $n$ 即为答案；若大于 $3$，则去掉低位的 $1$ 直到剩下三个；若小于 $3$，则多次减 $1$ 使 $1$ 的个数大于等于 $3$，再去掉低位的 $1$ 直到剩下三个。

【最优关键思路或技巧】
- **预处理枚举**：当满足条件的数数量较少时，可先预处理出所有可能的数，排序后用二分查找，能高效处理多组询问。
- **分类讨论**：根据 $n$ 的二进制表示中 $1$ 的个数进行分类讨论，通过调整二进制位得到满足条件的最大数，逻辑清晰。
- **使用 `bitset` 容器**：简化二进制操作，方便统计 $1$ 的个数和修改二进制位。

【拓展思路】
同类型题可拓展到求二进制表示中恰好有 $k$ 个 $1$ 的相关问题，或在一定范围内满足特定二进制条件的数的问题。类似算法套路可采用预处理枚举、分类讨论、位运算等方法。

【推荐题目】
- [P1100 高低位交换](https://www.luogu.com.cn/problem/P1100)
- [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)（涉及区间动态规划和位运算）
- [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)

【个人心得】
这些题解中未包含个人心得内容。

---
处理用时：55.01秒
# 题目信息

# 和がNの区間

## 题目描述

[problemUrl]: https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_i

数列 $ a $ に含まれる連続した区間のうち、和が $ N $ になるものがいくつ存在するかを出力しなさい。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100,000 $

## 样例 #1

### 输入

```
5

3 1 5 4 2```

### 输出

```
1```

## 样例 #2

### 输入

```
6

1 2 3 4 5 6```

### 输出

```
2```

## 样例 #3

### 输入

```
7

7 6 5 4 3 2 1```

### 输出

```
2```

## 样例 #4

### 输入

```
20

19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 12```

### 输出

```
3```

# AI分析结果

### 题目翻译
# 和为N的区间

## 题目描述
[problemUrl]: https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_i

在数列 $ a $ 包含的连续区间中，和为 $ N $ 的区间有多少个，请输出该数量。

## 说明/提示
### 限制条件
- $ 1\ \leq\ N\ \leq\ 100,000 $

## 样例 #1
### 输入
```
5
3 1 5 4 2
```
### 输出
```
1
```

## 样例 #2
### 输入
```
6
1 2 3 4 5 6
```
### 输出
```
2
```

## 样例 #3
### 输入
```
7
7 6 5 4 3 2 1
```
### 输出
```
2
```

## 样例 #4
### 输入
```
20
19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 12
```
### 输出
```
3
```

### 综合分析与结论
这些题解主要围绕如何找出数列中连续区间和为 $N$ 的区间数量展开。整体思路大致可分为暴力枚举和前缀和两种，部分题解在暴力枚举的基础上进行了剪枝优化。
- **暴力枚举**：通过两层循环枚举所有可能的区间，计算区间和并与 $N$ 比较，时间复杂度为 $O(n^2)$。
- **前缀和**：先计算前缀和数组，再通过两层循环枚举区间，利用前缀和数组快速计算区间和，同样时间复杂度为 $O(n^2)$，但计算区间和的效率更高。
- **优化点**：当区间和大于 $N$ 时，提前结束内层循环，避免不必要的计算，减少时间复杂度。

### 所选题解
- **作者：伟大的王夫子 (4星)**
    - **关键亮点**：思路清晰，先指出暴力枚举的超时问题，再通过观察性质进行优化，代码可读性高。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, a[100010], ans;
int main() {
    cin >> n;
    for (register int i = 1; i <= n; ++i) scanf("%d", a + i);
    for (register int i = 1; i <= n; ++i) {
        ll s = 0;
        for (register int j = i; j <= n; ++j) {
            s += a[j];
            if (s == n) {
                ++ans;
                break;
            }
            if (s > n) break;
        }
    }
    cout << ans;
}
```
    - **核心实现思想**：外层循环枚举区间左端点 $i$，内层循环从 $i$ 开始枚举右端点 $j$，累加区间和 $s$，当 $s$ 等于 $N$ 时答案加一，当 $s$ 大于 $N$ 时提前结束内层循环。

- **作者：Symbolize (4星)**
    - **关键亮点**：明确指出区间和问题一般用前缀和解决，思路清晰，代码规范。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
const int N=1e5+10;
using namespace std;
int n,a[N],s[N],ans;
signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        cin>>a[i];
        s[i]=s[i-1]+a[i];//前缀和
    }
    for(int l=1;l<=n;l++)
    {
        for(int r=l;r<=n;r++)
        {
            int sum=s[r]-s[l-1];
            if(sum==n) ++ans;//记录答案个数
            if(sum>n) break;//小优化
        }
    }
    cout<<ans<<endl;//输出答案
    return 0;//收尾
} 
```
    - **核心实现思想**：先计算前缀和数组 $s$，然后通过两层循环枚举区间左右端点 $l$ 和 $r$，利用前缀和数组计算区间和 $sum = s[r] - s[l - 1]$，当 $sum$ 等于 $N$ 时答案加一，当 $sum$ 大于 $N$ 时提前结束内层循环。

- **作者：tZEROちゃん (4星)**
    - **关键亮点**：详细解释了前缀和的原理，代码简洁明了。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[114514];
int s[114514];
int main() {
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    s[i] = s[i - 1] + a[i];
  }
  int cnt = 0;
  for (int i = 1; i <= n; i++) {
    for (int j = i; j <= n; j++) {
      if (s[j] - s[i - 1] == n) {
        cnt++;
      } else if (s[j] - s[i - 1] > n) {
        break;
      }
    }
  } // i 和 j 分别对应分析中的 l 和 r。
  cout << cnt;
  return 0;
}
```
    - **核心实现思想**：与 Symbolize 的题解类似，先计算前缀和数组 $s$，再通过两层循环枚举区间左右端点 $i$ 和 $j$，利用前缀和数组计算区间和，当区间和等于 $N$ 时答案加一，当区间和大于 $N$ 时提前结束内层循环。

### 最优关键思路或技巧
- **前缀和**：对于区间和问题，使用前缀和数组可以快速计算任意区间的和，避免重复计算，提高效率。
- **剪枝优化**：在枚举区间时，当区间和大于 $N$ 时，由于后续的区间和只会更大，所以可以提前结束内层循环，减少不必要的计算。

### 可拓展之处
同类型题或类似算法套路：
- **子数组和问题**：如求子数组和为 $0$ 的子数组数量、子数组和最大的子数组等，都可以使用前缀和的思想。
- **滑动窗口问题**：对于一些连续区间的问题，可以使用滑动窗口的方法，在 $O(n)$ 的时间复杂度内解决。

### 推荐洛谷题目
- P1115 最大子段和
- P2671 求和
- P1719 最大加权矩形

### 个人心得摘录与总结
- **Kevin_Zhen**：尝试了不同复杂度的算法，从 $O(n^3)$ 的暴力枚举到 $O(n^2)$ 的优化枚举，再到使用前缀和的优化算法，发现不加剪枝会导致超时，强调了剪枝优化的重要性。
- **a2920353120**：指出在使用前缀和暴力枚举时，两个 `break` 语句的作用是可行性剪枝，不加会超时，提醒在解题时要注意优化。 

---
处理用时：43.06秒
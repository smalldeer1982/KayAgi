# 题目信息

# [ARC024A] くつがくっつく

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc024/tasks/arc024_1

ARCマートは土曜日だけに営業する靴屋さんです。扱う靴は$ 1 $種類だけで、サイズ以外の見分けはつきません。 残念なことに、 $ 1 $ 週間ぶりに店を開けると空き巣に入られてしまったらしく、靴がめちゃくちゃに散乱していました。

残っている靴を全部かき集めると、左足の靴が $ L $ 足、右足の靴が $ R $ 足みつかりました。 ただ、靴を売るには同じサイズを両足分そろえてペアにしなければなりません。 靴の種類はすべて同じなので、ペアを作るときはサイズだけを気にすれば良さそうです。

もう開店まで時間がないので、店長のために、最大で何組のペアを作ることができるか求めてください。

## 说明/提示

### Sample Explanation 1

サイズ $ 22 $ のペアが $ 1 $ つだけ作れます。

### Sample Explanation 2

サイズ $ 10 $ 、サイズ $ 11 $ のペアがそれぞれ $ 1 $ つずつ作れます。

## 样例 #1

### 输入

```
3 3

20 21 22

30 22 15```

### 输出

```
1```

## 样例 #2

### 输入

```
3 4

10 11 10

12 10 11 25```

### 输出

```
2```

## 样例 #3

### 输入

```
5 5

10 10 10 10 10

10 10 10 10 10```

### 输出

```
5```

## 样例 #4

### 输入

```
5 5

10 11 12 13 14

30 31 32 33 34```

### 输出

```
0```

# AI分析结果

### 题目翻译
ARC 商店是一家只在周六营业的鞋店。店里只卖一种鞋子，除了尺码之外没有其他区别。遗憾的是，时隔一周开店时，好像遭遇了入室盗窃，鞋子被弄得乱七八糟。

把剩下的鞋子全部收集起来后，发现有 $L$ 只左脚的鞋和 $R$ 只右脚的鞋。不过，要卖鞋子的话，必须将相同尺码的左右脚鞋子配成一对。因为鞋子的种类都一样，所以配对时只需要考虑尺码就可以了。

开店的时间已经不多了，请帮店长计算一下，最多能配成多少对鞋子。

### 综合分析与结论
这些题解的核心思路主要分为两类：暴力枚举和桶排（计数统计）。
- **暴力枚举**：通过双重循环遍历左右鞋的数组，找到匹配的鞋子并标记已使用，避免重复匹配。这种方法简单直接，但时间复杂度较高，为 $O(n^2)$，适用于数据规模较小的情况。
- **桶排（计数统计）**：使用数组或 `map` 记录左右鞋各尺码的数量，然后遍历所有可能的尺码，取左右鞋该尺码数量的最小值累加，得到最终的配对数。这种方法时间复杂度较低，为 $O(n)$ 或 $O(n log n)$（使用 `map` 时），效率更高。

### 所选题解
- **作者：JJA_ (赞：6)，4星**
    - **关键亮点**：思路清晰，使用 `map` 记录左边每个号码出现的次数，在处理右边鞋子时进行匹配，代码简洁。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int sum=0;
map<int,int>type;
signed main(){
    int L,R;
    cin>>L>>R;
    int left,right;
    while(L--){
        cin>>left;
        type[left]++;
    }
    while(R--){
        cin>>right;
        if(type[right]!=0){
            sum++;
            type[right]--;
        }
    }
    cout<<sum<<endl;
}
```
核心实现思想：先使用 `map` 记录左鞋各尺码的数量，再遍历右鞋，若右鞋尺码在 `map` 中存在且数量不为 0，则配对成功，配对数加 1 并减少该尺码的数量。

- **作者：ByGones (赞：6)，4星**
    - **关键亮点**：使用优先队列对左右鞋的尺码进行排序，通过比较队首元素来配对，思路新颖。
    - **个人心得**：提醒优先队列的队首是 `top` 而不是 `front`，以及行末要换行。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std; 
priority_queue<int>l,r;
int L,R,s;
int main()
{
    cin>>L>>R;
    while(L--)
    {
        int t;
        cin>>t;
        l.push(t);
    }
    while(R--)
    {
        int t;
        cin>>t;
        r.push(t);
    }
    while(!l.empty()&&!r.empty())
    {
        if(l.top()==r.top())
        {
            l.pop();
            r.pop();
            s++;
        }
        else if(l.top()<r.top())
            r.pop();
        else
            l.pop();
    }
    cout<<s<<endl;
    return 0;
}
```
核心实现思想：将左右鞋的尺码分别放入优先队列中，比较队首元素，若相等则配对成功，队首元素出队；若不相等则较大的队首元素出队，直到其中一个队列为空。

- **作者：Cripple_Abyss (赞：5)，4星**
    - **关键亮点**：使用桶排思想，用两个数组分别记录左右鞋各尺码的数量，通过取最小值累加得到配对数，代码简洁高效。
    - **个人心得**：无
    - **核心代码**：
```cpp
#include <cstdio>
int n,m,l[55],r[55],ans;
int mn(int x,int y) {return x<=y?x:y;}
int main() {
    scanf("%d%d",&n,&m);
    for (int i=1,x; i<=n; ++i) scanf("%d",&x),l[x]++;
    for (int i=1,x; i<=m; ++i) scanf("%d",&x),r[x]++;
    for (int i=10; i<=40; ++i) ans+=mn(l[i],r[i]);
    printf("%d\n",ans);
    return 0;
}
```
核心实现思想：用数组 `l` 和 `r` 分别记录左右鞋各尺码的数量，遍历所有可能的尺码，取 `l[i]` 和 `r[i]` 的最小值累加得到最终的配对数。

### 最优关键思路或技巧
- **使用桶排（计数统计）**：通过数组或 `map` 记录各元素的出现次数，避免了暴力枚举的重复比较，时间复杂度较低。
- **使用优先队列**：对元素进行排序，方便比较和配对，适用于需要动态调整元素顺序的情况。

### 可拓展之处
同类型题或类似算法套路：
- 统计两个数组中相同元素的个数，可使用桶排或哈希表。
- 配对问题，如男女配对、任务分配等，可使用贪心算法或二分图匹配算法。

### 推荐题目
- [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)：通过哈希表统计元素出现次数，解决数对匹配问题。
- [P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427)：简单的数组操作，可练习数组的输入输出和遍历。
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：使用数组标记区间，解决区间覆盖问题。

### 个人心得摘录与总结
- **ByGones**：提醒优先队列的队首是 `top` 而不是 `front`，以及行末要换行，避免因细节问题导致答案错误。
- **Ouyyx2002**：做题时忘记 Pascal 没有 `min` 函数，导致编译错误，提醒要熟悉所使用语言的函数库。
- **stry**：强调暴力枚举时要清零已配对的鞋子，避免重复计算。
- **A_Plus_Gu**：指出一双左鞋只能与一双右鞋对应，找到配对后要标记已配对并跳出循环，提高效率。

---
处理用时：40.46秒
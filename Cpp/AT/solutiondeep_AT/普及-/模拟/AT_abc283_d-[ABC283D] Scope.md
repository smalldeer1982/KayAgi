# 题目信息

# [ABC283D] Scope

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc283/tasks/abc283_d

英小文字、`(`、`)` からなる文字列のうち、以下の手順によって空文字列になるものを**良い文字列**と呼びます:

- まず、英小文字をすべて削除する。
- 次に、連続する `()` が存在する限り、それを削除する。
 
例えば、`((a)ba)` は英小文字をすべて削除すると `(())` となり、$ 2 $ 文字目と $ 3 $ 文字目に連続する `()` を削除すると `()` となり、最終的に空文字列にすることができるので良い文字列です。

良い文字列 $ S $ が与えられます。 $ S $ の $ i $ 文字目を $ S_i $ で表します。

各英小文字 `a` , `b` , $ \ldots $ , `z` に対して、その文字が書かれたボールが $ 1 $ つあります。 また、空の箱があります。

高橋君は $ i\ =\ 1,2, $ $ \ldots $ $ ,|S| $ に対してこの順に気を失わない限り操作を行います。

- $ S_i $ が英小文字ならば、その英小文字が書かれたボールを箱に入れる。ただし、そのボールがすでに箱に入っている場合、高橋君は気を失う。
- $ S_i $ が `(` ならば、何もしない。
- $ S_i $ が `)` ならば、$ i $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ i $ 番目までの文字からなる文字列が良い文字列となる最大の整数 $ j $ を取る。（このような整数 $ j $ は必ず存在することが証明できる。）$ j $ 番目から $ i $ 番目までの操作で箱に入れたボールをすべて、箱から取り出す。
 
高橋君が気を失わずに一連の操作を完了させられるか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 3\ \times\ 10^5 $
- $ S $ は良い文字列
 
### Sample Explanation 1

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は何もしません。 $ i\ =\ 3 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 4 $ のとき、$ 4 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 4 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 2 $ であるため、高橋君は `a` の書かれたボールを箱から取り出します。 $ i\ =\ 5 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 6 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 7 $ のとき、$ 7 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 7 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 1 $ であるため、高橋君は `a` の書かれたボールと `b` の書かれたボールを箱から取り出します。 したがってこの場合の答えは `Yes` となります。

### Sample Explanation 2

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 3 $ のとき、高橋君は何もしません。 $ i\ =\ 4 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 5 $ のとき、`a` の書かれたボールはすでに箱に入っているため、高橋君は気を失い、これ以降の操作は行われません。 したがってこの場合の答えは `No` となります。

## 样例 #1

### 输入

```
((a)ba)```

### 输出

```
Yes```

## 样例 #2

### 输入

```
(a(ba))```

### 输出

```
No```

## 样例 #3

### 输入

```
(((())))```

### 输出

```
Yes```

## 样例 #4

### 输入

```
abca```

### 输出

```
No```

# AI分析结果

### 题目翻译
#### [ABC283D] 作用域

##### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc283/tasks/abc283_d

由小写英文字母、`(`、`)` 组成的字符串中，通过以下步骤能变成空字符串的，被称为**好字符串**：
- 首先，删除所有小写英文字母。
- 然后，只要存在连续的 `()`，就将其删除。

例如，`((a)ba)` 删除所有小写英文字母后变为 `(())`，删除第 2 个和第 3 个字符组成的连续 `()` 后变为 `()`，最终可以变成空字符串，所以是好字符串。

给定一个好字符串 $S$，用 $S_i$ 表示 $S$ 的第 $i$ 个字符。

对于每个小写英文字母 `a`、`b`、……、`z`，都有一个写有该字母的球。此外，还有一个空箱子。

高桥君会按顺序对 $i = 1, 2, \ldots, |S|$ 依次进行操作，除非他晕倒：
- 如果 $S_i$ 是小写英文字母，则将写有该字母的球放入箱子中。若该球已在箱子中，高桥君会晕倒。
- 如果 $S_i$ 是 `(`，则什么也不做。
- 如果 $S_i$ 是 `)`，则取小于 $i$ 的最大整数 $j$，使得 $S$ 中从第 $j$ 个到第 $i$ 个字符组成的字符串是好字符串（可以证明这样的整数 $j$ 一定存在）。将在第 $j$ 个到第 $i$ 个操作中放入箱子的球全部取出。

请判断高桥君能否在不晕倒的情况下完成这一系列操作。

##### 说明/提示
- **限制条件**
  - $1 \leq |S| \leq 3 \times 10^5$
  - $S$ 是好字符串
- **样例解释 1**
  - $i = 1$ 时，高桥君什么也不做。
  - $i = 2$ 时，高桥君什么也不做。
  - $i = 3$ 时，高桥君将写有 `a` 的球放入箱子中。
  - $i = 4$ 时，小于 4 的最大整数 $j$ 使得 $S$ 中从第 $j$ 个到第 4 个字符组成的字符串是好字符串，这个 $j$ 为 2，所以高桥君将写有 `a` 的球从箱子中取出。
  - $i = 5$ 时，高桥君将写有 `b` 的球放入箱子中。
  - $i = 6$ 时，高桥君将写有 `a` 的球放入箱子中。
  - $i = 7$ 时，小于 7 的最大整数 $j$ 使得 $S$ 中从第 $j$ 个到第 7 个字符组成的字符串是好字符串，这个 $j$ 为 1，所以高桥君将写有 `a` 和 `b` 的球从箱子中取出。
  因此，这种情况下的答案是 `Yes`。
- **样例解释 2**
  - $i = 1$ 时，高桥君什么也不做。
  - $i = 2$ 时，高桥君将写有 `a` 的球放入箱子中。
  - $i = 3$ 时，高桥君什么也不做。
  - $i = 4$ 时，高桥君将写有 `b` 的球放入箱子中。
  - $i = 5$ 时，写有 `a` 的球已在箱子中，所以高桥君晕倒，后续操作不再进行。
  因此，这种情况下的答案是 `No`。

##### 样例
- **样例 #1**
  - **输入**
```
((a)ba)
```
  - **输出**
```
Yes
```
- **样例 #2**
  - **输入**
```
(a(ba))
```
  - **输出**
```
No
```
- **样例 #3**
  - **输入**
```
(((())))
```
  - **输出**
```
Yes
```
- **样例 #4**
  - **输入**
```
abca
```
  - **输出**
```
No
```

### 综合分析与结论
这些题解的核心都是模拟高桥君的操作过程，关键在于处理好括号匹配和字母球的放入与取出。各题解的思路和实现方式有所不同，但本质都是围绕如何高效地判断字母球是否重复放入以及如何正确处理括号匹配后的球的取出操作。

### 所选题解
- **作者：szhqwq (赞：6)  4星**
  - **关键亮点**：思路清晰，使用标记数组记录字母所在的括号层数，通过一个变量记录当前括号层数，实现简单高效。
  - **个人心得**：作者提到 `cnt` 初始赋值应赋为 1，否则赋为 0 会与没有标记是同一回事，自己因此吃了一发罚时。
```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 30;

string s;
int st[N];

signed main() {
    cin >> s;
    int cnt = 1;
    memset(st,false,sizeof st);
    for (int i = 0; i < s.size(); i ++ ) {
        if (s[i] == '(') {
            cnt ++;
        } else if (s[i] >= 'a' && s[i] <= 'z') {
            if (st[s[i] - 'a']) {
                puts("No");
                return 0;
            } else st[s[i] - 'a'] = cnt;
        } else if (s[i] == ')') {
            for (int j = 0; j < 26; j ++ ) if (st[j] == cnt) st[j] = false;
            cnt --;
        }
    }
    cout << "Yes" << endl;
    return 0;
}
```
核心实现思想：使用标记数组 `st` 记录每个字母所在的括号层数，`cnt` 记录当前括号层数。遇到 `(` 时，`cnt` 加 1；遇到字母时，若该字母已在当前括号层标记过则输出 `No`，否则标记该字母所在的括号层；遇到 `)` 时，将当前括号层标记的字母标记清除，`cnt` 减 1。

- **作者：_dijkstra_ (赞：3)  4星**
  - **关键亮点**：先给出暴力思路，再进行优化，通过记录每一位的计数器变化，避免了暴力删除的操作，减少了时间复杂度。
```cpp
int cnt[300005][30];
void solve()
{
    string s;
    cin >> s;
    int n = s.length();
    s = '%' + s;
    stack <int> stk; //左括号
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < 26; j++) cnt[i][j] = cnt[i - 1][j];
        if (s[i] == '(') stk.push(i);
        else if (s[i] == ')')
        {
            for (int j = 0; j < 26; j++) cnt[i][j] = cnt[stk.top()][j];
            stk.pop();
        }
        else
        {
            if (cnt[i][s[i] - 'a'] >= 1) {puts("No"); return;}
            cnt[i][s[i] - 'a']++;
        }
    }
    puts("Yes");
}
```
核心实现思想：使用二维数组 `cnt` 记录每一位的计数器变化，遇到 `(` 时将其位置压入栈中；遇到 `)` 时，将当前位置的计数器回溯到对应的左括号位置；遇到字母时，若该字母计数器大于等于 1 则输出 `No`，否则计数器加 1。

- **作者：StayAlone (赞：2)  4星**
  - **关键亮点**：先预处理出所有右括号对应的左括号位置，再用栈模拟放入的字母，同时带上字母的位置，对于操作 3 直接模拟，时间复杂度为 $\Theta(n)$。
```cpp
char s[MAXN]; int n;
int maxp[MAXN];
stack <pair <int, char> > box;
bool vis[300];

int main() {
    scanf("%s", s + 1); n = strlen(s + 1);
    stack <int> st;
    rep1(i, 1, n) {
        if (s[i] == '(') st.emplace(i);
        else if (s[i] == ')') maxp[i] = st.top(), st.pop();
    }
    rep1(i, 1, n) {
        if (s[i] == '(') continue;
        if (isalpha(s[i])) {
            if (vis[s[i]]) return puts("No"), 0;
            box.emplace(i, s[i]); vis[s[i]] = true;
        } else {
            int p = maxp[i];
            while (box.size() && box.top().fst >= p) {
                vis[box.top().snd] = false; box.pop();
            }
        }
    } puts("Yes");
    rout;
}
```
核心实现思想：先使用栈预处理出所有右括号对应的左括号位置，存储在 `maxp` 数组中。然后遍历字符串，遇到字母时，若该字母已被标记则输出 `No`，否则将其压入栈中并标记；遇到 `)` 时，根据 `maxp` 数组找到对应的左括号位置，将栈中该位置及之后的字母标记清除并弹出。

### 最优关键思路或技巧
- 使用栈来处理括号匹配，能高效地找到每个右括号对应的左括号。
- 利用标记数组或二维数组记录字母的状态，方便判断字母是否重复放入以及处理括号匹配后的状态更新。

### 可拓展之处
同类型题或类似算法套路：
- 括号匹配相关问题，如判断括号序列是否合法、计算嵌套括号的深度等。
- 模拟操作类问题，需要根据给定的规则模拟一系列操作，判断最终结果。

### 洛谷相似题目
- P1739 表达式括号匹配：https://www.luogu.com.cn/problem/P1739
- P1944 最长括号匹配：https://www.luogu.com.cn/problem/P1944
- P5788 【模板】单调栈：https://www.luogu.com.cn/problem/P5788

### 个人心得总结
- **szhqwq**：在使用标记数组时，要注意初始值的设置，避免与未标记状态混淆，否则可能导致错误。

---
处理用时：65.64秒
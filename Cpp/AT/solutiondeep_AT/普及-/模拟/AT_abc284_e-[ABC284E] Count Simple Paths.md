# 题目信息

# [ABC284E] Count Simple Paths

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc284/tasks/abc284_e

頂点に $ 1 $ から $ N $ の番号が、辺に $ 1 $ から $ M $ の番号がついた $ N $ 頂点 $ M $ 辺の単純無向グラフが与えられます。辺 $ i $ は頂点 $ u_i $ と頂点 $ v_i $ を結んでいます。また、各頂点の次数は $ 10 $ 以下です。  
 頂点 $ 1 $ を始点とする単純パス(同じ頂点を複数回通らないパス)の個数を $ K $ とします。$ \min(K,\ 10^6) $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min\ \left(2\ \times\ 10^5,\ \frac{N(N-1)}{2}\right) $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 入力で与えられるグラフは単純グラフ
- 入力で与えられるグラフの頂点の次数はすべて $ 10 $ 以下
- 入力される値は全て整数
 
### Sample Explanation 1

条件を満たすパスは次の $ 3 $ 個です。(長さが $ 0 $ のパスも数えるのに注意してください。) - 頂点 $ 1 $ - 頂点 $ 1 $, 頂点 $ 2 $ - 頂点 $ 1 $, 頂点 $ 2 $, 頂点 $ 3 $

## 样例 #1

### 输入

```
4 2

1 2

2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 6

1 2

1 3

1 4

2 3

2 4

3 4```

### 输出

```
16```

## 样例 #3

### 输入

```
8 21

2 6

1 3

5 6

3 8

3 6

4 7

4 6

3 4

1 5

2 4

1 2

2 7

1 4

3 5

2 5

2 3

4 5

3 7

6 7

5 7

2 8```

### 输出

```
2023```

# AI分析结果

### 题目翻译
给定一个有 $N$ 个顶点和 $M$ 条边的简单无向图，顶点编号从 $1$ 到 $N$，边编号从 $1$ 到 $M$。边 $i$ 连接顶点 $u_i$ 和顶点 $v_i$。此外，每个顶点的度数不超过 $10$。

设从顶点 $1$ 出发的简单路径（不重复经过同一顶点的路径）的数量为 $K$，请输出 $\min(K, 10^6)$。

### 综合分析与结论
本题要求计算从顶点 $1$ 出发的简单路径数量，并输出该数量与 $10^6$ 的较小值。由于图中可能存在环，且路径数量可能很大，直接暴力搜索会超时。但题目给出了每个顶点度数不超过 $10$ 以及答案取 $\min(K, 10^6)$ 的限制，这使得我们可以使用深度优先搜索（DFS）结合剪枝的方法来解决问题。

### 通用建议与扩展思路
- **思路要点**：使用深度优先搜索（DFS）遍历图，从顶点 $1$ 开始，每到达一个新的顶点就将路径数量加 $1$。为避免重复访问同一顶点，使用一个标记数组记录当前路径中已经访问过的顶点。当路径数量达到 $10^6$ 时，直接输出 $10^6$ 并结束程序。
- **优化技巧**：利用题目中答案取 $\min(K, 10^6)$ 的限制进行剪枝，避免不必要的搜索，从而降低时间复杂度。
- **可拓展之处**：对于类似的图论问题，如计算图中特定路径的数量、判断图中是否存在特定路径等，都可以考虑使用深度优先搜索或广度优先搜索，并结合剪枝技巧来优化算法。

### 重点代码及核心实现思想
```cpp
#include<bits/stdc++.h>
using namespace std;
const int limit = 1e6;
int n, m, ans;
bool vis[200005];
vector<int> G[200005];

void dfs(int x) {
    if (++ans == limit) {
        cout << limit;
        exit(0);
    }
    for (int i = 0; i < (int)G[x].size(); i++) {
        if (!vis[G[x][i]]) {
            vis[G[x][i]] = 1;
            dfs(G[x][i]);
            vis[G[x][i]] = 0;
        }
    }
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        G[x].push_back(y);
        G[y].push_back(x);
    }
    vis[1] = 1;
    dfs(1);
    cout << ans;
    return 0;
}
```
**核心实现思想**：
1. **建图**：使用邻接表存储图的边信息。
2. **DFS 遍历**：从顶点 $1$ 开始进行深度优先搜索，每到达一个新的顶点，路径数量加 $1$。
3. **剪枝**：当路径数量达到 $10^6$ 时，直接输出 $10^6$ 并结束程序。
4. **回溯**：在回溯时，将当前顶点的标记清除，以便后续可以再次访问该顶点。

### 推荐洛谷题目
1. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)：图的染色问题，可使用深度优先搜索解决。
2. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)：简单的图论搜索问题，可使用广度优先搜索或深度优先搜索解决。
3. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：经典的迷宫搜索问题，可使用深度优先搜索解决。

### 个人心得摘录与总结
- **Orange_qwq**：题目要看全，样例最好都手动模拟，避免看错题目要求或限制；题目看错别怕，也许是正解的第一步；考虑是否需要回溯；是否需要多想一步，代码是否完全正确，是否需要添加小优化；最好不要用 `vector` 存图，除了打 AT 比赛时可稍稍偷懒。
- **CarroT1212**：一定要读题，注意题目中的特殊条件，如本题中答案是 $\min(K, 10^6)$，这一条件可以帮助我们优化算法。 

---
处理用时：30.03秒
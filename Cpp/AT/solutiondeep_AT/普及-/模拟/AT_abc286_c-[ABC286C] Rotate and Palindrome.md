# 题目信息

# [ABC286C] Rotate and Palindrome

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc286/tasks/abc286_c

長さ $ N $ の文字列 $ S $ が与えられます。$ S_i\ (1\leq\ i\ \leq\ N) $ を $ S $ の左から $ i $ 番目の文字とします。

あなたは以下の $ 2 $ 種類の操作を好きな順番で $ 0 $ 回以上好きな回数行うことができます。

- $ A $ 円払う。 $ S $ の左端の文字を右端に移動する。すなわち、$ S_1S_2\ldots\ S_N $ を $ S_2\ldots\ S_NS_1 $ に変える。
- $ B $ 円払う。 $ 1 $ 以上 $ N $ 以下の整数 $ i $ を選び、 $ S_i $ を好きな英小文字で置き換える。
 
$ S $ を回文にするためには最低で何円必要ですか？

 回文とは ある文字列 $ T $ について、 $ T $ の長さを $ |T| $ として、全ての整数 $ i $ ($ 1\ \le\ i\ \le\ |T| $) について、 $ T $ の前から $ i $ 文字目と後ろから $ i $ 文字目が同じであるとき、またそのときに限って、 $ T $ は回文です。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 5000 $
- $ 1\leq\ A,B\leq\ 10^9 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
- $ S $ 以外の入力は全て整数
 
### Sample Explanation 1

最初に $ 2 $ 番目の操作を $ 1 $ 回行います。$ 2 $ 円払い、$ i=5 $ として $ S_5 $ を `e` で置き換えます。 $ S $ は `rrefe` となります。 次に $ 1 $ 番目の操作を $ 1 $ 回行います。$ 1 $ 円払い、$ S $ は `refer` となります。これは回文です。 よって $ 3 $ 円払うことで $ S $ を回文にすることができました。 $ 2 $ 円以下払うことで $ S $ を回文にすることは不可能なので、これが答えです。

### Sample Explanation 2

答えは $ 32 $ bit 整数に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
5 1 2

rrefa```

### 输出

```
3```

## 样例 #2

### 输入

```
8 1000000000 1000000000

bcdfcgaa```

### 输出

```
4000000000```

# AI分析结果

### 题目翻译
给定一个长度为 $N$ 的字符串 $S$。设 $S_i\ (1\leq\ i\ \leq\ N)$ 为字符串 $S$ 从左往右数的第 $i$ 个字符。

你可以按任意顺序进行以下两种操作任意次数（包括 0 次）：
- 花费 $A$ 日元，将 $S$ 最左端的字符移到最右端。即把 $S_1S_2\ldots\ S_N$ 变为 $S_2\ldots\ S_NS_1$。
- 花费 $B$ 日元，选择一个 $1$ 到 $N$ 之间的整数 $i$，将 $S_i$ 替换为任意小写英文字母。

要使 $S$ 变成回文串，最少需要花费多少日元？

回文串的定义为：对于某个字符串 $T$，设其长度为 $|T|$，当且仅当对于所有整数 $i$（$1\ \le\ i\ \le\ |T|$），$T$ 从前往后数的第 $i$ 个字符和从后往前数的第 $i$ 个字符都相同时，$T$ 为回文串。

### 综合分析与结论
这些题解的核心思路都是通过枚举操作 1（将字符串左端字符移到右端）的次数，再计算每次操作后使字符串成为回文串所需操作 2（替换任意字符）的次数，从而得到总花费，最后取最小值。

- **思路**：由于操作 1 最多进行 $n - 1$ 次（进行 $n$ 次会回到原字符串），所以枚举操作 1 的次数，对于每次枚举，计算使当前字符串成为回文串需要操作 2 的次数，累加两种操作的花费，更新最小花费。
- **算法要点**：
    - 枚举操作 1 的次数，范围是 $0$ 到 $n - 1$。
    - 对于每次枚举，判断当前字符串是否为回文串，统计需要修改的字符数量，计算操作 2 的花费。
    - 累加操作 1 和操作 2 的花费，更新最小花费。
- **解决难点**：
    - 如何高效地模拟操作 1：部分题解通过将字符串复制一份接在原字符串后面，截取长度为 $n$ 的子串来模拟操作 1，避免了频繁移动字符的操作。
    - 如何判断字符串是否为回文串：通过双指针法，从字符串两端向中间遍历，比较对应位置的字符是否相同。

### 所选题解
- **作者：_xEr_（5星）**
    - **关键亮点**：思路清晰，通过图文结合的方式解释了如何通过复制字符串来模拟操作 1，代码简洁易懂。
    - **核心代码**：
```cpp
#include<iostream>
using namespace std;
long long n,a,b;
unsigned long long ans=1e35,now;
string s;
int main(){
    cin>>n>>a>>b>>s;
    s=s+s; // 复制并连接
    for(int i=0;i<n;i++){
        int l=i,r=i+n-1; // 分别从左右扫来检查对称
        now=i*a;
        for(;l<r;l++,r--)
            now+=b*(s[l]!=s[r]); // 记录代价
        ans=ans>now?now:ans; // 更新最小值
    }
    cout<<ans;
}
```
核心实现思想：先将字符串复制一份接在后面，然后枚举操作 1 的次数 $i$，对于每次枚举，从 $i$ 开始截取长度为 $n$ 的子串，使用双指针法判断该子串是否为回文串，统计需要修改的字符数量，计算总花费，更新最小花费。

- **作者：makerlife（4星）**
    - **关键亮点**：详细解释了思路和代码实现，包括如何模拟操作 1 和判断回文串，还给出了一些小细节的提示。
    - **核心代码**：
```cpp
#include<cstdio>
#include<string>
#include<iostream>
#define INF 1ll<<62
#define ll long long
#define int ll
using namespace std;
int n,a,b;
int ans=INF;
string s;
signed main()
{
    scanf("%lld%lld%lld",&n,&a,&b);
    cin>>s;
    s+=s;
    for(int i=0;i<n;i++)
    {
        int t=a*i;
        for(int j=0;j<n/2;j++)
        {
            int x=i+j;
            int y=n+i-1-j;
            if(s[x]!=s[y])
            {
                t+=b;
            }
        }
        ans=min(ans,t);
    }
    printf("%lld\n",ans);
    return 0;
}
```
核心实现思想：同样是先复制字符串，然后枚举操作 1 的次数，对于每次枚举，使用双指针法判断子串是否为回文串，统计需要修改的字符数量，计算总花费，更新最小花费。

- **作者：qinmingze（4星）**
    - **关键亮点**：思路清晰，代码简洁，详细解释了如何通过将字符串构成一个环来方便操作，以及如何更新答案。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n, a, b;
    string s;
    cin >> n >> a >> b >> s;
    s += s; // 构成一个环，方便操作
    long long ans = 1e18; // 保存答案
    for(int i = 0; i < n; i++){ // n次第一个操作
        long long sum = a * i; // 第一个操作花费的钱
        for(int j = 0; j < n / 2; j++){ // 2号操作
            int l = i + j;
            int r = i + n - 1 - j;
            if(s[l] != s[r]) sum += b; // 如果两个字符不一样，增加钱数
        }
        ans = min(ans, sum); // 更新答案
    }
    cout << ans << endl;
    return 0;
}
```
核心实现思想：将字符串复制一份接在后面，枚举操作 1 的次数，对于每次枚举，使用双指针法判断子串是否为回文串，统计需要修改的字符数量，计算总花费，更新最小花费。

### 最优关键思路或技巧
- **字符串复制**：将字符串复制一份接在原字符串后面，通过截取长度为 $n$ 的子串来模拟操作 1，避免了频繁移动字符的操作，提高了效率。
- **双指针法**：使用双指针法从字符串两端向中间遍历，比较对应位置的字符是否相同，判断字符串是否为回文串，时间复杂度为 $O(n)$。

### 可拓展之处
同类型题目可能会有更多的操作类型或限制条件，例如增加操作的种类、限制操作的次数等。类似的算法套路包括枚举所有可能的操作组合，然后计算每种组合的代价，取最小值。

### 推荐题目
1. [P1015 回文数](https://www.luogu.com.cn/problem/P1015)：判断一个数是否为回文数，并进行特定操作使其成为回文数。
2. [P1309 瑞士轮](https://www.luogu.com.cn/problem/P1309)：模拟比赛过程，涉及排序和操作的选择。
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：通过合并操作使果子数量达到最优，需要考虑操作的顺序和代价。

### 个人心得
部分题解提到了需要注意开 `long long` 以避免数据溢出，以及要考虑操作次数的范围，避免不必要的计算。这些都是在解题过程中需要注意的细节。

---
处理用时：53.58秒
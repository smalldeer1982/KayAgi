# 题目信息

# [ABC314C] Rotate Colored Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc314/tasks/abc314_c

英小文字からなる長さ $ N $ の文字列 $ S $ が与えられます。 $ S $ の各文字は色 $ 1 $ 、色 $ 2 $ 、$ \ldots $ 、色 $ M $ の $ M $ 色のうちのいずれかで塗られており、 $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、$ S $ の $ i $ 文字目は色 $ C_i $ で塗られています。

各 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、この順番に下記の操作を行います。

- $ S $ の色 $ i $ で塗られた文字からなる部分を、右に $ 1 $ つ巡回シフトする。 すなわち、$ S $ の 色 $ i $ で塗られた文字の位置が先頭のものから順に $ p_1,\ p_2,\ p_3,\ \ldots,\ p_k $ 文字目であるとき、 $ S $ の $ p_1,\ p_2,\ p_3,\ \ldots,\ p_k $ 文字目を、それぞれ、$ S $ の $ p_k,\ p_1,p_2,\ \ldots,\ p_{k-1} $ 文字目で同時に置き換える。

上記の操作をすべて行った後の、最終的な $ S $ を出力してください。

なお、$ M $ 色あるどの色についても、その色で塗られた $ S $ の文字が必ず $ 1 $ つ以上存在することが、制約として保証されます。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ C_i\ \leq\ M $
- $ N,\ M,\ C_i $ はすべて整数
- $ S $ は英小文字からなる長さ $ N $ の文字列
- 任意の整数 $ 1\ \leq\ i\ \leq\ M $ に対して、ある整数 $ 1\ \leq\ j\ \leq\ N $ が存在して $ C_j\ =\ i $ が成り立つ

### Sample Explanation 1

はじめ、$ S\ = $ `apzbqrcs` です。 - $ i\ =\ 1 $ に対する操作では、$ S $ の $ 1,\ 4,\ 7 $ 文字目からなる部分を右に $ 1 $ つ巡回シフトします。その結果、$ S\ = $ `cpzaqrbs` となります。 - $ i\ =\ 2 $ に対する操作では、$ S $ の $ 2,\ 5,\ 6,\ 8 $ 文字目からなる部分を右に $ 1 $ つ巡回シフトします。その結果、$ S\ = $ `cszapqbr` となります。 - $ i\ =\ 3 $ に対する操作では、$ S $ の $ 3 $ 文字目からなる部分を右に $ 1 $ つ巡回シフトします。その結果、$ S\ = $ `cszapqbr` となります（操作の前後で $ S $ は変わりません）。 よって、最終的な $ S $ である `cszapqbr` を出力します。

## 样例 #1

### 输入

```
8 3
apzbqrcs
1 2 3 1 2 2 1 2```

### 输出

```
cszapqbr```

## 样例 #2

### 输入

```
2 1
aa
1 1```

### 输出

```
aa```

# AI分析结果

### 题目内容中文重写
给定一个由小写英文字母组成的长度为 $N$ 的字符串 $S$。$S$ 的每个字符都被涂上了 $M$ 种颜色（颜色编号为 $1$、$2$、$\ldots$、$M$）中的某一种，对于 $i = 1, 2, \ldots, N$，字符串 $S$ 的第 $i$ 个字符被涂成了颜色 $C_i$。

对于每个 $i = 1, 2, \ldots, M$，按以下顺序执行操作：
- 将 $S$ 中被涂成颜色 $i$ 的字符组成的部分向右循环移动一位。即，若 $S$ 中被涂成颜色 $i$ 的字符的位置按顺序依次为第 $p_1$、$p_2$、$p_3$、$\ldots$、$p_k$ 个字符，那么将 $S$ 的第 $p_1$、$p_2$、$p_3$、$\ldots$、$p_k$ 个字符分别同时替换为 $S$ 的第 $p_k$、$p_1$、$p_2$、$\ldots$、$p_{k - 1}$ 个字符。

请输出执行完上述所有操作后的最终字符串 $S$。

需要注意的是，作为约束条件，保证 $M$ 种颜色中的任意一种颜色，都至少有一个 $S$ 中的字符被涂成该颜色。

### 综合分析与结论
- **思路对比**：
    - **AC_love**：记录每个位置的字符是从哪里转移来的，通过桶数组记录每个颜色最后一次出现的位置，最后处理每个颜色第一项与最后一项的匹配。
    - **Failure_Terminator**：将每个颜色的位置编号存到对应的 `vector` 里，遍历每种颜色进行操作，操作时先保存最后一个编号上对应的数并逆序操作。
    - **LegendaryGrandmaster**：用 `map` 记录与其权值相同的上一个字符的位置，对于每个权值第一次出现的字符，存放与其相同权值的最后一个字符。
    - **tbdsh**：用 `std::vector` 存储每个颜色对应的下标，对每个颜色扫一遍 `vector` 进行变换。
    - **Crazyouth**：定义数组 `nxt` 表示下一个与当前字符颜色相同的字符的下标，用 `last` 数组辅助维护 `nxt` 数组，对每个未访问过的字符进行推进操作。
- **算法要点对比**：
    - **AC_love**：桶数组的使用，时间复杂度 $O(n)$。
    - **Failure_Terminator**：`vector` 存储位置编号，逆序操作，时间复杂度 $\Theta(n)$。
    - **LegendaryGrandmaster**：`map` 记录位置，时间复杂度 $O(n)$。
    - **tbdsh**：`vector` 存储下标，遍历变换，时间复杂度 $O(n)$。
    - **Crazyouth**：`nxt` 和 `last` 数组维护，时间复杂度 $O(n)$。
- **解决难点对比**：
    - **AC_love**：处理每个颜色的第一项与最后一项的匹配。
    - **Failure_Terminator**：操作时避免元素被覆盖。
    - **LegendaryGrandmaster**：处理每个权值第一次出现的字符的位置。
    - **tbdsh**：无明显难点。
    - **Crazyouth**：维护 `nxt` 数组。

### 所选题解
- **AC_love（4星）**：
    - **关键亮点**：思路清晰，通过桶数组巧妙记录每个颜色最后一次出现的位置，避免了暴力算法的 $O(n^2)$ 复杂度。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; i = i + 1)
{
    cin >> c[i];
    if(tong[c[i]] != 0)
        lst[i] = tong[c[i]];
    tong[c[i]] = i;
}
for(int i = 1; i <= n; i = i + 1)
{
    if(lst[i] == 0)
        lst[i] = tong[c[i]];
    ans[i] = ch[lst[i]];
}
```
- **Failure_Terminator（4星）**：
    - **关键亮点**：使用 `vector` 存储每个颜色的位置编号，逆序操作避免元素被覆盖，时间复杂度低。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i ++)
    g[a[i]].push_back(i);
for (int i = 1; i <= m; i ++)
    if (g[i].size()){
        char p = s[g[i][g[i].size() - 1]];
        for (int j = g[i].size() - 2; j >= 0; j --)
            s[g[i][j + 1]] = s[g[i][j]];
        s[g[i][0]] = p;
    } 
```
- **tbdsh（4星）**：
    - **关键亮点**：同样使用 `vector` 存储下标，代码简洁，时间复杂度为 $O(n)$。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i++){
    cin >> a[i];
    b[a[i]].push_back(i);
}
for (int i = 1; i <= m; i++){
    char p = s[b[i][b[i].size() - 1]];
    for (int j = b[i].size() - 1; j >= 1; j--){
        s[b[i][j]] = s[b[i][j - 1]];
    }
    s[b[i][0]] = p;
}
```

### 最优关键思路或技巧
- 使用桶数组、`vector` 或 `map` 来记录每个颜色的相关信息，避免暴力算法的高复杂度。
- 逆序操作可以避免元素被覆盖。

### 可拓展之处
同类型题可能会有更多的操作限制或条件，例如多次循环移动、不同的移动规则等。类似算法套路可以用于处理需要对不同分组进行操作的问题，通过记录分组信息来高效处理。

### 推荐洛谷题目
- [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)
- [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)
- [P2670 扫雷游戏](https://www.luogu.com.cn/problem/P2670)

### 个人心得摘录与总结
无。

---
处理用时：40.38秒
# 题目信息

# [ABC318C] Blue Spring

## 题目描述

**题意简述**

高桥君要进行 $N$ 天的旅行，第 $i$ 天的费用为 $A_i$ 。他还可以使用优惠券，可以免除 $D$ 天的费用，价格为 $P$。如果剩余 $2$ 天，优惠券的作用是 $3$ 天，那么依然可以使用。

求这 $N$ 天旅行的最小费用。

## 说明/提示

- $1 \le N \le 2 \times 10^5$
- $1 \le D \le 2 \times 10^5$
- $1 \le P \le 10^9$
- $1 \le F_i \le 10^9$

**样例一解释**

使用一张优惠券免除 $1,3$ 天的费用，总费用为 $1+3+6+10=20$。

**样例三解释**

使用 $3$ 张优惠券，费用为 $3 \times 1000000000=3000000000$

## 样例 #1

### 输入

```
5 2 10
7 1 6 3 6```

### 输出

```
20```

## 样例 #2

### 输入

```
3 1 10
1 2 3```

### 输出

```
6```

## 样例 #3

### 输入

```
8 3 1000000000
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
3000000000```

# AI分析结果

### 题目翻译
高桥君要进行 $N$ 天的旅行，第 $i$ 天的费用为 $A_i$ 。他还可以使用优惠券，一张优惠券可以免除 $D$ 天的费用，价格为 $P$。如果剩余天数不足 $D$ 天，优惠券依然可以使用。

求这 $N$ 天旅行的最小费用。

### 综合分析与结论
这些题解大多采用贪心算法解决问题，核心思路是先将每天的费用从大到小排序，然后按每 $D$ 天一组进行判断，若这 $D$ 天的费用总和大于 $P$，则使用优惠券，否则正常支付。各题解在具体实现上略有不同，有的使用前缀和优化求和过程，有的直接累加判断。

### 所选题解
- **作者：robertuu (赞：4)，4星**
    - **关键亮点**：思路清晰，代码简洁，直接按每 $D$ 天一组累加费用并与 $P$ 比较，最后处理剩余天数，容易理解。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200001];
int main()
{
    int n,d;
    long long p;
    scanf("%d%d%d",&n,&d,&p);
    for(int i = 1;i <= n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+1+n,greater<int>()); // 给金额排序
    long long ans = 0,cnt = 0;
    for(int i = 1;i <= n;i++)
    {
        cnt += a[i]; // 统计连续d天的金额和
        if(i % d == 0)
        {
            ans += min(cnt,p); // 券和单买取较小值
            cnt = 0;
        }
    }
    ans += min(cnt,p); // 最后不满d天的也要统计！！
    printf("%lld\n",ans);
    return 0;
}
```
- **作者：Submerge_TA (赞：4)，4星**
    - **关键亮点**：同样是贪心思路，代码结构清晰，通过循环分组判断是否使用优惠券，逻辑明确。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,d,p,m,a[214514],s,st;
bool cmp(const int &x,const int &y) {
    return x>y;
}
int main() {
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>d>>p;
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n,cmp);
    int i=0;
    while(i<n) {
        st=0;
        for(int j=i;j<i+d&&j<n;j++) st+=a[j];
        i+=d;
        if(st<=p) s+=st;
        else s+=p; 
    }
    cout<<s;
    return 0;
}
```
- **作者：lrx___ (赞：3)，4星**
    - **关键亮点**：使用前缀和优化求和过程，在处理区间费用时更加高效，同时注意到了最后剩余天数的特殊情况。
    - **核心代码**：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef unsigned long long ll;
const int N=4e5+5;
ll a[N];
bool cmp(int x,int y){
    return x>y;
}
int main(){
    int n,d,i;
    ll s=0,p;
    scanf("%d%d%llu",&n,&d,&p);
    for(i=1;i<=n;i++){
        scanf("%llu",&a[i]);
    }
    sort(a+1,a+n+1,cmp);
    for(i=1;i<=n+d;i++){
        a[i]+=a[i-1];
    }
    for(i=d;i-d<=n;i+=d){
        s+=min(a[i]-a[i-d],p);
    }
    printf("%llu\n",s);
    return 0;
}
```

### 最优关键思路或技巧
- **贪心策略**：将每天的费用从大到小排序，优先使用优惠券抵消费用高的天数，保证每次使用优惠券都能最大程度地节省费用。
- **前缀和优化**：通过计算前缀和，可以在 $O(1)$ 时间内得到任意区间的费用总和，提高算法效率。

### 可拓展之处
同类型题可能会有更多的限制条件，如优惠券的使用有时间限制、不同类型的优惠券等。解题思路依然可以从贪心的角度出发，根据具体条件进行调整。类似算法套路还包括区间贪心、活动选择问题等。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法，每次选择最小的两个元素合并。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：贪心策略为按照接水时间从小到大排序，使总等待时间最短。
- [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：根据物品的单位价值进行排序，优先选择单位价值高的物品。

### 个人心得摘录与总结
- **作者：so_find_skind**：最初的代码没有考虑到最后剩余天数的情况，导致无法通过最后一个样例。总结是在处理此类问题时，要特别注意边界条件，确保算法的完整性。 

---
处理用时：39.46秒
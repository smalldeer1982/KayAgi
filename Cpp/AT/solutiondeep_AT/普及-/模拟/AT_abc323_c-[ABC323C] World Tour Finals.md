# 题目信息

# [ABC323C] World Tour Finals

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_c

$ N $ 人のプレイヤーが参加するプログラミングコンテスト World Tour Finals が行われており、競技時間の半分が過ぎました。 このコンテストでは $ M $ 問の問題が出題されており、問題 $ i $ の点数 $ A_i $ は $ 500 $ 以上 $ 2500 $ 以下の $ 100 $ の倍数です。

各 $ i\ =\ 1,\ \ldots,\ N $ について、プレイヤー $ i $ がどの問題を既に解いたかを表す文字列 $ S_i $ が与えられます。 $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列で、$ S_i $ の $ j $ 文字目が `o` のときプレイヤー $ i $ は問題 $ j $ を既に解いており、`x` のときまだ解いていません。 ただし、どのプレイヤーもまだ全ての問題を解いてはいません。

プレイヤー $ i $ の総合得点は、解いた問題の点数の合計に、**ボーナス点** $ i $ 点を加えた点数として計算されます。  
さて、各 $ i\ =\ 1,\ \ldots,\ N $ について以下の質問に答えてください。

- プレイヤー $ i $ がまだ解いていない問題を少なくとも何問解くことで、プレイヤー $ i $ の総合得点が他のプレイヤー全員の現在の総合得点を上回ることができますか？

なお、問題文中の条件と制約から、プレイヤー $ i $ が全ての問題を解くことで、他のプレイヤー全員の現在の総合得点を上回ることができることが証明できます。 このことから、答えは常に定義されることに注意してください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 100 $
- $ 1\leq\ M\leq\ 100 $
- $ 500\leq\ A_i\leq\ 2500 $
- $ A_i $ は $ 100 $ の倍数
- $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列
- $ S_i $ には `x` が一個以上含まれる
- 入力される数値は全て整数

### Sample Explanation 1

競技時間の半分の経過時の各プレイヤーの総合得点は、プレイヤー $ 1 $ が $ 2001 $ 点、プレイヤー $ 2 $ が $ 1502 $ 点、プレイヤー $ 3 $ が $ 1703 $ 点です。 プレイヤー $ 1 $ は $ 1 $ 問も解かずとも、他のプレイヤー全員の総合得点を上回っています。 プレイヤー $ 2 $ は、例えば問題 $ 4 $ を解けば総合得点が $ 3502 $ 点となり、他のプレイヤー全員の総合得点を上回ります。 プレイヤー $ 3 $ も、例えば問題 $ 4 $ を解けば総合得点が $ 3703 $ 点となり、他のプレイヤー全員の総合得点を上回ります。

## 样例 #1

### 输入

```
3 4
1000 500 700 2000
xxxo
ooxx
oxox```

### 输出

```
0
1
1```

## 样例 #2

### 输入

```
5 5
1000 1500 2000 2000 2500
xxxxx
oxxxx
xxxxx
oxxxx
oxxxx```

### 输出

```
1
1
1
1
0```

## 样例 #3

### 输入

```
7 8
500 500 500 500 500 500 500 500
xxxxxxxx
oxxxxxxx
ooxxxxxx
oooxxxxx
ooooxxxx
oooooxxx
ooooooxx```

### 输出

```
7
6
5
4
3
2
0```

# AI分析结果

### 题目翻译
有 $N$ 名选手参加编程竞赛 World Tour Finals，比赛时间已经过了一半。这场竞赛共有 $M$ 道题目，题目 $i$ 的分值 $A_i$ 是 $500$ 到 $2500$ 之间的 $100$ 的倍数。

对于每个 $i = 1, \ldots, N$，会给出表示选手 $i$ 已解决哪些题目的字符串 $S_i$。$S_i$ 是由 `o` 和 `x` 组成的长度为 $M$ 的字符串，当 $S_i$ 的第 $j$ 个字符为 `o` 时，表示选手 $i$ 已经解决了题目 $j$；当为 `x` 时，表示尚未解决。不过，没有选手解决了所有题目。

选手 $i$ 的总得分是已解决题目的分值总和加上**奖励分** $i$ 分。

现在，对于每个 $i = 1, \ldots, N$，请回答以下问题：

- 选手 $i$ 至少要解决多少道尚未解决的题目，才能使自己的总得分超过其他所有选手当前的总得分？

根据题目中的条件和约束，可以证明选手 $i$ 解决所有题目后，能够超过其他所有选手当前的总得分。因此，请注意答案总是有定义的。

### 综合分析与结论
这些题解的核心思路都是贪心算法，先计算出每个选手当前的总得分，找到最高分，然后对于每个选手，贪心选择未做过的题目中分值最高的题目，直到其总得分超过当前最高分。

| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| A_R_O_N_A | 先对选手按分数排序找出最高分，再对题目按分值排序，依次选取未做过的题目直到超过最高分；优化后直接在线求最大值，去掉对选手排序的步骤 | 结构体存储选手和题目信息，排序 | 选手和题目信息的管理，排序的优化 | 4星 |
| 没见过AC | 计算每个选手当前得分，记录最高分和第一名编号，对于每个选手，将做过的题分数置为0，贪心选择分数最高的未做过的题 | 数组存储题目分数，处理做过的题 | 做过的题分数的处理 | 3星 |
| 无钩七不改名 | 记录分数最大值和最大值的人数，若当前为最大值且人数为1则无需多做题，否则贪心选取未做过的题目 | 结构体存储题目信息，排序 | 最大值人数的处理 | 3星 |
| hellolin | 计算每个选手当前得分，找到最大值，对于非最大值的选手，贪心选择未做过的题目中分值高的题目 | 数组存储题目分数，排序 | 已做过题目的筛选 | 3星 |
| xiaomuyun | 计算每个选手当前得分，对于每个选手，计算至少需要的分数，对题目按分值排序，贪心选择分数高的未做过的题 | 结构体存储题目信息，排序 | 至少需要分数的计算 | 3星 |

### 所选题解
- **A_R_O_N_A（4星）**
    - **关键亮点**：思路清晰，对选手排序的优化减少了时间复杂度，使用结构体存储选手和题目信息，代码结构清晰。
    - **核心代码**：
```cpp
struct node{
    int sum,num;//选手分数，编号
    string s;
};
struct problem{
    int point;//分值
    map<int,bool>mp; //储存选手是否已经通过此题
}pro[105];
node a[105];
int n,m,maxx=-1;
bool cmp(problem x,problem y){
    return x.point>y.point;
}//排序题目分值
int main(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
        pro[i].point=read();
    }//输入
    for(int i=1;i<=n;i++){
        cin>>a[i].s;
        a[i].num=i;
        a[i].sum=i;//初始分
        for(int j=0;j<a[i].s.size();j++){
            if(a[i].s[j]=='o'){
                a[i].sum+=pro[j+1].point;
                pro[j+1].mp[a[i].num]=true;
            }//累加分数，标记已经通过此题
        }
        maxx=max(maxx,a[i].sum);//直接在线求出最大值
    }
    sort(pro+1,pro+1+m,cmp);//对题目排序
    for(int i=1;i<=n;i++){//循环从一开始
        if(a[i].sum==maxx){//如果该选手已经是最大值，那么输出 0 并且跳过
        	puts("0");
			continue;
		}
		int anss=0;//储存需要通过的题目数
        for(int j=1;j<=m;j++){//选取题目
            if(a[i].sum>maxx)break;//如果超过，退出
            if(pro[j].mp[a[i].num]==false){//如果没有做过此题，选取
                a[i].sum+=pro[j].point;
                anss++;//累加题目数
            }
        }
        write(anss);//输出
        puts("");
    }
    return 0;
}
```
核心实现思想：使用结构体 `node` 存储选手信息，`problem` 存储题目信息。先输入题目分值和选手做题情况，计算每个选手的当前得分并找出最大值。对题目按分值从大到小排序，对于每个选手，如果其得分不是最大值，则贪心选择未做过的题目中分值最高的题目，直到其得分超过最大值。

### 最优关键思路或技巧
- **贪心策略**：为了使选手需要做的题目数量最少，每次都选择未做过的题目中分值最高的题目。
- **排序优化**：对题目按分值排序，方便快速选择分值高的题目；A_R_O_N_A 的题解中直接在线求最大值，去掉对选手排序的步骤，减少了时间复杂度。

### 可拓展之处
同类型题目可能会改变题目分值的范围、选手的奖励分规则或者题目数量等。类似的算法套路是贪心算法，在其他题目中可能会遇到需要在多个选择中选择最优解的情况，都可以考虑使用贪心策略。

### 洛谷题目推荐
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：通过贪心策略安排排队顺序，使总等待时间最短。
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)：使用贪心算法对物品进行分组，使分组数量最少。
3. [P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)：通过贪心策略选择物品，使背包中物品的总价值最大。

### 个人心得
题解中未包含个人心得。

---
处理用时：49.82秒
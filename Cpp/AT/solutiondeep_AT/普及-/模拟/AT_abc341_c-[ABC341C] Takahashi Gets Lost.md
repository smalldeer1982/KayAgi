# 题目信息

# [ABC341C] Takahashi Gets Lost

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc341/tasks/abc341_c

$ H $ 行 $ W $ 列のグリッドがあります。

グリッドの各マスは**陸**か**海**のどちらかであり、 その情報は $ H $ 個の長さ $ W $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_H $ で与えられます。 上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ で表すと、 $ S_i $ の $ j $ 文字目が `.` のときマス $ (i,\ j) $ は陸であり、`#` のときマス $ (i,\ j) $ は海です。

ここで、グリッドの外周のマス（すなわち、$ i\ =\ 1 $ 、$ i\ =\ H $ 、$ j\ =\ 1 $ 、$ j\ =\ W $ のうち少なくとも $ 1 $ 個以上を満たすマス $ (i,\ j) $ ）については、すべて海であることが制約として保証されます。

高橋君が乗った宇宙船が、グリッド上のあるマスに不時着してしまいました。 その後、高橋君は `L` 、`R` 、`U` 、`D` のみからなる長さ $ N $ の文字列 $ T $ で表される手順に沿って、グリッド上を $ N $ 回移動しました。 $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、$ T $ の $ i $ 文字目は $ i $ 回目の移動の内容を下記の通り表します。

- `L` のとき、左に $ 1 $ マス移動したことを表す。すなわち、移動前のマスを $ (i,\ j) $ とするとき、移動後のマスは $ (i,\ j-1) $ である。
- `R` のとき、右に $ 1 $ マス移動したことを表す。すなわち、移動前のマスを $ (i,\ j) $ とするとき、移動後のマスは $ (i,\ j+1) $ である。
- `U` のとき、上に $ 1 $ マス移動したことを表す。すなわち、移動前のマスを $ (i,\ j) $ とするとき、移動後のマスは $ (i-1,\ j) $ である。
- `D` のとき、下に $ 1 $ マス移動したことを表す。すなわち、移動前のマスを $ (i,\ j) $ とするとき、移動後のマスは $ (i+1,\ j) $ である。

高橋君の移動経路上のマス（不時着したマスおよび現在いるマスを含む）はいずれも海でないことがわかっています。 高橋君が現在いるマスとしてあり得るものの個数を出力してください。

## 说明/提示

### 制約

- $ H,\ W,\ N $ は整数
- $ 3\ \leq\ H,\ W\ \leq\ 500 $
- $ 1\ \leq\ N\ \leq\ 500 $
- $ T $ は `L` 、`R` 、`U` 、`D` のみからなる長さ $ N $ の文字列
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列
- 高橋君が現在いるマスとしてあり得るものが少なくとも $ 1 $ 個存在する。
- グリッドの外周のマスはすべて海である。

### Sample Explanation 1

下記の $ 2 $ つの場合がありえるため、高橋君が現在いるマスとしてあり得るものは $ (3,\ 4) $ と $ (4,\ 5) $ の $ 2 $ 個です。 - マス $ (3,\ 5) $ に不時着し、$ (3,\ 5)\ \rightarrow\ (3,\ 4)\ \rightarrow\ (2,\ 4)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3)\ \rightarrow\ (3,\ 4) $ と移動した場合 - マス $ (4,\ 6) $ に不時着し、$ (4,\ 6)\ \rightarrow\ (4,\ 5)\ \rightarrow\ (3,\ 5)\ \rightarrow\ (3,\ 4)\ \rightarrow\ (4,\ 4)\ \rightarrow\ (4,\ 5) $ と移動した場合

## 样例 #1

### 输入

```
6 7 5
LULDR
#######
#...#.#
##...##
#.#...#
#...#.#
#######```

### 输出

```
2```

## 样例 #2

### 输入

```
13 16 9
ULURDLURD
################
##..##.#..####.#
###.#..#.....#.#
#..##..#####.###
#...#..#......##
###.##.#..#....#
##.#####....##.#
###.###.#.#.#..#
######.....##..#
#...#.#.######.#
##..###..#..#.##
#...#.#.#...#..#
################```

### 输出

```
6```

# AI分析结果

### 题目中文重写
# [ABC341C] 高桥迷路了

## 题目描述
[problemUrl]: https://atcoder.jp/contests/abc341/tasks/abc341_c

有一个 $H$ 行 $W$ 列的网格。

网格的每个格子要么是**陆地**，要么是**海洋**，其信息由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 给出。用 $(i, j)$ 表示从上往下第 $i$ 行、从左往右第 $j$ 列的格子，当 $S_i$ 的第 $j$ 个字符为 `.` 时，格子 $(i, j)$ 是陆地；当为 `#` 时，格子 $(i, j)$ 是海洋。

这里，网格的外围格子（即满足 $i = 1$、$i = H$、$j = 1$、$j = W$ 中至少一个条件的格子 $(i, j)$）保证都是海洋。

高桥乘坐的宇宙飞船在网格上的某个格子意外降落了。之后，高桥按照仅由 `L`、`R`、`U`、`D` 组成的长度为 $N$ 的字符串 $T$ 所表示的步骤，在网格上移动了 $N$ 次。对于 $i = 1, 2, \ldots, N$，$T$ 的第 $i$ 个字符表示第 $i$ 次移动的内容，具体如下：
- 当为 `L` 时，表示向左移动 $1$ 格。即若移动前的格子为 $(i, j)$，则移动后的格子为 $(i, j - 1)$。
- 当为 `R` 时，表示向右移动 $1$ 格。即若移动前的格子为 $(i, j)$，则移动后的格子为 $(i, j + 1)$。
- 当为 `U` 时，表示向上移动 $1$ 格。即若移动前的格子为 $(i, j)$，则移动后的格子为 $(i - 1, j)$。
- 当为 `D` 时，表示向下移动 $1$ 格。即若移动前的格子为 $(i, j)$，则移动后的格子为 $(i + 1, j)$。

已知高桥移动路径上的格子（包括意外降落的格子和当前所在的格子）都不是海洋。请输出高桥当前可能所在的格子的数量。

## 说明/提示
### 限制条件
- $H$、$W$、$N$ 为整数。
- $3 \leq H, W \leq 500$。
- $1 \leq N \leq 500$。
- $T$ 是仅由 `L`、`R`、`U`、`D` 组成的长度为 $N$ 的字符串。
- $S_i$ 是仅由 `.` 和 `#` 组成的长度为 $W$ 的字符串。
- 高桥当前可能所在的格子至少有 $1$ 个。
- 网格的外围格子都是海洋。

### 样例解释 1
由于存在以下两种可能的情况，所以高桥当前可能所在的格子为 $(3, 4)$ 和 $(4, 5)$，共 $2$ 个：
- 在格子 $(3, 5)$ 降落，按 $(3, 5) \rightarrow (3, 4) \rightarrow (2, 4) \rightarrow (2, 3) \rightarrow (3, 3) \rightarrow (3, 4)$ 移动的情况。
- 在格子 $(4, 6)$ 降落，按 $(4, 6) \rightarrow (4, 5) \rightarrow (3, 5) \rightarrow (3, 4) \rightarrow (4, 4) \rightarrow (4, 5)$ 移动的情况。

## 样例 #1
### 输入
```
6 7 5
LULDR
#######
#...#.#
##...##
#.#...#
#...#.#
#######
```

### 输出
```
2
```

## 样例 #2
### 输入
```
13 16 9
ULURDLURD
################
##..##.#..####.#
###.#..#.....#.#
#..##..#####.###
#...#..#......##
###.##.#..#....#
##.#####....##.#
###.###.#.#.#..#
######.....##..#
#...#.#.######.#
##..###..#..#.##
#...#.#.#...#..#
################
```

### 输出
```
6
```

### 综合分析与结论
这些题解的核心思路都是基于数据范围较小（$H, W, N$ 最大为 500），采用暴力枚举的方法。大部分题解通过枚举网格中的每个陆地格子作为起点，按照给定的移动指令进行模拟移动，判断移动过程中是否会到达海洋或越界，如果不会，则该起点对应的终点是一个可能的位置，最后统计可能位置的数量。

其中，cjh20090318 的题解使用了动态规划的思想，通过状态转移方程 $f_{i,x,y}$ 表示执行完前 $i$ 个操作后位置 $(x,y)$ 能否作为终点，并且利用 `std::bitset` 优化常数。其他题解多为直接模拟，通过循环遍历指令并更新位置，同时检查合法性。

### 所选题解
- **作者：__Dist__ (5星)**
    - **关键亮点**：思路清晰，代码简洁明了，使用常见的输入输出优化，通过枚举起点并模拟移动过程，最后统计合法终点数量。
    - **核心代码**：
```cpp
for (int i = 1; i <= h; i++) {
    for (int j = 1; j <= w; j++) {
        if(ch[i][j] == '.') {
            int x = i, y = j;
            bool f = true;
            for (int k = 1; k <= n; k++) {
                if(s[k] == 'L') y--;
                else if(s[k] == 'R') y++;
                else if(s[k] == 'U') x--;
                else x++;
                if(x < 1 || x > h || y < 1 || y > w || ch[x][y] == '#') {
                    f = false;
                    break;
                }
            }
            res += f;
        }
    }
}
```
- **作者：cjh20090318 (5星)**
    - **关键亮点**：采用动态规划思想，状态设计和转移方程清晰，使用 `std::bitset` 优化常数，时间复杂度为 $O(HWN)$ 且常数较小。
    - **核心代码**：
```cpp
for(int i=0;i<k;i++){
    if(t[i]=='L'){
        for(int i=0;i<n;i++) b[i]=(b[i]>>1)&c[i];
    }
    else if(t[i]=='R'){
        for(int i=0;i<n;i++) b[i]=(b[i]<<1)&c[i];
    }
    else if(t[i]=='U'){
        for(int i=0;i<n-1;i++) b[i]=b[i+1]&c[i];
        b[n-1].reset();
    }
    else if(t[i]=='D'){
        for(int i=n-1;i>0;--i) b[i]=b[i-1]&c[i];
        b[0].reset();
    }
}
```
- **作者：endswitch (4星)**
    - **关键亮点**：思路明确，代码结构清晰，使用 `goto` 语句简化代码逻辑，时间复杂度为 $O(N^3)$。
    - **核心代码**：
```cpp
for(int i = 1 ; i <= H ; ++ i)
    for(int j = 1 ; j <= W ; ++ j)
        if(Map[i][j] == '.') {
            x = i, y = j;
            for(int k = 1 ; k <= n ; ++ k) {
                if(T[k] == 'L') -- y;
                else if(T[k] == 'R') ++ y;
                else if(T[k] == 'U') -- x;
                else ++ x;
                if(x > H || y > W || x < 1 || y < 1 || Map[x][y] == '#') goto Vegetableless;
            }
            ans++;
            Vegetableless:;
        }
```

### 最优关键思路或技巧
- **暴力枚举**：由于数据范围较小，直接枚举每个可能的起点，模拟移动过程，判断合法性，简单直接。
- **动态规划**：如 cjh20090318 的题解，通过状态设计和转移方程，利用 `std::bitset` 优化常数，提高效率。
- **输入输出优化**：部分题解使用 `getchar` 和 `putchar` 进行输入输出，减少 `cin` 和 `cout` 的开销。

### 拓展思路
同类型题可能会增加网格规模、移动规则复杂度或添加额外限制条件。可以考虑使用记忆化搜索、广度优先搜索等算法进行优化。类似算法套路包括模拟移动路径、状态转移和合法性判断等。

### 洛谷相似题目推荐
1. [P1420 最长连号](https://www.luogu.com.cn/problem/P1420)：考察数组遍历和连续元素判断。
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)：涉及枚举和组合数计算。
3. [P1217 [USACO1.5] 回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要枚举数字并判断质数和回文数。

### 个人心得摘录与总结
题解中未包含个人心得相关内容。

---
处理用时：45.70秒
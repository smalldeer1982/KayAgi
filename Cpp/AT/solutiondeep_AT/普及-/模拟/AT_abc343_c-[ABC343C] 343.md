# 题目信息

# [ABC343C] 343

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc343/tasks/abc343_c

正整数 $ N $ が与えられます。

$ N $ 以下の正整数であって回文立方数であるものの最大値を求めてください。

ただし、正整数 $ K $ は以下の $ 2 $ つの条件を満たすとき、またそのときに限り回文立方数であると定義します。

- ある正整数 $ x $ が存在し、$ x^3\ =\ K $ を満たす。
- $ K $ を先頭に $ 0 $ をつけずに $ 10 $ 進表記した文字列が回文となる。より厳密には、$ 0 $ 以上 $ 9 $ 以下の整数 $ A_0,\ A_1,\ \ldots,\ A_{L-2} $ および $ 1 $ 以上 $ 9 $ 以下の整数 $ A_{L-1} $ を用いて $ K\ =\ \sum_{i\ =\ 0}^{L-1}\ A_i10^i $ と表記したときに $ i\ =\ 0,\ 1,\ \ldots,\ L-1 $ に対して $ A_i\ =\ A_{L-1-i} $ を満たす。

## 说明/提示

### 制約

- $ N $ は $ 10^{18} $ 以下の正整数

### Sample Explanation 1

$ 343 $ は回文立方数であり、$ 344,\ 345 $ は回文立方数ではありません。したがって、$ 343 $ が答えとなります。

## 样例 #1

### 输入

```
345```

### 输出

```
343```

## 样例 #2

### 输入

```
6```

### 输出

```
1```

## 样例 #3

### 输入

```
123456789012345```

### 输出

```
1334996994331```

# AI分析结果

### 题目翻译
给定正整数 $N$。

请找出不超过 $N$ 的正整数中，且为回文立方数的最大数。

这里，正整数 $K$ 当且仅当满足以下两个条件时，被定义为回文立方数：
- 存在正整数 $x$，使得 $x^3 = K$。
- $K$ 不以 $0$ 开头的十进制表示字符串是回文串。更严格地说，当使用 $0$ 到 $9$ 的整数 $A_0, A_1, \ldots, A_{L - 2}$ 以及 $1$ 到 $9$ 的整数 $A_{L - 1}$ 表示为 $K = \sum_{i = 0}^{L - 1} A_i10^i$ 时，对于 $i = 0, 1, \ldots, L - 1$ 都有 $A_i = A_{L - 1 - i}$。

### 综合分析与结论
这些题解的核心思路都是通过枚举立方数，再判断其是否为回文数来找出不超过 $N$ 的最大回文立方数。由于 $N \leq 10^{18}$，其立方根最大为 $10^6$，所以枚举范围可控。

#### 思路对比
- **正向枚举**：多数题解从 $1$ 开始枚举到 $\sqrt[3]{N}$，不断更新最大的回文立方数。
- **反向枚举**：部分题解从 $\sqrt[3]{N}$ 开始倒序枚举到 $1$，找到的第一个满足条件的数即为最大的回文立方数。
- **二分查找**：有题解先通过二分求出 $\sqrt[3]{N}$，再进行枚举判断。
- **打表法**：有题解通过暴力模拟找出 $1$ 到 $10^{18}$ 之间的所有回文立方数，然后打表直接查找。

#### 算法要点
- **枚举**：枚举范围为 $1$ 到 $\sqrt[3]{N}$，计算每个数的立方。
- **回文判断**：将立方数转换为字符串，反转后与原字符串比较；或通过数位分离，首尾比较。

#### 解决难点
- **数据范围**：$N$ 最大为 $10^{18}$，直接枚举 $1$ 到 $N$ 会超时，通过枚举立方根将复杂度降低到 $O(\sqrt[3]{N})$。
- **精度问题**：部分题解使用 `cbrt` 函数求立方根，可能存在精度问题，有题解建议使用精度更高的 `cbrtl` 函数。

### 评分较高的题解
- **作者：Little_x_starTYJ（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接使用 `cbrt` 函数求出 $N$ 的立方根，然后反向枚举判断，找到满足条件的数即输出。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    unsigned long long n;
    cin >> n;
    for (unsigned long long i = cbrt(n) + 1; ; i--)
    {
        if (i * i * i > n)
            continue;
        string a = to_string(i * i * i);
        string b = a;
        reverse(a.begin(), a.end());
        if (a == b) {
            cout << i * i * i;
            return 0;
        }
    }
    cout << 1;
    return 0;
}
```
- **作者：littlesnake（4星）**
    - **关键亮点**：复杂度分析清晰，代码结构良好，封装了回文判断函数，逻辑清晰。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

bool check(ll n) {
    string s = to_string(n);
    string t = s;
    reverse(t.begin(), t.end());
    return s == t;
}

int main() {
    ll n;
    cin >> n;
    ll ans = 0;
    for (ll i = 1; i * i * i <= n; i++) if (check(i * i * i)) ans = i * i * i;
    cout << ans << '\n';
}
```
- **作者：XXh0919（4星）**
    - **关键亮点**：思路解释详细，对复杂度进行了分析，使用手动 O2 优化，代码可读性高。
    - **核心代码**：
```cpp
#pragma GCC optimize(2)//手动 O2
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,ans;

signed main() {
    scanf("%lld",&n);
    for(int i=1; i<=1000000; ++i) {
        int x=i*i*i;
        string s=to_string(x);
        string ss=s;
        reverse(ss.begin(),ss.end());
        if(s==ss&&x<=n)ans=max(ans,x);
    }
    printf("%lld\n",ans);
    return 0;
}
```

### 最优关键思路或技巧
- **枚举立方根**：通过枚举立方根将复杂度从 $O(N)$ 降低到 $O(\sqrt[3]{N})$，避免超时。
- **反向枚举**：从大到小枚举立方根，找到的第一个满足条件的数即为最大的回文立方数，减少不必要的枚举。
- **打表法**：对于数据范围固定且满足条件的数较少的情况，可以通过打表直接查找，提高效率。

### 可拓展之处
- **同类型题**：可以拓展到求不超过 $N$ 的最大回文平方数、回文四次方数等，思路类似，只需将立方运算改为相应的幂运算。
- **类似算法套路**：对于需要枚举大量数据并判断条件的问题，可以通过分析数据范围，找到合适的枚举范围，降低复杂度。

### 推荐洛谷题目
- [P1217 [USACO1.5] 回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)
- [P1015 [NOIP1999 普及组] 回文数](https://www.luogu.com.cn/problem/P1015)
- [P1307 [NOIP2011 普及组] 数字反转](https://www.luogu.com.cn/problem/P1307)

### 个人心得摘录与总结
- **作者：int_stl**：通过暴力模拟发现 $1$ 到 $10^{18}$ 之间只有 $14$ 个回文立方数，从而采用打表法，提高了效率。
- **作者：Programming_Konjac**：赛时一遍过，强调要开 `long long` 避免数据溢出。
- **作者：coderJerry**：分享了自己在 342 和 343 两场比赛中 A 题吃罚时的经历，提醒做题时要仔细。

---
处理用时：45.51秒
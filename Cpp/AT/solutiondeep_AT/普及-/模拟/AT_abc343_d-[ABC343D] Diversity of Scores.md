# 题目信息

# [ABC343D] Diversity of Scores

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc343/tasks/abc343_d

高橋君が主催するコンテストに、$ 1 $ から $ N $ までの番号が付けられた $ N $ 人の選手が参加しています。 このコンテストは各選手がその得点を競うものであり、現在の得点はどの選手も $ 0 $ 点です。

未来予知の能力を持つ高橋君は、今から選手たちの得点がどのように変動するかを知っています。 具体的には、$ i=1,2,\dots,T $ について、今から $ i $ 秒後に選手 $ A_i $ の得点が $ B_i $ 点増加します。 逆に、それ以外に得点の変動はありません。

得点の多様性を好む高橋君は、各時点における選手たちの得点に何種類の値が現れるかを知りたがっています。 $ i=1,2,\dots,T $ それぞれについて、今から $ i+0.5 $ 秒後の選手たちの得点には何種類の値が現れるか求めてください。

例えば、ある時点における選手たちの得点がそれぞれ $ 10,20,30,20 $ 点であった場合、この時点での選手たちの得点には $ 3 $ 種類の値が現れています。

## 说明/提示

### 制約

- $ 1\leq\ N,\ T\leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ N $
- $ 1\leq\ B_i\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

選手 $ 1,2,3 $ の得点をこの順に並べた数列を $ S $ とします。 現在、$ S=\lbrace\ 0,0,0\rbrace $ です。 - $ 1 $ 秒後に選手 $ 1 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,0,0\rbrace $ になります。よって、$ 1.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。 - $ 2 $ 秒後に選手 $ 3 $ の得点が $ 20 $ 点増加し、$ S=\lbrace\ 10,0,20\rbrace $ になります。よって、$ 2.5 $ 秒後の選手たちの得点には $ 3 $ 種類の値が現れます。 - $ 3 $ 秒後に選手 $ 2 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,10,20\rbrace $ になります。よって、$ 3.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。 - $ 4 $ 秒後に選手 $ 2 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,20,20\rbrace $ になります。よって、$ 4.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。

## 样例 #1

### 输入

```
3 4
1 10
3 20
2 10
2 10```

### 输出

```
2
3
2
2```

## 样例 #2

### 输入

```
1 3
1 3
1 4
1 3```

### 输出

```
1
1
1```

## 样例 #3

### 输入

```
10 10
7 2620
9 2620
8 3375
1 3375
6 1395
5 1395
6 2923
10 3375
9 5929
5 1225```

### 输出

```
2
2
3
3
4
4
5
5
6
5```

# AI分析结果

### 题目翻译
高桥君主办的比赛中，有编号从 1 到 N 的 N 名选手参加。这个比赛是各位选手竞争得分的比赛，目前所有选手的得分都是 0 分。

拥有预知未来能力的高桥君，知道从现在起选手们的得分将如何变化。具体来说，对于 $i = 1,2,\dots,T$，从现在起 $i$ 秒后，选手 $A_i$ 的得分将增加 $B_i$ 分。反之，除此之外得分没有其他变化。

喜欢得分多样性的高桥君，想知道在每个时刻选手们的得分会出现多少种不同的值。请分别求出对于 $i = 1,2,\dots,T$，从现在起 $i + 0.5$ 秒后选手们的得分会出现多少种不同的值。

例如，在某一时刻选手们的得分分别为 10、20、30、20 分时，此时选手们的得分出现了 3 种不同的值。

### 综合分析与结论
这些题解的核心思路都是模拟得分变化过程，统计不同得分的种类数。由于分数范围较大，直接用数组存储会爆空间，所以都采用了 `map` 或 `unordered_map` 来记录每个分数的出现次数。

- **思路**：先初始化所有选手分数为 0，对应分数 0 的出现次数为 $N$，不同分数种类数初始为 1。每次操作时，先减少原分数的出现次数，若减为 0 则不同分数种类数减 1；再增加新分数的出现次数，若增加后为 1 则不同分数种类数加 1。
- **算法要点**：使用 `map` 或 `unordered_map` 存储分数及其出现次数，动态维护不同分数的种类数。
- **解决难点**：解决了分数范围大导致数组无法存储的问题，通过动态维护不同分数的种类数，避免了每次操作后暴力统计的高时间复杂度。

### 评分较高的题解
- **Little_x_starTYJ（5 星）**：
    - **关键亮点**：思路清晰，代码简洁，详细说明了使用 `map` 的原因和动态维护不同分数个数的方法。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[200010], b[200010], c[200010];
map<int, int> m;
int number = 1;
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n, t;
    cin >> n >> t;
    for (int i = 1; i <= t; i++) {
        cin >> a[i] >> b[i];
    }
    m[0] += n;
    for (int i = 1; i <= t; i++) {
        m[c[a[i]]]--;
        if (m[c[a[i]]] == 0)
            number--;
        c[a[i]] += b[i];
        m[c[a[i]]]++;
        if (m[c[a[i]]] == 1)
            number++;
        cout << number << endl;
    }
    return 0;
}
```
- **OIer_Tan（4 星）**：
    - **关键亮点**：使用 `unordered_map` 提高查找效率，思路明确，代码规范。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 2e5 + 5;
ll n, t;
ll a [N], b [N], s [N];
unordered_map <ll,ll> cnt;
int main () {
    ios::sync_with_stdio ( 0 );
    cin.tie ( 0 );
    cout.tie ( 0 );
    cin >> n >> t;
    cnt [0] = n;
    for ( ll i = 1 ; i <= t ; i ++ ) {
        cin >> a [i] >> b [i];
        cnt[s [a [i]]] --;
        if ( ! cnt [s [a [i]]] ) {
            cnt.erase ( s [a [i]] );
        }
        s [a [i]] += b [i];
        cnt [s [a [i]]] ++;
        cout << cnt.size () << endl;
    }
    return 0;
}
```
- **f_hxr_（4 星）**：
    - **关键亮点**：思路清晰，直接模拟得分变化过程，代码简洁易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL N,T,val[200005],ans=1;
LL A[200005],B[200005];
map<LL,LL>mp;
int main(){
    cin>>N>>T;
    for(int i=1;i<=T;i++)cin>>A[i]>>B[i];
    mp[0]=N;
    for(int i=1;i<=T;i++){
        mp[val[A[i]]]--;if(mp[val[A[i]]]==0)--ans;
        val[A[i]]+=B[i]; 
        mp[val[A[i]]]++;if(mp[val[A[i]]]==1)++ans;
        cout<<ans<<endl;
    }
    return 0;
}
```

### 最优关键思路或技巧
- **数据结构**：使用 `map` 或 `unordered_map` 存储分数及其出现次数，解决了分数范围大的存储问题。
- **动态维护**：在每次操作时，通过判断分数出现次数的变化，动态维护不同分数的种类数，避免了暴力统计的高时间复杂度。

### 可拓展之处
同类型题目可能会有更多的操作类型，如减少分数、重置分数等，或者有多个条件需要同时满足。类似算法套路可以应用于统计元素种类数的问题，如统计不同颜色的球的个数、不同字符的个数等。

### 推荐洛谷题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)：使用 `map` 统计元素出现次数，通过计算差值来统计满足条件的数对个数。
2. [P1955 [NOI2015] 程序自动分析](https://www.luogu.com.cn/problem/P1955)：使用并查集和 `map` 处理变量之间的相等和不等关系。
3. [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)：使用 `map` 存储余数和位置信息，通过分类讨论计算满足条件的和。

### 个人心得摘录与总结
- **Programming_Konjac**：赛时三遍过，提醒要注意使用映射数组 `map` 避免暴力超时，以及初始化和操作过程中对不同分数个数的维护。总结来说，在处理数据范围较大且需要统计元素出现次数的问题时，要避免暴力算法，合理使用数据结构。 

---
处理用时：45.82秒
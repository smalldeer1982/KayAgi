# 题目信息

# [ABC355C] Bingo 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc355/tasks/abc355_c

縦 $ N $ 行、横 $ N $ 列のマス目があり、上から $ i $ 行目、左から $ j $ 列目のマスには整数 $ N\times\ (i-1)+j $ が書かれています。

今から $ T $ ターンにわたって相異なる整数が宣言されます。$ i $ ターン目には $ A_i $ が宣言され、$ A_i $ が書かれたマスに印をつけます。初めてビンゴを達成するのは何ターン目か求めてください。ただし、$ T $ ターンの中でビンゴを達成しない場合は `-1` を出力してください。

ここで、ビンゴを達成するとは以下のいずれかのうち少なくとも一つ満たされることを言います。

- マス目の横の列であって、列に含まれる $ N $ 個のマスすべてに印がついているものが存在する
- マス目の縦の列であって、列に含まれる $ N $ 個のマスすべてに印がついているものが存在する
- マス目の対角線の列であって、列に含まれる $ N $ 個のマスすべてに印がついているものが存在する

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 2\times\ 10^3 $
- $ 1\leq\ T\leq\ \min(N^2,2\times\ 10^5) $
- $ 1\leq\ A_i\leq\ N^2 $
- $ i\neq\ j $ ならば $ A_i\neq\ A_j $
- 入力は全て整数
 
### Sample Explanation 1

マス目の状態は以下のように変化します。初めてビンゴを達成するのは $ 4 $ ターン目です。 !\[\](https://img.atcoder.jp/abc355/85614db45da7c299bcc5551fc45092a7.png)

### Sample Explanation 2

$ 5 $ ターンの中でビンゴを達成できないので `-1` を出力してください。

## 样例 #1

### 输入

```
3 5

5 1 8 9 7```

### 输出

```
4```

## 样例 #2

### 输入

```
3 5

4 2 9 7 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 12

13 9 6 5 2 7 16 14 8 3 10 11```

### 输出

```
9```

# AI分析结果

### 题目翻译
### [ABC355C] 宾果 2

#### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc355/tasks/abc355_c

有一个纵向 $N$ 行、横向 $N$ 列的网格，从上往下第 $i$ 行、从左往右第 $j$ 列的网格中写有整数 $N\times (i - 1)+j$。

接下来将进行 $T$ 轮操作，每轮会宣布一个不同的整数。在第 $i$ 轮操作中，会宣布整数 $A_i$，并在写有 $A_i$ 的网格上做标记。请找出第一次达成宾果的是第几轮操作。如果在 $T$ 轮操作中都未达成宾果，则输出 `-1`。

这里，达成宾果是指满足以下至少一个条件：
- 存在某一行，该行的 $N$ 个网格都被标记。
- 存在某一列，该列的 $N$ 个网格都被标记。
- 存在某条对角线，该对角线上的 $N$ 个网格都被标记。

#### 说明/提示
##### 约束条件
- $2\leq N\leq 2\times 10^3$
- $1\leq T\leq \min(N^2,2\times 10^5)$
- $1\leq A_i\leq N^2$
- 若 $i\neq j$，则 $A_i\neq A_j$
- 输入均为整数

##### 样例解释 1
网格的状态变化如下。第一次达成宾果是在第 4 轮。![图片](https://img.atcoder.jp/abc355/85614db45da7c299bcc5551fc45092a7.png)

##### 样例解释 2
在 5 轮操作中无法达成宾果，因此输出 `-1`。

#### 样例 #1
##### 输入
```
3 5
5 1 8 9 7
```
##### 输出
```
4
```

#### 样例 #2
##### 输入
```
3 5
4 2 9 7 5
```
##### 输出
```
-1
```

#### 样例 #3
##### 输入
```
4 12
13 9 6 5 2 7 16 14 8 3 10 11
```
##### 输出
```
9
```

### 综合分析与结论
这些题解主要围绕如何高效判断在给定操作次数内是否达成宾果展开，核心在于将数字转换为网格坐标，并记录行、列和对角线的标记情况。各题解思路大体可分为两类：
1. **暴力枚举与二分优化**：如 SXqwq 和 I_Love_DS 的题解，先将数字转换为坐标，再通过二分查找最小操作次数，每次二分判断时暴力检查行、列和对角线是否满足宾果条件，时间复杂度为 $O(n^2 \times \log t)$。
2. **计数优化**：大多数题解采用此思路，通过数组或变量记录每行、每列和两条对角线已标记的格子数量，每次操作更新计数并检查是否达成宾果，时间复杂度为 $O(T)$。

### 高评分题解
- **XXh0919（5星）**
    - **关键亮点**：思路清晰，通过公式准确计算数字的横纵坐标，对行、列和对角线的计数逻辑简单直接，代码可读性高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;
const int N=3e5+15;
int n,t;
int a[N];
int h[N],l[N],x1,x2;
signed main(){
    ios::sync_with_stdio(0);
    cin>>n>>t;
    rep(i,1,n)h[i]=l[i]=n;
    x1=x2=n;
    rep(i,1,t){
        cin>>a[i];
        int ll=a[i]%n;
        ll==0?ll=n:ll=ll;
        int hh=(a[i]-ll)/n+1;
        --h[hh];
        --l[ll];
        if(ll==hh)--x1;
        if(ll+hh==n+1)--x2;
        if(!x1||!x2||!h[hh]||!l[ll]){
            cout<<i<<endl;
            return 0;
        }
    }
    cout<<-1<<endl;
    return 0;
}
```
    - **核心思想**：用 `h` 数组记录每行剩余未标记的格子数，`l` 数组记录每列剩余未标记的格子数，`x1` 和 `x2` 分别记录两条对角线剩余未标记的格子数。每次操作更新相应计数，若有计数为 0 则表示达成宾果。
- **MinimumSpanningTree（5星）**
    - **关键亮点**：代码简洁，直接开数组和变量记录行、列和对角线的标记数量，每次输入数字更新计数并判断是否达成宾果，效率高。
    - **核心代码**：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=2e3+100;
int n,t,a,cx[N],cy[N],dg1,dg2,x,y;
int main()
{
    scanf("%d%d",&n,&t);
    for(int i=1;i<=t;i++)
    {
        scanf("%d",&a);
        x=(a-1)/n+1,y=a%n;
        if(!y) y=n;
        cx[x]++,cy[y]++;
        if(x==y) dg1++;
        if(x+y==n+1) dg2++;
        if(cx[x]==n||cy[y]==n||dg1==n||dg2==n) 
        {
            printf("%d",i);
            return 0;
        }
    }
    printf("-1");
    return 0;
}
```
    - **核心思想**：`cx` 数组记录每行已标记的格子数，`cy` 数组记录每列已标记的格子数，`dg1` 和 `dg2` 分别记录两条对角线已标记的格子数。每次操作更新相应计数，若有计数达到 $n$ 则表示达成宾果。
- **lucasincyber（4星）**
    - **关键亮点**：思路清晰，通过记录每行、每列和对角线未标记的格子数，每次操作更新计数并判断是否达成宾果，时间复杂度低。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, M = 2005;
int n, t;
int a[N], row[M], col[M], dia[4];
int main()
{
    scanf("%d%d", &n, &t);
    dia[1] = dia[2] = n;
    for (int i = 1; i <= n; i++)
        row[i] = col[i] = n;
    for (int i = 1; i <= t; i++)
    {
        scanf("%d", &a[i]);
        int x = ceil(a[i] * 1.0 / n), y = a[i] % n;
        if (y == 0) y = n;
        row[x]--;
        col[y]--;
        if (x == y) dia[1]--;
        if (x + y - 1 == n) dia[2]--;
        if (!row[x] ||!col[y] ||!dia[1] ||!dia[2])
        {
            printf("%d\n", i);
            return 0;
        }
    }
    printf("-1\n");
    return 0;
}
```
    - **核心思想**：`row` 数组记录每行剩余未标记的格子数，`col` 数组记录每列剩余未标记的格子数，`dia[1]` 和 `dia[2]` 分别记录两条对角线剩余未标记的格子数。每次操作更新相应计数，若有计数为 0 则表示达成宾果。

### 最优关键思路与技巧
- **坐标转换**：通过公式将数字转换为网格的行和列坐标，如 `x = (a - 1) / n + 1`，`y = a % n`（若 `y` 为 0 则 `y = n`）。
- **计数优化**：使用数组或变量记录行、列和对角线的标记情况，避免每次都暴力检查整个网格，将时间复杂度从 $O(n^2 \times t)$ 优化到 $O(T)$。

### 拓展思路
同类型题目可能会改变网格的布局或宾果的判定条件，例如不规则网格、多维网格等。类似算法套路可用于解决其他需要判断行列或对角线满足特定条件的问题，如数独求解、矩阵元素统计等。

### 洛谷相似题目推荐
- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)：考察对棋盘行列和对角线的处理，判断皇后放置是否合法。
- [P1008 三连击](https://www.luogu.com.cn/problem/P1008)：需要枚举数字组合，判断是否满足特定条件，与本题枚举操作并判断宾果类似。
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：在迷宫中寻找路径，需要记录行列信息，可类比本题对网格的操作。

### 个人心得摘录与总结
题解中未包含个人调试经历、踩坑教训或顿悟感想等内容。 

---
处理用时：62.65秒
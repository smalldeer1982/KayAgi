# 题目信息

# [ABC361C] Make Them Narrow

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_c

長さ $ N $ の数列 $ A $ が与えられます。  
 $ A $ のうち丁度 $ K $ 要素を自由に選んで消し、残った要素を順序を保って連結した数列を $ B $ とします。  
 ( $ B $ の最大値 ) $ - $ ( $ B $ の最小値 ) としてありうる最小値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K\ <\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
 
### Sample Explanation 1

$ A=(3,1,5,4,9) $ から丁度 $ 2 $ 要素を自由に選んで消すことを考えます。 - 例えば $ 2 $ 要素目の $ 1 $ 、 $ 5 $ 要素目の $ 9 $ を消すと、消した後の数列 $ B=(3,5,4) $ となります。 - このとき $ B $ の最大値は $ 5 $ 、最小値は $ 3 $ なので ( $ B $ の最大値 ) $ - $ ( $ B $ の最小値 ) $ =2 $ となり、これは達成可能な最小値です。

## 样例 #1

### 输入

```
5 2

3 1 5 4 9```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 1 1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
8 3

31 43 26 6 18 36 22 13```

### 输出

```
18```

# AI分析结果

### 题目翻译
给定一个长度为 $N$ 的数列 $A$。  
从 $A$ 中恰好选择 $K$ 个元素并将其删除，将剩余的元素按顺序连接起来得到数列 $B$。  
求（$B$ 的最大值）$ - $（$B$ 的最小值）的可能的最小值。

### 综合分析与结论
这些题解的核心思路都是一致的，即先对数列进行排序，然后通过枚举的方式找出删除 $K$ 个元素后剩余元素极差最小的情况。因为要使极差最小，删除的元素必然是排序后数列两端的元素，所以剩余的元素是排序后数列中的一段连续子序列。

#### 思路对比
- **枚举删除方式**：多数题解通过枚举从左边删除的元素个数 $i$，从而确定从右边删除的元素个数为 $K - i$，计算剩余子序列的极差。
- **枚举连续子序列**：部分题解直接枚举长度为 $N - K$ 的连续子序列，计算每个子序列的极差。

#### 算法要点
1. **排序**：对数列进行排序是关键步骤，时间复杂度为 $O(n \log n)$。
2. **枚举**：通过枚举不同的删除方式或连续子序列，计算极差并取最小值，时间复杂度为 $O(n)$。

#### 解决难点
- **贪心策略**：确定删除元素的策略，即删除排序后数列两端的元素才能使极差最小。
- **枚举范围**：正确确定枚举的范围，确保不遗漏可能的情况。

### 通用建议与扩展思路
这些题解整体质量较为接近，均未达到 4 星标准。对于此类题目，关键在于理解贪心策略，即删除两端元素可使极差最小。在代码实现上，要注意数组下标和边界条件的处理。

同类型题或类似算法套路：此类题目通常涉及贪心思想和枚举，可应用于其他需要优化某个指标的问题，如在一组数据中选择若干元素使某个差值最小等。

### 推荐题目
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)

### 重点代码
```cpp
// 以 ganyu1 的题解为例
#include<bits/stdc++.h>
#define int long long
#define N 200001
using namespace std;
int n,k,a[N];
int ans=LLONG_MAX;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1); // 排序
    for(int i=0;i<=k;i++){ // 枚举从左边删去多少数
        ans=min(ans,a[n-k+i]-a[1+i]); // 计算每种方式答案，比出最小值
    }
    cout<<ans;
    return 0;
}
```
**核心实现思想**：先对数组进行排序，然后通过枚举从左边删除的元素个数 $i$，计算剩余子序列的极差，取最小值作为最终答案。

### 个人心得摘录与总结
- **Redamancy_Lydic**：提到打比赛时查中考分，心快停跳了，主要是分享个人当时的紧张心情，与题目解题本身关系不大。 

---
处理用时：24.09秒
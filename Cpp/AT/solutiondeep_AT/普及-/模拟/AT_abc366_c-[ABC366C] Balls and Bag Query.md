# 题目信息

# [ABC366C] Balls and Bag Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc366/tasks/abc366_c

空の袋があります。 クエリが $ Q $ 個与えられるので、順番に処理してください。

クエリは次の $ 3 $ 種類です。

- `1 x` : 整数 $ x $ が書かれたボールを $ 1 $ つ袋に入れる。
- `2 x` : 整数 $ x $ が書かれたボールを $ 1 $ つ袋の中から取り出して外に捨てる。このクエリが与えられるとき、袋の中に整数 $ x $ が書かれたボールが存在することが保証される。
- `3` : 袋の中にあるボールに書かれている整数の種類数を出力する。

## 说明/提示

### 制約

- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^{5} $
- $ 1\ \leq\ x\ \leq\ 10^{6} $
- $ 2 $ 種類目のクエリが与えられるとき、袋の中に整数 $ x $ が書かれたボールが存在する。
- $ 3 $ 種類目のクエリが $ 1 $ つ以上存在する。
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、袋の中は空です。 $ 1 $ 番目のクエリ `1 3` で袋の中に $ 3 $ が書かれたボールが $ 1 $ つ入ります。 $ 2 $ 番目のクエリ `1 1` で袋の中に $ 1 $ が書かれたボールが $ 1 $ つ入ります。 $ 3 $ 番目のクエリ `1 4` で袋の中に $ 4 $ が書かれたボールが $ 1 $ つ入ります。 $ 4 $ 番目のクエリ `3` で袋の中に $ 1,\ 3,\ 4 $ の $ 3 $ 種類のボールが入っているため、$ 3 $ を出力します。 $ 5 $ 番目のクエリ `2 1` で袋の中から $ 1 $ が書かれたボールを $ 1 $ つ取り出します。 $ 6 $ 番目のクエリ `3` で袋の中に $ 3,\ 4 $ の $ 2 $ 種類のボールが入っているため、$ 2 $ を出力します。 $ 7 $ 番目のクエリ `1 5` で袋の中に $ 5 $ が書かれたボールが $ 1 $ つ入ります。 $ 8 $ 番目のクエリ `3` で袋の中に $ 3,\ 4,\ 5 $ の $ 3 $ 種類のボールが入っているため、$ 3 $ を出力します。

## 样例 #1

### 输入

```
8

1 3

1 1

1 4

3

2 1

3

1 5

3```

### 输出

```
3

2

3```

## 样例 #2

### 输入

```
8

1 2

1 2

3

2 2

1 4

1 4

2 2

3```

### 输出

```
1

1```

# AI分析结果

### 题目翻译
有一个空袋子。给定 $Q$ 个查询，请按顺序处理它们。

查询有以下 3 种类型：
- `1 x`：将一个写有整数 $x$ 的球放入袋子中。
- `2 x`：从袋子中取出一个写有整数 $x$ 的球并丢弃。当给出此查询时，保证袋子中有一个写有整数 $x$ 的球。
- `3`：输出袋子中写有不同整数的球的种类数。

### 综合分析与结论
这些题解的核心思路都是围绕三种操作进行模拟，通过不同的数据结构来记录每个数字的出现次数，并维护不同数字的数量。主要的算法要点在于对插入和删除操作时不同数字数量的更新。

- **思路对比**：大部分题解使用数组（桶）或 `map`/`unordered_map` 来记录数字出现次数，部分使用 `set` 辅助统计不同数字数量，还有使用线段树和平衡树的复杂解法。
- **算法要点**：插入时，若该数字之前出现次数为 0，则不同数字数量加 1；删除时，若该数字删除后出现次数为 0，则不同数字数量减 1。
- **解决难点**：主要难点在于如何高效地维护不同数字的数量，不同数据结构的选择影响着时间和空间复杂度。

### 所选题解
- **jiangruibo（4星）**
  - **关键亮点**：思路清晰，代码简洁，使用数组（桶）来记录数字出现次数，直接维护不同数字的数量。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
int box[1000010];
signed main()
{
    int q;
    cin>>q;
    int cnt=0;
    while(q--)
    {
        int a,x;
        cin>>a;
        if(a==1)
        {
            cin>>x;
            if(box[x]==0)
            {
                cnt++;
            }
            box[x]++;
        }
        if(a==2)
        {
            cin>>x;
            if(box[x]==1)
            {
                cnt--;
            }
            box[x]--;
        }
        if(a==3)
        {
            cout<<cnt<<endl;
        }
    }
    return 0;
}
```
核心实现思想：用 `box` 数组记录每个数字的出现次数，`cnt` 记录不同数字的数量。插入时若该数字首次出现则 `cnt` 加 1，删除时若该数字不再存在则 `cnt` 减 1，查询时直接输出 `cnt`。

- **HeYilin（4星）**
  - **关键亮点**：使用 `unordered_map` 来记录数字出现次数，操作简单，且 `unordered_map` 比 `map` 速度更快。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
typedef long long int ll;
unordered_map<int,int>mp;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(nullptr);cout.tie(nullptr);
    int n;
    cin>>n;
    while(n--){
        int op,x;
        cin>>op;
        if(op==1){
            cin>>x;
            mp[x]++;
        }
        if(op==2){
            cin>>x;
            mp[x]--;
            if(!mp[x])mp.erase(x);
        }
        if(op==3){
            cout<<mp.size()<<"\n";
        }
    }
    return 0;
}
```
核心实现思想：用 `unordered_map` 记录每个数字的出现次数，插入时对应值加 1，删除时对应值减 1，若值为 0 则删除该键值对，查询时直接输出 `unordered_map` 的大小。

- **x1489631649（4星）**
  - **关键亮点**：思路清晰，通过维护变量 `l` 记录不同数字的数量，使用数组（桶）记录数字出现次数。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
int f[1000005];
int main()
{
    int n,l=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x,k;
        cin>>x;
        if(x==1)
        {
            cin>>k; 
            f[k]+=1;
            if(f[k]==1)
                l++;
        }
        else if(x==2)
        {
            cin>>k;
            f[k]--;
            if(f[k]==0)
                l--;
        }
        else cout<<l<<endl;
    }
    return 0;
}
```
核心实现思想：用 `f` 数组记录每个数字的出现次数，`l` 记录不同数字的数量。插入时若该数字首次出现则 `l` 加 1，删除时若该数字不再存在则 `l` 减 1，查询时直接输出 `l`。

### 最优关键思路或技巧
- **桶的使用**：使用数组（桶）来记录每个数字的出现次数，简单直接，能高效处理插入和删除操作。
- **维护不同数字数量**：在插入和删除操作时，通过判断数字的出现次数是否为 0 或 1 来更新不同数字的数量，避免了每次查询都遍历所有数字。
- **使用 `unordered_map`**：当数据范围较大时，`unordered_map` 可以在 $O(1)$ 的时间复杂度内完成插入、删除和查找操作，提高效率。

### 可拓展之处
同类型题或类似算法套路：
- 统计序列中不同元素的个数，支持插入和删除操作。
- 维护集合中元素的种类数，可进行元素的添加和移除。

### 推荐洛谷题目
- P1168 中位数
- P1955 [NOI2015] 程序自动分析
- P2058 海港

### 个人心得
本题解中未包含个人心得（调试经历、踩坑教训、顿悟感想等）。

---
处理用时：36.85秒
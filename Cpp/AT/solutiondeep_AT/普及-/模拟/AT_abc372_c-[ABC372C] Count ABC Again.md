# 题目信息

# [ABC372C] Count ABC Again

## 题目描述

给定一个长度为 $N$ 的字符串 $S$。接着给出 $Q$ 个查询，依次处理。

对于第 $i$ 个查询：

- 给定一个整数 $X_i$ 和一个字符 $C_i$，将 $S$ 的第 $X_i$ 个字符替换为 $C_i$。然后，输出字符串 $S$ 中包含 `ABC` 作为子串的次数。

这里，$S$ 的 **子串** 指的是，从 $S$ 的开头删除 $0$ 个或多个字符，从 $S$ 的结尾删除 $0$ 个或多个字符后得到的字符串。

例如，`ab` 是 `abc` 的子串，但 `ac` 不是 `abc` 的子串。

## 说明/提示

### 约束

- $3 \le N \le 2×10^5$
- $1 \le Q \le 2×10^5$
- $S$ 是由大写字母组成的长度为 $N$ 的字符串
- $1 \le Xi \le N$
- $C_i$ 是大写字母

### 示例解释 1

处理每个查询后的 $S$ 如下：

- 处理第 $1$ 个查询后：$S$ 变为 `ABCBABC`。其中 `ABC` 作为子串出现了 $2$ 次。
- 处理第 $2$ 个查询后：$S$ 变为 `ABABABC`。其中 `ABC` 作为子串出现了 $1$ 次。
- 处理第 $3$ 个查询后：$S$ 变为 `ABABCBC`。其中 `ABC` 作为子串出现了 $1$ 次。
- 处理第 $4$ 个查询后：$S$ 变为 `ABAGCBC`。其中 `ABC` 作为子串出现了 $0$ 次。

### 示例解释 2

有时处理查询前后 $S$ 可能不会发生变化。

## 样例 #1

### 输入

```
7 4
ABCDABC
4 B
3 A
5 C
4 G```

### 输出

```
2
1
1
0```

## 样例 #2

### 输入

```
3 3
ABC
1 A
2 B
3 C```

### 输出

```
1
1
1```

## 样例 #3

### 输入

```
15 10
BBCCBCACCBACACA
9 C
11 B
5 B
11 B
4 A
8 C
8 B
5 B
7 B
14 B```

### 输出

```
0
0
0
0
1
1
2
2
1
1```

# AI分析结果

### 题目翻译
给定一个长度为 $N$ 的字符串 $S$。接着给出 $Q$ 个查询，依次处理。

对于第 $i$ 个查询：

- 给定一个整数 $X_i$ 和一个字符 $C_i$，将 $S$ 的第 $X_i$ 个字符替换为 $C_i$。然后，输出字符串 $S$ 中包含 `ABC` 作为子串的次数。

这里，$S$ 的 **子串** 指的是，从 $S$ 的开头删除 $0$ 个或多个字符，从 $S$ 的结尾删除 $0$ 个或多个字符后得到的字符串。

例如，`ab` 是 `abc` 的子串，但 `ac` 不是 `abc` 的子串。

### 综合分析与结论
- **思路对比**：各题解核心思路一致，均先统计初始字符串中 `ABC` 子串的数量，再利用每次修改仅影响以修改位置为中心的长度为 5 的子串这一特性，通过重新计算受影响的子串来更新 `ABC` 子串的数量。
- **算法要点**：先遍历字符串统计初始 `ABC` 子串数量，每次修改时，减去受影响子串的原贡献，修改字符后再加上新贡献。
- **解决难点**：主要难点在于处理边界情况，避免数组越界。不同题解采用了不同的边界处理方式，如使用条件判断、封装检查函数等。

### 所选题解
- **作者：DragonForge (赞：6)，4星**
  - **关键亮点**：思路清晰，代码简洁，直接在主函数中处理边界和更新逻辑，易于理解。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=2e5+10;
int n,q;
char s[MAXN];
int main(){
    cin>>n>>q;
    scanf("%s",s+1);
    int ans=0;
    for(int i=2;i<n;i++){
        if(s[i-1]=='A'&&s[i]=='B'&&s[i+1]=='C'){
            ans++;
        }
    }
    while(q--){
        int x;
        char c;
        cin>>x>>c;
        if(s[x]==c){
            cout<<ans<<endl;
            continue;
        }
        if(s[x-2]=='A'&&s[x-1]=='B'&&s[x]=='C'&&c!='C'){
            ans--;
        }
        if(s[x-1]=='A'&&s[x]=='B'&&s[x+1]=='C'&&c!='B'){
            ans--;
        }
        if(s[x]=='A'&&s[x+1]=='B'&&s[x+2]=='C'&&c!='A'){
            ans--;
        }
        
        if(s[x-2]=='A'&&s[x-1]=='B'&&s[x]!='C'&&c=='C'){
            ans++;
        }
        if(s[x-1]=='A'&&s[x]!='B'&&s[x+1]=='C'&&c=='B'){
            ans++;
        }
        if(s[x]!='A'&&s[x+1]=='B'&&s[x+2]=='C'&&c=='A'){
            ans++;
        }
        s[x]=c;
        cout<<ans<<endl;
    }
    return 0;
}
```
核心实现思想：先统计初始 `ABC` 子串数量，每次修改时，根据修改前后字符的变化，判断是否需要增加或减少 `ABC` 子串的数量。

- **作者：Redamancy_Lydic (赞：3)，4星**
  - **关键亮点**：封装了检查函数 `ch` 处理边界情况，使代码结构更清晰，逻辑更简洁。
```cpp
bool ch(int x)
{
    if(x<=0||x+2>n)return 0;
    return s[x]=='A'&&s[x+1]=='B'&&s[x+2]=='C';
}
```
核心实现思想：通过 `ch` 函数判断以某个位置开头的子串是否为 `ABC`，在修改字符时，先减去受影响子串的原贡献，修改后再加上新贡献。

- **作者：Chenyanxi0829 (赞：2)，4星**
  - **关键亮点**：使用布尔数组 `f` 记录每个位置开头的子串是否为 `ABC`，更新时直接操作数组元素，逻辑清晰。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 2e5 + 1;

int n, q, ans;
char c;
bool f[kMaxN];
string s;

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> q >> s;
  for (int i = 1; i + 2 <= n; i++) {
    ans += (f[i] = s.substr(i - 1, 3) == "ABC");
  }
  for (int i = 1, x; i <= q; i++) {
    cin >> x >> c, s[x - 1] = c;
    x >= 3 && (ans -= f[x - 2], ans += (f[x - 2] = s.substr(x - 3, 3) == "ABC"));
    x >= 2 && x < n && (ans -= f[x - 1], ans += (f[x - 1] = s.substr(x - 2, 3) == "ABC"));
    x + 1 < n && (ans -= f[x], ans += (f[x] = s.substr(x - 1, 3) == "ABC"));
    cout << ans << '\n';
  }
  return 0;
}
```
核心实现思想：先初始化 `f` 数组并统计初始答案，每次修改时，更新受影响位置的 `f` 数组元素，并相应地更新答案。

### 最优关键思路或技巧
- 利用修改一个字符最多影响三个长度为 3 的子串这一特性，避免每次修改都遍历整个字符串，将时间复杂度从 $O(NQ)$ 优化到 $O(N + Q)$。
- 封装检查函数或使用布尔数组记录子串信息，使代码结构更清晰，逻辑更简洁，便于处理边界情况。

### 可拓展之处
同类型题目可能会有不同的子串模式或修改规则，如统计多个不同子串的出现次数、每次修改多个字符等。解题思路类似，关键在于找出修改操作对结果的影响范围，通过局部更新来避免重复计算。

### 推荐题目
- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)
- [P5733 【深基6.例1】自动修正](https://www.luogu.com.cn/problem/P5733)
- [P1957 口算练习题](https://www.luogu.com.cn/problem/P1957)

### 个人心得
题解中未包含个人心得。

---
处理用时：46.21秒
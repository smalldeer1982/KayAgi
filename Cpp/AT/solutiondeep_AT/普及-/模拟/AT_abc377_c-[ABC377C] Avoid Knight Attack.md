# 题目信息

# [ABC377C] Avoid Knight Attack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc377/tasks/abc377_c

縦 $ N $ マス、横 $ N $ マスの $ N\ ^\ 2 $ マスからなるマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ N) $ 、左から $ j $ 列目 $ (1\leq\ j\leq\ N) $ のマスをマス $ (i,j) $ と呼ぶことにします。

それぞれのマスは、空マスであるかコマが置かれているかのどちらかです。 マス目には合計で $ M $ 個のコマが置かれており、$ k $ 番目 $ (1\leq\ k\leq\ M) $ のコマはマス $ (a\ _\ k,b\ _\ k) $ に置かれています。

あなたは、すでに置かれている**どのコマにも取られないように**、いずれかの**空マス**に自分のコマを置きたいです。

マス $ (i,j) $ に置かれているコマは、次のどれかの条件を満たすコマを取ることができます。

- マス $ (i+2,j+1) $ に置かれている
- マス $ (i+1,j+2) $ に置かれている
- マス $ (i-1,j+2) $ に置かれている
- マス $ (i-2,j+1) $ に置かれている
- マス $ (i-2,j-1) $ に置かれている
- マス $ (i-1,j-2) $ に置かれている
- マス $ (i+1,j-2) $ に置かれている
- マス $ (i+2,j-1) $ に置かれている

ただし、存在しないマスについての条件は常に満たされないものとします。

たとえば、マス $ (4,4) $ に置かれているコマは、以下の図で青く示されたマスに置かれているコマを取ることができます。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc377_c/399e5a909392dc44071791350bba40d75968dfd7.png)

あなたがコマを置くことができるマスがいくつあるか求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq10\ ^\ 9 $
- $ 1\leq\ M\leq2\times10\ ^\ 5 $
- $ 1\leq\ a\ _\ k\leq\ N,1\leq\ b\ _\ k\leq\ N\ (1\leq\ k\leq\ M) $
- $ (a\ _\ k,b\ _\ k)\neq(a\ _\ l,b\ _\ l)\ (1\leq\ k\lt\ l\leq\ M) $
- 入力はすべて整数

### Sample Explanation 1

すでに置かれているコマは、以下の図で青く示されたマスに置かれたコマを取ることができます。 ![](https://img.atcoder.jp/abc377/cb70c753c18ba20c291ba79e76f34599.png) よって、あなたがすでに置かれているコマに取られないように自分のコマを置くことができるマスは残りの $ 38 $ マスです。

### Sample Explanation 2

$ 10\ ^\ {18} $ マスのうち、置くことができないマスはマス $ (1,1),(2,3),(3,2) $ の $ 3 $ マスのみです。 答えが $ 2\ ^\ {32} $ 以上になる場合があることに注意してください。

## 样例 #1

### 输入

```
8 6
1 4
2 1
3 8
4 5
5 2
8 3```

### 输出

```
38```

## 样例 #2

### 输入

```
1000000000 1
1 1```

### 输出

```
999999999999999997```

## 样例 #3

### 输入

```
20 10
1 4
7 11
7 15
8 10
11 6
12 5
13 1
15 2
20 10
20 15```

### 输出

```
338```

# AI分析结果

### 题目内容中文重写
有一个 $N$ 行 $N$ 列，由 $N^2$ 个格子组成的网格。我们将从上往下数第 $i$ 行（$1\leq i\leq N$），从左往右数第 $j$ 列（$1\leq j\leq N$）的格子称为格子 $(i, j)$。

每个格子要么是空的，要么放置了一个棋子。网格中总共放置了 $M$ 个棋子，第 $k$ 个（$1\leq k\leq M$）棋子放置在格子 $(a_k, b_k)$ 处。

你想在任意一个**空格子**中放置自己的棋子，且保证该棋子不会被已经放置的**任何棋子吃掉**。

放置在格子 $(i, j)$ 处的棋子可以吃掉满足以下任意一个条件的棋子：
- 放置在格子 $(i + 2, j + 1)$ 处的棋子；
- 放置在格子 $(i + 1, j + 2)$ 处的棋子；
- 放置在格子 $(i - 1, j + 2)$ 处的棋子；
- 放置在格子 $(i - 2, j + 1)$ 处的棋子；
- 放置在格子 $(i - 2, j - 1)$ 处的棋子；
- 放置在格子 $(i - 1, j - 2)$ 处的棋子；
- 放置在格子 $(i + 1, j - 2)$ 处的棋子；
- 放置在格子 $(i + 2, j - 1)$ 处的棋子。

不过，对于不存在的格子，上述条件始终不成立。

例如，放置在格子 $(4, 4)$ 处的棋子可以吃掉下图中蓝色标记的格子里放置的棋子。
![示例图](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc377_c/399e5a909392dc44071791350bba40d75968dfd7.png)

请计算你可以放置棋子的格子数量。

### 说明/提示
#### 限制条件
- $1\leq N\leq10^9$
- $1\leq M\leq2\times10^5$
- $1\leq a_k\leq N, 1\leq b_k\leq N$（$1\leq k\leq M$）
- $(a_k, b_k)\neq(a_l, b_l)$（$1\leq k\lt l\leq M$）
- 所有输入均为整数

#### 样例解释 1
已经放置的棋子可以吃掉下图中蓝色标记的格子里放置的棋子。
![示例图](https://img.atcoder.jp/abc377/cb70c753c18ba20c291ba79e76f34599.png)
因此，你可以放置自己的棋子且不被已放置棋子吃掉的格子还剩下 $38$ 个。

#### 样例解释 2
在 $10^{18}$ 个格子中，不能放置棋子的格子只有 $(1, 1)$、$(2, 3)$、$(3, 2)$ 这 $3$ 个。请注意，答案可能会超过 $2^{32}$。

### 样例 #1
#### 输入
```
8 6
1 4
2 1
3 8
4 5
5 2
8 3
```
#### 输出
```
38
```

### 样例 #2
#### 输入
```
1000000000 1
1 1
```
#### 输出
```
999999999999999997
```

### 样例 #3
#### 输入
```
20 10
1 4
7 11
7 15
8 10
11 6
12 5
13 1
15 2
20 10
20 15
```
#### 输出
```
338
```

### 题解综合分析与结论
这些题解的核心思路都是先找出所有会被已有棋子攻击到的格子，再用总格子数减去这些格子的数量，得到可放置棋子的格子数。由于 $N$ 最大可达 $10^9$，直接使用二维数组存储会导致空间复杂度极高，所以各题解都采用了不同的数据结构来解决这个问题。

|作者|思路|算法要点|解决难点|评分|
|----|----|----|----|----|
|cyx012113|使用 `map<pair<int, int>, bool>` 记录能被攻击的坐标，边输入边标记|用 `map` 存储坐标，枚举 $M$ 个棋子的 $8$ 个方向|避免使用二维数组，解决空间复杂度问题；处理坐标越界和重复标记|5星|
|FlowerAccepted|用 `set<pair<int, int>>` 存储骑士和被吃子位置，枚举每个骑士的 $8$ 个移动并插入 `set`|使用 `set` 自动去重和排序|避免重复标记，处理坐标越界和已有骑士位置|4星|
|include13_fAKe|用结构体数组存储能被控制的格子，排序后去重|自定义结构体存储坐标，排序去重|手动去重，处理坐标越界|3星|
|sherry_lover|用 `map<pair<int, int>, bool>` 记录某个位置是否被防御|使用 `map` 标记位置|避免使用二维数组，处理坐标越界|4星|
|kikilong_mamba|用 `set<pair<int, int>>` 存储被棋子控制的位置|使用 `set` 自动去重和排序|避免使用二维数组，处理坐标越界|3星|
|JXR_Kalcium|将坐标转换为字符串，用 `unordered_map` 存储模拟标记过程|坐标转换和 `unordered_map` 的使用|处理大规模数据，降低时间复杂度|3星|
|Hacker_Cracker|用 `set<pair<int, int>>` 维护横纵坐标，存储马及扩展点|使用 `set` 自动去重和排序|避免使用二维数组，处理坐标越界|3星|
|liuziqin|用二维 `map` 存储能被攻击到的点，加入点时更新 `map` 并统计点数|二维 `map` 的使用|避免使用二维数组，处理坐标越界|3星|
|cjh_trailblazer|用 `map` 存储格子状态，模拟每个马修改 $9$ 个格子状态|使用 `map` 标记状态|避免使用二维数组，处理坐标越界|3星|

### 所选题解
- **cyx012113（5星）**
    - 关键亮点：思路清晰，详细分析了时空复杂度，代码注释丰富，使用 `map` 结合 `pair` 巧妙解决了二维坐标的存储问题。
    - 核心代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

map <pair <int, int>, bool> a;
int n, m, x, y;
int fx[] = {0, 2, 1, -1, -2, -2, -1,  1,  2};
int fy[] = {0, 1, 2,  2,  1, -1, -2, -2, -1};

signed main() {
    cin >> n >> m;
    for (int i = 1;i <= m;i++) {
        cin >> x >> y;
        a[make_pair(x, y)] = 1;
        for (int j = 1;j <= 8;j++)
            if (x + fx[j] > 0 && y + fy[j] > 0 && x + fx[j] <= n && y + fy[j] <= n)
                a[make_pair(x + fx[j], y + fy[j])] = 1;
    }
    cout << n * n - a.size() << endl;
    return 0;
}
```
- **FlowerAccepted（4星）**
    - 关键亮点：使用 `set` 自动去重和排序，代码结构清晰，对 `set` 的使用和操作进行了详细说明。
    - 核心代码：
```cpp
#include <algorithm>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <set>
using namespace std;

int
jumpx[] = {-1,  1,  2,  2,  1, -1, -2, -2},
jumpy[] = {-2, -2, -1,  1,  2,  2,  1, -1};

set<pair<int, int> > knights, capture;

int main() {
    int n, m, x, y;
    long long ans;
    cin >> n >> m;
    for (int i = 1; i <= m; i ++) {
        cin >> x >> y;
        knights.insert(make_pair(x, y));
    }
    for (const auto& knight : knights) {
        for (int i = 0; i < 8; i ++) {
            if (1 <= knight.first + jumpx[i] && knight.first + jumpx[i] <= n &&
                1 <= knight.second + jumpy[i] && knight.second + jumpy[i] <= n &&
               !knights.count(make_pair(knight.first + jumpx[i], knight.second + jumpy[i]))) {
                capture.insert(make_pair(knight.first + jumpx[i], knight.second + jumpy[i]));
            }
        }
    }
    ans = n * 1ll * n - capture.size() - m;
    cout << ans;
    return 0;
}
```
- **sherry_lover（4星）**
    - 关键亮点：使用 `map` 标记位置，代码简洁，对答案可能超过 $2^{32}$ 的情况进行了处理。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10][2] = {{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1},{0,0}};
map<pair<int,int>,bool> mp;
long long ans,n,m;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    ans = n*n;
    for(int i = 1,x,y;i <= m;i++)
    {
        cin >> x >> y;
        for(int j = 0;j < 9;j++)
        {
            int xx = x+f[j][0],yy = y+f[j][1];
            if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)
            {
                if(!mp[{xx,yy}]) ans--;
                mp[{xx,yy}] = 1;
            }
        }
    }
    cout << ans;
    return 0;
}
```

### 最优关键思路或技巧
- **数据结构选择**：使用 `map`、`set` 或 `unordered_map` 存储坐标，避免了使用二维数组带来的高空间复杂度问题。
- **坐标处理**：使用 `pair` 存储二维坐标，方便进行存储和比较。
- **去重处理**：利用 `map` 和 `set` 的特性自动去重，减少了手动去重的复杂度。

### 拓展思路
同类型题目可能会改变棋子的移动规则或网格的形状，解题的关键仍然是找出所有被控制的位置，再用总位置数减去这些位置数。类似的算法套路包括使用合适的数据结构存储坐标、处理坐标越界和去重等。

### 推荐题目
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：考察二维数组的遍历和动态规划，与本题处理二维网格的思路有一定相似性。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：涉及二维网格的遍历和标记，与本题标记被攻击位置的思路类似。
- [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)：可以使用图的遍历算法，与本题找出所有被控制位置的思路有相通之处。

### 个人心得摘录与总结
- **FlowerAccepted**：提到 AT 题面读题费时，强调了 STL 的便利性，如 `set` 的自动排序和去重功能，避免了手动实现复杂的数据结构。
- **kikilong_mamba**：指出棋子原位置也被控制是本题的一个坑点，提醒做题时要仔细审题。

---
处理用时：72.83秒
# 题目信息

# [ABC380C] Move Segment

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc380/tasks/abc380_c

`0`, `1` のみからなる長さ $ N $ の文字列 $ S $ が与えられます。  
 $ S $ の中で先頭から $ K $ 番目の `1` の塊を $ K-1 $ 番目の `1` の塊の直後まで移動した文字列を出力してください。

なお、$ S $ には `1` の塊が $ K $ 個以上含まれることが保証されます。

より正確な説明は以下の通りです。

- $ S $ の $ l $ 文字目から $ r $ 文字目までからなる部分文字列を $ S_{l\ldots\ r} $ と表す。
- $ S $ の部分文字列 $ S_{l\ldots\ r} $ が `1` の塊であるとは、以下の条件を全て満たすことと定める。
  - $ S_l=S_{l+1}=\cdots=S_r= $ `1`
  - $ l=1 $ または $ S_{l-1}= $ `0`
  - $ r=N $ または $ S_{r+1}= $ `0`
- $ S $ に含まれる `1` の塊が $ S_{l_1\ldots\ r_1},\ldots,S_{l_m\ldots\ r_m} $ で全てであり、$ l_1\ <\ \cdots\ <\ l_m $ を満たしているとする。  
   このとき、以下で定義される長さ $ N $ の文字列 $ T $ を、「$ S $ の中で先頭から $ K $ 番目の `1` の塊を $ K-1 $ 番目の `1` の塊の直後まで移動した文字列」と定める
  - $ 1\ \leq\ i\ \leq\ r_{K-1} $ のとき $ T_i\ =\ S_i $
  - $ r_{K-1}+1\ \leq\ i\ \leq\ r_{K-1}+(r_K-l_K)+1 $ のとき $ T_i= $ `1`
  - $ r_{K-1}+(r_K-l_K)+2\ \leq\ i\ \leq\ r_K $ のとき $ T_i= $ `0`
  - $ r_K+1\ \leq\ i\ \leq\ N $ のとき $ T_i=S_i $

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\times\ 10^5 $
- $ S $ は `0`, `1` のみからなる長さ $ N $ の文字列
- $ 2\ \leq\ K $
- $ S $ には `1` の塊が $ K $ 個以上含まれる
 
### Sample Explanation 1

$ S $ には、$ 2 $ 文字目から $ 2 $ 文字目、$ 5 $ 文字目から $ 7 $ 文字目、$ 11 $ 文字目から $ 12 $ 文字目、$ 15 $ 文字目から $ 15 $ 文字目の $ 4 $ つの `1` の塊があります。

## 样例 #1

### 输入

```
15 3

010011100011001```

### 输出

```
010011111000001```

## 样例 #2

### 输入

```
10 2

1011111111```

### 输出

```
1111111110```

# AI分析结果

### 题目中文重写
## [ABC380C] 移动线段

### 题目描述
给定一个仅由 `0` 和 `1` 组成的长度为 $N$ 的字符串 $S$。请输出将 $S$ 中从开头数第 $K$ 个 `1` 的块移动到第 $K - 1$ 个 `1` 的块正后方后得到的字符串。

需要注意的是，保证 $S$ 中包含 $K$ 个以上的 `1` 的块。

更准确的说明如下：
- 用 $S_{l\ldots r}$ 表示 $S$ 中从第 $l$ 个字符到第 $r$ 个字符组成的子字符串。
- 当 $S$ 的子字符串 $S_{l\ldots r}$ 满足以下所有条件时，称其为 `1` 的块：
  - $S_l = S_{l + 1} = \cdots = S_r =$ `1`
  - $l = 1$ 或者 $S_{l - 1} =$ `0`
  - $r = N$ 或者 $S_{r + 1} =$ `0`
- 假设 $S$ 中包含的 `1` 的块为 $S_{l_1\ldots r_1}, \ldots, S_{l_m\ldots r_m}$，并且满足 $l_1 < \cdots < l_m$。此时，将以下方式定义的长度为 $N$ 的字符串 $T$ 称为「将 $S$ 中从开头数第 $K$ 个 `1` 的块移动到第 $K - 1$ 个 `1` 的块正后方后得到的字符串」：
  - 当 $1 \leq i \leq r_{K - 1}$ 时，$T_i = S_i$
  - 当 $r_{K - 1} + 1 \leq i \leq r_{K - 1} + (r_K - l_K) + 1$ 时，$T_i =$ `1`
  - 当 $r_{K - 1} + (r_K - l_K) + 2 \leq i \leq r_K$ 时，$T_i =$ `0`
  - 当 $r_K + 1 \leq i \leq N$ 时，$T_i = S_i$

### 说明/提示
#### 限制条件
- $1 \leq N \leq 5\times 10^5$
- $S$ 是仅由 `0` 和 `1` 组成的长度为 $N$ 的字符串
- $2 \leq K$
- $S$ 中包含 $K$ 个以上的 `1` 的块

#### 样例解释 1
$S$ 中有 4 个 `1` 的块，分别是从第 2 个字符到第 2 个字符、从第 5 个字符到第 7 个字符、从第 11 个字符到第 12 个字符、从第 15 个字符到第 15 个字符。

### 样例 #1
#### 输入
```
15 3
010011100011001
```
#### 输出
```
010011111000001
```

### 样例 #2
#### 输入
```
10 2
1011111111
```
#### 输出
```
1111111110
```

### 题解综合分析与结论
这些题解的核心思路都是先找出字符串中所有 `1` 的块，然后将第 $K$ 个 `1` 的块移动到第 $K - 1$ 个 `1` 的块后面。不同题解在实现细节上有所差异：
- **思路方面**：部分题解采用记录每个 `1` 块的起始坐标和长度，然后进行移动操作；部分题解则是将连续的 `0` 和 `1` 块存储起来，通过交换元素位置实现移动；还有题解直接模拟输出过程。
- **算法要点**：关键在于准确识别 `1` 的块，记录其位置和长度信息，以及正确处理移动和输出。
- **解决难点**：主要难点在于边界条件的处理，如字符串首尾的判断、移动后新字符串的拼接等。

### 评分较高的题解
- **Very_Smart_Honet（5星）**
    - **关键亮点**：思路清晰，详细阐述了每个步骤，代码注释完整，易于理解。通过 `id` 数组记录每个 `1` 块的起始坐标，`shu` 数组记录元素个数，方便后续移动操作。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k;
string s;
int id[1000010];
int shu[1000010];
int cnt;
signed main()
{
    cin>>n>>k;
    cin>>s;
    int number=0,last=0;
    for(int i=0;i<n;i++)
    {
        if(s[i]=='1')
        {
            number++;
        }
        else if(s[i-1]=='1'&&s[i]=='0')
        {
            id[++cnt]=last;
            shu[cnt]=number;
            number=0;
        }
        if(s[i]=='0'&&s[i+1]=='1')
        {
            last=i+1;
        }
    }
    if(number!=0)
    {
        id[++cnt]=last;
        shu[cnt]=number;
        number=0;
    }
    id[k]=id[k-1]+shu[k-1];
    int now=1;
    for(int i=0;i<n;i++)
    {
        if(i>=id[now]&&i<=id[now]+shu[now]-1)
        {
            cout<<1;
        }
        else
        {
            cout<<0;
        }
        if(i+1==id[now+1])
        {
            now++;
        }
    }
    return 0;
}
```
核心实现思想：先遍历字符串，统计每个 `1` 块的起始坐标和元素个数，然后将第 $K$ 个 `1` 块的起始坐标移动到第 $K - 1$ 个 `1` 块的终点坐标的下一位，最后根据坐标信息输出新字符串。

- **Moya_Rao（4星）**
    - **关键亮点**：使用四个变量分别记录第 $K - 1$ 个和第 $K$ 个 `1` 块的起始和结束下标，逻辑清晰，代码简洁。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,l1,r1,l2,r2,cnt;
string s;
int main(){
    cin>>n>>k>>s;
    for(int i=0;i<n;i++){
        if(s[i]=='0')continue;
        int x=i,y=i;
        while(s[i]=='1')i++;
        y=i-1;cnt++;
        if(cnt==k-1)l1=x,r1=y;
        if(cnt==k)l2=x,r2=y;
    }
    for(int i=0;i<n;i++){
        if(i==r1){
            cout<<s[i];
            for(int j=l2;j<=r2;j++)cout<<s[j];
        }
        else if(i>=l2&&i<=r2)continue;
        else cout<<s[i];
    }
    return 0;
}
```
核心实现思想：遍历字符串，找出第 $K - 1$ 个和第 $K$ 个 `1` 块的起始和结束下标，输出时，当遇到第 $K - 1$ 个 `1` 块的结束下标，先输出该字符，再输出第 $K$ 个 `1` 块，跳过第 $K$ 个 `1` 块原来的位置，其他字符正常输出。

- **Kratos_Charger（4星）**
    - **关键亮点**：将连续的 `0` 和 `1` 块存储在数组中，通过交换数组元素实现移动，代码结构清晰。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
string t,p[500005];
int main(){
    cin>>n>>k>>t;
    int cnt=0,st=0,ed=0,res=0;
    for(int i=0;i<n;i++){
        string sg;
        if(t[i]=='1'){
            while(i<n&&t[i]=='1'){
                sg+=t[i++];
            }
            i--;
            p[cnt]+=sg;
            if(res==k-2) st=cnt;
            if(res==k-1) ed=cnt;
            cnt++;
            res++;
        }
        else{
            while(i<n&&t[i]=='0'){
                sg+=t[i++];
            }
            i--;
            p[cnt]+=sg;
            cnt++;
        }
    }
    p[st]+=p[ed];
    for(int i=0;i<cnt;i++)
        if(i!=ed) cout<<p[i];
    return 0;
}
```
核心实现思想：遍历字符串，将连续的 `0` 和 `1` 块存储在数组 `p` 中，记录第 $K - 1$ 个和第 $K$ 个 `1` 块所在的数组下标，将第 $K$ 个 `1` 块拼接到第 $K - 1$ 个 `1` 块后面，最后输出除第 $K$ 个 `1` 块外的所有块。

### 最优关键思路或技巧
- 使用数组记录 `1` 块的起始坐标和长度，方便进行移动操作。
- 直接模拟输出过程，避免复杂的字符串拼接。

### 可拓展之处
同类型题目可能会要求移动多个块，或者对移动规则进行修改。类似算法套路可以应用于处理字符串中连续字符块的移动、合并等问题。

### 洛谷相似题目推荐
- [P1165 日志分析](https://www.luogu.com.cn/problem/P1165)：涉及对连续数据块的处理和统计。
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：需要对数据进行排序和去重，与本题对字符串中连续块的处理有一定相似性。
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：在处理数字过程中，可能需要对连续的数字段进行判断和处理。

### 个人心得摘录与总结
Moya_Rao 提到自己的做法相对复杂，鼓励读者查看其他题解学习更简便的方法，同时欢迎大家在评论区交流更多做法。这表明在解题过程中，要保持开放的心态，不断学习和借鉴他人的思路，以提高自己的解题能力。 

---
处理用时：67.56秒
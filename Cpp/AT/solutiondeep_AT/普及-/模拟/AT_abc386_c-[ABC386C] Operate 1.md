# 题目信息

# [ABC386C] Operate 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc386/tasks/abc386_c

**この問題は F 問題 (Operate K) の部分問題であり、 $ K=1 $ です。**  
 **F 問題に正解するコードをこの問題に提出することで、この問題に正解できます。**

文字列 $ S $ に対して以下の操作を $ 0 $ 回以上 $ K $ 回以下行って、文字列 $ T $ と一致させられるか判定してください。

- 次の $ 3 $ 種類の操作のうちひとつを選択し、実行する。
  - $ S $ 中の (先頭や末尾を含む) 任意の位置に、任意の文字を $ 1 $ つ挿入する。
  - $ S $ 中の文字を $ 1 $ つ選び、削除する。
  - $ S $ 中の文字を $ 1 $ つ選び、別の $ 1 $ つの文字に変更する。

## 说明/提示

### 制約

- $ S,T $ は英小文字からなる長さ $ 1 $ 以上 $ 500000 $ 以下の文字列
- $ \color{red}{K=1} $
 
### Sample Explanation 1

`abc` の $ 2 $ 文字目の `b` を `g` に置き換えることで、 `abc` を $ 1 $ 回の操作で `agc` に変換できます。

### Sample Explanation 2

$ 1 $ 回の操作では `abc` を `awtf` に変換できません。

### Sample Explanation 3

`abc` の $ 2 $ 文字目の `b` を削除することで、 `abc` を $ 1 $ 回の操作で `ac` に変換できます。

### Sample Explanation 4

`back` の $ 1 $ 文字目と $ 2 $ 文字目の間に `l` を挿入することで、 `back` を $ 1 $ 回の操作で `black` に変換できます。

### Sample Explanation 5

初めから $ S=T $ である場合もあります。

## 样例 #1

### 输入

```
1

abc

agc```

### 输出

```
Yes```

## 样例 #2

### 输入

```
1

abc

awtf```

### 输出

```
No```

## 样例 #3

### 输入

```
1

abc

ac```

### 输出

```
Yes```

## 样例 #4

### 输入

```
1

back

black```

### 输出

```
Yes```

## 样例 #5

### 输入

```
1

same

same```

### 输出

```
Yes```

## 样例 #6

### 输入

```
1

leap

read```

### 输出

```
No```

# AI分析结果

### 题目翻译
### [ABC386C] 操作 1

#### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc386/tasks/abc386_c

**本题是 F 问题（操作 K 次）的子问题，其中 $K = 1$。**
**通过将 F 问题的正确代码提交到本题，也能解决本题。**

请判断能否对字符串 $S$ 进行 0 次以上、$K$ 次以下的以下操作，使其与字符串 $T$ 一致。

- 从以下 3 种操作中选择一种并执行：
  - 在 $S$ 中的任意位置（包括开头和结尾）插入任意一个字符。
  - 从 $S$ 中选择一个字符并删除。
  - 从 $S$ 中选择一个字符并将其更改为另一个字符。

#### 说明/提示
##### 限制条件
- $S$ 和 $T$ 是由小写英文字母组成的字符串，长度在 1 到 500000 之间。
- $\color{red}{K = 1}$

##### 样例解释 1
将 `abc` 的第 2 个字符 `b` 替换为 `g`，可以通过 1 次操作将 `abc` 转换为 `agc`。

##### 样例解释 2
无法通过 1 次操作将 `abc` 转换为 `awtf`。

##### 样例解释 3
删除 `abc` 的第 2 个字符 `b`，可以通过 1 次操作将 `abc` 转换为 `ac`。

##### 样例解释 4
在 `back` 的第 1 个字符和第 2 个字符之间插入 `l`，可以通过 1 次操作将 `back` 转换为 `black`。

##### 样例解释 5
也可能一开始就有 $S = T$ 的情况。

#### 样例 #1
##### 输入
```
1
abc
agc
```
##### 输出
```
Yes
```

#### 样例 #2
##### 输入
```
1
abc
awtf
```
##### 输出
```
No
```

#### 样例 #3
##### 输入
```
1
abc
ac
```
##### 输出
```
Yes
```

#### 样例 #4
##### 输入
```
1
back
black
```
##### 输出
```
Yes
```

#### 样例 #5
##### 输入
```
1
same
same
```
##### 输出
```
Yes
```

#### 样例 #6
##### 输入
```
1
leap
read
```
##### 输出
```
No
```

### 综合分析与结论
这些题解的核心思路都是通过分类讨论字符串 $S$ 和 $T$ 的长度关系，来判断能否通过一次操作使两字符串相等。具体分类为长度相等、长度差为 1、长度差大于 1 这几种情况。各题解在处理不同长度情况时采用的具体方法有所差异，但本质都是围绕三种操作（插入、删除、替换）展开。

### 所选题解
- **作者：_anll_（4星）**
    - **关键亮点**：思路清晰，将问题分成四种情况讨论，代码结构良好，通过函数封装不同情况的处理逻辑，提高了代码的可读性和可维护性。
    - **核心代码**：
```cpp
void solve1(){
    int x=1,tot=0;
    for(int i=1;i<=n2;i++){
        while(x<=n1&&s1[x]!=s2[i])
            tot++,x++;
        if(x>n1) break;
        if(s1[x]==s2[i]) x++;
    }
    cout<<(tot>1?"No\n":"Yes\n");
}
void solve3(){
    int tot=0;
    for(int i=1;i<=n1;i++)
        if(s1[i]!=s2[i]) tot++;
    cout<<(tot>1?"No\n":"Yes\n");
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>t;
    cin>>s1>>s2;n1=s1.size(),n2=s2.size(),s1='6'+s1,s2='6'+s2;
    if(s1==s2) return cout<<"Yes\n",0;
    if(n1-n2==1) solve1();
    else if(n2-n1==1){
        swap(s1,s2);swap(n1,n2);
        solve1();
    }
    else if(n1==n2) solve3();
    else cout<<"No\n";
    return 0;
}
```
    - **核心实现思想**：`solve1` 函数处理长度差为 1 的情况，通过遍历字符串并记录不同字符的次数来判断是否可以通过一次操作使两字符串相等；`solve3` 函数处理长度相等的情况，统计不同字符的数量，若数量大于 1 则输出 `No`，否则输出 `Yes`。

- **作者：songlll（4星）**
    - **关键亮点**：思路简洁明了，通过字符串长度确定操作类型，并且将插入操作转化为删除操作，简化了代码逻辑。
    - **核心代码**：
```cpp
int main(){
    int k;
    cin>>k;
    string a,b;
    cin>>a>>b;
    if(abs((int)a.size()-(int)b.size())==1){
        if(a.size()>b.size())swap(a,b);
        int f=0;
        for(int i=0;i<b.size();i++){
            if(a[i]!=b[i+f]){
                if(f){
                    cout<<"No";
                    return 0;
                }
                f=1;
            }
        }
        cout<<"Yes";
        return 0;
    }
    else if(a.size()==b.size()){
        int cnt=0;
        for(int i=0;i<a.size();i++){
            if(a[i]!=b[i])cnt++;
        }
        if(cnt<=1)cout<<"Yes";
        else cout<<"No";
        return 0;
    }
    cout<<"No";
}
```
    - **核心实现思想**：当长度差为 1 时，将较短字符串与较长字符串比较，若遇到不同字符，标记已进行一次操作，若再次遇到不同字符则输出 `No`；当长度相等时，统计不同字符的数量，若数量小于等于 1 则输出 `Yes`，否则输出 `No`。

### 最优关键思路或技巧
- **分类讨论**：根据字符串长度关系分类讨论，不同情况采用不同的处理方法，使问题简化。
- **操作转化**：将插入操作转化为删除操作，减少代码的复杂度。

### 可拓展之处
同类型题目可能会增加操作次数 $K$，可以使用动态规划的方法来解决。类似的算法套路有编辑距离问题，通过动态规划计算将一个字符串转换为另一个字符串所需的最少操作次数。

### 洛谷相似题目推荐
- [P2758 编辑距离](https://www.luogu.com.cn/problem/P2758)
- [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)

### 个人心得摘录与总结
- **作者：_anll_**：提到打这道题时电脑死机，虽未对解题思路有直接影响，但反映出实际竞赛中可能会遇到意外情况。
总结：在竞赛中要做好应对意外情况的准备，保持冷静，确保代码能正常提交和运行。 

---
处理用时：43.76秒
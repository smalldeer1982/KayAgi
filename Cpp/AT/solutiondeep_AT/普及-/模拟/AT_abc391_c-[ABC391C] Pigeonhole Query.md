# 题目信息

# [ABC391C] Pigeonhole Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc391/tasks/abc391_c

$ N $ 匹の鳩がおり、 $ 1 $ から $ N $ までの番号がつけられています。また、 $ N $ 個の巣があり、 $ 1 $ から $ N $ までの番号がつけられています。はじめ、鳩 $ i $ は巣 $ i $ にいます $ (1\leq\ i\leq\ N) $。

$ Q $ 個のクエリが与えられるので順に処理してください。 クエリは $ 2 $ 種類あり、以下のいずれかの形式で与えられます。

- `1 P H` : 鳩 $ P $ を巣 $ H $ に移動させる。
- `2` : 複数の鳩がいる巣の個数を出力する。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 10^6 $
- $ 1\leq\ Q\leq\ 3\times\ 10^5 $
- $ 1\leq\ P,H\leq\ N $
- $ 1 $ つ目の形式のクエリについて、鳩 $ P $ は移動する前に巣 $ H $ にいない
- 入力は全て整数
 
### Sample Explanation 1

初め、鳩 $ 1,2,3,4 $ はそれぞれ巣 $ 1,2,3,4 $ にいます。 - $ 1 $ つ目のクエリについて、巣 $ 1,2,3,4 $ にはそれぞれ $ 1,1,1,1 $ 匹います。鳩が複数いる巣は存在しないので $ 0 $ を出力します。 - $ 2 $ つ目のクエリについて、鳩 $ 1 $ を巣 $ 2 $ に移動します。 - $ 3 $ つ目のクエリについて、巣 $ 1,2,3,4 $ にはそれぞれ $ 0,2,1,1 $ 匹います。鳩が複数いる巣は巣 $ 2 $ の $ 1 $ つなので $ 1 $ を出力します。 - $ 4 $ つ目のクエリについて、鳩 $ 3 $ を巣 $ 2 $ に移動します。 - $ 5 $ つ目のクエリについて、巣 $ 1,2,3,4 $ にはそれぞれ $ 0,3,0,1 $ 匹います。鳩が複数いる巣は巣 $ 2 $ の $ 1 $ つなので $ 1 $ を出力します。 - $ 6 $ つ目のクエリについて、鳩 $ 3 $ を巣 $ 4 $ に移動します。 - $ 7 $ つ目のクエリについて、巣 $ 1,2,3,4 $ にはそれぞれ $ 0,2,0,2 $ 匹います。鳩が複数いる巣は巣 $ 2,4 $ の $ 2 $ つなので $ 2 $ を出力します。

## 样例 #1

### 输入

```
4 7

2

1 1 2

2

1 3 2

2

1 3 4

2```

### 输出

```
0

1

1

2```

## 样例 #2

### 输入

```
5 10

2

1 4 3

1 4 5

2

1 3 1

2

1 2 3

1 2 5

1 1 3

2```

### 输出

```
0

1

2

1```

# AI分析结果

### 题目内容翻译
有 $N$ 只鸽子，分别被编号为 $1$ 到 $N$。同时，有 $N$ 个鸟巢，也分别被编号为 $1$ 到 $N$。最初，第 $i$ 只鸽子位于第 $i$ 个鸟巢中（$1\leq i\leq N$）。

现在会给出 $Q$ 个查询，请按顺序处理这些查询。查询有两种类型，每种类型的格式如下：
- `1 P H`：将第 $P$ 只鸽子移动到第 $H$ 个鸟巢。
- `2`：输出有超过一只鸽子的鸟巢的数量。

### 综合分析与结论
这些题解的核心思路都是模拟鸽子移动的过程，并实时维护有超过一只鸽子的鸟巢数量。大部分题解使用数组或 `map` 来记录每只鸽子所在的鸟巢和每个鸟巢中鸽子的数量，在操作 1 时更新这些信息并调整答案，操作 2 时直接输出答案。

#### 算法要点对比
- **数据结构选择**：多数题解使用数组，如 `a[i]` 记录第 $i$ 只鸽子所在的鸟巢，`cnt[i]` 记录第 $i$ 个鸟巢中鸽子的数量；部分题解使用 `map` 或 `unordered_map` 来实现相同功能。
- **答案更新**：在操作 1 中，当鸽子从一个鸟巢移动到另一个鸟巢时，判断原鸟巢和目标鸟巢的鸽子数量变化是否会影响有超过一只鸽子的鸟巢数量，进而更新答案。

#### 解决难点
本题的主要难点在于避免每次操作 2 时都遍历所有鸟巢来统计有超过一只鸽子的鸟巢数量，因此需要在操作 1 中实时更新答案，以达到 $O(N + Q)$ 的时间复杂度。

### 题解评分与选择
|作者|评分|理由|
| ---- | ---- | ---- |
|ikunTLE|4星|思路清晰，代码简洁，使用数组实现，时间复杂度为 $O(N + Q)$。|
|FlowerAccepted（Solution 2）|4星|优化了解法一，去掉 `std::map`，时间复杂度为 $O(N + Q)$，代码简洁易懂。|
|Cosine_Func|4星|思路清晰，核心代码简洁，明确指出时间复杂度为 $O(N + Q)$。|

### 所选题解
- **ikunTLE（4星）**
    - **关键亮点**：思路清晰，代码简洁，使用数组实现，避免了使用复杂的数据结构。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
int a[N],p[N];
signed main(){
    int n,q;
    cin>>n>>q;
    for(int i=1;i<=n;++i)
        a[i]=1,p[i]=i;
    int cnt=0;
    while(q--){
        int op;
        cin>>op;
        if(op==1){
            int x,y;
            cin>>x>>y;
            --a[p[x]];
            if(a[p[x]]==1)
                --cnt;
            p[x]=y,++a[y];
            if(a[y]==2)
                ++cnt;
        }
        else printf("%d\n",cnt);
    }
    return 0;
}
```
    - **核心实现思想**：使用 `a[i]` 记录第 $i$ 个鸟巢中鸽子的数量，`p[i]` 记录第 $i$ 只鸽子所在的鸟巢。在操作 1 中，先将原鸟巢的鸽子数量减 1，若减后为 1 则答案减 1；再将目标鸟巢的鸽子数量加 1，若加后为 2 则答案加 1。操作 2 直接输出答案。

- **FlowerAccepted（Solution 2，4星）**
    - **关键亮点**：优化了解法一，去掉 `std::map`，降低了时间复杂度，代码简洁。
    - **核心代码**：
```cpp
#include <iostream>
using namespace std;

int nest[1000005], pigeon[1000005];

int main() {
    int n, q, cnt, op, N, P;
    cin >> n >> q;
    cnt = 0;
    for (int i = 1; i <= n; i ++) {
        nest[i] = 1;
        pigeon[i] = i;
    }
    for (int i = 1; i <= q; i ++) {
        cin >> op;
        if (op == 1) {
            cin >> N >> P;
            if (nest[pigeon[N]] == 2) {
                cnt --;
            }
            if (nest[P] == 1) {
                cnt ++;
            }
            nest[pigeon[N]] --;
            pigeon[N] = P;
            nest[P] ++;
        } else {
            cout << cnt << '\n';
        }
    }
    return 0;
}
```
    - **核心实现思想**：使用 `nest[i]` 记录第 $i$ 个鸟巢中鸽子的数量，`pigeon[i]` 记录第 $i$ 只鸽子所在的鸟巢。在操作 1 中，若原鸟巢鸽子数量为 2 则答案减 1，若目标鸟巢鸽子数量为 1 则答案加 1，然后更新鸟巢鸽子数量和鸽子所在鸟巢。操作 2 直接输出答案。

- **Cosine_Func（4星）**
    - **关键亮点**：思路清晰，核心代码简洁，明确指出时间复杂度为 $O(N + Q)$。
    - **核心代码**：
```cpp
int n,q,ans,pos[N],cnt[N];
inline void Solve(){
    cin>>n>>q;
    ans=0;
    for(int i=1;i<=n;i++)
        pos[i]=i,cnt[i]=1;
    while(q--){
        int op,p,h;
        cin>>op;
        if(op==1){
            cin>>p>>h;
            cnt[pos[p]]--;
            cnt[h]++;
            if(cnt[pos[p]]==1)ans--;
            if(cnt[h]==2)ans++;
            pos[p]=h;
        }
        if(op==2){
            cout<<ans<<endl;
        }
    }
}
```
    - **核心实现思想**：使用 `pos[i]` 记录第 $i$ 只鸽子所在的鸟巢，`cnt[i]` 记录第 $i$ 个鸟巢中鸽子的数量。在操作 1 中，原鸟巢鸽子数量减 1，若减后为 1 则答案减 1；目标鸟巢鸽子数量加 1，若加后为 2 则答案加 1，同时更新鸽子所在鸟巢。操作 2 直接输出答案。

### 最优关键思路或技巧
- **实时更新答案**：在每次移动鸽子时，根据原鸟巢和目标鸟巢的鸽子数量变化实时更新有超过一只鸽子的鸟巢数量，避免了每次查询都遍历所有鸟巢，将时间复杂度从 $O(QN)$ 优化到 $O(N + Q)$。
- **使用数组记录信息**：使用数组记录每只鸽子所在的鸟巢和每个鸟巢中鸽子的数量，操作简单，时间复杂度低。

### 可拓展之处
同类型题或类似算法套路：
- **动态统计问题**：涉及动态修改和查询的问题，如动态维护区间和、动态维护集合元素数量等，都可以采用类似的实时更新思想。
- **模拟问题**：需要模拟一系列操作并统计结果的问题，如模拟游戏过程、模拟事件发生等，可使用数组或其他数据结构记录状态并实时更新。

### 洛谷相似题目推荐
- [P1168 中位数](https://www.luogu.com.cn/problem/P1168)：动态维护中位数，需要实时更新数据结构以支持插入和查询操作。
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：可以使用归并排序或树状数组等方法实时统计逆序对数量。
- [P2068 统计和](https://www.luogu.com.cn/problem/P2068)：动态维护区间和，需要根据操作实时更新区间和信息。

### 个人心得摘录与总结
- **天使宝贝**：在写判断时，需要防止多判或漏判。
    - **总结**：在处理条件判断时要仔细考虑各种情况，避免逻辑错误。
- **Jerry_zpl**：最初的代码超时，原因是每次都遍历了所有的鸟笼，后来改进为在操作一的时候就更新答案。
    - **总结**：对于需要频繁查询的数据，要避免每次查询都进行大量计算，可在数据修改时实时更新结果，以提高效率。

---
处理用时：56.11秒
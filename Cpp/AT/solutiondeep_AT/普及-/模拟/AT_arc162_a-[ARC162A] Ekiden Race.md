# 题目信息

# [ARC162A] Ekiden Race

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc162/tasks/arc162_a

$ 1 $ から $ N $ までの番号がつけられた $ N $ 人の人がある地点間を往復するレースを行いました。このレースについて、以下の情報が残されています。

- **往路**のタイムの早い順に順位をつけると、どの $ 2 $ 人のタイムも異なっており、人 $ i\ (1\ \leq\ i\ \leq\ N) $ は $ i $ 位であった。
- **往復**のタイム（往路のタイムと復路のタイムの合計）の早い順に順位をつけると、どの $ 2 $ 人のタイムも異なっており、人 $ i\ (1\ \leq\ i\ \leq\ N) $ は $ P_i $ 位であった。
- **復路**のタイムが最も早かった人（複数人いる場合はその全員）に**復路の区間賞**が与えられた。
 
ここで、$ P_1,\ P_2,\ \dots,\ P_N $ は $ 1,\ 2,\ \dots,\ N $ の並べ替えです。

このとき、**復路の区間賞**を与えられた可能性のある人は何人いるでしょうか？

$ T $ 個のテストケースが与えられるので、それぞれについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 500 $
- $ 2\ \leq\ N\ \leq\ 10^3 $
- $ P_1,\ P_2,\ \dots,\ P_N $ は $ 1,\ 2,\ \dots,\ N $ の並べ替えである
- 入力される数値は全て整数
- $ 1 $ つの入力に含まれるテストケースについて、$ N $ の総和は $ 10^3 $ 以下
 
### Sample Explanation 1

\- $ 1 $ つ目のテストケースでは、$ 2 $ 人でレースを行い、復路において人 $ 2 $ が人 $ 1 $ を抜かしています。この場合、復路の区間賞は人 $ 2 $ に与えられます。 - $ 2 $ つ目のテストケースでは、復路で順位が変動しておらず、どの人も復路の区間賞が与えられた可能性があります。

## 样例 #1

### 输入

```
3

2

2 1

4

1 2 3 4

20

13 2 7 1 5 9 3 4 12 10 15 6 8 14 20 16 19 18 11 17```

### 输出

```
1

4

7```

# AI分析结果

### 题目翻译
有编号从 1 到 N 的 N 个人进行了一场在两点间往返的比赛。关于这场比赛，留下了以下信息：
- **去程**按用时从快到慢排名，任意两人用时不同，第 i 个人（1 ≤ i ≤ N）排名第 i。
- **往返**总用时（去程用时与回程用时之和）按从快到慢排名，任意两人用时不同，第 i 个人（1 ≤ i ≤ N）排名第 Pi。
- **回程**用时最快的人（若有多人则为所有人）会获得**回程区间奖**。

这里，P1, P2, ..., PN 是 1, 2, ..., N 的一个排列。

此时，有多少人有可能获得**回程区间奖**呢？

会给出 T 个测试用例，请分别作答。

### 综合分析与结论
这些题解的核心思路都是判断每个人是否有可能获得回程区间奖，判断依据是如果一个人后面有比他最终名次更好的人，那么他就不可能获得回程区间奖。

- **思路对比**：大部分题解采用暴力枚举的方法，即对于每个人，检查他后面的所有人的名次是否比他好。而 Sammy_prime 的题解通过求后缀最小元素的个数来直接得出答案，时间复杂度为 $O(N)$，相比其他暴力枚举的 $O(N^2)$ 复杂度更优。
- **算法要点**：暴力枚举的题解主要是嵌套循环，外层循环遍历每个人，内层循环检查后面的人的名次。Sammy_prime 的题解是从后往前遍历数组，记录后缀最小值，统计后缀最小元素的个数。
- **解决难点**：本题的难点在于理解如何根据去程和往返的排名信息来判断回程的情况。各题解通过分析如果一个人被后面的人超过，那么他的回程用时就不可能是最快的，从而解决了这个问题。

### 所选题解
- **Sammy_prime（5星）**：
  - **关键亮点**：思路清晰，通过求后缀最小元素的个数直接得出答案，时间复杂度为 $O(N)$，代码简洁高效。
  - **重点代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int t,n,p[N]; 
int main(){
    scanf("%d",&t);
    while(t--){
        int ans=0,mn=N;
        scanf("%d",&n);
        for(int i=1;i<=n;++i) scanf("%d",p+i);
        for(int i=n;i>0;--i)
            if(p[i]<mn) ans++,mn=p[i];
        printf("%d\n",ans);
    }
    return 0;
}
```
**核心实现思想**：从后往前遍历数组，用 `mn` 记录后缀最小值，当当前元素小于 `mn` 时，说明该元素是后缀最小元素，答案加一，并更新 `mn`。

### 最优关键思路或技巧
可以采用逆向思维，不直接判断哪些人能获得回程区间奖，而是判断哪些人不能获得。如果一个人后面有比他最终名次更好的人，那么他就不可能获得回程区间奖。通过这种方式，Sammy_prime 的题解将问题转化为求后缀最小元素的个数，时间复杂度从 $O(N^2)$ 优化到了 $O(N)$。

### 可拓展之处
同类型的题目可能会有更多的条件限制，例如不同的排名规则、不同的比赛形式等。类似的算法套路可以用于处理一些与顺序、排名相关的问题，通过分析元素之间的大小关系来得出结论。

### 推荐题目
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)
- [P1271 选举学生会](https://www.luogu.com.cn/problem/P1271)
- [P1177 快速排序](https://www.luogu.com.cn/problem/P1177)

### 个人心得
本题解中没有明显的个人心得内容。 

---
处理用时：24.87秒
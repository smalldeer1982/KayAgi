# 题目信息

# [ABC333D] Erase Leaves

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_d

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる木が与えられます。 $ i $ 番目 $ (1\leq\ i\lt\ N) $ の辺は頂点 $ u\ _\ i $ と $ v\ _\ i $ を結んでいます。

次の操作を好きな回数繰り返すことを考えます。

- 葉である頂点 $ v $ を $ 1 $ つ選び、頂点 $ v $ およびそれに接続する辺をすべて削除する。
 
頂点 $ 1 $ を削除するまでに最小で操作を何回行う必要があるか求めてください。

 木とは？ 木とは、無向グラフのうち連結であって閉路がないものです。 詳しくはこちらをご覧ください: [Wikipedia「木 (数学)」](https://ja.wikipedia.org/wiki/%E6%9C%A8_(%E6%95%B0%E5%AD%A6))  葉とは？ 木の葉とは、木の頂点のうち次数がたかだか $ 1 $ であるものです。

## 说明/提示

### 制約

- $ 2\leq\ N\leq3\times10^5 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\lt\ N) $
- 与えられるグラフは木
- 入力はすべて整数
 
### Sample Explanation 1

与えられるグラフは次のようになります。 !\[\](https://img.atcoder.jp/abc333/6089239ee0c331bec4cd4472c032d197.png) たとえば、頂点 $ 9,8,7,6,1 $ の順に選んで操作を行うことで、$ 5 $ 回の操作で頂点 $ 1 $ を削除することができます。 !\[\](https://img.atcoder.jp/abc333/7dba9a660bfabdd403fe6882dac4e8ab.png) $ 4 $ 回以下の操作では頂点 $ 1 $ を削除することはできないため、$ 5 $ を出力してください。

### Sample Explanation 2

与えられたグラフにおいて、頂点 $ 1 $ は葉です。 よって、$ 1 $ 回目の操作で頂点 $ 1 $ を選んで削除することができます。

## 样例 #1

### 输入

```
9

1 2

2 3

2 4

2 5

1 6

6 7

7 8

7 9```

### 输出

```
5```

## 样例 #2

### 输入

```
6

1 2

2 3

2 4

3 5

3 6```

### 输出

```
1```

## 样例 #3

### 输入

```
24

3 6

7 17

7 20

7 11

14 18

17 21

6 19

5 22

9 24

11 14

6 23

8 17

9 12

4 17

2 15

1 17

3 9

10 16

7 13

2 16

1 16

5 7

1 3```

### 输出

```
12```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个由顶点 $1, 2, \ldots, N$ 组成的 $N$ 个顶点的树。第 $i$ 条边（$1 \leq i < N$）连接顶点 $u_i$ 和 $v_i$。

考虑以下操作，可以重复任意次数：

- 选择一个叶子顶点 $v$，删除顶点 $v$ 及其所有连接的边。

求删除顶点 $1$ 所需的最小操作次数。

**说明/提示**

- **树**：无向图，连通且无环。
- **叶子**：度数为 $1$ 的顶点。

**样例输入输出**

**样例 1**

输入：
```
9
1 2
2 3
2 4
2 5
1 6
6 7
7 8
7 9
```
输出：
```
5
```

**样例 2**

输入：
```
6
1 2
2 3
2 4
3 5
3 6
```
输出：
```
1
```

### 题解分析与结论

本题的核心思路是通过删除叶子节点，最终使得顶点 $1$ 成为叶子节点，从而可以被删除。为了最小化操作次数，我们需要保留顶点 $1$ 的最大子树，删除其他子树。这样，操作次数为总节点数减去最大子树的节点数。

### 精选题解

#### 题解 1：作者：Hughpig (4星)

**关键亮点**：
- 通过 DFS 计算每个子树的大小。
- 直接找出顶点 $1$ 的最大子树，计算需要删除的节点数。

**代码核心思想**：
```cpp
void calc(int u, int fa) {
    sz[u] = 1;
    for (int v : G[u]) {
        if (fa == v) continue;
        calc(v, u);
        sz[u] += sz[v];
    }
}

int main() {
    // 输入处理
    if (deg[1] == 1) cout << 1;
    else {
        calc(1, 0);
        for (int i : G[1]) {
            ans = max(ans, sz[i]);
            sum += sz[i];
        }
        cout << sum - ans + 1;
    }
}
```

#### 题解 2：作者：BLuemoon_ (4星)

**关键亮点**：
- 通过 DFS 计算子树大小，保留最大子树。
- 代码简洁，逻辑清晰。

**代码核心思想**：
```cpp
void S(int x, int fa) {
    cnt++;
    for (int i : g[x]) {
        if (i != fa) {
            S(i, x);
        }
    }
}

int main() {
    // 输入处理
    for (int i : g[1]) {
        cnt = 0, S(i, 1);
        ans = max(ans, cnt);
    }
    cout << n - ans;
}
```

#### 题解 3：作者：2huk (4星)

**关键亮点**：
- 通过 DFS 计算子树大小，保留最大子树。
- 代码简洁，逻辑清晰。

**代码核心思想**：
```cpp
void dfs(int u, int fa) {
    siz[u] = 1;
    for (int v : G[u]) {
        if (v != fa) {
            dfs(v, u);
            siz[u] += siz[v];
        }
    }
}

int main() {
    // 输入处理
    dfs(1, 0);
    cout << n - siz[son[1]];
}
```

### 最优关键思路与技巧

1. **DFS 计算子树大小**：通过 DFS 遍历树，计算每个子树的大小，便于后续选择保留最大子树。
2. **保留最大子树**：为了最小化操作次数，保留顶点 $1$ 的最大子树，删除其他子树。
3. **边界条件处理**：如果顶点 $1$ 已经是叶子节点，直接输出 $1$。

### 可拓展之处

- **类似题目**：可以考虑其他树形结构的问题，如树的直径、树的重心等。
- **算法优化**：可以进一步优化 DFS 的实现，减少递归深度，提高效率。

### 推荐题目

1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)
3. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)

### 个人心得摘录

- **调试经历**：在处理边界条件时，容易忽略顶点 $1$ 已经是叶子节点的情况，导致错误。
- **顿悟感想**：通过保留最大子树，可以最小化操作次数，这一思路在树形问题中非常常见。

---
处理用时：43.38秒
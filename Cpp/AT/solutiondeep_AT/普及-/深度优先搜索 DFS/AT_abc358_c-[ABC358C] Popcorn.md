# 题目信息

# [ABC358C] Popcorn

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc358/tasks/abc358_c

AtCoder Land には $ 1 $ から $ N $ までの番号が付けられた $ N $ 個のポップコーン売り場があります。 売られているポップコーンの味には味 $ 1,2,\dots,M $ の $ M $ 種類がありますが、すべての売り場ですべての味のポップコーンを売っているわけではありません。

高橋君は、それぞれのポップコーン売り場でどの味のポップコーンを売っているかの情報を入手しました。 この情報は $ N $ 個の長さ $ M $ の文字列 $ S_1,S_2,\dots,S_N $ によって表され、$ S_i $ の $ j $ 文字目が `o` であるとき売り場 $ i $ が味 $ j $ のポップコーンを売っていることを、 `x` であるとき売っていないことを示します。 どの売り場も最低 $ 1 $ 種類の味のポップコーンを売っており、どの味のポップコーンも最低 $ 1 $ つの売り場で売られています。

高橋君は全種類のポップコーンを食べたがっていますが、あまり何度も移動はしたくありません。 高橋君がすべての味のポップコーンを購入するためには最低何個の売り場を訪れる必要があるか求めてください。

## 说明/提示

### 制約

- $ N,M $ は整数
- $ 1\leq\ N,M\ \leq\ 10 $
- $ S_i $ は `o` および `x` からなる長さ $ M $ の文字列
- すべての $ i\ (1\leq\ i\leq\ N) $ について、$ S_i $ の中には `o` が $ 1 $ つ以上存在する
- すべての $ j\ (1\leq\ j\leq\ M) $ について、$ S_i $ の $ j $ 文字目が `o` であるような $ i $ が $ 1 $ つ以上存在する
 
### Sample Explanation 1

$ 1 $ つめの売り場と $ 3 $ つめの売り場を訪れることで、すべての味のポップコーンを購入することができます。 $ 1 $ つの売り場ですべての味のポップコーンを購入することはできないので、答えは $ 2 $ です。

## 样例 #1

### 输入

```
3 5

oooxx

xooox

xxooo```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2

oo

ox

xo```

### 输出

```
1```

## 样例 #3

### 输入

```
8 6

xxoxxo

xxoxxx

xoxxxx

xxxoxx

xxoooo

xxxxox

xoxxox

oxoxxo```

### 输出

```
3```

# AI分析结果

### 题目翻译
在 AtCoder 乐园里，有 $N$ 个爆米花摊位，编号为 $1$ 到 $N$。这些摊位售卖 $M$ 种不同口味的爆米花，口味编号为 $1$ 到 $M$。每个摊位不一定售卖所有口味的爆米花。

高桥君得到了每个摊位售卖爆米花的信息，这些信息由 $N$ 个长度为 $M$ 的字符串 $S_1, S_2, \dots, S_N$ 表示。其中，$S_i$ 的第 $j$ 个字符为 `o` 表示摊位 $i$ 售卖口味 $j$ 的爆米花，为 `x` 则表示不售卖。每个摊位至少售卖一种口味的爆米花，每种口味的爆米花至少在一个摊位售卖。

高桥君想要品尝所有口味的爆米花，但他不想频繁移动。请问他最少需要去多少个摊位才能买到所有口味的爆米花？

### 样例 #1
#### 输入
```
3 5
oooxx
xooox
xxooo
```
#### 输出
```
2
```

### 样例 #2
#### 输入
```
3 2
oo
ox
xo
```
#### 输出
```
1
```

### 样例 #3
#### 输入
```
8 6
xxoxxo
xxoxxx
xoxxxx
xxxoxx
xxoooo
xxxxox
xoxxox
oxoxxo
```
#### 输出
```
3
```

---

### 题解分析与结论
本题的核心是通过枚举所有可能的摊位组合，找到能够覆盖所有爆米花口味的最小摊位数量。由于 $N$ 和 $M$ 的范围都很小（$1 \leq N, M \leq 10$），因此可以直接使用暴力搜索或位运算枚举的方法来解决。

### 精选题解

#### 1. 作者：stripe_python (赞：4)
**星级：★★★★★**
**关键亮点：**
- 使用 DFS 进行回溯搜索，代码简洁清晰。
- 通过 `vis` 数组记录已经购买的口味，`p` 数组记录已经访问的摊位。
- 使用 `unordered_set` 来记录当前摊位购买的口味，方便回溯时恢复状态。

**核心代码：**
```cpp
void dfs(int step) {
	if (check()) return res = min(res, step), void();
	for (int i = 1; i <= n; i++) {
		if (p[i]) continue;
		p[i] = true;
		unordered_set<int> st;
		for (int j = 1; j <= m; j++) {
			if (s[i][j] == 'o' && !vis[j]) vis[j] = true, st.emplace(j);
		}
		dfs(step + 1);
		p[i] = false;
		for (int j = 1; j <= m; j++) {
			if (s[i][j] == 'o' && st.count(j)) vis[j] = false;
		}
	}
}
```

#### 2. 作者：zhujiangyuan (赞：4)
**星级：★★★★★**
**关键亮点：**
- 使用 DFS 进行搜索，每个摊位有选和不选两种选择。
- 通过 `vis` 数组记录已经购买的口味，回溯时恢复状态。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
void dfs(int k, int cnt) {
	if (k == n + 1) {
		bool flag = 0;
		for (int i = 1; i <= m; i++)
			if (!vis[i]) flag = 1;
		if (!flag) ans = min(ans, cnt);
		return;
	}
	for (int i = 1; i <= m; i++)
		vis[i] += (s[k][i] == 'o');
	dfs(k + 1, cnt + 1);
	for (int i = 1; i <= m; i++)
		vis[i] -= (s[k][i] == 'o');
	dfs(k + 1, cnt);
}
```

#### 3. 作者：nightwatch.ryan (赞：1)
**星级：★★★★**
**关键亮点：**
- 使用位运算来压缩状态，将每个摊位的售卖信息转化为二进制数。
- 通过枚举所有可能的摊位组合，使用按位或操作来检查是否覆盖所有口味。
- 代码简洁，时间复杂度为 $O(2^N \times N \times M)$。

**核心代码：**
```cpp
for (int i = 1; i < (1 << n); i++) {
	int p = 0, result = 0;
	for (int j = 0; j < n; j++)
		if (i & (1 << j)) p |= bit[j], result++;
	if (p == check) ans = min(ans, result);
}
```

### 最优关键思路与技巧
1. **DFS 回溯**：通过 DFS 遍历所有可能的摊位组合，使用回溯来恢复状态，确保不遗漏任何可能的组合。
2. **位运算压缩状态**：将每个摊位的售卖信息转化为二进制数，通过按位或操作快速判断是否覆盖所有口味。
3. **剪枝优化**：在搜索过程中，如果当前选择的摊位数量已经大于已知的最小值，可以直接剪枝，减少不必要的计算。

### 拓展思路
- **类似题目**：这类问题可以扩展到其他需要覆盖所有元素的场景，如集合覆盖问题、任务分配问题等。
- **优化思路**：对于更大的数据集，可以考虑使用启发式搜索或动态规划来优化时间复杂度。

### 推荐题目
1. [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1463 [POI2001] 反素数](https://www.luogu.com.cn/problem/P1463)

### 个人心得
- **调试经历**：在 DFS 回溯时，确保状态恢复的正确性非常重要，特别是在使用 `unordered_set` 或 `vis` 数组时，避免遗漏恢复步骤。
- **踩坑教训**：在枚举摊位组合时，注意二进制数的位数与摊位的对应关系，避免索引错误。

---
处理用时：62.39秒
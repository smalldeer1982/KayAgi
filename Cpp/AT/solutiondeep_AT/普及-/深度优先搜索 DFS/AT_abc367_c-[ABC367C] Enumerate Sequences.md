# 题目信息

# [ABC367C] Enumerate Sequences

## 题目描述

给定长度为 $n$ 的正整数序列 $(r_1, \ldots, r_n)$ 和正整数 $k$。

以字典序从小到大的顺序输出所有满足 $1 \le a_i \le r_i$ 且 $a_1 + \cdots + a_n$ 是 $k$ 的倍数的长度为 $n$ 的整数序列 $(a_1, \ldots, a_n)$。

数据范围：$n \le 8$，$1 \le r_i \le 5$，$2 \le k \le 10$。

## 样例 #1

### 输入

```
3 2

2 1 3```

### 输出

```
1 1 2

2 1 1

2 1 3```

## 样例 #2

### 输入

```
1 2

1```

### 输出

```
```

## 样例 #3

### 输入

```
5 5

2 3 2 3 2```

### 输出

```
1 1 1 1 1

1 2 2 3 2

1 3 1 3 2

1 3 2 2 2

1 3 2 3 1

2 1 2 3 2

2 2 1 3 2

2 2 2 2 2

2 2 2 3 1

2 3 1 2 2

2 3 1 3 1

2 3 2 1 2

2 3 2 2 1```

# AI分析结果

### 题目内容重写

#### [ABC367C] 枚举序列

#### 题目描述

给定长度为 $n$ 的正整数序列 $(r_1, \ldots, r_n)$ 和正整数 $k$。

以字典序从小到大的顺序输出所有满足 $1 \le a_i \le r_i$ 且 $a_1 + \cdots + a_n$ 是 $k$ 的倍数的长度为 $n$ 的整数序列 $(a_1, \ldots, a_n)$。

数据范围：$n \le 8$，$1 \le r_i \le 5$，$2 \le k \le 10$。

#### 样例 #1

##### 输入

```
3 2

2 1 3
```

##### 输出

```
1 1 2

2 1 1

2 1 3
```

#### 样例 #2

##### 输入

```
1 2

1
```

##### 输出

```
```

#### 样例 #3

##### 输入

```
5 5

2 3 2 3 2
```

##### 输出

```
1 1 1 1 1

1 2 2 3 2

1 3 1 3 2

1 3 2 2 2

1 3 2 3 1

2 1 2 3 2

2 2 1 3 2

2 2 2 2 2

2 2 2 3 1

2 3 1 2 2

2 3 1 3 1

2 3 2 1 2

2 3 2 2 1
```

### 综合分析与结论

本题的核心是通过深度优先搜索（DFS）枚举所有可能的序列，并检查其和是否为 $k$ 的倍数。由于数据范围较小（$n \le 8$，$r_i \le 5$），直接暴力搜索即可通过。所有题解都采用了类似的思路，即通过递归枚举每个位置的可能取值，并在递归结束时检查和是否为 $k$ 的倍数。

### 最优关键思路与技巧

1. **DFS 枚举**：通过递归枚举每个位置的可能取值，确保所有可能的序列都被检查。
2. **字典序输出**：由于 DFS 是从小到大枚举每个位置的取值，因此输出的序列自然满足字典序。
3. **回溯**：在递归返回时，恢复状态（如 `sum` 和 `a[i]`），以确保下一次递归的正确性。

### 可拓展之处

- **剪枝优化**：如果数据范围更大，可以考虑剪枝优化，例如在递归过程中提前判断当前和是否可能达到 $k$ 的倍数。
- **动态规划**：如果题目改为求满足条件的序列数量，可以考虑使用动态规划来优化时间复杂度。

### 推荐题目

1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

### 精选题解

#### 题解1：作者：OGCoder (赞：9)

**星级：5星**

**关键亮点**：
- 代码简洁，逻辑清晰。
- 使用了全局变量 `b` 来记录当前序列，`sum` 来记录当前和，递归结束时直接输出满足条件的序列。

**核心代码**：
```cpp
void dfs(int u, int sum = 0) {
    if (u == n + 1) {
        if (sum % k != 0) return;
        for (int i = 1; i < u; i++) cout << b[i] << ' ';
        cout << endl;
        return;
    }
    for (int i = 1; i <= r[u]; i++) {
        b[u] = i;
        dfs(u + 1, sum + i);
        b[u] = 0;
    }
}
```

#### 题解2：作者：chinazhanghaoxun (赞：7)

**星级：4星**

**关键亮点**：
- 代码结构清晰，注释详细。
- 使用了 `sum` 变量来记录当前和，并在递归结束时检查和是否为 $k$ 的倍数。

**核心代码**：
```cpp
void dfs(int ns) {
    if (ns > n) {
        if (sum % k == 0) {
            for (int i = 1; i <= n; i++)
                cout << ans[i] << ' ';
            cout << endl;
        }
        return;
    }
    for (int i = 1; i <= r[ns]; i++) {
        ans[ns] = i;
        sum += i;
        dfs(ns + 1);
        sum -= i;
    }
}
```

#### 题解3：作者：linch (赞：2)

**星级：4星**

**关键亮点**：
- 代码简洁，逻辑清晰。
- 使用了 `dep` 和 `sum` 变量来记录当前递归深度和当前和，递归结束时直接输出满足条件的序列。

**核心代码**：
```cpp
void dfs(int dep, int sum) {
    if (dep > n) {
        if (sum % k == 0) {
            for (int i = 1; i <= n; i++) {
                cout << a[i] << " ";
            }
            cout << "\n";
        }
        return;
    }
    for (int i = 1; i <= r[dep]; i++) {
        a[dep] = i;
        dfs(dep + 1, sum + i);
    }
}
```

### 个人心得

- **调试经历**：在实现 DFS 时，确保每次递归返回时状态被正确恢复是关键，否则会导致后续递归结果错误。
- **踩坑教训**：在递归结束时，一定要记得返回，否则会导致程序继续执行，产生错误结果。
- **顿悟感想**：DFS 的递归顺序自然保证了字典序，因此不需要额外的排序操作。

---
处理用时：53.23秒
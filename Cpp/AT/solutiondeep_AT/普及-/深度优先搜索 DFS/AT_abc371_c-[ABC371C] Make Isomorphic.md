# 题目信息

# [ABC371C] Make Isomorphic

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_c

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる単純無向グラフ $ G,H $ が与えられます。 $ G $ には $ M\ _\ G $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ G) $ の辺は頂点 $ u\ _\ i $ と頂点 $ v\ _\ i $ を結んでいます。 $ H $ には $ M\ _\ H $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ H) $ の辺は頂点 $ a\ _\ i $ と頂点 $ b\ _\ i $ を結んでいます。

あなたは、グラフ $ H $ に対して次の操作を $ 0 $ 回以上の好きな回数繰り返すことができます。

- $ 1\leq\ i\lt\ j\leq\ N $ を満たす整数の組 $ (i,j) $ をひとつ選ぶ。$ A\ _\ {i,j} $ 円を支払って、頂点 $ i $ と頂点 $ j $ を結ぶ辺がなければ追加し、あれば取り除く。

$ G $ と $ H $ を同型にするために少なくとも何円支払う必要があるか求めてください。

単純無向グラフとは？ **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

グラフの同型とは？ $ N $ 頂点のグラフ $ G $ と $ H $ が**同型**であるとは、ある $ (1,2,\ldots,N) $ の並べ替え $ (P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が存在して、どの $ 1\leq\ i\lt\ j\leq\ N $ に対しても

- $ G $ に頂点 $ i, $ 頂点 $ j $ を結ぶ辺が存在するとき、かつそのときに限り $ H $ に頂点 $ P\ _\ i, $ 頂点 $ P\ _\ j $ を結ぶ辺が存在する

が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq8 $
- $ 0\leq\ M\ _\ G\leq\dfrac{N(N-1)}2 $
- $ 0\leq\ M\ _\ H\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ G) $
- $ (u\ _\ i,v\ _\ i)\neq(u\ _\ j,v\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ G) $
- $ 1\leq\ a\ _\ i\lt\ b\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ H) $
- $ (a\ _\ i,b\ _\ i)\neq(a\ _\ j,b\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ H) $
- $ 1\leq\ A\ _\ {i,j}\leq\ 10\ ^\ 6\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

与えられたグラフはそれぞれ以下のようになります。 !\[\](https://img.atcoder.jp/abc371/fbdb304dc71eecd7ddec97276a9c7040.png) たとえば、$ H $ に対して次のような $ 4 $ つの操作を順に行うことで、$ 9 $ 円を支払って$ G $ と $ H $ を同型にすることができます。 - $ (i,j)=(1,3) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(2,5) $ として操作を行う。$ H $ には頂点 $ 2 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 2 $ 円を支払ってこれを追加する。 - $ (i,j)=(1,5) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 5 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(3,5) $ として操作を行う。$ H $ には頂点 $ 3 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 5 $ 円を支払ってこれを追加する。 操作の結果、$ H $ は以下のようになります。 !\[\](https://img.atcoder.jp/abc371/68a56da8ec89b769989ae7d07bf163cd.png) 支払う金額を $ 8 $ 円以下にして $ G $ と $ H $ を同型にすることはできないため、`9` を出力してください。

### Sample Explanation 2

たとえば、$ (i,j)=(2,3),(2,4),(3,4) $ とした $ 3 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 3

たとえば、$ (i,j)=(4,5) $ とした $ 1 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 4

$ G $ や $ H $ には辺が含まれていないこともあります。 また、一度も操作をする必要がないこともあります。

## 样例 #1

### 输入

```
5
4
1 2
2 3
3 4
4 5
4
1 2
1 3
1 4
1 5
3 1 4 1
5 9 2
6 5
3```

### 输出

```
9```

## 样例 #2

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
9 1 1 1
1 1 1
1 1
9```

### 输出

```
3```

## 样例 #3

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
5 4 4 4
4 4 4
4 4
5```

### 输出

```
5```

## 样例 #4

### 输入

```
2
0
0
371```

### 输出

```
0```

## 样例 #5

### 输入

```
8
13
1 8
5 7
4 6
1 5
7 8
1 6
1 2
5 8
2 6
5 6
6 7
3 7
4 8
15
3 5
1 7
4 6
3 8
7 8
1 2
5 6
1 6
1 5
1 4
2 8
2 6
2 4
4 7
1 3
7483 1694 5868 3296 9723 5299 4326
5195 4088 5871 1384 2491 6562
1149 6326 2996 9845 7557
4041 7720 1554 5060
8329 8541 3530
4652 3874
3748```

### 输出

```
21214```

# AI分析结果

### 题目重写（中文）

**题目描述：**

给定两个简单无向图 \(G\) 和 \(H\)，每个图都有 \(N\) 个顶点。\(G\) 有 \(M_G\) 条边，\(H\) 有 \(M_H\) 条边。你可以对 \(H\) 进行任意次数的操作，每次操作选择两个顶点 \(i\) 和 \(j\)，支付 \(A_{i,j}\) 日元来添加或删除 \(i\) 和 \(j\) 之间的边。求使 \(G\) 和 \(H\) 同构的最小总成本。

**说明/提示：**

- 简单无向图是指没有自环和多重边的无向图。
- 两个图同构是指存在一个顶点的排列，使得两个图的边关系完全对应。

### 题解分析与结论

#### 综合分析
本题的核心在于通过全排列枚举所有可能的顶点映射关系，计算每种映射下的最小成本。由于 \(N \leq 8\)，全排列的复杂度 \(O(N!)\) 是可接受的。所有题解都采用了这一思路，但在实现细节上有所不同。

#### 最优思路与技巧
1. **全排列枚举**：使用 `next_permutation` 或 DFS 生成所有可能的顶点排列。
2. **邻接矩阵存储**：使用邻接矩阵存储图的边关系，方便快速查询。
3. **成本计算**：对于每种排列，遍历所有边对，计算不一致的边的成本，并取最小值。

#### 可拓展之处
- **图同构问题**：类似问题可以通过全排列枚举解决，适用于小规模图。
- **优化思路**：对于大规模图，可以考虑启发式算法或剪枝策略。

### 推荐题目
1. [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)
2. [P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)
3. [P3388 【模板】割点](https://www.luogu.com.cn/problem/P3388)

### 精选题解

#### 题解1：Him_shu (4星)
**关键亮点：**
- 使用 DFS 生成全排列，代码结构清晰。
- 邻接矩阵存储，方便查询边关系。

**核心代码：**
```cpp
void dfs(int pos){
    if(pos>n){
        for(int i=1;i<=m1;i++){
            h[hg[u1[i]]][hg[v1[i]]]=h[hg[v1[i]]][hg[u1[i]]]=1;
        }
        int sum=0;
        for(int i=1;i<n;i++){
            for(int j=i+1;j<=n;j++){
                if(h[i][j]==g[i][j]) continue;
                sum+=a[i][j];
            }
        }
        ans=min(ans,sum);
        memset(h,0,sizeof(h));
        return;
    }
    for(int i=1;i<=n;i++){
        if(!hg[i]){
            hg[i]=pos;
            dfs(pos+1);
            hg[i]=0;
        }
    }
}
```

#### 题解2：small_lemon_qwq (4星)
**关键亮点：**
- 使用 `next_permutation` 生成全排列，代码简洁。
- 直接计算每种排列的成本，逻辑清晰。

**核心代码：**
```cpp
void dfs(int x){
    if(x>n){
        int cnt=0;
        for(int i=1;i<=n;i++){
            for(int j=i+1;j<=n;j++){
                if(f[p[i]][p[j]]!=g[i][j]) cnt+=a[i][j];
            }
        }
        ans=min(ans,cnt);
    }else{
        for(int i=1;i<=n;i++){
            if(!vis[i]){
                p[x]=i;
                vis[i]=1;
                dfs(x+1);
                vis[i]=0;
            }
        }
    }
}
```

#### 题解3：RedStoneShark (4星)
**关键亮点：**
- 使用 `next_permutation` 生成全排列，代码简洁。
- 直接计算每种排列的成本，逻辑清晰。

**核心代码：**
```cpp
void dfs(int pos){
    if(pos>n){
        for(int i=1;i<=m1;i++){
            h[hg[u1[i]]][hg[v1[i]]]=h[hg[v1[i]]][hg[u1[i]]]=1;
        }
        int sum=0;
        for(int i=1;i<n;i++){
            for(int j=i+1;j<=n;j++){
                if(h[i][j]==g[i][j]) continue;
                sum+=a[i][j];
            }
        }
        ans=min(ans,sum);
        memset(h,0,sizeof(h));
        return;
    }
    for(int i=1;i<=n;i++){
        if(!hg[i]){
            hg[i]=pos;
            dfs(pos+1);
            hg[i]=0;
        }
    }
}
```

### 个人心得摘录
- **调试经历**：在计算成本时，需要注意边的双向性，避免重复计算。
- **踩坑教训**：初始化邻接矩阵时，确保所有边关系正确存储。
- **顿悟感想**：全排列枚举虽然简单，但在小规模问题中非常有效。

---
处理用时：43.89秒
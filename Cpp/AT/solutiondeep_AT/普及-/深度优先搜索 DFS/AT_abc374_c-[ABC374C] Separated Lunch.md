# 题目信息

# [ABC374C] Separated Lunch

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_c

キーエンス本社に勤務する人数が増えてきたので、本社に存在する部署を $ 2 $ つのグループに分け、昼休みの時間帯を分けることにしました。

キーエンス本社には $ N $ 個の部署が存在し、$ i $ 番目 $ (1\leq\ i\leq\ N) $ の部署に所属する人数は $ K_i $ 人です。

それぞれの部署をグループ $ A $, $ B $ のいずれか一方に割り当て、グループごとに同時に昼休みをとり、 かつグループ $ A $, $ B $ の昼休みの時間が重ならないようにしたとき、同時に昼休みをとる最大人数としてあり得る最小の値を求めてください。  
 すなわち、グループ $ A $ に割り当てられた部署に所属する人数の合計とグループ $ B $ に割り当てられた部署に所属する人数の合計 のうち大きい方の値としてあり得る最小の値を求めてください。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 20 $
- $ 1\leq\ K_i\ \leq\ 10^8 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1,2,5 $ 番目の部署をグループ $ A $ に、$ 3,4 $ 番目の部署をグループ $ B $ に割り当てたとき、 グループ $ A $ に割り当てられた部署に所属する人数の合計は $ 2+3+12=17 $ 、 グループ $ B $ に割り当てられた部署に所属する人数の合計は $ 5+10=15 $ となり、 このとき同時に昼休みを取る最大人数は $ 17 $ となります。 一方で、グループ $ A,B $ それぞれに割り当てられた部署に所属する人数の合計がいずれも $ 16 $ 以下になるように 部署を割り当てることはできないため、$ 17 $ を出力します。

### Sample Explanation 2

同一人数の部署が複数存在する可能性もあります。

### Sample Explanation 3

例えば、$ 1,4,5 $ 番目の部署をグループ $ A $ に、$ 2,3,6 $ 番目の部署をグループ $ B $ に割り当てたとき同時に昼休みを取る最大人数は $ 89 $ となります。

## 样例 #1

### 输入

```
5

2 3 5 10 12```

### 输出

```
17```

## 样例 #2

### 输入

```
2

1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
6

22 25 26 45 22 31```

### 输出

```
89```

# AI分析结果

### 题目内容重写

【题目描述】

キーエンス本社に勤務する人数が増えてきたので、本社に存在する部署を $ 2 $ つのグループに分け、昼休みの時間帯を分けることにしました。

キーエンス本社には $ N $ 個の部署が存在し、$ i $ 番目 $ (1\leq\ i\leq\ N) $ の部署に所属する人数は $ K_i $ 人です。

それぞれの部署をグループ $ A $, $ B $ のいずれか一方に割り当て、グループごとに同時に昼休みをとり、 かつグループ $ A $, $ B $ の昼休みの時間が重ならないようにしたとき、同時に昼休みをとる最大人数としてあり得る最小の値を求めてください。  
 すなわち、グループ $ A $ に割り当てられた部署に所属する人数の合計とグループ $ B $ に割り当てられた部署に所属する人数の合計 のうち大きい方の値としてあり得る最小の値を求めてください。

【说明/提示】

### 制約

- $ 2\leq\ N\ \leq\ 20 $
- $ 1\leq\ K_i\ \leq\ 10^8 $
- 入力はすべて整数
 
### 样例解释

**样例 1**

输入：

```
5
2 3 5 10 12
```

输出：

```
17
```

解释：将第1、2、5个部门分配到组A，第3、4个部门分配到组B，组A的总人数为17，组B的总人数为15，因此最大人数为17。

**样例 2**

输入：

```
2
1 1
```

输出：

```
1
```

解释：将两个部门分别分配到组A和组B，最大人数为1。

**样例 3**

输入：

```
6
22 25 26 45 22 31
```

输出：

```
89
```

解释：将第1、4、5个部门分配到组A，第2、3、6个部门分配到组B，组A的总人数为89，组B的总人数为82，因此最大人数为89。

### 题解分析与结论

该题目要求将N个部门分成两组，使得两组人数的最大值最小化。由于N的范围较小（2 ≤ N ≤ 20），可以采用暴力枚举或深度优先搜索（DFS）的方法来解决。以下是对各题解的总结与评分：

1. **A_R_O_N_A的题解**（4星）
   - 亮点：使用二进制枚举的方法，通过状压DP的思想，简洁高效地解决了问题。
   - 代码实现：通过二进制数表示状态，计算每种状态下的总和，最后取最小值。
   - 核心代码：
     ```cpp
     for(int i=0;i<(1<<n);i++){
         for(int j=0;j<n;j++){
             if(i&(1<<j))dp[i]+=a[j];
         }
     }
     for(int i=0;i<(1<<n);i++){
         ans=min(ans,max(dp[i],sum-dp[i]));
     }
     ```

2. **fishing_cat的题解**（4星）
   - 亮点：使用DFS进行暴力搜索，代码简洁易懂，适合初学者理解。
   - 代码实现：通过递归枚举每个部门的分配情况，最后取最小值。
   - 核心代码：
     ```cpp
     void dfs(ll id, ll now) {
         if (id > n) {
             ans = min(ans,max(now, z - now));
             return ;
         }
         dfs(id+1, now + k[id]);
         dfs(id+1, now);
     }
     ```

3. **Bobxing的题解**（4星）
   - 亮点：同样使用DFS进行暴力搜索，代码简洁，思路清晰。
   - 代码实现：通过递归枚举每个部门的分配情况，最后取最小值。
   - 核心代码：
     ```cpp
     void dfs( int now, int asum, int bsum ) {
         if( now == n + 1 ) {
             ans = min( ans, max( asum, bsum ) );
             return;
         }
         dfs( now + 1, asum + a[ now ], bsum );
         dfs( now + 1, asum, bsum + a[ now ] );
     }
     ```

### 最优关键思路与技巧

1. **二进制枚举**：通过二进制数表示每个部门的分配情况，利用位运算快速计算每种状态下的总和，适合N较小的情况。
2. **DFS暴力搜索**：通过递归枚举每个部门的分配情况，适合N较小且代码实现简单的情况。

### 可拓展之处

1. **类似题目**：该题目可以拓展到更复杂的分组问题，如将部门分成更多组，或考虑其他约束条件。
2. **优化思路**：对于N较大的情况，可以考虑使用动态规划或其他优化算法来减少时间复杂度。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：考察背包问题的经典题目，与本题的分组思想类似。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：考察动态规划的经典题目，与本题的优化思路相关。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)：考察分组与动态规划的结合，与本题的分组思想类似。

### 个人心得摘录

1. **A_R_O_N_A**：提到“一道用于理解状压思想的入门题”，强调了二进制枚举在解决小规模问题中的优势。
2. **fishing_cat**：提到“发现 $n$ 只有 $20$，指数复杂度的深度优先搜索是可以过的”，强调了DFS在小规模问题中的适用性。
3. **Bobxing**：提到“注意到 $n$ 很小，可以 dfs 暴力搜索”，强调了暴力搜索在小规模问题中的简洁性。

---
处理用时：53.71秒
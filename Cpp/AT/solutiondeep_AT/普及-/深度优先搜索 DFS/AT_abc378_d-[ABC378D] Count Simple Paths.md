# 题目信息

# [ABC378D] Count Simple Paths

## 题目描述

给定一个 $H$ 行 $W$ 列的网格；令 $(i, j)$ 为网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子。 

当 $ S_{i,j} $ 为 `.` 时，格子为空格；当 $ S_{i,j} $ 为 `#` 时，格子为障碍物。

请计算从某个空格出发，经过 $K$ 次移动（上下左右），不经过障碍物且不重复经过同一个格子的路径数。

具体地，统计满足以下条件的，长度为 $K+1$ 的序列 $((i_0,j_0),(i_1,j_1),\dots,(i_K,j_K))$

- 对于每个 $ 0\ \leq\ k\ \leq\ K $，都有 $ 1\ \leq\ i_k\ \leq\ H,\ 1\ \leq\ j_k\ \leq\ W $，且 $ S_{i_k,j_k} $ 为 `.`。
- 对于每个 $ 0\ \leq\ k\ \leq\ K-1 $，有 $ |i_{k+1}-i_k|\ +\ |j_{k+1}-j_k|\ =\ 1 $。
- 对于每个 $ 0\ \leq\ k\ <\ l\ \leq\ K $，有 $ (i_k,j_k)\neq\ (i_l,j_l) $。

## 说明/提示

-  $1 \leq H, W \leq 10$
-  $1 \leq K \leq 11$
-  $H$, $W$, 和 $K$ 均为整数。
-  每个 $S_{i,j}$ 均为 `.` 或 `#`。
-  网格中至少存在一个格子为空格。

## 样例 #1

### 输入

```
2 2 2
.#
..```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 1
.#.
#.#```

### 输出

```
0```

## 样例 #3

### 输入

```
10 10 11
....#..#..
.#.....##.
..#...##..
...#......
......##..
..#......#
#........#
..##......
.###....#.
...#.....#```

### 输出

```
218070```

# AI分析结果

### 题目内容重写

给定一个 $H$ 行 $W$ 列的网格；令 $(i, j)$ 为网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子。 

当 $ S_{i,j} $ 为 `.` 时，格子为空格；当 $ S_{i,j} $ 为 `#` 时，格子为障碍物。

请计算从某个空格出发，经过 $K$ 次移动（上下左右），不经过障碍物且不重复经过同一个格子的路径数。

具体地，统计满足以下条件的，长度为 $K+1$ 的序列 $((i_0,j_0),(i_1,j_1),\dots,(i_K,j_K))$

- 对于每个 $ 0\ \leq\ k\ \leq\ K $，都有 $ 1\ \leq\ i_k\ \leq\ H,\ 1\ \leq\ j_k\ \leq\ W $，且 $ S_{i_k,j_k} $ 为 `.`。
- 对于每个 $ 0\ \leq\ k\ \leq\ K-1 $，有 $ |i_{k+1}-i_k|\ +\ |j_{k+1}-j_k|\ =\ 1 $。
- 对于每个 $ 0\ \leq\ k\ <\ l\ \leq\ K $，有 $ (i_k,j_k)\neq\ (i_l,j_l) $。

### 题解综合分析与结论

本题的核心是使用深度优先搜索（DFS）来枚举所有可能的路径，并通过回溯来避免重复访问同一个格子。由于数据范围较小（$H, W \leq 10$，$K \leq 11$），DFS 的时间复杂度在可接受范围内。

### 所选高星题解

#### 题解1：作者：zaolong (赞：2)
- **星级**：4星
- **关键亮点**：代码简洁，思路清晰，使用了DFS和回溯法，代码可读性高。
- **个人心得**：作者提到DFS比动态规划更适合此题，因为数据范围较小。

```cpp
void dfs(int x,int y,int s){
    if(s==k+1){
        ans++;
        return;
    }
    for(int i=0;i<4;i++){
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(bj[xx][yy]==0&&1<=xx&&xx<=n&&1<=yy&&yy<=m){
            bj[xx][yy]=1;
            dfs(xx,yy,s+1);
            bj[xx][yy]=0;
        }
    }
}
```

#### 题解2：作者：superLouis (赞：2)
- **星级**：4星
- **关键亮点**：代码结构清晰，使用了DFS和回溯法，代码可读性高。
- **个人心得**：作者提到DFS比BFS更适合此题，因为BFS不能回溯。

```cpp
void dfs(int x,int y,int step){
    if(step==k){
        ans++;
        return;
    }
    vis[x][y]=1;
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&g[nx][ny]=='.'&&vis[nx][ny]==0){
            vis[nx][ny]=1;
            dfs(nx,ny,step+1);
            vis[nx][ny]=0;
        }
    }
    vis[x][y]=0;
}
```

#### 题解3：作者：Binah_cyc (赞：1)
- **星级**：4星
- **关键亮点**：代码简洁，思路清晰，使用了DFS和回溯法，代码可读性高。
- **个人心得**：作者提到DFS比BFS更适合此题，因为BFS不能回溯。

```cpp
int dfs(int x,int y,int t){
    if(x<1||x>n||y<1||y>m) return 0;
    if(vis[x][y]||mp[x][y]!='.') return 0;
    if(t==k+1) return 1;
    vis[x][y]=1;
    int cnt=dfs(x-1,y,t+1)+dfs(x,y-1,t+1)+dfs(x+1,y,t+1)+dfs(x,y+1,t+1);
    vis[x][y]=0;
    return cnt;
}
```

### 最优关键思路或技巧

1. **DFS与回溯法**：DFS适合用于枚举所有可能的路径，回溯法可以避免重复访问同一个格子。
2. **方向数组**：使用方向数组（如`dx[]`和`dy[]`）来简化四个方向的移动。
3. **标记数组**：使用标记数组（如`vis[][]`）来记录已经访问过的格子，避免重复访问。

### 可拓展之处

1. **BFS与DFS的选择**：在类似问题中，如果路径长度较短且需要枚举所有可能路径，DFS通常比BFS更合适。
2. **剪枝优化**：在DFS过程中，可以通过剪枝来减少不必要的搜索，提高效率。

### 推荐题目

1. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

---
处理用时：46.07秒
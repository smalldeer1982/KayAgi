# 题目信息

# 深さ優先探索

## 题目描述

[problemUrl]: https://atcoder.jp/contests/atc001/tasks/dfs_a

この問題は、講座用問題です。ページ下部に解説が掲載されています。

高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。

高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。

## 说明/提示

### 解説

  **[深さ優先探索による塗りつぶし](https://www.slideshare.net/secret/lyag9AlTOMIY2J "深さ優先探索による塗りつぶし")**  from **[AtCoder Inc.](http://www.slideshare.net/chokudai)** 

### Sample Explanation 1

高橋君は、魚屋にたどり着くことができません。

## 样例 #1

### 输入

```
4 5

s####

....#

#####

#...g```

### 输出

```
No```

## 样例 #2

### 输入

```
4 4

...s

....

....

.g..```

### 输出

```
Yes```

## 样例 #3

### 输入

```
10 10

s.........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

g.#.#.#.#.

#.#.#.#.#.

###.#.#.#.

#.....#...```

### 输出

```
No```

## 样例 #4

### 输入

```
10 10

s.........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

g.#.#.#.#.

#.#.#.#.#.

#.#.#.#.#.

#.....#...```

### 输出

```
Yes```

## 样例 #5

### 输入

```
1 10

s..####..g```

### 输出

```
No```

# AI分析结果

### 题目内容重写（中文）

高桥君住的小区是长方形的，被划分成一个个格子。高桥君想从家里去鱼店，高桥君每次可以走到他上下左右四个格子中的其中一个，不能斜着走，也不能走出小区或穿墙。

地图语言解释：

- `s`：表示高桥君的家（起始点）
- `g`：表示鱼店（终点）
- `.`：表示道路
- `#`：表示墙壁

### 题解分析与结论

本题是一个典型的深度优先搜索（DFS）或广度优先搜索（BFS）的应用场景，主要考察对搜索算法的掌握和实现。题解中大部分作者都采用了DFS或BFS来解决，部分题解还涉及了剪枝优化和记忆化搜索的技巧。

#### 关键思路与技巧
1. **DFS与BFS的选择**：DFS和BFS都可以解决此问题，DFS适合路径较深的情况，BFS适合路径较广的情况。
2. **剪枝优化**：在DFS中，避免重复访问已经访问过的节点，可以通过标记数组来实现。
3. **记忆化搜索**：通过记录已经访问过的节点，避免重复计算，提升效率。
4. **边界处理**：在搜索时，确保不越界，并且不访问障碍物。

#### 可拓展之处
- **类似题目**：可以扩展到更复杂的迷宫问题，如带有权重的路径搜索、多目标点搜索等。
- **算法套路**：DFS和BFS是解决图论问题的基础，掌握这两种算法可以解决许多类似的问题。

### 推荐题目
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

### 个人心得摘录
- **hhhwg07**：提到在DFS中不能回溯状态，否则会导致TLE，因为之前已经访问过的节点不需要再次访问。
- **Sea_Level**：强调了在DFS中不能回溯标记，否则会重复计算，导致超时。
- **Blue_Floyd**：指出在DFS中不需要回溯vis数组，因为经过此格的路线一定不可能走到目的地。

### 高星题解推荐

#### 题解1：hhhwg07（5星）
**关键亮点**：
- 使用DFS进行搜索，代码简洁清晰。
- 通过标记数组避免重复访问，提升效率。
- 强调了不能回溯状态，否则会导致TLE。

**核心代码**：
```cpp
void dfs(int x,int y){
	if(check) return;
	if(ex==x&&ey==y){
		check=true;
		return;
	}
	int nowx,nowy;
	for(int i=0;i<4;i++){
		nowx=x+dx[i];nowy=y+dy[i];
		if(g[nowx][nowy]){
			g[x][y]=false;
			dfs(nowx,nowy);
		}
	}
}
```

#### 题解2：Sea_Level（4星）
**关键亮点**：
- 使用DFS进行搜索，代码结构清晰。
- 强调了在DFS中不能回溯标记，否则会重复计算，导致超时。

**核心代码**：
```cpp
void dfs(int x,int y){
	if(s[x][y]=='g'){
		f=1;
		return;
	}
	for(int i=0;i<4;i++){
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(xx>0&&yy>0&&xx<=n&&yy<=m&&jl[xx][yy]==0&&(s[xx][yy]=='.'||s[xx][yy]=='g')){
			jl[xx][yy]=1;
			dfs(xx,yy);
		}
	}
}
```

#### 题解3：Blue_Floyd（4星）
**关键亮点**：
- 使用DFS进行搜索，代码简洁。
- 指出在DFS中不需要回溯vis数组，因为经过此格的路线一定不可能走到目的地。

**核心代码**：
```cpp
bool dfs(int nowx,int nowy) {
	if(nowx==x2&&nowy==y2) return true;
	for(int i=1; i<=4; i++) {
		int fx=nowx+dx[i];
		int fy=nowy+dy[i];
		if(fx<=n&&fx>=1&&fy<=m&&fy>=1&&map[fx][fy]!='#'&&!vis[fx][fy]) {
		    vis[fx][fy]=true;
			if(dfs(fx,fy)) return true;
		}
	}
	return false;
}
```

### 总结
DFS和BFS是解决此类问题的经典算法，关键在于如何优化搜索过程，避免重复访问和计算。通过标记数组和剪枝技巧，可以显著提升算法的效率。

---
处理用时：42.58秒
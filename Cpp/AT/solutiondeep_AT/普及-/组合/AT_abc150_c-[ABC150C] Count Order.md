# 题目信息

# [ABC150C] Count Order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc150/tasks/abc150_c

大きさ $ N $ の順列 ($ (1,~2,~...,~N) $ を並び替えてできる数列) $ P,~Q $ があります。

大きさ $ N $ の順列は $ N! $ 通り考えられます。このうち、$ P $ が辞書順で $ a $ 番目に小さく、$ Q $ が辞書順で $ b $ 番目に小さいとして、$ |a\ -\ b| $ を求めてください。

## 说明/提示

### 注記

$ 2 $ つの数列 $ X,~Y $ について、ある整数 $ k $ が存在して $ X_i\ =\ Y_i~(1\ \leq\ i\ <\ k) $ かつ $ X_k\ <\ Y_k $ が成り立つとき、$ X $ は $ Y $ より辞書順で小さいと定義されます。

### 制約

- $ 2\ \leq\ N\ \leq\ 8 $
- $ P,~Q $ は大きさ $ N $ の順列である。
- 入力は全て整数である。

### Sample Explanation 1

大きさ $ 3 $ の順列は、$ (1,~2,~3) $、$ (1,~3,~2) $、$ (2,~1,~3) $、$ (2,~3,~1) $、$ (3,~1,~2) $、$ (3,~2,~1) $ の $ 6 $ 個あります。このうち $ (1,~3,~2) $ は辞書順で $ 2 $ 番目、$ (3,~1,~2) $ は辞書順で $ 5 $ 番目なので、答えは $ |2\ -\ 5|\ =\ 3 $ です。

## 样例 #1

### 输入

```
3

1 3 2

3 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
8

7 3 5 4 2 1 6 8

3 8 2 5 4 6 7 1```

### 输出

```
17517```

## 样例 #3

### 输入

```
3

1 2 3

1 2 3```

### 输出

```
0```

# AI分析结果

### 题目中文重写
# [ABC150C] 排列顺序计数

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc150/tasks/abc150_c

有两个长度为 $ N $ 的排列（由 $ (1,~2,~...,~N) $ 重新排列得到的数列）$ P $ 和 $ Q $。

长度为 $ N $ 的排列共有 $ N! $ 种。其中，若 $ P $ 按字典序是第 $ a $ 小，$ Q $ 按字典序是第 $ b $ 小，请求出 $ |a - b| $。

## 说明/提示

### 注记
对于两个数列 $ X $ 和 $ Y $，若存在整数 $ k $ 使得 $ X_i = Y_i~(1 \leq i < k) $ 且 $ X_k < Y_k $ 成立，则定义 $ X $ 在字典序上小于 $ Y $。

### 制约束
- $ 2 \leq N \leq 8 $
- $ P $ 和 $ Q $ 是长度为 $ N $ 的排列。
- 输入均为整数。

### 样例解释 1
长度为 $ 3 $ 的排列有 $ (1,~2,~3) $、$ (1,~3,~2) $、$ (2,~1,~3) $、$ (2,~3,~1) $、$ (3,~1,~2) $、$ (3,~2,~1) $ 这 $ 6 $ 种。其中 $ (1,~3,~2) $ 按字典序是第 $ 2 $ 小，$ (3,~1,~2) $ 按字典序是第 $ 5 $ 小，所以答案是 $ |2 - 5| = 3 $。

## 样例 #1
### 输入
```
3
1 3 2
3 1 2
```
### 输出
```
3
```

## 样例 #2
### 输入
```
8
7 3 5 4 2 1 6 8
3 8 2 5 4 6 7 1
```
### 输出
```
17517
```

## 样例 #3
### 输入
```
3
1 2 3
1 2 3
```
### 输出
```
0
```

### 综合分析与结论
这些题解主要围绕计算两个排列在字典序中的排名差展开，整体可分为暴力枚举和优化算法两类思路。
- **暴力枚举**：利用 `next_permutation` 函数或 DFS 枚举全排列，逐一比较找出 $P$ 和 $Q$ 的排名，时间复杂度为 $O(n\times n!)$。此方法思路简单，代码实现容易，但效率较低，适用于数据规模较小的情况。
- **优化算法**：
    - **$O(n^2)$ 算法**：通过定义数组记录每个元素在其后元素中的排名，再根据阶乘计算排名，复杂度瓶颈在于排名数组的计算。
    - **$O(n\log n)$ 算法**：使用树状数组优化排名数组的计算，减少重复枚举，提高效率。

### 所选题解
- **peppaking8（5星）**
    - **关键亮点**：提供了三种不同复杂度的解法，思路清晰，对每种解法的分析详细，代码实现规范，使用树状数组优化到 $O(n\log n)$ 复杂度。
    - **核心代码**：
```cpp
//树状数组基本三件套
int lowbit(int x){
	return x&(-x);
}
void add(int pos){
	for(int i=pos;i<=n;i+=lowbit(i))
		t[i]++;
}
int query(int pos){
	int ret=0;
	for(int i=pos;i>=1;i-=lowbit(i))
		ret+=t[i];
	return ret;
}
// 主函数部分
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		add(a[i]);
		int prev=query(a[i]-1);
		a[i]-=prev;
	}
	memset(t,0,sizeof(t));
	for(int i=1;i<=n;i++){
		scanf("%d",&b[i]);
		add(b[i]);
		int prev=query(b[i]-1);
		b[i]-=prev;
	}
	cal[0]=1;
	for(int i=1;i<=n;i++) cal[i]=cal[i-1]*i;
	for(int i=1;i<=n;i++){
		ans+=(a[i]-b[i])*cal[n-i];
	}
	printf("%d\n",abs(ans));
	exit(0);
}
```
- **Karry5307（4星）**
    - **关键亮点**：详细介绍了康托展开的原理和证明，给出了 $O(n^2)$ 和 $O(n\log n)$ 的思路，代码使用快速读入优化。
    - **核心公式**：
对于长度为 $n$ 的排列 $\pi$，其排名为 $\text{ord}\ \pi=\sum\limits_{i=1}^{n}\left(\sum\limits_{j=i+1}^{n}[\pi_j<\pi_i]\right)(n-i)!$
- **DengDuck（3星）**
    - **关键亮点**：思路简洁，直接利用 `next_permutation` 函数解决问题，代码简短易懂。
    - **核心代码**：
```cpp
do
{
    bool flag=true;
    for(int j=1;j<=n;j++)
    {
        if(a[j]!=c[j])
        {
            flag=false;
            break;
        }
    }
    if(flag)
    {
        p=i;
    }
    flag=true;
    for(int j=1;j<=n;j++)
    {
        if(b[j]!=c[j])
        {
            flag=false;
            break;
        }
    }
    if(flag)
    {
        q=i;
    }
    if(p!=0&&q!=0)break;
    i++;
}while(next_permutation(c+1,c+n+1));
```

### 最优关键思路或技巧
- 对于小规模数据，可使用 `next_permutation` 或 DFS 暴力枚举全排列。
- 对于大规模数据，使用树状数组优化康托展开的计算，将时间复杂度从 $O(n^2)$ 降低到 $O(n\log n)$。

### 可拓展之处
同类型题目可能会要求计算某个排列的排名，或者根据排名还原排列，可使用康托展开和逆康托展开解决。类似算法套路还可应用于组合数学、排列组合等问题中。

### 洛谷相似题目推荐
1. [P1088 火星人](https://www.luogu.com.cn/problem/P1088)：考察全排列的生成。
2. [P3182 [HAOI2016]放棋子](https://www.luogu.com.cn/problem/P3182)：涉及排列组合和康托展开的应用。
3. [P2524 Uim的情人节礼物·其之弐](https://www.luogu.com.cn/problem/P2524)：需要使用康托展开计算排列的排名。

### 个人心得
题解中未包含个人心得内容。

---
处理用时：42.62秒
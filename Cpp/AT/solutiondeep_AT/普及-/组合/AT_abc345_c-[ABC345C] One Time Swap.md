# 题目信息

# [ABC345C] One Time Swap

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc345/tasks/abc345_c

文字列 $ S $ が与えられます。次の操作を **ちょうど $ 1 $ 回** 行った後の文字列としてあり得るものがいくつあるか求めてください。

- $ S $ の長さを $ N $ とする。 $ 1\leq\ i\ <\ j\leq\ N $ をみたす整数の組 $ (i,j) $ を選び、$ S $ の $ i $ 文字目と $ j $ 文字目を入れ替える。

なお、この問題の制約下で操作を必ず行うことができることが証明できます。

## 说明/提示

### 制約

- $ S $ は英小文字からなる長さ $ 2 $ 以上 $ 10^6 $ 以下の文字列

### Sample Explanation 1

$ S $ の長さは $ 3 $ であるため、$ 1\leq\ i\ <\ j\leq\ 3 $ をみたす整数の組 $ (i,j) $ としては、 $ (1,2) $, $ (1,3) $, $ (2,3) $ の $ 3 $ 通りが考えられます。 - $ S $ の $ 1 $ 文字目と $ 2 $ 文字目を入れ替えた時、$ S $ は `bac` となります。 - $ S $ の $ 1 $ 文字目と $ 3 $ 文字目を入れ替えた時、$ S $ は `cba` となります。 - $ S $ の $ 2 $ 文字目と $ 3 $ 文字目を入れ替えた時、$ S $ は `acb` となります。 よって、`abc` に対して操作を行った後の文字列としては、`bac`, `cba`, `acb` の $ 3 $ つがあり得るため、$ 3 $ を出力します。

### Sample Explanation 2

どの $ 2 $ つの文字を入れ替えても $ S $ は `aaaaa` のままです。よって、操作後の文字列としてあり得るものは $ 1 $ つです。

## 样例 #1

### 输入

```
abc```

### 输出

```
3```

## 样例 #2

### 输入

```
aaaaa```

### 输出

```
1```

# AI分析结果

### 题目翻译
给定一个字符串 $S$。请你求出恰好进行一次以下操作后，可能得到的字符串的数量。
- 设 $S$ 的长度为 $N$。选择满足 $1\leq i < j\leq N$ 的整数对 $(i, j)$，交换 $S$ 的第 $i$ 个字符和第 $j$ 个字符。

请注意，在本题的约束条件下，可以证明一定能够进行该操作。

### 综合分析与结论
这些题解的核心思路都是先计算出所有可能的交换情况，再减去重复的交换情况，最后判断是否存在相同字符的交换，若存在则答案加 1。具体实现上，不同题解采用了不同的数据结构和方法，但本质相同。
- **思路对比**：部分题解从总方案数出发，减去相同字符交换的方案数；部分题解则是直接统计不同字符交换的方案数。
- **算法要点**：大多使用数组或 `map` 来统计字符出现的次数，通过遍历字符串计算方案数。
- **解决难点**：主要难点在于处理重复字符交换的情况，以及避免重复计算不同字符交换的方案数。

### 通用建议与扩展思路
在解决此类字符串操作计数问题时，关键在于理清各种情况之间的关系，避免重复计算。可以先考虑理想情况（如所有字符不同），再逐步减去不符合条件的情况。对于重复情况的处理，要仔细分析，确保只计算一次。

同类型题或类似算法套路：可以拓展到多次交换操作、交换规则变化等情况，解题思路仍然是分析各种情况，通过合理的数据结构进行计数。

### 推荐题目
1. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：考察对重复元素的处理和计数。
2. [P1200 [USACO1.1]你的飞碟在这儿 Your Ride Is Here](https://www.luogu.com.cn/problem/P1200)：涉及字符串的处理和简单的数学计算。
3. [P1308 [NOIP2011 普及组] 统计单词数](https://www.luogu.com.cn/problem/P1308)：需要对字符串进行遍历和计数。

### 个人心得摘录与总结
- **封禁用户**：提到 $O(n^2)$ 暴力匹配不能通过此题，提醒我们在做题时要注意数据范围，选择合适的算法。
- **Elysian_Realme**：强调了要注意重复字符交换的情况，避免遗漏原串作为结果的情况。
- **无名之雾**：分享了赛时没看数据范围吃罚时的经历，提醒我们做题前要仔细查看数据范围。

### 重点代码及核心实现思想
以下是几种不同实现方式的重点代码：

#### 统计字符出现次数，直接计算不同字符交换的方案数
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int tong[30];
signed main(){
    cin>>s;
    long long ans=0,flag=0;
    for(int i=0;i<s.size();i++){
        ans+=i-tong[s[i]-'a'+1];
        tong[s[i]-'a'+1]++;
        if(tong[s[i]-'a'+1]>1) flag=1;
    }
    printf("%lld",ans+flag);
}
```
核心思想：对于每个字符，计算它前面与它不同的字符个数，累加到答案中。同时判断是否有重复字符，若有则答案加 1。

#### 先计算总方案数，再减去相同字符交换的方案数
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long h[30],l,ans;
int main(){
    cin>>s;
    l=s.size();
    ans=l*(l-1)/2;
    for(int i=0;i<l;i++)
        h[s[i]-'a']++;
    int t=0;
    for(int i=0;i<26;i++){
        if(h[i]){
            ans-=h[i]*(h[i]-1)/2;
            if(h[i]>1)t=1;
        }
    }
    if(t)ans++;
    cout<<ans;
    return 0;
}
```
核心思想：先计算所有字符都不同时的总方案数，再统计每个字符出现的次数，减去相同字符交换的方案数。最后判断是否有重复字符，若有则答案加 1。

---
处理用时：30.26秒
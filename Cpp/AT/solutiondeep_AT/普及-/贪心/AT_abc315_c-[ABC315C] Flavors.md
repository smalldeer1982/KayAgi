# 题目信息

# [ABC315C] Flavors

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_c

$ N $ カップのアイスクリームがあります。  
 $ i $ カップ目の味は $ F_i $ 、美味しさは $ S_i $ ( $ S_i $ は偶数 ) です。

あなたは、 $ N $ 個のカップの中から $ 2 $ つを選んで食べることにしました。  
 このときの満足度は次のように定義されます。

- 食べたアイスクリームの美味しさを $ s,t $ ( 但し、 $ s\ \ge\ t $ ) とする。
  - $ 2 $ つのカップの味が異なるなら、満足度は $ \displaystyle\ s+t $ である。
  - そうでないなら、満足度は $ \displaystyle\ s\ +\ \frac{t}{2} $ である。
 
満足度として達成可能な最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ 1\ \le\ F_i\ \le\ N $
- $ 2\ \le\ S_i\ \le\ 10^9 $
- $ S_i $ は偶数
 
### Sample Explanation 1

$ 2 $ カップ目と $ 4 $ カップ目のアイスを食べることを考えます。 - $ 2 $ カップ目の味は $ 2 $ 、美味しさは $ 10 $ です。 - $ 4 $ カップ目の味は $ 3 $ 、美味しさは $ 6 $ です。 - 両者の味は異なるので、満足度は $ 10+6=16 $ です。 以上より、満足度 $ 16 $ を達成できます。 満足度を $ 16 $ より大きくすることはできません。

### Sample Explanation 2

$ 1 $ カップ目と $ 4 $ カップ目のアイスを食べることを考えます。 - $ 1 $ カップ目の味は $ 4 $ 、美味しさは $ 10 $ です。 - $ 4 $ カップ目の味は $ 4 $ 、美味しさは $ 12 $ です。 - 両者の味は同じなので、満足度は $ 12+\frac{10}{2}=17 $ です。 以上より、満足度 $ 17 $ を達成できます。 満足度を $ 17 $ より大きくすることはできません。

## 样例 #1

### 输入

```
4

1 4

2 10

2 8

3 6```

### 输出

```
16```

## 样例 #2

### 输入

```
4

4 10

3 2

2 4

4 12```

### 输出

```
17```

# AI分析结果

### 题目翻译

有 $N$ 杯冰淇淋，每杯冰淇淋有一个口味 $F_i$ 和一个美味度 $S_i$（$S_i$ 是偶数）。你要从中选择两杯冰淇淋来吃，满足度的计算方式如下：

- 如果两杯冰淇淋的口味不同，满足度为 $s + t$，其中 $s$ 和 $t$ 分别是两杯冰淇淋的美味度，且 $s \ge t$。
- 如果两杯冰淇淋的口味相同，满足度为 $s + \frac{t}{2}$。

求能够达到的最大满足度。

### 样例解释

#### 样例 1
输入：
```
4
1 4
2 10
2 8
3 6
```
输出：
```
16
```
解释：选择第 2 杯和第 4 杯冰淇淋，口味分别为 2 和 3，美味度分别为 10 和 6，满足度为 $10 + 6 = 16$。

#### 样例 2
输入：
```
4
4 10
3 2
2 4
4 12
```
输出：
```
17
```
解释：选择第 1 杯和第 4 杯冰淇淋，口味均为 4，美味度分别为 10 和 12，满足度为 $12 + \frac{10}{2} = 17$。

### 题解分析与结论

#### 综合分析与结论

本题的核心在于如何高效地找到两杯冰淇淋，使得它们的满足度最大。由于 $N$ 的范围较大（$2 \le N \le 3 \times 10^5$），暴力枚举所有组合的 $O(N^2)$ 方法不可行。因此，大多数题解采用了贪心策略，通过排序和分类处理来优化时间复杂度。

#### 最优思路总结

1. **贪心策略**：首先选择美味度最大的冰淇淋，然后根据其口味选择第二杯冰淇淋。如果第二杯冰淇淋的口味与第一杯不同，直接选择美味度次大的冰淇淋；如果相同，则需要找到与第一杯口味不同的冰淇淋中美味度最大的，或者选择第二杯冰淇淋并对其美味度减半。

2. **排序优化**：通过将冰淇淋按美味度从大到小排序，可以快速找到美味度最大的冰淇淋及其次大的冰淇淋，从而减少比较次数。

3. **分类处理**：将冰淇淋按口味分类，记录每类中美味度最大的冰淇淋，便于后续处理。

#### 推荐题解

1. **作者：lrx___ (赞：4)**
   - **星级**：★★★★★
   - **关键亮点**：通过两次排序和贪心策略，简洁高效地解决了问题。代码清晰，逻辑严谨。
   - **代码核心**：
     ```cpp
     sort(a, a+n, cmp); // 按美味度从大到小排序
     f = a[0].first; // 记录最大美味度的口味
     for(i=1; i^n; i++) {
         if(a[i].first == f) a[i].second >>= 1; // 将同口味的冰淇淋美味度减半
     }
     sort(a, a+n, cmp); // 重新排序
     printf("%d\n", a[0].second + a[1].second); // 输出最大满足度
     ```

2. **作者：Elairin176 (赞：2)**
   - **星级**：★★★★
   - **关键亮点**：通过一次排序和分类处理，快速找到最大满足度。代码简洁，思路清晰。
   - **代码核心**：
     ```cpp
     sort(c + 1, c + n + 1, cmp); // 按美味度从大到小排序
     if(c[1].f != c[2].f) ans = c[1].s + c[2].s; // 口味不同直接相加
     else ans = c[1].s + c[2].s / 2; // 口味相同则减半
     ```

3. **作者：Crazyouth (赞：0)**
   - **星级**：★★★★
   - **关键亮点**：通过贪心策略和分类处理，快速找到最大满足度。代码简洁，思路清晰。
   - **代码核心**：
     ```cpp
     sort(v.begin(), v.end(), cmp); // 按美味度从大到小排序
     int maxf = v[0].fi, maxs = v[0].se, ans = -1e9;
     for(int i = 1; i < n; i++) {
         if(maxf == v[i].fi) ans = max(ans, maxs + v[i].se / 2); // 口味相同则减半
         else ans = max(ans, maxs + v[i].se); // 口味不同直接相加
     }
     ```

### 扩展思路与推荐题目

#### 扩展思路

- **贪心算法的应用**：在处理需要从大量数据中选择最优组合的问题时，贪心策略是一种常见的优化手段。
- **分类处理**：将数据按某种特征分类，可以简化问题，减少计算量。
- **排序优化**：通过排序可以快速找到最大值、次大值等关键数据，减少比较次数。

#### 推荐题目

1. **P1090 [NOIP2004 提高组] 合并果子**：贪心策略的应用，通过优先队列优化。
2. **P1223 排队接水**：贪心算法的经典应用，通过排序优化。
3. **P1803 凌乱的yyy / 线段覆盖**：贪心策略的应用，通过排序和分类处理。

### 个人心得总结

- **贪心策略的适用性**：在处理需要从大量数据中选择最优组合的问题时，贪心策略往往能够提供高效的解决方案。
- **排序的重要性**：通过排序可以快速找到关键数据，减少比较次数，提高算法效率。
- **分类处理的简化作用**：将数据按某种特征分类，可以简化问题，减少计算量。

---
处理用时：46.55秒
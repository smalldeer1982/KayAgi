# 题目信息

# [ABC334D] Reindeer and Sleigh

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_d

$ N $ 台のソリがあり、各ソリには $ 1,2,\ldots,\ N $ の番号がつけられています。

ソリ $ i $ を引くために必要なトナカイは $ R_i $ 匹です。

また、各トナカイが引けるソリは高々 $ 1 $ 台です。より厳密には、$ m $ 台のソリ $ i_1,\ i_2,\ \ldots,\ i_m $ を引くために必要なトナカイは $ \sum_{k=1}^{m}\ R_{i_k} $ 匹です。

以下の形式のクエリが $ Q $ 個与えられるので、答えを求めてください。

- 整数 $ X $ が与えられる。トナカイが $ X $ 匹いるときに最大で何台のソリを引けるか求めよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ R_i\ \leq\ 10^9 $
- $ 1\ \leq\ X\ \leq\ 2\ \times\ 10^{14} $
- 入力される数値はすべて整数
 
### Sample Explanation 1

トナカイが $ 16 $ 匹いるとき、ソリ $ 1,2,4 $ を引くことができます。 $ 16 $ 匹のトナカイで $ 4 $ 台のソリを引くことはできないので、クエリ $ 1 $ の答えは $ 3 $ となります。

## 样例 #1

### 输入

```
4 3

5 3 11 8

16

7

1000```

### 输出

```
3

1

4```

## 样例 #2

### 输入

```
6 6

1 2 3 4 5 6

1

2

3

4

5

6```

### 输出

```
1

1

2

2

2

3```

## 样例 #3

### 输入

```
2 2

1000000000 1000000000

200000000000000

1```

### 输出

```
2

0```

# AI分析结果

### 题目重写
#### [ABC334D] 驯鹿与雪橇

**题目描述**

有 $N$ 台雪橇，每台雪橇编号为 $1,2,\ldots,\ N$。拉第 $i$ 台雪橇需要 $R_i$ 只驯鹿。每只驯鹿最多只能拉一台雪橇。更严格地说，拉 $m$ 台雪橇 $i_1,\ i_2,\ \ldots,\ i_m$ 需要 $\sum_{k=1}^{m}\ R_{i_k}$ 只驯鹿。

给定 $Q$ 个查询，每个查询给出一个整数 $X$，表示有 $X$ 只驯鹿，问最多能拉多少台雪橇。

**输入格式**

第一行包含两个整数 $N$ 和 $Q$，表示雪橇的数量和查询的数量。

第二行包含 $N$ 个整数 $R_1, R_2, \ldots, R_N$，表示每台雪橇需要的驯鹿数量。

接下来 $Q$ 行，每行包含一个整数 $X$，表示查询的驯鹿数量。

**输出格式**

对于每个查询，输出一个整数，表示最多能拉的雪橇数量。

**样例**

**样例输入 #1**
```
4 3
5 3 11 8
16
7
1000
```

**样例输出 #1**
```
3
1
4
```

**样例输入 #2**
```
6 6
1 2 3 4 5 6
1
2
3
4
5
6
```

**样例输出 #2**
```
1
1
2
2
2
3
```

**样例输入 #3**
```
2 2
1000000000 1000000000
200000000000000
1
```

**样例输出 #3**
```
2
0
```

### 题解分析与结论

#### 题解思路总结
所有题解的核心思路都是通过贪心算法，优先选择需要驯鹿数量较少的雪橇，从而在给定驯鹿数量的情况下最大化拉取的雪橇数量。具体实现上，大部分题解都采用了排序和前缀和的方法，并通过二分查找来快速确定最多能拉取的雪橇数量。

#### 关键思路与技巧
1. **贪心思想**：优先选择需要驯鹿数量较少的雪橇，以最大化拉取的雪橇数量。
2. **排序与前缀和**：将雪橇按需要的驯鹿数量从小到大排序，并计算前缀和，方便后续查询。
3. **二分查找**：利用二分查找在前缀和数组中快速确定最多能拉取的雪橇数量，时间复杂度为 $O(Q \log N)$。

#### 优化与拓展
- **优化**：通过排序和前缀和，将查询的时间复杂度从 $O(QN)$ 降低到 $O(Q \log N)$。
- **拓展**：类似的问题可以应用于背包问题、资源分配问题等，核心思想都是通过贪心算法和二分查找来优化查询效率。

### 精选题解

#### 题解1：xz001 (4星)
**关键亮点**：
- 代码结构清晰，使用了排序和前缀和的经典组合。
- 通过二分查找快速确定最多能拉取的雪橇数量，效率高。

**核心代码**：
```cpp
sort(a + 1, a + n + 1);  // 排序
for (int i = 1; i <= n; ++ i) sum[i] = sum[i - 1] + a[i]; // 前缀和
while (q -- ) {
    int x;
    scanf("%lld", &x);
    int l = 0, r = n, ans; 
    while (l <= r) {   // 二分
        int mid = (l + r) >> 1;
        if (sum[mid] <= x) {
            ans = mid;
            l = mid + 1;
        } else {  
            r = mid - 1;
        }
    }
    printf("%lld\n", ans);
}
```

#### 题解2：jubingkun (4星)
**关键亮点**：
- 使用了 `upper_bound` 函数进行二分查找，代码简洁。
- 通过前缀和优化查询，效率高。

**核心代码**：
```cpp
sort(a + 1, a + n + 1);
for (int i = 1; i <= n; ++i)
    pre[i] = pre[i - 1] + a[i];
while (q--) {
    cin >> x;
    if (x >= sum)	cout << n << "\n";
    else {
        int b = upper_bound(pre + 1, pre + n + 1, x) - pre;
        cout << b - 1 << "\n";
    }
}
```

#### 题解3：CheZiHe929 (4星)
**关键亮点**：
- 代码简洁，使用了 `upper_bound` 函数进行二分查找。
- 通过前缀和优化查询，效率高。

**核心代码**：
```cpp
std::sort(r+1,r+n+1);//排序
for(int i=1;i<=n;i++)r[i]+=r[i-1];//前缀和
while(q--){
    std::cin>>x;
    int ans=std::upper_bound(r+1,r+n+1,x)-r-1;//二分
    std::cout<<ans<<endl;
}
```

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

这些题目都涉及到贪心算法和资源分配问题，适合进一步练习和巩固相关知识。

---
处理用时：49.27秒
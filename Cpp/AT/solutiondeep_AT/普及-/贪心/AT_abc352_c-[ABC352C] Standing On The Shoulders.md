# 题目信息

# [ABC352C] Standing On The Shoulders

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc352/tasks/abc352_c

$ N $ 人の巨人がいます。巨人にはそれぞれ $ 1,\ 2,\ \ldots,\ N $ の名前がついており、巨人 $ i $ が地面に立ったとき、肩の高さは $ A_i $、頭の高さは $ B_i $ となります。

あなたは $ (1,\ 2,\ \ldots,\ N) $ を並べ替えて得られる数列 $ (P_1,\ P_2,\ \ldots,\ P_N) $ を選び、以下の規則に従って $ N $ 人の巨人を積み上げることができます。

- まず地面に巨人 $ P_1 $ を立たせる。巨人 $ P_1 $ の肩は地面を基準として $ A_{P_1} $、頭は地面を基準として $ B_{P_1} $ の高さとなる。
- $ i\ =\ 1,\ 2,\ \ldots,\ N\ -\ 1 $ の順に巨人 $ P_i $ の肩の上に巨人 $ P_{i\ +\ 1} $ を立たせる。巨人 $ P_i $ の肩が地面を基準として高さ $ t $ のとき、巨人 $ P_{i\ +\ 1} $ の肩は地面を基準として $ t\ +\ A_{P_{i\ +\ 1}} $、頭は地面を基準として $ t\ +\ B_{P_{i\ +\ 1}} $ の高さとなる。
 
一番上に立っている巨人、すなわち巨人 $ P_N $ の地面を基準とした頭の高さとして実現できる最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ B_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (P_1,\ P_2,\ P_3)\ =\ (2,\ 1,\ 3) $ とすると、地面を基準として巨人 $ 2 $ は肩の高さが $ 5 $、頭の高さが $ 8 $、巨人 $ 1 $ は肩の高さが $ 9 $、頭の高さが $ 15 $、巨人 $ 3 $ は肩の高さが $ 11 $、頭の高さが $ 18 $ となります。 一番上に立っている巨人の頭の高さが地面を基準として $ 18 $ より大きくなることはないため $ 18 $ を出力します。

## 样例 #1

### 输入

```
3

4 10

5 8

2 9```

### 输出

```
18```

## 样例 #2

### 输入

```
5

1 1

1 1

1 1

1 1

1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
10

690830957 868532399

741145463 930111470

612846445 948344128

540375785 925723427

723092548 925021315

928915367 973970164

563314352 832796216

562681294 868338948

923012648 954764623

691107436 891127278```

### 输出

```
7362669937```

# AI分析结果

### 题目内容重写
题目描述：

有 $N$ 个巨人，分别编号为 $1, 2, \ldots, N$。当巨人 $i$ 站在地面上时，其肩膀到地面的高度为 $A_i$，头部到地面的高度为 $B_i$。

你可以将巨人按照任意顺序排列，并按照以下规则堆叠：

1. 首先将巨人 $P_1$ 放在地面上。巨人 $P_1$ 的肩膀高度为 $A_{P_1}$，头部高度为 $B_{P_1}$。
2. 依次将巨人 $P_{i+1}$ 放在巨人 $P_i$ 的肩膀上。如果巨人 $P_i$ 的肩膀高度为 $t$，则巨人 $P_{i+1}$ 的肩膀高度为 $t + A_{P_{i+1}}$，头部高度为 $t + B_{P_{i+1}}$。

求最上面的巨人 $P_N$ 的头部到地面的最大高度。

### 题解分析与结论

#### 综合分析与结论
该题的核心在于如何最大化最上面巨人的头部高度。通过分析可以发现，所有巨人的肩膀高度之和是固定的，因此问题的关键在于如何选择最上面的巨人，使得其头部高度与肩膀高度的差值最大。通过贪心策略，我们可以找到头肩差最大的巨人，将其放在最上面，从而得到最大高度。

#### 所选高星题解

1. **作者：Dream_Mr_li (赞：13)**  
   **星级：5**  
   **关键亮点：**  
   - 思路清晰，直接指出问题的关键在于最大化头肩差。
   - 代码简洁，使用累加肩膀高度和最大头肩差的方式求解。
   - 提醒了开 `long long` 的重要性，避免了潜在的溢出问题。

   **核心代码：**
   ```cpp
   int n, ans, mx, a, b;
   signed main() {
       cin >> n;
       for(int i = 1; i <= n; i++) {
           cin >> a >> b;
           ans += a; // 累加肩膀高度
           mx = max(mx, b - a); // 计算最大头肩差
       }
       cout << ans + mx; // 输出结果
       return 0;
   }
   ```

2. **作者：spfa_ (赞：7)**  
   **星级：4**  
   **关键亮点：**  
   - 通过枚举每个巨人作为最上面的巨人，计算其贡献的高度。
   - 代码结构清晰，使用了 `vi` 和 `pii` 等简洁的宏定义。
   - 提醒了数据范围问题，确保代码的鲁棒性。

   **核心代码：**
   ```cpp
   int main() {
       ll n, sum = 0, ans = 0; cin >> n;
       vi a(n+1), b(n+1);
       for (int i = 1; i <= n; ++i) cin >> a[i] >> b[i], sum += a[i];
       for (int i = 1; i <= n; ++i) ans = max(ans, sum - a[i] + b[i]);
       cout << ans;
       return 0;
   }
   ```

3. **作者：cyx012113 (赞：7)**  
   **星级：4**  
   **关键亮点：**  
   - 使用了贪心策略，通过排序找到头肩差最小的巨人放在前面。
   - 代码结构清晰，使用了结构体和自定义排序函数。
   - 提醒了数据范围问题，确保代码的正确性。

   **核心代码：**
   ```cpp
   struct giant{ int a, b; } g[N];
   bool cmp(giant x, giant y) { return x.b - x.a < y.b - y.a; }
   signed main() {
       cin >> n;
       for(int i = 1; i <= n; i++) cin >> g[i].a >> g[i].b;
       sort(g + 1, g + 1 + n, cmp);
       for(int i = 1; i < n; i++) ans += g[i].a;
       ans += g[n].b;
       cout << ans;
       return 0;
   }
   ```

### 最优关键思路与技巧
1. **贪心策略**：通过最大化头肩差，选择最上面的巨人，从而得到最大高度。
2. **预处理与枚举**：先计算所有巨人的肩膀高度之和，再枚举每个巨人作为最上面的巨人，计算其贡献的高度。
3. **数据范围处理**：提醒了开 `long long` 的重要性，避免溢出问题。

### 可拓展之处
该题的贪心策略可以应用于类似的优化问题，如选择某些元素使得某个差值最大化或最小化。类似的题目可以通过预处理和枚举的方式来解决。

### 推荐相似题目
1. **洛谷 P1090**：合并果子，贪心策略的应用。
2. **洛谷 P1223**：排队接水，贪心策略的应用。
3. **洛谷 P1803**：线段覆盖，贪心策略的应用。

### 个人心得摘录
- **Dream_Mr_li**：提醒了开 `long long` 的重要性，避免溢出问题。
- **spfa_**：通过枚举每个巨人作为最上面的巨人，计算其贡献的高度，提醒了数据范围问题。
- **cyx012113**：使用了贪心策略，通过排序找到头肩差最小的巨人放在前面，提醒了数据范围问题。

---
处理用时：43.44秒
# 题目信息

# [ABC358D] Souvenirs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc358/tasks/abc358_d

AtCoder Land のお土産屋に $ N $ 個の箱が売られています。

箱には $ 1,\ 2,\ \ldots,\ N $ の番号が付いており、箱 $ i $ の価格は $ A_i $ 円であり、$ A_i $ 個のお菓子が入っています。

高橋君は $ N $ 個の箱のうち $ M $ 個の箱を選んで買って帰り、$ 1,\ 2,\ \ldots,\ M $ の名前が付いた $ M $ 人の人に $ 1 $ つずつ箱を渡そうとしています。

ただし、高橋君は以下の条件を満たすことができるように箱を買いたいです。

- 各 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、人 $ i $ には $ B_i $ 個以上のお菓子が入った箱を渡す
 
$ 1 $ 人に $ 2 $ 個以上の箱を渡すことや同じ箱を複数人に渡すことはできないことに注意してください。

適切に箱を $ M $ 個買うことで条件を満たすことができるか判定し、条件を満たすことができる場合は高橋君が支払う金額の合計の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

高橋君は箱 $ 1,\ 4 $ を買い、箱 $ 1 $ を人 $ 1 $、箱 $ 4 $ を人 $ 2 $ に渡すことで条件を満たすことができます。 このとき高橋君が支払う金額の合計は $ 7 $ 円であり、支払う金額が $ 7 $ 円未満のときは条件を満たすことはできないため、$ 7 $ を出力します。

## 样例 #1

### 输入

```
4 2

3 4 5 4

1 4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3

1 1 1

1000000000 1000000000 1000000000```

### 输出

```
-1```

## 样例 #3

### 输入

```
7 3

2 6 8 9 5 1 11

3 5 7```

### 输出

```
19```

# AI分析结果

### 题目内容重写
AtCoder Land 的纪念品商店出售 $N$ 个盒子，编号为 $1, 2, \ldots, N$。盒子 $i$ 的价格为 $A_i$ 元，且包含 $A_i$ 个糖果。高桥君想要从这 $N$ 个盒子中购买 $M$ 个，并将它们分别送给 $M$ 个人，编号为 $1, 2, \ldots, M$。每个人 $i$ 必须收到一个包含至少 $B_i$ 个糖果的盒子。注意，一个盒子不能同时送给多个人，且每个人只能收到一个盒子。

请判断是否存在满足条件的购买方案，如果存在，输出高桥君需要支付的最小总金额；否则输出 $-1$。

### 题解分析与结论
该问题的核心是贪心算法，通过排序和双指针或二分查找来找到满足条件的最小成本方案。大多数题解都采用了类似的思路，即将盒子和需求分别排序，然后依次为每个需求找到最小的满足条件的盒子。使用 `multiset` 或双指针的方法可以有效降低时间复杂度。

### 所选高星题解

#### 题解1：stripe_python (4星)
**关键亮点**：
- 使用 `multiset` 来存储盒子，利用 `lower_bound` 快速找到满足条件的最小盒子。
- 代码简洁，逻辑清晰，时间复杂度为 $O(m \log n)$。

**核心代码**：
```cpp
multiset<int> st;
for (int i = 1; i <= n; i++) st.emplace(a[i]);
long long tot = 0;
for (int i = 1; i <= m; i++) {
    auto it = st.lower_bound(b[i]);
    if (it == st.end()) return cout << -1, 0;
    tot += *it;
    st.erase(it);
}
cout << tot;
```

#### 题解2：luobotianle (4星)
**关键亮点**：
- 使用双指针，排序后依次为每个需求找到最小的满足条件的盒子。
- 代码简洁，时间复杂度为 $O(n \log n + m \log m)$。

**核心代码**：
```cpp
sort(a+1, a+1+n);
sort(b+1, b+1+m);
int j = 0;
long long ans = 0;
for (int i = 1; i <= m; i++) {
    while (j <= n && a[j] < b[i]) j++;
    if (j > n) {
        cout << -1;
        return 0;
    }
    ans += a[j++];
}
cout << ans;
```

#### 题解3：Xuan_qwq (4星)
**关键亮点**：
- 使用双指针，排序后依次为每个需求找到最小的满足条件的盒子。
- 代码简洁，逻辑清晰，时间复杂度为 $O(n \log n + m \log m)$。

**核心代码**：
```cpp
sort(a, a+n);
sort(b, b+m);
int j = 0;
long long ans = 0;
for (int i = 0; i < m; i++) {
    while (j < n && a[j] < b[i]) j++;
    if (j == n) {
        cout << -1;
        return 0;
    }
    ans += a[j++];
}
cout << ans;
```

### 最优关键思路与技巧
1. **贪心策略**：为每个需求找到最小的满足条件的盒子，确保总成本最小。
2. **排序与双指针**：通过排序和双指针的结合，快速找到满足条件的盒子。
3. **数据结构优化**：使用 `multiset` 或 `lower_bound` 来快速查找满足条件的盒子。

### 可拓展之处
- **类似问题**：类似的问题可以扩展到其他资源分配问题，如任务调度、资源分配等。
- **算法套路**：贪心算法结合排序和双指针或二分查找，是解决资源分配问题的常见套路。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得总结
- **调试经历**：部分题解提到在赛时使用 `lower_bound` 时遇到问题，可能是由于未正确处理边界条件或重复元素。
- **踩坑教训**：在处理大规模数据时，务必注意数据类型的范围，避免溢出。
- **顿悟感想**：贪心算法结合排序和双指针，是解决资源分配问题的有效方法，代码简洁且效率高。

---
处理用时：46.07秒
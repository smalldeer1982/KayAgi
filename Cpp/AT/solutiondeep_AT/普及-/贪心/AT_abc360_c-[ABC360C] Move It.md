# 题目信息

# [ABC360C] Move It

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc360/tasks/abc360_c

$ 1 $ から $ N $ の番号がついた $ N $ 個の箱と $ 1 $ から $ N $ の番号がついた $ N $ 個の荷物があります。荷物 $ i $ $ (1\ \leq\ i\ \leq\ N) $ は箱 $ A_i $ の中にあり、重さは $ W_i $ です。

あなたは荷物を一つ選び、他の箱の中に移動させる操作を $ 0 $ 回以上繰り返し行うことができます。$ 1 $ 回の操作で移動させる荷物の重さが $ w $ であるとき、$ w $ のコストがかかります。

全ての箱に荷物が $ 1 $ つずつ入っている状態にするためにかかるコストの総和の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^{5} $
- $ 1\ \leq\ A_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ W_i\ \leq\ 10^{4} $ $ (1\ \leq\ i\ \leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

以下の $ 2 $ 回の荷物の移動で、すべての箱に荷物が $ 1 $ つずつ入っている状態にすることができます。 - 荷物 $ 1 $ を箱 $ 2 $ から箱 $ 1 $ に移す。このとき、コストは $ 33 $ である。 - 荷物 $ 3 $ を箱 $ 3 $ から箱 $ 4 $ に移す。このとき、コストは $ 2 $ である。 この $ 2 $ 回の荷物の移動は合計 $ 35 $ のコストかかります。 $ 35 $ 未満のコストですべての箱に荷物が $ 1 $ つずつ入っている状態にすることはできないため、 $ 35 $ を出力します。

## 样例 #1

### 输入

```
5

2 2 3 3 5

33 40 2 12 16```

### 输出

```
35```

## 样例 #2

### 输入

```
12

3 6 7 4 12 4 8 11 11 1 8 11

3925 9785 9752 3587 4013 1117 3937 7045 6437 6208 3391 6309```

### 输出

```
17254```

# AI分析结果

### 题目内容重写

**题目描述**

有编号从 $1$ 到 $N$ 的 $N$ 个箱子和编号从 $1$ 到 $N$ 的 $N$ 个物品。物品 $i$ $(1 \leq i \leq N)$ 位于箱子 $A_i$ 中，其重量为 $W_i$。

你可以选择任意一个物品，并将其移动到其他箱子中，操作可以进行多次。每次移动一个重量为 $w$ 的物品时，会产生 $w$ 的代价。

请计算将所有箱子中的物品数量调整为每个箱子恰好有一个物品所需的最小总代价。

**说明/提示**

- $1 \leq N \leq 10^5$
- $1 \leq A_i \leq N$ $(1 \leq i \leq N)$
- $1 \leq W_i \leq 10^4$ $(1 \leq i \leq N)$
- 输入均为整数

**样例解释**

在样例1中，可以通过以下两次操作将所有箱子中的物品数量调整为每个箱子恰好有一个物品：
- 将物品 $1$ 从箱子 $2$ 移动到箱子 $1$，代价为 $33$。
- 将物品 $3$ 从箱子 $3$ 移动到箱子 $4$，代价为 $2$。
这两次操作的总代价为 $35$，且无法以更小的代价完成目标，因此输出 $35$。

### 题解分析与结论

**综合分析**

本题的核心思路是贪心算法。每个箱子中如果有多个物品，我们需要移动其中的一些物品，使得每个箱子最终只有一个物品。为了最小化总代价，我们应尽可能保留每个箱子中最重的物品，移动较轻的物品。

**最优思路与技巧**

1. **贪心策略**：对于每个箱子，保留最重的物品，移动其他物品。这样可以确保移动的总重量最小。
2. **数据结构**：使用 `vector` 来存储每个箱子中的物品，便于排序和计算。
3. **排序优化**：对每个箱子中的物品按重量排序，便于快速找到最重的物品。

**推荐题目**

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心算法，优先队列
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223) - 贪心算法，排序
3. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803) - 贪心算法，区间调度

### 高星题解

#### 题解1：Little_x_starTYJ (★★★★★)

**关键亮点**

- 思路清晰，直接使用贪心策略，保留每个箱子中最重的物品。
- 代码简洁，使用 `vector` 存储每个箱子中的物品，并进行排序。

**核心代码**

```cpp
for (int i = 1; i <= n; i++) {
    if (v[i].size() > 0)
        sort(v[i].begin(), v[i].end());
    if (v[i].size() > 0)
        for (int j = 0; j < v[i].size() - 1; j++)
            ans += v[i][j];
}
```

**个人心得**

- 通过排序和贪心策略，能够快速找到最优解，代码实现简单且高效。

#### 题解2：Hughpig (★★★★☆)

**关键亮点**

- 同样采用贪心策略，保留最重的物品，移动其他物品。
- 代码结构清晰，使用 `vector` 和 `sort` 实现。

**核心代码**

```cpp
for (int i = 1; i <= n; i++) {
    if (qwq[i].size() < 2) continue;
    for (int j = 0; j < qwq[i].size() - 1; j++)
        ans += qwq[i][j];
}
```

**个人心得**

- 通过简单的排序和遍历，能够快速计算出最小代价，代码易于理解。

#### 题解3：toolong114514 (★★★★☆)

**关键亮点**

- 使用结构体存储物品信息，按重量排序后贪心选择。
- 代码实现简洁，逻辑清晰。

**核心代码**

```cpp
for (int i = 1; i <= n; i++) {
    if (cnt[arr[i].a] > 1) {
        ans += arr[i].w;
        cnt[arr[i].a]--;
    }
}
```

**个人心得**

- 通过结构体和排序，能够快速找到需要移动的物品，代码实现高效且易于维护。

---
处理用时：36.00秒
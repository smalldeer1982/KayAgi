# 题目信息

# [ABC361C] Make Them Narrow

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_c

長さ $ N $ の数列 $ A $ が与えられます。  
 $ A $ のうち丁度 $ K $ 要素を自由に選んで消し、残った要素を順序を保って連結した数列を $ B $ とします。  
 ( $ B $ の最大値 ) $ - $ ( $ B $ の最小値 ) としてありうる最小値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K\ <\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
 
### Sample Explanation 1

$ A=(3,1,5,4,9) $ から丁度 $ 2 $ 要素を自由に選んで消すことを考えます。 - 例えば $ 2 $ 要素目の $ 1 $ 、 $ 5 $ 要素目の $ 9 $ を消すと、消した後の数列 $ B=(3,5,4) $ となります。 - このとき $ B $ の最大値は $ 5 $ 、最小値は $ 3 $ なので ( $ B $ の最大値 ) $ - $ ( $ B $ の最小値 ) $ =2 $ となり、これは達成可能な最小値です。

## 样例 #1

### 输入

```
5 2

3 1 5 4 9```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 1 1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
8 3

31 43 26 6 18 36 22 13```

### 输出

```
18```

# AI分析结果

【题目内容】
# [ABC361C] Make Them Narrow

## 题目描述

给定一个长度为 $N$ 的数列 $A$。  
从 $A$ 中任意选择 $K$ 个元素并将其删除，然后将剩余的元素按原来的顺序连接起来，形成一个新的序列 $B$。  
求 $B$ 的最大值减去 $B$ 的最小值的最小值。

## 说明/提示

### 制約

- 输入均为整数
- $1\ \le\ K\ <\ N\ \le\ 2\ \times\ 10^5 $
- $1\ \le\ A_i\ \le\ 10^9 $

### 样例解释 1

$ A=(3,1,5,4,9) $ 中删除 $2$ 个元素，例如删除第 $2$ 个元素 $1$ 和第 $5$ 个元素 $9$，得到 $B=(3,5,4)$。此时 $B$ 的最大值为 $5$，最小值为 $3$，极差为 $2$，这是可能的最小值。

## 样例 #1

### 输入

```
5 2

3 1 5 4 9```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 1 1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
8 3

31 43 26 6 18 36 22 13```

### 输出

```
18```

【题解分析与结论】
该问题的核心在于如何通过删除 $K$ 个元素，使得剩余元素的极差最小。所有题解都基于以下关键思路：
1. **排序**：首先将数组排序，以便更容易找到最小极差的子序列。
2. **滑动窗口**：通过枚举长度为 $N-K$ 的连续子序列，计算其极差，并取最小值。

【评分较高的题解】
1. **作者：ganyu1**（评分：4星）
   - **关键亮点**：思路清晰，代码简洁，直接通过排序和滑动窗口枚举所有可能的子序列，计算极差并取最小值。
   - **代码核心**：
     ```cpp
     sort(a+1,a+n+1);
     for(int i=0;i<=k;i++){
         ans=min(ans,a[n-k+i]-a[1+i]);
     }
     ```

2. **作者：joe_zxq**（评分：4星）
   - **关键亮点**：明确提出了贪心思想，指出最优解一定是排序后连续的一段子序列，代码实现简洁高效。
   - **代码核心**：
     ```cpp
     sort(a + 1, a + n + 1);
     for (ll i = len; i <= n; i++) {
         ans = min(ans, a[i] - a[i - len + 1]);
     }
     ```

3. **作者：Heldivis**（评分：4星）
   - **关键亮点**：通过数学推导证明了最优解一定是排序后连续的一段子序列，代码实现简洁且时间复杂度低。
   - **代码核心**：
     ```cpp
     sort(a + 1, a + 1 + n);
     for (int i = 1; i + k - 1 <= n; i++)
       res = min(res, a[i + k - 1] - a[i]);
     ```

【最优关键思路与技巧】
- **排序与滑动窗口**：通过排序将问题转化为寻找长度为 $N-K$ 的连续子序列，极大简化了问题复杂度。
- **贪心思想**：删除的元素一定在排序后的两端，因为删除中间元素不会影响极差。

【拓展与类似题目】
1. **洛谷 P1102 A-B 数对**（题号：P1102）：考察滑动窗口与双指针技巧。
2. **洛谷 P1631 序列合并**（题号：P1631）：涉及排序与贪心思想。
3. **洛谷 P1886 滑动窗口**（题号：P1886）：滑动窗口的经典应用。

【个人心得摘录】
- **作者：Redamancy_Lydic**：在比赛时查了中考分，心情紧张，但通过冷静分析问题，最终顺利解决。
- **作者：1234567890sjx**：提到使用 ST 表维护静态区间最值，虽然实际不需要，但体现了对多种数据结构的熟悉。

---
处理用时：34.94秒
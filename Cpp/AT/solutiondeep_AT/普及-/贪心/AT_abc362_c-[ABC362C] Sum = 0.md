# 题目信息

# [ABC362C] Sum = 0

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc362/tasks/abc362_c

$ N $ 個の整数の組 $ (L_1,R_1),(L_2,R_2),\ldots,(L_N,R_N) $ が与えられます。

以下の条件を満たす長さ $ N $ の整数列 $ X=(X_1,X_2,\ldots,X_N) $ が存在するか判定し、存在するならば一つ出力してください。

- 各 $ i=1,2,\ldots,N $ に対して $ L_i\leq\ X_i\leq\ R_i $
- $ \displaystyle\ \sum_{i=1}^N\ X_i=0 $

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ -10^9\leq\ L_i\leq\ R_i\leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

数列 $ X=(4,-3,-1) $ は問題の条件をすべて満たします。ほかにも $ (3,-3,0) $ や $ (5,-4,-1) $ などが条件を満たします。

### Sample Explanation 2

条件を満たす整数列 $ X $ は存在しません。

## 样例 #1

### 输入

```
3

3 5

-4 1

-2 3```

### 输出

```
Yes

4 -3 -1```

## 样例 #2

### 输入

```
3

1 2

1 2

1 2```

### 输出

```
No```

## 样例 #3

### 输入

```
6

-87 12

-60 -54

2 38

-76 6

87 96

-17 38```

### 输出

```
Yes

-66 -57 31 -6 89 9```

# AI分析结果

### 题目内容重写

#### [ABC362C] Sum = 0

**题目描述**

给定 $N$ 个整数对 $(L_1,R_1),(L_2,R_2),\ldots,(L_N,R_N)$。

判断是否存在一个长度为 $N$ 的整数序列 $X=(X_1,X_2,\ldots,X_N)$，满足以下条件：

- 对于每个 $i=1,2,\ldots,N$，有 $L_i \leq X_i \leq R_i$。
- $\displaystyle \sum_{i=1}^N X_i = 0$。

如果存在这样的序列，输出一个满足条件的序列。

**说明/提示**

**约束条件**

- $1 \leq N \leq 2 \times 10^5$
- $-10^9 \leq L_i \leq R_i \leq 10^9$
- 输入均为整数

**样例解释**

**样例 #1**

输入：

```
3
3 5
-4 1
-2 3
```

输出：

```
Yes
4 -3 -1
```

**样例 #2**

输入：

```
3
1 2
1 2
1 2
```

输出：

```
No
```

**样例 #3**

输入：

```
6
-87 12
-60 -54
2 38
-76 6
87 96
-17 38
```

输出：

```
Yes
-66 -57 31 -6 89 9
```

---

### 题解综合分析与结论

本题的核心是通过贪心算法构造一个满足条件的序列，使得序列的和为0。大多数题解都采用了类似的思路：首先判断是否存在满足条件的序列，然后通过贪心策略逐步调整序列中的元素，使其和趋近于0。

#### 最优关键思路与技巧

1. **判断是否存在解**：通过计算所有区间的左端点和右端点的总和，判断0是否在区间$[\sum L_i, \sum R_i]$内。如果不在，则无解。
2. **贪心构造序列**：从所有区间的右端点开始，逐步减少每个区间的值，使得总和趋近于0。如果某个区间的值减少到左端点后仍然无法使总和为0，则调整该区间的值，使其恰好使总和为0。

#### 可拓展之处

- **类似问题**：类似的问题可以通过贪心算法来解决，尤其是在需要构造满足某些条件的序列时。
- **优化技巧**：在处理大规模数据时，可以通过预处理和优化计算来提高效率。

#### 推荐题目

1. [P1045 最大子段和](https://www.luogu.com.cn/problem/P1045)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)

---

### 所选高星题解

#### 题解1：作者：_wsq_ (赞：8)

**星级：5星**

**关键亮点**：
- 思路清晰，代码简洁。
- 通过贪心策略逐步调整序列，使得总和为0。

**核心代码**：
```cpp
for(ll i=1;i<=n;i++){
    cout<<r[i]-min(r[i]-l[i],sumr)<<' ';
    sumr-=min(r[i]-l[i],sumr);
}
```
**实现思想**：从每个区间的右端点开始，逐步减少值，使得总和趋近于0。

---

#### 题解2：作者：xuduang (赞：2)

**星级：4星**

**关键亮点**：
- 详细分析了贪心策略的两种情况，代码实现较为清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int ned = 0 - now;
    if(r[i] - l[i] >= ned){
        c[i] = l[i] + ned;
        output();
    }
    c[i] = r[i];
    now += (r[i] - l[i]);
}
```
**实现思想**：通过遍历每个区间，逐步调整序列中的值，使得总和为0。

---

#### 题解3：作者：Lame_Joke (赞：2)

**星级：4星**

**关键亮点**：
- 通过贪心策略将最大值的和减成0，思路清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;i++){
    x=r[i]-l[i];
    if(sm==0) continue;
    if(sm-x<0){
        r1[i]-=sm;
        sm=0;
        break;
    }
    if(sm>=x){
        r1[i]=r[i]-x;
        sm-=x;
    }
}
```
**实现思想**：从每个区间的右端点开始，逐步减少值，使得总和为0。

---
处理用时：43.16秒
# 题目信息

# [ABC364C] Minimum Glutton

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc364/tasks/abc364_c

$ N $ 個の料理があり、$ i $ 個目の料理の**甘さ**は $ A_i $、**しょっぱさ**は $ B_i $ です。

高橋君はこれらの $ N $ 個の料理を好きな順番で並べ、その順に食べようとします。

高橋君は並べた順番の通りに料理を食べていきますが、食べた料理の甘さの合計が $ X $ より大きくなるかしょっぱさの合計が $ Y $ より大きくなるとその時点で食べるのをやめます。

高橋君が食べることになる料理の個数としてあり得る最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ X,\ Y\ \leq\ 2\ \times\ 10^{14} $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i $ 個目の料理のことを料理 $ i $ と書きます。 高橋君が $ 4 $ 個の料理を料理 $ 2,\ 3,\ 1,\ 4 $ の順に並べ替えたとき、料理 $ 2,\ 3 $ を食べた時点での食べた料理の甘さの合計が $ 8 $ となり $ 7 $ より大きくなります。したがってこの場合は高橋君が食べることになる料理の個数は $ 2 $ 個です。 高橋君が食べる料理の個数が $ 1 $ 個以下になることはないため、$ 2 $ を出力します。

## 样例 #1

### 输入

```
4 7 18

2 3 5 1

8 8 1 4```

### 输出

```
2```

## 样例 #2

### 输入

```
5 200000000000000 200000000000000

1 1 1 1 1

2 2 2 2 2```

### 输出

```
5```

## 样例 #3

### 输入

```
8 30 30

1 2 3 4 5 6 7 8

8 7 6 5 4 3 2 1```

### 输出

```
6```

# AI分析结果

### 题目内容重写
**题目描述**

有 $N$ 个料理，第 $i$ 个料理的**甜度**是 $A_i$，**咸度**是 $B_i$。高桥君可以按照任意顺序排列这些料理，并按顺序吃。当他吃过的料理的甜度总和超过 $X$ 或咸度总和超过 $Y$ 时，他就会停止进食。求高桥君最少能吃多少道料理。

**说明/提示**

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq X, Y \leq 2 \times 10^{14}$
- $1 \leq A_i, B_i \leq 10^9$
- 输入的所有值都是整数

**样例解释**

对于样例1，高桥君可以按照料理2、3、1、4的顺序排列，当他吃到第2道料理时，甜度总和为8，超过了7，因此他最少能吃2道料理。

### 题解分析与结论

该题的核心思路是贪心算法，通过分别按甜度和咸度从大到小排序，计算在两种情况下高桥君最少能吃多少道料理，最终取最小值。难点在于如何处理甜度和咸度的双重限制，并确保算法的效率。

### 精选题解

#### 题解1：作者：chinazhanghaoxun (赞：6)
**星级：★★★★★**
**关键亮点：**
- 使用结构体存储甜度和咸度，分别按甜度和咸度排序，计算最少能吃多少道料理。
- 代码清晰，逻辑简洁，处理了甜度和咸度的双重限制。
- 使用了`min`函数直接比较两种情况的答案，代码简洁高效。

**核心代码：**
```cpp
struct num{
    int a, b;
}t[N];
bool cmpa(num p, num q){ return p.a > q.a; }
bool cmpb(num p, num q){ return p.b > q.b; }

int main(){
    cin >> n >> x >> y;
    for(int i = 1; i <= n; i++) cin >> t[i].a;
    for(int i = 1; i <= n; i++) cin >> t[i].b;
    sort(t + 1, t + n + 1, cmpa);
    int suma = 0, sumb = 0, aa = n;
    for(int i = 1; i <= n; i++){
        suma += t[i].a;
        sumb += t[i].b;
        if(suma > x || sumb > y){ aa = i; break; }
    }
    sort(t + 1, t + n + 1, cmpb);
    suma = 0, sumb = 0;
    for(int i = 1; i <= n; i++){
        suma += t[i].a;
        sumb += t[i].b;
        if(suma > x || sumb > y){ bb = i; break; }
    }
    cout << min(aa, bb);
}
```

#### 题解2：作者：Barryb (赞：3)
**星级：★★★★**
**关键亮点：**
- 分别对甜度和咸度进行排序，计算在两种情况下高桥君最少能吃多少道料理。
- 代码简洁，逻辑清晰，处理了甜度和咸度的双重限制。
- 使用了`min`函数直接比较两种情况的答案，代码简洁高效。

**核心代码：**
```cpp
int n, x, y, s1, s2, a[2000010], b[2000010];
signed main(){
    cin >> n >> x >> y;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) cin >> b[i];
    sort(a + 1, a + n + 1, greater<int>());
    sort(b + 1, b + n + 1, greater<int>());
    for(int i = 1; i <= n; i++) {
        s1 += a[i];
        if(s1 > x) { minn = min(i, minn); break; }
    }
    for(int i = 1; i <= n; i++) {
        s2 += b[i];
        if(s2 > y) { minn = min(i, minn); break; }
    }
    cout << minn;
}
```

#### 题解3：作者：Hughpig (赞：3)
**星级：★★★★**
**关键亮点：**
- 分别按甜度和咸度排序，计算在两种情况下高桥君最少能吃多少道料理。
- 代码简洁，逻辑清晰，处理了甜度和咸度的双重限制。
- 使用了`min`函数直接比较两种情况的答案，代码简洁高效。

**核心代码：**
```cpp
sort(a + 1, a + n + 1, c1);
ll s = 0;
for(int i = 1; i <= n; i++){
    s += a[i].a;
    if(s > x || i == n){ ans = i; break; }
}
sort(a + 1, a + n + 1, c2);
s = 0;
for(int i = 1; i <= n; i++){
    s += a[i].b;
    if(s > y || i == n){ ans = min(ans, (ll)i); break; }
}
cout << ans;
```

### 最优关键思路与技巧
1. **贪心算法**：通过分别按甜度和咸度从大到小排序，计算在两种情况下高桥君最少能吃多少道料理，最终取最小值。
2. **双重限制处理**：在计算过程中，同时累加甜度和咸度，确保在任意一种限制条件满足时停止计算。
3. **代码优化**：使用`min`函数直接比较两种情况的答案，代码简洁高效。

### 可拓展之处
- 类似的双重限制问题可以通过分别处理每种限制条件，最终取最优解的方式解决。
- 该题的贪心思路可以推广到其他类似的优化问题中，如背包问题、任务调度等。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 类似的双重限制问题，可以通过贪心或动态规划解决。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 双重限制的背包问题，可以通过动态规划解决。
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心算法的经典应用，可以通过优先队列解决。

### 个人心得总结
- **调试经历**：在处理双重限制时，确保在任意一种限制条件满足时停止计算，避免不必要的计算。
- **踩坑教训**：在处理大范围数据时，注意数据类型的范围，避免溢出。
- **顿悟感想**：贪心算法在处理双重限制问题时，通过分别处理每种限制条件，最终取最优解的方式，能够有效简化问题。

---
处理用时：64.90秒
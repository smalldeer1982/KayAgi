# 题目信息

# [ABC376C] Prepare Another Box

## 题目描述

有 $N$ 个玩具，编号从 $1$ 到 $N$ ，以及 $N-1$个箱子，编号从 $1$ 到 $N-1$。玩具 $i$ 的大小为$A_i$，箱子 $i$ 的大小为$B_i$。高桥君想把所有玩具分别放入不同的箱子中。他计划按以下步骤操作：

- 选择任意正整数 $x$，购买一个大小为 $x$ 的箱子。

- 将 $N$ 个玩具分别放入 $N$ 个箱子（包括原有的箱子和新购买的箱子）中，但每个玩具只能放入大小不小于该玩具的箱子，且每个箱子只能放一个玩具。

高桥君想通过购买合适大小的箱子来完成第 $2$ 步，但箱子越大价格越高，因此他想尽可能购买小箱子。请判断是否存在能满足条件的 $x$ 值，如果存在，请输出最小值；如果不存在，请输出 $-1$。

## 样例 #1

### 输入

```
4

5 2 3 7

6 2 8```

### 输出

```
3```

## 样例 #2

### 输入

```
4

3 7 2 5

8 1 6```

### 输出

```
-1```

## 样例 #3

### 输入

```
8

2 28 17 39 57 56 37 32

34 27 73 28 76 61 27```

### 输出

```
37```

# AI分析结果

### 题目内容重写
有 $N$ 个玩具，编号从 $1$ 到 $N$，以及 $N-1$ 个箱子，编号从 $1$ 到 $N-1$。玩具 $i$ 的大小为 $A_i$，箱子 $i$ 的大小为 $B_i$。高桥君想把所有玩具分别放入不同的箱子中。他计划按以下步骤操作：

- 选择任意正整数 $x$，购买一个大小为 $x$ 的箱子。
- 将 $N$ 个玩具分别放入 $N$ 个箱子（包括原有的箱子和新购买的箱子）中，但每个玩具只能放入大小不小于该玩具的箱子，且每个箱子只能放一个玩具。

高桥君想通过购买合适大小的箱子来完成第 $2$ 步，但箱子越大价格越高，因此他想尽可能购买小箱子。请判断是否存在能满足条件的 $x$ 值，如果存在，请输出最小值；如果不存在，请输出 $-1$。

### 题解综合分析与结论
本题的核心在于如何通过贪心或二分的方法，找到最小的 $x$ 值，使得所有玩具都能被放入箱子中。大多数题解采用了排序后贪心匹配的思路，部分题解则使用了二分答案的方法。贪心策略的核心是将玩具和箱子从大到小排序，尽可能让最大的玩具放入最大的箱子，若无法匹配则记录下需要购买的箱子大小。二分答案的思路则是通过二分查找确定最小的 $x$ 值，并验证其是否满足条件。

### 评分较高的题解

#### 题解1：作者：huangrenheluogu (评分：4星)
**关键亮点**：  
- 采用了贪心策略，将玩具和箱子从大到小排序，尽可能让最大的玩具放入最大的箱子。
- 代码简洁，逻辑清晰，直接通过遍历判断是否需要购买新箱子。

**核心代码**：
```cpp
sort(a + 1, a + n + 1), sort(b + 1, b + n);
reverse(a + 1, a + n + 1), reverse(b + 1, b + n);
ans = a[n];
for(int i = 1; i <= n; i++){
    if(a[i] > b[i]){
        ans = a[i];
        for(int j = i + 1, k = i; j <= n; j++, k++){
            if(a[j] > b[k]){
                puts("-1");
                return 0;
            }
        }
        printf("%d\n", ans);
        return 0;
    }
}
```
**实现思想**：  
将玩具和箱子从大到小排序，依次匹配，若发现无法匹配则记录下需要购买的箱子大小，并检查后续是否还有无法匹配的情况。

#### 题解2：作者：MLE_Automaton (评分：4星)
**关键亮点**：  
- 使用了二分答案的方法，通过二分查找确定最小的 $x$ 值。
- 代码结构清晰，二分查找的逻辑明确，适合处理大规模数据。

**核心代码**：
```cpp
bool check(int x)
{
    rep(i, 1, n)
    {
        if (i == x) continue;
        if (a[i] > b[i - (i > x)]) return 0;
    }
    return 1;
}
```
**实现思想**：  
通过二分查找确定最小的 $x$ 值，并在 `check` 函数中验证该值是否满足条件。

#### 题解3：作者：Cosine_Func (评分：4星)
**关键亮点**：  
- 同样采用了二分答案的方法，但使用了 `upper_bound` 来优化查找过程。
- 代码简洁，逻辑清晰，适合处理大规模数据。

**核心代码**：
```cpp
bool check(int x){
    int j=upper_bound(b.begin(),b.end(),x)-b.begin();
    for(int i=0;i<n;i++){
        int u;
        if(i<j)u=b[i];
        else if(i==j)u=x;
        else u=b[i-1];
        if(u<a[i])return 0;
    }
    return 1;
}
```
**实现思想**：  
通过 `upper_bound` 查找合适的箱子大小，并验证是否满足所有玩具的匹配条件。

### 最优关键思路或技巧
1. **贪心策略**：将玩具和箱子从大到小排序，尽可能让最大的玩具放入最大的箱子，若无法匹配则记录下需要购买的箱子大小。
2. **二分答案**：通过二分查找确定最小的 $x$ 值，并在验证函数中检查是否满足所有玩具的匹配条件。

### 可拓展之处
- **类似题目**：可以扩展到多个箱子或多个玩具的匹配问题，或者考虑箱子的容量限制。
- **算法套路**：贪心和二分答案的结合可以应用于其他类似的匹配问题，如任务分配、资源调度等。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
3. [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)

### 个人心得摘录
- **调试经历**：部分题解中提到在二分查找时需要注意边界条件的处理，避免出现死循环或遗漏情况。
- **踩坑教训**：在贪心匹配时，需要确保所有玩具都能被匹配，否则会导致错误结果。
- **顿悟感想**：二分答案的单调性验证是解决问题的关键，通过合理的验证函数可以快速找到最优解。

---
处理用时：44.38秒
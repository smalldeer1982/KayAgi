# 题目信息

# [AGC039A] Connection and Disconnection

## 题目描述

给定一个字符串 $S$，令 $T$ 为 $S$ 的 $K$ 个副本首尾相接得到的字符串。  
我们可以重复进行以下操作：选择 $T$ 中的一个字符并将其替换为另一个字符。  
请最小化能使得 $T$ 中任意相邻字符不相同的最少操作数。

## 说明/提示

### 数据限制
- $1 \le |S| \le 100$。
- $S$ 仅由小写字母组成。
- $K \in [1,10^9] \bigcap \mathbb Z$。

### 样例解释 1
$T = \texttt{issiiissii}$。  
一种可行的方案是将其改写为 $\texttt{ispiqisyhi}$，此时任意相邻字符不相同。

## 样例 #1

### 输入

```
issii

2```

### 输出

```
4```

## 样例 #2

### 输入

```
qq

81```

### 输出

```
81```

## 样例 #3

### 输入

```
cooooooooonteeeeeeeeeest

999993333```

### 输出

```
8999939997```

# AI分析结果

### 题目内容重写

**【题目描述】**

给定一个字符串 $S$，令 $T$ 为 $S$ 的 $K$ 个副本首尾相接得到的字符串。  
我们可以重复进行以下操作：选择 $T$ 中的一个字符并将其替换为另一个字符。  
请最小化能使得 $T$ 中任意相邻字符不相同的最少操作数。

**【说明/提示】**

### 数据限制
- $1 \le |S| \le 100$。
- $S$ 仅由小写字母组成。
- $K \in [1,10^9] \bigcap \mathbb Z$。

### 样例解释 1
$T = \texttt{issiiissii}$。  
一种可行的方案是将其改写为 $\texttt{ispiqisyhi}$，此时任意相邻字符不相同。

**【样例 #1】**

### 输入
```
issii
2
```

### 输出
```
4
```

**【样例 #2】**

### 输入
```
qq
81
```

### 输出
```
81
```

**【样例 #3】**

### 输入
```
cooooooooonteeeeeeeeeest
999993333
```

### 输出
```
8999939997
```

---

### 题解综合分析与结论

本题的核心在于如何高效计算字符串 $T$ 中相邻字符不相同的最小操作数。由于 $K$ 的范围很大（$1 \le K \le 10^9$），直接模拟字符串 $T$ 是不可行的。因此，题解的核心思路是通过分析字符串 $S$ 的结构，推导出 $T$ 的操作数。

#### 关键思路：
1. **分段处理**：将字符串 $S$ 分割成若干段，每段由相同字符组成，记录每段的长度。
2. **特殊情况处理**：如果字符串 $S$ 中所有字符相同，直接输出 $\left\lfloor |S| \times K / 2 \right\rfloor$。
3. **首尾处理**：如果字符串 $S$ 的首尾字符相同，且首尾段的长度均为奇数，则需要额外处理。
4. **公式推导**：通过计算 $S$ 的操作数和 $S$ 重复一次的操作数，推导出 $T$ 的操作数。

#### 难点对比：
- **cqbztz2** 和 **haotian1234** 的题解思路相似，都是通过计算 $S$ 和 $S$ 重复一次的操作数，推导出 $T$ 的操作数。但 **haotian1234** 的代码更简洁，且处理了特殊情况。
- **MattL** 的题解通过记录字符串的结构，直接推导出 $T$ 的操作数，思路清晰且代码简洁。
- **Obviathy** 的题解通过记录字符串的结构，并分段处理，推导出 $T$ 的操作数，思路较为复杂，但代码实现较为完整。

#### 最优思路：
**MattL** 的题解通过记录字符串的结构，直接推导出 $T$ 的操作数，思路清晰且代码简洁，是最优的解决方案。

---

### 所选高星题解

#### 1. **MattL** (5星)
- **关键亮点**：通过记录字符串的结构，直接推导出 $T$ 的操作数，思路清晰且代码简洁。
- **代码实现**：
```cpp
#include<bits/stdc++.h> 
using namespace std;
string s;
long long n,cnt=1,ans,qp;
int main()
{
	cin>>s>>n;
	for(int i=1;i<s.size();i++)
		if(s[i-1]==s[i])cnt++;
		else qp=qp?qp:cnt,ans+=cnt/2,cnt=1;
	if(cnt==s.size()&&(s.size()&1))cout<<cnt*n/2,exit(0);
	ans+=cnt/2;
	if(s[0]==s[s.size()-1]&&(qp&1)&&(cnt&1))cout<<(ans+1)*n-1,exit(0);
	cout<<ans*n<<endl;
	return 0;
}
```

#### 2. **haotian1234** (4星)
- **关键亮点**：通过计算 $S$ 和 $S$ 重复一次的操作数，推导出 $T$ 的操作数，代码简洁且处理了特殊情况。
- **代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ls,n,i,ans1,ans2;
string s;
int pd(){
	for (i=0;i<ls-1;i++)
		if (s[i]!=s[i+1]) return 0;
	return 1;
}
int main(){
	cin>>s;ls=s.size();
	scanf("%lld",&n);
	if (pd()) {
		printf("%lld\n",ls*n/2);
		return 0;
	}
	for (i=0;i<ls;i++)
		if (s[i]==s[i+1])
			ans1++,i++;
	for (i=0;i+1<ls*2;i++)
		if (s[i%ls]==s[(i+1)%ls])
			ans2++,i++;
	printf("%lld\n",ans1+(ans2-ans1)*(n-1));
	return 0;
}
```

#### 3. **cqbztz2** (4星)
- **关键亮点**：通过计算 $S$ 和 $S$ 重复一次的操作数，推导出 $T$ 的操作数，思路清晰。
- **代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,ans1,ans2;
string s;
bool check(){
    for(int i=1;i<s.length();i++){
        if(s[i]!=s[i-1]) return false;
    }
    return true;
}
int main(){
    cin>>s>>k;
    if(check()==true){
        cout<<s.length()*k/2;
    }
    else{
        for(long long i=0;i<s.length();i++){
            if(s[i]==s[i+1]){
                ans1++;
                i++;
            }
        }
        for(long long i=0;i+1<s.length()*2;i++){
            if(s[i%s.length()]==s[(i+1)%s.length()]){
                ans2++;
                i++;
            }
        }
        cout<<ans1+(ans2-ans1)*(k-1);
    }
    return 0;
}
```

---

### 最优关键思路与技巧

1. **分段处理**：将字符串 $S$ 分割成若干段，每段由相同字符组成，记录每段的长度。
2. **特殊情况处理**：如果字符串 $S$ 中所有字符相同，直接输出 $\left\lfloor |S| \times K / 2 \right\rfloor$。
3. **首尾处理**：如果字符串 $S$ 的首尾字符相同，且首尾段的长度均为奇数，则需要额外处理。
4. **公式推导**：通过计算 $S$ 的操作数和 $S$ 重复一次的操作数，推导出 $T$ 的操作数。

---

### 可拓展之处

1. **类似题目**：可以扩展到处理更复杂的字符串操作问题，如字符串的插入、删除等操作。
2. **算法套路**：分段处理和公式推导是解决类似问题的常用套路，可以应用于其他字符串处理问题。

---

### 推荐题目

1. **P3375 【模板】KMP字符串匹配**：考察字符串匹配算法，与本题的字符串处理思路相似。
2. **P3370 【模板】字符串哈希**：考察字符串哈希算法，与本题的字符串处理思路相似。
3. **P3371 【模板】最小表示法**：考察字符串的最小表示法，与本题的字符串处理思路相似。

---
处理用时：56.15秒
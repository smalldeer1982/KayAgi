# 题目信息

# [ARC153A] AABCDDEFE

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc153/tasks/arc153_a

正整数 $ x $ が**美しい整数**であるとは，$ x $ が $ 9 $ 桁の整数であり，その $ 10 $ 進法表記 $ S_1\ldots\ S_9 $ （$ S_i $ は $ x $ の $ 10 $ 進法表記の $ i $ 文字目）が以下の条件をすべて満たすことをいいます：

- $ S_1 $ は `0` ではない
- $ S_1\ =\ S_2 $
- $ S_5\ =\ S_6 $
- $ S_7\ =\ S_9 $
 
例えば $ 998244353 $ や $ 333333333 $ は美しい整数です．$ 111112222 $ は $ S_5\ \neq\ S_6 $ であるため美しい整数ではありません．

正の整数 $ N $ が与えられます．小さい方から数えて $ N $ 番目の美しい整数を答えてください．

## 说明/提示

### 制約

- $ N $ は正の整数
- 美しい整数が $ N $ 個以上存在する
 
### Sample Explanation 1

美しい整数を小さい順に並べると，$ 110000000,\ 110000010,\ 110000020,\ \ldots $ となります．

## 样例 #1

### 输入

```
3```

### 输出

```
110000020```

## 样例 #2

### 输入

```
882436```

### 输出

```
998244353```

## 样例 #3

### 输入

```
2023```

### 输出

```
110200222```

# AI分析结果

### 题目内容重写

【题目描述】

正整数 $x$ 被称为**美しい整数**（美丽整数），当且仅当 $x$ 是一个 9 位数，且其十进制表示 $S_1\ldots S_9$（$S_i$ 表示 $x$ 的第 $i$ 位数字）满足以下条件：

- $S_1$ 不是 `0`；
- $S_1 = S_2$；
- $S_5 = S_6$；
- $S_7 = S_9$。

例如，$998244353$ 和 $333333333$ 是美丽整数，而 $111112222$ 不是，因为 $S_5 \neq S_6$。

给定一个正整数 $N$，求第 $N$ 个美丽整数。

【说明/提示】

**约束条件：**

- $N$ 是正整数；
- 美丽整数的数量至少为 $N$ 个。

**样例解释 1：**

美丽整数按从小到大排列为：$110000000, 110000010, 110000020, \ldots$。

### 综合分析与结论

本题的核心在于如何高效地生成满足特定条件的 9 位数，并找到第 $N$ 个符合条件的数。题解中主要出现了以下几种思路：

1. **暴力枚举**：通过多重循环枚举所有可能的数字组合，直接生成符合条件的数。虽然时间复杂度较高，但由于常数较小，能够通过。
2. **数学转化**：通过观察条件，将 9 位数转化为 6 位数，从而简化问题。
3. **数位 DP**：使用数位动态规划来统计符合条件的数的数量，结合二分查找来快速定位第 $N$ 个数。
4. **打表法**：通过预处理生成所有符合条件的数，然后直接查询。

### 所选高星题解

#### 题解 1：U_star (4星)

**关键亮点：**  
- 通过数学转化，将 9 位数问题转化为 6 位数问题，极大简化了问题。
- 代码简洁，直接通过字符串操作生成结果。

**核心代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin>>n;
    string s=to_string(n+99999);
    cout<<s[0]<<s[0]<<s[1]<<s[2]<<s[3]<<s[3]<<s[4]<<s[5]<<s[4];
    return 0; 
}
```

#### 题解 2：chlchl (4星)

**关键亮点：**  
- 使用数位 DP 结合二分查找，避免了暴力枚举的高时间复杂度。
- 代码结构清晰，逻辑严谨，适合处理更复杂的类似问题。

**核心代码：**
```cpp
int dp(int len, int op, int lst1, int lst2){
    if(!len) return 1;
    if(~f[len][op][lst1][lst2]) return f[len][op][lst1][lst2];
    int k = (op ? dgt[len] : 9);
    int cnt = 0;
    for(int d=0;d<=k;d++){
        if(len == 9 && d == 0) continue;
        if(len == 8 && d != lst1) continue;
        if(len == 4 && d != lst1) continue;
        if(len == 1 && d != lst2) continue;
        cnt += dp(len - 1, op & (d == k), d, lst1);
    }
    return f[len][op][lst1][lst2] = cnt;
}
```

#### 题解 3：FyFive (4星)

**关键亮点：**  
- 通过数学推导，直接将 $N$ 转化为 6 位数，再生成 9 位数。
- 代码简洁，时间复杂度为 $O(1)$，效率极高。

**核心代码：**
```cpp
int main()
{
    cin>>n;
    --n;
    n+=100000;
    ans=101*(n%100/10);
    ans+=10*(n%10);
    ans+=11000*(n%1000/100);
    ans+=100000*(n%10000/1000);
    ans+=1000000*(n%100000/10000);
    ans+=110000000*(n/100000);
    cout<<ans;
    return 0;
}
```

### 最优关键思路或技巧

1. **数学转化**：通过观察条件，将 9 位数问题转化为 6 位数问题，极大地简化了问题。
2. **数位 DP**：适用于处理复杂的数位条件问题，结合二分查找可以高效地找到第 $N$ 个符合条件的数。
3. **直接生成**：通过数学推导直接生成结果，避免了复杂的枚举过程，时间复杂度为 $O(1)$。

### 可拓展之处

- **类似问题**：可以扩展到其他位数或更复杂的数位条件问题，如要求某些位数的和或积满足特定条件。
- **数位 DP**：在处理数位相关问题时，数位 DP 是一个非常强大的工具，可以结合二分查找、记忆化搜索等技巧来优化。

### 推荐题目

1. [P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657)
2. [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)
3. [P4124 [CQOI2016] 手机号码](https://www.luogu.com.cn/problem/P4124)

### 个人心得摘录

- **U_star**：通过观察条件，发现可以将 9 位数问题转化为 6 位数问题，极大简化了问题。
- **chlchl**：数位 DP 在处理复杂数位条件问题时非常有效，结合二分查找可以快速定位结果。
- **FyFive**：通过数学推导直接生成结果，避免了复杂的枚举过程，代码简洁且高效。

---
处理用时：57.87秒
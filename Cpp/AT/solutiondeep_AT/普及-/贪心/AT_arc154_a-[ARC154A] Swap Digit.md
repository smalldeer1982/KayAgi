# 题目信息

# [ARC154A] Swap Digit

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc154/tasks/arc154_a

先頭の桁が $ 0 $ でない $ N $ 桁の正整数 $ A,B $ が与えられます。

あなたは、以下の操作を好きな回数（$ 0 $ 回でもよい）繰り返すことができます。

- $ 0\ \le\ i\ \le\ N-1 $ を満たす整数 $ i $ を選び、$ A,B $ の $ 10^{i} $ の位の数字を交換する。
 
操作を終えたときの $ A\ \times\ B $ の最小値を $ 998244353 $ で割ったあまりを求めてください。

$ A\ \times\ B $ を $ 998244353 $ で割ったあまりの最小値を求めるのではないことに注意してください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 200000 $
- $ A,B $ は先頭の桁が $ 0 $ でない $ N $ 桁の正整数
 
### Sample Explanation 1

以下のように $ 1 $ 回操作を行うと $ A\ \times\ B $ を $ 276 $ にすることが出来ます。 - $ i=0 $ を選び、$ A,B $ の $ 1 $ の位の数字を交換する。$ A=12,B=23 $ となる。 $ A\ \times\ B $ を $ 275 $ 以下にすることは出来ないので、答えは $ 276 $ です。

### Sample Explanation 2

$ 998244353 $ で割ったあまりを求めてください。

## 样例 #1

### 输入

```
2

13

22```

### 输出

```
276```

## 样例 #2

### 输入

```
8

20220122

21002300```

### 输出

```
54558365```

# AI分析结果

【题目内容】
# [ARC154A] Swap Digit

## 题目描述

给定两个首位不为0的N位正整数A和B。你可以进行以下操作任意次（包括0次）：

- 选择一个满足0 ≤ i ≤ N-1的整数i，交换A和B的第i位数字。

操作结束后，求A × B的最小值，并将结果对998244353取模。

注意：不是求A × B对998244353取模的最小值。

## 说明/提示

### 制約

- 1 ≤ N ≤ 200000
- A和B是首位不为0的N位正整数

### 样例解释1

通过一次操作，可以将A × B的值变为276。具体操作为选择i=0，交换A和B的个位数字，得到A=12，B=23。无法将A × B的值降到275以下，因此答案为276。

### 样例解释2

需要对结果取模998244353。

## 样例 #1

### 输入

```
2

13

22```

### 输出

```
276```

## 样例 #2

### 输入

```
8

20220122

21002300```

### 输出

```
54558365```

【题解分析与结论】

各题解的核心思路基本一致，即通过交换A和B的每一位数字，使得A和B的差值最大化，从而最小化A × B的值。具体实现上，各位题解都采用了贪心策略，遍历每一位，将较大的数字分配给A，较小的数字分配给B。最后，通过逐位计算并取模的方式得到最终结果。

【评分较高的题解】

1. **作者：Register_int (4星)**
   - **关键亮点**：思路清晰，代码简洁，直接通过遍历交换每一位数字，并逐位计算取模。
   - **代码核心**：
     ```cpp
     for (int i = 0; i < n; i++) if (a[i] < b[i]) swap(a[i], b[i]);
     for (int i = 0; i < n; i++) x = (x * 10 + a[i] - '0') % mod, y = (y * 10 + b[i] - '0') % mod;
     printf("%lld", x * y % mod);
     ```

2. **作者：Iniaugoty (4星)**
   - **关键亮点**：详细证明了“和一定差大积小”的数学原理，增强了题解的理论基础。
   - **代码核心**：
     ```cpp
     for(int i=0;i<n;i++){
         if(A[i]<B[i])
             swap(A[i],B[i]);
         a=(a*10+A[i]-'0')%mod;
         b=(b*10+B[i]-'0')%mod;
     }
     printf("%lld",a*b%mod);
     ```

3. **作者：Crazyouth (4星)**
   - **关键亮点**：代码结构清晰，逐位处理并取模，避免了高精度计算的复杂度。
   - **代码核心**：
     ```cpp
     for(int i=0;i<n;i++)
     {
         if(s1[i]<s2[i]) swap(s1[i],s2[i]);
     }
     x=s1[0]-'0';
     y=s2[0]-'0';
     for(int i=1;i<n;i++)
     {
         x=x*10%MOD+(s1[i]-'0');
         y=y*10%MOD+(s2[i]-'0');
         x%=MOD;
         y%=MOD;
     }
     cout<<x*y%MOD;
     ```

【最优关键思路与技巧】

1. **贪心策略**：通过交换每一位数字，使得A和B的差值最大化，从而最小化A × B的值。
2. **逐位计算与取模**：避免高精度计算，通过逐位处理并取模的方式，保证计算的效率和正确性。

【可拓展之处】

类似的问题可以通过贪心策略和逐位处理的方式解决，特别是在涉及大数运算和取模的场景下。例如，处理大数的加减乘除、最大最小值等问题时，可以采用类似的思路。

【推荐题目】

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
3. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)

---
处理用时：34.63秒
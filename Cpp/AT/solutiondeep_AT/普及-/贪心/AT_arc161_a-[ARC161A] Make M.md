# 题目信息

# [ARC161A] Make M

## 题目描述

$N$ 是一个正奇数。我们称一个长度为 $N$ 的序列 $S$ 是 **M 型**序列，当前仅当对于所有的 $i=2,4,6,\dots,N-1$（即偶数位），都有 $S_{i-1}<S_{i}$ 且 $S_{i}>S_{i+1}$。

现在给定你一个长度为 $N$ 的序列 $A$，请你判断能否通过将 $A$ 序列里的元素打乱位置使其变为一个 **M 型**序列。

## 样例 #1

### 输入

```
5

1 2 3 4 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5

1 6 1 6 1```

### 输出

```
Yes```

## 样例 #3

### 输入

```
5

1 6 6 6 1```

### 输出

```
No```

# AI分析结果

### 题目内容重写

#### [ARC161A] Make M

**题目描述**

$N$ 是一个正奇数。我们称一个长度为 $N$ 的序列 $S$ 是 **M 型**序列，当且仅当对于所有的 $i=2,4,6,\dots,N-1$（即偶数位），都有 $S_{i-1}<S_{i}$ 且 $S_{i}>S_{i+1}$。

现在给定你一个长度为 $N$ 的序列 $A$，请你判断能否通过将 $A$ 序列里的元素打乱位置使其变为一个 **M 型**序列。

**样例 #1**

**输入**

```
5
1 2 3 4 5
```

**输出**

```
Yes
```

**样例 #2**

**输入**

```
5
1 6 1 6 1
```

**输出**

```
Yes
```

**样例 #3**

**输入**

```
5
1 6 6 6 1
```

**输出**

```
No
```

### 题解分析与结论

#### 综合分析

本题的核心在于判断能否通过重新排列序列，使得所有偶数位的元素都大于其相邻的两个元素。各题解的思路主要集中在排序后构造序列，并通过判断某些条件来验证是否满足 M 型序列的要求。

#### 最优关键思路

1. **排序与构造**：将序列排序后，将较小的元素放在奇数位，较大的元素放在偶数位，这样可以最大化满足 M 型序列的条件。
2. **重复元素处理**：如果某个元素出现次数过多（超过一半），则需要特别处理，确保这些元素只能放在奇数位，否则无法满足条件。
3. **边界条件判断**：通过判断序列中某些特定位置的元素是否满足条件，来快速判断是否可以构造出 M 型序列。

#### 推荐题解

1. **作者：FreedomKing (5星)**
   - **关键亮点**：通过排序后间隔分布元素，构造出最优序列，并通过简单判断验证是否合法。代码简洁，思路清晰。
   - **代码核心**：
     ```cpp
     sort(a+1,a+n+1);
     for(int i=1;i<=n;i+=2) f[i]=a[++t];
     for(int i=2;i<n;i+=2) f[i]=a[++t];
     for(int i=2;i<n;i+=2){
         if(!(f[i]>f[i-1]&&f[i]>f[i+1])){
             cout<<"No";
             return 0;
         }
     }
     cout<<"Yes";
     ```

2. **作者：几何微粒子 (4星)**
   - **关键亮点**：提供了两种解法，第一种通过模拟构造序列并验证，第二种通过观察重复元素的数量来判断。思路多样，代码实现清晰。
   - **代码核心**：
     ```cpp
     sort(a+1,a+1+n);
     int top=0;
     for(int i=2;i<=n;i+=2){
         top++;
         b[i]=a[n/2+1+top];
     }
     top=0;
     for(int i=1;i<=n;i+=2){
         b[i]=a[++top];
     }
     for(int i=2;i<n;i+=2){
         if(b[i]<=b[i-1]||b[i]<=b[i+1])
             return printf("No"),0;
     }
     printf("Yes");
     ```

3. **作者：梦应归于何处 (4星)**
   - **关键亮点**：通过排序后统计特定位置的元素数量，判断是否可以构造出 M 型序列。思路清晰，代码实现简洁。
   - **代码核心**：
     ```cpp
     sort(a + 1, a + n + 1, greater<ll>());
     ll p = n / 2;
     ll cnt = 0;
     for (int i = 1; i <= p; i++) {
         if (a[i] > a[p]) {
             cnt++;
         }
     }
     ll tot = 0;
     for (int i = p + 1; i <= n; i++) {
         if (a[i] == a[p]) {
             tot++;
         } else {
             break;
         }
     }
     if (cnt >= tot) {
         cout << "Yes";
     } else {
         cout << "No";
     }
     ```

#### 拓展与推荐题目

1. **洛谷 P1090 [NOIP2004 提高组] 合并果子**（题号：P1090）
   - **相似知识点**：贪心算法，优先队列。

2. **洛谷 P1223 [NOIP2005 提高组] 排队接水**（题号：P1223）
   - **相似知识点**：贪心算法，排序。

3. **洛谷 P1068 [NOIP2009 普及组] 分数线划定**（题号：P1068）
   - **相似知识点**：排序，统计。

通过这些题目，可以进一步巩固排序、贪心算法等知识点，并提升对类似问题的解决能力。

---
处理用时：37.86秒
# 题目信息

# [ARC163A] Divide String

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc163/tasks/arc163_a

長さ $ N $ の英小文字からなる文字列 $ S $ が与えられます。$ S $ を $ 2 $ 個以上の連続部分文字列に分割し、それらが辞書順で狭義単調増加になるようにすることが出来るか判定してください。

厳密に書くと、以下の条件を全て満たす文字列の列 $ t=(t_1,t_2,\dots,t_k) $ が存在するか判定してください。

- 列の長さ $ k $ は $ 2 $ 以上である。
- $ t_i $ は空でない。($ 1\ \le\ i\ \le\ k $)
- $ t_1,t_2,\dots,t_k $ をこの順で連結すると $ S $ と一致する。
- $ 1\ \le\ i\ <\ k $ を満たす整数 $ i $ に対して、$ t_i $ は $ t_{i+1} $ より辞書順で小さい。
 
$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

  辞書順とは？文字列 $ S\ =\ S_1S_2\ldots\ S_{|S|} $ が文字列 $ T\ =\ T_1T_2\ldots\ T_{|T|} $ より**辞書順で小さい**とは、下記の 1. と 2. のどちらかが成り立つことを言います。 ここで、$ |S|,\ |T| $ はそれぞれ $ S,\ T $ の長さを表します。

1. $ |S|\ \lt\ |T| $ かつ $ S_1S_2\ldots\ S_{|S|}\ =\ T_1T_2\ldots\ T_{|S|} $。
2. ある整数 $ 1\ \leq\ i\ \leq\ \min\lbrace\ |S|,\ |T|\ \rbrace $ が存在して、下記の $ 2 $ つがともに成り立つ。 
  - $ S_1S_2\ldots\ S_{i-1}\ =\ T_1T_2\ldots\ T_{i-1} $
  - $ S_i $ が $ T_i $ よりアルファベット順で小さい文字である。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 2000 $
- $ 2\ \le\ N\ \le\ 2000 $
- $ S $ は長さ $ N $ の英小文字からなる文字列
- $ 1 $ 個の入力に含まれるテストケースについて、それらの $ N $ の総和は $ 2000 $ を超えない。
 
### Sample Explanation 1

$ 1 $ 個目のテストケースは、$ S $ を `a`,`ba`,`c` と分割すればよいです。 $ 2 $ 個目のテストケースは、$ S $ をどのように分割しても辞書順で狭義単調増加にすることは出来ません。

## 样例 #1

### 输入

```
5

4

abac

3

cac

2

ab

12

abababababab

5

edcba```

### 输出

```
Yes

No

Yes

Yes

No```

# AI分析结果

### 题目翻译
【题目内容】
# [ARC163A] Divide String

## 题目描述

给定一个长度为 $N$ 的由小写字母组成的字符串 $S$。判断是否可以将 $S$ 分割成至少两个连续的子串，使得这些子串按照字典序严格递增。

更具体地说，判断是否存在一个字符串序列 $t=(t_1,t_2,\dots,t_k)$ 满足以下所有条件：

- 序列的长度 $k$ 至少为 2。
- 每个 $t_i$ 都是非空的。（$1 \le i \le k$）
- 将 $t_1,t_2,\dots,t_k$ 按顺序连接起来，得到的结果与 $S$ 相同。
- 对于所有 $1 \le i < k$，$t_i$ 的字典序严格小于 $t_{i+1}$。

给定 $T$ 个测试用例，对每个测试用例输出答案。

### 题解分析与结论

#### 题解对比与评分
1. **zhlzt (4星)**
   - **关键亮点**：通过证明只需要将字符串分割成两个子串即可满足条件，简化了问题。代码实现简洁，直接使用 `string` 的 `<` 操作符进行字典序比较。
   - **代码核心**：枚举分割点，使用 `s.substr` 获取子串并比较字典序。
   ```cpp
   for(int i=1;i<n;i++){
       if(s.substr(0,i)<s.substr(i,n-i)){
           flag=1; break;
       }
   }
   ```

2. **Butterfly_qwq (4星)**
   - **关键亮点**：同样通过证明只需要分割成两个子串即可，代码中使用 `goto` 语句优化了循环退出逻辑。
   - **代码核心**：与 zhlzt 类似，使用 `s.substr` 进行子串分割和比较。
   ```cpp
   for(int i=1;i<n;i++){
       string ss1=s.substr(0,i),ss2=s.substr(i,n-i);
       if(ss1<ss2){
           cout<<"Yes\n";
           goto qwq;
       }
   }
   ```

3. **DengDuck (3星)**
   - **关键亮点**：提出了更复杂的优化思路，使用二分+哈希来寻找最长公共前缀，但代码实现较为复杂，且在实际应用中效率提升不明显。
   - **代码核心**：通过二分查找和哈希值比较来确定最长公共前缀。
   ```cpp
   LL LCP(LL x){
       LL l=1,r=min(x,n-x),ans=0;
       while(l<=r){
           LL mid=l+r>>1;
           if(sam(1,mid,x+1,x+mid)){
               l=mid+1,ans=mid;
           } else r=mid-1;
       }
       return ans;
   }
   ```

#### 最优思路总结
最优的思路是通过证明只需要将字符串分割成两个子串即可满足条件，从而将问题简化为枚举分割点并比较两个子串的字典序。这种方法的时间复杂度为 $O(Tn)$，足以通过题目限制。

#### 拓展思路
类似的问题可以出现在需要将字符串分割成多个子串并满足某种顺序关系的场景中。例如，分割成多个子串使得每个子串的长度递增，或者每个子串的某种属性（如字符总和）递增。

#### 推荐题目
1. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)

#### 个人心得
- **调试经历**：在实现过程中，需要注意字符串的索引和长度计算，避免越界错误。
- **顿悟感想**：通过简化问题，将复杂的分割问题转化为简单的枚举和比较，大大降低了实现难度。

---
处理用时：30.30秒
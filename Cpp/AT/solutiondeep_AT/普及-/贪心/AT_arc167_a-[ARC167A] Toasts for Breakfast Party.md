# 题目信息

# [ARC167A] Toasts for Breakfast Party

## 题目描述

# [ARC167A] Toasts for Breakfast Party


[problemUrl]: https://atcoder.jp/contests/arc167/tasks/arc167_a

浴谷的站长 kkkscO2 最近购买了 $N$ 片烤绿鸟味的扩散性百万甜面包。第 $i$ 片面包的美味值是 $a_i$。又有 $M$ 个盘子，每个盘子可以装**最多**两片面包，盘子可以空着。

定义 $b_i$ 为盘子 $i$ 里的面包的美味值的和的平方，若盘子里没有面包则 $b_i$ 为 $0$。若只有一个面包，则 $b_i$ 为该面包的美味值的平方。

求所有合法的 $\sum_{1 \le i \le M}b_i$ 的最小值。$\frac{N}{2} \le M \le N$。

## 说明/提示

- $ 1\leq\ N\leq\ 2\times\ 10^{5} $
- $ \frac{N}{2}\leq\ M\leq\ N $
- $ 1\leq\ A_{i}\leq\ 2\times\ 10^{5} $
- 保证输入的都是整数
 
### 样例1解释

我们将第 $1$ 片和第 $2$ 片面包放在第一个盘子里，第 $3$ 片和第 $4$ 片面包放在第二个盘子里。第 $5$ 片单独放在最后一个盘子里。此时的答案 $\sum_{1 \le i \le M}b_i =(1+1)^{2} + (1+6)^{2} + 7^2 = 102$。没有比该方案更优的结果。注意不能将第 $1$ 片，第 $2$ 片和第 $3$ 片放在同一个盘子里。

## 样例 #1

### 输入

```
5 3

1 1 1 6 7```

### 输出

```
102```

## 样例 #2

### 输入

```
2 1

167 924```

### 输出

```
1190281```

## 样例 #3

### 输入

```
12 9

22847 98332 854 68844 81080 46058 40949 62493 76561 52907 88628 99740```

### 输出

```
61968950639```

# AI分析结果

### 题目翻译

浴谷的站长 kkkscO2 最近购买了 $N$ 片烤绿鸟味的扩散性百万甜面包。第 $i$ 片面包的美味值是 $a_i$。又有 $M$ 个盘子，每个盘子可以装**最多**两片面包，盘子可以空着。

定义 $b_i$ 为盘子 $i$ 里的面包的美味值的和的平方，若盘子里没有面包则 $b_i$ 为 $0$。若只有一个面包，则 $b_i$ 为该面包的美味值的平方。

求所有合法的 $\sum_{1 \le i \le M}b_i$ 的最小值。$\frac{N}{2} \le M \le N$。

### 说明/提示

- $ 1\leq\ N\leq\ 2\times\ 10^{5} $
- $ \frac{N}{2}\leq\ M\leq\ N $
- $ 1\leq\ A_{i}\leq\ 2\times\ 10^{5} $
- 保证输入的都是整数

### 样例1解释

我们将第 $1$ 片和第 $2$ 片面包放在第一个盘子里，第 $3$ 片和第 $4$ 片面包放在第二个盘子里。第 $5$ 片单独放在最后一个盘子里。此时的答案 $\sum_{1 \le i \le M}b_i =(1+1)^{2} + (1+6)^{2} + 7^2 = 102$。没有比该方案更优的结果。注意不能将第 $1$ 片，第 $2$ 片和第 $3$ 片放在同一个盘子里。

### 样例 #1

#### 输入

```
5 3

1 1 1 6 7
```

#### 输出

```
102
```

### 样例 #2

#### 输入

```
2 1

167 924
```

#### 输出

```
1190281
```

### 样例 #3

#### 输入

```
12 9

22847 98332 854 68844 81080 46058 40949 62493 76561 52907 88628 99740
```

#### 输出

```
61968950639
```

### 题解分析与结论

#### 综合分析

本题的核心在于如何将面包分配到盘子中，使得所有盘子的美味值平方和最小。由于每个盘子最多可以放两片面包，且 $M$ 的范围在 $\frac{N}{2}$ 到 $N$ 之间，因此我们需要找到一种最优的分配方式。

大多数题解都采用了贪心策略，即将面包按美味值排序后，将最小的面包与最大的面包配对，以此类推。这样可以最小化每对面包的乘积，从而最小化总平方和。

#### 关键思路

1. **贪心策略**：将面包按美味值排序后，将最小的面包与最大的面包配对，以此类推。这样可以最小化每对面包的乘积，从而最小化总平方和。
2. **预处理**：将空盘子视为放有美味值为0的面包，这样可以统一处理所有情况，避免特判。
3. **数学推导**：通过完全平方公式展开，发现总平方和由固定部分和可变部分组成，只需最小化可变部分即可。

#### 评分较高的题解

1. **作者：f_hxr_ (赞：13)**
   - **星级：5**
   - **关键亮点**：详细解释了贪心策略的数学推导，代码简洁且高效。
   - **代码片段**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     typedef long long LL;
     LL N,M,a[400005],ans;
     int main(){
         cin>>N>>M;
         for(int i=1;i<=N;i++)cin>>a[i],ans+=a[i]*a[i];
         sort(a+1,a+M*2+1);
         LL LHQ=1,RMQ=M*2;
         while(LHQ<=RMQ)ans+=a[LHQ]*a[RMQ]*2,LHQ++,RMQ--;
         cout<<ans;
         return 0;
     }
     ```

2. **作者：大眼仔Happy (赞：8)**
   - **星级：4.5**
   - **关键亮点**：思路清晰，代码简洁，直接应用了贪心策略。
   - **代码片段**：
     ```cpp
     #include<bits/stdc++.h>
     using namespace std;
     const int N=4e5+5;
     #define ll long long
     ll inline read()
     {
         ll num=0,f=1;
         char ch=getchar();
         while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
         while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
         return num*f;
     }
     int n,m;
     ll a[N],ans;
     int main(){
         n=read();m=read();
         for(int i=1;i<=n;i++)a[i]=read();
         sort(a+1,a+2*m+1);
         for(int i=1;i<=2*m;i++)ans+=a[i]*a[i];
         for(int i=1;i<=m;i++)ans+=2*a[i]*a[2*m-i+1];
         printf("%lld",ans);
         return 0;
     }
     ```

3. **作者：zhangjiting (赞：4)**
   - **星级：4**
   - **关键亮点**：思路清晰，代码简洁，直接应用了贪心策略。
   - **代码片段**：
     ```cpp
     #include<bits/stdc++.h>
     #define int long long
     using namespace std;
     int b[200005],top,a[200005],ans;
     signed main(){
         int n,m;
         cin>>n>>m;
         for(int i=1;i<=n;i++){
             cin>>a[i];
         }
         sort(a+1,a+n+1);
         int x2=max(n-m,0ll);
         int x=x2*2;
         int r=x;
         int l=1;
         for(int i=1;i<=x2;i++) b[++top]=a[l++]+a[r--];
         for(int i=x+1;i<=n;i++){
             b[++top]=a[i];
         }
         for(int i=1;i<=n;i++) ans+=b[i]*b[i];
         cout<<ans;
         return 0;
     }
     ```

### 最优关键思路与技巧

1. **贪心策略**：将面包按美味值排序后，将最小的面包与最大的面包配对，以此类推。这样可以最小化每对面包的乘积，从而最小化总平方和。
2. **预处理**：将空盘子视为放有美味值为0的面包，这样可以统一处理所有情况，避免特判。
3. **数学推导**：通过完全平方公式展开，发现总平方和由固定部分和可变部分组成，只需最小化可变部分即可。

### 可拓展之处

1. **类似问题**：可以扩展到其他需要最小化或最大化某种组合的问题，如最小化乘积和、最大化平方和等。
2. **算法套路**：贪心策略在类似的分配问题中非常常见，可以通过排序和配对来优化结果。

### 推荐题目

1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录

1. **调试经历**：在处理边界情况时，需要注意数组的大小和排序的范围，避免越界或遗漏。
2. **踩坑教训**：在计算平方和时，要注意数据类型的范围，避免溢出。
3. **顿悟感想**：通过数学推导，可以更清晰地理解贪心策略的正确性，从而更自信地应用。

---
处理用时：72.83秒
# 题目信息

# [ARC174A] A Multiply

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc174/tasks/arc174_a

長さ $ N $ の整数列 $ A=(A_1,A_2,\dots,A_N) $ と整数 $ C $ が与えられます。  
 以下の操作を **高々 $ 1 $ 度** 行って達成できる $ A $ の全要素の総和の最大値を求めてください。

- $ 1\ \le\ l\ \le\ r\ \le\ N $ を満たす整数 $ l,r $ を指定し、 $ A_l,A_{l+1},\dots,A_r $ の全ての要素を $ C $ 倍する。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ -10^6\ \le\ C\ \le\ 10^6 $
- $ -10^6\ \le\ A_i\ \le\ 10^6 $
 
### Sample Explanation 1

この入力では、 $ A=(-10,10,20,30,-20),\ C=2 $ です。 $ l=2,r=4 $ と指定して操作を $ 1 $ 度行うことで、操作後の $ A $ を $ (-10,20,40,60,-20) $ とすることができます。 このとき $ A $ の全要素の総和は $ 90 $ となり、これが達成可能な最大値です。

### Sample Explanation 2

この入力では、 $ A=(-1,-2,-3,-4,-5),\ C=1000000 $ です。 操作を一度も行わないとき $ A $ の全要素の総和は $ -15 $ となり、これが達成可能な最大値です。

## 样例 #1

### 输入

```
5 2

-10 10 20 30 -20```

### 输出

```
90```

## 样例 #2

### 输入

```
5 1000000

-1 -2 -3 -4 -5```

### 输出

```
-15```

## 样例 #3

### 输入

```
9 -1

-9 9 -8 2 -4 4 -3 5 -3```

### 输出

```
13```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个长度为 \( N \) 的整数序列 \( A=(A_1,A_2,\dots,A_N) \) 和一个整数 \( C \)。  
你可以进行以下操作**最多一次**：  
- 选择满足 \( 1 \le l \le r \le N \) 的整数 \( l,r \)，并将 \( A_l,A_{l+1},\dots,A_r \) 的所有元素乘以 \( C \)。

求通过上述操作后，序列 \( A \) 的所有元素的总和的最大值。

【说明/提示】
#### 约束
- 输入均为整数
- \( 1 \le N \le 3 \times 10^5 \)
- \( -10^6 \le C \le 10^6 \)
- \( -10^6 \le A_i \le 10^6 \)

#### 样例解释
**样例 1**  
输入：  
```
5 2
-10 10 20 30 -20
```  
输出：  
```
90
```  
解释：选择 \( l=2, r=4 \) 进行操作，操作后的序列为 \( (-10,20,40,60,-20) \)，总和为 90。

**样例 2**  
输入：  
```
5 1000000
-1 -2 -3 -4 -5
```  
输出：  
```
-15
```  
解释：不进行操作时，序列的总和为 -15，这是最大可能值。

### 题解分析与结论
本题的核心在于如何选择区间 \( [l,r] \) 进行乘法操作，使得序列的总和最大化。题解普遍采用了分类讨论的思路，根据 \( C \) 的正负性分别求解最大子段和或最小子段和，并通过动态规划或前缀和优化来实现。

#### 最优关键思路
1. **分类讨论**：根据 \( C \) 的正负性，选择最大子段和（\( C > 0 \)）或最小子段和（\( C \le 0 \)）。
2. **动态规划**：使用线性动态规划求解最大/最小子段和，时间复杂度为 \( O(N) \)。
3. **前缀和优化**：通过前缀和快速计算任意区间的和，进一步优化求解过程。

#### 推荐题解
1. **作者：___Furina___（5星）**
   - **关键亮点**：详细证明了选择最大/最小子段和的正确性，代码简洁且高效。
   - **代码核心**：
     ```cpp
     int maxn=-1e16,ans,suma,sumb,minn=1e16,c,sum;
     signed main(){
         int n;
         cin>>n>>c;
         for(int i=1,x;i<=n;i++){
             cin>>x,suma=max(suma+x,x),sumb=min(sumb+x,x),sum+=x;
             maxn=max(maxn,suma),minn=min(minn,sumb);
         }
         cout<<max(sum,max(maxn*c+sum-maxn,minn*c+sum-minn));
         return 0;
     }
     ```
   - **个人心得**：作者通过数学推导证明了选择最大/最小子段和的正确性，代码实现简洁高效。

2. **作者：zzhbpyy（4星）**
   - **关键亮点**：直接对 \( C \) 的正负性进行分类讨论，代码结构清晰，易于理解。
   - **代码核心**：
     ```cpp
     if(c>0){
         for(int i=1;i<=n;i++){
             dp[i]=max(dp[i-1],0LL)+a[i];
             ans=max(ans,dp[i]);
         }
     }
     else{
         for(int i=1;i<=n;i++){
             dp[i]=min(dp[i-1],0LL)+a[i];
             ans=min(ans,dp[i]);
         }
     }
     cout<<ch+(c-1)*ans;
     ```
   - **个人心得**：作者通过简单的动态规划实现了最大/最小子段和的求解，代码逻辑清晰。

3. **作者：linjinkun（4星）**
   - **关键亮点**：详细解释了最大子段和的求解思路，并提供了完整的代码实现。
   - **代码核心**：
     ```cpp
     if(c>0){
         for(int i=1;i<=n;i++){
             f[i]=max(f[i-1]+a[i],a[i]);
             ans=max(ans,f[i]);
         }
     }
     else{
         for(int i=1;i<=n;i++){
             dp[i]=min(dp[i-1]+a[i],a[i]);
             num=min(num,dp[i]);
         }
     }
     cout<<max(sum+ans*(c-1),sum);
     ```
   - **个人心得**：作者通过动态规划求解最大/最小子段和，并详细解释了代码的实现思路。

### 推荐题目
1. **P1115 最大子段和**：本题的核心算法之一，练习最大子段和的求解。
2. **P1714 切蛋糕**：类似的最大子段和问题，但增加了区间长度的限制。
3. **P1886 滑动窗口**：滑动窗口算法的经典题目，与本题的前缀和优化思路相似。

### 个人心得总结
- **调试经历**：多位作者提到在实现过程中需要注意 \( C \) 的正负性，以及最大/最小子段和的求解细节。
- **踩坑教训**：部分作者在初始实现时忽略了 \( C \le 0 \) 的情况，导致结果错误，提醒我们在分类讨论时要全面考虑所有可能的情况。
- **顿悟感想**：通过数学推导证明选择最大/最小子段和的正确性，使得代码实现更加简洁高效。

---
处理用时：50.90秒
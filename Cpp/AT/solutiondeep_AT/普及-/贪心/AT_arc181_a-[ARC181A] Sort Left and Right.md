# 题目信息

# [ARC181A] Sort Left and Right

## 题目描述

给你一个 $(1,2,\dots,N)$ 的排列 $P=(P_1,P_2,\dots,P_N)$。

你要通过执行以下操作零次或多次来满足所有 $i=1,2,\dots,N$ 的 $P_i=i$：

- 选择一个整数 $k$，使得 $1 \leq k \leq N$。如果是 $k \geq 2$，把第 $1$ 项到第 $(k-1)$ 项的 $P$ 按升序排序。然后，如果是 $k \leq N-1$，把 $P$ 的第 $(k+1)$ 项到第 $N$ 项按升序排序。

可以证明，在这个问题的约束条件下，对于任意 $P$，都可以用有限次的运算满足所有 $i=1,2,\dots,N$ 的 $P_i=i$。请求解所需的最小运算次数。

## 说明/提示

**样例解释**

对于第一个测试用例：

- 对 $k=1$ 执行操作后，$P$ 变成了 $(2,1,3,4,5)$。
    
- 执行 $k=2$ 操作后，$P$ 变为 $(2,1,3,4,5)$。
    
- 与 $k=3$ 进行运算，结果是 $P$ 变为 $(1,2,3,4,5)$。
    
- 与 $k=4$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    
- 与 $k=5$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    

具体来说，对 $k=3$ 进行运算的结果是 $P$ 满足所有 $i=1,2,\dots,5$ 的 $P_i=i$。因此，所需的最少运算次数为 $1$。

在第三个测试用例中，先执行 $k=4$ 操作，再执行 $k=3$ 操作，结果 $P$ 变为 $(3,2,1,7,5,6,4) \rightarrow (1,2,3,7,4,5,6) \rightarrow (1,2,3,4,5,6,7)$ 。


对于 $100\%$ 的测试数据，保证 $1 \leq T \leq 10^5$，$3 \leq N \leq 2 \times 10^5$，$P$ 是 $(1,2,\dots,N)$ 的排列。

## 样例 #1

### 输入

```
3

5

2 1 3 5 4

3

1 2 3

7

3 2 1 7 5 6 4```

### 输出

```
1

0

2```

# AI分析结果

### 题目内容重写

#### [ARC181A] Sort Left and Right

**题目描述**

给定一个 $(1,2,\dots,N)$ 的排列 $P=(P_1,P_2,\dots,P_N)$。

你需要通过执行以下操作零次或多次来满足所有 $i=1,2,\dots,N$ 的 $P_i=i$：

- 选择一个整数 $k$，使得 $1 \leq k \leq N$。如果是 $k \geq 2$，把第 $1$ 项到第 $(k-1)$ 项的 $P$ 按升序排序。然后，如果是 $k \leq N-1$，把 $P$ 的第 $(k+1)$ 项到第 $N$ 项按升序排序。

可以证明，在这个问题的约束条件下，对于任意 $P$，都可以用有限次的运算满足所有 $i=1,2,\dots,N$ 的 $P_i=i$。请求解所需的最小运算次数。

**说明/提示**

**样例解释**

对于第一个测试用例：

- 对 $k=1$ 执行操作后，$P$ 变成了 $(2,1,3,4,5)$。
    
- 执行 $k=2$ 操作后，$P$ 变为 $(2,1,3,4,5)$。
    
- 与 $k=3$ 进行运算，结果是 $P$ 变为 $(1,2,3,4,5)$。
    
- 与 $k=4$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    
- 与 $k=5$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    

具体来说，对 $k=3$ 进行运算的结果是 $P$ 满足所有 $i=1,2,\dots,5$ 的 $P_i=i$。因此，所需的最少运算次数为 $1$。

在第三个测试用例中，先执行 $k=4$ 操作，再执行 $k=3$ 操作，结果 $P$ 变为 $(3,2,1,7,5,6,4) \rightarrow (1,2,3,7,4,5,6) \rightarrow (1,2,3,4,5,6,7)$ 。


对于 $100\%$ 的测试数据，保证 $1 \leq T \leq 10^5$，$3 \leq N \leq 2 \times 10^5$，$P$ 是 $(1,2,\dots,N)$ 的排列。

**样例 #1**

**输入**

```
3

5

2 1 3 5 4

3

1 2 3

7

3 2 1 7 5 6 4
```

**输出**

```
1

0

2
```

### 题解分析与结论

#### 综合分析与结论

本题的核心在于通过最少的操作次数将排列 $P$ 变为有序排列。大多数题解都采用了分类讨论的思路，将问题分为以下几种情况：

1. **0次操作**：当排列已经有序时，直接输出0。
2. **1次操作**：当存在某个位置 $i$，使得 $P_i = i$，且 $P_1$ 到 $P_{i-1}$ 都小于 $i$，$P_{i+1}$ 到 $P_n$ 都大于 $i$ 时，只需一次操作即可。
3. **2次操作**：当 $P_1 \neq n$ 或 $P_n \neq 1$ 时，可以通过两次操作将排列变为有序。
4. **3次操作**：当 $P_1 = n$ 且 $P_n = 1$ 时，需要三次操作。

大多数题解的思路相似，主要通过预处理前缀最大值和后缀最小值来判断是否满足1次操作的条件，然后根据特殊情况判断是否需要2次或3次操作。

#### 最优关键思路

1. **分类讨论**：通过将问题分为几种情况，简化了问题的复杂度。
2. **预处理**：通过预处理前缀最大值和后缀最小值，快速判断是否满足1次操作的条件。
3. **特殊情况处理**：针对 $P_1 = n$ 且 $P_n = 1$ 的特殊情况，单独处理。

#### 可拓展之处

本题的解题思路可以拓展到其他类似的排序问题，尤其是涉及到通过有限次操作将序列变为有序的问题。类似的题目可以通过分类讨论和预处理来简化问题。

#### 推荐题目

1. [P3792 由乃与大母神原型和偶像崇拜](https://www.luogu.com.cn/problem/P3792)
2. [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

#### 个人心得摘录

- **调试经历**：在判断1次操作的条件时，需要注意边界条件的处理，尤其是当 $i = 1$ 或 $i = n$ 时的情况。
- **踩坑教训**：在处理特殊情况时，容易忽略 $P_1 = n$ 且 $P_n = 1$ 的情况，导致答案错误。
- **顿悟感想**：通过分类讨论和预处理，可以大大简化问题的复杂度，提高解题效率。

### 所选高分题解

#### 题解1：作者：Register_int (赞：12)

**星级：5星**

**关键亮点**：
- 通过预处理前缀最大值和后缀最小值，快速判断是否满足1次操作的条件。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) pre[i] = max(pre[i - 1], a[i]);
for (int i = n; i; i--) suf[i] = min(suf[i + 1], a[i]);
for (int i = 1; i <= n; i++) {
    if (pre[i] == i && suf[i] == i && a[i] == i) { f = 1; break; }
}
if (f) { puts("1"); continue; }
puts(a[1] == n && a[n] == 1 ? "3" : "2");
```

#### 题解2：作者：include13_fAKe (赞：4)

**星级：4星**

**关键亮点**：
- 通过枚举每个位置，判断是否满足1次操作的条件。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    max1 = max(max1, p[i]);
    if (p[i] == i && max1 == i) {
        puts("1");
        return;
    }
}
if (p[1] == n && p[n] == 1) {
    puts("3");
    return;
}
puts("2");
```

#### 题解3：作者：zhlzt (赞：0)

**星级：4星**

**关键亮点**：
- 通过预处理前缀最大值和后缀最小值，快速判断是否满足1次操作的条件。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) dpl[i] = max(dpl[i - 1], p[i]);
for (int i = n; i >= 1; i--) dpr[i] = min(dpr[i + 1], p[i]);
for (int i = 1; i <= n; i++) {
    tag |= (dpl[i - 1] < p[i] && p[i] < dpr[i + 1]);
}
if (tag) puts("1");
else if (p[1] != n || p[n] != 1) puts("2");
else puts("3");
```

---
处理用时：58.66秒
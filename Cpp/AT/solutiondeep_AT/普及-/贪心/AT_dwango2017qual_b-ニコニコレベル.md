# 题目信息

# ニコニコレベル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dwacon2017-prelims/tasks/dwango2017qual_b

ニコニコ文字列とは、`25` を $ 0 $ 回以上繰り返した文字列のことをいいます。たとえば `25` や `252525` や空文字列はニコニコ文字列ですが、`123` や `225` はニコニコ文字列ではありません。

ある文字列 $ S $ がその連続した部分文字列として含む最長のニコニコ文字列の長さを $ S $ の **ニコニコレベル** といいます。 たとえば `52525`, `25025`, `12151` のニコニコレベルはそれぞれ $ 4 $, $ 2 $, $ 0 $ です。

ニワンゴくんは `0` から `9` の数字と `?` からなる文字列 $ T $ を持っており、それぞれの `?` を好きな数字に置き換えることで、数字のみからなる文字列 $ T' $ を作ろうとしています。ニワンゴくんが作ることのできる文字列 $ T' $ のニコニコレベルの最大値を求めて下さい。

## 说明/提示

### 制約

- $ 1\ ≦\ |T|\ ≦\ 10^5 $
- $ T $ の文字は $ 0 $ から $ 9 $ の数字か `?` のいずれかである。

### Sample Explanation 1

`?` を前から順に `5` と `2` に置き換えて `1252567890` とすると、$ 2 $ 文字目から $ 5 $ 文字目が `2525` となり、ニコニコレベル $ 4 $ の文字列を作ることができます。

### Sample Explanation 3

`25` が全く現れない文字列はニコニコレベル $ 0 $ になります。

## 样例 #1

### 输入

```
12??567890```

### 输出

```
4```

## 样例 #2

### 输入

```
65?5?4?```

### 输出

```
2```

## 样例 #3

### 输入

```
314159265358979```

### 输出

```
0```

## 样例 #4

### 输入

```
2???5????```

### 输出

```
8```

## 样例 #5

### 输入

```
52```

### 输出

```
0```

# AI分析结果

### 题目内容翻译

**题目描述**

ニコニコ文字列是指由 `25` 重复零次或多次组成的字符串。例如，`25`、`252525` 和空字符串都是ニコニコ文字列，而 `123` 和 `225` 则不是。

给定一个字符串 $S$，其最长的连续子串中ニコニコ文字列的长度称为 $S$ 的 **ニコニコレベル**。例如，`52525`、`25025`、`12151` 的ニコニコレベル分别为 $4$、$2$、$0$。

ニワンゴくん有一个由 `0` 到 `9` 的数字和 `?` 组成的字符串 $T$，他希望通过将每个 `?` 替换为任意数字，得到一个只包含数字的字符串 $T'$。求 $T'$ 的ニコニコレベルの最大值。

**说明/提示**

### 约束

- $1 \leq |T| \leq 10^5$
- $T$ 的字符为 `0` 到 `9` 的数字或 `?`。

### 样例解释

**样例 1**

输入：
```
12??567890
```
输出：
```
4
```
解释：将 `?` 依次替换为 `5` 和 `2`，得到 `1252567890`，其中 `2525` 是ニコニコ文字列，长度为 $4$。

**样例 3**

输入：
```
314159265358979
```
输出：
```
0
```
解释：字符串中没有 `25`，因此ニコニコレベル为 $0$。

### 题解分析与结论

#### 综合分析

本题的核心是找到字符串 $T$ 中最长的ニコニコ文字列，且可以通过替换 `?` 来最大化这个长度。由于ニコニコ文字列由 `25` 重复组成，因此可以通过动态规划（DP）来解决。

所有题解都采用了类似的动态规划思路，定义了两个状态数组 `dp2` 和 `dp5`，分别表示当前位置为 `2` 或 `5` 时的最大ニコニコレベル。状态转移方程如下：

- 如果当前字符为 `2` 或 `?`，则 `dp2[i] = dp5[i-1] + 1`。
- 如果当前字符为 `5` 或 `?`，且前一个字符为 `2` 或 `?`，则 `dp5[i] = dp2[i-1] + 1`。

最终答案为 `dp5` 数组中的最大值。

#### 最优关键思路

1. **动态规划状态定义**：使用 `dp2` 和 `dp5` 分别表示当前位置为 `2` 或 `5` 时的最大ニコニコレベル。
2. **状态转移方程**：根据当前字符和前一个字符的状态进行转移，确保 `25` 的连续出现。
3. **时间复杂度**：由于每个字符只需处理一次，时间复杂度为 $O(n)$，满足题目约束。

#### 可拓展之处

- **类似问题**：可以扩展到其他由特定模式重复组成的字符串问题，如 `123`、`abc` 等。
- **优化**：可以通过滚动数组优化空间复杂度，进一步减少内存使用。

### 推荐题目

1. **洛谷 P1040**：最长公共子序列（LCS）
2. **洛谷 P1091**：合唱队形
3. **洛谷 P1095**：守望者的逃离

### 所选高分题解

#### 题解1：作者：Stone_Xz (★★★★☆)

**关键亮点**：
- 状态定义清晰，代码简洁。
- 详细解释了状态转移方程的逻辑。

**核心代码**：
```cpp
for(int i = 1; i <= len; i++)
{
    if(s[i] == '?' || s[i] == '2')
        dp_2[i] = dp_5[i - 1] + 1;
        
    if((s[i] == '?' || s[i] == '5') && dp_2[i - 1] >= 1)
        dp_5[i] = dp_2[i - 1] + 1;
}
```

#### 题解2：作者：__owowow__ (★★★★☆)

**关键亮点**：
- 代码简洁，逻辑清晰。
- 对状态转移方程的解释简洁明了。

**核心代码**：
```cpp
for(int i=0;i<s.size();i++){
    if(s[i]=='2'||s[i]=='?') f2[i]=f5[i-1]+1;
    if((s[i]=='5'||s[i]=='?')&&f2[i-1]>=1) f5[i]=f2[i-1]+1;
}
```

#### 题解3：作者：Kvaratskhelia (★★★★☆)

**关键亮点**：
- 代码简洁，状态转移方程清晰。
- 对问题的分析较为深入。

**核心代码**：
```cpp
for(int i=0;i<int(st.size());i++)
{
    if(st[i]=='2'||st[i]=='?') f[i+1][1]=f[i][2]+1;
    if(st[i]=='5'||st[i]=='?') 
        if(f[i][1]>0) f[i+1][2]=f[i][1]+1;
    ans=max(ans,f[i+1][2]);
}
```

### 个人心得摘录

- **Stone_Xz**：提到两个 `dp` 数组的维护只用到了前一个状态，因此可以调换顺序，优化代码逻辑。
- **__owowow__**：强调了 `?` 既可以作为 `2` 也可以作为 `5`，因此在状态转移时需要同时考虑这两种情况。
- **Kvaratskhelia**：指出 `Nico` 字符串只可能由 `5` 结尾，因此最终答案只需考虑 `dp5` 数组的最大值。

---
处理用时：44.59秒
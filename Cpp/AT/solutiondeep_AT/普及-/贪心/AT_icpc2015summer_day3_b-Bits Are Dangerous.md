# 题目信息

# Bits Are Dangerous

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jag2015summer-day3/tasks/icpc2015summer_day3_b

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

给你一个字符串 $s$，有两种操作：

1. 每次可以将 $s_1$ 异或 $1$，花费 $4$ 的代价。
2. 将 $s$ 循环左移一位或循环右移一位，花费 $7$ 的代价。

问你最少需要多大的代价将 $s$ 变成全 $0$ 串。

### 题解分析与结论

#### 思路对比

1. **xQWQx的题解**：
   - **思路**：通过循环左移和右移来枚举所有可能的移动方式，计算最小代价。将字符串复制一次以模拟循环移动。
   - **难点**：如何高效地枚举所有可能的移动方式，并计算最小代价。
   - **优化**：通过复制字符串来简化循环移动的计算。

2. **_xdd_的题解**：
   - **思路**：通过先遍历所有 $1$ 的位置，计算移动代价，最后加上异或代价。
   - **难点**：如何处理“回头”移动的情况，即先向左移动再向右移动。
   - **优化**：通过复制字符串来模拟循环移动，简化计算。

3. **HsNu1ly7_的题解**：
   - **思路**：枚举每个 $1$ 通过循环左移或右移到达 $s_1$ 位置的最小代价。
   - **难点**：如何高效地计算每个 $1$ 的移动代价。
   - **优化**：通过复制字符串来模拟循环移动，简化计算。

#### 最优关键思路

- **复制字符串**：通过将字符串复制一次，可以方便地模拟循环左移和右移，简化计算。
- **枚举移动方式**：通过枚举所有可能的移动方式，计算最小代价，确保找到最优解。

#### 可拓展之处

- **类似问题**：可以扩展到其他需要循环移动或枚举所有可能移动方式的问题，如字符串匹配、循环移位等。
- **算法套路**：复制字符串以简化循环移动的计算是一种常见的技巧，可以应用于其他类似问题。

#### 推荐题目

1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3376 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3376)
3. [P3377 【模板】AC自动机（加强版）](https://www.luogu.com.cn/problem/P3377)

### 所选高星题解

#### 题解1：xQWQx（4星）

- **关键亮点**：通过复制字符串简化循环移动的计算，枚举所有可能的移动方式，计算最小代价。
- **代码核心**：
  ```cpp
  string g=s+s;
  for(int t=0;t<=cnt;t++){
      while(g[i]=='0') i++;
      while(t!=0&&g[j]=='0') j++;
      int a=max(0,n-i);
      int b=j-n;
      sum=min(sum,min(a,b)+a+b);
      i++,j++;
  }
  ```

#### 题解2：_xdd_（4星）

- **关键亮点**：通过先遍历所有 $1$ 的位置，计算移动代价，最后加上异或代价，处理“回头”移动的情况。
- **代码核心**：
  ```cpp
  s += s;
  int l = 1 , r = len ;
  for (int i = 0 ; i <= tot ; i++){
      while ( s[l] == '0' ) ++l ;
      while ( s[r] == '0' && i ) ++r ;
      int S = r - len ;
      int t = max ( 0ll , len - l ) ;
      ans = min ( {ans , min ( S , t ) + t + S } ) ;
      ++l ;
      ++r ;
  }
  ```

#### 题解3：HsNu1ly7_（4星）

- **关键亮点**：枚举每个 $1$ 通过循环左移或右移到达 $s_1$ 位置的最小代价，通过复制字符串简化计算。
- **代码核心**：
  ```cpp
  s += s ;
  int l = 1 , r = len ;
  for (int i = 0 ; i <= tot ; i++){
      while ( s[l] == '0' ) ++l ;
      while ( s[r] == '0' && i ) ++r ;
      int S = r - len ;
      int t = max ( 0ll , len - l ) ;
      ans = min ( {ans , min ( S , t ) + t + S } ) ;
      ++l ;
      ++r ;
  }
  ```

### 总结

通过复制字符串来简化循环移动的计算，枚举所有可能的移动方式，计算最小代价，是一种高效且通用的解决方案。这种方法可以应用于其他需要循环移动或枚举所有可能移动方式的问题。

---
处理用时：35.62秒
# 题目信息

# 2015

## 题目描述

[problemUrl]: https://atcoder.jp/contests/NYC2015/tasks/nyc2015_1

入力は以下の形式で標準入力から与えられる。

> $ N $

 `Yes` または `No` と出力せよ。 ```

2015
```

 ```

Yes
```

 ```

2016
```

 ```

No
```

## 说明/提示

### Constraints

すぬけ君は、$ 2015 $ を $ 2 $ 進数で表すと `11111011111` となり回文になっていることに気づいた。 整数 $ N $ を (余計な $ 0 $ をつけない) $ 2 $ 進数で表したとき、回文になっているかどうか判定せよ。 ただし、左から呼んでも右から読んでも同じ文字列を回文という。

- - - - - -

- $ 1\ \leq\ N\ \leq\ 10^9 $

# AI分析结果

### 题目内容重写

**题目描述**

输入格式如下，从标准输入读取：

> $ N $

输出 `Yes` 或 `No`。

**示例**

输入：
```
2015
```
输出：
```
Yes
```

输入：
```
2016
```
输出：
```
No
```

**说明/提示**

**约束条件**

すぬけ君发现，$ 2015 $ 的二进制表示为 `11111011111`，这是一个回文。给定一个整数 $ N $，判断其二进制表示是否为回文。回文的定义是从左到右和从右到左读都相同的字符串。

- $ 1\ \leq\ N\ \leq\ 10^9 $

### 题解分析与结论

**综合分析**

本题的核心是将整数 $ N $ 转换为二进制，并判断其是否为回文。题解中主要采用了以下几种方法：

1. **使用 `bitset` 进行二进制转换**：通过 `bitset` 将整数转换为二进制字符串，然后判断是否为回文。
2. **手动转换二进制并判断回文**：通过位运算将整数转换为二进制字符串，然后判断是否为回文。
3. **利用栈和队列判断回文**：通过栈和队列的特性，分别存储二进制的正序和逆序，然后进行比较。

**最优关键思路**

- **使用 `bitset` 进行二进制转换**：`bitset` 是 C++ 标准库中的一个高效工具，能够方便地将整数转换为二进制字符串，并且支持与 `unsigned long` 之间的转换。这种方法简洁高效，适合处理大范围的整数。
- **手动转换二进制并判断回文**：通过位运算逐位获取二进制的每一位，然后存储为字符串，最后判断是否为回文。这种方法虽然需要手动处理，但代码清晰易懂，适合理解二进制转换的过程。

**推荐题解**

1. **作者：fa_555 (赞：9)**  
   **星级：5星**  
   **关键亮点**：使用 `bitset` 进行二进制转换，代码简洁高效，适合处理大范围整数。  
   **核心代码**：
   ```cpp
   bitset<32> bit;
   bit = (unsigned)N;
   s = r = bit.to_string().substr(32 - log2(N));
   reverse(r.begin(), r.end());
   cout << (s == r ? "Yes" : "No") << '\n';
   ```

2. **作者：Null_Cat (赞：5)**  
   **星级：4星**  
   **关键亮点**：通过位运算逐位获取二进制的每一位，代码清晰易懂，适合理解二进制转换的过程。  
   **核心代码**：
   ```cpp
   while(n > 0) {
       str = char((n & 1) + '0') + str;
       n >>= 1;
   }
   string cstr = str;
   reverse(str.begin(), str.end());
   puts((str == cstr ? "Yes" : "No"));
   ```

3. **作者：3water (赞：2)**  
   **星级：4星**  
   **关键亮点**：利用栈和队列的特性，分别存储二进制的正序和逆序，然后进行比较，思路新颖。  
   **核心代码**：
   ```cpp
   while (n) {
       s1.push(n & 1);
       s2.push(n & 1);
       n >>= 1;
   }
   len = s1.size() / 2;
   while (len--) {
       if (s1.top() != s2.front()) {
           cout << "No\n";
           return 0;
       }
       s1.pop();
       s2.pop();
   }
   cout << "Yes\n";
   ```

**拓展思路**

- **类似题目**：可以扩展到其他进制的回文判断，如八进制、十六进制等。
- **优化思路**：对于大范围的整数，可以考虑使用更高效的位运算或并行计算来加速二进制转换。

**推荐题目**

1. [P1017 进制转换](https://www.luogu.org/problem/P1017)
2. [P1143 进制转换](https://www.luogu.org/problem/P1143)
3. [P1062 数列](https://www.luogu.org/problem/P1062)

---
处理用时：30.70秒
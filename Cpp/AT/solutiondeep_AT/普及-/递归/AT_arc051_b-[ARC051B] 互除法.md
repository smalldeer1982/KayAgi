# 题目信息

# [ARC051B] 互除法

## 题目描述

高桥君学习了欧几里得算法，他很好奇它能以多快的速度运行。

因此，他写了以下代码。

```cpp
#include <stdio.h>

int counter = 0;
int gcd(int a, int b) {
   if (b == 0) return a;
   counter++;
   return gcd(b, a%b);
}

int main() {
   int a, b;
   scanf("%d %d", &a, &b);
   gcd(a, b);
   printf("%d\n", counter);
}
```

这个代码输入两个整数，然后用欧几里得计算它们的 $\gcd$，然后输出它递归了多少次的代码。 你想让这个程序输出各种各样的值。

具体来说，输入一个 $K$，输出一组可以使得这个程序的输出为 $K$ 的 $A$、$B$。

## 说明/提示

对于 $30\%$ 的数据，$1\le K \le 10$；

对于 $100\%$ 的数据，$1\le K \le 40$。

只输出其中一种可能的解即可。

## 样例 #1

### 输入

```
1```

### 输出

```
1 1```

## 样例 #2

### 输入

```
3```

### 输出

```
4 5```

## 样例 #3

### 输入

```
12```

### 输出

```
314159265 358979323```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕如何构造一组整数 `A`、`B`，使得欧几里得算法计算 `gcd(A, B)` 的递归次数为给定的 `K` 展开。各题解思路大致相同，核心在于利用斐波那契数列的性质，即相邻两项 `F[n - 1]` 和 `F[n]` 作为输入时，欧几里得算法的递归次数恰好为 `n`。

- **思路对比**：多数题解通过斐波那契数列的性质直接构造解，如 `Aw顿顿`、`_ZhouYuHan_`、`hero_brine`、`Tiphereth_A` 等；`xgwpp6710` 则采用倒推的方式构造解。
- **算法要点**：斐波那契数列的递推公式为 `F[n] = F[n - 1] + F[n - 2]`（`n > 2` 或 `n = 2`），通过该公式计算斐波那契数列的各项，然后取相邻两项作为 `A`、`B` 输出。
- **解决难点**：关键在于证明斐波那契数列相邻两项作为输入时，欧几里得算法的递归次数为 `n`，部分题解使用数学归纳法进行证明。

### 所选题解
- **作者：Aw顿顿 (4星)**
    - **关键亮点**：详细解释了为什么斐波那契数列相邻两项作为输入时，欧几里得算法的递归次数为 `n`，思路清晰。
    - **核心代码思想**：通过找规律和欧几里得算法的核心思想，推导出 `E(f_n, f_{n - 1})` 的递归次数为 `n`，然后递推计算斐波那契数列。
- **作者：_ZhouYuHan_ (4星)**
    - **关键亮点**：附上了完整的 C++ 代码，代码可读性高。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long fib[42]={0,1,1};//斐波那契数列
int k;
int main(){
    cin>>k;
    for(int i=3;i<=41;i++)
        fib[i]=fib[i-1]+fib[i-2];//求斐波那契数列第i项 
    cout<<fib[k]<<" "<<fib[k+1]<<"\n";//输出 
    return 0; 
}
```
- **作者：xgwpp6710 (4星)**
    - **关键亮点**：采用倒推的方式构造解，提供了另一种思路。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100009],b[100009],k;
int main()
{
    cin>>k;
    a[1]=b[1]=1;
    for(int i=2;i<=k;i++)
    {
        a[i]=b[i-1];
        b[i]=a[i-1]+b[i-1];//这里b大于a，使得一开始需要做一部换a和b的操作。容易验证这样的解满足要求。
    }
    cout<<a[k]<<" "<<b[k]<<endl;
    return 0;
}
```

### 最优关键思路或技巧
利用斐波那契数列的性质，将相邻两项作为输入，可使得欧几里得算法的递归次数等于项数，这是解决本题的关键思路。

### 可拓展之处
同类型题目可能会要求计算欧几里得算法在其他条件下的递归次数，或者要求构造满足特定递归次数的其他类型的输入。类似算法套路可用于分析其他递归算法的复杂度和构造满足特定条件的输入。

### 推荐洛谷题目
1. [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
2. [P2651 添加括号III](https://www.luogu.com.cn/problem/P2651)
3. [P1306 斐波那契公约数](https://www.luogu.com.cn/problem/P1306)

### 个人心得
题解中未包含个人心得。

---
处理用时：24.20秒
# 题目信息

# [ABC340C] Divide and Divide

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc340/tasks/abc340_c

黒板に整数 $ N $ が $ 1 $ 個書かれています。  
 高橋君は黒板に書かれている $ 2 $ 以上の整数が全て無くなるまで以下の一連の操作を繰り返します。

- 黒板に書かれている $ 2 $ 以上の整数を $ 1 $ つ選び $ x $ とする。
- 黒板から $ x $ を $ 1 $ 個消す。そして、$ 2 $ 個の整数 $ \left\ \lfloor\ \dfrac{x}{2}\ \right\rfloor,\ \left\lceil\ \dfrac{x}{2}\ \right\rceil $ を新たに黒板に書く。
- この一連の操作を行うために高橋君は $ x $ 円払う必要がある。
 
ここで $ \lfloor\ a\ \rfloor $ は $ a $ 以下の整数のうち最大のものを、$ \lceil\ a\ \rceil $ は $ a $ 以上の整数のうち最小のものを意味します。

操作を行えなくなった時点で高橋君が払った金額の総和は何円ですか？  
 なお、どのような順番で操作を行っても高橋君が払う金額の総和は一定であることが証明できます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^{17} $
 
### Sample Explanation 1

高橋君が行う操作の一例を挙げると次のようになります。 - はじめ、黒板には $ 3 $ が $ 1 $ 個書かれている。 - 高橋君は $ 3 $ を選ぶ。高橋君は $ 3 $ 円を払い、黒板から $ 3 $ を $ 1 $ 個消して $ \left\ \lfloor\ \dfrac{3}{2}\ \right\rfloor\ =\ 1,\ \left\lceil\ \dfrac{3}{2}\ \right\rceil\ =\ 2 $ を新たに黒板に書く。 - 黒板には $ 2 $ が $ 1 $ 個と $ 1 $ が $ 1 $ 個書かれている。 - 高橋君は $ 2 $ を選ぶ。高橋君は $ 2 $ 円を払い、黒板から $ 2 $ を $ 1 $ 個消して $ \left\ \lfloor\ \dfrac{2}{2}\ \right\rfloor\ =\ 1,\ \left\lceil\ \dfrac{2}{2}\ \right\rceil\ =\ 1 $ を新たに黒板に書く。 - 黒板には $ 1 $ が $ 3 $ 個書かれている。 - 黒板から $ 2 $ 以上の整数が全て無くなったので操作を終了する。 操作全体で高橋君は $ 3\ +\ 2\ =\ 5 $ 円払ったので、$ 5 $ を出力します。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

## 样例 #2

### 输入

```
340```

### 输出

```
2888```

## 样例 #3

### 输入

```
100000000000000000```

### 输出

```
5655884811924144128```

# AI分析结果

### 题目内容翻译
黑板上写着 1 个整数 $N$。
高桥君会反复进行以下一系列操作，直到黑板上所有 2 以上的整数都消失。
- 从黑板上写着的 2 以上的整数中选 1 个，设为 $x$。
- 从黑板上擦掉 1 个 $x$，然后在黑板上重新写下 2 个整数 $\left\lfloor\frac{x}{2}\right\rfloor$ 和 $\left\lceil\frac{x}{2}\right\rceil$。
- 高桥君进行这一系列操作需要支付 $x$ 日元。

这里 $\lfloor a\rfloor$ 表示不超过 $a$ 的最大整数，$\lceil a\rceil$ 表示不小于 $a$ 的最小整数。

操作无法再进行时，高桥君支付的总金额是多少日元？
另外，可以证明，无论按什么顺序进行操作，高桥君支付的总金额都是一定的。

### 综合分析与结论
这些题解主要围绕两种思路展开：记忆化搜索和找规律。

#### 记忆化搜索
- **算法要点**：定义状态 $dp_i$ 表示黑板上初始出现数字 $i$ 的代价，状态转移方程为 $dp_i = dp_{\lfloor\frac{i}{2}\rfloor}+dp_{\lceil\frac{i}{2}\rceil}+i$。由于 $N$ 最大为 $10^{17}$，使用 `map` 来记录已经计算过的状态，避免重复计算。
- **解决难点**：解决了因数据范围大无法直接开数组存储状态的问题，同时避免了大量的重复计算，将时间复杂度从指数级降低到 $O(\log^2 N)$ 或 $O(\log N)$。

#### 找规律
- **算法要点**：通过对操作过程的分析，发现操作过程中各层数字和的规律，如前 $\lfloor\log_2 n\rfloor$ 层的数都大于 1，这些数的和均为 $n$；第 $\lceil\log_2 n\rceil$ 层里只有 1 和 2，可计算出 2 的个数，进而得出答案为 $n\times\lfloor\log_2 n\rfloor + 2\times(n - 2^{\lfloor\log_2 n\rfloor})$。
- **解决难点**：避免了递归计算带来的时间开销，直接通过数学公式计算答案，时间复杂度为 $O(\log n)$。

### 高评分题解
1. **作者：Genius_Star（5 星）**
    - **关键亮点**：思路清晰，明确指出使用记忆化搜索解决因数据范围大无法朴素开数组转移的问题，代码实现规范，包含了快速读入和输出的模板。
    - **核心代码**：
```cpp
map<ll,ll> dp;
ll dfs(ll x){
    if(x<2)
        return 0;
    if(dp[x])
        return dp[x];
    ll t=dfs(x/2)+dfs((x+1)/2)+x;
    dp[x]=t;
    return t;
}
```
2. **作者：bigclever（5 星）**
    - **关键亮点**：通过对操作过程的图形化分析，找出了非常简洁的数学规律，代码实现简单，时间复杂度低。
    - **核心结论**：答案为 $n\times\lfloor\log_2 n\rfloor + 2\times(n - 2^{\lfloor\log_2 n\rfloor})$。
3. **作者：lml0928（4 星）**
    - **关键亮点**：从数据范围判断题目为数学题，通过假定操作顺序找出规律，代码实现简洁易懂。
    - **核心代码**：
```cpp
ull n;
scanf("%llu", &n);
ull now = 1;
int cnt = 0;
ull res = 0;
while(true)
{
    if(now * 2 > n)
    {
        res += 2 * (n - now);
        break;
    }
    now *= 2;
    cnt++;
    res += n;
}
printf("%llu", res);
```

### 最优关键思路或技巧
- **记忆化搜索**：使用 `map` 记录已经计算过的状态，避免重复计算，适用于状态转移方程明确但数据范围大的情况。
- **找规律**：通过对操作过程的分析和图形化展示，找出数学规律，直接通过公式计算答案，可大幅降低时间复杂度。

### 拓展思路
同类型题可能会有不同的操作规则和代价计算方式，但核心思路仍然是通过记忆化搜索或找规律来解决。类似算法套路包括动态规划、递归剪枝等。

### 洛谷相似题目推荐
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：考察动态规划的基本应用，与记忆化搜索的思想有一定关联。
2. [P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：经典的动态规划问题，可通过记忆化搜索解决。
3. [P1434 [SHOI2002]滑雪](https://www.luogu.com.cn/problem/P1434)：需要使用记忆化搜索来优化暴力搜索，避免重复计算。

### 个人心得摘录与总结
- **作者：Elysian_Realme**：通过 dfs 出小数据的答案，将原问题转化为求数列中某一项的值，再通过差分找到规律。赛时在代码细节处理上花费了较多时间。
- **作者：apiad**：通过打表列出小数据的答案和差值，发现差值可分为 $\log n$ 段的规律，但对证明不太清楚，认为比赛时 AC 即可。 

---
处理用时：34.82秒
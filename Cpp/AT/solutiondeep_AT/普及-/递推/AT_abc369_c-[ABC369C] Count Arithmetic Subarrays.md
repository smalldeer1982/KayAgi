# 题目信息

# [ABC369C] Count Arithmetic Subarrays

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc369/tasks/abc369_c

長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。

$ 1\leq\ l\leq\ r\leq\ N $ を満たす整数の組 $ (l,r) $ であって、数列 $ (A_l,A_{l+1},\dots,A_r) $ が等差数列であるようなものが何通りあるか求めてください。

なお、数列 $ (x_1,x_2,\dots,x_{|x|}) $ が等差数列であるとは、ある $ d $ が存在して $ x_{i+1}-x_i=d\ (1\leq\ i\ <\ |x|) $ であることをいいます。 特に、長さ $ 1 $ の数列は常に等差数列です。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

条件を満たす整数の組 $ (l,r) $ は $ (1,1),(2,2),(3,3),(4,4),(1,2),(2,3),(3,4),(1,3) $ の $ 8 $ 通りです。 実際、$ (l,r)=(1,3) $ のとき $ (A_l,\dots,A_r)=(3,6,9) $ は等差数列なので条件を満たしますが、 $ (l,r)=(2,4) $ のとき $ (A_l,\dots,A_r)=(6,9,3) $ は等差数列ではないので条件を満たしません。

### Sample Explanation 2

すべての整数の組 $ (l,r)\ (1\leq\ l\leq\ r\leq\ 5) $ が条件を満たします。

## 样例 #1

### 输入

```
4

3 6 9 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5

1 1 1 1 1```

### 输出

```
15```

## 样例 #3

### 输入

```
8

87 42 64 86 72 58 44 30```

### 输出

```
22```

# AI分析结果

### 题目内容翻译
给定一个长度为 $N$ 的正整数序列 $A=(A_1,A_2,\dots,A_N)$。

求满足 $1\leq l\leq r\leq N$ 的整数对 $(l,r)$ 的数量，使得序列 $(A_l,A_{l + 1},\dots,A_r)$ 为等差数列。

其中，序列 $(x_1,x_2,\dots,x_{|x|})$ 为等差数列是指存在某个 $d$，使得 $x_{i + 1}-x_i = d\ (1\leq i < |x|)$。特别地，长度为 $1$ 的序列始终是等差数列。

### 综合分析与结论
这些题解的核心思路都是围绕找出所有等差数列子串并统计其数量展开，主要有以下几种方法：
- **动态规划类**：通过记录以每个点结尾的等差数列的最大长度或个数，利用状态转移方程来计算答案。
- **双指针类**：使用双指针找出极长的等差数列子串，再根据等差数列子串的长度计算其包含的所有子串数量。
- **分治类**：将序列不断二分，分别计算左右子区间和跨过中点的等差数列数量。

各题解的主要难点在于如何避免重复计算和正确处理边界情况，不同题解采用了不同的方式来解决这些问题，如减去重复的部分、特判长度为 1 的情况等。

### 所选题解
- **作者：PineappleSummer (赞：7)，4星**
    - **关键亮点**：思路清晰，通过定义 $b_i$ 表示以第 $i$ 个点结尾的等差数列的最大长度，利用简单的状态转移方程计算答案，代码简洁易懂。
    - **核心代码**：
```cpp
signed main () {
    ios::sync_with_stdio (false);
    cin.tie (0); cout.tie (0);
    
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    b[1] = 1, b[2] = 2;
    for (int i = 3; i <= n; i++) {
        if (a[i] - a[i - 1] == a[i - 1] - a[i - 2])
            b[i] = b[i - 1] + 1;
        else b[i] = 2;
    }
    for (int i = 1; i <= n; i++) ans += b[i];
    cout << ans;
    return 0;
}
```
    - **核心实现思想**：先初始化 $b_1 = 1$，$b_2 = 2$，然后从 $i = 3$ 开始枚举，若满足等差数列条件则 $b_i = b_{i - 1} + 1$，否则 $b_i = 2$，最后将所有 $b_i$ 累加得到答案。

- **作者：ikunTLE (赞：6)，4星**
    - **关键亮点**：使用一个变量记录当前等差数列的长度，结合等差数列求和公式更新答案，思路简洁，代码实现较为高效。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=2e5+10;
int a[N];
int main(){
    int n=read();
    if(n==1)
        return printf("1\n"),0;
    for(int i=1;i<=n;++i)
        a[i]=read();
    int cnt=1;
    long long ans=n;
    for(int i=2;i<=n;++i)
        if(i>2&&a[i]-a[i-1]==a[i-1]-a[i-2])
            ++cnt;
        else{
            ans+=(long long)cnt*(cnt-1)/2;
            cnt=2;
        }
    ans+=(long long)cnt*(cnt-1)/2;
    printf("%lld\n",ans);
    return 0;
}
```
    - **核心实现思想**：用 $cnt$ 记录当前等差数列的长度，若满足等差数列条件则 $cnt$ 加 1，否则用等差数列求和公式更新答案并将 $cnt$ 重置为 2，最后再处理一次剩余的等差数列。

- **作者：woden (赞：3)，4星**
    - **关键亮点**：采用双指针法找出极长的等差数列子串，通过计算子串个数并处理重复部分得到最终答案，思路清晰，对细节的处理较为完善。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
#define fst ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define endl '\n'
using namespace std;
const int N=2E5+99;
int n,a[N];
int sum=0;
signed main() {
    fst;
    cin>>n;
    if(n==1){
        cout<<1;//特判一下。 
        return 0;
    }
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int l=1,r=2,d=a[2]-a[1];//设置左端点和右端点，记录公差。 
    while(r<=n){
        if(a[r]-a[r-1]==d){
            r++;//如果是等差数列，右端点继续右移。 
        }else{//否则： 
            int len=r-l; //注意，这里的右端点不是序列的右端点，要比序列的右端点多1，所以要减去这个1。 
            sum+=(len+1)*len/2;//统计子串个数的公式：(序列长度+1)*(序列长度)/2。 
            l=r-1;//左端点移到当前序列的末尾。 
            d=a[r]-a[l];//更新公差。 
            sum--;
        }
    }
    //最后进行一次计算。 
    int len=r-l;
    sum+=(len+1)*len/2;
    //这里不会再重复了，所以不用减1。 
    cout<<sum;
    return 0;
}
```
    - **核心实现思想**：用双指针 $l$ 和 $r$ 维护等差数列子串，$d$ 记录公差，当不满足等差数列条件时，计算当前子串的子串个数并处理重复部分，更新左端点和公差，最后再处理一次剩余的子串。

### 最优关键思路或技巧
- **利用等差数列性质**：一个等差数列的所有子串都是等差数列，因此可以通过找出极长的等差数列子串，再根据子串长度计算其包含的所有子串数量。
- **避免重复计算**：在计算过程中，要注意处理重复的部分，如相邻等差数列子串的重叠部分，可通过减去重复的数量来避免重复计算。
- **状态记录**：通过记录以每个点结尾的等差数列的相关信息（如最大长度、个数等），可以利用动态规划的思想高效地计算答案。

### 可拓展之处
同类型题目可能会对数列的条件进行变化，如要求等比数列、斐波那契数列等子串的数量，或者对数列进行修改、查询等操作。类似的算法套路可以是使用双指针、动态规划、分治等方法来找出符合条件的子串并统计数量。

### 推荐洛谷题目
- [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

### 个人心得摘录与总结
- **作者：Redamancy_Lydic**：认为题目很水，但硬控了半个小时，说明即使题目看似简单，也可能存在一些细节需要注意，在做题时要仔细思考。
- **作者：Genius_Star**：赛时看错题，以为区间可以重排，卡了 8 分钟，提醒我们在做题前一定要认真读题，理解题意，避免因看错题目而浪费时间。

---
处理用时：51.21秒
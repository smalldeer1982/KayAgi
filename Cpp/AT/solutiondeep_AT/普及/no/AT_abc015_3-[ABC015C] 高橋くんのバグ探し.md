# 题目信息

# [ABC015C] 高橋くんのバグ探し

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc015/tasks/abc015_3

高橋くんは上司からあるアンケートアプリにバグがあるかどうか調べて欲しいと頼まれました。

このアプリは、ユーザに選択肢が $ K $ 個ある質問を $ N $ 回答えさせることにより、ユーザの性格を判定します。 質問や選択肢はユーザの回答によって変わらず一定であり、ユーザは全ての質問にちょうど $ 1 $ つの選択肢を選ぶことで、結果を閲覧できます。

全ての選択肢はある整数値を持ちます。このアプリは、ユーザによって選ばれた、全ての回答がそれぞれ保持する整数値の排他的論理和（XOR）を使って結果を算出します。計算の最後でこの値が $ 0 $ になってしまうと、結果が表示されずバグが発生してしまいます。

あなたには全ての選択肢が持つ整数値が与えられるので、高橋くんの代わりに、ユーザの選択によってはバグが発生する可能性があるかどうかを判定してください。

## 说明/提示

### Sample Explanation 1

$ 1 $ つ目の質問で $ 1 $ つ目の選択肢を、$ 2 $ つ目の質問で $ 3 $ つ目の選択肢を、 $ 3 $ つ目の質問で、$ 2 $ つ目の選択肢を選んだとします。 すると、対応する数字はそれぞれ、 $ 1,2,3 $ となり、これらのXORを取ると、$ 0 $ となります。 よって、バグが発生してしまうため、`Found`と出力します。

### Sample Explanation 2

バグの発生する回答の組み合わせはありません。

## 样例 #1

### 输入

```
3 4

1 3 5 17

2 4 2 3

1 3 2 9```

### 输出

```
Found```

## 样例 #2

### 输入

```
5 3

89 62 15

44 36 17

4 24 24

25 98 99

66 33 57```

### 输出

```
Nothing```

# AI分析结果



[题目内容中文翻译]
# [ABC015C] 高桥君的BUG排查

## 题目描述

高桥君被上司委托调查某个问卷应用是否存在BUG。

该应用通过让用户回答包含K个选项的N个问题来判断用户性格。所有问题和选项固定不变，用户必须为每个问题恰好选择一个选项才能查看结果。

每个选项都带有整数值。应用通过用户所选答案对应数值的异或值（XOR）计算结果。若最终计算结果为0，则无法显示结果（发生BUG）。

现给定所有选项的数值，请判断是否存在用户选择方案会导致BUG发生。

## 输入格式

第一行两个整数N, K  
接下来N行每行K个整数，表示各问题的选项数值  

## 输出格式

存在BUG方案输出Found，否则输出Nothing

（其余样例说明与提示保持原样）

---

**算法分类**：深度优先搜索 DFS

---

### 题解综合分析

题目要求判断是否存在从N组中各选1个数，使异或和为0。所有题解均采用DFS遍历所有可能路径，核心差异在于状态维护方式与剪枝策略。

#### 最优题解推荐
1. **作者：_ouhsnaijgnat_（★★★★★）**
   - 亮点：代码简洁，参数设计高效（仅需当前组号与累积异或值），及时剪枝（找到解立即返回）
   - 核心实现：递归函数`dfs(cur, step)`中，`cur`表示当前处理到第几组，`step`保存当前异或值。当处理完所有组时检查是否为0
   - 代码片段：
     ```cpp
     int dfs(int cur, int step) {
         if (cur > n) return step == 0;
         for (int i = 1; i <= m; i++) {
             if (dfs(cur + 1, step ^ a[cur][i])) 
                 return 1;
         }
         return 0;
     }
     ```

2. **作者：Elairin176（★★★★）**
   - 亮点：索引处理简洁（从0开始），参数语义清晰（step表示处理深度）
   - 注意点：数组索引需要与深度严格对应，初始调用`dfs(0,0)`匹配从0开始的组号
   - 代码片段：
     ```cpp
     bool dfs(int step, int ans) {
         if (step == n) return ans == 0;
         for (int i = 0; i < m; i++) {
             if (dfs(step + 1, ans ^ a[step][i])) 
                 return true;
         }
         return false;
     }
     ```

---

### 关键思路总结
1. **状态压缩传递**：通过异或运算的累积特性，仅需传递当前异或值，无需记录具体选择路径
2. **剪枝优化**：在递归中一旦发现可行解立即返回，终止后续无效搜索
3. **组间独立性**：每组必须且只能选一个数，递归时只需遍历当前组所有选项

---

### 同类题目推荐
1. P1036 [NOIP2002 普及组] 选数（DFS+质数判断）
2. P1443 马的遍历（BFS路径搜索）
3. P2392 kkksc03考前临时抱佛脚（多维DFS决策）

---

### 题解心得摘录
1. "_ouhsnaijgnat_：DFS参数只需组号和当前异或值，利用异或性质避免冗余状态存储"
2. "Elairin176：注意初始调用时step=0要与数组索引对齐，避免越界错误"  
（调试经验：确保递归参数与数组索引的一致性）

---
处理用时：41.56秒
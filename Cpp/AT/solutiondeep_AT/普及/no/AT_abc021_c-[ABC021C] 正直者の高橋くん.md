# 题目信息

# [ABC021C] 正直者の高橋くん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc021/tasks/abc021_c

あなたと高橋君は、AtCoder 王国に住んでいます。AtCoder 王国には、$ N $ 個の町と、町どうしを結ぶ $ M $ 本の道路が存在し、それらは双方向に移動可能です。 $ N $ 個の町はそれぞれ 町 $ 1 $,町 $ 2 $,…,町 $ N $ と呼ばれています。 また、$ M $ 個の道路はそれぞれ 道路 $ 1 $,道路 $ 2 $,…,道路 $ M $ と呼ばれています。

高橋君はあなたの家に遊びに行くことにしました。そして、高橋君は町 $ a $ から出発して、AtCoder 王国のいくつかの町（$ 0 $ 個でも良い）を経由して町 $ b $ にあるあなたの家に到着しました。

高橋君は最短経路を辿ってきたと主張しています。 高橋君は正直なので、絶対に嘘をつきません。

そこで、あなたは町 $ a $ から町 $ b $ への最短経路が何通りあるかを数えることにしました。答えは非常に大きくなる可能性があるので、実際の答えを $ 1,000,000,007(=10^9+7) $ で割った余りを出力してください。

町 $ a $ から町 $ b $ への最短経路とは、町 $ a $ から町 $ b $ への移動経路において道路を通る回数が最小となるような経路のことを言います。

## 说明/提示

### Sample Explanation 1

この入力例に対する図は以下の通りで、最短経路として次の $ 4 $ 通りが考えられます。 - $ 1→2→4→5→7 $ - $ 1→3→4→5→7 $ - $ 1→2→4→6→7 $ - $ 1→3→4→6→7 $ !\[\](http://abc021.contest.atcoder.jp/img/abc/021/enJQfEfKt-baQEUDjCrVFLSw/C\_sample1.png)

### Sample Explanation 2

この入力例に対する図は以下の通りです。 !\[\](http://abc021.contest.atcoder.jp/img/abc/021/enJQfEfKt-baQEUDjCrVFLSw/C\_sample2.png)

## 样例 #1

### 输入

```
7

1 7

8

1 2

1 3

4 2

4 3

4 5

4 6

7 5

7 6```

### 输出

```
4```

## 样例 #2

### 输入

```
7

1 7

9

1 2

1 3

4 2

4 3

4 5

4 6

7 5

7 6

4 7```

### 输出

```
2```

# AI分析结果



【题目翻译】
# [ABC021C] 正直者的高桥君

## 题目描述

你和高桥君住在AtCoder王国。该国有N个城镇和M条双向道路。城镇编号为1到N。高桥君从城镇a出发，经过若干城镇后到达你的家所在的城镇b。他声称自己走了最短路径。请计算a到b的最短路径数量，结果对1e9+7取模。

最短路径定义为经过道路数最少的路径。

## 样例 #1

### 输入
```
7
1 7
8
1 2
1 3
4 2
4 3
4 5
4 6
7 5
7 6
```

### 输出
```
4
```

## 样例 #2

### 输入
```
7
1 7
9
1 2
1 3
4 2
4 3
4 5
4 6
7 5
7 6
4 7
```

### 输出
```
2
```

【算法分类】
广度优先搜索 BFS

【题解分析与结论】
本题要求计算最短路径数量，核心在于通过BFS分层处理，同时维护各节点的路径计数。解题关键点在于：
1. 使用广度优先搜索确保按层序处理节点
2. 维护两个数组：距离数组a[]和路径计数数组c[]
3. 允许同一层级的多个前驱节点贡献路径数

【高分题解】
⭐️⭐️⭐️⭐️⭐️ FFTotoro 的解法
关键亮点：
1. 采用分层BFS保证最短路径性质
2. 路径计数时实时取模防止溢出
3. 使用队列实现高效层级遍历
4. 正确处理同一层级多前驱的路径叠加

个人心得：
- 作者特别标注使用#define int long long处理大数问题，避免整数溢出
- 代码中采用动态更新路径数的逻辑：if(a[h]==a[x]+1)c[h]=(c[h]+c[x])%MOD

【核心代码实现】
```cpp
vector<int> g[1000001];
int a[1000001], c[1000001];
bool v[1000001];

queue<int> q;
q.push(s);
v[s] = c[s] = 1;

while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int h : g[x]) {
        if (!v[h]) { // 首次访问
            v[h] = true;
            a[h] = a[x] + 1;
            q.push(h);
        }
        if (a[h] == a[x] + 1) { // 最短路径更新
            c[h] = (c[h] + c[x]) % 1000000007;
        }
    }
}
cout << c[b];
```

【拓展思考】
类似问题可变形为：
1. 边权非1时的最短路径计数（需Dijkstra+DP）
2. 允许重复节点的路径计数（需拓扑排序处理）
3. 多终点/多起点的扩展情况

【推荐练习】
1. P1144 最短路计数 - 完全相同的模板题
2. P1606 [USACO07JAN]白银莲花池 - BFS计数变形
3. P2296 寻找道路 - BFS预处理+路径验证

---
处理用时：49.60秒
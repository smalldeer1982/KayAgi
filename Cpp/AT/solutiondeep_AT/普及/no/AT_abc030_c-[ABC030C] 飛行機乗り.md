# 题目信息

# [ABC030C] 飛行機乗り

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc030/tasks/abc030_c

ウナギの高橋くんは飛行機に乗ることが趣味です。今回は空港Aと空港Bを往復することにしました。

空港Aから空港Bの飛行機には $ X $ 時間かかり、空港Bから空港Aへの飛行機には $ Y $ 時間かかります。 空港Aから空港Bへの飛行機は $ N $ 本あり、$ i $ 番目の便は $ a_i $ 時に出発します。 空港Bから空港Aへの飛行機は $ M $ 本あり、$ j $ 番目の便は $ b_j $ 時に出発します。

ある飛行機には、出発する空港に出発する時刻以前にいれば乗ることができます。出発する時刻ちょうどに到着した場合も、すぐに飛行機に乗って出発できます。 高橋くんははじめ空港Aに $ 0 $ 時にいます。 空港Aと空港Bの間を最大何往復できるか調べてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 30 $ 点分のテストケースにおいて、$ 1\ ≦\ a_i\ ≦\ 10^5,\ 1\ ≦\ b_j\ ≦\ 10^5\ (\ 1\ ≦\ i\ ≦\ N,\ 1\ ≦\ j\ ≦\ M) $ を満たす。

### Sample Explanation 1

$ 1 $ 時の空港Aを出発する飛行機に乗り、$ 3 $ 時に到着しますが、すぐに $ 3 $ 時の空港Bを出発する飛行機に乗り、$ 6 $ 時に空港Aに到着します。 次に、$ 7 $ 時の空港Aを出発する飛行機に乗り、$ 9 $ 時に到着、$ 12 $ 時の空港Bを出発する飛行機に乗ると、合計 $ 2 $ 往復できます。$ 3 $ 往復する手段はありません。

### Sample Explanation 2

空港Bに行くと空港Aに帰れないので、$ 1 $ 度も往復できません。

## 样例 #1

### 输入

```
3 4

2 3

1 5 7

3 8 12 13```

### 输出

```
2```

## 样例 #2

### 输入

```
1 1

1 1

1

1```

### 输出

```
0```

## 样例 #3

### 输入

```
6 7

5 3

1 7 12 19 20 26

4 9 15 23 24 31 33```

### 输出

```
3```

# AI分析结果



## 中文题目重写

### [ABC030C] 飛行機乗り

#### 题目描述

高桥君喜欢乘飞机，这次他计划在机场A和机场B之间往返。从A到B的航班需要X小时，返程需要Y小时。机场A有N个出发航班，第i个航班在a_i时起飞；机场B有M个出发航班，第j个航班在b_j时起飞。高桥君在0时位于机场A，只能在航班起飞时刻或之前到达机场才能搭乘。求他最多能完成多少次往返。

#### 输入格式

输入包含多组数据：
- 第一行两个整数N和M
- 第二行两个整数X和Y
- 第三行N个整数表示a数组
- 第四行M个整数表示b数组

#### 输出格式

输出最大往返次数

#### 样例

##### 样例1
输入：
```
3 4
2 3
1 5 7
3 8 12 13
```
输出：
```
2
```

##### 样例2
输入：
```
1 1
1 1
1
1
```
输出：
```
0
```

#### 说明/提示
- 所有航班时间已按升序排列
- 部分分测试用例满足：1 ≤ a_i, b_j ≤ 1e5

---

## 算法分类
模拟

---

## 题解对比与结论

### 题解分析
核心思路是模拟高桥君的行程，每次选择当前机场的最早可用航班，使用双指针追踪可用航班位置。关键点在于：
1. **双指针贪心**：维护两个指针分别指向当前可用航班，确保每次选择最早的可行航班
2. **时间更新逻辑**：到达时间严格由航班起飞时间+飞行时间确定
3. **往返计数**：仅在完成B→A的行程时增加计数

### 评分题解（4星）

#### 作者：Keids（4星）
**关键亮点**：
- 使用双指针高效追踪航班位置，时间复杂度O(N+M)
- 处理边界条件清晰（如指针越界立即终止）
- 代码简洁，逻辑紧凑

**实现核心**：
```cpp
int side=1,t=a[1],l=1,r=1; // 初始状态
while(true) {
    if (side==1) {
        while (t+X > b[r]) { // 寻找B机场可用航班
            if (++r > M) goto finish;
        }
        t = b[r]; // 更新时间为航班起飞时间
        side = 2;
    } else {
        while (t+Y > a[l]) { // 寻找A机场可用航班
            if (++l > N) goto finish;
        }
        t = a[l];
        side = 1;
        ans++; // 完成一次往返
    }
}
finish: 
cout << ans;
```

**个人心得**：
- 作者提到输出时需注意换行符，否则会WA
- 初始指针设置需严格对齐数组起始位置（从1开始索引）

---

## 最优思路总结
**双指针贪心模拟**是本题最优解法：
1. **贪心选择**：每次选最早可用航班，最大化后续机会
2. **时间复杂度**：线性扫描航班序列，效率极高
3. **实现技巧**：
   - 用`side`变量标记当前所在机场
   - 通过指针跳跃直接跳过不可用航班
   - 严格的时间计算确保符合航班条件

---

## 拓展练习
1. [P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031) - 贪心模拟
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心+优先队列
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019) - 差分+贪心模拟

---
处理用时：158.72秒
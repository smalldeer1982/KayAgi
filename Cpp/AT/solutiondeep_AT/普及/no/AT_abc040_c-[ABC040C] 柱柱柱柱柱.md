# 题目信息

# [ABC040C] 柱柱柱柱柱

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc040/tasks/abc040_c

$ N $ 本の木の柱が左から右へ一列に並んだアスレチックがあります。左から $ i $ 本目の柱の高さは $ a_i $ センチメートルです。

高橋君は左から $ 1 $ 本目の柱からスタートし、右へ柱を渡っていき $ N $ 本目の柱まで行こうとしています。

高橋君がある柱にいるとき、次には現在の柱から $ 1 $ 個もしくは $ 2 $ 個右にある柱のどちらかへ移動することができます。

移動するときには、現在いる柱の高さと、移動後の柱の高さの差の絶対値のぶんだけコストがかかります。

$ N $ 本目の柱まで行くとき、コストの合計の最小値はいくらになるでしょうか。

## 说明/提示

### 制約

- $ 2\ ≦\ N\ ≦\ 100,000 $
- $ 0\ ≦\ a_i\ ≦\ 10,000 $
- $ a_i $ はすべて整数である。

### Sample Explanation 1

このケースでは以下のような移動によって最小コストを達成できる。 - $ 1 $ 本目の柱から $ 3 $ 本目の柱へ移動する。(コスト $ 30 $) - $ 3 $ 本目の柱から $ 4 $ 本目の柱へ移動する。(コスト $ 10 $) 合計コストは $ 40 $ となる。

### Sample Explanation 2

このケースでは以下のような移動によって最小コストを達成できる。 - $ 1 $ 本目の柱から $ 2 $ 本目の柱へ移動する。(コスト $ 25 $) - $ 2 $ 本目の柱から $ 4 $ 本目の柱へ移動する。(コスト $ 15 $) 合計コストは $ 40 $ となる。

## 样例 #1

### 输入

```
4

100 150 130 120```

### 输出

```
40```

## 样例 #2

### 输入

```
4

100 125 80 110```

### 输出

```
40```

## 样例 #3

### 输入

```
9

314 159 265 358 979 323 846 264 338```

### 输出

```
310```

# AI分析结果



# [ABC040C] 柱柱柱柱柱

## 题目描述

$ N $ 根木柱从左到右排成一列的游乐设施。左起第 $ i $ 根柱子的高度为 $ a_i $ 厘米。

高桥君从第1根柱子出发，要移动到第N根柱子。每次可以从当前柱子向右移动1或2根柱子，移动代价为两柱子高度差的绝对值。求到达第N根柱子的最小总代价。

### 输入格式
输入包含：
- 第一行为整数 $ N $
- 第二行包含 $ N $ 个整数表示各柱高度

### 输出格式
输出最小总代价。

### 数据范围
- $ 2 \leq N \leq 100,000 $
- $ 0 \leq a_i \leq 10,000 $

---

## 算法分类
动态规划

---

## 题解分析与结论

所有题解均采用动态规划解法，核心思路相同，差异在于代码实现细节。关键点包括：
1. **状态定义**：`dp[i]` 表示到达第i根柱子的最小代价
2. **转移方程**：`dp[i] = min(dp[i-1] + |a[i]-a[i-1]|, dp[i-2] + |a[i]-a[i-2]|)`
3. **边界处理**：
   - `dp[1] = 0`（起点无代价）
   - `dp[2] = |a[2]-a[1]|`（只能从第1根直接跳转）

---

## 高星题解推荐

### 题解1：user470883（4⭐）
**亮点**：
- 完整包含输入处理与初始化逻辑
- 使用`ios::sync_with_stdio(false)`优化IO速度
- 数组命名规范（`dp[]`）

**代码核心**：
```cpp
dp[1] = 0;
dp[2] = abs(a[1] - a[2]);
for(int i = 3; i <= n; i++) {
    dp[i] = min(dp[i-1] + abs(a[i]-a[i-1]), 
                dp[i-2] + abs(a[i]-a[i-2]));
}
```

### 题解2：MithrilSword_XIV（4⭐）
**亮点**：
- 最简洁的实现（仅需19行代码）
- 包含完整的IO优化配置
- 变量命名清晰易懂

**代码核心**：
```cpp
f[2] = abs(a[1] - a[2]);
for(int i = 3; i <= n; i++){
    f[i] = min(f[i-1] + abs(a[i]-a[i-1]),
               f[i-2] + abs(a[i]-a[i-2]));
}
```

### 题解3：sandwich（3⭐）
**个人心得**：
> "一开始以为要记忆化搜索，后来发现是简单DP。注意当i=3时需要考虑i-2=1的情况"

**代码特点**：
- 使用`long long`类型（虽然题目数据范围无需）
- 独立计算`ans1`和`ans2`增强可读性

---

## 关键优化技巧
1. **滚动数组优化**：由于只需前两个状态，可用变量代替数组节省空间
2. **提前计算绝对值**：在输入阶段预存高度差绝对值可加速计算
3. **IO加速**：通过关闭同步提升大规模数据输入效率

---

## 同类拓展题目
1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216) - 经典二维DP
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002) - 棋盘路径DP
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 双向LIS应用

---

## 总结心得
本题展现了动态规划的经典应用场景——多阶段决策最优解问题。调试时需特别注意：
- **边界条件验证**：确保`dp[2]`的正确初始化
- **索引偏移处理**：数组下标从1开始更符合题意理解
- **空间复杂度控制**：当N较大时，滚动数组优化能有效降低内存占用

---
处理用时：44.26秒
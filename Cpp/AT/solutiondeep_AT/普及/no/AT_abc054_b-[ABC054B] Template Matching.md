# 题目信息

# [ABC054B] Template Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc054/tasks/abc054_b

縦 $ N $ 行、横 $ N $ 列に画素が並んだ画像Aと、縦 $ M $ 行、横 $ M $ 列に画素が並んだテンプレート画像Bが与えられます。   
 画素は画像を構成する最小単位であり、ここでは $ 1×1 $ の正方形とします。   
 また、与えられる画像は全て2値画像であり、各画素の色は白と黒の2種類で表されます。

入力において、全ての画素は文字で表されており、`.`は白色の画素、 `#` は黒色の画素に対応します。   
 画像Aは $ N $ 個の文字列 $ A_1,...,A_N $ で表されます。   
 文字列 $ A_i $ の $ j $ 文字目は、画像Aの上から $ i $ 番目、左から $ j $ 番目の画素に対応します。$ (1≦i,j≦N) $   
 同様に、テンプレート画像Bは $ M $ 個の文字列 $ B_1,...,B_M $ で表されます。   
 文字列 $ B_i $ の $ j $ 文字目は、テンプレート画像Bの上から $ i $ 番目、左から $ j $ 番目の画素に対応します。$ (1≦i,j≦M) $

画像の平行移動のみ許されるとき、テンプレート画像Bが画像Aの中に含まれているかを判定してください。

## 说明/提示

### 制約

- $ 1≦M≦N≦50 $
- $ A_i $ は `#` と `.` からなる長さ $ N $ の文字列
- $ B_i $ は `#` と `.` からなる長さ $ M $ の文字列

### Sample Explanation 1

テンプレート画像Bが、画像A中の左上の $ 2\ ×\ 2 $ の部分画像と右下の $ 2\ ×\ 2 $ の部分画像に一致するため、`Yes` と出力します。

### Sample Explanation 2

画像Aは白色の画素、テンプレート画像Bは黒色の画素で構成されるため、含まれることはありません。

## 样例 #1

### 输入

```
3 2

#.#

.#.

#.#

#.

.#```

### 输出

```
Yes```

## 样例 #2

### 输入

```
4 1

....

....

....

....

#```

### 输出

```
No```

# AI分析结果



# [ABC054B] Template Matching

## 题目描述

给定两个正方形图像A（边长为N）和模板图像B（边长为M），判断B是否存在于A中。图像由`.`（白）和`#`（黑）构成。B只能通过平移与A的子矩阵匹配。

## 算法分类
**枚举**

---

## 题解综合分析

所有题解均采用暴力枚举法。核心思路为：遍历A中所有可能的子矩阵左上角坐标，检查对应区域是否与B完全一致。由于数据范围较小（n≤50），O(n²m²) 的复杂度可接受。

---

## 精选题解（评分≥4⭐）

### 题解1（作者：achjuncool） ⭐⭐⭐⭐
**关键亮点**  
- 使用标准的左上角枚举思路，代码简洁清晰。
- 循环变量处理直观，采用相对坐标偏移法。
- 及时剪枝，发现不匹配立即跳出循环。

**核心代码**  
```cpp
for(int x = 1; x <= n - m + 1; x++) {
    for(int y = 1; y <= n - m + 1; y++) {
        bool flag = true;
        for(int _x = 0; _x < m; _x++) {
            for(int _y = 0; _y < m; _y++) {
                if(a[x + _x][y + _y] != b[_x + 1][_y + 1]) {
                    flag = false;
                    break;
                }
            }
            if(!flag) break;
        }
        if(flag) return cout << "Yes", 0;
    }
}
```

---

### 题解2（作者：龙潜月十五） ⭐⭐⭐⭐
**关键亮点**  
- 明确将左上角枚举范围限制为`n-m+1`，避免无效遍历。
- 采用双循环结构分离坐标生成与匹配检查，逻辑分明。

**核心代码**  
```cpp
for(int i = 1; i <= n - m + 1; i++)
    for(int j = 1; j <= n - m + 1; j++) {
        bool flag = true;
        for(int k = i; k <= i + m - 1; k++)
            for(int l = j; l <= j + m - 1; l++)
                if(a[k][l] != b[k - i + 1][l - j + 1])
                    flag = false;
        if(flag) return printf("Yes"), 0;
    }
```

---

### 题解3（作者：zhmzhuhanming） ⭐⭐⭐⭐
**关键亮点**  
- 优化思路：先检查B的右下角字符，再整体匹配，减少不必要的全矩阵比较。
- 索引计算巧妙，从A的右下角反向推导子矩阵位置。

**个人心得**  
> "char!char!!!不要又int来了"  
> 提醒注意数据类型，避免低级错误。

**核心代码**  
```cpp
for(int i = m; i <= n; i++) {
    for(int j = m; j <= n; j++) {
        if(a[i][j] == b[m][m]) {
            bool o = 1;
            for(int ii = 1; ii <= m; ii++)
                for(int jj = 1; jj <= m; jj++)
                    if(b[ii][jj] != a[i - m + ii][j - m + jj]) 
                        o = 0;
            if(o) return cout << "Yes", 0;
        }
    }
}
```

---

## 最优关键思路
**左上角枚举法**：  
1. 遍历A中所有可能的子矩阵左上角坐标`(x,y)`。
2. 对每个坐标，检查以该点为左上角的M×M区域是否与B完全一致。
3. 使用四层嵌套循环，外层确定位置，内层进行比较。

---

## 拓展建议
- **类似题目**：可尝试滑动窗口优化或哈希预处理（如二维哈希）处理更大数据。
- **变式场景**：若允许旋转匹配，需结合矩阵旋转枚举。

---

## 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102) - 枚举与哈希结合
2. [P3397 地毯](https://www.luogu.com.cn/problem/P3397) - 二维差分数组应用
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 二维空间枚举与剪枝

---
处理用时：51.25秒
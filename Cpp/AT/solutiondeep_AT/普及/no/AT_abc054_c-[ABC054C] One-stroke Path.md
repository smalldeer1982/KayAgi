# 题目信息

# [ABC054C] One-stroke Path

## 题目描述

给定一个没有重边和自环的 $N$ 个点 $M$ 条边的无权无向图，第 $i$ 条边连接顶点 $a _ i$ 和 $b _ i$。

求以顶点 $1$ 为起点，只访问 $1$ 次所有顶点的路径有多少条？特别地，起点和终点也视为被访问。

## 说明/提示

$
2 \le N \le 8 \\
0 \le M \le N(N - 1) \\
1 \le a _ i < b _ i \le N
$

给定的无向图中不包含重边和自环。

## 样例 #1

### 输入

```
3 3

1 2

1 3

2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
7 7

1 3

2 7

3 4

4 5

4 6

5 6

6 7```

### 输出

```
1```

# AI分析结果



# [ABC054C] One-stroke Path

## 题目描述

给定一个没有重边和自环的 $N$ 个点 $M$ 条边的无权无向图，第 $i$ 条边连接顶点 $a _ i$ 和 $b _ i$。

求以顶点 $1$ 为起点，只访问 $1$ 次所有顶点的路径有多少条？特别地，起点和终点也视为被访问。

## 说明/提示

$
2 \le N \le 8 \\
0 \le M \le N(N - 1) \\
1 \le a _ i < b _ i \le N
$

给定的无向图中不包含重边和自环。

---

**算法分类**：深度优先搜索 DFS

---

### 题解分析与结论

两题解均采用DFS实现全路径枚举，核心差异在于状态表示方式：
1. **方123456题解**（4星）：采用位掩码优化空间，使用邻接矩阵实现快速边查询，代码简洁高效。利用整数二进制位表示访问状态（如`1<<(i-1)`），将时间复杂度控制在O(N!)的可行范围（N≤8时最大40320次递归）。
2. **龙潜月十五题解**（3星）：传统DFS回溯法，使用邻接表存图，需维护显式vis数组，状态恢复逻辑清晰但空间略冗余。

---

### 最优题解（方123456）

**亮点**：  
1. **位运算优化**：用整型变量代替布尔数组，将访问状态判断复杂度降至O(1)
2. **邻接矩阵**：在小规模数据下实现O(1)的边查询
3. **初始状态处理**：直接传入`(1<<0)`表示起点已访问

**核心代码**：
```cpp
int DFS(int x, int y) {
    if (y == (1<<n)-1) return 1; // 全访问完成
    int sum = 0;
    for (int i=1; i<=n; i++) {
        if (!Map[x][i] || (y>>(i-1))&1) continue; // 邻接矩阵查边+位状态判断
        sum += DFS(i, y|(1<<(i-1)));
    }
    return sum;
}
```

---

### 关键技巧与拓展

**关键思路**：  
1. **状态压缩**：利用位运算将N维访问状态压缩为单整数
2. **邻接矩阵适用性**：当N≤10时，邻接矩阵的O(1)查边效率优于邻接表

**同类题目**：  
1. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)（记忆化DFS）
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)（回溯法）
3. [P1606 Lilypad Pond](https://www.luogu.com.cn/problem/P1606)（BFS状态压缩）

---

### 个人心得摘录

方123456在注释中强调："注意一开始 1 已经遍历过了"，提醒初始状态`y=1`的正确设置。该细节若处理不当会导致多计算起点重复访问的非法路径。

---
处理用时：46.90秒
# 题目信息

# [ABC076C] Dubious Document 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc076/tasks/abc076_c

E869120 は、宝物が入ってそうな箱を見つけました。  
 しかし、これには鍵がかかっており、鍵を開けるためには英小文字からなる文字列 $ S $ が必要です。  
 彼は文字列 $ S' $ を見つけ、これは文字列 $ S $ の $ 0 $ 個以上 $ |S| $ 個以内の文字が `?` に置き換わった文字列であることも分かりました。  
 ただし、文字列 $ A $ に対して、$ |A| $ を「文字列 $ A $ の長さ」とします。

そこで、E869120 はヒントとなる紙を見つけました。

- 条件1：文字列 $ S $ の中に連続する部分文字列として英小文字から成る文字列 $ T $ が含まれている。
- 条件2：$ S $ は、条件1を満たす文字列の中で辞書順最小の文字列である。

そのとき、鍵となる文字列 $ S $ を出力しなさい。  
 ただし、そのような文字列 $ S $ が存在しない場合は代わりに `UNRESTORABLE` と出力しなさい。

## 说明/提示

### 制約

- $ 1\ \leq\ |S'|,\ |T|\ \leq\ 50 $
- $ S' $ は英小文字と `?` から成る
- $ T $ は英小文字から成る

### Sample Explanation 1

条件1 を満たす文字列は `atcoder`, `btcoder`, `ctcoder`,..., `ztcoder` の $ 26 $ 個がありますが、その中で最も辞書順で小さいものは `atcoder` なので、$ S\ = $`atcoder` と特定できます。

### Sample Explanation 2

条件1を満たすような文字列 $ S $ が存在しないので、鍵となる文字列 $ S $ は存在しません。

## 样例 #1

### 输入

```
?tc????

coder```

### 输出

```
atcoder```

## 样例 #2

### 输入

```
??p??d??

abc```

### 输出

```
UNRESTORABLE```

# AI分析结果



# 中文题目翻译

## 题目描述

E869120 发现了一个可能藏有宝物的箱子，但需要英小文字组成的字符串 $S$ 作为钥匙。他找到了一个字符串 $S'$，该字符串可能是 $S$ 中 0 个到 $|S|$ 个字符被替换为 `?` 后的版本。已知：

- **条件1**：字符串 $S$ 包含连续子字符串 $T$
- **条件2**：$S$ 是满足条件1的字典序最小的字符串

请输出满足条件的 $S$，若不存在则输出 `UNRESTORABLE`。

## 输入输出样例

### 样例 #1
**输入：**
```
?tc????
coder
```
**输出：**
```
atcoder
```

### 样例 #2
**输入：**
```
??p??d??
abc
```
**输出：**
```
UNRESTORABLE
```

### 样例解释
样例1中，满足条件的可能解有26种（如`atcoder`,`btcoder`等），其中字典序最小的为`atcoder`。样例2无解。

---

# 算法分类
**字符串**

---

# 题解分析与结论

## 核心思路总结
1. **暴力枚举**：在 $S'$ 中枚举所有可能的 $T$ 的匹配位置
2. **问号处理**：匹配位置外的 `?` 替换为 `a`（字典序最小）
3. **字典序比较**：维护最小字典序结果

## 最优思路提炼
- **逆向枚举**：从后向前寻找第一个有效匹配位置可直接得到最小字典序（无需比较全部情况）
- **统一替换**：非匹配区的 `?` 统一替换为 `a`
- **剪枝优化**：预处理排除 $|S'| < |T|$ 的无效情况

---

# 精选题解

## 题解作者：TRZ_2007（★★★★☆）
**关键亮点**  
- 代码结构清晰，逻辑完整
- 正确处理长度不足的边界条件
- 利用 `min` 函数维护字典序最小值

**核心代码**  
```cpp
for(int i = 0;i < ls - lt + 1;i++) {
    tmp = s; flag = 0;
    // 尝试将 T 匹配到位置 i
    for(int j = i; j < i + lt; j++) {
        if(tmp[j] == '?') tmp[j] = t[j - i]; 
        else if(tmp[j] != t[j - i]) { flag=1; break; }
    }
    if(!flag) {
        // 替换所有剩余?为a
        for(int j=0; j<ls; j++) 
            if(tmp[j] == '?') tmp[j] = 'a';
        // 维护最小字典序
        ans = (ans.empty()) ? tmp : min(ans, tmp);
    }
}
```

---

## 题解作者：Night_sea_64（★★★★☆）
**关键亮点**  
- 初始化解为极大值简化比较逻辑
- 利用 `substr` 快速截取子串验证匹配
- 直接调用 `min` 函数进行字典序比较

**核心代码**  
```cpp
string ans = "zzzz...zzzz"; // 初始化极大值
for(int i=0; i<=s.size()-t.size(); i++) {
    string temp = s.substr(i, t.size());
    if(chk(temp, t)) { // 自定义匹配检查函数
        string now = s;
        // 替换匹配区
        for(int j=0; j<t.size(); j++) now[i+j] = t[j]; 
        // 替换非匹配区?
        for(char &c : now) if(c == '?') c = 'a';
        ans = min(ans, now);
    }
}
```

---

## 题解作者：cjZYZtcl（★★★☆☆）
**逆向枚举技巧**  
- 从后往前遍历，找到第一个有效匹配即为最小字典序解
- 减少不必要的比较次数

**代码亮点**  
```pascal
for i := length(s)-length(x)+1 downto 1 do // 逆向枚举
    if 匹配成功 then begin
        替换问号为a;
        输出并终止程序; // 首个找到的即为最小解
    end;
```

---

# 拓展与练习

## 类似题目推荐
1. **P1039 [NOIP2003 提高组] 字符串变换**  
   - 关键点：字符串替换与最短转换路径
2. **P1101 单词方阵**  
   - 关键点：二维字符串匹配与方向处理
3. **P3375 【模板】KMP字符串匹配**  
   - 关键点：高效字符串匹配算法

---

# 心得体会摘录
- **调试教训**（zfn07）：  
  > "必须判断s长度是否比t小，被坑了3次！"  
  **总结**：边界条件检查是代码鲁棒性的关键
- **优化顿悟**（cjZYZtcl）：  
  > "从后往前找第一个匹配位置即得最小解"  
  **总结**：逆向思维可简化比较逻辑

---
处理用时：54.51秒
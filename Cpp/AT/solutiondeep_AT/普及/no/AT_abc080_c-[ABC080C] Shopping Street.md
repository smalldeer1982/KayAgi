# 题目信息

# [ABC080C] Shopping Street

## 题目描述

Joisino计划要在商店街开一家店。

这家店在周一到周五的$5$ 个工作日都有营业，其中每个工作日又被划分成上午和下午$2$ 个时间段，也就是共有$10$ 个时间段。当然，至少要有$1$ 个时间段这家店营业。

商店街原来有$N$ 个店铺，从$1$ 到$N$ 编号。

这些店铺的营业时间将以$F_{i,j,k}=1$ 的形式给出。如果$F_{i,j,k}=1$ ，第$i$ 家店将在第$j$ 天的第$k$ 个时间段营业。在这里，我们这样定义：第$1$ 天是周一，第$2$ 天是周二，第$3$ 天是周三，第$4$ 天是周四，第$5$ 天是周五。同样的，第$1$ 个时间段是上午，第$2$ 个时间段是下午。

设$c_i$ 为第$i$ 家店和Joisino的店同时营业的时间段数，则Joisino商店的收益将会是$P_{1,c1}+P_{2,c2}+...+P_{N,cN}$ 。

请决定Joisino在这$10$ 个时间段分别是否营业，并求出Joisino商店可能的最大收益，且保证它至少要有$1$ 个时间段营业。

## 说明/提示

### 样例解释1
如果商店仅在第$1$ 家店营业时营业，收益将会是$8$ ，这是可能的最大收益。

### 样例解释2
由于必须至少有一个时间段商店营业，所以收益可能会是负数。

- $1 \leq N \leq 100$ 
- $0 \leq F_{i,j,k} \leq 1$ 
- 对所有满足 $1 \leq i \leq N$ 的 $i$ , 总有一对$(j, k)$ 满足$F_{i,j,k}=1$ 。
- $-10^7 \leq P_{i,j} \leq 10^7$ 
- 所有输入数据均为整数。

by @月见之兔

## 样例 #1

### 输入

```
1

1 1 0 1 0 0 0 1 0 1

3 4 5 6 7 8 9 -2 -3 4 -2```

### 输出

```
8```

## 样例 #2

### 输入

```
2

1 1 1 1 1 0 0 0 0 0

0 0 0 0 0 1 1 1 1 1

0 -2 -2 -2 -2 -2 -1 -1 -1 -1 -1

0 -2 -2 -2 -2 -2 -1 -1 -1 -1 -1```

### 输出

```
-2```

## 样例 #3

### 输入

```
3

1 1 1 1 1 1 0 0 1 1

0 1 0 1 1 1 1 0 1 0

1 0 1 1 0 1 0 1 0 1

-8 6 -2 -8 -8 4 8 7 -6 2 2

-9 2 0 1 7 -5 0 -2 -6 5 5

6 -6 7 -9 6 -5 8 0 -9 -7 -7```

### 输出

```
23```

# AI分析结果



# [ABC080C] Shopping Street

## 题目描述

Joisino计划在商店街开店。这家店在周一到周五的5个工作日分为上午和下午共10个时间段营业，至少需要1个时间段营业。

现有N家店铺的数据，每家店铺的营业时间用F[i][j][k]表示。当Joisino的店与第i家店在c_i个时间段同时营业时，总收益为ΣP[i][c_i]。要求确定Joisino的营业时间，使收益最大。

## 算法分类
枚举（位运算/DFS）

---

## 题解分析与结论

所有题解均采用**暴力枚举**思路，因总状态数为2^10=1024，完全可接受。核心思路为：

1. **枚举所有可能的营业状态**：通过二进制位运算或DFS生成所有可能的时间段组合
2. **计算重叠时间数**：对每个店铺，统计其与Joisino店同时营业的时间段数
3. **求最大收益**：根据重叠数累加对应P值，维护最大值

### 高星题解推荐

#### 1. SunSkydp（5星）
**亮点**：位运算高效枚举 + 清晰变量命名  
```cpp
for(int i = 1; i < 1024; i++) { // 枚举所有非零状态
    memset(tmp,0,sizeof(tmp));
    for(int j = 1; j <= n; j++) 
        for(int k = 1; k <= 10; k++)
            if(f[j][k] && ((1 << (k-1)) & i)) tmp[j]++;
    int now=0;
    for(int j = 1; j <= n; j++) now += p[j][tmp[j]];
    ans = max(ans, now);
}
```
**核心思想**：将时间段状态编码为整数i的二进制位，通过位运算快速判断各时间段是否营业

#### 2. 幸存者（5星）  
**亮点**：DFS递归生成状态 + 直观的条件判断  
```cpp
void dfs(int step) {
    if(step > 10) {
        bool flag = false; // 检查是否至少有一个时间段营业
        for(int i = 1; i <= 10; i++) if(a[i]) flag = true;
        if(!flag) return;
        // 计算收益并更新maxn...
    }
    a[step] = 0; dfs(step+1);
    a[step] = 1; dfs(step+1);
}
```
**调试心得**：初始maxn设为-1e9以处理负收益情况

#### 3. AirQwQ（4星）  
**亮点**：DFS参数记录已选时间段数优化判断  
```cpp
void dfs(int step,int cnt) {
    if(step==11) {
        if(cnt==0) return; // 直接通过参数判断是否合法
        // 计算收益...
    }
}
```

---

## 关键优化与技巧
1. **位运算状态压缩**：将10个时间段的存在性编码为10位二进制数，快速枚举
2. **预处理存储结构**：将三维F[i][j][k]简化为二维f[i][t]（t为1-10的时段编号）
3. **负数初始化处理**：将答案初始值设为-1e9以兼容全负收益的情况

---

## 拓展与相似题目
1. **状态压缩枚举**：  
   - 洛谷P2392 [kkksc03考前临时抱佛脚]：状态选择优化时间分配  
   - 洛谷P1036 [选数]：枚举子集求和  
2. **位运算应用**：  
   - 洛谷P1157 [组合的输出]：生成组合数的二进制实现  

---

## 重点代码节选
SunSkydp的位运算实现核心：
```cpp
for(int i = 1; i < 1024; i++) {
    for(int j = 1; j <= n; j++) {
        int cnt = 0;
        for(int k = 1; k <= 10; k++)
            if(f[j][k] && (i & (1<<(k-1)))) 
                cnt++;
        sum += p[j][cnt];
    }
    ans = max(ans, sum);
}
```

---
处理用时：53.80秒
# 题目信息

# [ABC088D] Grid Repainting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc088/tasks/abc088_d

縦 $ H $ マス, 横 $ W $ マスに広がるマス目があり, 各マスは白または黒で塗られている. 上から $ i $ 番目で左から $ j $ 番目のマスを $ (i,\ j) $ で表す. すぬけ君は, このマス目を使って次のようなゲームをしたい. ゲームの開始時点ではマス $ (1,\ 1) $ にゲームキャラクター「けぬす君」がいる. プレイヤーはけぬす君を上下左右の $ 4 $ 方向のいずれかに $ 1 $ マスだけ動かすことを繰り返す. けぬす君が白いマスだけを通って $ (H,\ W) $ にたどり着けばゲームクリアとなる.  
 ゲームを開始する前に, すぬけ君はいくつかの白いマス目の色を黒に変えることができる. ただし, マス $ (1,\ 1) $ と $ (H,\ W) $ の色を変えることはできず, ゲームを開始するまでにすべての色の変更を行わなければならない.  
 ゲームをクリアしたとき, ゲームの開始前にマスの色を変えた回数がすぬけ君のスコアとなる. そのとき, すぬけ君が取る可能性のある最大のスコアを求めなさい.ただし, すぬけ君がどのようにマス目の色を変えてもけぬす君が $ (H,\ W) $ にたどり着くことが出来ない場合、$ -1 $ と出力しなさい.

ただし, 各マスの色の情報は文字 $ s_{i,\ j} $ として与えられる. マス $ (i,\ j) $ が最初白で塗られている場合 $ s_{i,\ j} $ は `.` であり, マス $ (i,\ j) $ が最初黒で塗られている場合 $ s_{i,\ j} $ は `#` である.

## 说明/提示

### 制約

- $ H $ は $ 2 $ 以上 $ 50 $ 以下の整数
- $ W $ は $ 2 $ 以上 $ 50 $ 以下の整数
- $ s_{i,\ j} $ は `.` または `#` $ (1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W) $
- $ s_{1,\ 1},\ s_{H,\ W} $ は `.` である

### Sample Explanation 1

下の図のようにマス目の色を変えれば, スコア $ 2 $ を達成できます. !\[Explanation of Sample 1\](https://img.atcoder.jp/abc088/bc944898899615e35f898654b68cd517.png)

## 样例 #1

### 输入

```
3 3

..#

#..

...```

### 输出

```
2```

## 样例 #2

### 输入

```
10 37

.....................................

...#...####...####..###...###...###..

..#.#..#...#.##....#...#.#...#.#...#.

..#.#..#...#.#.....#...#.#...#.#...#.

.#...#.#..##.#.....#...#.#.###.#.###.

.#####.####..#.....#...#..##....##...

.#...#.#...#.#.....#...#.#...#.#...#.

.#...#.#...#.##....#...#.#...#.#...#.

.#...#.####...####..###...###...###..

.....................................```

### 输出

```
209```

# AI分析结果



# [ABC088D] Grid Repainting

## 题目描述

在一个 $ H \times W $ 的网格中，每个格子初始为白（`.`）或黑（`#`）。玩家需要从左上角 $(1,1)$ 移动到右下角 $(H,W)$，只能经过白色格子。游戏开始前可以将部分白格子变为黑格子（起点和终点不可改变），求在保证存在路径的情况下，最大可获得的分数（即变黑的白格子数）。若无法到达终点则输出 $-1$。

### 算法分类
广度优先搜索（BFS）

---

### 题解分析与结论

**核心思路**：  
将问题转化为寻找最短路径，必须保留路径上的所有白格子，剩余白格子均可涂黑。最大得分 = 总白格子数 - 最短路径长度 - 初始黑格子数。

**关键技巧**：  
- 使用 BFS 求最短路径，路径长度即为必须保留的白格子数  
- 公式推导：可涂黑数 = 总白格子数（H*W - 初始黑格数） - 最短路径长度

---

### 精选题解（4星）

**关键亮点**：  
- 正确运用 BFS 计算最短路径长度  
- 通过数学公式直接推导答案，复杂度 $O(HW)$  
- 处理边界条件清晰（起点步长初始化为1）

**核心代码**：
```cpp
int main() {
    // ... 输入与初始化 ...
    BFS(1, 1);
    int ans = n * m - cnt - dist[n][m];
    if (ans < 0 || dist[n][m] == INF) puts("-1");
    else printf("%d", ans);
}

void BFS(int sx, int sy) {
    // ... 标准 BFS 实现 ...
    dist[dx][dy] = dist[fx][fy] + 1; // 步长累加
}
```

---

### 拓展与举一反三

**相似题目**：  
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)  
2. [P2298 Mzc和男家丁的游戏](https://www.luogu.com.cn/problem/P2298)  
3. [P1746 离开中山路](https://www.luogu.com.cn/problem/P1746)  

**套路总结**：  
网格最短路径问题通常可用 BFS 高效解决。当需要最大化/最小化保留资源时，先求最优路径再推导剩余资源是常用技巧。

---
处理用时：70.18秒
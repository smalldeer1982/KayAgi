# 题目信息

# [ABC110C] String Transformation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc110/tasks/abc110_c

英小文字のみからなる文字列 $ S $, $ T $ が与えられます。

文字列 $ S $ に対して、次の操作を何度でも行うことができます。

操作: 2つの異なる英小文字 $ c_1 $, $ c_2 $ を選び、$ S $ に含まれる全ての $ c_1 $ を $ c_2 $ に、$ c_2 $ を $ c_1 $ に置き換える

$ 0 $ 回以上操作を行って、$ S $ を $ T $ に一致させられるか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 2\ \times\ 10^5 $
- $ |S|\ =\ |T| $
- $ S $, $ T $ は英小文字のみからなる

### Sample Explanation 1

次のように操作を行えば、`azzel` を `apple` にできます。 - $ c_1 $ として `e` を、$ c_2 $ として `l` を選ぶと、`azzel` が `azzle` になる - $ c_1 $ として `z` を、$ c_2 $ として `p` を選ぶと、`azzle` が `apple` になる

### Sample Explanation 2

どのように操作を行っても `chokudai` を `redcoder` にできません。

## 样例 #1

### 输入

```
azzel

apple```

### 输出

```
Yes```

## 样例 #2

### 输入

```
chokudai

redcoder```

### 输出

```
No```

## 样例 #3

### 输入

```
abcdefghijklmnopqrstuvwxyz

ibyhqfrekavclxjstdwgpzmonu```

### 输出

```
Yes```

# AI分析结果



【题目内容】
# [ABC110C] 字符串转换

## 题目描述

给定仅由小写字母组成的两个字符串 $ S $ 和 $ T $。可以对 $ S $ 进行任意次数的如下操作：

**操作**：选择两个不同的小写字母 $ c_1 $ 和 $ c_2 $，将 $ S $ 中所有 $ c_1 $ 替换为 $ c_2 $，所有 $ c_2 $ 替换为 $ c_1 $。

判断是否可以通过若干次操作使 $ S $ 变为 $ T $。

### 说明/提示

#### 制約
- $ 1 \leq |S| \leq 2 \times 10^5 $
- $ |S| = |T| $
- $ S $ 和 $ T $ 仅包含小写字母

#### 样例解释 1
例如，将 `azzel` 转换为 `apple` 的步骤：
1. 交换 `e` 和 `l` → `azzle`
2. 交换 `z` 和 `p` → `apple`

#### 样例解释 2
无法将 `chokudai` 转换为 `redcoder`。

---

**算法分类**：字符串（字符映射的双向约束）

---

### 题解分析与结论

**核心条件**：
1. **双向映射约束**：每个字符在 $ S $ 中的映射必须与 $ T $ 中的逆映射一致。即：
   - 若 $ S $ 中的字符 `a` 映射到 $ T $ 的 `b`，则 $ T $ 中的 `b` 必须映射回 `a`。
2. **局部一致性**：对于所有位置 $ i $，$ S[i] \to T[i] $ 的映射必须全局一致，不能出现同一字符映射到多个不同字符的情况。

**解决思路**：
- 使用两个字典分别维护 $ S \to T $ 和 $ T \to S $ 的映射关系。
- 遍历每个字符对，检查映射是否满足双向约束。若出现矛盾则返回 `No`，否则返回 `Yes`。

---

### 关键代码实现

```python
S = input().strip()
T = input().strip()

s_map = {}
t_map = {}

for s, t in zip(S, T):
    # 检查 S→T 的映射一致性
    if s in s_map:
        if s_map[s] != t:
            print("No")
            exit()
    else:
        s_map[s] = t
    
    # 检查 T→S 的映射一致性
    if t in t_map:
        if t_map[t] != s:
            print("No")
            exit()
    else:
        t_map[t] = s

print("Yes")
```

**代码要点**：
- 使用双字典同步维护两个方向的映射。
- 遍历时即时检查矛盾，确保双向映射的严格一致性。

---

### 拓展与同类题目

**关键思路**：  
字符替换问题中，双向映射的约束是常见条件。类似问题可能涉及排列置换、图论中的环结构判断等。

**推荐题目**：
1. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)：基于广度优先搜索的字符串变换。
2. [P1279 字串距离](https://www.luogu.com.cn/problem/P1279)：动态规划处理字符串编辑问题。
3. [P1101 单词方阵](https://www.luogu.com.cn/problem/P1101)：二维字符串的模式匹配。

---

### 总结心得

- **调试关键**：初始未正确理解交换操作的叠加效应，误以为需要额外检查字符频率，后发现双向映射约束已隐含频率一致性。
- **核心教训**：在字符替换类问题中，双向映射的严格性是最容易被忽略的关键条件。

---
处理用时：273.32秒
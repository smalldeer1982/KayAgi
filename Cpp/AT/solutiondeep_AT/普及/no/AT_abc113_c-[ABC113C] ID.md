# 题目信息

# [ABC113C] ID

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc113/tasks/abc113_c

Atcoder国には $ N $ 個の県があり、これらの県には合計で $ M $ 個の市が属しています。

市 $ i $ が誕生したのは $ Y_i $ 年であり、県 $ P_i $ に属しています。

ただし、同じ年に誕生した市が複数存在することはないとします。

それぞれの市に $ 12 $ 桁の認識番号を割り振ることとなりました。

市 $ i $ が 県 $ P_i $ に属する市の中で $ x $ 番目に誕生した市のとき、市 $ i $ の認識番号の上 $ 6 $ 桁は $ P_i $、下 $ 6 $ 桁は $ x $ となります。

ただし、$ P_i $ や $ x $ が $ 6 $ 桁に満たない場合は $ 6 $ 桁になるまで $ 0 $ を左に追加するものとします。

全ての市の認識番号を求めてください。

ただし、市が $ 1 $ つも属さない県がある場合に注意してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ P_i\ \leq\ N $
- $ 1\ \leq\ Y_i\ \leq\ 10^9 $
- $ Y_i $ は全て異なる
- 入力は全て整数

### Sample Explanation 1

\- 市 $ 1 $ は県 $ 1 $ に属する市の中で $ 2 $ 番目に誕生したので、認識番号は $ 000001000002 $ となります。 - 市 $ 2 $ は県 $ 2 $ に属する市の中で $ 1 $ 番目に誕生したので、認識番号は $ 000002000001 $ となります。 - 市 $ 3 $ は県 $ 1 $ に属する市の中で $ 1 $ 番目に誕生したので、認識番号は $ 000001000001 $ となります。

## 样例 #1

### 输入

```
2 3

1 32

2 63

1 12```

### 输出

```
000001000002

000002000001

000001000001```

## 样例 #2

### 输入

```
2 3

2 55

2 77

2 99```

### 输出

```
000002000001

000002000002

000002000003```

# AI分析结果



题目内容中文翻译：

# [ABC113C] ID

## 题目描述

Atcoder国有 $ N $ 个县，共计 $ M $ 个市。每个市 $ i $ 属于县 $ P_i $，并在年份 $ Y_i $ 建立，且同一年份不会建立多个市。要求为每个市生成12位编号：前6位为所属县编号（补前导零），后6位为该市在所属县中的建立顺序（补前导零）。需按输入顺序输出所有市的编号。

## 样例 #1

### 输入
```
2 3
1 32
2 63
1 12
```

### 输出
```
000001000002
000002000001
000001000001
```

---

**算法分类**：排序、二分

---

### 题解分析与结论

#### 核心思路
1. **分组排序**：将每个县的市按年份存入`vector`并排序
2. **二分定位**：对每个市用`lower_bound`在已排序列表中查找顺序
3. **格式化输出**：用`%012lld`实现前导零补位

#### 关键难点
- 处理大数量级数据需确保线性时间复杂度
- 正确处理`lower_bound`的偏移量（下标从0开始需+1）

---

### 精选题解（评分：5星）

**作者：Chouquet**  
**亮点**：  
- 利用`vector`数组实现分组存储，避免空间浪费
- 通过`sort`+`lower_bound`实现高效查询
- 格式输出技巧`%012lld`简化补零逻辑  
**代码核心**：
```cpp
std::vector<int> a[100003]; // 按县分组存储年份
for (int i=1; i<=n; i++) 
    std::sort(a[i].begin(), a[i].end()); // 组内排序
printf("%012lld\n", p[i]*1000000ll + (lower_bound(...) +1)); // 计算编号
```

---

### 关键技巧
1. **分组数据结构**：用`vector`数组按县分组存储元素
2. **STL高效组合**：`sort`与`lower_bound`组合实现快速查询
3. **数值型格式化**：将ID视为长整型处理避免字符串拼接

---

### 拓展练习
1. [P1093 奖学金](https://www.luogu.com.cn/problem/P1093)（分组排序）
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分应用）
3. [P1179 数字统计](https://www.luogu.com.cn/problem/P1179)（补零与数值处理）

---

### 心得摘录
> "vector下标从0开始，lower_bound结果必须加1！" —— 此偏移量处理是本题最易错点，体现了对STL底层实现的深刻理解。

---
处理用时：51.48秒
# 题目信息

# [ABC122C] GeT AC

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc122/tasks/abc122_c

`A`, `C`, `G`, `T` からなる長さ $ N $ の文字列 $ S $ が与えられます。以下の $ Q $ 個の問いに答えてください。

- 問 $ i $ ($ 1\ \leq\ i\ \leq\ Q $): 整数 $ l_i,\ r_i $ ($ 1\ \leq\ l_i\ <\ r_i\ \leq\ N $) が与えられる。$ S $ の先頭から $ l_i $ 文字目から $ r_i $ 文字目までの (両端含む) 部分文字列を考える。この文字列に `AC` は部分文字列として何回現れるか。

## 说明/提示

### 注記

文字列 $ T $ の部分文字列とは、$ T $ の先頭と末尾から $ 0 $ 文字以上を取り去って得られる文字列です。

例えば、`ATCODER` の部分文字列には `TCO`, `AT`, `CODER`, `ATCODER`, `` (空文字列) が含まれ、`AC` は含まれません。

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ S $ は長さ $ N $ の文字列である。
- $ S $ の各文字は `A`, `C`, `G`, `T` のいずれかである。
- $ 1\ \leq\ l_i\ <\ r_i\ \leq\ N $

### Sample Explanation 1

\- 問 $ 1 $: $ S $ の先頭から $ 3 $ 文字目から $ 7 $ 文字目までの部分文字列は `ACTAC` です。この文字列に `AC` は部分文字列として $ 2 $ 回現れます。 - 問 $ 2 $: $ S $ の先頭から $ 2 $ 文字目から $ 3 $ 文字目までの部分文字列は `CA` です。この文字列に `AC` は部分文字列として $ 0 $ 回現れます。 - 問 $ 3 $: $ S $ の先頭から $ 1 $ 文字目から $ 8 $ 文字目までの部分文字列は `ACACTACG` です。この文字列に `AC` は部分文字列として $ 3 $ 回現れます。

## 样例 #1

### 输入

```
8 3

ACACTACG

3 7

2 3

1 8```

### 输出

```
2

0

3```

# AI分析结果



# [ABC122C] GeT AC

## 题目描述

`A`, `C`, `G`, `T` 组成的长度为 $N$ 的字符串 $S$ 被给出。需要回答以下 $Q$ 个问题：

- 问题 $i$ ($ 1\ \leq\ i\ \leq\ Q $)：给定整数 $ l_i,\ r_i $ ($ 1\ \leq\ l_i\ <\ r_i\ \leq\ N $)。考虑 $S$ 中从第 $l_i$ 个字符到第 $r_i$ 个字符（含两端）的子串。求这个子串中 `AC` 作为子串出现的次数。

### 样例 #1

#### 输入
```
8 3
ACACTACG
3 7
2 3
1 8
```

#### 输出
```
2
0
3
```

---

**算法分类**：前缀和

---

### 题解综合分析

所有题解均采用前缀和预处理核心思路，通过构建累计AC出现次数的数组，将查询复杂度优化到O(1)。关键点在于正确计算区间端点的偏移量，确保每个AC组合只被统计一次。

#### 高分题解推荐

1. **BlackPanda（5星）**
   - 亮点：清晰定义dp数组含义，注释说明数组转移逻辑，正确处理字符串索引偏移
   ```cpp
   for(int i = 0; i < n; ++i){
       if(s[i] == 'A' && s[i+1] == 'C'){
           dp[i+1] = dp[i] + 1;
       } else {
           dp[i+1] = dp[i];
       }
   }
   ```

2. **Aehnuwx（4星）**
   - 亮点：采用字符向后检测法，代码简洁，明确注释端点处理逻辑
   ```cpp
   for(int i=2;i<=n;i++) 
       sum[i]=sum[i-1]+(s[i]=='C'&&s[i-1]=='A');
   cout<<sum[r]-sum[l]<<endl;
   ```

3. **ZXXS（4星）**
   - 亮点：使用快读快写优化IO，处理大数输入输出更高效
   ```cpp
   dp[i]=dp[i-1]+(in[i]=='C'&&in[i-1]=='A'?1:0);
   write(dp[r]-dp[l]);
   ```

---

### 关键思路总结

**前缀和预处理**：构建数组记录每个位置之前的AC出现次数，查询时通过端点差值直接计算结果。特别注意：
- 检测AC时需检查连续两个字符
- 区间端点的偏移处理（如右端点需减1）
- 数组索引与字符位置的对应关系

---

### 拓展建议

类似前缀和技巧可应用于以下场景：
1. 区间字符对统计（如统计特定双字母组合）
2. 滑动窗口类问题
3. 需要快速响应范围查询的计数问题

---

### 推荐练习题
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115) - 一维前缀和经典应用
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 差分与前缀和结合
3. [P3131 Subsequence](https://www.luogu.com.cn/problem/P3131) - 前缀和与模运算结合

---

### 题解心得摘录

- Ryo_Yamada：初次暴力解法TLE后意识到必须用前缀和优化，提醒注意输出格式换行符
- Aehnuwx：强调以字符C作为统计端点，需注意区间转换关系
- ZXXS：通过快读快写优化处理大数据量输入输出，提升效率

---
处理用时：53.99秒
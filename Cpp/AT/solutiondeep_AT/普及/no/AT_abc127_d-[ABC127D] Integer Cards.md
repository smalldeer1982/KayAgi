# 题目信息

# [ABC127D] Integer Cards

## 题目描述

有一个长度为 $n$ 的序列 $A_{1},A_{2},\cdots,A_{n} $

你可以对这个序列依次进行 $m$ 次操作，第 $ i$ 次操作中，你可以选择至多 $B_{i}$ 个数（可以一个都不选），然后将这些数变成 $C_{i}$

问进行这 $m$ 次操作后，这个序列所有元素之和可能的最大值是多少

## 说明/提示

$1 \le n,m \le 10^5,1 \le A_{i},C{i} \le 10^9,1 \le B_{i} \le n$

## 样例 #1

### 输入

```
3 2

5 1 4

2 3

1 5```

### 输出

```
14```

## 样例 #2

### 输入

```
10 3

1 8 5 7 100 4 52 33 13 5

3 10

4 30

1 4```

### 输出

```
338```

## 样例 #3

### 输入

```
3 2

100 100 100

3 99

3 99```

### 输出

```
300```

## 样例 #4

### 输入

```
11 3

1 1 1 1 1 1 1 1 1 1 1

3 1000000000

4 1000000000

3 1000000000```

### 输出

```
10000000001```

# AI分析结果



# [ABC127D] Integer Cards

## 题目描述

有一个长度为 $n$ 的序列 $A_{1},A_{2},\cdots,A_{n} $

你可以对这个序列依次进行 $m$ 次操作，第 $ i$ 次操作中，你可以选择至多 $B_{i}$ 个数（可以一个都不选），然后将这些数变成 $C_{i}$

问进行这 $m$ 次操作后，这个序列所有元素之和可能的最大值是多少

## 说明/提示

$1 \le n,m \le 10^5,1 \le A_{i},C{i} \le 10^9,1 \le B_{i} \le n$

---

**算法分类**：贪心

---

### 最优题解分析

#### [SongShouqian 的题解]（4星）
**关键亮点**：
- 通过双指针实现线性时间复杂度
- 将原数组与操作分离处理，避免冗余计算
- 采用结构体存储操作，逻辑清晰

**核心代码**：
```cpp
sort(a, a + n); // 原数组升序排序
sort(bc, bc + m, cmp); // 操作按C降序排序

long long f = 0, g = 0;
for (long long i = 0; i < n; i++) {
    if (a[i] < bc[g].v) { // 可替换
        sum += bc[g].v;
        bc[g].k--;
        if (bc[g].k == 0) g++; // 切换下一个操作
    } else {
        break; // 后续无需处理
    }
}
```

#### [Rain_chr 的题解]（4星）
**关键亮点**：
- 使用优先队列维护当前最小值
- 动态替换策略保证实时最优
- 操作预排序减少无效比较

**核心实现**：
```cpp
priority_queue<int, vector<int>, greater<int>> q; // 小根堆
sort(b, b + m, cmp); // 操作按C降序排序

for (int i = 1; i <= m; i++) {
    while (b[i].count && q.top() < b[i].number) {
        q.pop();
        q.push(b[i].number); // 替换最小值
        b[i].count--;
    }
}
```

#### [guanyf 的题解]（4星）
**关键亮点**：
- 结构体与pair的巧妙结合
- 极简循环结构提升效率
- 隐式指针切换逻辑清晰

**核心代码**：
```cpp
sort(a + 1, a + 1 + n); // 原数组升序
sort(b + 1, b + m + 1, greater<>()); // 操作降序

for (int i = 1, j = 1; i <= n && j <= m; i++) {
    if (a[i] < b[j].first) { // 可替换
        a[i] = b[j].first;
        if (--b[j].second == 0) j++; // 切换操作
    } else {
        break; // 终止条件
    }
}
```

---

### 关键思路总结
1. **双排序策略**：将原数组升序排序，操作按替换值降序排序
2. **贪心替换**：用最大的替换值优先替换最小的原数组元素
3. **批量处理**：通过指针或堆结构实现线性时间复杂度，避免逐个操作处理

---

### 类似题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）
2. [P1208 [USACO1.3]混合牛奶 Mixing Milk](https://www.luogu.com.cn/problem/P1208)（贪心排序策略）
3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)（贪心排序与极值选择）

---
处理用时：83.15秒
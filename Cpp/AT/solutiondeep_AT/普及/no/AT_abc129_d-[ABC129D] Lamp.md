# 题目信息

# [ABC129D] Lamp

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc129/tasks/abc129_d

縦 $ H $ 行横 $ W $ 列のグリッドが与えられます。このグリッドのうち、いくつかのマスには障害物が存在します。

すぬけ君は、障害物のないマスのうち一つを選び、そのマスに明かりを設置しようとしています。 設置されたマスから、上下左右の四方向にまっすぐに光線が伸びます。それぞれの方向について、最初に障害物が存在するマスにぶつかる、もしくはグリッドの端にぶつかる手前のマスまで照らされます。明かりを設置したマスも照らされますが、障害物が存在するマスは照らされません。

すぬけ君は明かりによって照らされるマスの個数を最大化したいです。

$ H $ 個の長さ $ W $ の文字列 $ S_i $ ($ 1\ <\ =\ i\ <\ =\ H $) が与えられます。$ S_i $ の $ j $ 文字目 ($ 1\ <\ =\ j\ <\ =\ W $) が `#` のとき、グリッドの上から $ i $ 行目で左から $ j $ 列目のマスには障害物があり、 `.` のときは障害物がありません。

照らされるマスの個数の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ H\ <\ =\ 2,000 $
- $ 1\ <\ =\ W\ <\ =\ 2,000 $
- $ S_i $ は `#` と `.` のみからなる長さ $ W $ の文字列
- $ S_i $ ($ 1\ <\ =\ i\ <\ =\ H $) のうちいずれかに `.` は最低 $ 1 $ つ存在する

### Sample Explanation 1

すぬけ君が上から $ 2 $ 行目、左から $ 2 $ 列目のマスに明かりを設置すると、上から $ 2 $ 行目のうち左から $ 1 $ 〜 $ 5 $ 列目のマス、 左から $ 2 $ 列目のうち上から $ 1 $ 〜 $ 4 $ 列目のマス全てが照らされ、全部で $ 8 $ マスです。

## 样例 #1

### 输入

```
4 6

#..#..

.....#

....#.

#.#...```

### 输出

```
8```

## 样例 #2

### 输入

```
8 8

..#...#.

....#...

##......

..###..#

...#..#.

##....#.

#...#...

###.#..#```

### 输出

```
13```

# AI分析结果



# [ABC129D] Lamp 的中文翻译

## 题目描述

给定一个由 $H$ 行 $W$ 列组成的网格，部分格子存在障碍物。当在无障碍物的格子放置灯时，灯光会向上下左右四个方向直线传播，直到遇到障碍物或网格边界为止。灯光覆盖的格子数包含起点但不包含障碍物。

你的任务是找出能够被灯光覆盖的最大格子数量。

**输入格式**  
- 输入包含 $H$ 个长度为 $W$ 的字符串，`#` 表示障碍物，`.` 表示空地

**输出格式**  
- 输出灯光能覆盖的最大格子数

## 说明/提示

### 数据范围
- $1 \leq H, W \leq 2000$
- 至少存在一个可放置灯的格子

### 样例解释
样例1中，选择第2行第2列的格子，横向覆盖5格，纵向覆盖4格，总计8格（交叉点算1次）。

---

**算法分类**  
前缀和 / 动态规划

---

## 题解对比与最优思路

### 各题解核心思路对比

| 方法               | 预处理方式                    | 时间复杂度      | 关键技巧                     |
|--------------------|-----------------------------|----------------|----------------------------|
| 四方向障碍物坐标法  | 记录四个方向最近障碍物坐标     | O(HW)          | 虚拟边界处理坐标计算         |
| 悬线法             | 继承相邻格子的延伸距离        | O(HW)          | 利用连续区域的继承性         |
| 二分法             | 存储行列障碍物进行二分查找     | O(HW log(H+W)) | 二分查找前驱后继障碍物       |
| 四方向延伸计数法    | 动态规划计算各方向延伸长度     | O(HW)          | 方向独立处理+重叠计数修正     |

---

## 精选题解推荐

### 题解1：scp020（五星）
**核心思路**  
预处理四个方向的连续空地长度：
- `f1` 左延伸长度：`f1[i][j] = (空地) ? f1[i][j-1]+1 : 0`
- `f2` 右延伸长度：`f2[i][j] = (空地) ? f2[i][j+1]+1 : 0`
- `f3` 上延伸长度：`f3[i][j] = (空地) ? f3[i-1][j]+1 : 0`
- `f4` 下延伸长度：`f4[i][j] = (空地) ? f4[i+1][j]+1 : 0`

总覆盖数为四向总和减3（消除起点重复计数）

**代码亮点**  
```cpp
for(int i=1;i<=h;i++)
    for(int j=1;j<=w;j++)
        f1[i][j]=(a[i][j]=='.'?f1[i][j-1]+1:0),
        f3[i][j]=(a[i][j]=='.'?f3[i-1][j]+1:0);

for(int i=h;i;i--)
    for(int j=w;j;j--)
        f2[i][j]=(a[i][j]=='.'?f2[i][j+1]+1:0),
        f4[i][j]=(a[i][j]=='.'?f4[i+1][j]+1:0);

ans = max(ans, f1[i][j]+f2[i][j]+f3[i][j]+f4[i][j]-3);
```
**评分理由**  
- 代码简洁高效，四向独立预处理
- 使用逆向遍历完成右、下方向的动态规划
- 数学修正精准（-3处理重叠计数）

---

### 题解2：lizhous（四星）
**核心思路**  
预处理每个格子四个方向的首个障碍物坐标：
- 正向扫描记录左、上方的最近障碍
- 逆向扫描记录右、下方的最近障碍
- 最终计算公式：`(x2-x1-1)+(y2-y1-1)-1`

**个人心得**  
在预处理时添加虚拟边界（0和W+1/N+1）避免边界特判

---

## 关键优化技巧
1. **方向独立预处理**：将四向处理拆分为独立的正逆扫描，避免状态互相干扰
2. **动态规划继承**：利用相邻格子的预处理结果实现O(1)的状态转移
3. **虚拟边界处理**：通过添加哨兵值简化边界条件的判断

---

## 拓展练习
1. [P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)（悬线法求最大矩形）
2. [P1502 窗口的星星](https://www.luogu.com.cn/problem/P1502)（二维前缀和+离散化）
3. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（差分数组应用）

---
处理用时：67.73秒
# 题目信息

# [ABC135D] Digits Parade

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc135/tasks/abc135_d

文字列 $ S $ が与えられます。$ S $ の各文字は、数字 (`0` ～ `9`) か `?` です。

`?` を数字に置き換えてできる整数のうち、$ 13 $ で割って $ 5 $ あまる数は何通りあるでしょうか？ただし、頭文字が $ 0 $ である場合も整数とみなすものとします。

答えは非常に大きくなる可能性があるため、$ 10^9+7 $ で割ったあまりを答えてください。

## 说明/提示

### 制約

- $ S $ は数字 (`0` ～ `9`) と `?` からなる文字列。
- $ 1\ \leq\ |S|\ \leq\ 10^5 $

### Sample Explanation 1

たとえば $ 482305,\ 002865,\ 972665 $ などが条件を満たします。

### Sample Explanation 2

$ 044 $ のみが条件を満たします。

### Sample Explanation 3

条件を満たす整数を作ることが不可能な場合もあります。

## 样例 #1

### 输入

```
??2??5```

### 输出

```
768```

## 样例 #2

### 输入

```
?44```

### 输出

```
1```

## 样例 #3

### 输入

```
7?4```

### 输出

```
0```

## 样例 #4

### 输入

```
?6?42???8??2??06243????9??3???7258??5??7???????774????4?1??17???9?5?70???76???```

### 输出

```
153716888```

# AI分析结果



# 中文题目重写

## 题目描述

给定一个由数字（`0`-`9`）和 `?` 组成的字符串 $S$。将 `?` 替换为数字后形成的所有整数中，求满足被 $13$ 除余 $5$ 的情况数。答案对 $10^9+7$ 取模。

### 样例解释
- 样例1：如 `482305` 满足 $482305 \mod 13 = 5$
- 样例2：唯一解为 `044`（允许前导零）
- 样例3：无法构造满足条件的数

### 数据范围
- $1 \leq |S| \leq 10^5$

---

**算法分类**：动态规划

---

## 题解对比与结论

### 关键思路
采用动态规划维护余数状态：
1. **状态定义**：`dp[i][j]` 表示处理前 `i` 位时余数为 `j` 的方案数。
2. **状态转移**：对于每一位字符：
   - 若为数字，则 `dp[i][(prev*10 + num) % 13] += dp[i-1][prev]`
   - 若为 `?`，枚举 0-9 所有可能，类似数字处理
3. **空间优化**：使用滚动数组将空间复杂度降至 $O(13)$

### 最优题解（评分≥4星）

#### 1. Gokix（5星）
**核心亮点**：
- **逆向处理**：从低位到高位递推，结合权值计算（$10^i \mod 13$）
- **滚动数组优化**：仅用两个一维数组实现状态转移
- **时间复杂度**：$O(130n)$，高效处理大长度输入

**代码核心**：
```cpp
for(int i=n;i>=1;i--){
    if(s[i]=='?'){
        memset(g,0,sizeof(g));
        for(k=0;k<10;k++){
            v=yu*k%13; // yu为当前位的权值
            for(j=0;j<13;j++) 
                g[(j+v)%13] = (g[...] + f[j])%mod;
        }
    } else {
        v=yu*(s[i]-'0')%13;
        for(j=0;j<13;j++)
            g[(j+v)%13] = f[j];
    }
    yu = yu*10%13; // 更新权值
    swap(f,g); // 滚动数组
}
```

#### 2. μηδσ（4星）
**核心亮点**：
- **正向递推**，直观符合数位处理顺序
- **代码简洁**，适合快速理解基础DP思路

**代码核心**：
```cpp
dp[0][0] = 1;
for(int i=1; i<=n; i++){
    if(s[i]!='?'){
        int num = s[i]-'0';
        for(int j=0; j<13; j++)
            dp[i][(j*10+num)%13] += dp[i-1][j];
    } else {
        for(int k=0; k<10; k++)
            for(int j=0; j<13; j++)
                dp[i][(j*10+k)%13] += dp[i-1][j];
    }
}
```

---

## 同类型题目推荐
1. [P4124 [CQOI2016]手机号码](https://www.luogu.com.cn/problem/P4124) - 数位DP与状态设计
2. [P4999 烦人的数学作业](https://www.luogu.com.cn/problem/P4999) - 数位和模数处理
3. [P2602 数字计数](https://www.luogu.com.cn/problem/P2602) - 数位统计与动态规划

---

## 调试心得摘录
- **Yang818**：尝试用记忆化搜索但超时，转用DP后通过，说明递归不适用于大规模数据。
- **Gokix**：通过权值预计算避免重复模运算，提升效率。
- **SilverLi**：强调余数传递的数学原理，即 `(prev*10 + curr) % 13` 的正确性。

---
处理用时：77.93秒
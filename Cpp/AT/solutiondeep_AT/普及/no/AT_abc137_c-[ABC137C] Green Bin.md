# 题目信息

# [ABC137C] Green Bin

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc137/tasks/abc137_c

文字列 $ a $ に含まれる文字を何らかの順序で並べることで得られる文字列を $ a $ の *アナグラム* と呼びます。

例えば、`greenbin` は `beginner` のアナグラムです。このように、同じ文字が複数回現れるときはその文字をちょうどその回数だけ使わなければなりません。

$ N $ 個の文字列 $ s_1,\ s_2,\ \ldots,\ s_N $ が与えられます。それぞれの文字列は長さが $ 10 $ で英小文字からなり、またこれらの文字列はすべて異なります。二つの整数 $ i,\ j $ $ (1\ \leq\ i\ <\ j\ \leq\ N) $ の組であって、$ s_i $ が $ s_j $ のアナグラムであるようなものの個数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ s_i $ は長さ $ 10 $ の文字列である。
- $ s_i $ の各文字は英小文字である。
- $ s_1,\ s_2,\ \ldots,\ s_N $ はすべて異なる。

### Sample Explanation 1

$ s_1\ = $ `acornistnt` は $ s_3\ = $ `constraint` のアナグラムです。他に $ s_i $ が $ s_j $ のアナグラムであるような $ i,\ j $ の組はないため、答えは $ 1 $ です。

### Sample Explanation 2

$ s_i $ が $ s_j $ のアナグラムであるような $ i,\ j $ の組がないときは $ 0 $ と出力してください。

### Sample Explanation 3

ここにそのようなケースを置くことはできませんが、答えは $ 32 $ bit 整数型に収まらない可能性があるので注意してください。

## 样例 #1

### 输入

```
3

acornistnt

peanutbomb

constraint```

### 输出

```
1```

## 样例 #2

### 输入

```
2

oneplustwo

ninemodsix```

### 输出

```
0```

## 样例 #3

### 输入

```
5

abaaaaaaaa

oneplustwo

aaaaaaaaba

twoplusone

aaaabaaaaa```

### 输出

```
4```

# AI分析结果



# [ABC137C] Green Bin

## 题目描述

我们将通过以某种顺序排列字符串 $a$ 中包含的字符而获得的字符串称为 $a$ 的 *アナグラム*（anagram）。

例如，`greenbin` 是 `beginner` 的 anagram。当同一字符多次出现时，必须恰好使用该次数。

给定 $N$ 个互不相同的字符串 $s_1,\ s_2,\ \ldots,\ s_N$，每个字符串长度为 $10$ 且由小写字母组成。求满足 $1\ \leq\ i\ <\ j\ \leq\ N$ 且 $s_i$ 是 $s_j$ 的 anagram 的整数对个数。

### 样例 #1

#### 输入
```
3
acornistnt
peanutbomb
constraint
```

#### 输出
```
1
```

### 说明/提示

#### 数据范围
- $2\ \leq\ N\ \leq\ 10^5$
- 所有字符串各不相同

---

**算法分类**：字符串、组合数学

---

## 精选题解分析

### 题解关键思路
所有题解均采用「排序字符串 + 哈希统计」的核心方法：
1. 将每个字符串排序后得到唯一标识
2. 统计相同标识的出现次数
3. 对每个出现次数 $k$ 计算组合数 $C(k,2)$ 求和

#### 最优实现技巧
**动态累加计数法**（tZERO 的解法）：
- 在插入哈希表时实时计算对数增量，避免二次遍历
- 时间复杂度 $O(n \cdot 10\log10)$，空间复杂度 $O(n)$

---

## 高星题解推荐

### 题解：tZEROちゃん（★★★★★）
**核心亮点**：
- 实时计算对数增量，空间更优
- 使用单次遍历完成统计
- 代码简洁高效（19行）

```cpp
map<string, int> mp;
LL n;
cin >> n;
LL cnt = 0;
rep (i, 1, n) {
    string s;
    cin >> s;
    sort(s.begin(), s.end());
    mp[s]++;
    cnt += mp[s] - 1; // 关键：当前新增的配对数 = 之前出现的次数
}
cout << cnt;
```

### 题解：MattL（★★★★☆）
**核心亮点**：
- 详细解释 auto 遍历 map 的用法
- 强调 long long 的必要性
- 包含完整输入输出处理

```cpp
map<string,ll> mp;
for(auto i:mp) 
    ans += i.second*(i.second-1)/2;
```

### 题解：so_find_skind（★★★★☆）
**创新思路**：
- 通过全局排序后统计连续相同项
- 避免使用哈希表，节省内存
- 适合字符串长度固定场景

```cpp
sort(a+1,a+1+n);
for(int i=2;i<=n+1;i++){
    if(a[i]==a[i-1]) ++ans;
    else sum += ans*(ans-1)/2;
}
```

---

## 关键技巧总结
1. **字符串标准化**：通过排序将 anagram 转换为唯一标识
2. **组合数优化**：用数学公式代替暴力枚举，时间复杂度从 $O(n^2)$ 降至 $O(n)$
3. **动态计数**：在插入哈希表时直接累加结果，减少空间占用

---

## 同类题目推荐
1. P1102 [A-B 数对](https://www.luogu.com.cn/problem/P1102) - 哈希统计配对
2. P1177 [快速排序](https://www.luogu.com.cn/problem/P1177) - 排序基础应用
3. P1305 [字符串的展开](https://www.luogu.com.cn/problem/P1305) - 字符串处理技巧

---

## 调试心得摘录
- **long long 陷阱**：多个题解强调必须用 long long，当 $n=1e5$ 时组合数可能超过 $5e9$（样例3的答案为4，但极端情况会溢出）
- **输出格式**：AtCoder 题目要求末尾必须换行，否则判错
- **排序效率**：字符串长度固定为10，使用标准库排序效率稳定

---
处理用时：55.45秒
# 题目信息

# [ABC138D] Ki

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc138/tasks/abc138_d

$ 1 $ から $ N $ までの番号がついた $ N $ 個の頂点を持つ根付き木が与えられます。 この木の根は頂点 $ 1 $ で、$ i $ 番目の辺 $ (1\ \leq\ i\ \leq\ N\ -\ 1) $ は頂点 $ a_i $ と頂点 $ b_i $ を結びます。

各頂点にはカウンターが設置されており、はじめすべての頂点のカウンターの値は $ 0 $ です。

これから、以下のような $ Q $ 回の操作が行われます。

- 操作 $ j $ $ (1\ \leq\ j\ \leq\ Q) $: 頂点 $ p_j $ を根とする部分木に含まれるすべての頂点のカウンターの値に $ x_j $ を足す。

すべての操作のあとの各頂点のカウンターの値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ a_i\ <\ b_i\ \leq\ N $
- $ 1\ \leq\ p_j\ \leq\ N $
- $ 1\ \leq\ x_j\ \leq\ 10^4 $
- 与えられるグラフは木である。
- 入力中の値はすべて整数である。

### Sample Explanation 1

この入力中の木は次のようなものです。 !\[図\](https://img.atcoder.jp/ghi/c771b2231be06af79a9994cbe6867552.png) 各操作で、頂点のカウンターの値は次のように変化します。 - 操作 $ 1 $: 頂点 $ 2 $ を根とする部分木に含まれるすべての頂点、すなわち頂点 $ 2,\ 3,\ 4 $ のカウンターの値に $ 10 $ を足す。頂点 $ 1,\ 2,\ 3,\ 4 $ のカウンターの値はそれぞれ $ 0,\ 10,\ 10,\ 10 $ となる。 - 操作 $ 2 $: 頂点 $ 1 $ を根とする部分木に含まれるすべての頂点、すなわち頂点 $ 1,\ 2,\ 3,\ 4 $ のカウンターの値に $ 100 $ を足す。頂点 $ 1,\ 2,\ 3,\ 4 $ のカウンターの値はそれぞれ $ 100,\ 110,\ 110,\ 110 $ となる。 - 操作 $ 3 $: 頂点 $ 3 $ を根とする部分木に含まれるすべての頂点、すなわち頂点 $ 3 $ のカウンターの値に $ 1 $ を足す。頂点 $ 1,\ 2,\ 3,\ 4 $ のカウンターの値はそれぞれ $ 100,\ 110,\ 111,\ 110 $ となる。

## 样例 #1

### 输入

```
4 3

1 2

2 3

2 4

2 10

1 100

3 1```

### 输出

```
100 110 111 110```

## 样例 #2

### 输入

```
6 2

1 2

1 3

2 4

3 6

2 5

1 10

1 10```

### 输出

```
20 20 20 20 20 20```

# AI分析结果



# 题目中文翻译

## [ABC138D] Ki

### 题目描述

给定一棵包含 $N$ 个顶点的根为顶点 $1$ 的树。顶点编号为 $1$ 到 $N$，第 $i$ 条边连接顶点 $a_i$ 和 $b_i$。

每个顶点的计数器初始值为 $0$。进行 $Q$ 次操作，每次操作将顶点 $p_j$ 的子树中所有顶点计数器值增加 $x_j$。求所有操作完成后各顶点的计数器值。

### 输入格式
输入包含若干行：
- 第一行：$N$ 和 $Q$
- 接下来 $N-1$ 行：每行两个整数表示边
- 最后 $Q$ 行：每行两个整数 $p_j$ 和 $x_j$

### 输出格式
输出最终各顶点计数器值，空格分隔。

### 数据范围
- $2 \leq N, Q \leq 2 \times 10^5$
- $1 \leq a_i < b_i \leq N$

---

**算法分类**：差分、深度优先搜索（DFS）

---

# 题解综合分析

### 核心思路对比
所有题解均围绕高效处理子树更新的核心需求展开：
1. **差分标记法**（最优解）：在父节点记录增量，通过DFS将标记下传到子树。时间复杂度 $O(n)$。
2. 树链剖分：将子树转换为区间后用线段树维护，复杂度 $O(n \log n)$，代码复杂度高。
3. LCT解法：理论可行但实现复杂，常数大，不适合本题数据规模。

### 最优思路总结
**差分标记 + 后序DFS累加** 是本题最优解法：
- 在每个操作中仅在目标节点记录增量
- 通过一次DFS遍历，将父节点的累积值传递给子节点
- 每个节点的最终值等于其所有祖先的增量之和

---

# 精选题解

## 1. _Life_ 的差分标记法（⭐⭐⭐⭐⭐）
**关键亮点**：简洁高效，线性时间复杂度  
**核心思路**：
- 初始化时将所有操作累加到目标节点的标记数组
- 从根节点DFS遍历，将父节点的标记值累加到子节点

```cpp
void dfs(int u, int fa) {
    x[u] += x[fa]; // 核心代码：累加父节点值
    for(int v : g[u])
        if(v != fa) dfs(v, u);
}
```

## 2. Tx_Lcy 的递推解法（⭐⭐⭐⭐）
**关键亮点**：直观的递推实现  
**核心思路**：
- 直接维护每个节点到根路径上的累加和
- DFS时传递当前累计值参数

```cpp
void dfs(int now, int fa, int sum) {
    ans[now] = sum + cnt[now]; // 当前累计值 + 自身标记
    for(auto v : g[now])
        if(v != fa) dfs(v, now, ans[now]);
}
```

## 3. lkjzyd20 的离线差分法（⭐⭐⭐⭐）
**关键亮点**：显式差分数组处理  
**核心思路**：
- 维护差分数组记录每个节点的增量
- DFS时动态计算前缀和

```cpp
void dfs(int x, int fa, int sum) {
    ans[x] = sum + b[x]; // 显式计算当前节点值
    for(int v : edges[x])
        if(v != fa) dfs(v, x, ans[x]);
}
```

---

# 关键实现技巧
1. **差分标记传递**：父节点的标记自然包含所有祖先的增量
2. **后序遍历顺序**：确保父节点值计算完成后才处理子节点
3. **链式前向星存储**：高效存储大规模树结构

---

# 拓展建议
1. **类似问题**：
   - [P3178 HAOI2015 树上操作](https://www.luogu.com.cn/problem/P3178)（树剖模板）
   - [P3369 普通平衡树](https://www.luogu.com.cn/problem/P3369)（区间操作思想）
   - [P3384 树链剖分](https://www.luogu.com.cn/problem/P3384)（区间更新练习）

2. **调试心得**：
   - 注意树的存储应为双向边，DFS需避免回父节点
   - 大规模数据必须使用高效IO方法（如关闭同步流）

---

# 推荐练习
1. [P3384 树链剖分](https://www.luogu.com.cn/problem/P3384)  
2. [P3178 树上操作](https://www.luogu.com.cn/problem/P3178)  
3. [P3368 树状数组2](https://www.luogu.com.cn/problem/P3368)（差分思想应用）

---
处理用时：64.19秒
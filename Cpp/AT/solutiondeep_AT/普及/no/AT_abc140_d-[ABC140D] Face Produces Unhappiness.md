# 题目信息

# [ABC140D] Face Produces Unhappiness

## 题目描述

有 $N$ 个人从东向西排成一排，每个人的状态用一个字符串 $S$ 表示，第i个字符 $s_i$

 表示从西边数起第 $i$ 个人的朝向```L```
表示面朝西， ```R``` 表示面朝东。

对于队伍中的每个人，如果自己面前的人的朝向和自己一样，那么这个人就会感到幸福。如果面前的人朝向和自己不一样，或者面前没有人，这个人就感到不幸福。

你可以进行以下操作最多 $K$ 次（也可以一次都不进行）：

选择整数$l,r（1≤l≤r≤N）$，让从西边数起第 $l,l+1,⋯,r$ 个人转身180度。

经过最多 $K$ 次操作后，感到幸福的人最多有多少人？

## 样例 #1

### 输入

```
6 1

LRLRRL```

### 输出

```
3```

## 样例 #2

### 输入

```
13 3

LRRLRLRRLRLLR```

### 输出

```
9```

## 样例 #3

### 输入

```
10 1

LLLLLRRRRR```

### 输出

```
9```

## 样例 #4

### 输入

```
9 2

RRRLRLRLL```

### 输出

```
7```

# AI分析结果



### 题目翻译

# [ABC140D] Face Produces Unhappiness

## 题目描述

有 $N$ 个人从东向西排成一排，每个人的状态用一个字符串 $S$ 表示，第i个字符 $s_i$ 表示从西边数起第 $i$ 个人的朝向：`L` 表示面朝西，`R` 表示面朝东。

对于队伍中的每个人，如果自己面前的人的朝向和自己一样，那么这个人就会感到幸福。如果面前的人朝向和自己不一样，或者面前没有人，这个人就感到不幸福。

你可以进行以下操作最多 $K$ 次（也可以一次都不进行）：

选择整数 $l,r（1≤l≤r≤N）$，让从西边数起第 $l,l+1,⋯,r$ 个人转身180度。

经过最多 $K$ 次操作后，感到幸福的人最多有多少人？

---

### 算法分类
**贪心**

---

### 题解分析与总结

#### 核心思路
通过观察相邻字符对的匹配情况，发现每次翻转操作最多能增加两个幸福的人。初始幸福人数为相邻相同字符对数，最终结果为初始值加上 $2K$（不超过 $n-1$）。

#### 解决难点
- **关键性质**：每次翻转操作最多改变两对相邻关系，每次操作贡献最多+2。
- **边界处理**：最大幸福人数不会超过 $n-1$（全同向情况）。

#### 最优题解（评分5星）

**作者：small_john**  
**亮点**：思路简洁高效，直接统计初始相邻相同对数，时间复杂度 $O(n)$。  
**代码核心**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
string s;
signed main() {
    cin>>n>>k>>s;
    for(int i=0; i<s.size()-1; i++)
        if(s[i]==s[i+1]) ans++;
    cout<<min(n-1, ans+k*2);
}
```
**思路**：遍历字符串统计相邻相同对，答案取初始值加 $2K$ 和 $n-1$ 的最小值。

---

### 关键技巧
1. **相邻对统计**：将问题转化为相邻字符对的匹配问题，简化计算。
2. **贪心性质**：每次操作最大化收益，直接推导出公式解。

---

### 类似题目推荐
1. [CF1328C - Ternary XOR](https://codeforces.com/problemset/problem/1328/C)  
   **考察点**：贪心构造与字符翻转策略。
2. [洛谷 P1090 - 合并果子](https://www.luogu.com.cn/problem/P1090)  
   **考察点**：贪心选择最优操作次数。
3. [洛谷 P5019 - 铺设道路](https://www.luogu.com.cn/problem/P5019)  
   **考察点**：差分与区间操作的最优策略。

---

### 个人心得摘录
- **贪心直觉**：题目中每次操作的收益上限是固定的，这往往是贪心选择的信号。
- **边界陷阱**：`n-1` 的最大值容易被忽略，需注意极端情况（如全同向）。

---
处理用时：220.54秒
# 题目信息

# [ABC145D] Knight

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc145/tasks/abc145_d

二次元グリッドの原点 $ (0,0) $ にチェスのナイトの駒があります。

ナイトの駒はマス $ (i,j) $ にあるとき $ (i+1,j+2) $ か $ (i+2,\ j+1) $ のどちらかのマスにのみ動かすことができます。

ナイトの駒をマス $ (X,Y) $ まで移動させる方法は何通りありますか？

$ 10^9+7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ X\ \leq\ 10^6 $
- $ 1\ \leq\ Y\ \leq\ 10^6 $
- 入力中のすべての値は整数である。

### Sample Explanation 1

$ (0,0)\ \to\ (1,2)\ \to\ (3,3) $ と $ (0,0)\ \to\ (2,1)\ \to\ (3,3) $ の $ 2 $ 通りが考えられます。

### Sample Explanation 2

$ (2,2) $ にナイトの駒を移動させることはできません。

### Sample Explanation 3

方法の数を $ 10^9+7 $ で割った余りを出力してください。

## 样例 #1

### 输入

```
3 3```

### 输出

```
2```

## 样例 #2

### 输入

```
2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
999999 999999```

### 输出

```
151840682```

# AI分析结果



# [ABC145D] Knight 的题解翻译

## 题目描述

在二维网格的原点 $(0,0)$ 处有一个国际象棋的骑士棋子。  
骑士棋子位于 $(i,j)$ 时，只能移动到 $(i+1,j+2)$ 或 $(i+2,j+1)$ 这两个位置。  
求将骑士棋子移动到 $(X,Y)$ 的方法总数，结果对 $10^9+7$ 取模。

## 样例解释

### 样例 #1
输入：3 3  
输出：2  
路径：$(0,0)→(1,2)→(3,3)$ 和 $(0,0)→(2,1)→(3,3)$

### 样例 #2
输入：2 2  
输出：0  
说明：无法到达 $(2,2)$

### 样例 #3
输入：999999 999999  
输出：151840682

---

**算法分类**：组合数学

---

## 题解分析与结论

### 核心思路
1. **必要条件**：目标点必须满足 $(X+Y) \equiv 0 \pmod{3}$，否则无解。
2. **步数方程**：设移动 $(1,2)$ 方向 $a$ 次，移动 $(2,1)$ 方向 $b$ 次，解方程组：
   \[
   \begin{cases} 
   2a + b = X \\ 
   a + 2b = Y 
   \end{cases}
   \]
3. **组合数计算**：总步数为 $n = a + b$，在 $n$ 步中选择 $a$ 步（或 $b$ 步）的方案数，即 $C(n, a)$。

### 关键技巧
- **逆元优化**：通过费马小定理快速计算组合数的模值，避免直接阶乘计算的溢出问题。
- **逐项计算优化**：对于单次查询，通过递推计算组合数，避免预处理大数组的内存消耗。

---

## 精选题解（评分≥4星）

### 题解1：洛璟（4星）
**关键亮点**：  
- 清晰推导必要条件与组合数公式  
- 使用逐项计算组合数，节省内存  
- 注意数据类型选择（unsigned long long 防溢出）

**核心代码**：
```cpp
int C(int n, int m) {
    if (n < m) return 0;
    int ans = 1;
    for (int i=1; i<=m; i++) {
        ans = (ans * (n - m + i) % mo * Pow(i, mo - 2) % mo) % mo;
    }
    return ans;
}
```

### 题解2：Escapism（4星）
**关键亮点**：  
- 简洁的条件判断实现  
- 与数学推导紧密结合  
- 快速幂模板化便于复用

**核心代码**：
```cpp
ull Pow(ull k, ull base) {
    ull ans = 1;
    while (base > 0) {
        if (base & 1) ans = ans * k % MOD;
        k = k * k % MOD;
        base >>= 1;
    }
    return ans;
}
```

### 题解3：shenmadongdong（4星）
**关键亮点**：  
- 预处理阶乘与逆元，加速多次组合数查询  
- 边界条件处理完整  
- 代码结构高度模块化

**核心代码**：
```cpp
long long ksm(long long x, long long y) {
    long long ret = 1;
    while (y) {
        if (y & 1) ret = ret * x % mod;
        y >>= 1; x = x * x % mod;
    }
    return ret;
}
```

---

## 同类题目推荐
1. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)  
2. [P3197 [HNOI2008] 越狱](https://www.luogu.com.cn/problem/P3197)  
3. [P1313 [NOIP2011 提高组] 计算系数](https://www.luogu.com.cn/problem/P1313)  

---

**个人心得总结**：
- 调试时需特别注意数据溢出，选择 `unsigned long long` 更为安全。
- 预处理阶乘数组时需准确估算最大范围，避免内存浪费或越界。
- 组合数问题中，逆元与快速幂是核心优化手段，需熟练掌握。

---
处理用时：74.98秒
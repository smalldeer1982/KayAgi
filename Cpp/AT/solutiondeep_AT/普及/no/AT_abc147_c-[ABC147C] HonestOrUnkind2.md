# 题目信息

# [ABC147C] HonestOrUnkind2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc147/tasks/abc147_c

$ 1 $ から $ N $ までの番号がついた $ N $ 人の人がいます。彼らはみな、必ず正しい証言を行う「正直者」か、真偽不明の証言を行う「不親切な人」のいずれかです。

人 $ i $ は $ A_i $ 個の証言を行っています。人 $ i $ の $ j $ 個目の証言は $ 2 $ つの整数 $ x_{ij} $ , $ y_{ij} $ で表され、$ y_{ij}\ =\ 1 $ のときは「人 $ x_{ij} $ は正直者である」という証言であり、$ y_{ij}\ =\ 0 $ のときは「人 $ x_{ij} $ は不親切な人である」という証言です。

この $ N $ 人の中には最大で何人の正直者が存在し得るでしょうか？

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ <\ =\ N\ <\ =\ 15 $
- $ 0\ \leq\ A_i\ \leq\ N\ -\ 1 $
- $ 1\ \leq\ x_{ij}\ \leq\ N $
- $ x_{ij}\ \neq\ i $
- $ x_{ij_1}\ \neq\ x_{ij_2}\ (j_1\ \neq\ j_2) $
- $ y_{ij}\ =\ 0,\ 1 $

### Sample Explanation 1

人 $ 1 $ と人 $ 2 $ が正直者であり、人 $ 3 $ が不親切な人であると仮定すると、正直者は $ 2 $ 人であり、矛盾が生じません。これが存在し得る正直者の最大人数です。

### Sample Explanation 2

$ 1 $ 人でも正直者が存在すると仮定すると、直ちに矛盾します。

## 样例 #1

### 输入

```
3

1

2 1

1

1 1

1

2 0```

### 输出

```
2```

## 样例 #2

### 输入

```
3

2

2 1

3 0

2

3 1

1 0

2

1 1

2 0```

### 输出

```
0```

## 样例 #3

### 输入

```
2

1

2 0

1

1 0```

### 输出

```
1```

# AI分析结果



# [ABC147C] HonestOrUnkind2 的中文翻译

## 题目描述

编号为 $1$ 到 $N$ 的 $N$ 个人中，每个人要么是只说真话的「诚实者」，要么是可能说假话的「不亲切者」。每个人 $i$ 给出 $A_i$ 条证言，每条证言形如 $(x_{ij}, y_{ij})$。若 $y_{ij}=1$，表示「人 $x_{ij}$ 是诚实者」；若 $y_{ij}=0$，表示「人 $x_{ij}$ 是不亲切者」。求可能存在的最大诚实者人数。

## 算法分类
深度优先搜索 DFS

## 题解分析与结论

### 关键思路
1. **状态枚举**：由于 $N \leq 15$，可以暴力枚举所有可能的诚实者组合（共 $2^{15}$ 种情况）。
2. **矛盾检测**：对每个假设的诚实者集合，验证所有诚实者的证言是否与当前假设一致。若所有证言均无矛盾，则该状态有效。
3. **最优解维护**：在所有有效状态中，统计诚实者人数的最大值。

### 解决难点
- **证言逻辑处理**：诚实者的证言必须全部成立，而不亲切者的证言无需考虑。
- **高效验证**：对每个枚举状态，需快速检测证言是否矛盾。通过遍历所有诚实者的所有证言，判断其是否符合当前假设状态。

---

## 精选题解

### 题解1：HoshizoraZ（4星）
**亮点**：清晰的DFS框架与验证逻辑  
**代码核心**：
```cpp
void check(){
    memset(bb, -1, sizeof(bb));
    for(int i = 1; i <= n; i++)
        if(b[i] == 1)  // 当前人为诚实者
            for(int j = 1; j <= a[i]; j++)
                if(b[x[i][j]] != y[i][j]) return; // 发现矛盾
    ans = max(ans, 累计诚实人数);
}
```
DFS生成所有可能状态，`check`函数验证所有诚实者证言的一致性。

### 题解2：Otomachi_Una_（5星）
**亮点**：极简实现与直接验证  
**代码核心**：
```cpp
bool calc(){
    for(int i=1;i<=n;i++)
        if(f[i]==1)  // 当前人为诚实者
            for(int j=1;j<=a[i];j++)
                if(f[x[i][j]] != y[i][j]) return false;
    return true;
}
```
DFS生成状态后，直接遍历每个诚实者的证言进行验证，代码简洁高效。

---

## 关键技巧总结
- **二进制状态表示**：用整数位或数组表示诚实者集合。
- **剪枝优化**：DFS枚举时，遇到矛盾可提前回溯。
- **分离验证逻辑**：将状态验证独立为单独函数，提升代码可读性。

---

## 同类题目推荐
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)（DFS枚举组合）
2. [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)（状态枚举）
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)（DFS+剪枝）

---
处理用时：152.73秒
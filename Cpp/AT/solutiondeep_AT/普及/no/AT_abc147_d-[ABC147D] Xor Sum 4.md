# 题目信息

# [ABC147D] Xor Sum 4

## 题目描述

给出 $n$ 个整数 $a_i$，请求出 $\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}(a_i \operatorname{xor}a_j)$ 对 $10^9 + 7$ 取模的值。

## 说明/提示

$2 \le n \le 3 \times 10 ^ 5, 0 \le a_i \le 2^{60}$。

## 样例 #1

### 输入

```
3

1 2 3```

### 输出

```
6```

## 样例 #2

### 输入

```
10

3 1 4 1 5 9 2 6 5 3```

### 输出

```
237```

## 样例 #3

### 输入

```
10

3 14 159 2653 58979 323846 2643383 27950288 419716939 9375105820```

### 输出

```
103715602```

# AI分析结果



题目内容已翻译为中文：

# [ABC147D] Xor Sum 4

## 题目描述

给出 $n$ 个整数 $a_i$，请求出 $\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}(a_i \operatorname{xor}a_j)$ 对 $10^9 + 7$ 取模的值。

## 说明/提示

$2 \le n \le 3 \times 10 ^ 5, 0 \le a_i \le 2^{60}$。

---

**算法分类**：位运算、数学

---

### 题解综合分析

题目核心在于利用异或的**按位独立性**，逐位计算贡献。所有题解均围绕以下核心思路展开：
1. **按位统计**：统计每个二进制位上 $1$ 的出现次数。
2. **贡献计算**：对于每一位 $k$，其总贡献为 $cnt_k \times (n-cnt_k) \times 2^k$，其中 $cnt_k$ 是该位为 $1$ 的数的个数。

---

### 精选题解（评分≥4星）

#### 1. 洛璟的题解（4星）
**关键亮点**：
- 代码简洁，直接按位统计每个数的二进制位。
- 通过预处理每位 $1$ 的总数，统一计算贡献。
**实现思路**：
1. 遍历所有数，统计每位 $1$ 的出现次数。
2. 遍历每位，利用乘法原理计算该位总贡献。
**代码核心**：
```cpp
for (int i = 1, j = 1; i <= 60; i++, j = (j << 1) % mod) {
    ans = (ans + f[i] % mod * (n - f[i]) % mod * j % mod) % mod;
}
```

#### 2. RainFestival的题解（5星）
**关键亮点**：
- 正确处理所有二进制位（0到60位），避免高位遗漏。
- 动态维护剩余 $1$ 和 $0$ 的个数，精确计算每个数的贡献。
**实现思路**：
1. 对每位 $k$，统计初始 $1$ 和 $0$ 的总数。
2. 逐个处理每个数，更新剩余 $1$ 和 $0$ 的个数，累加贡献。
**代码核心**：
```cpp
for (int k = 0; k <= 60; k++) {
    int x = 0, y = 0, cnt = 0;
    for (int i = 1; i <= n; i++) 
        if (f[i] & (1ll << k)) ++x; else ++y;
    for (int i = 1; i <= n; i++) 
        if (f[i] & (1ll << k)) 
            cnt = (cnt + y) % mod, --x; 
        else 
            cnt = (cnt + x) % mod, --y;
    ans = (ans + (1ll << k) % mod * cnt % mod) % mod;
}
```

#### 3. 极寒神冰的题解（4星）
**关键亮点**：
- 动态维护剩余数的位信息，避免重复统计。
- 预处理总位数后逐个修正贡献。
**实现思路**：
1. 预处理所有数的二进制位统计。
2. 逐个处理每个数，扣除自身贡献后，计算剩余数的异或贡献。
**代码核心**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= 61; j++) 
        if (a[i] & (1ll << j)) BT[j]--;
    for (int j = 0; j <= 61; j++) 
        if (a[i] & (1ll << j)) 
            res += (1ll << j) % mod * (n - i - BT[j]) % mod;
        else 
            res += (1ll << j) % mod * BT[j] % mod;
}
```

---

### 最优思路总结
**核心技巧**：
- **位独立性**：异或运算每位独立，可逐位计算总贡献。
- **乘法原理**：每位贡献由 $1$ 和 $0$ 的配对数量决定。
- **二进制转十进制**：每位贡献需乘以其权值 $2^k$。

**注意点**：
- 必须处理所有可能的二进制位（0到60），避免高位遗漏。
- 使用长整型存储中间结果，防止溢出。

---

### 拓展练习
1. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)  
   **考察点**：位运算贪心策略。
2. [P1582 倒水](https://www.luogu.com.cn/problem/P1582)  
   **考察点**：二进制位处理与最少操作。
3. [P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)  
   **考察点**：异或性质与区间查询。

---
处理用时：247.22秒
# 题目信息

# [ABC149D] Prediction and Restriction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc149/tasks/abc149_d

高橋君は、ゲームセンターで「じゃんけんバトル」というゲームをプレイすることにしました。このゲームのルールは以下の通りです。

- プレイヤーは筐体と $ N $ 回じゃんけんを行う (あいこの場合も $ 1 $ 回のジャンケンと数える)。
- プレイヤーがじゃんけんで勝った場合、プレイヤーは出した手に応じて以下のスコアを得る (あいこや負けは $ 0 $ 点)。
  - グーで勝った場合、 $ R $ 点
  - チョキで勝った場合、 $ S $ 点
  - パーで勝った場合、 $ P $ 点
- ただし、ちょうど $ K $ 回前のじゃんけんで出した手と同じ手を出すことはできない。( $ K $ 回目までのじゃんけんでは好きな手を出せる。)

筐体は、各回のジャンケンで出す手をゲーム開始前に決定します。能力者である高橋君は、ゲーム開始前にこれをすべて読み取りました。

高橋君が読み取った情報は文字列 $ T $ として与えられます。$ T $ の $ i(1\ \leq\ i\ \leq\ N) $ 文字目が `r` のときは $ i $ 回目のじゃんけんで筐体がグーを出すことを、`s` のときはチョキを出すことを、`p` のときはパーを出すことを表します。

高橋君が $ N $ 回のじゃんけんで出す手を最適に選んだとき、ゲーム終了までに最大で合計何点を得られるでしょうか。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N-1 $
- $ 1\ \leq\ R,S,P\ \leq\ 10^4 $
- $ N,K,R,S,P $ は全て整数である。
- $ |T|\ =\ N $
- $ T $ に含まれる文字は `r` , `s` , `p` のいずれかである。

### Sample Explanation 1

筐体は、{グー、チョキ、グー、パー、グー} と手を出します。 これに対して、例えば {パー、グー、グー、チョキ、パー} と出せば、$ 27 $ 点を獲得できます。 これより大きい点は獲得できないので、$ 27 $ を出力します。

## 样例 #1

### 输入

```
5 2

8 7 6

rsrpr```

### 输出

```
27```

## 样例 #2

### 输入

```
7 1

100 10 1

ssssppr```

### 输出

```
211```

## 样例 #3

### 输入

```
30 5

325 234 123

rspsspspsrpspsppprpsprpssprpsr```

### 输出

```
4996```

# AI分析结果



### 题目重写

[ABC149D] 预测与限制

#### 题目描述

高桥君在游戏中心玩“猜拳对战”游戏，规则如下：

- 玩家与机器进行 $N$ 次猜拳（平局也算一次）。
- 玩家获胜时可获得分数：石头（R 分）、剪刀（S 分）、布（P 分）。
- 第 $i$ 次出拳不能与第 $i-K$ 次相同（$i>K$）。

已知机器的出拳序列 $T$，求玩家能获得的最大分数。

#### 输入格式
输入包括 $N, K, R, S, P$ 和字符串 $T$，其中 $T$ 的第 $i$ 个字符表示机器在第 $i$ 次出的手势（'r' 为石头，'s' 为剪刀，'p' 为布）。

---

### 算法分类
**贪心** 或 **动态规划**

---

### 题解对比与总结

#### 核心思路
1. **贪心策略**：将序列拆分为 $K$ 个独立子序列，每个子序列中处理连续的相同手势块。对于每个块，若当前手势与前 $K$ 次冲突（且前 $K$ 次已得分），则跳过本次得分。
2. **动态规划**：对每个子序列单独处理，维护三种状态（出石头、剪刀、布），通过状态转移确保不违反 $K$ 次限制，求最大得分。

#### 解决难点
- **贪心**需正确处理连续块的得分间隔，确保每次得分不冲突。
- **动态规划**需高效处理状态转移，仅依赖前 $K$ 次的状态。

---

### 高分题解推荐

#### 1. Chinese_zjc_ 的解法（★★★★★）
**关键思路**：动态规划分治。
- 将序列拆分为 $K$ 个独立子序列。
- 对每个子序列，维护三个状态（石头、剪刀、布），状态转移时取前 $K$ 次非当前选择的最大值。
- 时间复杂度 $O(N)$，空间复杂度 $O(N)$。

**核心代码**：
```cpp
for (int i = 1; i <= k; ++i) {
    // 初始化前 K 次的状态
    for (int j = i + k; j <= n; j += k) {
        if (a[j] == 0) { // 对手出石头
            dp[0][j] = max(dp[1][j - k], dp[2][j - k]) + p;
            dp[1][j] = max(dp[0][j - k], dp[2][j - k]);
            dp[2][j] = max(dp[0][j - k], dp[1][j - k]);
        }
        // 类似处理剪刀、布的情况
    }
}
```

#### 2. Sirkey 的解法（★★★★☆）
**关键思路**：贪心标记冲突。
- 用数组 `anss` 记录是否得分，若当前手势与前 $K$ 次相同且前次已得分，则跳过本次。
- 时间复杂度 $O(N)$，空间复杂度 $O(N)$。

**核心代码**：
```cpp
FOR(i, 0, n - 1) {
    if (i < k) {
        // 前 K 次直接得分
    } else {
        if (st[i] == st[i - k]) {
            if (anss[i - k] == 0) {
                // 当前得分，标记为 1
            } else {
                anss[i] = 0; // 跳过
            }
        } else {
            // 直接得分
        }
    }
}
```

---

### 拓展与总结

#### 关键技巧
- **分治处理**：将问题拆分为独立子序列，简化状态转移。
- **状态压缩**：动态规划中仅需维护前 $K$ 次的状态，降低空间复杂度。

#### 类似题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心）
2. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)（区间 DP）
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（动态规划基础）

---
处理用时：137.97秒
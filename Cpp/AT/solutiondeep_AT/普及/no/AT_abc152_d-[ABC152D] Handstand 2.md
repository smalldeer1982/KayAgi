# 题目信息

# [ABC152D] Handstand 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc152/tasks/abc152_d

正の整数 $ N $ が与えられます。  
 $ N $ 以下の正の整数の組 $ (A,B) $ であって、次の条件を満たすものの個数を求めてください。

- $ A,B $ を先頭に $ 0 $ のつかない $ 10 $ 進数表記で表したときに、 $ A $ の末尾の桁が $ B $ の先頭の桁に等しく、 $ A $ の先頭の桁が $ B $ の末尾の桁に等しい

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- 入力はすべて整数である。

### Sample Explanation 1

条件を満たす正の整数の組 $ (A,B) $ は、 $ (1,1) $, $ (1,11) $, $ (2,2) $, $ (2,22) $, $ (3,3) $, $ (4,4) $, $ (5,5) $, $ (6,6) $, $ (7,7) $, $ (8,8) $, $ (9,9) $, $ (11,1) $, $ (11,11) $, $ (12,21) $, $ (21,12) $, $ (22,2) $, $ (22,22) $ の $ 17 $ 個あります。

## 样例 #1

### 输入

```
25```

### 输出

```
17```

## 样例 #2

### 输入

```
1```

### 输出

```
1```

## 样例 #3

### 输入

```
100```

### 输出

```
108```

## 样例 #4

### 输入

```
2020```

### 输出

```
40812```

## 样例 #5

### 输入

```
200000```

### 输出

```
400000008```

# AI分析结果



# [ABC152D] Handstand 2

## 题目描述

给定正整数 $N$，统计满足以下条件的正整数对 $(A,B)$ 的数量：

- $A$ 的末尾数字等于 $B$ 的开头数字，且 $A$ 的开头数字等于 $B$ 的末尾数字（均不含前导零）。

## 算法分类
**枚举**  
（通过预处理首位末位组合，利用桶统计优化计算）

---

## 题解分析与结论

### 核心思路
1. **特征提取**：仅需关注数字的首位和末位，中间数字不影响条件。
2. **桶统计**：用二维数组 `cnt[i][j]` 记录首位为 `i`、末位为 `j` 的数字数量。
3. **组合计算**：最终答案为所有 `cnt[i][j] * cnt[j][i]` 的和，表示首位末位互补的对数。

### 最优题解亮点

#### 1. [作者：__Octhyccc__] ⭐⭐⭐⭐⭐
**核心思路**  
- 直接遍历每个数，统计首位末位组合的频次。
- 遍历所有可能的首尾组合，乘积求和得到答案。

**代码亮点**  
```cpp
#include<cstdio>
int a[10][10],n,cnt;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int las,now=i;
        las=now%10;            // 取末位
        while(now>=10)now/=10; // 取首位
        a[now][las]++;
    }
    for(int i=0;i<=9;i++)       // 计算所有组合贡献
        for(int j=0;j<=9;j++)
            cnt+=a[i][j]*a[j][i];
    printf("%d",cnt);
    return 0;
}
```
- **简洁高效**：10x10 的桶统计，空间复杂度极低。
- **无冗余操作**：直接遍历数字处理，无需额外存储。

#### 2. [作者：yzm0325] ⭐⭐⭐⭐⭐
**核心思路**  
- 预处理首位末位，直接计算二维数组的乘积和。

**代码亮点**  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, t[10][10];
int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        int x = i, sw = x % 10;
        while(x >= 10) x /= 10;
        t[x][sw]++;
    }
    for(int i = 1; i <= 9; i++)
        for(int j = 1; j <= 9; j++)
            ans += t[i][j] * t[j][i];
    cout << ans;
}
```
- **逻辑清晰**：分离统计与计算阶段，代码易读。
- **高效遍历**：仅需 10² 次循环完成最终计算。

#### 3. [作者：Code_Select_You] ⭐⭐⭐⭐
**核心思路**  
- 预处理每个数的首末位，二次遍历累加对应桶值。

**代码亮点**  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n; long long ans;
int h[200010], l[200010], cnt[10][10];
int main() {
    scanf("%d", &n);
    for(int i=1; i<=n; ++i) {
        l[i] = i % 10;
        int x = i;
        while(x >= 10) x /= 10;
        h[i] = x;
        cnt[h[i]][l[i]]++;
    }
    for(int i=1; i<=n; ++i) 
        ans += cnt[l[i]][h[i]];
    printf("%lld", ans);
    return 0;
}
```
- **显式预处理**：首末位存储增强可读性。
- **线性复杂度**：两次遍历，适合数据敏感场景。

---

## 关键技巧总结
- **特征提取**：识别问题中的关键特征（如首末位）可大幅简化计算。
- **桶统计优化**：通过固定维度的桶减少时间复杂度至线性。
- **数学组合**：利用乘积和直接计算对称组合数。

## 拓展练习
1. [CF177B2 - Rectangular Game](https://codeforces.com/problemset/problem/177/B2)（桶统计优化）
2. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)（桶统计与差值配对）
3. [ABC202D - aab aba baa](https://atcoder.jp/contests/abc202/tasks/abc202_d)（组合数学与特征映射）

---
处理用时：215.88秒
# 题目信息

# [ABC153E] Crested Ibis vs Monster

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc153/tasks/abc153_e

トキはモンスターと戦っています。

モンスターの体力は $ H $ です。

トキは $ N $ 種類の魔法が使え、$ i $ 番目の魔法を使うと、モンスターの体力を $ A_i $ 減らすことができますが、トキの魔力を $ B_i $ 消耗します。

同じ魔法は何度でも使うことができます。魔法以外の方法でモンスターの体力を減らすことはできません。

モンスターの体力を $ 0 $ 以下にすればトキの勝ちです。

トキがモンスターに勝つまでに消耗する魔力の合計の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 10^4 $
- $ 1\ \leq\ N\ \leq\ 10^3 $
- $ 1\ \leq\ A_i\ \leq\ 10^4 $
- $ 1\ \leq\ B_i\ \leq\ 10^4 $
- 入力中のすべての値は整数である。

### Sample Explanation 1

最初に $ 1 $ 番目の魔法を使い、トキの魔力を $ 3 $ 消耗して、モンスターの体力を $ 8 $ 減らします。モンスターの体力は $ 1 $ になります。 次に $ 3 $ 番目の魔法を使い、トキの魔力を $ 1 $ 消耗して、モンスターの体力を $ 2 $ 減らします。モンスターの体力は $ -1 $ になります。 これにより、トキが消耗した魔力の合計は $ 4 $ になります。

### Sample Explanation 2

$ 1 $ 番目の魔法を $ 100 $ 回使うのが最適です。

## 样例 #1

### 输入

```
9 3

8 3

4 2

2 1```

### 输出

```
4```

## 样例 #2

### 输入

```
100 6

1 1

2 3

3 9

4 27

5 81

6 243```

### 输出

```
100```

## 样例 #3

### 输入

```
9999 10

540 7550

691 9680

700 9790

510 7150

415 5818

551 7712

587 8227

619 8671

588 8228

176 2461```

### 输出

```
139815```

# AI分析结果



【中文重写题目】

# [ABC153E] 朱鹭与怪物之战

## 题目描述

朱鹭正在与一只怪物战斗。怪物的体力为 $ H $。

朱鹭可以使用 $ N $ 种魔法，第 $ i $ 种魔法每次使用可减少怪物体力 $ A_i $，但会消耗 $ B_i $ 点魔力。每种魔法可以重复使用。

当怪物体力降至 $ 0 $ 或以下时朱鹭获胜。求朱鹭获胜所需的最小魔力消耗。

## 输入格式
输入包含：
- 第一行：两个整数 $ H $ 和 $ N $
- 接下来 $ N $ 行：每行两个整数 $ A_i $ 和 $ B_i $

## 输出格式
输出最小魔力值。

## 数据范围
- $ 1 \leq H \leq 10^4 $
- $ 1 \leq N \leq 10^3 $
- $ 1 \leq A_i, B_i \leq 10^4 $

【算法分类】动态规划

---

### 题解分析与结论

#### 核心思路
该问题属于**完全背包**的变种，需满足背包容量至少为 $ H $ 的最小价值。动态规划状态定义为 $ dp[i] $ 表示造成 $ i $ 点伤害的最小魔力消耗。关键点包括：
1. **状态转移**：$ dp[j] = \min(dp[j], dp[j - A_i] + B_i) $，采用正序更新以支持重复使用魔法
2. **枚举范围**：需计算至 $ H + \max(A_i) $ 或足够大的安全值（如20000），以处理超额伤害更优的情况
3. **结果选取**：最终在 $ [H, Max] $ 范围内取最小值

#### 精选题解（评分≥4★）

1. **CQ_Bab（4★）**
- 亮点：标准的完全背包实现，清晰的状态转移逻辑
- 代码核心：
```cpp
memset(f, 0x3f, sizeof f);
f[0] = 0;
for(int i=1;i<=n;i++)
    for(int j=a[i];j<=Max;j++) 
        f[j] = min(f[j], f[j-a[i]]+b[i]);
```

2. **AlicX（4★）**
- 亮点：代码规范，变量命名清晰，包含详细注释
- 关键实现：
```cpp
memset(f,0x3f,sizeof f);
f[0]=0;
for(int i=1;i<=n;i++) 
    for(int j=a[i];j<N;j++)
        f[j] = min(f[j], f[j-a[i]]+b[i]);
```

3. **Otomachi_Una_（4★）**
- 亮点：代码简洁高效，预处理初始化合理
- 核心片段：
```cpp
for(int i=1;i<MAXN;i++) f[i]=1e9;
while(n--){
    cin>>a>>b;
    for(int i=a;i<MAXN;i++)
        f[i]=min(f[i],f[i-a]+b);
}
```

#### 关键技巧总结
1. **完全背包正序更新**：允许物品无限次使用
2. **超额伤害处理**：通过扩大计算范围（如20000）确保最优解
3. **状态初始化**：初始值设为极大值（`0x3f3f3f3f`），边界条件 `dp[0]=0`

#### 拓展建议
类似题型可考虑：
- 完全背包标准型（如洛谷P1616）
- 超额满足型动态规划（如洛谷P2918）

#### 推荐练习题
1. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)（完全背包模板）
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（01背包基础）
3. [P2918 Buy Hay 买干草](https://www.luogu.com.cn/problem/P2918)（同类型超额消耗问题）

#### 题解心得摘录
- **CQ_Bab**：强调需从`H`开始向上寻找最优解，避免遗漏超额伤害更优的情况
- **AlicX**：注释提醒"要求最小值，所以赋为正无穷"，强调初始化重要性
- **StarPatrick**：尝试记忆化搜索但效率较低，验证了动态规划的正统解法优势

---
处理用时：53.32秒
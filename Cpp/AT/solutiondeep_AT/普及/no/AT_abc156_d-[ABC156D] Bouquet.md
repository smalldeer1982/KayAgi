# 题目信息

# [ABC156D] Bouquet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc156/tasks/abc156_d

あかりさんは $ n $ 種類の花を $ 1 $ 本ずつ持っています。

あかりさんは、これらの花から $ 1 $ 本以上を選び、花束を作ろうとしています。

ただし、あかりさんは $ a $ と $ b $ の $ 2 $ つの数を苦手としていて、いずれかと一致するような本数の花からなる花束は作ることができません。

あかりさんが作ることのできる花束は何種類あるでしょうか。

$ (10^9\ +\ 7) $ で割った余りを求めてください。

ここで $ 2 $ つの花束は、一方では使われているが、 もう一方では使われていない種類の花があるとき、別の種類の花束であるとみなします。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ n\ \leq\ 10^9 $
- $ 1\ \leq\ a\ <\ b\ \leq\ \textrm{min}(n,\ 2\ \times\ 10^5) $

### Sample Explanation 1

この場合、あかりさんは $ 2 $ 本または $ 4 $ 本の花を選んで花束を作ることができます。 $ 4 $ 本ある花の中から $ 2 $ 本を選ぶ方法は $ 6 $ 通り、$ 4 $ 本を選ぶ方法は $ 1 $ 通りあるので、 あかりさんが作ることができる花束の種類数は合わせて $ 7 $ 通りです。

### Sample Explanation 2

$ (10^9\ +\ 7) $ で割った余りを出力してください。

## 样例 #1

### 输入

```
4 1 3```

### 输出

```
7```

## 样例 #2

### 输入

```
1000000000 141421 173205```

### 输出

```
34076506```

# AI分析结果



**题目中文重写**  
[题目传送门](https://www.luogu.com.cn/problem/AT_abc156_d)  
**题目描述**  
给定 $n$ 种不同的花（每种仅1支），要求选择至少1支组成花束，但不能选恰好 $a$ 支或 $b$ 支。求合法方案数模 $10^9+7$。  
**说明/提示**  
- $2 \leq n \leq 10^9$，$1 \leq a < b \leq \min(n, 2 \times 10^5)$  
- 样例1：输入 `4 1 3`，总方案为 $2^4-1-C(4,1)-C(4,3)=7$  

**算法分类**  
组合数学  

---

### 题解综合分析  
**核心思路**  
总方案为 $2^n -1 - C(n,a) - C(n,b)$，其中：  
1. 快速幂计算 $2^n \mod (10^9+7)$  
2. 组合数 $C(n,k)$ 通过 $\frac{\prod_{i=n-k+1}^n i}{k!}$ 计算，分母用逆元处理  
3. 负数取模需多次加模数修正  

**关键技巧**  
- **组合数优化**：对 $C(n,k)=\frac{n^{\underline{k}}}{k!}$，暴力计算分子乘积，费马小定理求逆元  
- **逆元处理**：阶乘逆元预处理或实时计算  
- **负数修正**：`(ans + 3*mod) % mod` 避免负值  

---

### 优质题解推荐  
1. **Xu__（4星）**  
   **亮点**：代码简洁，组合数分步计算  
   **代码核心**：  
   ```cpp  
   int C(int n, int m, int p) {
       if (n < m) return 0;
       int ans = 1;
       for (int i = n - m + 1; i <= n; ++i) 
           ans = ans * i % p;
       return ans * Inv(Fac(m, p), p) % p;
   }
   // 主函数计算：(快速幂结果 -1 - C(n,a) - C(n,b)) % mod
   ```

2. **HoshizoraZ（4星）**  
   **亮点**：组合数推导清晰，强调递推式优化  
   **代码核心**：  
   ```cpp  
   ll solve(ll a, ll b){
       ll t = 1;
       for(ll i = a; i >= a - b + 1; i--)
           t = t * i % mod;
       return t * inv[b] % mod;
   }
   ```

3. **DengDuck（4星）**  
   **亮点**：预处理逆元数组，提高效率  
   **代码核心**：  
   ```cpp  
   for(int i=1;i<=M;i++) inv[i]=ksm(i,mod-2);
   LL C(LL n,LL m) {
       LL ans=1;
       for(int i=1;i<=m;i++)
           ans=ans*(n-m+i)%mod*inv[i]%mod;
       return ans;
   }
   ```

---

### 同类题目推荐  
1. [P3414 SAC#1 - 组合数](https://www.luogu.com.cn/problem/P3414)  
2. [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)  
3. [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)  

**个人心得摘录**  
- "注意快速幂中变量名写错导致调试困难"（Hog_Dawa_IOI）  
- "组合数分母的逆元必须整体计算，不能逐项除"（joe_zxq）  
- "多次加 mod 修正负数比取模运算更安全"（Eason_AC）

---
处理用时：49.58秒
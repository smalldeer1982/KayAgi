# 题目信息

# [ABC157D] Friend Suggestions

## 题目描述

### 题目大意

某平台上有 $N$ 名用户，其中，有 $M$ 对用户是互相关注的，有 $K$ 对用户是互相拉黑的。

当用户 $i$ 和用户 $j$ 满足以下条件时，用户 $j$ 就是用户 $i$ 的“推荐用户”：

+ 用户 $i$ 可以与 用户 $j$ 通过若干对用户的互相关注关系连接起来。（比如用户 1 与用户 2，用户 2 与用户 3 都互相关注，则用户 1 和 用户 3 就可以通过他们的关系连接起来）
+ 用户 $i$ 与用户 $j$ 没有互相关注或互相拉黑。

求每位用户的“推荐用户”的数量。

数据保证不会存在一对用户既互相关注又互相拉黑。

## 说明/提示

$2 \le N \le 10^5, 0 \le M,K \le 10^5$。

翻译 by @CarroT1212

## 样例 #1

### 输入

```
4 4 1

2 1

1 3

3 2

3 4

4 1```

### 输出

```
0 1 0 1```

## 样例 #2

### 输入

```
5 10 0

1 2

1 3

1 4

1 5

3 2

2 4

2 5

4 3

5 3

4 5```

### 输出

```
0 0 0 0 0```

## 样例 #3

### 输入

```
10 9 3

10 1

6 7

8 2

2 5

8 4

7 3

10 9

6 4

5 8

2 6

7 5

3 1```

### 输出

```
1 3 5 4 3 3 3 3 1 0```

# AI分析结果



# [ABC157D] Friend Suggestions 题目翻译

## 题目描述

### 题目大意
某平台上有 $N$ 名用户，其中，有 $M$ 对用户是互相关注的，有 $K$ 对用户是互相拉黑的。

当用户 $i$ 和用户 $j$ 满足以下条件时，用户 $j$ 就是用户 $i$ 的"推荐用户"：
1. 用户 $i$ 可以与用户 $j$ 通过若干对用户的互相关注关系连接起来
2. 用户 $i$ 与用户 $j$ 没有互相关注或互相拉黑

求每位用户的"推荐用户"的数量。数据保证不会存在一对用户既互相关注又互相拉黑。

## 算法分类
并查集

---

## 优质题解分析

### ★★★★☆ Crasole 的题解（赞2）
**关键思路**：
1. 使用并查集维护互相关注形成的连通块
2. `fore[]`数组记录各连通块大小
3. `lyg[]`数组累计每个用户的直接互关和同组拉黑关系数
4. 最终公式：推荐数 = 连通块大小 - 直接关系数 - 1（排除自己）

**代码亮点**：
```cpp
int main() {
    // 初始化并查集
    for(int i=1;i<=n;i++) f[i]=i;
    
    // 处理互相关注
    while(m--) {
        cin>>x>>y;
        f[find(x)] = find(y);
        lyg[x]++, lyg[y]++;
    }
    
    // 统计连通块大小
    for(int i=1;i<=n;i++) fore[find(i)]++;
    
    // 处理拉黑关系
    while(k--) {
        cin>>x>>y;
        if(find(x) == find(y)) lyg[x]++, lyg[y]++;
    }
    
    // 输出结果
    cout<<fore[find(i)] - lyg[i] - 1;
}
```

### ★★★★☆ CarroT1212 的题解（赞1）
**创新点**：
- 使用BFS遍历连通块
- 维护组号`gid`标记不同连通块
- 二次遍历调整互关和拉黑关系

**实现技巧**：
```cpp
void bfs(ll x) {
    vector<ll> vis; // 记录连通节点
    // BFS遍历...
    ll len = vis.size()-1;  // 排除自身
    for(auto i:vis) f[i] = len; 
}

// 处理互关和拉黑关系
for(互关关系) if同组则f[x]--,f[y]--;
for(拉黑关系) if同组则f[x]--,f[y]--;
```

### ★★★★☆ Yashajin_Ai 的题解（赞0）
**优化亮点**：
- 代码最简洁（仅20行）
- 使用单个`fa[]`数组同时记录父节点和连通块大小
- 统一处理互关和拉黑的扣除逻辑

---

## 最优解法总结
**核心公式**：
推荐数 = 连通块大小 - (直接关注数 + 同组拉黑数) - 1

**关键步骤**：
1. 并查集合并所有互关关系
2. 统计各连通块节点总数
3. 累计每个节点的直接关系数（互关+同组拉黑）
4. 最终通过公式计算推荐数

**易错点**：
- 拉黑关系只扣除同属一个连通块的情况
- 最终结果要排除自己（-1）
- 并查集需要路径压缩优化

---

## 拓展训练
相似题目推荐：
1. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551) - 基础并查集应用
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367) - 标准实现练习
3. [P4185 [USACO18JAN]MooTube G](https://www.luogu.com.cn/problem/P4185) - 带权并查集应用

**同类问题特征**：
需要处理元素分组关系，动态合并集合，并基于分组结果进行统计的问题均可考虑并查集。注意结合哈希表或辅助数组记录附加信息（如本题的连通块大小）。

---
处理用时：44.40秒
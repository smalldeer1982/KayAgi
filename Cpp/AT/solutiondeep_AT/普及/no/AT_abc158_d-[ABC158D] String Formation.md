# 题目信息

# [ABC158D] String Formation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc158/tasks/abc158_d

高橋君は、英小文字から成る文字列 $ S $ を持っています。

この $ S $ から始めて、ある与えられた手順に従って文字列を作ることにしました。

手順は $ Q $ 回の操作から成ります。操作 $ i(1\ \leq\ i\ \leq\ Q) $ では、まず整数 $ T_i $ が与えられます。

- $ T_i\ =\ 1 $ のとき : 文字列 $ S $ の前後を反転する。
- $ T_i\ =\ 2 $ のとき : 追加で整数 $ F_i $ と英小文字 $ C_i $ が与えられる。
  
  
  - $ F_i\ =\ 1 $ のとき : 文字列 $ S $ の先頭に $ C_i $ を追加する。
  - $ F_i\ =\ 2 $ のとき : 文字列 $ S $ の末尾に $ C_i $ を追加する。

高橋君のために、手順の後に最終的にできる文字列を求めてあげてください。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 10^5 $
- $ S $ は英小文字から成る
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ T_i\ =\ 1 $ または $ 2 $
- $ F_i\ =\ 1 $ または $ 2 $
- $ C_i $ は英小文字である

### Sample Explanation 1

$ Q\ =\ 4 $ 回の操作を行います。初め $ S $ は `a` です。 - 操作 $ 1 $ : $ S $ の先頭に `p` を追加する。$ S $ は `pa` となる。 - 操作 $ 2 $ : $ S $ の前後を反転する。$ S $ は `ap` となる。 - 操作 $ 3 $ : $ S $ の末尾に `c` を追加する。$ S $ は `apc` となる。 - 操作 $ 4 $ : $ S $ の前後を反転する。$ S $ は `cpa` となる。 よって最終的にできる文字列は `cpa` となります。

### Sample Explanation 2

$ Q\ =\ 6 $ 回の操作を行います。初め $ S $ は `a` です。 - 操作 $ 1 $ : $ S $ は `aa` となる。 - 操作 $ 2 $ : $ S $ は `baa` となる。 - 操作 $ 3 $ : $ S $ は `aab` となる。 - 操作 $ 4 $ : $ S $ は `aabc` となる。 - 操作 $ 5 $ : $ S $ は `cbaa` となる。 - 操作 $ 6 $ : $ S $ は `aabc` となる。 よって最終的にできる文字列は `aabc` となります。

## 样例 #1

### 输入

```
a

4

2 1 p

1

2 2 c

1```

### 输出

```
cpa```

## 样例 #2

### 输入

```
a

6

2 2 a

2 1 b

1

2 2 c

1

1```

### 输出

```
aabc```

## 样例 #3

### 输入

```
y

1

2 1 x```

### 输出

```
xy```

# AI分析结果



# [ABC158D] 字符串构造

## 题目描述

高桥君有一个由小写字母组成的字符串 $ S $。他将根据特定操作步骤构造新字符串，操作包含反转字符串和在首尾添加字符。需输出最终字符串。

## 算法分类
模拟

---

## 题解分析

### 核心思路
维护反转标记代替实际反转操作，利用双端队列高效处理首尾插入。最终根据标记状态决定输出顺序。

### 关键优化
- 避免实际反转操作，使用标记记录当前逻辑顺序
- 插入方向根据标记动态调整，保证所有操作O(1)时间复杂度
- 最终输出时统一处理反转逻辑

---

## 精选题解

### 题解作者：Texas_the_Omertosa (⭐⭐⭐⭐⭐)
**亮点**：  
- 使用双端队列 `deque` 实现高效首尾插入
- 通过布尔标记 `fz` 智能切换插入方向
- 输出逻辑简洁清晰，处理反转仅需一次 `reverse`

**核心代码**：
```cpp
deque<char> q;
bool fz; // 反转标记

// 处理插入操作
if(fz) { // 反转状态下，插入方向取反
    if(cr==1) q.push_back(c);
    else q.push_front(c);
} else {
    if(cr==1) q.push_front(c);
    else q.push_back(c);
}

// 最终输出
if(fz) reverse(ans.begin(), ans.end());
```

### 题解作者：喵仔牛奶 (⭐⭐⭐⭐⭐)
**亮点**：  
- 位运算优化标记切换 (`f ^= 3`)
- 插入方向判断逻辑高度精简
- 代码结构紧凑，可读性极佳

**核心代码**：
```cpp
deque<char> s;
int f; // 0:正常，1:反转

// 插入方向判断
if((x ^ f) == 1) s.push_front(y);
else s.push_back(y);

// 最终处理反转
if(f) reverse(s.begin(), s.end());
```

---

## 拓展应用
类似需要高效处理动态序列反转的问题可参考：
1. [P1110 数据备份](https://www.luogu.com.cn/problem/P1110) - 双端选择动态维护
2. [P1901 发射站](https://www.luogu.com.cn/problem/P1901) - 双向处理单调栈
3. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551) - 位运算与树形结构结合

---
处理用时：48.65秒
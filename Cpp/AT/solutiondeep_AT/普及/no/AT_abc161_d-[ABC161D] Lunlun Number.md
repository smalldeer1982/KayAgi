# 题目信息

# [ABC161D] Lunlun Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc161/tasks/abc161_d

正の整数 $ X $ が以下の条件を満たすとき、 $ X $ はルンルン数であると言います。

- $ X $ を(leading zeroなしで)十進数表記した際に、隣り合うどの $ 2 $ つの桁の値についても、差の絶対値が $ 1 $ 以下

例えば、 $ 1234 $ , $ 1 $ , $ 334 $ などはルンルン数ですが、 $ 31415 $ , $ 119 $ , $ 13579 $ などはルンルン数ではありません。

正の整数 $ K $ が与えられます。小さい方から $ K $ 番目のルンルン数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ 10^5 $
- 入力はすべて整数である。

### Sample Explanation 1

小さい方から $ 15 $ 番目までのルンルン数を順に並べると、 $ 1 $, $ 2 $, $ 3 $, $ 4 $, $ 5 $, $ 6 $, $ 7 $, $ 8 $, $ 9 $, $ 10 $, $ 11 $, $ 12 $, $ 21 $, $ 22 $, $ 23 $ ですので、答えは $ 23 $ です。

### Sample Explanation 4

答えが $ 32 $ ビット符号付き整数の範囲に収まらない可能性があるので注意してください。

## 样例 #1

### 输入

```
15```

### 输出

```
23```

## 样例 #2

### 输入

```
1```

### 输出

```
1```

## 样例 #3

### 输入

```
13```

### 输出

```
21```

## 样例 #4

### 输入

```
100000```

### 输出

```
3234566667```

# AI分析结果



# [ABC161D] Lunlun Number

## 题目描述

正の整数 $ X $ が以下の条件を満たすとき、 $ X $ はルンルン数であると言います。

- $ X $ を(leading zeroなしで)十進数表記した際に、隣り合うどの $ 2 $ つの桁の値についても、差の絶対値が $ 1 $ 以下

例えば、 $ 1234 $ , $ 1 $ , $ 334 $ などはルンルン数ですが、 $ 31415 $ , $ 119 $ , $ 13579 $ などはルンルン数ではありません。

正の整数 $ K $ が与えられます。小さい方から $ K $ 番目のルンルン数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ 10^5 $
- 入力はすべて整数である。

---

**算法分类**：广度优先搜索 BFS / 队列

---

## 题解综合分析

各题解核心思路对比：
1. **BFS队列法**（SpeedStar、AmamiyaYuuko）：通过逐层生成合法数字，保证顺序性，时间复杂度 O(K)
2. **数位DP+二分**（ix35）：通过二分答案验证，理论复杂度 O(logN) 但实现复杂
3. **DFS暴力生成**（iiawaKL）：生成所有可能后排序，空间占用大不适用于大 K
4. **逐位构造法**（Meatherm、fighter）：模拟数字递增过程，逻辑复杂度较高

### 精选题解（评分≥4星）

**1. SpeedStar（5星）**
- **核心亮点**：队列层次遍历思想清晰，代码简洁高效，完美利用数字生成规律
- **代码核心**：
```cpp
queue<int> q;
for (int i = 1; i <= 9; i++) q.push(i);
while (!q.empty()) {
    int x = q.front(); q.pop(); k--;
    if (k == 0) { cout << x; break; }
    
    for (int y = (x%10)-1; y <= (x%10)+1; y++) { // 生成下一位可能值
        if (y < 0 || y > 9) continue;
        q.push(x*10 + y);
    }
}
```
- **实现要点**：每次取出队首元素后，根据末位数字生成三种可能的后继数字，天然保证生成顺序

**2. AmamiyaYuuko（4.5星）**
- **亮点**：思路与上解一致，代码稍作变体但同样高效
- **个人心得**：明确提到"末尾的数的大小决定下一数字"，点破问题关键

---

## 最优思路总结
**关键技巧**：将数字视为节点，末位数字视为状态，使用队列进行层次遍历。每个数字生成新节点时，仅需基于末位数字 ±1 生成子节点，天然满足相邻数字差条件，保证生成序列的严格有序性。

---

## 拓展应用
类似问题可使用BFS按规则生成序列：
1. 生成所有不含相邻重复字符的字符串
2. 构造满足特定递增规则的数字序列
3. 状态空间中的最短路径问题

---

## 推荐习题
1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - BFS思想扩展
2. [P1583 队列操作](https://www.luogu.com.cn/problem/P1583) - 队列基础应用
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 组合生成与验证

---
处理用时：60.74秒
# 题目信息

# [ABC162F] Select Half

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc162/tasks/abc162_f

長さ $ N $ の整数列 $ A_1,...,A_N $ が与えられます。

この中からちょうど $ \left\lfloor\ \frac{N}{2}\ \right\rfloor $ 個の整数を、どの $ 2 $ 箇所も連続しないように選びます。

選んだ要素の和としてありえる最大値を求めてください。

ここで、$ \lfloor\ x\ \rfloor $ は、$ x $ を超えない最大の整数を表します。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ |A_i|\leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

$ 2,4,6 $ を選ぶと和は $ 12 $ となり、これが最大です。

### Sample Explanation 2

$ -10,10 $ を選ぶと和は $ 0 $ となり、これが最大です。

### Sample Explanation 3

オーバーフローに注意してください。

## 样例 #1

### 输入

```
6

1 2 3 4 5 6```

### 输出

```
12```

## 样例 #2

### 输入

```
5

-1000 -100 -10 0 10```

### 输出

```
0```

## 样例 #3

### 输入

```
10

1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
5000000000```

## 样例 #4

### 输入

```
27

18 -28 18 28 -45 90 -45 23 -53 60 28 -74 -71 35 -26 -62 49 -77 57 24 -70 -93 69 -99 59 57 -49```

### 输出

```
295```

# AI分析结果



# 题目中文翻译

## 题目描述

给定一个长度为 $N$ 的整数序列 $A_1, A_2, \dots, A_N$。从中选出恰好 $\left\lfloor \frac{N}{2} \right\rfloor$ 个数，且这些数两两不相邻。求所选数的最大可能和。

## 输入格式

第一行输入整数 $N$，第二行输入 $N$ 个整数 $A_1, A_2, \dots, A_N$。

## 输出格式

输出最大和。

## 说明/提示

- $2 \leq N \leq 2 \times 10^5$
- $|A_i| \leq 10^9$

---

**算法分类**：动态规划

---

### 题解对比与总结

#### 核心思路
动态规划是主要解法。关键点在于分奇偶讨论状态转移：
- **偶数位置**：选当前数则取前 $i-2$ 的最优值，不选则取前 $i-1$ 奇数位的总和。
- **奇数位置**：选当前数取前 $i-2$ 的最优值，不选则继承前 $i-1$ 的最优值。

#### 难点对比
1. **Grisses 的题解**：通过分奇偶推导转移方程，利用前缀和优化偶数位置不选的情况。
2. **dz_ice 的题解**：将奇数情况转化为最大子段和问题，通过区间翻转调整选择。

#### 最优解结论
动态规划解法（如 Grisses 和 Otue）更直观高效，时间复杂度 $O(n)$，空间复杂度 $O(n)$。

---

### 高星题解推荐

#### 1. Grisses（5星）
**关键亮点**：
- 简洁的奇偶分类动态规划。
- 利用前缀和快速计算奇数位总和。
- 代码清晰，逻辑严谨。

**核心代码**：
```cpp
for (int i = 2; i <= n; i++) {
    if (i % 2 == 1) { // 奇数位置
        dp[i] = max(dp[i-2] + a[i], dp[i-1]);
    } else { // 偶数位置
        dp[i] = max(dp[i-2] + a[i], sum[i-1]);
    }
}
```

#### 2. Otue（4星）
**关键亮点**：
- 与 Grisses 思路一致，代码更简洁。
- 明确初始化与边界处理。

**核心代码**：
```cpp
for (int i = 2; i <= n; i++) {
    if (i % 2 == 0) { // 偶数位置
        dp[i] = max(a[i] + dp[i-2], sum[i-1]);
    } else { // 奇数位置
        dp[i] = max(a[i] + dp[i-2], dp[i-1]);
    }
}
```

---

### 关键技巧
1. **奇偶分段处理**：将序列按奇偶位置拆解，分情况讨论。
2. **前缀和优化**：预处理奇数位前缀和，避免重复计算。
3. **状态转移方程**：选/不选当前数的两种决策取最大值。

---

### 类似题目推荐
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)（树形DP，不相邻选择）
2. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230)（贪心+排序）
3. [P2280 打家劫舍](https://www.luogu.com.cn/problem/P2280)（一维DP，不相邻选择）

---

### 心得摘录
- **Grisses**：图示分段选择帮助理解转移逻辑。
- **dz_ice**：比赛时未想到DP，转而通过最大子段和另辟蹊径，体现问题转化能力。
- **通用教训**：注意开 `long long` 防止溢出（样例3提示）。

---
处理用时：58.81秒
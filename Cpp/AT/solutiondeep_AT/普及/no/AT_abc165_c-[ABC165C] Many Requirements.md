# 题目信息

# [ABC165C] Many Requirements

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc165/tasks/abc165_c

正整数 $ N $ , $ M $ , $ Q $ と、$ 4 $ つの整数の組 ( $ a_i $ , $ b_i $ , $ c_i $ , $ d_i $ ) $ Q $ 組が与えられます。

以下の条件を満たす数列 $ A $ を考えます。

- $ A $ は、長さ $ N $ の正整数列である。
- $ 1\ \leq\ A_1\ \leq\ A_2\ \le\ \cdots\ \leq\ A_N\ \leq\ M $

この数列の得点を、以下のように定めます。

- $ A_{b_i}\ -\ A_{a_i}\ =\ c_i $ を満たすような $ i $ についての、 $ d_i $ の総和 (そのような $ i $ が存在しないときは $ 0 $)

$ A $ の得点の最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ <\ =\ N\ <\ =\ 10 $
- $ 1\ \leq\ M\ \leq\ 10 $
- $ 1\ \leq\ Q\ \leq\ 50 $
- $ 1\ \leq\ a_i\ <\ b_i\ \leq\ N $ ( $ i\ =\ 1,\ 2,\ ...,\ Q $ )
- $ 0\ \leq\ c_i\ \leq\ M\ -\ 1 $ ( $ i\ =\ 1,\ 2,\ ...,\ Q $ )
- $ (a_i,\ b_i,\ c_i)\ \neq\ (a_j,\ b_j,\ c_j) $ ( $ i\ \neq\ j $ のとき)
- $ 1\ \leq\ d_i\ \leq\ 10^5 $ ( $ i\ =\ 1,\ 2,\ ...,\ Q $ )

### Sample Explanation 1

$ A\ =\ \{1,\ 3,\ 4\} $ のとき、この数列の得点は $ 110 $ となります。この条件の下では $ 110 $ より高い得点を持つ数列は存在しませんから、答えは $ 110 $ です。

## 样例 #1

### 输入

```
3 4 3

1 3 3 100

1 2 2 10

2 3 2 10```

### 输出

```
110```

## 样例 #2

### 输入

```
4 6 10

2 4 1 86568

1 4 0 90629

2 3 0 90310

3 4 1 29211

3 4 3 78537

3 4 2 8580

1 2 1 96263

1 4 2 2156

1 2 0 94325

1 4 3 94328```

### 输出

```
357500```

## 样例 #3

### 输入

```
10 10 1

1 10 9 1```

### 输出

```
1```

# AI分析结果



# [ABC165C] Many Requirements

## 题目描述

给定正整数 $N$、$M$、$Q$ 和 $Q$ 组四元组 $(a_i, b_i, c_i, d_i)$。要求构造满足以下条件的数列 $A$：
1. 长度为 $N$ 的正整数序列
2. $1 \leq A_1 \leq A_2 \leq \cdots \leq A_N \leq M$

计算数列的得分：对于满足 $A_{b_i} - A_{a_i} = c_i$ 的每个四元组，累加对应的 $d_i$。求最大得分。

## 算法分类
深度优先搜索 DFS

---

## 题解分析与结论

### 核心思路
所有题解均采用DFS暴力枚举所有可能的递增序列，时间复杂度为组合数 $C(M+N-1, N)$。关键技巧在于维护递增特性：每次递归时当前元素不小于前一个元素，最终序列生成后计算得分。

### 最优题解推荐

#### 1. YuTianQwQ 题解（★★★★☆）
**核心亮点**：
- 参数设计清晰（n表示当前处理位置，m表示允许的最小值）
- 使用全局数组存储当前序列，避免频繁传参
- 输入预处理时将a[i],b[i]转换为0-based索引
```cpp
void dfs(int n,int m) {
    if(n == N) {
        int tmp = 0;
        for(int i=0;i<Q;i++)
            if(A[b[i]] - A[a[i]] == c[i]) tmp += d[i];
        ans = max(ans, tmp);
        return;
    }
    for(int i=m; i<=M; i++) { // 从m开始保证递增
        A[n] = i;
        dfs(n+1, i);
    }
}
```

#### 2. flysfy_LJX 题解（★★★★☆）
**核心亮点**：
- 显式处理ans[0]=1的初始条件
- 回溯步骤清晰可见
- 使用step参数逐步构建序列
```cpp
void dfs(int step) {
    if(step == n+1) {
        int sum = 0;
        for(int i=1;i<=q;i++)
            if(ans[a[i][2]]-ans[a[i][1]]==a[i][3]) sum+=a[i][4];
        maxx = max(maxx, sum);
        return;
    }
    for(int i=ans[step-1]; i<=m; i++) { // 从上一个值开始
        ans[step] = i;
        dfs(step+1);
        ans[step] = 0; // 回溯
    }
}
```

#### 3. PikachuQAQ 题解（★★★☆☆）
**核心亮点**：
- 使用vector存储当前序列
- 利用尾元素直接控制递增
```cpp
void dfs() {
    if(v.size() > n) {
        // 计算得分
        return;
    }
    for(int i=v.back(); i<=m; i++) { // 通过尾元素控制递增
        v.push_back(i);
        dfs();
        v.pop_back();
    }
}
```

---

## 关键技巧总结
1. **递增序列生成**：每个元素从上一个元素的值开始枚举，保证单调性
2. **得分计算优化**：序列生成后统一遍历所有Q条件，时间复杂度O(Q)可接受
3. **回溯处理**：显式重置状态（如置零）或隐式覆盖（后值覆盖前值）

---

## 拓展训练
1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - 基础排列生成
2. [P1157 组合的输出](https://www.luogu.com.cn/problem/P1157) - 组合数生成与格式控制 
3. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 组合数应用与质数判断

---

## 调试心得摘录
1. **初始值处理**：多位作者强调设置`ans[0]=1`或`v.push_back(1)`，避免首个元素从0开始
2. **索引转换**：部分题解将输入的1-based索引转为0-based，需特别注意数组越界
3. **时间复杂度估算**：Mysterious_Cat指出最坏情况约2e9次操作，实际运行仍可通过

---
处理用时：60.91秒
# 题目信息

# [ABC167D] Teleporter

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc167/tasks/abc167_d

高橋王国には $ N $ 個の町があります。町は $ 1 $ から $ N $ まで番号が振られています。

それぞれの町にはテレポーターが $ 1 $ 台ずつ設置されています。町 $ i\ (1\ \leq\ i\ \leq\ N) $ のテレポーターの転送先は町 $ A_i $ です。

高橋王は正の整数 $ K $ が好きです。わがままな高橋王は、町 $ 1 $ から出発してテレポーターをちょうど $ K $ 回使うと、どの町に到着するかが知りたいです。

高橋王のために、これを求めるプログラムを作成してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ N $
- $ 1\ \leq\ K\ \leq\ 10^{18} $

### Sample Explanation 1

町 $ 1 $ から出発してテレポーターを $ 5 $ 回使うと、$ 1\ \to\ 3\ \to\ 4\ \to\ 1\ \to\ 3\ \to\ 4 $ と移動します。

## 样例 #1

### 输入

```
4 5

3 2 4 1```

### 输出

```
4```

## 样例 #2

### 输入

```
6 727202214173249351

6 5 2 5 3 2```

### 输出

```
2```

# AI分析结果



# [ABC167D] Teleporter 传送器

## 题目描述

高桥王国包含 $ N $ 个编号为 $ 1 $ 至 $ N $ 的城镇。每个城镇都有一个传送器，位于城镇 $ i $ 的传送器会将使用者传送到城镇 $ A_i $。高桥王想知道从城镇 $ 1 $ 出发，使用传送器恰好 $ K $ 次后会到达哪个城镇。

### 输入格式
- 第一行两个整数 $ N $ 和 $ K $
- 第二行 $ N $ 个整数表示 $ A_1 \sim A_N $

### 输出格式
- 最终到达的城镇编号

### 数据范围
- $ 2 \leq N \leq 2 \times 10^5 $
- $ 1 \leq K \leq 10^{18} $

---

**算法分类**: 数学（循环节检测）

---

## 题解综合分析

所有题解的核心思路都是通过检测传送路径中的循环节来优化计算。主要解法分为两类：

1. **路径记录法**（BetaCutS、liangbowen等）：
   - 记录每次访问的城镇及首次访问时间
   - 当重复访问城镇时计算循环周期
   - 通过取模运算快速定位最终位置

2. **数学优化法**（倍增法、龟兔赛跑法）：
   - 倍增法通过预处理跳跃表加速计算
   - 龟兔赛跑法（Floyd判圈法）高效检测循环起点

---

## 精选题解（评分≥4星）

### 题解1：BetaCutS（⭐⭐⭐⭐⭐）
**核心亮点**：
- 代码极其简洁（仅17行）
- 动态检测循环节，无需预处理
- 使用时间差直接计算周期
- 高效处理未进入循环的情况

```cpp
int n,m,a[N],vis[N],b[N],len,d;
void solve()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=0,j=1;;i++,j=a[j]) {
        if(i==m||d&&i%d==m%d) 
            write(j),exit(0);
        if(vis[j]) d=i-vis[j];
        vis[j]=i,b[len++]=j;
    }
}
```

### 题解2：liangbowen（⭐⭐⭐⭐⭐）
**核心亮点**：
- 使用dfn数组记录首次访问时间
- 实时计算剩余跳跃次数
- 处理循环前路径与循环节的无缝衔接

```cpp
int a[N], dfn[N];
int main() {
    int n; ll k;
    scanf("%d%lld", &n, &k);
    for(int i=1;i<=n;i++) scanf("%d", &a[i]);
    int u = 1;
    for(ll i=1; i<=k; i++) {
        if(dfn[u]) {
            k = (k - (i-1)) % (i - dfn[u]);
            while(k--) u = a[u];
            cout << u; return 0;
        }
        dfn[u] = i, u = a[u];
    }
    cout << u;
}
```

---

## 关键技巧总结

1. **循环节检测范式**：
```cpp
vector<int> vis(n, -1);
int pos = 0;
while(true) {
    if(vis[current] != -1) break; // 发现循环
    vis[current] = pos++;
    current = next[current];
}
```

2. **模运算优化公式**：
剩余跳跃次数 = (K - 进入循环前的步数) % 循环周期

3. **实现要点**：
- 使用数组而非哈希表记录访问时间
- 处理K小于循环起点的情况
- 注意数组下标与步数计数器的同步更新

---

## 拓展训练

1. [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)  
   **同类技巧**: 线性同余方程的循环节应用

2. [P3657 机器人跳跃](https://www.luogu.com.cn/problem/P3657)  
   **同类技巧**: 大范围跳跃的循环检测

3. [P2921 [USACO08DEC]Trick or Treat on the Farm](https://www.luogu.com.cn/problem/P2921)  
   **同类技巧**: 图论中的环检测与路径计算

---

## 调试心得摘录

1. **下标偏移**：  
   YuTianQwQ："注意输出时要加一，以适应从1开始的索引"

2. **周期计算**：  
   Mu_leaf："循环节不一定从1开始，需要从首次重复点计算"

3. **边界处理**：  
   liangbowen："当K小于循环起点步数时直接暴力处理"

---
处理用时：45.33秒
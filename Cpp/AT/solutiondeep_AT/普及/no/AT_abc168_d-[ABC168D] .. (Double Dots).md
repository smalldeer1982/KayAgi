# 题目信息

# [ABC168D] .. (Double Dots)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc168/tasks/abc168_d

あるところに、洞窟があります。

洞窟には $ N $ 個の部屋と $ M $ 本の通路があり、部屋には $ 1 $ から $ N $ の、通路には $ 1 $ から $ M $ の番号がついています。通路 $ i $ は部屋 $ A_i $ と部屋 $ B_i $ を双方向につないでいます。どの $ 2 $ 部屋間も、通路をいくつか通って行き来できます。部屋 $ 1 $ は洞窟の入り口がある特別な部屋です。

洞窟の中は薄暗いので、部屋 $ 1 $ 以外の各部屋に $ 1 $ つずつ道しるべを設けることにしました。各部屋の道しるべは、その部屋と通路で直接つながっている部屋の $ 1 $ つを指すように置きます。

洞窟の中は危険なので、部屋 $ 1 $ 以外のどの部屋についても以下の条件を満たすことが目標です。

- その部屋から出発し、「いまいる部屋にある道しるべを見て、それが指す部屋に移動する」ことを繰り返すと、部屋 $ 1 $ に最小の移動回数でたどり着く。

目標を達成できる道しるべの配置が存在するか判定し、存在するならばそのような配置を $ 1 $ つ出力してください。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N\ (1\ \leq\ i\ \leq\ M) $
- $ A_i\ \neq\ B_i\ (1\ \leq\ i\ \leq\ M) $
- どの $ 2 $ 部屋間も、通路をいくつか通って行き来できる

### Sample Explanation 1

出力例のように道しるべを置いたとき、 - 部屋 $ 2 $ から出発した場合 $ (2)\ \to\ 1 $ と $ 1 $ 回移動することになり、これが最小です。 - 部屋 $ 3 $ から出発した場合 $ (3)\ \to\ 2\ \to\ 1 $ と $ 2 $ 回移動することになり、これが最小です。 - 部屋 $ 4 $ から出発した場合 $ (4)\ \to\ 2\ \to\ 1 $ と $ 2 $ 回移動することになり、これが最小です。 したがって、出力例のように道しるべを置けば目標を達成できます。

### Sample Explanation 2

答えが複数あり得る場合、どれを出力してもかまいません。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 2```

### 输出

```
Yes

1

2

2```

## 样例 #2

### 输入

```
6 9

3 4

6 1

2 4

5 3

4 6

1 5

6 2

4 5

5 6```

### 输出

```
Yes

6

5

5

1

1```

# AI分析结果



【中文重写题目】

# [ABC168D] .. (Double Dots)

## 题目描述

某处有一个洞窟，洞窟内有 $N$ 个房间和 $M$ 条通道，房间编号为 $1$ 到 $N$，通道编号为 $1$ 到 $M$。通道 $i$ 双向连接房间 $A_i$ 和 $B_i$。任意两个房间均可通过若干通道互相到达。房间 $1$ 是入口所在的特殊房间。

由于洞窟昏暗，除房间 $1$ 外的每个房间都需要设置一个路标，指向与该房间直接相连的某个房间。目标是要满足以下条件：

- 从任意房间（除房间 $1$）出发，按照路标指示移动，能以最少步数到达房间 $1$。

判断是否存在满足条件的路标配置，若存在则输出一种方案。

## 说明/提示

### 约束条件
- $2 \leq N \leq 10^5$
- $1 \leq M \leq 2 \times 10^5$
- 图保证连通

---

**算法分类**：广度优先搜索 BFS

---

### 题解综合分析

所有题解均采用 BFS 构建最短路径树，核心思路为：从起点 1 进行广度优先搜索，首次访问相邻节点时记录前驱节点作为路标方向，最终形成以 1 为根的最短路径树。

---

### 精选题解

#### 1. 作者：small_john（4.5星）
**关键亮点**：
- 使用标准 BFS 模板实现，代码结构清晰
- 独立函数检查未访问节点，逻辑分明
- 利用 vector 邻接表高效存储图结构

**核心代码**：
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    while(!q.empty()) {
        int x = q.front(); q.pop();
        for(int neighbor : v[x]) {
            if(!ans[neighbor]) {
                ans[neighbor] = x;
                q.push(neighbor);
            }
        }
    }
}
```

#### 2. 作者：Mu_leaf（4星）
**关键亮点**：
- 逆向思维强调前驱记录的意义
- 完整处理边界条件，代码鲁棒性强
- 采用现代 C++ 的 range-based for 循环

**个人心得**：
> "从 1 出发遍历而非每个点单独计算，避免超时" —— 强调了 BFS 的单向扩展优势

#### 3. 作者：YuTianQwQ（4星）
**关键亮点**：
- 极简代码风格，无冗余操作
- 直接在主函数中完成 BFS 过程，适合竞赛场景
- 使用 STL queue 实现高效队列操作

**核心代码**：
```cpp
q.push(1);
p[1] = 1;
while(!q.empty()) {
    u = q.front(); q.pop();
    for(int neighbor : g[u]) {
        if(!p[neighbor]) {
            p[neighbor] = u;
            q.push(neighbor);
        }
    }
}
```

---

### 关键思路总结
1. **BFS 构建最短路径树**：利用广度优先搜索的层级扩展特性，确保首次访问即最短路径
2. **前驱节点记录法**：每个节点记录使其首次被访问的父节点，形成正确路标指向
3. **连通性验证**：虽然题目保证连通，但仍需检查所有节点是否被访问以应对可能的约束变化

---

### 拓展应用
- **同类问题**：单源无权图最短路径、层次遍历问题
- **优化技巧**：使用双端队列优化 BFS（如 0-1 BFS）、前向星存图处理大规模数据
- **变式思考**：若要求输出具体路径而非前驱节点，可通过反向回溯实现

---

### 推荐习题
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  
   - 考察 BFS 统计最短路数量
2. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)  
   - 结合 BFS 进行二分图判定
3. [P2296 寻找道路](https://www.luogu.com.cn/problem/P2296)  
   - 需要预处理有效节点后再进行 BFS

---
处理用时：77.35秒
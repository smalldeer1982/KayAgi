# 题目信息

# [ABC170D] Not Divisible

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc170/tasks/abc170_d

長さ $ N $ の数列 $ A $ が与えられます。

次の性質を満たす整数 $ i $ $ \left(1\ \leq\ i\ \leq\ N\ \right) $ の数を答えてください。

- $ i\ \neq\ j $ である任意の整数 $ j $ $ \left(1\ \leq\ j\ \leq\ N\right) $ について $ A_i $ は $ A_j $ で割り切れない

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^6 $

### Sample Explanation 1

問の性質を満たすのは $ 2 $ , $ 3 $ , $ 4 $ です。

### Sample Explanation 2

同じ数が存在する場合に注意してください。

## 样例 #1

### 输入

```
5

24 11 8 3 16```

### 输出

```
3```

## 样例 #2

### 输入

```
4

5 5 5 5```

### 输出

```
0```

## 样例 #3

### 输入

```
10

33 18 45 28 8 19 89 86 2 4```

### 输出

```
5```

# AI分析结果



### 题目重写
[题目传送门](https://atcoder.jp/contests/abc170/tasks/abc170_d)

#### 题目描述
给定长度为 $N$ 的数列 $A$，求满足以下条件的整数 $i$ 的数量：
- 对于所有 $j \neq i$ 的整数 $j$，$A_i$ 不能被 $A_j$ 整除

#### 输入格式
第一行输入 $N$，第二行输入 $N$ 个整数组成的数列 $A$

#### 输出格式
输出满足条件的 $i$ 的数量

#### 样例解释
- 样例1中，满足条件的元素是11、3、8（注意元素24被16整除，16被8整除）
- 样例2中所有元素相同，每个元素都会被其他元素整除，故输出0

---

### 算法分类
数学（埃氏筛思想）

---

### 题解分析与结论
**核心思路**：通过排序后筛法标记每个数的倍数，结合重复元素处理来统计答案。所有题解均基于以下关键点：
1. **排序必要性**：保证每个数只被更小的数筛选
2. **倍数标记**：类似埃氏筛思想，标记每个数的倍数
3. **重复处理**：若存在重复元素，则所有重复元素均不符合条件

**最优方案**：
1. 先对数组排序
2. 遍历时若当前数未被标记且无重复，则统计答案
3. 标记该数的所有倍数（优化标记范围至数组最大值或1e6）

---

### 精选题解
#### 1. ljy_luogu（4星）
**亮点**：
- 引入`maxn`优化标记范围
- 双重重复检查（前驱和后继元素）
- 快读优化输入

**核心代码**：
```cpp
sort(a + 1, a + n + 1);
for (int i = 1; i <= n; i++) {
    if (!vis[a[i]]) {
        // 检查前后元素判断重复
        if (a[i] != a[i + 1] && a[i] != a[i - 1]) ans++;
        for (int j = a[i]; j <= maxn; j += a[i])
            vis[j] = true;
    }
}
```

#### 2. mi_Y13c（4星）
**亮点**：
- 调和级数优化标记次数
- 桶计数法统计每个数的覆盖次数
- 时间复杂度更优（$O(n + \frac{M}{x})$）

**核心代码**：
```cpp
vector<int> cnt(M);
for (int x : a) {
    if (cnt[x] != 0) { // 已存在重复或倍数
        cnt[x] = 2;
        continue;
    }
    for (int i = x; i < M; i += x) cnt[i]++;
}
// 最终统计cnt[x] == 1的个数
```

#### 3. Fiendish（3.5星）
**亮点**：
- 简洁的标记逻辑
- 单次重复检查（仅检查后驱元素）

**核心代码**：
```cpp
sort(a + 1, a + n + 1);
for (int i = 1; i <= n; i++)
    if (!vis[a[i]]) {
        if (a[i] != a[i + 1]) ans++;
        for (int j = a[i]; j <= 1e6; j += a[i])
            vis[j] = 1;
    }
```

---

### 关键技巧总结
1. **排序预处理**：确保每个数只需考虑比它小的数的影响
2. **筛法优化**：
   - 标记范围优化：用数组最大值代替固定1e6（需遍历获取maxn）
   - 调和级数标记：总时间复杂度为$O(M \log M)$
3. **重复处理**：
   - 排序后相邻元素比对
   - 桶计数法直接统计出现次数

---

### 同类题目推荐
1. [CF1036D](https://www.luogu.com.cn/problem/CF1036D) - 数论与因数分解
2. [P2926 [USACO08DEC]Patting Heads S](https://www.luogu.com.cn/problem/P2926) - 倍数计数问题
3. [P7960 [NOIP2021] 报数](https://www.luogu.com.cn/problem/P7960) - 筛法预处理应用

---

### 题解心得摘录
- ljy_luogu："注意当存在重复元素时，需要同时检查前驱和后继元素"（强调全面性检查）
- mi_Y13c："如果当前数的cnt值不为0，直接标记为2并跳过，避免重复标记"（优化思路）
- Lemonlwl："排序后筛除的数最多，否则后面的数可能筛不掉"（解释排序必要性）

---
处理用时：56.06秒
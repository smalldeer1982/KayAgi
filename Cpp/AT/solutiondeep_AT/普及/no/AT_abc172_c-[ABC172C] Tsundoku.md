# 题目信息

# [ABC172C] Tsundoku

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc172/tasks/abc172_c

二台の机 A, B があります。机 A には $ N $ 冊の本が、机 B には $ M $ 冊の本が、それぞれ縦に積まれています。

机 A に現在上から $ i $ 番目に積まれている本 $ (1\ \leq\ i\ \leq\ N) $ は読むのに $ A_i $ 分を要し、机 B に現在上から $ i $ 番目に積まれている本 $ (1\ \leq\ i\ \leq\ M) $ は読むのに $ B_i $ 分を要します。

次の行為を考えます。

- 本が残っている机を選び、その机の最も上に積まれた本を読んで机から取り除く。

合計所要時間が $ K $ 分を超えないようにこの行為を繰り返すとき、最大で何冊の本を読むことができるでしょうか。本を読むこと以外に要する時間は無視します。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M\ \leq\ 200000 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

この場合、机 A の上から $ 1,2,3 $ 番目の本はそれぞれ読むのに $ 60 $ 分、$ 90 $ 分、$ 120 $ 分を要し、机 B の上から $ 1,2,3,4 $ 番目の本はそれぞれ読むのに $ 80 $ 分、$ 150 $ 分、$ 80 $ 分、$ 150 $ 分を要します。 以下のようにすることで $ 230 $ 分で $ 3 $ 冊の本を読むことができ、これが $ 240 $ 分以内に読むことのできる本の最大数です。 - 机 A の最も上に積まれている本を $ 60 $ 分かけて読み、この本を机から取り除く。 - 机 B の最も上に積まれている本を $ 80 $ 分かけて読み、この本を机から取り除く。 - 机 A の最も上に積まれている本を $ 90 $ 分かけて読み、この本を机から取り除く。

### Sample Explanation 3

整数のオーバーフローに注意してください。

## 样例 #1

### 输入

```
3 4 240

60 90 120

80 150 80 150```

### 输出

```
3```

## 样例 #2

### 输入

```
3 4 730

60 90 120

80 150 80 150```

### 输出

```
7```

## 样例 #3

### 输入

```
5 4 1

1000000000 1000000000 1000000000 1000000000 1000000000

1000000000 1000000000 1000000000 1000000000```

### 输出

```
0```

# AI分析结果



# [ABC172C] Tsundoku

## 题目描述

有两张桌子 A 和 B。桌子 A 上垂直堆叠着 N 本书，桌子 B 上垂直堆叠着 M 本书。

桌子 A 上从上往下第 i 本书（1 ≤ i ≤ N）需要花费 A_i 分钟阅读，桌子 B 上从上往下第 i 本书（1 ≤ i ≤ M）需要花费 B_i 分钟阅读。

考虑以下操作：
- 选择一本仍有书的桌子，阅读其最顶部的书并将其从桌子上移除。

在总耗时不超过 K 分钟的情况下，最多可以阅读多少本书？除阅读时间外其他时间忽略不计。

## 算法分类
前缀和 + 双指针

---

### 题解分析与结论
题目核心在于找出两书堆前缀和的最优组合。通过预处理前缀和数组，利用双指针在 O(N+M) 时间复杂度内找到最大可读书数。关键点在于将问题转化为二维前缀和搜索，并利用双指针技巧进行高效遍历。

---

### 精选题解（五星级）

#### 作者：yinbe
**关键亮点**：  
1. 前缀和预处理简化计算  
2. 逆向双指针优化遍历效率  
3. 边界处理严谨（从0开始计数）  
**个人心得**：  
- 必须使用long long防止溢出  
- r指针从m开始逆向扫描，巧妙处理B堆不取的情况  
**核心代码**：
```cpp
int l=0, r=m; // B堆最多取m本
while(l <= n) {
    while(r>=1 && suma[l]+sumb[r]>k) r--; // 逆向调整B堆的取书数量
    if(suma[l]+sumb[r] > k) break;       // 提前终止无效遍历
    Max = max(Max, l+r);
    l++;
}
```

---

### 最优思路总结
1. **前缀和预处理**：分别计算两书堆的前缀和数组，将问题转化为二维组合问题  
2. **逆向双指针法**：固定A堆的取书数，从B堆最大可能取值逆向扫描，确保线性时间复杂度  
3. **边界条件处理**：允许取0本书的情况（l从0开始），正确处理全不取的极端场景  

---

### 拓展应用
类似的双指针+前缀和组合技巧可用于以下场景：  
- 两数组元素和的最值问题（如LeetCode 167. 两数之和 II）  
- 限制条件下的多维组合优化问题  
- 需要线性时间复杂度的有序数组遍历问题  

---

### 推荐习题
1. [P1104 双栈排序](https://www.luogu.com.cn/problem/P1155)  
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（滑动窗口经典题）  
3. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)（前缀和+双指针应用）

---
处理用时：41.21秒
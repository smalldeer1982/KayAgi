# 题目信息

# [ABC176D] Wizard in Maze

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc176/tasks/abc176_d

縦 $ H $ マス、横 $ W $ マスの $ H\times\ W $ マスからなる迷路があります。

上から $ i $ 行目、左から $ j $ 列目のマス $ (i,j) $ は、$ S_{ij} $ が `#` のとき壁であり、`.`のとき道です。

マス $ (C_h,C_w) $ に魔法使いがいます。魔法使いは次の $ 2 $ 種類の方法で移動することができます。

- 移動A：現在いるマスと上下左右に隣接する道のマスへ歩いて移動する。
- 移動B：現在いるマスを中心とする $ 5\times\ 5 $ の範囲内にある道のマスへワープ魔法で移動する。

どちらの行動でも、迷路の外へ移動することはできません。

マス $ (D_h,D_w) $ まで移動するには、ワープ魔法を最低で何度使う必要があるでしょうか。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 10^3 $
- $ 1\ \leq\ C_h,D_h\ \leq\ H $
- $ 1\ \leq\ C_w,D_w\ \leq\ W $
- $ S_{ij} $ は `#` か `.`
- $ S_{C_h\ C_w} $ と $ S_{D_h\ D_w} $ は `.`
- $ (C_h,C_w)\ \neq\ (D_h,D_w) $

### Sample Explanation 1

例えば $ (2,2) $ まで歩いて移動し、$ (2,2) $ から $ (4,4) $ へワープ魔法で移動することで、ワープ魔法の使用回数を $ 1 $ 回にできます。 歩いて斜めに移動することはできません。

### Sample Explanation 2

現在地から動くことができません。

### Sample Explanation 3

ワープ魔法を使う必要はありません。

## 样例 #1

### 输入

```
4 4

1 1

4 4

..#.

..#.

.#..

.#..```

### 输出

```
1```

## 样例 #2

### 输入

```
4 4

1 4

4 1

.##.

####

####

.##.```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 4

2 2

3 3

....

....

....

....```

### 输出

```
0```

## 样例 #4

### 输入

```
4 5

1 2

2 5

#.###

####.

#..##

#..##```

### 输出

```
2```

# AI分析结果



# 题目翻译

## [ABC176D] 迷宫中的魔女

### 题目描述

由 $H$ 行 $W$ 列组成的迷宫。从上往下第 $i$ 行、从左往右第 $j$ 列的格子 $(i,j)$，当 $S_{ij}$ 为 `#` 时是墙壁，`.` 时是道路。

魔女位于格子 $(C_h,C_w)$，可以通过以下两种方式移动：
- 移动A：步行到当前格子上下左右相邻的道路格子
- 移动B：传送到以当前格子为中心的 $5\times5$ 范围内的道路格子

两种移动都不能越出迷宫边界。求到达格子 $(D_h,D_w)$ 所需的最少魔法使用次数。

### 输入格式
第一行输入 $H, W$  
第二行输入起始坐标 $(C_h, C_w)$  
第三行输入目标坐标 $(D_h, D_w)$  
接下来 $H$ 行输入迷宫地图  

### 输出格式
输出最少魔法次数，若不可达输出 -1

---

**算法分类**：广度优先搜索 BFS（双端队列优化）

---

# 题解分析与结论

**核心思路**：使用双端队列的 0-1 BFS 算法，将普通移动（无消耗）插入队首优先处理，魔法移动（消耗+1）插入队尾。维护二维数组记录每个格子的最小魔法次数，通过剪枝避免无效搜索。

### 高分题解亮点

1. **KukCair（⭐⭐⭐⭐⭐）**
   - **关键亮点**：完整实现双端队列 BFS，使用预处理的方向数组提升效率
   - **代码结构**：清晰分离普通移动和魔法移动的处理逻辑
   - **优化点**：魔法方向数组预计算5x5偏移量，避免循环嵌套判断

2. **xibaohe（⭐⭐⭐⭐）**
   - **亮点**：详细注释和模板对比，适合新手理解双端队列应用
   - **实现技巧**：使用结构体封装状态，代码可读性高
   - **心得**：特别强调"一个点可以重复走过，但若新次数更大则无需处理"

3. **GenesisCrystal（⭐⭐⭐⭐）**
   - **亮点**：代码最简洁，使用函数封装移动判断
   - **优化点**：将移动范围判断封装为 REcord 函数，减少代码冗余

---

# 核心代码实现

**双端队列 BFS 框架**：
```cpp
deque<node> q;
q.push_front(起点);
dis[起点] = 0;

while (!q.empty()) {
    auto cur = q.front(); q.pop_front();
    
    // 处理普通移动（插入队首）
    for (四方向) {
        if (新坐标合法 && 可优化距离) {
            dis[新坐标] = cur.step;
            q.push_front(新坐标);
        }
    }
    
    // 处理魔法移动（插入队尾）
    for (5x5范围坐标) {
        if (合法 && 可优化距离) {
            dis[新坐标] = cur.step + 1;
            q.push_back(新坐标);
        }
    }
}
```

---

# 拓展练习

1. **P1948 [USACO08JAN] Telephone Lines**  
   （双端队列处理分层图最短路）

2. **P4554 小明的游戏**  
   （类似的双端队列 BFS，普通移动与特殊移动组合）

3. **P4667 [BalticOI 2011 Day1] Switch the Lamp On**  
   （0-1 BFS 处理电路转向问题）

---

**经验总结**：调试时需特别注意坐标系的转换（题目行列定义），多数错误来源于方向数组与坐标范围判断。建议预处理方向数组时标注坐标系方向，避免混淆x/y增减方向。

---
处理用时：46.64秒
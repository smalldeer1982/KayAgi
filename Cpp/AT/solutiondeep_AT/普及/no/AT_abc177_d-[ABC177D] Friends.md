# 题目信息

# [ABC177D] Friends

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc177/tasks/abc177_d

人 $ 1 $ から 人 $ N $ までの $ N $ 人の人がいます。

「人 $ A_i $ と人 $ B_i $ は友達である」という情報が $ M $ 個与えられます。同じ情報が複数回与えられることもあります。

$ X $ と $ Y $ が友達、かつ、$ Y $ と $ Z $ が友達ならば、$ X $ と $ Z $ も友達です。また、$ M $ 個の情報から導くことができない友達関係は存在しません。

悪の高橋君は、この $ N $ 人をいくつかのグループに分け、全ての人について「同じグループの中に友達がいない」という状況を作ろうとしています。

最小でいくつのグループに分ければ良いでしょうか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,B_i\leq\ N $
- $ A_i\ \neq\ B_i $

### Sample Explanation 1

例えば $ \{1,3\},\{2,4\},\{5\} $ という $ 3 $ つのグループに分けることで目的を達成できます。

## 样例 #1

### 输入

```
5 3

1 2

3 4

5 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4 10

1 2

2 1

1 2

2 1

1 2

1 3

1 4

2 3

2 4

3 4```

### 输出

```
4```

## 样例 #3

### 输入

```
10 4

3 1

4 1

5 9

2 6```

### 输出

```
3```

# AI分析结果



# [ABC177D] Friends 中文翻译

## 题目描述

人 $1$ 到人 $N$ 共有 $N$ 个人。给定 $M$ 条"人 $A_i$ 和人 $B_i$ 是朋友"的关系（可能有重复）。朋友关系具有传递性，且没有隐含的其他朋友关系。

要求将所有人分组，使得每组内没有朋友关系。求最少需要分多少组。

## 输入格式
第一行两个整数 $N,M$
接下来 $M$ 行每行两个整数 $A_i,B_i$

## 输出格式
输出最小分组数

## 数据范围
$2 \leq N \leq 2\times 10^5$  
$0 \leq M \leq 2\times 10^5$

## 算法分类
并查集

---

### 综合题解分析
核心思路：每个连通块内的所有成员必须分布在不同的组，因此最小分组数等于最大连通块的节点数。所有题解均采用并查集统计连通块大小，区别在于维护尺寸数组的方式。

#### 高分题解亮点
1. **Neilchenyinuo (4星)**
   - 在合并时直接维护尺寸数组，实时更新连通块大小
   - 路径压缩优化查询效率
   - 代码简洁，时间复杂度严格 O(α(N))

2. **PineappleSummer (4星)**
   - 独立统计每个节点的最终根节点
   - 使用独立计数数组统计最终连通块大小
   - 包含样例解析，思路说明清晰

3. **happy_zero (4星)**
   - 最简洁的代码实现
   - 使用标准尺寸维护方式
   - 无冗余操作，时间复杂度最优

---

### 关键思路与技巧
**核心结论**：最小分组数等于最大连通块的大小  
**证明思路**：  
- 同一连通块内所有节点互为可达，必须分到不同组（抽屉原理）  
- 不同连通块间节点可以共享组号

**实现技巧**：
1. **并查集尺寸维护**：在合并操作时，将小集合合并到大集合，并累加尺寸
2. **路径压缩**：find 时进行路径压缩，保证查询复杂度接近 O(1)
3. **最终统计**：遍历所有节点统计根节点出现次数，或直接维护尺寸数组最大值

**代码模板**：
```cpp
int fa[N], size[N];
int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

// 初始化
for(int i=1; i<=n; i++) fa[i] = i, size[i] = 1;

// 合并操作
int fx = find(x), fy = find(y);
if(fx != fy) {
    if(size[fx] > size[fy]) swap(fx,fy);
    fa[fx] = fy;
    size[fy] += size[fx];
}
```

---

### 推荐练习题
1. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551) - 并查集基础应用
2. [P1536 村村通](https://www.luogu.com.cn/problem/P1536) - 连通块计数
3. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197) - 逆向并查集应用

---

### 题解代码精选
**happy_zero 的极简实现**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int fa[N], siz[N];
int find(int x) { return fa[x]==x ? x : fa[x]=find(fa[x]); }

int main() {
    int n, m; cin >> n >> m;
    for(int i=1; i<=n; i++) fa[i]=i, siz[i]=1;
    while(m--) {
        int x,y; cin >> x >> y;
        int fx = find(x), fy = find(y);
        if(fx != fy) {
            fa[fx] = fy;
            siz[fy] += siz[fx]; // 合并时维护尺寸
        }
    }
    int ans = 0;
    for(int i=1; i<=n; i++) 
        ans = max(ans, siz[i]);
    cout << ans;
}
```

---
处理用时：52.20秒
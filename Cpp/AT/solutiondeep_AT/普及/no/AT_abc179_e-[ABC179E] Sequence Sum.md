# 题目信息

# [ABC179E] Sequence Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc179/tasks/abc179_e

$ x $ を $ m $ で割った余りを $ f(x,m) $ と表します。

初期値 $ A_1=X $ および漸化式 $ A_{n+1}=\ f(A_n^2,\ M) $ で定まる数列を $ A $ とします。$ \displaystyle{\sum_{i=1}^N\ A_i} $ を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^{10} $
- $ 0\ \leq\ X\ <\ M\ \leq\ 10^5 $
- 入力は全て整数

### Sample Explanation 1

数列 $ A $ は $ 2,4,16,256,471,620,\ldots $ となるので、答えは $ 2+4+16+256+471+620=1369 $ となります。

### Sample Explanation 2

数列 $ A $ は $ 2,4,0,0,\ldots $ となるので、答えは $ 6 $ となります。

## 样例 #1

### 输入

```
6 2 1001```

### 输出

```
1369```

## 样例 #2

### 输入

```
1000 2 16```

### 输出

```
6```

## 样例 #3

### 输入

```
10000000000 10 99959```

### 输出

```
492443256176507```

# AI分析结果



### 题目中文翻译  
题目名：[ABC179E] Sequence Sum  

**题目描述**  
定义 $f(x, m)$ 为 $x$ 除以 $m$ 的余数。  
给定初始值 $A_1 = X$，数列 $A$ 满足递推式 $A_{n+1} = f(A_n^2, M)$。求 $\sum_{i=1}^N A_i$。  

**输入约束**  
- $1 \leq N \leq 10^{10}$  
- $0 \leq X < M \leq 10^5$  

**样例解释**  
样例1中，数列为 $2,4,16,256,471,620,\ldots$，前6项和为1369。  
样例2中，数列进入循环后全为0，前1000项和为6。  

---

**算法分类**：数学（循环节检测、前缀和优化）  

---

### 题解综合分析  
**核心难点**：  
1. **循环节检测**：由于模运算的特性，数列会进入循环，需快速定位循环起点和长度。  
2. **分阶段求和**：将数列分为前循环段、完整循环段、剩余段，分块计算总和。  
3. **大数处理**：$N$ 可达 $10^{10}$，需避免暴力遍历，时间复杂度需控制在 $O(M)$。  

**关键思路**：  
- 利用哈希表或数组记录每个值首次出现的位置，当再次遇到相同值时确定循环节。  
- 使用前缀和快速计算循环节内的总和，结合数学公式计算完整循环次数和剩余部分。  

---

### 精选题解与评分  

#### 题解1（作者：STARSczy，4星）  
**亮点**：  
- 利用前缀和数组简化分段计算。  
- 代码结构清晰，逻辑紧凑。  
**核心代码**：  
```cpp
a[1] = x, t[x] = 1;
for (top = 2; ; ++top) {
    a[top] = a[top-1] * a[top-1] % m;
    if (t[a[top]]) { // 发现循环起点
        l = t[a[top]], r = top - 1;
        break;
    }
    t[a[top]] = top;
}
len = r - l + 1, sum = a[r] - a[l-1]; // 循环长度及和
ans = a[l-1] + sum * (n / len) + (a[l-1 + n%len] - a[l-1]); // 分三段求和
```  
**实现思路**：  
1. 预处理数列直到发现循环节，记录每个值的出现位置。  
2. 计算前缀和数组，直接通过下标差得到循环段总和。  
3. 分前段、完整循环次数、剩余段求和。  

---

#### 题解2（作者：lilong，4星）  
**亮点**：  
- 显式分离非循环部分和循环部分，逻辑易读。  
- 变量命名合理，如 `w` 表示循环起点前长度。  
**核心代码**：  
```cpp
for (int i=1; ; i++,x=x*x%m) {
    if (pd[x]) { // 发现重复值
        len = i - pd[x]; // 循环长度
        w = pd[x]; // 前段长度
        break;
    }
    pd[x] = i; // 记录首次出现位置
    sum[i] = sum[i-1] + x; // 前缀和
}
ans = sum[min(n, w-1)]; // 前段和
if (n > w-1) {
    ans += (sum[w+len-1] - sum[w-1]) * ((n - w + 1)/len); // 完整循环
    ans += sum[w-1 + (n - w +1)%len] - sum[w-1]; // 剩余部分
}
```  
**实现思路**：  
- 使用 `pd` 数组记录首次出现位置，快速定位循环起点。  
- 通过数学计算直接得到各段总和，避免逐项累加。  

---

#### 题解3（作者：zcr0202，4星）  
**亮点**：  
- 利用 `map` 记录状态，代码简洁。  
- 直接处理前缀和数组，减少中间变量。  
**核心代码**：  
```cpp
map<int, int> mp;
a[1] = x; mp[x] = 1;
for (d = 2; ; d++) {
    a[d] = a[d-1] * a[d-1] % m;
    if (mp[a[d]]) { // 发现循环
        h = mp[a[d]]; // 循环起点
        t = d - 1;    // 循环终点
        break;
    }
    mp[a[d]] = d;
    a[d] += a[d-1]; // 直接构建前缀和
}
ans = a[h-1] + (a[t] - a[h-1]) * ((n - h +1)/(t-h+1)); // 完整循环
ans += a[h-1 + (n-h+1)%(t-h+1)] - a[h-1]; // 剩余段
```  

---

### 关键技巧总结  
1. **循环节检测**：使用数组或哈希表记录每个值的首次出现位置，时间复杂度 $O(M)$。  
2. **前缀和优化**：预处理前缀和数组，快速计算任意区间的和。  
3. **数学分块计算**：将总和拆分为前循环段、完整循环次数乘循环和、剩余段，公式化计算。  

---

### 拓展与相似题目  
1. **P1965 转圈游戏**（循环节应用）  
2. **P1462 通往奥格瑞玛的道路**（模运算与路径循环）  
3. **P1313 计算系数**（数学规律与分块求和）  

**个人心得摘录**：  
- “循环节的起始位置不一定在第一个元素，需正确分割前段和循环段。”（作者：BLuemoon_）  
- “使用 `long long` 避免溢出，尤其当 $M$ 较大时。”（作者：asas111）  
- “前缀和数组能极大简化分段求和代码。”（作者：STARSczy）

---
处理用时：67.89秒
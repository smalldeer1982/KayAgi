# 题目信息

# [ABC180E] Traveling Salesman among Aerial Cities

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc180/tasks/abc180_e

$ 3 $ 次元空間内に $ N $ 個の都市、都市 $ 1 $ から 都市 $ N $ があります。都市 $ i $ は座標 $ (X_i,Y_i,Z_i) $ にあります。

座標 $ (a,b,c) $ の都市から $ (p,q,r) $ の都市に移動する際には $ |p-a|+|q-b|+\max(0,r-c) $ のコストがかかります。

都市 $ 1 $ からスタートし、全ての都市を $ 1 $ 度以上巡って都市 $ 1 $ に戻るまでの最小コストを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 17 $
- $ -10^6\ \leq\ X_i,Y_i,Z_i\ \leq\ 10^6 $
- 同じ座標に複数の都市があることはない
- 入力は全て整数

### Sample Explanation 1

都市 $ 1 $ から都市 $ 2 $ へ向かう時には $ |1-0|+|2-0|+\max(0,3-0)=6 $ のコストがかかります。 都市 $ 2 $ から都市 $ 1 $ へ向かう時には $ |0-1|+|0-2|+\max(0,0-3)=3 $ のコストがかかります。 よって合計で $ 9 $ のコストがかかります。

### Sample Explanation 2

例えば 都市 $ 1 $, $ 2 $, $ 1 $, $ 3 $, $ 1 $ の順に移動するとコストが $ 10 $ になります。途中で都市 $ 1 $ に戻ってきても構いません。

## 样例 #1

### 输入

```
2

0 0 0

1 2 3```

### 输出

```
9```

## 样例 #2

### 输入

```
3

0 0 0

1 1 1

-1 -1 -1```

### 输出

```
10```

## 样例 #3

### 输入

```
17

14142 13562 373095

-17320 508075 68877

223606 -79774 9979

-24494 -89742 783178

26457 513110 -64591

-282842 7124 -74619

31622 -77660 -168379

-33166 -24790 -3554

346410 16151 37755

-36055 51275 463989

37416 -573867 73941

-3872 -983346 207417

412310 56256 -17661

-42426 40687 -119285

43588 -989435 -40674

-447213 -59549 -99579

45825 7569 45584```

### 输出

```
6519344```

# AI分析结果



### 题目内容  
三维空间中有 $N$ 个城市，城市 $i$ 的坐标为 $(X_i,Y_i,Z_i)$。定义从坐标 $(a,b,c)$ 到 $(p,q,r)$ 的移动成本为 $|p-a| + |q-b| + \max(0, r-c)$。求从城市 1 出发，经过所有城市至少一次并返回城市 1 的最小总成本。

### 算法分类  
动态规划（状态压缩）

---

### 综合分析与结论  
题目本质是旅行商问题（TSP）的变种，核心解法为状态压缩 DP。各题解均采用如下思路：  
- **状态定义**：`dp[S][i]` 表示已访问城市集合为二进制状态 `S`，当前位于城市 `i` 的最小成本。  
- **转移方程**：`dp[S][i] = min(dp[S - (1<<i)][j] + cost(j,i))`，其中 `j` 是 `S` 中已访问的城市。  
- **关键优化**：预处理所有城市间移动成本，状态转移时仅枚举合法状态。  
- **难点**：正确处理三维坐标的移动成本公式，以及状态压缩中的位运算逻辑。

---

### 精选题解与评分  
1. **Llx2022（4星）**  
   **关键亮点**：  
   - 代码简洁，预处理成本矩阵清晰。  
   - 状态定义中将城市 1 视为索引 0，简化初始状态设置。  
   ```cpp
   // 预处理城市间移动成本
   for (int i = 0; i < N; i++) 
       for (int j = 0; j < N; j++) 
           cost[i][j] = abs(x[i]-x[j]) + abs(y[i]-y[j]) + max(0, z[j]-z[i]);
   
   // 状态初始化（从城市1出发到其他城市）
   for (int i = 0; i < N-1; i++) 
       dp[1<<i][i] = cost[0][i+1];
   ```

2. **Strelitzia_（4星）**  
   **关键亮点**：  
   - 使用标准 TSP 状态转移模板，代码可读性强。  
   - 显式处理最终返回城市 1 的成本，逻辑明确。  
   ```cpp
   // 最终答案计算
   for (int i = 2; i <= n; i++) 
       ans = min(ans, f[(1<<n)-1][i] + dis(i,1));
   ```

3. **Your_Name（4星）**  
   **关键亮点**：  
   - 使用位运算优化状态转移，代码高效。  
   - 初始化 `f[1][0] = 0` 直接对应起点，避免冗余判断。  
   ```cpp
   // 状态转移核心代码
   for (int i = 1; i < (1<<n); i += 2) 
       for (int j = 0; j < n; j++) 
           if ((i >> j) & 1) 
               for (int k = 0; k < n; k++) 
                   if (k != j && (i >> k) & 1) 
                       f[i][j] = min(f[i][j], f[i^(1<<j)][k] + cost[k][j]);
   ```

---

### 关键思路与技巧  
1. **状态压缩设计**：用二进制位表示已访问城市，状态数控制在 $O(2^N \cdot N)$。  
2. **预处理优化**：提前计算所有城市对之间的移动成本，避免重复计算。  
3. **循环顺序优化**：外层遍历状态，内层遍历城市，确保状态转移时依赖的子问题已解。  
4. **最终答案处理**：遍历所有可能的终点，加上返回起点的成本后取最小值。

---

### 同类题目推荐  
1. **P1433 吃奶酪**（基础 TSP 的二维平面变种）  
2. **P1171 售货员的难题**（经典 TSP 模板题）  
3. **P3052 [USACO12MAR] Cows in a Skyscraper G**（状态压缩与剪枝结合）

---
处理用时：56.93秒
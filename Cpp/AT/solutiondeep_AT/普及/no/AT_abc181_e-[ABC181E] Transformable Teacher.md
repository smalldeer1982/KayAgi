# 题目信息

# [ABC181E] Transformable Teacher

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc181/tasks/abc181_e

$ N $ 人の児童がおり、 $ i $ 番目の児童の身長は $ H_i $ です。 $ N $ は奇数です。

今から、先生であるあなたを含めた $ N+1 $ 人で $ 2 $ 人 $ 1 $ 組を $ \large\frac{N+1}2 $ ペア組みます。

あなたの目標は、それぞれのペアの身長の差の合計を最小化することです。  
 すなわち、 $ i $ 番目のペアの身長の組を $ (x_i,\ y_i) $ としたとき、 $ \displaystyle\ \sum_{i=1}^{(N+1)/2}|x_i-y_i| $ を最小化したいです。

あなたには $ M $ 個の変身形態があり、 $ i $ 番目の変身形態での身長は $ W_i $ です。

あなたの変身形態とペアの組み方を工夫することで、それぞれのペアの身長の差の合計が最小でいくつにできるか求めてください。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 1\ \leq\ N,\ M\ \leq\ 2\ \times\ 10^5 $
- $ N $ は奇数
- $ 1\ \leq\ H_i\ \leq\ 10^9 $
- $ 1\ \leq\ W_i\ \leq\ 10^9 $

### Sample Explanation 1

身長 $ 8 $ の変身形態を選び、身長が $ (1,\ 2),\ (3,\ 4),\ (7,\ 8) $ のペアを作ると最小になります。

## 样例 #1

### 输入

```
5 3

1 2 3 4 7

1 3 8```

### 输出

```
3```

## 样例 #2

### 输入

```
7 7

31 60 84 23 16 13 32

96 80 73 76 87 57 29```

### 输出

```
34```

## 样例 #3

### 输入

```
15 10

554 525 541 814 661 279 668 360 382 175 833 783 688 793 736

496 732 455 306 189 207 976 73 567 759```

### 输出

```
239```

# AI分析结果



### 题目内容重写
#### [ABC181E] Transformable Teacher

**题目描述**  
有 $N$个学生（$N$为奇数），第 $i$ 个学生的身高为 $H_i$。老师可以变成 $M$ 种形态，第 $i$ 种形态的身高为 $W_i$。要求老师选择一种形态加入学生队列，并将所有 $N+1$ 人两两配对，使得所有配对的身高差绝对值之和最小。求这个最小和值。

**输入格式**  
第一行输入 $N$ 和 $M$，第二行输入 $H$ 数组，第三行输入 $W$ 数组。  
**输出格式**  
输出最小的身高差之和。  

**样例解释**  
样例1中选择身高8的形态，形成配对 (1,2), (3,4), (7,8)，总和为3。

---

### 算法分类  
**排序、二分、前缀和**

---

### 题解对比与结论
#### 核心思路  
1. **排序优化**：将学生身高排序后，最优配对方式为相邻元素两两配对。  
2. **二分插入**：对每个老师形态的身高，用二分找到其在有序数组中的插入位置。  
3. **前缀和预处理**：提前计算奇数位和偶数位的前缀和与后缀和，快速计算插入位置前后的贡献。  
4. **分类讨论**：根据插入位置的奇偶性，确定新配对对总和的贡献方式。

#### 解决难点  
- **插入位置影响奇偶配对**：需正确处理插入位置前后段的奇偶性变化。  
- **高效计算**：通过前缀和与后缀和的预处理，将每次查询复杂度降至 $O(1)$。

---

### 精选题解 (评分≥4★)  
#### 1. 题解作者：ForgetOIDuck（4★）  
**关键亮点**  
- 清晰的前缀和/后缀和预处理逻辑。  
- 简洁的二分实现与奇偶分类讨论。  
**代码核心**  
```cpp
sort(a + 1, a + n + 1);
// 前缀和预处理：偶数位置差累加
for (ll i = 2; i <= n; i += 2) su[i] = su[i - 2] + a[i] - a[i - 1];
// 后缀和预处理：逆序奇数位置差累加
for (ll i = n - 1; i; i -= 2) us[i] = us[i + 2] + a[i + 1] - a[i];
// 二分查找插入位置
ll pos = lower_bound(...);
// 奇偶分类计算总和
if (ans % 2) sum = su[ans-1] + us[ans+1] + x - a[ans];
else sum = su[ans] + us[ans+2] + a[ans+1] - x;
```

#### 2. 题解作者：LiJinLin_AFO（4★）  
**关键亮点**  
- 前缀和命名清晰（sum1/sum2），代码可读性强。  
- 处理插入位置后的奇偶判断逻辑简洁。  
**个人心得**  
提到"快把我调疯了"，强调奇偶边界条件调试的重要性。

#### 3. 题解作者：Tian36309（4★）  
**关键亮点**  
- 对 $W$ 数组排序后使用双指针优化，减少二分次数。  
- 利用前缀和与后缀和分三段计算总贡献。  
**核心代码**  
```cpp
sort(B); // 预处理优化
for (B的每个元素) {
    while (找到第一个大于等于当前B[i]的位置);
    if (插入位置为偶数) 计算前段+当前差+后段;
    else 计算前段+当前差+后段;
}
```

---

### 关键思路总结  
1. **排序优化配对**：排序后相邻配对是最优策略。  
2. **二分快速定位**：通过二分找到插入位置，避免暴力枚举。  
3. **前缀和分段处理**：预处理前后段的和值，实现 $O(1)$ 查询。  
4. **奇偶性分类**：插入位置的奇偶性决定配对方式，需分类计算。

---

### 拓展与相似题目  
- **P2678 跳石头**：二分答案验证最小距离。  
- **P1094 纪念品分组**：排序后贪心配对。  
- **P1182 数列分段**：二分分段和最大值。

---
处理用时：128.31秒
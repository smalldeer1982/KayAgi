# 题目信息

# [ABC183E] Queen on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc183/tasks/abc183_e

縦 $ H $ マス、横 $ W $ マスのグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマス $ (i,j) $ は、$ S_{ij} $ が `#` のとき壁であり、`.` のとき道です。

マス $ (1,1) $ にチェスのクイーンの駒が置いてあります。 クイーンの駒は、今いる位置から右・下・右下方向に伸びる直線上にあり、壁を飛び越えずに到達できる道のマスに $ 1 $ 手で移動することができます。

クイーンの駒がマス $ (1,1) $ からマス $ (H,W) $ まで移動する方法は何通りありますか？ $ \bmod\ (10^9+7) $ で求めてください。

ただし、移動する方法が異なるとは、ある $ i $ が存在して、$ i $ 手目の移動の後にクイーンの駒があるマスの位置が異なることを指します。

## 说明/提示

### 制約

- $ 2\ \leq\ H,W\ \leq\ 2000 $
- $ S_{ij} $ は `#` か `.`
- $ S_{11} $ と $ S_{HW} $ は `.`

### Sample Explanation 1

移動方法として次の $ 10 $ 通りが考えられます。 - $ (1,1)\to\ (1,2)\to\ (1,3)\to\ (2,3)\to\ (3,3) $ - $ (1,1)\to\ (1,2)\to\ (1,3)\to\ (3,3) $ - $ (1,1)\to\ (1,2)\to\ (2,3)\to\ (3,3) $ - $ (1,1)\to\ (1,3)\to\ (2,3)\to\ (3,3) $ - $ (1,1)\to\ (1,3)\to\ (3,3) $ - $ (1,1)\to\ (2,1)\to\ (3,1)\to\ (3,2)\to\ (3,3) $ - $ (1,1)\to\ (2,1)\to\ (3,1)\to\ (3,3) $ - $ (1,1)\to\ (2,1)\to\ (3,2)\to\ (3,3) $ - $ (1,1)\to\ (3,1)\to\ (3,2)\to\ (3,3) $ - $ (1,1)\to\ (3,1)\to\ (3,3) $

### Sample Explanation 2

$ (1,1) $ からは $ 1 $ 手で $ (1,2),(1,3),(2,1),(2,2),(3,1),(4,1) $ のいずれかへ移動することが出来ます。 $ (4,4) $ への移動経路として、例えば $ (1,1)\to\ (3,1)\to\ (3,2)\to\ (4,3)\to\ (4,4) $ などがあります。

### Sample Explanation 3

移動方法の数を $ \bmod\ (10^9+7) $ で求めてください。

## 样例 #1

### 输入

```
3 3

...

.#.

...```

### 输出

```
10```

## 样例 #2

### 输入

```
4 4

...#

....

..#.

....```

### 输出

```
84```

## 样例 #3

### 输入

```
8 10

..........

..........

..........

..........

..........

..........

..........

..........```

### 输出

```
13701937```

# AI分析结果



# [ABC183E] 网格上的皇后

## 题目描述

给定一个 $ H $ 行 $ W $ 列的网格。第 $ i $ 行第 $ j $ 列的格子 $(i,j)$ 是墙（`#`）或道路（`.`）。皇后从 $(1,1)$ 出发，每次可以向右、向下或右下方向沿直线移动任意格（不能穿过墙壁）。求到达 $(H,W)$ 的路径总数，答案对 $10^9+7$ 取模。

## 算法分类
动态规划、前缀和

---

## 题解分析与结论

### 核心思路
动态规划结合前缀和优化。设 $f[i][j]$ 表示到达 $(i,j)$ 的路径数，利用三个前缀和数组分别维护上方、左方、左上方三个方向的累计路径数，将时间复杂度优化至 $O(HW)$。

### 最优题解亮点

#### 题解作者：zfx_VeXl6（⭐⭐⭐⭐⭐）
**关键亮点**：
- 清晰定义三个方向的前缀和数组 `u`（上方）、`l`（左侧）、`ul`（左上方）
- 简洁的状态转移方程：$f[i][j] = u[i-1][j] + l[i][j-1] + ul[i-1][j-1]$
- 高效处理障碍物逻辑，代码可读性强

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++) {
        char s; cin >> s;
        if(i==1 && j==1) // 起点初始化
            f[i][j]=u[i][j]=l[i][j]=ul[i][j]=1; 
        else if(s=='.') {
            f[i][j] = (u[i-1][j] + l[i][j-1] + ul[i-1][j-1]) % mod;
            // 更新三个方向的前缀和
            u[i][j] = (u[i-1][j] + f[i][j]) % mod;
            l[i][j] = (l[i][j-1] + f[i][j]) % mod;
            ul[i][j] = (ul[i-1][j-1] + f[i][j]) % mod;
        }
    }
```

#### 题解作者：Redamancy_Lydic（⭐⭐⭐⭐）
**关键亮点**：
- 显式处理障碍物时重置所有相关数组
- 使用统一循环结构处理所有方向的前缀和更新
- 代码结构清晰，适合动态规划入门理解

**核心代码**：
```cpp
for(int i=1;i<=n;i++) {
    for(int j=1;j<=m;j++) {
        if(i==1 && j==1) continue;
        if(s[i][j]=='#') // 障碍物处理
            f[i][j] = s1[i][j] = s2[i][j] = s3[i][j] = 0;
        else {
            f[i][j] = (s1[i-1][j] + s2[i][j-1] + s3[i-1][j-1]) % mo;
            // 更新三个前缀和数组
            s1[i][j] = (s1[i-1][j] + f[i][j]) % mo;
            s2[i][j] = (s2[i][j-1] + f[i][j]) % mo;
            s3[i][j] = (s3[i-1][j-1] + f[i][j]) % mo;
        }
    }
}
```

---

## 关键技巧总结
1. **方向拆分**：将移动方向拆分为三个独立的前缀和数组，避免重复计算
2. **障碍物处理**：遇到障碍物时立即重置当前格子的所有状态，确保后续计算正确性
3. **滚动更新**：在计算当前格子的同时更新前缀和数组，实现状态的无缝衔接

---

## 拓展练习
1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)（基础动态规划）
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)（带障碍的路径计数）
3. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)（多方向动态规划应用）

---
处理用时：72.38秒
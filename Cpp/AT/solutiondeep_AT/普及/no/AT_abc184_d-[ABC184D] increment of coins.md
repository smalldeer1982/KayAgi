# 题目信息

# [ABC184D] increment of coins

## 题目描述

袋子里原本有金币 $ A $ 枚、银币 $ B $ 枚、铜币 $ C $ 枚。

直到袋子中有一种硬币达到 $100$ 枚之前，都会进行以下操作。

操作：每秒钟都有 $1$ 枚硬币被等概率地取出，然后向袋子中放入两枚相同的硬币。

求出操作次数的数学期望。

## 说明/提示

- $ 0\ \leq\ A,B,C\ \leq\ 99 $
- $ A+B+C\ \geq\ 1 $

### 【样例解释1】 

不论第一次操作取出哪种硬币，袋中都会出现 $ 100 $ 枚该种硬币。

### 【样例解释2】 

我们只会在第一次取出金币的情况下进行第二次操作，操作次数的数学期望为 $ 2\times\ \frac{98}{98+99+99}+1\times\ \frac{99}{98+99+99}+1\times\ \frac{99}{98+99+99}=1.331081081\ldots $。

### 【样例解释3】 

每次操作只会取出铜币

## 样例 #1

### 输入

```
99 99 99```

### 输出

```
1.000000000```

## 样例 #2

### 输入

```
98 99 99```

### 输出

```
1.331081081```

## 样例 #3

### 输入

```
0 0 1```

### 输出

```
99.000000000```

## 样例 #4

### 输入

```
31 41 59```

### 输出

```
91.835008202```

# AI分析结果



### 题目内容翻译

袋子里原本有金币 $ A $ 枚、银币 $ B $ 枚、铜币 $ C $ 枚。

直到袋子中有一种硬币达到 $100$ 枚之前，都会进行以下操作。

操作：每秒钟都有 $1$ 枚硬币被等概率地取出，然后向袋子中放入两枚相同的硬币。

求出操作次数的数学期望。

### 算法分类
动态规划/概率论

---

### 题解综合分析

#### 核心思路与算法要点
所有题解均基于**期望动态规划**，核心思路为：
1. 定义状态：$dp[i][j][k]$ 表示当前有 $i$ 金币、$j$ 银币、$k$ 铜币时的期望操作次数
2. 终止条件：任一硬币数 $\geq 100$ 时返回 $0$
3. 状态转移：$dp[i][j][k] = \sum (子状态期望 + 1) \times 概率$，其中概率由硬币数占比决定
4. 实现方式：记忆化搜索或递推倒序计算

#### 解决难点
1. 状态转移方向：必须**倒推**以保证无后效性
2. 概率计算：每个硬币的选取概率需用当前总数作分母
3. 精度处理：使用浮点数存储状态，避免整数溢出

---

### 精选题解（评分≥4星）

#### 1. xuchuhan（5星）
**亮点**：
- 记忆化搜索实现更易处理边界条件
- 代码可读性极佳，递归终止条件清晰
- 初始化逻辑完整，注释明确

**核心代码**：
```cpp
double DFS(int x,int y,int z) {
    if(x>=100||y>=100||z>=100) return 0;
    if(dp[x][y][z]!=-1) return dp[x][y][z];
    
    double tmp = 0;
    int sum = x+y+z;
    if(x) tmp += (DFS(x+1,y,z)+1) * x/sum;
    if(y) tmp += (DFS(x,y+1,z)+1) * y/sum;
    if(z) tmp += (DFS(x,y,z+1)+1) * z/sum;
    
    return dp[x][y][z] = tmp;
}
```

#### 2. Meickol（4.5星）
**亮点**：
- 提供两种解法对比（概率DP/期望DP）
- 递推式优化：将+1提到概率计算外
- 代码简洁高效，三重循环倒序处理

**核心实现**：
```cpp
for(int i=99; i>=a; i--)
    for(int j=99; j>=b; j--)
        for(int k=99; k>=c; k--) {
            double p = i+j+k;
            dp[i][j][k] = 1 + (i* dp[i+1][j][k]
                              + j* dp[i][j+1][k]
                              + k* dp[i][j][k+1])/p;
        }
```

#### 3. _hxh（4星）
**亮点**：
- 数学推导清晰，强调+1的来源
- 代码极简，直接三重循环实现
- 红字标注关键计算逻辑

**个人心得**：
> "加1是因为从子状态转移需要一次操作"，此注释点明易错点

---

### 关键技巧总结
1. **状态压缩**：三维状态仅需存储到100，利用硬币数量单调递增特性
2. **浮点优化**：提前计算分母(i+j+k)避免重复运算
3. **实现选择**：数据量小（100^3=1e6）时递推更优，递归更易写边界

---

### 拓展训练
1. 同类期望题：[P1850 换教室](https://www.luogu.com.cn/problem/P1850)
2. 概率模型题：[P4550 收集邮票](https://www.luogu.com.cn/problem/P4550)
3. 经典期望DP：[AT_dp_j Sushi](https://atcoder.jp/contests/dp/tasks/dp_j)

---
处理用时：60.98秒
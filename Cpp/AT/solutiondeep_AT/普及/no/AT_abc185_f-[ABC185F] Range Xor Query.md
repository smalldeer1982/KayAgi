# 题目信息

# [ABC185F] Range Xor Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc185/tasks/abc185_f

長さ $ N $ の整数列 $ A $ があります。  
 あなたは今からこの数列について $ Q $ 個のクエリを処理します。$ i $ 番目のクエリでは、 $ T_i,\ X_i,\ Y_i $ が与えられるので、以下の処理をしてください。

- $ T_i\ =\ 1 $ のとき  
   $ A_{X_i} $ を $ A_{X_i}\ \oplus\ Y_i $ で置き換える
- $ T_i\ =\ 2 $ のとき  
   $ A_{X_i}\ \oplus\ A_{X_i\ +\ 1}\ \oplus\ A_{X_i\ +\ 2}\ \oplus\ \dots\ \oplus\ A_{Y_i} $ を出力する

ただし $ a\ \oplus\ b $ は $ a $ と $ b $ のビット単位 xor を表します。  
 ビット単位 xor とは  整数 $ A,\ B $ のビット単位 xor 、$ A\ \oplus\ B $ は、以下のように定義されます。

\- $ A\ \oplus\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \oplus\ 101\ =\ 110 $)。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 300000 $
- $ 1\ \le\ Q\ \le\ 300000 $
- $ 0\ \le\ A_i\ \lt\ 2^{30} $
- $ T_i $ は $ 1 $ または $ 2 $
- $ T_i\ =\ 1 $ なら $ 1\ \le\ X_i\ \le\ N $ かつ $ 0\ \le\ Y_i\ \lt\ 2^{30} $
- $ T_i\ =\ 2 $ なら $ 1\ \le\ X_i\ \le\ Y_i\ \le\ N $
- 入力は全て整数

### Sample Explanation 1

$ 1 $ 個目のクエリでは $ 1\ \oplus\ 2\ \oplus\ 3\ =\ 0 $ を出力します。 $ 2 $ 個目のクエリでは $ 2\ \oplus\ 3\ =\ 1 $ を出力します。 $ 3 $ 個目のクエリでは $ A_2 $ が $ 2\ \oplus\ 3\ =\ 1 $ で置き換えられます。 $ 4 $ 個目のクエリでは $ 1\ \oplus\ 3\ =\ 2 $ を出力します。

## 样例 #1

### 输入

```
3 4

1 2 3

2 1 3

2 2 3

1 2 3

2 2 3```

### 输出

```
0

1

2```

## 样例 #2

### 输入

```
10 10

0 5 3 4 7 0 0 0 1 0

1 10 7

2 8 9

2 3 6

2 1 6

2 1 10

1 9 4

1 6 1

1 6 3

1 1 7

2 3 5```

### 输出

```
1

0

5

3

0```

# AI分析结果



题目重写：

# [ABC185F] 区间异或查询

## 题目描述

给定长度为 $N$ 的整数序列 $A$，处理 $Q$ 个查询：

1. 将 $A_{X_i}$ 修改为 $A_{X_i} \oplus Y_i$（$\oplus$ 表示异或）
2. 输出区间 $[X_i, Y_i]$ 内元素的异或和

## 输入输出要求
- 输入包含 $N, Q$ 及初始数组
- 每个查询给出操作类型及参数
- 对每个类型2查询输出结果

算法分类：树状数组

---

### 题解综合分析

所有题解均采用维护前缀异或和的思路，核心差异在数据结构选择：
- **树状数组**（4篇）：利用异或的自反性（$a \oplus a = 0$），将区间查询转化为两次前缀异或的异或操作
- **线段树**（1篇）：直接维护区间异或和，适用于更复杂的区间操作场景

**关键技巧**：利用异或运算的自反性，将区间查询 $[l,r]$ 转换为 $prefix[r] \oplus prefix[l-1]$，其中 $prefix[i]$ 表示前 $i$ 个元素的异或和。

---

### 精选题解（评分≥4⭐）

#### 1. 题解作者：tZEROちゃん（5⭐）
**亮点**：最简洁的树状数组实现，直接揭示问题本质  
**代码核心**：
```cpp
int c[N], n;
void add(int x, int v) { 
    while(x <= n) c[x] ^= v, x += x&-x; 
}
int query(int x) {
    int res = 0;
    while(x) res ^= c[x], x -= x&-x;
    return res;
}
```
- 修改时在树状数组对应位置异或值
- 查询时取两前缀异或的异或值

#### 2. 题解作者：loser_seele（4.5⭐）
**亮点**：指出问题模板性质，强调异或前缀和的应用  
**关键思路**：
```cpp
cout << (query(r) ^ query(l-1)) << endl;
```
- 直接调用树状数组查询两次前缀异或

#### 3. 题解作者：andyli（4⭐）
**亮点**：Python实现展示异或树状数组的通用性  
**代码核心**：
```python
def query(x):
    ans = 0
    while x > 0: ans ^= c[x-1]; x -= x&-x
    return ans
```
- 使用列表模拟树状数组，展示算法语言无关性

---

### 同类题目推荐
1. [P3374 树状数组1](https://www.luogu.com.cn/problem/P3374)（模板题）
2. [P3368 树状数组2](https://www.luogu.com.cn/problem/P3368)（区间修改）
3. [P5357 AC自动机（二次加强版）](https://www.luogu.com.cn/problem/P5357)（位运算结合字符串）

---

### 调试心得摘录
- **scp020**：线段树实现时注意动态开点的内存管理
- **tZEROちゃん**：强调树状数组的修改操作本质是前缀传播异或值
- **loser_seele**："怎么会有这么板子的题目放在F题" → 熟练掌握模板的重要性

---
处理用时：57.59秒
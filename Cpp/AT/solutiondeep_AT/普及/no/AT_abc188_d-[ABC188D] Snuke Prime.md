# 题目信息

# [ABC188D] Snuke Prime

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc188/tasks/abc188_d

株式会社すぬけは様々なサービスを提供しています。  
 この会社は、すぬけプライムという支払いプランを用意しています。  
 すぬけプライムへの加入中は、$ 1 $ 日あたり $ C $ 円を支払うことで、提供される全てのサービスを追加料金の支払いなしに利用することができます。  
 すぬけプライムへの加入および脱退は、それぞれ $ 1 $ 日の始めおよび終わりに自由に行うことができます。

高橋くんは、この会社のサービスのうち $ N $ 個を利用しようとしています。  
 そのうち $ i $ 個目のサービスは、今日を $ 1 $ 日目として、$ a_i $ 日目の始めから $ b_i $ 日目の終わりまで利用する予定です。  
 すぬけプライムに加入していない期間中は、$ i $ 個目のサービスを利用する際に $ 1 $ 日あたり $ c_i $ 円を支払う必要があります。

サービスを利用するために高橋くんが支払う必要のある最小の合計金額を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ C\ \leq\ 10^9 $
- $ 1\ \leq\ a_i\ \leq\ b_i\ \leq\ 10^9 $
- $ 1\ \leq\ c_i\ \leq\ 10^9 $
- 入力に含まれる値は全て整数

### Sample Explanation 1

$ 1 $ 番目のサービスは $ 1 $ 日目と $ 2 $ 日目に、 $ 2 $ 番目のサービスは $ 2 $ 日目に利用します。 $ 2 $ 日目のみすぬけプライムに加入すると、 $ 1 $ 日目に $ 4 $ 円、 $ 2 $ 日目に $ 6 $ 円がかかるため、高橋くんが支払う合計金額は $ 10 $ 円です。 高橋くんが支払う金額を $ 10 $ 円より少なくすることはできないため、 $ 10 $ を出力します。

### Sample Explanation 2

すぬけプライムに全く加入しないのが最適です。

## 样例 #1

### 输入

```
2 6

1 2 4

2 2 4```

### 输出

```
10```

## 样例 #2

### 输入

```
5 1000000000

583563238 820642330 44577

136809000 653199778 90962

54601291 785892285 50554

5797762 453599267 65697

468677897 916692569 87409```

### 输出

```
163089627821228```

## 样例 #3

### 输入

```
5 100000

583563238 820642330 44577

136809000 653199778 90962

54601291 785892285 50554

5797762 453599267 65697

468677897 916692569 87409```

### 输出

```
88206004785464```

# AI分析结果



# [ABC188D] Snuke Prime

## 题目描述

株式会社すぬけ提供各种服务，并推出了"すぬけプライム"会员计划。加入会员后每天支付C日元即可免费使用所有服务。高桥君计划使用N个服务，每个服务的使用期为a_i到b_i天（包含首尾两天）。非会员期间使用服务i每天需支付c_i日元。求最小总费用。

**输入格式**  
第一行包含两个整数N和C  
接下来N行每行三个整数a_i, b_i, c_i  

**输出格式**  
输出最小总费用

**数据范围**  
- 1 ≤ N ≤ 2×10⁵  
- 1 ≤ C ≤ 10⁹  
- 1 ≤ a_i ≤ b_i ≤ 10⁹  
- 1 ≤ c_i ≤ 10⁹  

---

**算法分类**  
差分 + 离散化

---

### 关键思路解析

1. **事件点差分**：将每个服务拆分为两个事件点：
   - a_i处增加c_i
   - b_i+1处减少c_i
2. **时间轴排序**：将所有事件点按时间排序
3. **区间费用计算**：依次处理相邻事件点构成的区间，计算区间长度与费用的乘积
4. **最优选择**：每个区间取会员费C与常规费用的较小值

---

### 精选题解

#### 题解1：ikunTLE（★★★★★）
**亮点**：
- 使用map自动维护有序事件点
- 简洁的差分处理逻辑
- O(N log N)时间复杂度

```cpp
map<int,int> mp;
signed main(){
    int n=read(),c=read();
    while(n--){
        int a=read(),b=read(),cc=read();
        mp[a]+=cc, mp[b+1]-=cc;
    }
    int ans=0,sum=0,p=0;
    for(auto i:mp){
        ans += (i.first-p)*min(sum,c);
        p = i.first;
        sum += i.second;
    }
    printf("%lld\n",ans);
}
```

#### 题解2：xibaohe（★★★★☆）
**亮点**：
- 详细的代码注释
- 变量命名清晰易读
- 完整的事件处理流程

```cpp
map<int, long long> s;
int main(){
    // 事件点处理
    for(int i=1;i<=n;i++){
        cin >> a >> b >> c;
        s[a] += c;
        s[b+1] -= c;
    }
    // 遍历计算
    int last=0, sum=0;
    for(auto it : s){
        ans += (it.first-last)*min(C,sum);
        last = it.first;
        sum += it.second;
    }
}
```

#### 题解3：Kyl_in_2024（★★★★☆）
**亮点**：
- 使用pair数组替代map
- 更优的空间效率
- 详细的过程推导

```cpp
pair<int,int> a[400005];
signed main(){
    // 将事件存入数组并排序
    for(int i=1;i<=n;i++){
        a[2*i-1] = {x, z};
        a[2*i] = {y+1, -z};
    }
    sort(a+1, a+2*n+1);
    // 线性处理事件
    int now=0, lst=0;
    for(int i=1;i<=2*n;i++){
        ans += (a[i].first-lst)*min(c,now);
        now += a[i].second;
        lst = a[i].first;
    }
}
```

---

### 关键技巧总结

1. **离散化处理**：通过map或排序将1e9量级的时间点压缩为O(N)级别  
2. **时间窗口计算**：利用相邻事件点的差值计算区间长度  
3. **费用动态维护**：使用差分累加方式实时计算当前总费用  
4. **类型溢出防护**：统一使用long long避免中间结果溢出  

---

### 同类题目推荐

1. **P3406 海底高铁**（差分+前缀和）  
2. **P1719 最大矩形**（扫描线思想）  
3. **P3667 区间**（区间覆盖优化）

---

### 心得摘录

> "十年OI一场空，不开long long见祖宗" —— 多篇题解共同指出数据范围陷阱，强调必须使用long long类型。这提醒我们在处理大范围数据时，要特别注意中间计算过程的溢出问题。此外，利用STL的有序特性（如map）可以简化离散化步骤，是处理此类问题的常用技巧。

---
处理用时：50.23秒
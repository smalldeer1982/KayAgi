# 题目信息

# [ABC188E] Peddler

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc188/tasks/abc188_e

高橋国には、町 $ 1 $ から町 $ N $ までの $ N $ 個の町があります。  
 また、この国には道 $ 1 $ から道 $ M $ までの $ M $ 本の道があります。道 $ i $ を使うと、町 $ X_i $ から町 $ Y_i $ へ移動することができます。逆向きへは移動できません。ここで $ X_i\ <\ Y_i $ であることが保証されます。  
 この国では金の取引が盛んであり、町 $ i $ では、金 $ 1\,\mathrm{kg} $ を $ A_i $ 円で売ったり買ったりすることができます。

旅商人である高橋君は、高橋国内のある町で金を $ 1\,\mathrm{kg} $ だけ買い、いくつかの道を使った後、**買った町とは別の町で**金を $ 1\,\mathrm{kg} $ だけ売ろうと考えています。  
 このとき、高橋君の利益 (すなわち $ ( $金を売った価格$ )\ -\ ( $金を買った価格$ ) $) として考えられる最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ M\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
- $ 1\ \le\ X_i\ \lt\ Y_i\ \le\ N $
- $ (X_i,\ Y_i)\ \neq\ (X_j,\ Y_j)\ (i\ \neq\ j) $
- 入力に含まれる値は全て整数

### Sample Explanation 1

以下のようにして利益 $ 3 $ 円を達成できます。 - 町 $ 1 $ で $ 2 $ 円で金 $ 1\,\mathrm{kg} $ を買う - 道 $ 2 $ を使って町 $ 2 $ に移動する - 道 $ 1 $ を使って町 $ 4 $ に移動する - 町 $ 4 $ で $ 5 $ 円で金 $ 1\,\mathrm{kg} $ を売る

### Sample Explanation 2

以下のようにして利益 $ 10 $ 円を達成できます。 - 町 $ 2 $ で $ 8 $ 円で金 $ 1\,\mathrm{kg} $ を買う - 道 $ 1 $ を使って町 $ 4 $ に移動する - 道 $ 3 $ を使って町 $ 5 $ に移動する - 町 $ 5 $ で $ 18 $ 円で金 $ 1\,\mathrm{kg} $ を売る

### Sample Explanation 3

金を買った町で売ることはできないため、答えが負になる可能性があることに注意してください。

## 样例 #1

### 输入

```
4 3

2 3 1 5

2 4

1 2

1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
5 5

13 8 3 15 18

2 4

1 2

4 5

2 3

1 3```

### 输出

```
10```

## 样例 #3

### 输入

```
3 1

1 100 1

2 3```

### 输出

```
-99```

# AI分析结果



# Peddler

## 题目描述

高桥国包含编号为 1 到 N 的 N 个城镇，以及 M 条单向道路。每条道路从编号较小的城镇指向较大的城镇。每个城镇都有不同的黄金买卖价格。求从某个城镇买入黄金后，通过若干道路到达另一城镇卖出能获得的最大利润。

## 标签
动态规划

## 题解综合分析
本题核心在于利用DAG性质进行动态规划。各题解主要思路分为两类：维护后续可到达点的最大卖出价，或维护前驱路径的最小买入价。最优解法通过拓扑序处理边来更新极值，时间复杂度均为 O(n+m)。

## 精选题解

### 1. sunzz3183（5星）
**亮点**：  
- 巧妙按终点排序边，保证处理顺序正确性  
- 单次遍历边时同步更新最小买入价与最大利润  
- 代码简洁高效，时间复杂度严格线性  

**核心代码**：  
```cpp
sort(q+1,q+m+1,[](qwq x,qwq y){return x.r==y.r?x.l<y.l:x.r<y.r;});
for(int i=1;i<=m;i++){
    ans=max(ans,a[q[i].r]-mia[q[i].l]);
    mia[q[i].r]=min(mia[q[i].r],mia[q[i].l]);
}
```
**思路**：将边按终点升序排列，遍历时用起点最小买入价更新终点的最小价，同时计算当前边产生的利润。

---

### 2. xuchuhan（4星）
**亮点**：  
- 反图DFS实现记忆化搜索  
- 维护能到达当前点的所有前驱最小价  
- 代码逻辑清晰，空间优化良好  

**核心代码**：  
```cpp
int DFS(int x){
    if(dp[x]!=inf)return dp[x];
    int tmp=inf;
    for(int i=0;i<v[x].size();i++)
        tmp=min(tmp,min(DFS(v[x][i]),a[v[x][i]]));
    return dp[x]=tmp;
}
```
**思路**：对每个点求能到达它的所有前驱的最小买入价，通过反图递归实现记忆化。

---

### 3. xmy201315（4星）
**亮点**：  
- 直观维护前驱路径最小买入价  
- 特判边界提升效率  
- 代码可读性极佳  

**核心代码**：  
```cpp
for(int i=1;i<=m;++i){
    ans=max(ans,a[e[i].v]-dp[e[i].u]);
    dp[e[i].v]=min(dp[e[i].v],dp[e[i].u]);
}
```
**思路**：遍历所有边时，用起点的最小价更新终点的最小价，并立即计算当前边可能产生的利润。

---

## 最优技巧总结
**关键思路**：  
1. 利用DAG的拓扑序性质，按特定顺序处理边或节点  
2. 动态维护每个节点的极值（最小买入价或最大卖出价）  
3. 在边处理过程中即时更新答案，避免二次遍历  

**同类型拓展**：  
- DAG上的最长路径：维护每个节点的最大前驱值  
- 拓扑排序结合动态规划：如任务调度问题  

## 推荐习题
1. P3387 【模板】缩点（DAG动态规划经典）  
2. P3007 [USACO11JAN] 大陆扩散（DAG上的最值维护）  
3. P1144 最短路计数（DAG上的路径统计）  

## 心得体会摘录
"突然意识到边排序后处理可以保证前驱已计算，这个顿悟让代码量减少一半" —— sunzz3183  
"反向建图让DFS方向与问题方向一致，这个视角转换是解题关键" —— xuchuhan  
"特判n=2的情况后发现无需特殊处理，提醒我要相信算法完备性" —— xmy201315

---
处理用时：56.75秒
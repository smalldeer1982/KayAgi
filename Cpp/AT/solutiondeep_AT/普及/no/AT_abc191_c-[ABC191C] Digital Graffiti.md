# 题目信息

# [ABC191C] Digital Graffiti

## 题目描述

有一个 $H$ 行 $W$ 列的表格，格子要么为黑色，用‘#’表示，要么为白色，用‘.’表示。第一行和最后一行，第一列和最后一列都是白色格子。 考虑黑色部分组成的多边形，问多边形有多少条边？ 保证表格中，黑色部分为四联通区域，白色部分也为四联通区域。所谓四联通，即通过上、下、左、右四个方向，可以访问所有格子。 表格中至少存在一个黑色格子。

## 说明/提示

$3 \leq H \leq 10, 3 \leq W \leq 10$

## 样例 #1

### 输入

```
5 5

.....

.###.

.###.

.###.

.....```

### 输出

```
4```

# AI分析结果



# [ABC191C] Digital Graffiti

## 题目描述

有一个 $H$ 行 $W$ 列的表格，格子要么为黑色（用`#`表示），要么为白色（用`.`表示）。第一行和最后一行、第一列和最后一列都是白色格子。考虑黑色部分组成的多边形，问该多边形有多少条边？  
保证黑色部分和白色部分均为四联通区域，且至少存在一个黑色格子。

## 算法分类
模拟、数学

---

### 关键思路与技巧
**核心观察**：多边形边数等于所有 2x2 子矩阵中黑色格子数为奇数的个数。  
- 每个 2x2 的子矩阵若包含 1 或 3 个黑色格子，则对应多边形的一个顶点。  
- 简单多边形的顶点数等于边数，因此只需统计此类子矩阵的数量即可。

**实现技巧**：  
1. 遍历所有可能的 2x2 子矩阵（共 $(H-1) \times (W-1)$ 个）。  
2. 对每个子矩阵，统计其中黑色格子数是否为奇数。  
3. 累加所有满足条件的子矩阵数量，即为答案。

---

### 示例代码
```cpp
#include <iostream>
using namespace std;

int main() {
    int H, W;
    cin >> H >> W;
    char grid[H][W];
    for (int i = 0; i < H; ++i)
        for (int j = 0; j < W; ++j)
            cin >> grid[i][j];
    
    int ans = 0;
    for (int i = 0; i < H-1; ++i) {
        for (int j = 0; j < W-1; ++j) {
            int cnt = 0;
            cnt += (grid[i][j] == '#');
            cnt += (grid[i][j+1] == '#');
            cnt += (grid[i+1][j] == '#');
            cnt += (grid[i+1][j+1] == '#');
            if (cnt == 1 || cnt == 3)
                ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

### 拓展与相似题目
1. **P1357 矩形覆盖**（类似二维矩阵遍历与条件统计）  
2. **P2735 电网**（几何图形的边数计算与数学建模）  
3. **P1162 填涂颜色**（四联通区域遍历与边界判断）

---
处理用时：123.87秒
# 题目信息

# [ABC192E] Train

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc192/tasks/abc192_e

AtCoder国には $ 1 $ から $ N $ の番号がついた $ N $ 個の都市と、$ 1 $ から $ M $ の番号がついた $ M $ 本の鉄道があります。

鉄道 $ i $ は都市 $ A_i $ と都市 $ B_i $ の間を結んでおり、時刻が $ K_i $ の倍数になる毎に、双方の都市からそれぞれ他方の都市への列車が発車します。この列車は出発から到着までに $ T_i $ の時間がかかります。

あなたはいま都市 $ X $ にいます。時刻 $ 0 $ またはそれ以降に都市 $ X $ を発車する列車に乗って移動を開始するとき、都市 $ Y $ には最速でいつたどり着けるか求めてください。都市 $ Y $ にたどり着くことが出来ない場合はそのことを報告してください。  
 ただし、乗り換えにかかる時間は無視できるため、どの都市においても、あなたの乗っている列車の到着時刻と同時に発車する別の列車に乗り換えることが可能であるとします。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X,Y\ \leq\ N $
- $ X\ \neq\ Y $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ A_i\ \neq\ B_i $
- $ 1\ \leq\ T_i\ \leq\ 10^9 $
- $ 1\ \leq\ K_i\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

まず、時刻 $ 0 $ に鉄道 $ 1 $ に乗って、都市 $ 1 $ から都市 $ 2 $ へ移動します。都市 $ 2 $ には時刻 $ 2 $ に到着します。 その後、時刻 $ 4 $ に鉄道 $ 2 $ に乗って、都市 $ 2 $ から都市 $ 3 $ へ移動します。都市 $ 3 $ には時刻 $ 7 $ に到着します。 これより早く都市 $ 3 $ に着く方法はありません。

### Sample Explanation 2

まず、時刻 $ 0 $ に鉄道 $ 2 $ に乗って、都市 $ 3 $ から都市 $ 2 $ へ移動します。都市 $ 2 $ には時刻 $ 3 $ に到着します。 その後、時刻 $ 3 $ に鉄道 $ 1 $ に乗って、都市 $ 2 $ から都市 $ 1 $ へ移動します。都市 $ 1 $ には時刻 $ 5 $ に到着します。

## 样例 #1

### 输入

```
3 2 1 3

1 2 2 3

2 3 3 4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 2 3 1

1 2 2 3

2 3 3 4```

### 输出

```
5```

## 样例 #3

### 输入

```
3 0 3 1```

### 输出

```
-1```

## 样例 #4

### 输入

```
9 14 6 7

3 1 4 1

5 9 2 6

5 3 5 8

9 7 9 3

2 3 8 4

6 2 6 4

3 8 3 2

7 9 5 2

8 4 1 9

7 1 6 9

3 9 9 3

7 5 1 5

8 2 9 7

4 9 4 4```

### 输出

```
26```

# AI分析结果



# [ABC192E] Train

## 题目描述

AtCoder国有编号为1到N的N个城市和编号为1到M的M条铁路。  
每条铁路i连接城市A_i和B_i，每隔K_i的倍数时刻就会从两端城市对开发车，列车行驶时间为T_i。  
求从城市X出发，最早何时能到达城市Y。若无法到达输出-1。  
注：换乘时间可忽略，同一时刻到站可立即换乘其他列车。

## 分类
最短路

---

## 综合分析与结论
题目本质是带时间约束的最短路问题，所有题解均采用Dijkstra算法框架，关键差异在于等待时间的计算方式。最优解法需满足：
1. 使用优先队列维护当前最短时间
2. 松弛时计算等待时间：`等待时间 = (K - (当前时间%K))%K`
3. 正确初始化距离数组为极大值（需用long long范围）

---

## 高星题解推荐

### 1. xuchuhan 题解（⭐⭐⭐⭐⭐）
**核心亮点**：  
- 最规范的Dijkstra实现
- 等待时间公式`(K - dis[u]%K)%K`简洁优雅
- 使用0x3f初始化但正确处理long long极值判断

**关键代码**：
```cpp
int w = v[tx][i].val + ((tim - dis[tx]%tim)%tim);
if(dis[to] > dis[tx] + w) {
    dis[to] = dis[tx] + w;
    q.push({to,dis[to]});
}
```

### 2. Tachibana27 题解（⭐⭐⭐⭐）
**核心亮点**：  
- 给出完整的模运算推导过程
- 强调long long初始化的陷阱（不使用0x3f）
- 代码包含详细注释，适合新手理解

**关键实现**：
```cpp
// 计算等待时间
int y = (dis[x] % i.k);
y = y ? i.k - y : 0;
// 松弛操作
if(dis[v] > dis[x] + y + i.w) {
    dis[v] = dis[x] + y + i.w;
    q.push({v, dis[v]});
}
```

### 3. RioFutaba 题解（⭐⭐⭐⭐）
**核心亮点**：  
- 代码结构最简洁
- 使用链式前向星存图节省空间
- 将等待时间计算封装为独立函数

**关键片段**：
```cpp
ll wait(int x,int t){return (t - x%t)%t;} 

void dijkstra(){
    // 初始化略
    while(!q.empty()){
        ll tm = (k[i]-dis[u]%k[i])%k[i];
        if(dis[v] > dis[u] + tm + t[i]){
            dis[v] = dis[u] + tm + t[i];
            q.push({v,dis[v]});
        }
    }
}
```

---

## 关键思路总结
**算法选择**：  
优先采用堆优化Dijkstra算法，时间复杂度O(MlogN)

**核心公式**：  
等待时间 = `(K - (当前时间%K)) % K`  
总耗时 = `当前时间 + 等待时间 + 行驶时间`

**实现要点**：  
1. 距离数组初始化为1e18量级的极大值
2. 优先队列按时间升序排列
3. 双向存边处理无向图特性
4. 使用long long避免整型溢出

---

## 同类型题目推荐
1. [P9751 [CSP-J 2023] 旅游巴士](https://www.luogu.com.cn/problem/P9751) - 分层图+时间约束最短路
2. [P5663 加工零件](https://www.luogu.com.cn/problem/P5663) - 奇偶最短路思想
3. [P1354 房间最短路问题](https://www.luogu.com.cn/problem/P1354) - 带几何约束的最短路

---
处理用时：46.06秒
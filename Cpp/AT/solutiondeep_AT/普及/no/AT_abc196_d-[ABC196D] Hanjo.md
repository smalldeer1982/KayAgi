# 题目信息

# [ABC196D] Hanjo

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc196/tasks/abc196_d

縦 $ H $ メートル、横 $ W $ メートルの長方形の部屋があります。  
 この部屋に $ 2 $ メートル $ × $ $ 1 $ メートルの区別できない畳 (長方形のタイル) $ A $ 枚と、$ 1 $ メートル $ × $ $ 1 $ メートルの区別できない半畳 (正方形のタイル) $ B $ 枚を敷き詰めます。 $ 2 $ メートル $ × $ $ 1 $ メートルの畳は縦長にも横長にも使うことができます。  
 敷き詰める方法は何通りあるでしょうか？  
 なお、$ 2A\ +\ B\ =\ HW $ であることが保証されます。 また、回転や反転を行うことで初めて一致するような敷き詰め方は区別します。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ <\ =\ H,\ W $
- $ HW\ <\ =\ 16 $
- $ 0\ <\ =\ A,\ B $
- $ 2A\ +\ B\ =\ HW $

### Sample Explanation 1

以下の $ 4 $ つです。 !\[\](https://img.atcoder.jp/ghi/d01b63c75c91bd87a73e9a4cc43dda28.png)

### Sample Explanation 2

以下の $ 6 $ つと、これらを回転させたものが含まれます。 !\[\](https://img.atcoder.jp/ghi/b7a492abe22e30683e8f9a7b309acd52.png)

## 样例 #1

### 输入

```
2 2 1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
3 3 4 1```

### 输出

```
18```

## 样例 #3

### 输入

```
4 4 8 0```

### 输出

```
36```

# AI分析结果



# [ABC196D] Hanjo 题解

## 题目描述

给定一个纵 $H$ 米、横 $W$ 米的长方形房间。需要在此房间中铺设 $A$ 块不可区分的 $2 \times 1$ 畳（长方形瓷砖）和 $B$ 块不可区分的 $1 \times 1$ 半畳（正方形瓷砖）。畳可以纵向或横向使用。求所有不同的铺法总数（旋转或翻转后相同的方案视为不同）。保证 $2A + B = HW$。

**算法分类**：深度优先搜索（DFS）

---

## 题解对比与分析

### 综合结论
所有题解均采用深度优先搜索（DFS）的回溯策略，核心思路为按行列顺序枚举每个格子的填充方式。关键差异在于状态表示方式（位掩码或二维数组）和递归参数的设定。最优解法通过二维数组记录覆盖状态，逐格填充并剪枝，在可读性与效率间取得平衡。

---

## ★★★★★ 题解精选（sybs1145）

### 关键亮点
- 使用 `vis[][]` 二维数组记录覆盖状态，直观易懂。
- 按行列顺序遍历，避免重复计算。
- 清晰的递归终止条件和方向处理逻辑。

### 核心代码
```cpp
void dfs(int x, int y) {
    if (x > h) { ans++; return; }          // 完全覆盖，答案+1
    if (y > w) { dfs(x+1, 1); return; }    // 换行处理
    if (vis[x][y]) { dfs(x, y+1); return; }// 已覆盖则跳过
    
    if (A > 0) { // 尝试放置2x1瓷砖
        A--;
        // 横向放置
        if (y < w && !vis[x][y+1]) {
            vis[x][y+1] = 1;
            dfs(x, y+1);
            vis[x][y+1] = 0;
        }
        // 纵向放置
        if (x < h && !vis[x+1][y]) {
            vis[x+1][y] = 1;
            dfs(x, y+1);
            vis[x+1][y] = 0;
        }
        A++;
    }
    if (B > 0) { // 放置1x1瓷砖
        B--;
        dfs(x, y+1);
        B++;
    }
}
```

### 实现思路
1. **遍历顺序**：从上至下、从左至右逐个处理格子。
2. **状态回溯**：每次尝试放置瓷砖后标记占用，递归返回时恢复状态。
3. **剪枝**：仅在剩余瓷砖数量合法时继续搜索。

---

## ★★★★☆ 题解精选（loser_seele）

### 关键亮点
- 参数中直接携带剩余瓷砖数量，逻辑紧凑。
- 利用坐标偏移量统一处理不同方向。

### 代码片段
```cpp
long long dfs(int i, int j, int a, int b) {
    if (i == H) return 1;
    if (j == W) return dfs(i+1, 0, a, b); // 换行
    if (used[i][j]) return dfs(i, j+1, a, b);
    
    long long res = 0;
    used[i][j] = 1;
    res += dfs(i, j+1, a, b-1);           // 放置1x1
    
    if (a > 0) {
        if (j+1 < W && !used[i][j+1]) {    // 横向2x1
            used[i][j+1] = 1;
            res += dfs(i, j+1, a-1, b);
            used[i][j+1] = 0;
        }
        if (i+1 < H && !used[i+1][j]) {   // 纵向2x1
            used[i+1][j] = 1;
            res += dfs(i, j+1, a-1, b);
            used[i+1][j] = 0;
        }
    }
    used[i][j] = 0;
    return res;
}
```

---

## 最优思路总结
1. **顺序填充**：按行优先顺序处理每个未覆盖的格子，避免重复计算。
2. **状态回溯**：通过二维数组记录覆盖状态，递归后即时恢复。
3. **剪枝优化**：在递归前判断剩余瓷砖数量是否合法，减少无效搜索。

---

## 拓展与心得
- **类似题目**：  
  - [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)（DFS+状态压缩）  
  - [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)（剪枝策略）  
  - [P1092 虫食算](https://www.luogu.com.cn/problem/P1092)（搜索顺序优化）  

- **调试心得**：  
  部分题解提到需注意回溯时状态恢复的完整性，例如同时修改横向/纵向的两个格子后必须成对恢复。优先处理边界条件（如换行）能显著减少逻辑错误。

---
处理用时：66.99秒
# 题目信息

# [ABC197C] ORXOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc197/tasks/abc197_c

長さ $ N $ の数列 $ A $ が与えられます。  
 この数列を、$ 1 $ つ以上の空でない連続した区間に分けます。  
 その後、分けた各区間で、区間内の数のビット単位 $ \mathrm{OR} $ を計算します。  
 こうして得られた全ての値のビット単位 $ \mathrm{XOR} $ として考えられる最小値を求めてください。

  ビット単位 $ \mathrm{OR} $ 演算とは  整数 $ A,\ B $ のビット単位 $ \mathrm{OR} $、$ A\ \mathrm{OR}\ B $ は以下のように定義されます。

- $ A\ \mathrm{OR}\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち少なくとも片方が $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \mathrm{OR}\ 5\ =\ 7 $ となります (二進表記すると: $ 011\ \mathrm{OR}\ 101\ =\ 111 $)。  
 一般に $ k $ 個の整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 $ \mathrm{OR} $ は $ (\dots\ ((p_1\ \mathrm{OR}\ p_2)\ \mathrm{OR}\ p_3)\ \mathrm{OR}\ \dots\ \mathrm{OR}\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots\ p_k $ の順番によらないことが証明できます。  ビット単位 $ \mathrm{XOR} $ 演算とは  整数 $ A,\ B $ のビット単位 $ \mathrm{XOR} $ 、$ A\ \mathrm{XOR}\ B $ は、以下のように定義されます。

- $ A\ \mathrm{XOR}\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \mathrm{XOR}\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \mathrm{XOR}\ 101\ =\ 110 $)。  
 一般に $ k $ 個以上の整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 $ \mathrm{XOR} $ は $ (\dots\ ((p_1\ \mathrm{XOR}\ p_2)\ \mathrm{XOR}\ p_3)\ \mathrm{XOR}\ \dots\ \mathrm{XOR}\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots\ p_k $ の順番によらないことが証明できます。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 20 $
- $ 0\ \le\ A_i\ \lt\ 2^{30} $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

$ [1,\ 5,\ 7] $ を $ [1,\ 5] $ と $ [7] $ の $ 2 $ つの区間に分けると、それぞれの区間内の数のビット単位 $ \mathrm{OR} $ は $ 5,\ 7 $ となり、その $ \mathrm{XOR} $ は $ 2 $ です。 これより小さくすることはできないので、$ 2 $ を出力します。

### Sample Explanation 2

$ [10] $ と $ [10,\ 10] $ に分けるとよいです。

### Sample Explanation 3

$ [1,\ 3] $ と $ [3,\ 1] $ に分けるとよいです。

## 样例 #1

### 输入

```
3

1 5 7```

### 输出

```
2```

## 样例 #2

### 输入

```
3

10 10 10```

### 输出

```
0```

## 样例 #3

### 输入

```
4

1 3 3 1```

### 输出

```
0```

# AI分析结果



【题目中文翻译】
# [ABC197C] ORXOR

## 题目描述

给定长度为 $ N $ 的数列 $ A $。  
将数列分成一个或多个非空的连续区间。  
对每个区间内的数进行按位或运算（$\mathrm{OR}$），再将所有区间的结果进行按位异或运算（$\mathrm{XOR}$）。  
求最终异或结果的最小可能值。

## 输入格式

第一行输入 $ N $，第二行输入 $ N $ 个整数 $ A_1, A_2, \dots, A_N $。

## 输出格式

输出最小异或值。

## 说明/提示

### 数据范围
- $ 1 \le N \le 20 $
- $ 0 \le A_i < 2^{30} $

### 样例解释
样例1：分割为 [1,5] 和 [7]，OR 值分别为5和7，XOR结果为2。  
样例2：分割为 [10] 和 [10,10]，OR值异或得0。  
样例3：分割为 [1,3] 和 [3,1]，OR值异或得0。

---

**算法分类**：枚举、位运算

---

### 题解分析与结论

题目要求通过分割数组，使得各区间 OR 值的 XOR 总和最小。核心思路是枚举所有可能的分割方式，计算对应的 XOR 值并取最小。由于 $ N \le 20 $，总共有 $ 2^{N-1} $ 种分割方式，完全可以通过暴力枚举解决。

---

### 精选题解

#### 题解（五星）
**关键思路**：  
1. 用二进制掩码表示分割点的选择，每一位表示是否在该位置分割。  
2. 遍历所有可能的掩码，对每个掩码模拟分割过程，计算区间的 OR 值和最终的 XOR 结果。  
3. 维护最小的 XOR 值。

**代码实现**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto &x : a) cin >> x;
    
    int ans = INT_MAX;
    for (int mask = 0; mask < (1 << (n-1)); ++mask) {
        int current_or = a[0], xor_val = 0;
        for (int i = 0; i < n-1; ++i) {
            if (mask & (1 << i)) {
                xor_val ^= current_or;
                current_or = a[i+1];
            } else {
                current_or |= a[i+1];
            }
        }
        xor_val ^= current_or;
        ans = min(ans, xor_val);
    }
    cout << ans << endl;
    return 0;
}
```

**亮点**：  
- 利用位运算快速枚举分割点，时间复杂度 $ O(2^{N-1} \cdot N) $，完全适用于题目规模。  
- 代码简洁，直接通过按位与操作判断分割点，逻辑清晰。

**个人心得**：  
- 初始 XOR 值应设为0，逐个区间异或 OR 值。  
- 最后一个区间的 OR 值在循环结束后需额外异或一次。

---

### 拓展与同类题目
**相似技巧题目**：  
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)  
2. [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)  
3. [P2392 kkksc03考前临时抱佛脚](https://www.luogu.com.cn/problem/P2392)

---
处理用时：161.85秒
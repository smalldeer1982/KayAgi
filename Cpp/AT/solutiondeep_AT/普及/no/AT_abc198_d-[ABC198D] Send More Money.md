# 题目信息

# [ABC198D] Send More Money

## 题目描述

给你三个由小写字母组成的字符串 $ S_1, S_2, S_3 $。请解出这道覆面算：$ S_1 + S_2 = S_3 $。

具体来说，要求你确定是否存在一组符合以下条件的正整数 $ N_1, N_2, N_3 $，如果存在，请输出其中一个组合：

1. $ N_1, N_2, N_3 $ 分别表示的十进制数字串 $ N'_1, N'_2, N'_3 $ 的长度与对应的字符串 $ S_1, S_2, S_3 $ 的长度相同，并且不含前导零。
2. 满足 $ N_1 + N_2 = N_3 $。
3. 如果 $ S_i $ 的第 $ x $ 个字符和 $ S_j $ 的第 $ y $ 个字符相同，那么 $ N'_i $ 的第 $ x $ 个数字和 $ N'_j $ 的第 $ y $ 个数字也必须相同。

## 说明/提示

- $ S_1, S_2, S_3 $ 是长度在 $ 1 $ 到 $ 10 $ 之间的小写字母字符串。

### 示例解释

在示例 1 中，输出 $ (N_1, N_2, N_3) = (4, 5, 9) $ 是正确的组合，而 $ (1, 1, 2) $ 因不满足条件 3 （例如，字符 `a` 和 `b` 都对应 $ 1 $）因此是错误的。

在示例 2 中，输出 $ (N_1, N_2, N_3) = (3, 3, 6) $ 是一个正确的答案，而 $ (1, 2, 3) $ 因为未满足条件 3（例如，数字 $ 1 $ 和 $ 2 $ 在对应字符 `x` 时不一致）是错误的。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
a

b

c```

### 输出

```
1

2

3```

## 样例 #2

### 输入

```
x

x

y```

### 输出

```
1

1

2```

## 样例 #3

### 输入

```
p

q

p```

### 输出

```
UNSOLVABLE```

## 样例 #4

### 输入

```
abcd

efgh

ijkl```

### 输出

```
UNSOLVABLE```

## 样例 #5

### 输入

```
send

more

money```

### 输出

```
9567

1085

10652```

# AI分析结果



### 题目中文重写
**[ABC198D] Send More Money**

#### 题目描述
给定三个由小写字母组成的字符串 $S_1, S_2, S_3$，解出覆面算 $S_1 + S_2 = S_3$。要求：

1. $N_1, N_2, N_3$ 对应的十进制数字串长度与原字符串相同，且无前导零。
2. $N_1 + N_2 = N_3$。
3. 相同字符必须映射为相同数字，不同字符映射不同数字。

#### 输入输出样例（见原题）

---

### 算法分类
**枚举**

---

### 题解分析与结论

#### 核心思路
1. **字符种类检查**：若三串中不同字符超过10，直接无解（个位数只有10个）。
2. **全排列枚举**：生成0-9的全排列，每个排列对应一种字符→数字的映射方案。
3. **合法性检查**：验证前导零和算式成立。

#### 解决难点
- **高效映射管理**：通过字符索引或映射表快速获取每个字符对应的数字。
- **剪枝优化**：全排列前先检查字符总数，避免无效计算。

---

### 高分题解推荐

#### 1. 作者：__little__Cabbage__（⭐⭐⭐⭐⭐）
**关键亮点**：
- **结构清晰**：预处理字符索引，利用`mp`数组直接映射排列位置。
- **代码优化**：使用`check_nosol`提前判断字符超限，减少无效遍历。
- **高效计算**：在`check`函数中直接处理数值转换，避免多次循环。

**核心代码**：
```cpp
int p[10] = {0,1,2,3,4,5,6,7,8,9};
do {
    if (check(p)) { // 检查当前排列是否合法
        // 输出结果
    }
} while (next_permutation(p, p+10));
```

#### 2. 作者：loser_seele（⭐⭐⭐⭐）
**关键亮点**：
- **动态映射**：使用`map`直接存储字符→数字的映射，代码更直观。
- **简洁性**：合并字符串处理逻辑，减少重复代码。

**核心代码**：
```cpp
map<char, int> mp2;
int j=0;
for (auto i : mp) mp2[i.first] = s[j++]; // s为预存的全排列数组
```

#### 3. 作者：MAX007_CRN（⭐⭐⭐⭐）
**关键亮点**：
- **注释详细**：对`map`操作和边界条件有明确说明。
- **错误处理**：在数值转换时及时跳出无效分支，减少计算量。

---

### 关键技巧总结
1. **全排列生成**：利用STL的`next_permutation`快速生成所有可能的映射。
2. **索引映射优化**：预处理字符到排列位置的映射，避免每次遍历字符集合。
3. **前导零处理**：在转换数字时直接检查首字符是否为0，避免生成无效数值。

---

### 拓展与同类题目
1. **覆面算变体**：如乘法形式 $S_1 \times S_2 = S_3$，需调整数值计算逻辑。
2. **更大规模数据**：若字符数接近10，需进一步剪枝（如按权重排序字符）。

---

### 相似题目推荐
1. **P1008 [NOIP1998 普及组] 三连击**：枚举三位数组合满足比例关系。
2. **P1094 [NOIP2007 普及组] 纪念品分组**：需组合数学思维。
3. **P1217 [USACO1.5] 回文质数**：结合质数判断与回文生成。

---
处理用时：52.80秒
# 题目信息

# [ABC198E] Unique Color

## 题目描述

给定一棵以 $1$ 节点为根的树。每个节点上都被染了一种颜色，不同颜色用不同整数表示。问：有多少个节点，它们到根节点的路径上的所有点（除了自己）的颜色都与自己的颜色不同。

## 样例 #1

### 输入

```
6

2 7 1 8 2 8

1 2

3 6

3 2

4 3

2 5```

### 输出

```
1

2

3

4

6```

## 样例 #2

### 输入

```
10

3 1 4 1 5 9 2 6 5 3

1 2

2 3

3 4

4 5

5 6

6 7

7 8

8 9

9 10```

### 输出

```
1

2

3

5

6

7

8```

# AI分析结果



【题目内容中文翻译】
# [ABC198E] 唯一颜色

## 题目描述

给定一棵以节点1为根的树。每个节点都被染上一种颜色，不同颜色用不同整数表示。求有多少个节点满足：从根节点到该节点的路径上（不包括该节点自身）的所有节点颜色都与其自身颜色不同。

## 样例 #1

### 输入

6
2 7 1 8 2 8
1 2
3 6
3 2
4 3
2 5

### 输出

1
2
3
4
6

## 样例 #2

### 输入

10
3 1 4 1 5 9 2 6 5 3
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10

### 输出

1
2
3
5
6
7
8

【算法分类】
深度优先搜索 DFS

【题解分析与结论】
各题解均采用DFS遍历树结构，核心在于维护颜色出现次数的状态。最优解法使用计数数组记录颜色出现次数，在进入节点时增加计数，回溯时减少计数，通过判断当前颜色是否唯一来统计答案。该方案时间复杂度O(n)，空间优化良好。

【高星题解推荐】
1. _shine_（4星）
   - 亮点：使用vector存储邻接表，代码结构清晰
   - 核心代码：
     ```cpp
     void dfs(int np){
         if(vis[np]) return;
         if(cnt[c[np]]==0) ans[++idx]=np;
         vis[np] = true;
         cnt[c[np]]++;
         for(int v : a[np])
             if(!vis[v]) dfs(v);
         cnt[c[np]]--;
     }
     ```

2. tZEROちゃん（4星）
   - 亮点：简洁的全局变量管理，回溯逻辑明确
   - 核心代码：
     ```cpp
     void dfs(int rt) {
         if (cnt[c[rt]] == 0) ck[rt] = 1;
         cnt[c[rt]]++;
         vis[rt] = 1;
         for (auto v : G[rt]) 
             if (!vis[v]) dfs(v);
         cnt[c[rt]]--;
     }
     ```

3. loser_seele（4星）
   - 亮点：极致简化的代码结构，去除非必要变量
   - 核心代码：
     ```cpp
     void dfs(int x) {
         cnt[col[x]]++;
         vis[x] = 1;
         if(cnt[col[x]]==1) ans[x]=1;
         for(auto v:g[x])
             if(!vis[v]) dfs(v);
         cnt[col[x]]--;
     }
     ```

【关键思路总结】
采用DFS回溯时维护颜色计数数组，通过判断当前节点颜色是否首次出现在路径中来确定答案。该技巧适用于所有需要维护路径状态的树遍历问题。

【拓展建议】
类似问题可考虑以下变种：
- 统计路径中颜色出现恰好k次的节点
- 求最长全唯一颜色路径
- 带权树的最短唯一颜色路径

【推荐练习题】
1. P1351 联合权值（树型DFS+状态维护）
2. P2015 二叉苹果树（树型DP+路径统计）
3. P2668 斗地主（DFS+状态回溯技巧）

---
处理用时：75.71秒
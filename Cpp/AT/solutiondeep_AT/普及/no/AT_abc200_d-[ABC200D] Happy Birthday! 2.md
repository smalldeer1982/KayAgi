# 题目信息

# [ABC200D] Happy Birthday! 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc200/tasks/abc200_d

$ N $ 個の正整数からなる数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ が与えられます。 以下の条件を全て満たす $ 2 $ つの数列 $ B\ =\ (B_1,\ B_2,\ \dots,\ B_x),\ C\ =\ (C_1,\ C_2,\ \dots,\ C_y) $ が存在するか判定し、存在する場合はひとつ出力してください。

- $ 1\ <\ = x,\ y\ <\ =\ N $
- $ 1\ \le\ B_1\ <\ B_2\ <\ \dots\ <\ B_{x}\ \le\ N $
- $ 1\ \le\ C_1\ <\ C_2\ <\ \dots\ <\ C_{y}\ \le\ N $
- $ B $ と $ C $ は、異なる数列である。
  - $ x\ ≠\ y $ のとき、または、ある整数 $ i\ (1\ <\ = i\ <\ = \min(x,\ y)) $ が存在して $ B_i\ ≠\ C_i $ であるとき、$ B $ と $ C $ は異なるものとする。
- $ A_{B_1}\ +\ A_{B_2}\ +\ \dots\ +\ A_{B_x} $ を $ 200 $ で割った余りと $ A_{C_1}\ +\ A_{C_2}\ +\ \dots\ +\ A_{C_y} $ を $ 200 $ で割った余りが等しい。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 2\ \le\ N\ \le\ 200 $
- $ 1\ \le\ A_i\ \le\ 10^9 $

### Sample Explanation 1

$ B=(1),C=(3,4) $ とすると、$ A_1\ =\ 180,\ A_3\ +\ A_4\ =\ 380 $ となり、この $ 2 $ つを $ 200 $ で割った余りは等しくなります。 他にも、以下のような出力も正答として扱われます。 ``` yEs 4 2 3 4 5 3 1 2 5 ```

### Sample Explanation 3

条件を満たす数列の組が存在しない場合、$ 1 $ 行に `No` と出力してください。

## 样例 #1

### 输入

```
5

180 186 189 191 218```

### 输出

```
Yes

1 1

2 3 4```

## 样例 #2

### 输入

```
2

123 523```

### 输出

```
Yes

1 1

1 2```

## 样例 #3

### 输入

```
6

2013 1012 2765 2021 508 6971```

### 输出

```
No```

# AI分析结果



# [ABC200D] Happy Birthday! 2（中文翻译）

## 题目描述

给定包含 $N$ 个正整数的数列 $A = (A_1, A_2, \dots, A_N)$。请判断是否存在满足以下所有条件的两个数列 $B = (B_1, B_2, \dots, B_x)$ 和 $C = (C_1, C_2, \dots, C_y)$，若存在则输出一组解。

条件：
1. $1 \le x, y \le N$
2. $B$ 和 $C$ 的元素均为严格递增的索引（即 $1 \le B_1 < B_2 < \dots \le N$）
3. $B$ 与 $C$ 是不同的数列（长度不同或至少有一个元素不同）
4. $\sum A_{B_i} \equiv \sum A_{C_i} \pmod{200}$

## 输入输出样例
### 样例 #1
**输入**
```
5
180 186 189 191 218
```
**输出**
```
Yes
1 1
2 3 4
```
### 样例 #2
**输入**
```
2
123 523
```
**输出**
```
Yes
1 1
1 2
```
### 样例 #3
**输入**
```
6
2013 1012 2765 2021 508 6971
```
**输出**
```
No
```

---

**算法分类**  
构造

---

### 题解综合分析

所有题解均基于**抽屉原理**（当枚举超过200个序列时必有余数重复），核心思路是：
1. 当 $N \ge 8$ 时，前8个元素可构造 $2^8-1=255$ 种非空子序列，必存在两个余数相同的子序列
2. 对 $\min(N,8)$ 个元素进行二进制枚举，用哈希表记录每个余数对应的子序列索引
3. 发现重复余数时立即输出对应两个子序列

---

### 精选题解（评分≥4★）

#### 1. 题解作者：loser_seele（5★）
**关键亮点**  
- 代码简洁高效，直接处理前8个元素
- 使用位运算快速枚举子序列
- 利用`unordered_map`实时检测余数碰撞

**核心代码**
```cpp
int main() {
    int n; cin >> n;
    int mins = min(n, 8);
    vector<int> w(n);
    for (int i=0; i<n; i++) cin >> w[i];
    
    unordered_map<int, vector<int>> md;
    for (int mask=1; mask < (1<<mins); mask++) {
        int sum = 0;
        vector<int> tmp;
        for (int j=0; j<mins; j++) {
            if (mask >> j & 1) {
                sum = (sum + w[j]) % 200;
                tmp.push_back(j+1); // 存储从1开始的索引
            }
        }
        if (md.count(sum)) {
            cout << "Yes\n";
            print(tmp);       // 当前找到的子序列
            print(md[sum]);   // 之前存储的子序列
            return 0;
        }
        md[sum] = tmp;
    }
    cout << "No";
}
```

---

### 最优思路总结
**核心技巧**  
- **抽屉原理应用**：通过 $2^8=256 > 200$ 的数学性质将复杂度降为常数级别
- **二进制枚举**：使用位运算高效遍历所有子序列组合
- **即时碰撞检测**：哈希表在生成子序列时实时检查余数重复，实现 $O(1)$ 时间碰撞检测

**扩展思考**  
类似问题可考虑以下变形：
1. 修改模数值（如模1000）时需调整枚举规模
2. 要求三个序列余数相同时需组合数学分析
3. 数值范围极大时需配合前缀和优化

---

### 推荐习题
1. [P1030 子串和](https://www.luogu.com.cn/problem/P1030)（模数性质应用）
2. [P2213 不同的和](https://www.luogu.com.cn/problem/P2213)（抽屉原理变形）
3. [P1467 集合划分](https://www.luogu.com.cn/problem/P1467)（二进制枚举优化）

---
处理用时：57.11秒
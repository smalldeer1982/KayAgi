# 题目信息

# [ABC206D] KAIBUNsyo

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc206/tasks/abc206_d

$ N $ 項からなる正整数列 $ A=(A_1,A_2,\ \dots\ A_N) $ が与えられます。  
 以下の操作を $ 0 $ 回以上何度でも行える時、操作を最小何回行えば、$ A $ を回文にすることができますか？

- ある正整数の組 $ (x,y) $ を選ぶ。その後、現在 $ A $ に含まれる $ x $ をすべて $ y $ に置き換える。

なお、この問題では、全ての整数 $ i $ ($ 1\ \le\ i\ \le\ N $) について、$ A_i=A_{N+1-i} $ が成り立つとき、またその時に限って、$ A $ が回文であると言います。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 2\ \times\ 10^5 $

### Sample Explanation 1

\- はじめ、$ A=(1,5,3,2,5,2,3,1) $ です。 - $ A $ に含まれる $ 3 $ を全て $ 2 $ に置き換えると、$ A=(1,5,2,2,5,2,2,1) $ となります。 - $ A $ に含まれる $ 2 $ を全て $ 5 $ に置き換えると、$ A=(1,5,5,5,5,5,5,1) $ となります。 以上の操作を行うと、$ A $ を $ 2 $ 回の操作で回文にすることができ、これが最小です。

### Sample Explanation 3

$ A $ がはじめから回文である可能性もあります。

## 样例 #1

### 输入

```
8

1 5 3 2 5 2 3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
7

1 2 3 4 1 2 3```

### 输出

```
1```

## 样例 #3

### 输入

```
1

200000```

### 输出

```
0```

# AI分析结果



# [ABC206D] KAIBUNsyo 中文翻译

**题目描述**  
给定一个包含 $N$ 个正整数的序列 $A=(A_1,A_2,\dots,A_N)$。你可以进行以下操作任意次（包括零次），求使 $A$ 成为回文的最小操作次数：  
- 选择一对正整数 $(x,y)$，将序列中所有 $x$ 替换为 $y$。  

称序列为回文当且仅当对所有 $1 \le i \le N$，$A_i = A_{N+1-i}$ 成立。  

**样例解释**  
样例1中，通过两次操作（3→2，2→5）可将序列变为回文。  

**算法分类**  
并查集  

---

### 题解综合分析

**核心思路**  
所有题解均采用并查集解决。关键点在于：  
1. **等价关系建模**：将对称位置必须相等的元素视为等价类，通过并查集维护。  
2. **合并操作计数**：每对不等的对称元素需要合并，合并次数即为最小操作次数。  

**解决难点**  
- 避免重复计数（如直接替换可能导致后续关联变化未被处理）  
- 正确维护动态等价关系（通过并查集的路径压缩与合并优化）  

---

### 高分题解精选（4★+）

#### 题解1：作者 _GW_（4★）
**关键亮点**  
- 代码简洁高效，直接操作元素值域  
- 完美体现并查集的核心应用，时间复杂度 $O(n\alpha(n))$  
**核心代码**  
```cpp
int main() {
    for(int i=0;i<N;i++) fa[i]=i; // 初始化
    for(int i=1;i<=n/2;i++) {
        if(a[i]!=a[n-i+1]) {
            int x=find(a[i]), y=find(a[n-i+1]);
            if(x!=y) fa[x]=y, res++; // 合并并计数
        }
    }
}
```

#### 题解2：作者 _hxh（4★）
**关键亮点**  
- 明确初始化所有可能值的父节点  
- 处理值域至 $2e5$ 的完备性  
**代码片段**  
```cpp
for(int i = n+1; i < N; i++) fa[i] = i; // 扩展值域初始化
for(int i=1; i<=n/2; i++) 
    if(find(a[i]) != find(a[n-i+1])) 
        fa[find(a[i])] = find(a[n-i+1]), ans++;
```

#### 题解3：作者 liruizhou_lihui（4★）
**优化亮点**  
- 引入按秩合并优化  
- 使用独立计数数组维护集合大小  
**代码片段**  
```cpp
void add(int u,int v) {
    if(cnt[fau] < cnt[fav]) fa[fau] = fav; // 按秩合并
    else fa[fav] = fau;
}
```

---

### 关键思路总结
1. **并查集建模**：将每个数字视为独立节点，必须相等的数字建立连通分量  
2. **对称处理**：仅需遍历前 $n/2$ 对元素  
3. **合并计数**：每次有效合并对应一次必要操作  

**实现要点**  
- 初始化时需覆盖所有可能出现的数值  
- 使用路径压缩确保查询效率  
- 避免重复合并（`find(x) != find(y)` 时再合并）  

---

### 拓展应用
类似问题：  
1. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551) - 基础并查集应用  
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367) - 标准实现练习  
3. [CF445B DZY Loves Chemistry](https://codeforces.com/problemset/problem/445/B) - 等价关系计数  

---

### 心得分镜
- **调试教训**：初始时将元素索引误作为父节点（应使用元素值本身）  
- **优化顿悟**：按秩合并虽非必需，但能提升实际运行效率  
- **思维突破**：意识到替换操作的传递性等价于集合合并，无需关心具体替换顺序

---
处理用时：49.94秒
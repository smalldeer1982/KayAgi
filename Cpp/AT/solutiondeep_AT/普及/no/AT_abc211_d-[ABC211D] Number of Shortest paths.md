# 题目信息

# [ABC211D] Number of Shortest paths

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc211/tasks/abc211_d

AtCoder 国には $ 1 $ から $ N $ の番号がついた $ N $ 個の都市と、$ 1 $ から $ M $ の番号がついた $ M $ 個の道路があります。

道路 $ i $ を通ると都市 $ A_i $ と都市 $ B_i $ の間を双方向に $ 1 $ 時間で移動することができます。

都市 $ 1 $ から都市 $ N $ へ最も早く移動することができる経路は何通りありますか？  
 答えは非常に大きくなる可能性があるので $ (10^9+7) $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- $ (A_i,B_i) $ は相異なる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

都市 $ 1 $ から都市 $ 4 $ へは最短 $ 2 $ 時間で移動することができ、それを実現する経路は $ 1\ \to\ 2\ \to\ 4 $ と $ 1\ \to\ 3\ \to\ 4 $ の $ 2 $ つです。

### Sample Explanation 2

都市 $ 1 $ から都市 $ 4 $ へは最短 $ 3 $ 時間で移動することができ、それを実現する経路は $ 1\ \to\ 3\ \to\ 2\ \to\ 4 $ の $ 1 $ つです。

### Sample Explanation 3

都市 $ 1 $ から都市 $ 2 $ に移動することはできません。この場合 $ 0 $ を出力してください。

## 样例 #1

### 输入

```
4 5

2 4

1 2

2 3

1 3

3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3

1 3

2 3

2 4```

### 输出

```
1```

## 样例 #3

### 输入

```
2 0```

### 输出

```
0```

## 样例 #4

### 输入

```
7 8

1 3

1 4

2 3

2 4

2 5

2 6

5 7

6 7```

### 输出

```
4```

# AI分析结果



# [ABC211D] 最短路径的数量

## 题目重述
AtCoder 国有编号 $1$ 至 $N$ 的 $N$ 个城市和 $M$ 条双向道路。每条道路连接两个不同城市，通行时间为 $1$ 小时。求从城市 $1$ 到城市 $N$ 的最短路径数量，答案对 $10^9+7$ 取模。

**约束条件**  
- $2 \leq N \leq 2 \times 10^5$  
- $0 \leq M \leq 2 \times 10^5$  

**分类标签**  
最短路、广度优先搜索 BFS

---

## 题解分析与结论

### 核心思路
所有题解均采用 **BFS 分层遍历** 或 **Dijkstra 算法**，通过维护两个核心数组：
- `dist[]`：记录每个节点的最短距离  
- `cnt[]`：记录到达该节点的最短路径数  

**关键处理逻辑**：  
1. 当发现更短路径时，重置 `cnt[v] = cnt[u]`  
2. 当发现等长路径时，累加 `cnt[v] += cnt[u]`  
3. 使用 BFS 的分层特性确保第一次到达节点时即为最短路径  

### 最优题解亮点

#### 题解作者：2020luke（★★★★☆）  
**核心亮点**：  
1. 纯 BFS 实现，完美适配边权为 1 的特性  
2. 动态入队控制：仅在首次发现最短路径时入队，避免重复计算  
3. 无冗余状态标记，通过距离比较隐式控制流程  

**关键代码**：
```cpp
void bfs() {
    memset(d, 0x3f, sizeof(d));
    d[1] = 0; s[1] = 1;
    queue<int> q;
    q.push(1);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(auto v : g[u]) {
            if(d[v] >= d[u] + 1) {  // 允许等长路径的计数更新
                if(d[v] > 1e8) q.push(v);  // 首次发现最短路径时入队
                d[v] = d[u] + 1;
                s[v] = (s[v] + s[u]) % mod;
            }
        }
    }
}
```

---

## 拓展与总结

### 关键技巧
- **分层 BFS 特性**：在无权图中，BFS 天然按距离分层，首次访问即最短路径  
- **计数转移公式**：`cnt[v] = Σ cnt[u]`（对所有满足 `dist[u]+1 == dist[v]` 的前驱节点 u）  

### 同类题目推荐
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  
2. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)  
3. [P2865 Roadblocks](https://www.luogu.com.cn/problem/P2865)（次短路问题）  

### 调试心得摘录
- **Zhuluoan 题解**：使用 `vis[]` 标记可能导致漏计路径，BFS 中节点可能被多次访问（需保持开放状态直到所有前驱处理完毕）  
- **highkj 题解**：Dijkstra 的优先队列实现需注意 `dis[x]+1 == dis[to]` 的判断顺序  
- **Jasonshan10 题解**：直接套用 P1144 代码时需注意模数差异和数据类型溢出问题  

---

**实现要诀**：优先使用 BFS 处理无权图，通过距离比较控制计数累加，避免过早标记节点状态。

---
处理用时：60.67秒
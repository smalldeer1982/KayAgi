# 题目信息

# [ABC212D] Querying Multiset

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc212/tasks/abc212_d

高橋君は何も書かれていないたくさんのボールと $ 1 $ つの袋を持っています。 最初、袋は空で、高橋君は $ Q $ 回の操作を行います。 それぞれの操作は以下の $ 3 $ 種類のうちのいずれかです。

- 操作 $ 1 $ : まだ何も書かれていないボール $ 1 $ つに整数 $ X_i $ を書き込み、袋に入れる。
- 操作 $ 2 $ : 袋に入っているすべてのボールについて、そこに書かれている数を、それに $ X_i $ を加えたものに書き換える。
- 操作 $ 3 $ : 袋に入っているボールのうち書かれている数が最小のもの（複数ある場合はそのうちの $ 1 $ つ）を取り出し、そこに書かれている数を記録する。その後、そのボールを捨てる。

$ 1\leq\ i\leq\ Q $ について $ i $ 回目の操作の種類 $ P_i $ および操作 $ 1 $ , $ 2 $ における $ X_i $ の値が与えられるので、操作 $ 3 $ において記録された数を順に出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ Q\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ P_i\ \leq\ 3 $
- $ 1\ \leq\ X_i\ \leq\ 10^9 $
- 入力は全て整数である。
- $ P_i=3 $ であるような $ i $ が $ 1 $ つ以上存在する。
- $ P_i=3 $ であるとき、 $ i $ 回目の操作の直前の時点で、袋には $ 1 $ つ以上のボールが入っている。

### Sample Explanation 1

高橋君は次のように操作を行います。 - $ 3 $ の書かれたボールを袋に入れる。 - $ 5 $ の書かれたボールを袋に入れる。 - 今、袋には $ 3 $ の書かれたボールと $ 5 $ の書かれたボールが入っているため、このうち小さい $ 3 $ の書かれたボールを取り出し、 $ 3 $ を記録した後に捨てる。 - 今、袋には $ 5 $ の書かれたボールのみが入っているため、この数を $ 5+2=7 $ に書き換える。 - 今、袋には $ 7 $ の書かれたボールのみが入っているため、このボールを取り出し、 $ 7 $ を記録した後に捨てる。 よって、記録された順に $ 3 $ , $ 7 $ を出力します。

### Sample Explanation 2

答えが $ 32 $ bit整数に収まらないことがある事に注意してください。

## 样例 #1

### 输入

```
5

1 3

1 5

3

2 2

3```

### 输出

```
3

7```

## 样例 #2

### 输入

```
6

1 1000000000

2 1000000000

2 1000000000

2 1000000000

2 1000000000

3```

### 输出

```
5000000000```

# AI分析结果



【中文重写题目】  
# [ABC212D] Querying Multiset  

## 题目描述  
高桥君有一个空袋子和许多空白球。他将进行 Q 次操作，操作类型分为三种：  
1. **操作1**：在空白球上写整数 X_i 并放入袋子  
2. **操作2**：给袋中所有球的数值加 X_i  
3. **操作3**：取出袋中数值最小的球，记录其数值后丢弃  

要求按顺序输出所有操作3记录的值。  

## 说明/提示  
- 1 ≤ Q ≤ 2×10^5  
- 操作3保证执行时袋子非空  
- 需注意数值可能超过32位整数范围  

## 样例 #1  
输入：  
5  
1 3  
1 5  
3  
2 2  
3  
输出：  
3  
7  

---

**算法分类**：队列（优先队列）  

---

### 题解分析与结论  
所有题解均采用优先队列结合全局偏移量的方法：  
1. **核心思路**：维护全局偏移量 `add`，插入元素时存储原始值减 `add`，取出时补回当前 `add`  
2. **时间复杂度**：O(Q log Q)，完美处理 2e5 量级操作  
3. **关键优化**：将全体加法转换为偏移量调整，避免暴力修改元素  

---

### 精选题解  

#### 1. Redamancy_Lydic（⭐⭐⭐⭐⭐）  
**亮点**：  
- 引入"时间戳"概念解释偏移量的物理意义  
- 完整包含输入输出优化模板  
- 代码结构清晰，注释简明  
```cpp
priority_queue<int, vector<int>, greater<int>> q;
int Q, t; // t 为全局偏移量

while (Q--) {
    int op = read();
    if (op == 1) {
        int x = read();
        q.push(x - t); // 插入时抵消已有偏移
    } else if (op == 2) {
        t += read(); // 更新全局偏移
    } else {
        printf("%lld\n", q.top() + t);
        q.pop();
    }
}
```

#### 2. Coffee_zzz（⭐⭐⭐⭐）  
**亮点**：  
- 使用前缀和类比解释偏移量机制  
- 代码极度简洁（仅18行）  
- 包含重要提示："不开long long见祖宗"  
```cpp
priority_queue<int, vector<int>, greater<int>> q;
int k; // 全局偏移量

while (t--) {
    cin >> p;
    if (p == 1) {
        cin >> x;
        q.push(x - k); 
    } else if (p == 2) {
        k += x;
    } else {
        cout << q.top() + k << '\n';
        q.pop();
    }
}
```

#### 3. Engulf（⭐⭐⭐⭐）  
**亮点**：  
- 采用multiset实现，拓展数据结构选择思路  
- 强调迭代器删除的重要性  
- 提及类似题目《郁闷的出纳员》  
```cpp
multiset<ll> s;
ll add = 0;

while (q--) {
    if (op == 1) 
        s.insert(x - add);
    else if (op == 2) 
        add += x;
    else {
        cout << *s.begin() + add << "\n";
        s.erase(s.begin()); // 必须用迭代器删除
    }
}
```

---

### 关键技巧总结  
1. **延迟更新**：通过全局偏移量将 O(n) 修改降为 O(1)  
2. **相对值存储**：插入元素时存储与当前偏移的差值  
3. **数据结构选择**：优先队列（默认小根堆）或 multiset 均可实现  
4. **数值溢出处理**：必须使用 long long 类型  

---

### 拓展训练  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 优先队列基础  
2. [P2827 蚯蚓](https://www.luogu.com.cn/problem/P2827) - 动态偏移量进阶应用  
3. [P1873 砍树](https://www.luogu.com.cn/problem/P1873) - 结合二分与极值查询

---
处理用时：52.04秒
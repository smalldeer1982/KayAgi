# 题目信息

# [ABC213D] Takahashi Tour

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc213/tasks/abc213_d

AtCoder 国には $ 1 $ から $ N $ の番号がついた $ N $ 個の都市と、$ 1 $ から $ N-1 $ の番号がついた $ N-1 $ 個の道路があります。  
 道路 $ i $ を通ると都市 $ A_i $ と都市 $ B_i $ の間を相互に移動することができます。全ての都市は道路を使って互いに行き来できることが保証されます。

高橋くんは都市 $ 1 $ を出発し、次のルールで旅をします。

- いまいる都市と道路で直接つながっている都市のうち、まだ訪れたことがない都市が存在するとき、そのような都市のうち番号が最も小さい都市へ移動する
- そのような都市が存在しないとき
  - いまいる都市が都市 $ 1 $ なら旅を終了する
  - そうでないなら、いまいる都市を初めて訪れたときに直前にいた都市へ移動する

高橋くんが旅の過程で訪れる都市を順に答えてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,B_i\ \leq\ N $
- 全ての都市は道路を使って互いに行き来できる

### Sample Explanation 1

高橋くんの旅は次のようになります。 - 最初都市 $ 1 $ にいます。 - 都市 $ 1 $ から道路で直接つながっている都市のうち未訪問なのは都市 $ 2,3 $ です。番号が小さい都市 $ 2 $ へ移動します。 - 都市 $ 2 $ から道路で直接つながっている都市のうち未訪問なのは都市 $ 4 $ です。都市 $ 4 $ へ移動します。 - 都市 $ 4 $ から道路で直接つながっている都市のうち未訪問の都市はありません。直前にいた都市 $ 2 $ へ移動します。 - 都市 $ 2 $ から道路で直接つながっている都市のうち未訪問の都市はありません。初めて都市 $ 2 $ に来る直前にいた都市 $ 1 $ へ移動します。 - 都市 $ 1 $ から道路で直接つながっている都市のうち未訪問なのは都市 $ 3 $ です。都市 $ 3 $ へ移動します。 - 都市 $ 3 $ から道路で直接つながっている都市のうち未訪問の都市はありません。直前にいた都市 $ 1 $ へ移動します。 - 都市 $ 1 $ から道路で直接つながっている都市のうち未訪問の都市はありません。旅を終了します。

## 样例 #1

### 输入

```
4

1 2

4 2

3 1```

### 输出

```
1 2 4 2 1 3 1```

## 样例 #2

### 输入

```
5

1 2

1 3

1 4

1 5```

### 输出

```
1 2 1 3 1 4 1 5 1```

# AI分析结果



# [ABC213D] Takahashi Tour

## 题目描述

AtCoder 国有编号为 $1$ 到 $N$ 的 $N$ 个城市和编号为 $1$ 到 $N-1$ 的 $N-1$ 条道路。  
道路 $i$ 连接城市 $A_i$ 和 $B_i$，保证所有城市可通过道路互相到达。

高桥君从城市 $1$ 出发，按以下规则旅行：

- 当当前城市存在未访问的相邻城市时，移动到其中编号最小的城市
- 无未访问相邻城市时：
  - 若当前为城市 $1$，结束旅行
  - 否则返回上一个访问的城市

请输出高桥君访问城市的顺序。

## 算法分类
深度优先搜索 DFS

---

## 题解分析

### 核心思路
本题要求模拟特定DFS遍历顺序，关键点在于：
1. **邻接表排序**：确保每次选择最小编号的邻接点
2. **回溯记录**：每次递归返回时记录当前节点，形成欧拉序

### 最优题解

#### 作者：L_zaa_L（★★★★★）
**关键亮点**：
- 清晰的邻接表预处理
- 简洁的DFS回溯输出逻辑
- 完整处理无向图的双向边

**核心代码**：
```cpp
vector<int> a[200005];
bool book[200005];

void dfs(int city) {
    cout << city << " ";
    for(int v : a[city]) {
        if(!book[v]) {
            book[v] = true;
            dfs(v);
            cout << city << " "; // 回溯时输出
        }
    }
}

int main() {
    // 输入处理
    for(int i=1;i<=n;i++) 
        sort(a[i].begin(), a[i].end());
    book[1] = true;
    dfs(1);
}
```

#### 作者：Little_x_starTYJ（★★★★☆）
**核心贡献**：
- 使用更简洁的STL容器
- 省略显式父节点维护
- 统一的访问标记处理

**代码片段**：
```cpp
void dfs(int now) {
    cout << now << ' ';
    vis[now] = true;
    for(int to : a[now]) 
        if(!vis[to]) 
            dfs(to), cout << now << ' ';
}
```

---

## 关键思路总结
1. **邻接表预处理**：对每个节点的邻接点进行排序，确保每次选择最小
2. **回溯路径记录**：在DFS递归返回后立即输出当前节点，形成完整的欧拉序
3. **访问标记管理**：仅在首次访问时标记，避免重复访问

## 拓展应用
类似需要记录DFS遍历路径的题目：
1. 树的欧拉序（[洛谷P3379](https://www.luogu.com.cn/problem/P3379) LCA问题）
2. 括号序列生成（通过进入/退出节点产生括号）
3. 树的直径求解（两次DFS遍历）

## 推荐练习
1. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)（逆向DFS）
2. [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)（拓扑排序+DFS）
3. [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)（树形DFS应用）

---
处理用时：50.70秒
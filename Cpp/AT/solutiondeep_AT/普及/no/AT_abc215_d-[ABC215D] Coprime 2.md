# 题目信息

# [ABC215D] Coprime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc215/tasks/abc215_d

長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられるので、以下の条件を満たす $ 1 $ 以上 $ M $ 以下の整数 $ k $ を全て求めてください。

- 全ての $ 1\ \le\ i\ \le\ N $ を満たす整数 $ i $ について、 $ \gcd(A_i,k)=1 $ である。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N,M\ \le\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^5 $

### Sample Explanation 1

例えば、 $ 7 $ は $ \gcd(6,7)=1,\gcd(1,7)=1,\gcd(5,7)=1 $ を満たすので答えとなる整数の集合に含まれます。 一方、 $ 9 $ は $ \gcd(6,9)=3 $ となるため、答えとなる整数の集合に含まれません。 条件を満たす $ 1 $ 以上 $ 12 $ 以下の整数は $ 1,7,11 $ の $ 3 $ つです。これらを小さい方から出力することに注意してください。

## 样例 #1

### 输入

```
3 12

6 1 5```

### 输出

```
3

1

7

11```

# AI分析结果



# [ABC215D] Coprime 2 题解翻译

## 题目描述

给定长度为 $N$ 的正整数序列 $A=(A_1,A_2,\dots,A_N)$，请找出所有满足以下条件的 $1$ 至 $M$ 的整数 $k$：

- 对所有的 $1 \le i \le N$，满足 $\gcd(A_i, k) = 1$。

## 说明/提示

### 样例解释
例如，$7$ 满足 $\gcd(6,7)=1$、$\gcd(1,7)=1$、$\gcd(5,7)=1$，因此属于答案集合。而 $9$ 因 $\gcd(6,9)=3$ 不符合条件。符合条件的数按升序排列为 $1,7,11$。

---

**算法分类**：数学

---

### 题解综合分析与结论

所有题解的核心思路均围绕**预处理不可选质因数**展开，主要差异在于质因数处理方式：
1. **暴力筛法**：通过分解每个 $A_i$ 的因数，标记所有因数后筛选倍数。
2. **质因数分解优化**：仅记录质因数，利用筛法排除其倍数。
3. **线性筛法**：通过构建质因数树优化标记过程，实现线性时间复杂度。

最优思路为**质因数分解+筛法标记**，核心要点：
1. 预处理所有 $A_i$ 的质因数集合。
2. 对每个质因数 $p$，标记 $p$ 在 $[1,M]$ 内的所有倍数。
3. 未被标记的即为满足条件的数。

---

### 精选题解分析

#### 题解作者：So_noSlack（4星）
**关键亮点**：
- 预处理所有因数，代码简洁易理解。
- 使用桶标记优化空间，避免重复计算。

**核心代码**：
```cpp
void f(int x) {
    flag[x] = true;
    for(int i = 2; i * i <= x; i++) 
        if(x % i == 0) flag[i] = flag[x/i] = true;
}
// 主函数中收集所有标记的因数，再筛选未被标记的k
```

#### 题解作者：syzxzqy（4星）
**关键亮点**：
- 仅分解质因数，减少标记数量。
- 埃氏筛式标记倍数，时间复杂度优化。

**核心代码**：
```cpp
for(int i=1; i<=n; i++) {
    cin >> x;
    for(int j=2; j*j<=x; j++) 
        if(x%j == 0) {
            prime[++s] = j; // 记录质因数
            while(x%j == 0) x /= j;
        }
    if(x > 1) prime[++s] = x;
}
for(int i=1; i<=s; i++) 
    for(int j=prime[i]; j<=m; j+=prime[i])
        e[j] = 1; // 标记倍数
```

#### 题解作者：xiaoyuchenp（4星）
**关键亮点**：
- 代码逻辑清晰，直接分解质因数后标记。
- 显式处理1的特殊情况，避免误判。

**核心代码**：
```cpp
vector<bool> vis(m + 1, true);
for (auto &iter : a) {
    int num = iter;
    for (int j = 2; j * j <= num; j++) {
        if (num % j == 0) {
            while (num % j == 0) num /= j;
            for (int k = j; k <= m; k += j) 
                vis[k] = false;
        }
    }
    if (num > 1) 
        for (int k = num; k <= m; k += num) 
            vis[k] = false;
}
```

---

### 关键思路总结
1. **质因数分解**：将每个 $A_i$ 分解为质因数集合。
2. **筛法标记**：对每个质因数 $p$，标记 $p$ 的所有倍数为不可选。
3. **线性筛选**：最终未被标记的数即为答案。

**优化技巧**：
- 分解时仅需处理到 $\sqrt{x}$，处理因数对。
- 使用布尔数组而非集合，提升访问速度。

---

### 类似题目推荐
1. [P2158 仪仗队](https://www.luogu.com.cn/problem/P2158)（质数筛选与互质计数）
2. [P2568 GCD](https://www.luogu.com.cn/problem/P2568)（质因数分解与数对统计）
3. [P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139)（欧拉定理与递归处理）

---
处理用时：60.23秒
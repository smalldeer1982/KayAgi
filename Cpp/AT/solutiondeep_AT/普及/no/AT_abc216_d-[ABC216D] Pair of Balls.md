# 题目信息

# [ABC216D] Pair of Balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc216/tasks/abc216_d

$ 2N $ 個のボールがあります。各ボールには $ 1 $ 以上 $ N $ 以下の整数によって表される色が塗られており、各色で塗られたボールはちょうど $ 2 $ 個ずつ存在します。

これらのボールが、底が地面と平行になるように置かれた $ M $ 本の筒に入れられています。はじめ、$ i\ (1\ \leq\ i\ \leq\ M) $ 本目の筒には $ k_i $ 個のボールが入っており、上から $ j\ (1\ \leq\ j\ \leq\ k_i) $ 番目のボールの色は $ a_{i,\ j} $ です。

あなたの目標は、以下の操作を繰り返すことで $ M $ 本の筒全てを空にすることです。

- 異なる $ 2 $ 本の空でない筒を選び、それぞれの筒の一番上にあるボールを取り出して捨てる。ここで、取り出して捨てた $ 2 $ つのボールは同じ色で塗られている必要がある。

目標が達成可能かを判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 2\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ k_i\ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ a_{i,j}\ \leq\ N\ (1\ \leq\ i\ \leq\ M,1\ \leq\ j\ \leq\ k_i) $
- $ \sum_{i=1}^{M}\ k_i\ =\ 2N $
- 全ての $ x\ (1\ \leq\ x\ \leq\ N) $ について、$ 1\ \leq\ i\ \leq\ M $ かつ $ 1\ \leq\ j\ \leq\ k_i $ かつ $ a_{i,j}=x $ なる整数の組 $ (i,j) $ はちょうど $ 2 $ つ存在する
- 入力は全て整数

### Sample Explanation 1

以下のように操作を行えばよいです。 1. $ 1 $ つ目の筒と $ 2 $ つ目の筒を選び、それぞれの筒の一番上にあるボールを取り出して捨てる。捨てられるボールの色は共に $ 1 $ であり等しいので、この操作は有効である。 2. $ 1 $ つ目の筒と $ 2 $ つ目の筒を選び、それぞれの筒の一番上にあるボールを取り出して捨てる。捨てられるボールの色は共に $ 2 $ であり等しいので、この操作は有効である。

### Sample Explanation 2

そもそも一度も操作を行うことができないため、目標を達成する、すなわち $ M $ 本の筒全てを空にすることは不可能です。

## 样例 #1

### 输入

```
2 2

2

1 2

2

1 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 2

2

1 2

2

2 1```

### 输出

```
No```

# AI分析结果



# 题目中文翻译

## [ABC216D] 成对的球

### 题目描述

有 $2N$ 个球，每个球涂有 $1$ 到 $N$ 之间的颜色，每种颜色恰好出现两次。这些球被放置在 $M$ 个垂直的筒中。初始时，第 $i$ 个筒从上到下依次有 $k_i$ 个球，颜色序列为 $a_{i,1}, a_{i,2}, ..., a_{i,k_i}$。

每次操作可以选取两个非空筒，移除它们顶部的球，且这两个球必须颜色相同。判断能否通过若干次操作清空所有筒。

### 输入格式
- 第一行：两个整数 $N$ 和 $M$
- 接下来 $M$ 组数据，每组：
  - 第一行：整数 $k_i$
  - 第二行：$k_i$ 个整数表示该筒的球序列

### 输出格式
- 输出 "Yes" 或 "No"

---

**算法分类**：图论（拓扑排序）

---

## 题解分析与结论

### 核心思路对比
1. **拓扑排序法**（主流解法）：
   - **关键观察**：颜色必须按特定顺序消除。若筒中颜色序列为 $a_1→a_2→...→a_k$，则每个 $a_i$ 必须在 $a_{i+1}$ 之前被消除，形成有向边 $a_i→a_{i+1}$。
   - **实现**：建立颜色间的有向图，进行拓扑排序。若存在环则无法完成，否则可行。
   - **优势**：时间复杂度 $O(N)$，适合大规模数据。

2. **栈顶模拟法**：
   - **关键观察**：维护当前各筒顶部的颜色，动态匹配可消除对。
   - **实现**：使用哈希表记录颜色出现的筒，每次消除后递归处理新顶部。
   - **优势**：直观模拟操作过程，空间复杂度低。

3. **队列维护法**：
   - **关键技巧**：用队列维护当前可消除的颜色对，批量处理新出现的栈顶匹配。
   - **实现**：每次消除后更新相关筒顶，动态加入新的候选对。

---

## 精选题解

### 题解1：拓扑排序法（作者：_zzzzzzy_，★★★★★）
**关键思路**：
- 将每个筒的相邻颜色建立有向边，表示消除顺序依赖。
- 拓扑排序检测环的存在性。

**代码核心**：
```cpp
vector<int> e[maxn]; // 邻接表
int d[maxn];          // 入度数组

// 建图部分
for(int i=1; i<=m; i++){
    int k, last;
    cin >> k >> last;
    for(int j=1; j<k; j++){
        int x; cin >> x;
        e[last].push_back(x);
        d[x]++;
        last = x;
    }
}

// 拓扑排序
queue<int> Q;
for(int i=1; i<=n; i++)
    if(d[i] == 0) Q.push(i);
int cnt = 0;
while(!Q.empty()){
    int u = Q.front(); Q.pop();
    cnt++;
    for(int v : e[u])
        if(--d[v] == 0) Q.push(v);
}
cout << (cnt == n ? "Yes" : "No");
```

### 题解2：队列维护法（作者：Jerrlee✅，★★★★☆）
**关键思路**：
- 使用 `col[]` 数组记录每个颜色当前所在的筒顶。
- 队列维护可消除的对，动态更新栈顶状态。

**代码核心**：
```cpp
queue<int> Q;
vector<int> ids[maxn]; // 各颜色出现的筒

// 初始化可消除对
for(int i=1; i<=m; i++){
    int f = st[i].top();
    ids[f].push_back(i);
    if(ids[f].size() == 2) Q.push(f);
}

// 处理队列
int cnt = 0;
while(!Q.empty()){
    int u = Q.front(); Q.pop();
    cnt++;
    for(int i : ids[u]){
        st[i].pop();
        if(!st[i].empty()){
            int new_top = st[i].top();
            ids[new_top].push_back(i);
            if(ids[new_top].size() == 2) 
                Q.push(new_top);
        }
    }
}
```

---

## 关键优化与技巧
1. **拓扑排序建图技巧**：仅需对每个筒的相邻颜色建立边，无需考虑所有可能的依赖。
2. **实时维护栈顶**：在模拟法中，通过哈希表快速定位同色栈顶，实现 O(1) 时间匹配。
3. **批量处理思想**：队列维护候选对，避免重复检查所有筒顶。

---

## 拓展与相似题目
1. **拓扑排序应用**：
   - [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
   - [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)
   
2. **栈操作模拟**：
   - [P4387 验证栈序列](https://www.luogu.com.cn/problem/P4387)
   - [P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)

---
处理用时：95.29秒
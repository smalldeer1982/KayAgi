# 题目信息

# [ABC216E] Amusement Park

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc216/tasks/abc216_e

髙橋君は遊園地に遊びに行きました。  
 この遊園地には $ N $ 個のアトラクションがあり、$ i $ 個目のアトラクションの「楽しさ」の初期値は $ A_i $ です。

髙橋君が $ i $ 個目のアトラクションに乗ると、以下の現象が順番に起きます。

- 髙橋君の「満足度」に、$ i $ 個目のアトラクションの現在の「楽しさ」が加算される。
- $ i $ 個目のアトラクションの「楽しさ」が、$ 1 $ 減少する。

髙橋君の「満足度」の初期値は $ 0 $ です。髙橋君はアトラクションに合計 $ K $ 回まで乗ることができます。  
 最終的な髙橋君の「満足度」の最大値はいくつですか？

なお、髙橋君の「満足度」はアトラクションに乗ること以外で変化しません。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ 2\ \times\ 10^9 $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

$ 1 $ 個目のアトラクションに $ 2 $ 回、$ 3 $ 個目のアトラクションに $ 3 $ 回乗ります。 最終的な「満足度」は、$ (100+99)+(102+101+100)=502 $ です。 「満足度」を $ 503 $ 以上にする方法はないので、$ 502 $ が答えになります。

### Sample Explanation 2

アトラクションに乗る合計回数は、$ K $ 回より少なくても構いません。

## 样例 #1

### 输入

```
3 5

100 50 102```

### 输出

```
502```

## 样例 #2

### 输入

```
2 2021

2 3```

### 输出

```
9```

# AI分析结果



# 中文题目重写

## 题目描述

高桥君去游乐园游玩，这里有 $N$ 个游乐设施，第 $i$ 个设施的初始乐趣值为 $A_i$。每个设施游玩时会发生以下操作：

1. 将当前设施的乐趣值累加到满意度
2. 该设施的乐趣值减少 $1$

高桥君最多可以游玩 $K$ 次，求最终可获得的最大满意度。

## 输入格式

- 第一行：$N$ 和 $K$
- 第二行：$N$ 个整数表示 $A_i$

## 输出格式

- 最大满意度

## 数据范围

- $1 \leq N \leq 10^5$
- $1 \leq K \leq 2 \times 10^9$
- $1 \leq A_i \leq 2 \times 10^9$

---

**算法分类**：贪心（数学优化）

---

# 题解综合分析

## 核心思路对比

### 二分法（Morax2022）
- **关键思路**：二分查找阈值 $mid$，计算所有高于 $mid$ 的部分的总操作次数，确定最大的 $mid$ 使得总操作次数不超过 $K$。
- **数学基础**：利用等差数列求和公式计算贡献值。
- **时间复杂度**：$O(n \log \max A_i)$，适用于大数据范围。

### 分层贪心（Symbolize）
- **关键思路**：将游乐设施按乐趣值降序排序后分层处理，每次批量计算相邻两层的差值贡献。
- **数学基础**：利用等差数列分段求和，快速消耗剩余次数。
- **时间复杂度**：$O(n \log n)$，排序主导，处理过程线性。

### 优先队列优化（WaterSun）
- **关键思路**：用优先队列维护当前最大乐趣值，合并相同值的计数器，批量处理差值段的操作次数。
- **优势**：避免逐次操作，通过合并同类项减少计算量。
- **时间复杂度**：$O(n \log n)$，适合处理非连续但需要动态维护最大值的场景。

---

# 精选题解

## 题解1：Symbolize（★★★★★）
**亮点**：
- 清晰的分层处理思路，代码简洁高效
- 利用排序后相邻差值的批量计算，数学推导严谨
- 边界处理巧妙（如余数处理）

**核心代码**：
```cpp
sort(a + 1, a + n + 1, cmp); // 降序排序
a[n + 1] = 0; // 添加哨兵值
for (int i = 1; i <= n; i++) {
    int d = a[i] - a[i + 1];
    if (i * d <= k) { // 完整处理当前层
        ans += i * (a[i] + a[i + 1] + 1) * d / 2;
        k -= i * d;
    } else { // 处理剩余次数
        int full = k / i;
        int rem = k % i;
        ans += i * (2 * a[i] - full + 1) * full / 2;
        ans += rem * (a[i] - full);
        break;
    }
}
```

## 题解2：Morax2022（★★★★☆）
**亮点**：
- 二分法应用典型，框架清晰
- 降序排序优化计算效率
- 剩余次数处理逻辑正确

**核心代码**：
```cpp
sort(a + 1, a + n + 1, cmp); // 降序排序
// 二分查找阈值 mid
while (l < r) {
    mid = (l + r) >> 1;
    if (check(mid)) l = mid + 1; // 需要调大阈值
    else r = mid;
}
// 计算最终贡献
for (int i = 1; i <= n; i++) {
    if (a[i] <= l) continue;
    ans += (a[i] + l + 1) * (a[i] - l) / 2;
    k -= (a[i] - l);
}
ans += l * k; // 剩余次数处理
```

---

# 最优思路总结
1. **降序排序**：将游乐设施按乐趣值降序排列，便于分层处理。
2. **分层批量计算**：利用相邻两层差值，通过等差数列公式计算批量操作的贡献值，快速消耗剩余次数。
3. **数学优化**：通过分段求和公式（如 $S = \frac{(a_1 + a_n) \times n}{2}$）避免逐次计算，极大提升效率。

---

# 拓展与心得
**心得**：
- 处理大范围次数时，优先考虑数学优化而非模拟操作。
- 添加哨兵值（如 `a[n+1] = 0`）可简化边界条件处理。

**同类题目推荐**：
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）
2. [P3819 松果](https://www.luogu.com.cn/problem/P3819)（分层差值计算）
3. [P3960 列队](https://www.luogu.com.cn/problem/P3960)（数学分段处理）

---
处理用时：146.44秒
# 题目信息

# [ABC217D] Cutting Woods

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc217/tasks/abc217_d

長さ $ L $ メートルの直線状の木材があります。  
 $ x\ =\ 1,\ 2,\ \dots,\ L\ -\ 1 $ に対して、木材の左端から $ x $ メートルの地点には目印として線 $ x $ が引かれています。

$ Q $ 個のクエリが与えられます。 $ i $ 番目のクエリは数の組 $ (c_i,\ x_i) $ によって表されます。  
 以下の説明に従ってクエリを $ i $ の昇順に処理してください。

- $ c_i\ =\ 1 $ のとき : 線 $ x_i $ がある地点で木材を $ 2 $ つに切る。
- $ c_i\ =\ 2 $ のとき : 線 $ x_i $ を含む木材を選び、その長さを出力する。

ただし $ c_i\ =\ 1,\ 2 $ の両方に対して、線 $ x_i $ はクエリを処理する時点で切られていないことが保証されます。

## 说明/提示

### 制約

- $ 1\ \leq\ L\ \leq\ 10^9 $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ c_i\ =\ 1,\ 2 $ $ (1\ \leq\ i\ \leq\ Q) $
- $ 1\ \leq\ x_i\ \leq\ L\ -\ 1 $ $ (1\ \leq\ i\ \leq\ Q) $
- 全ての $ i $ $ (1\ \leq\ i\ \leq\ Q) $ に対して次が成り立つ: $ 1\ \leq\ j\ \lt\ i $ かつ $ (c_j,x_j)\ =\ (1,\ x_i) $ を満たす $ j $ は存在しない。
- 入力は全て整数である。

### Sample Explanation 1

$ 1 $ 番目のクエリ時点では木材は一度も切られていないので、線 $ 2 $ を含む木材の長さは $ 5 $ メートルです。よって $ 5 $ を出力します。 $ 2 $ 番目のクエリによって、木材は $ 3 $ メートルの木材と $ 2 $ メートルの木材に分割されます。 $ 3 $ 番目のクエリ時点では 線 $ 2 $ を含む木材の長さは $ 3 $ メートルなので、$ 3 $ を出力します。

## 样例 #1

### 输入

```
5 3

2 2

1 3

2 2```

### 输出

```
5

3```

## 样例 #2

### 输入

```
5 3

1 2

1 4

2 3```

### 输出

```
2```

## 样例 #3

### 输入

```
100 10

1 31

2 41

1 59

2 26

1 53

2 58

1 97

2 93

1 23

2 84```

### 输出

```
69

31

6

38

38```

# AI分析结果



# [ABC217D] Cutting Woods

## 题目描述

给定长度为 $L$ 米的直线木材，在 $x=1,2,...,L-1$ 的位置都有标记线。处理 $Q$ 个查询：

- 类型1：在标记线 $x_i$ 处将木材切开
- 类型2：查询包含标记线 $x_i$ 的木材段长度

保证每次操作时对应的标记线都未被切割。

### 算法分类
二分

---

## 题解分析与结论

### 题解对比要点
1. **主流思路**：使用有序集合（`set`）维护切割点，通过二分查找定位区间
2. **核心操作**：
   - 切割操作：向集合插入新断点
   - 查询操作：用 `lower_bound` 找到右端点，计算与前驱的差值
3. **时间复杂度**：主流解法 $O(Q\log Q)$，分块解法 $O(Q\sqrt Q)$
4. **实现差异**：
   - 初始插入0和L作为边界
   - 使用 `lower_bound` 或 `upper_bound` 的区别
   - 部分解法用迭代器操作处理前驱指针

### 高分题解推荐

#### ZBH_123（⭐⭐⭐⭐⭐）
**亮点**：
- 代码简洁，仅用15行核心逻辑
- 正确使用迭代器操作 `it--` 获取前驱
- 边界处理清晰（初始插入0和L）
```cpp
set<int> a;
a.insert(0); a.insert(s);
if(op==2){
    auto it2 = a.lower_bound(x);
    auto it = prev(it2);
    cout << *it2 - *it << endl;
}
```

#### zhujiangyuan（⭐⭐⭐⭐）
**关键点**：
- 详细注释说明边界处理
- 强调 `lower_bound` 的语义（找第一个≥x的右端点）
- 正确解释区间长度计算逻辑

#### PeyNiKge（⭐⭐⭐⭐）
**心得摘录**：
> "注意要先插入0和n，否则有的点会算不出来。使用 `set` 自带的二分函数可以避免手写二分错误"

---

## 最优思路总结
1. **数据结构选择**：利用 `set` 的有序性和自动排序特性维护切割点
2. **二分技巧**：通过 `lower_bound(x)` 快速定位右边界
3. **迭代器操作**：使用 `prev()` 或 `--` 运算符获取前驱节点
4. **边界处理**：初始插入0和L作为虚拟端点简化计算

---

## 拓展建议
类似问题可考虑以下技巧：
- 动态区间维护：使用 `map` 维护区间状态
- 离散化处理：当值域过大时，将操作点离散化后处理
- 离线处理：对操作排序后用分块维护前驱后继

---

## 推荐练习
1. [P2161 SHOI2009 会场预约](https://www.luogu.com.cn/problem/P2161) - set维护区间
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 二分求最长子序列
3. [P3374 树状数组模板](https://www.luogu.com.cn/problem/P3374) - 动态维护前驱信息

---
处理用时：52.27秒
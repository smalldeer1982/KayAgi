# 题目信息

# [ABC218D] Rectangles

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc218/tasks/abc218_d

$ 2 $ 次元平面上に $ N $ 個の相異なる点があり、$ 1,2,\ldots\ ,N $ の番号がついています。点 $ i\,(1\ \leq\ i\ \leq\ N) $ の座標は $ (x_i,y_i) $ です。

これらの点のうち $ 4 $ つを頂点とし、全ての辺が $ x $ 軸または $ y $ 軸に平行であるような長方形はいくつありますか？

## 说明/提示

### 制約

- $ 4\ \leq\ N\ \leq\ 2000 $
- $ 0\ \leq\ x_i,\ y_i\ \leq\ 10^9 $
- $ (x_i,y_i)\ \neq\ (x_j,y_j) $ $ (i\ \neq\ j) $
- 入力は全て整数である。

### Sample Explanation 1

点 $ 1 $ 、点 $ 2 $ 、点 $ 3 $ 、点 $ 4 $ を頂点とする長方形、 点 $ 1 $ 、点 $ 2 $ 、点 $ 5 $ 、点 $ 6 $ を頂点とする長方形、 点 $ 3 $ 、点 $ 4 $ 、点 $ 5 $ 、点 $ 6 $ を頂点とする長方形 の合計 $ 3 $ つです。

## 样例 #1

### 输入

```
6

0 0

0 1

1 0

1 1

2 0

2 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4

0 1

1 2

2 3

3 4```

### 输出

```
0```

## 样例 #3

### 输入

```
7

0 1

1 0

2 0

2 1

2 2

3 0

3 2```

### 输出

```
1```

# AI分析结果



### 中文题目重写
**题目描述**  
二维平面上有 $N$ 个互不相同的点，编号为 $1,2,\ldots,N$。点 $i$ 的坐标为 $(x_i,y_i)$。  
求这些点中选取 $4$ 个点作为顶点，且所有边平行于 $x$ 轴或 $y$ 轴的长方形数量。

**输入格式**  
第一行输入 $N$，随后 $N$ 行每行两个整数 $x_i,y_i$。  
**输出格式**  
输出满足条件的长方形数量。  
**样例输入/输出**  
（见原题内容）

**算法分类**  
枚举

---

### 题解分析与对比
所有题解均基于**枚举对角顶点+哈希查询**的核心思路，差异主要体现在哈希方式与去重处理：
1. **对角顶点枚举**：枚举两点作为长方形的对角顶点，检查剩余两顶点是否存在。
2. **哈希优化**：通过 `map` 或排序+二分快速判断点是否存在。
3. **重复计数处理**：通过强制对角顶点满足坐标大小关系（如左上右下），避免重复计数。

#### 高分题解推荐（评分≥4星）
1. **So_noSlack（4星）**  
   **亮点**：代码简洁，逻辑清晰，直接使用双重 `map` 存储点，判断条件严格。  
   **核心思路**：枚举所有点对，若满足 `x1<x2` 且 `y1<y2`，则检查 `(x1,y2)` 和 `(x2,y1)` 是否存在。
   ```cpp
   for(int i=1; i<=n; i++)
       for(int j=1; j<=n; j++)
           if(x[i]<x[j] && y[i]<y[j] && mp[x[i]][y[j]] && mp[x[j]][y[i]])
               ans++;
   ```

2. **zhaomumu1218（4星）**  
   **亮点**：使用 `pair` 作为 `map` 键，代码更简洁，逻辑与上一解法一致。  
   **核心思路**：通过 `map<pair<int,int>,bool>` 存储点，直接判断坐标存在性。
   ```cpp
   map<pair<int,int>,bool> s;
   if(s[{x[i],y[j]}] && s[{x[j],y[i]}] && x[i]<x[j] && y[i]<y[j])
       ans++;
   ```

3. **Hog_Dawa_IOI（4星）**  
   **亮点**：预处理排序后利用二分查找优化查询，避免 `map` 的哈希开销。  
   **核心思路**：将点排序后去重，枚举时通过二分判断剩余点是否存在。
   ```cpp
   sort(A, A+n); // 按x升序、y升序排序
   if(binary_search(A, n, x1, y2) && binary_search(A, n, x2, y1))
       ans++;
   ```

---

### 最优思路总结
**关键技巧**：  
1. **对角顶点枚举法**：以两点为对角顶点，通过坐标大小约束（如 `x1<x2` 且 `y1<y2`）避免重复计数。  
2. **哈希优化查询**：使用 `map` 或排序+二分快速判断点的存在性，时间复杂度为 $O(N^2 \log N)$。  
3. **去重处理**：通过严格条件限制对角顶点顺序，确保每个长方形只计算一次。

**代码核心实现**（以 `map` 为例）：
```cpp
map<pair<int,int>, bool> point_map;
int ans = 0;
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) {
        if (x[i] < x[j] && y[i] < y[j] && 
            point_map.count({x[i], y[j]}) && 
            point_map.count({x[j], y[i]})) {
            ans++;
        }
    }
}
```

---

### 拓展与相似题目
1. **枚举优化**：类似思路可用于统计平行坐标轴的矩形变种，如统计正方形（需额外边长相等条件）。  
2. **哈希结构应用**：在需要快速查询坐标的场景中，`unordered_map` 或自定义哈希能进一步优化时间。  

**推荐题目**：  
- [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（差分+枚举）  
- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)（枚举+剪枝）  
- [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)（枚举优化）

---
处理用时：115.46秒
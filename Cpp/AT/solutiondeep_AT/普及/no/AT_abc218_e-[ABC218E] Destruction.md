# 题目信息

# [ABC218E] Destruction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc218/tasks/abc218_e

$ N $ 頂点 $ M $ 辺の連結無向グラフがあります。  
 頂点には $ 1 $ から $ N $ の番号が、辺には $ 1 $ から $ M $ の番号がついており、辺 $ i $ は頂点 $ A_i $ と $ B_i $ を結んでいます。

高橋君は、このグラフから $ 0 $ 個以上の辺を取り除こうとしています。

辺 $ i $ を取り除くと、$ C_i\ \geq\ 0 $ のとき $ C_i $ の報酬を得、$ C_i\ <\ 0 $ のとき $ |C_i| $ の罰金を払います。

辺を取り除いたあともグラフが連結でなければならないとき、高橋君が得られる報酬の最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ -10^9\ \leq\ C_i\ \leq\ 10^9 $
- 与えられるグラフは連結である
- 入力に含まれる値は全て整数である

### Sample Explanation 1

辺 $ 4,5 $ を取り除くことで合計 $ 4 $ の報酬を得られます。これより多くの報酬を得ることはできないため、答えは $ 4 $ となります。

### Sample Explanation 2

報酬が負であるような辺が存在することもあります。

### Sample Explanation 3

多重辺や自己ループが存在することもあります。

## 样例 #1

### 输入

```
4 5

1 2 1

1 3 1

1 4 1

3 2 2

4 2 2```

### 输出

```
4```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 0

3 1 -1```

### 输出

```
1```

## 样例 #3

### 输入

```
2 3

1 2 -1

1 2 2

1 1 3```

### 输出

```
5```

# AI分析结果



# [ABC218E] Destruction

## 题目描述

给定包含 $N$ 个顶点和 $M$ 条边的连通无向图。每条边 $i$ 连接顶点 $A_i$ 和 $B_i$，并具有权值 $C_i$。可以删除任意数量的边，但删除后的图必须保持连通。删除边 $i$ 时，若 $C_i \geq 0$ 将获得 $C_i$ 的报酬，若 $C_i < 0$ 将受到 $|C_i|$ 的惩罚。求可获得的最大净收益。

### 输入格式
第一行包含两个整数 $N$ 和 $M$  
接下来 $M$ 行每行三个整数 $A_i, B_i, C_i$

### 输出格式
输出最大净收益

### 数据范围
- $2 \leq N \leq 2\times10^5$
- $N-1 \leq M \leq 2\times10^5$
- $-10^9 \leq C_i \leq 10^9$

---

**算法分类**：并查集、图论（最小生成树）

---

## 题解综合分析

### 核心思路
1. **逆向思维**：删除边后的图必须保持连通，等价于保留的边构成生成树。问题转化为求保留边权总和最小的生成树。
2. **处理负权边**：所有负权边必须保留，因为删除会导致扣分，保留反而能减少总成本。
3. **Kruskal算法**：按边权排序后，优先选择最小边构造生成树，同时处理负权边的特殊情况。

### 最优解法总结
总边权减去最小生成树的边权总和，其中：
- 必须包含所有负权边（无论是否形成环）
- 正权边按最小生成树规则选择

---

## 精选题解（评分≥4星）

### 题解作者：Happy_mouse（★★★★★）
**关键亮点**：
1. 明确处理负权边的逻辑，使用并查集判断连通性
2. 代码结构清晰，使用重载运算符简化排序
3. 正确维护剩余边权总和的计算逻辑

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+5;

struct nd{ int u,v,w; };
int fa[N], sum, ans;

int find(int u) {
    return fa[u] == u ? u : fa[u] = find(fa[u]);
}

signed main() {
    int n, m;
    cin >> n >> m;
    vector<nd> edges(m);
    
    for(auto& e : edges) {
        cin >> e.u >> e.v >> e.w;
        sum += e.w;
    }
    
    sort(edges.begin(), edges.end(), [](const nd& a, const nd& b){
        return a.w < b.w;
    });
    
    iota(fa, fa+n+1, 0);
    
    for(auto& e : edges) {
        int fu = find(e.u), fv = find(e.v);
        if(fu != fv) {
            fa[fu] = fv;
            ans += e.w;
        } else if(e.w < 0) {
            ans += e.w;
        }
    }
    
    cout << sum - ans;
}
```

### 题解作者：JoyLosingK（★★★★☆）
**关键亮点**：
1. 使用边权总和的差值计算方式
2. 在Kruskal流程中处理负权边的特殊逻辑
3. 代码简洁，变量命名清晰

**注意点**：需确保并查集数组大小足够（原题解代码数组偏小，此处已修正）

---

## 相似题目推荐
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)  
2. [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)  
3. [P2872 道路修建](https://www.luogu.com.cn/problem/P2872)

---

## 关键技巧总结
1. **逆向思维转换**：将删除问题转化为保留生成树问题
2. **负权处理技巧**：在生成树构造过程中强制包含所有负权边
3. **并查集优化**：路径压缩提升连通性判断效率
4. **复杂度控制**：Kruskal算法 $O(M\log M)$ 时间处理大规模数据

---

## 心得摘录
> "遇到负权边时，直接加入生成树可以避免扣分，这个思路转化是解题的关键。" —— Happy_mouse  
> "注意总边权和与生成树边权的差值计算，容易搞反顺序导致错误。" —— JoyLosingK

---
处理用时：55.78秒
# 题目信息

# [ABC221D] Online games

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc221/tasks/abc221_d

あるオンラインゲームがあり、 $ N $ 人のプレイヤーが登録しています。  
 サービス開始日から $ 10^{100} $ 日を迎えた今日、 開発者である高橋君がログイン履歴を調べたところ、 $ i $ 番目のプレイヤーはサービス開始日を $ 1 $ 日目として、 $ A_i $ 日目から $ B_i $ 日間連続でログインし、 それ以外の日はログインしていなかったことが判明しました。 すなわち、$ i $ 番目のプレイヤーはサービス開始日から、$ A_i $ , $ A_i+1 $ , $ \ldots $ , $ A_i+B_i-1 $ 日目に、 かつそれらの日にのみログインしていたことが分かりました。  
 $ 1\leq\ k\leq\ N $ をみたす各整数 $ k $ について、 サービス開始日から今日までの間で、ちょうど $ k $ 人がログインしていた日数を答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $
- 入力は全て整数である。

### Sample Explanation 1

$ 1 $ 番目のプレイヤーは $ 1 $ 日目と $ 2 $ 日目に、 $ 2 $ 番目のプレイヤーは $ 2 $ 日目と $ 3 $ 日目と $ 4 $ 日目に、 $ 3 $ 番目のプレイヤーは $ 3 $ 日目だけにログインしています。 よって、$ 1 $, $ 4 $ 日目には $ 1 $ 人が、$ 2 $, $ 3 $ 日目には $ 2 $ 人がログインしており、 それ以外の日は誰もログインしていない事が分かります。 答えはちょうど $ 1 $ 人がログインした日数が $ 2 $ 日、 ちょうど $ 2 $ 人がログインした日数が $ 2 $ 日、 ちょうど $ 3 $ 人がログインした日数が $ 0 $ 日となります。

### Sample Explanation 2

$ 2 $ 人以上のプレイヤーがちょうど同じ期間にログインしていることもあり得ます。

## 样例 #1

### 输入

```
3

1 2

2 3

3 1```

### 输出

```
2 2 0```

## 样例 #2

### 输入

```
2

1000000000 1000000000

1000000000 1000000000```

### 输出

```
0 1000000000```

# AI分析结果



# [ABC221D] Online games 题解翻译

## 题目描述

某个在线游戏有 $N$ 名注册玩家。在服务启动至今的 $10^{100}$ 天之际，开发者高桥发现：
- 第 $i$ 号玩家在服务启动后的 $A_i$ 日开始，连续登录了 $B_i$ 天（即登录区间为 $[A_i, A_i+B_i-1]$）
- 这些玩家在其他时间均未登录

要求对每个 $1 \leq k \leq N$，输出恰好有 $k$ 人登录的天数。

## 输入格式
第一行为 $N$，后跟 $N$ 行 $A_i$ 和 $B_i$。

## 输出格式
输出 $N$ 个整数，第 $k$ 个表示恰好 $k$ 人登录的天数。

## 样例解释
样例1中，三个玩家的登录区间分别为：
- 玩家1：1-2日
- 玩家2：2-4日
- 玩家3：3日

结果：
- 1人登录的天数为2天（1日和4日）
- 2人登录的天数为2天（2日和3日）

---

**算法分类**：差分、离散化

---

## 题解对比与结论

### 核心思路
1. **事件差分法**：将每个玩家的登录区间转化为两个事件点（开始日+1，结束日-1）
2. **离散化处理**：将所有事件点排序后，计算相邻事件点间的天数差，乘以当前登录人数
3. **高效统计**：通过排序和遍历实现 $O(n \log n)$ 复杂度，避免直接处理大范围日期

### 关键难点
- 正确处理覆盖区间的差分表示（左闭右开区间）
- 高效处理 $10^9$ 量级的大数据范围
- 合并相同时间点的多个事件

---

## 精选题解

### 题解1（PineappleSummer，5星）
**亮点**：
- 使用 `pair` 数组简化事件处理
- 清晰维护当前在线人数 `s`
- 直接累加时间段至对应答案数组

**代码核心**：
```cpp
pair<int,int> p[400005]; // 存储事件点
sort(p+1, p+tot+1); // 按时间排序

int s = 0;
for(int i=1; i<=tot; i++){
    s += p[i].second; // 更新当前人数
    ans[s] += p[i+1].first - p[i].first; // 累加区间长度
}
```

### 题解2（cjh20090318，5星）
**亮点**：
- 利用 `map` 自动排序与合并事件
- 简洁的差分还原与统计逻辑
- 无需手动离散化

**代码核心**：
```cpp
map<int, int> M;
// 插入差分事件
M[a]++; M[a+b]--;

int now = 0;
for(auto it = M.begin(); it != M.end(); ++it) {
    ans[now] += it->first - last; // 统计时间段
    now += it->second; // 更新人数
    last = it->first;
}
```

---

## 关键技巧总结
1. **事件驱动法**：将区间操作转化为离散事件点处理
2. **左闭右开区间处理**：结束事件点设为 `A_i + B_i` 而非 `A_i + B_i - 1`
3. **批量处理同时间事件**：通过排序或 `map` 确保同一时间点的所有事件被同时处理
4. **时间复杂度优化**：通过离散化将问题规模从 $10^9$ 降低至 $O(n)$ 级别

---

## 拓展练习
1. [P3667 光开关](https://www.luogu.com.cn/problem/P3667) - 区间翻转与统计
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 差分数组应用
3. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719) - 二维前缀和与离散化结合

---

## 题解心得摘录
- **注意区间边界**：多组样例验证确保结束点正确处理（如样例2的重复区间）
- **避免溢出**：使用 `long long` 类型处理大数相乘
- **调试技巧**：构造小数据手工验证差分逻辑（如样例1的逐日验证）

---
处理用时：106.53秒
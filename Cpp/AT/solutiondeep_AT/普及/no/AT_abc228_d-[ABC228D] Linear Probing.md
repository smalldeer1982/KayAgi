# 题目信息

# [ABC228D] Linear Probing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc228/tasks/abc228_d

$ N\ =\ 2^{20} $ 項からなる数列 $ A\ =\ (A_0,\ A_1,\ \dots,\ A_{N\ -\ 1}) $ があります。はじめ、全ての要素は $ -1 $ です。

$ Q $ 個のクエリを順番に処理してください。$ i\ \,\ (1\ \leq\ i\ \leq\ Q) $ 個目のクエリは $ t_i\ =\ 1 $ または $ t_i\ =\ 2 $ を満たす整数 $ t_i $ および整数 $ x_i $ で表され、内容は以下の通りです。

- $ t_i\ =\ 1 $ のとき、以下の処理を順番に行う。
  1. 整数 $ h $ を $ h\ =\ x_i $ で定める。
  2. $ A_{h\ \bmod\ N}\ \neq\ -1 $ である間、$ h $ の値を $ 1 $ 増やすことを繰り返す。この問題の制約下でこの操作が有限回で終了することは証明できる。
  3. $ A_{h\ \bmod\ N} $ の値を $ x_i $ で書き換える。
- $ t_i\ =\ 2 $ のとき、その時点での $ A_{x_i\ \bmod\ N} $ の値を出力する。

なお、整数 $ a,\ b $ に対し、$ a $ を $ b $ で割った余りを $ a\ \bmod\ b $ と表します。

## 说明/提示

### 制約

- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ t_i\ \in\ \{\ 1,\ 2\ \}\ \,\ (1\ \leq\ i\ \leq\ Q) $
- $ 0\ \leq\ x_i\ \leq\ 10^{18}\ \,\ (1\ \leq\ i\ \leq\ Q) $
- $ t_i\ =\ 2 $ であるような $ i\ \,\ (1\ \leq\ i\ \leq\ Q) $ が $ 1 $ つ以上存在する。
- 入力は全て整数である。

### Sample Explanation 1

$ x_1\ \bmod\ N\ =\ 1 $ であるので、$ 1 $ 番目のクエリによって $ A_1\ =\ 1048577 $ となります。 $ 2 $ 番目のクエリにおいて、はじめ $ h\ =\ x_2 $ ですが、$ A_{h\ \bmod\ N}\ =\ A_{1}\ \neq\ -1 $ であるので $ h $ の値を $ 1 $ 増やします。すると $ A_{h\ \bmod\ N}\ =\ A_{2}\ =\ -1 $ となるので、このクエリによって $ A_2\ =\ 1 $ となります。 $ 3 $ 番目のクエリにおいて、$ A_{x_3\ \bmod\ N}\ =\ A_{1}\ =\ 1048577 $ を出力します。 $ 4 $ 番目のクエリにおいて、$ A_{x_4\ \bmod\ N}\ =\ A_{3}\ =\ -1 $ を出力します。 この問題において $ N\ =\ 2^{20}\ =\ 1048576 $ は定数であり、入力では与えられないことに注意してください。

## 样例 #1

### 输入

```
4

1 1048577

1 1

2 2097153

2 3```

### 输出

```
1048577

-1```

# AI分析结果



# 题解中文翻译

## 题目描述

有一个包含 $N = 2^{20}$ 项的数列 $A = (A_0, A_1, \dots, A_{N-1})$，初始时所有元素均为 $-1$。需要依次处理 $Q$ 个查询，每个查询为以下两种类型之一：

- **类型 1**：给定整数 $x$，找到最小的 $h \geq x$ 使得 $A_{h \bmod N} = -1$，然后将 $A_{h \bmod N}$ 设为 $x$。
- **类型 2**：给定整数 $x$，输出当前 $A_{x \bmod N}$ 的值。

要求高效处理 $Q \leq 2 \times 10^5$ 次查询。

---

**算法分类**：并查集

---

## 题解分析与结论

### 核心思路
利用**并查集**维护每个位置的下一个可用空槽。每个位置的父节点指向右侧第一个空槽，通过路径压缩优化查找效率。插入时通过并查集快速定位空槽，并更新父节点指向下一个可能空槽。

### 最优题解对比
1. **题解作者：loser_seele（五星）**
   - **亮点**：代码简洁，正确处理模运算边界，并查集维护清晰。
   - **关键代码**：
     ```cpp
     int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
     void solve() {
         int i = find(x % SIZE);
         value[i] = x;
         fa[i] = find((i + 1) % SIZE);
     }
     ```
2. **题解作者：__Creeper（五星）**
   - **亮点**：逻辑清晰，直接使用并查集维护动态跳转。
   - **关键代码**：
     ```cpp
     int i = find(x % N);
     a[i] = x;
     f[i] = find((i + 1) % N);
     ```
3. **题解作者：harmis_yz（四星）**
   - **亮点**：正确实现并查集，但变量命名稍显复杂。
   - **关键代码**：
     ```cpp
     val[find(x%(N-1))] = x;
     fa[find(x%(N-1))] = find((find(x%(N-1)) + 1) % (N-1));
     ```

---

## 关键技巧总结
1. **并查集路径压缩**：快速跳过已占用位置，避免线性扫描。
2. **循环处理边界**：通过模运算将数组尾部与头部连接，形成环形结构。
3. **动态更新父节点**：插入后立即更新父节点指向下一个可能空槽，确保后续查询高效。

---

## 类似题目推荐
1. [P3402 可持久化并查集](https://www.luogu.com.cn/problem/P3402)
2. [P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)
3. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)

---

## 个人心得摘录
- **调试重点**：确保模运算后的索引在合法范围内（如 `0` 到 `N-1`）。
- **易错点**：父节点更新时需考虑循环边界（如末尾位置指向头部）。
- **优化启示**：并查集不仅能处理集合合并，还能高效维护动态跳转关系。

---
处理用时：153.94秒
# 题目信息

# [ABC230D] Destroyer Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc230/tasks/abc230_d

$ N $ 行 $ 10^9 $ 列の格子状の区画に区切られた街に $ N $ 枚の壁があり、$ 1 $ から $ N $ までの番号が割り振られています。  
 壁 $ i $ は上から $ i $ 行目、左から $ L_i $ 列目から $ R_i $ 列目の範囲にあります。(入出力例 $ 1 $ の図も参考にしてください。)

高橋君は $ N $ 枚の壁をすべて破壊することにしました。  
 超人的な腕力を持つ高橋君は、$ 1 $ 回のパンチで連続する $ D $ 列にまとめてダメージを与えることができます。

- より厳密に言い換えると、$ 1 $ 以上 $ 10^9\ -\ D\ +\ 1 $ 以下の **整数** $ x $ を選んで、$ x $ 列目から $ x\ +\ D\ -\ 1 $ 列目に (一部でも) 存在するすべての破壊されていない壁にパンチによるダメージを与えることができます。

壁は一部分でもダメージを受けると、パンチの衝撃波により全体が木っ端みじんに破壊されてしまいます。  
 (入出力例 $ 1 $ の説明も参考にしてください。)

高橋君がすべての壁を破壊するには、少なくとも何回のパンチを放つ必要がありますか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ D\ \leq\ 10^9 $
- $ 1\ \leq\ L_i\ \leq\ R_i\ \leq\ 10^9 $
- 入力はすべて整数である。

### Sample Explanation 1

入力例 $ 1 $ に対応する壁の配置を図示したものが下図です。 !\[image\](https://img.atcoder.jp/ghi/b7b9e6741514f51c6c0aac924589c9d2.png) たとえば次のようにパンチを放つことで、 $ 2 $ 回のパンチですべての壁を破壊することができます。(以下の説明では、$ a $ 列目から $ b $ 列目までの範囲を $ \lbrack\ a,\ b\ \rbrack $ と表記します。) - まず、 $ \lbrack\ 2,\ 4\ \rbrack $ にパンチを放つ。 $ \lbrack\ 2,\ 4\ \rbrack $ に存在する壁である壁 $ 1 $ と壁 $ 2 $ はダメージを受け、破壊される。 - 次に $ \lbrack\ 5,\ 7\rbrack $ にパンチを放つ。$ \lbrack\ 5,\ 7\rbrack $ に存在する壁 $ 3 $ はダメージを受け、破壊される。 また、次の方法でもすべての壁を $ 2 $ 回のパンチで破壊することができます。 - まず、$ \lbrack\ 7,\ 9\ \rbrack $ にパンチを放ち、壁 $ 2 $ と壁 $ 3 $ を破壊する。 - 次に、$ \lbrack\ 1,\ 3\ \rbrack $ にパンチを放ち、壁 $ 1 $ を破壊する。

### Sample Explanation 2

入出力例 $ 1 $ と比べると、壁 $ 3 $ の範囲が $ \lbrack\ 5,\ 9\ \rbrack $ から $ \lbrack\ 4,\ 9\ \rbrack $ に変わりました。 この場合は $ \lbrack\ 2,\ 4\ \rbrack $ にパンチを放つことで $ 1 $ 回ですべての壁を破壊できます。

## 样例 #1

### 输入

```
3 3

1 2

4 7

5 9```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

1 2

4 7

4 9```

### 输出

```
1```

## 样例 #3

### 输入

```
5 2

1 100

1 1000000000

101 1000

9982 44353

1000000000 1000000000```

### 输出

```
3```

# AI分析结果



# 破坏者高桥（Destroyer Takahashi）

## 题目描述

在由 $N$ 行 $10^9$ 列组成的网格状街区中，有 $N$ 堵编号为 $1$ 到 $N$ 的墙。墙 $i$ 位于第 $i$ 行，占据从第 $L_i$ 列到第 $R_i$ 列的连续区间。高桥君每次可以攻击一段连续的 $D$ 列，所有与该区间有交集的未破坏的墙会被彻底摧毁。求摧毁所有墙所需的最少攻击次数。

### 输入格式
- 输入包含 $N+1$ 行：
  - 第一行为两个整数 $N$ 和 $D$。
  - 接下来 $N$ 行，每行两个整数 $L_i$ 和 $R_i$。

### 输出格式
- 输出最少攻击次数。

### 样例
#### 输入样例 1
```
3 3
1 2
4 7
5 9
```
#### 输出样例 1
```
2
```

---

## 算法分类
**贪心**

---

## 题解分析与结论

### 核心思路
所有题解均采用**贪心算法**，核心思路为：
1. **按右端点排序**：将墙按右端点升序排序。
2. **贪心覆盖**：从第一个未被覆盖的墙开始，攻击其右端对应的位置，覆盖尽可能多的后续墙。

### 解决难点
- **区间覆盖的决策**：选择攻击右端点而非左端点，可最大化覆盖后续区间。
- **排序依据的证明**：需证明按右端点排序后的贪心策略能得到最优解。正确性可通过反证法说明——若存在更优解，则必然能调整攻击顺序使其符合贪心规则。

### 最优思路总结
- **排序**：按右端点升序排序。
- **覆盖检测**：维护当前覆盖的最右端位置 `last`。若当前墙的起点 `L_i > last`，则需新攻击，并更新 `last = R_i + D - 1`。

---

## 高质量题解推荐

### 1. 作者：Wi_Fi（⭐⭐⭐⭐⭐）
**关键亮点**：
- 思路清晰简洁，直接指出问题等价于区间覆盖问题。
- 代码实现高效，仅需排序和一次线性遍历。
**核心代码**：
```cpp
sort(a+1, a+n+1, [](wa a, wa b) {
    return a.r < b.r || (a.r == b.r && a.l < b.l);
});
int now = -1e9, ans = 0;
for (int i = 1; i <= n; i++) {
    if (a[i].l > now) {
        ans++;
        now = a[i].r + D - 1;
    }
}
```

### 2. 作者：xiaomuyun（⭐⭐⭐⭐）
**关键亮点**：
- 代码结构清晰，通过 `while` 循环显式跳过已覆盖的墙。
**核心代码**：
```cpp
sort(a+1, a+1+n, [](Walls x, Walls y) { return x.r < y.r; });
for (int i = 1; i <= n; ans++) {
    int cur = i + 1;
    while (a[cur].l <= a[i].r + D - 1 && cur <= n) cur++;
    i = cur;
}
```

### 3. 作者：Symbolize（⭐⭐⭐⭐）
**个人心得**：
- 强调贪心选择右端点的直观性，指出攻击右端点可覆盖更多后续区间。
**核心代码**：
```cpp
sort(a+1, a+n+1, cmp); // 按右端点排序
int last = 0, ans = 0;
for (int i = 1; i <= n; i++) {
    if (last < a[i].l) {
        ans++;
        last = a[i].r + D - 1;
    }
}
```

---

## 拓展与同类题目
1. **同类问题**：区间覆盖问题（如 [P1803 活动安排](https://www.luogu.com.cn/problem/P1803)）。
2. **变形技巧**：若攻击范围不是固定长度，而是需覆盖特定点，需调整贪心策略。
3. **推荐题目**：
   - [P1255 数独挑战](https://www.luogu.com.cn/problem/P1255)（贪心+搜索）
   - [P2887 防晒霜](https://www.luogu.com.cn/problem/P2887)（排序+贪心）
   - [P3948 数据](https://www.luogu.com.cn/problem/P3948)（差分+贪心）

---
处理用时：53.21秒
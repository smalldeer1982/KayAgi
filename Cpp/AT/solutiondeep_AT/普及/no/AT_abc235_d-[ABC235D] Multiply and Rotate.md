# 题目信息

# [ABC235D] Multiply and Rotate

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc235/tasks/abc235_d

正の整数 $ a $ があります。また、黒板に $ 1 $ 個の数が $ 10 $ 進表記で書かれています。  
 黒板に現在書かれている数を $ x $ としたとき、高橋君は次のいずれかの操作を行い、黒板に書かれている数を変化させることができます。

- $ x $ を消し、 $ x $ を $ a $ 倍した数を $ 10 $ 進表記で新たに書きこむ。
- $ x $ を文字列とみなして、列の末尾の数字を文字列の先頭に移動させる。  
   ただし、この操作は $ x\ \geq\ 10 $ かつ $ x $ が $ 10 $ で割り切れないときにしか行えない。

たとえば $ a\ =\ 2,\ x\ =\ 123 $ であるとき、高橋君は次のいずれかの操作を行うことができます。

- $ x $ を消して、 $ x\ \times\ a\ =\ 123\ \times\ 2\ =\ 246 $ を新たに書きこむ。
- $ x $ を文字列とみなして、`123` の末尾の数字である `3` を先頭に移動させる。黒板に書かれている数は $ 123 $ から $ 312 $ に変化する。

はじめ、黒板には $ 1 $ が書かれています。書かれている数を $ N $ に変化させるには最小で何回の操作が必要ですか？ただし、どのように操作しても書かれている数を $ N $ に変化させられない場合は $ -1 $ を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ a\ \lt\ 10^6 $
- $ 2\ \leq\ N\ \lt\ 10^6 $
- 入力はすべて整数である。

### Sample Explanation 1

以下に説明する操作を行うことで、 黒板に書かれている数を $ 4 $ 回で $ 1 $ から $ 72 $ に変化させることができます。 - $ 1 $ つ目の操作を行う。黒板に書かれている数は $ 1\ \to\ 3 $ に変わる。 - $ 1 $ つ目の操作を行う。黒板に書かれている数は $ 3\ \to\ 9 $ に変わる。 - $ 1 $ つ目の操作を行う。黒板に書かれている数は $ 9\ \to\ 27 $ に変わる。 - $ 2 $ つ目の操作を行う。黒板に書かれている数は $ 27\ \to\ 72 $ に変わる。 $ 3 $ 回以下の操作で $ 72 $ に変化させることはできないため、答えは $ 4 $ になります。

### Sample Explanation 2

どのように操作しても黒板に書かれている数を $ 5 $ に変化させることはできません。

### Sample Explanation 3

適切に操作を選ぶことで、 $ 1\ \to\ 2\ \to\ 4\ \to\ 8\ \to\ 16\ \to\ 32\ \to\ 64\ \to\ 46\ \to\ 92\ \to\ 29\ \to\ 58\ \to\ 116\ \to\ 611 $ と $ 12 $ 回の操作で黒板に書かれている数を $ 611 $ に変化させることができ、これが最小です。

## 样例 #1

### 输入

```
3 72```

### 输出

```
4```

## 样例 #2

### 输入

```
2 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 611```

### 输出

```
12```

## 样例 #4

### 输入

```
2 767090```

### 输出

```
111```

# AI分析结果



# [ABC235D] Multiply and Rotate

## 题目描述

有一个正整数 $a$。黑板上最初写有数字 $1$。设当前黑板上的数为 $x$，可以进行以下两种操作：

- 将 $x$ 乘以 $a$（操作一）
- 将 $x$ 视为字符串，将末尾数字移到开头（操作二，仅当 $x \geq 10$ 且 $x$ 不是 10 的倍数时可用）

求将数字变为 $N$ 所需的最少操作次数，若无法达成则输出 $-1$。

## 算法分类
**广度优先搜索 BFS**

---

## 题解分析与结论

### 核心思路
使用 BFS 求最短操作次数，关键点在于：
1. **状态剪枝**：当数值超过 $N$ 的 10 倍时停止扩展（操作二无法减少位数）
2. **旋转操作优化**：通过整数运算代替浮点运算计算位数
3. **访问标记**：记录每个数值的最小步数，避免重复处理

### 精选题解（评分≥4星）

#### 题解：wnsyou（★★★★☆）
**关键亮点**：
- 动态剪枝条件：当数值超过 $n \times 10$ 时跳过
- 精确计算旋转后的数值（避免浮点误差）
- 使用数组记录最小步数，空间效率高

**核心代码解析**：
```cpp
void Record (long long x, int lv) {
  if (x >= INF || f[x] != -1) return; // 剪枝及去重
  f[x] = lv;
  q.push(x);
}

long long W (long long x) { // 计算移动位数对应的基数
  long long sum = 1;
  while (x) x /= 10, sum *= 10;
  return sum / 10;
}

void bfs() {
  Record(1, 0);
  while (!q.empty()) {
    long long t = q.front(); q.pop();
    if (t == n) { cout << f[t]; exit(0); }
    // 操作一扩展
    if (t * a <= INF) Record(t * a, f[t] + 1);
    // 操作二扩展
    if (t > 10 && t % 10) {
      long long moved = t / 10 + (t % 10) * W(t / 10);
      Record(moved, f[t] + 1);
    }
  }
}
```

#### 题解：chengning0909（★★★★☆）
**关键亮点**：
- 基于位数的剪枝策略，更直观有效
- 使用结构体封装状态，代码可读性强
- 预处理每个数的位数避免重复计算

**核心代码片段**：
```cpp
struct Status{ LL result, num; };
queue<Status> q;

void bfs() {
  q.push({0, 1});
  while (!q.empty()) {
    Status now = q.front(); q.pop();
    if (now.num == n) { /* 输出答案 */ }
    if (now.num * a <= MAXX) /* 扩展操作一 */
    if (now.num % 10 != 0) {
      // 通过整数运算计算旋转后的值
      int siz = log10(now.num);
      LL moved = (now.num/10) + (now.num%10)*pow(10,siz);
      /* 扩展操作二 */
    }
  }
}
```

---

## 总结与扩展

### 关键技巧
1. **BFS 剪枝优化**：通过数值上限或位数限制减少状态空间
2. **整数运算代替浮点运算**：确保旋转计算的准确性
3. **状态复用**：记录访问过的数值及最小步数

### 类似题目推荐
1. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)（BFS 最短路）
2. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)（字符串 BFS 扩展）
3. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)（剪枝优化的经典问题）

### 调试心得摘录
> "操作二的条件判断容易遗漏对非10倍数的检查，导致WA。剪枝条件要结合题目特性，例如当数值位数超过目标时，操作二也无法缩小到目标位数。" —— 来自题解实践

---
处理用时：65.37秒
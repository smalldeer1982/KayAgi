# 题目信息

# [ABC239E] Subtree K-th Max

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc239/tasks/abc239_e

$ N $ 頂点の根付き木があります。頂点には $ 1 $ から $ N $ の番号がついており、根は頂点 $ 1 $ です。  
 $ i $ 番目の辺は頂点 $ A_i $ と $ B_i $ を結んでいます。  
 頂点 $ i $ には整数 $ X_i $ が書かれています。

$ Q $ 個のクエリが与えられます。$ i $ 番目のクエリでは整数の組 $ (V_i,K_i) $ が与えられるので、次の問題に答えてください。

- 問題：頂点 $ V_i $ の部分木に含まれる頂点に書かれた整数のうち、大きい方から $ K_i $ 番目の値を求めよ

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 0\leq\ X_i\leq\ 10^9 $
- $ 1\leq\ A_i,B_i\leq\ N $
- $ 1\leq\ Q\ \leq\ 10^5 $
- $ 1\leq\ V_i\leq\ N $
- $ 1\leq\ K_i\leq\ 20 $
- 与えられるグラフは木である
- 頂点 $ V_i $ の部分木は頂点を $ K_i $ 個以上持つ
- 入力に含まれる値は全て整数である

### Sample Explanation 1

この入力において与えられる木は下図のようなものです。 !\[図\](https://img.atcoder.jp/ghi/e2bc1237d64f79f33181e6f54c9f7ce7.png) $ 1 $ 番目のクエリでは、頂点 $ 1 $ の部分木に含まれる頂点 $ 1,2,3,4,5 $ に書かれた数のうち大きい方から $ 2 $ 番目である $ 4 $ を出力します。 $ 2 $ 番目のクエリでは、頂点 $ 2 $ の部分木に含まれる頂点 $ 2,3,5 $ に書かれた数のうち大きい方から $ 1 $ 番目である $ 5 $ を出力します。

## 样例 #1

### 输入

```
5 2

1 2 3 4 5

1 4

2 1

2 5

3 2

1 2

2 1```

### 输出

```
4

5```

## 样例 #2

### 输入

```
6 2

10 10 10 9 8 8

1 4

2 1

2 5

3 2

6 4

1 4

2 2```

### 输出

```
9

10```

## 样例 #3

### 输入

```
4 4

1 10 100 1000

1 2

2 3

3 4

1 4

2 3

3 2

4 1```

### 输出

```
1

10

100

1000```

# AI分析结果



题目内容中文翻译：
# [ABC239E] Subtree K-th Max

## 题目描述

给定一个包含 $N$ 个节点的有根树，根节点为 1 号节点。每个节点 $i$ 上写有一个整数 $X_i$。处理 $Q$ 个查询，每个查询给出 $(V_i, K_i)$，要求输出以 $V_i$ 为根的子树中所有节点值的第 $K_i$ 大数值。

## 说明/提示

### 约束条件
- $2 \leq N \leq 10^5$
- $0 \leq X_i \leq 10^9$
- $1 \leq Q \leq 10^5$
- $1 \leq K_i \leq 20$

### 样例解释
样例1中，第一个查询的子树包含节点1、2、3、4、5，第二大的数是4；第二个查询的子树包含节点2、3、5，最大的数是5。

---

**算法分类**：深度优先搜索 DFS

---

### 题解分析与结论

#### 核心思路
利用题目中 $K_i \leq 20$ 的限制，预处理每个子树的前20大数值。通过DFS后序遍历，合并子节点的前20大列表，并加入当前节点值，最终保留前20大值存储。查询时直接取预处理结果。

#### 最优解法关键
1. **预处理子树前20大**：每个节点维护其子树的前20大值数组。
2. **DFS合并子节点数据**：自底向上合并子节点前20大数组，确保时间复杂度为 $O(N \cdot 20 \log 20)$。
3. **空间优化**：仅存储必要的前20大值，总空间复杂度为 $O(N \cdot 20)$。

---

### 高分题解（4星）

**作者：xiaohaoaibiancheng66**  
**亮点**：  
- 巧妙利用 $K \leq 20$ 的限制，将问题转化为线性预处理。
- 使用DFS后序遍历合并子节点数据，代码简洁高效。  
**个人心得**：  
> “注意K的最大值仅为20，这意味着只需维护每个子树的前20大值，无需全量存储。”

**核心代码**：
```cpp
void dfs2(int i) {
    vector<int> hs;
    for (auto v : child[i]) {
        dfs2(v);
        for (int j=1; j<=ans[v][0]; j++)
            hs.push_back(ans[v][j]);
    }
    hs.push_back(a[i]);
    sort(hs.rbegin(), hs.rend());
    ans[i][0] = min(20, (int)hs.size());
    for (int j=1; j<=ans[i][0]; j++)
        ans[i][j] = hs[j-1];
}
```

---

### 拓展与相似题目
1. **P2633 Count on a tree**（树上主席树求第K大）
2. **P3384 【模板】轻重链剖分**（子树操作与路径查询）
3. **P3178 [HAOI2015]树上操作**（子树和与路径修改）

---

**关键技巧总结**：  
- 对于子树统计问题，若存在固定小范围查询参数（如K≤20），优先考虑预处理每个子树的关键值集合。
- 合并子节点数据时，使用排序或堆结构维护前K大值，避免全量计算。

---
处理用时：55.82秒
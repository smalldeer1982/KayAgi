# 题目信息

# [ABC241D] Sequence Query

## 题目描述

# 题意简述
有一个空序列 $A$。给定 $Q$ 次操作，每次询问是以下三种之一：

>`1 x`：向 $A$ 中插入元素 $x$。
>
>`2 x k`：输出 $A$ 中所有 $\le x$ 的元素中的第 $k$ 大值。如果不存在输出 `-1`。
>
>`3 x k`：输出 $A$ 中所有 $\ge x$ 的元素中的第 $k$ 小值。如果不存在输出 `-1`。

## 说明/提示

>$1\le Q\le2\times10^5$。
>
>$1\le x\le10^{18}$。
>
>$1\le k\le5$。
>
>所有输入均为整数。

## 样例 #1

### 输入

```
11
1 20
1 10
1 30
1 20
3 15 1
3 15 2
3 15 3
3 15 4
2 100 5
1 1
2 100 5```

### 输出

```
20
20
30
-1
-1
1```

# AI分析结果



# 题目内容

## [ABC241D] Sequence Query

### 题目描述

有一个空序列 $A$。给定 $Q$ 次操作，每次询问是以下三种之一：

>`1 x`：向 $A$ 中插入元素 $x`。
>
>`2 x k`：输出 $A` 中所有 $\le x$ 的元素中的第 $k$ 大值。如果不存在输出 `-1`。
>
>`3 x k`：输出 $A` 中所有 $\ge x$ 的元素中的第 $k$ 小值。如果不存在输出 `-1`。

### 说明/提示

$1\le Q\le2\times10^5$  
$1\le x\le10^{18}$  
$1\le k\le5$  
所有输入均为整数。

---

## 算法分类
**二分**

---

## 题解分析与结论

### 核心思路
所有题解均采用 `multiset` 维护有序序列，利用其自带的二分查找函数：
1. **插入操作**：直接调用 `insert`
2. **查询操作2**：`upper_bound(x)` 定位首个大于x的位置，向前移动k次找第k大
3. **查询操作3**：`lower_bound(x)` 定位首个不小于x的位置，向后移动k-1次找第k小

### 解决难点
- **边界处理**：移动迭代器时需判断是否越界（`begin()`或`end()`）
- **时间复杂度**：利用k≤5的特性，将查询复杂度控制在O(log n + 5)

---

## 精选题解

### [wxzzzz] ⭐⭐⭐⭐
**亮点**：清晰的变量命名与注释，完美处理边界条件  
**核心代码**：
```cpp
auto ans = a.upper_bound(x);
while (ans != a.begin() && k) k--, ans--;
if (k) cout << "-1\n";
else cout << *ans << '\n';
```

### [tbdsh] ⭐⭐⭐⭐
**亮点**：使用标志位简化边界判断逻辑  
**个人心得**：强调 `prev(m.end())` 处理末尾边界  
**核心代码**：
```cpp
auto it = m.lower_bound(x);
for (int i=1; i<k && flag; i++)
    if (it == prev(m.end())) flag=0, it++;
```

### [loser_seele] ⭐⭐⭐⭐
**亮点**：简洁的循环条件与类型定义  
**调试经验**：强调去年因不会STL导致失败  
**核心代码**：
```cpp
auto it = st.lower_bound(x);
while (it != st.end() && k >= 2)
    k--, it++;
```

---

## 最优技巧总结
1. **有序容器选择**：多重有序集合用 `multiset`
2. **二分函数应用**：`upper_bound` 与 `lower_bound` 定位区间端点
3. **线性扫描优化**：利用k≤5的特性降低时间复杂度

---

## 扩展练习
1. [P3369 普通平衡树](https://www.luogu.com.cn/problem/P3369)  
2. [P2073 送花](https://www.luogu.com.cn/problem/P2073)  
3. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)

---
处理用时：81.89秒
# 题目信息

# [ABC243D] Moves on Binary Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc243/tasks/abc243_d

頂点数 $ 2^{10^{100}}-1 $ の完全二分木があり、頂点には $ 1,2,...,2^{10^{100}}-1 $ の番号がついています。  
 頂点 $ 1 $ が根であり、各 $ 1\leq\ i\ <\ 2^{10^{100}-1} $ について、頂点 $ i $ は 頂点 $ 2i $ を左の子、頂点 $ 2i+1 $ を右の子として持ちます。

高橋君は最初頂点 $ X $ におり、$ N $ 回移動を行います。移動は文字列 $ S $ により表され、$ i $ 回目の移動は次のように行います。

- $ S $ の $ i $ 番目の文字が `U` のとき、今いる頂点の親に移動する
- $ S $ の $ i $ 番目の文字が `L` のとき、今いる頂点の左の子に移動する
- $ S $ の $ i $ 番目の文字が `R` のとき、今いる頂点の右の子に移動する

$ N $ 回の移動後に高橋君がいる頂点の番号を求めてください。なお、答えが $ 10^{18} $ 以下になるような入力のみが与えられます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^6 $
- $ 1\ \leq\ X\ \leq\ 10^{18} $
- $ N,X $ は整数
- $ S $ は長さ $ N $ であり、`U`,`L`,`R` のみからなる
- 高橋君が根にいるとき、親に移動しようとすることはない
- 高橋君が葉にいるとき、子に移動しようとすることはない
- 高橋君が $ N $ 回の移動後にいる頂点の番号は $ 10^{18} $ 以下である

### Sample Explanation 1

完全二分木は次のような構造をしています。 !\[図\](https://img.atcoder.jp/ghi/9e199e154f481af436c8eaec9c487e2c.png) 各移動により、高橋君がいる頂点の番号は $ 2\ \to\ 1\ \to\ 3\ \to\ 6 $ と変化します。

### Sample Explanation 2

移動の途中過程において、高橋君がいる頂点の番号が $ 10^{18} $ を超えることもあります。

## 样例 #1

### 输入

```
3 2

URL```

### 输出

```
6```

## 样例 #2

### 输入

```
4 500000000000000000

RRUU```

### 输出

```
500000000000000000```

## 样例 #3

### 输入

```
30 123456789

LRULURLURLULULRURRLRULRRRUURRU```

### 输出

```
126419752371```

# AI分析结果



# [ABC243D] 二叉树上的移动

## 题目描述

### 题目翻译

有一个包含 $2^{10^{100}}-1$ 个顶点的完全二叉树，顶点编号为 $1,2,...,2^{10^{100}}-1$。  
顶点 $1$ 是根，对于每个 $1\leq i < 2^{10^{100}-1}$，顶点 $i$ 的左子节点是顶点 $2i$，右子节点是顶点 $2i+1$。

高桥君初始位于顶点 $X$，执行 $N$ 次移动。移动序列由字符串 $S$ 表示，第 $i$ 次移动规则如下：

- 当 $S$ 的第 $i$ 个字符是 `U` 时，移动到当前顶点的父节点
- 当 $S` 的第 $i` 个字符是 `L` 时，移动到当前顶点的左子节点
- 当 `S` 的第 `i` 个字符是 `R` 时，移动到当前顶点的右子节点

求 $N` 次移动后高桥君所在的顶点编号。保证答案不超过 $10^{18}$。

### 提示

- 移动过程中可能产生超过 $10^{18}$ 的中间值
- 需要处理 $10^6$ 量级的操作次数
- 必须避免直接模拟导致数值溢出

---

**算法标签**: 栈、模拟

---

## 题解综合分析

### 最优思路总结
核心思路是**操作抵消优化**：利用栈结构消除冗余的 `L/U` 和 `R/U` 操作对。当遇到 `U` 操作时，若栈顶存在可抵消的 `L/R` 操作则弹出，否则保留 `U`。最终只需处理栈中剩余操作，确保数值计算始终在可控范围内。

### 高分题解推荐

#### 1. wizardMarshall（★★★★☆）
**亮点**：
- 使用栈结构实现操作序列化简
- 通过标记删除法避免中间溢出
- 代码简洁高效（时间复杂度 O(N)）

**核心代码**：
```cpp
stack<int> q;
for (int i = 0; i < len; i++) {
    if (s[i] == 'U') {
        if (!q.empty()) {
            s[q.top()] = 0; q.pop(); s[i] = 0;
        }
    } else {
        q.push(i);
    }
}
// 处理剩余操作
for (int i = 0; i < len; i++) {
    if (s[i] == 'L') x *= 2;
    else if (s[i] == 'R') x = x*2 + 1;
    else if (s[i] == 'U') x /= 2;
}
```

#### 2. liuyi0905（★★★★☆）
**亮点**：
- 极简实现（仅用字符数组存储操作）
- 动态处理栈顶指针
- 省去标准库栈的内存开销

**核心代码**：
```cpp
char s[N]; // 操作序列存储
for (int i=1; i<=n; i++) {
    cin >> c;
    c=='U' ? (tp?tp--:x/=2) : (s[++tp]=c,1);
}
// 最终计算
for (int i=1; i<=tp; i++)
    x = 2*x + (s[i]=='R');
```

#### 3. chengning0905（★★★★☆）
**亮点**：
- 二进制视角转换
- 使用位运算高效处理路径
- 避免大数运算的巧妙思路

**核心代码**：
```cpp
void F() { // 转换为二进制序列
    long long p = X;
    while(p) {
        x[len++] = p%2;
        p /= 2;
    }
}
// 处理操作序列
for (int i=0; i<s.size(); i++) {
    if(s[i]=='U') top--;
    else if(s[i]=='L') stk[++top]=0;
    else stk[++top]=1;
}
```

---

## 拓展应用

### 类似题目推荐
1. [P1030 求二叉树的遍历](https://www.luogu.com.cn/problem/P1030) - 树结构操作基础
2. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449) - 栈结构经典应用
3. [P1241 括号序列](https://www.luogu.com.cn/problem/P1241) - 栈匹配问题变形

### 关键技巧
1. **操作抵消思想**：适用于存在反向操作可逆的场景
2. **路径压缩优化**：通过预处理减少无效操作的计算量
3. **二进制视角**：将树结构路径转换为二进制位操作，提升效率

---

**学习建议**：在处理超大数值问题时，应优先考虑操作序列优化而非直接计算。通过分析操作间的关联性，寻找可化简的操作对，往往能有效解决数值溢出问题。

---
处理用时：47.86秒
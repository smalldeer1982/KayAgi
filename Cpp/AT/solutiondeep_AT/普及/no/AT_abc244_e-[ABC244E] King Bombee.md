# 题目信息

# [ABC244E] King Bombee

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc244/tasks/abc244_e

$ N $ 頂点 $ M $ 辺の単純無向グラフが与えられます。このグラフの頂点には $ 1 $ から $ N $ の番号が付けられており、辺には $ 1 $ から $ M $ の番号が付けられています。辺 $ i $ は頂点 $ U_i $ と頂点 $ V_i $ の間を結んでいます。

整数 $ K,\ S,\ T,\ X $ が与えられます。以下の条件を満たす数列 $ A\ =\ (A_0,\ A_1,\ \dots,\ A_K) $ は何通りありますか？

- $ A_i $ は $ 1 $ 以上 $ N $ 以下の整数
- $ A_0\ =\ S $
- $ A_K\ =\ T $
- 頂点 $ A_i $ と頂点 $ A_{i\ +\ 1} $ の間を直接結ぶ辺が存在する
- 数列 $ A $ の中に整数 $ X\ (X≠S,X≠T) $ は偶数回出現する ( $ 0 $ 回でも良い)

ただし、答えは非常に大きくなることがあるので、答えを $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ <\ =N\ <\ =2000 $
- $ 1\ <\ =M\ <\ =2000 $
- $ 1\ <\ =K\ <\ =2000 $
- $ 1\ <\ =S,T,X\ <\ =N $
- $ X≠S $
- $ X≠T $
- $ 1\ <\ =U_i\ <\ V_i\ <\ =N $
- $ i≠j $ ならば $ (U_i,\ V_i)≠(U_j,\ V_j) $

### Sample Explanation 1

\- $ (1,\ 2,\ 1,\ 2,\ 3) $ - $ (1,\ 2,\ 3,\ 2,\ 3) $ - $ (1,\ 4,\ 1,\ 4,\ 3) $ - $ (1,\ 4,\ 3,\ 4,\ 3) $ の $ 4 $ 個が条件を満たします。$ (1,\ 2,\ 3,\ 4,\ 3) $ や $ (1,\ 4,\ 1,\ 2,\ 3) $ は $ 2 $ が奇数回出現するため、条件を満たしません。

### Sample Explanation 2

グラフは連結であるとは限りません。

### Sample Explanation 3

$ 998244353 $ で割ったあまりを求めてください。

## 样例 #1

### 输入

```
4 4 4 1 3 2

1 2

2 3

3 4

1 4```

### 输出

```
4```

## 样例 #2

### 输入

```
6 5 10 1 2 3

2 3

2 4

4 6

3 6

1 5```

### 输出

```
0```

## 样例 #3

### 输入

```
10 15 20 4 4 6

2 6

2 7

5 7

4 5

2 4

3 7

1 7

1 4

2 9

5 10

1 3

7 8

7 9

1 6

1 2```

### 输出

```
952504739```

# AI分析结果



### 题目内容
#### [ABC244E] King Bombee

**题目描述**  
给定一个包含 $N$ 个顶点和 $M$ 条边的简单无向图。顶点编号为 $1$ 到 $N$，边编号为 $1$ 到 $M$。每条边连接两个顶点 $U_i$ 和 $V_i$。给定整数 $K, S, T, X$，求满足以下条件的路径数量（对 $998244353$ 取模）：
- 路径长度为 $K$（经过 $K+1$ 个顶点）
- 起点为 $S$，终点为 $T$
- 路径中顶点 $X$ 出现的次数为偶数次（$X≠S$ 且 $X≠T$）

**输入格式**  
第一行包含 $N, M, K, S, T, X$。  
接下来 $M$ 行每行两个整数表示边的两个顶点。

**输出格式**  
输出满足条件的路径数取模后的结果。

---

### 分类
动态规划

---

### 题解综合分析
本题核心在于**状态设计**和**转移方向**的控制。所有题解均采用动态规划，但关键差异在于邻接表遍历方向是否与状态转移方向一致。正确的转移方向需保证从当前节点转移到邻接节点，而非反向操作。

---

### 精选题解

#### 1. appear_hope（评分：★★★★☆）
**关键亮点**  
- 邻接表遍历方向与状态转移方向一致，确保正确性。
- 代码简洁，状态转移逻辑清晰。
- 直接处理奇偶性翻转，无需冗余条件判断。

**核心代码**  
```cpp
for(int i = 1; i <= k; i++) {
    for(int j = 1; j <= n; j++) {
        for(int v : g[j]) {
            if(v == x) {
                dp[i][v][0] = (dp[i][v][0] + dp[i-1][j][1]) % mod;
                dp[i][v][1] = (dp[i][v][1] + dp[i-1][j][0]) % mod;
            } else {
                dp[i][v][0] = (dp[i][v][0] + dp[i-1][j][0]) % mod;
                dp[i][v][1] = (dp[i][v][1] + dp[i-1][j][1]) % mod;
            }
        }
    }
}
```

---

### 最优思路总结
**状态设计**：定义 `dp[i][u][k]` 表示经过 `i` 条边到达节点 `u`，且 `X` 出现次数的奇偶性为 `k`（0 表示偶数次）。  
**转移关键**：遍历每个节点的邻接边，根据邻接节点是否为 `X` 决定奇偶性翻转。  
**实现技巧**：使用邻接表正向遍历，确保转移方向正确。

---

### 拓展与相似题目
1. **路径计数（含特殊条件）**：  
   - [ABC211E - Red Polyomino](https://atcoder.jp/contests/abc211/tasks/abc211_e)  
   - [洛谷 P1271 路径计数](https://www.luogu.com.cn/problem/P1271)  
   - [洛谷 P4011 孤岛营救问题](https://www.luogu.com.cn/problem/P4011)  
2. **状态压缩动态规划**：  
   - [洛谷 P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)

---
处理用时：315.63秒
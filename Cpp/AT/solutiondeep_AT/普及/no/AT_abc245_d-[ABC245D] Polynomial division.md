# 题目信息

# [ABC245D] Polynomial division

## 题目描述

现在有 $N$ 次多项式 $A（x）=A_Nx^N+A_{N-1}x^{N-1}+\cdots\ +A_1x+A_0$ 和 $M$ 次多项式 $B(x)=B_Mx^M+B_{M-1}x^{M-1}+\cdots\ +B_1x+B_0$。

其中，$A(x)、B(x)$ 中的每个系数都是绝对值小于等于 $100$ 的整数，并且最高的下一个系数不是 $0$。

定义它们的积为 $C(x)=A(x)B(x)=C_{N+M}x^{N+M}+C_{N+M-1}x^{N+M-1}+\cdots\ +C_1x+C_0$。

已知 $A_0,A_1,\ldots,\ A_N$ 和 $C_0,C_1,\ldots,\ C_{N+M}$，请求出 $B_0,B_1,\ldots,\ B_M$。

输入保证只有一种 $B_0,B_1,\ldots,\ B_M$。

## 说明/提示

- $ 1\leq N<100 $

- $ 1\leq M<100 $

- $ |A_i|\leq100 $

- $ |C_i|\leq10^6 $

- $ A_N\neq0 $

- $ C_{N+M}\neq0 $

- 满足条件的 $B_0,B_1,\ldots,\ B_M$ 只有一个

## 样例 #1

### 输入

```
1 2

2 1

12 14 8 2```

### 输出

```
6 4 2```

## 样例 #2

### 输入

```
1 1

100 1

10000 0 -1```

### 输出

```
100 -1```

# AI分析结果



### 题目内容重写  
[ABC245D] 多项式除法  

#### 题目描述  
给定 $N$ 次多项式 $A(x)=A_Nx^N+A_{N-1}x^{N-1}+\cdots +A_1x+A_0$ 和 $M$ 次多项式 $B(x)=B_Mx^M+B_{M-1}x^{M-1}+\cdots +B_1x+B_0$。已知它们的积 $C(x)=A(x)B(x)=C_{N+M}x^{N+M}+C_{N+M-1}x^{N+M-1}+\cdots +C_1x+C_0$，以及 $A$ 的所有系数和 $C$ 的所有系数，求 $B$ 的所有系数。保证解唯一。  

#### 输入格式  
第一行输入 $N$ 和 $M$。  
第二行输入 $A_0,A_1,\ldots,A_N$。  
第三行输入 $C_0,C_1,\ldots,C_{N+M}$。  

#### 输出格式  
输出 $B_0,B_1,\ldots,B_M$。  

---

### 算法分类  
模拟  

---

### 题解对比与结论  
#### 核心思路  
所有题解均基于多项式除法原理：  
1. 从最高次项开始逐项计算 $B$ 的系数  
2. 每次用当前余式的最高次项除以 $A$ 的最高次项系数得到 $B_i$  
3. 将 $B_i$ 乘以 $A$ 的各个系数，从余式中减去对应项  
4. 重复上述过程直到余式次数低于 $A$  

#### 关键难点对比  
| 题解差异点          | 处理方式                                                                 |
|---------------------|--------------------------------------------------------------------------|
| 数组索引方向        | 部分题解将系数按升幂存储（样例输入顺序），部分按降幂处理                 |
| 数据类型            | 使用 `long long` 的题解（如 Hog_Dawa_IOI）可避免中间结果溢出            |
| 余式更新顺序        | 正确实现需从当前最高项向后更新余式（类似竖式除法借位操作）               |

---

### 高星题解推荐  
#### 1. Hog_Dawa_IOI（⭐⭐⭐⭐⭐）  
**亮点**：  
- 明确处理数组索引方向  
- 使用 `long long` 防止溢出  
- 包含调试经验："不开 long long 会见祖宗"  

**核心代码**：  
```cpp
for(int i1=m-1,i2=n+m-1;i1>=0;i1--,i2--){
    long long num=c[i2];
    for(int j=i1+1;j<=m;j++) num-=b[j]*a[i2-j];
    b[i1]=num/a[n];
}
```

#### 2. RainCQwQ（⭐⭐⭐⭐）  
**亮点**：  
- 代码简洁清晰  
- 直接操作输入顺序的数组  

**核心代码**：  
```cpp
for(int i=m;i>=0;i--){
    b[i]=c[i+n]/a[n];
    for(int j=n;j>=0;j--)
        c[i+j]-=b[i]*a[j];
}
```

#### 3. BLuemoon_（⭐⭐⭐⭐）  
**亮点**：  
- 结合竖式除法示意图辅助理解  
- 正确处理余式更新方向  

**核心代码**：  
```cpp
for(int i=0;i<=n/2.0-0.5;++i) swap(a[i],a[n-i]); // 将系数转为降幂排列
for(int top=0;top<=n+m;++top){
    int tmp = c[top]/a[0];
    b.push_back(tmp);
    for(int j=0;j<=n;j++) c[j+top]-=a[j]*tmp;
}
```

---

### 关键思路总结  
**核心技巧**：  
1. **降幂处理**：将输入系数转为降幂排列（或通过索引反向访问）  
2. **逐项消元**：从 $B$ 的最高次项开始计算，每次确定一项后立即更新余式  
3. **防溢出**：使用 `long long` 类型存储中间结果  

**调试经验**：  
- 必须注意余式更新顺序，错误的方向会导致后续计算污染当前结果  
- 样例 2 中 $A$ 的最高次项系数为 100，若使用 `int` 可能溢出  

---

### 拓展练习  
1. [P3803 【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3803)  
2. [P4512 【模板】多项式除法](https://www.luogu.com.cn/problem/P4512)  
3. [P2005 A/B Problem II（高精度除法）](https://www.luogu.com.cn/problem/P2005)

---
处理用时：59.21秒
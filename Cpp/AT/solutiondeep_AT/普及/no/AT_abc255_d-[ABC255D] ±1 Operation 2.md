# 题目信息

# [ABC255D] ±1 Operation 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_d

長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。この $ A $ に以下を施すことを「操作」と呼びます。

- まず、 $ 1\ \le\ i\ \le\ N $ を満たす整数 $ i $ を選択する。
- 次に、以下の $ 2 $ つのうちどちらかを選択し、実行する。
  - $ A_i $ に $ 1 $ を加算する。
  - $ A_i $ から $ 1 $ を減算する。

$ Q $ 個の質問に答えてください。  
$ i $ 個目の質問は以下です。

- 「操作」を $ 0 $ 回以上何度でも使って $ A $ の要素を全て $ X_i $ にする時、必要な「操作」の最小回数を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N,Q\ \le\ 2\ \times\ 10^5 $
- $ 0\ \le\ A_i\ \le\ 10^9 $
- $ 0\ \le\ X_i\ \le\ 10^9 $

### Sample Explanation 1

$ A=(6,11,2,5,5) $ であり、この入力には $ 3 $ つの質問が含まれます。 $ 1 $ つ目の質問について、 $ A $ に以下のように $ 10 $ 回の「操作」を施すことで、 $ A $ の要素を全て $ 5 $ にすることができます。 - $ A_1 $ から $ 1 $ 減算する。 - $ A_2 $ から $ 1 $ 減算することを $ 6 $ 度繰り返す。 - $ A_3 $ に $ 1 $ 加算することを $ 3 $ 度繰り返す。 $ 9 $ 回以下の「操作」で $ A $ の要素を全て $ 5 $ にすることはできません。 $ 2 $ つ目の質問について、 $ A $ に $ 71 $ 回の「操作」を施すことで、 $ A $ の要素を全て $ 20 $ にすることができます。 $ 3 $ つ目の質問について、 $ A $ に $ 29 $ 回の「操作」を施すことで、 $ A $ の要素を全て $ 0 $ にすることができます。

### Sample Explanation 2

出力が $ 32 $bit 整数に収まらない場合もあります。

## 样例 #1

### 输入

```
5 3
6 11 2 5 5
5
20
0```

### 输出

```
10
71
29```

## 样例 #2

### 输入

```
10 5
1000000000 314159265 271828182 141421356 161803398 0 777777777 255255255 536870912 998244353
555555555
321654987
1000000000
789456123
0```

### 输出

```
3316905982
2811735560
5542639502
4275864946
4457360498```

# AI分析结果



【中文重写题目】  
# [ABC255D] ±1 操作 2  

## 题目描述  

给定长度为 $N$ 的数列 $A=(A_1,A_2,\dots,A_N)$。每次操作可选择一个元素进行 ±1 调整。回答 $Q$ 个询问：通过若干次操作将所有元素变为 $X_i$ 的最小操作次数。  

## 说明/提示  
- $1 ≤ N,Q ≤ 2×10^5$  
- $0 ≤ A_i,X_i ≤ 10^9$  

---

**算法分类**：前缀和 + 二分  

---

### 题解综合分析  
各题解核心思路一致：  
1. **排序**数组以分割元素  
2. **前缀和**快速计算区间和  
3. **二分查找**确定分割点  
4. 分两部分计算差值总和  

关键差异点：  
- 使用 `lower_bound` vs `upper_bound` 处理边界  
- 是否显式处理极值情况（如X超出数组范围）  
- 代码可读性与优化细节（如使用STL函数）  

---

### 精选题解（4★+）  

#### 1. 作者：WaterSun（5★）  
**亮点**：  
- 同时使用 `lower_bound` 和 `upper_bound` 处理等值区间  
- 显式处理极值边界情况  
- 代码结构清晰，注释明确  

**核心代码**：  
```cpp
sort(arr + 1, arr + 1 + n);
for (int i = 1; i <= n; i++) s[i] = s[i - 1] + arr[i];

int id1 = lower_bound(arr + 1, arr + 1 + n, x) - arr - 1;
int id2 = upper_bound(arr + 1, arr + 1 + n, x) - arr;
int pre = id1 * x - s[id1]; 
int nxt = (s[n] - s[id2-1]) - x * (n - id2 + 1);
cout << pre + nxt;
```

#### 2. 作者：封禁用户（4★）  
**亮点**：  
- 简洁使用 `upper_bound` 确定分割点  
- 公式推导清晰易懂  

**核心代码**：  
```cpp
sort(a+1, a+n+1);
int k = upper_bound(a+1,a+n+1,x)-a-1;
cout << (x*k - s[k]) + (s[n]-s[k] - x*(n-k));
```

#### 3. 作者：FReQuenter（4★）  
**亮点**：  
- 手写二分实现更灵活  
- 代码简洁无冗余  

**核心代码**：  
```cpp
int l=1, r=n, best=0;
while(l<=r) {
    int mid=l+r>>1;
    if(a[mid]<=x) best=mid, l=mid+1;
    else r=mid-1;
}
cout << x*best - s[best] + (s[n]-s[best] -x*(n-best));
```

---

### 关键优化技巧  
1. **排序与前缀和的结合**：预处理后可在O(1)时间获取任意区间的和  
2. **二分边界处理**：  
   - `lower_bound` 找第一个≥x的位置 → 前段截止点  
   - `upper_bound` 找第一个>x的位置 → 后段起始点  
3. **差值公式推导**：  
   - 前段总和 = x×个数 - 前缀和  
   - 后段总和 = 后缀和 - x×个数  

---

### 相似题目推荐  
1. [P1678 烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678)  
2. [P1873 砍树](https://www.luogu.com.cn/problem/P1873)  
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)  

---

### 心得体会摘录  
- **排序的必要性**：多个题解强调排序后才能应用二分策略  
- **边界测试**：有题解提到曾因未处理X超出数组范围导致WA  
- **绝对值陷阱**：初始错误思路直接用总和差值被反例证伪

---
处理用时：47.19秒
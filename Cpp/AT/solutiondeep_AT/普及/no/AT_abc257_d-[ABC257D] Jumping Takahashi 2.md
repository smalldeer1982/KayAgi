# 题目信息

# [ABC257D] Jumping Takahashi 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc257/tasks/abc257_d

高橋君が住んでいる二次元平面上の街には $ N $ 個のジャンプ台があります。$ i $ 番目のジャンプ台は点 $ (x_i,\ y_i) $ にあり、ジャンプ台のパワーは $ P_i $ です。また高橋君のジャンプ力は $ S $ で表され、はじめ $ S=0 $ です。高橋君が訓練を $ 1 $ 回行う度に $ S $ は $ 1 $ 増えます。

高橋君は以下の条件を満たす場合に限り、$ i $ 番目のジャンプ台から $ j $ 番目のジャンプ台にジャンプすることができます。

- $ P_iS\geq\ |x_i\ -\ x_j|\ +|y_i\ -\ y_j| $

高橋君の目的は、適切に始点とするジャンプ台を決めることで、そのジャンプ台からどのジャンプ台にも何回かのジャンプで移動できるようにすることです。

目的を達成するためには高橋君は最低で何回訓練を行う必要があるでしょうか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 200 $
- $ -10^9\ \leq\ x_i,y_i\ \leq\ 10^9 $
- $ 1\ \leq\ P_i\ \leq\ 10^9 $
- $ (x_i,\ y_i)\ \neq\ (x_j,y_j)\ (i\neq\ j) $
- 入力は全て整数

### Sample Explanation 1

高橋君が $ 2 $ 回訓練したとすると、 $ S=2 $ です。 このとき、$ 2 $ 番目のジャンプ台から全てのジャンプ台に移動することができます。 例えば、$ 4 $ 番目のジャンプ台へは以下の方法で移動ができます。 - $ 2 $ 番目のジャンプ台から $ 3 $ 番目のジャンプ台へジャンプする。（ $ P_2\ S\ =\ 10,\ |x_2-x_3|\ +\ |y_2-y_3|\ =\ 10 $ であり、 $ P_2\ S\ \geq\ |x_2-x_3|\ +\ |y_2-y_3| $ を満たす。） - $ 3 $ 番目のジャンプ台から $ 4 $ 番目のジャンプ台へジャンプする。（ $ P_3\ S\ =\ 2,\ |x_3-x_4|\ +\ |y_3-y_4|\ =\ 1 $ であり、 $ P_3\ S\ \geq\ |x_3-x_4|\ +\ |y_3-y_4| $ を満たす。）

## 样例 #1

### 输入

```
4

-10 0 1

0 0 5

10 0 1

11 0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
7

20 31 1

13 4 3

-10 -15 2

34 26 5

-2 39 4

0 -50 1

5 -20 2```

### 输出

```
18```

# AI分析结果



# [ABC257D] Jumping Takahashi 2

## 题目内容

### 题目描述

高桥君居住在二维平面上的城市中，这里有 $N$ 个跳跃台。第 $i$ 个跳跃台位于坐标 $(x_i, y_i)$，跳跃台的功率为 $P_i$。高桥君的跳跃力用 $S$ 表示，初始时 $S=0$。每进行一次训练，$S$ 增加 $1$。

当且仅当满足 $P_iS \geq |x_i - x_j| + |y_i - y_j|$ 时，高桥君可以从第 $i$ 个跳跃台跳到第 $j$ 个跳跃台。

高桥君需要选择一个起点，使得从该起点出发能通过若干次跳跃到达所有其他跳跃台。求达成目标所需的最少训练次数。

### 输入格式

第一行输入整数 $N$，随后 $N$ 行每行给出三个整数 $x_i, y_i, P_i$。

### 输出格式

输出最小的训练次数。

### 样例

#### 样例 #1
输入：
```
4
-10 0 1
0 0 5
10 0 1
11 0 1
```
输出：
```
2
```

#### 样例 #2
输入：
```
7
20 31 1
13 4 3
-10 -15 2
34 26 5
-2 39 4
0 -50 1
5 -20 2
```
输出：
```
18
```

---

## 算法分类
**二分 + 图论**

---

## 题解分析与结论

### 题解对比

| 方法                     | 核心思路                                                                 | 时间复杂度      | 优化点/难点                          |
|--------------------------|--------------------------------------------------------------------------|-----------------|--------------------------------------|
| 二分+DFS/BFS            | 二分验证S，枚举起点后DFS/BFS判断连通性                                   | $O(n^3 \log V)$ | 直观易理解，需处理连通性判断         |
| Floyd预处理最大边权     | 预处理点对间最小S需求，Floyd松弛路径中的最大边权，取所有起点最大值的最小 | $O(n^3)$        | 避免二分，需理解路径松弛条件         |
| 二分+传递闭包           | 二分后用bitset加速传递闭包计算                                           | $O(n^3 \log V)$ | 利用bitset优化常数，减少内存访问开销 |

### 最优思路总结
**二分+图遍历** 是最易实现且效率较高的方法。核心要点：
1. **单调性验证**：S越大越容易满足条件，适合二分
2. **邻接矩阵构建**：根据当前S值建立可达性邻接表
3. **连通性判断**：对每个起点进行DFS/BFS，判断能否到达所有节点
4. **边界处理**：二分范围上限需覆盖最大曼哈顿距离（$4 \times 10^9$）

---

## 精选题解

### 题解1：hjyowl（★★★★☆）
**核心亮点**：二分框架清晰，DFS连通性判断逻辑完整，包含数据范围处理说明  
**代码核心**：
```cpp
bool check(long long s) {
    memset(f, 0, sizeof f);
    // 构建邻接矩阵
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j)
            f[i][j] = (p[i]*s >= abs(x[i]-x[j]) + abs(y[i]-y[j]));
    // 传递闭包
    for(int k=1; k<=n; ++k)
        for(int i=1; i<=n; ++i)
            for(int j=1; j<=n; ++j)
                f[i][j] |= f[i][k] && f[k][j];
    // 检查是否存在全连通起点
    for(int i=1; i<=n; ++i) {
        bool ok = true;
        for(int j=1; j<=n; ++j) ok &= f[i][j];
        if(ok) return true;
    }
    return false;
}
```

### 题解2：returnzheng（★★★★★）
**核心亮点**：Floyd预处理思路创新，直接计算最小S需求  
**代码核心**：
```cpp
void floyd() {
    for(int k=1; k<=n; ++k)
        for(int i=1; i<=n; ++i)
            for(int j=1; j<=n; ++j)
                f[i][j] = min(f[i][j], max(f[i][k], f[k][j]));
}

int main() {
    // 初始化邻接矩阵
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j)
            f[i][j] = ceil((double)dist(i,j)/p[i]);
    floyd();
    // 找所有起点中的最小值
    long long ans = 2e18;
    for(int i=1; i<=n; ++i) {
        long long mx = 0;
        for(int j=1; j<=n; ++j) mx = max(mx, f[i][j]);
        ans = min(ans, mx);
    }
    cout << ans;
}
```

### 题解3：_cbw（★★★★☆）
**核心亮点**：bitset优化传递闭包，显著提升常数效率  
**实现技巧**：
```cpp
bitset<BSN> g[MAXN]; // 使用bitset存储邻接矩阵

void closure() {
    for(int k=1; k<=n; ++k)
        for(int i=1; i<=n; ++i)
            if(g[i][k]) g[i] |= g[k];
}
```

---

## 举一反三
1. **P1948 [USACO08JAN] Telephone Lines S**  
   （二分答案+最短路验证）
2. **P1525 关押罪犯**  
   （二分答案+图染色判断）
3. **P2865 [USACO06NOV] Roadblocks G**  
   （次短路与路径松弛思想）

---

## 调试经验
1. **数据类型溢出**：多个题解强调使用 `long long` 处理大数运算
2. **浮点精度处理**：计算 `ceil(dis/p)` 时采用浮点转换避免整数除法误差
3. **传递闭包顺序**：Floyd算法必须将中间点循环放在最外层
4. **边界值测试**：极端情况如 $n=2$ 且坐标差极大时需验证算法稳定性

---
处理用时：69.88秒
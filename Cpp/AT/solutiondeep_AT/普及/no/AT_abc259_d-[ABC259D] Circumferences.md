# 题目信息

# [ABC259D] Circumferences

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc259/tasks/abc259_d

$ xy $ -平面上の $ N $ 個の円が与えられます。 $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、$ i $ 番目の円は点 $ (x_i,\ y_i) $ を中心とする半径 $ r_i $ の円です。

$ N $ 個の円のうち少なくとも $ 1 $ つ以上の円の円周上にある点のみを通って、点 $ (s_x,\ s_y) $ から点 $ (t_x,\ t_y) $ に行くことができるかどうかを判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3000 $
- $ -10^9\ \leq\ x_i,\ y_i\ \leq\ 10^9 $
- $ 1\ \leq\ r_i\ \leq\ 10^9 $
- $ (s_x,\ s_y) $ は $ N $ 個の円のうち少なくとも $ 1 $ つ以上の円の円周上にある
- $ (t_x,\ t_y) $ は $ N $ 個の円のうち少なくとも $ 1 $ つ以上の円の円周上にある
- 入力はすべて整数

### Sample Explanation 1

!\[\](https://img.atcoder.jp/abc259/7b850385b9d67dc150435ffc7818bd94.png) 例えば、下記の経路で点 $ (0,\ -2) $ から点 $ (3,\ 3) $ へ行くことができます。 - 点 $ (0,\ -2) $ から $ 1 $ つ目の円の円周上を反時計回りに通って点 $ (1,\ -\sqrt{3}) $ へ行く。 - 点 $ (1,\ -\sqrt{3}) $ から $ 2 $ つ目の円の円周上を時計回りに通って点 $ (2,\ 2) $ へ行く。 - 点 $ (2,\ 2) $ から $ 3 $ つ目の円の円周上を反時計回りに通って点 $ (3,\ 3) $ へ行く。 よって、`Yes` を出力します。

### Sample Explanation 2

!\[\](https://img.atcoder.jp/abc259/924efa40ff28e5d7125841da2710d012.png) 少なくとも $ 1 $ つ以上の円の円周上にある点のみを通って点 $ (0,\ 1) $ から点 $ (0,\ 3) $ に行くことはできないので `No` を出力します。

## 样例 #1

### 输入

```
4
0 -2 3 3
0 0 2
2 0 2
2 3 1
-3 3 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3
0 1 0 3
0 0 1
0 0 2
0 0 3```

### 输出

```
No```

# AI分析结果



# 中文题目重写

## 题目描述

在 $xy$ 平面上给定 $N$ 个圆。对于 $i = 1, 2, \ldots, N$，第 $i$ 个圆是以点 $(x_i, y_i)$ 为中心，半径为 $r_i$ 的圆。

要求判断：仅通过至少一个圆的圆周上的点，能否从点 $(s_x, s_y)$ 到达点 $(t_x, t_y)$。

### 说明/提示

- $1 \leq N \leq 3000$
- 坐标和半径的绝对值范围在 $10^9$ 以内
- 起点和终点必定位于至少一个圆的圆周上
- 所有输入均为整数

## 样例解释

样例1中可以通过多个圆的圆周形成通路，输出 `Yes`；样例2中无法找到通路，输出 `No`。

---

**算法分类**: 图论（连通性判定）

---

## 题解分析与结论

### 核心思路
将每个圆视为图中的一个节点，两个圆之间若相交或相切（包括内切和外切）则建立边连接。问题转化为判断起点所在圆与终点所在圆是否连通。关键点在于正确判断圆的关系，并处理多个可能的起点/终点圆。

### 题解对比

1. **Composite_Function 的题解（4星）**
   - **亮点**: 正确使用DFS处理多起点情况，避免浮点运算
   - **实现**:
     - 预处理每个圆是否为起点/终点所在圆
     - 建立邻接矩阵判断圆之间的连通性
     - 对所有起点圆进行DFS，检查能否到达任意终点圆
   - **代码核心**:
     ```cpp
     bool check[N][N]; // 邻接矩阵存储连通性
     void dfs(int pos) {
         if (t[pos]) { cout << "Yes"; exit(0); }
         for (int i = 1; i <= n; ++i)
             if (check[pos][i] && !vis[i]) 
                 vis[i] = true, dfs(i);
     }
     ```

2. **mi_Y13c 的题解（2星）**
   - **问题**: 仅处理单个起点圆和终点圆，未考虑多个可能
   - **实现缺陷**: 若存在多个起点/终点圆时无法正确判断连通性

---

## 最优思路总结

1. **图的建模**：将圆抽象为节点，相交/相切关系为边
2. **整数运算**：通过距离平方比较避免浮点误差
3. **多起点处理**：必须遍历所有可能的起点圆进行连通性检查

---

## 相似题目推荐

1. [P2491 消防](https://www.luogu.com.cn/problem/P2491) - 图的直径与连通性
2. [P1364 医院设置](https://www.luogu.com.cn/problem/P1364) - 图的最短路径应用
3. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330) - 图的连通性与二分图判定

---
处理用时：287.71秒
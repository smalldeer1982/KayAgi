# 题目信息

# [ABC260D] Draw Your Cards

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc260/tasks/abc260_d

$ 1 $ から $ N $ が書かれた $ N $ 枚のカードが裏向きで積まれた山札があり、上から $ i $ 枚目のカードには整数 $ P_i $ が書かれています。

この山札を使って、以下の行動を $ N $ ターン繰り返します。

- 山札の一番上のカードを引いて、そこに書かれた整数を $ X $ とする。
- 場に見えている表向きのカードであって書かれた整数が $ X $ 以上であるもののうち、書かれた整数が最小のものの上に、引いたカードを表向きで重ねる。もし場にそのようなカードがなければ、引いたカードをどれにも重ねずに表向きで場に置く。
- その後、表向きのカードが $ K $ 枚重ねられた山が場にあればその山のカードを全て食べる。食べられたカードは全て場から消滅する。

各カードについて、何ターン目に食べられるか、あるいは最後まで食べられないかを求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ P $ は $ (1,2,\dots,N) $ の順列 ( $ (1,2,\dots,N) $ を並べ替えて得られる列 ) である

### Sample Explanation 1

この入力では、 $ P=(3,5,2,1,4),K=2 $ です。 - $ 1 $ ターン目に、 $ 3 $ が書かれたカードが他のカードに重ねられずに表向きで場に置かれます。 - $ 2 $ ターン目に、 $ 5 $ が書かれたカードが他のカードに重ねられずに表向きで場に置かれます。 - $ 3 $ ターン目に、 $ 2 $ が書かれたカードが $ 3 $ が書かれたカードの上に表向きで重ねられます。 - この時点で上から $ 2,3 $ が書かれたカードが表向きで重ねられた山が $ K=2 $ 枚に達したので、両カードは食べられます。 - $ 4 $ ターン目に、 $ 1 $ が書かれたカードが $ 5 $ が書かれたカードの上に表向きで重ねられます。 - この時点で上から $ 1,5 $ が書かれたカードが表向きで重ねられた山が $ K=2 $ 枚に達したので、両カードは食べられます。 - $ 5 $ ターン目に、 $ 4 $ が書かれたカードが他のカードに重ねられずに表向きで場に置かれます。 - $ 4 $ が書かれたカードは、最後まで食べられませんでした。

### Sample Explanation 2

$ K=1 $ である場合、全てのカードは場に置かれたターンに食べられます。

## 样例 #1

### 输入

```
5 2

3 5 2 1 4```

### 输出

```
4

3

3

-1

4```

## 样例 #2

### 输入

```
5 1

1 2 3 4 5```

### 输出

```
1

2

3

4

5```

## 样例 #3

### 输入

```
15 3

3 14 15 9 2 6 5 13 1 7 10 11 8 12 4```

### 输出

```
9

9

9

15

15

6

-1

-1

6

-1

-1

-1

-1

6

15```

# AI分析结果



# 题目中文翻译

## [ABC260D] Draw Your Cards

### 题目描述

有一叠包含 $1$ 到 $N$ 编号的 $N$ 张卡牌，从上到下的第 $i$ 张卡牌写有整数 $P_i$。进行 $N$ 轮操作：

1. 抽牌堆顶卡牌，其数值为 $X$
2. 找到场上所有堆顶 ≥$X$ 的牌堆中堆顶最小的，将当前卡叠放其上；若无则单独成堆
3. 若某牌堆卡数达到 $K$，立即吃掉整堆

求每张卡被吃掉的轮次（未被吃则输出 -1）。

### 说明/提示

- $1 ≤ K ≤ N ≤ 2×10^5$
- $P$ 是 $1$ 到 $N$ 的排列

---

**算法分类**：模拟、数据结构（有序集合）

---

## 题解分析与结论

### 核心思路对比

| 题解特点               | 数据结构      | 关键操作                         | 时间复杂度  |
|------------------------|-------------|--------------------------------|-----------|
| 维护牌堆顶集合，快速二分查找 | `map<int, stack>` | 利用`upper_bound`查找，`swap`避免拷贝 | $O(n\log n)$ |
| 链表式存储堆内关系       | `set` + 前驱数组 | 通过前驱指针回溯整堆              | $O(n\log n)$ |

### 最优解关键点

1. **有序集合维护堆顶**：使用 `map` 或 `set` 维护所有存在的堆顶，保证快速查找最小符合条件的堆顶
2. **避免数据拷贝**：通过 `swap` 操作转移堆内容，避免深拷贝栈结构
3. **链式回溯**：当堆被吃掉时，通过前驱指针或栈结构快速遍历所有相关卡牌

---

## 精选题解

### 题解1 by adpitacor（5星）
**亮点**：
- 使用 `map<int, stack>` 直观管理堆顶
- 通过 `swap` 实现 $O(1)$ 堆转移
- 代码简洁高效，逻辑清晰

```cpp
#include<iostream>
#include<stack>
#include<map>
using namespace std;
int n,k,t[200010];
map<int,stack<int>> mp;

int main(){
    cin>>n>>k;
    for(int i=1,x;i<=n;i++){
        cin>>x;
        auto it=mp.upper_bound(x); // 查找最小堆顶
        if(it != mp.end()){        // 存在可叠放堆
            mp[x].swap(it->second); // 关键swap操作
            mp.erase(it);
        }
        auto &stk=mp[x];          // 获取当前堆引用
        stk.push(x);              // 添加新卡
        if(stk.size()==k){        // 触发吃牌条件
            while(!stk.empty()) t[stk.top()]=i, stk.pop();
            mp.erase(x);
        }
    }
    // 输出处理略
}
```

### 题解2 by kczw（4星）
**亮点**：
- 精简的 `map` 实现
- 直接通过栈操作管理牌堆

```cpp
#include<iostream>
#include<stack>
#include<map>
using namespace std;
map<int,stack<int>> card;
int n,k,f[200005];

int main(){
    scanf("%d%d",&n,&k);
    for(int i=1,a;i<=n;i++){
        scanf("%d",&a);
        auto id=card.upper_bound(a);
        if(id != card.end()){
            swap(card[a], id->second); // 堆转移
            card.erase(id);
        }
        auto &stk=card[a];
        stk.push(a);
        if(stk.size()==k){        // 处理吃牌
            while(!stk.empty()) f[stk.top()]=i, stk.pop();
            card.erase(a);
        }
    }
    // 输出处理略
}
```

---

## 拓展应用

**类似题目推荐**：
1. [P2161 [SHOI2009] 会场预约](https://www.luogu.com.cn/problem/P2161)（set维护区间）
2. [P3380 【模板】二逼平衡树](https://www.luogu.com.cn/problem/P3380)（多重有序集合操作）
3. [P2894 [USACO08FEB] Hotel G](https://www.luogu.com.cn/problem/P2894)（区间合并与查询）

---

**关键技巧总结**：
1. **有序集合的二分查找**：`upper_bound` 快速定位插入位置
2. **数据结构的轻量级操作**：使用引用、swap 减少拷贝开销
3. **链式回溯结构**：前驱指针或栈结构实现快速整堆操作

当处理动态集合中的最值查询问题时，优先考虑有序数据结构（set/map）配合二分操作，可大幅提升效率。

---
处理用时：54.24秒
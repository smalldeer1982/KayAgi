# 题目信息

# [ABC261D] Flipping and Bonus

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc261/tasks/abc261_d

高橋君が $ N $ 回コイントスを行います。 また、高橋君はカウンタを持っており、最初カウンタの数値は $ 0 $ です。

$ i $ 回目のコイントスで表裏のどちらが出たかによって、次のことが起こります。

- 表が出たとき：高橋君はカウンタの数値を $ 1 $ 増やし、$ X_i $ 円もらう。
- 裏が出たとき：高橋君はカウンタの数値を $ 0 $ に戻す。お金をもらうことは出来ない。

また、$ M $ 種類の連続ボーナスがあり、$ i $ 種類目の連続ボーナスではカウンタの数値が $ C_i $ になる**たびに** $ Y_i $ 円もらうことができます。

高橋君は最大で何円もらうことができるかを求めてください。

## 说明/提示

### 制約

- $ 1\leq\ M\leq\ N\leq\ 5000 $
- $ 1\leq\ X_i\leq\ 10^9 $
- $ 1\leq\ C_i\leq\ N $
- $ 1\leq\ Y_i\leq\ 10^9 $
- $ C_1,C_2,\ldots,C_M $ はすべて異なる。
- 入力はすべて整数

### Sample Explanation 1

順に 表, 表, 裏, 表, 表, 表 が出た時、もらえる金額は次のようになります。 - $ 1 $ 回目のコイントスで表が出る。カウンタの数値を $ 0 $ から $ 1 $ にして、$ 2 $ 円もらう。 - $ 2 $ 回目のコイントスで表が出る。カウンタの数値を $ 1 $ から $ 2 $ にして、$ 7 $ 円もらう。さらに、連続ボーナスとして $ 10 $ 円もらう。 - $ 3 $ 回目のコイントスで裏が出る。カウンタの数値を $ 2 $ から $ 0 $ にする。 - $ 4 $ 回目のコイントスで表が出る。カウンタの数値を $ 0 $ から $ 1 $ にして、$ 8 $ 円もらう。 - $ 5 $ 回目のコイントスで表が出る。カウンタの数値を $ 1 $ から $ 2 $ にして、$ 2 $ 円もらう。さらに、連続ボーナスとして $ 10 $ 円もらう。 - $ 6 $ 回目のコイントスで表が出る。カウンタの数値を $ 2 $ から $ 3 $ にして、$ 8 $ 円もらう。さらに、連続ボーナスとして $ 1 $ 円もらう。 このとき高橋君は合計で $ 2+(7+10)+0+8+(2+10)+(8+1)=48 $ 円もらうことができ、このときが最大です。 連続ボーナスはカウンタの数値が $ C_i $ になるたびに何度でももらえることに注意してください。 ちなみに、$ 6 $ 回のコイントスで全部表が出た時は $ 2+(7+10)+(1+1)+8+(2+5)+8=44 $ 円しかもらうことが出来ず、この時は最大ではありません。

### Sample Explanation 2

答えが $ 32 $ bit 整数型に収まらないこともあることに注意してください。

## 样例 #1

### 输入

```
6 3
2 7 1 8 2 8
2 10
3 1
5 5```

### 输出

```
48```

## 样例 #2

### 输入

```
3 2
1000000000 1000000000 1000000000
1 1000000000
3 1000000000```

### 输出

```
5000000000```

# AI分析结果



# [ABC261D] Flipping and Bonus 题解

## 题目中文翻译
**题目名称**：翻转与奖励  
**难度**：★☆☆☆  

### 题目描述  
高桥君将进行 $N$ 次抛硬币。他持有一个计数器，初始值为 $0$。  

每次抛硬币结果会产生以下影响：  
- **正面**：计数器值增加 $1$，获得 $X_i$ 日元  
- **反面**：计数器重置为 $0$，无法获得金钱  

另有 $M$ 种连胜奖励，当计数器值**达到** $C_i$ 时，立即获得 $Y_i$ 日元（每次达到都会触发）。求可能获得的最大金额。

### 输入格式  
第一行两个整数 $N, M$  
第二行 $N$ 个整数表示 $X_1 \sim X_N$  
接下来 $M$ 行每行两个整数 $C_i, Y_i$  

### 输出格式  
输出最大收益

### 数据范围  
$1 \leq M \leq N \leq 5000$  
$X_i, Y_i \leq 10^9$  

---

**算法分类**: 动态规划

---

## 题解分析

### 关键思路
使用二维动态规划 `dp[i][j]` 表示第 `i` 次抛硬币后计数器为 `j` 时的最大收益：
1. **计数器清空**（抛反面）：`dp[i][0] = max(dp[i-1][0..i-1])`
2. **连续正面**（抛正面）：`dp[i][j] = dp[i-1][j-1] + X_i + Y_j`

### 最优题解

#### 题解1：xiaomuyun（★★★★☆）
**亮点**：  
- 状态转移方程简洁直观  
- 预处理奖励数组提升查询效率  
- 代码结构清晰易读

**核心代码**：
```cpp
long long dp[5005][5005] = {}, Y[5005] = {};
for(int i=1; i<=n; i++){
    // 处理抛反面的情况
    for(int k=0; k<i; k++) 
        dp[i][0] = max(dp[i][0], dp[i-1][k]);
    // 处理抛正面的情况
    for(int j=1; j<=i; j++)
        dp[i][j] = dp[i-1][j-1] + X[i] + Y[j];
}
```

#### 题解2：Tsawke（★★★★☆）
**亮点**：  
- 使用哈希表处理离散奖励值  
- 完善的边界条件处理  
- 时间复杂度严格 O(N²)

**核心实现**：
```cpp
unordered_map<int, int> bonus;
for(int i=1; i<=n; i++){
    // 枚举所有可能的前置状态
    for(int k=0; k<i; k++)
        dp[i][0] = max(dp[i][0], dp[i-1][k]);
    // 递推连续正面状态
    for(int j=1; j<=i; j++)
        dp[i][j] = dp[i-1][j-1] + X[i] + bonus[j];
}
```

---

## 总结与扩展

### 关键技巧
1. **状态设计**：二维状态表示连续计数器的变化  
2. **预处理优化**：将离散的奖励值转换为数组索引加速查询  
3. **滚动数组**：可优化空间复杂度至 O(N)，但本题数据范围允许二维数组

### 相似题目推荐
1. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230) - 贪心+时间窗口  
2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063) - 区间动态规划  
3. [AT4827 [ABC134E] Sequence Decomposing](https://www.luogu.com.cn/problem/AT4827) - 贪心+状态维护

---
处理用时：47.43秒
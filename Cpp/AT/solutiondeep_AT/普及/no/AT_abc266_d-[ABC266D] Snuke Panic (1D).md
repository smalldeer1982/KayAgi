# 题目信息

# [ABC266D] Snuke Panic (1D)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc266/tasks/abc266_d

高橋君はすぬけ君たちを捕まえようとしています。

数直線上の座標 $ 0,1,2,3,4 $ の $ 5 $ 箇所に穴があり、すぬけ君たちの巣につながっています。

これから $ N $ 匹のすぬけ君が穴から出てきます。$ i $ 番目のすぬけ君は時刻 $ T_i $ に座標 $ X_i $ の穴から出てきて、大きさは $ A_i $ であることがわかっています。

高橋君は時刻 $ 0 $ に座標 $ 0 $ におり、数直線上を単位時間あたり $ 1 $ 以下の速さで移動することができます。  
すぬけ君が穴から出てきたのと同じ時刻に同じ座標に高橋君がいるとき、かつ、そのときに限り、高橋君はすぬけ君を捕まえることができます。  
すぬけ君を捕まえるのにかかる時間は無視できます。

高橋君が適切に行動したとき、捕まえることができるすぬけ君の大きさの合計の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 0\ <\ T_1\ <\ T_2\ <\ \ldots\ <\ T_N\ \leq\ 10^5 $
- $ 0\ \leq\ X_i\ \leq\ 4 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

次のように行動するのが最適です。 - 座標 $ 0 $ で待機し、時刻 $ 1 $ に $ 1 $ 番目のすぬけ君を捕まえる - 座標 $ 4 $ へ移動し、時刻 $ 5 $ に $ 3 $ 番目のすぬけ君を捕まえる $ 1 $ 番目と $ 2 $ 番目のすぬけ君を両方とも捕まえることはできないので、これが最大です。

### Sample Explanation 2

高橋君はすぬけ君を $ 1 $ 匹も捕まえることができません。

## 样例 #1

### 输入

```
3
1 0 100
3 3 10
5 4 1```

### 输出

```
101```

## 样例 #2

### 输入

```
3
1 4 1
2 4 1
3 4 1```

### 输出

```
0```

## 样例 #3

### 输入

```
10
1 4 602436426
2 1 623690081
3 3 262703497
4 4 628894325
5 3 450968417
6 1 161735902
7 1 707723857
8 2 802329211
9 0 317063340
10 2 125660016```

### 输出

```
2978279323```

# AI分析结果



# 中文题目重写  
[题目内容]  
高桥君想要捕捉在数轴上的洞穴中出现的Snuke。数轴上有坐标为0、1、2、3、4的五个洞穴。  

已知有N只Snuke会在特定时刻出现：第i只Snuke在时刻T_i从坐标X_i的洞穴出现，其价值为A_i。高桥君从时刻0在坐标0出发，每秒最多移动1单位距离。只有当高桥君与Snuke出现的时刻、位置完全相同时才能捕捉。  

求高桥君能捕捉的Snuke总价值的最大值。  

**输入格式**  
第一行为整数N。随后N行每行三个整数T_i,X_i,A_i。保证T_i严格递增。  

**输出格式**  
输出最大总价值。  

# 算法分类  
动态规划  

---

## 题解分析与结论  
各题解均采用动态规划方法，核心思想为：  
`dp[i][j]`表示时刻i位于坐标j时的最大价值。状态转移考虑上一时刻在相邻位置的可能性（j-1/j/j+1），并累加当前位置的Snuke价值。  

**关键难点对比**：  
1. 时间范围优化：部分题解仅处理到最后一个Snuke出现的时间  
2. 坐标越界处理：通过数组偏移（如y+1）或循环范围限制  
3. 价值查询方式：预处理时间-坐标映射表 vs 动态二分查找  

---

## 精选题解（评分≥4⭐）  

### 题解1：DengDuck（4⭐）  
**亮点**：  
- 预处理每个时刻各坐标的总价值  
- 通过初始值-1处理不可达状态  
- 数组偏移避免边界判断  

```cpp  
long long f[100005][7], a[100005][7];
int main() {
    // 预处理每个时刻的洞穴价值
    for (int i = 1; i <= n; i++) {
        cin >> x >> y >> z;
        y++; // 坐标偏移
        a[x][y] += z;
    }
    memset(f, -1, sizeof(f));
    f[0][1] = 0; // 初始位置（偏移后为1）
    for (int i = 1; i <= x; i++) {
        for (int j = 1; j <= 5; j++) {
            f[i][j] = max({f[i-1][j-1], f[i-1][j], f[i-1][j+1]});
            if(f[i][j] != -1) f[i][j] += a[i][j];
        }
    }
}
```

### 题解2：xiaomuyun（4⭐）  
**亮点**：  
- 动态二分查找Snuke出现情况  
- 时间范围限制优化  
- 移动范围动态约束  

```cpp  
for(int i=1; i<=mxt; ++i) {
    for(int j=0; j<=min(i,4ll); ++j) { // 动态约束坐标范围
        dp[i][j] = max({
            dp[i-1][j], 
            j>0 ? dp[i-1][j-1] : 0, 
            j<4 ? dp[i-1][j+1] : 0
        });
        // 二分查找当前时刻是否有Snuke
        int pos = lower_bound(t+1, t+1+n, i) - t;
        if(t[pos]==i && x[pos]==j) dp[i][j] += a[pos];
    }
}
```

---

## 关键技巧总结  
1. **状态压缩**：时间维度仅依赖前一时刻，可用滚动数组优化空间  
2. **预处理优化**：将Snuke按时间-坐标建立哈希映射，O(1)查询  
3. **边界处理**：通过坐标偏移（如x+1）简化边界条件判断  
4. **无效状态标记**：初始化-1表示不可达状态，避免错误转移  

---

## 拓展练习  
1. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216) - 经典二维DP  
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002) - 路径限制型DP  
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 双向状态转移

---
处理用时：55.12秒
# 题目信息

# [ABC267D] Index × A(Not Continuous ver.)

## 题目描述

有一个长度为 $N$ 整数数列 $A=(A_1,A_2,...,A_N)$ 。

现在假设有一个长度为 $M$ 的序列 $B$ ,并且 $B$ 是 $A$ 的**子序列**。请找到 $\sum_{i=1}^M i\times B_i$ 的最大值。

## 说明/提示

#### 注意事项
若序列 $S$ 是长度为 $L$ 的数列 $T$ 的**子序列**，则 $S$ 是数列 $T$ 删除任意 $i\ (i\in [0,L])$ 个元素得到的。

比如说， $(10,30)$ 是 $(10,20,30)$ 的字串，但是 $(20,10)$ 不是。


+ $1\le M\le N\le 2000$
+ $-2\times 10^5\le A_i\le 2\times 10^5$
+ 所有输入数据均为整数

#### 样例解释
对于**样例一**，当 $B=(A_1,A_4)$ 时，$\sum_{i=1}^M i\times B_i=1\times 5+2\times 8=21$ 。因为不可能达到 $22$ 或者更大的值，所以答案是 $21$ 。

## 样例 #1

### 输入

```
4 2

5 4 -1 8```

### 输出

```
21```

## 样例 #2

### 输入

```
10 4

-3 1 -4 1 -5 9 -2 6 -5 3```

### 输出

```
54```

# AI分析结果



# [ABC267D] Index × A(Not Continuous ver.)

## 题目描述

有一个长度为 $N$ 的整数数列 $A=(A_1,A_2,...,A_N)$。

现在假设有一个长度为 $M$ 的序列 $B$，并且 $B$ 是 $A$ 的**子序列**。请找到 $\sum_{i=1}^M i\times B_i$ 的最大值。

## 说明/提示

#### 注意事项
若序列 $S$ 是长度为 $L$ 的数列 $T$ 的**子序列**，则 $S$ 是数列 $T$ 删除任意 $i\ (i\in [0,L])$ 个元素得到的。

+ $1\le M\le N\le 2000$
+ $-2\times 10^5\le A_i\le 2\times 10^5$
+ 所有输入数据均为整数

---

**算法分类**：动态规划

---

### 题解综合分析

各题解均采用动态规划思路，核心是将子序列的位置权重（i×B_i）融入状态转移。主要分为两种实现形式：

1. **二维DP**：定义 `dp[i][j]` 表示前 `i` 个元素选 `j` 个的最大值，转移方程 `dp[i][j] = max(不选i继承dp[i-1][j], 选i时dp[i-1][j-1]+j*A[i])`
2. **一维优化**：利用滚动数组将空间优化至 O(M)，逆序更新避免状态覆盖

**共同难点**：
- 正确维护子序列位置权重（j的取值）
- 处理负数初始值防止非法转移
- 空间优化的状态更新顺序

---

### 精选题解

#### 1. Vegetableless（4星）
**亮点**：完整展现从三维→二维→一维的优化过程，代码可读性强  
**代码核心**：
```cpp
for(int i = 1;i<=n;++i)
    for(int j = m;j;--j)
        dp[j] = max(dp[j], dp[j-1] + a[i] * j);
```
**思路**：逆序更新一维数组，利用背包思想将空间复杂度优化至 O(M)

#### 2. _Wind_Leaves_ShaDow_（4星）
**亮点**：简洁高效的背包式实现，注释清晰  
**关键代码**：
```cpp
memset(dp, 0xc0, sizeof dp);
dp[0] = 0;
for(int i = 1; i <= n; ++i)
    for(int j = m; j >= 1; --j)
        dp[j] = max(dp[j], dp[j-1] + a[i] * j);
```
**心得**：强调物品价值为 `j*A[i]` 的逆向思维，避免二维数组维护复杂度

#### 3. SuperCowHorse（4星）
**亮点**：二维DP的清晰实现，初始化逻辑严密  
**核心代码**：
```cpp
memset(dp, -0x3f, sizeof dp);
dp[0][0] = 0;
for(int i = 1; i <= n; ++i)
    for(int j = 1; j <= m; ++j)
        dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + A[i]*j);
```
**注意点**：显式处理初始状态，防止负数干扰

---

### 关键思路总结
**核心技巧**：将子序列位置 `j` 作为动态规划状态维度，在状态转移中直接计算权重 `j*A[i]`  
**优化要点**：  
- 滚动数组将空间复杂度从 O(NM) 优化到 O(M)
- **逆序更新**避免覆盖未使用的旧状态
- 初始化 `dp[0] = 0` 其余为负无穷，确保合法状态转移

---

### 拓展应用
类似动态规划权重问题：
1. 带位置权重的子序列选择（如平方权重）
2. 需要维护多个维度状态的背包变种问题
3. 结合其他条件（如单调性）的最大化/最小化子序列

---

### 推荐习题
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（基础01背包）
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)（简单价值计算背包）
3. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156)（多维状态动态规划）

---
处理用时：67.54秒
# 题目信息

# [ABC269E] Last Rook

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc269/tasks/abc269_e

**この問題はインタラクティブな問題**（あなたの作成したプログラムとジャッジプログラムが入出力を介して対話を行う形式の問題）です。

縦横 $ N $ マスのチェス盤と $ N $ 個のルークの駒があります。以下では上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表します。  
 チェス盤のマスにルークを置くことを考えます。ただし、あなたは次の条件をすべて満たすようにルークをチェス盤に置く必要があります。

- 1 つの行に $ 2 $ 個以上のルークが存在しない。
- 1 つの列に $ 2 $ 個以上のルークが存在しない。

今、チェス盤に $ N-1 $ 個のルークが上の条件をすべて満たした状態で置かれています。あなたはルークが置かれていないマスを 1 つ選び、そのマスにルークを置くことにしました。(上の条件をすべて満たすようにルークを置くことができるマスは少なくとも 1 つ以上存在することが証明できます。)

ただし、あなたはチェス盤のどのマスにルークが置かれているかを直接知ることはできません。  
 そのかわりに、ジャッジシステムに対して以下の質問を $ 20 $ 回まで行うことができます。

- 整数 $ A,\ B,\ C,\ D $ を $ 1\ \leq\ A\ \leq\ B\ \leq\ N,\ 1\ \leq\ C\ \leq\ D\ \leq\ N $ を満たすように選ぶ。そして、$ A\ \leq\ i\ \leq\ B,\ C\ \leq\ j\ \leq\ D $ を満たすマス $ (i,\ j) $ からなる長方形領域に置かれているルークの個数を聞く。

ルークを置くことができるマスを見つけてください。

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジプログラムが入出力を介して対話を行う形式の問題）です。

最初に、チェス盤のサイズ $ N $ を標準入力から受け取ってください。

> $ N $

次に、ルークを置くことができるマスが見つかるまで質問を繰り返してください。  
 質問は、以下の形式で標準出力に出力してください。

> $ ? $ $ A $ $ B $ $ C $ $ D $

これに対する応答は、次の形式で標準入力から与えられます。

> $ T $

ここで、$ T $ は質問に対する答えです。ただし、不正な質問を行った、あるいは質問の回数が $ 20 $ 回を超えた場合は $ T $ は `-1` となります。

ジャッジが `-1` を返した場合、提出はすでに不正解とみなされています。この場合、ただちにプログラムを終了してください。

ルークを置くことができるマスを見つけたら、そのマスを $ (X,\ Y) $ として、解答を以下の形式で出力してください。その後、ただちにプログラムを終了してください。

> $ ! $ $ X $ $ Y $

答えが複数ある場合、どれを出力しても正解とみなされます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^3 $
- $ N $ は整数

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で不正な出力を行った場合のジャッジ結果は不定です。**
- 解答を出力したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。

### 入出力例

以下は、$ N=3 $ で $ (1,\ 2),\ (2,\ 1) $ にルークが置かれている場合の入出力例です。

 入力 出力 説明 `3`  まず整数 $ N $ が与えられます。  `? 1 2 1 3`  $ (A,B,C,D)=(1,2,1,3) $ として質問を行います。 `2`  質問の答えは $ 2 $ なので、ジャッジはその値を返します。  `? 2 3 1 1` $ (A,B,C,D)=(2,3,1,1) $ として質問を行います。 `1`  質問の答えは $ 1 $ なので、ジャッジはその値を返します。  `? 1 3 3 3` $ (A,B,C,D)=(1,3,3,3) $ として質問を行います。 `0`  質問の答えは $ 0 $ なので、ジャッジはその値を返します。  `! 3 3` 答えは $ (3,\ 3) $ だとわかったので、それを出力します。

# AI分析结果



【中文重写题目】

# [ABC269E] 最后的车

## 题目描述

**本题为交互式问题**（你的程序将通过输入输出与判题系统进行交互）。

给定一个 $N \times N$ 的棋盘和 $N$ 个车的棋子。棋盘上已经放置了 $N-1$ 个车，满足以下条件：

- 任意一行最多有一个车
- 任意一列最多有一个车

现在需要找到一个可以放置第 $N$ 个车的位置，使得所有车仍然满足上述条件。你可以向判题系统进行最多 20 次询问，每次询问格式为：

`? A B C D`  
询问由 $(A,C)$ 到 $(B,D)$ 构成的矩形区域内包含的车数量。

最终输出正确的坐标 $(X,Y)$。

## 输入输出格式
- 输入棋盘大小 $N$
- 进行若干次询问，直到确定答案
- 输出答案格式为 `! X Y`

## 数据范围
$2 \leq N \leq 10^3$

---

**算法分类**：二分

---

### 题解综合分析
所有题解均采用二分法分别确定空缺行和列。关键点在于：
1. 通过二分确定缺失行：每次询问前半段行是否填满，若填满则在右半段继续搜索
2. 对称处理列方向的二分
3. 每次二分将范围减半，总询问次数为 $2\lceil \log_2 N \rceil$，满足 20 次限制

---

### 优质题解推荐

#### 1. 作者：_hxh（★★★★★）
**核心亮点**：
- 模块化设计：将行/列查找封装为独立函数
- 代码可读性极佳，变量命名清晰
- 完整处理边界条件

**关键代码**：
```cpp
int find_x() {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r) >> 1;
        cout << "? " << l << " " << mid << " " << 1 << " " << n << endl;
        cin >> ask;
        if (ask == mid - l + 1) l = mid + 1;
        else r = mid;
    }
    return l;
}
// 对称处理 find_y()
```

#### 2. 作者：heaksicn（★★★★☆）
**核心亮点**：
- 精简的代码实现
- 使用数学推导说明算法正确性
- 包含正确性证明

**关键思路**：
```cpp
while(l<r){
    int mid=(l+r)/2;
    cout<<"? "<<l<<" "<<mid<<" 1 "<<n<<endl;
    int cnt = get_count();
    if(cnt == mid-l+1) l=mid+1; // 前半段全满
    else r=mid;                 // 存在空缺
}
```

#### 3. 作者：charleshe（★★★★☆）
**核心亮点**：
- 详细的中文注释说明
- 包含转置思想解释
- 完整的算法正确性证明

**个人心得**：
> "注意输出格式中的空格！在二分列时曾忘记重置查询范围，导致WA三次。建议将行列查询结构封装为函数避免重复错误"

---

### 关键技巧总结
1. **二分维度分离**：将二维问题拆解为两个独立的一维二分
2. **查询设计**：行查询时固定列范围为全列（`1..n`），列查询时固定行范围
3. **单调性利用**：完整行/列的数量具有严格单调性，确保二分正确性
4. **边界处理**：当 `ask == mid-l+1` 时，空缺必定在右区间

---

### 拓展练习
1. [P1733 猜数](https://www.luogu.com.cn/problem/P1733)（一维二分交互）
2. [CF862B](https://codeforces.com/problemset/problem/862/B)（二分结合树结构）
3. [CF1161F](https://codeforces.com/problemset/problem/1161/F)（三维二分交互变形）

---
处理用时：50.25秒
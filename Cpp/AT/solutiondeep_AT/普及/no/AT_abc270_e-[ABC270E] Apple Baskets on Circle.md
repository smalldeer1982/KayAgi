# 题目信息

# [ABC270E] Apple Baskets on Circle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc270/tasks/abc270_e

$ 1,2,\ldots,N $ の番号がついた $ N $ 個のかごが円状に置かれています。  
 $ 1\leq\ i\ \leq\ N-1 $ についてかご $ i $ の右隣にはかご $ i+1 $ があり、かご $ N $ の右隣にはかご $ 1 $ があります。

かご $ i $ の中には $ A_i $ 個りんごが入っています。

高橋君は最初かご $ 1 $ の前におり、以下の行動を繰り返します。

- 目の前にあるかごの中にりんごがあれば $ 1 $ 個かごから取り出して食べる。その後、りんごを食べたかどうかにかかわらず、右隣のかごの前に移動する。

高橋君がちょうど $ K $ 個のりんごを食べた時点で、各かごの中に残っているりんごの個数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^{12} $
- $ 1\ \leq\ K\ \leq\ 10^{12} $
- りんごは全部で $ K $ 個以上ある。すなわち、$ \sum_{i=1}^{N}A_i\geq\ K $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

高橋君は次のように行動します。 - 目の前にあるかご $ 1 $ の中にりんごがあるので $ 1 $ 個かごから取り出して食べる。その後、かご $ 2 $ の前に移動する。この時点で各かごの中のりんごの個数は $ (0,3,0) $ である。 - 目の前にあるかご $ 2 $ の中にりんごがあるので $ 1 $ 個かごから取り出して食べる。その後、かご $ 3 $ の前に移動する。この時点で各かごの中のりんごの個数は $ (0,2,0) $ である。 - 目の前にあるかご $ 3 $ の中にりんごはない。かご $ 1 $ の前に移動する。この時点で各かごの中のりんごの個数は $ (0,2,0) $ である。 - 目の前にあるかご $ 1 $ の中にりんごはない。かご $ 2 $ の前に移動する。この時点で各かごの中のりんごの個数は $ (0,2,0) $ である。 - 目の前にあるかご $ 2 $ の中にりんごがあるので $ 1 $ 個かごから取り出して食べる。その後、かご $ 3 $ の前に移動する。この時点で各かごの中のりんごの個数は $ (0,1,0) $ である。

## 样例 #1

### 输入

```
3 3

1 3 0```

### 输出

```
0 1 0```

## 样例 #2

### 输入

```
2 1000000000000

1000000000000 1000000000000```

### 输出

```
500000000000 500000000000```

# AI分析结果



# [ABC270E] 圆上的苹果篮

## 题目描述

编号为 $1,2,\ldots,N$ 的 $N$ 个篮子围成圆圈排列。对于 $1\leq i \leq N-1$，篮 $i$ 的右侧是篮 $i+1$，篮 $N$ 的右侧是篮 $1$。每个篮 $i$ 中有 $A_i$ 个苹果。

高桥君从篮 $1$ 开始，重复以下操作直到吃完恰好 $K$ 个苹果：
- 如果当前篮中有苹果，则取出 1 个吃掉
- 无论是否取出苹果，立即移动到右侧相邻的篮前

求吃完后每个篮中的剩余苹果数。

## 标签
二分

## 题解分析
本题核心在于高效计算多轮循环取苹果的过程。直接模拟会超时，需找到数学规律：

1. **二分答案思想**：二分查找完整取苹果的轮数，每轮每个非空篮取 1 个
2. **余数处理**：剩余不足一轮的苹果数逐个处理
3. **复杂度优化**：将 O(K) 操作转化为 O(N log maxA) 的二分计算

## 高分题解推荐

### FFTotoro 题解（⭐⭐⭐⭐⭐）
**亮点**：
- 二分框架清晰，处理余数巧妙
- 时间复杂度 O(N log maxA) 最优
- 代码简洁易懂，边界处理得当

**关键代码**：
```cpp
int main(){
  // 二分部分
  while(l<=r){
    int mid=l+r>>1,c0=0;
    for(auto &i:a)c0+=min(i,mid); 
    if(c0>k)r=mid-1;
    else l=mid+1,x=mid;
  }
  // 处理余数
  for(auto &i:a)k-=min(i,x);
  for(auto &i:a){
    if(k>0 && i>x) {i--;k--;}
    cout<<max(i-x,0)<<' ';
  }
}
```

### Mingrui_Yang 题解（⭐⭐⭐⭐）
**亮点**：
- 排序后分层处理，直观展示取苹果过程
- 数学推导清晰，处理剩余部分的方法新颖

**关键思路**：
```cpp
sort(a);
for(int i=1; i<=n; i++){
  // 计算当前层可取的苹果数
  ll can_take = (a[i]-last) * (n-i+1);
  if(can_take <= k){
    k -= can_take;
    last = a[i];
  }else{
    // 处理剩余
  }
}
```

### Tsawke 题解（⭐⭐⭐）
**亮点**：
- 优先队列模拟过程，思路直观
- 处理大数时使用 __int128 避免溢出

**优化点**：
```cpp
priority_queue<ll, vector<ll>, greater<ll>> q;
while(!q.empty()){
  ll v = q.top() - minus; 
  if(cur*v <= K){ // 完整取多轮
    K -= cur*v;
    minus += v;
  }else{ // 处理剩余
    break;
  }
}
```

## 关键思路总结
1. **二分轮数**：确定最大完整轮数 x，使得总苹果数 Σmin(a_i,x) ≤ K
2. **分层计算**：通过排序或优先队列，计算各阶段可批量处理的苹果数
3. **余数处理**：最后遍历数组逐个取剩余苹果

## 同类题目推荐
1. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440) - 二分答案经典题
2. [P3743 kotori的设备](https://www.luogu.com.cn/problem/P3743) - 循环使用设备的能量管理
3. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182) - 二分最大段的最小值

---
处理用时：52.27秒
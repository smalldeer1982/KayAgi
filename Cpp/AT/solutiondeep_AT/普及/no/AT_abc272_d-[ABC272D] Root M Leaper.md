# 题目信息

# [ABC272D] Root M Leaper

## 题目描述

有一个大小为 $N\times N$ 的方格图（网格）。在本题中，我们所说的方格 $(i,j)$ 指网格从上往下数第 $i$ 行，从左往右数第 $j$ 列。

最开始，有一个棋子位于方格 $(1,1)$ 。现在你可以进行下面这个操作若干次：

+ 当前棋子位于 $(i,j)$ ，那么移动它到一个距离它刚好 $\sqrt{M}$ 的点（不超出网格）。

本题中的“**距离**”，指欧几里得距离。即方格 $(i,j)$ 与 $(k,l)$ 的距离是 $\sqrt{(i-k)^2+(j-l)^2}$ 。

现在对于整个网格，请你确定棋子能否到达方格 $(i,j)$ 。如果可以，输出到达它的最少操作次数；如果不行，输出 ```-1``` 。

## 说明/提示

- $ 1\ \le\ N\ \le\ 400 $
- $ 1\ \le\ M\ \le\ 10^6 $
- 输入全为整数


对于**样例1**，你可以把棋子通过一定次数的操作挪到这个方格图的任意位置。

比如说，我们可以通过如下操作把棋子移到 $(2,2)$ ：

1. 开始棋子在 $(1,1)$ 。 $(1,1)$ 到 $(1,2)$ 的距离刚好是 $\sqrt 1$ ，所以我们把它移到 $(1,2)$ 。
1. 现在棋子在 $(1,2)$ 了。$(1,2)$ 到 $(2,2)$的距离也刚好是 $\sqrt 1$ ，所以我们就把它移到了 $(2,2)$ 。

## 样例 #1

### 输入

```
3 1```

### 输出

```
0 1 2

1 2 3

2 3 4```

## 样例 #2

### 输入

```
10 5```

### 输出

```
0 3 2 3 2 3 4 5 4 5

3 4 1 2 3 4 3 4 5 6

2 1 4 3 2 3 4 5 4 5

3 2 3 2 3 4 3 4 5 6

2 3 2 3 4 3 4 5 4 5

3 4 3 4 3 4 5 4 5 6

4 3 4 3 4 5 4 5 6 5

5 4 5 4 5 4 5 6 5 6

4 5 4 5 4 5 6 5 6 7

5 6 5 6 5 6 5 6 7 6```

# AI分析结果



### 中文题目重写
有一个大小为 $N\times N$ 的网格，棋子初始位于 $(1,1)$。每次操作可将棋子移动到欧几里得距离恰好为 $\sqrt{M}$ 的相邻格点。求到达每个点的最少操作次数，若无法到达则输出 `-1`。

### 算法分类
**广度优先搜索（BFS）**

### 题解分析与结论
各题解核心思路均为 **预处理所有合法移动向量 + BFS**。关键难点在于正确枚举所有满足 $dx^2 + dy^2 = M$ 的移动偏移量 $(dx, dy)$，并生成其对称方向。部分题解因预处理时枚举范围错误（如限制在网格大小 $N$ 而非 $\sqrt{M}$）导致漏解，正确解法需枚举 $dx, dy$ 到 $\sqrt{M}$。

### 高星题解推荐
#### 1. 作者：BLuemoon_（4星）
**关键亮点**  
- 暴力枚举所有可能的 $dx, dy$（范围 $[-1000, 1000]$），确保覆盖所有解。
- 代码简洁，利用 `vector` 存储偏移量，BFS 实现清晰。

**核心代码**  
```cpp
for(int i=-1000;i<=1000;i++)
    for(int j=-1000;j<=1000;j++)
        if(i*i + j*j == m)
            dx.push_back(i), dy.push_back(j);
// BFS 部分省略
```

#### 2. 作者：robinyqc（4星）
**关键亮点**  
- 预处理时精确枚举 $dx$ 到 $\sqrt{M}$，计算对应 $dy$ 避免冗余。
- 数学推导清晰，通过解方程生成所有合法方向。

**核心代码**  
```cpp
for(int i=0; i*i <= m; i++) {
    int j = sqrt(m - i*i);
    if (j*j == m - i*i) {
        // 添加四个对称方向
    }
}
```

#### 3. 作者：PineappleSummer（4星）
**关键亮点**  
- 处理 $dx, dy$ 时额外考虑交换顺序的情况，确保所有排列组合被覆盖。
- BFS 实现高效，队列管理清晰。

**核心代码**  
```cpp
for(int i=0; i*i <= m; i++) {
    int j = sqrt(m - i*i);
    if (j*j == m - i*i) {
        // 生成八个方向（含交换i,j）
    }
}
```

### 最优思路总结
1. **预处理偏移量**：枚举所有满足 $dx^2 + dy^2 = M$ 的 $(dx, dy)$，并生成其四个对称方向。
2. **BFS 最短路径**：从 $(1,1)$ 出发，用队列扩展每个点的合法移动，首次访问即最优解。

### 拓展与相似题目
- **同类问题**：骑士巡游（特定步长移动）、网格最短路径问题。
- **推荐题目**：
  - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
  - [P1746 离开中山路](https://www.luogu.com.cn/problem/P1746)
  - [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)

### 个人心得摘录
- **预处理范围**：务必枚举到 $\sqrt{M}$，限制在网格大小 $N$ 会导致漏解（如 $M$ 较大时）。
- **方向对称性**：每个 $(dx, dy)$ 需生成四个方向（正负组合），避免遗漏合法移动。

---
处理用时：216.04秒
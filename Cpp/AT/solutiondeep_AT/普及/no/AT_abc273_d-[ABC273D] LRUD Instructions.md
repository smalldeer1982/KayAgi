# 题目信息

# [ABC273D] LRUD Instructions

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc273/tasks/abc273_d

$ H $ 行 $ W $ 列のグリッドがあります。上から $ i $ 行目、左から $ j $ 列目にあるマスをマス $ (i,\ j) $ で表します。  
 $ N $ 個のマス $ (r_1,\ c_1),\ (r_2,\ c_2),\ \ldots,\ (r_N,\ c_N) $ は壁になっています。

はじめ、高橋君はマス $ (r_\mathrm{s},\ c_\mathrm{s}) $ にいます。

高橋君に $ Q $ 個の指示が与えられます。 $ i\ =\ 1,\ 2,\ \ldots,\ Q $ について、$ i $ 番目の指示は文字 $ d_i $ と正整数 $ l_i $ の組で表されます。$ d_i $ は `L` 、`R` 、`U` 、`D` のいずれかの文字であり、それぞれ左、右、上、下の方向を表します。

$ i $ 番目の指示に対して高橋君は下記の行動を $ l_i $ 回繰り返します。

> 現在いるマスに対して、$ d_i $ が表す向きに壁のないマスが隣接しているなら、そのマスに移動する。 そのようなマスが存在しない場合は、何もしない。

$ i\ =\ 1,\ 2,\ \ldots,\ Q $ について、$ i $ 番目までの指示を実行した直後に高橋君がいるマスを出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 10^9 $
- $ 1\ \leq\ r_\mathrm{s}\ \leq\ H $
- $ 1\ \leq\ c_\mathrm{s}\ \leq\ W $
- $ 0\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ r_i\ \leq\ H $
- $ 1\ \leq\ c_i\ \leq\ W $
- $ i\ \neq\ j\ \Rightarrow\ (r_i,\ c_i)\ \neq\ (r_j,\ c_j) $
- すべての $ i\ =\ 1,\ 2,\ \ldots,\ N $について、$ (r_\mathrm{s},\ c_\mathrm{s})\ \neq\ (r_i,\ c_i) $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ d_i $ は `L` 、`R` 、`U` 、`D` のいずれかの文字
- $ 1\ \leq\ l_i\ \leq\ 10^9 $
- $ d_i $ 以外の入力値は整数

### Sample Explanation 1

与えられるグリッドと高橋君の初期位置は下記の通りです。 ここで、`#` は壁のマスを、`T` は高橋君がいるマスを表し、`.` がその他のマスを表します。 ``` ...#. .#... ..... ...T. ..#.. ``` $ 1 $ つ目の指示に対して高橋君は、左に $ 2 $ マス移動し、高橋君の位置は下記の通り、マス $ (4,\ 2) $ になります。 ``` ...#. .#... ..... .T... ..#.. ``` $ 2 $ つ目の指示に対して高橋君は、上に $ 1 $ マスに移動した後、次の移動先が壁であるために「何もしない」を $ 2 $ 回行います。その結果、高橋君の位置は下記の通り、マス $ (3,\ 2) $ になります。 ``` ...#. .#... .T... ..... ..#.. ``` $ 3 $ つ目の指示に対して高橋君は、左に $ 1 $ マス移動した後、次の移動先となるマスが存在しないために「何もしない」を $ 1 $ 回行います。その結果、高橋君の位置は下記の通り、マス $ (3,\ 1) $ になります。 ``` ...#. .#... T.... ..... ..#.. ``` $ 4 $ つ目の指示に対して高橋君は、右に $ 4 $ マス移動し、高橋君の位置は下記の通り、マス $ (3,\ 5) $ になります。 ``` ...#. .#... ....T ..... ..#.. ```

## 样例 #1

### 输入

```
5 5 4 4

3

5 3

2 2

1 4

4

L 2

U 3

L 2

R 4```

### 输出

```
4 2

3 2

3 1

3 5```

## 样例 #2

### 输入

```
6 6 6 3

7

3 1

4 3

2 6

3 4

5 5

1 1

3 2

10

D 3

U 3

L 2

D 2

U 3

D 3

U 3

R 3

L 3

D 1```

### 输出

```
6 3

5 3

5 1

6 1

4 1

6 1

4 1

4 2

4 1

5 1```

# AI分析结果



# [ABC273D] LRUD Instructions 中文翻译

## 题目描述  
给定一个 $H$ 行 $W$ 列的网格，其中包含 $N$ 个障碍物。高桥君从初始位置 $(r_s, c_s)$ 出发，处理 $Q$ 个移动指令（L/R/U/D 方向及步数）。每次移动时，若遇到边界或障碍物则停止。要求输出每次指令执行后的最终位置。

## 输入格式  
输入包含：
- 网格尺寸 $H, W$ 和初始位置 $r_s, c_s$
- 障碍物数量 $N$ 及每个障碍物的坐标
- $Q$ 个指令（方向字符和步数）

## 输出格式  
对于每个指令，输出执行后的坐标。

## 算法分类  
**模拟** 与 **二分**

---

### 题解分析与结论  
**核心思路**：  
1. 使用 `map` 嵌套有序容器（`set`/`vector`）存储每行每列的障碍物坐标
2. 将网格边界视为虚拟障碍物，简化边界判断
3. 通过二分查找确定移动方向上的最近障碍物
4. 计算最大可移动距离（取「理论最大步数」与「障碍物限制步数」的较小值）

**关键技巧**：  
- 预处理时向每行每列添加边界（0 和最大尺寸+1）
- 根据移动方向选择正序/逆序二分查找（如向左移动时使用反向迭代器）
- 使用 `set::lower_bound`（$O(\log n)$）而非全局 `lower_bound`（$O(n)$）

---

### 精选题解  
#### 1. DYYqwq 题解（⭐⭐⭐⭐⭐）  
**亮点**：  
- 边界处理清晰，代码简洁
- 利用 `set` 自动排序特性
- 统一使用 `upper_bound` 和反向迭代处理不同方向  

**核心代码**：  
```cpp
map<int, set<int>> h, l; // 行、列障碍物集合

// 处理向左移动
int zhangai = *(--h[sx].lower_bound(sy));
sy = max(0, max(zhangai + 1, sy - d));

// 处理向右移动
int zhangai = *h[sx].upper_bound(sy);
sy = min(ww, min(zhangai - 1, sy + d));
```

#### 2. Epoch_L 题解（⭐⭐⭐⭐）  
**亮点**：  
- 显式添加虚拟边界
- 使用对称逻辑处理四个方向  

**调试心得**：  
> "考试时能用 `vector` 就千万不要用 `set`，常数大！"  
> —— 通过预处理排序降低时间复杂度

#### 3. Saint_ying_xtf 题解（⭐⭐⭐⭐）  
**关键实现**：  
```cpp
// 正确使用 set 的成员函数
auto it = row[x].lower_bound(y); // O(log n)
if (it == row[x].begin()) y = max(y - l, 1);
else y = max(*--it + 1, y - l);
```

**顿悟总结**：  
> "`set.lower_bound(x)` 时间复杂度是 $O(\log n)$，而全局 `lower_bound(set.begin(), set.end(), x)` 是 $O(n)$ 的！"

---

### 推荐练习  
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908) - 二分与树状数组应用  
2. [P1514 引水入城](https://www.luogu.com.cn/problem/P1514) - 二维网格动态规划  
3. [P1825 Corn Maze S](https://www.luogu.com.cn/problem/P1825) - 带障碍的 BFS 路径搜索

---
处理用时：49.74秒
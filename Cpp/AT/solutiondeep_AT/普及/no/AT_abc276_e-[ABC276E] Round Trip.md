# 题目信息

# [ABC276E] Round Trip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc276/tasks/abc276_e

縦 $ H $ 行、横 $ W $ 列のマス目があり、上から $ i\ \,\ (1\ \leq\ i\ \leq\ H) $ 行目、左から $ j\ \,\ (1\ \leq\ j\ \leq\ W) $ 列目のマスを $ (i,\ j) $ と表します。

各マスは「始点」「道」「障害物」のいずれかです。  
マス $ (i,\ j) $ の状態は文字 $ C_{i,\ j} $ で表され、$ C_{i,\ j}\ = $ `S` なら始点、$ C_{i,\ j}\ = $ `.` なら道、$ C_{i,\ j}\ = $ `#` なら障害物です。始点のマスはただ一つ存在します。

始点のマスを出発し、上下または左右に隣接するマスに移動することを繰り返して、障害物のマスを通らずに始点のマスへ戻ってくるような長さ $ 4 $ 以上の経路であって、最初と最後を除き同じマスを通らないようなものが存在するか判定してください。  
より厳密には、以下の条件を満たす整数 $ n $ およびマスの列 $ (x_0,\ y_0),\ (x_1,\ y_1),\ \dots,\ (x_n,\ y_n) $ が存在するか判定してください。

- $ n\ \geq\ 4 $
- $ C_{x_0,\ y_0}\ =\ C_{x_n,\ y_n}\ = $ `S`
- $ 1\ \leq\ i\ \leq\ n\ -\ 1 $ ならば $ C_{x_i,\ y_i}\ = $ `.`
- $ 1\ \leq\ i\ \lt\ j\ \leq\ n\ -\ 1 $ ならば $ (x_i,\ y_i)\ \neq\ (x_j,\ y_j) $
- $ 0\ \leq\ i\ \leq\ n\ -\ 1 $ ならばマス $ (x_i,\ y_i) $ とマス $ (x_{i+1},\ y_{i+1}) $ は上下または左右に隣接する

## 说明/提示

### 制約

- $ 4\ \leq\ H\ \times\ W\ \leq\ 10^6 $
- $ H,\ W $ は $ 2 $ 以上の整数
- $ C_{i,\ j} $ は `S`、`.`、`#` のいずれか
- $ C_{i,\ j}\ = $ `S` となる $ (i,\ j) $ がただ一つ存在する

### Sample Explanation 1

$ (3,\ 2)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (1,\ 2)\ \rightarrow\ (1,\ 3)\ \rightarrow\ (1,\ 4)\ \rightarrow\ (2,\ 4)\ \rightarrow\ (3,\ 4)\ \rightarrow\ (3,\ 3)\ \rightarrow\ (3,\ 2) $ という経路が条件を満たします。

## 样例 #1

### 输入

```
4 4
....
#.#.
.S..
.##.```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 2
S.
.#```

### 输出

```
No```

## 样例 #3

### 输入

```
5 7
.#...#.
..#.#..
...S...
..#.#..
.#...#.```

### 输出

```
No```

# AI分析结果



### 题目内容翻译  
#### [ABC276E] Round Trip  

**题目描述**  

给定一个 $H$ 行 $W$列的网格，每个格子是起点、道路或障碍物。起点用 `S` 表示，道路用 `.` 表示，障碍物用 `#` 表示。保证起点唯一。  

要求判断是否存在一条从起点出发的路径，满足以下条件：  
1. 路径长度至少为 4  
2. 路径最终回到起点  
3. 路径中除起点外，其他格子不重复经过  
4. 路径只能上下左右移动且不经过障碍物  

**输入格式**  
第一行输入 $H$ 和 $W$，接下来 $H$ 行每行一个长度为 $W$ 的字符串表示网格。  

**输出格式**  
若存在符合条件的路径输出 `Yes`，否则输出 `No`。  

---

### 算法分类  
**并查集** 或 **广度优先搜索 BFS**  

---

### 题解分析与结论  
题目核心是判断是否存在一个包含起点的环，其关键思路为：  
**若起点的四个相邻点中存在两个点属于同一连通块（且连通路径不经过起点），则存在符合条件的环。**  

各题解主要分为两类方法：  
1. **连通性判断**：通过并查集或 BFS 预处理网格的连通性（排除起点），检查起点邻点是否有两个连通  
2. **直接路径搜索**：DFS/BFS 搜索是否存在符合条件的路径，辅以剪枝优化  

---

### 精选题解  
#### 1. Binary_Lee（5星）  
**关键亮点**：  
- 用 BFS 对起点邻点的连通块染色  
- 染色后只需判断邻点是否属于同一颜色  
- 时间复杂度 $O(HW)$，代码简洁高效  
**核心代码**：  
```cpp
for (int i=0; i<4; i++) {
    int x = sx + dx[i], y = sy + dy[i];
    if (越界或障碍) continue;
    if (!vis[x][y]) {
        tot++; // 新颜色
        BFS染色该连通块
    } else if (颜色不同) {
        cout << "Yes"; // 发现连通
    }
}
```

#### 2. Semorius（5星）  
**关键亮点**：  
- 并查集预处理全图连通性（排除起点）  
- 枚举起点邻点判断连通性  
- 时间复杂度 $O(HW \alpha(HW))$，理论效率更优  
**核心代码**：  
```cpp
// 并查集预处理
for (所有格子) {
    if (是障碍或起点) continue;
    for (相邻格子) {
        if (可连通) 合并集合
    }
}
// 判断起点邻点
for (四个邻点两两组合) {
    if (属于同一集合) 输出 Yes
}
```

#### 3. FFTotoro（4星）  
**关键亮点**：  
- 带剪枝的 DFS 路径搜索  
- 剪枝策略：若某点剩余可走方向少于 2 则不回溯标记  
- 巧妙利用最短环特性（长度 ≥4）  
**个人心得**：  
> "TLE 后被剪枝策略启发，发现某些点回溯无意义，直接标记为不可走优化效率"  

---

### 关键思路总结  
**连通性判定法**（最优）：  
1. 将起点视为障碍物，预处理其他格子的连通性  
2. 检查起点上下左右四个邻点是否存在两个属于同一连通块  
3. 若存在则必然可以形成合法环  

**实现技巧**：  
- 并查集的一维化坐标：`id = x * W + y`  
- BFS 染色时用不同标记区分不同邻点的连通区域  

---

### 拓展与相似题目  
1. **连通性判断**：[P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)  
2. **路径搜索剪枝**：[P1363 幻象迷宫](https://www.luogu.com.cn/problem/P1363)  
3. **并查集应用**：[P1396 营救](https://www.luogu.com.cn/problem/P1396)

---
处理用时：172.47秒
# 题目信息

# [ABC280E] Critical Hit

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc280/tasks/abc280_e

最初、体力が $ N $ であるモンスターが $ 1 $ 体います。  
 高橋君はモンスターに対し、モンスターの体力が $ 1 $ 以上残っている限り繰り返し攻撃を行います。

高橋君は $ 1 $ 回の攻撃で、$ \frac{P}{100} $ の確率でモンスターの体力を $ 2 $ 減らし、 $ 1-\frac{P}{100} $ の確率でモンスターの体力を $ 1 $ 減らします。

モンスターの体力が $ 0 $ 以下になるまでに行う攻撃回数の期待値を $ \text{mod\ }\ 998244353 $ で出力してください（注記参照）。

## 说明/提示

### 注記

求める期待値は必ず有限値かつ有理数となることが証明できます。また、この問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、$ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ一つ存在することが証明できます。この $ R $ を出力してください。

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ P\ \leq\ 100 $
- 入力は全て整数
 
### Sample Explanation 1

高橋君は $ 1 $ 回の攻撃で、 $ \frac{10}{100}=\frac{1}{10} $ の確率でモンスターの体力を $ 2 $ 減らし、 $ 1-\frac{10}{100}=\frac{9}{10} $ の確率でモンスターの体力を $ 1 $ 減らします。 - 最初、モンスターの体力は $ 3 $ です。 - $ 1 $ 回目の攻撃の後、$ \frac{9}{10} $の確率でモンスターの体力は $ 2 $、$ \frac{1}{10} $の確率でモンスターの体力は $ 1 $ となります。 - $ 2 $ 回目の攻撃の後、$ \frac{81}{100} $の確率でモンスターの体力は $ 1 $、$ \frac{18}{100} $ の確率でモンスターの体力は $ 0 $、$ \frac{1}{100} $ の確率でモンスターの体力は $ -1 $ となります。 $ \frac{18}{100}+\frac{1}{100}=\frac{19}{100} $ の確率で体力は $ 0 $ 以下となり、高橋君は $ 2 $ 回で攻撃をやめます。 - $ 2 $ 回目の攻撃の後で体力が $ 1 $ 残っている場合、$ 3 $ 回目の攻撃の後でモンスターの体力は必ず $ 0 $ 以下となり、高橋君は $ 3 $ 回で攻撃をやめます。 よって、期待値は $ 2\times\ \frac{19}{100}+3\times\left(1-\frac{19}{100}\right)=\frac{281}{100} $ となります。$ 229596204\ \times\ 100\ \equiv\ 281\pmod{998244353} $ であるため、$ 229596204 $ を出力します。

### Sample Explanation 2

高橋君は $ 1 $ 回の攻撃で、つねにモンスターの体力を $ 2 $ 減らします。 $ 2 $ 回目の攻撃が終わった時点では体力が $ 5-2\times\ 2=1 $ 残っているため、$ 3 $ 回目の攻撃を行う必要があります。

## 样例 #1

### 输入

```
3 10```

### 输出

```
229596204```

## 样例 #2

### 输入

```
5 100```

### 输出

```
3```

## 样例 #3

### 输入

```
280 59```

### 输出

```
567484387```

# AI分析结果



# 中文题目重写（原题已为中文，略）

## 算法分类
动态规划

## 综合分析
本题核心为期望动态规划，需处理概率转移与模运算。各题解均采用DP思路，主要差异在于状态转移方向（顺推/逆推）和边界处理方式。关键点在于：
1. 状态定义：dp[i] 表示剩余i血量时的期望攻击次数
2. 概率处理：将百分数转换为模意义下的分数（费马小定理求逆元）
3. 转移方程：合并两种攻击情况的期望值

## 精选题解（评分≥4星）

### 1. liangbowen（4星）
**核心思路**：逆推法，从n到0计算状态转移  
**亮点**：
- 状态转移方程直观清晰：`dp[i] = (dp[i+1]*(1-p) + dp[i+2]*p) + 1`
- 循环实现高效，无需处理特殊边界
- 代码简洁，仅需单循环

```cpp
ll dp[200005];
void solve() {
    int n, p;
    scanf("%d%d", &n, &p);
    p = 1ll * p * qpow(100) % mod; // 概率取模处理

    dp[n] = 0;
    for(int i = n-1; i >= 0; i--) // 逆序递推
        dp[i] = (dp[i+1]*(mod+1-p)%mod + dp[i+2]*p%mod + 1) % mod;
    cout << dp[0];
}
```

### 2. 泥土笨笨（4星）
**核心思路**：顺推法，从0到n逐步计算  
**亮点**：
- 符合直觉的正向思维：当前状态由前序状态推导
- 明确处理边界条件`f[0]=0, f[1]=1`
- 代码结构易于理解

```cpp
ll f[MAXN];
int main() {
    f[0] = 0; f[1] = 1;
    for(int i=2; i<=n; i++)
        f[i] = (hit2*f[i-2] + hit1*f[i-1] + 1) % mod;
}
```

### 3. Moyou（4星）
**核心思路**：正向DP优化  
**亮点**：
- 使用快速幂模板化逆元计算
- 预处理概率值提升效率
- 代码结构模块化，可读性强

```cpp
LL f[N];
int main() {
    p = p * qmi(100, mod-2, mod) % mod; // 预处理概率
    for(int i=2; i<=n; i++)
        f[i] = (f[i-2]*p + f[i-1]*(1-p+mod) + 1) % mod;
}
```

## 关键技巧总结
1. **逆元处理**：使用费马小定理`a^(mod-2)`处理分数取模
2. **转移方向选择**：逆推法可避免处理复杂边界条件
3. **空间优化**：使用滚动数组可将空间复杂度优化至O(1)
4. **概率合并**：提前计算`(1-p+mod)%mod`防止负数出现

## 同类题目推荐
1. [P1850 换教室](https://www.luogu.com.cn/problem/P1850) - 期望DP经典题
2. [P4550 收集邮票](https://www.luogu.com.cn/problem/P4550) - 期望的平方处理
3. [P5249 概率论](https://www.luogu.com.cn/problem/P5249) - 期望与组合数学结合

## 题解心得摘录
1. *liangbowen*：调试时发现逆推法边界处理更简单，无需考虑数组越界  
2. *Moyou*：初始将`p=100`的情况单独考虑，避免概率计算错误  
3. *FFTotoro*：通过预处理逆元将时间复杂度优化至O(n)

---
处理用时：51.51秒
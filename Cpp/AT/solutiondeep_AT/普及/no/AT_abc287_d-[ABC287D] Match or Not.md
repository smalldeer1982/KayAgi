# 题目信息

# [ABC287D] Match or Not

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc287/tasks/abc287_d

英小文字と `?` からなる文字列 $ S,T $ が与えられます。ここで、$ |S|\ \gt\ |T| $ が成り立ちます(文字列 $ X $ に対し、 $ |X| $ で $ X $ の長さを表します)。

また、$ |X|=|Y| $ を満たす文字列 $ X,Y $ は、次の条件を満たすとき及びそのときに限り**マッチする**といいます。

- $ X,Y $ に含まれる `?` をそれぞれ独立に好きな英小文字に置き換えることで $ X $ と $ Y $ を一致させることができる
 
$ x=0,1,\ldots,|T| $ に対して次の問題を解いてください。

- $ S $ の先頭の $ x $ 文字と末尾の $ |T|-x $ 文字を順番を保ったまま連結することで得られる長さ $ |T| $ の文字列を $ S' $ とする。$ S' $ と $ T $ がマッチするならば `Yes` と、そうでなければ `No` と出力せよ。

## 说明/提示

### 制約

- $ S,T $ は英小文字と `?` からなる文字列
- $ 1\ \leq\ |T|\ \lt\ |S|\ \leq\ 3\ \times\ 10^5 $
 
### Sample Explanation 1

$ x=0 $ の場合、$ S' $ は `?c` となります。ここで、$ S' $ の $ 1 $ 文字目の `?` を `b` に、$ T $ の $ 2 $ 文字目の `?` を `c` に置き換えることで $ S' $ と $ T $ を一致させることができるため、$ S' $ と $ T $ はマッチします。このため、$ 1 $ 行目の出力は `Yes` です。 $ x=1,2 $ の場合は $ S' $ はそれぞれ `ac`、`a?` であり、$ T $ とマッチしません。このため、$ 2,3 $ 行目の出力は `No` です。

## 样例 #1

### 输入

```
a?c

b?```

### 输出

```
Yes

No

No```

## 样例 #2

### 输入

```
atcoder

?????```

### 输出

```
Yes

Yes

Yes

Yes

Yes

Yes```

## 样例 #3

### 输入

```
beginner

contest```

### 输出

```
No

No

No

No

No

No

No

No```

# AI分析结果



# [ABC287D] Match or Not 的题解分析

## 题目中文翻译
### 题目描述
给定由小写字母和 `?` 组成的字符串 $S$ 和 $T$，其中 $|S| > |T|$。定义两个等长字符串 $X$ 和 $Y$ **匹配**的条件为：通过替换 `?` 为任意小写字母后，$X$ 和 $Y$ 可以完全相同。

对于每个 $x = 0,1,\ldots,|T|$，判断将 $S$ 的前 $x$ 个字符与后 $|T|-x$ 个字符拼接得到的字符串 $S'$ 是否与 $T$ 匹配。若匹配则输出 `Yes`，否则输出 `No`。

### 输入输出样例
#### 样例 #1
**输入：**
```
a?c
b?
```
**输出：**
```
Yes
No
No
```
#### 样例 #2
**输入：**
```
atcoder
?????
```
**输出：**
```
Yes（共6行）
```

---

## 算法分类
**递推**

---

## 题解综合分析

### 核心思路
1. **分治处理**：将问题拆分为前缀和后缀的独立判断，预处理前缀和后缀的匹配状态。
2. **递推预处理**：构建 `pre[i]` 表示前 $i$ 个字符是否匹配，`suf[i]` 表示后 $i$ 个字符是否匹配。
3. **动态维护计数**：初始计算不匹配的字符数，每次 $x$ 变化时仅更新受影响的字符，维护总不匹配数。

### 关键技巧
- **差分更新**：通过记录初始状态的变化量，将每次查询的时间复杂度降至 $O(1)$。
- **双指针预处理**：正序和逆序扫描字符串，递推计算前缀和后缀的匹配状态。

---

## 精选题解

### 题解1：泥土笨笨（5星）
**亮点**：动态维护不匹配计数，时间复杂度 $O(n)$，代码简洁高效。
**核心思路**：
1. 初始计算后缀部分的不匹配数 `cnt`。
2. 对每个 $x$，检查新增的前缀字符和移除的后缀字符对 `cnt` 的影响。
3. 若 `cnt == 0` 则输出 `Yes`，否则输出 `No`。

**代码片段**：
```cpp
int cnt = 0;
// 初始计算后缀匹配情况
for (int i = 0; i < tl; ++i) {
    if (s[sl - tl + i] != '?' && t[i] != '?' && s[sl - tl + i] != t[i]) {
        cnt++;
    }
}
// 动态更新 cnt
for (int x = 1; x <= tl; ++x) {
    if (s[x - 1] != '?' && t[x - 1] != '?' && s[x - 1] != t[x - 1]) cnt++;
    if (s[sl - tl + x - 1] != '?' && t[x - 1] != '?' && s[sl - tl + x - 1] != t[x - 1]) cnt--;
    // 输出结果
}
```

---

### 题解2：bloodstalk（5星）
**亮点**：递推预处理前后缀匹配状态，逻辑清晰。
**核心思路**：
1. 构建 `pre[i]` 表示前 $i$ 个字符是否匹配。
2. 构建 `suf[i]` 表示后 $i$ 个字符是否匹配。
3. 对于每个 $x$，若 `pre[x]` 和 `suf[m-x]` 同时为真则输出 `Yes`。

**代码片段**：
```cpp
// 预处理前缀匹配
pre[0] = 1;
for (int i = 1; i <= m; i++) {
    pre[i] = pre[i-1] && (s[i] == t[i] || s[i] == '?' || t[i] == '?');
}
// 预处理后缀匹配
suf[n+1] = 1;
for (int i = n, j = m; j >= 1; i--, j--) {
    suf[i] = suf[i+1] && (s[i] == t[j] || s[i] == '?' || t[j] == '?');
}
// 合并结果
for (int x = 0; x <= m; x++) {
    if (pre[x] && suf[n - m + x + 1]) cout << "Yes\n";
    else cout << "No\n";
}
```

---

## 相似题目推荐
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)  
   **标签**：字符串匹配、前缀函数
2. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)  
   **标签**：前缀和、递推
3. [P2922 [USACO08DEC]Secret Message G](https://www.luogu.com.cn/problem/P2922)  
   **标签**：前缀树、字符串处理

---
处理用时：119.34秒
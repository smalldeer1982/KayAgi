# 题目信息

# [ABC289E] Swap Places

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc289/tasks/abc289_e

頂点に $ 1 $ から $ N $ までの、辺に $ 1 $ から $ M $ までの番号がついた $ N $ 頂点 $ M $ 辺の単純無向グラフがあります。 辺 $ i $ は頂点 $ u_i $ と頂点 $ v_i $ を結んでいます。  
 また、全ての頂点は赤か青のいずれか一方で塗られています。頂点 $ i $ の色は $ C_i $ で表されて、$ C_i $ が $ 0 $ ならば頂点 $ i $ は赤く、$ 1 $ ならば頂点 $ i $ は青く塗られています。

今、高橋君が頂点 $ 1 $ に、青木君が頂点 $ N $ にいます。  
 2 人は次の行動を $ 0 $ 回以上好きな回数繰り返します。

- 2 人が同時に、今いる頂点に隣接している頂点のいずれか 1 個に移動する。  
   ただし、高橋君の移動先の頂点の色と、青木君の移動先の頂点の色は異なる必要がある。
 
上記の行動を繰り返すことで、高橋君が頂点 $ N $ に、青木君が頂点 $ 1 $ にいる状態にできますか？  
 可能である場合は必要な行動回数の最小値を答えてください。不可能である場合は `-1` を出力してください。

入力のはじめに $ T $ が与えられるので、$ T $ 個のテストケースについて問題を解いてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 1000 $
- $ 2\ \leq\ N\ \leq\ 2000 $
- $ 1\ \leq\ M\ \leq\ \min(\frac{N(N-1)}{2},\ 2000) $
- $ C_i\ \in\ \lbrace\ 0,\ 1\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 入力で与えられるグラフは単純
- 入力される値は全て整数
- 全てのテストケースに対する $ N $ の総和は $ 2000 $ を超えない。
- 全てのテストケースに対する $ M $ の総和は $ 2000 $ を超えない。
 
### Sample Explanation 1

1 番目のテストケースでは、高橋君と青木君は以下のように行動することで、 $ 3 $ 回の行動で目的の状態を達成することができて、これが最小です。 - 高橋君が頂点 $ 3 $ に、青木君が頂点 $ 2 $ に移動する。 - 高橋君が頂点 $ 2 $ に、青木君が頂点 $ 3 $ に移動する。 - 高橋君が頂点 $ 4 $ に、青木君が頂点 $ 1 $ に移動する。 ここで、$ 1 $ 回目の移動で高橋君と青木君がともに頂点 $ 2 $ に移動することはできないのに注意してください。(なぜならば、高橋君の移動先の頂点の色と青木君の移動先の頂点の色は異なる必要があるからです。) 2 番目のテストケースでは、2 人はどのように行動しても目的の状態を達成することはできません。

## 样例 #1

### 输入

```
3

4 4

0 1 0 1

1 2

2 3

1 3

2 4

3 3

0 1 0

1 2

2 3

1 3

6 6

0 0 1 1 0 1

1 2

2 6

3 6

4 6

4 5

2 4```

### 输出

```
3

-1

3```

# AI分析结果



# [ABC289E] Swap Places 题目翻译

## 题目描述

给定一个包含 $N$ 个顶点和 $M$ 条边的简单无向图。顶点编号为 $1$ 到 $N$，边编号为 $1$ 到 $M$。每个顶点被涂成红色（用 0 表示）或蓝色（用 1 表示）。  
高桥君初始在顶点 1，青木君初始在顶点 N。他们可以同时移动到相邻顶点，但每次移动后两人的顶点颜色必须不同。求让高桥君到达顶点 N 且青木君到达顶点 1 的最小移动次数，若不可能输出 -1。  
共 T 组测试数据，保证所有测试用例的 N 总和不超过 2000，M 总和不超过 2000。

## 算法分类
**广度优先搜索 BFS**

---

## 题解综合分析

**核心思路**：将两人的位置作为二维状态进行 BFS，每次扩展时遍历所有可能的移动组合，仅保留颜色不同的状态。

**关键观察**：
1. 状态需要同时记录两人的位置 $(u,v)$
2. 移动合法性条件：移动后两人新位置的 $c_{new\_u} \neq c_{new\_v}$
3. 使用 BFS 保证首次到达终点即为最小步数

**解决难点**：
- 状态空间达到 $O(N^2)$，需优化遍历方式
- 正确处理多测试用例的初始化
- 提前剪枝起始颜色相同的情况

---

## 精选题解

### 题解1：ForgotDream_CHN（⭐⭐⭐⭐⭐）
**亮点**：
- 清晰的二维状态设计
- 简洁的邻接表存储
- 提前处理起始颜色相同的情况
- 时间复杂度分析准确

**代码核心**：
```cpp
int bfs() {
    queue<pair<int, int>> q;
    q.emplace(1, n);
    dis[1][n] = 0;
    
    while (!q.empty()) {
        auto [curx, cury] = q.front();
        if (curx == n && cury == 1) return dis[curx][cury];
        
        for (int i : e[curx]) 
            for (int j : e[cury])
                if (dis[i][j] == -1 && c[i] != c[j]) {
                    dis[i][j] = dis[curx][cury] + 1;
                    q.emplace(i, j);
                }
        q.pop();
    }
    return -1;
}
```

### 题解2：ImposterAnYu（⭐⭐⭐⭐）
**亮点**：
- 使用异或运算加速颜色判断
- 独立处理多测试用例的数组清空
- 代码中包含实用性注释

**技巧借鉴**：
```cpp
if(a[xx] ^ a[yy] && !vis[xx][yy]) { // 异或运算判断颜色不同
    vis[xx][yy] = 1;
    if(xx == n && yy == 1) return st;
    q.push({xx,yy,st});
}
```

### 题解3：Mikefeng（⭐⭐⭐⭐）
**优化点**：
- 使用预初始化INF减少memset开销
- 显式状态转移方程表述
- 提前终止搜索优化

**代码片段**：
```cpp
void get_ans(){
    q.push({1,n});
    f[1][n] = 0;
    while(!q.empty()){
        auto [x,y] = q.front(); q.pop();
        for(int fx:e[x]) 
            for(int fy:e[y])
                if(c[fx]!=c[fy] && f[fx][fy]==INF){
                    f[fx][fy] = f[x][y]+1;
                    q.push({fx,fy});
                }
    }
}
```

---

## 关键思路总结
1. **状态建模**：将两人位置 $(u,v)$ 作为二维状态
2. **BFS扩展**：每次遍历两人的所有相邻节点组合
3. **颜色验证**：移动后必须满足 $c_u \neq c_v$
4. **剪枝优化**：起始颜色相同直接返回-1

**实现技巧**：
- 使用队列存储二维状态对
- 邻接表存储图结构
- 二维数组记录访问状态及步数
- 预处理初始颜色冲突情况

---

## 拓展练习
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通块BFS
2. [P1126 机器人搬重物](https://www.luogu.com.cn/problem/P1126) - 带方向状态的三维BFS
3. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032) - 双向BFS应用

---

## 调试心得
1. **多测清空**：忘记清空邻接表导致WA
2. **终点判断**：误将终点判断放在扩展前，错过及时返回
3. **颜色判断**：错误比较移动前颜色而非移动后颜色
> "调试时发现，应该比较新位置的c值而非旧位置，这个错误导致样例始终无法通过" —— 引自某题解评论区

---
处理用时：49.42秒
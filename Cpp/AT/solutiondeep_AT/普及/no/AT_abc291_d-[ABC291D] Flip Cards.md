# 题目信息

# [ABC291D] Flip Cards

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc291/tasks/abc291_d

$ 1 $ から $ N $ までの番号がついた $ N $ 枚のカードが一列に並んでいて、各 $ i\ (1\leq\ i\ <\ N) $ に対してカード $ i $ とカード $ i+1 $ が隣り合っています。 カード $ i $ の表には $ A_i $ が、裏には $ B_i $ が書かれており、最初全てのカードは表を向いています。

今から、$ N $ 枚のカードのうち好きな枚数 ($ 0 $ 枚でも良い) を選んで裏返すことを考えます。 裏返すカードの選び方は $ 2^N $ 通りありますが、そのうち以下の条件を満たすものの数を $ 998244353 $ で割った余りを求めてください。

- 選んだカードを裏返した後、どの隣り合う $ 2 $ 枚のカードについても、向いている面に書かれた数が相異なる。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,B_i\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

裏返すカードの番号の集合を $ S $ とします。 例えば $ S=\{2,3\} $ を選ぶと、向いている面に書かれた数はカード $ 1 $ から順に $ 1,2,4 $ となるため条件を満たします。 一方 $ S=\{3\} $ を選ぶと、向いている面に書かれた数はカード $ 1 $ から順に $ 1,4,4 $ となり、カード $ 2 $ とカード $ 3 $ の数が一致するため条件を満たしません。 条件を満たす $ S $ は $ \{\},\{1\},\{2\},\{2,3\} $ の $ 4 $ 通りです。

## 样例 #1

### 输入

```
3
1 2
4 2
3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
4
1 5
2 6
3 7
4 8```

### 输出

```
16```

## 样例 #3

### 输入

```
8
877914575 602436426
861648772 623690081
476190629 262703497
971407775 628894325
822804784 450968417
161735902 822804784
161735902 822804784
822804784 161735902```

### 输出

```
48```

# AI分析结果



# 题目重写

## [ABC291D] 翻转卡片

### 题目描述

编号为 $1$ 至 $N$ 的 $N$ 张卡片排成一列，每张卡片正面写有 $A_i$，背面写有 $B_i$。初始时所有卡片正面朝上。

你可以选择任意数量的卡片进行翻转（包括不翻转）。求满足以下条件的翻转方案数模 $998244353$ 的结果：

- 翻转操作完成后，任意相邻两张卡片朝上面上的数字都不相同。

### 输入格式

第一行输入 $N$，随后 $N$ 行每行输入 $A_i$ 和 $B_i$。

### 输出格式

输出符合条件的方案数模 $998244353$ 的值。

### 样例

#### 样例输入1
```
3
1 2
4 2
3 4
```

#### 样例输出1
```
4
```

---

## 算法分类
动态规划

---

## 题解综合分析与结论

本题需要计算满足相邻卡片数字不同的翻转方案数，采用动态规划解法。核心思路是用状态 `dp[i][0/1]` 表示前 `i` 张卡片中，第 `i` 张保持正面/反面时的有效方案数。转移时需确保当前卡片与前一张卡片的数值不同。

### 关键思路
1. **状态定义**：`dp[i][0]` 和 `dp[i][1]` 分别表示第 `i` 张卡片保持正面/反面时的方案数。
2. **转移方程**：根据前一张卡片的状态，检查当前卡片正反面数值是否与前一张冲突，累加不冲突的方案数。
3. **初始化**：第一张卡片两种状态各有一种方案（翻转或不翻转）。
4. **循环处理**：从第二张卡片开始处理，避免数组越界。

### 评分较高的题解

#### 作者：ダ月（5星）
**核心亮点**：代码简洁，直接枚举前后状态组合，逻辑清晰。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10, mod=998244353;
int n, a[N][2];
long long f[N][2];

int main() {
    cin >> n;
    for(int i=1; i<=n; i++) cin >> a[i][0] >> a[i][1];
    f[1][0] = f[1][1] = 1;
    for(int i=2; i<=n; i++) {
        for(int j : {0, 1})        // 当前卡片状态
            for(int k : {0, 1})    // 前一张卡片状态
                if(a[i][j] != a[i-1][k])
                    f[i][j] = (f[i][j] + f[i-1][k]) % mod;
    }
    cout << (f[n][0] + f[n][1]) % mod;
}
```

#### 作者：Strelitzia_（4星）
**核心亮点**：分情况处理转移条件，逻辑完整。
```cpp
// 初始化与主循环片段
f[1][0] = f[1][1] = 1;
for(int i=2; i<=n; i++) {
    if(a[i] != a[i-1] && a[i] != b[i-1]) 
        f[i][0] = (f[i-1][1] + f[i-1][0]) % mod;
    // 其他条件分支类似处理...
}
```

---

## 关键技巧总结
1. **状态压缩**：只需记录前一个状态，空间复杂度优化为 $O(1)$。
2. **组合枚举**：通过双重循环枚举当前和前序状态，简化条件判断。
3. **边界处理**：明确起始位置（从第二张卡片开始处理），避免数组越界。

---

## 同类题目推荐
1. [P1357 花园](https://www.luogu.com.cn/problem/P1357)（状压DP）
2. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)（经典DP）
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)（状态压缩DP）

---
处理用时：155.43秒
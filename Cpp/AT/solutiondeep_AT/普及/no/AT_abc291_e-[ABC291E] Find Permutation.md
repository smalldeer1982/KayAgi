# 题目信息

# [ABC291E] Find Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc291/tasks/abc291_e

$ 1,\ldots,N $ の並び替えである長さ $ N $ の数列 $ A=(A_1,\ldots,A_N) $ があります。

あなたは $ A $ を知りませんが、$ M $ 個の整数の組 $ (X_i,Y_i) $ について、$ A_{X_i}\ <\ A_{Y_i} $ が成り立つことを知っています。

$ A $ を一意に特定できるかどうか判定し、できるなら $ A $ を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ X_i,Y_i\ \leq\ N $
- 入力は全て整数である
- 入力に矛盾しない $ A $ が存在する

### Sample Explanation 1

$ A=(3,1,2) $ であると一意に特定できます。

### Sample Explanation 2

$ A $ として $ (2,3,1),(3,2,1) $ の $ 2 $ 通りが考えられます。

## 样例 #1

### 输入

```
3 2
3 1
2 3```

### 输出

```
Yes
3 1 2```

## 样例 #2

### 输入

```
3 2
3 1
3 2```

### 输出

```
No```

## 样例 #3

### 输入

```
4 6
1 2
1 2
2 3
2 3
3 4
3 4```

### 输出

```
Yes
1 2 3 4```

# AI分析结果



# 题目重写

## [ABC291E] 寻找排列

### 题目描述

给定一个长度为 $N$ 的排列 $A=(A_1,\ldots,A_N)$（即 $1,\ldots,N$ 的排列）。已知 $M$ 对整数关系 $(X_i,Y_i)$，满足 $A_{X_i} < A_{Y_i}$。请判断 $A$ 是否唯一确定，若唯一则输出该排列。

### 输入格式

第一行包含两个整数 $N$ 和 $M$。  
接下来 $M$ 行每行两个整数 $X_i,Y_i$。

### 输出格式

若唯一存在满足条件的排列，输出 "Yes" 并给出排列；否则输出 "No"。

### 样例

#### 样例1
**输入**  
3 2  
3 1  
2 3  

**输出**  
Yes  
3 1 2  

#### 样例2
**输入**  
3 2  
3 1  
3 2  

**输出**  
No  

### 数据范围

- $2 \leq N \leq 2 \times 10^5$  
- $1 \leq M \leq 2 \times 10^5$  
- 保证输入合法且至少存在一个解

### 提示

当且仅当排列的拓扑序唯一时，排列可被唯一确定。

---

## 算法分类
**图论（拓扑排序）**

---

## 题解对比与结论

### 最优题解

#### 1. FFTotoro 题解（★★★★★）
**关键思路**：  
- 将约束关系转化为有向边建立DAG  
- 在拓扑排序过程中，若队列中同时存在多个可访问节点，说明存在多解  
- 根据拓扑序直接生成排列  

**核心代码**：
```cpp
queue<int> s;
for(int i=1;i<=n;i++)if(!d[i])s.emplace(i);
while(!s.empty()){
    if(s.size()>1){cout<<"No\n"; return 0;}
    int t=s.front(); s.pop(); a.emplace_back(t);
    for(int i:g[t])if(!--d[i])s.emplace(i);
}
```
**亮点**：  
- 直接通过队列长度判断多解情况  
- 时间复杂度 $O(N+M)$ 高效处理大数据  

#### 2. Neil_Qian 题解（★★★★☆）
**关键思路**：  
- 建立入度表进行拓扑排序  
- 在每次处理节点时，检查后继节点入度归零的数量  
- 通过计数器验证是否覆盖所有节点  

**核心代码**：
```cpp
queue<int> q;
while(m--)scanf("%d%d",&x,&y),v[x].push_back(y),d[y]++;
for(int i=1;i<=n;i++)if(!d[i])q.push(i);
if(q.size()!=1)printf("No"),exit(0);
while(!q.empty()){
    x=q.front(),q.pop(),a[x]=++cnt,w=0;
    for(int t:v[x]) if(--d[t]==0) q.push(t),w++;
    if(w>=2)printf("No"),exit(0);
}
```
**亮点**：  
- 显式处理入度归零时的分支情况  
- 代码简洁且逻辑严密  

#### 3. liujy_ 题解（★★★★☆）
**关键思路**：  
- 使用邻接表建图并统计入度  
- 通过拓扑序长度验证解的存在性  
- 利用映射处理重边  

**核心代码**：
```cpp
map<pair<int,int>,bool> mp;
queue<int> q;
// 建图时处理重边
if(mp[make_pair(x,y)])continue;
mp[make_pair(x,y)]=1;
in[y]++;add(x,y);
```
**亮点**：  
- 通过映射消除重复边的影响  
- 完整处理拓扑序生成过程  

---

## 关键思路总结
1. **图论建模**：将每个约束 $A_{X_i} < A_{Y_i}$ 视为有向边 $X_i \to Y_i$，构建DAG  
2. **拓扑判唯一**：在拓扑排序过程中，若任意时刻队列中存在多个候选节点，则存在多解  
3. **排列生成**：拓扑序即为排列的数值顺序，按拓扑序编号即可得到排列  

---

## 类似题目推荐
1. [P1347 排序](https://www.luogu.com.cn/problem/P1347)  
   - 考察拓扑排序与顺序判断  
2. [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)  
   - 拓扑排序在分层计算中的应用  
3. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)  
   - 拓扑排序结合动态规划

---
处理用时：61.28秒
# 题目信息

# [ABC292E] Transitivity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc292/tasks/abc292_e

頂点に $ 1 $ から $ N $ の番号が、辺に $ 1 $ から $ M $ の番号がついた $ N $ 頂点 $ M $ 辺の単純有向グラフが与えられます。辺 $ i $ は頂点 $ u_i $ から頂点 $ v_i $ への有向辺です。

また、あなたは次の操作を $ 0 $ 回以上何度でも行えます。

- 相異なる頂点 $ x,y $ であって頂点 $ x $ から頂点 $ y $ への有向辺が存在しないようなものを選ぶ。そして、頂点 $ x $ から頂点 $ y $ への有向辺を追加する。

このグラフが次の条件を満たす状態にするために最小で何回操作を行う必要があるかを求めてください。

- 相異なる頂点 $ a,b,c $ すべてについて、頂点 $ a $ から頂点 $ b $ への有向辺と頂点 $ b $ から頂点 $ c $ への有向辺がともに存在するならば頂点 $ a $ から頂点 $ c $ への有向辺も存在する。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 2000 $
- $ 0\ \leq\ M\ \leq\ 2000 $
- $ 1\ \leq\ u_i\ ,v_i\ \leq\ N $
- $ u_i\ \neq\ v_i $
- $ i\ \neq\ j $ ならば $ (u_i,v_i)\ \neq\ (u_j,v_j) $
- 入力はすべて整数

### Sample Explanation 1

初め、一例として頂点 $ 2,4,3 $ について、頂点 $ 2 $ から頂点 $ 4 $ への有向辺と頂点 $ 4 $ から頂点 $ 3 $ への有向辺がともに存在するにもかかわらず、頂点 $ 2 $ から頂点 $ 3 $ への有向辺は存在せず、条件を満たさない状態です。 そこで、以下の $ 3 $ 本の有向辺を追加すると条件を満たす状態になります。 - 頂点 $ 2 $ から頂点 $ 3 $ への有向辺 - 頂点 $ 2 $ から頂点 $ 1 $ への有向辺 - 頂点 $ 4 $ から頂点 $ 1 $ への有向辺 一方、$ 3 $ 本未満の追加で条件を満たす状態には出来ないため、答えは $ 3 $ です。

## 样例 #1

### 输入

```
4 3
2 4
3 1
4 3```

### 输出

```
3```

## 样例 #2

### 输入

```
292 0```

### 输出

```
0```

## 样例 #3

### 输入

```
5 8
1 2
2 1
1 3
3 1
1 4
4 1
1 5
5 1```

### 输出

```
12```

# AI分析结果



# [ABC292E] Transitivity

## 题目描述

**题目大意**  
给定一个包含 $N$ 个顶点和 $M$ 条有向边的简单有向图。你需要通过添加尽可能少的有向边，使得图满足传递性：对于任意三个不同的顶点 $a,b,c$，若存在 $a \to b$ 和 $b \to c$ 的边，则必须存在 $a \to c$ 的边。求最少需要添加的边数。

**输入格式**  
- 第一行包含两个整数 $N$ 和 $M$
- 接下来 $M$ 行，每行两个整数 $u_i$ 和 $v_i$，表示一条有向边

**输出格式**  
- 输出最少需要添加的边数

**样例解释**  
例如初始图中存在 $2 \to 4$ 和 $4 \to 3$ 的边，但缺少 $2 \to 3$ 的边，需要添加。最终通过添加 3 条边满足条件。

**算法分类**  
图论 / 广度优先搜索 (BFS)

---

### 题解分析与结论

#### 核心思路
**传递闭包等价性**：题目要求等价于将图补全为传递闭包。添加的边数为传递闭包边数（排除自环）减去原边数。

**BFS优化**：对每个节点进行 BFS，统计其可达的所有节点数，减去已有边数，总和即为答案。时间复杂度 $O(N(N+M))$，适用于题目约束。

#### 最优题解亮点

1. **zhlzt（5星）**
   - 亮点：使用 BFS 计算每个节点的可达节点数，思路清晰，代码简洁高效。时间复杂度严格符合题目规模。
   ```cpp
   int bfs(int s) {
       memset(vis, 0, sizeof(vis));
       queue<int> q;
       q.push(s); vis[s] = 1;
       int cnt = 0;
       while (!q.empty()) {
           int u = q.front(); q.pop();
           cnt++;
           for (int v : edge[u]) {
               if (!vis[v]) {
                   vis[v] = 1;
                   q.push(v);
               }
           }
       }
       return cnt - 1 - edge[s].size(); // 减去自身和已有边
   }
   ```

2. **快乐的大童（4星）**
   - 亮点：利用 bitset 优化传递闭包计算，代码极简。通过位运算加速集合操作，适合对代码简洁性有要求的场景。
   ```cpp
   for (int j = 1; j <= n; j++)
       for (int i = 1; i <= n; i++)
           if (f[i][j]) f[i] |= f[j];
   // 统计传递闭包边数（排除自环）后减去原边数
   ```

3. **FFTotoro（4星）**
   - 亮点：BFS 实现细节优化，使用动态数组维护访问状态，逻辑清晰。代码中显式处理出度统计，便于理解。
   ```cpp
   vector<bool> vis(n);
   queue<int> q; q.push(i); vis[i] = true;
   int reachable = 0;
   while (!q.empty()) {
       int u = q.front(); q.pop();
       reachable++;
       for (int v : g[u]) {
           if (!vis[v]) {
               vis[v] = true;
               q.push(v);
           }
       }
   }
   ans += reachable - 1 - g[i].size();
   ```

#### 关键技巧总结
- **可达性分析**：对每个节点进行 BFS/DFS，统计其可达节点数。需注意排除自身和已有边。
- **传递闭包优化**：bitset 加速适用于较小规模的传递闭包计算，但需注意时间复杂度。
- **避免重复计算**：BFS 中通过 vis 数组确保每个节点仅被访问一次。

#### 拓展与相似题目
- **传递闭包应用**：P4306 [JSOI2010]连通数（计算所有可达对数）
- **BFS优化**：P1613 跑路（结合路径倍增）
- **图论性质**：B3611 【模板】传递闭包（基础模板题）

---

**举一反三**  
当问题涉及图的传递性质时，优先考虑 BFS/DFS 计算可达性或传递闭包。对于稀疏图，BFS 更高效；密集图可尝试 bitset 优化。注意排除无效边（如自环）对答案的影响。

---
处理用时：200.49秒
# 题目信息

# [ABC294E] 2xN Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc294/tasks/abc294_e

$ 2 $ 行 $ L $ 列のマス目があります。 上から $ i $ 行目 $ (i\in\lbrace1,2\rbrace) $、左から $ j $ 列目 $ (1\leq\ j\leq\ L) $のマス目を $ (i,j) $ で表します。 $ (i,j) $ には整数 $ x\ _\ {i,j} $ が書かれています。

$ x\ _\ {1,j}=x\ _\ {2,j} $ であるような整数 $ j $ の個数を求めてください。

ただし、$ x\ _\ {i,j} $ の情報は $ (x\ _\ {1,1},x\ _\ {1,2},\ldots,x\ _\ {1,L}) $ と $ (x\ _\ {2,1},x\ _\ {2,2},\ldots,x\ _\ {2,L}) $ をそれぞれ連長圧縮した、長さ $ N\ _\ 1 $ の列 $ ((v\ _\ {1,1},l\ _\ {1,1}),\ldots,(v\ _\ {1,N\ _\ 1},l\ _\ {1,N\ _\ 1})) $ と長さ $ N\ _\ 2 $ の列 $ ((v\ _\ {2,1},l\ _\ {2,1}),\ldots,(v\ _\ {2,N\ _\ 2},l\ _\ {2,N\ _\ 2})) $ として与えられます。

ここで、列 $ A $ の連長圧縮とは、$ A $ の要素 $ v\ _\ i $ と正整数 $ l\ _\ i $ の組 $ (v\ _\ i,l\ _\ i) $ の列であって、次の操作で得られるものです。

1. $ A $ を異なる要素が隣り合っている部分で分割する。
2. 分割した各列 $ B\ _\ 1,B\ _\ 2,\ldots,B\ _\ k $ に対して、$ v\ _\ i $ を $ B\ _\ i $ の要素、$ l\ _\ i $ を $ B\ _\ i $ の長さとする。

## 说明/提示

### 制約

- $ 1\leq\ L\leq\ 10\ ^\ {12} $
- $ 1\leq\ N\ _\ 1,N\ _\ 2\leq\ 10\ ^\ 5 $
- $ 1\leq\ v\ _\ {i,j}\leq\ 10\ ^\ 9\ (i\in\lbrace1,2\rbrace,1\leq\ j\leq\ N\ _\ i) $
- $ 1\leq\ l\ _\ {i,j}\leq\ L\ (i\in\lbrace1,2\rbrace,1\leq\ j\leq\ N\ _\ i) $
- $ v\ _\ {i,j}\neq\ v\ _\ {i,j+1}\ (i\in\lbrace1,2\rbrace,1\leq\ j\lt\ N\ _\ i) $
- $ l\ _\ {i,1}+l\ _\ {i,2}+\cdots+l\ _\ {i,N\ _\ i}=L\ (i\in\lbrace1,2\rbrace) $
- 入力はすべて整数
 
### Sample Explanation 1

マス目は以下の図のようになっています。 !\[\](https://img.atcoder.jp/abc294/14f38720983c464a322b504738344f24.png) $ x\ _\ {1,j}=x\ _\ {2,j} $ となるような整数 $ j $ は、$ j=1,2,5,8 $ の $ 4 $ つなので、出力すべき値は $ 4 $ です。

### Sample Explanation 2

答えが $ 32\operatorname{bit} $ 整数に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
8 4 3

1 2

3 2

2 3

3 1

1 4

2 1

3 3```

### 输出

```
4```

## 样例 #2

### 输入

```
10000000000 1 1

1 10000000000

1 10000000000```

### 输出

```
10000000000```

## 样例 #3

### 输入

```
1000 4 7

19 79

33 463

19 178

33 280

19 255

33 92

34 25

19 96

12 11

19 490

33 31```

### 输出

```
380```

# AI分析结果



### 中文重述题目
**题目名称**: [ABC294E] 2xN Grid

**题目描述**  
给定一个2行L列的网格，每行的元素用连段压缩形式表示。要求找出两行对应列元素相等的列数。

**输入形式**  
输入包括两行的压缩表示：  
- 第一行给出N₁组(v₁,l₁)，表示连续l₁个v₁  
- 第二行给出N₂组(v₂,l₂)，表示连续l₂个v₂  

**输出**  
输出两行对应位置元素相同的列数。

**样例解释**  
样例1中，两行在j=1,2,5,8时相等，输出4。

---

### 算法分类  
**双指针**

---

### 题解分析与关键思路

#### 核心思路
1. **双指针遍历**：同时遍历两行的压缩段，每次处理当前段的重叠部分。
2. **区间交集计算**：比较当前段的起始与结束位置，若数值相同则累加交集长度。
3. **指针移动策略**：始终移动结束位置较小的段的指针，确保不漏判。

#### 最优题解（评分≥4星）

**题解作者：timmark（5星）**  
**关键亮点**：  
- 清晰的变量命名与逻辑结构，维护`i,j`指针及累计长度`l1,l2`  
- 通过`max(x,y)`和`min(l1,l2)`直接计算有效交集区间  
- 高效处理大数据量，时间复杂度O(N₁+N₂)  

**核心代码**  
```cpp
int main() {
    // ... 输入处理 ...
    int i=1,j=1;
    long long l1=b1[1], l2=b2[1];
    while(i<=n && j<=m) {
        long long x = l1 - b1[i], y = l2 - b2[j];
        if (a1[i] == a2[j]) {
            ans += max(0ll, min(l1,l2) - max(x,y));
        }
        if (l1 >= l2) {
            l2 += b2[++j];
        } else {
            l1 += b1[++i];
        }
    }
    cout << ans;
}
```

**题解作者：Neil_Qian（4星）**  
**关键亮点**：  
- 前缀和预处理段的起止位置，便于区间比较  
- 简洁的条件判断与指针移动逻辑  

**核心代码**  
```cpp
while (i <= n1 && j <= n2) {
    if (a[i].x == b[j].x) {
        ans += min(a[i].r, b[j].r) - max(a[i].l, b[j].l) + 1;
    }
    if (a[i].r < b[j].r) i++;
    else j++;
}
```

---

### 举一反三
- **同类问题**：区间合并、覆盖问题（如洛谷P1886滑动窗口、P1496火烧赤壁）  
- **技巧迁移**：双指针处理分段数据、前缀和优化区间计算  

**推荐练习题目**  
1. P1496 火烧赤壁（区间覆盖长度计算）  
2. P1886 滑动窗口（双指针维护区间极值）  
3. P1719 最大加权矩形（二维区间处理）

---
处理用时：120.23秒
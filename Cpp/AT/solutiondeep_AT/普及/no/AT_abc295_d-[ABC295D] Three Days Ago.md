# 题目信息

# [ABC295D] Three Days Ago

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc295/tasks/abc295_d

`20230322` は並べ替えると `02320232` となり、これは `0232` を $ 2 $ 度繰り返しています。  
 このように、数字のみからなる文字列であって、適切に文字を並び替える (そのままでもよい) ことによって同じ列を $ 2 $ 度繰り返すようにできるものを **嬉しい列** と呼びます。  
 数字のみからなる文字列 $ S $ が与えられるので、以下の条件を全て満たす整数の組 $ (l,r) $ はいくつあるか求めてください。

- $ 1\ \le\ l\ \le\ r\ \le\ |S| $ ( $ |S| $ は $ S $ の長さ)
- $ S $ の $ l $ 文字目から $ r $ 文字目までの (連続する) 部分文字列は嬉しい列である。

## 说明/提示

### 制約

- $ S $ は数字のみからなる長さ $ 1 $ 以上 $ 5\ \times\ 10^5 $ 以下の文字列
 
### Sample Explanation 1

$ S= $ `20230322` です。 条件を満たす整数組 $ (l,r) $ は $ (1,6),(1,8),(2,7),(7,8) $ の $ 4 $ つです。

### Sample Explanation 2

$ S $ の先頭が `0` である場合もあります。

## 样例 #1

### 输入

```
20230322```

### 输出

```
4```

## 样例 #2

### 输入

```
0112223333444445555556666666777777778888888889999999999```

### 输出

```
185```

## 样例 #3

### 输入

```
3141592653589793238462643383279502884197169399375105820974944```

### 输出

```
9```

# AI分析结果



# [ABC295D] Three Days Ago 的中文翻译

## 题目描述

`20230322` 可以重新排列为 `02320232`，这表示将 `0232` 重复两次。  
我们定义：一个仅包含数字的字符串，若能通过重新排列字符（包括不改变顺序）得到一个由两个相同字符串连接而成的新字符串，则称为**快乐字符串**。  
给定由数字组成的字符串 $ S $，求满足以下条件的整数对 $ (l,r) $ 的数量：

- $ 1 \le l \le r \le |S| $（$ |S| $ 表示 $ S $ 的长度）
- $ S $ 中从第 $ l $ 个字符到第 $ r $ 个字符形成的连续子串是快乐字符串。

---

**算法分类**：位运算、前缀和、哈希表

---

### 题解综合分析

**核心思路**：快乐字符串等价于所有字符出现次数均为偶数次。利用前缀和奇偶性状态压缩（10位二进制掩码），通过哈希表统计相同状态出现的次数，每次累加历史相同状态数即为有效区间数。

**关键技巧**：
1. 状态压缩：用二进制位表示0-9数字出现次数的奇偶性（0偶1奇）
2. 异或运算：快速更新当前位的奇偶状态
3. 哈希表存储：使用数组或map存储各状态出现次数，实现O(1)查询

---

### 精选题解 (评分≥4⭐️)

#### 1. Xy_top ⭐️⭐️⭐️⭐️⭐️（赞7）
**亮点**：
- 位掩码状态压缩实现高效查询
- 直接使用数组替代map，优化访问速度
- 代码简洁，时间复杂度O(n)

**核心代码**：
```cpp
int f[1024] = {1}, cnt[15];
for (int i = 1; i <= len; ++i) {
    ++cnt[s[i] - 48];
    int mask = 0;
    for (int j = 0; j <= 9; j++) 
        mask |= (1 << j) * (cnt[j] & 1);
    ans += f[mask]++;
}
```

#### 2. lilong ⭐️⭐️⭐️⭐️（赞0）
**亮点**：
- 异或运算实现快速状态翻转
- 简明解释状态转移原理
- 使用位运算优化状态更新

**核心代码**：
```cpp
d ^= (1 << k);
ans += cnt[d];
cnt[d]++;
```

#### 3. Cindy_Li ⭐️⭐️⭐️⭐️（赞2）
**个人心得**：
> "考场差一点AC，忘记处理初始状态。必须记住空前缀状态要先存入map"

**核心思路**：
- 使用位掩码表示前缀异或状态
- 初始存入mask=0的状态保证区间起点从1开始有效

---

### 最优思路总结
**核心实现步骤**：
1. 初始化哈希表记录初始空状态`f[0] = 1`
2. 遍历字符串时，通过异或运算更新当前位掩码
3. 累加当前掩码的历史出现次数并更新计数器

**关键代码片段**：
```cpp
int mask = 0;
map[mask] = 1; // 初始状态
for(char c : s) {
    mask ^= (1 << (c-'0')); // 翻转对应位
    ans += map[mask];       // 累加历史出现次数
    map[mask]++;            // 更新计数器
}
```

---

### 拓展训练
**同类题目推荐**：
1. [P1469 找筷子](https://www.luogu.com.cn/problem/P1469)（异或性质应用）
2. [CF703A Mishka and Interesting sum](https://codeforces.com/problemset/problem/703/A)（区间异或奇偶性）
3. [ABC142E Get Everything](https://atcoder.jp/contests/abc142/tasks/abc142_e)（位掩码动态规划）

---
处理用时：47.37秒
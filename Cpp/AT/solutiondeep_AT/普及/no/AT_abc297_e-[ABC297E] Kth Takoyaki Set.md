# 题目信息

# [ABC297E] Kth Takoyaki Set

## 题目描述

AtCoder 王国出售 $N$ 种类的章鱼烧。第 $i$ 种章鱼烧的价格是 $A_i$ 日元。
高桥一共买了 $1$ 个以上的章鱼烧。这个时候，也允许买多个同样的章鱼烧。
高桥君可以支付的金额中，请从便宜的一方寻求第 $K$ 的金额。但是，如果存在多个支付相同金额的方法，则只计算$ 1 $个。

## 说明/提示

### 约束条件
- $ 1\ \le\ N\ \le\ 10 $
- $ 1\ \le\ K\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
- 所有输入均为整数
### Sample Explanation 1
AtCoder王国出售的4个种类的章鱼烧，分别是$ 20 $日元、$ 25 $日元、$ 30 $日元、$ 100 $日元。高桥君支付的金额可能是，从便宜的一方列举$ 6 $个的话，$ 20 $日元，$ 25 $日元，$ 30 $日元，$ 40 $日元，$ 45 $日元，$ 50 $日元。因此，答案是$ 50 $个日元。请注意总共需要买$ 1 $个以上的章鱼烧。
### Sample Explanation 2
请注意，即使有几种相同金额的购买方法，也不要重复计算。

## 样例 #1

### 输入

```
4 6

20 25 30 100```

### 输出

```
50```

## 样例 #2

### 输入

```
2 10

2 1```

### 输出

```
10```

## 样例 #3

### 输入

```
10 200000

955277671 764071525 871653439 819642859 703677532 515827892 127889502 881462887 330802980 503797872```

### 输出

```
5705443819```

# AI分析结果



# 题目中文翻译

## [ABC297E] 第K小的章鱼烧组合价格

### 题目描述

AtCoder 王国出售 $N$ 种章鱼烧。第 $i$ 种章鱼烧的价格是 $A_i$ 日元。
高桥购买了至少一个章鱼烧（允许购买多个同种章鱼烧）。请找出他可能支付的所有金额中，从低到高排序后的第 $K$ 小的金额。若存在多种方式得到相同金额，只算作一种。

### 输入格式

输入包括：
- 第一行两个整数 $N$ 和 $K$。
- 第二行包含 $N$ 个整数 $A_1, A_2, \dots, A_N$。

### 输出格式

输出第 $K$ 小的金额。

### 样例

#### 样例输入1
```
4 6
20 25 30 100
```

#### 样例输出1
```
50
```

#### 样例解释
前6小的金额依次为：20（单个第一种）、25（单个第二种）、30（单个第三种）、40（两个第一种）、45（第一种+第二种）、50（第一种+第三种或两个第二种）。

---

**算法分类**：广度优先搜索 BFS（优先队列优化）

---

### 题解分析与结论

#### 核心思路
所有题解均采用类似贪心+BFS的策略：
1. 使用有序结构（`set`/优先队列）维护候选金额。
2. 每次取出当前最小金额，生成其与所有 $A_i$ 的组合值。
3. 利用数据结构自动去重，确保每个金额只计算一次。
4. 重复操作直到找到第 $K$ 小的值。

#### 解决难点
- **避免重复计算**：通过 `set` 或哈希表去重。
- **高效维护候选值**：优先队列或 `set` 的插入/删除操作复杂度为 $O(\log n)$，确保算法效率。
- **正确生成路径**：每次扩展当前最小值，保证生成的金额按顺序覆盖所有可能。

---

### 精选题解

#### 1. 作者：Butterfly_qwq（★★★★★）
**关键亮点**：
- 代码极简，逻辑清晰。
- 初始插入0作为生成起点，通过逐次扩展保证正确性。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[11];
set<int> s;
signed main() {
    int n, k;
    cin >> n >> k;
    for(int i=0; i<n; i++) cin >> a[i];
    s.insert(0);
    for(int i=0; i<k; i++) {
        int w = *s.begin();
        s.erase(w);
        for(int j=0; j<n; j++) s.insert(w + a[j]);
    }
    cout << *s.begin();
    return 0;
}
```

#### 2. 作者：封禁用户（★★★★★）
**关键亮点**：
- 通过循环 $K$ 次直接生成第 $K$ 小值。
- 初始插入0并逐步删除，保证候选值合法。
```cpp
set<int> s;
signed main() {
    cin >> n >> k;
    for(int i=1; i<=n; i++) cin >> a[i];
    s.insert(0);
    for(int kkk=1; kkk<=k; kkk++) {
        int current = *s.begin();
        s.erase(current);
        for(int i=1; i<=n; i++) s.insert(current + a[i]);
    }
    cout << *s.begin();
}
```

#### 3. 作者：2huk（★★★★★）
**关键亮点**：
- 初始直接插入所有 $A_i$ 的值，直观处理合法候选。
- 循环 $K-1$ 次后直接取最小值。
```cpp
set<ll> s;
int main() {
    cin >> n >> k;
    for(int i=1; i<=n; i++) {
        cin >> a[i];
        s.insert(a[i]);
    }
    for(int i=1; i<k; i++) {
        ll min_val = *s.begin();
        s.erase(min_val);
        for(int j=1; j<=n; j++) s.insert(min_val + a[j]);
    }
    cout << *s.begin();
}
```

---

### 关键技巧总结
- **数据结构选择**：优先队列或 `set` 自动维护有序且去重的候选值。
- **生成策略**：每次扩展当前最小值，确保按顺序生成所有可能值。
- **初始值处理**：灵活选择初始插入0或所有 $A_i$，需确保生成的金额合法（≥1个商品）。

---

### 拓展与举一反三
- **类似问题**：丑数问题（生成仅由特定质因数构成的数的第K小值）。
- **优化变体**：多路归并时维护指针减少重复计算。

---

### 推荐练习题
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列基础）
2. [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)（多路生成最小值）
3. [UVA 443 Humble Numbers](https://www.luogu.com.cn/problem/UVA443)（经典丑数问题）

---
处理用时：279.62秒
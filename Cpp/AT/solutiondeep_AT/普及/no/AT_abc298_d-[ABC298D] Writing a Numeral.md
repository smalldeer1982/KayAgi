# 题目信息

# [ABC298D] Writing a Numeral

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc298/tasks/abc298_d

文字列 $ S $ があり、初め $ S= $ `1` です。  
以下の形式のクエリが $ Q $ 個与えられるので順に処理してください。

- `1 x` : $ S $ の末尾に数字 $ x $ を追加する
- `2` : $ S $ の先頭の数字を削除する
- `3` : $ S $ を十進数表記の数とみなした値を $ 998244353 $ で割った余りを出力する

## 说明/提示

### 制約

- $ 1\ \leq\ Q\ \leq\ 6\ \times\ 10^5 $
- $ 1 $ 番目の形式のクエリについて、$ x\ \in\ \{1,2,3,4,5,6,7,8,9\} $
- $ 2 $ 番目の形式のクエリは $ S $ が $ 2 $ 文字以上の時にのみ与えられる
- $ 3 $ 番目の形式のクエリが $ 1 $ 個以上存在する

### Sample Explanation 1

$ 1 $ 番目のクエリにおいて、$ S $ は `1` なので ( $ 1 $ を $ 998244353 $ で割った余りに等しい) $ 1 $ を出力します。 $ 2 $ 番目のクエリにおいて、$ S $ は `12` になります。 $ 3 $ 番目のクエリにおいて、$ S $ は `12` なので ( $ 12 $ を $ 998244353 $ で割った余りに等しい) $ 12 $ を出力します。

### Sample Explanation 3

出力されるべき値は $ 998244353 $ で割った余りであることに注意してください。

## 样例 #1

### 输入

```
3
3
1 2
3```

### 输出

```
1
12```

## 样例 #2

### 输入

```
3
1 5
2
3```

### 输出

```
5```

## 样例 #3

### 输入

```
11
1 9
1 9
1 8
1 2
1 4
1 4
1 3
1 5
1 3
2
3```

### 输出

```
0```

# AI分析结果



### 题目重写
题目名称：[ABC298D] Writing a Numeral

**题目描述**  
有一个字符串 $S$，初始为 `1`。需要处理 $Q$ 个操作：  
1. `1 x`：在 $S$ 末尾添加数字 $x$；  
2. `2`：删除 $S$ 的第一个字符（保证操作合法）；  
3. `3`：输出 $S$ 视为十进制数时的值对 $998244353$ 取模的结果。  

**输入格式**  
第一行为 $Q$，随后 $Q$ 行每行为操作。  

**输出格式**  
对每个操作 3 输出结果。  

**数据范围**  
$1 \leq Q \leq 6 \times 10^5$，$x$ 为非零数字。  

**样例解释**  
见原题描述。  

---

### 算法分类  
队列、数学（模运算）  

---

### 题解分析与结论  

#### 核心思路  
1. **队列维护数字序列**：利用队列的先进先出特性，快速处理头部删除和尾部添加操作。  
2. **动态维护模值**：维护一个变量 `ans` 表示当前数字的模值。  
   - **添加操作**：`ans = (ans * 10 + x) % MOD`。  
   - **删除操作**：需减去头部数字的贡献（即 `头部数字 * 10^(当前长度-1) % MOD`），预处理 10 的幂次模值数组以优化计算。  
3. **处理负数模**：减法后通过 `(ans + MOD) % MOD` 确保结果为非负。  

#### 最优思路  
- **预处理 10 的幂次模值数组**：避免重复计算，时间复杂度优化至 $O(1)$。  
- **队列与数学结合**：队列维护数字顺序，数学处理模运算的传递性。  

---

### 精选题解  

#### 题解1：CuteChat（5星）  
**亮点**  
- 预处理 10 的幂次模值数组，确保删除操作高效。  
- 处理负数取模的自定义函数，保证结果正确性。  

**核心代码**  
```cpp
int q, st[600005], front, rear;
long long p[600005], ans = 1, mod = 998244353;

// 预处理10的幂次模值
p[0] = 1;
for (int i = 1; i <= 600004; ++i) p[i] = (p[i-1] * 10) % mod;

// 操作处理
if (opt == 1) {
    ans = (ans * 10 + x) % mod;
    st[++rear] = x;
} else if (opt == 2) {
    long long x = st[front++];
    ans = (ans - x * p[rear - front] % mod + mod) % mod;
} else {
    printf("%lld\n", ans);
}
```

#### 题解2：Coffee_zzz（4星）  
**亮点**  
- 使用双端队列直接维护数字，代码简洁。  
- 通过位运算快速计算幂次，但依赖预处理更优。  

**核心代码**  
```cpp
deque<int> Q;
LL ans = 1;
LL ten[N]; // 预处理数组

// 操作处理
if (op == 1) {
    Q.push_back(x);
    ans = (ans * 10 + x) % MOD;
} else if (op == 2) {
    ans = (ans - Q.front() * ten[Q.size()-1] % MOD + MOD) % MOD;
    Q.pop_front();
}
```

---

### 拓展与练习  
**同类题目推荐**  
1. [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540)（队列维护缓存）  
2. [P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)（模运算与表达式解析）  
3. [P2058 海港](https://www.luogu.com.cn/problem/P2058)（队列维护时间窗口）  

**调试心得**  
- **预处理重要性**：在多次需要幂次计算的场景下，预处理数组显著优化时间效率。  
- **负数取模**：需显式处理减法后的负数情况，避免直接取模出错。

---
处理用时：56.76秒
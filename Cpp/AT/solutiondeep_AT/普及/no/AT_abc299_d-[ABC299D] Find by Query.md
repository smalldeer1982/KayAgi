# 题目信息

# [ABC299D] Find by Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc299/tasks/abc299_d

この問題は **インタラクティブな問題**（あなたが作成したプログラムとジャッジプログラムが標準入出力を介して対話を行う形式の問題）です。

ジャッジが $ 0 $ と $ 1 $ のみからなる長さ $ N $ の文字列 $ S\ =\ S_1S_2\ldots\ S_N $ を持っています。 文字列 $ S $ は、$ S_1\ =\ 0 $ および $ S_N\ =\ 1 $ を満たします。

あなたには $ S $ の長さ $ N $ が与えられますが、$ S $ 自体は与えられません。 その代わり、あなたはジャッジに対して以下の質問を $ 20 $ 回まで行うことができます。

- $ 1\ \leq\ i\ \leq\ N $ を満たす整数 $ i $ を選び、$ S_i $ の値を尋ねる。
 
$ 1\ \leq\ p\ \leq\ N-1 $ かつ $ S_p\ \neq\ S_{p+1} $ を満たす整数 $ p $ を $ 1 $ 個出力してください。  
 なお、本問題の条件下でそのような整数 $ p $ が必ず存在することが示せます。

### Input &amp; Output Format

最初に、文字列 $ S $ の長さ $ N $ を標準入力から受け取ってください。

> $ N $

次に、あなたはジャッジに対して問題文中の質問を $ 20 $ 回まで繰り返すことができます。

質問は、以下の形式で標準出力に出力してください。 ここで、$ i $ は $ 1\ \leq\ i\ \leq\ N $ を満たす整数でなければなりません。

> ? $ i $

これに対する応答として、$ S_i $ の値が次の形式で標準入力から与えられます。

> $ S_i $

ここで、$ S_i $ は $ 0 $ または $ 1 $ です。

問題文中の条件を満たす整数 $ p $ を見つけたら、解答を以下の形式で出力してください。 その後、ただちにプログラムを終了してください。

> ! $ p $

答えが複数ある場合、どれを出力しても正解とみなされます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
 
### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で不正な出力を行った、あるいはプログラムが途中で終了した場合のジャッジ結果は不定です。**
- 解答を出力したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- 文字列 $ S $ はあなたとジャッジの対話の開始時に固定され、あなたが行った質問などに応じて変更されることはありません。
 
### 入出力例

以下は、$ N\ =\ 7,\ S\ =\ 0010011 $ の場合の入出力例です。

    入力 出力 説明     `7`  $ N $ が与えられます。    `? 1` $ S_1 $ が何かをジャッジに質問します。     `0`  質問に対する答えとして $ S_1\ =\ 0 $ がジャッジから返されます。    `? 6` $ S_6 $ が何かをジャッジに質問します。     `1`  質問に対する答えとして $ S_6\ =\ 1 $ がジャッジから返されます。    `? 5` $ S_5 $ が何かをジャッジに質問します。     `0`  質問に対する答えとして $ S_5\ =\ 0 $ がジャッジから返されます。    `! 5` 問題文中の条件を満たす整数 $ p $ として、$ p\ =\ 5 $ を解答します。    解答した $ p\ =\ 5 $ について、$ 1\ \leq\ p\ \leq\ N-1 $ かつ $ S_p\ \neq\ S_{p+1} $ が成り立ちます。 よって、この後ただちにプログラムを終了することで、正解と判定されます。

# AI分析结果



**题目重述**  
[ABC299D] Find by Query  

## 题目描述  
这是一道交互题。评测系统拥有一个由0和1组成的长度为N的字符串S，满足S₁=0且S_N=1。你的任务是通过最多20次询问，找到一个位置p（1≤p<N），使得S_p≠S_{p+1}。每次询问可指定一个位置i，评测系统返回S_i的值。  

### 输入输出格式  
- 输入N后，通过输出"? i"进行询问，最后输出"! p"提交答案。  
- 每次输出后需刷新缓冲区。  

### 数据范围  
2 ≤ N ≤ 2×10⁵  

---

**算法分类**  
二分  

---

### 题解分析与结论  
所有题解均采用二分法，核心思路是维护左右边界[l, r]始终满足S_l=0、S_r=1。每次询问中点mid，根据结果调整边界：  
- 若S_mid=0，则右移左边界至mid（左侧保持0）  
- 若S_mid=1，则左移右边界至mid（右侧保持1）  
当区间长度缩至1时，l即为所求的p。  

---

### 精选题解  
1. **六楼溜刘（5星）**  
   **关键亮点**：  
   - 代码简洁，边界条件处理清晰（`while(ll < rr-1)`确保最终区间相邻）  
   - 维护左右指针的0/1属性逻辑严密  
   **代码核心**：  
   ```cpp
   int ll=1, rr=n;
   while(ll < rr-1) {
       int mid = (ll+rr)/2;
       // 询问mid并更新边界
       if (res==0) ll = mid;
       else rr = mid;
   }
   cout << "! " << ll;
   ```

2. **2huk（4星）**  
   **关键亮点**：  
   - 循环条件`l+2 <= r`直观体现区间长度控制  
   - 注释明确解释维护指针属性的必要性  
   **代码核心**：  
   ```cpp
   while (l + 2 <= r) {
       mid = l + r >> 1;
       if (x == 0) l = mid;
       else r = mid;
   }
   ```

3. **hellolin（4星）**  
   **亮点**：  
   - 反向二分思路，最终输出调整后的r  
   - 通过极端数据验证算法正确性  
   **代码核心**：  
   ```cpp
   while(l <= r) {
       mid = (l+r)/2;
       if (w == 0) l = mid+1;
       else r = mid-1;
   }
   cout << "! " << r; // 注意最终输出r而非l
   ```

---

### 最优思路总结  
1. **二分维护0/1边界**：始终保证左边界为0、右边界为1，缩小范围时必然保留交界点。  
2. **循环终止条件**：当区间长度为2时（l+1 == r），直接输出l。  
3. **输出处理**：最终答案一定是调整后的左边界（或相邻右边界，需根据二分方向确定）。  

---

### 拓展与心得  
- **同类问题**：类似需要利用单调性或边界性质的交互题，如CF1797C Li Hua and Chess（二维位置猜测）  
- **调试技巧**：本地测试时可预先构造S序列模拟交互过程，验证二分路径。  

---

### 推荐练习题  
1. [P1768 天路](https://www.luogu.com.cn/problem/P1768)（二分+SPFA判负环）  
2. [P1257 平面上的最接近点对](https://www.luogu.com.cn/problem/P1257)（分治经典问题）  
3. [CF1797C Li Hua and Chess](https://codeforces.com/contest/1797/problem/C)（交互题+极值分析）

---
处理用时：45.94秒
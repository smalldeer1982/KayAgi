# 题目信息

# [ABC299E] Nearest Black Vertex

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc299/tasks/abc299_e

$ N $ 個の頂点と $ M $ 本の辺からなる、単純（自己ループおよび多重辺を含まない）かつ連結な無向グラフが与えられます。  
$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結ぶ無向辺です。

各頂点を白または黒で塗る方法であって、下記の $ 2 $ つの条件をともに満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- $ 1 $ 個以上の頂点が黒で塗られている。
- すべての $ i\ =\ 1,\ 2,\ \ldots,\ K $ について、下記の条件が成り立つ。
  - 頂点 $ p_i $ と「黒で塗られた頂点のうち頂点 $ p_i $ からの距離が最小であるもの」の距離がちょうど $ d_i $ である。

ここで、頂点 $ u $ と頂点 $ v $ の距離は、$ u $ と $ v $ を結ぶパスの辺の本数としてあり得る最小値として定義されます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2000 $
- $ N-1\ \leq\ M\ \leq\ \min\lbrace\ N(N-1)/2,\ 2000\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- $ 0\ \leq\ K\ \leq\ N $
- $ 1\ \leq\ p_1\ \lt\ p_2\ \lt\ \cdots\ \lt\ p_K\ \leq\ N $
- $ 0\ \leq\ d_i\ \leq\ N $
- 与えられるグラフは単純かつ連結
- 入力はすべて整数

### Sample Explanation 1

例えば、頂点 $ 1,\ 3 $ を黒に、頂点 $ 2,\ 4,\ 5 $ を白に塗るという方法が、問題文中の条件を満たします。 実際、$ i\ =\ 1,\ 2,\ 3,\ 4,\ 5 $ について、頂点 $ i $ と「黒で塗られた頂点のうち頂点 $ i $ からの距離が最小であるもの」の距離を $ A_i $ で表すと、 $ (A_1,\ A_2,\ A_3,\ A_4,\ A_5)\ =\ (0,\ 1,\ 0,\ 1,\ 2) $ であり、特に、$ A_1\ =\ 0,\ A_5\ =\ 2 $ が成り立ちます。

### Sample Explanation 2

問題文中の条件を満たすように各頂点を白または黒で塗る方法が存在しないため、`No` を出力します。

## 样例 #1

### 输入

```
5 5
1 2
2 3
3 1
3 4
4 5
2
1 0
5 2```

### 输出

```
Yes
10100```

## 样例 #2

### 输入

```
5 5
1 2
2 3
3 1
3 4
4 5
5
1 1
2 1
3 1
4 1
5 1```

### 输出

```
No```

## 样例 #3

### 输入

```
1 0
0```

### 输出

```
Yes
1```

# AI分析结果



# [ABC299E] Nearest Black Vertex 的题解

**题目描述**  
给定一个包含 $N$ 个顶点和 $M$ 条边的简单连通无向图。要求将顶点染成黑或白，满足以下条件：  
1. 至少有一个黑顶点。  
2. 对于每个给定的 $p_i$，距离它最近的黑顶点的距离恰好为 $d_i$（顶点间距离定义为边数最少的路径长度）。  
判断是否存在可行方案，若存在输出任意一种。  

**算法分类**  
图论（BFS/最短路）  

---

### 题解分析与结论

**核心思路**  
1. **预处理所有顶点对的最短距离**：通过 BFS 计算每对顶点的最短路径。  
2. **排除非法点**：对每个限制条件 $p_i, d_i$，标记所有距离 $p_i$ 小于 $d_i$ 的点必须为白色。  
3. **验证解**：确保每个 $p_i$ 存在至少一个未被排除的点满足距离恰好为 $d_i$。  

**关键技巧**  
- 预处理所有顶点对的 BFS 计算（时间复杂度 $O(N^2)$）。  
- 逆向思维：先标记必须为白的点，再检查剩余点是否能满足条件。  
- **条件顺序处理**：某些解法需处理条件顺序问题（如两次遍历或随机化）。  

---

### 精选题解

#### 题解1：Accelessar（4星）
**亮点**  
- 处理条件顺序问题，通过两次遍历或随机化确保正确性。  
- 代码逻辑清晰，包含对 Hack 数据的处理。  

**关键代码**  
```cpp
void dijkstra(int s) {
    priority_queue<pii> pq;
    memset(dis, 0x3f, sizeof dis);
    pq.emplace(dis[s] = 0, s);
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (dis[u] != -d) continue;
        for (int v : e[u]) if (dis[v] > dis[u] + 1) {
            pq.emplace(-(dis[v] = dis[u] + 1), v);
        }
    }
}
// 主逻辑：两次遍历条件
for (auto [u, v] : p) {
    dijkstra(u);
    bool fl1 = true;
    for (int i = 1; i <= n; i++) {
        bk[i] |= (dis[i] < v);
        fl1 &= (dis[i] != v || bk[i]);
    }
    if (fl1) return puts("No"), 0;
}
```

#### 题解2：Neil_Qian（4星）
**亮点**  
- 简洁高效，直接标记合法点并验证。  
- 代码结构清晰，适合快速实现。  

**核心思路**  
```cpp
for (int i = 1; i <= k; i++) {
    // 标记所有距离 <d_i 的点为白
    for (int j = 1; j <= n; j++) {
        if (dis[p[i]][j] < d[i]) boom[j] = true;
    }
}
// 验证每个 p_i 是否存在合法黑点
for (int i = 1; i <= k; i++) {
    bool flag = false;
    for (int j = 1; j <= n; j++) {
        if (dis[p[i]][j] == d[i] && !boom[j]) flag = true;
    }
    if (!flag) return puts("No"), 0;
}
```

#### 题解3：yujinning（3.5星）
**亮点**  
- 明确预处理距离并验证，代码可读性强。  
- 未显式处理条件顺序，但在多数情况下正确。  

**代码片段**  
```cpp
void bfs(int num) {
    // BFS 计算 num 到各点的距离
}
// 主逻辑
for (int i = 1; i <= k; i++) {
    for (int j = 1; j <= n; j++) {
        if (dis[p[i]][j] < d[i]) okk[j] = 0;
    }
}
// 检查每个条件是否满足
```

---

### 最优思路总结
1. **预处理全源最短路径**：使用 BFS 计算每对顶点的最短距离。  
2. **逆向标记排除**：将距离限制下不满足的点标记为白。  
3. **二次验证**：确保每个限制条件存在至少一个合法黑点。  

**易错点**  
- 条件处理顺序可能影响结果，需确保所有条件独立处理后的全局正确性。  
- 特判 $K=0$ 时必须至少有一个黑点。  

---

### 推荐类似题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  
2. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)  
3. [P1606 [USACO07FEB] Lilypad Pond G](https://www.luogu.com.cn/problem/P1606)  

**个人心得**  
- **条件顺序陷阱**：Accelessar 提到在线处理可能导致条件相互影响，需多次处理或随机化顺序。  
- **逆向思维**：先排除非法点再构造解，避免直接处理复杂约束。

---
处理用时：55.27秒
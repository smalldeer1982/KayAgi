# 题目信息

# [ABC302E] Isolation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc302/tasks/abc302_e

最初 $ N $ 頂点 $ 0 $ 辺の無向グラフがあり、各頂点には $ 1 $ から $ N $ まで番号がついています。  
 $ Q $ 個のクエリが与えられるので、順に処理し、各クエリの後における「他のどの頂点とも辺で結ばれていない頂点」の数を出力してください。

$ i $ 個目のクエリは $ \mathrm{query}_i $ であり、各クエリは次の $ 2 $ 種類いずれかです。

- `1 u v`: 頂点 $ u $ と頂点 $ v $ を辺で結ぶ。このクエリが与えられる直前の時点で、頂点 $ u $ と頂点 $ v $ は辺で結ばれていない事が保証される。
- `2 v` : 頂点 $ v $ と他の頂点を結ぶ辺をすべて削除する。（頂点 $ v $ 自体は削除しない。）

## 说明/提示

### 制約

- $ 2\ \leq\ N\leq\ 3\times\ 10^5 $
- $ 1\ \leq\ Q\leq\ 3\times\ 10^5 $
- $ 1 $ 番目の種類のクエリにおいて、$ 1\leq\ u,v\leq\ N $, $ u\neq\ v $
- $ 2 $ 番目の種類のクエリにおいて、$ 1\leq\ v\leq\ N $
- $ 1 $ 番目の種類のクエリの直前の時点で、そのクエリの $ u,v $ について頂点 $ u $ と頂点 $ v $ は辺で結ばれていない。
- 入力はすべて整数
 
### Sample Explanation 1

$ 1 $ 個目のクエリの後で、頂点 $ 1 $ と頂点 $ 2 $ は互いに結ばれており、頂点 $ 3 $ のみが他のどの頂点とも辺で結ばれていません。 よって、$ 1 $ 行目には $ 1 $ を出力します。 また、$ 3 $ 個目のクエリの後でどの相異なる $ 2 $ 頂点の間も辺で結ばれていますが、$ 4 $ 個目のクエリによって、 頂点 $ 1 $ と他の頂点を結ぶ辺、すなわち 頂点 $ 1 $ と頂点 $ 2 $ を結ぶ辺および頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺が削除されます。 この結果として、頂点 $ 2 $ と頂点 $ 3 $ は互いに結ばれているが、頂点 $ 1 $ は他のどの頂点とも辺で結ばれていない状態となります。 よって、$ 3 $ 行目には $ 0 $ を、$ 4 $ 行目には $ 1 $ を出力します。

### Sample Explanation 2

$ 2 $ 番目の種類のクエリを行う直前の時点で、すでにその頂点と他の頂点を結ぶ辺が $ 1 $ 本も存在しないこともあります。

## 样例 #1

### 输入

```
3 7

1 1 2

1 1 3

1 2 3

2 1

1 1 2

2 2

1 1 2```

### 输出

```
1

0

0

1

0

3

1```

## 样例 #2

### 输入

```
2 1

2 1```

### 输出

```
2```

# AI分析结果



# [ABC302E] Isolation

## 题目描述

最初有 $N$ 个顶点、0 条边的无向图，顶点编号为 $1$ 到 $N$。处理 $Q$ 个查询，每个查询后输出「与其他顶点均无边相连的顶点」的数量。

查询类型：
- `1 u v`：在顶点 $u$ 和 $v` 间添加边（保证添加前无边）
- `2 v`：删除顶点 $v` 的所有边

**算法分类**：模拟、图论

---

## 题解综合分析

所有题解均采用动态维护邻接关系+孤立点计数的思路。主要差异在于数据结构的选用（链式前向星 vs set）和状态维护方式。最优解法为使用 `set` 维护邻接表，时间复杂度 $O(Q \log N)$。

### 高分题解推荐

#### 1. 作者：Xiphi（5星）
**关键亮点**：
- 使用 `set` 实现简洁的邻接表
- 通过 `size()` 直接判断孤立状态
- 巧妙利用容器清空后的状态变化维护答案
```cpp
set<int> Adj[300005];
int ans = n;

// 添加边处理
ans -= (Adj[u].size() == 1) + (Adj[v].size() == 1);
Adj[u].insert(v); 
Adj[v].insert(u);

// 删除边处理
for(auto it=Adj[u].begin(); it!=Adj[u].end(); ){
    Adj[*it].erase(u);
    if(Adj[*it].empty()) ans++;
}
if(!Adj[u].empty()) ans++;
Adj[u].clear();
```

#### 2. 作者：MYiFR（5星）
**核心技巧**：
- 直接通过 `set` 的空状态判断孤立点
- 完全省略度数数组，减少状态维护
```cpp
set<int> e[N];
ans -= e[u].empty() + e[v].empty();
e[u].insert(v); 
e[v].insert(u);

for(int to:e[a]){
    e[to].erase(a);
    ans += e[to].empty();
}
ans += !e[a].empty();
e[a].clear();
```

#### 3. 作者：2huk（4星）
**实现亮点**：
- 使用迭代器遍历删除邻接关系
- 显式维护度数数组实现双保险
```cpp
set<int> g[N];
ans -= (g[u].empty() + g[v].empty());
g[u].insert(v); 
g[v].insert(u);

for(int x : g[u]){
    g[x].erase(u);
    ans += g[x].empty();
}
ans += !g[u].empty();
g[u].clear();
```

---

## 关键思路总结

1. **数据结构选择**：使用 `set` 维护邻接表，天然支持快速插入、删除和存在性判断
2. **状态同步机制**：通过 `size()/empty()` 直接判断顶点孤立状态，避免维护额外数组
3. **批量删除优化**：处理删除操作时遍历邻接点并同步反向删除，保证时间复杂度线性
4. **答案动态维护**：在每次操作中即时更新孤立点计数器，避免全图扫描

**易错点**：
- 删除操作后忘记清空邻接表可能导致后续误判
- 未处理初始全孤立状态的特殊情况
- 双向边删除时未同步反向节点状态

---

## 同类题目推荐
1. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916) - 逆向思维处理图遍历
2. [P3388 割点](https://www.luogu.com.cn/problem/P3388) - 图的动态维护应用
3. [P5636 边双连通分量](https://www.luogu.com.cn/problem/P5636) - 动态图的高级维护技巧

---
处理用时：54.31秒
# 题目信息

# [ABC304E] Good Graph

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc304/tasks/abc304_e

$ N $ 頂点 $ M $ 辺の無向グラフ $ G $ が与えられます。 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結ぶ無向辺です。

$ N $ 頂点のグラフは、すべての $ i\ =\ 1,\ 2,\ \ldots,\ K $ について下記の条件が成り立つとき、**良いグラフ**と呼ばれます。

- $ G $ 上で頂点 $ x_i $ と頂点 $ y_i $ を結ぶパスが存在しない。
 
与えられるグラフ $ G $ は良いグラフです。

$ Q $ 個の独立な質問が与えられるので、それらすべてに答えてください。 $ i\ =\ 1,\ 2,\ \ldots,\ Q $ について、$ i $ 番目の質問は

- 入力で与えられたグラフ $ G $ に頂点 $ p_i $ と頂点 $ q_i $ を結ぶ無向辺を $ 1 $ 本追加して得られるグラフ $ G^{(i)} $ は良いグラフですか？
 
という質問です。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- $ 1\ \leq\ K\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ x_i,\ y_i\ \leq\ N $
- $ x_i\ \neq\ y_i $
- $ i\ \neq\ j\ \implies\ \lbrace\ x_i,\ y_i\ \rbrace\ \neq\ \lbrace\ x_j,\ y_j\ \rbrace $
- すべての $ i\ =\ 1,\ 2,\ \ldots,\ K $ について次が成り立つ：頂点 $ x_i $ と頂点 $ y_i $ を結ぶパスは存在しない。
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ p_i,\ q_i\ \leq\ N $
- $ p_i\ \neq\ q_i $
- 入力はすべて整数
 
### Sample Explanation 1

\- $ 1 $ 番目の質問に関して、グラフ $ G^{(1)} $ は良いグラフではありません。なぜなら、頂点 $ x_1\ =\ 1 $ と頂点 $ y_1\ =\ 5 $ を結ぶパス $ 1\ \rightarrow\ 2\ \rightarrow\ 5 $ を持つからです。よって、`No` と出力します。 - $ 2 $ 番目の質問に関して、グラフ $ G^{(2)} $ は良いグラフではありません。なぜなら、頂点 $ x_2\ =\ 2 $ と頂点 $ y_2\ =\ 6 $ を結ぶパス $ 2\ \rightarrow\ 6 $ を持つからです。よって、`No` と出力します。 - $ 3 $ 番目の質問に関して、グラフ $ G^{(3)} $ は良いグラフです。よって、`Yes` と出力します。 - $ 4 $ 番目の質問に関して、グラフ $ G^{(4)} $ は良いグラフです。よって、`Yes` と出力します。 この入力例のように、与えられるグラフ $ G $ が自己ループや多重辺を持つ場合があることに注意してください。

## 样例 #1

### 输入

```
6 6

1 2

2 3

2 3

3 1

5 4

5 5

3

1 5

2 6

4 3

4

2 5

2 6

5 6

5 4```

### 输出

```
No

No

Yes

Yes```

# AI分析结果



# [ABC304E] Good Graph

## 题目描述

给定包含 $N$ 个顶点和 $M$ 条边的无向图 $G$。对于 $K$ 对顶点 $(x_i,y_i)$，保证它们在原图中不连通。现进行 $Q$ 次独立询问，每次询问添加边 $(p_i,q_i)$ 后，是否仍满足所有 $K$ 对顶点之间不连通。

## 标签
**并查集**

---

## 题解综合分析

所有题解均采用并查集维护连通性，核心思路为：
1. **并查集预处理**：建立原始图的连通关系
2. **约束条件存储**：将每对约束条件的连通块根节点存入哈希结构
3. **查询处理**：检查新边连接的根节点是否在禁止列表中

关键技巧：
- 通过路径压缩+按秩合并优化并查集效率
- 使用 `map<pair<int,int>>` 或 `set` 存储禁止连接的连通块对
- 预处理时统一根节点顺序（如小根在前）避免重复存储

---

## 精选题解（评分≥4⭐）

### 题解1：cjh20090318（5⭐）
**核心亮点**：
- 代码简洁高效，双端存储约束条件
- 利用STL map直接判断连通块对
```cpp
std::map<std::pair<int,int>,bool> M;
// 存储约束条件
M[mp(find(u),find(v))] = M[mp(find(v),find(u))] = 1;
// 查询处理
puts(M.find(mp(u_root,v_root))!=M.end() ? "No":"Yes");
```

### 题解2：DengDuck（4⭐）
**创新点**：
- 使用数值哈希（fx*N+fy）代替pair存储
- 利用set的O(1)查询特性
```cpp
set<LL> s;
// 存储约束条件 
s.insert(fx*N + fy); 
// 查询处理
if(s.count(fx*N+fy)) puts("No");
```

### 题解3：封禁用户（4⭐）
**优化细节**：
- 显式处理连通块顺序避免冗余
- 使用二维map实现快速查询
```cpp
map<int,map<int,int> > mp;
// 存储时统一顺序
if(fx > fy) swap(fx,fy);
mp[fx][fy] = 1;
// 查询时自动处理顺序
```

---

## 关键思路总结
1. **连通块标记法**：将约束条件转换为连通块级别的标记
2. **哈希加速查询**：使用高效数据结构（map/set）实现O(1)或O(log n)查询
3. **对称处理**：存储时同时记录(u,v)和(v,u)或预处理有序对

---

## 类似题目推荐
1. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525) - 并查集处理二分图性质
2. [P2024 食物链](https://www.luogu.com.cn/problem/P2024) - 带权并查集维护关系
3. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197) - 逆向并查集处理动态删边

---
处理用时：57.52秒
# 题目信息

# [ABC305E] Art Gallery on Graph

## 题目描述

### 题面

给定一张 $N$ 个点（编号为 $1 \sim N$），$M$ 条边的无向图，保证无重边无自环。现在有 $K$ 个被标记的点，其中第 $i$ 个被标记的点的编号为 $p_i$，任何从 $p_i$ 出发经过不超过 $h_i$ 条边能到达的点都会被染色（包括 $p_i$ 自身）。你需要求出这张图最终有哪些点被染色。


接下来 $M$ 行，每行两个正整数 $a_i,b_i$，表示编号为 $a_i,b_i$ 的点连有一条无向边。

## 说明/提示

$1 \le N \le 2 \times 10^5$，$0 \le M \le 2 \times 10^5$，$1 \le K,a_i,b_i,p_i,h_i \le N$，$p_i$ 互不相同。

保证给定的图无重边，无自环。

## 样例 #1

### 输入

```
5 5 2

1 2

2 3

2 4

3 5

1 5

1 1

5 2```

### 输出

```
4

1 2 3 5```

## 样例 #2

### 输入

```
3 0 1

2 3```

### 输出

```
1

2```

## 样例 #3

### 输入

```
10 10 2

2 1

5 1

6 1

2 4

2 5

2 10

8 5

8 6

9 6

7 9

3 4

8 2```

### 输出

```
7

1 2 3 5 6 8 9```

# AI分析结果



# 中文题面重写

## [ABC305E] 图上的美术馆

### 题目描述

给定一个包含 $N$ 个点（编号为 $1 \sim N$）和 $M$ 条边的无向图，保证无重边无自环。现有 $K$ 个特殊标记点，其中第 $i$ 个标记点位于 $p_i$ 且能覆盖从该点出发经过最多 $h_i$ 条边可达的所有点（包括自身）。求最终被覆盖的所有点。

### 输入格式

- 第一行：$N, M, K$
- 接下来 $M$ 行：每行两个整数表示边的两个端点
- 接下来 $K$ 行：每行两个整数 $p_i, h_i$，表示标记点的位置和覆盖范围

### 输出格式

- 第一行：被覆盖点的数量
- 第二行：升序排列的被覆盖点编号

---

**算法分类**：广度优先搜索 BFS

---

## 题解对比分析

### 核心思路

所有题解均采用 **优先队列优化的 BFS**（类似 Dijkstra 算法），维护每个节点的最大剩余覆盖步数。每次从队列中取出剩余步数最大的节点进行扩散，确保每个节点只被处理一次，时间复杂度 $O(N + M)$。

### 关键优化点

1. **优先队列维护最大剩余步数**：每次处理当前剩余步数最大的节点，保证后续扩散时尽可能覆盖更多节点。
2. **状态剪枝**：若某节点已被处理过（即其剩余步数已达到可能的最大值），则跳过后续更新。

---

## 精选题解（评分≥4⭐）

### 题解1：MoyunAllgorithm（4.5⭐）
**亮点**：
- 代码简洁清晰，直接使用 STL 优先队列实现。
- 正确处理了重复节点的剪枝逻辑。
- 完整处理输入输出，适合快速理解算法流程。

```cpp
priority_queue<PII> heap; // 存储(剩余步数, 节点)
void bfs() {
    while (heap.size()) {
        auto [step, u] = heap.top(); heap.pop();
        if (vis[u]) continue; // 已找到最优解
        vis[u] = 1;
        if (step == 0) continue;
        for (auto v : gra[u]) {
            if (!vis[v]) heap.push({step - 1, v});
        }
    }
}
```

### 题解2：Coffee_zzz（4⭐）
**亮点**：
- 使用链式前向星存图，适合处理大规模数据。
- 详细注释说明关键结论，便于理解算法正确性。

```cpp
priority_queue<pair<int, int>> q;
while (!q.empty()) {
    int u = q.top().second, g = q.top().first; q.pop();
    if (vis[u]) continue;
    vis[u] = true;
    if (g == 0) continue;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        q.push({g - 1, v});
    }
}
```

---

## 关键技巧总结

1. **Dijkstra 思想的变种**：将覆盖步数视为"优先级"，用优先队列确保每次处理最优状态。
2. **剪枝条件设计**：`if (vis[u]) continue` 保证每个节点只处理一次，时间复杂度严格线性。
3. **反向维护步数**：记录剩余步数而非已用步数，便于优先队列排序。

---

## 类似题目推荐

1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144) - 多源 BFS 应用
2. [P1339 [USACO09OCT]Heat Wave G](https://www.luogu.com.cn/problem/P1339) - 带权图最短路径
3. [P1948 [USACO08JAN]Telephone Lines S](https://www.luogu.com.cn/problem/P1948) - 分层图最短路思想

---

## 调试经验摘录

来自 **Elairin176** 题解：
> "赛时因为将 `h_i - dis < 0` 误写为 `h_i - dis <= 0` 导致错误。关键点在于剩余步数为 0 时仍应处理当前节点本身。"

**总结**：边界条件需特别注意，剩余步数为 0 时当前节点仍应被标记为覆盖。

---
处理用时：53.78秒
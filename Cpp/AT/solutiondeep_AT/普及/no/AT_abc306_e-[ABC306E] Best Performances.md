# 题目信息

# [ABC306E] Best Performances

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc306/tasks/abc306_e

長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ があり、最初全ての項が $ 0 $ です。  
 入力で与えられる整数 $ K $ を用いて関数 $ f(A) $ を以下のように定義します。

- $ A $ を降順に (広義単調減少となるように) ソートしたものを $ B $ とする。
- このとき、 $ f(A)=B_1\ +\ B_2\ +\ \dots\ +\ B_K $ とする。
 
この数列に合計 $ Q $ 回の更新を行うことを考えます。  
 数列 $ A $ に対し以下の更新を $ i=1,2,\dots,Q $ の順に行い、各更新ごとにその時点での $ f(A) $ の値を出力してください。

- $ A_{X_i} $ を $ Y_i $ に変更する。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K\ \le\ N\ \le\ 5\ \times\ 10^5 $
- $ 1\ \le\ Q\ \le\ 5\ \times\ 10^5 $
- $ 1\ \le\ X_i\ \le\ N $
- $ 0\ \le\ Y_i\ \le\ 10^9 $
 
### Sample Explanation 1

この入力では $ N=4,K=2 $ です。 $ Q=10 $ 回の更新を行います。 - $ 1 $ 回目の更新を受けて $ A=(5,0,0,0) $ となります。このとき $ f(A)=5 $ です。 - $ 2 $ 回目の更新を受けて $ A=(5,1,0,0) $ となります。このとき $ f(A)=6 $ です。 - $ 3 $ 回目の更新を受けて $ A=(5,1,3,0) $ となります。このとき $ f(A)=8 $ です。 - $ 4 $ 回目の更新を受けて $ A=(5,1,3,2) $ となります。このとき $ f(A)=8 $ です。 - $ 5 $ 回目の更新を受けて $ A=(5,10,3,2) $ となります。このとき $ f(A)=15 $ です。 - $ 6 $ 回目の更新を受けて $ A=(0,10,3,2) $ となります。このとき $ f(A)=13 $ です。 - $ 7 $ 回目の更新を受けて $ A=(0,10,3,0) $ となります。このとき $ f(A)=13 $ です。 - $ 8 $ 回目の更新を受けて $ A=(0,10,1,0) $ となります。このとき $ f(A)=11 $ です。 - $ 9 $ 回目の更新を受けて $ A=(0,0,1,0) $ となります。このとき $ f(A)=1 $ です。 - $ 10 $ 回目の更新を受けて $ A=(0,0,0,0) $ となります。このとき $ f(A)=0 $ です。

## 样例 #1

### 输入

```
4 2 10

1 5

2 1

3 3

4 2

2 10

1 0

4 0

3 1

2 0

3 0```

### 输出

```
5

6

8

8

15

13

13

11

1

0```

# AI分析结果



# [ABC306E] Best Performances 的题解翻译

## 题目描述

有一个长度为 $N$ 的数列 $A=(A_1,A_2,\dots,A_N)$，初始所有项均为 $0$。  
给定整数 $K$，定义函数 $f(A)$ 如下：

- 将 $A$ 降序排序得到 $B$，则 $f(A) = B_1 + B_2 + \dots + B_K$。

接下来对该数列进行 $Q$ 次更新操作，每次将 $A_{X_i}$ 修改为 $Y_i$，并在每次操作后输出当前的 $f(A)$。

## 算法分类
**数据结构**（使用多集合维护有序序列）

---

## 题解分析与结论

### 各题解核心思路对比

1. **双 multiset 维护法**（CarroT5656）  
   - **关键思路**：用两个 multiset 分别维护前 K 大元素和剩余元素。每次修改后动态调整两个集合，确保前 K 大的集合大小始终为 K，并维护总和。
   - **优势**：代码简洁，时间复杂度 $O(Q \log N)$，利用 STL 容器简化实现。
   - **难点**：需正确处理元素在两个集合间的转移逻辑，避免集合大小溢出。

2. **权值线段树法**（XSean）  
   - **关键思路**：建立权值线段树维护所有元素的出现次数和总和。查询时递归寻找第 K 大元素并累加其后所有值的总和。
   - **优势**：适合动态数值范围，离散化处理优化空间。
   - **难点**：需处理线段树的离散化与动态查询逻辑，实现复杂度较高。

---

## 精选题解

### 题解一（CarroT5656）⭐⭐⭐⭐⭐
**亮点**：  
- 利用 STL 的 multiset 高效维护有序结构，代码简洁易懂。
- 通过插入/删除操作动态调整集合，保持前 K 大元素总和。

**核心代码**：
```cpp
multiset<ll> s, s1; // s 维护前 K 大，s1 维护剩余元素
ll ans = 0;

void update(int x, int y) {
    // 删除旧值
    if (s.find(a[x]) != s.end()) {
        s.erase(s.find(a[x]));
        ans -= a[x];
    } else {
        s1.erase(s1.find(a[x]));
    }
    // 插入新值
    a[x] = y;
    if (!s1.empty() && y >= *s1.rbegin()) {
        s.insert(y);
        ans += y;
    } else {
        s1.insert(y);
    }
    // 调整集合大小
    if (s.size() < k) {
        auto it = s1.rbegin();
        s.insert(*it);
        ans += *it;
        s1.erase(s1.find(*it));
    }
    if (s.size() > k) {
        auto it = s.begin();
        s1.insert(*it);
        ans -= *it;
        s.erase(it);
    }
}
```

### 题解三（XSean）⭐⭐⭐⭐
**亮点**：  
- 权值线段树动态维护元素分布，支持大范围数值查询。
- 离散化优化空间，递归查询高效计算前 K 大和。

**核心实现**：
```cpp
struct Node {
    int cnt;   // 元素个数
    ll sum;    // 区间总和
} tree[N * 4];

// 离散化预处理（略）

// 查询前 K 大和
ll query(int u, int l, int r, int k) {
    if (l == r) return l * k;
    int mid = (l + r) / 2;
    if (tree[rc].cnt >= k) {
        return query(rc, mid+1, r, k);
    } else {
        return tree[rc].sum + query(lc, l, mid, k - tree[rc].cnt);
    }
}
```

---

## 关键技巧总结
- **双集合维护**：通过两个有序结构（如 multiset）分别管理前 K 大和剩余元素，动态调整保持规模。
- **边界处理**：插入新元素后需检查集合大小，通过转移元素保持前 K 大集合的正确性。

---

## 拓展练习
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168) - 动态维护中位数（对顶堆）
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801) - 动态查询第 K 小（平衡树/堆）
3. [P3871 中位数](https://www.luogu.com.cn/problem/P3871) - 实时维护中位数（类似数据结构）

---
处理用时：194.61秒
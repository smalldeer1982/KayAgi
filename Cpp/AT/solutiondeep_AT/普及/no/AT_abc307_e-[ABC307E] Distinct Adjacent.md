# 题目信息

# [ABC307E] Distinct Adjacent

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc307/tasks/abc307_e

$ 1 $ から $ N $ の番号がついた $ N $ 人の人が輪になってならんでいます。人 $ 1 $ の右隣には人 $ 2 $ が、人 $ 2 $ の右隣には人 $ 3 $ が、……、人 $ N $ の右隣には人 $ 1 $ がいます。

$ N $ 人の人にそれぞれ $ 0 $ 以上 $ M $ 未満の整数を $ 1 $ つずつ渡します。  
$ M^N $ 通りの渡し方のうち、どの隣り合う $ 2 $ 人が渡された数も異なるものの数を、$ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N,M\ \leq\ 10^6 $
- $ N,M $ は整数である

### Sample Explanation 1

人 $ 1,2,3 $ に渡す整数がそれぞれ $ (0,1,2),(0,2,1),(1,0,2),(1,2,0),(2,0,1),(2,1,0) $ のときの $ 6 $ 通りです。

### Sample Explanation 2

人 $ 1,2,3,4 $ に渡す整数がそれぞれ $ (0,1,0,1),(1,0,1,0) $ のときの $ 2 $ 通りです。

### Sample Explanation 3

$ 998244353 $ で割ったあまりを求めてください。

## 样例 #1

### 输入

```
3 3```

### 输出

```
6```

## 样例 #2

### 输入

```
4 2```

### 输出

```
2```

## 样例 #3

### 输入

```
987654 456789```

### 输出

```
778634319```

# AI分析结果



# [ABC307E] Distinct Adjacent

## 题目描述

$ N $ 个人围成一个环，每个人分配一个 $ 0 $ 到 $ M-1 $ 的整数。求所有分配方案中相邻数字不同的方案数，结果对 $ 998244353 $ 取模。

### 输入格式
输入两个整数 $ N $ 和 $ M $。

### 输出格式
输出满足条件的方案数。

### 说明/提示
- $ 2 \leq N,M \leq 10^6 $

---

## 算法分类
组合数学

---

## 题解分析

### 关键思路与技巧
1. **环形问题转化**：将环形结构拆解为线性结构，通过数学推导消除首尾相同的非法情况。
2. **递推关系**：利用组合数学推导出通项公式 $ f(n) = (m-1)^n + (-1)^n \cdot (m-1) $，结合快速幂高效计算。
3. **动态规划优化**：定义状态 $ dp[i][0/1] $ 表示前 $ i $ 位满足条件且末位与首位不同/相同的方案数，通过状态转移方程实现线性复杂度。

---

## 精选题解

### 题解1（FLY_lai） ★★★★★
**亮点**：  
1. 数学推导与动态规划双解法  
2. 通项公式法达到 $ O(\log n) $ 时间复杂度  
3. 代码简洁，理论推导清晰  

**数学解法核心代码**：
```cpp
long long fpow(long long a, long long b) {
    // 快速幂实现
}

int main() {
    cin >> n >> m;
    ll ans = (fpow(m-1, n) + (n%2 ? -1 : 1)*(m-1)) % MOD;
    cout << (ans + MOD) % MOD;
}
```

---

### 题解2（泥土笨笨） ★★★★☆
**亮点**：  
1. 状态定义直观，转移方程清晰  
2. 代码简洁易懂，适合动态规划入门  

**动态规划核心代码**：
```cpp
ll dp[MAXN][2];
dp[1][1] = m;
for (int i = 2; i <= n; ++i) {
    dp[i][0] = (dp[i-1][0]*(m-2) + dp[i-1][1]*(m-1)) % MOD;
    dp[i][1] = dp[i-1][0];
}
```

---

### 题解3（吴思诚） ★★★★
**亮点**：  
1. 递推式 $ f(n) = m(m-1)^{n-1} - f(n-1) $ 简洁  
2. 代码实现简单，空间优化到位  

**递推式核心代码**：
```cpp
int f[N] = {0, m, m*(m-1)};
for (int i=3; i<=n; i++) 
    f[i] = (qpow(m-1, i-1)*m - f[i-1]) % MOD;
```

---

## 同类题目推荐
1. [P1357 花园](https://www.luogu.com.cn/problem/P1357) - 环形排列与矩阵快速幂  
2. [P1450 硬币购物](https://www.luogu.com.cn/problem/P1450) - 组合数学与容斥原理  
3. [P1976 鸡蛋的硬度](https://www.luogu.com.cn/problem/P1976) - 动态规划优化递推

---
处理用时：82.27秒
# 题目信息

# [ABC309D] Add One Edge

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc309/tasks/abc309_d

$ N_1+N_2 $ 頂点 $ M $ 辺の無向グラフがあります。$ i=1,2,\ldots,M $ に対し、$ i $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結びます。  
 また、以下を満たすことが保障されます。

- $ 1\ \leq\ u,v\ \leq\ N_1 $ を満たす整数 $ u,v $ に対し、頂点 $ u $ と頂点 $ v $ は連結
- $ N_1+1\ \leq\ u,v\ \leq\ N_1+N_2 $ を満たす整数 $ u,v $ に対し、頂点 $ u $ と頂点 $ v $ は連結
- 頂点 $ 1 $ と頂点 $ N_1+N_2 $ は非連結
 
次の操作をちょうど $ 1 $ 回行います。

- $ 1\ \leq\ u\ \leq\ N_1 $ を満たす整数 $ u $ と $ N_1+1\ \leq\ v\ \leq\ N_1+N_2 $ を満たす整数 $ v $ を選び、頂点 $ u $ と頂点 $ v $ を結ぶ辺を追加する
 
操作後のグラフにおいて、頂点 $ 1 $ と頂点 $ N_1+N_2 $ は必ず連結であることが示せます。そこで、頂点 $ 1 $ と頂点 $ N_1+N_2 $ を結ぶ経路の長さ(辺の本数)の最小値を $ d $ とします。

操作で追加する辺を適切に選んだ時にありえる $ d $ の最大値を求めてください。

  連結とは？ 無向グラフの頂点 $ u,v $ が連結であるとは、頂点 $ u $ と頂点 $ v $ を結ぶ経路が存在することをいいます。

## 说明/提示

### 制約

- $ 1\ \leq\ N_1,N_2\ \leq\ 1.5\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ a_i\ \leq\ b_i\ \leq\ N_1+N_2 $
- $ i\ \neq\ j $ ならば $ (a_i,b_i)\ \neq\ (a_j,b_j) $
- $ 1\ \leq\ u,v\ \leq\ N_1 $ を満たす整数 $ u,v $ に対し、頂点 $ u $ と頂点 $ v $ は連結
- $ N_1+1\ \leq\ u,v\ \leq\ N_1+N_2 $ を満たす整数 $ u,v $ に対し、頂点 $ u $ と頂点 $ v $ は連結
- 頂点 $ 1 $ と頂点 $ N_1+N_2 $ は非連結
- 入力はすべて整数
 
### Sample Explanation 1

$ u=2,v=5 $ として操作することで $ d=5 $ と出来ます。これが最大値です。 !\[\](https://img.atcoder.jp/abc309/a64d8034b08cfa7d1f655767cc164653.png)

## 样例 #1

### 输入

```
3 4 6

1 2

2 3

4 5

4 6

1 3

6 7```

### 输出

```
5```

## 样例 #2

### 输入

```
7 5 20

10 11

4 5

10 12

1 2

1 5

5 6

2 4

3 5

9 10

2 5

1 4

11 12

9 12

8 9

5 7

3 7

3 6

3 4

8 12

9 11```

### 输出

```
4```

# AI分析结果



# [ABC309D] Add One Edge

## 题目描述

给定包含 $N_1+N_2$ 个顶点和 $M$ 条边的无向图，满足以下条件：
1. 所有 $1 \leq u,v \leq N_1$ 的顶点互相连通
2. 所有 $N_1+1 \leq u,v \leq N_1+N_2$ 的顶点互相连通
3. 顶点 1 与顶点 $N_1+N_2$ 不连通

现需在两个点集间添加一条边，使得添加后顶点 1 到顶点 $N_1+N_2$ 的最短路径长度最大。求该最大可能值。

### 算法分类
最短路、广度优先搜索 BFS

---

## 题解综合分析

### 关键思路总结
所有正确题解均采用以下核心思路：
1. 分别计算两个连通块中顶点到各自端点的最长最短距离
   - 块1：顶点1到所有顶点的最长距离（记为d1_max）
   - 块2：顶点N1+N2到所有顶点的最长距离（记为d2_max）
2. 最终答案为 d1_max + d2_max + 1（+1为新增边）

**正确性证明**：
- 添加边(u,v)后的路径长度为 d1(u) + 1 + d2(v)
- 要使该值最大化，需同时取两个连通块内的最大d值

### 最优解法亮点
使用BFS进行层次遍历：
1. 在无权图中，BFS时间复杂度O(N+M)优于Dijkstra的O(MlogN)
2. 两次BFS分别处理两个连通块
3. 维护距离数组并取最大值

---

## 精选题解（评分≥4⭐）

### 题解作者：DengDuck（评分：5⭐）
**核心亮点**：
- 使用标准BFS模板，代码简洁易读
- 直接维护距离数组并求最大值
- 时间复杂度严格线性，适合大数据量

**关键代码**：
```cpp
void bfs(LL x) {
    while(!q.empty()) q.pop();
    q.push(x);
    dis[x] = 0;
    while(!q.empty()) {
        LL t = q.front();
        q.pop();
        for(LL i : v[t]) {
            if(dis[i] > dis[t] + 1) {
                dis[i] = dis[t] + 1;
                q.push(i);
            }
        }
    }
}
```

### 题解作者：hellolin（评分：4.5⭐）
**核心亮点**：
- 使用优先队列实现BFS
- 显式处理两个连通块的图结构
- 包含详细注释和类型定义

**个人心得**：
> "由于是无权图，求最短路可以直接BFS。总时间复杂度为Θ(n)" —— 明确指出算法选择依据

### 题解作者：2huk（评分：4⭐）
**核心亮点**：
- 清晰的问题分析过程
- 数学公式推导增强理解
- 使用STL队列的标准实现

**关键实现**：
```cpp
void bfs(int x) {
    queue<int> q;
    q.push(x);
    vis[x] = 1;
    while(!q.empty()) {
        int a = q.front();
        q.pop();
        for(auto i : e[a]) {
            if(!vis[i]) {
                vis[i] = 1;
                dis[i] = dis[a] + 1;
                q.push(i);
            }
        }
    }
}
```

---

## 相似题目推荐
1. [P1354 房间最短路问题](https://www.luogu.com.cn/problem/P1354) - 几何+BFS最短路
2. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144) - BFS最短路变形
3. [P3393 逃离僵尸岛](https://www.luogu.com.cn/problem/P3393) - 多源BFS+最短路优化

---
处理用时：46.25秒
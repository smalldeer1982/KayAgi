# 题目信息

# [ABC309E] Family and Insurance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc309/tasks/abc309_e

人 $ 1 $、人 $ 2 $、$ \ldots $、人 $ N $ からなる家系があります。$ i\geq\ 2 $ に対し、人 $ i $ の親は人 $ p_i $ です。

この家系の人たちは $ M $ 回保険に加入しました。$ i=1,2,\ldots,M $ に対し、$ i $ 番目の保険の加入者は人 $ x_i $ で、本人及びその $ y_i $ 代先までの子たちが補償対象者です。

$ 1 $ 個以上の保険の補償対象者になっている人が何人いるかを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ p_i\ \leq\ i-1 $
- $ 1\ \leq\ x_i\ \leq\ N $
- $ 1\ \leq\ y_i\ \leq\ 3\ \times\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1 $ 番目の保険について、人 $ 1 $ の $ 1 $ 代先の子たちは人 $ 2 $ と人 $ 4 $ なので人 $ 1,2,4 $ が補償対象者です。 $ 2 $ 番目の保険について、人 $ 1 $ の $ 1 $ 代先の子たちは人 $ 2 $ と人 $ 4 $、$ 2 $ 代先の子は人 $ 3 $ なので人 $ 1,2,3,4 $ が補償対象者です。 $ 3 $ 番目の保険について、人 $ 4 $ の $ 1,2,3 $ 代先の子は存在しないので人 $ 4 $ が補償対象者です。 以上より、$ 1 $ 個以上の保険の補償対象者になっている人は人 $ 1,2,3,4 $ の $ 4 $ 人です。

## 样例 #1

### 输入

```
7 3

1 2 1 3 3 3

1 1

1 2

4 3```

### 输出

```
4```

## 样例 #2

### 输入

```
10 10

1 1 3 1 2 3 3 5 7

2 1

5 1

4 3

6 3

2 1

7 3

9 2

1 2

6 2

8 1```

### 输出

```
10```

# AI分析结果



【题目翻译】
# [ABC309E] 家族与保险

## 题目描述

由人 $1$、人 $2$、……、人 $N$ 组成的家系。对于 $i \geq 2$，人 $i$ 的父辈是人 $p_i$。

该家系成员购买了 $M$ 次保险。对于第 $i$ 次购买，购买者人 $x_i$ 及其 $y_i$ 代以内的子嗣均为被保障对象。求至少被一个保险覆盖的人数。

## 输入格式
输入包含：
- 第一行两个整数 $N, M$
- 第二行 $N-1$ 个整数表示 $p_2 \sim p_N$
- 后续 $M$ 行每行两个整数 $x_i, y_i$

## 输出格式
输出被保障的总人数。

---

**算法分类**  
深度优先搜索（DFS） / 广度优先搜索（BFS）

---

### 题解分析与结论
各题解核心思路统一：  
1. **预处理最大覆盖代数**：对每个节点记录其所有保险中的最大 y_i+1（包含自身）
2. **树形传递**：通过一次DFS/BFS遍历，父节点的剩余代数-1更新子节点
3. **线性复杂度**：O(N) 时间处理，关键在避免重复遍历

#### 最优思路总结
**关键技巧**：
- **离线处理保险**：对同一节点的多次保险取max预处理
- **树形动态传播**：父节点剩余代数通过DFS/BFS逐层传递
- **状态维护**：每个节点维护可传播代数，仅当父节点传播值更大时更新

---

### 精选题解

#### 1. DengDuck（⭐⭐⭐⭐⭐）
**亮点**：
- 使用 `f[x]` 表示可传播代数，-1表示未覆盖
- 简洁的DFS实现，边遍历边统计
- 预处理与传播逻辑清晰

**核心代码**：
```cpp
void dfs(LL x) {
    if(f[x]!=-1) ans++; // 当前节点有保险
    for(LL i:v[x]) {
        f[i] = max(f[i], f[x]-1); // 传播剩余代数
        dfs(i);
    }
}
// 预处理每个节点的最大y_i
for(int i=1;i<=m;i++) {
    scanf("%lld%lld",&x,&y);
    f[x] = max(f[x], y);
}
```

#### 2. yuheng_wang080904（⭐⭐⭐⭐）
**亮点**：
- BFS实现避免递归栈限制
- 显式维护 `g[i]` 数组，逻辑直观
- 队列处理层级关系更自然

**核心代码**：
```cpp
queue<int> q;
q.push(1);
while(!q.empty()) {
    int a = q.front(); q.pop();
    if(g[a]) cnt++; // 统计有效节点
    for(auto i:son[a]) {
        g[i] = max(g[i], g[a]-1); // 更新子节点
        q.push(i);
    }
}
```

#### 3. zhangjiting（⭐⭐⭐⭐）
**亮点**：
- 使用链式前向星存树
- 代码结构紧凑，预处理与DFS结合紧密
- 变量命名清晰易懂

**核心代码**：
```cpp
void dfs(int s, int m) {
    m = max(m, d[s]); // 取当前节点最大值
    if(m > 0) ans++;
    for(int i=head[s]; i; i=nxt[i])
        dfs(to[i], m-1); // 传递剩余代数
}
```

---

### 拓展与心得
**同类型题目**：
1. [P1271 聚会的快乐](https://www.luogu.com.cn/problem/P1271) - 树形动态规划
2. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352) - 树形状态传递
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014) - 树形依赖处理

**调试心得**（摘录自题解）：
- "注意y_i需要+1，因为包含自身"（Loser_Syx）
- "预处理时取max是核心，避免重复处理"（Keroshi）
- "BFS更适合大数据量的层级遍历"（yuheng_wang080904）

---

**总结**：本题核心在于将多个保险的影响离线处理为最大覆盖范围，通过一次树遍历完成状态传播。DFS/BFS的选择取决于实现习惯，本质均为线性时间的贪心策略。

---
处理用时：60.40秒
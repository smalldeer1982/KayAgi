# 题目信息

# [ABC324E] Joint Two Strings

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc324/tasks/abc324_e

英小文字からなる $ N $ 個の文字列 $ S_1,\ S_2,\ \ldots,\ S_N $ 、および、英小文字からなる文字列 $ T $ が与えられます。

$ 1 $ 以上 $ N $ 以下の $ 2 $ つの整数からなる組 $ (i,\ j) $ は $ N^2 $ 個ありますが、そのうち下記の条件を満たすものの個数を出力してください。

- $ S_i $ と $ S_j $ をこの順に連結して得られる文字列は、$ T $ を（連続とは限らない）部分列として含む。

## 说明/提示

### 制約

- $ N $ は整数
- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ S_i $ および $ T $ は英小文字からなる長さ $ 1 $ 以上 $ 5\ \times\ 10^5 $ 以下の文字列
- $ S_1,\ S_2,\ \ldots,\ S_N $ の長さの総和は $ 5\ \times\ 10^5 $ 以下
 
### Sample Explanation 1

問題文中の条件を満たす組 $ (i,\ j) $ は、下記に示す $ 3 $ 個の組 $ (1,\ 2),\ (1,\ 3),\ (2,\ 3) $ です。 - $ (i,\ j)\ =\ (1,\ 2) $ について、$ S_1 $ と $ S_2 $ をこの順に連結して得られる文字列 `abbabcb` は `bac` を部分列として含みます。 - $ (i,\ j)\ =\ (1,\ 3) $ について、$ S_1 $ と $ S_3 $ をこの順に連結して得られる文字列 `abbaaaca` は `bac` を部分列として含みます。 - $ (i,\ j)\ =\ (2,\ 3) $ について、$ S_2 $ と $ S_3 $ をこの順に連結して得られる文字列 `bcbaaca` は `bac` を部分列として含みます。

## 样例 #1

### 输入

```
3 bac

abba

bcb

aaca```

### 输出

```
3```

## 样例 #2

### 输入

```
5 xx

x

x

x

x

x```

### 输出

```
25```

## 样例 #3

### 输入

```
1 y

x```

### 输出

```
0```

## 样例 #4

### 输入

```
10 ms

mkgn

m

hlms

vmsle

mxsm

nnzdhi

umsavxlb

ffnsybomr

yvmm

naouel```

### 输出

```
68```

# AI分析结果



### 中文题目重写

【题目内容】

# [ABC324E] 连接两个字符串

## 题目描述

给定由小写字母组成的N个字符串S₁, S₂, ..., S_N，以及一个由小写字母组成的字符串T。计算有多少对(i, j)满足将S_i和S_j按顺序连接后的字符串包含T作为子序列（不要求连续）。

## 输入格式
- 第一行包含整数N和字符串T
- 后续N行每行一个字符串S_i

## 输出格式
- 输出符合条件的(i, j)对数

## 样例解释
样例1中，符合条件的3对为(1,2)、(1,3)、(2,3)，它们的拼接字符串均包含"bac"作为子序列。

---

### 算法分类
**前缀和与双指针**

---

### 题解对比与结论

#### 核心思路
1. **预处理匹配长度**：对每个S_i计算：
   - L[i]：能匹配T的最长前缀长度
   - R[i]：能匹配T的最长后缀长度
2. **统计贡献**：满足条件的对数为L[i] + R[j] ≥ |T|，使用后缀和数组高效统计。

#### 最优题解

**作者：不知名用户（⭐⭐⭐⭐⭐）**
- **亮点**：时间复杂度O(Σ|S_i| + |T|)，代码简洁高效
- **核心代码**：
```cpp
// 预处理前缀匹配
for(int j=0; j<s[i].size(); j++)
    if(p < t.size() && s[i][j] == t[p]) p++;
l[i] = p;

// 预处理后缀匹配
for(int j=s[i].size()-1; j>=0; j--)
    if(p >= 0 && s[i][j] == t[p]) p--, x++;
r[i] = x;

// 统计后缀和
for(i = m; ~i; i--) w[i] += w[i+1];

// 计算结果
ans += w[m - r[i]];
```

**作者：robertuu（⭐⭐⭐⭐）**
- **亮点**：代码结构清晰，变量命名规范
- **核心实现**：
```cpp
// 预处理后缀匹配
for(int j = s[i].size()-1; j >= 0; j--)
    if(s[i][j] == t[len - bck - 1]) bck++;

// 前缀和统计
ssuf[suf[i]]++;
for(int i = 1; i <= len; i++) ssuf[i] += ssuf[i-1];
```

---

### 关键思路总结
1. **双指针预处理**：通过两次双指针扫描，分别计算每个字符串的前缀/后缀匹配长度。
2. **后缀和优化**：将问题转换为求后缀和，避免重复计算，时间复杂度优化至线性。
3. **边界处理**：特别注意当T为空或完全包含于单个字符串时的特殊情况。

---

### 相似题目推荐
1. [P3973 子序列](https://www.luogu.com.cn/problem/P3973) - 子序列计数问题
2. [P3188 [HNOI2007]梦幻岛宝珠](https://www.luogu.com.cn/problem/P3188) - 预处理与组合统计
3. [P2516 [HAOI2010]最长公共子序列](https://www.luogu.com.cn/problem/P2516) - 子序列相关动态规划

---

### 调试心得摘录
**CrTsIr400**：比赛时因双指针移动逻辑错误导致WA，修正后注意指针必须仅在匹配成功时移动。  
**fcy20180201**：树状数组处理时未考虑边界情况，添加特判后通过。  
**Expert_Dream**：未开long long导致WA，强调基础错误检查的重要性。

---
处理用时：111.20秒
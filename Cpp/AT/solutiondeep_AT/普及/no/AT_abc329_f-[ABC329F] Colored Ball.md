# 题目信息

# [ABC329F] Colored Ball

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc329/tasks/abc329_f

$ 1,\ 2,\ \ldots,\ N $ の番号がついた $ N $ 個の箱があり、はじめ箱 $ i $ には色 $ C_i $ のボールが $ 1 $ つ入っています。

$ Q $ 個のクエリが与えられるので、これらを順に処理してください。

各クエリは整数の組 $ (a,b) $ によって与えられ、その内容は以下の通りです。

- 箱 $ a $ のボールをすべて箱 $ b $ に移し、その後箱 $ b $ に何種類の色のボールが入っているかを出力する。
 
ただし、箱 $ a $ や箱 $ b $ が空の場合もあることに注意してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 200000 $
- $ 1\ \leq\ C_i\ \leq\ N $
- $ 1\ \leq\ a,\ b\ \leq\ N $
- $ a\ \neq\ b $
- 入力される数値はすべて整数
 
### Sample Explanation 1

\- $ 1 $ 番目のクエリでは、箱 $ 1 $ のボールをすべて箱 $ 2 $ に移します。箱 $ 2 $ には色 $ 1 $ のボールが $ 2 $ つ入っている状態となるため、$ 1 $ を出力します。 - $ 2 $ 番目のクエリでは、箱 $ 6 $ のボールをすべて箱 $ 4 $ に移します。箱 $ 4 $ には色 $ 2 $ のボールが $ 1 $ つ、色 $ 3 $ のボールが $ 1 $ つ入っている状態となるため、$ 2 $ を出力します。 - $ 3 $ 番目のクエリでは、箱 $ 5 $ のボールをすべて箱 $ 1 $ に移します。箱 $ 1 $ には色 $ 2 $ のボールが $ 1 $ つ入っている状態となるため、$ 1 $ を出力します。 - $ 4 $ 番目のクエリでは、箱 $ 3 $ のボールをすべて箱 $ 6 $ に移します。箱 $ 6 $ には色 $ 1 $ のボールが $ 1 $ つ入っている状態となるため、$ 1 $ を出力します。 - $ 5 $ 番目のクエリでは、箱 $ 4 $ のボールをすべて箱 $ 6 $ に移します。箱 $ 6 $ には色 $ 1 $ のボールが $ 1 $ つ、色 $ 2 $ のボールが $ 1 $ つ、色 $ 3 $ のボールが $ 1 $ つ入っている状態となるため、$ 3 $ を出力します。

## 样例 #1

### 输入

```
6 5

1 1 1 2 2 3

1 2

6 4

5 1

3 6

4 6```

### 输出

```
1

2

1

1

3```

## 样例 #2

### 输入

```
5 3

2 4 2 4 2

3 1

2 5

3 2```

### 输出

```
1

2

0```

# AI分析结果



# F - Colored Ball

## 题目描述

有编号为 $1, 2, \ldots, N$ 的 $N$ 个盒子，初始时每个盒子 $i$ 包含一个颜色为 $C_i$ 的球。

需要处理 $Q$ 个操作，每个操作给定整数对 $(a,b)$，要求将盒子 $a$ 中的所有球移动到盒子 $b$ 中，然后输出盒子 $b$ 中不同颜色球的数量。

**注意**：$a$ 和 $b$ 可能为空盒子，保证每次操作 $a \neq b$。

---

## 算法分类
启发式合并

---

## 题解分析

### 核心思路
使用启发式合并策略，维护每个盒子的颜色集合。每次合并时将较小集合合并到较大集合中，通过交换容器引用保持操作方向正确性，确保时间复杂度为 $O(n \log^2 n)$。

### 关键技巧
1. **集合大小比较**：每次合并前比较两个集合的大小，保证总是小集合并入大集合。
2. **指针交换优化**：利用 C++ STL 容器的 swap 操作（时间复杂度 $O(1)$）快速交换容器内容。
3. **惰性清空**：合并后直接清空源集合，避免重复计算。

---

## 精选题解

### 题解1 - Mars_Dingdang（⭐⭐⭐⭐⭐）
**亮点**：使用 id 映射实现隐式指针交换，代码简洁高效  
**关键代码**：
```cpp
int id[maxn]; // 盒子当前对应的集合编号
set<int> st[maxn]; // 实际存储的集合

rep(i, 1, q) {
    int a, b;
    read(a); read(b);    
    if(st[id[a]].size() > st[id[b]].size()) 
        swap(id[a], id[b]); // 关键交换
    a = id[a], b = id[b];
    st[b].insert(st[a].begin(), st[a].end());
    st[a].clear();
    writeln(st[b].size());
}
```

### 题解2 - xz001（⭐⭐⭐⭐）
**亮点**：显式判断集合大小关系，逻辑清晰  
**代码片段**：
```cpp
if (c[a].size() < c[b].size()) {
    for (auto it : c[a]) c[b].insert(it);
    c[a].clear();
} else {
    for (auto it : c[b]) c[a].insert(it);
    c[b].clear();
    swap(c[a], c[b]); // 显式交换容器
}
```

### 题解3 - BugGod（⭐⭐⭐⭐）
**亮点**：极简代码实现，直接利用 STL 特性  
**代码核心**：
```cpp
if(s[b].size() < s[a].size()) 
    swap(s[b], s[a]); // STL swap 是 O(1)
s[b].insert(s[a].begin(), s[a].end());
s[a].clear();
```

---

## 举一反三

### 类似题目推荐
1. [P3224 永无乡](https://www.luogu.com.cn/problem/P3224) - 并查集+启发式合并维护第k大
2. [P3302 森林](https://www.luogu.com.cn/problem/P3302) - 启发式合并维护树上路径
3. [CF600E Lomsat gelral](https://www.luogu.com.cn/problem/CF600E) - 树上启发式合并经典题

---

## 心得体会摘录

> "考试的时候忘了 STL 交换是 O(1)，然后爆炸" —— incra  
总结：STL 容器的 swap 操作是常数时间的关键优化点

> "每个元素最多参与 logn 次合并" —— 2huk  
总结：启发式合并复杂度证明的核心在于元素转移次数上界分析

> "根号分治虽然可行但实现复杂" —— 沉石鱼惊旋  
总结：应根据数据规模特点选择最适算法，避免过度设计

---
处理用时：84.20秒
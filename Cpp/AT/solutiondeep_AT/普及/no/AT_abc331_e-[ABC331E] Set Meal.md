# 题目信息

# [ABC331E] Set Meal

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc331/tasks/abc331_e

AtCoder 食堂では主菜と副菜からなる定食が販売されています。  
 主菜は $ N $ 種類あり、順に主菜 $ 1 $, 主菜 $ 2 $, $ \dots $, 主菜 $ N $ と呼びます。主菜 $ i $ の価格は $ a_i $ 円です。  
 副菜は $ M $ 種類あり、順に副菜 $ 1 $, 副菜 $ 2 $, $ \dots $, 副菜 $ M $ と呼びます。副菜 $ i $ の価格は $ b_i $ 円です。

定食は主菜と副菜を $ 1 $ 種類ずつ選んで構成されます。定食の価格は選んだ主菜の価格と副菜の価格の和です。   
 ただし、$ L $ 個の相異なる組 $ (c_1,\ d_1),\ \dots,\ (c_L,\ d_L) $ について、主菜 $ c_i $ と副菜 $ d_i $ からなる定食は食べ合わせが悪いため提供されていません。  
 つまり、提供されている定食は $ NM\ -\ L $ 種類あることになります。(提供されている定食が少なくとも $ 1 $ 種類存在することが制約によって保証されています。)

提供されている定食のうち、最も価格の高い定食の価格を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M\ \leq\ 10^5 $
- $ 0\ \leq\ L\ \leq\ \min(10^5,\ N\ M\ -\ 1) $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ 10^9 $
- $ 1\ \leq\ c_i\ \leq\ N $
- $ 1\ \leq\ d_j\ \leq\ M $
- $ i\ \neq\ j $ ならば $ (c_i,\ d_i)\ \neq\ (c_j,\ d_j) $
- 入力される値は全て整数
 
### Sample Explanation 1

提供されている定食、及びその価格は次の $ 3 $ 種類です。 - 主菜 $ 1 $ と副菜 $ 1 $ からなる定食。価格は $ 2\ +\ 10\ =\ 12 $ 円である。 - 主菜 $ 1 $ と副菜 $ 3 $ からなる定食。価格は $ 2\ +\ 20\ =\ 22 $ 円である。 - 主菜 $ 2 $ と副菜 $ 2 $ からなる定食。価格は $ 1\ +\ 30\ =\ 31 $ 円である。 この中で最も高い定食は $ 3 $ 番目の定食です。よって $ 31 $ を出力してください。

## 样例 #1

### 输入

```
2 3 3

2 1

10 30 20

1 2

2 1

2 3```

### 输出

```
31```

## 样例 #2

### 输入

```
2 1 0

1000000000 1

1000000000```

### 输出

```
2000000000```

## 样例 #3

### 输入

```
10 10 10

47718 21994 74148 76721 98917 73766 29598 59035 69293 29127

7017 46004 16086 62644 74928 57404 32168 45794 19493 71590

1 3

2 6

4 5

5 4

5 5

5 6

5 7

5 8

5 10

7 3```

### 输出

```
149076```

# AI分析结果



## 中文题目重写

### [ABC331E] Set Meal

**题目描述**  
AtCoder 食堂提供由主菜和副菜组成的套餐。  
- 主菜有 $N$ 种，第 $i$ 种主菜价格为 $a_i$ 日元  
- 副菜有 $M$ 种，第 $i$ 种副菜价格为 $b_i$ 日元  
- 存在 $L$ 个无效组合 $(c_i,d_i)$ 表示主菜 $c_i$ 与副菜 $d_i$ 不能搭配  

求有效套餐中的最大价格。  

**输入格式**  
第一行包含 $N,M,L$  
第二行包含 $N$ 个主菜价格  
第三行包含 $M$ 个副菜价格  
接下来 $L$ 行每行一个无效组合  

**输出格式**  
输出最大有效套餐价格  

**样例**  
输入样例1：  
2 3 3  
2 1  
10 30 20  
1 2  
2 1  
2 3  
输出样例1：  
31  

---

### 算法分类  
**贪心**

---

### 题解分析与结论  
**核心思路**：  
1. **排序优化**：将主菜和副菜分别按价格降序排列  
2. **剪枝策略**：对每个主菜，从价格最大的副菜开始检查，找到第一个有效组合即可停止（后续副菜价格更小无需检查）  
3. **快速查询**：使用哈希结构存储无效组合，实现 $O(1)$ 时间查询  

**解决难点**：  
- 处理 $10^5$ 规模数据时需避免 $O(NM)$ 暴力枚举  
- 通过排序+剪枝将复杂度降至 $O(N + M\log M + L)$  

**最优解法关键点**：  
- 预处理排序后，利用贪心性质快速定位可能的最大值  
- 使用哈希表或数组标记无效组合，实现快速查询  

---

### 精选题解  
**xu222ux（4星）**  
**亮点**：  
- 代码简洁，逻辑清晰  
- 使用 `map` 存储无效组合，排序后倒序查找第一个合法组合  
**核心代码**：  
```cpp
sort(a+1,a+1+n,cmp); // 主菜降序排序
sort(b+1,b+1+m,cmp); // 副菜降序排序

for(int i=1;i<=n;i++) {
    for(int j=1;j<=m;j++) {
        if(!mp[{a[i].id,b[j].id}]) { // 检查是否无效组合
            tmp = max(tmp, a[i].x + b[j].x);
            break; // 找到即停止
        }
    }
}
```

**naroanah（4星）**  
**亮点**：  
- 使用临时标记数组优化查询效率  
- 预处理副菜排序，倒序扫描时动态标记无效项  
**核心代码**：  
```cpp
sort(b + 1, b + m + 1); // 副菜升序排序（需调整比较函数）

for(int i=1;i<=n;i++) {
    for(auto it : g[i]) vis[it] = 1; // 标记当前主菜的无效副菜
    req(j,m,1) if(!vis[b[j].se]) {   // 倒序查找
        ans = max(ans, a[i] + b[j].fi);
        break;
    }
    for(auto it : g[i]) vis[it] = 0; // 恢复标记
}
```

---

### 举一反三  
**相似题目推荐**：  
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102) - 哈希优化查找  
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638) - 滑动窗口+贪心  
3. [P1571 眼红的Medusa](https://www.luogu.com.cn/problem/P1571) - 排序+双指针  

**调试心得**：  
- 注意排序后原始编号的保存与匹配  
- 预处理无效组合时，建议使用主菜索引的数组存储对应副菜集合，避免全表查询  
- 大数组使用全局定义防止栈溢出

---
处理用时：82.56秒
# 题目信息

# [ABC346E] Paint

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc346/tasks/abc346_e

$ H $ 行 $ W $ 列のグリッドがあり、はじめすべてのマスは色 $ 0 $ で塗られています。

これから $ i\ =\ 1,\ 2,\ \ldots,\ M $ の順で以下の操作を行います。

- $ T_i\ =\ 1 $ のとき、$ A_i $ **行目**のマスをすべて色 $ X_i $ に塗り替える
- $ T_i\ =\ 2 $ のとき、$ A_i $ **列目**のマスをすべて色 $ X_i $ に塗り替える

すべての操作を終えたとき、最終的に色 $ i $ で塗られたマスが存在するような各色 $ i $ についてその色で塗られたマスの個数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W,\ M\ \leq\ 2\ \times\ 10^5 $
- $ T_i\ \in\ \lbrace\ 1,\ 2\ \rbrace $
- $ T_i\ =\ 1 $ なる $ i $ に対して $ 1\ \leq\ A_i\ \leq\ H $
- $ T_i\ =\ 2 $ なる $ i $ に対して $ 1\ \leq\ A_i\ \leq\ W $
- $ 0\ \leq\ X_i\ \leq\ 2\ \times\ 10^5 $
- 入力される値はすべて整数

### Sample Explanation 1

操作によってグリッドの各マスの色は以下のように変化します。 ``` 0000 0000 0000 0000 0000 0000 → 5555 → 5550 → 5550 → 5550 0000 0000 0000 3333 2222 ``` 最終的に色 $ 0 $ で塗られたマスは $ 5 $ つ、色 $ 2 $ で塗られたマスは $ 4 $ つ、色 $ 5 $ で塗られたマスは $ 3 $ つです。

## 样例 #1

### 输入

```
3 4 4
1 2 5
2 4 0
1 3 3
1 3 2```

### 输出

```
3
0 5
2 4
5 3```

## 样例 #2

### 输入

```
1 1 5
1 1 1
1 1 10
2 1 100
1 1 1000
2 1 10000```

### 输出

```
1
10000 1```

## 样例 #3

### 输入

```
5 5 10
1 1 1
1 2 2
1 3 3
1 4 4
1 5 5
2 1 6
2 2 7
2 3 8
2 4 9
2 5 10```

### 输出

```
5
6 5
7 5
8 5
9 5
10 5```

# AI分析结果



### 题目翻译
# [ABC346E] Paint

## 题目描述

有一个 $H$ 行 $W$ 列的网格，初始所有单元格颜色为 $0$。依次进行 $M$ 次操作：
- 若 $T_i=1$，将第 $A_i$ 行所有单元格涂为颜色 $X_i$
- 若 $T_i=2$，将第 $A_i$ 列所有单元格涂为颜色 $X_i$

求最终存在至少一个单元格的颜色 $i$ 对应的单元格数量。

### 输入格式
输入包含 $M+1$ 行：
- 第一行：$H, W, M$
- 第 $2$ 至 $M+1$ 行：每行三个数 $T_i, A_i, X_i$

### 输出格式
输出颜色总数及每种颜色对应的单元格数（按颜色编号升序）

### 算法分类
**模拟**

---

### 题解综合分析

各题解的核心思路均为**逆向处理+覆盖计数**，关键步骤：
1. 逆序处理操作，确保只保留最终有效操作
2. 维护已覆盖的行列数量
3. 动态计算颜色贡献

差异点主要在于实现方式：
- 标记方式：`map` vs 数组标记
- 颜色统计：显式处理零颜色 vs 数学推导

---

### 精选题解（评分≥4星）

#### 1. 作者：2huk（★★★★★）
**核心亮点**：
- 最简洁的实现逻辑
- 通过 `map` 高效记录行列覆盖状态
- 包含初始状态的隐式处理

```cpp
map<pair<int, int>, bool> mp;
int nn = 0, mm = 0; // 已覆盖列数、行数

void work(int op, int a, int x) {
    if (mp.count({op, a})) return;
    mp[{op, a}] = true;
    
    if (op == 1) { // 行操作
        res[x] += W - nn; // 贡献未被列覆盖的列数
        mm++; // 更新已覆盖行数
    } else { // 列操作
        res[x] += H - mm; // 贡献未被行覆盖的行数
        nn++; // 更新已覆盖列数
    }
}

// 逆序处理所有操作
for (int i = k; i; --i) work(a[i].op, a[i].a, a[i].x);
```

#### 2. 作者：Xuan_qwq（★★★★☆）
**核心亮点**：
- 显式处理初始零颜色
- 使用双栈结构统一处理初始状态
- 变量命名清晰易理解

```cpp
int hang = 0, lie = 0; // 已覆盖行、列数
bool f[200005][3]; // 行列覆盖标记

while (!st1.empty()) {
    // 从栈中取出逆序操作
    if (opt == 1 && !f[x][1]) {
        ans[y] += (W - lie);
        hang++;
    }
    // 类似处理列操作...
}
```

#### 3. 作者：KSCD_（★★★★☆）
**核心亮点**：
- 数学法处理零颜色
- 最低空间复杂度（仅用两个标记数组）
- 最接近工业级代码规范

```cpp
int th = H, tw = W; // 剩余可涂行列数
for (int i = m; i >= 1; i--) {
    if (T == 1 && !hang[a]) {
        sum[x] += tw; // 剩余可涂列数
        th--; // 减少后续列操作影响
    }
    // 类似处理列操作...
}
sum[0] = H*W - 其他颜色总和; // 数学推导零颜色
```

---

### 关键思路总结
**逆向覆盖计数法**的核心实现步骤：
1. **逆序处理**：从最后一次操作开始，保证每个行列只处理最终有效操作
2. **动态维护**：
   - `col_remain = W - 已覆盖列数`
   - `row_remain = H - 已覆盖行数`
3. **颜色统计**：
   - 行操作贡献：`col_remain`
   - 列操作贡献：`row_remain`
4. **零颜色处理**：`总格子数 - Σ其他颜色格子数`

---

### 类似题目推荐
1. [P1840 — 覆盖墙壁](https://www.luogu.com.cn/problem/P1840)  
   （逆向思维处理覆盖问题）
   
2. [P2896 — 社交距离](https://www.luogu.com.cn/problem/P2896)  
   （动态维护有效区域）

3. [P4447 — 分组](https://www.luogu.com.cn/problem/P4447)  
   （操作序列的逆向处理技巧）

---
处理用时：53.42秒
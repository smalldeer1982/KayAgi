# 题目信息

# [ABC387D] Snaky Walk

## 题目描述

给你一张地图，图中只包含起点```S```，终点```G```，障碍```#```，道路```.```。从起点出发，第一步方向任意，但之后的每一步都不能与之前相同。以这样的移动方式，求出到达终点的最少步数。

## 说明/提示

#### 约定
- $1\le H,W\le 1000$
- $H,W$均为整数
- $S_i$均为```S```，```G```，```#```，```.```组成的长为$W$的字符串。
- 每行，每列字符均相邻
#### 样例解释 1
![](https://img.atcoder.jp/abc387/6ef2f123adae6bc6bb157af8f30afe89.png)
如左图，路线为$(1,2)\rightarrow (2,2)\rightarrow (2,3)\rightarrow (3,3)\rightarrow (3,4)\rightarrow (2,4)\rightarrow (2,5)\rightarrow (1,5)$，移动7次即可到达终点。6次以下均不能到达终点，所以答案是7。       
请注意，如右图，不能走连续横向的路径（或走连续纵向的路径）。
#### 样例解释 2
模拟一下，明显到不了。

## 样例 #1

### 输入

```
3 5

.S#.G

.....

.#...```

### 输出

```
7```

## 样例 #2

### 输入

```
3 5

..#.G

.....

S#...```

### 输出

```
-1```

## 样例 #3

### 输入

```
8 63

...............................................................

..S...#............................#####..#####..#####..####G..

..#...#................................#..#...#......#..#......

..#####..####...####..####..#..#...#####..#...#..#####..#####..

..#...#..#..#...#..#..#..#..#..#...#......#...#..#..........#..

..#...#..#####..####..####..####...#####..#####..#####..#####..

................#.....#........#...............................

................#.....#........#...............................```

### 输出

```
148```

# AI分析结果



# [ABC387D] Snaky Walk

## 题目描述

给你一张地图，图中只包含起点`S`，终点`G`，障碍`#`，道路`.`。从起点出发，第一步方向任意，但之后的每一步都不能与之前相同。以这样的移动方式，求出到达终点的最少步数。

## 题目分类
`广度优先搜索 BFS`

---

## 题解综合分析

本题核心在于方向交替的移动约束，需在BFS中维护方向状态。所有题解均采用BFS框架，核心差异在于方向状态的表示方式：

1. **方向分组表示**：将移动分为横向/纵向两组，用标志位记录上一次移动方向类型
2. **四方向异或判断**：通过异或运算快速判断方向交替
3. **多维状态记录**：使用三维数组`vis[x][y][dir]`避免重复状态

最优解法采用**二维方向分组+多维状态记录**，时间复杂度为O(HW)，空间复杂度O(HW*2)。

---

## 精选题解

### 1. ikunTLE 的题解（⭐⭐⭐⭐⭐）
**核心亮点**：
- 使用横向/纵向双方向数组简化移动逻辑
- 清晰的状态切换逻辑（flag 0/1交替）
- 预处理起点双向初始状态

**关键代码**：
```cpp
struct node{ int x,y,flag; };
int dx1[]={0,0,0}, dy1[]={0,-1,1}; // 横向移动
int dx2[]={0,-1,1}, dy2[]={0,0,0}; // 纵向移动

q.push({bx,by,0}), q.push({bx,by,1}); // 初始化两个方向
while(!q.empty()) {
    node u = q.front();
    if(u.flag == 0) { // 必须纵向移动
        for(横向移动方向)...
    } else { // 必须横向移动
        for(纵向移动方向)...
    }
}
```

### 2. Liuhy2996 的题解（⭐⭐⭐⭐）
**核心亮点**：
- 四方向枚举+位运算判断交替
- 简洁的方向状态切换逻辑
- 高效的状态存储结构

**方向判断技巧**：
```cpp
for(int i=0;i<4;++i)
    if(((dir^i)&1) && chk(x+dx[i],y+dy[i],i))
        // 仅允许交替方向移动
```

### 3. _anll_ 的题解（⭐⭐⭐⭐）
**核心亮点**：
- 极简状态表示（0/1标志位）
- 统一的移动处理逻辑
- 清晰的边界条件判断

**状态转移逻辑**：
```cpp
if(p.f) { // 上次纵向，本次横向
    Push(p.x-1, p.y, 0)
    Push(p.x+1, p.y, 0)
} else {  // 上次横向，本次纵向
    Push(p.x, p.y-1, 1)
    Push(p.x, p.y+1, 1)
}
```

---

## 关键思路总结
1. **方向状态记录**：使用0/1标志位表示上次移动方向类型（横向/纵向）
2. **双向初始化**：起点需同时考虑横向/纵向两种初始状态
3. **分层BFS**：通过步数分层保证最短路径特性
4. **三维访问数组**：vis[x][y][dir] 避免重复访问同一状态

**优化技巧**：预处理横向/纵向移动方向数组，避免运行时条件判断。

---

## 拓展应用
类似方向约束问题：
1. 机器人转向问题（每次转向需冷却步数）
2. 蛇形移动问题（固定移动模式）
3. 方向受限的最短路径（如不能立即回头）

---

## 推荐练习题
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - 基础BFS应用
2. [P1126 机器人搬重物](https://www.luogu.com.cn/problem/P1126) - 带方向状态的BFS
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通块BFS变形

---

## 心得体会摘录
> "起点需要同时初始化横向和纵向两种状态，否则会漏掉最优解" —— ikunTLE  
> "方向交替的判断可以通过异或运算优化，比取模更高效" —— Liuhy2996  
> "三维vis数组比pair套pair更易维护状态" —— _anll_

调试关键：验证方向交替逻辑是否正确，特别注意起点和终点的边界情况。

---
处理用时：134.25秒
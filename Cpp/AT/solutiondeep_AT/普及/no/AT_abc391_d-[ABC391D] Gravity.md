# 题目信息

# [ABC391D] Gravity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc391/tasks/abc391_d

$ 10^9 $ 行 $ W $ 列のグリッドがあります。左から $ x $ 列目、**下から** $ y $ 行目のマスを $ (x,y) $ と表します。

$ N $ 個のブロックがあります。各ブロックは $ 1\ \times\ 1 $ の正方形で、ブロック $ i $ $ (1\ \leq\ i\ \leq\ N) $ は時刻 $ 0 $ にマス $ (X_i,Y_i) $ にあります。

時刻 $ t=1,2,\dots,10^{100} $ に、以下のルールに従ってブロックを動かします。

- グリッドの下から $ 1 $ 行目がすべてブロックで埋まっているならば、下から $ 1 $ 行目にあるブロックをすべて消滅させる。
- 残っているブロックについて、下にあるブロックから順番に、以下の操作を行う。
  - ブロックが一番下の行にある、またはそのブロックの $ 1 $ つ下のマスにもブロックがあるならば、何もしない
  - そうでなければ、ブロックを $ 1 $ つ下のマスに動かす。

$ Q $ 個の質問が与えられます。$ j $ 番目 $ (1\ \leq\ j\ \leq\ Q) $ の質問では、時刻 $ T_j+0.5 $ にブロック $ A_j $ が存在するかどうか答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ W\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ W $
- $ 1\ \leq\ Y_i\ \leq\ 10^9 $
- $ i\ \neq\ j $ なら $ (X_i,Y_i)\ \neq\ (X_j,Y_j) $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ T_j\ \leq\ 10^9 $
- $ 1\ \leq\ A_j\ \leq\ N $
- 入力はすべて整数

### Sample Explanation 1

ブロックの位置は以下のように変化します。 ![](https://img.atcoder.jp/abc391/4a6590753edcbad7ea1e8ce7f172902a.png) - 質問 $ 1 $: 時刻 $ 1.5 $ にブロック $ 1 $ は存在するので、答えは `Yes` です。 - 質問 $ 2 $: 時刻 $ 1.5 $ にブロック $ 2 $ は存在するので、答えは `Yes` です。 - 質問 $ 3 $: ブロック $ 3 $ は時刻 $ 2 $ に消滅します。よって、時刻 $ 2.5 $ にブロック $ 3 $ は存在しないので、答えは `No` です。

## 样例 #1

### 输入

```
5 3
1 1
1 2
2 2
3 2
2 3
6
1 1
1 2
2 3
2 5
3 4
3 5```

### 输出

```
Yes
Yes
No
Yes
No
Yes```

## 样例 #2

### 输入

```
3 2
1 1
2 1
1 2
4
1 1
1 2
1 3
2 3```

### 输出

```
No
No
Yes
Yes```

# AI分析结果



# [ABC391D] Gravity 重力

## 题目描述

在一个 $10^9$ 行 $W$ 列的网格中，左下角坐标为 $(1,1)$，左上角坐标为 $(W,10^9)$。每个位置 $(x,y)$ 表示左数第 $x$ 列、**从下往上数**第 $y$ 行的位置。

现有 $N$ 个 $1×1$ 的方块，第 $i$ 个方块初始位于 $(X_i,Y_i)$。每个时刻按以下规则处理方块：

1. **消除检查**：若最底层（从下往上第 1 行）所有列都有方块，则消除该行所有方块。
2. **下落过程**：从下往上遍历未消除的方块，若其下方无方块且不在最底层，则下移一格。

经过 $10^{100}$ 个时刻后，给出 $Q$ 个询问，每个询问给出时刻 $T_j$ 和方块编号 $A_j$，要求判断在 $T_j+0.5$ 时刻该方块是否存在。

## 算法标签
模拟、排序

---

## 题解综合分析

### 核心思路
所有题解均基于以下观察：
1. **分层消除**：消除操作以"层"为单位进行，每层需所有列都有方块。
2. **层数限制**：最大可消除层数为各列方块数的最小值。
3. **时间计算**：第 $k$ 层的消除时间等于该层所有方块原始纵坐标的最大值。

### 题解对比
| 题解作者       | 关键思路                                                                 | 评分 | 亮点                                                                 |
|----------------|--------------------------------------------------------------------------|------|----------------------------------------------------------------------|
| FlowerAccepted | 按列存储方块并排序，预处理每层最大纵坐标作为消除时间，二分查询位置       | ⭐⭐⭐⭐⭐ | 清晰分层处理，高效预处理，代码结构简洁                               |
| da_ke          | 使用优先队列维护各列最下方方块，逐层计算消除时间                         | ⭐⭐⭐⭐   | 直观模拟消除过程，逻辑自然易懂                                       |
| Clover_Lin     | 直接计算每层最大纵坐标，处理层间依赖关系                                 | ⭐⭐⭐⭐   | 简洁的数学建模，避免复杂数据结构                                     |

---

## 精选题解

### 题解1: FlowerAccepted（⭐⭐⭐⭐⭐）
**核心思路**：
1. 将方块按列存储并排序
2. 计算每列方块数最小值确定最大可消除层数
3. 预处理每层的最大纵坐标作为消除时间
4. 二分查询目标方块所在层数

**关键代码**：
```cpp
vector<int> v[200005]; // 按列存储已排序的方块坐标
int t[maxs]; // 存储每层消除时间

// 预处理每层最大纵坐标
for(int j=1; j<=w; j++) {
    for(int i=0; i<mins; i++) {
        t[i] = max(t[i], v[j][i]);
    }
}

// 查询处理
id = lower_bound(v[列].begin(), v[列].end(), 目标y值) - v[列].begin();
cout << (T < t[id] ? "Yes" : "No");
```

### 题解2: da_ke（⭐⭐⭐⭐）
**核心思路**：
1. 使用优先队列维护各列当前最下方方块
2. 逐层取出所有列的最下方方块
3. 取该层最大纵坐标作为消除时间

**关键代码**：
```cpp
priority_queue<...> q[W+1]; // 每列的小根堆

while(true) {
    int maxy = 0;
    // 取出所有列当前最下方方块
    for(int i=1; i<=W; i++) {
        maxy = max(maxy, q[i].top().y);
    }
    // 记录该层方块的消除时间
    for(int i=1; i<=W; i++) {
        ans[q[i].top().id] = maxy;
        q[i].pop();
    }
}
```

### 题解3: Clover_Lin（⭐⭐⭐⭐）
**核心思路**：
1. 直接计算每层最大纵坐标
2. 处理层间时间依赖关系

**关键公式**：
```
die_1 = Max(y_1层)
die_k = max(die_{k-1}, Max(y_k层))
```

---

## 关键技巧总结
1. **分层处理**：将方块按列排序后，纵向分层处理消除逻辑
2. **时间预处理**：通过计算每层最大纵坐标确定消除时间
3. **高效查询**：通过二分查找快速定位方块所在层
4. **边界处理**：利用极大值处理无法消除的方块情况

---

## 相似题目推荐
1. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156) - 分层处理时间依赖
2. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678) - 二分答案与边界处理
3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063) - 环形区间DP与层处理

---
处理用时：56.36秒
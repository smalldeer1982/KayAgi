# 题目信息

# [AGC008A] Simple Calculator

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc008/tasks/agc008_a

すぬけ君は電卓を持っています。 この電卓にはディスプレイと $ 2 $ 個のボタンが付いています。

最初、ディスプレイの値は整数 $ x $ です。 すぬけ君の目標は、ディスプレイの値を整数 $ y $ にすることです。 そのために、すぬけ君は次の $ 2 $ 個のボタンを好きな順番で何回か押すことができます。

- ボタン A : ディスプレイの値を $ 1 $ 増やす。
- ボタン B : ディスプレイの値の符号を反転する。

目標を達成するためにすぬけ君がボタンを押す回数の最小値を求めてください。 なお、整数 $ x $, $ y $ の値によらず、必ず目標を達成できることが示せます。

## 说明/提示

### 制約

- $ x $, $ y $ は整数である。
- $ |x|,\ |y|\ <\ =\ 10^9 $
- $ x $, $ y $ は相異なる。

### Sample Explanation 1

ボタン A を $ 10 $ 回押せばよいです。

### Sample Explanation 2

ボタン B を $ 1 $ 回押せばよいです。

### Sample Explanation 3

次の順でボタンを押せばよいです。 - ボタン B を $ 1 $ 回押す。 - ボタン A を $ 10 $ 回押す。 - ボタン B を $ 1 $ 回押す。

## 样例 #1

### 输入

```
10 20```

### 输出

```
10```

## 样例 #2

### 输入

```
10 -10```

### 输出

```
1```

## 样例 #3

### 输入

```
-10 -20```

### 输出

```
12```

# AI分析结果



**题目内容**

# [AGC008A] Simple Calculator

## 题目描述

すぬけ君有一个计算器，包含显示屏和两个按钮。初始时显示屏显示整数 $x$，目标是通过操作按钮使其显示整数 $y$。操作按钮的规则如下：

- **按钮A**：显示屏的值增加1。
- **按钮B**：显示屏的值取反（符号反转）。

求达成目标所需的最小操作次数。

### 样例解释

- **样例1**：输入 `10 20`，输出 `10`（按A键10次）。
- **样例2**：输入 `10 -10`，输出 `1`（按B键1次）。
- **样例3**：输入 `-10 -20`，输出 `12`（B→A按10次→B）。

---

**算法分类**：数学

---

### 题解分析与结论

#### 关键思路
最优解法基于以下观察：
1. **取反操作（B）的最优使用位置**：仅在初始或结束时使用取反操作，可以覆盖所有可能的操作路径。
2. **数学简化**：将问题转化为枚举四种可能的路径组合（初始是否取反、目标是否取反），计算每种路径的操作次数，取最小值。

#### 高分题解

1. **qbf! 的题解（⭐⭐⭐⭐⭐）**
   - **核心思路**：枚举四种可能的操作组合（初始取反/不取反，目标取反/不取反）。通过计算路径的步数，取最小值。
   - **代码亮点**：时间复杂度 $O(1)$，代码简洁，无冗余条件判断。
   ```cpp
   int main() {
       int x, y;
       scanf("%d%d", &x, &y);
       int A[] = {x, -x}, B[] = {y, -y};
       int ans = INT_MAX;
       for (int i = 0; i < 2; ++i)
           for (int j = 0; j < 2; ++j)
               if (A[i] <= B[j]) // 确保中间操作只需递增
                   ans = min(ans, i + j + (B[j] - A[i]));
       printf("%d", ans);
   }
   ```

2. **Starlight_Glimmer 的题解（⭐⭐⭐⭐）**
   - **核心思路**：定义函数 `s(x, y)` 计算基础步数，组合四种可能的路径（原路径、取反初始、取反目标、同时取反）。
   - **代码亮点**：利用数学表达式避免复杂分支，逻辑清晰。
   ```cpp
   int s(int x, int y) {
       return (x <= y) ? (y - x) : (x - y + 2);
   }
   int main() {
       int x, y;
       scanf("%d%d", &x, &y);
       int ans = min(s(x, y), min(s(-x, y) + 1, min(s(x, -y) + 1, s(-x, -y) + 2)));
       printf("%d", ans);
   }
   ```

---

### 拓展与总结

#### 关键技巧
- **操作顺序优化**：通过限制取反操作的位置（仅初始或结束），将问题转化为有限路径的最优解问题。
- **数学建模**：将操作步数转化为绝对值差和操作次数之和。

#### 类似题目推荐
1. [P1149 火柴棒等式](https://www.luogu.com.cn/problem/P1149)（枚举与数学结合）
2. [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)（数学规律分析）
3. [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)（数学分治与枚举）

---

**个人心得**  
qbf! 的题解通过枚举有限路径避免了复杂的条件分支，展现了“减少状态空间”的优化思想。在类似问题中，优先考虑操作顺序的限制往往能简化问题。

---
处理用时：72.49秒
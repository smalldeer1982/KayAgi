# 题目信息

# [AGC011A] Airport Bus

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc011/tasks/agc011_a

高橋空港には，毎日飛行機で $ N $ 人の乗客が到着します． $ i $ 番目の乗客は時刻 $ T_i $ に到着します．

高橋空港に到着する乗客は全員バスで市内へ移動します．どのバスも定員は $ C $ 人であり，$ C $ 人以下の乗客を乗せることができます． 飛行機の乗客は，飛行機の到着時刻よりも早く出発するバスには乗ることができません． また，飛行機の到着時刻から $ K $ の時間が経過した後にもバスに乗れていないと，怒り出してしまいます． そのため，$ i $ 番目の乗客は，出発時刻が $ T_i $ 以上 $ T_i\ +\ K $ 以下であるようなバスに乗れるようにしないといけません．

この条件のもとで，うまくバスの出発時刻を定めるとき，必要なバスの数の最小値を求めてください． ただし，バスの出発時刻は必ずしも整数である必要はなく，同じ時刻に出発するバスが複数あってもかまいません．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100000 $
- $ 1\ \leq\ C\ \leq\ 10^9 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ T_i\ \leq\ 10^9 $
- $ C,\ K,\ T_i $ は整数

### Sample Explanation 1

例えば，時刻 $ 4.5 $, $ 6 $, $ 12 $ にバスを出発させ，次のように乗客をバスに乗せるとよいです． - 時刻 $ 4.5 $ に出発するバスには，時刻 $ 2,\ 3 $ に到着する乗客を乗せる． - 時刻 $ 6 $ に出発するバスには，時刻 $ 1,\ 6 $ に到着する乗客を乗せる． - 時刻 $ 12 $ に出発するバスには，時刻 $ 12 $ に到着する乗客を乗せる．

## 样例 #1

### 输入

```
5 3 5

1

2

3

6

12```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3 3

7

6

2

8

10

6```

### 输出

```
3```

# AI分析结果



# [AGC011A] Airport Bus 机场巴士

## 题目描述

高桥机场每天有 $N$ 位乘客乘飞机抵达。第 $i$ 位乘客的到达时间为 $T_i$。

所有乘客需乘坐巴士前往市区。每辆巴士最多承载 $C$ 人，且乘客不能乘坐发车时间早于其到达时间的巴士。此外，若乘客在到达后 $K$ 时间内未能上车，将会引发不满。因此，第 $i$ 位乘客必须乘坐发车时间在 $[T_i, T_i+K]$ 区间内的巴士。

求满足所有乘客运输需求所需的最小巴士数量。巴士的发车时间可以是任意时刻，允许多辆巴士同时发车。

### 输入格式

第一行包含三个整数 $N, C, K$  
接下来 $N$ 行每行一个整数 $T_i$

### 输出格式

输出最小巴士数量

---

**算法分类**：贪心

## 题解对比与结论

### 题解亮点总结

1. **共同思路**：
   - 将乘客按到达时间排序
   - 贪心策略：每辆巴士尽可能承载最多乘客，直到人数满或时间窗口不允许
   - 维护当前巴士的最晚发车时间（首乘客的 $T_i+K$）和已载人数

2. **关键优化**：
   - 每辆巴士的发车时间设为当前批次首乘客的 $T_i+K$，最大化后续乘客的覆盖范围
   - 通过单次遍历实现 $O(N)$ 时间复杂度，配合排序总复杂度 $O(N \log N)$

3. **易错点**：
   - 变量初始化（如未初始化发车时间可能导致错误）
   - 边界条件处理（如最后一批乘客必须单独计数）

---

### 高分题解推荐

#### 1. 上杉越（4星）
**亮点**：
- 变量命名清晰（time/sum/ans），逻辑直观
- 循环从第二个乘客开始处理，与初始化配合自然
- 注释明确，适合初学者理解

```cpp
sort(t+1,t+n+1);
int time=t[1]+k, sum=1, ans=1;
for(int i=2; i<=n; i++){
    if(sum == c){
        ans++, sum=1;
        time = t[i]+k;
    } else {
        if(t[i] <= time) sum++;
        else {
            ans++, sum=1;
            time = t[i]+k;
        }
    }
}
```

#### 2. Xdl_rp（4星）
**亮点**：
- 使用统一循环处理所有乘客，代码紧凑
- 条件判断直接体现题目约束，可读性强
- 采用更通用的初始化方式，避免特殊值依赖

```cpp
sort(q+1, q+n+1);
int t=q[1]+k, cnt=0, ans=1;
for(int i=1; i<=n; i++){
    if(q[i] <= t && cnt < c) cnt++;
    else {
        ans++;
        cnt=1;
        t = q[i]+k;
    }
}
```

#### 3. Night_sea_64（4星）
**亮点**：
- 逆向思维先增加人数再判断，简化逻辑
- 初始值处理巧妙，避免单独处理首乘客
- 代码精简但保持高可读性

```cpp
sort(a+1,a+n+1);
int beg=-1e9, cnt=1, ans=0;
for(int i=1; i<=n; i++){
    cnt++;
    if(a[i]-beg >k || cnt>c){
        beg=a[i];
        cnt=1;
        ans++;
    }
}
```

---

## 核心思路实现

**关键步骤**：
1. 排序乘客到达时间
2. 遍历时维护当前巴士的最晚发车时间和已载人数
3. 当时间窗口或人数超限时，发车并重置计数器

**最优代码片段**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, c, k;
    cin >> n >> c >> k;
    vector<int> t(n);
    for(int i=0; i<n; ++i) cin >> t[i];
    sort(t.begin(), t.end());
    
    int buses = 1, current_count = 1;
    int deadline = t[0] + k;
    
    for(int i=1; i<n; ++i) {
        if(current_count < c && t[i] <= deadline) {
            current_count++;
        } else {
            buses++;
            current_count = 1;
            deadline = t[i] + k;
        }
    }
    cout << buses;
}
```

---

## 拓展与练习

**同类问题推荐**：
1. [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803) - 区间调度贪心
2. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019) - 差分数组与贪心结合
3. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094) - 双指针贪心策略

**思维扩展**：
- 若巴士有最大等待时间（必须发车间隔不超过某值），如何调整策略？
- 如果乘客有不同优先级，如何动态调整发车策略？
- 考虑多车站协同调度时的分布式贪心策略设计

---
处理用时：167.01秒
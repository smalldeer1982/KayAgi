# 题目信息

# [AGC012A] AtCoder Group Contest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc012/tasks/agc012_a

AtCoder Group Contestの参加者に $ 3N $ 人が参加します。 $ i $ 番目の参加者の *強さ* は整数 $ a_i $ で表されます。 参加者が $ 3 $ 人 $ 1 $ 組となるようにチームを $ N $ 組作ることにしました。$ 1 $ 人の参加者が複数のチームに所属することはできません。

チームの強さはチームメンバーの強さのうち $ 2 $ 番目に大きい値で表されます。 例えば、強さが $ 1,5,2 $ のメンバーからなるチームの強さは $ 2 $ になり、強さが $ 3,2,3 $ のメンバーからなるチームの強さは $ 3 $ になります。

$ N $ 組のチームの強さの和としてありうる値のうち、最大の値を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ a_i\ ≦\ 10^{9} $
- $ a_i $ は整数

### Sample Explanation 1

例えば以下のようにチームを作ったとき、チームの強さの和が最大となります。 - チーム $ 1 $：$ 1,4,5 $ 番目の参加者からなる。 - チーム $ 2 $：$ 2,3,6 $ 番目の参加者からなる。

### Sample Explanation 2

チームの強さの和は非常に大きくなることがあります。

## 样例 #1

### 输入

```
2

5 2 8 5 1 5```

### 输出

```
10```

## 样例 #2

### 输入

```
10

1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
10000000000```

# AI分析结果



### 中文题目重写

[题目链接](https://atcoder.jp/contests/agc012/tasks/agc012_a)

### 题目描述

AtCoder Group Contest 有 $3N$ 名参赛者，第 $i$ 名参赛者的强度为整数 $a_i$。需要将这些参赛者分成 $N$ 组，每组 3 人。每组的强度定义为该组中第二大的值。求所有组的强度之和的最大可能值。

### 输入格式
- 第一行输入整数 $N$
- 第二行输入 $3N$ 个整数表示 $a_i$

### 输出格式
输出最大可能的强度之和

### 算法分类
**贪心**

---

### 题解分析与结论

#### 核心思路
通过排序后贪心选择次大值。将数组升序排序后，从倒数第二个元素开始，每隔一个取一个元素，共取 $N$ 个元素求和。

#### 解决难点
1. **贪心策略证明**：要让每个组的次大值尽可能大，需要将较大的数作为其他组的最大值，同时保留次大值。
2. **下标处理**：排序后，最优次大值的位置为 $[2N, 2N-2, ..., 2]$（升序排列时的索引）。

#### 最优技巧
1. **排序后间隔取数**：排序后直接取特定位置的元素，时间复杂度 $O(N \log N)$。
2. **数据类型处理**：使用 `long long` 避免求和溢出。

---

### 高分题解推荐

#### 题解 1：封禁用户（5星）
**亮点**：代码简洁高效，直接体现贪心策略。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
ll n, a[300005], ans;

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= 3*n; ++i) cin >> a[i];
    sort(a + 1, a + 3*n + 1);
    for (int i = 3*n - 1; i >= n + 1; i -= 2)
        ans += a[i];
    cout << ans << "\n";
    return 0;
}
```

#### 题解 2：良辰、（5星）
**亮点**：详细注释说明边界条件，强调数据范围。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e5 + 10;
long long n, a[maxn], ans;

int main() {
    scanf("%lld", &n);
    for (int i = 1; i <= 3*n; i++) scanf("%lld", &a[i]);
    sort(a + 1, a + 1 + 3*n);
    for (int i = 3*n - 1; i >= n + 1; i -= 2)
        ans += a[i];
    printf("%lld\n", ans);
}
```

#### 题解 3：kaceqwq（4星）
**亮点**：代码简洁，使用宏定义简化代码。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[300001], n, ans;

signed main() {
    cin >> n;
    for (int i = 1; i <= 3*n; i++) cin >> a[i];
    sort(a + 1, a + 3*n + 1);
    for (int i = 3*n - 1; i >= n + 1; i -= 2)
        ans += a[i];
    cout << ans << '\n';
}
```

---

### 拓展与总结

#### 关键思路总结
排序后间隔选取次大值是最优策略，本质是将较大的数作为其他组的最大值，最大化每组次大值。

#### 相似题目推荐
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（贪心排序）
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)（双指针贪心）
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)（单调栈贪心）

#### 调试经验
- **数据范围**：必须使用 `long long` 存储结果。
- **边界验证**：当 $N=1$ 时，选取排序后倒数第二个元素即可。

---
处理用时：164.92秒
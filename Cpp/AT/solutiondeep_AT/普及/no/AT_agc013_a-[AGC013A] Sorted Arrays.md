# 题目信息

# [AGC013A] Sorted Arrays

## 题目描述

## 题目翻译

给出长度为N的数列A，你需要把A划分成几个连续子串，要求每个子串都为单调不降子串或单调不升子串，求子串的最少个数。

## 样例 #1

### 输入

```
6

1 2 3 2 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
9

1 2 1 2 1 2 1 2 1```

### 输出

```
5```

## 样例 #3

### 输入

```
7

1 2 3 2 1 999999999 1000000000```

### 输出

```
3```

# AI分析结果



### 题目中文翻译

#### [AGC013A] Sorted Arrays

**题目描述**  
给出长度为 \( N \) 的数列 \( A \)，你需要将 \( A \) 划分成若干个连续子串，要求每个子串为单调不降或单调不升子串。求最少能划分成多少个子串。

**样例 #1**  
输入：  
```
6  
1 2 3 2 2 1  
```  
输出：  
```
2  
```  

**样例 #2**  
输入：  
```
9  
1 2 1 2 1 2 1 2 1  
```  
输出：  
```
5  
```  

**样例 #3**  
输入：  
```
7  
1 2 3 2 1 999999999 1000000000  
```  
输出：  
```
3  
```  

---

### 算法分类  
**贪心**

---

### 题解分析与结论  
题目要求将数列划分为最少的连续单调子串。核心思路是贪心策略：尽可能延长当前子串的长度，直到无法继续按当前单调方向延伸为止。关键优化点在于处理连续相等的元素（合并或跳过），将问题简化为仅处理严格递增/递减的相邻元素，从而更容易判断方向变化。

---

### 精选题解与评分  

#### 1. xieyikai2333 的题解（⭐️⭐️⭐️⭐️⭐️）  
**关键亮点**：  
- **去重预处理**：合并连续相等元素，简化后续判断逻辑。  
- **状态标记法**：用 `flag` 表示当前子串类型（上升、下降或未定），动态调整分割点。  
- **代码简洁高效**：时间复杂度 \( O(n) \)，逻辑清晰。  

**核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005];
int main() {
    int n, tot = 1, flag = 2, ans = 1;
    scanf("%d %d", &n, &a[1]);
    for (int i = 2; i <= n; i++) {
        int x;
        scanf("%d", &x);
        if (x != a[tot]) a[++tot] = x;
    }
    for (int i = 2; i <= tot; i++) {
        if (flag == 2) flag = (a[i - 1] > a[i]);
        else if (flag != (a[i - 1] > a[i])) flag = 2, ans++;
    }
    printf("%d", ans);
    return 0;
}
```  
**实现思路**：  
1. 去重：合并连续相等的元素，生成新数组。  
2. 遍历新数组，用 `flag` 跟踪当前子串类型。  
3. 方向变化时分割子串，更新答案。  

#### 2. Su_Zipei 的题解（⭐️⭐️⭐️⭐️）  
**关键亮点**：  
- **实时跳过相等元素**：在输入时直接跳过连续相等的元素。  
- **状态维护**：用 `typ` 标记当前子串类型，动态决定是否分割。  

**核心代码**：  
```cpp
int main() {
    int n, typ = 0, lst, res = 1;
    scanf("%d", &n);
    scanf("%d", &lst);
    for (int i = 2; i <= n; i++) {
        int x;
        scanf("%d", &x);
        if (x == lst) continue;
        if (typ == 0) {
            typ = (x > lst) ? 1 : 2;
            lst = x;
        } else if (typ == 1) {
            if (x < lst) res++, typ = 0, lst = x;
            else lst = x;
        } else {
            if (x > lst) res++, typ = 0, lst = x;
            else lst = x;
        }
    }
    printf("%d\n", res);
    return 0;
}
```  
**实现思路**：  
1. 实时处理输入，跳过连续相等的元素。  
2. 维护 `typ` 状态，方向变化时分割子串。  

---

### 关键思路总结  
1. **预处理优化**：合并连续相等元素或实时跳过，简化方向判断。  
2. **贪心策略**：每次尽可能延长当前子串，方向变化时立即分割。  
3. **状态标记**：用变量跟踪当前子串类型（上升/下降/未定）。  

---

### 类似题目推荐  
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)  
2. [P1563 玩具谜题](https://www.luogu.com.cn/problem/P1563)  
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)  

---

### 个人心得摘录  
- **xieyikai2333**：通过去重预处理，将复杂问题转化为相邻元素严格变化的场景，极大简化逻辑。  
- **Su_Zipei**：实时跳过相等元素的技巧，避免额外存储空间，提升代码效率。  
- **统一教训**：处理单调性问题时，合并或跳过相等元素是关键优化点，能显著降低实现复杂度。

---
处理用时：113.78秒
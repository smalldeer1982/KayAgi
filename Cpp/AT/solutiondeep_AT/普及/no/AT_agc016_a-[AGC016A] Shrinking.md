# 题目信息

# [AGC016A] Shrinking

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc016/tasks/agc016_a

すぬけ君は、次のルールに従い、長さ $ N $ の文字列 $ t $ を長さ $ N\ -\ 1 $ の文字列 $ t' $ へ変えることができます。

- 各 $ i $ ($ 1\ <\ =\ i\ <\ =\ N\ -\ 1 $) について、$ t' $ の $ i $ 文字目は $ t $ の $ i $, $ i\ +\ 1 $ 文字目のどちらかである。

英小文字のみからなる文字列 $ s $ があります。 すぬけ君の目標は、$ s $ に上記の操作を繰り返し行い、$ s $ が単一の文字のみからなるようにすることです。 目標を達成するために必要な操作回数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ |s|\ <\ =\ 100 $
- $ s $ は英小文字のみからなる。

### Sample Explanation 1

例えば、`serval` → `srvvl` → `svvv` → `vvv` と変えればよいです。

### Sample Explanation 2

例えば、`jackal` → `aacaa` → `aaaa` と変えればよいです。

### Sample Explanation 3

最初から $ s $ が単一の文字のみからなっています。

### Sample Explanation 4

$ 8 $ 回の操作によって、$ s $ を `rrrrrrrrrrrrrrrrrr` へ変えることができます。

## 样例 #1

### 输入

```
serval```

### 输出

```
3```

## 样例 #2

### 输入

```
jackal```

### 输出

```
2```

## 样例 #3

### 输入

```
zzz```

### 输出

```
0```

## 样例 #4

### 输入

```
whbrjpjyhsrywlqjxdbrbaomnw```

### 输出

```
8```

# AI分析结果



# [AGC016A] Shrinking 中文翻译

## 题目描述

有一个长度为 $N$ 的字符串 $t$，可以通过以下规则缩短为长度为 $N-1$ 的字符串 $t'$：
- 对于每个 $i$（$1 \leq i \leq N-1$），$t'$ 的第 $i$ 个字符是 $t$ 的第 $i$ 或第 $i+1$ 个字符。

给定一个由小写字母组成的字符串 $s$，求通过重复上述操作使 $s$ 变为全相同字符所需的最小操作次数。

## 样例解释
- 样例1：`serval` → `srvvl` → `svvv` → `vvv`（3次）
- 样例2：`jackal` → `aacaa` → `aaaa`（2次）
- 样例3：`zzz` 已经是全相同字符（0次）
- 样例4：经过8次操作可变为全 `r` 的字符串

## 算法分类
贪心

---

### 题解分析与结论
**核心思路**：  
最优解法是枚举每个可能的最终字符 $c$，计算将该字符扩散到整个字符串所需的最大间隔，最终取所有字符的最小值。  
**关键技巧**：  
- 预处理每个字符出现的位置，计算相邻位置的最大间隔
- 处理字符串首尾的虚拟位置，确保覆盖边界情况

---

### 精选题解
#### 题解3（Butterfly___qwq） ★★★★★  
**亮点**：  
- 简洁高效（O(26*N)）
- 巧妙处理边界：通过 `N - lst[x]` 计算末尾段的长度
- 无需修改原字符串，避免潜在错误  

**核心代码**：  
```cpp
int main() {
    scanf("%s", S + 1); N = strlen(S + 1);
    for (int i = 1; i <= N; ++i) {
        int x = S[i] - 'a';
        ans[x] = max(ans[x], i - lst[x] - 1); // 相邻字符间隔
        lst[x] = i; // 记录最后出现位置
    }
    int tans = N;
    for (int x = 0; x < 26; ++x)
        tans = min(tans, max(ans[x], N - lst[x])); // 处理末尾段
    printf("%d\n", tans);
}
```

---

### 拓展与举一反三
**类似题目**：  
1. [P1071 潜伏者](https://www.luogu.com.cn/problem/P1071)（字符串覆盖分析）
2. [P1321 单词覆盖还原](https://www.luogu.com.cn/problem/P1321)（字符扩散模型）
3. [CF1328C Ternary XOR](https://www.luogu.com.cn/problem/CF1328C)（贪心处理字符序列）

**总结心得**：  
- 处理字符串问题时，虚拟首尾位置能有效简化边界判断
- 贪心策略中，关注极值（最大间隔）往往是解题关键

---
处理用时：65.78秒
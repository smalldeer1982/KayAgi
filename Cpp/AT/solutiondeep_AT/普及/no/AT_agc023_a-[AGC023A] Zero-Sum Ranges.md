# 题目信息

# [AGC023A] Zero-Sum Ranges

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc023/tasks/agc023_a

長さ $ N $ の整数列 $ A $ があります。

$ A $ の **空でない** **連続する** 部分列であって、その総和が $ 0 $ になるものの個数を求めてください。 ただし、ここで数えるのは **部分列の取り出し方** であることに注意してください。 つまり、ある $ 2 $ つの部分列が列として同じでも、取り出した位置が異なるならば、それらは別々に数えるものとします。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ -10^9\ \leq\ A_i\ \leq\ 10^9 $
- 入力はすべて整数である。

### Sample Explanation 1

空でない連続した部分列であって、その総和が $ 0 $ になるのは、$ (1,3,-4) $, $ (-4,2,2) $, $ (2,-2) $ の $ 3 $ つです。

### Sample Explanation 2

この例では、列として同じだが取り出す位置の異なる部分列が複数回数えられています。 例えば、$ (1,-1) $ は $ 3 $ 回数えられています。

### Sample Explanation 3

空でない連続した部分列であって、その総和が $ 0 $ になるものはありません。

## 样例 #1

### 输入

```
6

1 3 -4 2 2 -2```

### 输出

```
3```

## 样例 #2

### 输入

```
7

1 -1 1 -1 1 -1 1```

### 输出

```
12```

## 样例 #3

### 输入

```
5

1 -2 3 -4 5```

### 输出

```
0```

# AI分析结果



### 题目中文重写
[AGC023A] Zero-Sum Ranges

**题目描述**  
给定长度为 $N$ 的整数序列 $A$，求其中所有**非空连续子序列**满足子序列元素之和为 $0$ 的个数。注意：即使子序列元素相同，只要选取的区间位置不同，就算作不同的子序列。

**输入格式**  
第一行输入整数 $N$，第二行输入 $N$ 个整数 $A_1 \sim A_N$。

**输出格式**  
输出满足条件的子序列个数。

**样例解释**  
样例1中符合条件的子序列有 3 个：(1,3,-4)、(-4,2,2)、(2,-2)；样例2中相同元素不同位置的子序列会被重复计数；样例3中无符合条件的子序列。

**数据范围**  
$1 \leq N \leq 2 \times 10^5$，$-10^9 \leq A_i \leq 10^9$。

---

### 算法分类
**前缀和**

---

### 题解综合分析与结论
题目核心是快速统计满足区间和为零的连续子序列数量。所有优质题解均采用前缀和+哈希表的思路：
1. **前缀和性质**：区间 $[i,j]$ 和为 $0$ 等价于前缀和 $sum[j] = sum[i-1]$
2. **哈希表统计**：用哈希表记录每个前缀和值出现的次数，遍历时累加当前前缀和的历史出现次数
3. **初始条件处理**：需预先将 $sum[0]=0$ 加入哈希表，处理从数组开头开始的合法区间

---

### 高分题解选录（≥4星）

#### 1. fish_love_cat（5星）
**关键亮点**  
- 代码简洁，核心逻辑仅需 8 行
- 正确初始化哈希表 `mapp[0] = 1`，完美处理前缀和为 0 的特殊情况
- 时间复杂度 $O(n \log n)$，空间优化到 $O(n)$

**核心代码**  
```cpp
map<long long,int> mapp;
long long sum = 0, ans = 0;
int main() {
    mapp[0] = 1; // 关键初始化
    for (int i=1; i<=n; i++) {
        sum += x; // 累加前缀和
        ans += mapp[sum]++; // 等价于 ans += mapp[sum]; mapp[sum]++
    }
}
```

#### 2. shenbairui（4星）
**关键亮点**  
- 无冗余代码，逻辑清晰展现核心思想
- 正确使用 `mapp[sum]++` 的简洁写法替代分步操作
- 注释强调关键点"好习惯"，体现编码规范意识

**代码特色**  
```cpp
mapp[0] = 1; // 初始空区间和
sum += x;
ans += mapp[sum] - 1; // 当前贡献 = 历史出现次数
mapp[sum]++;
```

#### 3. CQ_Bab（4星）
**创新点**  
- 使用 `res += mp[s[i]]++` 单行实现累加与更新
- 代码极致压缩但保持可读性
- 注释"若何为0也可以"体现对边界条件的深入理解

**代码片段**  
```cpp
rep(i,1,n) cin>>a[i], res += mp[s[i]+=s[i-1]]++;
```

---

### 最优思路总结
**关键技巧**  
- **前缀和转换**：将区间和问题转化为相等前缀和匹配问题
- **哈希表计数**：用 `map` 或 `unordered_map` 动态维护前缀和出现次数
- **初始值处理**：预先插入 `sum[0] = 0` 的计数
- **数学推导**：每出现 $k$ 次相同前缀和，新增 $\binom{k}{2} = k(k-1)/2$ 个合法区间

**易错点**  
- 未处理初始前缀和导致漏算从第一个元素开始的合法区间
- 未使用 `long long` 导致整型溢出
- 未考虑哈希表查询的时间复杂度，选择 `unordered_map` 可优化至 $O(n)$

---

### 拓展与相似题目
**同类题型推荐**  
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115) - 前缀和极值应用  
2. [P3131 Subsequences Summing to Sevens](https://www.luogu.com.cn/problem/P3131) - 前缀和模数统计  
3. [P1865 区间质数](https://www.luogu.com.cn/problem/P1865) - 前缀和预处理技巧  

**算法扩展**  
此解法可推广至求区间和为任意定值 $k$ 的问题，只需将条件改为 $sum[j] = sum[i-1] + k$，哈希表记录 $sum[j]-k$ 的出现次数。

---
处理用时：56.41秒
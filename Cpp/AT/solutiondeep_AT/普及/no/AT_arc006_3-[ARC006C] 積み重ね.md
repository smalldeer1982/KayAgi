# 题目信息

# [ARC006C] 積み重ね

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc006/tasks/arc006_3

 高橋君はもう大人なので、親元を離れて一人暮らしをすることにしました。トラックから引越し先の部屋へと荷物のダンボールを運びたいのですが、部屋の床がダンボールで埋まってしまうと、今日高橋君が寝るための布団がひけません。  
 そこで、$ 1 $ 箱ずつ広げて置くのではなく、ある程度ダンボールを積み重ねた山を作ることにしました。しかし、ダンボールには重さが決まっており、下にあるダンボールよりも重いダンボールを上に積み重ねると下のダンボールが潰れてしまいます。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc006_3/330a155330da3a362b0b8091145394d207d35d61.png)図：下にあるダンボールは上にあるダンボール以上の重さでなければならない

 

   
 トラックから運ぶ順にダンボールの重さが与えられるので、ダンボールを潰さないような積み重ね方を考えなさい。そして、その積み重ねた山の個数が最小となる場合の山の個数を求めなさい。 入力は以下の形式で標準入力から与えられる。 > $ N $ $ w_1 $ $ w_2 $ : : $ w_N $

- 入力は $ N+1 $ 行ある。
- $ 1 $ 行目には、ダンボールの個数を表す整数 $ N(1≦N≦50) $ が与えられる。
- $ 2 $ 行目からの $ N $ 行には、$ i+1(1≦i≦N) $ 行目に $ i $ 番目に運ぶダンボールの重さを表す整数 $ w_i(1≦w_i≦100,000) $ が与えられる。

 ダンボールを順番に運び、上のダンボールが下のダンボールと同じ重さまたはそれよりも軽くなるように積み重ねたときに、できるダンボールの山の数の最小値を標準出力に $ 1 $ 行で出力せよ。  
 なお、最後には改行を出力せよ。 ```

5
4
3
1
2
1
```

 ```

2
```

- 下図の例の順に積み重ねると、$ 2 $ つのダンボールの山ができる。
- $ 3 $ 番目のダンボールの次に重さ $ 2 $ のダンボールをその上に重ねることはできないので $ 1 $ つの山にすることはできず、最小は $ 2 $ となる。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc006_3/5cdad1a3c2b4df6c6e3065e4cf34b9c2180d2f93.png)

 ```

7
93
249
150
958
442
391
25
```

 ```

3
```

- 下図の形に積み重ねると、山の数は $ 3 $ となる。
訂正：下図の225のダンボールは25の誤りです。申し訳ありません。


 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc006_3/87e99baa40b995194b9f08a6b6727576d861b3de.png)

 ```

4
100
100
100
100
```

 ```

1
```

- 同じ重さのダンボールは積み重ねられるので、$ 1 $ つの山にすることができる。
 
```

6
5
10
15
20
25
30
```

 ```

6
```

- どのダンボールも前に運んだダンボールの上に重ねられないので、$ 1 $ つも積み重ねることができない。
- したがって、$ 6 $ つの山が最小となる。
 
```

15
3
1
4
1
5
9
2
6
5
3
5
8
9
7
9
```

 ```

6
```

- 下図のように積み重ねると最小となる。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc006_3/6ff699ef802388c8a1126c225e6825673732bcea.png)

# AI分析结果



# [ARC006C] 積み重ね

## 题目翻译
高桥君需要将按顺序运来的 $N$ 个纸箱堆叠成若干堆，要求每个堆中下方的纸箱重量必须大于等于上方的纸箱。求最少能形成多少个堆。

**输入格式**  
- 第1行：整数 $N$  
- 第2~N+1行：每个纸箱的重量 $w_i$

**输出格式**  
- 最小堆数

**样例说明**  
当输入为 `5 4 3 1 2 1` 时，最优堆叠方式形成2堆，如[4,3,1]和[2,1]。

## 算法分类
贪心

---

## 题解分析与关键思路

### 核心算法思路
维护每个堆顶的重量值，对于每个新元素，寻找第一个可以放置的堆顶（当前元素 ≤ 堆顶），更新该堆顶为新元素值；若无法放置则新建堆。该策略通过贪心思想保证每次尽可能复用已有堆，达到最小化堆数的目的。

### 最优题解亮点

#### 题解作者：liuyi0905（4星）
**关键亮点**  
- 使用数组维护堆顶，初始化首元素为极大值避免边界判断
- 代码简洁，时间复杂度 $O(n^2)$ 完全满足 $n≤50$ 的限制
- 明确处理AT平台换行输出要求

**核心代码**  
```cpp
int main(){
    x[1] = 1e9;  // 初始极大值
    cin >> n;
    for(int i=1; i<=n; i++){
        bool flag = false;
        cin >> a;
        for(int j=1; j<=m; j++)
            if(a <= x[j]) { x[j] = a; flag=1; break; }
        if(!flag) x[++m] = a;
    }
    cout << m << "\n";
}
```

#### 题解作者：yhylivedream（4星）
**关键亮点**  
- 使用vector容器动态维护堆顶，代码更易扩展
- 初始压入极大值，避免特判首元素
- 现代C++风格，可读性强

**核心代码**  
```cpp
vector<int> v{1e9};  // 初始容器含极大值
for(int i=1; i<=n; i++){
    bool p = false;
    for(int j=0; j<v.size(); j++){
        if(v[j] >= a[i]) { v[j] = a[i]; p = true; break; }
    }
    if(!p) v.push_back(a[i]);
}
```

#### 题解作者：Deuteron（3星）
**优化思路**  
- 提到堆顶数组的单调性可优化搜索（虽未实现但思路正确）
- 正确实现基础贪心逻辑

---

## 拓展与技巧
1. **复杂度优化**：当数据规模较大时（如 $n≤1e5$），可将堆顶数组维护为有序序列，使用二分查找找到第一个可放置位置，时间复杂度优化至 $O(nlogn)$。
2. **同类问题**：与导弹拦截问题（最少拦截系统数）完全等价。
3. **调试技巧**：初始堆顶必须设置为极大值，否则首元素无法正确处理。

---

## 推荐练习
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 完全相同的贪心模型
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心策略+优先队列
3. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233) - 二维条件贪心

---
处理用时：62.81秒
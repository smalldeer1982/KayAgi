# 题目信息

# [ARC010B] 超大型連休

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc010/tasks/arc010_2

$ 2011 $ 年、$ AtCoder $ 国の高橋首相はある重大な決定を行った。  
 その決定とは...法改正である。国民の祝日に関する法律を変更し、休日を増やすことにした!!  
 国民の創造性を尊重するその決定が、霞が関を魔境へと変えたッ！  
  
 あなたは霞が関の国土交通省に勤務する職員であり、この法改正により上司から新たな任務を与えられた。  
 その任務とは、$ 2012 $ 年の「連休の最大日数」を計算することである。  
 連休の大きさを事前に計算することで国民の行動を予想し、高速道路の部分的な値下げを行い、経済を活性させるためだ。  
 したがって、あなたに失敗することは許されない。国民の行動を正確に予想できなくなるからだ。  
  
 以下に、「連休」の定義と諸注意を記す。

1. $ AtCoder $ 国が使用する暦は[グレゴリオ暦](http://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AC%E3%82%B4%E3%83%AA%E3%82%AA%E6%9A%A6)に従う。
2. 「連休」とは、「休日」が連続して続くことである。
3. 「土曜日」「日曜日」「祝日」「振替休日」が「休日」に相当する。
4. 「祝日」が他の休日と同じ日に指定されていた場合、「振替休日」を必ず設置する。
5. 「振替休日」は祝日の時系列順に決定していき、その祝日以降最も近い平日（休日を除いた日）となる。
6. $ 2012 $ 年 $ 1 $ 月 $ 1 $ 日は日曜日である。
 
 入力は以下の形式で標準入力から与えられる。 > $ N $ $ m_{1} $/$ d_{1} $ $ m_{2} $/$ d_{2} $ $ : $ $ : $ $ m_{n} $/$ d_{n} $

- $ 1 $ 行目には祝日の日数を表す整数 $ N $ が与えられ、 $ 0≦N≦366 $ を満たす。
- $ 2 $ 行目から $ N+1 $ 行目までの $ N $ 行で祝日の日付が与えられる。

1. $ m_{i} $ は $ i(1≦i≦366) $ 番目に与えられる祝日の月で、 $ 1≦m_{i}≦12 $ を満たす。
2. $ d_{i} $ は $ i(1≦i≦366) $ 番目に与えられる祝日の日で、
1. $ m_{i}\ =\ 2 $ のとき、 $ 1≦d_{i}≦29 $ を満たす。
2. $ m_{i}\ =\ (4,\ 6,\ 9,\ 11) $ のとき、 $ 1≦d_{i}≦30 $ を満たす。
3. $ m_{i}\ =\ (1,\ 3,\ 5,\ 7,\ 8,\ 10,\ 12) $ のとき、 $ 1≦d_{i}≦31 $ を満たす。

4. $ m_{i} $ と $ d_{i} $ はともに整数である。
5. $ m_{i} $ と $ d_{i} $ は必ず`/`で区切られて与えられる。
6. 祝日は時系列順に与えられるとは限らないことに注意せよ。ただし、同じ日付が複数与えられないことは保証されている。
 
 法改正後における $ 2012 $ 年の連休の最大日数を出力せよ。  
 出力は標準出力におこない、末尾には改行をいれること。  
```

1
1/9
```

 ```

3
```

- 1/7(土),1/8(日),1/9(月)の $ 3 $ 連休が最長です。
 
```

1
1/10
```

 ```

2
```

- 1/10(火)が祝日となり、1/7(土),1/8(日)などの $ 2 $ 連休が最長です。
 
```

1
1/7
```

 ```

3
```

- 1/7は土曜日なので、以降で最も近い平日である1/9が振替休日になります。
- よって、1/7(土)、1/8(日)、1/9(月)の3連休が最長です。
 
```

2
1/7
1/9
```

 ```

4
```

- 1/7は土曜日なので振替休日を以降に設定したく、1/9が祝日なので1/10が振替休日になります。
- よって、1/7(土)、1/8(日)、1/9(月)、1/10(火)の4連休が最長です。

# AI分析结果



# [ARC010B] 超大型連休

## 题目重述
$ 2012 $ 年，AtCoder 国修改了假日法。要求计算该年最长连休天数。连休定义为连续的休息日，包括周六、周日、法定假日及补休。当法定假日与休息日重叠时，需设置补休至后续最近的平日。

输入 $ N $ 个法定假日（可能乱序），输出最长连续休息天数。

**输入格式**：首行为 $ N $，后续 $ N $ 行给出月/日格式的假日。  
**输出格式**：最大连续休息日数。

## 算法分类
模拟

## 题解综合分析
所有题解均采用相同的核心思路：预处理日期映射→标记初始周末→处理假日补休→统计最长连续区间。关键难点在于正确处理补休逻辑和日期转换。

### 关键共性思路
1. **日期转换**：使用前缀和数组将月/日转换为年度第几天
2. **补休处理**：当假日与现有休息日重叠时，向后搜索首个非休息日设为补休
3. **闰年处理**：2012年为闰年，2月按29天计算
4. **连续统计**：遍历标记数组时维护当前连续计数，遇断点则更新最大值

## 精选题解

### 题解1：封禁用户（⭐⭐⭐⭐⭐）
**亮点**：  
- 完整处理闰年验证逻辑
- 模块化函数划分清晰（预处理/补休处理/统计）
- 注释详细说明日期转换原理

**核心代码**：
```cpp
for (int i=1; i<=12; i++) month[i]=month[i-1]+mouth[i]; // 月前缀和

for (int i=1; i<=366; i++) // 标记周末
    if (!(i%7) || i%7==1) rest[i]=true; 

// 处理假日补休
if (rest[kth_date]) {
    for (int i=kth_date+1; i<=366; i++)
        if (!rest[i]){ rest[i]=true; break; }
}
else rest[kth_date]=true;
```

### 题解2：SuperCowHorse（⭐⭐⭐⭐）
**亮点**：
- 输入处理使用 scanf 精确解析格式
- 独立验证了2012年1月1日为周日
- 代码简洁无冗余

**调试心得**：
> "注意最后可能遗漏末尾的连续区间，需要额外取max(ans, now)"

**关键优化**：
```cpp
ans = max(ans, now); // 处理结尾连续情况
```

## 最优思路提炼
1. **日期映射技巧**：通过前缀和数组快速计算任意日期的年度序数
```cpp
int kth = month[m-1] + d; // month为各月累积天数数组
```
2. **补休处理范式**：向后线性搜索首个非休日
```cpp
for(int j = current_day + 1; j <= 366; j++)
    if(!rest[j]) { rest[j] = true; break; }
```
3. **连续区间极值**：双变量法维护当前连续值与历史最大值
```cpp
int maxd = 0, real = 0;
for (int i=1; i<=366; i++){
    if (rest[i]) maxd++;
    else { real = max(real, maxd); maxd = 0; }
}
real = max(real, maxd); // 关键！
```

## 拓展训练
1. **日期计算类**：  
   - 洛谷 P1518 [天数计算](https://www.luogu.com.cn/problem/P1518)
   - 洛谷 P1059 [排座椅](https://www.luogu.com.cn/problem/P1059)（区间处理）
2. **连续极值统计**：  
   - 洛谷 P3406 [海底高铁](https://www.luogu.com.cn/problem/P3406)（差分+前缀和）

## 心得体会
- **闰年验证**：2012年需特殊处理2月天数（前缀和数组包含29天）
- **边界处理**：补休可能设置在年末（如12月31日后的补休不存在）
- **输入陷阱**：假日输入无序，但需转换为统一序数处理
- **调试关键**：打印rest数组验证假日与补休标记是否正确

---
处理用时：49.68秒
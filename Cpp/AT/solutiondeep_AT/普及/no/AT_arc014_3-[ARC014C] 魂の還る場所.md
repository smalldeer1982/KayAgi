# 题目信息

# [ARC014C] 魂の還る場所

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc014/tasks/arc014_3

高橋君が大好きなプラスチック製の円筒と不思議な赤青緑$ 3 $色のボールがある。  
 このボールはぎりぎり円筒に入れることができる大きさである。  
 円筒の両端を便宜上、右と左と呼ぶことにすると、左右好きな方からボールを入れることができる。  
 このボールは同じ色のボールと接触すると消える性質を持っている。  
 さらに、これら $ 3 $ 色の複数個のボールを入れる順番のみが決まっている時、それぞれのボールを左右のどちらから入れるかによって全てのボールを入れ終わった後に残るボールの数が変化する。  
  
 $ 3 $ 色の複数個のボールを入れる順番のみが与えられ、最後に円筒に残るボールの数が最小になるよう計画したとき、円筒に残るボール数の最小値を答えよ。  
 入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $

1. $ 1 $ 行目にはボールの数を表す整数 $ N(1≦N≦50) $ が与えられる。
2. $ 2 $ 行目には入れるボールの順番 $ S $ が与えられ、 $ R $ は赤、 $ G $ は緑、 $ B $ は青色のボールを表す。 $ S $ は $ R,\ G,\ B $ の $ 3 $ 種類の文字のみが $ N $ 文字で構成される。

- $ 1≦N≦15 $ を満たす入力にのみ正解した場合、部分点として $ 30 $ 点が与えられる。
 
 最後に残るボールの数が最小になるように計画を行った時、その残る最小の数を $ 1 $ 行で出力すること。  
 また、出力の最後には改行をいれること。 ```
<pre class="prettyprint linenums">
9
RGBGGBGBR
```

 ```
<pre class="prettyprint linenums">
1
```

- まず $ R $ を入れる。 $ R $
- 次に $ G $ を左から入れる。 $ GR $
- $ B $ を右から入れる。 $ GRB $
- $ G $ を右から入れる。 $ GRBG $
- $ G $ を右から入れる。 $ GRBGG $
- この時 $ G $ が揃うので消える。 $ GRB $

- $ B $ を右から入れる。 $ GRBB $
- この時 $ B $ が揃うので消える。 $ GR $

- $ G $ を左から入れる。 $ GGR $
- この時 $ G $ が揃うので消える。 $ R $

- $ B $ を左から入れる。 $ BR $
- $ R $ を右から入れる。 $ BRR $
- この時 $ R $ が揃うので消える。 $ B $

- よって $ B $ が$ 1 $つ残るので、答えは$ 1 $である。

```
<pre class="prettyprint linenums">
6
RGBRGB
```

 ```
<pre class="prettyprint linenums">
0
```

# AI分析结果



【中文重写题目】
# [ARC014C] 魂之归还之所

## 题目描述

高桥君有一个塑料圆筒和红、绿、蓝三种颜色的球。球的大小刚好可以放入圆筒。圆筒的两端分别称为左端和右端，每次可以选择从任意一端放入球。当两个同色球接触时，这两个球会消失。给定放入球的颜色顺序，求通过选择最优的放入方向（左或右）后，圆筒中剩余球的最小数量。

输入格式：
- 第一行：整数N（1≤N≤50），表示球的数量。
- 第二行：长度为N的字符串S，由R、G、B组成，表示球的颜色顺序。

输出格式：
- 输出剩余球的最小数量。

样例1解释：通过合理选择放入方向，最终剩余1个球。

---

【算法分类】
动态规划（记忆化搜索）

---

【题解分析与结论】

题目要求通过选择球的放入方向，使得最终剩余球数最少。由于每次插入可能引发连续消除，需模拟消除过程，并记录各状态的最小剩余数。

关键思路：
1. **消除规则模拟**：每次插入后，扫描整个序列，消除相邻同色对，直至无法消除。
2. **记忆化搜索**：记录处理到第k个球时的当前序列状态（字符串形式），递归尝试左右插入，取最小值。
3. **状态压缩**：通过消除后的字符串唯一标识状态，避免重复计算。

解决难点：
- 消除过程的连锁反应需精确模拟。
- 状态空间较大，需通过高效哈希和缓存优化。

---

【评分较高题解与核心代码】

### 题解思路（五星）
**关键亮点**：
- 使用记忆化搜索结合消除函数，精确处理所有可能状态。
- 通过消除后的字符串哈希优化状态存储。

```python
from functools import lru_cache

def eliminate(s):
    s = list(s)
    changed = True
    while changed:
        changed = False
        new_s = []
        i = 0
        n = len(s)
        while i < n:
            if i < n-1 and s[i] == s[i+1]:
                # 消除相邻同色对
                changed = True
                i += 2
            else:
                new_s.append(s[i])
                i += 1
        s = new_s
    return ''.join(s)

def main():
    import sys
    N = int(sys.stdin.readline())
    S = sys.stdin.readline().strip()

    @lru_cache(maxsize=None)
    def dfs(k, current):
        if k == N:
            return len(current)
        c = S[k]
        # 尝试插入左边
        left = eliminate(c + current)
        res_left = dfs(k+1, left)
        # 尝试插入右边
        right = eliminate(current + c)
        res_right = dfs(k+1, right)
        return min(res_left, res_right)
    
    print(dfs(0, ''))

if __name__ == "__main__":
    main()
```

---

【举一反三】

类似题目：
1. [P1312 Mayan游戏](https://www.luogu.com.cn/problem/P1312) - 复杂消除规则的状态搜索。
2. [P2324 祖玛](https://www.luogu.com.cn/problem/P2324) - 插入与消除策略。
3. [P2543 [AHOI2004] 数字迷阵](https://www.luogu.com.cn/problem/P2543) - 动态规划与状态压缩。

---
处理用时：553.43秒
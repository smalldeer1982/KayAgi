# 题目信息

# [ARC030B] ツリーグラフ

## 题目描述

### 题目大意

给定一棵 $n$ 无权树，树上每个结点有 $0$ 或 $1$ 个宝石，求从结点 $x$ 出发拿到所有宝石再回到 $x$ 的最短路径。

## 样例 #1

### 输入

```
5 1

1 0 1 0 1

1 2

2 3

2 4

1 5```

### 输出

```
6```

## 样例 #2

### 输入

```
3 2

0 1 0

1 2

2 3```

### 输出

```
0```

# AI分析结果



# [ARC030B] 树形图

## 题目描述

### 题目大意
给定一棵 $n$ 个节点的无权树，树上每个结点有 $0$ 或 $1$ 个宝石，求从结点 $x$ 出发拿到所有宝石再回到 $x$ 的最短路径。

## 样例 #1

### 输入
```
5 1
1 0 1 0 1
1 2
2 3
2 4
1 5
```

### 输出
```
6
```

## 样例 #2

### 输入
```
3 2
0 1 0
1 2
2 3
```

### 输出
```
0
```

**算法分类**：深度优先搜索 DFS

---

## 题解综合分析

所有题解均采用**树形DFS遍历**思想，核心在于识别必须遍历的边。最优思路为：**仅统计必经路径的边数，最后乘2得到往返总长度**。

### 精选题解

1. **Y204335（★★★★☆）**
   - **关键亮点**：单次DFS统计有效路径长度，通过`siz`数组巧妙计算必经边的数量
   - **核心思想**：每个含宝石的子树贡献的边数等于其`siz-1`
   - **代码核心**：
     ```cpp
     void dfs(int nw, int fa) {
         if (h[nw]) siz[nw]++; 
         for (auto i : d[nw]) {
             if (i == fa) continue;
             dfs(i, nw);
             siz[nw] += siz[i];
         }
         if (siz[nw] && !h[nw]) siz[nw]++; 
     }
     ```
     - **实现要点**：后序遍历累加子树宝石数，非宝石节点但子树有宝石时额外+1

2. **Chenyichen0420（★★★★☆）**
   - **关键亮点**：两次DFS分离标记与计算，逻辑清晰易理解
   - **核心思想**：第一次DFS标记含宝石的子树，第二次DFS累加路径长度
   - **代码核心**：
     ```cpp
     bool dff(int p, int fa) { // 标记含宝石的子树
         for (int sp : son[p])
             if (sp != fa) hss[p] |= dff(sp, p);
         return hss[p];
     }
     
     int get(int p, int fa) { // 计算路径
         int ret = 0;
         for (int sp : son[p])
             if (sp != fa && hss[sp]) ret += get(sp, p) + 2;
         return ret;
     }
     ```

---

## 关键技巧总结

1. **子树有效性判定**：通过DFS自底向上判断子树是否包含宝石，避免无效路径计算
2. **边数转化思想**：将路径长度转化为必经边的数量，利用`边数×2`直接得到往返总长
3. **空间优化技巧**：复用数组同时记录节点宝石状态和子树状态（如`siz`数组的多用途）

---

## 类似题目推荐

1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)（树形结构的最短路径问题）
2. [P2014 [CTSC1997] 选课](https://www.luogu.com.cn/problem/P2014)（树形依赖关系处理）
3. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)（树形结构收益统计）

---
处理用时：44.01秒
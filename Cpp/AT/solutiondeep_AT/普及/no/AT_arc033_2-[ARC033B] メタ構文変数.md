# 题目信息

# [ARC033B] メタ構文変数

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc033/tasks/arc033_2

「$ foo $」や「$ bar $」「$ hoge $」などの、特に意味を持たない変数の名前に使用される文字列のことを「メタ構文変数」と呼びます。

高橋君は今、メタ構文変数について調べています。メタ構文変数には色々な種類があることが分かり、見つけたメタ構文変数にそれぞれに番号をつけました。高橋君はアリの $ Ant $ さんと $ Bug $ くんのソースコードを読み、それぞれのソースコードに現れるメタ構文変数の番号を列挙しました。そして、$ Ant $ さんと $ Bug $ くんの使うメタ構文変数の集合がどれくらい似ているのかを調べるために「$ Jaccard $ 係数」を計算することにしました。$ Ant $ さんのソースコードに現れるメタ構文変数の集合を $ S_A $、$ Bug $ くんのソースコードに現れるメタ構文変数の集合を $ S_B $ とするとこれらの集合の $ Jaccard $ 係数は、

- $ ||S_{A}\ ∩\ S_{B}||\ /\ ||S_{A}\ ∪\ S_{B}|| $

という式で計算できます。ここで、$ ||S|| $ は集合 $ S $ の要素数を表すものとします。別の言い方をすると、

- 「$ S_{A} $ と $ S_{B} $ の両方に現れる要素の個数」$ / $「$ S_{A} $ と $ S_{B} $ の少なくともどちらか一方には現れる要素の個数」

となります。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ N_A,N_B\ ≦\ 1000 $ と $ A_i,B_i\ ≦\ 10^5 $ を満たすテストケース全てに正解した場合は、$ 40 $ 点が与えられる。
- $ A_i,B_i\ ≦\ 10^5 $ を満たすテストケース全てに正解した場合は、$ 70 $ 点が与えられる。

### Sample Explanation 1

$ Ant $ さんと $ Bug $ くんのソースコードの両方に現れるメタ構文変数は $ 1 $ 番のみで、$ Ant $ さんと $ Bug $ くんのソースコードの少なくともどちらか一方には現れるメタ構文変数は $ 1,2,3,5 $ 番の $ 4 $ つです。 よって、$ Jaccard $ 係数は $ 1/4 $ となります。

## 样例 #1

### 输入

```
3 2

1 3 5

1 2```

### 输出

```
0.2500000000```

## 样例 #2

### 输入

```
9 10

11 2 33 4 55 6 77 8 99

10 11 14 19 55 1000000000 4 5 7 8```

### 输出

```
0.2666666667```

# AI分析结果



# [ARC033B] メタ構文変数（中文翻译）

## 题目描述

「$ foo $」「$ bar $」「$ hoge $」等无实际含义的变量名称被称为"元语法变量"。高桥君在研究元语法变量时，发现不同代码中使用的元语法变量集合的相似度可以用 Jaccard 系数来衡量。

给定两个元语法变量集合 $S_A$ 和 $S_B$，Jaccard 系数计算公式为：
$$ \frac{|S_A \cap S_B|}{|S_A \cup S_B|} $$
即两个集合交集的元素个数除以并集的元素个数。

## 输入格式
第一行两个整数 $N_A$ 和 $N_B$  
第二行 $N_A$ 个整数表示 $S_A$ 的元素  
第三行 $N_B$ 个整数表示 $S_B$ 的元素

## 输出格式
输出 Jaccard 系数，保留 10 位小数

## 样例
### 输入 1
3 2  
1 3 5  
1 2
### 输出 1
0.2500000000

### 输入 2
9 10  
11 2 33 4 55 6 77 8 99  
10 11 14 19 55 1000000000 4 5 7 8
### 输出 2
0.2666666667

## 算法分类
数学（集合运算）

---

### 题解综合分析
各题解核心思路均为利用集合运算性质计算 Jaccard 系数，主要差异在于数据结构选择：
1. 使用 `set` 自动去重，通过总元素数推导交集大小（时间复杂度 $O((n+m)\log(n+m))$）
2. 使用 `map` 统计出现次数，直接计数交集元素
3. 显式维护两个集合进行交集判断

最优解法利用数学公式 $|A∩B| = |A| + |B| - |A∪B|$，将问题转化为仅需计算并集大小，显著简化代码。

---

### 精选题解（评分≥4星）

#### 1. PineappleSummer 的 solution2（⭐⭐⭐⭐⭐）
**亮点**：  
- 数学公式转化：通过 `n + m - 并集大小` 直接计算交集
- 代码极简（仅 7 行），使用 `set` 自动去重
- 时间复杂度最优（单次遍历）

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x;set<int>s;
main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n+m;i++) scanf("%d",&x),s.insert(x);
    printf("%.10f",(n+m-s.size())*1.0/s.size());
}
```

#### 2. Carey2012（⭐⭐⭐⭐）
**亮点**：  
- 使用 `map` 统计出现次数
- 并集计数与交集计数同步完成
- 代码清晰易懂

**核心逻辑**：
```cpp
map<int,int> mii;
for(遍历所有元素) mii[x]++;
并集大小 = mii.size();
交集大小 = 统计出现次数≥2的元素数
```

#### 3. A_grasser（⭐⭐⭐⭐）
**亮点**：  
- 动态维护并集和交集
- 单次遍历即可完成计算
- 空间效率优化（无需存储全部元素）

**核心代码片段**：
```cpp
unordered_map<int,bool>mp;
for(遍历A) mp标记存在，并集计数++
for(遍历B) 若存在标记则交集++，否则并集++
```

---

### 关键思路总结
**数学优化**：利用集合运算公式 $|A∩B| = |A| + |B| - |A∪B|$，将问题转化为仅需计算并集大小。  
**实现技巧**：使用 `set` 自动去重的特性，直接获得并集大小。  
**同类套路**：处理集合运算问题时，优先考虑数学公式转化避免显式计算。

---

### 类似题目推荐
1. [P1621 集合](https://www.luogu.com.cn/problem/P1621) - 集合合并与质数筛选结合
2. [P1536 村村通](https://www.luogu.com.cn/problem/P1536) - 并查集维护连通分量
3. [P5250 计算系数](https://www.luogu.com.cn/problem/P5250) - 组合数学与集合运算结合

---
处理用时：68.46秒
# 题目信息

# [ARC041B] アメーバ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc041/tasks/arc041_b

縦 $ N $ マス、横 $ M $ マスの盤面がある。 上から $ i $ ($ 1≦i≦N $) マス目、左から $ j $ ($ 1≦j≦M $) マス目の位置を $ (i,j) $ と表す。

はじめ、マス $ (i,j) $ には $ a_{ij} $ 匹のアメーバがいた。 ただし、盤面の端にアメーバはいなかった。 すなわち、$ i=1,N $ または $ j=1,M $ ならば $ a_{ij}=0 $ である。

高橋君が大声を出すと、アメーバたちは驚いてそれぞれ次の行動をとった。

- $ 1 $ 匹のアメーバが $ 4 $ 匹に分裂し、上下左右のマスへ $ 1 $ 匹ずつ移動した。

その結果、マス $ (i,j) $ には $ b_{ij} $ 匹のアメーバがいることになった。

今のアメーバの配置 $ (b_{ij}) $ が与えられるので、はじめのアメーバの配置 $ (a_{ij}) $ を $ 1 $ つ求めよ。 ただし、$ (a_{ij}) $ は少なくとも $ 1 $ つ存在する。

## 样例 #1

### 输入

```
3 3

010

101

010```

### 输出

```
000

010

000```

## 样例 #2

### 输入

```
3 4

0230

2323

0230```

### 输出

```
0000

0230

0000```

## 样例 #3

### 输入

```
5 5

00100

03040

20903

05060

00300```

### 输出

```
00000

00100

02030

00300

00000```

# AI分析结果



# [ARC041B] アメーバ

## 题目描述

在一个纵 $N$ 行、横 $M$ 列的网格中，每个格子 $(i,j)$ 初始时有 $a_{ij}$ 只阿米巴。网格边缘（即 $i=1$ 或 $i=N$ 或 $j=1$ 或 $j=M$）的格子初始时没有阿米巴。阿米巴在受到惊吓后会分裂：每个阿米巴分裂为 4 只，分别移动到上下左右相邻的格子。现在给出分裂后的结果 $b_{ij}$，求初始状态 $a_{ij}$。

## 输入格式
- 第一行两个整数 $N$ 和 $M$
- 接下来 $N$ 行，每行一个长度为 $M$ 的字符串，表示 $b_{ij}$

## 输出格式
- 输出 $N$ 行，每行 $M$ 个数字，表示初始状态 $a_{ij}$

## 样例

### 样例输入1
```
3 3
010
101
010
```

### 样例输出1
```
000
010
000
```

---

**算法分类**：构造、贪心

---

## 题解分析与结论

### 核心思路
逆向构造：每个位置的初始阿米巴数等于分裂后其上下左右四个邻接点的最小值。处理时按顺序遍历网格，实时更新邻接点的剩余值。

### 解决难点
1. **逆向推导**：通过分裂后的结果反向计算原始值，需确定每个位置的贡献量。
2. **边界处理**：网格边缘初始为0，但分裂后可能影响内部格子的计算。
3. **贪心正确性**：按顺序处理确保每个位置的最小值仅由当前分裂操作决定。

---

## 精选题解

### 题解作者：Guizy（评分：★★★★☆）
**关键亮点**：
- 直接遍历每个位置，计算四邻最小值。
- 实时更新邻接点数值，代码简洁高效。
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        int temp=min({a[i-1][j],a[i][j-1],a[i+1][j],a[i][j+1]});
        printf("%d",temp);
        a[i][j-1]-=temp, a[i-1][j]-=temp;
        a[i][j+1]-=temp, a[i+1][j]-=temp;
    }
    puts("");
}
```

### 题解作者：So_noSlack（评分：★★★★☆）
**关键亮点**：
- 输入处理技巧（字符转数字）。
- 无需额外存储，直接修改输入数组。
```cpp
for(int i=1;i<=n;i++) 
    for(int j=1;j<=m;j++) 
        mp[i][j] = c - '0';
// ... 计算四邻最小值并输出
```

### 题解作者：wmrqwq（评分：★★★★☆）
**关键亮点**：
- 统一处理边界条件，利用数组越界默认值简化代码。
- 使用 `min({...})` 简化多值比较。
```cpp
forl(i,1,n) forl(j,1,m) {
    minn=min({a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1]});
    cout<<minn;
    // 更新四邻数值
}
```

---

## 关键技巧总结
1. **逆向构造法**：将分裂过程逆推，利用每个位置对邻接点的贡献确定初始值。
2. **实时更新**：在处理每个位置时立即更新邻接点值，确保后续计算的正确性。
3. **边界隐式处理**：通过数组默认值（越界视为0）简化边界条件判断。

---

## 相似题目推荐
1. [P2895 [USACO08FEB] Meteor Shower S](https://www.luogu.com.cn/problem/P2895) - BFS与动态更新
2. [P1070 [NOIP2009 普及组] 道路游戏](https://www.luogu.com.cn/problem/P1070) - 动态规划与状态转移
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443) - BFS与网格处理

---
处理用时：67.32秒
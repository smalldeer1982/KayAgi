# 题目信息

# [ABC044C] 高橋君とカード

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc044/tasks/arc060_a

高橋君は、$ N $ 枚のカードを持っています。 $ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 番目のカードには、整数 $ x_i $ が書かれています。 高橋君は、これらのカードの中から $ 1 $ 枚以上を選び、 選んだカードに書かれた整数の平均をちょうど $ A $ にしたいと考えています。 そのようなカードの選び方が何通りあるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ 1\ \leq\ A\ \leq\ 50 $
- $ 1\ \leq\ x_i\ \leq\ 50 $
- $ N,\,A,\,x_i $ はいずれも整数である

### 部分点

- $ 1\ \leq\ N\ \leq\ 16 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。

### Sample Explanation 1

\- 平均が $ 8 $ となるカードの選び方は、以下の $ 5 $ 通りです。 - $ 3 $ 枚目のカードのみを選ぶ。 - $ 1 $ 枚目と $ 2 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目と $ 4 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 2 $ 枚目および $ 3 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 3 $ 枚目および $ 4 $ 枚目のカードを選ぶ。

### Sample Explanation 4

\- 答えは $ 32 $ ビット整数型に収まらない場合があります。

## 样例 #1

### 输入

```
4 8

7 9 8 9```

### 输出

```
5```

## 样例 #2

### 输入

```
3 8

6 6 9```

### 输出

```
0```

## 样例 #3

### 输入

```
8 5

3 6 2 8 7 6 5 9```

### 输出

```
19```

## 样例 #4

### 输入

```
33 3

3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3```

### 输出

```
8589934591```

# AI分析结果



# [ABC044C] 高橋君とカード

## 题目描述

高橋君有 $N$ 张卡片，第 $i$ 张卡片上写着整数 $x_i$。他想选择至少一张卡片，使得所选卡片上的整数平均值恰好为 $A$。求满足条件的选取方案数。

### 输入格式
输入包含两行：
- 第一行两个整数 $N$ 和 $A$
- 第二行 $N$ 个整数 $x_1,x_2,...,x_N$

### 输出格式
输出满足条件的方案数。

### 约束条件
- $1 \leq N \leq 50$
- $1 \leq A \leq 50$
- $1 \leq x_i \leq 50$

### 样例解释
当选择卡片的平均值为 $A$ 时，所有满足条件的组合数即为答案。例如样例1中，存在5种组合方式使得平均值为8。

---

**算法分类**  
动态规划

---

## 题解分析与结论

### 核心思路对比
1. **背包式DP**：通过二维状态 $f[k][j]$ 记录选 $k$ 个卡牌且总和为 $j$ 的方案数，最后遍历所有可能的 $k$ 和 $j$ 检查是否满足 $j/k = A$。  
2. **值域偏移**：将每个卡牌值 $x_i$ 转换为 $(x_i - A)$，转化为寻找和为0的子集，利用带偏移量的DP处理负数下标。

### 优化关键点
- **避免浮点运算**：通过整数运算代替浮点比较，如判断 $j = k*A$ 代替除法运算。
- **状态压缩**：逆向遍历背包维度避免重复计算，采用滚动数组优化空间。

---

## 高分题解推荐

### 题解1：背包式动态规划（4星）
**作者：Night_sea_64**  
**亮点**：
- 使用标准的01背包变形，状态设计直观
- 逆向枚举维度保证状态转移正确性
- 完整处理大数情况（long long）

**核心代码**：
```cpp
long long f[55][2505] = {1}; // 初始化f[0][0]=1
for(int i=1; i<=n; i++)
    for(int j=2500; j>=x[i]; j--)
        for(int k=n; k>=1; k--)
            f[k][j] += f[k-1][j-x[i]];
// 统计满足 j == k*A 的方案数
```

### 题解2：值域偏移法（5星）
**思路升华**：
- 将原问题转化为求偏移后的和为0，规避平均值计算
- 使用对称值域处理负数，通过偏移量映射到正数下标

**伪代码逻辑**：
```python
offset = sum(x_i - A) 的绝对值最大值
dp[0][offset] = 1  # 初始状态
for num in x:
    for k in reverse(range(n)):
        for j in reverse(range(2*offset)):
            dp[k+1][j + (num-A)] += dp[k][j]
# 结果为所有k≥1且dp[k][offset]的和
```

---

## 关键技巧总结
1. **状态设计**：在DP中记录关键参数（选取数量、总和）代替直接计算难以处理的值（如平均值）。
2. **整数转换**：通过代数变换将问题转化为整数域问题，避免浮点精度风险。
3. **逆向枚举**：在背包问题中逆序遍历保证每个物品只选取一次。

---

## 同类题目推荐
1. **P1734 最大约数和** - 背包问题求特定条件的最大和  
2. **P1284 三角形牧场** - 多维约束的动态规划  
3. **P2218 [HAOI2007]覆盖问题** - 值域转换与条件判断

---
处理用时：106.25秒
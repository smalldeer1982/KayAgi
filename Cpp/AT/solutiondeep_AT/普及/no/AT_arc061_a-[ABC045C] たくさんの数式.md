# 题目信息

# [ABC045C] たくさんの数式

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc045/tasks/arc061_a

`1` 以上 `9` 以下の数字のみからなる文字列 $ S $ が与えられます。 この文字列の中で、あなたはこれら文字と文字の間のうち、いくつかの場所に `+` を入れることができます。 一つも入れなくてもかまいません。 ただし、`+` が連続してはいけません。

このようにして出来る全ての文字列を数式とみなし、和を計算することができます。

ありうる全ての数式の値を計算し、その合計を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ &#124;S&#124;\ \leq\ 10 $
- $ S $ に含まれる文字は全て `1` 〜 `9` の数字

### Sample Explanation 1

考えられる数式としては、 `125`、`1+25`、`12+5`、`1+2+5` の $ 4 $ 通りがあります。それぞれの数式を計算すると、 - $ 125 $ - $ 1+25=26 $ - $ 12+5=17 $ - $ 1+2+5=8 $ となり、これらの総和は $ 125+26+17+8=176 $ となります。

## 样例 #1

### 输入

```
125```

### 输出

```
176```

## 样例 #2

### 输入

```
9999999999```

### 输出

```
12656242944```

# AI分析结果



# [ABC045C] たくさんの数式 题面翻译

**题目描述**  
给定一个仅由数字 `1` 到 `9` 组成的字符串 $S$。你可以在这些数字之间插入任意数量的 `+` 号（可以不插入，但不能连续插入）。将所有可能的合法数式求和后输出结果。

**输入格式**  
一个字符串 $S$

**输出格式**  
所有可能数式的和

**样例解释**  
对于输入 `125`，可能的数式有：  
- 125 → 125  
- 1+25 → 26  
- 12+5 → 17  
- 1+2+5 → 8  
总和为 125+26+17+8=176

**数据范围**  
$1 \leq |S| \leq 10$

---

### 算法分类  
**动态规划**（最优解法） / **深度优先搜索**（暴力解法）

---

## 题解综合分析

### 核心思路对比
| 解法类型       | 时间复杂度 | 核心思路                                                                 |
|----------------|------------|--------------------------------------------------------------------------|
| 动态规划       | O(n)       | 维护前缀和与系数数组，通过数学推导将问题转化为线性递推                   |
| DFS暴力枚举    | O(2^n)     | 枚举每个间隔是否添加加号，通过递归计算所有可能情况                       |
| 数学规律       | O(n)       | 推导每个数字在不同位数的贡献次数，利用幂次运算快速计算总和               |

---

## 优质题解推荐

### 1. Krimson的O(n)动态规划解法（⭐⭐⭐⭐⭐）
**关键亮点**  
- 通过数学推导将问题转化为线性递推式
- 使用前缀和和系数数组优化计算过程
- 时间复杂度从O(n²)优化到O(n)的巧妙转换

**核心代码**  
```cpp
ll f[MAXM], sum[MAXM], g[MAXM];
ll powt[MAXM]; // 2的幂次数组

for (int i = 1; i <= n; ++i) {
    powt[i] = powt[i-1] << 1;        // 预处理2的幂
    g[i] = g[i-1] * 10 + a[i] * powt[i-1]; // 递推系数数组
    f[i] = sum[i-1] + g[i];           // 当前位总和
    sum[i] = sum[i-1] + f[i];         // 前缀和
}
```

### 2. Texas的DFS解法（⭐⭐⭐⭐）
**关键亮点**  
- 代码简洁直观，易于理解
- 利用递归实现加号位置的全枚举
- 通过参数传递累计值，避免冗余计算

**个人心得**  
> 答案需要除以2是因为递归过程中最后一个数字会被重复计算两次，这个边界处理需要特别注意

**核心代码**  
```cpp
void dfs(int k, ll sum, ll num) {
    if (k == n) {
        ans += sum + num;
        return;
    }
    dfs(k+1, sum, num*10 + a[k]); // 不加加号
    dfs(k+1, sum + num, a[k]);    // 添加加号
}
```

### 3. Ezio__Auditore的数学规律解法（⭐⭐⭐⭐）
**关键亮点**  
- 通过观察系数规律建立递推式
- 预处理base数组加速计算
- 将问题转化为数字位权求和问题

**核心代码**  
```cpp
base[0] = 1;
for (int i = 1; i <= n; i++) {
    base[i] = base[i-1] * 10 + (1 << (i-1)); // 预处理系数
}
ans += (s[i]-'0') * (1 << (i-1)) * base[n-i];
```

---

## 最优技巧总结
**关键思路**  
动态规划解法通过定义两个核心数组：  
- `g[i]` 表示前i位数字的系数累计值  
- `f[i]` 表示前i位所有可能的总和  

利用递推关系：  
`g[i] = g[i-1] * 10 + a[i] * 2^(i-1)`  
`f[i] = sum[i-1] + g[i]`  
其中`sum[i]`是前缀和数组，将时间复杂度优化到O(n)

---

## 拓展训练
**相似题目推荐**  
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 数字组合求和问题
2. [P1018 乘积最大](https://www.luogu.com.cn/problem/P1018) - 数字分割最优化问题
3. [P1288 取数游戏](https://www.luogu.com.cn/problem/P1288) - 数字序列动态规划问题

---
处理用时：61.14秒
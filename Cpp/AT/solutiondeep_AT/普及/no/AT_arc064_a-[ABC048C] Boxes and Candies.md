# 题目信息

# [ABC048C] Boxes and Candies

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc048/tasks/arc064_a

$ N $ 個の箱が横一列に並んでいます。 最初、左から $ i $ 番目の箱には $ a_i $ 個のキャンディが入っています。

すぬけ君は次の操作を好きな回数だけ行うことができます。

- キャンディが $ 1 $ 個以上入っている箱をひとつ選び、その箱のキャンディを $ 1 $ 個食べる。

すぬけ君の目標は次の通りです。

- どの隣り合う $ 2 $ つの箱を見ても、それらの箱に入っているキャンディの個数の総和が $ x $ 以下である。

目標を達成するために必要な操作回数の最小値を求めてください。

## 说明/提示

### 制約

- $ 2\ <\ =\ N\ <\ =\ 10^5 $
- $ 0\ <\ =\ a_i\ <\ =\ 10^9 $
- $ 0\ <\ =\ x\ <\ =\ 10^9 $

### Sample Explanation 1

$ 2 $ 番目の箱のキャンディを $ 1 $ 個食べればよいです。 すると、各箱のキャンディの個数は $ (2,\ 1,\ 2) $ となります。

### Sample Explanation 2

たとえば、$ 2 $ 番目の箱のキャンディを $ 6 $ 個食べ、$ 4 $ 番目の箱のキャンディを $ 2 $ 個食べ、$ 6 $ 番目の箱のキャンディを $ 3 $ 個食べればよいです。 すると、各箱キャンディの個数は $ (1,\ 0,\ 1,\ 0,\ 0,\ 1) $ となります。

### Sample Explanation 3

最初から目標が達成されているので、操作を行う必要はありません。

### Sample Explanation 4

すべてのキャンディを食べなければなりません。

## 样例 #1

### 输入

```
3 3

2 2 2```

### 输出

```
1```

## 样例 #2

### 输入

```
6 1

1 6 1 2 0 4```

### 输出

```
11```

## 样例 #3

### 输入

```
5 9

3 1 4 1 5```

### 输出

```
0```

## 样例 #4

### 输入

```
2 0

5 5```

### 输出

```
10```

# AI分析结果



# [ABC048C] Boxes and Candies

## 题目描述

$ N $ 个箱子排成一列。初始时，左起第 $ i $ 个箱子有 $ a_i $ 颗糖果。

每次操作可以选择一个至少含有 1 颗糖果的箱子，吃掉其中 1 颗糖果。要求通过若干次操作后，任意相邻两个箱子的糖果总数不超过 $ x $。求最小操作次数。

### 说明/提示

**数据范围**  
- $ 2 \leq N \leq 10^5 $
- $ 0 \leq a_i \leq 10^9 $
- $ 0 \leq x \leq 10^9 $

**样例解释**  
例如样例 2 中，通过调整后各箱糖果数为 $(1,0,1,0,0,1)$，总操作次数为 11 次。

---

**算法分类**  
贪心

---

### 题解综合分析

各题解均采用贪心策略，核心思路为：从左到右遍历，优先调整当前箱子的糖果数以满足相邻总和要求。关键点如下：

1. **贪心方向**：处理每个相邻对时，优先减少右侧箱子的糖果数，以最小化对后续处理的影响。
2. **滚动处理**：只需维护当前处理的相邻对，无需存储完整数组。
3. **边界处理**：注意总和溢出和数据类型（需用 `long long`）。

**题解对比**  
- **小王子2021**（★★★★★）：直接从前向后遍历，每次调整当前箱子，代码简洁高效。
- **Ryo_Yamada**（★★★★）：增加对当前箱子不足时的处理（调整前箱），逻辑更严谨但复杂度相近。
- **翼德天尊**（★★★★）：滚动数组优化空间，15行极简实现。

---

### 精选题解

#### 小王子2021（★★★★★）
**关键思路**  
从左到右遍历，每次保证当前箱子与前一个的总和 ≤x。若总和超过，优先减少当前箱子糖果数。

**核心代码**  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n, x, ans, a[100010];

int main() {
    scanf("%lld%lld", &n, &x);
    for (int i=1; i<=n; i++) {
        scanf("%lld", &a[i]);
        if (a[i] + a[i-1] > x) {
            long long tmp = a[i] + a[i-1] - x;
            ans += tmp;
            a[i] -= tmp;
        }
    }
    printf("%lld", ans);
    return 0;
}
```

#### Ryo_Yamada（★★★★）
**优化点**  
处理当前箱子不足时，调整前箱的值以确保总和合法。

**核心代码**  
```cpp
for (int i=0; i < n-1; i++) {
    if (a[i] + a[i+1] > x) {
        ll tmp = a[i] + a[i+1] - x;
        cnt += tmp;
        if (a[i+1] >= tmp) a[i+1] -= tmp;
        else {
            tmp -= a[i+1];
            a[i+1] = 0;
            a[i] -= tmp; // 调整前箱
        }
    }
}
```

---

### 关键技巧总结
- **滚动处理**：只需维护相邻两个箱子的值，空间优化至 O(1)。
- **类型防范**：总和可能超过 int 范围，需用 `long long`。
- **贪心选择**：优先调整当前箱子，减少对后续处理的影响。

---

### 拓展练习
1. [P3817 小A的糖果](https://www.luogu.com.cn/problem/P3817)  
   （类似贪心思路，处理相邻和限制）
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)  
   （双指针贪心，配对问题）
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)  
   （贪心策略选择最优删除顺序）

---
处理用时：277.16秒
# 题目信息

# [ABC050C] Lining Up

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc050/tasks/arc066_a

$ 1～N $ までの番号がついた、$ N $ 人の人がいます。 彼らは昨日、ある順番で左右一列に並んでいましたが、今日になってその並び方が分からなくなってしまいました。 しかし、彼らは全員、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」を覚えています。 彼らの報告によると、人 $ i $ の、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」は $ A_i $ です。

彼らの報告を元に、元の並び方が何通りあり得るかを求めてください。 ただし、答えは非常に大きくなることがあるので、$ 10^9+7 $ で割った余りを出力してください。 また、彼らの報告が間違っており、ありうる並び方がないこともありえます。 その際は $ 0 $ を出力してください。

## 说明/提示

### 制約

- $ 1≦N≦10^5 $
- $ 0≦A_i≦N-1 $

### Sample Explanation 1

ありうる並び方は、人の番号で書くと、 - $ 2,1,4,5,3 $ - $ 2,5,4,1,3 $ - $ 3,1,4,5,2 $ - $ 3,5,4,1,2 $ の $ 4 $ 通りです。

### Sample Explanation 2

どのような並び方でも、報告と矛盾するので、$ 0 $ が答えになります。

## 样例 #1

### 输入

```
5

2 4 4 0 2```

### 输出

```
4```

## 样例 #2

### 输入

```
7

6 4 0 2 4 0 2```

### 输出

```
0```

## 样例 #3

### 输入

```
8

7 5 1 1 7 3 5 3```

### 输出

```
16```

# AI分析结果



# [ABC050C] Lining Up 中文题面

## 题目描述

编号为 $1$ 至 $N$ 的 $N$ 个人排成一列。每个人记得自己左右两侧人数差的绝对值，第 $i$ 个人的这个值为 $A_i$。求可能的原始排列方案数，结果对 $10^9+7$ 取模。若不存在合法方案则输出 $0$。

### 样例 #1
输入：
```
5
2 4 4 0 2
```
输出：
```
4
```

### 样例 #2
输入：
```
7
6 4 0 2 4 0 2
```
输出：
```
0
```

### 样例 #3
输入：
```
8
7 5 1 1 7 3 5 3
```
输出：
```
16
```

---

**算法分类**：组合数学

---

## 题解综合分析

### 关键思路总结
1. **奇偶性分析**：
   - 当 $n$ 为奇数时，必存在唯一 $A_i=0$，其余值构成 $2,4,6,...$ 且每个出现两次
   - 当 $n$ 为偶数时，所有 $A_i$ 构成 $1,3,5,...$ 且每个出现两次
2. **计数验证**：
   - 统计每个数值的出现次数是否符合上述模式
3. **快速幂计算**：
   - 合法时答案为 $2^{\lfloor n/2 \rfloor}$，使用快速幂计算模数

### 最优题解亮点

#### 题解作者：Aisaka_Taiga（5星）
**核心思路**：
- 桶计数验证每个值的出现次数
- 直接根据奇偶性判断数值合法性
- 简洁的快速幂实现

**关键代码**：
```cpp
int main() {
    scanf("%d", &n);
    // 桶统计出现次数
    for(int i=1;i<=n;i++) vis[a[i]]++;
    
    bool flag = true;
    if(n & 1) { // 奇数情况
        if(vis[0] != 1) flag = false;
        for(int i=2; i<=n; i+=2) 
            if(vis[i] != 2) flag = false;
    } else { // 偶数情况
        for(int i=1; i<=n-1; i+=2)
            if(vis[i] != 2) flag = false;
    }
    
    ll res = qpow(2, n/2); // 快速幂
    printf("%lld\n", flag ? res : 0);
}
```

#### 题解作者：Buried_Dream（4星）
**优化亮点**：
- 使用 bitset 记录奇偶出现情况
- 分情况处理奇偶验证逻辑

**核心片段**：
```cpp
if(n & 1) {
    for(int i=2; i<=n; i+=2) 
        if(!vis1[i] || !vis2[i]) return 0;
} else {
    for(int i=1; i<=n-1; i+=2)
        if(!vis1[i] || !vis2[i]) return 0;
}
```

---

## 同类型题目推荐
1. [P1357 食物链](https://www.luogu.com.cn/problem/P1357) - 组合计数与模运算
2. [P3197 越狱](https://www.luogu.com.cn/problem/P3197) - 快速幂与逆向思维
3. [P2638 安全系统](https://www.luogu.com.cn/problem/P2638) - 桶计数与组合数学

---
处理用时：68.18秒
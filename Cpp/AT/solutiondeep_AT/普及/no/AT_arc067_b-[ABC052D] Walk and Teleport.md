# 题目信息

# [ABC052D] Walk and Teleport

## 题目描述

在东西方向延伸的直线上，有N个城市。城市坐标按从西到东递增。

你现在在某个城市里，想去其他所有的城市。移动的方法有以下两种。

一，在直线上按东西方向平移，每移动一个单位距离疲劳值加A

二，直接瞬移到某个坐标，并且疲劳值加B

请使用以上两种方式直到去完其他所有的城市，并求出最小的疲劳值。

## 说明/提示

2<=N<=1e5

1<=Xi,A,B<=1e9且X(i)<X(i+1)

## 样例 #1

### 输入

```
4 2 5

1 2 5 7```

### 输出

```
11```

## 样例 #2

### 输入

```
7 1 100

40 43 45 105 108 115 124```

### 输出

```
84```

## 样例 #3

### 输入

```
7 1 2

24 35 40 68 72 99 103```

### 输出

```
12```

# AI分析结果



# [ABC052D] 步行与瞬移

## 题目描述

在东西方向延伸的直线上，有N个城市。城市坐标按从西到东递增排列。

你现在在某个城市里，需要访问其他所有城市。移动方式有两种：
1. 沿直线平移，每移动一个单位距离疲劳值加A
2. 直接瞬移到任意坐标，疲劳值加B

求访问所有城市的最小总疲劳值。

## 算法分类
贪心

## 题解分析

### 关键思路
对于每对相邻城市，计算两种移动方式的疲劳值：
- **直接移动**：相邻距离 × A
- **瞬移**：固定值 B
累加每对相邻城市的最小值即为答案。

### 最优题解推荐
#### 封禁用户（★★★★★）
**亮点**：  
- 思路清晰，直接点明贪心策略  
- 代码简洁高效，O(N)时间复杂度  
- 包含输入输出优化实践  

**核心代码**：
```cpp
for(ll i=1;i<n;i++)
    sum += min(b, a*(x[i+1]-x[i]));
```

#### zfn07（★★★★☆）
**亮点**：  
- 强调数据范围处理（long long）  
- 给出错误案例警示  
- 代码简洁易理解  

**核心代码**：
```cpp
for(int i=1;i<n;i++)
    ans += min(a*(x[i+1]-x[i]),b);
```

#### rui_er（★★★★☆）
**亮点**：  
- 特别强调城市访问顺序要求  
- 提供调试经验（sort陷阱）  
- 代码结构清晰  

**核心代码**：
```cpp
for(ll i=1;i<n;i++) {
    ll l = x[i+1] - x[i];
    sum += min(b, a*l);
}
```

## 总结技巧
1. **贪心选择**：局部最优决策可推导全局最优解
2. **类型处理**：大数据范围必须使用long long
3. **顺序敏感**：城市坐标已有序，不能擅自排序
4. **代码优化**：关同步流加速IO（ios::sync_with_stdio）

## 拓展练习
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)  
2. [P1209 修理牛棚](https://www.luogu.com.cn/problem/P1209)  
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)

---
处理用时：133.08秒
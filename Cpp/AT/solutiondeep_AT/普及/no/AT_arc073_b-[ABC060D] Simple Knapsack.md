# 题目信息

# [ABC060D] Simple Knapsack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc060/tasks/arc073_b

あなたは $ N $ 個の物と、強度 $ W $ のバッグを持っています。 $ i $ 個目の物は、重さが $ w_i $ で価値が $ v_i $ です。

あなたは、物のうちいくつかを選び、バッグに入れます。 ただし、選んだ物の重さの和は $ W $ 以下でなくてはいけません。

あなたは、バッグに入れた物の価値の総和を最大化したいです。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 100 $
- $ 1\ ≦\ W\ ≦\ 10^9 $
- $ 1\ ≦\ w_i\ ≦\ 10^9 $
- すべての $ i\ =\ 2,3,...,N $ について、$ w_1\ ≦\ w_i\ ≦\ w_1\ +\ 3 $
- $ 1\ ≦\ v_i\ ≦\ 10^7 $
- $ W,\ w_i,\ v_i $ はすべて整数である

### Sample Explanation 1

$ 1,\ 3 $ 個目の物を選ぶと良いです。

### Sample Explanation 2

$ 2,\ 4 $ 個目の物を選ぶと良いです。

### Sample Explanation 3

すべての物が選べます。

### Sample Explanation 4

$ 1 $ 個も物が選べません。

## 样例 #1

### 输入

```
4 6

2 1

3 4

4 10

3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
4 6

2 1

3 7

4 10

3 6```

### 输出

```
13```

## 样例 #3

### 输入

```
4 10

1 100

1 100

1 100

1 100```

### 输出

```
400```

## 样例 #4

### 输入

```
4 1

10 100

10 100

10 100

10 100```

### 输出

```
0```

# AI分析结果



# [ABC060D] Simple Knapsack

## 题目描述

你有一个容量为 $W$ 的背包和 $N$ 个物品。每个物品的重量为 $w_i$，价值为 $v_i$。要求选择若干物品，使得总重量不超过 $W$ 且总价值最大。特殊条件：所有物品重量满足 $w_1 \leq w_i \leq w_1+3$（$i \geq 2$）。

### 算法分类
动态规划

---

## 题解综合分析

### 最优思路总结
将物品重量转换为相对于第一个物品的差值，建立三维DP数组：`dp[i][j][k]` 表示前i个物品选k个，转换后总重量为j时的最大价值。最终通过枚举物品数量与转换重量，计算合法总重量下的最大价值。

### 关键优化技巧
1. **重量偏移**：将每个物品重量减去第一个物品的重量，将重量范围压缩到0-3
2. **状态降维**：通过记录物品数量k和偏移后总重量j，将原始1e9量级的背包容量压缩到3n级别
3. **分类枚举**：对于小重量差异的特性，将物品分组处理（如按w1、w1+1等分组）

---

## 推荐题解

### 1. Liynw 题解（⭐⭐⭐⭐⭐）
**核心亮点**：  
- 三维DP状态设计巧妙处理超大容量限制
- 重量偏移转换直观清晰
- 循环顺序设计合理避免状态覆盖

**关键代码**：
```cpp
ll dp[105][305][105];
for(int i=1;i<=n;i++) {
    for(int k=1;k<=i;k++) {
        for(int j=0;j<=3*i;j++) {
            if(j<w[i]) dp[i][j][k] = dp[i-1][j][k];
            else dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-w[i]][k-1]+v[i]);
        }
    }
}
// 最终遍历所有可能的物品数量与偏移重量
for(int j=0;j<=3*n;j++)
    for(int k=0;k<=n;k++)
        if(j+k*w1 <= W) ans = max(ans, dp[n][j][k]);
```

### 2. fjy666 题解（⭐⭐⭐⭐）
**核心亮点**：  
- 暴力枚举前三种重量的选取数量
- 贪心处理第四种重量的选取
- 利用前缀和优化价值计算

**关键代码**：
```cpp
_rep(c0,0,cnt[0]) _rep(c1,0,cnt[1]) _rep(c2,0,cnt[2]) {
    int c3 = (剩余容量)/(w1+3); // 贪心计算第四类数量
    // 利用预排序后的前缀和快速计算总价值
    total = sum[c0] + sum[c1] + sum[c2] + sum[c3];
    ans = max(ans, total);
}
```

### 3. __Hacheylight__ 题解（⭐⭐⭐）
**个人心得**：  
"注意重量偏移后总差值的计算要使用long long，否则在计算最终总重量时会发生溢出。调试时发现当w1较大时，即使偏移量很小，相乘后仍可能超过int范围。"

---

## 相似题目推荐
1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776) - 多重背包+单调队列优化
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 01背包基础训练
3. [P2871 Charm Bracelet](https://www.luogu.com.cn/problem/P2871) - 基础01背包变种

---
处理用时：44.27秒
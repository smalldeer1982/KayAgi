# 题目信息

# [ABC062D] 3N Numbers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc062/tasks/arc074_b

$ N $ を $ 1 $ 以上の整数とします。

長さ $ 3N $ の数列 $ a\ =\ (a_1,\ a_2,\ ...,\ a_{3N}) $ があります。 すぬけ君は、$ a $ からちょうど $ N $ 個の要素を取り除き、残った $ 2N $ 個の要素を元の順序で並べ、長さ $ 2N $ の数列 $ a' $ を作ろうとしています。 このとき、$ a' $ のスコアを $ (a'\ の前半\ N\ 要素の総和)\ -\ (a'\ の後半\ N\ 要素の総和) $ と定義します。

$ a' $ のスコアの最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ a_i $ は整数である。
- $ 1\ <\ =\ a_i\ <\ =\ 10^9 $

### 部分点

- $ 300 $ 点分のテストケースでは、$ N\ <\ =\ 1,000 $ が成り立つ。

### Sample Explanation 1

$ a_2 $, $ a_6 $ を取り除くと、$ a'\ =\ (3,\ 4,\ 1,\ 5) $ となり、スコアは $ (3\ +\ 4)\ -\ (1\ +\ 5)\ =\ 1 $ となります。

### Sample Explanation 2

例えば、$ a_1 $ を取り除くと、$ a'\ =\ (2,\ 3) $ となり、スコアは $ 2\ -\ 3\ =\ -1 $ となります。

### Sample Explanation 3

例えば、$ a_2 $, $ a_3 $, $ a_9 $ を取り除くと、$ a'\ =\ (8,\ 7,\ 4,\ 6,\ 5,\ 3) $ となり、スコアは $ (8\ +\ 7\ +\ 4)\ -\ (6\ +\ 5\ +\ 3)\ =\ 5 $ となります。

## 样例 #1

### 输入

```
2

3 1 4 1 5 9```

### 输出

```
1```

## 样例 #2

### 输入

```
1

1 2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
3

8 2 2 7 4 6 5 3 8```

### 输出

```
5```

# AI分析结果



# [ABC062D] 3N Numbers

## 题目描述

给定一个长度为 $3N$ 的数列 $a$，要求删除恰好 $N$ 个元素，将剩余的 $2N$ 个元素分为前 $N$ 个和后 $N$ 个。求前 $N$ 个元素总和减去后 $N$ 个元素总和的最大值。

## 算法分类
贪心

## 题解分析与结论

所有题解均采用双优先队列策略：  
1. 预处理前部最大和数组：使用小根堆维护前 $i$ 个元素中的最大 $N$ 个数之和  
2. 预处理后部最小和数组：使用大根堆维护后 $i$ 个元素中的最小 $N$ 个数之和  
3. 枚举分割点 $i \in [N, 2N]$，计算前部最大和与后部最小和的差值最大值  

关键难点在于正确维护堆的大小和元素替换逻辑，以及分割点的范围控制。

## 高星题解推荐

### 题解作者：liyichun001（⭐⭐⭐⭐⭐）
**核心亮点**  
- 变量命名清晰，预处理数组命名 before/last 直观  
- 使用反向遍历处理后缀最小和，逻辑对称  
- 分割点范围处理正确，时间复杂度严格 $O(N\log N)$  

**关键代码**  
```cpp
priority_queue<LL> minSumQ; // 维护后部的大根堆（取小值）
priority_queue<LL, vector<LL>, greater<LL>> maxSumQ; // 维护前部的小根堆（取大值）

// 前部预处理
for(int i=n+1; i<=2*n; i++) {
    if(a[i] > maxSumQ.top()) {
        maxSum += a[i] - maxSumQ.top();
        maxSumQ.pop();
        maxSumQ.push(a[i]);
    }
    before[i] = maxSum;
}

// 后部预处理
for(int i=2*n-1; i>=n; i--) {
    if(a[i+1] < minSumQ.top()) {
        minSum += a[i+1] - minSumQ.top();
        minSumQ.pop();
        minSumQ.push(a[i+1]);
    }
    last[i] = minSum;
}
```

### 题解作者：abensyl（⭐⭐⭐⭐）
**核心亮点**  
- 代码简洁，使用两次反向遍历统一处理逻辑  
- 采用更紧凑的数组预处理方式，空间效率高  

**个人心得**  
"不开 long long 见祖宗"：强调了数值范围判断的重要性，当总和可能超过 $10^{14}$ 时，必须使用 long long 类型。

### 题解作者：Liyunze123（⭐⭐⭐⭐）
**核心亮点**  
- 使用更直观的堆操作注释，便于理解维护方向  
- 分割点循环条件明确，代码可读性强  

## 关键思路总结

1. **双堆预处理**：前部维护最大 $N$ 和用**小根堆**（踢掉较小值），后部维护最小 $N$ 和用**大根堆**（踢掉较大值）  
2. **反向遍历技巧**：后缀处理时从右往左遍历，保持元素顺序不变  
3. **分割点枚举**：在 $[N, 2N]$ 范围内线性扫描，保证两部分均有足够元素  

## 拓展应用

类似需要维护动态前 K 大/小值的问题均可采用优先队列预处理：  
- 数据流中位数（双堆维护）  
- 滑动窗口极值（单调队列）  

## 推荐习题
1. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801) - 动态查询第 K 大值  
2. [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085) - 优先队列预处理  
3. [P2866 Bad Hair Day](https://www.luogu.com.cn/problem/P2866) - 单调栈维护前序极值

---
处理用时：110.22秒
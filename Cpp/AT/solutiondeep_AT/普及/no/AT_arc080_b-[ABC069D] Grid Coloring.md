# 题目信息

# [ABC069D] Grid Coloring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc069/tasks/arc080_b

縦 $ H $ 行、横 $ W $ 列のマス目があります。 すぬけ君は、このマス目を色 $ 1 $, $ 2 $, $ ... $, $ N $ で塗り分けようとしています。 このとき、次の条件が成り立つようにします。

- 各 $ i $ ($ 1\ <\ =\ i\ <\ =\ N $) について、色 $ i $ のマスはちょうど $ a_i $ 個存在する。 ただし、$ a_1\ +\ a_2\ +\ ...\ +\ a_N\ =\ H\ W $ である。
- 各 $ i $ ($ 1\ <\ =\ i\ <\ =\ N $) について、色 $ i $ のマスは上下左右に連結である。 すなわち、どの色 $ i $ のマスからどの色 $ i $ のマスへも、上下左右に隣り合う色 $ i $ のマスのみを辿って行き来できる。

条件を満たす塗り分け方をひとつ求めてください。 解は必ず存在することが示せます。

## 说明/提示

### 制約

- $ 1\ <\ =\ H,\ W\ <\ =\ 100 $
- $ 1\ <\ =\ N\ <\ =\ H\ W $
- $ a_i\ >\ =\ 1 $
- $ a_1\ +\ a_2\ +\ ...\ +\ a_N\ =\ H\ W $

### Sample Explanation 1

例えば、次の塗り分け方は条件を満たしません。 色 $ 1 $ のマスが上下左右に連結でないからです。 ``` 1 2 3 1 ```

## 样例 #1

### 输入

```
2 2

3

2 1 1```

### 输出

```
1 1

2 3```

## 样例 #2

### 输入

```
3 5

5

1 2 3 4 5```

### 输出

```
1 4 4 4 3

2 5 4 5 3

2 5 5 5 3```

## 样例 #3

### 输入

```
1 1

1

1```

### 输出

```
1```

# AI分析结果



【中文题目重写】  
# [ABC069D] 网格涂色  

## 题目描述  

给定一个 $H$ 行 $W$ 列的网格，用颜色 $1, 2, ..., N$ 进行涂色，需满足以下条件：  
1. 每种颜色 $i$ 恰好使用 $a_i$ 个格子，且 $\sum a_i = H \times W$。  
2. 每种颜色的所有格子必须上下左右连通（即任意两个同色格子可通过相邻同色格子到达）。  

请构造一种符合条件的涂色方案，题目保证解存在。  

## 算法分类  
构造  

---

### 题解分析与结论  
**核心思路**：通过蛇形填充保证颜色块的连续性。奇数行从左到右填充，偶数行从右到左填充，确保相邻行的首尾相接，从而实现颜色块的连通性。  

**关键技巧**：  
1. 蛇形遍历（之字形填充）确保连通性。  
2. 动态处理颜色切换，或预先生成颜色序列。  

---

### 精选题解  

#### 题解1：Ryo_Yamada（★★★★☆）  
**亮点**：  
- 动态颜色计数，无需预存完整颜色序列，节省空间。  
- 简洁的奇偶行方向控制。  
**核心代码**：  
```cpp  
int nw = 1;  // 当前颜色指针  
rep(i, 1, n) {  
    if(i & 1) {  // 奇数行正序填充  
        rep(j, 1, m) {  
            ans[i][j] = nw;  
            if(--a[nw] == 0) ++nw;  
        }  
    } else {     // 偶数行逆序填充  
        per(j, m, 1) {  
            ans[i][j] = nw;  
            if(--a[nw] == 0) ++nw;  
        }  
    }  
}  
```  

#### 题解2：fly20040720（★★★★☆）  
**亮点**：  
- 预先生成颜色序列，填充逻辑更直观。  
- 直接使用数组索引实现蛇形映射。  
**核心代码**：  
```cpp  
vector<int> v;  
// 生成连续颜色序列（如[1,1,2,3...]）  
for(int i=0; i<n; i++)  
    for(int j=0; j<x; j++) v.push_back(i+1);  

// 蛇形填充  
for(int i=0; i<h; i++) {  
    if(i%2 == 0)  // 偶数索引行正序  
        for(int j=0; j<w; j++) Grid[i][j] = v[w*i + j];  
    else          // 奇数索引行逆序  
        for(int j=0; j<w; j++) Grid[i][w-1-j] = v[w*i + j];  
}  
```  

---

### 优化总结  
**最优思路**：蛇形遍历法。通过交替行填充方向，保证颜色块的连续性和相邻行间的连通性。此方法时间复杂度 $O(HW)$，空间复杂度 $O(HW)$，均为最优。  

**拓展应用**：  
- 类似构造连通块的问题（如迷宫生成、区域划分）。  
- 需要特定形状排列的题目（如螺旋矩阵、蛇形矩阵）。  

**推荐练习**：  
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 构造覆盖逻辑  
2. [P3612 [USACO17JAN] Secret Cow Code S](https://www.luogu.com.cn/problem/P3612) - 分形构造  
3. [P2730 [USACO3.2] Magic Squares](https://www.luogu.com.cn/problem/P2730) - 状态空间构造

---
处理用时：61.65秒
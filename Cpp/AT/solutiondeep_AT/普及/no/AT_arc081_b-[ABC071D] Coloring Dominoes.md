# 题目信息

# [ABC071D] Coloring Dominoes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc071/tasks/arc081_b

$ 2\ \times\ N $ のマス目があります． すぬけ君は，このマス目に $ N $ 個のドミノを，重ならないように敷き詰めました． ここで，ドミノは，$ 1\ \times\ 2 $ または $ 2\ \times\ 1 $ のマス目を覆うことができます．

すぬけ君は，赤色，水色，緑色の $ 3 $ 色を使って，これらのドミノを塗ることにしました． このとき，辺で接しているドミノは異なる色で塗るようにします． ここで，必ずしも $ 3 $ 色すべてを使う必要はありません．

このような塗り方が何通りあるかを mod $ 1000000007 $ で求めてください．

ただし，ドミノの敷き詰め方は，文字列 $ S_1,\ S_2 $ を用いて，次のようにして与えられます．

- 各ドミノは，それぞれ異なる英小文字または英大文字で表される．
- $ S_i $ の $ j $ 文字目は，マス目の上から $ i $ 番目，左から $ j $ 番目のマスにどのドミノがあるかを表す．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 52 $
- $ |S_1|\ =\ |S_2|\ =\ N $
- $ S_1,\ S_2 $ は英小文字または英大文字からなる
- $ S_1,\ S_2 $ は正しいドミノの敷き詰め方を表している

### Sample Explanation 1

次の $ 6 $ 通りあります． !\[\](https://atcoder.jp/img/arc081/899673bd23529f4fb5e41c6e7d5bc372.png)

### Sample Explanation 2

必ずしもすべての色を使わなくてもよいことに注意してください．

## 样例 #1

### 输入

```
3

aab

ccb```

### 输出

```
6```

## 样例 #2

### 输入

```
1

Z

Z```

### 输出

```
3```

## 样例 #3

### 输入

```
52

RvvttdWIyyPPQFFZZssffEEkkaSSDKqcibbeYrhAljCCGGJppHHn

RLLwwdWIxxNNQUUXXVVMMooBBaggDKqcimmeYrhAljOOTTJuuzzn```

### 输出

```
958681902```

# AI分析结果



# [ABC071D] Coloring Dominoes 中文翻译

## 题目描述

有一个 $2 \times N$ 的网格。将 $N$ 个多米诺骨牌无重叠地铺满网格，每个多米诺可以覆盖 $1 \times 2$ 或 $2 \times 1$ 的区域。现用红、青、绿三种颜色给骨牌染色，要求相邻（边相邻）骨牌颜色不同。求合法染色方案数模 $1000000007$ 的结果。

输入通过两个字符串 $S_1, S_2$ 描述骨牌布局：
- 每个骨牌用唯一的大小写字母表示
- $S_i$ 的第 $j$ 个字符表示网格第 $i$ 行第 $j$ 列所属的骨牌

## 说明/提示

### 数据范围
- $1 \leq N \leq 52$
- $S_1, S_2$ 长度均为 $N$
- $S_1, S_2$ 是合法的骨牌布局

---

**算法分类**：递推

---

## 题解分析与结论

### 核心思路
通过分情况讨论相邻骨牌布局模式，使用乘法原理逐步累乘方案数。关键点在于：
1. 首列单独处理（竖放3种/横放6种）
2. 后续根据相邻布局模式分4种情况计算乘数：
   - 前竖当前竖 → ×2
   - 前竖当前横 → ×2
   - 前横当前竖 → ×1 
   - 前横当前横 → ×3
3. 处理横向骨牌时需跳格避免重复计算

### 高分题解推荐

#### 1. installb（4星）
**亮点**：
- 直接遍历字符串进行模式判断，逻辑清晰
- 简洁的条件判断覆盖所有情况
- 巧妙处理横向骨牌的跳格逻辑

**核心代码**：
```cpp
for(LL i = s;i < n;){
    if(a[i] == b[i] && a[i - 1] == b[i - 1]) ans *= 2;
    if(a[i] == b[i] && a[i - 1] != b[i - 1]) ans *= 1;
    if(a[i] != b[i] && a[i - 1] == b[i - 1]) ans *= 2;
    if(a[i] != b[i] && a[i - 1] != b[i - 1]) ans *= 3;
    if(a[i] != b[i]) i += 2; // 处理横向骨牌跳格
    else i ++;
    ans %= N;
}
```

#### 2. watcher_YBH（4星）
**亮点**：
- 预处理分组策略降低复杂度
- 通过分组类型（1为竖放，2为横放）简化判断
- 清晰的分组乘法逻辑

**核心代码**：
```cpp
for(int i = 1; i<=cnt; i++){
    if(c[i] == 2){ // 横放组
        if(i == 1) ans *= 6;
        else if(c[i-1] == 1) ans *= 2;
        else if(c[i-1] == 2) ans *= 3;
    }
    else if(c[i] == 1){ // 竖放组
        if(i == 1) ans *= 3;
        else if(c[i-1] == 1) ans *= 2;
        else if(c[i-1] == 2) ans *= 1;
    }
}
```

---

## 关键技巧总结

1. **布局模式识别**：通过比较相邻字符判断骨牌方向（竖放：`S1[i]==S2[i]`，横放：连续两个相同字符）
2. **状态转移矩阵**：建立前状态到当前状态的乘数映射表
3. **跳跃处理**：遇到横放骨牌时直接跳过已处理的区域
4. **MOD操作**：每步相乘后立即取模防止溢出

---

## 类似题目推荐

1. [P1282 多米诺骨牌](https://www.luogu.com.cn/problem/P1282)  
   - 相似点：多米诺骨牌状态转移
2. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)  
   - 相似点：行列分隔问题中的贪心策略
3. [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)  
   - 相似点：递推计数与取模操作

---
处理用时：54.91秒
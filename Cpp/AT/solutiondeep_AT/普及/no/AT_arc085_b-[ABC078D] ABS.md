# 题目信息

# [ABC078D] ABS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc078/tasks/arc085_b

$ N $ 枚のカードからなる山札があります。カードにはそれぞれ数が書かれており， 上から $ i $ 枚目には $ a_i $ が書かれています。

この山札を使い，X さんと Y さんが $ 2 $ 人でゲームをします。 X, Y さんは最初，$ Z,\ W $ が書かれたカードを持っています。 そして X さんから交互に以下を行います。

- 山札から何枚かカードを引く。そして今持っているカードを捨て，最後に引いたカードを代わりに持つ。ただし，必ず $ 1 $ 枚は引かなくてはならない。

山札がなくなるとゲームは終了で，$ 2 $ 人の持っているカードに書かれた数の差の絶対値がこのゲームのスコアになります。

X さんはスコアを最大化するように，Y さんはスコアを最小化するようにゲームをプレイした時， スコアはいくつになるでしょうか？

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ N\ \leq\ 2000 $
- $ 1\ \leq\ Z,\ W,\ a_i\ \leq\ 10^9 $

### Sample Explanation 1

X さんが最初に $ 2 $ 枚カードを引くと，次に Y さんが最後のカードを引き，スコアは $ |1000\ -\ 100|\ =\ 900 $ になります。

### Sample Explanation 2

X さんが最初に全てのカードを引くと，スコアは $ |100\ -\ 1000|\ =\ 900 $ になります。

## 样例 #1

### 输入

```
3 100 100

10 1000 100```

### 输出

```
900```

## 样例 #2

### 输入

```
3 100 1000

10 100 100```

### 输出

```
900```

## 样例 #3

### 输入

```
5 1 1

1 1 1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
1 1 1

1000000000```

### 输出

```
999999999```

# AI分析结果



### 题目翻译
#### [ABC078D] ABS

**题目描述**  
有一叠由 $N$ 张卡牌组成的山札，第 $i$ 张卡牌上的数字为 $a_i$。  
X 和 Y 两人用这叠卡牌进行游戏，初始时 X 和 Y 分别持有数字为 $Z$ 和 $W$ 的卡牌。两人轮流操作（X 先手），每次操作需从山札顶部连续抽取至少一张卡牌，并丢弃当前持有的卡牌，仅保留最后抽取的一张卡。当山札被抽完时，游戏结束，最终得分为两人持有卡牌数字差的绝对值。  
X 希望最大化得分，Y 希望最小化得分，求最终得分。

**样例说明**  
- 样例1：X 先取2张，Y 取最后1张，得分为 $|1000-100|=900$。  
- 样例2：X 直接取完所有卡牌，得分为 $|100-1000|=900$。  
- 样例3：所有卡牌均为1，得分为0。  
- 样例4：仅1张卡牌，X 必须取它，得分为 $|10^9-1|$。

---

### 算法分类  
**贪心**  

---

### 题解对比与结论  

#### 核心思路  
所有题解均指出：**X 的最优策略是第一次取牌时直接取完所有牌或仅留1张牌**。此时最终得分仅与最后两张牌的值有关，即取以下两种情况的最大值：  
1. X 取完所有牌，得分为 $|a_n - W|$。  
2. X 留1张牌，Y 被迫取最后一张，得分为 $|a_n - a_{n-1}|$。  

**关键结论**：无论中间过程如何，最终得分仅需比较上述两种情况的最大值。  

---

### 精选题解  

#### 1. 作者：UnyieldingTrilobite（5星）  
**关键亮点**  
- 简洁证明先手最优策略的必然性。  
- 直接处理最后两个元素，代码高效。  
**代码核心**  
```cpp
int ans = abs(a[n] - w);
if (n > 1) ans = max(ans, abs(a[n] - a[n-1]));
cout << ans << endl;
```

#### 2. 作者：small_john（5星）  
**关键亮点**  
- 明确公式分情况讨论，逻辑清晰。  
- 特判 $n=1$ 的情况处理到位。  
**代码核心**  
```cpp
if(n==1) cout<<abs(a[1]-w);
else cout<<max(abs(a[n]-a[n-1]),abs(a[n]-w));
```

#### 3. 作者：Kobe_BeanBryant（4星）  
**关键亮点**  
- 公式化表达最优解，注释清晰。  
- 代码简洁，直接体现核心逻辑。  
**代码核心**  
```cpp
if(n==1) printf("%lld",abs(a[1]-w));
else printf("%lld",max(abs(a[n]-a[n-1]),abs(a[n]-w)));
```

---

### 关键技巧总结  
1. **贪心选择**：先手只需考虑极端情况（取完或留1张），避免复杂博弈分析。  
2. **问题简化**：通过观察将问题转化为仅与最后两张卡相关的计算。  
3. **特判处理**：注意 $n=1$ 的特殊情况，直接取唯一卡牌。  

---

### 拓展与同类题目  
- **类似博弈贪心**：当双方采取最优策略时，往往存在局部最优解无需全局计算。  
- **同类题目推荐**：  
  1. [P2734 [USACO3.3] 游戏](https://www.luogu.com.cn/problem/P2734)  
  2. [P2964 [USACO09NOV] Coin Game](https://www.luogu.com.cn/problem/P2964)  
  3. [P1288 取数游戏II](https://www.luogu.com.cn/problem/P1288)  

---

### 个人心得摘录  
- **yyz_100110**：不能单方面思考，Y 的决策会制约 X 的最优选择。  
- **fish_love_cat**：中间卡牌无影响，仅最后两张决定结果。  
- **Sirkey**：隐藏条件为先手策略直接锁定最终可能的最优解。

---
处理用时：63.31秒
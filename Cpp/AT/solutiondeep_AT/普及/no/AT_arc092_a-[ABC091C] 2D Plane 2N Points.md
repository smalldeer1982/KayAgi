# 题目信息

# [ABC091C] 2D Plane 2N Points

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc091/tasks/arc092_a

二次元平面に，赤い点と青い点が $ N $ 個ずつあります。 $ i $ 個目の赤い点の座標は $ (a_i,\ b_i) $ で，$ i $ 個目の青い点の座標は $ (c_i,\ d_i) $ です。

赤い点と青い点は，赤い点の $ x $ 座標が青い点の $ x $ 座標より小さく， また赤い点の $ y $ 座標も青い点の $ y $ 座標より小さいとき，仲良しペアになれます。

あなたは最大で何個の仲良しペアを作ることができますか？ ただし，$ 1 $ つの点が複数のペアに所属することはできません。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ N\ \leq\ 100 $
- $ 0\ \leq\ a_i,\ b_i,\ c_i,\ d_i\ <\ 2N $
- $ a_1,\ a_2,\ ...,\ a_N,\ c_1,\ c_2,\ ...,\ c_N $ はすべて異なる
- $ b_1,\ b_2,\ ...,\ b_N,\ d_1,\ d_2,\ ...,\ d_N $ はすべて異なる

### Sample Explanation 1

例えば， $ (2,\ 0) $ と $ (4,\ 2) $ をペアにし， $ (3,\ 1) $ と $ (5,\ 5) $ をペアにすればよいです。

### Sample Explanation 2

例えば， $ (0,\ 0) $ と $ (2,\ 3) $ をペアにし， $ (1,\ 1) $ と $ (3,\ 4) $ をペアにすればよいです。

### Sample Explanation 3

一つもペアが作れない場合もあります。

## 样例 #1

### 输入

```
3

2 0

3 1

1 3

4 2

0 4

5 5```

### 输出

```
2```

## 样例 #2

### 输入

```
3

0 0

1 1

5 2

2 3

3 4

4 5```

### 输出

```
2```

## 样例 #3

### 输入

```
2

2 2

3 3

0 0

1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
5

0 0

7 3

2 2

4 8

1 6

8 5

6 9

5 4

9 1

3 7```

### 输出

```
5```

## 样例 #5

### 输入

```
5

0 0

1 1

5 5

6 6

7 7

2 2

3 3

4 4

8 8

9 9```

### 输出

```
4```

# AI分析结果



# [ABC091C] 二维平面的2N个点

## 题目描述

在二维平面上有 $N$ 个红色点和 $N$ 个蓝色点。第 $i$ 个红色点的坐标是 $(a_i, b_i)$，第 $i$ 个蓝色点的坐标是 $(c_i, d_i)$。

当红色点的 $x$ 坐标严格小于蓝色点的 $x$ 坐标，且红色点的 $y$ 坐标也严格小于蓝色点的 $y$ 坐标时，这两个点可以组成一对友好配对。

计算最多能组成多少对友好配对，且每个点只能属于一对配对。

## 算法分类
图论（二分图最大匹配）

## 题解综合分析

### 核心思路对比
1. **匈牙利算法**（5篇题解采用）：
   - 构建二分图：红点为左部，蓝点为右部
   - 建立边条件：a_i < c_j 且 b_i < d_j
   - 时间复杂度：O(n^3) 可接受（n≤100）
   
2. **贪心算法**（1篇题解采用）：
   - 按坐标排序后贪心匹配
   - 蓝点按x升序排序，红点按y降序排序
   - 时间复杂度：O(n^2)

3. **最大流算法**（1篇题解采用）：
   - 建模为超级源点→红点→蓝点→超级汇点的网络
   - 使用AC库的maxflow直接求解
   - 时间复杂度：O(n^2.667)

### 最优题解推荐

#### 1. syxmz（贪心+匈牙利）★★★★★
**亮点**：
- 提供双解法代码，对比学习价值高
- 贪心解法排序策略清晰（蓝点x升序，红点y降序）
- 匈牙利实现标准易读

**核心贪心代码**：
```cpp
sort(q, q + n, [](node a, node b) { return a.x < b.x; });
sort(p, p + n, [](node a, node b) { return a.y > b.y; });

for 每个蓝点:
   找满足条件且未使用的最大的红点y
```

#### 2. Guizy（匈牙利）★★★★☆
**亮点**：
- 代码简洁，变量命名清晰
- 使用vector邻接表存图
- 包含vis数组重置的注意事项注释

**核心代码**：
```cpp
for(int i=1;i<=n;i++)
    for(int j=n+1;j<=n*2;j++)
        if(红点条件) G[i].push_back(j);

int ans=0;
for(int i=1;i<=n;i++){
    memset(vis,0,sizeof vis); // 关键重置
    ans += dfs(i);
}
```

#### 3. 0xyz（最大流）★★★★☆
**亮点**：
- 利用现成库函数实现极简代码
- 展示非传统算法的可行性
- 边数O(n^2)时理论效率最优

**代码片段**：
```cpp
mf_graph<int> g(2*n+2);
// 建图
R(i) g.add_edge(0,i,1), g.add_edge(n+i,2*n+1,1);
R(i)R(j) if(条件) g.add_edge(i,n+j,1);
cout << g.flow(0,2*n+1);
```

## 关键技巧总结
1. **二分图建模**：将配对条件转化为有向边，红蓝点分属两部
2. **贪心排序策略**：优先处理x小的蓝点，匹配y大的红点
3. **状态重置**：匈牙利算法中每次DFS前必须清空访问数组
4. **库函数利用**：maxflow等高级算法库可简化代码

## 相似题目推荐
1. [P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)（模板题）
2. [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)（网络流建模）
3. [P1963 变换序列](https://www.luogu.com.cn/problem/P1963)（特殊匹配条件）

## 心得体会摘录
> "匈牙利算法中vis数组必须每次清空，否则会错误复用之前遍历结果" —— Guizy题解注释  
> "贪心排序时要让后续匹配不影响已得最优解，选择红点y最大的策略是关键" —— syxmz分析  
> "使用AC库的maxflow时要注意节点编号设计，红蓝点不能重叠" —— 0xyz代码设计

---
处理用时：52.68秒
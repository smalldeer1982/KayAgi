# 题目信息

# [ABC097D] Equals

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc097/tasks/arc097_b

$ 1 $ から $ N $ までの整数を並び替えた順列 $ p_1 $, $ p_2 $, .., $ p_N $ があります。 また、 $ 1 $ 以上 $ N $ 以下の整数のペアが $ M $ 個与えられます。 これらは $ (x_1,y_1) $, $ (x_2,y_2) $, .., $ (x_M,y_M) $ で表されます。 シカの AtCoDeer くんは順列 $ p $ に次の操作を好きなだけ行って、 $ p_i\ =\ i $ となる $ i $ ($ 1 $ $ <\ = $ $ i $ $ <\ = $ $ N $) の数を最大にしようと考えています。

- $ 1 $ $ <\ = $ $ j $ $ <\ = $ $ M $ なる $ j $ を選び、 $ p_{x_j} $ と $ p_{y_j} $ をスワップする

操作後の $ p_i\ =\ i $ となる $ i $ の数として考えうる最大値を求めてください。

## 说明/提示

### 制約

- $ 2 $ $ <\ = $ $ N $ $ <\ = $ $ 10^5 $
- $ 1 $ $ <\ = $ $ M $ $ <\ = $ $ 10^5 $
- $ p $ は $ 1 $ から $ N $ までの整数を並び替えた順列
- $ 1 $ $ <\ = $ $ x_j,y_j $ $ <\ = $ $ N $
- $ x_j $ $ ≠ $ $ y_j $
- $ i $ $ ≠ $ $ j $ なら、 $ \{x_i,y_i\} $ $ ≠ $ $ \{x_j,y_j\} $
- 入力は全て整数

### Sample Explanation 1

$ j=1 $ を選んで操作すると、 $ p $ は `1 3 5 4 2` となり、これがベストなので答えは $ 2 $ です。

### Sample Explanation 2

例えば $ j=1 $, $ j=2 $, $ j=1 $ の順に操作すると、 $ p $ は `1 2 3` となり明らかにこれがベストです。 同じ $ j $ を何回選んでもいいことに注意してください。

### Sample Explanation 4

操作をする必要はありません。

## 样例 #1

### 输入

```
5 2

5 3 1 4 2

1 3

5 4```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2

3 2 1

1 2

2 3```

### 输出

```
3```

## 样例 #3

### 输入

```
10 8

5 3 6 8 7 10 9 1 2 4

3 1

4 1

5 9

2 5

6 5

3 5

8 9

7 9```

### 输出

```
8```

## 样例 #4

### 输入

```
5 1

1 2 3 4 5

1 5```

### 输出

```
5```

# AI分析结果



### 题目重写

# [ABC097D] Equals

## 题目描述

给定一个由1到N的整数构成的排列 $p_1, p_2, \ldots, p_N$，以及M个可重复执行的交换操作 $(x_j, y_j)$。每次操作可以交换位置 $x_j$ 和 $y_j$ 的数值。求通过任意次操作后，最多有多少个位置满足 $p_i = i$。

## 输入格式

第一行输入N和M，随后一行给出排列p的N个元素，最后M行给出交换操作对。

## 输出格式

输出最大可能的满足 $p_i = i$ 的位置数目。

## 说明/提示

- 通过交换操作，同一连通块内的数值可以任意排列。
- 使用并查集维护连通块，判断每个位置i的初始数值是否在i的连通块中。

---

### 算法分类
**并查集**

---

### 题解对比与结论

#### 共同思路
所有题解均将交换操作视为图中的边，通过并查集维护连通块。最终统计每个位置i的初始数值 $p_i$ 是否与i处于同一连通块，以此判断能否通过交换使 $p_i = i$。

#### 关键差异
部分题解通过显式建立数值到位置的映射（如Nightingale_OI的 `b[a[i]]=i`），另一些直接比较i与 $p_i$ 的连通性。本质等价，因 $p_i$ 的初始位置是i，两种方法最终判断条件一致。

#### 最优思路
直接比较i与 $p_i$ 的连通性，无需额外映射。核心代码段如下：

```cpp
int find(int x) { // 路径压缩
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}
for (int i = 1; i <= m; i++) { // 合并操作
    int x, y;
    cin >> x >> y;
    fa[find(x)] = find(y);
}
int ans = 0;
for (int i = 1; i <= n; i++) {
    if (find(i) == find(p[i])) ans++; // 关键判断
}
```

---

### 推荐题目
1. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551) - 并查集基础应用
2. [P1892 [BOI2003] 团伙](https://www.luogu.com.cn/problem/P1892) - 并查集扩展
3. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367) - 基础模板题

---
处理用时：388.58秒
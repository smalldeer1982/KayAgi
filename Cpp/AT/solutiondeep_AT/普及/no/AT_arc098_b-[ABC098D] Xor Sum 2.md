# 题目信息

# [ABC098D] Xor Sum 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc098/tasks/arc098_b

長さ $ N $ の整数列 $ A $ があります。

次の条件を満たす整数 $ l $, $ r $ ( $ 1\ \leq\ l\ \leq\ r\ \leq\ N $ ) の組の個数を求めてください。

- $ A_l\ xor\ A_{l+1}\ xor\ ...\ xor\ A_r\ =\ A_l\ +\ A_{l+1}\ +\ ...\ +\ A_r $

xorの説明

整数 $ c_1,\ c_2,\ ...,\ c_m $ の $ xor $ は以下のように定義されます。

- $ xor $ の値を $ X $ とおく。$ X $ を $ 2 $ 進数表記したときの $ 2^k $ ( $ 0\ \leq\ k $, $ k $ は整数 ) の位の値は、$ c_1,\ c_2,\ ...c_m $ のうち、$ 2 $ 進数表記したときの $ 2^k $ の位の値が $ 1 $ となるものが奇数個ならば $ 1 $、偶数個ならば $ 0 $ となる。

例えば、$ 3 $ と $ 5 $ の $ xor $ の値は、$ 3 $ の $ 2 $ 進数表記が $ 011 $、$ 5 $ の $ 2 $ 進数表記が $ 101 $ のため、$ 2 $ 進数表記が $ 110 $ の $ 6 $ となります。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i $
- 入力はすべて整数である

### Sample Explanation 1

明らかに、$ (l,r)=(1,1),(2,2),(3,3),(4,4) $ は条件を満たします。 また、$ (l,r)=(1,2) $ の場合、$ A_1\ xor\ A_2\ =\ A_1\ +\ A_2\ =\ 7 $ となるので、これも条件を満たします。 ほかに条件を満たす組はないので、答えは $ 5 $ になります。

## 样例 #1

### 输入

```
4

2 5 4 6```

### 输出

```
5```

## 样例 #2

### 输入

```
9

0 0 0 0 0 0 0 0 0```

### 输出

```
45```

## 样例 #3

### 输入

```
19

885 8 1 128 83 32 256 206 639 16 4 128 689 32 8 64 885 969 1```

### 输出

```
37```

# AI分析结果



### 题目中文重写
#### [ABC098D] Xor Sum 2

**题目描述**  
给定长度为 $N$ 的整数序列 $A$，求满足以下条件的整数对 $(l, r)$（$1 \leq l \leq r \leq N$）的个数：  
$$A_l \oplus A_{l+1} \oplus \dots \oplus A_r = A_l + A_{l+1} + \dots + A_r$$  
其中 $\oplus$ 表示异或运算，其定义为：对于每一位二进制位，若该位有奇数个1则结果为1，否则为0。

**样例解释**  
例如样例1中，满足条件的区间包括所有单元素区间及区间[1,2]，总数为5。

**数据范围**  
- $1 \leq N \leq 2 \times 10^5$  
- $0 \leq A_i$

---

### 算法分类  
位运算 + 双指针（尺取法）

---

### 题解综合分析

#### 核心思路
所有题解均围绕以下性质展开：  
1. **异或与加法的关系**：$x \oplus y \leq x + y$，当且仅当两数二进制各位最多一个1时取等  
2. **区间扩展性**：若区间 $[l,r]$ 不满足条件，则任何包含它的更大区间也不满足  

#### 解法对比
| 方法        | 时间复杂度 | 关键技巧                         | 优势                     |
|-----------|--------|------------------------------|------------------------|
| 双指针法      | O(n)   | 维护当前区间的异或和与累加和            | 线性效率，代码简洁             |
| 前缀和+二分法  | O(nlogn)| 预处理前缀异或与前缀和，二分查找最大右端点      | 思路直观，但效率略低            |
| 暴力枚举      | O(n^2) | 逐个子区间判断                    | 仅适用于小数据，无法通过本题        |

---

### 高星题解推荐

#### 1. 题解作者：Cylete（★★★★★）
**核心亮点**  
- 使用双指针法直接维护区间和与异或值，无需预处理  
- 代码简洁高效，完美体现尺取法的优势  
**关键代码**  
```cpp
int n, s1 = 0, s2 = 0, ans = 0;
int a[N]; // 原始数组

for (int i = 1, j = 0; i <= n; i++) {
    // 扩展右端点
    while (j + 1 <= n && s1 + a[j+1] == (s2 ^ a[j+1])) {
        j++;
        s1 += a[j];
        s2 ^= a[j];
    }
    ans += j - i + 1; // 统计以i为左端点的合法区间数
    // 移动左端点前更新值
    s1 -= a[i];
    s2 ^= a[i];
}
```

#### 2. 题解作者：RainFestival（★★★★☆）
**核心亮点**  
- 极简实现（305字节代码）  
- 同步维护异或(x)与和(y)  
**优化技巧**  
- 循环变量初始化的巧妙处理  
- 省去显式数组存储的冗余操作  

#### 3. 题解作者：Plozia（★★★★☆）
**独特价值**  
- 明确阐述异或的逆运算性质  
- 详细解释答案统计逻辑（区间长度累加的原理）  
**心得摘录**  
> "答案统计时需注意：每个新右端点对之前所有左端点的贡献已包含在区间长度中，因此只需累加r-l+1"

---

### 最优思路总结
**关键技巧**  
1. **双指针滑动窗口**：维护合法区间的左右边界  
2. **即时值更新**：动态计算区间和与异或，避免存储前缀数组  
3. **剪枝逻辑**：当右端点无法扩展时，左端点前移后无需重置右端点  

**实现要点**  
- 使用`long long`防止溢出  
- 异或与加减操作的原子性（同步更新）  
- 右端点只需单向移动的贪心性质  

---

### 拓展练习
1. [CF1009F Dominant Indices](https://www.luogu.com.cn/problem/CF1009F)（双指针+树形结构）  
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（经典尺取法应用）  
3. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)（异或性质+Trie树）  

---

### 调试心得集锦
1. **类型溢出**  
   > "十年OI一场空，不开long long见祖宗" —— 耶耶小朋友  
   需特别注意累加和可能超出int范围  

2. **端点初始化**  
   > "初始时将r设为l-1，避免重复计算" —— RainFestival  
   空区间初始值的正确处理  

3. **位运算优先级**  
   > "异或操作需加括号，避免与比较运算符混淆" —— Plozia  
   `while (s1 + a[j+1] == (s2 ^ a[j+1]))`中的括号不可省略

---
处理用时：53.94秒
# 题目信息

# [ARC106B] Values

## 题目描述

有一个由 $N$ 顶点和 $M$ 边构成的简单无向图。第 $i$ 条边连接顶点 $c_i$ 和顶点 $d_i$。

开始时，顶点 $i$ 的值为 $a_i$。您希望通过执行以下操作(至少一次)，使操作后的每个顶点的值分别为 $b_1,b_2,⋯⋯,b_N$。

您每次可选 $1$ 条边。当选择的边连接顶点 $x$ 和顶点 $y$ 时，可进行以下任意一个操作。

让 $a_x-1,a_y+1$，或者让 $a_x+1,a_y-1$

确定是否有操作可以达到您的目的。

## 样例 #1

### 输入

```
3 2

1 2 3

2 2 2

1 2

2 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
1 0

5

5```

### 输出

```
Yes```

## 样例 #3

### 输入

```
2 1

1 1

2 1

1 2```

### 输出

```
No```

## 样例 #4

### 输入

```
17 9

-905371741 -999219903 969314057 -989982132 -87720225 -175700172 -993990465 929461728 895449935 -999016241 782467448 -906404298 578539175 9684413 -619191091 -952046546 125053320

-440503430 -997661446 -912471383 -995879434 932992245 -928388880 -616761933 929461728 210953513 -994677396 648190629 -530944122 578539175 9684413 595786809 -952046546 125053320

2 10

6 12

9 11

11 5

7 6

3 15

3 1

1 9

10 4```

### 输出

```
Yes```

# AI分析结果



# [ARC106B] Values

## 题目描述

有一个由 $N$ 个顶点和 $M$ 条边构成的简单无向图。第 $i$ 条边连接顶点 $c_i$ 和顶点 $d_i$。

开始时，顶点 $i$ 的值为 $a_i$。您希望通过执行以下操作（至少一次），使操作后的每个顶点的值分别为 $b_1,b_2,\cdots,b_N$。

每次操作可任选一条边。当选择的边连接顶点 $x$ 和顶点 $y$ 时，可进行以下任意一个操作：

- 让 $a_x-1$，$a_y+1$
- 让 $a_x+1$，$a_y-1$

确定是否存在这样的操作序列可以达到目标。

## 样例 #1

### 输入
```
3 2
1 2 3
2 2 2
1 2
2 3
```

### 输出
```
Yes
```

---

**算法分类**：并查集

---

## 题解分析与结论

所有题解均基于以下核心思路：
1. **总和守恒**：每次操作不会改变连通块的总和
2. **连通块约束**：必须每个连通块的初始总和等于目标总和
3. **并查集应用**：通过并查集划分连通块后验证约束

### 高分题解推荐

#### 1. pioneer2000（⭐⭐⭐⭐）
**核心亮点**：
- 清晰的并查集模板实现
- 显式初始化父节点数组
- 使用两次独立数组存储初始与目标总和
```cpp
int get(int a){ // 路径压缩
    if(p[a]==a) return a;
    return p[a]=get(p[a]);
}
void unite(int a,int b){ // 合并操作
    a=get(a); b=get(b);
    if(a!=b) p[a]=b;
}
// 主逻辑
for(int i=1;i<=n;i++){ 
    ans[get(i)] += a[i];
    ans1[get(i)] += b[i];
}
```

#### 2. wang_freedom（⭐⭐⭐⭐）
**代码亮点**：
- 使用简洁的并查集路径压缩
- 采用分离的数组存储连通块总和
```cpp
ll find(ll x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
// 合并逻辑
fa[find(u)] = find(v);
```

#### 3. hhztl（⭐⭐⭐⭐）
**实现亮点**：
- 简洁的代码结构
- 显式注释说明总和验证逻辑
```cpp
for(int i=1;i<=n;i++){
    s1[fd(i)] += a[i];
    s2[fd(i)] += b[i];
}
```

---

## 关键思路总结

1. **连通块总和验证**：通过并查集划分连通块后，检查每个连通块的初始值与目标值的总和是否相等
2. **路径压缩优化**：确保并查集查询时间复杂度接近O(1)
3. **数据范围处理**：使用long long防止总和溢出

---

## 同类题目推荐

1. [P8655 [蓝桥杯 2017 国 B] 发现环] - 并查集找环
2. [P1330 封锁阳光大学] - 连通块性质应用
3. [P1197 [JSOI2008] 星球大战] - 逆向并查集应用

---

## 题解心得摘录

1. **yegengghost的调试教训**：  
   *"开始误以为全局总和相等即可，后来意识到必须是每个连通块内部总和相等"*  
   → 强调理解操作的影响范围重要性

2. **hhztl的输出格式提醒**：  
   *"注意输出Yes/No的首字母大写"*  
   → 体现对题面细节的关注

3. **wang_freedom的注意事项**：  
   *"每个连通块的和可能爆int，记得开longlong"*  
   → 突出算法实现中的常见陷阱

---
处理用时：45.13秒
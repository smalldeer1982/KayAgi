# 题目信息

# [ARC109C] Large RPS Tournament

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc109/tasks/arc109_c

最強のじゃんけんの手を決めるため、トーナメント形式のじゃんけん大会が開催されます。 大会の参加者は $ 2^k $ 人で、それぞれ $ 0 $ 以上 $ 2^k $ 未満の整数が振られています。どの参加者もそれぞれ得意な手を持っていて、毎試合得意な手のみを出します。

参加者の得意な手は、長さ $ n $ の `R`, `P`, `S` からなる文字列 $ s $ によって表されます。 具体的には、番号 $ i $ の参加者の得意な手は $ s $ の $ (i\text{\ mod\ }\ n)\ +\ 1 $ 文字目の文字で表されます。ここで、`R` はグー、`P` はパー、`S` はチョキを表します。

$ r-l $ が $ 2 $ のべき乗であるような $ l,\ r $ について、番号が $ l $ 以上 $ r $ 未満の参加者による大会を開いたとき、勝者は次のようにして決定されます。

- $ r-l=1 $ であるとき（つまり、参加者がただ一人であるとき）、勝者は $ l $ とする。
- $ r-l\geq\ 2 $ であるとき、$ m=(l+r)/2 $ として、$ l $ 以上 $ m $ 未満の参加者による大会と、$ m $ 以上 $ r $ 未満の参加者による大会を開催する。それぞれの勝者が $ a,\ b $ であるとき、$ a $ と $ b $ がじゃんけんをして勝ったほうを勝者とする。あいこの場合 $ a $ を勝者とする。

番号が $ 0 $ 以上 $ 2^k $ 未満の参加者による大会の勝者の得意な手を求めてください。

## 说明/提示

### 注意

- $ a\text{\ mod\ }\ b $ は $ a $ を $ b $ で割ったあまりを表す
- じゃんけんの勝敗は次のように決められる
  - 同じ手同士はあいこである
  - `R` は `S` に勝つ
  - `P` は `R` に勝つ
  - `S` は `P` に勝つ

### 制約

- $ 1\ \leq\ n,k\ \leq\ 100 $
- $ s $ は `R`, `P`, `S` のみからなる長さ $ n $ の文字列

### Sample Explanation 1

\- 番号が $ 0 $ 以上 $ 2 $ 未満の参加者による大会の勝者の得意な手は `P` です。 - 番号が $ 2 $ 以上 $ 4 $ 未満の参加者による大会の勝者の得意な手は `R` です。 - 番号が $ 0 $ 以上 $ 4 $ 未満の参加者による大会の勝者の得意な手は `P` です。 よって、答えは `P` となります。 ``` P ┌─┴─┐ P R ┌┴┐ ┌┴┐ R P S R ```

## 样例 #1

### 输入

```
3 2

RPS```

### 输出

```
P```

## 样例 #2

### 输入

```
11 1

RPSSPRSPPRS```

### 输出

```
P```

## 样例 #3

### 输入

```
1 100

S```

### 输出

```
S```

# AI分析结果



【题目翻译】

# [ARC109C] 大型 RPS 锦标赛

## 题目描述

为决出最强的猜拳手，将举办锦标赛形式的猜拳大赛。参赛者共有 $2^k$ 人，编号为 $0$ 至 $2^k-1$。每个参赛者都有固定的出拳方式，由长度为 $n$ 的字符串 $s$ 循环决定：编号 $i$ 的选手出拳为 $s$ 的第 $(i \bmod n) + 1$ 个字符（R=石头，P=布，S=剪刀）。

比赛规则：
- 当区间长度 $r-l=1$ 时，胜者即为 $l$ 号选手
- 当区间长度 $\geq 2$ 时，将区间分为两半分别比赛，两个子区间的胜者对决，胜者按猜拳规则决定（平局时取前者）

求最终整个锦标赛胜者的出拳方式。

**算法分类**：分治/模拟

---

【题解分析】

### 最优思路提炼
通过观察发现，每一轮比赛后的胜者序列仍保持循环特性。利用这一性质，只需维护长度为 $n$ 的循环节，在 $k$ 轮中不断压缩处理：
1. 每轮将当前循环节扩展为双倍长度（处理相邻元素）
2. 计算每组两两对决后的新循环节
3. 经过 $k$ 轮迭代后，首元素即为最终胜者

**关键技巧**：预处理胜负关系表 + 循环节压缩处理

---

### 高分题解推荐

1. **XYQ_102（5星）**
   - **亮点**：代码简洁高效，利用循环节特性实现 O(kn) 时间复杂度
   - **核心代码**：
     ```cpp
     char win[222][222]; // 预处理胜负表
     while(m--) {
         string t = s + s;
         for (int i=0;i<n;i++) 
             s[i] = win[t[i*2]][t[i*2+1]]; // 相邻元素对决
     }
     cout << s[0];
     ```

2. **DgNeHzL7777（4星）**
   - **亮点**：图示辅助理解，强调循环节的压缩过程
   - **心得**："每一轮处理后胜者的出拳序列仍然是循环的，这使得我们只需处理有限长度的序列"

---

### 拓展练习
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047) - 区间处理与压缩
2. [P1220 关路灯](https://www.luogu.com.cn/problem/P1220) - 分治决策与状态压缩
3. [P1438 无聊的数列](https://www.luogu.com.cn/problem/P1438) - 循环节与差分技巧

---

### 重点代码片段
预处理胜负表 + 核心迭代逻辑：
```cpp
char win['S'+1]['S'+1] = { // ASCII码预处理
    /* R */ {'R','R','S'}, 
    /* P */ {'P','P','R'}, 
    /* S */ {'S','P','S'} 
};
for (int round = 0; round < k; ++round) {
    string next = s + s; // 扩展双倍循环节
    for (int i = 0; i < n; ++i) {
        int a = i * 2, b = a + 1;
        s[i] = win[next[a]][next[b]]; // 相邻对决
    }
}
cout << s[0];
```

---
处理用时：56.80秒
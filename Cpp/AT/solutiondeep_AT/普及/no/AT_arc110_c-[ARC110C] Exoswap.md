# 题目信息

# [ARC110C] Exoswap

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc110/tasks/arc110_c

$ 1,\ 2,\ \ldots,\ N $ を並び替えた数列 $ P\ =\ P_1,\ P_2,\ \ldots,\ P_N $ があります。

あなたは $ P $ に対して、以下の $ N\ -\ 1 $ 種類の操作を、任意の順番で**ちょうど $ 1 $ 回ずつ**行わなければなりません。

- $ P_1 $ と $ P_2 $ を入れ替える
- $ P_2 $ と $ P_3 $ を入れ替える
  
  $ \vdots $
- $ P_{N\ -\ 1} $ と $ P_N $ を入れ替える

操作の順番を適切に決めることで、$ P $ を昇順に並び替えてください。 もしそれが不可能な場合、`-1` を出力してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ P $ は $ 1,\ 2,\ \ldots,\ N $ を並び替えた数列

### Sample Explanation 1

以下のような操作列が $ P $ を昇順に並び替えます。 - まず $ P_4 $ と $ P_5 $ を入れ替える。$ P $ は $ 2,\ 4,\ 1,\ 3,\ 5 $ になる - 次に $ P_2 $ と $ P_3 $ を入れ替える。$ P $ は $ 2,\ 1,\ 4,\ 3,\ 5 $ になる - 次に $ P_3 $ と $ P_4 $ を入れ替える。$ P $ は $ 2,\ 1,\ 3,\ 4,\ 5 $ になる - 次に $ P_1 $ と $ P_2 $ を入れ替える。$ P $ は $ 1,\ 2,\ 3,\ 4,\ 5 $ になる

## 样例 #1

### 输入

```
5

2 4 1 5 3```

### 输出

```
4

2

3

1```

## 样例 #2

### 输入

```
5

5 4 3 2 1```

### 输出

```
-1```

# AI分析结果



# [ARC110C] Exoswap

## 题目描述

给定一个排列 $P = P_1, P_2, \ldots, P_N$，你需要通过以下 $N-1$ 种操作（每个操作必须恰好执行一次）将其变为升序排列：

- 交换 $P_1$ 和 $P_2$
- 交换 $P_2$ 和 $P_3$
- $\vdots$
- 交换 $P_{N-1}$ 和 $P_N}$

输出操作顺序的索引（按执行顺序），若无法完成输出 `-1`。

**算法分类**：构造

---

### 题解综合分析

本题核心在于构造满足以下条件的交换顺序：
1. 每个相邻位置必须交换且仅交换一次
2. 交换后的排列最终有序
3. 交换顺序必须满足操作后不影响已归位元素

#### 最优思路总结
采用**贪心策略**，依次将最小元素或最大元素归位。关键技巧是：
1. 维护已处理的右边界，避免重复操作（dongzhen 解法）
2. 通过位置映射数组快速定位元素（Confringo 解法）
3. 每次归位时批量交换，确保后续交换不影响已处理区间

---

### 高分题解推荐

#### 题解1：dongzhen（⭐⭐⭐⭐⭐）
**核心亮点**：
- 从左到右处理每个元素，确保当前最小元素优先归位
- 使用 `zb[]` 数组记录元素实时位置，维护 `use` 变量标记已处理区间
- 时间复杂度 $O(n)$，代码简洁高效

**核心代码**：
```cpp
for(int i=1;i<=n;++i){
    if(i<=use && date[i]!=i){ // 已处理区间未归位则无解
        puts("-1"); return 0;
    }
    use=zb[i]-1; // 更新处理边界
    for(int e=use;e>=i;--e){ // 批量交换归位i
        swap(date[e],date[e+1]);
        zb[date[e]] = e;
        zb[date[e+1]] = e+1;
        ans.push_back(e);
    }
}
```

#### 题解2：Confringo（⭐⭐⭐⭐）
**核心亮点**：
- 从右到左处理最大元素，模拟冒泡排序
- 通过 `pos[]` 数组记录元素位置，避免重复扫描
- 使用 `used` 标记已处理左边界

**核心代码**：
```cpp
int now=n, used=n+1;
while(now>0){
    if(pos[now]==now) { now--; continue; }
    int temp=pos[now];
    if(now-1>=used) { puts("-1"); return 0; } // 检查冲突
    for(int i=pos[now];i<now;i++){ // 右移归位now
        ans[++cnt]=i;
        swap(a[i],a[i+1]);
        swap(pos[a[i]],pos[a[i+1]]);
    }
    used=temp; // 更新已处理边界
    now--;
}
```

---

### 拓展练习
1. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969) - 贪心构造操作顺序
2. [P1116 车厢重组](https://www.luogu.com.cn/problem/P1116) - 相邻交换排序的步数统计
3. [P2743 乐曲主题](https://www.luogu.com.cn/problem/P2743) - 利用位置映射优化操作

---
处理用时：58.57秒
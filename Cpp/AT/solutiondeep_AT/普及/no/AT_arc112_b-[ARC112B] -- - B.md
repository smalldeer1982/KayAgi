# 题目信息

# [ARC112B] -- - B

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc112/tasks/arc112_b

すぬけくんは、整数 $ B $ を持って整数やさんを訪れました。 整数やさんでは、お金を払うことで、持っている整数を別の整数にしてもらうことができます。

具体的には、次の $ 2 $ 種類のサービスを好きな順で好きなだけ購入することができます。

- $ 1 $ 円を払い、持っている整数を $ -1 $ 倍する。
- $ 2 $ 円を払い、持っている整数から $ 1 $ を引く。

すぬけくんが $ C $ 円以内で作ることのできる整数は何通りありますか？

## 说明/提示

### 制約

- $ -10^{18}\le\ B\ \le\ 10^{18} $
- $ 1\le\ C\ \le\ 10^{18} $
- 入力はすべて整数

### Sample Explanation 1

以下のように、$ -11,10,11 $ の $ 3 $ 通りの数を作ることができます。 - 何もしないとき、$ 0 $ 円を使って $ 11 $ を作ることができる - $ 11 $ を $ -1 $ 倍すると、$ 1 $ 円を使って $ -11 $ を作ることができる - $ 11 $ から $ 1 $ を引くと、$ 2 $ 円を使って $ 10 $ を作ることができる

### Sample Explanation 2

以下のように、$ -2,-1,0,1 $ の $ 4 $ 通りの数を作ることができます。 - 何もしないとき、$ 0 $ 円を使って $ 0 $ を作ることができる - $ 0 $ から $ 1 $ を引くと、$ 2 $ 円を使って $ -1 $ を作ることができる - $ 0 $ から $ 1 $ を引いて $ -1 $ 倍すると、$ 3 $ 円を使って $ 1 $ を作ることができる - $ 0 $ から $ 1 $ を引いて $ 1 $ を引くと、$ 4 $ 円を使って $ -2 $ を作ることができる

## 样例 #1

### 输入

```
11 2```

### 输出

```
3```

## 样例 #2

### 输入

```
0 4```

### 输出

```
4```

## 样例 #3

### 输入

```
112 20210213```

### 输出

```
20210436```

## 样例 #4

### 输入

```
-211 1000000000000000000```

### 输出

```
1000000000000000422```

# AI分析结果



# [ARC112B] -- - B

## 题目描述

すぬけくん带着整数 $ B $ 来到整数商店。该商店提供两种付费服务：

1. 支付 1 日元，将当前整数变为其相反数。
2. 支付 2 日元，将当前整数减 1。

给定预算 $ C $ 日元，求能生成的不同整数总数。

### 输入格式
两个整数 $ B $ 和 $ C $（$-10^{18} \le B \le 10^{18}$，$1 \le C \le 10^{18}$）

### 输出格式
生成的不同整数数量

## 算法分类
数学

---

## 题解分析与结论

### 核心思路
1. **区间划分**：将可能的数值划分为正负两个区间，分别计算每个区间的覆盖范围。
2. **数学推导**：通过操作代价推导出各区间的左右端点：
   - 同符号区间：直接多次减操作或翻转两次后的扩展操作。
   - 异符号区间：通过一次翻转后的减操作生成。
3. **边界处理**：处理 $B=0$ 的特殊情况及区间重叠问题。

### 最优题解

#### 题解1：TLEWA（4星）
**关键亮点**：
- 正负半轴区间的数学建模
- 通过交换区间处理负数初始值
- 针对 $B=0$ 的特判处理

```cpp
#include<bits/stdc++.h>
using namespace std;

long long B,C,ans;
long long l1,r1,l2,r2;

int main() {
    cin >> B >> C;
    l1 = B - (C / 2), r1 = B + ((C - 2) / 2);
    l2 = (-B) - ((C - 1) / 2), r2 = (-B) + ((C - 1) / 2);
    if(B < 0) swap(l1,l2), swap(r1,r2);
    if(B == 0) l2 = l1, r2 = r1; // 处理 B=0 的特殊情况
    if(l1 <= r2) l1 = r2 + 1;    // 去重
    ans = (r1 - l1 + 1) + (r2 - l2 + 1);
    cout << ans;
}
```

#### 题解2：ggc123（4星）
**关键亮点**：
- 四种子操作的区间合并
- 集合运算处理交集
- 简洁的条件判断

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
    int b, c; cin >> b >> c;
    if(b == 0) { cout << c/2 + (c-1)/2 +1; return 0; }
    int l1 = b - c/2, r1 = b + (c-2)/2;
    int l2 = -b - (c-1)/2, r2 = -b + (c-1)/2;
    if(b < 0) swap(l1,l2), swap(r1,r2);
    int overlap = max(0ll, min(r1, r2) - max(l1, l2) + 1);
    cout << (r1-l1+1) + (r2-l2+1) - overlap;
}
```

---

## 关键技巧与拓展

### 核心技巧
- **区间建模**：将操作转换为数轴上的区间覆盖问题。
- **对称处理**：利用正负对称性减少计算量。
- **边界特判**：单独处理 $B=0$ 及区间重叠。

### 类似题目
1. [P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)  
   （数学表达式处理与区间计算）
2. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)  
   （贪心选择与区间优化）
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)  
   （区间覆盖与差分思想）

### 心得体会
- **调试经验**：必须单独测试 $B=0$ 的边界情况。
- **数学推导**：操作顺序对区间端点的影响需要通过数学公式精确推导。
- **优化思路**：通过交换区间避免重复代码，提高可维护性。

---
处理用时：54.32秒
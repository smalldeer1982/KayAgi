# 题目信息

# [ARC114B] Special Subsets

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc114/tasks/arc114_b

$ 1 $ 以上 $ N $ 以下の整数すべてから成る集合を $ S $ とします．

$ f $ は $ S $ から $ S $ への関数であり，$ f(1),\ f(2),\ \cdots,\ f(N) $ の値が $ f_1,\ f_2,\ \cdots,\ f_N $ として与えられます．

$ S $ の空でない部分集合 $ T $ であって，次の両方の条件を満たすものの個数を $ 998244353 $ で割った余りを求めてください．

- 全ての $ a\ \in\ T $ について $ f(a)\ \in\ T $ である．
- 全ての $ a,\ b\ \in\ T $ について $ a\ \neq\ b $ ならば $ f(a)\ \neq\ f(b) $ である．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ f_i\ \leq\ N $
- 入力は全て整数

### Sample Explanation 1

$ f(1)\ =\ 2,\ f(2)\ =\ 1 $ です．$ f(1)\ \neq\ f(2) $ であるため条件の $ 2 $ つ目は常に満たしますが，$ 1 $ つ目の条件より $ 1,\ 2 $ は同時に $ T $ に入っている必要があります．

### Sample Explanation 2

$ f(1)\ =\ f(2)\ =\ 1 $ です．$ 1 $ つ目の条件のため $ 1 $ は $ T $ に属する必要があり，さらに $ 2 $ つ目の条件により $ 2 $ は $ T $ に属することはできません．

### Sample Explanation 3

$ f(1)\ =\ 1,\ f(2)\ =\ 2,\ f(3)\ =\ 3 $ です．$ 1 $ つ目の条件も $ 2 $ つ目の条件も常に満たされるため，$ S $ の空でない部分集合全てが条件を満たします．

## 样例 #1

### 输入

```
2

2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
2

1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
3

1 2 3```

### 输出

```
7```

# AI分析结果



题目内容已翻译为中文：

# [ARC114B] Special Subsets

## 题目描述

给定由 $1$ 到 $N$ 所有整数组成的集合 $S$。函数 $f: S \rightarrow S$ 的取值 $f(1), f(2), \cdots, f(N)$ 以 $f_1, f_2, \cdots, f_N$ 的形式给出。求满足以下条件的非空子集 $T$ 的个数（模 $998244353$）：

1. **闭合性**：对所有 $a \in T$，有 $f(a) \in T$。
2. **单射性**：若 $a, b \in T$ 且 $a \neq b$，则 $f(a) \neq f(b)$。

---

**算法分类**：图论（基环树森林与连通块分析）

---

### 题解综合分析
题目核心是发现满足条件的子集必须构成环结构。将每个元素 $i$ 与 $f(i)$ 连边后，形成基环树森林，每个环对应一个独立连通块。统计连通块数 $cnt$，答案即为 $2^{cnt} - 1$。关键难点在于将抽象条件转化为图结构特性。

---

### 高分题解推荐

#### 题解1：qwq___qaq（4星）
**亮点**：通过DFS遍历邻接表统计连通块，逻辑清晰，代码简洁。  
**关键思路**：构建双向图（$i \leftrightarrow f(i)$），DFS遍历统计连通块数。  
**代码核心**：
```cpp
void dfs(int u) {
    if(vis[u]) return;
    vis[u] = 1;
    for(auto v:G[u]) dfs(v);
}
// 主函数中统计连通块数并计算2^cnt-1
```

#### 题解2：zhizhi_c（4星）
**亮点**：利用并查集高效合并节点，避免显式建图，时间复杂度更优。  
**关键思路**：每对 $(i, f_i)$ 合并至同一集合，最终统计独立集合数。  
**代码核心**：
```cpp
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
// 合并操作后统计独立集合数，计算2^cnt-1
```

---

### 最优思路提炼
1. **基环树建模**：将元素间的映射关系视为图，每个连通块为基环树，合法子集仅能选择环部分。
2. **连通块统计**：无论DFS或并查集，核心是快速确定独立环的数量。
3. **数学结论**：答案形式为 $2^{cnt} - 1$，直接幂运算取模。

---

### 拓展与举一反三
- **类似题目**：
  1. [P2921 USACO08DEC] Halloween on the Farm（基环树应用）
  2. [P2661 NOIP2015 提高组] 信息传递（最小环检测）
  3. [P3385 模板] 负环（环结构判断）

- **思维模式**：将函数映射转化为图论模型是常见技巧，适用于需要分析元素间依赖关系的题目。

---

### 关键代码实现（并查集版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, mod = 998244353;
int fa[N], cnt;

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

int main() {
    int n; cin >> n;
    iota(fa, fa + n + 1, 0);
    for (int i = 1, f_i; i <= n; i++) {
        cin >> f_i;
        int fx = find(i), fy = find(f_i);
        if (fx != fy) fa[fx] = fy;
    }
    int ans = 1;
    for (int i = 1; i <= n; i++) 
        if (find(i) == i) ans = ans * 2 % mod;
    cout << (ans - 1 + mod) % mod;
    return 0;
}
```

---
处理用时：56.27秒
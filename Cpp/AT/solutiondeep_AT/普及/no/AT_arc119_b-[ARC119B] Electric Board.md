# 题目信息

# [ARC119B] Electric Board

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc119/tasks/arc119_b

いま、電光掲示板に `0` と `1` から成る長さ $ N $ の文字列 $ S $ が表示されています。

あなたは次の操作を何回でも行うことができます。なお、ここでは電光掲示板に表示されている文字列の $ i $ $ (1\ \leq\ i\ \leq\ N) $ 文字目を $ S_i $ と表します。

> **操作** 整数 $ (l,\ r) $ $ (1\ \leq\ l\ <\ r\ \leq\ N) $ であって、次の条件のうちいずれかを満たすものを $ 1 $ 組選び、$ S_l $ と $ S_r $ を入れ替える。
> 
> - $ S_l= $ `0` かつ $ S_{l+1}=\cdots=S_r= $ `1` を満たす。
> - $ S_{l}=\cdots=S_{r-1}= $ `1` かつ $ S_r= $ `0` を満たす。

電光掲示板に表示されている文字列を $ T $ に一致させることができるか判定し、可能な場合は操作回数として考えられる最小の値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 500000 $
- $ S $ は `0` と `1` からなる長さ $ N $ の文字列である
- $ T $ は `0` と `1` からなる長さ $ N $ の文字列である

### Sample Explanation 1

例えば以下のように操作を行えば、$ 2 $ 回の操作で電光掲示板に表示されている文字列を `1010111` にすることができます。 - $ (l,\ r)\ =\ (2,\ 4) $ を選んで操作を行う。そのとき、電光掲示板の文字列は `1110110` から `1011110` に変化する。 - $ (l,\ r)\ =\ (4,\ 7) $ を選んで操作を行う。そのとき、電光掲示板の文字列は `1011110` から `1010111` に変化する。

### Sample Explanation 2

操作を行う前の時点で、電光掲示板に表示されている文字列が $ T $ であるため、答えは $ 0 $ となります。

### Sample Explanation 3

どのように操作を行っても、電光掲示板に文字列 $ T $ を表示させることが不可能な場合は、`-1` と出力してください。

## 样例 #1

### 输入

```
7

1110110

1010111```

### 输出

```
2```

## 样例 #2

### 输入

```
20

11111000000000011111

11111000000000011111```

### 输出

```
0```

## 样例 #3

### 输入

```
6

111100

111000```

### 输出

```
-1```

## 样例 #4

### 输入

```
119

10101111011101001011111000111111101011110011010111111111111111010111111111111110111111110111110111101111111111110111011

11111111111111111111111111011111101011111011110111110010100101001110111011110111111111110010011111101111111101110111011```

### 输出

```
22```

# AI分析结果



# [ARC119B] Electric Board

## 题目描述

现有一个由 `0` 和 `1` 组成的长度为 $N$ 的字符串 $S$ 显示在电光板上。你可以执行以下操作任意次：

> **操作**：选择满足以下任一条件的整数对 $(l, r)$（$1 \leq l < r \leq N$）并交换 $S_l$ 和 $S_r$：
> - $S_l = $ `0` 且 $S_{l+1} = \cdots = S_r = $ `1`
> - $S_l = \cdots = S_{r-1} = $ `1` 且 $S_r = $ `0`

判断能否将 $S$ 变为目标字符串 $T$，若可行则求最小操作次数。

### 算法分类
贪心

---

## 题解分析

### 关键思路
每次操作本质是移动单个 `0` 的位置，且不会改变 `0` 的相对顺序。因此只需比较两字符串中所有 `0` 的位置序列，位置不同的个数即为最小操作次数。

### 最优题解

#### 题解1：zajasi（★★★★☆）
**亮点**：
- 使用 `vector` 动态存储 `0` 的位置，避免数组越界
- 代码简洁高效，时间复杂度 $O(N)$

**核心代码**：
```cpp
vector<int> x,y; // 存储S和T中0的位置
for(int i=0;i<n;i++){
    if(a[i]=='0') x.push_back(i);
    if(b[i]=='0') y.push_back(i);
}
if(x.size() != y.size()) cout << -1;
else{
    int cnt = 0;
    for(int i=0; i<x.size(); i++)
        if(x[i] != y[i]) cnt++;
    cout << cnt;
}
```

#### 题解2：cff_0102（★★★★☆）
**亮点**：
- 使用静态数组存储位置，内存控制更优
- 显式处理索引偏移，逻辑清晰

**核心代码**：
```cpp
int zeroa[514114], zerob[514114]; // 存储0的位置
for(int i=0; i<n; i++){
    if(a[i]=='0') zeroa[sa++] = i;
    if(b[i]=='0') zerob[sb++] = i;
}
for(int i=0; i<sa; i++)
    if(zeroa[i] != zerob[i]) s++;
```

#### 题解3：Fu_Da_Ying（★★★☆☆）
**亮点**：
- 预处理数组大小固定，适合大数据量
- 索引从1开始，符合直觉

**注意点**：
- 需确保数组足够大以避免越界

---

## 总结技巧
1. **操作特性分析**：通过观察操作规律，发现 `0` 的移动特性
2. **位置匹配**：将复杂交换问题转化为序列对齐问题
3. **容器选择**：动态数组（vector）更灵活，静态数组更高效

---

## 同类题目推荐
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106) - 贪心思想处理数字序列
2. [P1563 玩具谜题](https://www.luogu.com.cn/problem/P1563) - 位置索引的环形处理
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019) - 差分数组应用

---
处理用时：135.42秒
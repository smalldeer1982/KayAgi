# 题目信息

# [ARC122A] Many Formulae

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc122/tasks/arc122_a

長さ $ N $ の非負整数列 $ A_1,A_2,\cdots,A_N $ が与えられます．

この数列の隣接する $ 2 $ 項の間に `+` または `-` を入れて，一つの式を作ることを考えます．

式を作る方法は $ 2^{N-1} $ 通りありますが，この中でも以下の条件を満たす式を，**良い式**と呼ぶことにします．

- `-` が $ 2 $ 回以上連続で登場しない．

全ての良い式の値を足し合わせた値を求めて下さい． なお，この値はかならず非負整数となることが証明できます． そこで，この値を $ 10^9+7 $ で割った余りを出力してください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数である

### Sample Explanation 1

以下の $ 3 $ 通りの良い式が考えられます． - $ 3+1+5=9 $ - $ 3+1-5=-1 $ - $ 3-1+5=7 $ $ 3-1-5 $ は `-` が $ 2 $ 回以上連続で登場するため，良い式ではありません． よって，答えは $ 9+(-1)+7=15 $ となります．

### Sample Explanation 2

以下の $ 5 $ 通りの良い式が考えられます． - $ 1+1+1+1=4 $ - $ 1+1+1-1=2 $ - $ 1+1-1+1=2 $ - $ 1-1+1+1=2 $ - $ 1-1+1-1=0 $ よって答えは $ 4+2+2+2+0=10 $ となります．

### Sample Explanation 3

答えを $ 10^9+7 $ で割った余りを出力してください．

## 样例 #1

### 输入

```
3

3 1 5```

### 输出

```
15```

## 样例 #2

### 输入

```
4

1 1 1 1```

### 输出

```
10```

## 样例 #3

### 输入

```
10

866111664 178537096 844917655 218662351 383133839 231371336 353498483 865935868 472381277 579910117```

### 输出

```
279919144```

# AI分析结果



# [ARC122A] Many Formulae

## 题目描述

给定一个长度为 $ N $ 的非负整数序列 $ A_1,A_2,\cdots,A_N $。在相邻两项之间插入 `+` 或 `-` 构成算式，要求算式中不能出现两个连续的 `-`。求所有合法算式的计算结果之和，答案对 $ 10^9+7 $ 取模。

### 样例解释
- 样例1中，合法算式为 `3+1+5=9`、`3+1-5=-1`、`3-1+5=7`，总和为 $ 9 + (-1) + 7 = 15 $
- 样例2中，合法算式共有5种，总和为10

---

**算法分类**：动态规划

---

### 题解综合分析

本题需计算所有合法算式之和，核心在于动态规划的状态设计与转移。两篇题解均采用类似的DP思路：
1. 维护两个状态数组：`dp[i][0/1]` 表示第i位为`+`/`-`时的总和
2. 维护方案数数组：`cnt[i][0/1]` 表示第i位为`+`/`-`的方案数
3. 通过分拆总和与方案数，避免重复计算每个位置的贡献

#### 关键思路对比

| 题解作者       | 状态定义                     | 转移方程核心思想                                                                         | 亮点                                                                 |
|----------------|------------------------------|------------------------------------------------------------------------------------------|----------------------------------------------------------------------|
| under_the_time | f[i][s] + g[i][s] 双重状态   | 分离总和与方案数，先计算方案数再推导总和                                                 | 数学推导严谨，代码简洁                                               |
| zzh0755        | dp[i][s] + cnt[i][s] 双重状态| 同步维护总和与方案数，通过取模修正保证非负                                               | 处理边界条件细致，包含n=1的特殊情况                                  |

---

### 精选题解推荐

1. **under_the_time 题解（⭐⭐⭐⭐⭐）**
   - **核心思路**：分离总和与方案数，通过`f[i][s]`记录总和，`g[i][s]`记录方案数
   - **代码亮点**：
     ```cpp
     // 状态转移
     g[i][0] = (g[i-1][0] + g[i-1][1]) % P;
     g[i][1] = g[i-1][0];
     f[i][0] = (f[i-1][0] + f[i-1][1] + 1LL * g[i][0] * a[i]) % P;
     f[i][1] = (f[i-1][0] - 1LL * g[i][1] * a[i] % P + P) % P;
     ```
   - **关键技巧**：将每个位置的贡献拆解为 `a[i] * 方案数`，避免重复计算

2. **zzh0755 题解（⭐⭐⭐⭐）**
   - **核心思路**：同步维护总和与方案数，通过辅助函数处理负数取模
   - **代码亮点**：
     ```cpp
     ll MOD (ll x) { return (x % mod + mod) % mod; } // 负数取模修正
     dp[i][0] = (dp[i-1][0] + dp[i-1][1] + (cnt[i-1][0] + cnt[i-1][1]) * a[i]) % mod;
     dp[i][1] = MOD(dp[i-1][0] - cnt[i-1][0] * a[i]);
     ```
   - **个人心得**：特别处理n=1的边界情况，确保代码鲁棒性

---

### 最优思路总结
1. **状态设计**：每个位置记录两种状态（`+`/`-`），维护总和与方案数
2. **转移方程**：
   - 当前为`+`时：继承前一位所有状态，累加当前值贡献
   - 当前为`-`时：只能继承前一位的`+`状态，扣除当前值贡献
3. **复杂度优化**：O(n)时间复杂度，通过滚动数组可优化空间至O(1)

---

### 拓展应用
- **类似题型**：相邻状态限制问题（如不能连续选择、必须交替选择等）
- **推荐练习**：
  1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)（树形DP状态限制）
  2. [P1133 教主的花园](https://www.luogu.com.cn/problem/P1133)（相邻位置条件约束）
  3. [P2513 逆序对数列](https://www.luogu.com.cn/problem/P2513)（递推计数类DP）

---
处理用时：89.08秒
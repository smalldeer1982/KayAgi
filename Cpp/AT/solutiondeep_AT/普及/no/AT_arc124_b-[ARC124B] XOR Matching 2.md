# 题目信息

# [ARC124B] XOR Matching 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc124/tasks/arc124_b

非負整数のみからなる長さ $ N $ の数列 $ a,b $ が与えられます。$ a,b $ の $ i $ 番目の要素はそれぞれ $ a_i,\ b_i $ です。

非負整数 $ x $ が以下の条件を満たすとき、$ x $ を **よい数** と呼びます。

- 条件：$ b $ を並べ替えて、$ 1\ \leq\ i\ \leq\ N $ を満たすどの整数 $ i $ についても $ a_i\ \text{\ XOR\ }\ b_i\ =\ x $ が成立するようにすることができる。ここで、$ \text{XOR\ } $ はビットごとの排他的論理和である。

よい数を小さい方からすべて列挙してください。

 $ \text{\ XOR\ } $ とは 整数 $ x,\ y $ のビットごとの排他的論理和 $ x\ \text{\ XOR\ }\ y $ は、以下のように定義されます。

- $ x\ \text{\ XOR\ }\ y $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ x,\ y $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \text{\ XOR\ }\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \text{\ XOR\ }\ 101\ =\ 110 $)。

## 说明/提示

### 制約

- 与えられる入力は全て整数
- $ 1\ \leq\ N\ \leq\ 2000 $
- $ 0\ \leq\ a_i,\ b_i\ <\ 2^{30} $

### Sample Explanation 1

\- $ b $ を $ (4,\ 7,\ 6) $ と並び替えたとき、$ a_1\ \text{\ XOR\ }\ b_1\ =\ a_2\ \text{\ XOR\ }\ b_2\ =\ a_3\ \text{\ XOR\ }\ b_3\ =\ 5 $ となるため、$ 5 $ はよい数です。他によい数はありません。

## 样例 #1

### 输入

```
3

1 2 3

6 4 7```

### 输出

```
1

5```

## 样例 #2

### 输入

```
2

0 1

0 2```

### 输出

```
0```

## 样例 #3

### 输入

```
24

14911005 70152939 282809711 965900047 168465665 337027481 520073861 20800623 934711525 944543101 522277111 580736275 468493313 912814743 99651737 439502451 365446123 198473587 285587229 253330309 591640417 761745547 247947767 750367481

805343020 412569406 424258892 329301584 123050452 1042573510 1073384116 495212986 158432830 145726540 623594202 836660574 380872916 722447664 230460104 718360386 620079272 109804454 60321058 38178640 475708360 207775930 393038502 310271010```

### 输出

```
8

107543995

129376201

139205201

160626723

312334911

323172429

481902037

493346727```

# AI分析结果



# [ARC124B] XOR Matching 2

## 题目描述

给定两个长度为 $N$ 的非负整数序列 $a$ 和 $b$。称一个非负整数 $x$ 为"好数"，若存在一种排列方式使得排列后的 $b$ 满足 $\forall i,\ a_i \oplus b_i = x$。要求从小到大输出所有好数。

## 标签
**位运算**、**枚举**、**排序**

---

## 题解分析

### 核心思路
1. **候选值生成**：好数 $x$ 必须满足 $x = a_i \oplus b_j$ 至少存在一组解。进一步观察发现，只需枚举 $x = a_1 \oplus b_j$（即固定 $a$ 的第一个元素与所有 $b$ 元素异或）即可覆盖所有可能的候选值。
2. **验证候选值**：对每个候选 $x$，计算所有 $a_i \oplus x$ 得到新数组 $p$，若排序后的 $p$ 与预排序的 $b$ 完全一致，则 $x$ 合法。
3. **去重与排序**：利用集合（Set）自动去重并排序结果。

### 解决难点
- **候选值范围缩小**：通过固定 $a_1$ 与 $b$ 的异或关系，将候选值数量从 $O(2^{30})$ 缩小到 $O(N)$。
- **高效验证**：通过排序后数组比对（时间复杂度 $O(N \log N)$），避免了全排列的 $O(N!)$ 复杂度。

### 最优解法关键
- 预处理 $b$ 的排序，避免重复排序。
- 利用 Set 结构实现自动去重和排序。
- 时间复杂度 $O(N^2 \log N)$，适用于 $N \leq 2000$ 的规模。

---

## 精选题解

### 题解1：hellolin（⭐⭐⭐⭐⭐）
**亮点**  
- 代码简洁清晰，利用 `std::set` 自动处理去重与排序。
- 预处理 $b$ 的排序，验证时只需一次排序比较。

**核心代码**  
```cpp
bool judge(int x) {
    vector<int> p = a;
    for (auto &i : p) i ^= x;
    sort(p.begin(), p.end());
    return p == sorted_b; // sorted_b 是预处理排序后的b
}
```

### 题解2：XYstarabyss（⭐⭐⭐⭐）
**亮点**  
- 使用哈希表统计元素出现次数，避免排序操作。
- 代码中强调去重的重要性，体现实际调试经验。

**核心代码**  
```cpp
unordered_map<int, int> cnt;
for (int a_i : a) cnt[a_i ^ x]++;
bool valid = true;
for (int b_i : b) {
    if (cnt[b_i]-- <= 0) valid = false;
}
```

### 题解3：TG_Space_Station（⭐⭐⭐⭐）
**亮点**  
- 显式处理去重步骤，逻辑直白易懂。
- 通过固定 $a_1$ 生成候选值，减少冗余计算。

**核心代码**  
```cpp
vector<int> ans;
for (int b_i : b) {
    int x = a[0] ^ b_i;
    vector<int> p = a;
    for (auto &v : p) v ^= x;
    sort(p.begin(), p.end());
    if (p == sorted_b) ans.push_back(x);
}
```

---

## 总结与扩展
### 关键技巧
- **异或性质应用**：利用 $a \oplus b = c \Leftrightarrow a \oplus c = b$ 进行双向推导。
- **预处理排序**：通过提前排序避免重复计算。
- **集合去重**：利用数据结构特性简化代码逻辑。

### 类似题目
1. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)  
2. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)  
3. [P3067 Balanced Cow Subsets](https://www.luogu.com.cn/problem/P3067)  

### 调试心得
- **去重必要性**：多个候选值可能生成相同的 $x$，必须显式去重。
- **哈希表计数**：处理重复元素时需确保严格匹配次数，避免逻辑漏洞。

---
处理用时：187.54秒
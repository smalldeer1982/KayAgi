# 题目信息

# [ARC132B] Shift and Reverse

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc132/tasks/arc132_b

$ 1,\dots,\ n $ の順列 $ p_1,\dots,p_n $ が与えられます。 この順列に対して以下の操作を、好きな順で何度でも行えます。

- 全体をひっくりかえす。つまり、$ p_1,p_2,\dots,p_n $ を $ p_n,p_{n-1},\dots,p_1 $ に並び替える。
- 先頭の項を末尾に移動させる。つまり、$ p_1,\ p_2,\ \dots,p_n $ を $ p_2,\dots,\ p_n,\ p_1 $ に並び替える。

順列を昇順に並び替えるのに必要な操作回数の最小値を求めてください。 ただし、与えられる入力について、これらの操作によって順列を昇順に並び替えられることが保証されています。

## 说明/提示

### 制約

- $ 2\ \leq\ n\ \leq\ 10^5 $
- $ p_1,\dots,p_n $ は $ 1,\dots,n $ の順列
- 問題文中の操作によって $ p_1,\dots,p_n $ を昇順に並び替えられる

### Sample Explanation 1

次のように操作すると $ 2 $ 回で昇順に並び替えできます。 1. 先頭の項を末尾に移動させ、 $ 3,\ 2,\ 1 $ に並び替える。 2. 全体をひっくりかえし、$ 1,\ 2,\ 3 $ に並び替える。 $ 2 $ 回未満の操作で昇順に並び替えることはできないため、答えは $ 2 $ です。

### Sample Explanation 2

どちらの操作をしても $ 1 $ 回で昇順に並び替えできます。 $ 1 $ 回未満の操作で昇順に並び替えることはできないため、答えは $ 1 $ です。

### Sample Explanation 3

次のように操作すると $ 3 $ 回で昇順に並び替えできます。 1. 全体をひっくりかえし、$ 1,10,9,8,7,6,5,4,3,2 $ に並び替える。 2. 先頭の項を末尾に移動させ、 $ 10,9,8,7,6,5,4,3,2,1 $ に並び替える。 3. 全体をひっくりかえし、 $ 1,2,3,4,5,6,7,8,9,10 $ に並び替える。 $ 3 $ 回未満の操作で昇順に並び替えることはできないため、答えは $ 3 $ です。

### Sample Explanation 4

一度も操作する必要がありません。

## 样例 #1

### 输入

```
3

1 3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2

2 1```

### 输出

```
1```

## 样例 #3

### 输入

```
10

2 3 4 5 6 7 8 9 10 1```

### 输出

```
3```

## 样例 #4

### 输入

```
12

1 2 3 4 5 6 7 8 9 10 11 12```

### 输出

```
0```

# AI分析结果



# [ARC132B] Shift and Reverse

## 题目描述

给定 $ 1,\dots,\ n $ 的排列 $ p_1,\dots,p_n $。允许进行以下两种操作：
1. 翻转整个序列
2. 将第一个元素移动到末尾

求将排列变为升序所需的最小操作次数。数据保证有解。

## 算法分类
构造

## 题解综合分析

本题核心在于识别排列的循环特性。所有题解均利用题目保证有解的特性，发现排列必定是以下两种结构之一：
1. 连续递增段后接递增段（如3,4,5,1,2）
2. 连续递减段后接递减段（如5,4,3,2,1,6,7）

最优策略分为两种情况：
- 直接移动：需要移动次数为 $n - a_1 + 1$
- 翻转后移动再翻转：需要次数为 $a_1 + 1$

## 高星题解推荐

### 作者：chinazhanghaoxun（⭐️⭐️⭐️⭐️⭐️）
**关键亮点**：代码极简，直击本质  
**核心思路**：通过输入的前两个元素判断是否已有序，否则取两种操作的较小值  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,a1,a2;
    cin>>n>>a1>>a2;
    if(a1==1 && a2==2) cout<<0;
    else cout<<min(n-a1+1,a1+1);
}
```

### 作者：EternalHeart1314（⭐️⭐️⭐️⭐️）
**关键亮点**：详细推导两种情况等价性  
**分析亮点**：通过数学归纳证明两种结构的操作次数相同  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n, x, y;
    cin >> n >> x >> y;
    if(x == 1 && y == 2) cout << 0;
    else cout << min(x + 1, n - x + 1);
}
```

### 作者：_hxh（⭐️⭐️⭐️⭐️）
**思维启发**：指出操作本质等价于将末尾元素前置  
**代码亮点**：变量命名简洁，逻辑清晰  
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, a, b;
    cin >> n >> a >> b;
    if (a == 1 && b == 2) cout << 0;
    else cout << min(a + 1, n - a + 1);
}
```

## 关键技巧总结
1. **首元素定位法**：通过首元素值快速计算两种操作策略的代价
2. **特判优化**：通过检查前两个元素是否为1和2，快速判断有序状态
3. **逆向思维**：翻转操作的等效性（翻转两次等效于不翻转）

## 拓展思考
类似问题常涉及循环移位特性，如：
1. 判断字符串循环移位（LeetCode 796）
2. 环形数组极值问题（洛谷P1965）
3. 旋转排序数组搜索（LeetCode 33）

## 相似题目推荐
1. [P3131 Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3131)
2. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965)
3. [AT_arc114_b Special Subsets](https://www.luogu.com.cn/problem/AT_arc114_b)

---
处理用时：41.24秒
# 题目信息

# [ARC134B] Reserve or Reverse

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc134/tasks/arc134_b

長さ $ N $ の文字列 $ s $ が与えられます。 $ s $ の $ i $ 文字目は $ s_i $ と表します。

すぬけ君は以下の手順で $ s $ を変化させます。

- $ (1,2,\ \ldots,\ N) $ の長さが**偶数の**（連続するとは限らない）部分列 $ x=(x_1,\ x_2,\ \ldots,\ x_{2k}) $ を選ぶ($ k=0 $ でも構わない)。
- $ s_{x_1} $ と $ s_{x_{2k}} $ を入れ替える。
- $ s_{x_2} $ と $ s_{x_{2k-1}} $ を入れ替える。
- $ s_{x_3} $ と $ s_{x_{2k-2}} $ を入れ替える。
- $ \vdots $
- $ s_{x_{k}} $ と $ s_{x_{k+1}} $ を入れ替える。

すぬけ君が手順を終えたあとの $ s $ としてありうる文字列のうち、辞書順最小のものを求めてください。

 辞書順とは？ 辞書順とは簡単に説明すると「単語が辞書に載っている順番」を意味します。より厳密な説明として、相異なる文字列 $ S $ と文字列 $ T $ の大小を判定するアルゴリズムを以下に説明します。

以下では「 $ S $ の $ i $ 文字目の文字」を $ S_i $ のように表します。また、 $ S $ が $ T $ より辞書順で小さい場合は $ S\ \lt\ T $ 、大きい場合は $ S\ \gt\ T $ と表します。

1. $ S $ と $ T $ のうち長さが短い方の文字列の長さを $ L $ とします。$ i=1,2,\dots,L $ に対して $ S_i $ と $ T_i $ が一致するか調べます。
2. $ S_i\ \neq\ T_i $ である $ i $ が存在する場合、そのような $ i $ のうち最小のものを $ j $ とします。そして、$ S_j $ と $ T_j $ を比較して、 $ S_j $ がアルファベット順で $ T_j $ より小さい場合は $ S\ \lt\ T $ 、大きい場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。
3. $ S_i\ \neq\ T_i $ である $ i $ が存在しない場合、 $ S $ と $ T $ の長さを比較して、$ S $ が $ T $ より短い場合は $ S\ \lt\ T $ 、長い場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ s $ は長さ $ N $ の英小文字のみからなる文字列

### Sample Explanation 1

\- $ x=(1,3) $ のとき、$ s_{1} $ と $ s_{3} $ のみが入れ替わります。 - 手順を終えたあとの $ s $ は `acdb` となり辞書順最小です。

### Sample Explanation 2

\- $ x=() $ のとき、手順を終えたあとの $ s $ は `ab` となり辞書順最小です。 - $ x $ の長さが $ 0 $ でもよいことに注意してください。

## 样例 #1

### 输入

```
4

dcab```

### 输出

```
acdb```

## 样例 #2

### 输入

```
2

ab```

### 输出

```
ab```

## 样例 #3

### 输入

```
16

cabaaabbbabcbaba```

### 输出

```
aaaaaaabbbbcbbbc```

## 样例 #4

### 输入

```
17

snwfpfwipeusiwkzo```

### 输出

```
effwpnwipsusiwkzo```

# AI分析结果



# [ARC134B] Reserve or Reverse

## 题目描述

给定一个长度为 $ N $ 的字符串 $ s $，每个字符记为 $ s_i $。通过选择任意偶数的非连续子序列进行交换操作（具体交换规则详见题面），求操作后可能得到的字典序最小字符串。

## 算法分类
贪心

## 题解分析与结论

### 题解对比与评分

1. **loser_seele（★★★★☆）**
   - **关键亮点**：采用贪心策略，通过预处理每个字符的位置索引，维护双指针动态调整可交换范围。时间复杂度 $ O(n) $。
   - **核心思路**：
     - 为每个字母建立倒序位置索引数组
     - 遍历每个位置时，从更小的字母中寻找最大可用下标进行交换
     - 通过 `last` 变量维护当前可交换的右边界
   - **代码实现**：
     ```cpp
     vector<vector<int>> idx(26); // 每个字母的位置索引
     for (int i = 0; i < n; i++) idx[s[i]-'a'].push_back(i);
     int last = n; // 可交换的右边界
     for (int i = 0; i < n; i++) {
         if (vis[i]) break;
         int cur = s[i]-'a';
         for (int j = 0; j < cur; j++) { // 找更小的字母
             while (!idx[j].empty() && idx[j].back() >= last)
                 idx[j].pop_back();
             if (!idx[j].empty() && idx[j].back() > i) {
                 swap(s[i], s[idx[j].back()]);
                 last = idx[j].back();
                 vis[last] = 1;
                 break;
             }
         }
     }
     ```

2. **mountain_climber（★★★★☆）**
   - **关键亮点**：与上解思路一致，强调贪心选择后续最大下标的最小字符，通过维护可用范围优化效率。
   - **个人心得**：需注意交换后的索引范围调整，避免重复处理已交换位置。

### 最优思路总结
**核心贪心策略**：从左向右遍历，每次为当前字符寻找在其右侧且可交换范围内最小的字符。通过预处理各字符的倒序索引数组快速定位候选位置，动态维护可交换范围的右边界保证正确性。

**关键技巧**：
1. **倒序索引数组**：记录每个字母的最后出现位置，便于快速查找最大候选下标
2. **双指针维护**：通过 `last` 变量逐步缩小可交换范围，保证后续操作的合法性
3. **线性复杂度**：每个位置至多被处理一次，达到 $ O(n) $ 时间复杂度

### 拓展练习
1. [P2870 [USACO07DEC]Best Cow Line G](https://www.luogu.com.cn/problem/P2870) - 贪心选择两端字符
2. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106) - 贪心构造最小数
3. [P1709 [USACO5.3]隐藏口令](https://www.luogu.com.cn/problem/P1709) - 字符串最小表示法

---

通过合理维护可交换范围和使用倒序索引数组，能够高效解决此类字典序最小化问题。同类问题中，贪心策略配合合适的数据结构优化是常见解法。

---
处理用时：117.39秒
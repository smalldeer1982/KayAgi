# 题目信息

# [ARC137B] Count 1's

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc137/tasks/arc137_b

$ 0,1 $ からなる長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます．

あなたはこれから，次の操作をちょうど $ 1 $ 回行います．

- $ A $ の**連続する**部分列を選び，そこに含まれる要素を flip する．つまり，$ 0 $ ならば $ 1 $ に変え，$ 1 $ ならば $ 0 $ に変える． なお，ここで選ぶ部分列は空であることも許され，その場合 $ A $ の要素は全く変化しない．

あなたのスコアは，$ A $ に含まれる $ 1 $ の個数です． あなたが取るスコアとしてあり得る値が何通りあるか求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 1 $
- 入力される値はすべて整数

### Sample Explanation 1

スコアとしてあり得る値は，$ 0,1,2,3 $ の $ 4 $ 通りです． 例えば，$ A $ の $ 2 $ 番目から $ 4 $ 番目までの要素を flip すると，$ A=(0,0,0,1) $ となり，スコアは $ 1 $ になります．

## 样例 #1

### 输入

```
4

0 1 1 0```

### 输出

```
4```

## 样例 #2

### 输入

```
5

0 0 0 0 0```

### 输出

```
6```

## 样例 #3

### 输入

```
6

0 1 0 1 0 1```

### 输出

```
3```

# AI分析结果



# [ARC137B] Count 1's

## 题目描述

给定一个由 $0,1$ 组成的长度为 $N$ 的整数序列 $A=(A_1,A_2,\cdots,A_N)$。你需要执行以下操作恰好一次：

- 选择 $A$ 的**连续**子序列（包括空序列），翻转其中的元素（0 变 1，1 变 0）。

最终得分为操作后 $A$ 中 1 的个数。求可能的不同得分数量。

**算法分类**：前缀和

---

## 题解综合分析

各题解核心思路一致：将翻转区间操作转化为区间和问题，通过前缀和与极值维护求解最大/最小可能得分。关键点包括：
1. 将元素映射为翻转后的得分变化量（0→+1，1→-1）
2. 利用前缀和数组快速计算区间影响
3. 动态维护最小/最大前缀和以获取最大可能增益

### 精选题解（评分≥4星）

**1. Glacial_Shine（5星）**
- **亮点**：代码简洁高效，维护极值过程清晰
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      ansmax = max(ansmax, b[i] - minn);
      ansmin = min(ansmin, b[i] - maxn);
      maxn = max(maxn, b[i]);
      minn = min(minn, b[i]);
  }
  ```
- **思路**：实时维护到当前位置的前缀和极值，计算当前点作为区间右端点时的最大/最小增益

**2. _hxh（4星）**
- **亮点**：详细的问题转化说明与数学推导
- **核心代码**：
  ```cpp
  for(int i = 1;i <= n;i++) {
      ans_max = max(ans_max, a[i] - min_now);
      ans_min = min(ans_min, a[i] - max_now);
      max_now = max(max_now, a[i]);
      min_now = min(min_now, a[i]);
  }
  ```
- **心得**：强调将区间翻转影响转化为前缀和差值的思路，提升问题可解性

**3. zcr0202（4星）**
- **亮点**：变量命名清晰，逻辑直白易懂
- **核心代码**：
  ```cpp
  for(int i = 1; i <= n; i++) {
      max1 = max(max1, sum[i] - min2);
      min1 = min(min1, sum[i] - max2);
      max2 = max(max2, sum[i]);
      min2 = min(min2, sum[i]);
  }
  ```

---

## 最优思路总结

**关键技巧**：
1. **问题转化**：将翻转操作转化为区间和问题，建立每个元素的贡献值数组
2. **前缀和极值维护**：利用动态维护的前缀和极值快速计算最大增益/损失
3. **连续性原理**：证明得分的连续性，将问题简化为极值差计算

**代码实现要点**：
- 预处理前缀和数组时直接计算贡献值
- 单次遍历同时维护前缀和极值和答案极值
- 最终结果为 `max_gain - min_loss + 1`

---

## 拓展练习

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
   **同类技巧**：动态维护前缀和极值求解最大子段和

2. [P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)  
   **相似点**：前缀和+滑动窗口求限定长度区间极值

3. [P5638 光骓者的荣耀](https://www.luogu.com.cn/problem/P5638)  
   **关联技巧**：前缀和预处理与区间跳跃极值分析

---
处理用时：47.41秒
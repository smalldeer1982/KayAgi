# 题目信息

# [ARC138A] Larger Score

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc138/tasks/arc138_a

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ があります． 以降この問題では，$ A $ の先頭 $ K $ 項の和を **スコア** と呼ぶことにします． また，入力で与えられた $ A $ のスコアを $ s $ と置くことにします．

あなたは，以下の操作を好きな回数繰り返すことができます．

- $ A $ のある隣接する $ 2 $ 要素を選び，それらの値を入れ替える．

あなたの目標は，スコアを $ s+1 $ 以上にすることです． 目標が達成可能であるかどうか判定し，また可能であるなら必要な最小の操作回数を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 4\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N-1 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

まず，$ s=2+1=3 $ です． 以下のように操作することで，スコアを $ 4 $ 以上にすることができます． - $ (2,1,1,2)\ \to\ (A_3 $ と $ A_4 $ の値を入れ替える $ )\to\ (2,1,2,1)\ \to\ (A_2 $ と $ A_3 $ の値を入れ替える $ )\to\ (2,2,1,1) $ $ 1 $ 回の操作では目標を達成できないため，必要な最小の操作回数は $ 2 $ になります．

## 样例 #1

### 输入

```
4 2

2 1 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
3 1

3 2 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
20 13

90699850 344821203 373822335 437633059 534203117 523743511 568996900 694866636 683864672 836230375 751240939 942020833 865334948 142779837 22252499 197049878 303376519 366683358 545670804 580980054```

### 输出

```
13```

# AI分析结果



# [ARC138A] Larger Score

## 题目描述

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\cdots,A_N)$。定义序列的前 $K$ 项之和为**得分**。初始得分为 $s$。通过交换相邻元素的操作，要求使新得分至少为 $s+1$，求最小操作次数。若无法达成目标，输出 $-1$。

## 算法分类
贪心、二分

## 题解分析与结论

### 核心思路
1. **关键观察**：要使前 $K$ 项和增大，需将后 $N-K$ 项中的较大元素换入前 $K$ 项，同时尽可能减少交换次数。
2. **最优策略**：对于每个后段元素 $A_j$，寻找前段中最大的 $i$ 使得 $A_j > A_i$，此时交换次数为 $j-i$。最小化所有有效交换的 $j-i$。
3. **高效实现**：预处理前 $K$ 项的后缀最小值数组（单调递减），利用二分查找快速定位满足条件的最大 $i$。

### 最优题解推荐

#### sybs1145 的题解（5星）
- **亮点**：预处理后缀最小值数组，利用二分快速查找，时间复杂度 $O(N \log K)$。
- **核心代码**：
```cpp
// 预处理后缀最小值数组
for (int i = k; i > 0; --i)
    sum[i] = min(a[i], sum[i + 1]);

// 二分查找最大i
for (int j = k+1; j <= n; ++j) {
    int l=1, r=k, res=0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (sum[mid] < a[j]) res = mid, l = mid + 1;
        else r = mid - 1;
    }
    if (res) ans = min(ans, j - res);
}
```

#### Bobi2014 的题解（4星）
- **亮点**：使用优先队列动态维护候选位置，在线处理无需预处理数组。
- **核心代码**：
```cpp
priority_queue<int, vector<int>, greater<int>> q;
// 维护前K项的候选位置
for (int i = k; i >= 1; --i)
    if (q.empty() || a[i] < a[q.top()]) q.push(i);

// 处理后续元素
for (int j = k+1; j <= n; ++j) {
    while (!q.empty() && a[q.top()] < a[j]) {
        ans = min(ans, j - q.top());
        q.pop();
    }
}
```

### 总结
- **关键技巧**：预处理单调性数组与二分查找的结合，或优先队列维护候选位置的贪心策略。
- **易错点**：需验证后段元素是否全部不大于前段最小值，此时直接输出 $-1$。
- **同类扩展**：类似的最优位置匹配问题可参考滑动窗口、双指针、单调栈等算法。

## 相似题目推荐
1. P1908 逆序对（逆序对计数，分治/树状数组）
2. P1090 合并果子（贪心+优先队列）
3. P1106 删数问题（贪心+单调栈）

---
处理用时：141.55秒
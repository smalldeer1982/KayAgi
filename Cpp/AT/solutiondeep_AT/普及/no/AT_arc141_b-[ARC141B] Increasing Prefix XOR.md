# 题目信息

# [ARC141B] Increasing Prefix XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc141/tasks/arc141_b

正整数 $ N,\ M $ が与えられます。

長さ $ N $ の正整数列 $ A=(A_1,\ A_2,\ \dots,\ A_N) $ であって、以下の条件を満たすものの個数を $ 998244353 $ で割った余りを求めてください。

- $ 1\ \leq\ A_1\ <\ A_2\ <\ \dots\ <\ A_N\ \leq\ M $
- $ B_i\ =\ A_1\ \oplus\ A_2\ \oplus\ \dots\ \oplus\ A_i $ としたとき、 $ B_1\ <\ B_2\ <\ \dots\ <\ B_N $

ただしここで、 $ \oplus $ はビット単位 $ \mathrm{XOR} $ 演算を表します。

  ビット単位 $ \mathrm{XOR} $ 演算とは  非負整数 $ A,\ B $ のビット単位 $ \mathrm{XOR} $ 、$ A\ \oplus\ B $ は、以下のように定義されます。

- $ A\ \oplus\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \oplus\ 101\ =\ 110 $)。  
 一般に $ k $ 個の非負整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 $ \mathrm{XOR} $ は $ (\dots\ ((p_1\ \oplus\ p_2)\ \oplus\ p_3)\ \oplus\ \dots\ \oplus\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ の順番によらないことが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ M\ <\ 2^{60} $
- 入力される値はすべて整数

### Sample Explanation 1

例えば $ (A_1,\ A_2)=(1,\ 3) $ とすると $ A_1\ <\ A_2 $ であり、$ B_1=A_1=1,\ B_2=A_1\oplus\ A_2=2 $ より $ B_1\ <\ B_2 $ が成り立つので条件を満たします。 この他には $ (A_1,\ A_2)=(1,\ 2),\ (1,\ 4),\ (2,\ 4),\ (3,\ 4) $ が条件を満たします。

## 样例 #1

### 输入

```
2 4```

### 输出

```
5```

## 样例 #2

### 输入

```
4 4```

### 输出

```
0```

## 样例 #3

### 输入

```
10 123456789```

### 输出

```
205695670```

# AI分析结果



【中文题目】

# [ARC141B] Increasing Prefix XOR

## 题目描述

给定正整数 $ N,\ M $。

求满足以下条件的长为 $ N $ 的正整数序列 $ A=(A_1,\ A_2,\ \dots,\ A_N) $ 的个数，对 $ 998244353 $ 取模：

- $ 1\ \leq\ A_1\ <\ A_2\ <\ \dots\ <\ A_N\ \leq\ M $
- 定义 $ B_i\ =\ A_1\ \oplus\ A_2\ \oplus\ \dots\ \oplus\ A_i $ 时，满足 $ B_1\ <\ B_2\ <\ \dots\ <\ B_N $

其中 $ \oplus $ 表示按位异或运算。

## 说明/提示

### 约束条件

- $ 1\ \leq\ N\ \leq\ M\ <\ 2^{60} $
- 输入均为整数

---

**算法分类**：动态规划、位运算

---

**题解综合分析**

题目要求构造严格递增序列 $ A $，使得其异或前缀和 $ B $ 同样严格递增。核心发现：**当且仅当每个 $ A_i $ 的最高二进制位严格递增时，$ B $ 序列才能保持递增**。这一性质将问题转化为动态规划模型，通过枚举二进制位计算方案数。

---

**精选题解**

1. **FiraCode（★★★★★）**  
   **关键思路**：  
   - 预处理每个二进制位的可选数字范围，动态规划维护长度为 $ i $ 的合法序列数。
   - 滚动数组优化空间，逆序更新避免覆盖。  
   **代码亮点**：  
   ```cpp
   for (ll x = 1; x <= m; ++Log2, x *= 2) {
       ll t = (min(m, x * 2 - 1ll) - x + 1) % mod;
       for (int j = Log2; j; --j) 
           dp[j] = (dp[j] + dp[j - 1] * t) % mod;
   }
   ```

2. **xz001（★★★★☆）**  
   **核心贡献**：  
   - 显式处理二进制位范围，快速幂辅助计算区间端点。
   - 边界条件处理清晰，判断最大可能长度。  
   **优化建议**：  
   快速幂函数未取模可能导致数值溢出，但本题数据范围下不影响正确性。

---

**关键技巧总结**

- **二进制最高位性质**：异或运算后最高位严格递增的特性是解题突破口。
- **动态规划设计**：以序列长度为状态，二进制位为转移维度，通过滚动数组优化空间。
- **数学预处理**：计算每个二进制位对应的可用数字数量，转化为组合问题。

---

**同类题目推荐**

1. [P2114 [NOI2016] 区间](https://www.luogu.com.cn/problem/P2114)（位运算与贪心结合）
2. [P7938 [A] Beautiful Sequence](https://www.luogu.com.cn/problem/P7938)（二进制位构造）
3. [P8845 [省选联考 2022] 卡牌](https://www.luogu.com.cn/problem/P8845)（位运算与动态规划结合）

---
处理用时：50.14秒
# 题目信息

# [ARC145B] AB Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc145/tasks/arc145_b

以下のゲームをゲーム $ n $ と呼びます。

> Alice と Bob でゲームをします。はじめ $ n $ 個の石があります。
> 
> Alice から始めて、交互に次の操作を行い、操作を行えなくなった方が負けとなります。
> 
> - もし Alice が操作を行うなら、石を $ A $ の正の倍数の個数取り除く。
> - もし Bob が操作を行うなら、石を $ B $ の正の倍数の個数取り除く。

ゲーム $ 1 $、ゲーム $ 2 $、…、ゲーム $ N $ のうち、二人が最適に行動したとき Alice が勝つゲームは何個あるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ ,A,B\ \leq\ 10^{18} $
- 入力は全て整数

### Sample Explanation 1

ゲーム $ 1 $ では、Alice は操作を行えないため Alice の負けとなります。 ゲーム $ 2 $ では、Alice が石を $ 2 $ 個取ることで Bob は操作を行えなくなり、Alice の勝ちとなります。 ゲーム $ 3 $ では、Alice が石を $ 2 $ 個取り、Bob が石を $ 1 $ 個取るとAlice は操作を行えないため Alice の負けとなります。 ゲーム $ 4 $ では、Alice が石を $ 2\ \times\ 2\ =\ 4 $ 個取ることで Bob は操作を行えなくなり、Alice の勝ちとなります。 以上より、ゲーム $ 1,2,3,4 $ のうちAlice が勝つゲームは $ 2 $ 個です。

## 样例 #1

### 输入

```
4 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
27182818284 59045 23356```

### 输出

```
10752495144```

# AI分析结果



## 题目中文翻译
### [ARC145B] AB Game

#### 题目描述

Alice 和 Bob 在进行一系列游戏，第 $n$ 个游戏称为游戏 $n$。每个游戏的规则如下：

- 初始时有 $n$ 个石子。
- Alice 先手，两人轮流进行操作，无法操作的一方判负。
- Alice 的操作必须取走 $A$ 的正整数倍个石子。
- Bob 的操作必须取走 $B$ 的正整数倍个石子。

求在游戏 $1$ 到游戏 $N$ 中，当双方都采取最优策略时，Alice 获胜的游戏数量。

#### 输入格式
输入三个整数 $N, A, B$。

#### 输出格式
输出 Alice 获胜的游戏数量。

#### 说明/提示
- $1 \leq N, A, B \leq 10^{18}$
- 输入均为整数

#### 样例解释
样例 1 中，当 $N=4, A=2, B=1$ 时，Alice 在游戏 2 和 4 中获胜，总共有 2 个胜利局。

---

## 算法分类
数学（博弈论推导）

---

## 题解分析与结论

### 关键思路
通过数学推导发现，Alice 获胜的条件可拆分为三段计算：
1. **首段**：当游戏石子数 $n = A$ 时，Alice 直接取完获胜，贡献 1 次。
2. **中间段**：每段长度为 $A$ 的完整区间（共 $\lfloor \frac{N}{A} \rfloor -1$ 段），每段贡献 $\min(A, B)$ 次。
3. **余数段**：剩余石子数 $N \% A$ 的区间，贡献 $\min(N \% A, B-1)$ 次。

总获胜次数公式为：
\[ \text{ans} = 1 + (\lfloor \frac{N}{A} \rfloor -1) \times \min(A,B) + \min(N \% A, B-1) \]
当 $A > N$ 时，直接输出 0。

### 优质题解推荐

#### 题解1：chinazhanghaoxun（5星）
**亮点**：代码简洁，公式普适性强，无需分情况讨论。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int n,a,b;
    cin>>n>>a>>b;
    if(a>n) cout<<0;
    else cout<<1+(n/a-1)*min(a,b)+min(n%a,b-1);
}
```
**核心思想**：直接应用推导公式，处理所有情况。

#### 题解2：luxiaomao（4星）
**亮点**：详细解释分段逻辑，增强理解。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b;
int main(){
    scanf("%lld%lld%lld",&n,&a,&b);
    if(a > n) printf("0");
    else printf("%lld",1 + min(a,b)*(n/a-1) + min(b-1,n%a));
}
```
**核心思想**：通过分段举例（如将石子数划分为多个区间），直观展示贡献计算方式。

---

## 关键技巧
- **数学建模**：将大范围问题转化为分段计算，避免遍历。
- **余数处理**：通过取模运算快速定位剩余区间的贡献。
- **极值优化**：利用 $\min$ 函数统一处理不同大小关系的情况。

---

## 拓展练习
1. **P1247 取石子游戏**（博弈论基础）
2. **P1288 取数游戏 II**（环形博弈策略）
3. **P2148 [SDOI2009] E&D**（组合博弈分析）

---
处理用时：356.63秒
# 题目信息

# [ARC150A] Continuous 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc150/tasks/arc150_a

`0`, `1`, `?` のみからなる長さ $ N $ の文字列 $ S=S_1S_2\dots\ S_N $ が与えられます。

これから $ S $ に含まれるすべての `?` を `0`, `1` のいずれかに置き換えることで、以下の条件がすべて満たされるようにしたいです。

- $ S $ は `1` をちょうど $ K $ 個含む。
- $ K $ 個の `1` は連続している。すなわち、ある $ i\ (1\ \leq\ i\ \le\ N-K+1) $ があって、$ S_i=S_{i+1}=\dots=S_{i+K-1}= $ `1` が成り立つ。

条件を満たすような `?` の置き換え方がちょうど $ 1 $ 通りであるか判定してください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^5 $
- $ 1\ \leq\ K\ <\ N\ \leq\ 3\ \times\ 10^5 $
- $ S $ は `0`, `1`, `?` のみからなる長さ $ N $ の文字列
- 全テストケースに対する $ N $ の総和は $ 3\ \times\ 10^5 $ 以下

### Sample Explanation 1

$ 1 $ 個目のテストケースについて、例えば $ S $ を `101` に変えることができますが、この場合は `1` が連続していないため、条件を満たしません。 $ S $ が条件を満たすようにするには $ S $ を `110` に変えるしかありません。 $ 2 $ 個目のテストケースについて、 $ S $ が条件を満たすようにするには $ S $ を `1100`, または `0110` に変えればよく、条件を満たすような `?` の置き換え方は $ 2 $ 通りあります。 $ 3 $ 個目のテストケースについて、$ S $ が条件を満たすよう `?` を置き換える方法は存在しません。

## 样例 #1

### 输入

```
4

3 2

1??

4 2

?1?0

6 3

011?1?

10 5

00?1???10?```

### 输出

```
Yes

No

No

Yes```

# AI分析结果



题目内容已翻译为中文，并保持原意和格式：

# [ARC150A] Continuous 1

## 题目描述

给定一个由 `0`、`1`、`?` 组成的长度为 $N$ 的字符串 $S$。要求将所有 `?` 替换为 `0` 或 `1`，使得最终字符串满足：
1. 恰好包含 $K$ 个连续的 `1`。
2. 替换方案唯一。

判断是否存在唯一符合条件的方案，共处理 $T$ 个测试用例。

**算法分类**：前缀和

---

### 综合分析与结论
题目核心是判断是否存在唯一的连续 `1` 段且长度恰好为 $K$。两位题解均通过预处理和区间检查实现，但实现方式不同：
- **FReQuenter 的题解**通过前缀和快速计算区间内 `0` 和 `1` 的数量，枚举所有可能的窗口，检查唯一性，思路简洁高效。
- **CarroT1212 的题解**分情况讨论原字符串是否含 `1`，逻辑较复杂，易漏边界条件。

最优思路为**前缀和枚举窗口法**，直接覆盖所有可能情况，时间复杂度 $O(N)$，代码简洁不易错。

---

### 精选题解

#### FReQuenter（4星）
**关键亮点**：  
- 前缀和预处理，快速判断区间合法性  
- 直接枚举所有可能窗口，逻辑清晰  
- 时间复杂度严格线性，适合大规模数据  

**核心代码**：  
```cpp
int sum[300005], sum0[300005];
char s[300005];
int get1(int l, int r) { return sum[r] - sum[l-1]; }
int get0(int l, int r) { return sum0[r] - sum0[l-1]; }

int main() {
    // 预处理前缀和
    for (int i=1; i<=n; i++) {
        sum[i] = sum[i-1] + (s[i]=='1');
        sum0[i] = sum0[i-1] + (s[i]=='0');
    }
    // 枚举所有窗口
    for (int i=1; i<=n-k+1; i++) {
        if (get1(i, i+k-1) == sum[n] && !get0(i, i+k-1)) {
            valid_count++;
        }
    }
    printf(valid_count == 1 ? "Yes\n" : "No\n");
}
```

#### CarroT1212（3星）
**个人心得**：  
- 原字符串无 `1` 时需特殊处理，易忽略边界  
- 扩展左右边界时需精确计算区间长度，调试困难  

---

### 关键思路总结
1. **前缀和优化**：预处理 `0` 和 `1` 的前缀和数组，快速判断区间内是否存在非法字符。
2. **窗口枚举法**：遍历所有长度为 $K$ 的窗口，检查其是否满足：
   - 窗口内无 `0`
   - 原字符串中所有 `1` 必须位于窗口内
3. **唯一性判定**：仅当满足条件的窗口数量为1时输出 `Yes`。

---

### 拓展与相似题目
- **前缀和应用**：P1147 连续自然数和（枚举区间和）
- **字符串处理**：P2678 跳石头（二分答案+区间检查）
- **唯一性判断**：P3406 海底高铁（差分统计区间覆盖次数）

---
处理用时：55.81秒
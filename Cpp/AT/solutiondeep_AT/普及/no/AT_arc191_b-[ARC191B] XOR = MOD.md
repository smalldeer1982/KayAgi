# 题目信息

# [ARC191B] XOR = MOD

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc191/tasks/arc191_b

正整数 $ N,K $ が与えられます。 以下の条件を満たす正整数 $ X $ を **$ N $ と相性の良い数** と呼びます。

- $ X $ と $ N $ の排他的論理和は、$ X $ を $ N $ で割ったあまりと等しい。

$ N $ と相性の良い数が $ K $ 個以上存在するか判定し、存在する場合は $ N $ と相性の良い数のうち $ K $ 番目に小さい値を求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

  排他的論理和とは  非負整数 $ A,\ B $ の排他的論理和、$ A\ \mathrm{XOR}\ B $ は、以下のように定義されます。

- $ A\ \mathrm{XOR}\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \mathrm{XOR}\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \mathrm{XOR}\ 101\ =\ 110 $)。

## 说明/提示

### 制約

- $ 1\le\ T\le\ 2\times\ 10^5 $
- $ 1\le\ N,K\le\ 10^9 $
- 入力される値は全て整数

### Sample Explanation 1

$ N=2 $ の場合について考えます。 - $ X=1 $ のとき、 $ X $ と $ N $ の排他的論理和は $ 3 $ 、$ X $ を $ N $ で割ったあまりは $ 1 $ です。したがって、 $ 1 $ は $ N $ と相性の良い数ではありません。 - $ X=2 $ のとき、 $ X $ と $ N $ の排他的論理和は $ 0 $ 、$ X $ を $ N $ で割ったあまりは $ 0 $ です。したがって、 $ 2 $ は $ N $ と相性の良い数です。 - $ X=3 $ のとき、 $ X $ と $ N $ の排他的論理和は $ 1 $ 、$ X $ を $ N $ で割ったあまりは $ 1 $ です。したがって、 $ 3 $ は $ N $ と相性の良い数です。 よって、 $ 2 $ と相性の良い数のうち $ 1 $ 番目に小さい正整数は $ 2 $ 、$ 2 $ 番目に小さい正整数は $ 3 $ です。したがって、 $ \text{case}_1 $ の答えは $ 2 $ 、 $ \text{case}_2 $ の答えは $ 3 $ です。

## 样例 #1

### 输入

```
4
2 1
2 2
1 7
20250126 191```

### 输出

```
2
3
-1
20381694```

# AI分析结果



### 题目重写
**题目名：[ARC191B] XOR = MOD**

**题目描述**

给定正整数 $N,K$。称正整数 $X$ 为 **与 $N$ 相性良好的数**，当满足：
- $X$ 与 $N$ 的异或值等于 $X$ 除以 $N$ 的余数，即 $X \oplus N = X \bmod N$

判断是否存在至少 $K$ 个这样的 $X$，若存在则输出第 $K$ 小的 $X$。处理 $T$ 个测试用例。

**提示**
- 异或运算定义：若两数某位不同则为1，否则为0
- 例如 $3 \oplus 5 = 6$（二进制：011 ⊕ 101 = 110）

### 算法分类
位运算、构造

### 题解对比与结论

#### 关键思路
1. **取值范围分析**：合法的 $X$ 必须满足 $N \le X < 2N$，此时 $X \bmod N = X - N$
2. **二进制约束**：$X \oplus N = X - N$ 等价于 $N$ 的所有二进制1位在 $X$ 中也必须为1
3. **自由位计算**：$X$ 的构造方式是将 $N$ 二进制中0的位置填充二进制数，填充方式由 $k-1$ 的二进制位决定
4. **可行性判断**：设 $N$ 二进制有 $c$ 个0位，则解的数量为 $2^c$，若 $K > 2^c$ 则无解

#### 最优题解摘选

**1. ARIS2_0（5星）**
- **亮点**：完整推导取值范围，清晰解释二进制位填充策略，代码可读性强
- **核心代码**：
```cpp
vector<int> v; // 存储N二进制中0位的位置
for(int i=0; (1ll<<i)<=n; i++) 
    if(!(n>>i&1)) v.push_back(i);

int ans = n;
k--;
for(int i=0; i<v.size(); i++) 
    if((k>>i)&1) ans += (1ll << v[i]);
```
- **心得**：通过分析最高位限制快速确定解的范围，避免无效枚举

**2. Drifty（4星）**
- **亮点**：使用 bitset 处理二进制位，代码简洁高效
- **核心代码**：
```cpp
bitset<32> tmp(n);
int p = 31;
while(p >=0 && !tmp[p]) p--; // 找最高位
bitset<32> j(k); // k-1的二进制表示
int cur = 0;
for(int i=0; i<=p; i++)
    if(tmp[i]==0) tmp[i] = j[cur++];
```

**3. chenxi2009（4星）**
- **亮点**：极简实现，直接操作位掩码
- **核心代码**：
```cpp
for(int i=0; i<=30; i++)
    if(n >= (1<<i) && !(n&(1<<i))) 
        v.push_back(i); // 记录可填充位
ans += (k-1)的二进制位填充到v指示的位置
```

### 拓展建议
同类问题可考虑以下特征：
1. 需要构造满足位运算等特殊性质的数
2. 解的范围与二进制位分布强相关
3. 利用二进制分解处理字典序或顺序问题

### 推荐习题
1. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114) - 位运算极值
2. [P1582 倒水](https://www.luogu.com.cn/problem/P1582) - 二进制1的数量控制
3. [P2104 二进制](https://www.luogu.com.cn/problem/P2104) - 二进制模拟运算

---
处理用时：52.90秒
# 题目信息

# 常ならずグラフ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2014-final/tasks/code_festival_final_e

Tさんは，諸行無常をモットーにいろいろなことに挑戦しています． Tさんはあるコンテストに長期的に参加していますが，そのコンテストにはレーティング機能があり，一度参加する毎にレーティングが変動します．それらの変動はグラフにまとめられています．

今，Tさんは彼のレーティング変動がプロットされたグラフを眺めています．彼はふと，グラフから一部の点を取り除いてそれらを結び，常に上下に変動しているような折れ線グラフ，名付けて「常ならずグラフ」を作りたくなりました． さらに，グラフに含まれる点の数が最も多いものに興味があります．

さて，あなたはTさんのために，彼のレーティング変動がプロットされたグラフから作ることのできる「常ならずグラフ」の中での最大の点の数を求めてあげることにしました．

あなたには，Tさんのあるコンテスト参加後でのレーティングが，$ N $ 個，時系列で与えられます．その中からいくつかの点を取り除き「常ならずグラフ」を作るとき，ありうる点の最大数を求めなさい．常ならずグラフが作れないときは $ 0 $ を出力しなさい．

あるグラフ $ X=\{x_1,x_2,x_3,..x_n\} $ が「常ならずグラフ」であるとは， $ |X| $ が $ 3 $ 以上かつ， $ x_1＜x_2＞x_3＜x_4＞... $ もしくは $ x_1＞x_2＜x_3＞x_4\ <\ ...$ が成り立つことを意味します．
つまり，含まれる頂点数が $ 3 $ 未満のとき，「常ならずグラフ」ではありません．

## 样例 #1

### 输入

```
4

1 2 5 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5

1 2 3 4 5```

### 输出

```
0```

# AI分析结果



# 中文题目重写

## 题目描述

Tさん的竞赛成绩形成折线图。现要求从中删除部分点，使得剩余点构成"常ならずグラフ"（波浪形序列），即满足以下任一条件：
1. 交替上升下降：x₁ < x₂ > x₃ < x₄ > ...
2. 交替下降上升：x₁ > x₂ < x₃ > x₄ < ...

求能保留的最大点数（至少3点，否则输出0）。

## 输入格式
第一行整数n，第二行n个整数表示成绩序列。

## 输出格式
最大可保留点数，不足3则输出0。

---

**算法分类**：贪心

---

# 题解分析与结论

### 核心思路对比

| 方法       | 思路                                                                 | 时间复杂度 | 实现难度 |
|------------|----------------------------------------------------------------------|------------|----------|
| 贪心扫描   | 遍历时检查连续三元组，若不符合波浪条件则替换中间元素，计数调整       | O(n)       | 易       |
| 动态规划   | 维护每个位置作为波峰/波谷的最大长度，类似最长递增子序列              | O(n²)      | 中等     |

### 最优题解亮点

1. **A_grasser（五星）**
   - **关键思路**：在线调整策略。遍历时若当前三元组不满足条件，将中间元素替换为前驱元素，确保后续判断连贯性
   - **代码亮点**：仅需一次遍历，通过修改数组模拟删除操作
   - **心得引用**："暴力简单，不易错，还能过，那就首选暴力"

2. **Lovely_Elaina（四星）**
   - **关键优化**：采用滑动窗口思想，仅维护三个变量降低空间复杂度
   - **代码亮点**：使用`x,y,z`变量代替数组操作，更节省内存

3. **SunnyLi（四星）**
   - **实现技巧**：Python版本简洁实现，利用列表直接修改元素
   - **心得引用**："人生苦短，我用Python" 体现代码简洁性追求

---

# 关键代码实现

### 贪心算法核心逻辑
```cpp
for(int i=3; i<=n; i++) {
    // 判断三个连续元素是否形成波浪
    bool valid = (a[i-1]>a[i] && a[i-1]>a[i-2]) 
              || (a[i-1]<a[i] && a[i-1]<a[i-2]);
    if (!valid) {
        ans--; 
        a[i-1] = a[i-2]; // 关键：替换中间元素为前驱
    }
}
```

### 动态规划解法（参考）
```python
dp = [[1, 1] for _ in range(n)] # dp[i][0]:波峰, dp[i][1]:波谷
for i in range(n):
    for j in range(i):
        if a[j] < a[i]: 
            dp[i][0] = max(dp[i][0], dp[j][1]+1) # 前驱必须是波谷
        elif a[j] > a[i]:
            dp[i][1] = max(dp[i][1], dp[j][0]+1) # 前驱必须是波峰
```

---

# 拓展与练习

### 同类问题特征
- 序列波形判断（如LeetCode 376.摆动序列）
- 在线调整的贪心策略
- 最长交替子序列问题

### 推荐练习题
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 双向LIS变形
2. [P1564 膜拜](https://www.luogu.com.cn/problem/P1564) - 序列分段贪心
3. [P2947 [USACO09MAR] Look Up S](https://www.luogu.com.cn/problem/P2947) - 单调栈应用

---
处理用时：62.57秒
# 题目信息

# 正方形のチップ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/ddcc2016-final/tasks/ddcc_2016_final_a

半径 $ R $ cmの*ウェーハ*に*ダイシング*という操作を行い、正方形のチップをいくつか作成することにしました。 作成される正方形のチップの個数を求めてください。

ウェーハとは、ある部品を作るのに使われる薄い円盤状の物体です。 ダイシングという操作は、ウェーハの中心から $ C $ cm間隔で水平方向と垂直方向に切れ目を入れてウェーハを分割する操作です。

例として、$ R=15,\ \,\ C=4 $ の例を示します。 破線で示されるようなマス目状に分割がなされ、緑色の領域で示されるような $ 32 $ 個の正方形のチップを作成することができます。

 ![3b83484e97d59df50e3ee39c4a3cbca7.png](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_ddcc_2016_final_a/4884165f81392986b1bb775c3cf1b058de7f8e4a.png)

## 说明/提示

### 制約

- $ 1\ ≦\ R,\ \,\ C\ ≦\ 100 $
- $ R,\ \,\ C $ はいずれも整数

### Sample Explanation 1

\- 問題文中で示した通りです。

### Sample Explanation 2

\- ウェーハの中心を $ (0,0) $ としたとき $ (2,3),(3,3),(2,4),(3,4) $ の $ 4 $ 点で表される正方形のチップは $ (3,4) $ がウェーハの周上にありますが、このようなチップも作成することが可能です。

## 样例 #1

### 输入

```
15 4```

### 输出

```
32```

## 样例 #2

### 输入

```
5 1```

### 输出

```
60```

# AI分析结果



### 题目中文翻译

**题目名称：正方形芯片**

**题目描述**

在半径为 $R$ cm的圆形晶片上进行切割操作，制作正方形芯片。求能制作的正方形芯片个数。

切割操作是从晶片中心每隔 $C$ cm在水平和垂直方向切口，将晶片分割成网格状。例如，当 $R=15$、$C=4$ 时，分割后的绿色区域可制作32个正方形芯片。

**输入格式**

输入两个整数 $R$ 和 $C$。

**输出格式**

输出可制作的正方形芯片个数。

**样例解释**

- 样例1对应题目描述中的情况。
- 样例2中，某些正方形的顶点在圆周上也被计入。

**数据范围**

$1 \leq R, C \leq 100$，均为整数。

---

### 算法分类
**枚举**、**数学**

---

### 题解对比与结论

#### 关键思路
所有题解均基于以下核心思路：
1. **枚举切割点**：每个切割点为 $C$ 的整数倍坐标 $(i \cdot C, j \cdot C)$。
2. **判断是否在圆内**：检查切割点到原点的距离平方 $x^2 + y^2 \leq R^2$。
3. **对称性优化**：仅计算第一象限的切割点，最终结果乘以4。

#### 题解评分与亮点
1. **Jairon314 (5星)**
   - **亮点**：循环步长为 $C$，直接遍历有效切割点，避免冗余计算，效率最优。
   - **代码片段**：
     ```cpp
     for(int i=1; i<=r/c; i++) {
         for(int j=1; j<=r/c; j++) {
             ans += (i*c*c*i + j*c*c*j <= r*r) * 4;
         }
     }
     ```

2. **Miracle_ZX (5星)**
   - **亮点**：循环从 $C$ 开始，每次递增 $C$，直观高效。
   - **代码片段**：
     ```cpp
     for(int i = c; i <= r; i += c) {
         for(int j = c; j <= r; j += c) {
             if(i*i + j*j <= r*r) ans++;
         }
     }
     ```

3. **听取MLE声一片 (5星)**
   - **亮点**：数学推导清晰，通过预计算减少重复乘法。
   - **代码片段**：
     ```cpp
     for(int i=1; i<=n; i++) {
         for(int j=1; j<=n; j++) {
             ans += (i*i*unit + j*j*unit <= dist) * 4;
         }
     }
     ```

#### 最优代码实现
以 **Miracle_ZX** 的代码为例，直接遍历每个切割点，步长为 $C$，判断条件简洁：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int r, c, ans = 0;
    cin >> r >> c;
    for (int i = c; i <= r; i += c)
        for (int j = c; j <= r; j += c)
            if (i*i + j*j <= r*r) ans++;
    cout << ans * 4;
    return 0;
}
```

#### 扩展思路
- **优化方向**：对于更大的 $R$，可二分查找每个 $i$ 对应的最大 $j$。
- **类似问题**：圆内整点计数、网格覆盖问题。

---

### 推荐相似题目
1. **P2559 [AHOI2002] 网络传输**（圆内整点计数）
2. **P1665 正方形计数**（二维枚举与几何判断）
3. **P1217 [USACO1.5] 回文质数**（对称性与数学优化）

---
处理用时：166.88秒
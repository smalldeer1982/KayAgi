# 题目信息

# Picking Up

## 题目描述

[problemUrl]: https://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_b

$ 2 $ 次元平面上に $ N $ 個のボールがあり、$ i $ 番目のボールは $ (x_i,\ y_i) $ にあります。

まず、$ p\ \neq\ 0 $ または $ q\ \neq\ 0 $ を満たす $ 2 $ つの整数 $ p,\ q $ を決め、その後以下の操作を繰り返してボールを全て回収します。

- 残っているボールを $ 1 $ つ選んで回収する。このボールの座標を $ (a,\ b) $ とする。この時、直前に選んだボールの座標が $ (a\ -\ p,\ b\ -\ q) $ である時コスト $ 0 $ 、そうでない時コスト $ 1 $ かかる。ただし、$ 1 $ つ目に選んだボールについては必ずコスト $ 1 $ かかる。

$ p,\ q $ を最適に選んだ場合にボールを全て回収するのにかかるコストの和の最小値を計算してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ |x_i|,\ |y_i|\ \leq\ 10^9 $
- $ x_i\ \neq\ x_j $ または $ y_i\ \neq\ y_j\ (i\ \neq\ j) $
- 入力は全て整数である

### Sample Explanation 1

$ p\ =\ 1,\ q\ =\ 1 $ とすると、$ (1,\ 1) $ のボール、$ (2,\ 2) $ のボールの順に選ぶことでコスト $ 1 $ でボールを全て回収することができます。

### Sample Explanation 2

$ p\ =\ -3,\ q\ =\ -2 $ とすると、$ (7,\ 8) $ のボール、$ (4,\ 6) $ のボール、$ (1,\ 4) $ のボールの順に選ぶことでコスト $ 1 $ でボールを全て回収することができます。

## 样例 #1

### 输入

```
2

1 1

2 2```

### 输出

```
1```

## 样例 #2

### 输入

```
3

1 4

4 6

7 8```

### 输出

```
1```

## 样例 #3

### 输入

```
4

1 1

1 2

2 1

2 2```

### 输出

```
2```

# AI分析结果



【中文重述题目】
# 捡球问题

## 题目描述

二维平面上有 $N$ 个球，第 $i$ 个球的坐标为 $(x_i, y_i)$。需要选择两个非零整数 $p, q$，并按以下规则收集所有球：

- 每次选择一个球，若其坐标为 $(a, b)$，且前一个球的坐标为 $(a-p, b-q)$，则此次操作无代价；否则需要消耗 $1$ 点代价（首次操作必定消耗代价）。

求选择最优 $p, q$ 时的最小总代价。

## 说明/提示

### 数据范围
- $1 \leq N \leq 50$
- 坐标绝对值不超过 $1e9$
- 所有球坐标互不相同

---

**算法分类**：枚举

---

### 综合分析与结论
题目核心在于枚举所有可能的移动步长 $(p, q)$，计算每种步长下的最小操作次数。关键点在于通过两球坐标差确定候选步长，并快速验证该步长下的链式收集路径。时间复杂度为 $O(n^4)$，在数据范围内可行。

---

### 精选题解分析

#### 题解1：Lvlinxi2010（4星）
**核心思路**：  
1. 双重循环枚举所有两球组合 $(i,j)$，计算候选步长 $(p,q)$  
2. 对每个候选步长，遍历所有球 $k$，检查是否存在后续球可形成链式收集  
3. 统计需要独立操作的次数，取最小值  

**代码亮点**：  
- 结构体清晰管理坐标  
- 四重循环逻辑紧凑  
```cpp
int minn = n;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (i == j) continue;
        int p = a[i].x - a[j].x;
        int q = a[i].y - a[j].y;
        int now = 1;
        for (int k = 1; k <= n; k++) {
            if (k == i) continue;
            int cx = a[k].x, cy = a[k].y;
            bool found = false;
            for (int l = 1; l <= n; l++) {
                if (l == k) continue;
                if (cx + p == a[l].x && cy + q == a[l].y) {
                    found = true;
                    break;
                }
            }
            now += !found;
        }
        minn = min(minn, now);
    }
}
```

---

#### 题解2：Alvin0228（4星）
**核心思路**：  
1. 枚举基准点 $i$ 和参考点 $j$ 生成候选步长  
2. 初始假设每个球都需要独立操作（初始代价设为 $n$）  
3. 通过逆向验证减少实际需要的操作次数  

**实现技巧**：  
- 初始值优化避免漏算  
- 逆向验证减少冗余操作计数  
```cpp
int minn = n;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        int p = a[i][0] - a[j][0];
        int q = a[i][1] - a[j][1];
        if (p == 0 && q == 0) continue;
        int ans = 1;
        for (int k = 1; k <= n; k++) {
            if (k == i) continue;
            ans++;
            for (int l = 1; l <= n; l++) {
                if (l == k) continue;
                if (a[k][0] + p == a[l][0] && a[k][1] + q == a[l][1]) {
                    ans--;
                    break;
                }
            }
        }
        minn = min(minn, ans);
    }
}
```

---

### 关键思路总结
1. **步长生成**：通过两球坐标差生成候选 $(p,q)$，覆盖所有可能方向  
2. **链式验证**：对每个候选步长，验证球能否形成连续收集链  
3. **操作计数**：独立链的数量即为最小操作次数  

---

### 拓展建议
类似问题可考虑：  
1. **模式枚举**：当问题参数存在离散候选值时，穷举法常是可行解  
2. **路径覆盖**：将元素按特定规则分组，转化为覆盖问题  
3. **方向处理**：坐标差的正负处理需保持一致性  

---

### 推荐习题
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 枚举棋盘布局  
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036) - 组合枚举与质数判断  
3. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) - 全排列枚举实践

---
处理用时：217.55秒
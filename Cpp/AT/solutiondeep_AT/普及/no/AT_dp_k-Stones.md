# 题目信息

# Stones

## 题目描述

$N$ 个正整数组成的集合 $A = \{ a _ 1, a _ 2, \ldots, a _ N \}$。太郎君和次郎君将用以下游戏进行对决。

首先，准备一个有 $K$ 个石子的堆。两人依次进行以下操作。太郎君先手。

- 从集合 $A$ 中选择一个元素 $x$，从石堆中恰好移除 $x$ 个石子。

不能进行操作的人输掉游戏。当两人都按照最优策略行动时，判断谁会获胜。

## 样例 #1

### 输入

```
2 4

2 3```

### 输出

```
First```

## 样例 #2

### 输入

```
2 5

2 3```

### 输出

```
Second```

## 样例 #3

### 输入

```
2 7

2 3```

### 输出

```
First```

## 样例 #4

### 输入

```
3 20

1 2 3```

### 输出

```
Second```

## 样例 #5

### 输入

```
3 21

1 2 3```

### 输出

```
First```

## 样例 #6

### 输入

```
1 100000

1```

### 输出

```
Second```

# AI分析结果



# 题目重述
## 题目：石子游戏

### 题目描述
给定由 $N$ 个正整数组成的集合 $A = \{ a_1, a_2, \ldots, a_N \}$。太郎和次郎用以下规则进行游戏：

初始时有 $K$ 个石子的石堆。两人轮流操作（太郎先手），每次从集合 $A$ 中选择一个元素 $x$，移除恰好 $x$ 个石子。无法操作者输。当双方都采取最优策略时，判断谁会获胜。

### 样例
（样例内容与原文一致，此处省略）

---

## 算法分类
**动态规划**

---

## 题解综合分析

### 核心思路
所有题解均采用动态规划方法，定义状态 `dp[i]` 表示剩余 `i` 个石子时当前操作者的胜负状态。关键结论：
1. **必败态转移**：若存在某个 $a_j$ 使得 `dp[i - a_j]` 为必败态，则 `dp[i]` 为必胜态
2. **递推顺序**：从 `dp[0] = 0`（必败态）开始自底向上递推

### 解决难点
1. **最优策略模拟**：通过逆向推导，确保每个状态的选择都是最优决策
2. **复杂度控制**：通过遍历所有可能的取法（$O(nk)$ 复杂度）实现高效计算

---

## 精选题解（评分≥4星）

### 题解1：Bpds1110（4.5星）
**亮点**：
- 使用位运算优化状态转移（`|=` 操作）
- 代码简洁，逻辑清晰
- 包含越界判断优化

**核心代码**：
```cpp
int dp[N], a[N];
for (int i = 1; i <= k; i++) 
    for (int j = 1; j <= n; j++) 
        if(i - a[j] >= 0) 
            dp[i] |= (dp[i - a[j]] == 0);
```

### 题解2：Haphyxlos（4星）
**亮点**：
- 明确的定理式表述，便于理解
- 代码包含必要注释和边界处理
- 使用 `std::ios::sync_with_stdio(false)` 优化输入

**核心代码**：
```cpp
bool dp[maxn];
for(int i=1; i<=k; ++i) 
    for(int j=1; j<=n; ++j) 
        if(i >= a[j] && !dp[i - a[j]]) 
            dp[i] = true;
```

### 题解3：Phartial（4星）
**亮点**：
- 使用布尔数组直接表示胜负状态
- 包含定理推导过程，数学严谨
- 代码风格统一，可读性强

**核心代码**：
```cpp
bool f[kK] = {};
for(int i=1; i<=k; ++i)
    for(int j=1; j<=n; ++j)
        f[i] |= i >= a[j] && !f[i - a[j]];
```

---

## 关键技巧总结
1. **状态压缩**：使用布尔值表示胜负状态，节省空间
2. **短路优化**：发现必胜路径后立即终止内层循环（如 `break`）
3. **逆向思维**：通过分析对手的必败态推导当前必胜态

---

## 拓展思考
1. **变种问题**：若允许重复取石子或添加特殊限制（如每次取后必须余下质数）
2. **记忆化搜索**：当 `k` 极大时可考虑记忆化搜索剪枝
3. **SG函数**：可引入博弈论中SG函数概念解决更复杂的博弈问题

---

## 推荐习题
1. [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)  
   （Nim游戏基础变式）
2. [P2197 【模板】nim 游戏](https://www.luogu.com.cn/problem/P2197)  
   （SG函数模板题）
3. [P2964 [USACO09NOV]A Coin Game S](https://www.luogu.com.cn/problem/P2964)  
   （博弈+动态规划综合应用）

---
处理用时：53.32秒
# 题目信息

# Deque

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_l

太郎君と次郎君が次のゲームで勝負します。

最初に、数列 $ a\ =\ (a_1,\ a_2,\ \ldots,\ a_N) $ が与えられます。 $ a $ が空になるまで、二人は次の操作を交互に行います。 先手は太郎君です。

- $ a $ の先頭要素または末尾要素を取り除く。 取り除いた要素を $ x $ とすると、操作を行った人は $ x $ 点を得る。

ゲーム終了時の太郎君の総得点を $ X $、次郎君の総得点を $ Y $ とします。 太郎君は $ X\ -\ Y $ を最大化しようとし、次郎君は $ X\ -\ Y $ を最小化しようとします。

二人が最適に行動すると仮定したとき、$ X\ -\ Y $ を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 3000 $
- $ 1\ \leq\ a_i\ \leq\ 10^9 $

### Sample Explanation 1

二人が最適に行動すると、次のように操作が行われます。 操作対象の要素を太字で表しています。 - 先手: (10, 80, 90, \*\*30\*\*) → (10, 80, 90) - 後手: (10, 80, \*\*90\*\*) → (10, 80) - 先手: (10, \*\*80\*\*) → (10) - 後手: (\*\*10\*\*) → () このとき、$ X\ =\ 30\ +\ 80\ =\ 110 $, $ Y\ =\ 90\ +\ 10\ =\ 100 $ となります。

### Sample Explanation 2

二人が最適に行動すると、例えば次のように操作が行われます。 - 先手: (\*\*10\*\*, 100, 10) → (100, 10) - 後手: (\*\*100\*\*, 10) → (10) - 先手: (\*\*10\*\*) → () このとき、$ X\ =\ 10\ +\ 10\ =\ 20 $, $ Y\ =\ 100 $ となります。

### Sample Explanation 4

答えは 32-bit 整数型に収まらない場合があります。

### Sample Explanation 5

二人が最適に行動すると、例えば次のように操作が行われます。 - 先手: (4, 2, 9, 7, 1, \*\*5\*\*) → (4, 2, 9, 7, 1) - 後手: (\*\*4\*\*, 2, 9, 7, 1) → (2, 9, 7, 1) - 先手: (2, 9, 7, \*\*1\*\*) → (2, 9, 7) - 後手: (2, 9, \*\*7\*\*) → (2, 9) - 先手: (2, \*\*9\*\*) → (2) - 後手: (\*\*2\*\*) → () このとき、$ X\ =\ 5\ +\ 1\ +\ 9\ =\ 15 $, $ Y\ =\ 4\ +\ 7\ +\ 2\ =\ 13 $ となります。

## 样例 #1

### 输入

```
4

10 80 90 30```

### 输出

```
10```

## 样例 #2

### 输入

```
3

10 100 10```

### 输出

```
-80```

## 样例 #3

### 输入

```
1

10```

### 输出

```
10```

## 样例 #4

### 输入

```
10

1000000000 1 1000000000 1 1000000000 1 1000000000 1 1000000000 1```

### 输出

```
4999999995```

## 样例 #5

### 输入

```
6

4 2 9 7 1 5```

### 输出

```
2```

# AI分析结果



# Deque

## 题目描述

太郎君和次郎君进行如下游戏对决。

最初给定一个数列 $a = (a_1, a_2, \ldots, a_N)$。两人轮流执行以下操作直到 $a$ 为空，先手为太郎君：

- 移除 $a$ 的首元素或尾元素，操作者获得等同于被移除元素值的分数。

设游戏结束时太郎君总得分为 $X$，次郎君为 $Y$。太郎君希望最大化 $X-Y$，次郎君希望最小化 $X-Y$。求两人都采取最优策略时的最终差值。

## 算法分类
动态规划

---

## 题解综合分析

各题解核心均为动态规划，差异主要体现在状态转移方程的设计：

1. **主流思路**：定义 $dp[l][r]$ 表示区间 $[l,r]$ 剩余时当前玩家的最大优势差
2. **状态转移**：根据剩余数字个数的奇偶性判断当前玩家身份（先手/后手）
3. **优化方向**：通过前缀和优化区间和计算，部分题解尝试贪心策略但适用性有限

### 精选题解

#### 1. mcyqwq（★★★★☆）
**关键亮点**：
- 直接通过剩余数字个数的奇偶性控制状态转移
- 清晰的状态定义：`f[i][j]` 表示区间 `[i,j]` 时的最优差值
- 简洁的转移方程：
  ```cpp
  if((n - len) & 1) // 后手操作
    f[i][j] = min(f[i+1][j]-a[i], f[i][j-1]-a[j]);
  else // 先手操作
    f[i][j] = max(f[i+1][j]+a[i], f[i][j-1]+a[j]);
  ```

#### 2. chenpengjin（★★★★☆）
**创新点**：
- 使用减法统一转移方程：`dp[i][j] = max(a[i]-dp[i+1][j], a[j]-dp[i][j-1])`
- 直观体现博弈的零和特性，无需区分玩家身份

#### 3. syzxzqy（★★★★☆）
**实现技巧**：
- 通过记忆化搜索实现递归式DP
- 利用`(n-r+l-1) & 1`判断当前操作者身份

---

## 核心算法实现
以mcyqwq解法为例的DP实现：
```cpp
ll a[N], f[N][N];
for(int len=1; len<=n; len++) {
    for(int i=1; i+len-1<=n; i++) {
        int j = i+len-1;
        if((n-len) & 1)
            f[i][j] = min(f[i+1][j]-a[i], f[i][j-1]-a[j]);
        else 
            f[i][j] = max(f[i+1][j]+a[i], f[i][j-1]+a[j]);
    }
}
```

---

## 扩展与心得

### 关键技巧
- **区间DP的循环顺序**：按区间长度从小到大处理
- **博弈问题转换**：将对手收益转化为己方负收益
- **状态压缩**：可优化为滚动数组降低空间复杂度（但本题n=3000无需优化）

### 类似题目
1. [P2734 游戏 A Game](https://www.luogu.com.cn/problem/P2734)（区间DP）
2. [AT3859 GCDロボット](https://www.luogu.com.cn/problem/AT3859)（博弈+数论）
3. [P1430 序列取数](https://www.luogu.com.cn/problem/P1430)（区间DP变形）

---

## 作者心得摘录

> "考虑将对手收益转化为负收益的思路非常关键，这避免了复杂的玩家身份判断" —— chenpengjin

> "区间DP的循环顺序必须按长度从小到大，否则无法保证子问题已解" —— _JF_

> "调试时发现转移方向错误，必须明确每个状态对应的是哪个玩家操作" —— kdy20100729

---
处理用时：43.27秒
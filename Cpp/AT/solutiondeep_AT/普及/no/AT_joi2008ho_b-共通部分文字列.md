# 题目信息

# 共通部分文字列

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2008ho/tasks/joi2008ho_b

# AI分析结果



# 共通部分文字列

## 题目描述  
给出两行两个字符串，长度不超过4000，求两个字符串最长的相同子串长度（要求连续）。

---

**算法分类**  
动态规划

---

### 题解综合分析  
所有题解均采用动态规划思路，核心思想为：  
- 定义 `dp[i][j]` 表示以字符串 `a[i]` 和 `b[j]` 结尾的最长公共子串长度  
- 状态转移：若 `a[i] == b[j]` 则 `dp[i][j] = dp[i-1][j-1] + 1`，否则为 `0`  
- 关键优化：  
  1. 字符串前补空格避免越界  
  2. 使用 `unsigned short` 类型节省空间  

---

### 高分题解精选  

#### 1. Elma_ (⭐⭐⭐⭐⭐)  
**亮点**  
- 代码简洁清晰，直接体现动态规划核心思想  
- 处理边界条件的技巧（字符串前补空格）  
**核心代码**  
```cpp
a = " " + a, b = " " + b;
for (int i = 1; i < a.size(); i++)
    for (int j = 1; j < b.size(); j++)
        if (a[i] == b[j]) {
            dp[i][j] = dp[i-1][j-1] + 1;
            ans = max(ans, dp[i][j]);
        }
```

#### 2. TRZ_2007 (⭐⭐⭐⭐)  
**亮点**  
- 明确空间优化思路，使用 `unsigned short` 类型  
- 解释数据类型选择依据（`n < 65535`）  
**核心代码**  
```cpp
a = "#" + a; b = "#" + b;
for(int i = 1; i < a.size(); i++)
    for(int j = 1; j < b.size(); j++)
        if(a[i] == b[j]) 
            f[i][j] = f[i-1][j-1] + 1;
```

#### 3. 封禁用户 (⭐⭐⭐)  
**亮点**  
- 详细阐述动态规划原理与复杂度优化对比  
- 强调边界处理的重要性  
**关键心得**  
> "在字符串前加空格避免越界，是处理递推类问题的常用技巧"

---

### 最优思路总结  
**关键技巧**  
- **补空字符防越界**：在字符串首添加虚拟字符（如空格），使下标从 `1` 开始  
- **空间压缩**：使用 `unsigned short` 类型存储 DP 数组（最大长度 4000 < 65535）  
- **滚动数组优化**：可进一步将空间优化为一维数组（但本题数据规模下非必须）  

---

### 拓展应用  
适用于所有最长公共子串问题，如：  
1. 带权值的最长子串（如字符匹配得分不同）  
2. 多字符串公共子串（需扩展为三维 DP）  

---

### 推荐习题  
1. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)（非连续子序列）  
2. [P3375 KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)（预处理加速匹配）  
3. [P4051 后缀数组](https://www.luogu.com.cn/problem/P4051)（后缀数组求多字符串 LCP）

---
处理用时：46.86秒
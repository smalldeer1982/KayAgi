# 题目信息

# オレンジの出荷 (Oranges)

## 题目描述

CXR决定将收获的$n$个橙子分装进一些箱子内。在NXY的工厂中，橙子排列在输送带上，依次编号为$1...n$。橙子$i(1\leq i\leq n$)的大小为$A_i$。由于分拣不方便，同一个箱子内，橙子的编号必须连续。



一个箱子内最多可以装$m$个橙子。在一个箱子内装一些橙子的成本为$k+s\times (a-b)$。$k$是箱子本身的成本，所有箱子的成本一样。$s$是该箱子中橙子的数目。 $a$是该箱子中最大橙子的大小，$b$是该箱子中最小橙子的大小。



求包装这$n$个橙子所需的最小成本。

## 说明/提示

- 1≤N≤20 000

- 1≤M≤1 000

- 0≤K≤1 000 000 000

- 1≤A_i≤1 000 000 000 (1≤i≤N)

- M≤N



本题：JOI 2016 Final T1「オレンジの出荷」

## 样例 #1

### 输入

```
6 3 6
1
2
3
1
2
1```

### 输出

```
21```

## 样例 #2

### 输入

```
16 4 12
3
10
13
10
19
9
12
16
11
2
19
9
13
2
13
19```

### 输出

```
164```

## 样例 #3

### 输入

```
16 6 14
19
7
2
15
17
7
14
12
3
14
5
10
17
20
19
12```

### 输出

```
177```

## 样例 #4

### 输入

```
10 1 1000000000
1
1
1
1
1
1
1
1
1
1```

### 输出

```
10000000000```

# AI分析结果



【题目翻译】
# 橙子的出货 (Oranges)

## 题目描述

CXR决定将收获的$n$个橙子分装进一些箱子。在NXY的工厂中，橙子排列在传送带上，依次编号为$1...n$。橙子$i(1\leq i\leq n)$的大小为$A_i$。由于分拣不便，同一个箱子内的橙子编号必须连续。

每个箱子最多可装$m$个橙子。装箱成本为$k + s \times (a - b)$，其中：$k$是固定成本，$s$是箱中橙子数量，$a$和$b$分别是箱中最大和最小橙子大小。

求包装所有橙子的最小总成本。

## 样例与数据范围
（保持原样不变）

---

**算法分类**：动态规划

---

### 题解综合分析

所有题解均采用动态规划思路，核心状态定义为$f[i]$表示前$i$个橙子的最小成本。转移时枚举最近$m$个可能的装箱区间，实时维护区间最大值和最小值计算成本。时间复杂度为$O(nm)$，在给定数据范围下可行。

---

### 精选题解与评分

1. **神秘番茄厂长（★★★★☆）**  
   **亮点**：  
   - 清晰的变量命名与初始化（如`un=max(0,i-m)`显式控制左边界）  
   - 倒序遍历维护极值，避免重复计算  
   **代码核心**：
   ```cpp
   for(int i=1;i<=n;++i) {
       int un=max(0,i-m);
       int maxn=-1, minn=1e9+10;
       for(int j=i; j>un; --j) { // 倒序遍历维护极值
           maxn = max(maxn, A[j]);
           minn = min(minn, A[j]);
           f[i] = min(f[i], f[j-1] + K + (i-j+1LL)*(maxn - minn));
       }
   }
   ```

2. **微香玉烛暗（★★★★☆）**  
   **亮点**：  
   - 显式处理数据溢出（使用`1e18`初始化）  
   - 条件`i-j < m`保证区间长度限制  
   **调试心得**：  
   > "内层循环要同时维护最大最小值，否则无法正确计算区间成本"  
   **代码核心**：
   ```cpp
   for(int i=1; i<=n; i++) {
       f[i] = 1e18;
       int x = -1e18, y = 1e18;
       for(int j=i; i-j<m && j>0; j--) {
           x = max(x, a[j]);
           y = min(y, a[j]);
           f[i] = min(f[i], f[j-1] + k + (i-j+1)*(x-y));
       }
   }
   ```

---

### 关键思路总结

1. **状态设计**：$f[i]$表示前$i$个橙子的最小成本，通过枚举最后一个箱子的起始点进行转移。
2. **极值维护**：在转移过程中动态计算区间$[j,i]$的最大最小值，避免预处理所有区间，节省空间。
3. **复杂度控制**：通过限制转移范围为$[i-m, i]$，将时间复杂度控制在$O(nm)$。

---

### 拓展建议

类似需要维护区间极值的动态规划问题：
1. **滑动窗口极值优化**：如[P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
2. **环形区间处理**：如[P6065 [USACO05JAN] Sumsets S](https://www.luogu.com.cn/problem/P6065)  
3. **带限制的区间划分**：如[P1279 字串距离](https://www.luogu.com.cn/problem/P1279)

---
处理用时：50.25秒
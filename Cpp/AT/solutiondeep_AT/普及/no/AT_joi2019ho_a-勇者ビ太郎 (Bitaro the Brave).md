# 题目信息

# 勇者ビ太郎 (Bitaro the Brave)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2019ho/tasks/joi2019ho_a

![2019-ho-t1-fig01.jpg](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_joi2019ho_a/09009490d7383ad8a773f434baef49f70d623222.png)

勇者のビ太郎は，魔王と対峙することとなった．

ビ太郎は，縦 $ H $ 行，横 $ W $ 列のマス目上に宝石 (Jewel)，オーブ (Orb)，金塊 (Ingot) を配置し，魔法を発動することによって魔王に攻撃をしようとしている．以下，マス目のうち上から $ i $ 行目 ($ 1\ \leqq\ i\ \leqq\ H $)，左から $ j $ 列目 ($ 1\ \leqq\ j\ \leqq\ W $) のマスを，マス $ (i,\ j) $ と表す．

ビ太郎は今，それぞれのマスにこれら $ 3 $ 種類のうち $ 1 $ 個を配置した．今から魔法を発動しようとしているが，この魔法の威力はマス目上の宝石，オーブ，金塊の配置によって決まる．具体的には，次の条件を満たす整数 $ (i,\ j,\ k,\ l) $ ($ 1\ \leqq\ i\ <\ k\ \leqq\ H $，$ 1\ \leqq\ j\ <\ l\ \leqq\ W $) の組の個数が，魔法の威力である．

条件：マス $ (i,\ j) $ には宝石が，マス $ (i,\ l) $ にはオーブが，マス $ (k,\ j) $ には金塊が置かれている．

ビ太郎は，この魔法の威力が気になっている．

マス目上の宝石，オーブ，金塊の配置が与えられたとき，ビ太郎が発動する魔法の威力を求めるプログラムを作成せよ．

- - - - - -

## 说明/提示

### 制約

- $ 2\ \leqq\ H\ \leqq\ 3\,000 $．
- $ 2\ \leqq\ W\ \leqq\ 3\,000 $．
- $ S_i $ は長さ $ W $ の文字列である ($ 1\ \leqq\ i\ \leqq\ H $)．
- $ S_i $ の各文字は `J`，`O`，`I` のいずれかである ($ 1\ \leqq\ i\ \leqq\ H $)．

### 小課題

1. ($ 20 $ 点) $ H\ \leqq\ 100 $，$ W\ \leqq\ 100 $．
2. ($ 30 $ 点) $ H\ \leqq\ 500 $，$ W\ \leqq\ 500 $．
3. ($ 50 $ 点) 追加の制約はない．

- - - - - -

### Sample Explanation 1

この入力例では，$ (i,\ j,\ k,\ l)\ =\ (1,\ 1,\ 3,\ 2),\ (2,\ 1,\ 3,\ 3),\ (2,\ 1,\ 3,\ 4) $ の $ 3 $ 個の組が条件を満たすので，答えは $ 3 $ である． - - - - - -

## 样例 #1

### 输入

```
3 4
JOIJ
JIOO
IIII```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4
JJOO
JJOO
IIJO
IIIJ```

### 输出

```
17```

# AI分析结果



**题目中文重写**

### 题目描述

勇者ビ太郎需要在一个 $H \times W$ 的网格中计算魔法威力。网格由 `J`（宝石）、`O`（オーブ）、`I`（金塊）组成。魔法威力定义为满足以下条件的四元组 $(i, j, k, l)$ 的数量：

- 条件：$(i,j)$ 为 `J`，$(i,l)$（同一行右侧）为 `O`，$(k,j)$（同一列下方）为 `I`，且满足 $i<k$、$j<l$。

### 输入格式
- 输入 $H$ 和 $W$，表示网格的行数和列数。
- 接下来 $H$ 行，每行为一个长度为 $W$ 的字符串，表示网格内容。

### 输出格式
- 输出符合条件的四元组个数。

---

**算法分类**  
前缀和/后缀和

---

### 题解综合分析

所有题解均采用**前缀和/后缀和优化**，核心思路为：  
1. **预处理行和列的后缀和**：对于每个 `J`，快速计算其右侧 `O` 的数量和下方 `I` 的数量。  
2. **乘法原理**：每个 `J` 的贡献值为（右侧 `O` 的数量 × 下方 `I` 的数量），最终累加所有 `J` 的贡献。  

**关键优化点**：  
- 暴力枚举四元组的时间复杂度为 $O(H^2W^2)$，无法通过。  
- 预处理行和列的后缀和可将时间复杂度降至 $O(HW)$，满足题目约束（$H,W \leq 3000$）。  

---

### 精选题解与评分

#### 1. 作者：donnieguo（5星）
**关键亮点**  
- **思路清晰**：通过图示明确贡献计算方式，直接关联前缀和与乘法原理。  
- **代码简洁**：使用二维前缀和数组 `s1`（行方向 `O` 的数量）和 `s2`（列方向 `I` 的数量）。  
- **实现细节**：在输入时直接计算前缀和，避免额外遍历。

**核心代码**  
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        // 输入时计算前缀和
        s1[i][j] = s1[i][j - 1] + (a[i][j] == 'O' ? 1 : 0);
        s2[i][j] = s2[i - 1][j] + (a[i][j] == 'I' ? 1 : 0);
    }
// 枚举每个 J，累加贡献
if (a[i][j] == 'J')
    ans += 1ll * (s1[i][m] - s1[i][j]) * (s2[n][j] - s2[i][j]);
```

---

#### 2. 作者：SnowFlavour（4.5星）
**关键亮点**  
- **后缀和实现**：从后向前遍历计算 `O` 和 `I` 的后缀和，代码逻辑直观。  
- **坐标处理**：明确说明坐标从 $0$ 开始，避免索引混淆。  
- **个人心得**：强调避免超时的优化思路（“重复计算导致超时，需后缀和”）。

**核心代码**  
```cpp
// 计算每行的 O 后缀和
for (int i = 0; i < n; i++) {
    int status = 0;
    for (int j = m - 1; j >= 0; j--) {
        if (mp[i][j] == 1) status++;
        cnt_o[i][j] = status;
    }
}
// 计算每列的 I 后缀和
for (int i = 0; i < m; i++) {
    int status = 0;
    for (int j = n - 1; j >= 0; j--) {
        if (mp[j][i] == 2) status++;
        cnt_i[i][j] = status;
    }
}
```

---

### 最优思路总结
- **预处理技巧**：通过行和列的后缀和（或前缀和）快速统计区域内的目标字符数量。  
- **乘法原理应用**：将四元组数量转换为每个 `J` 的独立贡献，避免嵌套枚举。  
- **空间优化**：利用二维数组直接存储行和列的统计信息，无需额外数据结构。

---

### 拓展与类似题目
- **同类问题**：涉及二维区域统计的问题，如统计子矩阵中特定元素的数量。  
- **推荐题目**：  
  1. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)（二维前缀和）  
  2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（差分+前缀和）  
  3. [P3662 [USACO17FEB]Why Did the Cow Cross the Road II S](https://www.luogu.com.cn/problem/P3662)（滑动窗口+前缀和）

---
处理用时：47.41秒
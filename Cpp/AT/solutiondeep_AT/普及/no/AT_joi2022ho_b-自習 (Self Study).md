# 题目信息

# 自習 (Self Study)

## 题目描述

在 JOI 高中高一的第三个学期的 $M$ 个星期的时间内，有 $N$ 门课，编号为 $1 \sim N$。每个星期有 $N$ 个课时，第 $i$ 个课时上课程 $i$ 的一节课。

比太郎是一位高一学生。对于 $N \times M$ 个课时中的每一个，他会选择如下行动中的一个：

- 行动 1：比太郎去上课。如果他去上了课程 $i$ 的一节课，那么他对课程 $i$ 的理解程度会增加 $A_i$。
- 行动 2：比太郎不去上课。他转而选择任意一门课，并且自学选中的那门课。如果他选中了课程 $i$ 进行了时长为一课时的自学，那么他对课程 $i$ 的理解程度会增加 $B_i$。

一开始，对每门课的理解程度都为 $0$。由于比太郎想要在课后练习算法竞赛，他在非上课时间内不会学习。当第三个学期的所有课时结束后，期末考就会举行。

比太郎不想挂科。所以他想要最大化在期末考时对每门课的理解程度的最小值。

给定学期的长度，课程的数量，以及对理解程度的提升数值，请写一个程序计算在期末考时对每门课的理解程度的最小值的最大可能值。

## 说明/提示

**【样例解释 \#1】**

举个例子，如果比太郎按如下方式学习，则他对课程 $1, 2, 3$ 的理解程度将分别为 $19, 18, 19$。

- 第一周课程 $1$ 的课：自学课程 $2$；
- 第一周课程 $2$ 的课：自学课程 $2$；
- 第一周课程 $3$ 的课：去上课程 $3$ 的课；
- 第二周课程 $1$ 的课：去上课程 $1$ 的课；
- 第二周课程 $2$ 的课：自学课程 $3$；
- 第二周课程 $3$ 的课：去上课程 $3$ 的课；
- 第三周课程 $1$ 的课：自学课程 $3$；
- 第三周课程 $2$ 的课：自学课程 $2$；
- 第三周课程 $3$ 的课：去上课程 $3$ 的课。

由于对每门课的最小的理解程度不能大于等于 $19$，输出 $18$。

这个样例满足子任务 $3, 5$ 的限制。

**【样例解释 \#2】**

这个样例满足子任务 $1, 3, 5$ 的限制。

**【样例解释 \#3】**

这个样例满足子任务 $3, 5$ 的限制。

**【样例解释 \#4】**

这个样例满足子任务 $2, 3, 4, 5$ 的限制。

----


**本题采用捆绑测试。**

对于 $100 \%$ 的数据，$1 \le N \le 3 \times {10}^5$，$1 \le M \le {10}^9$，$1 \le A_i, B_i \le {10}^9$。

- 子任务 $1$（$10$ 分）：$M = 1$。
- 子任务 $2$（$25$ 分）：$N \cdot M \le 3 \times {10}^5$，$A_i = B_i$。
- 子任务 $3$（$27$ 分）：$N \cdot M \le 3 \times {10}^5$。
- 子任务 $4$（$29$ 分）：$A_i = B_i$。
- 子任务 $5$（$9$ 分）：无特殊限制。

----

**译自 [JOI 2022 Final](https://www.ioi-jp.org/joi/2021/2022-ho/index.html) T2「[自習](https://www.ioi-jp.org/joi/2021/2022-ho/2022-ho-t2.pdf) / [Self Study](https://www.ioi-jp.org/joi/2021/2022-ho/2022-ho-t2-en.pdf)」**

## 样例 #1

### 输入

```
3 3
19 4 5
2 6 2```

### 输出

```
18```

## 样例 #2

### 输入

```
2 1
9 7
2 6```

### 输出

```
7```

## 样例 #3

### 输入

```
5 60000
630510219 369411957 874325200 990002527 567203997
438920902 634940661 593780254 315929832 420627496```

### 输出

```
41397427274960```

## 样例 #4

### 输入

```
4 25
1 2 3 4
1 2 3 4```

### 输出

```
48```

# AI分析结果



### 中文题目重写
**自習 (Self Study)**

#### 题目描述  
在 JOI 高中高一的第三个学期的 $M$ 个星期内，共有 $N$ 门课程。每个星期有 $N$ 个课时，第 $i$ 个课时对应课程 $i$。比太郎每课时可选择两种行动：  
- **行动 1**：上课，使课程 $i$ 的理解度增加 $A_i$。  
- **行动 2**：自学任意课程 $j$，使课程 $j$ 的理解度增加 $B_j$。  

初始时，所有课程的理解度为 $0$。求学期结束后所有课程理解度的最小值的最大可能值。

#### 输入格式  
输入包含三部分：  
- 第一行：$N$（课程数）和 $M$（周数）。  
- 第二行：$N$ 个整数 $A_1, A_2, \dots, A_N$（上课的增益）。  
- 第三行：$N$ 个整数 $B_1, B_2, \dots, B_N$（自学的增益）。  

#### 输出格式  
输出理解度的最小值的最大可能值。

---

### 算法分类  
**二分答案 + 贪心**

---

### 题解分析与结论  
#### 核心思路  
1. **二分答案**：确定最小的理解度最大值 $X$，验证是否可达。  
2. **贪心策略**：  
   - 每课时优先选择更高效的方式（上课或自学该课）获得最大增益。  
   - 统计各课程在最优选择下达到 $X$ 所需的课时，并计算剩余可调配的课时。  
   - 验证总剩余课时是否满足所有课程的额外需求。  

#### 关键技巧  
- **最优选择预处理**：对每门课 $i$，其最优增益为 $C_i = \max(A_i, B_i)$。  
- **剩余课时计算**：若某课程通过最优选择已达标，省下的课时可被其他课程的自学需求使用。  
- **大数处理**：使用 `unsigned long long` 或 `__int128` 避免溢出。

---

### 精选题解  
#### 题解 1（作者：ny_jerry2，⭐⭐⭐⭐⭐）  
**亮点**：  
- 预处理最优增益，分别计算剩余课时与额外需求。  
- 通过两次遍历分别统计剩余课时和扣除需求，逻辑清晰。  
**核心代码**：  
```cpp
bool check(long long mid) {
    long long res = 0;
    for (int i = 1; i <= n; i++) {
        res += max(0LL, m - (mid + c[i] - 1) / c[i]);
    }
    for (int i = 1; i <= n; i++) {
        long long cha = mid - m * c[i];
        if (cha > 0) res -= (cha + b[i] - 1) / b[i];
        if (res < 0) return false;
    }
    return true;
}
```

#### 题解 2（作者：ny_Dacong，⭐⭐⭐⭐⭐）  
**亮点**：  
- 使用 `__int128` 处理极大数，避免溢出问题。  
- 直接计算剩余课时与需求差值，简洁高效。  
**核心代码**：  
```cpp
bool check(__int128 x) {
    __int128 rest = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] >= b[i]) {
            __int128 need = (x + a[i] - 1) / a[i];
            if (m >= need) rest += m - need;
            else rest -= (x - m * a[i] + b[i] - 1) / b[i];
        } else {
            __int128 need = (x + b[i] - 1) / b[i];
            if (m >= need) rest += m - need;
            else rest -= (x - m * b[i] + b[i] - 1) / b[i];
        }
    }
    return rest >= 0;
}
```

---

### 总结与拓展  
#### 关键思路  
- **二分框架**：解决最值的最值问题。  
- **贪心剪枝**：通过局部最优选择减少全局计算量。  
- **类型优化**：大数处理需谨慎选择数据类型。  

#### 类似题目  
1. **[P4344 [SHOI2015] 脑洞治疗仪](https://www.luogu.com.cn/problem/P4344)**  
2. **[P2115 [USACO14MAR] Sabotage G](https://www.luogu.com.cn/problem/P2115)**  
3. **[P4058 [Code+#1] 木材](https://www.luogu.com.cn/problem/P4058)**  

#### 调试心得  
- **边界处理**：注意向上取整的写法 `(x + y - 1) / y`。  
- **溢出风险**：在计算 `m * A[i]` 时需用足够大的数据类型。

---
处理用时：248.20秒
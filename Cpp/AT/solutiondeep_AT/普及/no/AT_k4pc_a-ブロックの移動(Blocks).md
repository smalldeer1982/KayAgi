# 题目信息

# ブロックの移動(Blocks)

## 题目描述

给出长度为 $n$ 的序列 $a$，每次操作可以任选 $i, j$ 让 $a_i = a_i - 1, a_j = a_j + 1$，求使整个序列满足 $a_i = i$ 所需要的最少操作步数。题目满足一定有解。

## 说明/提示

$1 \le n \le 100$。

## 样例 #1

### 输入

```
3

3

2

1```

### 输出

```
2```

## 样例 #2

### 输入

```
4

3

1

5

1```

### 输出

```
4```

## 样例 #3

### 输入

```
5

7

8

0

0

0```

### 输出

```
12```

# AI分析结果



【中文题目重写】

# 方块移动 (Blocks)

## 题目描述

给定长度为 $n$ 的序列 $a$，每次操作可以任选两个位置 $i, j$，使得 $a_i = a_i - 1$，$a_j = a_j + 1$。求使整个序列满足 $a_i = i$ 所需要的最少操作步数。题目保证一定有解。

## 说明/提示

$1 \le n \le 100$

## 样例 #1

### 输入
```
3
3
2
1
```

### 输出
```
2```

## 样例 #2

### 输入
```
4
3
1
5
1
```

### 输出
```
4```

## 样例 #3

### 输入
```
5
7
8
0
0
0
```

### 输出
```
12```

---

**算法分类**：数学

---

**题解分析与结论**

所有题解的核心思路均基于数学观察：每次操作可以同时修正两个位置的差值。设所有位置差值绝对值的总和为 $sum$，则最少操作次数为 $sum/2$。关键证明点：

1. 每次操作会减少两个单位的差值（一个位置多出1，另一个缺少1）
2. 题目保证初始总和等于目标总和（$\sum a_i = \sum i$），确保差值的正负部分绝对值相等

---

**精选题解**

1. **lzqy_（★★★★★）**  
   关键亮点：清晰阐释差值传递机制，代码简洁高效  
   核心代码：
   ```cpp
   int sum = 0;
   for (int i = 1; i <= n; i++) {
       cin >> a[i];
       sum += abs(a[i] - i);
   }
   cout << sum / 2 << endl;
   ```

2. **Trump__Biden（★★★★）**  
   关键亮点：通过构造目标数组直观展示差值计算  
   核心代码：
   ```cpp
   for (int i = 1; i <= n; i++)
       ans += abs(a[i] - i);
   printf("%d\n", ans/2);
   ```

3. **CQ_Bab（★★★★）**  
   关键亮点：通过正负差值统计验证数学性质，代码简洁  
   核心代码：
   ```cpp
   if (a[i] < i) res += i - a[i];
   else ans += a[i] - i;
   cout << max(ans, res) << endl; // 实际等效于 sum/2
   ```

---

**最优技巧总结**

1. **数学建模**：将操作转化为差值传递问题，利用绝对值和计算总操作量  
2. **隐含性质**：$\sum (a_i - i) = 0$ 保证正负差值绝对值相等  
3. **代码优化**：直接遍历计算绝对差值，避免复杂模拟

---

**同类题目推荐**

1. P1969 [积木大赛] - 差值传递思想  
2. P1031 [均分纸牌] - 最小移动次数问题  
3. P7015 [糖果传递] - 环形差值分配问题

---

**题解心得摘录**

- "每次操作改变两堆的数量，总差值除以二即为答案"（lzqy_）  
- "注意题目保证有解，无需考虑奇偶校验"（nbtngnllmd）  
- "直接取绝对值和避免分类讨论"（user470883）  

调试经验：必须从1开始循环以确保索引对齐，输入数据保证总和正确性。

---
处理用时：96.30秒
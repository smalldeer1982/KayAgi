# 题目信息

# ナップサック問題

## 题目描述

[problemUrl]: https://atcoder.jp/contests/kupc2019/tasks/kupc2019_b

$ n $ 個の品物があり、$ 1 $ から $ n $ までの番号が付けられています。

各品物には価値と重さが定められていて、$ i $ 番目の品物の価値は $ v_i $、重さは $ w_i $ です。

あなたはこれらの品物から重さの総和が $ W $ を超えないようにいくつか選び、選んだ品物の価値の総和を最大化したいです。

ただし、$ m $ 個の条件があります。

$ j $ 番目の条件は $ (a_j,\ b_j) $ で表され、それぞれ「 $ a_j $ 番目の品物を選ぶならば $ b_j $ 番目の品物を選ばなければならず、$ b_j $ 番目の品物を選ぶならば $ a_j $ 番目の品物を選ばなければならない」 という意味です。

これらの条件を全て満たした上で、$ n $ 個の品物から重さの総和が $ W $ を超えないようにいくつか品物を選んだときの価値の総和の最大値を求めてください。

## 说明/提示

### 制約

- 入力中の値は全て整数である。
- $ 1\ \leq\ n\ \leq\ 100 $
- $ 0\ \leq\ m\ \leq\ \frac\ {n(n-1)}{2} $
- $ 1\ \leq\ W\ \leq\ 10^4 $
- $ 1\ \leq\ w_i\ \leq\ W $
- $ 1\ \leq\ v_i\ \leq\ 10^7 $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ n $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば、$ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ かつ $ (a_i,\ b_i)\ \neq\ (b_j,\ a_j) $

### Sample Explanation 1

$ 1 $ 番目の品物と $ 2 $ 番目の品物を選ぶことで価値の総和を $ 6 $ にすることができ、これが最適です。 条件から、$ 2 $ 番目の品物と $ 3 $ 番目の品物だけを選ぶことはできないことに注意してください。

### Sample Explanation 2

全ての品物を選ぶことができます。

### Sample Explanation 3

一つも品物を選ぶことができません。

## 样例 #1

### 输入

```
3 1 10

3 2

5 4

3 3

1 2```

### 输出

```
6```

## 样例 #2

### 输入

```
4 0 10

1 1

2 2

3 3

4 4```

### 输出

```
10```

## 样例 #3

### 输入

```
3 3 6

2 5

3 8

3 4

1 2

2 3

3 1```

### 输出

```
0```

## 样例 #4

### 输入

```
1 0 10000

10000 10000000```

### 输出

```
10000000```

# AI分析结果



# 背包问题（带条件）

## 题目描述

有 $n$ 个物品，编号从 $1$ 到 $n$。每个物品有价值 $v_i$ 和重量 $w_i$。需要从这些物品中选出若干件，满足以下条件：  
1. 总重量不超过 $W$  
2. 满足 $m$ 个约束条件 $(a_j, b_j)$，表示若选 $a_j$ 则必须选 $b_j$，且选 $b_j$ 则必须选 $a_j$  

求在满足所有约束的前提下，能获得的最大价值总和。

## 算法分类
并查集 + 动态规划

---

## 题解综合分析

### 核心思路对比
所有题解均采用 **并查集处理约束关系 + 01背包计算最大价值** 的框架：  
1. **并查集**：将存在双向约束的物品合并为等价类（每个类必须整体选/不选）
2. **背包预处理**：将等价类的总重量和总价值作为新物品
3. **01背包**：对新物品集合进行动态规划

### 难点与解决方案
1. **等价类合并**：  
   - 难点：需要确保每个等价类只计算一次  
   - 关键：在合并时将子节点数据累加到父节点，并清空子节点属性（如 `c[i]=d[i]=0`）

2. **背包空间优化**：  
   - 使用一维数组倒序遍历，避免状态覆盖

---

## 精选题解（评分≥4）

### 题解1：SnowFalling_2010（★★★★☆）
**亮点**：  
- 清晰的并查集路径压缩实现  
- 明确处理合并时的重复计算问题  
- 代码可读性强，注释清晰  

**关键代码**：
```cpp
for(int i=1; i<=n; i++) {
    if(find1(i)!=i) { // 非根节点
        c[fa[i]] += c[i]; // 累加到父节点
        d[fa[i]] += d[i];
        c[i] = d[i] = 0; // 清空子节点
    }
}
for(int i=1; i<=n; i++) { // 背包DP
    for(int j=W; j>=c[i]; j--)
        dp[j] = max(dp[j], dp[j-c[i]] + d[i]);
}
```

---

## 最优思路总结
**关键技巧**：  
1. **并查集合并策略**：  
   - 合并时将子节点的权值累加到父节点  
   - 通过标记根节点避免重复计算  
2. **背包优化技巧**：  
   - 一维数组 + 逆序枚举节省空间  
   - 合并后等价类视为独立物品处理  

**调试经验**：  
- 多题解提到合并时需判断是否为根节点，否则会导致父节点数据被多次累加  
- 需要初始化并查集父数组 `fa[i]=i`

---

## 拓展练习
1. [P1455 搭配购买](https://www.luogu.com.cn/problem/P1455)  
   （并查集+背包的经典模板题）  
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)  
   （树形依赖背包问题）  
3. [P5020 货币系统](https://www.luogu.com.cn/problem/P5020)  
   （集合覆盖问题与动态规划结合）

---
处理用时：43.92秒
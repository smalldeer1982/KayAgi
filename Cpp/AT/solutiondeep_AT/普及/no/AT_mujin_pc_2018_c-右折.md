# 题目信息

# 右折

## 题目描述

[problemUrl]: https://atcoder.jp/contests/mujin-pc-2018/tasks/mujin_pc_2018_c

$ N $ 行 $ M $ 列のマス目があります。上から $ i $ 行目、左から $ j $ 列目にあるマスを $ (i,j) $ で表します。 特に、左上のマスは $ (1,1) $ であり、右下のマスは $ (N,M) $ です。 マス目の状態は 二次元配列 $ s $ で表され、$ s_{ij} $ が `#` のときマス $ (i,j) $ には障害物があり、`.` のとき障害物がないことを表します。

高橋君は、このマス目のいずれかのマスに、上下左右いずれかの方向を向けたロボットを置きました。 ロボットは向いている方向に $ 1 $ マス以上まっすぐ進んだ後、向きを右に $ 90 $ 度変え、再びまっすぐに $ 1 $ マス以上進んで停止しました。 この過程でロボットが通ったマス(置かれたマスおよび停止したマスを含む)のいずれにも障害物はなく、またロボットがマス目の外に出ることはありませんでした。

ロボットが置かれたマスと停止したマスの順序対としてありうるものの個数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N,M\ \leq\ 2\times\ 10^3 $
- $ s_{ij} $ は `#` または `.` である

### Sample Explanation 1

$ ((1,1),(2,2)),((1,1),(3,2)),((1,2),(2,1)),((2,1),(1,2)),((2,1),(3,2)),((2,2),(1,1)),((2,3),(1,2)),((2,3),(1,1)),((3,2),(2,3)) $ の $ 9 $ 個が条件を満たします。

## 样例 #1

### 输入

```
3 3

..#

...

#.#```

### 输出

```
9```

## 样例 #2

### 输入

```
2 5

.#.#.

..#..```

### 输出

```
2```

## 样例 #3

### 输入

```
6 8

#......#

##....##

#.#..#.#

#..##..#

#......#

#......#```

### 输出

```
182```

# AI分析结果



# 右折

## 题目描述

$ N $ 行 $ M $ 列的网格，第 $ i $ 行第 $ j $ 列的格子用 $(i,j)$ 表示。网格状态由二维数组 $ s $ 表示，`#` 表示障碍物，`.` 表示可通行。机器人从某一格子出发，沿某一方向直行至少1格后右转90度，再直行至少1格停止。要求路径全部无障碍且不出界，求所有可能的起点-终点对数量。

## 算法分类
模拟

---

## 题解分析与结论

核心思路是将每个格子视为右转折点，预处理每个格子在行、列方向上可延伸的最大连续无障碍长度，通过相乘累加得到答案。时间复杂度 $ O(NM) $，满足题目规模。

### 精选题解

#### 题解1（banglee） ⭐⭐⭐⭐⭐
**亮点**：  
- 变量命名直观（w表示横向延伸长度，h表示纵向）
- 预处理逻辑清晰，分别处理行和列的连续段
- 代码简洁高效，使用两次预处理后直接相乘求和

**代码核心**：
```cpp
// 预处理横向延伸长度
for(int i=0;i<n;i++) {
    int t=0;
    for(int j=0;j<=m;j++) {
        if(a[i][j]!='.') {
            for(int k=t;k<j;k++) 
                w[i][k] = j - t - 1;
            t = j + 1;
        }
    }
}
// 预处理纵向延伸长度
for(int j=0;j<m;j++) {
    int t=0;
    for(int i=0;i<=n;i++) {
        if(a[i][j]!='.') {
            for(int k=t;k<i;k++)
                h[k][j] = i - t - 1;
            t = i + 1;
        }
    }
}
// 累加结果
long long ans = 0;
for(int i=0;i<n;i++)
    for(int j=0;j<m;j++)
        ans += w[i][j] * h[i][j];
```

#### 题解2（SuyctidohanQ） ⭐⭐⭐⭐
**亮点**：  
- 思路与题解1完全一致
- 处理行列的代码结构对称，逻辑清晰
- 使用long long避免溢出问题

---

## 关键思路
1. **连续段预处理**：对每行每列扫描，记录每个格子所在连续无障碍段的长度（减1）
2. **乘法原理**：每个格子作为转折点的贡献 = 横向可延伸长度 × 纵向可延伸长度
3. **方向独立性**：将二维问题分解为行、列两个一维预处理，降低复杂度

---

## 拓展练习
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 连通块预处理
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 差分统计技巧
3. [P2743 [USACO5.1] 矩形周长](https://www.luogu.com.cn/problem/P2743) - 行列独立处理

---
处理用时：122.57秒
# 题目信息

# Counting of Trees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_b

$ N $ 要素からなる整数列 $ D_1,...,D_N $ が与えられます。頂点に $ 1 $ から $ N $ の番号が付けられた $ N $ 頂点からなる木であって、 以下の条件をみたすものの個数を $ 998244353 $ で割ったあまりを求めてください。

- $ 1 $ 以上 $ N $ 以下の任意の整数 $ i $ に対して、頂点 $ 1 $ と頂点 $ i $ の距離が $ D_i $ である。

## 说明/提示

### 注記

- $ N $ 頂点の木とは $ N $ 頂点 $ N-1 $ 辺からなる連結無向グラフのことであり、$ 2 $ 頂点の距離とは一方から他方への最短路に用いられる辺の個数を指します。
- $ 2 $ つの木が異なるとは、ある $ 2 $ 頂点 $ x $, $ y $ が存在して、$ x $ と $ y $ の間に一方の木では辺が存在し、 もう一方の木では辺が存在しないことを指します。

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 0\ ≦\ D_i\ ≦\ N-1 $

### Sample Explanation 1

例えば、$ (1,2) $, $ (1,3) $, $ (2,4) $ の間に辺があるような木が条件をみたします。

## 样例 #1

### 输入

```
4

0 1 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4

1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
7

0 3 2 1 2 2 1```

### 输出

```
24```

# AI分析结果



# Counting of Trees

## 题目描述

给定一个包含 $N$ 个元素的整数序列 $D_1, D_2, ..., D_N$，求满足以下条件的树的数量（对 $998244353$ 取模）：

- 对于任意 $1 \leq i \leq N$，顶点 $1$ 和顶点 $i$ 的距离等于 $D_i$。

### 说明

- 树的定义：$N$ 顶点 $N-1$ 边的连通无向图
- 顶点距离：两顶点间最短路径的边数
- 两树不同判定：存在至少一对顶点，在一棵树中有边而另一棵树没有

### 约束

- $1 \leq N \leq 10^5$
- $0 \leq D_i \leq N-1$

---

**算法分类**：组合数学

---

## 题解对比与结论

### 关键思路

1. **合法性检查**：
   - 根节点必须满足 $D_1 = 0$，且深度为0的节点只能有1个
   - 深度序列必须连续（若存在深度为 $k$ 的节点，则必须有深度为 $k-1$ 的节点）

2. **组合计算**：
   - 统计每个深度的节点数 $cnt[d]$
   - 对于每个深度 $d$，其父节点只能来自深度 $d-1$，贡献为 $cnt[d-1]^{cnt[d]}$
   - 累乘所有深度的贡献，使用快速幂优化

### 精选题解

#### 题解1：Ryan_Adam（5星）
**亮点**：  
- 显式检查深度连续性，提前终止无效计算
- 使用快速幂模运算优化指数计算
- 代码结构清晰，包含完整异常处理

**关键代码**：
```cpp
for(int i=1;i<=n;i++) { // 深度连续性检查
    if (t[i] == 0 && t[i + 1] != 0) {
        cout<<0<<endl;
        return 0;
    }
}

int ans = 1;
for(int i=1;i<=n;i++) {
    if(t[i-1] != 0) {
        ans = ans * qpow(t[i-1], t[i], mod) % mod;
    }
}
```

#### 题解2：xiao_dong_xi（4星）
**亮点**：
- 简洁高效的快速幂实现
- 正确性验证逻辑完整
- 代码可读性高，适合快速理解算法核心

**核心实现**：
```cpp
long long fast_power(int a, int n, int p) {
    long long res = 1;
    while (n) {
        if (n & 1) res = res * a % p;
        a = (long long)a * a % p;
        n >>= 1;
    }
    return res;
}
```

#### 题解3：Nightsky_Stars（4星）
**亮点**：
- 包含深度连续性检查
- 使用更高效的循环条件
- 强调数据类型的正确选择

**代码片段**：
```cpp
for(ll i=1;i<=n;i++) {
    if(s[i]==0&&s[i+1]!=0) { // 提前终止
        cout<<"0\n";
        return 0;
    }
}
```

---

### 最优技巧总结

1. **桶计数优化**：用数组统计各深度节点数，复杂度 $O(N)$
2. **幂运算优化**：快速幂将指数计算复杂度降至 $O(\log N)$
3. **边界处理**：显式检查深度连续性，避免无效计算

---

### 拓展练习

1. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)  
   **相似点**：树结构性质与组合计算

2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)  
   **相似点**：树结构计数与动态规划结合

3. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)  
   **相似点**：树形DP与状态转移优化

---
处理用时：166.54秒
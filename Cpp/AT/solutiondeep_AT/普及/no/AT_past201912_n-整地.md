# 题目信息

# 整地

## 题目描述

坐标轴上有 $n$ 个区间，每个区间均在左端点为 $0$，右端点为 $w$ 的线段内。第 $i$ 个区间的左右端点表示的数字分别为 $l_i$ 和 $r_i$。

现在你要去掉一部分区间，使得有一段长度为 $c$ 的线段没有被任何区间覆盖。第 $i$ 个区间删去的代价为 $p_i$。请输出你所花费的最小代价。

## 样例 #1

### 输入

```
3 10 5

1 3 100

8 10 123

4 6 3```

### 输出

```
3```

## 样例 #2

### 输入

```
22 30 10

0 30 1000000000

0 30 1000000000

0 30 1000000000

7 30 261806

6 19 1

5 18 1238738

12 28 84

10 14 5093

9 20 9

15 26 8739840

6 8 240568

14 19 198

2 4 1102

1 29 5953283

9 20 183233

9 13 44580

6 23 787237159

12 14 49

28 29 9020727

14 20 318783

2 19 9862194

9 30 166652```

### 输出

```
3805189325```

# AI分析结果



### 题目重写
已为中文，无需重写。

### 算法分类
离散化

---

### 综合分析与结论
题目要求找到一段未被覆盖的 c 长度区间，并最小化删除区间的代价总和。关键点在于如何高效枚举所有可能的候选区间，并快速计算对应的最小代价。

#### 题解对比与评分
1. **eoinlee 题解（★★★★）**
   - **关键亮点**：利用离散化处理端点，预处理前缀和与后缀和，实现 O(1) 计算候选区间的保留代价总和。
   - **实现思路**：
     - 离散化所有区间的左右端点，生成候选的 c 长度区间。
     - 预处理前缀和 `pre[i]`（所有完全在 i 左侧的区间代价和）和后缀和 `suf[i]`（所有完全在 i 右侧的区间代价和）。
     - 对每个候选区间 `[L, R]`，答案公式为 `sum - pre[L] - suf[R]`，其中 `sum` 是总代价。
   - **代码核心**：
     ```cpp
     // 离散化端点并排序
     vector<int> points = {0, w - c};
     for (auto [l, r, p] : intervals) {
         points.push_back(max(0, l - c));
         points.push_back(min(w - c, r));
     }
     sort(points.begin(), points.end());
     // 计算 pre 和 suf 数组
     ```

2. **Chenyanxi0829 题解（★★★★）**
   - **关键亮点**：滑动窗口结合优先队列动态维护覆盖区间的代价，实时计算最小删除代价。
   - **实现思路**：
     - 生成候选区间（每个区间的左端点减 c 或右端点作为起点）。
     - 排序候选区间和输入区间，通过双指针维护当前覆盖候选区间的区间集合。
     - 使用优先队列管理区间的右端点，动态移除不再覆盖当前候选区间的区间。
   - **代码核心**：
     ```cpp
     // 生成候选区间并排序
     for (int i = 1; i <= n; i++) {
         b[2*i-1] = { max(0, a[i][0]-c), max(0, a[i][0]-c)+c };
         b[2*i] = { min(w, a[i][1]+c)-c, min(w, a[i][1]+c) };
     }
     // 滑动窗口维护当前覆盖区间
     for (int i=1, j=0; i<=2*n; i++) {
         while (j < n && a[j+1][0] < b[i].second) {
             j++;
             q.push({a[j][1], a[j][2]});
             sum += a[j][2];
         }
         while (!q.empty() && q.top().first <= b[i].first) {
             sum -= q.top().second;
             q.pop();
         }
         ans = min(ans, sum);
     }
     ```

---

### 最优关键思路
1. **候选区间的端点离散化**：仅考虑现有区间的端点或边界点，减少枚举量。
2. **数据结构优化**：使用前缀和/后缀和或优先队列，快速计算保留区间的代价总和。

---

### 拓展与推荐题目
1. **滑动窗口应用**：洛谷 P1886（滑动窗口 /【模板】单调队列）
2. **离散化与区间覆盖**：洛谷 P1719（最大加权矩形）
3. **贪心+优先队列**：洛谷 P3128（[USACO15DEC]Max Flow P）

---
处理用时：76.85秒
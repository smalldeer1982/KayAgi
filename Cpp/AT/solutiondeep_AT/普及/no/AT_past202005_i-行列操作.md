# 题目信息

# 行列操作

## 题目描述

有一个满足以下条件的一个 $n \times n$ 的矩阵 $a$。若将该数列上起第 $i$ 行，左起第 $j$ 列上的数记为 $a_{i,j}$，则：

- 当 $1 \le i,j \le n$ 时，$a_{i,j}=n \times (i-1)+j-1$。

## 说明/提示

**数据规模与约定**

对于全部测试点，数据保证：

- $1 \le n,q \le 10^5$；
- $1 \le x,y \le n$；
- 保证至少存在一个形如`4 x y`格式的查询；
- 输入中的所有数值均为整数。

## 样例 #1

### 输入

```
2

19

4 1 1

4 1 2

4 2 1

4 2 2

3

4 1 1

4 1 2

4 2 1

4 2 2

1 1 2

4 1 1

4 1 2

4 2 1

4 2 2

2 2 1

4 1 1

4 1 2

4 2 1

4 2 2```

### 输出

```
0

1

2

3

0

2

1

3

1

3

0

2

3

1

2

0```

## 样例 #2

### 输入

```
3

9

2 2 3

3

1 2 1

2 3 2

1 1 3

3

4 1 1

4 2 2

4 2 3```

### 输出

```
1

6

8```

# AI分析结果



### 题目重写
有一个满足以下条件的 $n \times n$ 矩阵 $a$，其中元素 $a_{i,j}$ 定义为：  
- 当 $1 \le i,j \le n$ 时，$a_{i,j} = n \times (i-1) + j-1$。

现需进行 $q$ 次操作，操作类型包括：  
1. 交换两行  
2. 交换两列  
3. 转置矩阵  
4. 查询某位置元素  

数据规模：  
- $1 \le n,q \le 10^5$  
- 保证至少存在一个查询操作  

---

### 算法分类  
模拟

---

### 题解对比与结论  

#### 核心思路对比  
1. **ylch（五星）**:  
   - 维护行映射 `row` 和列映射 `col` 数组，记录当前行列对应的原始位置  
   - 转置操作交换 `row` 和 `col` 数组，并用布尔标记 `flag` 记录转置状态  
   - 查询时根据 `flag` 决定是否交换行列坐标  
   - 亮点：通过指针式映射实现 O(1) 操作，逻辑清晰且高效  

2. **andyli（四星）**:  
   - 类似 ylch 的映射思路，代码更简洁  
   - 转置时直接交换行列数组并取反标记  
   - 亮点：代码精简，但使用宏定义可能影响可读性  

3. **NFGase（四星）**:  
   - 用一维数组存储行和列的初始值  
   - 通过偏移量 `a` 和 `b` 切换行列的访问方式  
   - 转置时交换偏移量实现行列切换  
   - 亮点：空间优化巧妙，但代码逻辑理解成本较高  

#### 最优关键思路  
- **行列映射 + 转置标记**：通过维护行列的映射关系和转置状态，将矩阵的物理操作转换为逻辑映射的调整，所有操作均在 O(1) 时间内完成，完美适配大数据规模。  

#### 拓展思考  
- 类似问题可考虑通过"虚拟指针"或"懒更新"减少实际数据变动  
- 转置操作的本质是行列逻辑的互换，可推广到其他矩阵变换问题  

---

### 推荐相似题目  
1. [P3613 寄包柜](https://www.luogu.com.cn/problem/P3613) - 稀疏矩阵的虚拟存储  
2. [P2181 对角线](https://www.luogu.com.cn/problem/P2181) - 矩阵数学性质分析  
3. [P1102 表格统计](https://www.luogu.com.cn/problem/P1102) - 行列操作与统计  

---

### 核心代码实现（ylch 题解）  
```cpp
vector<int> row(n+1), col(n+1);
iota(row.begin(), row.end(), 0);
iota(col.begin(), col.end(), 0);
bool transpose = false;

while (q--) {
    int op, x, y;
    cin >> op;
    if (op == 1 || op == 2) {
        swap(op == 1 ? row[x] : col[x], op == 1 ? row[y] : col[y]);
    } else if (op == 3) {
        transpose = !transpose;
        swap(row, col);
    } else {
        int i = row[x], j = col[y];
        if (transpose) swap(i, j);
        cout << 1LL * n * (i-1) + (j-1) << '\n';
    }
}
```

---
处理用时：84.88秒
# 题目信息

# 数列の反転

## 题目描述

维护一个长度为 $2n$ 的序列 $a$。开始时，对于每个满足 $1 \le a \le 2n$ 的整数 $i$，都有 $a_i=i$。

给出 $q$ 次操作，每次操作都为以下两种形式中的一种：

- `1 k`：输出 $a_k$ 的值并换行。保证 $1 \le k \le 2n$。
- `2 k`：反转 $[n-k+1,n+k]$ 这个区间。反转后，原来的第 $p$ 个元素被换到了第 $2n-p+1$ 个元素的位置。保证 $1 \le k \le n$。

请按顺序执行操作。

## 说明/提示

#### 数据规模与约定

$1 \le n,q \le 2 \times10^5$，$1 \le t_i \le 2$。

## 样例 #1

### 输入

```
3 2

2 2

1 4```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3

2 3

1 3

1 1```

### 输出

```
4

6```

## 样例 #3

### 输入

```
5 6

2 2

2 1

2 1

2 3

1 2

2 3```

### 输出

```
2```

# AI分析结果



# 数列的反转

## 题目描述

维护一个长度为 $2n$ 的序列 $a$。初始时，对于每个满足 $1 \le i \le 2n$ 的整数 $i$，都有 $a_i=i$。

给出 $q$ 次操作，每次操作为以下两种形式之一：

- `1 k`：输出 $a_k$ 的值并换行。保证 $1 \le k \le 2n$。
- `2 k`：反转区间 $[n-k+1,n+k]$。反转后，原来的第 $p$ 个元素被换到第 $2n-p+1$ 个元素的位置。保证 $1 \le k \le n$。

请按顺序执行所有操作。

## 算法分类
树状数组 / 差分

---

## 题解分析与结论

### 关键思路对比
| 题解类型       | 核心思路                                                                 | 时间复杂度 | 优化点                         |
|----------------|--------------------------------------------------------------------------|------------|--------------------------------|
| 平衡树实现     | 使用 FHQ-Treap 维护序列，通过懒标记处理区间反转                             | O(q log n) | 标准数据结构解法               |
| 差分树状数组   | 将反转操作转化为奇偶次数的统计，通过维护反转次数的奇偶性决定最终输出值       | O(q log n) | 巧妙转换问题，极大简化实现难度 |

### 精选题解（4星+）

#### 1. SamHH0912（5星）
**核心思路**：  
通过观察反转操作的对称性，发现每个位置最终是否反转仅取决于其所在区间的反转次数的奇偶性。使用树状数组维护前缀奇偶次数，将区间操作转换为差分操作。

**关键代码**：
```cpp
inline bool flip(int x) {
    bool res = 0;
    for(;x;x-=lowbit(x)) res ^= c[x]&1;
    return res;
}

// 处理操作
if(op == 1) {
    int p = k>n ? k-n : n-k+1;
    if(flip(p)) cout << 2*n+1-k << "\n";
    else cout << k << "\n";
} else {
    add(1,1);  // 差分数组区间加
    if(k < n) add(k+1,-1);
}
```

#### 2. HUANGRUI11（4星）
**实现亮点**：  
利用树状数组维护反转次数的奇偶性，通过位运算优化奇偶判断。将每个反转操作转换为对差分数组的两次单点修改。

**代码片段**：
```cpp
void add(int x, int k) {
    while(x <= n) {
        a[x] += k;
        x += lowbit(x);
    }
}

bool dfs(int x) {
    bool res = 0;
    while(x > 0) {
        res ^= a[x]&1;
        x -= lowbit(x);
    }
    return res;
}
```

---

## 最优解法核心
**差分奇偶性判定**：  
1. 将每个反转区间操作转换为对区间 `[1, k]` 的奇偶次数修改
2. 查询时计算对应位置的反转次数奇偶性：
   - 奇数次：输出对称位置 `2n+1-k`
   - 偶数次：保持原值

---

## 举一反三
1. 类似差分技巧：P3368（树状数组模板）
2. 区间操作转换：P3391（文艺平衡树）
3. 奇偶性应用：CF525E（奇偶性状态压缩）

---

## 调试心得摘录
1. **SamHH0912**：  
   "观察反转区间的中点不变特性是解题突破口，将物理反转转换为逻辑标记后，复杂度骤降"
   
2. **HUANGRUI11**：  
   "最初尝试线段树超时，改用树状数组位运算优化后效率提升显著，注意差分边界处理"

---
处理用时：44.83秒
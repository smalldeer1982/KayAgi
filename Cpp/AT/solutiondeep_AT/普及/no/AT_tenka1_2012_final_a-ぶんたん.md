# 题目信息

# ぶんたん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tenka1-2012-final/tasks/tenka1_2012_final_a

 フィボナッチ数列は、以下のような漸化式で表される数列 $ F_0,\ F_1,\ F_2,\ …\ (=0,\ 1,\ 1,\ 2,\ 3,\ 5,\ 8,\ 13,\ …) $ であり、フィボナッチ数はこの数列に現れる数 $ F_i\ (i\ \geq\ 0) $ です。

- $ F_{0}\ =\ 0 $
- $ F_{1}\ =\ 1 $
- $ F_{i+2}\ =\ F_{i}\ +\ F_{i+1} $ ($ i\ \geq\ 0 $)

 ある正整数 $ n $ をいくつかのフィボナッチ数の和として表すことを考えます。  
 このとき、和が正整数 $ n $ となるフィボナッチ数の個数として考えられる最小の値を答えなさい。  
 ただし、同じフィボナッチ数を複数回用いることもできるものとし、複数回用いた場合はそれぞれ別々に数えるものとします。

 入力は以下の形式で標準入力から与えられる。 > $ n $

- 正整数 $ n $ ($ 1\ \leq\ n\ \leq\ 10^{10} $) が $ 1 $ 行で与えられる。
 
 与えられる数が小さい入力 ($ 1\ \leq\ N\ \leq\ 10^5 $) のみ正解すると、$ 100 $ 点満点に対して部分点として $ 50 $ 点が与えられる。 和が正整数 $ n $ となるフィボナッチ数の個数として考えられる最小の値を $ 1 $ 行で出力せよ。  
 なお、行の終端には改行が必要である。

# AI分析结果



### 中文重写题目

**题目名称：分弹**

**题目描述**

斐波那契数列是由以下递推式定义的数列 $F_0, F_1, F_2, \ldots$（即 $0, 1, 1, 2, 3, 5, 8, 13, \ldots$），其中每个数称为斐波那契数。  
给定一个正整数 $n$，将其表示为若干个斐波那契数之和，求所需斐波那契数的**最少个数**（允许重复使用同一斐波那契数，每个使用的数单独计数）。

**输入格式**  
输入为一个正整数 $n$（$1 \leq n \leq 10^{10}$）。  
小数据范围（$n \leq 10^5$）可得部分分（50/100）。

**输出格式**  
输出表示 $n$ 所需的最少斐波那契数的个数。

---

### 算法分类
**贪心**

---

### 题解分析与结论

**核心思路**  
1. **贪心策略**：每次选择不超过剩余值的最大的斐波那契数，尽可能多取该数，直到和为 $n$。  
2. **正确性依据**：斐波那契数列的指数级增长性质保证了较大的数覆盖更广的数值范围，优先取大数能快速减少剩余值，从而最小化总个数。  
3. **实现要点**：  
   - 预先生成斐波那契数列至首个大于 $n$ 的数。  
   - 逆序遍历数列，每次尽可能多取当前数。

**关键优化**  
- 斐波那契数列生成到约 $F_{45}$ 即可覆盖 $10^{10}$ 的范围，时间复杂度为 $O(\log n)$。  
- 直接遍历时无需二分，因数列生成后逆序检查的时间可忽略。

---

### 精选题解

#### 1. 作者：zjyqwq（5星）
**亮点**  
- 代码简洁，使用 `while(n >= a[j])` 实现贪心的多取操作。  
- 包含卡常技巧（如 `++i` 优于 `i++`），提升运行效率。  
**核心代码**  
```cpp
for(R int j=m;j>=1;--j){
    while(n>=a[j]) n-=a[j], ++k;
    if(n==0) break;
}
```

#### 2. 作者：_Arahc_（5星）
**亮点**  
- 引入齐肯多夫定理证明贪心正确性，强化理论支撑。  
- 提供二分查找优化思路（虽未实际采用，但启发拓展思维）。  
**关键证明**  
> 若贪心选取最大的数，总能通过合并相邻项证明其最优性，且分解唯一。

#### 3. 作者：infinities（4星）
**亮点**  
- 提供双重循环与单循环两种实现，对比展示优化思路。  
- 代码可读性高，适合初学者理解贪心流程。  
**核心代码**  
```cpp
for(int j=m;j>=1;j--){
    while(n-a[j]>=0) n-=a[j], k++;
    if(n==0) break;
}
```

---

### 最优代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    long long n;
    cin >> n;
    vector<long long> fib = {1, 1}; // 斐波那契数列初始值（F1=1, F2=1）
    
    // 生成数列至首个大于n的值
    while (fib.back() <= n) {
        fib.push_back(fib[fib.size()-1] + fib[fib.size()-2]);
    }
    
    int cnt = 0;
    for (int i = fib.size()-2; i >= 0; i--) { // 逆序遍历有效数
        cnt += n / fib[i];
        n %= fib[i];
        if (n == 0) break;
    }
    cout << cnt << endl;
    return 0;
}
```

---

### 拓展与心得

**同类问题**  
- 类似「硬币问题」（用最少硬币数凑金额），但斐波那契数的特殊性保证了贪心最优性。  
- 若数列非斐波那契性质，则可能需要动态规划（如背包问题）。

**调试心得**  
- 注意斐波那契数列的初始定义，避免生成错误（如误含0或起始项不符）。  
- 循环终止条件需严格验证，防止漏掉边界情况（如n恰为某斐波那契数）。

---

### 推荐习题
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心策略选择最小堆  
2. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969) - 差分思想与贪心结合  
3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995) - 贪心选择最大/小值交替

---
处理用时：78.82秒
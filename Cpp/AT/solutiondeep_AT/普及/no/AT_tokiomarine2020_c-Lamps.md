# 题目信息

# Lamps

## 题目描述

# Lamps


[problemUrl]: https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_c

给定 $ N $ 个灯泡，其亮度分别为 $ A_i $。每个灯泡的作用范围为 $ i-A_i-0.5$ 到 $ i+A_i+0.5 $。

有 $ K $ 轮操作。

每轮操作使得每个灯泡的亮度更改为照亮它的灯泡的个数。

## 说明/提示

- $ 1\ \leqq\ N\ \leqq\ 2\ \times\ 10^5 $
- $ 1\ \leqq\ K\ \leqq\ 2\ \times\ 10^5 $
- $ 0\ \leqq\ A_i\ \leqq\ N $

### 样例1解释 

$ 1 $ 号数只有第 $ 1 $ 个数本身作用 ，第 $ 2 $ 个数有第 $ 1 $ 和 第 $ 2 $ 个数作用，以此类推。

## 样例 #1

### 输入

```
5 1

1 0 0 1 0```

### 输出

```
1 2 2 1 2```

## 样例 #2

### 输入

```
5 2

1 0 0 1 0```

### 输出

```
3 3 4 4 3```

# AI分析结果



【中文重写题目】
# 灯泡

## 题目描述

给定 $ N $ 个灯泡，其初始亮度分别为 $ A_i $。每个灯泡的照射范围为 $ [i - A_i - 0.5, i + A_i + 0.5] $。

进行 $ K $ 轮操作，每轮操作中每个灯泡的亮度将被更新为能够覆盖它的灯泡数量（包含自身）。

### 输入格式
- 第一行两个整数 $ N $ 和 $ K $
- 第二行 $ N $ 个整数表示初始亮度数组 $ A $

### 输出格式
- 输出 $ K $ 轮操作后的灯泡亮度序列

## 样例 #1

### 输入
```
5 1
1 0 0 1 0
```

### 输出
```
1 2 2 1 2
```

## 样例 #2

### 输入
```
5 2
1 0 0 1 0
```

### 输出
```
3 3 4 4 3
```

---

**【算法分类】**  
差分

---

**【题解分析与结论】**  
两篇题解均采用差分数组加速区间更新，核心差异在于剪枝策略：  
1. Petit_Souris 的题解通过数学证明得出操作次数上限为 $ O(\log n) $，当出现全 $ n $ 值时提前终止  
2. DashZhanghanxu 的题解通过比较新旧数组是否相同来提前终止，虽然理论分析较弱但实际效果接近  

最优思路为：**差分数组 + 前缀和快速计算覆盖数，结合快速收敛特性提前终止**。关键技巧在于发现数值快速增长至 $ n $ 的特性，将总时间复杂度从 $ O(NK) $ 优化至 $ O(N\log N) $。

---

**【高分题解推荐】**  

### 题解一（5星）  
**作者：Petit_Souris**  
**关键亮点**：  
- 严谨的数学收敛性证明，说明最多进行 $ O(\log n) $ 次有效操作  
- 引入全 $ n $ 值剪枝条件，确保最优时间复杂度  
**代码核心思想**：  
```cpp
// 差分数组处理区间覆盖
vector<int> dif(N+1, 0);
for(int i=0; i<N; ++i){
    int L = max(1, i+1 - A[i]) - 1;
    int R = min(N, i+1 + A[i]) - 1;
    dif[L]++; dif[R+1]--;
}
// 前缀和求当前覆盖数
partial_sum(dif.begin(), dif.end()-1, A.begin());
```

### 题解二（4星）  
**作者：DashZhanghanxu**  
**关键亮点**：  
- 简洁的差分实现，易于理解  
- 通过新旧数组比对实现通用性剪枝  
**代码亮点**：  
```cpp
if(neww == A) break;  // 稳定状态检测
A.swap(neww);         // 内存复用优化
```

---

**【同类题目推荐】**  
1. [P3406 海底高铁] - 差分统计区间访问次数  
2. [P2280 激光炸弹] - 二维前缀和与区域覆盖  
3. [P3667 新型城市化] - 快速区间操作与收敛特性分析

---
处理用时：50.33秒
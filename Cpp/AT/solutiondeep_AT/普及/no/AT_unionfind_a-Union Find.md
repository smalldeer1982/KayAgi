# 题目信息

# Union Find

## 题目描述

[problemUrl]: https://atcoder.jp/contests/atc001/tasks/unionfind_a

この問題は、講座用問題です。ページ下部に解説が掲載されています。

$ N $ 頂点の、単純とは限らない無向グラフを考えます。 初期状態では、頂点のみが存在し、辺は全く存在せず、全ての頂点が孤立しているとします。 以下の $ 2 $ 種類のクエリが、$ Q $ 回与えられます。

- 連結クエリ： 頂点 $ A $ と、頂点 $ B $ を繋ぐ辺を追加します。
- 判定クエリ： 頂点 $ A $ と、頂点 $ B $ が、連結であるかどうか判定します。連結であれば `Yes`、そうでなければ `No` を出力します。

クエリを順番に処理し、判定クエリへの回答を出力して下さい。 この際、同じ辺が何度も追加されることや、自分自身への辺が追加されることもある事に注意してください。

連結であるとは、頂点 $ A $ から頂点 $ B $ まで辺をたどって到達可能であることを意味します。 $ A $ と $ B $ が同じ頂点の場合、連結であると定義します。 グラフは無向であるため、連結クエリによって頂点 $ A,\ B $ 間の辺が追加されると、$ A $ から $ B $ へも $ B $ から $ A $ へも辿れるようになります。

## 说明/提示

### 解説

  **[Union find(素集合データ構造)](https://www.slideshare.net/secret/CIWAduFPvzGrrE "Union find(素集合データ構造)")**  from **[AtCoder Inc.](http://www.slideshare.net/chokudai)** 

### Sample Explanation 1

以下のような手順で実行されます。 - $ 1 $ つ目のクエリで、頂点 $ 1 $ と頂点 $ 2 $ を繋ぎます。 - $ 2 $ つ目のクエリで、頂点 $ 3 $ と頂点 $ 2 $ を繋ぎます。 - $ 3 $ つ目のクエリで、頂点 $ 1 $ と頂点 $ 3 $ の連結判定を行います。連結しているので、`Yes`と出力します。 - $ 4 $ つ目のクエリで、頂点 $ 1 $ と頂点 $ 4 $ の連結判定を行います。連結していないので、`No`と出力します。 - $ 5 $ つ目のクエリで、頂点 $ 2 $ と頂点 $ 4 $ を繋ぎます。 - $ 6 $ つ目のクエリで、頂点 $ 4 $ と頂点 $ 1 $ の連結判定を行います。連結しているで、`Yes`と出力します。 - $ 7 $ つ目のクエリで、頂点 $ 4 $ と頂点 $ 2 $ を繋ぎます。これらは既に繋がれていますが、多重辺が出来ることもあります。 - $ 8 $ つ目のクエリで、頂点 $ 0 $ と頂点 $ 0 $ を繋ぎます。これらは同じ頂点ですが、自己ループが出来ることもあります。 - $ 9 $ つ目のクエリで、頂点 $ 0 $ と頂点 $ 0 $ の連結判定を行います。同じ頂点は常に連結していると見做せるので、`Yes`と出力します。

## 样例 #1

### 输入

```
8 9

0 1 2

0 3 2

1 1 3

1 1 4

0 2 4

1 4 1

0 4 2

0 0 0

1 0 0```

### 输出

```
Yes

No

Yes

Yes```

# AI分析结果



# Union Find

## 题目中文改写

$ N $ 个顶点的无向图初始无任何边，处理 $ Q $ 次两种操作：
1. 连接顶点 $ A $ 和 $ B $（允许自环和多重边）
2. 判断 $ A $ 与 $ B $ 是否连通

输出所有判定查询的结果。

**样例解释**：通过边连接形成连通分量，多次连接可能形成多重边，自环不影响连通性判断，相同顶点默认连通。

## 算法分类
并查集

---

## 题解综合分析

所有题解均采用路径压缩优化并查集，主要差异在于是否结合按秩合并及代码封装方式。关键点包括：
1. 路径压缩优化查询效率
2. 合并操作的根节点处理
3. 自环与重复边的天然容错性

---

## 精选题解（评分≥4星）

### 题解1：HsKr（⭐⭐⭐⭐⭐）
**核心亮点**：
1. 完整实现路径压缩 + 按秩合并双优化
2. 结构体封装并查集模板复用性强
3. 扩展讲解种类并查集应用场景

**关键代码**：
```cpp
struct Union_Find {
    int fa[MAXN], size[MAXN];
    Union_Find() { // 初始化
        for(int i=0;i<MAXN;i++) fa[i]=i, size[i]=1;
    }
    int find(int x) { // 路径压缩
        return fa[x] = (fa[x]==x) ? x : find(fa[x]);
    }
    void uni(int x, int y) { // 按秩合并
        int fx=find(x), fy=find(y);
        if(fx == fy) return;
        if(size[fx] > size[fy]) swap(fx,fy);
        fa[fx] = fy;
        size[fy] += size[fx];
    }
};
```

### 题解2：asasas（⭐⭐⭐⭐）
**核心亮点**：
1. 代码简洁适合新手理解
2. 突出路径压缩的核心实现
3. 直接处理输入输出的类型判断

**代码片段**：
```cpp
int f[100005];
int find(int x) {
    if(f[x] != x) f[x] = find(f[x]);
    return f[x];
}
void merge(int x, int y) {
    f[find(y)] = find(x);
}
// 输入处理直接判断操作类型
```

### 题解3：谷民（⭐⭐⭐⭐）
**优化技巧**：
1. 独立初始化函数增强可读性
2. 使用快读处理大数据输入
3. 按秩合并的三种情况分类处理

**调试心得**：
> "合并时要注意祖先的比较顺序，小树合并到大树能保持平衡性，实测可提升约20%效率"

---

## 关键思路总结
1. **双优化策略**：路径压缩（查询时扁平化树结构） + 按秩合并（保持树高平衡）
2. **状态复用**：根节点存储连通分量信息，合并只需修改根节点指针
3. **容错处理**：重复连接同一对节点不影响结果，自环自动满足连通性

---

## 拓展练习
1. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551) - 基础连通性判断
2. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367) - 标准模板实现
3. [P2024 食物链](https://www.luogu.com.cn/problem/P2024) - 种类并查集进阶应用

---
处理用时：44.81秒
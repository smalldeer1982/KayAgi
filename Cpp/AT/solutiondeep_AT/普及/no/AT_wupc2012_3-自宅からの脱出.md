# 题目信息

# 自宅からの脱出

## 题目描述

一张地图用一些字符串来描述。地图上的位置代表对应的平面坐标。

上端表示北方。西北角为坐标 $(1,1)$，东南角为坐标 $(M,N)$。坐标 $(x,y)$ 表示第 $y$ 行的第 $x$ 个字符。

- `.` 空地
- `C` 笔记本电脑
- `S` 出发地
- `G` 门

你可以在 $1$ 个单位时间内从当前位置，移动到 $(x+1,y),(x,y+1),(x-1,y),(x,y-1)$ 中的任意一个。

特别的，还有一些不能移动到的要求：

- 不能移动到墙壁（`#`）所在的地方。

- 移动到计算机所在地之后立刻拿上电脑，不用考虑此动作所花的时间。

- 到达家的门口时，如果此时没有拿上笔记本电脑，那么什么也不会发生。

请求出拿上电脑并到达门口的所花的最短时间。

![](https://cdn.luogu.org/upload/pic/23163.png)

## 说明/提示

对于 $100\%$ 的数据，$5\le n\le 500$，$5\le m\le 500$。

保证数据中墙壁围成了一个封闭图形。 

保证每行的首字符与末字符都为 `#`。

翻译 by @[159号程序员](https://www.luogu.com.cn/user/334586)

# AI分析结果



# 自宅からの脱出

## 题目描述

一张地图用字符串描述，包含空地`.`、墙壁`#`、起点`S`、电脑`C`和终点`G`。需从起点出发先拿到电脑，再到达终点，求最短时间。每次移动耗时1单位，不能穿过墙壁。

## 算法分类
广度优先搜索 BFS

---

## 题解分析与结论

### 核心思路
所有题解均采用 **两次BFS** 或 **一次逆向BFS** 的思路：
1. **两次BFS**：先计算起点→电脑的最短路径，再计算电脑→终点的最短路径，总和为答案。
2. **一次逆向BFS**：以电脑为起点，同时计算到起点和终点的距离，两段距离之和即为总时间。

### 解决难点
- **路径顺序限制**：必须确保先拿电脑再到达终点。两次BFS通过分阶段搜索自然满足顺序。
- **状态重置**：第二次BFS前需清空队列和访问数组。
- **逆向思维优化**：Max_s_xaM的题解通过一次BFS计算电脑到起点和终点的距离，避免重复搜索。

---

## 精选题解

### 1. Max_s_xaM（五星）
**关键亮点**：  
- 逆向思维，仅需一次BFS即可计算两段距离。
- 代码简洁高效，时间复杂度优化至单次BFS。  
**核心代码**：
```cpp
void bfs() {
    q.push(make_pair(xc, yc));
    vis[xc][yc] = 1;
    while (!q.empty()) {
        int x = q.front().first, y = q.front().second;
        q.pop();
        for (int i = 0; i < 4; i++) {
            int xx = x + dx[i], yy = y + dy[i];
            if (xx < 1 || xx > n || yy < 1 || yy > m || map[xx][yy] == '#' || vis[xx][yy]) continue;
            dis[xx][yy] = dis[x][y] + 1;
            q.push(make_pair(xx, yy));
            vis[xx][yy] = 1;
        }
    }
}
```

### 2. wssdl（四星）
**关键亮点**：  
- 使用三维`vis`数组记录是否携带电脑的状态。
- 处理复杂状态转移，确保路径合法性。  
**核心代码片段**：
```cpp
struct Node { int x, y, s; bool b; };
int bfs(int x, int y, int s, int b) {
    queue<Node> q;
    q.push({x, y, s, b});
    vis[x][y][b] = 1;
    while (!q.empty()) {
        Node cur = q.front(); q.pop();
        if (cur.x == fx && cur.y == fy && cur.b) return cur.s;
        if (a[cur.x][cur.y] == 'C') cur.b = 1;
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i], ny = cur.y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m || a[nx][ny] == '#' || vis[nx][ny][cur.b]) continue;
            vis[nx][ny][cur.b] = 1;
            q.push({nx, ny, cur.s + 1, cur.b});
        }
    }
    return -1;
}
```

### 3. zoobidubi（四星）
**关键亮点**：  
- 手写队列实现BFS，优化空间控制。
- 强调队列和访问数组的初始化问题。  
**个人心得**：  
> "搜第二遍时q数组一定一定要清0！！！否则会WA。"

---

## 关键思路总结
1. **两次BFS分段处理**：分别计算起点→电脑和电脑→终点的最短路径，确保顺序合法。
2. **状态压缩**：使用三维数组记录位置和是否携带电脑的状态，避免重复路径。
3. **逆向思维优化**：以必经点（电脑）为中心，单次BFS计算两段距离，减少时间复杂度。

---

## 拓展练习
1. [P3395 路障](https://www.luogu.com.cn/problem/P3395) - 分段BFS处理动态障碍
2. [P5195 森林木屋](https://www.luogu.com.cn/problem/P5195) - 必须收集钥匙的路径问题
3. [P3958 奶酪](https://www.luogu.com.cn/problem/P3958) - BFS在三维空间的应用

---
处理用时：66.83秒
# 题目信息

# 宇宙人からのメッセージ

## 题目描述

给出密文 $S$，解读方法如下：

- 设 $T$ 为空字符串；
- $i=1,2,...,|S|$ 以下按顺序进（$|S|$ 表示 $S$ 的长度）；
    - 当 $S$ 的第 $i$ 字母是 $R$ 时，将 $T$ 反转；
   - 当 $S$ 的第 $i$ 个字母不是 $R$ 时，在 $T$ 的末尾加上该字母。
- 然后，如果 $T$ 中连续出现了两个相同的字母，就去掉这两个字母。尽可能地继续这个操作(可以证明最终得到的字符串不会取决于去除的顺序)。

请输出通过以上操作得到的字符串 $T$。

## 说明/提示

- 字符串 $S$ 由英文小写字母和R组成；
- $1 \le |S| \le 5 × 10^5 $。

### 样例 1 解释

- 最初，$T$ 是空字符串。
- 在 $T$ 的末尾加上 `o`，$T$ 变成了 `o`。
- 在 $T$ 的末尾加上 `z`，$T$ 变成了 `oz`。
- $T$ 反转，$T$ 变成了 `zo`。
- 在 $T$ 的末尾加上 `n`，$T$ 变成了 `zon`。
- 在 $T$ 的末尾加上 `o`，$T$ 变成了 `zono`。
- 在 $T$ 的末尾加上 `n`，$T$ 变成了 `zonon`。
- 在 $T$ 的末尾加上 `n`，$T$ 变成了 `zononn`。
- 在 $T$ 的末尾加上 `o`，$T$ 变成了 `zononno`。
- 在 $T$ 的末尾加上 `e`，$T$ 变成了 `zononnoe`。
- 删除连续排列的 `n`，$T$ 变成了 `zonooe`。
- 删除连续排列的 `o`，$T$ 变成了 `zone`。

### 样例 2 解释
空串有时也会成为答案。

## 样例 #1

### 输入

```
ozRnonnoe```

### 输出

```
zone```

## 样例 #2

### 输入

```
hellospaceRhellospace```

### 输出

```
```

# AI分析结果



# 宇宙人からのメッセージ

## 题目描述
给出密文 $S$，解读方法如下：

- 设 $T$ 为空字符串；
- 对于每个字符按顺序处理：
    - 遇到字符 'R' 时反转 $T$；
    - 遇到其他字符时添加到 $T$ 末尾；
    - 每次添加后若存在连续重复字符则立即消除，尽可能重复消除。

最终输出处理后得到的字符串 $T$。

**算法分类**：队列

---

## 题解分析与结论

### 核心思路
通过双端队列维护字符串状态，用反转标记代替实际反转操作。关键优化点：
1. **方向标记**：使用布尔变量标记当前插入方向（正向/逆向）
2. **双端操作**：根据标记选择队头或队尾插入，并在插入时即时消除相邻重复字符
3. **延迟反转**：最终根据标记决定输出顺序，避免频繁反转操作

### 高分题解推荐

#### 1. SkyWave（4.5星）
**亮点**：
- 手写双端队列实现，通过数组模拟提高效率
- 初始指针设定巧妙解决空队列判断问题
- 详细注释与边界情况处理（样例2解释）

**核心代码**：
```cpp
int front = 5e5 + 1, rear = 5e5; // 初始指针位置
bool isRev = false;

for (int i = 1; str[i]; ++i) {
    if (str[i] == 'R') isRev ^= 1;
    else {
        if ((front != 5e5+1 || rear !=5e5) && 
           (isRev ? output[front]==str[i] : output[rear]==str[i])) {
            isRev ? ++front : --rear;
        } else {
            isRev ? output[--front] = str[i] : output[++rear] = str[i];
        }
    }
}
```
**个人心得**：  
初始指针位置设定（front=5e5+1）解决了空队列首次插入的判断问题，通过测试样例2时发现若从5e5开始会导致错误插入。

#### 2. ImNot6Dora（4星）
**亮点**：
- 简洁使用STL deque实现
- 逻辑清晰易于理解
- 正确处理空队列的边界情况

**核心代码**：
```cpp
deque<char> t;
bool f = 1;

for (char c : s) {
    if (c == 'R') f = !f;
    else if (f) {
        if (!t.empty() && t.back() == c) t.pop_back();
        else t.push_back(c);
    } else {
        if (!t.empty() && t.front() == c) t.pop_front();
        else t.push_front(c);
    }
}
```
**实现技巧**：  
利用STL容器内置方法直接操作队头队尾，减少代码量。

#### 3. 心灵震荡（4星）
**亮点**：
- 完整STL实现模板
- 强调空队列判断的重要性
- 输出时通过标记选择遍历方向

**关键提示**：  
在判断`t.front()/t.back()`前必须检查队列非空，否则会导致运行时错误。

---

## 知识扩展
**同类问题套路**：  
需要高效处理双向操作的问题，如：
1. 交替前插/后插的字符串构造
2. 带撤销操作的文本编辑器
3. 需要延迟处理反转的序列操作

**推荐练习**：  
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)（双端队列经典应用）  
2. [P1110 报表统计](https://www.luogu.com.cn/problem/P1110)（双端插入与动态查询）  
3. [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)（字符串处理与高效查询）

---
处理用时：61.45秒
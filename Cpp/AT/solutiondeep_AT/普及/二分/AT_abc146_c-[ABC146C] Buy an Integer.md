# 题目信息

# [ABC146C] Buy an Integer

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc146/tasks/abc146_c

高橋くんは整数を $ 1 $ つ買いに整数屋さんに行きました。

整数屋さんには $ 1 $ 以上 $ 10^9 $ 以下の整数が売られていて、整数 $ N $ を買うためには $ A\ \times\ N\ +\ B\ \times\ d(N) $ 円が必要です。ここで、$ d(N) $ は $ N $ の十進表記での桁数です。

高橋くんの所持金が $ X $ 円のとき、高橋くんの買うことのできる最も大きい整数を求めてください。ただし、買うことのできる整数が $ 1 $ つもない場合は $ 0 $ を出力してください。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ A\ \leq\ 10^9 $
- $ 1\ \leq\ B\ \leq\ 10^9 $
- $ 1\ \leq\ X\ \leq\ 10^{18} $

### Sample Explanation 1

$ 9 $ の値段は $ 10\ \times\ 9\ +\ 7\ \times\ 1\ =\ 97 $ 円で、これが買うことのできる最大の整数です。 他の整数の値段の例をいくつかあげると - $ 10:\ 10\ \times\ 10\ +\ 7\ \times\ 2\ =\ 114 $ 円 - $ 100:\ 10\ \times\ 100\ +\ 7\ \times\ 3\ =\ 1021 $ 円 - $ 12345:\ 10\ \times\ 12345\ +\ 7\ \times\ 5\ =\ 123485 $ 円 です。

### Sample Explanation 2

お店に売られている最大の整数を買うことができます。入力が $ 32 $ bit整数型に収まらないことがあることに注意してください。

## 样例 #1

### 输入

```
10 7 100```

### 输出

```
9```

## 样例 #2

### 输入

```
2 1 100000000000```

### 输出

```
1000000000```

## 样例 #3

### 输入

```
1000000000 1000000000 100```

### 输出

```
0```

## 样例 #4

### 输入

```
1234 56789 314159265```

### 输出

```
254309```

# AI分析结果

### 题目内容重写
高橋くん去整数店买一个整数。整数店出售的整数范围是 $1$ 到 $10^9$，购买整数 $N$ 所需的金额为 $A \times N + B \times d(N)$，其中 $d(N)$ 是 $N$ 的十进制位数。给定高橋くん的预算 $X$，求他能够购买的最大整数。如果无法购买任何整数，则输出 $0$。

### 说明/提示
#### 约束
- 所有输入均为整数。
- $1 \leq A \leq 10^9$
- $1 \leq B \leq 10^9$
- $1 \leq X \leq 10^{18}$

### 样例解释
#### 样例 1
输入：
```
10 7 100
```
输出：
```
9
```
解释：购买整数 $9$ 需要 $10 \times 9 + 7 \times 1 = 97$ 元，这是高橋くん能够购买的最大整数。

#### 样例 2
输入：
```
2 1 100000000000
```
输出：
```
1000000000
```
解释：高橋くん可以购买商店中最大的整数 $1000000000$。

#### 样例 3
输入：
```
1000000000 1000000000 100
```
输出：
```
0
```
解释：高橋くん的预算不足以购买任何整数。

### 题解分析与结论
本题的核心是通过二分查找来确定高橋くん能够购买的最大整数。由于整数的价格随着数值的增加而单调递增，因此可以使用二分查找来高效地找到满足条件的最大整数。

### 所选高分题解
#### 题解1：CYZZ (4星)
**关键亮点**：
- 使用二分查找法，时间复杂度为 $O(\log n)$。
- 详细解释了二分查找的边界条件和 `mid` 的取值问题，避免死循环。
- 代码简洁明了，易于理解。

**代码核心实现**：
```cpp
bool check(int mid) {
    int x = log10(mid) + 1;
    return (a * mid + b * x) <= c;
}

signed main() {
    scanf("%lld%lld%lld", &a, &b, &c);
    int l = 0, r = 1e9;
    while (l < r) {
        int mid = (l + r + 1) / 2;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    printf("%lld", r);
    return 0;
}
```

#### 题解2：TLEWA (4星)
**关键亮点**：
- 通过拆分问题，先确定整数的位数，再计算最大可能的整数，时间复杂度为 $O(\log n)$。
- 代码逻辑清晰，处理了边界情况。

**代码核心实现**：
```cpp
unsigned long long a, b, c, summ = 1;

int main() {
    cin >> a >> b >> c;
    if (1000000000 * a + 10 * b <= c) {
        cout << 1000000000 << endl;
        return 0;
    } else {
        unsigned long long i;
        for (i = 1; i <= 10; ++i) {
            if (summ * a + i * b > c) {
                --i;
                break;
            }
            summ *= 10;
        }
        cout << min((c - (i * b)) / a, summ - 1) << endl;
    }
    return 0;
}
```

#### 题解3：AbsMatt (4星)
**关键亮点**：
- 使用二分查找法，时间复杂度为 $O(\log n)$。
- 提供了两种计算整数位数的方法，增加了代码的灵活性。
- 代码结构清晰，易于理解。

**代码核心实现**：
```cpp
bool check(long long x) {
    return (n * x + int(log10(x) + 1) * m <= k);
}

int main() {
    scanf("%lld%lld%lld", &n, &m, &k);
    if (inf * n + 10 * m <= k) {
        printf("%lld", inf);
        exit(0);
    }
    int l = 0, r = 1e9;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else r = mid - 1;
    }
    printf("%lld", ans);
    return 0;
}
```

### 最优关键思路与技巧
- **二分查找**：利用单调性，通过二分查找快速确定最大满足条件的整数。
- **边界处理**：注意二分查找中的边界条件，避免死循环。
- **位数计算**：使用 `log10` 或循环计算整数的位数，确保计算的准确性。

### 可拓展之处
- **类似题目**：可以扩展到其他具有单调性的问题，如寻找满足某些条件的最小或最大值。
- **优化技巧**：在处理大范围数据时，二分查找是一种高效的算法，可以应用于多种场景。

### 推荐题目
1. [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)

### 个人心得总结
- **调试经历**：在处理二分查找时，边界条件的处理非常重要，稍有不慎就会导致死循环或错误结果。
- **踩坑教训**：在计算整数位数时，使用 `log10` 函数需要注意浮点数精度问题，避免计算错误。
- **顿悟感想**：二分查找不仅适用于有序数组，还可以应用于具有单调性的问题，是一种非常强大的算法工具。

---
处理用时：48.44秒
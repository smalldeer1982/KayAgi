# 题目信息

# [ABC319D] Minimum Width

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc319/tasks/abc319_d

高橋くんは、$ N $ 個の単語からなる文章をウィンドウに表示させようとしています。 すべての単語の縦幅は等しく、$ i $ 番目 $ (1\leq\ i\leq\ N) $ の単語の横幅は $ L\ _\ i $ です。

文章は、横幅 $ 1 $ の空白を単語の区切りとしてウィンドウに表示されます。 より厳密には、高橋くんが横幅 $ W $ のウィンドウに文章を表示しているとき、次の条件が成り立っています。

- 文章はいくつかの行に分かれている。
- $ 1 $ 番目の単語は一番上の行の先頭に表示されている。
- $ i $ 番目 $ (2\leq\ i\leq\ N) $ の単語は、$ i-1 $ 番目の単語の次に間隔を $ 1 $ だけ開けて表示されているか、$ i-1 $ 番目の単語が含まれる行の下の行の先頭に表示されているかの一方である。それ以外の場所に表示されていることはない。
- それぞれの行の横幅は $ W $ を超えない。ここで、行の横幅とは最も左にある単語の左端から最も右にある単語の右端までの距離を指す。
 
高橋くんが文章をウィンドウに表示したとき、文章が $ M $ 行に収まりました。 ウィンドウの横幅としてありえる最小の値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ M\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ L\ _\ i\leq10^9\ (1\leq\ i\leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

ウィンドウの横幅が $ 26 $ のとき、以下のようにして与えられた文章を $ 3 $ 行に収めることができます。 !\[\](https://img.atcoder.jp/abc319/710c42acf58eacf40178e28a0a0b3a2c.png) ウィンドウの横幅が $ 25 $ 以下のときは与えられた文章を $ 3 $ 行に収めることができないため、$ 26 $ を出力してください。 単語を複数の行にまたがって表示させたり、行の横幅がウィンドウの横幅を上回ったり、単語を並べ替えたりしてはいけないことに注意してください。 !\[\](https://img.atcoder.jp/abc319/ed3aac3d0c0eb00c5663aa6a95023b33.png)

### Sample Explanation 2

答えが $ 32\operatorname{bit} $ 整数に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
13 3

9 5 2 7 1 8 8 2 1 5 2 3 6```

### 输出

```
26```

## 样例 #2

### 输入

```
10 1

1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
10000000009```

## 样例 #3

### 输入

```
30 8

8 55 26 97 48 37 47 35 55 5 17 62 2 60 23 99 73 34 75 7 46 82 84 29 41 32 31 52 32 60```

### 输出

```
189```

# AI分析结果

### 题目内容重写（中文）

高橋くん想要在一个窗口中显示由 $N$ 个单词组成的句子。每个单词的宽度为 $L_i$，单词之间用宽度为 $1$ 的空格分隔。窗口的宽度为 $W$，句子在窗口中显示时需满足以下条件：

1. 句子被分成若干行。
2. 第一个单词显示在第一行的开头。
3. 对于第 $i$ 个单词（$2 \leq i \leq N$），它要么紧接在第 $i-1$ 个单词之后（中间有一个空格），要么显示在第 $i-1$ 个单词所在行的下一行的开头。
4. 每一行的宽度不超过 $W$。行的宽度定义为该行最左边单词的左端到最右边单词的右端的距离。

高橋くん希望句子在窗口中显示时，行数不超过 $M$ 行。求窗口的最小宽度 $W$。

### 样例解释

#### 样例 1

输入：
```
13 3
9 5 2 7 1 8 8 2 1 5 2 3 6
```
输出：
```
26
```
解释：当窗口宽度为 $26$ 时，句子可以分成 $3$ 行显示。若宽度小于 $26$，则无法在 $3$ 行内显示所有单词。

#### 样例 2

输入：
```
10 1
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
```
输出：
```
10000000009
```
解释：所有单词必须放在同一行，因此窗口宽度为所有单词宽度之和加上 $9$ 个空格。

### 题解分析与结论

本题的核心是通过二分查找确定最小窗口宽度 $W$，使得句子在窗口中显示时行数不超过 $M$。所有题解都采用了二分查找的思路，但在实现细节上有所不同。

#### 关键思路与技巧

1. **二分查找**：窗口宽度 $W$ 的范围为 $[\max(L_i), \sum L_i + (N-1)]$，通过二分查找确定最小 $W$。
2. **贪心模拟**：在二分查找的每一步，通过贪心策略模拟单词的排列，计算当前 $W$ 下所需的行数。
3. **边界处理**：在模拟过程中，需注意单词长度超过当前 $W$ 的情况，以及行末的空格处理。

#### 最优题解推荐

1. **题解作者：Dream_poetry**  
   **星级：★★★★★**  
   **关键亮点**：代码简洁，二分查找和贪心模拟的实现清晰，边界处理得当。  
   **核心代码**：
   ```cpp
   bool check(int x) {
       int now = a[1], cnt = 1;
       for (int i = 2; i <= n; i++) {
           if (now + 1 + a[i] > x) {
               cnt++;
               now = a[i];
           } else {
               now += a[i] + 1;
           }
       }
       return cnt <= m;
   }
   ```

2. **题解作者：dayz_break404**  
   **星级：★★★★☆**  
   **关键亮点**：代码可读性强，二分查找和贪心模拟的实现较为规范。  
   **核心代码**：
   ```cpp
   bool check(ll x) {
       ll now = 0, k = 1;
       for (int i = 1; i <= n; i++) {
           if (a[i] > x) return 0;
           if (!now) now--;
           if (now + a[i] + 1 <= x) now += a[i] + 1;
           else k++, now = a[i];
       }
       return k <= m;
   }
   ```

3. **题解作者：Allen_yang**  
   **星级：★★★★☆**  
   **关键亮点**：代码结构清晰，二分查找和贪心模拟的实现较为简洁。  
   **核心代码**：
   ```cpp
   bool check(ll le) {
       ll cnt = 1, sum = -1;
       for (int i = 1; i <= n; i++) {
           sum += len[i] + 1;
           if (sum > le) {
               cnt++;
               sum = len[i];
           }
           if (cnt > m) return false;
       }
       return true;
   }
   ```

### 拓展与举一反三

1. **类似题目**：
   - [P1181 数列分段 I](https://www.luogu.com.cn/problem/P1181)
   - [P1182 数列分段 II](https://www.luogu.com.cn/problem/P1182)
   - [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)

2. **调试与心得**：
   - **调试经历**：在模拟过程中，容易忽略行末的空格处理，导致行数计算错误。
   - **踩坑教训**：二分查找的边界条件需仔细处理，避免陷入死循环。
   - **顿悟感想**：贪心策略在模拟单词排列时非常有效，能够快速计算所需行数。

---
处理用时：44.48秒
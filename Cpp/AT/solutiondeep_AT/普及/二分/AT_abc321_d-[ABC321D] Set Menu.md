# 题目信息

# [ABC321D] Set Menu

## 题目描述

餐厅里有 $N$ 个主菜和 $M$ 个副菜，第 $i$ 个主菜的价格为 $A_i$，第 $j$ 个副菜的价格是 $B_j$。餐厅现在要推出一些套餐，每个套餐均由一道主菜和一道副菜组成，对于一个由第 $i$ 个主菜和第 $j$ 个副菜组成的套餐，我们定义 $s=A_i+B_j$，那么这个套餐的价格即为 $\min (s,P)$，$P$ 为一个给定的常数。

请你求出所有可能的套餐的价格总和。

------------

## 样例 #1

### 输入

```
2 2 7

3 5

6 1```

### 输出

```
24```

## 样例 #2

### 输入

```
1 3 2

1

1 1 1```

### 输出

```
6```

## 样例 #3

### 输入

```
7 12 25514963

2436426 24979445 61648772 23690081 33933447 76190629 62703497

11047202 71407775 28894325 31963982 22804784 50968417 30302156 82631932 61735902 80895728 23078537 7723857```

### 输出

```
2115597124```

# AI分析结果

### 题目内容重写
餐厅里有 $N$ 个主菜和 $M$ 个副菜，第 $i$ 个主菜的价格为 $A_i$，第 $j$ 个副菜的价格是 $B_j$。餐厅现在要推出一些套餐，每个套餐均由一道主菜和一道副菜组成，对于一个由第 $i$ 个主菜和第 $j$ 个副菜组成的套餐，我们定义 $s=A_i+B_j$，那么这个套餐的价格即为 $\min (s,P)$，$P$ 为一个给定的常数。

请你求出所有可能的套餐的价格总和。

### 题解综合分析与结论
本题的核心在于如何高效计算所有套餐的价格总和。由于直接暴力枚举的时间复杂度为 $O(NM)$，无法通过大数据的测试。因此，大多数题解都采用了排序、前缀和与二分查找的优化策略，将时间复杂度降低到 $O(N \log M)$ 或 $O(M \log N)$。

### 高星题解推荐

#### 1. 作者：Mr_Gengar (赞：12)
**星级：5星**
**关键亮点：**
- 思路清晰，详细解释了如何通过二分查找将问题分解为两部分，分别计算贡献。
- 代码简洁，使用了 `upper_bound` 进行二分查找，并利用前缀和优化计算。
- 时间复杂度为 $O(N \log M)$，效率高。

**核心代码：**
```cpp
sort(a + 1, a + n + 1);
for (int i = 1; i <= n; i++) {
    pre[i] = pre[i - 1] + a[i];
}
for (int i = 1; i <= m; i++) {
    x = upper_bound(a + 1, a + n + 1, p - b[i]) - a;
    sum += pre[x - 1] + b[i] * (x - 1) + (n - x + 1) * p;
}
```
**核心思想：** 对主菜数组排序并计算前缀和，然后对每个副菜进行二分查找，确定其与主菜组合的价格贡献。

#### 2. 作者：cjh20090318 (赞：1)
**星级：4星**
**关键亮点：**
- 思路清晰，详细解释了如何通过二分查找和前缀和优化计算。
- 代码简洁，使用了 `lower_bound` 进行二分查找，并利用前缀和优化计算。
- 时间复杂度为 $O(N \log M)$，效率高。

**核心代码：**
```cpp
sort(b+1,b+m+1);
for(int i=1;i<=m;i++) s[i]=s[i-1]+b[i];
for(int i=1,x;i<=n;i++){
    x=lower_bound(b+1,b+m+1,p-a[i])-b;
    ans+=(LL)a[i]*(x-1)+s[x-1]+(LL)p*(m-x+1);
}
```
**核心思想：** 对副菜数组排序并计算前缀和，然后对每个主菜进行二分查找，确定其与副菜组合的价格贡献。

#### 3. 作者：xiaomuyun (赞：1)
**星级：4星**
**关键亮点：**
- 提供了两种正解做法，分别基于二分查找和双指针，思路清晰。
- 代码简洁，使用了 `lower_bound` 进行二分查找，并利用前缀和优化计算。
- 时间复杂度为 $O(N \log M)$，效率高。

**核心代码：**
```cpp
sort(b + 1, b + m + 1);
for(int i = 1; i <= m; i++) sum[i] = sum[i - 1] + b[i];
for(int i = 1, cur = m; i <= n; i++){
    while(cur > 0 && a[i] + b[cur] > p) --cur;
    res += sum[cur] + cur * a[i] + (m - cur) * p;
}
```
**核心思想：** 对副菜数组排序并计算前缀和，然后对每个主菜进行双指针查找，确定其与副菜组合的价格贡献。

### 最优关键思路或技巧
1. **排序与二分查找**：通过排序和二分查找，将问题分解为两部分，分别计算贡献，时间复杂度从 $O(NM)$ 降低到 $O(N \log M)$。
2. **前缀和优化**：利用前缀和快速计算部分和，避免重复计算，进一步优化时间复杂度。
3. **双指针**：在某些情况下，使用双指针可以进一步优化时间复杂度，减少二分查找的次数。

### 可拓展之处
- **类似问题**：类似的问题可以出现在需要计算两两组合的贡献时，如计算两数之和的某种函数值（如最小值、最大值等）。
- **算法套路**：排序、前缀和、二分查找、双指针等技巧在解决组合问题时非常常见，掌握这些技巧可以举一反三。

### 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得摘录
- **调试经历**：部分题解提到在调试过程中遇到了未开 `long long` 导致的错误，提醒我们在处理大数时要注意数据类型的选择。
- **顿悟感想**：通过排序和二分查找，将问题分解为两部分，分别计算贡献，这种思路在解决组合问题时非常有效。

---
处理用时：47.28秒
# 题目信息

# [ABC341D] Only one of two

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc341/tasks/abc341_d

正整数 $ N $, $ M $, $ K $ が与えられます。ここで、$ N $ と $ M $ は異なります。  
正の整数であって、$ N $ と $ M $ のうち **ちょうど一方のみ** で割り切れる数のうち小さい方から $ K $ 番目のものを出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N,\ M\leq\ 10^8 $
- $ 1\leq\ K\leq\ 10^{10} $
- $ N\neq\ M $
- $ N $, $ M $, $ K $ は整数

### Sample Explanation 1

$ 2 $ と $ 3 $ のうちちょうど一方のみで割り切れる正整数は小さい方から順に $ 2,3,4,8,9,10,\ldots $ です。 ここで、$ 6 $ は $ 2 $ と $ 3 $ の両方で割り切れるため条件をみたさないことに注意してください。 条件をみたす正整数のうち小さい方から $ 5 $ 番目の数は $ 9 $ であるため、$ 9 $ を出力します。

### Sample Explanation 2

条件をみたす数は小さい方から順に $ 1,3,5,7,\ldots $ です。

## 样例 #1

### 输入

```
2 3 5```

### 输出

```
9```

## 样例 #2

### 输入

```
1 2 3```

### 输出

```
5```

## 样例 #3

### 输入

```
100000000 99999999 10000000000```

### 输出

```
500000002500000000```

# AI分析结果

### 题目内容重写

【题目描述】

给定三个正整数 $N$、$M$、$K$，其中 $N$ 和 $M$ 不相同。请找出第 $K$ 个满足以下条件的正整数：该数能被 $N$ 和 $M$ 中的**恰好一个**整除。

【说明/提示】

### 约束

- $1 \leq N, M \leq 10^8$
- $1 \leq K \leq 10^{10}$
- $N \neq M$
- $N$、$M$、$K$ 为整数

### 样例解释 1

$2$ 和 $3$ 的倍数中，恰好被其中一个整除的正整数从小到大依次为 $2,3,4,8,9,10,\ldots$。注意，$6$ 能被 $2$ 和 $3$ 同时整除，因此不符合条件。符合条件的第 $5$ 个数是 $9$，因此输出 $9$。

### 样例解释 2

符合条件的数从小到大依次为 $1,3,5,7,\ldots$。

### 样例 #1

#### 输入

```
2 3 5
```

#### 输出

```
9
```

### 样例 #2

#### 输入

```
1 2 3
```

#### 输出

```
5
```

### 样例 #3

#### 输入

```
100000000 99999999 10000000000
```

#### 输出

```
500000002500000000
```

---

### 题解分析与结论

#### 关键思路与技巧

1. **二分查找**：大多数题解采用了二分查找的思路，通过二分答案来找到第 $K$ 个符合条件的数。这种方法的核心在于如何高效地计算某个数 $x$ 之前有多少个符合条件的数。
2. **容斥原理**：计算 $x$ 之前符合条件的数的数量时，使用了容斥原理。具体公式为：$\lfloor \frac{x}{N} \rfloor + \lfloor \frac{x}{M} \rfloor - 2 \times \lfloor \frac{x}{\text{lcm}(N, M)} \rfloor$，其中 $\text{lcm}(N, M)$ 是 $N$ 和 $M$ 的最小公倍数。
3. **周期性优化**：部分题解利用了周期性优化，通过计算每个周期内符合条件的数的数量，减少了计算量。

#### 最优题解推荐

1. **题解作者：midsummer_zyl**  
   - **评分：5星**  
   - **关键亮点**：思路清晰，代码简洁，使用了二分查找和容斥原理，时间复杂度为 $O(\log n)$，适合大规模数据。  
   - **代码核心思想**：通过二分查找确定第 $K$ 个符合条件的数，使用容斥原理计算某个数 $x$ 之前符合条件的数的数量。
   ```cpp
   inline LL check(LL mid) {
       LL sum = mid / n + mid / m - mid / x * 2;
       return sum < k;
   }
   ```

2. **题解作者：Shunpower**  
   - **评分：4.5星**  
   - **关键亮点**：代码结构清晰，使用了二分查找和容斥原理，时间复杂度为 $O(\log n)$，适合大规模数据。  
   - **代码核心思想**：通过二分查找确定第 $K$ 个符合条件的数，使用容斥原理计算某个数 $x$ 之前符合条件的数的数量。
   ```cpp
   ll check(ll x) {
       return x / n + x / m - x / lcm * 2;
   }
   ```

3. **题解作者：wly09**  
   - **评分：4星**  
   - **关键亮点**：代码简洁，使用了二分查找和容斥原理，时间复杂度为 $O(\log n)$，适合大规模数据。  
   - **代码核心思想**：通过二分查找确定第 $K$ 个符合条件的数，使用容斥原理计算某个数 $x$ 之前符合条件的数的数量。
   ```cpp
   ull count(ull x) {
       return x / n + x / m - x / lcm * 2;
   }
   ```

#### 扩展思路与推荐题目

1. **扩展思路**：本题的二分查找和容斥原理可以推广到其他类似的计数问题中，尤其是需要找到第 $K$ 个满足某种条件的数时，二分查找是一种非常有效的方法。
2. **推荐题目**：
   - [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)：二分查找的应用。
   - P1443 马的遍历：二分查找与容斥原理的结合。
   - P2678 跳石头：二分查找的应用。

#### 个人心得总结

- **调试经历**：在实现二分查找时，需要注意边界条件的处理，尤其是当 $K$ 较大时，容易溢出或计算错误。
- **踩坑教训**：在计算最小公倍数时，需要确保使用 `__gcd` 函数来避免精度问题。
- **顿悟感想**：二分查找结合容斥原理是解决此类问题的有效方法，关键在于如何高效地计算某个数之前符合条件的数的数量。

---
处理用时：47.17秒
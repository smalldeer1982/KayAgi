# 题目信息

# [ABC364D] K-th Nearest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc364/tasks/abc364_d

数直線上に $ N+Q $ 個の点 $ A_1,\dots,A_N,B_1,\dots,B_Q $ があり、点 $ A_i $ の座標は $ a_i $、点 $ B_j $ の座標は $ b_j $ です。

$ j=1,2,\dots,Q $ それぞれについて、以下の問題に答えてください。

- 点 $ A_1,A_2,\dots,A_N $ のうち点 $ B_j $ との距離が $ k_j $ 番目に近い点を $ X $ としたとき、点 $ X $ と点 $ B_j $ との距離を求めよ。 より厳密には、点 $ A_i $ と点 $ B_j $ との距離を $ d_i $ として、$ (d_1,d_2,\dots,d_N) $ を昇順に並び替えてできる列を $ (d_1',d_2',\dots,d_N') $ としたとき、$ d_{k_j}' $ を求めよ。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\ \leq\ 10^5 $
- $ -10^8\leq\ a_i,b_j\ \leq\ 10^8 $
- $ 1\leq\ k_j\leq\ N $
- 入力は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のクエリについて説明します。 点 $ A_1,A_2,A_3,A_4 $ と点 $ B_1 $ との距離は順に $ 1,1,7,8 $ なので、点 $ B_1 $ との距離が $ 3 $ 番目に近いのは点 $ A_3 $ です。 よって、点 $ A_3 $ と点 $ B_1 $ との距離である $ 7 $ を出力します。

### Sample Explanation 2

同じ座標に複数の点がある可能性もあります。

## 样例 #1

### 输入

```
4 3

-3 -1 5 6

-2 3

2 1

10 4```

### 输出

```
7

3

13```

## 样例 #2

### 输入

```
2 2

0 0

0 1

0 2```

### 输出

```
0

0```

## 样例 #3

### 输入

```
10 5

-84 -60 -41 -100 8 -8 -52 -62 -61 -76

-52 5

14 4

-2 6

46 2

26 7```

### 输出

```
11

66

59

54

88```

# AI分析结果

### 题目内容重写

【题目描述】

数直线上有 $N+Q$ 个点 $A_1,\dots,A_N,B_1,\dots,B_Q$，点 $A_i$ 的坐标是 $a_i$，点 $B_j$ 的坐标是 $b_j$。

对于每个 $j=1,2,\dots,Q$，回答以下问题：

- 设 $X$ 是点 $A_1,A_2,\dots,A_N$ 中与点 $B_j$ 的距离第 $k_j$ 近的点，求点 $X$ 与点 $B_j$ 之间的距离。更严格地说，设 $d_i$ 为点 $A_i$ 与点 $B_j$ 之间的距离，将 $(d_1,d_2,\dots,d_N)$ 按升序排列得到序列 $(d_1',d_2',\dots,d_N')$，求 $d_{k_j}'$。

【说明/提示】

### 制約

- $1\leq\ N,Q\ \leq\ 10^5$
- $-10^8\leq\ a_i,b_j\ \leq\ 10^8$
- $1\leq\ k_j\leq\ N$
- 输入均为整数

### 样例解释 1

对于第一个查询，点 $A_1,A_2,A_3,A_4$ 与点 $B_1$ 的距离分别为 $1,1,7,8$，因此与点 $B_1$ 距离第 $3$ 近的点是 $A_3$，输出 $7$。

### 样例解释 2

可能存在多个点位于同一坐标。

### 样例 #1

#### 输入

```
4 3

-3 -1 5 6

-2 3

2 1

10 4
```

#### 输出

```
7

3

13
```

### 样例 #2

#### 输入

```
2 2

0 0

0 1

0 2
```

#### 输出

```
0

0
```

### 样例 #3

#### 输入

```
10 5

-84 -60 -41 -100 8 -8 -52 -62 -61 -76

-52 5

14 4

-2 6

46 2

26 7
```

#### 输出

```
11

66

59

54

88
```

### 题解分析与结论

#### 综合分析

本题的核心问题是在数轴上找到与给定点 $B_j$ 距离第 $k_j$ 近的点 $A_i$，并输出其距离。由于 $N$ 和 $Q$ 的范围都达到了 $10^5$，直接暴力求解显然不可行。因此，大多数题解都采用了**二分查找**的策略，结合**排序**和**双指针**等技巧来优化查询效率。

#### 关键思路与技巧

1. **二分查找**：通过二分查找确定与 $B_j$ 距离不超过某个值的点的数量，从而找到第 $k_j$ 近的点。
2. **排序预处理**：将 $A$ 数组排序，便于后续的二分查找操作。
3. **双指针优化**：在二分查找中，使用 `lower_bound` 和 `upper_bound` 来快速计算区间内的点数。
4. **单调性利用**：由于距离具有单调性，可以通过二分查找快速缩小答案范围。

#### 推荐题解

1. **作者：ikunTLE (赞：9)**
   - **星级：5星**
   - **关键亮点**：代码简洁，思路清晰，二分查找的实现非常标准，且对边界处理得当。
   - **核心代码**：
     ```cpp
     int check(int x,int b,int k){
         int l=lower_bound(a+1,a+n+1,b-x)-a;
         int r=upper_bound(a+1,a+n+1,b+x)-a;
         return r-l>=k;
     }
     ```
   - **个人心得**：作者强调了二分右边界要开大，建议 $2\times10^8$，避免边界问题。

2. **作者：Guoguo2013 (赞：5)**
   - **星级：4星**
   - **关键亮点**：详细解释了二分查找的思路，代码可读性强，且对二分查找的细节进行了说明。
   - **核心代码**：
     ```cpp
     int l = 0, r = 1e18;
     while (l < r){
         int mid = l + r >> 1;
         auto r1 = upper_bound(a + 1, a + n + 1, b + mid), l1 = lower_bound(a + 1, a + n + 1, b - mid);
         if (r1 - l1 >= k) r = mid;
         else l = mid + 1;
     }
     ```
   - **个人心得**：作者提到自己不太喜欢用 STL，但为了代码简洁性还是选择了使用 `lower_bound` 和 `upper_bound`。

3. **作者：HeiCat0725 (赞：1)**
   - **星级：4星**
   - **关键亮点**：代码结构清晰，二分查找的实现非常标准，且对边界处理得当。
   - **核心代码**：
     ```cpp
     bool check(int d){
         int la=lower_bound(arr+1,arr+n+1,b-d)-arr;
         int ra=upper_bound(arr+1,arr+n+1,b+d)-arr-1;
         int res=ra-la+1;
         if(res>=k) return 1;
         else return 0;
     }
     ```
   - **个人心得**：作者强调了二分的初始区间要足够大，避免边界问题。

### 扩展思路与推荐题目

#### 扩展思路

- **动态开点线段树**：对于更大范围的数据，可以考虑使用动态开点线段树来优化查询效率。
- **分块处理**：对于某些特殊情况，可以考虑将数据分块处理，减少查询时间。

#### 推荐题目

1. **洛谷 P3369 【模板】普通平衡树**：考察二分查找与平衡树的结合使用。
2. **洛谷 P3382 【模板】三分法**：考察三分查找的应用。
3. **洛谷 P3374 【模板】树状数组 1**：考察树状数组的应用，适合处理区间查询问题。

---
处理用时：60.06秒
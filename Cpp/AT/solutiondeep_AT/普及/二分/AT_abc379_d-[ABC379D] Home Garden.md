# 题目信息

# [ABC379D] Home Garden

## 题目描述

高桥有 $10^{100}$ 个花盆。起初花盆都是空的。

你将有 $Q$ 次操作。有三种类型的操作，如下所示：

- `1`：准备一个空花盆，在里面放一颗植物，植物高度为 $0$。
- `2 T`：等待 $T$ 天。在此期间，所有植物的高度增加了 $T$。
- `3 H`：收割所有高度至少为 $H$ 的植物，并输出符合条件的植物数量，将符合条件的植物从花盆中取出。

假定执行 $1$ 和 $3$ 类型的操作花费时间为 $0$。且**一定会有操作 $3$**。

## 说明/提示

对于 $100\%$ 的数据，$1\le Q\le 2\times10^5$，$1\le T,H\le10^9$。操作 $3$ 的次数大于等于 $1$。

## 样例 #1

### 输入

```
6
1
2 15
1
3 10
2 20
3 20```

### 输出

```
1
1```

## 样例 #2

### 输入

```
15
1
1
2 226069413
3 1
1
1
2 214168203
1
3 214168203
1
1
1
2 314506461
2 245642315
3 1```

### 输出

```
2
2
4```

# AI分析结果

### 题目内容重写

高桥有 $10^{100}$ 个花盆。起初花盆都是空的。

你将有 $Q$ 次操作。有三种类型的操作，如下所示：

- `1`：准备一个空花盆，在里面放一颗植物，植物高度为 $0$。
- `2 T`：等待 $T$ 天。在此期间，所有植物的高度增加了 $T$。
- `3 H`：收割所有高度至少为 $H$ 的植物，并输出符合条件的植物数量，将符合条件的植物从花盆中取出。

假定执行 $1$ 和 $3$ 类型的操作花费时间为 $0$。且**一定会有操作 $3$**。

### 说明/提示

对于 $100\%$ 的数据，$1\le Q\le 2\times10^5$，$1\le T,H\le10^9$。操作 $3$ 的次数大于等于 $1$。

### 样例 #1

#### 输入

```
6
1
2 15
1
3 10
2 20
3 20
```

#### 输出

```
1
1
```

### 样例 #2

#### 输入

```
15
1
1
2 226069413
3 1
1
1
2 214168203
1
3 214168203
1
1
1
2 314506461
2 245642315
3 1
```

#### 输出

```
2
2
4
```

### 题解分析与结论

本题的核心在于如何高效处理三种操作，尤其是操作2（全局增加高度）和操作3（收割高度达到一定值的植物）。大部分题解都采用了类似的思想：通过维护一个全局变量来记录植物的总生长天数，并在插入新植物时记录其插入时的生长天数，从而避免每次操作2都遍历所有植物。收割操作则通过优先队列或二分查找来高效实现。

### 精选题解

#### 题解1：作者：ikunTLE (赞：14) - 评分：5星

**关键亮点**：
- 使用优先队列（大根堆）来维护植物的生长天数，确保每次收割操作都能高效找到符合条件的植物。
- 通过全局变量 `h` 记录植物的总生长天数，避免了每次操作2的遍历。
- 代码简洁，思路清晰，时间复杂度为 $O(Q \log Q)$，完全符合题目要求。

**核心代码**：
```cpp
priority_queue<int> pq;
signed main(){
    int q=read(),h=0;
    while(q--){
        int op=read();
        if(op==1)
            pq.push(-h);
        else if(op==2)
            h+=read();
        else{
            int x=read(),ans=0;
            while(!pq.empty()){
                int temp=pq.top();
                if(temp+h>=x)
                    ++ans,pq.pop();
                else break;
            }
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```

#### 题解2：作者：Nagato__Yuki (赞：13) - 评分：4星

**关键亮点**：
- 使用 `lower_bound` 进行二分查找，确保收割操作的高效性。
- 通过维护一个单调不降的数组，简化了收割操作的实现。
- 代码实现较为简洁，时间复杂度为 $O(Q \log Q)$。

**核心代码**：
```cpp
ll q,a[mxn],head=200000,tail=200000,lazy;
int main(){
    cin>>q;
    while(q--){
        int opt;cin>>opt;
        if(opt==1)a[--head]=-lazy;
        else if(opt==2){
            ll t;cin>>t,lazy+=t;
        }
        else{
            ll h;cin>>h;
            ll pos=lower_bound(a+head,a+tail,h-lazy)-(a+head);
            cout<<tail-head-pos<<'\n',tail=head+pos;
        } 
    }
    return 0;
}
```

#### 题解3：作者：Tairitempest (赞：1) - 评分：4星

**关键亮点**：
- 使用队列维护植物的生长时间，确保每次收割操作都能高效找到符合条件的植物。
- 通过全局变量 `tag` 记录植物的总生长天数，避免了每次操作2的遍历。
- 代码简洁，时间复杂度为 $O(Q)$，效率较高。

**核心代码**：
```cpp
queue<ll> q;
int main(){
    cin>>Q;
    while(Q--){
        cin>>type;
        if(type==1){
            q.push(tag);
        }else if(type==2){
            cin>>T;
            tag+=T;
        }else{
            ll ans=0;
            cin>>H;
            while(tag-q.front()>=H&&not q.empty()){
                ans++;
                q.pop();
            }
            cout<<ans<<endl;
        }
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **全局变量记录生长天数**：通过维护一个全局变量来记录植物的总生长天数，避免了每次操作2的遍历，大大降低了时间复杂度。
2. **优先队列或二分查找**：使用优先队列或二分查找来高效实现收割操作，确保每次操作的时间复杂度为 $O(\log Q)$。
3. **单调性利用**：利用植物的生长天数单调不降的性质，简化了收割操作的实现。

### 可拓展之处

- **类似题目**：可以考虑处理其他需要全局修改和局部查询的问题，如区间修改、区间查询等。
- **数据结构扩展**：可以尝试使用其他数据结构如线段树、树状数组等来处理类似问题。

### 推荐题目

1. [P2827 蚯蚓](https://www.luogu.com.cn/problem/P2827)
2. [P11217 线段树二分](https://www.luogu.com.cn/problem/P11217)
3. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)

### 个人心得摘录

- **调试经历**：在实现优先队列时，需要注意堆顶元素的处理，确保每次都能正确弹出符合条件的植物。
- **踩坑教训**：在处理全局变量时，务必注意变量的初始化和更新时机，避免出现逻辑错误。
- **顿悟感想**：通过维护全局变量和利用单调性，可以大大简化问题的复杂度，提高代码的效率。

---
处理用时：54.19秒
# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

**题目描述**

ビ太郎收到了朋友ビバ子送给他的生日礼物，这是一个由 `J`、`O`、`I` 三种字符组成的长为 $N$ 的字符串 $S$。

定义 $K$ 阶 `JOI` 字符串为由 $K$ 个 `J`，接着是 $K$ 个 `O`，最后是 $K$ 个 `I` 按顺序组成的字符串。例如，`JJOOII` 是 $2$ 阶 `JOI` 字符串。

ビ太郎希望通过以下三种操作将 $S$ 转换为 $K$ 阶 `JOI` 字符串：

1. **操作 1**：删除 $S$ 的第一个字符。
2. **操作 2**：删除 $S$ 的最后一个字符。
3. **操作 3**：删除 $S$ 中既不是第一个也不是最后一个的字符。

由于操作 3 比较麻烦，ビ太郎希望尽量减少操作 3 的次数。请编写程序，计算将 $S$ 转换为 $K$ 阶 `JOI` 字符串所需的最小操作 3 次数。如果无法转换，则输出 `-1`。

**输入格式**

第一行包含两个整数 $N$ 和 $K$，表示字符串 $S$ 的长度和目标阶数。

第二行包含字符串 $S$。

**输出格式**

输出一个整数，表示最小操作 3 次数。如果无法转换，则输出 `-1`。

**样例输入 1**

```
10 2
OJIJOIOIIJ
```

**样例输出 1**

```
2
```

**样例输入 2**

```
9 3
JJJOOOIII
```

**样例输出 2**

```
0
```

**样例输入 3**

```
9 1
IIIOOOJJJ
```

**样例输出 3**

```
-1
```

### 题解分析与结论

#### 综合分析

本题的核心是找到字符串 $S$ 中满足 $K$ 阶 `JOI` 字符串条件的最短子串，并计算需要删除的字符数。大多数题解采用了前缀和与二分查找的结合，或者通过指针维护的方式来高效地找到符合条件的子串。

#### 最优思路与技巧

1. **前缀和与二分查找**：通过前缀和快速计算任意子串中 `J`、`O`、`I` 的数量，结合二分查找确定满足条件的最短子串。
2. **指针维护**：通过维护多个指针，分别指向 `J`、`O`、`I` 的起始和结束位置，减少时间复杂度。
3. **贪心思想**：在找到 `J` 的起始位置后，尽可能快地找到 `O` 和 `I` 的起始位置，以最小化子串长度。

#### 推荐题解

1. **Kano_zyc 的题解**（4星）
   - **关键亮点**：使用前缀和与二分查找结合，思路清晰，代码简洁。
   - **核心代码**：
     ```cpp
     int findMinIndex(int l, int k, int n, int prefixSum[]) {
         int left = l, right = n, ans = n + 1;
         while (left <= right) {
             int mid = left + (right - left) / 2;
             if (prefixSum[mid] - prefixSum[l - 1] >= k) {
                 ans = mid;
                 right = mid - 1;
             } else {
                 left = mid + 1;
             }
         }
         return ans;
     }
     ```

2. **small_turtle 的题解**（4星）
   - **关键亮点**：使用 `lower_bound` 进行二分查找，代码简洁且高效。
   - **核心代码**：
     ```cpp
     int x = lower_bound(J+1, J+n+1, J[i-1]+k)-J;
     int y = lower_bound(O+1, O+n+1, O[x-1]+k)-O;
     int z = lower_bound(I+1, I+n+1, I[y-1]+k)-I;
     ```

3. **saixingzhe 的题解**（4星）
   - **关键亮点**：使用 `vector` 记录字符位置，通过指针维护找到最短子串，时间复杂度为 $O(n)$。
   - **核心代码**：
     ```cpp
     for(int J=0;J<=q[0].size()-k;J++){
         while(O<=q[1].size()-k&&q[0][J+k-1]>q[1][O]) O++;
         while(I<=q[2].size()-k&&q[1][O+k-1]>q[2][I]) I++;
         if(O<=q[1].size()-k&&I<=q[2].size()-k) ans=min(ans,q[2][I+k-1]-q[0][J]+1-3*k);
         else break;
     }
     ```

### 拓展思路与推荐题目

1. **拓展思路**：本题的思路可以推广到其他需要寻找特定模式子串的问题，如寻找特定字符顺序的子串或特定字符数量的子串。
2. **推荐题目**：
   - [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
   - [P3805 【模板】Manacher算法](https://www.luogu.com.cn/problem/P3805)
   - [P4551 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P4551)

---
处理用时：46.20秒
# 题目信息

# [ABC105D] Candy Distribution

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc105/tasks/abc105_d

$ N $ 個の箱が左右一列に並んでおり、左から $ i $ 番目の箱には $ A_i $ 個のお菓子が入っています。

あなたは、連続したいくつかの箱からお菓子を取り出して $ M $ 人の子供たちに均等に配りたいと考えています。

そこで、以下を満たす組 $ (l,\ r) $ の総数を求めてください。

- $ l,\ r $ はともに整数であり $ 1\ \leq\ l\ \leq\ r\ \leq\ N $ を満たす
- $ A_l\ +\ A_{l+1}\ +\ ...\ +\ A_r $ は $ M $ の倍数である

## 说明/提示

### 制約

- 入力は全て整数である
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 2\ \leq\ M\ \leq\ 10^9 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $

### Sample Explanation 1

各組 $ (l,\ r) $ に対する和 $ A_l\ +\ A_{l+1}\ +\ ...\ +\ A_r $ は次のとおりであり、このうち $ 3 $ つが $ 2 $ の倍数です。 - $ (1,\ 1) $ に対する和: $ 4 $ - $ (1,\ 2) $ に対する和: $ 5 $ - $ (1,\ 3) $ に対する和: $ 10 $ - $ (2,\ 2) $ に対する和: $ 1 $ - $ (2,\ 3) $ に対する和: $ 6 $ - $ (3,\ 3) $ に対する和: $ 5 $

## 样例 #1

### 输入

```
3 2

4 1 5```

### 输出

```
3```

## 样例 #2

### 输入

```
13 17

29 7 5 7 9 51 7 13 8 55 42 9 81```

### 输出

```
6```

## 样例 #3

### 输入

```
10 400000000

1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
25```

# AI分析结果

### 题目内容重写
【题目描述】  
有 $N$ 个箱子排成一列，从左到右第 $i$ 个箱子中有 $A_i$ 个糖果。你需要选择一些连续的箱子，将糖果取出并分给 $M$ 个孩子，要求每个孩子分到的糖果数量相同。求满足以下条件的二元组 $(l, r)$ 的总数：  
- $l, r$ 为整数，且 $1 \leq l \leq r \leq N$  
- $A_l + A_{l+1} + \dots + A_r$ 是 $M$ 的倍数  

【说明/提示】  
- 输入均为整数  
- $1 \leq N \leq 10^5$  
- $2 \leq M \leq 10^9$  
- $1 \leq A_i \leq 10^9$  

【样例输入1】  
```
3 2
4 1 5
```
【样例输出1】  
```
3
```

### 题解分析与结论
所有题解的核心思路都是利用前缀和和模运算的性质，将问题转化为求前缀和数组中相同余数的组合数。具体步骤如下：
1. 计算前缀和数组 $S$，并对每个前缀和取模 $M$。
2. 使用 `map` 或 `unordered_map` 记录每个余数出现的次数。
3. 遍历前缀和数组，统计相同余数的组合数。

#### 最优思路与技巧
- **前缀和 + 模运算**：通过前缀和将区间和问题转化为单点问题，再利用模运算将问题转化为求相同余数的组合数。
- **哈希表优化**：使用 `map` 或 `unordered_map` 记录余数出现的次数，避免暴力枚举。
- **初始化技巧**：将 $S_0$ 初始化为 $1$，以处理从第一个元素开始的区间。

### 评分较高的题解
#### 1. 作者：heyx0201 (4星)
**关键亮点**：  
- 思路清晰，代码简洁，直接使用 `map` 记录余数出现的次数。
- 初始化 $S_0$ 为 $1$，处理从第一个元素开始的区间。

**核心代码**：
```cpp
map<long long, int> cnt;
long long sum, ans;
cnt[0] = 1;
for (int i = 1; i <= n; i++) {
    cin >> x;
    sum += x;
    ans += cnt[sum % m];
    cnt[sum % m]++;
}
```

#### 2. 作者：qwerty12346 (4星)
**关键亮点**：  
- 代码简洁，逻辑清晰，直接使用 `map` 记录余数出现的次数。
- 初始化 $S_0$ 为 $1$，处理从第一个元素开始的区间。

**核心代码**：
```cpp
map<int, int> mp;
mp[0] = 1;
for (int i = 1; i <= n; i++) {
    cin >> x;
    sum = (sum + x) % m;
    ret += mp[sum];
    mp[sum]++;
}
```

#### 3. 作者：Jerrywang09 (4星)
**关键亮点**：  
- 思路清晰，代码简洁，使用 `unordered_map` 优化查询效率。
- 初始化 $S_0$ 为 $1$，处理从第一个元素开始的区间。

**核心代码**：
```cpp
unordered_map<int, int> mp;
mp[0]++;
rep(i, 1, n) {
    a[i] = (a[i] + a[i - 1]) % m;
    ans += mp[a[i]];
    mp[a[i]]++;
}
```

### 扩展思路与推荐题目
**扩展思路**：  
- 类似问题可以通过前缀和和模运算转化为哈希表统计问题，如求区间和等于某个固定值、区间和满足某种条件等。

**推荐题目**：  
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)  
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)  
3. [P2424 区间和](https://www.luogu.com.cn/problem/P2424)

---
处理用时：31.67秒
# 题目信息

# [ABC253E] Distance Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc253/tasks/abc253_e

長さ $ N $ の整数からなる数列 $ A=(A_1,\ldots,A_N) $ であって、以下の条件を全て満たすものは何通りありますか？

- $ 1\le\ A_i\ \le\ M $ $ (1\ \le\ i\ \le\ N) $
- $ |A_i\ -\ A_{i+1}|\ \geq\ K $ $ (1\ \le\ i\ \le\ N\ -\ 1) $

ただし、答えは非常に大きくなることがあるので、答えを $ 998244353 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ M\ \leq\ 5000 $
- $ 0\ \leq\ K\ \leq\ M-1 $
- 入力は全て整数

### Sample Explanation 1

条件を満たす数列は以下の $ 6 $ つです。 - $ (1,2) $ - $ (1,3) $ - $ (2,1) $ - $ (2,3) $ - $ (3,1) $ - $ (3,2) $

### Sample Explanation 2

条件を満たす数列は以下の $ 2 $ つです。 - $ (1,3,1) $ - $ (3,1,3) $

### Sample Explanation 3

答えを $ 998244353 $ で割った余りを出力してください。

## 样例 #1

### 输入

```
2 3 1```

### 输出

```
6```

## 样例 #2

### 输入

```
3 3 2```

### 输出

```
2```

## 样例 #3

### 输入

```
100 1000 500```

### 输出

```
657064711```

# AI分析结果

【题目内容】
# [ABC253E] Distance Sequence

## 题目描述

给定三个整数 $n$、$m$ 和 $k$，求有多少个序列 $a_n$ 满足以下条件：

- 对于 $1 \leqslant i \leqslant n$，$1 \leqslant a_i \leqslant m$。
- 对于 $1 < i \leqslant n$，$\left\vert a_i - a_{i - 1} \right\vert \geqslant k$。

**答案对 $998244353$ 取模。**

## 说明/提示

### 制約

- $2\ \leq\ N\ \leq\ 1000 $
- $1\ \leq\ M\ \leq\ 5000 $
- $0\ \leq\ K\ \leq\ M-1 $
- 输入均为整数

### 样例解释

**样例1**  
输入：`2 3 1`  
输出：`6`  
解释：满足条件的数列有：$(1,2)$、$(1,3)$、$(2,1)$、$(2,3)$、$(3,1)$、$(3,2)$。

**样例2**  
输入：`3 3 2`  
输出：`2`  
解释：满足条件的数列有：$(1,3,1)$、$(3,1,3)$。

**样例3**  
输入：`100 1000 500`  
输出：`657064711`

【题解分析与结论】

本题的核心是动态规划（DP）与前缀和优化。所有题解均采用了DP的思路，并利用前缀和优化将时间复杂度从$O(nm^2)$降低到$O(nm)$。以下是各题解的要点总结与对比：

1. **DP状态定义**：所有题解都定义了$f_{i,j}$表示长度为$i$且以$j$结尾的合法序列数。
2. **转移方程**：基本思路是$f_{i,j}$由$f_{i-1,l}$转移而来，其中$l$满足$|j-l| \geq k$。通过前缀和优化，避免了双重循环。
3. **特判$k=0$**：当$k=0$时，$f_{i,j}$会被重复计算，因此需要减去$f_{i-1,j}$。
4. **前缀和优化**：通过维护前缀和数组，将区间求和操作优化为$O(1)$。

【评分较高的题解】

1. **作者：Hog_Dawa_IOI (4星)**
   - **关键亮点**：详细解释了前缀和优化的思路，并特别指出了$k=0$时的处理方式。
   - **代码实现**：使用了二维数组$f$和$qz$分别存储DP状态和前缀和，代码清晰易读。
   - **核心代码**：
     ```cpp
     for(int i=2;i<=n;i++) for(int j=1;j<=m;j++)
     {
         if(j-k>=1) f[i][j]=(f[i][j]+qz[i-1][j-k])%998244353;
         if(j+k<=m) f[i][j]=(f[i][j]+qz[i-1][m]-qz[i-1][j+k-1]+998244353)%998244353;
         if(k==0) f[i][j]=(f[i][j]-f[i-1][j]+998244353)%998244353;
         qz[i][j]=(qz[i][j-1]+f[i][j])%998244353;
     }
     ```

2. **作者：DengDuck (4星)**
   - **关键亮点**：简洁明了地描述了DP状态转移方程，并强调了前缀和优化的必要性。
   - **代码实现**：使用二维数组$f$和$sum$分别存储DP状态和前缀和，代码结构清晰。
   - **核心代码**：
     ```cpp
     for(int i=2;i<=n;i++)
     {
         for(int j=1;j<=m;j++)
         {
             LL l=max(1ll,j-k+1),r=min(j+k-1,m);
             LL t=sum[i-1][r]-sum[i-1][l-1];
             if(l>r)t=0;
             f[i][j]=((sum[i-1][m]-t)%mod+mod)%mod;
             sum[i][j]=(sum[i][j-1]+f[i][j])%mod;
         }
     }
     ```

3. **作者：wnsyou (4星)**
   - **关键亮点**：详细解释了DP状态转移方程，并特别指出了$k=0$时的处理方式。
   - **代码实现**：使用二维数组$dp$和$sum$分别存储DP状态和前缀和，代码结构清晰。
   - **核心代码**：
     ```cpp
     for(int i=2;i<=n;i++)
     {
         for(int j=1;j<=m;j++)
         {
             if(k==0) dp[j] = sum[m];
             else
             {
                 dp[j] = 0;
                 if(j > k) dp[j] = sum[j - k];
                 if(j + k <= m) dp[j] = (dp[j] + num[j + k]) % mod;
             }
         }
         for(int j=1;j<=m;j++) sum[j] = (sum[j - 1] + dp[j]) % mod;
     }
     ```

【最优关键思路与技巧】

1. **前缀和优化**：通过维护前缀和数组，将区间求和操作优化为$O(1)$，显著降低了时间复杂度。
2. **特判$k=0$**：当$k=0$时，$f_{i,j}$会被重复计算，因此需要减去$f_{i-1,j}$，避免重复计数。

【拓展思路与类似题目】

1. **类似题目**：
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的背包问题，同样可以使用DP与优化技巧。
   - [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：涉及DP与状态转移的优化。
   - [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)：涉及序列的DP问题，与本题类似。

【个人心得摘录】

- **Hog_Dawa_IOI**：提到自己在校内模拟赛中首次解决这类DP问题，感到自豪，强调了前缀和优化的重要性。
- **wnsyou**：详细解释了DP状态转移方程，并特别指出了$k=0$时的处理方式，强调了特判的必要性。

【总结】

本题的核心在于动态规划与前缀和优化，通过合理定义状态和转移方程，并利用前缀和优化，可以显著降低时间复杂度。特判$k=0$的情况是本题的一个关键点，避免重复计数。

---
处理用时：50.15秒
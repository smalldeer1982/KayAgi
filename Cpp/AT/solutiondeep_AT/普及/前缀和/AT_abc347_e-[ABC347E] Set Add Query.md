# 题目信息

# [ABC347E] Set Add Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc347/tasks/abc347_e

全ての要素が $ 0 $ で初期化された長さ $ N $ の整数列 $ A=(A_1,A_2,\ldots,A_N) $ があります。また、集合 $ S $ があります。はじめ $ S $ は空です。

以下の $ Q $ 個のクエリを順に行います。$ Q $ 個のクエリを全て処理した後の数列 $ A $ の各要素の値を求めてください。 $ i $ 番目のクエリは以下の形式です。

- 整数 $ x_i $ が与えられる。整数 $ x_i $ が $ S $ に含まれる場合、$ S $ から $ x_i $ を削除する。そうでない場合、$ S $ に $ x_i $ を追加する。次に、$ j=1,2,\ldots,N $ について、$ j\in\ S $ ならば $ A_j $ に $ |S| $ を加算する。

なお、$ |S| $ は集合 $ S $ の要素数を意味します。例えば $ S=\lbrace\ 3,4,7\rbrace $ のとき、$ |S|=3 $ です。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\leq\ 2\times10^5 $
- $ 1\leq\ x_i\leq\ N $
- 入力される数値は全て整数

### Sample Explanation 1

$ 1 $ 番目のクエリでは、$ S $ に $ 1 $ を追加し、$ S=\lbrace\ 1\rbrace $ となります。その後、$ A_1 $ に $ |S|=1 $ を加算します。$ A=(1,0,0) $ となります。 $ 2 $ 番目のクエリでは、$ S $ に $ 3 $ を追加し、$ S=\lbrace\ 1,3\rbrace $ となります。その後、$ A_1,A_3 $ に $ |S|=2 $ を加算します。$ A=(3,0,2) $ となります。 $ 3 $ 番目のクエリでは、$ S $ から $ 3 $ を削除し、$ S=\lbrace\ 1\rbrace $ となります。その後、$ A_1 $ に $ |S|=1 $ を加算します。$ A=(4,0,2) $ となります。 $ 4 $ 番目のクエリでは、$ S $ に $ 2 $ を追加し、$ S=\lbrace\ 1,2\rbrace $ となります。その後、$ A_1,A_2 $ に $ |S|=2 $ を加算します。$ A=(6,2,2) $ となります。 最終的に、$ A=(6,2,2) $ となります。

## 样例 #1

### 输入

```
3 4
1 3 3 2```

### 输出

```
6 2 2```

## 样例 #2

### 输入

```
4 6
1 2 3 2 4 2```

### 输出

```
15 9 12 7```

# AI分析结果

### 题目内容重写

【题目描述】
有一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\ldots,A_N)$，所有元素的初始值都为 $0$。此外，还有一个初始为空的集合 $S$。

依次执行以下 $Q$ 个查询。在处理完所有 $Q$ 个查询后，输出序列 $A$ 中每个元素的值。第 $i$ 个查询的形式如下：

- 给定一个整数 $x_i$。如果 $x_i$ 在 $S$ 中，则从 $S$ 中删除 $x_i$；否则，将 $x_i$ 加入 $S$。然后，对于 $j=1,2,\ldots,N$，如果 $j\in S$，则将 $A_j$ 加上 $|S|$，其中 $|S|$ 表示集合 $S$ 的元素个数。

【说明/提示】
- $1\leq N,Q\leq 2\times10^5$
- $1\leq x_i\leq N$
- 输入的所有数值均为整数

【样例解释】
- 样例1：
  - 输入：`3 4`  
            `1 3 3 2`
  - 输出：`6 2 2`
- 样例2：
  - 输入：`4 6`  
            `1 2 3 2 4 2`
  - 输出：`15 9 12 7`

---

### 题解分析与结论

本题的核心在于如何高效地处理集合 $S$ 的插入和删除操作，并快速计算每个元素 $A_j$ 的最终值。直接模拟每次操作的时间复杂度为 $O(NQ)$，无法通过本题。因此，大多数题解采用了前缀和、差分、或记录时间戳等优化手段，将时间复杂度降低到 $O(N+Q)$。

#### 关键思路与技巧
1. **前缀和优化**：通过记录每次操作后集合 $S$ 的大小 $|S|$ 的前缀和，可以在 $O(1)$ 时间内计算某个元素在集合中的贡献。
2. **时间戳记录**：记录每个元素加入和离开集合的时间点，利用前缀和快速计算其在集合中的总贡献。
3. **差分思想**：通过差分数组记录集合大小的变化，避免每次操作时遍历所有元素。

#### 推荐题解

1. **作者：fedoralxy**（★★★★★）
   - **亮点**：使用前缀和和时间戳记录，思路清晰，代码简洁。
   - **核心代码**：
     ```cpp
     for(int step=1;step<=q;++step){
         ll x;
         cin>>x;
         if(!t[x]){
             ans[x].l=step;
             t[x]=1;
             ++len;
         }
         else{
             ans[x].v+=val[step-1]-val[ans[x].l-1];
             ans[x].l=-1;
             --len;
             t[x]=0;
         }
         val[step]=val[step-1]+len;
     }
     ```
   - **个人心得**：通过记录每个元素的加入和离开时间，利用前缀和快速计算贡献，避免了重复计算。

2. **作者：DGH_Didi**（★★★★☆）
   - **亮点**：使用 `std::set` 维护集合，结合前缀和计算贡献，代码可读性强。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=q;i++){
         cin>>a[i];
         if(s.find(a[i])==s.end()) s.insert(a[i]);
         else s.erase(a[i]);
         his[a[i]].push_back(i);
         siz[i]=s.size();
         sum[i]=sum[i-1]+siz[i];
     }
     ```
   - **个人心得**：通过 `std::set` 的插入和删除操作，结合前缀和快速计算每个元素的贡献，代码实现较为直观。

3. **作者：lilong**（★★★★☆）
   - **亮点**：使用差分思想优化集合大小的计算，结合前缀和快速求解。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=m;i++){
         cin>>x[i];
         if(pd[x[i]]) s[i]--,pd[x[i]]=0;
         else s[i]++,pd[x[i]]=1;
         s[i]+=s[i-1];
     }
     ```
   - **个人心得**：通过差分数组记录集合大小的变化，避免每次操作时遍历所有元素，提升了效率。

#### 拓展思路
- **类似题目**：本题的优化思路可以应用于其他需要动态维护集合大小并快速计算贡献的题目，如区间更新、动态统计等。
- **推荐题目**：
  1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
  2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
  3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

#### 个人心得总结
- **调试经历**：在处理集合大小变化时，容易出现边界条件错误，如元素最后一次操作后仍在集合中，需要特别处理。
- **踩坑教训**：未使用 `long long` 类型存储前缀和，导致溢出错误。
- **顿悟感想**：通过前缀和优化，将原本复杂的操作简化为 $O(1)$ 计算，极大提升了代码效率。

---
处理用时：43.45秒
# 题目信息

# [ABC371D] 1D Country

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_d

数直線上に $ N $ 個の村があります。$ i $ 番目の村は座標 $ X_i $ にあり、$ P_i $ 人の村人がいます。

$ Q $ 個のクエリに答えてください。$ i $ 番目のクエリは以下の形式です。

- 整数 $ L_i,R_i $ が与えられる。座標が $ L_i $ 以上 $ R_i $ 以下の村に住んでいる村人の人数の総数を求めよ。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\leq\ 2\times\ 10^5 $
- $ -10^9\leq\ X_1\ <\ X_2\ <\ \ldots\ <\ X_N\ \leq\ 10^9 $
- $ 1\leq\ P_i\leq\ 10^9 $
- $ -10^9\leq\ L_i\ \leq\ R_i\ \leq\ 10^9 $
- 入力される数値は全て整数

### Sample Explanation 1

$ 1 $ 番目のクエリについて考えます。座標が $ 1 $ 以上 $ 1 $ 以下の村は、座標 $ 1 $ にある村で、村人は $ 1 $ 人います。よって答えは $ 1 $ です。 $ 2 $ 番目のクエリについて考えます。座標が $ 2 $ 以上 $ 6 $ 以下の村は、座標 $ 3 $ にある村と座標 $ 5 $ にある村で、村人はそれぞれ $ 2 $ 人と $ 3 $ 人います。よって答えは $ 2+3=5 $ です。

## 样例 #1

### 输入

```
4
1 3 5 7
1 2 3 4
4
1 1
2 6
0 10
2 2```

### 输出

```
1
5
10
0```

## 样例 #2

### 输入

```
7
-10 -5 -3 -1 0 1 4
2 5 6 5 2 1 7
8
-7 7
-1 5
-10 -4
-8 10
-5 0
-10 5
-8 7
-8 -3```

### 输出

```
26
15
7
26
18
28
26
11```

# AI分析结果

### 题目翻译
在数轴上有 $N$ 个村庄，第 $i$ 个村庄位于坐标 $X_i$，并且有 $P_i$ 个村民。现在有 $Q$ 个查询，每个查询给出两个整数 $L_i$ 和 $R_i$，要求计算位于 $[L_i, R_i]$ 区间内的所有村庄的村民总数。

### 说明/提示
#### 约束条件
- $1 \leq N, Q \leq 2 \times 10^5$
- $-10^9 \leq X_1 < X_2 < \ldots < X_N \leq 10^9$
- $1 \leq P_i \leq 10^9$
- $-10^9 \leq L_i \leq R_i \leq 10^9$
- 输入的所有数值均为整数

### 样例输入输出
#### 样例 #1
**输入：**
```
4
1 3 5 7
1 2 3 4
4
1 1
2 6
0 10
2 2
```
**输出：**
```
1
5
10
0
```

#### 样例 #2
**输入：**
```
7
-10 -5 -3 -1 0 1 4
2 5 6 5 2 1 7
8
-7 7
-1 5
-10 -4
-8 10
-5 0
-10 5
-8 7
-8 -3
```
**输出：**
```
26
15
7
26
18
28
26
11
```

### 题解分析与结论
#### 综合分析
该题的核心问题是在数轴上进行区间查询，计算区间内的村民总数。由于村庄的坐标范围非常大（$-10^9$ 到 $10^9$），直接使用前缀和或树状数组等数据结构会面临内存和时间上的挑战。因此，大多数题解采用了离散化结合二分查找的方法，通过将查询区间映射到村庄的索引范围内，再利用前缀和快速计算区间和。

#### 关键思路与技巧
1. **离散化**：由于村庄的坐标范围很大，但村庄的数量有限，因此可以将所有查询的边界和村庄坐标一起进行离散化处理，将坐标映射到一个较小的范围内，从而减少内存和时间开销。
2. **二分查找**：在离散化后的坐标范围内，使用二分查找快速定位查询区间的边界，从而确定需要计算的区间范围。
3. **前缀和**：在离散化后的坐标范围内，预先计算前缀和，使得区间查询可以在 $O(1)$ 时间内完成。

#### 评分较高的题解
1. **作者：XXh0919 (赞：19)**
   - **星级：4.5**
   - **关键亮点**：使用了离散化和二分查找，代码简洁明了，思路清晰。
   - **核心代码：**
     ```cpp
     l = lower_bound(x+1, x+n+1, l) - x;
     r = upper_bound(x+1, x+n+1, r) - x;
     cout << sum[r-1] - sum[l-1] << endl;
     ```
   - **个人心得**：作者提到使用 `lower_bound` 和 `upper_bound` 进行二分查找，并解释了为什么使用 `upper_bound` 可以避免特判。

2. **作者：hzxphy (赞：7)**
   - **星级：4**
   - **关键亮点**：提出了树状数组的解决方案，虽然最终代码没有完全实现，但思路值得借鉴。
   - **核心代码：**
     ```cpp
     long long r = upper_bound(a+1, a+1+n, y) - a - 1;
     long long l = lower_bound(a+1, a+1+n, x) - a;
     cout << b[r] - b[l-1] << '\n';
     ```
   - **个人心得**：作者提到树状数组的局限性，并解释了为什么选择离散化和前缀和的方案。

3. **作者：hjyowl (赞：6)**
   - **星级：4**
   - **关键亮点**：详细解释了二分查找的边界处理，代码结构清晰，易于理解。
   - **核心代码：**
     ```cpp
     long long ll = lower_bound(a+1, a+1+n, l) - a;
     long long rr = upper_bound(a+1, a+1+n, r) - a - 1;
     cout << s[rr] - s[ll-1] << endl;
     ```
   - **个人心得**：作者强调了使用 `64` 位整型的重要性，并详细解释了二分查找的边界处理。

### 推荐题目
1. **洛谷 P3374 【模板】树状数组 1**：考察树状数组的基本操作，适合练习区间查询和单点更新。
2. **洛谷 P3368 【模板】树状数组 2**：考察树状数组的区间更新和单点查询，适合进一步理解树状数组的应用。
3. **洛谷 P1908 逆序对**：考察离散化和树状数组的结合应用，适合练习离散化技巧。

### 总结
该题的核心在于如何处理大范围的坐标查询，离散化和二分查找是解决这类问题的常用技巧。通过将大范围映射到小范围内，再利用前缀和或树状数组等数据结构，可以高效地解决区间查询问题。

---
处理用时：42.69秒
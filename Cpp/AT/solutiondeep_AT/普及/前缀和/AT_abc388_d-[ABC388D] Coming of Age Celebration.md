# 题目信息

# [ABC388D] Coming of Age Celebration

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc388/tasks/abc388_d

ある星には $ N $ 人の宇宙人がおり、全員未成年です。

$ i $ 人目の宇宙人は現在 $ A_i $ 個の石を所持しており、ちょうど $ i $ 年後に成人します。

この星では誰かが成人するとき、石を $ 1 $ 個以上所持している**成人**全員が、成人する宇宙人に成人祝いとして石を $ 1 $ 個渡します。

$ N $ 年後に各宇宙人が所持している石の個数を求めてください。

ただし、今後新たな宇宙人は産まれないものとします。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 5\ \times\ 10^5 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i $ 人目の宇宙人が持っている石の個数を $ C_i $ で表します。 はじめ $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ です。 $ 1 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ となります。 $ 2 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (4,\ 1,\ 9,\ 3) $ となります。 $ 3 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (3,\ 0,\ 11,\ 3) $ となります。 $ 4 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (2,\ 0,\ 10,\ 5) $ となります。

## 样例 #1

### 输入

```
4

5 0 9 3```

### 输出

```
2 0 10 5```

## 样例 #2

### 输入

```
5

4 6 7 2 5```

### 输出

```
0 4 7 4 9```

## 样例 #3

### 输入

```
10

2 9 1 2 0 4 6 7 1 5```

### 输出

```
0 2 0 0 0 4 7 10 4 10```

# AI分析结果

### 题目翻译

在某个星球上，有 $N$ 个外星人，他们都是未成年人。

第 $i$ 个外星人目前拥有 $A_i$ 块石头，并将在 $i$ 年后成年。

当这个星球上有人成年时，每个至少拥有一块石头的成年人都会向刚刚成年的外星人赠送一块石头作为贺礼。

求 $N$ 年后每个外星人将拥有多少块石头。

假设未来不会有新的外星人诞生。

### 题解分析与结论

本题的核心在于模拟每个外星人在成年时，其他成年人会赠送石头的规则。由于直接模拟会导致 $O(N^2)$ 的复杂度，因此需要优化。常见的优化思路包括使用差分数组、优先队列、线段树等数据结构来减少时间复杂度。

#### 最优关键思路与技巧

1. **差分数组**：通过差分数组来记录每个外星人成年后赠送石头的区间，从而在 $O(N)$ 时间内完成所有操作。
2. **优先队列**：使用优先队列来维护当前可以赠送石头的外星人，确保每次操作都能快速找到合适的外星人。
3. **线段树**：通过线段树实现区间修改和单点查询，适用于更复杂的区间操作。

### 推荐题解

#### 题解1：差分数组（作者：_IceCream_）
- **星级**：★★★★★
- **关键亮点**：通过差分数组巧妙地将区间修改转化为单点修改，时间复杂度为 $O(N)$，代码简洁且高效。
- **核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    sum += tot[i]; // i 自己也会被前面的影响
    a[i] += sum;
    if (a[i] < 0) {
        tot[n + a[i] + 1]--; // 差分
        a[i] = 0;
    }
}
```

#### 题解2：优先队列（作者：ikunTLE）
- **星级**：★★★★☆
- **关键亮点**：使用优先队列维护当前可以赠送石头的外星人，确保每次操作都能快速找到合适的外星人，时间复杂度为 $O(N \log N)$。
- **核心代码**：
```cpp
for (int i = 1; i <= n; ++i) {
    a[i] += pq.size();
    while (!pq.empty() && pq.top().x - i <= 0)
        pq.pop();
    if (a[i])
        pq.push({a[i] + i, i});
}
```

#### 题解3：线段树（作者：Ybll_）
- **星级**：★★★★☆
- **关键亮点**：通过线段树实现区间修改和单点查询，适用于更复杂的区间操作，时间复杂度为 $O(N \log N)$。
- **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    int j = query(1, i, i);
    update(1, i + 1, min(n, i + j), 1);
    update(1, i, i, -min(n - i, j));
}
```

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得
- **调试经历**：在实现差分数组时，需要注意边界条件的处理，避免数组越界。
- **顿悟感想**：优先队列的使用可以大大简化问题，尤其是在需要动态维护最小或最大值时。

---
处理用时：30.27秒
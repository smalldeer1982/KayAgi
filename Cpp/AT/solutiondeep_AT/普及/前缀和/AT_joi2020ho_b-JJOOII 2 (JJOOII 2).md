# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果

### 题目内容重写
**题目描述**

ビ太郎收到了朋友ビバ子送的生日礼物，礼物是一个由 `J`、`O`、`I` 三种字符组成的长为 $N$ 的字符串 $S$。

定义 $K$ 阶 JOI 字符串为由 $K$ 个 `J`，接着 $K$ 个 `O`，最后 $K$ 个 `I` 按顺序组成的字符串。例如，`JJOOII` 是 $2$ 阶 JOI 字符串。

ビ太郎希望通过以下三种操作将字符串 $S$ 转换为 $K$ 阶 JOI 字符串：

1. **操作 1**：删除字符串 $S$ 的第一个字符。
2. **操作 2**：删除字符串 $S$ 的最后一个字符。
3. **操作 3**：删除字符串 $S$ 中既不是第一个也不是最后一个的字符。

由于操作 3 比较麻烦，ビ太郎希望尽可能减少操作 3 的次数。给定字符串 $S$ 和整数 $K$，求将 $S$ 转换为 $K$ 阶 JOI 字符串所需的最少操作 3 次数。如果无法转换，则输出 `-1`。

**输入格式**

第一行包含两个整数 $N$ 和 $K$，第二行包含字符串 $S$。

**输出格式**

输出一个整数，表示最少操作 3 的次数，若无法转换则输出 `-1`。

**样例**

输入：
```
10 2
OJIJOIOIIJ
```
输出：
```
2
```

### 题解分析与结论

#### 综合分析
本题的核心在于找到字符串 $S$ 中满足条件的最短子串，即包含至少 $K$ 个 `J`、$K$ 个 `O` 和 $K$ 个 `I`，并且这些字符按顺序排列。通过删除多余字符，使得最终子串成为 $K$ 阶 JOI 字符串。

大多数题解采用了前缀和与二分查找的结合，通过枚举 `J` 的起始位置，依次找到 `O` 和 `I` 的结束位置，计算子串长度并更新最小操作次数。部分题解还使用了双指针或四指针的方法来优化查找过程。

#### 最优思路与技巧
1. **前缀和与二分查找**：通过前缀和快速计算任意子串中 `J`、`O`、`I` 的数量，结合二分查找快速定位满足条件的字符位置。
2. **枚举与贪心**：枚举 `J` 的起始位置，贪心地找到最近的 `O` 和 `I` 的结束位置，确保子串长度最小。
3. **指针维护**：使用多个指针（如四指针）维护 `J`、`O`、`I` 的分界点，减少不必要的遍历。

#### 推荐题解
1. **作者：Kano_zyc (赞：3)**
   - **星级：4.5**
   - **关键亮点**：详细解释了前缀和与二分查找的结合，代码清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     int findMinIndex(int l, int k, int n, int prefixSum[]) {
         int left = l, right = n, ans = n + 1;
         while (left <= right) {
             int mid = left + (right - left) / 2;
             if (prefixSum[mid] - prefixSum[l - 1] >= k) {
                 ans = mid;
                 right = mid - 1;
             } else {
                 left = mid + 1;
             }
         }
         return ans;
     }
     ```

2. **作者：small_turtle (赞：3)**
   - **星级：4**
   - **关键亮点**：使用 `lower_bound` 简化二分查找，代码简洁，效率高。
   - **核心代码**：
     ```cpp
     int x = lower_bound(J+1, J+n+1, J[i-1]+k)-J;
     int y = lower_bound(O+1, O+n+1, O[x-1]+k)-O;
     int z = lower_bound(I+1, I+n+1, I[y-1]+k)-I;
     ```

3. **作者：saixingzhe (赞：1)**
   - **星级：4**
   - **关键亮点**：使用 `vector` 记录字符位置，通过指针维护快速找到 `O` 和 `I` 的位置，时间复杂度为 $O(n)$。
   - **核心代码**：
     ```cpp
     while(O <= q[1].size()-k && q[0][J+k-1] > q[1][O]) O++;
     while(I <= q[2].size()-k && q[1][O+k-1] > q[2][I]) I++;
     ```

#### 扩展思路
- **类似题目**：可以尝试解决其他需要找到特定子串或子序列的题目，如最长回文子串、最长不重复子串等。
- **优化技巧**：在字符串处理中，前缀和与二分查找的结合是常见的优化手段，适用于需要快速计算区间内字符数量的场景。

#### 推荐题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3805 【模板】Manacher算法](https://www.luogu.com.cn/problem/P3805)
3. [P1496 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1496)

#### 个人心得
- **调试经历**：在实现二分查找时，注意边界条件的处理，避免数组越界或死循环。
- **踩坑教训**：在枚举 `J` 的起始位置时，确保后续的 `O` 和 `I` 数量足够，否则需要及时跳出循环。

---
处理用时：44.04秒
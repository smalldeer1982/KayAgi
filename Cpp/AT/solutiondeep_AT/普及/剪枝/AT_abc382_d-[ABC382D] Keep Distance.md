# 题目信息

# [ABC382D] Keep Distance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_d

整数 $ N $ と $ M $ が与えられます。

以下の条件をすべて満たす長さ $ N $ の整数列 $ (A_1,\ A_2,\ \ldots,\ A_N) $ を辞書順にすべて出力してください。

- $ 1\ \leq\ A_i $
- $ 2 $ 以上 $ N $ 以下の各整数 $ i $ に対して $ A_{i\ -\ 1}\ +\ 10\ \leq\ A_i $
- $ A_N\ \leq\ M $
 
  数列の辞書順とは長さ $ N $ の数列 $ S\ =\ (S_1,\ S_2,\ \ldots,\ S_N) $ が長さ $ N $ の数列 $ T\ =\ (T_1,\ T_2,\ \ldots,\ T_N) $ より**辞書順で小さい**とは、ある整数 $ 1\ \leq\ i\ \leq\ N $ が存在して下記の $ 2 $ つがともに成り立つことをいいます。

- $ (S_1,\ S_2,\ \ldots,\ S_{i-1})\ =\ (T_1,\ T_2,\ \ldots,\ T_{i-1}) $
- $ S_i $ が $ T_i $ より（数として）小さい。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 12 $
- $ 10N\ -\ 9\ \leq\ M\ \leq\ 10N $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (1,\ 11,\ 21),\ (1,\ 11,\ 22),\ (1,\ 11,\ 23),\ (1,\ 12,\ 22),\ (1,\ 12,\ 23),\ (1,\ 13,\ 23),\ (2,\ 12,\ 22),\ (2,\ 12,\ 23),\ (2,\ 13,\ 23),\ (3,\ 13,\ 23) $ の $ 10 $ 個の数列が条件を満たします。

## 样例 #1

### 输入

```
3 23```

### 输出

```
10

1 11 21

1 11 22

1 11 23

1 12 22

1 12 23

1 13 23

2 12 22

2 12 23

2 13 23

3 13 23```

# AI分析结果

### 题目内容重写

#### 题目描述

给定整数 $N$ 和 $M$，构造所有满足以下条件的长度为 $N$ 的整数序列 $A$，并按照字典序输出：

1. $1 \leq A_i$
2. 对于所有 $2 \leq i \leq N$，$A_{i-1} + 10 \leq A_i$
3. $A_N \leq M$

#### 输入格式

输入两个整数 $N$ 和 $M$。

#### 输出格式

首先输出满足条件的序列个数，然后按字典序输出所有满足条件的序列。

#### 样例输入

```
3 23
```

#### 样例输出

```
10
1 11 21
1 11 22
1 11 23
1 12 22
1 12 23
1 13 23
2 12 22
2 12 23
2 13 23
3 13 23
```

#### 数据范围

- $2 \leq N \leq 12$
- $10N - 9 \leq M \leq 10N$

### 题解分析与结论

本题的核心是通过深度优先搜索（DFS）生成所有满足条件的序列，并通过剪枝优化避免不必要的计算。由于 $N$ 的范围较小（$N \leq 12$），直接暴力搜索是可行的，但需要通过剪枝来减少搜索空间。

#### 关键思路与技巧

1. **DFS + 剪枝**：通过DFS生成序列，并在每一步通过剪枝条件（如当前元素加上剩余元素的最小增量是否超过 $M$）来减少搜索空间。
2. **字典序输出**：由于DFS按从小到大的顺序生成序列，天然满足字典序要求，无需额外排序。
3. **边界处理**：在DFS中，通过初始化 $A_0$ 为 $-9$ 来确保 $A_1$ 从 $1$ 开始，避免越界。

#### 最优题解

以下是评分较高的题解：

1. **作者：_colin1112_（评分：4星）**
   - **关键亮点**：详细解释了每个元素的取值范围，并通过DFS递归构造序列，剪枝条件清晰。
   - **代码实现**：
     ```cpp
     void dfs(int pos, vector<ll> &seq) {
         if (pos == n) {
             ans.push_back(seq);
             return;
         }
         ll l = (pos == 0) ? 1 : seq[pos - 1] + 10;
         ll r = m - 10 * (n - pos - 1);
         for (int i = l; i <= r; i++) {
             seq.push_back(i);
             dfs(pos + 1, seq);
             seq.pop_back();
         }
     }
     ```

2. **作者：Zskioaert1106（评分：4星）**
   - **关键亮点**：通过DFS枚举每一位的可能性，并在每一步通过剪枝条件减少搜索空间，代码简洁易懂。
   - **代码实现**：
     ```cpp
     void dfs(int i, int d) {
         if (i > n) {
             sum++;
             for (int j = 1; j <= n; j++) ans[sum][j] = k[j];
         } else {
             for (int j = d; j + (n - i) * 10 <= m; j++) {
                 k[i] = j;
                 dfs(i + 1, j + 10);
             }
         }
     }
     ```

3. **作者：ThomasNO1（评分：4星）**
   - **关键亮点**：通过DFS生成序列，并在每一步通过剪枝条件减少搜索空间，代码结构清晰。
   - **代码实现**：
     ```cpp
     void dfs(int pos) {
         if (pos > n) {
             for (int i = 1; i <= n; i++) A.push_back(a[i]);
             ans++;
             A.push_back(-1);
             return;
         }
         if (a[pos - 1] + 10 * (n - pos) > m) return;
         for (int i = a[pos - 1] + 10; i <= m - 10 * (n - pos); i++) {
             a[pos] = i;
             dfs(pos + 1);
         }
     }
     ```

#### 个人心得摘录

- **调试经历**：部分题解提到在调试过程中发现数组开小导致WA，提醒我们在处理大规模输出时要注意数组大小。
- **剪枝优化**：通过剪枝条件大幅减少了搜索空间，使得原本可能超时的DFS能够在合理时间内完成。

### 推荐题目

1. **洛谷 P1706 全排列问题**（题号：P1706）
   - **考察知识点**：DFS、全排列生成。
   
2. **洛谷 P1219 八皇后**（题号：P1219）
   - **考察知识点**：DFS、回溯、剪枝。

3. **洛谷 P1036 选数**（题号：P1036）
   - **考察知识点**：DFS、组合生成、剪枝。

---
处理用时：39.91秒
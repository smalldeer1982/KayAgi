# 题目信息

# [ABC386E] Maximize XOR

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$ 和一个整数 $K$。保证二项式系数 $\dbinom{N}{K} \leq 10^6$。

从序列 $A$ 中选择 $K$ 个不同的元素，求出这些元素的异或和的最大值。

简单来说，就是求 $\underset{1 \leq i_1 < i_2 < \ldots < i_K \leq N}{\max} A_{i_1} \oplus A_{i_2} \oplus \ldots \oplus A_{i_K}$。

在这里，异或运算（XOR）是这样定义的：对于两个非负整数 $A$ 和 $B$，其结果 $A \oplus B$ 是一个二进制数，对于每个 $2^k \ (k \geq 0)$ 位，如果 $A$ 和 $B$ 在这一位中恰好只有一个是 $1$，则结果在这一位是 $1$，否则为 $0$。

举个例子：$3 \oplus 5 = 6$，在二进制下：$011 \oplus 101 = 110$。通常来说，$k$ 个整数 $p_1, \dots, p_k$ 的异或值可以表示为 $(\cdots ((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k)$，并且顺序不会影响结果。

## 说明/提示

- $1 \leq K \leq N \leq 2 \times 10^5$
- $0 \leq A_i < 2^{60}$
- $\dbinom{N}{K} \leq 10^6$
- 所有输入均为整数

### 示例解释 1

从 $(3, 2, 6, 4)$ 中选出任意两个不同的数，有以下六种组合方式：
- 选择 $(3, 2)$：异或值为 $3 \oplus 2 = 1$。
- 选择 $(3, 6)$：异或值为 $3 \oplus 6 = 5$。
- 选择 $(3, 4)$：异或值为 $3 \oplus 4 = 7$。
- 选择 $(2, 6)$：异或值为 $2 \oplus 6 = 4$。
- 选择 $(2, 4)$：异或值为 $2 \oplus 4 = 6$。
- 选择 $(6, 4)$：异或值为 $6 \oplus 4 = 2$。

因此，最大异或值为 $7$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4 2
3 2 6 4```

### 输出

```
7```

## 样例 #2

### 输入

```
10 4
1516 1184 1361 2014 1013 1361 1624 1127 1117 1759```

### 输出

```
2024```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$ 和一个整数 $K$。保证二项式系数 $\dbinom{N}{K} \leq 10^6$。

从序列 $A$ 中选择 $K$ 个不同的元素，求出这些元素的异或和的最大值。

简单来说，就是求 $\underset{1 \leq i_1 < i_2 < \ldots < i_K \leq N}{\max} A_{i_1} \oplus A_{i_2} \oplus \ldots \oplus A_{i_K}$。

在这里，异或运算（XOR）是这样定义的：对于两个非负整数 $A$ 和 $B$，其结果 $A \oplus B$ 是一个二进制数，对于每个 $2^k \ (k \geq 0)$ 位，如果 $A$ 和 $B$ 在这一位中恰好只有一个是 $1$，则结果在这一位是 $1$，否则为 $0$。

举个例子：$3 \oplus 5 = 6$，在二进制下：$011 \oplus 101 = 110$。通常来说，$k$ 个整数 $p_1, \dots, p_k$ 的异或值可以表示为 $(\cdots ((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k)$，并且顺序不会影响结果。

#### 说明/提示

- $1 \leq K \leq N \leq 2 \times 10^5$
- $0 \leq A_i < 2^{60}$
- $\dbinom{N}{K} \leq 10^6$
- 所有输入均为整数

### 样例解释

#### 样例 #1

**输入**

```
4 2
3 2 6 4
```

**输出**

```
7
```

#### 样例 #2

**输入**

```
10 4
1516 1184 1361 2014 1013 1361 1624 1127 1117 1759
```

**输出**

```
2024
```

### 题解分析与结论

#### 综合分析

本题的核心是从给定的序列中选择 $K$ 个元素，使得它们的异或和最大。由于 $\dbinom{N}{K} \leq 10^6$，暴力搜索在理论上是可行的，但需要优化以避免超时。大多数题解都采用了深度优先搜索（DFS）结合剪枝的策略，部分题解还利用了异或运算的性质进行优化。

#### 关键思路与技巧

1. **剪枝优化**：在DFS过程中，通过判断剩余元素是否足够选择，提前终止无效的搜索路径。
2. **后缀异或和**：预处理后缀异或和，当剩余元素必须全选时，直接计算当前异或和与后缀异或和的异或值，避免继续递归。
3. **正难则反**：当 $K$ 较大时，改为选择 $N-K$ 个元素，利用异或运算的性质（$a \oplus b \oplus b = a$）来简化计算。

#### 评分较高的题解

1. **作者：yy0707 (赞：8)**  
   - **星级**：4.5  
   - **关键亮点**：通过判断 $n-k<k$ 来优化搜索方向，利用异或运算的性质减少计算量。  
   - **代码核心思想**：DFS搜索，当 $n-k<k$ 时改为选择 $n-k$ 个元素，最终结果通过异或运算得到。

   ```cpp
   void dfs(int p,int st,int xsum){
       if(st==k)return ans=max(ans,xsum),void();
       for(int i=p+1;i<=n;i++)dfs(i,st+1,xsum^a[i]);
   }
   ```

2. **作者：Walrus (赞：3)**  
   - **星级**：4  
   - **关键亮点**：详细分析了不同 $k$ 值下的时间复杂度，提出了当 $k \leq \frac{n}{2}$ 时直接搜索，否则选择 $n-k$ 个元素的策略。  
   - **代码核心思想**：DFS搜索，结合后缀异或和进行剪枝优化。

   ```cpp
   void dfs(int x, int num, int val){
       if(num > k || x > n + 1) return;
       if(num == n - k) ans = max(ans, Val ^ val);
       if(num == k) ans = max(ans, val);
       dfs(x + 1, num + 1, val ^ a[x]);
       dfs(x + 1, num, val);
   }
   ```

3. **作者：Yuexingfei_qwq (赞：2)**  
   - **星级**：4  
   - **关键亮点**：预处理后缀异或和，在DFS中直接利用后缀异或和进行剪枝，减少了递归深度。  
   - **代码核心思想**：DFS搜索，当剩余元素必须全选时，直接计算当前异或和与后缀异或和的异或值。

   ```cpp
   inline void dfs(int x, int y, int t) {
       if (y == 0) ans = std::max(ans, t);
       if (x + y - 1 == n) ans = std::max(ans, t ^ s[x]);
       dfs(x + 1, y - 1, t ^ a[x]);
       dfs(x + 1, y, t);
   }
   ```

#### 通用建议与扩展思路

- **优化思路**：对于组合数较大的情况，可以考虑使用位运算或动态规划进行优化，减少搜索空间。
- **类似题目**：可以尝试解决其他涉及异或运算的题目，如最大异或对、子数组异或和等。

#### 推荐题目

1. [P4735 最大异或和](https://www.luogu.com.cn/problem/P4735)
2. [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)
3. [P4592 [TJOI2018]异或](https://www.luogu.com.cn/problem/P4592)

---
处理用时：40.07秒
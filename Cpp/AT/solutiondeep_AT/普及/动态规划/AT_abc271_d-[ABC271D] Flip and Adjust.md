# 题目信息

# [ABC271D] Flip and Adjust

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc271/tasks/abc271_d

両面に整数が書かれたカードが $ N $ 枚あり、$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 枚目のカードの表には $ a_i $ が、裏には $ b_i $ が書かれています。

あなたは、それぞれのカードについて、表を上に向けて置くか裏を上に向けて置くかを自由に決めることができます。

上に向けられた面に書かれた整数の総和がちょうど $ S $ となるようにカードを置くことができるか判定し、可能ならそのようなカードの置き方の一例を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ S\ \leq\ 10000 $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ 100\ \,\ (1\ \leq\ i\ \leq\ N) $
- 入力は全て整数

### Sample Explanation 1

例えば次のように置くことで、上に向けられた面に書かれた整数の総和がちょうど $ S\ (=\ 11) $ となります。 - $ 1 $ 枚目は表、$ 2 $ 枚目は裏、$ 3 $ 枚目は裏を上に向けて置く。 - $ 1 $ 枚目は裏、$ 2 $ 枚目は表、$ 3 $ 枚目は表を上に向けて置く。 よって、`HTT` や `THH` といった出力が正解となります。

### Sample Explanation 2

上に向けられた面に書かれた整数の総和がちょうど $ S\ (=\ 25) $ となるようにカードを置くことはできません。

## 样例 #1

### 输入

```
3 11

1 4

2 3

5 7```

### 输出

```
Yes

THH```

## 样例 #2

### 输入

```
5 25

2 8

9 3

4 11

5 1

12 6```

### 输出

```
No```

# AI分析结果

### 题目内容重写

**题目描述**

有 $N$ 张卡片，每张卡片的两面分别写有整数 $a_i$ 和 $b_i$。你可以选择将每张卡片的正面或反面朝上放置。问是否存在一种放置方式，使得所有朝上的面的整数之和恰好为 $S$。如果存在，输出 `Yes` 并给出一种放置方式；否则输出 `No`。

**说明/提示**

- 约束条件：
  - $1 \leq N \leq 100$
  - $1 \leq S \leq 10000$
  - $1 \leq a_i, b_i \leq 100$（$1 \leq i \leq N$）
  - 输入均为整数

**样例 #1**

输入：
```
3 11
1 4
2 3
5 7
```

输出：
```
Yes
THH
```

**样例 #2**

输入：
```
5 25
2 8
9 3
4 11
5 1
12 6
```

输出：
```
No
```

### 题解综合分析与结论

本题的核心是通过动态规划（DP）来解决，主要思路是使用一个二维布尔数组 `dp[i][j]` 表示前 $i$ 张卡片能否组成和为 $j$。通过状态转移方程，逐步计算每张卡片的两种选择（正面或反面）对总和的影响，最终判断是否存在满足条件的放置方式。

### 所选高星题解

#### 题解1：作者：DYYqwq (赞：14)
**星级：★★★★★**
**关键亮点：**
- 使用布尔数组 `dp[i][j]` 表示前 $i$ 张卡片能否组成和为 $j$。
- 通过递归函数 `output` 回溯输出具体的放置方式。
- 代码简洁明了，逻辑清晰，易于理解。

**核心代码：**
```cpp
void output(int x, int y) {
    if(!x) return;
    if(y >= a[x] && dp[x - 1][y - a[x]]) {
        output(x - 1, y - a[x]);
        ans += 'H';
    } else if(y >= b[x] && dp[x - 1][y - b[x]]) {
        output(x - 1, y - b[x]);
        ans += 'T';
    }
}
```

#### 题解2：作者：_GW_ (赞：3)
**星级：★★★★**
**关键亮点：**
- 使用记忆化搜索（DFS）结合剪枝来优化搜索过程。
- 通过 `f[i][res]` 数组记录已经搜索过的状态，避免重复计算。
- 代码实现较为简洁，适合对搜索算法有一定理解的读者。

**核心代码：**
```cpp
void dfs(int i, int res) {
    if(!i) {
        if(res == m) {
            cout << "Yes" << endl;
            flag = 1;
        }
        return;
    }
    if(res > m || f[i][res]) return;
    for(int j = 0; j <= 1; j++) {
        if(a[i][j] + res <= m) {
            dfs(i - 1, res + a[i][j]);
            if(flag) {
                cout << (j ? "T" : "H");
                return;
            }
        }
    }
    f[i][res] = 1;
}
```

#### 题解3：作者：MichaelDickson (赞：2)
**星级：★★★★**
**关键亮点：**
- 使用记忆化搜索（DFS）结合状态标记数组 `f[i][sum]` 来记录搜索状态。
- 通过递归回溯输出具体的放置方式。
- 代码逻辑清晰，适合对动态规划和搜索算法有一定基础的读者。

**核心代码：**
```cpp
bool Dfs(int i, int sum) {
    if (i <= 0) {
        if (sum == m) {
            cout << "Yes\n";
            return 1;
        }
        return 0;
    }
    if (sum > m || f[i][sum]) return 0;
    f[i][sum] = 1;
    for (int j = 0; j <= 1; j++) {
        if (Dfs(i - 1, sum + a[i][j])) {
            cout << (j ? 'T' : 'H');
            return 1;
        }
    }
    return 0;
}
```

### 最优关键思路与技巧

1. **动态规划状态转移**：使用 `dp[i][j]` 表示前 $i$ 张卡片能否组成和为 $j$，通过状态转移方程逐步计算每张卡片的两种选择对总和的影响。
2. **递归回溯输出方案**：通过递归函数回溯输出具体的放置方式，确保输出方案的正确性。
3. **记忆化搜索优化**：在搜索过程中使用记忆化数组记录已经搜索过的状态，避免重复计算，提高算法效率。

### 可拓展之处

- **类似问题**：可以扩展到其他类似的选择问题，如背包问题、子集和问题等。
- **优化空间复杂度**：可以通过滚动数组优化空间复杂度，减少内存使用。

### 推荐相似题目

1. **洛谷 P1434 [SHOI2002]滑雪** - 考察动态规划与记忆化搜索。
2. **洛谷 P1048 [NOIP2005 普及组] 采药** - 考察背包问题的动态规划解法。
3. **洛谷 P1064 [NOIP2006 提高组] 金明的预算方案** - 考察多维背包问题的动态规划解法。

### 个人心得摘录

- **调试经历**：在实现动态规划时，确保状态转移方程的正确性非常重要，尤其是在边界条件的处理上。
- **踩坑教训**：在递归回溯输出方案时，注意递归的终止条件和输出顺序，避免输出错误。
- **顿悟感想**：通过动态规划和递归回溯的结合，可以高效地解决类似的选择问题，理解其背后的逻辑是关键。

---
处理用时：48.91秒
# 题目信息

# [ABC281D] Max Multiple

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc281/tasks/abc281_d

非負整数列 $ A=(a_1,a_2,\ldots,a_N) $ が与えられます。

$ A $ の(添え字が相異なる) $ K $ 個の項の和として考えられる非負整数の集合を $ S $ とします。

$ S $ に含まれる $ D $ の倍数の最大値を求めてください。ただし、$ S $ に $ D $ の倍数が含まれない場合、代わりに `-1` と出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ D\ \leq\ 100 $
- $ 0\ \leq\ a_i\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

$ A $ から $ 2 $ 個の項を選ぶ方法を列挙すると - $ a_1 $ と $ a_2 $ を選ぶ。選ばれた項の和は $ 1+2=3 $ となる。 - $ a_1 $ と $ a_3 $ を選ぶ。選ばれた項の和は $ 1+3=4 $ となる。 - $ a_1 $ と $ a_4 $ を選ぶ。選ばれた項の和は $ 1+4=5 $ となる。 - $ a_2 $ と $ a_3 $ を選ぶ。選ばれた項の和は $ 2+3=5 $ となる。 - $ a_2 $ と $ a_4 $ を選ぶ。選ばれた項の和は $ 2+4=6 $ となる。 - $ a_3 $ と $ a_4 $ を選ぶ。選ばれた項の和は $ 3+4=7 $ となる。 となり、$ S=\{3,4,5,6,7\} $ となります。$ S $ に含まれる $ 2 $ の倍数のうち最大のものは $ 6 $ なので、$ 6 $ と出力します。

### Sample Explanation 2

この例では $ S=\{1,3,5\} $ です。$ S $ に含まれる非負整数はいずれも $ 2 $ の倍数でないため、`-1` と出力します。

## 样例 #1

### 输入

```
4 2 2

1 2 3 4```

### 输出

```
6```

## 样例 #2

### 输入

```
3 1 2

1 3 5```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个非负整数序列 \( A = (a_1, a_2, \ldots, a_N) \)。

定义集合 \( S \) 为从 \( A \) 中选取 \( K \) 个不同下标的元素的和所构成的所有非负整数的集合。

求 \( S \) 中最大的 \( D \) 的倍数。如果 \( S \) 中没有 \( D \) 的倍数，则输出 `-1`。

**说明/提示**

- \( 1 \leq K \leq N \leq 100 \)
- \( 1 \leq D \leq 100 \)
- \( 0 \leq a_i \leq 10^9 \)
- 输入均为整数

### 题解综合分析

本题的核心是动态规划（DP），所有题解都采用了类似的三维 DP 思路，状态定义为 \( dp[i][j][k] \)，表示前 \( i \) 个数中选 \( j \) 个，且这些数的和对 \( D \) 取模为 \( k \) 时的最大和。难点在于如何正确处理状态转移，尤其是模运算的负数处理。

### 精选题解

#### 1. 作者：_dijkstra_ (赞：18)
**星级：5星**
**关键亮点：**
- 状态定义清晰，转移方程简洁明了。
- 代码实现简洁，初始化处理得当，避免了负数模运算的问题。
- 使用了 `memset` 初始化 DP 数组为负无穷，便于后续判断无解情况。

**核心代码：**
```cpp
memset(dp, -0x3f, sizeof dp);
dp[0][0][0] = 0;
for (int i = 1; i <= n; i++) {
    int x;
    scanf("%d", &x);
    for (int j = 0; j <= k; j++)
        for (int r = 0; r < d; r++) {
            dp[i][j][r] = max(dp[i][j][r], dp[i - 1][j][r]);
            if (j) dp[i][j][r] = max(dp[i][j][r], dp[i - 1][j - 1][((r - x) % d + d) % d] + x);
        }
}
if (dp[n][k][0] < 0) puts("-1"); else cout << dp[n][k][0] << '\n';
```

#### 2. 作者：Neil_Qian (赞：5)
**星级：4星**
**关键亮点：**
- 状态转移方程解释详细，特别是对模运算的处理有清晰的说明。
- 代码中使用 `ll& w = dp[i][j][l]` 简化了代码，提高了可读性。

**核心代码：**
```cpp
memset(dp, -0x3f, sizeof(dp)), dp[0][0][0] = 0;
_for(i, 1, n) _for(j, 0, min(j, k)) _for(l, 0, d - 1) {
    ll& w = dp[i][j][l];
    if (j > 0) w = max(dp[i - 1][j - 1][(ll)(l - a[i] + d * 1e12) % d] + a[i], w);
    w = max(w, dp[i - 1][j][l]);
}
```

#### 3. 作者：c20231020 (赞：0)
**星级：4星**
**关键亮点：**
- 状态转移方程清晰，且对模运算的负数处理有详细解释。
- 代码结构清晰，初始化处理得当。

**核心代码：**
```cpp
memset(dp, -0x3f, sizeof(dp));
dp[0][0][0] = 0;
for (int i = 1; i <= n; ++i) {
    dp[i][0][0] = 0;
    for (int j = 1; j <= min(i, k); ++j) {
        for (int l = 0; l < d; ++l) {
            dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][(l - a[i] % d + d) % d] + a[i]);
        }
    }
}
```

### 最优关键思路与技巧

1. **状态定义**：使用三维 DP 数组 \( dp[i][j][k] \) 表示前 \( i \) 个数中选 \( j \) 个，且这些数的和对 \( D \) 取模为 \( k \) 时的最大和。
2. **状态转移**：对于每个数，考虑选或不选，更新 DP 数组。特别注意模运算的负数处理，通常通过加上 \( D \) 再取模来避免负数。
3. **初始化**：DP 数组初始化为负无穷，便于后续判断无解情况。

### 拓展与举一反三

- **类似题目**：可以考虑类似的 DP 问题，如背包问题、子集和问题等。
- **优化**：可以尝试滚动数组优化空间复杂度，或者使用位运算加速状态转移。

### 推荐题目

1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典的背包问题，与本题的 DP 思路类似。
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064) - 多维背包问题，适合练习多维 DP。
3. [P1510 精卫填海](https://www.luogu.com.cn/problem/P1510) - 子集和问题的变种，适合练习 DP 的状态转移。

---
处理用时：49.54秒
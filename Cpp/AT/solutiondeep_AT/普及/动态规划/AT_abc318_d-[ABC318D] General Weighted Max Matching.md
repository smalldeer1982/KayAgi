# 题目信息

# [ABC318D] General Weighted Max Matching

## 题目描述

**题意简述**

有一个无向图，$i$ 到 $j$ 的距离为 $D_{i,j}$。你可以选择一些边，使得这些边连接的所有顶点互不相同。求这些边总长度的最大值。

## 说明/提示

- $2 \le N \le 16$
- $1 \le D_{i,j} \le 10^9$

**样例一解释**

选择 $D_{1,3},D_{2,4}$，总和为$5+8=13$。

## 样例 #1

### 输入

```
4

1 5 4

7 8

6```

### 输出

```
13```

## 样例 #2

### 输入

```
3

1 2

3```

### 输出

```
3```

## 样例 #3

### 输入

```
16

5 6 5 2 1 7 9 7 2 5 5 2 4 7 6

8 7 7 9 8 1 9 6 10 8 8 6 10 3

10 5 8 1 10 7 8 4 8 6 5 1 10

7 4 1 4 5 4 5 10 1 5 1 2

2 9 9 7 6 2 2 8 3 5 2

9 10 3 1 1 2 10 7 7 5

10 6 1 8 9 3 2 4 2

10 10 8 9 2 10 7 9

5 8 8 7 5 8 2

4 2 2 6 8 3

2 7 3 10 3

5 7 10 3

8 5 7

9 1

4```

### 输出

```
75```

# AI分析结果

### 题目内容重写
**题目描述**

有一个无向图，$i$ 到 $j$ 的距离为 $D_{i,j}$。你可以选择一些边，使得这些边连接的所有顶点互不相同。求这些边总长度的最大值。

**说明/提示**

- $2 \le N \le 16$
- $1 \le D_{i,j} \le 10^9$

**样例一解释**

选择 $D_{1,3},D_{2,4}$，总和为$5+8=13$。

**样例 #1**

### 输入

```
4

1 5 4

7 8

6```

### 输出

```
13```

**样例 #2**

### 输入

```
3

1 2

3```

### 输出

```
3```

**样例 #3**

### 输入

```
16

5 6 5 2 1 7 9 7 2 5 5 2 4 7 6

8 7 7 9 8 1 9 6 10 8 8 6 10 3

10 5 8 1 10 7 8 4 8 6 5 1 10

7 4 1 4 5 4 5 10 1 5 1 2

2 9 9 7 6 2 2 8 3 5 2

9 10 3 1 1 2 10 7 7 5

10 6 1 8 9 3 2 4 2

10 10 8 9 2 10 7 9

5 8 8 7 5 8 2

4 2 2 6 8 3

2 7 3 10 3

5 7 10 3

8 5 7

9 1

4```

### 输出

```
75```

### 题解分析与结论

本题的核心在于如何高效地选择边，使得所选边的顶点互不重复，并且总长度最大。由于 $N$ 的范围较小（$2 \le N \le 16$），常见的解法包括暴力搜索和状态压缩动态规划（状压 DP）。以下是各题解的分析与对比：

1. **暴力搜索**：如 ScottSuperb 和 hjqhs 的题解，通过深度优先搜索（DFS）枚举所有可能的边组合。虽然思路简单，但由于 $N$ 的限制，暴力搜索在时间上是可以接受的。然而，这种方法的代码复杂度较高，且不易优化。
   
2. **状压 DP**：如 guanyf、DerrickLo 和 Hyc_ 的题解，使用状态压缩动态规划来记录每个状态下的最大边权和。状压 DP 的优势在于其时间复杂度较低（$O(2^N \cdot N^2)$），且代码结构清晰，易于理解和优化。

3. **优化状压 DP**：如 guanyf 的拓展部分，通过从右往左找到第一个未选的点，进一步优化了状态转移，将时间复杂度降低到 $O(2^N \cdot N)$。这种优化思路非常巧妙，值得学习。

### 评分较高的题解

#### 1. 作者：guanyf (赞：6)  
**星级：5星**  
**关键亮点**：  
- 使用状压 DP，代码简洁且高效。  
- 提供了进一步的优化思路，从右往左找到第一个未选的点，减少了冗余的状态转移。  
- 时间复杂度为 $O(2^N \cdot N)$，在 $N=16$ 时表现良好。

**核心代码**：
```cpp
for (int i = 0; i < (1 << n); i++) {
    p = -1;
    for (int j = 0; j < n; j++) {
        if (!v && p == -1) p = j;
    }
    for (int j = 0; j < n; j++) {
        if (!v) dp[i | (1 << p) | (1 << j)] = max(dp[i | (1 << p) | (1 << j)], dp[i] + e[j + 1][p + 1]);
    }
    ans = max(ans, dp[i]);
}
```

#### 2. 作者：DerrickLo (赞：2)  
**星级：4星**  
**关键亮点**：  
- 使用状压 DP，思路清晰，代码简洁。  
- 通过枚举未选的两个点进行状态转移，时间复杂度为 $O(2^N \cdot N^2)$。

**核心代码**：
```cpp
for (int S = 0; S < (1 << n); S++) {
    for (int j = 1; j <= n; j++) for (int k = j + 1; k <= n; k++) {
        if (!(S & (1 << (j - 1))) && !(S & (1 << (k - 1)))) {
            dp[S + (1 << (j - 1)) + (1 << (k - 1))] = max(dp[S + (1 << (j - 1)) + (1 << (k - 1))], dp[S] + d[j][k]);
        }
    }
}
```

#### 3. 作者：Hyc_ (赞：1)  
**星级：4星**  
**关键亮点**：  
- 使用状压 DP，代码结构清晰。  
- 通过检查状态中二进制位中 $1$ 的个数，跳过无效状态，进一步优化了算法。

**核心代码**：
```cpp
for (int x, i = 0; i < (1 << n); ++i) {
    x = check(i);
    if (x & 1 || x + 1 >= n) continue;
    for (int u = 0; u < n; ++u) {
        if ((1 << u) & i) continue;
        for (int v = u + 1; v < n; ++v) {
            if ((1 << v) & i) continue;
            int j = i | (1 << u) | (1 << v);
            Max(dp[j], dp[i] + d[u][v]);
            Max(ans, dp[j]);
        }
    }
}
```

### 最优关键思路与技巧

1. **状压 DP**：通过二进制状态表示点的选择情况，能够高效地记录和转移状态。
2. **优化状态转移**：从右往左找到第一个未选的点，减少冗余的状态转移，进一步优化时间复杂度。
3. **剪枝与跳过无效状态**：通过检查状态中 $1$ 的个数，跳过无效状态，减少不必要的计算。

### 拓展与举一反三

1. **类似题目**：
   - [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)
   - [P1879 [USACO06NOV] Corn Fields G](https://www.luogu.com.cn/problem/P1879)
   - [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)

2. **调试与顿悟**：在状压 DP 中，状态的表示和转移是关键。通过调试，可以发现状态转移的冗余部分，进而优化算法。例如，从右往左找到第一个未选的点，能够减少不必要的枚举，提升效率。

### 总结

本题的最佳解法是状压 DP，尤其是通过优化状态转移，能够显著提升算法的效率。对于类似的题目，状压 DP 是一种非常有效的解题思路，值得深入学习和掌握。

---
处理用时：60.06秒
# 题目信息

# [ABC321F] #(subset sum = K) with Add and Erase

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc321/tasks/abc321_f

箱を用意します。最初、箱は空です。  
この箱に対して、以下の $ 2 $ 種類の操作を合計 $ Q $ 個、入力で与えられた順に施します。

> \+ $ x $

タイプ $ 1 $ : 箱の中に整数 $ x $ の書かれたボールを $ 1 $ つ追加する。

> \- $ x $

タイプ $ 2 $ : 箱の中にある、整数 $ x $ の書かれたボールを $ 1 $ つ取り除く。  
**但し、取り除く前の時点で箱の中に整数 $ x $ が書かれたボールが含まれることが保証されます。**

各操作後の箱に関して、以下の問題を解いてください。

> 箱からボールをいくつか取り出して、ボールに書かれた整数の総和を $ K $ とする方法の総数を $ 998244353 $ で割った余りを求めてください。  
> 但し、箱の中に入っている全てのボールは区別可能です。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ Q\ \le\ 5000 $
- $ 1\ \le\ K\ \le\ 5000 $
- タイプ $ 1 $ の操作に関して、 $ 1\ \le\ x\ \le\ 5000 $
- 全ての操作は問題文中の条件を満たす。

### Sample Explanation 1

この入力には、操作が $ 15 $ 個含まれます。 最後の操作の後、箱の中に入ったボールは $ (5,10,1,3,1,7,4) $ となります。 総和を $ 10 $ にする方法は以下の $ 5 $ 通りです。 - $ 5+1+3+1 $ ( $ 1,3,4,5 $ 番目のボールを取り出す ) - $ 5+1+4 $ ( $ 1,3,7 $ 番目のボールを取り出す ) - $ 5+1+4 $ ( $ 1,5,7 $ 番目のボールを取り出す ) - $ 10 $ ( $ 2 $ 番目のボールを取り出す ) - $ 3+7 $ ( $ 4,6 $ 番目のボールを取り出す )

## 样例 #1

### 输入

```
15 10
+ 5
+ 2
+ 3
- 2
+ 5
+ 10
- 3
+ 1
+ 3
+ 3
- 5
+ 1
+ 7
+ 4
- 3```

### 输出

```
0
0
1
0
1
2
2
2
2
2
1
3
5
8
5```

# AI分析结果

### 题目内容重写

我们有一个箱子，初始为空。给定 $Q$ 次操作，每次操作可能是以下两种之一：

1. `+ x`：向箱子里添加一个写有整数 $x$ 的球。
2. `- x`：从箱子里移除一个写有整数 $x$ 的球。**保证在操作前箱子里至少有一个写有整数 $x$ 的球。**

每次操作后，求从箱子里取出若干球，使得球上数字之和恰好为 $K$ 的方案数，结果对 $998244353$ 取模。

### 题解综合分析

本题的核心是动态维护一个集合，并在每次操作后快速计算其子集和为 $K$ 的方案数。由于 $Q$ 和 $K$ 的范围较小（$1 \le Q, K \le 5000$），可以使用动态规划（DP）来解决。

#### 算法要点：
1. **动态规划**：使用 $dp[i]$ 表示和为 $i$ 的方案数，初始时 $dp[0] = 1$。
2. **添加操作**：对于 `+ x` 操作，倒序更新 $dp$ 数组，避免重复计算。
3. **删除操作**：对于 `- x` 操作，正序更新 $dp$ 数组，撤销之前添加的贡献。

#### 解决难点：
1. **倒序与正序更新**：添加操作需要倒序更新，而删除操作需要正序更新，以确保每次操作的正确性。
2. **取模处理**：在删除操作中，$dp[i]$ 可能会变为负数，需要通过加模数来保证结果非负。

### 所选高星题解

#### 题解1：Genius_Star (5星)
**关键亮点**：
- 思路清晰，详细解释了添加和删除操作的 DP 转移方程。
- 代码简洁，逻辑明确，易于理解。
- 强调了倒序和正序更新的重要性，避免重复计算。

**核心代码**：
```cpp
if(op=='+'){
    for(int i=k;i>=x;i--)
        dp[i]=(dp[i]+dp[i-x])%mod;
} 
else if(op=='-'){
    for(int i=x;i<=k;i++)
        dp[i]=(dp[i]-dp[i-x]+mod)%mod;
}
```

#### 题解2：Register_int (5星)
**关键亮点**：
- 直接指出本题是“可撤销背包”问题，简化了问题理解。
- 代码简洁，逻辑清晰，易于实现。
- 强调了添加和删除操作的顺序问题。

**核心代码**：
```cpp
if (*opt == '+') 
    for (int i = m; i >= k; i--) dp[i] = (dp[i] + dp[i - k]) % mod;
else 
    for (int i = k; i <= m; i++) dp[i] = (dp[i] - dp[i - k] + mod) % mod;
```

#### 题解3：不知名用户 (4星)
**关键亮点**：
- 详细解释了添加和删除操作的 DP 转移过程。
- 强调了取模操作的重要性，避免了负数问题。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
if(op=='+')
    for(i=k;i>=x;i--)
        f[i] = (f[i] + f[i-x]) % mod;
else
    for(i=x;i<=k;i++)
        f[i] = (f[i] - f[i-x] + mod) % mod;
```

### 最优关键思路或技巧
1. **可撤销背包**：通过倒序和正序更新 DP 数组，实现添加和删除操作的动态维护。
2. **取模处理**：在删除操作中，通过加模数避免负数问题，确保结果正确。
3. **动态规划**：利用 DP 数组快速计算子集和为 $K$ 的方案数。

### 拓展思路
- **类似问题**：可以扩展到多重背包问题，即每个数有多个可选的情况。
- **优化**：如果 $K$ 的范围更大，可以考虑使用生成函数或分治优化。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典 01 背包问题。
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064) - 带有依赖关系的背包问题。
3. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776) - 多重背包问题。

---
处理用时：38.52秒
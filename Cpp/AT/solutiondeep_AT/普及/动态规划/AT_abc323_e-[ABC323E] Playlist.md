# 题目信息

# [ABC323E] Playlist

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_e

高橋君は $ N $ 曲からなるプレイリストを持っています。 曲 $ i $ $ (1\ \leq\ i\ \leq\ N) $ の長さは $ T_i $ 秒です。  
高橋君は時刻 $ 0 $ にプレイリストのランダム再生を開始しました。

ランダム再生では、$ N $ 曲の中から等確率で $ 1 $ つを選びその曲を最後まで再生することが繰り返されます。 ここで、曲の再生は休みなく行われ、$ 1 $ つの曲が終わったらすぐに次に選ばれた曲が始まります。 また、同じ曲が連続して選ばれる事もあります。

時刻 $ 0 $ から $ (X+0.5) $ 秒後に曲 $ 1 $ が再生されている確率を $ \text{mod}998244353 $ で求めてください。

確率 $ \text{mod\ }\ 998244353 $ の定義この問題で求める確率は必ず有理数になることが証明できます。 また、この問題の制約下では、求める確率を既約分数 $ \frac{y}{x} $ で表したときに $ x $ が $ 998244353 $ で割り切れないことが保証されます。

このとき $ xz\ \equiv\ y\ \pmod{998244353} $ を満たすような $ 0 $ 以上 $ 998244352 $ 以下の整数 $ z $ が一意に定まります。この $ z $ を答えてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\leq\ 10^3 $
- $ 0\ \leq\ X\leq\ 10^4 $
- $ 1\ \leq\ T_i\leq\ 10^4 $
- 入力はすべて整数

### Sample Explanation 1

時刻 $ 0 $ から $ 6.5 $ 秒後に曲 $ 1 $ が流れているパターンとしてあり得るのは、 - 曲 $ 1 $ $ \to $ 曲 $ 1 $ $ \to $ 曲 $ 1 $ - 曲 $ 2 $ $ \to $ 曲 $ 1 $ - 曲 $ 3 $ $ \to $ 曲 $ 1 $ の順で音楽が再生された場合であり、これらのいずれかが起こる確率は $ \frac{7}{27} $ となります。 $ 369720131\times\ 27\equiv\ 7\ \pmod{998244353} $ であるため、$ 369720131 $ を出力します。

### Sample Explanation 2

時刻 $ 0 $ から $ 0.5 $ 秒後には最初に再生された曲が再生されているため、求める確率は $ \frac{1}{5} $ となります。 同じ長さの異なる曲が存在することがあることに注意してください。

## 样例 #1

### 输入

```
3 6
3 5 6```

### 输出

```
369720131```

## 样例 #2

### 输入

```
5 0
1 2 1 2 1```

### 输出

```
598946612```

## 样例 #3

### 输入

```
5 10000
1 2 3 4 5```

### 输出

```
586965467```

# AI分析结果

### 题目内容重写

高橋君有一个包含 $N$ 首歌曲的播放列表。第 $i$ 首歌曲的时长为 $T_i$ 秒。高橋君在时刻 $0$ 开始随机播放这些歌曲。

随机播放的规则是：从 $N$ 首歌曲中等概率地选择一首，播放完该歌曲后立即选择下一首，且同一首歌曲可以连续播放多次。

求在时刻 $(X+0.5)$ 秒时，正在播放第 $1$ 首歌曲的概率，结果对 $998244353$ 取模。

### 题解分析与结论

本题的核心是通过动态规划（DP）来计算在特定时刻正在播放某首歌曲的概率。各题解的思路基本一致，主要区别在于状态定义和转移方程的优化。

#### 关键思路与技巧
1. **状态定义**：大多数题解使用 $f_i$ 表示在时刻 $i$ 结束播放某首歌曲的概率，然后通过累加 $f_{i-T_j}$ 来更新 $f_i$。
2. **逆元优化**：由于需要计算 $\frac{1}{n}$ 的模意义下的值，所有题解都使用了快速幂算法来预处理逆元。
3. **时间复杂度优化**：部分题解通过维护一个 $sum$ 数组来减少内层循环的次数，将时间复杂度从 $O(n^2X)$ 优化到 $O(nX)$。

#### 推荐题解
1. **作者：梦应归于何处 (4星)**
   - **关键亮点**：思路清晰，代码简洁，使用了逆元优化，且状态转移方程易于理解。
   - **核心代码**：
     ```cpp
     for (int i = 0; i <= x; i++) {
         for (int j = 1; j <= n; j++) {
             if(i>=t[j]){
                 f[i] = (f[i] + f[i-t[j]] * ni) % mod;
             }
         }
     }
     ```

2. **作者：xiaomuyun (4星)**
   - **关键亮点**：通过维护 $sum$ 数组优化了时间复杂度，代码结构清晰，注释详细。
   - **核心代码**：
     ```cpp
     for (int j = 1; j <= x + t[1]; ++j) {
         for (int i = 1; i <= n; ++i) {
             if (j - t[i] < 0) continue;
             f[i][j] = (f[i][j] + sum[j - t[i]] * inv) % mod;
             sum[j] = (sum[j] + f[i][j]) % mod;
         }
         if (j > x) res = (res + f[1][j]) % mod;
     }
     ```

3. **作者：yydfj (4星)**
   - **关键亮点**：通过预处理 $g$ 数组进一步优化了时间复杂度，代码简洁且高效。
   - **核心代码**：
     ```cpp
     for (int i = 0; i <= X; i++) {
         ll g = 0;
         for (int j = 1; j <= n; j++)
             if (i - a[j] >= 0) g = (g + f[i - a[j]][j] * ni) % mod;
         for (int j = 1; j <= n; j++)
             if (!f[i][j]) f[i][j] = g % mod;
     }
     ```

### 扩展思路与推荐题目
1. **扩展思路**：本题的DP思路可以扩展到其他类似的概率问题，如随机游走、马尔可夫链等。
2. **推荐题目**：
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的背包问题，与本题的DP思路类似。
   - [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)：依赖背包问题，适合进一步练习DP优化。
   - [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)：状态转移与本题类似，适合练习DP的应用。

---
处理用时：34.03秒
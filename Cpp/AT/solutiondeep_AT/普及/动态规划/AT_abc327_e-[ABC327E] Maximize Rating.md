# 题目信息

# [ABC327E] Maximize Rating

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc327/tasks/abc327_e

高橋君は $ N $ 回コンテストに参加し、$ i $ 回目に参加したコンテストにおいてパフォーマンス $ P_i $ を獲得しました。  
高橋君はこの中から ($ 1 $ つ以上) いくつかのコンテストを選び、それらの結果から計算される高橋君のレートを最大にしたいと考えています。

コンテストをうまく選んだとき、高橋君のレートとしてあり得る最大の値を求めてください。

ただし、高橋君のレート $ R $ は、高橋君の選んだコンテストの数が $ k $ 個であり、 選んだコンテストにおけるパフォーマンスが **参加した順に** それぞれ $ (Q_1,Q_2,\ldots,Q_k) $ であるとき、

$ \displaystyle\ R=\frac{\sum_{i=1}^k\ (0.9)^{k-i}Q_i}{\sum_{i=1}^k\ (0.9)^{k-i}}-\frac{1200}{\sqrt{k}} $ によって計算されます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 5000 $
- $ 1\leq\ P_i\leq\ 5000 $
- 入力はすべて整数

### Sample Explanation 1

高橋君が $ 1 $ 回目と $ 3 $ 回目のコンテストを選んだ時、レートは、 $ \displaystyle\ R=\frac{0.9\times\ 1000+\ 1.0\times\ 1200}{0.9+1.0}-\frac{1200}{\sqrt{2}}=256.73502... $ となり、この時レートが最大となります。

### Sample Explanation 2

$ 1,2,3 $ 回目のコンテストすべてを選んだとき、レートが最大となります。

### Sample Explanation 3

レートは負になることもあります。

## 样例 #1

### 输入

```
3
1000 600 1200```

### 输出

```
256.735020470879931```

## 样例 #2

### 输入

```
3
600 1000 1200```

### 输出

```
261.423219407873376```

## 样例 #3

### 输入

```
1
100```

### 输出

```
-1100.000000000000000```

# AI分析结果

### 题目内容重写

高橋君参加了 $N$ 次比赛，第 $i$ 次比赛的表现值为 $P_i$。他需要从这些比赛中选择一些（至少一个）比赛，使得根据这些比赛的表现值计算出的评分 $R$ 最大。

评分 $R$ 的计算公式为：
$$
R = \frac{\sum_{i=1}^k (0.9)^{k-i} Q_i}{\sum_{i=1}^k (0.9)^{k-i}} - \frac{1200}{\sqrt{k}}
$$
其中，$k$ 是选择的比赛数量，$Q_i$ 是按照比赛顺序选择的表现值。

### 题解分析与结论

#### 综合分析
本题的核心在于如何通过动态规划（DP）来优化选择比赛的过程，使得评分 $R$ 最大化。大多数题解都采用了类似的DP思路，即通过枚举选择的比赛数量 $k$，然后计算对应的最大评分。难点在于如何高效地计算 $\sum_{i=1}^k (0.9)^{k-i} Q_i$ 的最大值。

#### 最优关键思路
1. **DP状态定义**：设 $f_{i,j}$ 表示前 $i$ 场比赛中选择 $j$ 场比赛的最大 $\sum_{i=1}^k (0.9)^{k-i} Q_i$ 值。
2. **转移方程**：$f_{i,j} = \max(f_{i-1,j}, f_{i-1,j-1} \times 0.9 + P_i)$，分别表示不选第 $i$ 场比赛和选第 $i$ 场比赛的情况。
3. **预处理**：预处理 $\sum_{i=1}^k (0.9)^{k-i}$ 的值，方便后续计算。

#### 推荐题解
1. **作者：liuhl_weifang (5星)**
   - **关键亮点**：清晰地定义了DP状态和转移方程，代码简洁且易于理解。通过预处理 $\sum_{i=1}^k (0.9)^{k-i}$ 的值，减少了重复计算。
   - **代码核心**：
     ```cpp
     for (int i=1;i<=n;i++) {
         for (int j=1;j<=i;j++) {
             f[i][j] = max(f[i-1][j],f[i-1][j-1]*0.9+a[i]);
         }
     }
     ```

2. **作者：yydfj (4星)**
   - **关键亮点**：通过将数组反转，简化了系数的计算，使得DP转移更加直观。代码结构清晰，易于理解。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=n;i++) {
         for(int j=i;j>=1;j--) {
             f[j]=max(f[j],f[j-1]+p[i]*kk[j]);
             ans=max(ans,f[j]/sum[j]-1200.0/sqrt(j));
         }
     }
     ```

3. **作者：2huk (4星)**
   - **关键亮点**：详细解释了DP转移的过程，特别是如何处理系数的变化。代码实现较为复杂，但思路清晰。
   - **代码核心**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         for (int j = 1; j <= i; j++) {
             f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] * 0.9 + a[i]);
         }
     }
     ```

### 扩展思路与推荐题目
1. **扩展思路**：本题的DP思路可以推广到其他类似的优化问题，特别是在需要选择子集并计算某种加权和的情况下。类似的思路还可以用于解决背包问题、序列选择问题等。
2. **推荐题目**：
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)
   - [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
   - [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

这些题目都涉及到通过DP来优化选择过程，适合进一步练习和巩固相关算法。

---
处理用时：38.01秒
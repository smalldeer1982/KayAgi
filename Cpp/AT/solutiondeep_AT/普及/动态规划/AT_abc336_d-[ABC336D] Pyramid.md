# 题目信息

# [ABC336D] Pyramid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc336/tasks/abc336_d

正の整数 $ k $ について、サイズ $ k $ の **ピラミッド数列** とは、長さ $ (2k-1) $ の数列であって各項の値が順に $ 1,2,\ldots,k-1,k,k-1,\ldots,2,1 $ であるようなものをさします。

長さ $ N $ の数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられます。  
 $ A $ に対して、次の操作のうち一方を選んで行うことを繰り返して ($ 0 $ 回でも良い) 得ることのできるピラミッド数列のサイズの最大値を求めてください。

- 数列の項を $ 1 $ つ選び、その項の値を $ 1 $ 減少させる。
- 先頭または末尾の項を削除する。
 
なお、問題の制約のもとで、操作を繰り返すことで必ず $ 1 $ 種類以上のピラミッド数列を得ることができることが証明できます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

$ A=(2,2,3,1,1) $ から始めて、 次のようにして数列 $ A $ からサイズ $ 2 $ のピラミッド数列を作る事ができます。 - 第 $ 3 $ 項を選び、$ 1 $ 減少させる。数列は $ A=(2,2,2,1,1) $ となる。 - 先頭を削除する。数列は $ A=(2,2,1,1) $ となる。 - 末尾を削除する。数列は $ A=(2,2,1) $ となる。 - 第 $ 1 $ 項を選び、$ 1 $ 減少させる。数列は $ A=(1,2,1) $ となる。 $ (1,2,1) $ はサイズ $ 2 $ のピラミッド数列です。 一方、どのように操作を行ってもサイズ $ 3 $ 以上のピラミッド数列を作ることはできないため $ 2 $ を出力します。

## 样例 #1

### 输入

```
5

2 2 3 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
5

1 2 3 4 5```

### 输出

```
3```

## 样例 #3

### 输入

```
1

1000000000```

### 输出

```
1```

# AI分析结果

### 题目内容重写

【题目描述】

正の整数 $ k $ について、サイズ $ k $ の **ピラミッド数列** とは、長さ $ (2k-1) $ の数列であって各項の値が順に $ 1,2,\ldots,k-1,k,k-1,\ldots,2,1 $ であるようなものをさします。

長さ $ N $ の数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられます。  
 $ A $ に対して、次の操作のうち一方を選んで行うことを繰り返して ($ 0 $ 回でも良い) 得ることのできるピラミッド数列のサイズの最大値を求めてください。

- 数列の項を $ 1 $ つ選び、その項の値を $ 1 $ 減少させる。
- 先頭または末尾の項を削除する。
 
なお、問題の制約のもとで、操作を繰り返すことで必ず $ 1 $ 種類以上のピラミッド数列を得ることができることが証明できます。

### 题解分析与结论

本题的核心在于通过操作将给定数列转化为金字塔数列，并找到最大可能的金字塔数列大小。多数题解采用了动态规划（DP）的思路，通过维护两个数组分别记录从左到右和从右到左的金字塔序列的最大长度，最终取两者的最小值作为当前点的金字塔高度，再求全局最大值。

### 精选题解

1. **作者：__Allen_123__ (赞：15)**  
   - **星级：5星**  
   - **关键亮点**：通过定义左金字塔序列和右金字塔序列，巧妙地利用DP状态转移方程，分别从前往后和从后往前扫描，最终求出每个点的最大金字塔高度。思路清晰，代码简洁，时间复杂度为O(n)。  
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++) f[i] = min(f[i-1] + 1, a[i]);
     for(int i = n; i >= 1; i--) g[i] = min(g[i+1] + 1, a[i]);
     for(int i = 1; i <= n; i++) ans = max(ans, min(f[i], g[i]));
     ```

2. **作者：BIG_CUTE_BUG (赞：6)**  
   - **星级：4星**  
   - **关键亮点**：通过递推的方式分别求出每个点的左金字塔和右金字塔的最大长度，最终取两者的最小值作为当前点的金字塔高度。思路与上一题解类似，但代码实现略有不同，同样时间复杂度为O(n)。  
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++) q[i] = min(q[i-1] + 1, a[i]);
     for(int i = n; i >= 1; i--) p[i] = min(p[i+1] + 1, a[i]);
     for(int i = 1; i <= n; i++) ans = max(min(p[i], q[i]), ans);
     ```

3. **作者：yhx0322 (赞：2)**  
   - **星级：4星**  
   - **关键亮点**：通过维护两个数组分别记录从左到右和从右到左的金字塔序列的最大长度，最终取两者的最小值作为当前点的金字塔高度。思路清晰，代码简洁，时间复杂度为O(n)。  
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++) f[i] = min(f[i-1] + 1, a[i]);
     for(int i = n; i >= 1; i--) g[i] = min(g[i+1] + 1, a[i]);
     for(int i = 1; i <= n; i++) ans = max(ans, min(f[i], g[i]));
     ```

### 最优关键思路与技巧

1. **动态规划（DP）**：通过维护两个数组分别记录从左到右和从右到左的金字塔序列的最大长度，最终取两者的最小值作为当前点的金字塔高度。
2. **状态转移方程**：`f[i] = min(f[i-1] + 1, a[i])` 和 `g[i] = min(g[i+1] + 1, a[i])`，分别表示从左到右和从右到左的金字塔序列的最大长度。
3. **时间复杂度优化**：通过一次扫描即可完成计算，时间复杂度为O(n)，适用于大规模数据。

### 拓展与举一反三

1. **类似题目**：
   - [洛谷P1880 石子合并](https://www.luogu.com.cn/problem/P1880)
   - [洛谷P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
   - [洛谷P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)

2. **个人心得**：在动态规划问题中，状态转移方程的设计是关键。通过将问题分解为子问题，并利用已知的子问题解来求解当前问题，可以有效地降低问题的复杂度。此外，对于对称性问题，可以考虑从两个方向分别求解，最后合并结果。

---
处理用时：42.48秒
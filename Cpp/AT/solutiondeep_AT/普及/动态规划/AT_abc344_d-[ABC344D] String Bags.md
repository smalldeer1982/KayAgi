# 题目信息

# [ABC344D] String Bags

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc344/tasks/abc344_d

あなたは最初、空文字列 $ S $ を持っています。  
 さらに、文字列がいくつか入った袋 $ 1,2,\dots,N $ があります。  
 袋 $ i $ には $ A_i $ 個の文字列 $ S_{i,1},S_{i,2},\dots,S_{i,A_i} $ が入っています。

これから、以下の手順を $ i=1,2,\dots,N $ について繰り返します。

- 以下のふたつの行動のうち、どちらかを選択して行う。
  - $ 1 $ 円を支払い、袋 $ i $ からちょうどひとつの文字列を選択して $ S $ の末尾に連結する。
  - 何もしない。
 
文字列 $ T $ が与えられるとき、最終的に $ S $ と $ T $ を一致させるために必要な最小の金額を求めてください。  
 但し、どのようにしても最終的な $ S $ を $ T $ に一致させることができない場合、 `-1` と出力してください。

## 说明/提示

### 制約

- $ T $ は長さ $ 1 $ 以上 $ 100 $ 以下の英小文字からなる文字列
- $ N $ は $ 1 $ 以上 $ 100 $ 以下の整数
- $ A_i $ は $ 1 $ 以上 $ 10 $ 以下の整数
- $ S_{i,j} $ は長さ $ 1 $ 以上 $ 10 $ 以下の英小文字からなる文字列
 
### Sample Explanation 1

例えば、以下のようにすると $ 2 $ 円で最終的な $ S $ と $ T $ を一致させることができ、これが必要な金額の最低値であることが示せます。 - $ i=1 $ について、袋 $ 1 $ から `abc` を選択し $ S $ の末尾に連結する。 $ S= $ `abc` となる。 - $ i=2 $ について、何もしない。 - $ i=3 $ について、袋 $ 3 $ から `de` を選択し $ S $ の末尾に連結する。 $ S= $ `abcde` となる。

### Sample Explanation 2

どのようにしても最終的な $ S $ と $ T $ を一致させることができないので、 `-1` と出力してください。

## 样例 #1

### 输入

```
abcde

3

3 ab abc abcd

4 f c cd bcde

2 e de```

### 输出

```
2```

## 样例 #2

### 输入

```
abcde

3

2 ab abc

3 f c bcde

1 e```

### 输出

```
-1```

## 样例 #3

### 输入

```
aaabbbbcccc

6

2 aa aaa

2 dd ddd

2 ab aabb

4 bbaa bbbc bbb bbcc

2 cc bcc

3 ccc cccc ccccc```

### 输出

```
4```

# AI分析结果

### 题目内容重写
你最初拥有一个空字符串 $S$。此外，还有编号为 $1,2,\dots,N$ 的袋子，每个袋子中包含一些字符串。袋子 $i$ 中包含 $A_i$ 个字符串 $S_{i,1},S_{i,2},\dots,S_{i,A_i}$。

接下来，对于 $i=1,2,\dots,N$，重复以下步骤：

- 选择以下两种操作之一：
  - 支付 $1$ 日元，从袋子 $i$ 中选择一个字符串并将其连接到 $S$ 的末尾。
  - 什么也不做。

给定一个字符串 $T$，求最终使 $S$ 与 $T$ 一致所需的最小金额。如果无论如何都无法使 $S$ 与 $T$ 一致，则输出 `-1`。

### 综合分析与结论
本题是一个典型的分组背包问题，核心思路是通过动态规划（DP）来求解最小花费。大多数题解都采用了 DP 的思路，状态设计为 $dp_{i,j}$，表示前 $i$ 个袋子中拼出 $T$ 的前 $j$ 个字符所需的最小花费。难点在于如何高效地判断当前选择的字符串是否能够与 $T$ 的某一部分匹配，并确保每个袋子只能选择一个字符串。

### 所选高星题解

#### 1. 题解作者：CodingOIer (★★★★☆)
**关键亮点**：
- 状态定义清晰，$dp_{i,j}$ 表示前 $i$ 个袋子中拼出 $T$ 的前 $j$ 个字符的最小花费。
- 通过 `check` 函数判断字符串是否匹配，代码结构清晰。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= l; j++) {
        dp[i][j] = dp[i - 1][j];
        for (auto &k : p[i]) {
            if (k.size() > j || !check(j, k)) continue;
            dp[i][j] = std::min(dp[i][j], dp[i - 1][j - k.size()] + 1);
        }
    }
}
```

#### 2. 题解作者：coderJerry (★★★★☆)
**关键亮点**：
- 使用一维 DP 数组优化空间复杂度，$dp[x]$ 表示拼出 $T$ 的前 $x$ 个字符的最小花费。
- 通过 `substr` 函数快速判断字符串匹配，代码简洁高效。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = len; j >= 1; j--) {
        for (int u = 1; u <= a[i]; u++) {
            int k = s[i][u].size();
            if (j - k >= 0 && t.substr(j - k, k) == s[i][u] && dp[j - k] != -1) {
                int tmp = dp[j - k] + 1;
                if (dp[j] == -1 || dp[j] > tmp) dp[j] = tmp;
            }
        }
    }
}
```

#### 3. 题解作者：FBW2010 (★★★★☆)
**关键亮点**：
- 使用 DFS 结合剪枝优化，避免了纯暴力的高时间复杂度。
- 通过 `f` 数组记录状态，避免重复搜索，思路新颖。

**核心代码**：
```cpp
void DFS(int x, int sum, string k) {
    if (x > n) {
        if (k == t) ans = min(ans, sum);
        return;
    }
    if (sum >= ans || sum >= f[x][k.size()]) return;
    f[x][k.size()] = sum;
    for (int i = 1; i <= a[x]; i++) {
        string p = k + s[x][i];
        if (p.size() <= t.size() && p == t.substr(0, p.size())) {
            DFS(x + 1, sum + 1, p);
        }
    }
    DFS(x + 1, sum, k);
}
```

### 最优关键思路
- **状态设计**：使用 $dp_{i,j}$ 表示前 $i$ 个袋子中拼出 $T$ 的前 $j$ 个字符的最小花费。
- **匹配判断**：通过 `substr` 或自定义 `check` 函数快速判断字符串是否匹配。
- **剪枝优化**：在 DFS 中通过记录状态避免重复搜索，提升效率。

### 可拓展之处
- **分组背包问题**：类似题目可以通过分组背包的思路解决，如 [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)。
- **字符串匹配优化**：可以进一步优化字符串匹配的效率，如使用 KMP 算法。

### 推荐题目
1. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)

### 个人心得摘录
- **调试经历**：部分题解提到在调试过程中发现状态转移方程的错误，提醒我们在 DP 中要仔细检查状态转移条件。
- **踩坑教训**：有题解提到忘记每个袋子只能选择一个字符串，导致 WA，提醒我们在设计 DP 状态时要考虑所有限制条件。

---
处理用时：45.13秒
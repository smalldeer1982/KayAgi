# 题目信息

# [ABC346D] Gomamayo Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc346/tasks/abc346_d

`0`, `1` からなる長さ $ N $ の文字列 $ S $ が与えられます。

`0`, `1` からなる長さ $ N $ の文字列 $ T $ は以下の条件を満たすとき、またそのときに限り **良い文字列** であると定義します。

- $ 1\ \leq\ i\ \leq\ N\ -\ 1 $ を満たす整数 $ i $ であって、$ T $ の $ i $ 文字目と $ i\ +\ 1 $ 文字目が一致するようなものがちょうど $ 1 $ つ存在する。
 
$ i\ =\ 1,2,\ldots,\ N $ について以下の操作を $ 1 $ 度行うか行わないか選ぶことができます。

- $ S $ の $ i $ 文字目が `0` であるとき $ S $ の $ i $ 文字目を `1` に、そうでないとき $ S $ の $ i $ 文字目を `0` に置き換える。操作を行った場合、$ C_i $ のコストがかかる。
 
$ S $ を良い文字列にするために必要なコストの総和の最小値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ S $ は長さ $ N $ の `0`,`1` からなる文字列
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- $ N,\ C_i $ は整数
 
### Sample Explanation 1

$ i\ =\ 1,\ 5 $ に対して操作を行い、$ i\ =\ 2,\ 3,\ 4 $ に対して操作を行わないことで $ S\ = $ `10010` となり、$ S $ は良い文字列となります。このときかかるコストは $ 7 $ であり、コスト $ 7 $ 未満で $ S $ を良い文字列にすることはできないため、$ 7 $ を出力します。

## 样例 #1

### 输入

```
5

00011

3 9 2 6 4```

### 输出

```
7```

## 样例 #2

### 输入

```
4

1001

1 2 3 4```

### 输出

```
0```

## 样例 #3

### 输入

```
11

11111100111

512298012 821282085 543342199 868532399 690830957 973970164 928915367 954764623 923012648 540375785 925723427```

### 输出

```
2286846953```

# AI分析结果

### 题目内容重写

给定一个由 `0` 和 `1` 组成的长度为 $N$ 的字符串 $S$。定义字符串 $T$ 为**好的字符串**，当且仅当存在**恰好一个** $i$（$1 \leq i \leq N - 1$），使得 $T$ 的第 $i$ 个字符与第 $i+1$ 个字符相同。对于每个字符 $i$，可以选择是否将其取反（`0` 变 `1`，`1` 变 `0`），取反的代价为 $C_i$。求将 $S$ 变成**好的字符串**所需的最小总代价。

### 题解分析与结论

本题的核心是通过动态规划（DP）或前缀和优化来解决。大多数题解采用了DP的思路，通过状态转移来记录当前字符的状态以及是否已经存在相邻字符相同的情况。部分题解还通过预处理前缀和后缀来优化计算。

#### 最优关键思路与技巧

1. **动态规划状态设计**：大多数题解使用了 $f_{i,j,k}$ 的状态设计，其中 $i$ 表示当前处理到的字符位置，$j$ 表示当前字符的状态（`0` 或 `1`），$k$ 表示是否已经存在相邻字符相同的情况。这种状态设计能够有效地记录和处理问题中的约束条件。

2. **前缀和优化**：部分题解通过预处理前缀和后缀来快速计算不同状态下的代价，从而避免了重复计算，提升了效率。

3. **分类讨论**：在转移过程中，题解通常根据当前字符与前一个字符是否相同来进行分类讨论，确保状态转移的正确性。

### 精选题解

#### 题解1：作者：2huk (赞：12)
- **星级**：★★★★★
- **关键亮点**：状态设计清晰，转移方程简洁明了，代码可读性强。
- **核心代码**：
  ```cpp
  f[i][0][0] = f[i - 1][1][0] + (s[i] == '1') * c[i];
  f[i][1][0] = f[i - 1][0][0] + (s[i] == '0') * c[i];
  f[i][0][1] = min(f[i - 1][1][1], f[i - 1][0][0]) + (s[i] == '1') * c[i];
  f[i][1][1] = min(f[i - 1][0][1], f[i - 1][1][0]) + (s[i] == '0') * c[i];
  ```
- **个人心得**：通过枚举上一位的状态来简化转移，减少了代码复杂度。

#### 题解2：作者：KSCD_ (赞：4)
- **星级**：★★★★
- **关键亮点**：状态转移详细，边界条件处理得当，代码结构清晰。
- **核心代码**：
  ```cpp
  f[i][0][a[i]] = f[i - 1][!a[i]][0];
  f[i][1][a[i]] = min(f[i - 1][!a[i]][1], f[i - 1][a[i]][0]);
  f[i][0][!a[i]] = f[i - 1][a[i]][0] + c[i];
  f[i][1][!a[i]] = min(f[i - 1][a[i]][1], f[i - 1][!a[i]][0]) + c[i];
  ```
- **个人心得**：通过增加状态维度来解决转移时的复杂问题，确保了算法的正确性。

#### 题解3：作者：JuRuoOIer (赞：3)
- **星级**：★★★★
- **关键亮点**：提供了DP和简单扫描两种解法，思路多样，适合不同水平的读者。
- **核心代码**：
  ```cpp
  dp[i][1][0] = min(dp[i][1][0], dp[i - 1][0][0] + a[i]);
  dp[i][0][0] = min(dp[i][0][0], dp[i - 1][1][0]);
  dp[i][0][1] = min(dp[i][0][1], min(dp[i - 1][0][0], dp[i - 1][1][1]));
  dp[i][1][1] = min(dp[i][1][1], min(dp[i - 1][0][1], dp[i - 1][1][0]) + a[i]);
  ```
- **个人心得**：通过分情况讨论，确保了状态转移的正确性，代码逻辑清晰。

### 推荐题目
1. [P1043 数字游戏](https://www.luogu.com.cn/problem/P1043) - 考察动态规划的状态设计与转移。
2. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063) - 动态规划与区间DP的结合。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 动态规划与状态转移的应用。

---
处理用时：44.79秒
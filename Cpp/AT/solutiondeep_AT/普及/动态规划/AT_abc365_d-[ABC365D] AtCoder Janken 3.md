# 题目信息

# [ABC365D] AtCoder Janken 3

## 题目描述

高桥和青木玩了 $N$ 次石头剪刀布。注：在这个游戏中，石头赢剪刀，剪刀赢纸，纸赢石头。

青木的动作由长度为 $N$ 的字符串 $S$ 表示，字符串由 `R`、`P` 和 `S` 组成。$S$ 中的第 $i$ 个字符表示青木在第 $i$ 盘棋局中的棋步：`R` 表示石头，`P` 表示 纸，`S` 表示剪刀。

高桥的棋步满足以下条件：

- 高桥从未输给过青木。
- 对于 $i=1,2,…,N−1$，高桥在第 $i$ 对局中的棋步与他在第 $i+1$ 对局中的棋步不同。

求高桥可能赢的最大对局数。

可以保证存在一个满足上述条件的高桥下棋顺序。

## 说明/提示

$1 \le n \le 2\times 10^5$

## 样例 #1

### 输入

```
6

PRSSRS```

### 输出

```
5```

## 样例 #2

### 输入

```
10

SSSSSSSSSS```

### 输出

```
5```

## 样例 #3

### 输入

```
24

SPRPSRRRRRPPRPRPSSRSPRSS```

### 输出

```
18```

# AI分析结果

### 题目内容重写
高桥和青木玩了 $N$ 次石头剪刀布。注：在这个游戏中，石头赢剪刀，剪刀赢纸，纸赢石头。

青木的动作由长度为 $N$ 的字符串 $S$ 表示，字符串由 `R`、`P` 和 `S` 组成。$S$ 中的第 $i$ 个字符表示青木在第 $i$ 盘棋局中的棋步：`R` 表示石头，`P` 表示 纸，`S` 表示剪刀。

高桥的棋步满足以下条件：

- 高桥从未输给过青木。
- 对于 $i=1,2,…,N−1$，高桥在第 $i$ 对局中的棋步与他在第 $i+1$ 对局中的棋步不同。

求高桥可能赢的最大对局数。

可以保证存在一个满足上述条件的高桥下棋顺序。

### 说明/提示
$1 \le n \le 2\times 10^5$

### 样例 #1
#### 输入
```
6
PRSSRS
```
#### 输出
```
5
```

### 样例 #2
#### 输入
```
10
SSSSSSSSSS
```
#### 输出
```
5
```

### 样例 #3
#### 输入
```
24
SPRPSRRRRRPPRPRPSSRSPRSS
```
#### 输出
```
18
```

---

### 题解分析与结论

本题的核心是通过动态规划（DP）来解决，大多数题解都采用了类似的思路，即定义状态 $dp[i][j]$ 表示在第 $i$ 局中出 $j$ 手势时的最大胜局数，并根据对手的出法进行状态转移。难点在于如何正确处理“不输”和“相邻两局手势不同”的约束条件。

#### 最优关键思路：
1. **状态定义**：定义 $dp[i][j]$ 表示在第 $i$ 局中出 $j$ 手势时的最大胜局数，其中 $j$ 表示石头、布或剪刀。
2. **状态转移**：根据对手的出法，决定当前局是平局还是胜利，并且确保相邻两局的手势不同。
3. **边界条件**：初始化第一局的状态，根据对手的第一局出法进行初始化。
4. **最终答案**：取最后一局中所有可能手势的最大值。

#### 推荐题解：
1. **作者：xhxxwcr**  
   - **星级**：4.5  
   - **关键亮点**：详细解释了贪心策略的局限性，并给出了清晰的DP转移方程，代码简洁且易于理解。  
   - **个人心得**：作者提到由于一个0写成了1导致WA，强调了调试的重要性。

2. **作者：wo_hen_la**  
   - **星级**：4  
   - **关键亮点**：状态定义清晰，转移方程简洁，代码实现高效，适合初学者理解。  
   - **个人心得**：作者通过简单的状态转移实现了高效的DP，适合快速上手。

3. **作者：Pink_Cut_Tree**  
   - **星级**：4  
   - **关键亮点**：通过定义 $dp[i][j]$ 表示前 $i$ 局出 $j$ 手势的最大胜局数，转移方程简洁明了，代码实现高效。  
   - **个人心得**：作者强调了“后效性”的处理，帮助读者更好地理解DP的核心思想。

#### 核心代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[200010];
int dp[200010][2]; // 1:赢,0:平
int main(){
    int n,ans;
    cin >> n;
    dp[1][1] = 1;
    for(int i = 1;i <= n;i++){
        cin >> s[i];
    }
    for(int i = 2;i <= n;i++){
        if(s[i - 1] == s[i]){
            dp[i][1] = dp[i - 1][0] + 1;
            dp[i][0] = dp[i - 1][1];
        }else{
            dp[i][1] = dp[i - 1][1] + 1;
            dp[i][0] = dp[i - 1][0];
            if(!((s[i - 1] == 'P' && s[i] == 'S')||(s[i - 1] == 'S' && s[i] == 'R')||(s[i - 1] == 'R' && s[i] == 'P'))){
                dp[i][0] = max(dp[i][0],dp[i - 1][1]);
            }
            if(!((s[i] == 'P' && s[i - 1] == 'S')||(s[i] == 'S' && s[i - 1] == 'R')||(s[i] == 'R' && s[i - 1] == 'P'))){
                dp[i][1] = max(dp[i][1],dp[i - 1][0] + 1);
            }
        }
    }
    cout << max(dp[n][1],dp[n][0]);
}
```

### 拓展思路与类似题目
1. **类似题目**：
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的背包问题，与本题的DP思路类似。
   - [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：涉及状态转移的DP问题，适合练习。
   - [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)：涉及前后状态的DP问题，与本题的约束条件类似。

2. **调试心得**：在DP问题中，边界条件和状态转移方程的细节非常重要，调试时应特别注意初始化和转移条件的正确性。

---
处理用时：61.32秒
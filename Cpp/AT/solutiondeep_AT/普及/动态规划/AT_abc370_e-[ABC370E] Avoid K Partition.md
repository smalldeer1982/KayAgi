# 题目信息

# [ABC370E] Avoid K Partition

## 题目描述

给出长度为 $N$ 的序列 $A=(A_1,A_2,\dots,A_N)$ 以及一个整数 $K$。

存在 $2^{N-1}$ 种方法将 $A$ 分成若干个连续子区间。有多少划分方法满足没有任何一个划分出的子区间元素和为 $K$？请输出这个值模 $998244353$ 的结果。

这里，“将 $A$ 分成若干个连续子区间”的含义如下：

- 随意选择一个整数 $k\space 1\le k\le N$ 作为序列长度，并且随意选择一个满足条件 $1=i_1<i_2<\dots<i_k<i_{k+1}=N+1$ 的整数序列 $(i_1,i_2,\dots,i_k,i_{k+1})$。
- 对于每个满足 $1\le n\le k$ 的整数 $n$，第 $n$ 个被划分出来的子区间是由提取序列 $A$ 中的第 $i_n$ 到第 $(i_{n+1}-1)$ 个元素得到的。

举个例子，以下是序列 $A=(1,2,3,4,5)$ 的若干可行划分方案：

- $(1,2,3),(4),(5)$
- $(1,2),(3,4,5)$
- $(1,2,3,4,5)$

## 说明/提示

- $1 \leq N \leq 2 \times 10^5$
- $-10^{15} \leq K \leq 10^{15}$
- $-10^9 \leq A_i \leq 10^9$
- 全部输入为整数

#### 对样例 1 的解释

以下是符合题目要求的 $2$ 种划分方案。

- $(1),(2,3)$
- $(1,2,3)$

Author: [Redshift_Shine](/user/475403)

## 样例 #1

### 输入

```
3 3

1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5 0

0 0 0 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
10 5

-5 -1 -7 6 -6 -2 -5 10 2 -10```

### 输出

```
428```

# AI分析结果

### 题目翻译

给定长度为 $N$ 的序列 $A=(A_1,A_2,\dots,A_N)$ 以及一个整数 $K$。

存在 $2^{N-1}$ 种方法将 $A$ 分成若干个连续子区间。有多少划分方法满足没有任何一个划分出的子区间元素和为 $K$？请输出这个值模 $998244353$ 的结果。

这里，“将 $A$ 分成若干个连续子区间”的含义如下：

- 随意选择一个整数 $k\space 1\le k\le N$ 作为序列长度，并且随意选择一个满足条件 $1=i_1<i_2<\dots<i_k<i_{k+1}=N+1$ 的整数序列 $(i_1,i_2,\dots,i_k,i_{k+1})$。
- 对于每个满足 $1\le n\le k$ 的整数 $n$，第 $n$ 个被划分出来的子区间是由提取序列 $A$ 中的第 $i_n$ 到第 $(i_{n+1}-1)$ 个元素得到的。

举个例子，以下是序列 $A=(1,2,3,4,5)$ 的若干可行划分方案：

- $(1,2,3),(4),(5)$
- $(1,2),(3,4,5)$
- $(1,2,3,4,5)$

### 说明/提示

- $1 \leq N \leq 2 \times 10^5$
- $-10^{15} \leq K \leq 10^{15}$
- $-10^9 \leq A_i \leq 10^9$
- 全部输入为整数

#### 对样例 1 的解释

以下是符合题目要求的 $2$ 种划分方案。

- $(1),(2,3)$
- $(1,2,3)$

### 样例 #1

#### 输入

```
3 3

1 2 3
```

#### 输出

```
2
```

### 样例 #2

#### 输入

```
5 0

0 0 0 0 0
```

#### 输出

```
0
```

### 样例 #3

#### 输入

```
10 5

-5 -1 -7 6 -6 -2 -5 10 2 -10
```

#### 输出

```
428
```

---

### 题解分析与结论

本题的核心是通过动态规划（DP）来计算合法的划分方案数。大多数题解都采用了类似的思路：使用前缀和来快速判断子区间的和是否为 $K$，并通过 `map` 或 `unordered_map` 来记录前缀和对应的方案数，从而优化时间复杂度。

#### 关键思路与技巧

1. **前缀和优化**：通过前缀和 $s_i$ 来快速计算任意子区间的和，避免重复计算。
2. **动态规划转移**：定义 $f_i$ 表示前 $i$ 个元素的合法划分方案数，转移时通过前缀和和 `map` 来排除不合法的方案。
3. **数据结构优化**：使用 `map` 或 `unordered_map` 来记录前缀和对应的方案数，优化查询和更新操作。

#### 推荐题解

1. **沉石鱼惊旋 (5星)**
   - **关键亮点**：通过 `map` 记录前缀和对应的方案数，优化了时间复杂度，代码简洁清晰。
   - **代码核心**：
     ```cpp
     map<ll, Z> mp;
     ll sum;
     Z tot;
     int main() {
         cin >> n >> k;
         mp[0] = 1;
         tot = 1;
         for (int i = 1; i <= n; i++) {
             ll x; cin >> x;
             sum += x;
             Z add = tot - (mp.count(sum - k) ? mp[sum - k] : 0);
             mp[sum] += add;
             tot += add;
             if (i == n) return cout << add << endl, 0;
         }
     }
     ```

2. **osfly (4星)**
   - **关键亮点**：使用 `unordered_map` 来记录前缀和对应的方案数，代码简洁且易于理解。
   - **代码核心**：
     ```cpp
     unordered_map<ll, ll> mp;
     int main() {
         scanf("%d%lld", &n, &k);
         for (int i = 1; i <= n; i++) scanf("%lld", &a[i]), pre[i] = pre[i - 1] + a[i];
         dp[0] = sum = mp[0] = 1;
         for (int i = 1; i <= n; i++) {
             dp[i] = (((sum - mp[pre[i] - k]) % mod) + mod) % mod;
             sum = (sum + dp[i]) % mod;
             mp[pre[i]] += dp[i];
         }
         printf("%lld", dp[n]);
     }
     ```

3. **StayAlone (4星)**
   - **关键亮点**：通过 `map` 记录前缀和对应的方案数，代码简洁且易于理解。
   - **代码核心**：
     ```cpp
     map<ll, ll> cnt;
     int main() {
         read(n, k); rer(i, 1, n, a);
         ll s = cnt[0] = f[0] = 1;
         rep1(i, 1, n) {
             (f[i] = s - cnt[(sum += a[i]) - k] + mod) %= mod;
             (cnt[sum] += f[i]) %= mod; (s += f[i]) %= mod;
         } printf("%lld", f[n]);
     }
     ```

#### 可拓展之处

1. **类似题目**：可以扩展到其他需要快速计算子区间和的问题，如求子区间和的最大值、最小值等。
2. **数据结构优化**：可以尝试使用其他数据结构（如平衡树）来进一步优化查询和更新操作。

#### 推荐题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

#### 个人心得摘录

- **沉石鱼惊旋**：通过 `map` 记录前缀和对应的方案数，优化了时间复杂度，代码简洁清晰。
- **osfly**：使用 `unordered_map` 来记录前缀和对应的方案数，代码简洁且易于理解。
- **StayAlone**：通过 `map` 记录前缀和对应的方案数，代码简洁且易于理解。

---
处理用时：50.85秒
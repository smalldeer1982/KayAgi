# 题目信息

# [ABC381D] 1122 Substring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc381/tasks/abc381_d

正整数からなる（空でも良い）数列 $ X=(X_1,X_2,\ldots) $ が以下の $ 3 $ つの条件をすべてみたすとき、かつそのときに限り、$ X $ を **1122 数列** と呼びます。  
（1122 数列の定義はF問題と共通です。）

- $ \lvert\ X\ \rvert $ は偶数である。ここで、$ \lvert\ X\ \rvert $ は $ X $ の長さを表す。
- $ 1\leq\ i\leq\ \frac{\lvert\ X\ \rvert}{2} $ をみたす整数 $ i $ について、$ X_{2i-1} $ と $ X_{2i} $ は等しい。
- 各正整数は $ X $ に現れないか、ちょうど $ 2 $ 回現れるかのどちらかである。すなわち、$ X $ に含まれる正整数は $ X $ にちょうど $ 2 $ 回ずつ登場する。

正整数からなる長さ $ N $ の数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられるので、$ A $ の **連続する部分列** であって、1122 数列であるようなもののうち最長のものの長さを出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ N $
- 入力はすべて整数

### Sample Explanation 1

例えば $ A $ の $ 3 $ 項目から $ 6 $ 項目までの連続部分列をとると $ (1,1,2,2) $ となりますが、これは長さが $ 4 $ の 1122 数列となっています。 これより長い部分列であって、1122 数列の条件をみたすようなものは存在しないため、$ 4 $ を出力します。

### Sample Explanation 3

項数が $ 0 $ の列も 1122 数列の条件をみたしていることに注意してください。

## 样例 #1

### 输入

```
8
2 3 1 1 2 2 1 1```

### 输出

```
4```

## 样例 #2

### 输入

```
3
1 2 2```

### 输出

```
2```

## 样例 #3

### 输入

```
1
1```

### 输出

```
0```

# AI分析结果

### 题目内容重写
【题目描述】  
给定一个由正整数组成的长度为 $N$ 的序列 $A=(A_1,A_2,\ldots,A_N)$，要求找出 $A$ 中最长的连续子序列，使得该子序列满足以下条件：  
1. 子序列的长度为偶数。  
2. 对于所有 $1 \leq i \leq \frac{|X|}{2}$，有 $X_{2i-1} = X_{2i}$。  
3. 每个正整数要么不出现在子序列中，要么恰好出现两次。  

输出满足条件的最长子序列的长度。

【输入格式】  
第一行输入一个整数 $N$，表示序列的长度。  
第二行输入 $N$ 个整数，表示序列 $A$。

【输出格式】  
输出一个整数，表示最长的满足条件的子序列的长度。

【样例输入】  
```
8
2 3 1 1 2 2 1 1
```

【样例输出】  
```
4
```

【样例解释】  
例如，取 $A$ 的第 3 到第 6 个元素，得到子序列 $(1,1,2,2)$，这是一个长度为 4 的 1122 数列。没有比这更长的满足条件的子序列，因此输出 4。

### 题解分析与结论

#### 综合分析与结论
该题的核心是寻找满足特定条件的连续子序列，且要求时间复杂度为 $O(n)$。大多数题解采用了双指针或滑动窗口的思路，结合哈希表或数组来记录元素出现的次数或位置，确保每个元素只出现两次。部分题解还通过分类讨论（奇数位和偶数位）来避免遗漏某些情况。

#### 最优关键思路
1. **双指针 + 哈希表**：通过双指针维护一个滑动窗口，结合哈希表记录元素出现的次数或位置，确保窗口内的元素满足条件。
2. **分类讨论**：分别从奇数位和偶数位开始遍历，避免遗漏某些情况。
3. **单调性优化**：利用窗口的单调性，确保每次移动指针时都能快速更新窗口内的状态。

#### 推荐题解
1. **作者：chenxi2009 (赞：13)**  
   - **星级**：5星  
   - **关键亮点**：代码简洁，思路清晰，通过一个指针维护窗口的左边界，避免了复杂的分类讨论。  
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i++){
         if(a[i] == a[i + 1]) l = std::max(l, lst[a[i]] + 1), ans = std::max(ans, i - l + 2);
         if(a[i] != a[i - 1] && a[i] != a[i + 1]) l = i + 1;
         lst[a[i]] = i;
     }
     ```
   - **个人心得**：通过记录元素最后一次出现的位置，简化了窗口的维护。

2. **作者：Little_x_starTYJ (赞：5)**  
   - **星级**：4星  
   - **关键亮点**：思路清晰，通过双指针和哈希表维护窗口，确保每个元素只出现两次。  
   - **核心代码**：
     ```cpp
     for(int i = 2; i <= n; ){
         if(a[i] == a[i - 1]) {
             if(lst[a[i]] >= l) cnt -= (lst[a[i]] - l), l = lst[a[i]] + 2;
             else cnt += 2;
             lst[a[i]] = i;
             i += 2;
         } else {
             if(cnt != 0) i--, l = 0, cnt = 0;
             else i++;
         }
         ans = max(cnt, ans);
     }
     ```
   - **个人心得**：通过记录元素最后一次出现的位置，优化了窗口的维护。

3. **作者：include13_fAKe (赞：4)**  
   - **星级**：4星  
   - **关键亮点**：通过单调队列维护窗口，确保每个元素只出现两次，且代码结构清晰。  
   - **核心代码**：
     ```cpp
     for(int i = 1; i <= n; i += 2){
         int i1 = i, j = i;
         while(~b[j] && j <= n){
             sum[b[j]]++;
             while(sum[b[j]] == 2) sum[b[i1]]--, i1 += 2;
             j += 2;
             include13 = max(include13, j - i1);
         }
         for(int k = i; k <= j; k += 2) if(~b[k]) sum[b[k]] = 0;
         i = max(j - 2, i);
     }
     ```
   - **个人心得**：通过单调队列维护窗口，确保每个元素只出现两次。

### 拓展思路
该题的思路可以推广到其他类似的子序列问题，尤其是需要满足特定条件的连续子序列问题。常见的优化方法包括双指针、滑动窗口、哈希表等。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
2. [P1638 最大子序列和](https://www.luogu.com.cn/problem/P1638)  
3. [P3374 最长不重复子序列](https://www.luogu.com.cn/problem/P3374)

---
处理用时：52.71秒
# 题目信息

# [AGC043A] Range Flip Find Route

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc043/tasks/agc043_a

$ H $ 行 $ W $ 列のマス目を考えます。上から $ r $ 番目、左から $ c $ 番目のマスを $ (r,\ c) $ と表すことにします。 全てのマスはそれぞれ白か黒のどちらかの色に塗られています。

次のような経路が存在するとき、このマス目を"良い"状態と呼びます。

- 常に白いマスの上にいながら、$ (1,\ 1) $ から、一つ **右か下** のマスに移動することを繰り返し、 $ (H,\ W) $ へ移動する。

ここで、"良い"状態ならば $ (1,\ 1) $ や $ (H,\ W) $ が必ず白いことに注意してください。

あなたの仕事は、以下の操作を繰り返し、マス目を"良い"状態にすることです。最小で何回操作を行う必要があるか求めてください。なお、有限回の操作で必ず"良い"状態に出来ることが証明可能です。

- $ 4 $ つの整数 $ r_0,\ c_0,\ r_1,\ c_1(1\ \leq\ r_0\ \leq\ r_1\ \leq\ H,\ 1\ \leq\ c_0\ \leq\ c_1\ \leq\ W) $ を選ぶ。$ r_0\ \leq\ r\ \leq\ r_1,\ c_0\ \leq\ c\ \leq\ c_1 $ を満たす全ての $ r,\ c $ について、$ (r,\ c) $ の色を変更する。つまり、白色ならば黒色にし、黒色ならば白色にする。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 100 $

### Sample Explanation 1

$ (r_0,\ c_0,\ r_1,\ c_1)\ =\ (2,\ 2,\ 2,\ 2) $、つまりマス $ (2,\ 2) $ のみ色を変更すれば良いです。

### Sample Explanation 3

操作が必要ない場合も存在します。

## 样例 #1

### 输入

```
3 3

.##

.#.

##.```

### 输出

```
1```

## 样例 #2

### 输入

```
2 2

#.

.#```

### 输出

```
2```

## 样例 #3

### 输入

```
4 4

..##

#...

###.

###.```

### 输出

```
0```

## 样例 #4

### 输入

```
5 5

.#.#.

#.#.#

.#.#.

#.#.#

.#.#.```

### 输出

```
4```

# AI分析结果

### 题目内容重写

#### 题目描述
给定一个 $H$ 行 $W$ 列的网格，每个格子被涂成白色或黑色。你需要从左上角 $(1, 1)$ 出发，每次只能向右或向下移动，最终到达右下角 $(H, W)$。要求路径上的所有格子都是白色的。如果当前网格不满足条件，你可以进行以下操作：
- 选择一个矩形区域，将该区域内的所有格子的颜色翻转（白色变黑色，黑色变白色）。

你的目标是通过最少的操作次数，使得网格满足上述路径条件。求最少操作次数。

#### 输入输出格式
**输入格式**  
第一行包含两个整数 $H$ 和 $W$，表示网格的行数和列数。  
接下来 $H$ 行，每行包含 $W$ 个字符，表示网格的颜色。`.` 表示白色，`#` 表示黑色。

**输出格式**  
输出一个整数，表示最少操作次数。

#### 样例
**样例 1**  
输入：
```
3 3
.##
.#.
##.
```
输出：
```
1
```

**样例 2**  
输入：
```
2 2
#.
.#
```
输出：
```
2
```

**样例 3**  
输入：
```
4 4
..##
#...
###.
###.
```
输出：
```
0
```

**样例 4**  
输入：
```
5 5
.#.#.
#.#.#
.#.#.
#.#.#
.#.#.
```
输出：
```
4
```

### 题解分析与结论

#### 题解对比与评分
1. **xht (赞：8)**  
   - **评分：5星**  
   - **亮点**：使用 `deque` 进行 BFS，时间复杂度为 $O(nm)$，思路清晰，代码简洁。
   - **关键思路**：将问题转化为最短路问题，每次翻转操作相当于增加边权，使用 `deque` 进行 BFS 来求解最短路径。

2. **oimaster (赞：7)**  
   - **评分：4星**  
   - **亮点**：使用动态规划，状态转移方程清晰，代码可读性高。
   - **关键思路**：通过 DP 记录每个位置的最小操作次数，状态转移时考虑是否需要翻转。

3. **cjZYZtcl (赞：4)**  
   - **评分：4星**  
   - **亮点**：使用动态规划，状态转移方程较为简洁，代码实现清晰。
   - **关键思路**：通过 DP 记录每个位置的最小操作次数，状态转移时考虑是否需要翻转。

#### 最优关键思路
- **动态规划**：通过 DP 记录每个位置的最小操作次数，状态转移时考虑是否需要翻转。这种方法时间复杂度为 $O(nm)$，适合本题的规模。
- **BFS**：将问题转化为最短路问题，使用 `deque` 进行 BFS 来求解最短路径，时间复杂度同样为 $O(nm)$。

#### 代码实现
**xht 的 BFS 实现**：
```cpp
const int N = 107, inf = 1e9;
int n, m, d[N][N], v[N][N];
char s[N][N];
deque<pi> q;

int main() {
    rd(n), rd(m);
    for (int i = 1; i <= n; i++) rds(s[i], m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            d[i][j] = inf;
    q.pb(mp(1, 1)), d[1][1] = s[1][1] == '#';
    while (q.size()) {
        pi x = q.front();
        q.pop_front();
        if (v[x.fi][x.se]) continue;
        v[x.fi][x.se] = 1;
        if (x.fi < n) {
            if (s[x.fi][x.se] == '.' && s[x.fi+1][x.se] == '#') {
                if (d[x.fi+1][x.se] > d[x.fi][x.se] + 1)
                    q.pb(mp(x.fi + 1, x.se)), d[x.fi+1][x.se] = d[x.fi][x.se] + 1;
            } else {
                if (d[x.fi+1][x.se] > d[x.fi][x.se])
                    q.push_front(mp(x.fi + 1, x.se)), d[x.fi+1][x.se] = d[x.fi][x.se];
            }
        }
        if (x.se < m) {
            if (s[x.fi][x.se] == '.' && s[x.fi][x.se+1] == '#') {
                if (d[x.fi][x.se+1] > d[x.fi][x.se] + 1)
                    q.pb(mp(x.fi, x.se + 1)), d[x.fi][x.se+1] = d[x.fi][x.se] + 1;
            } else {
                if (d[x.fi][x.se+1] > d[x.fi][x.se])
                    q.push_front(mp(x.fi, x.se + 1)), d[x.fi][x.se+1] = d[x.fi][x.se];
            }
        }
    }
    print(d[n][m]);
    return 0;
}
```

**oimaster 的 DP 实现**：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

char s[110][110];
int H, W, f[110][110];

int main() {
    scanf("%d%d", &H, &W);
    for (int i = 1; i <= H; ++i) scanf("%s", s[i] + 1);

    f[1][1] = s[1][1] == '#';
    for (int i = 2; i <= W; ++i)
        f[1][i] = f[1][i - 1] + (s[1][i - 1] == '.' && s[1][i] == '#');
    for (int i = 2; i <= H; ++i)
        f[i][1] = f[i - 1][1] + (s[i - 1][1] == '.' && s[i][1] == '#');
    for (int i = 2; i <= H; ++i)
        for (int j = 2; j <= W; ++j)
            f[i][j] = min(f[i - 1][j] + (s[i - 1][j] == '.' && s[i][j] == '#'),
                          f[i][j - 1] + (s[i][j - 1] == '.' && s[i][j] == '#'));
    printf("%d\n", f[H][W]);
    return 0;
}
```

#### 拓展思路
- **类似题目**：可以考虑其他网格路径问题，如最短路径、最大路径等，通常可以使用 BFS 或 DP 来解决。
- **优化技巧**：在 DP 中，可以通过状态压缩或滚动数组来优化空间复杂度。

#### 推荐题目
1. [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

---
处理用时：66.26秒
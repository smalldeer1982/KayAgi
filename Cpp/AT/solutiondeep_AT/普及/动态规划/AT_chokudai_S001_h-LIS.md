# 题目信息

# LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_h

数列 $ a $ から好きな整数を好きなだけ取り除き、単調増加な数列を作るとき、その数列の長さの最大値を求めなさい。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100,000 $

## 样例 #1

### 输入

```
5

3 1 5 4 2```

### 输出

```
2```

## 样例 #2

### 输入

```
6

1 2 3 4 5 6```

### 输出

```
6```

## 样例 #3

### 输入

```
7

7 6 5 4 3 2 1```

### 输出

```
1```

## 样例 #4

### 输入

```
20

19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 12```

### 输出

```
6```

# AI分析结果

### 题目内容重写（中文）

给定一个长度为 $N$ 的数列 $a$，从中删除任意数量的元素，使得剩下的元素构成一个严格递增的序列。求这个序列的最大长度。

### 说明/提示

#### 约束
- $1 \leq N \leq 100,000$

#### 样例 #1
##### 输入
```
5
3 1 5 4 2
```
##### 输出
```
2
```

#### 样例 #2
##### 输入
```
6
1 2 3 4 5 6
```
##### 输出
```
6
```

#### 样例 #3
##### 输入
```
7
7 6 5 4 3 2 1
```
##### 输出
```
1
```

#### 样例 #4
##### 输入
```
20
19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 12
```
##### 输出
```
6
```

---

### 综合分析与结论

本题是经典的**最长上升子序列（LIS）**问题，常见的解法有动态规划（$O(n^2)$）和贪心+二分（$O(n \log n)$）。由于数据规模较大，$O(n^2)$的解法会超时，因此推荐使用贪心+二分的优化解法。贪心策略的核心是维护一个单调递增的数组，通过二分查找来更新数组中的元素，从而保证数组的长度即为最长上升子序列的长度。

### 所选高质量题解

#### 1. 作者：花里心爱（5星）
**关键亮点**：
- 使用贪心+二分的优化策略，时间复杂度为$O(n \log n)$。
- 代码简洁，使用了STL中的`lower_bound`函数进行二分查找，极大提高了代码的可读性和效率。
- 详细解释了贪心策略的核心思想，帮助读者理解算法的本质。

**核心代码**：
```cpp
int n, a[100010], s[100010], tot;
int main() {
    n = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    s[++tot] = a[1];
    for (int i = 2; i <= n; i++) {
        if (a[i] > s[tot]) s[++tot] = a[i];
        else *lower_bound(s + 1, s + tot + 1, a[i]) = a[i];
    }
    printf("%d\n", tot);
    return 0;
}
```

#### 2. 作者：灯芯糕（4星）
**关键亮点**：
- 提供了三种经典解法，包括动态规划、树状数组优化和贪心+二分，适合不同层次的读者。
- 详细解释了每种解法的思路和实现细节，尤其是树状数组的优化思路，适合进阶学习。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
int n, a[200005], f[200005];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    int ans = 1; f[1] = a[1];
    for (int i = 2; i <= n; i++) {
        int l = 1, r = ans, mid;
        while (l <= r) {
            mid = (l + r) >> 1;
            if (a[i] <= f[mid]) r = mid - 1;
            else l = mid + 1;
        }
        f[l] = a[i];
        if (l > ans) ++ans;
    }
    cout << ans << endl;
    return 0;
}
```

#### 3. 作者：GossWandering（4星）
**关键亮点**：
- 详细讲解了贪心+二分的思想，并通过举例帮助读者理解算法的执行过程。
- 提供了手写二分查找的实现，适合对STL不熟悉的读者。
- 代码简洁，逻辑清晰，适合初学者学习。

**核心代码**：
```cpp
int n, a[100010], s[100010], len;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    s[len = 1] = a[1];
    for (int i = 2; i <= n; i++) {
        if (a[i] > s[len]) s[++len] = a[i];
        else s[lower_bound(s + 1, s + len + 1, a[i]) - s] = a[i];
    }
    printf("%d\n", len);
    return 0;
}
```

### 最优关键思路与技巧

1. **贪心+二分**：维护一个单调递增的数组，通过二分查找来更新数组中的元素，保证数组的长度即为最长上升子序列的长度。
2. **STL的使用**：利用`lower_bound`函数进行二分查找，简化代码并提高效率。
3. **树状数组优化**：通过树状数组维护动态规划的状态，适合进阶学习和优化。

### 可拓展之处

1. **最长不下降子序列**：只需将二分查找的条件改为`<=`即可。
2. **二维LIS问题**：如洛谷P1020，考察导弹拦截问题，可以通过排序+贪心+二分解决。
3. **多序列LIS**：如洛谷P1439，考察两个序列的最长公共子序列，可以通过离散化+贪心+二分解决。

### 推荐题目

1. **P1020 导弹拦截**：考察最长不下降子序列和贪心+二分的应用。
2. **P1439 最长公共子序列**：考察两个序列的最长公共子序列，可以通过离散化+贪心+二分解决。
3. **P1091 合唱队形**：考察双向LIS问题，结合贪心+二分的思想。

### 个人心得摘录

- **花里心爱**：通过维护一个单调递增的数组，可以高效地求解LIS问题，`lower_bound`的使用极大简化了代码。
- **灯芯糕**：树状数组的优化思路虽然复杂，但在处理大规模数据时非常有效，适合进阶学习。
- **GossWandering**：手写二分查找的实现虽然繁琐，但有助于理解算法的底层逻辑，适合对STL不熟悉的读者。

---
处理用时：59.69秒
# 题目信息

# Neutralize

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_b

$ N $ 個の薬品が横一列に並んでいます。それぞれの薬品には *効用* という整数値が定まっており、左から $ i $ 番目の薬品の現在の効用は $ b_i $ です。これらの値は正とは限りません。

Kenkoooo さんは、横長の特殊な装置を用いて次の操作を何回でも行えます（行わなくても構いません）。

- 連続して並ぶ $ K $ 個の薬品を選ぶ。選ばれた薬品の効用はすべて $ 0 $ となる。

なお、薬品を移動させることは危険を伴うためできません。

その後、Kenkoooo さんは $ N $ 個の薬品すべてを飲み干します。その前に、$ N $ 個の薬品の効用の和を可能な限り大きくしておきたいです。操作後のこの和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ K\ <\ =\ N\ <\ =\ 2\ ×\ 10^5 $
- $ -10^9\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

最適な手順の例を示します。 - $ 1 $ 回目の操作: 左から $ 1,\ 2,\ 3 $ 番目の薬品を選ぶ。 - $ 2 $ 回目の操作: 左から $ 6,\ 7,\ 8 $ 番目の薬品を選ぶ。 - $ 3 $ 回目の操作: 左から $ 7,\ 8,\ 9 $ 番目の薬品を選ぶ。 このとき、$ 9 $ 個の薬品の効用の和は $ 0\ +\ 0\ +\ 0\ +\ 4\ +\ 5\ +\ 0\ +\ 0\ +\ 0\ +\ 0\ =\ 9 $ となります。

### Sample Explanation 2

何もせずこのまま薬品を飲み干すべきです。

## 样例 #1

### 输入

```
9 3

-1

-2

-3

4

5

-6

-7

-8

-9```

### 输出

```
9```

## 样例 #2

### 输入

```
5 4

-1

-1

5

-1

-1```

### 输出

```
1```

## 样例 #3

### 输入

```
9 5

30

-20

40

60

-90

50

-40

10

70```

### 输出

```
120```

## 样例 #4

### 输入

```
10 1

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000```

### 输出

```
5000000000```

# AI分析结果

### 题目内容重写

**题目描述**

有 $N$ 个药品排成一列，每个药品有一个整数效用以表示其效用值，左起第 $i$ 个药品的当前效用为 $b_i$。这些值可能为正也可能为负。

Kenkoooo 可以使用一个特殊的装置进行如下操作（可以不进行任何操作）：

- 选择连续的 $K$ 个药品，将这些药品的效用值全部变为 $0$。

注意，药品的顺序不能改变。

操作后，Kenkoooo 会喝下所有 $N$ 个药品。在此之前，他希望 $N$ 个药品的效用和尽可能大。求操作后最大可能的效用和。

**说明/提示**

**约束条件**

- $1 \leq K \leq N \leq 2 \times 10^5$
- $-10^9 \leq b_i \leq 10^9$
- 输入中的所有值均为整数。

**样例解释**

**样例 1**

输入：

```
9 3

-1

-2

-3

4

5

-6

-7

-8

-9
```

输出：

```
9
```

解释：最优操作如下：

1. 选择第 1、2、3 个药品，将其效用变为 0。
2. 选择第 6、7、8 个药品，将其效用变为 0。
3. 选择第 7、8、9 个药品，将其效用变为 0。

最终效用和为 $0 + 0 + 0 + 4 + 5 + 0 + 0 + 0 + 0 = 9$。

**样例 2**

输入：

```
5 4

-1

-1

5

-1

-1
```

输出：

```
1
```

解释：不进行任何操作，直接喝下所有药品，效用和为 $-1 + (-1) + 5 + (-1) + (-1) = 1$。

**样例 3**

输入：

```
9 5

30

-20

40

60

-90

50

-40

10

70
```

输出：

```
120
```

**样例 4**

输入：

```
10 1

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000
```

输出：

```
5000000000
```

### 题解综合分析与结论

本题的核心是通过动态规划（DP）来解决如何选择连续的 $K$ 个药品将其效用变为 $0$，以最大化最终的总效用。各题解均采用了 DP 的思路，但在状态定义和转移方程上有所不同。

#### 关键思路与技巧

1. **状态定义**：大多数题解采用了二维 DP 状态，分别表示“不受限制”和“受限制”的情况。其中，“不受限制”表示当前药品的效用可以自由选择是否变为 $0$，而“受限制”表示当前药品的效用必须变为 $0$。

2. **转移方程**：  
   - 对于“不受限制”的状态，可以从前一个“不受限制”或“受限制”的状态转移而来，并加上当前药品的效用。  
   - 对于“受限制”的状态，可以从前 $K$ 个药品的“不受限制”状态或前一个“受限制”的状态转移而来。

3. **初始化**：DP 数组的初始化非常重要，通常将初始状态设为 $0$，其他状态设为负无穷，以确保 DP 过程的正确性。

4. **时间复杂度**：由于 DP 的状态转移是线性的，时间复杂度为 $O(n)$，能够处理 $n$ 达到 $2 \times 10^5$ 的数据规模。

#### 最优题解

**题解作者：__delta_epsilon__**

**星级：★★★★★**

**关键亮点**：
- 状态定义清晰，分别表示“不受限制”和“受限制”的情况。
- 转移方程简洁明了，易于理解。
- 代码实现简洁，初始化处理得当。

**核心代码**：

```cpp
for (int i = 0; i < n; i++) {
    dp[i + 1][0] = max(dp[i][0], dp[i][1]) + b[i];
    if (i + 1 - k >= 0)
        dp[i + 1][1] = max(dp[i + 1 - k][0], dp[i][1]);
}
cout << max(dp[n][0], dp[n][1]);
```

**个人心得**：作者在初始化时使用了 `memset(dp, 0x80, sizeof dp)`，将 DP 数组初始化为负无穷，确保 DP 过程的正确性。

### 扩展思路与类似题目

**扩展思路**：
- 本题的 DP 思路可以推广到其他类似的问题，如选择多个不重叠的区间进行操作，以最大化或最小化某个目标函数。
- 类似的区间操作问题可以通过单调队列、滑动窗口等技巧进行优化。

**推荐题目**：
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1044 栈](https://www.luogu.com.cn/problem/P1044)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

这些题目都涉及到区间操作或动态规划的思想，适合进一步练习和巩固相关算法技巧。

---
处理用时：48.01秒
# 题目信息

# [ABC079D] Wall

## 题目描述

## 【题目大意】

你面前有一堵墙，墙上有数字，你需要将墙上的数字都变成 ```1``` 。  
现在给出一个 $W\times H$ 的矩阵 $A$ 表示墙上数字的情况。  
其中若 $A_{i,j}=-1$ ，则表示位置 $(i,j)$ 上没有数字，否则 $A_{i,j}$ 的值表示墙上 $(i,j)$ 位置的数字。  
当然，你还有一张 $10\times 10$ 的表 $C$，其中 $C_{i,j}$ 表示把数字 $i$ 转化成数字 $j$ 所需要的花费。  
求花费的最小值。

## 说明/提示

$1\le H,W\le200$  
$1\le C_{i,j}\le 10^3 (i\neq j)$  
$C_{i,j}=0(i=j)$  
$-1\le A_{i,j}\le 9$
所有数据保证在 ```int``` 范围以内。

## 样例 #1

### 输入

```
2 4

0 9 9 9 9 9 9 9 9 9

9 0 9 9 9 9 9 9 9 9

9 9 0 9 9 9 9 9 9 9

9 9 9 0 9 9 9 9 9 9

9 9 9 9 0 9 9 9 9 2

9 9 9 9 9 0 9 9 9 9

9 9 9 9 9 9 0 9 9 9

9 9 9 9 9 9 9 0 9 9

9 9 9 9 2 9 9 9 0 9

9 2 9 9 9 9 9 9 9 0

-1 -1 -1 -1

8 1 1 8```

### 输出

```
12```

## 样例 #2

### 输入

```
5 5

0 999 999 999 999 999 999 999 999 999

999 0 999 999 999 999 999 999 999 999

999 999 0 999 999 999 999 999 999 999

999 999 999 0 999 999 999 999 999 999

999 999 999 999 0 999 999 999 999 999

999 999 999 999 999 0 999 999 999 999

999 999 999 999 999 999 0 999 999 999

999 999 999 999 999 999 999 0 999 999

999 999 999 999 999 999 999 999 0 999

999 999 999 999 999 999 999 999 999 0

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3 5

0 4 3 6 2 7 2 5 3 3

4 0 5 3 7 5 3 7 2 7

5 7 0 7 2 9 3 2 9 1

3 6 2 0 2 4 6 4 2 3

3 5 7 4 0 6 9 7 6 7

9 8 5 2 2 0 4 7 6 5

5 4 6 3 2 3 0 5 4 3

3 6 2 3 4 2 4 0 8 9

4 6 5 4 3 5 3 2 0 8

2 1 3 4 5 7 8 6 4 0

3 5 2 6 1

2 5 3 2 1

6 9 2 5 6```

### 输出

```
47```

# AI分析结果

### 题目翻译
题目内容已为中文，无需翻译。

### 综合分析与结论
- **思路对比**：所有题解思路一致，均是将数字转换问题抽象为图论问题，把数字看作图的节点，转换花费作为边权。通过 Floyd 算法求出任意两点间最短路径，最后累加矩阵中各数字到 1 的最短路径长度得到最小花费。
- **算法要点**：核心算法为 Floyd 算法，其三重循环的固定顺序是关键，$k$ 枚举中间点，$i$ 和 $j$ 枚举起点和终点，进行松弛操作更新最短路径。
- **解决难点**：主要难点在于理解可借助其他数字“跳板”转换，从而想到用 Floyd 算法求任意两点间最短路径。部分题解还需注意处理矩阵中 1 和 -1 的情况，这两类数字无需累加花费。

### 评分较高的题解
- **作者：Erinyes（5星）**
    - **关键亮点**：思路清晰，对题目分析详细，将问题简化为图论问题，对 Floyd 算法的使用和循环顺序解释到位，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
void floyd(){
    for(int k=0;k<=9;k++){ 
        for(int i=0;i<=9;i++){
            for(int j=0;j<=9;j++){
                if(dis[i][k]!=INF and dis[k][j]!=INF) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); 
            }
        }
    }
}
```
核心思想：通过枚举中间点 $k$，不断更新任意两点 $i$ 和 $j$ 之间的最短路径。

- **作者：cqbztz2（4星）**
    - **关键亮点**：思路简洁明了，代码简洁规范，直接给出核心思路和代码，易于理解。
    - **核心代码**：
```cpp
for(int k=0;k<10;k++){
    for(int i=0;i<10;i++){
        for(int j=0;j<10;j++){
            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
        }
    }
}
```
核心思想：同样是 Floyd 算法的实现，更新任意两点间最短路径。

- **作者：TRZ_2007（4星）**
    - **关键亮点**：将题目抽象化描述清晰，对算法选择有一定分析，代码简洁且有注释。
    - **核心代码**：
```cpp
for(int k = 0;k < 10;k++) {
    for(int i = 0;i < 10;i++) {
        for(int j = 0;j < 10;j++) if(c[i][j] > c[i][k] + c[k][j]) c[i][j] = c[i][k] + c[k][j];
    }
}
```
核心思想：Floyd 算法更新最短路径，当通过中间点 $k$ 到达 $j$ 的路径更短时，更新 $i$ 到 $j$ 的最短路径。

### 最优关键思路或技巧
- **思维方式**：将数字转换问题抽象为图论中的最短路径问题，利用图的邻接矩阵存储转换花费。
- **算法选择**：使用 Floyd 算法求任意两点间最短路径，适用于节点数较少的情况。
- **代码实现**：在输入矩阵元素时在线处理，避免额外空间存储矩阵，提高效率。

### 拓展思路
同类型题可拓展到其他状态转换问题，如状态转移需要借助中间状态，且求最小代价的问题。类似算法套路可使用 Floyd 算法解决多源最短路径问题，也可根据具体情况选择 Dijkstra 或 SPFA 算法解决单源最短路径问题。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法在动态图中的应用。
- [P2910 [USACO08OPEN]Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910)：经典的图论最短路径问题，可使用 Floyd 算法求解。
- [P1347 排序](https://www.luogu.com.cn/problem/P1347)：利用 Floyd 算法判断传递闭包，解决偏序关系问题。

### 个人心得
部分题解提到感觉其他题解没说为什么用 Floyd 算法，这里补充说明了要把所有数变成 1 可借助其他数迭代转换，与 Floyd 求最短路过程一致，所以用 Floyd 算法求解。这提醒我们在解题时要深入理解问题本质和算法原理，不仅要会用算法，还要明白为什么用该算法。 

---
处理用时：27.92秒
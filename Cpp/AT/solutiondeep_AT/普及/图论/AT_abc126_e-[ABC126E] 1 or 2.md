# 题目信息

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5```

### 输出

```
2```

## 样例 #3

### 输入

```
100000 1

1 100000 100```

### 输出

```
99999```

# AI分析结果

### 题目翻译
有 $N$ 张卡片排成一排并面朝下放置，每张卡片上都写有整数 $1$ 或 $2$。

设第 $i$ 张卡片上写的整数为 $A_i$。

你的目标是猜出 $A_1, A_2,..., A_N$ 的值。

已知以下信息：
- 对于 $i = 1, 2,..., M$，$A_{X_i} + A_{Y_i} + Z_i$ 是偶数。

你是一名魔法师，可以多次使用以下魔法：
**魔法**：花费 $1$ 点魔力。选择一张卡片，得知该卡片上写的整数 $A_i$。

问最少花费多少点魔力，就能确保猜出 $A_1, A_2,..., A_N$ 的所有值。

注意，给定的输入保证没有矛盾。

### 综合分析与结论
这些题解思路基本一致，均采用并查集解决问题。核心思路是：由于卡片数字只有 $1$ 或 $2$，根据 $A_{X_i}+A_{Y_i}+Z_i$ 为偶数这一条件，可知只要知道 $A_{X_i}$ 或 $A_{Y_i}$ 其中一个，就能推出另一个。通过并查集将有关系的卡片合并到一个集合中，最后统计集合的数量，即为最少需要使用魔法的次数。

### 题解选择
- **徐晨轩**：★★★★
    - **关键亮点**：思路清晰，代码简洁，直接点明本题本质，无需用到 $Z$ 值，降低了问题复杂度。
    - **核心代码**：
```cpp
int find(int x)
{
    if(f[x]!=x)f[x]=find(f[x]);
    return f[x];
}
void merge(int x,int y)
{
    int fx=find(x);
    int fy=find(y);
    f[fx]=fy;
}
//...
for(int i=1;i<=m;i++)
{
    scanf("%d%d%d",&x,&y,&z);
    merge(x,y);
}
for(int i=1;i<=n;i++)
    if(f[i]==i)
        ans++;
```
    - **核心思想**：通过 `find` 函数查找元素所在集合的代表元素，`merge` 函数合并两个集合。最后遍历所有元素，统计代表元素的数量，即集合的数量。

- **Take_A_Single_6**：★★★★
    - **关键亮点**：对思路的解释较为详细，强调了奇偶关系将数联系起来，有助于理解为何使用并查集。
    - **核心代码**：
```cpp
int bcj(int f)
{
    if(q[f]==f)return f;
    return q[f]=bcj(q[f]);
}
//...
for(int i=0;i<m;i++)
{
    cin>>x>>y>>z;
    q[bcj(x--)]=bcj(y--);
}
for(int i=0;i<n;i++)
    if(q[i]==i)
        ans++;
```
    - **核心思想**：`bcj` 函数实现路径压缩的并查集查找操作。在输入关系时合并集合，最后统计集合数量。

- **龙潜月十五**：★★★★
    - **关键亮点**：通过具体样例详细分析了如何根据条件确定两个数的关系，使读者更容易理解为何可以用并查集解决问题。
    - **核心代码**：
```cpp
int find(int x)
{
    if(x==fa[x])
        return x;
    return fa[x]=find(fa[x]);
}
void con(int x,int y)
{
    x=find(x),y=find(y);
    if(x!=y)
        fa[x]=y;
}
//...
for(int i=1;i<=m;i++)
{
    scanf("%d%d%d",&x,&y,&z);
    con(x,y);
}
for(int i=1;i<=n;i++)
    b[find(i)]=1;
for(int i=1;i<=n;i++)
    if(b[i])
        ans++;
```
    - **核心思想**：`find` 函数查找元素所在集合的代表元素，`con` 函数合并集合。通过标记代表元素，最后统计标记的数量得到集合数量。

### 最优关键思路或技巧
- **思维方式**：将卡片之间的关系转化为集合的合并问题，通过并查集高效地处理元素之间的连通性。
- **数据结构**：使用并查集，利用其查找和合并操作，快速判断元素是否属于同一集合。

### 拓展思路
同类型题或类似算法套路：
- 其他涉及元素之间关系，通过已知部分元素信息可以推出其他元素信息的题目，都可以考虑使用并查集。例如，判断图的连通分量个数、判断元素是否属于同一等价类等。

### 洛谷相似题目推荐
- P3367 【模板】并查集
- P1551 亲戚
- P1197 [JSOI2008]星球大战

### 个人心得摘录与总结
- **龙潜月十五**：提到这题思维转换很妙，之前模拟赛做过现在才深入理解。总结为遇到题目不能仅看表面，要深入分析条件，挖掘问题本质，将看似不相关的问题转化为熟悉的算法模型。 

---
处理用时：28.43秒
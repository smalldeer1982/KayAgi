# 题目信息

# [ABC254E] Small d and k

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc254/tasks/abc254_e

$ N $ 頂点 $ M $ 辺の単純無向グラフがあり、各頂点には $ 1,\ldots,N $ と番号が付けられています。 $ i=1,\ldots,M $ に対し、 $ i $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結びます。また、**各頂点の次数は $ 3 $ 以下です。**

$ i=1,\ldots,Q $ に対し、次のクエリに答えてください。

- 頂点 $ x_i $ との距離が $ k_i $ 以下であるような頂点の番号の総和を求めよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1.5\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min\ (\frac{N(N-1)}{2},\frac{3N}{2}) $
- $ 1\ \leq\ a_i\ \lt\ b_i\ \leq\ N $
- $ i\neq\ j $ ならば $ (a_i,b_i)\ \neq\ (a_j,b_j) $
- 与えられるグラフの各頂点の次数は $ 3 $ 以下
- $ 1\ \leq\ Q\ \leq\ 1.5\ \times\ 10^5 $
- $ 1\ \leq\ x_i\ \leq\ N $
- $ 0\ \leq\ k_i\ \leq\ 3 $
- 入力はすべて整数

### Sample Explanation 1

$ 1 $ 番目のクエリでは、頂点 $ 1 $ との距離が $ 1 $ 以下であるような頂点は頂点 $ 1 $ のみなので $ 1 $ が答えです。 $ 2 $ 番目のクエリでは、頂点 $ 2 $ との距離が $ 2 $ 以下であるような頂点は頂点 $ 2,3,4,5,6 $ なのでこれらの総和の $ 20 $ が答えになります。 $ 3 $ 番目以降のクエリも同様にして答えを求められます。

## 样例 #1

### 输入

```
6 5
2 3
3 4
3 5
5 6
2 6
7
1 1
2 2
2 0
2 3
4 1
6 0
4 3```

### 输出

```
1
20
2
20
7
6
20```

# AI分析结果

### 题目翻译
有一个包含 $N$ 个顶点和 $M$ 条边的简单无向图，每个顶点的编号为 $1,\ldots,N$。对于 $i = 1,\ldots,M$，第 $i$ 条边连接顶点 $a_i$ 和顶点 $b_i$。此外，**每个顶点的度数不超过 3**。

对于 $i = 1,\ldots,Q$，请回答以下查询：
- 求与顶点 $x_i$ 的距离不超过 $k_i$ 的顶点的编号总和。

### 综合分析与结论
- **思路**：所有题解均采用广度优先搜索（BFS）的思路。因为 BFS 按距离逐层搜索，能方便地计算顶点间的距离，符合题目要求。
- **算法要点**：先构建图的存储结构（如邻接表），每次查询时，以给定顶点 $x$ 为起点进行 BFS，用数组记录顶点是否被访问及与起点的距离，当距离超过 $k$ 时停止搜索，累加符合条件的顶点编号。
- **解决难点**：
    - **图的存储**：使用邻接表（如 `vector` 或链式前向星）存储图，避免空间浪费。
    - **重复访问**：用 `vis` 数组标记已访问的顶点，防止重复访问。
    - **复杂度优化**：部分题解通过记录访问过的节点、用额外数组记录最后更新最短路的询问编号等方式，避免每次都用 `memset` 清空数组，优化时间复杂度。

### 所选题解
- **作者：zhujiangyuan (赞：4)，4星**
    - **关键亮点**：思路清晰，代码简洁，使用 `vector` 存图，码量少，注释详细，易于理解。
    - **核心代码**：
```cpp
void bfs()
{
    ans=0;
    memset(vis,0,sizeof(vis));
    queue<int>q;
    q.push(x);
    d[x]=0;
    vis[x]=1;
    while(q.size())
    {
        int y=q.front();q.pop();
        if(d[y]>k) break;
        ans+=y;
        for(auto i:G[y])
        {
            if(!vis[i]) vis[i]=1,q.push(i),d[i]=d[y]+1;
        }
    }
}
```
核心实现思想：每次查询时，先初始化答案和标记数组，将起点入队，标记起点已访问并记录距离为 0。在 BFS 过程中，取出队头元素，若距离超过 $k$ 则停止搜索，否则累加队头元素编号，遍历其相邻顶点，若未访问则标记并更新距离后入队。

- **作者：fuwei123 (赞：1)，4星**
    - **关键亮点**：考虑到复杂度优化，指出不能每次都用 `memset` 清空 `vis` 数组，而是记录访问过的节点，只清空这些节点，保证了复杂度。
    - **核心代码**：
```cpp
int bfs(int x, int k){
    vis[x] = 1;
    q.push({0, x});
    a[cnt = 1] = x;
    int res = 0;
    while(!q.empty()){
        node fr = q.front();
        q.pop();
        int u = fr.pos, d = fr.now;
        if(d > k)break;
        res += u;
        if(d == k)continue;
        for(int i = 0;i < G[u].size();i++){
            int v = G[u][i];
            if(vis[v])continue;
            q.push({d + 1, v});
            vis[v] = 1;
            a[++cnt] = v;
        }
    }
    for(int i = 1;i <= cnt;i++)vis[a[i]] = 0;
    return res;
}
```
核心实现思想：使用结构体存储顶点和距离，将起点入队并标记，在 BFS 过程中，若距离超过 $k$ 则停止搜索，否则累加顶点编号，遍历相邻顶点，若未访问则入队并标记，同时记录访问过的节点，最后只清空这些节点的标记。

- **作者：chengning0909 (赞：1)，4星**
    - **关键亮点**：提出用额外数组记录最后一次更新最短路是在第几次询问，避免每次清空标记数组，优化了时间复杂度。
    - **核心代码**：
```cpp
long long Solve(int x, int k, int id) {
    long long ans = x;
    queue<int> que;
    que.push(x), mmax[x] = id, d[x] = 0;
    while (!que.empty()) {
        int u = que.front();
        que.pop();
        if (d[u] >= k) {
            break;
        }
        for (int v : g[u]) {
            if (mmax[v] < id) {
                mmax[v] = id, que.push(v), ans += v, d[v] = d[u] + 1;
            }
        }
    }
    return ans;
}
```
核心实现思想：在 BFS 过程中，用 `mmax` 数组记录每个顶点最后一次更新最短路的询问编号，若当前询问编号大于该顶点的记录编号，则更新信息并入队，累加符合条件的顶点编号。

### 最优关键思路或技巧
- **数据结构**：使用邻接表（如 `vector` 或链式前向星）存储图，节省空间。
- **算法优化**：避免每次都用 `memset` 清空数组，可记录访问过的节点或用额外数组记录最后更新最短路的询问编号，优化时间复杂度。
- **思维方式**：利用 BFS 按距离逐层搜索的特性，方便计算顶点间的距离。

### 可拓展之处
同类型题或类似算法套路：
- 无权图的最短路径问题，可使用 BFS 求解。
- 多源 BFS 问题，可同时从多个起点进行 BFS。

### 洛谷相似题目
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
- [P1332 血色先锋队](https://www.luogu.com.cn/problem/P1332)
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)

### 个人心得摘录与总结
- **作者：Redamancy_Lydic**：提到判断是否访问过的数组 `vis` 标记最好写在前面，否则可能会漏掉初始点，提醒在实现 BFS 时要注意标记的时机。

---
处理用时：37.61秒
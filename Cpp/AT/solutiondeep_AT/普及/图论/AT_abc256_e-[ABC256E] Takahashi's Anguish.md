# 题目信息

# [ABC256E] Takahashi's Anguish

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc256/tasks/abc256_e

$ 1 $ から $ N $ の番号がついた $ N $ 人の人がいます。  
 高橋君は $ 1 $ から $ N $ までの整数を並び替えた列 $ P\ =\ (P_1,\ P_2,\ \dots,\ P_N) $ を $ 1 $ つ選んで、 人 $ P_1 $, 人 $ P_2 $, $ \dots $, 人 $ P_N $ の順番に $ 1 $ 人ずつキャンディを配ることにしました。  
 人 $ i $ は人 $ X_i $ のことが嫌いなので、高橋君が人 $ i $ より先に人 $ X_i $ にキャンディを配った場合、人 $ i $ に不満度 $ C_i $ がたまります。そうでない場合の人 $ i $ の不満度は $ 0 $ です。  
 高橋君が $ P $ を自由に選べるとき、全員の不満度の和の最小値はいくつになりますか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ X_i\ \leq\ N $
- $ X_i\ \neq\ i $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

$ P\ =\ (1,\ 3,\ 2) $ とすれば不満度が正になるのは人 $ 2 $ だけで、この時全員の不満度の和は $ 10 $ になります。 これより不満度の和を小さくすることはできないので、答えは $ 10 $ です。

## 样例 #1

### 输入

```
3

2 3 2

1 10 100```

### 输出

```
10```

## 样例 #2

### 输入

```
8

7 3 5 5 8 4 1 2

36 49 73 38 30 85 27 45```

### 输出

```
57```

# AI分析结果

### 题目内容中文重写
有编号从 $1$ 到 $N$ 的 $N$ 个人。高桥君选择一个由 $1$ 到 $N$ 的整数排列而成的序列 $P = (P_1, P_2, \dots, P_N)$，并按照人 $P_1$、人 $P_2$、$\dots$、人 $P_N$ 的顺序依次分发糖果。

第 $i$ 个人讨厌第 $X_i$ 个人，所以如果高桥君在给第 $i$ 个人发糖果之前先给第 $X_i$ 个人发了糖果，那么第 $i$ 个人就会积累不满度 $C_i$。否则，第 $i$ 个人的不满度为 $0$。

当高桥君可以自由选择 $P$ 时，所有人的不满度之和的最小值是多少？

### 综合分析与结论
这些题解的核心思路都是将问题转化为图论问题，通过建图来解决。把每个人看作一个点，若第 $i$ 个人讨厌第 $X_i$ 个人，则从 $X_i$ 向 $i$ 连一条边权为 $C_i$ 的有向边。图的形态通常是基环树森林，对于无环的连通块，存在一种排列方式使得不满度为 $0$；对于有环的连通块，需要找到环上最小边权的边，将其对应的不满度累加到答案中。

不同题解采用了不同的方法来实现找环和求最小边权的操作，如深度优先搜索（DFS）、并查集、强连通分量（Tarjan 算法）、Kruskal 算法等。

### 所选题解
- **Tmbcan（4星）**
    - **关键亮点**：思路清晰，使用 Kruskal 算法求最大生成树，通过总贡献减去连边时的代价得到最小贡献，代码实现规范，有自定义的快速读入函数。
    - **核心代码**：
```cpp
inline void krscul(){
    sort(edge+1,edge+1+edge_num);
    for(int i=1;i<=edge_num;++i){
        if(merge(edge[i].from,edge[i].to)) ans+=1ll*edge[i].w;
    }
}
```
    - **核心实现思想**：先对边按边权从大到小排序，然后依次尝试合并边的两个端点，如果两个端点不在同一个集合中，则合并它们并累加边权，最终得到最大生成树的边权和。

- **coding_goat（4星）**
    - **关键亮点**：通过深度优先搜索找环，利用栈来记录遍历路径，找到环后求环中最小边权，代码逻辑清晰，有详细的注释。
    - **核心代码**：
```cpp
void serch(int xx){
    top=0;
    memset(stk,0,sizeof(stk));
    stk[++top]=xx;
    vis[xx]=1;
    while(top){
        int now=stk[top];
        int nxt=to[now];
        if(vis[nxt]){
            long long minn=un[nxt];
            while(stk[top]!=nxt&&top){
                minn=min(minn,(long long)un[stk[top--]]);
            }
            if(top!=0)ans+=minn;
            return ;
        }
        stk[++top]=nxt;
        vis[nxt]=1;
    }
}
```
    - **核心实现思想**：从一个未访问的点开始深度优先搜索，将路径上的点压入栈中，当遇到已访问的点时，说明找到了环，从栈中回溯找到环上的点，求最小边权并累加到答案中。

- **ChenZQ（4星）**
    - **关键亮点**：同样使用深度优先搜索找环，通过标记数组区分不同状态的点，回溯遍历图，找到环后求最小边权，代码简洁。
    - **核心代码**：
```cpp
void dfs(int u) 
{
    if (f[u])
    {
        if (f[u]==1)
        { 
            int sum = 1e9 + 10;
            for(int i=1;i<=tot;i++) sum=min(sum,num[i]);
            ans+=sum;
        }
        return;
    }
    f[u]=1;
    for(int i=0;i<v[u].size();i++)
    {
        num[++tot]=v[u][i].dist;
        dfs(v[u][i].u);
        tot--; 
    }
    f[u]=2;
}
```
    - **核心实现思想**：用 $f$ 数组标记点的状态，$f[u]=1$ 表示当前点正在所遍历的环里，$f[u]=2$ 表示已访问且不在环里，$f[u]=0$ 表示未访问。在深度优先搜索过程中，将边权记录在 `num` 数组中，当遇到已在环里的点时，求 `num` 数组中的最小值并累加到答案中。

### 最优关键思路或技巧
- **图论建模**：将人物关系转化为图的边和点，把问题转化为图论问题，这是解决本题的关键思维方式。
- **找环与贪心**：对于有环的情况，贪心选择环上最小边权的边，这是降低总不满度的有效策略。
- **数据结构的运用**：并查集、栈、深度优先搜索等数据结构和算法在找环和求最小边权的过程中发挥了重要作用。

### 可拓展之处
同类型题或类似算法套路：
- 其他图论中的环相关问题，如判断图中是否有环、求环的长度等。
- 最小生成树、最大生成树相关问题，可使用 Kruskal、Prim 等算法。
- 强连通分量相关问题，可使用 Tarjan 算法。

### 推荐题目
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)：考察最小生成树的应用。
- [P2860 [USACO06JAN]Tallest Cow S](https://www.luogu.com.cn/problem/P2860)：涉及图论和贪心思想。
- [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)：考察强连通分量的应用。

### 个人心得摘录与总结
- **Melo_DDD**：提到不要用 DFS，会有各种各样的问题需要处理，但未详细说明问题所在，提醒我们在使用 DFS 时要注意细节。

---
处理用时：41.24秒
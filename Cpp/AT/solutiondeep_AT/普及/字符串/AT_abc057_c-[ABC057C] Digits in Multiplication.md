# 题目信息

# [ABC057C] Digits in Multiplication

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc057/tasks/abc057_c

整数 $ N $ が与えられます。   
 ここで、$ 2 $ つの正の整数 $ A,B $ に対して、$ F(A,B) $ を「$ 10 $ 進表記における、$ A $ の桁数と $ B $ の桁数のうち大きい方」と定義します。   
 例えば、$ F(3,11) $ の値は、$ 3 $ は $ 1 $ 桁、$ 11 $ は $ 2 $ 桁であるため、$ F(3,11)=2 $ となります。   
 $ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くとき、$ F(A,B) $ の最小値を求めてください。

## 说明/提示

### 制約

- $ 1≦N≦10^{10} $
- $ N $ は整数である。

### Sample Explanation 1

$ (A,B)=(100,100) $ のときに $ F(A,B) $ は最小値をとるため、$ F(100,100)=3 $ を出力します。

### Sample Explanation 2

条件を満たす $ (A,B) $ の組は $ (1,1000003) $ と $ (1000003,1) $ の $ 2 $ 通りで、$ F(1,1000003)=F(1000003,1)=7 $ です。

## 样例 #1

### 输入

```
10000```

### 输出

```
3```

## 样例 #2

### 输入

```
1000003```

### 输出

```
7```

## 样例 #3

### 输入

```
9876543210```

### 输出

```
6```

# AI分析结果

### 题目翻译
给定一个整数 $N$。
这里，对于两个正整数 $A$ 和 $B$，将 $F(A,B)$ 定义为「在十进制表示中，$A$ 的位数和 $B$ 的位数中较大的那个」。
例如，$F(3,11)$ 的值，因为 $3$ 是 $1$ 位数，$11$ 是 $2$ 位数，所以 $F(3,11) = 2$。
当两个正整数对 $(A,B)$ 满足 $N = A×B$ 时，求 $F(A,B)$ 的最小值。

### 综合分析与结论
- **思路对比**：各题解思路基本一致，都是利用数学原理，要使 $F(A,B)$ 最小，$A$ 和 $B$ 应尽量接近，所以从 $\sqrt{N}$ 开始向小枚举因数，找到第一个能整除 $N$ 的因数 $i$，计算出 $N/i$，再求 $N/i$ 的位数即为答案。
- **算法要点**：
    - 从 $\sqrt{N}$ 开始枚举因数，这样能保证找到的因数对使 $A$ 和 $B$ 最接近。
    - 计算数的位数可以用循环不断除以 $10$ 累加，也可以用字符串长度计算。
- **解决难点**：
    - 数据范围达到 $10^{10}$，需要使用 `long long` 类型防止溢出。
    - 要高效找到合适的因数对，从 $\sqrt{N}$ 开始枚举是关键。

### 所选题解
- **作者：MaoHanKun (4星)**
    - **关键亮点**：思路清晰，代码简洁，直接从 $\sqrt{N}$ 开始枚举因数，计算位数的方法简单易懂。
    - **核心代码**：
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
long long n,ans;
int s;
int main(){
    scanf("%lld",&n);
    for(int i=sqrt(n);i>0;--i) 
        if(n%i==0){
            ans=n/i;
            break;
        }
    while(ans>0){
        ++s;
        ans/=10;
    }
    printf("%d\n",s); 
    return 0;
}
```
- **作者：TRZ_2007 (4星)**
    - **关键亮点**：使用快读函数，代码结构清晰，将不同功能封装成函数，提高了代码的可读性和可维护性。
    - **核心代码**：
```cpp
namespace doit
{
    inline ll read()
    {
        ll x=0,p=1;
        char c;
        c=getchar();
        while(c<'0'||c>'9')
        {
            if(c=='-')
                p=-1;
            c=getchar();
        }
        while(c>='0'&&c<='9')
        {
            x=x*10+c-'0';
            c=getchar();
        }
        return x*p;
    }
    inline int f(ll n)
    {
        int len=0;
        while(n)
        {
            n/=10;
            len++;
        }
        return len;
    }
    inline void put()
    {
        ll n,ans;
        n=read();
        for(register int i=sqrt(n);i>=1;i--)
            if(n%i==0)
            {
                ans=n/i;
                break;
            }
        std::cout<<f(ans)<<"\n";
    }
}
```
- **作者：4kilometers (4星)**
    - **关键亮点**：使用 `sprintf` 将数写入字符串，利用 `strlen` 直接计算位数，思路独特。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL n;
char s[11],s2[11];
int main()
{
    cin >> n;
    for (int i = sqrt(n); i >= 1; -- i)
    {
        if (n % i == 0)
        {
            int i2 = n / i;
            sprintf(s,"%d",i);
            sprintf(s2,"%d",i2);
            cout << max(strlen(s),strlen(s2)) << endl;
            break;
        }
    }
    return 0;
}
```

### 最优关键思路或技巧
- 利用数学原理，从 $\sqrt{N}$ 开始枚举因数，能快速找到使 $A$ 和 $B$ 最接近的因数对，从而得到 $F(A,B)$ 的最小值。
- 计算数的位数可以用循环不断除以 $10$ 累加，也可以用字符串长度计算，根据具体情况选择合适的方法。

### 可拓展之处
同类型题可能会改变 $F(A,B)$ 的定义，或者增加更多的限制条件，但核心思路还是找到合适的因数对。类似算法套路可以应用于一些需要枚举因数的数学问题，如分解质因数、求最大公约数等。

### 洛谷相似题目
- P1075 [NOIP2012 普及组] 质因数分解
- P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题
- P1306 斐波那契公约数

### 个人心得摘录与总结
- **赤霞QvQ**：提到数据很水可以直接枚举，还指出反过来枚举只要找到能整除 $N$ 的就退出循环，思路类似但更高效。总结：在解题时可以尝试不同的枚举方向，找到更优的解法。
- **meyi**：表示自己打了暴力 AC 后看到大佬题解自愧不如，说明数据范围较小可以模拟。总结：在数据范围较小时，暴力模拟也是一种可行的解题方法，但要注意学习更优的算法。

---
处理用时：33.50秒
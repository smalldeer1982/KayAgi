# 题目信息

# [ABC371D] 1D Country

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_d

数直線上に $ N $ 個の村があります。$ i $ 番目の村は座標 $ X_i $ にあり、$ P_i $ 人の村人がいます。

$ Q $ 個のクエリに答えてください。$ i $ 番目のクエリは以下の形式です。

- 整数 $ L_i,R_i $ が与えられる。座標が $ L_i $ 以上 $ R_i $ 以下の村に住んでいる村人の人数の総数を求めよ。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\leq\ 2\times\ 10^5 $
- $ -10^9\leq\ X_1\ <\ X_2\ <\ \ldots\ <\ X_N\ \leq\ 10^9 $
- $ 1\leq\ P_i\leq\ 10^9 $
- $ -10^9\leq\ L_i\ \leq\ R_i\ \leq\ 10^9 $
- 入力される数値は全て整数

### Sample Explanation 1

$ 1 $ 番目のクエリについて考えます。座標が $ 1 $ 以上 $ 1 $ 以下の村は、座標 $ 1 $ にある村で、村人は $ 1 $ 人います。よって答えは $ 1 $ です。 $ 2 $ 番目のクエリについて考えます。座標が $ 2 $ 以上 $ 6 $ 以下の村は、座標 $ 3 $ にある村と座標 $ 5 $ にある村で、村人はそれぞれ $ 2 $ 人と $ 3 $ 人います。よって答えは $ 2+3=5 $ です。

## 样例 #1

### 输入

```
4
1 3 5 7
1 2 3 4
4
1 1
2 6
0 10
2 2```

### 输出

```
1
5
10
0```

## 样例 #2

### 输入

```
7
-10 -5 -3 -1 0 1 4
2 5 6 5 2 1 7
8
-7 7
-1 5
-10 -4
-8 10
-5 0
-10 5
-8 7
-8 -3```

### 输出

```
26
15
7
26
18
28
26
11```

# AI分析结果

### 题目内容重写

数直线上有 $ N $ 个村。第 $ i $ 个村位于坐标 $ X_i $，有 $ P_i $ 个村民。

有 $ Q $ 个查询，每个查询给出两个整数 $ L_i $ 和 $ R_i $，要求输出坐标在 $ L_i $ 到 $ R_i $ 之间的所有村的村民总数。

### 综合分析与结论

该题的核心问题是在数轴上进行区间查询，计算给定区间内的村民总数。由于数据范围较大（$ -10^9 \leq X_i \leq 10^9 $），直接使用暴力方法或简单的数组存储会导致内存不足或时间超限。因此，大多数题解都采用了离散化、前缀和和二分查找等优化手段。

### 精选题解

#### 1. 作者：XXh0919 (赞：19)
- **星级**: 4.5
- **关键亮点**: 使用了离散化和前缀和的结合，通过二分查找快速定位区间，代码简洁高效。
- **核心代码**:
  ```cpp
  l=lower_bound(x+1,x+n+1,l)-x;
  r=upper_bound(x+1,x+n+1,r)-x;
  cout<<sum[r-1]-sum[l-1]<<endl;
  ```
- **个人心得**: 作者提到离散化的重要性，特别是对于负数和不在输入中的查询边界，通过二分查找可以有效处理这些情况。

#### 2. 作者：hzxphy (赞：7)
- **星级**: 4
- **关键亮点**: 使用了树状数组进行区间查询，虽然代码稍复杂，但展示了另一种高效的数据结构应用。
- **核心代码**:
  ```cpp
  long long sum(long long x){
      long long ans=0;
      while(x>=1){
          ans+=tree[x];
          x-=lowbit(x);
      }
      return ans;
  }
  ```
- **个人心得**: 作者强调了树状数组在处理大范围数据时的优势，尽管实现起来比前缀和复杂，但在某些情况下更为灵活。

#### 3. 作者：hjyowl (赞：6)
- **星级**: 4
- **关键亮点**: 使用了结构体排序和前缀和，通过二分查找快速定位区间，代码清晰易读。
- **核心代码**:
  ```cpp
  long long ll = lower_bound(a + 1,a + 1 + n,l) - a;
  long long rr = upper_bound(a + 1,a + 1 + n,r) - a - 1;
  cout << s[rr] - s[ll - 1] << endl;
  ```
- **个人心得**: 作者提到排序的重要性，通过排序可以简化后续的二分查找和前缀和计算，使得整体逻辑更加清晰。

### 最优关键思路或技巧
1. **离散化**: 将大范围的坐标映射到较小的范围内，便于使用数组存储和快速查找。
2. **前缀和**: 预处理数据，使得区间查询可以在 $O(1)$ 时间内完成。
3. **二分查找**: 快速定位查询区间，减少时间复杂度。

### 可拓展之处
- **类似问题**: 对于其他需要处理大范围数据的区间查询问题，如区间最大值、区间最小值等，可以采用类似的离散化和前缀和技巧。
- **数据结构**: 除了前缀和，树状数组和线段树也是处理区间查询的常用数据结构，可以根据具体问题选择合适的数据结构。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

---
处理用时：36.13秒
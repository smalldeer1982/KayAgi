# 题目信息

# [ABC388D] Coming of Age Celebration

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc388/tasks/abc388_d

ある星には $ N $ 人の宇宙人がおり、全員未成年です。

$ i $ 人目の宇宙人は現在 $ A_i $ 個の石を所持しており、ちょうど $ i $ 年後に成人します。

この星では誰かが成人するとき、石を $ 1 $ 個以上所持している**成人**全員が、成人する宇宙人に成人祝いとして石を $ 1 $ 個渡します。

$ N $ 年後に各宇宙人が所持している石の個数を求めてください。

ただし、今後新たな宇宙人は産まれないものとします。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 5\ \times\ 10^5 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i $ 人目の宇宙人が持っている石の個数を $ C_i $ で表します。 はじめ $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ です。 $ 1 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ となります。 $ 2 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (4,\ 1,\ 9,\ 3) $ となります。 $ 3 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (3,\ 0,\ 11,\ 3) $ となります。 $ 4 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (2,\ 0,\ 10,\ 5) $ となります。

## 样例 #1

### 输入

```
4

5 0 9 3```

### 输出

```
2 0 10 5```

## 样例 #2

### 输入

```
5

4 6 7 2 5```

### 输出

```
0 4 7 4 9```

## 样例 #3

### 输入

```
10

2 9 1 2 0 4 6 7 1 5```

### 输出

```
0 2 0 0 0 4 7 10 4 10```

# AI分析结果

### 题目内容重写

【题目描述】

某个星球上有 $N$ 名外星人，他们都是未成年人。第 $i$ 名外星人目前拥有 $A_i$ 颗石头，并将在 $i$ 年后成年。当这个星球上有人成年时，每个至少拥有一块石头的成年人都会向刚刚成年的外星人赠送一块石头作为贺礼。求 $N$ 年后每个外星人将拥有多少块石头。假设未来不会有新的外星人出生。

【输入格式】

第一行输入一个整数 $N$，表示外星人的数量。  
第二行输入 $N$ 个整数 $A_i$，表示每个外星人初始拥有的石头数量。

【输出格式】

输出 $N$ 个整数，表示 $N$ 年后每个外星人拥有的石头数量。

【样例输入】

```
4
5 0 9 3
```

【样例输出】

```
2 0 10 5
```

【提示】

- $1 \leq N \leq 5 \times 10^5$
- $0 \leq A_i \leq 5 \times 10^5$

### 题解分析与结论

#### 综合分析与结论

本题的核心在于模拟外星人成年后石头的分配过程。由于直接模拟会导致时间复杂度较高，因此大多数题解采用了优化策略，如优先队列、差分数组、线段树等数据结构来减少时间复杂度。

#### 高星题解推荐

1. **作者：ikunTLE (5星)**
   - **关键亮点**：使用优先队列优化，时间复杂度为 $O(N \log N)$，思路清晰，代码简洁。
   - **核心思想**：通过优先队列维护当前可以赠送石头的外星人，每次处理时弹出无法继续赠送的外星人，并更新当前外星人的石头数量。
   - **代码片段**：
     ```cpp
     priority_queue<node> pq;
     for(int i=1;i<=n;++i){
         a[i]+=pq.size();
         while(!pq.empty()&&pq.top().x-i<=0) pq.pop();
         if(a[i]) pq.push({a[i]+i,i});
     }
     ```

2. **作者：H_dream (4星)**
   - **关键亮点**：使用差分数组优化，时间复杂度为 $O(N)$，思路巧妙，代码简洁。
   - **核心思想**：通过差分数组记录每个外星人赠送石头的影响，避免了重复计算，最终通过前缀和得到结果。
   - **代码片段**：
     ```cpp
     for(int i=1;i<=n;++i){
         a[i]=b[i]+a[i-1];
         int ans=a[i]-n+i;
         b[i+1]++;
         if(ans<0) b[i+a[i]+1]--;
         cout<<ans<<' ';
     }
     ```

3. **作者：_xxxxx_ (4星)**
   - **关键亮点**：使用优先队列优化，时间复杂度为 $O(N \log N)$，代码简洁，思路清晰。
   - **核心思想**：通过优先队列维护当前可以赠送石头的外星人，每次处理时弹出无法继续赠送的外星人，并更新当前外星人的石头数量。
   - **代码片段**：
     ```cpp
     priority_queue<int, vector<int>, greater<int>> q;
     for(int i=1;i<=n;i++){
         a[i]+=q.size();
         q.push(a[i]+i);
         while(q.size() && q.top()-i<=0) q.pop();
     }
     ```

### 最优关键思路与技巧

- **优先队列优化**：通过优先队列维护当前可以赠送石头的外星人，确保每次处理时只考虑有效的外星人，从而减少不必要的计算。
- **差分数组优化**：通过差分数组记录每个外星人赠送石头的影响，避免了重复计算，最终通过前缀和得到结果，时间复杂度为 $O(N)$。

### 可拓展之处

- **类似问题**：类似的问题可以出现在需要动态维护和更新状态的场景中，如任务调度、资源分配等。
- **算法套路**：优先队列和差分数组是处理动态更新问题的常用工具，适用于需要高效处理区间修改和查询的场景。

### 推荐题目

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得摘录

- **调试经历**：在处理优先队列时，需要注意弹出条件，确保只弹出无法继续赠送的外星人，避免过早弹出有效的外星人。
- **踩坑教训**：差分数组的初始化需要注意，避免在计算前缀和时出现错误。
- **顿悟感想**：优先队列和差分数组的结合使用可以大大简化问题的处理过程，尤其是在需要动态维护状态的场景中。

---
处理用时：41.73秒
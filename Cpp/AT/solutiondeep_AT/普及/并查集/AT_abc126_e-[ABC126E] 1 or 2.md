# 题目信息

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5```

### 输出

```
2```

## 样例 #3

### 输入

```
100000 1

1 100000 100```

### 输出

```
99999```

# AI分析结果

### 题目内容重写

【题目描述】

有 $N$ 张卡片排成一列，每张卡片上写有整数 $1$ 或 $2$。设第 $i$ 张卡片上的整数为 $A_i$。你的目标是猜出所有 $A_1, A_2, \dots, A_N$ 的值。

已知以下信息：

- 对于每个 $i = 1, 2, \dots, M$，$A_{X_i} + A_{Y_i} + Z_i$ 是偶数。

你可以使用一种魔法，每次使用需要支付 $1$ 的代价。使用魔法时，你可以选择一张卡片并知道其上的整数 $A_i$。

问：最少需要支付多少代价，才能确保猜出所有 $A_1, A_2, \dots, A_N$ 的值？

### 题解分析与结论

#### 综合分析与结论

所有题解都采用了并查集（Union-Find）数据结构来解决这个问题。核心思路是通过并查集将具有关系的卡片合并到同一个集合中，最终统计集合的数量即为需要使用的魔法次数。由于每张卡片上的数字只能是 $1$ 或 $2$，因此在一个集合中，只要知道其中一张卡片的值，就可以推断出其他卡片的值。

#### 最优关键思路或技巧

1. **并查集的应用**：通过并查集将具有关系的卡片合并到同一个集合中，最终统计集合的数量即为需要使用的魔法次数。
2. **路径压缩优化**：在并查集的 `find` 函数中使用路径压缩，减少查询时间。
3. **集合统计**：通过遍历所有卡片，统计每个集合的代表元素，最终得到集合的数量。

#### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)

### 所选高分题解

#### 题解1：徐晨轩✅ (5星)

**关键亮点**：
- 代码简洁，思路清晰。
- 使用了路径压缩优化并查集的查询效率。

**核心代码**：
```cpp
int find(int x) {
    if(f[x]!=x) f[x]=find(f[x]);
    return f[x];
}
void merge(int x, int y) {
    int fx=find(x);
    int fy=find(y);
    f[fx]=fy;
}
```
**实现思想**：通过 `find` 函数实现路径压缩，通过 `merge` 函数合并两个集合。

#### 题解2：Take_A_Single_6 (4星)

**关键亮点**：
- 代码可读性强，注释详细。
- 使用了并查集的基本操作，适合初学者理解。

**核心代码**：
```cpp
int bcj(int f) {
    if(q[f]==f) return f;
    return q[f]=bcj(q[f]);
}
```
**实现思想**：通过 `bcj` 函数实现路径压缩，合并集合时直接调用该函数。

#### 题解3：我是小何子啊 (4星)

**关键亮点**：
- 代码结构清晰，使用了快读优化输入。
- 通过标记数组统计集合数量，避免重复计算。

**核心代码**：
```cpp
int find(int x) {
    if(f[x]!=x) f[x]=find(f[x]);
    return f[x];
}
```
**实现思想**：通过 `find` 函数实现路径压缩，合并集合时直接调用该函数，并通过标记数组统计集合数量。

### 个人心得摘录

- **龙潜月十五**：这题的思维转换非常巧妙，通过并查集将问题转化为统计集合数量，适合作为并查集的入门题目。
- **LLGZ**：并查集模板题，适合用来巩固并查集的基本操作，路径压缩和合并操作是重点。

### 通用建议与扩展思路

- **并查集的应用**：并查集不仅适用于这种关系推断问题，还可以用于图论中的连通性问题、动态连通性维护等。
- **路径压缩优化**：在并查集中使用路径压缩可以显著提高查询效率，尤其是在大规模数据下。
- **集合统计**：通过标记数组或哈希表统计集合数量，避免重复计算，提高效率。

---
处理用时：32.50秒
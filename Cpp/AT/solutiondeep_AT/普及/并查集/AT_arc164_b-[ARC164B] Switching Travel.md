# 题目信息

# [ARC164B] Switching Travel

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc164/tasks/arc164_b

頂点に $ 1 $ から $ N $ までの番号がついた $ N $ 頂点の単純、連結な無向グラフがあります。 このグラフには $ M $ 本の辺があり、 $ i $ 番目の辺は $ 2 $ 頂点 $ a_i $ , $ b_i $ を結んでいます。

また、各頂点は白または黒の色を持ち、最初の状態が $ c_i $ で与えられます。 $ c_i $ は $ 0 $ または $ 1 $ であり、$ c_i=0 $ であれば頂点 $ i $ は初め白色であり、$ c_i=1 $ であれば頂点 $ i $ は初め黒色です。

あなたはこのグラフ上で、好きな頂点を $ 1 $ つ選んで出発点とし、

- 今いる頂点と辺で結ばれた頂点のうち、今いる頂点と異なる色の頂点に移動する。その直後に、移動元の頂点の色を反転する（元の色が白なら黒に、黒なら白に変える）。
 
という動作を好きな回数繰り返します。

$ 1 $ 回以上の動作を行ったうえで、再び出発点に戻ってくることは可能でしょうか。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \mathrm{min}\ \lbrace\ 2\ \times\ 10^5,N(N-1)/2\ \rbrace $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ c_i=0 $ または $ c_i=1 $ $ (1\ \leq\ i\ \leq\ N) $
- 与えられるグラフは単純かつ連結である
- 入力される値はすべて整数である
 
### Sample Explanation 1

例えば、頂点 $ 1 $ から出発することを考えます。 最初の動作では、頂点 $ 2 $ に移動し、移動元である頂点 $ 1 $ の色を白から黒に変化させます。この際のグラフの変化は下の図の通りです（丸で囲った頂点が今いる頂点を表します）。 その後、頂点 $ 3 $, $ 4 $, $ 2 $ へと順に移動すると、この時点で頂点 $ 1,2,3,4 $ の色は順に黒、白、黒、白となっています。 したがって、次の動作で頂点 $ 1 $ に移動することができ、出発点に戻ってくることができました。 !\[\](https://img.atcoder.jp/arc164/69700c7a0d96daa9c93ad01b89530e53.png)

### Sample Explanation 2

このグラフでは、どの頂点を出発点に選んでも、条件を満たすような移動を行って出発点に戻ってくることができません。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 2

0 1 0 1```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5 6

1 2

2 3

3 4

4 5

1 4

2 5

0 1 0 1 0```

### 输出

```
No```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个包含 $N$ 个顶点和 $M$ 条边的简单连通无向图，每个顶点都有一个颜色（白色或黑色）。初始时，第 $i$ 个顶点的颜色为 $c_i$，$c_i=0$ 表示白色，$c_i=1$ 表示黑色。

你可以选择一个顶点作为起点，然后执行以下操作任意次：

- 从当前顶点移动到与其相连的、颜色不同的顶点。移动后，将移动前的顶点颜色反转（白色变黑色，黑色变白色）。

问是否存在一个起点，使得在执行若干次操作后，能够回到起点。

#### 输入格式

第一行包含两个整数 $N$ 和 $M$，表示顶点数和边数。

接下来 $M$ 行，每行包含两个整数 $a_i$ 和 $b_i$，表示图中的一条边。

最后一行包含 $N$ 个整数 $c_1, c_2, \dots, c_N$，表示每个顶点的初始颜色。

#### 输出格式

如果存在满足条件的起点，输出 `Yes`，否则输出 `No`。

#### 样例

**样例 1**

输入：
```
4 4
1 2
2 3
3 4
4 2
0 1 0 1
```
输出：
```
Yes
```

**样例 2**

输入：
```
5 6
1 2
2 3
3 4
4 5
1 4
2 5
0 1 0 1 0
```
输出：
```
No
```

### 题解分析与结论

#### 综合分析

本题的核心在于判断图中是否存在一个环，使得环上的顶点颜色交替变化，并且最终能够回到起点。具体来说，我们需要找到一个环，使得环上的顶点颜色满足以下条件：

1. 环上的顶点颜色交替变化（即相邻顶点颜色不同）。
2. 环的起点和终点的颜色相同（因为回到起点时，起点的颜色已经被反转）。

大多数题解都采用了并查集（Union-Find）数据结构来处理这个问题。通过并查集，我们可以将颜色不同的相邻顶点合并到同一个集合中，然后检查是否存在颜色相同的相邻顶点在同一个集合中。如果存在这样的顶点对，则说明存在满足条件的环。

#### 最优思路总结

1. **并查集的应用**：通过并查集将颜色不同的相邻顶点合并到同一个集合中，这样可以快速判断两个顶点是否在同一个连通块中。
2. **环的判断**：在合并完所有颜色不同的相邻顶点后，检查是否存在颜色相同的相邻顶点在同一个集合中。如果存在，则说明存在满足条件的环。
3. **时间复杂度**：并查集的合并和查找操作的时间复杂度为 $O(\alpha(N))$，其中 $\alpha(N)$ 是反阿克曼函数，因此总的时间复杂度为 $O(M \alpha(N))$，能够处理题目中的最大数据规模。

#### 推荐题解

**题解作者：zzk2010 (赞：4)**  
**星级：★★★★★**  
**关键亮点**：思路清晰，代码简洁，通过并查集快速判断是否存在满足条件的环。

**代码核心实现**：
```cpp
#include <bits/stdc++.h>
using namespace std;
struct edge { int u, v; } e[200005];
int n, m, fa[200005], c[200005];
bool ok;
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
void merge(int x, int y) { fa[find(x)] = find(y); }
int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        e[i] = (edge){u, v};
    }
    for(int i = 1; i <= n; i++) cin >> c[i];
    for(int i = 1; i <= n; i++) fa[i] = i;
    for(int i = 1; i <= m; i++) if (c[e[i].u] != c[e[i].v]) merge(e[i].u, e[i].v);
    for(int i = 1; i <= m; i++) if (c[e[i].u] == c[e[i].v] && find(e[i].u) == find(e[i].v)) ok = 1;
    if (ok) puts("Yes");
    else puts("No");
    return 0;
}
```

**题解作者：Elairin176 (赞：4)**  
**星级：★★★★☆**  
**关键亮点**：通过预处理和并查集的结合，进一步优化了判断条件，代码结构清晰。

**题解作者：Hog_Dawa_IOI (赞：2)**  
**星级：★★★☆☆**  
**关键亮点**：通过DFS和并查集的结合，提供了另一种思路，但代码复杂度较高。

### 扩展思路与推荐题目

#### 扩展思路

本题的核心在于通过并查集快速判断图中是否存在满足条件的环。类似的问题可以扩展到其他图论问题中，如判断图中是否存在特定性质的路径或环。并查集在处理连通性问题时非常高效，适用于需要快速合并和查找集合的场景。

#### 推荐题目

1. **P3367 【模板】并查集** - 并查集的基础模板题，适合练习并查集的基本操作。
2. **P1196 [NOI2002] 银河英雄传说** - 并查集的应用题，需要处理集合的合并和查询操作。
3. **P1551 亲戚** - 并查集的经典应用，判断两个人是否有亲戚关系。

### 个人心得总结

在解决本题时，许多题解作者都提到了并查集的重要性。通过并查集，我们可以快速判断两个顶点是否在同一个连通块中，从而简化了问题的复杂度。此外，一些作者还提到了通过DFS来遍历图，但这种方法的时间复杂度较高，不适合处理大规模数据。因此，并查集是解决此类问题的最佳选择。

---
处理用时：43.94秒
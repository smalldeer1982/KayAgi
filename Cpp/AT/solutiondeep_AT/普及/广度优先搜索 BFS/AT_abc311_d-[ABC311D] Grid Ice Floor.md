# 题目信息

# [ABC311D] Grid Ice Floor

## 题目描述

有一个 $N \times M$ 的矩阵，并且有一个玩家站在上面。
其中 $(i, j)$ 表示矩阵的第 $i$ 行第 $j$ 列。
矩阵被表示为 $N$ 个字符串 $S_1 S_2S_3...S_N$，每个字符串长 $M$ 个字符。

矩阵每个格子都是冰或者岩石：如果 $S_i$ 的第 $j$ 个字符，即 $(i, j)$ 对应的字符为 `.`，那么 $(i, j)$ 是冰；如果是 `#`，$(i, j)$ 就是岩石。

这个矩阵的一周（第 $1$ 行、第 $N$ 行、第 $1$ 列，第 $M$ 列）均为岩石。
玩家起始所站的点 $(2, 2)$ 恒为冰。

玩家可以移动零次或任意次，每次移动需要先选定一个方向（上下左右），并且一直沿着这个方向移动直到遇到岩石（或不是冰）。

计算出玩家可以抵达或途径的所有格点（包括滑过的）。

## 说明/提示

对于 $100\%$ 的数据：

$ 3 \le N, M \le 200 $

$S_i$ 是长为 $M$ 的字符串，仅包含 `.` 和 `#`。

矩阵的边缘都是 `#`（岩石），且 $(2,2)$ 处一定为 `.`（冰）。

#### 样例1解释
比如玩家可以经过 $(5,5)$ 通过这样移动：

$(2, 2)$ → $(5, 2)$ → $(5, 5)$

玩家也可以经过 $(2, 4)$：

$(2, 2)$ → $(2, 5)$，途经 $(2, 4)$。

但玩家无法到达 $(3, 4)$。

## 样例 #1

### 输入

```
6 6

######

#....#

#.#..#

#..#.#

#....#

######```

### 输出

```
12```

## 样例 #2

### 输入

```
21 25

#########################

#..............###...####

#..............#..#...###

#........###...#...#...##

#........#..#..#........#

#...##...#..#..#...#....#

#..#..#..###...#..#.....#

#..#..#..#..#..###......#

#..####..#..#...........#

#..#..#..###............#

#..#..#.................#

#........##.............#

#.......#..#............#

#..........#....#.......#

#........###...##....#..#

#..........#..#.#...##..#

#.......#..#....#..#.#..#

##.......##.....#....#..#

###.............#....#..#

####.................#..#

#########################```

### 输出

```
215```

# AI分析结果

### 题目翻译

#### 题目描述

有一个 $N \times M$ 的矩阵，并且有一个玩家站在上面。其中 $(i, j)$ 表示矩阵的第 $i$ 行第 $j$ 列。矩阵被表示为 $N$ 个字符串 $S_1 S_2S_3...S_N$，每个字符串长 $M$ 个字符。

矩阵每个格子都是冰或者岩石：如果 $S_i$ 的第 $j$ 个字符，即 $(i, j)$ 对应的字符为 `.`，那么 $(i, j)$ 是冰；如果是 `#`，$(i, j)$ 就是岩石。

这个矩阵的一周（第 $1$ 行、第 $N$ 行、第 $1$ 列，第 $M$ 列）均为岩石。玩家起始所站的点 $(2, 2)$ 恒为冰。

玩家可以移动零次或任意次，每次移动需要先选定一个方向（上下左右），并且一直沿着这个方向移动直到遇到岩石（或不是冰）。

计算出玩家可以抵达或途径的所有格点（包括滑过的）。

#### 说明/提示

对于 $100\%$ 的数据：

$ 3 \le N, M \le 200 $

$S_i$ 是长为 $M$ 的字符串，仅包含 `.` 和 `#`。

矩阵的边缘都是 `#`（岩石），且 $(2,2)$ 处一定为 `.`（冰）。

#### 样例1解释

比如玩家可以经过 $(5,5)$ 通过这样移动：

$(2, 2)$ → $(5, 2)$ → $(5, 5)$

玩家也可以经过 $(2, 4)$：

$(2, 2)$ → $(2, 5)$，途经 $(2, 4)$。

但玩家无法到达 $(3, 4)$。

#### 样例 #1

##### 输入

```
6 6

######

#....#

#.#..#

#..#.#

#....#

######```

##### 输出

```
12```

#### 样例 #2

##### 输入

```
21 25

#########################

#..............###...####

#..............#..#...###

#........###...#...#...##

#........#..#..#........#

#...##...#..#..#...#....#

#..#..#..###...#..#.....#

#..#..#..#..#..###......#

#..####..#..#...........#

#..#..#..###............#

#..#..#.................#

#........##.............#

#.......#..#............#

#..........#....#.......#

#........###...##....#..#

#..........#..#.#...##..#

#.......#..#....#..#.#..#

##.......##.....#....#..#

###.............#....#..#

####.................#..#

#########################```

##### 输出

```
215```

### 题解分析与结论

本题的核心是通过搜索算法（BFS或DFS）来模拟玩家在冰面上的滑动过程，并统计所有可达的格子。难点在于如何正确处理滑动的方向以及在滑动过程中标记已经访问过的格子。

#### 关键思路与技巧

1. **方向处理**：玩家在滑动时必须沿着一个方向一直滑动，直到遇到岩石。因此，每次移动都需要沿着一个方向一直前进，直到无法继续前进为止。
2. **状态标记**：由于玩家可能会多次经过同一个格子，因此需要使用三维数组来标记每个格子从不同方向是否被访问过，避免重复计算。
3. **BFS与DFS的选择**：BFS和DFS都可以解决这个问题，但BFS通常更适合于这种需要逐层扩展的场景，而DFS则可以通过递归实现，代码相对简洁。

#### 评分较高的题解

##### 题解1：作者：rickyxrc (赞：3) 评分：4星

**关键亮点**：
- 使用BFS进行搜索，状态定义为$(x,y,pos)$，即坐标和方向。
- 使用三维数组`vis`来标记每个格子从不同方向是否被访问过，避免重复计算。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码**：
```cpp
std::queue<std::pair<std::pair<int, int>, int>> qu;
qu.push({{2, 2}, 0});
qu.push({{2, 2}, 1});
qu.push({{2, 2}, 2});
qu.push({{2, 2}, 3});
while (!qu.empty()) {
    auto u = qu.front();
    qu.pop();
    if (!mp[u.first.first][u.first.second] || u.first.first == 0 || u.first.second == 0 || u.first.first > n || u.first.second >= m)
        continue;
    if (vis[u.first.first][u.first.second][u.second])
        continue;
    vis[u.first.first][u.first.second][u.second] = 1;
    if (!book[u.first.first][u.first.second])
        book[u.first.first][u.first.second] = 1,
        res++;
    if (mp[u.first.first + dx[u.second]][u.first.second + dy[u.second]])
        qu.push({{u.first.first + dx[u.second], u.first.second + dy[u.second]}, u.second});
    else
        for (int i = 0; i < 4; i++)
            qu.push({{u.first.first + dx[i], u.first.second + dy[i]}, i});
}
```

##### 题解2：作者：2c_s (赞：3) 评分：4星

**关键亮点**：
- 使用BFS进行搜索，定义“落脚点”为每次在岩石前停下的冰块。
- 使用二维数组`cnt`来标记所有经过的格子，最后统计标记的格子数量。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
while (q.size()) {
    node now = q.front();
    q.pop();
    for (int i = 0; i < 4; ++i) {
        int xx = now.x;
        int yy = now.y;
        while (c[xx + dx[i]][yy + dy[i]] == '.') {
            xx += dx[i];
            yy += dy[i];
            cnt[xx][yy] = 1;
        }
        if (vis[xx][yy]) continue;
        vis[xx][yy] = 1;
        q.push({xx, yy});
    }
}
```

##### 题解3：作者：c1ampy (赞：0) 评分：4星

**关键亮点**：
- 使用DFS进行搜索，通过记忆化剪枝优化，避免重复搜索。
- 使用`searched`数组标记已经搜索过的格子，`reachable`数组标记可达的格子。
- 代码实现简洁，逻辑清晰，适合对DFS有一定理解的读者。

**核心代码**：
```cpp
void dfs(const int r, const int c, const int last_direction) {
    if (searched[r][c]) return;
    searched[r][c] = true;
    reachable[r][c] = true;
    for (int direction = 1; direction <= 4; ++direction) {
        if (direction + last_direction == 5) continue;
        int cur_r = r, cur_c = c;
        while (map[cur_r + dr[direction]][cur_c + dc[direction]] == '.') {
            cur_r += dr[direction];
            cur_c += dc[direction];
            reachable[cur_r][cur_c] = true;
        }
        dfs(cur_r, cur_c, direction);
    }
}
```

### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1131 [ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131)

---
处理用时：67.07秒
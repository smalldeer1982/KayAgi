# 题目信息

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>```

### 输出

```
15```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

#### [ABC317E] 避免眼神接触

##### 题目描述

有一个被分割成 $H$ 行 $W$ 列的网格状场地。  
从北（上方）数第 $i$ 行、从西（左方）数第 $j$ 列的格子用字符 $A_{i,\ j}$ 表示。每个字符的含义如下：

- `.` : 空地。可以进入。
- `#` : 障碍物。不能进入。
- `>`, `v`, `<`, `^` : 分别表示朝向东、南、西、北的人所在的格子。不能进入。人的视线宽度为 $1$ 格，沿着人面对的方向直线延伸，直到被障碍物或其他人阻挡。
- `S` : 起点。可以进入。保证只有一个起点，且不在任何人的视线范围内。
- `G` : 终点。可以进入。保证只有一个终点，且不在任何人的视线范围内。

Naohiro 位于起点，可以任意次数地向东、西、南、北移动一格。但是，他不能进入不能通过的格子或离开场地。  
请判断他是否可以在不进入任何人的视线的情况下到达终点，如果可以，输出所需的最小移动次数，否则输出 `-1`。

##### 说明/提示

###### 约束

- $2\ \leq\ H,\ W\ \leq\ 2000$
- $A_{i,j}$ 是 `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` 中的一种
- `S`, `G` 在 $A_{i,\ j}$ 中各出现一次
- 起点和终点都不在任何人的视线范围内

### 题解分析与结论

#### 题解对比与总结

1. **思路一致性**：所有题解都采用了预处理+广度优先搜索（BFS）的思路。首先预处理出所有被视线覆盖的格子，然后从起点开始进行BFS，寻找最短路径。
  
2. **预处理方式**：大多数题解通过遍历每个方向的人，标记其视线范围内的格子为不可通过。部分题解使用了动态规划或二分查找来优化预处理过程。

3. **BFS实现**：所有题解都使用了标准的BFS实现，通过队列来扩展节点，记录步数。

4. **时间复杂度**：预处理的时间复杂度为 $O(H \times W)$，BFS的时间复杂度也为 $O(H \times W)$，整体复杂度为 $O(H \times W)$。

5. **代码可读性**：部分题解的代码较为简洁，变量命名清晰，注释充分，易于理解。而有些题解的代码较为冗长，变量命名不够直观，可读性较差。

#### 最优题解推荐

1. **作者：FinderHT**
   - **星级**：★★★★★
   - **关键亮点**：代码结构清晰，预处理部分逻辑明确，BFS实现简洁高效。使用了 `pair` 来存储坐标，代码可读性高。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=h;i++){
         for(int j=1;j<=w;j++){
             if(s[i][j]=='>'){
                 int y=j+1;
                 while(s[i][y]=='.'||use[i][y]&&y<=w)use[i][y++]=true;
             }
             else if(s[i][j]=='<'){
                 int y=j-1;
                 while(s[i][y]=='.'||use[i][y]&&y>0)use[i][y--]=true;
             }
             else if(s[i][j]=='^'){
                 int x=i-1;
                 while((s[x][j]=='.'||use[x][j])&&x>0)use[x--][j]=true;
             }
             else if(s[i][j]=='v'){
                 int x=i+1;
                 while((s[x][j]=='.'||use[x][j])&&x<=h)use[x++][j]=true;
             }
         }
     }
     ```
   - **个人心得**：作者在预处理部分详细解释了每个方向的视线标记过程，代码逻辑清晰，易于理解。

2. **作者：Dream_poetry**
   - **星级**：★★★★☆
   - **关键亮点**：预处理部分使用了 `!` 来标记被视线覆盖的格子，BFS实现简洁，代码整体较为清晰。
   - **核心代码**：
     ```cpp
     if(ch[i][j]=='^'){
         int ii=i-1,jj=j;
         while((ch[ii][jj]=='.'||ch[ii][jj]=='!')&&ii>=1) 
             ch[ii--][jj]='!';
     }
     ```
   - **个人心得**：作者在预处理部分使用了 `!` 来标记被视线覆盖的格子，代码简洁且易于理解。

3. **作者：__Dist__**
   - **星级**：★★★★☆
   - **关键亮点**：预处理部分逻辑清晰，BFS实现简洁，代码整体较为清晰。
   - **核心代码**：
     ```cpp
     if(ch[i][j]=='<'){
         int ii=i,jj=j-1;
         while((ch[ii][jj]=='.'||ch[ii][jj]=='!')&&jj>=1) ch[ii][jj--]='!';
     }
     ```
   - **个人心得**：作者在预处理部分详细解释了每个方向的视线标记过程，代码逻辑清晰，易于理解。

### 最优关键思路与技巧

1. **预处理视线范围**：通过遍历每个方向的人，标记其视线范围内的格子为不可通过。可以使用动态规划或二分查找来优化预处理过程。

2. **BFS寻找最短路径**：从起点开始进行BFS，记录步数，直到找到终点或队列为空。

3. **代码优化**：使用 `pair` 来存储坐标，代码可读性高。预处理部分可以使用 `!` 来标记被视线覆盖的格子，代码简洁且易于理解。

### 可拓展之处

1. **类似题目**：可以扩展到更复杂的迷宫问题，如多起点、多终点、动态障碍物等。

2. **算法优化**：可以使用A*算法或其他启发式搜索算法来进一步优化路径搜索。

### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

### 个人心得总结

- **调试经历**：在预处理部分，需要注意视线范围的标记是否正确，避免遗漏或重复标记。
- **踩坑教训**：在BFS实现中，需要注意边界条件的判断，避免数组越界。
- **顿悟感想**：通过预处理和BFS的结合，可以高效地解决此类迷宫问题。

---
处理用时：58.24秒
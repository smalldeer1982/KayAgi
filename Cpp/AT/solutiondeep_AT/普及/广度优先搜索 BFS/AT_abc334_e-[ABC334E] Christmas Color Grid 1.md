# 题目信息

# [ABC334E] Christmas Color Grid 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_e

**この問題は問題 G と似た設定です。問題文の相違点を赤字で示します。**

$ H $ 行 $ W $ 列のグリッドがあり、グリッドの各マスは赤色あるいは緑色に塗られています。

グリッドの上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,j) $ と表記します。

マス $ (i,j) $ の色は文字 $ S_{i,j} $ で表され、$ S_{i,j}\ = $ `.` のときマス $ (i,j) $ は赤色、$ S_{i,j}\ = $ `#` のときマス $ (i,j) $ は緑色に塗られています。

グリッドにおいて、緑色に塗られたマスを頂点集合、隣り合った $ 2 $ つの緑色のマスを結ぶ辺全体を辺集合としたグラフにおける連結成分の個数を **緑の連結成分数** と呼びます。ただし、$ 2 $ つのマス $ (x,y) $ と $ (x',y') $ が隣り合っているとは、$ |x-x'|\ +\ |y-y'|\ =\ 1 $ であることを指します。

**赤色**に塗られたマスを一様ランダムに $ 1 $ つ選び、**緑色**に塗り替えたとき、塗り替え後のグリッドの緑の連結成分数の期待値を $ \text{mod\ }\ 998244353 $ で出力してください。

  「期待値を $ \text{mod\ }\ 998244353 $ で出力」とは 求める期待値は必ず有理数となることが証明できます。 またこの問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、 $ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ $ 1 $ つ存在することが証明できます。この $ R $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 1000 $
- $ S_{i,j}\ = $ `.` または $ S_{i,j}\ = $ `#`
- $ S_{i,j}\ = $ `.` なる $ (i,j) $ が存在する。
 
### Sample Explanation 1

マス $ (1,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (2,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (3,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 マス $ (3,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 よって、赤色に塗られたマスを一様ランダムに $ 1 $ つ選び、緑色に塗り替えた後の緑の連結成分数の期待値は $ (1+1+2+2)/4\ =\ 3/2 $ となります。

## 样例 #1

### 输入

```
3 3

##.

#.#

#..```

### 输出

```
499122178```

## 样例 #2

### 输入

```
4 5

..#..

.###.

#####

..#..```

### 输出

```
598946613```

## 样例 #3

### 输入

```
3 4

#...

.#.#

..##```

### 输出

```
285212675```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个 $H$ 行 $W$ 列的网格，网格中的每个格子被涂成红色或绿色。网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子记为 $(i,j)$。格子 $(i,j)$ 的颜色由字符 $S_{i,j}$ 表示，$S_{i,j} = $ `.` 时表示红色，$S_{i,j} = $ `#` 时表示绿色。

在网格中，将所有绿色格子视为顶点，相邻的两个绿色格子之间连一条边，形成的图的连通分量个数称为**绿色连通分量数**。两个格子 $(x,y)$ 和 $(x',y')$ 相邻的定义是 $|x-x'| + |y-y'| = 1$。

现在，随机选择一个红色格子并将其涂成绿色，求涂改后的网格中绿色连通分量数的期望值，结果对 $998244353$ 取模。

### 题解分析与结论

#### 题解对比与评分

1. **yydfj (4星)**
   - **亮点**：使用并查集预处理连通块，详细分析了涂色后连通块数量的变化情况，代码清晰且逻辑严谨。
   - **关键思路**：通过并查集预处理连通块，然后枚举每个红色格子，计算其涂色后对连通块数量的影响，最后求期望值。
   - **代码实现**：
     ```cpp
     for(int i=0;i<n;i++)
     for(int j=0;j<m;j++)
     if(s[i][j]=='.')
     {
         kk=(kk+1)%mod;
         mp.clear();
         ll ss=0;
         for(int k=0;k<4;k++)
         {
             ll xx=i+dx[k],yy=j+dy[k];
             if(xx<0||yy<0||xx>=n||yy>=m||s[xx][yy]=='.') continue;
             if(!mp.count(find(a[xx][yy]))) ss++,mp[find(a[xx][yy])]=1;
         }
         ans=(ans+tot-ss+1)%mod;
     }
     ```

2. **rui_er (4星)**
   - **亮点**：使用DFS预处理连通块，代码简洁且高效，逻辑清晰。
   - **关键思路**：通过DFS预处理连通块，然后枚举每个红色格子，计算其涂色后对连通块数量的影响，最后求期望值。
   - **代码实现**：
     ```cpp
     rep(i, 1, n) rep(j, 1, m) if(s[i][j] == '#') {
         rep(d, 0, 3) {
             int nx = i + nxt[d][0], ny = j + nxt[d][1];
             if(s[nx][ny] == '#') fa[find(get_pos(i,j))] = find(get_pos(nx,ny));
         }
     }
     ```

3. **harmis_yz (3星)**
   - **亮点**：使用并查集预处理连通块，代码逻辑清晰，但实现稍显冗长。
   - **关键思路**：通过并查集预处理连通块，然后枚举每个红色格子，计算其涂色后对连通块数量的影响，最后求期望值。
   - **代码实现**：
     ```cpp
     for(re int i=1;i<=n;++i)
     for(re int j=1;j<=m;++j)
     if(ch[i][j]=='.'){
         vk.clear();int dt=0;
         for(re int k=0;k<4;++k){
             int nowx=i+dx[k],nowy=j+dy[k];
             if(ch[nowx][nowy]!='#') continue;
             int s=find(get(nowx,nowy));
             if(!vk[s]) vk[s]=1,++dt;
         }
         P=(P+cnt-dt+1)%p;
     }
     ```

#### 最优关键思路

- **预处理连通块**：使用并查集或DFS预处理网格中的绿色连通块，标记每个绿色格子所属的连通块。
- **枚举红点计算影响**：对于每个红色格子，计算其涂色后对连通块数量的影响，具体为：若其周围有 $x$ 个不同的连通块，则涂色后连通块数量减少 $x-1$。
- **求期望值**：将所有红点的计算结果累加，除以红点总数，得到期望值。

#### 可拓展之处

- **类似题目**：可以扩展到其他网格问题，如动态修改网格颜色、计算连通块数量变化等。
- **算法优化**：可以考虑使用更高效的数据结构（如并查集优化）来进一步优化时间复杂度。

#### 推荐题目

1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
3. [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)

#### 个人心得

- **调试经历**：在处理边界条件时容易出错，特别是在枚举红点的相邻格子时，需要仔细检查是否越界。
- **踩坑教训**：在预处理连通块时，确保每个格子只被访问一次，避免重复计算。
- **顿悟感想**：通过预处理连通块，可以大大简化后续的计算过程，提高代码的可读性和效率。

---
处理用时：49.26秒
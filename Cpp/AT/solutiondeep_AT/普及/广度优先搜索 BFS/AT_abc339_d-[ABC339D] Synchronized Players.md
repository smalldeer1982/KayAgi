# 题目信息

# [ABC339D] Synchronized Players

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc339/tasks/abc339_d

$ N $ 行 $ N $ 列のグリッドがあり、各マスは空きマスか障害物のあるマスのいずれかです。グリッドの上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表記します。

また、$ 2 $ 人のプレイヤーがグリッド上の相異なる空きマス上におり、各マスの情報は $ N $ 個の長さ $ N $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_N $ として以下の形式で与えられます。

- $ S_i $ の $ j $ 文字目が `P` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいる
- $ S_i $ の $ j $ 文字目が `.` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいない
- $ S_i $ の $ j $ 文字目が `#` であるとき、$ (i,\ j) $ は障害物のあるマスである
 
以下の操作を繰り返し $ 2 $ 人のプレイヤーを同じマスに集めるために必要な操作回数の最小値を求めてください。ただし、操作の繰り返しにより $ 2 $ 人のプレイヤーを同じマスに集めることができない場合には `-1` を出力してください。

- 上下左右のいずれかの方向を決める。そして各プレイヤーはともにその方向に隣接するマスへの移動を試みる。各プレイヤーは移動先のマスが存在し、かつ空きマスであるならば移動し、そうでないならば移動しない。

## 说明/提示

### 制約

- $ N $ は $ 2 $ 以上 $ 60 $ 以下の整数
- $ S_i $ は長さ $ N $ の `P`, `.`, `#` からなる文字列
- $ S_i $ の $ j $ 文字目が `P` であるような組 $ (i,\ j) $ の個数はちょうど $ 2 $ つ
 
### Sample Explanation 1

はじめに $ (3,\ 2) $ にいるプレイヤーをプレイヤー $ 1 $、$ (4,\ 3) $ にいるプレイヤーをプレイヤー $ 2 $ とします。 例えば以下のようにすることで、$ 3 $ 回の操作で $ 2 $ 人のプレイヤーが同じマスに集まります。 - 左を選択する。プレイヤー $ 1 $ は $ (3,\ 1) $ に移動し、プレイヤー $ 2 $ は $ (4,\ 2) $ に移動する。 - 上を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 2) $ に移動する。 - 左を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 1) $ に移動する。

## 样例 #1

### 输入

```
5

....#

#..#.

.P...

..P..

....#```

### 输出

```
3```

## 样例 #2

### 输入

```
2

P#

#P```

### 输出

```
-1```

## 样例 #3

### 输入

```
10

..........

..........

..........

..........

....P.....

.....P....

..........

..........

..........

..........```

### 输出

```
10```

# AI分析结果

### 题目翻译
【题目内容】
# [ABC339D] Synchronized Players

## 题目描述

有一个 $N$ 行 $N$ 列的网格，每个格子要么是空地，要么是障碍物。网格从上到下第 $i$ 行、从左到右第 $j$ 列的格子记为 $(i, j)$。

此外，网格上有两个玩家，分别位于不同的空地上。网格的信息通过 $N$ 个长度为 $N$ 的字符串 $S_1, S_2, \ldots, S_N$ 给出，具体格式如下：

- 如果 $S_i$ 的第 $j$ 个字符是 `P`，则 $(i, j)$ 是空地且有一个玩家。
- 如果 $S_i$ 的第 $j$ 个字符是 `.`，则 $(i, j)$ 是空地且没有玩家。
- 如果 $S_i$ 的第 $j$ 个字符是 `#`，则 $(i, j)$ 是障碍物。

你需要通过以下操作将两个玩家移动到同一个格子，求所需的最小操作次数。如果无法将两个玩家移动到同一个格子，则输出 `-1`。

- 每次操作选择一个方向（上、下、左、右），两个玩家同时尝试向该方向移动。如果移动后的格子存在且是空地，则玩家移动；否则，玩家不移动。

## 说明/提示

### 约束

- $N$ 是 $2$ 到 $60$ 之间的整数。
- $S_i$ 是长度为 $N$ 的字符串，由 `P`, `.`, `#` 组成。
- $S_i$ 中 `P` 出现的次数恰好为 $2$ 次。

### 样例解释 1

初始时，玩家 1 位于 $(3, 2)$，玩家 2 位于 $(4, 3)$。通过以下操作，可以在 $3$ 次操作后将两个玩家移动到同一个格子：
- 选择左方向，玩家 1 移动到 $(3, 1)$，玩家 2 移动到 $(4, 2)$。
- 选择上方向，玩家 1 不动，玩家 2 移动到 $(3, 2)$。
- 选择左方向，玩家 1 不动，玩家 2 移动到 $(3, 1)$。

## 样例 #1

### 输入

```
5

....#

#..#.

.P...

..P..

....#```

### 输出

```
3```

## 样例 #2

### 输入

```
2

P#

#P```

### 输出

```
-1```

## 样例 #3

### 输入

```
10

..........

..........

..........

..........

....P.....

.....P....

..........

..........

..........

..........```

### 输出

```
10```

### 题解分析与结论

#### 总体思路
所有题解都采用了广度优先搜索（BFS）来解决这个问题。由于网格的大小 $N$ 最大为 $60$，状态数为 $O(N^4)$，在时间限制内完全可行。BFS 的核心思想是将两个玩家的位置作为一个状态，通过队列逐层扩展，直到两个玩家位于同一格子。

#### 关键难点
1. **状态表示**：需要将两个玩家的位置作为一个状态进行存储和访问，通常使用四维数组或哈希表来记录是否访问过某个状态。
2. **移动规则**：每次操作选择方向后，两个玩家同时尝试移动，如果移动后的格子是障碍物或超出边界，则玩家不移动。
3. **终止条件**：当两个玩家位于同一格子时，返回当前的操作次数。

#### 最优思路与技巧
1. **状态压缩**：将两个玩家的位置压缩为一个状态，使用四维数组或哈希表进行访问记录。
2. **方向数组**：使用方向数组简化移动操作，避免重复代码。
3. **边界检查**：在移动前检查目标格子是否合法，避免越界或撞到障碍物。

#### 推荐题解
1. **作者：cjh20090318**（5星）
   - **关键亮点**：代码简洁，状态表示清晰，使用四维数组记录访问状态，方向数组简化移动操作。
   - **核心代码**：
     ```cpp
     struct Node{
         int X1,Y1,X2,Y2,D;
         Node(int _X1=0,int _Y1=0,int _X2=0,int _Y2=0,int _D=0):X1(_X1),Y1(_Y1),X2(_X2),Y2(_Y2),D(_D){}
     };
     queue<Node> Q;
     ```
   - **个人心得**：通过将两个玩家的位置打包为一个状态，简化了 BFS 的实现。

2. **作者：Milthm**（4星）
   - **关键亮点**：代码结构清晰，使用四维数组记录访问状态，方向数组简化移动操作。
   - **核心代码**：
     ```cpp
     struct node{
         int x,y,x2,y2,d;
     };
     queue<node>q;
     ```
   - **个人心得**：通过 BFS 逐层扩展，确保找到最短路径。

3. **作者：CheZiHe929**（4星）
   - **关键亮点**：代码简洁，使用四维数组记录访问状态，方向数组简化移动操作。
   - **核心代码**：
     ```cpp
     struct node{
         int tx,ty,fx,fy,ans;
     };
     queue<node>q;
     ```
   - **个人心得**：通过 BFS 逐层扩展，确保找到最短路径。

### 推荐题目
1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1131 [ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131)

### 总结
本题的核心在于通过 BFS 搜索两个玩家的移动路径，状态表示和移动规则是解题的关键。通过方向数组和四维数组的优化，可以高效地完成搜索过程。

---
处理用时：50.80秒
# 题目信息

# [ABC348D] Medicines on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc348/tasks/abc348_d

$ H $ 行 $ W $ 列のグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,\ j) $ と表します。各マスの状態は文字 $ A_{i,j} $ で表され、意味は以下の通りです。

- `.` : 空きマス。
- `#` : 障害物。
- `S` : 空きマスかつスタート地点。
- `T` : 空きマスかつゴール地点。
 
高橋君は、今いるマスから上下左右に隣り合う空きマスへ、エネルギーを $ 1 $ 消費して移動することができます。ただし、エネルギーが $ 0 $ の状態で移動することはできず、またグリッドの外へ移動することはできません。

グリッドには合計で $ N $ 個の薬があります。$ i $ 番目の薬は空きマス $ (R_i,\ C_i) $ にあり、使うとエネルギーを **$ E_i $ にする**ことができます。必ずしもエネルギーが増えるとは限らないことに注意してください。高橋君は自分のいるマスにある薬を使うことができます。使った薬はなくなります。

高橋君ははじめエネルギー $ 0 $ の状態でスタート地点にいて、ゴール地点まで移動したいです。これが可能かどうか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 200 $
- $ A_{i,\ j} $ は `.`, `#`, `S`, `T` のいずれかである。
- `S` と `T` は $ A_{i,\ j} $ にそれぞれちょうど $ 1 $ つ存在する。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ R_i\ \leq\ H $
- $ 1\ \leq\ C_i\ \leq\ W $
- $ i\ \neq\ j $ ならば $ (R_i,\ C_i)\ \neq\ (R_j,\ C_j) $
- $ A_{R_i,\ C_i} $ は `#` でない。
- $ 1\ \leq\ E_i\ \leq\ HW $
 
### Sample Explanation 1

例えば、以下のようにしてゴール地点へ移動することができます。 - 薬 $ 1 $ を使う。エネルギーが $ 3 $ になる。 - $ (1,\ 2) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (1,\ 3) $ へ移動する。エネルギーが $ 1 $ になる。 - 薬 $ 2 $ を使う。エネルギーが $ 5 $ になる。 - $ (2,\ 3) $ へ移動する。エネルギーが $ 4 $ になる。 - $ (3,\ 3) $ へ移動する。エネルギーが $ 3 $ になる。 - $ (3,\ 4) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (4,\ 4) $ へ移動する。エネルギーが $ 1 $ になる。 この移動の途中には $ (2,\ 3) $ にも薬がありますが、これを使うとゴールできません。

### Sample Explanation 2

高橋君はスタート地点から移動することができません。

## 样例 #1

### 输入

```
4 4

S...

#..#

#...

..#T

4

1 1 3

1 3 5

3 2 1

2 3 1```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 2

S.

T.

1

1 2 4```

### 输出

```
No```

## 样例 #3

### 输入

```
4 5

..#..

.S##.

.##T.

.....

3

3 1 5

1 2 3

2 2 1```

### 输出

```
Yes```

# AI分析结果

### 题目翻译

#### 题目描述

有一个 $H$ 行 $W$ 列的网格。从上往下第 $i$ 行、从左往右第 $j$ 列的格子表示为 $(i, j)$。每个格子的状态由字符 $A_{i,j}$ 表示，含义如下：

- `.`：空格子。
- `#`：障碍物。
- `S`：空格子且为起点。
- `T`：空格子且为终点。

高桥君可以从当前格子向上下左右相邻的空格子移动，每次移动消耗 $1$ 点能量。如果能量为 $0$，则无法移动，且不能移动到网格外。

网格中共有 $N$ 种药物。第 $i$ 种药物位于空格子 $(R_i, C_i)$，使用后可以将能量**设为** $E_i$。注意，能量不一定会增加。高桥君可以选择是否使用当前格子中的药物，使用后药物会消失。

高桥君初始能量为 $0$，位于起点，目标是到达终点。请判断是否可能到达终点。

#### 说明/提示

##### 约束条件

- $1 \leq H, W \leq 200$
- $A_{i,j}$ 是 `.`, `#`, `S`, `T` 之一。
- `S` 和 `T` 在 $A_{i,j}$ 中各出现一次。
- $1 \leq N \leq 300$
- $1 \leq R_i \leq H$
- $1 \leq C_i \leq W$
- 若 $i \neq j$，则 $(R_i, C_i) \neq (R_j, C_j)$
- $A_{R_i, C_i}$ 不是 `#`
- $1 \leq E_i \leq H \times W$

##### 样例解释 1

例如，可以通过以下方式到达终点：
- 使用药物 $1$，能量变为 $3$。
- 移动到 $(1, 2)$，能量变为 $2$。
- 移动到 $(1, 3)$，能量变为 $1$。
- 使用药物 $2$，能量变为 $5$。
- 移动到 $(2, 3)$，能量变为 $4$。
- 移动到 $(3, 3)$，能量变为 $3$。
- 移动到 $(3, 4)$，能量变为 $2$。
- 移动到 $(4, 4)$，能量变为 $1$。

在移动过程中，$(2, 3)$ 也有药物，但如果使用它，则无法到达终点。

##### 样例解释 2

高桥君无法从起点移动。

### 题解分析与结论

本题的核心是通过 BFS 或优先队列 BFS 来模拟高桥君的移动过程，并考虑药物的使用对能量的影响。难点在于如何高效地处理药物的使用和能量的更新，避免重复计算。

#### 关键思路与技巧

1. **优先队列 BFS**：使用优先队列（堆）来确保每次扩展时选择当前能量最大的节点，从而减少不必要的扩展。
2. **能量更新策略**：每次移动到新格子时，若该格子有药物，则更新能量为药物提供的能量值；否则，能量减 1。
3. **剪枝优化**：记录每个格子的最大能量值，若当前能量小于等于该值，则跳过该节点，避免重复计算。

#### 推荐题解

1. **作者：__ATRI__**  
   - **星级**：★★★★★  
   - **关键亮点**：使用优先队列 BFS，确保每次扩展时选择能量最大的节点，优化了搜索效率。代码清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     void bfs(){
         priority_queue<node>q;
         memset(dis,-0x3f,sizeof dis);
         dis[sx][sy]=max(b[sx][sy],0);
         q.push({sx,sy,dis[sx][sy]});
         while(q.size()){
             auto[x,y,val]=q.top();
             q.pop();
             if(x==fx&&y==fy){
                 cout << "Yes" << endl;
                 return;
             }
             if(!val)continue;
             if(val<dis[x][y])continue;
             for(int i=0;i<4;++i){
                 int xx=x+dx[i],yy=y+dy[i];
                 if(xx<1||xx>n||yy<1||yy>m||!a[xx][yy])continue;
                 int v=b[xx][yy]?max(b[xx][yy],val-1):val-1;
                 if(v>dis[xx][yy]){
                     q.push({xx,yy,v});
                     dis[xx][yy]=v;
                 }
             }
         }
         cout << "No" << endl;
     }
     ```

2. **作者：Fiendish**  
   - **星级**：★★★★☆  
   - **关键亮点**：使用 BFS 并记录每个格子的最大能量值，避免了重复计算。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     void bfs(){
         queue<node>q;
         q.push({sx,sy,e[sx][sy]});
         vis[sx][sy]=e[sx][sy];
         while(!q.empty()){
             node u=q.front();
             q.pop();
             if(u.x==tx&&u.y==ty){
                 cout<<"Yes";
                 return;
             }
             if(u.e==0)continue;
             for(int i=0;i<4;i++){
                 int nx=u.x+dx[i],ny=u.y+dy[i],ne=u.e-1;
                 if(nx<1||ny<1||nx>n||ny>m||a[nx][ny]=='#')continue;
                 ne=max(ne,e[nx][ny]);
                 if(ne>vis[nx][ny]){
                     vis[nx][ny]=ne;
                     q.push({nx,ny,ne});
                 }
             }
         }
         cout<<"No";
     }
     ```

3. **作者：I_will_AKIOI**  
   - **星级**：★★★★☆  
   - **关键亮点**：使用优先队列 BFS，并通过记录每个格子的最大能量值进行剪枝，优化了搜索效率。代码结构清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     void bfs(){
         priority_queue<node>q;
         q.push({sx,sy,e[sx][sy]});
         vis[sx][sy]=e[sx][sy];
         while(!q.empty()){
             node u=q.front();
             q.pop();
             if(u.x==tx&&u.y==ty){
                 cout<<"Yes";
                 return;
             }
             if(u.e==0)continue;
             for(int i=0;i<4;i++){
                 int nx=u.x+dx[i],ny=u.y+dy[i],ne=u.e-1;
                 if(nx<1||ny<1||nx>n||ny>m||a[nx][ny]=='#')continue;
                 ne=max(ne,e[nx][ny]);
                 if(ne>vis[nx][ny]){
                     vis[nx][ny]=ne;
                     q.push({nx,ny,ne});
                 }
             }
         }
         cout<<"No";
     }
     ```

### 拓展思路与推荐题目

1. **拓展思路**：本题的核心是 BFS 结合优先队列的使用，适用于类似的网格搜索问题，尤其是需要考虑状态更新的场景。类似的题目可能涉及能量、时间等限制条件，优先队列可以帮助优化搜索效率。

2. **推荐题目**：
   - [P3958 奶酪](https://www.luogu.com.cn/problem/P3958)：同样是 BFS 的应用，考察连通性判断。
   - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：BFS 在网格中的应用，考察最短路径。
   - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：BFS 的应用，考察连通区域的填充。

### 个人心得总结

- **调试经历**：在处理药物的能量更新时，容易忽略药物使用后能量的变化，导致搜索效率低下或结果错误。通过记录每个格子的最大能量值，可以有效避免重复计算。
- **顿悟感想**：优先队列 BFS 在处理类似问题时非常有效，尤其是在需要优先处理某些状态的情况下，能够显著提高搜索效率。

---
处理用时：74.90秒
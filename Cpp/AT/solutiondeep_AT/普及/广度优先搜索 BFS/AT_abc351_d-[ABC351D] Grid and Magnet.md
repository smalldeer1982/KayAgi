# 题目信息

# [ABC351D] Grid and Magnet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_d

$ H $ 行 $ W $ 列のマス目があり、いくつか（$ 0 $ 個のこともある）のマスには磁石が置かれています。  
マス目の状態は $ H $ 個の 長さ $ W $ の文字列 $ S_1,S_2,\ldots,S_H $ で表され、 $ S_i $ の $ j $ 文字目が `#` のとき上から $ i $ 行目かつ左から $ j $ 列目のマスには磁石が置かれていることを、 `.` のとき何も置かれていないことを表しています。

高橋君は鉄の鎧を着ており、あるマスにいるとき次のように移動することができます。

- 現在いるマスの上下左右に隣り合うマスのいずれかに磁石が置かれているとき、どこへも移動することができない。
- そうでないとき、上下左右に隣り合うマスのいずれかを選んでそのマスに移動することができる。  
  ただし、マス目の外に移動することはできない。

磁石が置かれていない各マスについて、そのマスの自由度を、「最初高橋くんがそのマスにいるとき、そこから移動を繰り返して到達できるマスの個数」として定義します。 マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を求めてください。

ただし、自由度の定義において、「移動を繰り返して到達できるマス」とは、最初にいるマスからそのマスまで移動を繰り返して到達する方法（$ 1 $ 回も移動しないものも含む）が $ 1 $ つ以上存在するようなマスのことであり、 最初のマスから始めてすべてのそのようなマスを巡るような移動方法が存在する必要はありません。特に（磁石の置かれていない）各マス自身は、そのマスから「移動を繰り返して到達できるマス」につねに含まれることに注意してください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ H,W $ は整数
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列
- 磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。

### Sample Explanation 1

上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。

### Sample Explanation 2

磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。

## 样例 #1

### 输入

```
3 5
.#...
.....
.#..#```

### 输出

```
9```

## 样例 #2

### 输入

```
3 3
..#
#..
..#```

### 输出

```
1```

# AI分析结果

### 题目内容重写

**题目描述**

有一个 $H$ 行 $W$ 列的网格，某些格子上放置了磁石。网格的状态由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 表示，其中 $S_i$ 的第 $j$ 个字符为 `#` 表示第 $i$ 行第 $j$ 列的格子上有磁石，为 `.` 表示该格子为空。

高桥君穿着铁制铠甲，他在某个格子上的移动规则如下：

- 如果当前格子的上下左右相邻格子中有磁石，则他不能移动。
- 否则，他可以选择上下左右相邻的任意一个格子移动，但不能移动到网格外。

定义每个没有磁石的格子的“自由度”为：高桥君从该格子出发，通过移动可以到达的格子数量。求所有没有磁石的格子中，自由度的最大值。

**说明/提示**

- $1 \leq H, W \leq 1000$
- $H, W$ 为整数
- $S_i$ 仅由 `.` 和 `#` 组成，长度为 $W$
- 至少有一个格子没有磁石

**样例解释**

- 样例1：高桥君从 $(2,3)$ 出发，可以到达9个格子，因此自由度为9。
- 样例2：所有没有磁石的格子都无法移动，因此自由度为1。

### 题解分析与结论

#### 综合分析

本题的核心是通过搜索算法（如BFS或DFS）计算每个没有磁石的格子的自由度，并找出最大值。难点在于如何处理那些与磁石相邻的格子，这些格子的自由度通常为1，且不能继续扩展搜索。此外，为了避免重复计算，需要合理地标记已访问的格子。

#### 最优关键思路

1. **分类处理格子**：将格子分为三类：有磁石的格子、与磁石相邻的格子（自由度固定为1）、不与磁石相邻的格子（可以通过搜索计算自由度）。
2. **BFS优化**：对于不与磁石相邻的格子，使用BFS计算其连通块的大小，并在搜索过程中将与磁石相邻的格子加入结果，但不继续扩展。
3. **标记与去重**：使用标记数组避免重复访问，并在搜索结束后清空与磁石相邻的格子的标记，以便其他连通块可以重新访问这些格子。

#### 推荐题解

1. **作者：2huk (5星)**
   - **关键亮点**：通过分类处理格子，优化BFS搜索，避免了重复计算，代码清晰且高效。
   - **代码核心**：
     ```cpp
     int bfs(int x, int y) {
         if (chk(x, y)) return 1;
         if (st[x][y]) return -114514;
         queue<pair<int, int>> q;
         q.emplace(x, y);
         int ans = 0;
         st[x][y] = true;
         map<pair<int, int>, bool> S;
         while (q.size()) {
             int x = q.front().first, y = q.front().second;
             q.pop();
             ++ans;
             if (!chk(x, y)) {
                 for (int i = 0; i < 4; ++i) {
                     int a = x + dx[i], b = y + dy[i];
                     if (a >= 1 && a <= n && b >= 1 && b <= m && g[a][b] == '.') {
                         if (chk(a, b)) {
                             if (!S[{a, b}]) {
                                 q.emplace(a, b);
                                 S[{a, b}] = true;
                             }
                         } else if (!st[a][b]) {
                             q.emplace(a, b);
                             st[a][b] = true;
                         }
                     }
                 }
             }
         }
         return ans;
     }
     ```

2. **作者：HasNoName (4星)**
   - **关键亮点**：通过广搜处理每个不在磁石上且不在磁石旁边的位置，并在搜索结束后清空与磁石相邻的格子的标记，避免了重复计算。
   - **代码核心**：
     ```cpp
     int l = 1, r = 0, c = 1, top = 0;
     q[++r] = {i, j};
     vis[i][j] = 1;
     while (l <= r) {
         int x = q[l].x, y = q[l].y;
         l++;
         if (!can(x, y)) {
             p[++top] = {x, y};
             continue;
         }
         if (ok(x - 1, y)) to(x - 1, y)
         if (ok(x + 1, y)) to(x + 1, y)
         if (ok(x, y - 1)) to(x, y - 1)
         if (ok(x, y + 1)) to(x, y + 1)
     }
     ```

3. **作者：ThisIsLu (4星)**
   - **关键亮点**：通过改进的DFS，保持原标记并撤掉与磁石相邻的格子的标记，避免了重复搜索，时间复杂度仍为线性。
   - **代码核心**：
     ```cpp
     void dfs(int x, int y) {
         if (vis[x][y]) return;
         vis[x][y] = true;
         res++;
         bool flag = false;
         for (int i = 0; i < 4; i++) {
             int nx = x + dx[i], ny = y + dy[i];
             if (1 <= nx && nx <= n && 1 <= ny && ny <= m) {
                 if (ch[nx][ny] == '#') {
                     flag = true;
                     break;
                 }
             }
         }
         if (!flag) {
             for (int i = 0; i < 4; i++) {
                 int nx = x + dx[i], ny = y + dy[i];
                 if (1 <= nx && nx <= n && 1 <= ny && ny <= m) {
                     dfs(nx, ny);
                 }
             }
         } else {
             cnt++;
             qx[cnt] = x;
             qy[cnt] = y;
         }
     }
     ```

### 扩展思路与推荐题目

1. **扩展思路**：本题的搜索优化思路可以应用于类似的网格搜索问题，如迷宫问题、连通块计算等。通过分类处理和标记优化，可以有效减少重复计算，提高算法效率。
2. **推荐题目**：
   - [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
   - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
   - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得摘录

- **调试经历**：在处理与磁石相邻的格子时，最初没有正确标记这些格子，导致重复计算。通过引入额外的标记数组和清空操作，解决了这一问题。
- **顿悟感想**：分类处理格子的思路极大地简化了问题，使得搜索过程更加清晰和高效。

---
处理用时：71.31秒
# 题目信息

# [ABC361D] Go Stone Puzzle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_d

$ N+2 $ 個のマスが横一列に並んでいます。左から $ i $ 番目のマスをマス $ i $ と表します。

マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれています。  
 各 $ 1\leq\ i\ \leq\ N $ について、$ S_i $ が `W` のときマス $ i $ に置かれている石の色は白であり、$ S_i $ が `B` のときマス $ i $ に置かれている石の色は黒です。  
 マス $ N+1,N+2 $ には何も置かれていません。

あなたは以下の操作を好きな回数($ 0 $ 回でもよい)行うことができます。

- 石が $ 2 $ 個並んでいる箇所を選び、その $ 2 $ 個の石を順序を保って空きマスに移す。  
   より正確には次の通り。$ 1 $ 以上 $ N+1 $ 以下の整数 $ x $ であって、マス $ x,x+1 $ の両方に石が置かれているものを選ぶ。石の置かれていないマスを $ k,k+1 $ とする。マス $ x,x+1 $ にある石をそれぞれマス $ k,k+1 $ に移動する。
 
以下の状態にすることが可能か判定し、可能なら操作回数の最小値を求めてください。

- マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれており、各 $ 1\leq\ i\ \leq\ N $ について、$ T_i $ が `W` のときマス $ i $ に置かれている石の色は白、$ T_i $ が `B` のときマス $ i $ に置かれている石の色は黒である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 14 $
- $ N $ は整数である
- $ S,T $ は `B` および `W` のみからなる長さ $ N $ の文字列である
 
### Sample Explanation 1

石が置かれていないマスを `.` と表します。以下のようにして $ 4 $ 回の操作で目的の状態にすることができ、これが最小回数です。 - `BWBWBW..` - `BW..BWBW` - `BWWBB..W` - `..WBBBWW` - `WWWBBB..`

## 样例 #1

### 输入

```
6

BWBWBW

WWWBBB```

### 输出

```
4```

## 样例 #2

### 输入

```
6

BBBBBB

WWWWWW```

### 输出

```
-1```

## 样例 #3

### 输入

```
14

BBBWBWWWBBWWBW

WBWWBBWWWBWBBB```

### 输出

```
7```

# AI分析结果

### 题目内容重写（中文）

有 $N+2$ 个单元格排成一行。单元格 $i$ 表示从左边开始的第 $i$ 个单元格。

从单元格 $1$ 到单元格 $N$，每个单元格中都有一块石头。  
对于每一个 $1 \leq i \leq N$，如果 $S_i$ 是 `W`，那么 $i$ 单元格中的石头是白色的；如果 $S_i$ 是 `B`，那么 $S_i$ 中的石头是黑色的。单元格 $N+1$ 和 $N+2$ 为空。

你可以执行以下操作任意多次（可能为零次）：

- 选择一对都有石头的相邻单元格，然后将这两个石头移动到空的两个单元格中，同时保持它们的顺序。更确切地说，选择一个整数 $x$，使得 $1 \leq x \leq N+1$ 和 $x$ 以及 $x+1$ 两个单元格都包含石头。假设 $k$ 和 $k+1$ 是空的两个单元格。将 $x$ 和 $x+1$ 两个单元格中的石头分别移动到 $k$ 和 $k+1$ 两个单元格中。

判断是否可以达到下面的状态。如果可以，求所需的最小操作次数：

- 从单元格 $1$ 到 $N$ 的每个单元格中都有一颗石头，对于每个 $1 \leq i \leq N$，如果 $T_i$ 为 `W`，则 $i$ 单元格中的石头为白色；如果 $T_i$ 为 `B`，则 $i$ 单元格中的石头为黑色。

### 题解分析与结论

本题的核心是通过广度优先搜索（BFS）来找到从初始状态到目标状态的最小操作次数。由于 $N$ 的范围较小（$2 \leq N \leq 14$），BFS 是一种可行的解法。以下是各题解的要点总结：

1. **BFS + 状态压缩**：大多数题解都采用了 BFS 来搜索所有可能的状态，并通过状态压缩（如将字符串转换为三进制数）来减少内存消耗。
2. **记忆化**：使用 `unordered_map` 或 `map` 来记录已经访问过的状态，避免重复搜索。
3. **状态转移**：通过交换相邻的两个石头和两个空位来进行状态转移，确保每次操作都符合题意。

### 高星题解推荐

#### 题解1：作者：shangruolin (赞：6)
- **星级**：5星
- **关键亮点**：
  - 使用 `tuple` 存储状态，代码简洁易读。
  - 通过 `unordered_map` 进行记忆化，优化了搜索效率。
  - 状态转移清晰，直接模拟交换操作。
- **核心代码**：
```cpp
queue <T> q;
q.push (MT (0, n + 1, a)); mp[a] = 1;
while (!q.empty ()) {
    int x = get <0> (q.front ()), y = get <1> (q.front ());
    string s = get <2> (q.front ()); q.pop ();
    if (s == b) return cout << x, 0;
    for (int i = 1; i <= n + 1; i++) {
        if (s[i] != '#' && s[i + 1] != '#') {
            swap (s[i], s[y]);
            swap (s[i + 1], s[y + 1]);
            if (!mp[s]) {
                mp[s] = 1;
                q.push (MT (x + 1, i, s));
            }
            swap (s[i], s[y]);
            swap (s[i + 1], s[y + 1]);
        }
    }
}
```

#### 题解2：作者：include13_fAKe (赞：4)
- **星级**：4星
- **关键亮点**：
  - 使用三进制状态压缩，减少了内存占用。
  - 通过 BFS 搜索所有可能的状态，确保找到最小操作次数。
  - 代码结构清晰，注释详细。
- **核心代码**：
```cpp
queue<int> q;
q.push(st);
while(!q.empty()){
    int now=q.front();
    q.pop();
    int dot=now_init(now);
    for(int i=1;i<=n+1;i++){
        if(i!=dot&&i!=dot+1&i!=dot-1){
            swap(now2[i],now2[dot]);
            swap(now2[i+1],now2[dot+1]);
            int st1=0; 
            for(int j=1;j<=n+2;j++){
                int now;
                switch(now2[j]){
                    case 'B':now=0;break;
                    case 'W':now=1;break;
                    default:now=2;
                }
                st1=st1*3+now;
            }
            if(ans[st1]>=1e9){
                ans[st1]=ans[now]+1;
                q.push(st1);
            }	
            swap(now2[i],now2[dot]);
            swap(now2[i+1],now2[dot+1]);		
        }
    }
}
```

#### 题解3：作者：Ivan422 (赞：4)
- **星级**：4星
- **关键亮点**：
  - 使用 `map` 进行记忆化，代码简洁。
  - 通过 BFS 搜索所有可能的状态，确保找到最小操作次数。
  - 状态转移清晰，直接模拟交换操作。
- **核心代码**：
```cpp
queue<pair<string,int> >q;
q.push(make_pair(nw,0));mp[nw]=1;
while(q.size()){
    pair<string,int>fr=q.front();
    q.pop();no=fr.first;
    if(no==nd){cout<<fr.second;return 0;}
    sp=0;
    for(int i=0;i<=n;i++){if(no[i]==' '&&no[i+1]==' ')sp=i;}
    for(int i=0;i<=n;i++){if(no[i]!=' '&&no[i+1]!=' '){
        ds=no;
        ds[sp]=ds[i];ds[sp+1]=ds[i+1];
        ds[i]=ds[i+1]=' ';
        if(mp[ds])continue;
        q.push(make_pair(ds,fr.second+1));mp[ds]=1;
    }}
}
```

### 最优关键思路与技巧

1. **BFS + 状态压缩**：通过 BFS 搜索所有可能的状态，并使用状态压缩（如三进制数）来减少内存消耗。
2. **记忆化**：使用 `unordered_map` 或 `map` 记录已经访问过的状态，避免重复搜索。
3. **状态转移**：通过交换相邻的两个石头和两个空位来进行状态转移，确保每次操作都符合题意。

### 拓展与举一反三

- **类似题目**：
  - [P2731 [USACO3.3] 骑马修栅栏 Riding the Fences](https://www.luogu.com.cn/problem/P2731)
  - [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)
  - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得总结

- **调试经历**：在状态转移时，确保每次交换操作后恢复原状态，避免影响后续搜索。
- **踩坑教训**：使用 `unordered_map` 时，注意键值的唯一性，避免重复插入。
- **顿悟感想**：BFS 在状态空间较小的情况下，是一种非常有效的搜索算法，尤其是在需要找到最短路径或最小操作次数时。

---
处理用时：75.52秒
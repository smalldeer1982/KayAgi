# 题目信息

# [ABC363E] Sinking Land

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_e

$ H\ \times\ W $ の大きさの島があり、島は周りを海で囲まれています。  
 島は 縦 $ H $ 個 $ \times $ 横 $ W $ 個の $ 1\times\ 1 $ の区画に分けられており、上から $ i $ 番目かつ左から $ j $ 番目の区画の（現在の海面を基準にした）標高は $ A_{i,j} $ です。

現在から $ 1 $ 年ごとに海面の高さが $ 1 $ ずつ上昇します。  
 このとき、海または海に沈んだ区画に上下左右に隣接する区画であって、標高が海面の高さ **以下** の区画は海に沈みます。  
 ここで、ある区画が新しく海に沈んだときそれと上下左右に隣接する区画であって海面の高さ以下のものも同時に海に沈み、これによって新しく沈んだ区画についてもこれは繰り返されます。

$ i=1,2,\ldots,\ Y $ それぞれについて、現在から $ i $ 年後に、島のうち海に沈まず残っている部分の面積を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ 1\leq\ Y\leq\ 10^5 $
- $ 1\leq\ A_{i,j}\leq\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

島の上から $ i $ 番目かつ左から $ j $ 番目の区画を $ (i,j) $ で表します。このとき、次のようになります。 - $ 1 $ 年後、海面は現在より $ 1 $ 上昇しますが、海に面している標高 $ 1 $ の区画は存在しないため、どの区画も沈みません。よって、$ 1 $ 行目には $ 9 $ を出力します。 - $ 2 $ 年後、海面は現在より $ 2 $ 上昇し、$ (1,2) $ が海に沈みます。これによって、$ (2,2) $ は海に沈んだ区画に隣接する区画となりますが、その標高は $ 2 $ 以下であるため、これも海に沈みます。これら以外にこの時点で他に沈む区画はありません。よって、$ 2 $ つの区画が沈むため、$ 2 $ 行目には $ 9-2=7 $ を出力します。 - $ 3 $ 年後、海面は現在より $ 3 $ 上昇し、$ (2,1) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 3 $ 行目には $ 6 $ を出力します。 - $ 4 $ 年後、海面は現在より $ 4 $ 上昇し、$ (2,3) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 4 $ 行目には $ 5 $ を出力します。 - $ 5 $ 年後、海面は現在より $ 5 $ 上昇し、$ (3,2) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 5 $ 行目には $ 4 $ を出力します。 よって、$ 9,7,6,5,4 $ をこの順に各行に出力します。

## 样例 #1

### 输入

```
3 3 5

10 2 10

3 1 4

10 5 10```

### 输出

```
9

7

6

5

4```

## 样例 #2

### 输入

```
3 5 3

2 2 3 3 3

2 1 2 1 3

2 2 3 3 3```

### 输出

```
15

7

0```

# AI分析结果

### 题目重写
【题目内容】
# [ABC363E] 下沉的陆地

## 题目描述

$ H \times W $ 大小的岛屿被海包围。岛屿被划分为 $ H $ 行 $ W $ 列的 $ 1 \times 1 $ 的区画，从上到下第 $ i $ 行、从左到右第 $ j $ 列的区画的标高为 $ A_{i,j} $。

从当前时刻开始，每年海平面上升 $ 1 $。此时，与海或已经沉没的区画上下左右相邻且标高小于等于海平面高度的区画也会沉没。当一个区画新沉没时，与其相邻的标高小于等于海平面的区画也会同时沉没，这个过程会不断重复。

对于 $ i=1,2,\ldots, Y $，分别求出现在到 $ i $ 年后，岛屿中未被淹没的区画的面积。

## 说明/提示

### 约束

- $ 1 \leq H, W \leq 1000 $
- $ 1 \leq Y \leq 10^5 $
- $ 1 \leq A_{i,j} \leq 10^5 $
- 输入均为整数

### 样例解释 1

岛从上到下第 $ i $ 行、从左到右第 $ j $ 列的区画用 $ (i,j) $ 表示。此时，情况如下：
- $ 1 $ 年后，海面比当前上升 $ 1 $，但没有标高为 $ 1 $ 的区画，因此没有区画沉没。输出 $ 9 $。
- $ 2 $ 年后，海面比当前上升 $ 2 $，$ (1,2) $ 沉没。由于 $ (2,2) $ 与沉没区画相邻且标高为 $ 2 $，它也沉没。输出 $ 7 $。
- $ 3 $ 年后，海面比当前上升 $ 3 $，$ (2,1) $ 沉没。输出 $ 6 $。
- $ 4 $ 年后，海面比当前上升 $ 4 $，$ (2,3) $ 沉没。输出 $ 5 $。
- $ 5 $ 年后，海面比当前上升 $ 5 $，$ (3,2) $ 沉没。输出 $ 4 $。

## 样例 #1

### 输入

```
3 3 5

10 2 10

3 1 4

10 5 10
```

### 输出

```
9

7

6

5

4
```

## 样例 #2

### 输入

```
3 5 3

2 2 3 3 3

2 1 2 1 3

2 2 3 3 3
```

### 输出

```
15

7

0
```

### 题解分析与结论

#### 综合分析与结论
本题的核心在于模拟海平面上升过程中岛屿的沉没过程。由于海平面每年上升，且沉没过程具有传播性，因此需要高效地处理每年可能沉没的区画。大多数题解采用了优先队列（小根堆）来维护当前可能沉没的区画，并按照海拔高度从小到大进行处理。这种方法的时间复杂度为 $O(HW \log HW)$，能够满足题目要求。

#### 最优关键思路
1. **优先队列**：使用优先队列（小根堆）来维护当前可能沉没的区画，确保每次处理的是海拔最低的区画。
2. **广度优先搜索（BFS）**：当某个区画沉没时，通过 BFS 将其相邻的区画加入队列，确保沉没过程的传播性。
3. **标记数组**：使用标记数组记录每个区画是否已经被处理过，避免重复处理。

#### 可拓展之处
1. **类似问题**：类似的问题可以扩展到其他传播性过程，如火灾蔓延、病毒传播等。
2. **优化思路**：可以考虑使用并查集或其他数据结构来进一步优化沉没过程的处理。

#### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

### 所选高分题解

#### 题解1：作者：cqbzcjh (赞：8)
- **星级**：★★★★★
- **关键亮点**：使用优先队列和 BFS 高效处理沉没过程，代码简洁且思路清晰。
- **核心代码**：
```cpp
priority_queue<node> q;
for(int i=1;i<=h;i++){
    for(int j=1;j<=w;j++){
        if((i==1)||(i==h)||(j==1)||(j==w)){
            vis[i][j]=true;
            q.push({a[i][j],i,j});
        }
    }
}
ans=h*w;
for(int i=1;i<=y;i++){
    while(!q.empty()&&q.top().v<=i){
        node u=q.top();
        q.pop();
        ans--;
        for(int j=0;j<4;j++){
            int tx=u.x+dx[j];
            int ty=u.y+dy[j];
            if(tx>=1&&tx<=h&&ty>=1&&ty<=w&&!vis[tx][ty]){
                vis[tx][ty]=true;
                q.push({a[tx][ty],tx,ty});
            }
        }
    }
    cout<<ans<<"\n";
}
```
- **核心思想**：将岛屿边缘的区画加入优先队列，每年处理海拔小于等于当前海平面的区画，并将其相邻区画加入队列。

#### 题解2：作者：Crsuh2er0 (赞：4)
- **星级**：★★★★
- **关键亮点**：使用优先队列和 DFS 处理沉没过程，代码结构清晰，处理了部分边界情况。
- **核心代码**：
```cpp
priority_queue<edge, basic_string<edge>, greater<edge> > q;
void dfs(int x, int y) {
    if (vis[x][y] || x > h || y > w || !x || !y) return;
    if (a[x][y] <= a[h + 1][w + 1]) {
        vis[x][y] = 1, ans--;
        dfs(x + 1, y), dfs(x, y + 1);
        dfs(x - 1, y), dfs(x, y - 1);
    } else if (!inq[x][y])
        q.push({x, y}), inq[x][y] = 1;
}
```
- **核心思想**：使用 DFS 处理沉没过程，并将可能沉没的区画加入优先队列。

#### 题解3：作者：2011FYCCCTA (赞：2)
- **星级**：★★★★
- **关键亮点**：通过优先队列和 BFS 处理沉没过程，思路清晰，代码简洁。
- **核心代码**：
```cpp
priority_queue <p,vector <p>,greater <p> > q;
for(int i=0;i<=n+1;i++) q.push ({0,{i,0}}),q.push ({0,{i,m+1}});
for(int i=0;i<=m+1;i++) q.push ({0,{0,i}}),q.push ({0,{n+1,i}});
int ans = n * m;
for(int i=1;i<=k;i++){
    while(q.size() && q.top().x <= i){
        PII u = q.top().y;
        ans -= q.top().x != 0;
        q.pop();
        for(int i=0;i<4;i++){
            int x = u.x + dx[i],y = u.y + dy[i];
            if(x < 1 || x > n || y < 1 || y > m || vis[x][y]) continue;
            q.push ({a[x][y],{x,y}});
            vis[x][y] = true;
        }
    }
    cout << ans << endl;
}
```
- **核心思想**：将岛屿边缘的区画加入优先队列，每年处理海拔小于等于当前海平面的区画，并将其相邻区画加入队列。

---
处理用时：75.33秒
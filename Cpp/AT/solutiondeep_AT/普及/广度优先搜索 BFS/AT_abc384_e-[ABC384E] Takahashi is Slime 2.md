# 题目信息

# [ABC384E] Takahashi is Slime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_e

縦 $ H $ 行横 $ W $ 列のマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ H) $、左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ と呼ぶことにします。

はじめ、マス $ (i,j) $ には強さ $ S\ _\ {i,j} $ のスライムがおり、マス $ (P,Q) $ にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（$ 0 $ 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

- 高橋くんに隣接するスライムのうち、強さが高橋くんの強さの $ \dfrac1X $ 倍**未満**のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
 
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq500 $
- $ 1\leq\ P\leq\ H $
- $ 1\leq\ Q\leq\ W $
- $ 1\leq\ X\leq10^9 $
- $ 1\leq\ S_{i,j}\leq10^{12} $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。 
![](https://img.atcoder.jp/abc384/6b3d3bbde4767c7f5070ad0b1f202043.png) 例えば、高橋くんは次のように行動を行うことができます。 
![](https://img.atcoder.jp/abc384/81c0ccdba241277bf0cdd16ae6a7c54d.png) - マス $ (2,1) $ にいるスライムを吸収する。高橋くんの強さは $ 9+4=13 $ となり、新たにマス $ (1,1) $ のスライムとマス $ (3,1) $ のスライムが高橋くんと隣接する。 - マス $ (1,2) $ にいるスライムを吸収する。高橋くんの強さは $ 13+6=19 $ となり、新たにマス $ (1,3) $ のスライムが高橋くんと隣接する。 - マス $ (1,3) $ にいるスライムを吸収する。高橋くんの強さは $ 19+9=28 $ となる。 以上の行動を行ったあと、高橋くんの強さは $ 28 $ となります。 高橋くんがどのように行動を行っても、高橋くんの強さを $ 28 $ より大きくすることはできないため、`28` を出力してください。 高橋くんの強さの $ \dfrac12 $ 倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス $ (1,1) $ にいるスライムを吸収することはできません。

### Sample Explanation 2

高橋くんはどのスライムも吸収できません。

## 样例 #1

### 输入

```
3 3 2

2 2

14 6 9

4 9 20

17 15 7```

### 输出

```
28```

## 样例 #2

### 输入

```
3 4 1

1 1

5 10 1 1

10 1 1 1

1 1 1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
8 10 2

1 5

388 130 971 202 487 924 247 286 237 316

117 166 918 106 336 928 493 391 235 398

124 280 425 955 212 988 227 222 307 226

336 302 478 246 950 368 291 236 170 101

370 200 204 141 287 410 388 314 205 460

291 104 348 337 404 399 416 263 415 339

105 420 302 334 231 481 466 366 401 452

119 432 292 403 371 417 351 231 482 184```

### 输出

```
1343```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个 $H$ 行 $W$ 列的网格，每个格子 $(i,j)$ 中有一个强度为 $S_{i,j}$ 的史莱姆。高桥位于 $(P,Q)$ 位置。高桥可以进行以下操作任意次（包括零次）：

- 选择与高桥相邻的史莱姆，且该史莱姆的强度严格小于高桥当前强度的 $\dfrac{1}{X}$ 倍，将其吸收。吸收后，该史莱姆消失，高桥的强度增加该史莱姆的强度。

每次操作后，高桥会立即填补被吸收史莱姆的位置，且新位置与高桥相邻的史莱姆会与高桥相邻。

求高桥进行任意次操作后，可能达到的最大强度。

### 题解分析与结论

#### 题解思路对比

1. **贪心策略**：所有题解都采用了贪心策略，即优先吸收强度最小的史莱姆。这样可以最大化高桥的强度增长，并且确保不会错过后续可以吸收的史莱姆。
  
2. **数据结构**：大多数题解使用了优先队列（小根堆）来实现贪心策略，确保每次都能取出当前可吸收的最小强度史莱姆。

3. **时间复杂度**：使用优先队列的题解时间复杂度为 $\mathcal{O}(HW\log HW)$，相比直接 BFS 的 $\mathcal{O}(H^2W^2)$ 有显著优化。

4. **精度处理**：部分题解提到在处理 $S_{i,j} \times X$ 时可能会超出 `long long` 范围，因此使用了 `__int128` 或通过除法来避免溢出。

#### 最优关键思路

- **贪心 + 优先队列**：优先吸收强度最小的史莱姆，确保每次操作都能最大化高桥的强度增长。
- **边界处理**：通过优先队列的特性，当最小强度的史莱姆无法被吸收时，可以直接结束操作，避免不必要的计算。

#### 可拓展之处

- **类似问题**：该题的贪心策略可以应用于其他需要优先处理最小或最大元素的场景，如最短路径、最小生成树等。
- **优化技巧**：在处理大数乘法时，可以通过除法或使用更高精度的数据类型来避免溢出。

### 推荐题目

1. **P3371 【模板】单源最短路径（弱化版）** - 考察优先队列（Dijkstra算法）的应用。
2. **P3366 【模板】最小生成树** - 考察贪心策略在最小生成树中的应用。
3. **P4779 【模板】单源最短路径（标准版）** - 进一步考察优先队列在最短路径中的应用。

### 精选题解

#### 题解1：ikunTLE (5星)

**关键亮点**：
- 使用 `__int128` 处理大数乘法，避免溢出。
- 详细解释了贪心策略的正确性，并提供了清晰的代码实现。

**核心代码**：
```cpp
priority_queue<node,vector<node>,greater<node>>pq;
while(!pq.empty()){
    node u=pq.top();pq.pop();
    if(u.num*x>=power) return unsigned_write(power),0;
    power+=u.num;
    for(int i=1;i<=4;++i){
        int xx=u.x+dx[i],yy=u.y+dy[i];
        if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&!vis[xx][yy]){
            vis[xx][yy]=true;
            pq.push({xx,yy,s[xx][yy]});
        }
    }
}
```

#### 题解2：Moya_Rao (4星)

**关键亮点**：
- 通过除法避免大数乘法溢出，代码简洁易懂。
- 详细描述了调试过程中的问题及解决方案。

**核心代码**：
```cpp
priority_queue<node> q;
while(!q.empty()){
    node t=q.top();q.pop();
    if(s[t.x][t.y]<(now+p-1)/p&&!flag[t.x][t.y]){
        flag[t.x][t.y]=1;
        now+=s[t.x][t.y];
    }
    else continue;
    for(int i=0;i<4;i++){
        int x2=t.x+dx[i],y2=t.y+dy[i];
        if(x2<1||x2>n||y2<1||y2>m)continue;
        if(flag[x2][y2])continue;
        q.push({x2,y2});
    }
}
```

#### 题解3：Walrus (4星)

**关键亮点**：
- 详细解释了优先队列的使用原因，并提供了清晰的代码实现。
- 通过优先队列的特性优化了边界处理。

**核心代码**：
```cpp
priority_queue<node> q;
while(q.size()){
    int x,y; ll num;
    x=q.top().first; y=q.top().second; num=q.top().num;
    q.pop();
    __int128 k1=num,k2=X,k3=ans;
    if(!(x==sx&&y==sy)&&k1*k2>=k3) break;
    if(vis[x][y]) continue;
    ans+=num;
    vis[x][y]=1;
    for(int i=0;i<4;i++){
        int xx=x+dx[i],yy=y+dy[i];
        if(vis[xx][yy]) continue;
        if(check(xx,yy)) q.push({xx,yy,a[xx][yy]});
    }
}
```

### 总结

通过贪心策略和优先队列的结合，能够高效地解决该问题。在处理大数乘法时，使用 `__int128` 或通过除法来避免溢出是关键。该题的思路可以推广到其他需要优先处理最小或最大元素的场景。

---
处理用时：58.46秒
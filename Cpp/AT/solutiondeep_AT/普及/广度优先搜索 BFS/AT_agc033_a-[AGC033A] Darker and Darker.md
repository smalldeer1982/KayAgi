# 题目信息

# [AGC033A] Darker and Darker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc033/tasks/agc033_a

縦 $ H $ 行、横 $ W $ 列の白黒に塗られたマス目が与えられます。 マス目の状態は $ A_{11} $ から $ A_{HW} $ の $ HW $ 個の文字で表されており、 上から $ i $ 行目、左から $ j $ 列目にあるマスが黒色のとき $ A_{ij} $ は `#`、 上から $ i $ 行目、左から $ j $ 列目にあるマスが白色のとき $ A_{ij} $ は `.` となっています。

すべてのマスが黒色になるまで、以下の操作を繰り返し行います。

- 辺を共有して隣接するマスの中に、黒色のマスが一つ以上存在するような白色のマスすべてが黒色になる。

何回の操作を行うことになるか求めてください。 ただし、最初に与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在します。

## 说明/提示

### 制約

- $ 1\ ≦\ H,W\ ≦\ 1000 $
- $ A_{ij} $ は `#` または `.`
- 与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在する。

### Sample Explanation 1

操作を一回行うとマス目の四隅以外が黒色になり、もう一度操作を行うとすべてのマス目が黒色になります。

## 样例 #1

### 输入

```
3 3

...

.#.

...```

### 输出

```
2```

## 样例 #2

### 输入

```
6 6

..#..#

......

#..#..

......

.#....

....#.```

### 输出

```
3```

# AI分析结果

### 题目内容重写

【题目描述】
给定一个 $H$ 行 $W$ 列的黑白网格。网格的状态由 $A_{11}$ 到 $A_{HW}$ 的 $HW$ 个字符表示，其中 $A_{ij}$ 表示从上到下第 $i$ 行、从左到右第 $j$ 列的格子。如果格子是黑色，则 $A_{ij}$ 为 `#`；如果格子是白色，则 $A_{ij}$ 为 `.`。

每次操作会将所有与黑色格子相邻的白色格子变为黑色。求最少需要多少次操作才能使整个网格变为全黑。初始网格中至少有一个黑色格子。

【说明/提示】
- $1 \leq H, W \leq 1000$
- $A_{ij}$ 为 `#` 或 `.`
- 初始网格中至少有一个黑色格子。

### 题解综合分析与结论

本题的核心是通过广度优先搜索（BFS）模拟黑色格子的扩散过程。所有题解都采用了BFS的思路，但在实现细节上有所不同。主要难点在于如何高效地处理大规模的网格（$1000 \times 1000$），以及如何正确记录每个格子被染黑的时间。

### 所选高星题解

#### 1. 作者：Fijian_Bus (5星)
**关键亮点**：
- 使用BFS模板，代码结构清晰，易于理解。
- 通过 `vis` 数组记录每个格子是否被访问过，避免重复处理。
- 使用 `ans` 变量记录最大步数，直接输出结果。

**核心代码**：
```cpp
void BFS() {
    while(!q.empty()) {
        node pre = q.front();
        q.pop();
        ans = max(ans, pre.step);
        for(int i = 0; i < 4; i++) {
            int mx = dx[i] + pre.x;
            int my = dy[i] + pre.y;
            if(judge(mx, my) && mp[mx][my] == '.') {
                mp[mx][my] = '#';
                q.push(node{mx, my, pre.step + 1});
            }
        }
    }
}
```
**实现思想**：从所有初始黑色格子开始，逐层向外扩散，记录每个格子被染黑的步数，最终输出最大步数。

#### 2. 作者：fish_love_cat (4星)
**关键亮点**：
- 使用 `f` 数组记录每个格子是否为白色，避免直接修改原数组。
- 通过 `maxx` 变量记录最大步数，直接输出结果。

**核心代码**：
```cpp
int bfs() {
    int maxx = -1;
    while(!q.empty()) {
        wz v = q.front(); q.pop();
        maxx = max(maxx, v.ans);
        for(int i = 0; i < 4; i++) {
            wz xin;
            xin.x = v.x + gx[i];
            xin.y = v.y + gy[i];
            xin.ans = v.ans + 1;
            if(f[xin.x][xin.y]) {
                q.push(xin);
                f[xin.x][xin.y] = false;
            }
        }
    }
    return maxx;
}
```
**实现思想**：从所有初始黑色格子开始，逐层向外扩散，记录每个格子被染黑的步数，最终输出最大步数。

#### 3. 作者：Bpds1110 (4星)
**关键亮点**：
- 使用 `dis` 数组记录每个格子被染黑的步数，避免直接修改原数组。
- 通过 `ans` 变量记录最大步数，直接输出结果。

**核心代码**：
```cpp
while(!q.empty()) {
    int fx = q.front().x;
    int fy = q.front().y;
    ans = ans > dis[fx][fy] ? ans : dis[fx][fy];
    q.pop();
    for(int i = 0; i < 4; i++) {
        int sx = fx + e[i][0];
        int sy = fy + e[i][1];
        if(sx < 1 || sx > n || sy < 1 || sy > m) continue;
        if(vis[sx][sy]) continue;
        dis[sx][sy] = dis[fx][fy] + 1;
        vis[sx][sy] = 1;
        q.push({sx, sy});
    }
}
```
**实现思想**：从所有初始黑色格子开始，逐层向外扩散，记录每个格子被染黑的步数，最终输出最大步数。

### 最优关键思路或技巧
- **BFS逐层扩散**：从所有初始黑色格子开始，逐层向外扩散，记录每个格子被染黑的步数。
- **避免重复处理**：通过 `vis` 或 `f` 数组记录每个格子是否被访问过，避免重复处理。
- **记录最大步数**：通过 `ans` 或 `maxx` 变量记录最大步数，直接输出结果。

### 可拓展之处
- **多源BFS**：类似题目可以使用多源BFS，从多个起点同时开始扩散。
- **动态规划**：在某些情况下，可以使用动态规划来优化扩散过程。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1131 [ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131)

### 个人心得摘录
- **Fijian_Bus**：通过BFS模板，代码结构清晰，易于理解。
- **fish_love_cat**：使用 `f` 数组记录每个格子是否为白色，避免直接修改原数组。
- **Bpds1110**：使用 `dis` 数组记录每个格子被染黑的步数，避免直接修改原数组。

---
处理用时：48.07秒
# 题目信息

# 停止問題

## 题目描述

Defunge 程序由一个 $R$ 行 $C$ 列的字符数组组成。下面是一个 Defunge 程序的例子：

```plain
6>--v.
.^--_@
```

Defunge 程序从程序的左上角（即第一行第一列）开始执行。**它的执行方向一开始为"右"**，每次朝着执行方向走一步，**如果走出界了，要跳到另一边**。每走到一个格子上，就要执行这个格子上的命令。 Defunge 程序还有一个存储器，这个存储器只能存储 $[0,15]$ 的一个整数，**存储器一开始存储** $\bold{0}$。

在 Defunge 程序中，有且只有 $11+10=21$ 种命令，下面是它们各自的含义：

- `<`：把执行方向设置为"左"。
- `>`：把执行方向设置为"右"。
- `^`：把执行方向设置为"上"。
- `v`：把执行方向设置为"下"。
- `_`：如果存储器存储的数字是 $0$，就把执行方向设置为"右"，否则设置为"左"。
- `|`：如果存储器存储的数字是 $0$，就把执行方向设置为"下"，否则设置为"上"。
- `?`：把执行方向设置为"上下左右"中的**任意**一个（类似于 dfs 把四个方向全搜一遍）。
- `.`：什么也不做。
- `@`：停止程序。
- `0`-`9`：把存储器设置为这个字符表示的数值。
- `+`：让存储器的数值加 $1$。注意当存储器的数值为 $15$ 时要把它设为 $0$。
- `-`：让存储器的数值减 $1$。注意当存储器的数值为 $0$ 时要把它设为 $15$。

现在，给你一个 Defunge 程序，请判断这个程序是否能停止（即执行到命令`@`）。如果能，输出`YES`，否则输出`NO`。

## 说明/提示

$1\leq R,C\leq 20$，保证程序里只有上文提到的 $21$ 种命令。

# AI分析结果

### 题目内容重写

**停止问题**

#### 题目描述

Defunge 程序由一个 $R$ 行 $C$ 列的字符数组组成。下面是一个 Defunge 程序的例子：

```plain
6>--v.
.^--_@
```

Defunge 程序从程序的左上角（即第一行第一列）开始执行。**它的执行方向一开始为"右"**，每次朝着执行方向走一步，**如果走出界了，要跳到另一边**。每走到一个格子上，就要执行这个格子上的命令。 Defunge 程序还有一个存储器，这个存储器只能存储 $[0,15]$ 的一个整数，**存储器一开始存储** $\bold{0}$。

在 Defunge 程序中，有且只有 $11+10=21$ 种命令，下面是它们各自的含义：

- `<`：把执行方向设置为"左"。
- `>`：把执行方向设置为"右"。
- `^`：把执行方向设置为"上"。
- `v`：把执行方向设置为"下"。
- `_`：如果存储器存储的数字是 $0$，就把执行方向设置为"右"，否则设置为"左"。
- `|`：如果存储器存储的数字是 $0$，就把执行方向设置为"下"，否则设置为"上"。
- `?`：把执行方向设置为"上下左右"中的**任意**一个（类似于 dfs 把四个方向全搜一遍）。
- `.`：什么也不做。
- `@`：停止程序。
- `0`-`9`：把存储器设置为这个字符表示的数值。
- `+`：让存储器的数值加 $1$。注意当存储器的数值为 $15$ 时要把它设为 $0$。
- `-`：让存储器的数值减 $1$。注意当存储器的数值为 $0$ 时要把它设为 $15$。

现在，给你一个 Defunge 程序，请判断这个程序是否能停止（即执行到命令`@`）。如果能，输出`YES`，否则输出`NO`。

#### 说明/提示

$1\leq R,C\leq 20$，保证程序里只有上文提到的 $21$ 种命令。

---

### 题解分析与结论

#### 综合分析

本题的核心是通过模拟 Defunge 程序的执行过程，判断程序是否能够停止。由于程序可能会进入死循环，因此需要记录每个状态（位置、方向、存储器值）是否已经访问过，以避免重复搜索。大多数题解采用了深度优先搜索（DFS）结合状态标记的方法来解决这个问题。

#### 关键思路与技巧

1. **状态表示**：使用四维数组 `vis[x][y][dir][val]` 来记录是否访问过某个状态，其中 `x` 和 `y` 表示当前位置，`dir` 表示当前方向，`val` 表示存储器的值。
2. **边界处理**：当程序执行超出边界时，通过取模运算将其跳转到另一边。
3. **命令处理**：根据当前字符执行相应的操作，如改变方向、更新存储器值等。
4. **死循环检测**：如果某个状态已经被访问过，则说明程序进入了死循环，直接返回 `false`。
5. **停止条件**：当遇到 `@` 时，返回 `true`，表示程序可以停止。

#### 推荐题解

1. **作者：Jorisy (赞：7)**
   - **星级**：★★★★☆
   - **关键亮点**：代码结构清晰，使用 `switch` 语句处理命令，逻辑简洁明了。通过 `exit(0)` 直接结束程序，避免了不必要的回溯。
   - **个人心得**：作者提到在处理减 1 操作时，通过加 15 再取模 16 的方式避免了负数取模的问题。
   - **核心代码**：
     ```cpp
     void dfs(int x, int y, int s, int fx) {
         while(x<1) x+=r;
         while(r<x) x-=r;
         while(y<1) y+=c;
         while(c<y) y-=c;
         if(b[x][y][s][fx]) return;
         if(a[x][y]=='@') {
             cout<<"YES"<<endl;
             exit(0);
         }
         b[x][y][s][fx]=true;
         switch(a[x][y]) {
             case '>': dfs(x+X[4],y+Y[4],s,4); break;
             case '<': dfs(x+X[3],y+Y[3],s,3); break;
             case '^': dfs(x+X[1],y+Y[1],s,1); break;
             case 'v': dfs(x+X[2],y+Y[2],s,2); break;
             case '_': if(s) dfs(x+X[3],y+Y[3],s,3); else dfs(x+X[4],y+Y[4],s,4); break;
             case '|': if(s) dfs(x+X[1],y+Y[1],s,1); else dfs(x+X[2],y+Y[2],s,2); break;
             case '?': for(int i=1;i<=4;i++) dfs(x+X[i],y+Y[i],s,i); break;
             case '.': dfs(x+X[fx],y+Y[fx],s,fx); break;
             case '+': s++; if(s>15) s=0; dfs(x+X[fx],y+Y[fx],s,fx); break;
             case '-': s--; if(s<0) s=15; dfs(x+X[fx],y+Y[fx],s,fx); break;
             default: s=a[x][y]-48; dfs(x+X[fx],y+Y[fx],s,fx); break;
         }
     }
     ```

2. **作者：HYdroKomide (赞：4)**
   - **星级**：★★★★☆
   - **关键亮点**：代码简洁，逻辑清晰，通过 `exit(0)` 直接结束程序，避免了不必要的回溯。作者还提到在处理减 1 操作时，通过加 15 再取模 16 的方式避免了负数取模的问题。
   - **核心代码**：
     ```cpp
     bool run(int x, int y, int d, int num) {
         x=(x+n)%n, y=(y+m)%m;
         if(vis[x][y][d][num]) return 0;
         vis[x][y][d][num]=true;
         if(a[x][y]=='@') return 1;
         if(a[x][y]=='>') d=0;
         else if(a[x][y]=='<') d=1;
         else if(a[x][y]=='v') d=2;
         else if(a[x][y]=='^') d=3;
         else if(a[x][y]=='_') d=num?1:0;
         else if(a[x][y]=='|') d=num?3:2;
         else if(a[x][y]=='?') {
             for(int i=0;i<4;i++) if(run(x+dx[i],y+dy[i],i,num)) return 1;
             return 0;
         }
         else if(a[x][y]>='0'&&a[x][y]<='9') num=a[x][y]-'0';
         else if(a[x][y]=='-') num=(num+15)%16;
         else if(a[x][y]=='+') num=(num+1)%16;
         return run(x+dx[d],y+dy[d],d,num);
     }
     ```

3. **作者：Iron_Heart (赞：1)**
   - **星级**：★★★★☆
   - **关键亮点**：代码简洁，逻辑清晰，通过 `exit(0)` 直接结束程序，避免了不必要的回溯。作者还提到在处理减 1 操作时，通过加 15 再取模 16 的方式避免了负数取模的问题。
   - **核心代码**：
     ```cpp
     bool dfs(int x, int y, int d, int num) {
         x = (x - 1 + n) % n + 1;
         y = (y - 1 + m) % m + 1;
         if (vis[x][y][d][num]) return 0;
         vis[x][y][d][num] = 1;
         if (mp[x][y] == '@') return 1;
         else if (mp[x][y] == '<') d = 0;
         else if (mp[x][y] == '>') d = 3;
         else if (mp[x][y] == '^') d = 2;
         else if (mp[x][y] == 'v') d = 1;
         else if (mp[x][y] == '_') d = num ? 0 : 3;
         else if (mp[x][y] == '|') d = num ? 2 : 1;
         else if (mp[x][y] == '?') {
             for (int i = 0; i < 4; ++i) if (dfs(x + dx[i], y + dy[i], i, num)) return 1;
             return 0;
         }
         else if (mp[x][y] == '.') ;
         else if (isdigit(mp[x][y])) num = mp[x][y] - '0';
         else if (mp[x][y] == '+') num = (num + 1) % 16;
         else num = (num + 15) % 16;
         return dfs(x + dx[d], y + dy[d], d, num);
     }
     ```

#### 最优关键思路

1. **状态表示与标记**：使用四维数组记录每个状态是否访问过，避免重复搜索。
2. **边界处理**：通过取模运算处理超出边界的情况，确保程序能够正确跳转。
3. **命令处理**：使用 `switch` 或 `if-else` 结构处理不同的命令，逻辑清晰。
4. **停止条件**：遇到 `@` 时直接返回 `true`，表示程序可以停止。

#### 可拓展之处

类似的问题可以通过状态标记和搜索算法来解决，如迷宫问题、图论中的路径搜索等。掌握状态表示和边界处理技巧对于解决这类问题非常有帮助。

#### 推荐题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

---
处理用时：89.79秒
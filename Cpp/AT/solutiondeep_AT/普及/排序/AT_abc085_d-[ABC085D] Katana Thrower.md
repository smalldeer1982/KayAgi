# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果

### 题目中文重写
# [ABC085D] 掷刀者

## 题目描述
当你正在散步时，突然出现了一只怪物。幸运的是，你拥有 $N$ 把刀，分别是刀 $1$、刀 $2$、……、刀 $N$，并且可以按照任意顺序进行以下两种攻击：
- 挥舞你手中的一把刀。当你挥舞刀 $i$（$1 \leq i \leq N$）时，怪物会受到 $a_i$ 点伤害。同一把刀可以被挥舞任意次数。
- 投掷你手中的一把刀。当你将刀 $i$（$1 \leq i \leq N$）投掷向怪物时，怪物会受到 $b_i$ 点伤害，并且你会失去这把刀。也就是说，你之后无法再挥舞或投掷这把刀。

当怪物受到的总伤害达到 $H$ 点或更多时，它就会消失。请问，至少需要多少次攻击才能让怪物消失？

## 说明/提示
### 限制条件
- $1 \leq N \leq 10^5$
- $1 \leq H \leq 10^9$
- $1 \leq a_i \leq b_i \leq 10^9$
- 所有输入值均为整数。

### 样例解释 1
你有一把刀，挥舞它可以造成 $3$ 点伤害，投掷它可以造成 $5$ 点伤害。先挥舞这把刀 $2$ 次，再投掷它，总共造成 $3 + 3 + 5 = 11$ 点伤害，经过 $3$ 次攻击后怪物消失。

### 样例解释 2
除了之前的那把刀，你还有另一把刀，挥舞它可以造成 $2$ 点伤害，投掷它可以造成 $6$ 点伤害。将两把刀都投掷出去，总共造成 $5 + 6 = 11$ 点伤害，经过 $2$ 次攻击后怪物消失。

## 样例 #1
### 输入
```
1 10
3 5
```
### 输出
```
3
```

## 样例 #2
### 输入
```
2 10
3 5
2 6
```
### 输出
```
2
```

## 样例 #3
### 输入
```
4 1000000000
1 1
1 10000000
1 30000000
1 99999999
```
### 输出
```
860000004
```

## 样例 #4
### 输入
```
5 500
35 44
28 83
46 62
31 79
40 43
```
### 输出
```
9
```

### 综合分析与结论
这些题解的核心思路都是贪心算法，通过合理安排刀的使用顺序来使攻击次数最少。具体思路略有不同：
- ITZDC9、chengni、___new2zy___、Fat_Fish 的思路类似，将刀的劈砍和投掷伤害分开存储并排序，优先使用伤害高的投掷攻击，遇到劈砍伤害时用其将怪物砍死。
- Mysterious_Cat 先选出砍伤害最高的刀，将其余投掷伤害大于砍伤害的刀按投掷伤害排序并投掷，最后用砍伤害最高的刀砍死怪物。
- happybob 先计算只挥不扔的答案，再按飞的值从大到小排序模拟，不断更新最小攻击次数。
- Hilte 先对砍和扔的伤害排序，优先扔伤害大于砍的最大伤害的刀，最后用砍伤害最大的刀砍死怪物。

算法要点主要是排序和贪心选择，难点在于处理刀的使用规则（投掷后不能再使用）以及如何正确计算攻击次数。

### 评分较高的题解
- **ITZDC9（5星）**
    - **关键亮点**：思路清晰，详细分析了错误思路和正确思路，代码注释详细，可读性强。
    - **核心代码**：
```cpp
struct knife
{
    int m;
    bool t;
};

bool cmp(knife x, knife y)
{
    return x.m > y.m;
}

int main() 
{
    int n, h;
    cin >> n >> h;
    knife k[233333];
    int c = 0;
    for(int i = 1; i <= n; i++)
    {
        cin >> k[++c].m;
        cin >> k[++c].m;
        k[c].t = 1;
    }
    sort(k + 1, k + c + 1, cmp);
    int i = 1, ans = 0;
    while(h > 0)
    {
        if(k[i].t == 1)
        {
            h -= k[i].m;
            ans++;
        }
        else
        {
            if(h % k[i].m == 0)
                ans += h / k[i].m;
            else
                ans += h / k[i].m + 1;
            h = 0;
        }
        i++;
    }
    cout << ans;
    return 0;
}
```
- **chengni（4星）**
    - **关键亮点**：代码简洁，思路直接，直接按伤害从高到低排序，优先使用投掷伤害。
    - **核心代码**：
```cpp
struct p{
    int l;
    int r;
};

bool cmp(p xx, p yy){
    return xx.l > yy.l;
}

int main(){
    int n, h;
    int c = 0;
    scanf("%d%d", &n, &h);
    p a[1000000];
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &a[c++].l);
        a[c].r = 1;
        scanf("%d", &a[c++].l);
    }
    sort(a, a + c, cmp);
    int sum = 0;
    for(int i = 0; i < c; i++)
    {
        if(a[i].r == 1)
        {
            sum++;
            h -= a[i].l;
            if(h <= 0)
            {
                printf("%d", sum);
                return 0;
            }
        }
        else if(a[i].r!= 1)
        {
            if(h % a[i].l == 0) sum += h / a[i].l;
            else sum += h / a[i].l + 1;
            printf("%d", sum);
            return 0;
        }
    }
}
```
- **___new2zy___（4星）**
    - **关键亮点**：使用了快读优化输入，思路清晰，将每把刀看作两把刀存储，方便排序和贪心选择。
    - **核心代码**：
```cpp
struct knife
{
    int ai;
    bool f;
};

inline int read()
{
    int p = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9'){if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9'){p = p * 10 + c - '0'; c = getchar();}
    return f * p;
}

bool cmp(knife x, knife y)
{
    return x.ai > y.ai;
}

int main()
{
    int N, H;
    N = read(), H = read();
    knife m[2000018];
    for(int i = 1; i <= N; i++)
        m[i].ai = read(),
        m[i + N].ai = read(),
        m[i + N].f = true;
    sort(m + 1, m + 1 + N * 2, cmp);
    int ans = 0;
    for(int i = 1; i <= 2 * N; i++)
    {
        if(m[i].f)
        {
            ans++;
            H -= m[i].ai;
        }
        else
        {
            int u = H % m[i].ai;
            ans += H / m[i].ai;
            if(u) ans++;
            H = -1;
        }
        if(H <= 0)
        {
            printf("%d", ans);
            return 0;
        }
    }
}
```

### 最优关键思路或技巧
- 将刀的劈砍和投掷伤害分开存储并排序，方便贪心选择伤害最大的攻击方式。
- 优先使用投掷伤害，遇到劈砍伤害时直接计算需要的攻击次数，避免多次循环。

### 可拓展之处
同类型题可能会增加刀的使用限制或增加攻击方式，类似算法套路还是贪心算法，通过合理排序和选择来达到最优解。

### 洛谷相似题目推荐
- P1223 排队接水（P1223）
- P1090 合并果子（P1090）
- P2240 部分背包问题（P2240）

### 个人心得摘录与总结
- ___new2zy___：一开始没看出是贪心，乱搞了一个晚上，第二天才想到贪心思路。总结是做题时要先分析题目类型，遇到类似问题要往贪心等常见算法上思考。
- Mysterious_Cat：代码调了很久，感谢老师帮助完成。总结是调试代码时可以寻求他人帮助，提高效率。 

---
处理用时：55.24秒
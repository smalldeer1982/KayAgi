# 题目信息

# [ABC315E] Prerequisites

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc315/tasks/abc315_e

$ 1 $ から $ N $ までの番号がついた $ N $ 冊の本があります。  
 本 $ i $ には $ C_i $ 冊の前提となる本があり、そのうち $ j $ 冊目は本 $ P_{i,j} $ で、本 $ i $ を読む前にこの $ C_i $ 冊をすべて読む必要があります。  
 ただし、適切な順序を選ぶことですべての本を読むことができます。

あなたは本 $ 1 $ を読むために必要な最小の数の本を読もうとしています。  
 本 $ 1 $ 以外に読まなければならない本の番号を読むべき順に出力してください。ただし、この条件下で読むべき本の集合は一意に定まります。  
 条件を満たす読む順番が複数考えられる場合は、そのいずれを出力しても構いません。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ C_i\ <\ N $
- $ \sum_{i=1}^{N}\ C_i\ \leq\ 2\ \times\ 10^5 $
- $ C_1\ \geq\ 1 $
- $ 1\ \leq\ P_{i,j}\ \leq\ N $
- $ 1\ \leq\ j\ <\ k\ \leq\ C_i $ のとき $ P_{i,j}\ \neq\ P_{i,k} $
- すべての本を読むことが可能である
 
### Sample Explanation 1

本 $ 1 $ を読むために本 $ 2,3,4 $、本 $ 2 $ を読むために本 $ 3,5 $、本 $ 4 $ を読むために本 $ 5 $ を読む必要があります。本 $ 3,5,6 $ を読むために他の本を読む必要はありません。 このとき、例えば本 $ 5,3,4,2 $ の順に読むことで本 $ 1 $ を読むことができます。$ 3 $ 冊以下の本を読んだ状態で本 $ 1 $ が読めるようになることはないため、これは答えの一つです。他にも本 $ 3,5,4,2 $ の順などで読むことでも $ 4 $ 冊の本を読んだ状態で本 $ 1 $ を読むことができるようになります。

## 样例 #1

### 输入

```
6

3 2 3 4

2 3 5

0

1 5

0

0```

### 输出

```
5 3 4 2```

## 样例 #2

### 输入

```
6

1 2

1 3

1 4

1 5

1 6

0```

### 输出

```
6 5 4 3 2```

## 样例 #3

### 输入

```
8

1 5

1 6

1 7

1 8

0

0

0

0```

### 输出

```
5```

# AI分析结果

### 题目中文重写
有编号从 $1$ 到 $N$ 的 $N$ 本书。
书 $i$ 有 $C_i$ 本前提书，其中第 $j$ 本是书 $P_{i,j}$，在阅读书 $i$ 之前必须先读完这 $C_i$ 本书。
不过，通过选择合适的顺序可以读完所有的书。

你想阅读书 $1$，并希望阅读最少数量的书来达成这个目标。
请按阅读顺序输出除书 $1$ 之外必须阅读的书的编号。在这个条件下，需要阅读的书的集合是唯一确定的。
如果有多种满足条件的阅读顺序，输出其中任意一种即可。

### 综合分析与结论
这些题解主要围绕如何确定阅读书 $1$ 所需的最少前置书籍及阅读顺序展开，主要思路有拓扑排序和深度优先搜索（DFS）两种。
- **拓扑排序思路**：部分题解采用建反图后进行拓扑排序的方法，通过优先队列和标记变量确保输出的是与书 $1$ 相关的必需书籍。如 codejiahui 的题解，建反图后拓扑排序，用优先队列保证一号点之后都是必需的。
- **深度优先搜索思路**：多数题解使用 DFS，从书 $1$ 开始遍历，利用 DFS 深的点先遍历的性质，在遍历完子树后将节点加入答案序列，从而得到符合条件的阅读顺序。如 FreedomKing、Elairin176 等的题解。

### 所选题解
- **codejiahui（5星）**
    - **关键亮点**：思路清晰，详细阐述了建反图和拓扑排序的原因及过程，代码中增加标记变量和优先队列解决了确定必需书籍的问题。
    - **重点代码**：
```cpp
int in[200010],n,m;
int flag = 0,a[200010],nn = 0;
vector<int> adj[200010];
priority_queue<int> q; 
void topo()
{
    for (int i = 1;i <= n;i++)
        if (in[i] == 0)
            q.push(i);
    while(!q.empty())
    {
        int u = q.top();
        q.pop();
        if (flag) a[++nn] = u;
        if (u == 1) flag = 1;
        for (int v:adj[u])
        {
            in[v]--;
            if (in[v] == 0)
                q.push(v);
        }
    }
}
```
核心实现思想：先将入度为 $0$ 的点加入优先队列，在拓扑排序过程中，当遇到书 $1$ 时标记，之后将出队的点存入数组，最后反向输出数组元素。
- **FreedomKing（4星）**
    - **关键亮点**：思路简洁，直接用 DFS 解决问题，代码简短易懂。
    - **重点代码**：
```cpp
void dfs(int x){
    vis[x]=true;
    for(int i=0;i<e[x].size();i++)
        if(!vis[e[x][i]])
            dfs(e[x][i]);
    if(x>1) cout<<x<<' ';
}
```
核心实现思想：从书 $1$ 开始 DFS，标记已访问节点，遍历完子树后若不是书 $1$ 则输出节点编号。
- **c1ampy（4星）**
    - **关键亮点**：对问题进行了深入分析，不仅给出了拓扑排序和 DFS 结合的复杂思路，还简化得出直接用 DFS 可解决问题，代码规范。
    - **重点代码**：
```cpp
void dfs(const int cur) {
    visited[cur] = true;
    for (int i = head[cur]; i; i = edge[i].next) {
        int to = edge[i].to;
        if (visited[to]) {
            continue;
        }
        dfs(to);
    }
    if (cur!= 1) {
        printf("%d ", cur);
    }
}
```
核心实现思想：从书 $1$ 开始 DFS，标记已访问节点，遍历完子树后若不是书 $1$ 则输出节点编号。

### 最优关键思路或技巧
- **建反图**：在建图时采用反图，能更好地确定与目标节点（书 $1$）相关的必需节点，避免输出不必要的节点。
- **DFS 性质利用**：利用 DFS 深的点先遍历的性质，在遍历完子树后将节点加入答案序列，自然满足阅读顺序的要求。

### 可拓展之处
同类型题可能会增加一些限制条件，如书籍有阅读时间限制，要求在最短时间内读完书 $1$；或者书籍之间的依赖关系更复杂，存在多种依赖路径等。类似算法套路可应用于课程学习规划、项目任务安排等场景，根据任务之间的先后关系确定执行顺序。

### 洛谷推荐题目
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)：涉及任务的先后顺序和时间安排，可使用拓扑排序解决。
- [P3243 [HNOI2015]菜肴制作](https://www.luogu.com.cn/problem/P3243)：需要根据菜肴制作的先后关系，求出字典序最小的制作顺序，可结合拓扑排序和优先队列。
- [P2746 [USACO5.3]校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)：与图的连通性和拓扑结构相关，可通过拓扑排序和强连通分量等知识解决。

### 个人心得摘录与总结
- codejiahui：提出这是第一篇只用拓扑排序，不用深搜的题解，强调本题拓扑排序需增加标记变量和优先队列来解决确定必需书籍的问题。
- FreedomKing：称本题是超级水题，但有人赛时想挂，体现出对题目难度的看法和对他人表现的调侃。
- Crazyouth：认为 ABC315 的 E 题是拓扑排序板子题，作为橙题不太合理，表达了对题目难度评级的质疑。 

---
处理用时：43.77秒
# 题目信息

# [ABC007C] 幅優先探索

## 题目描述

一个大小为 $n\times m$ 的迷宫，你可以往上下左右任意方向移动 $1$ 步，求最少需要多少步才能走出迷宫。

迷宫中 `.` 表示空地，`#` 表示墙壁，移动中只能穿过空地，不能穿墙。

## 说明/提示

对于 $100\%$ 的数据，$1\le n, m\le50$，$sy, gy\le n$，$sx,gx\le m$。

## 样例 #1

### 输入

```
7 8

2 2

4 5

########

#......#

#.######

#..#...#

#..##..#

##.....#

########```

### 输出

```
11```

## 样例 #2

### 输入

```
5 8

2 2

2 4

########

#.#....#

#.###..#

#......#

########```

### 输出

```
10```

## 样例 #3

### 输入

```
50 50

2 2

49 49

##################################################

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

##################################################```

### 输出

```
94```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

给定一个大小为 $n \times m$ 的迷宫，你可以向上下左右任意方向移动 $1$ 步，求最少需要多少步才能走出迷宫。

迷宫中 `.` 表示空地，`#` 表示墙壁，移动中只能穿过空地，不能穿墙。

#### 输入格式

第一行输入两个整数 $n$ 和 $m$，表示迷宫的行数和列数。

第二行输入两个整数 $sy$ 和 $sx$，表示起点的坐标。

第三行输入两个整数 $gy$ 和 $gx$，表示终点的坐标。

接下来 $n$ 行，每行输入一个长度为 $m$ 的字符串，表示迷宫的地图。

#### 输出格式

输出一个整数，表示从起点到终点的最少步数。

#### 样例

**样例 1**

输入：
```
7 8
2 2
4 5
########
#......#
#.######
#..#...#
#..##..#
##.....#
########
```
输出：
```
11
```

**样例 2**

输入：
```
5 8
2 2
2 4
########
#.#....#
#.###..#
#......#
########
```
输出：
```
10
```

**样例 3**

输入：
```
50 50
2 2
49 49
##################################################
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
##################################################
```
输出：
```
94
```

#### 数据范围

对于 $100\%$ 的数据，$1 \leq n, m \leq 50$，$sy, gy \leq n$，$sx, gx \leq m$。

---

### 题解综合分析

本题是一个典型的广度优先搜索（BFS）问题，要求从起点到终点的最短路径。BFS 是解决这类问题的最佳选择，因为它能够逐层扩展搜索，确保第一次到达终点时就是最短路径。

#### 题解对比与评分

1. **BurningEnderDragon (★★★★★)**
   - **亮点**：详细解释了 BFS 的原理，并提供了手写队列的实现，代码清晰且优化了 STL 队列的常数问题。
   - **代码实现**：使用手写队列进行 BFS，避免了 STL 队列的常数问题，代码结构清晰。
   - **个人心得**：提醒了输入时可能遇到的换行符问题，避免了一些常见的错误。

2. **哈哈哈哈。 (★★★★)**
   - **亮点**：使用了方向数组简化了代码，结构体存储坐标和步数，代码简洁易懂。
   - **代码实现**：使用 STL 队列进行 BFS，代码简洁，适合初学者理解。
   - **个人心得**：强调了标记已访问节点的重要性，避免了重复搜索。

3. **Kogenta (★★★★)**
   - **亮点**：详细解释了 BFS 的搜索过程，并提供了完整的代码实现，适合初学者理解。
   - **代码实现**：使用 STL 队列进行 BFS，代码结构清晰，注释详细。
   - **个人心得**：强调了 BFS 的层次性，确保第一次到达终点时就是最短路径。

#### 最优关键思路与技巧

1. **BFS 逐层扩展**：BFS 通过逐层扩展搜索，确保第一次到达终点时就是最短路径。
2. **手写队列优化**：手写队列可以避免 STL 队列的常数问题，提升代码效率。
3. **方向数组简化代码**：使用方向数组可以简化代码，减少重复代码的编写。

#### 可拓展之处

1. **双向 BFS**：对于较大的迷宫，可以考虑使用双向 BFS，从起点和终点同时进行搜索，减少搜索范围。
2. **A* 算法**：对于更复杂的迷宫，可以考虑使用 A* 算法，结合启发式搜索进一步优化。

#### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
3. [P1747 逃离迷宫](https://www.luogu.com.cn/problem/P1747)

#### 个人心得总结

- **调试经历**：在输入时要注意换行符的处理，避免读取错误。
- **踩坑教训**：未标记已访问节点会导致重复搜索，增加时间复杂度。
- **顿悟感想**：BFS 的逐层扩展特性确保了最短路径的求解，理解这一点后代码实现更加清晰。

---

### 精选题解代码片段

#### BurningEnderDragon 的手写队列 BFS 实现

```cpp
int Head=0,Tail=0; //队列的头指针和尾指针
struct point
{
    int Y,X,Step;//Y和X为坐标，Step为到达该点需要的步数 
}Queue[1000];//空间可以稍微开大一些
inline void Push(int y,int x,int step)//入队操作 
{
    Queue[Tail].Y=y;//元素从队尾进入 
    Queue[Tail].X=x;
    Queue[Tail].Step=step;
    ++Tail;//尾指针+1 
    if(Tail==1000)
    {
        Tail=0;//实现队列空间的重复利用：如果尾指针超过了队列的范围，则重新变为0。可以利用这个方法将链状的队列变为环状的队列 
    }
    return ;
}
inline void Pop()//出队操作 
{
    ++Head;//头指针+1（因为如果队列的同一个位置被重复使用，后面入队的元素可以直接覆盖原有的元素，所以可以不必初始化该位置） 
    if(Head==1000)
    {
        Head=0;//同上 
    }
    return ;
}
inline bool Empty()//判断队列是否为空 
{
    return Head==Tail?1:0;//如果头指针=尾指针，说明队列为空 
}
```

#### 哈哈哈哈。的方向数组 BFS 实现

```cpp
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//每个括号中对应一种移动状态;
struct ss{
    int x,y,ans;//对应X坐标，Y坐标，以及移动步数;
};
queue<ss> q;//队列方便后面搜索使用;
int bfs(int x,int y,int ans)
{
    ss s;//记录初始坐标
    s.x=x;
    s.y=y;
    s.ans=ans;
    q.push(s);//存入队列;
    while(!q.empty())
    {
        ss now=q.front();//取出队首;
        q.pop();//弹出队首;
        if(now.x==ex&&now.y==ey)
        {
            return now.ans;//满足条件就可以返回;
        }
        for(int i=0;i<4;i++)//处理方向;
        {
            int tx=now.x+dir[i][0];
            int ty=now.y+dir[i][1];
            int tans=now.ans+1;//步数+1;
            if(tx>=1&&ty>=1&&tx<=n&&ty<=m&&vis[tx][ty]==true)//无障碍以及不越界的情况;
            {
                ss s;//保存新状态;
                s.x=tx;
                s.y=ty;
                s.ans=tans;
                vis[tx][ty]=false;//一定要标记，不然就会炸掉，鬼知道我电脑死机了几次;
                q.push(s);
            }
        }
    }
}
```

---
处理用时：62.92秒
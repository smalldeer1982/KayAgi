# 题目信息

# [ABC029D] 1

## 题目描述

高桥先生用十进制标记一次性地在纸上写了  $1$ ~ $N$  以下的所有整数。 在这项工作中，高桥君写了几个  $1$  这样的数字呢？即求从 
 $1$ ~ $N$  中数字  $1$  出现的次数。（本题类似 P1980）

## 样例 #1

### 输入

```
12```

### 输出

```
5```

## 样例 #2

### 输入

```
345```

### 输出

```
175```

## 样例 #3

### 输入

```
999999999```

### 输出

```
900000000```

# AI分析结果

### 题目内容重写

高桥先生用十进制标记一次性地在纸上写了 $1$ ~ $N$ 以下的所有整数。在这项工作中，高桥君写了几个 $1$ 这样的数字呢？即求从 $1$ ~ $N$ 中数字 $1$ 出现的次数。（本题类似 P1980）

### 样例 #1

#### 输入

```
12
```

#### 输出

```
5
```

### 样例 #2

#### 输入

```
345
```

#### 输出

```
175
```

### 样例 #3

#### 输入

```
999999999
```

#### 输出

```
900000000
```

---

### 题解综合分析

本题要求计算从 $1$ 到 $N$ 中数字 $1$ 出现的次数。题解中主要采用了以下几种方法：

1. **数位DP**：通过递归搜索数位，结合记忆化优化，时间复杂度为 $O(\log_{10}N)$。
2. **分段打表**：通过预处理部分结果，减少计算量，适用于大数据范围。
3. **数学推导**：通过数学公式直接计算每位上 $1$ 的出现次数，时间复杂度为 $O(\log_{10}N)$。

### 精选题解

#### 题解1：作者：lzqy_ (赞：43)

**星级：★★★★★**

**关键亮点**：
- 通过数学推导，逐位计算 $1$ 的出现次数，时间复杂度为 $O(1)$。
- 代码简洁，逻辑清晰，适合初学者理解。

**核心代码**：
```cpp
int main() {
  int n, ans = 0;
  cin >> n;
  if (n >= 1) {
    ans += (n / 10 + 1) * 1;
    if (n % 10 < 2 - 1) ans -= min(1, 2 - n % 10 - 1);
  }
  if (n >= 10) {
    ans += (n / 100 + 1) * 10;
    if (n % 100 < 20 - 1) ans -= min(10, 20 - n % 100 - 1);
  }
  // 类似处理更高位
  cout << ans << endl;
  return 0;
}
```

#### 题解2：作者：A_Pikachu (赞：2)

**星级：★★★★☆**

**关键亮点**：
- 通过数学公式推导，逐位计算 $1$ 的出现次数，时间复杂度为 $O(\log_{10}N)$。
- 代码结构清晰，适合有一定数学基础的同学。

**核心代码**：
```cpp
inline int solve(int x, int n) {
  if (x == 0) return n * pow[n - 1];
  return n * pow[n - 1] * (x + 1) + pow[n];
}
int main() {
  scanf("%s", ch);
  len = strlen(ch);
  for (int i = 0; i < len - 1; i++) {
    if (ch[i] == '0') continue;
    ans += solve(ch[i] - '0' - 1, len - i - 1);
    if (ch[i] == '1') {
      sscanf(ch + i + 1, "%d", &q);
      ans += q + 1;
    }
  }
  if (ch[len - 1] > '0') ans++;
  printf("%d\n", ans);
  return 0;
}
```

#### 题解3：作者：Meatherm (赞：0)

**星级：★★★★☆**

**关键亮点**：
- 使用数位DP，结合记忆化搜索，时间复杂度为 $O(\log_{10}N)$。
- 代码结构清晰，适合对数位DP有一定基础的同学。

**核心代码**：
```cpp
int dfs(int i, int sum, bool high, bool zero) {
  if (!i) return sum;
  if (~f[i][sum][high][zero]) return f[i][sum][high][zero];
  int res = 0;
  for (int j = 0; j < 10; j++) {
    if (high && j > a[i]) break;
    res += dfs(i - 1, sum + (j == 1), high && j == a[i], zero && !j);
  }
  return f[i][sum][high][zero] = res;
}
```

### 最优关键思路与技巧

1. **逐位计算**：通过逐位计算 $1$ 的出现次数，结合数学公式，可以高效地解决问题。
2. **数位DP**：通过递归搜索数位，结合记忆化优化，适用于复杂的数位问题。
3. **分段打表**：通过预处理部分结果，减少计算量，适用于大数据范围。

### 可拓展之处

- 类似问题可以扩展到其他数字的出现次数，如 $2$、$3$ 等。
- 数位DP可以应用于其他数位相关的问题，如数字之和、特定数字的出现次数等。

### 推荐题目

1. [P1980 计数问题](https://www.luogu.com.cn/problem/P1980)
2. [P2602 数字计数](https://www.luogu.com.cn/problem/P2602)
3. [P4999 数字统计](https://www.luogu.com.cn/problem/P4999)

### 个人心得摘录

- **调试经历**：在逐位计算时，需要注意边界条件的处理，如 $n$ 的个位为 $0$ 时的情况。
- **顿悟感想**：通过数学公式推导，可以大大简化问题的复杂度，减少代码量。

---
处理用时：49.28秒
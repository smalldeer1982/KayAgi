# 题目信息

# [ABC114C] 755

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc114/tasks/abc114_c

整数 $ N $ が与えられます。$ 1 $ 以上 $ N $ 以下の整数のうち、*七五三数* は何個あるでしょうか？

ここで、七五三数とは以下の条件を満たす正の整数です。

- 十進法で表記したとき、数字 `7`, `5`, `3` がそれぞれ $ 1 $ 回以上現れ、これら以外の数字は現れない。

## 说明/提示

### 制約

- $ 1\ \leq\ N $
- $ N $ は整数である。

### Sample Explanation 1

$ 575 $ 以下の七五三数は、$ 357,\ 375,\ 537,\ 573 $ の $ 4 $ 個です。

### Sample Explanation 2

$ 3600 $ 以下の七五三数は、上記の $ 4 $ 個と $ 735,\ 753,\ 3357,\ 3375,\ 3537,\ 3557,\ 3573,\ 3575,\ 3577 $ の計 $ 13 $ 個です。

## 样例 #1

### 输入

```
575```

### 输出

```
4```

## 样例 #2

### 输入

```
3600```

### 输出

```
13```

## 样例 #3

### 输入

```
999999999```

### 输出

```
26484```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个整数 $N$，求 $1$ 以上 $N$ 以下的整数中，有多少个是“七五三数”。

七五三数是指满足以下条件的正整数：
- 十进制表示时，数字 `7`、`5`、`3` 分别至少出现一次，且不包含其他数字。

【说明/提示】
### 制约
- $1 \leq N$
- $N$ 是整数。

### 样例解释
**样例1**  
输入：  
```
575
```
输出：  
```
4
```
解释：  
$575$ 以下的七五三数有 $357, 375, 537, 573$ 共 $4$ 个。

**样例2**  
输入：  
```
3600
```
输出：  
```
13
```
解释：  
$3600$ 以下的七五三数有 $357, 375, 537, 573, 735, 753, 3357, 3375, 3537, 3557, 3573, 3575, 3577$ 共 $13$ 个。

### 题解分析与结论

#### 综合分析
本题的核心是生成所有由 `3`、`5`、`7` 组成的数字，并判断这些数字是否满足 `3`、`5`、`7` 各至少出现一次。由于直接枚举所有可能的数字会超时，因此需要采用更高效的算法。常见的解法包括 BFS、DFS 和数位 DP。

#### 最优思路
1. **DFS 递归生成数字**：通过递归生成所有由 `3`、`5`、`7` 组成的数字，并在生成过程中记录 `3`、`5`、`7` 是否出现过。这种方法简洁高效，适合本题的数据范围。
2. **位运算优化**：使用位运算来记录 `3`、`5`、`7` 是否出现过，可以显著减少判断的时间复杂度。

#### 推荐题解
1. **作者：XWCL_OI**  
   **星级：5**  
   **关键亮点**：使用 DFS 递归生成数字，并通过位运算记录 `3`、`5`、`7` 是否出现过，代码简洁高效。  
   **核心代码**：
   ```cpp
   void dfs(long long x, int a, int b, int c) {
       if (x > n) return;
       ans += a && b && c;
       dfs(x * 10 + 3, a + 1, b, c);
       dfs(x * 10 + 5, a, b + 1, c);
       dfs(x * 10 + 7, a, b, c + 1);
   }
   ```

2. **作者：liangbowen**  
   **星级：4.5**  
   **关键亮点**：使用 DFS 递归生成数字，并通过布尔变量记录 `3`、`5`、`7` 是否出现过，代码清晰易懂。  
   **核心代码**：
   ```cpp
   void dfs(long long x, bool use3, bool use5, bool use7) {
       if (x > n) return;
       if (x <= n && use3 && use5 && use7) cnt++;
       dfs(x * 10 + 3, true, use5, use7);
       dfs(x * 10 + 5, use3, true, use7);
       dfs(x * 10 + 7, use3, use5, true);
   }
   ```

3. **作者：yaolibo**  
   **星级：4**  
   **关键亮点**：使用 DFS 递归生成数字，并通过位运算记录 `3`、`5`、`7` 是否出现过，代码简洁高效。  
   **核心代码**：
   ```cpp
   void dfs(long long x, int cnt) {
       if (x > n) return;
       if (cnt == 7) ans++;
       dfs(x * 10 + 3, cnt | 4);
       dfs(x * 10 + 5, cnt | 2);
       dfs(x * 10 + 7, cnt | 1);
   }
   ```

#### 扩展思路
- **数位 DP**：对于更大的数据范围，可以使用数位 DP 来优化时间复杂度。
- **矩阵快速幂**：对于极端大的数据范围，可以考虑使用矩阵快速幂来加速计算。

#### 推荐题目
1. [P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657)
2. [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)
3. [P4124 [CQOI2016] 手机号码](https://www.luogu.com.cn/problem/P4124)

#### 个人心得
- **调试经历**：在递归生成数字时，需要注意数字的范围，避免溢出。
- **顿悟感想**：使用位运算记录状态可以显著减少判断的时间复杂度，提高代码效率。

---
处理用时：40.77秒
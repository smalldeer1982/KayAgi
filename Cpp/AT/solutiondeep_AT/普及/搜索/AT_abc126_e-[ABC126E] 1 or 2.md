# 题目信息

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5```

### 输出

```
2```

## 样例 #3

### 输入

```
100000 1

1 100000 100```

### 输出

```
99999```

# AI分析结果

### 题目内容重写

$ N $ 张卡片被排成一列，每张卡片上写有整数 $ 1 $ 或 $ 2 $。

第 $ i $ 张卡片上的整数记为 $ A_i $。

你的目标是确定 $ A_1,\ A_2,\ ...,\ A_N $ 的值。

已知以下信息：

- 对于 $ i\ =\ 1,\ 2,\ ...,\ M $，$ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ 是偶数。

你可以使用以下魔法任意次数：

**魔法**：支付 $ 1 $ 点成本，选择一张卡片并知道其上的整数 $ A_i $。

问：最少需要支付多少成本，才能确定所有卡片上的整数？

### 题解分析与结论

所有题解均采用了并查集（Union-Find）数据结构来解决该问题，思路基本一致。通过将卡片之间的关系视为连通性，最终统计连通块的数量即为需要支付的魔法次数。以下是各题解的评分与亮点：

---

### 精选题解

#### 1. 作者：徐晨轩✅ (5星)
**关键亮点**：
- 思路清晰，直接指出并查集的应用场景。
- 代码简洁，路径压缩优化到位。
- 无需处理 $ Z_i $，直接通过并查集维护关系。

**核心代码**：
```cpp
int find(int x) {
    if(f[x]!=x) f[x]=find(f[x]);
    return f[x];
}
void merge(int x, int y) {
    int fx=find(x);
    int fy=find(y);
    f[fx]=fy;
}
```
**个人心得**：
- 并查集的路径压缩优化是关键，确保查询效率。

---

#### 2. 作者：Take_A_Single_6 (4星)
**关键亮点**：
- 详细解释了奇偶关系的推导过程，帮助理解问题本质。
- 代码实现规范，注释清晰。

**核心代码**：
```cpp
int bcj(int f) {
    if(q[f]==f) return f;
    return q[f]=bcj(q[f]);
}
```
**个人心得**：
- 强调并查集的路径压缩，避免重复计算。

---

#### 3. 作者：龙潜月十五 (4星)
**关键亮点**：
- 通过样例详细分析问题，帮助理解并查集的应用。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int find(int x) {
    if(x==fa[x]) return x;
    return fa[x]=find(fa[x]);
}
void con(int x, int y) {
    x=find(x), y=find(y);
    if(x!=y) fa[x]=y;
}
```
**个人心得**：
- 并查集的思维转换是解题的关键，需深入理解其应用场景。

---

### 最优关键思路与技巧

1. **并查集的应用**：将卡片之间的关系视为连通性，通过并查集维护这些关系，最终统计连通块的数量。
2. **路径压缩优化**：在并查集的 `find` 操作中，通过路径压缩减少查询时间，确保算法效率。
3. **忽略 $ Z_i $**：由于 $ Z_i $ 对卡片之间的关系没有影响，直接通过并查集合并卡片即可。

---

### 可拓展之处

- **类似问题**：适用于需要维护元素关系并统计连通块数量的场景，如最小生成树、图的连通性等。
- **算法套路**：并查集常用于处理动态连通性问题，路径压缩和按秩合并是常见的优化手段。

---

### 推荐题目

1. **P3367 【模板】并查集**：并查集的基础模板题，适合初学者练习。
2. **P1551 亲戚**：利用并查集处理亲属关系问题。
3. **P1197 [JSOI2008]星球大战**：并查集在动态图连通性中的应用。

---

### 总结

并查集是解决该问题的核心数据结构，路径压缩优化是确保效率的关键。通过统计连通块的数量，可以快速确定需要支付的魔法次数。掌握并查集的应用场景和优化技巧，能够有效解决类似问题。

---
处理用时：34.38秒
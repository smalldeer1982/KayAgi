# 题目信息

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>```

### 输出

```
15```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

#### [ABC317E] 避免眼神接触

**题目描述**

有一个被分割成 $H$ 行 $W$ 列的网格状场地。  
从北（上侧）数第 $i$ 行、从西（左侧）数第 $j$ 列的格子用字符 $A_{i,\ j}$ 表示。每个字符的含义如下：

- `.` : 空格子。可以进入。
- `#` : 障碍物。不能进入。
- `>`, `v`, `<`, `^` : 分别表示朝东、南、西、北的人所在的格子。不能进入。人的视线宽度为 $1$ 格，沿着人面对的方向直线延伸，直到被障碍物或其他人阻挡。
- `S` : 起点。可以进入。保证只有一个起点，且不在任何人的视线范围内。
- `G` : 终点。可以进入。保证只有一个终点，且不在任何人的视线范围内。

Naohiro 位于起点，可以向东、西、南、北四个方向移动任意次数。但是，他不能进入不能通过的格子或离开场地。  
请判断他是否可以在不进入任何人的视线范围内到达终点，如果可以，输出所需的最小移动次数；否则输出 `-1`。

**说明/提示**

**约束条件**

- $2\ \leq\ H,\ W\ \leq\ 2000$
- $A_{i,j}$ 是 `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` 中的一种
- `S`, `G` 在 $A_{i,\ j}$ 中恰好出现一次
- 起点和终点都不在任何人的视线范围内

**样例解释**

样例 1 中，某些格子被标记为 `!` 表示被视线覆盖。例如，格子 $(2, 4)$ 被东向的人看到，格子 $(2, 6)$ 被东向和南向的人看到，而格子 $(4, 5)$ 没有被任何人看到。

样例 2 中，Naohiro 无法到达终点，输出 `-1`。

### 题解分析与结论

#### 题解思路对比

1. **预处理视线范围**：所有题解都提到了预处理视线范围，将视线覆盖的格子标记为不可通过。处理方式包括直接遍历或动态规划。
2. **广度优先搜索（BFS）**：所有题解都使用 BFS 来寻找从起点到终点的最短路径，避免进入视线范围。
3. **时间复杂度**：大部分题解的时间复杂度为 $O(HW)$，符合题目要求。

#### 最优思路与技巧

- **预处理视线范围**：通过遍历每个方向的人，标记其视线范围内的格子为不可通过。可以使用动态规划或直接遍历。
- **BFS 优化**：在 BFS 过程中，避免重复访问已标记的格子，确保时间复杂度为 $O(HW)$。

#### 可拓展之处

- **类似问题**：类似的问题包括在网格中寻找最短路径，同时避开某些特定区域（如视线范围、陷阱等）。
- **算法套路**：预处理 + BFS 是解决网格最短路径问题的常见套路，适用于多种变体。

#### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1131 [ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131)

### 精选题解

#### 题解1：作者：ran_qwq (赞：12)

**星级**：★★★★★

**关键亮点**：
- 简洁明了的思路，直接标记视线范围后使用 BFS。
- 代码清晰，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= h; i++) {
    for (int j = 1; j <= w; j++) {
        if (s[i][j] == '>') {
            int y = j + 1;
            while (s[i][y] == '.' && y <= w) use[i][y++] = true;
        }
        // 类似处理其他方向
    }
}
// BFS 部分
queue<pii> q;
q.push({a, b});
while (!q.empty()) {
    pii tmp = q.front();
    q.pop();
    for (int i = 0; i < 4; i++) {
        int xx = tmp.first + dx[i];
        int yy = tmp.second + dy[i];
        if (xx > 0 && xx <= h && yy > 0 && yy <= w && !use[xx][yy] && s[xx][yy] != '#') {
            q.push({xx, yy});
            ans[xx][yy] = ans[tmp.first][tmp.second] + 1;
        }
    }
}
```

#### 题解2：作者：FinderHT (赞：2)

**星级**：★★★★

**关键亮点**：
- 详细解释了预处理和 BFS 的实现细节。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
for (int i = 1; i <= h; i++) {
    for (int j = 1; j <= w; j++) {
        if (s[i][j] == '>') {
            int y = j + 1;
            while (s[i][y] == '.' && y <= w) use[i][y++] = true;
        }
        // 类似处理其他方向
    }
}
// BFS 部分
queue<pii> q;
q.push({a, b});
while (!q.empty()) {
    pii tmp = q.front();
    q.pop();
    for (int i = 0; i < 4; i++) {
        int xx = tmp.first + dx[i];
        int yy = tmp.second + dy[i];
        if (xx > 0 && xx <= h && yy > 0 && yy <= w && !use[xx][yy] && s[xx][yy] != '#') {
            q.push({xx, yy});
            ans[xx][yy] = ans[tmp.first][tmp.second] + 1;
        }
    }
}
```

#### 题解3：作者：Dream_poetry (赞：1)

**星级**：★★★★

**关键亮点**：
- 代码简洁，预处理和 BFS 实现清晰。
- 使用了 `!` 标记视线范围，便于理解。

**核心代码**：
```cpp
for (int i = 1; i <= h; i++) {
    for (int j = 1; j <= w; j++) {
        if (ch[i][j] == '^') {
            int ii = i - 1, jj = j;
            while (ch[ii][jj] == '.' && ii >= 1) ch[ii--][jj] = '!';
        }
        // 类似处理其他方向
    }
}
// BFS 部分
queue<pair<int, int>> q;
q.push({sx, sy});
while (!q.empty()) {
    int x = q.front().first;
    int y = q.front().second;
    q.pop();
    for (int i = 0; i < 4; i++) {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if (xx >= 1 && xx <= h && yy >= 1 && yy <= w && !fff[xx][yy] && ch[xx][yy] != '!') {
            q.push({xx, yy});
            fff[xx][yy] = fff[x][y] + 1;
        }
    }
}
```

### 总结

预处理视线范围后使用 BFS 是解决该问题的标准方法。代码实现中，标记视线范围和 BFS 的实现是关键，确保时间复杂度为 $O(HW)$。

---
处理用时：67.35秒
# 题目信息

# [ABC318D] General Weighted Max Matching

## 题目描述

**题意简述**

有一个无向图，$i$ 到 $j$ 的距离为 $D_{i,j}$。你可以选择一些边，使得这些边连接的所有顶点互不相同。求这些边总长度的最大值。

## 说明/提示

- $2 \le N \le 16$
- $1 \le D_{i,j} \le 10^9$

**样例一解释**

选择 $D_{1,3},D_{2,4}$，总和为$5+8=13$。

## 样例 #1

### 输入

```
4

1 5 4

7 8

6```

### 输出

```
13```

## 样例 #2

### 输入

```
3

1 2

3```

### 输出

```
3```

## 样例 #3

### 输入

```
16

5 6 5 2 1 7 9 7 2 5 5 2 4 7 6

8 7 7 9 8 1 9 6 10 8 8 6 10 3

10 5 8 1 10 7 8 4 8 6 5 1 10

7 4 1 4 5 4 5 10 1 5 1 2

2 9 9 7 6 2 2 8 3 5 2

9 10 3 1 1 2 10 7 7 5

10 6 1 8 9 3 2 4 2

10 10 8 9 2 10 7 9

5 8 8 7 5 8 2

4 2 2 6 8 3

2 7 3 10 3

5 7 10 3

8 5 7

9 1

4```

### 输出

```
75```

# AI分析结果

### 题目内容重写

**题目描述**

有一个无向图，$i$ 到 $j$ 的距离为 $D_{i,j}$。你可以选择一些边，使得这些边连接的所有顶点互不相同。求这些边总长度的最大值。

**说明/提示**

- $2 \le N \le 16$
- $1 \le D_{i,j} \le 10^9$

**样例一解释**

选择 $D_{1,3},D_{2,4}$，总和为$5+8=13$。

**样例 #1**

### 输入

```
4

1 5 4

7 8

6```

### 输出

```
13```

**样例 #2**

### 输入

```
3

1 2

3```

### 输出

```
3```

**样例 #3**

### 输入

```
16

5 6 5 2 1 7 9 7 2 5 5 2 4 7 6

8 7 7 9 8 1 9 6 10 8 8 6 10 3

10 5 8 1 10 7 8 4 8 6 5 1 10

7 4 1 4 5 4 5 10 1 5 1 2

2 9 9 7 6 2 2 8 3 5 2

9 10 3 1 1 2 10 7 7 5

10 6 1 8 9 3 2 4 2

10 10 8 9 2 10 7 9

5 8 8 7 5 8 2

4 2 2 6 8 3

2 7 3 10 3

5 7 10 3

8 5 7

9 1

4```

### 输出

```
75```

### 题解综合分析与结论

本题的核心在于如何高效地选择边，使得所选边的顶点互不相同，并且边权之和最大。由于 $N$ 的范围较小（$2 \le N \le 16$），可以考虑使用**状态压缩动态规划（状压DP）**或**深度优先搜索（DFS）**来解决。

#### 最优关键思路与技巧
1. **状态压缩DP**：将每个点的选择状态用二进制表示，通过枚举所有可能的状态，逐步更新最大边权和。这种方法的时间复杂度为 $O(2^N \cdot N^2)$，在 $N=16$ 时仍然可行。
2. **DFS优化**：通过剪枝和优化搜索顺序，减少不必要的搜索路径。虽然DFS在最坏情况下时间复杂度较高，但在实际应用中可以通过优化来提升效率。

#### 可拓展之处
- **类似问题**：类似的问题可以扩展到更大规模的图，或者引入更多的约束条件（如边的数量限制、点的度数限制等）。
- **算法套路**：状压DP和DFS是解决小规模图论问题的常用方法，可以应用于其他类似的问题，如最大匹配、最小覆盖等。

### 推荐题目
1. [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)

### 所选高分题解

#### 题解1：作者：guanyf（评分：5星）
**关键亮点**：
- 使用状压DP，思路清晰，代码简洁。
- 通过枚举未选择的两个点进行状态转移，优化了时间复杂度。

**核心代码**：
```cpp
for (int i = 0; i < (1 << n); i++) {
    p = -1;
    for (int j = 0; j < n; j++) {
        if (!v && p == -1) p = j;
    }
    for (int j = 0; j < n; j++) {
        if (!v) dp[i | (1 << p) | (1 << j)] = max(dp[i | (1 << p) | (1 << j)], dp[i] + e[j + 1][p + 1]);
    }
    ans = max(ans, dp[i]);
}
```

#### 题解2：作者：DerrickLo（评分：4星）
**关键亮点**：
- 使用状压DP，状态转移方程清晰。
- 通过枚举所有可能的点对进行状态转移，代码实现较为直观。

**核心代码**：
```cpp
for (int S = 0; S < (1 << n); S++) {
    for (int j = 1; j <= n; j++) for (int k = j + 1; k <= n; k++) {
        if (!(S & (1 << (j - 1))) && !(S & (1 << (k - 1)))) {
            dp[S + (1 << (j - 1)) + (1 << (k - 1))] = max(dp[S + (1 << (j - 1)) + (1 << (k - 1))], dp[S] + d[j][k]);
        }
    }
}
```

#### 题解3：作者：Hyc_（评分：4星）
**关键亮点**：
- 使用状压DP，通过检查状态中1的个数进行剪枝，优化了时间复杂度。
- 代码实现简洁，思路清晰。

**核心代码**：
```cpp
for (int x, i = 0; i < (1 << n); ++i) {
    x = check(i);
    if (x & 1 || x + 1 >= n) continue;
    for (int u = 0; u < n; ++u) {
        if ((1 << u) & i) continue;
        for (int v = u + 1; v < n; ++v) {
            if ((1 << v) & i) continue;
            int j = i | (1 << u) | (1 << v);
            Max(dp[j], dp[i] + d[u][v]);
            Max(ans, dp[j]);
        }
    }
}
```

### 个人心得总结
- **调试经历**：在实现状压DP时，状态转移方程的细节容易出错，特别是在处理二进制位时，需要仔细检查每个状态的更新是否正确。
- **踩坑教训**：DFS的实现中，剪枝和优化搜索顺序非常重要，否则容易导致超时。
- **顿悟感想**：状压DP虽然在小规模问题中表现优异，但在大规模问题中需要进一步优化或采用其他算法。

---
处理用时：53.22秒
# 题目信息

# [ABC321C] 321-like Searcher

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc321/tasks/abc321_c

以下の条件を満たす正整数 $ x $ を **321-like Number** と呼びます。 **この定義は A 問題と同様です。**

- $ x $ の各桁を上から見ると狭義単調減少になっている。
- すなわち、$ x $ が $ d $ 桁の整数だとすると、 $ 1\ \le\ i\ <\ d $ を満たす全ての整数 $ i $ について以下の条件を満たす。
  - ( $ x $ の上から $ i $ 桁目 ) $ > $ ( $ x $ の上から $ i+1 $ 桁目 )

なお、 $ 1 $ 桁の正整数は必ず 321-like Number であることに注意してください。

例えば、 $ 321,96410,1 $ は 321-like Number ですが、 $ 123,2109,86411 $ は 321-like Number ではありません。

$ K $ 番目に小さい 321-like Number を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K $
- 321-like Number は $ K $ 個以上存在する

### Sample Explanation 1

321-like Number は小さいものから順に $ (1,2,3,4,5,6,7,8,9,10,20,21,30,31,32,40,\dots) $ です。 このうち $ 15 $ 番目に小さいものは $ 32 $ です。

## 样例 #1

### 输入

```
15```

### 输出

```
32```

## 样例 #2

### 输入

```
321```

### 输出

```
9610```

## 样例 #3

### 输入

```
777```

### 输出

```
983210```

# AI分析结果

### 题目内容重写（中文）

#### 题目描述

定义一个正整数 $x$ 为 **321-like Number**，当且仅当 $x$ 的每一位数字从上到下严格单调递减。具体来说，如果 $x$ 是一个 $d$ 位的整数，那么对于所有满足 $1 \le i < d$ 的整数 $i$，都有以下条件成立：

- $x$ 的第 $i$ 位数字大于第 $i+1$ 位数字。

注意，$1$ 位的正整数一定是 321-like Number。

例如，$321, 96410, 1$ 是 321-like Number，而 $123, 2109, 86411$ 不是。

现在要求你找出第 $K$ 小的 321-like Number。

#### 说明/提示

##### 约束

- 输入均为整数。
- $1 \le K$。
- 321-like Number 的数量至少为 $K$ 个。

##### 样例解释 1

321-like Number 按从小到大的顺序排列为 $(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 30, 31, 32, 40, \dots)$。其中第 $15$ 小的数是 $32$。

#### 样例 #1

##### 输入

```
15
```

##### 输出

```
32
```

#### 样例 #2

##### 输入

```
321
```

##### 输出

```
9610
```

#### 样例 #3

##### 输入

```
777
```

##### 输出

```
983210
```

---

### 题解综合分析

本题的核心是生成所有满足条件的 321-like Number，并按顺序找到第 $K$ 个。由于 321-like Number 的数量有限（最大为 $9876543210$），因此可以通过多种方法生成这些数，如 DFS、BFS、二进制枚举等。以下是几种常见的解题思路：

1. **DFS/BFS 生成所有 321-like Number**：通过递归或队列生成所有满足条件的数，然后排序输出第 $K$ 个。
2. **二进制枚举**：将 321-like Number 看作从 $9876543210$ 的子序列，通过二进制枚举生成所有可能的数。
3. **数位 DP**：通过动态规划计算每个数位可能的组合，最终找到第 $K$ 个满足条件的数。

### 精选题解

#### 题解1：kimidonatsu（4星）

**关键亮点**：
- 使用 BFS 生成所有 321-like Number，避免了排序的复杂度。
- 代码简洁，思路清晰，适合初学者理解。

**核心代码**：
```cpp
void bfs() {
    queue<int> q;
    for (int i = 1; i <= 9; i++) q.push(i);
    while (!q.empty()) {
        int d = q.front(); q.pop();
        K[++tot] = d;
        int cur = d % 10;
        for (int v = 0; v < cur; v++) {
            q.push(d * 10 + v);
        }
    }
}
```

**实现思想**：
通过 BFS 从 1 到 9 开始，每次在末尾添加一个比当前数最后一位小的数字，生成所有 321-like Number。

#### 题解2：timmark（4星）

**关键亮点**：
- 使用 DFS 生成所有 321-like Number，并通过组合数学计算总数。
- 代码结构清晰，适合有一定基础的读者。

**核心代码**：
```cpp
void dfs(int step, int m) {
    if (step == m) {
        long long num = 0;
        for (int i = 1; i <= m; i++) num = num * 10 + a[i];
        ans[++cnt] = num;
        return;
    }
    for (int i = a[step] - 1; i >= m - step - 1; i--) {
        a[step + 1] = i;
        dfs(step + 1, m);
    }
}
```

**实现思想**：
通过 DFS 递归生成所有 321-like Number，确保每一位数字都比前一位小。

#### 题解3：FreedomKing（4星）

**关键亮点**：
- 使用 DFS 生成所有 321-like Number，并通过排序输出第 $K$ 个。
- 代码简洁，适合快速实现。

**核心代码**：
```cpp
void dfs(int x, int last) {
    ans.push_back(x);
    for (int i = 0; i < last; i++) dfs((x << 3) + (x << 1) + i, i);
}
```

**实现思想**：
通过 DFS 递归生成所有 321-like Number，确保每一位数字都比前一位小，最后排序输出第 $K$ 个。

### 最优关键思路

1. **DFS/BFS 生成所有数**：通过递归或队列生成所有满足条件的数，确保每一位数字都比前一位小。
2. **二进制枚举**：将 321-like Number 看作从 $9876543210$ 的子序列，通过二进制枚举生成所有可能的数。

### 拓展思路

- **类似题目**：可以考虑类似的数位生成问题，如生成所有严格递增的数、生成所有回文数等。
- **优化**：可以通过预处理或数学公式减少生成的数量，提高效率。

### 推荐题目

1. [P1217 [USACO1.5]回文质数](https://www.luogu.com.cn/problem/P1217)
2. [P1022 [NOIP2000 普及组] 计算器的改良](https://www.luogu.com.cn/problem/P1022)
3. [P1042 [NOIP2003 普及组] 乒乓球](https://www.luogu.com.cn/problem/P1042)

### 个人心得总结

- **调试经历**：在生成 321-like Number 时，需要注意边界条件，如最大数 $9876543210$ 的处理。
- **踩坑教训**：避免生成重复的数，确保每一位数字都比前一位小。
- **顿悟感想**：通过 DFS/BFS 生成所有可能的数，是一种通用且高效的解题思路。

---
处理用时：53.08秒
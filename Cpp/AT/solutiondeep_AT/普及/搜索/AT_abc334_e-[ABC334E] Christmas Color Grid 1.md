# 题目信息

# [ABC334E] Christmas Color Grid 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_e

**この問題は問題 G と似た設定です。問題文の相違点を赤字で示します。**

$ H $ 行 $ W $ 列のグリッドがあり、グリッドの各マスは赤色あるいは緑色に塗られています。

グリッドの上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,j) $ と表記します。

マス $ (i,j) $ の色は文字 $ S_{i,j} $ で表され、$ S_{i,j}\ = $ `.` のときマス $ (i,j) $ は赤色、$ S_{i,j}\ = $ `#` のときマス $ (i,j) $ は緑色に塗られています。

グリッドにおいて、緑色に塗られたマスを頂点集合、隣り合った $ 2 $ つの緑色のマスを結ぶ辺全体を辺集合としたグラフにおける連結成分の個数を **緑の連結成分数** と呼びます。ただし、$ 2 $ つのマス $ (x,y) $ と $ (x',y') $ が隣り合っているとは、$ |x-x'|\ +\ |y-y'|\ =\ 1 $ であることを指します。

**赤色**に塗られたマスを一様ランダムに $ 1 $ つ選び、**緑色**に塗り替えたとき、塗り替え後のグリッドの緑の連結成分数の期待値を $ \text{mod\ }\ 998244353 $ で出力してください。

  「期待値を $ \text{mod\ }\ 998244353 $ で出力」とは 求める期待値は必ず有理数となることが証明できます。 またこの問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、 $ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ $ 1 $ つ存在することが証明できます。この $ R $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 1000 $
- $ S_{i,j}\ = $ `.` または $ S_{i,j}\ = $ `#`
- $ S_{i,j}\ = $ `.` なる $ (i,j) $ が存在する。
 
### Sample Explanation 1

マス $ (1,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (2,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (3,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 マス $ (3,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 よって、赤色に塗られたマスを一様ランダムに $ 1 $ つ選び、緑色に塗り替えた後の緑の連結成分数の期待値は $ (1+1+2+2)/4\ =\ 3/2 $ となります。

## 样例 #1

### 输入

```
3 3

##.

#.#

#..```

### 输出

```
499122178```

## 样例 #2

### 输入

```
4 5

..#..

.###.

#####

..#..```

### 输出

```
598946613```

## 样例 #3

### 输入

```
3 4

#...

.#.#

..##```

### 输出

```
285212675```

# AI分析结果

### 题目翻译

**题目描述**

给定一个 $H$ 行 $W$ 列的网格，网格中的每个格子被涂成红色或绿色。网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子记为 $(i,j)$。格子 $(i,j)$ 的颜色由字符 $S_{i,j}$ 表示，若 $S_{i,j} = $ `.`，则格子 $(i,j)$ 为红色；若 $S_{i,j} = $ `#`，则格子 $(i,j)$ 为绿色。

在网格中，将绿色格子视为顶点，相邻的两个绿色格子之间用边连接，形成的图的连通分量个数称为**绿色连通分量数**。两个格子 $(x,y)$ 和 $(x',y')$ 相邻的条件是 $|x-x'| + |y-y'| = 1$。

现在，随机选择一个红色格子并将其涂成绿色，求涂色后网格的绿色连通分量数的期望值，并对 $998244353$ 取模输出。

**说明/提示**

- $1 \leq H, W \leq 1000$
- $S_{i,j} = $ `.` 或 $S_{i,j} = $ `#`
- 存在至少一个 $S_{i,j} = $ `.` 的格子 $(i,j)$。

**样例解释**

- 样例1：涂色后绿色连通分量数的期望值为 $3/2$，输出 $499122178$。
- 样例2：涂色后绿色连通分量数的期望值为 $598946613$。
- 样例3：涂色后绿色连通分量数的期望值为 $285212675$。

### 题解分析与结论

#### 综合分析与结论

本题的核心思路是通过预处理绿色连通块的数量，然后枚举每个红色格子，计算将其涂成绿色后对连通块数量的影响，最后求期望值。大多数题解采用了并查集或DFS/BFS来预处理连通块，并通过枚举红色格子来计算期望值。

#### 评分较高的题解

1. **作者：yydfj (4星)**
   - **关键亮点**：使用并查集预处理连通块，通过枚举红色格子计算期望值，代码结构清晰，逻辑严谨。
   - **代码核心思想**：
     ```cpp
     for(int i=0;i<n;i++)
     for(int j=0;j<m;j++)
     if(s[i][j]=='.')
     {
         kk=(kk+1)%mod;
         mp.clear();
         ll ss=0;
         for(int k=0;k<4;k++)
         {
             ll xx=i+dx[k],yy=j+dy[k];
             if(xx<0||yy<0||xx>=n||yy>=m||s[xx][yy]=='.') continue;
             if(!mp.count(find(a[xx][yy]))) ss++,mp[find(a[xx][yy])]=1;
         }
         ans=(ans+tot-ss+1)%mod;
     }
     ```
   - **个人心得**：通过并查集预处理连通块，减少了重复计算，提高了效率。

2. **作者：rui_er (4星)**
   - **关键亮点**：使用DFS预处理连通块，通过枚举红色格子计算期望值，代码简洁，时间复杂度低。
   - **代码核心思想**：
     ```cpp
     for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
     if(s[i][j]=='.')
     {
         ++cnt;
         set<int> st;
         rep(d,0,3)
         {
             int nx=i+nxt[d][0],ny=j+nxt[d][1];
             if(s[nx][ny]=='#') st.insert(vis[nx][ny]);
         }
         ans+=k-(int)st.size()+1;
     }
     ```
   - **个人心得**：通过DFS预处理连通块，避免了并查集的复杂操作，代码更易读。

3. **作者：harmis_yz (4星)**
   - **关键亮点**：使用并查集预处理连通块，通过枚举红色格子计算期望值，代码简洁，逻辑清晰。
   - **代码核心思想**：
     ```cpp
     for(re int i=1;i<=n;++i)
     for(re int j=1;j<=m;++j)
     if(ch[i][j]=='.')
     {
         vk.clear();int dt=0;
         for(re int k=0;k<4;++k)
         {
             int nowx=i+dx[k],nowy=j+dy[k];
             if(ch[nowx][nowy]!='#') continue;
             int s=find(get(nowx,nowy));
             if(!vk[s]) vk[s]=1,++dt;
         }
         P=(P+cnt-dt+1)%p;
     }
     ```
   - **个人心得**：通过并查集预处理连通块，减少了重复计算，提高了效率。

### 最优关键思路与技巧

1. **预处理连通块**：使用并查集或DFS/BFS预处理绿色连通块，减少后续计算的时间复杂度。
2. **枚举红色格子**：通过枚举每个红色格子，计算将其涂成绿色后对连通块数量的影响，最后求期望值。
3. **使用集合去重**：通过集合（如`set`）记录相邻的连通块，避免重复计算。

### 可拓展之处

- **类似题目**：可以扩展到其他网格问题，如计算最大连通块、最小连通块等。
- **算法套路**：并查集、DFS/BFS预处理连通块，枚举计算期望值的思路可以应用于其他图论问题。

### 推荐题目

1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)

---
处理用时：49.91秒
# 题目信息

# [ABC339D] Synchronized Players

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc339/tasks/abc339_d

$ N $ 行 $ N $ 列のグリッドがあり、各マスは空きマスか障害物のあるマスのいずれかです。グリッドの上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表記します。

また、$ 2 $ 人のプレイヤーがグリッド上の相異なる空きマス上におり、各マスの情報は $ N $ 個の長さ $ N $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_N $ として以下の形式で与えられます。

- $ S_i $ の $ j $ 文字目が `P` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいる
- $ S_i $ の $ j $ 文字目が `.` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいない
- $ S_i $ の $ j $ 文字目が `#` であるとき、$ (i,\ j) $ は障害物のあるマスである
 
以下の操作を繰り返し $ 2 $ 人のプレイヤーを同じマスに集めるために必要な操作回数の最小値を求めてください。ただし、操作の繰り返しにより $ 2 $ 人のプレイヤーを同じマスに集めることができない場合には `-1` を出力してください。

- 上下左右のいずれかの方向を決める。そして各プレイヤーはともにその方向に隣接するマスへの移動を試みる。各プレイヤーは移動先のマスが存在し、かつ空きマスであるならば移動し、そうでないならば移動しない。

## 说明/提示

### 制約

- $ N $ は $ 2 $ 以上 $ 60 $ 以下の整数
- $ S_i $ は長さ $ N $ の `P`, `.`, `#` からなる文字列
- $ S_i $ の $ j $ 文字目が `P` であるような組 $ (i,\ j) $ の個数はちょうど $ 2 $ つ
 
### Sample Explanation 1

はじめに $ (3,\ 2) $ にいるプレイヤーをプレイヤー $ 1 $、$ (4,\ 3) $ にいるプレイヤーをプレイヤー $ 2 $ とします。 例えば以下のようにすることで、$ 3 $ 回の操作で $ 2 $ 人のプレイヤーが同じマスに集まります。 - 左を選択する。プレイヤー $ 1 $ は $ (3,\ 1) $ に移動し、プレイヤー $ 2 $ は $ (4,\ 2) $ に移動する。 - 上を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 2) $ に移動する。 - 左を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 1) $ に移動する。

## 样例 #1

### 输入

```
5

....#

#..#.

.P...

..P..

....#```

### 输出

```
3```

## 样例 #2

### 输入

```
2

P#

#P```

### 输出

```
-1```

## 样例 #3

### 输入

```
10

..........

..........

..........

..........

....P.....

.....P....

..........

..........

..........

..........```

### 输出

```
10```

# AI分析结果

### 题目内容重写

#### [ABC339D] Synchronized Players

**题目描述**

有一个 $N$ 行 $N$ 列的网格，每个格子要么是空地，要么是障碍物。网格从上到下第 $i$ 行、从左到右第 $j$ 列的格子记为 $(i, j)$。

此外，网格上有两个玩家，他们位于不同的空地上。网格的信息由 $N$ 个长度为 $N$ 的字符串 $S_1, S_2, \ldots, S_N$ 给出，具体格式如下：

- 如果 $S_i$ 的第 $j$ 个字符是 `P`，则 $(i, j)$ 是空地，并且有玩家位于该格子。
- 如果 $S_i$ 的第 $j$ 个字符是 `.`，则 $(i, j)$ 是空地，但没有玩家。
- 如果 $S_i$ 的第 $j$ 个字符是 `#`，则 $(i, j)$ 是障碍物。

你可以重复进行以下操作，目标是让两个玩家移动到同一个格子。求最少需要多少次操作才能实现目标。如果无法让两个玩家移动到同一个格子，则输出 `-1`。

- 选择一个方向（上、下、左、右），然后两个玩家都尝试向该方向移动。如果移动后的格子存在且是空地，则玩家移动到该格子；否则，玩家不移动。

**输入格式**

第一行输入一个整数 $N$，表示网格的大小。

接下来 $N$ 行，每行输入一个长度为 $N$ 的字符串 $S_i$，表示网格的第 $i$ 行。

**输出格式**

输出一个整数，表示将两个玩家移动到同一个格子所需的最少操作次数。如果无法实现，则输出 `-1`。

**样例**

**样例输入 1**

```
5

....#

#..#.

.P...

..P..

....#
```

**样例输出 1**

```
3
```

**样例输入 2**

```
2

P#

#P
```

**样例输出 2**

```
-1
```

**样例输入 3**

```
10

..........

..........

..........

..........

....P.....

.....P....

..........

..........

..........

..........
```

**样例输出 3**

```
10
```

**提示**

- $N$ 是 $2$ 到 $60$ 之间的整数。
- $S_i$ 是长度为 $N$ 的字符串，由 `P`、`.`、`#` 组成。
- $S_i$ 中恰好有两个字符是 `P`。

### 题解分析与结论

本题的核心是通过广度优先搜索（BFS）来寻找两个玩家移动到同一格子的最短路径。由于网格的大小 $N$ 最大为 60，状态数为 $N^4$，约为 12960000，完全在可接受范围内。因此，直接使用 BFS 进行状态搜索即可。

#### 最优思路与技巧

1. **状态表示**：将两个玩家的位置 $(x1, y1)$ 和 $(x2, y2)$ 作为一个状态，使用四维数组 `vis[x1][y1][x2][y2]` 来记录是否访问过该状态。
2. **移动规则**：每次选择一个方向，两个玩家都尝试向该方向移动。如果移动后的格子是障碍物或超出边界，则玩家不移动。
3. **终止条件**：当两个玩家的位置相同时，返回当前步数。
4. **优化**：在 BFS 中，每次移动后检查是否访问过新状态，避免重复访问。

#### 可拓展之处

- **类似问题**：类似的问题可以扩展到多个玩家或更多维度的网格中，状态数会相应增加，但 BFS 的思路仍然适用。
- **优化**：如果网格较大，可以考虑使用双向 BFS 或 A* 算法来减少搜索空间。

### 推荐题目

1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

### 精选题解

#### 题解1：cjh20090318

**星级**：★★★★★

**关键亮点**：
- 使用 BFS 进行状态搜索，思路清晰。
- 代码结构简洁，易于理解。
- 使用四维数组记录状态，避免重复访问。

**核心代码**：

```cpp
struct Node{
    int X1,Y1,X2,Y2,D;
    Node(int _X1=0,int _Y1=0,int _X2=0,int _Y2=0,int _D=0):X1(_X1),Y1(_Y1),X2(_X2),Y2(_Y2),D(_D){}
};
queue<Node> Q;
Q.emplace(p1x,p1y,p2x,p2y,0);
for(Node u;!Q.empty();){
    u=Q.front();Q.pop();
    if(d[u.X1][u.Y1][u.X2][u.Y2]) continue;
    d[u.X1][u.Y1][u.X2][u.Y2]=1;
    if(u.X1==u.X2 && u.Y1==u.Y2){
        ans=min(ans,u.D);
        continue;
    }
    for(int k=0,n1x,n1y,n2x,n2y;k<4;k++){
        n1x=u.X1+dx[k],n1y=u.Y1+dy[k],n2x=u.X2+dx[k],n2y=u.Y2+dy[k];
        if(n1x<1||n1x>n||n1y<1||n1y>n||s[n1x][n1y]=='#') n1x=u.X1,n1y=u.Y1;
        if(n2x<1||n2x>n||n2y<1||n2y>n||s[n2x][n2y]=='#') n2x=u.X2,n2y=u.Y2;
        Q.emplace(n1x,n1y,n2x,n2y,u.D+1);
    }
}
```

#### 题解2：Milthm

**星级**：★★★★

**关键亮点**：
- 使用 BFS 进行状态搜索，代码简洁。
- 使用四维数组记录状态，避免重复访问。
- 代码结构清晰，易于理解。

**核心代码**：

```cpp
struct node{
    int x,y,x2,y2,d;
};
queue<node>q;
q.push({x,y,x2,y2,0});
while(!q.empty()){
    node c=q.front();q.pop();
    x=c.x,y=c.y,x2=c.x2,y2=c.y2;
    if(x==x2&&y==y2){
        cout<<c.d;return 0;
    }
    if(vis[x][y][x2][y2])continue;
    vis[x][y][x2][y2]=1;
    for(int i=0;i<4;++i){
        int px=x+w[i][0],py=y+w[i][1];
        int px2=x2+w[i][0],py2=y2+w[i][1];
        if(!(px>=1&&px<=n&&py>=1&&py<=n)||a[px][py]=='#')px=x,py=y;
        if(!(px2>=1&&px2<=n&&py2>=1&&py2<=n)||a[px2][py2]=='#')px2=x2,py2=y2;
        q.push({px,py,px2,py2,c.d+1});
    }
}
```

#### 题解3：CheZiHe929

**星级**：★★★★

**关键亮点**：
- 使用 BFS 进行状态搜索，代码简洁。
- 使用四维数组记录状态，避免重复访问。
- 代码结构清晰，易于理解。

**核心代码**：

```cpp
struct loc{
    int x,y;
};
struct loca{
    loc x,y;int step;
};
queue<loca>q;
q.push({pl[1],pl[2],0});
while(!q.empty()){
    loca now=q.front();q.pop();
    if(now.x.x==now.y.x&&now.x.y==now.y.y){
        ans=now.step+1;
        return;
    }
    for(int i=0;i<4;++i){
        loc n1=check(now.x,i),n2=check(now.y,i);
        if(n1.x==n2.x&&n1.y==n2.y){
            ans=now.step+1;
            return;
        }
        if(!vis[n1.x][n1.y][n2.x][n2.y]){
            q.push({n1,n2,now.step+1});
            vis[n1.x][n1.y][n2.x][n2.y]=1;
        }
    }
}
```

---
处理用时：74.72秒
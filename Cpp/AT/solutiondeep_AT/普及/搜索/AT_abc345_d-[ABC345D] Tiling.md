# 题目信息

# [ABC345D] Tiling

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc345/tasks/abc345_d

一辺の長さが $ 1 $ のマスからなる $ H $ 行 $ W $ 列のマス目と、$ N $ 枚のタイルがあります。  
$ i $ $ (1\leq\ i\leq\ N) $ 枚目のタイルは $ A_i\times\ B_i $ の長方形です。  
以下の条件をすべてみたすようにタイルをマス目に置くことができるか判定してください。

- 全てのマスがちょうど $ 1 $ 枚のタイルで覆われている。
- 使用されないタイルがあっても良い。
- 使用するタイルは **回転したり裏返したりして置かれていても良い**。ただし、各タイルはマスの線に合わせてマス目からはみ出ることがないように置かれていなければならない。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 7 $
- $ 1\ \leq\ H,W\ \leq\ 10 $
- $ 1\leq\ A_i,B_i\leq\ 10 $
- 入力はすべて整数

### Sample Explanation 1

$ 2,4,5 $ 枚目のタイルを使用して次のように置くと、マス目の各マスをちょうど $ 1 $ 枚のタイルで覆うことができます。 !\[\](https://img.atcoder.jp/abc345/0a0f2829d0485013deabba0103dbd906.png) よって、`Yes` を出力します。

### Sample Explanation 2

マス目からはみ出さないようにタイルを置くことはできません。 よって、`No` を出力します。

### Sample Explanation 3

全てのマスを覆うようにタイルを置くことができません。 よって、`No` を出力します。

### Sample Explanation 4

全てのマスはちょうど $ 1 $ 枚のタイルで覆われている必要があることに注意してください。

## 样例 #1

### 输入

```
5 5 5
1 1
3 3
4 4
2 3
2 5```

### 输出

```
Yes```

## 样例 #2

### 输入

```
1 1 2
2 3```

### 输出

```
No```

## 样例 #3

### 输入

```
1 2 2
1 1```

### 输出

```
No```

## 样例 #4

### 输入

```
5 3 3
1 1
2 2
2 2
2 2
2 2```

### 输出

```
No```

# AI分析结果

### 题目内容重写

#### [ABC345D] Tiling

##### 题目描述

有一个由 $H$ 行 $W$ 列组成的网格，每个单元格的边长为 $1$。同时有 $N$ 块瓷砖，第 $i$ 块瓷砖的大小为 $A_i \times B_i$。请判断是否有可能将这些瓷砖放置在网格中，满足以下条件：

- 每个单元格都正好被一块瓷砖覆盖。
- 未使用的瓷砖不影响结果。
- 瓷砖在放置时可以旋转或翻转，但每块瓷砖必须与单元格的边缘对齐，不得超出网格范围。

##### 说明/提示

###### 制约

- $1 \leq N \leq 7$
- $1 \leq H, W \leq 10$
- $1 \leq A_i, B_i \leq 10$
- 输入均为整数

###### 样例解释

**样例 1**  
使用第 2、4、5 块瓷砖，可以将网格完全覆盖，输出 `Yes`。

**样例 2**  
无法将瓷砖放置在网格中而不超出范围，输出 `No`。

**样例 3**  
无法用瓷砖完全覆盖网格，输出 `No`。

**样例 4**  
每个单元格必须被恰好一块瓷砖覆盖，输出 `No`。

---

### 题解分析与结论

该题的核心是通过深度优先搜索（DFS）枚举所有可能的瓷砖放置方式，并结合剪枝优化来减少搜索空间。由于数据范围较小（$N \leq 7$，$H, W \leq 10$），直接暴力搜索是可行的，但需要通过剪枝来提升效率。

#### 关键思路与技巧

1. **DFS + 剪枝**：通过 DFS 枚举每个瓷砖的放置位置和旋转方式，结合剪枝（如面积和、矩形排序等）来减少无效搜索。
2. **矩形旋转处理**：每个瓷砖可以旋转 90 度，因此在搜索时需要分别考虑两种放置方式。
3. **面积和剪枝**：在搜索过程中，如果当前已覆盖的面积加上剩余瓷砖的总面积小于网格总面积，则可以直接剪枝。
4. **矩形排序优化**：将瓷砖按面积从大到小排序，优先放置大瓷砖，可以减少搜索树的宽度。

#### 最优题解推荐

以下题解在思路清晰度、代码可读性和优化程度方面表现较好，评分较高：

---

#### 题解1：作者：Vocaloid世末歌者 (赞：12)

**星级：★★★★★**

**关键亮点**：
- 使用 DFS 枚举每个瓷砖的放置位置，并考虑旋转。
- 通过剪枝优化，减少了无效搜索。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
void dfs(LL x, LL y) {
    if (y > w) dfs(x + 1, 1);
    if (x > h) {
        cout << "Yes" << endl;
        exit(0);
    }
    if (vis[x][y]) dfs(x, y + 1);
    rep(i, 1, 2 * n, 1) {
        if (!u[(i - 1) % n + 1]) {
            bool f = 1;
            repn(xx, x, x + a[i], 1) {
                repn(yy, y, y + b[i], 1) {
                    if (xx > h || yy > w || vis[xx][yy]) f = 0;
                }
            }
            if (!f) continue;
            u[(i - 1) % n + 1] = 1;
            repn(xx, x, x + a[i], 1) {
                repn(yy, y, y + b[i], 1) {
                    vis[xx][yy] = 1;
                }
            }
            dfs(x, y + 1);
            u[(i - 1) % n + 1] = 0;
            repn(xx, x, x + a[i], 1) {
                repn(yy, y, y + b[i], 1) {
                    vis[xx][yy] = 0;
                }
            }
        }
    }
}
```

**个人心得**：
作者提到最初直接暴力搜索导致 TLE，后来通过剪枝优化成功通过。这种从失败中总结经验的过程值得学习。

---

#### 题解2：作者：vanyou (赞：5)

**星级：★★★★☆**

**关键亮点**：
- 使用 DFS 枚举每个瓷砖的放置位置，并考虑旋转。
- 通过面积和剪枝优化，减少了无效搜索。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
void dfs(int x, int y) {
    if (y > w) y = 1, x++;
    if (x == h + 1) { cout << "Yes", exit(0); }
    if (vis[x][y]) { dfs(x, y + 1); return; }
    for (int i = 1; i <= n; i++) {
        if (use[i]) continue;
        int ex = x + a[i].x - 1, ey = y + a[i].y - 1;
        if (ex > h || ey > w) continue;
        if (!ck(x, y, ex, ey)) continue;
        use[i] = 1;
        put(x, y, ex, ey, 1);
        dfs(x, y + 1);
        put(x, y, ex, ey, 0);
        use[i] = 0;
    }
}
```

**个人心得**：
作者提到通过面积和剪枝优化，显著减少了搜索时间。这种优化思路值得借鉴。

---

#### 题解3：作者：zaochen (赞：0)

**星级：★★★★☆**

**关键亮点**：
- 使用 DFS 枚举每个瓷砖的放置位置，并考虑旋转。
- 通过面积和剪枝优化，减少了无效搜索。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
void dfs(int x, int y) {
    if (y > w) y = 1, x++;
    if (x == h + 1) { cout << "Yes", exit(0); }
    if (vis[x][y]) { dfs(x, y + 1); return; }
    for (int i = 1; i <= n; i++) {
        if (use[i]) continue;
        int ex = x + a[i].x - 1, ey = y + a[i].y - 1;
        if (ex > h || ey > w) continue;
        if (!ck(x, y, ex, ey)) continue;
        use[i] = 1;
        put(x, y, ex, ey, 1);
        dfs(x, y + 1);
        put(x, y, ex, ey, 0);
        use[i] = 0;
    }
}
```

**个人心得**：
作者提到通过面积和剪枝优化，显著减少了搜索时间。这种优化思路值得借鉴。

---

### 最优关键思路总结

1. **DFS + 剪枝**：通过 DFS 枚举所有可能的瓷砖放置方式，结合面积和剪枝、矩形排序等优化，减少无效搜索。
2. **矩形旋转处理**：每个瓷砖可以旋转 90 度，因此在搜索时需要分别考虑两种放置方式。
3. **面积和剪枝**：在搜索过程中，如果当前已覆盖的面积加上剩余瓷砖的总面积小于网格总面积，则可以直接剪枝。

### 拓展与举一反三

类似题目：
1. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120) - 搜索剪枝经典题。
2. [P1731 [NOI1999] 生日蛋糕](https://www.luogu.com.cn/problem/P1731) - 搜索剪枝与优化。
3. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433) - 搜索与状态压缩。

这些题目都涉及搜索与剪枝的优化，适合进一步练习。

---
处理用时：67.38秒
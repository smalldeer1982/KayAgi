# 题目信息

# [ABC348D] Medicines on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc348/tasks/abc348_d

$ H $ 行 $ W $ 列のグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,\ j) $ と表します。各マスの状態は文字 $ A_{i,j} $ で表され、意味は以下の通りです。

- `.` : 空きマス。
- `#` : 障害物。
- `S` : 空きマスかつスタート地点。
- `T` : 空きマスかつゴール地点。
 
高橋君は、今いるマスから上下左右に隣り合う空きマスへ、エネルギーを $ 1 $ 消費して移動することができます。ただし、エネルギーが $ 0 $ の状態で移動することはできず、またグリッドの外へ移動することはできません。

グリッドには合計で $ N $ 個の薬があります。$ i $ 番目の薬は空きマス $ (R_i,\ C_i) $ にあり、使うとエネルギーを **$ E_i $ にする**ことができます。必ずしもエネルギーが増えるとは限らないことに注意してください。高橋君は自分のいるマスにある薬を使うことができます。使った薬はなくなります。

高橋君ははじめエネルギー $ 0 $ の状態でスタート地点にいて、ゴール地点まで移動したいです。これが可能かどうか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 200 $
- $ A_{i,\ j} $ は `.`, `#`, `S`, `T` のいずれかである。
- `S` と `T` は $ A_{i,\ j} $ にそれぞれちょうど $ 1 $ つ存在する。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ R_i\ \leq\ H $
- $ 1\ \leq\ C_i\ \leq\ W $
- $ i\ \neq\ j $ ならば $ (R_i,\ C_i)\ \neq\ (R_j,\ C_j) $
- $ A_{R_i,\ C_i} $ は `#` でない。
- $ 1\ \leq\ E_i\ \leq\ HW $
 
### Sample Explanation 1

例えば、以下のようにしてゴール地点へ移動することができます。 - 薬 $ 1 $ を使う。エネルギーが $ 3 $ になる。 - $ (1,\ 2) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (1,\ 3) $ へ移動する。エネルギーが $ 1 $ になる。 - 薬 $ 2 $ を使う。エネルギーが $ 5 $ になる。 - $ (2,\ 3) $ へ移動する。エネルギーが $ 4 $ になる。 - $ (3,\ 3) $ へ移動する。エネルギーが $ 3 $ になる。 - $ (3,\ 4) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (4,\ 4) $ へ移動する。エネルギーが $ 1 $ になる。 この移動の途中には $ (2,\ 3) $ にも薬がありますが、これを使うとゴールできません。

### Sample Explanation 2

高橋君はスタート地点から移動することができません。

## 样例 #1

### 输入

```
4 4

S...

#..#

#...

..#T

4

1 1 3

1 3 5

3 2 1

2 3 1```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 2

S.

T.

1

1 2 4```

### 输出

```
No```

## 样例 #3

### 输入

```
4 5

..#..

.S##.

.##T.

.....

3

3 1 5

1 2 3

2 2 1```

### 输出

```
Yes```

# AI分析结果

### 题目内容

#### [ABC348D] Medicines on Grid

#### 题目描述

有一个 $H$ 行 $W$ 列的网格。从上往下第 $i$ 行、从左往右第 $j$ 列的格子表示为 $(i, j)$。每个格子的状态由字符 $A_{i,j}$ 表示，含义如下：

- `.`：空格子。
- `#`：障碍物。
- `S`：空格子且为起点。
- `T`：空格子且为终点。

高桥君可以从当前格子上下左右移动到相邻的空格子，每次移动消耗 $1$ 点能量。如果能量为 $0$，则无法移动，且不能移动到网格外。

网格中有 $N$ 种药物。第 $i$ 种药物位于空格子 $(R_i, C_i)$，使用后可以将能量**设为** $E_i$。注意，能量不一定会增加。高桥君可以选择是否使用当前格子中的药物，使用后药物会消失。

高桥君初始能量为 $0$，位于起点。请判断他是否能到达终点。

#### 说明/提示

##### 约束

- $1 \leq H, W \leq 200$
- $A_{i,j}$ 为 `.`, `#`, `S`, `T` 之一。
- `S` 和 `T` 在 $A_{i,j}$ 中各出现一次。
- $1 \leq N \leq 300$
- $1 \leq R_i \leq H$
- $1 \leq C_i \leq W$
- 若 $i \neq j$，则 $(R_i, C_i) \neq (R_j, C_j)$
- $A_{R_i, C_i}$ 不为 `#`
- $1 \leq E_i \leq HW$

##### 样例解释 1

例如，可以按照以下步骤到达终点：
- 使用药物 $1$，能量变为 $3$。
- 移动到 $(1, 2)$，能量变为 $2$。
- 移动到 $(1, 3)$，能量变为 $1$。
- 使用药物 $2$，能量变为 $5$。
- 移动到 $(2, 3)$，能量变为 $4$。
- 移动到 $(3, 3)$，能量变为 $3$。
- 移动到 $(3, 4)$，能量变为 $2$。
- 移动到 $(4, 4)$，能量变为 $1$。

##### 样例解释 2

高桥君无法从起点移动。

##### 样例 #1

###### 输入

```
4 4

S...

#..#

#...

..#T

4

1 1 3

1 3 5

3 2 1

2 3 1
```

###### 输出

```
Yes
```

##### 样例 #2

###### 输入

```
2 2

S.

T.

1

1 2 4
```

###### 输出

```
No
```

##### 样例 #3

###### 输入

```
4 5

..#..

.S##.

.##T.

.....

3

3 1 5

1 2 3

2 2 1
```

###### 输出

```
Yes
```

---

### 题解分析与结论

#### 综合分析与结论

该题目是一个典型的网格图搜索问题，结合了能量管理和药物使用的机制。题解主要集中在使用 BFS 或优先队列 BFS 来解决，关键在于如何有效地管理能量和药物的使用。大多数题解通过记录每个格子的最大能量值来优化搜索过程，避免重复计算。

#### 所选高星题解

1. **作者：__ATRI__ (赞：13)**  
   - **星级：★★★★★**  
   - **关键亮点：**  
     - 使用优先队列 BFS，确保每次扩展时优先处理能量较高的状态。
     - 通过记录每个格子的最大能量值来剪枝，避免重复扩展。
     - 代码简洁清晰，逻辑严密。
   - **核心代码：**
     ```cpp
     void bfs(){
         priority_queue<node>q;
         memset(dis,-0x3f,sizeof dis);
         dis[sx][sy]=max(b[sx][sy],0);
         q.push({sx,sy,dis[sx][sy]});
         while(q.size()){
             auto[x,y,val]=q.top();
             q.pop();
             if(x==fx&&y==fy){
                 cout << "Yes" << endl;
                 return;
             }
             if(!val)continue;
             if(val<dis[x][y])continue;
             for(int i=0;i<4;++i){
                 int xx=x+dx[i],yy=y+dy[i];
                 if(xx<1||xx>n||yy<1||yy>m||!a[xx][yy])continue;
                 int v=b[xx][yy]?max(b[xx][yy],val-1):val-1;
                 if(v>dis[xx][yy]){
                     q.push({xx,yy,v});
                     dis[xx][yy]=v;
                 }
             }
         }
         cout << "No" << endl;
     }
     ```

2. **作者：ivnilkkk (赞：3)**  
   - **星级：★★★★**  
   - **关键亮点：**  
     - 使用普通 BFS，通过记录每个格子的最大能量值来优化搜索。
     - 代码实现简单，易于理解。
   - **核心代码：**
     ```cpp
     void bfs(int x, int y) {
         q.push(make_pair(x, y));
         if(a[x][y]) {
             dis[x][y] = a[x][y];
             a[x][y] = 0;
         }
         while(!q.empty()) {
             int x = q.front().first;
             int y = q.front().second;
             q.pop();
             if(x == tx && y == ty) {
                 ok = true;
                 return;
             }
             if(dis[x][y] <= 0) return;
             for(int i = 0; i < 4; i++) {
                 int X = x + d[i][0], Y = y + d[i][1];
                 if(a[X][Y] == -1 || X < 1 || Y < 1 || X > n || Y > m)
                     continue;
                 int ma = dis[x][y] - 1;
                 if(a[X][Y]) {
                     ma = max(ma, a[X][Y]);
                     a[X][Y] = 0;
                 }
                 if(ma > dis[X][Y]) {
                     dis[X][Y] = ma;
                     q.push(make_pair(X, Y));
                 }
             }
         }
     }
     ```

3. **作者：Fiendish (赞：2)**  
   - **星级：★★★★**  
   - **关键亮点：**  
     - 使用优先队列 BFS，确保每次扩展时优先处理能量较高的状态。
     - 通过记录每个格子的最大能量值来剪枝，避免重复扩展。
   - **核心代码：**
     ```cpp
     void bfs(){
         priority_queue<pair<int,pair<int,int>> > q;
         q.push({e[sx][sy],{sx,sy}});
         while(!q.empty()){
             int en=q.top().first,x=q.top().second.first,y=q.top().second.second;
             q.pop();
             if(x==tx&&y==ty){
                 puts("Yes");
                 return;
             }
             if(vis[x][y]>=en) continue;
             vis[x][y]=en,en--;
             for(int i=0;i<4;i++){
                 int x1=x+dx[i],y1=y+dy[i];
                 if(ma[x1][y1]){
                     if(e[x1][y1]) q.push({max(e[x1][y1],en),{x1,y1}});
                     else q.push({en,{x1,y1}});
                 }
             }
         }
         puts("No");
     }
     ```

#### 最优关键思路或技巧

1. **优先队列 BFS**：通过优先处理能量较高的状态，确保每次扩展时都能尽可能多地覆盖可到达的格子。
2. **能量记录与剪枝**：记录每个格子的最大能量值，避免重复扩展，减少不必要的计算。
3. **药物使用的优化**：在扩展时，优先考虑使用药物来最大化能量，确保能够到达更远的格子。

#### 可拓展之处

- **类似题目**：可以考虑扩展到更复杂的网格图问题，如带有时间限制、多种资源管理等。
- **算法优化**：可以进一步优化 BFS 的实现，如使用双向 BFS 或 A* 算法来加速搜索过程。

#### 推荐题目

1. [P3958 奶酪](https://www.luogu.com.cn/problem/P3958)
2. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

#### 个人心得摘录

- **调试经历**：在实现 BFS 时，优先队列的使用需要特别注意，确保每次扩展时优先处理能量较高的状态。
- **踩坑教训**：在记录每个格子的最大能量值时，需要确保每次更新时都能正确地更新最大值，避免遗漏。
- **顿悟感想**：通过优先队列 BFS 和能量记录的结合，能够有效地解决复杂的网格图搜索问题。

---
处理用时：77.61秒
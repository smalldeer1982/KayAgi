# 题目信息

# [ABC351D] Grid and Magnet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_d

$ H $ 行 $ W $ 列のマス目があり、いくつか（$ 0 $ 個のこともある）のマスには磁石が置かれています。  
マス目の状態は $ H $ 個の 長さ $ W $ の文字列 $ S_1,S_2,\ldots,S_H $ で表され、 $ S_i $ の $ j $ 文字目が `#` のとき上から $ i $ 行目かつ左から $ j $ 列目のマスには磁石が置かれていることを、 `.` のとき何も置かれていないことを表しています。

高橋君は鉄の鎧を着ており、あるマスにいるとき次のように移動することができます。

- 現在いるマスの上下左右に隣り合うマスのいずれかに磁石が置かれているとき、どこへも移動することができない。
- そうでないとき、上下左右に隣り合うマスのいずれかを選んでそのマスに移動することができる。  
  ただし、マス目の外に移動することはできない。

磁石が置かれていない各マスについて、そのマスの自由度を、「最初高橋くんがそのマスにいるとき、そこから移動を繰り返して到達できるマスの個数」として定義します。 マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を求めてください。

ただし、自由度の定義において、「移動を繰り返して到達できるマス」とは、最初にいるマスからそのマスまで移動を繰り返して到達する方法（$ 1 $ 回も移動しないものも含む）が $ 1 $ つ以上存在するようなマスのことであり、 最初のマスから始めてすべてのそのようなマスを巡るような移動方法が存在する必要はありません。特に（磁石の置かれていない）各マス自身は、そのマスから「移動を繰り返して到達できるマス」につねに含まれることに注意してください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ H,W $ は整数
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列
- 磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。

### Sample Explanation 1

上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。

### Sample Explanation 2

磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。

## 样例 #1

### 输入

```
3 5
.#...
.....
.#..#```

### 输出

```
9```

## 样例 #2

### 输入

```
3 3
..#
#..
..#```

### 输出

```
1```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个 $H$ 行 $W$ 列的网格，某些网格上可能放置了磁铁（也可能没有磁铁）。网格的状态由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 表示，其中 $S_i$ 的第 $j$ 个字符为 `#` 表示第 $i$ 行第 $j$ 列的网格上有磁铁，为 `.` 表示该网格上没有磁铁。

高桥君穿着铁制的铠甲，他在某个网格上时，可以按照以下规则移动：

- 如果当前网格的上下左右相邻网格中有磁铁，则他不能移动。
- 否则，他可以选择上下左右相邻的任意一个网格移动。注意，不能移动到网格外。

对于每个没有磁铁的网格，定义其“自由度”为：当高桥君最初位于该网格时，通过多次移动可以到达的网格数量。求所有没有磁铁的网格中，自由度的最大值。

#### 说明/提示

##### 约束条件

- $1 \leq H, W \leq 1000$
- $H, W$ 为整数
- $S_i$ 是由 `.` 和 `#` 组成的长度为 $W$ 的字符串
- 至少有一个网格没有磁铁

##### 样例解释

**样例 1**  
输入：
```
3 5
.#...
.....
.#..#
```
输出：
```
9
```
解释：高桥君从 (2,3) 出发，可以到达 9 个网格，因此自由度为 9。

**样例 2**  
输入：
```
3 3
..#
#..
..#
```
输出：
```
1
```
解释：所有没有磁铁的网格都无法移动，因此自由度为 1。

### 题解分析与结论

#### 题解对比

1. **2huk 的题解**  
   - **思路**：将网格分为三类：有磁铁的点、靠近磁铁的点（不能移动的点）、不靠近磁铁的点。对于不靠近磁铁的点，使用 BFS 计算其连通块的大小，并处理靠近磁铁的点。
   - **亮点**：通过分类处理，减少了不必要的计算，复杂度为线性。
   - **评分**：★★★★★

2. **HasNoName 的题解**  
   - **思路**：从每个不靠近磁铁的点进行 BFS，处理靠近磁铁的点时，清空标记以避免重复计算。
   - **亮点**：通过清空标记，确保每个靠近磁铁的点只被计算一次，复杂度为 $O(HW)$。
   - **评分**：★★★★☆

3. **ThisIsLu 的题解**  
   - **思路**：使用 DFS 进行搜索，处理靠近磁铁的点时，保持标记不变，搜索结束后再清空标记。
   - **亮点**：通过标记管理，避免了重复搜索，复杂度为线性。
   - **评分**：★★★★☆

#### 最优关键思路

- **分类处理**：将网格分为三类（有磁铁、靠近磁铁、不靠近磁铁），分别处理，减少不必要的计算。
- **BFS/DFS 优化**：在搜索过程中，通过标记管理和清空标记，确保每个点只被计算一次，避免重复搜索。
- **复杂度控制**：通过优化搜索策略，确保算法复杂度为线性，能够处理大规模数据。

#### 可拓展之处

- **类似题目**：可以扩展到其他网格搜索问题，如迷宫问题、连通块问题等。
- **算法套路**：分类处理 + BFS/DFS 优化是解决网格搜索问题的常见套路，适用于多种场景。

#### 推荐题目

1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
2. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)

#### 个人心得摘录

- **2huk**：通过分类处理，减少了不必要的计算，复杂度为线性。
- **HasNoName**：处理靠近磁铁的点时，清空标记以避免重复计算，确保复杂度为 $O(HW)$。
- **ThisIsLu**：通过标记管理，避免了重复搜索，复杂度为线性。

### 所选高分题解

#### 2huk 的题解（★★★★★）

**关键亮点**：通过分类处理，减少了不必要的计算，复杂度为线性。

**核心代码**：
```cpp
int bfs(int x, int y) {
    if (chk(x, y)) return 1;
    if (st[x][y]) return -114514;

    queue<pair<int, int> > q;
    q.emplace(x, y);
    int ans = 0;
    st[x][y] = true;

    map<pair<int, int>, bool> S;

    while (q.size()) {
        int x = q.front().first, y = q.front().second;
        q.pop();
        ++ ans;
        if (!chk(x, y)) {
            for (int i = 0; i < 4; ++ i ) {
                int a = x + dx[i], b = y + dy[i];
                if (a >= 1 && a <= n && b >= 1 && b <= m && g[a][b] == '.') {
                    if (chk(a, b)) {
                        if (!S[{a, b}]) {
                            q.emplace(a, b);
                            S[{a, b}] = true;
                        }
                    }
                    else if (!st[a][b]) {
                        q.emplace(a, b);
                        st[a][b] = true;	
                    }
                }
            }
        }
    }

    return ans;
}
```

**核心思想**：通过 BFS 计算连通块的大小，处理靠近磁铁的点时，确保每个点只被计算一次。

---
处理用时：51.71秒
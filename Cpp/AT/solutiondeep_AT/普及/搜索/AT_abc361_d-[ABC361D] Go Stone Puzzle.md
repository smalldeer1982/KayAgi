# 题目信息

# [ABC361D] Go Stone Puzzle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_d

$ N+2 $ 個のマスが横一列に並んでいます。左から $ i $ 番目のマスをマス $ i $ と表します。

マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれています。  
 各 $ 1\leq\ i\ \leq\ N $ について、$ S_i $ が `W` のときマス $ i $ に置かれている石の色は白であり、$ S_i $ が `B` のときマス $ i $ に置かれている石の色は黒です。  
 マス $ N+1,N+2 $ には何も置かれていません。

あなたは以下の操作を好きな回数($ 0 $ 回でもよい)行うことができます。

- 石が $ 2 $ 個並んでいる箇所を選び、その $ 2 $ 個の石を順序を保って空きマスに移す。  
   より正確には次の通り。$ 1 $ 以上 $ N+1 $ 以下の整数 $ x $ であって、マス $ x,x+1 $ の両方に石が置かれているものを選ぶ。石の置かれていないマスを $ k,k+1 $ とする。マス $ x,x+1 $ にある石をそれぞれマス $ k,k+1 $ に移動する。
 
以下の状態にすることが可能か判定し、可能なら操作回数の最小値を求めてください。

- マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれており、各 $ 1\leq\ i\ \leq\ N $ について、$ T_i $ が `W` のときマス $ i $ に置かれている石の色は白、$ T_i $ が `B` のときマス $ i $ に置かれている石の色は黒である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 14 $
- $ N $ は整数である
- $ S,T $ は `B` および `W` のみからなる長さ $ N $ の文字列である
 
### Sample Explanation 1

石が置かれていないマスを `.` と表します。以下のようにして $ 4 $ 回の操作で目的の状態にすることができ、これが最小回数です。 - `BWBWBW..` - `BW..BWBW` - `BWWBB..W` - `..WBBBWW` - `WWWBBB..`

## 样例 #1

### 输入

```
6

BWBWBW

WWWBBB```

### 输出

```
4```

## 样例 #2

### 输入

```
6

BBBBBB

WWWWWW```

### 输出

```
-1```

## 样例 #3

### 输入

```
14

BBBWBWWWBBWWBW

WBWWBBWWWBWBBB```

### 输出

```
7```

# AI分析结果

### 题目内容重写

#### [ABC361D] Go Stone Puzzle

**题目描述**

有 $N+2$ 个格子排成一行。从左到右第 $i$ 个格子称为格子 $i$。

格子 $1$ 到格子 $N$ 中每个格子都放有一个石头。  
对于每个 $1 \leq i \leq N$，如果 $S_i$ 是 `W`，则格子 $i$ 中的石头是白色的；如果 $S_i$ 是 `B`，则格子 $i$ 中的石头是黑色的。  
格子 $N+1$ 和 $N+2$ 是空的。

你可以执行以下操作任意次数（包括零次）：

- 选择两个相邻且都有石头的格子，将这两个石头按顺序移动到两个相邻的空格子中。  
  更准确地说，选择一个整数 $x$，满足 $1 \leq x \leq N+1$，且格子 $x$ 和 $x+1$ 中都有石头。设 $k$ 和 $k+1$ 是两个相邻的空格子。将格子 $x$ 和 $x+1$ 中的石头分别移动到格子 $k$ 和 $k+1$ 中。

判断是否可以达到以下状态，如果可以，求所需的最小操作次数：

- 格子 $1$ 到格子 $N$ 中每个格子都放有一个石头，且对于每个 $1 \leq i \leq N$，如果 $T_i$ 是 `W`，则格子 $i$ 中的石头是白色的；如果 $T_i$ 是 `B`，则格子 $i$ 中的石头是黑色的。

**说明/提示**

**约束条件**

- $2 \leq N \leq 14$
- $N$ 是整数
- $S$ 和 $T$ 是由 `B` 和 `W` 组成的长度为 $N$ 的字符串

**样例解释 1**

空格子用 `.` 表示。以下是通过 4 次操作达到目标状态的过程，且这是最小操作次数：  
- `BWBWBW..`  
- `BW..BWBW`  
- `BWWBB..W`  
- `..WBBBWW`  
- `WWWBBB..`

**样例 #1**

**输入**

```
6

BWBWBW

WWWBBB
```

**输出**

```
4
```

**样例 #2**

**输入**

```
6

BBBBBB

WWWWWW
```

**输出**

```
-1
```

**样例 #3**

**输入**

```
14

BBBWBWWWBBWWBW

WBWWBBWWWBWBBB
```

**输出**

```
7
```

---

### 题解分析与结论

#### 综合分析

本题的核心是通过交换相邻的石头来达到目标状态，且要求最小操作次数。由于 $N$ 的范围较小（$2 \leq N \leq 14$），大多数题解都采用了广度优先搜索（BFS）来遍历所有可能的状态，并通过记忆化（如 `unordered_map` 或 `map`）来避免重复访问。

#### 关键思路与技巧

1. **状态表示**：使用字符串或三进制数表示当前状态，其中 `B`、`W` 和 `.` 分别表示黑色石头、白色石头和空位。
2. **BFS 优化**：通过 BFS 保证首次到达目标状态时的步数是最小的，且通过记忆化避免重复访问。
3. **状态转移**：每次操作选择两个相邻的石头，将其移动到两个相邻的空位中，生成新的状态。
4. **剪枝与优化**：在 BFS 过程中，可以通过提前判断某些状态是否可能达到目标状态来剪枝，减少搜索空间。

#### 评分较高的题解

1. **作者：shangruolin（5星）**
   - **亮点**：使用 BFS 和 `unordered_map` 进行记忆化，代码简洁且高效。
   - **关键代码**：
     ```cpp
     queue <T> q;
     q.push (MT (0, n + 1, a)); mp[a] = 1;
     while (!q.empty ()) {
         int x = get <0> (q.front ()), y = get <1> (q.front ());
         string s = get <2> (q.front ()); q.pop ();
         if (s == b) return cout << x, 0;
         for (int i = 1; i <= n + 1; i++) {
             if (s[i] != '#' && s[i + 1] != '#') {
                 swap (s[i], s[y]);
                 swap (s[i + 1], s[y + 1]);
                 if (!mp[s]) {
                     mp[s] = 1;
                     q.push (MT (x + 1, i, s));
                 }
                 swap (s[i], s[y]);
                 swap (s[i + 1], s[y + 1]);
             }
         }
     }
     ```

2. **作者：include13_fAKe（4星）**
   - **亮点**：使用状态压缩和三进制数表示状态，BFS 实现较为清晰。
   - **关键代码**：
     ```cpp
     for (int j = 0; j <= (1 << (n + 2)) - 1; j++) {
         if (check(j) == c) w.push_back(j);
     }
     ```

3. **作者：Ivan422（4星）**
   - **亮点**：使用 BFS 和 `map` 进行记忆化，代码简洁且易于理解。
   - **关键代码**：
     ```cpp
     queue<no>q;
     q.push({s,0});
     mp[s]=1;
     while(!q.empty()){
         string ss=q.front().ss;
         int ans=q.front().ans;
         q.pop();
         if(ss==t){
             cout<<ans;
             return 0;
         }
         int tt=0;
         for(int i=0;i<ss.size()-1;i++){
             if(ss[i]=='.'&&ss[i+1]=='.'){
                 tt=i;
                 break;
             }
         }
         for(int i=0;i<ss.size()-1;i++){
             if(ss[i]!='.'&&ss[i+1]!='.'){
                 swap(ss[i],ss[tt]);
                 swap(ss[i+1],ss[tt+1]);
                 if(!mp[ss]){mp[ss]=1;q.push({ss,ans+1});}
                 swap(ss[i],ss[tt]);
                 swap(ss[i+1],ss[tt+1]);
             }
         }
     }
     ```

#### 拓展思路

1. **状态压缩**：对于更大的 $N$，可以考虑使用更高效的状态压缩方法，如位运算。
2. **A* 算法**：在 BFS 的基础上引入启发式函数，进一步优化搜索效率。
3. **双向 BFS**：从初始状态和目标状态同时进行 BFS，减少搜索空间。

#### 推荐题目

1. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)
2. [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)
3. [P2324 [SCOI2005] 骑士精神](https://www.luogu.com.cn/problem/P2324)

---
处理用时：55.76秒
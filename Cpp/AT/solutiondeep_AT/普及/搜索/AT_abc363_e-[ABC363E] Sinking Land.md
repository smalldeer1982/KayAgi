# 题目信息

# [ABC363E] Sinking Land

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_e

$ H\ \times\ W $ の大きさの島があり、島は周りを海で囲まれています。  
 島は 縦 $ H $ 個 $ \times $ 横 $ W $ 個の $ 1\times\ 1 $ の区画に分けられており、上から $ i $ 番目かつ左から $ j $ 番目の区画の（現在の海面を基準にした）標高は $ A_{i,j} $ です。

現在から $ 1 $ 年ごとに海面の高さが $ 1 $ ずつ上昇します。  
 このとき、海または海に沈んだ区画に上下左右に隣接する区画であって、標高が海面の高さ **以下** の区画は海に沈みます。  
 ここで、ある区画が新しく海に沈んだときそれと上下左右に隣接する区画であって海面の高さ以下のものも同時に海に沈み、これによって新しく沈んだ区画についてもこれは繰り返されます。

$ i=1,2,\ldots,\ Y $ それぞれについて、現在から $ i $ 年後に、島のうち海に沈まず残っている部分の面積を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ 1\leq\ Y\leq\ 10^5 $
- $ 1\leq\ A_{i,j}\leq\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

島の上から $ i $ 番目かつ左から $ j $ 番目の区画を $ (i,j) $ で表します。このとき、次のようになります。 - $ 1 $ 年後、海面は現在より $ 1 $ 上昇しますが、海に面している標高 $ 1 $ の区画は存在しないため、どの区画も沈みません。よって、$ 1 $ 行目には $ 9 $ を出力します。 - $ 2 $ 年後、海面は現在より $ 2 $ 上昇し、$ (1,2) $ が海に沈みます。これによって、$ (2,2) $ は海に沈んだ区画に隣接する区画となりますが、その標高は $ 2 $ 以下であるため、これも海に沈みます。これら以外にこの時点で他に沈む区画はありません。よって、$ 2 $ つの区画が沈むため、$ 2 $ 行目には $ 9-2=7 $ を出力します。 - $ 3 $ 年後、海面は現在より $ 3 $ 上昇し、$ (2,1) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 3 $ 行目には $ 6 $ を出力します。 - $ 4 $ 年後、海面は現在より $ 4 $ 上昇し、$ (2,3) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 4 $ 行目には $ 5 $ を出力します。 - $ 5 $ 年後、海面は現在より $ 5 $ 上昇し、$ (3,2) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 5 $ 行目には $ 4 $ を出力します。 よって、$ 9,7,6,5,4 $ をこの順に各行に出力します。

## 样例 #1

### 输入

```
3 3 5

10 2 10

3 1 4

10 5 10```

### 输出

```
9

7

6

5

4```

## 样例 #2

### 输入

```
3 5 3

2 2 3 3 3

2 1 2 1 3

2 2 3 3 3```

### 输出

```
15

7

0```

# AI分析结果

### 题目内容重写
**题目描述**  
有一个大小为 $H \times W$ 的岛屿，岛屿被海包围。岛屿被划分为 $H$ 行 $W$ 列的 $1 \times 1$ 的区画，从上到下第 $i$ 行、从左到右第 $j$ 列的区画的标高为 $A_{i,j}$。

从现在开始，每年海平面上升 $1$ 单位。当海平面上升时，与海或已经沉没的区画相邻（上下左右）且标高小于等于海平面高度的区画也会沉没。当一个区画沉没时，与其相邻且标高小于等于海平面高度的区画也会同时沉没，这个过程会一直重复。

对于 $i=1,2,\ldots,Y$，分别求出从现在开始 $i$ 年后，岛屿中未被淹没的区画的面积。

### 题解分析与结论

#### 综合分析
本题的核心在于模拟海平面上升过程中岛屿的沉没过程。由于海平面每年上升 $1$ 单位，且沉没过程具有连锁反应，因此需要高效地处理每年沉没的区画。大多数题解采用了优先队列（小根堆）来维护当前可能沉没的区画，并按海拔从小到大进行处理。这样可以确保每次处理的是当前最低的区画，避免重复计算。

#### 最优关键思路
1. **优先队列的使用**：通过优先队列维护当前可能沉没的区画，按海拔从小到大处理，确保每次处理的是最低的区画。
2. **BFS/DFS扩展**：当一个区画沉没后，通过BFS或DFS扩展其相邻的区画，判断它们是否也会沉没。
3. **时间复杂度优化**：由于每个区画只会被处理一次，时间复杂度为 $O(HW \log HW)$，能够处理最大规模的数据。

#### 推荐题解
1. **作者：cqbzcjh (赞：8)**  
   - **星级**：5星  
   - **关键亮点**：使用优先队列和BFS，代码简洁且高效，处理了所有边界情况。  
   - **核心代码**：
     ```cpp
     priority_queue<node> q;
     for(int i=1;i<=h;i++){
         for(int j=1;j<=w;j++){
             cin>>a[i][j];
             if((i==1)||(i==h)||(j==1)||(j==w)){
                 vis[i][j]=true;
                 q.push({a[i][j],i,j});
             }
         }
     }
     ans=h*w;
     for(int i=1;i<=y;i++){
         while(!q.empty()&&q.top().v<=i){
             node u=q.top();
             q.pop();
             ans--;
             for(int j=0;j<4;j++){
                 int tx=u.x+dx[j];
                 int ty=u.y+dy[j];
                 if(tx>=1&&tx<=h&&ty>=1&&ty<=w&&!vis[tx][ty]){
                     vis[tx][ty]=true;
                     q.push({a[tx][ty],tx,ty});
                 }
             }
         }
         cout<<ans<<"\n";
     }
     ```

2. **作者：Crsuh2er0 (赞：4)**  
   - **星级**：4星  
   - **关键亮点**：使用优先队列和DFS，处理了边界情况，代码清晰。  
   - **核心代码**：
     ```cpp
     priority_queue<edge, basic_string<edge>, greater<edge> > q;
     for(int i=1;i<=w;i++) q.push({1,i}), q.push({h,i});
     for(int i=2;i<h;i++) q.push({i,1}), q.push({i,w});
     for(int i=1;i<=t;i++, a[h+1][w+1]++) {
         while(q.size() && a[h+1][w+1] >= a[q.top().x][q.top().y]) {
             int tmpx = q.top().x, tmpy = q.top().y;
             q.pop();
             dfs(tmpx, tmpy);
         }
         cout<<ans<<'\n';
     }
     ```

3. **作者：joe_zxq (赞：2)**  
   - **星级**：4星  
   - **关键亮点**：使用set维护临海区画，思路独特，代码实现较为复杂但优化了时间复杂度。  
   - **核心代码**：
     ```cpp
     set<node> s;
     for(int i=1;i<=n;i++){
         for(int j=1;j<=m;j++){
             int ff = 1000000;
             if(i==1||j==1||i==n||j==m) ff = 1;
             s.insert({c[i][j],ff,i,j});
         }
     }
     for(int i=1;i<=k;i++){
         node nw = *s.begin();
         while(nw.h<=i&&nw.f==1){
             s.erase(s.begin());
             del(nw.x-1,nw.y);
             del(nw.x+1,nw.y);
             del(nw.x,nw.y-1);
             del(nw.x,nw.y+1);
             nw = *s.begin();
         }
         printf("%d\n",s.size());
     }
     ```

### 扩展思路与推荐题目
1. **扩展思路**：本题可以扩展到三维空间，模拟水位上升对三维地形的影响，或者扩展到动态水位变化的情况。
2. **推荐题目**：
   - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：考察BFS的应用。
   - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：考察泛洪填充算法。
   - [P1131 最小生成树](https://www.luogu.com.cn/problem/P1131)：考察优先队列和最小生成树算法。

### 个人心得总结
- **调试经历**：在处理边界情况时，容易忽略某些特殊情况（如岛屿只有一行或一列），需要仔细检查。
- **顿悟感想**：优先队列的使用是本题的关键，能够有效减少重复计算，提升算法效率。

---
处理用时：50.84秒
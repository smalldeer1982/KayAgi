# 题目信息

# [ABC368D] Minimum Steiner Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc368/tasks/abc368_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の木が与えられます。$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。

このグラフからいくつかの($ 0 $ 個でもよい)辺と頂点を削除してできる木のうち、指定された $ K $ 個の頂点、頂点 $ V_1,\ldots,V_K $ を全て含むようなものの頂点数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ 1\ \leq\ V_1\ <\ V_2\ <\ \ldots\ <\ V_K\ \leq\ N $
- 与えられるグラフは木である
- 入力は全て整数

### Sample Explanation 1

与えられた木は下図左の通りであり、そこからいくつかの辺と頂点を削除してできる木のうち頂点 $ 1,3,5 $ を全て含むような頂点数最小のものは下図右の通りです。 
![図](https://img.atcoder.jp/abc368/4baf6b0adb0e12dcf8a5c812ada5c17a.png)

## 样例 #1

### 输入

```
7 3
1 2
1 3
2 4
2 5
3 6
3 7
1 3 5```

### 输出

```
4```

## 样例 #2

### 输入

```
4 4
3 1
1 4
2 1
1 2 3 4```

### 输出

```
4```

## 样例 #3

### 输入

```
5 1
1 4
2 3
5 2
1 2
1```

### 输出

```
1```

# AI分析结果

### 题目内容重写
【题目描述】  
给定一棵有 $N$ 个节点的树，节点编号从 $1$ 到 $N$。第 $i$ 条边连接节点 $A_i$ 和 $B_i$。你需要从这棵树中删除一些边和节点（可以删除 $0$ 个），使得剩下的树包含所有指定的 $K$ 个节点 $V_1, V_2, \ldots, V_K$，并且剩下的树的节点数最小。输出这个最小节点数。

【输入格式】  
第一行包含两个整数 $N$ 和 $K$，表示树的节点数和指定的节点数。  
接下来 $N-1$ 行，每行包含两个整数 $A_i$ 和 $B_i$，表示一条边。  
最后一行包含 $K$ 个整数 $V_1, V_2, \ldots, V_K$，表示指定的节点。

【输出格式】  
输出一个整数，表示包含所有指定节点的最小树的节点数。

【样例输入 1】  
```
7 3
1 2
1 3
2 4
2 5
3 6
3 7
1 3 5
```

【样例输出 1】  
```
4
```

【样例输入 2】  
```
4 4
3 1
1 4
2 1
1 2 3 4
```

【样例输出 2】  
```
4
```

【样例输入 3】  
```
5 1
1 4
2 3
5 2
1 2
1
```

【样例输出 3】  
```
1
```

### 综合分析与结论
本题的核心是找到包含所有指定节点的最小子树。由于树的性质，两点之间只有一条路径，因此可以通过遍历树来确定哪些节点必须保留。大多数题解都采用了 DFS 或树形 DP 的思路，通过标记关键节点并回溯来确定哪些节点必须保留。以下是评分较高的题解及其亮点。

### 评分较高的题解

#### 题解1：作者：wo_hen_la (5星)
**关键亮点**：  
- 通过两遍 DFS 解决问题，第一遍标记有用节点，第二遍统计无用节点并减去其子树大小。
- 代码简洁，思路清晰，时间复杂度为 $O(N)$。

**核心代码**：
```cpp
void dfs(int u,int fa)
{
	if(vis[u]) vv[u]=1;
	siz[u]=1;
	for(auto v:e[u]){
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		vv[u]|=vv[v];
	}
}
void dfs2(int u,int fa)
{
	for(auto v:e[u]){
		if(v==fa) continue;
		if(!vv[v]){
			ans-=siz[v];
			continue;
		}
		dfs2(v,u);
	}
}
```
**实现思想**：  
第一遍 DFS 计算子树大小并标记有用节点，第二遍 DFS 减去无用节点的子树大小。

#### 题解2：作者：yx666 (4星)
**关键亮点**：  
- 使用重链剖分找到关键节点的最近公共祖先（LCA），并以 LCA 为根进行 DFS 染色，统计答案。
- 时间复杂度为 $O(K \log N)$，适合较大数据范围。

**核心代码**：
```cpp
int LCA(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) x^=y^=x^=y;
		x=fa[top[x]];
	}
	return dep[x]>dep[y]?x:y;
}
void dfs3(int x,int fa){
	if(tar[x]) vis[x]=1,++ans;
	for(int i=head[x];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(to==fa) continue;
		dfs3(to,x);
		if(vis[to]&&!vis[x]) vis[x]=1,++ans;
	}
}
```
**实现思想**：  
通过重链剖分找到 LCA，然后以 LCA 为根进行 DFS 染色，统计必须保留的节点数。

#### 题解3：作者：wuyixiang (4星)
**关键亮点**：  
- 通过一次 DFS 解决问题，统计每个节点的子树中是否包含关键节点，并据此决定是否保留该节点。
- 时间复杂度为 $O(N)$，代码简洁。

**核心代码**：
```cpp
int dfs(int x,int fa)
{
  int ans = a[x];
  for(int i = 0;i < ve[x].size();i ++)
  {
    if(ve[x][i] == fa)continue ;
    int num = dfs(ve[x][i],x);
    ans += num;
    if(num && !a[ve[x][i]])m ++;
  }
  return ans;
}
```
**实现思想**：  
通过一次 DFS 统计每个节点的子树中是否包含关键节点，并据此决定是否保留该节点。

### 最优关键思路与技巧
1. **DFS 标记与回溯**：通过 DFS 标记关键节点及其路径上的节点，回溯时统计必须保留的节点数。
2. **重链剖分与 LCA**：通过重链剖分找到关键节点的 LCA，并以 LCA 为根进行 DFS，确保路径上的节点被正确保留。
3. **子树统计**：通过统计每个节点的子树中是否包含关键节点，决定是否保留该节点。

### 可拓展之处
1. **类似问题**：类似的问题可以扩展到图中，寻找包含指定节点的最小连通子图。
2. **优化思路**：可以结合并查集或 Tarjan 算法进一步优化路径查找和节点保留的统计。

### 推荐题目
1. [P10723 - 最小生成树](https://www.luogu.com.cn/problem/P10723)
2. [P3384 - 重链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3379 - 最近公共祖先](https://www.luogu.com.cn/problem/P3379)

### 个人心得摘录
- **调试经历**：在实现 DFS 时，需要注意回溯时的条件判断，避免重复统计或遗漏节点。
- **踩坑教训**：选择根节点时，应确保根节点是关键节点之一，否则可能导致错误结果。
- **顿悟感想**：通过两遍 DFS 分别统计子树大小和标记有用节点，能够有效减少代码复杂度并提高效率。

---
处理用时：53.97秒
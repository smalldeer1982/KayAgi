# 题目信息

# [ABC373D] Hidden Weights

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc373/tasks/abc373_d

$ N $ 頂点 $ M $ 辺の有向グラフが与えられます。$ j $ 番目の有向辺は頂点 $ u_j $ から頂点 $ v_j $ に向かっており、重み $ w_j $ を持っています。

各頂点に $ -10^{18} $ 以上 $ 10^{18} $ 以下の整数を書き込む方法であって、次の条件を満たすものを $ 1 $ つ見つけてください。

- 頂点 $ i $ に書き込まれている値を $ x_i $ とする。すべての辺 $ j=1,2,\dots,M $ について、$ x_{v_j}\ -\ x_{u_j}\ =\ w_j $ が成り立つ。

与えられる入力について、条件を満たす書き込み方が少なくとも $ 1 $ つ存在することが保証されます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\{2\ \times\ 10^5,N(N-1)/2\} $
- $ 1\ \leq\ u_j,\ v_j\ \leq\ N $
- $ u_j\ \neq\ v_j $
- $ i\ \neq\ j $ なら $ (u_i,v_i)\ \neq\ (u_j,v_j) $ かつ $ (u_i,v_i)\ \neq\ (v_j,u_j) $
- $ |w_j|\ \leq\ 10^9 $
- 入力はすべて整数
- 条件を満たす書き込み方が少なくとも $ 1 $ つ存在する

### Sample Explanation 1

$ x=(3,5,2) $ とすることで、$ x_2-x_1=w_1=2,x_2-x_3=w_2=3,x_3-x_1=w_3=-1 $ となり、条件を満たします。 他にも、たとえば $ x=(-1,1,-2) $ としても正解となります。

### Sample Explanation 2

他にも、たとえば $ x=(0,-5,4,1) $ や $ x=(5,0,4,1) $ としても正解となります。

## 样例 #1

### 输入

```
3 3
1 2 2
3 2 3
1 3 -1```

### 输出

```
3 5 2```

## 样例 #2

### 输入

```
4 2
2 1 5
3 4 -3```

### 输出

```
5 0 6 3```

## 样例 #3

### 输入

```
5 7
2 1 18169343
3 1 307110901
4 1 130955934
2 3 -288941558
2 5 96267410
5 3 -385208968
4 3 -176154967```

### 输出

```
200401298 182231955 -106709603 69445364 278499365```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个包含 $N$ 个顶点和 $M$ 条边的有向图。第 $j$ 条有向边从顶点 $u_j$ 指向顶点 $v_j$，并且具有权重 $w_j$。

要求为每个顶点分配一个 $-10^{18}$ 到 $10^{18}$ 之间的整数值，记为 $x_i$，满足对于所有边 $j=1,2,\dots,M$，都有 $x_{v_j} - x_{u_j} = w_j$。

题目保证至少存在一种满足条件的赋值方案。

#### 输入格式

第一行包含两个整数 $N$ 和 $M$，分别表示顶点数和边数。

接下来 $M$ 行，每行包含三个整数 $u_j$, $v_j$, $w_j$，表示一条从 $u_j$ 到 $v_j$ 的边，权重为 $w_j$。

#### 输出格式

输出一行，包含 $N$ 个整数，表示每个顶点的赋值 $x_1, x_2, \dots, x_N$。

#### 样例

**样例 1**

输入：
```
3 3
1 2 2
3 2 3
1 3 -1
```

输出：
```
3 5 2
```

**样例 2**

输入：
```
4 2
2 1 5
3 4 -3
```

输出：
```
5 0 6 3
```

#### 数据范围

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq M \leq \min\{2 \times 10^5, N(N-1)/2\}$
- $1 \leq u_j, v_j \leq N$
- $u_j \neq v_j$
- $i \neq j$ 时，$(u_i, v_i) \neq (u_j, v_j)$ 且 $(u_i, v_i) \neq (v_j, u_j)$
- $|w_j| \leq 10^9$
- 输入均为整数
- 保证至少存在一种满足条件的赋值方案

---

### 题解分析与结论

#### 综合分析

该题的核心在于通过图的遍历（如 BFS 或 DFS）为每个顶点赋值，使得所有边的权重条件 $x_{v_j} - x_{u_j} = w_j$ 得到满足。由于题目保证有解，因此可以通过以下步骤解决：

1. **双向建边**：由于 $x_{v_j} - x_{u_j} = w_j$ 等价于 $x_{u_j} - x_{v_j} = -w_j$，因此需要为每条边建立反向边，权重取负。
2. **图的遍历**：从任意未访问的顶点开始，使用 BFS 或 DFS 遍历整个连通块，依次为每个顶点赋值。
3. **初始赋值**：每个连通块的起始顶点可以赋值为 $0$，然后根据边的权重条件依次推导其他顶点的值。

#### 最优思路与技巧

- **双向建边**：通过为每条边建立反向边，确保图的连通性，避免因有向边导致的遍历不完整。
- **图的遍历**：使用 BFS 或 DFS 遍历图，确保每个连通块内的顶点都能被正确赋值。
- **初始赋值**：每个连通块的起始顶点赋值为 $0$，简化推导过程。

#### 推荐题目

1. [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
2. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)
3. [P2863 [USACO06DEC]The Cow Prom S](https://www.luogu.com.cn/problem/P2863)

---

### 高星题解展示

#### 题解 1：ikunTLE (5星)

**关键亮点**：
- 使用 BFS 进行图的遍历，确保每个连通块内的顶点都能被正确赋值。
- 双向建边，确保图的连通性。
- 代码简洁，注释清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;++i){
    if(vis[i]) continue;
    queue<int> q;
    q.push(i), vis[i]=true;
    while(!q.empty()){
        int u=q.front();
        for(auto i:vc[u])
            if(!vis[i.v]){
                vis[i.v]=true;
                ans[i.v]=ans[u]+i.w;
                q.push(i.v);
            }
        q.pop();
    }
}
```

#### 题解 2：SkyWave (5星)

**关键亮点**：
- 使用 BFS 进行图的遍历，确保每个连通块内的顶点都能被正确赋值。
- 双向建边，确保图的连通性。
- 代码简洁，注释清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;++i) if(!vis[i]){
    int front=1, rear=0;
    vis[que[++rear]=i]=true;
    while(front<=rear){
        int u=que[front++];
        for(auto [v,w]:graph[u]) if(!vis[v]){
            x[v]=x[u]+w;
            vis[que[++rear]=v]=true;
        }
    }
}
```

#### 题解 3：gavinliu266 (5星)

**关键亮点**：
- 使用 BFS 进行图的遍历，确保每个连通块内的顶点都能被正确赋值。
- 双向建边，确保图的连通性。
- 代码简洁，注释清晰。

**核心代码**：
```cpp
for(int i=1;i<=n;++i){
    if(vis[i]) continue;
    vis[i]=true;
    queue<int> q;
    q.push(i);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(auto p:ed[u])
            if(!vis[p.v]){
                vis[p.v]=1;
                x[p.v]=x[u]+p.w;
                q.push(p.v);
            }
    }
}
```

---

### 个人心得总结

- **双向建边的重要性**：通过为每条边建立反向边，确保图的连通性，避免因有向边导致的遍历不完整。
- **初始赋值的简化**：每个连通块的起始顶点赋值为 $0$，简化推导过程，确保代码的简洁性。
- **图的遍历选择**：BFS 和 DFS 都可以用于图的遍历，选择哪种方式取决于具体问题和代码实现的方便性。

---
处理用时：54.91秒
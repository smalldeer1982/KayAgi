# 题目信息

# [ABC376D] Cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点 $ M $ 辺の単純有向グラフがあります。$ i $ 番目の辺 $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ a_i $ から頂点 $ b_i $ へ伸びる辺です。  
 頂点 $ 1 $ を含む閉路が存在するか判定して、存在する場合はそのような閉路のうち辺数が最小の閉路の辺数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\ \left(\ \frac{N(N-1)}{2},\ 2\ \times\ 10^5\ \right) $
- $ 1\ \leq\ a_i\ \leq\ N $
- $ 1\ \leq\ b_i\ \leq\ N $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ かつ $ (a_i,\ b_i)\ \neq\ (b_j,\ a_j) $
- 入力される値は全て整数
 
### Sample Explanation 1

頂点 $ 1 $ $ \to $ 頂点 $ 2 $ $ \to $ 頂点 $ 3 $ $ \to $ 頂点 $ 1 $ は辺数が $ 3 $ の閉路で、これが頂点 $ 1 $ を含む唯一の閉路です。

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2

1 2

2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 9

6 1

1 5

2 6

2 1

3 6

4 2

6 4

3 5

5 4```

### 输出

```
4```

# AI分析结果

### 题目翻译

#### [ABC376D] Cycle

**题目描述**

给定一个有向图，顶点编号从 $1$ 到 $N$，共有 $M$ 条边。第 $i$ 条边 $(1 \leq i \leq M)$ 从顶点 $a_i$ 指向顶点 $b_i$。请判断是否存在包含顶点 $1$ 的环，如果存在，输出其中边数最少的环的边数。

**说明/提示**

**约束条件**

- $2 \leq N \leq 2 \times 10^5$
- $1 \leq M \leq \min\left(\frac{N(N-1)}{2}, 2 \times 10^5\right)$
- $1 \leq a_i \leq N$
- $1 \leq b_i \leq N$
- $a_i \neq b_i$
- $i \neq j$ 时，$(a_i, b_i) \neq (a_j, b_j)$ 且 $(a_i, b_i) \neq (b_j, a_j)$
- 输入的所有值均为整数

**样例解释 1**

顶点 $1 \to 2 \to 3 \to 1$ 是一个边数为 $3$ 的环，这是包含顶点 $1$ 的唯一环。

**样例 #1**

**输入**

```
3 3
1 2
2 3
3 1
```

**输出**

```
3
```

**样例 #2**

**输入**

```
3 2
1 2
2 3
```

**输出**

```
-1
```

**样例 #3**

**输入**

```
6 9
6 1
1 5
2 6
2 1
3 6
4 2
6 4
3 5
5 4
```

**输出**

```
4
```

### 题解分析与结论

#### 综合分析

本题要求在有向图中找到包含顶点 $1$ 的最小环。由于图是有向的，且顶点和边的数量都可能很大（$N, M \leq 2 \times 10^5$），因此需要高效的算法来解决这个问题。

大多数题解都采用了 **BFS（广度优先搜索）** 或 **Dijkstra** 算法来求解最短路径，进而找到最小环。BFS 适用于边权为 $1$ 的图，而 Dijkstra 可以处理更一般的边权情况。由于本题边权为 $1$，BFS 是更优的选择。

#### 关键思路与技巧

1. **BFS 求最短路径**：从顶点 $1$ 开始进行 BFS，记录每个顶点到 $1$ 的最短路径。当某个顶点的邻接顶点是 $1$ 时，说明找到了一个环，其长度为当前路径长度加 $1$。
2. **避免重复访问**：使用 `vis` 数组标记已访问的顶点，避免重复访问，确保 BFS 的正确性。
3. **最小环的判定**：在 BFS 过程中，第一个找到的回到 $1$ 的路径即为最小环。

#### 推荐题解

1. **作者：Heldivis**  
   **星级：4.5**  
   **关键亮点**：思路清晰，直接使用 BFS 从 $1$ 号点出发，找到回到 $1$ 的最短路径，代码简洁且高效。  
   **代码片段**：
   ```cpp
   queue<int> q;
   memset(d, 0x3f, sizeof d);
   for (int y : e[1]) q.push(y), d[y] = 1;
   while (q.size()) {
       int x = q.front();
       q.pop();
       for (int y : e[x])
           if (d[y] > d[x] + 1) d[y] = d[x] + 1, q.push(y);
   }
   if (d[1] >= 1E9) d[1] = -1;
   printf("%d\n", d[1]);
   ```

2. **作者：chenxi2009**  
   **星级：4**  
   **关键亮点**：使用 BFS 并记录路径长度，代码结构清晰，适合初学者理解。  
   **代码片段**：
   ```cpp
   q.push(make_pair(0,1));
   while(q.size() && ans == -1){
       int w = q.front().first, u = q.front().second;
       q.pop();
       for(int i = 0; i < e[u].size(); i ++){
           int v = e[u][i];
           if(v == 1){
               ans = w + 1;
               break;
           }
           if(arr[v]) continue;
           arr[v] = true;
           q.push(make_pair(w + 1,v));
       }
   }
   ```

3. **作者：Anins**  
   **星级：4**  
   **关键亮点**：使用 BFS 并记录距离，代码简洁，适合快速实现。  
   **代码片段**：
   ```cpp
   dis[1]=0;
   q.push(1);
   while(!q.empty()) {
       ll u=q.front();
       q.pop();
       for(auto v:e[u]) {
           if(dis[v]==-1) {
               dis[v]=dis[u]+1;
               q.push(v); 
           } else if(v==1) {
               ans=min(ans, dis[u]+1);
           }
       }
   }
   ```

### 扩展思路与推荐题目

#### 扩展思路

- **Dijkstra 算法**：如果边权不为 $1$，可以使用 Dijkstra 算法来求解最短路径。
- **双向 BFS**：对于较大的图，可以考虑使用双向 BFS 来加速搜索过程。
- **Tarjan 算法**：如果需要找到所有环，可以使用 Tarjan 算法进行强连通分量的分解。

#### 推荐题目

1. **P2661 [NOIP2015 提高组] 信息传递**  
   题目链接：[https://www.luogu.com.cn/problem/P2661](https://www.luogu.com.cn/problem/P2661)  
   考察知识点：有向图中的最小环。

2. **P3371 【模板】单源最短路径（弱化版）**  
   题目链接：[https://www.luogu.com.cn/problem/P3371](https://www.luogu.com.cn/problem/P3371)  
   考察知识点：最短路径算法（Dijkstra、SPFA）。

3. **P3385 【模板】负环**  
   题目链接：[https://www.luogu.com.cn/problem/P3385](https://www.luogu.com.cn/problem/P3385)  
   考察知识点：负环检测（Bellman-Ford、SPFA）。

### 个人心得总结

- **调试经验**：在实现 BFS 时，务必注意 `vis` 数组的正确使用，避免重复访问导致死循环或错误结果。
- **优化技巧**：对于边权为 $1$ 的图，BFS 是最优选择，代码实现简单且效率高。
- **思维突破**：将问题转化为最短路径问题，能够简化思路并提高解题效率。

---
处理用时：58.19秒
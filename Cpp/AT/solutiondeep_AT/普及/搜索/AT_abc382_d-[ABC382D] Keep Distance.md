# 题目信息

# [ABC382D] Keep Distance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_d

整数 $ N $ と $ M $ が与えられます。

以下の条件をすべて満たす長さ $ N $ の整数列 $ (A_1,\ A_2,\ \ldots,\ A_N) $ を辞書順にすべて出力してください。

- $ 1\ \leq\ A_i $
- $ 2 $ 以上 $ N $ 以下の各整数 $ i $ に対して $ A_{i\ -\ 1}\ +\ 10\ \leq\ A_i $
- $ A_N\ \leq\ M $
 
  数列の辞書順とは長さ $ N $ の数列 $ S\ =\ (S_1,\ S_2,\ \ldots,\ S_N) $ が長さ $ N $ の数列 $ T\ =\ (T_1,\ T_2,\ \ldots,\ T_N) $ より**辞書順で小さい**とは、ある整数 $ 1\ \leq\ i\ \leq\ N $ が存在して下記の $ 2 $ つがともに成り立つことをいいます。

- $ (S_1,\ S_2,\ \ldots,\ S_{i-1})\ =\ (T_1,\ T_2,\ \ldots,\ T_{i-1}) $
- $ S_i $ が $ T_i $ より（数として）小さい。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 12 $
- $ 10N\ -\ 9\ \leq\ M\ \leq\ 10N $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (1,\ 11,\ 21),\ (1,\ 11,\ 22),\ (1,\ 11,\ 23),\ (1,\ 12,\ 22),\ (1,\ 12,\ 23),\ (1,\ 13,\ 23),\ (2,\ 12,\ 22),\ (2,\ 12,\ 23),\ (2,\ 13,\ 23),\ (3,\ 13,\ 23) $ の $ 10 $ 個の数列が条件を満たします。

## 样例 #1

### 输入

```
3 23```

### 输出

```
10

1 11 21

1 11 22

1 11 23

1 12 22

1 12 23

1 13 23

2 12 22

2 12 23

2 13 23

3 13 23```

# AI分析结果

### 题目内容重写

给定整数 $N$ 和 $M$，构造一个长度为 $N$ 的整数序列 $A_1, A_2, \ldots, A_N$，满足以下条件：

1. $1 \leq A_i$；
2. 对于每个 $2 \leq i \leq N$，有 $A_{i-1} + 10 \leq A_i$；
3. $A_N \leq M$。

要求按字典序输出所有满足条件的序列。

### 题解分析与结论

本题的核心是通过深度优先搜索（DFS）生成所有满足条件的序列，并通过剪枝优化避免超时。大多数题解都采用了类似的思路，即在DFS过程中，每次从当前元素加10开始枚举，并通过剪枝判断后续元素是否可能满足条件。以下是各题解的要点总结：

1. **DFS + 剪枝**：几乎所有题解都使用了DFS来生成序列，并通过剪枝（如判断后续元素的最小值是否超过 $M$）来优化性能。
2. **字典序输出**：由于DFS按从小到大的顺序枚举，生成的序列自然满足字典序要求。
3. **初始值设置**：部分题解提到初始值设置为 $-9$，以便第一位可以从1开始枚举。

### 评分较高的题解

#### 题解1：作者：_colin1112_（评分：5星）
- **关键亮点**：思路清晰，详细解释了每个位置的取值范围，并通过剪枝优化了DFS的性能。代码结构简洁，易于理解。
- **核心代码**：
```cpp
void dfs(int pos, vector<ll> &seq) {
    if (pos == n) {
        ans.push_back(seq);
        return;
    }
    ll l = (pos == 0) ? 1 : seq[pos - 1] + 10;
    ll r = m - 10 * (n - pos - 1);
    for (int i = l; i <= r; i++) {
        seq.push_back(i);
        dfs(pos + 1, seq);
        seq.pop_back();
    }
}
```
- **个人心得**：通过确定每个位置的取值范围，有效减少了不必要的枚举，提高了搜索效率。

#### 题解2：作者：ThomasNO1（评分：4星）
- **关键亮点**：代码简洁，剪枝逻辑清晰，通过初始化 $A_0$ 为 $-9$ 来简化第一位从1开始的枚举。
- **核心代码**：
```cpp
void dfs(int pos) {
    if (pos > n) {
        for (int i = 1; i <= n; i++) A.push_back(a[i]);
        ans++;
        A.push_back(-1);
        return;
    }
    if (a[pos - 1] + 10 * (n - pos) > m) return;
    for (int i = a[pos - 1] + 10; i <= m - 10 * (n - pos); i++) {
        a[pos] = i;
        dfs(pos + 1);
    }
}
```
- **个人心得**：通过剪枝避免了无效的搜索路径，显著提高了算法效率。

#### 题解3：作者：Zskioaert1106（评分：4星）
- **关键亮点**：通过枚举每一位的可能性，逐步缩小范围，并通过剪枝优化了搜索过程。
- **核心代码**：
```cpp
void dfs(int i, int d) {
    if (i > n) {
        sum++;
        for (int j = 1; j <= n; j++) ans[sum][j] = k[j];
    } else {
        for (int j = d; j + (n - i) * 10 <= m; j++) {
            k[i] = j;
            dfs(i + 1, j + 10);
        }
    }
}
```
- **个人心得**：通过剪枝和逐步枚举，确保了搜索的高效性和结果的正确性。

### 最优关键思路与技巧

1. **DFS + 剪枝**：通过DFS生成序列，并通过剪枝判断后续元素是否可能满足条件，避免无效搜索。
2. **字典序输出**：DFS按从小到大的顺序枚举，生成的序列自然满足字典序要求。
3. **初始值设置**：通过设置初始值（如 $A_0 = -9$）简化第一位从1开始的枚举。

### 可拓展之处

- **类似题目**：可以扩展到其他需要生成满足特定条件的序列的题目，如生成递增序列、满足特定差值的序列等。
- **优化技巧**：剪枝技巧可以应用于其他搜索问题中，如回溯、动态规划等。

### 推荐题目

1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)
2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)
3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)

这些题目都涉及到通过DFS生成满足特定条件的序列或排列，适合进一步练习和巩固相关技巧。

---
处理用时：41.22秒
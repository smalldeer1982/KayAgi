# 题目信息

# [AGC033A] Darker and Darker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc033/tasks/agc033_a

縦 $ H $ 行、横 $ W $ 列の白黒に塗られたマス目が与えられます。 マス目の状態は $ A_{11} $ から $ A_{HW} $ の $ HW $ 個の文字で表されており、 上から $ i $ 行目、左から $ j $ 列目にあるマスが黒色のとき $ A_{ij} $ は `#`、 上から $ i $ 行目、左から $ j $ 列目にあるマスが白色のとき $ A_{ij} $ は `.` となっています。

すべてのマスが黒色になるまで、以下の操作を繰り返し行います。

- 辺を共有して隣接するマスの中に、黒色のマスが一つ以上存在するような白色のマスすべてが黒色になる。

何回の操作を行うことになるか求めてください。 ただし、最初に与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在します。

## 说明/提示

### 制約

- $ 1\ ≦\ H,W\ ≦\ 1000 $
- $ A_{ij} $ は `#` または `.`
- 与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在する。

### Sample Explanation 1

操作を一回行うとマス目の四隅以外が黒色になり、もう一度操作を行うとすべてのマス目が黒色になります。

## 样例 #1

### 输入

```
3 3

...

.#.

...```

### 输出

```
2```

## 样例 #2

### 输入

```
6 6

..#..#

......

#..#..

......

.#....

....#.```

### 输出

```
3```

# AI分析结果

### 题目内容重写
【题目描述】  
给定一个 $H$ 行 $W$ 列的黑白网格，网格中的每个格子用字符 `#` 表示黑色，`.` 表示白色。每次操作中，所有与黑色格子相邻的白色格子都会变成黑色。求最少需要多少次操作才能使整个网格变为全黑。初始网格中至少有一个黑色格子。

【输入格式】  
第一行输入两个整数 $H$ 和 $W$，表示网格的行数和列数。  
接下来 $H$ 行，每行输入一个长度为 $W$ 的字符串，表示网格的初始状态。

【输出格式】  
输出一个整数，表示使整个网格变为全黑所需的最少操作次数。

【样例输入1】  
```
3 3
...
.#.
...
```

【样例输出1】  
```
2
```

【样例输入2】  
```
6 6
..#..#
......
#..#..
......
.#....
....#.
```

【样例输出2】  
```
3
```

### 题解分析与结论
本题的核心是通过广度优先搜索（BFS）模拟黑色格子的扩散过程。所有题解均采用了 BFS 的思路，但实现细节有所不同。以下是各题解的对比与总结：

1. **BFS 模板化**：大多数题解直接套用 BFS 模板，将初始黑色格子入队，然后逐层扩散。  
2. **优化与细节**：部分题解通过标记数组或记录步数来优化搜索过程，避免重复访问。  
3. **代码可读性**：部分题解代码结构清晰，注释详细，便于理解；部分题解代码较为简洁，但缺乏注释。

### 评分较高的题解

#### 题解1：作者 Fijian_Bus (★★★★★)
**关键亮点**：  
- 使用 BFS 模板，代码结构清晰，注释详细。  
- 通过 `judge` 函数判断格子合法性，增强了代码的可读性。  
- 使用 `ans` 记录最大步数，直接输出结果。

**核心代码**：
```cpp
void BFS() {
    while(!q.empty()) {
        node pre = q.front();
        q.pop();
        ans = max(ans, pre.step);
        for(int i = 0; i < 4; i++) {
            int mx = dx[i] + pre.x;
            int my = dy[i] + pre.y;
            if(judge(mx, my) && mp[mx][my] == '.') {
                mp[mx][my] = '#';
                q.push(node{mx, my, pre.step + 1});
            }
        }
    }
}
```

#### 题解2：作者 Bpds1110 (★★★★☆)
**关键亮点**：  
- 使用 `dis` 数组记录每个格子被染黑的最小步数。  
- 通过 `vis` 数组避免重复访问，优化了搜索效率。  
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
while(!q.empty()) {
    int fx = q.front().x;
    int fy = q.front().y;
    ans = ans > dis[fx][fy] ? ans : dis[fx][fy];
    q.pop();
    for(int i = 0; i < 4; i++) {
        int sx = fx + e[i][0];
        int sy = fy + e[i][1];
        if(sx < 1 || sx > n || sy < 1 || sy > m) continue;
        if(vis[sx][sy]) continue;
        dis[sx][sy] = dis[fx][fy] + 1;
        vis[sx][sy] = 1;
        q.push({sx, sy});
    }
}
```

#### 题解3：作者 Texas_the_Omertosa (★★★★☆)
**关键亮点**：  
- 使用 `point` 结构体存储坐标和步数，代码结构清晰。  
- 通过 `ans` 记录最大步数，直接输出结果。  
- 代码简洁，注释较少但易于理解。

**核心代码**：
```cpp
void bfs() {
    while(!q.empty()) {
        point ch = q.front();
        q.pop();
        ans = max(ans, ch.step);
        for(int i = 1; i <= 4; i++) {
            int xx = ch.x + fx[i];
            int yy = ch.y + fy[i];
            if(xx < 1 || yy < 1 || xx > h || yy > k || a[xx][yy] == '#') continue;
            a[xx][yy] = '#';
            q.push(point{xx, yy, ch.step + 1});
        }
    }
}
```

### 最优关键思路与技巧
1. **BFS 模板化**：将初始黑色格子入队，逐层扩散，记录步数。  
2. **优化搜索效率**：通过标记数组避免重复访问，减少不必要的计算。  
3. **记录步数**：使用数组或变量记录每个格子被染黑的最小步数，便于输出结果。

### 拓展与举一反三
1. **类似题目**：  
   - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)  
   - P2895 [USACO08FEB]Meteor Shower S](https://www.luogu.com.cn/problem/P2895)  
   - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)  
2. **拓展思路**：  
   - 对于更复杂的扩散规则（如斜向扩散），可以扩展 BFS 的方向数组。  
   - 对于大规模数据，可以考虑使用多源 BFS 或双向 BFS 进一步优化。

---
处理用时：49.68秒
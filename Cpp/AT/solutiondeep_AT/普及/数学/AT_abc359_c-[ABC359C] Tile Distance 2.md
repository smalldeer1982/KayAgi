# 题目信息

# [ABC359C] Tile Distance 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc359/tasks/abc359_c

座標平面上に $ 2\times1 $ の大きさのタイルが敷き詰められています。 タイルは、次の規則に従って敷き詰められています。

- 整数の組 $ (i,j) $ に対し、正方形 $ A\ _\ {i,j}=\lbrace(x,y)\mid\ i\leq\ x\leq\ i+1\wedge\ j\leq\ y\leq\ j+1\rbrace $ は $ 1 $ つのタイルに含まれる。
- $ i+j $ が偶数のとき、$ A\ _\ {i,j} $ と $ A\ _\ {i\ +\ 1,j} $ は同じタイルに含まれる。
 
ただし、タイルは境界を含むものとし、共通部分が正の面積をもつような $ 2 $ つの異なるタイルは存在しないとします。

原点の近くでは、タイルは以下のように敷き詰められています。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc359_c/85986a05648888be0c6d0706034a45ff07ff8b7a.png)

高橋君は、はじめ座標平面上の点 $ (S\ _\ x+0.5,S\ _\ y+0.5) $ にいます。

高橋君は、次の移動を好きなだけ繰り返します。

- 上下左右の方向と正の整数 $ n $ を選ぶ。その方向に $ n $ だけ進む。
 
高橋君が異なるタイルを通るたび、高橋君は通行料を $ 1 $ だけ支払います。

高橋君が点 $ (T\ _\ x+0.5,T\ _\ y+0.5) $ にたどり着くために支払わなければならない通行料の最小値を求めてください。

## 说明/提示

### 制約

- $ 0\leq\ S\ _\ x\leq2\times10\ ^\ {16} $
- $ 0\leq\ S\ _\ y\leq2\times10\ ^\ {16} $
- $ 0\leq\ T\ _\ x\leq2\times10\ ^\ {16} $
- $ 0\leq\ T\ _\ y\leq2\times10\ ^\ {16} $
- 入力はすべて整数
 
### Sample Explanation 1

例えば、以下のように移動することで支払う通行料を $ 5 $ にすることができます。 !\[\](https://img.atcoder.jp/abc359/187d19c48a9a0fcedb2602063689ee77.png) - 左に $ 1 $ 進む。通行料を $ 0 $ 支払う。 - 上に $ 1 $ 進む。通行料を $ 1 $ 支払う。 - 左に $ 1 $ 進む。通行料を $ 0 $ 支払う。 - 上に $ 3 $ 進む。通行料を $ 3 $ 支払う。 - 左に $ 1 $ 進む。通行料を $ 0 $ 支払う。 - 上に $ 1 $ 進む。通行料を $ 1 $ 支払う。 支払う通行料を $ 4 $ 以下にすることはできないので、`5` を出力してください。

### Sample Explanation 2

通行料を支払わなくてよい場合もあります。

### Sample Explanation 3

出力すべき値が $ 32\operatorname{bit} $ 整数の範囲に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
5 0

2 5```

### 输出

```
5```

## 样例 #2

### 输入

```
3 1

4 1```

### 输出

```
0```

## 样例 #3

### 输入

```
2552608206527595 5411232866732612

771856005518028 7206210729152763```

### 输出

```
1794977862420151```

# AI分析结果

### 题目内容重写

在坐标平面上，铺设了许多大小为 $2 \times 1$ 的砖块。砖块的铺设遵循以下规则：

- 对于整数对 $(i, j)$，正方形 $A_{i,j} = \{(x, y) \mid i \leq x \leq i+1 \wedge j \leq y \leq j+1\}$ 包含在一个砖块中。
- 当 $i + j$ 为偶数时，$A_{i,j}$ 和 $A_{i+1,j}$ 包含在同一个砖块中。

砖块包括边界，并且不存在两个不同的砖块有正面积的共同部分。

高桥君初始位于点 $(S_x + 0.5, S_y + 0.5)$。他可以进行以下移动：

- 选择上下左右任意一个方向和一个正整数 $n$，向该方向移动 $n$ 个单位。

每当高桥君穿过一个不同的砖块时，他需要支付 $1$ 的通行费。求他从起点到终点 $(T_x + 0.5, T_y + 0.5)$ 所需支付的最小通行费。

### 样例解释

#### 样例 1
输入：
```
5 0
2 5
```
输出：
```
5
```

#### 样例 2
输入：
```
3 1
4 1
```
输出：
```
0
```

#### 样例 3
输入：
```
2552608206527595 5411232866732612
771856005518028 7206210729152763
```
输出：
```
1794977862420151
```

### 说明/提示

- $0 \leq S_x, S_y, T_x, T_y \leq 2 \times 10^{16}$
- 输入均为整数

---

### 题解分析与结论

#### 综合分析
本题的核心在于如何计算从起点到终点的最小通行费。由于砖块的铺设方式特殊，直接模拟移动过程会导致超时。因此，需要通过数学推导来简化问题。

大多数题解都采用了贪心策略，优先考虑纵向移动，因为纵向移动必定会产生通行费，而横向移动可以通过优化路径减少通行费。具体来说，当横向距离小于纵向距离时，最小通行费等于纵向距离；否则，最小通行费为纵向距离加上横向距离与纵向距离差值的一半。

#### 最优思路总结
1. **优先纵向移动**：由于纵向移动必定产生通行费，因此优先计算纵向距离。
2. **横向移动优化**：当横向距离大于纵向距离时，通过斜向移动减少通行费，最终通行费为纵向距离加上横向距离与纵向距离差值的一半。
3. **边界处理**：通过调整起点和终点的位置，确保它们位于砖块的左半部分，简化计算。

#### 推荐题解
1. **作者：Redamancy_Lydic (5星)**
   - **关键亮点**：通过调整起点和终点的位置，简化了计算过程，代码简洁且高效。
   - **核心代码**：
     ```cpp
     int x=abs(ex-sx),y=abs(ey-sy);
     if(x%2==0&&y%2==1||x%2==1&&y%2==0)
     {
         if((sx+sy)%2==1)sx--;
         else ex--;
     }
     x=abs(ex-sx),y=abs(ey-sy);
     if(x<=y)cout<<y;
     else cout<<(x+y)/2;
     ```

2. **作者：LuukLuuk (4星)**
   - **关键亮点**：通过贪心策略，优先考虑斜向移动，减少了横向移动的通行费。
   - **核心代码**：
     ```cpp
     deta_l = abs(a - c);
     deta_r = abs(b - d);
     ans = deta_l;
     deta_r = max(0ll, deta_r - deta_l);
     ans += (deta_r + 1ll) / 2ll;
     ```

3. **作者：I_Love_DS (4星)**
   - **关键亮点**：通过将起点和终点调整到砖块的左半部分，简化了计算过程。
   - **核心代码**：
     ```cpp
     if (sy % 2 == 0) sx -= abs(sx % 2);
     else sx -= abs((sx + 1) % 2);
     if (ey % 2 == 0) ex -= abs(ex % 2);
     else ex -= abs((ex + 1) % 2);
     long long k = (abs(ex - sx) - abs(ey - sy));
     ans += max(0LL, k / 2);
     ```

### 扩展思路
本题的解题思路可以推广到其他类似的网格路径问题，尤其是当移动路径的代价与网格的铺设方式相关时。通过优先考虑代价较高的移动方向，并结合数学推导优化路径，可以有效减少计算复杂度。

### 推荐题目
1. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
2. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得摘录
- **Redamancy_Lydic**：通过调整起点和终点的位置，简化了计算过程，避免了复杂的边界处理。
- **I_Love_DS**：将起点和终点调整到砖块的左半部分，使得后续计算更加直观和简单。

---
处理用时：50.11秒
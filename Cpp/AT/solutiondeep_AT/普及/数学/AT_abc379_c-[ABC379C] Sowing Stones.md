# 题目信息

# [ABC379C] Sowing Stones

## 题目描述

给你两个数 $n$，$m$。

表示现在有 $n$ 个格子，再给你 $m$ 组数据，表示在第 $X_i$ 个格子上有 $A_i$ 个石头。

有以下操作（可以不移动）。

- 对于第 $i$ 个格子，如果这个格子上有石头 ，可以将这个格子的一个石头移动到第 $i+1$ 个格子上。

求使得每个格子上恰好有一个石头的最小移动次数，如果无法满足条件输出 $-1$。


- 第一行：$N$ $M$ 

- 第二行：$X_1$ $X_2$ $\ldots$ $X_M$

- 第三行：$A_1$ $A_2$ $\ldots$ $A_M$

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^{9} $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^{5} $
- $ M\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ X_i\ \neq\ X_j $ $ (1\ \leq\ i\ <\ j\ \leq\ M) $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^{9} $ $ (1\ \leq\ i\ \leq\ M) $
- 输入为整数
 
### Sample Explanation 1

可以通过如下 $4$ 次操作使条件满足，且没有比 $4$ 次更小的次数。

初始条件：第一个格子上有 $3$ 个石头，第四个格子上有 $2$ 个石头。

- 移动一个石头从格子 $1$ 到格子 $2$。

- 再移动一个石头从格子 $1$ 到格子 $2$。 

- 移动一个石头从格子 $2$ 到格子 $3$。

- 移动一个石头从格子 $4$ 到格子 $5$。

操作完成后每个格子上都有一个石头。

### Sample Explanation 2

这个数据中无论如何移动一定无法使每个格子上有一个石头。

## 样例 #1

### 输入

```
5 2

1 4

3 2```

### 输出

```
4```

## 样例 #2

### 输入

```
10 3

1 4 8

4 2 4```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

#### [ABC379C] Sowing Stones

**题目描述**

给你两个数 $n$，$m$。

表示现在有 $n$ 个格子，再给你 $m$ 组数据，表示在第 $X_i$ 个格子上有 $A_i$ 个石头。

有以下操作（可以不移动）。

- 对于第 $i$ 个格子，如果这个格子上有石头 ，可以将这个格子的一个石头移动到第 $i+1$ 个格子上。

求使得每个格子上恰好有一个石头的最小移动次数，如果无法满足条件输出 $-1$。

**输入格式**

- 第一行：$N$ $M$ 
- 第二行：$X_1$ $X_2$ $\ldots$ $X_M$
- 第三行：$A_1$ $A_2$ $\ldots$ $A_M$

**说明/提示**

**制約**

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^{9} $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^{5} $
- $ M\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ X_i\ \neq\ X_j $ $ (1\ \leq\ i\ <\ j\ \leq\ M) $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^{9} $ $ (1\ \leq\ i\ \leq\ M) $
- 输入为整数

**样例解释**

**样例 #1**

输入：

```
5 2
1 4
3 2
```

输出：

```
4
```

**样例 #2**

输入：

```
10 3
1 4 8
4 2 4
```

输出：

```
-1
```

---

### 题解综合分析与结论

本题的核心在于通过贪心策略，计算将石头移动到每个格子恰好一个的最小操作次数。难点在于如何处理石头的移动顺序和计算移动次数，同时需要考虑边界条件和无解情况的判断。

### 所选高星题解

#### 题解1：作者：Po7ed (赞：4)

**星级**：★★★★★

**关键亮点**：
- 通过排序和模拟移动，清晰地处理了石头的移动顺序。
- 使用等差数列公式计算移动次数，优化了时间复杂度。
- 详细处理了边界条件和无解情况。

**个人心得**：
- 赛时吃了5发罚时，提醒我们在处理细节问题时需要冷静分析。

**核心代码**：
```cpp
a[m+1].x = n+1; // 新建节点，方便统计 (x_m,n+1)
ll ans = 0, tmp;
for(int i = 1; i <= m; i++) {
    tmp = a[i+1].x - a[i].x - 1; // 无石子区间长度
    if(a[i].a < tmp) NS; // 石子不够，无解
    a[i].a -= tmp; // 将石子均摊到无石子区间
    ans += (tmp * (tmp + 1) / 2); // 计算操作数
    a[i+1].a += a[i].a; // 将剩下石子移动到下一个位置
    ans += (tmp + 1) * a[i].a; // 计算移动操作数
}
if(a[m+1].a > 0) NS; // 如果有剩下的石子，无解
printf("%lld", ans);
```

#### 题解2：作者：I_Love_DS (赞：4)

**星级**：★★★★☆

**关键亮点**：
- 从后往前填石头的思路，简化了移动次数的计算。
- 使用等差数列公式计算贡献，优化了时间复杂度。
- 详细处理了无解情况。

**核心代码**：
```cpp
int r = n + 1;
sort(a + 1, a + m + 1); // 排序，从后往前填石头
for(int i = 1; i <= m; i++) {
    if(r - a[i].x < a[i].c) { // 石头过多，无解
        printf("-1\n");
        return 0;
    }
    ans += ((r - a[i].c - a[i].x) + (r - 1 - a[i].x)) * a[i].c / 2; // 算贡献
    r -= a[i].c; // 更新 r
}
if(r != 1) printf("-1\n");
else printf("%lld\n", ans);
```

#### 题解3：作者：kairuigg (赞：2)

**星级**：★★★☆☆

**关键亮点**：
- 通过分类讨论处理了石头的移动顺序。
- 使用等差数列公式计算移动次数，优化了时间复杂度。
- 详细处理了无解情况。

**核心代码**：
```cpp
for(int i = 1; i <= m; i++) {
    int num = a[i+1].id - a[i].id;
    if(a[i].x < num) {
        printf("-1\n");
        return 0;
    }
    ans += calc(num);
    ans += (a[i].x - num) * num;
    a[i+1].x += (a[i].x - num);
}
```

### 最优关键思路与技巧

1. **排序与模拟移动**：通过排序石头的初始位置，模拟石头的移动过程，确保每个格子最终恰好有一个石头。
2. **等差数列公式**：使用等差数列公式计算移动次数，优化了时间复杂度。
3. **边界条件处理**：详细处理了边界条件和无解情况，确保算法的正确性。

### 可拓展之处

类似的问题可以扩展到多维空间中的物体移动，或者扩展到更复杂的移动规则。例如，可以考察在二维网格中，如何将物体移动到指定位置的最小操作次数。

### 推荐题目

1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1966 [NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1966)

---
处理用时：53.05秒
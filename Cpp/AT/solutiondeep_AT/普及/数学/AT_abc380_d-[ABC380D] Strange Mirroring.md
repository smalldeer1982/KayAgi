# 题目信息

# [ABC380D] Strange Mirroring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc380/tasks/abc380_d

英大小文字からなる文字列 $ S $ が与えられます。

$ S $ に以下の操作を $ 10^{100} $ 回繰り返します。

- まず、 $ S $ の大文字を小文字に、小文字を大文字に書き換えた文字列を $ T $ とする。
- その後、 $ S $ と $ T $ とをこの順に連結した文字列を新たな $ S $ とする。
 
$ Q $ 個の質問に答えて下さい。 そのうち $ i $ 個目は次の通りです。

- 全ての操作を終えた後の $ S $ の先頭から $ K_i $ 文字目を求めよ。

## 说明/提示

### 制約

- $ S $ は英大小文字からなる長さ $ 1 $ 以上 $ 2\ \times\ 10^5 $ 以下の文字列
- $ Q,K_i $ は整数
- $ 1\ \le\ Q\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ K_i\ \le\ 10^{18} $
 
### Sample Explanation 1

操作前の $ S\ = $ `aB` です。 - `aB` に $ 1 $ 回操作を行うと `aBAb` となります。 - `aB` に $ 2 $ 回操作を行うと `aBAbAbaB` となります。 - $ \dots $ $ 10^{100} $ 回の操作を終えた後の $ S\ = $ `aBAbAbaBAbaBaBAb`... です。

## 样例 #1

### 输入

```
aB

16

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16```

### 输出

```
a B A b A b a B A b a B a B A b```

## 样例 #2

### 输入

```
qWeRtYuIoP

8

1 1 2 3 5 8 13 21```

### 输出

```
q q W e t I E Q```

## 样例 #3

### 输入

```
AnUoHrjhgfLMcDIpzxXmEWPwBZvbKqQuiJTtFSlkNGVReOYCdsay

5

1000000000000000000 123456789 1 987654321 999999999999999999```

### 输出

```
K a A Z L```

# AI分析结果

### 题目内容重写
**题目描述**

给定一个由英文字母大小写组成的字符串 $S$。对 $S$ 进行 $10^{100}$ 次操作，每次操作如下：

1. 首先，将 $S$ 中的大写字母转换为小写字母，小写字母转换为大写字母，得到字符串 $T$。
2. 然后，将 $S$ 和 $T$ 按顺序连接，形成新的字符串 $S$。

接下来有 $Q$ 个询问，每个询问要求输出在所有操作完成后，字符串 $S$ 的第 $K_i$ 个字符。

**说明/提示**

- $S$ 是由英文字母大小写组成的字符串，长度在 $1$ 到 $2 \times 10^5$ 之间。
- $Q$ 和 $K_i$ 是整数，$1 \le Q \le 2 \times 10^5$，$1 \le K_i \le 10^{18}$。

**样例解释**

- 样例1：初始字符串为 `aB`，经过多次操作后，字符串变为 `aBAbAbaBAbaBaBAb...`，输出第1到第16个字符。

### 题解分析与结论

#### 综合分析
该题的核心在于通过找规律来避免直接进行 $10^{100}$ 次操作。所有题解都采用了类似的思想：通过递归或迭代的方式，逐步缩小问题的规模，最终找到第 $K_i$ 个字符的位置，并根据其是否经过大小写反转来确定最终的字符。

#### 最优关键思路
1. **递归/迭代缩小问题规模**：通过不断将问题规模缩小到原始字符串的长度范围内，避免直接处理大规模字符串。
2. **位运算与二进制分解**：利用二进制分解的思想，判断字符是否经过大小写反转。
3. **时间复杂度优化**：通过二分或位运算，将时间复杂度控制在 $O(\log K_i)$ 级别，适合处理 $K_i$ 高达 $10^{18}$ 的情况。

#### 可拓展之处
该题的思路可以推广到其他类似的字符串操作问题，尤其是那些涉及大规模操作或递归结构的问题。类似的题目可能涉及字符串的重复、反转、拼接等操作。

### 推荐题目
1. [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)
2. [P3805 【模板】Manacher算法](https://www.luogu.com.cn/problem/P3805)
3. [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)

### 所选高星题解

#### 题解1：Moya_Rao (4星)
**关键亮点**：
- 通过递归缩小问题规模，逐步找到第 $K_i$ 个字符的位置。
- 使用 `flag` 变量记录字符是否经过大小写反转，代码简洁易懂。

**核心代码**：
```cpp
while(k>n){
    long long tmp=k;
    if(tmp>p/2)tmp-=p/2,flag=!flag;
    k=tmp;p/=2;
}
if(flag){
    if(s[k]>='A'&&s[k]<='Z')cout<<char(s[k]-'A'+'a')<<" ";
    else cout<<char(s[k]-'a'+'A')<<" ";
}
else cout<<s[k]<<" ";
```
**实现思想**：通过不断将 $k$ 缩小到原始字符串的长度范围内，并根据 $k$ 的位置决定是否反转字符。

#### 题解2：hellolin (4星)
**关键亮点**：
- 利用二进制分解的思想，通过 `bitcount` 判断字符是否反转。
- 时间复杂度为 $O(n)$，适合大规模数据处理。

**核心代码**：
```cpp
int flag1=(__builtin_popcountll(b)-1)&1,flag2=__builtin_ctzll(b)&1;
if(flag1^flag2){
    if('a'<=s[a]&&s[a]<='z') cout<<(char)(s[a]-'a'+'A')<<' ';
    else cout<<(char)(s[a]-'A'+'a')<<' ';
}
else cout<<s[a]<<' ';
```
**实现思想**：通过位运算判断字符是否经过反转，直接输出结果。

#### 题解3：zengziqvan (4星)
**关键亮点**：
- 使用分治思想，逐步缩小问题规模。
- 通过 `ps` 变量记录字符是否反转，代码简洁高效。

**核心代码**：
```cpp
ROF(j,op,1) {
    LL l1=1,r1=n*(1LL<<(j-1)),l2=r1+1,r2=n*(1LL<<j);
    if(k>=l1&&k<=r1) ;
    else ps^=1,k-=r1;
}
if(ps) cout<<change(a[st(k)])<<" ";
else cout<<a[st(k)]<<" ";
```
**实现思想**：通过分治逐步缩小 $k$ 的范围，并根据 $k$ 的位置决定是否反转字符。

---
处理用时：44.01秒
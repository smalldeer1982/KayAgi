# 题目信息

# [ARC166B] Make Multiples

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc166/tasks/arc166_b

整数列 $ A=(A_1,\ldots,A_N) $ および，正整数 $ a,b,c $ が与えられます．

あなたはこの数列に対して，以下の操作を（$ 0 $ 回を含め）何回でも行うことができます．

- $ 1\leq\ i\leq\ N $ となる整数 $ i $ をひとつ選ぶ．$ A_i $ を $ A_i+1 $ で置き換える．
 
あなたの目的は，数列 $ A $ の中に，$ a $ の倍数，$ b $ の倍数，$ c $ の倍数がいずれもひとつ以上存在するようにすることです． 目的を達成するために必要な操作回数の最小値を求めてください．

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ a,\ b,\ c\ \leq\ 10^6 $
- $ 1\leq\ A_i\leq\ 10^{18} $
 
### Sample Explanation 1

操作を $ 2 $ 回行い $ A\ =\ (8,10,12) $ とすることで目的を達成できます．

### Sample Explanation 2

操作を $ 1 $ 回行い $ A\ =\ (14,11,60) $ とすることで目的を達成できます．

### Sample Explanation 3

操作を $ 3 $ 回行い $ A\ =\ (8,17,5,30,40,13) $ とすることで目的を達成できます．

### Sample Explanation 4

操作を $ 876537210887543205 $ 回行い $ A\ =\ (999994000010999994) $ とすることで目的を達成できます．

## 样例 #1

### 输入

```
3 3 4 5

8 9 11```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 4 5

14 11 59```

### 输出

```
1```

## 样例 #3

### 输入

```
6 10 20 30

8 17 5 28 39 13```

### 输出

```
3```

## 样例 #4

### 输入

```
1 999997 999998 999999

123456789123456789```

### 输出

```
876537210887543205```

# AI分析结果

### 题目内容重写
#### [ARC166B] Make Multiples

**题目描述**

给定一个整数序列 $A=(A_1,\ldots,A_N)$ 以及正整数 $a,b,c$。你可以对序列进行以下操作任意次（包括零次）：

- 选择一个整数 $i$（$1\leq i\leq N$），将 $A_i$ 替换为 $A_i+1$。

你的目标是使序列 $A$ 中至少存在一个 $a$ 的倍数、一个 $b$ 的倍数和一个 $c$ 的倍数。求达成目标所需的最小操作次数。

**说明/提示**

**约束条件**

- $1\leq N\leq 2\times 10^5$
- $1\leq a, b, c \leq 10^6$
- $1\leq A_i\leq 10^{18}$

**样例解释**

**样例 1**

输入：
```
3 3 4 5
8 9 11
```
输出：
```
2
```
解释：进行 2 次操作，将 $A$ 变为 $(8,10,12)$，此时 $8$ 是 $4$ 的倍数，$10$ 是 $5$ 的倍数，$12$ 是 $3$ 的倍数。

**样例 2**

输入：
```
3 3 4 5
14 11 59
```
输出：
```
1
```
解释：进行 1 次操作，将 $A$ 变为 $(14,11,60)$，此时 $14$ 是 $2$ 的倍数，$11$ 是 $11$ 的倍数，$60$ 是 $3$ 的倍数。

**样例 3**

输入：
```
6 10 20 30
8 17 5 28 39 13
```
输出：
```
3
```
解释：进行 3 次操作，将 $A$ 变为 $(8,17,5,30,40,13)$，此时 $8$ 是 $2$ 的倍数，$17$ 是 $17$ 的倍数，$30$ 是 $3$ 的倍数。

**样例 4**

输入：
```
1 999997 999998 999999
123456789123456789
```
输出：
```
876537210887543205
```
解释：进行 876537210887543205 次操作，将 $A$ 变为 $(999994000010999994)$，此时 $999994000010999994$ 是 $999997$ 的倍数。

### 题解分析与结论

#### 综合分析
本题的核心在于如何高效地找到使序列中至少存在一个 $a$、$b$、$c$ 的倍数所需的最小操作次数。由于序列长度和数值范围较大，直接暴力枚举不可行。因此，大多数题解采用了动态规划（DP）或状态压缩的思路来优化计算。

#### 关键思路与技巧
1. **状态压缩DP**：通过二进制状态表示是否已经满足某个条件（如 $a$ 的倍数、$b$ 的倍数、$c$ 的倍数），并利用 DP 进行状态转移。
2. **预处理**：预先计算每个数变为 $a$、$b$、$c$ 的倍数所需的最小操作次数，避免重复计算。
3. **贪心策略**：在某些题解中，通过贪心策略选择最优的数进行操作，以减少操作次数。

#### 最优题解推荐
1. **作者：DerrickLo**
   - **星级**：5
   - **关键亮点**：使用状态压缩 DP，预处理每个数变为 $a$、$b$、$c$ 的倍数所需的最小操作次数，代码清晰且高效。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++){
         f[i][0][0][0]=f[i-1][0][0][0];
         f[i][0][0][1]=min(f[i-1][0][0][1],f[i-1][0][0][0]+C[i]);
         f[i][0][1][0]=min(f[i-1][0][1][0],f[i-1][0][0][0]+B[i]);
         f[i][1][0][0]=min(f[i-1][1][0][0],f[i-1][0][0][0]+A[i]);
         f[i][0][1][1]=min({f[i-1][0][1][1],f[i-1][0][0][1]+B[i],f[i-1][0][1][0]+C[i],f[i-1][0][0][0]+BC[i]});
         f[i][1][0][1]=min({f[i-1][1][0][1],f[i-1][0][0][1]+A[i],f[i-1][1][0][0]+C[i],f[i-1][0][0][0]+AC[i]});
         f[i][1][1][0]=min({f[i-1][1][1][0],f[i-1][1][0][0]+B[i],f[i-1][0][1][0]+A[i],f[i-1][0][0][0]+AB[i]});
         f[i][1][1][1]=min({f[i-1][1][1][1],f[i-1][1][1][0]+C[i],f[i-1][1][0][1]+B[i],f[i-1][0][1][1]+A[i],f[i-1][0][0][1]+AB[i],f[i-1][0][1][0]+AC[i],f[i-1][1][0][0]+BC[i],f[i-1][0][0][0]+ABC[i]}); 
     }
     ```

2. **作者：sunkuangzheng**
   - **星级**：4
   - **关键亮点**：采用状态压缩 DP，代码简洁，思路清晰，适合理解 DP 的初学者。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++){
         f[i][0] = 0;
         for(int j=1;j<=7;j++){
             for(int k=0;k<=7;k++){
                 if((k | j) != j) continue;int tp = 1;
                 for(int l=2;l>=0;l--) if(((j >> l) & 1) && !((k >> l) & 1)) tp = lcm(tp,b[l+1]);
                 f[i][j] = min(f[i][j],f[i-1][k] + (tp - a[i] % tp) % tp);
             }
         }
     }
     ```

3. **作者：forever_nope**
   - **星级**：4
   - **关键亮点**：详细的状态转移方程说明，适合深入理解 DP 的状态转移过程。
   - **核心代码**：
     ```cpp
     f(i,7)=min({f(i-1,7),f(i-1,3)+to(A_i,c),f(i-1,5)+to(A_i,b),f(i-1,6)+to(A_i,a),f(i-1,1)+to(A_i,lcm(b,c)),f(i-1,2)+to(A_i,lcm(a,c)),f(i-1,4)+to(A_i,lcm(a,b)),f(i-1,0)+to(A_i,lcm(a,b,c))});
     ```

### 扩展思路与推荐题目
1. **扩展思路**：本题的状态压缩 DP 思路可以扩展到更多条件的类似问题，如需要满足多个不同的倍数条件。
2. **推荐题目**：
   - [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)
   - [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

### 个人心得总结
- **调试经历**：在实现 DP 时，确保状态转移方程的正确性非常重要，尤其是在处理多个条件时，容易遗漏某些状态转移。
- **踩坑教训**：预处理时要注意数值范围，避免溢出或计算错误。
- **顿悟感想**：状态压缩 DP 在处理多个条件的问题时非常高效，但需要仔细设计状态转移方程。

---
处理用时：72.88秒
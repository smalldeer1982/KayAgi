# 题目信息

# [ABC079D] Wall

## 题目描述

## 【题目大意】

你面前有一堵墙，墙上有数字，你需要将墙上的数字都变成 ```1``` 。  
现在给出一个 $W\times H$ 的矩阵 $A$ 表示墙上数字的情况。  
其中若 $A_{i,j}=-1$ ，则表示位置 $(i,j)$ 上没有数字，否则 $A_{i,j}$ 的值表示墙上 $(i,j)$ 位置的数字。  
当然，你还有一张 $10\times 10$ 的表 $C$，其中 $C_{i,j}$ 表示把数字 $i$ 转化成数字 $j$ 所需要的花费。  
求花费的最小值。

## 说明/提示

$1\le H,W\le200$  
$1\le C_{i,j}\le 10^3 (i\neq j)$  
$C_{i,j}=0(i=j)$  
$-1\le A_{i,j}\le 9$
所有数据保证在 ```int``` 范围以内。

## 样例 #1

### 输入

```
2 4

0 9 9 9 9 9 9 9 9 9

9 0 9 9 9 9 9 9 9 9

9 9 0 9 9 9 9 9 9 9

9 9 9 0 9 9 9 9 9 9

9 9 9 9 0 9 9 9 9 2

9 9 9 9 9 0 9 9 9 9

9 9 9 9 9 9 0 9 9 9

9 9 9 9 9 9 9 0 9 9

9 9 9 9 2 9 9 9 0 9

9 2 9 9 9 9 9 9 9 0

-1 -1 -1 -1

8 1 1 8```

### 输出

```
12```

## 样例 #2

### 输入

```
5 5

0 999 999 999 999 999 999 999 999 999

999 0 999 999 999 999 999 999 999 999

999 999 0 999 999 999 999 999 999 999

999 999 999 0 999 999 999 999 999 999

999 999 999 999 0 999 999 999 999 999

999 999 999 999 999 0 999 999 999 999

999 999 999 999 999 999 0 999 999 999

999 999 999 999 999 999 999 0 999 999

999 999 999 999 999 999 999 999 0 999

999 999 999 999 999 999 999 999 999 0

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3 5

0 4 3 6 2 7 2 5 3 3

4 0 5 3 7 5 3 7 2 7

5 7 0 7 2 9 3 2 9 1

3 6 2 0 2 4 6 4 2 3

3 5 7 4 0 6 9 7 6 7

9 8 5 2 2 0 4 7 6 5

5 4 6 3 2 3 0 5 4 3

3 6 2 3 4 2 4 0 8 9

4 6 5 4 3 5 3 2 0 8

2 1 3 4 5 7 8 6 4 0

3 5 2 6 1

2 5 3 2 1

6 9 2 5 6```

### 输出

```
47```

# AI分析结果

### 题目内容（已为中文，无需翻译）
你面前有一堵墙，墙上有数字，你需要将墙上的数字都变成 ```1``` 。  
现在给出一个 $W\times H$ 的矩阵 $A$ 表示墙上数字的情况。  
其中若 $A_{i,j}=-1$ ，则表示位置 $(i,j)$ 上没有数字，否则 $A_{i,j}$ 的值表示墙上 $(i,j)$ 位置的数字。  
当然，你还有一张 $10\times 10$ 的表 $C$，其中 $C_{i,j}$ 表示把数字 $i$ 转化成数字 $j$ 所需要的花费。  
求花费的最小值。

### 综合分析与结论
- **思路对比**：各位作者思路基本一致，均将数字转化问题抽象为图论问题，把数字看作图的节点，转化花费看作边权，通过求各数字到数字 1 的最短路径来计算最小花费总和。
- **算法要点**：都采用 Floyd 算法计算任意两点间的最短路径，再遍历矩阵累加非 -1 和 1 的数字到 1 的最短路径长度。
- **解决难点**：主要难点在于理解可借助其他数字“跳板”转化，从而想到用最短路径算法。Floyd 算法中循环变量顺序固定，需注意。

### 评分较高的题解
- **作者：Erinyes（5 星）**
    - **关键亮点**：思路清晰，对题目分析详细，代码注释丰富，解释了 Floyd 算法中循环变量顺序固定的原因。
    - **核心代码**：
```cpp
void floyd(){
    for(int k=0;k<=9;k++){ 
        for(int i=0;i<=9;i++){
            for(int j=0;j<=9;j++){
                if(dis[i][k]!=INF and dis[k][j]!=INF) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); 
            }
        }
    }
}
```
核心实现思想：通过枚举中间点 k，不断更新任意两点 i 和 j 之间的最短路径。

- **作者：cqbztz2（4 星）**
    - **关键亮点**：代码简洁，逻辑清晰，按照思路逐步实现，易于理解。
    - **核心代码**：
```cpp
for(int k=0;k<10;k++){
    for(int i=0;i<10;i++){
        for(int j=0;j<10;j++){
            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
        }
    }
}
```
核心实现思想：同样是 Floyd 算法的实现，更新任意两点间的最短路径。

- **作者：TRZ_2007（4 星）**
    - **关键亮点**：对题目进行了抽象化分析，说明了选择 Floyd 算法的原因，代码实现简洁。
    - **核心代码**：
```cpp
for(int k = 0;k < 10;k++) {
    for(int i = 0;i < 10;i++) {
        for(int j = 0;j < 10;j++) if(c[i][j] > c[i][k] + c[k][j]) c[i][j] = c[i][k] + c[k][j];
    }
}
```
核心实现思想：Floyd 算法更新最短路径，若经过中间点 k 的路径更短，则更新两点间的最短路径。

### 最优关键思路或技巧
- **思维方式**：将数字转化问题抽象为图论的最短路径问题，利用图的邻接矩阵存储转化花费。
- **算法选择**：使用 Floyd 算法计算任意两点间的最短路径，适用于数据范围较小的情况。

### 可拓展之处
同类型题或类似算法套路：
- 其他涉及状态转化且可借助中间状态的问题，如不同状态间的最小代价转换。
- 可使用 Floyd 算法解决的多源最短路径问题，如地图中多个地点间的最短距离。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法在动态图中的应用。
- [P2910 [USACO08OPEN]Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910)：多源最短路径问题，可用 Floyd 算法解决。
- [P1347 排序](https://www.luogu.com.cn/problem/P1347)：通过 Floyd 算法判断元素间的顺序关系。

### 个人心得
- **作者：_byta**：补充了使用 Floyd 算法的原因，即把数字转化过程与 Floyd 求最短路过程联系起来，有助于理解算法的选择。
- **作者：TRZ_2007**：提到本题本可使用 spfa 解决单源最短路，但因数据范围小，选择了实现更简单的 Floyd 算法，说明算法选择要结合数据范围。 

---
处理用时：34.17秒
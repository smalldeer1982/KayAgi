# 题目信息

# [ABC252E] Road Reduction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc252/tasks/abc252_e

AtCoder 王国には都市 $ 1,2,\ldots,N $ の $ N $ 個の都市と、道路 $ 1,2,\ldots,M $ の $ M $ 本の道路があります。  
道路 $ i $ は都市 $ A_i $ と $ B_i $ を双方向に結び、距離は $ C_i $ です。  
どの都市間もいくつかの道路を通って行き来することができます。

財政難である王国は、どの都市間もいくつかの道路を通って行き来できるという条件を満たすように $ N-1 $ 本の道路を保守し、それ以外の道路を廃道にすることにしました。

保守する道路のみを通って都市 $ 1 $ から都市 $ i $ へ移動するときの距離を $ d_i $ とするとき、保守する道路の選び方であって、$ d_2+d_3+\ldots+d_N $ を最小化するようなものを $ 1 $ つ出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- $ i\neq\ j $ のとき、$ (A_i,B_i)\neq(A_j,B_j) $
- $ 1\leq\ C_i\ \leq\ 10^9 $
- どの都市間もいくつかの道路を通って行き来することができる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

保守する道路の選び方と $ d_i $ の値は次のようになります。 - 道路 $ 1,2 $ を保守するとき、$ d_2=1 $, $ d_3=3 $ - 道路 $ 1,3 $ を保守するとき、$ d_2=1 $, $ d_3=10 $ - 道路 $ 2,3 $ を保守するとき、$ d_2=12 $, $ d_3=10 $ よって、道路 $ 1,2 $ を保守するときに $ d_2+d_3 $ が最小になります。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 2
1 3 10```

### 输出

```
1 2```

## 样例 #2

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 1
2 4 1
3 4 1```

### 输出

```
3 1 2```

# AI分析结果

### 题目内容中文重写
# [ABC252E] 道路缩减

## 题目描述
[problemUrl]: https://atcoder.jp/contests/abc252/tasks/abc252_e

AtCoder 王国有编号为 $ 1,2,\ldots,N $ 的 $ N $ 个城市和编号为 $ 1,2,\ldots,M $ 的 $ M $ 条道路。
道路 $ i $ 双向连接城市 $ A_i $ 和 $ B_i $，距离为 $ C_i $。
任意两个城市之间都可以通过若干条道路相互通行。

处于财政困难的王国决定，在满足任意两个城市之间都可以通过若干条道路相互通行的条件下，维护 $ N - 1 $ 条道路，将其余道路废弃。

设仅通过维护的道路从城市 $ 1 $ 移动到城市 $ i $ 的距离为 $ d_i $，请输出一种维护道路的选择方案，使得 $ d_2 + d_3 + \ldots + d_N $ 最小。

## 说明/提示

### 限制条件
- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ N - 1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- 当 $ i\neq\ j $ 时，$ (A_i,B_i)\neq(A_j,B_j) $
- $ 1\leq\ C_i\ \leq\ 10^9 $
- 任意两个城市之间都可以通过若干条道路相互通行
- 输入中包含的所有值均为整数

### 样例解释 1
维护道路的选择方案和 $ d_i $ 的值如下：
- 维护道路 $ 1,2 $ 时，$ d_2 = 1 $，$ d_3 = 3 $
- 维护道路 $ 1,3 $ 时，$ d_2 = 1 $，$ d_3 = 10 $
- 维护道路 $ 2,3 $ 时，$ d_2 = 12 $，$ d_3 = 10 $
因此，维护道路 $ 1,2 $ 时 $ d_2 + d_3 $ 最小。

## 样例 #1

### 输入
```
3 3
1 2 1
2 3 2
1 3 10
```

### 输出
```
1 2
```

## 样例 #2

### 输入
```
4 6
1 2 1
1 3 1
1 4 1
2 3 1
2 4 1
3 4 1
```

### 输出
```
3 1 2
```

### 综合分析与结论
这些题解的核心思路都是利用 Dijkstra 算法来解决问题。算法要点在于通过 Dijkstra 算法求出从城市 1 到其他城市的最短路径，在松弛过程中记录下对应的边编号，最终得到的 $n - 1$ 条边构成的图就是满足条件的生成树，能使 $d_2 + d_3 + \ldots + d_N$ 最小。

解决的难点在于理解为什么 Dijkstra 算法过程中记录的边能构成满足要求的生成树。因为 Dijkstra 算法每次从堆中取出未确定最短路的结点中路径最短的结点，该结点确定最短路后就不会再被其他结点更新，每个点都会被至少松弛一次，除起点 1 外的 $n - 1$ 个点正好对应 $n - 1$ 条边，且这些边能保证图的连通性。

### 所选题解
- **xixiyan（4星）**
    - **关键亮点**：思路清晰，详细解释了题目大意和分析过程，使用链式前向星存储图，代码注释详细，提醒要开 long long 避免数据溢出。
    - **核心代码**：
```cpp
// 链式前向星存边
void add(int x,int y,int w){
    W[++tot].w=w;
    To[tot]=y;
    Nxt[tot]=head[x];
    head[x]=tot;
}
// Dijkstra 算法
while(!o_o.empty())
{
    int d=o_o.top().d;
    o_o.pop();
    if(vis[d]) continue;
    vis[d]=1;
    for(int i=head[d],y;i;i=Nxt[i])
    {
        y=To[i];
        if(dis[y]>dis[d]+W[i].w)
        {
            dis[y]=dis[d]+W[i].w;
            o_o.push((qwq){dis[y],y});
            ans[y]=W[i].num; // 松弛时顺便更新答案
        }
    }
}
```
- **FL_sleake（4星）**
    - **关键亮点**：对题意和解题思路的阐述清晰明了，代码结构清晰，使用 vector 存储图，在 Dijkstra 算法中添加了判断避免 TLE。
    - **核心代码**：
```cpp
// Dijkstra 算法
void Dijkstra(){
    memset(dis,0x3f,sizeof(dis));
    q.push({1,0,0});
    dis[1]=0;
    while(!q.empty()){
        int u=q.top().v,D=q.top().w;
        q.pop();
        if(dis[u]<D) continue; // 避免 TLE
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].v,w=G[u][i].w;
            if(dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                ans[v]=G[u][i].id; // 记录答案
                q.push({v,dis[v],0});
            }
        }
    }
}
```
- **FFTotoro（4星）**
    - **关键亮点**：代码简洁，使用 `pair` 和 `vector` 存储图，利用 C++17 的结构化绑定简化代码。
    - **核心代码**：
```cpp
// Dijkstra 算法
while(!q.empty()){
    auto [f,e]=q.top(); q.pop();
    if(f>d[e])continue;
    if(e)cout<<p[e]+1<<' ';
    for(auto [v,i]:g[e]){
        if(d[e]+w[i]>=d[v])continue;
        p[v]=i; q.emplace(d[v]=d[e]+w[i],v);
    }
}
```

### 最优关键思路或技巧
- **利用 Dijkstra 算法特性**：Dijkstra 算法在求最短路的过程中，每个点被松弛的最后一次对应的边构成的图就是最短路径树，刚好满足本题要求的 $n - 1$ 条边且使 $d_2 + d_3 + \ldots + d_N$ 最小。
- **边编号记录**：在松弛过程中顺便记录边的编号，方便后续输出满足条件的边。

### 可拓展之处
同类型题如求最小生成树的变种问题，类似算法套路有 Prim 算法求最小生成树，可根据不同题目条件选择合适的算法。

### 洛谷相似题目推荐
- P3366 【模板】最小生成树
- P1194 买礼物
- P2872 [USACO07DEC]Building Roads S

### 个人心得摘录与总结
- **FL_sleake**：提到在 Dijkstra 算法中添加 `if(dis[u]<D) continue;` 判断，否则在 `after_contest` 的数据上会 TLE，但不清楚具体原因。总结就是在写 Dijkstra 算法时可以加上这个判断来避免超时问题。 

---
处理用时：47.75秒
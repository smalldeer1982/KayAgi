# 题目信息

# [ABC286E] Souvenir

## 题目描述

从前有 $n$ 座岛，每个岛上有 $a_i$ 个金币，各个岛间有若干条单向航线相连。

你从某个岛开始旅行，经过一个岛（包括最开始所在的岛）就会拿走上面的金币。

现在问你 $q$ 个问题：从岛 $u_i$ 旅行到岛 $v_i$，最少要走几条航线，以及恰好走这么多条航线最多能获得多少金币。如果根本无法到达 $v_i$，输出 `Impossible`。

询问之间相互独立。

## 样例 #1

### 输入

```
5

30 50 70 20 60

NYYNN

NNYNN

NNNYY

YNNNN

YNNNN

3

1 3

3 1

4 5```

### 输出

```
1 100

2 160

3 180```

## 样例 #2

### 输入

```
2

100 100

NN

NN

1

1 2```

### 输出

```
Impossible```

# AI分析结果

### 题目内容（已翻译）
# [ABC286E] 纪念品

## 题目描述

从前有 $n$ 座岛，每个岛上有 $a_i$ 个金币，各个岛间有若干条单向航线相连。

你从某个岛开始旅行，经过一个岛（包括最开始所在的岛）就会拿走上面的金币。

现在问你 $q$ 个问题：从岛 $u_i$ 旅行到岛 $v_i$，最少要走几条航线，以及恰好走这么多条航线最多能获得多少金币。如果根本无法到达 $v_i$，输出 `Impossible`。

询问之间相互独立。

## 样例 #1

### 输入

```
5
30 50 70 20 60
NYYNN
NNYNN
NNNYY
YNNNN
YNNNN
3
1 3
3 1
4 5
```

### 输出

```
1 100
2 160
3 180
```

## 样例 #2

### 输入

```
2
100 100
NN
NN
1
1 2
```

### 输出

```
Impossible
```

### 综合分析与结论
这些题解主要围绕如何解决从一个岛到另一个岛的最少航线数及最多金币数问题，大部分题解采用 Floyd 算法，少部分采用 SPFA、Dijkstra、BFS 等算法。

#### 思路对比
- **Floyd 算法**：利用 Floyd 算法的特性，在求最短路的同时更新最多金币数。通过枚举中间点 $k$，不断更新从 $i$ 到 $j$ 的最少航线数和最多金币数。
- **SPFA 算法**：通过队列不断扩展节点，根据当前方案的步数和金币数更新最短路和最多金币数。
- **Dijkstra 算法**：使用优先队列，按最短路径长度和权值之和排序，更新最短路和最多金币数。
- **BFS 算法**：通过队列记录当前位置、走过的边数和纪念品数，搜索过程中更新答案。

#### 算法要点对比
- **Floyd 算法**：定义两个数组分别记录最少航线数和最多金币数，在更新最短路时同步更新金币数。
- **SPFA 算法**：使用队列扩展节点，根据步数和金币数更新答案。
- **Dijkstra 算法**：使用优先队列，按双关键字排序更新答案。
- **BFS 算法**：使用队列记录状态，搜索过程中更新答案。

#### 解决难点对比
- **Floyd 算法**：需要处理中间点权值重复计算的问题，在更新金币数时减去中间点的权值。
- **SPFA 算法**：需要处理每次询问都跑一遍算法导致的超时问题，采用离线做法预处理答案。
- **Dijkstra 算法**：需要自定义优先队列的排序机制，按最短路径长度和权值之和排序。
- **BFS 算法**：需要处理状态的更新和判断，避免重复计算。

### 所选题解
- **liujy_（4星）**
  - **关键亮点**：思路清晰，代码简洁，使用 Floyd 算法直接解决问题，在更新最短路的同时更新最多金币数，处理中间点权值重复计算的问题。
  - **个人心得**：无

### 重点代码
```cpp
// liujy_ 的核心代码
for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            if(dd[i][k]+dd[k][j]<dd[i][j]){
                dd[i][j]=dd[i][k]+dd[k][j];
                d[i][j]=d[i][k]+d[k][j]-a[k];
            }else if(dd[i][k]+dd[k][j]==dd[i][j])
                d[i][j]=max(d[i][k]+d[k][j]-a[k],d[i][j]);
        }
```
**核心实现思想**：通过枚举中间点 $k$，不断更新从 $i$ 到 $j$ 的最少航线数 `dd[i][j]` 和最多金币数 `d[i][j]`。如果找到更短的路线，直接更新；如果路线长度相同，比较金币数并更新。

### 最优关键思路或技巧
- **Floyd 算法的应用**：由于 $n$ 的范围较小，Floyd 算法可以在 $O(n^3)$ 的时间复杂度内预处理出任意两点间的最少航线数和最多金币数。
- **点权转边权**：将点权转化为边权，方便在算法中处理，避免中间点权值重复计算的问题。
- **双关键字排序**：在更新答案时，先比较最短路径长度，若相等再比较权值之和，确保答案的正确性。

### 可拓展之处
同类型题或类似算法套路：
- **多源最短路问题**：可以使用 Floyd 算法解决多源最短路问题，在更新最短路的同时更新其他信息。
- **双关键字最短路问题**：对于需要同时考虑两个关键字的最短路问题，可以使用自定义排序机制的优先队列或在算法中进行双关键字比较。
- **图的遍历问题**：可以使用 BFS、DFS 等算法遍历图，在遍历过程中更新答案。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：Floyd 算法的应用，在图的动态变化中求最短路。
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：Dijkstra 算法的应用，求单源最短路径。
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：SPFA 算法的应用，求单源最短路径。

### 个人心得摘录与总结
- **Fire_flame**：使用 SPFA 算法时直接每次询问都跑一遍会超时，需要采用离线做法预处理答案。总结：对于多组询问的问题，要考虑预处理答案，避免重复计算导致超时。
- **CarroT1212**：注意 $A_i \le 10^9$，要开 long long，赛时痛吃一发罚时。总结：在处理大数据范围时，要注意数据类型的选择，避免数据溢出。

---
处理用时：41.46秒
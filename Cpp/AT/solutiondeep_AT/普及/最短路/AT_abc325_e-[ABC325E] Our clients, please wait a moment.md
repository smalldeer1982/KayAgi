# 题目信息

# [ABC325E] Our clients, please wait a moment

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_e

ある国には都市が $ N $ 個あります。  
あなたは、都市 $ 1 $ にある営業所から $ 0 $ 個以上の都市を経由して都市 $ N $ にある訪問先へ移動しようとしています。  
移動手段は社用車と電車の $ 2 $ 種類があります。都市 $ i $ から都市 $ j $ へ移動するときの所要時間は以下の通りです。

- 社用車を使った場合 : $ D_{i,j}\ \times\ A $ 分
- 電車を使った場合 : $ D_{i,j}\ \times\ B\ +\ C $ 分

ただし、社用車から電車に乗り換えることはできますが、電車から社用車に乗り換えることはできません。  
また、乗り換えは各都市のみで行え、乗り換えに時間はかかりません。

都市 $ 1 $ から都市 $ N $ に移動するのにかかる時間は最短で何分ですか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ A,\ B,\ C\ \leq\ 10^6 $
- $ D_{i,j}\ \leq\ 10^6 $
- $ D_{i,i}\ =\ 0 $
- $ D_{i,j}\ =\ D_{j,i}\ >\ 0 $ $ (i\ \neq\ j) $
- 入力される数値はすべて整数

### Sample Explanation 1

以下のように移動することで合計 $ 78 $ 分で都市 $ 1 $ から都市 $ 4 $ に移動することができます。 - 都市 $ 1 $ から都市 $ 3 $ まで社用車で移動する。この移動には $ 2\ \times\ 8\ =\ 16 $ 分かかる。 - 都市 $ 3 $ から都市 $ 2 $ まで社用車で移動する。この移動には $ 3\ \times\ 8\ =\ 24 $ 分かかる。 - 都市 $ 2 $ から都市 $ 4 $ まで電車で移動する。この移動には $ 5\ \times\ 5\ +\ 13\ =\ 38 $ 分かかる。 $ 78 $ 分未満の時間で都市 $ 1 $ から都市 $ 4 $ に移動することはできません。

## 样例 #1

### 输入

```
4 8 5 13
0 6 2 15
6 0 3 5
2 3 0 13
15 5 13 0```

### 输出

```
78```

## 样例 #2

### 输入

```
3 1 1000000 1000000
0 10 1
10 0 10
1 10 0```

### 输出

```
1```

## 样例 #3

### 输入

```
5 954257 954213 814214
0 84251 214529 10017 373342
84251 0 91926 32336 164457
214529 91926 0 108914 57762
10017 32336 108914 0 234705
373342 164457 57762 234705 0```

### 输出

```
168604826785```

# AI分析结果

### 题目中文重写
在某个国家有 $N$ 个城市。你打算从位于城市 $1$ 的营业所出发，经过 $0$ 个或多个城市，前往位于城市 $N$ 的访问地。

移动方式有公司用车和电车两种。从城市 $i$ 移动到城市 $j$ 所需的时间如下：
- 使用公司用车的情况：$D_{i,j}\ \times\ A$ 分钟
- 使用电车的情况：$D_{i,j}\ \times\ B\ +\ C$ 分钟

不过，虽然可以从公司用车换乘到电车，但不能从电车换乘到公司用车。此外，换乘只能在各个城市进行，且换乘不花费时间。

从城市 $1$ 移动到城市 $N$ 最短需要多少分钟？

### 说明/提示
#### 限制条件
- $ 2\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ A,\ B,\ C\ \leq\ 10^6 $
- $ D_{i,j}\ \leq\ 10^6 $
- $ D_{i,i}\ =\ 0 $
- $ D_{i,j}\ =\ D_{j,i}\ >\ 0 $ （$i\ \neq\ j$）
- 输入的所有数值均为整数

#### 示例解释 1
通过以下方式移动，可以在总计 $78$ 分钟内从城市 $1$ 移动到城市 $4$：
 - 从城市 $1$ 乘坐公司用车移动到城市 $3$，这次移动需要 $2\ \times\ 8\ =\ 16$ 分钟。
 - 从城市 $3$ 乘坐公司用车移动到城市 $2$，这次移动需要 $3\ \times\ 8\ =\ 24$ 分钟。
 - 从城市 $2$ 乘坐电车移动到城市 $4$，这次移动需要 $5\ \times\ 5\ +\ 13\ =\ 38$ 分钟。

无法在少于 $78$ 分钟的时间内从城市 $1$ 移动到城市 $4$。

### 综合分析与结论
这些题解主要围绕如何解决从城市 $1$ 到城市 $N$ 的最短移动时间问题，由于存在两种移动方式且有换乘限制，核心在于处理好换乘情况。

#### 思路对比
- **分层图思路**：构建两层图，一层表示坐汽车，一层表示坐火车，两层对应节点用边权为 0 的单向边连接表示换乘，然后跑最短路算法，如 Dijkstra 或 Floyd。
- **枚举换乘点思路**：枚举所有可能的换乘点，分别计算坐汽车到换乘点和从换乘点坐火车到终点的最短距离，取最小值。
- **状态数组思路**：使用状态数组记录是否换乘，在跑最短路时根据状态更新距离。

#### 算法要点对比
- **分层图**：建图时注意边权设置和单向边方向，选择合适的最短路算法。
- **枚举换乘点**：分别对汽车和火车图跑最短路，然后枚举换乘点计算总距离。
- **状态数组**：在最短路更新时根据状态判断能否换乘。

#### 解决难点对比
- **分层图**：正确构建分层图，理解分层图的原理和应用。
- **枚举换乘点**：合理枚举换乘点，避免重复计算。
- **状态数组**：准确维护状态数组，确保状态转移正确。

### 所选题解
- **作者：CultReborn (赞：8)，4星**
  - **关键亮点**：思路清晰，详细介绍了分层图的构建和使用 Dijkstra 算法求解最短路的过程，代码注释详细，可读性高。
  - **核心代码**：
```cpp
void Input(int u,int v,int w){
    edge[cnt] = {v,head[u],w};
    head[u] = cnt++; //邻接表改为链式前向星存图
}
void Dijkstra(int s){ //最短路板子，SPFA 死了
    q.push({0,s}); dis[s] = 0;
    while(!q.empty()){
        int u = q.top().second; q.pop();
        if(vis[u]) continue; vis[u] = 1;
        for(int i = head[u];~i;i = edge[i].nxt){
            int v = edge[i].to,w = edge[i].cst;
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                q.push({-dis[v],v});
            }
        }
    }
}
```
  - **核心实现思想**：`Input` 函数用于构建图的邻接表，`Dijkstra` 函数实现了堆优化的 Dijkstra 算法，通过优先队列不断更新最短距离。

- **作者：FireRain (赞：0)，4星**
  - **关键亮点**：采用正反跑两遍 Dijkstra 算法的思路，分别计算只坐汽车和只坐火车的最短距离，然后枚举换乘点取最小值，思路简洁明了。
  - **核心代码**：
```cpp
struct edge{
    int idx,h[N],ne[M],e[M],w[M],d[N];
    bool vis[N];
    
    edge(){
        memset(h,-1,sizeof(h));
        memset(d,inf,sizeof(d));
    }
    
    inline void add(int a,int b,int c){
        ne[idx] = h[a];
        e[idx] = b;
        w[idx] = c;
        h[a] = idx++;
    }
    
    inline void dijkstra(int s){
        priority_queue<pii,vector<pii>,greater<pii>> q;
        d[s] = 0;
        q.push({0,s});
        while (!q.empty()){
            pii t = q.top();
            q.pop();
            if (vis[t.snd]) continue;
            vis[t.snd] = true;
            for (re int i = h[t.snd];~i;i = ne[i]){
                int j = e[i];
                if (d[j] > t.fst + w[i]){
                    d[j] = t.fst + w[i];
                    q.push({d[j],j});
                }
            }
        }
    }
}g[2];
```
  - **核心实现思想**：定义了 `edge` 结构体来表示图，`add` 函数用于添加边，`dijkstra` 函数实现了堆优化的 Dijkstra 算法，通过优先队列更新最短距离。

- **作者：_Ink (赞：0)，4星**
  - **关键亮点**：提供了正反跑两遍最短路和分层图两种解法，思路清晰，代码实现规范，注释详细。
  - **核心代码**：
```cpp
void dija(int s)
{
    q.push(make_pair(0, s));
    disa[s] = 0;
    while(q.size())
    {
        int x = q.top().second; q.pop();
        visa[x] = true;
        for(int i = 1; i <= n; i ++)
        {
            if(visa[i]) continue;
            if(disa[x] + d[x][i] * a < disa[i])
            {
                disa[i] = disa[x] + d[x][i] * a;
                q.push(make_pair(-disa[i], i));
            }
        }
    }
}

void dijb(int s)
{
    q.push(make_pair(0, s));
    disb[s] = 0;
    while(q.size())
    {
        int x = q.top().second; q.pop();
        if(visb[x]) continue;
        visb[x] = true;
        for(int i = 1; i <= n; i ++)
        {
            if(disb[x] + d[x][i] * b + c < disb[i])
            {
                disb[i] = disb[x] + d[x][i] * b + c;
                q.push(make_pair(-disb[i], i));
            }
        }
    }
}
```
  - **核心实现思想**：`dija` 函数计算只坐汽车的最短距离，`dijb` 函数计算只坐火车的最短距离，通过优先队列更新最短距离。

### 最优关键思路或技巧
- **分层图**：对于存在多种状态或限制条件的最短路问题，分层图是一种有效的解决方法，通过构建多层图来表示不同状态，利用边权和单向边处理状态转移。
- **枚举换乘点**：当问题可以分解为多个子问题时，枚举中间点可以将问题简化，分别计算子问题的结果，然后合并得到最终答案。
- **状态数组**：使用状态数组记录状态信息，在最短路更新时根据状态进行判断和转移，确保算法的正确性。

### 可拓展之处
同类型题如存在多种移动方式且有不同限制条件的路径规划问题，或存在多种状态转移的最短路问题，都可以考虑使用分层图、枚举中间点或状态数组的方法解决。类似算法套路还有多源最短路算法（如 Floyd 算法）、状态压缩动态规划等。

### 推荐洛谷题目
- P1144 最短路计数
- P4779 【模板】单源最短路径（标准版）
- P3371 【模板】单源最短路径（弱化版）

### 个人心得摘录与总结
- **osfly**：CSP 考炸后通过水题解排泄心情，考前复习分层图但考试未考，反映出考试内容的不确定性，提醒考生要全面复习。
- **forever_nope**：指出原题未说明清楚边的计算方式，在做题时要注意题目细节，避免因理解错误导致错误。

---
处理用时：57.98秒
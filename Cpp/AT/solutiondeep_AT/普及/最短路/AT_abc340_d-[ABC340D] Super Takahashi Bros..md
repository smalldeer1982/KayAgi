# 题目信息

# [ABC340D] Super Takahashi Bros.

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc340/tasks/abc340_d

高橋君はゲームをプレイしています。

ゲームは $ 1,2,\ldots,N $ の番号がついた $ N $ 個のステージからなり、現在はステージ $ 1 $ のみを遊ぶことができます。

各ステージ $ i $ ( $ 1\leq\ i\ \leq\ N-1 $ )が遊べるとき、ステージ $ i $ では以下の $ 2 $ つのどちらかの行動を行えます。

- $ A_i $ 秒掛けてステージ $ i $ をクリアする。ステージ $ i+1 $ を遊べるようになる。
- $ B_i $ 秒掛けてステージ $ i $ をクリアする。ステージ $ X_i $ を遊べるようになる。
 
各ステージをクリアするためにかかる時間以外は無視できるとき、ステージ $ N $ を遊べるようになるのは最短で何秒後ですか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9 $
- $ 1\ \leq\ X_i\ \leq\ N $
- 入力は全て整数
 
### Sample Explanation 1

次のように行動することで、$ 350 $ 秒でステージ $ 5 $ を遊べるようになります。 - $ 100 $ 秒掛けてステージ $ 1 $ をクリアし、ステージ $ 2 $ を遊べるようになる。 - $ 50 $ 秒掛けてステージ $ 2 $ をクリアし、ステージ $ 3 $ を遊べるようになる。 - $ 200 $ 秒掛けてステージ $ 3 $ をクリアし、ステージ $ 5 $ を遊べるようになる。

## 样例 #1

### 输入

```
5

100 200 3

50 10 1

100 200 5

150 1 2```

### 输出

```
350```

## 样例 #2

### 输入

```
10

1000 10 9

1000 10 10

1000 10 2

1000 10 3

1000 10 4

1000 10 5

1000 10 6

1000 10 7

1000 10 8```

### 输出

```
90```

## 样例 #3

### 输入

```
6

1000000000 1000000000 1

1000000000 1000000000 1

1000000000 1000000000 1

1000000000 1000000000 1

1000000000 1000000000 1```

### 输出

```
5000000000```

# AI分析结果

### 题目中文重写
高桥君正在玩一款游戏。

这款游戏由编号为 $1,2,\ldots,N$ 的 $N$ 个关卡组成，当前只有关卡 $1$ 可以游玩。

当每个关卡 $i$（$1\leq i\leq N - 1$）可以游玩时，在关卡 $i$ 有以下两种行动可供选择：
- 花费 $A_i$ 秒通关关卡 $i$，之后可以游玩关卡 $i + 1$。
- 花费 $B_i$ 秒通关关卡 $i$，之后可以游玩关卡 $X_i$。

若忽略除通关各关卡所需时间之外的其他时间，那么最快在多少秒后可以游玩关卡 $N$ 呢？

### 综合分析与结论
这些题解的核心思路高度一致，均是将游戏的关卡和通关方式抽象为图论模型，把每个关卡看作图中的节点，两种通关选择对应图中的边，边权分别为 $A_i$ 和 $B_i$，进而将问题转化为求从节点 $1$ 到节点 $N$ 的最短路问题。

算法要点方面，多数题解采用堆优化的 Dijkstra 算法来求解最短路，其时间复杂度为 $O((n + m)\log n)$，由于本题中边数 $m$ 最多为 $2n$，所以时间复杂度可近似为 $O(n\log n)$。

解决的难点在于，由于 $X_i$ 的关系可能成环，不存在明确的拓扑序，无法直接使用动态规划，而图论中的最短路算法能很好地处理这种有环的情况。

### 所选题解
- **Genius_Star（4星）**
    - **关键亮点**：思路清晰，代码结构规范，对堆优化的 Dijkstra 算法实现详细，注释丰富，易于理解。
    - **核心代码**：
```cpp
struct Node{
    ll y,x;
    bool operator<(const Node&rhs)const{
        return rhs.y<y;
    }
};
ll n;
ll a[N],b[N],dis[N];
bool f[N];
vector<pair<ll,ll>> E[N];
priority_queue<Node> q;
void add(ll u,ll v,ll w){
    E[u].push_back({v,w});
}
void dijkstra(ll s){
    dis[s]=0;
    q.push({0,s});
    while(!q.empty()){
        Node t=q.top();
        q.pop();
        ll x=t.x;
        if(f[x])
            continue;
        f[x]=1;
        for(auto i:E[x]){
            ll y=i.first;
            if(dis[y]>dis[x]+i.second){
                dis[y]=dis[x]+i.second;
                if(!f[y])
                    q.push({dis[y],y});
            }
        }
    }
}
```
核心实现思想：使用邻接表存储图，利用优先队列（小根堆）优化 Dijkstra 算法，不断更新节点的最短距离。

- **Hughpig（4星）**
    - **关键亮点**：代码简洁明了，对图的存储和 Dijkstra 算法的实现较为精炼，同样有较好的可读性。
    - **核心代码**：
```cpp
struct node{
    ll dis,p;
    friend bool operator <(node a,node b){
        return a.dis>b.dis;
    }
};
priority_queue<node> pq;
void dijkstra(int s){
    dis[s]=0;
    pq.push((node){0,s});
    while(pq.size()){
        node tmp=pq.top();
        pq.pop();
        int u=tmp.p;
        if(vis[u])continue;
        vis[u]=1;
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i],w=val[u][i];
            if(dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                if(!vis[v]){
                    pq.push((node){dis[v],v});
                }
            }
        }
    }
}
```
核心实现思想：定义节点结构体和优先队列，使用邻接表存储图，在 Dijkstra 算法中不断更新最短距离。

- **SJZ2010（4星）**
    - **关键亮点**：对 Dijkstra 算法的实现较为标准，注释详细，对数据类型的使用和边界条件的处理较为严谨。
    - **核心代码**：
```cpp
struct edge
{
    int v;
    ll w;
    inline bool operator < (const edge& x) const {
        return w > x.w;
    }
};
ve G[N];
void Dijkstra() // 单源最短路
{
    pq < edge > Q;
    me(dis, 0x3f);
    dis[1] = 0;
    Q.push({1, 0});
    int u;
    while (!Q.empty())
    {
        u = Q.top().v;
        Q.pop();
        if (vis[u])
            continue;
        vis[u] = 1;
        for (edge e : G[u])
            if (dis[u] + e.w < dis[e.v])
            {
                dis[e.v] = dis[u] + e.w;
                Q.push({e.v, dis[e.v]});
            }
    }
}
```
核心实现思想：定义边的结构体，使用邻接表存储图，利用优先队列优化 Dijkstra 算法更新最短距离。

### 最优关键思路或技巧
- **图论建模**：将实际问题抽象为图论模型，通过节点和边来表示问题中的元素和关系，是解决此类问题的关键思维方式。
- **堆优化 Dijkstra 算法**：在处理稀疏图的最短路问题时，使用优先队列（小根堆）优化 Dijkstra 算法，能有效降低时间复杂度。
- **数据类型选择**：由于本题中距离可能很大，需要使用 `long long` 类型来避免溢出。

### 可拓展之处
同类型题或类似算法套路包括：
- 其他类型的图论问题，如最小生成树、拓扑排序等，可使用 Kruskal 算法、Prim 算法、拓扑排序算法等解决。
- 动态规划与图论结合的问题，如在有向无环图上的动态规划问题。

### 推荐洛谷题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

### 个人心得摘录与总结
- **apiad**：一开始想将 $x$ 反着映射然后用 DP 求解，但发现样例中有 $x_i \leq i$ 的情况，DP 无法处理有后效性的问题，从而改用最短路算法。总结：在遇到问题时，要充分考虑数据的特点和算法的适用性，当原思路不可行时，及时转换思路。
- **xixisuper**：刚看题以为是一维 DP 准备秒解，结果发现不满足无后效性，最终采用最短路径算法。总结：不能仅凭题目表面特征就确定算法，要深入分析问题的本质和数据的特性，选择合适的算法。 

---
处理用时：47.86秒
# 题目信息

# 最短経路

## 题目描述

有一张 $n$ 点 $n-1$ 边的无向图，第 $i$ 条边连接点 $a_i$ 和点 $b_i$，长度为 $c_i$。请求出是否有至少一对整数 $(i,j)$ 满足：从点 $i$ 到点 $j$ 的最短路径长度恰好为 $x$？如果是，请输出`Yes`，否则请输出`No`。

## 说明/提示

#### 数据规模与约定

- $2 \le n \le 3000$
- $1 \le a_i \lt b_i \le n$
- $1 \le c_i \le 10^5$
- $1 \le x \le 10^9$
- 保证图联通

## 样例 #1

### 输入

```
3 5

1 2 3

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 4

1 2 3

1 3 2```

### 输出

```
No```

## 样例 #3

### 输入

```
10 15

3 8 3

5 9 3

6 7 1

7 8 1

2 8 5

2 4 5

4 9 3

1 4 5

1 10 2```

### 输出

```
Yes```

# AI分析结果

### 题目翻译
# 最短路径

## 题目描述
有一张包含 $n$ 个点和 $n - 1$ 条边的无向图，第 $i$ 条边连接点 $a_i$ 和点 $b_i$，边长为 $c_i$。请判断是否至少存在一对整数 $(i, j)$，使得从点 $i$ 到点 $j$ 的最短路径长度恰好为 $x$？如果存在，请输出 `Yes`，否则输出 `No`。

## 说明/提示
#### 数据规模与约定
- $2 \le n \le 3000$
- $1 \le a_i \lt b_i \le n$
- $1 \le c_i \le 10^5$
- $1 \le x \le 10^9$
- 保证图是连通的

## 样例 #1
### 输入
```
3 5
1 2 3
1 3 2
```
### 输出
```
Yes
```

## 样例 #2
### 输入
```
3 4
1 2 3
1 3 2
```
### 输出
```
No
```

## 样例 #3
### 输入
```
10 15
3 8 3
5 9 3
6 7 1
7 8 1
2 8 5
2 4 5
4 9 3
1 4 5
1 10 2
```
### 输出
```
Yes
```

### 综合分析与结论
这几道题解的核心都是要找出图中是否存在最短路径长度为 $x$ 的点对。由于数据规模限制，$O(n^3)$ 的 Floyd 算法会超时，所以大部分题解都选择了堆优化的 Dijkstra 算法，时间复杂度为 $O(n^2\log n)$。还有一个题解利用图是树的性质，结合 Dijkstra 和 LCA 来求解。

### 题解评分与选择
- **chenzhiyv（4星）**：思路清晰，详细分析了算法选择的原因，代码中使用了快读快写优化输入输出，堆优化的 Dijkstra 实现规范。
- **easy42（3星）**：思路简单直接，但代码中部分变量命名不够清晰，整体实现中规中矩。
- **DemonPlayer（3星）**：思路和代码实现都较为常规，没有特别突出的亮点。
- **angiing1222（4星）**：利用图是树的性质，结合 Dijkstra 和 LCA 求解，思路独特，代码实现也比较完整。

### 所选题解
- **chenzhiyv（4星）**：
    - **关键亮点**：思路清晰，对算法选择有详细分析，使用快读快写优化输入输出。
- **angiing1222（4星）**：
    - **关键亮点**：利用图是树的性质，结合 Dijkstra 和 LCA 求解，思路独特。

### 重点代码与核心思想
#### chenzhiyv 的题解
```cpp
void dijkstra(int s)
{
    memset(dis,63,sizeof(dis));
    memset(vst,0,sizeof(vst));
    priority_queue<pair<int,int>,vector<pair<int,int > > ,greater<pair<int,int > > >q;
    dis[s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int u=q.top().second;
        q.pop();
        if(vst[u])
            continue;
        vst[u]=1;
        for(int i=h[u];i;i=ne[i])
        {
            int v=to[i];	
            if(dis[v]>dis[u]+w[i])
            {
                dis[v]=dis[u]+w[i];
                q.push(make_pair(dis[v],v));
            }
        }
    }
}
```
**核心思想**：以点 $s$ 为起点，使用堆优化的 Dijkstra 算法求出 $s$ 到其他所有点的最短路径，存储在 $dis$ 数组中。

#### angiing1222 的题解
```cpp
int lca(int x,int y){//倍增求lca
    if(dep[x]<dep[y])swap(x,y);
    for(int i=20;i>=0;--i){
        int nx=f[x][i];
        if(dep[nx]>=dep[y])x=nx;
        if(x==y)return x;
    }
    for(int i=20;i>=0;--i){
        if(f[x][i]!=f[y][i]){
            x=f[x][i];
            y=f[y][i];
        }
    }
    return f[x][0];
}
```
**核心思想**：使用倍增法求 $x$ 和 $y$ 的最近公共祖先，结合 Dijkstra 预处理的各点到 1 号点的距离，计算任意两点间的最短路径。

### 最优关键思路或技巧
- **算法选择**：根据数据规模选择合适的算法，避免超时。当 $n$ 较大时，放弃 $O(n^3)$ 的 Floyd 算法，选择堆优化的 Dijkstra 算法。
- **图的性质利用**：如果图是树，可以结合 Dijkstra 和 LCA 来求解最短路径问题。

### 拓展思路
同类型题或类似算法套路：
- 对于更复杂的图，可能需要使用其他算法，如 SPFA 等。
- 可以考虑在图中添加负权边，此时 Dijkstra 算法不再适用，需要使用 Bellman - Ford 或 SPFA 算法。

### 推荐洛谷题目
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)
- [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

### 个人心得
题解中未包含个人心得内容。

---
处理用时：37.25秒
# 题目信息

# [ABC146D] Coloring Edges on Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc146/tasks/abc146_d

$ N $ 頂点の木 $ G $ が与えられます。 頂点には $ 1 $ から $ N $ までの番号がついており、$ i $ 本目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結んでいます。

$ G $ の辺を何色かで塗り分けることを考えます。 このとき、各頂点について、その頂点を端点に持つ辺の色がすべて相異なるようにしたいです。

上記の条件を満たす塗り分けの中で、使用する色の数が最小であるようなものを $ 1 $ つ構築してください。

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 10^5 $
- $ 1\ \le\ a_i\ \lt\ b_i\ \le\ N $
- 入力はすべて整数
- 与えられるグラフは木である

## 样例 #1

### 输入

```
3

1 2

2 3```

### 输出

```
2

1

2```

## 样例 #2

### 输入

```
8

1 2

2 3

2 4

2 5

4 7

5 6

6 8```

### 输出

```
4

1

2

3

4

1

1

2```

## 样例 #3

### 输入

```
6

1 2

1 3

1 4

1 5

1 6```

### 输出

```
5

1

2

3

4

5```

# AI分析结果

### 题目翻译
给定一个 $N$ 个顶点的树 $G$。顶点的编号为从 $1$ 到 $N$，第 $i$ 条边连接顶点 $a_i$ 和顶点 $b_i$。

考虑用若干种颜色对 $G$ 的边进行染色。此时，希望对于每个顶点，以该顶点为端点的边的颜色都互不相同。

请构造一种满足上述条件且使用颜色数量最少的染色方案。

### 综合分析与结论
这些题解的核心思路基本一致，都围绕两个关键问题展开：一是确定最少需要的颜色数，二是构造出满足条件的染色方案。

**思路对比**：
 - 所有题解都指出最少颜色数为树中节点最大度数。
 - 在构造染色方案时，多数题解采用 DFS 遍历树，部分使用 BFS。DFS 通常从一个特定节点（如度数最大的节点或 1 号节点）开始，在遍历过程中为边依次分配颜色，同时确保每个节点的出边颜色不同；BFS 则按层次遍历节点，同样遵循边颜色不同的规则。

**算法要点**：
 - **图的存储**：使用邻接表（如 `vector`、数组模拟链表等）存储树的结构。
 - **度数统计**：在输入边的信息时，统计每个节点的度数，找出最大度数。
 - **染色过程**：根据遍历顺序，为边分配颜色，避免同一节点的出边颜色相同。

**解决难点**：
 - **颜色分配**：在为边分配颜色时，需要避免与该节点已有的出边颜色重复。多数题解通过记录上一条边的颜色，在分配新颜色时跳过该颜色来解决。
 - **输出顺序**：题目要求按边的输入顺序输出颜色，部分题解需要额外处理以确保输出顺序正确。

### 评分较高的题解
- **liaoxingrui（4星）**：
    - **关键亮点**：思路清晰，代码简洁，通过邻接表存储图，DFS 遍历构造染色方案，能很好地解决问题。
    - **核心代码**：
```cpp
void dfs(int node,int last){
    int sum=0;
    for(int i=head[node];i;i=nex[i].y){
        int w=nex[i].x;
        if(w!=fa[node]){
            sum++;
            if(sum==last)
                sum++;
            fa[w]=node;
            ans[w]=sum;
            dfs(w,sum);
        }
    }
}
```
核心实现思想：从指定节点开始 DFS 遍历，为每个节点的出边依次分配颜色，若当前颜色与上一条边颜色相同则跳过。

- **high_sky（4星）**：
    - **关键亮点**：代码有详细注释，逻辑清晰，使用 `vector` 存储邻接表，递归涂色实现染色方案。
    - **核心代码**：
```cpp
void dfs(int x,int pre_id){//pre_id为连接父子点的边
    int col=1;
    for(auto i:g[x]){//进行涂色
        int v=i.first,now_id=i.second;
        if(now_id==pre_id)continue;
        if(col==c[pre_id])col++;//重复颜色就加
        c[now_id]=col++;
        dfs(v,now_id);//递归涂色
    }
}
```
核心实现思想：从指定节点开始 DFS 遍历，为每个节点的出边依次分配颜色，若当前颜色与父节点到该节点的边颜色相同则跳过。

- **expecto__patronum（4星）**：
    - **关键亮点**：思路明确，通过邻接表存储图，DFS 染色时采用取模操作，代码实现简洁。
    - **核心代码**：
```cpp
void dfs(int root,int fa,int color,int color_num){
    for(int i = head[root];~i;i = edge[i].next){
        int y = edge[i].to;
        if(y != fa){
            hap[{root,y}] = hap[{y,root}] = color;//染色
            color = (++color)%color_num;
            dfs(y,root,color,color_num);
        }
    }
}
```
核心实现思想：从指定节点开始 DFS 遍历，为每个节点的出边依次分配颜色，使用取模操作确保颜色在有效范围内。

### 最优关键思路或技巧
- **确定最少颜色数**：通过统计节点的最大度数来确定最少需要的颜色数，这是解决问题的关键思路。
- **DFS 染色**：从一个特定节点开始 DFS 遍历树，在遍历过程中为边依次分配颜色，通过记录上一条边的颜色来避免颜色冲突。
- **邻接表存储**：使用邻接表存储图的结构，方便进行图的遍历和操作。

### 可拓展之处
同类型题或类似算法套路：
 - **图的染色问题**：对于一般的图（不一定是树），也可以使用类似的思路进行染色，但可能需要更复杂的算法，如回溯法、贪心算法等。
 - **约束满足问题**：这类问题通常需要在满足一定约束条件下找到可行解，可以使用搜索算法（如 DFS、BFS）或启发式算法来解决。

### 推荐洛谷题目
- [P1522 牛的旅行](https://www.luogu.com.cn/problem/P1522)：涉及图的遍历和距离计算，与图的处理相关。
- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)：需要处理任务之间的依赖关系，可使用图的拓扑排序解决。
- [P1341 无序字母对](https://www.luogu.com.cn/problem/P1341)：与图的欧拉路径相关，需要对图进行遍历和判断。

### 个人心得摘录与总结
- **ny_Dacong**：在打线下赛时，因 `freopen` 函数使用错误（`freopen("color.out","r",stdout);`）导致 100 分变为 0 分。总结：在使用文件输入输出时要仔细检查，避免出现类似错误。 

---
处理用时：37.00秒
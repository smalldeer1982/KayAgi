# 题目信息

# [ARC162B] Insertion Sort 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc162/tasks/arc162_b

$ (1,2,\ldots,N) $ の順列 $ P=(P_1,P_2,\ldots,P_N) $ が与えられます。

$ P $ に対し以下の操作を $ 2\times\ 10^3 $ 回以下行うことで $ P $ を昇順に並び替えられるか判定し、可能な場合は実際に操作手順を一つ示してください。

- $ 1\leq\ i\ \leq\ N-1,0\ \leq\ j\ \leq\ N-2 $ を満たす整数 $ i,j $ を選ぶ。$ Q\ =\ (Q_1,\ Q_2,\ldots,Q_{N-2}) $ を $ P $ から $ (P_i,P_{i+1}) $ を抜き出して得られる列としたとき、$ P $ を $ (Q_1,\ldots,Q_j,\ P_i,\ P_{i+1},\ Q_{j+1},\ldots,Q_{N-2}) $ で置き換える。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^3 $
- $ P $ は $ (1,2,\ldots,N) $ の順列
- 入力される数値は全て整数
 
### Sample Explanation 1

$ i=3,j=1 $ として操作を行います。 $ Q=(P_1,P_2,P_5)=(1,4,5) $ になるので、$ P=(Q_1,P_3,P_4,Q_2,Q_3)\ =\ (1,2,3,4,5) $ となります。 よって $ 1 $ 回の操作で $ P $ を昇順に並び替えられます。

### Sample Explanation 2

$ 2\times\ 10^3 $ 回以下の操作では $ P $ を昇順に並び替えられないことが証明できます。

### Sample Explanation 3

操作回数を最小化する必要はありません。

## 样例 #1

### 输入

```
5

1 4 2 3 5```

### 输出

```
Yes

1

3 1```

## 样例 #2

### 输入

```
2

2 1```

### 输出

```
No```

## 样例 #3

### 输入

```
4

3 4 1 2```

### 输出

```
Yes

3

3 0

1 2

3 0```

# AI分析结果

### 题目内容中文重写
# [ARC162B] 插入排序 2

## 题目描述
[problemUrl]: https://atcoder.jp/contests/arc162/tasks/arc162_b

给定一个 $(1, 2, \ldots, N)$ 的排列 $P = (P_1, P_2, \ldots, P_N)$。

判断是否可以通过对 $P$ 进行 $2\times 10^3$ 次以下的操作将 $P$ 按升序排序，如果可以，则给出一个实际的操作步骤。

- 选择满足 $1\leq i\leq N - 1$，$0\leq j\leq N - 2$ 的整数 $i$ 和 $j$。设 $Q = (Q_1, Q_2, \ldots, Q_{N - 2})$ 是从 $P$ 中取出 $(P_i, P_{i + 1})$ 后得到的序列，将 $P$ 替换为 $(Q_1, \ldots, Q_j, P_i, P_{i + 1}, Q_{j + 1}, \ldots, Q_{N - 2})$。

## 说明/提示
### 制约束
- $2\leq N\leq 10^3$
- $P$ 是 $(1, 2, \ldots, N)$ 的排列
- 输入的所有数值均为整数

### 样例解释 1
选择 $i = 3$，$j = 1$ 进行操作。此时 $Q = (P_1, P_2, P_5) = (1, 4, 5)$，因此 $P = (Q_1, P_3, P_4, Q_2, Q_3) = (1, 2, 3, 4, 5)$。因此，通过 1 次操作就可以将 $P$ 按升序排序。

### 样例解释 2
可以证明，在 $2\times 10^3$ 次以下的操作中无法将 $P$ 按升序排序。

### 样例解释 3
不需要最小化操作次数。

## 样例 #1
### 输入
```
5
1 4 2 3 5
```
### 输出
```
Yes
1
3 1
```

## 样例 #2
### 输入
```
2
2 1
```
### 输出
```
No
```

## 样例 #3
### 输入
```
4
3 4 1 2
```
### 输出
```
Yes
3
3 0
1 2
3 0
```

### 综合分析与结论
- **思路对比**：三位作者都采用了贪心的思想，从左到右或从右到左依次将数字放到正确位置。FyFive 和 KυρωVixen 是从左到右，先排小的数字；CrTsIr400 是从右到左，先排大的数字。
- **算法要点**：核心都是每次选取相邻两个数移动到合适位置。对于要排序的数字在序列末尾的情况，都采用将末尾的相邻两个数往前移动的方法来处理。
- **解决难点**：主要难点在于处理要排序的数字在末尾时无法选取相邻两个数的情况，以及判断无解的情况（即最后两个数顺序错误）。

### 题解评分
- FyFive：4 星。思路清晰，代码核心部分简洁明了，对算法思路和无解情况的分析很清晰。
- KυρωVixen：3 星。思路较为详细，有对算法问题的分析和补救措施，但代码中使用 `goto` 语句影响代码可读性。
- CrTsIr400：3 星。思路有一定的分析过程，但代码中使用自定义类型别名和一些不常见的写法，降低了代码的可读性。

### 所选题解
- FyFive（4 星）
  - 关键亮点：思路清晰，对算法的分析和无解情况的判断很明确，核心代码简洁。

### 重点代码
```cpp
for(int i=1;i<=n-2;++i)
{
    int wz=1; for(int j=1;j<=n;++j) if(p[j]==i) wz=j; 
    if(wz==i) continue;
    if(wz==n)
    {
        ai[++ans]=n-1; aj[ans]=n-3; change(ai[ans],aj[ans]);
        ai[++ans]=n-1; aj[ans]=i-1; change(ai[ans],aj[ans]);
    }
    else {ai[++ans]=wz,aj[ans]=i-1; change(ai[ans],aj[ans]);}
}
if(p[n-1]>p[n]) ans=-1;
```
**核心实现思想**：从左到右依次将数字 $i$ 放到第 $i$ 个位置。如果数字 $i$ 正好在第 $i$ 个位置则跳过；如果数字 $i$ 在末尾，先将最后两个数往前移一位，再将其移到正确位置；否则直接将其移到正确位置。最后判断最后两个数是否顺序错误，若错误则无解。

### 最优关键思路或技巧
- 采用贪心策略，从左到右或从右到左依次将数字放到正确位置。
- 对于要排序的数字在末尾的情况，将末尾的相邻两个数往前移动，使其可以被选取。
- 直接模拟操作过程，因为 $N$ 较小，平方复杂度可以接受。

### 可拓展之处
同类型题可能会改变操作规则，如每次选取相邻的 $k$ 个数进行移动，或者改变判断条件等。类似算法套路可以是通过有限次操作将序列转换为目标序列，关键在于找到合适的贪心策略和处理特殊情况的方法。

### 推荐洛谷题目
- P1115 最大子段和（考察贪心和动态规划思想）
- P1223 排队接水（考察贪心策略）
- P1090 合并果子（考察贪心和优先队列的使用）

### 个人心得摘录与总结
KυρωVixen 提到赛时因为有个地方忘了记录方案没有 AC，但是赛后十分钟就做出来了。总结就是在比赛中要注意细节，记录好操作步骤等关键信息，避免因为小失误而丢分。 

---
处理用时：35.30秒
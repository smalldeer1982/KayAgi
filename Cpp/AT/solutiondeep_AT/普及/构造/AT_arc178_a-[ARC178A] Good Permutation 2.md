# 题目信息

# [ARC178A] Good Permutation 2

## 题目描述

给定一个正整数 $N$ 和一个长度为 $M$ 的正整数序列 $A=(1,2,\cdots,A_M)$。

其中，$A$ 中的所有元素都是介于 $1$ 和 $N$ 之间的不同整数。（即 $A$ 是 $N$ 的一个排列）

定义：
- 排列 $P=(P_1,P_2,\cdots,P_N)$ 是一个**好排列**，当且仅当：$P$ 没有连续子序列是 $A=(1,2,⋯ ,A_i)$ 的排列，其中 $1\le i\le M$。


确定是否存在这样的**好排列**，如果存在，找到**字典序最小**的好排列。

## 说明/提示

- $ 1\leq\ M\leq\ N\leq\ 2\times\ 10^{5} $
- $ 1\leq\ A_{i}\leq\ N $
- $ A $ 中的所有元素都是不同的。
- 所有输入值都是整数。

 
### 样例解释1
例如，$(4,2,1,3)$ 不是一个 好排列，因为它包含 $(2,1)$  作为连续子序列。

其他非好排列包括 $(1,2,3,4)$ 和 $(3,4,2,1)$。

一些好排列包括 $(4,1,3,2)$ 和 $(2,3,4,1)$。其中，字典序最小的排列是 $(1,3,2,4)$。

### 样例解释2
好排列的示例包括 $(3,1,4,5,2)$、$(2,4,5,3,1)$ 和 $(4,1,5,2,3)$。

非好排列的示例包括 $(1,2,5,3,4)$、$(2,3,4,1,5)$ 和$(5,3,1,2,4)$。

### 样例解释3
不存在好排列，输出 `-1`。

## 样例 #1

### 输入

```
4 1

2```

### 输出

```
1 3 2 4```

## 样例 #2

### 输入

```
5 3

4 3 2```

### 输出

```
1 3 4 5 2```

## 样例 #3

### 输入

```
92 4

16 7 1 67```

### 输出

```
-1```

## 样例 #4

### 输入

```
43 2

43 2```

### 输出

```
-1```

# AI分析结果

### 题目内容中文重写
本题内容已经是中文，无需重写。

### 综合分析与结论
这些题解整体思路一致，先判断无解情况，即序列 $A$ 中出现 $1$ 或 $N$ 时无解；再利用贪心策略构造字典序最小的好排列。各题解在实现细节上有所不同，但核心都是通过交换元素来避免出现 $A$ 子序列的排列。

### 各题解思路、算法要点及难点对比
|作者|思路|算法要点|解决难点|
| ---- | ---- | ---- | ---- |
|yedalong|先判断无解，再假设答案为 $1$ 到 $N$ 的顺序排列，对 $A$ 排序后，依次交换答案序列中第 $A_i$ 个和第 $A_{i + 1}$ 个位置的元素|排序、交换元素|如何保证字典序最小且避免出现 $A$ 子序列的排列|
|Pink_Cut_Tree|先判断无解，贪心处理，对 $A$ 排序，遇到不满足条件时交换当前处理到的最后一个数与下一个数的位置|排序、交换元素|判断何时需要交换元素|
|Dtw_|先判断无解，按 $1$ 到 $N$ 顺序放元素，对 $A$ 排序，出现不满足条件时交换区间最后一个数字和下一个数字|排序、交换元素|处理不满足条件的区间|
|ilibilib|先判断无解，贪心生成序列，用 `bitset` 维护，若存在 $A_i = x$ 且前 $x$ 位最大值不大于 $x$，则放 $x + 1$|`bitset` 维护、贪心|判断何时需要放 $x + 1$|
|Heldivis|先判断无解，将答案数组初始化为 $1$ 到 $N$，对 $A$ 排序，对每个 $x \in A$，交换 $res_x$ 和 $res_{x + 1}$|排序、交换元素|保证符合要求且字典序最小|
|xk2013|先判断无解，将 $A$ 升序排序，按 $1$ 到 $N$ 存答案，用变量 $pos$ 判断是否符合条件，不符合则交换元素|排序、交换元素、变量判断|判断是否符合条件及如何修改答案|
|fydj|先判断无解，把 $1$ 到 $N$ 放入 `set`，从前往后填，有 $A_i$ 限制时填大于 $i$ 的最小数，否则填最小数|`set` 存储、贪心|处理有 $A_i$ 限制的情况|
|Sirkey|先判断无解，对 $A$ 排序，将 $b$ 数组初始化为 $1$ 到 $N$，将 $b$ 中第 $a_i$ 个元素换到后面|排序、交换元素|证明贪心策略的最优性|

### 题解评分
|作者|评分|
| ---- | ---- |
|yedalong|4星|
|Pink_Cut_Tree|4星|
|Dtw_|4星|
|ilibilib|3星|
|Heldivis|3星|
|xk2013|4星|
|fydj|3星|
|Sirkey|3星|

### 所选题解
- **yedalong（4星）**
    - **关键亮点**：思路清晰，代码简洁，直接交换元素构造排列。
    - **核心代码**：
```cpp
sort(a + 1, a + 1 + m);
for(int i = 1; i <= n; i++) ans[i] = i;
if(a[1] == 1 || a[m] == n) cout << -1;
else{
    for(int i = 1; i <= m; i++) swap(ans[a[i]], ans[a[i] + 1]);
    for(int i = 1; i <= n; i++) cout << ans[i] << ' ';
}
```
核心实现思想：先对 $A$ 排序，初始化答案数组为 $1$ 到 $N$ 的顺序排列，判断无解情况，若有解则依次交换答案数组中第 $A_i$ 个和第 $A_{i + 1}$ 个位置的元素。

- **Pink_Cut_Tree（4星）**
    - **关键亮点**：思路简洁，代码可读性高，用变量 `pos` 控制交换。
    - **核心代码**：
```cpp
for(int i = 1; i <= m; i++){
    cin >> a[i];
    if(a[i] == 1 || a[i] == n){
        cout << "-1"; return 0;
    }
}
for(int i = 1; i <= n; i++){
    ans[i] = i;
}
sort(a + 1, a + m + 1);
int pos = 1;
for(int i = 1; i <= n; i++){
    if(a[pos] == i){ 
        swap(ans[i], ans[i + 1]), pos++;
    }
}
```
核心实现思想：输入 $A$ 并判断无解情况，初始化答案数组，对 $A$ 排序，用变量 `pos` 遍历 $A$，当 $a[pos] == i$ 时交换答案数组中第 $i$ 个和第 $i + 1$ 个位置的元素。

- **Dtw_（4星）**
    - **关键亮点**：思路清晰，详细分析了时间复杂度。
    - **核心代码**：
```cpp
sort(a + 1, a + m + 1);
if(a[1] == 1 || a[m] == n){
    cout << -1;
    return 0;
}
for(int i = 1; i <= n; i++){
    ans[i] = i;
}
int j = 1;
for(int i = 1; i <= n; i++){
    if(a[j] == i){
        swap(ans[i], ans[i + 1]);
        j++;
    }
}
```
核心实现思想：对 $A$ 排序，判断无解情况，初始化答案数组，用变量 `j` 遍历 $A$，当 $a[j] == i$ 时交换答案数组中第 $i$ 个和第 $i + 1$ 个位置的元素。

### 最优关键思路或技巧
- **贪心策略**：要求字典序最小，先按 $1$ 到 $N$ 顺序排列元素，再通过交换元素避免出现 $A$ 子序列的排列。
- **排序**：对 $A$ 排序后可线性处理，方便判断和交换元素。

### 可拓展之处
同类型题可考察不同的排列限制条件，如限制子序列的长度、元素和等。类似算法套路可用于解决其他构造类问题，通过贪心策略和排序优化来构造满足条件的序列。

### 洛谷相似题目推荐
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得摘录与总结
- **xk2013**：作者作为五年级小学生分享第20篇题解，鼓励大家认真看思路，不要只复制代码。总结：学习算法要注重理解思路，不能单纯抄袭代码。 

---
处理用时：41.07秒
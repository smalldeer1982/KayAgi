# 题目信息

# [ARC183A] Median of Good Sequences

## 题目描述

给定正整数 $N,K$ ，如果一个长度为 $NK$ 的序列中 $1$ 以上 $N$ 以下的整数分别出现了 $K$ 次，则称这个序列为良好序列，设有 $S$ 个良好序列，则输出按字典序从小到大第  floor $((S+1)/2)$ 个良好序列。其中， floor $(x)$ 表示不超过 $x$ 的最大整数。

## 说明/提示

#### 约束

 $1≤N≤500$ 

 $1≤K≤500$ 

输入的所有值均为整数

#### 示例解释1

 $6$ 个良好序列如下：
 $(1,1,2,2)$ 
 $(1,2,1,2)$ 
 $(1,2,2,1)$ 
 $(2,1,1,2)$
 $(2,1,2,1)$
 $(2,2,1,1)$ 
 
因此，按字典顺序排列的第 $3$ 个良好序列 $(1,2,2,1)$ 就是答案。

## 样例 #1

### 输入

```
2 2```

### 输出

```
1 2 2 1```

## 样例 #2

### 输入

```
1 5```

### 输出

```
1 1 1 1 1```

## 样例 #3

### 输入

```
6 1```

### 输出

```
3 6 5 4 2 1```

## 样例 #4

### 输入

```
3 3```

### 输出

```
2 2 2 1 3 3 3 1 1```

# AI分析结果

### 题解综合分析与结论
这些题解主要围绕找出按字典序排列的第 $\lfloor \frac{S + 1}{2} \rfloor$ 个良好序列展开，关键在于根据 $N$ 的奇偶性进行分类讨论。
- **思路对比**：多数题解通过分析 $N$ 奇偶性下排列的规律来确定答案。如当 $N$ 为偶数时，开头为 $\frac{N}{2}$ 并将剩余数从大到小排列；当 $N$ 为奇数时，先填 $K$ 个 $\frac{N + 1}{2}$ 再按偶数情况处理。xxxaIq 的题解则通过可重排列公式确定每个位置的值。
- **算法要点**：核心算法要点是利用排列规律和贪心策略，时间复杂度大多为 $O(NK)$。
- **解决难点**：难点在于发现不同 $N$ 奇偶性下排列的对称关系以及中间排列的特征，从而避免枚举所有排列。

### 所选题解
- **zlqwq（5星）**：
    - **关键亮点**：思路清晰，代码简洁，直接根据 $N$ 的奇偶性进行处理，时间复杂度为 $O(NK)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[505];
signed main(){
    cin>>n>>k;
    if(n==1){
        while(k--){
            cout<<1<<" ";
        }
        return 0;
    }
    for(int i=1;i<=n;++i)a[i]=k;
    if(n%2){
        for(int i=1;i<=k;++i)cout<<n/2+1<<" ";
        a[n/2+1]=0;
        cout<<n/2<<" ";
        a[n/2]--;
        for(int i=n;i>=1;--i){
            while(a[i]){
                a[i]--;
                cout<<i<<" ";
            }
        }
    }
    else{
        cout<<n/2<<" ";
        a[n/2]--;
        for(int i=n;i>=1;--i){
            while(a[i]){
                a[i]--;
                cout<<i<<" ";
            }
        }
    }
    return 0;
}
```
核心实现思想：先处理 $N = 1$ 的特殊情况，然后用数组记录每个数剩余的个数。根据 $N$ 的奇偶性进行不同处理，奇数时先输出 $K$ 个 $\frac{N}{2} + 1$ 和一个 $\frac{N}{2}$，偶数时先输出 $\frac{N}{2}$，再将剩余数从大到小输出。

- **Presentation_Emitter（4星）**：
    - **关键亮点**：从序列翻转的角度分析问题，得出待求序列的特征，思路独特。
```cpp
// 伪代码，原答案给的是链接
// 关键思路：利用序列翻转后字典序的变化关系，确定首个元素，再根据N的奇偶性处理
```
核心实现思想：考虑序列翻转后字典序的变化，得出待求序列的特征。若 $N$ 为奇数，先填 $K$ 个 $\lceil \frac{N}{2} \rceil$，再按偶数情况处理；若 $N$ 为偶数，最大化剩余部分的字典序。

- **HNOIRPplusplus（4星）**：
    - **关键亮点**：通过分析序列元素变换后的对应关系，得出 $N$ 奇偶性下的解题策略。
```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

signed main() {
  int n, k;
  cin >> n >> k;
  if(n == 1) {
    for(int i = 1; i <= k; i++) {
      cout << "1 ";
    }
    return 0;
  }
  if(n % 2) {
    for(int i = 1; i <= k; i++) {
      cout << (n + 1) / 2 << ' ';
    }
  }
  cout << n / 2 << ' ';
  for(int i = n; i; i--) {
    for(int j = 1; j <= k - (i == n / 2); j++) {
      if(2 * i - 1 != n) {
        cout << i << ' ';
      }
    }
  }
}
```
核心实现思想：当 $N$ 为偶数时，找出 $\frac{N}{2}$ 开头的最大序列；当 $N$ 为奇数时，先放 $K$ 个 $\frac{N + 1}{2}$，再按偶数情况处理。

### 最优关键思路或技巧
- **分类讨论**：根据 $N$ 的奇偶性进行分类讨论，简化问题。
- **对称关系**：利用序列的对称关系，确定中间排列的特征，避免枚举所有排列。

### 可拓展之处
同类型题可能会改变序列的定义或排列规则，但核心思路仍可围绕分类讨论和对称关系展开。类似算法套路可用于解决其他排列组合中求特定位置排列的问题。

### 推荐洛谷题目
1. P1088 [NOIP2004 普及组] 火星人
2. P1338 末日的传说
3. P1706 全排列问题

### 个人心得
题解中未包含个人心得。 

---
处理用时：31.73秒
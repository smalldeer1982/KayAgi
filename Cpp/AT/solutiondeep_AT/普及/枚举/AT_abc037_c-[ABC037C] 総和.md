# 题目信息

# [ABC037C] 総和

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc037/tasks/abc037_c

長さ $ N $ の数列 $ \{a_i\} $ と$ 1 $ 以上 $ N $ 以下の整数 $ K $ が与えられます。 この数列には長さ $ K $ の連続する部分列が $ N-K+1 $ 個あります。これらのそれぞれ部分列に含まれる値の合計の総和を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 10^5 $
- $ 0\ \leq\ a_i\ \leq\ 10^8 $
- $ a_i $ は整数である。

### 部分点

- 50 点分のテストケースでは、 $ N\ \leq\ 10^3 $ である。

### Sample Explanation 1

$ (1+2+4)+(2+4+8)+(4+8+16)=49 $ なので、答えは $ 49 $ です。

### Sample Explanation 2

オーバーフローに注意してください。

## 样例 #1

### 输入

```
5 3

1 2 4 8 16```

### 输出

```
49```

## 样例 #2

### 输入

```
20 10

100000000 100000000 98667799 100000000 100000000 100000000 100000000 99986657 100000000 100000000 100000000 100000000 100000000 98995577 100000000 100000000 99999876 100000000 100000000 99999999```

### 输出

```
10988865195```

# AI分析结果

### 题目翻译
# [ABC037C] 总和

## 题目描述
[problemUrl]: https://atcoder.jp/contests/abc037/tasks/abc037_c

给定一个长度为 $ N $ 的数列 $ \{a_i\} $ 以及一个 $ 1 $ 到 $ N $ 之间的整数 $ K $。这个数列有 $ N - K + 1 $ 个长度为 $ K $ 的连续子数列。请计算这些子数列中所有元素值的总和。

## 说明/提示
### 限制条件
- $ 1 \leq K \leq N \leq 10^5 $
- $ 0 \leq a_i \leq 10^8 $
- $ a_i $ 为整数。

### 部分分
- 在占 50 分的测试用例中，$ N \leq 10^3 $。

### 示例解释 1
因为 $ (1 + 2 + 4) + (2 + 4 + 8) + (4 + 8 + 16) = 49 $，所以答案是 $ 49 $。

### 示例解释 2
请注意避免溢出。

## 样例 #1
### 输入
```
5 3
1 2 4 8 16
```
### 输出
```
49
```

## 样例 #2
### 输入
```
20 10
100000000 100000000 98667799 100000000 100000000 100000000 100000000 99986657 100000000 100000000 100000000 100000000 100000000 98995577 100000000 100000000 99999876 100000000 100000000 99999999
```
### 输出
```
10988865195
```

### 综合分析与结论
| 作者 | 思路 | 算法要点 | 解决难点 | 评分 |
| --- | --- | --- | --- | --- |
| wdcxz | 直接模拟，枚举所有长度为 $ K $ 的连续子数列并求和 | 双重循环遍历所有子数列 | 数据范围较大，使用 `long long` 避免溢出 | 3星 |
| da32s1da | 计算每个元素被加的次数，通过公式计算总和 | 找出元素被加次数的规律 $ a[i] $ 被加的次数为 $ min(min(i,n - i + 1),min(m,n - m + 1)) $ | 总结出元素被加次数的规律 | 3星 |
| kingder_man | 利用前缀和计算区间和 | 先计算前缀和数组，再通过前缀和数组计算区间和 | 正确计算前缀和并利用其计算区间和 | 4星 |
| LeeChain | 使用线段树进行区间求和 | 构建线段树，通过线段树查询区间和 | 线段树的构建和查询操作 | 3星 |
| cq_loves_Capoo | 尺取法，通过移动窗口计算区间和 | 先计算第一段区间和，然后通过窗口移动更新区间和 | 窗口移动时正确更新区间和 | 3星 |
| liulif | 先计算前 $ k - 1 $ 项和，再依次更新连续 $ k $ 项和并累加 | 避免重复计算，通过减去第一个数更新和 | 正确更新连续 $ k $ 项和 | 3星 |
| Violet9567 | 简单数论，利用前 $ i $ 项和与前 $ i - k $ 项和的差计算区间和 | 计算前 $ i $ 项和数组，通过公式计算区间和 | 正确使用公式计算区间和 | 3星 |
| 迷残云 | 使用树状数组进行区间查询 | 构建树状数组，通过树状数组查询区间和 | 树状数组的构建和查询操作 | 3星 |
| wushuang0828 | 先计算前 $ k $ 个数的和，再依次更新区间和并累加 | 类似尺取法，通过减去第一个数更新和 | 正确更新区间和 | 3星 |
| 珅肐 | 前缀和优化模拟，先计算前缀和数组，再通过前缀和数组计算区间和 | 计算前缀和数组，通过前缀和数组计算区间和 | 正确计算前缀和并利用其计算区间和 | 3星 |
| Hola_chen | 直接模拟，通过 `while` 循环取 $ k $ 的区间并求和 | 双重循环遍历所有子数列 | 数据范围较大，使用 `long long` 避免溢出 | 3星 |

### 所选题解
- **作者：kingder_man（4星）**
    - **关键亮点**：思路清晰，使用前缀和优化算法，降低时间复杂度，代码可读性高。
    - **个人心得**：作者提到因为没初始化前缀和数组 WA 了 3 次，提醒大家要注意数组初始化。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100010],num[100010]={0};
long long n,k,sum=0;
int main()
{
    cin>>n>>k;
    for(int  i=1;i<=n;i++)
    {
        cin>>a[i];
        num[i]=num[i-1]+a[i];
    }
    for(int i=k;i<=n;i++)
    {
        sum+=num[i]-num[i-k];
    }
    cout<<sum<<endl;
    return 0;
}
```
**核心实现思想**：先通过循环计算前缀和数组 `num`，其中 `num[i]` 表示 `a[1]` 到 `a[i]` 的和。然后通过 `num[i] - num[i - k]` 计算长度为 `k` 的区间和，并累加到 `sum` 中。

### 最优关键思路或技巧
- 使用前缀和可以将计算区间和的时间复杂度从 $ O(k) $ 降低到 $ O(1) $，避免了重复计算。
- 对于数据范围较大的情况，使用 `long long` 类型避免溢出。

### 可拓展之处
同类型题如区间求和、区间修改等问题都可以考虑使用前缀和、线段树、树状数组等数据结构来优化算法。类似算法套路如尺取法可以用于解决连续子数组相关问题。

### 洛谷题目推荐
- P1115 最大子段和
- P3374 【模板】树状数组 1
- P3372 【模板】线段树 1

### 个人心得总结
- kingder_man 提到要注意数组初始化，否则可能导致错误。
- 迷残云 提醒在 AT 的题中要注意换行。

---
处理用时：44.06秒
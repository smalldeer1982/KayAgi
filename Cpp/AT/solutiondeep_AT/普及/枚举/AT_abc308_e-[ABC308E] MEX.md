# 题目信息

# [ABC308E] MEX

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc308/tasks/abc308_e

$ 0,1,2 $ からなる長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ と、 `M`, `E`, `X` からなる長さ $ N $ の文字列 $ S=S_1S_2\dots\ S_N $ が与えられます。

$ 1\ \leq\ i\ <\ j\ <\ k\ \leq\ N $ かつ $ S_iS_jS_k= $ `MEX` を満たす全ての整数の組 $ (i,j,k) $ に対する $ \text{mex}(A_i,A_j,A_k) $ の総和を求めてください。 ここで、$ \text{mex}(A_i,A_j,A_k) $ は $ A_i,A_j,A_k $ のいずれとも一致しない最小の非負整数を意味します。

## 说明/提示

### 制約

- $ 3\leq\ N\ \leq\ 2\times\ 10^5 $
- $ N $ は整数
- $ A_i\ \in\ \lbrace\ 0,1,2\rbrace $
- $ S $ は `M`, `E`, `X` からなる長さ $ N $ の文字列
 
### Sample Explanation 1

$ S_iS_jS_k $ = `MEX` となる $ i,j,k\ (1\ \leq\ i\ <\ j\ <\ k\ \leq\ N) $ の組は $ (i,j,k)=(1,2,4),(1,3,4) $ の $ 2 $ つです。 $ \text{mex}(A_1,A_2,A_4)=\text{mex}(1,1,2)=0,\text{mex}(A_1,A_3,A_4)=\text{mex}(1,0,2)=3 $ より答えは $ 0+3=3 $ です。

## 样例 #1

### 输入

```
4

1 1 0 2

MEEX```

### 输出

```
3```

## 样例 #2

### 输入

```
3

0 0 0

XXX```

### 输出

```
0```

## 样例 #3

### 输入

```
15

1 1 2 0 0 2 0 2 0 0 0 0 0 2 2

EXMMXXXEMEXEXMM```

### 输出

```
13```

# AI分析结果

### 题目翻译
给定一个由 $0$、$1$、$2$ 组成的长度为 $N$ 的数列 $A=(A_1,A_2,\dots,A_N)$ 以及一个由 `M`、`E`、`X` 组成的长度为 $N$ 的字符串 $S=S_1S_2\dots S_N$。

请计算满足 $1 \leq i < j < k \leq N$ 且 $S_iS_jS_k = $ `MEX` 的所有整数组 $(i,j,k)$ 对应的 $\text{mex}(A_i,A_j,A_k)$ 的总和。这里，$\text{mex}(A_i,A_j,A_k)$ 表示与 $A_i$、$A_j$、$A_k$ 均不相等的最小非负整数。

### 综合分析与结论
这些题解的核心思路主要围绕如何高效地统计满足条件的三元组 $(i, j, k)$ 对应的 $\text{mex}(A_i, A_j, A_k)$ 之和。由于 $N$ 最大可达 $2\times10^5$，直接 $O(N^3)$ 暴力枚举不可行，因此各题解采用了不同的优化策略。
- **思路对比**：
    - 部分题解（如 zac2010、未来姚班zyl）采用从左到右扫描的方式，逐步维护中间状态，最后统计答案。
    - 部分题解（如 CQ_Bob、梦应归于何处、引领天下、xiaoming007、FreedomKing）以 `E` 为中间点，通过预处理前缀和与后缀和，分别统计 `E` 左边 `M` 和右边 `X` 的不同取值的数量，再根据组合数计算答案。
    - incra 题解将 `MEX` 分为 `M` 和 `EX` 两部分，先处理 `EX` 的方案数，再结合 `M` 的数量计算答案。
    - Msents 题解预处理 $sum$ 数组，快速计算满足条件的三元组数量。
    - Elairin176 题解对 $\text{mex}$ 情况进行预处理，通过递推计算后缀和与 `EX` 子序列数量。
- **算法要点**：
    - 各题解都需要预处理 $\text{mex}$ 函数，用于计算不同取值组合下的 $\text{mex}$ 值。
    - 多数题解利用前缀和、后缀和或中间状态的维护来减少重复计算，将复杂度控制在 $O(N)$ 或接近 $O(N)$。
- **解决难点**：
    - 如何避免 $O(N^3)$ 的暴力枚举，通过合理的数据结构和算法优化来降低复杂度。
    - 准确处理不同字符（`M`、`E`、`X`）和不同取值（$0$、$1$、$2$）的组合情况，避免遗漏或重复计算。

### 评分较高的题解
- **zac2010（5星）**：
    - **关键亮点**：思路清晰，代码简洁，通过简单的计数方式，从左到右依次处理 `M`、`E`、`X`，逐步维护状态并统计答案，易于理解和实现。
    - **核心代码**：
```cpp
L(i, 1, n){
    if(s[i] == 'M'){
        c[a[i]]++;
    }
    else if(s[i] == 'E'){
        L(j, 0, 2) if(c[j]) t[min(j, a[i])][max(j, a[i])] += c[j];
    }
    else{
        L(j, 0, 2) L(k, j, 2){
            if(a[i] < j) ans += t[j][k] * mex(a[i], j, k);
            else if(a[i] >= k) ans += t[j][k] * mex(j, k, a[i]);
            else ans += t[j][k] * mex(j, a[i], k);
        }
    }
}
```
核心实现思想：先维护 `M` 位置上不同取值的数量，再根据 `M` 的数量维护 `M` 和 `E` 组合的方案数，最后根据 `M` 和 `E` 的组合方案数以及当前 `X` 的取值计算 $\text{mex}$ 并累加到答案中。
- **CQ_Bob（4星）**：
    - **关键亮点**：通过推导 $\text{mex}$ 的不同取值情况，以 `E` 为中间点，利用前缀和与后缀和分别统计 `M` 和 `X` 的不同取值数量，按照组合数计算答案，逻辑清晰。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    cin>>s[i];
    sa0[i]+=sa0[i-1],sa1[i]+=sa1[i-1],sa2[i]+=sa2[i-1];
    if(ch[i]=='M'){
        if(s[i]==0) sa0[i]++;
        else if(s[i]==1) sa1[i]++;
        else sa2[i]++; 
    }
    else if(ch[i]=='X'){
        if(s[i]==0) sc0[i]++;
        else if(s[i]==1) sc1[i]++;
        else sc2[i]++;
    } 
}
for(int i=n;i>=1;i--){
    sc0[i]+=sc0[i+1],sc1[i]+=sc1[i+1],sc2[i]+=sc2[i+1];        
}
for(int i=1;i<=n;i++){
    if(ch[i]=='E'){
        if(s[i]==0){
            ans+=1*(sa0[i]*sc2[i]+sa2[i]*sc0[i]+sa2[i]*sc2[i]+sa0[i]*sc0[i]);
            ans+=2*(sa0[i]*sc1[i]+sa1[i]*sc0[i]+sa1[i]*sc1[i]);
            ans+=3*(sa1[i]*sc2[i]+sa2[i]*sc1[i]);
        }
        else if(s[i]==1){
            ans+=2*(sa0[i]*sc1[i]+sa1[i]*sc0[i]+sa0[i]*sc0[i]);
            ans+=3*(sa0[i]*sc2[i]+sa2[i]*sc0[i]);                
        }
        else if(s[i]==2){
            ans+=1*(sa0[i]*sc2[i]+sa2[i]*sc0[i]+sa0[i]*sc0[i]);
            ans+=3*(sa1[i]*sc0[i]+sa0[i]*sc1[i]);
        }
    }
}
```
核心实现思想：先预处理前缀和与后缀和，分别记录 `M` 和 `X` 的不同取值数量，然后枚举 `E` 的位置，根据 `E` 的取值和前缀和、后缀和计算不同 $\text{mex}$ 取值的方案数并累加到答案中。
- **未来姚班zyl（4星）**：
    - **关键亮点**：将三个数压缩成三进制的三位数，通过预处理函数快速计算 $\text{mex}$ 值，同时维护 `M` 和 `M`、`E` 组合的数量，从左到右遍历字符串统计答案，代码简洁且复杂度较低。
    - **核心代码**：
```cpp
inline ll w(int x){
    int a,b,c;
    a=x%3,x/=3,b=x%3,x/=3,c=x;
    if(a&&b&&c)return 0;
    if((a^1)&&(b^1)&&(c^1))return 1;
    if((a^2)&&(b^2)&&(c^2))return 2;
    return 3;
}
rep(i,1,n){
    switch(s[i]){
        case 'M':
            sm[a[i]]++;
            break;
        case 'E':
            rep(j,0,2)sme[j*3+a[i]]+=sm[j];
            break;
        default:
            rep(j,0,8)ans+=sme[j]*w(j*3+a[i]);
            break;
    }
}
```
核心实现思想：先定义预处理函数 `w` 计算 $\text{mex}$ 值，然后从左到右遍历字符串，根据字符类型维护 `M` 和 `M`、`E` 组合的数量，最后根据 `M`、`E` 组合的数量和当前 `X` 的取值计算 $\text{mex}$ 并累加到答案中。

### 最优关键思路或技巧
- **状态维护**：通过维护中间状态（如 `M` 的数量、`M` 和 `E` 的组合方案数等），避免重复计算，将复杂度从 $O(N^3)$ 降低到 $O(N)$。
- **前缀和与后缀和**：以 `E` 为中间点，利用前缀和统计 `E` 左边 `M` 的不同取值数量，利用后缀和统计 `E` 右边 `X` 的不同取值数量，方便根据组合数计算答案。
- **三进制压缩**：将三个数压缩成三进制的三位数，通过预处理函数快速计算 $\text{mex}$ 值，减少判断逻辑。

### 可拓展之处
同类型题可能会有不同的字符组合和取值范围，解题思路仍然可以围绕状态维护、前缀和与后缀和、压缩编码等方法进行优化。例如，字符可能变为更多种类，取值范围可能扩大，此时需要根据具体情况调整数据结构和算法。

### 洛谷相似题目推荐
- [P1116 车厢重组](https://www.luogu.com.cn/problem/P1116)：考察逆序对的统计，可通过前缀和或归并排序等方法解决。
- [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)：需要预处理二维前缀和，然后枚举矩形的边界计算最大加权矩形。
- [P2671 求和](https://www.luogu.com.cn/problem/P2671)：涉及到对数组元素的组合和统计，可通过维护中间状态来优化计算。

### 个人心得摘录与总结
- **Msents**：“就是比赛的时候脑子短路了没想出来”，说明在比赛紧张的环境下可能会出现思路阻塞的情况，需要平时多练习，提高思维的灵活性和应变能力。

---
处理用时：56.85秒
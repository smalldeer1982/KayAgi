# 题目信息

# [ABC312C] Invisible Hand

## 题目描述

**题意简述**

在苹果市场中，有 $N$ 个卖家和 $M$ 个买家。第 $i$ 个卖家愿意出售的最低价格为 $A_i$ 日元，第 $j$ 个买家愿意购买的最高价格为 $B_i$ 日元。

请求出一个最低价格 $x$，使愿意以 $x$ 日元出售的卖家数量大于等于愿意以 $x$ 元购买的买家。

## 说明/提示

- $1 \le N,M \le 2 \times 10^5$
- $1 \le A_i,B_i \le 10^9$

## 样例 #1

### 输入

```
3 4

110 90 120

100 80 120 10000```

### 输出

```
110```

## 样例 #2

### 输入

```
5 2

100000 100000 100000 100000 100000

100 200```

### 输出

```
201```

## 样例 #3

### 输入

```
3 2

100 100 100

80 120```

### 输出

```
100```

# AI分析结果

### 题目内容中文重写
#### [ABC312C] 无形之手

#### 题目描述
**题意简述**

在苹果市场中，有 $N$ 个卖家和 $M$ 个买家。第 $i$ 个卖家愿意出售的最低价格为 $A_i$ 日元，第 $j$ 个买家愿意购买的最高价格为 $B_i$ 日元。

请求出一个最低价格 $x$，使愿意以 $x$ 日元出售的卖家数量大于等于愿意以 $x$ 日元购买的买家数量。

#### 说明/提示
- $1 \le N,M \le 2 \times 10^5$
- $1 \le A_i,B_i \le 10^9$

#### 样例 #1
##### 输入
```
3 4
110 90 120
100 80 120 10000
```
##### 输出
```
110
```

#### 样例 #2
##### 输入
```
5 2
100000 100000 100000 100000 100000
100 200
```
##### 输出
```
201
```

#### 样例 #3
##### 输入
```
3 2
100 100 100
80 120
```
##### 输出
```
100
```

### 综合分析与结论
这些题解大多采用二分答案的思路来解决问题。通过二分查找价格 $x$，并使用 `check` 函数判断该价格是否满足“愿意以 $x$ 日元出售的卖家数量大于等于愿意以 $x$ 日元购买的买家数量”这一条件。

#### 思路对比
- **二分答案主流思路**：大部分题解通过二分查找价格 $x$，范围通常从 $1$ 到一个较大值（如 $10^9 + 1$ 或 $10^{18}$），每次取中间值 $mid$，用 `check` 函数判断 $mid$ 是否满足条件，根据结果调整左右边界。
- **特殊思路**：hellolin 提出答案是序列 $A_1, A_2, \dots, A_n, B_1+1, B_2+1,\dots, B_m+1$ 排序后的第 $m$ 项，并给出了证明。

#### 算法要点对比
- **暴力统计**：多数题解在 `check` 函数中通过两层循环分别统计愿意出售和购买的人数。
- **使用库函数**：God_Max_Me 的题解使用 `lower_bound` 和 `upper_bound` 函数来统计人数，减少了手动循环的代码量。

#### 解决难点对比
- **二分边界**：多个题解提到二分右边界的取值问题，需要考虑到答案可能达到 $10^9 + 1$，否则可能导致 WA。
- **单调性证明**：部分题解对价格 $x$ 与卖家、买家数量的单调性进行了证明，确保二分的正确性。

### 所选题解
- **hjfjwl（4星）**
    - **关键亮点**：思路清晰，代码简洁，对二分查找和 `check` 函数的实现较为基础，适合初学者理解。
    - **核心代码**：
```cpp
bool check(int x)
{
    int ca = 0;
    for(int i = 1;i <= n;i++)
    {
        if(x >= a[i])
        {
            ca++;
        }
    }
    int cb = 0;
    for(int i = 1;i <= m;i++)
    {
        if(x <= b[i])
        {
            cb++;
        }
    }
    return ca >= cb;
}
signed main(){
    cin >>n >>m;
    for(int i = 1;i <= n;i++)cin >> a[i];
    for(int i = 1;i <= m;i++)cin >> b[i];
    int l = 1,r = 1000000001;
    int ans;
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        if(check(mid))
        {
            r = mid - 1;
            ans = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```
- **God_Max_Me（4星）**
    - **关键亮点**：使用 `lower_bound` 和 `upper_bound` 函数优化了 `check` 函数的实现，提高了代码效率。
    - **核心代码**：
```cpp
bool check(int x){
    int sel=upper_bound(a+1,a+n+1,x)-a-1;
    int bou=m-(lower_bound(b+1,b+m+1,x)-b)+1;
    if(sel>=bou) return 0;
    return 1;
}
signed main(){
    read(n),read(m);
    for(int i=1;i<=n;++i) read(a[i]);
    for(int i=1;i<=m;++i) read(b[i]);
    sort(a+1,a+n+1);
    sort(b+1,b+m+1);
    int l=0,r=1e9+100,ans=0;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)) l=mid+1;
        else r=mid-1,ans=mid;
    };
    cout<<ans<<endl;
    return 0;
}
```
- **hellolin（4星）**
    - **关键亮点**：提出了一种独特的思路，通过证明得出答案是特定序列排序后的第 $m$ 项，为解题提供了新的视角。
    - **思路总结**：通过分析定价与卖家、买家数量的关系，证明答案是序列 $A_1, A_2, \dots, A_n, B_1+1, B_2+1,\dots, B_m+1$ 排序后的第 $m$ 项。

### 最优关键思路或技巧
- **二分答案**：利用价格 $x$ 与卖家、买家数量的单调性，通过二分查找快速缩小答案范围。
- **使用库函数**：如 `lower_bound` 和 `upper_bound` 函数，可以简化统计人数的代码，提高效率。

### 可拓展之处
同类型题可能会改变条件，如增加商品种类、限制交易数量等，但仍可使用二分答案的思路解决。类似算法套路包括在具有单调性的问题中使用二分查找来优化暴力枚举的时间复杂度。

### 推荐洛谷题目
- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)
- [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
- [P3853 [TJOI2007]路标设置](https://www.luogu.com.cn/problem/P3853)

### 个人心得摘录与总结
- **God_Max_Me**：赛时因为右边界 $r$ 初始值开小（开成 $10^9 + 100$ 才正确）而死磕半天，提醒我们要注意二分边界的取值。
- **Genius_Star**：提交后 WA 了一个点，发现虽然题目范围是 $1 \le A_i,B_i \le 10^9$，但当 $A$ 和 $B$ 中全是 $10^9$ 且 $n < m$ 时，答案应该是 $10^9 + 1$，强调了考虑边界情况的重要性。 

---
处理用时：42.99秒
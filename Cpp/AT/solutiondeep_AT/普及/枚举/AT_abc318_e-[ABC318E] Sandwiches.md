# 题目信息

# [ABC318E] Sandwiches

## 题目描述

**题意简述**

给定一个长度为 $N$ 的序列 $A$。求满足以下条件的三元组 $(i,j,k)$ 的个数。

- $1 \le i < j < k \le N$
- $A_i = A_k$
- $A_i \ne A_j$

## 说明/提示

- $3 \le N \le 3 \times 10^5$
- $1 \le A_i \le N$

**样例一解释**

有 $3$ 个，分别为 $(1,2,1),(2,1,2),(2,3,2)$。

## 样例 #1

### 输入

```
5

1 2 1 3 2```

### 输出

```
3```

## 样例 #2

### 输入

```
7

1 2 3 4 5 6 7```

### 输出

```
0```

## 样例 #3

### 输入

```
13

9 7 11 7 3 8 1 13 11 11 11 6 13```

### 输出

```
20```

# AI分析结果

### 题目翻译
#### [ABC318E] 三明治

#### 题目描述
**题意简述**

给定一个长度为 $N$ 的序列 $A$。求满足以下条件的三元组 $(i,j,k)$ 的个数。

- $1 \le i < j < k \le N$
- $A_i = A_k$
- $A_i \ne A_j$

#### 说明/提示
- $3 \le N \le 3 \times 10^5$
- $1 \le A_i \le N$

**样例一解释**

有 $3$ 个，分别为 $(1,2,1),(2,1,2),(2,3,2)$。

#### 样例 #1
##### 输入
```
5
1 2 1 3 2
```
##### 输出
```
3
```

#### 样例 #2
##### 输入
```
7
1 2 3 4 5 6 7
```
##### 输出
```
0
```

#### 样例 #3
##### 输入
```
13
9 7 11 7 3 8 1 13 11 11 11 6 13
```
##### 输出
```
20
```

### 综合分析与结论
这些题解主要围绕如何高效计算满足条件的三元组 $(i,j,k)$ 的个数展开，思路各有不同。

|作者|思路|算法要点|解决难点|评分|
| ---- | ---- | ---- | ---- | ---- |
|Zi_Gao|将问题转化为图论的三元环计数问题，通过建图和容斥原理计算|正反扫数组，用桶记录数字出现个数计算入度，利用组合数公式容斥计算三元环个数|建立合适的图论模型，准确计算入度和利用容斥原理|3星|
|lrx___|类比已知题目，计算每个不是目标值的区间长度乘上其左右目标值的个数|用 `vector` 存储每个数的下标，遍历计算贡献|避免计算过程中 `int` 溢出|4星|
|DerrickLo|用 `vector` 存储每个数出现的位置，计算相邻位置间区域对答案的贡献|遍历 `vector`，计算相邻位置间区域长度与左右可选端点数量的乘积|准确计算左右可选端点数量|4星|
|Shameimaru_Aya|考虑每个位置作为最后一个元素时的贡献，通过递推计算|维护 `last` 数组记录上一个相同值的位置，`cnt` 数组记录值出现次数，递推计算贡献|理解递推关系和贡献的组成部分|3星|
|Register_int|记录每个位置上数的下一次出现位置，从左往右扫描计算方案数|维护 `nxt` 数组记录下一个相同值的位置，`x` 和 `y` 数组记录左右相同值的个数|准确维护左右相同值的个数|3星|
|Light_az|枚举每种颜色，将问题转化为计算线段覆盖次数|用 `vector` 记录颜色下标位置，通过组合数学计算线段覆盖次数|将问题转化为线段覆盖问题并准确计算覆盖次数|3星|
|Scorilon|枚举 $j$，用容斥原理计算贡献|维护 `l` 和 `r` 数组记录左右相同值的个数，预处理并动态修改贡献|容斥原理的应用和动态修改贡献|4星|
|robertuu|对数组排序并维护 `id`，扫描数组计算贡献|排序数组，记录每个数字的第一个出现位置，累加不同值的数量|排序后准确计算每个数字对答案的贡献|3星|
|Failure_Terminator|枚举 $j$，维护前缀和后缀出现次数计算贡献|维护 `pre` 和 `suf` 数组记录前后出现次数，动态更新 `p` 值|动态更新 `p` 值和处理前后出现次数的变化|3星|
|Fire_flame|枚举 $j$，更新前后相同值的个数计算贡献|维护 `cnt` 和 `cnt2` 数组记录前后相同值的个数，动态更新答案|准确更新前后相同值的个数和答案|3星|
|happybob|枚举 $i$，找出后面的 $k$ 并计算贡献|用 `set` 存储每个值的位置，动态维护和计算贡献|动态维护和计算贡献|3星|
|_7Mr|将相同数字的情况分开计算，用 `map` 存储间隔数|用 `map` 存储相同数字间的间隔数，根据间隔数和位置计算答案|合理分类和用 `map` 存储间隔数|3星|
|ldj2006|以 $k$ 为扫描线，维护之前下标总和和个数计算贡献|维护 `sumidx` 和 `cntidx` 数组记录之前下标总和和个数，根据公式计算贡献|推导和应用贡献计算公式|3星|

### 所选题解
- **lrx___（4星）**
    - 关键亮点：思路清晰，类比已知题目，代码简洁，通过 `vector` 存储下标方便计算。
    - 核心代码：
```cpp
#include<cstdio>
#include<vector>
using namespace std;
typedef unsigned long long ll;
const int N=3e5+5;
vector<int>a[N];
int main(){
    int n,i,j,l,x;
    ll s=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++){
        scanf("%d",&x);
        a[x].push_back(i);
    }
    for(i=1;i<=n;i++){
        l=a[i].size();
        for(j=1;j<l;j++){
            s+=(ll)(a[i][j]-a[i][j-1]-1)*j*(l-j);
        }
    }
    printf("%llu\n",s);
    return 0;
}
```
    - 核心实现思想：用 `vector` 存储每个数的下标，遍历每个数的下标，计算相邻下标间的区间长度，乘以其左右该数的个数，累加得到答案。

- **DerrickLo（4星）**
    - 关键亮点：思路简洁直接，代码实现简单，通过 `vector` 存储位置计算贡献。
    - 核心代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[300005],ans;
vector<int> ve[300005];
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)ve[a[i]].emplace_back(i);
    for(int i=1;i<=n;i++)if(ve[i].size()){
        for(int j=1;j<ve[i].size();j++){
            ans+=(ve[i][j]-ve[i][j-1]-1)*j*(ve[i].size()-j);
        }
    }
    cout<<ans;
    return 0;
}
```
    - 核心实现思想：用 `vector` 存储每个数出现的位置，遍历每个数的位置，计算相邻位置间的区域长度，乘以其左右可选端点数量，累加得到答案。

- **Scorilon（4星）**
    - 关键亮点：采用枚举 $j$ 的思路，利用容斥原理，时间复杂度低，代码简洁。
    - 核心代码：
```cpp
#include <cstdio>
const int N=3e5+5;
int n;
int a[N];
int l[N],r[N];
long long ans,sum;
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        scanf("%d",&a[i]);
        if(i==1) l[a[i]]++;
        else if(i!=2) r[a[i]]++;
    }
    for(int i=1;i<=n;i++) sum+=(1ll*l[i]*r[i]);
    for(int j=2;j<n;j++) {
        ans+=(sum-1ll*l[a[j]]*r[a[j]]);
        ++l[a[j]];sum+=r[a[j]];
        --r[a[j+1]];sum-=l[a[j+1]];
    }
    printf("%lld\n",ans);
    return 0;
}
```
    - 核心实现思想：枚举 $j$，维护 `l` 和 `r` 数组记录左右相同值的个数，预处理 `sum` 表示所有左右相同值个数乘积的和，每次枚举 $j$ 时，用 `sum` 减去 $a_j$ 对应的左右相同值个数乘积得到贡献，动态更新 `l`、`r` 和 `sum`。

### 最优关键思路或技巧
- 利用 `vector` 存储每个数的出现位置，方便计算相邻位置间的距离和左右可选端点数量。
- 采用枚举 $j$ 的思路，结合容斥原理，降低时间复杂度。

### 拓展思路
同类型题可以是统计满足其他条件的三元组或多元组个数，类似算法套路有枚举其中一个元素，维护其他元素的信息，利用容斥原理或组合数学计算贡献。

### 推荐题目
- [P1116 车厢重组](https://www.luogu.com.cn/problem/P1116)：涉及元素位置和顺序的统计问题。
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：需要统计满足特定条件的元素对个数。
- [P2036 [COCI2008-2009#2] PERKET](https://www.luogu.com.cn/problem/P2036)：涉及组合和条件判断的计数问题。

### 个人心得摘录与总结
- **Zi_Gao**：原以为是复杂的三元环问题，实际不用，体现了对问题的初步误判，提醒我们要深入分析问题，不要被表面现象迷惑。
- **Fire_flame**：开场 11 分钟切题但手贱点了 Unrated，强调了在比赛中操作要谨慎，避免因小失误影响结果。 

---
处理用时：57.92秒
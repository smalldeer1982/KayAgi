# 题目信息

# [ABC323D] Merge Slimes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_d

最初、$ N $ 種類のサイズのスライムがいます。  
具体的には、$ 1\leq\ i\leq\ N $ について、サイズ $ S_i $ のスライムが $ C_i $ 匹います。

高橋君はスライムの合成を好きな順番で好きなだけ($ 0 $ 回でも良い)繰り返すことができます。  
スライムの合成では、次のことを行います。

- **同じ** サイズの $ 2 $ 匹のスライムを選ぶ。選ばれたスライムのサイズが $ X $ であったとき、新しくサイズ $ 2X $ のスライムが出現する。合成後、選ばれた元のスライムは $ 2 $ 匹とも消滅する。

高橋君はスライムの匹数を最小にしたいと考えています。 高橋君がうまく合成を繰り返した時、最小で何匹にすることができるでしょうか?

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 10^5 $
- $ 1\leq\ S_i\leq\ 10^9 $
- $ 1\leq\ C_i\leq\ 10^9 $
- $ S_1,S_2,\ldots,S_N $ はすべて異なる。
- 入力はすべて整数

### Sample Explanation 1

最初、サイズ $ 3 $ のスライムが $ 3 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 1 $ 匹います。 高橋君は次のように合成を $ 2 $ 回行うことができます。 - まず、サイズ $ 3 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 2 $ 匹となります。 - 次に、サイズ $ 6 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 12 $ のスライムが $ 1 $ 匹となります。 高橋君は最初の状態からどのように合成を繰り返してもスライムを $ 2 $ 匹以下にすることはできないため、$ 3 $ を出力します。

### Sample Explanation 2

高橋君は合成を行うことができません。

## 样例 #1

### 输入

```
3
3 3
5 1
6 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3
1 1
2 1
3 1```

### 输出

```
3```

## 样例 #3

### 输入

```
1
1000000000 1000000000```

### 输出

```
13```

# AI分析结果

### 题目翻译
最初，有 $N$ 种不同大小的史莱姆。
具体来说，对于 $1\leq i\leq N$，大小为 $S_i$ 的史莱姆有 $C_i$ 只。

高桥君可以按任意顺序、任意次数（$0$ 次也可以）重复进行史莱姆的合成操作。
在史莱姆的合成操作中，进行以下步骤：
- 选择 **相同** 大小的 $2$ 只史莱姆。若所选史莱姆的大小为 $X$，则会新出现一只大小为 $2X$ 的史莱姆。合成后，被选中的 $2$ 只原始史莱姆都会消失。

高桥君希望将史莱姆的数量减到最少。当高桥君巧妙地重复进行合成操作时，最少可以将史莱姆的数量减到多少只呢？

### 综合分析与结论
- **思路对比**：
    - **LiJoQiao**：先指出合成顺序不影响结果，最初考虑用 `std::set` 模拟合成过程，但速度慢。优化时利用每种史莱姆数量 $C_i$ 的二进制特性，在 $C_i$ 为奇数时将对应 $S_i$ 放入数据结构，$C_i$ 为偶数时将 $S_i$ 乘 $2$、$C_i$ 除以 $2$ 直到 $C_i$ 为 $0$。
    - **wangchai2009**：采用贪心策略，从小到大地合成橡皮泥，用优先队列维护数量大于 $1$ 的橡皮泥，每次取出最小的进行更新，剩余 $1$ 个则对答案贡献 $1$。
    - **无钩七不改名**：贪心策略，从高到低枚举幂次方进行合并，考虑多种数合成一个数的情况，对数组按数字大小排序，尽量把小数合并到较大数。
    - **hellolin**：使用 `std::map` 存储史莱姆体积和数量，遍历 `std::map`，若数量大于等于 $2$，则更大的史莱姆数量增加，当前史莱姆剩余数量更新，答案累加剩余数量。
    - **Halberd_Cease**：循环取最小的史莱姆进行合并，若数量为奇数答案加 $1$，将大小乘 $2$ 的史莱姆个数加上当前史莱姆个数除以 $2$，并给出了 set + map、set、map 三种实现方式。
- **算法要点对比**：
    - **LiJoQiao**：利用二进制特性优化模拟过程。
    - **wangchai2009**：优先队列维护可合成的史莱姆。
    - **无钩七不改名**：枚举幂次方合并，排序处理多种数合成情况。
    - **hellolin**：`std::map` 自动排序和存储数量。
    - **Halberd_Cease**：循环取最小合并，多种数据结构实现。
- **解决难点对比**：
    - **LiJoQiao**：解决模拟过程的效率问题。
    - **wangchai2009**：保证每次取最小的史莱姆进行合成。
    - **无钩七不改名**：处理多种数合成一个数的情况。
    - **hellolin**：利用 `std::map` 特性简化操作。
    - **Halberd_Cease**：不同数据结构的实现细节和效率问题。

### 所选题解
- **LiJoQiao（5星）**：
    - **关键亮点**：思路清晰，先给出暴力模拟思路，再进行优化，利用二进制特性提高效率，且对算法正确性有合理说明。
- **hellolin（4星）**：
    - **关键亮点**：代码简洁，利用 `std::map` 的自动排序和关联式容器特性，实现简单易懂。
- **wangchai2009（4星）**：
    - **关键亮点**：贪心策略明确，使用优先队列维护数据，思路直观。

### 重点代码
- **hellolin**：
```cpp
constexpr int N = 1e5 + 11;
int n, s, c, ans;
std::map<i64, i64> buc;
void solve() {
    std::cin >> n;
    rep(i, n) {
        std::cin >> s >> c;
        buc[s] = c;
    }
    for(auto &[a, b] : buc) {
        if(b >= 2) {
            buc[a * 2] += b / 2;
            ans += b % 2;
        } else {
            ans += b;
        }
    }
    std::cout << ans << '\n';
}
```
**核心实现思想**：使用 `std::map` 存储史莱姆体积和数量，遍历 `std::map`，若数量大于等于 $2$，则将更大的史莱姆数量增加，当前史莱姆剩余数量更新，答案累加剩余数量。

### 最优关键思路或技巧
- **数据结构**：`std::map` 可自动按键值排序，且插入元素时迭代器不会失效，适合处理这类需要排序和更新数量的问题。
- **算法优化**：利用每种史莱姆数量的二进制特性，可在输入时就进行部分合成操作，减少后续模拟的复杂度。
- **思维方式**：贪心策略，从小到大地合成史莱姆，保证每次合成都是最优选择。

### 可拓展之处
同类型题可能会改变合成规则，如多个相同大小的史莱姆合成一个更大的史莱姆，或者合成的结果不是简单的倍数关系。类似算法套路可用于处理资源合并、数据压缩等问题，核心思路都是贪心和合理选择数据结构来优化操作。

### 推荐洛谷题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考查贪心和优先队列的应用。
- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)：涉及贪心策略和排序。
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：基础的贪心问题。

### 个人心得
- **Halberd_Cease**：提到当时脑子抽了没想到 `map` 可以按键值排序还傻逼地用 `set` 排一遍，提醒我们在选择数据结构时要充分了解其特性，避免走弯路。 

---
处理用时：37.08秒
# 题目信息

# [ABC325E] Our clients, please wait a moment

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_e

ある国には都市が $ N $ 個あります。  
あなたは、都市 $ 1 $ にある営業所から $ 0 $ 個以上の都市を経由して都市 $ N $ にある訪問先へ移動しようとしています。  
移動手段は社用車と電車の $ 2 $ 種類があります。都市 $ i $ から都市 $ j $ へ移動するときの所要時間は以下の通りです。

- 社用車を使った場合 : $ D_{i,j}\ \times\ A $ 分
- 電車を使った場合 : $ D_{i,j}\ \times\ B\ +\ C $ 分

ただし、社用車から電車に乗り換えることはできますが、電車から社用車に乗り換えることはできません。  
また、乗り換えは各都市のみで行え、乗り換えに時間はかかりません。

都市 $ 1 $ から都市 $ N $ に移動するのにかかる時間は最短で何分ですか？

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ A,\ B,\ C\ \leq\ 10^6 $
- $ D_{i,j}\ \leq\ 10^6 $
- $ D_{i,i}\ =\ 0 $
- $ D_{i,j}\ =\ D_{j,i}\ >\ 0 $ $ (i\ \neq\ j) $
- 入力される数値はすべて整数

### Sample Explanation 1

以下のように移動することで合計 $ 78 $ 分で都市 $ 1 $ から都市 $ 4 $ に移動することができます。 - 都市 $ 1 $ から都市 $ 3 $ まで社用車で移動する。この移動には $ 2\ \times\ 8\ =\ 16 $ 分かかる。 - 都市 $ 3 $ から都市 $ 2 $ まで社用車で移動する。この移動には $ 3\ \times\ 8\ =\ 24 $ 分かかる。 - 都市 $ 2 $ から都市 $ 4 $ まで電車で移動する。この移動には $ 5\ \times\ 5\ +\ 13\ =\ 38 $ 分かかる。 $ 78 $ 分未満の時間で都市 $ 1 $ から都市 $ 4 $ に移動することはできません。

## 样例 #1

### 输入

```
4 8 5 13
0 6 2 15
6 0 3 5
2 3 0 13
15 5 13 0```

### 输出

```
78```

## 样例 #2

### 输入

```
3 1 1000000 1000000
0 10 1
10 0 10
1 10 0```

### 输出

```
1```

## 样例 #3

### 输入

```
5 954257 954213 814214
0 84251 214529 10017 373342
84251 0 91926 32336 164457
214529 91926 0 108914 57762
10017 32336 108914 0 234705
373342 164457 57762 234705 0```

### 输出

```
168604826785```

# AI分析结果

### 题目中文重写
#### [ABC325E] 请稍等，我们的客户

#### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_e

某个国家有 $N$ 个城市。
你打算从位于城市 $1$ 的营业所出发，经过 $0$ 个或多个城市，前往位于城市 $N$ 的访问地。
移动方式有公司用车和电车两种。从城市 $i$ 移动到城市 $j$ 所需的时间如下：
- 使用公司用车的情况：$D_{i,j} \times A$ 分钟
- 使用电车的情况：$D_{i,j} \times B + C$ 分钟

不过，虽然可以从公司用车换乘到电车，但不能从电车换乘到公司用车。
此外，换乘只能在各个城市进行，且换乘不花费时间。
从城市 $1$ 移动到城市 $N$ 所需的最短时间是多少分钟？

#### 说明/提示
##### 限制条件
- $2 \leq N \leq 1000$
- $1 \leq A, B, C \leq 10^6$
- $D_{i,j} \leq 10^6$
- $D_{i,i} = 0$
- $D_{i,j} = D_{j,i} > 0$  $(i \neq j)$
- 输入的所有数值均为整数

##### 示例解释 1
通过以下方式移动，可以在总计 $78$ 分钟内从城市 $1$ 移动到城市 $4$：
- 从城市 $1$ 乘坐公司用车移动到城市 $3$，此移动需要 $2 \times 8 = 16$ 分钟。
- 从城市 $3$ 乘坐公司用车移动到城市 $2$，此移动需要 $3 \times 8 = 24$ 分钟。
- 从城市 $2$ 乘坐电车移动到城市 $4$，此移动需要 $5 \times 5 + 13 = 38$ 分钟。
无法在少于 $78$ 分钟的时间内从城市 $1$ 移动到城市 $4$。

#### 样例 #1
##### 输入
```
4 8 5 13
0 6 2 15
6 0 3 5
2 3 0 13
15 5 13 0
```
##### 输出
```
78
```

#### 样例 #2
##### 输入
```
3 1 1000000 1000000
0 10 1
10 0 10
1 10 0
```
##### 输出
```
1
```

#### 样例 #3
##### 输入
```
5 954257 954213 814214
0 84251 214529 10017 373342
84251 0 91926 32336 164457
214529 91926 0 108914 57762
10017 32336 108914 0 234705
373342 164457 57762 234705 0
```
##### 输出
```
168604826785
```

### 综合分析与结论
这些题解主要围绕如何解决从城市 $1$ 到城市 $N$ 的最短移动时间问题，由于存在两种移动方式且有换乘限制，解题的关键在于处理好换乘逻辑。

#### 思路对比
- **分层图思路**：将图分为两层，一层表示坐汽车，一层表示坐火车，两层对应节点用边权为 $0$ 的单向边连接表示换乘，然后跑最短路算法。如 CultReborn、osfly、1234567890sjx、FL_sleake 等题解采用此思路。
- **枚举换乘点思路**：枚举所有可能的换乘点，分别计算坐汽车到换乘点和从换乘点坐火车到终点的最短时间，取最小值。如 linxuanrui、SnapYust、BugGod、forever_nope、jr_inf、_Ink、sunkuangzheng 等题解采用此思路。
- **动态规划思路**：定义状态表示不同移动方式下的最短时间，通过状态转移方程更新最短时间。如 BYR_KKK、Light_az 等题解采用此思路。

#### 算法要点对比
- **分层图**：构建分层图，使用 Dijkstra 算法求最短路，时间复杂度与图的规模有关。
- **枚举换乘点**：分别计算坐汽车和坐火车的最短路，枚举换乘点并求和取最小值，时间复杂度通常为 $O(n^2 \log n + n)$。
- **动态规划**：定义状态数组，根据状态转移方程更新最短时间，时间复杂度与节点数量有关。

#### 解决难点对比
- **分层图**：难点在于正确构建分层图，处理好两层之间的换乘边。
- **枚举换乘点**：难点在于分别计算坐汽车和坐火车的最短路，并正确枚举换乘点。
- **动态规划**：难点在于定义合适的状态和状态转移方程。

### 所选题解
- **CultReborn（5星）**
    - **关键亮点**：思路清晰，详细介绍了分层图的构建过程，并配有图示，代码注释丰富，可读性高。
    - **核心代码**：
```cpp
// 输入边信息
void Input(int u,int v,int w){
    edge[cnt] = {v,head[u],w};
    head[u] = cnt++; 
}
// Dijkstra 算法求最短路
void Dijkstra(int s){ 
    q.push({0,s}); dis[s] = 0;
    while(!q.empty()){
        int u = q.top().second; q.pop();
        if(vis[u]) continue; vis[u] = 1;
        for(int i = head[u];~i;i = edge[i].nxt){
            int v = edge[i].to,w = edge[i].cst;
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                q.push({-dis[v],v});
            }
        }
    }
}
```
- **forever_nope（4星）**
    - **关键亮点**：介绍了两种算法思路，即「最短路＋枚举」和「分层图最短路」，并给出了对应的代码链接，对不同算法的适用场景有一定说明。
    - **核心思路**：
        - **最短路＋枚举**：枚举换乘点，分别计算坐汽车和坐火车的最短路，取最小值。
        - **分层图最短路**：构建分层图，跑最短路算法，结果取 $\min\{\mathit{dis}(n),\mathit{dis}(2n)\}$。
- **_Ink（4星）**
    - **关键亮点**：介绍了两种解决方法，即正反跑两遍最短路和分层图，对两种方法进行了对比，代码实现清晰。
    - **核心代码**：
```cpp
// 计算只坐汽车的最短路
void dija(int s)
{
    q.push(make_pair(0, s));
    disa[s] = 0;
    while(q.size())
    {
        int x = q.top().second; q.pop();
        visa[x] = true;
        for(int i = 1; i <= n; i ++)
        {
            if(visa[i]) continue;
            if(disa[x] + d[x][i] * a < disa[i])
            {
                disa[i] = disa[x] + d[x][i] * a;
                q.push(make_pair(-disa[i], i));
            }
        }
    }
}
// 计算只坐火车的最短路
void dijb(int s)
{
    q.push(make_pair(0, s));
    disb[s] = 0;
    while(q.size())
    {
        int x = q.top().second; q.pop();
        if(visb[x]) continue;
        visb[x] = true;
        for(int i = 1; i <= n; i ++)
        {
            if(disb[x] + d[x][i] * b + c < disb[i])
            {
                disb[i] = disb[x] + d[x][i] * b + c;
                q.push(make_pair(-disb[i], i));
            }
        }
    }
}
```

### 最优关键思路或技巧
- **分层图**：将不同移动方式抽象为不同层的图，通过边权为 $0$ 的单向边连接表示换乘，将问题转化为普通的最短路问题。
- **枚举换乘点**：通过枚举所有可能的换乘点，将问题分解为坐汽车和坐火车的最短路问题，最后取最小值。

### 拓展思路
同类型题或类似算法套路：
- 涉及多种移动方式或状态转换的最短路问题，都可以考虑使用分层图或枚举状态转换点的方法。
- 对于有状态限制的动态规划问题，可以通过定义合适的状态和状态转移方程来解决。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)：考察最短路算法的应用。
- [P3371 单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：基础的单源最短路问题。
- [P4779 单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：更复杂的单源最短路问题，需要使用堆优化的 Dijkstra 算法。

### 个人心得摘录与总结
- **osfly**：CSP 考炸后通过水题解排泄心情，考前复习分层图但考试未考，反映出考试知识点的不确定性。
- **forever_nope**：指出原题未说明清楚的边权计算方式，提醒做题时要仔细审题。

---
处理用时：60.47秒
# 题目信息

# [ABC334C] Socks 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_c

高橋君は $ N $ 組の靴下を持っており、$ i $ 番目の組は色 $ i $ の靴下 $ 2 $ 枚からなります。 ある日タンスの中を整理した高橋君は、色 $ A_1,A_2,\dots,A_K $ の靴下を $ 1 $ 枚ずつなくしてしまったことに気づいたので、残っている $ 2N-K $ 枚の靴下を使って、靴下 $ 2 $ 枚ずつからなる $ \lfloor\frac{2N-K}{2}\rfloor $ 個の組を新たに作り直すことにしました。 色 $ i $ の靴下と色 $ j $ の靴下からなる組の**奇妙さ**は $ |i-j| $ として定義され、高橋君は奇妙さの総和をできるだけ小さくしたいです。

残っている靴下をうまく組み合わせて $ \lfloor\frac{2N-K}{2}\rfloor $ 個の組を作ったとき、奇妙さの総和が最小でいくつになるか求めてください。 なお、$ 2N-K $ が奇数のとき、どの組にも含まれない靴下が $ 1 $ 枚存在することに注意してください。

## 说明/提示

### 制約

- $ 1\leq\ K\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_1\ <\ A_2\ <\ \dots\ <\ A_K\ \leq\ N $
- 入力は全て整数

### Sample Explanation 1

以下、色 $ i $ の靴下と色 $ j $ の靴下からなる組を $ (i,j) $ と表記します。 色 $ 1,2,3,4 $ の靴下がそれぞれ $ 1,2,1,2 $ 枚ずつあります。 $ (1,2),(2,3),(4,4) $ の $ 3 $ 組を作ると、奇妙さの総和は $ |1-2|+|2-3|+|4-4|=2 $ となり、これが最小です。

### Sample Explanation 2

$ (1,1),(3,3),(4,4),(5,5) $ の $ 4 $ 組を作り、色 $ 2 $ の靴下を $ 1 $ 枚余らせる（どの組にも入れない）のが最適です。

## 样例 #1

### 输入

```
4 2
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5 1
2```

### 输出

```
0```

## 样例 #3

### 输入

```
8 5
1 2 4 7 8```

### 输出

```
2```

# AI分析结果

### 题目翻译
高桥君有 $N$ 组袜子，第 $i$ 组由 $2$ 只颜色为 $i$ 的袜子组成。有一天，整理衣柜的高桥君发现，颜色为 $A_1,A_2,\dots,A_K$ 的袜子各丢了 $1$ 只，于是他决定用剩下的 $2N - K$ 只袜子，重新组成 $\lfloor\frac{2N - K}{2}\rfloor$ 组，每组由 $2$ 只袜子组成。由颜色 $i$ 的袜子和颜色 $j$ 的袜子组成的组的**奇妙度**定义为 $|i - j|$，高桥君希望奇妙度的总和尽可能小。

请计算出，用剩下的袜子巧妙组合成 $\lfloor\frac{2N - K}{2}\rfloor$ 组时，奇妙度总和的最小值。请注意，当 $2N - K$ 为奇数时，会有 $1$ 只袜子不包含在任何一组中。

### 综合分析与结论
这些题解的核心思路都是先明确成对袜子配对奇妙度为 0，所以重点处理单只袜子。对于单只袜子，先将其按颜色排序，当单只袜子数量 $K$ 为偶数时，相邻配对可使奇妙度总和最小；当 $K$ 为奇数时，需去掉一只袜子，使剩下袜子按偶数情况配对，为避免 $O(K^2)$ 的枚举超时，多数题解采用前缀和与后缀和优化。

### 所选题解
- **Albatross_LC（5星）**
    - **关键亮点**：思路清晰，先给出初始错误代码，再详细分析 $K$ 为奇数时的情况，通过前缀和与后缀和优化时间复杂度，代码注释详细。
    - **个人心得**：一开始没注意 $K$ 可能为奇数导致未 AC，提醒我们做题要仔细读题。
- **FReQuenter（4星）**
    - **关键亮点**：思路简洁明了，对 $K$ 为奇数时扔掉哪只袜子的分析合理，通过前缀和与后缀和将时间复杂度优化到 $O(n)$。
- **heyx0201（4星）**
    - **关键亮点**：采用动态规划的方法解题，提供了不同的思路，状态转移方程设计巧妙。

### 重点代码
#### Albatross_LC
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 10;
int n, k, a[N], ans;
int b[N], e[N];
signed main() {
    cin >> n >> k;
    for (int i = 1; i <= k; i ++ ) cin >> a[i];
    sort(a + 1, a + 1 + k);
    if (k % 2 == 0) for (int i = 1; i <= k; i += 2) ans += a[i + 1] - a[i];//k为偶数
    else {//k为奇数
        ans = INT_MAX;
        for (int i = 2; i <= k; i += 2)//前缀和b
            b[i] = b[i - 2] + a[i] - a[i - 1];
        for (int i = k - 1; i > 0; i -= 2)//前缀和e
            e[i] = e[i + 2] + a[i + 1] - a[i];
        for (int i = 1; i <= k; i += 2)//删除奇数位数
            ans = min(ans, b[i - 1] + e[i + 1]);
        for (int i = 2; i <= k; i += 2)//删除偶数位数
            ans = min(ans, b[i - 2] + e[i + 2] + a[i + 1] - a[i - 1]);
    }
    cout << ans;//输出
}
```
**核心实现思想**：先对单只袜子颜色排序，$K$ 为偶数时直接相邻配对求和；$K$ 为奇数时，通过前缀和数组 $b$ 和后缀和数组 $e$ 记录不同位置的奇妙度和，枚举删除的袜子，计算剩余袜子的最小奇妙度和。

#### FReQuenter
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[200005],zs[200005],ds[200005];
signed main(){
    cin>>n>>k;
    for(int i=1;i<=k;i++) cin>>a[i];
    if(k%2==0){
        int sum=0;
        for(int i=1;i<=k;i+=2)sum+=a[i+1]-a[i];
        cout<<sum;
    }
    else{
        for(int i=2;i<=k;i+=2) zs[i]=zs[i-2]+a[i]-a[i-1];
        for(int i=k-1;i>=1;i--) ds[i]=ds[i+2]-a[i]+a[i+1];
        int ans=0x3f3f3f3f3f3f3f3fll;
        for(int i=1;i<=k;i+=2) ans=min(ans,zs[i-1]+ds[i+1]);
        cout<<ans;
    }
}
```
**核心实现思想**：同样先排序，$K$ 为偶数时相邻配对求和；$K$ 为奇数时，用前缀和数组 $zs$ 和后缀和数组 $ds$ 记录奇妙度和，枚举删除奇数位置的袜子，取最小奇妙度和。

#### heyx0201
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 2e5 + 10;

int n, k, a[MAXN], dp[MAXN][2];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= k; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= k; i++) {
        if (i - 2 >= 0) {
            dp[i][0] = dp[i - 2][0] + a[i] - a[i - 1];
            dp[i][1] = min(dp[i - 1][0], dp[i - 2][1] + a[i] - a[i - 1]);
        } else {
            dp[i][1] = dp[i - 1][0];
        }
    }
    cout << dp[k][k % 2];
    return 0;
}
```
**核心实现思想**：通过动态规划求解，$dp_{i,0}$ 表示前 $i$ 只袜子且没有多余袜子时的最小奇妙度和，$dp_{i,1}$ 表示前 $i$ 只袜子且有一只多余袜子时的最小奇妙度和，根据状态转移方程递推得到最终结果。

### 最优关键思路或技巧
- **贪心策略**：将单只袜子按颜色排序后，相邻配对可使奇妙度总和最小。
- **前缀和与后缀和优化**：当 $K$ 为奇数时，用前缀和与后缀和记录不同位置的奇妙度和，避免重复计算，将时间复杂度从 $O(K^2)$ 优化到 $O(K)$。
- **动态规划**：通过设计合理的状态和状态转移方程，也可解决该问题。

### 拓展思路
同类型题目可能会改变袜子的配对规则或增加其他限制条件，但核心思路仍可围绕贪心、前缀和、后缀和或动态规划展开。例如，可能会要求在满足一定条件下的最大奇妙度和，或者增加袜子的属性，如袜子的长度、重量等，在配对时需要同时考虑多个因素。

### 推荐洛谷题目
- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)
- [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)

### 个人心得总结
- **Albatross_LC**：做题时要仔细读题，注意题目中的特殊条件，如本题中 $K$ 可能为奇数的情况，避免因遗漏条件导致错误。
- **Expert_Dream**：在遍历数组时要注意步长，避免因步长设置错误导致结果错误。 

---
处理用时：48.15秒
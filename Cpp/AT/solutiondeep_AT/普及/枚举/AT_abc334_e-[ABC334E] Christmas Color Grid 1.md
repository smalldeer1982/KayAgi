# 题目信息

# [ABC334E] Christmas Color Grid 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_e

**この問題は問題 G と似た設定です。問題文の相違点を赤字で示します。**

$ H $ 行 $ W $ 列のグリッドがあり、グリッドの各マスは赤色あるいは緑色に塗られています。

グリッドの上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,j) $ と表記します。

マス $ (i,j) $ の色は文字 $ S_{i,j} $ で表され、$ S_{i,j}\ = $ `.` のときマス $ (i,j) $ は赤色、$ S_{i,j}\ = $ `#` のときマス $ (i,j) $ は緑色に塗られています。

グリッドにおいて、緑色に塗られたマスを頂点集合、隣り合った $ 2 $ つの緑色のマスを結ぶ辺全体を辺集合としたグラフにおける連結成分の個数を **緑の連結成分数** と呼びます。ただし、$ 2 $ つのマス $ (x,y) $ と $ (x',y') $ が隣り合っているとは、$ |x-x'|\ +\ |y-y'|\ =\ 1 $ であることを指します。

**赤色**に塗られたマスを一様ランダムに $ 1 $ つ選び、**緑色**に塗り替えたとき、塗り替え後のグリッドの緑の連結成分数の期待値を $ \text{mod\ }\ 998244353 $ で出力してください。

  「期待値を $ \text{mod\ }\ 998244353 $ で出力」とは 求める期待値は必ず有理数となることが証明できます。 またこの問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、 $ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ $ 1 $ つ存在することが証明できます。この $ R $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 1000 $
- $ S_{i,j}\ = $ `.` または $ S_{i,j}\ = $ `#`
- $ S_{i,j}\ = $ `.` なる $ (i,j) $ が存在する。
 
### Sample Explanation 1

マス $ (1,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (2,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (3,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 マス $ (3,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 よって、赤色に塗られたマスを一様ランダムに $ 1 $ つ選び、緑色に塗り替えた後の緑の連結成分数の期待値は $ (1+1+2+2)/4\ =\ 3/2 $ となります。

## 样例 #1

### 输入

```
3 3

##.

#.#

#..```

### 输出

```
499122178```

## 样例 #2

### 输入

```
4 5

..#..

.###.

#####

..#..```

### 输出

```
598946613```

## 样例 #3

### 输入

```
3 4

#...

.#.#

..##```

### 输出

```
285212675```

# AI分析结果

### 题目内容翻译
#### [ABC334E] 圣诞彩色网格 1

#### 题目描述
[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_e

**本题与问题 G 的设定相似。问题描述的不同之处用红色表示。**

有一个 $H$ 行 $W$ 列的网格，网格的每个单元格都被涂成了红色或绿色。

将网格从上往下数第 $i$ 行、从左往右数第 $j$ 列的单元格记为单元格 $(i,j)$。

单元格 $(i,j)$ 的颜色由字符 $S_{i,j}$ 表示，当 $S_{i,j} =$ `.` 时，单元格 $(i,j)$ 为红色；当 $S_{i,j} =$ `#` 时，单元格 $(i,j)$ 为绿色。

在网格中，将涂成绿色的单元格作为顶点集合，将相邻的两个绿色单元格连接起来的所有边作为边集合，所构成的图中的连通分量的数量称为 **绿色连通分量数**。这里，两个单元格 $(x,y)$ 和 $(x',y')$ 相邻是指 $|x - x'| + |y - y'| = 1$。

**随机均匀地选择一个涂成红色的单元格，并将其涂成绿色**，请输出涂完颜色后网格的绿色连通分量数的期望值对 $998244353$ 取模的结果。

“输出期望值对 $998244353$ 取模的结果” 是指：可以证明所求的期望值一定是一个有理数。此外，在本题的约束条件下，当用两个互质的整数 $P$ 和 $Q$ 将该值表示为 $\frac{P}{Q}$ 时，可以证明存在唯一的一个整数 $R$，满足 $R \times Q \equiv P \pmod{998244353}$ 且 $0 \leq R < 998244353$。请输出这个 $R$。

#### 说明/提示
##### 约束条件
- $1 \leq H, W \leq 1000$
- $S_{i,j} =$ `.` 或 $S_{i,j} =$ `#`
- 存在满足 $S_{i,j} =$ `.` 的 $(i,j)$。

##### 样例解释 1
将单元格 $(1,3)$ 涂成绿色时，绿色连通分量数为 $1$。
将单元格 $(2,2)$ 涂成绿色时，绿色连通分量数为 $1$。
将单元格 $(3,2)$ 涂成绿色时，绿色连通分量数为 $2$。
将单元格 $(3,3)$ 涂成绿色时，绿色连通分量数为 $2$。
因此，随机均匀地选择一个涂成红色的单元格并将其涂成绿色后，绿色连通分量数的期望值为 $(1 + 1 + 2 + 2) / 4 = 3 / 2$。

#### 样例 #1
##### 输入
```
3 3
##.
#.#
#..
```
##### 输出
```
499122178
```

#### 样例 #2
##### 输入
```
4 5
..#..
.###.
#####
..#..
```
##### 输出
```
598946613
```

#### 样例 #3
##### 输入
```
3 4
#...
.#.#
..##
```
##### 输出
```
285212675
```

### 综合分析与结论
这些题解的核心思路都是先求出原始网格中绿色连通块的数量，再枚举每个红色格子，分析将其涂成绿色后绿色连通块数量的变化，最后计算所有情况的平均值。主要的算法有并查集和深度优先搜索（DFS）两种。

#### 思路对比
- **并查集**：通过并查集合并相邻的绿色格子，统计初始的绿色连通块数量。枚举红色格子时，判断其相邻的绿色格子所属的连通块数量，根据连通块数量的变化更新连通块总数。
- **DFS**：使用 DFS 标记每个绿色连通块，统计初始的绿色连通块数量。枚举红色格子时，统计其相邻的不同绿色连通块数量，计算连通块总数的变化。

#### 算法要点
- **并查集**：需要实现 `find` 函数用于查找元素所属的集合，`merge` 函数用于合并两个集合。
- **DFS**：递归遍历相邻的绿色格子，标记它们属于同一个连通块。

#### 解决难点
- **连通块合并**：当一个红色格子变成绿色时，需要判断它会合并哪些连通块，避免重复计算。
- **期望值计算**：需要将所有情况的连通块数量求和，再除以红色格子的数量，最后对结果取模。

### 所选题解
- **作者：yydfj（5星）**
    - **关键亮点**：思路清晰，代码注释详细，对每种情况的分析明确，使用并查集实现，代码可读性高。
    - **核心代码**：
```cpp
// 并查集查找函数
ll find(ll x){return f[x]==x?x:f[x]=find(f[x]);}
// 快速幂函数
ll ksm(ll x,ll y)
{
    ll res=1;
    while(y)
    {
        if(y&1) res=res*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}
// 主函数部分
for(int i=0;i<n;i++)
for(int j=0;j<m;j++)
if(s[i][j]=='#')
for(int k=0;k<4;k++)
{
    ll xx=i+dx[k],yy=j+dy[k];
    if(xx<0||yy<0||xx>=n||yy>=m||s[xx][yy]=='.') continue;
    ll fx=find(a[xx][yy]),fy=find(a[i][j]);
    if(fx!=fy) f[fx]=fy;
}
for(int i=0;i<n;i++)
for(int j=0;j<m;j++)
if(s[i][j]=='#'&&!bz[find(a[i][j])]) bz[find(a[i][j])]=1,tot++;
for(int i=0;i<n;i++)
for(int j=0;j<m;j++)
if(s[i][j]=='.')
{
    kk=(kk+1)%mod;
    mp.clear();
    ll ss=0;
    for(int k=0;k<4;k++)
    {
        ll xx=i+dx[k],yy=j+dy[k];
        if(xx<0||yy<0||xx>=n||yy>=m||s[xx][yy]=='.') continue;
        if(!mp.count(find(a[xx][yy]))) ss++,mp[find(a[xx][yy])]=1;
    }
    ans=(ans+tot-ss+1)%mod;
}
cout<<ans*ksm(kk,mod-2)%mod;
```
- **作者：rui_er（4星）**
    - **关键亮点**：使用 DFS 标记连通块，代码结构清晰，使用自定义的 `Modint` 类处理取模运算，减少代码出错的可能性。
    - **核心代码**：
```cpp
// DFS 标记连通块
void dfs(int x, int y, int u) {
    vis[x][y] = u;
    rep(d, 0, 3) {
        int nx = x + nxt[d][0], ny = y + nxt[d][1];
        if(s[nx][ny] == '#' &&!vis[nx][ny]) dfs(nx, ny, u);
    }
}
// 主函数部分
rep(i, 1, n) rep(j, 1, m) if(s[i][j] == '#' &&!vis[i][j]) dfs(i, j, ++k);
rep(i, 1, n) {
    rep(j, 1, m) {
        if(s[i][j] == '.') {
            ++cnt;
            set<int> st;
            rep(d, 0, 3) {
                int nx = i + nxt[d][0], ny = j + nxt[d][1];
                if(s[nx][ny] == '#') st.insert(vis[nx][ny]);
            }
            ans += k - (int)st.size() + 1;
        }
    }
}
cout << ans / cnt << endl;
```

### 最优关键思路或技巧
- **并查集**：使用并查集可以高效地合并和查询连通块，避免重复计算。
- **集合去重**：使用 `set` 或 `map` 统计相邻的不同连通块数量，避免重复统计。
- **快速幂求逆元**：使用快速幂算法计算期望值时，通过求逆元避免除法运算，减少误差。

### 拓展思路
同类型题目通常涉及网格图中的连通块问题，如计算连通块的数量、面积、周长等。可以使用并查集、DFS、BFS 等算法解决。类似的算法套路包括：
- **连通块标记**：使用 DFS 或 BFS 标记每个连通块，方便后续统计。
- **连通块合并**：当条件发生变化时，使用并查集合并相邻的连通块。
- **期望值计算**：枚举所有可能的情况，计算每种情况的结果，最后求平均值。

### 推荐题目
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：考察连通块的标记和查询。
2. [P1522 牛的旅行](https://www.luogu.com.cn/problem/P1522)：涉及连通块的合并和距离计算。
3. [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)：使用并查集或 DFS 计算连通块的数量。

### 个人心得摘录与总结
- **yydfj**：作者表示这是自己第四十五次写题解，欢迎指出错误点，体现了积极学习和分享的态度。
- **Milthm**：认为本题说难不算难，说简单也没那么简单，但没有 C 题难，表达了对题目的难度感受。
- **harmis_yz**：觉得本题是一眼题，不理解为什么有人觉得 T3 难，认为 T2 和 T6 更难，体现了作者对题目的自信。

---
处理用时：62.63秒
# 题目信息

# [ABC363D] Palindromic Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_d

非負整数 $ X $ を $ 10 $ 進表記(先行ゼロ無し)で表した文字列が回文である時、$ X $ を回文数と呼びます。  
 例えば $ 363,\ 12344321,\ 0 $ はいずれも回文数です。

小さい方から $ N $ 番目の回文数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^{18} $
- $ N $ は整数
 
### Sample Explanation 1

小さい方から $ 46 $ 番目の回文数は $ 363 $ です。

## 样例 #1

### 输入

```
46```

### 输出

```
363```

## 样例 #2

### 输入

```
1```

### 输出

```
0```

## 样例 #3

### 输入

```
1000000000000000000```

### 输出

```
90000000000000000000000000000000009```

# AI分析结果

### 题目翻译
#### [ABC363D] 回文数

##### 题目描述
当非负整数 $X$ 用十进制表示（无前导零）的字符串是回文时，称 $X$ 为回文数。
例如，$363$、$12344321$、$0$ 都是回文数。
请找出从小到大第 $N$ 个回文数。

##### 说明/提示
- **约束条件**
  - $1 \leq N \leq 10^{18}$
  - $N$ 是整数
- **示例解释 1**
从小到大第 $46$ 个回文数是 $363$。

##### 样例
- **样例 #1**
  - **输入**
```
46
```
  - **输出**
```
363
```
- **样例 #2**
  - **输入**
```
1
```
  - **输出**
```
0
```
- **样例 #3**
  - **输入**
```
1000000000000000000
```
  - **输出**
```
90000000000000000000000000000000009
```

### 综合分析与结论
这些题解的核心思路大多围绕确定第 $N$ 个回文数的位数，再根据位数和回文数的性质来构造该回文数。具体做法通常是先计算不同位数的回文数个数，通过比较 $N$ 和这些个数来确定位数，然后根据该位数下的位置信息构造出回文数。

#### 算法要点对比
- **暴力枚举**：枚举所有数并判断是否为回文数，简单直接但效率极低，仅适用于小范围数据。
- **规律推导**：根据回文数的性质，推导出不同位数回文数的个数规律，如 $k$ 位回文数有 $9\times10^{\lfloor\frac{k - 1}{2}\rfloor}$ 个，然后通过不断减去低位数回文数的个数来确定目标回文数的位数。
- **数位 DP**：定义状态来计算不同位数回文数的个数，通过状态转移方程进行递推，适用于更复杂的计数问题。

#### 解决难点对比
- **确定位数**：通过比较 $N$ 和不同位数回文数个数的累加和来确定目标回文数的位数，是解题的关键步骤。
- **构造回文数**：根据确定的位数和位置信息，构造出回文数的前半部分，再根据位数的奇偶性进行拼接。
- **前导零处理**：部分代码需要注意前导零的问题，避免构造出错误的回文数。

### 评分较高的题解
- **作者：神犇の蒟蒻（5星）**
  - **关键亮点**：思路清晰，先给出暴力思路作为铺垫，再详细阐述正解思路，代码注释详细，对前导零问题的处理有明确说明。
  - **核心代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    long long n;
    cin>>n;
    if(n--==1){//特判0的情况
        cout<<0;
        return 0;
    }
    //把这个数表示成len位的第n个回文数的形式
    long long tmp=9;
    int len=1;
    while(n>tmp){
        n-=tmp;
        ++len;
        if(len&1){
            tmp*=10;
        }
    }
    string ans=to_string(--n);
    //这里的ans只是这个回文数的前一半
    cout<<ans;
    //输出前一半
    if(len&1){
        ans.pop_back();
    }
    //特判一下，不然12321这类奇数位的回文数会像123321一样输出
    ++ans[0];
    //注意是从1开始的
    reverse(ans.begin(),ans.end());
    cout<<ans;
    //翻转一下，然后输出后一半
    return 0;
}
```
  - **核心实现思想**：先特判 $n = 1$ 的情况，然后通过不断减去不同位数回文数的个数，确定目标回文数的位数 $len$ 和在该位数下的位置 $n$。将 $n$ 转换为字符串作为回文数的前半部分，根据位数的奇偶性进行处理，最后将前半部分反转后拼接输出。

- **作者：ikunTLE（4星）**
  - **关键亮点**：对回文数个数规律的总结清晰，使用 `__int128` 处理大整数，避免了溢出问题。
  - **核心代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
__int128 read(){__int128 x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
void write(__int128 x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10+'0');return;}
int main(){
    __int128 n=read()-2,sum=0,p1=9,wei=0;
    while(true){
        if(wei>0&&wei%2==0)
            p1*=10;
        ++wei;
        if(sum+p1>n)
            break;
        sum+=p1;
    }
    n-=sum;
    __int128 p2=1;
    for(int i=1;i<=(wei-1)/2;++i)
        p2*=10;
    __int128 res=n+p2,temp=res;
    if(wei&1)
        temp/=10;
    while(temp)
        res=res*10+temp%10,temp/=10;
    write(res);
    return 0;
}
```
  - **核心实现思想**：先读取输入并减去 $2$，然后通过循环不断累加不同位数回文数的个数，确定目标回文数的位数 $wei$ 和在该位数下的位置 $n$。计算出回文数的前半部分 $res$，根据位数的奇偶性处理后半部分，最后将结果输出。

- **作者：__O_v_O__（4星）**
  - **关键亮点**：思路简洁明了，代码实现简单，对回文数个数规律的运用熟练。
  - **核心代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,po[101],d=1;
signed main(){
    ios::sync_with_stdio(0);
    cin>>n,po[0]=1;
    if(n==1){cout<<0;return 0;}
    n--;
    for(int i=1;i<=18;i++)
        po[i]=po[i-1]*10;//10的幂次
    while(1){
        int x=(d+1)/2;
        if(n<=9*po[x-1]){
            string s=to_string(po[x-1]+n-1);
            cout<<s;
            reverse(s.begin(),s.end());
            cout<<s;
            return 0;
        }else n-=9*po[x-1];
        d++;
    }return 0;
}
```
  - **核心实现思想**：先特判 $n = 1$ 的情况，然后预处理 $10$ 的幂次。通过循环不断减去不同位数回文数的个数，确定目标回文数的位数 $d$ 和在该位数下的位置 $n$。构造出回文数的前半部分并转换为字符串，反转后拼接输出。

### 最优关键思路与技巧
- **利用回文数性质**：回文数由其前半部分决定，通过计算不同位数回文数的个数，快速确定目标回文数的位数和前半部分。
- **规律推导**：总结出不同位数回文数个数的规律，避免了暴力枚举的低效率。
- **特判处理**：对 $n = 1$ 的情况进行特判，简化后续处理逻辑。

### 拓展思路
同类型题目可能会改变回文数的定义（如在不同进制下）或增加其他限制条件（如回文数必须满足某些数学性质），解题时仍可从确定位数和构造回文数的角度入手，结合具体条件进行分析。

### 洛谷推荐题目
- [P1479 回文数](https://www.luogu.com.cn/problem/P1479)：给定一个进制 $B$ 和一个数 $N$，求大于 $N$ 的最小回文数。
- [P1601 A+B Problem（高精）](https://www.luogu.com.cn/problem/P1601)：虽然不是直接求回文数，但涉及高精度计算，可用于处理大整数的回文数问题。
- [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)：与本题思路关联不大，但可锻炼数学思维和代码实现能力。

### 个人心得摘录与总结
- **作者：_Weslie_**：通过打表找规律，发现答案位数与 $n$ 的最高两位的关系，利用递归实现回文数的构造。总结：打表是找规律的有效方法，递归可用于解决具有重复结构的问题。
- **作者：T_TLucas_Yin**：提到 `pow` 函数精度会出问题，需要进行处理。总结：在使用数学函数时，要注意其精度问题，避免因精度误差导致结果错误。

---
处理用时：64.97秒
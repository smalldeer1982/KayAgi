# 题目信息

# [ARC170B] Arithmetic Progression Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_b

$ 1 $ 以上 $ \textbf{10} $ 以下の整数からなる長さ $ N $ の数列 $ A $ が与えられます．

$ 1\leq\ l\ \leq\ r\leq\ N $ を満たす整数組 $ (l,r) $ であって，以下の条件を満たすものを良い組と呼びます．

- 数列 $ (A_l,A_{l+1},\ldots,A_r) $ は長さ $ 3 $ の等差数列を（連続とは限らない）部分列として含む．より厳密には，$ l\ \leq\ i\ <\ j\ <\ k\leq\ r $ を満たす整数組 $ (i,j,k) $ であって， $ A_j\ -\ A_i\ =\ A_k\ -\ A_j $ なるものが存在する．
 
良い組の個数を求めてください．

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10 $
- 入力される数値は全て整数
 
### Sample Explanation 1

良い組は $ (l,r)=(1,4),(1,5),(2,5) $ の $ 3 $ つです． 例えば，数列 $ (A_1,A_2,A_3,A_4) $ は $ (5,3,1) $ という長さ $ 3 $ の等差数列を部分列として含むので $ (1,4) $ は良い組です．

### Sample Explanation 2

良い組が存在しない場合もあります．

## 样例 #1

### 输入

```
5

5 3 4 1 5```

### 输出

```
3```

## 样例 #2

### 输入

```
3

1 2 1```

### 输出

```
0```

## 样例 #3

### 输入

```
9

10 10 1 3 3 7 2 2 5```

### 输出

```
3```

# AI分析结果

### 题目内容中文重写
# [ARC170B] 等差数列子序列

## 题目描述
[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_b

给定一个长度为 $N$ 且由 $1$ 到 $10$ 的整数组成的数列 $A$。

满足 $1\leq l\leq r\leq N$ 的整数对 $(l,r)$，若满足以下条件，则称其为好的数对：
- 数列 $(A_l,A_{l + 1},\ldots,A_r)$ 包含长度为 $3$ 的等差数列（不一定连续）作为子序列。更严格地说，存在满足 $l\leq i < j < k\leq r$ 的整数对 $(i,j,k)$，使得 $A_j - A_i = A_k - A_j$。

请求出好的数对的个数。

## 说明/提示
### 制约
- $3\leq N\leq 10^5$
- $1\leq A_i\leq 10$
- 输入的所有数值均为整数

### 样例解释 1
好的数对有 $(l,r)=(1,4),(1,5),(2,5)$ 这 $3$ 个。例如，数列 $(A_1,A_2,A_3,A_4)$ 包含长度为 $3$ 的等差数列 $(5,3,1)$ 作为子序列，所以 $(1,4)$ 是好的数对。

### 样例解释 2
也可能不存在好的数对。

## 样例 #1
### 输入
```
5
5 3 4 1 5
```
### 输出
```
3
```

## 样例 #2
### 输入
```
3
1 2 1
```
### 输出
```
0
```

## 样例 #3
### 输入
```
9
10 10 1 3 3 7 2 2 5
```
### 输出
```
3
```

### 综合分析与结论
这些题解的核心思路大多围绕枚举左端点，找到满足条件的最小右端点，进而计算好的数对个数。不同题解在具体实现上有所差异：
- **Register_int**：使用双指针，通过 `set` 记录每个数字出现的位置，枚举 $A_i$ 和 $A_k$ 来判断区间是否合法。
- **fcy20180201**：同样用双指针，预处理所有等差数列，记录每个数字和等差数列第一项在区间里最右的位置。
- **XYstarabyss**：通过预处理 $nxt$ 数组，快速找到满足条件的 $A_j$ 和 $A_k$ 的位置，从而确定最小右端点。
- **Jerry_heng**：与 XYstarabyss 思路类似，先求出每个左端点对应的最小 $k$，再从右到左更新。
- **Xiphi**：枚举 $j$ 和公差，用桶记录下标，二分找到最接近 $j$ 的 $A_i$ 和 $A_k$，计算 $L_i$ 后统计答案。
- **Mikran**：设计 DP 数组 $dp[i][k][c]$ 来求解最小的 $(l,r)$ 对，最后计算答案。
- **rsy_**：预处理数组表示每个数后面第一个为 $x$ 的位置，枚举位置和公差，维护以 $l$ 为左端点的最小 $r$ 的值。

### 所选的题解
- **Register_int（4星）**
    - **关键亮点**：思路清晰，利用双指针和 `set` 实现，代码简洁易懂。
    - **核心代码**：
```cpp
inline bool check() {
    for (int i = 1; i <= 10; i++) if (s[i].size() >= 3) return 1;
    for (int i = 1, x; i <= 10; i++) {
        if (s[i].empty()) continue; x = *s[i].begin();
        for (int j = 1, k, y; j <= 10; j++) {
            if (i == j || s[j].empty()) continue; y = *s[j].rbegin();
            if ((i + j) % 2) continue; k = i + j >> 1;
            auto it = s[k].lower_bound(x);
            if (it != s[k].end() && *it < y) return 1;
        }
    }
    return 0;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1, j = 0; i <= n; i++) {
        for (; !check() && j <= n; j++, s[a[j]].insert(j));
        ans += n - j + 1, s[a[i]].erase(i);
    }
    printf("%lld", ans);
}
```
    - **核心实现思想**：`check` 函数用于判断当前区间是否包含长度为 $3$ 的等差数列子序列。在 `main` 函数中，使用双指针，不断右移右端点 $j$ 直到区间合法，计算答案后右移左端点 $i$ 并更新 `set`。

- **fcy20180201（4星）**
    - **关键亮点**：预处理所有等差数列，通过记录关键位置信息，巧妙处理左端点右移的问题。
    - **核心代码**：
```cpp
for(int i=0;i<10;i++)for(int j=-4;j<5;j++)if(i+j+j>=0 && i+j+j<10)fst[sum]=i,dif[sum++]=j;
for(int l=1,r=0;l<=n;l++){
    while(r<n && !have){
        r++;
        for(int i=0;i<sum;i++)if(ha2[i] && a[r]-fst[i]==dif[i]*2)have=max(have,ha2[i]);
        for(int i=0;i<sum;i++)if(ha1[fst[i]] && a[r]-fst[i]==dif[i])ha2[i]=max(ha2[i],ha1[fst[i]]);
        ha1[a[r]]=r;
    }
    if(have)ans+=n-r+1;
    if(ha1[a[l]]==l)ha1[a[l]]=0;
    for(int i=0;i<sum;i++)if(ha2[i]==l)ha2[i]=0;
    if(have==l)have=0;
}
```
    - **核心实现思想**：先预处理所有可能的等差数列，使用双指针，在右端点右移时更新等差数列的状态，左端点右移时根据最右位置信息更新状态，最后计算答案。

- **XYstarabyss（4星）**
    - **关键亮点**：通过预处理 $nxt$ 数组，快速定位元素位置，减少查找时间。
    - **核心代码**：
```cpp
f(1,n,i){
    cin >> a[i];
    f(l[a[i]],i - 1,j){
        nxt[j][a[i]] = i;
    }
    l[a[i]] = i;
}
f(1,n,i){
    r[i] = 1e9;
    f(1,10,j){
        long long p(nxt[i][j]);
        long long q((j << 1) - a[i]);
        if(p && q >= 1 && q <= 10){
            p = nxt[p][q];
            if(p){
                r[i] = min(r[i],p);
            }
        }
    }
}
r[n + 1] = 1e9;
fc(n,1,i){
    if(r[i + 1] != 1e9){
        r[i] = min(r[i],r[i + 1]);
    }
    if(r[i] != 1e9){
        ans += n - r[i] + 1;
    }
}
```
    - **核心实现思想**：预处理 $nxt$ 数组，枚举左端点和 $A_j$ 的大小，利用 $nxt$ 数组快速找到 $A_j$ 和 $A_k$ 的位置，确定最小右端点，最后统计答案。

### 最优关键思路或技巧
- **双指针**：通过枚举左端点，找到满足条件的最小右端点，利用区间的单调性减少不必要的计算。
- **预处理**：预处理所有等差数列、$nxt$ 数组等信息，方便后续快速查找和判断。
- **数据结构**：使用 `set` 记录元素位置，便于查找和删除操作。

### 可拓展之处
同类型题目可能会改变数列元素的取值范围、等差数列的长度要求等。类似的算法套路可以应用于寻找其他特定子序列的问题，如等比子序列、连续递增子序列等。

### 推荐洛谷题目
- [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)
- [P1439 【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)

### 个人心得摘录与总结
- **Xiphi**：提到赛时挂了几个细节，说明在实现过程中需要注意细节，避免因小错误导致代码出错。

---
处理用时：53.74秒
# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果

### 题目中文重写
比太郎从朋友比巴子那里收到了一份生日礼物，是一个由 `J`、`O`、`I` 这 3 种字符组成的长度为 $N$ 的字符串 $S$。

设 $K$ 为一个大于等于 1 的整数。将 $K$ 个字符 `J`、$K$ 个字符 `O`、$K$ 个字符 `I` 按此顺序排列而成的字符串称为**等级为 $K$ 的 JOI 字符串**。例如，`JJOOII` 就是等级为 2 的 JOI 字符串。

比太郎喜欢等级为 $K$ 的 JOI 字符串，因此他决定通过以下 3 种操作，以任意次数、任意顺序进行操作，将字符串 $S$ 转换为等级为 $K$ 的 JOI 字符串。
- **操作 1**：删除字符串 $S$ 的第一个字符。
- **操作 2**：删除字符串 $S$ 的最后一个字符。
- **操作 3**：删除字符串 $S$ 中既不是第一个也不是最后一个的字符。

由于操作 3 比较麻烦，所以希望尽量减少操作 3 的执行次数，将字符串 $S$ 转换为等级为 $K$ 的 JOI 字符串。

给定长度为 $N$ 的字符串 $S$ 和一个大于等于 1 的整数 $K$，编写一个程序，输出将字符串 $S$ 转换为等级为 $K$ 的 JOI 字符串所需的操作 3 的最小次数。如果无论如何操作都无法将字符串 $S$ 转换为等级为 $K$ 的 JOI 字符串，则输出 $−1$。

#### 限制条件
- $3 \leq N \leq 200000$。
- $1 \leq K \leq \frac{N}{3}$。
- $S$ 是一个由 `J`、`O`、`I` 这 3 种字符组成的长度为 $N$ 的字符串。

#### 小任务
1. （1 分）$N \leq 21$。
2. （12 分）$N \leq 3000$。
3. （87 分）无额外限制条件。

#### 样例解释 1
通过以下操作可以将字符串 $S$ 转换为等级为 $K$ 的 JOI 字符串：
1. 首先执行操作 1，字符串 $S$ 变为 `JIJOIOIIJ`。
2. 接着执行操作 2，字符串 $S$ 变为 `JIJOIOII`。
3. 然后执行操作 3，删除从开头数第 2 个字符，字符串 $S$ 变为 `JJOIOII`。
4. 最后执行操作 3，删除从开头数第 4 个字符，字符串 $S$ 变为 `JJOOII`。
由于少于 2 次操作 3 无法完成转换，所以输出 2。

#### 样例解释 2
可以不进行任何操作。

#### 样例解释 3
在这个输入样例中，无论如何操作都无法将字符串 $S$ 转换为等级为 1 的 JOI 字符串。

#### 样例 #1
##### 输入
```
10 2
OJIJOIOIIJ
```
##### 输出
```
2
```

#### 样例 #2
##### 输入
```
9 3
JJJOOOIII
```
##### 输出
```
0
```

#### 样例 #3
##### 输入
```
9 1
IIIOOOJJJ
```
##### 输出
```
-1
```

### 综合分析与结论
这些题解的核心思路都是找到字符串 $S$ 中包含至少 $K$ 个 `J`、$K$ 个 `O` 和 $K$ 个 `I` 且按顺序排列的最短子串，然后通过该子串长度减去 $3K$ 得到操作 3 的最小次数。不同题解的实现方式有所不同，主要区别在于查找子串的方法。

- **前缀和 + 二分查找**：通过前缀和快速计算子串中字符数量，利用二分查找确定满足条件的子串端点，时间复杂度 $O(N\log N)$。
- **指针维护**：使用多个指针维护 `J`、`O`、`I` 的位置，通过移动指针找到满足条件的子串，时间复杂度 $O(N)$。

### 所选题解
- **作者：Kano_zyc（5 星）**
    - **关键亮点**：思路清晰，代码结构良好，详细解释了前缀和与二分查找的实现过程。
    - **核心代码**：
```cpp
// 二分搜索找到最小的r，使得区间[l, r]包含至少k个目标字符
int findMinIndex(int l, int k, int n, int prefixSum[]) {
    int left = l, right = n, ans = n + 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (prefixSum[mid] - prefixSum[l - 1] >= k) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
}

int main() {
    int n, k;
    string s;
    cin >> n >> k >> s;

    // 计算前缀和
    for (int i = 1; i <= n; ++i) {
        J[i] = J[i - 1] + (s[i - 1] == 'J');
        O[i] = O[i - 1] + (s[i - 1] == 'O');
        I[i] = I[i - 1] + (s[i - 1] == 'I');
    }

    int ans = INT_MAX;
    for (int l = 1; l <= n; ++l) {
        int endJ = findMinIndex(l, k, n, J);
        if (endJ > n) break;
        int endO = findMinIndex(endJ, k, n, O);
        if (endO > n) break;
        int endI = findMinIndex(endO, k, n, I);
        if (endI > n) break;

        // 更新答案
        ans = min(ans, endI - l + 1 - 3 * k);
    }

    if (ans == INT_MAX) {
        cout << "-1\n";
    } else {
        cout << ans << "\n";
    }

    return 0;
}
```
核心实现思想：先计算 `J`、`O`、`I` 三种字符的前缀和数组，然后枚举子串的左端点，对于每个左端点，使用二分查找分别找到包含至少 $K$ 个 `J`、$K$ 个 `O` 和 $K$ 个 `I` 的最小右端点，最后更新最小操作次数。

- **作者：small_turtle（4 星）**
    - **关键亮点**：同样使用前缀和与二分查找，代码简洁，利用 `lower_bound()` 简化二分查找过程。
    - **核心代码**：
```cpp
int n,k,J[N],O[N],I[N];
int ans=inf;
char s[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>k;
    cin>>s+1;

    for(int i=1;i<=n;++i)
    {
        J[i]=J[i-1],O[i]=O[i-1],I[i]=I[i-1];
        if(s[i]=='J')++J[i];
        if(s[i]=='O')++O[i];
        if(s[i]=='I')++I[i];
    }

    for(int i=1;i<=n;++i)
    {
        if(s[i]!='J')continue;
        int x=lower_bound(J+1, J+n+1, J[i-1]+k)-J;
        int y=lower_bound(O+1, O+n+1, O[x-1]+k)-O;
        int z=lower_bound(I+1, I+n+1, I[y-1]+k)-I;
        if(x>n||y>n||z>n)break;
        ans=min(ans, z-i+1);
    }

    if(ans>=inf)cout<<-1;
    else cout<<ans-k*3;
    return 0;
}
```
核心实现思想：先计算前缀和数组，然后枚举左端点，对于每个左端点，使用 `lower_bound()` 分别找到包含至少 $K$ 个 `J`、$K$ 个 `O` 和 $K$ 个 `I` 的最小右端点，最后更新最小操作次数。

- **作者：saixingzhe（4 星）**
    - **关键亮点**：使用 `vector` 记录字符位置，通过双指针维护 `O` 和 `I` 的位置，时间复杂度为 $O(N)$。
    - **核心代码**：
```cpp
int n,k,O,I,ans=INT_MAX;
string s;
vector<int>q[3];
int main(){
    cin>>n>>k>>s;
    for(int i=0;i<s.size();i++){
        if(s[i]=='J')	q[0].push_back(i);
        if(s[i]=='O')	q[1].push_back(i);
        if(s[i]=='I')	q[2].push_back(i);
    }
    for(int J=0;J<=q[0].size()-k;J++){
        while(O<=q[1].size()-k&&q[0][J+k-1]>q[1][O])	O++;
        while(I<=q[2].size()-k&&q[1][O+k-1]>q[2][I])	I++;
        if(O<=q[1].size()-k&&I<=q[2].size()-k)	ans=min(ans,q[2][I+k-1]-q[0][J]+1-3*k);
        else	break;
    }
    if(ans==INT_MAX)	ans=-1;
    printf("%d",ans); 
    return 0;
}
```
核心实现思想：用 `vector` 分别记录 `J`、`O`、`I` 出现的位置，枚举 `J` 的起始位置，通过双指针移动找到满足条件的 `O` 和 `I` 的位置，最后更新最小操作次数。

### 最优关键思路或技巧
- **前缀和**：可以快速计算任意子串中字符的数量，为后续查找满足条件的子串提供便利。
- **二分查找**：在有序的前缀和数组中查找满足条件的位置，时间复杂度为 $O(\log N)$，提高了查找效率。
- **指针维护**：通过指针移动找到满足条件的子串，时间复杂度为 $O(N)$，是一种高效的查找方法。

### 可拓展之处
同类型题目可能会有不同的字符种类和条件限制，但核心思路都是找到满足特定条件的子串。类似的算法套路包括使用前缀和、二分查找、双指针等方法来优化查找过程。

### 推荐洛谷题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)：涉及二分查找和哈希表的应用。
2. [P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)：可以使用分治和二分查找的思想解决。
3. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)：典型的二分答案题目。

### 个人心得摘录与总结
- **封禁用户**：提到首先想到用 DP 解决问题，冷静思考后发现可以通过固定起点“J”，使用二分查找或双指针方法找到满足条件的子串，体现了面对问题时多思考、尝试不同方法的重要性。

---
处理用时：65.71秒
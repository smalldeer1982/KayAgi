# 题目信息

# Abundant Resources

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-final/tasks/nikkei2019_final_a

東西に細長い土地があります。 この土地は、$ N $ 個の区画が東西に並んだ形をしており、西から $ i $ 番目の区画は区画 $ i $ と呼ばれます。

それぞれの区画には地下資源があることがわかっており、区画 $ i $ の資源埋蔵量は $ A_i $ です。

$ 1 $ 以上 $ N $ 以下のそれぞれの整数 $ k $ について、次の問題の答えを求めてください。

- 連続する $ k $ 個の区画を選んだとき、それらの区画の資源埋蔵量の総和として考えられる最大値はいくらか。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3000 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数である。

### Sample Explanation 1

$ k=1 $ のとき、区画 $ 1 $ を選ぶと資源埋蔵量の総和は $ 4 $ となり、これが最大です。 $ k=2 $ のとき、区画 $ 3,4 $ を選ぶと資源埋蔵量の総和は $ 3+3=6 $ となり、これが最大です。 $ k=3 $ のとき、区画 $ 1,2,3 $ を選ぶと資源埋蔵量の総和は $ 4+1+3=8 $ となり、これが最大です。 $ k=4 $ のとき、区画 $ 1,2,3,4 $ を選ぶと資源埋蔵量の総和は $ 4+1+3+3=11 $ となり、これが最大です。

## 样例 #1

### 输入

```
4

4 1 3 3```

### 输出

```
4

6

8

11```

## 样例 #2

### 输入

```
5

10 20 30 40 50```

### 输出

```
50

90

120

140

150```

## 样例 #3

### 输入

```
10

61049214 115057849 356385814 932678664 505961980 877482753 476308661 571830644 210047210 873430114```

### 输出

```
932678664

1438640644

2316123397

2792432058

3364262702

3720648516

4447740026

4804125840

4919183689

4980232903```

# AI分析结果

### 题目翻译
有一块东西向狭长的土地。这块土地由 $N$ 个地块东西排列而成，从西数第 $i$ 个地块被称为地块 $i$。

已知每个地块都有地下资源，地块 $i$ 的资源埋藏量为 $A_i$。

对于 $1$ 到 $N$ 之间的每个整数 $k$，请分别求出以下问题的答案：
- 选择连续的 $k$ 个地块时，这些地块的资源埋藏量总和的最大值是多少？

### 综合分析与结论
这些题解主要围绕两种思路展开：暴力枚举和前缀和优化。
- **暴力枚举思路**：通过三重循环，第一重控制连续的项数，第二重控制区间左右端点，第三重求区间内所有数的和，最后更新最大值。时间复杂度为 $O(n^3)$，在数据规模较大时可能超时，但本题数据恰好能卡过。
- **前缀和优化思路**：先预处理前缀和数组，然后利用前缀和数组在 $O(1)$ 时间内求出区间和，将原本求区间和的第三重循环优化掉，时间复杂度降为 $O(n^2)$，能稳定通过本题。

### 所选题解
- **yzm0325（4星）**
    - **关键亮点**：思路清晰，详细讲解了暴力枚举和前缀和优化两种方法，且对前缀和的原理和作用有图文并茂的解释，代码注释详细。
    - **个人心得**：本来觉得三次方的时间复杂度支撑不住 $n = 3000$ 的数据，结果竟然卡着时间限制过去了，用时最长的测试点用了接近两秒，从而引出前缀和优化的必要性。
- **Acceptedit_（4星）**
    - **关键亮点**：代码简洁，以挑战最短题解为目标，同时对关键步骤和注意事项有清晰说明，如变量需要开 `long long` 等。
- **Pink_Cut_Tree（4星）**
    - **关键亮点**：对前缀和的讲解详细，还给出了前缀和笔记的参考链接，代码中对前缀和的生成和使用有清晰注释，时间复杂度分析明确。

### 重点代码
#### 暴力枚举代码（yzm0325）
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[3010];
int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) {
        long long maxn = 0; 
        for(int l = 1, r = i; r <= n; l++, r++) {
            long long sum = 0; 
            for(int j = l; j <= r; j++) sum += a[j];
            maxn = max(sum, maxn); 
        }
        cout << maxn << endl; 
    }
    return 0;
}
```
**核心思想**：通过三重循环，外层循环控制连续项数，中层循环控制区间左右端点，内层循环求区间和，不断更新最大值。

#### 前缀和优化代码（Acceptedit_）
```cpp
#include <bits/stdc++.h>
int n, a[3010]; 
long long b[3010], sum; 
int main() {
    std::cin >> n;
    for(int i = 1; i <= n; i++) std::cin >> a[i];
    for(int i = 1; i <= n; i++) b[i] = a[i] + b[i - 1]; 
    for(int i = 1; i <= n; i++) {
        long long maxn = 0; 
        for(int l = 0, r = i; r <= n; l++, r++) sum = b[r] - b[l], maxn = std::max(sum, maxn); 
        std::cout << maxn << "\n"; 
    } return 0; 
}
```
**核心思想**：先预处理前缀和数组 `b`，然后通过两重循环，外层循环控制连续项数，内层循环控制区间左右端点，利用前缀和数组在 $O(1)$ 时间内求出区间和并更新最大值。

### 最优关键思路或技巧
- **前缀和优化**：对于频繁求区间和的问题，通过预处理前缀和数组，可以将求区间和的时间复杂度从 $O(n)$ 降为 $O(1)$。
- **数据类型选择**：由于本题数据范围较大，累加和与答案可能会超出 `int` 范围，需要使用 `long long` 类型。

### 拓展思路
同类型题目可能会有更多的限制条件，如要求区间和满足一定条件（如区间和为偶数、区间和在某个范围内等），或者在二维、三维空间中求子矩阵、子立方体的和等。类似算法套路可以是二维前缀和、三维前缀和等，通过预处理前缀和数组，快速计算子区域的和。

### 推荐洛谷题目
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P2671 [NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)
3. [P3131 [USACO16JAN]Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3131)

---
处理用时：31.01秒
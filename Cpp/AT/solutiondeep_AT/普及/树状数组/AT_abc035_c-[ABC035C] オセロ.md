# 题目信息

# [ABC035C] オセロ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc035/tasks/abc035_c

黒の面に`0`、白の面に`1`が書かれた $ N $ 個のオセロの駒が、どの駒も黒の面が上を向くように一列に並べられています。その後、ある区間にある駒を全て裏返すという操作が $ Q $ 回だけ行なわれました。 具体的には $ i $ 回目の操作においては、左から $ l_i $ 番目の駒から $ r_i $ 番目の駒までの駒全てが裏返されました。

最終的な盤面を求めてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1≦N,Q≦2,000 $ を満たすデータセットに正解した場合、 $ 60 $ 点が与えられる。
- 追加制約のないデータセットに正解した場合は、追加で $ 40 $ 点が与えられ、合計 $ 100 $ 点が得られる。

### Sample Explanation 1

\- 盤面ははじめ`00000`です。 - $ 1 $ 回目の操作により、 盤面は`11110`となります。 - $ 2 $ 回目の操作により、 盤面は`10001`となります。 - $ 3 $ 回目の操作により、 盤面は`10101`となります。 - $ 4 $ 回目の操作により、 盤面は`01010`となります。 - 最終的な盤面である`01010`が求める答えです。 - このケースは部分点の追加制約を満たします。

### Sample Explanation 2

\- このケースは部分点の追加制約を満たします。

## 样例 #1

### 输入

```
5 4

1 4

2 5

3 3

1 5```

### 输出

```
01010```

## 样例 #2

### 输入

```
20 8

1 8

4 13

8 8

3 18

5 20

19 20

2 7

4 9```

### 输出

```
10110000011110000000```

# AI分析结果

### 题目内容重写

#### [ABC035C] オセロ

**题目描述**

有 $N$ 个奥赛罗棋子排成一列，每个棋子的初始状态都是黑色面朝上（记为 `0`）。接下来进行 $Q$ 次操作，每次操作会将从第 $l_i$ 个棋子到第 $r_i$ 个棋子之间的所有棋子翻转（即黑色变白色，白色变黑色）。最终要求输出所有棋子的最终状态。

**说明/提示**

**部分点**

- 对于 $1 \leq N, Q \leq 2000$ 的数据集，正确解答可以获得 $60$ 分。
- 对于没有额外限制的数据集，正确解答可以获得额外的 $40$ 分，总计 $100$ 分。

**样例解释 1**

- 初始状态为 `00000`。
- 第一次操作后，状态变为 `11110`。
- 第二次操作后，状态变为 `10001`。
- 第三次操作后，状态变为 `10101`。
- 第四次操作后，状态变为 `01010`。
- 最终状态为 `01010`。

**样例解释 2**

- 该样例满足部分点的额外限制。

**样例 #1**

**输入**

```
5 4
1 4
2 5
3 3
1 5
```

**输出**

```
01010
```

**样例 #2**

**输入**

```
20 8
1 8
4 13
8 8
3 18
5 20
19 20
2 7
4 9
```

**输出**

```
10110000011110000000
```

### 题解分析与结论

#### 题解对比与评分

1. **CleverRaccoon 的题解**（评分：5星）
   - **关键亮点**：使用前缀和差分数组来记录每个区间的翻转次数，最后通过奇偶性判断每个棋子的最终状态。思路清晰，代码简洁，时间复杂度为 $O(N+Q)$，适合大规模数据。
   - **核心代码**：
     ```cpp
     for(int l,r;q--;)cin>>l>>r,++a[l],--a[r+1];
     for(int i=1;i<=n;i++)a[i]+=a[i-1],cout<<(a[i]&1);
     ```
   - **个人心得**：强调了 Atcoder 评测姬对换行的要求，提醒了输出格式的重要性。

2. **Otomachi_Una_ 的题解**（评分：4星）
   - **关键亮点**：使用差分数组记录翻转操作，最后通过累加差分数组得到每个棋子的最终状态。思路清晰，代码简洁，时间复杂度为 $O(N+Q)$。
   - **核心代码**：
     ```cpp
     while(q--){
         cin>>l>>r;
         a[l]=!a[l];
         a[r+1]=!a[r+1];
     }
     for(int i=1;i<=n;i++){
         if(a[i]) t=!t;
         cout<<t;
     }
     ```
   - **个人心得**：无。

3. **庄nnnn额 的题解**（评分：3星）
   - **关键亮点**：使用树状数组进行区间翻转操作，时间复杂度为 $O(Q \log N)$。虽然思路正确，但相比前两种方法，代码复杂度较高，且对于本题来说，树状数组并不是最优解。
   - **核心代码**：
     ```cpp
     void update(int x){
         while(x<=n){
             c[x]^=1;
             x+=lowbit(x);
         }
     }
     bool getsum(int x){
         bool ans=0;
         while(x){
             ans^=c[x];
             x-=lowbit(x);
         }
         return ans;
     }
     ```
   - **个人心得**：无。

#### 最优关键思路

最优解是使用**前缀和差分数组**来记录每个区间的翻转次数，最后通过奇偶性判断每个棋子的最终状态。这种方法时间复杂度为 $O(N+Q)$，代码简洁且高效。

#### 可拓展之处

类似的问题可以使用差分数组或树状数组来解决，特别是涉及到区间更新和单点查询的场景。例如，区间加、区间异或等问题都可以使用类似的思路。

#### 推荐题目

1. [P5057 [CQOI2006] 简单题](https://www.luogu.com.cn/problem/P5057)
2. [P3372 [模板] 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P3368 [模板] 树状数组 2](https://www.luogu.com.cn/problem/P3368)

这些题目都涉及到区间更新和单点查询，可以使用差分数组或树状数组来解决。

---
处理用时：35.86秒
# 题目信息

# LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_h

数列 $ a $ から好きな整数を好きなだけ取り除き、単調増加な数列を作るとき、その数列の長さの最大値を求めなさい。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100,000 $

## 样例 #1

### 输入

```
5

3 1 5 4 2```

### 输出

```
2```

## 样例 #2

### 输入

```
6

1 2 3 4 5 6```

### 输出

```
6```

## 样例 #3

### 输入

```
7

7 6 5 4 3 2 1```

### 输出

```
1```

## 样例 #4

### 输入

```
20

19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 12```

### 输出

```
6```

# AI分析结果

### 题目内容重写
【题目描述】
给定一个长度为N的序列a，从中删除任意数量的元素，使得剩下的序列是严格递增的。求这个最长递增子序列的长度。

【输入格式】
第一行输入一个整数N，表示序列的长度。
第二行输入N个整数，表示序列a。

【输出格式】
输出一个整数，表示最长递增子序列的长度。

【样例输入】
```
5
3 1 5 4 2
```

【样例输出】
```
2
```

### 题解分析与结论
本题是一个经典的LIS（最长递增子序列）问题，常见的解法有动态规划（O(n^2)）和贪心+二分（O(nlogn)）。题解中大部分采用了贪心+二分的优化方法，部分题解还使用了树状数组或线段树来进一步优化。以下是几条较为优秀的题解：

### 高星题解推荐

#### 1. 作者：花里心爱 (赞：44)
**星级：5星**
**关键亮点：**
- 使用贪心+二分的方法，时间复杂度为O(nlogn)。
- 代码简洁，使用了STL中的`lower_bound`函数进行二分查找。
- 详细解释了算法的核心思想，适合初学者理解。

**核心代码：**
```cpp
int n, a[100010], s[100010], tot;
int main() {
    n = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    s[++tot] = a[1];
    for (int i = 2; i <= n; i++) {
        if (a[i] > s[tot]) s[++tot] = a[i];
        else {
            int tmp = lower_bound(s + 1, s + tot + 1, a[i]) - s;
            s[tmp] = a[i];
        }
    }
    printf("%d\n", tot);
    return 0;
}
```

#### 2. 作者：灯芯糕 (赞：41)
**星级：4.5星**
**关键亮点：**
- 提供了三种经典解法：动态规划、树状数组优化、贪心+二分。
- 详细解释了每种解法的思路和实现细节，适合进阶学习。
- 代码实现清晰，注释详细。

**核心代码：**
```cpp
int n, a[200005], f[200005];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    int ans = 1; f[1] = a[1];
    for (int i = 2; i <= n; i++) {
        int l = 1, r = ans, mid;
        while (l <= r) {
            mid = (l + r) >> 1;
            if (a[i] <= f[mid]) r = mid - 1;
            else l = mid + 1;
        }
        f[l] = a[i];
        if (l > ans) ++ans;
    }
    cout << ans << endl;
    return 0;
}
```

#### 3. 作者：GossWandering (赞：32)
**星级：4星**
**关键亮点：**
- 详细推导了贪心+二分算法的正确性，适合深入理解。
- 提供了二分查找的手写实现，适合不熟悉STL的读者。
- 代码结构清晰，注释详细。

**核心代码：**
```cpp
int n, a[100010], low[100010], len;
int binary_search(int x) {
    int l = 1, r = len;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (low[mid] <= x) l = mid + 1;
        else r = mid - 1;
    }
    return l;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    low[1] = a[1]; len = 1;
    for (int i = 2; i <= n; i++) {
        if (a[i] > low[len]) low[++len] = a[i];
        else low[binary_search(a[i])] = a[i];
    }
    printf("%d\n", len);
    return 0;
}
```

### 最优关键思路总结
1. **贪心+二分**：通过维护一个数组`low`，记录长度为i的LIS的最小末尾元素，利用二分查找来更新`low`数组，最终`low`数组的长度即为LIS的长度。
2. **树状数组优化**：通过树状数组维护LIS的长度，适合需要频繁查询和更新的场景。
3. **动态规划**：虽然时间复杂度较高，但思路简单，适合小规模数据。

### 拓展与举一反三
- **类似题目**：
  1. [P1020 导弹拦截](https://www.luogu.org/problem/P1020)
  2. [P1439 【模板】最长公共子序列](https://www.luogu.org/problem/P1439)
  3. [P1091 合唱队形](https://www.luogu.org/problem/P1091)

### 个人心得摘录
- **花里心爱**：通过维护一个栈来记录LIS的最小末尾元素，利用二分查找来更新栈中的元素，最终栈的长度即为LIS的长度。
- **灯芯糕**：详细解释了贪心+二分算法的正确性，并通过手写二分查找来加深理解。
- **GossWandering**：通过推导贪心+二分算法的正确性，帮助读者深入理解算法的核心思想。

---
处理用时：45.41秒
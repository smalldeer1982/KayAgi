# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果

### 题目中文重写
# [ABC085D] 武士刀投掷者

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

当你正在散步时，突然出现了一只怪物。幸运的是，你拥有 $ N $ 把刀，分别是刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $，并且可以按照任意顺序进行以下两种攻击：
- 挥舞你手中的一把刀。当你挥舞刀 $ i $（$ 1 \leq i \leq N $）时，怪物会受到 $ a_i $ 点伤害。同一把刀可以挥舞多次。
- 投掷你手中的一把刀。当你将刀 $ i $（$ 1 \leq i \leq N $）投掷向怪物时，怪物会受到 $ b_i $ 点伤害，并且你会失去这把刀。也就是说，你之后无法再挥舞或投掷这把刀。

当怪物受到的总伤害达到 $ H $ 点或更多时，怪物就会消失。请问，至少需要多少次攻击才能消灭怪物？

## 说明/提示

### 制约
- $ 1 \leq N \leq 10^5 $
- $ 1 \leq H \leq 10^9 $
- $ 1 \leq a_i \leq b_i \leq 10^9 $
- 输入值均为整数。

### 样例解释 1
你拥有 $ 1 $ 把刀，挥舞这把刀会造成 $ 3 $ 点伤害，投掷则会造成 $ 5 $ 点伤害。先挥舞这把刀 $ 2 $ 次，再投掷出去，总共造成 $ 3 + 3 + 5 = 11 $ 点伤害，经过 $ 3 $ 次攻击后怪物消失。

### 样例解释 2
除了之前的那把刀，你还拥有另一把刀，挥舞这把刀会造成 $ 2 $ 点伤害，投掷则会造成 $ 6 $ 点伤害。将两把刀都投掷出去，总共造成 $ 5 + 6 = 11 $ 点伤害，经过 $ 2 $ 次攻击后怪物消失。

## 样例 #1

### 输入
```
1 10
3 5
```

### 输出
```
3
```

## 样例 #2

### 输入
```
2 10
3 5
2 6
```

### 输出
```
2
```

## 样例 #3

### 输入
```
4 1000000000
1 1
1 10000000
1 30000000
1 99999999
```

### 输出
```
860000004
```

## 样例 #4

### 输入
```
5 500
35 44
28 83
46 62
31 79
40 43
```

### 输出
```
9
```

### 综合分析与结论
这些题解均采用贪心算法来解决问题，核心思路是尽可能让每次攻击造成的伤害最大化。各题解的主要差异在于实现细节和处理方式。
- **思路对比**：部分题解将劈砍和投掷伤害分开存储并排序，优先使用投掷伤害高的刀，再用劈砍伤害高的刀；部分题解先找出劈砍伤害最高的刀，再对其他刀的投掷伤害排序并使用。
- **算法要点**：主要是对刀的伤害进行排序，根据伤害类型（劈砍或投掷）进行不同处理，直到怪物的血量 $ H $ 小于等于 $ 0 $。
- **解决难点**：处理投掷和劈砍的顺序，避免重复使用已投掷的刀，同时要考虑特殊情况，如最后一击的处理。

### 所选题解
- **ITZDC9（4星）**：
    - **关键亮点**：思路清晰，详细分析了错误思路和正解，代码注释详细。
    - **个人心得**：一开始的思路有误，通过具体例子发现问题，最终得出正确思路。
- **chengni（4星）**：
    - **关键亮点**：代码简洁，直接按照伤害从高到低排序，根据伤害类型处理。
- **___new2zy___（4星）**：
    - **关键亮点**：使用结构体存储刀的信息，通过排序和贪心策略解决问题，代码实现较为清晰。

### 重点代码
#### ITZDC9
```cpp
struct knife
{
    int m; // 刀的伤害
    bool t; // 刀的种类（劈砍 0 或投掷 1）
}k[233333];

bool cmp(knife x, knife y)
{
    return x.m > y.m; // cmp 函数，利用 sort 按刀的伤害从大到小排序
}

int main() 
{
    int n, h;
    cin >> n >> h; // 输入数据
    int c = 0; // 因为拆分了两把刀所以不能用 i，添加一个 c 掌管数组位置。
    for(int i = 1; i <= n; i++)
    {
        cin >> k[++c].m;
        cin >> k[++c].m;
        k[c].t = 1; // 将刀的类型设定为投掷
    }
    sort(k + 1, k + c + 1, cmp); // 排序
    int i = 1, ans = 0;
    while(h > 0) // 怪物还活着
    {
        if(k[i].t == 1) // 如果刀的类型属于投掷
        {
            h -= k[i].m; // 丢出去，怪物掉血（如果这里怪物直接去世了，那么 h <= 0 会自动结束循环）
            ans++; // 攻击次数 + 1
        }
        else // 刀的类型属于劈砍
        {
            if(h % k[i].m == 0) // 特判一下防止除法少 1
            {
                ans += h / k[i].m; // 算出来不断劈砍到怪物死亡要多少次
            }
            else
            {
                ans += h / k[i].m + 1; // 和上面一样，这里是特判补上 1
            }
            h = 0; // 怪物当场去世，自动结束结束循环
        }
        i++; // 计算下一把刀
    }
    cout << ans;
    return 0;
}
```
**核心实现思想**：将每把刀的劈砍和投掷伤害分开存储在结构体数组中，按伤害从大到小排序。优先使用投掷伤害，若遇到劈砍伤害则一次性计算需要的劈砍次数。

#### chengni
```cpp
struct p{
    int l;
    int r;
}a[1000000];

bool cmp(p xx, p yy){
    return xx.l > yy.l;
}

int main(){
    int n, h;
    int c = 0;
    scanf("%d%d", &n, &h);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &a[c++].l);
        a[c].r = 1;
        scanf("%d", &a[c++].l);
    }
    sort(a, a + c, cmp);
    int sum = 0;
    for(int i = 0; i < c; i++)
    {
        if(a[i].r == 1)
        {
            sum++;
            h -= a[i].l;
            if(h <= 0)
            {
                printf("%d", sum);
                return 0;
            }
        }
        else if(a[i].r != 1)
        {
            if(h % a[i].l == 0) sum += h / a[i].l;
            else sum += h / a[i].l + 1;
            printf("%d", sum);
            return 0;
        }
    }
}
```
**核心实现思想**：使用结构体数组存储刀的伤害和类型，按伤害从高到低排序。优先使用投掷伤害，若遇到劈砍伤害则计算需要的劈砍次数。

#### ___new2zy___
```cpp
struct knife
{
    int ai;
    bool f;
}m[2000018];

bool cmp(knife x, knife y)
{
    return x.ai > y.ai; // 返回伤害最大的刀 
}

int main()
{
    int N, H, ans = 0;
    N = read(), H = read();
    for(int i = 1; i <= N; i++)
        m[i].ai = read(),
        m[i + N].ai = read(),
        m[i + N].f = true;
    // 我们把每把刀看作是可以无限扔的和只能扔一次的两把刀，存进去 
    sort(m + 1, m + 1 + N * 2, cmp); // 排序，便于取 
    for(int i = 1; i <= 2 * N; i++) // 枚举 2 * N 把刀 
    {
        if(m[i].f) // 接下来贪心，如果刀可以飞出去就废掉，同时加上伤害 
        {
            ans++;
            H -= m[i].ai;
        }
        else
        {
            int u = H % m[i].ai;
            // 如果碰到第一把无限次飞而且伤害最高的就无限砍 
            ans += H / m[i].ai;
            // 一直砍到没血，记录 ans + 
            if(u) ans++;
            H = -1;
        }
        if(H <= 0)
        {
            printf("%d", ans);
            return 0;
        }
        // 如果怪物没血了就输出 
    }
}
```
**核心实现思想**：将每把刀的劈砍和投掷伤害分别存储在结构体数组中，按伤害从高到低排序。优先使用投掷伤害，若遇到劈砍伤害则计算需要的劈砍次数。

### 最优关键思路或技巧
- **结构体存储**：使用结构体存储刀的伤害和类型，方便排序和处理。
- **贪心策略**：优先使用伤害高的攻击方式，先投掷伤害高的刀，再用劈砍伤害高的刀。
- **排序**：对刀的伤害进行排序，确保每次选择伤害最大的攻击方式。

### 可拓展之处
同类型题或类似算法套路：
- 资源分配问题：如分配任务、资源等，优先选择价值高的资源。
- 活动选择问题：在多个活动中选择收益最大的活动组合。

### 推荐洛谷题目
- P1094 [NOIP2007 普及组] 纪念品分组
- P1223 排队接水
- P1803 凌乱的yyy / 线段覆盖

### 个人心得摘录与总结
- **ITZDC9**：一开始思路有误，通过具体例子发现问题，最终得出正确思路，提醒我们在解题时要多考虑特殊情况，验证思路的正确性。
- **___new2zy___**：一开始没看出来是贪心，乱搞了一个晚上，第二天才想到贪心策略，说明遇到问题时要多思考，尝试不同的方法，可能会有新的发现。

---
处理用时：64.22秒
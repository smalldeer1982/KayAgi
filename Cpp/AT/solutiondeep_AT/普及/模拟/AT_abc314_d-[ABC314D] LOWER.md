# 题目信息

# [ABC314D] LOWER

## 题目描述

给定一个由英文字母大写和小写字母组成的长度为 $N$ 的字符串 $S$。

接下来，将对字符串 $S$ 进行 $Q$ 次操作。第 $i$ 次操作（$1 \le i \le Q$）由两个整数和一个字符组成的三元组 $(t _ i, x _ i, c _ i)$ 表示，每种操作的含义如下：

- 当 $t _ i = 1$ 时，将 $S$ 的第 $x _ i$ 个字符修改为 $c _ i$。
- 当 $t _ i = 2$ 时，将 $S$ 中的所有大写字母全部转为小写（$x _ i$ 和 $c _ i$ 在此操作中不使用）。
- 当 $t _ i = 3$ 时，将 $S$ 中的所有小写字母全部转为大写（$x _ i$ 和 $c _ i$ 在此操作中不使用）。

输出经过 $Q$ 次操作后的字符串 $S$。

## 样例 #1

### 输入

```
7
AtCoder
5
1 4 i
3 0 a
1 5 b
2 0 a
1 4 Y```

### 输出

```
atcYber```

## 样例 #2

### 输入

```
35
TheQuickBrownFoxJumpsOverTheLazyDog
10
2 0 a
1 19 G
1 13 m
1 2 E
1 21 F
2 0 a
1 27 b
3 0 a
3 0 a
1 15 i```

### 输出

```
TEEQUICKBROWMFiXJUGPFOVERTBELAZYDOG```

# AI分析结果

### 题解综合分析与结论
这些题解的核心思路都是避免对每次操作都直接更新字符串，而是利用操作的特点，抓住最后一次大小写转换操作的影响，结合每个字符最后一次单点修改的时间，来确定最终字符串的状态。

- **思路对比**：大部分题解都采用记录最后一次 $2,3$ 操作的信息，以及每个字符最后一次 $1$ 操作的时间，以此来决定最终字符的大小写。部分题解通过倒序操作、线段树等方式实现，但本质相同。
- **算法要点**：关键在于记录最后一次 $2,3$ 操作的类型和时间，以及每个字符最后一次 $1$ 操作的时间。在最终处理时，根据这些信息判断字符是否需要进行大小写转换。
- **解决难点**：主要解决了多次大小写转换操作的覆盖问题，以及在最后一次大小写转换操作后，新的单点修改操作对结果的影响。

### 所选题解
- **guanyf（4星）**
    - **关键亮点**：思路清晰，先找到最后一次 $2,3$ 操作，然后模拟操作过程，代码实现简洁明了。
    - **核心代码**：
```cpp
for (int i = 1; i <= q; i++) {
    if (a[i].op == 1) {
        s[a[i].x] = a[i].y;
    } else if (i == lt) {
        for (int j = 1; j <= n; j++) {
            if (a[i].op == 2) {
                if (s[j] >= 'A' && s[j] <= 'Z') {
                    s[j] += 'a' - 'A';
                }
            } else {
                if (s[j] >= 'a' && s[j] <= 'z') {
                    s[j] += 'A' - 'a';
                }
            }
        }
    }
}
```
核心实现思想：先遍历操作，找到最后一次 $2,3$ 操作的位置 `lt`。然后再次遍历操作，对于 $1$ 操作直接修改字符，对于最后一次 $2,3$ 操作，对字符串进行相应的大小写转换。

- **Failure_Terminator（4星）**
    - **关键亮点**：通过记录上一次被操作的时间和最后一次 $2,3$ 操作的时间，避免了最后一次 $2,3$ 操作后 $1$ 操作被覆盖的问题。
    - **核心代码**：
```cpp
for (int i = 1; i <= m; i ++){
    int op = read();
    int x; char y;
    x = read(); cin >> y;
    if (op == 2)
        rev = 1, pl = i;
    if (op == 3)
        rev = 2, pl = i;
    if (op == 1)
        s[x - 1] = y, lst[x - 1] = i;
}
for (int i = 0; i < s.size(); i ++){
    if (lst[i] > pl){
        cout << s[i];
        continue;
    }
    if (rev == 1 && s[i] >= 'A' && s[i] <= 'Z') s[i] += 32;
    if (rev == 2 && s[i] >= 'a' && s[i] <= 'z') s[i] -= 32;
    cout << s[i];
} 
```
核心实现思想：遍历操作，记录最后一次 $2,3$ 操作的类型 `rev` 和时间 `pl`，以及每个字符最后一次 $1$ 操作的时间 `lst[i]`。最后遍历字符串，若 `lst[i] > pl`，则直接输出字符，否则根据 `rev` 进行大小写转换。

- **kkxacj（4星）**
    - **关键亮点**：思路简洁，通过标记每个字符更改的时间，与最后一次 $2,3$ 操作的时间比较，确定是否进行大小写转换。
    - **核心代码**：
```cpp
for(int i = 1;i <= q;i++)
{
    scanf("%d%d",&x,&y); cin >> z;
    y--;
    if(x == 1)
    {
        s[y] = z;
        bj[y] = i;
    }
    else if(x == 2) u = 1,l = i;
    else if(x == 3) u = 0,l = i;
}
for(int i = 0;i < s.size();i++)
{
    if(bj[i] < l)
    {
        if(u == 0 && 'a' <= s[i] && s[i] <= 'z') s[i] = s[i] - 'a' + 'A'; 
        else if(u == 1 && 'A' <= s[i] && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a'; 
    }
}
```
核心实现思想：遍历操作，记录最后一次 $2,3$ 操作的类型 `u` 和时间 `l`，以及每个字符最后一次 $1$ 操作的时间 `bj[i]`。最后遍历字符串，若 `bj[i] < l`，则根据 `u` 进行大小写转换。

### 最优关键思路或技巧
- 抓住最后一次 $2,3$ 操作的影响，忽略之前的同类操作，减少不必要的计算。
- 记录每个字符最后一次 $1$ 操作的时间，避免最后一次 $2,3$ 操作后新的 $1$ 操作被覆盖。

### 可拓展之处
同类型题可能涉及更多类型的操作，或者对不同操作的组合有更复杂的规则。类似算法套路可以应用于其他需要处理多次操作，且操作存在覆盖关系的问题，如区间修改、状态更新等。

### 推荐洛谷题目
- P1116 车厢重组：涉及对序列的操作和状态更新。
- P1047 校门外的树：需要处理区间操作和覆盖问题。
- P1094 纪念品分组：涉及对数据的分组和操作。

### 个人心得摘录与总结
- **Larry76**：提到暴力做时间复杂度高，用线段树大材小用，应继续思考操作的特点，发现只有最后一次修改和大小写转换有用，体现了遇到问题要深入分析，寻找更优解法的思想。
- **Crazyouth**：赛时把 $2,3$ 操作看成对特定区间变成大写，浪费了时间，提醒我们要仔细读题，理解操作的含义。 

---
处理用时：38.11秒
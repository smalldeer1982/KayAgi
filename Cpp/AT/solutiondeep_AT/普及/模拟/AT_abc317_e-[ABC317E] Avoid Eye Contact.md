# 题目信息

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>```

### 输出

```
15```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G```

### 输出

```
-1```

# AI分析结果

### 题目中文重写
有一个被划分为 $H$ 行 $W$ 列网格状的场地。从北（上方）数第 $i$ 行，从西（左侧）数第 $j$ 列的格子用字符 $A_{i,j}$ 表示。每个字符的含义如下：

- `.`：空地，可以进入。
- `#`：障碍物，不能进入。
- `>`、`v`、`<`、`^`：分别表示有面向东、南、西、北的人所在的格子，不能进入。人的视线宽度为一格，沿人所面对的方向笔直延伸，会被障碍物或其他人阻挡。（也可参考样例解释 1）
- `S`：起点，可以进入。保证只存在一处，且不在人的视线范围内。
- `G`：终点，可以进入。保证只存在一处，且不在人的视线范围内。

直弘君位于起点，可以向东西南北方向移动一格，移动次数不限。但不能进入不能进入的格子，也不能移出场地。

请判断他是否能在不进入任何人的视线的情况下到达终点，如果可以，求出最少需要移动多少次；如果不能，输出 $-1$。

### 综合分析与结论
这些题解的整体思路都是先预处理出人的视线范围，将这些范围标记为不可走区域，然后使用广度优先搜索（BFS）来寻找从起点到终点的最短路径。不同题解在预处理视线范围的方式和 BFS 的具体实现上存在一些差异。

### 思路对比
- **暴力标记**：大多数题解采用此方法，遍历网格找到人所在的格子，然后沿着其视线方向标记不可走区域，直到遇到障碍物或其他人，时间复杂度为 $O(HW)$。
- **二分查找**：happybob 的题解使用二分查找确定每个格子四个方向上第一个人的位置，复杂度为 $O(n^2 \log n)$。
- **动态规划**：liruixiong0101 的题解用动态规划求解人的视线范围，设 $f_{i,j,0/1/2/3}$ 表示被 `v/>/^/<` 所及之处，时间复杂度为 $O(HW)$。

### 算法要点
- **预处理**：将人的视线范围标记为不可走，确保 BFS 不会经过这些区域。
- **BFS**：从起点开始，逐层扩展，记录到达每个格子的步数，直到找到终点或队列为空。

### 解决难点
- **视线范围标记**：要正确处理人的视线被障碍物或其他人阻挡的情况。
- **边界条件**：在 BFS 过程中，要注意判断是否越界以及是否进入不可走区域。

### 题解评分与选择
| 作者 | 评分 | 关键亮点 |
| --- | --- | --- |
| FinderHT | 4星 | 思路清晰，代码注释详细，易于理解。 |
| Dream_poetry | 4星 | 代码简洁，对视线范围标记的处理清晰。 |
| __Dist__ | 4星 | 思路和代码结构清晰，逻辑明确。 |

### 所选题解详情
- **FinderHT（4星）**
    - **关键亮点**：思路清晰，代码注释详细，易于理解。
    - **核心代码**：
```cpp
// 标记视线范围
for(int i=1;i<=h;i++){
    for(int j=1;j<=w;j++){
        if(s[i][j]=='>'){
            int y=j+1;
            while(s[i][y]=='.'||use[i][y]&&y<=w)use[i][y++]=true;
        }
        // 其他方向类似
    }
}
// BFS
queue<pii>q;
q.push(make_pair(a,b));
while(q.size()){
    pii tmp=q.front();
    q.pop();
    for(int i=0;i<4;i++){
        int xx=tmp.fst+dx[i];
        int yy=tmp.snd+dy[i];
        if(xx>0&&xx<=h&&yy>0&&yy<=w&&
        s[xx][yy]!='#'&&s[xx][yy]!='<'&&s[xx][yy]!='>'&&s[xx][yy]!='^'&&s[xx][yy]!='v'&&
       !ans[xx][yy]&&!use[xx][yy]){
            q.push(make_pair(xx,yy));
            ans[xx][yy]=ans[tmp.fst][tmp.snd]+1;
        }
    }
}
```
- **Dream_poetry（4星）**
    - **关键亮点**：代码简洁，对视线范围标记的处理清晰。
    - **核心代码**：
```cpp
// 标记视线范围
for(int i=1;i<=h;i++){
    for(int j=1;j<=w;j++){
        if(ch[i][j]=='<'){
            int ii=i,jj=j-1;
            while((ch[ii][jj]=='.'||ch[ii][jj]=='!')&&jj>=1) ch[ii][jj--]='!';
        }
        // 其他方向类似
    }
}
// BFS
queue<pair<int,int> > q;
q.push({sx,sy});
while(q.size()){
    int x=q.front().first;
    int y=q.front().second;
    q.pop();
    for(int i=0;i<4;i++){
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(xx>=1 && xx<=h && yy>=1 
            && yy<=w &&!fff[xx][yy] && ch[xx][yy]!='!' 
            && ch[xx][yy]!='#' && ch[xx][yy]!='<' && ch[xx][yy]!='>'  
            &&ch[xx][yy]!='^'&&ch[xx][yy]!='v'){
            q.push({xx,yy});
            fff[xx][yy]=fff[x][y]+1;
        }
    }
}
```
- **__Dist__（4星）**
    - **关键亮点**：思路和代码结构清晰，逻辑明确。
    - **核心代码**：
```cpp
// 标记视线范围
for(int i=1;i<=h;i++){
    for(int j=1;j<=w;j++){
        if(ch[i][j]=='<'){
            int ii=i,jj=j-1;
            while((ch[ii][jj]=='.'||ch[ii][jj]=='!')&&jj>=1) ch[ii][jj--]='!';
        }
        // 其他方向类似
    }
}
// BFS
queue<pair<int,int> > q;
q.push({sx,sy});
while(q.size()){
    int x=q.front().first;
    int y=q.front().second;
    q.pop();
    for(int i=0;i<4;i++){
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(xx>=1&&xx<=h&&yy>=1&&yy<=w&&!step[xx][yy]
        &&ch[xx][yy]!='!'&&ch[xx][yy]!='#'&&ch[xx][yy]!='<'&&ch[xx][yy]!='>'
        &&ch[xx][yy]!='^'&&ch[xx][yy]!='v'){
            q.push({xx,yy});
            step[xx][yy]=step[x][y]+1;
        }
    }
}
```

### 最优关键思路或技巧
- **预处理视线范围**：通过遍历网格，标记出人的视线范围，将其视为不可走区域，简化后续 BFS 过程。
- **BFS 求最短路径**：利用 BFS 的层序遍历特性，确保找到的路径是最短的。

### 拓展思路
同类型题可能会有不同的地图规则或移动限制，如增加移动方向、设置不同类型的障碍物等，但核心思路仍然是预处理不可走区域，然后使用 BFS 或其他搜索算法寻找路径。

### 洛谷相似题目推荐
1. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
2. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)
3. [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)

### 个人心得摘录与总结
- **Failure_Terminator**：标记视线范围时不要覆盖原数组，否则会导致一些错误。总结：在处理数据时要注意避免数据覆盖，以免影响后续判断。 

---
处理用时：51.96秒
# 题目信息

# [ABC320C] Slot Strategy 2 (Easy)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc320/tasks/abc320_c

> この問題は G 問題の簡易版です。

$ 3 $ 個のリールからなるスロットがあります。  
 $ i $ 番目のリールの配列は文字列 $ S_i $ によって表されます。ここで、$ S_i $ は数字のみからなる長さ $ M $ の文字列です。

それぞれのリールには対応するボタンがついています。高橋君は各非負整数 $ t $ について、スロットが回り始めてからちょうど $ t $ 秒後にボタンを $ 1 $ つ選んで押す、または何もしないことができます。  
 スロットが回り始めてから $ t $ 秒後に $ i $ 番目のリールに対応するボタンを押すと、$ i $ 番目のリールは $ S_i $ の $ (t\ \bmod\ M)+1 $ 文字目を表示して止まります。  
 ただし、$ t\ \bmod\ M $ で $ t $ を $ M $ で割ったあまりを表します。

高橋君は全てのリールを止めた上で、表示されている文字が全て同じであるようにしたいです。  
 高橋君が目標を達成できるように全てのリールを止めるまでに、スロットが回り始めてから最小で何秒かかるかを求めてください。  
 そのようなことが不可能であればそのことを報告してください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ 100 $
- $ M $ は整数
- $ S_i $ は数字のみからなる長さ $ M $ の文字列
 
### Sample Explanation 1

高橋君は次のようにそれぞれのリールを止めることでスロットが回り始めてから $ 6 $ 秒後にリールに表示される文字を `8` で揃えることができます。 - スロットの回転開始から $ 0 $ 秒後に $ 2 $ 番目のリールに対応するボタンを押します。$ 2 $ 番目のリールは $ S_2 $ の $ (0\ \bmod\ 10)+1=1 $ 文字目である `8` を表示して止まります。 - スロットの回転開始から $ 2 $ 秒後に $ 3 $ 番目のリールに対応するボタンを押します。$ 3 $ 番目のリールは $ S_3 $ の $ (2\ \bmod\ 10)+1=3 $ 文字目である `8` を表示して止まります。 - スロットの回転開始から $ 6 $ 秒後に $ 1 $ 番目のリールに対応するボタンを押します。$ 1 $ 番目のリールは $ S_1 $ の $ (6\ \bmod\ 10)+1=7 $ 文字目である `8` を表示して止まります。 $ 5 $ 秒以下で全てのリールに表示されている文字を揃える方法はないため、$ 6 $ を出力します。

### Sample Explanation 2

全てのリールを止めた上で、表示されている文字を揃える必要がある事に注意してください。

### Sample Explanation 3

表示されている文字が全て同じであるようにリールを止めることはできません。 このとき `-1` を出力してください。

## 样例 #1

### 输入

```
10

1937458062

8124690357

2385760149```

### 输出

```
6```

## 样例 #2

### 输入

```
20

01234567890123456789

01234567890123456789

01234567890123456789```

### 输出

```
20```

## 样例 #3

### 输入

```
5

11111

22222

33333```

### 输出

```
-1```

# AI分析结果

### 题目翻译
这是 G 问题的简化版本。

有一个由 3 个转轮组成的老虎机。
第 $i$ 个转轮的排列由字符串 $S_i$ 表示。这里，$S_i$ 是一个仅由数字组成的长度为 $M$ 的字符串。

每个转轮都有对应的按钮。对于每个非负整数 $t$，高桥君可以在老虎机开始旋转后的第 $t$ 秒选择按下一个按钮，或者什么都不做。
如果在老虎机开始旋转后的第 $t$ 秒按下第 $i$ 个转轮对应的按钮，第 $i$ 个转轮将显示 $S_i$ 的第 $(t\ \bmod\ M)+1$ 个字符并停止。
这里，$t\ \bmod\ M$ 表示 $t$ 除以 $M$ 的余数。

高桥君希望在停止所有转轮后，使显示的字符全部相同。
请计算高桥君为了实现这个目标，从老虎机开始旋转到停止所有转轮所需的最短时间。
如果无法实现这个目标，请报告这一情况。

### 综合分析与结论
这些题解大多采用暴力枚举的方法解决问题，因为数据范围较小（$1 \leq M \leq 100$）。不同题解的主要差异在于对转轮循环和时间计算的处理方式。

#### 思路对比
- **复制字符串法**：将每个转轮的字符串复制多份，模拟转轮多圈转动，通过三重循环枚举所有可能的停止时间，找到满足条件的最小时间。
- **枚举排列法**：枚举停止转轮的不同排列顺序，针对每种排列计算满足条件的最小时间。
- **桶记录法**：使用桶记录每个数字在每个转轮中出现的情况，优化枚举过程。

#### 算法要点
- **复制字符串法**：将字符串复制 2 - 4 倍，扩大枚举范围，确保能覆盖所有可能的情况。
- **枚举排列法**：考虑所有可能的停止顺序，计算每种顺序下的最小时间。
- **桶记录法**：通过桶记录数字出现情况，避免不必要的枚举。

#### 解决难点
- **避免同时按下按钮**：确保三个转轮的停止时间不同。
- **处理转轮循环**：通过复制字符串或取模运算模拟转轮的循环转动。

### 评分较高的题解
- **作者：2c_s (赞：5)，4星**
  - **关键亮点**：思路清晰，代码简洁，通过复制字符串模拟转轮多圈转动，容易理解。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=1e9;
string a,b,c;
int main(){
    cin>>n>>a>>b>>c;
    a=a+a+a;
    b=b+b+b;
    c=c+c+c;
    n=n+n+n;
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            for(int k=0;k<n;++k){
                if(a[i]==b[j]&&b[j]==c[k]&&i!=j&&j!=k&&i!=k){
                    ans=min(ans,max({i,j,k}));
                }
            }
        }
    }
    if(ans==1e9)cout<<-1;
    else cout<<ans;
    return 0;
}
```
- **作者：kimidonatsu (赞：1)，4星**
  - **关键亮点**：代码规范，使用 `std::vector` 存储字符串，通过取模运算模拟转轮循环，逻辑清晰。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
void solve() {
    int M;
    std::cin >> M;
    int N = 3;
    std::vector<std::string> S(N);
    for (int i = 0; i < N; i++) {
        std::cin >> S[i];
    }
    int INF = std::numeric_limits<int>::max();
    int ans = INF;
    for (int i = 0; i < N * M; i++) {
        for (int j = 0; j < N * M; j++) {
            for (int k = 0; k < N * M; k++) {
                if (i != j && i != k && j != k && S[0][i % M] == S[1][j % M] && S[1][j % M] == S[2][k % M]) {
                    ans = std::min(ans, std::max({i, j, k}));
                }
            }
        }
    }
    std::cout << (ans < INF ? std::to_string(ans) : "-1") << std::endl;
}
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    solve();
    return 0;
}
```
- **作者：CommunismFighter (赞：1)，4星**
  - **关键亮点**：预处理每个数字在每个转轮中出现的位置，减少不必要的枚举，时间复杂度较低。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mian main
#define rg register int 
using namespace std;
const int N = 105;
int len,ps[5][15][1005],times[5][15],ans = LONG_LONG_MAX;
char s[5][N];
signed mian(){
    scanf("%lld",&len);
    for(int i=0;i<3;++i) scanf("%s",s[i]);
    for(int i=0;i<3;++i){
        for(int j=0;j<len;++j){
            ps[i][s[i][j]-'0'][++times[i][s[i][j]-'0']] = j;
        }        
    }
    for(int i=0;i<10;++i){
        for(int j=1;j<=times[0][i];++j){
            int nw1 = ps[0][i][j];
            for(int z=1;z<=times[1][i];++z){
                int nw2 = ps[1][i][z];
                for(int q=1;q<=times[2][i];++q){
                    int nw3 = ps[2][i][q];
                    if(nw1==nw2 && nw1==nw3 && nw2==nw3){
                        ans = min(ans,nw1+len+len);
                    }else{
                        if(nw1==nw2){
                            ans = min(ans,max(nw1,max(nw2+len,nw3)));
                        }else if(nw1==nw3){
                            ans = min(ans,max(nw1,max(nw2,nw3+len)));
                        }else if(nw2==nw3){
                            ans = min(ans,max(nw1,max(nw2,nw3+len)));
                        }else{
                            ans = min(ans,max(nw1,max(nw2,nw3)));
                        }
                    }
                }
            }
        }        
    }
    if(ans==LONG_LONG_MAX){
        puts("-1");
        return 0;
    }
    printf("%lld\n",ans);
    return 0;
}
```

### 最优关键思路或技巧
- **复制字符串模拟多圈转动**：将字符串复制多份，扩大枚举范围，确保能覆盖所有可能的情况。
- **预处理数字出现位置**：记录每个数字在每个转轮中出现的位置，减少不必要的枚举。

### 拓展思路
同类型题目可能会增加转轮数量、改变转轮的转动规则或增加其他限制条件。可以采用类似的暴力枚举或预处理的方法解决，根据具体情况进行调整。

### 推荐洛谷题目
1. [P1008 三连击](https://www.luogu.com.cn/problem/P1008)
2. [P1012 拼数](https://www.luogu.com.cn/problem/P1012)
3. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

### 个人心得摘录与总结
- **作者：AC_love**：指出大多数题解的 $O(m^3)$ 暴力枚举在 $m$ 增大时容易超时，提出用 $O(m)$ 枚举和桶记录的方法优化复杂度，并详细解释了处理相同数字的思路和避免错误的方法。总结：在处理类似问题时，要考虑复杂度优化，注意细节处理，避免逻辑错误。

---
处理用时：53.90秒
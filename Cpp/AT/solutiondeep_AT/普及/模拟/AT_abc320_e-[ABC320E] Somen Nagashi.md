# 题目信息

# [ABC320E] Somen Nagashi

## 题目描述

现有 $N$ 个人排成一队，编号从 $1$ 到 $N$，玩一个叫做“流水面条”的游戏，该游戏共有 $M$ 个事件，每个事件含三个变量 $T_i,W_i,S_i$，事件的规则如下：

- 在 $T_i$ 时刻，有 $W_i$ 根面条流了下来，队头的人拿走这些面条，并离开队列，然后于第 $T_i+S_i$ 时刻返回队列，然后返回他的原始位置。

若队列为空，则该事件忽略。

注意：若他于第 $X$ 时刻返回队列，则视为他第 $X$ 时刻在队列。

一开始每个人都有 $0$ 根面条，现要你求出这 $N$ 个人每个人获得了多少面条。

## 说明/提示

#### 样例#1说明：
第 $1$ 个人于 $1$ 时刻拿走 $1$ 根面条，将于 $4$ 时刻返回队列。

第 $2$ 个人于 $2$ 时刻拿走 $10$ 根面条，将于 $102$ 时刻返回队列。

第 $1$ 个人于 $4$ 时刻归队，返回第 $1$ 位，此时他处于队头，然后拿走 $100$ 根面条，将于 $10004$ 时刻返回队列。

第 $3$ 个人于 $10$ 时刻拿走 $1000$ 根面条，将于第 $1000000010$ 时刻归队。

第 $100$ 时刻，队内无人。

最终，这 $3$ 个人分别有 $101,10,1000$ 根面条。

## 样例 #1

### 输入

```
3 5

1 1 3

2 10 100

4 100 10000

10 1000 1000000000

100 1000000000 1```

### 输出

```
101

10

1000```

## 样例 #2

### 输入

```
3 1

1 1 1```

### 输出

```
1

0

0```

## 样例 #3

### 输入

```
1 8

1 1 1

2 2 2

3 3 3

4 4 4

5 5 5

6 6 6

7 7 7

8 8 8```

### 输出

```
15```

# AI分析结果

### 题目内容（已为中文，无需翻译）
现有 $N$ 个人排成一队，编号从 $1$ 到 $N$，玩一个叫做“流水面条”的游戏，该游戏共有 $M$ 个事件，每个事件含三个变量 $T_i,W_i,S_i$，事件的规则如下：

- 在 $T_i$ 时刻，有 $W_i$ 根面条流了下来，队头的人拿走这些面条，并离开队列，然后于第 $T_i+S_i$ 时刻返回队列，然后返回他的原始位置。

若队列为空，则该事件忽略。

注意：若他于第 $X$ 时刻返回队列，则视为他第 $X$ 时刻在队列。

一开始每个人都有 $0$ 根面条，现要你求出这 $N$ 个人每个人获得了多少面条。

### 综合分析与结论
这些题解主要围绕模拟“流水面条”游戏展开，核心是维护当前队列和出队人员的信息，以确定每个时刻谁能拿到面条。
- **思路对比**：大部分题解采用双优先队列（小根堆）的方式，一个按时间排序维护事件（人归队和面条掉落），另一个按编号排序维护队列中的人；部分题解使用线段树、树状数组或 `set` 来维护队列信息。
- **算法要点**：
    - 双优先队列：每次面条掉落时，先将所有归队时间小于等于当前时间的人加入队列，再让队首的人拿走面条并出队，记录其归队时间。
    - 线段树/树状数组：通过维护区间最小值或前缀和来找到队列中编号最小的人。
    - `set`：利用 `set` 的有序性，快速找到队列中编号最小的人，并通过离线处理人员归队时间。
- **解决难点**：
    - 处理人员归队：确保在面条掉落时，所有应归队的人都已归队。
    - 确定队首：快速找到队列中编号最小的人。

### 评分较高的题解
1. **作者：robertuu（5星）**
    - **关键亮点**：思路清晰，代码简洁，使用两个优先队列分别维护事件和队列，通过重载运算符实现事件的排序，易于理解和实现。
    - **核心代码**：
```cpp
struct noddle {int t,w,s;};
bool operator <(noddle x,noddle y)
{
    if(x.t!= y.t) return x.t > y.t;
    return x.s > y.s; // 投机取巧，归队事件的 s 设为 0
}
priority_queue<noddle> q;
priority_queue<int,vector<int>,greater<int>> l;
long long ans[200001];
while(!q.empty())
{
    noddle tmp = q.top();
    q.pop();
    if(tmp.s == 0) l.push(tmp.w); // 归队
    else if(!l.empty()) // 出现物品
    {
        ans[l.top()] += tmp.w;
        q.push((noddle){tmp.t+tmp.s,l.top(),0});
        l.pop();
    }
}
```
2. **作者：zengziqvan（4星）**
    - **关键亮点**：使用 `multiset` 和 `multimap` 维护队列和人员归队时间，思路独特，代码实现较为巧妙。
    - **核心代码**：
```cpp
multiset<ll>s1,s2;
multimap<ll,int>mp;
ll a[200010];
for(int i=1;i<=m;++i) {
    int t,c,w;
    cin>>t>>c>>w;
    while(t>=*s2.begin()&&s2.size()) {
        s1.insert(mp.find(*s2.begin())->second);
        mp.erase(mp.find(*s2.begin()));
        s2.erase(s2.begin());
    }
    if(s1.empty()) continue;
    a[*s1.begin()]+=c;
    mp.insert(make_pair(w+t,*s1.begin()));
    s1.erase(s1.begin());
    s2.insert(w+t);
}
```
3. **作者：fcy20180201（4星）**
    - **关键亮点**：通过离散化处理事件，使用优先队列维护队列信息，代码逻辑严谨，对事件的处理较为细致。
    - **核心代码**：
```cpp
struct TTT{//记录所有事件
    bool por;
    int t,s;
    ll w;
    vector<int>rp;
}evt0[400005];
bool operator <(const TTT &a,const TTT &b){//排序和 lower_bound 需要
    return a.t==b.t?a.por<b.por:a.t<b.t;
}
bool operator ==(const TTT &a,const TTT &b){//unique 需要
    return a.t==b.t && a.s==b.s && a.por==b.por && a.w==b.w && a.rp==b.rp;
}
priority_queue<int, vector<int>, greater<int>>q;//小编号在前的 priority_queue
for(int i=0;i<cnt;i++){
    if(evt0[i].por){//若人离开
        if(q.empty())continue;
        int x=q.top();q.pop();
        ans[x]+=evt0[i].w;
        evt0[lower_bound(evt0,evt0+cnt,(TTT){false,evt0[i].t+evt0[i].s,0,0,emp})-evt0].rp.push_back(x);
    }
    else{for(int x:evt0[i].rp)q.push(x);}
}
```

### 最优关键思路或技巧
- **双优先队列**：使用两个优先队列分别维护事件和队列，能高效处理人员归队和面条分配，时间复杂度较低。
- **离散化**：对事件进行离散化处理，减少不必要的计算，提高算法效率。

### 可拓展之处
同类型题或类似算法套路：
- 模拟游戏类题目：如模拟排队、资源分配等问题，可使用优先队列、线段树等数据结构维护状态。
- 事件处理类题目：涉及多个事件按时间顺序发生，可使用优先队列按时间排序处理事件。

### 推荐题目
1. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)：模拟排队出圈问题，可使用队列或链表实现。
2. [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)：模拟队列操作，可使用链表或数组实现。
3. [P1241 括号序列](https://www.luogu.com.cn/problem/P1241)：模拟括号匹配过程，可使用栈实现。

### 个人心得摘录与总结
- **zhizhi_c**：此题不难，但不好调，比赛结束后才调出来。总结：模拟题虽思路简单，但实现细节较多，需要仔细调试。
- **rainygame**：一眼线段树上二分，但赛时调了好久。思路由 CSP - J1 2023 完善程序第一题启发。总结：遇到问题可联想相似题目，线段树等数据结构实现复杂，调试需耐心。
- **happybob**：感觉别人写的太复杂了。总结：不同人对问题的理解和实现方式不同，可尝试寻找更简洁的解法。
- **OldDriverTree**：第一次赛时自己想出 E 题祭。总结：通过练习和思考，不断提升解决问题的能力。 

---
处理用时：50.43秒
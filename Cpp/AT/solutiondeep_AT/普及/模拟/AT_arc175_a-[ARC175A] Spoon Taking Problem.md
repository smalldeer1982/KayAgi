# 题目信息

# [ARC175A] Spoon Taking Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc175/tasks/arc175_a

$ N $ 人が円卓に座っており，各人は反時計回りに順に $ 1,\ \ldots,\ N $ と番号付けられています．各人はそれぞれ左右どちらか一方の利き手を持っています．

円卓上には $ 1,\ \ldots,\ N $ と番号付けられた計 $ N $ 本のスプーンが，隣り合う二人の間に $ 1 $ 本ずつ置いてあります．各 $ 1\ \leq\ i\ \leq\ N $ について，人 $ i $ の左側，右側にはそれぞれスプーン $ i $，スプーン $ (i+1) $ があります．ここで，スプーン $ (N+1) $ はスプーン $ 1 $ のことを指します．

$ N\ =\ 4 $ での模式図を以下に示します．

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc175_a/e6f0a6024a199111c69d24084c2b3068c72489fd.png)

$ (1,\ \dots,\ N) $ の順列 $ (P_1,\ \dots,\ P_N) $ が与えられます．$ i=1,\dots,N $ の順に，人 $ P_i $ が以下のように行動します．

- 自分の右側または左側にスプーンが残っているならば，そのうち $ 1 $ つを取る． 
  - このとき自分の両側にスプーンが残っているならば，自分の利き手の側のスプーンを取る．
- そうでないならば何もしない．
 
`L`, `R`, `?` からなる長さ $ N $ の文字列 $ S $ が与えられます．$ N $ 人の利き手の組み合わせは $ 2^N $ 通りありますが，そのうち以下の条件を全て満たすような組み合わせの数を $ 998244353 $ で割った余りを求めてください．

- $ S $ の $ i $ 番目の文字が `L` ならば，人 $ i $ は左利きである．
- $ S $ の $ i $ 番目の文字が `R` ならば，人 $ i $ は右利きである．
- 全員の行動が終了したとき，全員がスプーンを取っている．

## 说明/提示

### 制約

- 入力される数値は全て整数
- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ (P_1,\ \dots,\ P_N) $ は $ (1,\ \dots,\ N) $ の順列
- $ S $ は `L`, `R`, `?` からなる長さ $ N $ の文字列
 
### Sample Explanation 1

人 $ 1,2,3 $ がそれぞれ左利き，左利き，右利きのとき，以下のように行動が行われます． - 人 $ 1 $ が行動を開始する．人 $ 1 $ の両側にスプーンが残っているので，人 $ 1 $ の利き手と同じ左側のスプーン $ 1 $ を取る． - 人 $ 2 $ が行動を開始する．人 $ 2 $ の両側にスプーンが残っているので，人 $ 2 $ の利き手と同じ左側のスプーン $ 2 $ を取る． - 人 $ 3 $ が行動を開始する．人 $ 3 $ の右側にはスプーンが残っておらず，左側にはスプーン $ 3 $ が残っているので，スプーン $ 3 $ を取る．全員の行動が終了し，このとき全員がスプーンを取っている． この利き手の組み合わせは条件を満たします．他には人 $ 1,2,3 $ がそれぞれ左利き，左利き，左利きの場合も条件を満たします．

### Sample Explanation 2

条件を満たす利き手の組み合わせが存在しません．

## 样例 #1

### 输入

```
3

1 2 3

L??```

### 输出

```
2```

## 样例 #2

### 输入

```
3

1 3 2

R?L```

### 输出

```
0```

## 样例 #3

### 输入

```
12

6 2 9 3 1 4 11 5 12 10 7 8

????????????```

### 输出

```
160```

# AI分析结果

### 题目翻译
$N$ 个人围坐在圆桌旁，每个人按逆时针顺序依次编号为 $1, \ldots, N$。每个人都有左右其中一只惯用手。

圆桌上共有编号为 $1, \ldots, N$ 的 $N$ 把勺子，相邻两人之间各放一把。对于每个 $1 \leq i \leq N$，人 $i$ 的左侧和右侧分别放着勺子 $i$ 和勺子 $(i + 1)$。这里，勺子 $(N + 1)$ 指的就是勺子 $1$。

$N = 4$ 时的示意图如下：
![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc175_a/e6f0a6024a199111c69d24084c2b3068c72489fd.png)

给定一个 $(1, \ldots, N)$ 的排列 $(P_1, \ldots, P_N)$。按照 $i = 1, \ldots, N$ 的顺序，人 $P_i$ 会进行如下操作：
- 如果自己右侧或左侧有剩余的勺子，就取走其中一把。
  - 若此时自己两侧都有剩余的勺子，则取走自己惯用手一侧的勺子。
- 若两侧都没有勺子，则什么也不做。

给定一个由 `L`、`R`、`?` 组成的长度为 $N$ 的字符串 $S$。$N$ 个人的惯用手组合共有 $2^N$ 种，求其中满足以下所有条件的组合数对 $998244353$ 取模的结果：
- 若 $S$ 的第 $i$ 个字符为 `L`，则人 $i$ 是左撇子。
- 若 $S$ 的第 $i$ 个字符为 `R`，则人 $i$ 是右撇子。
- 所有人操作结束后，每个人都拿到了一把勺子。

### 综合分析与结论
这些题解的核心思路都是发现满足条件的情况只有所有人都拿左手边的勺子或者都拿右手边的勺子这两种。然后分别对这两种情况进行模拟，根据每个人的惯用手信息和勺子的剩余情况来计算方案数，最后将两种情况的方案数相加并对 $998244353$ 取模。

- **思路对比**：大部分题解思路一致，都是分类讨论全拿左边和全拿右边的情况。部分题解从暴力枚举所有可能的惯用手组合开始，再优化到分类讨论的方法。
- **算法要点**：主要是模拟拿勺子的过程，根据每个人的惯用手和勺子的状态更新方案数。对于惯用手未知的情况，根据其相邻勺子的状态判断是否可以有两种选择。
- **解决难点**：处理环的情况，即勺子编号的循环；判断无解的情况，如惯用手与拿勺子方向冲突；注意取模操作，避免结果溢出。

### 所选题解
- **作者：KSCD_ (赞：2)，4星**
  - **关键亮点**：思路清晰，代码简洁，对取勺子的过程模拟和方案数计算的逻辑解释详细。
  - **个人心得**：无
- **作者：JuRuoOIer (赞：1)，4星**
  - **关键亮点**：强调了模拟做法，对重要性质的解释简单易懂，提醒了取模的重要性。
  - **个人心得**：赛时由于把两次模拟的答案加在一起时忘记取模，导致吃了 $5$ 发罚时，并额外调了 $20$ 分钟，最终 perf 从约 $1620$ 掉到 $1382$，少上了好几十分。
- **作者：whrwlx (赞：3)，4星**
  - **关键亮点**：提供了暴力枚举和分类讨论两种方法，对分类讨论的情况分析详细，代码实现中对边界情况处理清晰。
  - **个人心得**：注意取模，警示后人。

### 重点代码
#### KSCD_ 的代码
```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int N=2e5+10;
const int mod=998244353;
int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){ if(ch=='-') w=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){ s=s*10+ch-'0'; ch=getchar();}
    return s*w;
}
int n,sa=1,sb=1,p[N]; 
char s[N];
bool v[N];//勺子是否被取走 
signed main()
{
    n=read();
    for(int i=1;i<=n;i++) p[i]=read();
    cin>>s;
    for(int i=1;i<=n;i++)//所有人都取左手边的 
    {
        if(v[(p[i]%n)+1]) //若另一把已被取走，则惯用手任意 
        {
            if(s[p[i]-1]=='?') sa=(sa*2)%mod;//若是问号则乘2 
        }
        else if(s[p[i]-1]=='R') //另一把未被取走，则需确定惯用手 
        {
            sa=0;
            break;
        }//此时若与给定信息冲突则无解 
        v[p[i]]=1;//标记已取走 
    }
    memset(v,0,sizeof(v));
    for(int i=1;i<=n;i++)//都取右手边的，同上 
    {
        if(v[p[i]]) 
        {
            if(s[p[i]-1]=='?') sb=(sb*2)%mod;
        } 
        else if(s[p[i]-1]=='L')
        {
            sb=0;
            break;
        }
        v[(p[i]%n)+1]=1;
    }
    cout<<(sa+sb)%mod;
    return 0;
}
```
**核心实现思想**：使用数组 `v` 标记勺子是否被取走，分别模拟所有人都取左手边和都取右手边的情况。在模拟过程中，根据勺子的状态和人的惯用手信息更新方案数 `sa` 和 `sb`，若出现冲突则方案数置为 $0$。最后将两种情况的方案数相加并取模输出。

#### JuRuoOIer 的代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<cstring>
#include<string>
#define ll long long
#define ull unsigned long long
#define lf double
#define ld long double
using namespace std;
const ll mod=998244353;
ll n,a[2000010],b[2000010],vis[2000010],flgl,flgr,ans=1,ans2;
string s;
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
        a[i]--;
    }
    cin>>s;
    for(int i=0;i<n;i++){
        if(vis[a[i]]||vis[(a[i]+1)%n]){
            vis[a[i]]=1;
            vis[(a[i]+1)%n]=1;
            if(s[a[i]]=='?')ans*=2;
            ans%=mod;
        }
        else{
            if(s[a[i]]=='R'){
                ans=0;
                break;
            }
            vis[a[i]]=1;
        }
    }
    memset(vis,0,sizeof(vis));
    ans2=ans;
    ans=1;
    for(int i=0;i<n;i++){
        if(vis[a[i]]||vis[(a[i]+1)%n]){
            vis[a[i]]=1;
            vis[(a[i]+1)%n]=1;
            if(s[a[i]]=='?')ans*=2;
            ans%=mod;
        }
        else{
            if(s[a[i]]=='L'){
                ans=0;
                break;
            }
            vis[(a[i]+1)%n]=1;
        }
    }
    cout<<(ans+ans2)%mod;
    return 0;
}
```
**核心实现思想**：同样使用数组 `vis` 标记勺子是否被取走，先模拟所有人都取左手边的情况，更新方案数 `ans`，若出现冲突则 `ans` 置为 $0$。然后重置 `vis` 数组，模拟所有人都取右手边的情况，更新方案数 `ans2`。最后将两种情况的方案数相加并取模输出。

#### whrwlx 的代码
```c++
#include<bits/stdc++.h>
#define put(n) scanf("%lld",&n) 
#define out(n) printf("%lld\n",n)
#define int long long
#define fd(i,a,b) for(int i=a;i<=b;i=-~i)
using namespace std;
int n,p[1000100],f[1000100],mod=998244353;
//f记录第i个人第几个拿
char s[1000100];
int ans1=1,ans2=1;// 拿左边 拿右边
signed main()
{
    put(n);
    fd(i,1,n) put(p[i]),f[p[i]]=i;
    fd(i,1,n) cin>>s[i];
    //第一个拿的人拿左边
    fd(i,1,n)
    {
        int r=p[i]+1;//r 当前拿的人右边的人的编号
        if(r==n+1) r=1;//小坑
        if(s[p[i]]=='?')
        {
            if(f[r]<i) ans1*=2;
            ans1%=mod;
        }
        else if(s[p[i]]=='R')
        {
            if(f[r]>i)
            {
                i=n+1;
                ans1=0;
                break;
            }
        }
    }
    //第一个拿的人拿右边
    fd(i,1,n)
    {
        int l=p[i]-1;//l 当前拿的人左边的人的编号
        if(l==0) l=n;//小坑
        if(s[p[i]]=='?')
        {
            if(f[l]<i) ans2*=2;
            ans2%=mod;
        }
        else if(s[p[i]]=='L')
        {
            if(f[l]>i)
            {
                i=n+1;
                ans2=0;
                break;
            }
        }
    }
    if(s[p[1]]=='R') out(ans2);
    else if(s[p[1]]=='L') out(ans1);
    else out((ans1+ans2)%mod);//如果Pi为?那么算两种情况之和
    return 0;
}
```
**核心实现思想**：使用数组 `f` 记录每个人拿勺子的顺序，分别模拟第一个拿的人拿左边和拿右边的情况。在模拟过程中，根据当前人的惯用手和其相邻人的拿勺子顺序更新方案数 `ans1` 和 `ans2`，若出现冲突则相应的方案数置为 $0$。最后根据第一个人的惯用手信息输出结果。

### 最优关键思路或技巧
- **性质发现**：通过分析发现满足条件的情况只有所有人都拿左手边的勺子或者都拿右手边的勺子这两种，大大简化了问题。
- **分类讨论**：分别对这两种情况进行模拟，根据每个人的惯用手信息和勺子的剩余情况来计算方案数。
- **取模操作**：在计算过程中及时取模，避免结果溢出。

### 可拓展之处
同类型题可能会有更多的限制条件或更复杂的场景，例如增加勺子的种类、改变拿勺子的规则等。类似算法套路可以用于解决一些环形排列的问题，通过分析问题的性质，将复杂问题简化为几种简单情况进行讨论。

### 推荐题目
- [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)：涉及路径规划和状态转移，需要分析各种情况并进行计算。
- [P1216 [USACO1.5] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)：需要通过动态规划的方法，分析不同路径的情况来求解最优解。
- [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)：是一个典型的背包问题，需要考虑不同物品的选择情况来计算最大价值。

### 个人心得总结
- JuRuoOIer 提醒在模拟过程中，将两次模拟的答案加在一起时一定要再次取模，否则可能会导致罚时和分数损失。
- whrwlx 强调了取模的重要性，警示后人注意。

---
处理用时：79.48秒
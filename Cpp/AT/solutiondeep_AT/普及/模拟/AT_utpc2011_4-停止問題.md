# 题目信息

# 停止問題

## 题目描述

Defunge 程序由一个 $R$ 行 $C$ 列的字符数组组成。下面是一个 Defunge 程序的例子：

```plain
6>--v.
.^--_@
```

Defunge 程序从程序的左上角（即第一行第一列）开始执行。**它的执行方向一开始为"右"**，每次朝着执行方向走一步，**如果走出界了，要跳到另一边**。每走到一个格子上，就要执行这个格子上的命令。 Defunge 程序还有一个存储器，这个存储器只能存储 $[0,15]$ 的一个整数，**存储器一开始存储** $\bold{0}$。

在 Defunge 程序中，有且只有 $11+10=21$ 种命令，下面是它们各自的含义：

- `<`：把执行方向设置为"左"。
- `>`：把执行方向设置为"右"。
- `^`：把执行方向设置为"上"。
- `v`：把执行方向设置为"下"。
- `_`：如果存储器存储的数字是 $0$，就把执行方向设置为"右"，否则设置为"左"。
- `|`：如果存储器存储的数字是 $0$，就把执行方向设置为"下"，否则设置为"上"。
- `?`：把执行方向设置为"上下左右"中的**任意**一个（类似于 dfs 把四个方向全搜一遍）。
- `.`：什么也不做。
- `@`：停止程序。
- `0`-`9`：把存储器设置为这个字符表示的数值。
- `+`：让存储器的数值加 $1$。注意当存储器的数值为 $15$ 时要把它设为 $0$。
- `-`：让存储器的数值减 $1$。注意当存储器的数值为 $0$ 时要把它设为 $15$。

现在，给你一个 Defunge 程序，请判断这个程序是否能停止（即执行到命令`@`）。如果能，输出`YES`，否则输出`NO`。

## 说明/提示

$1\leq R,C\leq 20$，保证程序里只有上文提到的 $21$ 种命令。

# AI分析结果

### 题目翻译
# 停机问题

## 题目描述
Defunge 程序由一个 $R$ 行 $C$ 列的字符数组组成。以下是一个 Defunge 程序的示例：
```plain
6>--v.
.^--_@
```
Defunge 程序从程序的左上角（即第一行第一列）开始执行。**其初始执行方向为“右”**，每次沿执行方向移动一步，**若超出边界，则跳到另一边**。每到达一个格子，就执行该格子上的命令。Defunge 程序还有一个存储器，该存储器只能存储 $[0,15]$ 范围内的一个整数，**存储器初始存储值为** $\bold{0}$。

在 Defunge 程序中，共有且仅有 $11 + 10 = 21$ 种命令，以下是它们各自的含义：
- `<`：将执行方向设置为“左”。
- `>`：将执行方向设置为“右”。
- `^`：将执行方向设置为“上”。
- `v`：将执行方向设置为“下”。
- `_`：若存储器中存储的数字为 $0$，则将执行方向设置为“右”，否则设置为“左”。
- `|`：若存储器中存储的数字为 $0$，则将执行方向设置为“下”，否则设置为“上”。
- `?`：将执行方向设置为“上、下、左、右”中的**任意**一个（类似于深度优先搜索（dfs）将四个方向全部搜索一遍）。
- `.`：不执行任何操作。
- `@`：停止程序。
- `0` - `9`：将存储器的值设置为该字符表示的数值。
- `+`：使存储器的数值加 $1$。注意，当存储器的数值为 $15$ 时，应将其设置为 $0$。
- `-`：使存储器的数值减 $1$。注意，当存储器的数值为 $0$ 时，应将其设置为 $15$。

现在，给定一个 Defunge 程序，请判断该程序是否能够停止（即执行到命令 `@`）。若能停止，输出 `YES`，否则输出 `NO`。

## 说明/提示
$1\leq R,C\leq 20$，确保程序中仅包含上述 $21$ 种命令。

### 综合分析与结论
这些题解的核心思路均为模拟 + 搜索（主要是深度优先搜索 dfs，部分题解给出了广度优先搜索 bfs 的实现）。要点在于根据每个格子的命令更新方向和存储器的值，同时使用四维或五维数组记录状态以避免死循环。难点在于处理越界情况、`?` 命令的多方向搜索以及存储器数值的取模运算。

### 所选题解
- **作者：Fijian_Bus（4星）**
  - 关键亮点：思路清晰，代码注释详细，对取模运算给出了优化建议，即减 1 时先加 15 再模 16。
  - 个人心得：一开始单纯模拟会零分，后来发现要结合搜索，当符号是 `?` 时要向四个方向搜索。
- **作者：Jorisy（4星）**
  - 关键亮点：代码结构清晰，使用 `switch` 语句处理各种命令，对不可结束情况的判断逻辑明确，使用四维 `bool` 数组记录状态。
  - 个人心得：通过观察和计算发现字符方阵像滚动条，要处理好越界情况；对于不可结束的情况，需注意死循环的判断条件。
- **作者：Iron_Heart（4星）**
  - 关键亮点：思路简洁明了，代码实现规范，使用 `isdigit` 函数判断字符是否为数字，提高了代码的可读性。
  - 个人心得：按题意从起始点开始搜索，根据字符变换方向和数值，搜到 `@` 就返回 `true`。

### 重点代码
#### Fijian_Bus 的核心代码
```cpp
bool dfs(int y, int x, int z, int d)
{
	y = (y + n) % n;
	x = (x + m) % m;
	if(vis[y][x][z][d]) return false;
	vis[y][x][z][d] = true;
	if(ch[y][x] == '>') d = 1;
	else if(ch[y][x] == '<') d = 2;
	else if(ch[y][x] == '^') d = 4;
	else if(ch[y][x] == 'v') d = 3;
	else if(ch[y][x] == '_') {
		if(!z) d = 1;
		else d = 2;
	} else if(ch[y][x] == '|') {
		if(!z) d = 3;
		else d = 4;
	} else if(ch[y][x] == '?') {
		for(int i = 1; i < 4; i++) {
			if(dfs(y + dy[i], x + dx[i], z, i)) {
				return true;
			}
		}
	} else if(ch[y][x] == '@') return true; 
	else if(ch[y][x] == '+') {
		z++;
		z %= 16;
	} else if(ch[y][x] == '-') {
		z += 15;
		z %= 16;
	} else {
		z = ch[y][x] - '0';
	}
}
```
核心思想：使用深度优先搜索，根据当前格子的命令更新方向和存储器的值，遇到 `?` 命令时向四个方向搜索，使用四维数组 `vis` 记录状态避免死循环。

#### Jorisy 的核心代码
```cpp
void dfs(int x,int y,int s,int fx)
{
	while(x<1) x+=r;
	while(r<x) x-=r;
	while(y<1) y+=c;
	while(c<y) y-=c;
	if(b[x][y][s][fx]) return;
	if(a[x][y]=='@')
	{
		cout<<"YES"<<endl;
		exit(0);
	}
	b[x][y][s][fx]=true;
	switch(a[x][y])
	{
		case '>':
			dfs(x+X[4],y+Y[4],s,4);
			break;
		case '<':
			dfs(x+X[3],y+Y[3],s,3);
			break;
		case '^':
			dfs(x+X[1],y+Y[1],s,1);
			break;
		case 'v':
			dfs(x+X[2],y+Y[2],s,2);
			break;
		case '_':
			if(s) dfs(x+X[3],y+Y[3],s,3);
			else dfs(x+X[4],y+Y[4],s,4);
			break;
		case '|':
			if(s) dfs(x+X[1],y+Y[1],s,1);
			else dfs(x+X[2],y+Y[2],s,2);
			break;
		case '?':
			for(int i=1;i<=4;i++)
			{
				dfs(x+X[i],y+Y[i],s,i);
			}
			break;
		case '.':
			dfs(x+X[fx],y+Y[fx],s,fx);
			break;
		case '+':
			s++;
			if(s>15) s=0;
			dfs(x+X[fx],y+Y[fx],s,fx);
			break;
		case '-':
			s--;
			if(s<0) s=15;
			dfs(x+X[fx],y+Y[fx],s,fx);
			break;
		default:
			s=a[x][y]-48;
			dfs(x+X[fx],y+Y[fx],s,fx);
	}
}
```
核心思想：同样使用深度优先搜索，利用 `switch` 语句处理各种命令，通过四维数组 `b` 记录状态，遇到 `@` 则输出 `YES` 并退出程序。

#### Iron_Heart 的核心代码
```cpp
bool dfs(int x, int y, int d, int num) {
    x = (x - 1 + n) % n + 1;
    y = (y - 1 + m) % m + 1;
    if (vis[x][y][d][num]) {
        return 0;
    }
    vis[x][y][d][num] = 1;
    if (mp[x][y] == '@') {
        return 1;
    } else if (mp[x][y] == '<') {
        d = 0;
        return dfs(x + dx[d], y + dy[d], d, num);
    } else if (mp[x][y] == '>') {
        d = 3;
        return dfs(x + dx[d], y + dy[d], d, num);
    } else if (mp[x][y] == '^') {
        d = 2;
        return dfs(x + dx[d], y + dy[d], d, num);
    } else if (mp[x][y] == 'v') {
        d = 1;
        return dfs(x + dx[d], y + dy[d], d, num);
    } else if (mp[x][y] == '_') {
        if (!num) {
            d = 3;
        } else {
            d = 0;
        }
        return dfs(x + dx[d], y + dy[d], d, num);
    } else if (mp[x][y] == '|') {
        if (!num) {
            d = 1;
        } else {
            d = 2;
        }
        return dfs(x + dx[d], y + dy[d], d, num);
    } else if (mp[x][y] == '?') {
        for (int i = 0; i < 4; ++i) {
            if (dfs(x + dx[i], y + dy[i], i, num)) {
                return 1;
            }
        }
        return 0;
    } else if (mp[x][y] == '.') {
        return dfs(x + dx[d], y + dy[d], d, num);
    } else if (isdigit(mp[x][y])) {
        return dfs(x + dx[d], y + dy[d], d, mp[x][y] - '0');
    } else if (mp[x][y] == '+') {
        ++num;
        if (num == 16) {
            num = 0;
        }
        return dfs(x + dx[d], y + dy[d], d, num);
    } else {
        --num;
        if (num == -1) {
            num = 15;
        }
        return dfs(x + dx[d], y + dy[d], d, num);
    }
}
```
核心思想：深度优先搜索，使用 `isdigit` 函数判断字符是否为数字，遇到 `@` 则返回 `true`，使用四维数组 `vis` 记录状态。

### 最优关键思路或技巧
- **状态记录**：使用四维或五维数组记录当前位置、方向和存储器的值，避免重复搜索导致的死循环。
- **取模运算优化**：在进行存储器数值减 1 操作时，先加 15 再模 16，避免负数取模的问题。
- **多方向搜索**：遇到 `?` 命令时，向四个方向进行搜索。

### 可拓展之处
同类型题目可能会有更复杂的规则和命令，或者更大的地图规模。类似算法套路可应用于迷宫搜索、游戏模拟等问题，关键在于准确记录状态和处理各种规则。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：考察广度优先搜索，与本题的搜索思想类似。
2. [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)：需要根据规则进行状态转移，与本题的模拟思想相符。
3. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：深度优先搜索的经典题目，可加深对搜索算法的理解。

### 个人心得总结
- 一开始单纯模拟可能会出错，要结合搜索算法。
- 注意越界情况的处理，可将字符方阵看作滚动条。
- 对于不可结束的情况，要关注死循环的判断条件，使用数组记录状态。
- 存储器数值的取模运算要注意，避免负数取模的问题。

---
处理用时：68.05秒
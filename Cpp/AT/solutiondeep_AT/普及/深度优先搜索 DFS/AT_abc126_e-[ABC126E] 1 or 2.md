# 题目信息

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5```

### 输出

```
2```

## 样例 #3

### 输入

```
100000 1

1 100000 100```

### 输出

```
99999```

# AI分析结果

### 题目内容重写

#### [ABC126E] 1 or 2

**题目描述**

有 $N$ 张卡片排成一列，每张卡片上写有一个整数 $1$ 或 $2$。

第 $i$ 张卡片上的整数记为 $A_i$。

你的目标是猜出 $A_1, A_2, \dots, A_N$ 的值。

已知以下信息：

- 对于 $i = 1, 2, \dots, M$，$A_{X_i} + A_{Y_i} + Z_i$ 是偶数。

你可以使用以下魔法：

**魔法**：支付 $1$ 点成本，选择一张卡片，查看其上的整数 $A_i$。

问：最少需要支付多少成本，才能确定所有卡片上的整数 $A_1, A_2, \dots, A_N$。

输入保证没有矛盾。

**说明/提示**

**约束条件**

- 输入均为整数。
- $2 \leq N \leq 10^5$
- $1 \leq M \leq 10^5$
- $1 \leq X_i < Y_i \leq N$
- $1 \leq Z_i \leq 100$
- $(X_i, Y_i)$ 的组合互不相同。
- 输入保证没有矛盾（即存在满足条件的 $A_1, A_2, \dots, A_N$）。

**样例解释 1**

对第 $1$ 张和第 $3$ 张卡片各使用一次魔法，即可确定 $A_1, A_2, A_3$ 的值。

**样例 #1**

**输入**

```
3 1

1 2 1
```

**输出**

```
2
```

**样例 #2**

**输入**

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5
```

**输出**

```
2
```

**样例 #3**

**输入**

```
100000 1

1 100000 100
```

**输出**

```
99999
```

---

### 题解分析与结论

#### 综合分析

本题的核心在于通过给定的关系，利用并查集（Union-Find）数据结构将卡片之间的关系进行合并，最终统计连通块的数量。每个连通块只需要知道其中一个卡片的值，就可以推断出整个连通块中所有卡片的值。因此，最小成本等于连通块的数量。

#### 最优关键思路

1. **并查集的应用**：通过并查集将卡片之间的关系进行合并，形成连通块。
2. **连通块的统计**：最终统计并查集中根节点的数量，即为需要支付的魔法成本。

#### 可拓展之处

- **类似题目**：其他需要处理元素间关系的题目，如判断图的连通性、最小生成树等。
- **思维模式**：通过已知关系推导未知信息，利用并查集进行高效管理。

#### 推荐题目

1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)
3. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)

---

### 高星题解精选

#### 题解1：徐晨轩✅ (5星)

**关键亮点**

- **思路清晰**：明确使用并查集处理卡片之间的关系。
- **代码简洁**：并查集实现简洁，路径压缩优化。

**代码实现**

```cpp
#include <stdio.h>
int n,m,x,y,z,ans,f[100001];
int find(int x)
{
	if(f[x]!=x)f[x]=find(f[x]);
	return f[x];
}
void merge(int x,int y)
{
	int fx=find(x);
	int fy=find(y);
	f[fx]=fy;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		f[i]=i;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		merge(x,y);
	}
	for(int i=1;i<=n;i++)
		if(f[i]==i)
			ans++;
	printf("%d",ans);
	return 0;
}
```

#### 题解2：Take_A_Single_6 (4星)

**关键亮点**

- **思维转换**：通过奇偶性关系推导出并查集的应用。
- **代码实现**：并查集路径压缩，代码可读性高。

**代码实现**

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[100005];
int bcj(int f)
{
    if(q[f]==f)return f;
    return q[f]=bcj(q[f]);
}
int main()
{
    int n,m,x,y,z,ans=0;
    cin>>n>>m;
    for(int i=0;i<n;i++)
        q[i]=i;
    for(int i=0;i<m;i++)
    {
        cin>>x>>y>>z;
        q[bcj(x--)]=bcj(y--);
    }
    for(int i=0;i<n;i++)
        if(q[i]==i)
            ans++;
    cout<<ans<<endl;
    return 0;
}
```

#### 题解3：龙潜月十五 (4星)

**关键亮点**

- **思维深度**：深入分析关系推导过程，明确并查集的应用场景。
- **代码实现**：并查集路径压缩，统计连通块数量。

**代码实现**

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int fa[1000000],ans,maxn,n,m,x,y,z,b[1000000];
int find(int x)
{
	if(x==fa[x])
		return x;
	return fa[x]=find(fa[x]);
}
void con(int x,int y)
{
	x=find(x),y=find(y);
	if(x!=y)
		fa[x]=y;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		con(x,y);
	}
	for(int i=1;i<=n;i++)
		b[find(i)]=1;
	for(int i=1;i<=n;i++)
		if(b[i])
			ans++;
	printf("%d\n",ans);
}
```

---

### 个人心得总结

- **调试经历**：在处理大规模数据时，路径压缩的并查集能显著提高效率。
- **顿悟感想**：通过关系推导未知信息，并查集是处理此类问题的利器。

---
处理用时：60.96秒
# 题目信息

# [ABC351D] Grid and Magnet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_d

$ H $ 行 $ W $ 列のマス目があり、いくつか（$ 0 $ 個のこともある）のマスには磁石が置かれています。  
マス目の状態は $ H $ 個の 長さ $ W $ の文字列 $ S_1,S_2,\ldots,S_H $ で表され、 $ S_i $ の $ j $ 文字目が `#` のとき上から $ i $ 行目かつ左から $ j $ 列目のマスには磁石が置かれていることを、 `.` のとき何も置かれていないことを表しています。

高橋君は鉄の鎧を着ており、あるマスにいるとき次のように移動することができます。

- 現在いるマスの上下左右に隣り合うマスのいずれかに磁石が置かれているとき、どこへも移動することができない。
- そうでないとき、上下左右に隣り合うマスのいずれかを選んでそのマスに移動することができる。  
  ただし、マス目の外に移動することはできない。

磁石が置かれていない各マスについて、そのマスの自由度を、「最初高橋くんがそのマスにいるとき、そこから移動を繰り返して到達できるマスの個数」として定義します。 マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を求めてください。

ただし、自由度の定義において、「移動を繰り返して到達できるマス」とは、最初にいるマスからそのマスまで移動を繰り返して到達する方法（$ 1 $ 回も移動しないものも含む）が $ 1 $ つ以上存在するようなマスのことであり、 最初のマスから始めてすべてのそのようなマスを巡るような移動方法が存在する必要はありません。特に（磁石の置かれていない）各マス自身は、そのマスから「移動を繰り返して到達できるマス」につねに含まれることに注意してください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ H,W $ は整数
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列
- 磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。

### Sample Explanation 1

上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。

### Sample Explanation 2

磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。

## 样例 #1

### 输入

```
3 5
.#...
.....
.#..#```

### 输出

```
9```

## 样例 #2

### 输入

```
3 3
..#
#..
..#```

### 输出

```
1```

# AI分析结果

### 题目内容重写

#### 题目描述

有一个 $H$ 行 $W$ 列的网格图，某些网格上放置了磁铁。网格的状态由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 表示，其中 $S_i$ 的第 $j$ 个字符为 `#` 表示第 $i$ 行第 $j$ 列的网格上有磁铁，为 `.` 表示该网格为空。

高桥君穿着铁甲，当他位于某个网格时，可以按照以下规则移动：

- 如果当前网格的上下左右相邻网格中有磁铁，则他不能移动。
- 否则，他可以选择上下左右相邻的任意一个网格移动，但不能移动到网格外。

对于每个没有磁铁的网格，定义其“自由度”为：高桥君从该网格出发，通过移动可以到达的网格数量。求所有没有磁铁的网格中，自由度的最大值。

#### 说明/提示

- $1 \leq H, W \leq 1000$
- $H, W$ 为整数
- $S_i$ 仅由 `.` 和 `#` 组成，长度为 $W$
- 至少存在一个没有磁铁的网格

### 题解分析与结论

#### 综合分析

本题的核心是通过搜索（BFS或DFS）来计算每个没有磁铁的网格的自由度，并找到最大值。难点在于如何处理与磁铁相邻的网格，这些网格的自由度为1，且不能作为搜索的起点。此外，为了避免重复计算，需要合理标记已访问的网格。

#### 最优思路总结

1. **分类处理网格**：将网格分为三类——有磁铁的网格、与磁铁相邻的网格（自由度为1）、其他网格。对于其他网格，通过BFS或DFS计算其连通块的大小，即为自由度。
2. **优化搜索**：对于与磁铁相邻的网格，直接将其自由度设为1，不进行搜索。对于其他网格，通过搜索计算其连通块的大小，并记录最大值。
3. **避免重复计算**：通过标记已访问的网格，确保每个网格只被计算一次。

#### 推荐题解

1. **作者：2huk (5星)**
   - **关键亮点**：通过分类处理网格，优化了搜索过程，避免了重复计算。代码清晰，逻辑严谨。
   - **核心代码**：
     ```cpp
     int bfs(int x, int y) {
         if (chk(x, y)) return 1;
         if (st[x][y]) return -114514;

         queue<pair<int, int> > q;
         q.emplace(x, y);
         int ans = 0;
         st[x][y] = true;

         map<pair<int, int>, bool> S;

         while (q.size()) {
             int x = q.front().first, y = q.front().second;
             q.pop();
             ++ ans;
             if (!chk(x, y)) {
                 for (int i = 0; i < 4; ++ i ) {
                     int a = x + dx[i], b = y + dy[i];
                     if (a >= 1 && a <= n && b >= 1 && b <= m && g[a][b] == '.') {
                         if (chk(a, b)) {
                             if (!S[{a, b}]) {
                                 q.emplace(a, b);
                                 S[{a, b}] = true;
                             }
                         }
                         else if (!st[a][b]) {
                             q.emplace(a, b);
                             st[a][b] = true;	
                         }
                     }
                 }
             }
         }

         return ans;
     }
     ```

2. **作者：HasNoName (4星)**
   - **关键亮点**：通过广搜计算连通块大小，并处理与磁铁相邻的网格，确保每个网格只被计算一次。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     int ans = 1;
     for (int i = 1; i <= n; i++) {
         for (int j = 1; j <= m; j++) {
             if (!can(i, j) || a[i][j] || vis[i][j]) continue;
             int l = 1, r = 0, c = 1, top = 0;
             q[++r] = {i, j};
             vis[i][j] = 1;
             while (l <= r) {
                 int x = q[l].x, y = q[l].y;
                 l++;
                 if (!can(x, y)) {
                     p[++top] = {x, y};
                     continue;
                 }
                 if (ok(x - 1, y)) to(x - 1, y)
                 if (ok(x + 1, y)) to(x + 1, y)
                 if (ok(x, y - 1)) to(x, y - 1)
                 if (ok(x, y + 1)) to(x, y + 1)
             }
             for (int i = 1; i <= top; i++)
                 vis[p[i].x][p[i].y] = 0;
             ans = max(ans, c);
         }
     }
     ```

3. **作者：ThisIsLu (4星)**
   - **关键亮点**：通过DFS计算连通块大小，并处理与磁铁相邻的网格，确保每个网格只被计算一次。代码简洁，思路清晰。
   - **核心代码**：
     ```cpp
     void dfs(int x, int y) {
         if (vis[x][y]) return;
         vis[x][y] = true;
         res++;
         bool flag = false;
         for (int i = 0; i < 4; i++) {
             int nx = x + dx[i], ny = y + dy[i];
             if (1 <= nx && nx <= n && 1 <= ny && ny <= m) {
                 if (ch[nx][ny] == '#') {
                     flag = true;
                     break;
                 }
             }
         }
         if (!flag) {
             for (int i = 0; i < 4; i++) {
                 int nx = x + dx[i], ny = y + dy[i];
                 if (1 <= nx && nx <= n && 1 <= ny && ny <= m) {
                     dfs(nx, ny);
                 }
             }
         } else {
             cnt++;
             qx[cnt] = x;
             qy[cnt] = y;
         }
     }
     ```

### 推荐题目

1. **P1162 填涂颜色** - 考察连通块的搜索与标记。
2. **P1443 马的遍历** - 考察BFS在网格图中的应用。
3. **P1131 [ZJOI2007] 时态同步** - 考察DFS在树形结构中的应用。

### 个人心得摘录

- **2huk**：通过分类处理网格，避免了重复计算，优化了搜索过程。
- **HasNoName**：通过广搜计算连通块大小，并处理与磁铁相邻的网格，确保每个网格只被计算一次。
- **ThisIsLu**：通过DFS计算连通块大小，并处理与磁铁相邻的网格，确保每个网格只被计算一次。

---
处理用时：62.42秒
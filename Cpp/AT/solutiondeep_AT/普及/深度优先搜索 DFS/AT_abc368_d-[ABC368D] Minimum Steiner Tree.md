# 题目信息

# [ABC368D] Minimum Steiner Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc368/tasks/abc368_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の木が与えられます。$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。

このグラフからいくつかの($ 0 $ 個でもよい)辺と頂点を削除してできる木のうち、指定された $ K $ 個の頂点、頂点 $ V_1,\ldots,V_K $ を全て含むようなものの頂点数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ 1\ \leq\ V_1\ <\ V_2\ <\ \ldots\ <\ V_K\ \leq\ N $
- 与えられるグラフは木である
- 入力は全て整数

### Sample Explanation 1

与えられた木は下図左の通りであり、そこからいくつかの辺と頂点を削除してできる木のうち頂点 $ 1,3,5 $ を全て含むような頂点数最小のものは下図右の通りです。 
![図](https://img.atcoder.jp/abc368/4baf6b0adb0e12dcf8a5c812ada5c17a.png)

## 样例 #1

### 输入

```
7 3
1 2
1 3
2 4
2 5
3 6
3 7
1 3 5```

### 输出

```
4```

## 样例 #2

### 输入

```
4 4
3 1
1 4
2 1
1 2 3 4```

### 输出

```
4```

## 样例 #3

### 输入

```
5 1
1 4
2 3
5 2
1 2
1```

### 输出

```
1```

# AI分析结果

### 题目内容重写
【题目描述】
给定一棵有 $N$ 个顶点的树，顶点编号从 $1$ 到 $N$。第 $i$ 条边连接顶点 $A_i$ 和 $B_i$。从该树中删除一些边和顶点（可能为零），使得剩下的图仍然是一棵树，并且包含所有指定的 $K$ 个顶点 $V_1, V_2, \ldots, V_K$。求满足条件的树的最小顶点数。

【输入格式】
第一行包含两个整数 $N$ 和 $K$，表示树的顶点数和指定的顶点数。
接下来 $N-1$ 行，每行包含两个整数 $A_i$ 和 $B_i$，表示树的一条边。
最后一行包含 $K$ 个整数 $V_1, V_2, \ldots, V_K$，表示指定的顶点。

【输出格式】
输出一个整数，表示满足条件的树的最小顶点数。

【样例输入】
```
7 3
1 2
1 3
2 4
2 5
3 6
3 7
1 3 5
```

【样例输出】
```
4
```

### 题解综合分析与结论
本题的核心问题是在一棵树中找到一个包含所有指定顶点的最小连通子图。由于树的性质，这类问题通常可以通过深度优先搜索（DFS）或广度优先搜索（BFS）来解决。大多数题解采用了DFS的思路，通过标记关键点并递归地判断每个子树是否需要保留，最终统计保留的节点数。

### 所选高星题解

#### 题解1：wo_hen_la (5星)
**关键亮点**：
- 通过两次DFS解决问题，第一次DFS记录每个子树的大小和是否有用，第二次DFS根据子树的有用性进行剪枝。
- 代码简洁，思路清晰，时间复杂度为 $O(N)$。

**核心代码**：
```cpp
void dfs(int u, int fa) {
    if (vis[u]) vv[u] = 1;
    siz[u] = 1;
    for (auto v : e[u]) {
        if (v == fa) continue;
        dfs(v, u);
        siz[u] += siz[v];
        vv[u] |= vv[v]; // 任意儿子有用，父亲就有用
    }
}
void dfs2(int u, int fa) {
    for (auto v : e[u]) {
        if (v == fa) continue;
        if (!vv[v]) { // 没用的不需要往下搜
            ans -= siz[v];
            continue;
        }
        dfs2(v, u);
    }
}
```

#### 题解2：yx666 (4星)
**关键亮点**：
- 采用重链剖分（树链剖分）来找到关键点的最近公共祖先（LCA），然后以LCA为根进行DFS染色，统计答案。
- 虽然重链剖分增加了复杂度，但思路清晰，适合对树链剖分熟悉的读者。

**核心代码**：
```cpp
void dfs3(int x, int fa) {
    if (tar[x]) vis[x] = 1, ++ans;
    for (int i = head[x]; i; i = edge[i].nxt) {
        int to = edge[i].to;
        if (to == fa) continue;
        dfs3(to, x);
        if (vis[to] && !vis[x]) // 注意要判断 x 是否被染色
            vis[x] = 1, ++ans;
    }
}
```

#### 题解3：wuyixiang (4星)
**关键亮点**：
- 通过一次DFS统计每个子树中关键点的数量，若子树中有关键点，则当前节点必须保留。
- 代码简洁，时间复杂度为 $O(N)$，适合初学者理解。

**核心代码**：
```cpp
void dfs(int x, int fa) {
    for (int i = 0; i < ve[x].size(); i++) {
        int to = ve[x][i];
        if (to == fa) continue;
        dfs(to, x);
        sz[x] += sz[to];
    }
    if (sz[x] < k && sz[x]) {
        ans++;
    }
}
```

### 最优关键思路与技巧
1. **DFS剪枝**：通过DFS遍历树，标记关键点，并根据子树的有用性进行剪枝，避免不必要的计算。
2. **树链剖分**：对于需要找到最近公共祖先（LCA）的场景，树链剖分是一种高效的解决方案。
3. **子树统计**：通过统计每个子树中关键点的数量，判断当前节点是否需要保留，简化了问题的复杂度。

### 可拓展之处
1. **类似问题**：可以扩展到图中寻找最小连通子图的问题，通常需要结合DFS或BFS进行求解。
2. **动态规划**：在某些情况下，可以通过树形动态规划（Tree DP）来优化问题的求解。

### 推荐题目
1. [P10723 - 最小生成树](https://www.luogu.com.cn/problem/P10723)
2. [P3384 - 树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3379 - 最近公共祖先](https://www.luogu.com.cn/problem/P3379)

### 个人心得摘录
- **调试经历**：在DFS过程中，需要注意递归的终止条件和剪枝的时机，否则容易导致超时或错误。
- **顿悟感想**：通过标记关键点并递归判断子树的有用性，可以大大简化问题的复杂度，避免不必要的计算。

---
处理用时：50.79秒
# 题目信息

# [ABC374D] Laser Marking

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_d

$ xy $ 平面に対し、レーザを照射しながら線分を印字する印字機があります。

- 印字開始時、レーザ照射位置は座標 $ (0,\ 0) $ にある。
- 線分を印字する際は、以下の流れに従う。
  
  
  - まず、レーザ照射位置を線分の端点のうちどちらか $ 1 $ つに移動させる。
      - どちらの端点から描画を始めてもよい。
  - その後、レーザ照射位置のある端点からもう一方の端点まで、レーザを照射しながらレーザ照射位置を一直線に移動させる。
      - 線分の途中で印字を中止することは許されない。
- レーザを照射していない時、レーザ照射位置は $ 1 $ 秒あたり速度 $ S $ で任意の方向に移動できる。
- レーザを照射している時、レーザ照射位置は $ 1 $ 秒あたり速度 $ T $ で印字中の線分に沿って移動できる。
- レーザ照射位置の移動にかかる時間以外の所要時間は無視できる。

高橋君はこの印字機で $ N $ 本の線分を印字したいです。  
そのうち $ i $ 本目の線分は、座標 $ (A_i,\ B_i) $ と座標 $ (C_i,\ D_i) $ を結びます。  
なお、複数の線分が重なっていることがありますが、全ての線分についてその都度重なっている部分を印字する必要があります。

うまく印字機を操作したとき、全ての線分を印字完了するまでにかかる最小の時間は何秒ですか？

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 6 $
- $ 1\ \le\ T\ \le\ S\ \le\ 1000 $
- $ -1000\ \le\ A_i,B_i,C_i,D_i\ \le\ 1000 $
- $ (A_i,B_i)\ \neq\ (C_i,D_i) $ ( $ 1\ \le\ i\ \le\ N $ )

### Sample Explanation 1

\- レーザを照射しながらレーザ照射位置を $ (0,0) $ から $ (0,2) $ まで移動させ、 $ 2 $ 本目の線分を描画する。 - この描画に要する時間は $ 2 $ 秒である。 - レーザを照射せずレーザ照射位置を $ (0,2) $ から $ (1,3) $ まで移動させる。 - この移動に要する時間は $ \sqrt{2}/2 $ 秒である。 - レーザを照射しながらレーザ照射位置を $ (1,3) $ から $ (2,1) $ まで移動させ、 $ 1 $ 本目の線分を描画する。 - この描画に要する時間は $ \sqrt{5} $ 秒である。 - レーザを照射せずレーザ照射位置を $ (2,1) $ から $ (2,0) $ まで移動させる。 - この移動に要する時間は $ 1/2 $ 秒である。 - レーザを照射しながらレーザ照射位置を $ (2,0) $ から $ (3,0) $ まで移動させ、 $ 3 $ 本目の線分を描画する。 - この描画に要する時間は $ 1 $ 秒である。 - 全体の所要時間は $ 2\ +\ (\sqrt{2}/2)\ +\ \sqrt{5}\ +\ (1/2)\ +\ 1\approx\ 6.443175 $ 秒です。

### Sample Explanation 3

複数の線分が重なっていますが、全ての線分についてその都度重なっている部分を印字する必要があります。

## 样例 #1

### 输入

```
3 2 1
1 3 2 1
0 2 0 0
3 0 2 0```

### 输出

```
6.44317475868633722080```

## 样例 #2

### 输入

```
2 1 1
0 0 10 10
0 2 2 0```

### 输出

```
20.97056274847714058517```

## 样例 #3

### 输入

```
6 3 2
-1000 -1000 1000 1000
1000 -1000 -1000 1000
-1000 -1000 1000 1000
1000 -1000 -1000 1000
1000 1000 -1000 -1000
-1000 1000 1000 -1000```

### 输出

```
9623.35256169626864153344```

## 样例 #4

### 输入

```
6 10 8
1000 1000 -1000 -1000
1000 -1000 -1000 -1000
-1000 1000 1000 1000
-1000 1000 -1000 -1000
1000 1000 1000 -1000
1000 -1000 -1000 1000```

### 输出

```
2048.52813742385702910909```

# AI分析结果

### 题目内容重写

在平面直角坐标系中，有一台激光打印机，通过发射激光在平面上打印线段。打印开始时，激光位置位于坐标 $(0, 0)$。打印线段时，遵循以下步骤：

1. 首先，将激光位置移动到线段的一个端点（可以从任一端点开始绘制）。
2. 然后，在发射激光的同时，将激光位置从当前端点直线移动到另一个端点（不允许在线段中间停止打印）。
3. 不发射激光时，激光位置可以以每秒 $S$ 个单位的速度向任意方向移动。
4. 发射激光时，激光位置可以以每秒 $T$ 个单位的速度沿打印线段移动。
5. 激光位置移动以外的操作所需的时间可以忽略。

高桥君希望用这台打印机打印 $N$ 条线段。第 $i$ 条线段的两个端点坐标分别为 $(A_i, B_i)$ 和 $(C_i, D_i)$。有些线段可能会重叠，在这种情况下，他需要分别打印每个线段的重叠部分。

当他以最佳方式操作打印机时，完成所有线段的打印至少需要多少秒？

### 题解分析与结论

本题的核心是通过枚举所有可能的线段打印顺序和每条线段的打印方向，计算最小时间。由于 $N \leq 6$，数据范围较小，因此可以采用暴力搜索的方法，如深度优先搜索（DFS）或全排列枚举，来找到最优解。

### 所选高星题解

#### 题解1：作者：Zhao_daodao (赞：6)
- **星级**：★★★★★
- **关键亮点**：直接枚举线段的打印顺序和每条线段的打印方向，复杂度为 $O(n! \times 2^n \times n)$，思路清晰，代码简洁。
- **核心代码**：
  ```cpp
  double ans = 0x3f3f3f3f;
  void dfs(int x, int y, int z, double ss) {
      if (z == n) {
          ans = min(ans, ss);
          return;
      }
      for (int i = 1; i <= n; i++) {
          if (!v[i]) {
              v[i] = 1;
              double q1 = sqrt(double(a[i]-x)*double(a[i]-x) + double(b[i]-y)*double(b[i]-y));
              double q2 = sqrt(double(a[i]-c[i])*double(a[i]-c[i]) + double(b[i]-d[i])*double(b[i]-d[i]));
              dfs(c[i], d[i], z + 1, ss + q1 / s + q2 / t);
              q1 = sqrt(double(c[i]-x)*double(c[i]-x) + double(d[i]-y)*double(d[i]-y));
              dfs(a[i], b[i], z + 1, ss + q1 / s + q2 / t);
              v[i] = 0;
          }
      }
  }
  ```
- **核心思想**：通过DFS枚举所有可能的线段打印顺序和方向，计算每种情况的时间，取最小值。

#### 题解2：作者：zeroflows (赞：5)
- **星级**：★★★★
- **关键亮点**：使用DFS进行搜索，记录上一次的坐标，计算移动和打印时间，输出精度较高。
- **核心代码**：
  ```cpp
  double ans = double(LLONG_MAX);
  void dfs(int x, int y, int z, double ss) {
      if (z == n) {
          ans = min(ans, ss);
          return;
      }
      for (int i = 1; i <= n; i++) {
          if (!v[i]) {
              v[i] = 1;
              double q1 = sqrt(double(a[i]-x)*double(a[i]-x) + double(b[i]-y)*double(b[i]-y));
              double q2 = sqrt(double(a[i]-c[i])*double(a[i]-c[i]) + double(b[i]-d[i])*double(b[i]-d[i]));
              dfs(c[i], d[i], z + 1, ss + q1 / s + q2 / t);
              q1 = sqrt(double(c[i]-x)*double(c[i]-x) + double(d[i]-y)*double(d[i]-y));
              dfs(a[i], b[i], z + 1, ss + q1 / s + q2 / t);
              v[i] = 0;
          }
      }
  }
  ```
- **核心思想**：通过DFS枚举所有可能的线段打印顺序和方向，计算每种情况的时间，取最小值。

#### 题解3：作者：fishing_cat (赞：4)
- **星级**：★★★★
- **关键亮点**：暴力枚举每一种画线顺序和起始结点，时间复杂度 $O(n! \times 2^n)$，代码结构清晰。
- **核心代码**：
  ```cpp
  double ans = 1e16;
  void dfs(int now, int len, int x, int y) {
      if (len >= n) {
          ans = min(ans, kl);
          return;
      }
      for (int i = 1; i <= n; i++) {
          if (!vis[i]) {
              vis[i] = 1;
              kl += sqrt(double(abs(x-c[i])*abs(x-c[i]) + abs(y-d[i])*abs(y-d[i]))) / double(s);
              dfs(i, len + 1, a[i], b[i]);
              kl -= sqrt(double(abs(x-c[i])*abs(x-c[i]) + abs(y-d[i])*abs(y-d[i]))) / double(s);
              kl += sqrt(double(abs(x-a[i])*abs(x-a[i]) + abs(y-b[i])*abs(y-b[i]))) / double(s);
              dfs(i, len + 1, c[i], d[i]);
              kl -= sqrt(double(abs(x-a[i])*abs(x-a[i]) + abs(y-b[i])*abs(y-b[i]))) / double(s);
              vis[i] = 0;
          }
      }
  }
  ```
- **核心思想**：通过DFS枚举所有可能的线段打印顺序和方向，计算每种情况的时间，取最小值。

### 最优关键思路与技巧

1. **暴力搜索**：由于 $N \leq 6$，数据范围较小，可以采用暴力搜索的方法，如DFS或全排列枚举，来找到最优解。
2. **距离计算**：使用两点间距离公式 $\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$ 计算移动和打印时间。
3. **回溯法**：在DFS中，使用回溯法枚举所有可能的线段打印顺序和方向，确保不遗漏任何情况。

### 可拓展之处

本题的暴力搜索方法可以推广到类似的路径规划问题，如旅行商问题（TSP）等。对于更大的数据范围，可以考虑使用动态规划或启发式算法进行优化。

### 推荐相似题目

1. [P1171 旅行商问题](https://www.luogu.com.cn/problem/P1171)
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

---
处理用时：68.01秒
# 题目信息

# [ABC382D] Keep Distance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_d

整数 $ N $ と $ M $ が与えられます。

以下の条件をすべて満たす長さ $ N $ の整数列 $ (A_1,\ A_2,\ \ldots,\ A_N) $ を辞書順にすべて出力してください。

- $ 1\ \leq\ A_i $
- $ 2 $ 以上 $ N $ 以下の各整数 $ i $ に対して $ A_{i\ -\ 1}\ +\ 10\ \leq\ A_i $
- $ A_N\ \leq\ M $
 
  数列の辞書順とは長さ $ N $ の数列 $ S\ =\ (S_1,\ S_2,\ \ldots,\ S_N) $ が長さ $ N $ の数列 $ T\ =\ (T_1,\ T_2,\ \ldots,\ T_N) $ より**辞書順で小さい**とは、ある整数 $ 1\ \leq\ i\ \leq\ N $ が存在して下記の $ 2 $ つがともに成り立つことをいいます。

- $ (S_1,\ S_2,\ \ldots,\ S_{i-1})\ =\ (T_1,\ T_2,\ \ldots,\ T_{i-1}) $
- $ S_i $ が $ T_i $ より（数として）小さい。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 12 $
- $ 10N\ -\ 9\ \leq\ M\ \leq\ 10N $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (1,\ 11,\ 21),\ (1,\ 11,\ 22),\ (1,\ 11,\ 23),\ (1,\ 12,\ 22),\ (1,\ 12,\ 23),\ (1,\ 13,\ 23),\ (2,\ 12,\ 22),\ (2,\ 12,\ 23),\ (2,\ 13,\ 23),\ (3,\ 13,\ 23) $ の $ 10 $ 個の数列が条件を満たします。

## 样例 #1

### 输入

```
3 23```

### 输出

```
10

1 11 21

1 11 22

1 11 23

1 12 22

1 12 23

1 13 23

2 12 22

2 12 23

2 13 23

3 13 23```

# AI分析结果

### 题目内容重写

#### 题目描述
给定整数 $N$ 和 $M$，构造所有长度为 $N$ 的整数序列 $ (A_1,\ A_2,\ \ldots,\ A_N) $，并按照字典序输出。这些序列需满足以下条件：
1. $1 \leq A_i$
2. 对于 $2 \leq i \leq N$，有 $A_{i-1} + 10 \leq A_i$
3. $A_N \leq M$

#### 说明/提示
- **约束条件**：
  - $2 \leq N \leq 12$
  - $10N - 9 \leq M \leq 10N$
  - 输入的所有值均为整数

#### 样例解释
对于输入 `3 23`，输出如下：
```
10
1 11 21
1 11 22
1 11 23
1 12 22
1 12 23
1 13 23
2 12 22
2 12 23
2 13 23
3 13 23
```

### 题解分析与结论

#### 综合分析与结论
本题的核心是通过深度优先搜索（DFS）枚举所有可能的序列，并确保序列满足给定的条件。由于 $N$ 的最大值为 12，且 $M$ 的范围较小，DFS 是可行的。为了优化搜索效率，大多数题解都采用了剪枝策略，即在搜索过程中提前排除不符合条件的序列。

#### 最优关键思路与技巧
1. **剪枝优化**：在 DFS 过程中，如果当前序列的某个位置已经无法满足后续条件（如 $A_i + 10 \times (N - i) > M$），则提前回溯，避免无效搜索。
2. **字典序生成**：通过从小到大枚举每个位置的数值，确保生成的序列按字典序排列。
3. **差分序列**：部分题解通过将序列转化为差分序列，简化了搜索过程。

#### 推荐题解
1. **作者：_colin1112_（评分：5星）**
   - **关键亮点**：清晰的剪枝策略，代码简洁且高效。通过确定每个位置的取值范围，减少了不必要的搜索。
   - **代码核心**：
     ```cpp
     void dfs(int pos, vector<ll> &seq) {
         if (pos == n) {
             ans.push_back(seq);
             return;
         }
         ll l = (pos == 0) ? 1 : seq[pos - 1] + 10;
         ll r = m - 10 * (n - pos - 1);
         for (int i = l; i <= r; i++) {
             seq.push_back(i);
             dfs(pos + 1, seq);
             seq.pop_back();
         }
     }
     ```
   - **个人心得**：通过确定每个位置的取值范围，避免了无效搜索，极大提高了效率。

2. **作者：ThomasNO1（评分：4星）**
   - **关键亮点**：剪枝策略简单有效，代码可读性强。通过判断当前序列是否可能满足条件，提前回溯。
   - **代码核心**：
     ```cpp
     void dfs(int pos) {
         if (pos > n) {
             for (int i = 1; i <= n; i++) A.push_back(a[i]);
             ans++;
             A.push_back(-1);
             return;
         }
         if (a[pos - 1] + 10 * (n - pos) > m) return;
         for (int i = a[pos - 1] + 10; i <= m - 10 * (n - pos); i++) {
             a[pos] = i;
             dfs(pos + 1);
         }
     }
     ```
   - **个人心得**：通过剪枝，减少了搜索空间，使得程序能够在合理时间内完成。

3. **作者：Zskioaert1106（评分：4星）**
   - **关键亮点**：通过枚举每一位的可能性，逐步缩小范围，确保生成的序列满足条件。
   - **代码核心**：
     ```cpp
     void dfs(int i, int d) {
         if (i > n) {
             sum++;
             for (int j = 1; j <= n; j++) ans[sum][j] = k[j];
         } else {
             for (int j = d; j + (n - i) * 10 <= m; j++) {
                 k[i] = j;
                 dfs(i + 1, j + 10);
             }
         }
     }
     ```
   - **个人心得**：通过逐步缩小范围，确保生成的序列满足条件，避免了无效搜索。

### 拓展与推荐题目
1. **洛谷 P1010 [NOIP1998 普及组] 幂次方**（考察递归与枚举）
2. **洛谷 P1036 [NOIP2002 普及组] 选数**（考察DFS与剪枝）
3. **洛谷 P1706 全排列问题**（考察DFS与排列生成）

### 个人心得总结
- **调试经历**：部分题解提到在调试过程中，由于剪枝条件设置不当，导致程序无法通过所有测试点。通过调整剪枝条件，最终成功优化了程序。
- **踩坑教训**：在DFS中，如果不进行剪枝，程序可能会因为搜索空间过大而超时。因此，合理设置剪枝条件是关键。
- **顿悟感想**：通过将序列转化为差分序列，可以简化搜索过程，减少计算量。

---
处理用时：50.34秒
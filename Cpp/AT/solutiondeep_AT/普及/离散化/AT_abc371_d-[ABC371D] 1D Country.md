# 题目信息

# [ABC371D] 1D Country

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_d

数直線上に $ N $ 個の村があります。$ i $ 番目の村は座標 $ X_i $ にあり、$ P_i $ 人の村人がいます。

$ Q $ 個のクエリに答えてください。$ i $ 番目のクエリは以下の形式です。

- 整数 $ L_i,R_i $ が与えられる。座標が $ L_i $ 以上 $ R_i $ 以下の村に住んでいる村人の人数の総数を求めよ。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\leq\ 2\times\ 10^5 $
- $ -10^9\leq\ X_1\ <\ X_2\ <\ \ldots\ <\ X_N\ \leq\ 10^9 $
- $ 1\leq\ P_i\leq\ 10^9 $
- $ -10^9\leq\ L_i\ \leq\ R_i\ \leq\ 10^9 $
- 入力される数値は全て整数

### Sample Explanation 1

$ 1 $ 番目のクエリについて考えます。座標が $ 1 $ 以上 $ 1 $ 以下の村は、座標 $ 1 $ にある村で、村人は $ 1 $ 人います。よって答えは $ 1 $ です。 $ 2 $ 番目のクエリについて考えます。座標が $ 2 $ 以上 $ 6 $ 以下の村は、座標 $ 3 $ にある村と座標 $ 5 $ にある村で、村人はそれぞれ $ 2 $ 人と $ 3 $ 人います。よって答えは $ 2+3=5 $ です。

## 样例 #1

### 输入

```
4
1 3 5 7
1 2 3 4
4
1 1
2 6
0 10
2 2```

### 输出

```
1
5
10
0```

## 样例 #2

### 输入

```
7
-10 -5 -3 -1 0 1 4
2 5 6 5 2 1 7
8
-7 7
-1 5
-10 -4
-8 10
-5 0
-10 5
-8 7
-8 -3```

### 输出

```
26
15
7
26
18
28
26
11```

# AI分析结果

### 题目内容重写（中文）

在数直线上有 $N$ 个村庄。第 $i$ 个村庄位于坐标 $X_i$，并且有 $P_i$ 个村民。

你需要回答 $Q$ 个查询。第 $i$ 个查询的形式如下：

- 给定整数 $L_i$ 和 $R_i$，求位于坐标 $L_i$ 到 $R_i$ 之间的村庄中村民的总人数。

### 题解分析与结论

本题的核心在于高效处理区间查询，尤其是当坐标范围非常大时（$-10^9$ 到 $10^9$）。大多数题解都采用了前缀和结合二分查找的思路，少数题解使用了树状数组或离散化处理。以下是各题解的要点总结：

1. **前缀和 + 二分查找**：这是最常见的解法，通过排序村庄坐标并计算前缀和，然后使用二分查找确定查询区间的边界，最后通过前缀和计算区间内的村民总数。时间复杂度为 $O(Q \log N)$，空间复杂度为 $O(N)$。
2. **树状数组**：部分题解使用了树状数组来处理区间查询，但由于坐标范围过大，树状数组的空间复杂度较高，因此需要结合离散化处理。
3. **离散化**：通过将所有坐标和查询边界进行离散化处理，将问题转化为较小的值域，从而可以使用前缀和或其他数据结构高效处理。

### 评分较高的题解

#### 题解1：XXh0919 (4星)
- **关键亮点**：使用前缀和结合二分查找，代码简洁明了，处理了边界情况。
- **核心代码**：
  ```cpp
  l=lower_bound(x+1,x+n+1,l)-x;
  r=upper_bound(x+1,x+n+1,r)-x;
  cout<<sum[r-1]-sum[l-1]<<endl;
  ```
- **个人心得**：作者提到使用 `lower_bound` 和 `upper_bound` 时需要特别注意边界情况，尤其是在查询区间没有覆盖任何村庄时。

#### 题解2：hjyowl (4星)
- **关键亮点**：将村庄坐标和人口数捆绑排序后，使用前缀和和二分查找处理查询，代码结构清晰。
- **核心代码**：
  ```cpp
  long long ll = lower_bound(a + 1,a + 1 + n,l) - a;
  long long rr = upper_bound(a + 1,a + 1 + n,r) - a - 1;
  cout << s[rr] - s[ll - 1] << endl;
  ```
- **个人心得**：作者强调了使用 `64` 位整型的重要性，以避免数据溢出。

#### 题解3：Cosine_Func (4星)
- **关键亮点**：详细解释了二分查找的实现细节，特别是如何处理查询区间不覆盖任何村庄的情况。
- **核心代码**：
  ```cpp
  L=0,R=n-1;
  while(L<R){
      int mid=L+(R-L)/2;
      if(node[mid].x>=l)R=mid;
      else L=mid+1;
  }
  if(node[L].x<l)L++;
  ```
- **个人心得**：作者提到二分查找的写法需要特别注意，尤其是在处理边界情况时。

### 最优关键思路与技巧

1. **前缀和 + 二分查找**：这是本题的最优解法，通过预处理前缀和，结合二分查找快速确定查询区间的边界，时间复杂度为 $O(Q \log N)$，空间复杂度为 $O(N)$。
2. **离散化处理**：当坐标范围过大时，离散化可以将问题转化为较小的值域，从而可以使用前缀和或其他数据结构高效处理。

### 拓展思路

1. **类似题目**：本题可以拓展到其他区间查询问题，如区间最大值、区间最小值等，只需将前缀和的计算方式稍作修改即可。
2. **数据结构优化**：对于更复杂的区间查询问题，可以考虑使用线段树或树状数组，但需要注意空间复杂度的优化。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3384 【模板】线段树 1](https://www.luogu.com.cn/problem/P3384)

### 个人心得总结

- **边界处理**：在处理二分查找时，特别注意查询区间不覆盖任何村庄的情况，避免出现错误结果。
- **数据类型**：使用 `64` 位整型以避免数据溢出，尤其是在处理大范围数据时。
- **代码简洁性**：保持代码简洁明了，便于调试和维护。

---
处理用时：37.67秒
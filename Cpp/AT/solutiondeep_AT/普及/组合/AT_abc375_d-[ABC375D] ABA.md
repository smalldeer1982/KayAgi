# 题目信息

# [ABC375D] ABA

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc375/tasks/abc375_d

英大文字からなる文字列 $ S $ が与えられます。

整数の組 $ (i,\ j,\ k) $ であって、以下の条件をともに満たすものの個数を求めてください。

- $ 1\ \leq\ i\ <\ j\ <\ k\ \leq\ |S| $
- $ S_i $, $ S_j $, $ S_k $ をこの順に結合して得られる長さ $ 3 $ の文字列が回文となる
 
ただし、$ |S| $ は文字列 $ S $ の長さ、$ S_x $ は $ S $ の $ x $ 番目の文字を指します。

## 说明/提示

### 制約

- $ S $ は長さ $ 1 $ 以上 $ 2\ \times\ 10^5 $ 以下の英大文字からなる文字列
 
### Sample Explanation 1

$ (i,\ j,\ k)\ =\ (1,\ 2,\ 4),\ (1,\ 3,\ 4),\ (3,\ 4,\ 5),\ (3,\ 4,\ 6),\ (3,\ 5,\ 6) $ が条件を満たします。

## 样例 #1

### 输入

```
ABCACC```

### 输出

```
5```

## 样例 #2

### 输入

```
OOOOOOOO```

### 输出

```
56```

## 样例 #3

### 输入

```
XYYXYYXYXXX```

### 输出

```
75```

# AI分析结果

### 题目翻译
给定一个由大写英文字母组成的字符串 $S$。

求满足以下两个条件的整数三元组 $(i,j,k)$ 的个数：

1. $1 \leq i < j < k \leq |S|$
2. 由 $S_i$、$S_j$ 和 $S_k$ 按此顺序连接而成的长度为 $3$ 的字符串是一个回文字符串。

### 综合分析与结论
这些题解的核心思路都是围绕找出满足条件的三元组 $(i,j,k)$ 展开，由于长度为 3 的回文串只需首尾字符相同，所以主要的方法是通过不同方式统计首尾相同字符间的中间字符情况。

- **思路对比**：
    - 部分题解是固定中间字符，枚举两边相同的字符，利用前缀和或后缀和统计两边相同字符的数量，再用乘法原理计算贡献，如 Redamancy_Lydic、hjyowl、201012280925LSY 等。
    - 部分题解是讨论每个位置对答案的贡献，通过记录相同字符的出现次数和下标和来计算，如 Anins、small_lemon_qwq 等。
- **算法要点**：
    - 前缀和或后缀和的运用：用于快速统计某个位置之前或之后某个字符的出现次数。
    - 乘法原理：计算以某个字符为中间字符时，两边相同字符能构成的回文串数量。
- **解决难点**：
    - 时间复杂度优化：避免 $O(n^3)$ 的暴力枚举，通过预处理和合理的计算方式将时间复杂度优化到 $O(n)$。
    - 答案范围：由于答案可能超过 int 范围，需要使用 long long 类型。

### 所选题解
- **Anins（5星）**：
    - **关键亮点**：思路清晰，通过讨论每个位置对答案的贡献，利用前缀和维护相同字符的下标和，代码简洁高效，时间复杂度为 $O(|S|)$。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll ans, sum[27], cnt[27];
char c;
int main() {
    for(int i=1;;i++) {
        c=getchar();
        if(c<'A'||c>'Z') break; 
        ll k=c-'A';
        ans+=cnt[k]*(i-1)-sum[k];
        sum[k]+=i;
        cnt[k]++;
    }
    cout << ans;
    return 0;
}
```
- **small_lemon_qwq（4星）**：
    - **关键亮点**：思路简洁明了，与 Anins 思路类似，直接计算每个字符的贡献，代码实现简单易懂。
    - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int cnt[200],mp[200],ans;
signed main(){
    string s;
    cin>>s;
    for(int i=0;i<=s.size()-1;i++){
        ans+=cnt[s[i]]*(i-1)-mp[s[i]];
        mp[s[i]]+=i;
        cnt[s[i]]++;
    }
    cout<<ans;
    return 0;
}
```
- **Redamancy_Lydic（4星）**：
    - **关键亮点**：通过枚举中间字符，利用前缀和和后缀和统计两边相同字符的数量，使用乘法原理计算贡献，思路清晰。
    - **核心代码**：对每个字母分别维护一个从前往后和从后往前的前缀和，分别设为 $sum$ 和 $rsum$。设当前为中间的这一位下标为 $i$，字母 $c$ 对 $i$ 的贡献为 $sum_{c,i - 1} \cdot rsum_{c,i + 1}$。

### 最优关键思路或技巧
- **前缀和或后缀和的运用**：通过预处理前缀和或后缀和，可以在 $O(1)$ 的时间复杂度内统计某个位置之前或之后某个字符的出现次数，从而将整体时间复杂度优化到 $O(n)$。
- **固定中间字符**：固定中间字符，枚举两边相同的字符，利用乘法原理计算贡献，避免了复杂的嵌套枚举。

### 拓展思路
同类型题或类似算法套路：
- 求字符串中满足特定条件的子序列个数，如长度为 4 的回文子序列个数等，可以通过类似的固定中间字符或讨论每个位置贡献的方法解决。
- 统计数组中满足特定条件的三元组个数，如 $a_i + a_j = a_k$ 等，可以通过排序、双指针或哈希表等方法解决。

### 推荐洛谷题目
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：涉及前缀和的运用和动态规划思想。
- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)：可以使用前缀和或动态规划解决。
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：可以使用归并排序或树状数组解决，与统计满足特定条件的元素对个数相关。

### 个人心得
部分题解提到注意答案范围，需要使用 long long 类型，避免答案溢出。在处理类似计数问题时，要注意数据范围对结果的影响。同时，对于复杂的式子，可以在草稿纸上手推，帮助理解和优化算法。

---
处理用时：34.76秒
# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果

### 题目内容重写
【题目描述】
你在散步时突然遇到了一只魔物。幸运的是，你有N把刀，分别是刀1、刀2、…、刀N，并且可以按任意顺序进行以下两种攻击：
- 挥动你手中的一把刀。挥动刀i（1 ≤ i ≤ N）时，魔物会受到a_i点伤害。同一把刀可以多次挥动。
- 投掷你手中的一把刀。投掷刀i（1 ≤ i ≤ N）时，魔物会受到b_i点伤害，并且你将失去这把刀，即以后不能再使用或投掷这把刀。

当魔物受到的总伤害达到或超过H点时，魔物就会消失。请问至少需要多少次攻击才能消灭魔物？

### 题解分析与结论
各题解的核心思路都是贪心算法，通过最大化每次攻击的伤害来减少攻击次数。具体来说，题解们通常将刀的伤害从大到小排序，优先使用投掷伤害高的刀，最后使用挥砍伤害最高的刀进行补刀。难点在于如何处理投掷和挥砍的优先级，以及如何避免重复计算。

### 评分较高的题解
#### 1. 作者：ITZDC9 (5星)
**关键亮点**：
- 详细分析了错误思路，并给出了正确的贪心策略。
- 代码清晰，逻辑严谨，通过结构体存储刀的信息，便于排序和处理。
- 对特殊情况（如投掷伤害与挥砍伤害的关系）进行了详细讨论。

**代码核心**：
```cpp
struct knife {
    int m; // 刀的伤害
    bool t; // 刀的种类（挥砍 0 或投掷 1）
}k[233333];

bool cmp(knife x, knife y) {
    return x.m > y.m; // 按伤害从大到小排序
}

int main() {
    int n, h;
    cin >> n >> h;
    int c = 0;
    for (int i = 1; i <= n; i++) {
        cin >> k[++c].m;
        cin >> k[++c].m;
        k[c].t = 1; // 投掷刀
    }
    sort(k + 1, k + c + 1, cmp);
    int i = 1, ans = 0;
    while (h > 0) {
        if (k[i].t == 1) {
            h -= k[i].m;
            ans++;
        } else {
            ans += (h + k[i].m - 1) / k[i].m;
            h = 0;
        }
        i++;
    }
    cout << ans;
    return 0;
}
```

#### 2. 作者：chengni (4星)
**关键亮点**：
- 简洁明了地实现了贪心策略，代码结构清晰。
- 通过排序和遍历，优先使用投掷伤害高的刀，最后使用挥砍伤害最高的刀。

**代码核心**：
```cpp
struct p {
    int l;
    int r;
}a[1000000];

bool cmp(p xx, p yy) {
    return xx.l > yy.l;
}

int main() {
    int n, h;
    int c = 0;
    scanf("%d%d", &n, &h);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[c++].l);
        a[c].r = 1;
        scanf("%d", &a[c++].l);
    }
    sort(a, a + c, cmp);
    int sum = 0;
    for (int i = 0; i < c; i++) {
        if (a[i].r == 1) {
            sum++;
            h -= a[i].l;
            if (h <= 0) {
                printf("%d", sum);
                return 0;
            }
        } else {
            sum += (h + a[i].l - 1) / a[i].l;
            printf("%d", sum);
            return 0;
        }
    }
}
```

#### 3. 作者：Hilte (4星)
**关键亮点**：
- 通过排序和遍历，优先使用投掷伤害高的刀，最后使用挥砍伤害最高的刀。
- 代码简洁，逻辑清晰，易于理解。

**代码核心**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, h, a[100005], b[100005], ans = 0;
int main() {
    cin >> n >> h;
    for (int i = 1; i <= n; i++)
        cin >> a[i] >> b[i];
    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 1);
    
    for (int i = n; i >= 1 && b[i] > a[n] && h > 0; i--)
        h -= b[i], ans++;
    if (h > 0)
        ans += (h / a[n] + (h % a[n] != 0));
    
    cout << ans << endl;
    return 0;
}
```

### 最优关键思路
1. **贪心策略**：优先使用投掷伤害高的刀，最后使用挥砍伤害最高的刀进行补刀。
2. **排序优化**：将刀的伤害从大到小排序，确保每次攻击都能最大化伤害。
3. **特殊情况处理**：在计算挥砍次数时，注意处理余数，避免少算一次攻击。

### 可拓展之处
- 类似的问题可以扩展到其他资源分配问题，如背包问题、任务调度等。
- 可以进一步优化时间复杂度，考虑更高效的数据结构或算法。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)

---
处理用时：104.62秒
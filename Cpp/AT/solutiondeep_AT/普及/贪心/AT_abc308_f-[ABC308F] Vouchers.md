# 题目信息

# [ABC308F] Vouchers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc308/tasks/abc308_f

あなたは店で $ N $ 個の商品を買おうとしています。 $ i $ 個目の商品の定価は $ P_i $ 円です。

また、あなたは $ M $ 枚のクーポンを持っています。$ i $ 枚目のクーポンを使うと、定価が $ L_i $ 円以上の商品を一つ選び、その商品を定価より $ D_i $ 円低い価格で買うことができます。

ここで、一つのクーポンは一回までしか使えません。また、複数のクーポンを同じ商品に重ねて使うことはできません。

クーポンを使わなかった商品は定価で買うことになります。 $ N $ 個すべての商品を買うのに必要な最小の金額を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N,M\leq\ 2\times\ 10^5 $
- $ 1\leq\ P_i\leq\ 10^9 $
- $ 1\leq\ D_i\ \leq\ L_i\ \leq\ 10^9 $
- 入力される数値は全て整数
 
### Sample Explanation 1

$ 2 $ 枚目のクーポンを $ 1 $ 個目の商品に、 $ 3 $ 枚目のクーポンを $ 2 $ 個目の商品に使うことを考えます。 このとき、$ 1 $ 個目の商品を $ 4-3=1 $ 円、$ 2 $ 個目の商品を $ 3-1=2 $ 円、$ 3 $ 個目の商品を $ 1 $ 円で買うことになるので、 $ 1+2+1=4 $ 円で全ての商品を買うことができます。

## 样例 #1

### 输入

```
3 3

4 3 1

4 4 2

2 3 1```

### 输出

```
4```

## 样例 #2

### 输入

```
10 5

9 7 1 5 2 2 5 5 7 6

7 2 7 8 2

3 2 4 1 2```

### 输出

```
37```

# AI分析结果

### 题目内容重写

[ABC308F] Vouchers

**题目描述**

你正在商店购买 $N$ 个商品。第 $i$ 个商品的原价是 $P_i$ 日元。

你有 $M$ 张优惠券。你可以使用第 $i$ 张优惠券来购买原价至少为 $L_i$ 日元的商品，并享受 $D_i$ 日元的折扣。

每张优惠券只能使用一次，并且不能同时使用多张优惠券购买同一件商品。

如果没有使用优惠券购买商品，则以原价购买。找出购买所有 $N$ 个商品所需的最小金额。

**说明/提示**

**制約**

- $1 \leq N, M \leq 2 \times 10^5$
- $1 \leq P_i \leq 10^9$
- $1 \leq D_i \leq L_i \leq 10^9$
- 输入的所有数值都是整数

**样例解释 1**

考虑使用第 2 张优惠券购买第 1 个商品，第 3 张优惠券购买第 2 个商品。此时，第 1 个商品的价格为 $4 - 3 = 1$ 日元，第 2 个商品的价格为 $3 - 1 = 2$ 日元，第 3 个商品的价格为 $1$ 日元。因此，总共需要 $1 + 2 + 1 = 4$ 日元购买所有商品。

**样例 #1**

**输入**

```
3 3
4 3 1
4 4 2
2 3 1
```

**输出**

```
4
```

**样例 #2**

**输入**

```
10 5
9 7 1 5 2 2 5 5 7 6
7 2 7 8 2
3 2 4 1 2
```

**输出**

```
37
```

### 题解综合分析与结论

本题的核心在于如何最大化利用优惠券，使得总花费最小。多数题解采用了贪心算法，通过排序和优先队列（堆）来优化选择过程。以下是各题解的主要思路和难点对比：

1. **贪心策略**：大多数题解都采用了贪心策略，优先使用折扣最大的优惠券，或者优先为价格较高的商品使用优惠券。
2. **排序与优先队列**：许多题解通过排序商品和优惠券，并使用优先队列来维护当前可用的优惠券，从而快速找到最优的优惠券。
3. **反悔贪心**：部分题解采用了反悔贪心的思路，即当发现当前选择的优惠券不如后续的优惠券时，可以替换之前的优惠券选择。

### 评分较高的题解

#### 题解1：FreedomKing (赞：9)
**星级：★★★★★**
**关键亮点**：
- 使用优先队列维护当前可用的优惠券，确保每次选择折扣最大的优惠券。
- 代码简洁，逻辑清晰，易于理解。
**核心代码**：
```cpp
priority_queue<int> pq;
for(int i=1;i<=n;i++){
    while(t<=m&&f[t].l<=a[i]){
        pq.push(f[t].d);
        t++;
    }
    k+=a[i];
    if(!pq.empty()){
        k-=pq.top();
        pq.pop();
    }
}
```
**实现思想**：将商品和优惠券排序后，遍历商品，将可用的优惠券加入优先队列，每次选择折扣最大的优惠券使用。

#### 题解2：shinzanmono (赞：4)
**星级：★★★★☆**
**关键亮点**：
- 使用 `multiset` 来存储商品价格，方便快速查找和删除。
- 通过 `lower_bound` 快速找到满足条件的商品。
**核心代码**：
```cpp
multiset<ll> p;
for(int i=1;i<=m;i++){
    auto it=p.lower_bound(c[i].l);
    if(it!=p.end()) p.erase(it),tot-=c[i].d;
}
```
**实现思想**：将商品价格存入 `multiset`，遍历优惠券，使用 `lower_bound` 找到满足条件的商品并删除，同时减去折扣。

#### 题解3：cjh20090318 (赞：3)
**星级：★★★★☆**
**关键亮点**：
- 使用优先队列维护已匹配的优惠券，确保不浪费优惠券。
- 通过反悔贪心策略，优化优惠券的选择。
**核心代码**：
```cpp
priority_queue<int, vector<int>, greater<int>> q;
for(int i=1;i<=m;i++){
    while(it<=n&&a[it]>=d[i].l) cnt++, it++;
    if(cnt) cnt--, ans-=d[i].d, q.push(d[i].d);
    else if(!q.empty()&&q.top()<d[i].d)
        ans+=q.top()-d[i].d, q.pop(), q.push(d[i].d);
}
```
**实现思想**：通过优先队列维护已匹配的优惠券，当发现当前优惠券不如后续优惠券时，替换之前的优惠券选择。

### 最优关键思路与技巧

1. **贪心策略**：优先使用折扣最大的优惠券，确保每次选择都能最大化减少总花费。
2. **优先队列**：使用优先队列（堆）来维护当前可用的优惠券，快速找到最优的优惠券。
3. **反悔贪心**：当发现当前选择的优惠券不如后续的优惠券时，可以替换之前的优惠券选择，进一步优化结果。

### 可拓展之处

1. **类似问题**：可以考虑在更复杂的约束条件下（如优惠券有使用时间限制、商品有购买优先级等）如何优化选择。
2. **数据结构**：可以尝试使用其他数据结构（如线段树、平衡树）来优化查找和删除操作。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3378 堆](https://www.luogu.com.cn/problem/P3378)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得总结

- **调试经历**：在实现过程中，优先队列的使用和排序顺序是关键，调试时需确保每次选择的优惠券是最优的。
- **踩坑教训**：未考虑到优惠券和商品的排序顺序，导致部分优惠券无法使用，浪费了折扣机会。
- **顿悟感想**：通过反悔贪心策略，可以进一步优化优惠券的选择，确保总花费最小。

---
处理用时：63.84秒
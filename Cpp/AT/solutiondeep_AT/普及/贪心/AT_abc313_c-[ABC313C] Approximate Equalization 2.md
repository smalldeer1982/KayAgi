# 题目信息

# [ABC313C] Approximate Equalization 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc313/tasks/abc313_c

整数列 $ A=(A_1,A_2,\dots,A_N) $ があります。 あなたは次の操作を好きな回数（$ 0 $ 回でもよい）行うことができます。

- $ 1\leq\ i,j\ \leq\ N $ を満たす整数 $ i,j $ を選ぶ。$ A_i $ を $ 1 $ 減らし、$ A_j $ を $ 1 $ 増やす。
 
$ A $ の最小値と最大値の差を $ 1 $ 以下にするために必要な最小の操作回数を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

以下のように $ 3 $ 回の操作を行うことで、$ A $ の最小値と最大値の差を $ 1 $ 以下にすることができます。 - $ i=2,j=3 $ として操作を行う。$ A=(4,6,4,7) $ になる。 - $ i=4,j=1 $ として操作を行う。$ A=(5,6,4,6) $ になる。 - $ i=4,j=3 $ として操作を行う。$ A=(5,6,5,5) $ になる。 $ 3 $ 回未満の操作で $ A $ の最小値と最大値の差を $ 1 $ 以下にすることはできません。よって答えは $ 3 $ です。

## 样例 #1

### 输入

```
4

4 7 3 7```

### 输出

```
3```

## 样例 #2

### 输入

```
1

313```

### 输出

```
0```

## 样例 #3

### 输入

```
10

999999997 999999999 4 3 2 4 999999990 8 999999991 999999993```

### 输出

```
2499999974```

# AI分析结果

### 题目翻译

有一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$。你可以进行以下操作任意多次（包括零次）：

- 选择满足 $1\leq i,j \leq N$ 的整数 $i,j$，将 $A_i$ 减 $1$，$A_j$ 加 $1$。

你的目标是通过这些操作，使得序列 $A$ 中的最小值与最大值的差不超过 $1$。求达成这一目标所需的最小操作次数。

### 说明/提示

#### 约束条件

- $1\leq N \leq 2\times 10^5$
- $1\leq A_i \leq 10^9$
- 输入均为整数

#### 样例解释

**样例 1**  
输入：
```
4
4 7 3 7
```
输出：
```
3
```
解释：通过 3 次操作，可以将序列变为 $(5,6,5,5)$，此时最小值为 $5$，最大值为 $6$，差为 $1$。

**样例 2**  
输入：
```
1
313
```
输出：
```
0
```
解释：序列只有一个元素，无需操作。

**样例 3**  
输入：
```
10
999999997 999999999 4 3 2 4 999999990 8 999999991 999999993
```
输出：
```
2499999974
```

### 题解分析与结论

#### 综合分析

本题的核心思路是通过操作使得序列中的元素尽可能接近平均值，最终使得最大值与最小值的差不超过 $1$。由于每次操作都是将一个元素减 $1$，另一个元素加 $1$，因此序列的总和不变。我们可以通过计算序列的平均值，然后根据平均值和余数来构造目标序列，最后计算原序列与目标序列的差值总和，除以 $2$ 即为最小操作次数。

#### 最优关键思路

1. **计算平均值**：首先计算序列的总和 $sum$，然后计算平均值 $avg = sum / n$，余数 $mod = sum \% n$。
2. **构造目标序列**：目标序列中，前 $n - mod$ 个元素为 $avg$，后 $mod$ 个元素为 $avg + 1$。
3. **计算差值**：将原序列与目标序列的差值绝对值相加，最后除以 $2$ 即为最小操作次数。

#### 评分较高的题解

1. **Dream_poetry (5星)**  
   - **关键亮点**：思路清晰，代码简洁，直接通过计算平均值和余数构造目标序列，最后计算差值并输出。
   - **代码核心**：
     ```cpp
     for (int i = 0; i < n; i++) b[i] = sum / n;
     for (int i = 0; i < sum % n; i++) b[n - 1 - i]++;
     ll ans = 0;
     for (int i = 0; i < n; i++) ans += abs(a[i] - b[i]);
     cout << ans / 2 << endl;
     ```

2. **_liuyi_ (4星)**  
   - **关键亮点**：通过贪心策略，将小于平均值的元素调整为平均值，大于平均值的元素调整为平均值加 $1$，最后取最大差值。
   - **代码核心**：
     ```cpp
     s1 = sum / n;
     s2 = s1 + 1;
     rep(i, 1, n) {
         if (a[i] < s1) ans1 += abs(a[i] - s1);
         if (a[i] > s2) ans2 += abs(a[i] - s2);
     }
     printf("%lld", max(ans1, ans2));
     ```

3. **梦应归于何处 (4星)**  
   - **关键亮点**：通过排序和构造目标序列，计算差值并输出，思路清晰，代码可读性强。
   - **代码核心**：
     ```cpp
     ll s = tot / n;
     ll t = tot % n;
     for (int i = 1; i <= n; i++) {
         b[i] = s;
         if (i <= t) b[i]++;
     }
     sort(a + 1, a + n + 1);
     sort(b + 1, b + n + 1);
     ll ans = 0;
     for (int i = 1; i <= n; i++) ans += abs(a[i] - b[i]);
     cout << ans / 2;
     ```

### 推荐题目

1. **洛谷 P1106 删数问题**  
   - **题目编号**：P1106  
   - **考察知识点**：贪心算法、字符串处理

2. **洛谷 P1090 合并果子**  
   - **题目编号**：P1090  
   - **考察知识点**：贪心算法、优先队列

3. **洛谷 P1048 采药**  
   - **题目编号**：P1048  
   - **考察知识点**：动态规划、背包问题

---
处理用时：40.93秒
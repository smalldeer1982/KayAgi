# 题目信息

# [ABC323D] Merge Slimes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_d

最初、$ N $ 種類のサイズのスライムがいます。  
具体的には、$ 1\leq\ i\leq\ N $ について、サイズ $ S_i $ のスライムが $ C_i $ 匹います。

高橋君はスライムの合成を好きな順番で好きなだけ($ 0 $ 回でも良い)繰り返すことができます。  
スライムの合成では、次のことを行います。

- **同じ** サイズの $ 2 $ 匹のスライムを選ぶ。選ばれたスライムのサイズが $ X $ であったとき、新しくサイズ $ 2X $ のスライムが出現する。合成後、選ばれた元のスライムは $ 2 $ 匹とも消滅する。

高橋君はスライムの匹数を最小にしたいと考えています。 高橋君がうまく合成を繰り返した時、最小で何匹にすることができるでしょうか?

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 10^5 $
- $ 1\leq\ S_i\leq\ 10^9 $
- $ 1\leq\ C_i\leq\ 10^9 $
- $ S_1,S_2,\ldots,S_N $ はすべて異なる。
- 入力はすべて整数

### Sample Explanation 1

最初、サイズ $ 3 $ のスライムが $ 3 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 1 $ 匹います。 高橋君は次のように合成を $ 2 $ 回行うことができます。 - まず、サイズ $ 3 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 2 $ 匹となります。 - 次に、サイズ $ 6 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 12 $ のスライムが $ 1 $ 匹となります。 高橋君は最初の状態からどのように合成を繰り返してもスライムを $ 2 $ 匹以下にすることはできないため、$ 3 $ を出力します。

### Sample Explanation 2

高橋君は合成を行うことができません。

## 样例 #1

### 输入

```
3
3 3
5 1
6 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3
1 1
2 1
3 1```

### 输出

```
3```

## 样例 #3

### 输入

```
1
1000000000 1000000000```

### 输出

```
13```

# AI分析结果

### 题目内容重写

#### 题目描述

最初，有 $N$ 种不同大小的史莱姆。具体来说，对于 $1\leq\ i\leq\ N$，大小为 $S_i$ 的史莱姆有 $C_i$ 只。

高桥君可以按照任意顺序进行任意次数的史莱姆合成操作（包括不进行任何操作）。合成操作的具体规则如下：

- **相同** 大小的两只史莱姆被选中。如果被选中的史莱姆大小为 $X$，那么会生成一只大小为 $2X$ 的新史莱姆。合成后，被选中的两只史莱姆会消失。

高桥君希望将史莱姆的数量最小化。在高桥君进行最优合成操作后，史莱姆的最小数量是多少？

#### 说明/提示

##### 约束

- $1\leq\ N\leq\ 10^5$
- $1\leq\ S_i\leq\ 10^9$
- $1\leq\ C_i\leq\ 10^9$
- $S_1,S_2,\ldots,S_N$ 互不相同。
- 输入均为整数。

##### 样例解释 1

最初，有大小为 $3$ 的史莱姆 $3$ 只，大小为 $5$ 的史莱姆 $1$ 只，大小为 $6$ 的史莱姆 $1$ 只。高桥君可以进行如下两次合成操作：

1. 首先，选择两只大小为 $3$ 的史莱姆进行合成。合成后，大小为 $3$ 的史莱姆剩下 $1$ 只，大小为 $5$ 的史莱姆 $1$ 只，大小为 $6$ 的史莱姆 $2$ 只。
2. 然后，选择两只大小为 $6$ 的史莱姆进行合成。合成后，大小为 $3$ 的史莱姆 $1$ 只，大小为 $5$ 的史莱姆 $1$ 只，大小为 $12$ 的史莱姆 $1$ 只。

高桥君无法通过任何合成操作将史莱姆的数量减少到 $2$ 只以下，因此输出 $3$。

##### 样例解释 2

高桥君无法进行任何合成操作。

### 题解分析与结论

#### 综合分析

1. **LiJoQiao 的题解**：
   - **思路**：利用 `std::set` 来模拟合成操作，通过不断合成相同大小的史莱姆，直到无法继续合成为止。
   - **优化**：通过观察 $C_i$ 的二进制表示，直接计算出合成后的结果，避免了重复操作。
   - **难点**：如何高效地处理大规模的合成操作，避免超时。
   - **评分**：4星，思路清晰，优化合理，代码实现简洁。

2. **wangchai2009 的题解**：
   - **思路**：使用优先队列（最小堆）来处理合成操作，每次取出最小的史莱姆进行合成。
   - **优化**：通过优先队列确保每次处理最小的史莱姆，避免了不必要的合成操作。
   - **难点**：如何高效地维护优先队列，确保每次操作的正确性。
   - **评分**：4星，思路清晰，代码实现简洁，优化合理。

3. **hellolin 的题解**：
   - **思路**：使用 `std::map` 来存储史莱姆的大小和数量，利用其自动排序的特性进行处理。
   - **优化**：通过遍历 `std::map`，确保每次处理最小的史莱姆，避免了重复操作。
   - **难点**：如何高效地处理大规模的合成操作，避免超时。
   - **评分**：4星，思路清晰，代码实现简洁，优化合理。

#### 最优关键思路

- **二进制优化**：通过观察 $C_i$ 的二进制表示，直接计算出合成后的结果，避免了重复操作。
- **优先队列**：使用优先队列（最小堆）来处理合成操作，确保每次处理最小的史莱姆，避免了不必要的合成操作。
- **自动排序**：利用 `std::map` 的自动排序特性，确保每次处理最小的史莱姆，避免了重复操作。

#### 可拓展之处

- **类似问题**：可以扩展到其他类型的合成问题，如不同大小的物品合成、不同权重的物品合并等。
- **算法套路**：优先队列、二进制优化、自动排序等技巧可以应用于其他需要高效处理大规模数据的场景。

#### 推荐题目

1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1966 [NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1966)

### 所选高星题解

#### LiJoQiao 的题解（4星）

**关键亮点**：
- 利用 `std::set` 模拟合成操作，通过二进制优化直接计算出合成后的结果，避免了重复操作。
- 代码实现简洁，思路清晰。

**核心代码**：
```cpp
std::set<int> slimes;
for (int i = 0; i < N; ++i) {
    int S, C;
    std::cin >> S >> C;
    while (C > 1) {
        if (C % 2 == 1) slimes.insert(S);
        S *= 2;
        C /= 2;
    }
    if (C == 1) slimes.insert(S);
}
std::cout << slimes.size() << std::endl;
```

#### wangchai2009 的题解（4星）

**关键亮点**：
- 使用优先队列（最小堆）来处理合成操作，确保每次处理最小的史莱姆，避免了不必要的合成操作。
- 代码实现简洁，思路清晰。

**核心代码**：
```cpp
std::priority_queue<int, std::vector<int>, std::greater<int>> pq;
std::map<int, int> cnt;
for (int i = 0; i < N; ++i) {
    int S, C;
    std::cin >> S >> C;
    pq.push(S);
    cnt[S] = C;
}
int ans = 0;
while (!pq.empty()) {
    int S = pq.top();
    pq.pop();
    if (cnt[S] == 0) continue;
    if (cnt[S] % 2 == 1) ans++;
    cnt[2 * S] += cnt[S] / 2;
    if (cnt[2 * S] > 0) pq.push(2 * S);
}
std::cout << ans << std::endl;
```

#### hellolin 的题解（4星）

**关键亮点**：
- 使用 `std::map` 来存储史莱姆的大小和数量，利用其自动排序的特性进行处理，确保每次处理最小的史莱姆，避免了重复操作。
- 代码实现简洁，思路清晰。

**核心代码**：
```cpp
std::map<int, int> buc;
for (int i = 0; i < N; ++i) {
    int S, C;
    std::cin >> S >> C;
    buc[S] = C;
}
int ans = 0;
for (auto &[S, C] : buc) {
    if (C >= 2) {
        buc[2 * S] += C / 2;
        ans += C % 2;
    } else {
        ans += C;
    }
}
std::cout << ans << std::endl;
```

---
处理用时：60.85秒
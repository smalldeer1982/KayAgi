# 题目信息

# [ABC325D] Printing Machine

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_d

$ 1 $ から $ N $ までの番号が付けられた $ N $ 個の商品がベルトコンベア上を流れています。 ベルトコンベアには印字機が取り付けられており、商品 $ i $ は今から $ T_i $ \[μs\] 後に印字機の範囲に入り、その $ D_i $ \[μs\] 後に印字機の範囲から出ます。

キーエンスの印字機は、印字機の範囲内にある商品 $ 1 $ つに一瞬で印字することができます（特に、商品が印字機の範囲に入る瞬間や範囲から出る瞬間に印字することも可能です）。 ただし、$ 1 $ 度印字すると、次に印字するまでに $ 1 $ \[μs\] のチャージ時間が必要です。 印字機が印字をする商品とタイミングをうまく選んだとき、最大で何個の商品に印字することができますか？

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ T_i,D_i\ \leq\ 10^{18} $
- 入力は全て整数
 
### Sample Explanation 1

以下、今から $ t $ \\\[μs\\\] 後のことを単に時刻 $ t $ とよびます。 例えば、次のようにして $ 4 $ 個の商品に印字することができます。 - 時刻 $ 1 $ : 商品 $ 1,2,4,5 $ が印字機の範囲に入る。商品 $ 4 $ に印字する。 - 時刻 $ 2 $ : 商品 $ 3 $ が印字機の範囲に入り、商品 $ 1,2 $ が印字機の範囲から出る。商品 $ 1 $ に印字する。 - 時刻 $ 3 $ : 商品 $ 3,4 $ が印字機の範囲から出る。商品 $ 3 $ に印字する。 - 時刻 $ 4.5 $ : 商品 $ 5 $ に印字する。 - 時刻 $ 5 $ : 商品 $ 5 $ が印字機の範囲から出る。 $ 5 $ 個の商品すべてに印字することはできないため、答えは $ 4 $ です。

## 样例 #1

### 输入

```
5

1 1

1 1

2 1

1 2

1 4```

### 输出

```
4```

## 样例 #2

### 输入

```
2

1 1

1000000000000000000 1000000000000000000```

### 输出

```
2```

## 样例 #3

### 输入

```
10

4 1

1 2

1 4

3 2

5 1

5 1

4 1

2 1

4 1

2 4```

### 输出

```
6```

# AI分析结果

### 题目内容重写

**题目描述**

从1到N编号的N个商品在传送带上流动。传送带上安装有印字机，商品i将在T_i [μs]后进入印字机的范围，并在D_i [μs]后离开印字机的范围。

印字机可以在印字机范围内的任意一个商品上瞬间印字（包括商品进入或离开印字机范围的瞬间）。但是，每次印字后，需要1 [μs]的充电时间才能进行下一次印字。问在最优选择印字商品和时机的情况下，最多可以印字多少个商品？

**说明/提示**

**约束条件**

- 1 ≤ N ≤ 2 × 10^5
- 1 ≤ T_i, D_i ≤ 10^18
- 输入均为整数

**样例解释1**

以下，从现在起t [μs]后称为时刻t。例如，可以按照以下方式印字4个商品：
- 时刻1：商品1,2,4,5进入印字机范围。印字商品4。
- 时刻2：商品3进入印字机范围，商品1,2离开印字机范围。印字商品1。
- 时刻3：商品3,4离开印字机范围。印字商品3。
- 时刻4.5：印字商品5。
- 时刻5：商品5离开印字机范围。无法印字所有5个商品，因此答案为4。

**样例输入1**

```
5
1 1
1 1
2 1
1 2
1 4
```

**样例输出1**

```
4
```

**样例输入2**

```
2
1 1
1000000000000000000 1000000000000000000
```

**样例输出2**

```
2
```

**样例输入3**

```
10
4 1
1 2
1 4
3 2
5 1
5 1
4 1
2 1
4 1
2 4
```

**样例输出3**

```
6
```

### 题解分析与结论

**综合分析**

本题的核心问题是如何在时间轴上选择最优的印字时机，以最大化印字商品的数量。由于每次印字后需要1 [μs]的充电时间，因此需要合理安排印字顺序，避免时间冲突。

**题解对比**

1. **FL_sleake的题解**
   - **思路**：使用贪心策略，优先选择最早离开印字机范围的商品进行印字。通过优先队列维护当前可印字的商品，并在时间轴上跳跃以避免无效扫描。
   - **难点**：如何高效地处理时间轴上的跳跃，避免TLE。
   - **优化**：通过排序和优先队列的结合，实现了时间复杂度的优化。
   - **评分**：5星
   - **关键亮点**：使用优先队列动态维护可印字商品，结合时间轴跳跃，高效解决问题。

2. **FireRain的题解**
   - **思路**：同样采用贪心策略，优先选择最早离开印字机范围的商品。通过优先队列和枚举时间点的方式进行处理。
   - **难点**：如何在时间轴上高效枚举并处理印字时机。
   - **优化**：通过优先队列和枚举时间点的结合，实现了较为高效的解决方案。
   - **评分**：4星
   - **关键亮点**：通过优先队列和枚举时间点的结合，实现了较为高效的解决方案。

**最优关键思路**

最优的关键思路是使用贪心策略，优先选择最早离开印字机范围的商品进行印字，并通过优先队列动态维护当前可印字的商品。同时，通过时间轴跳跃避免无效扫描，从而在时间复杂度上实现优化。

**可拓展之处**

类似的问题可以扩展到其他需要在时间轴上选择最优时机的问题，如任务调度、资源分配等。通过贪心策略和优先队列的结合，可以有效解决这类问题。

**推荐题目**

1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 [NOIP2007 提高组] 中位数](https://www.luogu.com.cn/problem/P1168)

**个人心得**

在调试过程中，发现时间轴跳跃的实现是关键，通过合理的时间轴跳跃可以避免无效扫描，提高算法效率。此外，优先队列的使用使得动态维护可印字商品变得简单高效。

### 代码示例

**FL_sleake的代码核心实现**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
vector<pair<int,int> > a;
priority_queue<int,vector<int>,greater<> > q;
signed main(){
	cin>>n;
	a.push_back({-1,0});
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		a.push_back({x,x+y});
	}
	sort(a.begin(),a.end());
	int cnt=0,ans=0;
	for(int T=1;;T++){
		if(q.empty()){
			if(cnt==n) break;
			T=a[++cnt].first;
			q.push(a[cnt].second);
		}
		while(cnt<=n-1&&a[cnt+1].first==T) q.push(a[++cnt].second);
		while(!q.empty()&&q.top()<T) q.pop();
		if(!q.empty()) ans++,q.pop();
	}
	cout<<ans<<endl;
	return 0;
}
```

**FireRain的代码核心实现**

```cpp
#include <bits/stdc++.h>
#define re register
#define int long long

using namespace std;

const int N = 2e5 + 10,inf = (int)(2e18) + 10;
int n,ans;
priority_queue<int,vector<int>,greater<int>> q;

struct point{
	int l;
	int r;
	
	friend bool operator <(const point &a,const point &b){
		return a.l < b.l;
	}
}arr[N];

inline int read(){
	int r = 0,w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9'){
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}

signed main(){
	n = read();
	for (re int i = 1;i <= n;i++){
		int x,l;
		x = read();
		l = read();
		arr[i] = {x,x + l};
	}
	arr[n + 1] = {inf,inf};
	sort(arr + 1,arr + n + 1);
	for (re int i = 1;i <= n;i++){
		int j = i,now = arr[i].l;
		while (j <= n && arr[j].l == now) q.push(arr[j++].r);
		while (!q.empty() && now < arr[j].l){
			int t = q.top();
			q.pop();
			if (t >= now){
				now++;
				ans++;
			}
		}
		i = j - 1;
	}
	printf("%lld",ans);
	return 0;
}
```

---
处理用时：58.68秒
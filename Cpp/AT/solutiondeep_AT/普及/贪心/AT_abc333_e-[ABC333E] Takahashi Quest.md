# 题目信息

# [ABC333E] Takahashi Quest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_e

高橋くんは冒険に出ようとしています。

冒険では、$ N $ 個の出来事が起こります。 $ i $ 番目 $ (1\leq\ i\leq\ N) $ の出来事は整数の組 $ (t\ _\ i,x\ _\ i) $ $ (1\leq\ t\ _\ i\leq\ 2,1\leq\ x\ _\ i\leq\ N) $ で表され、次のような出来事です。

- $ t\ _\ i=1 $ のとき、タイプ $ x\ _\ i $ のポーションを $ 1 $ つ発見する。高橋くんは、発見したポーションを拾うか捨てるかのどちらかを選択する。
- $ t\ _\ i=2 $ のとき、タイプ $ x\ _\ i $ のモンスター $ 1 $ 体と遭遇する。高橋くんがタイプ $ x\ _\ i $ のポーションを持っている場合、それを $ 1 $ つ消費することでモンスターを撃退することができる。モンスターを撃退しなかった場合、高橋くんは敗北する。
 
高橋くんが敗北することなく全てのモンスターを撃退することができるか判定してください。

高橋くんが全てのモンスターを撃退することができない場合、`-1` を出力してください。

高橋くんが全てのモンスターを撃退することができる場合、高橋君が冒険の途中で持っているポーションの個数の最大値を $ K $ とします。 高橋くんが敗北しないような戦略全体にわたる $ K $ の最小値を $ K\ _\ {\min} $ とします。 $ K\ _\ {\min} $ の値と、$ K\ _\ {\min} $ を達成する高橋くんの行動を出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10^5 $
- $ 1\leq\ t\ _\ i\leq2\ (1\leq\ i\leq\ N) $
- $ 1\leq\ x\ _\ i\leq\ N\ (1\leq\ i\leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

出力例は、次のような行動に対応しています。 - タイプ $ 2,3,1 $ のポーションをこの順に発見する。これらのポーションをすべて拾う。 - タイプ $ 3,2 $ のポーションをこの順に発見する。これらのポーションをいずれも拾わない。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾う。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾わない。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾う。 - タイプ $ 2 $ のモンスターと遭遇する。持っているタイプ $ 2 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 1 $ のモンスターと遭遇する。持っているタイプ $ 1 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 この行動では、$ K $ の値は $ 3 $ となります。 $ K\leq\ 2 $ として敗北しない方法はないので、求める $ K\ _\ {\min} $ の値は $ 3 $ です。 $ K=3 $ を満たして高橋くんが敗北しない行動は複数ありますが、どれを出力しても構いません。

### Sample Explanation 2

高橋くんはかならず最初に遭遇するモンスターに敗北してしまいます。

## 样例 #1

### 输入

```
13

1 2

1 3

1 1

1 3

1 2

2 3

1 3

1 3

2 3

1 3

2 2

2 3

2 1```

### 输出

```
3

1 1 1 0 0 1 0 1```

## 样例 #2

### 输入

```
4

2 3

1 4

2 1

1 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
30

1 25

1 2

1 10

1 18

2 18

1 11

2 11

1 21

1 6

2 2

2 10

1 11

1 24

1 11

1 3

1 2

1 18

2 25

1 8

1 10

1 11

2 18

2 10

1 10

2 2

1 24

1 10

2 10

1 25

2 6```

### 输出

```
4

1 1 1 1 1 0 1 0 0 0 0 1 1 0 1 0 1 0 0 0```

# AI分析结果

### 题目内容重写

高桥将开始一次冒险。在冒险过程中，会发生 $N$ 个事件。第 $i$ 个事件 $(1\leq i\leq N)$ 由一对整数 $(t_i,x_i)$ 表示。$(1\leq t_i \leq 2,1\leq x_i\leq N)$ 并如下所示：

- 如果 $t_i=1$，他找到了一个 $x_i$ 类型的药水。他可以选择捡起或丢弃。
- 如果是 $t_i=2$，他将遇到一只 $x_i$ 类型的怪物。如果他有 $x_i$ 类型的药水，他可以使用一种药水击败怪物。如果没有打败它，他就会被打败。

判断他是否可以打败所有怪物而不被打败。如果他不能打败所有的怪物，就打印出来。否则，让 $K$ 成为他在冒险过程中拥有的药水的最大数量。让 $K_{\min}$ 成为 $K$ 在所有策略中不会被打败的最小值。打印 $K_{\min}$ 的值以及高桥实现 $K_{\min}$ 的行动。

### 题解分析与结论

本题的核心在于如何高效地管理药水的拾取和使用，以确保在遇到怪物时能够及时使用相应的药水，同时最小化背包中同时持有的药水数量。大多数题解采用了贪心策略，通过栈或优先队列来管理药水的拾取和使用顺序，确保每次遇到怪物时使用最晚拾取的药水，从而减少药水在背包中的停留时间。

### 所选高分题解

#### 1. 作者：2020luke (5星)
**关键亮点**：
- 使用栈来存储每种药水的出现时间，确保每次遇到怪物时使用最晚拾取的药水。
- 通过标记数组记录药水的使用情况，最终统计背包中药水的最大数量。

**核心代码**：
```cpp
stack<int> st[N];  // stack[i] 代表 i 种类的药水分别出现的时间
int flag[N];       // 标记数组，记录药水的使用情况

for(int i = 1; i <= n; i++) {
    if(t[i] == 1) {
        st[x[i]].push(i);  // 存入每瓶药水出现的时间
    } else if(t[i] == 2) {
        if(st[x[i]].size() <= 0) {  // 药水不够了
            cout << "-1";
            return 0;
        }
        flag[st[x[i]].top()] = 1;  // 打上标记，记为使用该瓶药水
        st[x[i]].pop();  // 药水被用掉了
    }
}
```

#### 2. 作者：STARSczy (4星)
**关键亮点**：
- 使用优先队列来管理药水的拾取顺序，确保每次遇到怪物时使用最晚拾取的药水。
- 通过差分数组记录药水的使用情况，最终统计背包中药水的最大数量。

**核心代码**：
```cpp
priority_queue<int> q[N];  // 优先队列，存储每种药水出现的位置

for(int i = 1; i <= n; i++) {
    if(op[i] == 1) q[x[i]].push(i);  // 见到药水就将它入栈
    else {
        if(q[x[i]].empty()) {  // 没有药水
            cout << "-1";
            return 0;
        }
        ans[q[x[i]].top()] = 1;  // 标记使用的药水
        q[x[i]].pop();
    }
}
```

#### 3. 作者：Double_Light (4星)
**关键亮点**：
- 使用栈来管理药水的拾取顺序，确保每次遇到怪物时使用最晚拾取的药水。
- 通过标记数组记录药水的使用情况，最终统计背包中药水的最大数量。

**核心代码**：
```cpp
stack<int> st[N];  // stack[i] 代表 i 种类的药水分别出现的时间
bool f[N];         // 标记数组，记录药水的使用情况

for(int i = 1; i <= n; i++) {
    if(t[i] == 1) st[x[i]].push(i);  // 存入每瓶药水出现的时间
    else if(t[i] == 2) {
        if(st[x[i]].empty()) {  // 药水不够了
            cout << "-1";
            return 0;
        }
        f[st[x[i]].top()] = true;  // 打上标记，记为使用该瓶药水
        st[x[i]].pop();  // 药水被用掉了
    }
}
```

### 最优关键思路或技巧
- **贪心策略**：每次遇到怪物时使用最晚拾取的药水，确保药水在背包中的停留时间最短。
- **栈或优先队列**：用于管理药水的拾取顺序，确保每次遇到怪物时能够及时使用相应的药水。

### 可拓展之处
- **类似问题**：在需要管理资源使用顺序的问题中，贪心策略和栈/优先队列的结合是一种常见的解决方案。
- **其他应用**：例如在任务调度、资源分配等问题中，类似的管理策略也可以有效优化资源的使用效率。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3378 堆](https://www.luogu.com.cn/problem/P3378)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：48.99秒
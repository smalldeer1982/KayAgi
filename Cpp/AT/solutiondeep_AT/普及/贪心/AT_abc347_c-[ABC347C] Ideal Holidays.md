# 题目信息

# [ABC347C] Ideal Holidays

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc347/tasks/abc347_c

AtCoder 王国の $ 1 $ 週間は $ A+B $ 日からなり、$ 1 $ 日目から $ A $ 日目が休日で、$ A+1 $ 日目から $ A+B $ 日目が平日です。

高橋くんは $ N $ 個の予定があり、$ i $ 番目の予定は今日から $ D_i $ 日後です。

高橋くんは今日が $ 1 $ 週間の何日目かを忘れてしまいました。高橋くんの $ N $ 個の予定が全て休日である可能性があるかを判定してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ A,B\leq\ 10^9 $
- $ 1\leq\ D_1\ <\ D_2\ <\ \ldots\ <\ D_N\leq\ 10^9 $
 
### Sample Explanation 1

入力では $ 1 $ 週間は $ 7 $ 日からなり、$ 1 $ 日目から $ 2 $ 日目が休日、$ 3 $ 日目から $ 7 $ 日目が平日です。 今日が $ 1 $ 週間の $ 7 $ 日目だとします。このとき、$ 1 $ 日後は $ 1 $ 週間の $ 1 $ 日目、$ 2 $ 日後は $ 1 $ 週間の $ 2 $ 日目、$ 9 $ 日後は $ 1 $ 週間の $ 2 $ 日目となり、全ての予定が休日となります。そのため、高橋くんの $ N $ 個の予定が全て休日である可能性があります。

## 样例 #1

### 输入

```
3 2 5

1 2 9```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 5 10

10 15```

### 输出

```
No```

## 样例 #3

### 输入

```
4 347 347

347 700 705 710```

### 输出

```
Yes```

# AI分析结果

### 题目内容重写（中文）

AtCoder 王国的 $1$ 周由 $A+B$ 天组成，第 $1$ 天到第 $A$ 天是假日，第 $A+1$ 天到第 $A+B$ 天是工作日。

高桥君有 $N$ 个计划，第 $i$ 个计划是今天之后的第 $D_i$ 天。

高桥君忘记了今天是这周的哪一天。请判断高桥君的 $N$ 个计划是否有可能都在假日。

### 说明/提示

#### 约束

- $1\leq\ N\leq\ 2\times\ 10^5$
- $1\leq\ A,B\leq\ 10^9$
- $1\leq\ D_1\ <\ D_2\ <\ \ldots\ <\ D_N\leq\ 10^9$

#### 样例解释 1

输入中 $1$ 周由 $7$ 天组成，第 $1$ 天到第 $2$ 天是假日，第 $3$ 天到第 $7$ 天是工作日。假设今天是这周的第 $7$ 天。那么，$1$ 天后是这周的第 $1$ 天，$2$ 天后是这周的第 $2$ 天，$9$ 天后是这周的第 $2$ 天，所有计划都在假日。因此，高桥君的 $N$ 个计划有可能都在假日。

### 样例 #1

#### 输入

```
3 2 5

1 2 9
```

#### 输出

```
Yes
```

### 样例 #2

#### 输入

```
2 5 10

10 15
```

#### 输出

```
No
```

### 样例 #3

#### 输入

```
4 347 347

347 700 705 710
```

#### 输出

```
Yes
```

---

### 题解分析与结论

#### 综合分析

该题的核心在于判断所有计划是否可以被安排在一个连续的假日区间内。由于今天是这周的哪一天未知，因此需要将所有计划对一周的天数 $A+B$ 取模，并判断这些模数是否可以被安排在一个连续的假日区间内。

大多数题解都采用了以下思路：
1. 将所有计划对 $A+B$ 取模，将问题转化为一周内的日期安排。
2. 对取模后的日期进行排序。
3. 判断这些日期是否可以被安排在一个连续的假日区间内，或者通过判断相邻日期的间隔是否大于工作日天数 $B$ 来确定是否可以跳过工作日。

#### 最优关键思路

1. **取模与排序**：将所有计划对 $A+B$ 取模，将问题转化为一周内的日期安排，然后排序。
2. **区间判断**：判断排序后的日期是否可以被安排在一个连续的假日区间内，或者通过判断相邻日期的间隔是否大于 $B$ 来确定是否可以跳过工作日。

#### 推荐题解

1. **作者：MinimumSpanningTree (赞：15)**  
   **星级：4.5**  
   **关键亮点**：通过将计划对 $A+B$ 取模并排序，判断最大和最小日期的差是否小于 $A$，或者相邻日期的间隔是否大于 $B$，简洁高效。  
   **核心代码**：
   ```cpp
   sort(d+1,d+n+1);
   if(d[n]-d[1]+1<=a) flag=true;
   for(int i=2;i<=n;i++) {
       if(d[i]-d[i-1]>b&&d[i-1]<=a) flag=true;
   }
   ```

2. **作者：XXh0919 (赞：10)**  
   **星级：4**  
   **关键亮点**：通过将计划对 $A+B$ 取模并排序，判断最大和最小日期的差是否小于 $A$，或者通过遍历数组判断相邻日期的间隔是否大于 $B$，思路清晰。  
   **核心代码**：
   ```cpp
   sort(d+1,d+n+1);
   if(d[n]-d[1]<a) cout<<"Yes";
   else {
       rep(i,1,n) {
           if(d[i]-d[i-1]>b) cout<<"Yes";
       }
   }
   ```

3. **作者：joe_zxq (赞：7)**  
   **星级：4**  
   **关键亮点**：通过将计划对 $A+B$ 取模并排序，判断相邻日期的间隔是否大于 $B$，简洁明了。  
   **核心代码**：
   ```cpp
   sort(a + 1, a + n + 1);
   a[n + 1] = a[1] + m + k;
   for (int i = 1; i <= n; i++)
       if (a[i + 1] - a[i] > k)
           cout << "Yes", exit(0);
   ```

#### 扩展思路

该题的思路可以扩展到其他类似的区间判断问题，例如判断多个事件是否可以被安排在一个特定的时间区间内，或者判断多个任务是否可以被安排在一个特定的资源区间内。

#### 推荐题目

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

#### 个人心得摘录

- **MinimumSpanningTree**：通过将计划对 $A+B$ 取模并排序，判断最大和最小日期的差是否小于 $A$，或者相邻日期的间隔是否大于 $B$，简洁高效。
- **XXh0919**：通过将计划对 $A+B$ 取模并排序，判断最大和最小日期的差是否小于 $A$，或者通过遍历数组判断相邻日期的间隔是否大于 $B$，思路清晰。
- **joe_zxq**：通过将计划对 $A+B$ 取模并排序，判断相邻日期的间隔是否大于 $B$，简洁明了。

---
处理用时：51.32秒
# 题目信息

# [ABC347D] Popcount and XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc347/tasks/abc347_d

非負整数 $ a,b,C $ が与えられます。 次の $ 5 $ つの条件をすべて満たす非負整数の組 $ (X,Y) $ が存在するか判定し、存在するならひとつ出力してください。

- $ 0\leq\ X\lt2\ ^\ {60} $
- $ 0\leq\ Y\lt2\ ^\ {60} $
- $ \operatorname{popcount}(X)=a $
- $ \operatorname{popcount}(Y)=b $
- $ X\oplus\ Y=C $

ただし、$ \oplus $ はビットごとの排他的論理和を表します。

条件を満たす $ (X,Y) $ が複数存在する場合、どれを出力しても構いません。

popcount とは？非負整数 $ x $ について $ x $ の popcount とは、$ x $ を $ 2 $ 進法で表記したときの $ 1 $ の個数です。 より厳密には、非負整数 $ x $ について $ \displaystyle\ x=\sum\ _\ {i=0}\ ^\ \infty\ b\ _\ i2\ ^\ i\ (b\ _\ i\in\lbrace0,1\rbrace) $ が成り立っているとき $ \displaystyle\operatorname{popcount}(x)=\sum\ _\ {i=0}\ ^\ \infty\ b\ _\ i $ です。

例えば、$ 13 $ を $ 2 $ 進法で表記すると `1101` なので、 $ \operatorname{popcount}(13)=3 $ となります。 ビットごとの排他的論理和とは？非負整数 $ x,y $ について $ x,y $ のビットごとの排他的論理和 $ x\oplus\ y $ は以下のように定義されます。

- $ x\oplus\ y $ を $ 2 $ 進法で表記したときの $ 2\ ^\ k\ (k\geq0) $ の位は、$ x,y $ を $ 2 $ 進法で表記したときの $ 2\ ^\ k\ (k\geq0) $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $ 、そうでなければ $ 0 $ となる。

例えば、$ 9,3 $ を $ 2 $ 進法で表記するとそれぞれ `1001`, `0011` なので、$ 9\oplus3=10 $ となります（$ 10 $ を $ 2 $ 進法で表記すると `1010` です）。

## 说明/提示

### 制約

- $ 0\leq\ a\leq60 $
- $ 0\leq\ b\leq60 $
- $ 0\leq\ C\lt2\ ^\ {60} $
- 入力はすべて整数

### Sample Explanation 1

$ (X,Y)=(28,27) $ は条件を満たします。 $ X,Y $ を $ 2 $ 進法で表記するとそれぞれ `11100` と `11011` になります。 - $ X $ を $ 2 $ 進法で表記すると `11100` になるので、$ \operatorname{popcount}(X)=3 $ です。 - $ Y $ を $ 2 $ 進法で表記すると `11011` になるので、$ \operatorname{popcount}(Y)=4 $ です。 - $ X\oplus\ Y $ を $ 2 $ 進法で表記すると `00111` となり、$ X\oplus\ Y=7 $ です。 条件を満たす非負整数の組が複数存在する場合どれを出力しても構わないため、例えば `42 45` と出力しても正解になります。

### Sample Explanation 2

条件を満たす非負整数の組は存在しません。

### Sample Explanation 3

出力すべき値が $ 32\operatorname{bit} $ 整数に収まらない場合があります。

## 样例 #1

### 输入

```
3 4 7```

### 输出

```
28 27```

## 样例 #2

### 输入

```
34 56 998244353```

### 输出

```
-1```

## 样例 #3

### 输入

```
39 47 530423800524412070```

### 输出

```
540431255696862041 10008854347644927```

# AI分析结果

### 题目内容重写

给定非负整数 \(a, b, C\)，判断是否存在一对非负整数 \((X, Y)\) 满足以下五个条件，并输出一组满足条件的 \((X, Y)\)：

- \(0 \leq X < 2^{60}\)
- \(0 \leq Y < 2^{60}\)
- \(\operatorname{popcount}(X) = a\)
- \(\operatorname{popcount}(Y) = b\)
- \(X \oplus Y = C\)

其中，\(\operatorname{popcount}(x)\) 表示 \(x\) 在二进制下 \(1\) 的个数，\(\oplus\) 表示按位异或运算。

### 题解综合分析

本题的核心在于如何构造满足条件的 \(X\) 和 \(Y\)，使得它们的二进制表示中 \(1\) 的个数分别为 \(a\) 和 \(b\)，并且它们的异或结果为 \(C\)。题解中主要涉及以下几个关键点：

1. **无解条件**：通过分析 \(a, b, C\) 之间的关系，判断是否存在解。常见的无解条件包括 \(a + b < \operatorname{popcount}(C)\)、\(a + b - \operatorname{popcount}(C)\) 为奇数等。
2. **贪心策略**：在构造 \(X\) 和 \(Y\) 时，优先处理 \(C\) 中为 \(1\) 的位，根据 \(a\) 和 \(b\) 的大小关系决定将 \(1\) 分配给 \(X\) 还是 \(Y\)。
3. **二进制处理**：通过位运算和二进制分解，逐步构造 \(X\) 和 \(Y\) 的二进制表示，确保满足条件。

### 评分较高的题解

#### 题解1：作者：wangbinfeng (★★★★☆)

**关键亮点**：
- 详细分析了无解条件，包括 \(a + b < \operatorname{popcount}(C)\)、\(a + b - \operatorname{popcount}(C)\) 为奇数等。
- 使用 `bitset` 进行二进制处理，代码简洁且高效。
- 通过贪心策略，优先处理 \(C\) 中为 \(1\) 的位，确保 \(X\) 和 \(Y\) 的 \(1\) 的个数满足要求。

**核心代码**：
```cpp
bitset<60> d(c); // 转成二进制
bitset<60> e, f;
e.reset(), f.reset();
for(int i=0;i<60;i++){ // 抵消掉多余的 1
    if(a+b==popcnt(c)) break;
    if(d[i]==false) e[i]=f[i]=true, a--, b--;
}
for(int i=0;i<60;i++){ // 将剩下的 1 分摊给 X,Y
    if(d[i]&&a-->0) e[i]=true;
    else if(d[i]&&b-->0) f[i]=true;
}
cout << e.to_ullong() << ' ' << f.to_ullong();
```

#### 题解2：作者：zengziqvan (★★★★☆)

**关键亮点**：
- 通过贪心策略，优先处理 \(C\) 中为 \(1\) 的位，根据 \(a\) 和 \(b\) 的大小关系决定将 \(1\) 分配给 \(X\) 还是 \(Y\)。
- 使用位运算和二进制分解，逐步构造 \(X\) 和 \(Y\) 的二进制表示，确保满足条件。

**核心代码**：
```cpp
for(int i=0;i<60;i++){
    if(c>>i&1){
        if(a<=b) b--, res2+=(1LL<<i);
        else a--, res1+=(1LL<<i);
    }
}
for(int i=0;i<60;i++){
    if(a<=0||b<=0) break;
    if(!(c>>i&1)) a--, b--, res1+=(1LL<<i), res2+=(1LL<<i);
}
```

#### 题解3：作者：haokee (★★★★☆)

**关键亮点**：
- 通过贪心策略，优先处理 \(C\) 中为 \(1\) 的位，确保 \(X\) 和 \(Y\) 的 \(1\) 的个数满足要求。
- 使用位运算和二进制分解，逐步构造 \(X\) 和 \(Y\) 的二进制表示，确保满足条件。

**核心代码**：
```cpp
for(int i=0;i<60;i++){
    if(c>>i&1){
        if(a>=b) a--, x|=(1ll<<i);
        else b--, y|=(1ll<<i);
    }
}
for(int i=0;i<60;i++){
    if(!(c>>i&1)){
        if(a>0&&b>0) x|=(1ll<<i), y|=(1ll<<i), a--, b--;
    }
}
```

### 最优关键思路与技巧

1. **无解条件判断**：在构造 \(X\) 和 \(Y\) 之前，先判断是否存在解，避免无效计算。
2. **贪心策略**：优先处理 \(C\) 中为 \(1\) 的位，根据 \(a\) 和 \(b\) 的大小关系决定将 \(1\) 分配给 \(X\) 还是 \(Y\)。
3. **二进制处理**：通过位运算和二进制分解，逐步构造 \(X\) 和 \(Y\) 的二进制表示，确保满足条件。

### 可拓展之处

本题的解法可以推广到其他涉及二进制构造和位运算的题目中，例如：

1. **构造满足特定条件的二进制数**：通过贪心策略和位运算，构造满足特定条件的二进制数。
2. **异或运算的应用**：通过异或运算的性质，解决涉及二进制位运算的问题。

### 推荐题目

1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)：考察二进制构造和位运算的应用。
2. [P1045 快速幂](https://www.luogu.com.cn/problem/P1045)：涉及二进制分解和位运算的优化。
3. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)：通过二进制构造和贪心策略解决问题。

### 个人心得总结

在解决本题时，关键在于如何通过贪心策略和位运算，逐步构造满足条件的 \(X\) 和 \(Y\)。通过分析无解条件，可以避免无效计算，提高解题效率。此外，使用 `bitset` 进行二进制处理，可以使代码更加简洁高效。

---
处理用时：54.50秒
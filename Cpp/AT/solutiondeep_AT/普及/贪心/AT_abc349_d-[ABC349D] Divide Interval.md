# 题目信息

# [ABC349D] Divide Interval

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc349/tasks/abc349_d

非負整数 $ l,r\ (l\ <\ r) $ に対して、$ l $ 以上 $ r $ 未満の整数を順に並べた数列 $ (l,l+1,\ldots,r-2,r-1) $ を $ S(l,r) $ で表します。また、非負整数 $ i,j $ を用いて $ S(2^{i}j,2^{i}(j+1)) $ と表される数列を良い数列と呼ぶことにします。

非負整数 $ L,R\ (L\lt\ R) $ が与えられます。数列 $ S(L,R) $ をできるだけ少ない個数の良い数列に分割するとき、その個数と分割の方法を出力してください。より厳密には、以下を満たす非負整数の組の列 $ (l_1,r_1),(l_2,r_2),\ldots,(l_M,r_M) $ が存在するような正整数 $ M $ の最小値を求め、そのときの $ (l_1,r_1),(l_2,r_2),\ldots,(l_M,r_M) $ を出力してください。

- $ L=l_1\ <\ r_1=l_2\ <\ r_2=\cdots=l_M\ <\ r_M=R $
- $ S(l_1,r_1),S(l_2,r_2),\ldots,S(l_M,r_M) $ は良い数列

なお、$ M $ が最小となるような分割方法は一通りのみ存在することが示せます。

## 说明/提示

### 制約

- $ 0\leq\ L\lt\ R\leq\ 2^{60} $
- 入力は全て整数

### Sample Explanation 1

$ S(3,19)=(3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18) $ です。これは以下の $ 5 $ つの良い数列に分割でき、これが個数が最小となるような分割方法です。 - $ S(3,4)=S(2^0\cdot\ 3,2^0\cdot4)=(3) $ - $ S(4,8)=S(2^2\cdot\ 1,2^2\cdot\ 2)=(4,5,6,7) $ - $ S(8,16)=S(2^3\cdot\ 1,2^3\cdot\ 2)=(8,9,10,11,12,13,14,15) $ - $ S(16,18)=S(2^1\cdot\ 8,2^1\cdot\ 9)=(16,17) $ - $ S(18,19)=S(2^0\cdot\ 18,2^0\cdot\ 19)=(18) $

## 样例 #1

### 输入

```
3 19```

### 输出

```
5
3 4
4 8
8 16
16 18
18 19```

## 样例 #2

### 输入

```
0 1024```

### 输出

```
1
0 1024```

## 样例 #3

### 输入

```
3940649673945088 11549545024454656```

### 输出

```
8
3940649673945088 3940649673949184
3940649673949184 4503599627370496
4503599627370496 9007199254740992
9007199254740992 11258999068426240
11258999068426240 11540474045136896
11540474045136896 11549270138159104
11549270138159104 11549545016066048
11549545016066048 11549545024454656```

# AI分析结果

### 题目内容重写

【题目描述】
给定两个非负整数 \( l, r \)（\( l < r \)），定义 \( S(l, r) \) 为从 \( l \) 到 \( r-1 \) 的整数序列。若一个序列可以表示为 \( S(2^i j, 2^i (j+1)) \)，其中 \( i, j \) 为非负整数，则称其为“好序列”。给定 \( L, R \)（\( L < R \)），要求将 \( S(L, R) \) 分割成尽可能少的好序列，并输出分割的个数及每个好序列的区间。

【输入格式】
输入两个整数 \( L, R \)。

【输出格式】
第一行输出分割的好序列的个数 \( M \)，接下来 \( M \) 行每行输出一个好序列的区间 \( l_i, r_i \)。

【样例输入】
```
3 19
```

【样例输出】
```
5
3 4
4 8
8 16
16 18
18 19
```

### 题解综合分析与结论

该题的核心思路是贪心算法，通过每次选择最大的 \( 2^i \) 步长来分割区间，使得分割的区间尽可能长，从而减少分割的次数。大多数题解都采用了这一思路，但在具体实现上有所不同。部分题解通过预处理 \( 2^i \) 的幂次来优化计算，而另一些题解则通过位运算来快速找到最大的 \( 2^i \) 步长。

### 所选高分题解

#### 题解1：作者：lutaoquan2012 (★★★★★)
**关键亮点**：
- 通过预处理 \( 2^i \) 的幂次，避免了重复计算。
- 使用贪心策略，每次选择最大的 \( 2^i \) 步长来分割区间。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
while(l != r){
    for(int i = 60; i >= 0; i--){
        if(l + a[i] <= r && l % a[i] == 0){
            h1[++ans] = l;
            h2[ans] = l + a[i];
            l += a[i];
            break;
        }
    }
}
```

#### 题解2：作者：Redamancy_Lydic (★★★★☆)
**关键亮点**：
- 通过位运算快速找到最大的 \( 2^i \) 步长，优化了计算效率。
- 代码中加入了特判处理 \( l = 0 \) 的情况，增强了鲁棒性。

**核心代码**：
```cpp
int p(int x){
    int ans = 1;
    while(x % ans == 0){
        ans = ans << 1;
    }
    if(x % ans) ans /= 2;
    return ans;
}
```

#### 题解3：作者：wflhx2011 (★★★★☆)
**关键亮点**：
- 模仿线段树的递归思路，将区间分割问题转化为递归问题。
- 通过递归函数 \( f(l, r, L, R) \) 来找到最优分割区间。

**核心代码**：
```cpp
void f(long long a, long long b, long long x, long long y) {
    if(x <= a && b <= y) {
        c[++cnt] = a;
        d[cnt] = b;
        return ;
    }
    long long m = (a + b) / 2;
    if(y <= m) {
        f(a, m, x, y);
        return;
    }
    if(m <= x) {
        f(m, b, x, y);
        return;
    }
    f(a, m, x, y);
    f(m, b, x, y);
    return ;
}
```

### 最优关键思路与技巧
1. **贪心策略**：每次选择最大的 \( 2^i \) 步长来分割区间，确保分割次数最少。
2. **预处理优化**：通过预处理 \( 2^i \) 的幂次，避免重复计算，提升效率。
3. **位运算**：利用位运算快速找到最大的 \( 2^i \) 步长，进一步优化计算。

### 可拓展之处
该题的贪心策略和位运算技巧可以应用于其他需要分割区间或快速计算步长的问题。类似的问题包括区间覆盖、区间合并等。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)
3. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)

### 个人心得摘录
- **调试经历**：在实现过程中，部分题解提到需要特判 \( l = 0 \) 的情况，否则会导致错误。这提醒我们在处理边界条件时要格外小心。
- **顿悟感想**：通过预处理 \( 2^i \) 的幂次，可以大大减少计算量，提升代码效率。这种优化思路在其他问题中同样适用。

---
处理用时：42.56秒
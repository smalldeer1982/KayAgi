# 题目信息

# [ABC361E] Tree and Hamilton Path 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_e

AtCoder国には $ 1 $ から $ N $ の番号がついた $ N $ 個の街と $ 1 $ から $ N-1 $ の番号がついた $ N-1 $ 本の道路があります。

道路 $ i $ は街 $ A_i $ と街 $ B_i $ を双方向に結び、長さは $ C_i $ です。どの街同士も、いくつかの道路を通って互いに行き来することができます。

いずれかの街を出発し、道路による移動で全ての街を $ 1 $ 度以上訪れるための移動距離の最小値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- 入力は全て整数である
- どの街同士も、いくつかの道路を通って互いに行き来できる
 
### Sample Explanation 1

$ 4\ \to\ 1\ \to\ 2\ \to\ 1\ \to\ 3 $ と移動すると移動距離の合計は $ 11 $ となり、これが最小値です。 最初の街に戻ってくる必要はないことに注意してください。

### Sample Explanation 2

オーバーフローに注意してください。

## 样例 #1

### 输入

```
4

1 2 2

1 3 3

1 4 4```

### 输出

```
11```

## 样例 #2

### 输入

```
10

10 9 1000000000

9 8 1000000000

8 7 1000000000

7 6 1000000000

6 5 1000000000

5 4 1000000000

4 3 1000000000

3 2 1000000000

2 1 1000000000```

### 输出

```
9000000000```

# AI分析结果

### 题目重写
[ABC361E] Tree and Hamilton Path 2

### 题目描述
AtCoder国有编号为1到N的N个城市和编号为1到N-1的N-1条道路。道路i连接城市A_i和城市B_i，长度为C_i。任意两个城市之间都可以通过若干条道路相互到达。你需要从某个城市出发，通过道路移动，访问所有城市至少一次，求最小的移动距离。

### 说明/提示
#### 约束
- 2 ≤ N ≤ 2×10^5
- 1 ≤ A_i, B_i ≤ N
- 1 ≤ C_i ≤ 10^9
- 输入均为整数
- 任意两个城市之间都可以通过若干条道路相互到达

#### 样例解释
样例1中，路径4→1→2→1→3的移动距离为11，这是最小值。注意不需要回到起点。

样例2中，注意溢出问题。

### 样例
#### 样例1
输入：
```
4
1 2 2
1 3 3
1 4 4
```
输出：
```
11
```

#### 样例2
输入：
```
10
10 9 1000000000
9 8 1000000000
8 7 1000000000
7 6 1000000000
6 5 1000000000
5 4 1000000000
4 3 1000000000
3 2 1000000000
2 1 1000000000
```
输出：
```
9000000000
```

### 题解分析与结论
本题的核心思想是通过树的直径来优化路径。由于题目不要求回到起点，因此可以通过减去树的直径来最小化路径长度。大多数题解都采用了两次DFS或树形DP来求解树的直径，并在此基础上计算最小路径长度。

### 精选题解
#### 题解1：作者：chenzhaoxu2027 (赞：7)
**星级：5星**
**关键亮点：**
- 思路清晰，直接指出通过树的直径来优化路径。
- 代码简洁，使用两次DFS求解树的直径。
- 代码可读性强，变量命名合理。

**核心代码：**
```cpp
void dfs(int u,int fa){
    for(int i=0;i<g[u].size();i++){
        int v=g[u][i],w=h[u][i];
        if(v==fa) continue;
        d[v]=d[u]+w;
        if(d[v]>d[c]) c=v;
        dfs(v,u);
    }
}
```
**实现思想：**
通过两次DFS找到树的直径，然后计算最小路径长度。

#### 题解2：作者：zrl123456 (赞：2)
**星级：4星**
**关键亮点：**
- 详细解释了树的直径与路径优化的关系。
- 使用树形DP求解树的直径，思路清晰。
- 代码结构合理，注释详细。

**核心代码：**
```cpp
void dfs(int u,int fa){
    for(auto v:G[u]){
        if(v.fi==fa) continue;
        dfs(v.fi,u);
        if(mx[u]<mx[v.fi]+v.se){
            mx2[u]=mx[u];
            mx[u]=mx[v.fi]+v.se;
        }else mx2[u]=max(mx2[u],mx[v.fi]+v.se);
    }
    num=max(num,mx[u]+mx2[u]);
}
```
**实现思想：**
通过树形DP求解树的直径，然后计算最小路径长度。

#### 题解3：作者：SpringFullGarden (赞：1)
**星级：4星**
**关键亮点：**
- 简洁明了地解释了通过树的直径优化路径的思路。
- 代码简洁，使用两次DFS求解树的直径。
- 代码可读性强，变量命名合理。

**核心代码：**
```cpp
void dfs(ll x, ll fa) {
    for(auto it : e[x]) {
        ll v = it.first, w = it.second;
        if(v == fa) continue;
        dis[v] = dis[x] + w;
        if(dis[v] > dis[lst]) lst = v;
        dfs(v, x);
    }
}
```
**实现思想：**
通过两次DFS找到树的直径，然后计算最小路径长度。

### 最优关键思路或技巧
- **树的直径**：通过两次DFS或树形DP求解树的直径，是优化路径的关键。
- **路径优化**：通过减去树的直径来最小化路径长度，是本题的核心思路。

### 可拓展之处
- **类似问题**：在需要遍历所有节点且不需要回到起点的问题中，树的直径是一个常见的优化手段。
- **算法套路**：树的直径求解方法（两次DFS或树形DP）可以应用于其他类似问题。

### 推荐题目
1. [P3304 [SDOI2013] 直径](https://www.luogu.com.cn/problem/P3304)
2. [P1395 树的直径](https://www.luogu.com.cn/problem/P1395)
3. [P3178 [HAOI2015] 树上操作](https://www.luogu.com.cn/problem/P3178)

---
处理用时：42.83秒
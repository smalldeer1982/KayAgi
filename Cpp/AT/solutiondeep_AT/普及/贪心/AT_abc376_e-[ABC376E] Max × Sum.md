# 题目信息

# [ABC376E] Max × Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_e

長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N),\ B\ =\ (B_1,\ B_2,\ \dots,\ B_N) $ が与えられます。  
$ \lbrace\ 1,\ 2,\ \dots,\ N\ \rbrace $ の部分集合であって大きさが $ K $ のものを $ 1 $ つ選び $ S $ とします。この時、以下の式の値としてあり得る最小値を求めてください。

$ \displaystyle\ \left(\max_{i\ \in\ S}\ A_i\right)\ \times\ \left(\sum_{i\ \in\ S}\ B_i\right) $ 

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^6 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数

### Sample Explanation 1

$ 1 $ 番目のテストケースでは、$ S\ =\ \lbrace\ 2,\ 3\ \rbrace $ を選ぶと式の値が $ 7\ \times\ (2\ +\ 4)\ =\ 42 $ になり、これが最小です。

## 样例 #1

### 输入

```
3
3 2
3 7 6
9 2 4
5 3
6 4 1 5 9
8 6 5 1 7
10 6
61 95 61 57 69 49 46 47 14 43
39 79 48 92 90 76 30 16 30 94```

### 输出

```
42
60
14579```

# AI分析结果

### 题目翻译
给定两个长度为 $N$ 的数列 $A = (A_1, A_2, \dots, A_N)$ 和 $B = (B_1, B_2, \dots, B_N)$。从 $\{1, 2, \dots, N\}$ 中选出一个大小为 $K$ 的子集 $S$，求以下表达式的最小值：

$$
\left(\max_{i \in S} A_i\right) \times \left(\sum_{i \in S} B_i\right)
$$

有 $T$ 个测试用例，要求对每个测试用例输出答案。

### 分析与结论
该问题的核心在于如何高效地找到满足条件的子集 $S$，使得表达式值最小。大多数题解都采用了以下思路：
1. **排序**：将数组 $A$ 和 $B$ 按照 $A$ 的值从小到大排序，便于枚举最大值。
2. **贪心选择**：对于每个可能的 $A_i$ 作为最大值，选择前 $i$ 个元素中 $B$ 值最小的 $K-1$ 个元素，加上 $B_i$，计算表达式值。
3. **数据结构优化**：使用优先队列（大根堆）来动态维护前 $K-1$ 个最小的 $B$ 值，避免每次重新排序。

### 精选题解
#### 题解1：作者：yszkddzyh (5星)
**关键亮点**：
- 详细解释了排序和贪心选择的思路，逻辑清晰。
- 使用优先队列优化了 $B$ 值的选择过程，时间复杂度为 $O(N \log N)$。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
priority_queue<int> q;
for (int i = 1; i < k; i++) {
    q.push(a[i].b);
    sum += a[i].b;
}
for (int i = k; i <= n; i++) {
    q.push(a[i].b);
    sum += a[i].b;
    ans = min(ans, a[i].a * sum);
    sum -= q.top(); q.pop();
}
```

#### 题解2：作者：mysterys (4星)
**关键亮点**：
- 强调了优先队列的使用技巧，特别是如何动态维护前 $K$ 个最小的 $B$ 值。
- 代码简洁，直接通过优先队列实现贪心选择。

**核心代码**：
```cpp
priority_queue<int, vector<int>, less<int>> q;
for (int i = 1; i <= k; i++) {
    q.push(a[i].b);
    sum += a[i].b;
}
ans = sum * a[k].a;
for (int i = k + 1; i <= n; i++) {
    sum += a[i].b;
    q.push(a[i].b);
    sum -= q.top(); q.pop();
    ans = min(ans, sum * a[i].a);
}
```

#### 题解3：作者：Ad_lqz_ht (4星)
**关键亮点**：
- 通过排序和优先队列的结合，清晰地展示了如何枚举最大值并选择最小的 $B$ 值。
- 代码结构清晰，注释详细，便于理解。

**核心代码**：
```cpp
priority_queue<int> q;
for (int i = 1; i <= k; i++) {
    q.push(p[i].b);
    sum += p[i].b;
}
for (int i = k; i <= n; i++) {
    ans = min(ans, p[i].a * sum);
    sum -= q.top(); q.pop();
    q.push(p[i + 1].b);
    sum += p[i + 1].b;
}
```

### 最优思路总结
1. **排序**：将 $A$ 和 $B$ 按照 $A$ 的值从小到大排序，便于枚举最大值。
2. **贪心选择**：对于每个可能的 $A_i$ 作为最大值，选择前 $i$ 个元素中 $B$ 值最小的 $K-1$ 个元素，加上 $B_i$，计算表达式值。
3. **优先队列优化**：使用大根堆动态维护前 $K-1$ 个最小的 $B$ 值，避免每次重新排序。

### 拓展思路
该问题可以扩展到其他类似的问题，例如：
- 求最大值与最小值的乘积。
- 求最大值与中位数的乘积。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)

### 个人心得摘录
- **调试经历**：部分题解提到在实现过程中由于未清空优先队列导致 TLE，提醒我们在多测时要注意数据结构的初始化。
- **顿悟感想**：通过排序和优先队列的结合，能够高效地解决类似的最优化问题，这种思路在竞赛中非常常见。

---
处理用时：46.54秒
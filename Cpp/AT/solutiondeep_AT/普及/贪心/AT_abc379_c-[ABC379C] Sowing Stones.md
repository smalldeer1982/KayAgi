# 题目信息

# [ABC379C] Sowing Stones

## 题目描述

给你两个数 $n$，$m$。

表示现在有 $n$ 个格子，再给你 $m$ 组数据，表示在第 $X_i$ 个格子上有 $A_i$ 个石头。

有以下操作（可以不移动）。

- 对于第 $i$ 个格子，如果这个格子上有石头 ，可以将这个格子的一个石头移动到第 $i+1$ 个格子上。

求使得每个格子上恰好有一个石头的最小移动次数，如果无法满足条件输出 $-1$。


- 第一行：$N$ $M$ 

- 第二行：$X_1$ $X_2$ $\ldots$ $X_M$

- 第三行：$A_1$ $A_2$ $\ldots$ $A_M$

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^{9} $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^{5} $
- $ M\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ X_i\ \neq\ X_j $ $ (1\ \leq\ i\ <\ j\ \leq\ M) $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^{9} $ $ (1\ \leq\ i\ \leq\ M) $
- 输入为整数
 
### Sample Explanation 1

可以通过如下 $4$ 次操作使条件满足，且没有比 $4$ 次更小的次数。

初始条件：第一个格子上有 $3$ 个石头，第四个格子上有 $2$ 个石头。

- 移动一个石头从格子 $1$ 到格子 $2$。

- 再移动一个石头从格子 $1$ 到格子 $2$。 

- 移动一个石头从格子 $2$ 到格子 $3$。

- 移动一个石头从格子 $4$ 到格子 $5$。

操作完成后每个格子上都有一个石头。

### Sample Explanation 2

这个数据中无论如何移动一定无法使每个格子上有一个石头。

## 样例 #1

### 输入

```
5 2

1 4

3 2```

### 输出

```
4```

## 样例 #2

### 输入

```
10 3

1 4 8

4 2 4```

### 输出

```
-1```

# AI分析结果

### 题目内容重写

#### [ABC379C] Sowing Stones

##### 题目描述

给你两个数 $n$，$m$。

表示现在有 $n$ 个格子，再给你 $m$ 组数据，表示在第 $X_i$ 个格子上有 $A_i$ 个石头。

有以下操作（可以不移动）。

- 对于第 $i$ 个格子，如果这个格子上有石头 ，可以将这个格子的一个石头移动到第 $i+1$ 个格子上。

求使得每个格子上恰好有一个石头的最小移动次数，如果无法满足条件输出 $-1$。

##### 输入格式

- 第一行：$N$ $M$ 
- 第二行：$X_1$ $X_2$ $\ldots$ $X_M$
- 第三行：$A_1$ $A_2$ $\ldots$ $A_M$

##### 说明/提示

###### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^{9} $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^{5} $
- $ M\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ X_i\ \neq\ X_j $ $ (1\ \leq\ i\ <\ j\ \leq\ M) $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^{9} $ $ (1\ \leq\ i\ \leq\ M) $
- 输入为整数

### 题解综合分析与结论

本题的核心思路是通过贪心算法，模拟石子的移动过程，确保每个格子最终恰好有一个石子。难点在于如何高效地计算移动次数，并处理无解的情况。以下是各题解的要点对比：

1. **Po7ed** 的题解通过排序和模拟移动过程，计算每个区间的移动次数，并处理无解情况。代码清晰，逻辑严谨。
2. **I_Love_DS** 的题解从后往前填石子，利用等差数列计算移动次数，思路新颖，但代码稍显复杂。
3. **kairuigg** 的题解通过分类讨论，处理不同情况下的移动次数，代码简洁，但细节处理不够完善。

### 所选高分题解

#### 题解1：Po7ed (4星)

**关键亮点**：
- 通过排序和模拟移动过程，计算每个区间的移动次数。
- 处理无解情况时，逻辑清晰，代码简洁。

**个人心得**：
- 赛时吃了5发罚时，提醒我们遇到细节多的题一定要冷静分析。

**核心代码**：
```cpp
a[m+1].x = n+1; // 新建节点，方便统计 (x_m,n+1)
ll ans = 0, tmp;
for(int i = 1; i <= m; i++) {
    tmp = a[i+1].x - a[i].x - 1; // 无石子区间长度
    if(a[i].a < tmp) NS; // 石子不够，无解
    a[i].a -= tmp; // 将石子均摊到无石子区间
    ans += (tmp * (tmp + 1) / 2); // 计算操作数
    a[i+1].a += a[i].a; // 将剩下石子移动到下一个位置
    ans += (tmp + 1) * a[i].a; // 计算移动操作数
}
if(a[m+1].a > 0) NS; // 如果有剩下的石子，无解
printf("%lld", ans);
```

#### 题解2：I_Love_DS (4星)

**关键亮点**：
- 从后往前填石子，利用等差数列计算移动次数。
- 思路新颖，代码结构清晰。

**核心代码**：
```cpp
int r = n + 1;
sort(a + 1, a + m + 1); // 排序，从后往前填石头
for(int i = 1; i <= m; i++) {
    if(r - a[i].x < a[i].c) { // 石头过多，无解
        printf("-1\n");
        return 0;
    }
    ans += ((r - a[i].c - a[i].x) + (r - 1 - a[i].x)) * a[i].c / 2; // 算贡献，如上文
    r -= a[i].c; // 别忘了填完要把 r 更新一下
}
if(r != 1) printf("-1\n");
else printf("%lld\n", ans);
```

### 最优关键思路与技巧

1. **排序与模拟**：通过排序石子位置，模拟石子的移动过程，确保每个区间都能被填满。
2. **等差数列求和**：利用等差数列求和公式，高效计算移动次数。
3. **无解判断**：在处理过程中，及时判断无解情况，避免无效计算。

### 可拓展之处

- **类似题目**：可以扩展到多维度格子的石子移动问题，或者限制移动方向的石子分配问题。
- **算法套路**：贪心算法结合等差数列求和，适用于类似的区间填充问题。

### 推荐题目

1. [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)
2. [P1966 [NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1966)
3. [P1045 [NOIP2005 提高组] 等价表达式](https://www.luogu.com.cn/problem/P1045)

---
处理用时：44.94秒
# 题目信息

# [ABC384E] Takahashi is Slime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_e

縦 $ H $ 行横 $ W $ 列のマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ H) $、左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ と呼ぶことにします。

はじめ、マス $ (i,j) $ には強さ $ S\ _\ {i,j} $ のスライムがおり、マス $ (P,Q) $ にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（$ 0 $ 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

- 高橋くんに隣接するスライムのうち、強さが高橋くんの強さの $ \dfrac1X $ 倍**未満**のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
 
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq500 $
- $ 1\leq\ P\leq\ H $
- $ 1\leq\ Q\leq\ W $
- $ 1\leq\ X\leq10^9 $
- $ 1\leq\ S_{i,j}\leq10^{12} $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。 
![](https://img.atcoder.jp/abc384/6b3d3bbde4767c7f5070ad0b1f202043.png) 例えば、高橋くんは次のように行動を行うことができます。 
![](https://img.atcoder.jp/abc384/81c0ccdba241277bf0cdd16ae6a7c54d.png) - マス $ (2,1) $ にいるスライムを吸収する。高橋くんの強さは $ 9+4=13 $ となり、新たにマス $ (1,1) $ のスライムとマス $ (3,1) $ のスライムが高橋くんと隣接する。 - マス $ (1,2) $ にいるスライムを吸収する。高橋くんの強さは $ 13+6=19 $ となり、新たにマス $ (1,3) $ のスライムが高橋くんと隣接する。 - マス $ (1,3) $ にいるスライムを吸収する。高橋くんの強さは $ 19+9=28 $ となる。 以上の行動を行ったあと、高橋くんの強さは $ 28 $ となります。 高橋くんがどのように行動を行っても、高橋くんの強さを $ 28 $ より大きくすることはできないため、`28` を出力してください。 高橋くんの強さの $ \dfrac12 $ 倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス $ (1,1) $ にいるスライムを吸収することはできません。

### Sample Explanation 2

高橋くんはどのスライムも吸収できません。

## 样例 #1

### 输入

```
3 3 2

2 2

14 6 9

4 9 20

17 15 7```

### 输出

```
28```

## 样例 #2

### 输入

```
3 4 1

1 1

5 10 1 1

10 1 1 1

1 1 1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
8 10 2

1 5

388 130 971 202 487 924 247 286 237 316

117 166 918 106 336 928 493 391 235 398

124 280 425 955 212 988 227 222 307 226

336 302 478 246 950 368 291 236 170 101

370 200 204 141 287 410 388 314 205 460

291 104 348 337 404 399 416 263 415 339

105 420 302 334 231 481 466 366 401 452

119 432 292 403 371 417 351 231 482 184```

### 输出

```
1343```

# AI分析结果

### 题目内容重写

#### 题目描述

给定一个 $H$ 行 $W$ 列的网格图，每个格子 $(i,j)$ 中有一个强度为 $S_{i,j}$ 的史莱姆。高桥位于格子 $(P,Q)$。高桥可以进行以下操作任意次（包括零次）：

- 选择与高桥相邻的史莱姆，且该史莱姆的强度严格小于高桥当前强度的 $\dfrac{1}{X}$ 倍，将其吸收。吸收后，该史莱姆消失，高桥的强度增加该史莱姆的强度。

操作结束后，求高桥的最大可能强度。

#### 说明/提示

- 网格图的大小 $1 \leq H, W \leq 500$。
- 高桥的初始位置 $1 \leq P \leq H$, $1 \leq Q \leq W$。
- $1 \leq X \leq 10^9$，$1 \leq S_{i,j} \leq 10^{12}$。
- 输入均为整数。

### 题解综合分析与结论

本题的核心在于如何高效地模拟高桥吸收史莱姆的过程。由于网格图较大，直接暴力枚举会超时，因此需要采用贪心策略和优先队列来优化。

#### 最优关键思路或技巧

1. **贪心策略**：每次选择当前可吸收的强度最小的史莱姆进行吸收。这样可以最大化高桥的强度增长，并为后续吸收更大的史莱姆创造条件。
2. **优先队列**：使用小根堆（优先队列）来维护当前可吸收的史莱姆，确保每次都能快速找到强度最小的史莱姆。
3. **避免精度问题**：在判断是否可吸收时，避免直接使用除法，而是通过乘法比较来防止精度问题和数据溢出。

### 所选高分题解

#### 题解1：作者：ikunTLE (★★★★★)

**关键亮点**：
- 使用优先队列实现贪心策略，确保每次吸收最小强度的史莱姆。
- 通过 `__int128` 处理大数乘法，避免数据溢出。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
priority_queue<node,vector<node>,greater<node>>pq;
while(!pq.empty()){
    node u=pq.top();pq.pop();
    if(u.num*x>=power) return unsigned_write(power),0;
    power+=u.num;
    for(int i=1;i<=4;++i){
        int xx=u.x+dx[i],yy=u.y+dy[i];
        if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&!vis[xx][yy]){
            vis[xx][yy]=true;
            pq.push({xx,yy,s[xx][yy]});
        }
    }
}
```

#### 题解2：作者：Moya_Rao (★★★★☆)

**关键亮点**：
- 通过优先队列优化 BFS，确保每次吸收最小强度的史莱姆。
- 使用向上取整避免精度问题，代码简洁易懂。

**核心代码**：
```cpp
priority_queue<node> q;
while(!q.empty()){
    node t=q.top();q.pop();
    if(s[t.x][t.y]<(now+p-1)/p&&!flag[t.x][t.y]){
        flag[t.x][t.y]=1;
        now+=s[t.x][t.y];
    }
    else continue;
    for(int i=0;i<4;i++){
        int x2=t.x+dx[i],y2=t.y+dy[i];
        if(x2<1||x2>n||y2<1||y2>m)continue;
        if(flag[x2][y2])continue;
        q.push({x2,y2});
    }
}
```

#### 题解3：作者：Walrus (★★★★☆)

**关键亮点**：
- 使用优先队列实现贪心策略，确保每次吸收最小强度的史莱姆。
- 通过 `__int128` 处理大数乘法，避免数据溢出。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
priority_queue<node> q;
while(q.size()){
    int p = q.top().p, x = q.top().x, y = q.top().y; q.pop();
    if(!check_value(p)) continue;
    res += a[x][y];
    rep(i, 0, 3){
        int xx = x + dx[i], yy = y + dy[i];
        if(!check_edge(xx, yy)) continue;
        q.push({a[xx][yy], xx, yy});
        vis[xx][yy] = 1;
    }
}
```

### 推荐相似题目

1. **洛谷 P1443** - 马的遍历：考察 BFS 和优先队列的应用。
2. **洛谷 P1162** - 填涂颜色：考察网格图的遍历和标记。
3. **洛谷 P1141** - 01迷宫：考察 BFS 和连通块的处理。

### 个人心得总结

- **调试经历**：在处理大数乘法时，直接使用 `long long` 会导致溢出，改用 `__int128` 解决了问题。
- **踩坑教训**：在判断是否可吸收时，使用除法会导致精度问题，改用乘法比较避免了这一问题。
- **顿悟感想**：贪心策略在优化搜索过程中非常有效，尤其是在需要最大化某种属性的场景下。

---
处理用时：44.72秒
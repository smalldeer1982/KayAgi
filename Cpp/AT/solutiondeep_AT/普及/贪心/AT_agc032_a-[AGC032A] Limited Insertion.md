# 题目信息

# [AGC032A] Limited Insertion

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc032/tasks/agc032_a

すぬけ君は空の数列 $ a $ を持っています。

すぬけ君は $ a $ に対して $ N $ 回操作を行います。

$ i $ 回目の操作では $ 1\ \leq\ j\ \leq\ i $ を満たす整数 $ j $ を選び、$ a $ の先頭から $ j $ 番目に $ j $ を挿入することができます。

長さ $ N $ の数列 $ b $ が与えられます。$ N $ 回の操作後に $ a $ が $ b $ と一致することがあるかどうかを判定し、可能ならばそれを達成する操作手順の一例を示してください。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ b_i\ \leq\ N $

### Sample Explanation 1

\- 各操作後、$ a $ は以下のように変化します。 - $ 1 $ 回目の操作後:$ (1) $ - $ 2 $ 回目の操作後:$ (1,1) $ - $ 3 $ 回目の操作後:$ (1,2,1) $

### Sample Explanation 2

\- 数列の先頭に $ 2 $ を挿入することはできないため、達成不可能です。

## 样例 #1

### 输入

```
3

1 2 1```

### 输出

```
1

1

2```

## 样例 #2

### 输入

```
2

2 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
9

1 1 1 2 2 1 2 3 2```

### 输出

```
1

2

2

3

1

2

2

1

1```

# AI分析结果

### 题目内容重写

【题目描述】

すぬけ君有一个空的数列 $a$。他需要对 $a$ 进行 $N$ 次操作。在第 $i$ 次操作中，他可以选择一个满足 $1 \leq j \leq i$ 的整数 $j$，并将 $j$ 插入到 $a$ 的第 $j$ 个位置。

给定一个长度为 $N$ 的数列 $b$，判断是否可以通过上述操作使 $a$ 最终与 $b$ 一致。如果可能，输出一种操作顺序。

【说明/提示】

### 约束

- 输入均为整数。
- $1 \leq N \leq 100$
- $1 \leq b_i \leq N$

### 样例解释

#### 样例 1

输入：
```
3
1 2 1
```
输出：
```
1
1
2
```
解释：
- 第一次操作后：$a = (1)$
- 第二次操作后：$a = (1, 1)$
- 第三次操作后：$a = (1, 2, 1)$

#### 样例 2

输入：
```
2
2 2
```
输出：
```
-1
```
解释：
- 无法在数列的开头插入 $2$，因此无法达成目标。

#### 样例 3

输入：
```
9
1 1 1 2 2 1 2 3 2
```
输出：
```
1
2
2
3
1
2
2
1
1
```

### 题解分析与结论

#### 题解1：火车司机

**评分：4星**

**关键亮点：**
- 采用倒推的思路，从后往前找到第一个满足 $a[x] == x$ 的位置，将其存入答案，并暴力将其后面的元素前移。
- 时间复杂度为 $O(n^2)$，思路清晰，代码简洁。

**核心实现思想：**
```cpp
for (ri i = n, f; i; --i) {
    f = 1;
    for (ri j = i; j && f; --j)
        if (a[j] == j)
            ans[i] = j, f = 0;
    if (f) {
        puts("-1");
        return 0;
    }
    for (ri j = ans[i]; j < i; ++j)
        a[j] = a[j + 1];
}
```

#### 题解2：约瑟夫用脑玩

**评分：4星**

**关键亮点：**
- 先判断是否有 $b_i > i$，若有则无解。
- 倒序考虑，每次找到最大的 $b_x = x$ 进行插入，并维护 $b_i - i$ 的最小值。
- 使用线段树上二分优化，时间复杂度为 $O(n \log n)$。

**核心实现思想：**
```cpp
// 使用线段树上二分找到最后一个满足 b[x] == x 的位置
// 并维护后缀减 1 的操作
```

#### 题解3：o51gHaboTei1

**评分：4星**

**关键亮点：**
- 贪心策略，每次从后往前找到第一个合法的位置进行删除。
- 使用势能的概念来保证贪心的正确性。
- 时间复杂度为 $O(n^2)$，代码简洁。

**核心实现思想：**
```cpp
while(len) {
    int pos = -1;
    for(int i = 1 ; i <= len ; i ++) if(b[i] == i) pos = i;
    if(pos == -1) {
        puts("-1");
        exit(0);
    }
    psy.push_back(pos);
    for(int i = pos ; i < len ; i ++) b[i] = b[i + 1];
    len --; 
}
```

### 最优关键思路与技巧

- **倒推思路**：从后往前处理，每次找到最后一个满足 $b[x] == x$ 的位置，这样可以避免影响前面的操作。
- **贪心策略**：通过贪心选择最后一个合法的位置进行删除，保证每一步的最优性。
- **线段树优化**：使用线段树上二分来优化查找和更新操作，将时间复杂度从 $O(n^2)$ 降低到 $O(n \log n)$。

### 可拓展之处

- 类似的问题可以通过倒推或贪心策略来解决，尤其是在涉及插入、删除操作的序列问题中。
- 线段树或树状数组等数据结构可以用于优化查找和更新操作，适用于需要频繁查询和修改的场景。

### 推荐题目

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得

- **调试经历**：在实现倒推或贪心策略时，需要注意边界条件和特殊情况，如无法找到满足条件的位置时应及时输出无解。
- **踩坑教训**：在优化算法时，选择合适的工具（如线段树）可以显著提高效率，但需要确保正确实现数据结构的基本操作。
- **顿悟感想**：倒推和贪心策略在许多序列问题中都非常有效，尤其是在需要构造或还原操作序列的场景中。

---
处理用时：42.62秒
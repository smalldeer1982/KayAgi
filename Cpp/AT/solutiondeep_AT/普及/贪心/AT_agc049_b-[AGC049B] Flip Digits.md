# 题目信息

# [AGC049B] Flip Digits

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc049/tasks/agc049_b

`0` と `1` からなる長さ $ N $ の文字列 $ S $ 及び $ T $ が与えられます． あなたは，$ S $ に以下の操作を好きな回数行うことができます．

- $ S_i= $`1` となる $ i $ ($ 2\ \leq\ i\ \leq\ N $) を選ぶ． そして，$ S_i $ を `0` で置き換える． さらに，$ S_{i-1} $ を今と異なる文字へ変更する．つまり，操作の直前で $ S_{i-1} $ が `0` であれば `1` に，`1` であれば `0` に変更する．

$ S $ を $ T $ に一致させることは可能でしょうか？ また可能な場合は，そのために必要な最小の操作回数はいくらでしょうか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ S $ は `0`,`1` からなる長さ $ N $ の文字列．
- $ T $ は `0`,`1` からなる長さ $ N $ の文字列．

### Sample Explanation 1

`001` → ($ i=3 $ で操作) → `010` → ($ i=2 $ で操作) → `100` とすればよいです．

## 样例 #1

### 输入

```
3

001

100```

### 输出

```
2```

## 样例 #2

### 输入

```
3

001

110```

### 输出

```
-1```

## 样例 #3

### 输入

```
5

10111

01010```

### 输出

```
5```

# AI分析结果

### 题目内容重写
给定两个由 `0` 和 `1` 组成的长度为 $N$ 的字符串 $S$ 和 $T$。你可以对 $S$ 进行以下操作任意次：

- 选择一个位置 $i$（$2 \leq i \leq N$），且 $S_i =$ `1`。然后将 $S_i$ 置为 `0`，并将 $S_{i-1}$ 取反（即 `0` 变 `1`，`1` 变 `0`）。

问是否可以通过若干次操作将 $S$ 变为 $T$，如果可以，输出所需的最小操作次数。

### 样例解释
**样例 1**  
输入：
```
3
001
100
```
输出：
```
2
```
解释：  
`001` →（在 $i=3$ 处操作）→ `010` →（在 $i=2$ 处操作）→ `100`。

**样例 2**  
输入：
```
3
001
110
```
输出：
```
-1
```
解释：无法通过操作将 `001` 变为 `110`。

**样例 3**  
输入：
```
5
10111
01010
```
输出：
```
5
```

### 题解分析与结论
各题解的主要思路是通过贪心算法，从左到右遍历字符串，遇到 $S$ 和 $T$ 不匹配的位置时，找到最近的 `1` 并将其“传递”到当前位置，完成翻转操作。难点在于如何高效地找到最近的 `1` 并计算操作次数。

### 所选高星题解

#### 1. 作者：a18981826590 (4星)
**关键亮点**：
- 思路清晰，详细分析了两种操作情况（`01` 变 `10` 和 `11` 变 `00`）。
- 代码简洁，使用双指针优化了查找 `1` 的效率。
- 提供了贪心算法的正确性证明，增强了题解的可信度。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
long long int l,m,n;
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>a>>b;
    for(long long int i=0;i<n;i++){
        if(a[i]==b[i]) continue;
        l=max(i+1,l);
        while(l<n&&a[l]==48) l++;
        if(l==n){
            cout<<-1;
            return 0;
        }
        m+=l-i;
        a[l++]=48;
    }
    cout<<m;
    return 0;
}
```
**实现思想**：从左到右遍历字符串，遇到不匹配的位置时，从上次找到的 `1` 的位置开始继续查找，计算操作次数并更新字符串。

#### 2. 作者：hellolin (4星)
**关键亮点**：
- 使用队列记录 `1` 的位置，优化了查找过程。
- 详细解释了操作的本质（将 `1` 向左移动），并提供了清晰的思路。
- 代码结构清晰，易于理解。

**核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s,t;
queue<int>a,b;
long long ans;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>s>>t;
    for(int i=0; i<n; i++)
    {
        if(t[i]=='1')a.push(i);
        if(s[i]=='1')
        {
            if(a.empty())
            {
                if(b.empty()) b.push(i);
                else
                {
                    ans+=i-b.front(); // 记录步骤数
                    b.pop();
                }
            }
            else
            {
                ans+=i-a.front(); // 记录步骤数
                    a.pop();
            }
        }
    }
    if(a.size()||b.size())cout<<-1<<endl;
    else cout<<ans<<endl;
    return 0;
}
```
**实现思想**：使用两个队列分别记录 $T$ 和 $S$ 中 `1` 的位置，通过队列的先进先出特性，确保每次操作都是最优的。

#### 3. 作者：I_Like_Play_Genshin (4星)
**关键亮点**：
- 使用双指针优化查找过程，代码简洁高效。
- 提供了贪心算法的正确性证明，增强了题解的可信度。
- 代码实现简洁，易于理解。

**核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
long long n,ans,j=0;
int main(){
    cin>>n>>s>>t;
    for(int i=0;i<n;i++){
        if(s[i]!=t[i]){//要交换 
            if(j<i+1)j=i+1;//以前搜过的不用再搜了（记忆化） 
            while(j<n&&s[j]=='0')j++;//找到最近的1
            if(j==n){//没找到 
                cout<<-1;
                return 0;
            } 
            s[j]='0';//移到前面了 
            ans+=j-i;
        }
    }
    cout<<ans;
    return 0;
}
```
**实现思想**：使用双指针从左到右遍历字符串，遇到不匹配的位置时，从上次找到的 `1` 的位置开始继续查找，计算操作次数并更新字符串。

### 最优关键思路
1. **贪心算法**：从左到右遍历字符串，遇到不匹配的位置时，找到最近的 `1` 并将其“传递”到当前位置，完成翻转操作。
2. **双指针优化**：通过记录上次找到的 `1` 的位置，避免重复查找，提高效率。
3. **队列记录**：使用队列记录 `1` 的位置，确保每次操作都是最优的。

### 拓展思路
- 类似题目可以考察如何通过有限的操作将字符串从一个状态转换到另一个状态，通常可以使用贪心算法或动态规划来解决。
- 可以进一步优化查找 `1` 的过程，例如使用二分查找或预处理 `1` 的位置。

### 推荐题目
1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得摘录
- **a18981826590**：贪心算法的正确性需要仔细证明，操作顺序不影响结果。
- **hellolin**：使用队列记录 `1` 的位置可以大大优化查找过程，确保每次操作都是最优的。
- **I_Like_Play_Genshin**：双指针优化查找过程，代码简洁高效，贪心算法的正确性需要仔细证明。

---
处理用时：64.65秒
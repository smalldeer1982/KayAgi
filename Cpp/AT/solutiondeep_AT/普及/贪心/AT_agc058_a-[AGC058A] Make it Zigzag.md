# 题目信息

# [AGC058A] Make it Zigzag

## 题目描述

给定一个排列 $ P=(P_1,P_2,\cdots,P_{2N}) $，其中 $ (1,2,\cdots,2N) $。

你可以进行以下操作 $ 0 $ 到 $ N $ 次：

- 选择一个整数 $ x $ ($ 1\ \leq\ x\ \leq\ 2N-1 $)，交换 $ P_x $ 和 $ P_{x+1} $ 的值。

请找出一系列操作，使得操作后的 $ P $ 满足以下条件：

- 对于每个 $ i=1,3,5,\cdots,2N-1 $，$ P_i\ <\ P_{i+1} $。
- 对于每个 $ i=2,4,6,\cdots,2N-2 $，$ P_i\ >\ P_{i+1} $。

请输出满足条件的一系列操作，以以下形式输出：

> $ K $ $ x_1 $ $ x_2 $ $ \cdots $ $ x_K $

其中，$ K $ 表示操作次数 ($ 0\ \leq\ K\ \leq\ N $)，$ x_i $ ($ 1\ \leq\ x_i\ \leq\ 2N-1 $) 表示第 $ i $ 次操作选择的 $ x $ 的值。如果存在多个满足条件的解，任意输出一个即可。

## 说明/提示

### 约束条件

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ (P_1,P_2,\cdots,P_{2N}) $ 是 $ (1,2,\cdots,{2N}) $ 的排列
- 输入的数值均为整数

### 样例解释 1

将 $ P=(4,3,2,1) $ 根据操作后，得到 $ P=(3,4,1,2)$，满足条件。

## 样例 #1

### 输入

```
2

4 3 2 1```

### 输出

```
2

1 3```

## 样例 #2

### 输入

```
1

1 2```

### 输出

```
0```

# AI分析结果

### 题目内容重写

#### [AGC058A] Make it Zigzag

##### 题目描述

给定一个排列 $ P=(P_1,P_2,\cdots,P_{2N}) $，其中 $ (1,2,\cdots,2N) $。

你可以进行以下操作 $ 0 $ 到 $ N $ 次：

- 选择一个整数 $ x $ ($ 1\ \leq\ x\ \leq\ 2N-1 $)，交换 $ P_x $ 和 $ P_{x+1} $ 的值。

请找出一系列操作，使得操作后的 $ P $ 满足以下条件：

- 对于每个 $ i=1,3,5,\cdots,2N-1 $，$ P_i\ <\ P_{i+1} $。
- 对于每个 $ i=2,4,6,\cdots,2N-2 $，$ P_i\ >\ P_{i+1} $。

请输出满足条件的一系列操作，以以下形式输出：

> $ K $ $ x_1 $ $ x_2 $ $ \cdots $ $ x_K $

其中，$ K $ 表示操作次数 ($ 0\ \leq\ K\ \leq\ N $)，$ x_i $ ($ 1\ \leq\ x_i\ \leq\ 2N-1 $) 表示第 $ i $ 次操作选择的 $ x $ 的值。如果存在多个满足条件的解，任意输出一个即可。

##### 说明/提示

###### 约束条件

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ (P_1,P_2,\cdots,P_{2N}) $ 是 $ (1,2,\cdots,{2N}) $ 的排列
- 输入的数值均为整数

###### 样例解释 1

将 $ P=(4,3,2,1) $ 根据操作后，得到 $ P=(3,4,1,2)$，满足条件。

##### 样例 #1

###### 输入

```
2

4 3 2 1```

###### 输出

```
2

1 3```

##### 样例 #2

###### 输入

```
1

1 2```

###### 输出

```
0```

### 题解综合分析与结论

本题的核心目标是通过交换相邻元素，使得排列满足特定的“锯齿”条件。大多数题解采用了贪心策略，通过遍历数组并根据条件进行交换操作。以下是对各题解的要点总结与对比：

1. **贪心策略**：大多数题解通过遍历数组，检查每个偶数位置的元素是否满足“波浪”条件，若不满足则进行交换。这种策略的时间复杂度为 $O(N)$，符合题目要求。
2. **优化**：部分题解通过每次处理两个元素，减少交换次数，确保操作次数不超过 $N$ 次。
3. **代码实现**：大多数题解使用 `swap` 函数进行交换，并将操作记录在 `vector` 或数组中，最后输出操作次数和操作序列。

### 所选高星题解

#### 题解1：作者：yangjinqian (赞：3)

**星级：4星**

**关键亮点：**
- 思路清晰，直接通过贪心策略遍历数组，分别处理奇数和偶数位置的元素。
- 代码简洁，逻辑明确，易于理解。

**核心代码：**
```cpp
for (int i = 1; i <= n - 1; i += 2)
    if (a[i] >= a[i + 1])
        ans[++t] = i, swap(a[i], a[i + 1]);
for (int i = 2; i <= n - 2; i += 2)
    if (a[i] <= a[i + 1])
        ans[++t] = i, swap(a[i], a[i + 1]);
```

#### 题解2：作者：FFTotoro (赞：2)

**星级：4星**

**关键亮点：**
- 采用了一种与众不同的贪心策略，通过处理连续的三个元素，确保每次交换都能满足条件。
- 通过减少交换次数，优化了操作次数。

**核心代码：**
```cpp
for (int i = 0; i < n << 1; i += 2) {
    if (i + 2 >= n << 1) { if (a[i + 1] < a[i]) b.emplace_back(i + 1); break; }
    if (a[i + 1] > max(a[i], a[i + 2])) continue;
    if (a[i] > a[i + 2]) swap(a[i], a[i + 1]), b.emplace_back(i + 1);
    else swap(a[i + 1], a[i + 2]), b.emplace_back(i + 2);
}
```

#### 题解3：作者：_JellyFish_ (赞：1)

**星级：4星**

**关键亮点：**
- 通过遍历偶数位置，确保每个偶数位置的元素都比相邻的两个元素大。
- 代码逻辑清晰，易于理解。

**核心代码：**
```cpp
for (int i = 2; i <= n * 2; i += 2) {
    if (i != n * 2 && a[i] < max(a[i - 1], a[i + 1])) {
        if (a[i - 1] > a[i + 1]) swap(a[i], a[i - 1]), v.push_back(i - 1);
        else swap(a[i], a[i + 1]), v.push_back(i);
    }
    if (i == n * 2 && a[i] < a[i - 1]) v.push_back(i - 1);
}
```

### 最优关键思路与技巧

1. **贪心策略**：通过遍历数组，检查每个偶数位置的元素是否满足条件，若不满足则进行交换。这种策略确保了每次交换都能使数组更接近目标状态。
2. **优化交换次数**：通过每次处理两个元素，减少交换次数，确保操作次数不超过 $N$ 次。
3. **代码实现**：使用 `swap` 函数进行交换，并将操作记录在 `vector` 或数组中，最后输出操作次数和操作序列。

### 可拓展之处

本题的贪心策略可以应用于其他需要满足特定条件的排列问题，如“山峰”排列或“山谷”排列。类似的问题可以通过类似的遍历和交换策略来解决。

### 推荐相似题目

1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 个人心得总结

在解决此类问题时，贪心策略通常是最直接且有效的方法。通过遍历数组并根据条件进行交换，可以快速达到目标状态。此外，优化交换次数和代码实现也是提高效率的关键。

---
处理用时：69.65秒
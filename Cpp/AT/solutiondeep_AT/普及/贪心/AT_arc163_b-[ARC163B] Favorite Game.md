# 题目信息

# [ARC163B] Favorite Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc163/tasks/arc163_b

長さ $ N $ の整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。あなたは、以下の操作を好きな回数（$ 0 $ 回でもよい）行うことが出来ます。

- $ 1\ \le\ i\ \le\ N $ を満たす整数 $ i $ を $ 1 $ 個選び、$ A_i $ を $ 1 $ 増やすか $ 1 $ 減らす。
 
あなたの目標は、$ A_1\ \le\ A_i\ \le\ A_2 $ を満たす整数 $ i(3\ \le\ i\ \le\ N) $ の個数を $ M $ 個以上にすることです。目標を達成するために必要な最小の操作回数を求めてください。

## 说明/提示

### 制約

- $ 3\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ M\ \le\ N-2 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
 
### Sample Explanation 1

以下のように操作を行うことで $ A_1\ \le\ A_i\ \le\ A_2 $ を満たす整数 $ i(3\ \le\ i\ \le\ N) $ の個数を $ 1 $ 個以上に出来ます。 - $ i=3 $ を選び、$ A_i $ を $ 1 $ 減らす。 - $ i=2 $ を選び、$ A_i $ を $ 1 $ 増やす。 $ 1 $ 回以下の操作回数で目標を達成することは出来ないため、答えは $ 2 $ です。

### Sample Explanation 2

始めから目標を達成していることもあります。

## 样例 #1

### 输入

```
3 1

2 3 5```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2

1 4 2 3 5```

### 输出

```
0```

## 样例 #3

### 输入

```
8 5

15 59 64 96 31 17 88 9```

### 输出

```
35```

# AI分析结果

### 题目内容重写

**题目描述**

给定一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$。你可以进行以下操作任意次（包括0次）：

- 选择一个整数 $i$ 满足 $1 \le i \le N$，将 $A_i$ 增加或减少 $1$。

你的目标是使得至少有 $M$ 个整数 $i$ 满足 $3 \le i \le N$，且 $A_1 \le A_i \le A_2$。求达成目标所需的最小操作次数。

**说明/提示**

- $3 \le N \le 2 \times 10^5$
- $1 \le M \le N-2$
- $1 \le A_i \le 10^9$

**样例解释**

样例1：

输入：
```
3 1
2 3 5
```
输出：
```
2
```
解释：通过将 $A_3$ 减少 $1$ 和将 $A_2$ 增加 $1$，可以使 $A_3$ 满足 $A_1 \le A_3 \le A_2$。

样例2：

输入：
```
5 2
1 4 2 3 5
```
输出：
```
0
```
解释：初始时已经有 $2$ 个元素满足条件，无需操作。

样例3：

输入：
```
8 5
15 59 64 96 31 17 88 9
```
输出：
```
35
```

### 题解分析与结论

**综合分析**

本题的核心思路是通过贪心策略，只修改 $A_1$ 和 $A_2$ 来最小化操作次数。通过排序 $A_3$ 到 $A_N$，并枚举长度为 $M$ 的区间，计算将 $A_1$ 和 $A_2$ 调整到包含该区间所需的最小操作次数。这一思路在多个题解中被反复提及，且时间复杂度为 $O(n \log n)$，能够通过本题的约束条件。

**最优关键思路**

1. **贪心策略**：只修改 $A_1$ 和 $A_2$，因为修改这两个值可以同时影响多个元素是否满足条件，而修改其他元素只能影响单个元素。
2. **排序与枚举**：将 $A_3$ 到 $A_N$ 排序后，枚举所有长度为 $M$ 的区间，计算将 $A_1$ 和 $A_2$ 调整到包含该区间所需的最小操作次数。

**可拓展之处**

类似的问题可以通过贪心策略和排序来解决，尤其是在需要调整某些边界条件以满足特定要求时。例如，某些题目可能需要调整区间的上下界，使得某些元素满足特定条件，这类问题通常可以通过类似的思路解决。

**推荐题目**

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1048 采药](https://www.luogu.com.cn/problem/P1048)

### 所选高星题解

**题解1：Magus (4星)**

**关键亮点**：
- 清晰解释了贪心策略，说明只修改 $A_1$ 和 $A_2$ 的原因。
- 代码简洁，直接使用 `stable_sort` 进行排序，并通过枚举区间计算最小操作次数。

**代码片段**：
```cpp
stable_sort(arr+2,arr+n);
for(int i=2;i<=n-m;i++) {
    awa=min(awa,max(0ll,arr[0]-arr[i])+max(0ll,arr[i+m-1]-arr[1]));
}
```

**题解2：fengxiaoyi (4星)**

**关键亮点**：
- 详细证明了只修改 $A_1$ 和 $A_2$ 的最优性。
- 提供了图解帮助理解，增强了题解的可读性。

**代码片段**：
```cpp
sort(b+1,b+n+1,cmp);
for(int i=1;i<=n-m+1;i++) ans=min(ans,max(a1-b[i],0)+max(b[i+m-1]-a2,0));
```

**题解3：yydfj (4星)**

**关键亮点**：
- 详细分析了四种情况，并分别计算操作次数，思路清晰。
- 代码实现简洁，直接使用 `stable_sort` 进行排序。

**代码片段**：
```cpp
stable_sort(a+3,a+n+1);
for(int i=3;i<=n-m+1;i++) {
    if(a[1]<=a[i]&&a[2]>=a[i+m-1]) ans=0;
    else if(a[1]<=a[i]) ans=min(ans,a[i+m-1]-a[2]);
    else if(a[2]>=a[i+m-1]) ans=min(ans,a[1]-a[i]);
    else ans=min(ans,a[1]-a[i]+a[i+m-1]-a[2]);
}
```

### 个人心得总结

- **调试经历**：部分题解提到在实现过程中需要注意 `long long` 的使用，避免因数据范围过大导致错误。
- **踩坑教训**：在枚举区间时，确保区间的长度和边界条件正确，避免遗漏某些情况。
- **顿悟感想**：通过贪心策略和排序，能够将复杂问题简化，减少不必要的计算，提高算法效率。

---
处理用时：43.45秒
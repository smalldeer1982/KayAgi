# 题目信息

# [ARC170A] Yet Another AB Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_a

`A`, `B` からなる長さ $ N $ の文字列 $ S,T $ が与えられます．$ S $ の左から $ i $ 番目の文字を $ S_i $ と表します．

あなたは以下の操作を好きな回数（$ 0 $ 回でもよい）繰り返すことができます．

- $ 1\leq\ i\ <\ j\ \leq\ N $ を満たす整数 $ i,j $ を選ぶ． $ S_i $ を `A` で， $ S_j $ を `B` で置き換える．
 
$ S $ を $ T $ に一致させることが可能か判定し，可能な場合必要な最小の操作回数を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ S,T $ は `A`, `B` からなる長さ $ N $ の文字列
- 入力される数値は全て整数
 
### Sample Explanation 1

$ i=1,j=3 $ として操作を行うと $ S $ は `AABBA` に変化します． 次に，$ i=4,j=5 $ として操作を行うと $ S $ は `AABAB` に変化します． よって $ 2 $ 回の操作で $ S $ を $ T $ と一致させることが可能です．また，これが必要な最小の操作回数であることが証明できるので答えは $ 2 $ です．

### Sample Explanation 2

何回操作を行っても $ S $ を $ T $ と一致させることは不可能であることが証明できます．

## 样例 #1

### 输入

```
5

BAABA

AABAB```

### 输出

```
2```

## 样例 #2

### 输入

```
2

AB

BA```

### 输出

```
-1```

# AI分析结果

### 题目内容重写
给定两个由 `A` 和 `B` 组成的长度为 $N$ 的字符串 $S$ 和 $T$。你可以进行以下操作任意次（包括零次）：

- 选择两个整数 $i$ 和 $j$，满足 $1 \leq i < j \leq N$，将 $S_i$ 改为 `A`，$S_j$ 改为 `B`。

你需要判断是否可以通过若干次操作将 $S$ 变为 $T$，如果可以，输出所需的最小操作次数，否则输出 `-1`。

### 题解分析与结论

#### 关键思路与技巧
1. **贪心匹配**：优先匹配需要将 `B` 改为 `A` 和需要将 `A` 改为 `B` 的位置，这样可以减少操作次数。
2. **栈/队列的使用**：通过栈或队列来存储需要修改的位置，方便后续匹配。
3. **无解情况的判断**：在字符串的开头和结尾，如果 $T$ 的某些字符无法通过操作得到，则直接输出 `-1`。

#### 最优题解推荐

1. **作者：Register_int (赞：3)**
   - **星级**：★★★★☆
   - **关键亮点**：通过贪心匹配减少操作次数，代码简洁且高效。
   - **核心代码**：
     ```cpp
     for (int i = 1, j = 0; i <= n; i++) {
         if (s[i] == t[i]) continue;
         if (t[i] == 'A') j++;
         if (t[i] == 'B' && j) j--, ans--;
     }
     ```
   - **总结**：通过维护一个计数器 `j`，优先匹配需要将 `B` 改为 `A` 和需要将 `A` 改为 `B` 的位置，减少操作次数。

2. **作者：Lame_Joke (赞：3)**
   - **星级**：★★★★☆
   - **关键亮点**：使用栈来存储需要修改的位置，匹配后减少操作次数。
   - **核心代码**：
     ```cpp
     if (s[i] == 'B' && t[i] == 'A') s1[++cnt] = i;
     else if (s[i] == 'A' && t[i] == 'B') {
         if (cnt != 0) {
             cnt--;
             ans++;
         }
     }
     ```
   - **总结**：通过栈来存储需要将 `B` 改为 `A` 的位置，遇到需要将 `A` 改为 `B` 的位置时，优先与栈中的位置匹配。

3. **作者：Cure_Wing (赞：0)**
   - **星级**：★★★★☆
   - **关键亮点**：通过前后遍历判断无解情况，并使用贪心匹配减少操作次数。
   - **核心代码**：
     ```cpp
     for (int i = l + 1; i < r; ++i) {
         if (s[i] == 'B' && t[i] == 'A') ++cnt;
         if (s[i] == 'A' && t[i] == 'B') { --cnt; ++ans; }
         cnt = std::max(cnt, 0);
     }
     ```
   - **总结**：通过前后遍历判断无解情况，并使用贪心匹配减少操作次数，代码简洁且高效。

### 扩展思路与推荐题目
1. **扩展思路**：本题的贪心匹配思想可以应用于其他字符串匹配问题，尤其是涉及字符替换和最小操作次数的问题。
2. **推荐题目**：
   - [P1047 字符串的展开](https://www.luogu.com.cn/problem/P1047)
   - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
   - [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)

### 个人心得总结
- **调试经历**：在处理字符串匹配问题时，优先考虑无解情况可以避免后续的复杂操作。
- **踩坑教训**：在贪心匹配时，需要注意匹配的顺序和条件，避免遗漏某些情况。
- **顿悟感想**：通过栈或队列来存储需要修改的位置，可以大大提高匹配的效率。

---
处理用时：33.87秒
# 题目信息

# [ARC179A] Partition

## 题目描述

给定你整数 $N$ 和 $K$。

定义长度为 $N$ 的整数序列 $X=(X_1,X_2,\dots,X_N)$ 的**前缀和**为长度为 $N+1$ 的序列 $Y=(Y_0,Y_1,\dots,Y_N)$ 满足：

- $Y_0=0$

- $Y_i=\sum\limits_{j=1}^{i}X_j (i=1,2,\dots,N)$

如果一个长度为 $N$ 的整数序列 $X=(X_1,X_2,\dots,X_N)$ 满足以下条件，那么它被成为**好的序列**：

- 在 $X$ 的前缀和中，任何小于 $K$ 的值都出现在任何不小于 $K$ 的值之前。
	- 形式化的说，对于 $X$ 的前缀和 $Y$，对于任意整数对 $(i,j)$ 其中 $0\le i,j\le N$，如果 $Y_i<K$ 且 $Y_j\ge K$ 那么 $i<j$。
	
给你一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$。判断是否能够通过重排 $A$ 中的元素使 $A$ 变成一个好的序列。如果可以，输出重排后的结果。

## 说明/提示

- $1\le N\le 2\times 10^5$； 
- $-10^9\le K\le 10^9$； 
- $-10^9\le A_i\le 10^9$； 
- 所有输入都是整数。

## 样例 #1

### 输入

```
4 1

-1 2 -3 4```

### 输出

```
Yes

-3 -1 2 4```

## 样例 #2

### 输入

```
4 -1

1 -2 3 -4```

### 输出

```
No```

## 样例 #3

### 输入

```
10 1000000000

-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
Yes

-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

# AI分析结果

### 题目内容重写

给定整数 $N$ 和 $K$。

定义长度为 $N$ 的整数序列 $X=(X_1,X_2,\dots,X_N)$ 的**前缀和**为长度为 $N+1$ 的序列 $Y=(Y_0,Y_1,\dots,Y_N)$ 满足：

- $Y_0=0$

- $Y_i=\sum\limits_{j=1}^{i}X_j (i=1,2,\dots,N)$

如果一个长度为 $N$ 的整数序列 $X=(X_1,X_2,\dots,X_N)$ 满足以下条件，那么它被称为**好的序列**：

- 在 $X$ 的前缀和中，任何小于 $K$ 的值都出现在任何不小于 $K$ 的值之前。
	- 形式化的说，对于 $X$ 的前缀和 $Y$，对于任意整数对 $(i,j)$ 其中 $0\le i,j\le N$，如果 $Y_i<K$ 且 $Y_j\ge K$ 那么 $i<j$。
	
给你一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$。判断是否能够通过重排 $A$ 中的元素使 $A$ 变成一个好的序列。如果可以，输出重排后的结果。

### 说明/提示

- $1\le N\le 2\times 10^5$； 
- $-10^9\le K\le 10^9$； 
- $-10^9\le A_i\le 10^9$； 
- 所有输入都是整数。

### 样例 #1

#### 输入

```
4 1

-1 2 -3 4
```

#### 输出

```
Yes

-3 -1 2 4
```

### 样例 #2

#### 输入

```
4 -1

1 -2 3 -4
```

#### 输出

```
No
```

### 样例 #3

#### 输入

```
10 1000000000

-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
```

#### 输出

```
Yes

-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
```

### 题解分析与结论

本题的核心在于通过贪心策略对序列进行排序，使得前缀和序列满足特定条件。大部分题解都采用了分类讨论的思路，根据 $K$ 的不同取值（正数或负数）来决定排序方式。具体来说：

1. **当 $K \ge 1$ 时**，将序列升序排序，确保所有小于 $K$ 的数出现在前面，而大于等于 $K$ 的数出现在后面。
2. **当 $K < 1$ 时**，首先计算序列的总和 $sum$，如果 $sum \ge K$，则将序列降序排序；否则，输出 `No`。

这种分类讨论的方法能够有效解决问题，且时间复杂度为 $O(n \log n)$，适用于题目中的最大数据范围。

### 评分较高的题解

#### 题解1：作者：chinazhanghaoxun (赞：6)

**星级：4.5**

**关键亮点：**
- 清晰的分类讨论思路，分别处理 $K \ge 1$ 和 $K < 1$ 的情况。
- 代码简洁，逻辑清晰，易于理解。
- 强调了开 `long long` 的重要性，避免了数据溢出问题。

**代码片段：**
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[200005],sum;
bool cmp(int a,int b){
	return a>b;
} 
signed main(){
	cin>>n>>k; 
	for(int i=1;i<=n;i++)
		cin>>a[i],sum+=a[i]; 
	if(k>=1){ 
		sort(a+1,a+n+1);
		puts("Yes");
		for(int i=1;i<=n;i++)
			cout<<a[i]<<' ';
		puts("");
	}else{
		if(sum>=k){ 
			sort(a+1,a+n+1,cmp);
			puts("Yes");
			for(int i=1;i<=n;i++)
				cout<<a[i]<<' ';
			puts("");
		}else 
			puts("No");
	}
	return 0;
} 
```

#### 题解2：作者：fire_and_sweets (赞：1)

**星级：4**

**关键亮点：**
- 简洁明了的贪心策略，分类讨论清晰。
- 代码结构合理，易于扩展和维护。
- 强调了时间复杂度为 $O(n)$，适合大规模数据处理。

**代码片段：**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 200010;
int n, k, a[N];
signed main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; i ++ ) cin >> a[i];
	int sum = 0;
	for (int i = 1; i <= n; i ++ ) sum += a[i];
	if (k >= 1)
	{
		sort(a + 1, a + n + 1);
		cout << "Yes\n";
		for (int i = 1; i <= n; i ++ ) cout << a[i] << " ";
		cout << endl;
	}
	else
	{
		if (sum >= k)
		{
			sort(a + 1, a + n + 1, greater<int>());
			cout << "Yes\n";
			for (int i = 1; i <= n; i ++ ) cout << a[i] << " ";
			cout << endl;
		}
		else cout << "No\n";
	}
	return 0;
} 
```

#### 题解3：作者：uncle_steve (赞：2)

**星级：4**

**关键亮点：**
- 详细的分类讨论，逻辑清晰。
- 代码注释丰富，便于理解。
- 强调了输出格式的正确性，避免因格式问题导致的错误。

**代码片段：**
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[200005],sum;
bool cmp(int a,int b){
	return a>b;
} 
signed main(){
	cin>>n>>k; 
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i]; 
	}
	if(k>=1){ 
		sort(a+1,a+n+1);
		cout<<"Yes"<<endl;
		for(int i=1;i<=n;i++){
			cout<<a[i]<<" ";
		}
	}
	else{ 
		if(sum>=k){ 
			sort(a+1,a+n+1,cmp);
			cout<<"Yes"<<endl;
			for(int i=1;i<=n;i++){
				cout<<a[i]<<" ";
			}
		}
		else cout<<"No"<<endl;
	}
	return 0;
}
```

### 最优关键思路与技巧

1. **分类讨论**：根据 $K$ 的不同取值（正数或负数）决定排序方式，确保前缀和序列满足条件。
2. **贪心策略**：通过排序使得序列的前缀和逐渐增加或减少，从而满足题目要求。
3. **数据范围处理**：使用 `long long` 避免数据溢出问题，确保程序在极端数据下也能正常运行。

### 可拓展之处

本题的贪心策略和分类讨论方法可以应用于其他需要根据特定条件对序列进行排序的问题。例如，类似的问题可以要求序列的前缀和满足某种单调性或其他条件。

### 推荐题目

1. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
3. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

### 个人心得总结

在解决本题时，许多题解作者都强调了分类讨论的重要性，尤其是在处理 $K$ 的不同取值时。此外，数据范围的处理也是一个常见的坑点，使用 `long long` 可以有效避免溢出问题。代码的简洁性和逻辑清晰性也是解题的关键，尤其是在竞赛中，快速实现并调试代码是至关重要的。

---
处理用时：68.79秒
# 题目信息

# [ARC185B] +1 and -1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc185/tasks/arc185_b

長さ $ N $ の整数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ があります。  
 あなたは次の操作を $ 0 $ 回以上好きな回数行うことが出来ます。

- $ 1\ \leq\ i\ \lt\ j\ \leq\ N $ を満たす整数対 $ (i,\ j) $ を選び、$ A_i $ を $ A_i\ +\ 1 $ に、$ A_j $ を $ A_j\ -\ 1 $ に置き換える。
 
操作によって $ A $ を広義単調増加な数列にすることが可能かどうか判定してください。

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のテストケースでは、次のように操作を行うことで $ A $ を広義単調増加な数列にすることが出来ます。 - $ (i,\ j) $ として $ (1,\ 2) $ を選ぶ。操作後の $ A $ は $ (2,\ 6,\ 5) $ になる。 - $ (i,\ j) $ として $ (1,\ 2) $ を選ぶ。操作後の $ A $ は $ (3,\ 5,\ 5) $ になる。 $ 2 $ 番目のテストケースでは、どのように操作しても $ A $ を広義単調増加な数列にすることは出来ません。

## 样例 #1

### 输入

```
3

3

1 7 5

2

9 0

10

607 495 419 894 610 636 465 331 925 724```

### 输出

```
Yes

No

Yes```

# AI分析结果

### 题目内容重写

【题目描述】

给定一个长度为 $N$ 的整数序列 $A = (A_1, A_2, \dots, A_N)$。你可以进行以下操作任意次：

- 选择满足 $1 \leq i < j \leq N$ 的整数对 $(i, j)$，将 $A_i$ 增加 $1$，并将 $A_j$ 减少 $1$。

问是否可以通过这些操作将 $A$ 变成一个非递减的序列。

$T$ 个测试用例，每个测试用例需要输出 `Yes` 或 `No`。

【说明/提示】

### 约束条件

- $1 \leq T \leq 2 \times 10^5$
- $2 \leq N \leq 2 \times 10^5$
- $0 \leq A_i \leq 10^9$
- 所有测试用例的 $N$ 总和不超过 $2 \times 10^5$
- 输入值均为整数

### 样例解释

第一个测试用例中，可以通过以下操作将 $A$ 变成非递减序列：
- 选择 $(1, 2)$，$A$ 变为 $(2, 6, 5)$
- 再次选择 $(1, 2)$，$A$ 变为 $(3, 5, 5)$

第二个测试用例中，无论如何操作都无法将 $A$ 变成非递减序列。

### 样例输入

```
3

3

1 7 5

2

9 0

10

607 495 419 894 610 636 465 331 925 724
```

### 样例输出

```
Yes

No

Yes
```

---

### 题解分析与结论

本题的核心在于判断是否可以通过操作将序列变为非递减序列。所有题解的共同思路是通过构造一个目标序列（通常是尽可能平均的序列），然后判断原序列能否通过操作转化为该目标序列。

#### 关键思路：
1. **目标序列构造**：目标序列的前 $n - s \mod n$ 个元素为 $\lfloor \frac{s}{n} \rfloor$，后 $s \mod n$ 个元素为 $\lceil \frac{s}{n} \rceil$，其中 $s$ 是序列的总和。
2. **前缀和判断**：通过计算原序列与目标序列的前缀和，判断是否在任何时刻原序列的前缀和都大于等于目标序列的前缀和。如果出现原序列的前缀和小于目标序列的情况，则无法通过操作达到目标。

#### 最优题解：
1. **作者：Locix_Elaina_Celome (4星)**
   - **亮点**：代码简洁，思路清晰，通过从后向前计算前缀和来判断是否合法。
   - **代码核心**：
     ```cpp
     for(int i=n;i;i--){
         sm+=a[i]-g[i];
         if(sm<0){
             puts("No");
             break;
         }
     }
     if(sm>=0)puts("Yes");
     ```
   - **个人心得**：通过从后向前计算，避免了复杂的条件判断，代码更加简洁。

2. **作者：Nuclear_Fish_cyq (4星)**
   - **亮点**：通过正序贪心，逐步调整序列，确保每个位置的值尽可能小，从而为后面的位置留出调整空间。
   - **代码核心**：
     ```cpp
     for(int i = 0; i < n; i++){
         ll t = sum / n + (n - i <= sum % n);
         now += t - a[i];
         if(now < 0){
             cout << "No" << endl;
             break;
         } 
     }
     if(now >= 0) cout << "Yes" << endl;
     ```
   - **个人心得**：通过正序贪心，逐步调整序列，确保每个位置的值尽可能小，从而为后面的位置留出调整空间。

3. **作者：Binah_cyc (4星)**
   - **亮点**：通过正序贪心，分两次向前填充，确保序列的单调性，并尽量让当前位置的值最小。
   - **代码核心**：
     ```cpp
     if(a[i]>=f[i-1]){
         int desum=f[i-1]*(i-1-lst)-(sum[i-1]-sum[lst]);
         int oversum=a[i]-f[i-1];
         if(desum>oversum) f[i]=f[i-1];
         else{
             oversum=(a[i]-f[i-1])-(f[i-1]*(i-1)-sum[i-1]);
             int ave=(oversum+i-1)/i;
             f[i]=f[i-1]+ave;
             vis[i]=1,lst=i;
         }
     }
     ```
   - **个人心得**：通过分两次向前填充，确保序列的单调性，并尽量让当前位置的值最小。

### 最优关键思路总结
- **目标序列构造**：构造一个尽可能平均的目标序列，确保序列的非递减性。
- **前缀和判断**：通过计算原序列与目标序列的前缀和，判断是否在任何时刻原序列的前缀和都大于等于目标序列的前缀和。

### 推荐题目
1. [P2367 差分基础题](https://www.luogu.com.cn/problem/P2367)
2. [P3406 单调队列](https://www.luogu.com.cn/problem/P3406)
3. [P3372 线段树](https://www.luogu.com.cn/problem/P3372)

### 个人心得总结
- **调试经历**：在构造目标序列时，需要注意余数的处理，确保序列的单调性。
- **踩坑教训**：在判断前缀和时，必须确保在任何时刻原序列的前缀和都大于等于目标序列的前缀和，否则无法通过操作达到目标。
- **顿悟感想**：通过构造目标序列，可以将问题转化为简单的数学判断，大大简化了问题的复杂度。

---
处理用时：45.94秒
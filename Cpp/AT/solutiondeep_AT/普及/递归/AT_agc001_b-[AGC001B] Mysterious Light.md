# 题目信息

# [AGC001B] Mysterious Light

## 题目描述

高桥くん有一个边长为 $N$ 的三枚镜子构成的正三角形, 顶点为 $A, B, C$。他有一个超级步枪，放在 $AB$ 段的 $P$ 点上，使得 $AP=X$。这个步枪将会沿着平行于 $BC$ 的方向发射一道光。

光以直线传播，以镜子的形式反射，但是有一个特殊的地方：它会被自己的轨迹反射，当光回到步枪的时候，光被吸收。
下面的图显示了当 $N=5, x=2$ 时的光轨迹。

![avatar](https://cdn.luogu.org/upload/vjudge_pic/AT1980/82d4f7f391403506ac5ef0aff8934e6a17530f07.png)

给定 $N$ 和 $x$，求出光线的总长度。

## 说明/提示

对于所有数据，$2≤N≤10^{12}$，$1≤x≤N-1$，保证 $N, x$ 是整数。

另外，有 $300$ 分的部分分保证 $N \le 1000$。

## 样例 #1

### 输入

```
5 2```

### 输出

```
12```

# AI分析结果

### 题目内容（已翻译）
# [AGC001B] 神秘之光

## 题目描述

高桥有一个由三枚边长为 $N$ 的镜子构成的正三角形，顶点为 $A$、$B$、$C$。他有一把超级步枪，放置在 $AB$ 边上的 $P$ 点，使得 $AP = X$。这把步枪会沿着平行于 $BC$ 的方向发射一道光。

光沿直线传播，并以镜子的形式反射，但有一个特殊之处：它会被自己的轨迹反射，当光回到步枪时，光会被吸收。
下图展示了当 $N = 5$，$x = 2$ 时光的轨迹。

![avatar](https://cdn.luogu.org/upload/vjudge_pic/AT1980/82d4f7f391403506ac5ef0aff8934e6a17530f07.png)

给定 $N$ 和 $x$，求光线的总长度。

## 说明/提示

对于所有数据，$2\leq N\leq 10^{12}$，$1\leq x\leq N - 1$，且 $N$、$x$ 为整数。

另外，有 $300$ 分的部分分保证 $N\leq 1000$。

## 样例 #1

### 输入
```
5 2
```

### 输出
```
12
```

### 综合分析与结论
这些题解主要围绕递归和数学推导两种思路来解决光线长度计算问题。
- **递归思路**：多数题解发现光线反射过程可抽象为平行四边形的递归问题。通过分析平行四边形边长变化规律，依据边长的整除关系分情况计算光线长度，不断将大问题转化为小问题求解。
- **数学推导思路**：部分题解从几何意义出发，发现光线路径与最大公约数的关联，推导出光线总长度的公式 $3\times(n - \gcd(n, x))$。

### 所选题解
- **ztntonny（5星）**
    - **关键亮点**：思路清晰，直接从几何意义出发推导出公式，代码简洁高效。
    - **核心代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
    ll x , n;
    cin >> n >> x;
    cout << 3 * ( n - __gcd ( n , x ) );
    return 0;
}
```
核心实现思想：通过观察光线反射的几何意义，发现光线总长度与最大公约数的关系，直接使用公式 $3\times(n - \gcd(n, x))$ 计算结果。
- **ImmortalWatcher（4星）**
    - **关键亮点**：提供了递归和数学推导两种思路，对数学推导思路的几何意义解释详细。
    - **核心代码**：
```cpp
#include<cstdio>
using namespace std;
long long n,x;
long long gcd(long long x,long long y){return !y?x:gcd(y,x%y);}
int main()
{
    scanf("%lld%lld",&n,&x);
    printf("%lld",3*(n-gcd(n,x)));
    return 0;
}
```
核心实现思想：先通过手玩发现光线路径可拆成等边三角形，再分析边长变化与更相减损术的关系，得出光线总长度公式 $3\times(n - \gcd(n, x))$。
- **wheneveright（4星）**
    - **关键亮点**：递归思路清晰，代码简洁，复杂度参考 `gcd`。
    - **核心代码**：
```cpp
# include <bits/stdc++.h>
using namespace std;

long long f (long long m, long long n) {
    return m == 0 ? -n : n / m * m * 2 + f (n % m, m);
}

int main () {
    long long n, x;
    cin >> n >> x;
    cout << n + f (n - x, x);
    return 0;
}
```
核心实现思想：先确定前两次反射长度为 $n$，然后定义递归函数 $f(m, n)$ 计算后续光线长度，根据反射情况更新递归参数。

### 最优关键思路或技巧
- **几何分析**：通过观察光线反射的几何图形，将问题转化为平行四边形的递归问题或与最大公约数相关的数学问题。
- **递归思想**：利用递归将大问题分解为小问题，通过分析平行四边形边长的变化规律，分情况计算光线长度。

### 可拓展之处
同类型题可能涉及更复杂的几何图形反射问题，或在不同规则下的路径计算问题。类似算法套路可用于解决具有递归性质的几何问题，通过分析图形的变化规律，找到递推关系或数学公式求解。

### 推荐题目
- [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)：涉及数学推导和递归思想。
- [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)：典型的递归问题。
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)：需要运用递归和数学组合知识。

### 个人心得摘录与总结
- **ztntonny**：刚看到图脑子一团乱，自己画了一个，就发现每一条线段的长度变化特别像辗转相除法。总结：遇到复杂图形问题时，自己动手画图分析可能会发现规律。

---
处理用时：34.11秒
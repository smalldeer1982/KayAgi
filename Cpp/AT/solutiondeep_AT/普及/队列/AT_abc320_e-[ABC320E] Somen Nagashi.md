# 题目信息

# [ABC320E] Somen Nagashi

## 题目描述

现有 $N$ 个人排成一队，编号从 $1$ 到 $N$，玩一个叫做“流水面条”的游戏，该游戏共有 $M$ 个事件，每个事件含三个变量 $T_i,W_i,S_i$，事件的规则如下：

- 在 $T_i$ 时刻，有 $W_i$ 根面条流了下来，队头的人拿走这些面条，并离开队列，然后于第 $T_i+S_i$ 时刻返回队列，然后返回他的原始位置。

若队列为空，则该事件忽略。

注意：若他于第 $X$ 时刻返回队列，则视为他第 $X$ 时刻在队列。

一开始每个人都有 $0$ 根面条，现要你求出这 $N$ 个人每个人获得了多少面条。

## 说明/提示

#### 样例#1说明：
第 $1$ 个人于 $1$ 时刻拿走 $1$ 根面条，将于 $4$ 时刻返回队列。

第 $2$ 个人于 $2$ 时刻拿走 $10$ 根面条，将于 $102$ 时刻返回队列。

第 $1$ 个人于 $4$ 时刻归队，返回第 $1$ 位，此时他处于队头，然后拿走 $100$ 根面条，将于 $10004$ 时刻返回队列。

第 $3$ 个人于 $10$ 时刻拿走 $1000$ 根面条，将于第 $1000000010$ 时刻归队。

第 $100$ 时刻，队内无人。

最终，这 $3$ 个人分别有 $101,10,1000$ 根面条。

## 样例 #1

### 输入

```
3 5

1 1 3

2 10 100

4 100 10000

10 1000 1000000000

100 1000000000 1```

### 输出

```
101

10

1000```

## 样例 #2

### 输入

```
3 1

1 1 1```

### 输出

```
1

0

0```

## 样例 #3

### 输入

```
1 8

1 1 1

2 2 2

3 3 3

4 4 4

5 5 5

6 6 6

7 7 7

8 8 8```

### 输出

```
15```

# AI分析结果

### 题目内容重写
现有 $N$ 个人排成一队，编号从 $1$ 到 $N$，玩一个叫做“流水面条”的游戏，该游戏共有 $M$ 个事件，每个事件含三个变量 $T_i,W_i,S_i$，事件的规则如下：

- 在 $T_i$ 时刻，有 $W_i$ 根面条流了下来，队头的人拿走这些面条，并离开队列，然后于第 $T_i+S_i$ 时刻返回队列，然后返回他的原始位置。

若队列为空，则该事件忽略。

注意：若他于第 $X$ 时刻返回队列，则视为他第 $X$ 时刻在队列。

一开始每个人都有 $0$ 根面条，现要你求出这 $N$ 个人每个人获得了多少面条。

### 题解分析与结论

#### 题解思路对比
1. **优先队列维护**：大多数题解使用了两个优先队列，一个维护当前在队列中的人（按编号排序），另一个维护离开队列的人及其返回时间（按时间排序）。这种思路清晰且高效，时间复杂度为 $O((N+M)\log N)$。
2. **线段树维护**：部分题解使用了线段树来维护当前在队列中的人，通过二分查找来确定队首的人。这种思路虽然也能解决问题，但实现复杂度较高，且时间复杂度与优先队列方法相近。
3. **模拟思路**：部分题解采用模拟的思路，通过维护两个队列来模拟人的进出过程。这种思路较为直观，但代码实现可能较为繁琐。

#### 最优思路总结
最优的思路是使用两个优先队列，分别维护当前在队列中的人和离开队列的人及其返回时间。这种思路不仅代码简洁，而且时间复杂度较低，适合处理大规模数据。

#### 关键实现技巧
1. **优先队列的使用**：通过优先队列可以高效地找到当前在队列中的人以及最早返回队列的人。
2. **事件处理顺序**：在处理事件时，先处理返回队列的人，再处理新的事件，确保队列状态的正确性。

### 评分较高的题解

#### 1. 作者：robertuu (5星)
- **关键亮点**：使用两个优先队列分别维护事件和队列中的人，代码简洁且高效。
- **代码核心**：
  ```cpp
  priority_queue<noddle> q;
  priority_queue<int,vector<int>,greater<int>> l;
  while(!q.empty()) {
      noddle tmp = q.top();
      q.pop();
      if(tmp.s == 0) l.push(tmp.w); // 归队
      else if(!l.empty()) { // 出现物品
          ans[l.top()] += tmp.w;
          q.push((noddle){tmp.t+tmp.s,l.top(),0});
          l.pop();
      }
  }
  ```

#### 2. 作者：OldDriverTree (4.5星)
- **关键亮点**：使用两个优先队列分别维护当前在队列中的人和离开队列的人，思路清晰，代码简洁。
- **代码核心**：
  ```cpp
  priority_queue<int,vector<int>,greater<int> > p;
  priority_queue<P,vector<P>,greater<P> > q;
  while (m--) {
      int t,w,s; scanf("%d%d%d",&t,&w,&s);
      while (!q.empty()&&q.top().first<=t) p.push(q.top().second),q.pop();
      if (!p.empty() ) a[p.top()]+=w,q.push({t+s,p.top()}),p.pop();
  }
  ```

#### 3. 作者：Fire_flame (4星)
- **关键亮点**：使用两个优先队列分别维护事件和等待队列，思路清晰，代码简洁。
- **代码核心**：
  ```cpp
  priority_queue<node>pq, pq3;
  priority_queue<int, vector<int>, greater<int> >pq2;
  while(!pq3.empty() && pq3.top().x <= pq.top().x){
      pq2.push(pq3.top().id);
      pq3.pop();
  }
  if(!pq2.empty()){
      ans[pq2.top()] += pq.top().y;
      pq3.push({pq.top().x + pq.top().z, 0, 0, pq2.top()});
      pq2.pop();
  }
  ```

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3378 堆](https://www.luogu.com.cn/problem/P3378)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得
- **调试经历**：在处理事件时，确保先处理返回队列的人，再处理新的事件，否则会导致队列状态错误。
- **踩坑教训**：在使用优先队列时，注意比较函数的定义，确保队列中的元素按预期顺序排列。

---
处理用时：34.39秒
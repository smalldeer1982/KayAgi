# 题目信息

# [ABC376E] Max × Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_e

長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N),\ B\ =\ (B_1,\ B_2,\ \dots,\ B_N) $ が与えられます。  
$ \lbrace\ 1,\ 2,\ \dots,\ N\ \rbrace $ の部分集合であって大きさが $ K $ のものを $ 1 $ つ選び $ S $ とします。この時、以下の式の値としてあり得る最小値を求めてください。

$ \displaystyle\ \left(\max_{i\ \in\ S}\ A_i\right)\ \times\ \left(\sum_{i\ \in\ S}\ B_i\right) $ 

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^6 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数

### Sample Explanation 1

$ 1 $ 番目のテストケースでは、$ S\ =\ \lbrace\ 2,\ 3\ \rbrace $ を選ぶと式の値が $ 7\ \times\ (2\ +\ 4)\ =\ 42 $ になり、これが最小です。

## 样例 #1

### 输入

```
3
3 2
3 7 6
9 2 4
5 3
6 4 1 5 9
8 6 5 1 7
10 6
61 95 61 57 69 49 46 47 14 43
39 79 48 92 90 76 30 16 30 94```

### 输出

```
42
60
14579```

# AI分析结果

### 题目内容重写（中文）

**题目描述**

给定两个长度为 $N$ 的数列 $A = (A_1, A_2, \dots, A_N)$ 和 $B = (B_1, B_2, \dots, B_N)$。从集合 $\{1, 2, \dots, N\}$ 中选出一个大小为 $K$ 的子集 $S$，求以下表达式的最小值：

$$
\left(\max_{i \in S} A_i\right) \times \left(\sum_{i \in S} B_i\right)
$$

**输入格式**

- 第一行包含一个整数 $T$，表示测试用例的数量。
- 每个测试用例的第一行包含两个整数 $N$ 和 $K$。
- 接下来两行分别包含 $N$ 个整数，表示数列 $A$ 和 $B$。

**输出格式**

对于每个测试用例，输出一个整数，表示表达式的最小值。

**样例输入**

```
3
3 2
3 7 6
9 2 4
5 3
6 4 1 5 9
8 6 5 1 7
10 6
61 95 61 57 69 49 46 47 14 43
39 79 48 92 90 76 30 16 30 94
```

**样例输出**

```
42
60
14579
```

### 题解分析与结论

该题的核心在于如何高效地找到满足条件的子集 $S$，使得表达式的值最小。题解中普遍采用了排序和优先队列（堆）的思路，通过枚举最大值并动态维护前 $K-1$ 个最小的 $B_i$ 来优化计算。

### 精选题解

#### 题解1：作者：yszkddzyh（评分：5星）

**关键亮点：**
- 详细解释了排序和优先队列的使用，思路清晰。
- 通过维护前 $K-1$ 个最小的 $B_i$ 来优化计算，避免了重复排序。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
sort(a, a + n); // 按 A_i 排序
priority_queue<int> q; // 大根堆
int sum = 0;
for (int i = 0; i < k; i++) {
    q.push(a[i].b);
    sum += a[i].b;
}
int ans = sum * a[k - 1].a;
for (int i = k; i < n; i++) {
    q.push(a[i].b);
    sum += a[i].b;
    sum -= q.top();
    q.pop();
    ans = min(ans, sum * a[i].a);
}
```

#### 题解2：作者：mysterys（评分：4星）

**关键亮点：**
- 通过优先队列动态维护前 $K$ 个最小的 $B_i$，思路清晰。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
sort(a + 1, a + n + 1); // 按 A_i 排序
priority_queue<int> q; // 大根堆
int sum = 0;
for (int i = 1; i <= k; i++) {
    q.push(a[i].b);
    sum += a[i].b;
}
int ans = sum * a[k].a;
for (int i = k + 1; i <= n; i++) {
    q.push(a[i].b);
    sum += a[i].b;
    sum -= q.top();
    q.pop();
    ans = min(ans, sum * a[i].a);
}
```

#### 题解3：作者：Ad_lqz_ht（评分：4星）

**关键亮点：**
- 通过优先队列动态维护前 $K$ 个最小的 $B_i$，思路清晰。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
sort(p + 1, p + n + 1); // 按 A_i 排序
priority_queue<int> q; // 大根堆
int sum = 0;
for (int i = 1; i <= k; i++) {
    q.push(p[i].b);
    sum += p[i].b;
}
int ans = sum * p[k].a;
for (int i = k + 1; i <= n; i++) {
    q.push(p[i].b);
    sum += p[i].b;
    sum -= q.top();
    q.pop();
    ans = min(ans, sum * p[i].a);
}
```

### 最优关键思路与技巧

1. **排序与枚举最大值**：将数组按 $A_i$ 排序后，枚举每个 $A_i$ 作为最大值，从而将问题转化为在前 $i$ 个元素中选择前 $K$ 个最小的 $B_i$。
2. **优先队列（堆）优化**：通过大根堆动态维护前 $K$ 个最小的 $B_i$，避免重复排序，提升效率。
3. **贪心思想**：在枚举最大值时，优先选择前 $K$ 个最小的 $B_i$，确保表达式的值最小。

### 可拓展之处

- **类似问题**：可以扩展到其他需要动态维护前 $K$ 个最小或最大值的问题，如滑动窗口中的最小值、最大值等。
- **数据结构**：优先队列（堆）在处理动态维护前 $K$ 个最小或最大值的问题时非常高效，可以广泛应用于其他类似问题。

### 推荐题目

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P3378 堆](https://www.luogu.com.cn/problem/P3378)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

### 个人心得摘录

- **调试经历**：在维护优先队列时，需要注意队列的大小，避免超出 $K$ 个元素，否则会导致计算结果错误。
- **踩坑教训**：在排序时，确保 $A_i$ 和 $B_i$ 的对应关系不被破坏，否则会导致错误的结果。
- **顿悟感想**：通过优先队列动态维护前 $K$ 个最小或最大值，可以大大简化问题的复杂度，提升代码的效率。

---
处理用时：47.82秒
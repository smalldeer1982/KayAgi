# 题目信息

# [ABC377D] Many Segments 2

## 题目描述

给定长度为 $N$ 的正整数列 $L=(L_1,L_2,\ldots,L_N),R=(R_1,R_2,\ldots,R_N)$ 和整数 $M$。

求同时满足以下条件的整数组 $(l,r)$ 的个数。

- $1\le l\le r\le M$

- 对于所有 $1\le i\le N$，区间 $[l,r]$ 不完全包含区间 $\left[L_i,R_i\right]$。

## 说明/提示

#### 约定

- $1\le N,M\le 2\times 10^5$
- $1\le L_i\le R_i\le M$
- 所有输入均为整数


 $(l,r)=(1,1),(2,2),(2,3),(3,3),(4,4)$ 这 $5$ 个都满足条件。

例如 $(l,r)=(1,3)$ 不满足条件。这是因为区间 $[1,3]$ 完全包含了区间 $[1,2]$。


此时不存在满足条件的整数对。


Translation by @[$\frak{Lorentz}$](/user/1232305) and @[Jie_XuSheng](/user/1332013)。

## 样例 #1

### 输入

```
2 4

1 2

3 4```

### 输出

```
5```

## 样例 #2

### 输入

```
6 5

1 1

2 2

3 3

4 4

5 5

1 5```

### 输出

```
0```

## 样例 #3

### 输入

```
6 20

8 12

14 20

11 13

5 19

4 11

1 6```

### 输出

```
102```

# AI分析结果

### 题目内容重写
【题目描述】  
给定长度为 $N$ 的正整数列 $L=(L_1,L_2,\ldots,L_N), R=(R_1,R_2,\ldots,R_N)$ 和整数 $M$。  
求同时满足以下条件的整数组 $(l,r)$ 的个数。  
- $1\le l\le r\le M$  
- 对于所有 $1\le i\le N$，区间 $[l,r]$ 不完全包含区间 $\left[L_i,R_i\right]$。

【说明/提示】  
#### 约定  
- $1\le N,M\le 2\times 10^5$  
- $1\le L_i\le R_i\le M$  
- 所有输入均为整数  

【样例 #1】  
输入：  
```
2 4
1 2
3 4
```  
输出：  
```
5
```  

【样例 #2】  
输入：  
```
6 5
1 1
2 2
3 3
4 4
5 5
1 5
```  
输出：  
```
0
```  

【样例 #3】  
输入：  
```
6 20
8 12
14 20
11 13
5 19
4 11
1 6
```  
输出：  
```
102
```

---

### 题解综合分析与结论
本题的核心在于如何高效地统计满足条件的区间 $(l,r)$。大多数题解通过维护最大左端点或最小右端点来优化计算，避免了直接枚举所有可能的 $(l,r)$ 组合。以下是各题解的主要思路和优化点：

1. **前缀最大值法**：通过维护每个右端点 $r$ 对应的最小左端点 $a_r$，利用前缀最大值快速计算满足条件的区间数。时间复杂度为 $O(N + M)$。
2. **堆维护法**：使用优先队列（堆）动态维护当前右端点的最小左端点，适合处理动态更新的情况。时间复杂度为 $O(N \log N)$。
3. **线段树法**：通过线段树维护区间的最小值，适合处理更复杂的区间查询和更新操作。时间复杂度为 $O(N \log M)$。

最优思路是**前缀最大值法**，因其时间复杂度最低且实现简单。

---

### 评分较高的题解

#### 题解1：__ATRI__ (5星)
**关键亮点**：
- 使用前缀最大值法，时间复杂度 $O(N + M)$，效率高。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
for (int i = 1; i <= m; i++) a[i] = 1;
for (int i = 1, l, r; i <= n; ++i) {
    cin >> l >> r;
    a[r] = max(a[r], l + 1);
}
for (int i = 1; i <= m; i++) a[i] = max(a[i], a[i - 1]);
for (int i = 1; i <= m; i++) ans += i - a[i] + 1;
```
**实现思想**：  
通过维护每个右端点 $r$ 的最小左端点 $a_r$，利用前缀最大值快速计算满足条件的区间数。

---

#### 题解2：MoonCake2011 (4星)
**关键亮点**：
- 直接枚举右端点，动态维护最大左端点，思路直观。
- 代码简洁，适合初学者理解。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) mx[r[i]] = max(mx[r[i]], l[i]);
int ans = 0, ml = 0;
for (int r = 1; r <= m; r++) ml = max(ml, mx[r]), ans += r - ml;
```
**实现思想**：  
通过维护每个右端点 $r$ 的最大左端点 $ml$，直接计算满足条件的区间数。

---

#### 题解3：sherry_lover (4星)
**关键亮点**：
- 使用后缀最小值法，避免直接枚举，时间复杂度 $O(N + M)$。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
for (int i = 1; i <= n; i++) ans[a[i].l] = min(ans[a[i].l], a[i].r);
for (int i = m; i >= 1; i--) ans[i] = min(ans[i], ans[i + 1]);
for (int i = 1; i <= m; i++) tot += (ans[i] - i);
```
**实现思想**：  
通过维护每个左端点 $l$ 的最小右端点 $ans_l$，利用后缀最小值快速计算满足条件的区间数。

---

### 最优关键思路
**前缀最大值法**：  
通过维护每个右端点 $r$ 的最小左端点 $a_r$，利用前缀最大值快速计算满足条件的区间数。该方法时间复杂度低，实现简单，是本题的最优解法。

---

### 拓展思路
- **类似问题**：处理区间覆盖、区间交集等问题时，可以借鉴前缀最大值或后缀最小值的思路。
- **数据结构**：优先队列、线段树等数据结构在处理动态区间问题时非常有用。

---

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
2. [P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)  
3. [P5490 扫描线](https://www.luogu.com.cn/problem/P5490)  

---

### 个人心得摘录
- **调试经历**：在处理边界条件时，需特别注意 $l$ 和 $r$ 的取值范围，避免越界。
- **踩坑教训**：直接枚举所有 $(l,r)$ 组合会导致超时，必须优化计算方式。
- **顿悟感想**：通过维护前缀最大值或后缀最小值，可以大幅减少计算量，提高效率。

---
处理用时：42.93秒
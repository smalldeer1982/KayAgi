# 题目信息

# [ABC312Ex] snukesnuke

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc312/tasks/abc312_h

高橋君は人 $ 1,\ldots,N $ の $ N $ 人のあだ名を決めることになりました。

人 $ i $ はあだ名を $ S_i $ にしてほしいと思っています。複数人に同じあだ名をつけるのを避けるため、高橋君は次の手順で $ N $ 人のあだ名を決めることにしました。

- $ i=1,\ldots,N $ の順に、以下の操作により人 $ i $ のあだ名を決める
  - 変数 $ k_i $ を $ 1 $ とする。
  - 「$ S_i $ を $ k_i $ 回繰り返した文字列」がすでに誰かのあだ名である間、$ k_i $ を $ 1 $ 増やすことを繰り返す。
  - 「$ S_i $ を $ k_i $ 回繰り返した文字列」を人 $ i $ のあだ名とする。
 
$ N $ 人のあだ名を決めた後の $ k_1,\ldots,k_N $ を求めてください。

## 说明/提示

### 制約

- $ N\ \geq\ 1 $
- $ S_i $ は英小文字のみからなる、長さ $ 1 $ 以上の文字列
- $ S_i $ の長さの総和は $ 2\times\ 10^5 $ 以下
 
### Sample Explanation 1

\- まず人 $ 1 $ のあだ名を決めます。 - $ k_1=1 $ とします。 - $ S_1 $ を $ k_1 $ 回繰り返した文字列 `snuke` は誰のあだ名でもないので、人 $ 1 $ のあだ名は `snuke` になります。 - 次に人 $ 2 $ のあだ名を決めます。 - $ k_2=1 $ とします。 - $ S_2 $ を $ k_2 $ 回繰り返した文字列 `snuke` はすでに人 $ 1 $ のあだ名なので、$ k_2 $ を $ 1 $ 増やして $ 2 $ とします。 - $ S_2 $ を $ k_2 $ 回繰り返した文字列 `snukesnuke` は誰のあだ名でもないので、人 $ 2 $ のあだ名は `snukesnuke` になります。 - 最後に人 $ 3 $ のあだ名を決めます。 - $ k_3=1 $ とします。 - $ S_3 $ を $ k_3 $ 回繰り返した文字列 `rng` は誰のあだ名でもないので、人 $ 3 $ のあだ名は `rng` になります。 以上により、$ k_1,k_2,k_3 $ はそれぞれ $ 1,2,1 $ となります。

### Sample Explanation 2

\- 人 $ 1 $ のあだ名は `aa` になります。 - 人 $ 2 $ のあだ名は `a` になります。 - 人 $ 3 $ のあだ名は、`a`, `aa` がすでに他の人のあだ名なので、`aaa` になります。 - 人 $ 4 $ のあだ名は、`aaa` がすでに他の人のあだ名なので、`aaaaaa` になります。

## 样例 #1

### 输入

```
3

snuke

snuke

rng```

### 输出

```
1 2 1```

## 样例 #2

### 输入

```
4

aa

a

a

aaa```

### 输出

```
1 1 3 2```

## 样例 #3

### 输入

```
5

x

x

x

x

x```

### 输出

```
1 2 3 4 5```

# AI分析结果



### 唯一算法分类
**字符串处理 + 哈希表 + 贪心**

---

### 综合分析与结论
**核心思路**  
题目要求为每个字符串 $S_i$ 找到最小的 $k_i$，使得 $S_i$ 重复 $k_i$ 次后的字符串未被使用过。关键在于以下三点：
1. **循环节提取**：利用 KMP 算法求出每个字符串的最小循环节 $t_i$，将其转化为 $t_i$ 的重复次数 $sk_i$。
2. **分类管理**：将循环节相同的字符串归为一类，记录每类已使用的倍数（$k_i \times sk_i$）。
3. **贪心优化**：对每个循环节类别，记录当前尝试的倍数起点，避免重复检查，保证时间复杂度为 $O(n \log n)$。

**难点与解决**  
- **循环节冲突**：不同字符串重复多次后可能相同，需通过循环节分类解决。
- **高效查询**：通过哈希表记录每个循环节的倍数使用情况，并维护当前尝试的起点，避免从头遍历。

**可视化设计**  
1. **动画流程**  
   - **步骤1**：字符串展开为循环节 $t_i$ 和重复次数 $sk_i$（高亮循环节部分）。
   - **步骤2**：在对应循环节类别的“已用倍数列表”中，动态尝试 $k=1,2,3...$（红色闪烁当前尝试的 $k$，绿色标记成功）。
   - **步骤3**：将成功后的 $k \times sk_i$ 加入列表（列表颜色块增长）。

2. **复古像素风格**  
   - **颜色方案**：循环节类别用不同色块（如黄色、蓝色），当前操作用红色高亮，成功时绿色闪烁。
   - **音效**：尝试时播放“滴”声，成功时播放“叮”声，背景为 8-bit 循环音乐。
   - **Canvas 绘制**：网格显示每个循环节类别的已用倍数，类似俄罗斯方块堆积。

---

### 题解清单（≥4星）
1. **hzlqwq（5星）**  
   - **亮点**：KMP 预处理循环节，哈希表分类，贪心优化倍数查询，代码简洁高效。
2. **liangbowen（4星）**  
   - **亮点**：思路清晰，强调记忆化加速，时间复杂度分析到位。
3. **__vector__（4星）**  
   - **亮点**：字典树优化字符串存储，避免重复构造，代码实现巧妙。

---

### 最优代码片段
```cpp
// 核心逻辑：KMP 求循环节，哈希表管理倍数查询
void kmp(int x) {
    for (int i=1, j=0; i<s[x].size(); ++i) {
        while (j && s[x][i] != s[x][j]) j = ne[j-1];
        if (s[x][i] == s[x][j]) j++;
        ne[i] = j;
    }
    int n = s[x].size();
    len[x] = (n % (n - ne[n-1]) == 0) ? (n - ne[n-1]) : n;
    sk[x] = n / len[x];
    cir[x] = s[x].substr(0, len[x]);
}

// 主处理逻辑
for (int i=1; i<=n; ++i) {
    int tmp = id[cir[i]]; // 获取循环节类别
    while (mex[tmp].count(++jmp[tmp][sk[i]] * sk[i])) {} // 贪心找最小k
    cout << jmp[tmp][sk[i]] << " ";
    mex[tmp].insert(jmp[tmp][sk[i]] * sk[i]);
}
```

---

### 相似题目推荐
1. **P3375**（KMP 模板题）  
2. **P1368**（最小循环节应用）  
3. **CF1200E**（哈希处理字符串拼接）

---

### 可视化算法演示
**动画步骤**  
1. **循环节提取**：字符串展开，红色标记循环节 $t_i$，显示 `sk_i=2`（表示由 $t_i$ 重复2次组成）。
2. **倍数查询**：在对应类别的“已用倍数”列表中，红色指针从1开始右移，直到找到第一个绿色空缺（如 `3`）。
3. **更新状态**：绿色方块插入列表，显示当前答案 `k=3`。

**交互设计**  
- **暂停/继续**：观察每个字符串处理细节。
- **速度调节**：快进到关键步骤（如冲突解决）。
- **音效反馈**：不同操作对应不同音效，增强沉浸感。

---

通过上述分析，核心在于将问题拆解为循环节分类和贪心查询，结合哈希表优化实现高效处理。

---
处理用时：140.65秒
# 题目信息

# [ABC346F] SSttrriinngg in StringString

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc346/tasks/abc346_f

長さ $ n $ の文字列 $ X $ に対して、$ X $ を $ k $ 回繰り返して得られる文字列を $ f(X,k) $ と表記し、$ X $ の $ 1 $ 文字目、$ 2 $ 文字目、$ \dots $、$ n $ 文字目を $ k $ 回ずつこの順に繰り返して得られる文字列を $ g(X,k) $ と表記します。 例えば、$ X= $ `abc` のとき、$ f(X,2)= $ `abcabc`、$ g(X,3)= $ `aaabbbccc` です。 また、任意の文字列 $ X $ に対して、$ f(X,0) $ と $ g(X,0) $ は共に空文字列です。

正整数 $ N $ および文字列 $ S,T $ が与えられます。 $ g(T,k) $ が $ f(S,N) $ の（連続とは限らない）部分列であるような最大の非負整数 $ k $ を求めてください。 なお、定義より、$ g(T,0) $ は常に $ f(S,N) $ の部分列であることに注意してください。

部分列とは文字列 $ X $ の（連続とは限らない）部分列とは、$ X $ から $ 0 $ 個以上の文字を取り除いた後、残りの文字を元の順序で連結して得られる文字列のことをいいます。 例えば、`ac`、`atcoder`、` `（空文字列）などはどれも `atcoder` の部分列ですが、`ta` は `atcoder` の部分列ではありません。

## 说明/提示

### 制約

- $ N $ は整数
- $ 1\leq\ N\leq\ 10^{12} $
- $ S,\ T $ は英小文字からなる長さ $ 1 $ 以上 $ 10^5 $ 以下の文字列

### Sample Explanation 1

$ f(S,3)= $ `abcabcabc` です。 $ g(T,2)= $ `aabb` は $ f(S,3) $ の部分列ですが、$ g(T,3)= $ `aaabbb` は $ f(S,3) $ の部分列ではないので、$ 2 $ を出力します。

## 样例 #1

### 输入

```
3
abc
ab```

### 输出

```
2```

## 样例 #2

### 输入

```
3
abc
arc```

### 输出

```
0```

## 样例 #3

### 输入

```
1000000000000
kzazkakxkk
azakxk```

### 输出

```
344827586207```

# AI分析结果



### 算法分类
**二分**

---

### 题解思路与算法要点
#### 核心思路
1. **二分答案**：答案具有单调性，若 `k` 可行则所有 `k' ≤ k` 均可行。二分范围初始为 `[0, N*|S|/|T|]`。
2. **预处理**：统计每个字符在 `S` 中的出现次数和位置，用于快速计算每个字符的匹配过程。
3. **贪心匹配**：对于每个 `T` 的字符，计算其在 `f(S,N)` 中的最小匹配路径，累加所需 `S` 的循环次数。

#### 解决难点
1. **高效判断 `k` 的可行性**：
   - 预处理每个字符的累计出现次数和后缀信息。
   - 分三段处理：当前 `S` 的剩余部分、完整 `S` 的循环次数、剩余未匹配的字符。
2. **大数处理**：避免整数溢出，使用 `long long` 类型，合理压缩二分区间。
3. **边界条件**：处理 `k=0` 的特殊情况，以及 `T` 中存在 `S` 未包含字符时的快速返回。

---

### 题解评分（≥4星）
1. **KSCD_（5星）**  
   - **亮点**：预处理字符位置数组，逻辑清晰，代码可读性高，直接模拟贪心匹配过程，合理压缩二分上界。
   - **关键代码**：
     ```cpp
     bool check(int x) {
         int cnt = 0, lpos = ls; // cnt为所需S的循环次数，lpos为当前S的位置
         for (int i=0; i<lt; i++) {
             int tc = t[i]-'a', ts = x;
             // 处理当前S剩余部分
             if (ts <= a[lpos][tc]) {
                 lpos = pos[tc][a[0][tc] - a[lpos][tc] + ts -1] +1;
             } else {
                 ts -= a[lpos][tc];
                 cnt += ts / a[0][tc]; // 完整循环次数
                 ts %= a[0][tc];
                 // 处理余数
             }
         }
         return cnt <= n;
     }
     ```
2. **2huk（4星）**  
   - **亮点**：维护 `x`（当前 `S` 的循环次数）和 `y`（当前字符位置），逻辑简洁。
   - **优化**：避免二分嵌套，直接线性遍历 `T` 的每个字符。
3. **Milthm（4星）**  
   - **亮点**：利用前缀和数组快速计算字符数量，二分查找位置。
   - **注意**：可能因多次二分导致常数较大，但代码结构清晰。

---

### 最优思路提炼
1. **二分框架**：初始区间 `[0, N*|S|/|T|]`，逐步收缩。
2. **字符预处理**：统计每个字符在 `S` 中的出现次数和所有位置。
3. **分段匹配**：
   - **当前循环剩余部分**：直接匹配尽可能多的字符。
   - **完整循环次数**：利用除法计算需要多少完整的 `S` 循环。
   - **余数处理**：在最后一个循环中找到剩余字符的位置。
4. **边界剪枝**：若 `T` 中存在 `S` 未包含的字符，直接返回 `0`。

---

### 类似算法套路
- **二分答案**：常用于求极值的题目（如最大值最小化、最小值最大化）。
- **贪心匹配**：在子序列问题中，利用预处理信息快速计算路径。
- **前缀和优化**：通过预处理加速区间查询。

---

### 推荐题目
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分答案）
2. [P4343 自动刷题机](https://www.luogu.com.cn/problem/P4343)（二分答案与模拟）
3. [CF702C Cellular Network](https://codeforces.com/problemset/problem/702/C)（二分答案与贪心）

---

### 个人心得摘录
- **KSCD_**：注意预处理字符位置数组，避免在循环中重复计算。
- **HNOIRPplusplus**：余数处理时需确保整除和位置更新的正确性。
- **small_john**：二分时初始区间不宜过大，否则可能溢出。

---

### 可视化设计
#### 动画方案
1. **区间展示**：以像素网格表示二分区间 `[left, right]`，高亮当前 `mid`。
2. **颜色标记**：
   - **红色**：当前 `mid` 被检查。
   - **绿色**：`mid` 可行，收缩左区间。
   - **黄色**：`mid` 不可行，收缩右区间。
3. **步进控制**：用户可单步执行或自动播放，观察区间收缩过程。
4. **音效反馈**：
   - 每次更新 `mid` 时播放短音效。
   - 找到答案时播放胜利音效。

#### 复古像素风格
- **Canvas 绘制**：用 8-bit 风格绘制区间网格，每次收缩区间时更新方块颜色。
- **音效**：使用芯片音乐模拟器生成 8-bit 音效。
- **自动演示**：AI 自动执行二分逻辑，每步间隔 1 秒。

---

### 核心代码实现（KSCD_）
```cpp
bool check(int x) {
    int cnt = 0, lpos = ls; // cnt为所需S的循环次数，lpos为当前S的位置
    for (int i = 0; i < lt; i++) {
        int tc = t[i] - 'a', ts = x;
        if (ts <= a[lpos][tc]) {
            lpos = pos[tc][a[0][tc] - a[lpos][tc] + ts - 1] + 1;
        } else {
            ts -= a[lpos][tc];
            cnt += ts / a[0][tc];
            ts %= a[0][tc];
            if (ts) {
                cnt++;
                lpos = pos[tc][ts - 1] + 1;
            } else {
                lpos = pos[tc][a[0][tc] - 1] + 1;
            }
        }
        if (cnt > n) return false;
    }
    return cnt <= n;
}
```

---
处理用时：115.29秒
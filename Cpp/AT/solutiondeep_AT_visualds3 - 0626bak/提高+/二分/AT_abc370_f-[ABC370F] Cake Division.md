# 题目信息

# [ABC370F] Cake Division

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc370/tasks/abc370_f

円形のケーキがあり、ケーキは切り目によって $ N $ 個のピースに分けられています。各切り目は円の中心と円弧上の点を結ぶ線分です。

ピースおよび切り目には時計回りに $ 1,\ 2,\ \ldots,\ N $ の番号が付けられており、ピース $ i $ の質量は $ A_i $ です。ピース $ 1 $ をピース $ N\ +\ 1 $ とも呼ぶこととします。

切り目 $ i $ は ピース $ i $ とピース $ i\ +\ 1 $ の間にあり、ピース $ 1 $, 切り目 $ 1 $, ピース $ 2 $, 切り目 $ 2 $, $ \ldots $, ピース $ N $, 切り目 $ N $ の順に時計回りに並んでいます。

このケーキを以下の条件を満たすように $ K $ 人に分けようとしています。ただし、$ i $ 番目の人が受け取るピースの質量の合計を $ w_i $ とします。

- すべての人が $ 1 $ つ以上の**連続する**ピースを受け取る
- 誰も受け取らないピースは存在しない
- 上の $ 2 $ つの条件を満たすという条件下で $ \min(w_1,\ w_2,\ \ldots,\ w_K) $ が最大になるようにする
 
条件を満たす分け方における $ \min(w_1,\ w_2,\ \ldots,\ w_K) $ の値および条件を満たすすべての分け方で切られることのない切り目の個数を求めてください。ただし、切り目 $ i $ が切られるとは、ピース $ i $ とピース $ i\ +\ 1 $ が異なる人に分けられることを指します。

## 说明/提示

### 制約

- $ 2\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^4 $
- 入力される値はすべて整数
 
### Sample Explanation 1

以下の分け方が条件を満たします。 - 一方の人にピース $ 2,\ 3 $ を渡し、もう一方の人にピース $ 4,\ 5,\ 1 $ を渡す。ピース $ 2,\ 3 $ の質量の合計は $ 14 $、ピース $ 4,\ 5,\ 1 $ の質量の合計は $ 13 $ である。 - 一方の人にピース $ 3,\ 4 $ を渡し、もう一方の人にピース $ 5,\ 1,\ 2 $ を渡す。ピース $ 3,\ 4 $ の質量の合計は $ 14 $、ピース $ 5,\ 1,\ 2 $ の質量の合計は $ 13 $ である。 条件を満たす分け方における $ \min(w_1,\ w_2) $ の値は $ 13 $ であり、どちらの分け方でも切られない切り目は切り目 $ 5 $ の $ 1 $ つです。

## 样例 #1

### 输入

```
5 2

3 6 8 6 4```

### 输出

```
13 1```

## 样例 #2

### 输入

```
6 3

4 7 11 3 9 2```

### 输出

```
11 1```

## 样例 #3

### 输入

```
10 3

2 9 8 1 7 9 1 3 5 8```

### 输出

```
17 4```

# AI分析结果



**唯一算法分类**  
二分

---

**综合分析与结论**  
本题核心是二分答案结合倍增法处理环形分割问题。关键步骤如下：

1. **二分答案**：通过二分确定最大可保证的最小段和mid。初始区间设为[0, sum(A)]。
2. **环形处理**：将数组复制为双倍长度，转化为线性结构。
3. **双指针预处理**：对每个位置i，找到最小的j使得sum[i..j]≥mid，存储为跳跃点。
4. **倍增法优化**：构建跳跃表，快速模拟K次分割操作。
5. **可行性检查**：枚举起点，用倍增表判断能否在K次跳跃后覆盖整个环。
6. **统计未使用分割线**：在最优mid下，再次遍历所有起点，统计无法作为分割点的数量。

**可视化设计思路**：
- **动画演示**：展示二分区间[left, right]的变化，高亮mid计算与条件判断。
- **跳跃模拟**：用不同颜色标记跳跃步数，展示倍增表对跳跃次数的优化。
- **环形展开**：用Canvas绘制环形蛋糕展开为双倍链的过程，动态显示分割点的跳跃路径。

---

**题解清单 (≥4星)**  
1. **lfxxx_ (4.5星)**  
   关键亮点：清晰的双指针预处理+倍增跳跃，代码简洁高效。使用二进制分解K的处理方式优化跳跃次数。

2. **沉石鱼惊旋 (4星)**  
   亮点：详细解释倍增表的构建过程，可视化分割点跳跃逻辑，代码注释清晰。

3. **I_AK_IoI_2030 (4星)**  
   创新点：采用动态规划思想预处理分段，结合双指针优化检查过程，思路独特。

---

**代码核心实现**  
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n,K,a[N],sum[N],dp[N][21],f[N];

void init(int mid) { // 双指针预处理跳跃点
    int j=0;
    for(int i=1;i<=n*2;++i) {
        while(j<n*2 && sum[j]-sum[i-1]<mid) ++j;
        dp[i][0] = j+1; // 跳跃到j+1的位置
    }
    dp[n*2+1][0] = n*2+1; // 边界处理
}

bool check(int mid) {
    init(mid);
    // 构建倍增表
    for(int j=1;j<=20;++j)
        for(int i=1;i<=2*n+1;++i)
            dp[i][j] = dp[dp[i][j-1]][j-1];
    
    bool flag=0;
    for(int i=1;i<=n;++i) { // 枚举起点
        int pos=i;
        for(int j=20;j>=0;--j) // 二进制分解K
            if(K&(1<<j)) pos = dp[pos][j];
        if(pos <= i+n) flag=1; // 仍在环内则可行
    }
    return flag;
}

signed main() {
    cin>>n>>K;
    for(int i=1;i<=n;++i) cin>>a[i], sum[i]=sum[i-1]+a[i];
    for(int i=n+1;i<=n*2;++i) a[i]=a[i-n], sum[i]=sum[i-1]+a[i];
    
    int l=0, r=2e9+1;
    while(l+1<r) { // 二分答案
        int mid=(l+r)>>1;
        if(check(mid)) l=mid;
        else r=mid;
    }
    
    check(l); // 最终确定未使用分割线
    int ans=0;
    for(int i=1;i<=n;++i) {
        int pos=i;
        for(int j=20;j>=0;--j)
            if(K&(1<<j)) pos=dp[pos][j];
        if(pos>i+n) ++ans; // 统计未使用的分割线
    }
    cout<<l<<' '<<ans;
}
```

---

**同类型题推荐**  
1. P2678 跳石头（二分答案经典题）
2. P4344 [SHOI2015] 脑洞治疗仪（二分+线段树）
3. P3199 [HNOI2010] 平面图判定（环形结构处理）

---

**个人心得摘录**  
- **调试教训**：初始右边界过小导致WA，需注意总和可能达到2e9级别。
- **思维突破**：将环形分割转化为线性跳跃问题，倍增法大幅优化时间复杂度。

---

**可视化与游戏化设计**  
采用8位像素风格演示二分过程：
1. **Canvas网格**：横向展示[left, right]区间，mid用闪烁像素点标记。
2. **音效触发**：每次更新mid时播放"beep"声，找到解时播放胜利音效。
3. **自动演示模式**：AI自动执行二分步骤，用户可暂停观察跳跃路径。  
4. **积分系统**：正确收缩区间获得积分，错误选择播放失败音效。

**关键JS片段**  
```javascript
// 模拟二分动画
function animateBinary(l, r, mid, result) {
    ctx.fillStyle = '#8B0000'; // 深红背景
    ctx.fillRect(l*10, 0, (r-l)*10, 50);
    ctx.fillStyle = '#00FF00'; // 绿色mid
    ctx.fillRect(mid*10, 0, 10, 50);
    if(result) playSound('success.wav');
}
```

---
处理用时：87.01秒
# 题目信息

# [ARC116E] Spread of Information

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc116/tasks/arc116_e

高橋国には $ N $ 箇所の町があり、それぞれ町 $ 1 $ 、町 $ 2 $、 $ \ldots $ 、町 $ N $ と名付けられています。 この国には $ N-1 $ 本の道があり、 $ i $ 本目の道は 町 $ u_i $ と町 $ v_i $ を双方向に結びます。任意の $ 2 $ つの町 $ a $, $ b $ について、いくつかの道を通ることにより、町 $ a $ から町 $ b $ へ移動することが出来ます。

高橋国王は、ある情報を国土全体に流そうとしています。多忙な高橋国王は、 $ K $ 箇所までの町にしか直接情報を伝達することが出来ません。

高橋国王の情報伝達が終わった瞬間を時刻 $ 0 $ とします。 $ t\ =\ 1,\ 2,\ 3,\ \cdots $ について、以下の現象が発生します。

- $ 1 $ 本の道で直接結ばれている町の組 $ a $, $ b $ について、 時刻 $ t-0.5 $ に町 $ a $ に情報が伝わっており、町 $ b $ に情報が伝わっていないとき、 時刻 $ t $ に町 $ b $ にも情報が伝わる。

高橋国王は $ K $ 箇所の連絡先を適切に選択し、全ての町に情報が伝わるまでに掛かる時間を最小化しようと考えています。最小値を答えてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ K\ <\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 任意の $ 2 $ つの町 $ a $, $ b $ について、いくつかの道を通ることにより、町 $ a $ から町 $ b $ へ移動することが出来る。

### Sample Explanation 1

高橋国王が町 $ 2 $ と町 $ 4 $ に直接情報を伝達した場合、町 $ 1 $ 、 $ \ldots $ 、町$ 5 $ に初めて情報が伝わる時刻は、それぞれ $ 1,\ 0,\ 1,\ 0,\ 1 $ となります。このとき、 国土全体に情報が広まるのは時刻 $ 1 $ であり、これが達成可能な最小値であることが証明出来ます。

## 样例 #1

### 输入

```
5 2

1 2

2 3

3 4

4 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 1

1 2

1 3

1 4

5 4```

### 输出

```
2```

## 样例 #3

### 输入

```
20 3

2 15

6 5

12 1

7 9

17 2

15 5

2 4

17 16

12 2

8 17

17 19

18 11

20 8

20 3

13 9

11 10

11 20

14 8

11 7```

### 输出

```
3```

# AI分析结果



**唯一算法分类**  
二分

---

### **题解思路、算法要点与解决难点**

**核心思路**  
本题采用**二分答案**结合**树形DP**的思路。通过二分枚举可能的最长时间`mid`，判定是否存在一种选点方式，使得所有节点到最近选点的距离不超过`mid`且选点数量≤K。  
- **二分框架**：初始区间为`[0, 树的最大深度]`，通过不断收缩区间找到最小的`mid`。
- **树形DP**：每个节点维护两个状态：
  - `f[x]`：以x为根的子树中最远未被覆盖的节点到x的距离。
  - `g[x]`：以x为根的子树中最近选点到x的距离。
- **关键条件**：
  1. 若`g[x] > mid`，说明x无法被子树覆盖，需被父节点覆盖（此时`f[x]`更新为max）。
  2. 若`f[x] + g[x] <= mid`，子树可完全覆盖，`f[x]`置为负无穷。
  3. 若`f[x] == mid`，必须在x放置选点，计数器+1。

**解决难点**  
- **贪心策略**：在最深未覆盖节点的mid级祖先放置选点，确保覆盖范围最大化。
- **状态合并**：通过后序遍历合并子树信息，处理父子覆盖关系。
- **根节点特判**：遍历完成后需检查根节点是否被覆盖。

---

### **题解评分 (≥4星)**

1. **hzoi_Shadow (⭐⭐⭐⭐⭐)**  
   - **亮点**：状态转移清晰，代码简洁高效，注释详细，覆盖边界条件全面。
   - **代码**：初始化`f`为-∞、`g`为+∞，通过DFS合并子树状态，逻辑紧凑。

2. **Kketchup (⭐⭐⭐⭐)**  
   - **亮点**：结合将军令等类似题经验，状态定义明确，注释详细。
   - **优化**：使用`f[u][0]`和`f[u][1]`分别表示最近选点与最远未覆盖点。

3. **AC_love (⭐⭐⭐⭐)**  
   - **亮点**：代码简洁，直接通过贪心选择最远未覆盖点的mid级祖先，逻辑直观。

---

### **最优思路或技巧提炼**

1. **二分答案框架**  
   - **区间初始化**：左边界`l=0`，右边界`r=n-1`（树的最大链长）。
   - **收缩策略**：若`check(mid)`返回true，尝试更小值（`r=mid-1`），否则增大（`l=mid+1`）。

2. **树形DP状态合并**  
   ```cpp
   void dfs(int x, int fa, int mid) {
       f[x] = -INF, g[x] = INF;
       for (子节点y) {
           dfs(y, x, mid);
           f[x] = max(f[x], f[y] + 1); // 合并最远未覆盖
           g[x] = min(g[x], g[y] + 1); // 合并最近选点
       }
       if (g[x] > mid) f[x] = max(f[x], 0); // 需被父节点覆盖
       if (f[x] + g[x] <= mid) f[x] = -INF; // 子树已覆盖
       if (f[x] == mid) { // 必须选点
           cnt++;
           f[x] = -INF;
           g[x] = 0;
       }
   }
   ```

3. **根节点特判**  
   ```cpp
   bool check(int mid) {
       cnt = 0;
       dfs(1, -1, mid);
       if (f[1] >= 0) cnt++; // 根未被覆盖则加1
       return cnt <= K;
   }
   ```

---

### **同类型题与算法套路**

1. **类似题目**  
   - [P3942 将军令](https://www.luogu.com.cn/problem/P3942)：最小覆盖半径。
   - [P2279 消防局的设立](https://www.luogu.com.cn/problem/P2279)：覆盖距离为2的最小选点。
   - [P3523 DYN-Dynamite](https://www.luogu.com.cn/problem/P3523)：平衡覆盖与关键点数量。

2. **通用二分答案套路**  
   - **问题特征**：求极值的最优化问题（最大最小或最小最大）。
   - **步骤**：  
     1. 确定二分变量（如时间、距离）。  
     2. 设计判定函数（如`check(mid)`）。  
     3. 收缩区间直到收敛。

---

### **推荐相似题目**

1. **P2218 [HAOI2007] 覆盖问题**  
   - 在平面上用三个正方形覆盖所有点，求最小边长。

2. **P1083 借教室**  
   - 二分找到第一个无法满足订单的天数。

3. **P4343 自动刷题机**  
   - 二分答案判断可行解的上界和下界。

---

### **可视化与算法演示**

**动画设计**  
- **Canvas 展示**：树结构以层级布局绘制，当前DFS节点高亮为红色，选点标记为绿色。  
- **二分过程**：左侧显示区间`[l, r]`，`mid`值动态变化，颜色渐变（蓝→黄→红表示可行性）。  
- **音效**：  
  - 成功覆盖：播放清脆“叮”声。  
  - 需要选点：短促“咔哒”声。  

**复古像素风格**  
- **8位色板**：使用经典FC的16色调色板，树节点为方块，选点闪烁特效。  
- **AI 自动演示**：按帧逐步展示二分收缩与DFS过程，速度可调。

```javascript
// 伪代码：Canvas绘制选点过程
function drawTree(node, x, y) {
    drawPixelSquare(x, y, node.selected ? GREEN : WHITE);
    for (let child of node.children) {
        drawLine(x, y, child.x, child.y);
        drawTree(child, child.x, child.y);
    }
}
```

---

### **代码实现**

**核心二分逻辑**  
```cpp
int main() {
    int l = 0, r = n, ans = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    cout << ans << endl;
}
```

**完整代码（hzoi_Shadow版）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
struct node { int nxt, to; } e[400010];
int head[400010], f[400010], g[400010], cnt=0, sum=0;

void add(int u, int v) {
    e[++cnt] = {head[u], v};
    head[u] = cnt;
}

void dfs(int x, int fa, int k) {
    f[x] = -0x3f3f3f3f;
    g[x] = 0x3f3f3f3f;
    for (int i=head[x]; i; i=e[i].nxt) {
        int y = e[i].to;
        if (y != fa) {
            dfs(y, x, k);
            f[x] = max(f[x], f[y]+1);
            g[x] = min(g[x], g[y]+1);
        }
    }
    if (g[x] > k) f[x] = max(f[x], 0);
    if (f[x] + g[x] <= k) f[x] = -0x3f3f3f3f;
    if (f[x] == k) {
        f[x] = -0x3f3f3f3f;
        g[x] = 0;
        sum++;
    }
}

bool check(int mid, int k) {
    sum = 0;
    dfs(1, 0, mid);
    sum += (f[1] >= 0);
    return sum <= k;	
}

int main() {
    int n, k; cin >> n >> k;
    // 建树省略
    int l=0, r=n, ans=0;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (check(mid, k)) { ans=mid; r=mid-1; }
        else l = mid+1;
    }
    cout << ans << endl;
}
```

---
处理用时：95.57秒
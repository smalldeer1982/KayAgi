# 题目信息

# [ARC179C] Beware of Overflow

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc179/tasks/arc179_c

この問題は**インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

正整数 $ N $ が与えられます.

ジャッジシステムは正整数 $ R $ および $ N $ 個の整数 $ A_1,A_2,\dots\ ,A_N $ を隠し持っています. ここで $ |A_i|\le\ R,\ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $ を満たすことが保証されます.

絶対値が $ R $ 以下の整数しか書き込むことができない黒板があり, はじめは何も書き込まれていません.

ジャッジシステムは, 黒板に $ A_1,A_2,\ \dots\ ,A_N $ の値を **この順で** 書き込みました. あなたは, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にする必要があります.

あなたは $ R $ および $ A_i $ の値を直接知ることはできませんが, その代わりにジャッジシステムに対して次のやり取りを $ 25000 $ 回まで行うことができます.

正整数 $ i $ について, $ i $ 番目に黒板に書き込まれた整数を $ X_i $ とします. 特に, $ i=1,2,\dots\ ,N $ について $ X_i=A_i $ です.

$ 1 $ 回のやり取りでは, 相異なる正整数 $ i,j $ を指定し, 次のいずれかを選んで行います.

- 足し算をしてもらう. ジャッジシステムは黒板から $ X_i,X_j $ を消し, 新たに $ X_i+X_j $ の値を黒板に書き込む.
  - $ |X_i+X_j|\le\ R $ を満たしていなくてはならない.
- 大小比較をしてもらう. ジャッジシステムは $ X_i\lt\ X_j $ の真偽を答える.

ただし, 各やり取りを始める時点で $ i,j $ 番目に黒板に書き込まれた整数がすでに黒板から消されていてはなりません.

適切にやり取りを行って, 全てのやり取りを終えた後に黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にしてください.

$ R $ および $ A_i $ はプログラムとジャッジシステムの対話の開始前に決定されます.

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

最初に, $ N $ を標準入力から受け取ってください.

> $ N $

次に, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になるまで, やり取りを繰り返してください.

足し算をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> + $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ P $

ここで $ P $ は整数で,

- $ P\geq\ N+1 $ の場合は, $ X_i+X_j $ の値が黒板に書き込まれ, それが $ P $ 番目に書き込まれたことを表します.
- $ P=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

大小比較をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> ? $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ Q $

ここで $ Q $ は整数で,

- $ Q=1 $ の場合は, $ X_i\ <\ X_j $ が真であることを表します.
- $ Q=0 $ の場合は, $ X_i\ <\ X_j $ が偽であることを表します.
- $ Q=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

足し算をしてもらうやり取りおよび大小比較をしてもらうやり取りのいずれについても, ジャッジシステムの応答が $ -1 $ であった場合は, プログラムはすでに不正解とみなされています. この場合, ただちにプログラムを終了してください.

黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になったら, 以下の形式でそのことをジャッジシステムに報告してください. ただし, これはジャッジシステムとのやり取りの回数に計上されません. その後, ただちにプログラムを終了してください.

```
!
```

上記のいずれの形式にも当てはまらない出力を行った場合は, `-1` が標準入力から与えられます.

```
-1
```

このときも, プログラムはすでに不正解とみなされています. ただちにプログラムを終了してください.

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 1000 $
- $ 1\leq\ R\leq\ 10^9 $
- $ |A_i|\leq\ R $
- $ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $
- $ N,R,A_i $ は整数.

### 注意点

- **出力を行うたびに, 末尾に改行を入れて標準出力を flush してください. そうしなかった場合, ジャッジ結果が TLE となる可能性があります.**
- 解答を出力したら（または `-1` を受け取ったら）ただちにプログラムを終了してください. そうしない場合, ジャッジ結果は不定です.
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください.

### 入出力例

$ N=3,R=10,A_1=-1,A_2=10,A_3=1 $ のときの対話の一例を示します.

入力出力説明`3`まず整数 $ N $ が与えられます。`? 1 2`大小比較をしてもらいます.`1`$ X_1\lt\ X_2\ (-1\lt\ 10) $ なのでジャッジシステムは $ 1 $ を返します. `+ 1 3`足し算をしてもらいます.`4`ジャッジシステムは $ X_1=-1,X_3=1 $ を黒板から消し, $ X_1+X_3=0 $ の値を黒板に書き込みました. $ 4 $ 番目の書き込みでした.`+ 2 4`足し算をしてもらいます.`5`ジャッジシステムは $ X_2=10,X_4=0 $ を黒板から消し, $ X_2+X_4=10 $ の値を黒板に書き込みました. $ 5 $ 番目の書き込みでした.`!`黒板にはただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態になったので, そのことをジャッジシステムに報告します.

# AI分析结果



### 算法分类
**二分**

---

### 题解思路与核心难点
**核心思路**：  
1. **排序策略**：通过比较操作将原始数组排序（归并排序或稳定排序）。
2. **贪心合并**：每次取最小值和最大值合并，保证和的绝对值不超过 \( R \)。
3. **二分插入**：将合并后的新值通过二分查找插入有序数组，保持后续操作的有序性。

**解决难点**：  
1. **正确性证明**：需证明每次合并最小值和最大值的安全性（同符号时和不超过总和，异符号时绝对值不超过较大者）。
2. **高效插入**：通过二分查找将合并后的新值快速插入有序数组，减少比较次数。

**二分关键点**：  
- **搜索区间**：初始为当前数组的有效范围（例如 `left=1`, `right=len`）。
- **比较条件**：比较新生成的值与中间元素的大小，确定插入位置。
- **区间收缩**：若中间元素小于新值，则在右半区继续搜索；否则在左半区搜索。

---

### 题解评分（≥4星）
1. **作者：fcy20180201（⭐⭐⭐⭐⭐）**  
   - 思路清晰，完整证明策略正确性。
   - 归并排序实现稳定，二分插入逻辑简洁。
   - 代码可读性强，时间复杂度分析详细。

2. **作者：Moya_Rao（⭐⭐⭐⭐）**  
   - 使用 `stable_sort` 简化排序逻辑。
   - 代码简洁，但缺乏详细正确性证明。
   - 插入部分采用二分，时间复杂度合理。

3. **作者：_cbw（⭐⭐⭐⭐）**  
   - 代码结构清晰，插入逻辑明确。
   - 通过二分实现高效插入，但未优化传递闭包。
   - 提供可视化思路，增强理解。

---

### 最优思路与技巧
1. **贪心合并策略**：始终合并最小值和最大值，确保操作合法。
2. **归并排序优化**：利用归并排序的稳定性和 \( O(n \log n) \) 的比较次数。
3. **二分插入加速**：每次合并后通过二分查找快速确定新值的位置，减少比较次数至 \( O(n \log n) \)。

---

### 同类型题与算法套路
1. **贪心合并类**：如合并石子（洛谷 P1090），每次选择最小两堆合并。
2. **二分插入类**：在有序数组中动态维护元素（如插入排序优化）。
3. **交互式排序**：通过有限比较操作获取序列顺序信息。

**推荐题目**：  
1. 洛谷 P1090（合并果子）  
2. 洛谷 P1177（快速排序）  
3. 洛谷 P1908（逆序对，归并排序应用）

---

### 个人心得摘录
> **作者：fire_and_sweets**：  
> “最初尝试维护两个堆导致操作次数过多，改用二分插入后显著优化。调试中发现必须保证每次合并后的数组严格有序。”

---

### 可视化与算法演示
**动画设计**：  
1. **排序阶段**：展示归并排序的分治过程，用不同颜色标记左右子数组。
2. **合并阶段**：高亮当前最小值和最大值，合并后生成新值。
3. **二分插入**：动态显示搜索区间 `[left, right]`，标红 `mid` 元素，根据比较结果收缩区间。

**复古游戏化效果**：  
- **像素风格**：数组元素显示为 8-bit 方块，合并时播放“合成音效”。
- **自动演示**：AI 逐步执行排序和合并操作，支持暂停/步进。
- **积分系统**：正确完成一次合并得 10 分，错误操作扣分。

**关键代码片段（JS 伪代码）**：
```javascript
function visualizeBinaryInsert(arr, newVal) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        highlight(mid); // 高亮当前 mid 元素
        playSound('blip'); // 播放音效
        if (compare(arr[mid], newVal)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
        updateCanvas(arr, left, right); // 更新搜索区间显示
    }
    arr.splice(left, 0, newVal); // 插入新值
}
```

---

### 核心二分代码（C++ 片段）
```cpp
// 二分插入新值到有序数组
void insert(int res) {
    int l = 1, r = len, pos = len + 1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (Query(p[mid], res)) { // 若 p[mid] < res
            l = mid + 1;
        } else {
            r = mid - 1;
            pos = mid;
        }
    }
    // 将 res 插入到 pos 位置
    for (int j = len; j >= pos; j--) p[j+1] = p[j];
    p[pos] = res;
    len++;
}
```

---
处理用时：87.39秒
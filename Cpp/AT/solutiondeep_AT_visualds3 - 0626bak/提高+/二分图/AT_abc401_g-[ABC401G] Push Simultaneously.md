# 题目信息

# [ABC401G] Push Simultaneously

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc401/tasks/abc401_g

平面上有 $N$ 个高桥君和 $N$ 个按钮。平面上设有原点，从原点向东移动 $x$ 米、向北移动 $y$ 米的位置用坐标 $(x,y)$ 表示。第 $i$ 个高桥君 $(1 \leq i \leq N)$ 初始位于坐标 $(\mathit{sx}_i, \mathit{sy}_i)$，第 $i$ 个按钮位于坐标 $(\mathit{gx}_i, \mathit{gy}_i)$。

高桥君们需要在移动后**同时**按下这 $N$ 个按钮。每个按钮只能由位于该按钮坐标的高桥君按下。从到达按钮所在坐标到按下按钮所需的时间为 $0$ 秒。

每个高桥君可以以不超过 $1$ 米/秒的速度向任意方向移动。更严格地说，设第 $i$ 个高桥君在开始后 $t$ 秒时的坐标为 $(x_i(t), y_i(t))$，则必须满足以下所有条件：

- $x_i(0) = \mathit{sx}_i$
- $y_i(0) = \mathit{sy}_i$
- 对于所有非负实数 $t_0, t_1$，点 $(x_i(t_0), y_i(t_0))$ 和点 $(x_i(t_1), y_i(t_1))$ 之间的距离不超过 $|t_0 - t_1|$

请计算高桥君们达成目标所需的最短时间。严格来说，求满足以下条件的最小 $t$ 值：

- 适当定义满足上述条件的 $x_i, y_i$ 后，对于所有整数 $j$ $(1 \leq j \leq N)$ 和实数 $t'$ $(t' > t)$，存在整数 $i$ $(1 \leq i \leq N)$ 使得 $(x_i(t'), y_i(t')) = (\mathit{gx}_j, \mathit{gy}_j)$ 成立。

## 说明/提示

### 约束条件

- $1 \leq N \leq 300$
- $0 \leq \mathit{sx}_i \leq 10^{18}$ $(1 \leq i \leq N)$
- $0 \leq \mathit{sy}_i \leq 10^{18}$ $(1 \leq i \leq N)$
- $0 \leq \mathit{gx}_i \leq 10^{18}$ $(1 \leq i \leq N)$
- $0 \leq \mathit{gy}_i \leq 10^{18}$ $(1 \leq i \leq N)$
- $(\mathit{sx}_i, \mathit{sy}_i) \neq (\mathit{sx}_j, \mathit{sy}_j)$ $(1 \leq i < j \leq N)$
- $(\mathit{gx}_i, \mathit{gy}_i) \neq (\mathit{gx}_j, \mathit{gy}_j)$ $(1 \leq i < j \leq N)$
- $(\mathit{sx}_i, \mathit{sy}_i) \neq (\mathit{gx}_j, \mathit{gy}_j)$ $(1 \leq i \leq N, 1 \leq j \leq N)$
- 输入的所有数值均为整数

### 样例解释 1

初始时，高桥君和按钮的位置关系如图所示。

![](https://img.atcoder.jp/abc401/c384b713a3b955d1450b7c503cb429cd.png)

假设第 $1,2,3,4$ 个高桥君分别直接向第 $1,3,2,4$ 个按钮移动。

![](https://img.atcoder.jp/abc401/9e54567c2b21a9757d3769ea756ab892.png)

这样，高桥君们分别在开始后 $2$ 秒、$\sqrt{2}$ 秒、$1$ 秒、$\sqrt{2}$ 秒时到达对应按钮的坐标。因此，可以在开始后 $2$ 秒时同时按下所有按钮。反之，无法在 $2$ 秒之前同时按下所有按钮，所以输出 `2`。只要输出值与真实值的相对误差不超过 $10^{-6}$，例如 `1.999998` 或 `2.00000014` 也会被判定为正确。

### 样例解释 2

注意输入的坐标可能超出 $32$ 位整数的范围。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4

0 0

0 1

2 0

3 1

0 2

1 0

1 2

2 2```

### 输出

```
2```

## 样例 #2

### 输入

```
3

1 4

1 5

9 2

653589793238462643 383279502884197169

399375105820974944 592307816406286208

99862803482534211 706798214808651328```

### 输出

```
757682516069002110.04581169374262658710741005525```

## 样例 #3

### 输入

```
12

4459915897 5789359311

4393259463 4247016333

4827828467 4179021045

2654035685 3406423989

1790405301 4886103164

2978675817 4818583236

5912369644 5824121992

6016882384 4165667191

4305949638 3454894060

6545166942 5390976281

4043403253 4019611554

3462096432 4117859301

3528911877 4631601790

4627979431 4814676729

3810130146 5728760563

5586470124 3310360339

3664130072 4525834271

1710246881 3750440871

3143440609 5038869551

2294021341 3965849888

6189106395 4499485672

4799619607 5151972020

6905793542 3976136296

1764267574 4525373194```

### 输出

```
1299999319.116399442508650717909981965254```

# AI分析结果



**唯一算法分类**：二分答案 + 二分图匹配

---

### **综合分析与结论**
题目要求找到使所有高桥君同时按下按钮的最短时间，核心思路为：
1. **二分答案**：二分时间 $t$，判断是否存在完美匹配使得所有匹配边距离不超过 $t$。
2. **二分图匹配**：将高桥君与按钮的可行连接视为边，构建二分图，判断完美匹配存在性。

**难点与解决方案**：
- **精度处理**：使用整数存储距离平方避免浮点误差（如 `__int128`）。
- **高效匹配算法**：采用匈牙利算法或 Dinic 网络流，适应 $n=300$ 的数据规模。
- **优化二分过程**：预处理边并按距离排序，二分索引减少计算量。

**可视化设计**：
- **动画展示**：Canvas 绘制高桥君与按钮的位置，动态显示当前二分 $t$ 值及有效边。
- **匹配过程**：高亮当前 DFS 路径，展示增广路径寻找过程。
- **复古风格**：8-bit 像素风格，按钮与高桥君用不同颜色方块表示，匹配成功时播放上扬音效。

---

### **题解评分 (≥4星)**

1. **laiyouming (5星)**
   - **亮点**：预处理边并按距离排序，二分索引优化，代码简洁高效。
   - **代码**：通过排序边后二分索引，减少浮点运算，匈牙利算法实现清晰。

2. **WuMin4 (4星)**
   - **亮点**：直接二分时间 $t$，使用匈牙利算法，代码简短易读。
   - **注意**：需处理浮点精度，但通过二分次数保证收敛。

3. **Ivan422 (4星)**
   - **亮点**：使用 `__int128` 处理距离平方，避免精度问题，优化二分次数。
   - **心得**：强调数据范围处理，避免整数溢出。

---

### **最优思路或技巧提炼**
- **整数化距离**：用 `__int128` 存储距离平方，避免浮点误差。
- **预处理排序边**：按距离排序后二分索引，优化判断效率。
- **Dinic 网络流优化**：对大规模数据更高效，适合多次匹配判断。

---

### **同类型题或算法套路**
- **通用解法**：二分答案 + 图论模型（匹配/网络流）。
- **类似题**：
  - 洛谷 P3386（二分图最大匹配）
  - 洛谷 P2756（二分图匹配应用）
  - 洛谷 P2764（最小路径覆盖，转化为二分图）

---

### **推荐洛谷题目**
1. **P3386** - 二分图最大匹配模板
2. **P2763** - 试题库问题（网络流建模）
3. **P3254** - 圆桌问题（二分图多重匹配）

---

### **个人心得摘录**
- **Ivan422**：避免整数溢出需用 `__int128`，二分次数优化保证精度。
- **laiyouming**：排序边后二分索引，极大减少每次匹配的边数。

---

### **核心代码片段（laiyouming）**
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, c[3001], d[3001];
vector<pair<long double, pair<int, int>>> a;

bool dfs(int x) {
    d[x] = 1;
    for (auto j : b[x]) {
        if (!c[j] || (!d[c[j]] && dfs(c[j]))) {
            c[j] = x;
            return 1;
        }
    }
    return 0;
}

bool ok(long long x) {
    // 构建前x条边的图，检查完美匹配
}

int main() {
    // 预处理所有边并排序
    sort(a.begin(), a.end());
    // 二分索引
    while (l + 1 < r) {
        if (ok(mid)) r = mid;
        else l = mid;
    }
    printf("%.20Lf", a[r-1].first); // 输出最小时间
}
```

---

### **可视化与算法演示**
- **Canvas动画**：展示高桥君移动路径及有效边，当前二分区间动态调整。
- **步进控制**：单步执行二分过程，显示匹配状态变化。
- **音效触发**：找到增广路径时播放提示音，完美匹配成功时播放胜利音效。

---
处理用时：148.69秒
# 题目信息

# [AGC037C] Numbers on a Circle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc037/tasks/agc037_c

円環状に $ N $ 個の正整数が並んでおり、それらには円環に沿った順に $ 1 $ から $ N $ の番号がついています。

今 $ i $ 番目の数は $ A_i $ です。高橋君は $ i $ 番目の正整数が $ B_i $ となるようにしたいです。 そこで、高橋君は以下の操作を繰り返し行うことにしました。

- $ 1\ \leqq\ i\ \leqq\ N $ なる整数 $ i $ を一つ選ぶ。
- $ i-1,i,i+1 $ 番目の数をそれぞれ $ a,b,c $ としたとき、$ i $ 番目の数を $ a+b+c $ に置き換える。

ただし、$ 0 $ 番目の数は $ N $ 番目の数を指し、$ N+1 $ 番目の数は $ 1 $ 番目の数を指すことに注意してください。

高橋君が条件をみたすように操作を行うことができるかどうか判定してください。 また可能である場合は、高橋君が行う必要のある操作回数として考えられる最小の値を求めてください。

## 说明/提示

### 制約

- $ 3\ ≦\ N\ ≦\ 2\ \times\ 10^5 $
- $ 1\ ≦\ A_i,\ B_i\ ≦\ 10^9 $
- 入力中のすべての値は整数である

### Sample Explanation 1

例えば高橋君は以下のように操作を行うことができます。 - $ 2 $ 番目の数を $ 3 $ に置き換える。 - $ 2 $ 番目の数を $ 5 $ に置き換える。 - $ 3 $ 番目の数を $ 7 $ に置き換える。 - $ 1 $ 番目の数を $ 13 $ に置き換える。

## 样例 #1

### 输入

```
3

1 1 1

13 5 7```

### 输出

```
4```

## 样例 #2

### 输入

```
4

1 2 3 4

2 3 4 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
5

5 6 5 2 1

9817 1108 6890 4343 8704```

### 输出

```
25```

# AI分析结果



**唯一算法分类**  
贪心（逆向思维 + 优先队列）

---

**综合分析与结论**  
**题目核心**：通过逆向操作将目标数组 $B$ 逐步减为初始数组 $A$，每次操作选当前最大值减去左右两数之和，直到无法操作或达成目标。  
**关键难点**：  
1. **逆向操作合法性**：需保证每次操作后数值仍为正且能最终减到 $A_i$。  
2. **环状结构处理**：需正确处理首尾相邻的边界条件。  
3. **时间复杂度优化**：通过优先队列维护最大值，每次尽可能多减以减少操作次数。  

**核心算法流程**：  
1. **初始化检查**：若存在 $A_i > B_i$，直接无解。  
2. **优先队列维护**：将所有 $B_i > A_i$ 的元素加入优先队列。  
3. **贪心操作**：循环取出最大值，计算可减次数（`(B_i - A_i) / (B_{i-1} + B_{i+1})`），更新 $B_i$ 和总操作次数。  
4. **无解判断**：若无法继续减且未达 $A_i$，返回 `-1`。  

**可视化设计**：  
- **像素动画**：用 Canvas 绘制环形数组，高亮当前操作元素及其左右相邻元素。  
- **音效**：弹出堆顶元素时播放“选择”音效，成功减去数值时播放“滴答”音效，无解时播放“失败”音调。  
- **自动演示**：按贪心顺序自动执行操作，单步调试可观察优先队列动态变化。  

---

**题解清单 (≥4星)**  
1. **installb (4星)**  
   - **亮点**：详细推导逆向操作的必要性，强调优先处理最大值的正确性。  
   - **代码优化**：使用 `getnum` 处理环状结构，逻辑清晰。  
2. **gdf_yhm (4星)**  
   - **亮点**：通过样例分析直观展示操作过程，代码中直接维护 `b[0]` 和 `b[n+1]` 简化边界处理。  
3. **XCDRF_ (4星)**  
   - **亮点**：代码简洁，使用 `num` 函数处理环，突出贪心核心逻辑。  

---

**核心代码实现**  
```cpp
priority_queue<node> q; // 维护最大值
LL ans = 0;

while (!q.empty()) {
    LL i = q.top().id; q.pop();
    LL mns = b[left(i)] + b[right(i)]; // 左右两数之和
    LL del = (b[i] - a[i]) / mns;      // 可减次数
    
    if (del == 0 && b[i] != a[i]) {    // 无法操作且未达标
        cout << -1; return 0;
    }
    
    ans += del;
    b[i] -= del * mns;                 // 更新值
    
    if (b[i] > a[i]) q.push({i, b[i]}); // 重新入队
}
```

---

**同类型题与算法套路**  
- **逆向思维**：如 BFS 反向搜索、动态规划逆推。  
- **贪心 + 优先队列**：如合并果子（每次选最小两堆）、任务调度。  

**推荐题目**  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
2. [P1960 马拦过河卒（逆向DP）](https://www.luogu.com.cn/problem/P1960)  
3. [AT1219 歴史の研究（滑动窗口+堆）](https://www.luogu.com.cn/problem/AT1219)  

---

**个人心得摘录**  
> “若一个数已经是当前最大值，其左右两数无法在其之前操作，必须优先处理它。这种贪心顺序确保了无后效性。” —— installb  

---

**可视化与算法演示**  
**动画方案**：  
1. **环形数组展示**：用不同颜色方块表示每个数，当前操作元素高亮为红色。  
2. **堆动态显示**：优先队列以浮动列表形式展示，当前最大值闪烁提示。  
3. **操作步进**：点击“下一步”触发一次贪心操作，显示减去的数值和剩余值。  

**复古风格设计**：  
- **8位调色板**：使用经典 FC 红、黄、蓝三色表示数值大小。  
- **音效**：操作成功时播放 `8-bit` 上升音阶，失败时播放低沉嗡鸣。  
- **自动模式**：点击“播放”后自动执行，速度可调（慢/中/快）。  

**交互示例**：  
![Visual Demo](https://via.placeholder.com/600x400/000000/FFFFFF?text=点击查看贪心操作动态演示)

---
处理用时：88.25秒
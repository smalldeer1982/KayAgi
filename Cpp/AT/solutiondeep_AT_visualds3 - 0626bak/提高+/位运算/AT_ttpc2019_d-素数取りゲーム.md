# 题目信息

# 素数取りゲーム

## 题目描述

# 素数取り游戏



东工大的安酱和爱酱玩了一个叫做石头取走游戏的两人游戏，但是因为知道必胜法，所以不再感兴趣了。

于是，安酱考虑了一个基于素数的石头取回游戏，并将它命名为“素数取回游戏”。

素数取回游戏的规则如下：

- 开始时有 $N$ 堆小石子，在第 $i$ 堆中有 $X_i$ 个（$X_i$ 是素数）小石子。
- 两个玩家轮流选择存在小石堆的那一堆，并从那里拿走一些石子。
- **只能同时获取素数枚石子，并且在剩余的石子数量为 $0$ 或素数枚时才能继续进行**
- 先无法拿走石头的玩家输掉比赛。

虽然这条规则新颖，但似乎安和爱仍然知道怎样获胜。

请问当安穗是先手，爱穗是后手，面对由 $X_1$，$X_2$，$\ldots$，$X_N$ 个石头组成的 $N$ 堆石头时，假设他们采取最优策略，谁将获胜？

## 样例 #1

### 输入

```
1

13```

### 输出

```
An```

## 样例 #2

### 输入

```
2

17 13```

### 输出

```
An```

## 样例 #3

### 输入

```
6

49529 868033 52361 519803 19289 386501```

### 输出

```
Ai```

# AI分析结果



# 素数取りゲーム 题解分析

## 1. 算法分类
博弈论（Nim 游戏变种）

---

## 2. 题解思路与核心算法

### 核心思路
- **SG 函数分析**：每堆石子的 SG 值分为三种情况：
  - `SG=3`：仅当石子数为 7 时。
  - `SG=2`：当石子数减 2 仍是素数时（如 5→3 是素数）。
  - `SG=1`：其他情况（如 3→1 不是素数）。
- **胜负判定**：所有堆的 SG 值异或结果非零则先手（An）胜，否则后手（Ai）胜。

### 算法实现
- **素数判断**：预处理素数表（欧拉筛）或使用 Miller-Rabin 素性测试。
- **贡献计算**：遍历每个石子数，按规则计算其 SG 值并异或。

### 解决难点
- **SG 函数推导**：通过数学归纳和质数性质（奇偶性）证明只有三种 SG 值。
- **高效素数检测**：针对不同数据规模选择筛法或概率性测试。

---

## 3. 题解评分（≥4星）

### CEFqwq 题解（⭐⭐⭐⭐）
- **亮点**：
  - 结合 Nim 游戏模型，明确异或规则。
  - 预处理欧拉筛优化素数判断，代码高效。
  - 提供多种实现（线性筛、Miller-Rabin）应对不同数据范围。
- **代码片段**：
  ```cpp
  if(a[i]==7) res ^=3;
  else if(is_prime(a[i]-2)) res ^=2;
  else res ^=1;
  ```

### Genius_Star 题解（⭐⭐⭐）
- **亮点**：
  - 详细推导 SG 函数转移方程。
  - 通过模 6 分析证明质数性质，增强理论严谨性。
- **不足**：未处理大数情况，试除法效率较低。

---

## 4. 最优技巧提炼
- **SG 分治**：将每堆转化为 1/2/3 贡献，简化异或判断。
- **素数优化**：筛法预处理小素数，Miller-Rabin 处理大数。
- **位运算加速**：直接异或累积结果，时间复杂度 O(N)。

---

## 5. 同类题目推荐
1. P2197 【模板】Nim 游戏
2. P2964 [USACO09NOV] Coin Game
3. P3185 [HNOI2007] 分裂游戏

---

## 6. 可视化算法演示

### 动画设计
- **像素风格**：用 8-bit 色块表示石子堆，不同颜色区分 SG 值（红=1，蓝=2，黄=3）。
- **步进控制**：点击堆时高亮当前操作，显示剩余石子数和 SG 贡献。
- **音效**：异或结果为 0 时播放低沉音，非零时高音提示胜负。

### 交互示例
1. 初始界面展示各堆石子数和 SG 值。
2. 点击堆模拟取石子，更新剩余数和 SG 异或结果。
3. 自动模式演示最优策略路径。

---

## 7. 核心代码实现
```cpp
#include <iostream>
using namespace std;

bool is_prime(int x) {
    if (x < 2) return false;
    for (int i=2; i*i<=x; ++i)
        if (x%i == 0) return false;
    return true;
}

int main() {
    int n, res=0;
    cin >> n;
    while (n--) {
        int x; cin >> x;
        if (x == 7) res ^= 3;
        else if (is_prime(x-2)) res ^= 2;
        else res ^= 1;
    }
    cout << (res ? "An" : "Ai");
}
```

---
处理用时：81.20秒
# 题目信息

# [ABC219G] Propagation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc219/tasks/abc219_g

$ N $ 頂点 $ M $ 辺の単純無向グラフが与えられます。$ N $ 個の頂点はそれぞれ頂点 $ 1 $ 、頂点 $ 2 $ 、$ \ldots $ 、頂点 $ N $ と呼ばれます。  
 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結んでいます。  
 また、$ i\ =\ 1,\ 2,\ \ldots,\ N $ について、頂点 $ i $ には整数 $ i $ が書かれています。

$ Q $ 個のクエリが与えられます。  
 $ i\ =\ 1,\ 2,\ \ldots,\ Q $ について、$ i $ 番目のクエリは整数 $ x_i $ で表されます。 $ i $ 番目のクエリでは以下の操作をおこないます。

1. 頂点 $ x_i $ に書かれている整数を $ X $ とおく。
2. 頂点 $ x_i $ と隣接するすべての頂点について、それに書かれた整数を $ X $ に書き換える。

ただし、頂点 $ u $ と頂点 $ v $ が隣接するとは、頂点 $ u $ と頂点 $ v $ を結ぶ辺が存在することを言います。

入力で与えられる順にすべてのクエリを処理した後の時点における、各頂点に書かれた整数をそれぞれ出力して下さい。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min(2\ \times\ 10^5,\ N(N-1)/2) $
- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- $ 1\ \leq\ x_i\ \leq\ N $
- 与えられるグラフは単純である。すなわち、自己ループや多重辺は存在しない。
- 入力はすべて整数

### Sample Explanation 1

それぞれのクエリでは以下のような操作が行われます。 - $ 1 $ 番目のクエリ $ (x_1\ =\ 1) $ : 頂点 $ 1 $ に書かれた整数は $ 1 $ であり、頂点 $ 1 $ に隣接する頂点は頂点 $ 2 $ と頂点 $ 5 $ です。 よって、頂点 $ 2 $ と頂点 $ 5 $ に書かれた整数がそれぞれ $ 1 $ に書き換えられます。 - $ 2 $ 番目のクエリ $ (x_2\ =\ 3) $ : 頂点 $ 3 $ に書かれた整数は $ 3 $ であり、頂点 $ 3 $ に隣接する頂点は頂点 $ 2 $ と頂点 $ 4 $ です。よって、頂点 $ 2 $ と頂点 $ 4 $ に書かれた整数がそれぞれ $ 3 $ に書き換えられます。 - $ 3 $ 番目のクエリ $ (x_3\ =\ 4) $ : 頂点 $ 4 $ に書かれた整数は $ 3 $ であり、頂点 $ 4 $ に隣接する頂点は頂点 $ 2 $ 、頂点 $ 3 $ 、頂点 $ 5 $ です。よって、頂点 $ 2 $ 、頂点 $ 3 $ 、頂点 $ 5 $ に書かれた整数がそれぞれ $ 3 $ に書き換えられます。 （頂点 $ 2 $ と頂点 $ 3 $ にはすでに $ 3 $ が書かれているので、書かれた整数が実際に変更されるのは頂点 $ 5 $ のみです。）

## 样例 #1

### 输入

```
5 6 3

4 2

4 3

1 2

2 3

4 5

1 5

1 3 4```

### 输出

```
1 3 3 3 3```

## 样例 #2

### 输入

```
14 14 8

7 4

13 9

9 8

4 3

7 2

13 8

12 8

11 3

6 3

7 14

6 5

1 4

10 13

5 2

2 6 12 9 1 10 5 4```

### 输出

```
1 6 1 1 6 6 1 9 9 10 11 12 10 14```

# AI分析结果



**唯一算法分类**  
根号分治

---

### **题解思路、算法要点与解决难点**

**核心思路**  
通过将顶点按度数分为轻点（度数小）和重点（度数大），对轻点直接暴力更新邻居，对重点打延迟标记，预处理相邻重点列表以降低时间复杂度至 O(q√m)。

**解决难点**  
1. **暴力更新的优化**：轻点直接更新邻居，时间复杂度 O(√m)。  
2. **延迟标记管理**：重点仅记录最后一次更新的值和时间戳，避免频繁操作。  
3. **预处理相邻重点列表**：每个顶点存储相邻的重点，确保合并标记时时间复杂度可控。

---

### **题解评分 (≥4星)**

1. **ziyistudy (4.5星)**  
   - **亮点**：代码简洁，预处理部分清晰，通过 `nxt` 数组维护相邻重点，时间戳比较逻辑高效。  
   - **优化**：明确阈值选择 `hal=450`，时间复杂度严格控制在根号级别。  

2. **mojoege (4星)**  
   - **亮点**：详细解释根号分治的动机，引入 `find` 函数统一处理标记合并逻辑。  
   - **代码结构**：使用 `col` 和 `tim` 数组分离轻重点状态，逻辑清晰。  

3. **Purslane (4星)**  
   - **亮点**：函数 `get_val` 封装标记合并逻辑，代码模块化强，预处理 `GG` 数组高效。  

---

### **最优思路或技巧提炼**

1. **根号分治阈值选择**：取 `sqrt(m)` 作为轻重点分界线，确保重点数量不超过 O(√m)。  
2. **延迟标记设计**：重点记录最后一次更新的值和时间戳，仅在需要时合并相邻重点的标记。  
3. **预处理相邻重点列表**：每个顶点维护相邻的重点集合，避免遍历所有邻居。  
4. **时间戳比较**：通过比较时间戳确定最新值，保证正确性。  

---

### **同类型题或类似算法套路**

- **CF398D**：根号分治处理动态图操作。  
- **ABC253G**：延迟标记与预处理结合优化时间复杂度。  
- **LOJ 数列分块**：分块思想在数据结构中的通用应用。  

---

### **推荐洛谷题目**

1. **P3203 [HNOI2010]弹飞绵羊**（分块处理跳跃操作）  
2. **P3396 哈希冲突**（根号分治优化查询）  
3. **P5356 [Ynoi2017] 由乃打扑克**（分块与懒标记结合）  

---

### **可视化与算法演示**

**核心逻辑动画设计**：  
1. **像素风格界面**：顶点显示为像素方块，轻点用绿色，重点用红色，当前操作顶点高亮闪烁。  
2. **操作步骤动画**：  
   - **查询阶段**：选中顶点后，若为轻点，扩散绿色波纹到邻居；若为重点，红色方块闪烁并记录标记。  
   - **最终合并阶段**：遍历所有顶点，红色方块向相邻方块发射光线，表示标记合并。  
3. **音效与交互**：  
   - **扩散波纹**：播放 8-bit 音效，频率随操作次数增加。  
   - **标记合并**：成功合并时播放上升音调，失败则短促“哔”声。  
4. **参数控制面板**：可调节动画速度、隐藏/显示重点、单步执行。  

---

### **代码实现（核心逻辑）**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10, B = 450;
vector<int> g[N], heavy_adj[N];
int col[N], tim[N], tag_col[N], tag_time[N];
bool is_heavy[N];

int get_value(int u) {
    int res = col[u], latest = tim[u];
    for (int v : heavy_adj[u]) {
        if (tag_time[v] > latest) {
            latest = tag_time[v];
            res = tag_col[v];
        }
    }
    return res;
}

int main() {
    int n, m, q; cin >> n >> m >> q;
    for (int i = 1; i <= n; ++i) col[i] = i;
    for (int i = 0; i < m; ++i) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    // 预处理重点及相邻重点列表
    for (int i = 1; i <= n; ++i) {
        is_heavy[i] = (g[i].size() >= B);
        if (is_heavy[i]) {
            for (int v : g[i]) {
                heavy_adj[v].push_back(i);
            }
        }
    }
    // 处理查询
    for (int i = 1; i <= q; ++i) {
        int u; cin >> u;
        col[u] = get_value(u);
        tim[u] = i;
        if (is_heavy[u]) {
            tag_col[u] = col[u];
            tag_time[u] = i;
        } else {
            for (int v : g[u]) {
                col[v] = col[u];
                tim[v] = i;
            }
        }
    }
    // 最终合并标记
    for (int i = 1; i <= n; ++i) {
        col[i] = get_value(i);
        cout << col[i] << " ";
    }
    return 0;
}
```

**代码要点**：  
- `get_value` 函数合并当前顶点与其相邻重点的标记。  
- 预处理 `heavy_adj` 数组存储每个顶点的相邻重点。  
- 轻点直接更新邻居，重点仅更新标记。  

---

### **个人心得摘录**

> “根号分治的难点在于阈值的选择和标记的合并逻辑，预处理相邻重点列表是优化关键。” —— ziyistudy  
> “延迟标记类似线段树的懒操作，但需注意时间戳的优先级。” —— mojoege  

---

**可视化实现参考**：  
- 使用 `Canvas` 绘制顶点网格，`requestAnimationFrame` 控制动画。  
- 音效通过 `Web Audio API` 播放，不同操作触发不同音效。  
- 交互面板用 `dat.GUI` 库实现参数调节。

---
处理用时：85.46秒
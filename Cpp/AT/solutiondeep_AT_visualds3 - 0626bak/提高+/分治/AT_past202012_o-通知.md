# 题目信息

# 通知

## 题目描述

有一张 $n$ 点 $m$ 边的无向图。点的编号从 $1$ 到 $n$，第 $i$ 条边连接点 $a_i$ 和 $b_i$。每个点都有一个属性值，初始时均为 $0$。

有 $q$ 次操作，每次操作给出操作类型 $t_i$ 和操作参数 $x_i$。

- 当 $t_i=1$ 时，将与点 $x_i$ **直接相连**的点的属性值加 $1$。
- 当 $t_i=2$ 时，将点 $x_i$ 的属性值输出，然后将该值设为 $0$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的测试数据，保证：

- $2 \le n \le 2 \times 10^5$，$1 \le m \le 2 \times 10^5$，$1 \le a_i \lt b_i \le n$；
- $1 \le q \le 2 \times 10^5$，$t_i \in \{ 1,2 \}$，$1 \le x_i \le n$。

输入数据均为整数。

## 样例 #1

### 输入

```
3 2

1 2

1 3

5

1 1

2 2

1 1

2 3

2 1```

### 输出

```
1

2

0```

## 样例 #2

### 输入

```
7 7

1 4

1 6

3 4

3 5

3 7

4 5

4 7

15

1 1

2 3

1 4

2 2

1 5

1 1

1 4

2 4

2 3

2 1

1 7

1 2

2 5

2 4

2 2```

### 输出

```
0

0

3

3

2

2

1

0```

## 样例 #3

### 输入

```
10 13

1 2

1 5

1 9

2 3

2 4

3 5

3 6

3 9

4 8

5 7

5 10

6 7

6 10

20

1 5

2 8

1 4

2 9

1 1

1 6

2 8

1 10

2 7

1 10

1 10

2 8

1 7

2 5

1 9

2 2

1 9

1 4

2 4

2 6```

### 输出

```
0

0

1

2

0

5

2

0

4```

# AI分析结果



## 算法分类
根号分治

## 题解思路与算法要点
### 核心思路
题目要求在无向图上处理两种操作：1) 给某点所有邻居加1；2) 查询并清零某点的值。采用根号分治策略，将节点按度数分为大点（度数≥√n）和小点（度数<√n），分别处理：

- **操作1（修改）**：
  - 若操作点是小点：暴力遍历所有邻居，直接修改其值。
  - 若操作点是大点：记录标记（Tag数组），暂不修改邻居。
  
- **操作2（查询）**：
  - 当前值 = 直接存储的值（小点贡献） + 相邻大点的标记总和。
  - 清零时需将值设为负的标记和，避免重复计算。

### 解决难点
1. **标记管理**：大点的修改延迟到查询时统计，避免频繁遍历高度数节点。
2. **清零处理**：查询后需将值设为相邻大点标记和的相反数，确保后续标记的正确性。
3. **预处理优化**：预先为每个节点记录相邻大点列表，查询时仅遍历这些大点。

### 算法流程
1. **预处理**：
   - 计算度数，筛选大点。
   - 为每个节点记录相邻大点列表。
2. **操作处理**：
   - 修改操作按大小点分别处理。
   - 查询操作累加大点标记并调整清零逻辑。

---

## 题解评分
### 题解1（EityDawn） ★★★★☆
- **亮点**：代码简洁，阈值取固定值400，预处理清晰。
- **不足**：注释较少，阈值选择未动态计算。

### 题解2（hgckythgcfhk） ★★★★☆
- **亮点**：使用`__builtin_sqrt`动态计算阈值，代码高度优化。
- **不足**：变量命名简略，可读性稍差。

### 题解3（BFSDFS123） ★★★★☆
- **亮点**：详细注释，结构清晰，适合理解。
- **不足**：未处理输入输出优化，可能效率略低。

---

## 最优思路提炼
**根号分治 + 延迟标记**  
- **核心逻辑**：按度数分治，小点暴力修改，大点记录标记。
- **数据结构**：邻接表存储图，`Tag`数组记录大点标记，`Fa/Heavysons`存储相邻大点。
- **查询优化**：查询时统计相邻大点标记总和，清零操作抵消标记影响。

---

## 类似题目推荐
1. **P3695 [CYANA]跳跳棋**（根号分治处理跳跃操作）
2. **P3396 哈希冲突**（分块处理模数查询）
3. **P5355 [Ynoi2017] 由乃的玉米田**（根号分治+莫队）

---

## 可视化设计（核心算法过程）
### 动画方案
1. **数据结构展示**：
   - 节点分为红（大点）、蓝（小点）。
   - 修改时，小点扩散蓝色波纹，大点标记闪烁红色。
2. **操作高亮**：
   - 修改操作：高亮操作点及其邻居。
   - 查询操作：显示当前值计算过程（小点值+大点标记）。
3. **标记流动**：
   - 大点标记以半透明红色覆盖相邻节点，查询时标记流动到目标节点。

### 复古像素风格
- **颜色方案**：8色调色板，红（#FF0000）、蓝（#0000FF）、绿（#00FF00）。
- **音效**：
  - 修改操作：短促“哔”声。
  - 查询成功：上升音阶。
  - 错误操作：低沉“嗡”声。
- **Canvas绘制**：网格布局，节点为16x16像素方块，标记以闪烁动画展示。

---

## 核心代码实现
```cpp
// 预处理大点及其相邻关系
int B = sqrt(n);
for (int u = 1; u <= n; u++) {
    for (int v : G[u]) {
        if (deg[v] > B) {
            heavy_adj[u].push_back(v); // 记录相邻大点
        }
    }
}

// 操作处理
if (op == 1) {
    if (deg[x] <= B) { // 小点：暴力修改邻居
        for (int v : G[x]) a[v]++;
    } else { // 大点：记录标记
        tag[x]++;
    }
} else {
    int sum = a[x];
    for (int v : heavy_adj[x]) sum += tag[v]; // 累加大点标记
    cout << sum << endl;
    a[x] = -sum; // 清零逻辑
}
```

---

## 总结
通过根号分治平衡操作复杂度，结合延迟标记优化查询效率，该算法在O(q√n)时间复杂度下高效处理大规模数据。预处理和标记管理是核心，正确实现需注意清零时的负值处理。

---
处理用时：81.84秒
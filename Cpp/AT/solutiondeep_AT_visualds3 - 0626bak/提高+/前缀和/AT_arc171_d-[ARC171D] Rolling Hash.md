# 题目信息

# [ARC171D] Rolling Hash

## 题目描述

给定整数 $P,B$ 满足 $P$ 是质数，$1\le B\le P-1$。

对于序列 $X=(x_1,x_2,\cdots,x_n)$，定义 $\operatorname{hash}(X)$ 的值为
$$\operatorname{hash}(X)=\left(\sum_{i=1}^nx_iB^{n-i}\right)\bmod P$$

给定 $M$ 对整数 $(L_i,R_i)(1\le i\le M)$，请问是否存在长度为 $N$ 的序列 $A=(A_1,A_2,\cdots,A_N)$ 满足：

- 对每一个 $i(1\le i\le M)$，都有
  $$\operatorname{hash}((A_{L_i},A_{L_i+1},\cdots,A_{R_i}))\not=0$$

## 说明/提示

-   $2 \leq P \leq 10^9$
-   $P$ 是质数。
-   $1 \leq B \leq P - 1$
-   $1 \leq N \leq 16$
-   $1 \leq M \leq \frac{N(N+1)}{2}$
-   $1 \leq L_i \leq R_i \leq N$
-   $(L_i, R_i) \neq (L_j, R_j)$ if $i \neq j$.
-   所有的输入都是整数。

## 样例 #1

### 输入

```
3 2 3 3

1 1

1 2

2 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 1 3 3

1 1

2 3

1 3```

### 输出

```
No```

## 样例 #3

### 输入

```
998244353 986061415 6 11

1 5

2 2

2 5

2 6

3 4

3 5

3 6

4 4

4 5

4 6

5 6```

### 输出

```
Yes```

# AI分析结果



# ARC171D Rolling Hash 题解分析

## 唯一算法分类
**图论-着色问题 / 状态压缩动态规划**

---

## 综合分析与结论

### 核心思路
将哈希约束转化为图论着色问题：每个区间约束等价于两点不能同色。通过状压DP计算图的色数是否≤P。

### 算法流程
1. **问题转化**：定义后缀哈希值 s_i，将区间哈希值约束转化为 s_l ≠ s_{r+1}，建立节点间边。
2. **预处理独立集**：标记所有可能独立染色的子集。
3. **状压DP**：计算每个子集最少颜色数，最终判断全集是否≤P。

### 难点解决
- **哈希转化**：通过数学变形将模运算约束转化为颜色不同约束。
- **色数计算**：通过状压DP枚举独立集，实现高效色数计算。

### 可视化设计
- **像素动画**：用网格表示节点集合，颜色渐变显示当前处理状态。
- **音效提示**：转移成功时播放上升音调，最终结果时播放胜利音效。
- **自动演示**：按位逐步展开子集处理过程，高亮当前处理的子集T。

---

## 题解清单（≥4星）

### rui_er（⭐⭐⭐⭐⭐）
- **亮点**：完整的状态预处理与DP实现，代码清晰高效。
- **核心代码**：预处理独立集与状压DP转移。
- **心得**：通过后缀哈希巧妙转化问题，避免直接构造序列。

### KingPowers（⭐⭐⭐⭐）
- **亮点**：数学推导详尽，明确P>n的快速判断条件。
- **核心思路**：独立集分解降低复杂度。

### Coffee_zzz（⭐⭐⭐⭐）
- **亮点**：详细推导哈希变换，强调B与P互质的关键性。
- **代码**：简明的状压DP实现，适合快速理解。

---

## 最优思路提炼
- **哈希转化技巧**：通过后缀哈希将区间约束转化为两节点颜色不同。
- **独立集状压DP**：预处理所有可能单色子集，按层累加颜色数。
- **位运算优化**：快速枚举子集，O(3ⁿ)时间复杂度在n≤16时可行。

---

## 相似题型推荐
1. **洛谷P2819**：图的m着色问题，回溯法基础。
2. **洛谷P2831**：状压DP处理集合覆盖。
3. **洛谷P4910**：独立集与覆盖问题变种。

---

## 核心代码实现
```cpp
int P, B, n, m, G[N][N], f[1 << N], g[1 << N];

int main() {
    // 输入处理与建图
    cin >> P >> B >> n >> m;
    rep(i, 1, m) {
        int l, r; cin >> l >> r;
        G[l][r+1] = G[r+1][l] = 1; // 建立无向边
    }
    if (P > n) { cout << "Yes"; return 0; }

    // 预处理独立集g[S]
    const int U = (1 << (n+1)) - 1;
    rep(S, 0, U) {
        g[S] = 1;
        rep(u, 0, n) if (S & (1<<u))
            rep(v, u+1, n) if (S & (1<<v))
                if (G[u][v]) { g[S]=0; break; }
    }

    // 状压DP计算最小颜色数
    memset(f, 0x3f, sizeof(f));
    f[0] = 0;
    rep(S, 1, U) for(int T=S; T; T=(T-1)&S)
        if (g[T]) f[S] = min(f[S], f[S^T]+1);

    cout << (f[U] <= P ? "Yes" : "No");
}
```

---

## 可视化设计要点
- **8位像素风格**：用16色调色板，节点显示为色块，边为红色线条。
- **Canvas动画**：网格布局展示状态S的二进制位，绿色高亮当前处理的子集T。
- **音效触发**：每次成功转移时播放“哔”声，最终结果时播放NES风格胜利音乐。
- **自动模式**：按二进制顺序展开状态处理，速度可调。

---
处理用时：84.72秒
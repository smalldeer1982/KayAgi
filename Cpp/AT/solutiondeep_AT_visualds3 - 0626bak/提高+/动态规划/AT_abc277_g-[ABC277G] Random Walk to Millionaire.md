# 题目信息

# [ABC277G] Random Walk to Millionaire

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc277/tasks/abc277_g

$ N $ 個の頂点と $ M $ 本の辺からなる連結かつ単純な無向グラフが与えられます。  
$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結んでいます。

高橋君は、はじめ**レベル**が $ 0 $ の状態で頂点 $ 1 $ におり、下記の行動をちょうど $ K $ 回行います。

- まず、いまいる頂点に隣接する頂点の中から、$ 1 $ つを等確率でランダムに選択し、その頂点に移動する。
- その後、移動後の頂点 $ v $ に応じて、下記のイベントが発生します。
  - $ C_v\ =\ 0 $ のとき : 高橋君のレベルが $ 1 $ だけ増加する。
  - $ C_v\ =\ 1 $ のとき : 高橋君のいまのレベルを $ X $ とする。高橋君は $ X^2 $ 円のお金を獲得する。

上記の $ K $ 回の行動の過程で高橋君が獲得するお金の合計金額の期待値を $ \mathrm{mod}\,\ 998244353 $ で出力してください（注記参照）。

## 说明/提示

### 注記

求める期待値は必ず有理数となることが証明できます。またこの問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、$ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ一つ存在することが証明できます。この $ R $ を求めてください。

### 制約

- $ 2\ \leq\ N\ \leq\ 3000 $
- $ N-1\ \leq\ M\ \leq\ \min\lbrace\ N(N-1)/2,\ 3000\rbrace $
- $ 1\ \leq\ K\ \leq\ 3000 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- $ u_i\ \neq\ v_i $
- $ i\ \neq\ j\ \implies\ \lbrace\ u_i,\ v_i\rbrace\ \neq\ \lbrace\ u_j,\ v_j\ \rbrace $
- 与えられるグラフは連結
- $ C_i\ \in\ \lbrace\ 0,\ 1\rbrace $
- 入力はすべて整数

### Sample Explanation 1

高橋君の移動経路として考えられるものは複数ありますが、ここでは例として、高橋君が頂点 $ 1 $ を始点として、$ 1\ \rightarrow\ 2\ \rightarrow\ 4\ \rightarrow\ 5\ \rightarrow\ 4\ \rightarrow\ 2\ \rightarrow\ 1\ \rightarrow\ 2\ \rightarrow\ 3 $ と移動する場合に獲得するお金の合計金額を計算します。 1. 高橋君は $ 1 $ 回目の行動で、いまいる頂点 $ 1 $ に隣接する頂点 $ 2 $ に移動します。$ C_2\ =\ 0 $ であるため、その後高橋君のレベルが $ 1 $ に上がります。 2. 高橋君は $ 2 $ 回目の行動で、いまいる頂点 $ 2 $ に隣接する頂点 $ 4 $ に移動します。$ C_4\ =\ 1 $ であるため、その後高橋君は $ 1^2\ =\ 1 $ 円を獲得します。 3. 高橋君は $ 3 $ 回目の行動で、いまいる頂点 $ 4 $ に隣接する頂点 $ 5 $ に移動します。$ C_5\ =\ 0 $ であるため、その後高橋君のレベルが $ 2 $ に上がります。 4. 高橋君は $ 4 $ 回目の行動で、いまいる頂点 $ 5 $ に隣接する頂点 $ 4 $ に移動します。$ C_4\ =\ 1 $ であるため、その後高橋君は $ 2^2\ =\ 4 $ 円を獲得します。 5. 高橋君は $ 5 $ 回目の行動で、いまいる頂点 $ 4 $ に隣接する頂点 $ 2 $ に移動します。$ C_2\ =\ 0 $ であるため、その後高橋君のレベルが $ 3 $ に上がります。 6. 高橋君は $ 6 $ 回目の行動で、いまいる頂点 $ 2 $ に隣接する頂点 $ 1 $ に移動します。$ C_1\ =\ 0 $ であるため、その後高橋君のレベルが $ 4 $ に上がります。 7. 高橋君は $ 7 $ 回目の行動で、いまいる頂点 $ 1 $ に隣接する頂点 $ 2 $ に移動します。$ C_2\ =\ 0 $ であるため、その後高橋君のレベルが $ 5 $ に上がります。 8. 高橋君は $ 8 $ 回目の行動で、いまいる頂点 $ 2 $ に隣接する頂点 $ 3 $ に移動します。$ C_3\ =\ 1 $ であるため、その後高橋君は $ 5^2\ =\ 25 $ 円を獲得します。 よって、高橋君が獲得するお金の合計金額は、$ 1\ +\ 4\ +\ 25\ =\ 30 $ 円です。

## 样例 #1

### 输入

```
5 4 8
4 5
2 3
2 4
1 2
0 0 1 1 0```

### 输出

```
89349064```

## 样例 #2

### 输入

```
8 12 20
7 6
2 6
6 4
2 1
8 5
7 2
7 5
3 7
3 5
1 8
6 3
1 4
0 0 1 1 0 0 0 0```

### 输出

```
139119094```

# AI分析结果



# [ABC277G] Random Walk to Millionaire

## 题目描述

给定一个包含 $N$ 个顶点和 $M$ 条边的连通简单无向图。  
顶点分为两种类型：$C_v=0$ 时为经验节点，$C_v=1$ 时为奖励节点。

高桥君初始在顶点 1，等级为 0，执行以下操作恰好 $K$ 次：
1. 从当前顶点的相邻顶点中随机选择一个移动
2. 移动后根据顶点类型：
   - 经验节点：等级 +1
   - 奖励节点：获得当前等级 $X$ 的平方金额（$X^2$ 元）

求获得金额的期望值，答案对 $998244353$ 取模。

### 输入格式
第一行包含 $N,M,K$，随后 $M$ 行给出边，最后一行给出每个顶点的 $C_i$ 值。

### 输出格式
输出期望值的模数结果。

### 数据范围
- $2 \leq N \leq 3000$
- $N-1 \leq M \leq 3000$
- $1 \leq K \leq 3000$

---

## 算法分类：线性DP

## 题解分析

### 核心思路
采用三维线性动态规划，维护三个关键状态：
- `dp[i][u][0]`: 第 $i$ 步在节点 $u$ 时等级的零次方期望（即概率）
- `dp[i][u][1]`: 第 $i$ 步在节点 $u$ 时等级的一次方期望
- `dp[i][u][2]`: 第 $i$ 步在节点 $u$ 时等级的二次方期望

通过数学展开式 $(x+1)^2 = x^2 + 2x + 1$ 将平方期望分解为低次项组合，避免直接维护高维等级状态。

### 状态转移
1. **移动阶段**：将前一步各邻接节点的状态按概率转移到当前节点
2. **类型处理**：
   - 经验节点：更新状态为升级后的期望值
   - 奖励节点：将当前二次方期望累加到总答案

### 解决难点
- 利用期望线性性拆分平方项，将状态维度从 $O(K \cdot N^2)$ 降为 $O(K \cdot N)$
- 分阶段处理移动和类型操作，确保状态转移的正确性

---

## 精选题解（≥4星）

### 1. liangbowen（★★★★★）
**亮点**：  
- 代码结构清晰，分步处理转移与类型判断
- 使用邻接表高效处理图结构
```cpp
for (int i = 1; i <= k; i++) {
    for (int u = 1; u <= n; u++) {
        for (int _ = head[u]; _; _ = e[_].nxt) {
            int v = e[_].now;
            (p0[i][u] += p0[i-1][v] * inv[v]) %= mod;
            (p1[i][u] += p1[i-1][v] * inv[v]) %= mod;
            (p2[i][u] += p2[i-1][v] * inv[v]) %= mod;
        }
        if (a[u]) ans = (ans + p2[i][u]) % mod;
        else {
            (p2[i][u] += 2 * p1[i][u] + p0[i][u]) %= mod;
            (p1[i][u] += p0[i][u]) %= mod;
        }
    }
}
```

### 2. DengDuck（★★★★）
**亮点**：  
- 使用三维数组分开维护状态
- 在转移时显式处理边的关系
```cpp
for (int j = 1; j <= 2*m; j++) {
    LL u = x[j], v = y[j];
    LL k = inv[du[u]];
    if (c[v] == 0) {
        Add(f[i][v][0], f[i-1][u][0]*k%mod);
        Add(f[i][v][1], (f[i-1][u][0] + f[i-1][u][1])%mod*k%mod);
        Add(f[i][v][2], (f[i-1][u][0] + 2*f[i-1][u][1] + f[i-1][u][2])%mod*k%mod);
    }
    if (c[v] == 1) {
        Add(ans, f[i][v][2]);
    }
}
```

### 3. Sharpsmile（★★★★）
**亮点**：  
- 详细推导状态转移的数学原理
- 通过分层处理降低理解难度

---

## 关键技巧
1. **平方拆解**：利用 $(x+1)^2 = x^2 + 2x + 1$ 将高次期望分解为低次项组合
2. **概率分流**：通过邻接节点的度数倒数实现概率平均分配
3. **分阶段处理**：将移动和类型操作分离，避免状态干扰

---

## 同类题目
1. **P1654 OSU!**  
   维护连续成功次数的期望，计算得分平方的期望
2. **CF235B Let's Play Osu!**  
   类似OSU!的得分模型，处理连续命中奖励
3. **P1365 WJMZBMR打osu!**  
   动态规划处理概率与期望的组合计算

---

## 可视化设计
### 动态规划矩阵动画
- **界面**：8位像素风格，每个节点显示为独立方格，颜色表示状态强度
- **转移高亮**：移动阶段用流动光效显示状态转移路径
- **类型反馈**：经验节点显示升级特效，奖励节点显示金币飞入总金额
- **音效设计**：
  - 状态转移时播放电子音效
  - 累积奖励时播放金币碰撞声
  - 错误操作时播放警示音

### 交互功能
- **步进控制**：支持逐帧播放/暂停/加速
- **状态追踪**：点击任意节点查看详细状态变化曲线
- **对比模式**：并排显示不同题解的转移过程差异

---

## 核心代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;
const int MOD = 998244353;
const int MAXN = 3005;

vector<int> adj[MAXN];
int c[MAXN], inv_deg[MAXN];
long long dp0[MAXN][MAXN], dp1[MAXN][MAXN], dp2[MAXN][MAXN];

long long qpow(long long a, int b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    for (int i = 1; i <= n; ++i) {
        cin >> c[i];
        inv_deg[i] = qpow(adj[i].size(), MOD-2);
    }

    dp0[0][1] = 1;
    long long ans = 0;
    
    for (int i = 1; i <= k; ++i) {
        for (int u = 1; u <= n; ++u) {
            for (int v : adj[u]) {
                dp0[i][v] = (dp0[i][v] + dp0[i-1][u] * inv_deg[u]) % MOD;
                dp1[i][v] = (dp1[i][v] + dp1[i-1][u] * inv_deg[u]) % MOD;
                dp2[i][v] = (dp2[i][v] + dp2[i-1][u] * inv_deg[u]) % MOD;
            }
        }
        for (int u = 1; u <= n; ++u) {
            if (c[u] == 0) {
                dp2[i][u] = (dp2[i][u] + 2 * dp1[i][u] + dp0[i][u]) % MOD;
                dp1[i][u] = (dp1[i][u] + dp0[i][u]) % MOD;
            } else {
                ans = (ans + dp2[i][u]) % MOD;
            }
        }
    }
    
    cout << ans << endl;
    return 0;
}
```

---
处理用时：217.05秒
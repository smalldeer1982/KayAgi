# 题目信息

# [ABC319G] Counting Shortest Paths

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc319/tasks/abc319_g

$ N $ 頂点の無向完全グラフ $ G $ に対して下記の操作を行います。

> 各 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、頂点 $ u_i $ と 頂点 $ v_i $ を結ぶ無向辺を削除する。

その後の $ G $ において、頂点 $ 1 $ から頂点 $ N $ へのパスが存在するかどうかを判定し、 存在する場合は頂点 $ 1 $ から 頂点 $ N $ への最短パスの個数を $ 998244353 $ で割った余りを求めてください。

ここで、頂点 $ 1 $ から 頂点 $ N $ への最短パスとは、頂点 $ 1 $ から頂点 $ N $ へのパスであって含む辺の本数が最小であるものです。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min\lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- $ u_i\ \neq\ v_i $
- $ i\ \neq\ j\ \implies\ \lbrace\ u_i,\ v_i\ \rbrace\ \neq\ \lbrace\ u_j,\ v_j\ \rbrace $
- 入力はすべて整数

### Sample Explanation 1

操作後の $ G $ における頂点 $ 1 $ から頂点 $ N $ への最短パスは、$ 3 $ 本の辺を含む下記の $ 3 $ 個のパスです。 - 頂点 $ 1 $ $ \rightarrow $ 頂点 $ 2 $ $ \rightarrow $ 頂点 $ 3 $ $ \rightarrow $ 頂点 $ 6 $ - 頂点 $ 1 $ $ \rightarrow $ 頂点 $ 2 $ $ \rightarrow $ 頂点 $ 5 $ $ \rightarrow $ 頂点 $ 6 $ - 頂点 $ 1 $ $ \rightarrow $ 頂点 $ 4 $ $ \rightarrow $ 頂点 $ 5 $ $ \rightarrow $ 頂点 $ 6 $

### Sample Explanation 2

操作後の $ G $ には辺が $ 1 $ 本もありません。 頂点 $ 1 $ から頂点 $ N $ へのパスが存在しないため `-1` を出力します。

## 样例 #1

### 输入

```
6 7
4 3
1 3
2 4
1 6
4 6
5 1
6 2```

### 输出

```
3```

## 样例 #2

### 输入

```
4 6
1 2
1 3
1 4
2 3
2 4
3 4```

### 输出

```
-1```

# AI分析结果



0. **题目翻译**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   # [ABC319G] 统计最短路径数  

   ## 题目描述  

   给定一个包含 $N$ 个顶点的无向完全图 $G$，执行以下操作：  

   > 对于每个 $i=1,2,\ldots,M$，删除顶点 $u_i$ 和 $v_i$ 之间的无向边。  

   操作后的图 $G$ 中，判断是否存在从顶点 $1$ 到顶点 $N$ 的路径。若存在，求该最短路径的数量对 $998244353$ 取模的结果。  

   最短路径定义为包含边数最少的路径。  

   ## 输入格式  
   - 第一行两个整数 $N,M$  
   - 接下来 $M$ 行每行两个整数 $u_i,v_i$  

   ## 数据范围  
   - $2 \le N \le 2 \times 10^5$  
   - $0 \le M \le \min(2 \times 10^5, N(N-1)/2)$  

   ---

1. **唯一算法分类**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   **线性DP**  

2. **综合分析与结论**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   **核心思路**  
   - **分层BFS**：通过广度优先搜索分层确定每个节点的最短距离  
   - **动态规划统计路径**：维护各层的路径数总和，利用补图特性快速计算  

   **关键难点与解决方案**  
   | 难点 | 解决方案 |  
   |---|---|  
   | 大规模图无法显式存储 | 用集合维护未访问节点，通过补图边反向计算可达性 |  
   | 路径数统计复杂度高 | 维护各层的路径总数（sum数组），通过「总和 - 非法边贡献」计算 |  
   | 删除边的快速查询 | 邻接表存储被删边，哈希表快速判断边是否存在 |  

   **状态转移方程**  
   ```math  
   f[v] = \underbrace{\sum_{dis[u]=k} f[u]}_{\text{完全图总贡献}} - \underbrace{\sum_{(u,v)\in G'} f[u]}_{\text{被删边的非法贡献}}  
   ```  
   其中 $dis[v] = k+1$，$G'$ 表示被删除边的集合  

   **可视化设计**  
   - **动态网格展示**：  
     ![分层DP示意图](https://cdn.luogu.com.cn/upload/image_hosting/j1cr5svg.png)  
     - 黄色高亮当前处理的层  
     - 红色标记被删除边影响的转移路径  
     - 绿色动态更新sum值  
   - **复古像素风格**：  
     - 8-bit音效：节点入队时播放短促「哔」声，路径数更新时播放「叮」声  
     - Canvas绘制：每个节点显示为16x16像素方块，层次按Y轴排列  
     - 自动演示模式：按层次逐步展开，每层间隔1秒展示计算过程  

3. **题解清单（≥4星）**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   | 作者 | 星级 | 核心亮点 |  
   |---|---|---|  
   | RiceFruit | ★★★★★ | 首创分层维护sum数组思想，代码简洁高效 |  
   | Flanksy | ★★★★☆ | 使用unordered_set优化集合操作，时空平衡优秀 |  
   | User_Unauthorized | ★★★★☆ | 数学式推导状态转移，理论分析透彻 |  

   **个人心得摘录**  
   > _"被 after_contest 数据制裁后发现，取模运算可能将合法解误判为0，通过双重取模解决"_ —— Genius_Star

4. **代码实现与核心逻辑**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   ```cpp  
   // RiceFruit 题解核心代码  
   vector<int> p[maxn]; // 按距离分层的节点  
   int sum = 0;         // 当前层的总路径数  

   // 分层处理  
   for(int i=2; i<=max_dis; i++){  
       // 初始化本层所有节点的路径数为上一层的总和  
       for(int x : p[i]) f[x] = sum;  

       // 减去被删边的非法贡献  
       for(int x : p[i-1]){  
           for(int y : deleted_edges[x]){  
               if(dis[y] == i)  
                   f[y] = (f[y] - f[x] + mod) % mod;  
           }  
       }  

       // 更新当前层总和  
       sum = accumulate(p[i].begin(), p[i].end(), 0LL) % mod;  
   }  
   ```

5. **相似题目推荐**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   1. [CF920E] 补图连通性  
   2. [CF1242B] 0-1 MST  
   3. [洛谷P1144] 最短路计数  

6. **可视化代码片段（Canvas动画）**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   ```javascript  
   // 绘制分层节点  
   function drawLayer(ctx, nodes, y, color) {  
       nodes.forEach((node, x) => {  
           ctx.fillStyle = color;  
           ctx.fillRect(50 + x*30, 50 + y*60, 25, 25);  
           ctx.fillText(`f=${node.f}`, 55 + x*30, 70 + y*60);  
       });  
   }  

   // 播放音效  
   function playSound(type) {  
       const beep = new Audio('data:audio/wav;base64,UklGRl9...');  
       if(type == 'update') beep.play();  
   }  
   ```

   **交互设计**  
   - 空格键暂停/继续  
   - 方向键控制动画速度  
   - 按H键高亮显示当前处理层  

---

通过上述分析，我们构建了一个结合BFS分层与线性DP的高效解法，其核心在于利用补图的特性快速计算合法路径数。该模式可推广至各类补图最短路问题，展现了逆向思维与动态维护的巧妙结合。

---
处理用时：95.46秒
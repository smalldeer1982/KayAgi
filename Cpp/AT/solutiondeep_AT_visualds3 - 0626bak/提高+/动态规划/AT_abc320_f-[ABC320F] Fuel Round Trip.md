# 题目信息

# [ABC320F] Fuel Round Trip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc320/tasks/abc320_f

数直線上の座標 $ 0 $ から座標 $ X_N $ まで行き、折り返して座標 $ 0 $ まで帰ってくる計画を立てています。ただし、往路では正の方向、復路では負の方向にしか進めません。  
 移動は車で行います。車は距離 $ 1 $ 進むごとに $ 1 $ リットルの燃料を消費します。燃料は $ H $ リットルまで所持することができ、燃料を所持していない状態で進むことはできません。  
 各 $ i\ =\ 1,\ 2,\ \ldots,\ N-1 $ について、座標 $ X_i $ にはガソリンスタンドがあり、$ P_i $ 円払うと $ F_i $ リットルの燃料が得られます。ただし、$ H $ リットルを超えて燃料を所持することはできません。より厳密には、$ x $ リットルの燃料を持っているときに座標 $ X_i $ にあるガソリンスタンドを使うと $ P_i $ 円を払う必要があり、持っている燃料は $ \min(x\ +\ F_i,\ H) $ リットルとなります。 各ガソリンスタンドは、**往路と復路で合わせて** $ 1 $ 回までしか使うことができません。  
 はじめに燃料を $ H $ リットル所持しているとき、この計画を達成することができるか判定し、可能ならば必要な金額の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ H\ \leq\ 300 $
- $ 0\ <\ X_1\ <\ X_2\ <\ \ldots\ <\ X_N\ \leq\ 10^5 $
- $ 1\ \leq\ P_i\ \leq\ 10^5 $
- $ 1\ \leq\ F_i\ \leq\ H $
- 入力される数値はすべて整数
 
### Sample Explanation 1

往路で座標 $ 5 $ の、復路で座標 $ 9 $ のガソリンスタンドを用いることにより合計 $ 9 $ 円払うことで計画を達成することができます。 計画を達成するためにかかる金額を $ 8 $ 円以下にすることはできません。往路と復路で同じガソリンスタンドを使うことができないことに注意してください。

## 样例 #1

### 输入

```
4 10

2 5 9 11

8 10

5 8

4 9```

### 输出

```
9```

## 样例 #2

### 输入

```
1 1

100000```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 20

4 13 16 18 23

1 16

2 8

4 11

8 13```

### 输出

```
13```

# AI分析结果



0. **题目翻译**  
   
---
# [ABC320F] Fuel Round Trip

## 题目描述

在数直线上的坐标 $0$ 出发，计划前往坐标 $X_N$ 后折返回到坐标 $0$。往路只能向正方向移动，返路只能向负方向移动。  
车辆每移动 $1$ 单位距离消耗 $1$ 升燃料，初始携带 $H$ 升燃料（最大容量），燃料耗尽时无法移动。  
在 $X_1,X_2,...,X_{N-1}$ 处设有加油站，每个加油站可支付 $P_i$ 日元补充 $F_i$ 升燃料（不可超过 $H$ 升上限）。每个加油站在往返途中合计最多使用一次。  
求完成往返行程的最小费用，若不可行则输出 $-1$。

## 输入输出样例

### 样例1
输入：
```
4 10
2 5 9 11
8 10
5 8
4 9
```
输出：
```
9
```

### 样例2
输入：
```
1 1
100000
```
输出：
```
-1
```

---

1. **唯一算法分类**  
   线性DP

---

2. **综合分析与结论**  

### 核心思路与难点解析
本题需要同时处理往返路径的油量消耗与加油站使用限制，核心难点在于：
- **往返路径耦合**：加油站使用次数需在往返路径中共享
- **状态维度爆炸**：需同时记录往路与返路的油量状态

### 关键算法设计
采用三维动态规划 `dp[i][j][k]`，表示：
- 到达第 `i` 个加油站时
- 往路剩余油量为 `j`
- 返路剩余油量为 `k` 的最小费用

#### 状态转移方程
设相邻加油站间距为 `d = X[i+1] - X[i]`，转移分三种情况：
```math
dp[i+1][j-d][k+d] = \min(\text{不加油})
dp[i+1][\min(j+F_i,H)-d][k+d] = \min(\text{往路加油}+P_i)
dp[i+1][j-d][\max(k-F_i+d,0)] = \min(\text{返路加油}+P_i)
```

### 可视化设计要点
- **像素网格**：用Canvas绘制三维DP表，每个立方体单元表示状态 `(i,j,k)`
- **颜色编码**：
  - 红色：不可达状态
  - 绿色：当前最优状态
  - 黄色：正在更新的状态
- **音效触发**：
  - 水滴声：状态转移
  - 金币声：费用更新
  - 警报声：无解状态
- **自动演示模式**：AI自动选择最优转移路径，展示油量增减动画

---

3. **题解清单 (≥4星)**  

| 题解作者 | 星级 | 核心亮点 |
|---------|------|---------|
| Zi_Gao  | ★★★★★ | 倒序DP设计巧妙，代码结构清晰 |
| LCat90  | ★★★★☆ | 正向DP定义直观，状态转移易理解 | 
| SoyTony | ★★★★☆ | 数学推导严谨，处理返程加油边界条件精准 |

---

4. **最优代码实现**  

### 核心代码片段（Zi_Gao）
```cpp
// 初始化
memset(dp, 0x3f, sizeof(dp));
for(int i=0; i<=h; ++i)
    dp[n][i][i] = 0;

// 倒序DP转移
for(int i=n-1; ~i; --i){
    for(int j=0; j<=h; ++j)
        for(int k=0; k<=h; ++k){
            int d = x[i+1] - x[i];
            if(j+d <= h && k >= d){
                // 不加油
                dp[i][j][k-d] = min(dp[i][j][k-d], dp[i+1][j+d][k]);
                // 往路加油
                int nj = min(j+d + F[i], h);
                dp[i][nj][k-d] = min(..., dp[i+1][j][k] + P[i]);
                // 返路加油
                int nk = max(k-d - F[i], 0);
                dp[i][j+d][nk] = min(..., dp[i+1][j][k] + P[i]);
            }
        }
    // 前缀最小值优化
    for(int j=1; j<=h; ++j)
        for(int k=h; k>=0; --k)
            dp[i][j][k] = min(dp[i][j][k], dp[i][j-1][k+1]);
}
```

---

5. **相似题目推荐**  
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)  
2. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156)  
3. [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)  

---

6. **可视化代码示例（伪JS）**  
```javascript
// Canvas初始化
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const COLOR_SCHEME = {
  base: '#2c3e50',     // 基础色
  active: '#e74c3c',   // 当前状态
  optimal: '#2ecc71'   // 最优状态
};

// 绘制DP状态网格
function drawDPGrid(i_layer) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for(let j=0; j<=H; j++){
    for(let k=0; k<=H; k++){
      const color = dp[i][j][k] === INF ? COLOR_SCHEME.base : 
                   (isOptimal(i,j,k) ? COLOR_SCHEME.optimal : COLOR_SCHEME.active);
      ctx.fillStyle = color;
      ctx.fillRect(j*10, k*10, 8, 8); // 像素块绘制
    }
  }
  // 播放音效
  if(dpUpdated) playSound('drop.wav');
}
```

---
处理用时：69.29秒
# 题目信息

# [ABC342F] Black Jack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc342/tasks/abc342_f

あなたとディーラーでゲームをします。 ゲームは $ 1 $ 以上 $ D $ 以下の整数が等確率で出る $ D $ 面サイコロ、$ 0 $ で初期化された変数 $ x,y $ を用いて以下のように行われます。

- あなたはサイコロを振り、出た目を $ x $ に加算する操作を好きな回数行える。ここで、あなたは操作を行うたびに次の操作を行うかを選択できる。
- その後、ディーラーは $ y\ <\ L $ を満たす限り、サイコロを振り、出た目を $ y $ に加算する操作を繰り返す。
- $ x\ >\ N $ の場合あなたの負けである。そうでない場合、$ y\ >\ N $ または $ x\ >\ y $ のいずれかを満たす場合あなたの勝ちで、どちらも満たさない場合あなたの負けである。
 
あなたが勝率を最大化するように適切に行動する際、勝率を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\leq\ L\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ D\ \leq\ N $
 
### Sample Explanation 1

$ x $ が $ 2 $ 以下の場合操作を続けるという戦略が最適であることが証明できます。

## 样例 #1

### 输入

```
3 2 2```

### 输出

```
0.468750000000000```

## 样例 #2

### 输入

```
200000 200000 200000```

### 输出

```
0.999986408692793```

# AI分析结果



# 题目中文翻译

## 题目描述

你和庄家进行一个游戏。游戏使用一个 $D$ 面的骰子（每个面为 $1$ 到 $D$ 的整数，等概率出现），以及初始化为 $0$ 的两个变量 $x$ 和 $y$。游戏规则如下：

1. **你的回合**：你可以多次掷骰子，将结果累加到 $x$。每次掷骰后，你可以选择继续或停止。
2. **庄家的回合**：当 $y < L$ 时，庄家会持续掷骰子并将结果累加到 $y$，直到 $y \geq L$。
3. **胜负判定**：
   - 若 $x > N$，你输。
   - 否则，若 $y > N$ 或 $x > y$，你赢；否则你输。

求你在采取最优策略时的最大胜率。

### 输入格式
输入三个整数 $N, L, D$。

### 输出格式
输出一个浮点数表示最大胜率，保留至少十位小数。

### 样例解释
样例1中，当 $x \leq 2$ 时继续掷骰子是最优策略，胜率约为 0.46875。

---

## 算法分类
**线性动态规划（线性DP）**

---

## 综合分析与结论

### 核心思路
1. **概率逆向递推**：定义 $dp_i$ 为当前 $x=i$ 时的最大胜率。倒序计算 $dp_i$，每个状态考虑两种选择：
   - **停止**：根据庄家的概率分布 $g$ 计算当前胜率。
   - **继续**：取后续 $D$ 个状态的期望胜率。
2. **庄家概率分布 $g$**：通过动态规划结合树状数组/线段树优化区间操作，高效计算 $g_i$（庄家最终和为 $i$ 的概率）。
3. **前缀和优化**：在计算 $dp$ 时维护滑动窗口的和，避免重复计算。

### 关键难点与解决
- **难点1：高效计算 $g$ 数组**
  - 庄家操作固定但涉及区间累加，暴力计算为 $O(LD)$，不可行。
  - **解决方案**：使用树状数组维护区间加操作，将复杂度优化至 $O(N \log N)$。
- **难点2：状态转移的优化**
  - 计算 $dp_i$ 时需要快速求 $D$ 个后续状态的均值。
  - **解决方案**：维护滑动窗口和，倒序递推时动态调整窗口。

### 可视化设计
- **动态网格展示**：将 $dp$ 和 $g$ 数组以网格形式呈现，每个单元格显示当前值。
- **颜色标记**：
  - **红色**：当前正在计算的 $dp_i$ 或 $g_i$。
  - **绿色**：受当前操作影响的区间（如 $g$ 的区间加操作）。
- **音效触发**：
  - **区间加**：播放短促的“滴”声。
  - **状态更新**：成功更新最优解时播放上扬音效。

---

## 题解评分（≥4星）

### 1. 作者：Otue（★★★★★）
- **亮点**：
  - 完整推导状态转移方程，明确分离“继续”与“停止”两种选择。
  - 使用树状数组优化区间操作，代码结构清晰。
  - 提供详细的概率计算示例（如样例1的胜率推导）。

### 2. 作者：WaterSun（★★★★☆）
- **亮点**：
  - 通过前缀和简化庄家概率分布的计算。
  - 代码中直接维护滑动窗口，减少空间占用。

### 3. 作者：Symbolize（★★★★☆）
- **亮点**：
  - 代码简洁，直接通过前缀和优化 $g$ 数组。
  - 使用注释明确分离概率计算模块，可读性强。

---

## 核心代码实现

### 庄家概率计算（树状数组优化）
```cpp
struct Fenwick {
    double tr[N];
    void modify(int l, int r, double v) {
        for (int i=l; i<=r; i++) tr[i] += v;
    }
    double query(int x) {
        double res = 0;
        for (; x>0; x-=x&-x) res += tr[x];
        return res;
    }
} T;

// 计算 g 数组
g[0] = 1.0;
for (int i=0; i<L; i++) {
    double p = T.query(i);
    T.modify(i+1, i+D, p/D); // 区间加操作
    T.clear(i); // 清零已处理的节点
}
```

### 玩家 DP 递推
```cpp
double sum = 0.0;
for (int i=MAX; i>=0; i--) {
    if (i > N) dp[i] = 0;
    else {
        double stop = (i ? g[i-1] : 0) + (1 - g[N]);
        dp[i] = max(stop, sum/D);
    }
    sum += dp[i];
    if (i+D <= MAX) sum -= dp[i+D];
}
```

---

## 同类型题目推荐
1. **CF678D**：骰子期望问题，需结合线性DP与概率计算。
2. **AT4521**：博弈论中的最优策略设计，涉及逆向DP。
3. **Luogu P1850**：概率DP与期望计算，含复杂状态转移。

---

## 可视化代码片段（Canvas 绘制）

```javascript
// 绘制 DP 网格
function drawGrid(ctx, dp, g) {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    for (let i=0; i<dp.length; i++) {
        const x = (i % 20) * 50;
        const y = Math.floor(i/20) * 50;
        ctx.fillStyle = `hsl(${dp[i]*120}, 70%, 50%)`;
        ctx.fillRect(x, y, 45, 45);
        ctx.fillText(dp[i].toFixed(2), x+5, y+20);
    }
}
// 触发音效（Web Audio API）
function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---

## 个人心得摘录
- **Otue**：调试时发现未及时清零 $g$ 数组的前 $L$ 项导致概率错误，强调边界检查的重要性。
- **Symbolize**：通过手算样例1的 $g$ 分布验证树状数组的正确性，体现测试用例对概率题的关键作用。

---
处理用时：80.46秒
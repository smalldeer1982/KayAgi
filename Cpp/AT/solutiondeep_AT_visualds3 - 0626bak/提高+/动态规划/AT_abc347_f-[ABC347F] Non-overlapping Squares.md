# 题目信息

# [ABC347F] Non-overlapping Squares

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc347/tasks/abc347_f

$ N\times\ N $ のマス目があり、上から $ i $ 行目、左から $ j $ 列目 $ (1\leq\ i,j\leq\ N) $ のマスには整数 $ A\ _\ {i,j} $ が書かれています。

整数 $ M $ が与えられます。 $ M\times\ M $ のマス目を重ならないように $ 3 $ つ選ぶときの、選んだマス目に書かれている整数の総和としてありえる最大値を求めてください。

 問題の厳密な定義 整数の $ 6 $ つ組 $ (i\ _\ 1,j\ _\ 1,i\ _\ 2,j\ _\ 2,i\ _\ 3,j\ _\ 3) $ が次の $ 3 $ つの条件を満たしているとき、**良い $ 6 $ つ組**ということにします。 - $ 1\leq\ i\ _\ k\leq\ N-M+1\ (k=1,2,3) $
- $ 1\leq\ j\ _\ k\leq\ N-M+1\ (k=1,2,3) $
- $ k\neq\ l\ (k,l\in\lbrace1,2,3\rbrace) $ ならば、$ \lbrace(i,j)\mid\ i\ _\ k\leq\ i\lt\ i\ _\ k+M\wedge\ j\ _\ k\leq\ j\lt\ j\ _\ k+M\rbrace $ と $ \lbrace(i,j)\mid\ i\ _\ l\leq\ i\lt\ i\ _\ l+M\wedge\ j\ _\ l\leq\ j\lt\ j\ _\ l+M\rbrace $ に共通部分はない
 
 良い $ 6 $ つ組 $ (i\ _\ 1,j\ _\ 1,i\ _\ 2,j\ _\ 2,i\ _\ 3,j\ _\ 3) $ に対する値 $ \displaystyle\ \sum\ _\ {k=1}\ ^\ 3\sum\ _\ {i=i\ _\ k}\ ^\ {i\ _\ k+M-1}\sum\ _\ {j=j\ _\ k}\ ^\ {j\ _\ k+M-1}A\ _\ {i,j} $ の最大値を求めてください。 この問題の制約のもとで良い $ 6 $ つ組が存在することが示せます。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 1000 $
- $ 1\leq\ M\leq\ N/2 $
- $ 0\leq\ A\ _\ {i,j}\leq10\ ^\ 9 $
- 入力はすべて整数
 
### Sample Explanation 1

与えられたグリッドから、以下の図のように $ 3\times3 $ のマス目を $ 3 $ つ選ぶと（これは $ (i\ _\ 1,j\ _\ 1,i\ _\ 2,j\ _\ 2,i\ _\ 3,j\ _\ 3)=(1,5,2,1,5,2) $ とすることに対応します）、選んだマス目に書かれている数の合計は $ 154 $ となります。 ![](https://img.atcoder.jp/abc347/f24ee82455befb7c9af500437f79cde8.png) 問題文の条件を満たす選び方であって選んだマス目に書かれている数の合計が $ 155 $ 以上であるものは存在しないため、$ 154 $ を出力してください。

### Sample Explanation 2

以下のように選ぶのが最適です。 ![](https://img.atcoder.jp/abc347/d380b6de908ba5259451d798e7851be3.png)

### Sample Explanation 3

以下のように選ぶのが最適です。 ![](https://img.atcoder.jp/abc347/592c9536ace6712dd7532131b8da15be.png)

## 样例 #1

### 输入

```
7 3

3 1 4 1 5 9 2

6 5 3 5 8 9 7

9 3 2 3 8 4 6

2 6 4 3 3 8 3

2 7 9 5 0 2 8

8 4 1 9 7 1 6

9 3 9 9 3 7 5```

### 输出

```
154```

## 样例 #2

### 输入

```
7 1

3 1 4 1 5 9 2

6 5 3 5 8 9 7

9 3 2 3 8 4 6

2 6 4 3 3 8 3

2 7 9 5 0 2 8

8 4 1 9 7 1 6

9 3 9 9 3 7 5```

### 输出

```
27```

## 样例 #3

### 输入

```
16 4

74 16 58 32 97 52 43 51 40 58 13 24 65 11 63 29

98 75 40 77 15 50 83 85 35 46 38 37 56 38 63 55

95 42 10 70 53 40 25 10 70 32 33 19 52 79 74 58

33 91 53 11 65 63 78 77 81 46 81 63 11 82 55 62

39 95 92 69 77 89 14 84 53 78 71 81 66 39 96 29

74 26 60 55 89 35 32 64 17 26 74 92 84 33 59 82

23 69 10 95 94 14 58 58 97 95 62 58 72 55 71 43

93 77 27 87 74 72 91 37 53 80 51 71 37 35 97 46

81 88 26 79 78 30 53 68 83 28 59 28 74 55 20 86

93 13 25 19 53 53 17 24 69 14 67 81 10 19 69 90

88 83 62 92 22 31 27 34 67 48 42 32 68 14 96 87

44 69 25 48 68 42 53 82 44 42 96 31 13 56 68 83

63 87 24 75 16 70 63 99 95 10 63 26 56 12 77 49

94 83 69 95 48 41 40 97 45 61 26 38 83 91 44 31

43 69 54 64 20 60 17 15 62 25 58 50 59 63 88 70

72 95 21 28 41 14 77 22 64 78 33 55 67 51 78 40```

### 输出

```
3295```

# AI分析结果



# [ABC347F] 不重叠的三个正方形

## 题目描述

给定一个 $N \times N$ 的网格，每个格子 $(i,j)$ 包含整数 $A_{i,j}$。要求选出三个互不重叠的 $M \times M$ 子网格，使得这三个子网格中所有数的总和最大。子网格的选取需满足以下条件：

1. 每个子网格的左上角坐标 $(i_k,j_k)$ 满足 $1 \leq i_k \leq N-M+1$ 和 $1 \leq j_k \leq N-M+1$。
2. 三个子网格的区域不能有任何重叠部分。

输出可能的最大总和。

### 输入格式
输入包含：
- 第一行两个整数 $N, M$。
- 接下来 $N$ 行，每行 $N$ 个整数表示网格中的数值。

### 输出格式
输出最大总和。

### 数据范围
- $2 \leq N \leq 1000$
- $1 \leq M \leq \lfloor N/2 \rfloor$
- $0 \leq A_{i,j} \leq 10^9$

---

## 唯一算法分类
**无算法分类**

---

## 综合分析与结论

### 核心思路与难点
核心思路是通过预处理所有可能的 $M \times M$ 子网格和，并利用几何分割将问题转化为多个独立区域的最值查询。主要难点在于：

1. **布局分类**：三个子网格的摆放必须满足不重叠条件，共有 6 种典型布局（如水平分割、垂直分割、L型分割等）。
2. **高效查询**：需要快速获取任意分割区域内的最大子网格和。

### 关键算法步骤
1. **二维前缀和预处理**：快速计算任意 $M \times M$ 子网格的和。
2. **区域最值预处理**：
   - 预处理左上、右上、左下、右下四个方向的最大子网格和数组。
   - 预处理行/列方向的最大值数组，用于快速查询水平或垂直分割后的最值。
3. **旋转网格处理**：将网格旋转 4 次（0°, 90°, 180°, 270°），统一处理不同方向的分割情况。
4. **枚举分割线**：在每种旋转状态下枚举分割线，计算三种区域的最值之和。

### 动态规划与预处理
- **状态定义**：定义 `ul[i][j]` 表示左上角在 $(i,j)$ 之前的最大子网格和。
- **转移方程**：`ul[i][j] = max(ul[i-1][j], ul[i][j-1], sum[i][j])`，其他方向类似。
- **数据结构**：二维数组存储各方向的最值，支持 $O(1)$ 查询。

### 可视化设计思路
1. **网格展示**：用 Canvas 绘制网格，不同颜色标记当前处理的子网格。
2. **动态分割线**：高亮分割线并逐步展示三种区域的划分过程。
3. **最值标记**：用闪烁效果突出当前最大值的子网格。
4. **复古像素风格**：采用 8 位色彩（如深蓝、浅蓝、橙色）区分不同区域，音效提示最值更新。

---

## 题解清单 (≥4星)

### 1. MrPython 的题解（5星）
- **亮点**：通过网格旋转统一处理所有方向，代码复用率高；利用 DP 数组预处理各方向最值，逻辑清晰。
- **关键代码**：
  ```cpp
  vector<vector<uli>> rotate(...) // 网格旋转函数
  uli f(...) // 处理特定方向的分割情况
  ```

### 2. wangbinfeng 的题解（4.5星）
- **亮点**：参考了 P3625 题解，定义了 6 种布局情况；使用四方向最值数组简化查询。
- **代码片段**：
  ```cpp
  dat[0][i][j] = max(...) // 左上方向预处理
  ```

### 3. elbissoPtImaerD 的题解（4星）
- **亮点**：显式处理了六种分割情况，枚举分割线时结合行列最值数组。
- **关键思路**：
  ```cpp
  ans = max(ans, _Q(...)) // 枚举分割线求最大和
  ```

---

## 最优思路提炼

### 关键技巧
1. **几何分割**：将问题分解为有限种布局情况，每种情况对应特定的分割线组合。
2. **旋转复用**：通过旋转网格避免重复编写不同方向的代码。
3. **四方向最值数组**：预处理左上、右上、左下、右下的区域最大值，支持快速查询。
4. **行列最值优化**：单独预处理每行/列的最大值数组，加速水平或垂直分割的查询。

### 实现步骤
1. **计算所有子网格和**：使用二维前缀和。
2. **预处理四方向最值**：动态规划填充 `ul, ur, bl, br` 数组。
3. **处理旋转与分割**：对每个旋转后的网格，枚举分割线并计算三种区域的最值之和。

---

## 同类型题与算法套路

### 相似题目
1. **P3625 [APIO2009] 采油区域**：在网格中选择三个不重叠的矩形区域，最大化总和。
2. **CF1398D Colored Rectangles**：选择不重叠的矩形对，最大化总价值。
3. **洛谷P1433 吃奶酪**：平面中选择多个点的最优路径问题。

### 通用解法
对于涉及不重叠区域的最值问题，典型解法包括：
1. **几何分割**：将问题分解为有限种布局，分别处理。
2. **方向预处理**：利用动态规划预处理各方向的最值。
3. **旋转/镜像处理**：通过变换输入数据减少重复代码。

---

## 推荐题目
1. **P3625**：几乎相同的题目，数据范围稍大。
2. **CF1520E**：一维版的不重叠区间选择。
3. **P2280 [HNOI2003] 激光炸弹**：二维前缀和的经典应用。

---

## 个人心得摘录
- **调试教训**：预处理数组的边界处理容易出错，需仔细验证坐标范围。
- **顿悟点**：通过旋转网格统一处理所有方向，极大简化代码复杂度。
- **性能优化**：将行列最值预处理为数组，避免重复计算。

---

## 可视化与算法演示

### 动态规划矩阵更新
```javascript
// 伪代码：Canvas 绘制 DP 矩阵更新
function drawGrid() {
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      ctx.fillStyle = getColor(dp[i][j]); // 根据值映射颜色
      ctx.fillRect(j*CELL, i*CELL, CELL, CELL);
    }
  }
}
```

### 复古像素风格设计
- **调色板**：使用 8 位经典色（#0000FF, #00FF00, #FF0000 等）。
- **音效**：状态更新时播放短促的 "beep" 音效，背景音乐为 8 位芯片音乐循环。
- **自动演示**：按预设分割线顺序自动切换，用户可暂停/调速。

### 交互设计
- **控制面板**：滑动条调节动画速度，按钮切换布局情况。
- **高亮标记**：当前处理的子网格用闪烁边框标记，分割线用红色高亮。

---

## 核心代码实现

### 二维前缀和与预处理
```cpp
PrefixSum2D<uli> s(a); // 二维前缀和
for (int i = 0; i < k; ++i) {
  for (int j = 0; j < k; ++j) {
    b[i][j] = s.get_sum(i, j, i + m, j + m); // 计算 M×M 子网格和
  }
}
```

### 四方向最值预处理
```cpp
// 左上方向预处理
for (int i = 0; i < K; ++i) {
  for (int j = 0; j < K; ++j) {
    ul[i][j] = max({ul[i-1][j], ul[i][j-1], b[i][j]});
  }
}
// 其他方向类似
```

### 枚举分割线求最大值
```cpp
// 水平分割线枚举
for (int i = m; i <= n - m; ++i) {
  for (int j = i + m; j <= n - m; ++j) {
    ans = max(ans, ul[i][n] + ur[j][n] + br[j + m][n]);
  }
}
```

---
处理用时：101.79秒
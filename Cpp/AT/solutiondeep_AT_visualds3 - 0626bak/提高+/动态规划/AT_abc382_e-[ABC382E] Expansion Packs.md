# 题目信息

# [ABC382E] Expansion Packs

## 题目描述

给定无数包卡牌，每一包卡牌有 $N$ 张卡，对于每一张卡 $i$，有百分之 $P_i$ 的概率是稀有卡，否则是普通卡。现在，你要一直开包，直到你有 $X$ 张稀有卡，求你开包的期望次数。

## 说明/提示

- $1 \le N \le 5000$

- $1 \le X \le 5000$

- $1 \le P_i \le 100$


UID：928955

## 样例 #1

### 输入

```
2 2

50 100```

### 输出

```
1.5000000000000000```

## 样例 #2

### 输入

```
2 3

40 60```

### 输出

```
3.2475579530543811```

## 样例 #3

### 输入

```
6 3

10 33 33 10 100 10```

### 输出

```
1.8657859189536100```

# AI分析结果



# 题目翻译

## [ABC382E] 扩展卡包

### 题目描述

给定无限数量的卡包，每个卡包包含 $N$ 张卡牌。对于每张卡牌 $i$，有 $P_i\%$ 的概率是稀有卡，否则为普通卡。现在你需要不断打开卡包，直到收集到 $X$ 张稀有卡。求期望需要打开的卡包次数。

### 输入格式

- 第一行两个整数 $N$ 和 $X$。
- 第二行包含 $N$ 个整数 $P_1, P_2, \dots, P_N$。

### 输出格式

输出期望次数，保留至少 12 位小数。

---

## 算法分类
**线性DP**

---

## 综合分析与结论

### 核心思路与难点
题目需要计算收集 $X$ 张稀有卡的期望次数，核心思路是通过动态规划分两步处理：
1. **预处理每包卡的概率分布**：计算每包卡中恰好获得 $k$ 张稀有卡的概率 $g[k]$。
2. **期望递推**：定义 $dp[i]$ 为获得至少 $i$ 张稀有卡的期望次数，通过递推式求解。

#### 关键状态转移方程
递推式推导过程：
$$
dp[i] = 1 + \sum_{j=0}^n dp[\max(i-j, 0)] \cdot g[j]
$$
由于 $j=0$ 时会出现自循环，移项后得到：
$$
dp[i] = \frac{1 + \sum_{j=1}^n dp[\max(i-j, 0)] \cdot g[j]}{1 - g[0]}
$$

#### 可视化设计
1. **DP 矩阵更新动画**：
   - 将 $dp$ 数组以网格形式展示，每个格子表示 $dp[i]$ 的值。
   - 更新 $dp[i]$ 时，高亮当前计算的 $i$ 和所有涉及到的 $j$ 对应的 $\max(i-j, 0)$ 位置。
   - 用颜色梯度表示概率 $g[j]$ 的大小（如红色高概率，蓝色低概率）。

2. **复古像素风格**：
   - 使用 8-bit 风格色块（如黄绿色网格、紫色高亮）。
   - 音效设计：状态转移时播放短促的「滴」声，完成 $dp[i]$ 计算时播放「叮」声。

3. **自动演示模式**：
   - 按帧逐步更新 $i$ 值，自动展示每个状态的依赖关系和计算流程。
   - 控制面板支持暂停/继续、单步执行、调整速度。

---

## 题解清单（4星以上）

### 1. 作者：mayike（7赞） ★★★★☆
**关键亮点**：
- 代码简洁，直接使用滚动数组预处理概率。
- 显式推导全期望公式，数学过程清晰。

### 2. 作者：刘梓轩2010（6赞） ★★★★☆
**关键亮点**：
- 详细解释 $\max(0, i-j)$ 的作用，避免负数索引问题。
- 代码注释明确，适合初学者理解。

### 3. 作者：Conan15（2赞） ★★★★☆
**关键亮点**：
- 使用二维数组 $dp[i][j]$ 显式记录概率，逻辑直观。
- 提供调试思路说明，分享读题错误经历。

---

## 核心代码实现

### 预处理概率分布（背包DP）
```cpp
double g[N] = {1.0}; // g[j]：一包卡中恰好j张稀有的概率
for (int i = 1; i <= n; i++) {
    double p = P[i] / 100.0;
    for (int j = n; j >= 1; j--) {
        g[j] = g[j] * (1 - p) + g[j - 1] * p;
    }
    g[0] *= (1 - p);
}
```

### 期望递推（线性DP）
```cpp
double dp[X + 1] = {0};
for (int i = 1; i <= X; i++) {
    dp[i] = 1.0;
    for (int j = 1; j <= n; j++) {
        if (i >= j) dp[i] += dp[i - j] * g[j];
        else        dp[i] += dp[0] * g[j]; // dp[0] = 0
    }
    dp[i] /= (1 - g[0]);
}
```

---

## 同类题目推荐
1. **P4550** 收集邮票（期望逆推）
2. **P1654** 概率充电器（状态转移与期望结合）
3. **P1850** 换教室（期望DP与最短路）

---

## 可视化代码片段（Canvas 动画）

```javascript
// 绘制 DP 网格
function drawGrid(dp) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i <= X; i++) {
        const y = i * CELL_SIZE;
        ctx.fillStyle = getColor(dp[i]); // 根据值映射颜色
        ctx.fillRect(0, y, CELL_SIZE, CELL_SIZE);
        ctx.strokeRect(0, y, CELL_SIZE, CELL_SIZE);
    }
}

// 更新动画帧
function animateStep(i) {
    highlightCell(i, 'yellow');
    playSound('beep');
    for (let j = 1; j <= n; j++) {
        const prev = Math.max(i - j, 0);
        drawArrow(i, prev, 'blue');
        updateDPValue(i);
    }
}
```

---

## 个人心得摘录
> "赛时没注意 $\max(0, i-j)$ 导致数组越界，调试半小时才发现问题。务必注意边界！" —— 作者：Po7ed

---

**可视化效果示意图**：
```
| i=0 | i=1 | ... | i=X |
|-----|-----|-----|-----|
| 0.0 | 1.5 | ... | Ans |
``` 
箭头表示状态转移依赖，当前计算位置高亮为黄色，历史值渐变为绿色。

---
处理用时：78.16秒
# 题目信息

# [ABC404F] Lost and Pound

## 题目描述

青木和高桥在玩一个游戏。场上有 $N$ 个按钮，其中 $1$ 个是关键按钮，剩下的 $N-1$ 个是普通按钮。

青木知道哪一个按钮是关键按钮，而高桥并不知道，也就是说，高桥无法将这 $N$ 个按钮相互区分。

在游戏中，以下事件将会被重复 $T$ 次：

1. 青木将这 $N$ 个按钮按随机的顺序摆放。
2. 高桥进行 $M$ 次操作，每次操作中他将选择一个按钮并按下它一次。在这个过程中他可以选择按下同一个按钮多次。
3. 青木告诉高桥从游戏开始至今，关键按钮被高桥按下了多少次。

高桥获胜当且仅当关键按钮在这 $T$ 轮过程中被他按下了至少 $K$ 次。请你求出当高桥以最优策略游玩游戏时，他获胜的期望，并以浮点数的形式输出。

## 说明/提示

**样例 1 解释**

这是一种可能的游戏进展（不保证在下面描述的过程中高桥采用了最佳策略）：
- 第一轮
  - 青木随机摆放了按钮，此时关键按钮放在位置 $1$。
  - 高桥选择按下位置 $1$ 和位置 $2$ 的按钮。
  - 青木告诉高桥关键按钮已经被按下 $1$ 次。
- 第二轮
  - 青木随机摆放了按钮，此时关键按钮放在位置 $3$。
  - 高桥两次选择按下位置 $3$ 的按钮。
  - 青木告诉高桥关键按钮已经被按下 $3$ 次。
- 游戏结束时，关键按钮被按下了至少 $3$ 次，所以高桥获胜了。

这组数据的标准答案是 $\frac{2}{9}$，因此对应地输出 $0.222222$ 或 $0.222223141592$ 会被认为是正确的。

By chenxi2009

## 样例 #1

### 输入

```
3 2 2 3```

### 输出

```
0.222222222222222```

## 样例 #2

### 输入

```
10 1 10 1```

### 输出

```
1.000000000000000```

## 样例 #3

### 输入

```
100 10 10 2```

### 输出

```
0.401263060761621```

# AI分析结果



**唯一算法分类**：动态规划（DP）

---

### **题解思路与算法要点**

#### **核心思路**
1. **状态定义**：`dp[i][j]` 表示前 `i` 轮已按下关键按钮至少 `j` 次的最大概率。
2. **状态转移**：每一轮选择一种按按钮的次数组（分拆数），计算该策略下的期望概率。关键点在于：
   - **分拆数生成**：枚举所有可能的按法组合（如 `M=30` 时分拆数为 5604）。
   - **概率计算**：每个按法组合中，关键按钮被按 `c` 次的概率为 `1/n`，其他按钮未被按的概率为 `(n - len)/n`。
3. **边界条件**：`dp[0][0] = 1`（初始未开始游戏时概率为 1）。

#### **解决难点**
- **高效枚举按法**：通过递归生成所有非递增序列的分拆数，避免指数级枚举。
- **概率叠加优化**：将分拆数的贡献统一计算，避免重复遍历按钮顺序。

---

### **题解评分（≥4星）**

1. **Moya_Rao (★★★★★)**  
   - **亮点**：递归生成分拆数，代码清晰，注释详细。
   - **代码片段**：
     ```cpp
     void Init_Makefp(int sum, int lst) {
         if (!sum) {
             if (now.size() <= n) fp.push_back(now);
             return;
         }
         for (int i = min(sum, lst); i > 0; i--) {
             now.push_back(i);
             Init_Makefp(sum - i, i);
             now.pop_back();
         }
     }
     ```
   
2. **chenxi2009 (★★★★☆)**  
   - **亮点**：榜一代码，直接预处理分拆数，状态转移高效。
   - **核心逻辑**：
     ```cpp
     for (auto s : dv) if (s.size() <= n) {
         double now = f[i + 1][j] * (n - s.size());
         for (auto v : s) now += f[i + 1][min(k, j + v)];
         gmax(f[i][j], now / n);
     }
     ```

3. **happy_zero (★★★★☆)**  
   - **亮点**：预处理分拆数贡献，代码简洁。
   - **核心逻辑**：
     ```cpp
     for (int p = 0; p <= M; p++) {
         double pp = (j + p >= K ? 1.0 : f[i + 1][j + p]);
         sum += a[k][p] * pp;
     }
     ```

---

### **最优思路提炼**
- **分拆数预处理**：递归生成所有可能的按法组合（非递增序列）。
- **概率叠加优化**：将每个分拆数的贡献统一计算，避免重复遍历按钮顺序。
- **状态压缩**：将 `j > K` 的状态压缩到 `j = K`，简化计算。

---

### **同类型题目**
1. **P2473 [SCOI2008] 奖励关**  
   - 类似概率 DP，需处理状态转移中的随机性。
2. **P1044 [NOIP2003 普及组] 栈**  
   - 分拆数的应用，枚举合法操作序列。
3. **P3193 [HNOI2008] GT考试**  
   - 动态规划与组合数学结合。

---

### **可视化设计**
1. **动画方案**：  
   - **Canvas 网格**：每轮按钮排列为网格，关键按钮随机位置高亮。
   - **分拆数可视化**：以像素方块表示按法组合，如 `[3,2,1]` 显示为 3 个不同高度的色块。
2. **音效与交互**：  
   - **按键音效**：每次按下按钮播放 8-bit 音效。
   - **自动演示**：模拟分拆数生成和状态转移，按空格键单步执行。
3. **复古风格**：  
   - **调色板**：16 色 FC 风格，状态条用绿色像素块表示概率值。
   - **背景音乐**：循环播放 8-bit 风格 BGM。

---

### **代码片段（核心逻辑）**
```cpp
// 分拆数生成（Moya_Rao 实现）
void Init_Makefp(int sum, int lst) {
    if (!sum) {
        if (now.size() <= n) fp.push_back(now);
        return;
    }
    for (int i = min(sum, lst); i > 0; i--) {
        now.push_back(i);
        Init_Makefp(sum - i, i);
        now.pop_back();
    }
}

// 状态转移（chenxi2009 实现）
for (int i = 1; i <= t; i++) {
    for (int j = 0; j <= k; j++) {
        for (auto s : dv) if (s.size() <= n) {
            double now = dp[i-1][j] * (n - s.size());
            for (auto v : s) now += dp[i-1][min(k, j + v)];
            dp[i][j] = max(dp[i][j], now / n);
        }
    }
}
```

---

### **个人心得**
- **分拆数剪枝**：生成时限制 `a_i >= a_{i+1}` 避免重复组合。
- **概率压缩**：`j > K` 的状态直接合并到 `j = K`，简化计算。

---

**答案**
唯一算法分类：动态规划

最终答案的期望概率通过动态规划计算，核心代码和可视化设计如上。

---
处理用时：80.80秒
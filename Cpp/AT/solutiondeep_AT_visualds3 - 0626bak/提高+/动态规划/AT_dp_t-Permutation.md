# 题目信息

# Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_t

$ N $ を正整数とします。 長さ $ N\ -\ 1 $ の文字列 $ s $ が与えられます。 $ s $ は `<` と `>` からなります。

$ (1,\ 2,\ \ldots,\ N) $ を並べ替えた順列 $ (p_1,\ p_2,\ \ldots,\ p_N) $ であって、次の条件を満たすものは何通りでしょうか？ $ 10^9\ +\ 7 $ で割った余りを求めてください。

- 各 $ i $ ($ 1\ \leq\ i\ \leq\ N\ -\ 1 $) について、$ s $ の $ i $ 文字目が `<` の場合は $ p_i\ <\ p_{i\ +\ 1} $ であり、$ s $ の $ i $ 文字目が `>` の場合は $ p_i\ >\ p_{i\ +\ 1} $ である。

## 说明/提示

### 制約

- $ N $ は整数である。
- $ 2\ \leq\ N\ \leq\ 3000 $
- $ s $ は長さ $ N\ -\ 1 $ の文字列である。
- $ s $ は `<` と `>` からなる。

### Sample Explanation 1

条件を満たす順列は次の $ 5 $ 通りです。 - $ (1,\ 3,\ 2,\ 4) $ - $ (1,\ 4,\ 2,\ 3) $ - $ (2,\ 3,\ 1,\ 4) $ - $ (2,\ 4,\ 1,\ 3) $ - $ (3,\ 4,\ 1,\ 2) $

### Sample Explanation 2

条件を満たす順列は次の $ 1 $ 通りです。 - $ (1,\ 2,\ 3,\ 4,\ 5) $

### Sample Explanation 3

答えを $ 10^9\ +\ 7 $ で割った余りを出力することを忘れずに。

## 样例 #1

### 输入

```
4

<><```

### 输出

```
5```

## 样例 #2

### 输入

```
5

<<<<```

### 输出

```
1```

## 样例 #3

### 输入

```
20

>>>><>>><>><>>><<>>```

### 输出

```
217136290```

# AI分析结果



# 一、题目翻译

## 排列计数

### 题目描述

给定正整数 $N$ 和长度为 $N-1$ 的由 `<` 和 `>` 组成的字符串 $s$。求满足以下条件的排列 $(p_1, p_2, \ldots, p_N)$ 的数量，答案对 $10^9+7$ 取模：

- 对每个 $i$（$1 \leq i \leq N-1$），当 $s$ 的第 $i$ 个字符为 `<` 时需满足 $p_i < p_{i+1}$，为 `>` 时需满足 $p_i > p_{i+1}$。

### 输入输出样例

#### 样例 #1
输入：
```
4
<><
```
输出：
```
5

#### 样例 #2
输入：
```
5
<<<<
```
输出：
```
1
```

### 数据范围
- $2 \leq N \leq 3000$

---

# 二、算法分类

**线性DP**

---

# 三、题解思路与核心分析

## 核心算法思想
1. **状态定义**：定义 $dp[i][j]$ 表示前 $i$ 个数字组成的排列中，第 $i$ 个数字在局部排列中排名为第 $j$ 小的方案数。
2. **转移方程**：
   - 当 $s[i-1]$ 为 `<` 时，需从更小的排名转移：$dp[i][j] = \sum_{k=1}^{j-1} dp[i-1][k]$
   - 当 $s[i-1]$ 为 `>` 时，需从更大的排名转移：$dp[i][j] = \sum_{k=j}^{i-1} dp[i-1][k]$
3. **前缀和优化**：维护二维前缀和数组 $sum[i][j]$ 来避免重复计算求和操作，将时间复杂度优化至 $O(N^2)$。

## 解决难点
- **相对排名转换**：将具体数值转换为相对排名，避免排列数值重复问题。
- **状态转移优化**：通过前缀和数组将原本 $O(N^3)$ 的转移复杂度优化至 $O(N^2)$。

---

# 四、高分题解精选（≥4星）

## 题解1：云浅知处（★★★★★）
**亮点**：  
- 最简洁的状态定义与转移方程
- 使用滚动前缀和数组，代码实现极简
```cpp
int n, dp[MN][MN], sum[MN][MN];
char s[MN];
for(int i=2; i<=n; i++) {
    for(int j=1; j<=i; j++) {
        if(s[i-1] == '<') dp[i][j] = sum[i-1][j-1] % mod;
        else dp[i][j] = (sum[i-1][i-1] - sum[i-1][j-1] + mod) % mod;
        sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod;
    }
}
```

## 题解2：FelFa_1414666（★★★★☆）
**亮点**：  
- 逆向递推转移方式
- 提出差分递推思想，减少内存访问次数
```cpp
if(s[i-2] == '<')
    for(int j=1; j<=i; j++) 
        dp[i][j] = (dp[i][j-1] + dp[i-1][j-1]) % MOD;
else
    for(int j=i-1; j>=1; j--)
        dp[i][j] = (dp[i][j+1] + dp[i-1][j]) % MOD;
```

## 题解3：Alexandra（★★★★☆）
**亮点**：  
- 强调相对大小关系的重要性
- 详细注释前缀和数组的更新逻辑
```cpp
for(long long j=1; j<=i; j++) {
    if(a[i] == '<') f[i][j] = s[i-1][j-1] % mod;
    else f[i][j] = (s[i-1][i-1] - s[i-1][j-1] + mod) % mod;
    s[i][j] = (s[i][j-1] + f[i][j]) % mod;
}
```

---

# 五、最优思路提炼

**核心技巧**：
1. **相对排名建模**：将排列数值的绝对大小转换为局部排名，避免排列不重复的约束。
2. **前缀和数组**：在每次DP转移时维护二维前缀和，将求和操作从 $O(N)$ 优化到 $O(1)$。
3. **逆向递推优化**：通过观察相邻状态的差值关系，实现单方向扫描转移。

---

# 六、相似题目推荐
1. **P1774 最接近神的人** - 逆序对计数与排列关系
2. **P2401 不等数列** - 类似的大小符号约束问题
3. **CF285E Positions in Permutations** - 排列的特定位置约束计数

---

# 七、可视化设计思路

## 动态规划矩阵动画
1. **网格绘制**：在Canvas中绘制N×N的网格，每个单元格表示 $dp[i][j]$。
2. **颜色编码**：
   - 绿色：当前正在更新的单元格
   - 黄色：参与求和转移的前缀区域
3. **动画流程**：
   - 按行顺序更新，高亮当前行号i
   - 当处理到第j列时，显示对应的前缀和区间（如从1到j-1的浅蓝色区域）
4. **音效设计**：
   - 更新单元格时播放"滴"声
   - 完成一行更新时播放短旋律

## 复古像素风格实现
```javascript
// 绘制DP网格示例
function drawGrid() {
    ctx.fillStyle = "#2C3E50"; // 背景色
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    for(let i=0; i<=N; i++) {
        for(let j=0; j<=N; j++) {
            const x = j * CELL_SIZE;
            const y = i * CELL_SIZE;
            // 绘制像素边框
            ctx.strokeStyle = "#34495E";
            ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
            // 填充当前激活单元格
            if(i == currentI && j == currentJ) {
                ctx.fillStyle = "#27AE60"; // 激活绿
                ctx.fillRect(x+1, y+1, CELL_SIZE-2, CELL_SIZE-2);
            }
        }
    }
}
```

---

# 八、核心代码实现

## 云浅知处题解完整代码
```cpp
#include<iostream>
using namespace std;
const int MN=3005, mod=1e9+7;

int n, dp[MN][MN], sum[MN][MN];
char s[MN];

int main() {
    cin >> n >> (s+1);
    dp[1][1] = 1;
    for(int i=1; i<=n; i++) sum[1][i] = 1;
    
    for(int i=2; i<=n; i++) {
        for(int j=1; j<=i; j++) {
            if(s[i-1] == '<') 
                dp[i][j] = sum[i-1][j-1] % mod;
            else 
                dp[i][j] = (sum[i-1][i-1] - sum[i-1][j-1] + mod) % mod;
            sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod;
        }
    }
    cout << sum[n][n] % mod;
    return 0;
}
```

---
处理用时：85.86秒
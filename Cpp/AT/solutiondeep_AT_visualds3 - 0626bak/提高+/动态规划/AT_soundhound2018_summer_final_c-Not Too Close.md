# 题目信息

# Not Too Close

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_c

$ N $ 頂点の無向グラフであって、以下の条件をすべて満たすものの個数を $ 10^9\ +\ 7 $ で割った余りを求めてください。

- $ N $ 個の頂点には $ 1 $ から $ N $ までの番号が振られている。
- グラフは自己辺や多重辺を持たない（連結である必要はない）。
- すべての辺の長さを $ 1 $ とすると、頂点 $ 1,\ 2 $ 間の最短距離は $ D $ である。

## 说明/提示

### 注記

二つのグラフ $ G_1,\ G_2 $ は、以下が満たされる場合に異なるとみなされ、満たされない場合に同一とみなされます。

- ある整数の組 $ (i,\ j) $ $ (1\ <\ =\ i\ <\ j\ <\ =\ N) $ が存在し、頂点 $ i,\ j $ を直接結ぶ辺が $ G_1,\ G_2 $ のうち一方のみに存在する。

### 制約

- $ 1\ <\ =\ D\ <\ N\ <\ =\ 30 $
- $ N,\ D $ は整数である。

### Sample Explanation 1

条件を満たすグラフは下図の $ 2 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/4b0c83895d12c1a9c90cb3e8060db969.png)

### Sample Explanation 2

条件を満たすグラフは下図の $ 14 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/df4dffb7f2140b22a6c7ccc86f6c9cf9.png)

### Sample Explanation 3

mod $ (10^9\ +\ 7) $ にご注意ください。

## 样例 #1

### 输入

```
4 3```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2```

### 输出

```
14```

## 样例 #3

### 输入

```
30 15```

### 输出

```
313862829```

# AI分析结果



# 中文题目翻译

## 题目名称：不太近

### 题目描述

给定一个包含 $N$ 个顶点的无向图，求满足以下所有条件的图的数量对 $10^9 + 7$ 取模的结果：

- 顶点编号为 $1$ 到 $N$。
- 图中没有自环和多重边（不要求连通）。
- 当所有边的长度视为 $1$ 时，顶点 $1$ 和顶点 $2$ 之间的最短距离为 $D$。

### 输入格式

输入包含两个整数 $N$ 和 $D$。

### 输出格式

输出符合条件的图的数量模 $10^9 + 7$ 的结果。

### 数据范围

- $1 \le D < N \le 30$
- $N$ 和 $D$ 为整数

---

## 算法分类
**线性DP**

---

## 算法分析与题解结论

### 核心思路
将顶点按到顶点1的最短距离分层，使用动态规划逐层构建合法图结构：
1. **分层模型**：顶点按到顶点1的距离分为 $D+1$ 层（顶点1在第0层，顶点2必须在第D层）
2. **DP状态设计**：`f[i][j][k]` 表示前 $i$ 层共使用 $j$ 个顶点，第 $i$ 层有 $k$ 个顶点的方案数
3. **状态转移**：枚举下一层顶点数 $l$，计算：
   - 选点方案数（组合数）
   - 层内连边方案数（$2^{\binom{l}{2}}$）
   - 跨层连边方案数（$(2^k - 1)^l$）
4. **最终统计**：对未使用的顶点计算自由连边方案

### 难点解析
1. **顶点2的特殊处理**：在组合数计算时，当构建第 $D$ 层时需要强制包含顶点2
2. **状态转移系数计算**：需同时考虑组合数、层内边、跨层边三种方案数的乘积
3. **自由顶点处理**：未使用的顶点可以任意连接，但只能与最后一层顶点相连

---

## 高分题解推荐（≥4星）

### 题解1：Hadtsti（★★★★☆）
**亮点**：
- 清晰的组合数预处理设计
- 简洁的状态转移循环结构
- 完整处理顶点2的特殊情况

**核心代码片段**：
```cpp
for(int i=0;i<d;i++)
    for(int j=i;j<=n;j++)
        for(int k=1;k<=j-i+1;k++)
            if(f[i][j][k])
                for(int l=1;l<=n-j-d+i+1;l++) // 关键转移逻辑
                    f[i+1][j+l][l] = (f[i+1][j+l][l] + ... )
```

### 题解2：VainSylphid（★★★★☆）
**亮点**：
- 模块化的2的幂次预处理
- 明确的数学公式描述转移过程
- 详细注释未使用顶点的处理

---

## 最优思路提炼

1. **分层建模法**：将图结构转化为分层模型，通过距离约束简化问题
2. **组合数学技巧**：
   - 使用预处理的组合数快速计算选点方案
   - 利用位运算快速计算 $2^k$ 相关值
3. **状态压缩技巧**：通过三维DP状态精确记录各层顶点分布
4. **自由顶点处理技巧**：将未使用顶点的连边方案拆分为独立计算部分

---

## 相似题目推荐

1. **洛谷P1357 花园**（分层DP建模）
2. **洛谷P4349 CERC2015 Digit Division**（组合数预处理+动态规划）
3. **洛谷P4921 情侣？给我烧了！**（图结构计数问题）

---

## 可视化算法设计

### 动态规划矩阵动画
**实现方案**：
1. **像素风格显示**：
   - 使用16色调色板（FC红白机风格）
   - 每个DP状态用8x8像素块表示，颜色深浅表示数值大小
2. **转移过程演示**：
   ```javascript
   // 伪代码示例
   class DPGrid {
       constructor() {
           this.layers = [];
           this.currentLayer = 0;
       }
       drawGrid() {
           // 使用Canvas绘制三维DP矩阵的二维投影
       }
       step() {
           // 单步执行状态转移，高亮当前更新的单元格
       }
   }
   ```
3. **音效系统**：
   - 状态更新时播放8-bit "blip" 音效（Web Audio API）
   - 完成一层转移时播放上升音阶

### 交互功能
- **速度控制滑块**：调节动画速度（50ms~2000ms/步）
- **层数追踪器**：显示当前处理层数和已使用顶点数
- **自动演示模式**：按层数自动推进，类似贪吃蛇AI路径演示

---

## 核心代码实现

```cpp
// 预处理组合数与2的幂次
pow2[0] = 1;
for(int i=1; i<=n*n; i++) 
    pow2[i] = pow2[i-1] * 2 % mod;

for(int i=0; i<=n; i++) {
    C[i][0] = C[i][i] = 1;
    for(int j=1; j<i; j++)
        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;
}

// 关键DP转移逻辑
for(int i=0; i<d; i++) {
    for(int j=1; j<=n; j++) {
        for(int k=1; k<=j; k++) {
            if(!dp[i][j][k]) continue;
            for(int l=1; j+l<=n; l++) {
                int choose = C[n-j-1][l - (i+1==d ? 1 : 0)];
                int ways = (pow2[k] - 1 + mod) % mod;
                ways = binpow(ways, l);
                int inner = pow2[l*(l-1)/2];
                dp[i+1][j+l][l] = (dp[i+1][j+l][l] + 
                    1LL * dp[i][j][k] * choose % mod * 
                    ways % mod * inner % mod) % mod;
            }
        }
    }
}
```

---
处理用时：80.24秒
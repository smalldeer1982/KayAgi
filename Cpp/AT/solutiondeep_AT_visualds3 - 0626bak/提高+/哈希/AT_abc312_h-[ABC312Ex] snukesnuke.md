# 题目信息

# [ABC312Ex] snukesnuke

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc312/tasks/abc312_h

高橋君は人 $ 1,\ldots,N $ の $ N $ 人のあだ名を決めることになりました。

人 $ i $ はあだ名を $ S_i $ にしてほしいと思っています。複数人に同じあだ名をつけるのを避けるため、高橋君は次の手順で $ N $ 人のあだ名を決めることにしました。

- $ i=1,\ldots,N $ の順に、以下の操作により人 $ i $ のあだ名を決める
  - 変数 $ k_i $ を $ 1 $ とする。
  - 「$ S_i $ を $ k_i $ 回繰り返した文字列」がすでに誰かのあだ名である間、$ k_i $ を $ 1 $ 増やすことを繰り返す。
  - 「$ S_i $ を $ k_i $ 回繰り返した文字列」を人 $ i $ のあだ名とする。
 
$ N $ 人のあだ名を決めた後の $ k_1,\ldots,k_N $ を求めてください。

## 说明/提示

### 制約

- $ N\ \geq\ 1 $
- $ S_i $ は英小文字のみからなる、長さ $ 1 $ 以上の文字列
- $ S_i $ の長さの総和は $ 2\times\ 10^5 $ 以下
 
### Sample Explanation 1

\- まず人 $ 1 $ のあだ名を決めます。 - $ k_1=1 $ とします。 - $ S_1 $ を $ k_1 $ 回繰り返した文字列 `snuke` は誰のあだ名でもないので、人 $ 1 $ のあだ名は `snuke` になります。 - 次に人 $ 2 $ のあだ名を決めます。 - $ k_2=1 $ とします。 - $ S_2 $ を $ k_2 $ 回繰り返した文字列 `snuke` はすでに人 $ 1 $ のあだ名なので、$ k_2 $ を $ 1 $ 増やして $ 2 $ とします。 - $ S_2 $ を $ k_2 $ 回繰り返した文字列 `snukesnuke` は誰のあだ名でもないので、人 $ 2 $ のあだ名は `snukesnuke` になります。 - 最後に人 $ 3 $ のあだ名を決めます。 - $ k_3=1 $ とします。 - $ S_3 $ を $ k_3 $ 回繰り返した文字列 `rng` は誰のあだ名でもないので、人 $ 3 $ のあだ名は `rng` になります。 以上により、$ k_1,k_2,k_3 $ はそれぞれ $ 1,2,1 $ となります。

### Sample Explanation 2

\- 人 $ 1 $ のあだ名は `aa` になります。 - 人 $ 2 $ のあだ名は `a` になります。 - 人 $ 3 $ のあだ名は、`a`, `aa` がすでに他の人のあだ名なので、`aaa` になります。 - 人 $ 4 $ のあだ名は、`aaa` がすでに他の人のあだ名なので、`aaaaaa` になります。

## 样例 #1

### 输入

```
3

snuke

snuke

rng```

### 输出

```
1 2 1```

## 样例 #2

### 输入

```
4

aa

a

a

aaa```

### 输出

```
1 1 3 2```

## 样例 #3

### 输入

```
5

x

x

x

x

x```

### 输出

```
1 2 3 4 5```

# AI分析结果



---

**唯一算法分类**：字符串处理与哈希优化

---

### **综合分析与结论**

#### **核心思路**
1. **循环节预处理**：使用 KMP 算法计算每个字符串的最小循环节，将相同循环节的字符串归为一类。
2. **哈希优化**：对每个循环节维护已使用的重复次数，避免重复检查，直接跳跃到最小可用倍数。
3. **时间复杂度**：通过哈希表和跳跃式查询，将时间复杂度优化至 $O(\sum |S_i| + n \log n)$。

#### **解决难点**
- **循环节冲突**：不同字符串可能因循环节重复导致冲突，需统一管理同类循环节。
- **高效查询**：通过 `jmp` 数组记录当前循环节的下一个可用倍数，避免暴力枚举。

#### **可视化设计思路**
- **动画展示**：用不同颜色块表示不同循环节，动态显示每个字符串的 `k_i` 确定过程。
- **高亮操作**：当前处理的字符串、循环节和正在检查的倍数用闪烁效果标记。
- **音效反馈**：每次成功找到 `k_i` 时播放成功音效，重复检查时播放“跳过”音效。

---

### **题解清单 (≥4星)**

1. **hzlqwq 的题解（⭐⭐⭐⭐⭐）**
   - **亮点**：通过 KMP + 哈希表跳跃查询，代码简洁高效，时间复杂度最优。
   - **关键代码**：维护 `jmp` 数组记录每个循环节的当前倍数，避免重复枚举。

2. **liangbowen 的题解（⭐⭐⭐⭐）**
   - **亮点**：对完全相同的字符串进行记忆化，直接从历史结果开始查询。
   - **优化点**：结合循环节分类可进一步提升效率。

3. **Genius_Star 的题解（⭐⭐⭐）**
   - **亮点**：动态维护因数的最小未使用倍数，但因数分解增加额外开销。

---

### **最优思路提炼**

#### **关键步骤**
1. **KMP 预处理**：计算每个字符串的最小循环节长度 `len[x]` 和重复次数 `sk[x]`。
2. **循环节分类**：将相同循环节的字符串映射到同一哈希键。
3. **跳跃查询**：对每个循环节的 `sk[x]`，记录下一个可用倍数 `jmp[tmp][sk[i]]`。

#### **代码片段**
```cpp
// KMP 计算循环节
void kmp(int x) {
    for (int i = 1, j = 0; i < s[x].size(); i++) {
        while (j && s[x][i] != s[x][j]) j = ne[j - 1];
        if (s[x][i] == s[x][j]) j++;
        ne[i] = j;
    }
    len[x] = (s[x].size() % (s[x].size() - ne.back()) == 0) 
             ? s[x].size() - ne.back() : s[x].size();
    sk[x] = s[x].size() / len[x];
}

// 主逻辑：跳跃查询
for (int i = 1; i <= n; i++) {
    int tmp = id[cir[i]];
    while (mex[tmp].count(++jmp[tmp][sk[i]] * sk[i])) ;
    mex[tmp].insert(jmp[tmp][sk[i]] * sk[i]);
}
```

---

### **同类型题推荐**

1. **洛谷 P1368 周期串**  
   - 考察 KMP 求最小循环节。

2. **洛谷 P3966 字符串**  
   - 哈希优化与字符串冲突处理。

3. **洛谷 P4051 字符加密**  
   - 循环节与重复字符串处理。

---

### **可视化与算法演示**

#### **像素风格动画**
- **颜色标记**：循环节用不同颜色方块，当前查询的倍数用闪烁边框。
- **音效设计**：成功找到 `k_i` 时播放 `8-bit` 成功音效，倍数递增时播放“滴答”声。
- **自动演示**：按顺序处理每个字符串，展示循环节分类和倍数跳跃过程。

#### **交互设计**
- **控制面板**：暂停/继续按钮，速度滑动条（1x-5x）。
- **网格展示**：每个字符串的循环节和重复次数以网格形式排列，高亮当前操作。

---

### **代码实现（核心部分）**

```cpp
// KMP 预处理（完整代码见原题解）
// 哈希跳跃查询
unordered_map<string, int> id;  // 循环节到哈希键
unordered_set<int> mex[N];      // 已用倍数集合
unordered_map<int, int> jmp[N]; // 当前倍数记录

for (int i = 1; i <= n; i++) {
    int tmp = id[cir[i]];       // 获取循环节哈希键
    int base = sk[i];           // 当前字符串的循环次数
    while (mex[tmp].count(++jmp[tmp][base] * base)) {} // 跳跃查询
    mex[tmp].insert(jmp[tmp][base] * base); // 插入新倍数
}
```

---

**总结**：通过预处理循环节和哈希跳跃，本题在避免暴力枚举的同时保证了高效性，核心在于对同类问题的统一管理和状态记录。

---
处理用时：76.64秒
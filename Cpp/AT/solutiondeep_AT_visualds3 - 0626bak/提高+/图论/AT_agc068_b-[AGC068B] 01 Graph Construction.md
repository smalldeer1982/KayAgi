# 题目信息

# [AGC068B] 01 Graph Construction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc068/tasks/agc068_b

`0`,`1` のみからなる文字列の組 $ (S,T) $ が次の条件をすべて満たすとき (そしてそのときのみ) それを**良い**文字列組と呼ぶことにします．

- $ S,T $ に含まれる `0` の個数は等しい．
- $ S,T $ に含まれる `1` の個数は等しい．

特に，良い文字列組 $ (S,T) $ について，$ S,T $ の長さは同じです．

良い文字列組 $ (S,T) $ に対し，無向グラフ $ G(S,T) $ を次のように定義します．

- $ S $ の長さを $ L $ とする．頂点 $ 1,2,\cdots,L $ からなるグラフ $ g $ をつくる．
- $ S $ に含まれる `0` の個数を $ n $ とする． $ S $ に含まれる `0` の index を $ 1\ \leq\ a_1\ <\ a_2\ <\ \cdots\ <\ a_n\ \leq\ L $ とする． $ T $ に含まれる `0` の index を $ 1\ \leq\ b_1\ <\ b_2\ <\ \cdots\ <\ b_n\ \leq\ L $ とする． 各 $ 1\ \leq\ i\ \leq\ n $ に対し，頂点 $ a_i $ と頂点 $ b_i $ を結ぶ辺を $ g $ に追加する．
- $ S $ に含まれる `1` の個数を $ m $ とする． $ S $ に含まれる `1` の index を $ 1\ \leq\ c_1\ <\ c_2\ <\ \cdots\ <\ c_m\ \leq\ L $ とする． $ T $ に含まれる `1` の index を $ 1\ \leq\ d_1\ <\ d_2\ <\ \cdots\ <\ d_m\ \leq\ L $ とする． 各 $ 1\ \leq\ i\ \leq\ m $ に対し，頂点 $ c_i $ と頂点 $ d_i $ を結ぶ辺を $ g $ に追加する．
- 以上の手順で得た $ g $ を $ G(S,T) $ とする．

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます． 以下の条件をすべて満たす良い文字列組 $ (S,T) $ を $ 1 $ つ見つけてください．

- $ S $ の長さを $ L $ とする．$ N\ \leq\ L\ \leq\ 10^5 $ である．
- 各 $ 1\ \leq\ i,j\ \leq\ N $ について，$ G(S,T) $ で頂点 $ i $ と頂点 $ j $ が同じ連結成分に属すとき，そしてそのときのみ $ A_i=A_j $ である．

なお，この問題の制約下で解が必ず存在することが証明できます．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ A_i\ \leq\ N $
- 入力される値はすべて整数

### Sample Explanation 1

出力例の $ S,T $ について $ G(S,T) $ を求めると，次のようになります． - $ 4 $ 頂点ならなるグラフ $ g $ を用意する． - $ S $ に含まれる `0` の index は $ (1,2) $ で，$ T $ に含まれる `0` の index は $ (3,4) $ である． 辺 $ (1,3),(2,4) $ を $ g $ に追加する． - $ S $ に含まれる `1` の index は $ (3,4) $ で，$ T $ に含まれる `1` の index は $ (1,2) $ である． 辺 $ (3,1),(4,2) $ を $ g $ に追加する． - $ G(S,T)=g $ とする． $ G(S,T) $ の連結成分は，頂点 $ (1,3) $ からなる成分と頂点 $ (2,4) $ からなる成分です． これは条件をすべて満たすので，この $ (S,T) $ は正しい出力です．

## 样例 #1

### 输入

```
3
1 2 1```

### 输出

```
4
0011
1100```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
5
01010
01010```

## 样例 #3

### 输入

```
6
1 1 1 1 1 1```

### 输出

```
6
011111
111110```

## 样例 #4

### 输入

```
10
1 2 3 2 4 3 4 4 5 6```

### 输出

```
21
000101010111100011011
011010000010101111110```

# AI分析结果



## 算法分类
**构造**

## 题解思路与难点分析

### 核心思路
1. **预处理边列表**：将相同值的顶点对存入边列表 `e`，确保后续连接。
2. **初始构造**：初始化 `S` 为全 `0`，`T` 为全 `1`，此时 `S` 的 `0` 和 `T` 的 `1` 位置均为 `1~n`。
3. **旋转调整与边连接**：
   - 对于每条边 `(u, v)`，通过添加字符 `0` 或 `1` 旋转当前未匹配的 `0` 和 `1` 的起始位置到 `u` 和 `v`。
   - 添加 `10` 到 `S` 和 `01` 到 `T`，连接 `u` 和 `v`，随后继续旋转。
4. **平衡字符数量**：处理完所有边后，补充字符使 `S` 和 `T` 的 `0`、`1` 数量相等。

### 解决难点
1. **连通性保证**：通过边列表直接连接相同值的顶点，确保连通分量正确。
2. **字符平衡**：每次添加字符时保持 `0` 和 `1` 数量动态平衡，最终通过补全操作确保总数相等。
3. **旋转操作**：通过模运算调整当前起始位置，高效实现位置对齐。

## 题解评分
1. **Rainbow_qwq 的题解（★★★★★）**  
   - **亮点**：通过旋转和补全高效构造，代码简洁清晰，时间复杂度为 `O(n^2)`，完全满足题目约束。
   - **实现**：利用队列式旋转管理未匹配位置，最后补全字符保证平衡。

## 最优思路提炼
- **边预处理**：用哈希表记录相同值的顶点对，生成边列表。
- **双指针旋转**：维护两个指针 `p` 和 `q` 表示当前未匹配的 `0` 和 `1` 的起始位置，通过添加字符 `0` 或 `1` 旋转对齐。
- **关键操作**：每次连接边时添加 `10` 和 `01`，生成两条边（`0` 和 `1` 各一条），确保顶点连通。
- **补全平衡**：处理完所有边后，补充 `n` 个 `1` 和 `0`，确保 `S` 和 `T` 的 `0`、`1` 数量相等。

## 相似题目推荐
1. [CF1391E Pairs of Pairs](https://codeforces.com/problemset/problem/1391/E)  
   **关键词**：图构造、连通分量管理。
2. [Luogu P1341 无序字母对](https://www.luogu.com.cn/problem/P1341)  
   **关键词**：欧拉路径构造、字符对处理。
3. [LeetCode 886. Possible Bipartition](https://leetcode.com/problems/possible-bipartition/)  
   **关键词**：连通分量判断、图染色。

## 可视化算法分析
### 关键步骤动画设计
1. **初始状态**：展示 `S` 为全 `0`，`T` 为全 `1`，顶点 `1~n` 未连接。
2. **边处理**：对每条边 `(u, v)`，高亮 `u` 和 `v`，动态展示旋转过程（字符添加和指针移动），随后添加连接边。
3. **补全阶段**：以颜色区分补充的 `1` 和 `0`，展示字符数量平衡过程。

### 复古像素化实现
- **颜色方案**：`0` 用蓝色方块，`1` 用红色方块，边用黄色线条连接。
- **音效**：添加字符时播放“点击”音效，完成连接时播放“成功”音效。
- **自动演示**：按帧逐步展示旋转、连接、补全，支持暂停/继续。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define For(i, a, b) for (int i = (a); i <= (b); i++)
const int maxn = 1e5 + 5;
int n, pre[maxn];
vector<pair<int, int>> edges;

int main() {
    cin >> n;
    vector<int> a(n);
    memset(pre, -1, sizeof(pre));
    For(i, 0, n-1) {
        cin >> a[i];
        if (pre[a[i]] != -1)
            edges.emplace_back(pre[a[i]], i);
        pre[a[i]] = i;
    }

    string s(n, '0'), t(n, '1');
    int p = 0, q = 0;
    for (auto [u, v] : edges) {
        // 旋转0序列到u
        while (p != u) {
            s += '0';
            t += '0';
            p = (p + 1) % n;
        }
        // 旋转1序列到v
        while (q != v) {
            s += '1';
            t += '1';
            q = (q + 1) % n;
        }
        // 添加边
        s += '1'; t += '0';
        s += '0'; t += '1';
        p = (p + 1) % n;
        q = (q + 1) % n;
    }
    // 对齐p和q
    while (p != q) {
        s += '0';
        t += '0';
        p = (p + 1) % n;
    }
    // 补全平衡
    For(i, 0, n-1) {
        s += '1';
        t += '0';
    }
    cout << s.size() << "\n" << s << "\n" << t << "\n";
    return 0;
}
```

---
处理用时：306.54秒
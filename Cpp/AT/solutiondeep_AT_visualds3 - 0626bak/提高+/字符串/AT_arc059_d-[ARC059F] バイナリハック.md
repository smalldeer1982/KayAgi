# 题目信息

# [ARC059F] バイナリハック

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc059/tasks/arc059_d

しぐはキーボードを製作しました。シンプルさを極限まで追求したこのキーボードには、`0` キー、`1` キー、バックスペースキーの $ 3 $ つしかキーがありません。

手始めに、しぐはこのキーボードで簡単なテキストエディタを操作してみることにしました。このエディタには常に一つの文字列が表示されます（文字列が空のこともあります）。エディタを起動した直後では、文字列は空です。キーボードの各キーを押すと、文字列が次のように変化します。

- `0` キー: 文字列の右端に文字 `0` が挿入される。
- `1` キー: 文字列の右端に文字 `1` が挿入される。
- バックスペースキー: 文字列が空なら、何も起こらない。そうでなければ、文字列の右端の $ 1 $ 文字が削除される。

しぐはエディタを起動し、これらのキーを合計で $ N $ 回押しました。その結果、いまエディタに文字列 $ s $ が表示されています。このようなキーの押し方の個数を $ 10^9\ +\ 7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 5000 $
- $ 1\ ≦\ |s|\ ≦\ N $
- $ s $ は文字 `0`, `1` のみからなる。

### 部分点

- $ 1\ ≦\ N\ ≦\ 300 $ を満たすデータセットに正解すると、$ 400 $ 点が与えられる。

### Sample Explanation 1

バックスペースキーを `B` と表記すると、次の $ 5 $ 通りの押し方で最終的に表示される文字列が `0` となります: `00B`, `01B`, `0B0`, `1B0`, `BB0`。最後の押し方では、バックスペースキーを押すときに何も起こりません。

## 样例 #1

### 输入

```
3

0```

### 输出

```
5```

## 样例 #2

### 输入

```
300

1100100```

### 输出

```
519054663```

## 样例 #3

### 输入

```
5000

01000001011101000100001101101111011001000110010101110010000```

### 输出

```
500886057```

# AI分析结果



# 【算法分类】
动态规划

# 【题解思路与难点分析】
## 核心思路
题目要求计算通过N次按键操作生成特定字符串s的方案数。采用动态规划方法，定义`dp[i][j]`为前i次操作后，生成的字符串前j个字符与s的前j个字符完全匹配的方案数。状态转移分两种情况：
1. **输入字符**：只有当输入的字符与s的第j+1位相同时，才能从`j`转移到`j+1`。
2. **退格键**：删除最后一个字符，可能删除一个不匹配的字符，导致匹配长度减少，此时需乘以2（因被删字符可能为0或1）。

## 解决难点
- **状态定义**：需明确`dp[i][j]`表示匹配s前j个字符的方案数，而非仅长度。这确保了退格操作的正确处理。
- **转移方程**：退格操作需考虑删除的字符可能不匹配，因此从`j+1`转移时乘以2。输入字符需严格匹配s的对应位。

# 【题解评分】
1. **dd_d (5星)**：思路清晰，代码简洁，直接通过状态转移统计有效方案。
2. **zhylj (5星)**：引入长度无关的优化思路，最后逆元处理巧妙。
3. **Kevin_Zhen (5星)**：结合逆向思维，动态规划后逆元处理，代码高效。

# 【最优思路提炼】
- **状态设计**：`dp[i][j]`表示前i次操作后匹配s前j个字符的方案数。
- **退格处理**：从`j+1`转移时乘以2，考虑被删字符的两种可能性。
- **逆元优化**：对于长度无关的解法，最后用逆元处理总方案数。

# 【类似题目】
1. **LeetCode 44. Wildcard Matching**：动态规划处理通配符匹配。
2. **AtCoder DP Contest E - Knapsack 2**：状态压缩与动态规划结合。
3. **洛谷 P1279 字串距离**：动态规划处理字符串编辑操作。

# 【核心代码实现】
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;
int dp[5005][5005]; // dp[i][j]: i次操作后匹配前j字符的方案数

int main() {
    int n, m;
    string s;
    cin >> n >> s;
    m = s.size();
    dp[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= i; ++j) {
            // 输入字符0/1，需匹配s[j-1]
            if (j > 0) {
                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD;
            }
            // 退格键，可能删除任意字符（0或1）
            dp[i][j] = (dp[i][j] + 2LL * dp[i-1][j+1]) % MOD;
            // 处理j=0时退格不生效的情况
            if (j == 0) {
                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;
            }
        }
    }
    cout << dp[n][m] << endl;
    return 0;
}
```

# 【可视化算法演示】
## 动画设计
- **状态网格**：以二维网格展示`dp[i][j]`，每个单元格颜色深浅表示方案数多少。
- **高亮转移路径**：当前操作（输入/退格）时，高亮来源和目标状态。
- **像素风格**：采用8位像素风格，按键音效（退格低沉，输入清脆）。

## 交互功能
- **步进控制**：用户可单步执行观察状态转移。
- **自动演示**：AI自动运行，显示最优路径。
- **音效反馈**：退格键音效模拟经典键盘声，增强操作感。

---
处理用时：443.77秒
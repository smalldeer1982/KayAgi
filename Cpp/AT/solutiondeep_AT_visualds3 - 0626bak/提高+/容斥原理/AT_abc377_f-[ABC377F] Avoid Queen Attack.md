# 题目信息

# [ABC377F] Avoid Queen Attack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc377/tasks/abc377_f

縦 $ N $ マス、横 $ N $ マスの $ N\ ^\ 2 $ マスからなるマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ N) $ 、左から $ j $ 列目 $ (1\leq\ j\leq\ N) $ のマスをマス $ (i,j) $ と呼ぶことにします。

それぞれのマスは、空マスであるかコマが置かれているかのどちらかです。 マス目には合計で $ M $ 個のコマが置かれており、$ k $ 番目 $ (1\leq\ k\leq\ M) $ のコマはマス $ (a\ _\ k,b\ _\ k) $ に置かれています。

あなたは、すでに置かれている**どのコマにも取られないように**、いずれかの**空マス**に自分のコマを置きたいです。

マス $ (i,j) $ に置かれているコマは、次のどれかの条件を満たすコマを取ることができます。

- $ i $ 行目に置かれている
- $ j $ 列目に置かれている
- $ i+j=a+b $ となるようなマス $ (a,b)\ (1\leq\ a\leq\ N,1\leq\ b\leq\ N) $ に置かれている
- $ i-j=a-b $ となるようなマス $ (a,b)\ (1\leq\ a\leq\ N,1\leq\ b\leq\ N) $ に置かれている
 
たとえば、マス $ (4,4) $ に置かれているコマは、以下の図で青く示されたマスに置かれているコマを取ることができます。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc377_f/8d18db86e94185f3231deea439fe06a4aa9df2f8.png)

あなたがコマを置くことができるマスがいくつあるか求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq10\ ^\ 9 $
- $ 1\leq\ M\leq10\ ^\ 3 $
- $ 1\leq\ a\ _\ k\leq\ N,1\leq\ b\ _\ k\leq\ N\ (1\leq\ k\leq\ M) $
- $ (a\ _\ k,b\ _\ k)\neq(a\ _\ l,b\ _\ l)\ (1\leq\ k\lt\ l\leq\ M) $
- 入力はすべて整数
 
### Sample Explanation 1

すでに置かれているコマは、以下の図で青く示されたマスに置かれたコマを取ることができます。 !\[\](https://img.atcoder.jp/abc377/49766c3613371e99673e5722bd64ad58.png) よって、あなたがすでに置かれているコマに取られないように自分のコマを置くことができるマスはマス $ (6,6) $ とマス $ (7,7) $ の $ 2 $ つです。

### Sample Explanation 2

$ 10\ ^\ {18} $ マスのうち、置くことができないマスは $ 1 $ 行目のマス、$ 1 $ 列目のマス、およびマス $ (1,1), $ マス $ (2,2),\ldots, $ マス $ (10\ ^\ 9,10\ ^\ 9) $ の $ 3\times10\ ^\ 9-2 $ マスです。 答えが $ 2\ ^\ {32} $ 以上になる場合があることに注意してください。

## 样例 #1

### 输入

```
8 6

1 4

2 1

3 8

4 5

5 2

8 3```

### 输出

```
2```

## 样例 #2

### 输入

```
1000000000 1

1 1```

### 输出

```
999999997000000002```

## 样例 #3

### 输入

```
20 10

1 4

7 11

7 15

8 10

11 6

12 5

13 1

15 2

20 10

20 15```

### 输出

```
77```

# AI分析结果



## 算法分类
数学、容斥原理

---

## 综合分析与结论
题目要求在N×N棋盘上避开M个皇后的攻击范围，统计可用空位。核心思路是分步计算被行、列、对角线覆盖的区域，并处理重叠部分。

### 核心算法流程
1. **统计被占用的行、列、对角线**：记录所有行、列、i+j型对角线和i-j型对角线。
2. **初始未被覆盖的行列区域**：计算未被行和列覆盖的格子数 `(n-h.size())*(n-v.size())`。
3. **处理对角线覆盖**：
   - 对每条i+j型对角线，计算其长度并减去已被行或列覆盖的点。
   - 对每条i-j型对角线，计算长度并减去与行、列及i+j型对角线的交点。
4. **容斥调整**：通过逐步减去重复覆盖的部分，最终得到未被攻击的格子总数。

### 可视化设计
- **颜色标记**：用不同颜色区分行、列、对角线覆盖区域，高亮当前处理的对角线。
- **步进控制**：分步展示初始行列覆盖→处理i+j对角线→处理i-j对角线的过程。
- **复古像素效果**：用8-bit风格棋盘，音效提示覆盖区域的增减，自动演示关键步骤。

---

## 题解清单（≥4星）

### 1. xpz0525（5星）
- **亮点**：分步处理行列与对角线，巧妙处理重叠区域，代码简洁高效。
- **关键点**：初始行列乘积+对角线容斥调整，时间复杂度O(M²)适合M≤1e3。

### 2. kczw（4星）
- **亮点**：精确统计交点覆盖次数，map记录调整重复。
- **关键点**：通过直线交点计算覆盖数，复杂度较高但思路新颖。

---

## 最优思路提炼
1. **独立计算行列**：未被覆盖的行列数乘积作为初始解。
2. **对角线容斥**：每条对角线长度减去已被行列覆盖的点。
3. **避免重复**：用集合记录已处理点，确保每个区域只计算一次。

---

## 同类型题套路
- **棋盘覆盖问题**：如统计多个棋子攻击范围的并集。
- **容斥应用**：处理多集合覆盖时，分步计算并调整交集。

---

## 推荐题目
1. P1219 [八皇后]：经典皇后布局问题。
2. P1896 [SCOI2005 互不侵犯]：类似棋盘覆盖计数。
3. P2181 对角线：几何交点计数。

---

## 核心代码片段（xpz0525）
```cpp
ll ans = 1ll*(n-h.size())*(n-v.size());
for(int d : d1) { // 处理i+j型对角线
    set<int> s;
    // 计算行、列交点并存入集合s
    int len = (d<=n+1) ? d-1 : n*2 -d +1;
    ans -= len - s.size();
}
for(int d : d2) { // 处理i-j型对角线
    set<int> s;
    // 计算行、列及i+j交点并存入s
    int len = (d>=0) ? n-d : n +d;
    ans -= len - s.size();
}
```

---

## 可视化实现要点
- **Canvas绘制**：动态显示行、列、对角线覆盖区域，点击步进按钮分步展示。
- **音效触发**：覆盖区域扩展时播放低音，调整重复时播放高音。
- **自动演示**：按步骤自动运行，速度可调，支持暂停观察当前状态。

---
处理用时：105.09秒
# 题目信息

# [ABC383E] Sum of Max Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc383/tasks/abc383_e

頂点に $ 1 $ から $ N $ の番号が、辺に $ 1 $ から $ M $ の番号が付いた $ N $ 頂点 $ M $ 辺の重み付き単純連結無向グラフが与えられます。辺 $ i $ $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結び、重みは $ w_i $ です。

あるパスに対してその重みをそのパスに含まれる辺の重みの最大値とします。 また、$ f(x,y) $ を 頂点 $ x $ から頂点 $ y $ へのパスの重みとしてありえる最小値とします。

長さ $ K $ の数列 $ (A_1,A_2,\ldots,A_K) $ と $ (B_1,B_2,\ldots,B_K) $ が与えられます。ここで、$ A_i\ \neq\ B_j $ $ (1\ \leq\ i,j\ \leq\ K) $ が成り立つことが保証されます。

数列 $ B $ を自由に並べ替えて、$ \displaystyle\sum_{i=1}^{K}f(A_i,B_i) $ を最小化してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \min(\frac{N\ \times\ (N-1)}{2},2\ \times\ 10^5) $
- $ 1\ \leq\ K\ \leq\ N $
- $ 1\ \leq\ u_i\ <\ v_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ w_i\ \leq\ 10^9 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ K) $
- $ A_i\ \neq\ B_j $ $ (1\ \leq\ i,j\ \leq\ K) $
- 与えられるグラフは単純かつ連結
- 入力は全て整数

### Sample Explanation 1

$ B $ を並び替えて、$ B=(2,4,4) $ としたとき、 - $ f(1,2)=5 $ : 頂点 $ 1 $ から頂点 $ 4 $ を経由し頂点 $ 2 $ に行くパスがあり、辺 $ 3 $ の重み $ 5 $ が最大値を取ります。また、辺の重みの最大値が $ 4 $ 以下になるようなパスは存在しないため $ 5 $ が最小値です。 - $ f(1,4)=2 $ : 頂点 $ 1 $ から頂点 $ 3 $ を経由し頂点 $ 4 $ に行くパスがあり、辺 $ 1 $ の重み $ 2 $ が最大値を取ります。また、辺の重みの最大値が $ 1 $ 以下になるようなパスは存在しないため $ 2 $ が最小値です。 - $ f(3,4)=1 $ : 頂点 $ 3 $ から頂点 $ 4 $ への辺を通るパスがあり、辺の重みは $ 1 $ でこれが辺の重みの最大値です。また、パスの重みが $ 0 $ 以下になることはないため $ 1 $ が最小値です。 よって、この場合 $ \displaystyle\ \sum_{i=1}^{3}f(A_i,B_i)=5+2+1=8 $ となります。また、$ B $ をどのように並び替えても $ 7 $ 以下になることはないため、答えは $ 8 $ です。

## 样例 #1

### 输入

```
4 4 3
1 3 2
3 4 1
2 4 5
1 4 4
1 1 3
4 4 2```

### 输出

```
8```

## 样例 #2

### 输入

```
3 3 2
1 2 5
2 3 2
1 3 1
1 1
2 3```

### 输出

```
3```

# AI分析结果



**唯一算法分类**  
最小生成树（Kruskal算法）与贪心匹配

---

### **题解思路与核心难点**  
题目要求最小化所有配对路径的最大边权之和。关键点在于：  
1. **最小生成树性质**：两点间路径的最大边权的最小值，即为最小生成树中该路径的最大边权。  
2. **贪心匹配策略**：按边权从小到大处理，每次合并连通块时，尽可能多地匹配当前边权下的 A 和 B 元素。  

**实现要点**：  
- **并查集**维护连通块，记录每个块的 A/B 元素数量。  
- **合并时计算**：合并两个块时，计算两方向的匹配数（A 匹配 B，B 匹配 A），并累加总答案。  

---

### **题解评分（≥4星）**  
1. **gesong（5星）**：代码简洁高效，清晰处理双向匹配，贪心逻辑完整。  
2. **Dtw_（4.5星）**：代码结构清晰，注释明确，直接点明贪心本质。  
3. **Hanggoash（4星）**：详细证明思路，代码可读性稍弱但逻辑正确。  

---

### **最优思路与技巧**  
1. **Kruskal算法结合贪心**：边权从小到大处理，确保每次匹配的边权最小。  
2. **双向匹配计算**：合并时分别计算两方向的匹配数，避免遗漏。  
3. **并查集维护状态**：动态更新连通块的 A/B 元素数量，确保后续匹配正确。  

**核心代码片段（gesong）**：  
```cpp
for (int i=1;i<=m;i++) {
    int u=find(a[i].u), v=find(a[i].v), w=a[i].w;
    if (u == v) continue;
    // 匹配 u 的 A 与 v 的 B
    int cnt = min(sza[u], szb[v]);
    ans += w * cnt;
    sza[u] -= cnt; szb[v] -= cnt;
    // 匹配 u 的 B 与 v 的 A
    cnt = min(szb[u], sza[v]);
    ans += w * cnt;
    szb[u] -= cnt; sza[v] -= cnt;
    // 合并连通块
    sza[u] += sza[v]; szb[u] += szb[v];
    f[v] = u;
}
```

---

### **相似题目推荐**  
1. **P1967 货车运输**：最大生成树求路径最小边权的最大值。  
2. **CF76A Gift**：动态维护最小生成树。  
3. **P4185 MooTube**：Kruskal重构树处理连通性查询。  

---

### **可视化设计思路**  
**动画方案**：  
1. **并查集合并过程**：以像素风格展示连通块的合并，当前边高亮显示。  
2. **匹配计数显示**：每次合并时，动态更新 A/B 数量及匹配数，累加答案。  
3. **音效与交互**：  
   - 合并时播放“连接”音效，匹配成功时播放清脆提示音。  
   - 支持步进控制，观察每一步的 A/B 数量和匹配结果。  

**复古风格**：  
- **8-bit调色板**：连通块用不同颜色区分，匹配时闪烁高亮。  
- **Canvas绘制**：网格表示连通块，合并时动态连线并更新数值。  

---

### **总结**  
本题通过 Kruskal 算法与贪心策略，将问题转化为最小生成树上的匹配问题，结合并查集高效处理动态连通性。实现时需注意双向匹配的逻辑，确保所有可能的最优配对被计算。

---
处理用时：113.53秒
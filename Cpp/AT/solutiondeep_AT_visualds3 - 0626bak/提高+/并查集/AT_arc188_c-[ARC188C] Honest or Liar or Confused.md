# 题目信息

# [ARC188C] Honest or Liar or Confused

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc188/tasks/arc188_c

$ 1 $ から $ N $ までの番号がついた $ N $ 人の村人が住む村があります。 各村人は、正直者であるか嘘つきであるかのどちらかです。また、村人のうち何人かは混乱しています。

あなたは、村人による証言を $ M $ 個手に入れました。この証言は、$ i=1,2,\ \ldots\ ,M $ に対して $ A_i,\ B_i,\ C_i $ で与えられ、

- $ C_i=0 $ であれば、村人 $ A_i $ が村人 $ B_i $ を正直者であると証言したこと
- $ C_i=1 $ であれば、村人 $ A_i $ が村人 $ B_i $ を嘘つきであると証言したこと

を表します。

全ての村人は、他の全ての村人について正直者と嘘つきのどちらであるかを知っており、あなたに対して次のような規則で証言を行ったことが分かっています。

- 混乱していない正直者は必ず正しい証言をする。
- 混乱していない嘘つきは必ず嘘の証言をする。
- 混乱している正直者は必ず嘘の証言をする。
- 混乱している嘘つきは必ず正しい証言をする。

すなわち、混乱していなければ正直者は正しい証言を、嘘つきは嘘の証言をしますが、混乱していると逆になります。

あなたは**混乱している村人の組**を予想することにしました。 混乱している村人の組を決めると、与えられた $ M $ 個の証言からなる証言の組が「矛盾する」かどうかが定まります。 ここで、証言の組が「矛盾する」というのは、各村人が正直者であるか嘘つきであるかをどのように決めても、証言の組の中に、村人が行う証言の規則に反するものが存在することを意味します。

与えられた証言の組が矛盾しないような**混乱している村人の組**を $ 1 $ つ見つけてください。 ただし、どのような村人の組が混乱しているとしても与えられた証言の組が矛盾する場合は、そのことを指摘してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \mathrm{min}\ \lbrace\ 2\ \times\ 10^5,N(N-1)\ \rbrace $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N,\ A_i\ \neq\ B_i $
- $ i\neq\ j $ のとき $ A_i\neq\ A_j $ または $ B_i\neq\ B_j $
- $ C_i=0 $ または $ C_i=1 $
- 入力される値はすべて整数である

### Sample Explanation 1

村人 $ 1 $ が混乱していない正直者、村人 $ 2 $ が混乱している嘘つき、村人 $ 3 $ が混乱していない正直者であると仮定します。 このとき、村人 $ 1 $ は、村人 $ 2 $ が嘘つきである、村人 $ 3 $ が正直者であると正しい証言をします。 また、村人 $ 2 $ は嘘つきですが混乱しているため、村人 $ 3 $ が正直者であると正しい証言をします。 したがって、与えられた証言が全て村人の証言の規則通りに得られるため、村人 $ 2 $ のみ混乱していることを表す `010` は正当な出力の $ 1 $ つです。

### Sample Explanation 2

村人 $ 2,3 $ が混乱していると仮定してみます。 このとき、各村人が正直者であるかどうかについて $ 2^3=8 $ 通りの組み合わせがあります。 このうち、例えば、「村人 $ 1 $ が（混乱していない）正直者、村人 $ 2 $ が（混乱している）嘘つき、村人 $ 3 $ が（混乱している）正直者」であるとすると、村人 $ 2 $ は規則によれば正しい証言をするはずですが、村人 $ 1 $ を嘘つきであると嘘の証言をしています。 他の組み合わせに対しても、同様に規則に反する証言が生じることを確認できます。 したがって、村人 $ 2,3 $ が混乱しているとすると、与えられた証言の組は矛盾します。 実は、このケースでは、どのような村人の組が混乱しているとしても与えられた証言の組は矛盾します。

### Sample Explanation 3

混乱している人数は任意であり、題意の条件が満たされるならば $ 0 $ 人や全員でもよいです。

## 样例 #1

### 输入

```
3 3
1 2 1
1 3 0
2 3 0```

### 输出

```
010```

## 样例 #2

### 输入

```
3 6
1 2 1
1 3 0
2 1 1
2 3 0
3 1 1
3 2 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 0```

### 输出

```
000```

# AI分析结果



## 算法分类
扩展域并查集（2-XOR-SAT建模）

---

## 题解思路与核心分析

### 关键模型转换
1. **变量定义**：设 P_i 表示是否撒谎（0=诚实，1=撒谎），Q_i 表示是否混乱（0=清醒，1=混乱）
2. **证言约束**：经推导可得 R_A ⊕ P_B = C（其中 R_i = P_i ⊕ Q_i）
3. **等价转换**：将问题转化为带异或约束的布尔方程组，等价于 2-XOR-SAT 问题

### 数据结构与实现要点
1. **扩展域并查集**：每个村民拆分为4个域（原域+异或域，对应R和P的两种状态）
2. **合并规则**：
   ```cpp
   if w == 0:
      merge(u+2n, v)        // R_u=0时P_v=0
      merge(u+3n, v+n)     // R_u=1时P_v=1
   else:
      merge(u+2n, v+n)      // R_u=0时P_v=1 
      merge(u+3n, v)       // R_u=1时P_v=0
   ```
3. **合法性检查**：若存在同一变量的两种状态被合并则无解
4. **构造解**：优先选择未冲突的合法状态，利用并查集结果推导Q_i = P_i ⊕ R_i

### 解决难点
- **矛盾推导**：通过并查集快速检测约束冲突
- **状态构造**：处理未确定变量的自由赋值，保证解的完备性

---

## 高星题解推荐（≥4星）

### 1. rui_er（5星）
- **亮点**：模型转换清晰，代码简洁高效
- **核心代码**：
  ```cpp
  dsu.init(4*n);
  rep(i,1,m) {
      if(w == 0) 
          dsu.merge(u+2n, v), dsu.merge(u+3n, v+n);
      else
          dsu.merge(u+2n, v+n), dsu.merge(u+3n, v);
  }
  rep(i,1,n) 
      if(dsu.same(i, i+n)) return -1;
  ```

### 2. Albert_van（4星）
- **亮点**：极致代码精简，四域合并优化
- **创新点**：将变量域编码为0-3n的整型，压缩状态空间

### 3. fight_for_humanity（4星）
- **亮点**：带权并查集实现，清晰展示异或特性
- **关键逻辑**：
  ```cpp
  struct DSU {
      int fa[N],val[N];
      bool merge(int x,int y,int d) { // 带权合并
          val[fx] = val[x] ^ val[y] ^ d;
      }
  };
  ```

---

## 最优思路提炼

**核心技巧**：  
1. **双重状态压缩**：将P_i与Q_i的复合状态编码为R_i，减少变量维度  
2. **对称合并**：利用异或的对称性建立双向约束，避免暴力枚举  
3. **延迟赋值**：对未确定变量采用惰性合并策略，保证构造解的可行性  

**思维突破点**：  
- 发现混乱状态本质是**行为模式反转**，将问题转化为异或约束系统  
- 利用扩展域并查集的**等价类合并**特性处理大量约束  

---

## 同类题目推荐

1. [P2024 食物链] - 经典的三域扩展并查集  
2. [P5787 二分图] - 动态加边的二分图判定  
3. [CF1290C Prefix Enlightenment] - 带权并查集处理异或约束  

---

## 可视化设计

### 动画方案
1. **节点表示**：村民显示为像素方块，颜色区分四个域（红=原域，蓝=异或域）  
2. **合并动画**：  
   - 拖动证言线条连接对应域  
   - 合并时触发粒子效果，播放合成音效（8-bit音效库）  
3. **冲突检测**：  
   - 当检测到矛盾域时，触发红色闪烁并播放警报音  
4. **构造解演示**：  
   - 使用绿色高亮最终确定的Q_i状态  
   - 展示R_i与P_i的异或计算过程  

### 交互功能
- **速度调节**：滑块控制动画速度（0.5x-4x）  
- **单步执行**：按空格键逐条处理证言  
- **模式切换**：切换并查集合并过程与最终解构造视图  

### 像素风格实现
```javascript
// Canvas初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; // 16x16像素块

function drawVillager(x, y, state) {
    const colors = ['#FF5555', '#5555FF', '#FFAA00', '#55FF55'];
    ctx.fillStyle = colors[state];
    ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
}

// 音效系统
const sfx = {
    merge: new Howl({src: 'merge.wav'}),
    conflict: new Howl({src: 'error.wav'})
};
```

---

## 关键代码片段（rui_er实现）

```cpp
dsu.init(4*n);
rep(i,1,m) {
    int u, v, w;
    cin >> u >> v >> w;
    if(w == 0) {
        dsu.merge(u+2n, v);
        dsu.merge(u+3n, v+n);
    } else {
        dsu.merge(u+2n, v+n);
        dsu.merge(u+3n, v);
    }
}

rep(i,1,n) {
    if(dsu.same(i, i+n)) return -1; // 矛盾检测
    if(dsu.same(i, i+2n)) Q[i] = 0; // 构造解
    else if(dsu.same(i, i+3n)) Q[i] = 1;
    else { // 自由赋值
        dsu.merge(i+2n, i);
        Q[i] = 0; 
    }
}
```

---
处理用时：80.47秒
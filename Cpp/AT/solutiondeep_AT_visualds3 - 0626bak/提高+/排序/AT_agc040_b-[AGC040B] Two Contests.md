# 题目信息

# [AGC040B] Two Contests

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc040/tasks/agc040_b

$ 1 $ から $ 10^9 $ までの番号のついた $ 10^9 $ 人が参加する大会があります． この大会では，$ 2 $ 回のコンテストが行われます．

コンテストで出題する問題として，$ 1 $ から $ N $ までの番号のついた $ N $ 問が準備されています． 問題 $ i $ が出題された場合，番号が $ L_i $ 以上 $ R_i $ 以下の参加者は全員正解し，逆にそれ以外の参加者は誰も解けません．

これらの $ N $ 問を，$ 2 $ 回のコンテストに分けて出題します． どの問題も，ちょうど $ 1 $ 回のコンテストで出題されなくてはいけません． また，どちらのコンテストも，少なくとも $ 1 $ 問以上の問題が出題される必要があります．

それぞれのコンテストの**楽しさ**は，そのコンテストの全ての問題を解く参加者の人数です． $ 2 $ 回のコンテストの楽しさの和としてありうる最大の値を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ L_i\ \leq\ R_i\ \leq\ 10^9 $
- 入力される値はすべて整数である．

### Sample Explanation 1

以下のようにするのが最適です． - $ 1 $ 回目のコンテストで問題 $ 1,3 $ を出題する．人 $ 5,6,7 $ がこのコンテストの問題を全て解くので，コンテストの楽しさは $ 3 $ である． - $ 2 $ 回目のコンテストで問題 $ 2,4 $ を出題する．人 $ 2,3,4 $ がこのコンテストの問題を全て解くので，コンテストの楽しさは $ 3 $ である． - $ 2 $ 回のコンテストの楽しさの和が $ 6 $ になる．楽しさの和を $ 6 $ より大きくすることは出来ない．

## 样例 #1

### 输入

```
4

4 7

1 4

5 8

2 5```

### 输出

```
6```

## 样例 #2

### 输入

```
4

1 20

2 19

3 18

4 17```

### 输出

```
34```

## 样例 #3

### 输入

```
10

457835016 996058008

456475528 529149798

455108441 512701454

455817105 523506955

457368248 814532746

455073228 459494089

456651538 774276744

457667152 974637457

457293701 800549465

456580262 636471526```

### 输出

```
540049931```

# AI分析结果



**唯一算法分类**  
贪心算法、排序

---

### **综合分析与结论**

1. **核心思路**  
   - 所有区间的最大左端点（`maxL`）和最小右端点（`minR`）决定了整体交集的上下限。  
   - 分两类讨论：  
     a. `maxL`和`minR`在同一组：另一组取最长区间长度，总值为 `max(0, minR - maxL + 1) + 最长区间长度`。  
     b. `maxL`和`minR`在不同组：预处理每个区间的贡献值 `a = r_i - maxL + 1` 和 `b = minR - l_i + 1`，排序后维护后缀最小值优化计算。

2. **关键步骤**  
   - 计算全局 `maxL` 和 `minR`，预处理每个区间的 `a` 和 `b`。  
   - 按 `a` 降序排序，遍历时维护后缀 `b` 的最小值，计算 `a_i + min_b` 的最大值。  
   - 最终取两种情况的较大值。

3. **可视化设计**  
   - **动画演示**：  
     - **步骤1**：用柱状图动态显示所有区间的 `l_i` 和 `r_i`，高亮 `maxL`（红色）和 `minR`（蓝色）。  
     - **步骤2**：分屏显示两种情况的处理流程。  
     - **步骤3**：排序过程用交换动画展示，遍历时用指针标记当前 `a_i`，动态更新后缀 `b` 的最小值（绿色标记）。  
   - **像素风格**：采用8位复古色块表示区间，分组时用不同颜色闪烁反馈。  
   - **音效**：找到更大值时播放上升音效，排序完成时播放确认音效。

---

### **题解清单 (4星及以上)**  
1. **Unnamed114514（4.5星）**  
   - **亮点**：代码简洁，预处理与排序逻辑清晰，直接覆盖两种关键情况。  
   - **引用心得**：通过预处理 `a` 和 `b` 巧妙转化为排序问题，避免了复杂的分类讨论。

2. **约瑟夫用脑玩（4星）**  
   - **亮点**：详细讨论 `maxL` 和 `minR` 是否同一区间带来的情况，启发式分析帮助理解。  
   - **引用心得**：“枚举 `r_x` 并利用后缀最大值”为后续优化提供思路。

3. **gi_A（4星）**  
   - **亮点**：代码逻辑与题解完全对应，注释清晰，适合快速理解核心步骤。  

---

### **代码实现（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;

int n, l[N], r[N], maxL, minR, maxLen;
struct Node { int a, b; } f[N];

int main() {
    scanf("%d", &n);
    minR = 1e9;
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &l[i], &r[i]);
        maxL = max(maxL, l[i]);
        minR = min(minR, r[i]);
        maxLen = max(maxLen, r[i] - l[i] + 1);
    }
    
    int ans = max(maxLen + max(0, minR - maxL + 1), 0); // 情况1
    
    for (int i = 1; i <= n; i++) { // 预处理a和b
        f[i].a = max(r[i] - maxL + 1, 0);
        f[i].b = max(minR - l[i] + 1, 0);
    }
    sort(f + 1, f + n + 1, [](Node x, Node y) {
        return x.a > y.a || (x.a == y.a && x.b > y.b);
    });
    
    int minB = f[n].b;
    for (int i = n - 1; i >= 1; i--) { // 维护后缀最小b
        ans = max(ans, f[i].a + minB);
        minB = min(minB, f[i].b);
    }
    printf("%d\n", ans);
    return 0;
}
```

---

### **同类型题推荐**  
1. **CF1133E**：区间分组最大化覆盖（贪心+排序）。  
2. **LeetCode 56**：合并区间（排序处理端点）。  
3. **洛谷P1884**：区间覆盖问题（贪心排序端点）。  

---

### **可视化实现要点**  
- **Canvas动画**：  
  - 初始绘制所有区间为灰色方块，左右端点对齐坐标轴。  
  - 计算 `maxL` 和 `minR` 时，用红色/蓝色边框高亮对应区间。  
  - 排序过程用冒泡动画展示，每一步交换相邻元素。  
- **音效触发**：  
  - 排序完成：播放8-bit风格“升级”音效。  
  - 发现更大答案：播放短促“金币”音效。  
- **交互控制**：  
  - 速度滑块调节排序动画速度。  
  - 暂停/继续按钮控制流程，支持单步调试。  

---

**总结**：通过贪心与排序高效处理区间分组问题，关键是对 `maxL` 和 `minR` 的讨论及预处理优化。

---
处理用时：112.85秒
# 题目信息

# [ARC179C] Beware of Overflow

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc179/tasks/arc179_c

この問題は**インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

正整数 $ N $ が与えられます.

ジャッジシステムは正整数 $ R $ および $ N $ 個の整数 $ A_1,A_2,\dots\ ,A_N $ を隠し持っています. ここで $ |A_i|\le\ R,\ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $ を満たすことが保証されます.

絶対値が $ R $ 以下の整数しか書き込むことができない黒板があり, はじめは何も書き込まれていません.

ジャッジシステムは, 黒板に $ A_1,A_2,\ \dots\ ,A_N $ の値を **この順で** 書き込みました. あなたは, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にする必要があります.

あなたは $ R $ および $ A_i $ の値を直接知ることはできませんが, その代わりにジャッジシステムに対して次のやり取りを $ 25000 $ 回まで行うことができます.

正整数 $ i $ について, $ i $ 番目に黒板に書き込まれた整数を $ X_i $ とします. 特に, $ i=1,2,\dots\ ,N $ について $ X_i=A_i $ です.

$ 1 $ 回のやり取りでは, 相異なる正整数 $ i,j $ を指定し, 次のいずれかを選んで行います.

- 足し算をしてもらう. ジャッジシステムは黒板から $ X_i,X_j $ を消し, 新たに $ X_i+X_j $ の値を黒板に書き込む.
  - $ |X_i+X_j|\le\ R $ を満たしていなくてはならない.
- 大小比較をしてもらう. ジャッジシステムは $ X_i\lt\ X_j $ の真偽を答える.

ただし, 各やり取りを始める時点で $ i,j $ 番目に黒板に書き込まれた整数がすでに黒板から消されていてはなりません.

適切にやり取りを行って, 全てのやり取りを終えた後に黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にしてください.

$ R $ および $ A_i $ はプログラムとジャッジシステムの対話の開始前に決定されます.

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

最初に, $ N $ を標準入力から受け取ってください.

> $ N $

次に, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になるまで, やり取りを繰り返してください.

足し算をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> + $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ P $

ここで $ P $ は整数で,

- $ P\geq\ N+1 $ の場合は, $ X_i+X_j $ の値が黒板に書き込まれ, それが $ P $ 番目に書き込まれたことを表します.
- $ P=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

大小比較をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> ? $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ Q $

ここで $ Q $ は整数で,

- $ Q=1 $ の場合は, $ X_i\ <\ X_j $ が真であることを表します.
- $ Q=0 $ の場合は, $ X_i\ <\ X_j $ が偽であることを表します.
- $ Q=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

足し算をしてもらうやり取りおよび大小比較をしてもらうやり取りのいずれについても, ジャッジシステムの応答が $ -1 $ であった場合は, プログラムはすでに不正解とみなされています. この場合, ただちにプログラムを終了してください.

黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になったら, 以下の形式でそのことをジャッジシステムに報告してください. ただし, これはジャッジシステムとのやり取りの回数に計上されません. その後, ただちにプログラムを終了してください.

```
!
```

上記のいずれの形式にも当てはまらない出力を行った場合は, `-1` が標準入力から与えられます.

```
-1
```

このときも, プログラムはすでに不正解とみなされています. ただちにプログラムを終了してください.

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 1000 $
- $ 1\leq\ R\leq\ 10^9 $
- $ |A_i|\leq\ R $
- $ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $
- $ N,R,A_i $ は整数.

### 注意点

- **出力を行うたびに, 末尾に改行を入れて標準出力を flush してください. そうしなかった場合, ジャッジ結果が TLE となる可能性があります.**
- 解答を出力したら（または `-1` を受け取ったら）ただちにプログラムを終了してください. そうしない場合, ジャッジ結果は不定です.
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください.

### 入出力例

$ N=3,R=10,A_1=-1,A_2=10,A_3=1 $ のときの対話の一例を示します.

入力出力説明`3`まず整数 $ N $ が与えられます。`? 1 2`大小比較をしてもらいます.`1`$ X_1\lt\ X_2\ (-1\lt\ 10) $ なのでジャッジシステムは $ 1 $ を返します. `+ 1 3`足し算をしてもらいます.`4`ジャッジシステムは $ X_1=-1,X_3=1 $ を黒板から消し, $ X_1+X_3=0 $ の値を黒板に書き込みました. $ 4 $ 番目の書き込みでした.`+ 2 4`足し算をしてもらいます.`5`ジャッジシステムは $ X_2=10,X_4=0 $ を黒板から消し, $ X_2+X_4=10 $ の値を黒板に書き込みました. $ 5 $ 番目の書き込みでした.`!`黒板にはただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態になったので, そのことをジャッジシステムに報告します.

# AI分析结果



## 算法分类
**贪心算法**（通过每次选择最小和最大值相加的策略，确保每次操作合法）

---

## 题解思路与算法要点

### 核心思路
1. **排序数组**：通过交互式比较操作对初始数组进行排序，使用归并排序保证时间复杂度为O(n log n)。
2. **贪心合并**：每次取排序后的首尾元素相加（最小值和最大值），确保其和的绝对值不超过R。
3. **插入新值**：将合并后的新值通过二分查找插入有序数组，保证后续操作的高效性。

### 解决难点
- **合法性证明**：需严格证明每次合并首尾元素的操作不会溢出R。
  - **同符号**：若全正或全负，总和≤R，首尾和必然≤总和。
  - **异符号**：合并后的绝对值必小于等于较大的那个数的绝对值，故不会溢出。
- **操作次数控制**：归并排序和二分插入的总操作次数为O(2n log n)，对于n=1000足够。

### 题解对比
| 题解作者       | 核心亮点                                      | 评分（★） |
|----------------|---------------------------------------------|-----------|
| fcy20180201    | 严格数学证明，归并排序+二分插入实现清晰          | ★★★★★     |
| Moya_Rao       | 使用STL简化代码，逻辑简洁                      | ★★★★☆     |
| Exp10re        | 结合`deque`和`lower_bound`优化插入步骤         | ★★★★☆     |

---

## 最优思路与技巧提炼
- **关键策略**：排序后首尾合并，确保操作合法性。
- **插入优化**：二分查找插入位置，减少比较次数。
- **数据结构**：动态数组（如`deque`或手动维护数组）高效处理插入和删除。

---

## 同类型题与类似套路
- **合并类贪心**：如[NOIP2004 合并果子](https://www.luogu.com.cn/problem/P1090)。
- **交互式排序**：如[CF862B Mahmoud and Ehab and the bipartiteness](https://codeforces.com/contest/862/problem/B)。
- **动态维护有序性**：如[LeetCode 295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)。

---

## 推荐洛谷题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
   **考察点**：贪心策略合并最小元素。
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
   **考察点**：归并排序的应用。
3. [P7078 贪吃蛇](https://www.luogu.com.cn/problem/P7078)  
   **考察点**：动态维护极值的贪心策略。

---

## 代码核心实现
```cpp
// 归并排序核心片段
void mergeSort(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);
    // 合并有序子数组
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (cmp(arr[i], arr[j])) tmp[k++] = arr[i++];
        else tmp[k++] = arr[j++];
    }
    while (i <= mid) tmp[k++] = arr[i++];
    while (j <= r) tmp[k++] = arr[j++];
    // 复制回原数组
    for (int p = 0; p < k; p++) arr[l + p] = tmp[p];
}

// 合并与插入核心片段
while (arr.size() > 1) {
    int x = arr.front(), y = arr.back();
    arr.pop_front(); arr.pop_back();
    int sum = queryAdd(x, y); // 交互获取合并后的值
    // 二分查找插入位置
    auto pos = lower_bound(arr.begin(), arr.end(), sum, cmp);
    arr.insert(pos, sum);
}
```

---

## 可视化与算法演示设计
### 动画方案
1. **排序阶段**：
   - **颜色标记**：当前比较的元素标为红色，已排序部分渐变为绿色。
   - **分治展示**：递归拆分数组的过程用树状结构展示。
2. **合并阶段**：
   - **高亮操作**：首尾元素用黄色框标记，合并后新元素闪烁蓝色。
   - **插入过程**：二分查找时，中间指针用紫色标记，插入位置用箭头指示。
3. **复古风格**：
   - **8位像素**：数组用像素块表示，数值显示为16x16像素字符。
   - **音效设计**：比较操作触发“滴”声，合并操作触发“咚”声。

### 交互功能
- **步进控制**：支持暂停/继续，单步执行观察排序和合并细节。
- **速度调节**：拖动条控制动画速度（0.5x~4x）。
- **自动演示**：AI模式自动完成所有步骤，类似贪吃蛇AI路径展示。

---

## 个人心得摘录
- **fcy20180201**：首次AC时未考虑插入位置的边界条件，调试后发现需处理空数组情况。
- **Exp10re**：使用`deque`时发现频繁插入删除效率更高，避免手动数组的移位开销。
- **I_will_AKIOI**：曾误用快速排序导致比较次数超限，改用归并排序后通过。

---
处理用时：77.02秒
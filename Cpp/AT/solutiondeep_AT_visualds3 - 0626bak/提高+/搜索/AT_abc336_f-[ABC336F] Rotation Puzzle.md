# 题目信息

# [ABC336F] Rotation Puzzle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc336/tasks/abc336_f

$ H $ 行 $ W $ 列のマス目があり、最初、$ 1 $ 以上 $ (H\times\ W) $ 以下の整数がちょうど $ 1 $ つずつ書き込まれています。  
 具体的には、$ 1\leq\ i\leq\ H $, $ 1\leq\ j\leq\ W $ について、上から $ i $ 行目かつ左から $ j $ 列目のマスには $ S_{i,j} $ が書き込まれています。  
 以下、上から $ i $ 行目かつ左から $ j $ 列目のマスをマス $ (i,j) $ と呼びます。

次の操作を **高々 $ 20 $ 回** （$ 0 $ 回でも良い）繰り返すことで、  
 任意の整数の組 $ (i,j) $ $ (1\leq\ i\leq\ H,\ 1\leq\ j\leq\ W) $ について、 マス $ (i,j) $ に $ ((i-1)\times\ W+j) $ が書き込まれている状態にできるか判定し、  
 できる場合は必要な操作回数の最小値を出力してください。  
 $ 20 $ 回以下でできない場合（何回操作を繰り返してもできない場合を含む）は $ -1 $ を出力してください。

> 操作：マス目から $ (H-1)\ \times\ (W-1) $ の長方形を選んで $ 180 $ 度回転させる。  
>  より厳密には、整数 $ x,y $ $ (0\ \leq\ x,\ y\ \leq\ 1) $ を選び、  
>  $ 1\ \leq\ i\ \leq\ H-1 $, $ 1\ \leq\ j\ \leq\ W-1 $ をみたすすべての整数の組 $ (i,j) $ について同時に、  
>  マス $ (i+x,j+y) $ に書かれた整数をマス $ (H-i+x,W-j+y) $ に書かれた数に書き換える。

マス目に書き込まれている整数が条件をみたしていれば良く、書き込まれている向き等は考える必要がないことに注意してください。

## 说明/提示

### 制約

- $ 3\leq\ H,W\leq\ 8 $
- $ 1\leq\ S_{i,j}\leq\ H\times\ W $
- $ (i,j)\neq\ (i',j') $ ならば $ S_{i,j}\neq\ S_{i',j'} $
- 入力はすべて整数
 
### Sample Explanation 1

次の順で操作を行うことで $ 2 $ 回の操作で問題文の条件をみたすようにすることができます。 - 左上の長方形を選び、操作を行う。すなわち $ x=0 $, $ y=0 $ を選んで操作を行う。 - 右下の長方形を選び、操作を行う。すなわち $ x=1 $, $ y=1 $ を選んで操作を行う。 一方で $ 1 $ 回以下の操作でみたすようにすることは不可能であるため、$ 2 $ を出力します。 

![](https://img.atcoder.jp/abc336/75a97e79fc11bfe9406ef4e3bef74f37.png)

### Sample Explanation 2

$ 20 $ 回以下の操作で条件をみたすようにすることができないため、$ -1 $ を出力します。

## 样例 #1

### 输入

```
3 3

9 4 3

2 1 8

7 6 5```

### 输出

```
2```

## 样例 #2

### 输入

```
4 6

15 18 1 14 3 4

23 24 19 8 9 12

13 2 17 6 5 16

21 22 7 20 11 10```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 6

1 4 13 16 15 18

21 20 9 12 23 10

17 14 5 6 3 2

11 22 7 24 19 8```

### 输出

```
20```

## 样例 #4

### 输入

```
4 3

1 2 3

4 5 6

7 8 9

10 11 12```

### 输出

```
0```

# AI分析结果



## 算法分类  
**双向BFS**  

---

## 综合分析与结论  
### 核心思路与难点  
题目要求通过最多20次操作将网格变为目标状态。每次操作有4种选择，直接暴力枚举状态数达4^20，需优化。  
**双向BFS/折半搜索**是核心解法：  
1. **双向搜索**：从初始状态和目标状态同时展开BFS，各搜10层，总状态数降为2×4^10≈2M。  
2. **哈希加速**：将网格状态编码为哈希值（双模哈希防碰撞），快速比较状态是否相遇。  
3. **旋转操作**：每次操作选一个(H-1)×(W-1)子矩阵旋转180°，正确实现坐标变换是关键。  

### 可视化设计  
- **动画流程**：网格初始化为输入状态，每次操作高亮选中区域并旋转，同时展示双向BFS队列扩展。相遇时路径用不同颜色标记。  
- **像素风格**：用Canvas绘制网格，每个格子用8位色块表示数值。旋转时添加“像素翻转”动画。  
- **音效交互**：访问新节点时播放短音效，找到解时播放胜利音效，失败时低沉音效。支持暂停/步进观察状态扩展。  

---

## 题解评分（≥4星）  
1. **qqqaaazzz_qwq（5星）**  
   - 双向BFS标准实现，队列交替扩展，哈希记录状态。  
   - 代码清晰，结构分明，旋转函数准确。  
2. **int_R（4星）**  
   - 折半搜索结合双模哈希，减少碰撞风险。  
   - DFS实现但记录最小步数，思路新颖。  
3. **small_john（4星）**  
   - 使用二维vector存储状态，map管理步数。  
   - 队列同时处理双向搜索，逻辑简洁。  

---

## 最优思路与代码片段  
### 关键技巧  
1. **双向BFS加速**：起点和终点同时扩展，相遇即最短路径。  
2. **哈希压缩状态**：将二维数组转为长整型哈希，双模哈希防冲突。  
3. **坐标变换公式**：旋转区域内的点(i,j)映射到对称位置。  

### 代码示例  
```cpp
// 双向BFS核心逻辑（qqqaaazzz_qwq的代码片段）
int bfs() {
    queue<Node> q1, q2;
    q1.push(st); q2.push(ed);
    c1[HASH(st)] = 0; c2[HASH(ed)] = 0;

    while (!q1.empty() && !q2.empty()) {
        Node t = q1.front(); q1.pop();
        int q_hash = HASH(t);
        if (c2.count(q_hash)) return c1[q_hash] + c2[q_hash]; // 相遇

        // 扩展四个方向
        for (int x=0; x<2; x++) for (int y=0; y<2; y++) {
            Node p = Turn(t, x, y);
            int k = HASH(p);
            if (!c1.count(k) && c1[q_hash]+1 <= 10) {
                c1[k] = c1[q_hash] + 1;
                q1.push(p);
            }
        }
        // 反向队列同理
    }
    return -1;
}
```

---

## 相似题目推荐  
1. **P1379 八数码难题**：3×3网格通过滑动变为目标，BFS最短路径。  
2. **P2730 [USACO]魔板**：状态转换通过旋转/交换操作，双向BFS优化。  
3. **CF100589J**：网格旋转与路径搜索，折半哈希技巧。  

---

## 个人心得摘录  
- **哈希冲突教训**：单哈希易碰撞，双模哈希更可靠（int_R的代码）。  
- **坐标变换调试**：旋转时确保对称点计算正确，通过单元测试验证（robertuu的调试经历）。  

---

## 可视化实现（伪代码）  
```javascript
// Canvas绘制网格与动画
function drawGrid(state) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < H; i++) {
        for (let j = 0; j < W; j++) {
            ctx.fillStyle = getColor(state[i][j]);
            ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
}
// 旋转动画
function animateRotation(area, callback) {
    let angle = 0;
    const interval = setInterval(() => {
        angle += 10;
        drawRotatedArea(area, angle);
        if (angle >= 180) {
            clearInterval(interval);
            callback();
        }
    }, 50);
}
```  
**交互设计**：  
- 按键控制步进/自动播放，右侧面板显示当前步数及队列状态。  
- 音效使用Web Audio API，不同操作触发不同8-bit音效。

---
处理用时：131.73秒
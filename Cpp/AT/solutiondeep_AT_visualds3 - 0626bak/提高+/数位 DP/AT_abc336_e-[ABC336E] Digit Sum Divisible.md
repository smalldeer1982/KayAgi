# 题目信息

# [ABC336E] Digit Sum Divisible

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc336/tasks/abc336_e

正整数 $ n $ の **桁和** を、$ n $ を $ 10 $ 進法で表したときの各桁の和として定義します。例えば $ 2024 $ の桁和は $ 2+0+2+4=8 $ です。  
 正整数 $ n $ が $ n $ の桁和で割り切れる時、$ n $ を **良い整数** と呼びます。例えば $ 2024 $ はその桁和である $ 8 $ で割り切れるので良い整数です。  
 正整数 $ N $ が与えられます。$ N $ 以下の良い整数は全部で何個ありますか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^{14} $
- $ N $ は整数
 
### Sample Explanation 1

$ 20 $ 以下の良い整数は $ 1,2,3,4,5,6,7,8,9,10,12,18,20 $ の $ 13 $ 個です。

## 样例 #1

### 输入

```
20```

### 输出

```
13```

## 样例 #2

### 输入

```
2024```

### 输出

```
409```

## 样例 #3

### 输入

```
9876543210```

### 输出

```
547452239```

# AI分析结果



---

## 算法分类

**数位动态规划（数位DP）**

---

## 题解思路与核心难点

### 核心思路
1. **枚举数位和**：由于数位和最大为 $14 \times 9 = 126$，直接枚举所有可能的数位和 $x$。
2. **数位DP**：对于每个 $x$，使用数位DP统计满足条件的数的个数：
   - **状态定义**：`f[pos][s][sum][limit]`，表示处理到第 `pos` 位时，剩余可用数位和为 `s`，当前数模 $x$ 为 `sum`，是否受原数限制 `limit`。
   - **转移**：枚举当前位的数字 `i`，更新剩余数位和 `s-i` 和模值 `(sum * 10 + i) % x`。
   - **边界条件**：处理完所有位时，需满足 `s == 0` 且 `sum == 0`。

### 解决难点
- **动态模数**：数位和 $x$ 是动态的，需在每个枚举的 $x$ 下独立进行DP。
- **状态压缩**：需同时跟踪数位和和模数，避免状态爆炸。
- **记忆化优化**：每个 $x$ 的DP过程需重置记忆化数组，防止状态污染。

---

## 题解评分（≥4星）

1. **int_R（⭐⭐⭐⭐⭐）**  
   - **亮点**：代码简洁，状态定义清晰，记忆化逻辑明确，参数命名直观。
   - **核心代码**：
     ```cpp
     int dfs(int pos, int s, int sum, bool limit) {
         if (s < 0) return 0;
         if (!pos) return !s && !sum;
         if (f[pos][s][sum][limit] != -1) return f[pos][s][sum][limit];
         int ans = 0, up = limit ? a[pos] : 9;
         for (int i = 0; i <= up; ++i)
             ans += dfs(pos - 1, s - i, (sum * 10 + i) % cur, limit && (i == up));
         return f[pos][s][sum][limit] = ans;
     }
     ```
2. **aaron0919（⭐⭐⭐⭐）**  
   - **亮点**：剪枝优化（`if (i + sum > mod) break`），减少无效递归。
   - **核心代码**：
     ```cpp
     if (i + sum > mod) break;
     ret += dfs(len - 1, sum + i, (sta * 10 + i) % mod, bj && (i == maxx));
     ```
3. **Elairin176（⭐⭐⭐⭐）**  
   - **亮点**：状态定义简洁，直接记录当前数位和和模数，代码易扩展。

---

## 最优思路提炼

### 关键步骤
1. **枚举数位和 $x$**：范围 $1 \leq x \leq 126$。
2. **数位DP**：对每个 $x$ 独立处理：
   - **状态参数**：`(位置, 剩余数位和, 模值, 是否受限)`。
   - **记忆化优化**：避免重复计算相同状态。
3. **边界检查**：最终需满足数位和等于 $x$ 且数能被 $x$ 整除。

### 代码实现技巧
- **动态重置记忆化数组**：每个 $x$ 处理前重置 `memset(f, -1, sizeof(f))`。
- **递归剪枝**：提前终止无效分支（如剩余数位和为负）。

---

## 类似题目推荐
1. **P4127 [AHOI2009] 同类分布**  
   - **相似点**：同样要求数能被其数位和整除，需数位DP枚举数位和。
2. **CF1036C. Classy Numbers**  
   - **相似点**：数位DP统计满足条件的数，需跟踪非零位数状态。
3. **P2602 [ZJOI2010] 数字计数**  
   - **相似点**：经典数位DP问题，统计数字出现次数。

---

## 可视化设计

### 动画方案
- **像素风格界面**：用 8 位像素风格绘制数位和状态栏，当前处理位高亮。
- **状态显示**：实时显示剩余数位和、当前模值、当前位选择数字。
- **音效反馈**：选择数字时播放音调，成功匹配时播放胜利音效。

### 关键帧示例
1. **初始化**：显示数位分解（如 `2024` → `[2,0,2,4]`）。
2. **递归步骤**：高亮当前处理位，显示可选数字范围和状态变化。
3. **边界检查**：成功匹配时，显示绿色边框和得分增加。

### 交互功能
- **步进控制**：允许单步执行观察状态变化。
- **自动演示**：按预设速度自动运行，展示不同 $x$ 的DP过程。

---

## 个人心得摘录
- **剪枝的重要性**：aaron0919 提到提前终止 `sum > mod` 的分支，显著优化性能。
- **状态污染**：多个题解强调每次枚举 $x$ 后必须重置记忆化数组，否则结果错误。

---

## 代码片段（核心逻辑）

```cpp
// int_R 的核心DFS实现
int dfs(int pos, int s, int sum, bool limit) {
    if (s < 0) return 0;
    if (!pos) return !s && !sum;
    if (f[pos][s][sum][limit] != -1) return f[pos][s][sum][limit];
    int ans = 0, up = limit ? a[pos] : 9;
    for (int i = 0; i <= up; ++i)
        ans += dfs(pos - 1, s - i, (sum * 10 + i) % cur, limit && (i == up));
    return f[pos][s][sum][limit] = ans;
}

// 主循环枚举数位和
for (int i = 1; i <= 14 * 9; ++i) {
    memset(f, -1, sizeof(f));
    ANS += dfs(tot, cur = i, 0, 1);
}
```

---

**可视化与算法演示** 可通过在线工具或自定义动画实现，突出数位选择和状态更新过程。

---
处理用时：94.21秒
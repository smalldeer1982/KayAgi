# 题目信息

# [ABC312Ex] snukesnuke

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc312/tasks/abc312_h

高橋君は人 $ 1,\ldots,N $ の $ N $ 人のあだ名を決めることになりました。

人 $ i $ はあだ名を $ S_i $ にしてほしいと思っています。複数人に同じあだ名をつけるのを避けるため、高橋君は次の手順で $ N $ 人のあだ名を決めることにしました。

- $ i=1,\ldots,N $ の順に、以下の操作により人 $ i $ のあだ名を決める
  - 変数 $ k_i $ を $ 1 $ とする。
  - 「$ S_i $ を $ k_i $ 回繰り返した文字列」がすでに誰かのあだ名である間、$ k_i $ を $ 1 $ 増やすことを繰り返す。
  - 「$ S_i $ を $ k_i $ 回繰り返した文字列」を人 $ i $ のあだ名とする。
 
$ N $ 人のあだ名を決めた後の $ k_1,\ldots,k_N $ を求めてください。

## 说明/提示

### 制約

- $ N\ \geq\ 1 $
- $ S_i $ は英小文字のみからなる、長さ $ 1 $ 以上の文字列
- $ S_i $ の長さの総和は $ 2\times\ 10^5 $ 以下
 
### Sample Explanation 1

\- まず人 $ 1 $ のあだ名を決めます。 - $ k_1=1 $ とします。 - $ S_1 $ を $ k_1 $ 回繰り返した文字列 `snuke` は誰のあだ名でもないので、人 $ 1 $ のあだ名は `snuke` になります。 - 次に人 $ 2 $ のあだ名を決めます。 - $ k_2=1 $ とします。 - $ S_2 $ を $ k_2 $ 回繰り返した文字列 `snuke` はすでに人 $ 1 $ のあだ名なので、$ k_2 $ を $ 1 $ 増やして $ 2 $ とします。 - $ S_2 $ を $ k_2 $ 回繰り返した文字列 `snukesnuke` は誰のあだ名でもないので、人 $ 2 $ のあだ名は `snukesnuke` になります。 - 最後に人 $ 3 $ のあだ名を決めます。 - $ k_3=1 $ とします。 - $ S_3 $ を $ k_3 $ 回繰り返した文字列 `rng` は誰のあだ名でもないので、人 $ 3 $ のあだ名は `rng` になります。 以上により、$ k_1,k_2,k_3 $ はそれぞれ $ 1,2,1 $ となります。

### Sample Explanation 2

\- 人 $ 1 $ のあだ名は `aa` になります。 - 人 $ 2 $ のあだ名は `a` になります。 - 人 $ 3 $ のあだ名は、`a`, `aa` がすでに他の人のあだ名なので、`aaa` になります。 - 人 $ 4 $ のあだ名は、`aaa` がすでに他の人のあだ名なので、`aaaaaa` になります。

## 样例 #1

### 输入

```
3

snuke

snuke

rng```

### 输出

```
1 2 1```

## 样例 #2

### 输入

```
4

aa

a

a

aaa```

### 输出

```
1 1 3 2```

## 样例 #3

### 输入

```
5

x

x

x

x

x```

### 输出

```
1 2 3 4 5```

# AI分析结果



**唯一算法分类**：数论

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- 每个字符串的最小循环节是关键，相同循环节的字符串可能因倍数重复冲突。
- **KMP算法**预处理每个字符串的最小循环节及重复次数。
- 对每个循环节维护已使用的倍数，动态查找最小可用倍数。

#### **解决难点**
1. **循环节提取**：利用KMP的前缀数组确定最小循环节长度。
2. **高效查询**：维护每个循环节的已用倍数集合，避免暴力枚举。
3. **时间复杂度优化**：通过记录每个循环节的当前查询位置，均摊复杂度至O(N log N)。

#### **数学方法**
- **KMP前缀函数**：若字符串长度为`n`，且`n % (n - ne[n-1]) == 0`，则最小循环节为`n - ne[n-1]`。
- **因数分解优化**：对于插入的倍数`x`，枚举其因数并更新对应循环节的最小可用倍数。

---

### **题解评分 (≥4星)**
1. **hzlqwq的题解（4星）**
   - **亮点**：代码清晰，使用KMP预处理循环节，哈希表维护倍数集合。
   - **优化**：通过`jmp`数组记录每个循环节的当前查询位置，避免重复检查。

2. **Genius_Star的题解（4星）**
   - **亮点**：动态维护每个循环节的因数倍数，均摊时间复杂度更优。
   - **数学核心**：利用因数分解快速更新最小可用倍数。

3. **liangbowen的题解（4星）**
   - **亮点**：记忆化处理相同字符串，减少重复计算。
   - **思维角度**：将问题转化为相同循环节的倍数冲突问题，简化逻辑。

---

### **最优思路或技巧提炼**
- **循环节预处理**：所有题解均通过KMP算法提取最小循环节，这是问题转化的关键。
- **哈希表维护倍数集合**：记录每个循环节已使用的倍数，查询时从记录位置递增，避免重复扫描。
- **动态更新因数倍数**：插入新倍数时，枚举其因数并更新对应的最小可用倍数，均摊时间复杂度低。

---

### **同类型题或类似算法套路**
- **常见数论模型**：字符串周期性、因数倍数维护、哈希表优化查询。
- **通用思路**：  
  - 预处理循环节或周期性结构。  
  - 维护已使用状态，动态查找最小可用值。

---

### **推荐相似题目**
1. **P1368 最小周期问题**（KMP求最小循环节）
2. **P4391 [BOI2009]Radio Transmission**（KMP循环节应用）
3. **P3435 [POI2006]OKR-Periods of Words**（扩展KMP求最长周期）

---

### **可视化与算法演示**
**动画方案**：
1. **循环节提取**：高亮KMP前缀数组计算过程，展示如何推导最小循环节。
2. **倍数查询**：动态显示哈希表中当前循环节的已用倍数，逐步递增`k_i`直到找到可用位置。
3. **因数更新**：插入新倍数时，分解因数并更新对应循环节的最小可用值，用颜色标记更新的因数。

**复古像素风格**：
- **Canvas绘制**：每个循环节用不同颜色方块表示，已用倍数标记为红色，当前操作块闪烁。
- **音效**：成功找到倍数时播放8-bit音效，插入新倍数时触发短促音效。

---

### **代码实现核心片段（hzlqwq题解）**
```cpp
// KMP预处理循环节
void kmp(int x) {
    // ...计算前缀数组ne
    len[x] = (s[x].size() % (s[x].size() - ne.back()) == 0) 
             ? (s[x].size() - ne.back()) : s[x].size();
    cir[x] = s[x].substr(0, len[x]);
}

// 动态查询最小k_i
for (int i = 1; i <= n; i++) {
    int tmp = id[cir[i]]; // 循环节对应的哈希表索引
    // 递增查询直到找到未使用的倍数
    while (mex[tmp].count(++jmp[tmp][sk[i]] * sk[i])) {}
    mex[tmp].insert(jmp[tmp][sk[i]] * sk[i]);
}
```

**核心思想**：预处理循环节后，每个字符串只需在对应的哈希表中查找最小未使用倍数，时间复杂度O(1)均摊。

---
处理用时：69.63秒
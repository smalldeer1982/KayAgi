# 题目信息

# [ABC353F] Tile Distance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc353/tasks/abc353_f

座標平面上にタイルが敷き詰められています。 $ 1\times1 $ の大きさの小タイルと $ K\times\ K $ の大きさの大タイルの $ 2 $ 種類があり、次の規則に従って敷き詰められています。

- 整数の組 $ (i,j) $ に対し、正方形 $ \lbrace(x,y)\mid\ i\leq\ x\leq\ i+1\wedge\ j\leq\ y\leq\ j+1\rbrace $ は $ 1 $ つの小タイルもしくは $ 1 $ つの大タイルに含まれる。
  - $ \left\lfloor\dfrac\ iK\right\rfloor+\left\lfloor\dfrac\ jK\right\rfloor $ が偶数のとき、小タイルに含まれる。
  - そうでないとき、大タイルに含まれる。
 
ただし、タイルは境界を含むものとし、共通部分が正の面積をもつような $ 2 $ つの異なるタイルは存在しないとします。

例えば、$ K=3 $ のとき、タイルは以下のようになります。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc353_f/4828cef3de44d96612c498eeceffc46bc8c608c7.png)

 高橋君は、はじめ座標平面上の点 $ (S\ _\ x+0.5,S\ _\ y+0.5) $ にいます。

高橋君は、次の移動を好きなだけ繰り返します。

- 上下左右の方向と正の整数 $ n $ を選ぶ。その方向に $ n $ だけ進む。
 
高橋君が異なるタイルを通るたび、高橋君は通行料を $ 1 $ だけ支払います。

高橋君が点 $ (T\ _\ x+0.5,T\ _\ y+0.5) $ にたどり着くために支払わなければならない通行料の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ K\leq10\ ^\ {16} $
- $ 0\leq\ S\ _\ x\leq2\times10\ ^\ {16} $
- $ 0\leq\ S\ _\ y\leq2\times10\ ^\ {16} $
- $ 0\leq\ T\ _\ x\leq2\times10\ ^\ {16} $
- $ 0\leq\ T\ _\ y\leq2\times10\ ^\ {16} $
- 入力はすべて整数
 
### Sample Explanation 1

例えば、以下のように移動することで支払う通行料を $ 5 $ にすることができます。 !\[\](https://img.atcoder.jp/abc353/35d47ae5cfbcc870ac4d285a8e024278.png) - 上に $ 3 $ 進む。通行料を $ 1 $ 支払う。 - 左に $ 2 $ 進む。通行料を $ 1 $ 支払う。 - 上に $ 1 $ 進む。通行料を $ 1 $ 支払う。 - 左に $ 4 $ 進む。通行料を $ 2 $ 支払う。 支払う通行料を $ 4 $ 以下にすることはできないので、`5` を出力してください。

### Sample Explanation 2

!\[\](https://img.atcoder.jp/abc353/a454c75aab412b8ada226a5e7741e5e1.png) 高橋君が最短距離で移動するとき、どのように移動しても通行料を $ 42 $ だけ支払います。 支払う通行料を $ 41 $ 以下にすることはできないので、`42` を出力してください。

### Sample Explanation 3

通行料を支払わなくてよい場合もあります。

## 样例 #1

### 输入

```
3

7 2

1 6```

### 输出

```
5```

## 样例 #2

### 输入

```
1

41 42

13 56```

### 输出

```
42```

## 样例 #3

### 输入

```
100

100 99

199 1```

### 输出

```
0```

## 样例 #4

### 输入

```
96929423

5105216413055191 10822465733465225

1543712011036057 14412421458305526```

### 输出

```
79154049```

# AI分析结果



## 唯一算法分类
几何

## 综合分析与结论

### 核心思路
本题核心在于将复杂的铺砖结构转化为网格坐标系下的路径优化问题。关键在于理解：
1. 大砖块区域分布呈现棋盘式规律
2. 在大砖块内部移动无需支付费用
3. 相邻大砖块间移动存在最优路径模式

### 数学推导关键点
设大砖块坐标为(A,B)，小砖块坐标为(a,b)，则最优路径费用可分解为：
``` 
总费用 = 起点到大砖边界的费用 + 大砖间移动费用 + 终点到大砖边界的费用
```

大砖间移动费用公式（当 K≥3 时）：
```
费用 = 2 * max(Δx, Δy) 
```
其中 Δx 和 Δy 是大砖坐标差值的绝对值。该公式基于斜向移动策略，每个对角线移动可覆盖两个坐标方向的进度。

当 K=2 时需特殊处理：
```
费用 = 3*min(Δx, Δy) + 2*abs(Δx-Δy)
```
此时直接穿过小砖块区域更优。

### 可视化设计
采用棋盘式动画演示：
1. 红蓝交替显示大砖块区域
2. 黄色路径展示斜向移动策略
3. 绿色标记起点/终点，橙色标记边界穿越点
4. 实时显示费用计数器
5. 支持切换 K 值观察路径变化

![示例动画](https://example.com/path-animation.gif)

## 题解评分 (≥4星)

1. **Register_int (5星)**
   - 核心公式 `calc()` 函数精炼优雅
   - 采用四方向枚举策略避免复杂分情况
   - 代码结构清晰，逻辑分层明确

2. **g1ove (4星)** 
   - 独创性的坐标转换思路
   - 预处理函数 `da()` 设计巧妙
   - 包含详细的注释说明

3. **yemuzhe (4星)**
   - 采用旋转坐标系简化问题
   - 特殊处理 K=2 的公式推导完整
   - 包含调试经验分享

## 核心代码实现
```cpp
// 大砖间费用计算核心逻辑
ll calc(ll ax, ll ay, ll bx, ll by) {
    ll p = abs(ax - bx), q = abs(ay - by);
    if (p > q) swap(p, q);
    return p * 2 + (q - p) / 2 * min(k + 1, 4ll);
}

// 枚举四个相邻大砖方向
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

// 计算边界穿越费用
ll boundary_cost(int dir, int coord) {
    return (dir < 2) ? (k - coord % k) : (coord % k + 1);
}
```

## 同类型题目推荐
1. **P2730 [IOI2008] Pyramid Base** - 棋盘式路径规划
2. **P4643 [国家集训队]阿狸和桃子的游戏** - 网格移动费用优化
3. **CF1494E A-Z Graph** - 斜向移动策略优化

## 复古游戏化演示设计
```javascript
// 像素化演示核心逻辑
class TileVisualizer {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.palette = ['#2C3E50', '#E74C3C', '#2ECC71', '#F1C40F'];
    }

    drawGrid(K, path) {
        // 绘制棋盘式大砖块
        for(let i=0; i<10; i++) {
            for(let j=0; j<10; j++) {
                const color = ((i/K|0) + (j/K|0)) % 2 ? this.palette[0] : this.palette[1];
                this.ctx.fillStyle = color;
                this.ctx.fillRect(i*16, j*16, 16, 16);
            }
        }
        
        // 绘制路径动画
        path.forEach(([x,y], idx) => {
            this.ctx.fillStyle = this.palette[3];
            setTimeout(() => {
                this.ctx.fillRect(x*16, y*16, 4, 4);
                playSound('move');
            }, idx*200);
        });
    }
}
```

## 个人心得摘录
> "赛时意识到硬分讨会陷入死循环，转而寻找坐标变换规律，发现旋转45度后的坐标系能极大简化问题。调试时发现K=2的特殊情况需要完全不同的计算模式，最终通过绘制多组测试用例才找到正确公式。"

## 知识拓展
类似棋盘问题的通用解法：
1. **切比雪夫距离转换**：将曼哈顿距离问题转换为更易处理的坐标系
2. **分层处理策略**：将复杂结构分解为多层网格处理
3. **边界枚举法**：通过有限方向枚举替代无限路径搜索

---
处理用时：70.19秒
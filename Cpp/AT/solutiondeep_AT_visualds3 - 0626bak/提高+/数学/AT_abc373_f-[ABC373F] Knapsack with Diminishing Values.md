# 题目信息

# [ABC373F] Knapsack with Diminishing Values

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc373/tasks/abc373_f

$ N $ 種類の品物があり、 $ i $ 種類目の品物の重みは $ w_i $、価値は $ v_i $ です。どの種類の品物も $ 10^{10} $ 個ずつあります。

高橋君はこれから、品物をいくつか選んで、容量 $ W $ のバッグに入れます。高橋君は、選ぶ品物の価値を大きくしつつ、同じ種類の品物ばかりにならないようにしたいです。そこで高橋君は、$ i $ 種類目の品物を $ k_i $ 個選んだときの **うれしさ** を $ k_i\ v_i\ -\ k_i^2 $ と定義したとき、選んだ品物の重さの総和を $ W $ 以下にしつつ、各種類のうれしさの総和が最大になるように品物を選びます。高橋君が達成できる、うれしさの総和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3000 $
- $ 1\ \leq\ W\ \leq\ 3000 $
- $ 1\ \leq\ w_i\ \leq\ W $
- $ 1\ \leq\ v_i\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1 $ 種類目の品物を $ 2 $ 個、$ 2 $ 種類目の品物を $ 1 $ 個選ぶと、うれしさの総和を $ 5 $ にすることができ、これが最適です。 $ 1 $ 種類目の品物についてのうれしさは $ 2\ \times\ 4\ -\ 2^2\ =\ 4 $、$ 2 $ 種類目の品物についてのうれしさは $ 1\ \times\ 2\ -\ 1^2\ =\ 1 $ です。 また、重さの総和は $ 9 $ であり、容量 $ 10 $ のバッグに入ります。

## 样例 #1

### 输入

```
2 10

3 4

3 2```

### 输出

```
5```

## 样例 #2

### 输入

```
3 6

1 4

2 3

2 7```

### 输出

```
14```

## 样例 #3

### 输入

```
1 10

1 7```

### 输出

```
12```

# AI分析结果



## **唯一算法分类**
组合数学

---

## **综合分析与结论**

### **题目核心思路**
本题为背包问题变种，核心难点在于物品收益函数为二次函数（k*v_i -k²），无法直接套用传统背包模型。各题解核心思路为：
1. **预处理**每个重量w对应的最优k次选择的收益（利用贪心/优先队列维护增量）。
2. **分组背包DP**，将相同重量物品合并，按预处理后的收益进行状态转移。

### **关键公式与推导**
每个物品的收益函数为二次函数：  
$$
f(k) = k \cdot v_i - k^2  
$$
其增量收益（选第k个时的额外收益）为：  
$$
\Delta f(k) = f(k) - f(k-1) = v_i - (2k - 1)
$$
通过维护优先队列，每次选择当前增量最大的物品，可贪心求出每个重量w选k次的最优总收益。

### **解决难点**
1. **非线性收益处理**：通过拆解收益为增量序列，利用贪心选择最优增量。
2. **时间复杂度优化**：预处理每个重量w的收益后，背包DP复杂度降为调和级数（O(W log W)）。

### **可视化设计**
- **预处理阶段**：以像素风格显示不同重量w对应的物品队列，每次弹出最大增量元素并更新收益数组，伴随8-bit音效。
- **背包DP阶段**：动态绘制DP数组的更新过程，高亮当前处理的重量w和容量j，用不同颜色区分新旧状态。
- **复古效果**：采用16色像素风格，背包容量以网格展示，步进控制支持暂停/单步，音效触发关键操作。

---

## **题解清单 (≥4星)**

### 1. **作者：wangshulin（4.5星）**
- **亮点**：  
  - 预处理每个重量w的最优k次收益，利用贪心维护优先队列。  
  - 分组背包DP实现简洁，时间复杂度O(W² log W)。  
- **代码片段**：  
  ```cpp
  // 预处理每个重量w的最优k次收益
  for (int i = 1; i <= W; i++) {
      priority_queue<int> q;
      for (auto val : vec[i]) q.push(val - 1);
      for (int j = 1; j * i <= W; j++) {
          f[j] = f[j-1] + q.top();
          q.push(q.top() - 2); q.pop();
      }
      // 分组背包DP
      for (int j = W; j >= 0; j--) 
          for (int k = 1; k*i <= j; k++)
              dp[j] = max(dp[j], dp[j - k*i] + f[k]);
  }
  ```

### 2. **作者：DengDuck（4星）**
- **亮点**：  
  - 将物品按重量分组，预处理后直接分组背包。  
  - 优先队列维护增量收益，代码可读性强。  
- **个人心得**：  
  > “对每个重量w，优先队列动态维护当前最优选择，避免暴力枚举。”

### 3. **作者：g1ove（4星）**
- **亮点**：  
  - 使用斜率优化将DP复杂度降至O(nW)。  
  - 分模数处理转移，数学推导严谨。  
- **代码片段**：  
  ```cpp
  // 斜率优化转移
  for (d in 0..w-1) {
      for i in 0..m/w {
          while 队尾不满足凸性: 弹出;
          插入当前点;
          while 队首不满足斜率条件: 弹出;
          更新dp[j + i*w] = -i² + 队首点值;
      }
  }
  ```

---

## **最优思路提炼**
1. **贪心预处理**：对每个重量w，计算选k次的最优收益序列。  
2. **增量维护**：用优先队列动态选择当前最大增量，避免暴力计算。  
3. **分组背包DP**：按重量分组后，利用调和级数优化总复杂度。

---

## **类似题目推荐**
1. **洛谷 P1776**：多重背包+二进制优化（增量拆分思想）。  
2. **洛谷 P1759**：分组背包问题（按组处理）。  
3. **洛谷 P4544**：带限制的背包问题（决策单调性优化）。

---

## **复古游戏化动画设计**
- **像素风格**：背包容量以16x16网格显示，物品为不同颜色方块。  
- **音效触发**：  
  - 弹出优先队列元素：短促“滴”声。  
  - 更新DP数组：低频“嘟”声。  
- **自动演示**：AI自动选择最优增量，逐步填充DP数组，伴随背景8-bit音乐。  
- **交互控制**：支持暂停/单步/调整速度，高亮当前处理的重量和容量。

---

**代码实现参考**（核心贪心预处理）：  
```javascript
// 伪代码：优先队列预处理
function preprocess(w, items) {
  const pq = new MaxHeap();
  items.forEach(v => pq.insert(v - 1));
  const maxK = Math.floor(W / w);
  const f = new Array(maxK + 1).fill(0);
  for (let k = 1; k <= maxK; k++) {
    f[k] = f[k-1] + pq.top();
    pq.insert(pq.pop() - 2); // 更新增量
  }
  return f;
}
```

---
处理用时：65.32秒
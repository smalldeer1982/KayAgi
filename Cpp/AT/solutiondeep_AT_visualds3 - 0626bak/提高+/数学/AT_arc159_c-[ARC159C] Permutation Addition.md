# 题目信息

# [ARC159C] Permutation Addition

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc159/tasks/arc159_c

正整数列 $ A=(a_1,\ldots,a_N) $ が与えられます。

次の操作を $ 0 $ 回以上 $ 10^4 $ 回以下繰り返すことで $ A $ の値をすべて等しくできるかを判定し、可能な場合は操作列の一例を示してください。

- $ (1,\ldots,N) $ の順列 $ (p_1,\ldots,p_N) $ を決め、$ A $ を $ (a_1+p_1,\ldots,a_N+p_N) $ に置き換える。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 50 $
- $ 1\ \leq\ a_i\ \leq\ 50 $
- 入力はすべて整数
 
### Sample Explanation 1

この出力例の通りに $ 8 $ 回の操作を行うことで $ A $ は $ (24,24) $ となり、値がすべて等しくなります。

### Sample Explanation 3

初めから $ A $ の値がすべて等しいです。

## 样例 #1

### 输入

```
2

15 9```

### 输出

```
Yes

8

1 2

1 2

1 2

1 2

2 1

1 2

1 2

1 2```

## 样例 #2

### 输入

```
5

1 2 3 10 10```

### 输出

```
No```

## 样例 #3

### 输入

```
4

1 1 1 1```

### 输出

```
Yes

0```

# AI分析结果



**唯一算法分类**: 数论

---

### **题解思路与算法要点**

1. **必要条件分析**  
   - **总和条件**：每次操作总和增加 `n(n+1)/2`。  
     - **奇数n**：总和必须为n的倍数（因每次增量模n为0）。  
     - **偶数n**：总和模n需为0或`n/2`（后者可通过一次操作转为0）。  

2. **构造操作的核心思路**  
   - **调整差值**：通过两次排列操作，使得较大的元素减少1，较小的增加1。  
     - **排列设计**：两次排列的对应位置和为`n+1`，但针对特定元素调整其增量。  
     - **示例**：元素`a_i`在两次操作中分别获得增量`1`和`n`，`a_j`获得`2`和`n-1`，总差缩小2。  

3. **关键数学推导**  
   - **增量总和公式**：若两次排列分别为`p`和`q`，则总增量`Δ_i = p_i + q_i`。  
   - **构造`p`和`q`使得除目标元素外，`Δ_i = n+1`，而目标元素`Δ_i = n+1 ±1`。  

---

### **最优思路提炼**

1. **总和调整**：偶数n下若总和模n为`n/2`，先加一个任意排列使其模n为0。  
2. **差值平衡**：每次操作选择一对元素，通过两次排列使其差值缩小。  
3. **排列构造**：  
   ```cpp
   // 构造两次排列的示例代码（调整元素u和v的差）
   vector<int> p1(n), p2(n);
   int l = 3, r = n-2;
   for (int j=1; j<=n; ++j) {
       if (j == u) p1[j-1] = 1, p2[j-1] = n-1;
       else if (j == v) p1[j-1] = 2, p2[j-1] = n;
       else p1[j-1] = l++, p2[j-1] = r--;
   }
   ```

---

### **题解评分（≥4星）**

1. **Mashiroqwq（★★★★★）**  
   - 思路清晰，分奇偶讨论总和条件，代码简洁高效。  
   - 构造排列逻辑明确，直接操作差值平衡。  

2. **roBotic（★★★★☆）**  
   - 详细推导数学条件，强调差值调整的可行性。  
   - 代码实现稍复杂，但核心逻辑完整。  

3. **Purslane（★★★★☆）**  
   - 提供关键条件的直观解释，代码实现高效。  
   - 通过两次排列构造平衡，操作次数可控。  

---

### **同类型题目推荐**

1. **AT_arc145_b**（通过操作调整数组元素）  
2. **CF1375E**（排列操作与差值调整）  
3. **洛谷P1965**（模运算与数学构造）  

---

### **可视化与算法演示**

**8位像素动画设计**：  
- **Canvas绘制**：数组元素以像素方块表示，颜色深浅表示数值大小。  
- **操作步骤**：  
  1. **高亮调整元素**：红色（需增加）和蓝色（需减少）。  
  2. **排列叠加动画**：两次排列增量以箭头飞入效果展示。  
  3. **差值变化**：调整后元素颜色渐变，显示新数值。  
- **音效**：  
  - 成功调整：8位“升级”音效。  
  - 完成平衡：胜利旋律。  

**交互控制**：  
- **步进/暂停**：观察每次操作后的数值变化。  
- **自动模式**：AI自动选择差值最大的元素对进行操作。  

---

**核心代码片段（C++）**  
```cpp
// 调整元素u和v的差
void adjustPair(int u, int v, vector<vector<int>>& ans) {
    vector<int> p1(n), p2(n);
    int l = 3, r = n-2;
    for (int j=0; j<n; ++j) {
        if (j == u) p1[j] = 1, p2[j] = n-1;
        else if (j == v) p1[j] = 2, p2[j] = n;
        else p1[j] = l++, p2[j] = r--;
    }
    ans.push_back(p1);
    ans.push_back(p2);
}
```

---

**总结**：通过数论条件判断和构造性排列操作，确保在有限次数内平衡数组。关键点在于总和条件验证和差值调整的排列设计。

---
处理用时：69.31秒
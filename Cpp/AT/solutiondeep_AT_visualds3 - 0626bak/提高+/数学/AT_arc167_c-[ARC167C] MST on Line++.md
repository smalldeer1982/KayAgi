# 题目信息

# [ARC167C] MST on Line++

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc167/tasks/arc167_c

正整数 $ N,K $ と長さ $ N $ の正整数列 $ A=(A_{1},A_{2},\dots,A_{N}) $ が与えられます。

$ (1,2,\dots\ ,N) $ の順列 $ P=(P_{1},P_{2},\dots\ ,P_{N}) $ に対して以下の「問題 MST on Line」について考え、その答えを $ f(P) $ と書きます。

> **問題 MST on Line**
> 
> 頂点に $ 1 $ から $ N $ までの番号がついた頂点数 $ N $ の重み付き無向グラフ $ G $ があります。$ G $ について $ 1\leq\ i\lt\ j\leq\ N $ を満たす任意の整数の組 $ (i,j) $ に対して以下が成り立ちます。
> 
> - $ j-i\leq\ K $ ならば頂点 $ i $ と頂点 $ j $ の間に辺が存在して、その辺の重みは **$ \max(A_{P_{i}},A_{P_{j}}) $**
> - $ j-i\gt\ K $ ならば頂点 $ i $ と頂点 $ j $ の間に辺は存在しない
>  
> $ G $ の最小全域木の辺の重みの和を求めてください。

全ての $ (1,2,\dots\ ,N) $ の順列 $ P=(P_{1},P_{2},\dots\ ,P_{N}) $ に対する $ f(P) $ の総和を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\leq\ K\lt\ N\leq\ 5000 $
- $ 1\leq\ A_{i}\leq\ 10^{9} $
- 入力は全て整数
 
### Sample Explanation 1

$ P=(1,2,3,4,5) $ としたとき、 頂点 $ 1 $ と $ 2 $ の間に存在する、重み $ 4 $ の辺、 頂点 $ 2 $ と $ 3 $ の間に存在する、重み $ 5 $ の辺、 頂点 $ 2 $ と $ 4 $ の間に存在する、重み $ 4 $ の辺、 頂点 $ 4 $ と $ 5 $ の間に存在する、重み $ 2 $ の辺、 という $ 4 $ つの辺は $ G $ の全域木となり、辺の重みの和は $ 15 $ です。 これ以上辺の重みの和を少なくするように全域木をとることはできないので、$ f(P)=15 $ となります。 以上のように全ての $ (1,2,3,4,5) $ の順列 $ P $ に対する $ f(P) $ の総和を求めると $ 1740 $ になるので、これを出力します。

## 样例 #1

### 输入

```
5 2

3 4 5 2 1```

### 输出

```
1740```

## 样例 #2

### 输入

```
2 1

167 924```

### 输出

```
1848```

## 样例 #3

### 输入

```
12 9

22847 98332 854 68844 81080 46058 40949 62493 76561 52907 88628 99740```

### 输出

```
660459584```

# AI分析结果



**唯一算法分类**：组合数学

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   将问题转化为每个元素 $A_i$ 在所有排列中作为 MST 边权出现的次数总和。通过组合数学计算每个 $A_i$ 的贡献。

2. **关键步骤与数学推导**  
   - **排序 $A$ 数组**：边权仅与相对大小相关，排序后简化问题。
   - **定义贡献函数 $f_i$**：表示所有排列中，边权 $\le A_i$ 的边在 MST 中的总边数。
   - **差分计算贡献**：$A_i$ 的贡献为 $f_i - f_{i-1}$，对应新增的边权为 $A_i$ 的边数。
   - **计算 $f_i$**：  
     对 $A_i$ 对应的序列 $Q$（所有 $\le A_i$ 的元素位置），统计相邻位置间距 $\le K$ 的组合数：
     \[
     f_i = i! \cdot (n-i)! \cdot (i-1) \sum_{j=1}^K \binom{n-j}{i-1}
     \]
     - **组合数求和**：$\sum_{j=1}^K \binom{n-j}{i-1}$ 统计所有可能的相邻间距。
     - **排列数**：$i! \cdot (n-i)!$ 为 $Q$ 和非 $Q$ 元素的排列方式。

3. **解决难点**  
   - **组合数预处理**：快速计算 $\binom{n-j}{i-1}$，使用阶乘与逆元预处理。
   - **差分优化**：通过 $f_i - f_{i-1}$ 避免重复计算，降低复杂度至 $O(nK)$。

---

### **题解评分（≥4星）**

1. **樱雪喵的题解（5星）**  
   - **亮点**：公式清晰，推导详细，代码简洁高效，直接实现关键公式。
   - **核心代码**：
     ```cpp
     for (int i=1; i<=n; i++)
         for (int j=1; j<=K; j++)
             f[i] = (f[i] + jc[i] * jc[n-i] % mod * (i-1) % mod * C(n-j, i-1)) % mod;
     ```

2. **elbissoPtImaerD的题解（4星）**  
   - **亮点**：通过贪心策略简化问题，结合组合数学与排列数，代码可读性强。
   - **核心公式**：
     \[
     f_m = (m-1)m!(n-m)! \sum_{d=1}^K \binom{n-d}{m-1}
     \]

3. **zhongpeilin的题解（4星）**  
   - **亮点**：详细注释与代码结合，逐步拆解贡献计算，适合初学者理解。

---

### **最优思路或技巧提炼**

1. **差分计数**：通过 $f_i - f_{i-1}$ 计算新增边权贡献，避免重复枚举。
2. **组合数预处理**：预计算阶乘与逆元，快速求解组合数。
3. **贪心策略**：相邻间距 $\le K$ 的边优先连接，转化为组合数求和问题。

---

### **同类型题或类似算法套路**

- **组合数学模型**：处理排列贡献时，常通过预处理阶乘与组合数优化计算。
- **差分优化**：在统计区间贡献时，差分数组可简化复杂度。
- **贪心+组合**：在 MST 问题中，利用贪心策略将边权排序后统计贡献。

---

### **推荐相似题目**

1. **洛谷 P1962**（组合数学与矩阵快速幂）
2. **洛谷 P3773**（排列组合与容斥原理）
3. **洛谷 P6620**（生成树计数与多项式优化）

---

### **可视化与算法演示**

1. **动画设计**  
   - **像素风格界面**：用 8-bit 像素块表示节点，边权用颜色区分。
   - **步进演示**：逐步显示 $Q$ 序列的生成、相邻间距统计、组合数计算。
   - **音效提示**：计算完成时播放音效，错误操作触发警示音。

2. **关键步骤高亮**  
   - **相邻间距计算**：用红色框标出当前统计的间距 $j$。
   - **组合数求和**：动态显示 $\sum_{j=1}^K \binom{n-j}{i-1}$ 的累加过程。

3. **自动推导模式**  
   - **AI 模拟**：自动遍历 $i$ 和 $j$，展示公式中每个项的生成过程。

---

### **代码实现（关键部分）**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5005, mod = 998244353;
int n, K, a[N], fac[N], inv[N], f[N];

int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % mod;
        a = 1ll * a * a % mod;
        b >>= 1;
    }
    return res;
}

void init() {
    fac[0] = 1;
    for (int i = 1; i < N; i++) fac[i] = 1ll * fac[i-1] * i % mod;
    inv[N-1] = qpow(fac[N-1], mod-2);
    for (int i = N-2; i >= 0; i--) inv[i] = 1ll * inv[i+1] * (i+1) % mod;
}

int C(int n, int m) {
    if (n < m || m < 0) return 0;
    return 1ll * fac[n] * inv[m] % mod * inv[n-m] % mod;
}

int main() {
    init();
    cin >> n >> K;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1);
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= K; j++)
            f[i] = (f[i] + C(n - j, i - 1)) % mod;
        f[i] = 1ll * f[i] * fac[i] % mod * fac[n - i] % mod * (i - 1) % mod;
    }
    
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans = (ans + 1ll * a[i] * (f[i] - f[i-1] + mod) % mod) % mod;
    
    cout << ans << endl;
    return 0;
}
```

**代码核心**：预处理组合数，计算 $f_i$ 并差分求和，时间复杂度 $O(nK)$。

---
处理用时：96.23秒
# 题目信息

# Not Too Close

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_c

$ N $ 頂点の無向グラフであって、以下の条件をすべて満たすものの個数を $ 10^9\ +\ 7 $ で割った余りを求めてください。

- $ N $ 個の頂点には $ 1 $ から $ N $ までの番号が振られている。
- グラフは自己辺や多重辺を持たない（連結である必要はない）。
- すべての辺の長さを $ 1 $ とすると、頂点 $ 1,\ 2 $ 間の最短距離は $ D $ である。

## 说明/提示

### 注記

二つのグラフ $ G_1,\ G_2 $ は、以下が満たされる場合に異なるとみなされ、満たされない場合に同一とみなされます。

- ある整数の組 $ (i,\ j) $ $ (1\ <\ =\ i\ <\ j\ <\ =\ N) $ が存在し、頂点 $ i,\ j $ を直接結ぶ辺が $ G_1,\ G_2 $ のうち一方のみに存在する。

### 制約

- $ 1\ <\ =\ D\ <\ N\ <\ =\ 30 $
- $ N,\ D $ は整数である。

### Sample Explanation 1

条件を満たすグラフは下図の $ 2 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/4b0c83895d12c1a9c90cb3e8060db969.png)

### Sample Explanation 2

条件を満たすグラフは下図の $ 14 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/df4dffb7f2140b22a6c7ccc86f6c9cf9.png)

### Sample Explanation 3

mod $ (10^9\ +\ 7) $ にご注意ください。

## 样例 #1

### 输入

```
4 3```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2```

### 输出

```
14```

## 样例 #3

### 输入

```
30 15```

### 输出

```
313862829```

# AI分析结果



**唯一算法分类**  
组合数学

---

**综合分析与结论**  

该题核心在于利用分层动态规划统计满足条件的无向图数目。通过将顶点按到顶点1的最短距离分层，确保顶点2位于第D层。关键点包括：

1. **动态规划状态设计**  
   定义 `dp[i][j][k]` 表示构建到第i层，共使用j个顶点，且第i层有k个顶点时的方案数。状态转移时需计算：
   - **组合数**：下一层选点的方案数（特别处理顶点2在第D层的情况）
   - **层间边**：下一层每个点必须至少连接当前层一个点，方案为 `(2^k -1)^l`
   - **层内边**：下一层内部任意连边，方案为 `2^(l*(l-1)/2)`

2. **顶点2的特殊处理**  
   在第D层选点时需强制包含顶点2，此时组合数为 `C(n-j-1, l-1)`；其他层则正常选择。

3. **剩余顶点处理**  
   未分配的顶点可自由连接，内部连边方案为 `2^(C(m,2))`，与第D层连边方案为 `2^(k*m)`，其中 `m = n-j`。

**可视化设计**  
- **分层动画**：用不同颜色块表示各层，顶点1和2高亮显示，动态展示层间连边和层内连边的生成过程。
- **组合数计算**：高亮剩余顶点集合，模拟选点过程，特别标红顶点2在第D层的强制选择。
- **公式推导**：分步显示 `(2^k-1)^l` 和 `2^(l*(l-1)/2)` 的计算逻辑，用颜色区分各部分贡献。

---

**题解清单 (≥4星)**  

1. **Zhao_daodao 题解（4.5星）**  
   - **亮点**：状态转移清晰，预处理组合数和幂次数组优化效率，代码简洁易读。
   - **代码片段**：  
     ```cpp
     (now += old * C(n-j-1, l-(i==d-1)) % mod * fc[C(l,2)] % mod * ksm(fc[k]+mod-1, l) % mod) %= mod;
     ```

2. **Hadtsti 题解（4.2星）**  
   - **亮点**：详细注释组合数预处理和转移逻辑，强调顶点2的强制选择条件。
   - **代码片段**：  
     ```cpp
     C[n-j-1][w - (i+1 ==d)] // 顶点2的特殊处理
     ```

3. **VainSylphid 题解（4.0星）**  
   - **亮点**：明确分层策略，强调剩余顶点的自由连边不影响条件，代码结构清晰。
   - **代码片段**：  
     ```cpp
     ans += dp[d][i][k] * pow2[k*(n-i) + C(n-i,2)]
     ```

---

**最优思路/技巧提炼**  

1. **分层动态规划**：按到顶点1的最短距离分层，逐层构建图结构。
2. **组合数优化**：预处理组合数和幂次数组，避免重复计算。
3. **顶点2强制选择**：在第D层选点时通过组合数调整确保顶点2必选。
4. **剩余顶点自由连边**：独立计算未分配顶点的边方案，不影响原条件。

---

**同类题型与通用解法**  

- **分层图计数**：如 [CF1763E](https://codeforces.com/problemset/problem/1763/E)（按子树分层统计）
- **组合动态规划**：如 [ABC262E](https://atcoder.jp/contests/abc262/tasks/abc262_e)（限制条件下的边选择）
- **最短路径约束**：如 [洛谷P1144](https://www.luogu.com.cn/problem/P1144)（最短路计数）

---

**推荐题目**  
1. [ABC262E - Red and Blue Graph](https://atcoder.jp/contests/abc262/tasks/abc262_e)  
2. [洛谷P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  
3. [CF1763E - Node Pairs](https://codeforces.com/problemset/problem/1763/E)  

---

**个人心得摘录**  
- **调试关键**：验证组合数是否正确处理顶点2的强制选择，通过小样例（如N=4, D=3）逐步跟踪状态转移。
- **优化经验**：预处理所有可能的2的幂次和组合数，减少运行时计算量。

---

**代码核心实现**  
```cpp
// 预处理组合数C和pow2数组
for (int i = 0; i <= n; i++) {
    C[i][0] = C[i][i] = 1;
    for (int j = 1; j < i; j++)
        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;
}
pow2[0] = 1;
for (int i = 1; i <= n*n; i++)
    pow2[i] = pow2[i-1] * 2 % mod;

// 动态规划转移
dp[0][1][1] = 1;
for (int i = 0; i < d; i++) {
    for (int j = 1; j <= n; j++) {
        for (int k = 1; k <= j; k++) {
            if (!dp[i][j][k]) continue;
            for (int l = 1; l <= n-j; l++) {
                int ways = C[n-j-1][l - (i+1 == d)];
                int layer_edges = pow2[l*(l-1)/2];
                int cross_edges = pow(pow2[k] - 1, l);
                dp[i+1][j+l][l] = (dp[i+1][j+l][l] + dp[i][j][k] * ways % mod * layer_edges % mod * cross_edges % mod) % mod;
            }
        }
    }
}

// 统计答案
int ans = 0;
for (int j = d; j <= n; j++) {
    for (int k = 1; k <= j; k++) {
        int remain = n - j;
        int free_edges = pow2[k * remain + remain*(remain-1)/2];
        ans = (ans + dp[d][j][k] * free_edges % mod) % mod;
    }
}
```

---

**可视化与游戏化设计**  
- **复古像素风格**：用16色调色板绘制各层顶点，顶点1为红色，顶点2为绿色，层间边闪烁黄色。
- **动画演示**：逐步展开每层构建过程，显示组合数选点、层内连边和跨层连边的生成。
- **音效设计**：每完成一层转移播放8位音效，答案计算成功时播放胜利音效。
- **交互控制**：支持暂停/继续，单步观察状态转移，调节动画速度。

---
处理用时：183.75秒
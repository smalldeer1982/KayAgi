# 题目信息

# [ABC020D] LCM Rush

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc020/tasks/abc020_d

$ 2 $ つの正整数 $ a, $ $ b $ の最小公倍数 $ LCM(a,\ b) $ とは、 $ a $ の倍数であり、かつ $ b $ の倍数でもあるような正整数のうち最小のものをいいます。

$ 2 $ つの正整数 $ N, $ $ K $ が与えられます。 $ 1 $ 以上 $ N $ 以下のすべての整数 $ i $ について $ LCM(i,\ K) $ を足しあわせたものを $ 1,000,000,007 $ で割った余りを求めてください。

## 说明/提示

### 部分点

この問題は AtCoder Beginner Contest の問題としては非常に難しいため、通常 ($ 100 $ 点満点) と異なり $ 101 $ 点満点であり、部分点が設定されている。

- $ 5 $ 点分のテストケースは $ 1 $ $ ≦ $ $ N, $ $ K $ $ ≦ $ $ 100 $ を満たす。
- 別の $ 10 $ 点分のテストケースは $ 1 $ $ ≦ $ $ N $ $ ≦ $ $ 10^4, $ $ 1 $ $ ≦ $ $ K $ $ ≦ $ $ 100 $ を満たす。
- さらに別の $ 85 $ 点分のテストケースは $ 1 $ $ ≦ $ $ N $ $ ≦ $ $ 10^9, $ $ 1 $ $ ≦ $ $ K $ $ ≦ $ $ 100 $ を満たす。以上で合計 $ 100 $ 点となる。

### Sample Explanation 1

$ LCM(1,\ 2)\ +\ LCM(2,\ 2)\ +\ LCM(3,\ 2)\ +\ LCM(4,\ 2)\ =\ 2\ +\ 2\ +\ 6\ +\ 4\ =\ 14 $ となります。

## 样例 #1

### 输入

```
4 2```

### 输出

```
14```

## 样例 #2

### 输入

```
10000 100```

### 输出

```
865504986```

## 样例 #3

### 输入

```
1000000000 90```

### 输出

```
50001213```

## 样例 #4

### 输入

```
1000000000 999999900```

### 输出

```
231285006```

# AI分析结果



## 唯一算法分类
**数论（因数分解 & 莫比乌斯反演）**

---

## 题解思路与核心难点

### 核心思路
1. **公式转换**：将 `lcm(i,K)` 转换为 `i*K/gcd(i,K)`，提取公因子 K。
2. **枚举因数**：通过枚举 `gcd(i,K)` 的因数 `d`，将问题拆分为多个子问题。
3. **互质求和**：计算在 `n/d` 范围内与 `K/d` 互质的数的和，利用莫比乌斯函数进行容斥。
4. **动态计算 μ**：预处理小范围的莫比乌斯函数，大数通过质因数分解实时计算。

### 解决难点
- **因数分解优化**：快速枚举 `K` 的所有因数，避免暴力枚举。
- **莫比乌斯函数高效计算**：结合预处理和暴力分解质因数，平衡时间与空间。
- **容斥求和**：利用 `μ(d)` 的符号特性实现快速容斥。

---

## 题解评分（≥4星）

### 1. EnofTaiPeople（★★★★☆）
- **亮点**：公式推导详尽，预处理+动态计算结合，代码结构清晰。
- **关键代码**：
  ```cpp
  int f(int n, int m) {
    int res = 0;
    for (int x : G) { // G为K的因数集合
      if (m % x) continue;
      res += μ(x) * x * 等差数列(n/x);
    }
    return res;
  }
  ```

### 2. EastPorridge（★★★★☆）
- **亮点**：数论分块优化，代码简洁，动态计算 μ 函数。
- **关键代码**：
  ```cpp
  int f(int n, int m) {
    for (int d : 因数集合) 
      res += μ(d) * d * 等差数列(n/d);
    return res;
  }
  ```

### 3. D2T1（★★★★☆）
- **亮点**：直接枚举因数，公式推导简洁，适合快速理解。
- **关键代码**：
  ```cpp
  for (int d : 因数集合) 
    ans += μ(d) * d * 等差数列(n/d);
  ```

---

## 最优思路提炼
1. **因数分解**：将 `K` 分解为所有可能的因数 `d`。
2. **互质求和公式**：
   \[
   \sum_{i=1}^{\lfloor n/d \rfloor} i \cdot [\gcd(i, K/d)=1] = \sum_{t \mid (K/d)} μ(t) \cdot t \cdot \text{等差数列}(\lfloor n/(d \cdot t) \rfloor)
   \]
3. **动态计算 μ**：小范围预处理，大数实时分解质因数。

---

## 同类型题推荐
1. **P2158 [SDOI2008] 仪仗队**（因数与互质计数）
2. **P2398 GCD SUM**（gcd 求和与莫比乌斯反演）
3. **P2527 不重复的素数**（质因数分解与容斥）

---

## 可视化算法演示

### 动画设计
- **像素风格界面**：用 8-bit 网格展示 `K` 的因数分解过程，每个因数 `d` 高亮显示。
- **动态容斥**：当选中一个因数 `d` 时，显示其对应的 `μ(d)` 值（绿色正数，红色负数），并动态累加贡献。
- **音效触发**：每次因数分解成功播放短促音效，贡献计算完成时播放成功音效。

### 关键步骤
1. **因数分解阶段**：
   - 网格中逐个显示 `K` 的因数，用不同颜色区分。
   - 显示 `d` 和 `K/d` 的配对关系。
2. **容斥计算阶段**：
   - 对每个因数 `d`，显示其对应的 `μ(d)` 值和贡献。
   - 动态更新总和，用进度条表示当前计算进度。
3. **自动演示模式**：AI 自动选择因数并计算，支持暂停/继续。

---

## 核心代码片段（EnofTaiPeople）
```cpp
vector<int> G; // 存储K的因数
for (int x : G) { // 遍历所有因数
  if (m % x) continue;
  res = (res + (ll)x * mus(x) % M * g(n/x)) % M; // g为等差数列求和
}
ans = (ll)K * ans % M; // 最终乘以K
```

---

## 个人心得摘录
- **调试教训**：未处理 `μ` 的负数可能导致结果错误，需显式取模修正（如 `(res%M + M)%M`）。
- **优化顿悟**：`K` 的因数数量远小于 `1e9`，暴力枚举可行，无需高级数据结构。

---
处理用时：79.34秒
# 题目信息

# [AGC036B] Do Not Duplicate

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc036/tasks/agc036_b

長さ $ N\ \times\ K $ の数列 $ X=(X_0,X_1,\cdots,X_{N\ \times\ K-1}) $ があります。 数列 $ X $ の要素は長さ $ N $ の数列 $ A=(A_0,A_1,\cdots,A_{N-1}) $ によって表され、全ての $ i,j $ ($ 0\ \leq\ i\ \leq\ K-1,\ 0\ \leq\ j\ \leq\ N-1 $) について、 $ X_{i\ \times\ N\ +\ j}=A_j $ です。

すぬけさんは、整数列 $ s $ を持っています。 最初、$ s $ は空です。 すぬけさんはこれから、すべての $ i=0,1,2,\cdots,N\ \times\ K-1 $ について、この順に、以下の操作を行います。

- $ s $ が $ X_i $ を含んでいない場合: $ s $ の末尾に $ X_i $ を追加する。
- $ s $ が $ X_i $ を含んでいる場合: $ s $ が $ X_i $ を含まなくなるまで、$ s $ の末尾の要素を削除し続ける。 このとき、$ X_i $ を末尾に**加えない**ことに注意せよ。

全ての操作が終わったあとの数列 $ s $ の状態を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ 10^{12} $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^5 $
- 入力される値はすべて整数である。

### Sample Explanation 1

$ X=(1,2,3,1,2,3) $ です。 操作は、以下のように行われます。 - $ i=0 $: $ s $ が $ 1 $ を含まないので、$ s $ の末尾に $ 1 $ を追加する。$ s=(1) $ となる。 - $ i=1 $: $ s $ が $ 2 $ を含まないので、$ s $ の末尾に $ 2 $ を追加する。$ s=(1,2) $ となる。 - $ i=2 $: $ s $ が $ 3 $ を含まないので、$ s $ の末尾に $ 3 $ を追加する。$ s=(1,2,3) $ となる。 - $ i=3 $: $ s $ が $ 1 $ を含むので、$ s $ が $ 1 $ を含む限り、末尾の要素を削除し続ける。$ s $ は $ (1,2,3)→(1,2)→(1)→() $ と変化する。 - $ i=4 $: $ s $ が $ 2 $ を含まないので、$ s $ の末尾に $ 2 $ を追加する。$ s=(2) $ となる。 - $ i=5 $: $ s $ が $ 3 $ を含まないので、$ s $ の末尾に $ 3 $ を追加する。$ s=(2,3) $ となる。

### Sample Explanation 3

数列 $ s $ が空のこともあります。

## 样例 #1

### 输入

```
3 2

1 2 3```

### 输出

```
2 3```

## 样例 #2

### 输入

```
5 10

1 2 3 2 3```

### 输出

```
3```

## 样例 #3

### 输入

```
6 1000000000000

1 1 2 2 3 3```

### 输出

```
```

## 样例 #4

### 输入

```
11 97

3 1 4 1 5 9 2 6 5 3 5```

### 输出

```
9 2 6```

# AI分析结果



**唯一算法分类**：模拟、循环节优化

---

### **题解思路与算法要点**

**核心思路**：  
通过预处理每个元素的下一个相同值的位置（`next`数组），找到操作的循环节。将大数次的重复操作（K次）通过取模简化为小次数，剩余部分暴力模拟栈操作。

**解决难点**：  
1. **避免直接模拟**：K极大（1e12），直接操作会超时。  
2. **循环节推导**：每个元素插入后，再次遇到相同元素时栈会被清空，形成周期性操作。  
3. **高效跳转**：通过`next`数组建立环状结构，快速计算循环次数。

**关键步骤**：  
1. **预处理`next`数组**：记录每个元素下一次出现的位置。  
2. **计算循环节长度**：从起点跳转`next`数组直到回到起点，统计跨过完整数组的次数。  
3. **取模优化**：将K对循环节长度取模，剩余次数暴力处理。

---

### **题解评分 (≥4星)**  
1. **feecle6418 (5星)**:  
   - **亮点**：代码简洁，直接通过`next`跳转找到循环节，暴力部分逻辑清晰。  
   - **代码可读性**：变量命名清晰，无冗余操作。  

2. **Augen_stern (4星)**:  
   - **亮点**：详细分步解释循环节推导，代码注释完整。  
   - **不足**：`next`数组预处理略微复杂。  

3. **StrSeeker (4星)**:  
   - **亮点**：提供两种题解思路对比，代码逻辑直接。  
   - **不足**：代码部分变量名较短，可读性稍差。

---

### **最优思路提炼**  
1. **`next`数组的构建**：  
   - 从后向前遍历数组，记录每个元素最后出现的位置，用于快速跳转。  
   - **代码片段**：  
     ```cpp  
     for (int i = n; i >= 1; i--) {  
         nxt[i] = lst[a[i]];  
         lst[a[i]] = i;  
     }  
     ```  
2. **循环节计算**：  
   - 从起点出发，通过`next`跳转统计跨过完整数组的次数，形成循环节。  
   - **代码片段**：  
     ```cpp  
     int p = 1, d = 0;  
     do {  
         int q = nxt[p];  
         if (q == n) d++;  
         if (q <= p) d++;  
         p = q % n + 1;  
     } while (p != 1);  
     K %= d;  
     ```  
3. **剩余次数暴力模拟**：  
   - 处理模后的K次操作，直接模拟栈的插入和删除。  

---

### **同类型题与类似套路**  
- **循环节优化**：如[LeetCode 957. Prison Cells After N Days](https://leetcode.com/problems/prison-cells-after-n-days/)。  
- **跳跃指针**：如[LeetCode 141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)。  
- **栈操作模拟**：如[洛谷 P5788 单调栈](https://www.luogu.com.cn/problem/P5788)。

---

### **推荐题目**  
1. **洛谷 P1965** [转圈游戏](https://www.luogu.com.cn/problem/P1965)：快速幂与循环节优化。  
2. **洛谷 P1516** [青蛙的约会](https://www.luogu.com.cn/problem/P1516)：模运算与线性同余方程。  
3. **洛谷 P1074** [靶形数独](https://www.luogu.com.cn/problem/P1074)：DFS剪枝与状态优化。

---

### **个人心得摘录**  
- **调试教训**：`next`数组的索引需注意从1开始还是0开始，否则会导致跳转错误。  
- **优化关键**：“发现循环节的存在是突破超大K的关键，直接暴力无法处理”。

---

### **可视化设计**  
**动画方案**：  
1. **像素风格栈模拟**：  
   - 使用8位像素风格绘制栈结构，元素入栈时绿色闪烁，出栈时红色闪烁。  
   - **Canvas实现**：网格布局，每个元素用16x16像素块表示，动态调整栈高度。  
2. **循环节跳转演示**：  
   - 高亮当前处理的元素和对应的`next`指针，箭头指示跳转路径。  
   - 音效：跳转时播放“哔”声，循环节结束时播放上扬音效。  
3. **交互控制**：  
   - **步进按钮**：单步执行跳转或栈操作。  
   - **速度调节**：滑动条控制动画速度（0.5x~5x）。  

**代码片段（JS伪代码）**：  
```javascript  
function drawStack(stack) {  
    ctx.clearRect(0, 0, canvas.width, canvas.height);  
    stack.forEach((val, idx) => {  
        drawPixelBlock(val, 10, 10 + idx * 20);  
    });  
}  
```  

**复古音效**：  
- 入栈：`beep(440, 50)`（高音）。  
- 出栈：`beep(220, 50)`（低音）。  
- 循环节完成：`playSound('victory.wav')`。  

---

**核心代码（feecle6418题解）**  
```cpp  
#include<bits/stdc++.h>  
using namespace std;  
int n, a[200005], lst[200005], nxt[200005], st[200005], top, is[200005];  
ll K;  
void Push(int x) {  
    if (!is[x]) st[++top] = x, is[x] = 1;  
    else while (st[top] != x) is[st[top--]] = 0;  
}  
int main() {  
    cin >> n >> K;  
    for (int i = 1; i <= n; i++) cin >> a[i];  
    for (int i = n; i >= 1; i--) nxt[i] = lst[a[i]], lst[a[i]] = i;  
    int p = 1, d = 0;  
    do { // 计算循环节长度  
        int q = nxt[p];  
        if (q == n) d++;  
        if (q <= p) d++;  
        p = q % n + 1;  
    } while (p != 1);  
    K %= d;  
    while (K > 5) { // 处理大K  
        int q = nxt[p], w = (q == n) + (q <= p);  
        p = q % n + 1, K -= w;  
    }  
    for (int i = p; i <= n; i++) Push(a[i]); // 暴力模拟剩余  
    for (int j = 1; j < K; j++)  
        for (int i = 1; i <= n; i++) Push(a[i]);  
    for (int i = 1; i <= top; i++) cout << st[i] << ' ';  
}  
```

---
处理用时：101.86秒
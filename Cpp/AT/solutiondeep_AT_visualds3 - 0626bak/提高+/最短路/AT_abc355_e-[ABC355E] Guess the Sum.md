# 题目信息

# [ABC355E] Guess the Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc355/tasks/abc355_e

この問題は **インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

正整数 $ N $ および $ 0 $ 以上 $ 2^N $ 未満の整数 $ L,R(L\leq\ R) $ が与えられます。 ジャッジシステムは、$ 0 $ 以上 $ 99 $ 以下の整数からなる長さ $ 2^N $ の数列 $ A\ =\ (A_0,\ A_1,\ \dots,\ A_{2^N-1}) $ を隠し持っています。

あなたの目標は $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを求めることです。ただし、あなたは数列 $ A $ の要素の値を直接知ることはできません。 その代わりに、ジャッジシステムに対して以下の質問を行うことができます。

- $ 2^i(j+1)\leq\ 2^N $ を満たすように非負整数 $ i,j $ を選ぶ。$ l=2^ij,r=2^i(j+1)-1 $ として $ A_l+A_{l+1}+\dots+A_{r} $ を $ 100 $ で割った余りを聞く。
 
どのような $ A $ であっても $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを特定することができる質問回数の最小値を $ m $ とします。$ m $ 回以内の質問を行って $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを求めてください。

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

最初に、整数 $ N,L,R $ を標準入力から受け取ってください。

> $ N $ $ L $ $ R $

次に、$ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りを特定できるまで質問を繰り返してください。 質問は、以下の形式で標準出力に出力してください。

> $ ? $ $ i $ $ j $

ここで、$ i,j $ は以下を満たす必要があります。

- $ i,j $ は非負整数
- $ 2^i(j+1)\leq\ 2^N $
 
これに対する応答は、次の形式で標準入力から与えられます。

> $ T $

ここで、$ T $ は質問に対する答えで、$ l=2^ij,r=2^i(j+1)-1 $ としたとき $ A_l+A_{l+1}+\dots+A_{r} $ を $ 100 $ で割った余りです。

ただし、$ i,j $ が制約を満たしていないか、質問回数が $ m $ 回を超えた場合は $ T $ は `-1` となります。

ジャッジが `-1` を返した場合、プログラムはすでに不正解とみなされています。この場合、ただちにプログラムを終了してください。

$ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りが特定出来たら、$ S $ を $ A_L+A_{L+1}+\dots+A_{R} $ を $ 100 $ で割った余りとして以下の形式で出力してください。その後、ただちにプログラムを終了してください。

> $ ! $ $ S $

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 18 $
- $ 0\leq\ L\leq\ R\leq\ 2^N-1 $
- 入力は全て整数
 
### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で誤った出力形式による出力を行った、あるいはプログラムが途中で終了した場合のジャッジ結果は不定です。**
- 解答を出力したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
 
### 入出力例

以下は、$ N=3,L=1,R=5,A=(31,41,59,26,53,58,97,93) $ の場合の入出力例です。この場合 $ m=3 $ であるため、質問を $ 3 $ 回まで行うことができます。

    入力 出力 説明     `3 1 5`  まず整数 $ N,L,R $ が与えられます。    `? 0 1`  $ (i,j)=(0,1) $ として質問を行います。   `41`  $ l=1,r=1 $ であるため、質問の答えは $ A_1=41 $ を $ 100 $ で割った余りである $ 41 $ です。ジャッジはその値を返します。    `? 1 1` $ (i,j)\ =\ (1,1) $ として質問を行います。   `85`  $ l=2,r=3 $ であるため、質問の答えは $ A_2+A_3=85 $ を $ 100 $ で割った余りである $ 85 $ です。ジャッジはその値を返します。    `? 1 2` $ (i,j)\ =\ (1,2) $ として質問を行います。   `11`  $ l=4,r=5 $ であるため、質問の答えは $ A_4+A_5=111 $ を $ 100 $ で割った余りである $ 11 $ です。ジャッジはその値を返します。    `! 37` 答えは $ 37 $ であるとわかったので、それを出力します。

# AI分析结果



## 算法分类
**BFS最短路**

---

## 综合分析与结论
### 核心思路
1. **前缀和差分转化**：将区间和转化为前缀和差 `sum[r] - sum[l-1]`，问题转化为求 `L` 到 `R+1` 的最短路径。
2. **图模型构建**：每个合法询问区间 `[2^i*j, 2^i*(j+1)-1]` 对应从 `2^i*j` 到 `2^i*(j+1)` 的双向边，边权为 1。
3. **BFS求最短路**：从 `L` 开始 BFS 找到到 `R+1` 的最短路径，记录前驱节点。
4. **路径回溯计算**：沿最短路径回溯时，根据移动方向（加/减区间）累加或扣除对应区间和。

### 解决难点
- **建图优化**：每个节点 `u` 只能向满足 `2^i | u` 的 `u ± 2^i` 转移，避免无效边。
- **路径方向判断**：通过比较前驱节点与当前节点的位置，确定加减方向。
- **模运算处理**：动态维护 `(ans % 100 + 100) % 100` 保证结果非负。

---

## 题解清单（评分 ≥4星）
1. **__ryp__（4.5星）**
   - **亮点**：代码简洁，详细解释 lowbit 优化转移条件。
   - **代码**：使用 BFS 最短路，路径回溯时动态计算模值。
   - **心得**：明确对比 ABC349D 的差异，强调可减性带来的优化空间。

2. **Iceturky（4星）**
   - **亮点**：将区间转为左闭右开形式，避免边界问题。
   - **代码**：双向建边，路径回溯时通过 `__lg` 快速计算区间长度。

3. **ran_qwq（4星）**
   - **亮点**：完整注释，清晰展示路径回溯的加减逻辑。
   - **代码**：使用 `pre[]` 数组记录前驱，通过 `__lg` 计算区间长度。

---

## 核心代码实现
### 建图与 BFS（Iceturky 实现）
```cpp
for(int k=0;k<=n;k++)
    for(int i=0;((i+1)<<k)<=(1<<n);i++)
        add(i<<k,(i+1)<<k), add((i+1)<<k,i<<k);

bfs(l, r+1); // 目标转为 R+1
```

### 路径回溯计算（ran_qwq 实现）
```cpp
int ans = 0;
for(int i=frm[r];i!=r;r=i,i=frm[i]){
    if(i < r) // 正向区间，加
        cout<<"? "<<__lg(r-i)<<" "<<(i>>__lg(r-i))<<endl;
    else      // 反向区间，减
        cout<<"? "<<__lg(i-r)<<" "<<(r>>__lg(i-r))<<endl;
    ans = (ans + 正负贡献) % 100;
}
```

---

## 同类型题目
1. **P10145 [WC2024] 线段树**：利用区间覆盖性质建图求最短路。
2. **CF1774E**：交互式最短路 + 动态路径回溯。
3. **AT_abc349_d**：区间覆盖问题（不可减版）。

---

## 个人心得摘录
- **__ryp__**：贪心策略无法保证最优，必须通过 BFS 枚举所有可能转移。
- **M1saka16I72**：将区间问题转化为前缀和差分是突破思维定式的关键。
- **Pentiment**：直接上线段树结构并非最优，暴力 BFS 反而更高效。

---

## 可视化与算法演示
### 动画设计
1. **节点扩展**：用绿色高亮当前 BFS 节点，红色标记已访问节点。
2. **边绘制**：蓝色线条表示合法转移边，灰色表示未激活边。
3. **路径回溯**：黄色箭头指示最短路径，加减操作用 `+`/`-` 符号动态显示。

### 复古游戏化要素
- **8-bit 音效**：节点扩展时播放 `beep` 音，路径完成时播放胜利音效。
- **像素网格**：用 16x16 像素块表示每个节点，转移边用不同颜色区分。
- **自动演示模式**：按空格键切换手动/自动，观察 BFS 如何逐步扩展。

### 交互控制
```javascript
// 伪代码：Canvas 绘制节点
function drawNode(x, y, state) {
    ctx.fillStyle = state === 'active' ? '#00FF00' : '#888888';
    ctx.fillRect(x*16, y*16, 14, 14); // 像素风格留边框
}
```

---

## 举一反三
1. **逆向思维**：将求和问题转化为图论模型。
2. **前缀和技巧**：差分计算是区间问题的常见突破口。
3. **BFS 应用**：边权相等时 BFS 可替代 Dijkstra，效率更优。

---
处理用时：74.63秒
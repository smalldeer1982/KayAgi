# 题目信息

# [ARC090E] Avoiding Collision

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc090/tasks/arc090_c

$ N $ 頂点 $ M $ 辺からなるグラフがあり、このグラフの上に高橋くんと青木くんがいます。

グラフの $ i $ 番目の辺は頂点 $ U_i $ と頂点 $ V_i $ を結んでいます。 この辺を通るのにかかる時間は、通る人 (高橋くんまたは青木くん) によらず、また通る方向によらず、$ D_i $ 分です。

高橋くんは頂点 $ S $ を、青木くんは頂点 $ T $ を同時に出発し、それぞれ頂点 $ T $ および頂点 $ S $ へ最短の時間で移動します。 二人の最短路の選び方の組であって、移動の途中で二人が (辺または頂点上で) 出会うことのないようなものの個数を $ 10^9\ +\ 7 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100,000 $
- $ 1\ \leq\ M\ \leq\ 200,000 $
- $ 1\ \leq\ S,\ T\ \leq\ N $
- $ S\ \neq\ T $
- $ 1\ \leq\ U_i,\ V_i\ \leq\ N $ ($ 1\ \leq\ i\ \leq\ M $)
- $ 1\ \leq\ D_i\ \leq\ 10^9 $ ($ 1\ \leq\ i\ \leq\ M $)
- $ i\ \neq\ j $ のとき、$ (U_i,\ V_i)\ \neq\ (U_j,\ V_j) $ かつ $ (U_i,\ V_i)\ \neq\ (V_j,\ U_j) $
- $ U_i\ \neq\ V_i $ ($ 1\ \leq\ i\ \leq\ M $)
- $ D_i $ は整数である
- 与えられるグラフは連結である

### Sample Explanation 1

条件を満たす最短路の選び方は以下の 2 通りあります。 - 高橋くんが頂点 $ 1\ \rightarrow\ 2\ \rightarrow\ 3 $ という経路で、青木くんが頂点 $ 3\ \rightarrow\ 4\ \rightarrow\ 1 $ という経路で移動する。 - 高橋くんが頂点 $ 1\ \rightarrow\ 4\ \rightarrow\ 3 $ という経路で、青木くんが頂点 $ 3\ \rightarrow\ 2\ \rightarrow\ 1 $ という経路で移動する。

## 样例 #1

### 输入

```
4 4

1 3

1 2 1

2 3 1

3 4 1

4 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

1 3

1 2 1

2 3 1

3 1 2```

### 输出

```
2```

## 样例 #3

### 输入

```
3 3

1 3

1 2 1

2 3 1

3 1 2```

### 输出

```
2```

## 样例 #4

### 输入

```
8 13

4 2

7 3 9

6 2 3

1 6 4

7 6 9

3 8 9

1 2 2

2 8 12

8 6 9

2 5 5

4 2 18

5 3 7

5 1 515371567

4 8 6```

### 输出

```
6```

# AI分析结果



### 唯一算法分类
最短路

---

### 题解思路与核心分析

#### 核心思路
1. **容斥原理**：总方案数（两人走最短路的组合）减去相遇方案数。
2. **最短路计数**：用 Dijkstra 算法计算从 S 和 T 出发的最短路径长度及路径数。
3. **相遇判断**：
   - **点相遇**：两人在某个点相遇需满足该点到 S 和 T 的最短路径长度相等，且两者之和等于总最短路长度。
   - **边相遇**：两人在边两端的时间差需满足不相交条件，且该边在最短路上。

#### 解决难点
- **最短路计数**：需在 Dijkstra 松弛过程中动态维护路径数。
- **双向判断**：边的相遇需检查两个方向（u→v 和 v→u）。
- **条件判断**：精确计算相遇的数学条件，避免重复或遗漏。

---

### 题解评分 (≥4星)

1. **小粉兔 (⭐⭐⭐⭐⭐)**
   - **亮点**：代码清晰，使用优先队列优化 Dijkstra，显式处理边的双向条件。
   - **核心代码**：两次 Dijkstra 计算最短路和路径数，双重循环遍历边。

2. **DengDuck (⭐⭐⭐⭐)**
   - **亮点**：代码简洁，通过交换边方向简化双向判断。
   - **核心逻辑**：用 `swap(u, v)` 处理边的双向相遇。

3. **Larryyu (⭐⭐⭐⭐)**
   - **亮点**：详细注释和条件推导，适合初学者理解。
   - **关键步骤**：显式分离点相遇和边相遇的条件判断。

---

### 最优技巧提炼
1. **容斥与最短路结合**：总方案数为路径数平方，通过减非法情况简化问题。
2. **边方向处理**：遍历边时交换起点终点，避免重复编码。
3. **数学条件剪枝**：对每个点和边严格验证相遇的充分必要条件。

---

### 同类型题与算法套路
- **通用套路**：最短路计数 + 条件容斥，常用于路径限制问题。
- **类似题目**：
  - 洛谷 P1144（最短路计数）
  - 洛谷 P1608（路径统计）
  - 洛谷 P3953（路径长度限制统计）

---

### 推荐洛谷题目
1. **P1144**：最短路计数，基础模板题。
2. **P1608**：统计指定条件的路径数。
3. **P2296**：需要结合最短路和节点排除条件。

---

### 个人心得摘录
- **小粉兔**：“注意边是无向的，需双向判断相遇条件。”
- **DengDuck**：“交换 u 和 v 处理边的方向，减少代码冗余。”
- **Larryyu**：“正难则反，先算总方案再减非法情况更简单。”

---

### 可视化算法演示设计

#### 核心流程动画
1. **Dijkstra 执行过程**：
   - **颜色标记**：当前处理的节点高亮为黄色，已确定最短路的节点为绿色。
   - **动态更新**：实时显示每个节点的最短距离和路径数。

2. **相遇条件检测**：
   - **点相遇**：满足条件的点显示红色边框，伴随闪烁效果。
   - **边相遇**：符合条件的边以蓝色高亮，并显示时间差公式。

#### 复古像素风格实现
- **Canvas 绘制**：节点为 16x16 像素方块，边为像素线条。
- **音效**：
  - 节点更新：8-bit “哔”声。
  - 条件满足：上扬音效提示合法相遇。
  - 错误操作：短促“咔嗒”声。

#### 交互设计
- **步进控制**：支持暂停/继续，单步执行 Dijkstra 松弛。
- **自动模式**：AI 自动运行，按最优顺序处理节点和边。

---

### 核心代码片段（小粉兔题解）
```cpp
void Dij(ll*d,ll*g,bool*v,int s){
    d[s]=0; pq.push(pli(0ll,s)); g[s]=1;
    while(!pq.empty()){
        pli P=pq.top(); pq.pop();
        int u=P.second; ll du=P.first;
        if(v[u]||d[u]<du) continue;
        v[u]=1;
        eF(i,u){ // 遍历邻接边
            if(d[to[i]]==du+w[i]) g[to[i]]=(g[to[i]]+g[u])%Mod;
            if(d[to[i]]>du+w[i]){
                g[to[i]]=g[u];
                d[to[i]]=du+w[i];
                pq.push(pli(d[to[i]],to[i]));
            }
        }
    }
}
// 统计点相遇
F(i,1,n) if(d1[i]+d2[i]==Dist && d1[i]==d2[i])
    Ans=(Ans - g1[i]^2 * g2[i]^2) % Mod;
// 统计边相遇（双向）
F(i,1,m){
    u=U[i],v=V[i],d=D[i];
    if(d1[u]+d+d2[v]==Dist && d1[u]+d>d2[v] && d2[v]+d>d1[u])
        Ans=(Ans - g1[u]^2 * g2[v]^2) % Mod;
    swap(u,v); // 处理反向边
    // 重复上述判断
}
```

---

### 总结
通过两次 Dijkstra 计算双向最短路和路径数，再严格判断点和边的相遇条件，最终用容斥得出答案。可视化设计可帮助理解动态松弛和条件检查过程。

---
处理用时：89.89秒
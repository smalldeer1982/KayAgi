# 题目信息

# [ABC311G] One More Grid Task

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc311/tasks/abc311_g

$ N\ \times\ M $ のグリッドがあり、上から $ i $ 行目、左から $ j $ 列目のマス $ (i,j) $ には非負整数 $ A_{i,j} $ が書かれています。  
 このグリッドのうち長方領域をひとつ選び、それを $ R $ とします。  
 厳密には、長方領域は以下の手順で選ばれます。

- $ 1\ \le\ l_x\ \le\ r_x\ \le\ N,\ 1\ \le\ l_y\ \le\ r_y\ \le\ M $ なる整数 $ l_x,\ r_x,\ l_y,\ r_y $ を選ぶ。
- このとき、整数 $ i,j $ が $ l_x\ \le\ i\ \le\ r_x $ かつ $ l_y\ \le\ j\ \le\ r_y $ を満たす、またその時に限って、マス $ (i,j) $ は $ R $ に含まれる。
 
適切に $ R $ を選ぶことによって、 $ f(R)\ = $ ( $ R $ 内のマスに書かれた整数の総和 ) $ \times $ ( $ R $ 内のマスに書かれた整数の最小値 ) として達成可能な最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N,M\ \le\ 300 $
- $ 1\ \le\ A_{i,j}\ \le\ 300 $
 
### Sample Explanation 1

左上がマス $ (1,1) $ 、右下がマス $ (2,2) $ の長方領域を選ぶことで、 $ f(R)\ =\ (5+4+4+3)\ \times\ \min(5,4,4,3)\ =\ 48 $ が達成でき、これが達成可能な最大値です。

## 样例 #1

### 输入

```
3 3

5 4 3

4 3 2

3 2 1```

### 输出

```
48```

## 样例 #2

### 输入

```
4 5

3 1 4 1 5

9 2 6 5 3

5 8 9 7 9

3 2 3 8 4```

### 输出

```
231```

## 样例 #3

### 输入

```
6 6

1 300 300 300 300 300

300 1 300 300 300 300

300 300 1 300 300 300

300 300 300 1 300 300

300 300 300 300 1 300

300 300 300 300 300 1```

### 输出

```
810000```

# AI分析结果



**唯一算法分类**：单调栈应用（二维转一维）

---

### **综合分析与结论**

#### **核心思路与难点**
- **核心思路**：将二维问题通过枚举上下边界压缩为一维，转化为「最小值乘区间和」的一维问题，结合单调栈快速求解每个最小值对应的最大区间。
- **关键难点**：
  1. **维度压缩**：如何将二维问题降维（枚举上下边界，计算每列的最小值/总和）。
  2. **快速求极值区间**：利用单调栈在 O(n) 时间内求解每个最小值对应的最大左右扩展边界。
- **算法流程**：
  1. **枚举上下边界** `x` 和 `y`，计算每列的最小值 `min_col[j]` 和总和 `sum_col[j]`。
  2. **前缀和优化**：计算 `sum_col` 的前缀和数组 `prefix`。
  3. **单调栈处理**：对 `min_col` 使用单调栈，找到每个 `j` 的左右第一个小于 `min_col[j]` 的位置 `left[j]` 和 `right[j]`。
  4. **计算贡献**：对每个 `j`，贡献值为 `min_col[j] * (prefix[right[j]] - prefix[left[j]-1])`，取最大值。

#### **可视化设计思路**
- **二维压缩动画**：网格中高亮当前枚举的上下边界，并动态生成一维 `min_col` 和 `sum_col` 的折线图。
- **单调栈动态演示**：用栈结构动态展示入栈、出栈过程，高亮当前处理的列和栈顶元素，触发音效（入栈“哔”，出栈“咔”）。
- **复古像素风格**：
  - 使用 8-bit 调色板（红、蓝、绿）渲染网格。
  - 关键步骤配 FC 音效，如找到最大值时播放“胜利”音效。
  - Canvas 绘制网格和折线图，单步执行控制速度。

---

### **题解清单（≥4星）**

1. **EuphoricStar（5星）**  
   - **关键亮点**：简洁的二维转一维思路，代码实现清晰，时间复杂度最优（O(n³)）。
   - **代码片段**：
     ```cpp
     for (int x = 1; x <= n; x++) {
         for (int j = 1; j <= m; j++) min_col[j] = INF;
         for (int y = x; y <= n; y++) {
             for (int j = 1; j <= m; j++) {
                 min_col[j] = min(min_col[j], a[y][j]);
                 sum_col[j] += a[y][j];
             }
             // 单调栈处理及贡献计算
         }
     }
     ```

2. **CaiZi（4星）**  
   - **关键亮点**：动态更新列的最小值和总和，避免重复计算，代码高效。
   - **代码片段**：
     ```cpp
     for (int y = x; y <= n; y++) {
         for (int k = 1; k <= m; k++) {
             b[k] = min(b[k], a[y][k]);
             c[k] = c[k] + a[y][k];
             d[k] = d[k-1] + c[k];
         }
         // 单调栈处理
     }
     ```

3. **FBW2010（4星）**  
   - **关键亮点**：详细注释和变量命名，适合新手理解，附带悬线法对比。
   - **代码片段**：
     ```cpp
     while (top && minn[st[top]] >= minn[k]) top--;
     l[k] = st[top] + 1;
     st[++top] = k;
     ```

---

### **最优思路与技巧提炼**
- **关键技巧**：
  1. **枚举上下边界**：将二维压缩为一维，时间复杂度从 O(n⁴) 降至 O(n³)。
  2. **单调栈维护极值区间**：快速求解每个最小值对应的最大扩展区间。
  3. **前缀和优化**：O(1) 时间计算区间和，避免重复求和。

---

### **同类型题推荐**
1. **P5788 单调栈模板**：练习单调栈基础。
2. **P4147 玉蟾宫**：悬线法求最大子矩阵。
3. **P1169 棋盘制作**：悬线法变种，结合奇偶性约束。

---

### **可视化代码片段（Canvas动画）**
```javascript
// 绘制二维网格与一维折线
function drawGridAndLine(minCol, sumCol) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制二维网格（略）
    // 绘制一维折线
    minCol.forEach((val, j) => {
        ctx.fillStyle = '#FF0000'; // 红色像素块表示最小值
        ctx.fillRect(j * 10, 200 - val, 8, 8);
    });
    sumCol.forEach((val, j) => {
        ctx.fillStyle = '#00FF00'; // 绿色像素块表示总和
        ctx.fillRect(j * 10, 300 - val, 8, 8);
    });
}
```

---

### **复古音效设计**
- **入栈音效**：8-bit 短音（频率 800Hz，时长 50ms）。
- **出栈音效**：频率 400Hz，时长 30ms。
- **最大贡献音效**：上升音阶（200→1000Hz，时长 200ms）。

---

**总结**：通过枚举维度降维+单调栈维护极值区间，时间复杂度严格 O(n³)，代码简洁高效，结合动态可视化可深入理解算法流程。

---
处理用时：82.83秒
# 题目信息

# [ABC311G] One More Grid Task

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc311/tasks/abc311_g

$ N\ \times\ M $ のグリッドがあり、上から $ i $ 行目、左から $ j $ 列目のマス $ (i,j) $ には非負整数 $ A_{i,j} $ が書かれています。  
 このグリッドのうち長方領域をひとつ選び、それを $ R $ とします。  
 厳密には、長方領域は以下の手順で選ばれます。

- $ 1\ \le\ l_x\ \le\ r_x\ \le\ N,\ 1\ \le\ l_y\ \le\ r_y\ \le\ M $ なる整数 $ l_x,\ r_x,\ l_y,\ r_y $ を選ぶ。
- このとき、整数 $ i,j $ が $ l_x\ \le\ i\ \le\ r_x $ かつ $ l_y\ \le\ j\ \le\ r_y $ を満たす、またその時に限って、マス $ (i,j) $ は $ R $ に含まれる。
 
適切に $ R $ を選ぶことによって、 $ f(R)\ = $ ( $ R $ 内のマスに書かれた整数の総和 ) $ \times $ ( $ R $ 内のマスに書かれた整数の最小値 ) として達成可能な最大値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N,M\ \le\ 300 $
- $ 1\ \le\ A_{i,j}\ \le\ 300 $
 
### Sample Explanation 1

左上がマス $ (1,1) $ 、右下がマス $ (2,2) $ の長方領域を選ぶことで、 $ f(R)\ =\ (5+4+4+3)\ \times\ \min(5,4,4,3)\ =\ 48 $ が達成でき、これが達成可能な最大値です。

## 样例 #1

### 输入

```
3 3

5 4 3

4 3 2

3 2 1```

### 输出

```
48```

## 样例 #2

### 输入

```
4 5

3 1 4 1 5

9 2 6 5 3

5 8 9 7 9

3 2 3 8 4```

### 输出

```
231```

## 样例 #3

### 输入

```
6 6

1 300 300 300 300 300

300 1 300 300 300 300

300 300 1 300 300 300

300 300 300 1 300 300

300 300 300 300 1 300

300 300 300 300 300 1```

### 输出

```
810000```

# AI分析结果



**唯一算法分类**：单调栈结合二维压缩

---

### **题解思路与难点分析**

#### **核心思路**  
题目要求找出一个子矩阵，使其元素和与最小值的乘积最大。主要方法是将二维问题压缩为一维处理：

1. **枚举上下边界**：固定上边界 `x` 和下边界 `y`，逐行扩展，将每一列的最小值和总和压缩为一维数组 `b[]`（最小值）和 `c[]`（总和）。
2. **一维处理**：对 `b[]` 使用单调栈，找到每个元素作为最小值时的左右边界，计算对应的区间和并更新最大值。

#### **解决难点**  
- **二维压缩为一维**：通过枚举上下边界，将每一列的最小值和总和压缩成一维数组，将问题转化为一维问题。
- **单调栈的高效处理**：利用单调栈快速找到每个元素作为最小值时的最大有效区间，时间复杂度优化至 O(n²m)。

---

### **题解评分 (≥4星)**

1. **EuphoricStar (⭐⭐⭐⭐⭐)**  
   - **思路清晰**：明确二维转一维的思想，代码简洁高效。  
   - **代码可读性**：使用逐步维护列的最小值和总和，单调栈逻辑清晰。  
   - **核心代码片段**：  
     ```cpp
     for (int x = 1; x <= n; x++) {
         for (int j = 1; j <= m; j++) b[j] = INF, c[j] = 0;
         for (int y = x; y <= n; y++) {
             for (int j = 1; j <= m; j++) {
                 b[j] = min(b[j], a[y][j]);
                 c[j] += a[y][j];
             }
             // 单调栈处理逻辑
         }
     }
     ```

2. **CaiZi (⭐⭐⭐⭐)**  
   - **优化思路**：动态维护列的最小值和总和，减少重复计算。  
   - **代码实现**：通过前缀和与单调栈结合，逻辑清晰。  
   - **核心代码片段**：  
     ```cpp
     for (int y = x; y <= n; y++) {
         for (int i = 1; i <= m; i++) {
             b[i] = min(b[i], a[y][i]);
             c[i] += a[y][i];
             d[i] = d[i-1] + c[i];
         }
         // 单调栈处理逻辑
     }
     ```

3. **FBW2010 (⭐⭐⭐⭐)**  
   - **实现细节**：显式处理左右边界的单调栈，代码易理解。  
   - **核心逻辑**：  
     ```cpp
     for (int k = 1; k <= m; k++) {
         while (!st.empty() && mn[st.top()] >= mn[k]) st.pop();
         l[k] = st.empty() ? 1 : st.top() + 1;
         st.push(k);
     }
     ```

---

### **最优思路提炼**

1. **二维压缩为一维**：枚举上下边界，将每列的最小值和总和存储为一维数组。
2. **单调栈求最大区间**：对每个元素找到其作为最小值时的最大左右边界，计算区间和与最小值的乘积。

---

### **同类型题目推荐**

1. **P4147 玉蟾宫**：最大全 0 子矩阵（悬线法经典题）。  
2. **P5788 单调栈模板**：寻找右侧第一个更大元素。  
3. **P2216 理想的正方形**：二维滑动窗口求极值。

---

### **可视化算法设计**

1. **动画流程**  
   - **步骤1**：展示矩阵的上下边界动态变化，高亮当前枚举的 `x` 和 `y`。  
   - **步骤2**：绘制压缩后的一维数组 `b[]` 和 `c[]`，显示每列的最小值和总和。  
   - **步骤3**：用颜色标记单调栈操作，当前元素入栈时高亮，弹出栈顶时显示左右边界。  

2. **复古像素风格**  
   - **颜色方案**：8-bit 调色板，绿色表示当前操作列，红色表示栈内元素。  
   - **音效触发**：元素入栈时播放“滴”声，找到更大值时播放成功音效。  

3. **交互功能**  
   - **步进控制**：允许调整枚举速度或单步执行，观察压缩和单调栈过程。  
   - **自动演示**：模拟 AI 自动运行，展示最优解的寻找过程。

---

### **核心代码实现**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 305;
int a[N][N], b[N], c[N], n, m;
ll sum[N], ans = 0;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    
    for (int x = 1; x <= n; x++) {
        fill(b + 1, b + m + 1, INT_MAX);
        fill(c, c + m + 1, 0);
        for (int y = x; y <= n; y++) {
            for (int j = 1; j <= m; j++) {
                b[j] = min(b[j], a[y][j]);
                c[j] += a[y][j];
                sum[j] = sum[j-1] + c[j];
            }
            stack<int> st; st.push(0);
            for (int j = 1; j <= m; j++) {
                while (st.size() > 1 && b[st.top()] >= b[j]) {
                    int k = st.top(); st.pop();
                    ans = max(ans, (ll)(sum[j-1] - sum[st.top()]) * b[k]);
                }
                st.push(j);
            }
            while (st.size() > 1) {
                int k = st.top(); st.pop();
                ans = max(ans, (ll)(sum[m] - sum[st.top()]) * b[k]);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

### **个人心得**

- **调试关键**：注意处理单调栈的初始化和边界条件（如哨兵元素）。  
- **优化点**：在枚举上下边界时，动态维护列的最小值和总和，避免重复计算。

---
处理用时：198.30秒
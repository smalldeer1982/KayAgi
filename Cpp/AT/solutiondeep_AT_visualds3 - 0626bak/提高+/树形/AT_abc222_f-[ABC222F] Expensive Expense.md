# 题目信息

# [ABC222F] Expensive Expense

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc222/tasks/abc222_f

AtCoder 王国は $ N $ 個の街と $ N-1 $ 個の道路からなります。  
 街には 街 $ 1 $, 街 $ 2 $, $ \dots $, 街 $ N $ と番号がついています。道路にも同様に 道路 $ 1 $, 道路 $ 2 $, $ \dots $, 道路 $ N-1 $ と番号が付いています。 道路 $ i $ は街 $ A_i $ と $ B_i $ を双方向に結んでいて、通過するときに $ C_i $ の通行料がかかります。すべての異なる街の組 $ (i,\ j) $ に対して、道路を経由して街 $ i $ から街 $ j $ に行くことができます。

今、列 $ D\ =\ (D_1,\ D_2,\ \dots,\ D_N) $ が与えられます。 $ D_i $ は街 $ i $ を観光するときにかかる費用です。 このとき、街 $ i $ から街 $ j $ への旅費 $ E_{i,j} $ を、(同じ道を $ 2 $ 回以上使わずに街 $ i $ から街 $ j $ へ向かうときにかかる通行料の和) に $ D_{j} $ を足したものとして定めます。

- 厳密に言い換えると、$ i\ -\ j $ 間の最短パスを $ i\ =\ p_0,\ p_1,\ \dots,\ p_{k-1},\ p_k\ =\ j $ として、街 $ p_{l} $ と街 $ p_{l+1} $ を結ぶ道路の通行料を $ c_l $ と置いたときに $ E_{i,j}\ =\ D_j\ +\ \displaystyle\sum_{l=0}^{k-1}\ c_l $ と定義します。

すべての $ i $ に対して、街 $ i $ を始点として他の街へ旅行したときにありえる旅費の最大値を求めてください。

- 厳密に言い換えると、すべての $ i $ に対して $ \max_{1\ \leq\ j\ \leq\ N,\ j\ \neq\ i}\ E_{i,j} $ を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ B_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ D_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N) $
- 整数の組 $ (i,j) $ が $ 1\ \leq\ i\ \lt\ j\ \leq\ N $ を満たすならば、街 $ i $ から街 $ j $ へいくつかの道路を通ることで移動できる。
- 入力はすべて整数である。

### Sample Explanation 1

すべての街の順序つき組 $ (i,j) $ に対して $ E_{i,j} $ を計算すると次のようになります。 - $ E_{1,2}\ =\ 2\ +\ 2\ =\ 4 $ - $ E_{1,3}\ =\ 5\ +\ 3\ =\ 8 $ - $ E_{2,1}\ =\ 2\ +\ 1\ =\ 3 $ - $ E_{2,3}\ =\ 3\ +\ 3\ =\ 6 $ - $ E_{3,1}\ =\ 5\ +\ 1\ =\ 6 $ - $ E_{3,2}\ =\ 3\ +\ 2\ =\ 5 $

## 样例 #1

### 输入

```
3

1 2 2

2 3 3

1 2 3```

### 输出

```
8

6

6```

## 样例 #2

### 输入

```
6

1 2 3

1 3 1

1 4 4

1 5 1

1 6 5

9 2 6 5 3 100```

### 输出

```
105

108

106

109

106

14```

## 样例 #3

### 输入

```
6

1 2 1000000000

2 3 1000000000

3 4 1000000000

4 5 1000000000

5 6 1000000000

1 2 3 4 5 6```

### 输出

```
5000000006

4000000006

3000000006

3000000001

4000000001

5000000001```

# AI分析结果



## 唯一算法分类
树的直径

---

## 综合分析与结论
**核心思路**：  
将每个点的点权转化为虚拟边权，通过两次DFS找到树的直径端点。每个点的最大旅费即为到两个端点距离的最大值。

**关键步骤**：
1. 为每个点u创建虚拟点u+n，连边权为D[u]
2. 两次DFS找到扩展后的树的直径端点L、R
3. 分别以L、R为根计算每个点到它们的距离
4. 最终答案为max(disL[i], disR[i])，排除端点自身情况

**可视化设计**：  
采用像素风格动画演示：
1. **树构建阶段**：用绿色方块表示原节点，黄色方块表示虚拟节点，动态绘制边权
2. **直径寻找**：
   - 第一次DFS用红色路径标记当前最长路径，找到端点L时播放胜利音效
   - 第二次DFS用蓝色路径标记，找到端点R时播放上扬音效
3. **距离计算**：以L、R为根时，用渐变色表示各节点距离值变化
4. **交互控制**：可单步执行DFS过程，高亮当前访问节点和回溯路径

---

## 题解清单 (4星及以上)

1. **作者：_zzzzzzy_（5星）**
   - 亮点：巧妙构造虚拟点转化点权，利用直径性质O(n)解决
   - 代码简洁高效，关键代码段：
     ```cpp
     add(i, n+i, d[i]); // 虚拟点连边
     dfs(l,0,disl); dfs(r,0,disr); // 两次距离计算
     ```

2. **作者：GI录像机（4星）**
   - 亮点：清晰阐述虚拟点与直径性质的关系
   - 关键图示辅助理解树的转化过程

3. **作者：tanshunyu0913（4星）**
   - 亮点：完整推导直径性质的应用场景
   - 代码结构清晰，包含详细的注释说明

---

## 最优思路提炼
**核心技巧**：
1. **虚拟点转化**：将点权D[i]转化为i→i+n的边权，使问题转化为纯边权问题
2. **直径端点性质**：最远点必为直径端点之一，避免逐个计算
3. **双端距离存储**：通过两次DFS存储各点到两端点的距离

**实现要点**：
```cpp
// 虚拟点连边
for(int i=1; i<=n; i++){
    add(i, i+n, D[i]);
    add(i+n, i, D[i]);
}

// 找直径端点
dfs(1,0); 
int L = 找到最远点;
dfs(L,0);
int R = 找到最远点;

// 计算距离
dfs(L, disL); 
dfs(R, disR);
```

---

## 相似题目推荐
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)  
   考察直径性质在最优路径选择中的应用

2. [P4408 逃学的小孩](https://www.luogu.com.cn/problem/P4408)  
   需要找到三点构成的最长路径，依赖直径端点特性

3. [P5536 核心节点](https://www.luogu.com.cn/problem/P5536)  
   结合直径性质与贪心选择

---

## 可视化算法演示
**动画流程**：
1. **树构建**：节点按层次展开，虚拟点显示在右侧
2. **第一次DFS**：
   - 动态显示深度优先遍历路径
   - 当前最长路径用红色高亮，终点L闪烁提示
3. **第二次DFS**：
   - 从L出发，蓝色路径标记新最长路径
   - 终点R出现时播放音效并显示直径线段
4. **结果展示**：
   - 切换L/R视角，显示各点到端点的距离
   - 最终答案用不同颜色标注在节点上方

**代码片段示例**（Canvas绘制节点）：
```javascript
function drawNode(x, y, isVirtual) {
  ctx.fillStyle = isVirtual ? '#FFD700' : '#00FF00';
  ctx.beginPath();
  ctx.arc(x, y, 15, 0, Math.PI*2);
  ctx.fill();
}
```

---

## 个人心得摘录
> "调试时发现虚拟点的编号处理错误，导致距离计算混乱。将原节点与虚拟节点分离编号后问题解决" —— 来自题解调试经历

> "最初尝试用换根DP，但处理兄弟节点间的最大值传递非常复杂，改用直径性质后代码量减少80%" —— 优化思路转变

---
处理用时：70.33秒
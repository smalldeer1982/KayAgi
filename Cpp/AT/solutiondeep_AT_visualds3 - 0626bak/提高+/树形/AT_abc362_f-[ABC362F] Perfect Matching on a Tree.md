# 题目信息

# [ABC362F] Perfect Matching on a Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc362/tasks/abc362_f

$ N $ 頂点の木 $ T $ が与えられます。$ T $ の頂点には $ 1 $ から $ N $ の番号がついており、 $ i\,(1\leq\ i\ \leq\ N-1) $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結んでいます。

$ T $ を用いて、$ N $ 頂点の完全グラフ $ G $ を次のように定めます。

- $ G $ の頂点 $ x $ と頂点 $ y $ の間の辺の重み $ w(x,y) $ を、$ T $ における頂点 $ x $ と頂点 $ y $ の間の最短距離とする
 
$ G $ の**最大重み最大マッチング**を一つ求めてください。すなわち、$ \lfloor\ N/2\ \rfloor $ 個の頂点のペアの集合 $ M=\{(x_1,y_1),(x_2,y_2),\dots,(x_{\lfloor\ N/2\ \rfloor},y_{\lfloor\ N/2\ \rfloor})\} $ であって、各頂点 $ 1,2,\dots,\ N $ が $ M $ に現れる回数がたかだか $ 1 $ 回であるようなもののうち、 $ \displaystyle\ \sum_{i=1}^{\lfloor\ N/2\ \rfloor}\ w(x_i,y_i) $ が最大であるものを一つ求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i\ <\ v_i\ \leq\ N $
- 入力されるグラフは木である
- 入力はすべて整数
 
### Sample Explanation 1

$ T $ において、頂点 $ 2,4 $ 間の距離は $ 2 $、頂点 $ 1,3 $ 間の距離は $ 2 $ なので、マッチング $ \{(2,4),(1,3)\} $ の重みは $ 4 $ です。重みが $ 4 $ より大きいマッチングは存在しないので、これが最大重み最大マッチングの一つです。他にも、 ``` 2 3 1 4 ``` などを出力しても正解になります。

### Sample Explanation 2

$ T $ において、頂点 $ 1,3 $ 間の距離は $ 2 $ なので、マッチング $ \{(1,3)\} $ の重みは $ 2 $ です。重みが $ 2 $ より大きいマッチングは存在しないので、これが最大重み最大マッチングの一つです。他にも、 ``` 3 1 ``` を出力しても正解になります。

## 样例 #1

### 输入

```
4

1 2

2 3

3 4```

### 输出

```
2 4

1 3```

## 样例 #2

### 输入

```
3

1 2

2 3```

### 输出

```
1 3```

# AI分析结果



**唯一算法分类**：树的重心与贪心算法

---

### **题解思路与核心难点**

**核心思路**：
1. **路径交点必为重心**：所有匹配对的路径必须相交于树的重心，否则存在更优交换。
2. **重心性质**：以重心为根时，各子树大小 ≤ ⌊n/2⌋，确保能完全配对。
3. **贪心配对**：每次从不同子树中选点，优先处理较大子树，避免剩余无法配对。

**算法流程**：
1. **找重心**：通过两次DFS确定树的重心。
2. **收集子树节点**：以重心为根，将各子树的节点存入不同列表。
3. **优先队列配对**：维护子树大小的最大堆，每次取两个最大的子树各选一个点配对。

**解决难点**：
- 如何确保所有路径相交：通过重心性质保证。
- 高效配对实现：优先队列动态维护子树规模。

---

### **题解评分（≥4星）**

1. **BrotherCall（5星）**  
   - 思路清晰，证明充分，代码使用优先队列实现高效配对。
   - 关键亮点：数学归纳证明路径相交，优先队列维护子树规模。

2. **zrl123456（4星）**  
   - DFS序直接配对，时间复杂度更低，代码简洁。
   - 关键亮点：DFS序构造配对，无需复杂数据结构。

3. **Engulf（4星）**  
   - 代码实现明确，优先队列操作详细。
   - 关键亮点：直观的子树管理，适合理解。

---

### **最优思路/技巧提炼**

1. **重心性质**：所有子树大小 ≤ ⌊n/2⌋，确保配对可行性。
2. **DFS序配对**：将节点按DFS序排列，直接前后半配对，保证不同子树。
3. **优先队列优化**：动态维护子树规模，避免剩余点无法配对。

---

### **同类型题/算法套路**

- **树的重心应用**：如会议选址（最大化覆盖效率）。
- **贪心构造配对**：如二分图最大匹配中的贪心策略。

**推荐题目**：
1. [P1395 会议](https://www.luogu.com.cn/problem/P1395)（树的重心）
2. [CF685B Kay and Snowflake](https://codeforces.com/problemset/problem/685/B)（子树重心）
3. [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)（加权重心）

---

### **代码实现（核心逻辑）**

**BrotherCall的核心代码**：
```cpp
priority_queue<pair<int, int>> pq;
// 收集各子树节点到sub数组
for (auto v : g[centroid]) {
    dfs(v, centroid, v);
    pq.push({sub[v].size(), v});
}
// 贪心配对
while (pq.size() >= 2) {
    auto a = pq.top(); pq.pop();
    auto b = pq.top(); pq.pop();
    cout << sub[a.second].back() << " " << sub[b.second].back() << endl;
    sub[a.second].pop_back();
    sub[b.second].pop_back();
    if (!sub[a.second].empty()) pq.push(a);
    if (!sub[b.second].empty()) pq.push(b);
}
```

---

### **可视化与算法演示**

**动画设计**：
1. **像素化树结构**：用Canvas绘制树，节点为彩色方块，边为线条。
2. **重心高亮**：红色标记重心，子树用不同颜色区分。
3. **配对过程**：
   - 每次从优先队列中弹出两个子树，动态显示队列状态。
   - 配对时连线闪烁，播放“匹配成功”音效。
4. **自动演示**：按步执行，用户可暂停/调速。

**复古游戏化**：
- **音效**：匹配时8-bit音效，背景音乐循环。
- **积分系统**：每成功配对一对得10分，连击加成。

---

### **个人心得摘录**

- **调试教训**：未考虑奇数节点时需单独处理根节点，导致WA。
- **思维突破**：通过路径相交性反推重心是关键，而非直接构造。

---

**总结**：通过树的重心性质与贪心配对，结合优先队列或DFS序实现高效构造，是解决此类问题的通用思路。

---
处理用时：79.64秒
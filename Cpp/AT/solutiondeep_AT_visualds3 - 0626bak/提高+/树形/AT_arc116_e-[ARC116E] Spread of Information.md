# 题目信息

# [ARC116E] Spread of Information

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc116/tasks/arc116_e

高橋国には $ N $ 箇所の町があり、それぞれ町 $ 1 $ 、町 $ 2 $、 $ \ldots $ 、町 $ N $ と名付けられています。 この国には $ N-1 $ 本の道があり、 $ i $ 本目の道は 町 $ u_i $ と町 $ v_i $ を双方向に結びます。任意の $ 2 $ つの町 $ a $, $ b $ について、いくつかの道を通ることにより、町 $ a $ から町 $ b $ へ移動することが出来ます。

高橋国王は、ある情報を国土全体に流そうとしています。多忙な高橋国王は、 $ K $ 箇所までの町にしか直接情報を伝達することが出来ません。

高橋国王の情報伝達が終わった瞬間を時刻 $ 0 $ とします。 $ t\ =\ 1,\ 2,\ 3,\ \cdots $ について、以下の現象が発生します。

- $ 1 $ 本の道で直接結ばれている町の組 $ a $, $ b $ について、 時刻 $ t-0.5 $ に町 $ a $ に情報が伝わっており、町 $ b $ に情報が伝わっていないとき、 時刻 $ t $ に町 $ b $ にも情報が伝わる。

高橋国王は $ K $ 箇所の連絡先を適切に選択し、全ての町に情報が伝わるまでに掛かる時間を最小化しようと考えています。最小値を答えてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ K\ <\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 任意の $ 2 $ つの町 $ a $, $ b $ について、いくつかの道を通ることにより、町 $ a $ から町 $ b $ へ移動することが出来る。

### Sample Explanation 1

高橋国王が町 $ 2 $ と町 $ 4 $ に直接情報を伝達した場合、町 $ 1 $ 、 $ \ldots $ 、町$ 5 $ に初めて情報が伝わる時刻は、それぞれ $ 1,\ 0,\ 1,\ 0,\ 1 $ となります。このとき、 国土全体に情報が広まるのは時刻 $ 1 $ であり、これが達成可能な最小値であることが証明出来ます。

## 样例 #1

### 输入

```
5 2

1 2

2 3

3 4

4 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 1

1 2

1 3

1 4

5 4```

### 输出

```
2```

## 样例 #3

### 输入

```
20 3

2 15

6 5

12 1

7 9

17 2

15 5

2 4

17 16

12 2

8 17

17 19

18 11

20 8

20 3

13 9

11 10

11 20

14 8

11 7```

### 输出

```
3```

# AI分析结果



# 算法分类  
**二分答案 + 树形贪心/DP**

---

## 题解思路与核心难点分析  
### 核心思路  
所有题解均采用 **二分答案 + 贪心验证** 框架：  
1. **二分答案**：答案范围在树的直径内，二分尝试时间 `mid`  
2. **验证逻辑**：检查是否存在一种选点方案，使得所有节点到最近关键点距离 ≤ `mid`，且关键点数量 ≤ `K`  
3. **贪心实现**：  
   - 自底向上遍历树（DFS回溯），维护两个关键变量：  
     - `f[x]`：以 `x` 为根的子树中，最远未被覆盖的节点到 `x` 的距离  
     - `g[x]`：以 `x` 为根的子树中，最近关键点到 `x` 的距离  
   - 根据子节点状态更新父节点，通过条件判断是否需要在 `x` 处放置关键点  

### 解决难点  
1. **状态转移条件**：  
   - **必须放置关键点**：当 `f[x] = mid` 时，必须选 `x`（否则无法覆盖最远节点）  
   - **完全覆盖**：若 `f[x] + g[x] ≤ mid`，子树已覆盖，无需处理  
   - **向上传递覆盖需求**：若 `g[x] > mid`，`x` 自身未被覆盖，需父节点处理  

2. **边界处理**：  
   - 根节点可能未被覆盖，需额外判断  
   - 初始化 `f[x] = -∞`, `g[x] = +∞` 避免干扰  

---

## 题解评分 (≥4星)  
1. **hzoi_Shadow（5星）**  
   - **亮点**：代码结构清晰，变量命名直观，注释详细  
   - **核心代码**：  
     ```cpp
     void dfs(int x,int fa,int k) {
       f[x] = -INF, g[x] = INF;
       for (遍历子节点) {
         dfs(y, x, k);
         f[x] = max(f[x], f[y] + 1); // 更新最远未覆盖
         g[x] = min(g[x], g[y] + 1); // 更新最近关键点
       }
       if (g[x] > k) f[x] = max(f[x], 0); // 自身未被覆盖
       if (f[x] + g[x] <= k) f[x] = -INF; // 子树全覆盖
       if (f[x] == k) { // 必须选点
         f[x] = -INF;
         g[x] = 0;
         sum++;
       }
     }
     ```

2. **Kketchup（4星）**  
   - **亮点**：代码简洁，状态转移逻辑明确  
   - **优化**：使用 `-1e9` 和 `1e9` 代替具体数值，提升可读性  

3. **Charlie_ljk（4星）**  
   - **亮点**：结合将军令题解对比，帮助理解  
   - **关键处理**：根节点特判逻辑清晰  

---

## 最优思路提炼  
1. **二分框架**：将最优化问题转化为判定性问题  
2. **贪心策略**：在最深未被覆盖节点的 `mid` 级祖先处选点，最大化覆盖范围  
3. **状态压缩**：通过 `f` 和 `g` 动态维护子树覆盖情况，避免重复计算  

---

## 同类题目推荐  
1. [P3942 将军令](https://www.luogu.com.cn/problem/P3942)（树的最小覆盖）  
2. [P2279 [HNOI2003] 消防局的设立](https://www.luogu.com.cn/problem/P2279)（固定半径覆盖）  
3. [P3523 [POI2011] DYN-Dynamite](https://www.luogu.com.cn/problem/P3523)（平衡覆盖与成本）  

---

## 可视化设计  
### 算法演示方案  
1. **树形结构展示**：  
   - 使用 Canvas 绘制树形结构，节点按层次排列  
   - 当前操作节点高亮（如红色边框）  

2. **状态可视化**：  
   - **未覆盖节点**：灰色  
   - **已覆盖区域**：绿色渐变（半径 `mid`）  
   - **关键点**：金色闪烁  

3. **动画流程**：  
   - **步骤1**：展示当前二分值 `mid`  
   - **步骤2**：DFS遍历树，实时更新 `f` 和 `g` 的数值显示  
   - **步骤3**：在满足 `f[x] = mid` 时播放音效并标记关键点  

### 复古像素风格实现  
```javascript
// 示例：像素风格节点绘制
function drawNode(x, y, state) {
  ctx.fillStyle = stateColors[state]; // 状态对应颜色
  ctx.fillRect(x*50, y*50, 40, 40);   // 像素方块
  if (state === 'SELECTED') {         // 关键点特效
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(x*50+8, y*50+8, 24, 24);
  }
}
```

### 音效设计  
- **关键点放置**：8-bit "叮" 音效  
- **覆盖完成**：上升音阶  
- **二分调整**：左右声道平衡表示 `mid` 增减  

---

## 核心代码实现  
```cpp
bool check(int mid) {
  cnt = 0;
  dfs(1, 0, mid);
  if (f[1] >= 0) cnt++; // 根节点特判
  return cnt <= K;
}

void dfs(int u, int fa, int lim) {
  f[u] = -INF, g[u] = INF;
  for (int v : tree[u]) {
    if (v == fa) continue;
    dfs(v, u, lim);
    f[u] = max(f[u], f[v] + 1);
    g[u] = min(g[u], g[v] + 1);
  }
  if (f[u] + g[u] <= lim) f[u] = -INF;
  if (g[u] > lim) f[u] = max(f[u], 0);
  if (f[u] == lim) {
    f[u] = -INF;
    g[u] = 0;
    cnt++;
  }
}
```

---
处理用时：74.52秒
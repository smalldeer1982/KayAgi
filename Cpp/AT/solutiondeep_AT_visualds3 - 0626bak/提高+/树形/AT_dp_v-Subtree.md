# 题目信息

# Subtree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_v

$ N $ 頂点の木があります。 頂点には $ 1,\ 2,\ \ldots,\ N $ と番号が振られています。 各 $ i $ ($ 1\ \leq\ i\ \leq\ N\ -\ 1 $) について、$ i $ 番目の辺は頂点 $ x_i $ と $ y_i $ を結んでいます。

太郎君は、各頂点を白または黒で塗ることにしました。 このとき、どの黒い頂点からどの黒い頂点へも、黒い頂点のみを辿って到達できるようにします。

正整数 $ M $ が与えられます。 各 $ v $ ($ 1\ \leq\ v\ \leq\ N $) について、次の質問に答えてください。

- 頂点 $ v $ が黒であるような頂点の色の組合せは何通りか？ $ M $ で割った余りを求めよ。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 2\ \leq\ M\ \leq\ 10^9 $
- $ 1\ \leq\ x_i,\ y_i\ \leq\ N $
- 与えられるグラフは木である。

### Sample Explanation 1

頂点の色の組合せは次図の $ 7 $ 通りです。 このうち、頂点 $ 1 $ が黒であるようなものは $ 3 $ 通り、頂点 $ 2 $ が黒であるようなものは $ 4 $ 通り、頂点 $ 3 $ が黒であるようなものは $ 3 $ 通りです。 !\[\](https://img.atcoder.jp/dp/subtree\_0\_muffet.png)

### Sample Explanation 4

答えを $ M $ で割った余りを出力することを忘れずに。

## 样例 #1

### 输入

```
3 100

1 2

2 3```

### 输出

```
3

4

3```

## 样例 #2

### 输入

```
4 100

1 2

1 3

1 4```

### 输出

```
8

5

5

5```

## 样例 #3

### 输入

```
1 100```

### 输出

```
1```

## 样例 #4

### 输入

```
10 2

8 5

10 8

6 5

1 5

4 8

2 10

3 6

9 2

1 7```

### 输出

```
0

0

1

1

1

0

1

0

1

1```

# AI分析结果



---

# Subtree 题解分析

## 唯一算法分类
**换根 DP**

---

## 题解思路与核心难点

### 核心思路
1. **两次 DFS 的换根 DP**：
   - **第一次 DFS**：计算每个节点作为根时的子树内方案数 `dp1`，公式为 `dp1[u] = ∏(dp1[v] + 1)`，其中 `v` 是子节点。
   - **第二次 DFS**：计算父方向贡献 `dp2`，公式为 `dp2[v] = dp2[u] * (前缀积 * 后缀积) + 1`，利用前缀积和后缀积避免除法。

2. **前缀积与后缀积优化**：
   - 预处理每个节点的兄弟节点的 `dp1[v]+1` 的前缀和后缀乘积，避免因模数非质数无法使用逆元的问题。

### 解决难点
- **兄弟节点乘积的高效计算**：通过 `O(n)` 预处理前缀积和后缀积，将 `O(n)` 的兄弟遍历优化为 `O(1)`。
- **换根时的状态转移**：父节点的贡献需结合兄弟子树与更上层节点，需动态维护乘积。

---

## 题解评分 (≥4星)

1. **zhlzt（5星）**
   - **亮点**：代码简洁，前缀/后缀积预处理清晰，变量命名规范。
   - **核心代码**：
     ```cpp
     void dfs1(int u, int fa) {
         dp1[u] = 1;
         vector<int> son; // 存储子节点
         for (int v : edge[u]) {
             if (v == fa) continue;
             dfs1(v, u);
             dp1[u] = 1LL * dp1[u] * (dp1[v] + 1) % mod;
             son.push_back(v);
         }
         // 前缀积
         int tmp = 1;
         for (int i = 0; i < son.size(); i++) {
             pre[son[i]] = tmp;
             tmp = 1LL * tmp * (dp1[son[i]] + 1) % mod;
         }
         // 后缀积
         tmp = 1;
         for (int i = son.size() - 1; i >= 0; i--) {
             suf[son[i]] = tmp;
             tmp = 1LL * tmp * (dp1[son[i]] + 1) % mod;
         }
     }
     ```

2. **FelFa_1414666（4.5星）**
   - **亮点**：详细注释和图示辅助理解，代码使用 `vector` 动态存储前缀/后缀积。
   - **核心代码**：
     ```cpp
     for (int i = 1; i < pre[s].size(); i++) 
         pre[s][i] = pre[s][i] * pre[s][i-1] % MOD;
     for (int i = suf[s].size() - 2; i >= 0; i--) 
         suf[s][i] = suf[s][i] * suf[s][i+1] % MOD;
     ```

3. **TKXZ133（4星）**
   - **亮点**：分治优化兄弟乘积，适合理解分治思想，但时间复杂度略高（O(n log n)）。

---

## 最优思路提炼
1. **换根 DP 框架**：两次 DFS 分别处理子树内和子树外的贡献。
2. **前缀/后缀积优化**：对兄弟节点的乘积进行预处理，避免除法。
3. **公式推导**：`dp2` 的转移需结合父节点贡献和兄弟乘积。

---

## 类似题目推荐
1. **P3478 [POI2008] STA-Station**（换根 DP 求最长路径）
2. **P3047 [USACO12FEB] Nearby Cows G**（换根 DP 统计子树外贡献）
3. **P1352 没有上司的舞会**（树形 DP 基础题）

---

## 可视化设计
### 核心算法演示
- **树形结构绘制**：以节点为中心展示 `dp1` 和 `dp2` 的值，子树部分用绿色高亮，父方向部分用蓝色。
- **前缀/后缀积动画**：在兄弟节点旁显示前缀（左→右）和后缀（右→左）的乘积过程，用不同颜色标记当前计算节点。
- **步进控制**：允许单步执行 DFS，观察 `dp1` 和 `dp2` 的更新过程。

### 复古游戏化效果
- **像素风格树**：用 8-bit 风格绘制树节点，每次计算节点时播放“滴答”音效。
- **自动演示模式**：AI 自动遍历树，完成两次 DFS，背景音乐为 Chiptune 风格循环。
- **积分系统**：每正确计算一个节点的 `dp1` 和 `dp2` 获得 10 分，错误时播放失败音效。

---

## 核心代码片段
```cpp
// 前缀/后缀积预处理（zhlzt 题解）
void dfs1(int u, int fa) {
    dp1[u] = 1;
    vector<int> son;
    for (int v : edge[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        son.push_back(v);
        dp1[u] = 1LL * dp1[u] * (dp1[v] + 1) % mod;
    }
    int tmp = 1;
    for (int i = 0; i < son.size(); i++) { // 前缀
        pre[son[i]] = tmp;
        tmp = 1LL * tmp * (dp1[son[i]] + 1) % mod;
    }
    tmp = 1;
    for (int i = son.size()-1; i >= 0; i--) { // 后缀
        suf[son[i]] = tmp;
        tmp = 1LL * tmp * (dp1[son[i]] + 1) % mod;
    }
}
```

---

## 总结
通过换根 DP 和前缀/后缀积优化，将问题的时间复杂度控制在 `O(n)`，是树形动态规划的经典应用。关键点在于对兄弟节点贡献的高效计算和状态转移的巧妙设计。

---
处理用时：82.22秒
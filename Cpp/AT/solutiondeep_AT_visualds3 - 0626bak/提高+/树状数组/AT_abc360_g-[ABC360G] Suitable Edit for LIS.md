# 题目信息

# [ABC360G] Suitable Edit for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc360/tasks/abc360_g

長さ $ N $ の整数列 $ A $ が与えられます。高橋くんは、 $ 1 $ 回だけ次の操作をします。

- $ 1 $ 以上 $ N $ 以下の整数 $ x $ と、任意の整数 $ y $ を選ぶ。$ A_x $ を $ y $ に置き換える。
 
操作をした後の $ A $ の最長増加部分列の長さとしてあり得る最大の値を求めてください。

  最長増加部分列とは？ 列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

 列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
 
### Sample Explanation 1

与えられた数列 $ A $ の LIS の長さは $ 2 $ です。例えば $ A_1 $ を $ 1 $ に置き換えると、操作後の $ A $ の LIS の長さが $ 3 $ になり、これが最大です。

## 样例 #1

### 输入

```
4

3 2 2 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5

4 5 3 6 7```

### 输出

```
4```

# AI分析结果



---

## 算法分类：动态规划 + 树状数组/线段树优化

### 核心思路与难点分析
**核心问题**：通过一次修改操作最大化数组的 LIS 长度  
**关键思路**：  
1. **预处理前后缀 LIS 长度**  
   分别计算每个位置的前缀 LIS 长度 `f[i]` 和后缀 LIS 长度 `g[i]`  
2. **枚举修改点**  
   对每个位置 `i` 考虑三种情况：  
   - 修改 `i` 之前的元素，拼接后续 LIS  
   - 修改 `i` 之后的元素，拼接前序 LIS  
   - 修改 `i` 本身，合并前后 LIS  
3. **数据结构优化**  
   使用树状数组或线段树快速查询区间最大值，实现 O(n log n) 复杂度  

**解决难点**：  
- **拼接条件**：需要满足 `a[j] < a[i]-1` 才能合并前后 LIS  
- **离散化处理**：由于数值范围大，需离散化压缩值域  
- **边界处理**：首尾元素的修改需特殊考虑  

---

### 最优思路提炼（Milthm 方法）
```python
# 预处理前缀 LIS
for i in 1..n:
    f[i] = max(f[j] for j < i and a[j] < a[i]) + 1
# 预处理后缀 LIS
for i in n..1:
    g[i] = max(g[j] for j > i and a[j] > a[i]) + 1
# 合并答案
ans = max(
    max(f) + 1,           # 末尾添加元素
    max(g) + 1,           # 开头添加元素
    max(f[i] + g[j] + 1)  # 拼接前后 LIS
)
```

---

### 题解评分（≥4星）
1. **Milthm（5星）**  
   - 思路清晰，树状数组实现简洁  
   - 利用 `unordered_map` 避免离散化  
   - 完整处理三种情况  

2. **ma_niu_bi（4星）**  
   - 线段树实现规范易读  
   - 离散化处理严谨  
   - 包含详细边界注释  

3. **Halberd_Cease（4星）**  
   - 双数组动态维护巧妙  
   - 无数据结构依赖，代码极简  
   - 时间复杂度最优  

---

### 同类型题目推荐
1. **洛谷 P1020**：导弹拦截（LIS 基础模板）  
2. **LeetCode 354**：俄罗斯套娃信封问题（二维 LIS）  
3. **CodeForces 1350B**：Orac and Models（树形 LIS）  

---

### 个人心得摘录
> "离散化时需包含 a[i]-1 和 a[i]+1，否则最后一个点 WA" —— incra  
> "修改点不一定在 LIS 内部，贪心选择拼接位置更优" —— Milthm  

---

### 可视化算法演示
**动画设计**：  
1. **分屏显示**  
   - 左屏：原数组，高亮当前处理位置  
   - 右屏：树状数组结构，动态更新查询范围  

2. **关键步骤**  
   - 红色闪烁：当前处理的元素 `a[i]`  
   - 绿色流动线：前缀 LIS 的传递过程  
   - 黄色箭头：树状数组的查询路径  

3. **复古像素风格**  
   - 8-bit 音效：每次树状数组更新时播放 "哔" 声  
   - 像素网格：用不同颜色块表示数组元素值  

**交互功能**：  
- 速度滑块：调节动画播放速度  
- 单步执行：观察每个位置的决策细节  
- 自动演示：AI 自动遍历所有可能修改点  

---

### 核心代码实现（Milthm 方法）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5,inf=1e9+7;
unordered_map<int,int> c;
int n,a[N],l[N],r[N],ans;

void add(int x,int k){
    while(x<=inf) c[x]=max(c[x],k), x+=x&-x;
}
int ask(int x){
    int ans=0;
    while(x) ans=max(ans,c[x]), x-=x&-x;
    return ans;
}

int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    // 计算前缀LIS (r数组)
    for(int i=1;i<=n;i++){
        r[i]=ask(a[i]-1)+1;
        add(a[i],r[i]);
        ans=max(ans, r[i]+(i!=n)); // 末尾可加元素
    }
    
    c.clear();
    // 计算后缀LIS (l数组)
    for(int i=n;i>=1;i--){
        l[i]=ask(inf-a[i]-1)+1;
        add(inf-a[i],l[i]);
        ans=max(ans, l[i]+(i!=1)); // 开头可加元素
    }
    
    c.clear();
    // 合并前后LIS
    for(int i=1;i<=n;i++){
        int k=ask(a[i+1]);
        ans=max(ans, l[i+1]+k+1);
        add(a[i]+2, r[i]); // 允许a[i]修改为a[i]+1
    }
    cout<<ans;
}
```

---

**关键解释**：  
- `r[i]` 存储以 `i` 结尾的前缀 LIS 长度  
- `l[i]` 存储以 `i` 开头的后缀 LIS 长度  
- 第三次遍历时，通过 `a[i]+2` 保证修改后的值可以连接前后序列

---
处理用时：90.05秒
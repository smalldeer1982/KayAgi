# 题目信息

# [ABC382E] Expansion Packs

## 题目描述

给定无数包卡牌，每一包卡牌有 $N$ 张卡，对于每一张卡 $i$，有百分之 $P_i$ 的概率是稀有卡，否则是普通卡。现在，你要一直开包，直到你有 $X$ 张稀有卡，求你开包的期望次数。

## 说明/提示

- $1 \le N \le 5000$

- $1 \le X \le 5000$

- $1 \le P_i \le 100$


UID：928955

## 样例 #1

### 输入

```
2 2

50 100```

### 输出

```
1.5000000000000000```

## 样例 #2

### 输入

```
2 3

40 60```

### 输出

```
3.2475579530543811```

## 样例 #3

### 输入

```
6 3

10 33 33 10 100 10```

### 输出

```
1.8657859189536100```

# AI分析结果



## 算法分类
动态规划、期望DP

---

## 题解思路与解决难点

### 核心思路
1. **概率预处理**：计算每包卡牌中获得恰好 `j` 张稀有卡的概率 `g[j]`，类似背包问题的动态规划。
2. **期望递推**：定义 `f[i]` 为获得至少 `i` 张稀有卡的期望次数。通过递推公式 `f[i] = (1 + Σf[i-j]*g[j]) / (1-g[0])` 逐步计算。

### 解决难点
- **自指处理**：当开包得到0张稀有卡时，当前期望次数会包含自身，需通过移项解决。
- **高效计算**：通过倒序背包预处理概率，将时间复杂度优化到 O(N² + NX)。
- **精度控制**：使用 `long double` 提升浮点计算精度，避免累积误差。

---

## 题解评分（≥4星）

1. **mayike (4.5星)**
   - 思路清晰，代码简洁。
   - 关键点：推导全期望公式，处理自指项。
   - 代码亮点：滚动数组优化空间。

2. **刘梓轩2010 (4星)**
   - 详细注释推导过程。
   - 代码规范，变量命名清晰。
   - 实现中显式处理 `max(0,i-j)` 边界。

3. **sxwgysh (4星)**
   - 数学符号与代码对应明确。
   - 使用 `max(0,i-j)` 处理边界条件。
   - 预处理部分用二维数组便于理解。

---

## 最优思路提炼
1. **概率背包**  
   - 倒序遍历更新概率数组，避免覆盖未更新的值。
   ```cpp
   for (int i=1; i<=n; i++) 
     for (int j=n; j>=1; j--)
       g[j] = g[j]*(1-p[i]) + g[j-1]*p[i];
   ```
   
2. **期望递推移项**  
   - 分离 j=0 的情况，解决自指问题：
   ```math
   f[i] = \frac{1 + \sum_{j=1}^n f[\max(i-j,0)] \cdot g[j]}{1 - g[0]}
   ```

---

## 同类型题目
1. **期望递推**：[SP1026 FAVDICE - Favorite Dice](https://www.luogu.com.cn/problem/SP1026)
2. **概率背包**：[CF518D Ilya and Escalator](https://codeforces.com/problemset/problem/518/D)
3. **倒序DP优化**：[P1850 换教室](https://www.luogu.com.cn/problem/P1850)

---

## 可视化设计
### 核心动画流程
1. **概率背包更新**  
   - **网格绘制**：在 Canvas 中绘制 N×N 网格，每格代表 `g[i][j]`。
   - **颜色渐变**：绿色表示概率增加，红色表示减少。
   - **步进演示**：每添加一张卡牌，动态更新网格颜色。

2. **期望递推过程**  
   - **进度条**：横向进度条表示当前计算的 `i`（目标稀有卡数）。
   - **柱状图**：每个柱子表示 `f[i]` 的值，颜色随值大小渐变。
   - **高亮操作**：计算 `f[i]` 时，用闪烁效果标记涉及的 `f[i-j]`。

### 复古像素风格
- **8位音效**：开包时播放 "哔" 声，计算完成时播放 "叮" 声。
- **像素字体**：使用 Press Start 2P 字体，所有数字显示为 8×8 像素。
- **自动演示**：按空格键切换手动/自动模式，自动模式下算法以 2 步/秒执行。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5005;
long double g[N], f[N], p[N];

int main() {
    int n, x; cin >> n >> x;
    for (int i=1; i<=n; i++) {
        int tmp; cin >> tmp;
        p[i] = tmp / 100.0L;
    }
    
    // 计算每包获得j张稀有卡的概率g[j]
    g[0] = 1;
    for (int i=1; i<=n; i++)
        for (int j=n; j>=1; j--)
            g[j] = g[j]*(1-p[i]) + g[j-1]*p[i];
    
    // 递推期望
    for (int i=1; i<=x; i++) {
        f[i] = 1;
        for (int j=1; j<=n; j++)
            if (i >= j) f[i] += f[i-j] * g[j];
        f[i] /= (1 - g[0]);
    }
    
    cout << fixed << setprecision(12) << f[x];
}
```

---

## 个人心得
- **精度陷阱**：某题解因使用 `float` 导致精度不足，改用 `long double` 后通过。
- **边界处理**：初始条件 `g[0]=1` 容易遗漏，需仔细验证概率总和为1。
- **思维误区**：曾误将至少X张视为恰好X张，导致递推式错误。

---
处理用时：94.45秒
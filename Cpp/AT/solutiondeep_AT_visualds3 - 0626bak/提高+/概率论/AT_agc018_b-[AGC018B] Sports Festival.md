# 题目信息

# [AGC018B] Sports Festival

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc018/tasks/agc018_b

高橋君は、スポーツ大会を開こうと考えています。 スポーツ大会に参加するのは、$ 1 $ から $ N $ までの番号のついた $ N $ 人の人です。 また、大会で行うスポーツとして、$ 1 $ から $ M $ までの番号のついた $ M $ 個のスポーツが候補に上がっています。 高橋君は、これらの中から $ 1 $ つ以上（全てでもよい）のスポーツを選んで、スポーツ大会で実施します。

高橋君は、人 $ i $ が、$ j $ 番目に好きなスポーツが $ A_{ij} $ であることを知っています。 それぞれの人は、スポーツ大会で実施されるスポーツのうち、自分が最も好きなスポーツだけに参加し、他のスポーツには参加しません。

高橋君は、一つのスポーツにたくさんの人が集まり過ぎることを懸念しています。 そこで高橋君は、スポーツ大会で実施するスポーツをうまく選んで、最も多くの人が参加しているスポーツの参加人数を最小化したくなりました。 最も多くの人が参加しているスポーツの参加人数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ M\ \leq\ 300 $
- $ A_{i1} $ , $ A_{i2} $ , $ ... $ , $ A_{iM} $ は、$ 1 $ から $ M $ の順列である。

### Sample Explanation 1

スポーツ $ 1 $,$ 3 $,$ 4 $ を実施することにすると、人 $ 1 $ はスポーツ $ 1 $ に、人 $ 2 $ はスポーツ $ 3 $ に、 人 $ 3 $ はスポーツ $ 3 $ に、人 $ 4 $ はスポーツ $ 4 $ に参加します。 このとき、参加人数が最大のスポーツはスポーツ $ 3 $ で、その参加人数 $ 2 $ 人です。 また、参加人数が最大のスポーツの参加人数が $ 1 $ 人になるような方法は存在しないので、この例の答えは $ 2 $ になります。

### Sample Explanation 2

全員の好みが一致しているので、どうやっても一つのスポーツに $ 3 $ 人集まってしまいます。 よってこの例の答えは $ 3 $ です。

## 样例 #1

### 输入

```
4 5

5 1 3 4 2

2 5 3 1 4

2 3 1 4 5

2 5 4 3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

2 1 3

2 1 3

2 1 3```

### 输出

```
3```

# AI分析结果



# AGC018B Sports Festival 题解分析

## 算法分类
**贪心算法**

---

## 题解思路与难点解析

### 核心思路
所有题解均采用**贪心策略**，核心流程为：
1. 初始状态选择所有项目
2. 统计各项目参与人数
3. 删除当前参与人数最多的项目
4. 重复步骤2-3直到只剩一个项目
5. 记录每次删除后的最大值，取最小结果

### 算法要点
1. **贪心正确性证明**：若保留当前最大项目，该项目的参与人数无法减少。每次必须删除当前最大值对应的项目才能获得更优解。
2. **指针优化**：维护每行的选择指针（如`pos[i]`），当某项目被删除时，只需调整受影响用户的指针，避免全量遍历。
3. **复杂度优化**：通过指针维护将时间复杂度优化至O(NM)，未优化版本为O(NM²)

### 解决难点
1. **动态选择更新**：在删除项目后，需要快速确定每个用户新的选择目标
2. **高效统计**：避免每次重新计算所有用户的选择，通过增量更新优化性能

---

## 题解评分 (≥4星)

### 五星题解
1. **Ebola（赞6）**
   - **亮点**：引入指针优化，时间复杂度最优；代码结构清晰，变量命名合理
   - **核心代码**：
     ```cpp
     while(vis[A[i][pos[i]]]) pos[i]++; // 指针跳跃式推进
     if(cnt[A[i][pos[i]]] > mx) cc = A[i][pos[i]], mx = cnt[cc]; // 动态统计最大值
     ```

2. **Umbrella_Leaf（赞4）**
   - **亮点**：数学归纳法严谨证明贪心正确性；使用`now[i]`记录用户选择层级
   - **优化点**：增量更新计数数组，避免全量重置

3. **Autream（赞3）**
   - **亮点**：明确指出支持O(N³)暴力；代码简洁适合快速理解
   - **不足**：未使用指针优化，复杂度较高

---

## 最优思路提炼

### 关键技巧
1. **贪心删减策略**：数学归纳保证每次删除当前最大值项目的必要性
2. **指针跳跃优化**：
   ```cpp
   // 维护每行的当前选择指针
   for(int i=1; i<=n; i++)
       while(vis[a[i][pos[i]]]) pos[i]++;
   ```
3. **增量计数**：仅更新受删除操作影响的用户选择

### 同类型题套路
- **最大值最小化**：通过逐步消除当前最大值的策略
- **动态调整选择**：维护用户/元素的当前状态指针
- 相似题目：P2899 [USACO08JAN]Cell Phone Network G（树形DP+贪心）、P2216 [HAOI2007]理想的正方形（滑动窗口+单调队列）

---

## 推荐练习
1. **P2899** - 树的最小支配集（贪心策略）
2. **P2216** - 二维区间最值（滑动窗口优化）
3. **P1849** - 贪心+优先队列应用

---

## 个人心得摘录
> "楼下那位没有维护每行的指针，复杂度比我多一个n" —— Ebola  
> "调试发现必须维护指针跳跃，否则TLE" —— wjr_jok  
> "突然意识到删除非最大值项目无法改变当前最大值" —— M_WC1S_M0

---

## 可视化算法演示设计

### 核心动画流程
```javascript
// 伪代码示例
class Visualization {
  constructor() {
    this.projects = Array(M).fill().map((_,i) => ({
      id: i+1, 
      count: 0,
      active: true
    }));
    
    this.people = Array(N).fill().map((_,i) => ({
      pref: [...], 
      pointer: 0
    }));
  }

  step() {
    // 1. 统计当前各项目人数（红色高亮最大值）
    // 2. 标记删除最大值项目（爆炸动画）
    // 3. 更新受影响用户的指针（绿色箭头移动）
    // 4. 记录当前最大值到历史记录（折线图更新）
  }
}
```

### 复古像素风格设计
1. **视觉元素**：
   - 项目：16x16像素方块，颜色按ID区分
   - 人数：方块下方数字显示，高度随人数增长
   - 用户：Q版像素小人分布在所选项目下方

2. **交互功能**：
   - **暂停/继续**：Space键控制
   - **单步执行**：→键步进
   - **速度调节**：↑/↓键调整帧率

3. **音效设计**：
   - 项目删除：8-bit爆炸音效（短促"砰"声）
   - 指针移动：电子滴答声
   - 记录最小值：清脆金币声

---

## 核心代码实现
```cpp
// Ebola 题解的核心逻辑
int main() {
    // 初始化指针
    for(int i=1; i<=n; i++) pos[i] = 1;
    
    while(true) {
        int mx = 0, cc = 0;
        memset(cnt, 0, sizeof(cnt));
        
        // 统计当前选择
        for(int i=1; i<=n; i++) {
            while(vis[A[i][pos[i]]]) pos[i]++; // 关键优化点
            cnt[A[i][pos[i]]]++;
            if(cnt[A[i][pos[i]]] > mx) {
                mx = cnt[A[i][pos[i]]];
                cc = A[i][pos[i]];
            }
        }
        
        if(!mx) break;
        ans = min(ans, mx);
        vis[cc] = true; // 标记删除
        
        // 更新受影响指针
        for(int i=1; i<=n; i++)
            if(A[i][pos[i]] == cc) pos[i]++;
    }
}
```

---
处理用时：78.70秒
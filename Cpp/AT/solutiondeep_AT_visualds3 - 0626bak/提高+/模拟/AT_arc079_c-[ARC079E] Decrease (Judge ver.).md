# 题目信息

# [ARC079E] Decrease (Judge ver.)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc079/tasks/arc079_c

長さ $ N $ の非負整数列 $ a_i $ に対し、数列の最大値が $ N-1 $ 以下になるまで以下の操作を繰り返し行うことを考えます。なお、この操作はD問題で考える操作と同一です。

- 数列のうち最も大きい要素を求める、複数ある場合はどれか $ 1 $ つ選ぶ。この要素の値を $ N $ 減らす。これ以外の要素の値を $ 1 $ 増やす。

なお、この操作を行い続けると、いつかは数列の最大値が $ N-1 $ 以下になることが証明できます。

ここで、数列 $ a_i $ が与えられるので、何回操作を行うことになるかを求めてください。

## 说明/提示

### 制約

- $ 2\ ≦\ N\ ≦\ 50 $
- $ 0\ ≦\ a_i\ ≦\ 10^{16}\ +\ 1000 $

## 样例 #1

### 输入

```
4

3 3 3 3```

### 输出

```
0```

## 样例 #2

### 输入

```
3

1 0 3```

### 输出

```
1```

## 样例 #3

### 输入

```
2

2 2```

### 输出

```
2```

## 样例 #4

### 输入

```
7

27 0 0 0 0 0 0```

### 输出

```
3```

## 样例 #5

### 输入

```
10

1000 193 256 777 0 1 1192 1234567891011 48 425```

### 输出

```
1234567894848```

# AI分析结果



**唯一算法分类**：贪心

---

### **题解思路与解决难点**

1. **核心思路**  
   每次选取当前数组中的最大值，计算将其减至 $N-1$ 所需的最少操作次数 $k$，并批量处理这些操作。其他元素在每次操作中会被加 $k$ 次，从而将逐次模拟转化为批量处理，大幅减少循环次数。

2. **关键步骤与公式推导**  
   - **公式计算**：设当前最大值为 $x$，需满足 $x - k \cdot N \le N-1$，解得 $k = \lceil \frac{x - (N-1)}{N} \rceil$。题解中通过 $(x - N)/N + 1$ 实现向上取整。
   - **批量更新**：每次操作后，将最大值减去 $k \cdot N$，其他元素增加 $k$，避免逐次操作。

3. **难点对比**  
   - **暴力模拟**：逐次操作时间复杂度高，无法处理大数。
   - **贪心批量处理**：通过公式直接计算操作次数，时间复杂度降为 $O(K \cdot N)$（$K$ 为循环次数），适用于大数。

---

### **题解评分（≥4星）**

1. **封禁用户的题解（4星）**  
   - **亮点**：直接排序取最大值，代码简洁，公式推导清晰。
   - **代码**：通过排序和批量更新高效处理大数。

2. **Ferdina_zcjb的题解（4星）**  
   - **亮点**：类似思路，代码简洁，数学转换清晰。
   - **代码**：直接取模并更新其他元素，逻辑明确。

3. **WaterSun的题解（4星）**  
   - **亮点**：遍历数组找最大值，避免排序，时间复杂度更低。
   - **代码**：使用 `up` 函数计算向上取整，可读性强。

---

### **最优思路与技巧提炼**

- **贪心策略**：每次处理最大值，尽可能减少其值。
- **数学优化**：通过公式 $k = \lceil \frac{x - (N-1)}{N} \rceil$ 计算批量操作次数，避免逐次模拟。
- **数据结构**：无需复杂结构，直接遍历或排序即可高效实现。

---

### **同类型题与算法套路**

- **类似问题**：调整元素值使满足条件，贪心选择最大值/最小值。
- **通用解法**：优先处理对全局影响最大的元素，通过数学推导减少操作次数。

---

### **推荐题目**

1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)  
3. [P3817 小A的糖果](https://www.luogu.com.cn/problem/P3817)  

---

### **个人心得摘录**

- **调试教训**：公式推导需验证边界条件，如最大值为 $N$ 的倍数时是否正确。
- **优化感悟**：批量处理是减少时间复杂度的关键，避免陷入逐次模拟的陷阱。

---

### **可视化与算法演示**

1. **动画设计**  
   - **像素风格**：用 8 位色块表示数组元素，当前处理的最大值高亮为红色。
   - **操作演示**：显示公式计算 $k$ 的过程，其他元素批量增加 $k$ 的动画。
   - **音效**：每次操作播放“减法”音效，完成时播放成功音效。

2. **代码片段（关键逻辑）**  
   ```cpp
   while (true) {
       sort(a, a + n, greater<int>());
       if (a[0] < n) break;
       int k = (a[0] - (n - 1) - 1) / n + 1;
       ans += k;
       a[0] -= k * n;
       for (int i = 1; i < n; i++) a[i] += k;
   }
   ```

---

### **总结**

通过贪心策略和数学优化，将逐次操作转为批量处理，时间复杂度显著降低。核心在于正确推导操作次数公式，并结合排序或遍历高效实现。

---
处理用时：226.06秒
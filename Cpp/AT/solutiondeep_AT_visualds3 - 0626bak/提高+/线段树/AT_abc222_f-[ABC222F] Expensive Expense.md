# 题目信息

# [ABC222F] Expensive Expense

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc222/tasks/abc222_f

AtCoder 王国は $ N $ 個の街と $ N-1 $ 個の道路からなります。  
 街には 街 $ 1 $, 街 $ 2 $, $ \dots $, 街 $ N $ と番号がついています。道路にも同様に 道路 $ 1 $, 道路 $ 2 $, $ \dots $, 道路 $ N-1 $ と番号が付いています。 道路 $ i $ は街 $ A_i $ と $ B_i $ を双方向に結んでいて、通過するときに $ C_i $ の通行料がかかります。すべての異なる街の組 $ (i,\ j) $ に対して、道路を経由して街 $ i $ から街 $ j $ に行くことができます。

今、列 $ D\ =\ (D_1,\ D_2,\ \dots,\ D_N) $ が与えられます。 $ D_i $ は街 $ i $ を観光するときにかかる費用です。 このとき、街 $ i $ から街 $ j $ への旅費 $ E_{i,j} $ を、(同じ道を $ 2 $ 回以上使わずに街 $ i $ から街 $ j $ へ向かうときにかかる通行料の和) に $ D_{j} $ を足したものとして定めます。

- 厳密に言い換えると、$ i\ -\ j $ 間の最短パスを $ i\ =\ p_0,\ p_1,\ \dots,\ p_{k-1},\ p_k\ =\ j $ として、街 $ p_{l} $ と街 $ p_{l+1} $ を結ぶ道路の通行料を $ c_l $ と置いたときに $ E_{i,j}\ =\ D_j\ +\ \displaystyle\sum_{l=0}^{k-1}\ c_l $ と定義します。

すべての $ i $ に対して、街 $ i $ を始点として他の街へ旅行したときにありえる旅費の最大値を求めてください。

- 厳密に言い換えると、すべての $ i $ に対して $ \max_{1\ \leq\ j\ \leq\ N,\ j\ \neq\ i}\ E_{i,j} $ を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ B_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ D_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N) $
- 整数の組 $ (i,j) $ が $ 1\ \leq\ i\ \lt\ j\ \leq\ N $ を満たすならば、街 $ i $ から街 $ j $ へいくつかの道路を通ることで移動できる。
- 入力はすべて整数である。

### Sample Explanation 1

すべての街の順序つき組 $ (i,j) $ に対して $ E_{i,j} $ を計算すると次のようになります。 - $ E_{1,2}\ =\ 2\ +\ 2\ =\ 4 $ - $ E_{1,3}\ =\ 5\ +\ 3\ =\ 8 $ - $ E_{2,1}\ =\ 2\ +\ 1\ =\ 3 $ - $ E_{2,3}\ =\ 3\ +\ 3\ =\ 6 $ - $ E_{3,1}\ =\ 5\ +\ 1\ =\ 6 $ - $ E_{3,2}\ =\ 3\ +\ 2\ =\ 5 $

## 样例 #1

### 输入

```
3

1 2 2

2 3 3

1 2 3```

### 输出

```
8

6

6```

## 样例 #2

### 输入

```
6

1 2 3

1 3 1

1 4 4

1 5 1

1 6 5

9 2 6 5 3 100```

### 输出

```
105

108

106

109

106

14```

## 样例 #3

### 输入

```
6

1 2 1000000000

2 3 1000000000

3 4 1000000000

4 5 1000000000

5 6 1000000000

1 2 3 4 5 6```

### 输出

```
5000000006

4000000006

3000000006

3000000001

4000000001

5000000001```

# AI分析结果



**唯一算法分类**：树的直径

---

### 题解思路与算法要点

**核心思路**：  
题目要求每个节点到其他节点的最长路径。由于树的性质，最长路径的两个端点必然是树的直径端点。通过以下步骤解决：
1. **点权转边权**：每个节点添加虚拟节点（如 `i+n`），并连接边权为 `D_i` 的边。
2. **三次DFS**：  
   - 第一次DFS找到距离根最远的端点 `L`  
   - 以 `L` 为根第二次DFS找到另一端点 `R`  
   - 分别以 `L` 和 `R` 为根计算每个节点到它们的距离  
3. **最终答案**：对每个节点，取到 `L` 和 `R` 距离的最大值（若自身是端点则排除自己）。

**解决难点**：  
- **虚拟节点处理**：正确构建虚拟边以将点权转化为边权。  
- **端点排除**：当节点是直径端点时，需取另一端点距离（如 `i+n == L` 时只能取 `R` 的距离）。  

---

### 最优思路提炼与代码实现

**关键技巧**：  
1. **虚拟节点构造**：将点权转化为边权，将原树扩展为包含虚拟节点的结构。  
2. **三次DFS求直径**：快速确定最长路径的两个端点，避免暴力枚举所有路径。  
3. **距离预处理**：仅需三次DFS即可计算所有节点到两个端点的距离，时间复杂度 O(n)。  

**代码片段**：  
```cpp
void dfs(int u, int fa, int dis[]) {
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (v != fa) {
            dis[v] = dis[u] + e[i].w;
            dfs(v, u, dis);
        }
    }
}

// 主逻辑
dfs(1, 0, dis1); // 第一次DFS找左端点L
int L = max_element(dis1+1, dis1+2n) - dis1;
dfs(L, 0, disL); // 第二次DFS找右端点R
int R = max_element(disL+1, disL+2n) - disL;
dfs(R, 0, disR); // 计算到右端点的距离

// 输出答案：取max(disL[i], disR[i])，排除自身为端点的情况
```

---

### 题解评分（≥4星）

1. **题解作者：_zzzzzzy_（★★★★）**  
   - **亮点**：简洁高效，三次DFS直接求解，代码清晰。  
   - **改进点**：虚拟节点命名和端点判断可优化（如使用 `i+n` 可能混淆）。  

2. **题解作者：In_Memory（★★★★）**  
   - **亮点**：换根DP详细推导，维护前缀/后缀最大值避免重复计算。  
   - **改进点**：代码复杂度较高，维护多个数组易出错。  

3. **题解作者：GI录像机（★★★☆）**  
   - **亮点**：与直径法类似，但代码实现中存在边界问题（如端点判断逻辑）。  

---

### 可视化算法设计

**动画方案**：  
1. **像素风格绘制**：  
   - 使用 8 位风格显示树结构，虚拟节点用不同颜色标记（如绿色）。  
   - 每次DFS时，当前遍历的节点高亮为黄色，边权变化显示为红色数值。  

2. **关键步骤演示**：  
   - **第一次DFS**：从根节点出发，逐步扩展，动态更新距离数组，最终标记最远端点 `L`。  
   - **第二次DFS**：从 `L` 出发，高亮路径，找到 `R` 后显示直径路径。  
   - **最终计算**：对每个节点，并行显示到 `L` 和 `R` 的距离，取最大值时显示闪烁效果。  

3. **音效与交互**：  
   - **音效**：遍历时播放“滴”声，找到端点时播放胜利音效。  
   - **控制面板**：支持暂停/继续，调节动画速度，单步执行观察距离更新。  

---

### 类似题目推荐

1. **洛谷 P1099** [树网的核](https://www.luogu.com.cn/problem/P1099)  
   - 核心：树的直径性质与路径选择。  

2. **洛谷 P4381** [Island](https://www.luogu.com.cn/problem/P4381)  
   - 核心：基环树上的最长路径问题。  

3. **洛谷 P3174** [毛毛虫](https://www.luogu.com.cn/problem/P3174)  
   - 核心：树形DP求最长链与扩展结构。  

---

**个人心得**：  
- **虚拟节点技巧**：将点权转化为边权是树形问题的常见优化，需注意虚拟节点的连接方式。  
- **端点排除**：在最终输出时，需仔细判断节点是否为直径端点，避免自环路径。  

**代码完整实现**：参见题解作者 `_zzzzzzy_` 的代码，关键部分已提炼。

---
处理用时：76.86秒
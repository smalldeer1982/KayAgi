# 题目信息

# [ABC346G] Alone

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc346/tasks/abc346_g

整数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ が与えられます。

整数の組 $ (L,\ R) $ であって、以下の条件を満たすものの個数を求めてください。

- $ 1\ \leq\ L\ \leq\ R\ \leq\ N $
- $ A_L,\ A_{L\ +\ 1},\ \ldots,\ A_R $ の中に $ 1 $ 度だけ出現する数が存在する。より厳密には、ある整数 $ x $ が存在して、$ A_i\ =\ x $ かつ $ L\ \leq\ i\ \leq\ R $ を満たす整数 $ i $ の個数がちょうど $ 1 $ 個である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ N $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (L,\ R)\ =\ (1,\ 1),\ (1,\ 3),\ (1,\ 4),\ (2,\ 2),\ (2,\ 3),\ (2,\ 4),\ (3,\ 3),\ (3,\ 4),\ (3,\ 5),\ (4,\ 4),\ (4,\ 5),\ (5,\ 5) $ の $ 12 $ 個の整数の組が条件を満たします。

## 样例 #1

### 输入

```
5

2 2 1 2 1```

### 输出

```
12```

## 样例 #2

### 输入

```
4

4 4 4 4```

### 输出

```
4```

## 样例 #3

### 输入

```
10

1 2 1 4 3 3 3 2 2 4```

### 输出

```
47```

# AI分析结果



---

## 算法分类
**扫描线算法**

---

## 题解思路与核心难点

### 核心思路
1. **预处理每个元素的左右边界**：对于每个元素，找到其前驱和后继位置，确定其作为唯一出现时的有效区间。
2. **转换为矩形覆盖问题**：每个元素的贡献区间形成一个矩形，求所有矩形的面积并（避免重复统计）。
3. **扫描线算法**：通过事件排序和线段树动态维护区间覆盖，高效计算面积并。

### 解决难点
- **去重问题**：多个元素可能覆盖同一区间，需通过面积并排除重叠。
- **高效统计**：线段树支持区间修改与快速查询，确保时间复杂度为 $O(n \log n)$。

---

## 题解评分

### [Lotus_Land (★★★★★)]
- **思路清晰**：将问题转化为矩形面积并，扫描线算法直接应用。
- **代码简洁**：预处理左右边界后直接生成事件点，逻辑清晰。
- **高效性**：利用线段树维护区间覆盖，时间复杂度最优。

### [forgotmyhandle (★★★★☆)]
- **动态维护覆盖区间**：每次左移左端点时调整线段树，巧妙利用覆盖次数。
- **实用技巧**：线段树维护最小值统计非覆盖区域，减少查询复杂度。
- **代码可读性**：变量命名清晰，但逻辑稍显复杂。

---

## 最优思路提炼
1. **预处理左右边界**：  
   - 对每个元素 $a_i$，记录其前驱位置 $l_i$ 和后继位置 $r_i$。
   - 有效区间为 $[l_i, i]$（左端点范围）和 $[i, r_i]$（右端点范围）。
2. **扫描线处理矩形并集**：  
   - 每个矩形对应两个事件：下边界（加入覆盖）和上边界（移除覆盖）。
   - 事件排序后，用线段树动态维护当前覆盖的区间总长度，累加面积贡献。

---

## 同类型题推荐
1. **洛谷 P5490 【模板】扫描线**：矩形面积并的模板题。
2. **Codeforces 817F MEX Queries**：动态维护区间覆盖与查询。
3. **LeetCode 850. Rectangle Area II**：二维矩形覆盖问题。

---

## 代码核心实现

### Lotus_Land 代码片段（扫描线）
```cpp
for(int i=1; i<=n; i++) {
    l[i] = mp[a[i]] + 1; // 左边界：前驱位置+1
    mp[a[i]] = i;
}
mp.clear();
for(int i=n; i>=1; i--) {
    r[i] = (mp.count(a[i]) ? mp[a[i]] - 1 : n); // 右边界：后继位置-1
    mp[a[i]] = i;
}
// 生成扫描线事件
for(int i=1; i<=n; i++) {
    add_edge(l[i], r[i] + 1, i, 1);  // 下边界事件
    add_edge(l[i], r[i] + 1, i + 1, -1); // 上边界事件
}
sort(e + 1, e + edgecnt + 1, cmp); // 按高度排序
// 扫描线计算面积
for(int i=1; i<=edgecnt; i++) {
    modify(1, 1, n, e[i].ll, e[i].rr-1, e[i].ff);
    ans += 1LL * tr[1].len * (e[i+1].hh - e[i].hh);
}
```

---

## 可视化设计

### 动画方案
1. **像素风格渲染**：  
   - 用8位色块表示元素，不同颜色区分唯一元素。
   - 扫描线从左到右移动，覆盖区域用高亮色标记。
2. **关键步骤高亮**：  
   - **当前扫描线位置**：红色竖线，动态移动。
   - **覆盖区间更新**：绿色块表示新增，黄色块表示移除。
3. **音效与交互**：  
   - **扫描线移动**：播放“滴答”音效。
   - **区间合并**：成功时播放短促上扬音效。
4. **自动演示模式**：  
   - 按空格键暂停/继续，方向键调整速度。
   - 右侧面板显示当前累计答案和覆盖长度。

---

## 个人心得摘录
> **Lotus_Land**：  
> “扫描线算法天然适合处理区间覆盖问题，关键在于正确生成事件点并排序。”  
> **forgotmyhandle**：  
> “线段树维护覆盖次数的技巧，灵感来自矩形面积并的模板题，但需注意动态调整区间。”

---
处理用时：93.19秒
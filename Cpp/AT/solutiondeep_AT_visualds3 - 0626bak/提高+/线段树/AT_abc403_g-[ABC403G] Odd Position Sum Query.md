# 题目信息

# [ABC403G] Odd Position Sum Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc403/tasks/abc403_g

初始有一个空数列 $A$。

需要依次处理 $Q$ 个查询。第 $i$ 个查询的描述如下：

> 给定整数 $y_i$。定义 $z$ 为：当 $i=1$ 时 $z=0$，否则 $z$ 为第 $i-1$ 个查询的答案。然后定义 $x_i=((y_i+z)\bmod 10^9)+1$。将 $x_i$ 添加到 $A$ 的末尾。
> 
> 接着，将 $A$ 升序排列得到序列 $B=(B_1,B_2,\ldots,B_i)$，求 $B$ 中奇数位置元素的总和。即若 $m$ 为不超过 $i$ 的最大奇数，则求 $B_1+B_3+B_5+\ldots+B_m$。

## 说明/提示

### 约束条件

- $1 \leq Q \leq 3 \times 10^5$
- $0 \leq y_i < 10^9$
- $1 \leq x_i \leq 10^9$
- 输入均为整数

### 样例解释 #1

- 第 1 个查询：$y_1=1,z=0$，故 $x_1=((1+0)\bmod 10^9)+1=2$。$A$ 变为 $(2)$，排序后 $B=(2)$，答案为 $B_1=2$。
- 第 2 个查询：$y_2=3,z=2$，故 $x_2=((3+2)\bmod 10^9)+1=6$。$A$ 变为 $(2,6)$，排序后 $B=(2,6)$，答案为 $B_1=2$。
- 第 3 个查询：$y_3=1,z=2$，故 $x_3=((1+2)\bmod 10^9)+1=4$。$A$ 变为 $(2,6,4)$，排序后 $B=(2,4,6)$，答案为 $B_1+B_3=8$。
- 第 4 个查询：$y_4=999999994,z=8$，故 $x_4=((999999994+8)\bmod 10^9)+1=3$。$A$ 变为 $(2,6,4,3)$，排序后 $B=(2,3,4,6)$，答案为 $B_1+B_3=6$。
- 第 5 个查询：$y_5=999999993,z=6$，故 $x_5=((999999993+6)\bmod 10^9)+1=1000000000$。$A$ 变为 $(2,6,4,3,1000000000)$，排序后 $B=(2,3,4,6,1000000000)$，答案为 $B_1+B_3+B_5=1000000006$。

### 样例解释 #2

$x_1,x_2,\ldots,x_8$ 的值依次为：

- 105282054
- 800516877
- 573289179
- 26509423
- 168629803
- 696409999
- 656737335
- 915059758

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
1
3
1
999999994
999999993```

### 输出

```
2
2
8
6
1000000006```

## 样例 #2

### 输入

```
8
105282053
695234822
468007124
120710491
568831200
700753895
765188109
262666319```

### 输出

```
105282054
105282054
905798931
599798602
995656103
891549225
1652393438
1652393438```

# AI分析结果



## 唯一算法分类
动态开点线段树/平衡树维护奇偶位置和

---

## 题解思路与算法要点

### 核心思路
维护有序序列的奇数位置和，每次插入新元素后快速计算。核心在于：
1. 不存储完整数组，而是在值域上维护统计信息
2. 每个区间记录奇数位和、偶数位和、元素个数
3. 合并时根据左区间元素个数的奇偶性调整右区间奇偶和

### 解决难点
- **动态维护有序序列**：使用动态开点线段树或平衡树处理值域离散问题
- **奇偶位置递推**：定义合并规则，若左区间元素个数为奇数，右区间奇偶和交换
- **高效计算**：插入复杂度O(log V)，V为值域大小

### 算法流程（以线段树为例）
1. **插入元素x**：在值域线段树对应位置增加计数
2. **节点更新**：
   ```python
   if 当前节点是叶子节点:
       更新计数及奇偶和（奇和=ceil(cnt/2)*x）
   else:
       递归插入左/右子树
       合并左右子树的奇偶和
   ```
3. **奇偶和合并规则**：
   ```
   左子树元素数奇偶性 → 决定右子树贡献方式
   左奇 → 右偶和加入总奇和，右奇和加入总偶和
   左偶 → 右奇和加入总奇和，右偶和加入总偶和
   ```

---

## 题解评分（≥4星）

1. **xxr___（5星）**
   - 极简代码：27行实现动态线段树
   - 重载运算符合并节点，逻辑清晰
   ```cpp
   struct node{ int len,even,odd; };
   inline node operator + (const node &x, const node &y) {
       return {x.len + y.len, x.even + ((x.len&1)?y.odd:y.even), 
               x.odd + ((x.len&1)?y.even:y.odd)};
   }
   ```

2. **Dtw_（4星）**
   - 详细注释与结构体设计
   - 动态开点线段树标准实现
   ```cpp
   void push_up(node &a, node b, node c) {
       a.c = b.c + c.c;
       a.odd = b.odd + (b.c&1 ? c.even : c.odd);
   }
   ```

3. **gcx114514（4星）**
   - 平衡树维护奇偶和
   - 利用FHQ Treap分裂合并特性
   ```cpp
   void pushup(int u) {
       if (左子树大小奇) {
           奇和 = 左奇 + 右偶;
           偶和 = 左偶 + 当前值 + 右奇;
       } else {
           奇和 = 左奇 + 当前值 + 右偶;
           偶和 = 左偶 + 右奇;
       }
   }
   ```

---

## 最优思路提炼
**关键技巧**：将奇偶位置和分解为可合并的区间属性，通过左右子树大小奇偶性动态调整合并方式。

**数据结构选择**：
- **动态开点线段树**：适合值域大但离散的场景，无需离散化
- **平衡树**：自然维护有序性，适合需要动态分裂合并的操作

**思维突破**：将位置奇偶性转化为区间属性，而非实际维护序列位置，极大简化计算。

---

## 相似题目推荐
1. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)  
   （动态维护有序序列基础）
2. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)  
   （区间合并与延迟标记）
3. [CF242E XOR on Segment](https://codeforces.com/problemset/problem/242/E)  
   （位操作与区间统计结合）

---

## 可视化设计

### 动画方案
1. **值域线段树结构**：
   - 以数轴为背景，动态绘制线段树节点范围
   - 插入元素时高亮对应值域区间，显示计数增加

2. **奇偶和合并演示**：
   ``` 
   左子树[1-5] (3元素) → 奇和=1+3+5=9 
   右子树[6-8] (2元素) → 偶和=6
   合并时左奇 → 总奇和=9 + 右偶和6 =15
   ```

3. **交互控制**：
   - 步进按钮：单步执行插入与合并
   - 速度滑块：调节动画播放速度
   - 高亮当前合并路径（红色线段表示左奇合并，蓝色为左偶）

### 复古像素风格（示例CSS）
```css
.node {
    border: 2px solid #8B8B83;
    background: #C3C3A5;
    font-family: 'PixelFont';
}
.highlight {
    background: #FFD700; /* 经典FC金色 */
    animation: pulse 0.5s infinite;
}
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
}
```

---

## 核心代码片段（xxr___版）
```cpp
struct node{ int len, even, odd; };
inline node operator+(const node &x, const node &y) {
    return {x.len + y.len, 
            x.even + ((x.len&1) ? y.odd : y.even),
            x.odd + ((x.len&1) ? y.even : y.odd)};
}

void ins(int &u, int l, int r, int x) {
    if(!u) u = ++idx;
    if(l == r) {
        tr[u] = tr[u] + node{1, l, 0};
        return;
    }
    int mid = (l+r)>>1;
    x <= mid ? ins(ls[u], l, mid, x) 
             : ins(rs[u], mid+1, r, x);
    tr[u] = tr[ls[u]] + tr[rs[u]];
}
```

---
处理用时：80.72秒
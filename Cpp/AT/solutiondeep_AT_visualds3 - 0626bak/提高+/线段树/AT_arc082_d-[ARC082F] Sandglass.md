# 题目信息

# [ARC082F] Sandglass

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc082/tasks/arc082_d

パーツAとパーツBからなる砂時計があります。これらのパーツにはいくらかの砂が入っています。 砂時計を置くときはパーツAとパーツBのどちらかが上になり、そうでないほうが下になります。

$ 1 $ 秒間に $ 1 $ \[g\] の砂が上にあるパーツから下にあるパーツに落ちます。 ただし、上のパーツにもう砂が残っていない場合は砂は落ちません。

はじめ時刻 $ 0 $ にパーツAが上にあり、$ a $ \[g\] の砂がパーツAに入っていて、$ X-a $ \[g\] の砂がパーツBに入っています(すなわち、合計 $ X $ \[g\] の砂が入っています)。

時刻 $ r_1,r_2,\ ..,\ r_K $ に砂時計をひっくり返します。この操作は瞬間的に行われ、時間はかからないものとします。なお、時刻 $ t $ とは時刻 $ 0 $ の $ t $ 秒後を指します。

クエリが $ Q $ 個与えられます。 各クエリは $ (t_i,a_i) $ の形をしています。 各クエリに対し、$ a=a_i $ だとして、時刻 $ t_i $ にパーツAに入っている砂の量が何gか答えてください。

## 说明/提示

### 制約

- $ 1\ <\ =X\ <\ =10^9 $
- $ 1\ <\ =K\ <\ =10^5 $
- $ 1\ <\ =r_1\ <\ r_2\ <\ ..\ <\ r_K\ <\ =10^9 $
- $ 1\ <\ =Q\ <\ =10^5 $
- $ 0\ <\ =t_1\ <\ t_2\ <\ ..\ <\ t_Q\ <\ =10^9 $
- $ 0\ <\ =a_i\ <\ =X\ (1\ <\ =i\ <\ =Q) $
- 入力値はすべて整数

### Sample Explanation 1

$ 1 $ つめのクエリでは、はじめパーツAに $ 90 $ \\\[g\\\] 入っていた砂が $ 30 $ \\\[g\\\] 減り、$ 60 $ \\\[g\\\] になります。 $ 2 $ つめのクエリでは、はじめパーツAに入っていた $ 1 $ \\\[g\\\] の砂がパーツBに落ちた後、$ 59 $ 秒間変化は起こりません。ここで砂時計をひっくり返し、その $ 1 $ 秒後にパーツAに入っている砂の量を聞かれているため、答えは $ 1 $ \\\[g\\\] になります。

### Sample Explanation 2

どのクエリでもはじめにパーツAに入っている砂は $ 100 $ \\\[g\\\] で、砂時計をひっくり返す前の時間での値を聞いています。

## 样例 #1

### 输入

```
180

3

60 120 180

3

30 90

61 1

180 180```

### 输出

```
60

1

120```

## 样例 #2

### 输入

```
100

1

100000

4

0 100

90 100

100 100

101 100```

### 输出

```
100

10

0

0```

## 样例 #3

### 输入

```
100

5

48 141 231 314 425

7

0 19

50 98

143 30

231 55

342 0

365 100

600 10```

### 输出

```
19

52

91

10

58

42

100```

# AI分析结果



## 算法分类
**线性扫描与数学模型维护**

---

## 综合分析与结论

### 核心思路与难点
1. **核心模型**：  
   - 所有初始沙子量在任意时刻的取值被夹在上下界之间（`f_0(t)` 和 `f_X(t)`）。  
   - 通过维护上下界 `up/down` 和中间值 `sum`，快速计算每个查询的结果。

2. **算法流程**：  
   - 按时间顺序处理翻转和查询事件。  
   - 对于每个翻转点 `r[i]`，更新上下界 `up/down` 和 `sum` 的值。  
   - 查询时，计算当前时间点的 `sum`，并根据上下界夹逼确定最终答案。

3. **可视化设计**：  
   - **动画展示**：  
     - 时间轴从左到右推进，每个翻转点用红色标记，查询点用蓝色标记。  
     - 上下界 `up/down` 用两条动态变化的横线表示，中间区域为有效范围。  
     - 当前 `sum` 值用绿色线段动态显示，超出上下界时自动截断。  
   - **复古像素风格**：  
     - 用 8-bit 像素块表示沙漏状态，翻转时播放“滴答”音效。  
     - 背景音乐采用循环的电子音效，查询正确时触发上扬音调。

---

## 题解清单（≥4星）

1. **ez_lcw（⭐⭐⭐⭐⭐）**  
   - **亮点**：通过维护 `up/down/sum` 实现线性时间复杂度，代码简洁高效。  
   - **代码关键**：  
     ```cpp
     while (处理翻转事件) {
         // 更新上下界和 sum
         down = clamp(down + tag * delta);
         up = clamp(up + tag * delta);
         sum += tag * delta;
         tag *= -1;
     }
     // 夹逼计算答案
     answer = clamp(sum + a, down, up);
     ```

2. **ezoiLZH（⭐⭐⭐⭐）**  
   - **亮点**：线段树动态维护区间加减和截断，思路直观。  
   - **关键逻辑**：  
     ```cpp
     void Add() { // 区间加并截断到 X
         if (minv >= X - delta) set_all(X);
         else if (maxv <= X - delta) add(delta);
     }
     ```

---

## 最优思路提炼
**夹逼法与线性维护**  
- **上下界夹逼**：所有查询结果被 `f_0(t)` 和 `f_X(t)` 夹逼，只需判断中间值是否越界。  
- **事件驱动处理**：按时间顺序处理翻转和查询，避免复杂数据结构。

---

## 同类型题推荐
1. **CF1138B Circus**（动态维护状态区间）  
2. **P2895 [USACO08FEB]Meteor Shower S**（时间轴事件处理）  
3. **AT1218 たのしい家庭菜園**（线性扫描与区间截断）

---

## 可视化算法演示（核心逻辑）

### 动画方案
1. **时间轴推进**：  
   - 横向时间轴，翻转点 `r[i]` 用红色方块标记，查询点用蓝色闪烁标记。  
   - 每次翻转时，沙漏图标旋转并播放翻转音效。

2. **上下界动态显示**：  
   - 上下界 `up/down` 用两条横向绿色/红色线段动态变化。  
   - 当前 `sum` 值用黄色线段显示，超出上下界时线段末端变为红色。

3. **像素风格实现**：  
   ```javascript
   // Canvas 绘制示例
   function draw() {
       ctx.fillStyle = '#8B0000'; // 暗红色像素块
       ctx.fillRect(x, up_y, 10, 2); // 上界线
       ctx.fillStyle = '#006400'; // 暗绿色像素块
       ctx.fillRect(x, down_y, 10, 2); // 下界线
       ctx.fillStyle = '#FFD700'; // 金色当前值
       ctx.fillRect(x, sum_y, 10, 2);
   }
   ```

---

## 代码实现（ez_lcw 核心逻辑）
```cpp
int main() {
    int X, K, Q;
    scanf("%d%d", &X, &K);
    vector<int> r(K+1);
    for (int i=1; i<=K; i++) scanf("%d", &r[i]);
    
    int up = X, down = 0, sum = 0, ptr = 0, tag = -1;
    while (Q--) {
        int t, a;
        scanf("%d%d", &t, &a);
        // 处理所有早于当前查询的翻转事件
        while (ptr < K && r[ptr+1] <= t) {
            int delta = r[ptr+1] - r[ptr];
            down = clamp(down + tag * delta, 0, X);
            up = clamp(up + tag * delta, 0, X);
            sum += tag * delta;
            tag *= -1;
            ptr++;
        }
        // 计算当前时间点的上下界和中间值
        int delta = t - r[ptr];
        int cur_down = clamp(down + tag * delta, 0, X);
        int cur_up = clamp(up + tag * delta, 0, X);
        int cur_sum = sum + tag * delta;
        // 夹逼计算答案
        int ans = clamp(cur_sum + a, cur_down, cur_up);
        printf("%d\n", ans);
    }
}
```

---
处理用时：68.47秒
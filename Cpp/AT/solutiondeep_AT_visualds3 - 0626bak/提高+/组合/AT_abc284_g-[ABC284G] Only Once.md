# 题目信息

# [ABC284G] Only Once

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc284/tasks/abc284_g

$ 1 $ 以上 $ N $ 以下の整数からなる長さ $ N $ の数列 $ A\ =\ (A_1,A_2,\dots,A_N) $ および整数 $ i\ (1\leq\ i\ \leq\ N) $ に対して、 長さ $ 10^{100} $ の数列 $ B_i=(B_{i,1},B_{i,2},\dots,B_{i,10^{100}}) $ を以下のように定義します。

- $ B_{i,1}=i $
- $ B_{i,j+1}=A_{B_{i,j}}\ (1\leq\ j\ <\ 10^{100}) $
 
また、$ S_i $ を「数列 $ B_i $ のなかでちょうど $ 1 $ 度だけ出てくる数の種類数」と定義します。 より厳密には、$ S_i $ は「$ B_{i,j}=k $ を満たす $ j\ (1\leq\ j\leq\ 10^{100}) $ がちょうど $ 1 $ つであるような $ k $ の数」です。

整数 $ N $ が与えられます。数列 $ A $ として考えられるものは $ N^N $ 通りありますが、それら全てに対して $ \displaystyle\ \sum_{i=1}^{N}\ S_i $ を求め、 その総和を $ M $ で割った余りを答えてください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 10^8\leq\ M\ \leq\ 10^9 $
- $ N,M $ は整数
 
### Sample Explanation 1

例として、$ A=(2,3,3,4) $ の場合を考えます。 - $ i=1 $ のとき : $ B_1=(1,2,3,3,3,\dots) $ となるから、$ 1 $ 度だけ出てくる数は $ 1,2 $ の $ 2 $ つで、$ S_1=2 $ - $ i=2 $ のとき : $ B_2=(2,3,3,3,\dots) $ となるから、$ 1 $ 度だけ出てくる数は $ 2 $ のみで、$ S_2=1 $ - $ i=3 $ のとき : $ B_3=(3,3,3,\dots) $ となるから、$ 1 $ 度だけ出てくる数は存在せず、$ S_3=0 $ - $ i=4 $ のとき : $ B_4=(4,4,4,\dots) $ となるから、$ 1 $ 度だけ出てくる数は存在せず、$ S_4=0 $ よって、$ \displaystyle\ \sum_{i=1}^{N}\ S_i=2+1+0+0=3 $ です。 他の $ 255 $ 通りの $ A $ に対しても同様に $ \displaystyle\ \sum_{i=1}^{N}\ S_i $ を計算したうえで、 $ 256 $ 通り全ての総和をとると $ 624 $ になります。

### Sample Explanation 3

総和を $ M $ で割った余りを出力してください。

## 样例 #1

### 输入

```
4 100000000```

### 输出

```
624```

## 样例 #2

### 输入

```
7 1000000000```

### 输出

```
5817084```

## 样例 #3

### 输入

```
2023 998244353```

### 输出

```
737481389```

## 样例 #4

### 输入

```
100000 353442899```

### 输出

```
271798911```

# AI分析结果



**算法分类**  
组合数学

---

**综合分析与结论**  
题目要求计算所有可能的基环树结构中每个链长度的总和。关键思路是将问题转化为基环树模型，利用对称性将总贡献简化为单个点的贡献之和乘以n。通过排列组合公式和快速幂高效计算每个链长度的贡献总和。

- **核心算法流程**：  
  1. 预处理n的幂次，方便后续快速计算。  
  2. 逐个枚举链的长度，计算对应的排列数、剩余点的可能性及贡献。  
  3. 累加所有链长度的贡献，最后乘以n得到总答案。  

- **可视化设计**：  
  用Canvas展示基环树结构，高亮当前链长度对应的节点路径。颜色标记链节点（绿色）、环节点（红色）、其他节点（灰色）。步进控制展示不同链长度的贡献计算过程，动态更新总答案。

---

**题解清单 (≥4星)**  
1. **zac2010（5星）**  
   - 关键亮点：利用对称性，代码简洁高效，时间复杂度O(n)。  
   - 代码可读性高，预处理幂次和逐步计算排列数。  

2. **DaiRuiChen007（4星）**  
   - 关键亮点：公式推导简洁，代码极简，直接利用快速幂和阶乘。  
   - 推导稍复杂，但代码实现高效。  

3. **hyman00（4星）**  
   - 关键亮点：拆分问题为链和环的组合数学计算，思路清晰。  
   - 代码实现结合快速幂和阶乘预处理。  

---

**最优思路与代码实现**  
zac2010的解法为核心思路，通过对称性将问题转化为单个点的贡献计算。关键代码如下：

```cpp
#include <bits/stdc++.h>
#define L(i, a, b) for(int i = a; i <= b; i++)
#define R(i, a, b) for(int i = a; i >= b; i--)
using namespace std;
const int N = 1e6 + 10;
int n, m, a = 1, ans, pn[N];
int main(){
    scanf("%d%d", &n, &m);
    pn[0] = 1;
    L(i, 1, n) pn[i] = 1ll * pn[i - 1] * n % m;
    L(l, 1, n){
        ans = (ans + 1ll * a * pn[n - l] % m * (1ll * l * (l - 1) / 2 % m) % m) % m;
        a = 1ll * a * (n - l) % m;
    }
    printf("%lld\n", 1ll * ans * n % m);
    return 0;
}
```

**核心逻辑**：  
- `pn`数组预处理n的幂次，避免重复计算。  
- `a`变量动态计算排列数$A_{n-1}^{l-1}$，每次循环更新。  
- 内层循环累加每个链长度的贡献，最后乘以n得到总答案。

---

**同类型题推荐**  
1. **洛谷P6384**：利用组合数学分析基环树结构。  
2. **洛谷P4381**：基环树直径问题，需处理环上贡献。  
3. **洛谷P2607**：基环树DP，统计节点权值和。  

---

**可视化与游戏化设计**  
- **Canvas动画**：展示基环树的链和环结构，高亮当前链的路径。  
- **步进控制**：按链长度逐步显示贡献计算，颜色标记当前操作。  
- **8位音效**：关键操作（如累加贡献）触发“点击”音效，完成计算时播放胜利音效。  
- **自动演示**：模拟AI自动遍历所有链长度，动态更新中间结果。  

**示例动画步骤**：  
1. 初始状态显示所有节点为灰色。  
2. 选择链长度l=2，高亮路径1→2→3（绿色）。  
3. 计算贡献，累加后显示当前总和。  
4. 循环直到所有链长度处理完毕，最终显示总答案。

---
处理用时：296.03秒
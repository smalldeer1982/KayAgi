# 题目信息

# Not Too Close

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_c

$ N $ 頂点の無向グラフであって、以下の条件をすべて満たすものの個数を $ 10^9\ +\ 7 $ で割った余りを求めてください。

- $ N $ 個の頂点には $ 1 $ から $ N $ までの番号が振られている。
- グラフは自己辺や多重辺を持たない（連結である必要はない）。
- すべての辺の長さを $ 1 $ とすると、頂点 $ 1,\ 2 $ 間の最短距離は $ D $ である。

## 说明/提示

### 注記

二つのグラフ $ G_1,\ G_2 $ は、以下が満たされる場合に異なるとみなされ、満たされない場合に同一とみなされます。

- ある整数の組 $ (i,\ j) $ $ (1\ <\ =\ i\ <\ j\ <\ =\ N) $ が存在し、頂点 $ i,\ j $ を直接結ぶ辺が $ G_1,\ G_2 $ のうち一方のみに存在する。

### 制約

- $ 1\ <\ =\ D\ <\ N\ <\ =\ 30 $
- $ N,\ D $ は整数である。

### Sample Explanation 1

条件を満たすグラフは下図の $ 2 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/4b0c83895d12c1a9c90cb3e8060db969.png)

### Sample Explanation 2

条件を満たすグラフは下図の $ 14 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/df4dffb7f2140b22a6c7ccc86f6c9cf9.png)

### Sample Explanation 3

mod $ (10^9\ +\ 7) $ にご注意ください。

## 样例 #1

### 输入

```
4 3```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2```

### 输出

```
14```

## 样例 #3

### 输入

```
30 15```

### 输出

```
313862829```

# AI分析结果



---

### 唯一算法分类
**动态规划（分层动态规划）与组合数学**

---

### 综合分析与结论

#### 核心思路与难点
- **分层建模**：将顶点按到顶点1的最短距离分层，确保顶点2严格位于第D层。
- **状态设计**：`dp[i][j][k]` 表示共构建`i`层，已选`j`个顶点，第`i`层有`k`个顶点的合法方案数。
- **转移逻辑**：
  - **组合数选择**：当进入第D层时，必须强制包含顶点2，组合数需调整为 `C(n-j-1, l-1)`。
  - **层间约束**：下一层每个点必须至少与当前层的一个点相连，方案数为 `(2^k - 1)^l`。
  - **层内自由连边**：下一层内部可任意连边，贡献 `2^(l(l-1)/2)`。
- **最终处理**：剩余顶点可自由连边，但只能连接第D层的点，贡献 `2^(k*(n-j) + (n-j)(n-j-1)/2)`。

#### 可视化设计要点
- **动态分层展示**：用像素网格表示各层顶点，当前层高亮为黄色，上一层为蓝色，下一层为绿色。
- **连边动画**：层间边用闪烁线条表示，自动生成时播放“连接音效”。
- **复古音效**：
  - 转移成功：8-bit“滴”声。
  - 完成第D层：胜利音效。
- **自动模式**：以0.5秒步进，展示各层构建过程，Canvas实时更新状态。

---

### 题解清单（4星及以上）

1. **Zhao_daodao（4.5星）**
   - **亮点**：代码简洁，组合数处理清晰，注释明确。
   - **关键代码**：预处理组合数和快速幂，动态规划三重循环结构。

2. **Hadtsti（4星）**
   - **亮点**：变量命名规范，预处理部分详细，适合理解数学逻辑。
   - **心得**：强调“必须至少连一条边”的条件，避免遗漏。

3. **VainSylphid（4星）**
   - **亮点**：代码紧凑，转移循环优化，适合快速实现。
   - **技巧**：使用`tmp`变量减少重复计算，提升效率。

---

### 最优思路与技巧提炼

1. **分层动态规划**：将顶点按距离分层，确保每层仅与相邻层连接。
2. **顶点2强制放置**：在组合数中特殊处理第D层，保证顶点2的唯一性。
3. **边约束计算**：通过 `(2^k - 1)^l` 确保层间必有边，避免距离错误。
4. **剩余顶点自由连**：利用指数公式快速计算未选顶点的全连接方案。

---

### 类似算法套路题目

1. **P6384 [COCI2006-2007#4] BRIGA**（图计数问题）
2. **P3773 [ZJOI2014] 力**（生成树计数与分层思想）
3. **P4337 [CEOI2006] Network**（层次结构图的最优化问题）

---

### 代码核心片段

```cpp
// 预处理组合数与快速幂
for (int i = 0; i <= n; i++) {
    C[i][0] = C[i][i] = 1;
    for (int j = 1; j < i; j++)
        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;
}
pow2[0] = 1;
for (int i = 1; i <= n*n; i++)
    pow2[i] = pow2[i-1] * 2 % mod;

// 动态规划转移
dp[0][1][1] = 1;
for (int i = 0; i < d; i++) {
    for (int j = i; j <= n; j++) {
        for (int k = 1; k <= j; k++) {
            if (!dp[i][j][k]) continue;
            for (int l = 1; l <= n-j; l++) {
                int choose = (i+1 == d) ? C[n-j-1][l-1] : C[n-j-1][l];
                int ways = (pow2[k] - 1 + mod) % mod;
                ways = (ways * pow2[l*(l-1)/2]) % mod;
                ways = (ways * choose) % mod;
                dp[i+1][j+l][l] = (dp[i+1][j+l][l] + dp[i][j][k] * ways) % mod;
            }
        }
    }
}

// 统计答案
int ans = 0;
for (int j = d; j <= n; j++) {
    for (int k = 1; k <= j; k++) {
        int rem = n - j;
        int contrib = pow2[k * rem + rem*(rem-1)/2];
        ans = (ans + dp[d][j][k] * contrib) % mod;
    }
}
```

---

### 复古游戏化动画设计

1. **像素网格绘制**：
   - 每层顶点用8x8像素块表示，层间距为20像素。
   - 当前操作层高亮为闪烁黄色，历史层渐变为灰色。

2. **音效触发**：
   - 层间连边时播放短促“哔”声（Web Audio API生成方波）。
   - 完成最终统计时播放8-bit胜利旋律。

3. **自动演示模式**：
   - 按步进键逐步生成各层，显示组合数、连边数的计算过程。
   - 控制面板支持暂停/继续，速度调节（1x, 2x, 0.5x）。

4. **积分系统**：
   - 每正确转移一层获得10分，连击（连续无错误）额外加分。
   - 最终答案正确时解锁“图灵奖杯”像素图标。

---

通过上述设计，学习者可直观观察分层构造过程，理解动态规划与组合数学的结合，同时通过游戏化元素提升学习趣味性。

---
处理用时：135.68秒
# 题目信息

# [ABC281G] Farthest City

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc281/tasks/abc281_g

正整数 $ N,\ M $ が与えられます。  
 頂点に $ 1,\ \dots,\ N $ の番号が付けられた $ N $ 頂点の単純連結無向グラフであって、以下の条件を満たすものの総数を $ M $ で割った余りを求めてください。

- 全ての $ u\ =\ 2,\ \dots,\ N-1 $ について、頂点 $ 1 $ から頂点 $ u $ までの最短距離は、頂点 $ 1 $ から頂点 $ N $ までの最短距離より真に小さい。
 
ただし、頂点 $ u $ から頂点 $ v $ までの最短距離とは、頂点 $ u,\ v $ を結ぶ単純パスに含まれる辺の本数の最小値を指します。  
 また、$ 2 $ つのグラフが異なるとは、ある $ 2 $ 頂点 $ u,\ v $ が存在して、これらの頂点を結ぶ辺が一方のグラフにのみ存在することを指します。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 500 $
- $ 10^8\ \leq\ M\ \leq\ 10^9 $
- $ N,\ M $ は整数
 
### Sample Explanation 1

以下の $ 8 $ 通りが条件を満たします。 !\[example\_00\](https://img.atcoder.jp/abc281/5c77dfe15dfa3c03666e654bf8cfdc01.png)

### Sample Explanation 3

$ M $ で割った余りを求めることに注意してください。

## 样例 #1

### 输入

```
4 1000000000```

### 输出

```
8```

## 样例 #2

### 输入

```
3 100000000```

### 输出

```
1```

## 样例 #3

### 输入

```
500 987654321```

### 输出

```
610860515```

# AI分析结果



**唯一算法分类**：动态规划与组合数学

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - **分层动态规划**：将节点按到顶点1的最短距离分层，保证顶点N位于最后一层。状态`dp[i][j]`表示前i个节点中，最后一层有j个节点的合法图数量。
   - **状态转移**：枚举上一层的节点数k，计算新层节点的选择、连接方式及内部连边方案：
     - **组合选择**：从剩余节点中选择j个，方案数为组合数`C(n-i+j-1, j)`。
     - **跨层连边**：每个新层节点需至少连接上一层的一个节点，方案为`(2^k - 1)^j`。
     - **内部连边**：j个新节点内部可任意连边，方案为`2^(j*(j-1)/2)`。
   - **预处理优化**：提前计算组合数、幂次、`(2^k - 1)^j`等，减少重复计算。

2. **解决难点**  
   - **正确性验证**：确保转移方程涵盖所有合法图结构，避免重复或遗漏。
   - **大数处理**：使用模运算防止溢出，预处理幂次和组合数优化时间复杂度。

---

### **题解评分 (≥4星)**

1. **Alexandra (5星)**  
   - **亮点**：详细推导分层逻辑，清晰解释转移方程各部分含义，代码结构清晰。
   - **代码可读性**：预处理组合数和幂次，使用显式循环结构，易于调试。

2. **Obviathy (4.5星)**  
   - **亮点**：从BFS树角度切入，强调层内连边不影响最短路性质，直观易懂。
   - **优化**：预处理`(2^k - 1)^j`减少快速幂调用次数。

3. **DeaphetS (4星)**  
   - **亮点**：类比CF类似题目，提供背包优化思路，代码简洁高效。
   - **实践性**：直接枚举最外层点数，省去部分状态维度，降低空间复杂度。

---

### **最优思路或技巧提炼**

1. **分层动态规划**  
   - 将节点按最短距离分层，确保顶点N位于最外层，通过状态转移逐步构建合法图。

2. **组合数学优化**  
   - 预处理组合数、幂次、`(2^k - 1)^j`，利用乘法原理合并各步骤贡献。

3. **关键转移方程**  
   ```plaintext
   dp[i][j] += dp[i-j][k] * C(...) * (2^k - 1)^j * 2^(j*(j-1)/2)
   ```

---

### **同类型题或算法套路**

- **相似题目**  
  1. **CF1657E**：图的最短路径限制与组合计数。
  2. **洛谷P6672**：分层DP与组合数学结合。
  3. **AT_abc232_g**：动态规划与排列组合优化。

---

### **可视化与算法演示**

1. **核心算法动画设计**  
   - **分层展示**：用不同颜色方块表示各层节点，动态添加新层并高亮连接关系。
   - **连边演示**：箭头动态绘制跨层连边（红色）和层内连边（蓝色），突出`(2^k - 1)^j`和`2^(j*(j-1)/2)`的生成过程。
   - **状态跟踪**：侧边栏实时显示`dp[i][j]`的值变化，标注当前选择的k值。

2. **复古像素风格实现**  
   - **Canvas绘制**：节点用8位像素方块表示，层间距固定，连边用低分辨率线条模拟。
   - **音效设计**：添加节点时播放“点击”音效，连边时播放“连接”音效，完成时播放胜利音效。
   - **自动演示模式**：按固定时间间隔步进转移，用户可暂停调整参数（如n值）。

---

### **代码片段（关键逻辑）**

```cpp
// 预处理组合数、幂次、(2^k-1)^j
void init() {
    c[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        c[i][0] = 1;
        for (int j = 1; j <= i; j++) 
            c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;
    }
    pow2[0] = 1;
    for (int i = 1; i <= n*n; i++) 
        pow2[i] = pow2[i-1] * 2 % mod;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++) 
            p[i][j] = pow(pow2[i]-1, j);
}

// 动态规划转移
dp[1][1] = 1;
for (int i = 2; i <= n; i++) {
    for (int j = 1; j < i; j++) {
        for (int k = 1; k <= i-j; k++) {
            dp[i][j] += dp[i-j][k] * c[n-i+j-1][j] % mod 
                      * pow2[j*(j-1)/2] % mod 
                      * p[k][j] % mod;
            dp[i][j] %= mod;
        }
    }
}
cout << dp[n][1];
```

---

### **推荐相似题目**

1. **洛谷P6672**：分层DP与组合计数。
2. **CF1657E**：图的最短路径限制与动态规划。
3. **AT_abc232_g**：组合优化与动态规划结合。

---
处理用时：75.88秒
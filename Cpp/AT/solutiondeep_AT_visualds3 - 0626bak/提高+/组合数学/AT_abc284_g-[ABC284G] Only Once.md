# 题目信息

# [ABC284G] Only Once

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc284/tasks/abc284_g

$ 1 $ 以上 $ N $ 以下の整数からなる長さ $ N $ の数列 $ A\ =\ (A_1,A_2,\dots,A_N) $ および整数 $ i\ (1\leq\ i\ \leq\ N) $ に対して、 長さ $ 10^{100} $ の数列 $ B_i=(B_{i,1},B_{i,2},\dots,B_{i,10^{100}}) $ を以下のように定義します。

- $ B_{i,1}=i $
- $ B_{i,j+1}=A_{B_{i,j}}\ (1\leq\ j\ <\ 10^{100}) $
 
また、$ S_i $ を「数列 $ B_i $ のなかでちょうど $ 1 $ 度だけ出てくる数の種類数」と定義します。 より厳密には、$ S_i $ は「$ B_{i,j}=k $ を満たす $ j\ (1\leq\ j\leq\ 10^{100}) $ がちょうど $ 1 $ つであるような $ k $ の数」です。

整数 $ N $ が与えられます。数列 $ A $ として考えられるものは $ N^N $ 通りありますが、それら全てに対して $ \displaystyle\ \sum_{i=1}^{N}\ S_i $ を求め、 その総和を $ M $ で割った余りを答えてください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 10^8\leq\ M\ \leq\ 10^9 $
- $ N,M $ は整数
 
### Sample Explanation 1

例として、$ A=(2,3,3,4) $ の場合を考えます。 - $ i=1 $ のとき : $ B_1=(1,2,3,3,3,\dots) $ となるから、$ 1 $ 度だけ出てくる数は $ 1,2 $ の $ 2 $ つで、$ S_1=2 $ - $ i=2 $ のとき : $ B_2=(2,3,3,3,\dots) $ となるから、$ 1 $ 度だけ出てくる数は $ 2 $ のみで、$ S_2=1 $ - $ i=3 $ のとき : $ B_3=(3,3,3,\dots) $ となるから、$ 1 $ 度だけ出てくる数は存在せず、$ S_3=0 $ - $ i=4 $ のとき : $ B_4=(4,4,4,\dots) $ となるから、$ 1 $ 度だけ出てくる数は存在せず、$ S_4=0 $ よって、$ \displaystyle\ \sum_{i=1}^{N}\ S_i=2+1+0+0=3 $ です。 他の $ 255 $ 通りの $ A $ に対しても同様に $ \displaystyle\ \sum_{i=1}^{N}\ S_i $ を計算したうえで、 $ 256 $ 通り全ての総和をとると $ 624 $ になります。

### Sample Explanation 3

総和を $ M $ で割った余りを出力してください。

## 样例 #1

### 输入

```
4 100000000```

### 输出

```
624```

## 样例 #2

### 输入

```
7 1000000000```

### 输出

```
5817084```

## 样例 #3

### 输入

```
2023 998244353```

### 输出

```
737481389```

## 样例 #4

### 输入

```
100000 353442899```

### 输出

```
271798911```

# AI分析结果



## 算法分类
组合数学

## 题解思路与核心难点

### 思路概述
题目要求所有可能的基环树结构中，每个节点到环的距离之和的总和。利用对称性，将问题转化为计算单个节点的贡献后乘以N。核心公式推导如下：

1. **链与环分解**：每个节点i的路径分为进入环前的链（长度d）和环本身（长度s）。
2. **排列组合**：链部分的排列数为A(n-1, d)，环部分为A(n-d-1, s-1)。
3. **递推优化**：通过递推式f(d) = n^{n-d} + (n-d)*f(d+1)快速计算累加项，将复杂度优化至O(n)。

### 解决难点
1. **模数非质数**：无法使用逆元求组合数，必须通过递推直接处理排列数。
2. **对称性应用**：发现所有节点贡献对称，只需计算单节点贡献后乘N。
3. **递推式推导**：将双重求和转化为线性递推，避免O(n²)复杂度。

### 关键变量与步骤
1. **预处理排列数**：使用循环计算A(n-1, d)的累乘。
2. **递推f数组**：从后向前递推计算各d对应的累加项。
3. **总贡献计算**：将排列数、递推结果与对应系数相乘累加。

## 题解评分（≥4星）

1. **Kreado（5星）**
   - 清晰推导递推式，代码简洁高效。
   - 利用递推将复杂度优化至O(n)，处理大数模运算巧妙。
   
2. **zac2010（4.5星）**
   - 直观的图形化解释，公式推导详细。
   - 代码直接实现公式，预处理幂次优化性能。
   
3. **DaiRuiChen007（4星）**
   - 简化公式至阶乘与幂次形式，代码极简。
   - 时间复杂度O(n)，适合快速实现。

## 最优思路提炼
1. **对称性转换**：总贡献 = 单点贡献 × N。
2. **链环分解**：将路径分解为链和环，分别计算排列组合。
3. **递推优化**：通过数学变换将双重求和转为线性递推，避免高复杂度。

## 核心代码实现
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5;

ll n, mod, ans=0, fact=1;

int main() {
    scanf("%lld%lld", &n, &mod);
    ll pow_n = 1; // n^{n-d}的逆序计算
    ans = 0;
    for(int d = n; d >= 1; --d) {
        pow_n = pow_n * n % mod;
        ll term = d * (d - 1) / 2 % mod;
        ans = (ans + fact * pow_n % mod * term % mod) % mod;
        fact = fact * (n - d + 1) % mod; // 更新排列数A(n-1, d-1)
    }
    printf("%lld\n", ans * n % mod);
    return 0;
}
```

## 同类型题目推荐
1. **P2602 数字计数** - 数位DP中的对称性应用。
2. **P1350 车的放置** - 组合数学与排列组合递推。
3. **P3193 猜数游戏** - 基环树与概率统计结合。

## 可视化设计

### 动画演示方案
1. **基环树构建**：动态绘制节点间的链接过程，高亮当前链与环。
2. **路径追踪**：用不同颜色标记链部分（蓝色）和环部分（红色）。
3. **递推过程**：侧边栏显示当前计算的d值、排列数和递推结果，同步更新公式变量。

### 复古像素风格
- **调色板**：16色，链节点用深蓝，环节点用砖红，背景浅灰。
- **音效**：链接时播放8-bit点击音，环形成时播放胜利音效。
- **自动演示**：按d从n到1逐步展示，每步暂停500ms，显示当前计算结果。

### 交互功能
- **速度调节**：滑动条控制动画速度（100ms~2000ms/步）。
- **单步执行**：按钮控制前进/后退，观察中间状态。
- **统计面板**：实时显示ans、fact、pow_n的当前值。

---
处理用时：77.03秒
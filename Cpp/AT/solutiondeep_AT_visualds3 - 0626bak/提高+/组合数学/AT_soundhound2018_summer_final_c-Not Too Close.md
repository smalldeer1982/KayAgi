# 题目信息

# Not Too Close

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_c

$ N $ 頂点の無向グラフであって、以下の条件をすべて満たすものの個数を $ 10^9\ +\ 7 $ で割った余りを求めてください。

- $ N $ 個の頂点には $ 1 $ から $ N $ までの番号が振られている。
- グラフは自己辺や多重辺を持たない（連結である必要はない）。
- すべての辺の長さを $ 1 $ とすると、頂点 $ 1,\ 2 $ 間の最短距離は $ D $ である。

## 说明/提示

### 注記

二つのグラフ $ G_1,\ G_2 $ は、以下が満たされる場合に異なるとみなされ、満たされない場合に同一とみなされます。

- ある整数の組 $ (i,\ j) $ $ (1\ <\ =\ i\ <\ j\ <\ =\ N) $ が存在し、頂点 $ i,\ j $ を直接結ぶ辺が $ G_1,\ G_2 $ のうち一方のみに存在する。

### 制約

- $ 1\ <\ =\ D\ <\ N\ <\ =\ 30 $
- $ N,\ D $ は整数である。

### Sample Explanation 1

条件を満たすグラフは下図の $ 2 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/4b0c83895d12c1a9c90cb3e8060db969.png)

### Sample Explanation 2

条件を満たすグラフは下図の $ 14 $ 通りです。 !\[\](https://img.atcoder.jp/soundhound2018-summer-final/df4dffb7f2140b22a6c7ccc86f6c9cf9.png)

### Sample Explanation 3

mod $ (10^9\ +\ 7) $ にご注意ください。

## 样例 #1

### 输入

```
4 3```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2```

### 输出

```
14```

## 样例 #3

### 输入

```
30 15```

### 输出

```
313862829```

# AI分析结果



---

### 算法分类
**动态规划（分层模型）**

---

### 题解思路与核心难点

#### 核心思路
1. **分层建模**：将顶点按到顶点1的最短距离分层，顶点1在第0层，顶点2必须在第D层。
2. **动态规划状态**：定义 `dp[i][j][k]` 表示前i层共使用j个顶点，第i层有k个顶点的方案数。
3. **转移方程**：
   - **下一层顶点选择**：组合数选点，区分是否在第D层（需包含顶点2）。
   - **内部连边**：每层内部连边方式为 `2^(C(l,2))`（l为下一层顶点数）。
   - **跨层连边**：每个下一层顶点至少连一个上一层顶点，方式为 `(2^k - 1)^l`。
4. **答案统计**：剩余顶点内部及与第D层的连边方式自由，总贡献为 `2^(k*(n-j) + C(n-j,2))`。

#### 解决难点
- **顶点2的强制位置**：在第D层时组合数需预留顶点2的位置。
- **连边约束的数学表示**：通过指数幂和组合数精确计算合法连边方式。
- **状态转移的高效计算**：预处理组合数和快速幂优化时间复杂度。

---

### 题解评分（≥4星）

1. **Zhao_daodao（4.5星）**  
   - 亮点：代码简洁，组合数和快速幂预处理清晰，转移逻辑明确。
   - 关键代码：动态规划循环与组合数选择逻辑。
   
2. **Hadtsti（4星）**  
   - 亮点：分层模型解释详细，注释明确，预处理部分高效。
   - 关键代码：转移时的组合数调整和贡献计算。

3. **VainSylphid（4星）**  
   - 亮点：状态转移方程推导完整，变量命名直观，答案统计逻辑清晰。
   - 关键代码：动态规划转移循环与答案累加部分。

---

### 最优思路提炼

1. **分层动态规划**：通过分层模型避免重复计算路径约束。
2. **组合数学优化**：预处理组合数和快速幂加速状态转移。
3. **顶点2的特殊处理**：在转移至第D层时强制选中顶点2，确保合法性。
4. **剩余顶点自由连边**：最终答案统计时允许剩余顶点自由连接，不影响最短路径。

---

### 类似题目与算法套路

- **同类型题**：最短路径计数、分层图结构统计。
- **通用套路**：动态规划结合组合数学，分层处理约束条件。
- **相似题推荐**：
  1. [CF 1476F - Lanterns](https://codeforces.com/problemset/problem/1476/F)（分层决策）
  2. [洛谷 P1357 花园](https://www.luogu.com.cn/problem/P1357)（状态压缩与转移）
  3. [AT DP Contest M - Candies](https://atcoder.jp/contests/dp/tasks/dp_m)（组合数优化DP）

---

### 核心代码实现

```cpp
// 预处理组合数和快速幂
for (int i = 0; i <= n; i++) {
    C[i][0] = C[i][i] = 1;
    for (int j = 1; j < i; j++)
        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;
}
pow2[0] = 1;
for (int i = 1; i <= n*n; i++) 
    pow2[i] = pow2[i-1] * 2 % mod;

// 动态规划转移
dp[0][1][1] = 1;
for (int i = 0; i < d; i++)
for (int j = 1; j <= n; j++)
for (int k = 1; k <= j; k++) {
    if (!dp[i][j][k]) continue;
    for (int l = 1; l <= n-j; l++) {
        int choose = (i+1 == d) ? C[n-j-1][l-1] : C[n-j-1][l];
        int ways_in = pow2[l * (l-1) / 2];
        int ways_cross = (pow2[k] - 1 + mod) % mod;
        ways_cross = pow(ways_cross, l);
        dp[i+1][j+l][l] = (dp[i+1][j+l][l] + dp[i][j][k] * choose % mod * ways_in % mod * ways_cross % mod) % mod;
    }
}

// 统计答案
int ans = 0;
for (int j = d; j <= n; j++)
for (int k = 1; k <= j; k++) {
    int rem = n - j;
    int rem_edges = pow2[k * rem + rem * (rem-1) / 2];
    ans = (ans + dp[d][j][k] * rem_edges % mod) % mod;
}
```

---

### 可视化与算法演示设计

1. **动画方案**：
   - **网格分层**：用不同颜色块表示各层顶点，顶点1和2高亮为红色和蓝色。
   - **连边动态绘制**：转移时动态显示下一层顶点选择及连边方式，用渐变色表示连边组合。
   
2. **交互控制**：
   - **步进控制**：允许单步执行动态规划转移，观察状态变化。
   - **参数调节**：滑动条调整N和D，实时更新算法过程。

3. **复古像素风格**：
   - **8位色块**：顶点用8x8像素块表示，层间间距固定。
   - **音效设计**：连边时播放“哔”声，状态转移成功时播放短促音符。

4. **自动演示模式**：
   - **AI自动步进**：按最优路径自动执行动态规划，辅以文字说明当前状态。

---

### 总结

本题通过分层动态规划模型，结合组合数学优化，高效统计满足最短路径约束的图数量。关键在于分层建模、顶点2的特殊处理及剩余顶点的自由连边计算。代码实现中预处理和状态转移的优化是核心技巧，类似问题可参考分层决策和组合计数的动态规划变种。

---
处理用时：107.50秒
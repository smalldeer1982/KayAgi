# 题目信息

# Three Colors

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tenka1-2019/tasks/tenka1_2019_d

$ N $ 個の整数が与えられます。$ i $ 個目の整数は $ a_i $ です。 与えられたすべての整数を赤、緑、青の $ 3 $ 色のいずれかで塗り、以下の条件を満たすようにする方法の個数を $ 998244353 $ で割ったあまりを求めてください。

- 赤、緑、青で塗られた整数の総和をそれぞれ $ R,G,B $ とする。三辺の長さがそれぞれ $ R,G,B $ であるような正の面積の三角形が存在する。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ a_i\ \leq\ 300(1\leq\ i\leq\ N) $
- 入力はすべて整数である

### Sample Explanation 1

三角形の三辺の長さがそれぞれ $ 1,2,2 $ となるように整数を塗り分けるしかなく、そのような塗り分け方は $ 18 $ 通り存在します。

## 样例 #1

### 输入

```
4

1

1

1

2```

### 输出

```
18```

## 样例 #2

### 输入

```
6

1

3

2

3

5

2```

### 输出

```
150```

## 样例 #3

### 输入

```
20

3

1

4

1

5

9

2

6

5

3

5

8

9

7

9

3

2

3

8

4```

### 输出

```
563038556```

# AI分析结果



# 算法分类
动态规划（背包问题）

# 题解思路与解决难点
**核心思路**：  
1. **逆向思维**：总合法方案数 = 3^N - 非法方案数  
2. **非法条件**：存在一个颜色总和 ≥ 其他两颜色之和（即 R ≥ G+B 或类似情况）  
3. **动态规划**：  
   - `f[j]` 表示选择若干数，其和至少为 `j` 的方案数（对应非法情况）  
   - `g[j]` 表示选择若干数，其和恰好为 `j` 的方案数（用于去重）  
4. **去重处理**：当总和为偶数时，需减去重复计算的 `R=G=S/2` 情况  

**关键难点**：  
1. 背包问题的状态转移设计（至少装满 vs 恰好装满）  
2. 滚动数组优化空间复杂度  
3. 边界条件处理（如总和为偶数时的重复计算）  

# 最优思路提炼
1. **正难则反**：通过逆向计算非法方案简化问题  
2. **滚动背包**：用一维数组倒序更新，节省空间  
3. **对称性优化**：仅计算一种非法情况（如红色），最后乘以3  
4. **重复处理**：针对总和为偶数的特殊情况，单独计算去重项  

# 可视化设计
**动画方案**：  
1. **背包更新过程**：  
   - 用颜色渐变的方块表示 `f` 数组的值  
   - 每次处理一个数 `a_i` 时，从右向左更新数组  
   - 高亮当前更新的位置 `j` 和 `j-a_i`  
2. **去重步骤**：  
   - 当总和为偶数时，用红色边框标出 `S/2` 的位置  
   - 展示 `g` 数组的更新过程与最终去重操作  
3. **复古像素风格**：  
   - 使用 8-bit 音效（点击声、成功/失败音效）  
   - Canvas 绘制网格，每个格子表示背包容量状态  
   - 自动演示模式下，算法步骤按固定时间间隔推进  

**交互功能**：  
- 暂停/继续按钮  
- 速度调节滑块（1x~10x）  
- 单步执行模式（观察每一步的数组变化）  

# 题解评分（≥4星）
1. **灵茶山艾府（5星）**  
   - 代码简洁，利用滚动数组优化空间  
   - 初始化技巧（`f[0] = 3` 减少乘法次数）  
   - 完整处理边界条件  

2. **shinkuu（4星）**  
   - 二维数组实现更易理解  
   - 详细注释和完整代码结构  

3. **fight_for_humanity（4星）**  
   - 引入斯特林数优化总方案计算  
   - 创新性思维值得参考  

# 核心代码实现
```python
MOD = 998244353

n = int(input())
a = [int(input()) for _ in range(n)]
total = sum(a)

# 初始化动态规划数组
f = [0] * (total + 1)
g = [0] * (total + 1)
f[0] = 3  # 初始状态：三种颜色都可能成为最大项
g[0] = 3

pow3 = 1
for num in a:
    pow3 = pow3 * 3 % MOD
    # 更新至少装满背包
    for j in range(total, num-1, -1):
        f[j] = (f[j] * 2 + f[j - num]) % MOD
    # 更新恰好装满背包
    for j in range(total, num-1, -1):
        g[j] = (g[j] + g[j - num]) % MOD

# 计算非法方案数
ceil_half = (total + 1) // 2
illegal = f[ceil_half]
if total % 2 == 0:
    illegal = (illegal - g[total//2]) % MOD

ans = (pow3 - 3 * illegal) % MOD
print(ans if ans >= 0 else ans + MOD)
```

# 相似题目推荐
1. **P2347 砝码称重**（动态规划背包问题）  
2. **P1282 多米诺骨牌**（差值背包问题）  
3. **P1048 采药**（经典01背包问题）

---
处理用时：91.45秒
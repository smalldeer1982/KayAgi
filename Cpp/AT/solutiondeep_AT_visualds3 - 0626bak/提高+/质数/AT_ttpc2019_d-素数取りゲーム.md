# 题目信息

# 素数取りゲーム

## 题目描述

# 素数取り游戏



东工大的安酱和爱酱玩了一个叫做石头取走游戏的两人游戏，但是因为知道必胜法，所以不再感兴趣了。

于是，安酱考虑了一个基于素数的石头取回游戏，并将它命名为“素数取回游戏”。

素数取回游戏的规则如下：

- 开始时有 $N$ 堆小石子，在第 $i$ 堆中有 $X_i$ 个（$X_i$ 是素数）小石子。
- 两个玩家轮流选择存在小石堆的那一堆，并从那里拿走一些石子。
- **只能同时获取素数枚石子，并且在剩余的石子数量为 $0$ 或素数枚时才能继续进行**
- 先无法拿走石头的玩家输掉比赛。

虽然这条规则新颖，但似乎安和爱仍然知道怎样获胜。

请问当安穗是先手，爱穗是后手，面对由 $X_1$，$X_2$，$\ldots$，$X_N$ 个石头组成的 $N$ 堆石头时，假设他们采取最优策略，谁将获胜？

## 样例 #1

### 输入

```
1

13```

### 输出

```
An```

## 样例 #2

### 输入

```
2

17 13```

### 输出

```
An```

## 样例 #3

### 输入

```
6

49529 868033 52361 519803 19289 386501```

### 输出

```
Ai```

# AI分析结果



**唯一算法分类**: 博弈论（Nim 游戏变种、SG 函数）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
将每个素数堆的取法转化为 **SG 函数值**，通过异或和判断胜负：
1. **SG 函数分类**：
   - 当石子数 `x=7` 时，贡献 `SG=3`（唯一能取 3 次的情况）。
   - 若 `x-2` 是素数，贡献 `SG=2`（可分解为两次取法）。
   - 其他情况贡献 `SG=1`（只能取一次）。
2. **异或和判定**：所有堆的 SG 值异或和若为非零，先手（安）必胜；否则后手（爱）胜。

#### **算法实现要点**
- **素数判定**：预处理素数表（欧拉筛/埃氏筛）或动态判断（Miller-Rabin）。
- **贡献计算**：根据 `x` 是否为 7 或 `x-2` 是否为素数，确定每堆的 SG 值。
- **异或运算**：累加所有 SG 值的异或和。

#### **解决难点**
- **SG 函数推导**：通过数学分析证明除 7 外，`x-2` 是否素数是决定 SG 值的关键。
- **高效素数判定**：对大规模数据需用筛法或概率性算法优化。

---

### **题解评分（≥4星）**

1. **CEFqwq（4星）**
   - **亮点**：代码简洁，预处理筛法高效，通过实例归纳 SG 值。
   - **不足**：证明部分较简略，未深入探讨 SG 函数来源。

2. **Genius_Star（5星）**
   - **亮点**：严谨推导 SG 函数，数学证明完整，代码清晰易读。
   - **关键引用**：通过模 6 分析质数分布，证明除 7 外无连续质数差 2。

3. **AC_love（4星）**
   - **亮点**：动态规划思路解释 SG 值，代码简短直接。
   - **不足**：未详细展开数学证明。

---

### **最优思路或技巧提炼**

- **博弈论核心**：将复杂取法规则转化为 SG 函数，利用异或和简化胜负判断。
- **数学优化**：利用质数奇偶性（除 2 外均为奇数），快速排除不可能情况。
- **高效实现**：预处理素数表加速判断，或使用 Miller-Rabin 处理大数。

---

### **同类型题或类似算法套路**

1. **Nim 游戏变种**：如 [P2197【模板】Nim 游戏](https://www.luogu.com.cn/problem/P2197)。
2. **SG 函数应用**：如取石子问题中每堆规则不同时的胜负判定。
3. **质数性质结合博弈**：如 [CF103148J](https://codeforces.com/gym/103148/problem/J)。

---

### **推荐洛谷题目**

1. [P2197：Nim 游戏模板题](https://www.luogu.com.cn/problem/P2197)
2. [P2568：GCD 结合质数筛法](https://www.luogu.com.cn/problem/P2568)
3. [P5655：基础数论与博弈结合](https://www.luogu.com.cn/problem/P5655)

---

### **个人心得摘录**

- **调试教训**：需注意 `x=2` 时 `x-2=0` 的特殊情况，避免误判为素数。
- **思维突破**：通过观察质数奇偶性，发现连续质数差仅 7 满足三次取法。

---

### **可视化与算法演示**

#### **核心算法过程**
1. **像素风格动画**：
   - 用 8 位像素风格展示石子堆，颜色标记当前操作的堆（红色高亮）。
   - 每堆显示当前 SG 值（1: 绿色，2: 蓝色，3: 紫色）。
2. **关键步骤演示**：
   - **取石子**：点击堆后，弹出可选素数（如 2、3、5），选择后更新剩余石子。
   - **异或和计算**：实时显示异或结果，背景色随结果变化（非零：黄，零：灰）。
3. **音效提示**：
   - 取石子时播放“叮”声，胜负揭晓时播放胜利/失败音效。

#### **交互设计**
- **步进控制**：允许单步执行，观察 SG 值计算和异或更新。
- **自动演示**：AI 模拟双方最优策略，动态展示石子堆变化。

---

### **代码实现（核心逻辑）**

```cpp
#include<bits/stdc++.h>
using namespace std;

// Miller-Rabin 素数判定（支持大数）
bool is_prime(long long n) {
    if (n <= 1) return false;
    if (n == 2 || n == 3) return true;
    if (n % 2 == 0) return false;
    long long d = n - 1, s = 0;
    while (d % 2 == 0) d /= 2, s++;
    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (a >= n) continue;
        long long x = 1, m = d;
        for (; m > 0; m >>= 1) {
            if (m & 1) x = (__int128)x * a % n;
            a = (__int128)a * a % n;
        }
        if (x == 1 || x == n - 1) continue;
        for (int r = 1; r < s; r++) {
            x = (__int128)x * x % n;
            if (x == n - 1) break;
        }
        if (x != n - 1) return false;
    }
    return true;
}

int main() {
    int n, xor_sum = 0;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        if (x == 7) xor_sum ^= 3;
        else if (is_prime(x - 2)) xor_sum ^= 2;
        else xor_sum ^= 1;
    }
    cout << (xor_sum ? "An" : "Ai") << endl;
    return 0;
}
```

**核心思想**：通过动态素数判断确定每堆 SG 值，异或和决定胜负。

---
处理用时：99.12秒
# 题目信息

# [ABC314G] Amulets

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc314/tasks/abc314_g

洞窟に、モンスター $ 1 $ 、モンスター $ 2 $ 、$ \ldots $ 、モンスター $ N $ の $ N $ 体のモンスターがおり、各モンスターには正整数の**攻撃力**と、$ 1 $ 以上 $ M $ 以下の整数で表される**タイプ**が定められています。 具体的には、$ i\ =\ 1,\ 2,\ \ldots,\ N $ について、モンスター $ i $ の攻撃力は $ A_i $ でタイプは $ B_i $ です。

高橋君はお守り $ 1 $ 、お守り $ 2 $ 、$ \ldots $ 、お守り $ M $ の $ M $ 個のお守りのうちのいくつかを持って、**体力**が $ H $ の状態でこの洞窟に冒険に出かけます。

冒険では高橋君は（体力が $ 0 $ 以下になって力尽きない限り）$ i\ =\ 1,\ 2,\ \ldots,\ N $ の順に下記の手順を行います。

- もし高橋君がお守り $ B_i $ を冒険に持ってきていないなら、高橋君はモンスター $ i $ の攻撃を受け、高橋君の体力が $ A_i $ だけ減少する。
- その後の時点での高橋君の体力が、
  - $ 0 $ より大きいならば、高橋君はモンスター $ i $ を倒す。
  - $ 0 $ 以下ならば、高橋君はモンスター $ i $ を倒せずに力尽きて冒険を終了する。

$ K\ =\ 0,\ 1,\ \ldots,\ M $ のそれぞれの場合について独立に、下記の問題を解いてください。

> 高橋君が全 $ M $ 個のお守りの中から $ K $ 個を選んで冒険に持っていくときの、高橋君が倒すモンスターの数としてあり得る最大値を求めよ。

なお、任意の $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、タイプが $ i $ であるモンスターが必ず $ 1 $ 体以上いることが、制約として保証されます。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ H\ \leq\ 10^9 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ M $
- 任意の $ 1\ \leq\ i\ \leq\ M $ に対して、ある $ 1\ \leq\ j\ \leq\ N $ が存在して $ B_j\ =\ i $ が成り立つ
- 入力はすべて整数

### Sample Explanation 1

$ K\ =\ 1 $ の問題を考えます。この場合、高橋君はお守り $ 2 $ を持っていくことで、$ 5 $ 体のモンスターを倒し、倒すモンスターの数の最大値を達成することができます。 その際の冒険は、下記の通りに進行します。 - $ i\ =\ 1 $ について、高橋君はお守り $ 2 $ を持っているため、モンスター $ 1 $ の攻撃を免れます。その後、高橋君はモンスター $ 1 $ を倒します。 - $ i\ =\ 2 $ について、高橋君はお守り $ 1 $ を持っていないため、モンスター $ 2 $ の攻撃を受けて体力が $ 6 $ になります。その後、高橋君はモンスター $ 2 $ を倒します。 - $ i\ =\ 3 $ について、高橋君はお守り $ 2 $ を持っているため、モンスター $ 3 $ の攻撃を免れます。その後、高橋君はモンスター $ 3 $ を倒します。 - $ i\ =\ 4 $ について、高橋君はお守り $ 2 $ を持っているため、モンスター $ 4 $ の攻撃を免れます。その後、高橋君はモンスター $ 4 $ を倒します。 - $ i\ =\ 5 $ について、高橋君はお守り $ 1 $ を持っていないため、モンスター $ 5 $ の攻撃を受けて体力が $ 1 $ になります。その後、高橋君はモンスター $ 5 $ を倒します。 - $ i\ =\ 6 $ について、高橋君はお守り $ 3 $ を持っていないため、モンスター $ 6 $ の攻撃を受けて体力が $ -8 $ になります。その後、高橋君はモンスター $ 6 $ を倒せずに力尽きて冒険を終了します。 同様に、$ K\ =\ 0 $ の場合は $ 2 $ 体のモンスターを、 $ K\ =\ 2 $ の場合はお守り $ 2,\ 3 $ を持っていくことで $ 7 $ 体のモンスター全てを、 $ K\ =\ 3 $ の場合はお守り $ 1,\ 2,\ 3 $ を持っていくことで $ 7 $ 体のモンスター全てを倒すことができます。

## 样例 #1

### 输入

```
7 3 7
3 2
1 1
4 2
1 2
5 1
9 3
2 3```

### 输出

```
2 5 7 7```

## 样例 #2

### 输入

```
15 5 400
29 5
27 4
79 1
27 2
30 3
4 1
89 2
88 3
75 5
3 1
39 4
12 1
62 4
38 2
49 1```

### 输出

```
8 12 15 15 15 15```

# AI分析结果



---

### 综合分析与结论

**核心思路**  
所有题解均围绕以下贪心策略展开：  
1. 预处理每个类型的前缀伤害总和  
2. 对于前i个怪兽，选择总伤害最大的K个类型作为护身符  
3. 判断剩余总伤害是否 ≤ H  

**解决难点**  
- **动态维护前K大集合**：随着i的增加，需要动态调整选择的护身符类型  
- **高效查询**：如何快速计算前K大元素的和  
- **单调性优化**：随着i增加，所需K值不会减少，可用双指针加速  

**算法对比**  

| 方法          | 数据结构       | 时间复杂度       | 实现难度 | 适用场景       |  
|-------------|------------|-------------|------|------------|  
| 对顶堆        | 大小根堆      | O(N log M)  | 中等  | 实时维护前K大   |  
| 平衡树        | Treap/SBT  | O(N log M)  | 困难  | 动态查询前K大   |  
| 权值线段树      | 线段树       | O(N log V)  | 较难  | 值域离散化场景  |  
| 主席树        | 可持久化线段树  | O(N log V)  | 困难  | 离线多版本查询   |  

---

### 题解评分（≥4★）

1. **Minuswy（4.5★）**  
   - **亮点**：  
     - 用两个`set`实现动态前K大维护  
     - 巧妙处理类型总伤害的增减  
     - 代码清晰易读  
   - **核心代码**：  
     ```cpp  
     while(sum >= h) { // 需要增加护身符数量  
         auto it = S.end(); --it;  
         T.insert(*it);  
         sum -= it->first;  
         S.erase(it);  
         ++K;  
     }  
     ```  

2. **SegTree（4★）**  
   - **亮点**：  
     - 平衡树直接维护前K大和  
     - 双指针优化遍历过程  
   - **关键实现**：  
     ```cpp  
     while(cur <= m && sum - sumd >= H) {  
         ans[cur] = i-1;  
         sumd += treap.query(m - cur);  
         ++cur;  
     }  
     ```  

3. **yzy1（4★）**  
   - **亮点**：  
     - 权值线段树实现动态维护  
     - 离线二分处理多个查询  
   - **重要片段**：  
     ```cpp  
     ll query(int k) {  
         return seg.query(rt[i], 1, MAXV, k);  
     }  
     ```  

---

### 最优思路与技巧

**贪心策略证明**：  
- 设前i个怪兽总伤害为S，若选择总伤害最大的K个类型（和为T），则剩余伤害为S-T  
- 当且仅当 S-T ≤ H 时可通过  
- 由排序不等式，选择最大K个类型是最优解  

**实现技巧**：  
1. **动态维护集合**：  
   - 使用两个集合（S已选，T未选）  
   - 当新增怪兽导致类型总伤害变化时，动态调整集合归属  

2. **双指针优化**：  
   ```  
   i: 当前处理的怪兽编号  
   K: 当前需要的最少护身符数  
   随着i增加，K单调不减  
   ```  

3. **平衡树操作**：  
   - 插入/删除时维护前K大集合  
   - 通过平衡树快速查询第K大元素  

---

### 同类型题目推荐

1. **P1801 黑匣子**  
   - 动态维护前K大元素  
   - 对顶堆经典问题  

2. **P3871 [TJOI2010]中位数**  
   - 动态维护有序集合中位数  
   - 类似的双集合维护策略  

3. **P3380 【模板】二逼平衡树**  
   - 区间前驱/后继查询  
   - 综合练习平衡树操作  

---

### 可视化设计

**像素化贪心演示**  
```html  
<div id="canvas-container">  
  <canvas id="pixel-canvas"></canvas>  
  <div class="controls">  
    <button onclick="prevStep()">←</button>  
    <button onclick="nextStep()">→</button>  
    <span id="step-info">Step 0</span>  
  </div>  
</div>  

<script>  
// 伪代码示例  
function drawStep(step) {  
  // 用不同颜色表示：  
  // - 当前处理的怪兽（红色像素块）  
  // - 已选护身符类型（绿色）  
  // - 未选类型（蓝色）  
  // 底部显示当前总伤害和剩余血量  
}  
</script>  
```  

**动画逻辑**：  
1. 每个怪兽出现时，更新对应类型总伤害  
2. 动态调整两个集合的归属  
3. 当总伤害超过H时，触发护身符增加动画  

**音效设计**：  
- `select.wav`：当护身符被选中  
- `overflow.wav`：当血量不足  
- `8bit_bgm.mp3`：循环背景音乐  

---

### 核心代码实现

**Minuswy的贪心核心**  
```cpp  
set<pair<int, int>> S, T; // S:已选集合，T:未选集合  

void update(int type, int delta) {  
  // 从原集合删除旧值  
  if(S.count({old_sum, type})) {  
    S.erase({old_sum, type});  
    sum -= old_sum;  
  } else {  
    T.erase({old_sum, type});  
  }  

  // 插入新值  
  new_sum = old_sum + delta;  
  if(new_sum < T.begin()->first) {  
    S.insert({new_sum, type});  
    sum += new_sum;  
  } else {  
    T.insert({new_sum, type});  
  }  

  // 调整集合平衡  
  while(sum >= H) {  
    auto it = S.end(); --it;  
    T.insert(*it);  
    sum -= it->first;  
    S.erase(it);  
    K++;  
  }  
}  
```  

---

**总结**：本题的关键在于动态维护前K大元素的和，结合双指针优化可达到O(N log M)的时间复杂度。对顶堆和平衡树是两种经典实现方式，其中set的实现更易理解，适合算法竞赛快速编码。

---
处理用时：93.89秒
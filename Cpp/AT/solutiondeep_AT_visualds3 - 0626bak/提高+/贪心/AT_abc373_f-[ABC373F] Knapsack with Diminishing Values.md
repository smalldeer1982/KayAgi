# 题目信息

# [ABC373F] Knapsack with Diminishing Values

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc373/tasks/abc373_f

$ N $ 種類の品物があり、 $ i $ 種類目の品物の重みは $ w_i $、価値は $ v_i $ です。どの種類の品物も $ 10^{10} $ 個ずつあります。

高橋君はこれから、品物をいくつか選んで、容量 $ W $ のバッグに入れます。高橋君は、選ぶ品物の価値を大きくしつつ、同じ種類の品物ばかりにならないようにしたいです。そこで高橋君は、$ i $ 種類目の品物を $ k_i $ 個選んだときの **うれしさ** を $ k_i\ v_i\ -\ k_i^2 $ と定義したとき、選んだ品物の重さの総和を $ W $ 以下にしつつ、各種類のうれしさの総和が最大になるように品物を選びます。高橋君が達成できる、うれしさの総和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3000 $
- $ 1\ \leq\ W\ \leq\ 3000 $
- $ 1\ \leq\ w_i\ \leq\ W $
- $ 1\ \leq\ v_i\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1 $ 種類目の品物を $ 2 $ 個、$ 2 $ 種類目の品物を $ 1 $ 個選ぶと、うれしさの総和を $ 5 $ にすることができ、これが最適です。 $ 1 $ 種類目の品物についてのうれしさは $ 2\ \times\ 4\ -\ 2^2\ =\ 4 $、$ 2 $ 種類目の品物についてのうれしさは $ 1\ \times\ 2\ -\ 1^2\ =\ 1 $ です。 また、重さの総和は $ 9 $ であり、容量 $ 10 $ のバッグに入ります。

## 样例 #1

### 输入

```
2 10

3 4

3 2```

### 输出

```
5```

## 样例 #2

### 输入

```
3 6

1 4

2 3

2 7```

### 输出

```
14```

## 样例 #3

### 输入

```
1 10

1 7```

### 输出

```
12```

# AI分析结果



---

### 题解思路、算法要点与解决难点

**核心问题建模**：  
每个物品选 k 次的价值函数为二次函数 $f(k) = kv_i -k^2$，其最大值为 $k^* = \lfloor v_i/2 \rfloor$。但需在背包容量约束下，组合多种物品的最优解。

**题解思路对比**：

1. **贪心预处理 + 分组背包（主流解法）**  
   - **核心思路**：对每个重量 w 预处理选 j 个物品的最优组合，转化为分组背包问题  
   - **预处理方法**：对同一重量的物品，每次选择当前能带来最大边际收益的（优先队列维护）  
   - **时间复杂度**：$O(W \log W + NW)$（调和级数优化）  
   - **难点突破**：发现同重量物品的贪心可叠加性，通过二次函数导数性质证明贪心正确性  

2. **斜率优化动态规划**  
   - **核心思路**：将状态转移方程拆解为线性函数，维护凸包优化决策过程  
   - **优势**：理论复杂度更低（$O(NW)$），但实现细节复杂  
   - **难点突破**：巧妙拆解转移式为线性形式，利用单调队列维护最优决策点  

3. **物品拆分 + 优先队列贪心**  
   - **核心思路**：将第 k 次选物品的边际收益 $v_i -2k+1$ 作为独立物品，动态维护最大收益选项  
   - **亮点**：无需显式预处理，直接通过优先队列动态生成有效选项  
   - **难点突破**：发现边际收益单调递减性质，避免无效状态转移  

---

### 题解评分（≥4★）

| 题解作者      | 评分 | 核心亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| wangshulin    | ★★★★☆ | 预处理贪心思路清晰，代码可读性强，调和级数优化巧妙                     |
| g1ove（解法1）| ★★★★☆ | 决策单调性优化代码简洁，理论分析透彻                                   |
| _WRYYY_       | ★★★★  | 优先队列贪心实现直观，代码结构清晰，附带详细推导过程                   |

---

### 最优思路或技巧提炼

**关键技巧**：  
1. **重量分组贪心预处理**  
   - 对相同重量 w 的物品，计算选 j 个的最优组合  
   - 每次选择边际收益最大的物品（$v_i -2k+1$）  
   - 使用优先队列维护当前可用选项  

2. **调和级数优化背包**  
   ```python
   for w in 1..W:
       for j in 1..W//w:
           update dp[j*w] with max value
   ```
   时间复杂度从 $O(W^2)$ 降为 $O(W \log W)$

3. **边际收益单调性利用**  
   - 第 k 次选物品的边际收益为 $v_i -2k+1$，严格递减  
   - 只需维护前 $\min(k^*, W/w_i)$ 次有效选择  

---

### 同类型题或类似算法套路

**常见变种**：  
1. **非线性价值背包**：价值函数为凸/凹函数（如 [CF1394D](https://codeforces.com/problemset/problem/1394/D)）  
2. **分组物品优化**：物品按重量分组，组内贪心预处理（如 [洛谷P6771](https://www.luogu.com.cn/problem/P6771)）  
3. **决策单调性优化**：转移方程可拆解为线性形式（如 [洛谷P3195](https://www.luogu.com.cn/problem/P3195)）  

---

### 推荐相似题目

1. **[洛谷P1776] 宝物筛选**  
   （多重背包 + 二进制优化，价值函数特殊形式）

2. **[CF730J] Bottles**  
   （背包容量约束下的最优组合，需预处理物品属性）

3. **[ARC066D] Contest with Drinks Hard**  
   （非线性价值函数优化，决策单调性应用）

---

### 个人心得摘录

> “**wangshulin**：预处理时发现每个重量 j 的最优选择是单调的，赛时直接感知正确性就打了，后来用二次函数导数性质验证”  
> —— 强调直觉与理论验证的结合

> “**g1ove**：斜率优化的移项过程调试了 2 小时，最终发现是符号错误。结论：手推公式时务必检查系数符号！”  
> —— 实现细节决定成败

---

### 可视化与算法演示设计

**贪心过程动画方案**：  
1. **像素风格界面**：  
   - 背包容量以横向像素条表示（总长度 W）  
   - 物品重量用不同颜色方块表示（w=3 → 3连方块）  

2. **贪心选择高亮**：  
   ```javascript
   function highlightBestChoice() {
       // 当前重量组中边际收益最大的选项闪烁显示
       currentItem.blink({color: '#FFD700', duration: 500});
   }
   ```

3. **音效反馈**：  
   - 选择物品时播放 8-bit “金币声”  
   - 错误选择（负收益）时播放低音警报  

4. **自动演示模式**：  
   ```python
   def auto_play():
       while not is_full():
           item = select_max_margin()  # AI选择最大边际收益
           place_item(item)
           update_display()
           play_sound('click.wav')
   ```

---

### 核心代码实现（贪心预处理 + 分组背包）

```cpp
priority_queue<int> q;  // 维护当前重量组的可用物品
vector<ll> f(W+1);

for (int w = 1; w <= W; ++w) {
    for (auto v : items[w]) 
        q.push(v - 1);  // 第一次选择收益为v-1
    
    vector<ll> gain(W/w + 1);
    for (int k=1; k<=W/w; ++k) {
        if (q.empty()) break;
        int cur = q.top(); q.pop();
        gain[k] = gain[k-1] + cur;
        q.push(cur - 2);  // 下次收益减少2
    }
    
    // 分组背包更新
    for (int j=W; j>=0; --j) 
        for (int k=1; k<=j/w; ++k)
            f[j] = max(f[j], f[j -k*w] + gain[k]);
}
```

---

**可视化交互示例**：  
![Knapsack Demo](https://i.imgur.com/8mTpZQr.gif)  
（图示：重量为2的物品组，优先选择高v值物品，黄色块表示当前选中）

---
处理用时：108.03秒
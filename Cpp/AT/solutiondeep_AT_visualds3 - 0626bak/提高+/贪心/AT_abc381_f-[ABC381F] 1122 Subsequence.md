# 题目信息

# [ABC381F] 1122 Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc381/tasks/abc381_f

正整数からなる（空でも良い）数列 $ X=(X_1,X_2,\ldots) $ が以下の $ 3 $ つの条件をすべてみたすとき、かつそのときに限り、$ X $ を **1122 数列** と呼びます。  
（1122 数列の定義はD問題と共通です。）

- $ \lvert\ X\ \rvert $ は偶数である。ここで、$ \lvert\ X\ \rvert $ は $ X $ の長さを表す。
- $ 1\leq\ i\leq\ \frac{\lvert\ X\ \rvert}{2} $ をみたす整数 $ i $ について、$ X_{2i-1} $ と $ X_{2i} $ は等しい。
- 各正整数は $ X $ に現れないか、ちょうど $ 2 $ 回現れるかのどちらかである。すなわち、$ X $ に含まれる正整数は $ X $ にちょうど $ 2 $ 回ずつ登場する。

正整数からなる長さ $ N $ の数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられるので、$ A $ の **（連続でなくても良い）部分列** であって、1122 数列であるようなもののうち最長のものの長さを出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 20 $
- 入力はすべて整数

### Sample Explanation 1

例えば $ A $ の部分列として、$ 1,4,5,6 $ 項目をとると $ (1,1,2,2) $ となりますが、これは長さが $ 4 $ の 1122 数列となっています。 これより長い部分列であって、1122 数列の条件をみたすようなものは存在しないため、$ 4 $ を出力します。

## 样例 #1

### 输入

```
7
1 3 3 1 2 2 1```

### 输出

```
4```

## 样例 #2

### 输入

```
1
20```

### 输出

```
0```

# AI分析结果



## 综合分析与结论

### 题解思路与核心难点
题目要求构造最长满足特定条件的子序列（每个元素成对出现且仅出现两次）。各题解核心思路为：
1. **状压DP + 贪心选择**：利用值域小（1-20）的特点，用二进制状态表示已选元素集合，状态值记录子序列末尾的最小位置
2. **预处理辅助数组**：通过逆序预处理 `nxt[i][x]` 表示位置i之后第一个x的位置，快速查询元素
3. **贪心转移策略**：每次选择当前状态后最近的两次相同元素，保证后续选择空间最大化

难点在于如何高效处理以下问题：
- 快速查询任意位置后的两个相同元素 → 预处理nxt数组
- 状态转移的顺序控制 → 按状态二进制位数递增转移
- 避免指数级复杂度 → 将n维状态压缩为二进制表示

### 贪心策略可视化设计
1. **像素化状态转移动画**：
   - 用20x20的像素网格表示状态（每个像素代表一个数字是否选中）
   - 黄色像素表示当前选中状态，绿色箭头表示正在尝试添加新元素
   - 下方滚动条展示原数组，高亮正在处理的元素位置

2. **关键步骤演示**：
```javascript
// 伪代码示例
function visualizeTransfer(s, x) {
  highlightStateGrid(s); // 当前状态高亮
  showArrow(s, x);       // 指向尝试添加的元素x
  let pos1 = nxt[dp[s]][x];
  let pos2 = nxt[pos1][x];
  flashElement(pos1);    // 闪烁显示第一个x的位置
  flashElement(pos2);    // 闪烁显示第二个x的位置
  updateStateGrid(s | (1<<x)); // 更新状态网格
}
```

3. **8位音效系统**：
   - 选中元素：播放NES风格的"coin"音效（短促的方波）
   - 状态更新成功：播放上升音阶
   - 转移失败：播放低音警报
   - 背景音乐：8-bit版本的《卡农》循环播放

### 复古游戏化设计
- **关卡模式**：将每个状态转移视为一个关卡，通关后解锁新数字
- **连击积分**：连续正确转移获得2倍积分，错误转移中断连击
- **AI演示模式**：贪心AI自动执行，用像素小人跳跃动画表示状态变化

---

## 题解评分（≥4星）

### 1. [作者：DengDuck] ⭐⭐⭐⭐⭐
- **亮点**：极简代码（22行），预处理与状态转移一气呵成
- **核心代码**：
```cpp
for(int S=0;S<(1<<M);S++)
  for(int j=0;j<M;j++)
    if(S&(1<<j)){
      int t = S^(1<<j);
      dp[S] = min(dp[S], nxt[nxt[dp[t]][j]][j]);
    }
```

### 2. [作者：__Allen_123__] ⭐⭐⭐⭐
- **亮点**：详细注释与预处理思路，适合教学
- **心得摘录**："越往深入去想，你的自我怀疑越深...这就是你热爱OI的心" —— 展现解题心路历程

### 3. [作者：MrPython] ⭐⭐⭐⭐
- **亮点**：STL容器高效实现二分查找，代码可读性强
- **关键片段**：
```cpp
auto it = lower_bound(apr[i].begin(), apr[i].end(), f[b]);
if(it != apr[i].end() && next(it) != apr[i].end())
  f[(1<<i)|b] = min(f[(1<<i)|b], *next(it)+1);
```

---

## 最优思路提炼

### 核心技巧
1. **状压状态设计**：`dp[S]`表示集合S的最小末尾位置
2. **双位置跳跃查询**：`nxt[nxt[pos][x]][x]`获取连续两个x的位置
3. **贪心转移顺序**：按二进制位数递增转移，保证无后效性

### 实现要点
```cpp
// 预处理nxt数组
for(int i=n; i>=0; i--){
  for(int x=1; x<=20; x++)
    nxt[i][x] = (a[i+1]==x) ? i+1 : nxt[i+1][x];
}

// 状态转移
for(int s=0; s<(1<<20); s++){
  if(dp[s] > n) continue;
  for(int x=0; x<20; x++){
    if(s & (1<<x)) continue;
    int p1 = nxt[dp[s]][x+1];
    int p2 = nxt[p1][x+1];
    if(p2 <= n) dp[s|(1<<x)] = min(dp[s|(1<<x)], p2);
  }
}
```

---

## 相似题目推荐
1. [洛谷P1896] 互不侵犯 - 状压DP经典问题
2. [洛谷P1879] 玉米田 - 网格状压DP
3. [CF1391D] 505 - 状压与矩阵验证

---

## 可视化代码片段

```javascript
// 像素化状态显示
const grid = new PixelGrid(20, 20, 10); // 20x20格子，每个10px
function updateState(s) {
  for(let i=0; i<20; i++) {
    const color = (s & (1<<i)) ? '#FFD700' : '#333';
    grid.fillRect(i%5*4, Math.floor(i/5)*4, 4, 4, color);
  }
}

// 音效系统
const sfx = {
  select: new Audio('data:audio/wav;base64,UklGRl9...'), // 简短beep
  success: new Audio('data:audio/wav;base64,UklGRk9...')
};

function playSfx(name) {
  sfx[name].currentTime = 0;
  sfx[name].play();
}
```

---

## 知识拓展
**状压DP的贪心本质**：本题将贪心的局部最优（选择最近元素）与状态压缩结合，实现在指数级状态空间中的高效搜索。这种"贪心剪枝"技巧也可用于旅行商问题(TSP)等经典状压场景。

---
处理用时：93.29秒
# 题目信息

# [AGC037B] RGB Balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc037/tasks/agc037_b

色のついたボールが $ 3N $ 個あり、それぞれには $ 1 $ から $ 3N $ の番号がついています。 各ボールの色は長さ $ 3N $ の文字列 $ S $ によって表されており、ボール $ i $ の色は $ S_i $ が `R` のとき赤色、`G` のとき緑色、`B` のとき青色です。 赤色のボール、緑色のボール、青色のボールはそれぞれ $ N $ 個ずつあります。

高橋君はこの $ 3N $ 個のボールを、各人が赤、青、緑のボールを $ 1 $ つずつ割り当てられるよう、$ N $ 人の人に分配することにしました。 ただし、ボールをもらう人たちはできるだけ近い番号のボールが欲しいので、高橋君はさらに以下の条件をみたすように分配することにしました。

- $ j $ 番目の人が受け取ったボールの番号を小さい順に $ a_j\ <\ b_j\ <\ c_j $ とする。
- このとき $ \sum_j\ (c_j-a_j) $ ができるだけ小さくなるように分配する。

高橋君がボールを分配する方法は何通りあるか求めてください。 答えは非常に大きくなることがあるので、$ 998244353 $ で割ったあまりを求めてください。 ただし、$ 2 $ つのボールの分配方法が異なるとは、ある人が存在して、その人が受け取ったボールの集合が異なることを指します。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ |S|=3N $
- $ S $ は `R`, `G`, `B` のみからなり、それぞれ $ N $ 回ずつ $ S $ に登場する

### Sample Explanation 1

例えば以下のようにボールを分配したとき、$ \sum_j\ (c_j-a_j) $ の値が $ 18 $ となり最小となります。 - $ 1 $ 番目の人にボール $ 1,5,9 $ を渡す。 - $ 2 $ 番目の人にボール $ 2,4,8 $ を渡す。 - $ 3 $ 番目の人にボール $ 3,6,7 $ を渡す。

## 样例 #1

### 输入

```
3

RRRGGGBBB```

### 输出

```
216```

## 样例 #2

### 输入

```
5

BBRGRRGRGGRBBGB```

### 输出

```
960```

# AI分析结果



## 综合分析与结论

### 核心思路与贪心策略
1. **贪心选择**：按顺序处理每个球，优先将当前球与已存在的两球组合（如 `RG`、`GB`、`RB`）配对，形成完整的三球组，从而最小化每个组的跨度 `c_j - a_j`。
2. **状态维护**：维护以下状态的计数：
   - 单色球：`R`、`G`、`B`
   - 两球组合：`RG`、`GB`、`RB`
3. **方案数累积**：每一步选择时，将可能的组合方式数目累乘，最后乘以 `n!`（因人的排列不同）。

### 解决难点
- **正确性证明**：贪心策略的正确性基于“优先闭合三球组”可保证全局最优。每次选择不影响后续更优解的存在。
- **状态转移**：正确处理各状态变量的增减，避免遗漏分支情况。
- **模运算处理**：在每一步乘法后取模，防止溢出。

### 算法可视化设计
- **动态状态显示**：以像素风格展示当前各状态变量（单色球、两球组合）的数量。
- **高亮当前球**：处理球时高亮其颜色，并显示可能的配对方式。
- **音效反馈**：成功配对时播放上扬音效，无法配对时播放警示音。
- **自动演示模式**：模拟贪心选择过程，逐步展示状态变化。

---

## 题解评分（≥4星）

### 1. MattiaBinutto（★★★★☆）
- **亮点**：代码简洁，状态维护清晰，优先处理完整组合。
- **关键代码**：
  ```cpp
  if (s[i] == 'R') {
    if (GB) ans = ans * GB % p, --GB;
    else if (G) ans = ans * G % p, ++RG, --G;
    // ... 其他分支
  }
  ```

### 2. MiRaciss（★★★★☆）
- **亮点**：逻辑与MattiaBinutto一致，变量命名略有不同，注释更贴近自然语言。
- **关键代码**：
  ```cpp
  if (s[i] == 'R') {
    if (BG) ans *= BG, BG--, ans %= Mod;
    // ... 其他分支
  }
  ```

### 3. yshpdyt（★★★★☆）
- **亮点**：代码简洁，直接在循环中处理阶乘，减少最终乘法步骤。
- **关键代码**：
  ```cpp
  for (int i=1; i<=n; i++) res = res * i % mod; // 提前处理阶乘
  ```

---

## 最优思路提炼

### 关键步骤
1. **遍历每个球**，按颜色分支处理。
2. **优先匹配互补两球组合**（如 `R` 匹配 `GB`）。
3. **次优匹配单色球**（如 `R` 匹配 `G` 或 `B`）。
4. **无法匹配则单独计数**。
5. **最终方案数乘 `n!`**。

### 正确性保障
- 每次选择确保当前球尽可能作为三球组的最后一个，保证跨度最小。
- 状态变量的维护确保所有可能组合被覆盖。

---

## 同类型题与算法套路

### 通用贪心策略
- **最小化跨度问题**：优先闭合区间，如区间调度、任务分配。
- **组合优化**：维护部分组合状态，逐步构造全局解。

### 推荐题目
1. **P1223 排队接水**（贪心排序）
2. **P1090 合并果子**（优先队列）
3. **P5019 铺设道路**（区间覆盖贪心）

---

## 个人心得摘录

- **调试教训**：分支顺序不可颠倒，必须优先处理完整组合。
- **顿悟点**：`n!` 的乘法源于组的全排列，而非组内排列。

---

## 可视化与算法演示

### 贪心过程动画设计
- **像素风格界面**：用不同颜色方块表示 `R`、`G`、`B` 球。
- **状态面板**：实时显示 `R`、`G`、`B`、`RG`、`GB`、`RB` 的计数。
- **高亮提示**：当前处理的球闪烁，可用箭头指示配对方式。
- **音效反馈**：成功配对时播放“叮”，错误时“哔”。

### 代码片段（JS伪代码）
```javascript
// 模拟处理球的过程
function processBall(color) {
  if (color === 'R') {
    if (GB > 0) {
      playSound('success');
      ans = (ans * GB) % MOD;
      GB--;
    } else if (G > 0) { /* ... */ }
  }
  // 更新Canvas显示状态
  updateCanvas();
}
```

---

## 核心代码实现

### 贪心逻辑（C++）
```cpp
for (int i = 1; i <= 3 * n; ++i) {
  if (s[i] == 'R') {
    if (GB) ans = ans * GB % MOD, GB--;
    else if (G) ans = ans * G % MOD, RG++, G--;
    else if (B) ans = ans * B % MOD, RB++, B--;
    else R++;
  }
  // 类似处理G和B
}
ans = ans * factorial(n) % MOD; // factorial预计算
```

---

**答案**
\boxed{216} （样例1的正确输出）

---
处理用时：117.09秒
# 题目信息

# [AGC065A] Shuffle and mod K

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc065/tasks/agc065_a

長さ $ N $ の整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。

あなたは $ A $ を自由に並び替えることが出来ます。並び替えた後の $ \sum_{i=1}^{N-1}\ ((A_{i+1}\ -\ A_i)\ \bmod\ K) $ としてあり得る最大値を求めてください。

ここで、$ x\ \bmod\ K $ とは $ 0\ \le\ y\ <\ K $ かつ $ x\ -\ y $ が $ K $ の倍数になる整数 $ y $ のことを指します。例えば、$ -3\ \bmod\ 8\ =\ 5,9\ \bmod\ 6\ =\ 3 $ となります。

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ K\ \le\ 10^9 $
- $ 0\ \le\ A_i\ <\ K $
 
### Sample Explanation 1

最適な例として、$ A\ =\ (2,1,0) $ と並び替えると $ (1\ -\ 2)\ \bmod\ 4\ +\ (0\ -\ 1)\ \bmod\ 4\ =\ 3\ +\ 3\ =\ 6 $ が達成できます。

## 样例 #1

### 输入

```
3 4

0 1 2```

### 输出

```
6```

## 样例 #2

### 输入

```
7 123

11 34 56 0 32 100 78```

### 输出

```
638```

# AI分析结果



### 综合分析与结论

**题目核心**：通过排列数组，最大化相邻元素差的模K总和。关键点在于如何最大化模K的贡献次数（p*K）和首尾元素差（aₙ -a₁）。

**贪心策略**：
1. **出现次数最多的元素决定分组数**：设其出现次数为m，则最多可形成m个严格递减组，此时贡献次数为n-m。
2. **两种情况对比**：
   - 情况1：分m组 → 总和为(n-m)K + (x₁ -x₂)，其中x₁是出现m次的最小值，x₂是最大值。
   - 情况2：分m±1组 → 总和为(n-m±1)K + 其他可能更大差值。
3. **动态维护候选集合**：通过排序和集合快速查找最大可能的首尾差值。

**可视化设计**：
- **动画展示**：将元素排序后，用不同颜色标记出现次数最多的元素。动态绘制分组过程，高亮每组首尾元素，显示当前贡献。
- **复古像素风格**：用8-bit风格展示元素，分组时播放音效（如“选择”提示音），不同组用不同颜色区分。
- **步进控制**：允许单步执行观察分组策略调整对总和的影响。

---

### 题解清单（≥4星）

1. **作者：_sunkuangzheng_（⭐⭐⭐⭐⭐）**
   - **亮点**：清晰的理论推导，明确分组策略与数学表达，逻辑严谨。
   - **核心**：通过出现次数最多的元素分组，分情况讨论最大差值。

2. **作者：Acoipp（⭐⭐⭐⭐）**
   - **亮点**：代码实现灵活，动态维护候选集合，覆盖多种情况。
   - **核心**：逆序遍历与集合操作高效寻找最大差值，代码结构清晰。

---

### 最优思路提炼

1. **统计频率**：找出出现次数最多的元素，确定最大分组数m。
2. **分组策略**：
   - **情况1（m组）**：确保每组严格递减，贡献次数n-m。
   - **情况2（m±1组）**：允许更大差值，枚举相邻元素最大差。
3. **差值计算**：维护候选集合，动态查找最大aₙ -a₁的可能值。

---

### 代码核心片段

```cpp
// 统计元素频率并排序
sort(a + 1, a + n + 1);
for (int i = 1; i <= n; i++) {
    if (p[tot].x == a[i]) p[tot].y++;
    else p[++tot] = {a[i], 1};
}

// 计算两种情况的最大值
ll func = 0;
for (int i = 1; i <= tot; i++) func = max(func, p[i].y);

// 情况1：分func组
set<ll> op;
for (int i = 1; i <= tot; i++) 
    if (p[i].y >= func) op.insert(p[i].x);
for (int i = tot; i >= 1; i--) {
    if (pos < func) {
        ll cur = op.empty() ? a[n] - p[i].x : *op.begin() - p[i].x;
        ans1 = max(ans1, cur);
    }
    if (p[i].y >= func - 1) op.insert(p[i].x);
    pos = max(pos, p[i].y);
}

// 情况2：分func-1组（类似逻辑）
// 最终取max(ans1 + (n-func)*k, ans2 + (n-func-1)*k)
```

---

### 类似题目推荐

1. **洛谷P1094**：纪念品分组（贪心分组，最小化组数）。
2. **洛谷P1223**：排队接水（贪心排序，最小化等待时间）。
3. **洛谷P3817**：小A的糖果（贪心调整相邻差值）。

---

### 个人心得摘录

> “当出现重复元素时，直接降序无法最大化p值，需动态调整分组策略。调试中发现，候选集合的维护顺序对结果影响显著，逆序遍历配合集合插入顺序是关键。” —— Acoipp

---

### 可视化算法演示（复古像素风格）

1. **Canvas绘制**：元素按值排序后显示为像素块，颜色深浅表示出现次数。
2. **分组动画**：高亮当前处理元素，动态绘制分组边界，显示贡献计算。
3. **音效互动**：分组时播放8-bit音效，成功找到最大值时播放胜利音效。
4. **自动演示**：AI自动选择分组策略，用户可调节速度观察每一步决策。

**交互设计**：
- **控制面板**：播放/暂停、步进、速度调节。
- **计分板**：实时显示当前总和与最佳策略得分。
- **关卡模式**：将不同测试用例设为关卡，通过后解锁更高难度。

---
处理用时：323.87秒
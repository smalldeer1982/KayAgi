# 题目信息

# [ARC173C] Not Median

## 题目描述

你有一个从 $1$ 到 $n$ 的整数排列 $P$ 。

对于所有 $ i=1,2,\dots,N $ ，输出满足以下所有条件的一对整数 $ (l,r) $ 的 $ r-l+1 $ 的最小值。如果不存在这样的 $ (l,r) $ ，则输出 `-1` 。

- $1 \le l \le i \le r \le N$ 。
- $r-l+1$ 是奇数。
- $ P_i $ **不是** $P$ 的子序列 $ (P_l,P_{l+1},\dots,P_r) $ 的中位数。

长度为 $ L $（奇数）的整数序列 $A$ 的中位数被定义为按升序对 $ A $ 排序后的序列 $ A' $ 的第 $ \frac{L+1}{2} $ 个值。

## 样例 #1

### 输入

```
5

1 3 5 4 2```

### 输出

```
3 3 3 5 3```

## 样例 #2

### 输入

```
3

2 1 3```

### 输出

```
-1 3 3```

## 样例 #3

### 输入

```
14

7 14 6 8 10 2 9 5 4 12 11 3 13 1```

### 输出

```
5 3 3 7 3 3 3 5 3 3 5 3 3 3```

# AI分析结果



### 综合分析与结论

**题目核心**：对排列的每个位置，快速找到包含它的最短奇数长度区间，使其不是该区间的中位数。关键在于高效判断相邻元素分布，利用贪心策略寻找最小合法区间。

**解决难点**：
1. **快速判断合法区间**：当i附近存在连续两个同侧元素时，答案必为3。
2. **边界处理**：首尾位置需特殊处理扩展方向。
3. **线性时间复杂度**：避免O(n²)暴力，通过跳跃扫描实现O(n)。

**贪心策略**：
- **核心思路**：若i左右存在两个同符号元素（均大于或均小于i），则答案3成立。否则以i为中心向两侧每次扩展两个元素，检查边界条件。
- **跳跃扫描**：当找到合法区间时，中间区域必然满足答案3，跳过重复扫描。

**可视化设计**：
- **像素风格**：用红色表示当前i，绿色/蓝色表示大于/小于i的元素。动态展示扩展过程，当检测到同色相邻块时高亮。
- **音效提示**：发现合法区间时播放清脆音效，扩展时播放步进音。
- **自动演示**：AI按贪心逻辑自动扩展，支持暂停/步进观察。

---

### 题解清单（评分≥4星）

1. **wosile（5星）**  
   - **核心**：贪心跳跃扫描，O(n)时间复杂度，代码简洁。  
   - **亮点**：通过相邻元素符号快速确定答案，边界处理巧妙。  
   - **代码片段**：
     ```cpp
     while(L>=1 || R<=n){
         if(L>1 && R<n && (a[L-1]-a[i])*(a[R+1]-a[i])>0) break;
         if(L>2 && (a[L-1]-a[i])*(a[L-2]-a[i])>0) break;
         if(R<n-1 && (a[R+1]-a[i])*(a[R+2]-a[i])>0) break;
         ans+=2, L-=2, R+=2;
     }
     ```

2. **lingziyi2025（4星）**  
   - **核心**：与wosile类似，但独立推导，代码风格清晰。  
   - **亮点**：详细注释与符号转换解释，易理解贪心逻辑。  
   - **代码片段**：
     ```cpp
     bool pd(int l,int r,int i){return 1ll*(a[l]-a[i])*(a[r]-a[i])>0;}
     // 检查l和r位置是否同符号（均大于或均小于i）
     ```

3. **Naganorhara_Yoimiya（4星）**  
   - **核心**：同贪心思路，变量命名更直观。  
   - **亮点**：函数封装条件判断，提升可读性。  
   - **代码片段**：
     ```cpp
     if(check(i)==1) break; // 封装多个条件判断
     ```

---

### 最优思路提炼

**贪心选择依据**：
1. **相邻同符号检测**：若i-1与i+1均大于（或均小于）i，则区间[i-1,i+1]合法，答案3。
2. **边界扩展策略**：每次扩展两个元素，避免偶数长度，优先检查最近的可能同符号对。

**实现技巧**：
- **符号乘积判同侧**：`(a[x]-a[i])*(a[y]-a[i])>0`快速判断两元素是否同侧。
- **跳跃式扩展**：通过L-=2和R+=2保证区间长度始终为奇数，减少无效判断。

---

### 同类型题推荐

1. **CF1005E2 Median on Subsegments (Hard Version)**  
   统计所有子数组的中位数分布，考察中位数性质与计数技巧。

2. **洛谷P1168 中位数**  
   动态维护数据流的中位数，练习堆结构应用中位数问题。

3. **LeetCode 480. Sliding Window Median**  
   滑动窗口中位数，需高效维护有序结构。

---

### 核心代码实现

**wosile题解完整代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[300005],n;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++){
        int L=i,R=i,ans=3;
        while(L>=1 || R<=n){
            if(L>1 && R<n && 1LL*(a[L-1]-a[i])*(a[R+1]-a[i])>0)break;
            if(L>2 && 1LL*(a[L-1]-a[i])*(a[L-2]-a[i])>0)break;
            if(R<n-1 && 1LL*(a[R+1]-a[i])*(a[R+2]-a[i])>0)break;
            if(i>1 && R<n && 1LL*(a[R]-a[i])*(a[R+1]-a[i])>0)break;
            if(i<n && L>1 && 1LL*(a[L]-a[i])*(a[L-1]-a[i])>0)break;
            ans+=2,L-=2,R+=2;
        }
        printf("%d ", (L>=1 || R<=n) ? ans : -1);
    }
    return 0;
}
```

---

### 可视化设计（贪心过程演示）

**HTML/JS示例**：
```html
<canvas id="canvas"></canvas>
<button onclick="toggle()">Play/Pause</button>
<script>
const colors = { mid: '#FF4136', gt: '#2ECC40', lt: '#0074D9' };
let ctx = canvas.getContext('2d'), id = 0, playing = false;

function draw(i, L, R) {
    // 绘制排列，i为中心，L/R为当前扩展边界
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let j = 1; j <= n; j++) {
        ctx.fillStyle = j === i ? colors.mid : 
            (a[j] > a[i] ? colors.gt : colors.lt);
        ctx.fillRect((j-1)*20, 0, 18, 50);
        if (j >= L && j <= R) { /* 高亮扩展区间 */ }
    }
}

function checkCondition(i, L, R) {
    // 实现贪心条件的判断，返回是否找到解
}

function step() {
    if (id >= n) return;
    let i = id, L = i, R = i, ans = 3;
    while (L >= 1 || R <= n) {
        if (checkCondition(i, L, R)) {
            playSound('success'); break;
        }
        L -= 2; R += 2; ans += 2;
        draw(i, L, R);
    }
    id++;
}
</script>
```

**交互设计**：
- **自动播放**：按帧逐步执行贪心扩展，检测到合法区间时闪烁。
- **音效**：使用Web Audio API在找到解时触发音效。
- **8位风格**：采用低分辨率色块与锯齿字体，模拟复古游戏界面。

---

**个人心得**：
- **边界优先**：首尾位置需单独处理，避免越界导致逻辑错误。
- **乘积符号技巧**：利用数值乘积快速判断同号，避免分支判断提升效率。

---
处理用时：111.29秒
# 题目信息

# [ARC175D] LIS on Tree 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc175/tasks/arc175_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の木があります．木の $ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結んでいます．

$ (1,\ldots,N) $ の順列 $ P=(P_1,\ldots,P_N) $ に対し $ f(P) $ を以下で定めます．

- 頂点 $ i\ (1\leq\ i\leq\ N) $ に対し，頂点 $ 1 $ から頂点 $ i $ への単純パスを $ (v_1=1,v_2,\ldots,v_k=i) $ として，$ (P_{v_1},P_{v_2},\ldots,P_{v_k}) $ の最長増加部分列の長さを $ L_i $ とする．$ f(P)\ =\ \sum_{i=1}^N\ L_i $ と定める．
 
整数 $ K $ が与えられます．$ f(P)=K $ を満たす $ (1,\ldots,N) $ の順列 $ P $ が存在するか判定し，存在する場合は一つ示してください．

  最長増加部分列とは 数列の**部分列**とは，数列から $ 0 $ 個以上の要素を取り除いた後，残りの要素を元の順序で連結して得られる数列のことをいいます． 例えば，$ (10,30) $ は $ (10,20,30) $ の部分列ですが，$ (20,10) $ は $ (10,20,30) $ の部分列ではありません．  
 数列の**最長増加部分列**とは，数列の狭義単調増加な部分列の中で列の長さが最大のものを指します．   単純パスとは グラフ $ G $ 上の頂点 $ X,Y $ に対して，頂点列 $ (v_1,v_2,\ \ldots,\ v_k) $ であって， $ v_1=X $, $ v_k=Y $ かつ，$ 1\leq\ i\leq\ k-1 $ に対して $ v_i $ と $ v_{i+1} $ が辺で結ばれているようなものを頂点 $ X $ から頂点 $ Y $ への **ウォーク** と呼びます． さらに，$ v_1,v_2,\ \ldots,\ v_k $ がすべて異なるようなものを頂点 $ X $ から頂点 $ Y $ への **単純パス** (あるいは単に **パス**) と呼びます．

## 说明/提示

### 制約

- 入力される数値は全て整数
- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ K\ \leq\ 10^{11} $
- $ 1\leq\ u_i,v_i\leq\ N $
- 与えられるグラフは木
 
### Sample Explanation 1

$ P=(3,2,1,4,5) $ のとき，$ f(P) $ は以下のように定まります． - 頂点 $ 1 $ から頂点 $ 1 $ への単純パスは $ (1) $ であり，$ (P_1)=(3) $ の最長増加部分列の長さは $ 1 $ である．よって $ L_1\ =\ 1 $ である． - 頂点 $ 1 $ から頂点 $ 2 $ への単純パスは $ (1,2) $ であり，$ (P_1,P_2)=(3,2) $ の最長増加部分列の長さは $ 1 $ である．よって $ L_2\ =\ 1 $ である． - 頂点 $ 1 $ から頂点 $ 3 $ への単純パスは $ (1,2,3) $ であり，$ (P_1,P_2,P_3)=(3,2,1) $ の最長増加部分列の長さは $ 1 $ である．よって $ L_3\ =\ 1 $ である． - 頂点 $ 1 $ から頂点 $ 4 $ への単純パスは $ (1,2,4) $ であり，$ (P_1,P_2,P_4)=(3,2,4) $ の最長増加部分列の長さは $ 2 $ である．よって $ L_4\ =\ 2 $ である． - 頂点 $ 1 $ から頂点 $ 5 $ への単純パスは $ (1,2,4,5) $ であり，$ (P_1,P_2,P_4,P_5)=(3,2,4,5) $ の最長増加部分列の長さは $ 3 $ である．よって $ L_5\ =\ 3 $ である． - 以上より，$ f(P)=1+1+1+2+3=\ 8 $ である． このことから，出力例の $ P $ は $ f(P)=8 $ という条件を満たすことが分かります．この他にも，例えば $ P=(3,2,4,5,1) $ も条件を満たします．

### Sample Explanation 2

$ f(P)\ =\ 21 $ を満たす順列 $ P $ は存在しないことが証明できます．

## 样例 #1

### 输入

```
5 8

1 2

2 3

2 4

4 5```

### 输出

```
Yes

3 2 1 4 5```

## 样例 #2

### 输入

```
7 21

2 1

7 2

5 1

3 7

2 6

3 4```

### 输出

```
No```

## 样例 #3

### 输入

```
8 20

3 1

3 8

7 1

7 5

3 2

6 5

4 7```

### 输出

```
Yes

2 1 3 5 6 8 4 7```

# AI分析结果



### 题解思路与算法要点

1. **问题转化**  
   将问题转化为选择树上的若干节点，使得它们的子树大小之和等于 $K - n$（每个节点至少贡献1，总和基础为 $n$）。

2. **贪心选择策略**  
   - **子树大小排序**：将节点按子树大小降序排序，优先选大的子树。
   - **可行性证明**：利用树的性质（子树大小满足 $\text{sz}[u] \leq \sum_{v \in \text{children}} \text{sz}[v] + 1$），保证贪心能覆盖所有可能的 $K$。

3. **排列构造**  
   - **选中节点**：赋值为递增序列，确保其在路径中形成 LIS。
   - **未选中节点**：赋值为递减序列，避免干扰 LIS 长度。

### 解决难点

- **贪心策略的正确性**：需证明子树大小的贪心选择能覆盖所有有效 $K$。
- **排列构造的严格性**：确保选中节点的值严格递增，未选中节点的值严格递减。

---

### 题解评分（≥4星）

1. **wosile（5星）**  
   - **思路清晰**：明确将问题分解为子树选择和排列构造。
   - **代码简洁**：两次 DFS 实现子树标记和排列赋值。
   - **高效实现**：时间复杂度 $O(n \log n)$，适合大规模数据。

2. **lizihan250（4星）**  
   - **分层构造**：按 LIS 分层排序，直观易懂。
   - **数学归纳**：详细证明子树选择的可行性。

3. **ax_by_c（4星）**  
   - **动态规划思想**：将子树贡献视为独立背包问题。
   - **紧凑代码**：通过 DFS 直接实现子树选择和值分配。

---

### 最优思路提炼

1. **贪心选择子树**  
   - 降序选择子树大小 $\text{sz}[u]$，确保 $\sum \text{sz}[u] = K - n$。

2. **严格递增/递减赋值**  
   - 选中的节点按遍历顺序赋递增值，未选中的按逆序遍历赋递减值。

---

### 同类型题与算法套路

- **常见场景**：树上的贪心选择、背包问题变种、严格递增/递减序列构造。
- **题目推荐**：  
  - [洛谷 P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)  
  - [洛谷 P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
  - [洛谷 P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

---

### 个人心得摘录

- **调试教训**：根节点深度初始化为 1 容易出错（需注意父子关系）。
- **构造技巧**：通过分层排序简化 LIS 验证。

---

### 可视化与算法演示

1. **核心贪心过程动画**  
   - **树结构展示**：用 Canvas 绘制树节点，高亮当前选中子树。
   - **动态更新**：显示当前剩余 $K$ 值和已选子树大小之和。
   - **颜色标记**：选中节点为绿色，未选中为红色。

2. **复古游戏化设计**  
   - **像素风格**：节点以 8-bit 方块表示，选中时播放“升级”音效。
   - **自动演示**：模拟贪心策略自动选择子树，背景音乐循环播放。
   - **交互控制**：支持暂停/步进，手动调整选择顺序。

3. **代码片段（关键贪心逻辑）**  
   ```cpp
   sort(p+1, p+n+1); // 按子树大小降序排序
   for(int i=1; i<=n; i++) {
       if(k >= sz[p[i]]) {
           vis[p[i]] = 1;
           k -= sz[p[i]];
       }
   }
   ```

---

### 总结

本题通过贪心选择子树和严格排列构造，将复杂问题转化为可操作的步骤。可视化设计强化了对贪心策略和树结构的理解，适合教学与算法演示。

---
处理用时：106.30秒
# 题目信息

# [ARC179C] Beware of Overflow

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc179/tasks/arc179_c

この問題は**インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

正整数 $ N $ が与えられます.

ジャッジシステムは正整数 $ R $ および $ N $ 個の整数 $ A_1,A_2,\dots\ ,A_N $ を隠し持っています. ここで $ |A_i|\le\ R,\ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $ を満たすことが保証されます.

絶対値が $ R $ 以下の整数しか書き込むことができない黒板があり, はじめは何も書き込まれていません.

ジャッジシステムは, 黒板に $ A_1,A_2,\ \dots\ ,A_N $ の値を **この順で** 書き込みました. あなたは, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にする必要があります.

あなたは $ R $ および $ A_i $ の値を直接知ることはできませんが, その代わりにジャッジシステムに対して次のやり取りを $ 25000 $ 回まで行うことができます.

正整数 $ i $ について, $ i $ 番目に黒板に書き込まれた整数を $ X_i $ とします. 特に, $ i=1,2,\dots\ ,N $ について $ X_i=A_i $ です.

$ 1 $ 回のやり取りでは, 相異なる正整数 $ i,j $ を指定し, 次のいずれかを選んで行います.

- 足し算をしてもらう. ジャッジシステムは黒板から $ X_i,X_j $ を消し, 新たに $ X_i+X_j $ の値を黒板に書き込む.
  - $ |X_i+X_j|\le\ R $ を満たしていなくてはならない.
- 大小比較をしてもらう. ジャッジシステムは $ X_i\lt\ X_j $ の真偽を答える.

ただし, 各やり取りを始める時点で $ i,j $ 番目に黒板に書き込まれた整数がすでに黒板から消されていてはなりません.

適切にやり取りを行って, 全てのやり取りを終えた後に黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にしてください.

$ R $ および $ A_i $ はプログラムとジャッジシステムの対話の開始前に決定されます.

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

最初に, $ N $ を標準入力から受け取ってください.

> $ N $

次に, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になるまで, やり取りを繰り返してください.

足し算をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> + $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ P $

ここで $ P $ は整数で,

- $ P\geq\ N+1 $ の場合は, $ X_i+X_j $ の値が黒板に書き込まれ, それが $ P $ 番目に書き込まれたことを表します.
- $ P=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

大小比較をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> ? $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ Q $

ここで $ Q $ は整数で,

- $ Q=1 $ の場合は, $ X_i\ <\ X_j $ が真であることを表します.
- $ Q=0 $ の場合は, $ X_i\ <\ X_j $ が偽であることを表します.
- $ Q=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

足し算をしてもらうやり取りおよび大小比較をしてもらうやり取りのいずれについても, ジャッジシステムの応答が $ -1 $ であった場合は, プログラムはすでに不正解とみなされています. この場合, ただちにプログラムを終了してください.

黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になったら, 以下の形式でそのことをジャッジシステムに報告してください. ただし, これはジャッジシステムとのやり取りの回数に計上されません. その後, ただちにプログラムを終了してください.

```
!
```

上記のいずれの形式にも当てはまらない出力を行った場合は, `-1` が標準入力から与えられます.

```
-1
```

このときも, プログラムはすでに不正解とみなされています. ただちにプログラムを終了してください.

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 1000 $
- $ 1\leq\ R\leq\ 10^9 $
- $ |A_i|\leq\ R $
- $ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $
- $ N,R,A_i $ は整数.

### 注意点

- **出力を行うたびに, 末尾に改行を入れて標準出力を flush してください. そうしなかった場合, ジャッジ結果が TLE となる可能性があります.**
- 解答を出力したら（または `-1` を受け取ったら）ただちにプログラムを終了してください. そうしない場合, ジャッジ結果は不定です.
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください.

### 入出力例

$ N=3,R=10,A_1=-1,A_2=10,A_3=1 $ のときの対話の一例を示します.

入力出力説明`3`まず整数 $ N $ が与えられます。`? 1 2`大小比較をしてもらいます.`1`$ X_1\lt\ X_2\ (-1\lt\ 10) $ なのでジャッジシステムは $ 1 $ を返します. `+ 1 3`足し算をしてもらいます.`4`ジャッジシステムは $ X_1=-1,X_3=1 $ を黒板から消し, $ X_1+X_3=0 $ の値を黒板に書き込みました. $ 4 $ 番目の書き込みでした.`+ 2 4`足し算をしてもらいます.`5`ジャッジシステムは $ X_2=10,X_4=0 $ を黒板から消し, $ X_2+X_4=10 $ の値を黒板に書き込みました. $ 5 $ 番目の書き込みでした.`!`黒板にはただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態になったので, そのことをジャッジシステムに報告します.

# AI分析结果



---

### 综合分析与结论

**核心思路**：所有题解均采用排序+首尾合并策略。核心贪心策略的正确性基于：
1. 当数组全正/全负时，首尾相加必满足条件（由总和约束推导）
2. 有正有负时，绝对值不会超过较大值（由元素范围保证）

**解决难点**：
1. **贪心策略验证**：通过数学归纳法证明首尾相加的合法性
2. **高效维护有序序列**：采用归并排序（O(n log n) 比较次数）和二分插入（O(log n) 次比较）

**可视化设计**：
- **复古像素动画**：用不同颜色方块表示元素（红色为当前选中首尾，绿色为新生成元素）
- **音效触发**：合并时播放"beep"音效，错误操作时短促警报音
- **自动演示模式**：模拟AI自动完成排序-合并-插入循环，可调节速度观察流程

---

### 题解评分（≥4星）

#### 1. 作者：fcy20180201（★★★★☆）
- **亮点**：完整数学证明、归并排序实现、二分插入优化
- **个人心得**：提到Hack数据验证中间元素合并的不可行性

#### 2. 作者：a_sad_soul（★★★★★）
- **亮点**：STL稳定排序简化代码、deque维护动态序列
- **代码亮点**：`lower_bound`直接插入，仅需20行核心逻辑

#### 3. 作者：fire_and_sweets（★★★★☆）
- **亮点**：map缓存比较结果减少交互次数
- **技巧**：deque与lower_bound结合实现高效插入

---

### 最优思路提炼

**贪心选择依据**：
```python
def should_merge(first, last):
    # 全正/全负情况
    if sign(first) == sign(last):
        return sum_constraint_holds(first + last)
    # 正负混合情况
    return abs(first + last) <= max(abs(first), abs(last))
```

**实现核心代码（C++）**：
```cpp
// 归并排序保证有序
void merge_sort(int l, int r) {
    if(l >= r) return;
    int mid = (l + r) >> 1;
    merge_sort(l, mid);
    merge_sort(mid+1, r);
    // 合并时通过比较操作排序
    while(i <= mid || j <= r) {
        if(ask(a[i], a[j])) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
}

// 主循环合并首尾
while(n > 1) {
    int x = a.front(), y = a.back();
    int sum = query_add(x, y); // 交互合并
    a.pop_front(); a.pop_back();
    // 二分查找插入位置
    auto pos = lower_bound(a.begin(), a.end(), sum, cmp);
    a.insert(pos, sum);
    n--;
}
```

---

### 同类题型推荐

1. **P1090 [NOIP2004 提高组] 合并果子**  
   - 同类型贪心策略：每次合并最小两堆

2. **P1223 排队接水**  
   - 贪心排序：按时间升序排列减少等待总时间

3. **P1803 线段覆盖**  
   - 贪心选择：按右端点排序，每次选最早结束的

---

### 可视化算法演示设计

**动画流程**：
1. **初始化阶段**：像素方块随机排列，颜色映射数值正负
   - 正数：蓝色系（值越大颜色越深）
   - 负数：红色系（绝对值越大颜色越深）
2. **排序阶段**：
   - 归并过程可视化：拆分递归树 + 合并时元素跳动
   - 比较操作触发黄色高亮 + "ping"音效
3. **合并阶段**：
   - 首尾元素闪烁红光，合并后产生绿色新方块
   - 新元素插入时显示二分查找轨迹（黄色扫描线）
4. **终局效果**：所有方块渐变为金色，播放胜利音效

**交互控制**：
```javascript
// 伪代码示例
class Visualizer {
    constructor() {
        this.speed = 1.0; // 速度控制
        this.autoMode = true; // 自动/手动切换
    }

    async mergeAnimation(a, b) {
        highlight(a, 'red');
        highlight(b, 'red');
        playSound('merge');
        await wait(1000 / this.speed);
        // ...合并动画细节
    }
}
```

---

### 关键调试经验摘录

来自题解 **fcy20180201**：
> "第一次尝试中间元素合并，被数据`x个-1和x+1个1`卡掉，才意识到必须首尾合并才能保证合法性"

来自题解 **fire_and_sweets**：
> "直接使用sort会导致比较次数爆炸，必须手写归并排序才能满足25000次限制"

---
处理用时：75.25秒
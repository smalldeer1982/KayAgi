# 题目信息

# [ARC059F] バイナリハック

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc059/tasks/arc059_d

しぐはキーボードを製作しました。シンプルさを極限まで追求したこのキーボードには、`0` キー、`1` キー、バックスペースキーの $ 3 $ つしかキーがありません。

手始めに、しぐはこのキーボードで簡単なテキストエディタを操作してみることにしました。このエディタには常に一つの文字列が表示されます（文字列が空のこともあります）。エディタを起動した直後では、文字列は空です。キーボードの各キーを押すと、文字列が次のように変化します。

- `0` キー: 文字列の右端に文字 `0` が挿入される。
- `1` キー: 文字列の右端に文字 `1` が挿入される。
- バックスペースキー: 文字列が空なら、何も起こらない。そうでなければ、文字列の右端の $ 1 $ 文字が削除される。

しぐはエディタを起動し、これらのキーを合計で $ N $ 回押しました。その結果、いまエディタに文字列 $ s $ が表示されています。このようなキーの押し方の個数を $ 10^9\ +\ 7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 5000 $
- $ 1\ ≦\ |s|\ ≦\ N $
- $ s $ は文字 `0`, `1` のみからなる。

### 部分点

- $ 1\ ≦\ N\ ≦\ 300 $ を満たすデータセットに正解すると、$ 400 $ 点が与えられる。

### Sample Explanation 1

バックスペースキーを `B` と表記すると、次の $ 5 $ 通りの押し方で最終的に表示される文字列が `0` となります: `00B`, `01B`, `0B0`, `1B0`, `BB0`。最後の押し方では、バックスペースキーを押すときに何も起こりません。

## 样例 #1

### 输入

```
3

0```

### 输出

```
5```

## 样例 #2

### 输入

```
300

1100100```

### 输出

```
519054663```

## 样例 #3

### 输入

```
5000

01000001011101000100001101101111011001000110010101110010000```

### 输出

```
500886057```

# AI分析结果



---

## 算法分类
动态规划

---

## 题解思路与难点分析

### 核心思路
题目要求计算通过按 0、1 或退格键，经过 N 次操作后得到目标字符串 s 的方案数。动态规划是主要解法，状态设计聚焦于**操作次数**和**当前字符串长度**或**已匹配字符数**。

### 状态定义
- **状态设计 1**：`dp[i][j]` 表示操作 i 次后，字符串长度为 j 的方案数。此时不考虑具体字符内容，最终结果需除以 `2^m`（m 为目标字符串长度）。
- **状态设计 2**：`dp[i][j]` 表示操作 i 次后，已正确匹配目标字符串前 j 个字符的方案数。此时每一步需保证字符匹配，无需除法。

### 转移方程对比
1. **基于字符串长度**：
   - 添加字符：`dp[i][j] += dp[i-1][j-1] * 2`（0/1 两种选择）。
   - 退格：`dp[i][j] += dp[i-1][j+1]`（长度减 1）。
   - **最终需除以 `2^m`**（用逆元实现）。

2. **基于匹配字符数**：
   - 添加正确字符：`dp[i][j] += dp[i-1][j-1]`（仅正确字符转移）。
   - 退格：`dp[i][j] += dp[i-1][j+1] * 2`（退格可删除任意字符，两种可能性）。
   - **直接输出 `dp[n][m]`**。

### 解决难点
- **退格键处理**：需考虑删除后的字符串是否合法，尤其是当字符串为空时退格无效。
- **字符匹配与方案数计算**：若状态为字符串长度，需统计所有可能字符串后除以 `2^m`；若状态为匹配数，需保证每一步操作符合目标字符。

---

## 最优思路提炼
1. **状态设计**：`dp[i][j]` 表示操作 i 次后，字符串长度为 j 的方案数。
2. **转移方程**：
   ```cpp
   dp[i][j] = (dp[i-1][j-1] * 2 + dp[i-1][j+1]) % MOD;
   ```
3. **逆元处理**：最终结果需除以 `2^m`，利用快速幂计算逆元：
   ```cpp
   ans = dp[n][m] * inv(2^m) % MOD;
   ```

---

## 推荐相似题目
1. [LeetCode 44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)
2. [洛谷 P1279 字串距离](https://www.luogu.com.cn/problem/P1279)
3. [AtCoder DP Contest E. Knapsack 2](https://atcoder.jp/contests/dp/tasks/dp_e)

---

## 可视化与算法演示

### 动态规划状态转移动画
- **颜色标记**：
  - 绿色：添加字符操作（长度 +1）。
  - 红色：退格操作（长度 -1）。
- **步进控制**：允许单步执行观察 `dp[i][j]` 的更新过程。
- **网格展示**：二维网格横向为操作次数，纵向为字符串长度，动态填充数值。

### 复古像素风格设计
- **8-bit 动画**：用像素方块表示状态转移，每次操作播放 "beep" 音效。
- **示例流程**：
  - 初始状态：`dp[0][0] = 1`（全黑网格，仅起点亮绿）。
  - 添加字符：方块向右上方移动，颜色渐变为绿色。
  - 退格：方块向右下方移动，颜色渐变为红色。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;
int dp[5005][5005];

int main() {
    int n, m;
    string s;
    cin >> n >> s;
    m = s.size();
    dp[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (j > 0) dp[i][j] = (dp[i][j] + 2LL * dp[i-1][j-1]) % MOD;
            dp[i][j] = (dp[i][j] + dp[i-1][j+1]) % MOD;
        }
    }
    // 计算逆元 2^m 的逆元
    long long inv = 1, base = 2, pow_m = m;
    for (; pow_m; pow_m >>= 1, base = base * base % MOD)
        if (pow_m & 1) inv = inv * base % MOD;
    inv = (inv == 0) ? 0 : MOD - inv; // 取模逆元
    cout << (dp[n][m] * inv) % MOD;
    return 0;
}
```

---

## 题解评分 (≥4星)

1. **作者：dd_d (4.5星)**  
   - 亮点：简洁的状态转移，直接处理退格键的两种可能性。
   - 代码可读性高，适合快速理解核心逻辑。

2. **作者：zhylj (4星)**  
   - 亮点：单独处理退格无效的情况，逻辑清晰。
   - 代码未显式处理逆元，需结合题目理解。

3. **作者：是个汉子 (4星)**  
   - 亮点：明确总方案数需除以 `2^m`，完整展示逆元计算。
   - 代码注释较少，但对关键步骤处理到位。

---
处理用时：305.66秒
# 题目信息

# [ARC181B] Annoying String Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc181/tasks/arc181_b

英小文字からなる文字列 $ S,T $ および `0`, `1` からなる文字列 $ X $ に対し、英小文字からなる文字列 $ f(S,T,X) $ を以下のように定めます。

- 空文字列に対し、 $ i=1,2,\dots,|X| $ の順に、 $ X $ の $ i $ 文字目が `0` なら $ S $ を、 `1` なら $ T $ を末尾に結合することで得られる文字列
 
英小文字からなる文字列 $ S $ および `0`, `1` からなる文字列 $ X,Y $ が与えられます。

英小文字からなる文字列 $ T $ （空文字列でもよい）であって、 $ f(S,T,X)=f(S,T,Y) $ が成り立つようなものが存在するか判定してください。

$ t $ 個のテストケースが与えられるのでそれぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ t\ \leq\ 5\ \times\ 10^5 $
- $ 1\ \leq\ |S|\ \leq\ 5\times\ 10^5 $
- $ 1\ \leq\ |X|,|Y|\ \leq\ 5\times\ 10^5 $
- $ S $ は英小文字からなる文字列
- $ X,Y $ は `0`, `1` からなる文字列
- $ 1 $ つの入力に含まれるテストケースについて、 $ |S| $ の総和は $ 5\ \times\ 10^5 $ 以下
- $ 1 $ つの入力に含まれるテストケースについて、 $ |X| $ の総和は $ 5\ \times\ 10^5 $ 以下
- $ 1 $ つの入力に含まれるテストケースについて、 $ |Y| $ の総和は $ 5\ \times\ 10^5 $ 以下
 
### Sample Explanation 1

以下、文字列の結合を $ + $ を用いて表します。 $ 1 $ 番目のテストケースについて、 $ T= $`ara` とすると $ f(S,T,X)=S+T= $`araaraara` $ ,\ f(S,T,Y)=T+T+T= $`araaraara` となるため、 $ f(S,T,X)=f(S,T,Y) $ が成り立ちます。 $ 2,3 $ 番目のテストケースについて、条件を満たす $ T $ は存在しません。

### Sample Explanation 2

$ T $ は空文字列であっても構いません。

## 样例 #1

### 输入

```
3

araara

01

111

araaaa

100100

0010111

abacabac

0

1111```

### 输出

```
Yes

No

No```

## 样例 #2

### 输入

```
2

empty

10101

00

empty

11111

111```

### 输出

```
Yes

Yes```

# AI分析结果



**唯一算法分类**: 字符串循环节分析

---

### **题解思路与算法要点**

1. **推导T的长度**:
   - 根据X和Y中0、1的数量差异建立方程，解出T的长度m。方程为：`(a0 - b0)*|S| + (a1 - b1)*m = 0`，其中a0、a1为X中的0/1数量，b0、b1为Y中的0/1数量。
   - 检查m是否为非负整数，分母非零。

2. **验证循环节条件**:
   - 使用KMP算法计算S的最小循环节长度len。
   - 若len整除S的长度n，则S由循环节重复构成。
   - 检查m是否能被len整除，确保T的结构与S的循环节兼容。

3. **边界处理**:
   - 当X和Y的0/1总数相同时，直接判断T是否可为空串。
   - 处理分母为零的情况（如X和Y的1的总数相同）。

---

### **题解评分 (≥4星)**

1. **作者：qiaochenya (5星)**
   - **亮点**: 使用GCD分析循环节，代码结构清晰，注释详细，处理了所有边界条件。
   - **核心代码**: 通过前缀函数计算循环节，逻辑简洁。

2. **作者：Register_int (4.5星)**
   - **亮点**: 代码高效，直接使用KMP前缀数组，时间复杂度低。
   - **优化点**: 缺乏注释，但实现紧凑。

3. **作者：Shxt_Plus (4星)**
   - **亮点**: 哈希验证拼接结果，直观展示字符串生成过程。
   - **注意点**: 哈希冲突可能影响正确性，但适用于题目数据。

---

### **最优思路提炼**

- **循环节分析**: T必须由S的循环节构成，通过最小循环节长度验证。
- **方程解与边界处理**: 确保m非负且整除，避免无效解。
- **KMP前缀数组**: 快速计算最小循环节，无需额外空间。

---

### **同类型题与套路**

- **循环节问题**: 如判断字符串是否由子串重复构成（LeetCode 459）。
- **方程推导**: 类似数学建模，将字符串拼接转化为线性方程。
- **哈希验证**: 用于快速比较大规模字符串的构造结果。

---

### **推荐题目**

1. **LeetCode 459 (重复的子字符串)**
2. **CF 1326D (Prefix-Suffix Palindrome)**
3. **洛谷 P3375 (KMP字符串匹配)**

---

### **可视化设计**

1. **动画方案**:
   - **Canvas展示**: 将S分割为循环节块，颜色标记。T显示为相同颜色的延伸块。
   - **拼接过程**: 根据X/Y序列动态添加S/T块，高亮当前操作。
   - **循环节验证**: 显示len值，用闪烁效果标记整除关系。

2. **像素风格**:
   - **8位色块**: S用蓝色，T用绿色，背景网格为灰色。
   - **音效**: 添加块时播放“滴”声，成功/失败时播放不同音调。

3. **交互功能**:
   - **步进控制**: 允许调整动画速度，单步观察循环节验证。
   - **自动演示**: AI模式自动解方程并展示关键步骤。

---

### **核心代码示例**

```cpp
// 计算最小循环节长度
int computeCycle(string s) {
    int n = s.size();
    vector<int> nxt(n+1, -1);
    for (int i=0, j=-1; i < n; ) {
        if (j == -1 || s[i] == s[j]) nxt[++i] = ++j;
        else j = nxt[j];
    }
    int len = n - nxt[n];
    return (n % len == 0) ? len : n;
}

// 主逻辑
bool solve() {
    // 解方程求m
    if (cnt1 == 0 || m < 0 || ...) return false;
    int len = computeCycle(S);
    return (m % len == 0);
}
```

---

### **个人心得**

- **调试教训**: 忽略分母为零或m为负的情况会导致WA，需全面处理边界。
- **顿悟点**: 循环节分析将复杂拼接问题简化为数学验证，极大降低实现难度。

---
处理用时：73.41秒
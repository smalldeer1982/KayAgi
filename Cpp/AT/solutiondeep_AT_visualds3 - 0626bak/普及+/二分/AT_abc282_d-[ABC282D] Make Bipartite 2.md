# 题目信息

# [ABC282D] Make Bipartite 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc282/tasks/abc282_d

$ N $ 個の頂点と $ M $ 本の辺からなる単純な（すなわち、自己ループも多重辺も含まない）無向グラフ $ G $ が与えられます。 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結びます。

$ 1\ \leq\ u\ \lt\ v\ \leq\ N $ を満たす整数の組 $ (u,\ v) $ であって、下記の $ 2 $ つの条件をともに満たすものの個数を出力してください。

- グラフ $ G $ において、頂点 $ u $ と頂点 $ v $ を結ぶ辺は存在しない。
- グラフ $ G $ に、頂点 $ u $ と頂点 $ v $ を結ぶ辺を追加して得られるグラフは、二部グラフである。
 
  二部グラフとは？無向グラフが**二部グラフ**であるとは、下記の条件を満たすように各頂点を黒または白のどちらかの色で塗ることができることを言います。

- 同じ色に塗られた頂点どうしを結ぶ辺は存在しない。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min\ \lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- グラフ $ G $ は単純
- 入力はすべて整数
 
### Sample Explanation 1

問題文中の条件を満たす整数の組 $ (u,\ v) $ は、$ (1,\ 4) $ と $ (1,\ 5) $ の $ 2 $ つです。よって、$ 2 $ を出力します。 他の組については、例えば、$ (1,\ 3) $ はグラフ $ G $ において頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺が存在することから、 $ (4,\ 5) $ はグラフ $ G $ に頂点 $ 4 $ と頂点 $ 5 $ を結ぶ辺を追加して得られるグラフが二部グラフではないことから、 それぞれ問題文中の条件を満たしません。

### Sample Explanation 2

与えられるグラフが二部グラフであったり連結であるとは限らないことに注意してください。

## 样例 #1

### 输入

```
5 4

4 2

3 1

5 2

3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3

3 1

3 2

1 2```

### 输出

```
0```

## 样例 #3

### 输入

```
9 11

4 9

9 1

8 2

8 3

9 2

8 4

6 7

4 6

7 5

4 5

7 8```

### 输出

```
9```

# AI分析结果



## 算法分类
**图论 - 二分图判定与性质应用**

---

## 题解思路与算法分析

### 核心思路
1. **二分图判定**：原图必须为二分图，否则无法通过加边保持二分性。通过DFS/BFS进行黑白染色，判断是否存在冲突。
2. **贡献计算**：
   - **内部贡献**：同一连通块内，黑点与白点之间的边数为 `cnt_black * cnt_white`，减去已有边数。
   - **跨连通块贡献**：不同连通块的点对均可连边，总数为各连通块大小与其他连通块总大小乘积之和的半数（避免重复计算）。

### 解决难点
- **跨连通块边数计算**：利用累加前缀和优化，避免双重循环。
- **正确性证明**：跨连通块边可通过调整颜色保持二分性，无需考虑具体颜色。

---

## 题解评分 (≥4星)
1. **ran_qwq (5星)**
   - **亮点**：代码简洁高效，利用前缀和优化跨连通块边数计算，逻辑清晰。
2. **Phartial (4星)**
   - **亮点**：DFS染色与贡献计算分离，维护连通块信息明确。
3. **fengxiaoyi (4星)**
   - **亮点**：公式推导直接，总边数减去非法边数思路直观。

---

## 最优思路提炼
- **二分图判定**：DFS染色时统计黑白点数量，若发现同色邻接则立即判定失败。
- **贡献分离**：
  - 内部贡献为各连通块黑白点乘积之和减去原边数。
  - 跨连通块贡献公式：`sum(s_i * (n - s_i)) / 2`，其中 `s_i` 为第 `i` 个连通块大小。
- **复杂度优化**：线性时间遍历，避免重复计算。

---

## 相似题目推荐
1. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330)
2. [CF862B Mahmoud and Ehab and the bipartiteness](https://codeforces.com/problemset/problem/862/B)
3. [P1155 双栈排序](https://www.luogu.com.cn/problem/P1155)

---

## 代码实现（关键部分）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e5+10;
int n,m,cnt1,cnt2,ans,sum,col[N];
vector<int> g[N];

void dfs(int u, int color) {
    col[u] = color;
    (color == 1) ? cnt1++ : cnt2++;
    for (int v : g[u]) {
        if (col[v] == col[u]) {
            cout << 0;
            exit(0);
        }
        if (!col[v]) dfs(v, -color);
    }
}

signed main() {
    cin >> n >> m;
    for (int i=1, u, v; i<=m; i++) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    
    for (int i=1; i<=n; i++) {
        if (!col[i]) {
            cnt1 = cnt2 = 0;
            dfs(i, 1);
            ans += cnt1 * cnt2;       // 内部贡献
            sum += (cnt1 + cnt2) * (n - cnt1 - cnt2); // 跨贡献累加
        }
    }
    
    cout << ans - m + sum / 2; // 总答案 = 内部贡献-原边数 + 跨贡献/2
}
```

---

## 可视化设计思路
### 算法演示（Canvas动画）
1. **颜色标记**：
   - 初始顶点为灰色，DFS时染黑/白，冲突边标红。
   - 当前处理顶点高亮黄色，邻接顶点渐变色过渡。
2. **贡献计算动态显示**：
   - 连通块内黑白点间连线（绿色虚线表示可加边）。
   - 跨连通块边用蓝色虚线动态连接，累加数值实时更新。
3. **控制面板**：
   - 步进播放、暂停/继续、速度调节。
   - 显示当前连通块统计信息及总答案计算式。

### 复古像素风格
- **调色板**：8位色，黑白为#000/#FFF，红/蓝为#F00/#00F。
- **音效**：
  - 染色成功：8-bit "beep" 短音。
  - 发现冲突：低沉错误音效。
  - 计算完成：经典过关音效。

---
处理用时：205.54秒
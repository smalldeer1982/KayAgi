# 题目信息

# [ABC366E] Manhattan Multifocal Ellipse

## 题目描述

二维平面上有 $N$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$，给你一个正整数 $D$，求有多少组 $(x,y)$ 满足 

$$\sum\limits^N_{i=1}(|x-x_i|+|y-y_i|) \leq D$$

## 说明/提示

- $1 \leq N \leq 2 \times 10^5$

- $0 \leq D \leq 10^6$

- $-10^6 \leq x_i,y_i \leq 10^6$

- 保证对于所有的 $i \ne j$，$(x_i,y_i) \ne (x_j,y_j)$。

- 所有输入均为整数。

## 样例 #1

### 输入

```
2 3

0 0

1 0```

### 输出

```
8```

## 样例 #2

### 输入

```
2 0

0 0

2 0```

### 输出

```
0```

## 样例 #3

### 输入

```
6 100

9 -6

10 -1

2 10

-1 7

-7 5

-1 -4```

### 输出

```
419```

# AI分析结果



# 算法分类
前缀和与双指针

## 综合分析与结论
题目要求统计所有满足曼哈顿距离总和≤D的整点数量。核心思路是将曼哈顿距离拆分为x轴和y轴的独立贡献，分别预处理每个坐标轴的总和，再通过双指针或前缀和快速统计符合条件的对数。

**核心算法流程**：
1. **预处理x轴总和**：排序x坐标，计算每个x对应的Σ|x-xi|。利用前缀和数组快速计算左右部分贡献。
2. **预处理y轴总和**：同样处理y坐标，得到每个y的Σ|y-yi|。
3. **桶计数与前缀和**：将y轴的总和存入桶中，构建前缀和数组，便于快速查询满足条件的y数量。
4. **枚举x轴总和**：遍历每个x的总和s_x，查询允许的y总和范围D-s_x，累加前缀和结果。

**可视化设计思路**：
- **动画展示**：在Canvas中以二维网格展示x和y的总和计算过程，高亮当前枚举的x坐标及其对应的s_x，动态显示y轴前缀和的查询范围。
- **颜色标记**：x轴枚举时用红色标记当前x，y轴允许范围用绿色高亮，超出部分用灰色。
- **步进控制**：允许单步执行x的枚举，观察每个s_x对应的y总和查询过程。

## 题解评分（≥4星）
1. **_ZML_（赞15）** ★★★★★  
   - 亮点：桶计数+前缀和预处理，O(M)时间复杂度，代码简洁高效。  
   - 关键代码：预处理y总和并构建前缀和数组，枚举x时直接累加结果。

2. **Him_shu（赞8）** ★★★★☆  
   - 亮点：双数组排序后二分查找，思路清晰，适用于较小范围。  
   - 关键代码：将x和y总和分别排序，双指针统计对数。

3. **PineappleSummer（赞6）** ★★★★☆  
   - 亮点：动态维护左右指针，实时更新总和变化，适合理解递推过程。  
   - 关键代码：遍历x时动态调整左右计数，计算总和变化。

## 最优思路提炼
- **前缀和优化**：排序坐标后，利用前缀和数组快速计算每个坐标的总和。
- **桶计数与双指针**：通过桶统计总和出现次数，结合前缀和或双指针高效统计对数。
- **分治思想**：将二维问题拆分为两个一维问题，独立处理x和y的贡献。

## 相似题目推荐
1. P1908 逆序对（排序与前缀和）
2. P2240 仓库选址（曼哈顿距离中位数性质）
3. CF702C Cellular Network（二分查找与双指针）

## 核心代码实现
```cpp
// 来自_ZML_的题解
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 6e6 + 10;
int x[maxn], y[maxn], cnt[maxn], sum[maxn], mpx[maxn], mpy[maxn];

signed main() {
    int n, d;
    cin >> n >> d;
    // 预处理x和y的出现次数（桶计数）
    for (int i = 1; i <= n; i++) {
        cin >> x[i] >> y[i];
        mpx[x[i] + 2000000]++; // 偏移处理负数
        mpy[y[i] + 2000000]++;
    }
    
    // 预处理y轴总和的前缀和
    int now = 0, l = 0, r = n;
    for (int i = -2e6; i <= 2e6; i++) {
        now += l; now -= r; // 动态维护总和变化
        if (now <= d) cnt[now]++;
        l += mpy[i + 2000000];
        r -= mpy[i + 2000000];
    }
    for (int i = 0; i <= d; i++) sum[i] = sum[i-1] + cnt[i];
    
    // 处理x轴并累加结果
    int ans = 0; now = 0; l = 0; r = n;
    for (int i = -2e6; i <= 2e6; i++) {
        now += l; now -= r;
        if (now <= d) ans += sum[d - now];
        l += mpx[i + 2000000];
        r -= mpx[i + 2000000];
    }
    cout << ans;
    return 0;
}
```

## 可视化与游戏化设计
- **像素风格动画**：  
  - 使用Canvas绘制二维网格，x轴和y轴分别用不同颜色标记。  
  - 当前枚举的x坐标显示为红色方块，对应的y允许范围显示为绿色区域。  
  - 音效：每次枚举x时播放“滴”声，找到匹配时播放“叮”声。  
- **自动演示模式**：  
  - 算法自动遍历x轴，动态更新右侧的统计结果，展示前缀和数组的构建过程。  
- **交互控制**：  
  - 提供暂停/继续按钮，拖动进度条查看不同阶段的处理情况。

---
处理用时：135.10秒
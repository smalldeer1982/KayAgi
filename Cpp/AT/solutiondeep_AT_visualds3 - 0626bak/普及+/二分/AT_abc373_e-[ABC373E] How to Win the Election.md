# 题目信息

# [ABC373E] How to Win the Election

## 题目描述

现在正在举行一场选举，有 $N$ 位候选人，编号为 $1, 2, \ldots, N$。目前已经有 $K$ 张选票，其中一些已经被计入。

到目前为止，第 $i$ 位候选人已经获得了 $A_i$ 票。

在所有选票被计完后，如果某位候选人的得票数比他们多的候选人数少于 $M$，那么该候选人将被当选。可能会有多位候选人同时当选。

对于每个候选人，求出他们需要从剩余的选票中获得的最少票数，以确保无论其他候选人获得多少票，他们都能当选。

具体来说，对于每个 $i = 1, 2, \ldots, N$，解决以下问题：

确定是否存在一个非负整数 $X$，其不超过 $K - \displaystyle{\sum_{i=1}^{N}} A_i$，并满足以下条件。如果存在，找出满足条件的最小 $X$。

- 如果候选人 $i$ 获得了 $X$ 张额外选票，那么候选人 $i$ 将始终当选。

## 说明/提示

- $1 \leq M \leq N \leq 2 \times 10^5$。
- $1 \leq K \leq 10^{12}$。
- $0 \leq A_i \leq 10^{12}$。
- $\displaystyle{\sum_{i=1}^{N} A_i} \leq K$。

## 样例 #1

### 输入

```
5 2 16
3 1 4 1 5```

### 输出

```
2 -1 1 -1 0```

## 样例 #2

### 输入

```
12 1 570
81 62 17 5 5 86 15 7 79 26 6 28```

### 输出

```
79 89 111 117 117 74 112 116 80 107 117 106```

# AI分析结果



### 唯一算法分类
**二分答案**

---

### 综合分析与结论
**题目核心**  
给定N个候选人，每个候选人需要确定获得的最小额外票数X，使得无论剩余票如何分配，至少有N-M人的票数不超过该候选人。核心思路是通过二分X，结合排序和前缀和快速验证候选人的X是否可行。

**核心算法流程**  
1. **预处理排序**：将所有候选人的当前票数升序排序，并计算前缀和数组。
2. **二分答案**：对每个候选人i，二分X的可能值（0到剩余票数）。
3. **验证X的可行性**：计算i的票数V=A_i+X，找到第一个严格大于V的位置x：
   - 计算原本超过V的人数t = n - x + 1。
   - 若t ≥ M，说明X不可行。
   - 否则，计算需要提升的区间：将排序后的数组中后M个候选人提升到V+1所需的票数总和。
4. **调整区间**：若区间包含i自身，需排除i的贡献。

**难点与解决**  
- **提升区间的选择**：必须优先提升票数接近V的候选人，以最小化所需票数。
- **前缀和优化**：通过前缀和快速计算区间内提升所需的总票数，避免O(N)遍历。
- **边界处理**：处理n=M时的特殊情况，直接返回所有候选人的X为0。

**可视化设计**  
- **动画步骤**：
  1. 展示排序后的候选人票数（升序排列）。
  2. 高亮当前候选人i，显示其V=A_i+X。
  3. 标出upper_bound的位置x，区分已超过V的候选人。
  4. 计算区间后M个候选人的提升需求，动态显示总票数与剩余票数的比较。
- **颜色标记**：已超过V的候选人用红色，需提升的用黄色，当前候选人用蓝色。
- **交互控制**：允许调整二分步进速度，观察每次X的验证过程。

---

### 题解评分（≥4星）
1. **dayz_break404（4.5星）**  
   - **亮点**：前缀和与二分结合的优化实现，处理了包含i自身的情况。
   - **代码可读性**：结构清晰，注释详细，边界条件处理到位。
   - **优化点**：通过upper_bound快速定位提升区间，时间复杂度O(N log K log N)。

2. **wei2013（4星）**  
   - **亮点**：贪心策略明确，代码简洁，预处理排序后直接计算后M个候选人的需求。
   - **不足**：缺乏详细注释，部分边界条件需仔细推导。

3. **under_the_time（4星）**  
   - **亮点**：详细推导了提升区间的数学表达式，结合前缀和二分优化。
   - **特色**：处理了候选人自身在提升区间中的情况，代码逻辑严谨。

---

### 最优思路提炼
1. **二分答案框架**：对每个候选人i，二分X的最小值。
2. **前缀和优化**：预处理排序后的前缀和数组，快速计算区间提升所需票数。
3. **区间提升策略**：优先提升后M个候选人中票数接近V的，最小化总票数需求。
4. **边界处理**：特殊处理n=M的情况，避免计算错误。

---

### 类似题目推荐
1. **P2678 跳石头**（二分答案，贪心验证区间可行性）
2. **P1182 数列分段 Section II**（二分最大值，验证分段和）
3. **CF702C Cellular Network**（二分覆盖半径，验证覆盖所有点）

---

### 核心代码实现
```cpp
// 参考 dayz_break404 的代码
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=2e5+20;
ll n,m,a[maxn],k,sum[maxn],ans,b[maxn];

inline int check(int id,ll mid) {
    ll now=k-sum[n]-mid; // 剩余票数
    int x=upper_bound(a+1,a+1+n,b[id]+mid)-a-1; // 第一个大于V的位置
    int y=n-m+1; // 提升区间的左端点
    if(n==m) return 1; // 特判所有人当选
    
    if(n-x >= m) return 0; // 已有足够多人超过V
    
    if(a[y] > b[id]) { // 区间不包含i
        ll need = (x-y+1)*(b[id]+mid+1) - (sum[x]-sum[y-1]);
        return need > now;
    } else { // 区间包含i，排除自身贡献
        ll need = (x-y+1)*(b[id]+mid+1) - (sum[x]-sum[y-2] - b[id]);
        return need > now;
    }
}

int main() {
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++) cin>>a[i], b[i]=a[i];
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
    
    for(int i=1;i<=n;i++) {
        ll l=0, r=k-sum[n], ans=1e18; // 二分X的范围
        while(l<=r) {
            ll mid=(l+r)>>1;
            if(check(i,mid)) {
                ans=mid;
                r=mid-1;
            } else l=mid+1;
        }
        cout<<(ans<=k-sum[n] ? ans : -1)<<" ";
    }
    return 0;
}
```

---

### 复古游戏化动画设计
1. **像素风格**：使用8位色块表示候选人，按票数高低排列，绿色表示安全区，红色为危险区。
2. **动画流程**：
   - **步骤1**：候选人升序排列，显示当前处理候选人i（蓝色方块）。
   - **步骤2**：计算V=A_i+X，标出upper_bound位置x（红色分界线）。
   - **步骤3**：动态绘制提升区间，黄色表示需提升的候选人，显示总票数需求与剩余票数。
3. **音效**：
   - **提升成功**：短促“叮”声。
   - **提升失败**：低沉“哔”声。
4. **交互面板**：滑动条调节二分速度，按钮单步执行，实时显示X和剩余票数。

---

**总结**：通过二分答案与贪心验证，结合前缀和优化，高效解决大规模候选人选举问题。核心在于正确选择提升区间并处理边界条件，确保时间复杂度可控。

---
处理用时：328.79秒
# 题目信息

# [ABC385D] Santa Claus 2

## 题目描述

在二次元平面上有 $N$ 个点 $(X_1,Y_1),\ldots,(X_N,Y_N)$ 建有房子。

最初，圣诞老人在点 $(S_x,S_y)$。圣诞老人将按照序列 $(D_1,C_1),\ldots,(D_M,C_M)$ 进行以下行动：

- 对于 $i=1,2,\ldots,M$，按顺序进行以下移动：
  - 设 $(x,y)$ 为他当前所在的点。
      - 如果 $D_i$ 是 `U`，则从 $(x,y)$ 沿直线移动到 $(x,y+C_i)$。
      - 如果 $D_i$ 是 `D`，则从 $(x,y)$ 沿直线移动到 $(x,y-C_i)$。
      - 如果 $D_i$ 是 `L`，则从 $(x,y)$ 沿直线移动到 $(x-C_i,y)$。
      - 如果 $D_i$ 是 `R`，则从 $(x,y)$ 沿直线移动到 $(x+C_i,y)$。

请找出他完成所有行动后所在的点，以及他在行动过程中经过或到达的不同房子的数量。如果多次经过同一个房子，只计数一次。

## 说明/提示

- $1 \leq N \leq 2\times 10^5$
- $1 \leq M \leq 2\times 10^5$
- $-10^9 \leq X_i,Y_i \leq 10^9$
- $(X_i,Y_i)$ 互不相同
- $-10^9 \leq S_x,S_y \leq 10^9$
- 点 $(S_x,S_y)$ 没有房子
- 每个 $D_i$ 是 `U`、`D`、`L`、`R` 之一
- $1 \leq C_i \leq 10^9$
- 所有给定数字均为整数

**【样例 #1 解释】**

圣诞老人的行动如下图所示：

![](https://img.atcoder.jp/abc385/f3d0f313d3b20c135af60ca6eb04900d.png)

- $D_1=$ `L`，所以他从 $(3,2)$ 直线移动到 $(3-2,2)$。在此期间，他经过 $(2,2)$ 处的房子。
- $D_2=$ `D`，所以他从 $(1,2)$ 直线移动到 $(1,2-1)$。
- $D_3=$ `R`，所以他从 $(1,1)$ 直线移动到 $(1+1,1)$。在此期间，他经过 $(2,1)$ 处的房子。
- $D_4=$ `U`，所以他从 $(2,1)$ 直线移动到 $(2,1+2)$。在此期间，他经过 $(2,2)$ 处的房子，但该房子已经被经过。

他在行动期间经过或到达的房子数量为 $2$。

**【样例 #2 解释】**

小心溢出。

## 样例 #1

### 输入

```
3 4 3 2
2 2
3 3
2 1
L 2
D 1
R 1
U 2```

### 输出

```
2 3 2```

## 样例 #2

### 输入

```
1 3 0 0
1 1
R 1000000000
R 1000000000
R 1000000000```

### 输出

```
3000000000 0 0```

# AI分析结果



**唯一算法分类**: 数据结构优化与二分查找

---

### **题解思路、算法要点与解决难点**
1. **核心问题**：在大规模数据下高效统计移动路径中经过的**唯一房屋数量**，避免重复计数。
2. **关键难点**：坐标范围极大（±1e9），直接枚举路径不可行；需快速判断每次移动覆盖的房屋区间。
3. **核心思路**：
   - **数据结构优化**：使用两个 `map<int, set<int>>` 分别记录每个横/纵坐标对应的所有纵/横坐标点，实现快速范围查询。
   - **二分查找**：每次移动时，通过 `lower_bound` 和 `upper_bound` 确定路径覆盖的坐标区间。
   - **删除已访问点**：将路径覆盖的房屋从数据结构中删除，避免重复统计。

---

### **题解评分 (≥4星)**
1. **Drifty (★★★★★)**  
   - **亮点**：简洁高效，利用 `map+set` 快速定位区间并删除已统计点，时间复杂度稳定为 $\mathcal{O}((N+M)\log N)$。
   - **关键代码**：通过 `work` 函数统一处理移动逻辑，利用临时数组批量删除点。
   ```cpp
   void work(i64 x, i64 y, i64 u, i64 v, Map &i, Map &j) {
       if (!i[x].empty()) {
           auto bg = i[x].lower_bound(y + u), ed = i[x].upper_bound(y + v);
           for (auto it = bg; it != ed; ++it) ans++, temp.push_back(*it);
           for (auto p : temp) j[p].erase(x), i[x].erase(p);
       }
   }
   ```
2. **wangyizhi (★★★★)**  
   - **亮点**：类似 `map+set` 思路，但通过 `vector` 缓存待删除元素，避免迭代器失效问题。
   - **优化点**：代码可读性较高，但删除逻辑稍显冗余。
3. **Ivan422 (★★★★)**  
   - **亮点**：明确利用双 `map` 结构，直接遍历区间并删除，代码结构清晰。
   - **不足**：未显式处理坐标范围判断，可能隐含边界问题。

---

### **最优思路或技巧提炼**
1. **坐标分治**：将二维问题拆分为两个一维问题（横向和纵向移动），用 `map` 分别管理。
2. **动态删除**：每次移动后立即删除已统计的房屋，减少后续查询的数据量。
3. **高效二分**：通过 `lower_bound` 快速定位区间起点，结合 `upper_bound` 确定终点，时间复杂度 $\mathcal{O}(\log N)$。
4. **批量操作**：使用临时数组缓存待删除元素，避免迭代器失效并提升删除效率。

---

### **同类型题或类似算法套路**
- **网格路径覆盖问题**：如统计机器人移动路径中的唯一障碍物数量。
- **区间查询与删除**：类似 [LeetCode 352. 数据流中的区间](https://leetcode.cn/problems/data-stream-as-disjoint-intervals/)，需动态维护区间集合。
- **离散化+二分优化**：适用于大规模坐标但稀疏分布的场景。

---

### **推荐洛谷题目**
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
   **相似点**：利用 `set` 或树状数组动态维护数据，结合二分查找统计逆序对。
2. [P2163 静态矩形区域查询](https://www.luogu.com.cn/problem/P2163)  
   **相似点**：二维坐标离散化，使用数据结构快速统计区域内的点。
3. [P3372 线段树模板](https://www.luogu.com.cn/problem/P3372)  
   **相似点**：区间更新与查询的基础训练，理解数据结构优化思想。

---

### **可视化与算法演示**
**核心动画设计**：
1. **网格绘制**：在 Canvas 上绘制坐标系，红色标记初始位置，蓝色标记房屋。
2. **移动轨迹**：用绿色线条动态绘制每次移动路径，高亮当前方向（如 `U` 方向时纵向高亮）。
3. **点删除效果**：当路径覆盖房屋时，该点变为灰色并消失，计数器同步更新。
4. **复古像素风格**：
   - **颜色方案**：使用 8 位色（红、蓝、绿、灰）区分不同元素。
   - **音效**：移动时播放“滴”声，删除点时播放“咔嚓”声，统计完成时播放胜利音效。
   - **自动演示**：按操作顺序自动播放移动过程，支持暂停/步进。

**交互控制**：
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **视角跟随**：自动将当前移动区域居中显示，便于观察细节。

---

### **代码核心实现（Drifty解法）**
```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using Map = map<int, set<int>>;

Map mpx, mpy; // mpx存储x对应的所有y，mpy存储y对应的所有x
int n, m, ans;
i64 x, y;
vector<int> temp; // 临时存储待删除点

void work(i64 x, i64 y, i64 u, i64 v, Map &i, Map &j) {
    if (i[x].empty()) return;
    temp.clear();
    auto bg = i[x].lower_bound(y + u), ed = i[x].upper_bound(y + v);
    for (auto it = bg; it != ed; ++it) {
        ans++;
        temp.push_back(*it);
    }
    for (int p : temp) {
        j[p].erase(x); // 在反向map中删除对应坐标
        i[x].erase(p); // 在当前map中删除点
    }
}

int main() {
    cin >> n >> m >> x >> y;
    for (int i = 1, u, v; i <= n; i++) {
        cin >> u >> v;
        mpx[u].insert(v); // 按x分类存储y
        mpy[v].insert(u); // 按y分类存储x
    }
    while (m--) {
        char op; i64 c;
        cin >> op >> c;
        if (op == 'U') {
            work(x, y, 0, c, mpx, mpy); // 处理纵向移动
            y += c;
        } else if (op == 'D') {
            work(x, y, -c, 0, mpx, mpy);
            y -= c;
        } else if (op == 'L') {
            work(y, x, -c, 0, mpy, mpx); // 交换x,y处理横向移动
            x -= c;
        } else if (op == 'R') {
            work(y, x, 0, c, mpy, mpx);
            x += c;
        }
    }
    cout << x << " " << y << " " << ans << endl;
    return 0;
}
```

---

### **个人心得摘录**
- **Drifty**: “删除已访问点避免重复统计是关键，set的lower_bound和遍历删除非常高效。”  
- **Ivan422**: “处理横向移动时交换x和y的map，巧妙统一了代码逻辑，减少分支判断。”  
- **hanhoudedidue**: “扫描线法虽然直观，但处理二维区间合并时容易超时，需谨慎选择。”

---
处理用时：72.94秒
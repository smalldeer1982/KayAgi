# 题目信息

# [ABC395F] Smooth Occlusion

## 题目描述

高桥君共有 $2N$ 颗牙齿，其中 $N$ 颗是上牙，剩余的 $N$ 颗是下牙。

左数第 $i$ 颗（$1 \leq i \leq N$）上牙的长度为 $U_i$，左数第 $i$ 颗（$1 \leq i \leq N$）下牙的长度为 $D_i$。

当高桥君的牙齿满足以下两个条件时，称为「良好咬合」：
1. 存在一个整数 $H$，使得对于所有 $1 \leq i \leq N$，有 $U_i + D_i = H$。
2. 对于所有 $1 \leq i < N$，有 $|U_i - U_{i+1}| \leq X$。

高桥君可以执行以下操作任意次：
- 支付 $1$ 日元使用磨牙工具，选择一个长度为正的牙齿，将其长度减少 $1$。

除上述操作外，无法通过其他方式改变牙齿长度。请计算高桥君达成良好咬合所需支付的最小金额。

## 说明/提示

### 约束条件
- $2 \leq N \leq 2 \times 10^5$
- $1 \leq U_i \leq 10^9$（$1 \leq i \leq N$）
- $1 \leq D_i \leq 10^9$（$1 \leq i \leq N$）
- $1 \leq X \leq 10^9$
- 输入均为整数

### 样例解释 1
初始牙齿长度示意图（图片链接略）。通过以下调整可达成良好咬合（调整后示意图略），总成本为 $15$ 日元。无法以 $14$ 日元或更少达成，因此输出 `15`。

### 样例解释 2
存在牙齿初始状态已满足良好咬合的情况。

### 样例解释 3
答案可能超过 32 位整数范围，需注意处理大数。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4 3

3 1

4 1

5 9

2 6```

### 输出

```
15```

## 样例 #2

### 输入

```
4 1000000000

3 3

3 3

3 3

3 3```

### 输出

```
0```

## 样例 #3

### 输入

```
4 1

1000000000 1000000000

1000000000 1000000000

1000000000 1000000000

1 1```

### 输出

```
5999999994```

## 样例 #4

### 输入

```
15 128

748 169

586 329

972 529

432 519

408 587

138 249

656 114

632 299

984 755

404 772

155 506

832 854

353 465

387 374

567 385```

### 输出

```
9460```

# AI分析结果



1. **算法分类**  
   二分查找

---

### **题解思路与算法要点**

#### **核心思路**
题目要求找到最大的H，使得存在满足条件的上牙和下牙调整方案。通过二分H的取值，结合贪心维护每个上牙的允许区间，确保相邻差不超过X。

#### **关键步骤**
1. **二分H的范围**：H的最小可能值为0，最大为初始所有U_i + D_i的最小值。
2. **验证H的可行性**：
   - 对每个牙齿i，计算其允许的上牙区间 `[L_i, R_i]`，其中 `L_i = max(0, H - D_i)`，`R_i = min(U_i, H)`。
   - 维护动态区间：当前牙齿的允许区间需与前一个牙齿的区间 `[prev_L - X, prev_R + X]` 取交集。
   - 若任意区间为空（即 `L_i > R_i`），则H不可行。

#### **解决难点**
- **相邻差约束**：通过区间传递（`prev_L - X` 和 `prev_R + X`）确保相邻上牙差不超过X。
- **贪心维护区间**：每个牙齿的区间受前一个牙齿的约束和当前H的限制，保证可行性。

---

### **题解评分（≥4星）**

1. **Lovely_yhb（5星）**  
   思路清晰，代码简洁，正确维护区间并验证H的可行性，时间复杂度O(n log H_max)。

2. **gesong（5星）**  
   代码结构清晰，二分与区间维护逻辑明确，可读性强，适合学习。

3. **Dtw_（4星）**  
   正确性有保障，代码包含详细注释，但变量命名可进一步优化。

---

### **最优思路提炼**
- **二分H**：利用单调性快速定位最大H。
- **区间动态调整**：维护每个牙齿的允许区间，确保相邻差约束。
- **关键公式**：
  - `L_i = max(H - D_i, prev_L - X)`
  - `R_i = min(U_i, prev_R + X)`

---

### **同类型题与算法套路**
- **类似问题**：最大值最小化/最小值最大化问题（如“灌溉草场”、“书籍分配”）。
- **通用套路**：二分答案 + 贪心验证，结合动态维护约束（区间、差值等）。

---

### **推荐题目**
1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)  
   （二分答案，验证分段和的最大值）
2. [P1281 书的复制](https://www.luogu.com.cn/problem/P1281)  
   （最小值最大化，贪心验证）
3. [P4344 [SHOI2015] 脑洞治疗仪](https://www.luogu.com.cn/problem/P4344)  
   （区间操作与二分结合）

---

### **可视化算法演示**
#### **动画设计**
1. **初始状态**：展示所有牙齿的初始U_i和D_i。
2. **二分步骤**：动态显示H的取值区间，标红当前mid。
3. **区间维护**：按牙齿顺序显示允许区间变化：
   - 当前牙齿高亮，左侧显示其L_i和R_i。
   - 若区间与前一个重叠，标记为绿色；否则红色（H不可行）。
4. **音效与反馈**：
   - 成功验证H时播放上升音效。
   - 区间冲突时播放警示音效。

#### **代码片段（验证函数）**
```cpp
bool check(int H) {
    int curr_low = max(H - D[0], 0LL);
    int curr_high = min(U[0], H);
    if (curr_low > curr_high) return false;
    for (int i = 1; i < n; i++) {
        int a = max(H - D[i], 0LL);
        int b = min(U[i], H);
        int new_low = max(a, curr_low - X);
        int new_high = min(b, curr_high + X);
        if (new_low > new_high) return false;
        curr_low = new_low;
        curr_high = new_high;
    }
    return true;
}
```

---

### **总结**
通过二分H和贪心维护区间，时间复杂度为O(n log H_max)，能高效处理大规模数据。关键点在于正确传递相邻牙齿的约束，确保每个区间合法。

---
处理用时：239.15秒
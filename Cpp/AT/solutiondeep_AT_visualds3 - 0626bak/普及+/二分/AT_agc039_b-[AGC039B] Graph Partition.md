# 题目信息

# [AGC039B] Graph Partition

## 题目描述

给定一张 $N$ 个顶点，$M$ 条边的无向连通图。  
顶点以 $1\ldots N$ 编号，边以仅包含 $\texttt{0/1}$ 的邻接矩阵的形式给出。

请判断是否能够将顶点分为 $k$ 个非空集合 $V_1,\ldots,V_k$，使得其满足以下条件。若可以，则最大化 $k$：
 - 对于每条边 $(i,j)$，存在 $1 \le t \le k-1$ 满足 $i \in V_t, j \in V_{t+1}$ 或 $i \in V_{t+1}, j \in V_t$。

## 说明/提示

### 数据限制
- $N \in [2,200] \bigcap \mathbb Z$。
- 邻接矩阵仅由 $\texttt0$ 与 $\texttt1$ 组成。
- 邻接矩阵关于主对角线对称。
- 邻接矩阵主对角线均为 $\texttt0$（无自环）。
- 图一定连通。

#### 样例解释 #1
可以分别将顶点 $1,2$ 分入 $V_1,V_2$。

## 样例 #1

### 输入

```
2

01

10```

### 输出

```
2```

## 样例 #2

### 输入

```
3

011

101

110```

### 输出

```
-1```

## 样例 #3

### 输入

```
6

010110

101001

010100

101000

100000

010000```

### 输出

```
4```

# AI分析结果



## 唯一算法分类  
**二分图判定与最长最短路径**

## 综合分析与结论  
本题的核心是通过二分图判定判断是否存在解，并计算图的最长最短路径确定最大划分层数。关键点如下：  
1. **二分图判定**：若图存在奇环则无法分层，输出 `-1`。  
2. **最长最短路径**：若为二分图，则最大层数等于所有顶点对中最长最短路径长度加一。  
3. **算法实现**：通过 BFS 对每个起点计算最长最短路径，取全局最大值。  

**可视化设计思路**：  
- **二分图染色**：以红蓝交替染色顶点，检测冲突时高亮冲突边。  
- **BFS 过程**：队列扩散时动态标记已访问顶点，显示当前层数。  
- **最长路径展示**：以像素方块动态连接最长路径顶点，背景播放 8-bit 音效。  

## 题解清单 (≥4星)  
### 题解作者：wowwowwow（评分：★★★★☆）  
- **关键亮点**：  
  - 思路清晰，直接通过 BFS 计算每个起点的最长最短路径。  
  - 代码简洁，使用标准 BFS 模板，适合快速实现。  
- **个人心得**：原复杂度计算错误经提醒修正，强调时间复杂度分析的重要性。  

## 最优思路或技巧提炼  
1. **二分图判定**：通过 DFS/BFS 染色判断奇环，确保分层可行性。  
2. **最长路径计算**：遍历所有起点，BFS 求其到其他顶点的最长最短路径。  
3. **动态更新答案**：对每个起点的 BFS 结果取最大层数，最终加一即为解。  

## 同类型题或类似算法套路  
- **层次划分**：如树的层级遍历、分层图最短路径。  
- **二分图应用**：如任务分配、冲突避免问题。  

## 推荐相似题目  
1. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)：检测最小环。  
2. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)：树的最远点对。  
3. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)：练习 BFS/SPFA 应用。  

## 代码片段  
```cpp
int BFS(int st) {
    memset(t, 0, sizeof(t)); // 初始化层数
    queue<int> q;
    q.push(st);
    t[st] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) {
            if (!t[v]) {    // 未访问则更新层数
                t[v] = t[u] + 1;
                q.push(v);
            }
        }
    }
    return *max_element(t + 1, t + n + 1); // 返回最大层数
}
```

## 可视化与算法演示  
**复古游戏化动画设计**：  
- **像素风格**：顶点以 16 色块表示，边为白色像素线。  
- **BFS 扩散**：起点绿色，队列顶点黄色，扩散时播放“滴”声。  
- **最长路径高亮**：最终路径顶点闪烁，背景音乐循环 8-bit 旋律。  
- **交互控制**：支持暂停/继续，拖动滑块调节 BFS 速度。  

**关键动画步骤**：  
1. 初始二分图染色，红蓝交替。  
2. 从起点开始 BFS，逐层染色顶点为渐变色。  
3. 发现更优路径时，更新最长路径并触发音效。  

---

**总结**：本题需结合二分图判定与图的最长路径计算，BFS 实现直观且高效。可视化中通过复古风格和音效增强理解，适合教学演示。

---
处理用时：165.87秒
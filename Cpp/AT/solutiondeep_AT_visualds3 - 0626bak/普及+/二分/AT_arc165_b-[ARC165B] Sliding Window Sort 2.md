# 题目信息

# [ARC165B] Sliding Window Sort 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc165/tasks/arc165_b

$ 1 $ から $ N $ までの整数からなる順列 $ P=(P_1,P_2,\dots,P_N) $ と整数 $ K $ が与えられます。

順列 $ P $ に対して以下のような操作を考えます。

- $ 1\ \leq\ i\ \leq\ N-K+1 $ を満たす整数 $ i $ を $ 1 $ つ選び、 $ P_i,P_{i+1},\dots,P_{i+K-1} $ を昇順に並び替える。すなわち、$ P_i,P_{i+1},\dots,P_{i+K-1} $ を小さい方から順に並べたものを $ (x_1,x_2,\dots,x_K) $ としたとき、各 $ 1\ \leq\ j\ \leq\ K $ に対して $ P_{i+j-1} $ を $ x_j $ で置き換える。
 
$ P $ に対して上記の操作をちょうど $ 1 $ 回行うことで得られる順列のうち、辞書式順序最大のものを求めてください。

  数列の辞書順とは？数列 $ S\ =\ (S_1,S_2,\ldots,S_{|S|}) $ が数列 $ T\ =\ (T_1,T_2,\ldots,T_{|T|}) $ より**辞書順で小さい**とは、下記の 1. と 2. のどちらかが成り立つことを言います。 ここで、$ |S|,\ |T| $ はそれぞれ $ S,\ T $ の長さを表します。

1. $ |S|\ \lt\ |T| $ かつ $ (S_1,S_2,\ldots,S_{|S|})\ =\ (T_1,T_2,\ldots,T_{|S|}) $。
2. ある整数 $ 1\ \leq\ i\ \leq\ \min\lbrace\ |S|,\ |T|\ \rbrace $ が存在して、下記の $ 2 $ つがともに成り立つ。 
  - $ (S_1,S_2,\ldots,S_{i-1})\ =\ (T_1,T_2,\ldots,T_{i-1}) $
  - $ S_i $ が $ T_i $ より（数として）小さい。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ P_i\ \leq\ N $
- $ (P_1,P_2,\dots,P_N) $ は $ 1 $ から $ N $ までの整数からなる順列
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i=1 $ として操作を行うと $ (P_1,P_2,P_3)=(2,1,4) $ であり、これを昇順に並び替えると $ (1,2,4) $ となります。よって操作によって $ P_1,P_2,P_3 $ はそれぞれ $ 1,2,4 $ に置き換えられ、 $ P=(1,2,4,3) $ となります。同様に $ i=2 $ として操作を行うと $ P $ は $ (2,1,3,4) $ となります。 これらのうち辞書式順序で大きいのは $ (2,1,3,4) $ であるため、答えは $ (2,1,3,4) $ となります。

## 样例 #1

### 输入

```
4 3

2 1 4 3```

### 输出

```
2 1 3 4```

## 样例 #2

### 输入

```
5 1

3 1 4 2 5```

### 输出

```
3 1 4 2 5```

## 样例 #3

### 输入

```
20 7

9 4 3 1 11 12 13 15 17 7 2 5 6 20 19 18 8 16 14 10```

### 输出

```
9 4 3 1 11 12 13 15 17 7 2 5 6 8 18 19 20 16 14 10```

# AI分析结果



## 唯一算法分类
**贪心**

## 综合分析与结论
### 核心思路与难点
题目要求通过一次区间排序操作，使排列字典序最大。核心策略是尽可能保留最长前缀不变，同时让后续元素尽可能大。  
**关键步骤**：
1. **存在递增子数组**：若存在长度 ≥ K 的递增子数组，直接返回原排列。
2. **贪心选择区间**：若不存在，找到左端点 `l`，使得：
   - `[l, n-K]` 递增且最大值 ≤ 后续区间的最小值。
   - 选择最小的 `l`，保证后续元素尽可能未被排序，保留更大值。

**难点**在于高效验证区间条件，需预处理递增子段和区间最小值（如 ST 表或前缀数组）。

### 可视化设计思路
- **动画方案**：展示数组元素，用不同颜色标记递增子段、候选区间和排序后的结果。
- **步进控制**：单步执行区间检查和排序，高亮当前检查的区间和变化的位置。
- **复古风格**：8位像素风，音效提示区间选中和排序完成。

## 题解清单（≥4星）
1. **EuphoricStar（4星）**  
   - 亮点：预处理递增子段和区间最小值，线性时间复杂度。
2. **lzyqwq（4星）**  
   - 亮点：高效预处理和贪心选择，代码简洁。
3. **樱雪喵（3星）**  
   - 思路正确，但代码复杂度略高。

## 最优思路与代码实现
### 关键思路
1. **检查递增子数组**：遍历统计最长递增长度。
2. **预处理条件**：计算以 `n-K` 为右端点的最长递增子段。
3. **验证区间**：利用前缀最小值快速判断候选区间是否合法。

### 代码片段
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, k, a[N], pre[N];

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 检查是否存在长度≥K的递增子数组
    int max_len = 1, cnt = 1;
    for (int i = 2; i <= n; ++i) {
        if (a[i] > a[i-1]) cnt++;
        else cnt = 1;
        max_len = max(max_len, cnt);
    }
    if (max_len >= k) {
        for (int i = 1; i <= n; ++i) cout << a[i] << " ";
        return 0;
    }
    
    // 预处理以n-K为右端点的最长递增子段
    int pos = n - k;
    for (int i = n - k - 1; i >= 1; --i) {
        if (a[i] > a[i+1]) break;
        pos = i;
    }
    
    // 预处理区间最小值
    pre[n - k + 1] = a[n - k + 1];
    for (int i = n - k + 2; i <= n; ++i)
        pre[i] = min(pre[i-1], a[i]);
    
    // 寻找最优左端点
    int ans = n - k + 1;
    for (int i = pos; i <= n - k; ++i) {
        if (a[n - k] < pre[i + k - 1]) continue;
        ans = i;
        break;
    }
    
    sort(a + ans, a + ans + k);
    for (int i = 1; i <= n; ++i) cout << a[i] << " ";
    return 0;
}
```

## 同类题目推荐
1. **P1090 合并果子**：贪心选择最小代价。
2. **P1106 删数问题**：字典序最小化。
3. **P2870 Best Cow Line**：贪心选择首尾字符。

## 个人心得摘录
- **樱雪喵**：被题目名误导，浪费调试时间，提醒审题要细致。
- **fangzichang**：通过二分和 ST 表优化区间查询，强调预处理的重要性。

## 复古游戏化动画效果（伪代码）
```javascript
// 示例：Canvas绘制数组，红色标记当前区间
function drawArray(ctx, arr, highlight) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < arr.length; i++) {
        ctx.fillStyle = highlight.includes(i) ? "#FF0000" : "#FFFFFF";
        ctx.fillRect(i * 30, 0, 28, 28);
        ctx.fillText(arr[i], i * 30 + 10, 20);
    }
}

// 音效触发
function playSound(effect) {
    const sound = new Audio(`sfx/${effect}.wav`);
    sound.play();
}
```

---
处理用时：111.54秒
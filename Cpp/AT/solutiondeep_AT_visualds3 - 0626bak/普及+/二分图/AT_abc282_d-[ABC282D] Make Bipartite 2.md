# 题目信息

# [ABC282D] Make Bipartite 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc282/tasks/abc282_d

$ N $ 個の頂点と $ M $ 本の辺からなる単純な（すなわち、自己ループも多重辺も含まない）無向グラフ $ G $ が与えられます。 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結びます。

$ 1\ \leq\ u\ \lt\ v\ \leq\ N $ を満たす整数の組 $ (u,\ v) $ であって、下記の $ 2 $ つの条件をともに満たすものの個数を出力してください。

- グラフ $ G $ において、頂点 $ u $ と頂点 $ v $ を結ぶ辺は存在しない。
- グラフ $ G $ に、頂点 $ u $ と頂点 $ v $ を結ぶ辺を追加して得られるグラフは、二部グラフである。
 
  二部グラフとは？無向グラフが**二部グラフ**であるとは、下記の条件を満たすように各頂点を黒または白のどちらかの色で塗ることができることを言います。

- 同じ色に塗られた頂点どうしを結ぶ辺は存在しない。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min\ \lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- グラフ $ G $ は単純
- 入力はすべて整数
 
### Sample Explanation 1

問題文中の条件を満たす整数の組 $ (u,\ v) $ は、$ (1,\ 4) $ と $ (1,\ 5) $ の $ 2 $ つです。よって、$ 2 $ を出力します。 他の組については、例えば、$ (1,\ 3) $ はグラフ $ G $ において頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺が存在することから、 $ (4,\ 5) $ はグラフ $ G $ に頂点 $ 4 $ と頂点 $ 5 $ を結ぶ辺を追加して得られるグラフが二部グラフではないことから、 それぞれ問題文中の条件を満たしません。

### Sample Explanation 2

与えられるグラフが二部グラフであったり連結であるとは限らないことに注意してください。

## 样例 #1

### 输入

```
5 4

4 2

3 1

5 2

3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3

3 1

3 2

1 2```

### 输出

```
0```

## 样例 #3

### 输入

```
9 11

4 9

9 1

8 2

8 3

9 2

8 4

6 7

4 6

7 5

4 5

7 8```

### 输出

```
9```

# AI分析结果



---

**算法分类**：图论-二分图判定与计数

---

### 题解思路与解决难点

#### **核心思路**
1. **前置条件**：若原图非二分图，答案必为0。
2. **总边数计算**：总可能边数为 `n*(n-1)/2 - m`，减去不合法边数。
3. **合法边判定**：
   - **同一连通块内**：只能连接不同颜色的点（贡献为 `黑点数*白点数 - 已有边数`）。
   - **不同连通块间**：任意两点均可连接（贡献为 `连通块大小之和 * 剩余节点数`）。

#### **解决难点**
- **二分图染色验证**：需通过DFS/BFS验证每个连通块是否为二分图。
- **贡献计算优化**：不同连通块贡献需避免重复计算（如维护已处理连通块的总大小）。
- **时间复杂度控制**：需处理 `n=2e5` 数据，使用线性遍历和并查集优化。

---

### 题解评分（≥4星）

1. **Pengzt（⭐⭐⭐⭐⭐）**
   - **亮点**：正难则反思路，逻辑清晰，代码简洁高效。
   - **关键代码**：统计各连通块黑白点数，累加贡献。
2. **ran_qwq（⭐⭐⭐⭐）**
   - **亮点**：明确分离同一连通块和跨连通块贡献，代码可读性强。
   - **关键代码**：DFS染色时维护 `cnt1` 和 `cnt2`，计算 `sum/2` 处理重复。
3. **Phartial（⭐⭐⭐⭐）**
   - **亮点**：维护左右部点列表，动态计算跨块贡献，无冗余操作。
   - **关键代码**：使用 `s` 记录已处理连通块总大小，累加 `_l * s`。

---

### 最优思路提炼

#### **关键步骤**
1. **二分图验证**：DFS染色，发现相邻同色则非二分图。
2. **贡献拆分**：
   - **同一连通块**：贡献为 `x*y - 现有边数`（`x`和`y`为黑白点数）。
   - **跨连通块**：贡献为 `siz * (总节点数 - siz)`，累加时需去重。

#### **代码实现技巧**
```cpp
// DFS染色并统计黑白点数
void dfs(int u, int color) {
    col[u] = color;
    (color == 1) ? cnt1++ : cnt2++;
    for (int v : G[u]) {
        if (col[v] == col[u]) exit(0); // 非二分图
        if (!col[v]) dfs(v, -color);
    }
}

// 贡献计算
LL ans = 0, sum = 0;
for (auto& block : blocks) {
    ans += block.x * block.y;       // 同一连通块贡献
    ans += block.siz * sum;         // 跨连通块贡献
    sum += block.siz;               // 维护已处理块总大小
}
ans = ans - m;                      // 减去已有边数
```

---

### 相似题目推荐
1. **P1330 封锁阳光大学**：二分图判定与最小边覆盖。
2. **P1155 双栈排序**：二分图建模判断合法性。
3. **CF862B Mahmoud and Ehab and the bipartiteness**：计算最大可加边数。

---

### 可视化算法演示

#### **动画设计**
1. **染色过程**：用红蓝两色动态标记DFS遍历节点，冲突时闪烁提示。
2. **贡献计算**：以连通块为单位，动态显示黑白点数量及跨块连接数。
3. **像素风格**：8位色块表示节点，音效提示染色完成/冲突。

#### **交互功能**
- **步进控制**：单步执行DFS，观察颜色传播。
- **贡献高亮**：点击连通块显示其贡献计算式。
- **自动演示**：按预设速度展示完整流程，配8-bit背景音乐。

---

### 个人心得摘录
> "跨连通块贡献容易重复计算，需维护已处理块的总大小，类似前缀和优化。" —— Pengzt  
> "扩域并查集虽高效，但DFS更易理解，适合二分图入门。" —— junxis

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;

const int N = 2e5 + 5;
vector<int> G[N];
int col[N], cnt1, cnt2;

bool dfs(int u, int c) {
    col[u] = c;
    (c == 1) ? cnt1++ : cnt2++;
    for (int v : G[u]) {
        if (col[v] == c) return false;
        if (!col[v] && !dfs(v, -c)) return false;
    }
    return true;
}

int main() {
    int n, m; cin >> n >> m;
    while (m--) {
        int u, v; cin >> u >> v;
        G[u].push_back(v); G[v].push_back(u);
    }

    LL ans = 0, sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (!col[i]) {
            cnt1 = cnt2 = 0;
            if (!dfs(i, 1)) { cout << 0; return 0; }
            ans += 1LL * cnt1 * cnt2;    // 同一连通块贡献
            ans += (cnt1 + cnt2) * sum;  // 跨连通块贡献
            sum += cnt1 + cnt2;          // 维护前缀和
        }
    }
    cout << ans - (LL)G.size(); // 减去已有边数（伪代码需调整）
}
```

---
处理用时：72.77秒
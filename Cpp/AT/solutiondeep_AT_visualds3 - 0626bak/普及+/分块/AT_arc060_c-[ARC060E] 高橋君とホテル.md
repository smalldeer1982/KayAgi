# 题目信息

# [ARC060E] 高橋君とホテル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc060/tasks/arc060_c

$ N $ 軒のホテルが一直線上に並んでいます。$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 番目のホテルは、座標 $ x_i $ に位置しています。

旅行者である高橋君には、次の $ 2 $ つの信念があります。

- 高橋君の $ 1 $ 日の移動距離は $ L $ を超えない。
- 高橋君は野宿をしない。すなわち、$ 1 $ 日の終わりには必ずいずれかのホテルにいなければならない。

$ Q $ 個のクエリが与えられます。$ j\,(1\ \leq\ j\ \leq\ Q) $ 番目のクエリとして、異なる $ 2 $ つの整数 $ a_j,\,b_j $ が与えられます。 各クエリについて、前述の信念をともに守った上で、高橋君が $ a_j $ 番目のホテルから $ b_j $ 番目のホテルに移動するために必要な最小日数を求めてください。 なお、高橋君が $ a_j $ 番目のホテルから $ b_j $ 番目のホテルに移動できることは保証されます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ L\ \leq\ 10^9 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ 1\ \leq\ x_i\ <\ x_2\ <\ ...\ <\ x_N\ \leq\ 10^9 $
- $ x_{i+1}\ -\ x_i\ \leq\ L $
- $ 1\ \leq\ a_j,b_j\ \leq\ N $
- $ a_j\ \neq\ b_j $
- $ N,\,L,\,Q,\,x_i,\,a_j,\,b_j $ はいずれも整数である

### 部分点

- $ N\ \leq\ 10^3 $ および $ Q\ \leq\ 10^3 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。

### Sample Explanation 1

$ 1 $ つ目のクエリでは、次のように行動することで、$ 1 $ 番目のホテルから $ 8 $ 番目のホテルへ $ 4 $ 日間で移動することができます。 - $ 1 $ 日目には、$ 1 $ 番目のホテルから $ 2 $ 番目のホテルへ移動する。この日の移動距離は $ 2 $ である。 - $ 2 $ 日目には、$ 2 $ 番目のホテルから $ 4 $ 番目のホテルへ移動する。この日の移動距離は $ 10 $ である。 - $ 3 $ 日目には、$ 4 $ 番目のホテルから $ 7 $ 番目のホテルへ移動する。この日の移動距離は $ 6 $ である。 - $ 4 $ 日目には、$ 7 $ 番目のホテルから $ 8 $ 番目のホテルへ移動する。この日の移動距離は $ 10 $ である。

## 样例 #1

### 输入

```
9

1 3 6 13 15 18 19 29 31

10

4

1 8

7 3

6 7

8 5```

### 输出

```
4

2

1

2```

# AI分析结果



## 算法分类
**倍增**

---

## 题解思路与算法要点

### 核心思路
1. **贪心策略**：每一步尽可能跳到当前能到达的最远旅馆，使总天数最小。
2. **倍增优化**：预处理每个点跳 $2^k$ 步后的位置，将单次查询的复杂度从 $O(n)$ 优化至 $O(\log n)$。

### 关键步骤
1. **预处理**：
   - 对每个旅馆 $i$，用双指针或二分找到其一步能到达的最远旅馆 $f[i][0]$。
   - 建立倍增数组 $f[i][j] = f[f[i][j-1]][j-1]$，表示从 $i$ 出发跳 $2^j$ 天后的位置。
2. **查询**：
   - 从高位到低位试跳，若当前跳跃不越界则累加天数，更新当前位置。

### 解决难点
1. **跳跃单调性**：由于旅馆坐标递增，跳跃最远位置具有单调性，确保预处理正确性。
2. **边界处理**：需处理无法直接到达终点的情况，最后一步需额外判断。

---

## 题解评分（≥4星）

### [GaryH] ★★★★★
- **亮点**：双指针预处理、代码简洁、时间复杂度严格 $O(n \log n + q \log n)$。
- **代码**：使用指针同步移动，避免二分带来的额外常数。

### [君のNOIP] ★★★★☆
- **亮点**：详细推导倍增原理，提供暴力解法对比，适合初学者理解。
- **优化**：预处理时直接使用数组缓存 $2^i$ 值，减少计算量。

### [yxy666] ★★★★☆
- **亮点**：引入类似LCA的树链抽象，提供另一种视角理解跳跃过程。
- **注意点**：代码中需特判最后一步未达终点的情况。

---

## 最优思路提炼
**关键技巧**：
1. **双指针预处理**：线性时间求出每个点的单步跳跃位置。
   ```cpp
   int l=1, r=0;
   for(; l<=n; l++){
       while(r<=n && x[r]-x[l]<=L) r++;
       f[l][0] = r-1;  // 最远能到达的位置
   }
   ```
2. **倒序倍增查询**：从高位指数向低位试跳，避免重复计算。
   ```cpp
   int ans = 0;
   for(int j=20; j>=0; j--){
       if(f[pos][j] < target){
           pos = f[pos][j];
           ans += (1<<j);
       }
   }
   if(pos < target) ans++;  // 最后一步特判
   ```

---

## 相似题目推荐
1. [P3502 弹飞绵羊](https://www.luogu.com.cn/problem/P3203)  
   **核心**：分块处理跳跃，与本题分块解法思路相通。
2. [P1613 跑路](https://www.luogu.com.cn/problem/P1613)  
   **核心**：倍增法预处理2^k距离的最短路径。
3. [CF1516D Cut](https://codeforces.com/problemset/problem/1516/D)  
   **核心**：区间划分与倍增结合，检验质因数分解特性。

---

## 算法可视化设计
**动画方案**：
1. **旅馆坐标轴**：横向排列像素方块表示旅馆，颜色深浅表示不同块。
2. **跳跃演示**：
   - **当前点**：红色高亮方块。
   - **跳跃范围**：绿色覆盖区域（长度L）。
   - **倍增跳跃**：黄色箭头显示 $2^k$ 步跳跃轨迹，伴随8-bit音效。
3. **控制面板**：
   - 步进按钮：单步执行/连续播放。
   - 速度滑块：调整动画播放速度（100ms~2s）。
   - 模式切换：对比暴力/分块/倍增的跳跃路径差异。

**复古风格**：
- **调色板**：使用FC红白机经典16色（红、绿、黄、蓝）。
- **音效**：
  - 跳跃成功：短促"哔"声（方波生成）。
  - 查询完成：上升音阶提示。
- **Canvas绘制**：旅馆用16x16像素块，跳跃路径用虚线箭头动态绘制。

---

## 核心代码实现
```cpp
// 预处理倍增数组
void preprocess() {
    for(int j=1; j<=20; j++) {
        for(int i=1; i<=n; i++) {
            f[i][j] = f[f[i][j-1]][j-1];
        }
    }
}

// 查询函数
int query(int a, int b) {
    if(a > b) swap(a, b);
    int ans = 0, pos = a;
    for(int j=20; j>=0; j--) {
        if(f[pos][j] < b) {
            ans += (1 << j);
            pos = f[pos][j];
        }
    }
    return ans + (pos < b);
}
```

---

## 个人心得摘录
> "预处理时发现边界情况处理不当导致WA，后来意识到当最远位置等于n时，后续跳跃应标记为无穷大。调试时通过小样例逐步跟踪跳跃步骤，发现未处理n的父节点导致越界。" —— [GaryH]  
> **启示**：边界值需单独验证，特别是跳跃终点为最后一个元素时。

> "最初尝试二分查询下一步位置，发现双指针线性扫描更高效。对比测试显示速度提升约40%。" —— [君のNOIP]  
> **优化**：在具有单调性的场景下，双指针往往优于二分。

---
处理用时：75.70秒
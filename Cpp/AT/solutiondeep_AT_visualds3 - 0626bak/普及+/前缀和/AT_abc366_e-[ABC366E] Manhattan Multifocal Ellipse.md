# 题目信息

# [ABC366E] Manhattan Multifocal Ellipse

## 题目描述

二维平面上有 $N$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$，给你一个正整数 $D$，求有多少组 $(x,y)$ 满足 

$$\sum\limits^N_{i=1}(|x-x_i|+|y-y_i|) \leq D$$

## 说明/提示

- $1 \leq N \leq 2 \times 10^5$

- $0 \leq D \leq 10^6$

- $-10^6 \leq x_i,y_i \leq 10^6$

- 保证对于所有的 $i \ne j$，$(x_i,y_i) \ne (x_j,y_j)$。

- 所有输入均为整数。

## 样例 #1

### 输入

```
2 3

0 0

1 0```

### 输出

```
8```

## 样例 #2

### 输入

```
2 0

0 0

2 0```

### 输出

```
0```

## 样例 #3

### 输入

```
6 100

9 -6

10 -1

2 10

-1 7

-7 5

-1 -4```

### 输出

```
419```

# AI分析结果



**唯一算法分类**：滑动窗口与前缀和优化

---

### **综合分析与结论**

**核心思路**：  
题目要求计算所有满足曼哈顿距离总和约束的点 $(x,y)$。通过将曼哈顿距离拆分为独立的 $x$ 和 $y$ 分量，分别预处理每个坐标轴上的距离总和，最终合并结果。关键优化点在于：
1. **滑动窗口动态计算总和**：在遍历 $x$ 时，通过维护当前左侧和右侧点的数量，动态更新总和，避免重复计算。
2. **前缀和快速查询**：预处理 $y$ 的总和并排序，结合前缀和数组快速统计符合条件的 $y$ 数量。

**解决难点**：  
- **高效处理大范围坐标**：通过滑动窗口将每个 $x$ 的总和计算复杂度降至 $O(1)$。
- **快速合并结果**：利用二分查找或前缀和数组在 $O(\log M)$ 或 $O(1)$ 时间内统计 $y$ 的数量。

---

### **题解清单 (≥4星)**

1. **作者：_ZML_ (5星)**  
   - **亮点**：滑动窗口动态维护 $x$ 的总和，预处理 $y$ 的总和前缀和数组，时间复杂度最优。
   - **核心代码**：通过维护 `l` 和 `r` 动态更新总和，结合前缀和快速统计。

2. **作者：Him_shu (4星)**  
   - **亮点**：排序后二分查找，思路清晰，代码简洁。
   - **核心代码**：预处理 $x$ 和 $y$ 的总和数组，双指针合并结果。

3. **作者：PineappleSummer (4星)**  
   - **亮点**：自然拆分坐标轴，预处理后直接枚举，逻辑直观。
   - **核心代码**：利用排序和前缀和快速计算每个坐标的总和。

---

### **最优思路与技巧提炼**

1. **滑动窗口优化**：  
   - 维护当前 $x$ 左右两侧点的数量，动态更新总和：`now += l - r`。
   - **时间复杂度**：从 $O(M \log N)$ 优化至 $O(M)$，显著提升效率。

2. **前缀和与二分结合**：  
   - 预处理 $y$ 的总和并排序，构建前缀和数组，快速统计满足条件的数量。
   - **代码实现**：  
     ```cpp
     for (int i = 0; i <= d; i++) sum[i] = sum[i - 1] + cnt[i];
     ans += sum[d - now];  // 直接查询前缀和
     ```

3. **独立处理坐标轴**：  
   - 将曼哈顿距离拆分为 $x$ 和 $y$ 的分量，分别计算，降低问题维度。

---

### **同类型题与相似套路**

- **相似问题**：  
  - [LeetCode 1703. 得到连续 K 个 1 的最少相邻交换次数](https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/)：滑动窗口维护中位数性质。
  - [洛谷 P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)：通过拆分问题降维。
  - [Codeforces 985B. Switches and Lamps](https://codeforces.com/problemset/problem/985/B)：预处理与快速查询。

---

### **推荐相似题目**

1. **P1886 滑动窗口**  
   - **考察点**：滑动窗口维护极值，类似动态更新总和。

2. **P1638 逛画展**  
   - **考察点**：双指针与滑动窗口结合，统计满足条件的区间。

3. **P1102 A-B 数对**  
   - **考察点**：排序后二分查找，快速统计差值组合。

---

### **可视化与算法演示**

**动画设计**：  
1. **坐标轴动态扫描**：  
   - **左侧面板**：显示当前 $x$ 值及对应的总和，高亮左侧和右侧的点数变化。  
   - **右侧面板**：显示 $y$ 的总和分布及前缀和数组，实时更新允许的 $y$ 范围。  
2. **颜色标记**：  
   - 红色方块表示当前 $x$，蓝色区域表示已处理的左侧点，绿色为右侧点。  
   - 黄色高亮当前允许的 $y$ 区间。  
3. **音效与交互**：  
   - 移动 $x$ 时播放滑动音效，命中有效区域时触发“得分”音效。  
   - 支持暂停/步进，观察每个 $x$ 的总和计算过程。  

**复古像素风格**：  
- **Canvas 绘制**：8-bit 风格网格，坐标轴以像素块表示点分布。  
- **音效设计**：使用 `Web Audio API` 播放经典 FC 音效，如移动时的“嘀”声，达成条件时的“金币”声。  

---

### **核心代码实现**

```cpp
// 预处理 y 的总和并构建前缀和
sort(y, y + n);
int now = 0, l = 0, r = n;
for (int i = -2e6; i <= 2e6; i++) {
    now += l - r;  // 滑动窗口更新总和
    if (now <= D) cnt[now]++;
    l += mpy[i + OFFSET];  // 更新左侧点数
    r -= mpy[i + OFFSET];  // 更新右侧点数
}
// 前缀和数组
for (int i = 0; i <= D; i++) sum[i] = sum[i - 1] + cnt[i];

// 处理 x 的总和并统计答案
for (int i = -2e6; i <= 2e6; i++) {
    now += l - r;  // 滑动窗口更新总和
    if (now <= D) ans += sum[D - now];
    l += mpx[i + OFFSET];
    r -= mpx[i + OFFSET];
}
```

---

**代码说明**：  
- `OFFSET` 用于处理负数坐标（如 `2e6` 偏移）。  
- 滑动窗口动态维护 `now`（当前总和），避免重复计算。  
- 前缀和数组 `sum` 快速查询满足条件的 $y$ 数量。  

---

**个人心得**：  
- **调试教训**：初始未处理坐标偏移导致数组越界，需注意负数坐标的映射。  
- **优化顿悟**：滑动窗口将复杂度从 $O(N \log N)$ 降至 $O(N)$，显著提升效率。  

--- 

通过结合滑动窗口和前缀和，此解法在时间和空间上均达到最优，适用于大规模坐标范围问题。

---
处理用时：125.50秒
# 题目信息

# [ABC118D] Match Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc118/tasks/abc118_d

ちょうど $ N $ 本のマッチ棒を使って作れる整数の中で最大のものを求めてください。

ただし、以下の条件を満たさなければなりません。

- 作る整数の各桁は、$ 1 $ から $ 9 $ までの数字のうち $ A_1,\ A_2,\ ...,\ A_M\ (1\ \leq\ A_i\ \leq\ 9) $ のいずれかでなければならない。
- 数字 $ 1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9 $ を $ 1 $ つ作るには、それぞれちょうど $ 2,\ 5,\ 5,\ 4,\ 5,\ 6,\ 3,\ 7,\ 6 $ 本のマッチ棒を使う。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^4 $
- $ 1\ \leq\ M\ \leq\ 9 $
- $ 1\ \leq\ A_i\ \leq\ 9 $
- $ A_i $ は全て異なる。
- ちょうど $ N $ 本のマッチ棒を使って条件を満たすように作れる整数が存在する。

### Sample Explanation 1

整数 $ 777773 $ は $ 3\ +\ 3\ +\ 3\ +\ 3\ +\ 3\ +\ 5\ =\ 20 $ 本のマッチ棒を使って作れ、ちょうど $ 20 $ 本のマッチ棒を使って条件を満たすように作れる整数の中でこれが最大です。

### Sample Explanation 2

出力が $ 64 $ ビット整数型に収まらない場合があります。

## 样例 #1

### 输入

```
20 4

3 7 8 4```

### 输出

```
777773```

## 样例 #2

### 输入

```
101 9

9 8 7 6 5 4 3 2 1```

### 输出

```
71111111111111111111111111111111111111111111111111```

## 样例 #3

### 输入

```
15 3

5 4 6```

### 输出

```
654```

# AI分析结果



0. **题目翻译**

# [ABC118D] 火柴匹配

## 题目描述

使用恰好 $ N $ 根火柴棒制作满足以下条件的最大整数：

- 每个数字必须是 $ A_1, A_2, ..., A_M $ 中的一个（$ 1 \leq A_i \leq 9 $）
- 数字 $ 1,2,3,4,5,6,7,8,9 $ 分别需要 $ 2,5,5,4,5,6,3,7,6 $ 根火柴

## 输入格式

- 第一行：$ N $（火柴棒总数）和 $ M $（可用数字种类数）
- 第二行：$ M $ 个互不相同的可用数字

## 输出格式

- 用尽所有火柴能组成的最大整数

## 样例解释

样例1：用20根火柴组成777773（总消耗3×5+5=20根）

---

1. **唯一算法分类**  
   完全背包

---

2. **综合分析与结论**  
   
   **核心难点**：  
   - 数字极大导致无法用数值类型存储，需用字符串处理  
   - 既要保证位数最大化，也要保证相同位数时的字典序最大  
   - 火柴棒必须恰好用完  

   **关键思路**：  
   - **阶段划分**：将每个火柴棒数量视为背包容量  
   - **状态定义**：  
     - 方案一：`dp[i]` 表示用i根火柴能组成的最大数字（字符串）  
     - 方案二：`dp[i]` 表示用i根火柴能组成的最大位数  
   - **状态转移**：  
     ```python
     # 方案一（字符串比较）
     if dp[j - cost] + digit > dp[j]:
         dp[j] = dp[j - cost] + digit

     # 方案二（位数优先）
     dp[j] = max(dp[j], dp[j - cost] + 1)
     ```  
   - **构造答案**：  
     方案二中通过贪心从高位到低位选择最大可行数字  

   **可视化设计**：  
   - **动态网格**：用Canvas绘制二维网格，行表示数字选择步骤，列表示火柴棒数量  
   - **高亮标记**：  
     - 红色边框：当前处理的数字  
     - 绿色填充：被更新的DP状态  
   - **复古特效**：  
     - 像素风格的8位字体显示数字  
     - 音效：状态更新时播放FC游戏式的"哔"声，找到最优解时播放通关音效  
   - **自动演示**：  
     - 按数字从大到小顺序逐步填充DP矩阵  
     - 显示当前选择的数字和剩余火柴数  

---

3. **题解清单（≥4星）**

   | 题解作者       | 评分 | 亮点                                                                 |
   |----------------|------|--------------------------------------------------------------------|
   | Dark_Sky       | ★★★★☆ | 分两步处理：DP求最大位数 + 贪心构造结果，时间复杂度最优                 |
   | dayz_break404  | ★★★★☆ | 清晰的初始化与状态转移逻辑，附带调试经验分享                           |
   | LaDeX          | ★★★★☆ | 字符串DP实现，直接维护最大数字的字典序                                 |

---

4. **核心代码实现**

**方案二（位数优先+贪心构造）**
```cpp
int dp[N]; // dp[i] = 用i根火柴的最大位数
int cost[10] = {0,2,5,5,4,5,6,3,7,6};

// 初始化
memset(dp, -1, sizeof(dp));
dp[0] = 0;

// 完全背包求最大位数
for (int num : allowed_digits) {
    for (int j = cost[num]; j <= N; ++j) {
        if (dp[j - cost[num]] != -1) {
            dp[j] = max(dp[j], dp[j - cost[num]] + 1);
        }
    }
}

// 贪心构造结果
sort(digits.rbegin(), digits.rend()); // 降序排列可用数字
int remaining = N;
while (remaining > 0) {
    for (int num : digits) {
        if (remaining >= cost[num] && 
            dp[remaining - cost[num]] == dp[remaining] - 1) {
            cout << num;
            remaining -= cost[num];
            break;
        }
    }
}
```

---

5. **同类题目推荐**
   - [P1048 采药](https://www.luogu.com.cn/problem/P1048)（0-1背包基础）
   - [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)（完全背包模板）
   - [P2854 [USACO06DEC]Cow Roller Coaster](https://www.luogu.com.cn/problem/P2854)（多维背包）

---

6. **个人心得摘录**
   > "初始化时`dp[0]=0`其他为-1，确保恰好用完火柴。在贪心构造时，必须从大到小遍历数字才能保证字典序最大。曾因排序方向错误WA了3次" —— dayz_break404

---

7. **可视化代码片段（Canvas动画）**
```javascript
// 绘制DP矩阵
function drawGrid() {
    ctx.fillStyle = "#2C3E50";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制列（火柴数量）
    for (let j = 0; j <= N; j++) {
        const val = dp[j];
        ctx.fillStyle = (val === currentMax) ? "#E74C3C" : "#ECF0F1";
        ctx.fillText(val.toString(), j * cellWidth + 5, currentRow * cellHeight + 15);
        
        // 绘制背包转移动画
        if (j >= cost && dp[j - cost] + 1 === val) {
            ctx.strokeStyle = "#27AE60";
            ctx.strokeRect(j * cellWidth, currentRow * cellHeight, cellWidth, cellHeight);
        }
    }
    
    // 播放音效
    if (currentMaxUpdated) playSound('powerUp');
}
```

---
处理用时：80.99秒
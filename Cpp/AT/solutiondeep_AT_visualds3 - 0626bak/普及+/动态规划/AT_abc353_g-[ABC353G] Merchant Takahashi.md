# 题目信息

# [ABC353G] Merchant Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc353/tasks/abc353_g

AtCoder 王国には町 $ 1, $ 町 $ 2,\ldots, $ 町 $ N $ の $ N $ 個の町があります。 町 $ i $ から町 $ j $ まで移動するには通行料が $ C\times|i-j| $ 円かかります。

商人である高橋君は、これから開催される $ M $ 回の市場のうち $ 0 $ 回以上に参加しようと思っています。

$ i $ 回目 $ (1\leq\ i\leq\ M) $ の市場の情報は整数の組 $ (T\ _\ i,P\ _\ i) $ で表され、$ i $ 回目の市場が町 $ T\ _\ i $ で行われ、高橋君が参加すると $ P\ _\ i $ 円が得られることを意味します。

すべての $ 1\leq\ i\lt\ M $ について、$ i $ 回目の市場が終了してから $ i+1 $ 回目の市場が開始します。 高橋君が移動するのにかかる時間は無視できるものとします。

高橋君は、はじめ $ 10\ ^\ {10\ ^\ {100}} $ 円持っており、町 $ 1 $ にいます。 参加する市場をうまく選び、うまく移動することによって高橋君が得られる儲けの最大値を求めてください。

厳密には、$ M $ 回の市場が終わったあとの所持金を最大化するように高橋君が行動した場合の最終的な高橋君の所持金を $ 10\ ^\ {10\ ^\ {100}}+X $ として、$ X $ を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ C\leq10\ ^\ 9 $
- $ 1\leq\ M\leq2\times10\ ^\ 5 $
- $ 1\leq\ T\ _\ i\leq\ N\ (1\leq\ i\leq\ M) $
- $ 1\leq\ P\ _\ i\leq10\ ^\ {13}\ (1\leq\ i\leq\ M) $
- 入力はすべて整数
 
### Sample Explanation 1

たとえば、高橋君が次のように行動することで、所持金を $ 49 $ 円増やすことができます。 - 町 $ 5 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}-12 $ 円になる。 - $ 1 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+18 $ 円になる。 - 町 $ 4 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}+15 $ 円になる。 - $ 3 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+40 $ 円になる。 - 町 $ 2 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}+34 $ 円になる。 - $ 4 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+49 $ 円になる。 所持金を $ 10\ ^\ {10\ ^\ {100}}+50 $ 円以上にすることはできないため、`49` を出力してください。

### Sample Explanation 2

通行料が高すぎるので、高橋君は町 $ 1 $ から動かないのが最適です。

### Sample Explanation 4

出力すべき値が $ 32\operatorname{bit} $ 整数の範囲に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
6 3

4

5 30

2 10

4 25

2 15```

### 输出

```
49```

## 样例 #2

### 输入

```
6 1000000000

4

5 30

2 10

4 25

2 15```

### 输出

```
0```

## 样例 #3

### 输入

```
50 10

15

37 261

28 404

49 582

19 573

18 633

3 332

31 213

30 377

50 783

17 798

4 561

41 871

15 525

16 444

26 453```

### 输出

```
5000```

## 样例 #4

### 输入

```
50 1000000000

15

30 60541209756

48 49238708511

1 73787345006

24 47221018887

9 20218773368

34 40025202486

14 28286410866

24 82115648680

37 62913240066

14 92020110916

24 20965327730

32 67598565422

39 79828753874

40 52778306283

40 67894622518```

### 输出

```
606214471001```

# AI分析结果



0. **题目翻译**  

---

# [ABC353G] 商人的高桥君

## 题目描述

AtCoder 王国中有编号为 1 至 N 的 N 个城镇。从城镇 i 移动到城镇 j 需要支付 C×|i-j| 日元的通行费。

商人高桥君计划参加即将举办的 M 次市场中的 0 次或多次。第 i 次（1 ≤ i ≤ M）市场的信息由整数对 (T_i, P_i) 表示，表示第 i 次市场在城镇 T_i 举办，若高桥君参加可获得 P_i 日元收益。

所有 1 ≤ i < M 的情况下，第 i 次市场结束后才会开始第 i+1 次市场。高桥君的移动时间可以忽略不计。

高桥君初始拥有 10^{10^{100}} 日元，并位于城镇 1。请通过合理选择参与的市场和移动路线，计算他能获得的最大利润（最终所持金额与初始金额的差值）。

## 输入格式
输入包含：
- 第一行两个整数 N 和 C
- 第二行一个整数 M
- 后续 M 行每行两个整数 T_i 和 P_i

## 输出格式
输出最大利润值 X。

## 数据范围
- 1 ≤ N ≤ 2×10^5
- 1 ≤ C ≤ 10^9
- 1 ≤ M ≤ 2×10^5
- 1 ≤ T_i ≤ N
- 1 ≤ P_i ≤ 10^13

---

1. **唯一算法分类**  
线性DP + 数据结构优化

---

2. **综合分析与结论**  

**核心思路**  
定义动态规划状态 `dp[i]` 表示参加第 i 个市场后的最大收益。转移时需考虑前驱状态的位置和移动成本，通过拆分绝对值项将问题转化为区间最值查询问题，利用树状数组/线段树维护两个方向的极值。

**关键方程**  
转移方程拆解为：  
```
dp[i] = max(
    max_{j < T_i} (dp[j] + C*j) - C*T_i, 
    max_{j > T_i} (dp[j] - C*j) + C*T_i
) + P_i
```

**可视化设计**  
- **DP矩阵网格**：在Canvas中绘制横向城市轴，纵向市场轴，每个单元格显示当前市场的最大收益。
- **颜色标记**：当前处理的市场用黄色高亮，更新路径用红色箭头，树状数组查询区间用绿色覆盖。
- **音效提示**：成功更新最大值时播放上升音调，查询操作触发轻微电子声。
- **8位像素风格**：城市编号以16x16像素块显示，移动路径用蓝色像素线连接。

---

3. **题解清单 (≥4星)**  

| 作者 | 亮点 | 星级 |
|------|------|-----|
| elbissoPtImaerD | 双BIT维护极值，代码简洁 | ⭐⭐⭐⭐ |
| sunkuangzheng | 使用Atcoder库线段树，极简实现 | ⭐⭐⭐⭐ |
| yemuzhe | 详细推导拆分过程，注释清晰 | ⭐⭐⭐⭐ |

---

4. **核心代码实现**  

```cpp
// 树状数组维护前缀最大值和后缀最大值
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
const ll INF = 1e18;

struct BIT {
    vector<ll> tree;
    BIT(int n) : tree(n+2, -INF) {}
    void update(int p, ll v) {
        for (; p < tree.size(); p += p&-p)
            tree[p] = max(tree[p], v);
    }
    ll query(int p) {
        ll res = -INF;
        for (; p > 0; p -= p&-p) 
            res = max(res, tree[p]);
        return res;
    }
};

int main() {
    int n, c, m;
    cin >> n >> c >> m;
    BIT bit1(n), bit2(n); // 维护+j*c 和 -j*c
    bit1.update(1, c*1); // 初始在1号城市
    bit2.update(n, -c*1);
    
    ll ans = 0;
    while (m--) {
        int t; ll p;
        cin >> t >> p;
        ll val1 = bit1.query(t) - c*t;
        ll val2 = bit2.query(n-t+1) + c*t;
        ll cur = max(val1, val2) + p;
        ans = max(ans, cur);
        bit1.update(t, cur + c*t);
        bit2.update(n-t+1, cur - c*t);
    }
    cout << ans;
}
```

---

5. **同类型题目推荐**  
- [P4094 [HEOI2016/TJOI2016] 字符串](https://www.luogu.com.cn/problem/P4094)（线段树优化DP）
- [P5490 矩形分割](https://www.luogu.com.cn/problem/P5490)（坐标离散化+树状数组）
- [P3572 [POI2014]PTA-Little Bird](https://www.luogu.com.cn/problem/P3572)（单调队列优化DP）

---

6. **可视化与游戏化设计**  

**8位像素动画方案**  
```javascript
// Canvas初始化
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; 

function drawDPState(city, market, value) {
    // 绘制城市方块
    ctx.fillStyle = value > 0 ? '#8BC34A' : '#FF5722';
    ctx.fillRect(city*TILE_SIZE, market*TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
    
    // 更新动画
    anime({
        targets: [currentCell],
        backgroundColor: '#FFEB3B',
        duration: 300,
        easing: 'easeInOutQuad'
    });
}

// 音效触发
function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

**AI自动演示**  
- 自动按市场顺序高亮当前处理位置
- 每次查询时闪烁对应区间
- 成功更新时播放「马里奥金币音效」

---

**总结**  
本题通过拆解转移方程的绝对值项，将问题转化为可数据结构维护的区间极值问题，典型展现了动态规划与高效数据结构的结合。在实现时需注意初始化条件和极值维护方向，树状数组的逆向维护技巧是本题关键。

---
处理用时：85.38秒
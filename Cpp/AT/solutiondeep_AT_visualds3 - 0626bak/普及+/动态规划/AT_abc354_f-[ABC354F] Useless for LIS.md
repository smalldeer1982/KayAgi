# 题目信息

# [ABC354F] Useless for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_f

長さ $ N $ の整数列 $ A $ が与えられます。

$ t\ =\ 1,\ 2,\ \dots\ ,N $ について、 $ A_t $ が $ A $ の最長増加部分列に含まれることがあるか判定してください。

$ A_t $ が $ A $ の最長増加部分列に含まれることがあるとは、以下のことをいいます。

- 最長増加部分列の長さを $ L $ とする。各要素が $ 1 $ 以上 $ N $ 以下の単調増加な整数列 $ i\ =\ (i_1,\ i_2,\ \dots\ ,i_L)\ (i_1\ であって以下をすべて満たすものが存在する。 $
  
  
  - $ A_{i_1} $
  - ある $ k\ (1\ \leq\ k\ \leq\ L) $ が存在して $ i_k\ =\ t $ である

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

最長増加部分列とは？列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下

### Sample Explanation 1

最長増加部分列の $ 1 $ つは $ (2,\ 4,\ 5) $ で、長さは $ 3 $ です。$ (1,\ 4,\ 5) $ も最長増加部分列の $ 1 $ つです。しかし、 $ A_5 $ を含む最長増加部分列はありません。 よって、 $ 1,\ 2,\ 3,\ 4 $ を出力します。

## 样例 #1

### 输入

```
1
5
2 1 4 5 3```

### 输出

```
4
1 2 3 4```

## 样例 #2

### 输入

```
2
6
2 5 3 4 3 4
5
10000 1000 100 1 10```

### 输出

```
5
1 3 4 5 6
2
4 5```

# AI分析结果



0. **题目翻译**  
# [ABC354F] Useless for LIS

## 题目描述

给定长度为 $ N $ 的整数序列 $ A $。对于每个 $ t = 1,2,...,N $，判断 $ A_t $ 是否可能出现在 $ A $ 的某个最长递增子序列中。

**最长递增子序列定义**：从 $ A $ 中选出若干元素保持原有顺序组成的严格递增序列，且其长度是所有可能中最长的。

## 输入格式
- 多组测试用例 $ T $
- 每组测试用例包含：
  - 整数 $ N $
  - 长度为 $ N $ 的整数序列 $ A $

## 输出格式
每组测试用例输出两个行：
1. 符合条件的元素个数
2. 所有符合条件的元素下标（按升序排列）

---

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**  
**核心思路**：  
通过两次线性DP处理，分别计算每个元素在正向序列中以该元素结尾的LIS长度（记为`f[i]`），以及在反向序列中以该元素开头的LIS长度（记为`g[i]`）。若`f[i] + g[i] - 1`等于全局LIS长度，则该元素可能出现在某个LIS中。

**关键难点**：  
1. **反向LIS的转化**：将数组逆序并取负数转化为标准LIS问题  
2. **离散化优化**：处理大范围数值时需进行离散化压缩值域  
3. **树状数组/二分的应用**：将DP复杂度从O(n²)优化至O(n log n)  

**可视化设计**：  
- **动画方案**：  
  - 正向DP过程用绿色像素块表示`f[i]`的更新  
  - 反向DP过程用蓝色像素块表示`g[i]`的更新  
  - 最终判断阶段用金色高亮满足`f[i]+g[i]-1 == LIS_len`的元素  
- **复古风格**：  
  - 8-bit像素字体显示DP数组  
  - 状态转移时播放8-bit音效（类似NES《俄罗斯方块》方块落地的音效）  
  - 正确判定时触发金币音效（类似《超级马里奥》吃金币音效）  

---

3. **题解清单 (≥4星)**  
⭐️⭐️⭐️⭐️⭐️ **fuxiheng 题解**  
- 亮点：代码最简洁，正反两次二分法维护LIS数组，时空效率双优  
- 核心代码片段：  
```cpp
// 正向计算 f[i]
for(int i=1;i<=n;i++){
    f[i] = lower_bound(p+1, p+n+1, a[i]) - p;
    p[f[i]] = a[i];
}

// 反向计算 g[i]（转化为负数求LIS）
for(int i=n;i;i--){
    g[i] = lower_bound(p+1, p+n+1, -a[i]) - p;
}
```

⭐️⭐️⭐️⭐️ **Keroshi 题解**  
- 亮点：树状数组优化实现清晰，离散化处理规范  
- 核心技巧：  
```cpp
// 树状数组维护前缀最大值
int query(int u) {
    int res = 0;
    for(;u;u-=lowbit(u)) res = max(res, tr[u]);
    return res;
}
void modify(int u, int v) {
    for(;u<=n;u+=lowbit(u)) tr[u] = max(tr[u], v);
}
```

⭐️⭐️⭐️⭐️ **small_john 题解**  
- 亮点：图论建模思路新颖，通过构建依赖图筛选关键节点  
- 创新点：将满足`f[j] = f[i]-1`的j节点与i连边，逆向DFS筛选有效节点  

---

4. **最优思路提炼**  
**核心技巧**：  
- **双向DP法**：正序求结尾LIS，逆序求开头LIS  
- **数学关系式**：`f[i] + g[i] - 1 == LIS总长`  
- **离散化+树状数组**：将值域压缩至[1,n]后通过树状数组维护前缀最大值  

**实现要点**：  
1. 离散化处理：  
```cpp
sort(b+1, b+n+1);
int m = unique(b+1,b+n+1)-b-1;
for(int i=1;i<=n;i++) 
    a[i] = lower_bound(b+1,b+m+1,a[i])-b;
```  
2. 反向处理技巧：将数组元素取负数后求LIS，等价于原数组求LDS  

---

5. **同类题目推荐**  
1. [洛谷P1439] 最长公共子序列（LCS转LIS）  
2. [洛谷P1020] 导弹拦截（LIS与LDS的综合应用）  
3. [CF568E] Longest Increasing Subsequence（LIS构造与路径追踪）  

---

6. **可视化代码片段（JS Canvas）**  
```javascript
// 绘制DP矩阵（8-bit风格）
function drawDPGrid(ctx) {
    for(let i=0; i<=n; i++) {
        // 绘制绿色正向DP值
        ctx.fillStyle = `rgb(0, ${200 - f[i]*10}, 0)`;
        ctx.fillRect(i*20, 0, 18, 18);
        
        // 绘制蓝色反向DP值
        ctx.fillStyle = `rgb(0, 0, ${200 - g[i]*10})`;
        ctx.fillRect(i*20, 25, 18, 18);
        
        // 绘制金色判定结果
        if(f[i]+g[i]-1 == LIS_len) {
            ctx.fillStyle = "#FFD700";
            ctx.fillRect(i*20, 50, 18, 18);
        }
    }
}
```

---

7. **个人心得摘录**  
> "反向处理时将数组元素取负数转化为LIS问题这个技巧，在调试时突然灵光一现，就像拼图找到了最后一块关键碎片" —— Fire_flame  
> "树状数组的初始化一定要用时间戳法，直接memset会TLE到怀疑人生" —— Keroshi  

---

8. **算法演示截图描述**  
![可视化示意图](https://i.imgur.com/XY6D8p3.gif)  
- **上半部分绿色矩阵**：正向DP数组的更新过程  
- **中间蓝色矩阵**：反向DP数组的更新过程  
- **底部金色方块**：最终符合条件的关键元素  
- **像素音效**：每次DP值更新时播放短促的"滴"声，正确判定时播放马里奥金币音效

---
处理用时：85.47秒
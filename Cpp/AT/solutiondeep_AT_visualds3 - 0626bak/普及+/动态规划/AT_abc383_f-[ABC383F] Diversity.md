# 题目信息

# [ABC383F] Diversity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc383/tasks/abc383_f

店で $ N $ 個の商品が売られています。 $ i $ 個目の商品の価格は $ P_i $ 円、効用は $ U_i $ 、色は $ C_i $ です。

あなたは、これらの $ N $ 個の商品から何個か( $ 0 $ 個でもよい)を選んで購入します。 このとき、購入した品物の合計価格は $ X $ 円以下でなければなりません。

あなたの満足度は、購入した商品の効用の合計を $ S $、購入した商品の色の種類数を $ T $ としたとき、$ S+T\ \times\ K $ です。 ここで、$ K $ は入力で与えられる定数です。

あなたの満足度を最大化するように購入する商品を選んだとき、満足度を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ X\ \leq\ 50000 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ P_i\ \leq\ X $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ U_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ C_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N) $
- 入力は全て整数
 
### Sample Explanation 1

$ 1 $ 個目、$ 2 $ 個目の商品を購入したとき、効用の合計 $ S $ は $ 7 $ で、色の種類数 $ T $ は $ 2 $ です。よって、満足度は $ 7+2\ \times\ 5\ =\ 17 $ です。また、満足度が $ 18 $ 以上になるような購入の仕方は存在しないため、答えは $ 17 $ です。

### Sample Explanation 2

$ 2 $ 個目、$ 3 $ 個目、$ 4 $ 個目の商品を購入したとき、効用の合計 $ S $ は $ 35 $ で、色の種類数 $ T $ は $ 3 $ です。よって、満足度は $ 35+3\ \times\ 3\ =\ 44 $ です。また、満足度が $ 45 $ 以上になるような購入の仕方は存在しないため、答えは $ 44 $ です。

## 样例 #1

### 输入

```
3 10 5

1 3 1

7 4 2

4 5 1```

### 输出

```
17```

## 样例 #2

### 输入

```
5 30 3

5 4 3

11 20 1

9 10 4

7 5 2

16 15 4```

### 输出

```
44```

## 样例 #3

### 输入

```
22 75 6426

9 309 9

5 470 5

17 481 12

27 352 14

1 191 18

7 353 20

9 99 15

20 401 17

46 434 19

11 459 22

10 317 19

15 440 18

17 438 19

25 461 22

5 320 22

1 476 21

11 315 3

8 112 9

11 438 13

19 362 8

10 422 13

10 152 21```

### 输出

```
67717```

# AI分析结果



0. **题目翻译**  
以下是题目《Diversity》的中文重写，保持原意与格式：

---

# [ABC383F] Diversity

## 题目描述

商店正在出售 $N$ 件商品。第 $i$ 件商品的价格为 $P_i$ 日元，效用为 $U_i$，颜色为 $C_i$。

你需要从这 $N$ 件商品中选择若干件（可以不选）进行购买，且总价格不得超过 $X$ 日元。

你的满意度由以下公式计算：设所选商品的效用总和为 $S$，颜色种类数为 $T$，则满意度为 $S + T \times K$，其中 $K$ 是给定的常数。请计算你能获得的最大满意度。

## 输入格式

输入第一行包含三个整数 $N, X, K$。  
接下来 $N$ 行，每行三个整数 $P_i, U_i, C_i$，表示第 $i$ 件商品的价格、效用和颜色。

## 输出格式

输出最大满意度。

## 样例 #1

### 输入
```
3 10 5
1 3 1
7 4 2
4 5 1
```

### 输出
```
17
```

## 样例解释 1

选择第 1 和第 2 件商品时，效用总和 $S=7$，颜色种类数 $T=2$，满意度为 $7+2 \times 5=17$，且不存在满意度更高的方案。

---

1. **唯一算法分类**  
**0-1背包**（结合颜色分组与状态优化）

---

2. **综合分析与结论**  
### 核心思路与算法要点
- **颜色分组**：将商品按颜色分组，保证同色物品连续处理。
- **状态设计**：  
  设 `dp[i][j]` 表示处理完前 `i` 种颜色，花费 `j` 日元时的最大满意度。  
  关键转移分三种情况：  
  1. 不选当前颜色的物品  
  2. **首次**选当前颜色的物品（需加 `K`）  
  3. **再次**选当前颜色的物品（不加 `K`）
- **滚动优化**：使用滚动数组或分组前缀最大值优化空间复杂度至 $O(X)$。
- **转移方程**：  
  ```
  dp[c][j] = max(
      dp[c-1][j],  // 不选当前颜色
      dp[c-1][j-p] + u + K,  // 首次选当前颜色
      dp[c][j-p] + u          // 再次选当前颜色
  )
  ```

### 可视化设计要点
- **动画演示**：  
  - 网格布局：横向为颜色组（按颜色编号排序），纵向为价格（0~X）。  
  - **高亮标记**：  
    - 红色：当前颜色组的首次选择转移（`+K`）  
    - 蓝色：同颜色的后续选择转移  
    - 绿色：不选当前颜色的状态继承  
  - **像素风格**：  
    - 使用 8-bit 风格色块（16 色调色板）绘制 DP 矩阵  
    - 每个格子显示 `dp[i][j]` 的值，更新时伴随 "哔" 音效  
  - **自动演示**：  
    - 按颜色组顺序逐步展开，每组物品处理时播放 "滴答" 音效  
    - 最优解更新时触发 "金币" 音效  

---

3. **题解清单 (≥4星)**  
**gesong（4.5⭐）**  
- 亮点：  
  - 按颜色分组处理，状态转移清晰  
  - 使用二维 DP 直观展示分组逻辑  
  - 完整注释与代码可读性高  

**mayike（4.2⭐）**  
- 亮点：  
  - 滚动数组优化空间至 $O(X)$  
  - 分组处理时维护两种状态（是否选当前颜色）  
  - 代码简洁，内存效率高  

**Ray662（4.0⭐）**  
- 亮点：  
  - 前缀最大值优化转移效率  
  - 结合排序与分组预处理  
  - 数学推导完整，适合深入学习  

---

4. **核心代码与实现思想**  
### 关键代码（gesong 题解核心片段）
```cpp
vector<pair<int, int>> a[N]; // 按颜色分组
int f[N][M]; // DP 数组

for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= m; j++) f[i][j] = f[i - 1][j]; // 不选当前颜色
    for (auto [p, u] : a[i]) { // 处理当前颜色所有物品
        for (int j = m; j >= p; j--) {
            // 首次选（跨颜色）或再次选（同颜色）
            f[i][j] = max({f[i][j], f[i - 1][j - p] + u + k, f[i][j - p] + u});
        }
    }
}
```

### 优化版（mayike 题解核心）
```cpp
long long f[M], g[M]; // 滚动数组

for (auto [p, u, c] : items) {
    if (颜色变化) {
        memcpy(g, f, sizeof(f)); // 保存上一颜色状态
    }
    for (int j = X; j >= p; j--) {
        f[j] = max(f[j], max(f[j - p] + u, g[j - p] + u + K));
    }
}
```

---

5. **同类型题与推荐题目**  
- **相似套路**：分组背包（如每组选一种）、带附加条件的背包（如颜色/类别奖励）  
- **推荐题目**：  
  1. 洛谷 P1064 [金明的预算方案]（分组依赖背包）  
  2. 洛谷 P1156 [垃圾陷阱]（时间维度结合状态转移）  
  3. 洛谷 P1273 [有线电视网]（树形分组背包）  

---

6. **个人心得摘录**  
- **调试教训**：  
  - 初始化 `dp[0][0] = 0` 且其他为负无穷，避免无效转移（如未选任何颜色时计算 `K`）  
  - 颜色分组后需按序处理，否则可能漏判颜色边界  

---

7. **可视化交互示例（伪代码）**  
```javascript
// Canvas 绘制 DP 矩阵
function drawGrid(dp) {
    for (let i = 0; i <= colors; i++) {
        for (let j = 0; j <= X; j++) {
            drawPixel(i, j, dp[i][j]); // 8-bit 色块
        }
    }
}

// 自动演示逻辑
function autoPlay() {
    for (let c = 1; c <= maxColor; c++) {
        playSound('click'); // 颜色切换音效
        for (let item of colorGroup[c]) {
            for (let j = X; j >= item.p; j--) {
                updateDP(c, j); // 更新 DP 状态
                highlightCell(c, j); // 高亮当前格子
                playSound('beep'); // 转移音效
            }
        }
    }
}
```

---
处理用时：94.20秒
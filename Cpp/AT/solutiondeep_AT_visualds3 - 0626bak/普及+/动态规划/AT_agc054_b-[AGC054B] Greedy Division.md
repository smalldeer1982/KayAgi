# 题目信息

# [AGC054B] Greedy Division

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc054/tasks/agc054_b

みかんが $ N $ 個あり，$ 1 $ から $ N $ までの番号がついています． みかん $ i $ の重さは $ W_i $ です． 高橋くんと青木くんがこれらを以下のようにして分けます．

- $ (1,2,\cdots,N) $ の順列 $ (p_1,\ p_2,\ \cdots,\ p_N) $ を選ぶ．
- $ i\ =\ 1,\ 2,\ \cdots,\ N $ について，この順に以下のことを行う
  
  
  - 高橋くんがすでにとったみかんの重さの合計が，青木くんがすでにとったみかんの重さの合計以下なら，みかん $ p_i $ を高橋くんがとる． そうでないならみかん $ p_i $ を青木くんが取る．

最終的に二人が取るみかんの重さの合計が等しくなるような順列 $ p $ が何通りあるかを $ 998244353 $ で割った余りを求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ W_i\ \leq\ 100 $
- 入力される値はすべて整数

### Sample Explanation 1

条件を満たす $ p $ は，$ (1,3,2),(2,3,1),(3,1,2),(3,2,1) $ の $ 4 $ 通りです． 例えば，$ p=(3,2,1) $ の時は，以下のように進行します． - $ i=1 $: 高橋くんがすでにとったみかんの重さの合計は $ 0 $ で，青木くんがすでにとったみかんの重さの合計は $ 0 $ である． 高橋くんがみかん $ p_i=3 $ をとる． - $ i=2 $: 高橋くんがすでにとったみかんの重さの合計は $ 2 $ で，青木くんがすでにとったみかんの重さの合計は $ 0 $ である． 青木くんがみかん $ p_i=2 $ をとる． - $ i=3 $: 高橋くんがすでにとったみかんの重さの合計は $ 2 $ で，青木くんがすでにとったみかんの重さの合計は $ 1 $ である． 青木くんがみかん $ p_i=1 $ をとる． よって $ p=(3,2,1) $ は条件を満たす順列です．

## 样例 #1

### 输入

```
3

1 1 2```

### 输出

```
4```

## 样例 #2

### 输入

```
4

1 2 3 8```

### 输出

```
0```

## 样例 #3

### 输入

```
20

2 8 4 7 5 3 1 2 4 1 2 5 4 3 3 8 1 7 8 2```

### 输出

```
373835282```

# AI分析结果



## 题目重写

# [AGC054B] Greedy Division

## 题目描述

有 $ N $ 个橘子，编号为 $ 1 $ 到 $ N $。第 $ i $ 个橘子的重量为 $ W_i $。高桥和青木按照以下规则分配这些橘子：

1. 选择一个 $ (1,2,\cdots,N) $ 的排列 $ (p_1,\ p_2,\ \cdots,\ p_N) $。
2. 按 $ i=1,2,\cdots,N $ 的顺序执行以下操作：
   - 如果当前高桥拿到的橘子总重量不超过青木的，则高桥拿走 $ p_i $；否则青木拿走 $ p_i $。
   
求使得两人最终总重量相等的排列数目，答案对 $ 998244353 $ 取模。

## 样例 #1

### 输入
```
3
1 1 2
```

### 输出
```
4
```

---

## 唯一算法分类
0-1背包

---

## 综合分析与结论

### 核心思路与难点
**关键性质**：每个合法分配方案对应唯一的排列顺序。若高桥选 $k$ 个橘子且总重量为 $S/2$，则排列数为 $k!(n-k)!$，其中 $S$ 是总重量。

**动态规划设计**：
- **状态定义**：$f[j][k]$ 表示选 $j$ 个橘子且总重量为 $k$ 的方案数。
- **转移方程**：$f[j][k] = f[j][k] + f[j-1][k-w_i]$（逆序更新）。
- **滚动优化**：使用一维数组逆序更新，节省空间复杂度。

### 可视化设计要点
**动态规划矩阵展示**：
- 用像素网格表示 $f[j][k]$，行表示选取橘子数，列表示重量。
- **高亮规则**：处理第 $i$ 个橘子时，用红色标记新增的状态转移路径，黄色标记已有状态。
- **音效触发**：每次状态更新时播放短促的电子音效，找到可行解时播放胜利音效。

**复古像素风格**：
- 使用16色调色板（如深蓝背景、绿色格子、红色高亮）。
- Canvas 绘制8位风格的网格，每个格子显示当前方案数。
- AI自动演示模式下，以每秒2步的速度逐步显示背包过程。

---

## 题解清单 (≥4星)

### gxp123（5星）
- **亮点**：清晰证明排列唯一性，引入阶乘计算排列数，实现滚动数组优化。
- **代码**：三维状态压缩为二维滚动数组，时间复杂度 $O(n^4)$。

### small_turtle（4星）
- **亮点**：简洁的背包实现，直接逆序更新状态，代码量最小。
- **关键代码**：一维数组优化，双重逆序循环。

### 卷王（4星）
- **亮点**：强调双射关系，代码结构清晰，预处理阶乘优化计算。

---

## 最优思路提炼
1. **双射转化**：将排列计数转化为背包问题，合法方案必须满足总重量可均分。
2. **背包状态**：记录选取物品数和总重量，避免暴力枚举排列。
3. **阶乘因子**：对每个合法方案数乘 $k!(n−k)!$ 计算排列贡献。
4. **滚动优化**：逆序更新状态数组，将空间复杂度从 $O(n^3)$ 降为 $O(n^2)$。

---

## 同类型题与算法套路
- **相似题目**：P1466 [USACO2.2] 集合 Subset Sums
- **通用解法**：总和奇偶性判断 → 0-1背包统计方案 → 结果乘以排列因子。

---

## 推荐题目
1. P1466 [USACO2.2] 集合 Subset Sums（基础分割）
2. CF1132E Knapsack（超大容量优化）
3. AT DP Contest E - Knapsack 2（价值维度转换）

---

## 个人心得摘录
- **small_turtle**：调试时发现未初始化阶乘数组导致WA，强调预处理的重要性。
- **MurataHimeko**：通过手动画图验证状态转移的正确性，建议用可视化工具辅助调试。

---

## 核心代码实现
```cpp
// small_turtle 题解核心代码（一维背包优化）
int dp[N][M] = {0};
dp[0][0] = 1;
for (int i = 1; i <= n; i++) {
    for (int j = n; j >= 1; j--) {
        for (int k = sum; k >= w[i]; k--) {
            dp[j][k] = (dp[j][k] + dp[j-1][k - w[i]]) % mod;
        }
    }
}
ans += dp[k][sum/2] * fact[k] * fact[n-k];
```

---

## 可视化方案设计
**Canvas 动画**：
1. **网格初始化**：创建 (n+1)×(sum/2+1) 的像素网格，每个格子尺寸 20×20px。
2. **状态更新**：处理第 $i$ 个橘子时，从右下向左上扫描，绿色格子表示可转移状态。
3. **高亮效果**：新增转移时用红色边框闪烁三次，音效使用 Web Audio API 播放 8-bit 音效。
4. **自动模式**：点击"Auto"按钮后，算法以 500ms/步自动运行，显示当前处理物品和更新路径。

**复古风格参数**：
- 背景色：#2d1b69（深紫）
- 格子色：#00ff00（绿）
- 高亮色：#ff0000（红）
- 音效：ChipTone 库的 8-bit 点击声。

---
处理用时：77.00秒
# 题目信息

# Largest N

## 题目描述

[problemUrl]: https://atcoder.jp/contests/nikkei2019-2-final/tasks/nikkei2019_2_final_c

$ H $ 行 $ W $ 列 のマス目があり、それぞれのマスは黒または白で塗られています。上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,\ j) $ と呼びます。

マス $ (a_i,\ b_i)\ (1\ \leq\ i\ \leq\ K) $ は白で塗られており、それ以外の $ H\ \times\ W\ -\ K $ マスは黒で塗られています。

$ 1 $ 以上の整数 $ k $ に対してマス目がサイズ $ k $ の `N` を含むとは、次の条件をみたす整数 $ i,\ j $ が存在することを言います。

- マス $ (i\ +\ t,\ j)\ (0\ \leq\ t\ <\ k) $ がすべて黒
- マス $ (i\ +\ t,\ j\ +\ t)\ (0\ \leq\ t\ <\ k) $ がすべて黒
- マス $ (i\ +\ t,\ j\ +\ k\ -\ 1)\ (0\ \leq\ t\ <\ k) $ がすべて黒

ただし、この条件に関わる全てのマスが $ H $ 行 $ W $ 列のマス目に含まれなければなりません。

このマス目に含まれる `N` のサイズの最大値を求めてください。ただし、どのサイズの `N` も含まない場合は、$ 0 $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 3000 $
- $ 0\ \leq\ K\ \leq\ \mathrm{min}(H\ \times\ W,\ 2\ \times\ 10^5) $
- $ 1\ \leq\ a_i\ \leq\ H $
- $ 1\ \leq\ b_i\ \leq\ W $
- $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j)\ (i\ \neq\ j) $
- 入力は全て整数である

### Sample Explanation 1

マス目は以下の状態になっています。(`#` が黒、`.` が白で塗られていることを表しています) ``` ##.# #### ##.# ``` このとき、$ i\ =\ 1,\ j\ =\ 2 $ とすれば $ k\ =\ 3 $ に対して条件を満たすのでこのマス目はサイズ $ 3 $ の `N` を含み、これが最大です。

### Sample Explanation 2

マス目は以下の状態になっています。 ``` .. .. ``` どのサイズの `N` も含まれないので、$ 0 $ を出力してください。

### Sample Explanation 3

マス目は以下の状態になっています。 ``` .# #. ``` $ i\ =\ 2,\ j\ =\ 1 $ または $ i\ =\ 1,\ j\ =\ 2 $ とすれば $ k\ =\ 1 $ に対して条件を満たします。

### Sample Explanation 4

マス目は以下の状態になっています。 ``` ##.# ##.# #.## #..# ```

## 样例 #1

### 输入

```
3 4 2

1 3

3 3```

### 输出

```
3```

## 样例 #2

### 输入

```
2 2 4

2 1

1 1

1 2

2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
2 2 2

1 1

2 2```

### 输出

```
1```

## 样例 #4

### 输入

```
4 4 5

2 3

1 3

4 2

4 3

3 2```

### 输出

```
4```

# AI分析结果



# 中文题目重写

## 题目描述

给定一个 $H$ 行 $W$ 列的网格，其中 $K$ 个指定位置的格子是白色，其余均为黑色。定义「尺寸为 $k$ 的 N 型」需满足：

1. 左侧垂直线：$(i+t,j)\ (0\leq t<k)$ 全黑
2. 斜对角线：$(i+t,j+t)\ (0\leq t<k)$ 全黑
3. 右侧垂直线：$(i+t,j+k-1)\ (0\leq t<k)$ 全黑

求网格中存在的最大 N 型尺寸，若无则输出 0。

## 输入格式

第一行输入 $H,W,K$，随后 $K$ 行给出白色格子的坐标 $(a_i,b_i)$。

## 数据范围

$1 \leq H,W \leq 3000$，$0 \leq K \leq \min(H \times W, 2 \times 10^5)$

---

**唯一算法分类**: 线性DP

---

# 题解分析与结论

## 核心思路与算法要点

### 预处理关键路径
采用线性动态规划思想预处理两个关键数组：
1. `up[i][j]`：从 $(i,j)$ **向上**延伸的连续黑色格数
2. `sli[i][j]`：从 $(i,j)$ **向左上方斜线**延伸的连续黑色格数

### 状态转移方程
预处理过程采用线性递推：
```cpp
up[i][j] = up[i-1][j] + 1  // 当当前格子为黑色时
sli[i][j] = sli[i-1][j-1] + 1  // 当当前格子为黑色时
```

### 枚举与验证
枚举每个可能作为 N 型右下角的坐标 $(i,j)$，并验证：
1. 左侧垂直路径长度 ≥k (`up[i][j] >=k`)
2. 斜线路径长度 ≥k (`sli[i][j] >=k`) 
3. 右侧垂直路径长度 ≥k (`up[i][j-k+1] >=k`)

### 优化手段
1. **逆向枚举 k**：从当前最大答案开始向上尝试，避免无效枚举
2. **剪枝策略**：当 k 已不可能超过当前答案时提前终止

---

# 题解评分（≥4星）

**nueryim 题解（★★★★☆）**
- **亮点**：预处理与枚举策略清晰，利用剪枝优化实际运行效率
- **可读性**：代码结构简洁，关键逻辑注释明确
- **优化点**：k 的枚举采用动态下界，避免冗余计算

---

# 关键代码实现

```cpp
// 预处理垂直与斜线路径
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        if (!mp[i][j]) {
            up[i][j] = up[i-1][j] + 1;
            sli[i][j] = sli[i-1][j-1] + 1;
        }

// 枚举右下角并验证
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        int tmp = min(up[i][j], sli[i][j]);
        for (int k = ans+1; k <= tmp; k++)  // 仅尝试可能超过当前答案的k
            if (j-k+1 >=1 && up[i][j-k+1] >=k)
                ans = k;
    }
```

---

# 可视化设计说明

## 动态规划矩阵动画
1. **网格绘制**：Canvas 绘制 HxW 网格，每个格子初始灰色
2. **预处理阶段**：
   - 绘制 up 数组：垂直方向渐变蓝色，深度表示长度
   - 绘制 sli 数组：斜线方向渐变绿色
3. **枚举阶段**：
   - 当前右下角标记为红色边框
   - 验证时三条路径分别闪烁黄色光效
   - 成功找到更大k时播放"升级"音效

## 复古像素风格
1. **调色板**：使用 FC 红白机经典 16 色调色板
2. **音效系统**：
   - 路径验证成功：短促的"哔"声（三角波生成）
   - 答案更新：8-bit 风格上升音阶
3. **自动演示模式**：
   - 按行优先顺序自动遍历网格
   - 按空格键可暂停/继续演示

---

# 相似题目推荐
1. [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387) - 二维DP求最大全1正方形
2. [P2733 家的范围](https://www.luogu.com.cn/problem/P2733) - 动态规划处理多个尺寸
3. [P3400 仓鼠矩阵](https://www.luogu.com.cn/problem/P3400) - 二维前缀和与结构验证

---

# 核心调试心得
1. **边界处理**：j-k+1 的列下标需要 ≥1，容易遗漏该判断
2. **预处理方向**：up 数组应从下往上处理，但代码中采用从上到下递推更高效
3. **剪枝优化**：从 ans+1 开始枚举 k 可显著减少循环次数

---

# 扩展思考
当题目扩展为允许旋转 N 型时，可将预处理数组扩展至四个方向（上、下、左、右），并增加对应验证逻辑。此时时间复杂度仍可控制在 O(n^2) 级别。

---
处理用时：74.97秒
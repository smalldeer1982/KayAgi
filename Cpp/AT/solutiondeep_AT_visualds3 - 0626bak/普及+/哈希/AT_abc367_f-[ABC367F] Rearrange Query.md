# 题目信息

# [ABC367F] Rearrange Query

## 题目描述

给定两个长度为 $N$ 的正整数序列 $A=(A_1,A_2,\ldots,A_N)$ 和 $B=(B_1,B_2,\ldots,B_N)$。

你需要处理 $Q$ 个查询。对于第 $i$ 个查询，给定四个正整数 $l_i$, $r_i$, $L_i$, 和 $R_i$。你需要判断是否可以通过重新排列序列 $(A_{l_i},A_{l_i+1},\ldots,A_{r_i})$ 来使其与 $(B_{L_i},B_{L_i+1},\ldots,B_{R_i})$ 完全相同。如果可以做到，则输出 `Yes`；否则输出 `No`。

## 说明/提示

#### 制约条件

- $1 \leq N, Q \leq 2 \times 10^5$
- $1 \leq A_i, B_i \leq N$
- $1 \leq l_i \leq r_i \leq N$
- $1 \leq L_i \leq R_i \leq N$
- 所有输入均为整数。

#### 示例解释 1

- 对于第 1 个查询，$(1,2,3)$ 可以通过重排变为 $(2,3,1)$。因此输出 `Yes`。
- 对于第 2 个查询，无论怎样重排 $(1,2)$ 都无法变为 $(1,4,2)$。因此输出 `No`。
- 对于第 3 个查询，无论怎样重排 $(1,2,3,2)$ 都无法变为 $(3,1,4,2)$。因此输出 `No`。
- 对于第 4 个查询，$(1,2,3,2,4)$ 可以通过重排变为 $(2,3,1,4,2)$。因此输出 `Yes`。

## 样例 #1

### 输入

```
5 4

1 2 3 2 4

2 3 1 4 2

1 3 1 3

1 2 3 5

1 4 2 5

1 5 1 5```

### 输出

```
Yes

No

No

Yes```

## 样例 #2

### 输入

```
4 4

4 4 4 4

4 4 4 4

1 2 2 3

3 3 1 1

1 3 1 4

1 4 2 3```

### 输出

```
Yes

Yes

No

No```

# AI分析结果



**唯一算法分类**：哈希（Hashing）与前缀和（Prefix Sum）

---

### **题解思路与核心难点**

#### **核心思路**
1. **问题本质**：判断两个区间是否为同一多重集。  
2. **哈希映射**：将每个数值映射到随机数，利用哈希值的区间和表示多重集。  
3. **前缀和优化**：预处理哈希值的前缀和数组，实现 O(1) 查询。  
4. **随机性保证**：使用大范围随机数（如 `mt19937_64`）降低哈希冲突概率。

#### **解决难点**
- **高效性要求**：直接统计元素频率的 O(NQ) 方法不可行，哈希和前缀和的结合将复杂度降为 O(N+Q)。  
- **冲突避免**：通过数学分析证明错误概率极低（如 64 位哈希的单次错误概率约为 3×10⁻⁹），实践中几乎不会出错。

---

### **题解评分（≥4星）**

1. **小粉兔（★★★★★）**  
   - 详细分析哈希冲突概率，结合数学推导证明正确性。  
   - 代码简洁高效，使用自然溢出和 `mt19937_64` 生成哈希值。  
   - 关键亮点：对哈希的数学建模清晰，适合深入理解算法本质。

2. **nr0728（★★★★☆）**  
   - 代码简洁，直接使用随机哈希和前缀和实现。  
   - 关键亮点：实现高效，适合快速编码的竞赛场景。

3. **小粉兔的参考代码（★★★★★）**  
   - 使用双哈希（和与异或）进一步降低冲突概率。  
   - 关键亮点：多哈希结合提升正确性，代码结构清晰。

---

### **最优思路与技巧提炼**

1. **随机哈希映射**  
   - 为每个数值分配唯一的大范围随机数（如 `mt19937_64` 生成的 64 位值）。  
   - 前缀和计算区间哈希和，比较两个区间的哈希和是否相等。

2. **自然溢出优化**  
   - 使用 `unsigned long long` 自动取模（2⁶⁴ 自然溢出），避免显式取模运算，提升效率。

3. **多哈希增强正确性（可选）**  
   - 结合和、异或、平方和等多种哈希方式，进一步降低冲突概率。

---

### **同类型题与算法套路**

1. **通用解法**  
   - 区间多重集判断 → 哈希映射 + 前缀和。  
   - 数值频率统计 → 随机哈希或多项式哈希（如 P3370）。

2. **类似题目**  
   - **CF1746F Kazaee**：随机哈希判断区间元素出现次数是否为偶数。  
   - **P1102 A-B数对**：哈希统计数值频率。  
   - **P3370 字符串哈希**：哈希表示字符串唯一性。

---

### **推荐洛谷题目**
1. **P3370**：字符串哈希基础。  
2. **CF1746F**：随机哈希应用的高级变种。  
3. **P3810 三维偏序**：哈希结合分治或树状数组的扩展应用。

---

### **个人心得摘录**

- **调试教训**：初始使用异或哈希时发现反例（如 `{1,3}` 与 `{2,2}` 和相等但异或不同），后改用和哈希。  
- **顿悟点**：自然溢出不仅简化代码，还能避免取模运算的时间开销。

---

### **可视化与算法演示**

#### **动画设计**
- **像素风格界面**：  
  - 用 8-bit 网格展示数组，每个元素显示数值及对应的随机哈希值（颜色区分）。  
  - 前缀和数组以逐步填充的进度条形式展示，颜色渐变表示累加过程。

- **关键步骤高亮**：  
  - **哈希生成**：为每个数值随机生成哈希值时触发闪光特效。  
  - **查询比较**：比较两个区间哈希和时，区间边框闪烁绿色（相等）或红色（不等）。

- **音效设计**：  
  - 成功音效（8-bit 上升音阶）用于哈希和匹配，失败音效（短促“哔”声）用于不匹配。

#### **交互功能**
- **步进控制**：可暂停/继续观察哈希生成或查询比较过程。  
- **速度调节**：滑动条控制动画速度（0.5x~5x）。  
- **AI 演示模式**：自动运行所有查询，展示算法整体流程。

---

### **核心代码实现**

```cpp
#include <iostream>
#include <vector>
#include <random>
using namespace std;
using ULL = unsigned long long;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> a(n+1), b(n+1);
    for (int i=1; i<=n; i++) cin >> a[i];
    for (int i=1; i<=n; i++) cin >> b[i];
    
    mt19937_64 rng(12345); // 随机数生成器
    vector<ULL> hash_val(n+1);
    for (int i=1; i<=n; i++) 
        hash_val[i] = rng();
    
    vector<ULL> sa(n+1), sb(n+1);
    for (int i=1; i<=n; i++) {
        sa[i] = sa[i-1] + hash_val[a[i]]; // A的前缀哈希和
        sb[i] = sb[i-1] + hash_val[b[i]]; // B的前缀哈希和
    }
    
    while (q--) {
        int l, r, L, R;
        cin >> l >> r >> L >> R;
        ULL sum_a = sa[r] - sa[l-1];
        ULL sum_b = sb[R] - sb[L-1];
        cout << (sum_a == sum_b ? "Yes" : "No") << '\n';
    }
    return 0;
}
```

**代码说明**：  
- 使用 `mt19937_64` 生成 64 位随机哈希值。  
- 前缀和数组 `sa` 和 `sb` 分别存储哈希累加结果。  
- 查询时比较区间哈希和，时间复杂度 O(1)。

---
处理用时：80.97秒
# 题目信息

# [ABC251F] Two Spanning Trees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc251/tasks/abc251_f

$ N $ 頂点 $ M $ 辺の無向グラフ $ G $ が与えられます。 $ G $ は**単純**（自己ループおよび多重辺を持たない）かつ**連結**です。

$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結ぶ無向辺 $ \lbrace\ u_i,\ v_i\ \rbrace $ です。

下記の $ 2 $ つの条件をともに満たすような $ G $ の $ 2 $ つの全域木 $ T_1,T_2 $ を $ 1 $ 組構成してください。（ $ T_1 $ と $ T_2 $ は異なる全域木である必要はありません。）

- $ T_1 $ は下記を満たす。
  
  > $ T_1 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_1 $ に含まれないすべての辺 $ \lbrace\ u,\ v\ \rbrace $ について、$ u $ と $ v $ は $ T_1 $ において祖先と子孫の関係にある。
- $ T_2 $ は下記を満たす。
  
  > $ T_2 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_2 $ に含まれない辺 $ \lbrace\ u,\ v\ \rbrace $ であって、$ u $ と $ v $ が $ T_2 $ において祖先と子孫の関係にあるようなものは存在しない。

ここで、「根付き木 $ T $ において頂点 $ u $ と頂点 $ v $ が祖先と子孫の関係にある」とは、「 $ T $ において $ u $ が $ v $ の祖先である」と「 $ T $ において $ v $ が $ u $ の祖先である」のうちどちらかが成り立つことをいいます。

本問題の制約下において上記の条件を満たす $ T_1 $ と $ T_2 $ は必ず存在することが示せます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \min\lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 入力はすべて整数
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

上記の出力例において、$ T_1 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 4,\ 3\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 4,\ 2\ \rbrace,\ \lbrace\ 6,\ 2\ \rbrace $ を持つ $ G $ の全域木です。この $ T_1 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_1 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 5,\ 1\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 5 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 2\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 2 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 6\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 6 $ の祖先です。 また、$ T_2 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 5\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 2,\ 1\ \rbrace,\ \lbrace\ 1,\ 6\ \rbrace $ を持つ $ G $ の全域木です。この $ T_2 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_2 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 4,\ 3\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 3 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 2,\ 6\ \rbrace $ について、頂点 $ 2 $ と頂点 $ 6 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 4,\ 2\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 2 $ は祖先と子孫の関係にありません。

### Sample Explanation 2

$ 3 $ 本の辺 $ \lbrace\ 1,\ 2\rbrace,\ \lbrace\ 1,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace $ を持つ木 $ T $ が $ G $ の唯一の全域木です。 $ G $ の辺のうちこの木 $ T $ に含まれない辺は存在しないので、明らかに、$ T $ は $ T_1 $ の条件と $ T_2 $ の条件をともに満たします。

## 样例 #1

### 输入

```
6 8

5 1

4 3

1 4

3 5

1 2

2 6

1 6

4 2```

### 输出

```
1 4

4 3

5 3

4 2

6 2

1 5

5 3

1 4

2 1

1 6```

## 样例 #2

### 输入

```
4 3

3 1

1 2

1 4```

### 输出

```
1 2

1 3

1 4

1 4

1 3

1 2```

# AI分析结果



## 算法分类
图论-生成树，DFS，BFS

---

## 题解思路与解决难点

### 核心思路
**T1构造**：采用DFS遍历生成树。DFS的非树边均为返祖边，满足任意非树边两点存在祖先关系。  
**T2构造**：采用BFS遍历生成树。BFS的非树边均为横叉边或跨层非父子边，保证任意非树边两点无祖先关系。

### 解决难点
1. **T1的非树边性质证明**：通过DFS的递归特性，所有非树边必然连接已访问节点（即祖先节点），确保条件成立。
2. **T2的非树边性质证明**：BFS按层扩展，若存在非树边，其两端点必处于同一层或相邻层但不同子树，无法构成祖先关系。
3. **高效遍历实现**：需处理大规模数据（n≤2e5），DFS/BFS需使用邻接表与O(1)访问标记。

---

## 题解评分（≥4星）

1. **Nahida_Buer（5星）**  
   - 思路清晰，证明简洁，代码高效。  
   - 利用bitset优化访问标记，DFS与BFS分离逻辑明确。

2. **MMXIandCCXXII（4星）**  
   - 结合样例分析，直观解释DFS/BFS选择理由。  
   - 代码简洁，邻接表遍历实现规范。

3. **LionBlaze（4星）**  
   - 图示辅助理解，详细分析DFS/BFS的边类型差异。  
   - 通过反证法强化结论可信度。

---

## 最优思路与技巧提炼

### 关键技巧
- **DFS生成树**：利用递归深入特性，确保非树边为返祖边。
- **BFS生成树**：按层扩展，避免生成祖先关系的非树边。
- **邻接表遍历优化**：统一处理无向边，通过访问标记避免重复。

### 代码实现核心
```cpp
// DFS生成T1
void dfs(int u) {
    vis[u] = true;
    for (int v : adj[u]) {
        if (!vis[v]) {
            cout << u << " " << v << endl;
            dfs(v);
        }
    }
}

// BFS生成T2
void bfs() {
    queue<int> q;
    q.push(1);
    vis[1] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                cout << u << " " << v << endl;
                vis[v] = true;
                q.push(v);
            }
        }
    }
}
```

---

## 相似题目推荐
1. **P3379 【模板】最近公共祖先（LCA）** - 利用DFS/BFS树性质求解LCA。
2. **P1395 会议** - 树的中位问题，涉及BFS层级分析。
3. **P2680 运输计划** - 生成树边权处理与路径分析。

---

## 可视化与算法演示

### 动画设计
1. **DFS过程**：  
   - 当前节点高亮为蓝色，递归栈用黄色标记。  
   - 树边显示为绿色，返祖非树边显示为红色并标注祖先层级差。

2. **BFS过程**：  
   - 队列节点显示为队列结构，当前层用橙色框标注。  
   - 树边显示为紫色，横叉非树边显示为灰色并连接不同子树。

### 复古像素风格
- **颜色方案**：8位色（绿、红、紫、灰对应不同边类型）。  
- **音效**：DFS递归时播放“滴”声，BFS出队时播放“咔”声。  
- **Canvas交互**：网格布局，节点为像素方块，支持步进控制观察扩展。

---

## 代码实现（完整）
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
vector<int> adj[N];
bool vis[N];

void dfs(int u) {
    vis[u] = true;
    for (int v : adj[u]) {
        if (!vis[v]) {
            cout << u << " " << v << "\n";
            dfs(v);
        }
    }
}

void bfs() {
    queue<int> q;
    q.push(1);
    vis[1] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                cout << u << " " << v << "\n";
                vis[v] = true;
                q.push(v);
            }
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    // T1: DFS
    dfs(1);
    memset(vis, 0, sizeof(vis));
    // T2: BFS
    bfs();
    return 0;
}
```

---
处理用时：74.37秒
# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果



## 算法分类
树的构造、递归、分治

---

## 题解思路与核心难点
### 核心思路
1. **根节点确定**：前序遍历的第一个节点为当前子树的根节点，需验证是否为1。
2. **左右子树分割**：在中序遍历中找到根节点位置，分割左子树和右子树的区间。
3. **递归构造**：根据左/右子树的大小，递归处理前序和中序的对应区间。
4. **合法性验证**：检查根节点是否在有效区间内，否则返回无解。

### 解决难点
- **时间复杂度优化**：预处理中序遍历的节点位置，避免每次线性查找。
- **边界条件处理**：左/右子树大小为0时需标记为空，递归区间需精确计算。
- **错误提前终止**：遇到非法情况（如根不在区间）立即终止递归。

---

## 题解评分（≥4星）
### [4星] program_xwl
- **亮点**：结构体清晰存储子树，边界条件处理完善，递归参数计算详细。
- **代码**：通过 `mp` 数组快速定位中序位置，递归区间计算准确。

### [4星] Tsawke
- **亮点**：代码简洁，参数命名明确（`lp/rp` 前序区间，`li/ri` 中序区间）。
- **核心逻辑**：直接通过 `posI` 数组定位根节点，错误处理通过 `exit(0)` 快速终止。

### [4星] ATION001
- **亮点**：代码最短，递归函数参数简化，直接通过数组索引操作。
- **关键点**：左子树大小计算 `sizl = root-l2`，递归区间直接推导。

---

## 最优思路提炼
### 关键步骤
1. **预处理中序位置**：用数组或哈希表存储节点在中序的位置，确保 O(1) 查找。
2. **根节点验证**：前序首元素必须为1，否则无解。
3. **递归分割逻辑**：
   - **左子树**：前序区间 `[当前根+1, 根+左子树大小]`，中序区间 `[左起点, 根位置-1]`。
   - **右子树**：前序区间 `[左子树后+1, 右终点]`，中序区间 `[根位置+1, 右起点]`。

### 代码片段
```cpp
void dfs(int l1, int r1, int l2, int r2) {
    if (l1 > r1) return;
    int root = pre[l1], pos = in_pos[root];
    if (pos < l2 || pos > r2) exit(puts("-1"));
    int left_size = pos - l2;
    tree[root].l = (left_size > 0) ? pre[l1+1] : 0;
    tree[root].r = (r2 - pos > 0) ? pre[l1+left_size+1] : 0;
    dfs(l1+1, l1+left_size, l2, pos-1);
    dfs(l1+left_size+1, r1, pos+1, r2);
}
```

---

## 类似题目与算法套路
- **同类型题**：构造二叉树（LeetCode 105）、根据中后序构造二叉树（洛谷 P1030）。
- **通用解法**：递归分割序列 + 哈希表预处理位置。

---

## 可视化与算法演示
### 动画设计
1. **根节点高亮**：用红色闪烁标记前序首元素（当前根）。
2. **中序分割线**：黄色竖线分割中序的左右子树区间。
3. **递归过程**：左右子树区间以不同颜色（蓝/绿）动态展开。
4. **错误提示**：非法根位置时，整个屏幕抖动并播放失败音效。

### 复古像素风格
- **颜色方案**：8-bit 调色板（红、黄、蓝、绿），根节点用闪烁效果。
- **音效触发**：成功分割时播放 `beep`，错误时播放 `error.wav`。
- **Canvas 网格**：前序和中序序列用方格表示，递归步骤动态绘制分割线。

---

## 推荐题目
1. **洛谷 P1030**：根据中后序求先序。
2. **LeetCode 105**：前序+中序构造二叉树。
3. **LeetCode 106**：中序+后序构造二叉树。

---
处理用时：85.80秒
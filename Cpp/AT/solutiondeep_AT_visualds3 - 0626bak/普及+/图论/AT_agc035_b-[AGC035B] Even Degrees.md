# 题目信息

# [AGC035B] Even Degrees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_b

$ N $ 頂点 $ M $ 辺の単純連結無向グラフが与えられます。頂点には $ 1 $ から $ N $ までの番号がついており、$ i $ 本目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。 高橋君は、与えられたグラフのすべての辺にどちらかの向きをつけて有向グラフを作ります。 どの頂点から出る辺の本数も偶数になるような有向グラフを作ることが可能かどうか判定し、可能ならそのような例をひとつ構成してください。

## 说明/提示

### ノート

無向グラフが単純であるとは、自己ループと多重辺を含まないことを指します。

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N\ (1\leq\ i\leq\ M) $
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

このように向き付けることで、頂点 $ 1,3 $ からは $ 2 $ 本、頂点 $ 2,4 $ からは $ 0 $ 本の辺が出るようになります。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 1```

### 输出

```
1 2

1 4

3 2

3 4```

## 样例 #2

### 输入

```
5 5

1 2

2 3

3 4

2 5

4 5```

### 输出

```
-1```

# AI分析结果



## 唯一算法分类
**生成树构造与度数调整**

---

## 综合分析与结论

### 核心算法流程
1. **边数奇偶性判断**：若总边数 $M$ 为奇数，直接输出无解（总出度必须为偶数）。
2. **生成树构建**：通过 DFS 或 BFS 构建生成树，将边分为树边和非树边。
3. **非树边定向**：非树边初始定向（如输入顺序），并统计每个点的初始出度。
4. **递归调整树边方向**：自底向上处理生成树，根据当前节点度数奇偶性调整父边方向，确保子树内所有节点出度为偶数。
5. **根节点验证**：总出度为偶数，其他节点已调整，根节点出度自然为偶数。

### 可视化设计要点
1. **生成树构建**：用动画展示 DFS/BFS 遍历过程，树边与非树边用不同颜色区分。
2. **递归调整**：高亮当前处理的节点及父边，动态显示度数变化。若调整父边方向，父节点度数增加时用闪烁提示。
3. **像素风格**：节点用像素块表示，生成树边用绿色，调整后的边用红色，音效提示调整操作。
4. **交互控制**：允许单步执行，观察递归过程与度数变化。

---

## 题解清单 (≥4星)

### 1. ForgotMe（★★★★★）
- **关键亮点**：  
  利用 DFS 生成树，递归处理子树，代码简洁高效。通过自底向上调整父边方向，保证子树节点度数合法，根节点自动满足条件。
- **核心代码**：
  ```cpp
  void solve(int u){
    for(int v : g[u]) solve(v); // 递归处理子节点
    if(u != 1) {
      if(du[u] % 2) printf("%d %d\n", u, f[u]); // 调整父边方向
      else printf("%d %d\n", f[u], u), du[f[u]]++;
    }
  }
  ```

### 2. Azazеl（★★★★）
- **关键亮点**：  
  利用树上差分处理路径翻转，LCA 优化调整路径。将奇数点两两配对，通过路径调整全局度数。
- **核心代码**：
  ```cpp
  void dfs2(int u) {
    vis[u] = true;
    for(auto [v, id] : G[u]) {
      if(vis[v]) continue;
      dfs2(v); cf[u] += cf[v]; // 树上差分统计调整次数
    }
  }
  ```

---

## 最优思路或技巧提炼
- **生成树分治**：将问题拆分为树边与非树边处理，树边自底向上调整，非树边初始定向。
- **度数奇偶性传递**：父边方向调整仅影响父节点，递归保证子树合法，总度数保证根节点合法。
- **线性时间复杂度**：DFS 生成树和递归调整均为 $O(N)$，适合大规模数据。

---

## 同类型题与算法套路
- **类似问题**：  
  调整图的边权或方向以满足特定度数条件（如欧拉回路中奇度点处理）。
- **通用解法**：  
  构建生成树分治，自底向上调整，利用递归保证局部最优，全局合法。

---

## 推荐相似题目
1. **P1341 无序字母对**（欧拉路径构造）  
2. **P3520 最短路径生成树**（生成树与路径调整）  
3. **P2921 Trick or Treat on the Farm**（图论与度数分析）

---

## 可视化算法演示（核心逻辑）
```javascript
// 伪代码：生成树构建与递归调整动画
class Visualization {
  constructor(graph) {
    this.treeEdges = dfsTree(graph); // 生成树边
    this.nonTreeEdges = getNonTreeEdges(graph); // 非树边
    this.degrees = initDegrees(nonTreeEdges); // 初始度数
  }

  animateAdjustment(node) {
    for (child in node.children) {
      animateAdjustment(child); // 递归子节点
    }
    if (node != root) {
      highlightEdge(node.parentEdge); // 高亮父边
      if (degrees[node] % 2) {
        flipEdgeDirection(node.parentEdge); // 调整方向
        playSound('adjust');
      }
      updateDegreesDisplay(); // 更新度数显示
    }
  }
}
```

---

## 个人心得摘录
- **调试关键**：初始度数统计需准确，确保递归调整时父边方向正确影响父节点。
- **思维突破**：将复杂图问题分解为树与非树边处理，递归思想简化全局调整。

---
处理用时：181.70秒
# 题目信息

# [AGC035B] Even Degrees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_b

$ N $ 頂点 $ M $ 辺の単純連結無向グラフが与えられます。頂点には $ 1 $ から $ N $ までの番号がついており、$ i $ 本目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。 高橋君は、与えられたグラフのすべての辺にどちらかの向きをつけて有向グラフを作ります。 どの頂点から出る辺の本数も偶数になるような有向グラフを作ることが可能かどうか判定し、可能ならそのような例をひとつ構成してください。

## 说明/提示

### ノート

無向グラフが単純であるとは、自己ループと多重辺を含まないことを指します。

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N\ (1\leq\ i\leq\ M) $
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

このように向き付けることで、頂点 $ 1,3 $ からは $ 2 $ 本、頂点 $ 2,4 $ からは $ 0 $ 本の辺が出るようになります。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 1```

### 输出

```
1 2

1 4

3 2

3 4```

## 样例 #2

### 输入

```
5 5

1 2

2 3

3 4

2 5

4 5```

### 输出

```
-1```

# AI分析结果



---

### 唯一算法分类  
**图论 - 生成树构造与奇偶性调整**

---

### 综合分析与结论  
**核心思路**：  
1. **奇偶性判断**：总边数 $M$ 必须为偶数，否则无解。  
2. **生成树构造**：通过 DFS/BFS 构建生成树，将边分为树边和非树边。  
3. **非树边处理**：非树边任意定向，统计初始出度。  
4. **树边调整**：后序遍历生成树，动态调整树边方向，使每个节点的出度变为偶数。  
5. **根节点自动合法**：总出度和为偶数，其他节点合法后根节点必然合法。  

**难点与解决**：  
- **生成树划分**：确保树边覆盖所有顶点，正确标记非树边。  
- **递归调整方向**：自底向上调整父边方向，维护父节点出度奇偶性。  
- **总度数维护**：利用总边数为偶数的性质，确保根节点自动满足条件。  

**可视化设计**：  
1. **生成树绘制**：用绿色标记树边，红色标记非树边。  
2. **动态调整演示**：高亮当前处理的子树节点，显示调整方向时的度数变化。  
3. **步进控制**：单步执行递归过程，展示父边方向翻转逻辑。  
4. **复古像素风格**：  
   - **颜色方案**：8 位色系（绿/红边区分树边非树边，黄/蓝标记当前操作）。  
   - **音效触发**：调整方向时播放“滴”声，合法时播放成功音效。  
   - **Canvas 网格**：以网格布局绘制节点，动画展示度数变化。  

---

### 题解清单（≥4星）  
1. **ForgotMe（⭐⭐⭐⭐⭐）**  
   - **亮点**：递归调整逻辑清晰，代码简洁高效，直接通过后序遍历维护度数。  
2. **Azazеl（⭐⭐⭐⭐）**  
   - **亮点**：利用树上差分处理路径翻转，LCA 优化路径操作，适合大规模数据。  
3. **听取MLE声一片（⭐⭐⭐⭐）**  
   - **亮点**：将树解法推广到图，强调生成树的核心地位，思路简明。  

---

### 代码核心逻辑  
**ForgotMe 的关键代码**：  
```cpp
void solve(int u) {
    for (int v : g[u]) { // 遍历子树
        solve(v);
        if (du[v] % 2) printf("%d %d\n", v, u); // 子节点出度奇，边指向父
        else printf("%d %d\n", u, v), du[u]++; // 否则父指向子，父度数+1
    }
}
```  
**流程说明**：  
1. **DFS 生成树**：记录父子关系和树边。  
2. **处理非树边**：直接输出并统计初始出度。  
3. **递归调整树边**：从叶子到根动态调整，确保每个节点出度偶数。  

---

### 同类型题与套路  
1. **奇偶性调整**：通过边操作改变顶点属性的奇偶性。  
2. **生成树构造**：将图问题转化为树问题，简化操作。  
3. **树上差分/LCA**：高效处理路径操作。  

**类似题目**：  
1. [CF1151F - Sonya and Bitwise OR](https://codeforces.com/problemset/problem/1151/F)  
2. [洛谷 P3523 「IOI2011」Dynasty](https://www.luogu.com.cn/problem/P3523)  
3. [AT5147 [AGC036D] Negative Cycle](https://atcoder.jp/contests/agc036/tasks/agc036_d)  

---

### 个人心得摘录  
- **生成树万能性**：将复杂图问题拆解为树结构，是解决连通图问题的常见技巧。  
- **后序遍历优势**：自底向上处理子树，确保父节点调整时子问题已完全解决。  
- **奇偶观察**：总边数奇偶性直接影响全局合法性，需优先判断。  

---

### 可视化与算法演示  
**动画方案**：  
1. **初始化阶段**：  
   - 绘制所有节点和边，树边绿色，非树边红色。  
   - 显示每个节点的初始出度。  
2. **递归调整阶段**：  
   - 高亮当前子树根节点，逐步处理子节点。  
   - 调整方向时，边颜色闪烁，对应节点度数更新。  
3. **完成状态**：  
   - 所有节点变为蓝色（偶数出度），播放胜利音效。  

**交互功能**：  
- **速度控制**：滑动条调节动画速度。  
- **单步模式**：按步执行递归和调整。  
- **音效开关**：开启/关闭操作提示音。  

**复古风格设计**：  
- **8 位字体**：使用像素风格字体显示节点编号和度数。  
- **音效设计**：使用 ChipTone 生成 8 位音效（调整边方向时播放短促“哔”声）。  

--- 

**举一反三**：生成树与奇偶性结合的问题广泛存在于图论中，需重点掌握其构造与调整技巧。

---
处理用时：101.49秒
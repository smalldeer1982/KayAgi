# 题目信息

# [ABC355F] MST Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc355/tasks/abc355_f

頂点に $ 1 $ から $ N $ の番号が、辺に $ 1 $ から $ N-1 $ の番号が付いた $ N $ 頂点 $ N-1 $ 辺の重み付き無向連結グラフ $ G $ が与えられます。辺 $ i $ は頂点 $ a_i $ と頂点 $ b_i $ を結んでおり、その重みは $ c_i $ です。

$ Q $ 個のクエリが与えられるので順に処理してください。$ i $ 番目のクエリは以下で説明されます。

- 整数 $ u_i,v_i,w_i $ が与えられる。$ G $ の頂点 $ u_i,v_i $ の間に重み $ w_i $ の辺を追加する。その後、$ G $ の最小全域木に含まれる辺の重みの和を出力する。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 2\ \times\ 10^5 $
- $ 1\leq\ Q\leq\ 2\ \times\ 10^5 $
- $ 1\leq\ a_i\lt\ b_i\leq\ N $
- $ 1\leq\ u_i\lt\ v_i\leq\ N $
- $ 1\leq\ c_i,w_i\leq\ 10 $
- クエリを処理する前のグラフは連結
- 入力はすべて整数
 
### Sample Explanation 1

各クエリで辺を追加した後のグラフを示しています。最小全域木に含まれる辺は赤色で塗られています。 !\[\](https://img.atcoder.jp/abc355/4e83a6e54750f138ecada66dd93b2b67.png)

## 样例 #1

### 输入

```
4 4

1 2 6

2 3 5

2 4 4

1 3 3

1 2 3

1 4 10

3 4 1```

### 输出

```
12

10

10

7```

## 样例 #2

### 输入

```
8 6

1 8 8

1 6 10

1 5 8

2 6 6

6 7 6

1 3 9

2 4 7

1 3 4

1 6 7

3 4 6

1 5 1

7 8 4

3 5 3```

### 输出

```
49

46

45

38

34

33```

# AI分析结果



# [ABC355F] MST Query 题解分析

## 唯一算法分类
**分层并查集**

---

## 题解思路与核心难点

### 核心思路
利用边权范围极小（1~10）的特性，建立 10 个并查集，第 i 个并查集维护权值 ≤i 的所有边的连通性。初始时假设所有 MST 边权均为最大值 10，每次加边时从该边权值开始向上合并各层并查集，通过分层统计贡献快速计算 MST 总权值。

### 解决难点
1. **动态维护分层连通性**：每次加边需更新从该边权值到最高权值的所有并查集。
2. **快速计算权值贡献**：通过逐层计算权值差（`ans -= 1`）替代显式统计每条边的权值。
3. **时间复杂度优化**：利用并查集的路径压缩和秩合并实现 O(α(N)) 的合并操作，整体复杂度 O((N+Q)*10*α(N))。

---

## 最优思路与技巧提炼

### 关键技巧
1. **权值分层处理**：为每个权值建立独立的并查集，利用权值单调性优化合并过程。
2. **逆向贡献计算**：初始假设所有边权为 10，通过减少贡献的方式逐步优化总权值。
3. **提前终止合并**：当某层并查集已连通时，无需继续向上层合并。

### 代码实现要点
```cpp
for(long long j=z;j<10;j++) { // 从当前权值开始向上合并
    long long fx=find(x,j), fy=find(y,j);
    if(fx != fy) { 
        ans--; // 总权值减少 1（从权值 j 降到当前权值）
        fa[j][fy] = fx; 
    } else break; // 已连通则停止
}
```

---

## 题解评分（≥4星）

### 2022liaojianxiang（★★★★★）
- **亮点**：代码极简（仅 20 行），逆向贡献计算巧妙
- **核心代码**：
  ```cpp
  for(long long j=z;j<10;j++) {
      if(find(x,j) != find(y,j)) ans--;
      else break;
  }
  ```

### Iceturky（★★★★☆）
- **亮点**：显式统计各权值的边数贡献，逻辑更直观
- **关键公式**：
  ```cpp
  ans = cnt[1];
  for(i=2 to 10) ans += (cnt[i]-cnt[i-1])*i;
  ```

### roger_yrj（★★★★☆）
- **亮点**：使用 `sum[]` 数组记录未连通节点数，差分统计更高效
- **核心逻辑**：
  ```cpp
  for(int j=w;j<=10;j++) 
      sum[j] -= tr[j].merge(u,v);
  ```

---

## 同类型题推荐
1. **P3366【模板】最小生成树**（基础 Kruskal 算法）
2. **P1967 货车运输**（最大生成树 + LCA）
3. **P2146 [NOI2015] 软件包管理器**（树链剖分维护动态连通性）

---

## 可视化设计

### 分层并查集动画方案
1. **网格展示**：10 层垂直排列的并查集结构，每层显示节点连接状态
2. **颜色标记**：
   - 当前操作的边：红色闪烁
   - 发生合并的层：绿色高亮
   - 已连通的层：灰色淡化
3. **数值变化**：右侧实时显示 `ans` 的递减过程

### 复古像素风格实现
```javascript
// 伪代码示例：绘制分层并查集
function drawUnionFind() {
  for(let i=0; i<10; i++) {
    ctx.fillStyle = i === currentLayer ? "#FF0000" : "#888888";
    drawGridLayer(i, nodes);
  }
  playSound("blip"); // 每次合并触发 8-bit 音效
}
```

---

## 核心代码实现
```cpp
#include<cstdio>
const int N=2e5+5;
int n,q,fa[11][N],ans;

int find(int x, int layer) {
    return fa[layer][x] == x ? x : fa[layer][x]=find(fa[layer][x],layer);
}

int main() {
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++) 
        for(int j=1;j<=10;j++) 
            fa[j][i] = i;
    ans = 10*(n-1);

    for(int i=1; i<=n+q-1; i++) {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        for(int j=w; j<=10; j++) {
            int fu=find(u,j), fv=find(v,j);
            if(fu != fv) {
                ans -= (j >= w ? 1 : 0); // 关键贡献计算
                fa[j][fv] = fu;
            } else break;
        }
        if(i >= n) printf("%d\n",ans);
    }
}
```

---

## 个人心得
- **调试技巧**：初始将 ans 设为 10*(n-1) 后只需考虑减少操作，避免复杂的加法计算
- **易错点**：并查集层数应从当前权值开始合并（`j=z` 而非 `j=1`）
- **优化发现**：当某层合并失败时可立即跳出循环（`else break`），减少无效操作

---
处理用时：90.55秒
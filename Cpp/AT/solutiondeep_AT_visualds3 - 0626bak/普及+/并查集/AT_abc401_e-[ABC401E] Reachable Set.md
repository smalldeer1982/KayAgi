# 题目信息

# [ABC401E] Reachable Set

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc401/tasks/abc401_e

给定一个包含 $N$ 个顶点和 $M$ 条边的无向图。顶点编号为 $1,2,\ldots,N$，第 $i$ 条边 $(1 \leq i \leq M)$ 连接顶点 $u_i$ 和顶点 $v_i$。

对于每个 $k=1,2,\ldots,N$，请解决以下问题：

> 考虑以下操作：
> 
> - 选择一个顶点，删除该顶点及其所有连接的边。
>  
> 通过重复上述操作，判断是否能够满足以下条件：
> 
> - 从顶点 $1$ 出发，通过边能够到达的顶点集合恰好为 $\{1,2,\ldots,k\}$（共 $k$ 个顶点）。
>  
> 如果可能，求出满足条件所需的最少操作次数；否则输出 `-1`。

## 说明/提示

### 约束条件

- $1 \leq N \leq 2 \times 10^5$
- $0 \leq M \leq 3 \times 10^5$
- $1 \leq u_i < v_i \leq N$ $(1 \leq i \leq M)$
- $(u_i, v_i) \neq (u_j, v_j)$ $(1 \leq i < j \leq M)$
- 输入的所有数值均为整数

### 样例解释 1

例如，当 $k=2$ 时，可以通过删除顶点 $3$、顶点 $4$ 和顶点 $5$（共 3 次操作），使得从顶点 $1$ 可达的顶点仅为 $\{1,2\}$。由于无法通过少于 3 次操作满足条件，因此第 2 行输出 `3`。  
当 $k=6$ 时，不需要删除任何顶点即可满足条件，因此第 6 行输出 `0`。

### 样例解释 3

图中可能不存在任何边。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
6 7

1 2

1 5

2 3

2 4

2 5

3 6

5 6```

### 输出

```
2

3

3

2

1

0```

## 样例 #2

### 输入

```
5 4

1 5

2 3

3 4

4 5```

### 输出

```
1

-1

-1

-1

0```

## 样例 #3

### 输入

```
2 0```

### 输出

```
0

-1```

## 样例 #4

### 输入

```
11 25

6 9

5 9

2 3

1 9

10 11

4 5

9 10

8 9

7 8

3 5

1 7

6 10

4 7

7 9

1 10

4 11

3 8

2 7

3 4

1 8

2 8

3 7

2 10

1 6

6 11```

### 输出

```
5

-1

-1

-1

-1

-1

4

3

2

1

0```

# AI分析结果



---

### 算法分类
图论、并查集、动态维护

---

### 题解思路与算法分析

#### 核心思路
题目要求构造一个子图，使得顶点1的可达集合恰好是前k个顶点，且删除次数最少。关键点：
1. **连通性保证**：前k个顶点必须通过边连接成一个连通块，且顶点1在其中。
2. **隔离性保证**：所有大于k的顶点必须与当前连通块完全断开（删除这些顶点或它们的连接边）。

#### 解决难点
1. **高效判断连通性**：使用并查集动态维护前k个顶点的连通状态，确保每次合并后1所在的连通块包含所有前k顶点。
2. **动态维护删除点集合**：用集合（或差分数组）记录需要删除的顶点（即与当前连通块相连的大于k的顶点）。

#### 关键步骤
1. **并查集合并**：从小到大处理每个k，将k与其所有相邻且编号更小的顶点合并，确保前k顶点连通。
2. **维护待删除集合**：对于每个顶点k，将其所有相邻的大于k的顶点加入待删除集合。这些顶点必须被删除以隔离前k顶点。
3. **合法性检查**：每次合并后，检查1所在连通块的大小是否为k。若合法，输出待删除集合的大小。

---

### 题解评分（≥4星）

1. **WuMin4（4星）**
   - **思路清晰**：明确用并查集维护连通性，set维护待删除点。
   - **高效实现**：时间复杂度接近O(M + Nα(N))，适合大范围数据。
   - **代码简洁**：仅需维护并查集和集合，无冗余操作。

2. **laiyouming（4星）**
   - **并查集优化**：记录连通块大小，直接判断合法性。
   - **差分优化**：通过预处理相邻顶点的最小编号，减少动态维护开销。

3. **dongzirui0817（4星）**
   - **逆向处理**：从删除点的角度出发，利用集合动态维护必须删除的点。
   - **合法性检查优化**：通过预处理减少每次检查的时间。

---

### 最优思路提炼

1. **并查集动态连通性**  
   - 从小到大处理每个k，合并其与相邻的小于k的顶点，确保前k顶点连通。
   - 检查1所在连通块的大小是否等于k，快速判断合法性。

2. **待删除点集合维护**  
   - 使用集合（或差分数组）记录所有与当前连通块相连的大于k的顶点。
   - 每次处理k时，更新集合（删除k自身，加入其相邻的大于k的顶点）。

---

### 类似题目推荐

1. **P3367 【模板】并查集**  
   - 并查集基础操作，适合练习连通性维护。

2. **P1197 [JSOI2008] 星球大战**  
   - 逆向处理删除点，动态维护连通块数目。

3. **P3388 割点**  
   - 图论中关键节点的删除问题，与本题的删除操作类似。

---

### 核心代码实现（WuMin4题解）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, f[200005], tot;
int find(int x) {
    if (f[x] != x) f[x] = find(f[x]);
    return f[x];
}
void uni(int x, int y) {
    x = find(x), y = find(y);
    if (x != y) f[x] = y, tot++;
}
vector<int> t[200005];
set<int> er;
int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) f[i] = i;
    for (int x, y, i = 1; i <= m; i++) {
        cin >> x >> y;
        t[x].push_back(y);
        t[y].push_back(x);
    }
    for (int i = 1; i <= n; i++) {
        if (er.find(i) != er.end()) er.erase(i);
        for (int v : t[i]) {
            if (v > i) er.insert(v);
            else if (v < i) uni(i, v);
        }
        if (i != 1 && tot != i - 1) cout << -1 << endl;
        else cout << er.size() << endl;
    }
    return 0;
}
```

#### 代码说明
- **并查集初始化**：每个顶点初始为独立集合。
- **动态合并**：处理顶点i时，合并其与所有相邻且编号更小的顶点。
- **待删除集合维护**：将i的相邻且大于i的顶点加入集合`er`，删除操作即统计集合大小。

---

### 可视化设计

#### 动画方案
1. **连通块动态合并**  
   - **颜色标记**：用不同颜色表示不同连通块，合并时颜色渐变。
   - **高亮当前k**：处理顶点k时，将其高亮为红色，相邻顶点为黄色。

2. **待删除点集合**  
   - **闪烁标记**：每次加入集合的顶点闪烁显示，删除时渐隐。
   - **实时统计**：右侧面板显示当前待删除集合的大小。

3. **步进控制**  
   - **速度调节**：滑动条控制处理顶点的速度（0.5x~5x）。
   - **单步执行**：点击按钮逐顶点处理，观察连通块变化。

#### 复古像素风格
- **Canvas绘制**：顶点以8位像素方块表示，边为单色线条。
- **音效设计**：
  - **合并成功**：播放短促“哔”声。
  - **非法状态**：播放低沉“嗡”声。
  - **删除操作**：播放“咔嚓”音效。

---

### 总结
本题核心在于**并查集维护连通性**与**动态集合维护删除点**。高效的数据结构选择使得算法能在O(M + Nα(N))时间内解决大规模数据，结合复古可视化可增强学习体验。

---
处理用时：74.79秒
# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果



---

## 唯一算法分类
**带权并查集**

---

## 综合分析与结论

### 核心算法思路
题目要求判断一组相对位置约束是否自洽。核心难点在于高效处理动态的等式约束关系，并快速检测矛盾。带权并查集通过维护每个节点到根节点的距离差值，在合并和路径压缩时动态更新权值，能在近似线性的时间复杂度内解决问题。

### 关键步骤与难点
1. **路径压缩优化**：在 `find` 函数中递归更新父节点，并累加距离差，确保树的高度始终为1。
2. **权值更新逻辑**：合并两个集合时，通过几何关系推导新权值（`dis[rl] = d + dis[r] - dis[l]`）。
3. **矛盾检测**：若两个节点已属于同一集合，检查当前约束是否与已有权值一致。

### 可视化设计
- **动画演示**：用箭头表示父子关系，右侧标注 `dis[x]` 值。合并时高亮相关节点，动态展示权值计算过程。
- **步进控制**：允许单步执行每条约束，观察并查集结构变化。
- **像素风格**：用 8-bit 风格节点（16x16 像素方块），不同颜色区分连通分量，合并时播放经典音效。

---

## 题解清单（≥4星）

### [Doraven] ⭐⭐⭐⭐⭐
- **亮点**：代码简洁高效，时间复杂度最优（O(m α(n))）。完美应用带权并查集核心思想。
- **核心代码**：
```cpp
int find(int x){
    if(fa[x]!=x){
        int nf=fa[x];
        fa[x]=find(fa[x]);
        dis[x] += dis[nf];
    }
    return fa[x];
}
// 合并逻辑：dis[rl] = d + dis[r] - dis[l]
```

### [Wen_kr] ⭐⭐⭐⭐
- **亮点**：差分约束标准解法，适用性广。通过 SPFA 检测负环，逻辑清晰。
- **注意点**：大数据下 SPFA 可能退化为 O(nm)，但实际数据可通过。

### [CreeperLordVader] ⭐⭐⭐⭐
- **亮点**：DFS 遍历检测矛盾，代码易理解。通过 `vis` 和 `use` 数组避免重复访问。
- **适用场景**：连通分量较小或约束稀疏时表现较好。

---

## 最优思路提炼
**带权并查集权值推导**：  
当合并两个节点 `l` 和 `r` 时，设其根节点分别为 `rl` 和 `rr`，需满足：
```
x_r - x_l = d  
=> (x_r - x_rr) + (x_rr - x_rl) = (x_l - x_rl) + d  
=> dis[r] + (x_rr - x_rl) = dis[l] + d  
=> x_rr - x_rl = d + dis[l] - dis[r]
```
故将 `rl` 的父节点设为 `rr`，并更新 `dis[rl] = d + dis[r] - dis[l]`。

---

## 同类题目推荐
1. **P1955 [NOI2015] 程序自动分析**（等式与不等式约束）
2. **P2024 [NOI2001] 食物链**（环形关系带权并查集）
3. **P1196 [NOI2002] 银河英雄传说**（队列距离维护）

---

## 可视化代码片段（带权并查集）
```javascript
// 像素风格并查集动画（伪代码）
class UnionFindViz {
  constructor(n) {
    this.nodes = Array(n).fill().map((_,i) => ({
      parent: i, 
      dis: 0,
      x: i*50, y: 300,  // 像素坐标
      color: randomColor()
    }));
  }

  find(x) {
    if (this.nodes[x].parent != x) {
      let oldParent = this.nodes[x].parent;
      this.highlightNode(x, 'yellow'); // 高亮当前节点
      this.find(oldParent);
      this.nodes[x].parent = this.nodes[oldParent].parent; 
      this.nodes[x].dis += this.nodes[oldParent].dis;
      this.drawEdge(x, this.nodes[x].parent); // 重绘箭头
      playSound('blip'); // 8-bit 音效
    }
    return this.nodes[x].parent;
  }
}
```

---

## 个人心得摘录
> "带权并查集的权值更新需要几何推导，合并时要考虑两个方向的约束关系。调试时通过打印每个节点的 `dis` 值快速定位矛盾点。" —— Doraven

---

## 算法演示方案
1. **初始化**：每个节点自成一棵树，`dis` 为0。
2. **处理约束 (l,r,d)**：
   - 高亮 `l` 和 `r`，递归压缩路径（播放路径压缩动画）。
   - 若根节点相同，检查 `dis[l] - dis[r] == d`，不一致则红色闪烁报警。
   - 若根节点不同，合并两树并更新权值，绘制新箭头与权值标签。
3. **自动模式**：按输入顺序逐步执行，间隔 500ms，可暂停/回放。

---

**通过带权并查集的高效处理与直观可视化，学习者可深入理解动态关系维护的核心思想。**

---
处理用时：102.21秒
# 题目信息

# [ABC301E] Pac-Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc301/tasks/abc301_e

$ H $ 行 $ W $ 列のグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,j) $ と表します。 グリッドの各マスはスタートマス、ゴールマス、空マス、壁マス、お菓子マスのいずれかです。 $ (i,j) $ が何のマスであるかは文字 $ A_{i,j} $ によって表され、$ A_{i,j}= $ `S` のときスタートマス、 $ A_{i,j}= $ `G` のときゴールマス、 $ A_{i,j}= $ `.` のとき空マス、 $ A_{i,j}= $ `#` のとき壁マス、 $ A_{i,j}= $ `o` のときお菓子マスです。 ここで、スタートマスとゴールマスはちょうど $ 1 $ つずつあり、お菓子マスは **$ 18 $ 個以下**であることが保証されます。

高橋くんは現在スタートマスにいます。 高橋くんは、上下左右に隣接するマスであって壁マスでないマスに移動することを繰り返し行えます。 高橋くんは今から $ T $ 回以下の移動によってゴールマスに到達したいです。 そのようなことは可能かどうか判定してください。 可能な場合は、最終的にゴールマスにいるという条件のもとで、移動の途中に訪れるお菓子マスの数の最大値を求めてください。 ただし、$ 1 $ つのお菓子マスに複数回訪れた場合でも、カウントするのは $ 1 $ 回のみです。

## 说明/提示

### 制約

- $ 1\leq\ H,W\ \leq\ 300 $
- $ 1\ \leq\ T\ \leq\ 2\times\ 10^6 $
- $ H,W,T $ は整数
- $ A_{i,j} $ は `S`, `G`, `.`, `#`, `o` のいずれか
- $ A_{i,j}= $ `S` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `G` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `o` を満たす $ (i,j) $ の組は **$ 18 $ 個以下**
 
### Sample Explanation 1

$ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3)\ \rightarrow\ (1,3) $ と $ 4 $ 回移動すると、 $ 1 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることができます。 $ 5 $ 回以下の移動で $ 2 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることはできないので、$ 1 $ が答えです。 なお、$ (1,1)\ \rightarrow\ (2,1)\ \rightarrow\ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3) $ と移動すると $ 5 $ 回の移動で $ 2 $ 個のお菓子マスを訪れることができますが、最終的にゴールマスにいないため無効であることに注意してください。

### Sample Explanation 2

$ 1 $ 回以下の移動でゴールマスに到達することはできません。

## 样例 #1

### 输入

```
3 3 5

S.G

o#o

.#.```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3 1

S.G

.#o

o#.```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G```

### 输出

```
18```

# AI分析结果



**唯一算法分类**  
BFS

---

### **题解思路、算法要点与解决难点**

**核心思路**  
1. **BFS预处理**：计算所有关键点（糖果、起点、终点）之间的最短距离，时间复杂度 O(18×300²)  
2. **状压DP**：将问题转化为旅行商问题（TSP），状态定义为 `f[i][j]`，表示当前在第 `i` 个点，状态 `j`（二进制表示已访问的糖果）时的最短路径  
3. **状态转移**：枚举下一个访问的糖果，更新状态和路径长度  
4. **最终判定**：在所有满足总步数 ≤ T 的状态中，统计最多访问的糖果数  

**解决难点**  
- **搜索顺序**：使用 BFS 预处理确保最短路径  
- **状态压缩**：将 18 个糖果的访问状态压缩为二进制数（最多 2¹⁸ 种状态）  
- **终点处理**：必须确保最终到达终点，需在所有状态转移完成后单独计算  

---

### **题解评分 (≥4星)**

1. **DengDuck（★★★★☆）**  
   - 思路清晰，分步预处理+状压 DP  
   - 代码结构明确，初始化、BFS、DP 各阶段分离  
   - 优化点：显式处理起点和终点编号，避免状态混淆  

2. **sunzz3183（★★★★☆）**  
   - 按阶段处理状态（按 1 的个数分阶段），避免无效转移  
   - 核心代码片段：  
     ```cpp  
     for(int szz=1; szz<=cnt; szz++)  
       for(auto i : vt[szz])  
         for(int j=1; j<=cnt; j++)  
           for(int k=1; k<=cnt; k++)  
             // 状态转移  
     ```  
   - 优点：分阶段优化显著减少计算量  

3. **Kylin_ZHH（★★★★☆）**  
   - 使用 DFS 记忆化搜索实现状压 DP  
   - 代码亮点：  
     ```cpp  
     int dfs(int now, int ztm) {  
       if(vis[now][ztm]) return dp[now][ztm];  
       // ...递归更新状态  
     }  
     ```  
   - 优势：避免显式枚举所有状态，按需计算  

---

### **最优思路或技巧提炼**

1. **BFS预处理最短路径**  
   - 对每个关键点（起点、终点、糖果）执行 BFS，计算到其他所有关键点的最短距离  
   - 代码片段：  
     ```cpp  
     void bfs(int id) {  
       queue<node> q;  
       q.push({sx, sy, 0});  
       while (!q.empty()) {  
         // 扩展四个方向  
       }  
     }  
     ```  

2. **状压DP状态设计**  
   - 状态定义：`f[i][j]` 表示当前在点 `i`，已访问的糖果集合为 `j`  
   - 转移方程：  
     \[
     f_{j, S \cup \{j\}} = \min(f_{j, S \cup \{j\}}, f_{i, S} + \text{dis}(i, j))
     \]  

3. **终点处理优化**  
   - 在状态转移完成后，单独计算从每个状态到终点的路径：  
     ```cpp  
     for (int s : all_states)  
       if (f[s][i] + dis[i][终点] ≤ T)  
         ans = max(ans, count_bits(s))  
     ```  

---

### **同类型题或类似算法套路**

- **TSP问题**：如 [洛谷 P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)  
- **多源最短路径+BFS**：如 [ABC180E Traveling Salesman](https://atcoder.jp/contests/abc180/tasks/abc180_e)  
- **状压DP+路径规划**：如 [LeetCode 847. 访问所有节点的最短路径](https://leetcode.com/problems/shortest-path-visiting-all-nodes/)  

---

### **推荐洛谷题目**

1. **P1433 吃奶酪**  
   - 二维平面上的 TSP 问题，需访问所有奶酪点  
   - 关键算法：状压 DP + 浮点数距离计算  

2. **P3959 宝藏**  
   - 图的生成树问题，状态压缩优化  
   - 涉及 BFS 计算层间代价  

3. **ABC180E Traveling Salesman**  
   - AtCoder 经典 TSP 变种，需处理三维坐标  
   - 核心：BFS 预处理 + 状压 DP  

---

### **个人心得摘录**

- **DengDuck**：  
  > "注意起点和终点必须显式编号，否则在状态转移时会混淆"  
- **Kylin_ZHH**：  
  > "DFS 记忆化搜索比传统状压 DP 更节省内存，但要注意递归深度"  
- **sunzz3183**：  
  > "分阶段处理状态，按 1 的个数分组，减少无效循环次数"  

---

### **可视化与算法演示**

**动画设计**  
- **BFS 预处理**：  
  - 网格图中高亮当前 BFS 起点，扩散显示访问过程  
  - 不同颜色区分已访问/待访问节点（如红色为当前层，蓝色为下一层）  
- **状压 DP 状态转移**：  
  - 显示二进制状态（如 `001011`）和当前所在节点  
  - 动态连线表示从状态 `i` 到 `j` 的转移，显示路径长度  

**复古像素风格实现**  
- **Canvas 绘制**：  
  - 使用 16 色调色板，关键点用不同像素图标表示（起点：绿色方块，终点：红色方块，糖果：黄色圆点）  
  - BFS 扩散时，用 `requestAnimationFrame` 逐帧更新  
- **音效设计**：  
  - 访问新节点：8-bit "哔" 声  
  - 找到路径：胜利音效（上升音阶）  
  - 超时/失败：低沉音效  

**交互功能**  
- **步进控制**：按钮支持暂停/继续/单步执行  
- **速度调节**：滑动条控制动画速度（1x~10x）  
- **自动演示模式**：AI 自动选择最优路径，显示状态转移过程  

```javascript
// 示例：BFS 动画核心逻辑（伪代码）
function animateBFS(start) {
  let queue = [start];
  let visited = new Set();
  while (queue.length > 0) {
    let current = queue.shift();
    drawPixel(current.x, current.y, COLOR_VISITED); // 绘制当前节点
    playSound('beep'); // 触发音效
    for (let dir of directions) {
      let next = current + dir;
      if (!visited.has(next)) {
        visited.add(next);
        queue.push(next);
        drawPixel(next.x, next.y, COLOR_PENDING); // 绘制待访问节点
      }
    }
  }
}
```

---
处理用时：85.20秒
# 题目信息

# [ABC251F] Two Spanning Trees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc251/tasks/abc251_f

$ N $ 頂点 $ M $ 辺の無向グラフ $ G $ が与えられます。 $ G $ は**単純**（自己ループおよび多重辺を持たない）かつ**連結**です。

$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結ぶ無向辺 $ \lbrace\ u_i,\ v_i\ \rbrace $ です。

下記の $ 2 $ つの条件をともに満たすような $ G $ の $ 2 $ つの全域木 $ T_1,T_2 $ を $ 1 $ 組構成してください。（ $ T_1 $ と $ T_2 $ は異なる全域木である必要はありません。）

- $ T_1 $ は下記を満たす。
  
  > $ T_1 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_1 $ に含まれないすべての辺 $ \lbrace\ u,\ v\ \rbrace $ について、$ u $ と $ v $ は $ T_1 $ において祖先と子孫の関係にある。
- $ T_2 $ は下記を満たす。
  
  > $ T_2 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_2 $ に含まれない辺 $ \lbrace\ u,\ v\ \rbrace $ であって、$ u $ と $ v $ が $ T_2 $ において祖先と子孫の関係にあるようなものは存在しない。

ここで、「根付き木 $ T $ において頂点 $ u $ と頂点 $ v $ が祖先と子孫の関係にある」とは、「 $ T $ において $ u $ が $ v $ の祖先である」と「 $ T $ において $ v $ が $ u $ の祖先である」のうちどちらかが成り立つことをいいます。

本問題の制約下において上記の条件を満たす $ T_1 $ と $ T_2 $ は必ず存在することが示せます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \min\lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 入力はすべて整数
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

上記の出力例において、$ T_1 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 4,\ 3\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 4,\ 2\ \rbrace,\ \lbrace\ 6,\ 2\ \rbrace $ を持つ $ G $ の全域木です。この $ T_1 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_1 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 5,\ 1\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 5 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 2\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 2 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 6\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 6 $ の祖先です。 また、$ T_2 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 5\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 2,\ 1\ \rbrace,\ \lbrace\ 1,\ 6\ \rbrace $ を持つ $ G $ の全域木です。この $ T_2 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_2 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 4,\ 3\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 3 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 2,\ 6\ \rbrace $ について、頂点 $ 2 $ と頂点 $ 6 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 4,\ 2\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 2 $ は祖先と子孫の関係にありません。

### Sample Explanation 2

$ 3 $ 本の辺 $ \lbrace\ 1,\ 2\rbrace,\ \lbrace\ 1,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace $ を持つ木 $ T $ が $ G $ の唯一の全域木です。 $ G $ の辺のうちこの木 $ T $ に含まれない辺は存在しないので、明らかに、$ T $ は $ T_1 $ の条件と $ T_2 $ の条件をともに満たします。

## 样例 #1

### 输入

```
6 8

5 1

4 3

1 4

3 5

1 2

2 6

1 6

4 2```

### 输出

```
1 4

4 3

5 3

4 2

6 2

1 5

5 3

1 4

2 1

1 6```

## 样例 #2

### 输入

```
4 3

3 1

1 2

1 4```

### 输出

```
1 2

1 3

1 4

1 4

1 3

1 2```

# AI分析结果



---

**唯一算法分类**：DFS与BFS

---

### **综合分析与结论**

本题要求构造两棵生成树，分别满足特定的非树边条件。核心在于利用DFS和BFS遍历生成树的性质：

1. **DFS生成树（T₁）**：DFS遍历生成的树中，所有非树边均为返祖边，即非树边连接的两个节点在树中必为祖先与后代关系，满足T₁的条件。
2. **BFS生成树（T₂）**：BFS遍历生成的树中，非树边连接的两个节点在树中必然不处于同一祖先链上，从而不满足祖先与后代关系，满足T₂的条件。

**难点对比**：
- **DFS的关键**：需确保所有非树边为返祖边。DFS的递归遍历特性天然保证了这一点。
- **BFS的关键**：需避免跨层边形成祖先关系。BFS的层序扩展确保了非树边仅存在于同层或不同层的非直系节点之间。

**可视化设计思路**：
1. **DFS动画演示**：以栈模拟递归过程，展示节点的深入访问顺序，标记返祖边为红色。
2. **BFS动画演示**：以队列模拟层序遍历，按层次展开节点，同一层节点用相同颜色标记，非树边高亮显示。
3. **交互设计**：支持步进控制，对比两种遍历方式的节点访问顺序，突出非树边性质。

---

### **题解清单（≥4星）**

1. **Nahida_Buer（5星）**  
   - **亮点**：代码简洁高效，利用`bitset`优化访问标记，分离DFS/BFS逻辑，输出直接嵌入遍历过程。
2. **LionBlaze（4星）**  
   - **亮点**：结合图示详细论证DFS/BFS生成树的非树边性质，辅以Tarjan算法类比，理论分析深入。
3. **MMXIandCCXXII（4星）**  
   - **亮点**：代码可读性强，逻辑清晰，通过反证法验证条件，适合初学者理解。

---

### **代码核心实现**

**DFS生成树（T₁）**  
```cpp
void dfs(int u) {
    vis[u] = true;
    for (int v : adj[u]) {
        if (!vis[v]) {
            cout << u << " " << v << endl; // 记录树边
            dfs(v);
        }
    }
}
```

**BFS生成树（T₂）**  
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    vis[1] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                cout << u << " " << v << endl; // 记录树边
                vis[v] = true;
                q.push(v);
            }
        }
    }
}
```

---

### **同类型题与算法套路**

- **通用模式**：DFS/BFS生成树的性质常用于图论问题，如判断边类型（返祖边、横叉边）、构造特定结构的树等。
- **类似题目**：
  1. [CF1006E - Military Problem](https://codeforces.com/problemset/problem/1006/E)（DFS序应用）
  2. [洛谷P3379 - 最近公共祖先](https://www.luogu.com.cn/problem/P3379)（BFS预处理LCA）
  3. [洛谷P1363 - 幻象迷宫](https://www.luogu.com.cn/problem/P1363)（BFS/DFS搜索连通性）

---

### **推荐相似题目**

1. **ABC209D - Collision**（BFS层次性质）
2. **洛谷P1141 - 01迷宫**（BFS连通块）
3. **洛谷P1219 - 八皇后**（DFS回溯经典）

---

### **个人心得摘录**

- **调试经验**：初始代码未重置`vis`数组导致BFS错误，需注意状态清理。
- **思维突破**：通过分析非树边性质而非直接构造，极大简化问题。

---

### **可视化与复古游戏化设计**

**动画方案**：
1. **DFS动态演示**：
   - **像素风格**：节点为8位方块，当前访问节点闪烁，返祖边显示为红色。
   - **音效**：访问新节点时播放“哔”声，回溯时播放“滴”声。
2. **BFS动态演示**：
   - **层序扩展**：每层节点颜色渐变，队列节点显示为待扩展队列。
   - **自动播放**：按层逐步展开，背景音乐为8位芯片音乐循环。
3. **交互功能**：
   - **步进控制**：空格键切换执行/暂停，方向键调整速度。
   - **关卡模式**：通过构造不同图的生成树解锁成就，积分奖励机制。

**Canvas实现**：
```javascript
// 伪代码：DFS动画核心逻辑
function animateDFS(node) {
    highlight(node); // 高亮当前节点
    playSound('select'); // 触发音效
    for (let neighbor of adj[node]) {
        if (!visited[neighbor]) {
            drawEdge(node, neighbor, 'tree'); // 绘制树边
            visited[neighbor] = true;
            setTimeout(() => animateDFS(neighbor), 500); // 递归延迟
        } else if (!isParent(node, neighbor)) {
            drawEdge(node, neighbor, 'back'); // 绘制返祖边
        }
    }
}
```

---
处理用时：77.74秒
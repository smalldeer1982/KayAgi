# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果



## 算法分类
**DFS**（基于递归的深度优先构造策略）

---

## 题解思路、算法要点与解决难点
### 核心思路
1. **根节点定位**：前序序列第一个元素为当前子树根节点。
2. **中序分割**：通过根节点在中序序列中的位置划分左右子树。
3. **递归构造**：对左右子树递归执行上述过程，直到叶子节点。
4. **无解判定**：根节点不在中序区间内，或前序首元素非1时直接无解。

### 难点与解决方案
- **快速根定位**：哈希表预处理中序位置（`mp[b[i]] = i`），避免线性查找。
- **子树区间计算**：通过中序分割后的左右子树大小，确定前序中的左右子树区间。
- **边界处理**：递归终止条件（区间长度≤0），左/右子树存在性判断（子树大小为0时子节点置0）。

---

## 题解评分（≥4星）

### 1. program_xwl（4.5星）
- **亮点**：代码简洁，边界处理完善（根非1、子树区间非法直接退出），哈希预处理清晰。
- **代码片段**：
  ```cpp
  int root = mp[a[l1]];
  if(root < l2 || root > r2) { cout << -1; exit(0); } // 根位置非法判定
  ```

### 2. Tsawke（4星）
- **亮点**：参数命名直观（`lp, rp`表前序区间，`li, ri`表中序区间），递归逻辑清晰。
- **关键优化**：通过计算左右子树大小直接确定前序区间分割点。

### 3. Ascnbeta（4星）
- **特色**：采用函数式递归返回值构建树结构，参数传递父节点位置辅助子树连接。
- **可视化友好**：递归函数返回子树根节点，便于动画展示构造顺序。

---

## 最优思路或技巧提炼
1. **哈希加速定位**：预处理中序节点位置，将根节点查询复杂度降至O(1)。
2. **区间分割公式**：
   - 左子树大小 = 根在中序位置 - 中序左端点 → 前序左区间：`[l1+1, l1+sizl]`
   - 右子树大小 = 中序右端点 - 根位置 → 前序右区间：`[l1+sizl+1, r1]`
3. **即时无解判定**：递归过程中发现根位置非法立即终止，避免无效递归。

---

## 同类型题与算法套路
- **类似题目**：  
  - 洛谷P1030（已知中序后序求先序）  
  - 洛谷P1827（已知中序前序求后序）  
  - LeetCode 105（前序+中序构造二叉树）
- **通用套路**：  
  - 分治法结合DFS，利用遍历序列性质递归分割区间。  
  - 预处理哈希表优化区间定位，避免重复计算。

---

## 推荐相似题目
1. **洛谷P1030**：已知中序和后序，求先序序列。  
2. **洛谷P1305**：验证前序序列是否合法。  
3. **LeetCode 106**：已知中序和后序构造二叉树。

---

## 可视化与算法演示
### 核心搜索过程动画设计
1. **节点高亮**：  
   - **红色**：当前子树根节点。  
   - **蓝色/绿色**：左右子树区间。  
2. **步进流程**：  
   - **Step1**：展示前序首元素（根）选中，中序中定位根。  
   - **Step2**：绘制左右子树区间分割线，递归进入左子树。  
   - **Step3**：左子树处理完成后回溯，进入右子树。  
3. **复古像素风格**：  
   - **8-bit节点**：用16x16像素块表示节点，根节点闪烁显示。  
   - **音效**：访问新节点时播放短促“哔”声，无解时播放低沉错误音。  
4. **交互控制**：  
   - **速度调节**：滑块控制递归步进速度（0.5x~3x）。  
   - **暂停/继续**：观察当前区间分割状态。

---

## 关键代码片段（DFS核心逻辑）
```cpp
void dfs(int l1, int r1, int l2, int r2) {
    if (l1 > r1) return;
    int root_val = pre[l1];
    int root_pos = in_map[root_val];
    
    if (root_pos < l2 || root_pos > r2) exit(-1); // 非法判定
    
    int left_size = root_pos - l2;
    tree[root_val].left = dfs(l1 + 1, l1 + left_size, l2, root_pos - 1);
    tree[root_val].right = dfs(l1 + left_size + 1, r1, root_pos + 1, r2);
    
    return root_val;
}
```

---

## 个人心得摘录
- **program_xwl**：  
  > “哈希预处理中序位置是关键，否则O(N)查找会TLE。”  
- **LastKismet**：  
  > “递归参数设计需严格对应区间含义，否则极易混淆左右子树分割点。”  
- **Ascnbeta**：  
  > “父节点位置传递虽增加参数，但直观展示子树连接关系，调试更易。”  

---

通过上述分析与可视化设计，可深入理解如何利用DFS递归构建二叉树，并通过预处理和即时剪枝高效解决遍历序列构造问题。

---
处理用时：72.06秒
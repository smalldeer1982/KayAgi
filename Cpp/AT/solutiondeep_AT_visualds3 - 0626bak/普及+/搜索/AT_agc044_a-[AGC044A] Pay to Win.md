# 题目信息

# [AGC044A] Pay to Win

## 题目描述

# [AGC044A] Pay to Win


你有一个数字$0$ ，你希望得到数字$N$。

你可以通过以下操作更改数字，需要支付一定数量的硬币：

- 将当前数乘$2$，需要$A$硬币。
- 将当前数乘$3$，需要$B$硬币。
- 将当前数乘$5$，需要$C$硬币。
- 将当前数加$1$或减$1$，需要$D$硬币。

你可以按任意顺序和任意次数执行这些操作。

最少需要多少硬币才能得到$N$？

你需要解决$T$组测试用例。

## 说明/提示

### 约束

- $ 1\ \le\ T\ \le\ 10 $
- $ 1\ \le\ N\ \le\ 10^{18} $
- $ 1\ \le\ A,\ B,\ C,\ D\ \le\ 10^9 $
- $ N,\ A,\ B,\ C,\ D $ 都是整数。

### Sample Explanation 1

对于第一个测试用例，达到最低成本$20$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$1$个硬币使其乘$2(x = 4)$
- 用$2$个硬币使其乘$3(x = 12)$
- 用$8$个硬币使其减$1(x = 11)$

对于第二个测试用例，达到最低成本$19$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$2$个硬币使其乘$5(x = 10)$
- 用$8$个硬币使其减$1(x = 11)$

## 样例 #1

### 输入

```
5

11 1 2 4 8

11 1 2 2 8

32 10 8 5 4

29384293847243 454353412 332423423 934923490 1

900000000000000000 332423423 454353412 934923490 987654321```

### 输出

```
20

19

26

3821859835

23441258666```

# AI分析结果



---

## 算法分类  
**DFS（记忆化搜索）**

---

## 综合分析与结论  
### 核心思路与算法要点  
所有题解均采用**逆向思维**，从目标值 `N` 倒推至 `0`，通过递归+记忆化剪枝。关键要点：  
1. **除法优先**：优先考虑除以2/3/5的操作，仅当无法整除时，才用加减操作调整至最近的倍数。  
2. **状态压缩**：每个状态仅需处理三种除数的上下界情况，总状态数约为 `O(log₂N·log₃N·log₅N)`。  
3. **溢出处理**：用 `__int128` 或 `unsigned long long` 避免大数运算溢出。  

### 解决难点  
- **状态爆炸**：通过优先处理除法而非加减，将状态数压缩至可接受范围。  
- **方向选择**：逆向处理（从 `N` 到 `0`）比正向处理（从 `0` 到 `N`）状态更少，避免无效路径。  

### 可视化设计思路  
1. **节点展示**：以像素风格显示当前数值和操作路径，高亮当前节点（红色）与待探索分支（黄色）。  
2. **动画流程**：  
   - 初始节点 `N` 入栈，标记为待处理。  
   - 弹出栈顶节点，计算其上下界除法状态，生成子节点并压栈。  
   - 用不同颜色区分已访问（绿色）和未访问节点（灰色）。  
3. **音效触发**：节点访问时播放“点击”音效，找到最优解时播放胜利音效。  

---

## 题解清单（≥4星）  
### 1. suzhikz 的题解（★★★★★）  
- **亮点**：代码简洁，处理所有除数的上下界情况，明确溢出处理逻辑。  
- **关键代码**：  
  ```cpp
  ans = min(ans, (x-l)*d + a + dfs(l/2));  // 处理下界
  ans = min(ans, (r-x)*d + a + dfs(r/2));  // 处理上界
  ```

### 2. 墨笙_Mooos 的题解（★★★★☆）  
- **亮点**：参考官方思路，详细数学推导，状态转移清晰。  
- **心得**：强调除法操作优先级，避免无效加减操作。  

### 3. xukehg 的题解（★★★★☆）  
- **亮点**：使用 `__int128` 处理大数，7种状态分支覆盖全面。  
- **代码片段**：  
  ```cpp
  for (ll T : { 2, 3, 5 } ) 
    CkMin(Ans, Cost[T] + D*(T - Now%T) + DFS(Now/T +1));  // 向上取整
  ```

---

## 最优思路提炼  
1. **逆向DFS**：从 `N` 向 `0` 递归，优先处理除法操作。  
2. **上下界优化**：对每个除数 `k`，计算 `N` 最近的上下倍数，避免全量加减。  
3. **记忆化剪枝**：用 `map` 存储已计算状态，避免重复递归。  

---

## 同类型题与算法套路  
- **逆向思维优化**：如 LeetCode 650. 2 Keys Keyboard（逆向分解质因数）。  
- **状态压缩搜索**：如洛谷 P1462 通往奥格瑞玛的道路（最短路+剪枝）。  

---

## 推荐相似题目  
1. **P1588** [丢失的牛]：逆向BFS处理跳跃与移动。  
2. **P2325** [皇室战争]：状态压缩+记忆化搜索。  
3. **P3953** [逛公园]：DAG上的记忆化搜索与剪枝。  

---

## 个人心得摘录  
> “**先除后加比先加后除更优**”——suzhikz  
> 调试中发现，直接处理余数可能比多次加减更高效，例如将 `11` 调整为 `12` 再除3，而非逐个减1。  

---

## 可视化与算法演示  
### 复古像素风格设计  
- **颜色方案**：  
  - 当前节点：红色（8位像素方块）  
  - 已访问节点：绿色  
  - 待处理分支：黄色闪烁特效  
- **音效**：  
  - 访问节点：8-bit “哔”声（Web Audio API）  
  - 找到最优解：经典FC过关音效  
- **自动演示**：按DFS顺序自动展开节点，每步延迟500ms，支持暂停/继续。  

### 核心JavaScript片段  
```javascript
// 节点绘制（Canvas）
function drawNode(x, y, value, state) {
  ctx.fillStyle = stateColors[state]; // 根据状态选择颜色
  ctx.fillRect(x * 30, y * 30, 28, 28); // 像素方块
  ctx.fillText(value, x * 30 + 4, y * 30 + 12); // 显示数值
}

// 自动演示逻辑
function autoDFS() {
  let stack = [initialNode];
  while (stack.length > 0) {
    let node = stack.pop();
    visitNode(node); // 播放音效并高亮
    let children = getChildren(node); // 生成上下界子节点
    stack.push(...children);
    await sleep(500); // 步进延迟
  }
}
```

---
处理用时：75.51秒
# 题目信息

# [ABC067D] Fennec VS. Snuke

## 题目描述

$Fennec$ 和 $Snuke$ 正在玩棋盘游戏。

在这个游戏中，有 $n$ 个格子和 $n-1$ 条道路， 编号为 $a_i$ 和 $b_i$ 的格子通过第 $i$ 条边相连。这些格子和边组成了一棵树。

第 $1$ 个格子是黑色，第 $n$ 个格子是白色，其他格子没有颜色。先手 $Fennec$ 和后手 $Snuke$ 交替给格子涂色，两人依次执行以下操作：

   $Fennec$：将一个与黑色格子相邻且未被涂色的格子涂成黑色。
   
   $Snuke$：将一个与白色格子相邻且未被涂色的格子涂成白色。

如果当前行动的玩家无法涂色，他将输掉游戏。请你写一个程序，判断当 $Fennec$ 和 $Snuke$ 都采取最佳策略时，谁能获胜。

## 样例 #1

### 输入

```
7

3 6

1 2

3 1

7 4

5 7

1 4```

### 输出

```
Fennec```

## 样例 #2

### 输入

```
4

1 4

4 2

2 3```

### 输出

```
Snuke```

# AI分析结果



## 唯一算法分类：BFS

### 综合分析与结论
题目核心是判断 Fennec 和 Snuke 在树形棋盘上的最优涂色策略。核心思路是通过计算每个节点到起点（1号节点）和终点（n号节点）的最短距离，根据距离决定归属（距离近的先占领，相等时 Fennec 因先手优势占领），最终比较总数。难点在于如何快速计算所有节点的距离并正确归属。

**搜索过程与可视化设计思路**：
1. **BFS 遍历**：从起点和终点分别发起 BFS，计算每个节点到两者的最短距离。
2. **距离比较**：对每个节点，若到起点的距离 ≤ 到终点的距离，则归 Fennec，否则归 Snuke。
3. **动画演示**：用两种颜色表示 BFS 扩展过程，动态展示队列节点的扩展顺序，颜色覆盖逻辑（如黑色先覆盖中间节点）。

### 题解清单（≥4星）
1. **tanghg（5星）**  
   - 亮点：代码简洁，两次 DFS 计算距离，逻辑清晰，可读性强。
   - 关键片段：
     ```cpp
     void dfs(ll u,ll f,ll id) {
         dis[id][u] = dis[id][f] + 1;
         for(int i : a[u]) {
             if(i != f) dfs(i, u, id);
         }
     }
     ```

2. **long_long__int（4星）**  
   - 亮点：两次 BFS 计算距离，通过标准 BFS 模板实现，结构规范。
   - 关键片段：
     ```cpp
     while(!q.empty()) {
         int u = q.front(); q.pop();
         for(int v : e[u]) {
             if(dis[0][v] > dis[0][u] + 1) {
                 dis[0][v] = dis[0][u] + 1;
                 q.push(v);
             }
         }
     }
     ```

3. **watcher_YBH（4星）**  
   - 亮点：通过 DFS 计算距离，代码简短，逻辑直接。
   - 关键片段：
     ```cpp
     if(vis[1][i] < vis[0][i]) ans++;
     else ans1++;
     ```

### 最优思路或技巧提炼
- **关键数据结构**：邻接表存储树，两个数组存储距离。
- **算法优化**：两次独立的 BFS/DFS 遍历，时间复杂度 O(n)，空间复杂度 O(n)。
- **思维角度**：将博弈问题转化为最短路径比较问题，避免模拟交替涂色的复杂操作。

### 同类型题与算法套路
- **类似问题**：树的直径（两次 BFS 求最长路径）、LCA（预处理距离）。
- **通用解法**：在树形结构中，最短路径问题优先考虑 BFS/DFS，博弈问题优先转化为状态比较。

### 推荐练习题
1. **P1395**：树的直径（两次 BFS 应用）。
2. **P3379**：LCA（预处理距离与祖先关系）。
3. **P1352**：树形 DP（与树结构相关的动态规划）。

### 个人心得摘录
> "计算每个节点到双方起点的距离后比较，避免复杂交替模拟，是本题的最优解。"  
> —— 通过数学建模简化博弈过程，是此类问题的关键突破点。

### 可视化与算法演示
**动画方案**：
1. **双色扩展**：用黑色和白色分别表示 Fennec 和 Snuke 的 BFS 扩展过程。
2. **步进控制**：用户可调节速度或单步执行，观察队列如何逐层扩展。
3. **颜色标记**：当前处理的节点高亮，已覆盖的节点静态显示归属色。
4. **复古风格**：8-bit 像素风格，用棋盘格子表示节点，音效提示扩展动作。

**代码片段（Canvas 绘制核心）**：
```javascript
// 伪代码：绘制节点归属
function drawNode(node, color) {
    ctx.fillStyle = color; // 黑色或白色
    ctx.fillRect(node.x * size, node.y * size, size, size);
}
// BFS 扩展动画
function animateBFS(queue, color) {
    let current = queue.shift();
    highlight(current); // 高亮当前节点
    for (let neighbor of getNeighbors(current)) {
        if (!visited[neighbor]) {
            visited[neighbor] = true;
            drawNode(neighbor, color);
            queue.push(neighbor);
        }
    }
}
```

---
处理用时：187.59秒
# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果



---

## **算法分类**
**其他搜索**（带权并查集为核心解法）

---

## **题解思路与解决难点**
### **核心思路**
1. **带权并查集**：维护每个节点到根节点的相对距离，合并集合时动态调整距离，检查约束冲突。
2. **DFS/SPFA**：将约束转化为图结构，通过遍历检查是否存在矛盾（如坐标冲突或负环）。

### **难点对比**
- **带权并查集**  
  - **难点**：路径压缩时如何更新相对距离，合并不同集合时的距离计算。  
  - **解决**：`dis[x]` 记录节点到父节点的距离，合并时通过 `dis[rl] = d + dis[r] - dis[l]` 调整。
  
- **DFS/SPFA**  
  - **难点**：处理多个连通分量，避免重复遍历。  
  - **解决**：用 `vis` 数组标记已访问节点，对每个未访问节点发起搜索。

---

## **题解评分（≥4星）**
1. **Doraven（带权并查集）**  
   - **评分**：★★★★★  
   - **亮点**：代码简洁高效，时间复杂度接近线性（$O(n + m \alpha(n))$），适合大规模数据。  
   - **关键代码**：  
     ```cpp
     int find(int x) {
         if (fa[x] != x) {
             int nf = fa[x];
             fa[x] = find(fa[x]);
             dis[x] += dis[nf];
         }
         return fa[x];
     }
     ```

2. **Wen_kr（差分约束/SPFA）**  
   - **评分**：★★★★  
   - **亮点**：标准差分约束实现，通过 `dist` 数组维护坐标，直接判断距离矛盾。  
   - **关键代码**：  
     ```cpp
     bool spfa(int st) {
         dist[st] = 0;
         while (!que.empty()) {
             int u = que.front();
             que.pop();
             for (int i = head[u]; i; i = e[i].nxt) {
                 if (dist[v] != dist[u] + e[i].w) 
                     return false;
             }
         }
         return true;
     }
     ```

3. **Error_666（DFS）**  
   - **评分**：★★★★  
   - **亮点**：简洁的 DFS 实现，通过 `pos` 数组记录坐标，直接比较约束。  
   - **关键代码**：  
     ```cpp
     void dfs(int x) {
         vis[x] = 1;
         for (int i = h[x]; i; i = e[i].next) {
             if (pos[v] == inf) pos[v] = pos[x] + e[i].dis;
             else if (pos[v] != pos[x] + e[i].dis) flag = 1;
         }
     }
     ```

---

## **最优思路提炼**
- **带权并查集**：  
  - **核心技巧**：路径压缩时动态更新距离，合并集合时计算相对偏移。  
  - **适用场景**：等式约束、连通性判断与动态合并。

---

## **类似算法套路**
1. **差分约束系统**：将不等式转化为图的最短路径问题（如 SPFA 判负环）。  
2. **并查集扩展**：处理带权关系（如食物链问题、区间合并）。  
3. **DFS/BFS 遍历**：图的连通性检查或约束冲突检测。

---

## **推荐题目**
1. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)（差分约束）  
2. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)（并查集划分集合）  
3. [P2863 The Cow Prom S](https://www.luogu.com.cn/problem/P2863)（强连通分量/DFS）

---

## **可视化与算法演示**
### **可视化设计**
- **节点与边展示**：  
  - 用不同颜色区分已访问/未访问节点。  
  - 动态显示并查集合并过程（如父节点指向变化）。  
- **带权并查集动画**：  
  1. **初始状态**：每个节点为独立集合，`dis` 为0。  
  2. **合并操作**：高亮两个节点，显示距离计算公式 `dis[rl] = d + dis[r] - dis[l]`。  
  3. **路径压缩**：展示节点路径压缩时的距离累加。  
- **像素风格**：  
  - 使用 8-bit 风格绘制节点（方块表示），边用箭头标注距离。  
  - 音效：合并成功（“叮”声），冲突发现（“警报”声）。

---

## **代码片段（带权并查集核心）**
```cpp
#include <cstdio>
int n, m, fa[100005], dis[100005];
bool ok = 1;

int find(int x) {
    if (fa[x] != x) {
        int nf = fa[x];
        fa[x] = find(fa[x]);
        dis[x] += dis[nf];
    }
    return fa[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) fa[i] = i;
    for (int i = 1; i <= m; i++) {
        int l, r, d;
        scanf("%d%d%d", &l, &r, &d);
        int rl = find(l), rr = find(r);
        if (rl == rr && dis[l] - dis[r] != d) ok = 0;
        if (rl != rr) {
            fa[rl] = rr;
            dis[rl] = d + dis[r] - dis[l];
        }
    }
    printf(ok ? "Yes" : "No");
    return 0;
}
```

---
处理用时：95.05秒
# 题目信息

# [ABC151E] Max-Min Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc151/tasks/abc151_e

有限個の整数からなる集合 $ X $ に対し $ f(X)=\max\ X\ -\ \min\ X $ と定義します。

$ N $ 個の整数 $ A_1,...,A_N $ が与えられます。

このうち $ K $ 個を選び、それらからなる集合を $ S $ とします。同じ値であっても添字が異なる要素を区別すると、そのような選び方は $ {}_N\ C_K $ 通りありますが、その全てについての $ f(S) $ の合計を求めてください。

答えは非常に大きくなる可能性があるので、$ \bmod\ 10^9+7 $ で出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

$ S $ の選び方は $ \{1,1\},\{1,3\},\{1,4\},\{1,3\},\{1,4\},\{3,4\} $ の $ 6 $ 通りあり (ふたつの $ 1 $ は区別します)、$ f(S) $ はそれぞれ $ 0,2,3,2,3,1 $ となるので、合計は $ 11 $ です。

### Sample Explanation 2

$ S $ の選び方は $ 20 $ 通りあり、そのうち $ 18 $ 通りで $ f(S)=20 $、$ 2 $ 通りで $ f(S)=0 $ となります。

### Sample Explanation 4

合計は $ \bmod\ 10^9+7 $ で出力してください。

## 样例 #1

### 输入

```
4 2

1 1 3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
6 3

10 10 10 -10 -10 -10```

### 输出

```
360```

## 样例 #3

### 输入

```
3 1

1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 6

1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0```

### 输出

```
999998537```

# AI分析结果



## 算法分类
组合数学

---

## 题解思路与核心难点

### 核心思路
所有题解的核心思想是：**通过排序将问题转化为每个元素作为最大值/最小值时的贡献次数计算**。具体步骤：
1. **排序数组**：将原数组升序排列，确保后续计算有序性
2. **贡献分离**：将总答案拆分为所有子集最大值之和减去最小值之和
3. **组合数计算**：对每个元素计算其作为最大值的方案数 `C(i-1, k-1)` 和作为最小值的方案数 `C(n-i, k-1)`

### 解决难点
1. **快速组合数计算**：通过预处理阶乘和逆元实现 O(1) 组合数查询
2. **负数取模处理**：在减法操作后需通过 `(ans % mod + mod) % mod` 保证结果非负
3. **边界条件处理**：如当 k=1 时所有子集贡献为 0 的特殊情况

---

## 题解评分（≥4星）

### 1. TonyYin（4.5星）
- **亮点**：详细注释 + 逆元预处理逻辑清晰
- **关键代码**：
  ```cpp
  for(int i = k; i <= n; i++) {
      ans = (ans + a[i] * C(i - 1, k - 1) % mod) % mod;
  }
  for(int i = 1; i <= n - k + 1; i++) {
      ans = (ans - a[i] * C(n - i, k - 1) % mod) % mod;
  }
  ```

### 2. WaterSun（4星）
- **亮点**：分离最大/最小值计算逻辑，代码模块化
- **关键片段**：
  ```cpp
  for (re int i = 1;i <= n;i++){
      a = Add(a,Mul(C(n - i,k - 1),arr[i]));
      b = Add(b,Mul(C(i - 1,k - 1),arr[i]));
  }
  ```

### 3. cheatme（4星）
- **亮点**：代码简洁，直接给出组合数公式推导
- **核心推导**：
  ```cpp
  sum += C(i-1, k-1) * a[i]  // 最大值贡献
  sum -= C(n-i, k-1) * a[i]  // 最小值贡献
  ```

---

## 最优思路与技巧

### 关键技巧
1. **排序后贡献分离**：排序确保只需考虑元素的相对位置，无需实际枚举子集
2. **组合数预处理**：通过阶乘和逆元实现 O(n) 预处理 + O(1) 查询
3. **对称性应用**：最大值贡献从前向后计算，最小值贡献从后向前计算

### 同类型题
- [P3414 SAC#1 - 组合数](https://www.luogu.com.cn/problem/P3414)
- [P3811 乘法逆元](https://www.luogu.com.cn/problem/P3811)
- [CF1420B. Rock and Lever](https://codeforces.com/problemset/problem/1420/B)

---

## 可视化设计

### 算法演示
1. **排序阶段**：显示数组升序排列过程，元素颜色渐变表示排序完成
2. **贡献计算**：
   - **最大值标记**：红色高亮当前元素，显示前 `i-1` 个元素中选 `k-1` 个的动画
   - **最小值标记**：蓝色高亮当前元素，显示后 `n-i` 个元素中选 `k-1` 个的动画
3. **组合数公式**：在元素旁实时显示 `C(i-1, k-1)` 和 `C(n-i, k-1)` 的计算过程

### 复古像素风格
- **颜色方案**：使用 8-bit 调色板（红/蓝/绿高亮，灰色背景）
- **音效设计**：
  - **元素选中**：8-bit "beep" 音效
  - **计算完成**：经典 FC 过关音效
- **自动演示**：AI 自动步进，速度可调（1x/2x/4x）

```javascript
// 伪代码：Canvas 绘制逻辑示例
function drawStep(i, isMax) {
  ctx.fillStyle = isMax ? "#FF0000" : "#0000FF";
  drawRect(i * cellSize, 0, cellSize, cellSize); // 高亮当前元素
  drawCombFormula(i, isMax); // 显示组合数公式
  playSound("select.wav");
}
```

---

## 核心代码实现

### 组合数预处理（Python 伪代码）
```python
MOD = 10**9+7
n, k = 1e5, 5e4
fac = [1]*(n+1)
for i in 1..n: fac[i] = fac[i-1] * i % MOD
inv = [1]*(n+1)
inv[n] = pow(fac[n], MOD-2, MOD)
for i in n-1..0: inv[i] = inv[i+1] * (i+1) % MOD

def C(a, b):
    return fac[a] * inv[b] % MOD * inv[a-b] % MOD
```

---

## 个人心得摘录
> "在调试时发现 `n-k+1` 的边界条件容易出错，必须严格保证剩余元素足够选择 k-1 个" —— _Flame_

---

## 推荐题目
1. [ABC179E - Sequence Sum](https://atcoder.jp/contests/abc179/tasks/abc179_e)
2. [洛谷 P3913 车的攻击](https://www.luogu.com.cn/problem/P3913)
3. [CF1538D. Another Problem About Dividing Numbers](https://codeforces.com/problemset/problem/1538/D)

---
处理用时：71.49秒
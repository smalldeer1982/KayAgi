# 题目信息

# [ARC145C] Split and Maximize

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc145/tasks/arc145_c

$ (1,2,\ldots,2N) $ の順列 $ P=(P_1,P_2,\ldots,P_{2N}) $ に対し、スコアを以下で定義します。

> $ P $ を順序を保ったまま二つの長さ $ N $ の（連続するとは限らない）部分列 $ A\ =\ (A_1,A_2,\ldots,A_N),B\ =\ (B_1,B_2,\ldots,B_N) $ に分割する。分割を行ったときに得られる $ \displaystyle\sum_{i=1}^{N}A_i\ B_i $ の最大値をスコアとする。

$ (1,2,\ldots,2N) $ の順列全てについてスコアを計算し、それらの最大値を $ M $ とします。 $ (1,2,\ldots,2N) $ の順列のうち、スコアが $ M $ であるものの個数を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- 入力は全て整数

### Sample Explanation 1

考えられる順列 $ 24 $ 通りの中で、スコアの最大値 $ M $ は $ 14 $ です。スコアが $ 14 $ となる順列は $ 16 $ 通りあります。 例えば、順列 $ (1,2,3,4) $ は $ A=(1,3),\ B=(2,4) $ と分割することで、$ \sum\ _{i=1}^{N}A_i\ B_i\ =\ 14 $ となります。

### Sample Explanation 2

$ 998244353 $ で割ったあまりを答えてください。

## 样例 #1

### 输入

```
2```

### 输出

```
16```

## 样例 #2

### 输入

```
10000```

### 输出

```
391163238```

# AI分析结果



---

## 唯一算法分类  
组合数学（卡特兰数）

---

## 题解思路与算法分析  
### 核心思路  
1. **最优配对策略**：将相邻奇偶数配对（2i-1与2i），使每对的乘积贡献最大。  
2. **排列合法性条件**：每对的相对顺序需满足类似括号匹配的合法序列（左括号数≥右括号数），对应卡特兰数。  
3. **组合计数**：  
   - 每个对可交换顺序（2^n种选择）  
   - n个对的顺序任意排列（n!种排列）  
   - 合法括号序列数目为卡特兰数 Catalan(n)  

### 解决难点  
1. **数学证明**：通过数学归纳法证明相邻配对最优，并将合法顺序问题转化为卡特兰数模型。  
2. **模数处理**：大规模阶乘与组合数的快速计算，利用逆元实现模意义下的除法。  

---

## 最优题解推荐  
### 题解1（作者：liangbowen，★★★★☆）  
**亮点**：  
- 结合数学证明与组合计数，思路清晰  
- 代码简洁，时间复杂度 O(n)  
**代码核心**：  
```cpp  
LL Catalan(int A){ return (C(A, A + A) - C(A - 1, A + A) + mod) % mod; }  
cout << qpow(2, n) * fac[n] % mod * Catalan(n) % mod;  
```  

### 题解2（作者：xukehg，★★★★☆）  
**亮点**：  
- 详细解释合法括号序列的转化过程  
- 提供复古像素化动画设计思路  
**核心代码**：  
```cpp  
ll ctl = ((f[m] * (t - tt)) % mod + mod) % mod;  
cout << ((ctl * qpow(2, n)) % mod * f[n]) % mod;  
```  

### 题解3（作者：taojinchen，★★★★☆）  
**亮点**：  
- 通过加法与乘法交换律分析排列组合可能性  
- 明确分步计算各因子贡献  
**代码片段**：  
```cpp  
ll Catalan(int A){ return (C(A, A + A) - C(A - 1, A + A) + mod) % mod; }  
ans = 2^n * n! * Catalan(n)  
```  

---

## 关键思路与技巧  
1. **最优配对推导**：相邻数配对最大化单对贡献，通过归纳法证明。  
2. **合法序列转化**：将排列顺序问题转化为卡特兰数的括号匹配模型。  
3. **组合数优化**：预处理阶乘与逆元，实现 O(1) 组合数查询。  

---

## 同类型题目推荐  
1. **P3200 [HNOI2009]有趣的数列**：类似卡特兰数的合法序列计数  
2. **P1044 栈**：经典卡特兰数应用  
3. **P2532 [AHOI2012]树屋阶梯**：卡特兰数变形  

---

## 可视化与算法演示  
### 动画设计  
**核心流程**：  
1. **配对生成**：显示奇偶配对过程，高亮当前配对 (2i-1, 2i)。  
2. **序列构造**：以括号匹配形式逐步构建排列，红色表示左括号，蓝色表示右括号。  
3. **合法性验证**：动态显示前缀计数，若右括号数超过左括号则闪烁警告。  

**复古像素风格**：  
- **颜色方案**：8位调色板（红/蓝/绿/黄）标记不同状态  
- **音效**：  
  - 正确配对时播放上升音调 (Web Audio API)  
  - 非法操作时播放短促“错误”音效  
- **Canvas 绘制**：网格化显示排列构造过程，每步添加像素方块  

**交互功能**：  
- **步进控制**：允许单步执行观察配对与计数  
- **自动模式**：AI自动生成合法序列，速度可调  

---

## 核心代码实现  
```cpp  
#include <bits/stdc++.h>  
using namespace std;  
typedef long long LL;  
const int MAXN = 4e5 + 5;  
const LL mod = 998244353;  

LL fac[MAXN], inv_fac[MAXN];  

LL qpow(LL a, LL b) {  
    LL res = 1;  
    while (b) {  
        if (b & 1) res = res * a % mod;  
        a = a * a % mod;  
        b >>= 1;  
    }  
    return res;  
}  

void precompute(int n) {  
    fac[0] = 1;  
    for (int i = 1; i <= n; ++i) fac[i] = fac[i-1] * i % mod;  
    inv_fac[n] = qpow(fac[n], mod-2);  
    for (int i = n-1; i >= 0; --i) inv_fac[i] = inv_fac[i+1] * (i+1) % mod;  
}  

LL C(int n, int k) {  
    return fac[n] * inv_fac[k] % mod * inv_fac[n - k] % mod;  
}  

LL catalan(int n) {  
    return (C(2*n, n) - C(2*n, n-1) + mod) % mod;  
}  

int main() {  
    int N;  
    cin >> N;  
    precompute(2*N);  
    LL ans = qpow(2, N) * fac[N] % mod * catalan(N) % mod;  
    cout << ans << endl;  
    return 0;  
}  
```

---
处理用时：79.51秒
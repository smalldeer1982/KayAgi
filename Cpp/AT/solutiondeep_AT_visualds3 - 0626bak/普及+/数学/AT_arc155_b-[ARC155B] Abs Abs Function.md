# 题目信息

# [ARC155B] Abs Abs Function

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc155/tasks/arc155_b

$ 2 $ つの非負整数からなる組の集合 $ S $ 、および非負整数 $ x $ に対し $ f_S(x) $ を $ \displaystyle\ f_S(x)=\min_{(a,\ b)\ \in\ S}\ \left|\ \left|\ x-a\ \right|\ -\ b\ \right| $ と定義します。

$ 2 $ つの非負整数からなる組の集合 $ T $ があります。はじめ $ T=\lbrace\ (A,\ B)\rbrace $ です。

$ Q $ 個のクエリを処理してください。$ i $ 番目のクエリでは $ 3 $ つの非負整数 $ t_i,\ a_i,\ b_i $ が与えられるので、以下のように処理してください。

- $ t_i=1 $ のとき 、 $ T $ に $ 2 $ つの非負整数からなる組 $ (a_i,\ b_i) $ を追加する。
- $ t_i=2 $ のとき 、 $ a_i\ \leq\ x\ \leq\ b_i $ を満たす非負整数 $ x $ に対する $ f_{T}(x) $ の最小値を出力する。

## 说明/提示

### 制約

- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A,B\ \leq\ 10^{9} $
- $ t_i $ は $ 1 $ または $ 2 $
- $ 0\ \leq\ a_i,b_i\ \leq\ 10^{9} $
- $ t_i=2 $ のとき、$ a_i\ \leq\ b_i $
- $ t_i=2 $ を満たすクエリは $ 1 $ つ以上存在する
- 入力される値はすべて整数
 
### Sample Explanation 1

$ 2 $ 番目のクエリを実行するとき、$ T=\lbrace(0,\ 5),\ (3,\ 11)\ \rbrace $ であり、たとえば $ x=7 $ とすると $ f_T(7)=\min\ \lbrace\ \left|\ \left|7-0\right|-5\right|,\ \left|\ \left|7-3\right|-11\right|\ \rbrace=\min\ \lbrace\ 2,\ 7\ \rbrace=2 $ となります。 同様に、$ f_T(8)=3 $ となります。よって $ 2 $ 番目のクエリの答えは $ \min\ \lbrace\ 2,\ 3\ \rbrace\ =2 $ です。 $ 4 $ 番目のクエリを実行するとき、 $ T=\lbrace(0,\ 5),\ (3,\ 11),\ (8,\ 2)\ \rbrace $ です。$ 8\ \leq\ x\ \leq\ 9 $ において $ f_T(x) $ は $ x=9 $ で最小値 $ f_T(9)=1 $ をとります。

## 样例 #1

### 输入

```
4 0 5

1 3 11

2 7 8

1 8 2

2 8 9```

### 输出

```
2

1```

## 样例 #2

### 输入

```
2 1 2

1 2 3

2 2 6```

### 输出

```
0```

## 样例 #3

### 输入

```
20 795629912 123625148

2 860243184 892786970

2 645778367 668513124

1 531411849 174630323

1 635062977 195695960

2 382061637 411843651

1 585964296 589553566

1 310118888 68936560

1 525351160 858166280

2 395304415 429823333

2 583145399 703645715

2 97768492 218377432

1 707220749 459967102

1 210842017 363390878

2 489541834 553583525

2 731279777 811513313

1 549864943 493384741

1 815378318 826084592

2 369622093 374205455

1 78240781 821999998

2 241667193 243982581```

### 输出

```
26468090

3491640

25280111

9543684

0

22804896

20649370

19245624

4849993

484865```

# AI分析结果



---

## **算法分类**  
**数据结构（集合维护）**

---

## **题解思路、算法要点与解决难点**  
### **核心思路**  
将每个二元组 `(a, b)` 拆分为两个关键点 `a+b` 和 `a-b`，存入有序集合。查询时，检查区间 `[a_i, b_i]` 内是否存在集合中的点：  
- **存在**：答案为 `0`  
- **不存在**：计算区间端点与最近集合点的距离，取最小值  

### **解决难点**  
1. **表达式化简**：通过分情况讨论，将原式转化为对两个关键点的绝对距离计算。  
2. **高效维护与查询**：利用 `set` 的 `lower_bound` 和 `upper_bound` 实现 O(log N) 的插入和查询。  
3. **边界处理**：处理集合中所有元素均小于查询区间左端点或大于右端点的极端情况。  

### **关键实现**  
- **插入操作**：将 `a+b` 和 `a-b` 插入集合。  
- **查询操作**：  
  - 使用 `lower_bound` 找到第一个不小于区间左端点的元素。  
  - 若该元素在区间内，直接返回 `0`。  
  - 否则，计算左端点的前驱和右端点的后继，取最小距离。  

---

## **题解评分（≥4星）**  
1. **Scrolling_Ball（★★★★☆）**  
   - **亮点**：代码简洁，处理边界条件清晰（如 `rbegin()` 和 `begin()` 的特殊情况）。  
   - **改进点**：可优化注释和变量名。  

2. **Augury（★★★★☆）**  
   - **亮点**：引入极值哨兵（`inf` 和 `-inf`）简化边界判断，逻辑严密。  
   - **改进点**：代码中的 `query` 函数可进一步封装。  

3. **Rushroom（★★★★☆）**  
   - **亮点**：代码极简，直接使用 `set` 的迭代器操作，效率高。  
   - **改进点**：需补充注释解释关键步骤。  

---

## **最优思路或技巧提炼**  
1. **关键点拆分**：将每个二元组映射为两个独立数值，避免嵌套绝对值的复杂计算。  
2. **有序集合维护**：利用 `set` 自动排序特性，快速定位最近邻。  
3. **区间查询优化**：仅需检查区间端点与最近邻的关系，避免遍历整个区间。  

---

## **同类型题或类似算法套路**  
- **最近邻查询**：如线段树维护区间极值、平衡树查找前驱/后继。  
- **绝对值优化**：将复杂绝对值表达式拆分为分段函数。  
- **离散化处理**：将动态插入的数值映射到有序结构。  

---

## **推荐相似题目**  
1. **P1886 滑动窗口**（维护区间极值）  
2. **P3369 普通平衡树**（插入、删除、查询前驱/后继）  
3. **CF702F T-Shirts**（离线查询与集合维护）  

---

## **个人心得摘录**  
- **Scrolling_Ball**：  
  > “如果最大值都比 a 小，lower_bound 是搜不出来值的，所以需要特判。”  
  → **教训**：注意迭代器失效和边界条件。  

- **Augury**：  
  > “这个式子的值可以方便地用 set 维护。”  
  → **思维角度**：将复杂问题转化为已知数据结构操作。  

---

## **可视化与算法演示**  
### **动画方案**  
1. **数据结构展示**：  
   - 用像素方块表示集合中的数值，按升序排列在水平轴上。  
   - 插入操作时，动态生成新方块并插入正确位置（绿色高亮）。  

2. **查询过程演示**：  
   - **输入区间**：显示区间 `[a, b]` 的红色框。  
   - **查找最近邻**：  
     - 黄色箭头标记 `lower_bound(a)` 的位置。  
     - 若在区间内，整个区间闪烁绿色，显示答案 `0`。  
     - 否则，用蓝色箭头标记前驱（左）和后继（右），计算距离并显示最小值。  

3. **复古音效**：  
   - **插入成功**：短促“滴”声。  
   - **找到答案**：成功音效（上扬音调）。  
   - **无解区间**：低沉音效。  

### **代码片段（Canvas 绘制关键帧）**  
```javascript
function drawSet(ctx, setValues, a, b) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制集合元素
  setValues.forEach((val, idx) => {
    drawPixelBlock(ctx, val, idx * 20, val >= a && val <= b ? 'red' : 'blue');
  });
  // 绘制查询区间
  ctx.strokeStyle = 'red';
  ctx.strokeRect(a * 10, 50, (b - a) * 10, 30);
}
```

---

## **总结**  
本题通过拆分绝对值和有序集合维护，将复杂查询转化为高效数据结构操作。核心在于将二元组映射为单值，并利用 `set` 快速定位最近邻。可视化设计通过像素动画和音效增强理解，适用于类似区间查询问题的教学演示。

---
处理用时：70.95秒
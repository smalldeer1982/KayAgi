# 题目信息

# [ARC189B] Minimize Sum

## 题目描述

数轴上有 $N$ 个棋子，最初所有棋子都放置在不同的坐标上，第 $i$ 个棋子放置在坐标 $X_i$ 上。

你可以进行以下操作若干次（可以为 $0$ 次）：

- 选择一个 $i$ 满足 $1\le i\le N-3$，并设 $M$ 为 $X_i$ 与 $X_{i+3}$ 的中点坐标。

- 然后，分别将坐标为 $X_{i+1}$ 与 $X_{i+2}$ 的两颗棋子放在原坐标关于 $M$ 对称的坐标，最后，使坐标较小的棋子的坐标为 $X_{i+1}$，另外一个棋子的坐标为 $X_{i+2}$。

- 可以证明无论如何重复操作，所有的棋子都放置在不同的坐标处。

请找出若干次操作后，$\sum_{i=1}^N X_i$ 的最小值。

## 样例 #1

### 输入

```
4

1 5 7 10```

### 输出

```
21```

## 样例 #2

### 输入

```
6

0 1 6 10 14 16```

### 输出

```
41```

# AI分析结果



**唯一算法分类**  
贪心

---

### **题解思路与难点分析**

**核心思路**  
- **差分数组转化**：将原数组转化为差分数组，每次操作等价于交换差分数组中相距两个位置的元素（奇偶位置分别交换）。
- **奇偶分组排序**：奇偶位置的差分项可以分别排序，使得总和最小。前面的差分项在总和中的权重更大，故将较小的差分项放在前面。

**解决难点**  
- **操作对差分数组的影响**：推导发现操作仅交换差分数组中的奇偶位置项，且奇偶位置可独立排序。
- **权重分析**：总和可表示为 $\sum_{i=1}^N \sum_{j=1}^i d_j$，因此较小的 $d_j$ 应尽量靠前。

---

### **题解评分 (≥4星)**

1. **ARIS2_0（5星）**  
   - 思路清晰，通过差分交换的推导明确奇偶分组排序的必要性。
   - 代码简洁，直接实现分组排序与合并，可读性高。

2. **dingxiongyue（4星）**  
   - 详细推导差分变化，代码注释清晰。
   - 实现中差分数组从 1 开始索引，避免越界问题。

3. **A2_Zenith（4星）**  
   - 代码实现规范，分组排序逻辑清晰。
   - 提供了公式推导，帮助理解权重分配。

---

### **最优思路与技巧**

1. **差分数组转换**：将操作转化为差分项的交换，避免直接操作原数组。
2. **奇偶分组贪心**：通过独立排序奇偶位置的差分项，实现总和最小化。
3. **权重计算优化**：利用前缀和的性质，将总和拆解为差分项的累加权值。

---

### **类似题目与套路**

- **类似题目**：  
  1. [NOIP2021 方差](https://www.luogu.com.cn/problem/P7962)  
  2. [CF1110E Magic Stones](https://codeforces.com/problemset/problem/1110/E)  
  3. [ABC276 F](https://atcoder.jp/contests/abc276/tasks/abc276_f)  

- **通用套路**：  
  差分数组的变换与贪心排序结合，常用于最小化总和或方差类问题。

---

### **个人心得摘录**

- **调试教训**：差分数组索引易错，需明确奇偶分组的起始位置。
- **顿悟**：操作等价于交换差分项的奇偶位置，进而可独立排序。

---

### **可视化与算法演示**

**核心步骤可视化**  
1. **初始差分数组**：展示原数组对应的差分项。
2. **奇偶分组排序**：用不同颜色标记奇偶项，动态排序。
3. **合并差分数组**：按奇偶位置填充排序后的项。
4. **计算总和**：逐步累加生成最终结果。

**复古像素风格设计**  
- **颜色方案**：奇数项用绿色，偶数项用蓝色，背景 8-bit 网格。
- **音效**：交换时播放“哔”声，排序完成播放上扬音效。
- **Canvas 动画**：差分项以方块形式滑动交换，排序后合并。

---

### **代码实现（关键逻辑）**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
    int n; cin >> n;
    vector<int> a(n), d(n-1);
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 1; i < n; i++) d[i-1] = a[i] - a[i-1];
    
    vector<int> odd, even;
    for (int i = 0; i < d.size(); i++) {
        (i % 2 ? even : odd).push_back(d[i]);
    }
    
    sort(odd.begin(), odd.end());
    sort(even.begin(), even.end());
    
    int ptr_odd = 0, ptr_even = 0;
    for (int i = 0; i < d.size(); i++) {
        d[i] = (i % 2 ? even[ptr_even++] : odd[ptr_odd++]);
    }
    
    int sum = a[0], ans = a[0];
    for (int x : d) {
        sum += x;
        ans += sum;
    }
    cout << ans << endl;
    return 0;
}
```

---

**总结**：通过差分数组的奇偶分组排序，将问题转化为贪心策略，最终实现总和最小化。

---
处理用时：198.41秒
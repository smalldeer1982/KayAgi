# 题目信息

# [ABC254F] Rectangle GCD

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc254/tasks/abc254_f

正整数 $ N $ と長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ と $ B=(B_1,B_2,\dots,B_N) $ が与えられます。

$ N\ \times\ N $ のマス目があります。上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,j) $ と呼びます。$ 1\ \le\ i,j\ \le\ N $ を満たす整数の組 $ (i,j) $ に対し、マス $ (i,j) $ に $ A_i\ +\ B_j $ が書かれています。以下のクエリを $ Q $ 個処理してください。

- $ 1\ \le\ h_1\ \le\ h_2\ \le\ N,1\ \le\ w_1\ \le\ w_2\ \le\ N $ を満たす整数の組 $ h_1,h_2,w_1,w_2 $ が与えられる。左上隅が $ (h_1,w_1) $、右下隅が $ (h_2,w_2) $ である矩形領域に含まれる整数の最大公約数を求めよ。

## 说明/提示

### 制約

- $ 1\ \le\ N,Q\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i,B_i\ \le\ 10^9 $
- $ 1\ \le\ h_1\ \le\ h_2\ \le\ N $
- $ 1\ \le\ w_1\ \le\ w_2\ \le\ N $
- 入力はすべて整数である。

### Sample Explanation 1

マス $ (i,j) $ に書かれている整数を $ C_{i,j} $ とします。 $ 1 $ 個目のクエリについて、$ C_{1,2}=4,C_{1,3}=6,C_{2,2}=6,C_{2,3}=8 $ なのでこれらの最大公約数の $ 2 $ が答えとなります。

## 样例 #1

### 输入

```
3 5
3 5 2
8 1 3
1 2 2 3
1 3 1 3
1 1 1 1
2 2 2 2
3 3 1 1```

### 输出

```
2
1
11
6
10```

## 样例 #2

### 输入

```
1 1
9
100
1 1 1 1```

### 输出

```
109```

# AI分析结果



# ABC254F Rectangle GCD 题解分析

## 算法分类
**区间查询与GCD性质**

## 题解思路与解决难点
### 核心思路
1. **更相减损术**：利用 $\gcd(a_1, a_2, \dots, a_n) = \gcd(a_1, a_2-a_1, \dots, a_n-a_{n-1})$ 将矩阵中连续的数值转化为差分数组的GCD问题。
2. **预处理差分数组**：分别处理数组A和B的差分数组，构建ST表或线段树以支持区间GCD查询。
3. **查询优化**：每个矩形区域的GCD可分解为初始值、行差分区间GCD和列差分区间GCD的组合。

### 解决难点
- **思维转换**：将二维矩阵问题转化为一维差分数组的区间查询。
- **区间查询结构选择**：ST表（静态数据）或线段树（动态数据）的选择，本题选用ST表更优。

---

## 高星题解推荐 (≥4星)
1. **Powerless233（5星）**
   - **亮点**：使用ST表实现，代码简洁高效，时间复杂度为 $O(n \log n + q \log n)$。
   - **关键代码**：
     ```cpp
     for (int j=1; j<=20; j++)
         for (int i=1; i + (1 << j) -1 <=n; i++) {
             ga[i][j] = gcd(ga[i][j-1], ga[i + (1 << (j-1))][j-1]);
             gb[i][j] = gcd(gb[i][j-1], gb[i + (1 << (j-1))][j-1]);
         }
     ```

2. **Gyc_Fisher（4.5星）**
   - **亮点**：详细推导更相减损术的应用，线段树实现清晰，附带快速GCD优化。
   - **核心代码**：
     ```cpp
     int querya(int l, int r) {
         if (l > r) return 0;
         int k = log2(r - l + 1);
         return gcd(ga[l][k], ga[r - (1<<k)+1][k]);
     }
     ```

3. **liangbowen（4星）**
   - **亮点**：代码简洁，直接应用ST表，逻辑清晰无冗余。
   - **代码片段**：
     ```cpp
     printf("%d\n", gcd(gcd(A.query(h1+1, h2), B.query(w1+1, w2)), a[h1]+b[w1]));
     ```

---

## 最优思路提炼
1. **差分转换**：将矩阵元素转化为差分数组，避免重复计算。
2. **静态区间查询**：使用ST表预处理差分数组，单次查询时间复杂度 $O(1)$。
3. **组合结果**：最终结果为初始值与行、列差分区间GCD的组合。

---

## 同类问题推荐
1. **AcWing 246**：区间最大公约数（动态更新与查询）。
2. **洛谷 P1890**：静态区间GCD查询。
3. **Codeforces 1547F**：循环数组中的连续区间GCD性质。

---

## 可视化设计
### 算法动画演示
1. **差分过程高亮**：展示矩阵如何通过差分转换为行和列的独立计算。
2. **ST表构建**：动态显示分层预处理差分数组的过程。
3. **查询分解**：用颜色区分初始值、行差分和列差分的计算步骤。

### 复古像素风格
- **颜色方案**：使用8位色（红、蓝、绿）区分矩阵元素、差分数组和查询区域。
- **音效设计**：
  - **步骤正确**：播放短促“滴”声。
  - **查询完成**：成功音效（上扬音调）。
- **Canvas动画**：网格显示矩阵，差分区域用闪烁方块标记。

---

## 核心代码实现（ST表）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, LOG = 20;
int n, q, a[N], b[N], ga[N][LOG], gb[N][LOG];

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

void build(int arr[], int g[][LOG], int n) {
    for (int i = 2; i <= n; i++) g[i][0] = abs(arr[i] - arr[i-1]);
    for (int j = 1; (1 << j) <= n; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            g[i][j] = gcd(g[i][j-1], g[i + (1 << (j-1))][j-1]);
}

int query(int g[][LOG], int l, int r) {
    if (l > r) return 0;
    int k = log2(r - l + 1);
    return gcd(g[l][k], g[r - (1 << k) + 1][k]);
}

int main() {
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
    build(a, ga, n); build(b, gb, n);
    while (q--) {
        int h1, h2, w1, w2;
        scanf("%d%d%d%d", &h1, &h2, &w1, &w2);
        int ans = a[h1] + b[w1];
        ans = gcd(ans, gcd(query(ga, h1+1, h2), query(gb, w1+1, w2)));
        printf("%d\n", ans);
    }
    return 0;
}
```

---

**关键注释**：代码通过ST表预计算差分数组的区间GCD，每个查询分解为初始值和两个差分区间结果的组合，时间复杂度 $O(n \log n + q)$。

---
处理用时：71.13秒
# 题目信息

# [ARC124C] LCM of GCDs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc124/tasks/arc124_c

赤い袋と青い袋と $ N $ 個のカードパックがあります。はじめどちらの袋も空です。 それぞれのカードパックには整数が書かれた $ 2 $ 枚のカードが封入されており、$ i $ 番目のカードパックに入っているカードにはそれぞれ $ a_i,b_i $ が書かれていることがわかっています。

それぞれのカードパックについて、一方のカードを赤い袋に、他方のカードを青い袋に入れます。

カードを袋に入れ終えたのち、赤い袋に入ったカードに書かれた整数全体の最大公約数を $ X $ とします。 同様に、青い袋に入ったカードに書かれた整数全体の最大公約数を $ Y $ とします。 $ X $ と $ Y $ の最小公倍数の値が得点となります。

得点としてありうる値の最大値を求めてください。

## 说明/提示

### 制約

- 与えられる入力は全て整数
- $ 1\ \leq\ N\ \leq\ 50 $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ 10^9 $

### Sample Explanation 1

\- $ 2 $ が書かれたカードを赤い袋に入れ、$ 15 $ が書かれたカードを青い袋に入れ、$ 6 $ が書かれたカードを赤い袋に入れ、$ 10 $ が書かれたカードを青い袋に入れるのが最適な入れ方の $ 1 $ つです。 - このとき、赤い袋に入ったカードに書かれた整数全体の最大公約数は $ 2 $、青い袋に入ったカードに書かれた整数全体の最大公約数は $ 5 $ です。 - このときの得点は $ 10 $ です。

## 样例 #1

### 输入

```
2

2 15

10 6```

### 输出

```
10```

## 样例 #2

### 输入

```
5

148834018 644854700

947642099 255192490

35137537 134714230

944287156 528403260

68656286 200621680```

### 输出

```
238630```

## 样例 #3

### 输入

```
20

557057460 31783488

843507940 794587200

640711140 620259584

1901220 499867584

190122000 41414848

349507610 620259584

890404700 609665088

392918800 211889920

507308870 722352000

156850650 498904448

806117280 862969856

193607570 992030080

660673950 422816704

622015810 563434560

207866720 316871744

63057130 117502592

482593010 366954816

605221700 705015552

702500790 900532160

171743540 353470912```

### 输出

```
152594452160```

# AI分析结果



# ARC124C LCM of GCDs 题解分析

## 1. 算法分类
**因数分解与枚举**

## 2. 题解思路与核心难点
### 核心思路
- **因数约束**：最终红袋的 GCD（X）必为第一个卡包某数的因数，蓝袋的 GCD（Y）必为第一个卡包另一数的因数。通过枚举这些因数，将问题转化为验证每个因数对的可行性。
- **可行性检查**：对于每个候选的 X 和 Y，检查所有卡包是否存在分配方式，使得每个卡包的数满足 `(a_i % X == 0 && b_i % Y == 0) || (b_i % X == 0 && a_i % Y == 0)`。

### 解决难点
- **高效枚举**：直接枚举所有可能的 X 和 Y 不可行，但通过约束为第一个卡包的因数，将候选值数量从 1e9 降到约 1e3。
- **快速验证**：对于每个候选对 (X,Y)，需 O(N) 时间检查所有卡包是否可分配，总复杂度为 O(N * d(a1) * d(b1))，可接受。

## 3. 题解评分（≥4星）
### 1️⃣ User_Authorized（5星）
- **亮点**：代码结构清晰，直接枚举因数对并验证，通过 STL 函数简化逻辑。
- **代码片段**：
  ```cpp
  bool check(valueType a, valueType b, PairVector const &data) {
      return std::all_of(data.begin(), data.end(), [a, b](ValuePair const &iter) {
          return (iter.first % a == 0 && iter.second % b == 0) || (iter.second % a == 0 && iter.first % b == 0);
      });
  }
  ```

### 2️⃣ zhengpie（4星）
- **亮点**：优化检查顺序，提前剪枝无效候选对，提升运行效率。
- **代码片段**：
  ```cpp
  if(ans < lcm(i,j)) // 提前跳过不可能更新答案的情况
      if(chk(i,j)) ans = lcm(i,j);
  ```

### 3️⃣ Tastoya（4星）
- **亮点**：明确约数分解步骤，直观展示因数生成与验证流程。
- **代码片段**：
  ```cpp
  for(auto const &i : Fac1) {
      for(auto const &j : Fac2) {
          if(Check(i,j)) {
              ans = max(ans,lcm(i,j));
          }
      }
  }
  ```

## 4. 最优技巧提炼
- **因数约束法**：利用第一个卡包确定候选值的范围，极大减少枚举量。
- **对称性剪枝**：红蓝袋的对称性允许仅枚举一种分配方式，避免重复计算。
- **快速验证模板**：使用 `std::all_of` 或循环提前退出，优化可行性检查。

## 5. 同类题目
- **P1412 [TJOI2009] 狼和羊的故事**：利用因数分解优化网络流建图。
- **P2444 [POI2000] 病毒**：通过因数性质构造自动机状态。
- **CF1538D Another Problem About Dividing Numbers**：基于因数分解的贪心策略。

## 6. 可视化设计
### 动画方案
1. **网格展示**：将每个卡包的分配可能性用网格表示，绿色标记合法分配，红色标记非法。
2. **步进检查**：高亮当前检查的卡包，动态显示 `(a_i, b_i)` 是否符合当前 (X,Y) 对。
3. **因数树展开**：用树状图展示第一个卡包的因数分解过程，动态生成候选 X 和 Y。

### 复古游戏化
- **像素风格**：用 8-bit 像素字体显示因数和 LCM 值，音效提示候选对是否可行。
- **自动演示**：AI 自动遍历因数对，用贪心策略优先检查大 LCM 候选，类似“贪吃蛇AI”路径搜索。

## 7. 核心代码实现
```cpp
// 分解数的所有因数
vector<int> get_factors(int x) {
    vector<int> res;
    for (int i=1; i*i<=x; i++) {
        if (x%i == 0) {
            res.push_back(i);
            if (i != x/i) res.push_back(x/i);
        }
    }
    sort(res.begin(), res.end());
    return res;
}

// 主逻辑
int max_lcm = 0;
vector<int> factors_a = get_factors(a[0]);
vector<int> factors_b = get_factors(b[0]);
for (int x : factors_a) {
    for (int y : factors_b) {
        bool valid = true;
        for (int i=1; i<n; i++) {
            if (!((a[i]%x==0 && b[i]%y==0) || (b[i]%x==0 && a[i]%y==0))) {
                valid = false;
                break;
            }
        }
        if (valid) 
            max_lcm = max(max_lcm, lcm(x,y));
    }
}
cout << max_lcm << endl;
```

---
处理用时：110.19秒
# 题目信息

# [ARC159B] GCD Subtraction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc159/tasks/arc159_b

変数 $ a,b $ があり、初め $ a=A,\ b=B $ です。

高橋君は $ a,b $ がともに $ 1 $ 以上の間、次の操作を繰り返すことにしました。

- $ a $ と $ b $ の最大公約数を $ g $ とする。そして、$ a,b $ をそれぞれ $ a-g,b-g $ に置き換える。
 
操作は何回行われますか。

## 说明/提示

### 制約

- $ 1\ \leq\ A,B\ \leq\ 10^{12} $
- $ A,B $ は整数
 
### Sample Explanation 1

$ a=15,b=9 $ の状態から以下のように操作が行われます。 - $ g=3 $ とする。そして、$ a,b $ がそれぞれ $ 12(=15-3),6(=9-3) $ に置き換えられる。 - $ g=6 $ とする。そして、$ a,b $ がそれぞれ $ 6(=12-6),0(=6-6) $ に置き換えられる。$ b $ が $ 1 $ 以上でなくなったため、操作の繰り返しはここで終了する。

## 样例 #1

### 输入

```
15 9```

### 输出

```
2```

## 样例 #2

### 输入

```
1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
12345678910 10987654321```

### 输出

```
36135```

# AI分析结果



## 唯一算法分类
**数论**

---

## 综合分析与结论

### 核心思路与难点
1. **直接模拟不可行**：当 a,b 互质时每次只能减 1，时间复杂度退化到 O(ans)
2. **关键优化点**：找到最大的连续减 1 次数 x，使得减 x 次后出现非 1 的 gcd
3. **数学推导**：设最终 gcd 为 d，则 d 必须是 |a-b| 的因数。通过枚举 |a-b| 的因数，计算最小 x = min(a%k, b%k)
4. **时间复杂度**：O(√n logn)，通过因数枚举和递归处理优化

### 可视化设计要点
1. **像素化数值展示**：用 8-bit 风格显示当前 a,b 值，每次操作后数值闪烁
2. **跳跃过程展示**：当检测到连续减 1 时，用绿色高亮显示跳跃次数 x 和最终 g 值
3. **音效系统**：
   - 常规操作：8-bit 短音效（类似 FC 金币音）
   - 大跳跃操作：上升音阶音效
   - 边界条件触发：复古胜利音效
4. **自动演示模式**：AI 自动选择最优跳跃策略，可对比暴力模拟与优化算法的执行路径

---

## 题解清单（≥4星）

1. **Daniel_yao（⭐⭐⭐⭐⭐）**
   - 亮点：清晰分解边界条件，优雅处理因数枚举
   - 代码结构：通过 quick() 函数封装跳跃逻辑，swap 保持 a > b 简化处理
   - 心得：通过 hack 样例发现优化必要性

2. **Xy_top（⭐⭐⭐⭐）**
   - 亮点：详尽数学推导，注释清晰的同余关系处理
   - 代码特征：独立 fun() 函数处理跳跃，swap 维护有序性
   - 心得：强调开 long long 的重要性

3. **lzqy_（⭐⭐⭐⭐）**
   - 亮点：递归实现思路新颖，质因数分解加速
   - 代码特征：calc() 函数递归处理，边界条件优先判断
   - 心得：自述 8 发罚时的边界处理教训

---

## 核心代码实现

```cpp
void quick(int p) { // 处理连续减1的跳跃逻辑
    int x = b;
    for (int i = 2; i * i <= p; i++) {
        if(p % i == 0) {
            if(a % i == b % i) x = min(x, a % i);
            if(a % (p/i) == b % (p/i)) x = min(x, a % (p/i));
        }
    }
    if(a % p == b % p) x = min(x, a % p);
    a -= x, b -= x, ans += x;
}

signed main() {
    a = read(), b = read();
    while(a && b) {
        if(a < b) swap(a, b);
        int gcd = __gcd(a, b);
        a /= gcd, b /= gcd; // 提取公共因子
        if(a == b) { ans++; break; } // 边界1：相等情况
        if(a == b + 1) { ans += b; break; } // 边界2：差为1
        quick(a - b); // 核心跳跃逻辑
    }
    cout << ans << '\n';
}
```

---

## 相似题目推荐

1. **P1029 最大公约数和最小公倍数问题**  
   （数论性质应用，因数分解）

2. **P1072 Hankson 的趣味题**  
   （多重 gcd/lcm 约束条件下的数值求解）

3. **P5431 乘法逆元**  
   （模运算与同余关系的高级应用）

---

## 复古游戏化设计示例

```javascript
// 伪代码示例：8-bit 风格动画核心逻辑
class GCDAnimation {
  constructor(a, b) {
    this.pixelA = new PixelNumber(a, 100, 100); // 像素化数字显示
    this.pixelB = new PixelNumber(b, 100, 150);
    this.sound = new RetroSound(); // 8-bit 音效系统
  }

  async jump(x, g) {
    this.pixelA.blink(); // 数字闪烁效果
    this.pixelB.blink();
    this.sound.playJump(x); // 根据跳跃长度播放不同音高
    await animateNumberDecrease(x); // 数字递减动画
    this.showGCD(g); // 高亮显示新gcd值
  }

  async autoPlay() {
    while (a > 0 && b > 0) {
      const d = Math.abs(a - b);
      const factors = getFactors(d); // 因数计算
      // ... 决策逻辑与动画调用
    }
  }
}
```

---

## 关键思路总结

1. **数学性质利用**：当 a,b 互质时，通过 |a-b| 的因数寻找跳跃点
2. **边界优先处理**：差为 0 或 1 的情况直接返回结果
3. **因数枚举优化**：仅需枚举到 sqrt(n)，正反因子同时处理
4. **递归分治思想**：将大问题分解为可跳跃的小段处理

---

## 个人心得摘录

> "被卡了 8 发罚时才意识到，当 a,b 已经是除以 gcd 后的值时，必须重新计算差值。这个边界条件像隐藏的地雷，测试用例设计需要更全面的覆盖。" —— lzqy_

> "优化后的代码反而比暴力模拟更考验数学直觉，在因数枚举时漏考虑对称因子（i 和 n/i）导致 WA 了三次，血的教训！" —— Xy_top

---
处理用时：66.58秒
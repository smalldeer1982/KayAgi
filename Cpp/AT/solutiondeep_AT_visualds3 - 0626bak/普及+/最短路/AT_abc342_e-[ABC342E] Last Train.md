# 题目信息

# [ABC342E] Last Train

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc342/tasks/abc342_e

AtCoder 国には駅 $ 1, $ 駅 $ 2,\ldots, $ 駅 $ N $ の $ N $ 個の駅があります。

AtCoder 国に存在する電車の情報が $ M $ 個与えられます。 $ i $ 番目 $ (1\leq\ i\leq\ M) $ の情報は正整数の $ 6 $ つ組 $ (l\ _\ i,d\ _\ i,k\ _\ i,c\ _\ i,A\ _\ i,B\ _\ i) $ で表され、次のような情報に対応しています。

- $ t=l\ _\ i,l\ _\ i+d\ _\ i,l\ _\ i+2d\ _\ i,\ldots,l\ _\ i+(k\ _\ i-1)d\ _\ i $ それぞれについて、次のような電車が存在する。
  - 時刻 $ t $ に 駅 $ A\ _\ i $ を出発し、時刻 $ t+c\ _\ i $ に駅 $ B\ _\ i $ に到着する。

これらの情報にあてはまらない電車は存在せず、電車以外の方法である駅から異なる駅へ移動することはできません。  
また、乗り換えにかかる時間は無視できるとします。

駅 $ S $ から駅 $ N $ に到着できる最終時刻を $ f(S) $ とします。  
より厳密には、整数の $ 4 $ つ組の列 $ \big((t\ _\ i,c\ _\ i,A\ _\ i,B\ _\ i)\big)\ _\ {i=1,2,\ldots,k} $ であって、次のすべての条件を満たすものが存在するような $ t $ の最大値を $ f(S) $ とします。

- $ t\leq\ t\ _\ 1 $
- $ A\ _\ 1=S,B\ _\ k=N $
- すべての $ 1\leq\ i\lt\ k $ について、$ B\ _\ i=A\ _\ {i+1} $
- すべての $ 1\leq\ i\leq\ k $ について、時刻 $ t\ _\ i $ に駅 $ A\ _\ i $ を出発して時刻 $ t\ _\ i+c\ _\ i $ に駅 $ B\ _\ i $ に到着する電車が存在する。
- すべての $ 1\leq\ i\lt\ k $ について、$ t\ _\ i+c\ _\ i\leq\ t\ _\ {i+1} $

ただし、そのような $ t $ が存在しないとき $ f(S)=-\infty $ とします。

$ f(1),f(2),\ldots,f(N-1) $ を求めてください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ M\leq2\times10\ ^\ 5 $
- $ 1\leq\ l\ _\ i,d\ _\ i,k\ _\ i,c\ _\ i\leq10\ ^\ 9\ (1\leq\ i\leq\ M) $
- $ 1\leq\ A\ _\ i,B\ _\ i\leq\ N\ (1\leq\ i\leq\ M) $
- $ A\ _\ i\neq\ B\ _\ i\ (1\leq\ i\leq\ M) $
- 入力はすべて整数

### Sample Explanation 1

AtCoder 国に走っている電車は以下の図のようになります（発着時間の情報は図には含まれていません）。 !\[\](https://img.atcoder.jp/abc342/c3007f6fd6e6bffff5483312395e51f6.png) 駅 $ 2 $ から駅 $ 6 $ に到着できる最終時刻について考えます。 次の図のように、駅 $ 2 $ を時刻 $ 56 $ に出発して駅 $ 2\rightarrow $ 駅 $ 3\rightarrow $ 駅 $ 4\rightarrow $ 駅 $ 6 $ のように移動することで駅 $ 6 $ に到着することができます。 !\[\](https://img.atcoder.jp/abc342/bf9e3c0a042ef63f63e45fd5b94a23af.png) 駅 $ 2 $ を時刻 $ 56 $ より遅く出発して駅 $ 6 $ に到着することはできないため、$ f(2)=56 $ です。

### Sample Explanation 2

駅 $ 1 $ を時刻 $ 10\ ^\ {18} $ に出発して駅 $ 5 $ に時刻 $ 10\ ^\ {18}+10\ ^\ 9 $ に到着するような電車が存在します。それ以降に駅 $ 1 $ を出発する電車はないため、$ f(1)=10\ ^\ {18} $ です。 このように、答えが $ 32\operatorname{bit} $ 整数におさまらない場合もあります。 また、時刻 $ 14 $ に駅 $ 2 $ を出発して時刻 $ 20 $ に駅 $ 3 $ に到着するような電車は $ 2 $ 番目の情報と $ 3 $ 番目の情報の両方で存在が保証されています。 このように、複数の情報に重複している電車もあります。

## 样例 #1

### 输入

```
6 7
10 5 10 3 1 3
13 5 10 2 3 4
15 5 10 7 4 6
3 10 2 4 2 5
7 10 2 3 5 6
5 3 18 2 2 3
6 3 20 4 2 1```

### 输出

```
55
56
58
60
17```

## 样例 #2

### 输入

```
5 5
1000000000 1000000000 1000000000 1000000000 1 5
5 9 2 6 2 3
10 4 1 6 2 3
1 1 1 1 3 5
3 1 4 1 5 1```

### 输出

```
1000000000000000000
Unreachable
1
Unreachable```

## 样例 #3

### 输入

```
16 20
4018 9698 2850 3026 8 11
2310 7571 7732 1862 13 14
2440 2121 20 1849 11 16
2560 5115 190 3655 5 16
1936 6664 39 8822 4 16
7597 8325 20 7576 12 5
5396 1088 540 7765 15 1
3226 88 6988 2504 13 5
1838 7490 63 4098 8 3
1456 5042 4 2815 14 7
3762 6803 5054 6994 10 9
9526 6001 61 8025 7 8
5176 6747 107 3403 1 5
2014 5533 2031 8127 8 11
8102 5878 58 9548 9 10
3788 174 3088 5950 3 13
7778 5389 100 9003 10 15
556 9425 9458 109 3 11
5725 7937 10 3282 2 9
6951 7211 8590 1994 15 12```

### 输出

```
720358
77158
540926
255168
969295
Unreachable
369586
466218
343148
541289
42739
165772
618082
16582
591828```

# AI分析结果



**唯一算法分类**  
图论（Dijkstra 算法 + 反向建图）

---

### **综合分析与结论**

#### **核心思路**
1. **反向建图**：将终点 N 作为起点，反向遍历所有可达路径。
2. **最长路径优化**：使用优先队列（大根堆）维护每个节点的最晚出发时间，每次取最大值进行松弛操作。
3. **时间窗口计算**：对于每条边，计算满足时间约束的最晚班次，公式为 `min((当前时间 - 车程时间 - 首班时间) // 间隔, 班次上限 - 1) * 间隔 + 首班时间`。
4. **边界处理**：首班车时间超过当前时间时跳过；班次索引不能超过 `k-1`。

#### **可视化设计思路**
1. **动画流程**：
   - 初始时，终点 N 显示为绿色，其他节点为红色。
   - 每次从队列取出节点时高亮为黄色，检查其邻边。
   - 更新邻节点时，对应边和节点闪烁蓝色，更新后节点变绿。
2. **像素风格实现**：
   - 使用 Canvas 绘制网格，节点为 16x16 像素方块。
   - 边以像素线条连接，标注班次参数（l, d, k, c）。
   - 时间数值以 8-bit 字体动态显示在节点下方。
3. **音效与交互**：
   - **更新成功音效**：8-bit "哔" 声（Web Audio 合成方波）。
   - **无解提示**：低音 "嘟" 声。
   - 支持暂停/步进，速度滑块调节动画帧率。

---

### **题解清单 (≥4星)**  
1. **Genius_Star（4.5★）**  
   - **亮点**：反向建图逻辑清晰，优先队列正确使用大根堆，代码可读性强。
   - **核心代码**：
     ```cpp
     ll w = min(((dis[u] - t.c - t.l) / t.d) * t.d + t.l, t.l + (t.k-1)*t.d);
     if (dis[v] < w) dis[v] = w;
     ```
2. **Otue（4★）**  
   - **亮点**：时间计算简洁，直接通过 `min` 处理班次上限。
   - **核心代码**：
     ```cpp
     ll D = l + min((dist[u] - l - c) / d, k - 1) * d;
     if (dist[v] < D) dist[v] = D;
     ```
3. **lml0928（4★）**  
   - **亮点**：代码结构模块化，注释明确，适合教学。
   - **心得**："赛内代码因取整方向错误丢分，强调边界检查的重要性"。

---

### **最优思路与实现**

#### **代码片段（反向建图 + Dijkstra）**
```cpp
priority_queue<pair<ll, ll>> Q; // {最晚时间, 节点}
Q.push({INF, n});
dis[n] = INF;

while (!Q.empty()) {
    ll u = Q.top().second, t = Q.top().first;
    Q.pop();
    if (vis[u]) continue;
    vis[u] = true;
    
    for (auto &e : G[u]) { // 遍历反图中的邻接边
        if (t - e.c < e.l) continue; // 无法赶上首班车
        ll cnt = min((t - e.c - e.l) / e.d, e.k - 1);
        ll new_t = e.l + cnt * e.d;
        if (dis[e.v] < new_t) {
            dis[e.v] = new_t;
            Q.push({new_t, e.v});
        }
    }
}
```

#### **关键技巧**
- **数学压缩**：通过 `(t - c - l) / d` 快速定位最大可行班次，避免逐班计算。
- **反向时间流**：将终点作为起点，将“最晚出发”转化为“最长路径”问题。

---

### **同类题目推荐**
1. **P1144 最短路计数**（反向 BFS 统计路径数）
2. **P1462 通往奥格瑞玛的道路**（条件约束下的最短路径）
3. **ABC277E Crystal Switches**（分层图 + 时间窗口）

---

### **可视化与复古像素动画**
```javascript
// Canvas 初始化与像素绘制
const ctx = canvas.getContext('2d');
const NODE_SIZE = 16, EDGE_COLOR = '#8B8B83';

function drawNode(x, y, color, time) {
    ctx.fillStyle = color; // 绿:已处理, 黄:当前, 红:未处理
    ctx.fillRect(x, y, NODE_SIZE, NODE_SIZE);
    ctx.fillStyle = '#FFF';
    ctx.font = '8px Pixel';
    ctx.fillText(time, x - 10, y + 20);
}

// 音效触发
function playBeep(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}

// 自动演示逻辑
let autoPlay = setInterval(() => {
    if (!pq.empty()) processNextNode();
    else clearInterval(autoPlay);
}, 500);
```

---

### **总结**
本题通过反向 Dijkstra 将复杂的时间约束转化为最长路径问题，结合数学优化避免暴力计算。可视化设计通过像素动画和音效增强理解，适合动态演示算法核心流程。同类题目可通过类似的时间窗口和反向图技巧解决。

---
处理用时：82.60秒
# 题目信息

# [ABC375F] Road Blocked

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc375/tasks/abc375_f

AtCoder国には $ 1 $ から $ N $ の番号がついた $ N $ 個の都市と、$ 1 $ から $ M $ の番号がついた $ M $ 本の道路があります。  
 道路 $ i $ は都市 $ A_i $ と都市 $ B_i $ を双方向に結び長さは $ C_i $ です。

$ Q $ 個のクエリが与えられるので順に処理してください。クエリは以下の $ 2 $ 種類のどちらかです。

- `1 i`：道路 $ i $ が通行止めとなる。
- `2 x y`：通行止めでない道路のみを通るときの都市 $ x $ から都市 $ y $ への最短距離を出力する。都市 $ x $ から都市 $ y $ に到達できないときは代わりに `-1` を出力する。
 
なお、$ 1 $ 種類目のクエリはテストケースごとに $ 300 $ 回以下であることが保証されます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 300 $
- $ 0\ \leq\ M\ \leq\ \frac{N(N-1)}{2} $
- $ 1\leq\ A_i\ <\ B_i\ \leq\ N $
- $ (A_i,B_i) $ は相異なる
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- $ 1\ \leq\ Q\ \leq\ 2\times\ 10^5 $
- $ 1 $ 種類目のクエリにおいて、$ 1\leq\ i\ \leq\ M $
- $ 1 $ 種類目のクエリにおいて与えられる道路は、その時点で通行止めでない
- $ 1 $ 種類目のクエリは $ 300 $ 回以下である
- $ 2 $ 種類目のクエリにおいて、$ 1\leq\ x\ <\ y\ \leq\ N $
- 入力は全て整数である
 
### Sample Explanation 1

\- $ 1 $ 番目のクエリでは、都市 $ 1 $ から都市 $ 3 $ への最短距離である $ 10 $ を出力します。 - $ 2 $ 番目のクエリにより、道路 $ 2 $ が通行止めとなりました。 - $ 3 $ 番目のクエリでは、都市 $ 1 $ から都市 $ 3 $ への最短距離である $ 11 $ を出力します。 - $ 4 $ 番目のクエリにより、道路 $ 1 $ が通行止めとなりました。 - $ 5 $ 番目のクエリでは、都市 $ 1 $ から都市 $ 3 $ には到達できないので、`-1` を出力します。

## 样例 #1

### 输入

```
3 3 5

1 2 5

1 3 10

2 3 6

2 1 3

1 2

2 1 3

1 1

2 1 3```

### 输出

```
10

11

-1```

## 样例 #2

### 输入

```
4 6 6

2 3 1

2 4 1

3 4 1

1 2 1

1 3 1

1 4 1

1 4

1 5

1 6

2 1 2

2 1 3

2 1 4```

### 输出

```
-1

-1

-1```

# AI分析结果



## 算法分类
动态全源最短路（Floyd算法 + 离线逆序处理）

---

## 综合分析与结论

### 核心思路与难点
**核心思路**：将删边操作离线逆序处理为加边操作，利用Floyd算法动态维护全源最短路。每次加边时，枚举所有点对，检查是否可以通过新边缩短距离。

**解决难点**：
1. **动态删边的低效性**：删边直接维护最短路困难，逆序处理将问题转化为更易处理的加边操作。
2. **全源维护的复杂度**：通过Floyd的松弛特性，每次加边仅需检查新边是否能为其他点对提供更优路径，而非重新计算全图。

**算法流程**：
1. 预处理初始图（排除被删除的边），用Floyd计算初始全源最短路。
2. 逆序处理操作：
   - 查询操作直接记录当前最短路。
   - 加边操作时，枚举所有点对，更新可能经过新边的路径：`dis[i][j] = min(dis[i][j], dis[i][u]+w+dis[v][j], dis[i][v]+w+dis[u][j])`

---

## 题解评分（≥4星）

1. **cjh20090318（5星）**
   - **亮点**：代码简洁，Floyd逻辑清晰，逆序处理与动态更新实现高效。
   - **核心代码**：
     ```cpp
     for(int u=1;u<=n;u++)for(int v=1;v<=n;v++) 
         d[u][v] = min({d[u][v], d[u][e[i].u]+e[i].w+d[e[i].v][v], d[u][e[i].v]+e[i].w+d[e[i].u][v]});
     ```

2. **Binah_cyc（4星）**
   - **亮点**：注释详细，变量命名规范，适合初学者理解。
   - **心得摘录**：强调“时光倒流”是经典技巧，对Floyd的更新步骤进行分情况讨论。

3. **卡卡卡卡卡卡（4星）**
   - **亮点**：代码极简，突出核心逻辑，适合竞赛快速编码。
   - **关键实现**：直接在Floyd矩阵中更新，省略复杂数据结构。

---

## 最优思路与技巧提炼

### 关键技巧
1. **离线逆序处理**：将动态删边转化为静态加边，避免实时维护困难。
2. **Floyd动态松弛**：加边时仅枚举点对，通过新边的两端点进行松弛，时间复杂度保持为`O(n²)`。
3. **矩阵复用**：始终维护全源最短路矩阵，查询操作复杂度降至`O(1)`。

### 同类型题
- **洛谷P1119 灾后重建**：动态加边查询最短路，Floyd按时间顺序松弛。
- **Codeforces 1473E. Minimum Path**：带权图动态修改边权的最短路问题。
- **HDU 3631 Shortest Path**：允许临时标记点，动态更新最短路。

---

## 可视化设计

### 动画方案
1. **网格表示**：以`N×N`像素网格表示全源最短路矩阵，每个格子显示`dis[i][j]`的值。
2. **加边高亮**：新边`(u, v)`加入时，用闪烁效果标记`u`和`v`节点。
3. **路径更新**：当点对`(i, j)`因新边被更新时，用流动线条显示路径`i→u→v→j`或`i→v→u→j`。
4. **音效提示**：成功更新路径时播放“滴”声，无更新时播放低音提示。

### 复古游戏化设计
- **8位像素风格**：节点用16×16像素方块表示，边用不同颜色线条绘制。
- **自动演示模式**：按逆序操作自动播放加边与查询过程，右侧面板显示当前操作类型。
- **积分系统**：每次成功优化路径获得10分，连续优化触发连击倍率。

---

## 核心代码实现（cjh20090318版）

```cpp
// 初始化Floyd矩阵
memset(d, 0x3f, sizeof d);
for(int i=1; i<=n; i++) d[i][i] = 0;
for(int i=1; i<=m; i++) if(!ct[i])
    add(e[i].u, e[i].v, e[i].w), add(e[i].v, e[i].u, e[i].w);

// Floyd预处理
for(int k=1; k<=n; k++)
for(int i=1; i<=n; i++)
for(int j=1; j<=n; j++)
    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

// 逆序处理加边操作
for(int _=q; _>0; --_) {
    if(Q[_].op == 1) {
        int i = Q[_].x;
        // 更新直接连接
        add(e[i].u, e[i].v, e[i].w), add(e[i].v, e[i].u, e[i].w);
        // 松弛所有点对
        for(int u=1; u<=n; u++)
        for(int v=1; v<=n; v++)
            d[u][v] = min({d[u][v], d[u][e[i].u]+e[i].w+d[e[i].v][v], 
                          d[u][e[i].v]+e[i].w+d[e[i].u][v]});
    }
}
```

---

## 推荐题目
1. **洛谷P1119**：灾后重建，动态加边最短路模板题。
2. **洛谷P4568**：飞行路线，分层图最短路思想。
3. **Codeforces 295B**：Greg and Graph，逆序加点的Floyd应用。

---
处理用时：94.80秒
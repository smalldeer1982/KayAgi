# 题目信息

# [ABC313D] Odd or Even

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc313/tasks/abc313_d

この問題は **インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

整数 $ N $ および $ N $ 未満の **奇数** $ K $ が与えられます。  
ジャッジシステムは、$ 0 $ および $ 1 $ からなる長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ を隠し持っています。

あなたは数列 $ A $ の要素の値を直接知ることはできません。  
その代わりに、ジャッジシステムに対して以下の質問を $ N $ 回まで行うことができます。

- $ 1 $ 以上 $ N $ 以下の相異なる整数 $ x_1,\ x_2,\ \dots,\ x_K $ を選ぶ。そして、$ A_{x_1}\ +\ A_{x_2}\ +\ \dots\ +\ A_{x_K} $ の偶奇を聞く。

$ N $ 回以下の質問で $ (A_1,\ A_2,\ \dots,\ A_N) $ を全て特定して、答えを出力してください。  
ただし、**ジャッジは適応的です**。言い換えると、ジャッジシステムは今までの質問の回答に矛盾しない範囲で$ A $ の内容を自由に変更することができます。  
そのため、出力が次の条件を満たす場合にあなたの作成したプログラムは正解とみなされます。それ以外の場合は不正解とみなされます。

- ここまでの質問の回答と矛盾しないような数列が一意に定まっており、かつそれがプログラムが出力した数列と一致している。

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です。

最初に、$ N $ および $ K $ を標準入力から受け取ってください。

> $ N $ $ K $

次に、$ (A_1,\ A_2,\ \dots,\ A_N) $ を全て特定できるまで質問を繰り返してください。  
質問は、以下の形式で標準出力に出力してください。ここで $ x_1,\ x_2,\ \dots,\ x_K $ は $ 1 $ 以上 $ N $ 以下の相異なる $ K $ 個の整数です。

> $ ? $ $ x_1 $ $ x_2 $ $ \dots $ $ x_K $

これに対する応答は、次の形式で標準入力から与えられます。

> $ T $

ここで、$ T $ は質問に対する答えで、

- $ T $ が `0` である場合は $ A_{x_1}\ +\ A_{x_2}\ +\ \dots\ +\ A_{x_K} $ は偶数であることを、
- $ T $ が `1` である場合は $ A_{x_1}\ +\ A_{x_2}\ +\ \dots\ +\ A_{x_K} $ は奇数であることを意味します。

ただし、$ x_1,\ x_2,\ \dots,\ x_K $ が制約を満たしていないか、質問の回数が $ N $ 回を超えた場合は $ T $ は `-1` となります。

ジャッジが `-1` を返した場合、プログラムはすでに不正解とみなされています。この場合、ただちにプログラムを終了してください。

$ A $ の要素を全て特定できたら、特定した $ A $ の要素を以下の形式で出力してください。その後、ただちにプログラムを終了してください。

> $ ! $ $ A_1 $ $ A_2 $ $ \dots $ $ A_N $

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \lt\ N\ \leq\ 1000 $
- $ K $ は奇数
- $ A_i $ は $ 0 $ または $ 1 $

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。そうしなかった場合、ジャッジ結果が TLE となる可能性があります。**
- **対話の途中で誤った出力形式による出力を行った、あるいはプログラムが途中で終了した場合のジャッジ結果は不定です。**
- 解答を出力したらただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- ジャッジは適応的です。言い換えると、ジャッジシステムは今までの質問の回答に矛盾しない範囲で $ A $ の内容を変更することができます。

### 入出力例

以下の入出力例は $ N=5,\ K=3 $ の場合の入出力例です。**この入出力例の通りに出力するとジャッジ結果は WA になることに注意してください。**  
入出力例では、プログラムが出力した $ A\ =\ (1,\ 0,\ 1,\ 1,\ 0) $ はここまでの質問の回答に矛盾しない数列ですが、例えば $ (0,\ 0,\ 1,\ 0,\ 0) $ もここまでの質問の回答に矛盾しない数列であるため、数列 $ A $ は一意に定まっていません。そのため、このプログラムは不正解とみなされます。

  入力 出力 説明    `5 3`  まず整数 $ N $ および $ K $ が与えられます。   `? 2 4 1 `  $ (x_1,\ x_2,\ x_3)\ =\ (2,\ 4,\ 1) $ として質問を行います。  `0`  質問の答えは $ 0 $ なので、ジャッジはその値を返します。   `? 5 3 2` $ (x_1,\ x_2,\ x_3)\ =\ (5,\ 3,\ 2) $ として質問を行います。   `1`  質問の答えは $ 1 $ なので、ジャッジはその値を返します。   `! 1 0 1 1 0` $ A $ の答えとして $ (1,\ 0,\ 1,\ 1,\ 0) $ を出力します。$ A $ を一意に特定できていないのでジャッジ結果は WA になります。

# AI分析结果



## 算法分类
数学/位运算

---

## 题解思路与解决难点

### 核心思路
所有题解均采用 **「前 K+1 元素特殊处理 + 剩余元素递推」** 的策略：
1. **前 K+1 元素推导**  
   - 构造 K+1 次询问，每次询问排除第 i 个元素（1≤i≤K+1）  
   - 利用奇数次异或的抵消性质，通过 K+1 次询问结果的异或总和确定整体奇偶性  
   - 通过差分法逐个推导每个元素的值（关键公式：a[i] = total_xor ^ s[i]）

2. **剩余元素递推**  
   - 对每个剩余元素 x（K+2 ≤ x ≤ N），选取前 K-1 个已知元素与 x 组成询问  
   - 利用已知元素的异或和与询问结果直接推导 x 的值

### 关键难点与突破
1. **自适应评测的应对**  
   - 必须确保所有推导步骤的确定性，避免存在多解的可能性  
   - 通过构造 K+1 次互斥询问（每个元素恰好被排除一次）消除不确定性

2. **奇数次异或的抵消特性**  
   - 每个元素在 K+1 次询问中被排除一次，参与 K 次  
   - 因 K 为奇数，总异或和等价于全体元素的异或和

---

## 题解评分（≥4星）

### [Fire_flame] ⭐⭐⭐⭐
- **亮点**：清晰展示前 K+1 元素的异或推导过程，代码注释详细  
- **改进点**：变量命名可优化（如用 total_xor 替代 op）

### [官方题解] ⭐⭐⭐⭐⭐
- **亮点**：代码最简洁，使用 lambda 表达式优化输出逻辑  
- **核心代码**：
  ```cpp
  vector<int> v;
  for(int j = 0; j < K + 1; j++)
    if(i != j) v.push_back(j);
  ans[i] = send(v) ^ r; // 通过异或总和修正结果
  ```

### [hcywoi] ⭐⭐⭐⭐
- **亮点**：数学推导最严谨，给出关键公式的详细证明  
- **核心公式**：
  ```math
  a_i = (\sum_{i=1}^{K+1} s_i) \bmod 2 \oplus s_i
  ```

---

## 最优思路提炼

### 关键技巧
1. **互斥询问构造法**  
   ```python
   # 前 K+1 次询问构造示例（N=5, K=3）
   Q1: 2 3 4 → 排除1
   Q2: 1 3 4 → 排除2
   Q3: 1 2 4 → 排除3
   Q4: 1 2 3 → 排除4
   Q5: 2 3 4 → 无关（实际代码需调整）
   ```

2. **差分推导公式**  
   设总异或和为 total_xor，则：
   ```math
   a_i = \text{total\_xor} \oplus s_i
   ```

### 实践应用
- **代码模板**：  
  ```cpp
  // 前 K+1 元素处理
  int total_xor = 0;
  for(int i=1; i<=K+1; i++) 
      total_xor ^= s[i];
  for(int i=1; i<=K+1; i++)
      a[i] = total_xor ^ s[i];
  ```

---

## 相似题目推荐
1. [CF1797C - Li Hua and Chess](https://codeforces.com/problemset/problem/1797/C)  
   **相似点**：交互题，需构造特定询问缩小解空间

2. [P1852 跳棋](https://www.luogu.com.cn/problem/P1852)  
   **相似点**：利用位运算特性推导隐藏状态

3. [AT_arc113_d](https://atcoder.jp/contests/arc113/tasks/arc113_d)  
   **相似点**：基于奇偶性的数学构造型问题

---

## 可视化设计

### 动画方案
1. **网格动态绘制**  
   - **数据结构**：N×2 网格，左侧显示当前推导元素，右侧显示异或过程  
   - **颜色标记**：  
     - 红色：当前正在处理的元素  
     - 绿色：已确定的元素  
     - 黄色：参与当前异或计算的元素

2. **关键步骤演示**  
   ```python
   # 示例步骤（K=3, N=5）
   1. 绘制初始空网格 [⚪⚪⚪⚪⚪]
   2. 处理前4个元素：
      - Q1: [⚫🟡🟡🟡⚪] → 显示异或结果为0
      - Q2: [🟡⚫🟡🟡⚪] → 异或结果1
      ...
   3. 推导出前4元素值 [1,0,1,1]
   4. 处理第5个元素：
      - Q5: [🟢🟢⚫⚪🟡] → 结果0 → 推导为0
   ```

### 复古游戏化设计
- **8位像素风格**：  
  - 使用 16 色调色板（NES 风格）  
  - 元素状态用不同色块表示（绿=确定，红=处理中，黄=参与计算）

- **音效设计**：  
  - 正确推导：8-bit 上升音阶（C-E-G）  
  - 错误/冲突：短促低音（C2）

---

## 核心代码示例（官方题解简化版）
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, K;
    cin >> N >> K;
    vector<int> ans(N);
    
    // 处理前 K+1 个元素
    int total_xor = 0;
    for (int i = 0; i <= K; i++) {
        cout << "? ";
        for (int j = 0; j <= K; j++) 
            if (j != i) cout << j+1 << " ";
        cout << endl;
        int res;
        cin >> res;
        ans[i] = res;
        total_xor ^= res;
    }
    for (int i = 0; i <= K; i++) 
        ans[i] ^= total_xor;

    // 处理剩余元素
    int known_sum = 0;
    for (int i = 0; i < K-1; i++) 
        known_sum ^= ans[i];
    for (int i = K+1; i < N; i++) {
        cout << "? ";
        for (int j = 0; j < K-1; j++) 
            cout << j+1 << " ";
        cout << i+1 << endl;
        int res;
        cin >> res;
        ans[i] = known_sum ^ res;
    }

    cout << "! ";
    for (int x : ans) cout << x << " ";
    cout << endl;
}
```

---
处理用时：104.14秒
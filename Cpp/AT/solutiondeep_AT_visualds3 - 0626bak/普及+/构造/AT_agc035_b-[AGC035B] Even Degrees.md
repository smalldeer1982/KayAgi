# 题目信息

# [AGC035B] Even Degrees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_b

$ N $ 頂点 $ M $ 辺の単純連結無向グラフが与えられます。頂点には $ 1 $ から $ N $ までの番号がついており、$ i $ 本目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。 高橋君は、与えられたグラフのすべての辺にどちらかの向きをつけて有向グラフを作ります。 どの頂点から出る辺の本数も偶数になるような有向グラフを作ることが可能かどうか判定し、可能ならそのような例をひとつ構成してください。

## 说明/提示

### ノート

無向グラフが単純であるとは、自己ループと多重辺を含まないことを指します。

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N\ (1\leq\ i\leq\ M) $
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

このように向き付けることで、頂点 $ 1,3 $ からは $ 2 $ 本、頂点 $ 2,4 $ からは $ 0 $ 本の辺が出るようになります。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 1```

### 输出

```
1 2

1 4

3 2

3 4```

## 样例 #2

### 输入

```
5 5

1 2

2 3

3 4

2 5

4 5```

### 输出

```
-1```

# AI分析结果



## 算法分类
图论-生成树构造

---

## 综合分析与结论

### 核心思路
1. **奇数边数无解**：总边数必须为偶数，否则无法满足每个顶点出度为偶数。
2. **生成树构造**：通过DFS或BFS构建生成树，非树边定向不影响最终结果。
3. **后序调整树边**：自底向上调整树边方向，确保每个子树顶点出度满足条件，最终根节点自动满足。

### 解决难点
- **生成树选择**：需正确处理树边与非树边，保证调整只影响树边方向。
- **度数传递**：通过后序遍历将子节点的度数奇偶性传递给父节点，动态调整父边方向。

### 可视化设计
- **树形结构展示**：以生成树为中心，用不同颜色标记树边与非树边。
- **动态调整演示**：高亮当前处理的子树节点，实时显示度数变化。
- **步进控制**：可单步执行DFS过程，观察每个节点如何调整父边方向。

---

## 题解清单（≥4星）

1. **ForgotMe（★★★★☆）**  
   - 关键亮点：简洁的生成树DFS调整，非树边直接处理，代码易读。
2. **Azazеl（★★★★☆）**  
   - 关键亮点：树上差分优化路径调整，LCA处理高效。

---

## 核心代码实现

### 关键逻辑片段（ForgotMe题解）
```cpp
void solve(int u) {
    for (int v : g[u]) {
        solve(v);
        if (du[v] % 2) {
            printf("%d %d\n", v, u);  // 子到父
        } else {
            printf("%d %d\n", u, v);  // 父到子，父度数+1
            du[u]++;
        }
    }
}
```

### 完整代码
```cpp
#include <cstdio>
#include <vector>
using namespace std;
struct Edge { int to, id; };
vector<Edge> G[100005];
vector<int> g[100005];
int n, m, du[100005], f[100005];
bool used[100005];

void dfs(int u) {
    for (Edge e : G[u]) {
        int v = e.to;
        if (v == f[u]) continue;
        if (!f[v]) {
            f[v] = u;
            used[e.id] = true;
            g[u].push_back(v);
            dfs(v);
        }
    }
}

void solve(int u) {
    for (int v : g[u]) {
        solve(v);
        if (du[v] % 2) {
            printf("%d %d\n", v, u);
        } else {
            printf("%d %d\n", u, v);
            du[u]++;
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    if (m % 2) { puts("-1"); return 0; }
    for (int i = 1, u, v; i <= m; i++) {
        scanf("%d%d", &u, &v);
        G[u].push_back({v, i});
        G[v].push_back({u, i});
    }
    f[1] = -1; dfs(1);
    for (int i = 1; i <= m; i++) {
        if (!used[i]) {
            printf("%d %d\n", G[u][i-1].to, G[v][i-1].to);
            du[G[u][i-1].to]++;
        }
    }
    solve(1);
    return 0;
}
```

---

## 同类型题推荐
1. **CF1153E** - 奇偶性构造与路径处理  
2. **洛谷P3512** - 生成树与度数调整  
3. **AT4144** - 图的定向与连通性  

---

## 可视化与游戏化设计
- **像素风格树形图**：用8位色块表示顶点，树边为绿色，非树边为灰色。
- **音效触发**：调整边方向时播放“滴”声，完成构造后播放胜利音效。
- **自动演示模式**：按DFS顺序自动处理节点，可暂停观察当前状态。

---

**总结**：通过生成树后序调整是解决此类度数奇偶问题的通用方法，结合动态规划思想逐步修正局部状态，最终全局满足条件。

---
处理用时：106.41秒
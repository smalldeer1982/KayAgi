# 题目信息

# [ARC161C] Dyed by Majority (Odd Tree)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc161/tasks/arc161_c

$ N $ 頂点の木が与えられます． 頂点には $ 1 $ から $ N $ までの番号が付いており，$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます． また，すべての頂点について，**接続する辺の本数は奇数**です．

与えられた木の各頂点を黒 ( `B` ) か白 ( `W` ) のいずれかの色で塗ります． このとき，「各頂点の色（ `B` または `W` ）を頂点の番号順に並べて得られる文字列」を**色の列**と呼びます．

色の列 $ S $ が与えられます． すべての頂点に色が塗られた状態で以下の操作を $ 1 $ 回行った結果，色の列が $ S $ となることがあり得るかどうかを判定し，あり得るなら操作を行う前の色の列として適切なものを $ 1 $ つ求めてください．

**操作:** 各頂点 $ k\ =\ 1,\ 2,\ \dots,\ N $ に対して，辺で結ばれた頂点の色のうち過半数を占めるものを $ C_k $ とする． すべての頂点について同時に，頂点 $ k $ の色を $ C_k $ に塗り替える．

$ T $ 個のテストケースが与えられるので，それぞれについて答えてください．

## 说明/提示

### 制約

- $ T\ \geq\ 1 $
- $ N\ \geq\ 2 $
- $ 1 $ つの入力に含まれるテストケースについて，$ N $ の総和は $ 2\ \times\ 10^5 $ 以下である．
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N\ (1\ \leq\ i\ \leq\ N\ -\ 1) $
- 与えられる辺 $ (A_i,\ B_i)\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ は木をなす．
- 各頂点 $ k\ (1\ \leq\ k\ \leq\ N) $ は $ A_i,\ B_i\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ として**合計奇数回**現れる．
- $ S $ は `B`, `W` からなる長さ $ N $ の文字列である．
 
### Sample Explanation 1

$ 1 $ つ目のテストケースについて，操作を行う前の色の列が `WBBW` であったとします． このとき， - 頂点 $ 1 $ について，辺で結ばれた頂点 $ 2,\ 3,\ 4 $ の色はそれぞれ `B`, `B`, `W` であり，過半数を占めるのは $ C_1\ =\ {} $`B`， - 頂点 $ 2 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_2\ =\ {} $`W`， - 頂点 $ 3 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_3\ =\ {} $`W`， - 頂点 $ 4 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_4\ =\ {} $`W` となります． したがって，操作後の色の列は `BWWW` となり，条件を満たします． 同様に，操作前の色の列が `WBBB`, `WBWB`, `WWBB` であった場合にも，操作後の色の列は `BWWW` となり，これらのうちどれを出力しても正答と見なされます。 $ 2 $ つ目のテストケースについて，入力された木において操作を行った結果，色の列が `BBWW` となることはあり得ません．

## 样例 #1

### 输入

```
2

4

1 2

1 3

1 4

BWWW

4

1 2

1 3

1 4

BBWW```

### 输出

```
WBBW

-1```

# AI分析结果



---

## 算法分类  
**树形结构上的贪心算法**

---

## 题解思路与算法要点  
### 核心思路  
1. **自底向上处理**：从叶子节点（度为1的节点）开始处理，通过DFS向上推导父节点的颜色需求。  
2. **颜色需求传递**：每个节点的颜色由其子节点的颜色分布决定。若子节点中与目标颜色相同的数量不足，则需父节点的颜色作为补充。  
3. **半数颜色处理**：当子节点中与目标颜色相同的数量恰好为半数时，必须要求父节点颜色与目标颜色一致。  

### 解决难点  
- **叶子节点约束**：叶子节点的父节点必须与其目标颜色一致。  
- **需求冲突检测**：若父节点已设定颜色且与当前需求冲突，则无解。  
- **根节点特判**：根节点没有父节点，其颜色需单独处理。  

---

## 题解评分  
### 良心WA题人（⭐⭐⭐⭐⭐）  
- **亮点**：代码简洁，逻辑清晰，利用DFS自底向上统计颜色数量，半数情况处理直观。  
- **关键代码**：通过`cnt == g[u].size()/2`判断需求传递。  

### luohanzhao（⭐⭐⭐⭐）  
- **亮点**：引入`ask`数组记录需求，处理多需求场景更灵活。  
- **缺陷**：变量命名和状态管理稍显复杂。  

### Lucyna_Kushinada（⭐⭐⭐⭐）  
- **亮点**：提出“固定状态”概念，逻辑系统性强。  
- **缺陷**：状态转换需更多注释辅助理解。  

---

## 最优思路提炼  
1. **叶子驱动逻辑**：叶子节点的父节点必须与叶子目标颜色一致，此约束自底向上传递。  
2. **颜色计数与需求**：统计子节点颜色数量，不足时依赖父节点补足，半数时强制父节点颜色。  
3. **冲突检测**：若父节点颜色与需求冲突，立即终止并返回无解。  

---

## 相似题目推荐  
1. **洛谷 P1352**：树形DP，处理父子节点间的约束关系。  
2. **Codeforces 862B**：树的结构分析与颜色分配。  
3. **LeetCode 968**：监控二叉树，贪心策略处理树形约束。  

---

## 代码核心实现  
```cpp
bool dfs(int u, int fa) {
    int cnt = 0;
    for (int v : g[u]) {
        if (v == fa) continue;
        if (!dfs(v, u)) return false;
        if (col[v] == s[u]) cnt++;
    }
    if (cnt < g[u].size() / 2) return false;
    if (cnt == g[u].size() / 2) {
        if (fa && col[fa] && col[fa] != s[u]) return false;
        col[fa] = s[u]; // 传递需求到父节点
    }
    return true;
}
```

---

## 可视化设计  
### 动画演示方案  
1. **像素风格渲染**：  
   - 节点以8位像素方块表示，初始灰色，确定颜色后变为B（蓝）/W（白）。  
   - 当前处理节点高亮为黄色，子节点边框闪烁提示颜色统计。  

2. **关键操作动画**：  
   - **颜色统计**：子节点颜色逐个亮起，计数器动态更新。  
   - **需求传递**：半数时父节点方块出现箭头指向当前节点，并填充目标颜色。  

3. **音效交互**：  
   - 成功分配颜色时播放清脆“叮”声，冲突时播放低沉“嗡”声。  

### 交互控制  
- **步进模式**：按空格键单步执行DFS遍历。  
- **自动演示**：AI模拟自底向上处理，速度可调（1x/2x/5x）。  

---

## 个人心得摘录  
> "叶子节点只能影响父节点，这一观察是解题的关键。通过自底向上的处理，逐步将问题转化为更小的子问题。" —— 良心WA题人  

---

通过此分析，可快速掌握树形贪心的核心逻辑，并在类似问题中灵活应用需求传递与冲突检测机制。

---
处理用时：88.43秒
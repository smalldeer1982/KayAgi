# 题目信息

# [ABC255E] Lucky Numbers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_e

長さ $ N-1 $ の整数列 $ S\ =\ (S_1,\ S_2,\ \ldots,\ S_{N-1}) $ および、「ラッキーナンバー」として $ M $ 個の相異なる整数 $ X_1,\ X_2,\ \ldots,\ X_M $ が与えられます。

長さ $ N $ の整数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ であって、次の条件を満たすものを「良い数列」と呼びます。

> すべての $ i\ =\ 1,\ 2,\ \ldots,\ N-1 $ について、$ A_i\ +\ A_{i+1}\ =\ S_i $ が成り立つ。

良い数列 $ A $ を $ 1 $ つ選ぶときの、$ A $ の要素のうちラッキーナンバーであるものの個数（すなわち、$ A_i\ \in\ \lbrace\ X_1,\ X_2,\ \ldots,\ X_M\ \rbrace $ となる $ 1 $ 以上 $ N $ 以下の整数 $ i $ の個数）としてあり得る最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10 $
- $ -10^9\ \leq\ S_i\ \leq\ 10^9 $
- $ -10^9\ \leq\ X_i\ \leq\ 10^9 $
- $ X_1\ \lt\ X_2\ \lt\ \cdots\ \lt\ X_M $
- 入力はすべて整数

### Sample Explanation 1

良い数列 $ A $ として $ A\ =\ (3,\ -1,\ 4,\ -1,\ 5,\ -9,\ 2,\ -6,\ 5) $ を選ぶと、$ A $ の要素のうちラッキーナンバーであるものは $ A_2,\ A_4,\ A_5,\ A_9 $ の $ 4 $ 個となり、これが考えられる中で最大です。

## 样例 #1

### 输入

```
9 2

2 3 3 4 -4 -7 -4 -1

-1 5```

### 输出

```
4```

## 样例 #2

### 输入

```
20 10

-183260318 206417795 409343217 238245886 138964265 -415224774 -499400499 -313180261 283784093 498751662 668946791 965735441 382033304 177367159 31017484 27914238 757966050 878978971 73210901

-470019195 -379631053 -287722161 -231146414 -84796739 328710269 355719851 416979387 431167199 498905398```

### 输出

```
8```

# AI分析结果



## 唯一算法分类
哈希映射

## 综合分析与结论

**核心思路**  
题目要求构造满足相邻元素和为定值的序列，并最大化幸运数的数量。所有题解均利用以下关键性质：确定任一位置的值即可唯一确定整个序列。因此，将问题转化为统计各位置取幸运数时对应的首项值，出现次数最多的首项即为最优解。

**算法流程**  
1. **预处理累积序列**：通过递推式预处理每个位置i对应的系数和常数项，便于快速计算首项。  
   - 例如，HyB的B数组满足 `B[i] = S[i-1] - B[i-1]`，表示前i-1项交替相加减的结果。  
2. **枚举所有位置和幸运数**：对每个位置i和幸运数X_j，计算对应的首项值。  
   - 公式推导：`A1 = (B[i] - X_j) * (-1)^(i+1)`  
3. **哈希统计**：用哈希表统计各首项值的出现次数，最大值即为答案。

**可视化设计**  
- **动画方案**：  
  1. 显示序列A的动态生成过程，高亮当前处理的i和X_j。  
  2. 逐步绘制预处理数组B的递推计算，用不同颜色区分奇偶项符号。  
  3. 当计算首项时，显示公式推导过程，并实时更新哈希表中的计数。  
- **复古风格**：  
  - 使用8位像素字体显示序列和哈希表。  
  - 每次哈希表更新时播放短促音效，最大值更新时播放胜利音效。  
  - Canvas绘制网格，每个格子表示一个位置i，点击可查看对应的首项推导过程。

## 题解清单 (≥4星)

1. **HyB_Capricornus（5星）**  
   - 思路清晰，推导详细，预处理B数组的递推式高效直观。  
   - 代码简洁，利用奇偶性直接处理符号。  
   - 核心代码：`mp[(b[i]-luky[j])*(i%2?-1:1)]++`  

2. **xuan_gong_dong（4星）**  
   - 类似预处理方法，代码简练。  
   - 显式处理奇偶判断，逻辑明确。  
   - 核心代码：`mp[sum + (j%2==0 ? -1 : 1)*x[j]]++`  

3. **__YSC__（4星）**  
   - 公式推导完整，代码结构清晰。  
   - 预处理sum数组，直接计算首项表达式。  
   - 核心代码：`mp[sum[i-1] + (i%2 ? 1 : -1)*x[j]]++`  

## 最优思路与代码实现

**关键思路**  
将每个位置i的幸运数X_j映射到首项A1的值，统计出现次数最多的A1。利用预处理数组快速计算各位置对应的系数，避免重复计算。

**代码片段**  
```cpp
#include <iostream>
#include <map>
#define ll long long
using namespace std;

const int MAXN = 1e5 + 5;
ll s[MAXN], x[15], sum[MAXN];
map<ll, int> mp;

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i < n; ++i) cin >> s[i];
    for (int i = 1; i <= m; ++i) cin >> x[i];
    
    // 预处理累积和，交替符号
    for (int i = 2; i <= n; ++i)
        sum[i] = s[i-1] - sum[i-1];
    
    // 统计所有可能的A1值
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            ll a1 = (sum[i] - x[j]) * (i % 2 ? -1 : 1);
            mp[a1]++;
        }
    
    int ans = 0;
    for (auto &p : mp) ans = max(ans, p.second);
    cout << ans << endl;
    return 0;
}
```

## 相似题目与扩展

1. **P5847 [IOI2005]河流**  
   - 类似递推关系与预处理技巧，通过状态压缩优化计数。  

2. **ABC223D - Restricted Permutation**  
   - 利用哈希表统计约束条件下的可行解频率。  

3. **CF1526C2 - Potions (Hard Version)**  
   - 贪心结合哈希优化，统计满足条件的最优选择。  

**推荐题目**  
- [洛谷 P1214](https://www.luogu.com.cn/problem/P1214) 等差数列  
- [洛谷 P3194](https://www.luogu.com.cn/problem/P3194) 水平可见直线  
- [洛谷 P5022](https://www.luogu.com.cn/problem/P5022) 旅行

---
处理用时：106.61秒
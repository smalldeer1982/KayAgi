# 题目信息

# [ABC323F] Push and Carry

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_f

座標平面上に高橋君と荷物があります。

高橋君は現在 $ (X_A,Y_A) $ におり、荷物は $ (X_B,Y_B) $ にあります。 高橋君は荷物を $ (X_C,Y_C) $ まで運びたいです。

高橋君は $ (x,y) $ にいるとき、$ 1 $ 回の行動で次のいずれかの動きをすることができます。

- $ (x+1,y) $ に移動する。移動前の時点で荷物が $ (x+1,y) $ にあった時、荷物を $ (x+2,y) $ に移動させる。
- $ (x-1,y) $ に移動する。移動前の時点で荷物が $ (x-1,y) $ にあった時、荷物を $ (x-2,y) $ に移動させる。
- $ (x,y+1) $ に移動する。移動前の時点で荷物が $ (x,y+1) $ にあった時、荷物を $ (x,y+2) $ に移動させる。
- $ (x,y-1) $ に移動する。移動前の時点で荷物が $ (x,y-1) $ にあった時、荷物を $ (x,y-2) $ に移動させる。

荷物を $ (X_C,Y_C) $ に移動させるまでに必要な最小の行動回数を求めてください。

## 说明/提示

### 制約

- $ -10^{17}\leq\ X_A,Y_A,X_B,Y_B,X_C,Y_C\leq\ 10^{17} $
- $ (X_A,Y_A)\neq\ (X_B,Y_B) $
- $ (X_B,Y_B)\neq\ (X_C,Y_C) $
- 入力はすべて整数

### Sample Explanation 1

高橋君は次のように行動することで $ 9 $ 回で荷物を $ (0,5) $ に運ぶことができます。 - $ (2,2) $ へ移動する。 - $ (3,2) $ へ移動する。 - $ (3,3) $ へ移動する。荷物は $ (3,4) $ に移動する。 - $ (3,4) $ へ移動する。荷物は $ (3,5) $ に移動する。 - $ (4,4) $ へ移動する。 - $ (4,5) $ へ移動する。 - $ (3,5) $ へ移動する。荷物は $ (2,5) $ に移動する。 - $ (2,5) $ へ移動する。荷物は $ (1,5) $ に移動する。 - $ (1,5) $ へ移動する。荷物は $ (0,5) $ に移動する。 $ 8 $ 回以下で荷物を $ (0,5) $ に運ぶことができないので、$ 9 $ を出力します。

## 样例 #1

### 输入

```
1 2 3 3 0 5```

### 输出

```
9```

## 样例 #2

### 输入

```
0 0 1 0 -1 0```

### 输出

```
6```

## 样例 #3

### 输入

```
-100000000000000000 -100000000000000000 100000000000000000 100000000000000000 -100000000000000000 -100000000000000000```

### 输出

```
800000000000000003```

# AI分析结果



## 算法分类
曼哈顿距离 + 路径阻挡处理

---

## 综合分析与结论
### 核心思路
1. **箱子路径固定**：箱子的曼哈顿距离 `|x_b-x_c| + |y_b-y_c|` 是必加的固定代价。
2. **人绕行路径选择**：人需要走到箱子后方两个候选位置（横向或纵向推箱子的起点），取两种路径的最小值：
   - 横向优先：走到 `(x_b±1, y_b)` 的代价
   - 纵向优先：走到 `(x_b, y_b±1)` 的代价
3. **路径阻挡处理**：若人在走向候选位置时被箱子阻挡，需额外增加 2 步绕行。
4. **转向代价**：若箱子和终点不在同一行/列，需额外加 2 步转向代价。

### 解决难点
- **路径阻挡判断**：当人与候选位置、箱子在同一直线且箱子在中间时（如人在 `(1,0)`，箱子在 `(2,0)`，候选位置在 `(3,0)`），需要绕行。
- **最优方向选择**：通过比较横向/纵向两种推法的总代价，避免复杂的分情况讨论。

### 可视化设计
1. **动画方案**：
   - **像素网格**：用 Canvas 绘制网格坐标系，箱子、人、终点分别用不同颜色方块标记。
   - **高亮路径**：
     - 红色虚线：人的移动路径
     - 绿色实线：箱子被推动的路径
     - 黄色闪烁：路径阻挡时的绕行段
   - **分步演示**：自动播放时，每帧展示一步移动，并标注当前步数。

2. **交互功能**：
   - **方向切换**：按钮切换横向优先/纵向优先的推法演示。
   - **阻挡模拟**：拖动人物初始位置，实时显示是否触发路径阻挡。

3. **复古效果**：
   - **音效**：推箱子时播放 8-bit "推动"音效，绕行时播放 "哔" 提示音。
   - **积分系统**：最优解达成时显示 "PERFECT" 像素字体，非最优解显示步数差。

---

## 题解评分 (≥4星)
1. **robertuu（★★★★☆）**  
   - 亮点：代码简洁，用方向标记 `X/Y=-1/1` 避免冗余分情况，`dist()` 函数精准处理阻挡。
   - 改进点：缺乏对转向代价的显式说明。

2. **jr_inf（★★★★☆）**  
   - 亮点：极简实现，直接计算两种候选位置的最小值，阻挡判断逻辑清晰。
   - 改进点：未处理坐标交换后的路径阻挡。

3. **incra（★★★★☆）**  
   - 亮点：通过坐标交换统一处理横纵方向，`get_dis()` 函数复用率高。
   - 改进点：转向代价计算稍显隐晦。

---

## 最优思路代码实现
### 核心逻辑
```cpp
long long dist(long long xa, long long ya, long long xb, long long yb, long long xc, long long yc) {
    long long res = abs(xa - xb) + abs(ya - yb);
    // 纵向阻挡判断（人与候选位置在同一列，且箱子在中间）
    if (xa == xb && xb == xc && ((ya < yc && yb > yc) || (ya > yc && yb < yc))) res += 2;
    // 横向阻挡判断（人与候选位置在同一行，且箱子在中间）
    if (ya == yb && yb == yc && ((xa < xc && xb > xc) || (xa > xc && xb < xc))) res += 2;
    return res;
}
```

### 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL dist(LL xa, LL ya, LL xb, LL yb, LL xc, LL yc) {
    LL res = abs(xa - xb) + abs(ya - yb);
    if (xa == xb && xb == xc && ((ya < yc && yb > yc) || (ya > yc && yb < yc))) res += 2;
    if (ya == yb && yb == yc && ((xa < xc && xb > xc) || (xa > xc && xb < xc))) res += 2;
    return res;
}

int main() {
    LL xa, ya, xb, yb, xc, yc;
    cin >> xa >> ya >> xb >> yb >> xc >> yc;
    
    int dx = (xc > xb) ? -1 : 1;
    int dy = (yc > yb) ? -1 : 1;
    
    if (xc == xb) {
        LL cost = dist(xa, ya, xb, yb + dy, xb, yb) + abs(yb - yc);
        cout << cost;
    } else if (yc == yb) {
        LL cost = dist(xa, ya, xb + dx, yb, xb, yb) + abs(xb - xc);
        cout << cost;
    } else {
        LL cost1 = dist(xa, ya, xb + dx, yb, xb, yb);
        LL cost2 = dist(xa, ya, xb, yb + dy, xb, yb);
        cout << min(cost1, cost2) + abs(xb - xc) + abs(yb - yc) + 2;
    }
    return 0;
}
```

---

## 同类型题与套路
### 相似题型
1. **推箱子（经典变种）**：如 `Luogu P1141`，需处理路径阻挡和最小步数。
2. **网格绕行问题**：如 `LeetCode 1293. 网格中的最短路径`，需计算带障碍物的最短路径。

### 通用套路
- **曼哈顿距离优先**：适用于无障碍网格中的最短路径估算。
- **方向分离处理**：将横纵移动分离计算，通过交换坐标统一逻辑。
- **阻挡预判**：通过坐标关系判断是否需要绕行。

---

## 推荐题目
1. **Luogu P1141**：二维网格中的推箱子变种，需处理动态阻挡。
2. **LeetCode 1091**：八方向最短路径，练习网格 BFS。
3. **AtCoder ABC151D**：迷宫中的最长最短路径，强化曼哈顿距离应用。

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制关键帧
function drawStep(ctx, step) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制网格
    drawGrid(ctx);
    // 绘制箱子（蓝色方块）
    ctx.fillStyle = "#00f";
    ctx.fillRect(bx * CELL_SIZE, by * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    // 绘制人（红色方块）
    ctx.fillStyle = "#f00";
    ctx.fillRect(ax * CELL_SIZE, ay * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    // 高亮当前移动路径（黄色）
    if (step.blocked) {
        ctx.strokeStyle = "#ff0";
        ctx.setLineDash([5, 3]);
        ctx.strokeRect(ax * CELL_SIZE, ay * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }
    // 播放音效
    if (step.blocked) playSound(blockSound);
    else playSound(moveSound);
}
```

---
处理用时：119.43秒
# 题目信息

# [ABC361F] x = a^b

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_f

$ 1 $ 以上 $ N $ 以下の正整数 $ x $ であって、ある正整数 $ a $ と **$ 2 $ 以上の** 正整数 $ b $ を用いて $ x=a^b $ と表現できるものはいくつありますか？

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 10^{18} $
 
### Sample Explanation 1

問題文中の条件を満たす整数は $ 1,4,8,9,16,25,27,32,36,49,64,81 $ の $ 12 $ 個です。

## 样例 #1

### 输入

```
99```

### 输出

```
12```

## 样例 #2

### 输入

```
1000000000000000000```

### 输出

```
1001003332```

# AI分析结果



---

**算法分类**  
数学+枚举

---

### **综合分析与结论**

**核心思路**  
题目要求统计区间 [1, N] 中能表示为 a^b（b≥2）的数个数。关键点在于高效枚举不同指数情况并去重：  
1. **分治指数范围**：将问题拆分为处理 b=2（平方数）和 b≥3 的情况。  
2. **哈希表去重**：枚举 b≥3 的 a^b，用哈希表记录非平方数的值。  
3. **避免重复统计**：平方数可能在 b≥3 时被生成，需在统计时排除。  

**实现难点**  
- **大数运算防溢出**：使用 `__int128` 或乘法过程中提前判断溢出。  
- **高效判断平方数**：采用 `sqrtl` 函数或二分法提高精度。  
- **时间复杂度优化**：b≥3 时 a 的上限为 1e6，总枚举次数在 O(1e6 * logN)。  

**可视化设计思路**  
- **动态枚举过程**：展示每个 (a, b) 的枚举路径，高亮当前计算的 a^b。  
- **颜色区分状态**：  
  - 绿色：新加入哈希表的非平方数。  
  - 红色：已存在的数或平方数（不加入）。  
- **统计面板**：实时显示已找到的平方数数量、哈希表大小及最终结果。  
- **复古像素风格**：使用 8-bit 网格展示数值分布，音效提示新元素加入或重复。  

---

### **题解评分 (≥4星)**  
1. **DrAlfred（4.5星）**  
   - 思路清晰，分治指数范围明确。  
   - 代码简洁，利用 `unordered_set` 去重，时间复杂度合理。  
   - 亮点：排除平方数的逻辑直接有效。  

2. **qhr2023（4星）**  
   - 代码简短，仅用两层循环实现核心逻辑。  
   - 使用 `map` 标记，直观处理重复。  
   - 优化点：未处理大数溢出，但在实际数据中表现良好。  

3. **Starrykiller（4星）**  
   - 结合容斥原理和莫比乌斯函数，数学严谨。  
   - 实现复杂但优化程度高，适合极大 N。  
   - 缺点：代码可读性较低，调试难度大。  

---

### **最优思路提炼**  
1. **分治指数法**：将 b=2 和 b≥3 分开处理，前者直接计算平方数，后者暴力枚举。  
2. **哈希去重**：用 `unordered_set` 或 `map` 记录已生成的数，避免重复统计。  
3. **平方数排除**：在枚举 b≥3 时检查是否为平方数，仅统计非平方部分。  

---

### **同类型题与算法套路**  
- **通用解法**：  
  - 指数分治 + 哈希去重 → 处理幂次统计问题。  
  - 容斥原理 → 解决重复计数（如莫比乌斯函数优化）。  
- **类似题目**：  
  1. [P9118 幂次](https://www.luogu.com.cn/problem/P9118)  
  2. [ABC193C - Unexpressed](https://atcoder.jp/contests/abc193/tasks/abc193_c)  
  3. [CF955A Feed the cat](https://codeforces.com/problemset/problem/955/A)（数学枚举变种）  

---

### **代码实现（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

int main() {
    i64 n;
    scanf("%lld", &n);
    unordered_set<i64> s;
    // 处理 b≥3 的情况
    for (i64 i = 2; i <= 1e6; i++) {
        __int128 curr = i * i;
        while (curr <= n) {
            i64 val = (i64)curr;
            if ((i64)sqrtl(val) * (i64)sqrtl(val) != val) // 排除平方数
                s.insert(val);
            curr *= i;
        }
    }
    // 结果 = 非平方数个数 + 总平方数
    printf("%lu\n", s.size() + (size_t)sqrtl(n));
    return 0;
}
```

---

### **可视化与算法演示**  
**动画设计**：  
1. **网格绘制**：Canvas 绘制 8-bit 风格网格，每个格子表示一个数值范围。  
2. **枚举过程**：  
   - 像素方块从底数 i=2 开始向右移动，每次乘法后向上跳跃（模拟指数增长）。  
   - 方块颜色根据是否加入集合变化（绿/红）。  
3. **统计面板**：右侧显示当前哈希表大小和平方数计数。  

**音效与交互**：  
- **加入集合**：播放 "ping" 音效（8-bit 风格）。  
- **重复或平方数**：播放低沉音效。  
- **自动模式**：按空格键切换手动/自动枚举，方向键调整速度。  

**复古风格参数**：  
- 调色板：16 色，主色调为青绿（枚举路径）、红（重复）、黄（统计面板）。  
- 音效生成：使用 Web Audio API 合成 8-bit 音效。  

---

**总结**：通过分治指数范围和哈希去重，结合复古像素动画，可直观展示算法核心流程，帮助理解高效枚举与去重的关键步骤。

---
处理用时：110.72秒
# 题目信息

# [AGC001C] Shorten Diameter

## 题目描述

给你一棵 $N$ 个点的无向树，定义点 $u$ 和 $v$ 之间的距离是从 $u$ 到 $v$ 的简单路径上的边数。

你需要删除一些点，使树的直径小于等于 $K$，当且仅当删除某点不会对树的联通性产生影响时才可以删除。问至少删除多少点才可以满足要求。

## 说明/提示

$2≤N≤2000$，$1≤K≤N-1$，保证给出的图是一棵树。

## 样例 #1

### 输入

```
6 2

1 2

3 2

4 2

1 6

5 6```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2

3 2

4 2

1 6

5 6```

### 输出

```
0```

# AI分析结果



---

**算法分类**：树的遍历与枚举中心点/边

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - **分奇偶讨论**：  
     - **K为偶数**：枚举直径中点（节点），保留距离该点不超过 `K/2` 的所有节点。  
     - **K为奇数**：枚举直径中间边，保留距离边两端节点之一不超过 `(K-1)/2` 的所有节点。  
   - **统计保留点数**：通过 DFS/BFS 遍历，计算满足条件的节点总数。  
   - **取最小值**：所有枚举情况中，保留最多节点的情况即为最优解，总删除点数为 `n - 最大保留数`。

2. **算法实现关键**  
   - **DFS遍历限制步长**：在遍历时限制最大步数，统计可达节点。  
   - **避免重复统计**：使用 `vis` 数组标记已访问节点，确保每个节点只被统计一次。  
   - **奇偶统一处理**：通过奇偶性判断选择枚举点或边，保证代码逻辑简洁。

3. **解决难点**  
   - **正确枚举中心**：确定中点（点或边）是解题核心，需严格分奇偶处理。  
   - **高效统计保留点**：DFS/BFS 的步长限制是时间复杂度优化的关键。

---

### **题解评分 (≥4星)**

1. **hhoppitree（5星）**  
   - 思路清晰，代码简洁，分奇偶处理逻辑明确。  
   - 通过共享 `vis` 数组避免重复统计，正确性高。  

2. **jyz666（4星）**  
   - 分奇偶讨论清晰，但未显式处理边重复枚举。  
   - 代码结构易懂，但变量命名可优化。  

3. **AsunderSquall（4星）**  
   - 预处理边列表避免重复枚举，时间复杂度更优。  
   - 代码注释详细，适合新手理解。  

---

### **最优思路与技巧提炼**

- **对称性思想**：通过枚举中点（点或边），将复杂问题转化为局部遍历问题。  
- **DFS步长剪枝**：限制遍历深度为 `K/2` 或 `(K-1)/2`，降低时间复杂度。  
- **奇偶分治**：将问题拆分为两种独立情况，简化逻辑处理。  

---

### **同类型题与算法套路**

- **类似问题**：求树的最小/最大覆盖子图、构造特定直径的树。  
- **通用解法**：枚举对称中心（点/边），结合遍历统计满足条件的节点。  

---

### **推荐相似题目**

1. **P1099 [NOIP2007 提高组] 树网的核**  
2. **P5536 【XR-3】核心城市**  
3. **P4408 [NOI2003] 逃学的小孩**  

---

### **个人心得摘录**

- **避免复杂化思路**：最初试图直接处理直径端点，后发现枚举中点更简单。  
- **调试教训**：处理边时需注意父节点设置，避免路径回溯导致错误统计。  

---

### **可视化与算法演示设计**

1. **核心流程动画**：  
   - **枚举中心点/边**：高亮当前中心点或边，扩散显示覆盖范围。  
   - **颜色标记**：绿色为保留节点，红色为删除节点。  
   - **步进控制**：允许单步执行，观察每个中心点/边的覆盖过程。  

2. **复古像素风格**：  
   - **节点显示**：8位像素块表示树节点，中心点用黄色闪烁。  
   - **覆盖扩散**：逐帧显示 DFS 扩散过程，音效伴随覆盖动作。  
   - **自动演示**：自动切换中心点/边，显示最优解变化。  

3. **交互设计**：  
   - **控制面板**：暂停/继续、调节动画速度、切换奇偶模式。  
   - **得分系统**：每找到更优解时播放胜利音效，累计得分。  

---

### **代码片段（关键逻辑）**

```cpp
// 枚举中心点（K为偶数）
for (int i = 1; i <= n; i++) {
    memset(vis, 0, sizeof(vis));
    cnt = 0;
    dfs(i, k / 2); // DFS统计可达点
    ans = min(ans, n - cnt);
}

// 枚举边（K为奇数）
for (int i = 1; i <= n; i++) {
    for (int j : G[i]) {
        memset(vis, 0, sizeof(vis));
        cnt = 0;
        dfs(i, (k - 1) / 2, j); // 从i出发，不经过j
        dfs(j, (k - 1) / 2, i); // 从j出发，不经过i
        ans = min(ans, n - cnt);
    }
}
```

---

**总结**：通过分奇偶枚举中心点/边，结合步长限制的 DFS，高效求解最小删除点数。核心思想是利用对称性简化问题，时间复杂度为 O(n²)，适用于题目约束。

---
处理用时：201.68秒
# 题目信息

# [ARC124C] LCM of GCDs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc124/tasks/arc124_c

赤い袋と青い袋と $ N $ 個のカードパックがあります。はじめどちらの袋も空です。 それぞれのカードパックには整数が書かれた $ 2 $ 枚のカードが封入されており、$ i $ 番目のカードパックに入っているカードにはそれぞれ $ a_i,b_i $ が書かれていることがわかっています。

それぞれのカードパックについて、一方のカードを赤い袋に、他方のカードを青い袋に入れます。

カードを袋に入れ終えたのち、赤い袋に入ったカードに書かれた整数全体の最大公約数を $ X $ とします。 同様に、青い袋に入ったカードに書かれた整数全体の最大公約数を $ Y $ とします。 $ X $ と $ Y $ の最小公倍数の値が得点となります。

得点としてありうる値の最大値を求めてください。

## 说明/提示

### 制約

- 与えられる入力は全て整数
- $ 1\ \leq\ N\ \leq\ 50 $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ 10^9 $

### Sample Explanation 1

\- $ 2 $ が書かれたカードを赤い袋に入れ、$ 15 $ が書かれたカードを青い袋に入れ、$ 6 $ が書かれたカードを赤い袋に入れ、$ 10 $ が書かれたカードを青い袋に入れるのが最適な入れ方の $ 1 $ つです。 - このとき、赤い袋に入ったカードに書かれた整数全体の最大公約数は $ 2 $、青い袋に入ったカードに書かれた整数全体の最大公約数は $ 5 $ です。 - このときの得点は $ 10 $ です。

## 样例 #1

### 输入

```
2

2 15

10 6```

### 输出

```
10```

## 样例 #2

### 输入

```
5

148834018 644854700

947642099 255192490

35137537 134714230

944287156 528403260

68656286 200621680```

### 输出

```
238630```

## 样例 #3

### 输入

```
20

557057460 31783488

843507940 794587200

640711140 620259584

1901220 499867584

190122000 41414848

349507610 620259584

890404700 609665088

392918800 211889920

507308870 722352000

156850650 498904448

806117280 862969856

193607570 992030080

660673950 422816704

622015810 563434560

207866720 316871744

63057130 117502592

482593010 366954816

605221700 705015552

702500790 900532160

171743540 353470912```

### 输出

```
152594452160```

# AI分析结果



## 算法分类
**数论、枚举**

---

## 题解思路与解决难点

### 核心思路
题目要求将每个卡包的两张卡片分配到两个袋子，使得两袋数的GCD的最小公倍数最大。关键点在于枚举可能的GCD值，并验证其可行性。

### 算法要点
1. **因数分解**：第一个卡包的a₁和b₁的因数构成候选集合，因为最终的X和Y必须是这些因数之一。
2. **枚举与验证**：遍历所有可能的(X,Y)组合，检查其他卡包是否能通过分配满足条件。

### 解决难点
- **因数数量爆炸**：直接枚举所有可能的因数组合会导致时间复杂度过高。通过限制候选集合到第一个卡包的因数，大幅减少枚举量。
- **分配策略验证**：对于每个候选(X,Y)，检查所有卡包是否存在一种分配方式，使得红袋中的数能被X整除，蓝袋中的数能被Y整除。

---

## 题解评分 (≥4星)
1. **User_Authorized (5星)**  
   - **思路清晰**：基于因数分解和枚举，逻辑严谨。
   - **代码简洁**：利用STL快速生成因数集合。
   - **唯一不足**：未完全覆盖第一个卡包交换分配的情况，但实践中能通过所有测试用例。

2. **Tastoya (4星)**  
   - **因数合并**：显式合并第一个卡包a₁和b₁的因数。
   - **详细注释**：代码可读性强，但未处理交换分配。

3. **Pt_crN (4星)**  
   - **因数检查优化**：提前生成因数集合，快速验证每个候选对。
   - **代码简洁性**：逻辑直白，但同样未覆盖交换分配。

---

## 最优思路与技巧
1. **因数候选集限制**：仅枚举第一个卡包的因数，避免全量枚举。
2. **分配条件验证**：对每个候选(X,Y)，只需验证其他卡包是否满足两种分配方式之一。
3. **合并因数优化**：将第一个卡包的a₁和b₁的因数合并，覆盖所有可能的分配顺序。

---

## 同类型题与套路
- **常见套路**：因数分解结合枚举，常用于涉及GCD/LCM的极值问题。
- **相似题目**：  
  - [CF1459C - Row GCD](https://codeforces.com/problemset/problem/1459/C)  
  - [洛谷P2441](https://www.luogu.com.cn/problem/P2441)（因数分解与动态规划）  
  - [AT ABC191E](https://atcoder.jp/contests/abc191/tasks/abc191_e)（最短路与GCD结合）

---

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

vector<ll> get_divisors(ll x) {
    vector<ll> res;
    for (ll i=1; i*i<=x; i++) {
        if (x%i == 0) {
            res.push_back(i);
            if (x/i != i) res.push_back(x/i);
        }
    }
    return res;
}

ll lcm(ll a, ll b) {
    return a / __gcd(a, b) * b;
}

bool check(ll x, ll y, vector<pair<ll, ll>>& cards) {
    for (auto& [a, b] : cards) {
        bool ok = (a%x == 0 && b%y == 0) || (b%x == 0 && a%y == 0);
        if (!ok) return false;
    }
    return true;
}

int main() {
    int n; cin >> n;
    vector<pair<ll, ll>> cards(n);
    for (auto& [a, b] : cards) cin >> a >> b;

    auto div_a = get_divisors(cards[0].first);
    auto div_b = get_divisors(cards[0].second);
    unordered_set<ll> candidates_x(div_a.begin(), div_a.end());
    candidates_x.insert(div_b.begin(), div_b.end());
    unordered_set<ll> candidates_y = candidates_x;

    ll ans = 0;
    for (auto x : candidates_x) {
        for (auto y : candidates_y) {
            if (check(x, y, cards)) {
                ans = max(ans, lcm(x, y));
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 可视化算法设计
### 动画演示方案
1. **像素风格界面**：用Canvas绘制卡包和袋子，卡牌以像素方块表示，颜色区分红蓝袋。
2. **步进操作**：高亮当前枚举的(X,Y)，动态显示卡包分配选择（绿框为选中）。
3. **颜色反馈**：红色表示验证失败，绿色表示成功，黄色表示当前检查的卡包。
4. **自动模式**：按因数大小顺序自动枚举，速度可调。

---

## 复古游戏化效果
- **8位音效**：验证成功时播放上升音阶，失败时低沉音效。
- **积分系统**：每通过一个候选对得10分，最终显示最高分。
- **关卡制**：将每个卡包的验证作为小关卡，通关后解锁速度调节。

---
处理用时：593.68秒
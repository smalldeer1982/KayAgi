# 题目信息

# [ABC354F] Useless for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_f

長さ $ N $ の整数列 $ A $ が与えられます。

$ t\ =\ 1,\ 2,\ \dots\ ,N $ について、 $ A_t $ が $ A $ の最長増加部分列に含まれることがあるか判定してください。

$ A_t $ が $ A $ の最長増加部分列に含まれることがあるとは、以下のことをいいます。

- 最長増加部分列の長さを $ L $ とする。各要素が $ 1 $ 以上 $ N $ 以下の単調増加な整数列 $ i\ =\ (i_1,\ i_2,\ \dots\ ,i_L)\ (i_1\ であって以下をすべて満たすものが存在する。 $
  
  
  - $ A_{i_1} $
  - ある $ k\ (1\ \leq\ k\ \leq\ L) $ が存在して $ i_k\ =\ t $ である

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

最長増加部分列とは？列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下

### Sample Explanation 1

最長増加部分列の $ 1 $ つは $ (2,\ 4,\ 5) $ で、長さは $ 3 $ です。$ (1,\ 4,\ 5) $ も最長増加部分列の $ 1 $ つです。しかし、 $ A_5 $ を含む最長増加部分列はありません。 よって、 $ 1,\ 2,\ 3,\ 4 $ を出力します。

## 样例 #1

### 输入

```
1
5
2 1 4 5 3```

### 输出

```
4
1 2 3 4```

## 样例 #2

### 输入

```
2
6
2 5 3 4 3 4
5
10000 1000 100 1 10```

### 输出

```
5
1 3 4 5 6
2
4 5```

# AI分析结果



**唯一算法分类**: 动态规划（结合贪心与二分优化）

---

### **题解思路与算法要点**
1. **核心思路**  
   - 对于每个元素，判断是否存在一个最长递增子序列（LIS）包含它。关键在于：以该元素结尾的LIS长度（正向）和以该元素开头的LIS长度（反向）之和减一等于整个序列的LIS总长度。
   - **正向处理**：计算每个元素作为结尾的LIS长度 `f[i]`，使用贪心+二分维护递增序列的最小末尾值。
   - **反向处理**：将数组反转并取负数后，再次计算每个元素的LIS长度 `g[i]`，等价于原数组中以该元素开头的最长递减子序列长度。
   - **条件判断**：若 `f[i] + g[i] - 1 == L`（`L`为总LIS长度），则该元素有效。

2. **解决难点**  
   - **高效计算正反LIS**：通过两次贪心二分将时间复杂度优化至 $O(n \log n)$。
   - **离散化处理**：部分题解通过离散化处理大值域，结合树状数组优化动态规划。

---

### **题解评分 (≥4星)**
1. **fuxiheng（★★★★★）**  
   - 代码简洁，正反两次二分维护DP数组，逻辑清晰。
   - 通过取反处理反向LIS，巧妙转换为相同问题。
   - 时间复杂度严格 $O(n \log n)$，适合大规模数据。

2. **Keroshi（★★★★☆）**  
   - 树状数组优化离散化后的动态规划，高效实现。
   - 代码结构清晰，可读性强，但离散化部分稍显冗余。

3. **small_john（★★★★☆）**  
   - 通过图遍历筛选有效节点，思路新颖。
   - 优化搜索次数，避免重复计算，但代码复杂度较高。

---

### **最优思路提炼**
1. **关键技巧**  
   - **正反两次处理**：正向计算以元素结尾的LIS长度，反向计算以元素开头的逆向LIS长度。
   - **贪心+二分维护DP数组**：用数组 `p` 维护递增序列的最小末尾值，快速更新每个元素的LIS长度。
   - **离散化与树状数组**：离散化后通过树状数组维护前缀最大值，优化动态规划过程。

2. **代码实现要点**  
   ```cpp
   // 正向处理（计算f[i]）
   for (int i = 1; i <= n; i++) {
       f[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
       p[f[i]] = a[i];
       Max = max(Max, f[i]);
   }
   // 反向处理（计算g[i]，取负数后处理）
   reverse(a + 1, a + n + 1);
   for (int i = 1; i <= n; i++) a[i] = -a[i];
   for (int i = n; i; i--) {
       g[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
       p[g[i]] = a[i];
   }
   // 判断条件
   if (f[i] + g[i] - 1 == Max) ans.push_back(i);
   ```

---

### **同类问题与算法套路**
- **类似题目**  
  1. [SPOJ - SUPPER](https://www.spoj.com/problems/SUPPER/)  
  2. [LeetCode 673 - Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)  
  3. [洛谷 P1439 - 最长公共子序列](https://www.luogu.com.cn/problem/P1439)  
- **通用套路**  
  - **正反动态规划**：用于处理需要前后缀信息的场景（如子序列覆盖）。
  - **离散化+树状数组**：优化动态规划中的区间查询问题。

---

### **可视化算法演示**
1. **动画设计**  
   - **正向处理**：元素从左到右依次高亮，显示当前元素插入DP数组的位置，并更新 `f[i]`。
   - **反向处理**：元素从右到左高亮，显示取反后的值插入反向DP数组，更新 `g[i]`。
   - **条件判断**：符合条件的元素闪烁并标记颜色。

2. **复古像素风格**  
   - **颜色标记**：正向（绿色）、反向（蓝色）、有效元素（红色）。
   - **音效触发**：元素处理时播放“点击”音效，有效元素触发“成功”音效。
   - **Canvas绘制**：用像素块表示数组元素，动态显示DP数组变化。

---

### **代码实现（题解1完整代码）**
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Luo_ty{
    const int MAXN = 200005, inf = 0x7fffffff / 2;
    int a[MAXN];
    int p[MAXN], f[MAXN], g[MAXN];
    int inc[MAXN];
    int main(){
        int T, n;
        scanf("%d", &T);
        while(T--){
            scanf("%d", &n);
            for(int i = 1;i <= n;i++) scanf("%d", &a[i]);
            // 正向计算f[i]
            for(int i = 1;i <= n;i++) p[i] = inf;
            p[0] = -inf;
            int Max = 0;
            for(int i = 1;i <= n;i++){
                f[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
                p[f[i]] = a[i];
                Max = max(Max, f[i]);
            }
            // 反向计算g[i]
            for(int i = 1;i <= n;i++) a[i] = -a[i];
            for(int i = 1;i <= n;i++) p[i] = inf;
            p[0] = -inf;
            for(int i = n;i >= 1;i--){
                g[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
                p[g[i]] = a[i];
            }
            // 统计结果
            int ans = 0;
            for(int i = 1;i <= n;i++){
                if(f[i] + g[i] - 1 == Max){
                    inc[++ans] = i;
                }
            }
            printf("%d\n", ans);
            for(int i = 1;i <= ans;i++) printf("%d ", inc[i]);
            puts("");
        }
        return 0;
    }
}
signed main(){
    return Luo_ty::main();
}
```

---
处理用时：207.46秒
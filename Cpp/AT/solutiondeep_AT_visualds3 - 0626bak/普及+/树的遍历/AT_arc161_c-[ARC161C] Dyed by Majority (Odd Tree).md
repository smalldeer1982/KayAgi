# 题目信息

# [ARC161C] Dyed by Majority (Odd Tree)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc161/tasks/arc161_c

$ N $ 頂点の木が与えられます． 頂点には $ 1 $ から $ N $ までの番号が付いており，$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます． また，すべての頂点について，**接続する辺の本数は奇数**です．

与えられた木の各頂点を黒 ( `B` ) か白 ( `W` ) のいずれかの色で塗ります． このとき，「各頂点の色（ `B` または `W` ）を頂点の番号順に並べて得られる文字列」を**色の列**と呼びます．

色の列 $ S $ が与えられます． すべての頂点に色が塗られた状態で以下の操作を $ 1 $ 回行った結果，色の列が $ S $ となることがあり得るかどうかを判定し，あり得るなら操作を行う前の色の列として適切なものを $ 1 $ つ求めてください．

**操作:** 各頂点 $ k\ =\ 1,\ 2,\ \dots,\ N $ に対して，辺で結ばれた頂点の色のうち過半数を占めるものを $ C_k $ とする． すべての頂点について同時に，頂点 $ k $ の色を $ C_k $ に塗り替える．

$ T $ 個のテストケースが与えられるので，それぞれについて答えてください．

## 说明/提示

### 制約

- $ T\ \geq\ 1 $
- $ N\ \geq\ 2 $
- $ 1 $ つの入力に含まれるテストケースについて，$ N $ の総和は $ 2\ \times\ 10^5 $ 以下である．
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N\ (1\ \leq\ i\ \leq\ N\ -\ 1) $
- 与えられる辺 $ (A_i,\ B_i)\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ は木をなす．
- 各頂点 $ k\ (1\ \leq\ k\ \leq\ N) $ は $ A_i,\ B_i\ (1\ \leq\ i\ \leq\ N\ -\ 1) $ として**合計奇数回**現れる．
- $ S $ は `B`, `W` からなる長さ $ N $ の文字列である．
 
### Sample Explanation 1

$ 1 $ つ目のテストケースについて，操作を行う前の色の列が `WBBW` であったとします． このとき， - 頂点 $ 1 $ について，辺で結ばれた頂点 $ 2,\ 3,\ 4 $ の色はそれぞれ `B`, `B`, `W` であり，過半数を占めるのは $ C_1\ =\ {} $`B`， - 頂点 $ 2 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_2\ =\ {} $`W`， - 頂点 $ 3 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_3\ =\ {} $`W`， - 頂点 $ 4 $ について，辺で結ばれた頂点 $ 1 $ の色は `W` であり，過半数を占めるのは $ C_4\ =\ {} $`W` となります． したがって，操作後の色の列は `BWWW` となり，条件を満たします． 同様に，操作前の色の列が `WBBB`, `WBWB`, `WWBB` であった場合にも，操作後の色の列は `BWWW` となり，これらのうちどれを出力しても正答と見なされます。 $ 2 $ つ目のテストケースについて，入力された木において操作を行った結果，色の列が `BBWW` となることはあり得ません．

## 样例 #1

### 输入

```
2

4

1 2

1 3

1 4

BWWW

4

1 2

1 3

1 4

BBWW```

### 输出

```
WBBW

-1```

# AI分析结果



### 算法分类选择
**树形贪心算法**（自底向上处理）

### 题解思路、算法要点与解决难点

#### 核心思路
1. **逆向推导**：从目标颜色反推初始颜色，每个节点在操作后的颜色等于其邻居的多数颜色。
2. **自底向上处理**：优先处理叶子节点，确定父节点的颜色必须等于叶子的目标颜色，递归处理父节点。
3. **需求传递**：若子节点颜色无法满足过半数要求，则要求父节点的颜色补足。

#### 解决难点
- **父子依赖**：父节点颜色可能被子节点需求强制设定，需处理冲突。
- **奇度数性质**：每个节点度数为奇数，确保操作时不存在平票情况。
- **根节点处理**：根节点无父节点，需单独验证是否满足条件。

#### 算法流程
1. **DFS后序遍历**：从叶子节点开始，逐层向上处理父节点。
2. **颜色统计与需求判断**：
   - 统计子节点中满足目标颜色的数量。
   - 若数量不足，强制父节点颜色补足。
   - 若数量刚达半数，父节点颜色必须补足。
3. **冲突检测**：若父节点颜色被多次设定为不同值，判定无解。

### 题解评分（≥4星）

1. **良心WA题人（★★★★★）**  
   思路清晰，代码简洁。通过DFS统计子节点颜色，明确处理父节点需求，代码逻辑直观。

2. **Lucyna_Kushinada（★★★★☆）**  
   提出“固定/不固定”状态分类，清晰展示节点需求传递逻辑，代码可读性高。

3. **鲤鱼江（★★★★☆）**  
   剥叶子法处理高效，特判根节点和双节点情况，代码结构紧凑。

---

### 最优思路或技巧提炼
1. **叶节点驱动父节点**：叶子节点的父节点初始颜色必须等于叶子目标颜色。
2. **贪心填充不确定子节点**：未确定的子节点初始颜色设为父节点目标颜色，最大化满足父节点需求。
3. **奇度数性质利用**：确保每个节点的邻居数量为奇数，简化过半数计算。

### 同类型题或类似算法套路
- **树形逆向推导**：如[ARC156C] 类似的反向推导树节点条件。
- **拓扑贪心**：如按度数为1的节点逐步处理，类似剥洋葱。

### 推荐相似题目
1. **P1355 树的颜色**（逆向推导树节点条件）
2. **P2665 树上游戏**（树形贪心与状态传递）
3. **CF1092F Tree with Maximum Cost**（树形DP与后序遍历）

---

### 个人心得摘录
- **多测清空**：鲤鱼江提到因未清空邻接表导致WA，需注意全局变量初始化。
- **奇偶处理**：利用度数为奇数简化过半数判断，避免平票边界情况。

---

### 可视化与算法演示设计

#### 动画方案
1. **树形结构展示**：Canvas绘制树，节点按层级分布。
2. **颜色标记**：
   - 红色高亮：当前处理的叶子节点。
   - 蓝色标记：父节点颜色被强制设定。
3. **步进流程**：
   - 初始：所有节点灰色（未确定）。
   - 选中叶子节点，父节点颜色设为叶子目标色。
   - 递归上移，重复处理新生成的叶子。
4. **冲突提示**：若父节点颜色冲突，播放警示音效并闪烁红色。

#### 复古像素风格
- **8位色调色板**：绿色（叶子）、黄色（处理中节点）、红色（冲突）。
- **音效**：
  - 成功设定颜色：短促“哔”声。
  - 冲突：低音“嗡”声。
- **自动演示**：按拓扑序自动处理节点，支持暂停/步进。

---

### 核心代码实现
```cpp
// 良心WA题人题解核心代码
bool dfs(int u, int fa) {
    int cnt = 0;
    for (int v : g[u]) {
        if (v == fa) continue;
        if (!dfs(v, u)) return false;  // 递归处理子节点
        if (!col[v]) col[v] = s[u];    // 贪心填充未确定子节点
        if (col[v] == s[u]) cnt++;     // 统计符合要求的子节点数
    }
    int total = g[u].size() - (fa != 0); // 实际子节点数（排除父节点）
    if (cnt < total / 2) return false;   // 不满足过半数
    
    // 处理需要父节点补足的情况
    if (cnt == total / 2) {
        if (!fa || (col[fa] && col[fa] != s[u])) 
            return false; // 父节点冲突
        col[fa] = s[u];  // 强制父节点颜色
    }
    return true;
}
```

---

### 总结
通过自底向上的贪心处理，利用树的层级结构逐步确定父节点颜色，结合奇度数特性简化判断，是解决此类树形逆向推导问题的典型方法。

---
处理用时：154.46秒
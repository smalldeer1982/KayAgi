# 题目信息

# [ABC258E] Packing Potatoes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc258/tasks/abc258_e

ベルトコンベアに載って $ 10^{100} $ 個のじゃがいもが $ 1 $ 個ずつ流れてきます。流れてくるじゃがいもの重さは長さ $ N $ の数列 $ W\ =\ (W_0,\ \dots,\ W_{N-1}) $ で表され、$ i\ \,\ (1\ \leq\ i\ \leq\ 10^{100}) $ 番目に流れてくるじゃがいもの重さは $ W_{(i-1)\ \bmod\ N} $ です。ここで、$ (i-1)\ \bmod\ N $ は $ i\ -\ 1 $ を $ N $ で割った余りを表します。

高橋君は、まず空の箱を用意し、次のルールに従ってじゃがいもを順番に箱に詰めていきます。

- じゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和が $ X $ 以上になったら、その箱には蓋をし、新たに空の箱を用意する。

$ Q $ 個のクエリが与えられます。$ i\ \,\ (1\ \leq\ i\ \leq\ Q) $ 番目のクエリでは、正整数 $ K_i $ が与えられるので、$ K_i $ 番目に蓋をされた箱に入っているじゃがいもの個数を求めてください。問題の制約下で、蓋をされた箱が $ K_i $ 個以上存在することが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ X\ \leq\ 10^9 $
- $ 1\ \leq\ W_i\ \leq\ 10^9\ \,\ (0\ \leq\ i\ \leq\ N\ -\ 1) $
- $ 1\ \leq\ K_i\ \leq\ 10^{12}\ \,\ (1\ \leq\ i\ \leq\ Q) $
- 入力は全て整数

### Sample Explanation 1

$ 2 $ つの箱に蓋をするまでの高橋くんの行動は以下の通りです。 - 空の箱を用意する。 - $ 1 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 3 $ である。 - $ 2 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 3\ +\ 4\ =\ 7 $ であり、$ X\ =\ 5 $ 以上になったのでこの箱には蓋をする。 - 新たに空の箱を用意する。 - $ 3 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 1 $ である。 - $ 4 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 1\ +\ 3\ =\ 4 $ である。 - $ 5 $ 番目のじゃがいもを箱に入れる。箱に入っているじゃがいもの重さの総和は $ 1\ +\ 3\ +\ 4\ =\ 8 $ であり、$ X\ =\ 5 $ 以上になったのでこの箱には蓋をする。 $ 1 $ 番目に蓋をされた箱には $ 2 $ つのじゃがいもが入っており、$ 2 $ 番目に蓋をされた箱には $ 3 $ つのじゃがいもが入っています。

## 样例 #1

### 输入

```
3 2 5
3 4 1
1
2```

### 输出

```
2
3```

## 样例 #2

### 输入

```
10 5 20
5 8 5 9 8 7 4 4 8 2
1
1000
1000000
1000000000
1000000000000```

### 输出

```
4
5
5
5
5```

# AI分析结果



**唯一算法分类**：循环节检测+前缀和+二分查找

---

### **题解思路与算法要点**

#### **核心思路**
1. **预处理每个起点的终止位置**：利用前缀和与二分法，确定从每个起点i开始装箱的终止位置，计算对应的土豆数量`ans[i]`及下一个起点`nxt[i]`。
2. **寻找循环节**：根据抽屉原理，从起点1出发遍历`nxt`数组，必在n+1步内进入循环，记录循环起点`st`和长度`cyc`。
3. **快速查询**：对每个查询K，若未进入循环直接取结果；否则通过模运算定位到循环中的对应位置。

#### **解决难点**
- **处理大X**：当X超过总和时，利用取模和整除减少计算量。
- **循环节检测**：通过标记访问顺序或队列分割路径，高效找到循环起点和长度。

---

### **题解评分 (≥4星)**

1. **xqh07 (4星)**  
   - **亮点**：代码简洁，利用`vis`和`rve`数组记录访问顺序，逻辑清晰。预处理部分用二分处理跨循环的情况。
   - **优化点**：循环节检测直接通过`vis`数组快速定位。

2. **FXT1110011010OI (4星)**  
   - **亮点**：复制数组处理环形结构，通过`xh`和`res`数组分离循环节前后的结果。
   - **优化点**：直接处理前n次装箱，确保后续进入循环。

3. **Tsawke (4星)**  
   - **亮点**：详细处理前缀和与二分边界，使用队列分割循环节路径。
   - **优化点**：代码注释详细，调试信息完备。

---

### **最优思路提炼**
- **关键技巧**：  
  1. **前缀和+二分**：快速确定每个起点对应的终止位置。  
  2. **循环节检测**：通过遍历标记或队列分割，将结果分为非循环前缀和循环体。  
  3. **模运算优化查询**：将大K映射到循环中的位置，实现O(1)查询。  

---

### **同类型题与算法套路**
- **类似问题**：约瑟夫环问题、循环链表检测、周期序列处理。
- **通用解法**：预处理每个状态的转移，检测循环后分治处理。

---

### **推荐题目**
1. **P1965 转圈游戏**（模运算与循环节）  
2. **P1516 青蛙的约会**（循环节与同余方程）  
3. **P3435 [POI2006] OKR-Periods of Words**（KMP与周期判断）

---

### **可视化设计**
- **动画方案**：  
  1. **网格绘制**：每个起点i显示为节点，箭头指向`nxt[i]`，高亮形成环的路径。  
  2. **步进控制**：单步执行装箱过程，显示当前箱子总和和二分查找过程。  
  3. **循环节标记**：用不同颜色区分非循环前缀和循环体。  

- **复古像素风格**：  
  - **颜色方案**：8位色块表示不同起点，闪烁箭头表示转移。  
  - **音效**：装箱完成时播放“完成音效”，循环检测成功时播放胜利音效。  
  - **自动演示**：模拟AI自动遍历nxt数组，高亮循环路径。

---

### **核心代码片段（xqh07题解）**
```cpp
// 预处理nxt和ans数组
for(int i = 1; i <= n; i++) {
    int y = s[n] - s[i-1], z = x;
    if(y >= x) {
        // 二分查找终止位置
        int pos = lower_bound(s + i, s + n + 1, s[i-1] + x) - s;
        nxt[i] = pos % n + 1;
        ans[i] = pos - i + 1;
    } else {
        // 处理跨循环的情况
        ans[i] += n - i + 1;
        z -= y;
        ans[i] += n * (z / s[n]);
        z %= s[n];
        int pos = lower_bound(s + 1, s + n + 1, z) - s;
        ans[i] += pos;
        nxt[i] = pos % n + 1;
    }
}
// 检测循环节
int i = 1, cnt = 1;
vis[1] = rve[1] = 1;
while(true) {
    i = nxt[i];
    ++cnt;
    if(vis[i]) {
        st = vis[i], cyc = cnt - vis[i];
        break;
    }
    vis[i] = cnt;
    rve[cnt] = i;
}
```

---

### **个人心得摘录**
> “调试中发现循环节检测的起始点容易出错，需仔细验证预处理后的nxt数组是否成环。” —— Tsawke  
> “复制数组处理环形结构让二分更直观，避免模运算干扰。” —— FXT1110011010OI

---
处理用时：75.96秒
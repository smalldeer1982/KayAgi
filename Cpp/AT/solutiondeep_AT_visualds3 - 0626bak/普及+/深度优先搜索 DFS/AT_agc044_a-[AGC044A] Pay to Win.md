# 题目信息

# [AGC044A] Pay to Win

## 题目描述

# [AGC044A] Pay to Win


你有一个数字$0$ ，你希望得到数字$N$。

你可以通过以下操作更改数字，需要支付一定数量的硬币：

- 将当前数乘$2$，需要$A$硬币。
- 将当前数乘$3$，需要$B$硬币。
- 将当前数乘$5$，需要$C$硬币。
- 将当前数加$1$或减$1$，需要$D$硬币。

你可以按任意顺序和任意次数执行这些操作。

最少需要多少硬币才能得到$N$？

你需要解决$T$组测试用例。

## 说明/提示

### 约束

- $ 1\ \le\ T\ \le\ 10 $
- $ 1\ \le\ N\ \le\ 10^{18} $
- $ 1\ \le\ A,\ B,\ C,\ D\ \le\ 10^9 $
- $ N,\ A,\ B,\ C,\ D $ 都是整数。

### Sample Explanation 1

对于第一个测试用例，达到最低成本$20$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$1$个硬币使其乘$2(x = 4)$
- 用$2$个硬币使其乘$3(x = 12)$
- 用$8$个硬币使其减$1(x = 11)$

对于第二个测试用例，达到最低成本$19$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$2$个硬币使其乘$5(x = 10)$
- 用$8$个硬币使其减$1(x = 11)$

## 样例 #1

### 输入

```
5

11 1 2 4 8

11 1 2 2 8

32 10 8 5 4

29384293847243 454353412 332423423 934923490 1

900000000000000000 332423423 454353412 934923490 987654321```

### 输出

```
20

19

26

3821859835

23441258666```

# AI分析结果



---

### 算法分类选择  
**其他搜索**（逆向记忆化DFS）

---

### 综合分析与结论  
**核心思路**：  
逆向DFS结合记忆化，从目标数N出发，通过除法和调整操作逐步归零，优先处理除法操作以减少状态数。每次操作考虑调整到最近的2/3/5倍数，递归求解子问题的最小代价。  

**解决难点**：  
1. **大数处理**：逆向操作通过除法快速缩小数值范围，避免正向搜索的指数爆炸。  
2. **状态剪枝**：记忆化存储每个数值的最小代价，避免重复计算。  
3. **调整策略**：对每个非整除的数，计算上下两个最近的倍数作为调整目标，确保不遗漏更优路径。  

**可视化设计**：  
- **动画方案**：在Canvas中以树状图展示当前节点（数值）和分支（调整到最近倍数的操作），节点颜色区分已访问（灰色）和待访问（绿色）。  
- **步进控制**：支持单步执行，展示当前节点如何选择调整方向（乘2/3/5的上下调整），并动态更新最小代价。  
- **复古像素风格**：用16色块表示数值大小，访问时播放8-bit音效，成功归零时触发胜利音效。  

---

### 题解清单（≥4星）  
1. **suzhikz（5星）**  
   - **亮点**：代码简洁，显式处理乘除后的上下界，使用`__int128`防止溢出。  
   - **心得**：通过逆向DFS减少状态数，优先除法操作优化路径。  

2. **IkunTeddy（4星）**  
   - **亮点**：显式拆分整除与非整除情况，逻辑清晰易读。  
   - **优化**：直接计算最近倍数，避免冗余条件判断。  

3. **墨笙_Mooos（4星）**  
   - **亮点**：理论分析完备，结合数学归纳证明时间复杂度，代码与官方思路一致。  

---

### 核心代码实现  
**逆向DFS + 记忆化（suzhikz）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
map<ll, ll> m;
ll a, b, c, d;

ll dfs(ll x) {
    if (m.count(x)) return m[x];
    if (x == 0) return 0;
    ll ans = min((__int128)x * d, (__int128)1e18); // 防止溢出
    // 处理乘2操作
    ll l = x / 2 * 2, r = (x + 1) / 2 * 2;
    ans = min(ans, (x - l) * d + a + dfs(l / 2));
    ans = min(ans, (r - x) * d + a + dfs(r / 2));
    // 处理乘3操作
    l = x / 3 * 3, r = (x + 2) / 3 * 3;
    ans = min(ans, (x - l) * d + b + dfs(l / 3));
    ans = min(ans, (r - x) * d + b + dfs(r / 3));
    // 处理乘5操作
    l = x / 5 * 5, r = (x + 4) / 5 * 5;
    ans = min(ans, (x - l) * d + c + dfs(l / 5));
    ans = min(ans, (r - x) * d + c + dfs(r / 5));
    return m[x] = ans;
}
```

---

### 同类型题与算法套路  
**类似题目**：  
1. **LeetCode 397. Integer Replacement**：通过加减和除以2操作将数变为1。  
2. **Codeforces 520B. Two Buttons**：逆向BFS处理乘2和减1操作。  
3. **洛谷 P1464 Function**：记忆化搜索避免重复计算。  

**通用套路**：  
- **逆向搜索**：当正向状态爆炸时，从目标倒推，结合剪枝。  
- **离散化记忆化**：用哈希表存储已计算的大数状态。  

---

### 推荐题目  
1. **P1588 丢失的牛**（逆向BFS）  
2. **P1443 马的遍历**（BFS最短路径）  
3. **P4017 最大食物链计数**（DAG记忆化搜索）  

---

### 个人心得摘录  
- **调试经验**：在处理大数时，需特别注意溢出问题，使用`__int128`临时存储中间结果。（suzhikz）  
- **顿悟感想**：先除后加减的策略总是优于先加减后除，避免了无效的中间状态。（墨笙_Mooos）  

---

### 可视化与算法演示  
**复古像素化实现要点**：  
1. **Canvas绘制**：数值以网格块显示，当前节点高亮为黄色，子节点为绿色/红色（上下调整方向）。  
2. **音效触发**：访问节点时播放短促“哔”声，找到最优解时播放胜利旋律。  
3. **自动演示**：按层次展开DFS分支，每步延迟500ms，模拟递归深入过程。  

**JavaScript片段**：  
```javascript
// 绘制当前节点和分支
function drawNode(x, cost) {
    ctx.fillStyle = "#FFFF00"; // 当前节点黄色
    ctx.fillRect(xPos, yPos, 30, 30);
    // 绘制子节点分支
    [x/2, x/3, x/5].forEach(child => {
        drawEdge(xPos, yPos, childX, childY);
        drawNode(child, childCost); // 递归绘制
    });
}
```

---
处理用时：103.72秒
# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果



# [ABC087D] People on a Line 题解分析

## 一、算法分类
**带权并查集（其他搜索）**

---

## 二、题解思路与解决难点
### ▍核心逻辑对比
| 方法           | 数据结构       | 时间复杂度   | 解决难点                         |
|----------------|---------------|-------------|----------------------------------|
| 带权并查集      | 并查集+距离数组 | O(m α(n))  | 动态维护相对距离，路径压缩时同步更新距离 |
| DFS差分约束     | 邻接表+标记数组 | O(n+m)     | 递归处理约束，回溯时撤销访问标记       |
| SPFA差分约束    | 队列+距离数组  | O(k·m)     | 基于队列松弛，检测距离矛盾             |

### ▍搜索算法要点（以DFS为例）
- **发起搜索**：从未访问的节点开始，设置基准点坐标（如 `deep[i] = 0`）
- **访问顺序**：递归遍历邻接节点，维护当前节点到起点的距离 `deep[]`
- **剪枝策略**：若发现已访问节点的计算距离与当前距离矛盾，立即返回错误
- **数据结构**：邻接表存储约束关系，`vis[]` 数组标记已访问节点

---

## 三、题解评分（≥4星）
### ★★★★★ Doraven（带权并查集）
- **亮点**：代码简洁高效，路径压缩与距离更新同步完成，完美处理大规模数据
- **代码片段**：
```cpp
int find(int x){
    if(fa[x]!=x){
        int nf=fa[x];
        fa[x]=find(fa[x]);
        dis[x] += dis[nf]; // 路径压缩时更新距离
    }
    return fa[x];
}
```

### ★★★★☆ CreeperLordVader（DFS差分约束）
- **亮点**：双标记数组（`vis` 和 `use`）避免重复搜索，递归逻辑清晰
- **个人心得**：  
  > "如果在继续下一层DFS时返回了true，这一层也返回true" —— 通过递归返回值快速传播错误状态

### ★★★★☆ Wen_kr（SPFA差分约束）
- **亮点**：队列优化松弛过程，动态检测坐标差超过1e9的非法情况
- **剪枝技巧**：提前终止条件 `curmax - curmin > 1e9` 应对极端数据

---

## 四、最优思路提炼
### ▍带权并查集核心技巧
1. **路径压缩同步更新距离**  
   在 `find` 函数中递归更新父节点时，累加路径上所有祖先的距离偏移量。
   
2. **合并集合的向量运算**  
   合并两个集合时，通过向量方程 `dis[rl] = d + dis[r] - dis[l]` 维护相对距离的数学正确性。

3. **即时矛盾检测**  
   若两个节点已连通且当前约束与已有距离矛盾，立即标记错误。

---

## 五、同类型题与算法套路
### 1. 相似问题
- **带权并查集**：[P2024 食物链](https://www.luogu.com.cn/problem/P2024)  
  （维护三类动物的循环关系）
- **差分约束系统**：[P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)  
  （处理不等式的可行性）

### 2. 通用模板
```python
# 带权并查集模板
class DSU:
    def __init__(self):
        self.parent = {}
        self.dist = {}  # 到根节点的距离
    
    def find(self, x):
        if x != self.parent[x]:
            root = self.find(self.parent[x])
            self.dist[x] += self.dist[self.parent[x]] # 路径压缩时更新距离
            self.parent[x] = root
        return self.parent[x]
```

---

## 六、推荐习题
1. [AT3882（原题）](https://www.luogu.com.cn/problem/AT3882)  
2. [P2294 狡猾的商人](https://www.luogu.com.cn/problem/P2294)（带权并查集应用）  
3. [P4926 脉冲探测器](https://www.luogu.com.cn/problem/P4926)（差分约束变形）

---

## 七、可视化与算法演示
### ▍带权并查集动画设计
![带权并查集路径压缩](https://assets.luogu.com.cn/upload/image_hosting/3m9kz5gv.gif)
- **颜色标记**：
  - 🔴 当前操作节点  
  - 🟢 已压缩路径的节点  
  - 数值标注：节点到父节点的距离

- **关键帧说明**：
  1. 初始状态：节点独立成树，距离为0  
  2. 处理约束 `(1,2,1)`：合并节点1和2，更新距离  
  3. 处理约束 `(2,3,1)`：路径压缩后动态调整节点1的距离

### ▍复古像素风格演示
- **Canvas绘制**：  
  用16x16像素方块表示节点，箭头表示约束关系，右侧显示当前合并操作。
- **音效设计**：
  - 📢 发现矛盾时播放8-bit警报音  
  - 🎵 背景音乐：FC经典《超级马里奥》地下关BGM

---

## 八、最终结论
**带权并查集**是本题最优解法，其以近线性的时间复杂度高效处理十万级数据，通过路径压缩与向量运算的精妙结合，完美解决动态约束维护问题。

---
处理用时：68.31秒
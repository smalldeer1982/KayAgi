# 题目信息

# [ABC340E] Mancala 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc340/tasks/abc340_e

$ 0 $ から $ N-1 $ の番号がついた $ N $ 個の箱があります。最初、箱 $ i $ には $ A_i $ 個のボールが入っています。

高橋君は $ i=1,2,\ldots,M $ の順に以下の操作を行います。

- 変数 $ C $ を $ 0 $ とする。
- 箱 $ B_i $ の中のボールを全て取り出し、手に持つ。
- 手にボールを $ 1 $ 個以上持っている間、次の処理を繰り返す：
  - $ C $ の値を $ 1 $ 増やす。
  - 手に持っているボールを $ 1 $ 個、箱 $ (B_i+C)\ \bmod\ N $ に入れる。
 
全ての操作を終えた後、各箱に入っているボールの個数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9 $
- $ 0\ \leq\ B_i\ <\ N $
- 入力は全て整数
 
### Sample Explanation 1

操作は次のように進行します。 !\[図\](https://img.atcoder.jp/abc340/2be752ad9f0e3a7336fb4d34561be58f.gif)

## 样例 #1

### 输入

```
5 3

1 2 3 4 5

2 4 0```

### 输出

```
0 4 2 7 2```

## 样例 #2

### 输入

```
3 10

1000000000 1000000000 1000000000

0 1 0 1 0 1 0 1 0 1```

### 输出

```
104320141 45436840 2850243019```

## 样例 #3

### 输入

```
1 4

1

0 0 0 0```

### 输出

```
1```

# AI分析结果



**唯一算法分类**  
区间更新/查询（使用线段树或树状数组）

---

### **题解思路、算法要点与解决难点**  
**核心逻辑**：  
每次操作将取出的球数分解为「整圈分配」和「余数分配」两部分：  
1. **整圈分配**：所有盒子增加 `⌊球数/N⌋`，用全局区间加实现  
2. **余数分配**：将剩余球分配到环形后续位置，拆分为最多两个连续区间进行局部加  

**数据结构**：  
- **树状数组**：通过差分数组实现单点修改、前缀和查询、区间加  
- **线段树**：直接支持区间加与单点查询  

**解决难点**：  
- **环形处理**：余数分配可能跨越末尾到开头，需拆分为两个连续区间  
- **复杂度优化**：将单次操作复杂度从 O(N) 降为 O(logN)  

---

### **题解评分 (≥4星)**  
1. **apiad 题解**（★★★★☆）  
   - **亮点**：图示辅助说明环形分配逻辑，代码结构清晰  
   - **不足**：线段树实现代码较长  

2. **KSCD_ 题解**（★★★★☆）  
   - **亮点**：注释详细，代码分段明确，特判处理周全  
   - **示例片段**：  
     ```cpp
     if (tu+ts>n-1) { // 处理环形拆分
         if (tu != n-1) add(1,tu+1,n-1,1,1);
         add(1,0,ts-(n-1-tu)-1,1,1);
     }
     ```

3. **NaOHqwq 题解**（★★★★☆）  
   - **亮点**：将操作分解为三步区间加，逻辑最贴近问题本质  

---

### **最优思路或技巧提炼**  
**关键技巧**：  
1. **数学分解**：`球数 = 整圈数×N + 余数`  
2. **环形转连续区间**：用模运算拆分环形操作为最多两个连续区间  
3. **差分优化**：树状数组通过差分实现 O(1) 全局加  

**代码片段示例**（树状数组实现核心逻辑）：  
```cpp
void add(int a,ll b){ // 差分数组更新
    while(a<=n) tr[a]+=b, a+=(a&-a);
}
ll ask(int a){ // 前缀和查询
    return a ? ask(a-(a&-a))+tr[a] : 0;
}

// 操作处理
ll y = ask(x); // 查询原值
add(1, y/n); add(n+1, -y/n); // 全局加整圈数
add(x+1,1); add(min(n, x+y%n)+1,-1); // 余数区间加
```

---

### **同类型题与算法套路**  
**通用解法**：  
- 环形数组操作 → 拆分为连续区间  
- 大规模重复操作 → 数学分解 + 批量更新  

**推荐题目**：  
1. [P3372 线段树模板](https://www.luogu.com.cn/problem/P3372)（区间加/求和）  
2. [CF817F 区间覆盖与统计](https://codeforces.com/problemset/problem/817/F)  
3. [AT_abc188_e 环形区间最值](https://atcoder.jp/contests/abc188/tasks/abc188_e)

---

### **可视化与算法演示**  
**动画设计**：  
1. **全局加阶段**：所有盒子瞬间变为绿色，显示 `+k` 文字  
2. **余数分配**：  
   - 红色光标从操作位置开始移动，逐个点亮后续盒子  
   - 当光标到达末尾时，跳转开头继续点亮，形成环形动画  
3. **数据结构同步**：右侧面板实时显示线段树节点更新过程  

**像素风格实现**：  
```javascript
// Canvas 绘制示例
function drawBoxes() {
  ctx.fillStyle = "#8B0000"; // 深红底色
  boxes.forEach((box, i) => {
    if (i === currentPos) ctx.fillStyle = "#FFD700"; // 高亮当前操作位置
    ctx.fillRect(i*30, 150, 25, 25); // 绘制盒子
    ctx.fillText(box.count, i*30+5, 170); // 显示球数
  });
}
```

**音效设计**：  
- 全局加时播放短促 "叮" 声  
- 余数分配时每个盒子加球播放 "咔嗒" 声  
- 操作完成时播放 8-bit 胜利音效  

---

### **总结**  
通过数学分解与数据结构优化，将看似复杂的环形操作转化为高效的区间更新问题。线段树/树状数组的选择取决于实现偏好，核心思路均通过批量处理降低时间复杂度。可视化设计通过颜色与音效强化对「整圈分配」与「余数分配」的直观理解。

---
处理用时：74.73秒
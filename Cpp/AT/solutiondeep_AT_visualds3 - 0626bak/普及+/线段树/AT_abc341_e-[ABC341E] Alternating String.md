# 题目信息

# [ABC341E] Alternating String

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc341/tasks/abc341_e

`0` と `1` のみからなる文字列であって、文字列中のどの連続する $ 2 $ 文字も異なるようなものを **良い文字列** とよびます。  
`0` と `1` のみからなる長さ $ N $ の文字列 $ S $ が与えられます。 $ Q $ 個のクエリが与えられるので、順に処理してください。  
クエリは次の $ 2 $ 種類です。

- `1 L R` : $ S $ の $ L $ 文字目から $ R $ 文字目までの `0` と `1` を反転させる。すなわち、$ L\leq\ i\leq\ R $ をみたす整数 $ i $ について、$ S $ の $ i $ 文字目が `0` ならば `1` に、`1` ならば `0` に変更する。
- `2 L R` : $ S $ の $ L $ 文字目から $ R $ 文字目までを（順番を変えずに）抜き出した長さ $ (R-L+1) $ の文字列を $ S' $ とする。$ S' $ が良い文字列ならば `Yes` を、そうでないならば `No` を出力する。

## 说明/提示

### 制約

- $ 1\leq\ N,\ Q\leq\ 5\times\ 10^5 $
- $ S $ は `0` と `1` のみからなる長さ $ N $ の文字列
- $ 1,2 $ 種類目のクエリについて、$ 1\leq\ L\leq\ R\leq\ N $
- $ 2 $ 種類目のクエリが少なくとも $ 1 $ つ存在する。
- $ N $, $ Q $, $ L $, $ R $ は整数

### Sample Explanation 1

最初、$ S= $`10100` です。このとき、クエリを与えられた順に処理すると以下のようになります。 - $ 1 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 3 $ 文字目までを抜き出した文字列は $ S'= $`101` です。これは良い文字列なので `Yes` を出力します。 - $ 2 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 5 $ 文字目までを抜き出した文字列は $ S'= $`10100` です。これは良い文字列でないので `No` を出力します。 - $ 3 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 4 $ 文字目までの `0` と `1` を反転させます。文字列 $ S $ は $ S= $`01010` となります。 - $ 4 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 5 $ 文字目までを抜き出した文字列は $ S'= $`01010` です。これは良い文字列なので `Yes` を出力します。 - $ 5 $ 番目のクエリについて、$ S $ の $ 3 $ 文字目の `0` と `1` を反転させます。文字列 $ S $ は $ S= $`01110` となります。 - $ 6 $ 番目のクエリについて、$ S $ の $ 2 $ 文字目から $ 4 $ 文字目までを抜き出した文字列は $ S'= $`111` です。これは良い文字列でないので `No` を出力します。

### Sample Explanation 2

`0` または `1` の $ 1 $ 文字からなる文字列は良い文字列の条件をみたすことに注意してください。

## 样例 #1

### 输入

```
5 6
10100
2 1 3
2 1 5
1 1 4
2 1 5
1 3 3
2 2 4```

### 输出

```
Yes
No
Yes
No```

## 样例 #2

### 输入

```
1 2
1
1 1 1
2 1 1```

### 输出

```
Yes```

# AI分析结果



# [ABC341E] Alternating String

## 算法分类
线段树、树状数组

---

## 题解思路与核心难点

### 核心思路
题目要求支持区间取反和查询区间是否为交替字符串。所有题解的核心思路均围绕 **快速判断相邻字符是否相同** 展开：

1. **线段树**：维护区间首尾字符和合法性状态，合并时检查左右子区间合法性及交界字符是否相同。
2. **树状数组/差分**：记录相邻字符是否相同，翻转时只修改区间边界，查询时判断区间内是否全为 1。
3. **分块/SET**：维护不合法位置集合，通过二分判断区间内是否存在非法点。

### 关键难点
- **翻转操作对相邻状态的影响**：翻转区间 [L, R] 时，只有 L-1 和 R 处的相邻关系可能改变。
- **高效合并区间状态**：线段树合并时需要判断左右子区间的连接处是否合法。
- **边界处理**：树状数组方法需处理 L=1 或 R=N 的特殊情况。

---

## 高分题解（≥4星）

### 1. 线段树维护合法性（作者：KSCD_，评分：⭐️⭐️⭐️⭐️⭐️）
- **核心亮点**：直接维护区间合法性，代码结构清晰。
- **代码片段**：
```cpp
struct node {
    int l, r, lv, rv, tag; 
    bool ok; // 区间是否合法
} tr[N<<2];

void pushup(int u) {
    tr[u].lv = tr[ls].lv, tr[u].rv = tr[rs].rv;
    tr[u].ok = tr[ls].ok && tr[rs].ok && (tr[ls].rv != tr[rs].lv);
}
void modify(int u, int l, int r) {
    if (覆盖区间) {
        tr[u].lv ^= 1, tr[u].rv ^= 1;
        tr[u].tag ^= 1; // 懒标记记录翻转
    }
}
```

### 2. 树状数组维护差分（作者：int_R，评分：⭐️⭐️⭐️⭐️⭐️）
- **核心亮点**：将问题转化为单点修改+区间求和，代码极简。
- **代码片段**：
```cpp
int tr[N]; // 树状数组维护差分数组
void update(int x) { // 修改 L-1 和 R 处
    if (x > 0) add(x, tr[x] ? -1 : 1);
}
int query(int l, int r) {
    return get_sum(l, r-1) == (r-l); // 全1则合法
}
```

### 3. SET维护非法点（作者：Alear，评分：⭐️⭐️⭐️⭐️）
- **核心亮点**：使用 STL set 存储非法位置，查询时二分判断。
- **代码片段**：
```cpp
set<int> bad; // 存储相邻相同的索引
void flip(int L, int R) {
    if (L > 1) toggle(L-1); // 翻转边界状态
    if (R < n) toggle(R);
}
bool check(int L, int R) {
    auto it = bad.lower_bound(L);
    return it == bad.end() || *it >= R;
}
```

---

## 最优思路提炼

### 关键技巧
1. **差分思想**：将相邻字符是否相同转化为独立标记，翻转时只影响边界。
2. **线段树合并**：通过维护首尾字符和合法性状态，实现 O(1) 区间合并。
3. **懒标记优化**：线段树的区间翻转通过懒标记延迟更新，保证 O(logN) 复杂度。

### 思维突破点
- **翻转不改变内部相邻性**：区间取反后，内部字符对的异同关系不变，只有边界可能变化。
- **合法性等价转换**：合法的区间 ⇨ 所有相邻字符不同 ⇨ 差分数组全 1。

---

## 相似题目推荐

1. [P3870 开关](https://www.luogu.com.cn/problem/P3870)（区间取反+区间求和）
2. [P6492 [COCI2010-2011#6] STEP](https://www.luogu.com.cn/problem/P6492)（维护最长合法子串）
3. [P2572 [SCOI2010] 序列操作](https://www.luogu.com.cn/problem/P2572)（复杂区间维护）

---

## 可视化设计

### 动画演示方案（线段树）
**核心逻辑**：展示线段树节点如何合并和翻转。
1. **初始化**：构建线段树，显示每个节点的 lv/rv 和 ok 状态。
2. **翻转操作**：
   - 高亮被翻转的区间节点，显示 tag 标记。
   - 播放翻转动画（0↔1），更新 lv/rv。
3. **查询操作**：
   - 递归过程可视化，显示检查左右子节点及连接处的过程。
   - 非法区间用红色高亮，合法区间用绿色。

**复古像素风格**：
- **颜色方案**：使用 8-bit 风格的绿/红表示合法/非法，黄色表示翻转中的节点。
- **音效**：
  - 翻转时播放 "blip" 音效。
  - 查询合法时播放上升音阶，非法时播放下降音阶。

---

## 核心代码（树状数组实现）
```cpp
int n, q, a[N], tr[N];
void add(int x, int v) { for(;x<=n;x+=x&-x) tr[x]+=v; }
int sum(int x) { int r=0; for(;x;x-=x&-x) r+=tr[x]; return r; }

int main() {
    scanf("%d%d%s", &n, &q, s+1);
    for(int i=1; i<=n; i++) a[i] = s[i]-'0';
    for(int i=2; i<=n; i++) 
        if(a[i] == a[i-1]) add(i-1, 1);

    while(q--) {
        int op, l, r; scanf("%d%d%d", &op, &l, &r);
        if(op == 1) {
            if(l > 1) add(l-1, (a[l-1]^=1) == a[l] ? 1 : -1);
            if(r < n) add(r, (a[r]^=1) == a[r+1] ? 1 : -1);
        } else {
            int s = sum(r-1) - sum(l-1);
            puts(s == r-l ? "Yes" : "No");
        }
    }
}
```

---
处理用时：91.69秒
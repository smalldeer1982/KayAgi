# 题目信息

# [ABC353G] Merchant Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc353/tasks/abc353_g

AtCoder 王国には町 $ 1, $ 町 $ 2,\ldots, $ 町 $ N $ の $ N $ 個の町があります。 町 $ i $ から町 $ j $ まで移動するには通行料が $ C\times|i-j| $ 円かかります。

商人である高橋君は、これから開催される $ M $ 回の市場のうち $ 0 $ 回以上に参加しようと思っています。

$ i $ 回目 $ (1\leq\ i\leq\ M) $ の市場の情報は整数の組 $ (T\ _\ i,P\ _\ i) $ で表され、$ i $ 回目の市場が町 $ T\ _\ i $ で行われ、高橋君が参加すると $ P\ _\ i $ 円が得られることを意味します。

すべての $ 1\leq\ i\lt\ M $ について、$ i $ 回目の市場が終了してから $ i+1 $ 回目の市場が開始します。 高橋君が移動するのにかかる時間は無視できるものとします。

高橋君は、はじめ $ 10\ ^\ {10\ ^\ {100}} $ 円持っており、町 $ 1 $ にいます。 参加する市場をうまく選び、うまく移動することによって高橋君が得られる儲けの最大値を求めてください。

厳密には、$ M $ 回の市場が終わったあとの所持金を最大化するように高橋君が行動した場合の最終的な高橋君の所持金を $ 10\ ^\ {10\ ^\ {100}}+X $ として、$ X $ を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ C\leq10\ ^\ 9 $
- $ 1\leq\ M\leq2\times10\ ^\ 5 $
- $ 1\leq\ T\ _\ i\leq\ N\ (1\leq\ i\leq\ M) $
- $ 1\leq\ P\ _\ i\leq10\ ^\ {13}\ (1\leq\ i\leq\ M) $
- 入力はすべて整数
 
### Sample Explanation 1

たとえば、高橋君が次のように行動することで、所持金を $ 49 $ 円増やすことができます。 - 町 $ 5 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}-12 $ 円になる。 - $ 1 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+18 $ 円になる。 - 町 $ 4 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}+15 $ 円になる。 - $ 3 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+40 $ 円になる。 - 町 $ 2 $ に移動する。所持金が $ 10\ ^\ {10\ ^\ {100}}+34 $ 円になる。 - $ 4 $ 回目の市場に参加する。所持金が $ 10\ ^\ {10\ ^\ {100}}+49 $ 円になる。 所持金を $ 10\ ^\ {10\ ^\ {100}}+50 $ 円以上にすることはできないため、`49` を出力してください。

### Sample Explanation 2

通行料が高すぎるので、高橋君は町 $ 1 $ から動かないのが最適です。

### Sample Explanation 4

出力すべき値が $ 32\operatorname{bit} $ 整数の範囲に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
6 3

4

5 30

2 10

4 25

2 15```

### 输出

```
49```

## 样例 #2

### 输入

```
6 1000000000

4

5 30

2 10

4 25

2 15```

### 输出

```
0```

## 样例 #3

### 输入

```
50 10

15

37 261

28 404

49 582

19 573

18 633

3 332

31 213

30 377

50 783

17 798

4 561

41 871

15 525

16 444

26 453```

### 输出

```
5000```

## 样例 #4

### 输入

```
50 1000000000

15

30 60541209756

48 49238708511

1 73787345006

24 47221018887

9 20218773368

34 40025202486

14 28286410866

24 82115648680

37 62913240066

14 92020110916

24 20965327730

32 67598565422

39 79828753874

40 52778306283

40 67894622518```

### 输出

```
606214471001```

# AI分析结果



# 题解分析：ABC353G - Merchant Takahashi

## 唯一算法分类
动态规划优化（拆绝对值 + 树状数组/线段树）

---

## 综合分析与结论
### 核心思路与算法流程
1. **动态规划状态设计**  
   - 定义 `dp[i]` 表示参加第 `i` 个集市后的最大收益。转移方程为：  
     `dp[i] = max{ dp[j] - C * |T_i - T_j| } + P_i`  
     其中 `T_i` 是第 `i` 个集市的举办城市，`C` 是移动单价，`P_i` 是收益。

2. **拆绝对值优化**  
   将转移分为两部分：  
   - **Case 1**: `j ≤ T_i` → `dp[i] = (max{ dp[j] + C*j } ) - C*T_i + P_i`  
   - **Case 2**: `j ≥ T_i` → `dp[i] = (max{ dp[j] - C*j } ) + C*T_i + P_i`  
   用两个树状数组/线段树维护 `dp[j]+C*j` 的前缀最大值和 `dp[j]-C*j` 的后缀最大值。

3. **数据结构实现**  
   - **树状数组**：处理前缀查询和后缀查询（通过反转下标处理后缀）  
   - **线段树**：直接维护区间最大值，支持更灵活的查询  

### 可视化设计要点
- **颜色标记**：红色高亮当前处理的集市，蓝色标记查询的前缀区间，绿色标记后缀区间  
- **动画步骤**：  
  1. 展示当前集市 `T_i` 的位置  
  2. 在左侧区间（蓝色）查询 `max(dp[j]+C*j)`  
  3. 在右侧区间（绿色）查询 `max(dp[j]-C*j)`  
  4. 更新 `dp[i]` 并插入到线段树对应位置  
- **复古像素风格**：用 8-bit 方块表示城市，音效在查询完成时播放 "beep" 音效  

---

## 题解评分（≥4星）
### 1. 作者：yemuzhe（★★★★☆）
- **亮点**：  
  - 使用双树状数组分别维护前缀和后缀最大值  
  - 代码简洁，初始化清晰  
  - 处理后缀时通过 `n-j+1` 反转下标  
```cpp
struct BIT {
    // 树状数组实现前缀最大值查询
    void add(int p, ll v) { /*...*/ }
    ll query(int p) { /*...*/ }
} tr1, tr2;

// 关键转移逻辑
ll t1 = tr1.query(x) - c * x;
ll t2 = tr2.query(x) + c * x;
dp[i] = max(t1, t2) + p;
```

### 2. 作者：sunkuangzheng（★★★★☆）
- **亮点**：  
  - 使用 AtCoder Library 的线段树模板，代码极简  
  - 直接维护 `f + C*i` 和 `f - C*i` 的全局最大值  
```cpp
segtree<ll, op, e> t1, t2; // 线段树维护区间最大值
ll d1 = t1.prod(1, x+1), d2 = t2.prod(x, n+1);
ll f = max(d1 - c*x, d2 + c*x) + p;
```

### 3. 作者：cjh20090318（★★★★☆）
- **亮点**：  
  - 手写线段树，详细注释初始化逻辑  
  - 显式处理初始状态 `f[1] = 0`  
```cpp
void build(int rt, int l, int r) {
    // 初始化线段树，-INF 表示未访问状态
    if (l == r) mx[rt] = (l == 1) ? 0 : -INF;
}
```

---

## 最优思路提炼
1. **拆绝对值分治**：将转移分为 `j ≤ T_i` 和 `j ≥ T_i` 两类，分别计算最优值。  
2. **双数据结构维护**：用两个结构（树状数组/线段树）分别维护 `dp[j] + C*j` 和 `dp[j] - C*j`，实现 O(log N) 查询。  
3. **初始化细节**：初始位置在 `T=1`，需正确设置初始值 `dp[1] = 0`。  

---

## 类似题目推荐
1. **洛谷 P6240 - 好吃的题目**（动态规划 + 线段树优化）  
2. **LeetCode 1235. 规划兼职工作**（区间排序 + 二分优化）  
3. **AtCoder DP Contest Q - Flowers**（二维偏序 + 数据结构优化）  

---

## 个人心得摘录
> "赛时没想到用双树状数组，拆绝对值后卡在了后缀处理，后来发现反转下标可以巧妙解决。" —— yemuzhe  
> "线段树的区间查询比树状数组更直观，但代码量稍大，AT库的 segtree 模板是神器。" —— sunkuangzheng  

---

## 可视化代码片段（树状数组版）
```javascript
// 伪代码：树状数组查询动画
function animateQuery(i, T_i) {
    highlightCity(T_i, 'red'); // 高亮当前城市
    // 查询左区间 [1, T_i]
    for (let j = 1; j <= T_i; j++) {
        highlightCity(j, 'blue');
        playSound('query');
    }
    let maxLeft = tr1.query(T_i);
    // 查询右区间 [T_i, n]
    for (let j = T_i; j <= n; j++) {
        highlightCity(j, 'green');
        playSound('query');
    }
    let maxRight = tr2.query(n - T_i + 1);
    // 更新 dp[i]
    dp[i] = Math.max(maxLeft - C*T_i, maxRight + C*T_i) + P_i;
    updateTree(i, T_i); // 插入到树状数组
}
```

---
处理用时：82.90秒
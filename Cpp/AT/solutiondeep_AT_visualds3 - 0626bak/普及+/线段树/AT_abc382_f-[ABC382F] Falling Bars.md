# 题目信息

# [ABC382F] Falling Bars

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_f

$ H $ 行 $ W $ 列のグリッドがあります。 このグリッドの上から $ i\ (1\leq\ i\leq\ H) $ 行目、左から $ j\ (1\leq\ j\leq\ W) $ 列目のマスを $ (i,j) $ と表記します。

$ 1 $ から $ N $ までの番号が付けられた $ N $ 個の横長のバーがグリッド上に置かれています。 バー $ i $ は $ 1\times\ 1 $ のブロックが横に $ L_i $ 個繋がった形をしており、その左端のブロックは最初マス $ (R_i,C_i) $ 上にあります。 すなわち、バー $ i $ は最初マス $ (R_i,C_i),\ (R_i,C_i+1),\ \dots,\ (R_i,C_i+L_i-1) $ を占めています。 ここで、相異なる $ 2 $ つのバーに占められているマスは存在しないことが保証されます。

現在の時刻は $ t=0 $ です。 非負整数 $ n $ を用いて $ t=0.5+n $ と表されるようなすべての時刻において、$ i=1,2,\dots,N $ の順に以下のことが起こります。

- バー $ i $ が一番下の行（$ H $ 行目）になく、かつバー $ i $ が占める各マスの $ 1 $ つ下のマスをどのバーも占めていない場合、バー $ i $ 全体が $ 1 $ マス分下に移動する。 すなわち、その時点でバー $ i $ が占めているマスが $ (r,C_i),(r,C_i+1),\dots,(r,C_i+L_i-1)\ (r\ <\ H) $ であり、どの $ j\ (0\leq\ j\leq\ L_i-1) $ についてもマス $ (r+1,C_i+j) $ を占めているバーが存在しないならば、 バー $ i $ の占めるマスが $ (r+1,C_i),(r+1,C_i+1),\dots,(r+1,C_i+L_i-1) $ に変化する。
- そうでないならば、何も起こらない。
 
$ t=10^{100} $ においてバー $ i $ が占めているマスを $ (R'_i,C_i),\ (R'_i,C_i+1),\ \dots,\ (R'_i,C_i+L_i-1) $ とします。 $ R'_1,R'_2,\dots,R'_N $ を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ R_i\leq\ H $
- $ 1\leq\ C_i\leq\ W $
- $ 1\leq\ L_i\leq\ W-C_i+1 $
- 与えられる初期状態において、相異なる $ 2 $ つのバーに占められているマスは存在しない
- 入力は全て整数
 
### Sample Explanation 1

以下の $ 3 $ つの図は左から順に $ t=0,1,2 $ でのグリッドの様子を表しています。 色の塗られた長方形は各バーを表し、長方形の中に書かれた数字はそのバーの番号です。 !\[\](https://img.atcoder.jp/abc382/57581b182e43915bce2b78747acfa2a6.png) グリッドの状態の変化は以下の通り説明されます。 - $ t=0.5 $: - $ i=1 $: バー $ 1 $ が占める各マスの $ 1 $ つ下のマスである $ (2,2),(2,3),(2,4) $ のうち、$ (2,2) $ がバー $ 3 $ に、$ (2,4) $ がバー $ 4 $ にそれぞれ占められているため、何も起こらない。 - $ i=2 $: バー $ 2 $ が占める各マスの $ 1 $ つ下のマスである $ (4,2),(4,3) $ がいずれも他のバーに占められていないため、バー $ 2 $ 全体が $ 1 $ マス分下に移動する。 - $ i=3 $: バー $ 3 $ が占める各マスの $ 1 $ つ下のマスである $ (3,1),(3,2) $ がいずれも他のバーに占められていないため、バー $ 3 $ 全体が $ 1 $ マス分下に移動する。 - $ i=4 $: バー $ 4 $ が占めるマスの $ 1 $ つ下のマスである $ (3,4) $ が他のバーに占められていないため、バー $ 4 $ 全体が $ 1 $ マス分下に移動する。 - $ t=1.5 $: - $ i=1 $: バー $ 1 $ が占める各マスの $ 1 $ つ下のマスである $ (2,2),(2,3),(2,4) $ がいずれも他のバーに占められていないため、バー $ 1 $ 全体が $ 1 $ マス分下に移動する。 - $ i=2 $: バー $ 2 $ は一番下の行にあるため、何も起こらない。 - $ i=3 $: バー $ 3 $ が占める各マスの $ 1 $ つ下のマスである $ (4,1),(4,2) $ のうち、$ (4,2) $ がバー $ 2 $ に占められているため、何も起こらない。 - $ i=4 $: バー $ 4 $ が占めるマスの $ 1 $ つ下のマスである $ (4,4) $ が他のバーに占められていないため、バー $ 4 $ 全体が $ 1 $ マス分下に移動する。 $ t=2.5,3.5,\dots $ においては $ 1 $ つ下のマスがすべて空いているようなバーが存在せず、何も起こらないため、$ t=10^{100} $ でのグリッドの状態は $ t=2 $ でのグリッドの状態（上図における一番右の状態）と同じです。 よって、$ R'_1=2,R'_2=4,R'_3=3,R'_4=4 $ です。

## 样例 #1

### 输入

```
4 4 4

1 2 3

3 2 2

2 1 2

2 4 1```

### 输出

```
2

4

3

4```

## 样例 #2

### 输入

```
382 382 3

3 3 3

8 8 8

2 2 2```

### 输出

```
382

382

381```

## 样例 #3

### 输入

```
5 10 8

2 2 1

4 3 1

4 8 2

1 2 2

2 5 3

5 4 3

4 5 2

1 5 2```

### 输出

```
5

5

5

4

3

5

4

2```

# AI分析结果



# 算法分类
**线段树**

---

## 题解思路与算法要点

### 核心思路
所有横条按初始行号从大到小排序，用线段树维护每个列的最低可用行。对于每个横条：
1. **查询区间最小值**：确定其覆盖区间内的最低可用行（即下方最近的阻碍位置）。
2. **更新区间值**：将该横条的最终位置设置为查询结果减一，并更新线段树。

### 解决难点
- **顺序处理**：按行号降序处理，确保已处理的横条不会影响后续计算。
- **区间操作**：用线段树高效处理区间查询最小值与区间赋值，时间复杂度为 O(N log W)。

---

## 题解评分（≥4星）

### [作者：Down_syndrome](https://atcoder.jp/contests/abc382/submissions/60323260) ★★★★★
- **亮点**：思路清晰，代码简洁，注释详细，线段树模板规范。
- **关键代码**：
  ```cpp
  build(1, 1, w);
  for (int i=1;i<=n;i++) {
      ans[d[i].id] = query(1, d[i].l, d[i].r) - 1;
      modify(1, d[i].l, d[i].r, ans[d[i].id]);
  }
  ```

### [作者：whx2009](https://atcoder.jp/contests/abc382/submissions/60323260) ★★★★☆
- **亮点**：代码简洁，直接维护最小值，初始值设为 `h+1`。
- **关键代码**：
  ```cpp
  jianshu(1,1,w);
  for(int i=1;i<=n;i++){
      int num=cha(1,a[i].c,a[i].c+a[i].r-1);
      ans[a[i].id]=num-1;
      xiugai(1,a[i].c,a[i].c+a[i].r-1,num-1);
  }
  ```

### [作者：Ivan422](https://atcoder.jp/contests/abc382/submissions/60345498) ★★★★☆
- **亮点**：维护最大值，初始值为0，逻辑反向但等价。
- **关键代码**：
  ```cpp
  for (int i=1;i<=q;i++){
      ans[a[i].id] = qry(1,1,m,a[i].l,a[i].r) + 1;
      upd(1,1,m,a[i].l,a[i].r,ans[a[i].id]);
  }
  ```

---

## 最优技巧提炼
1. **排序处理**：按初始行号降序排序，确保处理顺序不影响结果。
2. **线段树维护区间极值**：根据需求选择维护最小值或最大值，支持区间查询与赋值。
3. **懒标记优化**：高效处理区间更新，避免重复操作。

---

## 类似题目推荐
1. **P1253 扶苏的问题**（区间赋值与区间极值查询）
2. **P4093 [HEOI2016/TJOI2016] 序列**（CDQ分治与动态规划）
3. **P5490 扫描线**（区间覆盖与线段树应用）

---

## 可视化设计
### 核心算法演示
1. **Canvas动画**：绘制网格，横条按行号从高到低依次下落。
2. **颜色标记**：
   - **绿色**：当前处理的横条覆盖区间。
   - **红色**：线段树查询的区间最小值位置。
3. **步进控制**：手动控制每一步，观察线段树更新过程。

### 复古像素风格
- **8位调色板**：横条用不同颜色表示，网格线用灰色。
- **音效**：
  - **下落音效**：横条放置时播放短促“滴”声。
  - **更新音效**：线段树区间更新时播放“咔嗒”声。

---

## 核心代码实现
```cpp
// 线段树模板（维护区间最小值，支持区间赋值）
struct SegTree {
    struct Node { int l, r, min_val, tag; } tr[N << 2];
    void push_up(int k) { 
        tr[k].min_val = min(tr[k<<1].min_val, tr[k<<1|1].min_val); 
    }
    void push_down(int k) {
        if (tr[k].tag) {
            tr[k<<1].min_val = tr[k].tag;
            tr[k<<1|1].min_val = tr[k].tag;
            tr[k<<1].tag = tr[k].tag;
            tr[k<<1|1].tag = tr[k].tag;
            tr[k].tag = 0;
        }
    }
    void build(int k, int l, int r) {
        tr[k].l = l, tr[k].r = r, tr[k].tag = 0;
        if (l == r) { tr[k].min_val = H + 1; return; }
        int mid = (l + r) >> 1;
        build(k<<1, l, mid);
        build(k<<1|1, mid+1, r);
        push_up(k);
    }
    void update(int k, int L, int R, int val) {
        if (tr[k].l > R || tr[k].r < L) return;
        if (L <= tr[k].l && tr[k].r <= R) {
            tr[k].min_val = val;
            tr[k].tag = val;
            return;
        }
        push_down(k);
        update(k<<1, L, R, val);
        update(k<<1|1, L, R, val);
        push_up(k);
    }
    int query(int k, int L, int R) {
        if (tr[k].l > R || tr[k].r < L) return INF;
        if (L <= tr[k].l && tr[k].r <= R) return tr[k].min_val;
        push_down(k);
        return min(query(k<<1, L, R), query(k<<1|1, L, R));
    }
};
```

---
处理用时：89.76秒
# 题目信息

# [ABC385D] Santa Claus 2

## 题目描述

在二次元平面上有 $N$ 个点 $(X_1,Y_1),\ldots,(X_N,Y_N)$ 建有房子。

最初，圣诞老人在点 $(S_x,S_y)$。圣诞老人将按照序列 $(D_1,C_1),\ldots,(D_M,C_M)$ 进行以下行动：

- 对于 $i=1,2,\ldots,M$，按顺序进行以下移动：
  - 设 $(x,y)$ 为他当前所在的点。
      - 如果 $D_i$ 是 `U`，则从 $(x,y)$ 沿直线移动到 $(x,y+C_i)$。
      - 如果 $D_i$ 是 `D`，则从 $(x,y)$ 沿直线移动到 $(x,y-C_i)$。
      - 如果 $D_i$ 是 `L`，则从 $(x,y)$ 沿直线移动到 $(x-C_i,y)$。
      - 如果 $D_i$ 是 `R`，则从 $(x,y)$ 沿直线移动到 $(x+C_i,y)$。

请找出他完成所有行动后所在的点，以及他在行动过程中经过或到达的不同房子的数量。如果多次经过同一个房子，只计数一次。

## 说明/提示

- $1 \leq N \leq 2\times 10^5$
- $1 \leq M \leq 2\times 10^5$
- $-10^9 \leq X_i,Y_i \leq 10^9$
- $(X_i,Y_i)$ 互不相同
- $-10^9 \leq S_x,S_y \leq 10^9$
- 点 $(S_x,S_y)$ 没有房子
- 每个 $D_i$ 是 `U`、`D`、`L`、`R` 之一
- $1 \leq C_i \leq 10^9$
- 所有给定数字均为整数

**【样例 #1 解释】**

圣诞老人的行动如下图所示：

![](https://img.atcoder.jp/abc385/f3d0f313d3b20c135af60ca6eb04900d.png)

- $D_1=$ `L`，所以他从 $(3,2)$ 直线移动到 $(3-2,2)$。在此期间，他经过 $(2,2)$ 处的房子。
- $D_2=$ `D`，所以他从 $(1,2)$ 直线移动到 $(1,2-1)$。
- $D_3=$ `R`，所以他从 $(1,1)$ 直线移动到 $(1+1,1)$。在此期间，他经过 $(2,1)$ 处的房子。
- $D_4=$ `U`，所以他从 $(2,1)$ 直线移动到 $(2,1+2)$。在此期间，他经过 $(2,2)$ 处的房子，但该房子已经被经过。

他在行动期间经过或到达的房子数量为 $2$。

**【样例 #2 解释】**

小心溢出。

## 样例 #1

### 输入

```
3 4 3 2
2 2
3 3
2 1
L 2
D 1
R 1
U 2```

### 输出

```
2 3 2```

## 样例 #2

### 输入

```
1 3 0 0
1 1
R 1000000000
R 1000000000
R 1000000000```

### 输出

```
3000000000 0 0```

# AI分析结果



**唯一算法分类**：无算法分类（基于数据结构的高效查询与维护）

---

### **题解思路与核心难点**

1. **问题核心**  
   圣诞老人沿坐标轴移动，需统计移动路径覆盖的房屋数量。难点在于高效处理大范围坐标（至±1e9）及避免重复计数。

2. **题解对比与要点**  
   - **Drifty (map+set)**  
     - **核心思路**：使用两个 `map<int, set<int>>` 存储每个x坐标对应的y集合和每个y对应的x集合。每次移动时，根据方向在对应轴上二分查找覆盖的区间，删除已访问的点。  
     - **关键优化**：删除操作实时进行，避免重复统计，时间复杂度为 O((m+n) log n)。  
     - **解决难点**：利用STL的自动排序和高效二分，直接操作区间内的点。  
   - **The_foolishest_OIer (线段树+二分)**  
     - **核心思路**：对每个方向分别进行多次二分确定覆盖区间，用线段树标记访问过的点。  
     - **关键问题**：代码复杂度高，线段树维护需处理两套结构，且二分次数过多。  
   - **hanhoudedidue (扫描线+容斥)**  
     - **核心思路**：将路径转换为矩形区域，用扫描线计算覆盖面积，结合容斥求答案。  
     - **关键问题**：离散化和大范围区域合并可能导致效率不足。  

3. **结论**  
   Drifty的解法最优：利用STL的快速查询和删除，代码简洁且高效。其他解法或复杂度高（线段树）或实现难度大（扫描线），而map+set的解法直接针对问题特性设计，实践性最强。

---

### **题解评分 (≥4星)**

1. **Drifty (5星)**  
   - **亮点**：代码简洁，利用STL高效处理区间删除，逻辑清晰，时间复杂度优秀。  
   - **引用**：“每个点只会被删一次，时间复杂度 O((m + n) log n)”。

2. **wangyizhi (4星)**  
   - **亮点**：类似Drifty的map+set思路，但使用差分数组优化标记，代码更易扩展。  
   - **不足**：需处理数组大小问题，实现稍复杂。

3. **Ivan422 (4星)**  
   - **亮点**：详细分析排序策略，强调删除操作的正确性，适合教学。  
   - **引用**：“每一个点也只会标记一次，不会出现重复标记”。

---

### **最优思路提炼**

1. **数据结构选择**  
   使用 `map<int, set<int>>` 分别按x和y轴存储坐标点，确保快速查询和删除。

2. **移动处理逻辑**  
   - **垂直移动（U/D）**：在x对应的y集合中查找区间 `[y_old, y_new]`，删除并统计。  
   - **水平移动（L/R）**：在y对应的x集合中查找区间 `[x_old, x_new]`，删除并统计。  

3. **删除与去重**  
   删除操作实时执行，确保每个点仅被处理一次，避免重复计数。

---

### **相似题目推荐**

1. **洛谷 P1904 天际线**（扫描线处理矩形覆盖）  
2. **洛谷 P5490 矩形面积并**（离散化+线段树）  
3. **洛谷 P3740 覆盖墙壁**（坐标区间覆盖与统计）

---

### **可视化设计**

1. **算法演示**  
   - **Canvas 网格**：绘制平面坐标系，圣诞老人初始位置高亮为红色。  
   - **移动动画**：每次移动时，沿方向绘制线段（如蓝色箭头），覆盖的房屋点变为绿色并消失。  
   - **数据结构同步**：右侧面板显示两个 `map<int, set<int>>` 的实时状态，删除操作时对应点闪烁后消失。  

2. **复古像素风格**  
   - **颜色方案**：使用 8-bit 色调（红、蓝、绿、黄），圣诞老人为像素小人，房屋为小方块。  
   - **音效**：移动时播放“滴”声，删除房屋时播放“咔嚓”声，背景音乐为复古芯片音乐。  

3. **交互控制**  
   - **步进控制**：支持暂停/继续/单步，速度可调（1x~5x）。  
   - **自动演示**：AI自动执行移动，展示路径覆盖过程。

---

### **核心代码片段（Drifty解法）**

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using Map = map<int, set<int>>;
vector<int> temp; Map mpx, mpy;
int n, m; i64 x, y, c, ans;

void work(i64 x, i64 y, i64 u, i64 v, Map &i, Map &j) {
    if (!i.count(x) || i[x].empty()) return;
    temp.clear();
    auto bg = i[x].lower_bound(y + u), ed = i[x].upper_bound(y + v);
    for (auto it = bg; it != ed; ++it) {
        ans++;
        temp.push_back(*it);
        j[*it].erase(x); // 删除另一轴的记录
    }
    for (auto p : temp) i[x].erase(p); // 删除当前轴的记录
}

int main() {
    cin >> n >> m >> x >> y;
    for (int i = 1, u, v; i <= n; i++) {
        cin >> u >> v;
        mpx[u].insert(v);
        mpy[v].insert(u);
    }
    for (int i = 1; i <= m; i++) {
        char op; cin >> op >> c;
        if (op == 'U') work(x, y, 0, c, mpx, mpy), y += c;
        if (op == 'D') work(x, y, -c, 0, mpx, mpy), y -= c;
        if (op == 'L') work(y, x, -c, 0, mpy, mpx), x -= c;
        if (op == 'R') work(y, x, 0, c, mpy, mpx), x += c;
    }
    cout << x << ' ' << y << ' ' << ans << endl;
}
```

**核心逻辑**：  
- `work` 函数处理移动中的点删除：根据方向确定坐标轴，二分查找区间并删除点。  
- 维护两个map结构确保双向删除，避免重复计数。

---
处理用时：83.25秒
# 题目信息

# [ABC151E] Max-Min Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc151/tasks/abc151_e

有限個の整数からなる集合 $ X $ に対し $ f(X)=\max\ X\ -\ \min\ X $ と定義します。

$ N $ 個の整数 $ A_1,...,A_N $ が与えられます。

このうち $ K $ 個を選び、それらからなる集合を $ S $ とします。同じ値であっても添字が異なる要素を区別すると、そのような選び方は $ {}_N\ C_K $ 通りありますが、その全てについての $ f(S) $ の合計を求めてください。

答えは非常に大きくなる可能性があるので、$ \bmod\ 10^9+7 $ で出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

$ S $ の選び方は $ \{1,1\},\{1,3\},\{1,4\},\{1,3\},\{1,4\},\{3,4\} $ の $ 6 $ 通りあり (ふたつの $ 1 $ は区別します)、$ f(S) $ はそれぞれ $ 0,2,3,2,3,1 $ となるので、合計は $ 11 $ です。

### Sample Explanation 2

$ S $ の選び方は $ 20 $ 通りあり、そのうち $ 18 $ 通りで $ f(S)=20 $、$ 2 $ 通りで $ f(S)=0 $ となります。

### Sample Explanation 4

合計は $ \bmod\ 10^9+7 $ で出力してください。

## 样例 #1

### 输入

```
4 2

1 1 3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
6 3

10 10 10 -10 -10 -10```

### 输出

```
360```

## 样例 #3

### 输入

```
3 1

1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 6

1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0```

### 输出

```
999998537```

# AI分析结果



# 算法分类
组合数学

---

## 题解思路与算法分析

### 核心思路
**贡献拆分法**：将每个元素作为最大值和最小值的贡献分别计算，最终总和为最大值贡献总和减去最小值贡献总和。核心步骤如下：
1. **排序数组**：将原数组升序排列，使每个元素的前后关系明确。
2. **计算组合数**：预处理阶乘与逆元，快速计算组合数 `C(n, k)`。
3. **贡献统计**：
   - **最大值贡献**：对于排序后第 `i` 个元素，其作为最大值的次数为 `C(i-1, k-1)`（前 `i-1` 个元素中选 `k-1` 个）。
   - **最小值贡献**：同理，次数为 `C(n-i, k-1)`（后 `n-i` 个元素中选 `k-1` 个）。
4. **总和计算**：累加所有最大值贡献并减去最小值贡献。

### 解决难点
1. **组合数高效计算**：通过预处理阶乘和逆元数组，将组合数计算复杂度降至 `O(1)`。
2. **边界条件处理**：确保 `i` 的循环范围正确（如最大值从 `k` 开始，最小值到 `n-k+1` 结束），避免无效计算。

---

## 题解评分（≥4星）

### 1. TonyYin（★★★★☆）
- **亮点**：代码结构清晰，注释明确，预处理阶乘和逆元逻辑严谨。循环范围正确处理边界，取模运算完整。
- **关键代码**：
  ```cpp
  for(int i = k; i <= n; i++) ans += a[i] * C(i-1, k-1);
  for(int i = 1; i <= n - k + 1; i++) ans -= a[i] * C(n-i, k-1);
  ```

### 2. _determination_（★★★★☆）
- **亮点**：代码简洁，分离最大值和最小值的计算，变量命名直观。预处理阶乘后直接用逆元函数，逻辑直接。
- **关键代码**：
  ```cpp
  for (int i = m; i <= n; i++) ans1 += C(i-1, m-1) * a[i];
  for (int i = 1; i <= n-m+1; i++) ans2 += C(n-i, m-1) * a[i];
  ```

### 3. WaterSun（★★★★☆）
- **亮点**：贡献计算与代码分离，可读性强。使用 `Add` 和 `Sub` 宏增强代码可维护性。
- **关键代码**：
  ```cpp
  for (re int i = 1; i <= n; i++) a = Add(a, Mul(C(n-i, k-2), arr[i]));
  for (re int i = 1; i <= n; i++) b = Add(b, Mul(C(i-1, k-1), arr[i]));
  ```

---

## 最优思路提炼

### 关键步骤
1. **排序数组**：确保元素的顺序关系。
2. **组合数预处理**：使用逆元快速计算模意义下的组合数。
3. **贡献拆分**：分别统计每个元素作为最大值和最小值的次数，避免重复计算。

### 实现技巧
- **逆元优化**：通过费马小定理预处理阶乘逆元，将组合数计算复杂度降至 `O(1)`。
- **循环边界控制**：最大值从 `k` 开始，最小值到 `n-k+1` 结束，确保组合数有效。

---

## 同类型题与拓展

### 类似算法套路
- **贡献拆分法**：用于统计每个元素对最终结果的独立贡献（如子数组极值、区间和等）。
- **组合数预处理**：在涉及 `C(n, k)` 的问题中，预处理阶乘和逆元是常见优化手段。

### 推荐题目
1. **洛谷 P1108**：低价购买（统计最长下降子序列的数量，组合思想）。
2. **洛谷 P4071**：排列计数（错位排列与组合数的综合应用）。
3. **AT ABC171F**：Strivore（字符串组合问题，需预处理组合数）。

---

## 可视化与算法演示

### 核心逻辑动画设计
1. **排序动画**：展示数组升序排列过程，元素依次移动到正确位置。
2. **贡献计算**：
   - **最大值贡献**：高亮当前元素，显示其前方可选的 `k-1` 个元素（用绿色方块表示）。
   - **最小值贡献**：高亮当前元素，显示其后方可选的 `k-1` 个元素（用红色方块表示）。
3. **组合数计算**：在动画中动态显示 `C(i-1, k-1)` 和 `C(n-i, k-1)` 的计算过程。

### 复古像素风格实现
- **颜色方案**：8位色调色板，绿色表示最大值贡献，红色表示最小值贡献。
- **音效设计**：
  - **选中元素**：播放短促的“哔”声。
  - **计算完成**：播放上扬的“通关”音效。
- **Canvas 动画**：用像素块表示数组元素，组合数计算时显示动态数值滚动。

---

## 代码实现（关键部分）

### 预处理与组合数计算
```cpp
int fac[MAXN], inv[MAXN];
void init() {
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = fac[i-1] * i % mod;
    inv[n] = power(fac[n], mod-2, mod);
    for (int i = n-1; i >= 0; i--) inv[i] = inv[i+1] * (i+1) % mod;
}
int C(int a, int b) {
    if (a < b) return 0;
    return fac[a] * inv[b] % mod * inv[a-b] % mod;
}
```

### 贡献统计
```cpp
sort(a + 1, a + n + 1);
int ans = 0;
for (int i = k; i <= n; i++) 
    ans = (ans + a[i] * C(i-1, k-1)) % mod;
for (int i = 1; i <= n-k+1; i++) 
    ans = (ans - a[i] * C(n-i, k-1) % mod + mod) % mod;
cout << ans << endl;
```

---

## 个人心得摘录
> “**边界处理是核心**：一定要确保循环的 `i` 范围正确，否则会计算无效的组合数导致错误。例如，当 `i < k` 时，`C(i-1, k-1)` 为 0，必须跳过。” —— 摘自某题解调试注释。

---
处理用时：102.12秒
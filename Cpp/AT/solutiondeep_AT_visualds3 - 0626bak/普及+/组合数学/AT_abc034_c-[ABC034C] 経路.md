# 题目信息

# [ABC034C] 経路

## 题目描述

有一个 $W$ 行 $H$ 列的网格图（$2 \leq W,H \leq 10^5$），其中第 $i$ 行第 $j$ 列的坐标为 $(i,j)$。

现在有一个人想从起点 $(1,1)$ 走到终点 $(W,H)$，已知他每次可以从网格 $(i,j)$ 走向 $(i+1,j)$ 或 $(i,j+1)$。现在请你求出，他从起点走到终点的路线个数为多少。

由于这个数可能很大，因此你只要输出路线个数对 $10^9 + 7$ 取模的结果即可。

## 样例 #1

### 输入

```
4 3```

### 输出

```
10```

## 样例 #2

### 输入

```
123 456```

### 输出

```
210368064```

# AI分析结果



### 唯一算法分类
组合数学

---

### 题解思路与算法要点
**核心思路**：路径总数等价于从总步数 $W+H-2$ 中选 $W-1$ 步向下走的组合数 $\dbinom{W+H-2}{W-1}$。

**关键步骤**：
1. **预处理阶乘与逆元**：  
   - 线性递推计算每个数的逆元 `inv[i] = (MOD - MOD/i) * inv[MOD%i] % MOD`
   - 递推阶乘 `fact[i]` 和阶乘逆元 `inv_fact[i] = inv_fact[i-1] * inv[i] % MOD`

**解决难点**：  
- 除法取模需借助逆元，通过预处理将组合数计算转化为乘法，时间复杂度 $O(1)$。

---

### 题解评分（≥4星）
1. **残阳如血（★★★★★）**  
   - 思路清晰，代码结构简洁  
   - 线性递推逆元，效率最优  
   - 预处理数组命名规范，可读性强  

2. **jzjr（★★★★☆）**  
   - 使用费马小定理求逆元，代码稍显冗长  
   - 预处理阶乘逆元时倒序计算，优化空间利用  

3. **zjinze（★★★★☆）**  
   - 快速幂实现逆元，逻辑明确  
   - 预处理阶乘后即时计算逆元，减少内存占用  

---

### 最优思路提炼
1. **逆元预处理**：通过递推公式 $inv[i] = (MOD - MOD/i) \cdot inv[MOD\%i] \ \% \ MOD$ 在 $O(n)$ 时间内完成逆元计算。
2. **组合数公式**：$\dbinom{n}{k} = \text{fact}[n] \cdot \text{inv\_fact}[k] \cdot \text{inv\_fact}[n-k] \ \% \ MOD$，避免直接除法。

---

### 同类型题与算法套路
- **通用解法**：组合数取模问题均可通过预处理阶乘与逆元解决。
- **类似题目**：  
  - [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)  
  - [P1772 [ZJOI2006] 物流运输](https://www.luogu.com.cn/problem/P1772)  
  - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)

---

### 个人心得摘录
- **逆元初始化**：需特别注意 `inv[1] = 1`，否则后续递推错误。
- **数组大小**：预处理数组应覆盖最大可能的 $W+H$ 值（如 $2 \times 10^5$）。

---

### 可视化算法演示
**动画设计**：  
1. **网格路径绘制**：在 Canvas 上绘制网格，动态展示路径选择过程。
2. **组合数计算**：高亮当前阶乘与逆元计算步骤，同步显示公式 $\dbinom{n}{k}$。
3. **像素风格**：  
   - **颜色标记**：红色表示当前阶乘项，蓝色表示逆元项。  
   - **音效触发**：每完成一次阶乘或逆元计算时播放 8-bit 音效。

**交互功能**：  
- **步进控制**：允许单步执行预处理和组合数计算。
- **自动演示**：以贪吃蛇式路径自动遍历网格，展示不同路径选择。

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;
const int MAX_N = 2e5 + 10;

long long inv[MAX_N], fact[MAX_N], inv_fact[MAX_N];

void init() {
    inv[1] = 1;
    for (int i = 2; i < MAX_N; i++) 
        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
    fact[0] = inv_fact[0] = 1;
    for (int i = 1; i < MAX_N; i++) {
        fact[i] = fact[i-1] * i % MOD;
        inv_fact[i] = inv_fact[i-1] * inv[i] % MOD;
    }
}

long long comb(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
}

int main() {
    init();
    int W, H;
    cin >> W >> H;
    cout << comb(W + H - 2, W - 1) << endl;
    return 0;
}
```

**代码说明**：  
- `init()` 预处理逆元和阶乘，`comb()` 计算组合数。  
- 预处理范围 `MAX_N` 设为 $2 \times 10^5 + 10$ 覆盖题目最大输入。

---
处理用时：119.38秒
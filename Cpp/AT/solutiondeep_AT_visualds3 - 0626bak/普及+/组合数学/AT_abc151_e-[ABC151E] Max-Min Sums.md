# 题目信息

# [ABC151E] Max-Min Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc151/tasks/abc151_e

有限個の整数からなる集合 $ X $ に対し $ f(X)=\max\ X\ -\ \min\ X $ と定義します。

$ N $ 個の整数 $ A_1,...,A_N $ が与えられます。

このうち $ K $ 個を選び、それらからなる集合を $ S $ とします。同じ値であっても添字が異なる要素を区別すると、そのような選び方は $ {}_N\ C_K $ 通りありますが、その全てについての $ f(S) $ の合計を求めてください。

答えは非常に大きくなる可能性があるので、$ \bmod\ 10^9+7 $ で出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

$ S $ の選び方は $ \{1,1\},\{1,3\},\{1,4\},\{1,3\},\{1,4\},\{3,4\} $ の $ 6 $ 通りあり (ふたつの $ 1 $ は区別します)、$ f(S) $ はそれぞれ $ 0,2,3,2,3,1 $ となるので、合計は $ 11 $ です。

### Sample Explanation 2

$ S $ の選び方は $ 20 $ 通りあり、そのうち $ 18 $ 通りで $ f(S)=20 $、$ 2 $ 通りで $ f(S)=0 $ となります。

### Sample Explanation 4

合計は $ \bmod\ 10^9+7 $ で出力してください。

## 样例 #1

### 输入

```
4 2

1 1 3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
6 3

10 10 10 -10 -10 -10```

### 输出

```
360```

## 样例 #3

### 输入

```
3 1

1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 6

1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0```

### 输出

```
999998537```

# AI分析结果



# ABC151E Max-Min Sums 题解分析

---

## 唯一算法分类
**组合数学**

---

## 题解思路与解决难点

### 核心算法流程
1. **排序数组**：将给定数组升序排序以简化极值统计。
2. **组合数预处理**：通过逆元法预先计算组合数，支持快速查询 C(n,k)。
3. **贡献分离计算**：
   - **最大值贡献**：对每个元素 a[i]（i≥k），其作为最大值的子集数量为 C(i-1, k-1)，累加 a[i]*C(i-1,k-1)。
   - **最小值贡献**：对每个元素 a[i]（i≤n-k+1），其作为最小值的子集数量为 C(n-i, k-1)，累减 a[i]*C(n-i,k-1)。
4. **取模处理**：最终结果对 1e9+7 取模，避免溢出。

### 解决难点
- **暴力枚举不可行**：直接枚举所有子集复杂度为 O(C(n,k))，无法处理 n=1e5。
- **贡献推导**：通过排序后数学推导，将极值贡献转换为组合数计算，时间复杂度优化至 O(n log n + n)。
- **组合数快速计算**：使用逆元预处理阶乘，实现 O(1) 查询组合数。

---

## 高星题解推荐 (≥4星)

### 1. TonyYin（⭐⭐⭐⭐⭐）
- **亮点**：详细推导极值贡献公式，代码结构清晰，注释完整。
- **代码片段**：
  ```cpp
  for(int i = k; i <= n; i++) // 最大值贡献
      ans = (ans + a[i] * C(i-1, k-1)) % mod;
  for(int i = 1; i <= n - k + 1; i++) // 最小值贡献
      ans = (ans - a[i] * C(n-i, k-1)) % mod;
  ```

### 2. _determination_（⭐⭐⭐⭐）
- **亮点**：代码简洁，组合数计算与贡献分离处理高效。
- **代码片段**：
  ```cpp
  for (int i = m; i <= n; i++) ans1 += C(i-1,m-1) * a[i];
  for (int i = 1; i <= n-m+1; i++) ans2 += C(n-i,m-1) * a[i];
  ```

### 3. WaterSun（⭐⭐⭐⭐）
- **亮点**：使用逆元优化组合数计算，变量命名清晰。
- **代码片段**：
  ```cpp
  int C(int n, int m) {
      return fac[n] * inv(fac[m]) % mod * inv(fac[n-m]) % mod;
  }
  ```

---

## 最优技巧提炼

### 关键思路
- **排序后统计贡献**：排序后极值仅与位置相关，数学推导简化计算。
- **组合数分解**：将极值出现次数转化为组合数问题，避免枚举子集。

### 实现优化
- **逆元预处理**：O(n) 预处理阶乘和逆元，支持 O(1) 组合数查询。
- **贡献分离计算**：分别统计最大/最小值贡献，避免重复计算。

---

## 同类型题与推荐题目

### 类似算法套路
- **元素贡献法**：如统计子数组极值之和、逆序对计数等。
- **组合数学优化**：如快速计算排列组合相关问题（P3811、P2513）。

### 推荐题目
1. **P3811 【模板】乘法逆元**  
   （组合数预处理基础题）
2. **P2513 [HAOI2009] 逆序对数列**  
   （统计贡献与动态规划结合）
3. **CF1433F Zero Remainder Sum**  
   （极值统计与组合优化）

---

## 可视化与算法演示设计

### 核心动画流程
1. **排序可视化**：展示数组升序排序过程，元素动态排列。
2. **极值贡献高亮**：
   - **最大值**：元素标记为红色，显示其左侧可选元素区域（绿色框），动态绘制组合数计算路径。
   - **最小值**：元素标记为蓝色，显示其右侧可选元素区域（黄色框），同步更新组合数。
3. **贡献累加效果**：右侧面板实时显示当前总和，数值随动画步骤增长。

### 复古像素风格实现
- **颜色方案**：红（#FF0000）、蓝（#0000FF）、绿（#00FF00）像素块表示元素状态。
- **Canvas 绘制**：
  ```javascript
  function drawElement(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x*20, y*20, 18, 18); // 20x20 像素块，2像素间隔
  }
  ```
- **音效设计**：
  - **组合数计算**：8-bit "beep" 音效（频率 800Hz，时长 50ms）。
  - **贡献累加**：金币音效（上扬音调，频率 1200Hz→2000Hz）。

### 交互功能
- **步进控制**：支持暂停/继续、单步执行，速度调节（1x/2x/5x）。
- **AI 自动模式**：自动播放算法流程，高亮当前操作元素与组合数区域。

---

## 代码实现（核心逻辑）

### 组合数预处理与计算
```cpp
const int MOD = 1e9+7;
int fac[MAXN], inv[MAXN];

void init() {
    fac[0] = 1;
    for (int i=1; i<=n; i++) fac[i] = fac[i-1] * i % MOD;
    inv[n] = power(fac[n], MOD-2, MOD);
    for (int i=n-1; i>=0; i--) inv[i] = inv[i+1] * (i+1) % MOD;
}

int C(int a, int b) {
    if (a < b) return 0;
    return fac[a] * inv[b] % MOD * inv[a-b] % MOD;
}
```

### 主计算逻辑
```cpp
sort(a+1, a+n+1);
long long ans = 0;
for (int i=k; i<=n; i++)
    ans = (ans + a[i] * C(i-1, k-1)) % MOD;
for (int i=1; i<=n-k+1; i++)
    ans = (ans - a[i] * C(n-i, k-1) % MOD + MOD) % MOD;
cout << ans << endl;
```

---

通过上述分析，本题的核心在于巧妙利用排序与组合数学，将极值贡献高效分离计算。可视化设计通过动态展示元素贡献区域与组合数计算，可帮助理解算法核心思想。

---
处理用时：102.54秒
# 题目信息

# [ARC145C] Split and Maximize

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc145/tasks/arc145_c

$ (1,2,\ldots,2N) $ の順列 $ P=(P_1,P_2,\ldots,P_{2N}) $ に対し、スコアを以下で定義します。

> $ P $ を順序を保ったまま二つの長さ $ N $ の（連続するとは限らない）部分列 $ A\ =\ (A_1,A_2,\ldots,A_N),B\ =\ (B_1,B_2,\ldots,B_N) $ に分割する。分割を行ったときに得られる $ \displaystyle\sum_{i=1}^{N}A_i\ B_i $ の最大値をスコアとする。

$ (1,2,\ldots,2N) $ の順列全てについてスコアを計算し、それらの最大値を $ M $ とします。 $ (1,2,\ldots,2N) $ の順列のうち、スコアが $ M $ であるものの個数を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- 入力は全て整数

### Sample Explanation 1

考えられる順列 $ 24 $ 通りの中で、スコアの最大値 $ M $ は $ 14 $ です。スコアが $ 14 $ となる順列は $ 16 $ 通りあります。 例えば、順列 $ (1,2,3,4) $ は $ A=(1,3),\ B=(2,4) $ と分割することで、$ \sum\ _{i=1}^{N}A_i\ B_i\ =\ 14 $ となります。

### Sample Explanation 2

$ 998244353 $ で割ったあまりを答えてください。

## 样例 #1

### 输入

```
2```

### 输出

```
16```

## 样例 #2

### 输入

```
10000```

### 输出

```
391163238```

# AI分析结果



---

**唯一算法分类**  
组合数学

---

**综合分析与结论**  
本题核心在于将排列问题转化为组合数学模型，结合卡特兰数、阶乘与快速幂求解。关键思路如下：  
1. **配对策略**：最优解要求每对元素差为1，即相邻配对（如2i与2i-1），最大化乘积和。  
2. **排列组合**：  
   - 每对内部可交换顺序，贡献2^n种可能。  
   - 不同对的顺序可全排列，贡献n!种可能。  
3. **合法序列条件**：每对元素在排列中的出现顺序需满足任意前缀中左括号（先出现元素）数量≥右括号（后出现元素），转化为卡特兰数问题。  

**可视化设计思路**：  
- **动画流程**：  
  1. 将每对元素标记为左/右括号（如红蓝像素块），动态展示排列生成过程。  
  2. 实时统计左右括号数量差，背景色随差值变化（绿→安全，红→非法）。  
  3. 步进时高亮当前元素，触发音效（合法→清脆音，非法→警示音）。  
- **复古风格**：  
  - 使用8位像素风格网格，每格代表一个元素位置。  
  - 自动模式模拟AI生成合法排列，积分随成功步数增加。  

---

**题解清单 (≥4星)**  
1. **liangbowen (5星)**：逻辑清晰，代码简洁，详细证明配对最优性。  
2. **hhhqx (4星)**：感性解释转化思路，代码可读性强。  
3. **liyixin0514 (4星)**：直接推导卡特兰数公式，代码简练。  

---

**核心代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353, N = 4e5 + 5;
typedef long long LL;

LL fac[N], inv[N];

LL qpow(LL a, LL b) {
    LL res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void init() {
    fac[0] = 1;
    for (int i = 1; i < N; i++) fac[i] = fac[i-1] * i % mod;
    inv[N-1] = qpow(fac[N-1], mod-2);
    for (int i = N-2; i >= 0; i--) inv[i] = inv[i+1] * (i+1) % mod;
}

LL catalan(int n) {
    return (fac[2*n] * inv[n] % mod) * inv[n+1] % mod;
}

int main() {
    init();
    int n; cin >> n;
    LL ans = qpow(2, n) * fac[n] % mod;
    ans = ans * catalan(n) % mod;
    cout << ans << endl;
    return 0;
}
```

---

**同类型题推荐**  
1. [P3200 HNOI2009] 有趣的数列  
2. [P1044 NOIP2003] 栈  
3. [P1641 SCOI2010] 生成字符串  

---

**可视化演示设计**  
- **Canvas动画**：  
  - **元素标记**：每对元素显示为左/右括号，颜色区分。  
  - **动态路径**：合法路径显示绿色轨迹，非法路径变红闪烁。  
- **音效交互**：  
  - 合法添加元素时播放上升音调，非法时短促警告音。  
  - 完成序列后播放胜利音乐，积分显示在复古LED面板。  
- **自动模式**：模拟合法排列生成，速度可调，辅助理解卡特兰数增长规律。  

---

**关键公式与复杂度**  
总时间复杂度：O(N) 预处理阶乘与逆元，O(1) 查询。  
核心公式：答案 = 2^n × n! × (C(2n, n) / (n+1)) mod 998244353

---
处理用时：104.46秒
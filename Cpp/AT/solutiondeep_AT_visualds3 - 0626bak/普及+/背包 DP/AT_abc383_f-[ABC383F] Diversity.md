# 题目信息

# [ABC383F] Diversity

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc383/tasks/abc383_f

店で $ N $ 個の商品が売られています。 $ i $ 個目の商品の価格は $ P_i $ 円、効用は $ U_i $ 、色は $ C_i $ です。

あなたは、これらの $ N $ 個の商品から何個か( $ 0 $ 個でもよい)を選んで購入します。 このとき、購入した品物の合計価格は $ X $ 円以下でなければなりません。

あなたの満足度は、購入した商品の効用の合計を $ S $、購入した商品の色の種類数を $ T $ としたとき、$ S+T\ \times\ K $ です。 ここで、$ K $ は入力で与えられる定数です。

あなたの満足度を最大化するように購入する商品を選んだとき、満足度を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ X\ \leq\ 50000 $
- $ 1\ \leq\ K\ \leq\ 10^9 $
- $ 1\ \leq\ P_i\ \leq\ X $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ U_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ C_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N) $
- 入力は全て整数
 
### Sample Explanation 1

$ 1 $ 個目、$ 2 $ 個目の商品を購入したとき、効用の合計 $ S $ は $ 7 $ で、色の種類数 $ T $ は $ 2 $ です。よって、満足度は $ 7+2\ \times\ 5\ =\ 17 $ です。また、満足度が $ 18 $ 以上になるような購入の仕方は存在しないため、答えは $ 17 $ です。

### Sample Explanation 2

$ 2 $ 個目、$ 3 $ 個目、$ 4 $ 個目の商品を購入したとき、効用の合計 $ S $ は $ 35 $ で、色の種類数 $ T $ は $ 3 $ です。よって、満足度は $ 35+3\ \times\ 3\ =\ 44 $ です。また、満足度が $ 45 $ 以上になるような購入の仕方は存在しないため、答えは $ 44 $ です。

## 样例 #1

### 输入

```
3 10 5

1 3 1

7 4 2

4 5 1```

### 输出

```
17```

## 样例 #2

### 输入

```
5 30 3

5 4 3

11 20 1

9 10 4

7 5 2

16 15 4```

### 输出

```
44```

## 样例 #3

### 输入

```
22 75 6426

9 309 9

5 470 5

17 481 12

27 352 14

1 191 18

7 353 20

9 99 15

20 401 17

46 434 19

11 459 22

10 317 19

15 440 18

17 438 19

25 461 22

5 320 22

1 476 21

11 315 3

8 112 9

11 438 13

19 362 8

10 422 13

10 152 21```

### 输出

```
67717```

# AI分析结果



# 算法分类
动态规划（分组背包）

---

## 题解思路与核心难点

### 核心思路
1. **颜色分组**：将物品按颜色分类，保证相同颜色的物品连续处理
2. **分组背包变形**：对每个颜色组内的物品进行两种转移：
   - **首次选择该颜色**：从前一颜色组的DP值转移，并附加K收益
   - **非首次选择**：从当前颜色组的DP值转移，不加K收益
3. **滚动数组优化**：通过倒序遍历金额维度，实现空间复杂度优化

### 解决难点
1. **颜色计数处理**：通过颜色分组和分层转移，确保每个颜色贡献的K值仅计算一次
2. **状态转移设计**：
   - 维护两个状态数组：`f`（当前颜色组）、`g`（前一颜色组）
   - 每次颜色变化时，用`g`记录全局最大值
3. **时间复杂度控制**：通过分组和倒序处理，将复杂度优化至O(NX)

---

## 题解评分（≥4星）

1. **gesong（★★★★☆）**  
   - 亮点：清晰的二维DP结构，分组背包经典实现
   - 代码可读性：使用vector存储颜色分组，倒序转移逻辑简洁
   - 优化点：通过`max(a, max(b, c))`实现多条件转移

2. **wangyizhi（★★★★☆）**  
   - 亮点：双状态（选/未选当前颜色）的滚动数组设计
   - 代码技巧：通过`max({...})`实现多条件比较
   - 空间优化：仅使用两个一维数组实现状态压缩

3. **mayike（★★★★☆）**  
   - 亮点：使用全局数组`f`和临时数组`g`实现滚动逻辑
   - 思维角度：在颜色变化时统一更新全局最大值
   - 代码简洁性：通过`if(c_i≠c_{i+1})`判断颜色边界

---

## 最优思路与代码实现

### 关键代码（gesong版核心逻辑）
```cpp
vector<pair<int,int>> a[N]; // 按颜色分组存储物品
memset(f, 0xcf, sizeof f);  // 初始化为极小值
f[0][0] = 0;                // 初始状态

for (int i = 1; i <= n; i++) {
    // 继承前一颜色组的状态
    for (int j = 0; j <= m; j++) 
        f[i][j] = f[i-1][j];
    
    // 处理当前颜色组的每个物品
    for (auto [p, u] : a[i]) {
        for (int j = m; j >= p; j--) {
            // 首次选该颜色：从前一颜色转移 + K
            int case1 = f[i-1][j-p] + u + K;
            // 非首次选：从当前颜色转移
            int case2 = f[i][j-p] + u;
            f[i][j] = max({f[i][j], case1, case2});
        }
    }
}
```

### 可视化设计要点
1. **动画流程**：
   - 左侧显示颜色分组（不同色块）
   - 右侧显示DP表（横轴为金额，纵轴为颜色）
   - 当前处理物品高亮，对应DP格渐变动画
2. **交互功能**：
   - 步进控制：单步执行颜色组处理
   - 颜色追踪：点击DP格显示转移路径
3. **8位风格**：
   - 使用16色调色板（如NES绿、灰蓝）
   - 音效：物品选中时播放8位"哔"声，颜色切换时播放低音鼓点

---

## 同类题目推荐
1. **P1064 金明的预算方案**  
   （分组背包经典问题，附件系统类似颜色分组）
   
2. **P1156 垃圾陷阱**  
   （时间维度与状态转移的复合DP）

3. **P2014 选课**  
   （树形分组背包，父子依赖关系处理）

---

## 核心算法演示
```javascript
// 伪代码：Canvas绘制DP表更新
function drawDP() {
  ctx.fillStyle = '#2C3E50'; // 背景色
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 绘制DP表
  for (let c = 0; c <= maxColor; c++) {
    for (let j = 0; j <= X; j++) {
      const val = dp[c][j];
      const color = lerpColor('#3498db', '#e74c3c', val/maxVal);
      ctx.fillStyle = color;
      ctx.fillRect(j*cellW, c*cellH, cellW-1, cellH-1);
    }
  }
  
  // 高亮当前处理颜色
  ctx.strokeStyle = '#f1c40f';
  ctx.strokeRect(0, currentColor*cellH, canvas.width, cellH);
}
```

---

## 个人心得摘录
> "赛时纠结于颜色计数，后来意识到K值只需在首次选颜色时附加，瞬间思路畅通。调试时发现忘记倒序遍历金额维度，导致物品重复选择，修正后AC。" —— 摘自某题解评论区

---

## 算法比较与总结
| 方法            | 时间复杂度 | 空间复杂度 | 核心思路                     |
|-----------------|------------|------------|------------------------------|
| 二维颜色分组DP  | O(NX)      | O(NX)      | 显式维护颜色维度             |
| 滚动数组双状态   | O(NX)      | O(X)       | 通过0/1状态压缩颜色选择信息  |
| 全局临时数组     | O(NX)      | O(X)       | 颜色切换时更新全局最优       |

**最优选择**：滚动数组法在空间效率和代码简洁性上表现最佳，推荐实际编码采用。

---
处理用时：109.99秒
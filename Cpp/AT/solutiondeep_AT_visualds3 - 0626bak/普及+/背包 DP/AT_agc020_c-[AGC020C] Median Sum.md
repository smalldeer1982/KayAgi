# 题目信息

# [AGC020C] Median Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc020/tasks/agc020_c

$ N $ 個の整数 $ A_1 $, $ A_2 $, ..., $ A_N $ が与えられます。

$ A $ のすべての空でない部分列について、それぞれの和を考えます。このような和は $ 2^N\ -\ 1 $ 個存在し、この個数は奇数です。

これらの和を昇順に並べたものを $ S_1 $, $ S_2 $, ..., $ S_{2^N\ -\ 1} $ とします。

これらの中央値、$ S_{2^{N-1}} $ を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2000 $
- $ 1\ \leq\ A_i\ \leq\ 2000 $
- 入力値はすべて整数である。

### Sample Explanation 1

この場合、$ S\ =\ (1,\ 1,\ 2,\ 2,\ 3,\ 3,\ 4) $ となり、中央値は $ S_4\ =\ 2 $ です。

### Sample Explanation 2

この場合、$ S\ =\ (58) $ となります。

## 样例 #1

### 输入

```
3

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
1

58```

### 输出

```
58```

# AI分析结果



### 唯一算法分类
动态规划（01背包优化） + 位运算（bitset）

---

### 题解思路、算法要点与解决难点

1. **核心思路**  
   利用子集和对称性：对于总和为 `sum` 的集合，若存在和为 `x` 的子集，则必然存在和为 `sum-x` 的子集。中位数必为第一个大于等于 `(sum+1)/2` 的子集和。

2. **算法实现**  
   - **动态规划优化**：用 `bitset` 记录所有可能的子集和。初始时 `bitset[0] = 1`，表示空集存在。
   - **位运算转移**：对每个数 `a[i]`，将当前 `bitset` 左移 `a[i]` 位（表示所有已有和加上 `a[i]`），并与原 `bitset` 取或运算。
   - **对称性剪枝**：从 `(sum+1)/2` 开始向上扫描，找到第一个存在的子集和。

3. **解决难点**  
   - **高效处理状态**：直接枚举子集和的时间复杂度为指数级，使用 `bitset` 将状态压缩为位操作，时间/空间复杂度优化至 `O(N*sum/32)`。
   - **数学对称性应用**：通过对称性证明中位数必在 `[sum/2, sum]` 范围内，避免遍历全部可能。

---

### 题解评分（≥4星）

1. **紫题（5星）**  
   - **亮点**：代码最简，注释清晰，直接点明对称性与 `bitset` 优化核心。
   - **代码片段**：  
     ```cpp
     f |= f << x; // 转移方程
     for (int i=(sum+1)/2; ...) // 对称性剪枝
     ```

2. **ezoixx130（4星）**  
   - **亮点**：数学推导详细，解释补集对称性对中位数的影响。
   - **代码片段**：  
     ```cpp
     for (int i=n; i>=1; --i) f |= f << a[i]; // 逆序处理元素
     ```

3. **华为2X（4星）**  
   - **亮点**：趣味性教学，通过反选补集直观解释对称性。
   - **代码片段**：  
     ```cpp
     f |= f << x; // "只可意会不可言传"的位运算
     ```

---

### 最优思路或技巧提炼

1. **对称性剪枝**  
   中位数必为第一个大于等于 `sum/2` 的子集和，避免遍历全部 `2^N` 种情况。

2. **bitset优化**  
   将动态规划状态压缩为位操作，左移表示新增子集和，或运算合并状态。

3. **空集处理技巧**  
   初始包含空集，最终结果不受影响，因非空子集和中位数位置与全子集对称性一致。

---

### 同类型题或类似算法套路

1. **子集和问题**：如判断能否组成特定和（[洛谷P2347](https://www.luogu.com.cn/problem/P2347)）。
2. **对称性剪枝**：如求最接近 `sum/2` 的分割（背包问题变种）。
3. **bitset优化DP**：常见于状态稀疏的计数/存在性问题。

---

### 推荐题目

1. **P2347 砝码称重**  
   （bitset优化子集和存在性判断）
2. **P2392 kkksc03考前临时抱佛脚**  
   （对称性剪枝 + 分组背包）
3. **P4141 消失之物**  
   （动态规划状态删除与恢复）

---

### 可视化与算法演示设计

1. **动画方案**  
   - **Canvas绘制bitset位图**：每个位用像素块表示，绿色表示存在，黑色表示不存在。
   - **元素处理高亮**：当前处理的数 `a[i]` 显示为红色，左移操作时动态展示位扩展。
   - **对称线标记**：在 `sum/2` 处画黄色虚线，直观显示剪枝起点。

2. **复古像素风格**  
   - **音效**：位翻转时播放 8-bit "哔"声，找到答案时播放通关音效。
   - **自动演示模式**：AI按顺序处理元素，显示位图变化，最终自动定位中位数。

3. **交互设计**  
   - **步进控制**：支持暂停/继续/单步，调整动画速度。
   - **参数输入**：允许用户自定义数组，实时展示算法过程。

---

### 代码片段（核心逻辑）

```cpp
#include <bits/stdc++.h>
using namespace std;

bitset<4000005> f; // 最大sum=2000*2000=4e6
int main() {
    int n, x, sum = 0;
    cin >> n;
    f[0] = 1; // 初始空集
    for (int i = 0; i < n; ++i) {
        cin >> x;
        f |= f << x; // 转移方程：添加当前数的所有新可能
        sum += x;
    }
    // 对称性剪枝，找第一个≥sum/2的值
    for (int i = (sum+1)/2; i <= sum; ++i)
        if (f[i]) {
            cout << i << endl;
            break;
        }
    return 0;
}
```

---
处理用时：231.43秒
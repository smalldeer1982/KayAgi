# 题目信息

# [ABC312F] Cans and Openers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc312/tasks/abc312_f

$ N $ 個の品物があります。  
 これらはそれぞれ、缶切りが不要な缶・缶切りが必要な缶・缶切りのいずれかです。  
 $ i $ 個目の品物は、整数の組 $ (T_i,\ X_i) $ により次のように表されます。

- $ T_i\ =\ 0 $ ならば、$ i $ 個目の品物は缶切りが不要な缶で、入手すると満足度 $ X_i $ を得る。
- $ T_i\ =\ 1 $ ならば、$ i $ 個目の品物は缶切りが必要な缶で、入手した上で缶切りを使うと満足度 $ X_i $ を得る。
- $ T_i\ =\ 2 $ ならば、$ i $ 個目の品物は缶切りで、$ X_i $ 個までの缶に対して使用できる。
 
$ N $ 個の品物から $ M $ 個を選んで入手するとき、得られる満足度の合計としてあり得る最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ T_i $ は $ 0,1,2 $ のいずれか
- $ 1\ \leq\ X_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ 1,\ 2,\ 5,\ 7 $ 個目の品物を入手し、$ 7 $ 個目の品物である缶切りを $ 5 $ 個目の品物に対して使用すると、満足度 $ 6\ +\ 6\ +\ 15\ =\ 27 $ を得ます。 満足度が $ 28 $ 以上になる品物の入手方法は存在しませんが、上記の例において $ 7 $ 個目の品物のかわりに $ 6 $ 個目の品物や $ 8 $ 個目の品物を選んでも満足度 $ 27 $ を得ることができます。

## 样例 #1

### 输入

```
8 4

0 6

0 6

1 3

1 5

1 15

2 1

2 10

2 100```

### 输出

```
27```

## 样例 #2

### 输入

```
5 5

1 5

1 5

1 5

1 5

1 5```

### 输出

```
0```

## 样例 #3

### 输入

```
12 6

2 2

0 1

0 9

1 3

1 5

1 3

0 4

2 1

1 8

2 1

0 1

0 4```

### 输出

```
30```

# AI分析结果



## 算法分类
**贪心、前缀和、二分查找**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **分类处理与排序**：将三种物品分别按价值降序排列，确保每次选取最优。
2. **前缀和预处理**：分别计算各类型物品的前缀和数组，快速计算任意前k个物品的总价值。
3. **枚举与二分结合**：枚举选择T=1（需要开罐器的罐头）的数量，通过二分查找确定所需最少开罐器数量，剩余名额选择T=0的罐头。

### 解决难点
- **依赖关系**：T=1罐头必须与开罐器配合使用。需确保所选开罐器的总开启次数≥T=1的数量。
- **高效计算**：通过二分查找在O(log n)时间内确定最小开罐器数量，避免暴力枚举。
- **边界处理**：剩余名额可能不足或超出数组范围，需取最小值保证合法。

---

## 题解评分（≥4星）
1. **Engulf（4.5星）**  
   - 思路清晰，预处理前缀和+二分查找实现高效。  
   - 代码结构简洁，边界处理完善（如剩余名额判断）。  
   - 时间复杂度O(n log n)，适合大数据量。

2. **Fire_flame（4星）**  
   - 类似思路，但通过lower_bound处理开罐器需求。  
   - 代码中变量命名清晰，注释较少但逻辑明确。  
   - 需要注意剩余名额的正负判断。

3. **Genius_Star（4星）**  
   - 使用枚举T=1数量+二分开罐器的方式。  
   - 处理前缀和时显式取min避免越界，关键注释提醒易错点。  
   - 代码可读性较好，适合理解贪心与二分的结合。

---

## 最优思路或技巧提炼
1. **降序排序与前缀和**：确保每次选取当前最优解，前缀和快速计算总和。
2. **枚举+二分**：对T=1的数量枚举，通过二分确定最少开罐器，剩余名额贪心选T=0。
3. **边界处理**：如剩余名额为负时跳过，或取min(a.size(), remain)避免越界。

---

## 同类型题或类似算法套路
- **多条件组合优化**：需同时考虑多个依赖条件（如资源限制、物品依赖），常用贪心+二分或动态规划。
- **前缀和+二分**：如背包问题中求特定容量的最优解，或区间资源分配问题。

---

## 推荐洛谷题目
1. **P1803 凌乱的yyy / 线段覆盖**（贪心+排序）  
2. **P2240 部分背包问题**（贪心选择单位价值最高）  
3. **P1090 合并果子**（优先队列维护贪心选择）

---

## 个人心得摘录
- **Neil_Qian**：未处理剩余名额超过T=0数组长度导致WA，强调边界检查的重要性。
- **WanderingTrader**：初始代码忘记减少剩余开启次数（rem--），但仍通过部分测试点，提醒需全面测试边界条件。

---

## 算法可视化设计
### 关键步骤动画演示
1. **初始化**：三种物品降序排列，前缀和数组生成。
2. **枚举T=1数量（j）**：  
   - 显示当前j值，对应T=1的前j个罐头。
3. **二分查找开罐器数量（t）**：  
   - 动态绘制开罐器前缀和曲线，标记二分查找的mid和结果t。
4. **计算剩余名额与T=0选取**：  
   - 高亮剩余名额（m-j-t），显示选取的T=0数量及总和。
5. **更新最大值**：对比历史最大值，标记当前是否刷新记录。

### 复古像素风格设计
- **颜色方案**：T=0（绿色方块）、T=1（红色方块）、开罐器（蓝色方块），总和显示为黄色数字。
- **音效**：选取物品时播放8-bit点击音，刷新最大值时播放上升音调。
- **自动演示**：按j递增顺序自动播放，支持暂停/步进观察二分细节。

---

## 核心代码实现（Engulf版）
```cpp
vector<int> a, b, c;
sort(a.begin(), a.end(), greater<>());
sort(b.begin(), b.end(), greater<>());
sort(c.begin(), c.end(), greater<>());

// 前缀和预处理
vector<long long> pre_a(a.size() + 1), pre_b(b.size() + 1), pre_c(c.size() + 1);
for (int i = 0; i < a.size(); i++) pre_a[i+1] = pre_a[i] + a[i];
for (int i = 0; i < b.size(); i++) pre_b[i+1] = pre_b[i] + b[i];
for (int i = 0; i < c.size(); i++) pre_c[i+1] = pre_c[i] + c[i];

long long ans = 0;
for (int j = 0; j <= b.size(); j++) {
    if (j == 0) {
        ans = max(ans, pre_a[min(m, (int)a.size())]);
        continue;
    }
    // 二分找最小的t使得pre_c[t] >= j
    auto it = lower_bound(pre_c.begin(), pre_c.end(), j);
    if (it == pre_c.end()) continue;
    int t = it - pre_c.begin();
    if (j + t > m) continue;
    int remain = m - j - t;
    ans = max(ans, pre_b[j] + pre_a[min(remain, (int)a.size())]);
}
cout << ans << endl;
```

---
处理用时：147.58秒
# 题目信息

# [ABC366F] Maximum Composition

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc366/tasks/abc366_f

$ N $ 個の一次関数 $ f_1,f_2,\ldots,f_N $ が与えられます。$ f_i(x)=A_i\ x+B_i $ です。

$ 1 $ 以上 $ N $ 以下の**相異なる** $ K $ 個の整数からなる長さ $ K $ の数列 $ p=(p_1,p_2,\ \ldots\ p_K) $ について、$ f_{p_1}(f_{p_2}(\ldots\ f_{p_K}(1)\ldots\ )) $ としてありえる最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^{5} $
- $ 1\ \leq\ K\ \leq\ \text{min}(N,10) $
- $ 1\ \leq\ A_i,B_i\ \leq\ 50 $ $ (1\ \leq\ i\ \leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

ありえるすべての $ p $ とそれに対応する $ f_{p_1}(f_{p_2}(1)) $ の値は以下の通りです。 - $ p=\ (\ 1,2\ ) $ : $ f_1(f_2(1))=15 $ - $ p=\ (\ 1,3\ ) $ : $ f_1(f_3(1))=15 $ - $ p=\ (\ 2,1\ ) $ : $ f_2(f_1(1))=10 $ - $ p=\ (\ 2,3\ ) $ : $ f_2(f_3(1))=11 $ - $ p=\ (\ 3,1\ ) $ : $ f_3(f_1(1))=22 $ - $ p=\ (\ 3,2\ ) $ : $ f_3(f_2(1))=26 $ よって、 $ 26 $ と出力します。

## 样例 #1

### 输入

```
3 2
2 3
1 5
4 2```

### 输出

```
26```

## 样例 #2

### 输入

```
10 3
48 40
34 22
24 37
45 40
48 31
49 44
45 40
44 6
35 22
39 28```

### 输出

```
216223```

# AI分析结果



## 算法分类
动态规划、排序

---

## 题解思路与算法要点

### 核心思路
1. **排序推导**：通过比较相邻两个函数的嵌套顺序，推导出排序条件：
   - 当且仅当 `A_i*B_j + B_i > A_j*B_i + B_j` 时，函数i应排在函数j之前
   - 等价于按 `(A_i-1)/B_i` 从大到小排序（需处理除零情况）

2. **动态规划**：
   - 状态定义：`dp[i][j]` 表示前i个排序后的函数中选择j个的最大值
   - 转移方程：`dp[i][j] = max(dp[i-1][j], A_i*dp[i-1][j-1]+B_i)`
   - 使用滚动数组优化空间复杂度至O(K)

### 解决难点
1. **排序条件推导**：通过数学推导将嵌套顺序比较转化为可排序的指标
2. **DP优化**：利用前缀最大值避免重复计算，将时间复杂度优化至O(NK)
3. **边界处理**：正确处理初始状态 `dp[0][0] = 1`（嵌套起点为1）

---

## 题解评分（≥4星）

1. **lzyqwq（5星）**
   - 完整推导排序条件，给出严格的数学证明
   - 代码简洁高效，时间复杂度O(NK + NlogN)
   - 提供深刻的问题理解与算法优化思路

2. **Sorato_（4.5星）**
   - 清晰的状态定义与转移方程
   - 使用滚动数组优化空间，代码可读性强
   - 附带详细的数学推导过程

3. **cancan123456（4星）**
   - 提供正统解法与人类智慧解法对比
   - 代码实现简洁，包含两种解法的实现
   - 对非正解方案进行可行性分析

---

## 最优思路提炼

**关键技巧**：
1. **邻项交换法**：通过比较相邻元素的最优排列顺序确定全局排序规则
2. **滚动数组优化**：将二维DP压缩为一维，空间复杂度从O(NK)优化至O(K)
3. **前缀最大值维护**：在排序后的序列上，每个位置只需考虑前缀最大值

**思维启示**：
- 当问题涉及元素顺序影响结果时，优先考虑能否通过排序转化为有序选择问题
- 对于K较小的选择问题，可尝试结合排序与动态规划的组合解法

---

## 相似题目推荐
1. P1776 宝物筛选（排序+多重背包）
2. P1081 [NOIP2012 提高组] 开车旅行（预处理+双向链表）
3. P2577 [ZJOI2005] 午餐（贪心排序+动态规划）

---

## 可视化设计

**动画方案**：
1. **排序过程**：用不同颜色标记正在比较的函数对，展示条件判断结果
2. **DP状态更新**：
   - 左侧显示排序后的函数序列（像素风格，按排序顺序排列）
   - 右侧显示二维DP表（滚动显示当前层与上一层）
   - 当前处理的函数高亮显示（黄色边框）
   - 状态转移时显示数值变化动画（绿色增长/红色不变）
3. **音效设计**：
   - 排序比较时播放"滴"声
   - DP状态更新时根据是否更新播放不同音调
   - 最终答案出现时播放8-bit胜利音效

**复古风格**：
```javascript
// 伪代码示例
class PixelAnimator {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.gridSize = 16; // 16x16像素单位
    this.palette = ['#000','#F00','#0F0','#00F','#FF0']; // 复古配色
  }
  
  drawFunction(func, x, y, color) {
    // 绘制函数方块，A/B值用不同颜色显示
  }
  
  drawDPCell(value, x, y, highlight) {
    // 绘制DP状态格子，高亮时添加闪烁效果
  }
}
```

---

## 核心代码实现

**正统解法（滚动数组优化）**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

struct Func { int a, b; };
vector<Func> funcs;

int main() {
    int n, k;
    cin >> n >> k;
    for(int i=0; i<n; ++i) {
        int a, b; cin >> a >> b;
        funcs.push_back({a, b});
    }
    
    sort(funcs.begin(), funcs.end(), [](const Func& x, const Func& y) {
        return (ll)x.b*(y.a-1) > (ll)y.b*(x.a-1);
    });
    
    vector<ll> dp(k+1, 0);
    dp[0] = 1;
    for(auto& f : funcs) 
        for(int j=k; j>=1; --j)
            if(dp[j-1] > 0)
                dp[j] = max(dp[j], f.a * dp[j-1] + f.b);
    
    cout << dp[k];
}
```

**关键点说明**：
1. 排序规则使用交叉相乘避免浮点误差
2. 逆序更新DP数组实现滚动优化
3. 初始状态dp[0] = 1对应嵌套起点

---

## 总结
本题通过邻项交换法确定最优排列顺序，结合动态规划实现高效求解。其核心在于将复杂嵌套问题转化为有序选择问题，并通过排序与动态规划的结合实现优化。可视化设计应重点展示排序过程与DP状态转移，帮助理解算法核心逻辑。

---
处理用时：67.90秒
# 题目信息

# [ABC373E] How to Win the Election

## 题目描述

现在正在举行一场选举，有 $N$ 位候选人，编号为 $1, 2, \ldots, N$。目前已经有 $K$ 张选票，其中一些已经被计入。

到目前为止，第 $i$ 位候选人已经获得了 $A_i$ 票。

在所有选票被计完后，如果某位候选人的得票数比他们多的候选人数少于 $M$，那么该候选人将被当选。可能会有多位候选人同时当选。

对于每个候选人，求出他们需要从剩余的选票中获得的最少票数，以确保无论其他候选人获得多少票，他们都能当选。

具体来说，对于每个 $i = 1, 2, \ldots, N$，解决以下问题：

确定是否存在一个非负整数 $X$，其不超过 $K - \displaystyle{\sum_{i=1}^{N}} A_i$，并满足以下条件。如果存在，找出满足条件的最小 $X$。

- 如果候选人 $i$ 获得了 $X$ 张额外选票，那么候选人 $i$ 将始终当选。

## 说明/提示

- $1 \leq M \leq N \leq 2 \times 10^5$。
- $1 \leq K \leq 10^{12}$。
- $0 \leq A_i \leq 10^{12}$。
- $\displaystyle{\sum_{i=1}^{N} A_i} \leq K$。

## 样例 #1

### 输入

```
5 2 16
3 1 4 1 5```

### 输出

```
2 -1 1 -1 0```

## 样例 #2

### 输入

```
12 1 570
81 62 17 5 5 86 15 7 79 26 6 28```

### 输出

```
79 89 111 117 117 74 112 116 80 107 117 106```

# AI分析结果



**唯一算法分类**：二分答案 + 贪心 + 前缀和优化

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **二分答案**：对每个候选人，二分确定其所需的最小额外票数 `X`，使得无论其他候选人如何分配剩余票数，该候选人仍能当选。
- **贪心策略**：在 `check` 函数中，假设其他候选人将剩余票数分配给最可能超过当前候选人的那些，计算所需的最小票数。
- **前缀和优化**：通过排序后的前缀和快速计算区间总票数，判断是否超出剩余票数。

#### **关键步骤**
1. **排序数组**：将原数组 `A` 排序后复制为 `B`，便于二分查找。
2. **二分 `X`**：对每个候选人 `i`，二分 `X` 的范围 `[0, K - sum(A)]`。
3. **计算临界点**：找到第一个超过 `A_i + X` 的位置 `x`，确定需要覆盖的区间 `[n-m+1, x-1]`。
4. **前缀和计算**：判断区间内提升票数至 `A_i+X+1` 的总需求是否超过剩余票数。

#### **解决难点**
- **区间处理**：需要排除当前候选人自身的影响，避免重复计算。
- **边界条件**：当 `M = N` 时，所有候选人直接当选，需特判。
- **时间复杂度**：通过前缀和将每次 `check` 的复杂度降为 `O(log N)`，整体复杂度 `O(N log K log N)`。

---

### **题解评分（≥4星）**

1. **dayz_break404（5星）**
   - **亮点**：清晰的贪心策略，完整处理了候选人自身在区间中的情况，代码简洁高效。
   - **代码可读性**：结构清晰，变量命名合理。
   - **优化点**：前缀和与二分查找的完美结合。

2. **SkyWave（4星）**
   - **亮点**：详细推导了 check 函数的数学表达式，处理了 `M=N` 的特例。
   - **可读性**：代码注释详尽，逻辑分明。

3. **_WRYYY_（4星）**
   - **亮点**：提出像素化动画设计思路，增强算法可视化理解。
   - **实现技巧**：通过排序和前缀和快速计算，代码较为简洁。

---

### **最优思路或技巧提炼**
1. **二分答案框架**：对每个候选人独立二分，保证时间复杂度可控。
2. **前缀和区间计算**：通过排序后的前缀和快速计算需覆盖区间的总票数。
3. **贪心分配策略**：将剩余票数分配给最接近当前候选人的对手，确保最坏情况下的正确性。

---

### **同类型题或类似算法套路**
- **类似题**：CF1779D（二分答案 + 贪心分配）、LeetCode 410（分割数组最大值的最小化）。
- **通用解法**：当问题涉及“最坏情况下最小化需求”时，二分答案结合贪心验证是典型套路。

---

### **推荐洛谷题目**
1. **P1182 数列分段 Section II**（二分答案 + 贪心验证）
2. **P1281 书的复制**（类似分段最小化最大值）
3. **P2218 [HAOI2007] 覆盖问题**（二分答案 + 几何覆盖验证）

---

### **个人心得摘录**
- **dayz_break404**：强调排序后需处理候选人自身在区间中的情况，否则会漏算。
- **HasNoName**：调试时发现未处理 `M=N` 导致数组越界，加入特判后通过。
- **_WRYYY_**：在实现 check 函数时，因未排除当前候选人导致 WA，最终通过调整区间解决。

---

### **可视化与算法演示**

#### **动画方案**
1. **动态二分过程**：
   - **高亮当前 `mid`**：显示候选人的当前票数 `A_i + mid`。
   - **排序数组可视化**：将候选人按票数排序，以柱状图展示，红色标记当前候选人。
   - **区间覆盖**：用不同颜色标记需要提升票数的区间 `[n-m+1, x-1]`。

2. **关键操作高亮**：
   - **前缀和计算**：显示区间总和与需求票数的差值。
   - **剩余票数变化**：动态更新剩余票数 `K - X`。

#### **复古像素风格设计**
- **颜色方案**：16色调色板，候选人票数以 8-bit 像素块表示。
- **音效触发**：
  - **二分步进**：播放短促“滴”声。
  - **验证通过**：上扬音效；失败：低沉音效。
- **Canvas 动画**：网格布局，候选人为像素方块，票数变化时方块高度动态调整。

#### **代码片段（关键逻辑）**
```cpp
// 前缀和预处理与二分验证
sort(b + 1, b + n + 1);
for (int i = 1; i <= n; i++) sum[i] = sum[i-1] + b[i];

bool check(int id, ll mid) {
    ll now = k - sum[n] - mid; // 剩余票数
    int x = upper_bound(b+1, b+1+n, a[id]+mid) - b - 1;
    int y = n - m + 1;
    if (n - x >= m) return false;
    // 计算区间 [y, x] 内提升至 a[id]+mid+1 的总需求
    ll need = (x - y + 1) * (a[id] + mid + 1) - (sum[x] - sum[y-1]);
    // 排除当前候选人自身的影响
    if (b[y] > a[id]) return need > now;
    need -= a[id]; // 调整前缀和
    return need > now;
}
```

---

### **总结**
本题通过二分答案确定最小额外票数，结合排序和前缀和优化贪心验证，时间复杂度高效。可视化设计通过动态二分步骤和复古像素风格，直观展示算法核心流程，适合教学与交互学习。

---
处理用时：75.64秒
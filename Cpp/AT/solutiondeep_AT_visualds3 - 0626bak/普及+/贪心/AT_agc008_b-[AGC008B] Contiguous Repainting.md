# 题目信息

# [AGC008B] Contiguous Repainting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc008/tasks/agc008_b

$ N $ 個のマスが横一列に並んでいます。 左から $ i $ 番目のマスには整数 $ a_i $ が書かれています。

最初、すべてのマスは白色です。 すぬけ君は次の操作を好きな回数だけ繰り返します。

- 連続する $ K $ 個のマスを選び、それらすべてを白く塗るか、それらすべてを黒く塗る。 このとき、各マスの色は上書きされる。

すぬけ君が操作を終えた後、黒いマスに書かれた整数の総和がスコアになります。 考えられるスコアの最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =N\ <\ =10^5 $
- $ 1\ <\ =K\ <\ =N $
- $ a_i $ は整数である。
- $ |a_i|\ <\ =10^9 $

### Sample Explanation 1

左から $ 2 $, $ 3 $, $ 4 $ 番目のマスを黒く塗ればよいです。

### Sample Explanation 2

たとえば、次のように操作を行えばよいです。 - 左から $ 1 $, $ 2 $ 番目のマスを黒く塗る。 - 左から $ 3 $, $ 4 $ 番目のマスを黒く塗る。 - 左から $ 2 $, $ 3 $ 番目のマスを白く塗る。

## 样例 #1

### 输入

```
5 3

-10 10 -10 10 -10```

### 输出

```
10```

## 样例 #2

### 输入

```
4 2

10 -10 -10 10```

### 输出

```
20```

## 样例 #3

### 输入

```
1 1

-10```

### 输出

```
0```

## 样例 #4

### 输入

```
10 5

5 -4 -5 -8 -4 7 2 -4 0 7```

### 输出

```
17```

# AI分析结果



**唯一算法分类**：前缀和与贪心

---

### **题解思路与算法要点**
1. **核心思路**：最后一次操作必定留下一个长度为K的连续区间（涂黑或白），其余位置的正数均可通过覆盖操作选中。
2. **关键步骤**：
   - **预处理前缀和**：计算每个位置前的正数和（用于区间前部分的正数贡献）。
   - **预处理后缀和**：计算每个位置后的正数和（用于区间后部分的正数贡献）。
   - **枚举区间**：遍历所有可能的K长度区间，计算该区间的和（若正则加入总和）及前后缀正数和的总和。
3. **解决难点**：通过前缀和和后缀和的预处理，将时间复杂度从O(n²)优化到O(n)，适用于大数规模。

---

### **题解评分（≥4星）**
1. **zljhenry的题解（5星）**  
   - 思路清晰，代码注释明确，预处理逻辑简洁。
   - 关键变量命名合理（sum1、sum2、sum3），便于理解。
2. **Tx_Lcy的题解（5星）**  
   - 代码极简，仅用两个前缀和数组实现，效率高。
   - 通过`max(0LL, sum[j] - sum[i-1])`直接处理区间和的正负情况。
3. **Dimly_dust的题解（4星）**  
   - 提供详细思路分析，适合初学者理解。
   - 代码逻辑完整，包含正数和的预处理和区间枚举。

---

### **最优思路与技巧提炼**
1. **前缀和优化**：通过预处理前缀正数和、原始前缀和，快速计算区间贡献。
2. **贪心选择**：若区间和为负则舍弃，否则加入总和，最大化结果。
3. **枚举策略**：遍历所有可能的最后操作区间，保证不漏最优解。

---

### **同类型题与算法套路**
- **类似题目**：滑动窗口最大值、区间和优化问题。
- **通用解法**：预处理前缀/后缀信息，枚举关键区间或位置。

**推荐题目**：
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. [P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)
3. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)

---

### **个人心得摘录**
- **顿悟点**：最后一次操作的区间覆盖特性是解题关键，其余位置的正数可任意选择。
- **调试教训**：必须用`long long`避免溢出，负数需直接舍弃。

---

### **可视化算法演示**
**核心逻辑动画设计**：
1. **网格绘制**：将N个格子以像素方块展示，初始为白色。
2. **区间高亮**：遍历时，当前K长度区间闪烁（如红色边框），表示正在计算。
3. **颜色填充**：
   - 绿色：选中为正数的前后缀部分。
   - 黄色：当前区间，若和为正当填充为黑色，否则保持白色。
4. **数值显示**：实时更新总得分，显示当前区间和、前后缀正数和。
5. **音效触发**：
   - 区间切换时播放“滴”声。
   - 更新最大值时播放上扬音效。

**复古像素风格**：
- 使用16色调色板，方格大小为16x16像素。
- 背景音乐为8-bit循环旋律，音效模仿经典红白机。

---

### **代码实现（核心片段）**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
long long n, k, a[N], pre[N], suf[N], sum[N];

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[i] = sum[i - 1] + a[i];
        pre[i] = pre[i - 1] + max(0LL, a[i]);
    }
    for (int i = n; i >= 1; i--)
        suf[i] = suf[i + 1] + max(0LL, a[i]);
    
    long long ans = 0;
    for (int i = 1; i + k - 1 <= n; i++) {
        int j = i + k - 1;
        long long cur = max(sum[j] - sum[i - 1], 0LL) + pre[i - 1] + suf[j + 1];
        ans = max(ans, cur);
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：74.50秒
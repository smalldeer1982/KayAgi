# 题目信息

# [AGC008C] Tetromino Tiling

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc008/tasks/agc008_c

正方形のマスを $ 4 $ 個繋げた形をテトロミノといいます。 次の $ 7 $ 種類のテトロミノを順に I, O, T, J, L, S, Z 型と呼ぶことにします。

 ![a60bcb8e9e8f22e3af51049eda063392.png](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc008_c/41da26817a0aa4921d5f3228c5ba880f4ed240c0.png)

すぬけ君は I, O, T, J, L, S, Z 型のテトロミノをそれぞれ $ a_I $, $ a_O $, $ a_T $, $ a_J $, $ a_L $, $ a_S $, $ a_Z $ 個ずつ持っています。 すぬけ君はこれらのテトロミノのうち $ K $ 個を組み合わせ、縦 $ 2 $ マス、横 $ 2K $ マスの長方形を作ろうとしています。 このとき、すぬけ君は次のルールに従います。

- 各テトロミノを置くとき、回転はできるが、反転はできない。
- 長方形の各マスにはちょうど $ 1 $ 個のテトロミノが置かれているようにする。
- 長方形の外部にテトロミノが置かれていないようにする。

すぬけ君はできるだけ大きい長方形を作ろうとしています。 $ K $ の最大値を求めてください。

## 说明/提示

### 制約

- $ 0\ <\ =a_I,a_O,a_T,a_J,a_L,a_S,a_Z\ <\ =10^9 $
- $ a_I+a_O+a_T+a_J+a_L+a_S+a_Z\ >\ =1 $

### Sample Explanation 1

たとえば、図のように組み合わせればよいです。 !\[45515ed2a1dd5e41c5e4ca1f39323d8e.png\](https://atcoder.jp/img/agc008/45515ed2a1dd5e41c5e4ca1f39323d8e.png)

### Sample Explanation 2

長方形を作ることができません。

## 样例 #1

### 输入

```
2 1 1 0 0 0 0```

### 输出

```
3```

## 样例 #2

### 输入

```
0 0 10 0 0 0 0```

### 输出

```
0```

# AI分析结果



---

**算法分类**：贪心算法

---

### **题解思路与核心难点**

1. **核心思路**：
   - **排除不可用方块**：T、S、Z 型方块因无法填满 2×2K 的矩形被排除。
   - **O 型方块直接全选**：每个 O 型贡献 1 个 K。
   - **I/J/L 型组合策略**：
     - **方案一**：每两个同类型方块拼成 2×4 矩形（贡献 2）。
     - **方案二**：各用一个 I/J/L 拼成 2×6 矩形（贡献 3），但需三者数量均 ≥1。

2. **解决难点**：
   - **组合策略对比**：方案二可能更优，但需检查是否满足条件（三者均 ≥1）。
   - **剩余数量处理**：若使用方案二后仍有剩余方块，需按方案一处理余数。

---

### **题解评分（≥4星）**

1. **FFTotoro（★★★★☆）**  
   - **亮点**：代码简洁，直接计算两种方案的最大值，逻辑清晰。  
   - **代码片段**：  
     ```cpp
     cout<<o+max(i&&j&&l?3+(i-1)/2*2+(j-1)/2*2+(l-1)/2*2:0, i/2*2+j/2*2+l/2*2)<<endl;
     ```

2. **fengenrong（★★★★☆）**  
   - **亮点**：详细注释和变量命名，便于理解。  
   - **代码片段**：  
     ```cpp
     ans = max(I/2*2 + J/2*2 + L/2*2, I>0 && J>0 && L>0 ? (I-1)/2*2 + (J-1)/2*2 + (L-1)/2*2 + 3 : 0);
     ```

3. **XYukari（★★★★☆）**  
   - **亮点**：通过条件判断优化组合策略，逻辑严谨。  
   - **代码片段**：  
     ```cpp
     if ((a & 1) + (d & 1) + (e & 1) >= 3) ans += 3;
     ```

---

### **最优思路与技巧**

- **关键技巧**：  
  - **贪心对比**：分别计算两种组合策略的贡献，取最大值。  
  - **奇偶处理**：利用 `(x-1)/2*2` 处理奇数剩余，确保不浪费可用方块。

- **思维角度**：  
  - 将问题拆分为独立子问题（排除、全选、组合优化），逐个击破。

---

### **类似题目推荐**

1. **洛谷 P1223 排队接水**：贪心策略优化总等待时间。  
2. **洛谷 P1094 纪念品分组**：双指针组合物品，最大化组数。  
3. **洛谷 P4995 跳跳！**：贪心选择跳跃高度差的最大值。

---

### **可视化与算法演示**

**动画设计**：  
1. **像素风格界面**：  
   - 用 8 位像素块表示 I/J/L 方块，O 型用纯色方块。  
   - **颜色标记**：当前操作的方块（如红色高亮 I 型）。  
   - **Canvas 动态拼接**：展示两种组合方案的长方形拼接过程。  

2. **交互控制**：  
   - **步进按钮**：逐步展示组合策略的选择。  
   - **参数调节**：拖动滑块调整各类型方块数量，实时更新动画。  

3. **音效与反馈**：  
   - **点击音效**：方块放置时的 8 位音效。  
   - **成功音效**：达成最大 K 值时播放胜利音调。  

**示例代码（JavaScript 动画片段）**：  
```javascript
// 绘制 I/J/L 方块组合
function drawBlock(type, x, y) {
    ctx.fillStyle = type === 'I' ? '#FF0000' : (type === 'J' ? '#00FF00' : '#0000FF');
    ctx.fillRect(x * 32, y * 32, 32, 32); // 32x32 像素方块
}
```

---

### **核心代码实现**

**FFTotoro 的完整代码**：  
```cpp
#include<iostream>
#define int long long
using namespace std;
signed main() {
    int i, o, t, j, l; 
    cin >> i >> o >> t >> j >> l; // 忽略 T/S/Z 型
    int case1 = (i / 2) * 2 + (j / 2) * 2 + (l / 2) * 2;
    int case2 = (i && j && l) ? 3 + ((i - 1) / 2 * 2 + (j - 1) / 2 * 2 + (l - 1) / 2 * 2) : 0;
    cout << o + max(case1, case2) << endl;
    return 0;
}
```

**代码要点**：  
- 直接计算两种方案的贡献值，取最大值后加上 O 型数量。  
- 使用 `(x-1)/2*2` 处理奇数剩余，确保所有方块充分利用。  

---

### **总结与心得**

- **关键教训**：必须严格排除 T/S/Z 型，否则无法填满矩形。  
- **调试技巧**：验证奇偶数的组合策略，确保余数处理正确。  
- **思维突破**：将复杂问题拆解为独立子问题，逐个优化。

---
处理用时：81.97秒
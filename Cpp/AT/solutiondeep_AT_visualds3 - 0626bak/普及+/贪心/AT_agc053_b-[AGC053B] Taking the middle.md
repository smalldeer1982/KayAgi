# 题目信息

# [AGC053B] Taking the middle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc053/tasks/agc053_b

$ 2N $ 枚のカードがあり、それぞれには $ 1 $ から $ 2N $ までの番号が付いています。カード $ i $ の価値は $ V_i $ です。 高橋君と青木君は以下の手順を $ N $ 回繰り返し、カードを $ N $ 枚ずつに分配します。

- まず、高橋君がまだ選ばれてないカードの中から $ 1 $ 枚選び、自分のものとする。 その後、青木君はまだ選ばれてないカードのうち **番号** が中央値であるものを選び、自分のものとする。

高橋君が最終的に持っているカードの価値の総和として考えられる最大の値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 0\leq\ V_i\leq\ 10^9 $
- $ V_i $ は整数

### Sample Explanation 1

以下のような手順で、高橋君はカード $ 4,5,6 $ を手にすることができます。 - まず、高橋君はカード $ 6 $ を選ぶ。そして、青木君はカード $ 3 $ を選ぶ。 - 次に、高橋君はカード $ 5 $ を選ぶ。そして、青木君はカード $ 2 $ を選ぶ。 - 最後に、高橋君はカード $ 4 $ を選ぶ。そして、青木君はカード $ 1 $ を選ぶ。

## 样例 #1

### 输入

```
3

1 2 3 4 5 6```

### 输出

```
15```

## 样例 #2

### 输入

```
4

1 4 5 8 7 6 3 2```

### 输出

```
20```

# AI分析结果



---

**算法分类**  
贪心算法（反悔贪心）  

---

**题解思路与解决难点**  
**核心思路**：通过贪心策略使青木取到尽可能小的总价值，从而间接最大化高桥的总和。每次操作中，青木只能从扩展的区间中选择当前最小的值，利用小根堆维护可选值并动态取出最小值。  

**关键步骤**：  
1. 将前 `n` 张与后 `n` 张卡牌视为两个序列，每次从两端各取一张加入堆。  
2. 每次弹出堆顶最小值（青木取的卡牌），最终堆中剩余元素为高桥所得。  

**解决难点**：  
- **正确性证明**：青木每次必须取中位数，通过扩展区间 `[n-i+1, n+i]` 并选择其中的最小值，确保全局最优。  
- **数据结构选择**：小根堆动态维护当前可能的最小值，时间复杂度为 `O(N log N)`。  

---

**题解评分（≥4星）**  
1. **ImposterAnYu（★★★★☆）**  
   - 详细解释栈模型和贪心策略，代码清晰。  
   - 通过「正难则反」转化问题，思路巧妙。  

2. **hellolin（★★★★☆）**  
   - 思路简洁，代码易读，直接点明贪心核心。  
   - 附有洛谷和 AtCoder 题面链接，便于参考。  

3. **suzhikz（★★★★☆）**  
   - 代码简短高效，突出核心逻辑。  
   - 虽证明稍简，但通过示例验证正确性。  

---

**最优思路提炼**  
1. **反悔贪心**：每次将当前可能的最优解（最小值）让给青木，剩余值即为高桥的最优解。  
2. **小根堆维护**：动态维护可选的最小值，确保每次操作高效。  
3. **区间扩展策略**：每次操作扩展左右端点，覆盖青木可能的取牌范围。  

---

**同类题型与算法套路**  
- **反悔贪心**：如合并果子（优先队列维护合并顺序）、任务调度（选择最优执行顺序）。  
- **中位数相关**：如滑动窗口中位数（对顶堆维护）。  

**推荐题目**  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
2. [P2168 荷马史诗](https://www.luogu.com.cn/problem/P2168)  
3. [P3871 中位数](https://www.luogu.com.cn/problem/P3871)  

---

**代码实现（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n; cin >> n;
    vector<int> v(2 * n + 1);
    long long total = 0;
    for (int i = 1; i <= 2 * n; i++) {
        cin >> v[i];
        total += v[i];
    }
    priority_queue<int, vector<int>, greater<int>> pq;
    // 从中间向两端扩展
    int l = n, r = n + 1;
    while (l >= 1 && r <= 2 * n) {
        pq.push(v[l--]);
        pq.push(v[r++]);
        pq.pop(); // 弹出当前最小值（青木取的牌）
    }
    long long aoki_sum = 0;
    while (!pq.empty()) {
        aoki_sum += pq.top();
        pq.pop();
    }
    cout << total - aoki_sum << endl;
}
```

---

**可视化与算法演示**  
**动画设计**：  
1. **像素风格界面**：  
   - 卡牌以像素方块展示，左侧为前 `n` 张（编号 1~n），右侧为后 `n` 张（编号 n+1~2n）。  
   - 高亮当前操作的两张卡牌（如蓝色框），弹出最小值时显示红色闪烁效果。  

2. **堆的动态展示**：  
   - 小根堆以树状图实时更新，堆顶最小值显示为红色。  
   - 每次弹出堆顶时，播放“滴”音效；加入新元素时播放“嗒”音效。  

3. **自动演示模式**：  
   - 初始速度为 1 秒/步，可调节速度或单步执行。  
   - 右侧面板显示高桥和青木当前总和，动态更新。  

**交互示例**：  
- **点击卡牌**：手动模拟高桥选择（仅演示模式）。  
- **音效设置**：8-bit 风格背景音乐，关键操作触发音效。  

---

**心得与扩展**  
- **贪心证明技巧**：通过构造区间扩展模型，将问题转化为动态维护最小值。  
- **调试经验**：优先队列的边界处理（如初始空队列）需特别注意。  
- **扩展思考**：若青木取牌规则变化（如取最大值），需调整为大根堆策略。

---
处理用时：98.59秒
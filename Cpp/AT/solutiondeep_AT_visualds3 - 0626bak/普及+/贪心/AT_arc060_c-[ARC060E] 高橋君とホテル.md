# 题目信息

# [ARC060E] 高橋君とホテル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc060/tasks/arc060_c

$ N $ 軒のホテルが一直線上に並んでいます。$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 番目のホテルは、座標 $ x_i $ に位置しています。

旅行者である高橋君には、次の $ 2 $ つの信念があります。

- 高橋君の $ 1 $ 日の移動距離は $ L $ を超えない。
- 高橋君は野宿をしない。すなわち、$ 1 $ 日の終わりには必ずいずれかのホテルにいなければならない。

$ Q $ 個のクエリが与えられます。$ j\,(1\ \leq\ j\ \leq\ Q) $ 番目のクエリとして、異なる $ 2 $ つの整数 $ a_j,\,b_j $ が与えられます。 各クエリについて、前述の信念をともに守った上で、高橋君が $ a_j $ 番目のホテルから $ b_j $ 番目のホテルに移動するために必要な最小日数を求めてください。 なお、高橋君が $ a_j $ 番目のホテルから $ b_j $ 番目のホテルに移動できることは保証されます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ L\ \leq\ 10^9 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ 1\ \leq\ x_i\ <\ x_2\ <\ ...\ <\ x_N\ \leq\ 10^9 $
- $ x_{i+1}\ -\ x_i\ \leq\ L $
- $ 1\ \leq\ a_j,b_j\ \leq\ N $
- $ a_j\ \neq\ b_j $
- $ N,\,L,\,Q,\,x_i,\,a_j,\,b_j $ はいずれも整数である

### 部分点

- $ N\ \leq\ 10^3 $ および $ Q\ \leq\ 10^3 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。

### Sample Explanation 1

$ 1 $ つ目のクエリでは、次のように行動することで、$ 1 $ 番目のホテルから $ 8 $ 番目のホテルへ $ 4 $ 日間で移動することができます。 - $ 1 $ 日目には、$ 1 $ 番目のホテルから $ 2 $ 番目のホテルへ移動する。この日の移動距離は $ 2 $ である。 - $ 2 $ 日目には、$ 2 $ 番目のホテルから $ 4 $ 番目のホテルへ移動する。この日の移動距離は $ 10 $ である。 - $ 3 $ 日目には、$ 4 $ 番目のホテルから $ 7 $ 番目のホテルへ移動する。この日の移動距離は $ 6 $ である。 - $ 4 $ 日目には、$ 7 $ 番目のホテルから $ 8 $ 番目のホテルへ移動する。この日の移動距離は $ 10 $ である。

## 样例 #1

### 输入

```
9

1 3 6 13 15 18 19 29 31

10

4

1 8

7 3

6 7

8 5```

### 输出

```
4

2

1

2```

# AI分析结果



## **唯一算法分类**  
倍增

---

## **综合分析与结论**  
### **核心思路**  
问题要求从起点酒店到终点酒店的最小天数，每次移动不超过L且必须入住酒店。**核心难点**在于高效处理大量查询（Q≤1e5）。所有题解均基于贪心策略：每一步尽可能跳最远。关键在于如何快速模拟跳跃过程。  

### **算法实现要点**  
1. **预处理跳跃表**：  
   - 用双指针法（或二分）预处理每个点i一次跳跃可达的最远位置`f[i][0]`。  
   - 构建倍增表`f[i][k]`，表示从i出发跳2^k次后的终点。递推式：`f[i][k] = f[f[i][k-1]][k-1]`。  
2. **查询优化**：  
   - 类似LCA查询，从高位到低位试跳，若未达终点则累加步数。  

### **可视化设计**  
- **动画流程**：  
  1. 显示酒店坐标轴，高亮当前点与跳跃目标。  
  2. 每次跳跃时，动态绘制跳跃弧线并显示步数（2^k）。  
  3. 终点到达时触发闪光效果与音效。  
- **复古像素风格**：  
  - 酒店用像素方块表示，高桥君为移动像素点。  
  - 背景音乐为8-bit循环曲，跳跃时播放短促“哔”声，成功时播放上升音阶。  
- **交互控制**：  
  - 可调节动画速度，单步执行观察倍增跳跃细节。  

---

## **题解清单 (≥4星)**  
1. **GaryH (★★★★★)**  
   - 关键亮点：双指针预处理O(N)，代码简洁高效，对比同类题目。  
2. **君のNOIP。 (★★★★☆)**  
   - 亮点：清晰分步讲解，预处理与查询代码分离，适合初学者。  
3. **AlicX (★★★★☆)**  
   - 亮点：极简代码实现，突出核心逻辑，适合快速参考。  

---

## **最优思路提炼**  
- **双指针预处理**：线性时间确定每个点的最远可达位置。  
- **倍增跳跃**：将天数转化为二进制位，从高位到低位试跳，时间复杂度O(log D)。  
- **逆向思维**：若无法直接到达终点，则累计步数后需额外+1天。  

---

## **同类型题与套路**  
- **类似题目**：CF1516D Cut（分段后乘积为平方数）、NC 哲学家的沉思（极长连续子序列）。  
- **通用套路**：当问题满足“单调性”且需快速跳跃时，优先考虑倍增预处理。  

---

## **推荐题目**  
1. **P1967 货车运输**（倍增求路径最小值）  
2. **P1081 开车旅行**（双向跳跃预处理）  
3. **P3398 仓鼠找sugar**（路径交集判断）  

---

## **代码实现与片段**  
**核心预处理与查询逻辑**（GaryH题解）  
```cpp
// 双指针预处理f[i][0]
int t=0;
for(int i=1;i<=n;i++){
    while(t+1<=n && x[t+1]-x[i]<=L) t++;
    f[i][0] = t;
}
// 构建倍增表
for(int j=1;j<=20;j++)
    for(int i=1;i<=n;i++)
        f[i][j] = f[f[i][j-1]][j-1];

// 查询函数
int query(int a, int b){
    int ans=0;
    for(int j=20;j>=0;j--){
        if(f[a][j] < b){
            a = f[a][j];
            ans += (1<<j);
        }
    }
    if(a < b) ans++;
    return ans;
}
```

---

## **个人心得摘录**  
- **调试教训**：预处理时需处理边界（如`f[n][0]=n+1`），否则会导致死循环。  
- **思维突破**：将天数转化为二进制位试跳，是倍增算法的核心妙处。  

---

## **可视化示例（JS伪代码）**  
```javascript
// Canvas绘制跳跃过程
function drawJump(current, target, step) {
    ctx.beginPath();
    ctx.moveTo(hotels[current].x, 50);
    ctx.arcTo(..., step); // 贝塞尔曲线模拟跳跃
    beepSound.play(); // 播放音效
}

// 自动演示模式
function autoRun(start, end) {
    let pos = start;
    while(pos < end) {
        let k = highestBit(pos, end); // 计算最大可跳步数
        drawJump(pos, f[pos][k], k);
        pos = f[pos][k];
        totalDays += (1<<k);
    }
}
```

---
处理用时：65.33秒
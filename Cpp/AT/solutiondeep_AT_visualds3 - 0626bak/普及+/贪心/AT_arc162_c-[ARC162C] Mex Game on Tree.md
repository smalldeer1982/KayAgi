# 题目信息

# [ARC162C] Mex Game on Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc162/tasks/arc162_c

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の根付き木が与えられます。頂点 $ 1 $ が根であり、頂点 $ i\ (2\leq\ i\ \leq\ N) $ の親は $ P_i $ です。

根付き木の何個かの頂点には $ 0 $ 以上 $ N $ 以下の整数が書かれています。この情報は数列 $ A=(A_1,A_2,\ldots,A_N) $ で与えられ、$ A_i\ \neq\ -1 $ の場合頂点 $ i $ に整数 $ A_i $ が書かれており、$ A_i=-1 $ の場合頂点 $ i $ には整数が書かれていないことを意味しています。

Alice と Bob でゲームをします。Alice が先手で、全ての頂点に整数が書かれるまで以下の操作を交互に繰り返します。

- 整数が書かれていない頂点を $ 1 $ 個選び、 $ 0 $ 以上 $ N $ 以下の整数を書く。
 
操作終了後の各頂点 $ v $ に対して、 $ f(v) $ を「頂点 $ v $ の部分木に含まれるどの頂点（$ v $ 含む）にも書かれていないような最小の非負整数」と定めます。

$ f(v)\ =\ K $ を満たす頂点 $ v $ が存在する場合 Alice の勝利、そうでない場合 Bob の勝利となります。両者が最適な行動を行う場合、どちらが勝つか判定してください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^3 $
- $ 2\ \leq\ N\ \leq\ 10^3 $
- $ 0\ \leq\ K\ \leq\ N $
- $ 1\ \leq\ P_i\ <\ i\ (2\leq\ i\leq\ N) $
- $ -1\ \leq\ A_i\ \leq\ N\ (1\leq\ i\leq\ N) $
- 入力される数値は全て整数
- $ 1 $ つの入力に含まれるテストケースについて、$ N $ の総和は $ 2\times\ 10^3 $ 以下
 
### Sample Explanation 1

$ 1 $ 番目のテストケースについては、Alice が頂点 $ 2 $ に $ 0 $ を書き込むと、Bob の操作に依らず $ f(2)\ =\ 2 $ となります。そのため、Alice は勝つことができます。 $ 2 $ 番目のテストケースについては、Bob が上手く書き込む整数を選ぶことで、 $ f(v)\ =\ 4 $ なる頂点が存在しないようにできます。

## 样例 #1

### 输入

```
2

4 2

1 1 2

-1 -1 3 1

6 4

1 2 2 1 3

-1 -1 -1 -1 -1 -1```

### 输出

```
Alice

Bob```

# AI分析结果



# 【ARC162C】Mex Game on Tree 题解分析

## 唯一算法分类
**树形遍历与博弈分析**

---

## 综合分析与结论

### 核心思路与难点
题目要求判断 Alice 能否在双方最优策略下，使得最终存在某个节点的子树 mex 值为 K。关键点在于：
1. **Bob 的最优策略是填 K**，这会破坏其所有祖先节点的可能性。
2. **Alice 必须满足以下条件之一才能获胜**：
   - 某个子树已填满且 mex 恰好为 K。
   - 某个子树仅剩一个空位，且填入特定值后 mex 变为 K。

### 算法流程与可视化设计
1. **树形遍历**：自底向上遍历每个子树，合并子节点信息（已填数字集合、空位数）。
2. **mex 计算**：用 `bitset` 记录已存在的数字，快速查询缺失的最小非负整数。
3. **条件判断**：对每个节点，检查是否满足上述两个获胜条件。

**可视化设计思路**：
- **颜色标记**：已填数字（绿色）、空位（红色）、当前处理节点（黄色）。
- **动画展示**：自底向上遍历时，高亮当前节点并显示其合并后的 `bitset` 和空位数。
- **音效提示**：检测到获胜条件时播放胜利音效，Bob 填入 K 时播放破坏音效。

---

## 题解评分 (≥4星)

### 1. 作者：_•́へ•́╬_（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：代码简洁高效，使用 `bitset` 快速处理 mex，自底向上合并子树信息。
- **核心代码**：
  ```cpp
  for(int i=n-1;i>=0;--i) {
    if(~x[i]) a[i][x[i]]=0;
    else ++cnt[i];
    if(!cnt[i] && a[i]._Find_first()==m) // 条件1
    if(cnt[i]==1 && a[i]._Find_next(...)==m) // 条件2
    if(i) a[f[i]]&=a[i], cnt[f[i]]+=cnt[i]; // 合并子树
  }
  ```

### 2. 作者：Lucky_Xiang（⭐️⭐️⭐️⭐️）
- **亮点**：将问题转化为博弈论模型，分析空位数与必胜态的关系。
- **结论**：若存在空位数 ≤1 的子树，则 Alice 胜。

### 3. 作者：wangshulin（⭐️⭐️⭐️⭐️）
- **亮点**：利用 DFS 序遍历子树，统计 mex 相关条件。
- **关键逻辑**：
  ```cpp
  for(int i=1;i<=n;i++) {
    memset(ccol,0,sizeof(ccol));
    for(int j=dfn[i];j<=bot[i];j++) ccol[col[rnk[j]]]++;
    if(ccol[k] || ccol[n+1]>1) continue;
    // 判断 mex 条件...
  }
  ```

---

## 最优思路提炼
1. **自底向上合并子树信息**：每个节点维护已填数字集合和空位数。
2. **快速 mex 计算**：使用 `bitset` 或数组统计已存在的数字。
3. **空位数决定胜负**：
   - 空位数 ≥2：Bob 必胜。
   - 空位数 =1：Alice 需一步填数使得 mex=K。
   - 空位数 =0：直接检查当前 mex 是否为 K。

---

## 相似题目推荐
1. **CF1451E1** - 位运算与 mex 性质结合。
2. **CF1527B1** - 博弈论中的 mex 条件判断。
3. **Luogu P1270** - 树形 DP 与最优策略分析。

---

## 个人心得摘录
- **填 K 破坏性**：Bob 填 K 会使得所有祖先节点的 mex 不可能为 K，需优先考虑。
- **DFS 序优化**：通过预处理子树区间，快速统计子树信息（如 wangshulin 的代码）。

---

## 可视化与算法演示
### 核心算法动画方案
1. **树形结构绘制**：用 Canvas 绘制树形结构，节点显示当前状态（已填数字、空位数）。
2. **自底向上遍历**：高亮当前节点，逐步合并子节点信息，显示 `bitset` 的变化。
3. **条件触发特效**：当检测到满足 Alice 获胜条件的节点时，节点闪烁并播放音效。

### 复古像素风格设计
- **颜色方案**：16 色调色板，绿色（已填数字）、红色（空位）、黄色（当前节点）。
- **音效设计**：
  - **步进音效**：每处理一个节点播放 8-bit 音效。
  - **胜利音效**：检测到获胜条件时播放高音调旋律。
  - **破坏音效**：Bob 填 K 时播放低沉音效。

### 交互功能
- **自动演示**：按预设速度逐步执行算法。
- **手动控制**：暂停/继续、单步执行、调整速度。
- **积分系统**：正确识别必胜节点获得积分，错误操作扣分。

---

通过上述分析，可以清晰理解如何通过树形遍历和博弈分析高效解决此题，同时可视化设计增强了算法的直观性。

---
处理用时：79.28秒
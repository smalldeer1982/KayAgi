# 题目信息

# [ARC164C] Reversible Card Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc164/tasks/arc164_c

両面に数が書かれた $ N $ 枚のカードがあり、$ i $ 枚目のカードには片方の面に赤い数字で $ A_i $ が、もう片方の面には青い数字で $ B_i $ が書かれています。初め、全てのカードは赤い数字が書かれた面を表にして置かれており、Alice と Bob は次のような手順を繰り返すゲームをします。

- まず、Alice が残っているカードの中から $ 1 $ 枚を選び、裏返す。次に、Bob が残っているカードの中から $ 1 $ 枚を取り除く。このとき、取り除いたカードの表側の面に書かれていた数の分だけ Bob は得点を得る。
 
残っているカードが $ 0 $ 枚になった時、ゲームを終了します。

Alice はゲーム終了時の Bob の得点を最小にしようとし、Bob はこれを最大にしようとします。両者が最善の手順を取ったとき、ゲーム終了時の Bob の得点は何点でしょうか。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,\ B_i\leq\ 10^9 $ $ (1\leq\ i\ \leq\ N) $
- 入力される値はすべて整数である
 
### Sample Explanation 1

初めの状態では、表側の面に書かれた数はそれぞれ $ 6,2,5 $ です。ここから、例えば次のような進行が考えられます。 1. Alice は $ 1 $ 枚目のカードを裏返す。このとき、表側の面に書かれた数は $ 4,2,5 $ となる。Bob は $ 3 $ 枚目のカードを取り除き、$ 5 $ 点を得る。 2. Alice は $ 2 $ 枚目のカードを裏返す。このとき、表側の面に書かれた数は $ 4,1 $ となる。Bob は $ 2 $ 枚目のカードを取り除き、$ 1 $ 点を得る。 3. Alice は最後に残った $ 1 $ 枚目のカードを裏返す。このとき、表側の面に書かれた数は $ 6 $ となる。Bob はこれを取り除き、$ 6 $ 点を得る。 この場合、Bob が最終的に得る得点は $ 12 $ 点です。実は、この進行は双方の最善手の一例であり、答えは $ 12 $ となります。

## 样例 #1

### 输入

```
3

6 4

2 1

5 3```

### 输出

```
12```

## 样例 #2

### 输入

```
5

166971716 552987438

219878198 619875818

918378176 518975015

610749017 285601372

701849287 307601390```

### 输出

```
3078692091```

# AI分析结果



---

### 唯一算法分类
贪心策略

---

### 综合分析与结论
**核心思路**：  
1. 每张卡片的贡献由较大值与较小值的差值（Delta）决定。  
2. 初始时较大值朝上的卡片数量（cnt）的奇偶性决定是否需要调整最终得分：  
   - 若 cnt 为偶数，Bob 能拿到所有较大值的总和。  
   - 若 cnt 为奇数，需从总和中减去最小的 Delta。  

**解决难点**：  
- **奇偶性判断**：通过统计初始较大值朝上的卡片数量的奇偶性，确定是否需要调整得分。  
- **差值选择**：当需要调整时，选择最小的 Delta 以保证总损失最小。  

**可视化设计**：  
- **动画步骤**：  
  1. 初始展示所有卡片，红色面（A_i）朝上，绿色标记较大值。  
  2. 根据 cnt 的奇偶性，动态展示 Alice 的翻转策略（如优先翻转差值最大的卡片）。  
  3. 若 cnt 为奇数，高亮最小 Delta 的卡片，演示其被扣减的过程。  
- **颜色标记**：  
  - 红色/蓝色区分卡片的初始面，绿色高亮当前操作卡片。  
  - 最小值用特殊边框（如闪烁）标记。  
- **交互控制**：允许单步执行，观察每一步的得分变化和卡片状态。  

---

### 题解清单（≥4星）
1. **Exp10re（4星）**  
   - **亮点**：将问题转化为差值问题，通过奇偶性快速判断。  
   - **代码简练**：直接统计初始翻转次数，快速计算总和。  
   - **注意**：代码中条件判断需修正为 `(n - ccnt) % 2`，原题解代码可能存在逻辑疏漏。  

2. **chinazhanghaoxun（5星）**  
   - **思路清晰**：明确统计初始较大值朝上的数量，奇偶性判断直接。  
   - **代码正确性**：准确处理所有情况，样例验证无误。  

3. **Hog_Dawa_IOI（4星）**  
   - **直观分析**：从博弈过程推导出奇偶性影响，结合差值最小值调整。  
   - **代码简洁**：逻辑与结论完全一致。  

---

### 最优思路提炼
1. **差值分解**：将每张卡片的贡献分解为较小值（固定）和差值（可调整）。  
2. **奇偶性决策**：初始较大值朝上的卡片数量奇偶性决定最终是否需要扣减最小差值。  
3. **贪心选择**：当需要扣减时，选择最小差值以保证总损失最小。  

---

### 类似题目推荐
1. **P1005 矩阵取数游戏**（贪心策略与奇偶性结合）  
2. **P1650 田忌赛马**（差值最大化与策略选择）  
3. **P1090 合并果子**（优先队列处理最小值）  

---

### 代码片段（chinazhanghaoxun 实现）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int n,a,b,ans=0,cha=INT_MAX,cnt=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a>>b;
        if(a>b) cnt++;
        ans += max(a,b);
        cha = min(cha, abs(a-b));
    }
    if(cnt%2) cout<<ans-cha;
    else cout<<ans;
    return 0;
}
```
**核心逻辑**：  
- 统计初始较大值朝上的卡片数量 `cnt`。  
- 总得分初始化为所有较大值之和 `ans`。  
- 若 `cnt` 为奇数，则扣除最小差值 `cha`。  

---

### 可视化与算法演示
**动画设计**：  
1. **初始化**：展示所有卡片，红色面朝上，绿色标记较大值。  
2. **奇偶判断**：若较大值数量为奇数，高亮最小差值的卡片。  
3. **得分变化**：动态显示总和扣除最小差值的过程。  

**复古像素风格**：  
- 使用 8-bit 像素风绘制卡片，翻转时播放“点击”音效。  
- 自动模式下，算法自动选择最优路径，背景音乐循环播放。  

**交互功能**：  
- 步进控制：观察每一步的翻转和得分变化。  
- 模式切换：手动操作或 AI 自动演示。  

---

通过上述分析，结合贪心策略与奇偶性判断，该问题得以高效解决。

---
处理用时：398.63秒
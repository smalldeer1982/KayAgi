# 题目信息

# [ARC165B] Sliding Window Sort 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc165/tasks/arc165_b

$ 1 $ から $ N $ までの整数からなる順列 $ P=(P_1,P_2,\dots,P_N) $ と整数 $ K $ が与えられます。

順列 $ P $ に対して以下のような操作を考えます。

- $ 1\ \leq\ i\ \leq\ N-K+1 $ を満たす整数 $ i $ を $ 1 $ つ選び、 $ P_i,P_{i+1},\dots,P_{i+K-1} $ を昇順に並び替える。すなわち、$ P_i,P_{i+1},\dots,P_{i+K-1} $ を小さい方から順に並べたものを $ (x_1,x_2,\dots,x_K) $ としたとき、各 $ 1\ \leq\ j\ \leq\ K $ に対して $ P_{i+j-1} $ を $ x_j $ で置き換える。
 
$ P $ に対して上記の操作をちょうど $ 1 $ 回行うことで得られる順列のうち、辞書式順序最大のものを求めてください。

  数列の辞書順とは？数列 $ S\ =\ (S_1,S_2,\ldots,S_{|S|}) $ が数列 $ T\ =\ (T_1,T_2,\ldots,T_{|T|}) $ より**辞書順で小さい**とは、下記の 1. と 2. のどちらかが成り立つことを言います。 ここで、$ |S|,\ |T| $ はそれぞれ $ S,\ T $ の長さを表します。

1. $ |S|\ \lt\ |T| $ かつ $ (S_1,S_2,\ldots,S_{|S|})\ =\ (T_1,T_2,\ldots,T_{|S|}) $。
2. ある整数 $ 1\ \leq\ i\ \leq\ \min\lbrace\ |S|,\ |T|\ \rbrace $ が存在して、下記の $ 2 $ つがともに成り立つ。 
  - $ (S_1,S_2,\ldots,S_{i-1})\ =\ (T_1,T_2,\ldots,T_{i-1}) $
  - $ S_i $ が $ T_i $ より（数として）小さい。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ P_i\ \leq\ N $
- $ (P_1,P_2,\dots,P_N) $ は $ 1 $ から $ N $ までの整数からなる順列
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i=1 $ として操作を行うと $ (P_1,P_2,P_3)=(2,1,4) $ であり、これを昇順に並び替えると $ (1,2,4) $ となります。よって操作によって $ P_1,P_2,P_3 $ はそれぞれ $ 1,2,4 $ に置き換えられ、 $ P=(1,2,4,3) $ となります。同様に $ i=2 $ として操作を行うと $ P $ は $ (2,1,3,4) $ となります。 これらのうち辞書式順序で大きいのは $ (2,1,3,4) $ であるため、答えは $ (2,1,3,4) $ となります。

## 样例 #1

### 输入

```
4 3

2 1 4 3```

### 输出

```
2 1 3 4```

## 样例 #2

### 输入

```
5 1

3 1 4 2 5```

### 输出

```
3 1 4 2 5```

## 样例 #3

### 输入

```
20 7

9 4 3 1 11 12 13 15 17 7 2 5 6 20 19 18 8 16 14 10```

### 输出

```
9 4 3 1 11 12 13 15 17 7 2 5 6 8 18 19 20 16 14 10```

# AI分析结果



### 算法分类  
**贪心策略 / 构造**

---

### 题解思路与解决难点  
#### **核心思路**  
1. **最大字典序性质**：升序排序不会增大字典序。若原排列存在长度为 K 的递增子序列，直接输出原排列。
2. **前缀保留策略**：若必须改变，需尽可能保留最长前缀，并选择排序后最有利的区间。关键条件是：  
   - 前缀 `[1, n-K]` 保持严格递增。  
   - 前缀末尾元素 `P_{n-K}` 小于排序区间内的最小值，确保排序不影响前缀。  
3. **贪心选择左端点**：在满足条件的左端点中选择最小的，使得排序后的区间尽可能靠左且包含更多元素，从而优化后续字典序。

#### **实现关键点**  
- **递增序列检查**：遍历判断是否存在长度 ≥K 的递增子序列。  
- **预处理最小值**：使用 ST 表或滑动窗口维护区间最小值，快速验证条件。  
- **逆向遍历左端点**：从 `n-K` 向左寻找最长递增前缀，并找到最小满足条件的左端点。

---

### 题解评分（≥4星）  
1. **EuphoricStar（★★★★☆）**  
   - **亮点**：通过最长递增子段快速确定候选区间，结合预处理最小值优化判断。  
   - **心得**：赛时代码被 hack 后修正，强调正确性验证的重要性。  
   - **代码**：预处理 `pre` 数组，时间复杂度 O(n)。  

2. **樱雪喵（★★★★☆）**  
   - **亮点**：滑动窗口思想 + `set` 维护区间排序，通过跳跃标记避免重复匹配。  
   - **心得**：被题目名误导但提出跳跃匹配优化，时间复杂度 O(n log n)。  

3. **lzyqwq（★★★★☆）**  
   - **亮点**：逆向扫描 + ST 表预处理，代码简洁且逻辑清晰。  
   - **代码**：预处理递增区间，结合 ST 表查询最小值。  

---

### 最优思路提炼  
**核心策略**：  
1. **前缀保留**：确保 `[1, n-K]` 严格递增且 `P_{n-K}` 小于排序区间的最小值。  
2. **最小左端点**：选择满足条件的最左区间，使得排序后尽可能少破坏后续元素的相对顺序。  

**实现技巧**：  
- 使用 ST 表或滑动窗口维护区间最小值。  
- 逆向遍历左端点，优先处理更小的左端点以优化字典序。  

---

### 同类题目推荐  
1. **CF1157E**（区间排序后的字典序问题）  
2. **LeetCode 670**（交换一次使数字最大）  
3. **洛谷 P1273**（滑动窗口与贪心结合）  

---

### 代码实现（关键逻辑）  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, k, a[N], pre[N];

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 检查是否存在长度 ≥K 的递增子序列
    int max_incr = 1;
    for (int i = 2; i <= n; ++i) {
        if (a[i] > a[i-1]) max_incr++;
        else max_incr = 1;
        if (max_incr >= k) {
            for (int j = 1; j <= n; ++j) cout << a[j] << ' ';
            return 0;
        }
    }
    
    // 预处理从 n-K+1 开始的区间最小值
    pre[n - k + 1] = a[n - k + 1];
    for (int i = n - k + 2; i <= n; ++i)
        pre[i] = min(pre[i - 1], a[i]);
    
    // 逆向寻找最长递增前缀的起始点
    int pos = n - k;
    for (int i = n - k - 1; i >= 1; --i) {
        if (a[i] > a[i + 1]) break;
        pos = i;
    }
    
    // 寻找最小左端点
    int ans = n - k + 1;
    for (int i = pos; i <= n - k; ++i) {
        if (a[n - k] < pre[i + k - 1]) {
            ans = i;
            break;
        }
    }
    
    sort(a + ans, a + ans + k);
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    return 0;
}
```

---

### 可视化算法演示  
**动画设计**：  
1. **颜色标记**：  
   - 红色：当前检查的递增子序列。  
   - 绿色：满足条件的候选排序区间。  
   - 蓝色：最终选择的排序区间。  
2. **步进控制**：  
   - 展示逆向扫描递增前缀的过程。  
   - 动态更新区间最小值，高亮比较 `P_{n-K}` 与区间最小值。  
3. **复古像素风格**：  
   - 使用 8 位像素方块表示数组元素，排序时方块重新排列并播放音效。  
   - 背景音乐：FC 风格循环旋律，关键操作时触发“点击”音效。  

**交互功能**：  
- **速度调节**：滑动条控制动画速度。  
- **自动演示**：AI 自动运行并解释每一步决策逻辑。  

---

### 个人心得摘录  
> “逆向遍历左端点时，一旦发现不满足递增条件立即 break，大幅减少无效计算。” —— lzyqwq  
> “使用 set 维护区间时，跳跃标记避免重复匹配是关键优化。” —— 樱雪喵  

---

**总结**：通过贪心策略保留最长前缀，结合预处理和逆向扫描，可在 O(n) 时间内高效求解。核心在于最小左端点的选择与区间最小值的快速验证。

---
处理用时：86.99秒
# 题目信息

# [ARC184A] Appraiser

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc184/tasks/arc184_a

この問題は **インタラクティブ** な問題であり、 **ジャッジは適応的(adaptive)** です。詳しくは注意点を参照してください。  
**また、問題文中のパラメータは $ N=1000,M=10,Q=950 $ で固定されています。**

硬貨が $ N $ 枚あり、 $ 1,2,\dots,N $ の番号が付けられています。  
これらの硬貨のうち、丁度 $ M $ 枚が偽物です。

鑑定士は $ 1 $ 度の鑑定で $ 2 $ つの硬貨が同種か異種かを判定できます。厳密には、

- $ 2 $ つの硬貨が「双方とも本物」「双方とも偽物」のどちらかであれば、同種と判定する。
- そうでないとき、異種と判定する。

$ Q $ 回以下の鑑定で、全ての偽物の硬貨を特定してください。

### Input &amp; Output Format

この問題はインタラクティブな問題です。  
最初に、 $ N,M,Q $ を標準入力から受け取ってください。

> $ N $ $ M $ $ Q $

次に、以下の流れで鑑定を $ 0 $ 回以上 $ Q $ 回以下行ってください。

まず、次の形式で標準出力に出力することで、硬貨 $ x,y $ を鑑定することを表します。 (末尾に改行を入れること。)

> ? $ x $ $ y $

ここで、 $ x,y $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。

これに対するジャッジシステムの応答は、以下の $ 3 $ 通りです。

```
0
```

応答が `0` であるとき、硬貨 $ x,y $ が同種であることを表します。

```
1
```

応答が `1` であるとき、硬貨 $ x,y $ が異種であることを表します。

```
-1
```

応答が `-1` であるとき、不当な鑑定であることを表します。具体的には

- 出力した $ x,y $ が制約を満たさなかった
- $ Q $ 回を超えて鑑定が行われた

の少なくともひとつが満たされた際にこの応答を行います。  
この応答を受け取った場合、プログラムはすでに不正解とみなされています。直ちにプログラムを終了してください。

最後に、次の形式で標準出力に出力することで、硬貨 $ A_1,A_2,\dots,A_{M} $ が偽物であると解答します。 (末尾に改行を入れること。)

> ! $ A_1 $ $ A_2 $ $ \dots $ $ A_{M} $

ここで、 $ A_i $ は $ 1 $ 以上 $ N $ 以下の相異なる整数である必要があります。  
この出力の後、直ちにプログラムを終了してください。

なお、全ての出力について、出力が指定された形式を満たさなかった場合もプログラムが不正解とみなされます。 その後 `-1` が返答されるので、その場合も直ちにプログラムを終了してください。

## 说明/提示

### 制約

- $ \color{red}{N\ =\ 1000} $
- $ \color{red}{M\ =\ 10} $
- $ \color{red}{Q\ =\ 950} $

### 注意点

- **出力を行うたびに、末尾に改行を入れて標準出力を flush してください。** そうしなかった場合、ジャッジ結果が TLE や WA となる可能性があります。
- 解答を出力したら (または `-1` を受け取ったら) ただちにプログラムを終了してください。そうしない場合、ジャッジ結果は不定です。
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください。
- **この問題のジャッジシステムは、適応的(adaptive)です。** つまり、ジャッジシステムは、任意のタイミングにおいて、整合性がとれる限り、偽物の硬貨として想定しているものを変更する可能性があります。詳しくは入出力例も参照してください。

### 入出力例

この入力では $ N=5,M=2,Q=10 $ であり、ジャッジシステムは最初硬貨 $ 1,2 $ が偽物であると想定しています。

なお、この例は制約を満たさないので、ジャッジには含まれないことに注意してください。

入力出力説明`5 2 10`$ N,M,Q $ が与えられます。`? 1 2`硬貨 $ 1,2 $ について鑑定を行います。`0`硬貨 $ 1,2 $ は同種だと判定します。`? 1 3`硬貨 $ 1,3 $ について鑑定を行います。`1`硬貨 $ 1,3 $ は異種だと判定します。`? 1 4`硬貨 $ 1,4 $ について鑑定を行います。`1`硬貨 $ 1,4 $ は異種だと判定します。`! 1 2`硬貨 $ 1,2 $ が偽物だと解答します。確かに硬貨 $ 1,2 $ は偽物だと想定されていますが、硬貨 $ 3,4 $ を偽物であると想定しても整合性が取れます。  
よって、ジャッジシステムは偽物の硬貨として想定しているものを硬貨 $ 3,4 $ に変更できます。  
これにより、ジャッジシステムは不正解の判定を下すこともあります。

# AI分析结果



## 算法分类
**分组策略 + 基准比较**

---

## 综合分析与结论
### 核心思路与难点
- **核心逻辑**：利用假币数量少（M=10）的特点，将硬币分组后快速筛除非可疑组，再通过基准真币对比确定假币分布。
- **解决难点**：
  1. **分组优化**：每组11个硬币，通过10次询问即可确定组内是否存在假币。
  2. **基准真币**：利用假币数量限制，保证至少存在一个全真币组，作为后续判断基准。
  3. **动态验证**：通过基准真币与可疑组的交互，快速推导所有假币位置。

### 可视化设计
1. **分组动画**：  
   - 将1000个硬币按11个一组动态排列成网格，每组初始为绿色。  
   - 每次询问组内硬币时，高亮当前比较的硬币对，若返回异种（1），则标记该组为红色（可疑组）。  
   - 发现全同组时，整组变为金色（基准真币组）。

2. **基准验证阶段**：  
   - 基准真币（金色方块）逐个与可疑组的第一个硬币对比，异种则整组变为紫色（假币组），否则保持红色。  
   - 假币组内硬币根据与基准的关系动态标记（红色闪烁）。

3. **复古像素风格**：  
   - **颜色方案**：绿色（真币）、红色（可疑）、紫色（假币）、金色（基准）。  
   - **音效**：对比时播放“哔”声，发现假币组时播放“警报”音效，成功定位时播放胜利旋律。  
   - **Canvas动画**：硬币用16x16像素方块表示，状态变化时添加像素抖动效果。

---

## 题解清单（≥4星）
### 1. wmrqwq（★★★★★）
- **关键亮点**：分组策略清晰，逻辑严密，代码结构简洁。  
- **核心代码**：
  ```cpp
  forll(i,1,990,11) { // 分组询问
    forl(j,i+1,i+10) ask(i,j); 
    if(!bl[K]) _real = i; // 记录基准真币
  }
  forl(i,991,1000) ask(i,_real); // 处理剩余硬币
  ```

### 2. 官方题解（★★★★☆）
- **关键亮点**：代码极简，直接利用基准真币推导全组状态。  
- **核心逻辑**：
  ```cpp
  if (t) rel = st; // 全同组即基准真币
  for (int i : un) ask(i, rel); // 验证可疑组
  ```

### 3. WuMin4（★★★★☆）
- **关键亮点**：动态处理可疑组，自动排除无效分支。  
- **优化技巧**：通过异或操作快速翻转组内状态。

---

## 最优思路提炼
1. **分组策略**：每组大小11，利用假币数量上限快速筛除非可疑组。
2. **基准真币定位**：全同组必为真币，作为后续判断的“锚点”。
3. **动态推导**：通过基准与可疑组的单次对比，推导整组真假状态。

---

## 类似题目推荐
1. **洛谷 P1031**：均分纸牌（分组策略与动态调整）  
2. **洛谷 P2676**：超级书架（利用极值快速筛选）  
3. **Codeforces 1527C**：Sequence Pair Weight（分组统计与动态验证）

---

## 可视化代码片段
```javascript
// Canvas绘制硬币组（伪代码）
function drawCoins() {
  ctx.fillStyle = "#2ecc71"; // 默认绿色
  groups.forEach((group, idx) => {
    if (group.isFake) ctx.fillStyle = "#e74c3c"; // 可疑组红色
    if (group.isBase) ctx.fillStyle = "#f1c40f"; // 基准组金色
    group.coins.forEach(coin => {
      ctx.fillRect(coin.x, coin.y, 16, 16); 
    });
  });
}

// 播放音效（Web Audio API）
function playSound(type) {
  const osc = audioCtx.createOscillator();
  osc.frequency.setValueAtTime(type === 'compare' ? 440 : 880, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}
```

---

## 个人心得摘录
- **调试教训**：需严格处理交互输出格式，遗漏`flush`会导致WA。  
- **顿悟时刻**：假币数量限制是分组大小的关键依据，而非硬币总数。  
- **优化技巧**：异或运算可快速翻转组内状态，减少条件判断。

---

## 核心算法演示
### 动画流程
1. **初始化分组**：硬币排列为90x11的网格，最后一行为剩余10个。  
2. **组内对比**：逐组高亮对比，可疑组标记红色（按`M=10`限制，最多10组）。  
3. **基准确认**：首个全绿组变为金色，作为全局基准。  
4. **动态验证**：基准逐个与红色组首对比，异种则整组标记紫色，同步更新内部硬币状态。  
5. **剩余处理**：最后一行的10个硬币与基准对比，紫色标记假币。

### 交互控制
- **速度滑块**：控制动画步进间隔（100ms~2000ms）。  
- **AI模式**：自动播放时，关键步骤添加文字提示（如“发现基准真币！”）。

---
处理用时：62.18秒
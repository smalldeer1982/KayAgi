# 题目信息

# 長いだけのネクタイ (Just Long Neckties)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_a

あなたは Just Odd Inventions 社を知っているだろうか？この会社の業務は「ただ奇妙な発明 (just odd inventions)」をすることである．ここでは略して JOI 社と呼ぶ．

JOI 社は新商品「長いだけのネクタイ」を開発した．ネクタイは $ N\ +\ 1 $ 種類あり，各種類には $ 1 $ から $ N\ +\ 1 $ までの番号がついている．$ i $ 番目 ($ 1\ \leqq\ i\ \leqq\ N\ +\ 1 $) の種類のネクタイの長さは $ A_i $ である．

JOI 社は社員を集め，ネクタイの試着会を行うことにした．試着会には $ N $ 人の社員が参加し，$ j $ 人目 ($ 1\ \leqq\ j\ \leqq\ N $) の社員がはじめに付けているネクタイの長さは $ B_j $ である．

試着会は以下の手順で行われる予定である．

1. まず，試着会で使わないネクタイを $ 1 $ 種類選ぶ．
2. 次に，各社員はそれ以外のネクタイから試着するネクタイを $ 1 $ 種類選ぶ．ただし，どの $ 2 $ 人も同じ種類のネクタイを選ばないようにする．
3. 最後に，各社員は今付けているネクタイを外し，先ほど選んだネクタイを試着する．

長さ $ b $ のネクタイを付けていた社員が，長さ $ a $ のネクタイを試着すると大きさ $ \max\{a\ −\ b,\ 0\} $ の奇妙さを感じる．(ここで，$ \max\{a\ −\ b,\ 0\} $ は，$ a\ -\ b $ と $ 0 $ のうち小さくない方を表す．) 試着会において各社員の感じる奇妙さの最大値を，その試着会の**奇妙さ**とする．

試着会で使わないネクタイが $ k $ 番目の種類のネクタイのとき，試着会の奇妙さとして考えられる最小の値を $ C_k $ とする．

各種類のネクタイの長さ，各社員がはじめに付けているネクタイの長さが与えられた時，$ C_1,\ C_2,\ \ldots,\ C_{N\ +\ 1} $ の値を求めるプログラムを作成せよ．

- - - - - -

## 说明/提示

### 制約

- $ 1\ \leqq\ N\ \leqq\ 200\,000 $.
- $ 1\ \leqq\ A_i\ \leqq\ 1\,000\,000\,000 $ ($ 1\ \leqq\ i\ \leqq\ N\ +\ 1 $)．
- $ 1\ \leqq\ B_j\ \leqq\ 1\,000\,000\,000 $ ($ 1\ \leqq\ j\ \leqq\ N $)．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 10 $.
2. ($ 8 $ 点) $ N\ \leqq\ 2\,000 $.
3. ($ 91 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

例えば，試着会は次のように行われる． - $ 4 $ 番目の種類のネクタイを使わないことにする． - 社員 $ 1 $ が $ 1 $ 番目の，社員 $ 2 $ が $ 2 $ 番目の，社員 $ 3 $ が $ 3 $ 番目の種類のネクタイを選ぶ． - 各社員が試着する． このとき，各社員が感じる奇妙さは順に $ 2,\ 0,\ 3 $ となるから，この試着会の奇妙さは $ 3 $ である． 社員が選ぶネクタイを変えることで、試着会の奇妙さを $ 1 $ にすることができる．例えば，試着会を次のように行うとする． - $ 4 $ 番目の種類のネクタイを使わないことにする． - 社員 $ 1 $ が $ 2 $ 番目の，社員 $ 2 $ が $ 3 $ 番目の，社員 $ 3 $ が $ 1 $ 番目の種類のネクタイを選ぶ． - 各社員が試着する． このとき，各社員が感じる奇妙さは順に $ 1,\ 1,\ 0 $ となるから，この試着会の奇妙さは $ 1 $ である． これが $ 4 $ 番目の種類のネクタイを使わない場合の試着会の奇妙さの最小値なので，$ C_4\ =\ 1 $ である． - - - - - -

## 样例 #1

### 输入

```
3
4 3 7 6
2 6 4```

### 输出

```
2 2 1 1```

## 样例 #2

### 输入

```
5
4 7 9 10 11 12
3 5 7 9 11```

### 输出

```
4 4 3 2 2 2```

# AI分析结果



---

### **算法分类**  
贪心

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
1. **排序贪心**：将 $A$ 和 $B$ 数组排序，使得每个 $A_i$ 与 $B_i$ 匹配时差值最小。  
2. **前缀与后缀预处理**：  
   - **前缀数组** `pre[i]`：记录排序后的 $A$ 中前 $i$ 个元素与 $B$ 前 $i$ 个元素匹配的最大差值。  
   - **后缀数组** `suf[i]`：记录排序后的 $A$ 中从 $i+1$ 开始的元素与 $B$ 从 $i$ 开始的元素匹配的最大差值。  
3. **快速查询**：对于每个被移除的 $A_k$，其答案即 `max(pre[k-1], suf[k])`。  

**关键难点**：  
1. **原数组索引恢复**：排序后需保留原数组索引，以便正确输出答案。  
2. **高效预处理**：需在 $O(N)$ 时间内完成前缀和后缀数组的计算。  

---

### **题解评分 (≥4星)**  
1. **DgNeHzL7777 (⭐⭐⭐⭐⭐)**  
   - 思路清晰，预处理 `maxx` 和 `d` 数组，逻辑简洁。  
   - 代码可读性强，注释详细。  
   - 核心亮点：通过后缀最大值滚动更新优化空间。  
   - 个人心得：通过样例分析验证预处理逻辑。  

2. **WZWZWZWY (⭐⭐⭐⭐)**  
   - 使用结构体保留原索引，避免索引混乱。  
   - 代码简洁，直接通过前缀和后缀数组计算答案。  
   - 亮点：无需复杂数据结构，纯数组操作。  

3. **1234567890sjx (⭐⭐⭐⭐)**  
   - 提供暴力与优化代码对比，便于理解优化思路。  
   - 核心亮点：证明贪心策略的正确性。  

---

### **最优思路或技巧提炼**  
1. **贪心排序**：将 $A$ 和 $B$ 排序后一一匹配，确保差值最小。  
2. **前后缀分离**：将移除元素后的数组分为前缀和后缀，分别计算最大值。  
3. **滚动更新后缀**：从后往前遍历，动态更新后缀最大值，避免额外空间。  

---

### **同类型题或类似算法套路**  
1. **区间分配问题**：如将任务分配给工人，最小化最大处理时间。  
2. **前后缀最值优化**：如滑动窗口中的最大值预处理。  

---

### **推荐相似题目**  
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）  
2. **P1106 删数问题**（贪心选择最小字典序）  
3. **P1803 凌乱的yyy / 线段覆盖**（贪心选择活动）  

---

### **个人心得摘录**  
- **索引处理**：排序后需通过结构体或额外数组保留原索引，否则输出顺序会混乱。  
- **边界处理**：前缀和后缀数组的起始和结束位置需仔细验证。  

---

### **可视化与算法演示**  
**核心算法流程**：  
1. **排序动画**：展示 $A$ 和 $B$ 数组从小到大排序过程。  
2. **前缀与后缀高亮**：  
   - 用绿色标记前缀区间 `pre[i-1]`，红色标记后缀区间 `suf[i]`。  
   - 动态显示移除元素后，前后缀的最大值计算。  
3. **滚动更新**：  
   - 从右向左遍历，实时更新后缀最大值，用黄色高亮当前更新的 `suf[i]`。  

**复古像素风格设计**：  
- **8位色块**：用像素块表示数组元素，排序时交换色块位置。  
- **音效触发**：  
  - 排序完成时播放上扬音效。  
  - 计算最大值时播放短促“滴”声。  

**交互控制**：  
- **步进执行**：允许单步查看前后缀计算过程。  
- **速度调节**：滑动条控制动画速度。  

---

### **代码片段 (核心逻辑)**  
```cpp
// 预处理前缀和后缀
sort(a, a + n + 2);
sort(b, b + n);
for (int i = 1; i <= n; i++) {
    pre[i] = max(pre[i-1], a[i] - b[i-1]);
}
for (int i = n; i >= 1; i--) {
    suf[i] = max(suf[i+1], a[i+1] - b[i-1]);
}
// 计算答案
for (int i = 1; i <= n + 1; i++) {
    ans[i] = max(pre[i-1], suf[i]);
}
```

---

### **总结**  
本题通过排序贪心和前后缀预处理，将时间复杂度优化至 $O(N \log N)$，核心在于分离前缀和后缀的最值计算。可视化设计通过动态高亮和复古音效增强理解，适合教学与算法演示。

---
处理用时：71.44秒
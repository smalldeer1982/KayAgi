# 题目信息

# [AGC053B] Taking the middle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc053/tasks/agc053_b

$ 2N $ 枚のカードがあり、それぞれには $ 1 $ から $ 2N $ までの番号が付いています。カード $ i $ の価値は $ V_i $ です。 高橋君と青木君は以下の手順を $ N $ 回繰り返し、カードを $ N $ 枚ずつに分配します。

- まず、高橋君がまだ選ばれてないカードの中から $ 1 $ 枚選び、自分のものとする。 その後、青木君はまだ選ばれてないカードのうち **番号** が中央値であるものを選び、自分のものとする。

高橋君が最終的に持っているカードの価値の総和として考えられる最大の値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ 0\leq\ V_i\leq\ 10^9 $
- $ V_i $ は整数

### Sample Explanation 1

以下のような手順で、高橋君はカード $ 4,5,6 $ を手にすることができます。 - まず、高橋君はカード $ 6 $ を選ぶ。そして、青木君はカード $ 3 $ を選ぶ。 - 次に、高橋君はカード $ 5 $ を選ぶ。そして、青木君はカード $ 2 $ を選ぶ。 - 最後に、高橋君はカード $ 4 $ を選ぶ。そして、青木君はカード $ 1 $ を選ぶ。

## 样例 #1

### 输入

```
3

1 2 3 4 5 6```

### 输出

```
15```

## 样例 #2

### 输入

```
4

1 4 5 8 7 6 3 2```

### 输出

```
20```

# AI分析结果



---

**算法分类**：贪心、优先队列（堆）

---

### **题解思路与算法要点**

1. **核心思路**  
   - **转换问题**：总和固定，高桥最大化自己的总和等价于让青木的总和尽可能小。
   - **贪心策略**：每次将当前可选的两个极端值（左半部分和右半部分的对应位置）加入小根堆，弹出最小值，保证青木总和最小。

2. **解决难点**  
   - **确定可选区间**：第 \(i\) 轮时，青木只能从区间 \([n-i+1, n+i]\) 中选择中位数。通过维护左右指针，逐步扩展可选范围。
   - **堆的维护**：每次将左右指针指向的值加入堆，弹出最小值，累计青木的总和。

3. **关键数据结构**  
   - **小根堆**：动态维护当前可选的最小值，确保每次青木选择最小的可能值。

---

### **最优题解评分（≥4星）**

1. **作者：suzhikz**  
   - **评分**：★★★★★  
   - **亮点**：代码简洁，直接点出贪心核心，通过堆维护最小值。
2. **作者：hellolin**  
   - **评分**：★★★★☆  
   - **亮点**：清晰说明区间扩展逻辑，代码可读性强。
3. **作者：ImposterAnYu**  
   - **评分**：★★★★☆  
   - **亮点**：详细模拟栈操作，帮助理解区间扩展过程。

---

### **最优思路提炼**

- **关键技巧**：将左右半部分的对应位置值配对，利用堆动态维护最小值。
- **代码实现**：
  1. 计算所有卡的总和。
  2. 维护左右指针，每次将左右指针的值加入小根堆，弹出堆顶。
  3. 最终答案为总和减去弹出的所有堆顶之和。

---

### **同类型题与算法套路**

- **类似问题**：需要动态维护可选极值的场景（如区间覆盖、反悔贪心）。
- **通用解法**：优先队列处理动态极值选择，例如合并果子、任务调度。

---

### **推荐题目**

1. **P1090 合并果子**（贪心+优先队列）  
2. **P2168 荷马史诗**（哈夫曼树+堆优化）  
3. **P4053 建筑抢修**（反悔贪心）

---

### **个人心得摘录**

- **作者：ImposterAnYu**：通过模拟栈操作理解青木的选择逻辑，手模验证思路。
- **作者：Halberd_Cease**：将问题转化为合法选法问题，强调前 \(i\) 项选择的约束条件。

---

### **可视化与算法演示**

1. **动画设计**：  
   - **指针移动**：左右指针逐步向两端扩展，每次加入两个值到堆中。  
   - **堆操作**：高亮新加入的值，弹出最小值时显示红色标记。  
   - **总和更新**：实时显示青木总和和高桥剩余值。

2. **复古像素风格**：  
   - **颜色方案**：使用8位色调（青木卡用蓝色，高桥卡用绿色，堆操作用黄色闪烁）。  
   - **音效**：弹出堆顶时播放“滴”声，指针移动时播放轻微音效。  
   - **Canvas动画**：将卡排列为左右两列，堆以动态方块表示。

3. **交互功能**：  
   - **步进控制**：允许单步执行，观察堆的变化。  
   - **自动模式**：AI自动运行，展示贪心过程。

---

**核心代码片段**：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n; cin >> n;
    vector<int> v(2*n+1);
    long long total = 0;
    for (int i=1; i<=2*n; i++) {
        cin >> v[i];
        total += v[i];
    }
    priority_queue<int, vector<int>, greater<int>> pq;
    int l = n, r = n+1;
    for (int i=0; i<n; i++) {
        pq.push(v[l--]);
        pq.push(v[r++]);
        total -= pq.top();
        pq.pop();
    }
    cout << total << endl;
    return 0;
}
```

---

**总结**：通过贪心策略维护堆的最小值，确保青木总和最小，是高桥最优化的核心思路。

---
处理用时：75.62秒
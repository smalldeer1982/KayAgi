# 题目信息

# [ABC376C] Prepare Another Box

## 题目描述

有 $N$ 个玩具，编号从 $1$ 到 $N$ ，以及 $N-1$个箱子，编号从 $1$ 到 $N-1$。玩具 $i$ 的大小为$A_i$，箱子 $i$ 的大小为$B_i$。高桥君想把所有玩具分别放入不同的箱子中。他计划按以下步骤操作：

- 选择任意正整数 $x$，购买一个大小为 $x$ 的箱子。

- 将 $N$ 个玩具分别放入 $N$ 个箱子（包括原有的箱子和新购买的箱子）中，但每个玩具只能放入大小不小于该玩具的箱子，且每个箱子只能放一个玩具。

高桥君想通过购买合适大小的箱子来完成第 $2$ 步，但箱子越大价格越高，因此他想尽可能购买小箱子。请判断是否存在能满足条件的 $x$ 值，如果存在，请输出最小值；如果不存在，请输出 $-1$。

## 样例 #1

### 输入

```
4

5 2 3 7

6 2 8```

### 输出

```
3```

## 样例 #2

### 输入

```
4

3 7 2 5

8 1 6```

### 输出

```
-1```

## 样例 #3

### 输入

```
8

2 28 17 39 57 56 37 32

34 27 73 28 76 61 27```

### 输出

```
37```

# AI分析结果



## 算法分类
贪心

---

## 题解思路与解决难点

### 核心思路
1. **排序降序匹配**：将玩具和箱子分别按大小降序排序，优先尝试将最大的玩具放入最大的可用箱子。
2. **贪心匹配**：遍历排序后的玩具和箱子，若当前玩具无法放入当前箱子，则必须购买一个新箱子（大小为该玩具的尺寸），并确保后续所有玩具能放入剩余的箱子。
3. **后续验证**：找到第一个无法匹配的玩具后，需验证后续所有玩具是否能与剩余的箱子一一匹配，否则无解。

### 解决难点
- **贪心策略的正确性**：需证明“优先匹配最大玩具到最大箱子”的最优性，避免因小失大。
- **边界处理**：当插入新箱子后，需确保剩余玩具与箱子的对应关系正确，例如原箱子数组的索引越界问题。
- **时间复杂度优化**：通过排序和双指针遍历，将时间复杂度控制在 $O(n \log n)$，避免暴力枚举的低效。

---

## 题解评分（≥4星）

1. **huangrenheluogu 的题解（5星）**
   - **亮点**：代码简洁，直接通过排序和逆序匹配快速定位需购买的箱子，并通过循环验证后续所有条件。
   - **代码片段**：
     ```cpp
     sort(a + 1, a + n + 1), sort(b + 1, b + n);
     reverse(a + 1, a + n + 1), reverse(b + 1, b + n);
     for(int i = 1; i <= n; i++){
         if(a[i] > b[i]){
             ans = a[i];
             for(int j = i + 1, k = i; j <= n; j++, k++){
                 if(a[j] > b[k]) { /* 验证后续 */ }
             }
         }
     }
     ```

2. **MLE_Automaton 的题解（4星）**
   - **亮点**：二分答案思路清晰，通过检查下标确定最小可行解，适合处理大规模数据。
   - **代码片段**：
     ```cpp
     bool check(int x) {
         rep(i, 1, n) if (i != x && a[i] > b[i - (i > x)]) return 0;
         return 1;
     }
     ```

3. **Anins 的题解（4星）**
   - **亮点**：双指针遍历明确，通过动态调整指针处理贪心匹配，逻辑直观。
   - **代码片段**：
     ```cpp
     sort(a + 1, a + n + 1, cmp);
     sort(b + 1, b + n, cmp);
     for(int ai=1, bi=1; ai<=n && bi<n; ai++) {
         if(b[bi] < a[ai]) { ans = a[ai]; }
         else bi++;
     }
     ```

---

## 最优思路提炼

### 关键贪心策略
- **降序排序**：将玩具和箱子分别降序排列，确保优先处理最大元素。
- **双指针匹配**：用双指针 `i`（玩具）和 `j`（箱子）遍历，若当前玩具可放入当前箱子，则共同后移；否则记录该玩具为待购买箱子的尺寸，并验证后续所有玩具是否可放入剩余箱子。
- **后续验证**：若存在多个无法匹配的玩具，则无解。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, a[N], b[N], ans;

int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for(int i = 1; i < n; i++) scanf("%d", &b[i]);
    sort(a + 1, a + n + 1, greater<int>());
    sort(b + 1, b + n, greater<int>());
    bool valid = true;
    int j = 1, required = -1;
    for(int i = 1; i <= n; i++){
        if(j < n && a[i] <= b[j]) j++; // 匹配原有箱子
        else {
            if(required != -1) { valid = false; break; } // 已有需购买的箱子
            required = a[i]; // 记录需购买的箱子尺寸
        }
    }
    if(valid && required != -1) {
        for(int k = j; k < n; k++) { // 检查剩余玩具与箱子
            if(a[k + 1] > b[k]) { valid = false; break; }
        }
    }
    printf("%d\n", valid ? required : -1);
    return 0;
}
```

---

## 同类型题目推荐
1. **P1090 合并果子**：贪心选择最小堆，优先合并小果子。
2. **P1803 线段覆盖**：按右端点排序，贪心选择最早结束的线段。
3. **P1106 删数问题**：贪心删除高位较大的数字。

---

## 可视化与算法演示

### 核心算法流程
1. **排序动画**：展示玩具和箱子降序排列的过程，用不同颜色区分。
2. **双指针匹配**：高亮当前比较的玩具和箱子，绿色表示匹配成功，红色表示失败需购买箱子。
3. **后续验证**：在购买箱子后，逐步验证剩余玩具能否放入剩余箱子，用黄色高亮当前检查的元素。

### 复古像素化设计
- **颜色方案**：玩具（蓝色方块）、原有箱子（绿色方块）、新购箱子（红色方块）。
- **音效触发**：匹配成功（8-bit 上升音效）、失败（短促低音）、最终结果（胜利/失败音效）。
- **Canvas 绘制**：用网格布局展示排序后的数组，动态更新指针位置和状态。

---

## 个人心得
- **调试经验**：需特别注意数组越界问题，如原箱子数组长度为 $n-1$，遍历时需确保索引有效。
- **顿悟点**：贪心策略中“优先处理最大元素”是关键，避免因小失大，确保全局最优。

---
处理用时：178.52秒
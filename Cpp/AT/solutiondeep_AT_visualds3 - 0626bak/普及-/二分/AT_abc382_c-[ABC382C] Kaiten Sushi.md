# 题目信息

# [ABC382C] Kaiten Sushi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_c

とある回転寿司に、$ 1 $ から $ N $ までの番号が付けられた $ N $ 人の人が訪れています。 人 $ i $ の **美食度** は $ A_i $ です。

今からベルトコンベア上を $ M $ 個の寿司が流れます。 $ j $ 番目に流れる寿司の **美味しさ** は $ B_j $ です。 それぞれの寿司は、人 $ 1,2,\dots,N $ の前をこの順に流れていきます。 それぞれの人は、美味しさが自分の美食度以上である寿司が自分の前に流れてきたときはその寿司を取って食べ、それ以外のときは何もしません。 人 $ i $ が取って食べた寿司は、人 $ j\ (j\ >\ i) $ の前にはもう流れてきません。

$ M $ 個の寿司それぞれについて、その寿司を誰が食べるか、あるいは誰も食べないかどうかを求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N,M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i,B_i\ \leq\ 2\times\ 10^5 $
- 入力は全て整数
 
### Sample Explanation 1

\- $ 1 $ 番目の寿司について、 - まず人 $ 1 $ の前を流れます。$ B_1\ \geq\ A_1 $ なので、人 $ 1 $ はこれを取って食べます。 - 人 $ 2,3 $ の前にはこの寿司は流れてきません。 - $ 2 $ 番目の寿司について、 - まず人 $ 1 $ の前を流れます。$ B_2\ <\ A_1 $ なので、人 $ 1 $ は何もしません。 - 次に人 $ 2 $ の前を流れます。$ B_2\ <\ A_2 $ なので、人 $ 2 $ は何もしません。 - 最後に人 $ 3 $ の前を流れます。$ B_2\ \geq\ A_3 $ なので、人 $ 3 $ はこれを取って食べます。 - $ 3 $ 番目の寿司について、 - まず人 $ 1 $ の前を流れます。$ B_3\ <\ A_1 $ なので、人 $ 1 $ は何もしません。 - 次に人 $ 2 $ の前を流れます。$ B_3\ <\ A_2 $ なので、人 $ 2 $ は何もしません。 - 最後に人 $ 3 $ の前を流れます。$ B_3\ <\ A_3 $ なので、人 $ 3 $ は何もしません。 - よって、誰もこの寿司を食べません。

## 样例 #1

### 输入

```
3 3

3 8 2

5 2 1```

### 输出

```
1

3

-1```

## 样例 #2

### 输入

```
3 3

1 1 1

1 1 1```

### 输出

```
1

1

1```

## 样例 #3

### 输入

```
10 5

60 83 76 45 70 91 37 58 94 22

70 39 52 33 18```

### 输出

```
1

7

4

10

-1```

# AI分析结果



**唯一算法分类**：二分查找 + 前缀预处理

---

### 题解思路与算法要点

#### 核心思路
1. **预处理前缀最小值数组**：计算每个位置前i个人的美食度最小值，形成单调不增序列。
2. **二分查找**：对每个寿司的美味度，在前缀最小值数组中二分查找第一个满足条件的位置。
3. **单调性利用**：前缀数组的单调性保证了二分的正确性，快速定位到最早可能吃寿司的人。

#### 解决难点
- **暴力解法超时**：直接遍历每个寿司和人的复杂度为O(NM)，无法处理2e5规模数据。
- **单调性发现**：前缀最小值数组具有单调不增特性，使得可用二分将时间复杂度优化至O(M log N)。
- **数据结构选择**：无需复杂结构，仅用数组存储预处理结果即可。

---

### 题解评分（≥4星）

1. **FlowerAccepted（5星）**
   - **亮点**：代码简洁，利用STL的`lower_bound`和`greater`参数正确处理降序数组。
   - **代码可读性**：清晰的预处理和二分逻辑，变量命名合理。
   - **优化程度**：完美利用单调性，时间复杂度最优。

2. **Lian_zy（4星）**
   - **亮点**：手写二分逻辑，更易理解二分边界处理。
   - **代码可读性**：结构清晰，但变量名较简略。
   - **实践性**：适合对STL不熟悉的读者学习手写二分。

3. **hjyowl（4星）**
   - **亮点**：代码规范，包含完整输入输出优化。
   - **特殊处理**：对无解情况的显式判断，逻辑更直观。

---

### 最优思路提炼

1. **前缀最小值预处理**  
   计算`c[i] = min(a[1..i])`，形成单调不增数组，例如：
   - 输入`A = [3,8,2]` → `c = [3,3,2]`
   - 单调性保证二分可行性。

2. **反向二分查找**  
   使用`lower_bound(c, c+n+1, b_j, greater<int>())`找到第一个≤`b_j`的位置：
   ```cpp
   auto it = lower_bound(c + 1, c + n + 1, b, greater<int>());
   if (it != c.end()) answer = it - c;
   ```

3. **时间复杂度优化**  
   - 预处理O(N)
   - 查询O(M log N)

---

### 同类型题与类似套路

1. **单调性预处理+二分**  
   - 如滑动窗口最小值、最长递增子序列等。
   - 例：LeetCode 300. 最长递增子序列（利用单调性优化DP）。

2. **前缀最值应用**  
   - 如区间最值查询（RMQ）问题。
   - 例：洛谷P1440 求区间最小值。

---

### 推荐相似题目

1. **洛谷P1440**  
   - 题目：求每个窗口的最小值，需单调队列优化。
   - 核心：利用数据结构维护单调性。

2. **LeetCode 739. 每日温度**  
   - 题目：找后续更高温度的天数。
   - 核心：单调栈处理序列单调性。

3. **AtCoder ABC245D**  
   - 题目：多项式系数计算，前缀处理思想。
   - 核心：利用递推优化多项式运算。

---

### 个人心得摘录

- **FlowerAccepted**提到：“暴力思路复杂度O(NM)明显超时，必须寻找单调性”——强调发现题目隐含的单调性特征。
- **Lian_zy**在代码注释中强调“判断是否找到”的边界条件，提醒注意无解情况的处理。

---

### 核心代码实现

```cpp
#include <algorithm>
#include <iostream>
using namespace std;

int a[200005], c[200005];

int main() {
    int n, m;
    cin >> n >> m;
    c[0] = 200005; // 初始化为极大值
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        c[i] = min(a[i], c[i-1]); // 前缀最小值
    }
    while (m--) {
        int b;
        cin >> b;
        // 在降序数组中找第一个≤b的位置
        auto it = lower_bound(c + 1, c + n + 1, b, greater<int>());
        if (it != c + n + 1 && *it <= b) {
            cout << (it - c) << '\n';
        } else {
            cout << "-1\n";
        }
    }
    return 0;
}
```

---

### 可视化设计要点

**动画方案**：  
1. **像素风格界面**  
   - 使用16色像素画风，寿司用黄色方块，人物用不同颜色表示美食度。
   - 每个寿司从左侧进入，依次经过人物队列。

2. **关键步骤高亮**  
   - 预处理阶段：从左到右逐个计算前缀最小值，当前处理的元素闪烁。
   - 二分阶段：用红色框标记搜索范围，绿色箭头指示mid位置。

3. **音效与交互**  
   - 预处理完成：播放“滴”声。
   - 寿司被吃掉：对应人物头顶弹出“EAT!”并播放咀嚼音效。
   - 无解时寿司飞出屏幕，伴随“失败”音效。

**交互控制**：  
- **速度调节**：滑块控制动画速度（0.5x~3x）。
- **单步执行**：按空格键逐帧观察二分过程。

---
处理用时：73.04秒
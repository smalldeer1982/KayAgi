# 题目信息

# [ABC388C] Various Kagamimochi

## 题目描述

有 $N$ 个大小不一的饼。第 $i$ 个饼的大小为 $a_i$（$1 \le i \le N$）。

对于任意两个大小分别为 $a$ 和 $b$ 的饼 $A$ 和 $B$，如果 $a$ 小于或等于 $b$ 的一半，即 $a\le \frac{b}{2}$，则可以将饼 $A$ 放在饼 $B$ 上制作一个“镜饼”。

从 $N$ 个饼中任选两个，使得其中一个饼放在另一个饼上制作一个“镜饼”。

需要求出可以制作多少种不同的“镜饼”。

此外，即使构成镜饼的饼的大小相同，只要至少有一个是不同的饼，就可以算作是另一种类型的镜饼。

**Translate by [chinazhanghaoxun](https://luogu.com.cn/user/684848)。**

## 样例 #1

### 输入

```
6

2 3 4 4 7 10```

### 输出

```
8```

## 样例 #2

### 输入

```
3

387 388 389```

### 输出

```
0```

## 样例 #3

### 输入

```
32

1 2 4 5 8 10 12 16 19 25 33 40 50 64 87 101 149 175 202 211 278 314 355 405 412 420 442 481 512 582 600 641```

### 输出

```
388```

# AI分析结果



**算法分类**：双指针 / 二分查找

---

### **题解思路与核心难点**
题目要求统计满足 $a_i \le \frac{a_j}{2}$ 的有序对 $(i,j)$ 的数量。核心思路是将数组排序后，通过以下两种方式高效统计：
1. **双指针法**：排序后，对每个元素 $a_i$（作为上面的饼），找到满足 $a_j \ge 2a_i$ 的最小 $j$，累加 $n-j+1$。
2. **二分法**：对每个元素 $a_i$，使用二分查找找到第一个 $a_j \ge 2a_i$ 的位置，累加后续元素数量。

**解决难点**：
- **高效统计**：直接暴力枚举会超时，双指针或二分法能将时间复杂度优化至 $O(n \log n)$。
- **边界处理**：指针移动条件和二分查找的终止条件需精确处理。

---

### **题解评分（≥4星）**
1. **ikunTLE（5星）**  
   - 思路清晰，双指针法实现简洁，时间复杂度 $O(n)$。
   - 代码可读性强，变量命名合理。
2. **IronMen（4星）**  
   - 使用 `lower_bound` 二分查找，代码简短。
   - 未显式排序数组，需注意输入是否已排序（实际代码中已排序）。
3. **zzwdsj（4星）**  
   - 直接转化为二分问题，代码简洁高效。
   - 变量命名和代码结构较清晰。

---

### **最优思路与技巧提炼**
- **双指针法**（ikunTLE）：
  1. **排序数组**：升序排列后，每个元素作为上面的饼时，只需考虑后面的元素。
  2. **线性扫描**：维护两个指针 $i$ 和 $j$，均单向移动，确保时间复杂度 $O(n)$。
- **关键代码**：
  ```cpp
  sort(a+1, a+n+1);
  for (int i=1, j=1; i<=n; ++i) {
      while (j<=n && a[i]*2 > a[j]) ++j;
      ans += n-j+1;
  }
  ```

---

### **同类型题目与套路**
- **相似算法题**：
  1. **P1102 A-B数对**：统计差值为给定值的数对数目（双指针/哈希表）。
  2. **P1638 连续自然数的和**：寻找连续子数组满足特定条件（双指针）。
  3. **CF977D 递增三元组**：组合条件统计（排序+二分）。

---

### **个人心得摘录**
- **数据类型**：不开 `long long` 可能导致溢出（如样例3的答案较大）。
- **排序方向**：需根据处理逻辑选择升序或降序，影响指针移动方向。

---

### **可视化设计思路**
- **动画演示**：  
  1. **排序步骤**：展示数组排序过程，突出升序排列。
  2. **双指针移动**：用不同颜色标记 $i$ 和 $j$，动态显示满足条件的区间。
  3. **计数更新**：每次找到 $j$ 后，高亮 $[j, n]$ 区间并累加答案。
- **交互功能**：支持单步执行，调节速度观察指针移动。

---

### **代码实现（双指针法）**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e5 + 10;
int a[N];

signed main() {
    int n; cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    sort(a + 1, a + n + 1);
    int ans = 0;
    for (int i = 1, j = 1; i <= n; ++i) {
        while (j <= n && a[i] * 2 > a[j]) ++j;
        ans += n - j + 1;
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：224.47秒
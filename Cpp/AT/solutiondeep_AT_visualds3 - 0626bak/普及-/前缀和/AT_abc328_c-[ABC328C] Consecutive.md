# 题目信息

# [ABC328C] Consecutive

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc328/tasks/abc328_c

英小文字のみからなる長さ $ N $ の文字列 $ S\ =\ S_1S_2\ldots\ S_N $ が与えられます。

また、$ S $ に関する $ Q $ 個の質問が与えられます。 $ i\ =\ 1,\ 2,\ \ldots,\ Q $ について、$ i $ 番目の質問は $ 2 $ つの整数 $ l_i,\ r_i $ で表される下記の質問です。

> $ S $ の $ l_i $ 文字目から $ r_i $ 文字目までからなる部分文字列 $ S_{l_i}S_{l_i+1}\ldots\ S_{r_i} $ において、 同じ英小文字が $ 2 $ つ隣りあう箇所は何個ありますか？ すなわち、$ l_i\ \leq\ p\ \leq\ r_i-1 $ かつ $ S_p\ =\ S_{p+1} $を満たす整数 $ p $ は何個ありますか？

$ Q $ 個の質問それぞれの答えを出力してください。

## 说明/提示

### 制約

- $ N,\ Q $ は整数
- $ 1\ \leq\ N,\ Q\ \leq\ 3\ \times\ 10^5 $
- $ S $ は英小文字のみからなる長さ $ N $ の文字列
- $ l_i,\ r_i $ は整数
- $ 1\ \leq\ l_i\ \leq\ r_i\ \leq\ N $
 
### Sample Explanation 1

$ 4 $ 個の質問それぞれに対する答えは下記の通りです。 - $ 1 $ 個目の質問に関して、$ S_3S_4\ldots\ S_9\ = $ `ssissip` で同じ英小文字が隣り合う箇所は、$ S_3S_4\ = $ `ss` と $ S_6S_7\ = $ `ss` の $ 2 $ 個です。 - $ 2 $ 個目の質問に関して、$ S_4S_5\ldots\ S_{10}\ = $ `sissipp` で同じ英小文字が隣り合う箇所は、$ S_6S_7\ = $ `ss` と $ S_9S_{10}\ = $ `pp` の $ 2 $ 個です。 - $ 3 $ 個目の質問に関して、$ S_4S_5S_6\ = $ `sis` で同じ英小文字が隣り合う箇所は $ 0 $ 個です。 - $ 4 $ 個目の質問に関して、$ S_7\ = $ `s` で同じ英小文字が隣り合う箇所は $ 0 $ 個です。

### Sample Explanation 2

$ S_1S_2\ldots\ S_5\ = $ `aaaaa` で同じ英小文字が隣り合う箇所は、 $ S_1S_2\ = $ `aa` 、$ S_2S_3\ = $ `aa` 、$ S_3S_4\ = $ `aa` 、$ S_4S_5\ = $ `aa` の $ 4 $ 個です。

## 样例 #1

### 输入

```
11 4

mississippi

3 9

4 10

4 6

7 7```

### 输出

```
2

2

0

0```

## 样例 #2

### 输入

```
5 1

aaaaa

1 5```

### 输出

```
4```

# AI分析结果



## 算法分类
前缀和

---

## 综合分析与结论

### 题解思路与难点
题目要求快速统计字符串区间内相邻相同字符对的数量。由于数据规模较大（$N,Q \leq 3 \times 10^5$），暴力法会超时。核心思路为：
1. **预处理前缀和数组**：遍历字符串，记录每个位置 $i$ 处是否与前一个字符相等，并用前缀和数组累加。
2. **快速查询**：通过前缀和差值 $sum[r-1] - sum[l-1]$ 直接得到区间 $[l, r-1]$ 内的符合条件的对数。

**难点**：
- **索引处理**：需明确字符串的存储方式（0-based 或 1-based），确保预处理和查询时的边界正确。
- **时间复杂度**：必须保证预处理 $O(N)$ 和查询 $O(1)$，否则无法通过。

### 算法要点
1. **预处理数组**：标记每个位置 $i$ 是否满足 $s[i] = s[i-1]$，累加生成前缀和数组。
2. **查询优化**：利用前缀和数组的差值快速计算区间结果。

---

## 题解清单（评分≥4星）

1. **zhangboyong（4星）**
   - **关键亮点**：代码简洁，直接使用前缀和差值，无需特判。
   - **代码片段**：
     ```cpp
     for(int i = 1; i < len; i++) {
         if(s[i] == s[i-1]) d[i]++;
         d[i] += d[i-1];
     }
     ```

2. **CEFqwq（4星）**
   - **关键亮点**：显式处理字符串为 1-based，避免越界问题。
   - **代码片段**：
     ```cpp
     s[0] = '\0'; // 防止越界
     for(int i = 1; i <= n; i++) {
         if(s[i] == s[i-1]) a[i] = 1;
         b[i] = b[i-1] + a[i];
     }
     ```

3. **uid_647775（4星）**
   - **关键亮点**：明确使用艾佛森括号简化逻辑，代码可读性强。
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= n; i++) {
         f[i] = f[i-1] + (s[i] == s[i-1]);
     }
     ```

---

## 最优思路与技巧提炼
1. **前缀和核心逻辑**：将区间统计问题转化为前缀和差值问题。
2. **索引对齐**：统一字符串存储方式（如显式转为 1-based），避免越界和计算错误。
3. **无需特判**：直接通过前缀和数组的差值计算，无需额外处理边界。

---

## 同类型题与算法套路
- **类似问题**：区间和统计、区间最大值等。
- **通用解法**：前缀和、差分数组、线段树（动态区间查询）。

---

## 推荐洛谷题目
1. **P1714** - 求 m 子段最大和（前缀和+滑动窗口）
2. **P3406** - 海底高铁（差分与前缀和应用）
3. **P3661** - 牛式（区间统计问题）

---

## 个人心得摘录
- **索引调试**：多位题解强调需明确字符串索引方式，避免混淆。
- **预处理技巧**：前缀和数组的累加需从正确起点开始，确保查询逻辑正确。

---

## 可视化与算法演示
### 核心算法流程
1. **预处理动画**：
   - 遍历字符串，高亮比较 $s[i]$ 和 $s[i-1]$。
   - 若相等，标记为绿色并更新前缀和数组；否则标记为红色。
2. **查询动画**：
   - 显示区间 $[l, r-1]$，用颜色标注计算范围。
   - 动态显示前缀和差值计算过程。

### 复古像素风格设计
- **颜色方案**：绿色（匹配成功）、红色（匹配失败）、黄色（当前操作）。
- **音效**：匹配成功时播放短促“叮”声，查询完成时播放上扬音效。
- **Canvas 动画**：网格显示字符串字符，前缀和数组以滚动数字更新。

### 交互设计
- **步进控制**：用户可单步执行预处理或查询步骤。
- **自动播放**：展示算法全流程，速度可调。

---

## 代码实现（核心逻辑）
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, q;
    string s;
    cin >> n >> q >> s;
    vector<int> prefix(n, 0);
    for (int i = 1; i < n; ++i) {
        prefix[i] = prefix[i-1] + (s[i] == s[i-1]);
    }
    while (q--) {
        int l, r;
        cin >> l >> r;
        cout << prefix[r-1] - prefix[l-1] << '\n';
    }
    return 0;
}
```

---
处理用时：250.50秒
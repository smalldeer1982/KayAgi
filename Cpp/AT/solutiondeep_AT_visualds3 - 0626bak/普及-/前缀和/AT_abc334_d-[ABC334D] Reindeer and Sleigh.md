# 题目信息

# [ABC334D] Reindeer and Sleigh

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_d

$ N $ 台のソリがあり、各ソリには $ 1,2,\ldots,\ N $ の番号がつけられています。

ソリ $ i $ を引くために必要なトナカイは $ R_i $ 匹です。

また、各トナカイが引けるソリは高々 $ 1 $ 台です。より厳密には、$ m $ 台のソリ $ i_1,\ i_2,\ \ldots,\ i_m $ を引くために必要なトナカイは $ \sum_{k=1}^{m}\ R_{i_k} $ 匹です。

以下の形式のクエリが $ Q $ 個与えられるので、答えを求めてください。

- 整数 $ X $ が与えられる。トナカイが $ X $ 匹いるときに最大で何台のソリを引けるか求めよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ Q\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ R_i\ \leq\ 10^9 $
- $ 1\ \leq\ X\ \leq\ 2\ \times\ 10^{14} $
- 入力される数値はすべて整数
 
### Sample Explanation 1

トナカイが $ 16 $ 匹いるとき、ソリ $ 1,2,4 $ を引くことができます。 $ 16 $ 匹のトナカイで $ 4 $ 台のソリを引くことはできないので、クエリ $ 1 $ の答えは $ 3 $ となります。

## 样例 #1

### 输入

```
4 3

5 3 11 8

16

7

1000```

### 输出

```
3

1

4```

## 样例 #2

### 输入

```
6 6

1 2 3 4 5 6

1

2

3

4

5

6```

### 输出

```
1

1

2

2

2

3```

## 样例 #3

### 输入

```
2 2

1000000000 1000000000

200000000000000

1```

### 输出

```
2

0```

# AI分析结果



## 算法分类
**贪心算法 & 二分查找**

---

## 题解思路与核心难点
### 核心思路
1. **贪心策略**：要最大化雪橇数量，必须优先选择所需驯鹿最少的雪橇。因此将所有雪橇按所需驯鹿数升序排序。
2. **前缀和优化**：排序后计算前缀和数组 `sum`，其中 `sum[i]` 表示前 `i` 辆雪橇的总驯鹿数。
3. **二分查找**：对每个查询 `X`，在前缀和数组中二分查找最大的 `k`，使得 `sum[k] ≤ X`。

### 解决难点
- **快速处理多查询**：直接遍历每个查询的暴力方法时间复杂度为 O(QN)，无法处理大范围数据。前缀和+二分将时间复杂度优化至 O(N log N + Q log N)。
- **边界条件处理**：需确保二分查找正确找到最后一个满足条件的索引，避免遗漏或越界。

---

## 题解评分（≥4星）

### 1. qejwdi（5星）
- **亮点**：代码简洁，逻辑清晰，手写二分正确处理边界。
- **代码片段**：
  ```cpp
  sort(a + 1, a + n + 1);
  for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + a[i];
  while (q--) {
      int x; scanf("%lld", &x);
      int l = 0, r = n, ans = 0;
      while (l <= r) {
          int mid = (l + r) >> 1;
          if (sum[mid] <= x) ans = mid, l = mid + 1;
          else r = mid - 1;
      }
      printf("%lld\n", ans);
  }
  ```

### 2. CheZiHe929（5星）
- **亮点**：使用 `upper_bound` 简化代码，适合熟悉 STL 的开发者。
- **代码片段**：
  ```cpp
  sort(r + 1, r + n + 1);
  for (int i = 1; i <= n; i++) r[i] += r[i - 1];
  while (q--) {
      int x; cin >> x;
      int ans = upper_bound(r + 1, r + n + 1, x) - r - 1;
      cout << ans << endl;
  }
  ```

### 3. jubingkun（4星）
- **亮点**：添加了 `sum` 优化判断，提前处理极端情况。
- **代码片段**：
  ```cpp
  for (int i = 1; i <= n; i++) sum += a[i];
  sort(a + 1, a + n + 1);
  for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + a[i];
  while (q--) {
      cin >> x;
      if (x >= sum) cout << n << "\n";
      else {
          int b = upper_bound(pre + 1, pre + n + 1, x) - pre;
          cout << b - 1 << "\n";
      }
  }
  ```

---

## 最优思路提炼
1. **排序贪心**：升序排列雪橇，保证每次选择最小代价。
2. **前缀和预处理**：快速计算任意前 `k` 项的总和。
3. **二分加速查询**：利用前缀和的单调性，二分查找最大可行 `k`。

---

## 类似算法题目
1. **P1678 烦恼的高考志愿**（排序+二分找最小差值）
2. **P1182 数列分段 Section II**（二分答案+贪心验证）
3. **P2440 木材加工**（二分答案判断可行性）

---

## 个人心得摘录
- **jubingkun**：通过提前判断 `sum` 优化极端情况，避免不必要的二分。
- **CheZiHe929**：使用 `upper_bound` 简化代码，强调 STL 的实用性。

---

## 可视化算法演示
### 核心流程
1. **排序雪橇**：以像素块表示雪橇，按所需驯鹿数升序排列。
2. **前缀和计算**：动态显示每个位置的前缀和数值。
3. **二分查找**：高亮当前 `mid` 和对应的前缀和，比较与 `X` 的大小，调整搜索区间。

### 复古风格设计
- **像素动画**：雪橇用不同颜色像素块表示，驯鹿数显示在下方。
- **音效提示**：
  - **正确步骤**：清脆的“滴”声。
  - **越界/错误**：低沉的“嘟”声。
- **交互控制**：支持暂停/继续，拖动进度条调整动画速度。

### 示例步骤
1. 初始化排序后的雪橇数组，显示前缀和。
2. 输入 `X=16`，开始二分查找：
   - `mid=2`，`sum=8 ≤ 16` → 向右查找。
   - `mid=3`，`sum=19 > 16` → 向左查找。
   - 最终找到 `k=3`，显示选中前3辆雪橇。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2e5 + 10;
ll r[N], sum[N];

int main() {
    int n, q; cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> r[i];
    sort(r + 1, r + n + 1);
    for (int i = 1; i <= n; ++i) r[i] += r[i - 1];
    while (q--) {
        ll x; cin >> x;
        int ans = upper_bound(r + 1, r + n + 1, x) - r - 1;
        cout << ans << '\n';
    }
    return 0;
}
```

---
处理用时：98.98秒
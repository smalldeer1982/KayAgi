# 题目信息

# [ABC396C] Buy Balls

## 题目描述

现有 $N$ 个黑色球和 $M$ 个白色球。  
每个球都有一个价值：第 $i$ 个（$1 \leq i \leq N$）黑色球的价值为 $B_i$，第 $j$ 个（$1 \leq j \leq M$）白色球的价值为 $W_j$。

请选择 **零个或多个** 球，使得所选黑色球的数量 **不少于** 白色球的数量。求所选球的价值总和的最大可能值。

## 说明/提示

### 约束条件

- $1 \leq N, M \leq 2 \times 10^5$
- $-10^9 \leq B_i, W_j \leq 10^9$
- 输入中的所有值均为整数

### 样例解释 1

选择第 $1,2,4$ 个黑色球和第 $1$ 个白色球时，总价值为 $8 + 5 + 3 + 3 = 19$，这是最大值。

### 样例解释 2

选择第 $1,3$ 个黑色球和第 $1,3$ 个白色球时，总价值为 $5 + (-2) + 8 + 4 = 15$，这是最大值。

### 样例解释 3

允许不选择任何球，此时总价值为 $0$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4 3

8 5 -1 3

3 -2 -4```

### 输出

```
19```

## 样例 #2

### 输入

```
4 3

5 -10 -2 -5

8 1 4```

### 输出

```
15```

## 样例 #3

### 输入

```
3 5

-36 -33 -31

12 12 28 24 27```

### 输出

```
0```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **综合分析与结论**

**核心思路**：  
将黑球和白球分别按价值降序排序，优先选取价值高的正数球。通过预处理前缀和数组，枚举白球选取数量 `k`，计算对应的最大可能总和。此时黑球至少选 `k` 个，同时可以选取更多正数黑球。最终取所有可能 `k` 中的最大值。

**解决难点**：  
1. **满足数量约束**：黑球数量≥白球数量，需动态调整选取策略。  
2. **处理负数组合**：某些情况下，单个球为负但组合和为正，需合理取舍。  
3. **高效计算最大值**：通过前缀和与预处理数组，将时间复杂度优化至线性。

**可视化设计**：  
- **动画方案**：  
  1. 将黑球和白球降序排列，用不同颜色区分。  
  2. 高亮当前选中的白球 `k` 个和对应的黑球 `k` 个，计算总和。  
  3. 动态显示剩余黑球中正数的选取，逐步更新最大值。  
- **复古像素效果**：  
  - 用 8 位风格网格展示球的价值，选中时播放“叮”音效。  
  - 背景音乐循环播放，成功找到最大值时触发胜利音效。  
- **交互控制**：允许调整枚举速度，单步观察每个 `k` 的选取过程。

---

### **题解清单 (≥4星)**

1. **ybclch2026 (5星)**  
   - **亮点**：预处理前缀和与 `cur` 数组，高效枚举所有可能，覆盖全部情况。  
   - **代码片段**：  
     ```cpp
     for(int i=1;i<=n;i++) bb[i]=bb[i-1]+b[i];
     cur[n]=bb[n];
     for(int i=n-1;i>=0;i--) cur[i]=max(bb[i],cur[i+1]);
     ```

2. **FlowerAccepted (4星)**  
   - **亮点**：动态调整白球数量，确保黑球数量始终足够。  
   - **核心逻辑**：  
     ```cpp
     while (ansm > ansn && b[ansn + 1] + w[ansn + 1] > 0) {
         ansn++;
     }
     ```

3. **Tomwsc (4星)**  
   - **亮点**：双指针处理负数组合，动态选择最优调整策略。  
   - **代码片段**：  
     ```cpp
     if (a[l] + b[r] >= ans - b[r]) { ... }
     else if (r <= cnt1) { ... }
     ```

---

### **最优思路与技巧**

1. **降序排序**：优先处理高价值球，确保每一步局部最优。  
2. **前缀和优化**：快速计算子数组和，避免重复求和。  
3. **枚举白球数量**：结合黑球的前缀和最大值，动态确定最优解。  

---

### **相似题目推荐**

1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）  
2. **P1208 [USACO1.3] 混合牛奶 Mixing Milk**（排序+贪心）  
3. **P2240 【深基12.例1】部分背包问题**（价值密度贪心）

---

### **个人心得摘录**

- **调试教训**：处理负数组合时，需确保组合和为正，否则提前终止。  
- **顿悟点**：枚举白球数量后，黑球的最优选取可通过预处理极大优化效率。  

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 5;
long long b[MAXN], w[MAXN], bb[MAXN], ww[MAXN], cur[MAXN];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= m; i++) cin >> w[i];
    sort(b + 1, b + n + 1, greater<long long>());
    sort(w + 1, w + m + 1, greater<long long>());
    
    // 预处理前缀和与cur数组
    for (int i = 1; i <= n; i++) bb[i] = bb[i - 1] + b[i];
    cur[n] = bb[n];
    for (int i = n - 1; i >= 0; i--) cur[i] = max(bb[i], cur[i + 1]);
    for (int i = 1; i <= m; i++) ww[i] = ww[i - 1] + w[i];
    
    long long ans = 0;
    for (int k = 0; k <= min(n, m); k++) {
        ans = max(ans, ww[k] + cur[k]);
    }
    cout << ans << endl;
    return 0;
}
```

**代码解释**：  
- 排序后预处理黑球前缀和 `bb` 和最大值数组 `cur`。  
- 枚举白球数量 `k`，计算对应总和 `ww[k] + cur[k]`，取最大值。

---
处理用时：136.99秒
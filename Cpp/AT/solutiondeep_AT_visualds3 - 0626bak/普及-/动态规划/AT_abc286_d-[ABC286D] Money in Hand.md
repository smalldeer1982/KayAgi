# 题目信息

# [ABC286D] Money in Hand

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc286/tasks/abc286_d

高橋君は $ N $ 種類の硬貨をそれぞれ何枚か持っており、 具体的には、$ 1\leq\ i\leq\ N $ について $ A_i $ 円硬貨を $ B_i $ 枚持っています。

高橋君が現在持っている硬貨を用いて、（お釣りが出ないように）ちょうど $ X $ 円を支払うことができるか判定してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 50 $
- $ 1\leq\ X\leq\ 10^4 $
- $ 1\leq\ A_i\leq\ 100 $
- $ 1\leq\ B_i\leq\ 50 $
- $ A_i $ はすべて異なる。
- 入力はすべて整数
 
### Sample Explanation 1

高橋君は $ 2 $ 円硬貨を $ 3 $ 枚、$ 5 $ 円硬貨を $ 6 $ 枚持っています。 このうち、$ 2 $ 円硬貨を $ 2 $ 枚、$ 5 $ 円硬貨を $ 3 $ 枚用いることでちょうど $ 2\times\ 2+5\times\ 3=19 $ 円を支払うことができます。 よって、`Yes` を出力します。

### Sample Explanation 2

持っている硬貨をどのように組み合わせてもちょうど $ 18 $ 円を支払うことはできません。 よって、`No` を出力します。

### Sample Explanation 3

$ 1 $ 枚も使用しない硬貨が存在しても構いません。

## 样例 #1

### 输入

```
2 19

2 3

5 6```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 18

2 3

5 6```

### 输出

```
No```

## 样例 #3

### 输入

```
3 1001

1 1

2 1

100 10```

### 输出

```
Yes```

# AI分析结果



0. **题目翻译**  
# [ABC286D] 手头的钱

## 题目描述

高桥君持有 $N$ 种不同面值的硬币，每种硬币的具体情况为：对于 $1\leq\ i\leq\ N$，第 $i$ 种硬币面值为 $A_i$ 元，持有数量为 $B_i$ 枚。

请判断高桥君能否用现有硬币恰好支付 $X$ 元（不找零）。

## 输入格式

输入包含：
- 第一行两个整数 $N$ 和 $X$
- 随后 $N$ 行每行两个整数 $A_i$ 和 $B_i$

## 输出格式

若可以精确支付，输出 `Yes`；否则输出 `No`

## 样例 #1

输入：
```
2 19
2 3
5 6
```
输出：
```
Yes
```
说明：使用 2 元硬币 2 枚和 5 元硬币 3 枚（2×2 + 5×3 = 19）

## 样例 #2

输入：
```
2 18
2 3
5 6
```
输出：
```
No

```

## 样例 #3

输入：
```
3 1001
1 1
2 1
100 10
```
输出：
```
Yes
```

## 数据范围
- $1 \leq N \leq 50$
- $1 \leq X \leq 10^4$
- $A_i$ 互不相同，$1 \leq A_i \leq 100$，$1 \leq B_i \leq 50$

---

1. **唯一算法分类**  
多重背包

---

2. **综合分析与结论**  

**核心思路**：  
本题本质是判断在多重物品限制下能否恰好装满背包。每个硬币类型视为物品，面值 $A_i$ 为物品体积，数量 $B_i$ 为选择上限，背包容量为 $X$。需判断是否存在物品组合使总体积等于 $X$。

**状态转移方程**：  
一维 DP 数组优化版的核心转移逻辑：  
```math
f[j] = f[j] \lor f[j - k \cdot A_i] \quad (1 \leq k \leq B_i)
```
通过倒序枚举金额 $j$ 避免同一硬币的重复累加。

**可视化设计**：  
- **像素网格**：Canvas 绘制 $X+1$ 列网格，每格代表金额状态（绿色=可达，红色=不可达）。
- **动态更新**：处理第 $i$ 种硬币时，高亮当前硬币面值 $A_i$ 和对应的 $j-A_i$ 位置。
- **音效触发**：在状态更新时播放短促 "滴" 声，成功更新时音调升高。
- **自动演示**：按硬币顺序自动执行，每步间隔可调，展示 DP 数组逐步填充过程。

---

3. **题解清单 (≥4星)**  

⭐️⭐️⭐️⭐️⭐️ **yemuzhe 的题解**  
- **亮点**：一维 DP 空间优化，倒序循环处理多重限制，代码简洁高效  
- **核心代码**：  
```cpp
while (b--) {
    for (int i = m; i >= a; i--) {
        f[i] |= f[i - a];
    }
}
```

⭐️⭐️⭐️⭐️ **Neil_Qian 的题解**  
- **亮点**：明确指出正序/倒序枚举的关键差异，代码紧凑  
- **心得摘录**：  
> "倒序枚举 $j$ 避免同一硬币的重复使用，这是背包问题的经典优化技巧"

⭐️⭐️⭐️⭐️ **12345678hzx 的题解**  
- **亮点**：三重循环直观展示物品拆分过程，适合初学者理解  
- **代码片段**：  
```cpp
for(int j=1; j<=b[i]; j++)
    if(k>=j*a[i]) f[k] |= f[k-j*a[i]];
```

---

4. **最优技巧提炼**  

**关键优化**：  
- **一维倒序更新**：将二维状态压缩至一维，逆序遍历金额避免状态污染  
- **物品拆分法**：将 $B_i$ 个物品拆分为 $B_i$ 次 0-1 背包操作，保证数量限制  
- **位运算加速**：使用 `|=` 替代条件判断，提升代码执行效率  

**代码模板**：  
```cpp
bool dp[MAX_X] = {1}; // 初始化
for (每种物品i) {
    for (int k = 1; k <= B_i; k++) { // 拆分为B_i次
        for (int j = X; j >= A_i; j--) {
            dp[j] |= dp[j - A_i];
        }
    }
}
```

---

5. **同类型题推荐**  

- **多重背包基础**：  
  - 洛谷 P1776《宝物筛选》- 多重背包 + 二进制优化  
  - 洛谷 P1833《樱花》- 时间处理 + 多重背包  
- **变种问题**：  
  - 洛谷 P6567《买表》- 货币组合问题加强版  

---

6. **可视化代码片段**  

```javascript
// Canvas 绘制核心逻辑
function drawDPGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let j = 0; j <= X; j++) {
    ctx.fillStyle = dp[j] ? '#8bc34a' : '#ff5722'; // 绿/红色填充
    ctx.fillRect(j * cellSize, currentCoin * cellSize, cellSize, cellSize);
    
    // 高亮当前操作位置
    if (j === currentAmount || j === currentAmount - A_i) {
      ctx.strokeStyle = '#2196f3';
      ctx.strokeRect(...);
    }
  }
}

// 音效触发
function playSound(pitch) {
  const osc = audioContext.createOscillator();
  osc.frequency.value = pitch; // 成功时 800Hz，默认 400Hz
  osc.connect(audioContext.destination);
  osc.start(); osc.stop(0.1);
}
```

---

7. **个人心得**  

- **调试陷阱**：  
  初始忘记设置 `dp[0] = true`，导致所有状态无法更新。  
  > "背包问题必须明确初始化空背包状态"  

- **性能对比**：  
  当 $X=10^4$ 时，二维 DP 解法会占用 50×10^4 = 5MB 内存，而一维解法仅需 10KB，空间效率提升 500 倍。  

- **思维突破**：  
  将硬币按面值拆分后，问题转化为标准背包模型，这种转化思维在竞赛中尤为关键。  

---

通过综合运用一维 DP 优化、倒序枚举和位运算技巧，本题可在 O(N·B·X) 时间复杂度和 O(X) 空间复杂度下高效求解。可视化演示通过像素网格和音效反馈，可直观展现状态转移过程，加深对多重背包本质的理解。

---
处理用时：84.59秒
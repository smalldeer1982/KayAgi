# 题目信息

# [ABC343B] Adjacency Matrix

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc343/tasks/abc343_b

$ N $ 頂点の単純無向グラフ $ G $ があり、グラフの頂点には $ 1,2,\ldots,\ N $ の番号が付けられています。

$ G $ の隣接行列 $ (A_{i,j}) $ が与えられます。すなわち、$ G $ は $ A_{i,j}\ =\ 1 $ であるとき、またそのときに限り頂点 $ i $ と頂点 $ j $ を結ぶ辺を持ちます。

$ i\ =\ 1,\ 2,\ \ldots,\ N $ について、頂点 $ i $ と直接結ばれている頂点の番号を**昇順に**出力してください。

ただし、頂点 $ i $ と頂点 $ j $ が直接結ばれているとは、頂点 $ i $ と頂点 $ j $ を結ぶ辺が存在することをいいます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100 $
- $ A_{i,j}\ \in\ \lbrace\ 0,1\ \rbrace $
- $ A_{i,i}\ =\ 0 $
- $ A_{i,j}\ =\ A_{j,i} $
- 入力される値はすべて整数
 
### Sample Explanation 1

頂点 $ 1 $ と直接結ばれている頂点は頂点 $ 2,\ 3 $ です。したがって、$ 1 $ 行目には $ 2,\ 3 $ をこの順で出力します。 同様に、$ 2 $ 行目には $ 1,\ 4 $ をこの順に、$ 3 $ 行目には $ 1 $ を、$ 4 $ 行目には $ 2 $ を出力します。

### Sample Explanation 2

$ G $ に辺が存在しないこともあります。

## 样例 #1

### 输入

```
4

0 1 1 0

1 0 0 1

1 0 0 0

0 1 0 0```

### 输出

```
2 3

1 4

1

2```

## 样例 #2

### 输入

```
2

0 0

0 0```

### 输出

```
```

## 样例 #3

### 输入

```
5

0 1 0 1 1

1 0 0 1 0

0 0 0 0 1

1 1 0 0 1

1 0 1 1 0```

### 输出

```
2 4 5

1 4

5

1 2 5

1 3 4```

# AI分析结果



## 唯一算法分类
无算法分类

## 综合分析与结论
### 核心思路
题目要求根据邻接矩阵输出每个顶点的所有邻接顶点。关键步骤包括：
1. **遍历邻接矩阵行**：每个顶点对应一行，检查每个元素是否为1。
2. **收集邻接顶点**：将值为1的列索引转换为顶点编号。
3. **排序输出**：确保结果按升序排列。

### 解决难点
- **索引转换**：邻接矩阵的行列索引从0开始，而顶点编号从1开始，需正确处理转换。
- **输出格式**：需按升序排列且无多余空格，需注意空行处理。

### 可视化设计思路
1. **高亮当前处理行**：在邻接矩阵中用颜色标记当前顶点对应的行。
2. **动态收集顶点**：逐步检查每个元素，若为1则将其对应顶点加入列表并高亮。
3. **排序动画**：展示收集后的顶点列表排序过程，最终输出结果。

## 最优思路或技巧提炼
- **直接遍历邻接矩阵**：逐个检查每个元素是否为1，避免复杂结构。
- **顶点编号转换**：行列索引+1即对应顶点编号。
- **即时排序**：收集完成后立即排序，确保输出顺序正确。

## 同类型题或类似算法套路
- **邻接矩阵处理**：如统计顶点的度数、判断图是否连通等。
- **基础数组操作**：如二维数组遍历、条件筛选与排序。

## 推荐题目
1. **P3916 图的遍历**：反向建边，利用邻接表处理。
2. **P5318 查找文献**：邻接表遍历与排序。
3. **P1359 图的遍历**：邻接矩阵的深度优先遍历。

## 代码实现
```python
n = int(input())
adj = [list(map(int, input().split())) for _ in range(n)]

for i in range(n):
    neighbors = []
    for j in range(n):
        if adj[i][j] == 1:
            neighbors.append(j + 1)
    print(' '.join(map(str, sorted(neighbors))))
```

### 核心逻辑
- **邻接矩阵读取**：直接读取为二维列表。
- **顶点编号转换**：`j + 1`将列索引转换为顶点编号。
- **排序输出**：使用`sorted()`函数确保升序。

## 可视化与算法演示（核心算法过程）
### 动画方案
- **高亮当前行**：用黄色标记当前处理的顶点行。
- **元素检查**：绿色表示值为1的列，对应邻接顶点加入列表。
- **动态排序**：展示列表排序过程，最终结果以蓝色显示。

### 复古游戏化效果
- **像素风格**：邻接矩阵以16色网格显示，顶点编号用8位字体。
- **音效**：发现邻接顶点时播放“收集”音效，排序完成时播放胜利音效。
- **自动演示**：按步长自动遍历每个顶点，支持暂停与速度调节。

### 控制面板
- **步进控制**：单步执行或连续播放。
- **速度调节**：调整动画速度，观察细节变化。
- **状态显示**：当前处理顶点和已收集的邻接顶点列表。

---
处理用时：99.59秒
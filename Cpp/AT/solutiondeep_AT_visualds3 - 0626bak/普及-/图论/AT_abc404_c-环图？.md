# 题目信息

# 环图？

## 题目描述

你有一个 $N$ 个点 $M$ 条边的简单无向图，点从 $1$ 到 $N$ 编号，边从 $1$ 到 $M$ 编号。$i$ 号边连通了点 $A_i$ 和点 $B_i$。

你需要判断这个图是否是环图。一个图是“环图”当且仅当图中存在一个环包含图中的所有点，并且图上没有其他的边。

保证给定的图中无自环，无重边。

## 说明/提示

**样例 1 解释**

给定的图如下所示，这是一个环图。

![](https://img.atcoder.jp/abc404/92ea02f287069bfd5e2142ffcafa0e3e.png)



**样例 2 解释**

给定的图如下所示，这不是一个环图。

![](https://img.atcoder.jp/abc404/a428538cd729b649a952c46a67afd8d7.png)

By chenxi2009

## 样例 #1

### 输入

```
4 4
2 4
3 1
4 1
2 3```

### 输出

```
Yes```

## 样例 #2

### 输入

```
4 6
1 2
1 3
1 4
2 3
2 4
3 4```

### 输出

```
No```

# AI分析结果



**唯一算法分类**: 图论（环的判定）

---

### **题解思路、算法要点与解决难点**

1. **核心条件**：
   - **边数等于顶点数**（n = m）：环图必须是单一环，边数等于顶点数。
   - **每个顶点度数为2**：环中每个顶点仅连接两个相邻顶点。
   - **连通性**：整个图必须连通，排除多个不相交环的情况。

2. **实现方法**：
   - **度数检查**：遍历所有顶点，统计度数。
   - **连通性检查**：DFS/BFS遍历或并查集判断是否所有顶点连通。

3. **解决难点**：
   - **多环干扰**：即使度数正确，若存在多个环则不满足条件，需通过连通性检查排除。
   - **输入处理**：正确存储图结构并统计度数。

---

### **题解评分（≥4星）**

1. **Little_x_starTYJ（5星）**  
   - **亮点**：代码简洁，逻辑清晰，DFS遍历直观，覆盖所有核心条件。
   - **代码**：度数检查 + DFS连通性检查。

2. **ZZ0520（4星）**  
   - **亮点**：使用并查集高效判断连通性，避免显式遍历。
   - **注意**：代码中合并操作需正确处理输入的边。

3. **Chase12345（4星）**  
   - **亮点**：代码结构清晰，同时满足三个条件检查，可读性强。

---

### **最优思路或技巧提炼**

1. **度数检查优先**：快速排除度数不符的无效情况。
2. **连通性验证**：DFS/BFS适合小规模图；并查集适合大规模数据。
3. **边数判定前置**：若边数不等于顶点数，直接返回结果，减少后续计算。

---

### **同类型题或类似算法套路**

- **树的性质判定**：边数 = 顶点数 - 1，连通且无环。
- **欧拉回路判定**：所有顶点度数为偶数且图连通。
- **判断二分图**：通过颜色标记法检查。

---

### **推荐洛谷题目**

1. **P1351 联合权值**（图的遍历与权值计算）
2. **P3388 割点**（Tarjan算法求割点）
3. **P1330 封锁阳光大学**（二分图判定）

---

### **个人心得摘录**

- **并查集合并顺序**：合并时需确保父节点正确更新，避免逻辑错误。
- **度数统计陷阱**：输入每条边时需同时更新两个顶点的度数。
- **连通性检查必要性**：即使度数正确，仍需验证是否连通。

---

### **可视化与算法演示**

**核心逻辑动画方案**：

1. **步骤分解**：
   - **步骤1**：高亮显示边数检查（n vs m），若不等则显示红色“No”。
   - **步骤2**：逐个顶点显示度数，非2的顶点标记为红色。
   - **步骤3**：从顶点1开始遍历，动态显示访问路径，未访问顶点最终标红。

2. **复古像素风格**：
   - **颜色方案**：绿色为合法顶点，红色为非法，黄色为当前访问顶点。
   - **音效**：成功时播放8-bit胜利音效，失败时播放错误音效。
   - **Canvas动画**：顶点排列成环状网格，遍历时动态连线并填充颜色。

**交互设计**：
- **控制面板**：步进按钮调节执行速度，支持暂停/继续。
- **自动演示**：AI自动执行所有检查步骤，突出关键状态变化。

---

### **代码实现（关键片段）**

```cpp
// 选自 Little_x_starTYJ 的代码（核心逻辑）
#include<bits/stdc++.h>
using namespace std;
vector<int> v[200100];
bool vis[200010];

void dfs(int x) {
    vis[x] = 1;
    for (int u : v[x]) {
        if (!vis[u]) {
            dfs(u);
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    if (n != m) { cout << "No"; return 0; }

    for (int i = 1; i <= m; i++) {
        int u, V;
        cin >> u >> V;
        v[u].push_back(V);
        v[V].push_back(u);
    }

    for (int i = 1; i <= n; i++) {
        if (v[i].size() != 2) { cout << "No"; return 0; }
    }

    dfs(1);
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) { cout << "No"; return 0; }
    }

    cout << "Yes";
    return 0;
}
```

---
处理用时：73.68秒
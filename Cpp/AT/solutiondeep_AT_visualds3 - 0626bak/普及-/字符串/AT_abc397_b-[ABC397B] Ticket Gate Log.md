# 题目信息

# [ABC397B] Ticket Gate Log

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc397/tasks/abc397_b

高桥君收集了检票闸机的使用记录。然而他不小心删除了一部分进出场记录，现在正尝试恢复这些被删除的记录。

给定一个仅由字符 `i` 和 `o` 构成的字符串 $S$。我们可以在 $S$ 的任意位置插入 $0$ 个或多个字符，使得修改后的字符串满足以下条件：

- 字符串长度为偶数，且奇数位置的字符为 `i`，偶数位置的字符为 `o`。

请计算需要插入的最小字符数。根据题目约束条件，可以证明通过插入有限个字符一定能满足上述条件。

## 说明/提示

### 约束条件

- $S$ 是仅由 `i` 和 `o` 构成的字符串，长度在 $1$ 到 $100$ 之间

### 样例解释 1

在第 $3$ 个字符后插入 `o`，得到 `ioio` 即可满足条件。无法通过插入 $0$ 个或更少字符实现条件。

### 样例解释 2

在第 $1$ 个字符后插入 `o`，在第 $3$ 个字符后插入 `i`，得到 `ioio` 即可满足条件。无法通过插入 $1$ 个或更少字符实现条件。

### 样例解释 3

原字符串 $S$ 已经满足条件。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
ioi```

### 输出

```
1```

## 样例 #2

### 输入

```
iioo```

### 输出

```
2```

## 样例 #3

### 输入

```
io```

### 输出

```
0```

# AI分析结果



## 算法分类
无算法分类

## 综合分析与结论
题目要求构造一个满足特定奇偶位置字符的字符串，通过插入最少的字符实现。核心思路是动态规划，跟踪处理到的原字符位置和已构建的目标位置数，计算最小插入次数。

### 核心算法流程
1. **状态定义**：`dp[i][k]` 表示处理到原字符串第 `i` 个字符时，已构建 `k` 个目标字符的最小插入次数。
2. **状态转移**：
   - **跳过当前字符**：直接处理下一个字符，不改变插入次数。
   - **插入字符**：根据当前位置奇偶性插入正确字符，增加插入次数。
   - **使用原字符**：若原字符符合当前位置要求，则使用并转移到下一个位置。
3. **最终答案**：遍历所有可能的 `k`，选择最小的插入次数，确保最终长度为偶数。

### 可视化设计思路
- **动画演示**：在网格中动态展示 `dp` 表的更新过程，高亮当前处理的位置和状态转移路径。
- **颜色标记**：绿色表示跳过操作，红色表示插入，蓝色表示使用原字符。
- **步进控制**：允许单步执行，观察每一步的状态变化和转移选择。

## 最优思路或技巧提炼
通过动态规划，精确跟踪每个位置的可能状态，贪心地选择最优操作（插入或使用原字符），确保插入次数最少。关键点在于维护当前构建的位置奇偶性，并合理处理三种操作的可能性。

## 代码实现
```python
S = input().strip()
n = len(S)
k_max = 2 * n  # 足够大的上限
INF = float('inf')

dp = [[INF] * (k_max + 1) for _ in range(n + 1)]
dp[0][0] = 0

for i in range(n):
    for k in range(k_max + 1):
        if dp[i][k] == INF:
            continue
        # 跳过当前字符
        if dp[i + 1][k] > dp[i][k]:
            dp[i + 1][k] = dp[i][k]
        # 插入字符
        if k + 1 <= k_max:
            new_cost = dp[i][k] + 1
            if dp[i][k + 1] > new_cost:
                dp[i][k + 1] = new_cost
        # 使用原字符
        required = 'i' if (k + 1) % 2 == 1 else 'o'
        if S[i] == required:
            if k + 1 <= k_max and dp[i + 1][k + 1] > dp[i][k]:
                dp[i + 1][k + 1] = dp[i][k]

ans = INF
for k in range(k_max + 1):
    if dp[n][k] != INF:
        total = dp[n][k] + (k % 2)
        ans = min(ans, total)

print(ans)
```

## 同类型题与类似套路
类似动态规划处理字符串构造或编辑距离的题目，如 LeetCode 72 (编辑距离)、LeetCode 115 (不同的子序列) 等。

## 推荐相似题目
1. [LeetCode 72 - Edit Distance](https://leetcode.com/problems/edit-distance/)
2. [LeetCode 115 - Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)
3. [AtCoder DP Contest - Matching](https://atcoder.jp/contests/dp/tasks/dp_o)

---
处理用时：546.87秒
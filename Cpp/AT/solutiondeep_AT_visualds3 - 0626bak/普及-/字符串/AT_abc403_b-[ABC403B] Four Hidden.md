# 题目信息

# [ABC403B] Four Hidden

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc403/tasks/abc403_b

给定一个由小写字母和 `?` 组成的字符串 $T$，以及一个仅由小写字母组成的字符串 $U$。

字符串 $T$ 是通过将某个仅由小写字母组成的字符串 $S$ 中的恰好 $4$ 个字符替换为 `?` 而得到的。

请判断是否存在这样的 $S$，使得 $S$ 包含 $U$ 作为连续子字符串。

## 说明/提示

### 约束条件

- $T$ 是长度为 $4$ 到 $10$ 的由小写字母和 `?` 组成的字符串
- $T$ 中恰好包含 $4$ 个 `?`
- $U$ 是长度为 $1$ 到 $|T|$ 的仅由小写字母组成的字符串

### 样例解释 #1

例如，当 $S$ 为 `takanashi` 时，它包含 `nashi` 作为连续子字符串。

### 样例解释 #2

无论 `?` 被替换为何种字符，$S$ 都不可能包含 `snuke` 作为连续子字符串。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
tak??a?h?
nashi```

### 输出

```
Yes```

## 样例 #2

### 输入

```
??e??e
snuke```

### 输出

```
No```

## 样例 #3

### 输入

```
????
aoki```

### 输出

```
Yes```

# AI分析结果



## 唯一算法分类
无算法分类

---

## 综合分析与结论

### 题解思路与核心难点
- **核心思路**：暴力枚举所有可能的子串起始位置，检查是否满足条件。具体步骤为：
  1. 遍历字符串 T 中所有可能的子串起始位置 i。
  2. 对于每个 i，检查从 i 开始长度为 len(U) 的子串是否满足：
     - T 中的每个字符是 `?` 或等于 U 的对应字符。
  3. 若存在这样的子串，则输出 "Yes"；否则输出 "No"。
  
- **解决难点**：
  - **条件转换**：正确理解 T 中 `?` 是必须被替换的四个字符，其他字符固定。因此，子串匹配时，非 `?` 的字符必须与 U 完全匹配。
  - **高效性**：尽管是暴力枚举，但数据规模较小（T 长度 ≤10，U 长度 ≤10），时间复杂度 O(n·m) 完全可行。

### 可视化设计思路
- **动画方案**：
  - **步进演示**：在 Canvas 中绘制 T 的字符序列，高亮当前检查的子串范围。若字符匹配或为 `?`，标记为绿色；否则红色。
  - **像素风格**：使用 8-bit 风格，字符块用不同颜色区分匹配状态。
  - **音效**：匹配成功时播放胜利音效，失败时播放错误音效。
- **交互功能**：
  - 单步执行：允许用户手动控制遍历过程。
  - 自动模式：自动遍历所有可能的 i，显示每一步的检查结果。

---

## 题解清单（≥4星）

### 题解评分：★★★★★
- **关键亮点**：
  - 直接暴力枚举所有可能的子串起始位置，逻辑清晰。
  - 时间复杂度低，完全适用于题目约束。
  - 代码简洁，可读性强。

---

## 代码实现

### 核心逻辑代码
```python
T = input().strip()
U = input().strip()
n, m = len(T), len(U)
if m > n:
    print("No")
else:
    found = False
    for i in range(n - m + 1):
        valid = True
        for j in range(m):
            tc, uc = T[i + j], U[j]
            if tc != '?' and tc != uc:
                valid = False
                break
        if valid:
            found = True
            break
    print("Yes" if found else "No")
```

### 代码说明
- **输入处理**：读取 T 和 U。
- **边界条件**：若 U 长度大于 T，直接输出 "No"。
- **双重循环**：外层遍历所有子串起始位置，内层检查每个字符是否匹配条件。
- **提前终止**：一旦找到合法子串，立即结束遍历。

---

## 最优思路提炼
1. **暴力覆盖所有可能性**：由于数据规模极小，直接枚举所有可能的子串位置。
2. **条件剪枝**：在检查子串时，遇到不匹配的字符立即终止内层循环，减少无效计算。
3. **字符匹配规则**：非 `?` 字符必须严格相等，`?` 可任意替换为对应字符。

---

## 相似题目推荐
1. **[CF177B2](https://codeforces.com/problemset/problem/177/B2)**：字符串匹配与动态规划结合。
2. **[LeetCode 28. Implement strStr()](https://leetcode.com/problems/implement-strstr)**：经典的子串匹配问题。
3. **[洛谷 P3375](https://www.luogu.com.cn/problem/P3375)**：KMP 算法的模板题，可对比暴力解法与高效算法差异。

---
处理用时：344.08秒
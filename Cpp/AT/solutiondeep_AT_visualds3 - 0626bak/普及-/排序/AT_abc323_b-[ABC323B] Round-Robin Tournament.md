# 题目信息

# [ABC323B] Round-Robin Tournament

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_b

$ 1 $ から $ N $ までの番号が付いた $ N $ 人のプレイヤーが総当たり戦をしました。この総当たり戦で行われた試合全てについて、二人の一方が勝ち、もう一方が負けました。

総当たり戦の結果は $ N $ 個の長さ $ N $ の文字列 $ S_1,S_2,\ldots,S_N $ によって以下の形式で与えられます。

- $ i\neq\ j $ のとき、$ S_i $ の $ j $ 文字目は `o`, `x` のいずれかであり、`o` のときプレイヤー $ i $ がプレイヤー $ j $ に勝ったことを、`x` のときプレイヤー $ i $ がプレイヤー $ j $ に負けたことを意味する。
- $ i=j $ のとき、$ S_i $ の $ j $ 文字目は `-` である。

総当たり戦で勝った試合数が多いほうが順位が上であり、勝った試合数が同じ場合は、プレイヤーの番号が小さいほうが順位が上となります。 $ N $ 人のプレイヤーの番号を順位が高い順に答えてください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 100 $
- $ N $ は整数
- $ S_i $ は `o`, `x`, `-` からなる長さ $ N $ の文字列
- $ S_1,\ldots,S_N $ は問題文中の形式を満たす

### Sample Explanation 1

プレイヤー $ 1 $ は $ 0 $ 勝、プレイヤー $ 2 $ は $ 1 $ 勝、プレイヤー $ 3 $ は $ 2 $ 勝なので、プレイヤーの番号は順位が高い順に $ 3,2,1 $ です。

### Sample Explanation 2

プレイヤー $ 4 $ とプレイヤー $ 7 $ はどちらも $ 5 $ 勝ですが、プレイヤー番号が小さいプレイヤー $ 4 $ のほうが順位が上になります。

## 样例 #1

### 输入

```
3
-xx
o-x
oo-```

### 输出

```
3 2 1```

## 样例 #2

### 输入

```
7
-oxoxox
x-xxxox
oo-xoox
xoo-ooo
ooxx-ox
xxxxx-x
oooxoo-```

### 输出

```
4 7 3 1 5 2 6```

# AI分析结果



## 算法分类
无算法分类

## 综合分析与结论
### 题解思路与核心难点
题目要求根据循环赛结果对玩家进行排名。关键点在于：
1. **胜负统计**：每个玩家的胜场数等于其对应字符串中字符 `o` 的数量。
2. **排序规则**：先按胜场数降序，胜场相同则按编号升序。

**解决难点**：
- **正确统计胜场数**：需遍历每个字符串中的字符，仅统计 `o` 的数量。
- **自定义排序规则**：通过比较函数实现双重排序条件（胜场数优先降序，编号次优先升序）。

### 核心算法流程
1. **读取输入**：保存所有玩家的比赛结果字符串。
2. **统计胜场**：对每个玩家，遍历其字符串并统计 `o` 的数量。
3. **排序处理**：将玩家编号和胜场数存入容器，按自定义规则排序。
4. **输出结果**：按排序后的顺序输出玩家编号。

### 可视化设计思路
- **动画展示**：用网格表示每个玩家的比赛结果，高亮 `o` 以动态统计胜场数。
- **颜色标记**：胜场数用不同颜色区分，当前比较的玩家用闪烁效果。
- **步进控制**：允许逐步执行统计和排序过程，观察每一步的排序变化。

## 最优思路与技巧提炼
- **直接统计法**：利用字符串中 `o` 的总数直接表示胜场数，避免复杂判断。
- **自定义排序函数**：通过组合比较条件（胜场降序、编号升序）简化排序逻辑。
- **编码技巧**：使用 `pair<int, int>` 存储（胜场数，编号），方便排序。

## 代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<string> results(N);
    for (int i = 0; i < N; ++i) {
        cin >> results[i];
    }
    
    vector<pair<int, int>> players;
    for (int i = 0; i < N; ++i) {
        int wins = count(results[i].begin(), results[i].end(), 'o');
        players.emplace_back(-wins, i + 1); // 负数用于降序排序
    }
    
    sort(players.begin(), players.end(), [](const auto& a, const auto& b) {
        return a.first == b.first ? a.second < b.second : a.first < b.first;
    });
    
    for (int i = 0; i < players.size(); ++i) {
        if (i > 0) cout << " ";
        cout << players[i].second;
    }
    return 0;
}
```

## 同类型题目推荐
1. **P1093** [NOIP2007 普及组] 奖学金 - 类似的多条件排序问题。
2. **P1781** 宇宙总统 - 按特定规则比较字符串长度和字典序。
3. **P1068** [NOIP2009 普及组] 分数线划定 - 双关键字排序与统计。

---
处理用时：176.52秒
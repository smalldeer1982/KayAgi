# 题目信息

# [ABC348C] Colorful Beans

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc348/tasks/abc348_c

$ N $ 種類のビーンズが $ 1 $ 粒ずつあります。 $ i $ 種類目のビーンズはおいしさが $ A_i $ で色が $ C_i $ です。ビーンズは混ぜられており、色でしか区別することができません。

あなたはビーンズの色を $ 1 $ つ選び、その色のビーンズをどれか $ 1 $ 粒食べます。ビーンズの色をうまく選ぶことで、食べる可能性のあるビーンズのおいしさの最小値を最大化してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^{5} $
- $ 1\ \leq\ A_i\ \leq\ 10^{9} $
- $ 1\ \leq\ C_i\ \leq\ 10^{9} $
- 入力は全て整数である。
 
### Sample Explanation 1

同じ色のビーンズは互いに区別がつかないことに注意してください。 選ぶことができる色は 色 $ 1 $ と 色 $ 5 $ です。 - 色 $ 1 $ のビーンズは $ 2 $ 種類あり、美味しさはそれぞれ $ 100,\ 40 $ です。よって、色 $ 1 $ を選んだときのおいしさの最小値は $ 40 $ です。 - 色 $ 5 $ のビーンズは $ 2 $ 種類あり、美味しさはそれぞれ $ 20,\ 30 $ です。よって、色 $ 5 $ を選んだときのおいしさの最小値は $ 20 $ です。 おいしさの最小値を最大化するには 色 $ 1 $ を選べばよいため、そのときの最小値である $ 40 $ を出力します。

## 样例 #1

### 输入

```
4

100 1

20 5

30 5

40 1```

### 输出

```
40```

## 样例 #2

### 输入

```
10

68 3

17 2

99 2

92 4

82 4

10 3

100 2

78 1

3 1

35 4```

### 输出

```
35```

# AI分析结果



### 算法分类
哈希表

---

### 题解思路与难点对比

#### 核心思路
所有题解均围绕以下步骤展开：
1. **统计每个颜色的最小美味度**：遍历豆子，记录每个颜色对应的最小美味度。
2. **找出所有颜色的最小值中的最大值**：遍历所有颜色，取其最小值中的最大者。

#### 实现方式对比
- **哈希表（map/unordered_map）**：直接记录颜色到最小值的映射，适用于颜色范围大的场景。时间复杂度 O(N log N)。
- **排序法**：按颜色排序后，相同颜色豆子连续，遍历时只需记录颜色切换时的最小值。时间复杂度 O(N log N)。

#### 关键难点
- **颜色离散性**：颜色值可能高达 1e9，无法用数组存储，必须借助哈希结构。
- **效率优化**：map 的查询/插入复杂度为 O(log N)，而排序法通过预处理可能更快。

---

### 题解评分 (≥4星)

1. **Little_x_starTYJ（5星）**  
   - 提供两种思路，对比清晰，代码简洁。  
   - 使用 map 和排序两种方法，适合不同场景。  
   - 优化建议明确，实践性强。

2. **MinimumSpanningTree（4.5星）**  
   - 使用 unordered_map 提高效率，代码直观。  
   - 缺乏对排序法的对比，但核心逻辑完整。

3. **hz_rft（4星）**  
   - 结构体排序后遍历，思路清晰。  
   - 代码可读性高，适合理解排序法逻辑。

---

### 最优思路提炼
1. **哈希表法**：  
   - 使用 `map<int, int>` 或 `unordered_map` 记录每个颜色的最小值。  
   - 遍历豆子时更新哈希表，最后遍历哈希表取最大值。  
   - **代码示例**：  
     ```cpp
     unordered_map<int, int> min_val;
     for (auto &bean : beans) {
         if (!min_val.count(color)) 
             min_val[color] = a;
         else 
             min_val[color] = min(min_val[color], a);
     }
     int ans = 0;
     for (auto &[c, v] : min_val) 
         ans = max(ans, v);
     ```

2. **排序法**：  
   - 按颜色为第一关键字、美味度为第二关键字排序。  
   - 遍历时记录颜色切换时的最小值。  
   - **代码示例**：  
     ```cpp
     sort(beans.begin(), beans.end(), [](auto &a, auto &b) {
         return a.c == b.c ? a.a < b.a : a.c < b.c;
     });
     int ans = 0, last_color = -1;
     for (auto &bean : beans) {
         if (bean.c != last_color) {
             ans = max(ans, bean.a);
             last_color = bean.c;
         }
     }
     ```

---

### 类似题目推荐
1. **LeetCode 347. Top K Frequent Elements**（统计频率后取极值）
2. **P1097 [NOIP2007 提高组] 统计数字**（分组统计极值）
3. **P5143 攀爬者**（排序后分组处理）

---

### 可视化设计

#### 核心算法演示
1. **哈希表法动画**：  
   - **步骤分解**：  
     - 豆子依次飞入，根据颜色分组到不同桶中，桶显示当前最小值。  
     - 最终所有桶的最小值比较，最大值高亮。  
   - **交互**：支持暂停观察哈希表状态，速度调节。

2. **排序法动画**：  
   - **步骤分解**：  
     - 豆子按颜色和美味度排序，相同颜色豆子堆叠，最小值显示在顶部。  
     - 遍历时高亮颜色切换点，动态更新最大值。  
   - **交互**：单步执行，观察排序后处理流程。

#### 复古像素风格
- **颜色块表示**：每个颜色用 8-bit 像素方块表示，方块内显示当前最小值。  
- **音效**：豆子插入哈希表时播放“滴”声，最大值更新时播放“升级”音效。  
- **Canvas 绘制**：用网格布局展示哈希表或排序后的豆子队列，颜色渐变区分不同组。

---

### 总结
本题解通过哈希表或排序法高效解决极值问题，核心在于分组统计最小值。两种方法各有优劣，哈希表代码简洁，排序法预处理后遍历高效。可视化设计可直观展示分组和极值更新过程，适合教学与理解。

---
处理用时：63.20秒
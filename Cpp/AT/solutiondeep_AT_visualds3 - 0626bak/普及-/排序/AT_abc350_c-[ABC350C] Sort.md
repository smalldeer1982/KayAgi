# 题目信息

# [ABC350C] Sort

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc350/tasks/abc350_c

$ (1,2,\ldots,N) $ の並び替えである数列 $ A=(A_1,\ldots,A_N) $ が与えられます。  
 次の操作を $ 0 $ 回以上 $ N-1 $ 回以下行うことで、$ A $ を $ (1,2,\ldots,N) $ にしてください。

- 操作：$ 1\leq\ i\ <\ j\ \leq\ N $ を満たす整数の組 $ (i,j) $ を自由に選ぶ。$ A $ の $ i $ 番目と $ j $ 番目の要素を入れ替える。
 
なお、制約の条件下で必ず $ A $ を $ (1,2,\ldots,N) $ にできることが証明できます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ (A_1,\ldots,A_N) $ は $ (1,2,\ldots,N) $ の並び替えである
- 入力は全て整数である
 
### Sample Explanation 1

操作により数列は次のように変化します。 - 最初 $ A=(3,4,1,2,5) $ である。 - $ 1 $ 回目の操作で $ 1 $ 番目の要素と $ 3 $ 番目の要素を入れ替える。$ A=(1,4,3,2,5) $ になる。 - $ 2 $ 回目の操作で $ 2 $ 番目の要素と $ 4 $ 番目の要素を入れ替える。$ A=(1,2,3,4,5) $ になる。 この他、次のような出力でも正解とみなされます。 ``` 4 2 3 3 4 1 2 2 3 ```

## 样例 #1

### 输入

```
5

3 4 1 2 5```

### 输出

```
2

1 3

2 4```

## 样例 #2

### 输入

```
4

1 2 3 4```

### 输出

```
0```

## 样例 #3

### 输入

```
3

3 1 2```

### 输出

```
2

1 2

2 3```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路与算法要点**
- **核心思路**：维护每个数的当前位置，遍历数组，每次将当前数i归位，确保总交换次数不超过N-1次。
- **解决难点**：如何高效更新位置信息以避免重复交换。
- **关键变量**：
  - `now[i]` 或 `pos[i]`：记录数值i的当前位置。
  - 遍历数组时，若当前元素非i，则交换当前元素与i的正确位置，并更新位置信息。

---

### **题解评分 (≥4星)**
1. **qhr2023 (5星)**  
   - **亮点**：代码简洁，仅维护一个`now`数组，直接交换并更新位置，逻辑清晰。
   - **代码可读性**：变量名明确，无冗余操作。
2. **Harrylzh (4星)**  
   - **亮点**：通过`gs`数组记录位置，代码结构简单，直接交换并更新。
   - **优化**：交换时记录答案的顺序，避免重复计算。
3. **maokaiyu (4星)**  
   - **亮点**：使用`pos`数组直接定位，代码逻辑与问题描述高度一致。
   - **实践性**：代码实现直观，易于调试。

---

### **最优思路与技巧提炼**
- **关键技巧**：维护位置数组（如`now`或`pos`），每次遍历i时，若当前位置元素非i，则交换i与其正确位置。
- **时间复杂度**：O(N)，每个元素最多被处理一次。
- **空间优化**：仅需线性空间存储位置信息。

---

### **同类型题与算法套路**
- **通用解法**：排列的循环分解问题，将每个元素归位至其正确位置。
- **类似题目**：
  1. [LeetCode 41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
  2. [LeetCode 442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)
  3. [洛谷 P1908 逆序对](https://www.luogu.com.cn/problem/P1908)（需统计逆序对，但同样涉及位置交换思想）

---

### **可视化与算法演示**
- **动画设计**：
  - **初始状态**：显示数组元素，高亮当前遍历位置i。
  - **交换操作**：若元素非i，定位其正确位置j，交换i和j的元素，播放音效。
  - **颜色标记**：已归位的元素为绿色，待处理元素为红色。
- **交互功能**：
  - **步进控制**：允许用户单步执行或调整速度。
  - **自动模式**：模拟“AI自动运行”，逐步完成所有交换。
- **复古像素风格**：
  - **颜色方案**：8位色调色板（如红、绿、蓝、黄）。
  - **音效**：交换时播放短促音效，完成时播放胜利音效。
  - **Canvas 网格**：将数组元素显示为像素方块，每次交换动态更新。

---

### **核心代码实现**
```cpp
// 作者：qhr2023 的代码（核心逻辑）
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n, a[N], now[N], x[N], y[N], ans; 

int main() {
    cin >> n;
    for (int i=1; i<=n; i++) 
        cin >> a[i], now[a[i]] = i; // 初始化now数组

    for (int i=1; i<=n; i++) {
        if (a[i] != i) {
            int j = now[i];
            x[++ans] = i, y[ans] = j; // 记录交换位置
            swap(a[i], a[j]);         // 交换元素
            now[a[j]] = j;            // 更新now数组
            now[i] = i;
        }
    }

    cout << ans << '\n';
    for (int i=1; i<=ans; i++)
        cout << x[i] << ' ' << y[i] << '\n';
    return 0; 
}
```

---

### **总结**
- **核心思想**：通过维护位置数组，每次交换确保至少一个元素归位。
- **实践建议**：优先使用单数组维护位置信息（如`now`或`pos`），避免多数组同步更新的复杂性。
- **扩展思考**：该思路可推广至所有涉及排列归位的贪心问题，强调“每一步解决一个元素”的高效性。

---
处理用时：82.16秒
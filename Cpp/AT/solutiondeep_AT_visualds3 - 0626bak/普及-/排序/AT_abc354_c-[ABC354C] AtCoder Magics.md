# 题目信息

# [ABC354C] AtCoder Magics

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_c

高橋くんは、カードゲーム「AtCoder Magics」のカードを $ N $ 枚持っています。$ i $ 番目のカードをカード $ i $ と呼ぶことにします。各カードには強さとコストのパラメーターがあり、カード $ i $ の強さは $ A_i $ で、コストは $ C_i $ です。

高橋くんは、弱いカードは要らないので捨てることにしました。具体的には、以下の操作をできなくなるまで繰り返します。

- $ 2 $ つのカード $ x,\ y $ であって、 $ A_x\ >\ A_y $ かつ $ C_x\ <\ C_y $ であるようなものを選ぶ。カード $ y $ を捨てる。

操作ができなくなったとき、捨てられなかったカードの集合は一意に定まることが証明できます。これを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ C_i\ \leq\ 10^9 $
- $ A_1,\ A_2,\ \dots\ ,A_N $ は全て異なる
- $ C_1,\ C_2,\ \dots\ ,C_N $ は全て異なる
- 入力はすべて整数

### Sample Explanation 1

カード $ 1,\ 3 $ に注目すると、 $ A_1\ <\ A_3 $ かつ $ C_1\ >\ C_3 $ なのでカード $ 1 $ を捨てることができます。 それ以上操作をすることはできません。このときカード $ 2,\ 3 $ が残っているので、これらを出力します。

### Sample Explanation 2

この場合、どのカードも捨てることができません。

## 样例 #1

### 输入

```
3
2 4
1 1
3 2```

### 输出

```
2
2 3```

## 样例 #2

### 输入

```
5
1 1
10 2
100 3
1000 4
10000 5```

### 输出

```
5
1 2 3 4 5```

## 样例 #3

### 输入

```
6
32 101
65 78
2 29
46 55
103 130
52 40```

### 输出

```
4
2 3 5 6```

# AI分析结果



## 算法分类
**贪心算法**

---

## 题解思路与核心算法分析
### 题目核心难点
给定卡牌的强度与成本两个属性，需要快速判定哪些卡牌会被淘汰。暴力 O(n²) 比较不可行，需设计 O(nlogn) 解法。

### 核心算法流程
1. **排序策略**  
   按成本 C **从小到大排序**（或按强度 A 从大到小排序，两种主流思路均正确）
2. **线性扫描维护极值**  
   遍历排序后的卡牌，维护当前遇到的最大强度（或最小成本），通过单次遍历即可判定是否保留当前卡牌。

### 算法正确性证明
- **按成本排序**：保证后续卡牌成本递增。若当前卡牌强度小于之前遇到的最大强度，则必然存在前驱卡牌 A 更大、C 更小，当前卡被淘汰。
- **按强度排序**：保证后续卡牌强度递减。若当前卡牌成本大于之前遇到的最小成本，则必然存在前驱卡牌 C 更小、A 更大，当前卡被淘汰。

---

## 题解评分（≥4星）
1. **hjyowl（5星）**  
   - 思路：按 C 排序，维护最大 A，代码简洁清晰。
   - 亮点：正确性易理解，时间复杂度 O(nlogn)。
   ```cpp
   sort(a + 1, a + 1 + n, cmp); // 按 C 排序
   long long mx = -1e9;
   for (遍历卡牌) {
       if (a[i].x > mx) 保留;
       else 删除;
       mx = max(mx, a[i].x);
   }
   ```

2. **txl20（5星）**  
   - 思路：按 A 排序，维护最小 C，逻辑对称。
   - 亮点：逆向思维，直接标记保留卡牌。
   ```cpp
   sort(a + 1, a + n + 1, cmp); // 按 A 降序
   int minn = 1e18;
   for (遍历卡牌) {
       if (a[i].c < minn) 保留;
       else 删除;
       minn = min(minn, a[i].c);
   }
   ```

3. **stripe_python（4星）**  
   - 思路：按 A 降序排序，动态维护最小成本。
   - 亮点：代码高度简洁，直接筛选保留项。
   ```cpp
   sort(a, cmp); // A 降序排序
   vector<int> res;
   int minx = a[1].c;
   for (遍历卡牌) {
       if (a[i].c <= minx) 保留并更新 minx;
   }
   ```

---

## 最优思路提炼
**关键步骤：**
1. **排序维度选择**：按成本升序或强度降序（两种方法等效）。
2. **极值维护**：遍历时动态维护最大强度或最小成本。
3. **淘汰条件**：当前卡牌不满足极值条件时直接淘汰。

**思维要点：**
- 将二维条件（A 和 C）通过排序降为一维问题。
- 利用排序后的单调性，通过单次遍历即可完成筛选。

---

## 同类型题与算法套路
**类似题目特征：**
- 二维偏序问题（如两个属性需同时满足某种关系）。
- 需高效筛选符合条件元素，避免暴力比较。

**推荐题目：**
1. **洛谷 P1223** - 排队接水（贪心排序）
2. **洛谷 P2887** - 防晒霜分配（双属性贪心）
3. **洛谷 P1094** - 纪念品分组（双指针+贪心）

---

## 可视化算法设计
**核心动画演示：**
1. **排序阶段**  
   将卡牌按 C 升序排列，展示卡牌在二维平面（A 为纵轴，C 为横轴）的分布。
2. **扫描过程**  
   动态绘制一条“当前最大 A”的折线，卡牌若低于折线则标记为红色（淘汰），否则标记为绿色（保留）。
3. **高亮交互**  
   - **当前卡牌**：黄色高亮。
   - **历史最大 A**：蓝色折线实时更新。
   - **淘汰卡牌**：渐隐动画。

**复古像素风格实现：**
- **Canvas 绘制**：卡牌用 16x16 像素块表示，A/C 值以条形图显示。
- **音效设计**：
  - **保留卡牌**：8-bit 上升音效。
  - **淘汰卡牌**：短促“哔”声。
- **自动演示**：按空格键切换手动/自动模式，自动模式下算法逐步执行。

---

## 核心代码实现（按成本排序）
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Card { int a, c, id; };

int main() {
    int n; cin >> n;
    vector<Card> cards(n);
    for (int i = 0; i < n; ++i) {
        cin >> cards[i].a >> cards[i].c;
        cards[i].id = i + 1;
    }
    // 按成本升序排序
    sort(cards.begin(), cards.end(), [](Card x, Card y) {
        return x.c < y.c;
    });
    
    vector<int> ans;
    int max_a = -1;
    for (auto& card : cards) {
        if (card.a > max_a) {
            ans.push_back(card.id);
            max_a = card.a;
        }
    }
    
    sort(ans.begin(), ans.end());
    cout << ans.size() << endl;
    for (int id : ans) cout << id << " ";
}
```

---

## 个人心得摘录
> "在调试中发现，必须严格维护排序后的单调性。最初错误地同时考虑 A 和 C 的排序优先级，导致部分 case 遗漏。最终确定单一排序维度后问题迎刃而解。" —— hjyowl

---

## 算法可视化示例（伪代码）
```javascript
// Canvas 初始化
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

function drawCard(x, y, a, c, isActive) {
    // 绘制卡牌像素块
    ctx.fillStyle = isActive ? '#FFD700' : '#FFFFFF';
    ctx.fillRect(x*40, 200 - a*2, 30, 30);
    // 绘制A/C值
    ctx.fillText(`A:${a}`, x*40, 230 - a*2);
    ctx.fillText(`C:${c}`, x*40, 245 - a*2);
}

function animate() {
    // 动态更新最大A折线
    ctx.beginPath();
    ctx.moveTo(0, 200 - maxA*2);
    for (let i = 0; i < sortedCards.length; ++i) {
        ctx.lineTo(i*40 + 15, 200 - maxAHist[i]*2);
    }
    ctx.strokeStyle = '#0000FF';
    ctx.stroke();
    
    // 单步执行逻辑
    if (autoPlay && step < sortedCards.length) {
        checkCard(step++);
    }
    requestAnimationFrame(animate);
}
```

---
处理用时：93.62秒
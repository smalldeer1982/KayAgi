# 题目信息

# [ABC384C] Perfect Standings

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_c

高橋くんは、プログラミングコンテストを主催することにしました。

コンテストは A 問題、B 問題、C 問題、D 問題、E 問題の $ 5 $ 問からなり、それぞれの配点は $ a $ 点、$ b $ 点、$ c $ 点、$ d $ 点、$ e $ 点です。

コンテストには $ 31 $ 人が参加し、全員が $ 1 $ 問以上解きました。

より具体的には、文字列 `ABCDE` の空でない（連続するとは限らない）部分列すべてについて、その部分列を名前とする参加者が存在し、その参加者は名前に含まれる文字に対応する問題をすべて解き、それ以外の問題は解きませんでした。

例えば、A さんは A 問題のみを、BCE さんは B 問題、C 問題、E 問題を解きました。

参加者の名前を、取った点数が大きいほうから順に出力してください。 ただし、参加者が取った点数は、その参加者が解いた問題の配点の合計です。

ただし、同じ点数を獲得した参加者については、名前が辞書順で小さいほうを先に出力してください。

 辞書順で小さいとは？辞書順とは、一言で説明すると「単語が辞書に載っている順番」を意味します。

より厳密には、英大文字からなる相異なる文字列 $ S,T $ について、$ S $ が $ T $ より辞書順で小さいとは、以下の条件のどちらかが成り立つことを意味します。

- $ S $ の長さ $ |S| $ が $ T $ の長さより短く、$ T $ の先頭 $ |S| $ 文字が $ S $ と一致する
- ある整数 $ 1\leq\ i\leq\min\lbrace|S|,|T|\rbrace $ が存在して、次の $ 2 $ つの条件を両方を満たす
  - $ 1\leq\ j\lt\ i $ を満たすすべての整数 $ j $ に対して $ S $ の $ j $ 文字目と $ T $ の $ j $ 文字目が等しい
  - $ S $ の $ i $ 文字目が $ T $ の $ i $ 文字目よりアルファベット順で小さい
 
例えば、$ S= $ `AB` $ ,T= $ `ABC` とすると、ひとつめの条件が成り立つため $ S $ は $ T $ より小さいです。 また、$ S= $ `ABD` $ ,T= $ `ACD` とすると、ふたつめの条件が $ i=2 $ で成り立つため $ S $ は $ T $ より小さいです。

## 说明/提示

### 制約

- $ 100\leq\ a\leq\ b\leq\ c\leq\ d\leq\ e\leq\ 2718 $
- 入力はすべて整数
 
### Sample Explanation 1

それぞれの参加者の得点は以下のようになります。 !\[\](https://img.atcoder.jp/abc384/4dac80dfad9b0f66c75fec40eedb5e2d.png) 例えば、ADE さんと BCE さんは同じ得点を獲得していますが、ADE さんのほうが辞書順で小さい名前をもつため、ADE さんを先に出力してください。

## 样例 #1

### 输入

```
400 500 600 700 800```

### 输出

```
ABCDE

BCDE

ACDE

ABDE

ABCE

ABCD

CDE

BDE

ADE

BCE

ACE

BCD

ABE

ACD

ABD

ABC

DE

CE

BE

CD

AE

BD

AD

BC

AC

AB

E

D

C

B

A```

## 样例 #2

### 输入

```
800 800 900 900 1000```

### 输出

```
ABCDE

ACDE

BCDE

ABCE

ABDE

ABCD

CDE

ACE

ADE

BCE

BDE

ABE

ACD

BCD

ABC

ABD

CE

DE

AE

BE

CD

AC

AD

BC

BD

AB

E

C

D

A

B```

## 样例 #3

### 输入

```
128 256 512 1024 2048```

### 输出

```
ABCDE

BCDE

ACDE

CDE

ABDE

BDE

ADE

DE

ABCE

BCE

ACE

CE

ABE

BE

AE

E

ABCD

BCD

ACD

CD

ABD

BD

AD

D

ABC

BC

AC

C

AB

B

A```

# AI分析结果



### 算法分类
**无算法分类**

---

### 题解思路、算法要点与解决难点

#### 核心思路
题目要求生成所有非空子序列对应的参与者，并根据得分和字典序排序。核心分为两步：
1. **生成所有非空子序列**：通过位运算或多重循环生成所有可能的组合。
2. **自定义排序**：按得分降序排序，得分相同时按字典序升序。

#### 解决难点
1. **子序列的生成**：需确保生成的子序列不重复且覆盖所有可能。
2. **字典序的正确性**：生成的子序列必须按字母顺序排列（如 `BCE` 而非 `BEC`）。
3. **排序规则实现**：需同时处理得分和字典序的排序优先级。

#### 关键步骤
- **位运算生成子序列**：将每个子序列映射为 5 位二进制数，每一位表示是否选中对应题目。
- **动态计算得分**：遍历子序列的每个字符，累加对应题目的分数。
- **排序函数设计**：优先比较得分，得分相同则比较字符串字典序。

---

### 题解评分 (≥4星)

1. **4041nofoundGeoge**（5星）
   - **亮点**：利用位运算自动生成所有子序列，代码简洁高效，避免手动打表。
   - **缺点**：遍历得分范围时效率较低（但本题数据量小，影响可忽略）。
2. **ryf2011**（4星）
   - **亮点**：动态计算得分，维护性优于硬编码。
   - **缺点**：依赖预先生成的名字数组，存在打表风险。
3. **Happy_mouse**（4星）
   - **亮点**：二进制转换生成名字，代码简洁且正确性高。
   - **缺点**：排序逻辑中需额外处理二进制到字符串的转换。

---

### 最优思路或技巧提炼
1. **位运算生成子集**：通过二进制数表示子集，高效生成所有组合。
2. **字母顺序处理**：按固定顺序（A→B→C→D→E）处理二进制位，确保字典序正确。
3. **双重条件排序**：先按得分降序，再按字典序升序，利用 `std::sort` 自定义比较函数。

---

### 同类型题或类似算法套路
- **子集生成**：如 LeetCode 78. Subsets。
- **字典序排序**：如对字符串集合的排序问题。
- **多条件排序**：需要结合多个键值进行排序的场景。

---

### 推荐题目
1. **洛谷 P1706 全排列问题**（生成全排列，需处理字典序）。
2. **洛谷 P1036 选数**（生成子集并筛选符合条件的组合）。
3. **洛谷 P1157 组合的输出**（生成固定长度的组合并按字典序输出）。

---

### 个人心得摘录
- **调试经验**：在生成子序列时，需特别注意字母顺序，否则字典序比较会出错。
- **优化思考**：位运算生成子集的时间复杂度为 O(2ⁿ)，适用于较小规模问题。

---

### 可视化与算法演示
#### 核心算法过程
1. **生成子序列**：以二进制数表示子集，如 `01010` 对应 `BDE`。
2. **计算得分**：遍历二进制位，累加选中题目的分数。
3. **排序过程**：按得分从高到低排列，得分相同时按字典序调整顺序。

#### 动画设计
- **像素风格界面**：用 8 位网格展示每个子序列的生成过程。
- **颜色标记**：
  - **红色**：当前正在处理的二进制位。
  - **绿色**：已选中的题目。
- **步进控制**：允许单步执行，观察每个子序列的生成和得分计算。

#### 复古游戏化效果
- **音效**：生成子序列时播放“点击”音效，排序完成时播放胜利音效。
- **积分系统**：每正确生成一个子序列得 10 分，排序正确得 50 分。
- **自动演示模式**：算法自动运行，用户可暂停观察中间状态。

---

### 代码实现（关键片段）
#### 位运算生成子序列
```cpp
for (int i = 1; i < (1 << 5); ++i) {
    string name;
    int score = 0;
    if (i & (1 << 0)) { name += 'A'; score += a; }
    if (i & (1 << 1)) { name += 'B'; score += b; }
    // 类似处理 C, D, E
    participants.push_back({name, score});
}
```

#### 自定义排序函数
```cpp
bool cmp(const Participant& a, const Participant& b) {
    if (a.score != b.score) return a.score > b.score;
    return a.name < b.name;
}
```

#### 完整代码（参考 4041nofoundGeoge 实现）
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int a, b, c, d, e;
    cin >> a >> b >> c >> d >> e;
    vector<pair<int, string>> participants;

    for (int i = 1; i < (1 << 5); ++i) {
        string name;
        int score = 0;
        if (i & (1 << 0)) { name += 'A'; score += a; }
        if (i & (1 << 1)) { name += 'B'; score += b; }
        if (i & (1 << 2)) { name += 'C'; score += c; }
        if (i & (1 << 3)) { name += 'D'; score += d; }
        if (i & (1 << 4)) { name += 'E'; score += e; }
        participants.emplace_back(-score, name); // 负分用于升序排序
    }

    sort(participants.begin(), participants.end());

    for (auto& p : participants) {
        cout << p.second << endl;
    }
    return 0;
}
```

---
处理用时：279.64秒
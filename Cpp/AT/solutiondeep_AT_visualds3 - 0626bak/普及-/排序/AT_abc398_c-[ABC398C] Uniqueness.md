# 题目信息

# [ABC398C] Uniqueness

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc398/tasks/abc398_c

有 $N$ 个人，编号为 $1$ 至 $N$。第 $i$ 个人持有数值 $A_i$。

请找出满足以下条件的个体中持有数值最大的那个人的编号：
- 在除自己之外的 $N-1$ 人中，不存在持有相同数值的人。

如果不存在满足条件的人，请报告这一情况。


## 说明/提示

### 约束条件

- $1 \leq N \leq 3 \times 10^5$
- $1 \leq A_i \leq 10^9$
- 输入均为整数

### 样例解释 1

满足条件的人为编号 $4,7,8,9$ 的 $4$ 人。他们持有的数值分别为 $7,4,5,8$，其中最大数值的持有者是编号 $9$，因此答案为 $9$。

### 样例解释 2

当不存在满足条件的人时，输出 `-1`。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
9

2 9 9 7 9 2 4 5 8```

### 输出

```
9```

## 样例 #2

### 输入

```
4

1000000000 1000000000 998244353 998244353```

### 输出

```
-1```

# AI分析结果



## 算法分类
哈希表/计数统计

## 题解思路与算法要点
题目要求找出数组中唯一出现且数值最大的元素对应的编号。核心思路为：
1. **统计出现次数**：使用哈希表（如`map`或`unordered_map`）记录每个数值出现的次数。
2. **筛选唯一元素**：遍历原数组，筛选出出现次数为1的元素。
3. **比较最大值**：在唯一元素中记录数值最大的对应编号。

**解决难点**：
- **去重逻辑**：正确判断元素是否唯一需遍历整个数组进行计数。
- **高效查询**：哈希表实现O(1)或O(log n)的查询，避免暴力枚举的O(n²)复杂度。

## 题解评分（≥4星）
1. **SunburstFan（5星）**
   - **亮点**：代码简洁，使用`map`统计次数，逻辑清晰，可读性高。
   - **核心代码**：
     ```cpp
     map<int,int> mp;
     for (int i=1; i<=n; i++) mp[a[i]]++;
     int maxn=-1, ans=-1;
     for (int i=1; i<=n; i++) {
         if (mp[a[i]]==1 && maxn<a[i]) {
             maxn = a[i];
             ans = i;
         }
     }
     ```

2. **KobeBeanBryantCox（4星）**
   - **亮点**：反向遍历数组，优先找到最后出现的最大值。
   - **核心代码**：
     ```cpp
     for (int i=n; i>=1; i--)
         if (mp[a[i]] == 1)
             if (ans==-1 || a[i]>a[ans]) ans = i;
     ```

3. **kuaiCreator（4星）**
   - **亮点**：直接通过`map`筛选唯一值后取最大值。
   - **核心代码**：
     ```cpp
     map<int, int> mp;
     for (int i=1; i<=n; i++) mp[a[i]]++;
     int ans = -1;
     for (auto it : mp) {
         if (it.second == 1) ans = max(ans, it.first);
     }
     ```

## 最优思路提炼
1. **哈希表计数**：用`map`或`unordered_map`统计每个数的出现次数。
2. **遍历筛选**：遍历原数组，检查每个数是否唯一。
3. **记录最大值**：动态维护最大唯一值及其编号。

## 类似题目推荐
1. **LeetCode 136. 只出现一次的数字**：寻找唯一出现一次的元素。
2. **LeetCode 387. 字符串中的第一个唯一字符**：找出第一个唯一字符的索引。
3. **洛谷 P1271 选举学生会**：统计出现次数并排序。

## 可视化设计
### 动画演示
1. **初始化**：显示数组元素，每个元素以像素方块表示，颜色区分不同数值。
2. **统计阶段**：遍历数组，元素被访问时高亮，右侧哈希表同步更新计数。
3. **筛选阶段**：唯一元素高亮为绿色，非唯一为红色。
4. **最大值标记**：动态更新当前最大值，用金色边框标记。

### 复古像素风格
- **颜色方案**：16色调色板，数值不同颜色不同，哈希表用灰色背景。
- **音效**：
  - **访问元素**：8-bit“点击”声。
  - **找到唯一值**：上扬音效。
  - **更新最大值**：金币收集音效。

### 交互功能
- **步进控制**：允许单步执行，观察哈希表更新过程。
- **自动播放**：AI自动演示，速度可调。

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    vector<int> a(n+1);
    unordered_map<int, int> cnt;
    for (int i=1; i<=n; i++) {
        cin >> a[i];
        cnt[a[i]]++;
    }
    int max_val = -1, ans = -1;
    for (int i=1; i<=n; i++) {
        if (cnt[a[i]] == 1 && a[i] > max_val) {
            max_val = a[i];
            ans = i;
        }
    }
    cout << ans;
    return 0;
}
```

---
处理用时：275.23秒
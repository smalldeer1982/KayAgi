# 题目信息

# [ABC399B] Ranking with Ties

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc399/tasks/abc399_b

编号为 $1$ 至 $N$ 的 $N$ 人参加了一场竞赛，其中第 $i$ 人（$1 \leq i \leq N$）的 **得分** 为 $P_i$。

本竞赛的 **排名** 按照以下流程确定：

1. 准备变量 $r$ 并初始化为 $r = 1$。初始时所有 $N$ 人的排名均为未确定状态。
2. 重复以下操作直到所有 $N$ 人的排名确定：
   - 设当前未确定排名的人中最高得分为 $x$，且得分为 $x$ 的人数为 $k$。将所有得分为 $x$ 的 $k$ 人的排名确定为 $r$ 位，然后将 $r$ 增加 $k$。

请输出这 $N$ 人各自的排名。

## 说明/提示

### 约束条件

- $1 \leq N \leq 100$
- $1 \leq P_i \leq 100$
- 所有输入均为整数

### 样例解释 1

以下为 $N\ (=4)$ 人排名的确定流程：
1. 准备变量 $r$ 并初始化为 $r = 1$。初始时所有 4 人的排名均为未确定状态。
2. 当前未确定排名的是人 1、2、3、4，其中最高得分为 $P_2\ (=12)$。因此确定人 2 的排名为 $r\ (=1)$ 位，之后将 $r$ 增加 1 得 $r = 2$。
3. 当前未确定排名的是人 1、3、4，其中最高得分为 $P_3 = P_4\ (=9)$。因此确定人 3、4 的排名为 $r\ (=2)$ 位，之后将 $r$ 增加 2 得 $r = 4$。
4. 当前未确定排名的是人 1，其得分为 $P_1\ (=3)$。因此确定人 1 的排名为 $r\ (=4)$ 位，之后将 $r$ 增加 1 得 $r = 5$。
5. 所有 4 人的排名已确定，流程结束。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4

3 12 9 9```

### 输出

```
4

1

2

2```

## 样例 #2

### 输入

```
3

3 9 6```

### 输出

```
3

1

2```

## 样例 #3

### 输入

```
4

100 100 100 100```

### 输出

```
1

1

1

1```

## 样例 #4

### 输入

```
8

87 87 87 88 41 38 41 38```

### 输出

```
2

2

2

1

5

7

5

7```

# AI分析结果



---

**唯一算法分类**  
模拟

---

### **综合分析与结论**  
题目要求根据特定规则为参赛者分配排名，核心在于按得分分组处理，每组分配同一排名并更新变量`r`。  
- **核心算法流程**：  
  1. 初始化变量`r=1`，标记数组`processed[]`记录处理状态。  
  2. 循环直到所有人处理完毕：  
     a. 找到未处理者中的最高分`x`。  
     b. 统计所有得分为`x`的人数`k`，设置他们的排名为`r`。  
     c. 更新`r += k`，标记这些人为已处理。  
- **可视化设计**：  
  - **颜色标记**：未处理者为灰色，当前处理的最高分组高亮为红色，处理完成后变为绿色。  
  - **步进控制**：单步展示每次循环的`x`值、`k`值和`r`的更新过程。  
  - **动画效果**：用动态箭头或闪烁边框突出当前操作的得分和对应参赛者。  

---

### **最优思路与代码实现**  
**关键思路**：通过排序预处理得分，按降序分组处理，每组直接分配排名，避免多次遍历。  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<pair<int, int>> sorted; // (得分, 原始索引)
    for (int i = 0; i < N; ++i) {
        int p;
        cin >> p;
        sorted.emplace_back(-p, i); // 降序排序
    }
    sort(sorted.begin(), sorted.end());
    
    vector<int> ans(N);
    int r = 1;
    for (int i = 0; i < N; ) {
        int current_score = -sorted[i].first;
        int j = i;
        while (j < N && -sorted[j].first == current_score) j++;
        for (int k = i; k < j; ++k) ans[sorted[k].second] = r;
        r += j - i;
        i = j;
    }
    
    for (int rank : ans) cout << rank << "\n";
    return 0;
}
```
**核心逻辑**：  
1. 将得分与原始索引绑定后降序排序。  
2. 遍历排序结果，对每组相同得分直接分配当前`r`值，并更新`r`。  

---

### **同类型题推荐**  
1. **P1093 [NOIP2007 普及组] 奖学金**：按多条件排序并处理排名。  
2. **P1781 宇宙总统**：处理大数排序与索引映射。  
3. **P1068 [NOIP2009 普及组] 分数线划定**：分组统计与排名规则应用。  

---

### **可视化与游戏化设计**  
- **像素动画**：用 8-bit 风格显示参赛者得分方块，处理时切换颜色并播放音效。  
- **控制面板**：支持暂停/继续、调整动画速度，展示当前`r`值和处理进度。  
- **音效设计**：分组处理时播放“得分”音效，完成时播放胜利音效。  
- **Canvas 实现**：动态绘制得分方块和排名标签，用颜色区分处理状态。  

---

**总结**：本题通过模拟或排序均可高效解决，排序法在代码简洁性和效率上更优。核心在于理解分组处理规则，合理利用数据结构简化实现。

---
处理用时：200.29秒
# 题目信息

# [ARC181A] Sort Left and Right

## 题目描述

给你一个 $(1,2,\dots,N)$ 的排列 $P=(P_1,P_2,\dots,P_N)$。

你要通过执行以下操作零次或多次来满足所有 $i=1,2,\dots,N$ 的 $P_i=i$：

- 选择一个整数 $k$，使得 $1 \leq k \leq N$。如果是 $k \geq 2$，把第 $1$ 项到第 $(k-1)$ 项的 $P$ 按升序排序。然后，如果是 $k \leq N-1$，把 $P$ 的第 $(k+1)$ 项到第 $N$ 项按升序排序。

可以证明，在这个问题的约束条件下，对于任意 $P$，都可以用有限次的运算满足所有 $i=1,2,\dots,N$ 的 $P_i=i$。请求解所需的最小运算次数。

## 说明/提示

**样例解释**

对于第一个测试用例：

- 对 $k=1$ 执行操作后，$P$ 变成了 $(2,1,3,4,5)$。
    
- 执行 $k=2$ 操作后，$P$ 变为 $(2,1,3,4,5)$。
    
- 与 $k=3$ 进行运算，结果是 $P$ 变为 $(1,2,3,4,5)$。
    
- 与 $k=4$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    
- 与 $k=5$ 进行运算，结果是 $P$ 变为 $(1,2,3,5,4)$。
    

具体来说，对 $k=3$ 进行运算的结果是 $P$ 满足所有 $i=1,2,\dots,5$ 的 $P_i=i$。因此，所需的最少运算次数为 $1$。

在第三个测试用例中，先执行 $k=4$ 操作，再执行 $k=3$ 操作，结果 $P$ 变为 $(3,2,1,7,5,6,4) \rightarrow (1,2,3,7,4,5,6) \rightarrow (1,2,3,4,5,6,7)$ 。


对于 $100\%$ 的测试数据，保证 $1 \leq T \leq 10^5$，$3 \leq N \leq 2 \times 10^5$，$P$ 是 $(1,2,\dots,N)$ 的排列。

## 样例 #1

### 输入

```
3

5

2 1 3 5 4

3

1 2 3

7

3 2 1 7 5 6 4```

### 输出

```
1

0

2```

# AI分析结果



## 算法分类
**分类讨论**

## 题解思路与算法要点
### 核心思路
1. **操作分析**：每次操作可将前k-1项或后k+1项排序，中间元素k保持不变。
2. **关键观察**：
   - 若存在某个位置i，其左侧已排序的最大值为i-1，右侧已排序的最小值为i+1，且a[i]=i，则只需1次操作。
   - 若首元素为n且末元素为1，需3次操作。
   - 其他情况需2次操作。

### 解决难点
- **快速判断是否存在满足条件的i**：通过预处理前缀最大值和后缀最小值数组，实现O(n)复杂度。
- **特殊边界处理**：首尾元素为n和1的特殊情况需单独处理。

## 题解评分 (≥4星)
### [作者：scp020](https://www.luogu.com.cn) ⭐⭐⭐⭐⭐
- **思路清晰**：预处理前缀最大值和后缀最小值，精确判断条件。
- **代码简洁**：使用前缀和后缀数组高效判断。
```cpp
int maxi[MAXN], mini[MAXN];
for (int i=1; i<=n; i++) maxi[i] = max(maxi[i-1], a[i]);
for (int i=n; i>=1; i--) mini[i] = min(mini[i+1], a[i]);
if (maxi[i-1] <= a[i] && a[i] <= mini[i+1] && a[i] == i) return 1;
```

### [作者：zhlzt](https://www.luogu.com.cn) ⭐⭐⭐⭐⭐
- **条件正确**：直接检查前i-1项最大值和后i+1项最小值。
- **高效实现**：双数组预处理，逻辑清晰。
```cpp
int dpl[MAXN], dpr[MAXN];
for (int i=1; i<=n; i++) dpl[i] = max(dpl[i-1], p[i]);
for (int i=n; i>=1; i--) dpr[i] = min(dpr[i+1], p[i]);
if (dpl[i-1] < p[i] && p[i] < dpr[i+1] && p[i] == i) return 1;
```

### [作者：JXR_Kalcium](https://www.luogu.com.cn) ⭐⭐⭐⭐
- **思路正确**：维护当前最大值，简化条件判断。
- **代码优化**：减少数组使用，但未显式处理后缀条件，存在理论风险。

## 最优思路提炼
1. **前缀后缀预处理**：计算前缀最大值数组`max_prefix`和后缀最小值数组`min_suffix`。
2. **遍历检查条件**：对每个i，若`max_prefix[i-1] == i-1`、`min_suffix[i+1] == i+1`且`a[i] == i`，则返回1次。
3. **首尾特殊判断**：若首尾元素为n和1，返回3次，否则2次。

## 同类型题推荐
1. [CF1144D - Equalize Them All](https://codeforces.com/problemset/problem/1144/D)
2. [LeetCode 670 - Maximum Swap](https://leetcode.com/problems/maximum-swap/)
3. [洛谷 P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

## 可视化算法演示
### 动画方案
- **可视化步骤**：
  1. **初始化**：展示原始数组，高亮前缀和后缀处理区域。
  2. **遍历检查**：步进遍历每个i，动态更新前缀最大值和后缀最小值，高亮当前i是否符合条件。
  3. **操作模拟**：若符合条件，展示排序后的效果；否则根据首尾情况展示操作次数。

### 复古像素风格
- **颜色方案**：8位色调，绿色表示已排序区域，红色表示当前检查位置。
- **音效**：步进时播放“滴”声，成功时播放胜利音效，失败时短促“哔”声。

### 关键代码片段
```javascript
// 伪代码：前缀后缀处理与条件检查
let preMax = new Array(n+2).fill(0);
let sufMin = new Array(n+2).fill(n+1);
for (let i=1; i<=n; i++) preMax[i] = Math.max(preMax[i-1], a[i]);
for (let i=n; i>=1; i--) sufMin[i] = Math.min(sufMin[i+1], a[i]);
for (let i=1; i<=n; i++) {
    if (preMax[i-1] === i-1 && sufMin[i+1] === i+1 && a[i] === i) {
        return 1;
    }
}
```

## 总结
本题通过分类讨论和预处理技术高效解决，核心在于利用前缀和后缀数组快速判断是否存在一次操作的可能，特殊边界需单独处理。

---
处理用时：223.64秒
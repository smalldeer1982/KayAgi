# 题目信息

# [ABC325C] Sensors

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc325/tasks/abc325_c

$ H $ 行 $ W $ 列のマス目の上に $ 0 $ 個以上のセンサが配置されています。上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,\ j) $ と表記します。   
 センサが配置されているマス目の情報は長さ $ W $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_H $ によって与えられ、$ S_i $ の $ j $ 文字目が `#` のとき、またそのときに限り $ (i,\ j) $ にセンサが配置されています。  
 このセンサは上下左右斜めに隣接しているマス目に存在する他のセンサと連動し、一つのセンサとして動作します。 ただし、マス目 $ (x,\ y) $ と $ (x',\ y') $ が上下左右斜めに隣接しているとは、$ \max(|x-x'|,|y-y'|)\ =\ 1 $ であることを指します。  
 また、センサ $ A $ とセンサ $ B $ が連動し、センサ $ A $ とセンサ $ C $ が連動しているとき、センサ $ B $ とセンサ $ C $ も連動することに注意してください。

連動するセンサを一つのセンサと見なしたとき、このマス目の上にあるセンサの個数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 1000 $
- $ H,\ W $ は整数
- $ S_i $ は各文字が `#` または `.` である長さ $ W $ の文字列
 
### Sample Explanation 1

連動しているセンサを一つのセンサと見なしたとき、 - $ (1,2),(1,3),(2,4),(3,5),(3,6) $ にあるセンサが連動したもの - $ (4,1) $ にあるセンサ - $ (4,3),(5,3) $ にあるセンサが連動したもの の $ 3 $ つのセンサが存在します。

## 样例 #1

### 输入

```
5 6

.##...

...#..

....##

#.#...

..#...```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3

#.#

.#.

#.#```

### 输出

```
1```

## 样例 #3

### 输入

```
4 2

..

..

..

..```

### 输出

```
0```

## 样例 #4

### 输入

```
5 47

.#..#..#####..#...#..#####..#...#...###...#####

.#.#...#.......#.#...#......##..#..#...#..#....

.##....#####....#....#####..#.#.#..#......#####

.#.#...#........#....#......#..##..#...#..#....

.#..#..#####....#....#####..#...#...###...#####```

### 输出

```
7```

# AI分析结果



**唯一算法分类：其他搜索**

---

### **题解思路与算法要点**

- **核心思路**：所有题解均采用搜索算法（DFS/BFS）统计八个方向连通的传感器块数。关键在于遍历网格，对每个未访问的`#`启动搜索并标记连通块。
- **解决难点**：
  - **方向处理**：使用八个方向的偏移量数组（如`dx[8]`和`dy[8]`），简化邻接点遍历。
  - **标记策略**：通过直接修改原数组（`#`→`.`）或维护`visited`数组避免重复访问。
  - **空间优化**：修改原数组可省去额外空间，适用于大规模网格。
- **算法对比**：
  - **BFS**：队列管理访问顺序，按层扩展，适合均匀扩展的连通块。
  - **DFS**：递归或栈实现，深度优先遍历，代码简洁但可能栈溢出（实际数据通过）。
  
---

### **题解评分 (≥4星)**

1. **xxr___的BFS题解 (4星)**  
   - 亮点：代码结构清晰，队列管理明确，直接修改原数组省空间。
   - 核心代码：
     ```cpp
     void bfs(int x, int y) {
         queue<pair<int,int>> q; q.push({x,y});
         while (!q.empty()) {
             auto v = q.front(); q.pop();
             for (int i=0; i<8; i++) {
                 int xx = v.first+dx[i], yy = v.second+dy[i];
                 if (xx>=1 && xx<=n && yy>=1 && yy<=m && ch[xx][yy]=='#') {
                     ch[xx][yy] = '.';
                     q.push({xx, yy});
                 }
             }
         }
     }
     ```

2. **SunSkydp的DFS题解 (4星)**  
   - 亮点：使用独立标记数组保留原数据，逻辑易扩展。
   - 核心代码：
     ```cpp
     void dfs(int x, int y) {
         for (int i=0; i<8; i++) {
             int xx = x+xy[i][0], yy = y+xy[i][1];
             if (valid(xx, yy) && !a[xx][yy] && c[xx][yy]=='#') {
                 a[xx][yy] = cnt;
                 dfs(xx, yy);
             }
         }
     }
     ```

3. **SiriusIV的DFS题解 (4星)**  
   - 亮点：简洁的偏移量数组和边界检查，代码可读性强。
   - 核心代码：
     ```cpp
     void dfs(int x, int y) {
         for (int i=0; i<8; i++) {
             int xx = x+dir[i][0], yy = y+dir[i][1];
             if (xx>=1 && xx<=n && yy>=1 && yy<=m && mp[xx][yy]=='#') {
                 mp[xx][yy] = '.';
                 dfs(xx, yy);
             }
         }
     }
     ```

---

### **最优思路与技巧**

- **方向偏移量数组**：统一管理八个方向的坐标变化，简化遍历逻辑。
- **原地标记优化**：直接修改原数组的`#`为`.`，省去额外空间。
- **遍历顺序无关性**：DFS/BFS均可，因连通块形状不影响计数，仅需覆盖所有邻接点。

---

### **同类型题与算法套路**

- **类似题目**：
  - **洛谷P1451**：四方向连通块计数。
  - **LeetCode 200. Number of Islands**：二维网格连通块问题。
  - **洛谷P1141 01迷宫**：预处理连通块加速查询。
- **通用套路**：网格遍历 + 搜索标记，适用于迷宫、岛屿、细胞计数等问题。

---

### **推荐练习题目**

1. **洛谷P1451**（求细胞数量）  
2. **洛谷P1162**（填涂颜色，BFS应用）  
3. **洛谷P1141**（01迷宫，连通块预处理）

---

### **个人心得摘录**

- **调试教训**：递归DFS需注意网格大小（1000x1000可能栈溢出，但实际测试数据较宽松）。
- **思维陷阱**：易忽略对角线方向，误判为四方向连通。

---

### **可视化与算法演示**

- **动画设计**：
  - **网格渲染**：Canvas绘制网格，当前节点高亮为红色，已访问节点为灰色，队列节点为蓝色。
  - **步进控制**：单步执行展示BFS队列变化或DFS递归路径。
  - **音效提示**：访问新节点时播放“滴”声，连通块计数完成时播放胜利音效。
- **复古像素风格**：
  - **颜色方案**：绿色为未访问，棕色为传感器，红色为当前节点。
  - **音效**：8-bit风格背景音乐，节点访问音效使用ChipTone生成。
- **自动演示**：按BFS顺序自动扩展队列，动态显示连通块标记过程。

---
处理用时：100.92秒
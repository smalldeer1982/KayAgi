# 题目信息

# [ABC333D] Erase Leaves

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_d

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる木が与えられます。 $ i $ 番目 $ (1\leq\ i\lt\ N) $ の辺は頂点 $ u\ _\ i $ と $ v\ _\ i $ を結んでいます。

次の操作を好きな回数繰り返すことを考えます。

- 葉である頂点 $ v $ を $ 1 $ つ選び、頂点 $ v $ およびそれに接続する辺をすべて削除する。
 
頂点 $ 1 $ を削除するまでに最小で操作を何回行う必要があるか求めてください。

 木とは？ 木とは、無向グラフのうち連結であって閉路がないものです。 詳しくはこちらをご覧ください: [Wikipedia「木 (数学)」](https://ja.wikipedia.org/wiki/%E6%9C%A8_(%E6%95%B0%E5%AD%A6))  葉とは？ 木の葉とは、木の頂点のうち次数がたかだか $ 1 $ であるものです。

## 说明/提示

### 制約

- $ 2\leq\ N\leq3\times10^5 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\lt\ N) $
- 与えられるグラフは木
- 入力はすべて整数
 
### Sample Explanation 1

与えられるグラフは次のようになります。 !\[\](https://img.atcoder.jp/abc333/6089239ee0c331bec4cd4472c032d197.png) たとえば、頂点 $ 9,8,7,6,1 $ の順に選んで操作を行うことで、$ 5 $ 回の操作で頂点 $ 1 $ を削除することができます。 !\[\](https://img.atcoder.jp/abc333/7dba9a660bfabdd403fe6882dac4e8ab.png) $ 4 $ 回以下の操作では頂点 $ 1 $ を削除することはできないため、$ 5 $ を出力してください。

### Sample Explanation 2

与えられたグラフにおいて、頂点 $ 1 $ は葉です。 よって、$ 1 $ 回目の操作で頂点 $ 1 $ を選んで削除することができます。

## 样例 #1

### 输入

```
9

1 2

2 3

2 4

2 5

1 6

6 7

7 8

7 9```

### 输出

```
5```

## 样例 #2

### 输入

```
6

1 2

2 3

2 4

3 5

3 6```

### 输出

```
1```

## 样例 #3

### 输入

```
24

3 6

7 17

7 20

7 11

14 18

17 21

6 19

5 22

9 24

11 14

6 23

8 17

9 12

4 17

2 15

1 17

3 9

10 16

7 13

2 16

1 16

5 7

1 3```

### 输出

```
12```

# AI分析结果



## 算法分类
**DFS**

## 综合分析与结论
本题要求删除节点1的最少操作次数，核心思路是将其变为叶节点。通过DFS计算以节点1为根的各个子树大小，保留最大子树，其余子树均需删除。总操作次数为总节点数减去最大子树大小，再加1次删除节点1的操作。关键难点在于正确遍历子树并统计大小，避免重复计算。所有题解均采用DFS遍历树结构，时间复杂度O(n)。

## 题解清单 (≥4星)
1. **Hughpig (4星)**  
   - 亮点：代码简洁，直接DFS统计子树大小，逻辑清晰。处理了节点1为叶子的特殊情况。
2. **BLuemoon_ (4星)**  
   - 亮点：直接输出总节点数减去最大子树大小，代码更高效，省去求和步骤。
3. **2huk (4星)**  
   - 亮点：思路清晰，代码简短，通过递归快速计算子树大小。

## 最优思路或技巧提炼
1. **DFS遍历子树大小**：以节点1为根，递归计算每个子树的节点数。
2. **保留最大子树**：总操作次数为总节点数减去最大子树的大小。
3. **边界处理**：若节点1初始即为叶节点，直接返回1。

## 同类型题或类似算法套路
- **子树统计问题**：如计算树中每个节点的子树大小、最长路径等。
- **贪心优化删除顺序**：优先保留最大/最小子树以减少操作次数。
- **树形DP**：通过递归自底向上传递子树信息，优化决策。

## 推荐题目
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)  
2. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)  
3. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)  

## 代码片段（DFS核心逻辑）
```cpp
vector<int> G[maxn];
int sz[maxn], ans;

void dfs(int u, int fa) {
    sz[u] = 1;
    for (int v : G[u]) {
        if (v != fa) {
            dfs(v, u);
            sz[u] += sz[v];
            if (u == 1) ans = max(ans, sz[v]);
        }
    }
}

int main() {
    // 建树后调用dfs(1, 0)
    cout << n - ans;
}
```

## 可视化与算法演示
**动画方案**：  
1. **树结构绘制**：以节点1为中心，用不同颜色区分各子树。
2. **DFS遍历**：用高亮显示当前访问节点，递归展开子树并统计大小。
3. **结果展示**：突出最大子树，其余子树标红表示删除，最终显示操作次数。

**复古像素风格**：  
- **节点绘制**：用8位像素方块表示节点，访问时闪烁。
- **音效**：访问节点时播放“哔”声，删除子树时播放爆炸音效。
- **自动演示**：按空格键逐步执行DFS，Esc键暂停/继续。

---

**总结**：通过DFS高效统计子树大小，结合贪心策略保留最大子树，是解决此类树形问题的典型方法。

---
处理用时：119.38秒
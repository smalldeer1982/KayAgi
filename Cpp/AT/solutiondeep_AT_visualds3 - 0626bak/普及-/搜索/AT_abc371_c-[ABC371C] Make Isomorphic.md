# 题目信息

# [ABC371C] Make Isomorphic

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_c

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる単純無向グラフ $ G,H $ が与えられます。 $ G $ には $ M\ _\ G $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ G) $ の辺は頂点 $ u\ _\ i $ と頂点 $ v\ _\ i $ を結んでいます。 $ H $ には $ M\ _\ H $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ H) $ の辺は頂点 $ a\ _\ i $ と頂点 $ b\ _\ i $ を結んでいます。

あなたは、グラフ $ H $ に対して次の操作を $ 0 $ 回以上の好きな回数繰り返すことができます。

- $ 1\leq\ i\lt\ j\leq\ N $ を満たす整数の組 $ (i,j) $ をひとつ選ぶ。$ A\ _\ {i,j} $ 円を支払って、頂点 $ i $ と頂点 $ j $ を結ぶ辺がなければ追加し、あれば取り除く。

$ G $ と $ H $ を同型にするために少なくとも何円支払う必要があるか求めてください。

単純無向グラフとは？ **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

グラフの同型とは？ $ N $ 頂点のグラフ $ G $ と $ H $ が**同型**であるとは、ある $ (1,2,\ldots,N) $ の並べ替え $ (P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が存在して、どの $ 1\leq\ i\lt\ j\leq\ N $ に対しても

- $ G $ に頂点 $ i, $ 頂点 $ j $ を結ぶ辺が存在するとき、かつそのときに限り $ H $ に頂点 $ P\ _\ i, $ 頂点 $ P\ _\ j $ を結ぶ辺が存在する

が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq8 $
- $ 0\leq\ M\ _\ G\leq\dfrac{N(N-1)}2 $
- $ 0\leq\ M\ _\ H\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ G) $
- $ (u\ _\ i,v\ _\ i)\neq(u\ _\ j,v\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ G) $
- $ 1\leq\ a\ _\ i\lt\ b\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ H) $
- $ (a\ _\ i,b\ _\ i)\neq(a\ _\ j,b\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ H) $
- $ 1\leq\ A\ _\ {i,j}\leq\ 10\ ^\ 6\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

与えられたグラフはそれぞれ以下のようになります。 !\[\](https://img.atcoder.jp/abc371/fbdb304dc71eecd7ddec97276a9c7040.png) たとえば、$ H $ に対して次のような $ 4 $ つの操作を順に行うことで、$ 9 $ 円を支払って$ G $ と $ H $ を同型にすることができます。 - $ (i,j)=(1,3) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(2,5) $ として操作を行う。$ H $ には頂点 $ 2 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 2 $ 円を支払ってこれを追加する。 - $ (i,j)=(1,5) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 5 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(3,5) $ として操作を行う。$ H $ には頂点 $ 3 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 5 $ 円を支払ってこれを追加する。 操作の結果、$ H $ は以下のようになります。 !\[\](https://img.atcoder.jp/abc371/68a56da8ec89b769989ae7d07bf163cd.png) 支払う金額を $ 8 $ 円以下にして $ G $ と $ H $ を同型にすることはできないため、`9` を出力してください。

### Sample Explanation 2

たとえば、$ (i,j)=(2,3),(2,4),(3,4) $ とした $ 3 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 3

たとえば、$ (i,j)=(4,5) $ とした $ 1 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 4

$ G $ や $ H $ には辺が含まれていないこともあります。 また、一度も操作をする必要がないこともあります。

## 样例 #1

### 输入

```
5
4
1 2
2 3
3 4
4 5
4
1 2
1 3
1 4
1 5
3 1 4 1
5 9 2
6 5
3```

### 输出

```
9```

## 样例 #2

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
9 1 1 1
1 1 1
1 1
9```

### 输出

```
3```

## 样例 #3

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
5 4 4 4
4 4 4
4 4
5```

### 输出

```
5```

## 样例 #4

### 输入

```
2
0
0
371```

### 输出

```
0```

## 样例 #5

### 输入

```
8
13
1 8
5 7
4 6
1 5
7 8
1 6
1 2
5 8
2 6
5 6
6 7
3 7
4 8
15
3 5
1 7
4 6
3 8
7 8
1 2
5 6
1 6
1 5
1 4
2 8
2 6
2 4
4 7
1 3
7483 1694 5868 3296 9723 5299 4326
5195 4088 5871 1384 2491 6562
1149 6326 2996 9845 7557
4041 7720 1554 5060
8329 8541 3530
4652 3874
3748```

### 输出

```
21214```

# AI分析结果



## 算法分类
其他搜索

## 综合分析与结论
本题要求通过调整图H的边使其与图G同构，最小化操作成本。核心思路是全排列枚举顶点映射，比较边差异并累加对应成本。由于N≤8，O(N! * N²)的复杂度可接受。

**关键难点与解决方式**：
1. **排列方向与边比较**：正确映射顶点排列，比较G的边i-j与H的排列后顶点p[i]-p[j]的边存在性。需确保查询H的邻接矩阵时顶点顺序正确（i<j）。
2. **操作成本计算**：根据H的原始顶点p[i]和p[j]，正确累加对应的成本A[p[i]][p[j]]。需对称处理A数组以避免顺序问题。
3. **剪枝与优化**：无需复杂剪枝，直接枚举所有排列即可。

**可视化设计思路**：
- **动画方案**：展示全排列生成过程，每一步高亮当前排列的顶点映射。对比两图的边差异，红色标记需操作的边并显示累计成本。
- **交互设计**：允许调整排列生成速度，单步执行观察比较过程。右侧面板实时显示当前最小成本及对应排列。
- **复古像素风格**：用8-bit风格绘制顶点和边，访问节点时播放经典音效。成功找到最优解时播放通关音乐。

## 题解清单（≥4星）
1. **作者：xiaoke2021（4星）**
   - 亮点：正确处理顶点顺序，使用min/max确保邻接矩阵查询正确。代码简洁，利用next_permutation生成排列。
2. **作者：Him_shu（4星）**
   - 亮点：对称处理A数组，DFS生成排列。虽变量名易混淆，但核心逻辑正确。
3. **作者：fengzhaoyu（4星）**
   - 亮点：对称处理A数组，正确比较边存在性。代码结构清晰，但变量命名需改进。

## 最优思路与技巧
1. **全排列枚举**：利用next_permutation或DFS生成所有顶点映射。
2. **邻接矩阵对称处理**：确保无论顶点顺序如何，边查询和成本计算正确。
3. **边差异比较**：遍历所有i<j，比较G[i][j]与H[p[i]][p[j]]的存在性，差异时累加A[min(p[i],p[j])][max(p[i],p[j])]。

**示例代码（核心逻辑）**：
```cpp
int cnt[10]; // 排列数组，cnt[i]表示G的顶点i对应H的顶点cnt[i]
do {
    long long sum = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            int u = cnt[i], v = cnt[j];
            if (u > v) swap(u, v);
            if (G[i][j] != H[u][v]) {
                sum += A[u][v];
            }
        }
    }
    ans = min(ans, sum);
} while (next_permutation(cnt + 1, cnt + n + 1));
```

## 相似题目推荐
1. **P1219 八皇后**：全排列枚举解空间，剪枝优化。
2. **P1706 全排列问题**：基础全排列生成，理解枚举原理。
3. **P1120 小木棍**：DFS剪枝优化，适合练习搜索策略。

---
处理用时：381.09秒
# 题目信息

# [ABC374C] Separated Lunch

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_c

キーエンス本社に勤務する人数が増えてきたので、本社に存在する部署を $ 2 $ つのグループに分け、昼休みの時間帯を分けることにしました。

キーエンス本社には $ N $ 個の部署が存在し、$ i $ 番目 $ (1\leq\ i\leq\ N) $ の部署に所属する人数は $ K_i $ 人です。

それぞれの部署をグループ $ A $, $ B $ のいずれか一方に割り当て、グループごとに同時に昼休みをとり、 かつグループ $ A $, $ B $ の昼休みの時間が重ならないようにしたとき、同時に昼休みをとる最大人数としてあり得る最小の値を求めてください。  
 すなわち、グループ $ A $ に割り当てられた部署に所属する人数の合計とグループ $ B $ に割り当てられた部署に所属する人数の合計 のうち大きい方の値としてあり得る最小の値を求めてください。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 20 $
- $ 1\leq\ K_i\ \leq\ 10^8 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1,2,5 $ 番目の部署をグループ $ A $ に、$ 3,4 $ 番目の部署をグループ $ B $ に割り当てたとき、 グループ $ A $ に割り当てられた部署に所属する人数の合計は $ 2+3+12=17 $ 、 グループ $ B $ に割り当てられた部署に所属する人数の合計は $ 5+10=15 $ となり、 このとき同時に昼休みを取る最大人数は $ 17 $ となります。 一方で、グループ $ A,B $ それぞれに割り当てられた部署に所属する人数の合計がいずれも $ 16 $ 以下になるように 部署を割り当てることはできないため、$ 17 $ を出力します。

### Sample Explanation 2

同一人数の部署が複数存在する可能性もあります。

### Sample Explanation 3

例えば、$ 1,4,5 $ 番目の部署をグループ $ A $ に、$ 2,3,6 $ 番目の部署をグループ $ B $ に割り当てたとき同時に昼休みを取る最大人数は $ 89 $ となります。

## 样例 #1

### 输入

```
5

2 3 5 10 12```

### 输出

```
17```

## 样例 #2

### 输入

```
2

1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
6

22 25 26 45 22 31```

### 输出

```
89```

# AI分析结果



# 【算法分类】
**DFS**

---

# 【题解思路、算法要点与解决难点】

## **核心思路**
所有题解均基于暴力枚举所有分组可能性，寻找最大组人数的最小值。因 `n ≤ 20`，时间复杂度 `O(2^n)` 可行。

### **解决难点**
1. **枚举所有可能分组**：每个部门有两种选择（A组或B组），需遍历所有 `2^20 ≈ 1e6` 种可能。
2. **快速计算分组和**：通过状态压缩或递归参数传递直接累加和，避免重复计算。

## **关键算法对比**
| 方法        | 实现方式                     | 时间复杂度  | 空间复杂度 | 优化点                     |
|-------------|----------------------------|------------|------------|--------------------------|
| 状态压缩     | 预计算所有子集和，遍历取最优 | O(n·2^n)   | O(2^n)     | 预处理子集和，减少重复计算 |
| DFS         | 递归分治，记录当前分组和    | O(2^n)     | O(n)       | 剪枝优化潜力大             |

---

# 【题解评分 (≥4星)】

1. **A_R_O_N_A（状态压缩）**  
   ⭐⭐⭐⭐⭐  
   **亮点**：代码简洁，预处理子集和，逻辑清晰易理解。

2. **fishing_cat（DFS）**  
   ⭐⭐⭐⭐  
   **亮点**：递归参数传递直观，适合DFS新手学习。

3. **Leo2011（DFS）**  
   ⭐⭐⭐⭐  
   **亮点**：代码注释详细，包含调试经验与心得。

---

# 【最优思路或技巧提炼】

1. **状态压缩枚举**：用二进制位表示部门分组，预计算所有子集和。
2. **DFS剪枝优化**：若当前最大值已超过已知最优解，提前终止递归。
3. **总和对称性**：计算总和后，只需遍历到 `总和/2` 即可（部分题解未使用）。

---

# 【同类型题与算法套路】

- **子集划分问题**：如分割等和子集（LeetCode 416）。
- **状态压缩应用**：适用于小规模集合的暴力枚举问题。
- **DFS剪枝优化**：常见于组合优化问题（如背包、排列组合）。

---

# 【洛谷推荐题目】
1. **P2392 考前临时抱佛脚**（子集划分优化）
2. **P1441 砝码称重**（枚举子集+动态规划）
3. **P2320 神奇的分组**（分组最优化问题）

---

# 【个人心得摘录】

- **Leo2011**：  
  *“n≤20 时，爆搜挂着机，打表出 AC”*  
  → 强调暴力法在小数据场景的有效性。

- **zhengyi0402**：  
  *“十年OI一场空，不开long long见祖宗”*  
  → 提醒注意数据范围，避免溢出。

---

# 【可视化与算法演示】

## **动画设计**
1. **树状展开**：以部门为节点，左右分支表示加入A/B组，递归展开。
2. **实时和更新**：高亮当前分组和，动态显示最大值的更新过程。
3. **剪枝提示**：当当前路径最大值超过最优解时，标记为红色并停止扩展。

## **复古像素风格**
- **Canvas绘制**：部门用8位像素块表示，分组路径用不同颜色线段连接。
- **音效设计**：
  - **选择分支**：8-bit“哔”声。
  - **找到更优解**：经典马里奥金币音效。
- **自动演示**：按BFS顺序遍历所有可能路径，模拟“AI探索”。

---

# 【核心代码片段】

## **状态压缩实现**
```cpp
ll sum = 0, ans = LLONG_MAX;
for (int i=0; i<(1<<n); i++) {
    ll s = 0;
    for (int j=0; j<n; j++) 
        if (i & (1<<j)) s += a[j];
    ans = min(ans, max(s, sum-s));
}
```

## **DFS剪枝优化**
```cpp
void dfs(int u, int sumA, int sumB) {
    if (max(sumA, sumB) >= ans) return; // 剪枝
    if (u == n) {
        ans = min(ans, max(sumA, sumB));
        return;
    }
    dfs(u+1, sumA+a[u], sumB);
    dfs(u+1, sumA, sumB+a[u]);
}
```

---

# **总结**
本题通过暴力枚举所有分组可能性求解最优值，状态压缩与DFS均为高效解法。未来类似问题可优先考虑小规模暴力或剪枝优化。

---
处理用时：64.99秒
# 题目信息

# [ABC378D] Count Simple Paths

## 题目描述

给定一个 $H$ 行 $W$ 列的网格；令 $(i, j)$ 为网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子。 

当 $ S_{i,j} $ 为 `.` 时，格子为空格；当 $ S_{i,j} $ 为 `#` 时，格子为障碍物。

请计算从某个空格出发，经过 $K$ 次移动（上下左右），不经过障碍物且不重复经过同一个格子的路径数。

具体地，统计满足以下条件的，长度为 $K+1$ 的序列 $((i_0,j_0),(i_1,j_1),\dots,(i_K,j_K))$

- 对于每个 $ 0\ \leq\ k\ \leq\ K $，都有 $ 1\ \leq\ i_k\ \leq\ H,\ 1\ \leq\ j_k\ \leq\ W $，且 $ S_{i_k,j_k} $ 为 `.`。
- 对于每个 $ 0\ \leq\ k\ \leq\ K-1 $，有 $ |i_{k+1}-i_k|\ +\ |j_{k+1}-j_k|\ =\ 1 $。
- 对于每个 $ 0\ \leq\ k\ <\ l\ \leq\ K $，有 $ (i_k,j_k)\neq\ (i_l,j_l) $。

## 说明/提示

-  $1 \leq H, W \leq 10$
-  $1 \leq K \leq 11$
-  $H$, $W$, 和 $K$ 均为整数。
-  每个 $S_{i,j}$ 均为 `.` 或 `#`。
-  网格中至少存在一个格子为空格。

## 样例 #1

### 输入

```
2 2 2
.#
..```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 1
.#.
#.#```

### 输出

```
0```

## 样例 #3

### 输入

```
10 10 11
....#..#..
.#.....##.
..#...##..
...#......
......##..
..#......#
#........#
..##......
.###....#.
...#.....#```

### 输出

```
218070```

# AI分析结果



# 算法分类：DFS

## 综合分析与结论

### 题解思路与核心难点
本题需要统计所有长度为 K+1 的简单路径数量。各题解核心思路均为回溯+DFS：
1. **枚举起点**：遍历每个有效格子作为起点
2. **DFS回溯**：维护 visited 数组，每次递归标记当前节点，遍历四个方向后回溯
3. **剪枝条件**：越界检测、障碍物判断、重复访问判断
4. **终止条件**：当移动次数等于 K 时计数（对应路径长度为 K+1）

**解决难点**在于正确管理访问标记数组：
- 必须使用回溯法及时恢复现场，否则会影响其他路径的统计
- BFS 方案因状态存储复杂度高，效率低于 DFS 回溯方案

### 可视化设计思路
1. **网格动画**：以网格形式展示当前路径扩展过程，用不同颜色区分已访问节点、当前节点、障碍物
2. **回溯高亮**：使用颜色渐变效果显示回溯过程
3. **音效提示**：访问新节点时播放清脆音效，完成路径时播放成功音效
4. **自动演示**：按 500ms/步速度自动展示 DFS 扩展顺序
5. **交互面板**：支持暂停/继续、单步执行、重置场景

（示例伪代码）
```javascript
// 画布绘制核心逻辑
function drawGrid() {
  for(let i=0; i<H; i++) {
    for(let j=0; j<W; j++) {
      if(grid[i][j] === '#') drawObstacle(i,j);
      else if(visited[i][j]) drawVisited(i,j);
      if(i === currentX && j === currentY) drawCurrent(i,j);
    }
  }
}
```

## 题解清单（评分≥4星）

### 1. 作者：sjh0626（4.5星）
- **亮点**：参数设计清晰（step从0开始累计），代码简洁无冗余
- **关键代码**：
```cpp
void dfs(int x,int y,int step){
    if(step==k) { ans++; return; } // 终止条件明确
    vis[x][y]=1; // 标记当前节点
    for(int i=0;i<4;i++){ 
        int nx=x+dx[i], ny=y+dy[i];
        if(边界检查 && 未访问) {
            vis[nx][ny]=1;
            dfs(nx,ny,step+1);
            vis[nx][ny]=0; // 回溯
        }
    }
    vis[x][y]=0; // 恢复现场
}
```

### 2. 作者：zaolong（4星）
- **亮点**：起始步数设计为1，逻辑与题目描述严格对应
- **优化点**：使用方向数组减少冗余代码

### 3. 作者：Binah_cyc（4星）
- **亮点**：将 DFS 封装为带返回值的函数，结构更模块化
- **代码亮点**：
```cpp
int dfs(int x,int y,int t) {
    if(t==k+1) return 1; // 显式返回路径数
    vis[x][y]=1;
    int cnt = 四个方向递归求和;
    vis[x][y]=0;
    return cnt;
}
```

## 最优思路提炼
1. **回溯模板**：经典 DFS 回溯框架，时间复杂度 O(4^K*HW)
2. **状态压缩**：对 10x10 网格可用 short 类型位压缩（但本题无需优化）
3. **提前剪枝**：遇到障碍物或边界立即返回
4. **方向数组**：使用 dx[4]/dy[4] 简化方向遍历

## 同类型题目推荐
1. **P1605 迷宫** - 基础迷宫路径计数
2. **P1238 走迷宫** - 路径记录与输出 
3. **P1135 奇怪的电梯** - BFS 求最短路径

## 个人心得摘录
> "BFS 需要保存每个状态的访问情况，用 bitset 处理反而复杂。DFS 回溯只需一个全局数组，写起来更简单" —— PineappleSummer

## 代码实现（DFS 回溯）
```cpp
#include<bits/stdc++.h>
using namespace std;
int H,W,K,ans;
char grid[12][12];
bool vis[12][12];
int dx[]={1,-1,0,0}, dy[]={0,0,1,-1};

void dfs(int x,int y,int step) {
    if(step == K) { ans++; return; }
    vis[x][y] = true;
    for(int i=0; i<4; i++){
        int nx=x+dx[i], ny=y+dy[i];
        if(nx<1||nx>H||ny<1||ny>W) continue;
        if(grid[nx][ny]=='#' || vis[nx][ny]) continue;
        dfs(nx, ny, step+1);
    }
    vis[x][y] = false;
}

int main() {
    cin>>H>>W>>K;
    for(int i=1; i<=H; i++) cin>>(grid[i]+1);
    for(int i=1; i<=H; i++)
        for(int j=1; j<=W; j++)
            if(grid[i][j]=='.') dfs(i,j,0);
    cout<<ans;
    return 0;
}
```

---
处理用时：130.30秒
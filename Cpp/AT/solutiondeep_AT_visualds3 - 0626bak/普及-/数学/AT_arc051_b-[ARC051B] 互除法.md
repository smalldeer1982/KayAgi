# 题目信息

# [ARC051B] 互除法

## 题目描述

高桥君学习了欧几里得算法，他很好奇它能以多快的速度运行。

因此，他写了以下代码。

```cpp
#include <stdio.h>

int counter = 0;
int gcd(int a, int b) {
   if (b == 0) return a;
   counter++;
   return gcd(b, a%b);
}

int main() {
   int a, b;
   scanf("%d %d", &a, &b);
   gcd(a, b);
   printf("%d\n", counter);
}
```

这个代码输入两个整数，然后用欧几里得计算它们的 $\gcd$，然后输出它递归了多少次的代码。 你想让这个程序输出各种各样的值。

具体来说，输入一个 $K$，输出一组可以使得这个程序的输出为 $K$ 的 $A$、$B$。

## 说明/提示

对于 $30\%$ 的数据，$1\le K \le 10$；

对于 $100\%$ 的数据，$1\le K \le 40$。

只输出其中一种可能的解即可。

## 样例 #1

### 输入

```
1```

### 输出

```
1 1```

## 样例 #2

### 输入

```
3```

### 输出

```
4 5```

## 样例 #3

### 输入

```
12```

### 输出

```
314159265 358979323```

# AI分析结果



**算法分类选择**  
数学构造（斐波那契数列）

---

### **题解思路、算法要点与解决难点**
#### **核心思路**
- **斐波那契数列的性质**：相邻斐波那契数满足余数最大化，从而使得欧几里得算法的递归次数达到最大值。
- **构造方式**：输入的 `(A, B)` 为斐波那契数列的相邻两项 `F(K+1)` 和 `F(K)`，此时递归次数恰好为 `K` 次。

#### **解决难点**
1. **递归次数与斐波那契数的映射**  
   需通过数学推导验证斐波那契数相邻项的递归次数关系，确保每步余数最大。
2. **斐波那契数列的索引设计**  
   需明确斐波那契数列的初始条件（如 `F(0)=1` 或 `F(0)=0`）以保证构造的正确性。

#### **题解对比**
- **共同点**：均利用斐波那契数列构造输入。
- **差异点**：
  - **Aw顿顿**：直接推导斐波那契数与递归次数的关系，强调数学性质。
  - **_ZhouYuHan_**：提供代码实现，明确斐波那契数列的生成方式。
  - **xgwpp6710**：反向递推构造，每次生成更小的解。

---

### **题解评分（≥4星）**
1. **Aw顿顿（★★★★☆）**  
   - **思路清晰**：明确斐波那契数的递归次数关系。
   - **数学推导完整**：详细说明斐波那契数的余数性质。
   - **优化建议**：补充代码实现更直观。
2. **_ZhouYuHan_（★★★★☆）**  
   - **代码简洁**：直接生成斐波那契数列。
   - **可读性强**：代码逻辑清晰，适合快速实现。
3. **Tiphereth_A（★★★☆☆）**  
   - **数学归纳严谨**：但未提供代码实现。

---

### **最优思路与技巧**
- **斐波那契构造法**：利用斐波那契数的相邻项确保递归次数最大化。
- **反向递推法**：逐步构造满足条件的 `(A, B)`，每次操作仅需 `O(K)` 时间。

---

### **类似题目与算法套路**
- **类似题**：  
  - **洛谷 P2158 [SDOI2008] 仪仗队**（数学构造）
  - **洛谷 P1306 斐波那契公约数**（斐波那契与 GCD 结合）
  - **Codeforces 232A Cycles**（数学构造与递推）

---

### **个人心得摘录**
- **Aw顿顿**：“斐波那契数列的余数性质是核心，需结合欧几里得算法的最坏情况分析。”
- **xgwpp6710**：“反向递推时需注意初始条件，确保每个 `K` 的构造唯一。”

---

### **可视化与算法演示**
#### **核心逻辑动画设计**
1. **动画方案**：  
   - **步骤分解**：展示斐波那契数的生成过程，并通过颜色标记当前递归调用的两个数。
   - **余数变化**：高亮每一步的余数，强调其与前两项的关系。
2. **交互设计**：  
   - **像素风格**：使用 8-bit 风格显示斐波那契数和递归计数器。
   - **音效提示**：每次递归调用时播放音效，结束时播放成功音效。
3. **自动演示**：  
   - **参数调节**：允许输入 `K`，自动生成对应的 `(A, B)` 并演示递归流程。

#### **代码片段（斐波那契构造）**
```cpp
long long fib[42] = {0, 1, 1};
for (int i = 3; i <= 41; i++) 
    fib[i] = fib[i-1] + fib[i-2];
cout << fib[k] << " " << fib[k+1];
```

---

### **结论**
- **最优解**：使用斐波那契数列的相邻项构造输入，时间复杂度 `O(K)`。
- **扩展性**：该构造方法适用于所有 `K ≤ 40`，生成的数严格小于 `1e9`。

---
处理用时：387.45秒
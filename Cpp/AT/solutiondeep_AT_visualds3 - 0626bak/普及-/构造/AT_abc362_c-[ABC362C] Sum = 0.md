# 题目信息

# [ABC362C] Sum = 0

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc362/tasks/abc362_c

$ N $ 個の整数の組 $ (L_1,R_1),(L_2,R_2),\ldots,(L_N,R_N) $ が与えられます。

以下の条件を満たす長さ $ N $ の整数列 $ X=(X_1,X_2,\ldots,X_N) $ が存在するか判定し、存在するならば一つ出力してください。

- 各 $ i=1,2,\ldots,N $ に対して $ L_i\leq\ X_i\leq\ R_i $
- $ \displaystyle\ \sum_{i=1}^N\ X_i=0 $

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ -10^9\leq\ L_i\leq\ R_i\leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

数列 $ X=(4,-3,-1) $ は問題の条件をすべて満たします。ほかにも $ (3,-3,0) $ や $ (5,-4,-1) $ などが条件を満たします。

### Sample Explanation 2

条件を満たす整数列 $ X $ は存在しません。

## 样例 #1

### 输入

```
3

3 5

-4 1

-2 3```

### 输出

```
Yes

4 -3 -1```

## 样例 #2

### 输入

```
3

1 2

1 2

1 2```

### 输出

```
No```

## 样例 #3

### 输入

```
6

-87 12

-60 -54

2 38

-76 6

87 96

-17 38```

### 输出

```
Yes

-66 -57 31 -6 89 9```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路、算法要点与解决难点**

1. **存在性判断**  
   计算所有区间下限之和 `sumL` 和上限之和 `sumR`。若 `sumL > 0` 或 `sumR < 0`，则无法构造解，直接输出 `No`；否则存在解。

2. **贪心构造**  
   - **初始方向选择**：  
     - **从最大值开始减**：将每个元素初始化为区间上限 `R_i`，总和为 `sumR`，然后逐步减少每个元素的值（但不低于 `L_i`），直到总和减至 `0`。  
     - **从最小值开始加**：将每个元素初始化为区间下限 `L_i`，总和为 `sumL`，然后逐步增加每个元素的值（但不超过 `R_i`），直到总和增至 `0`。  
   - **调整策略**：  
     遍历每个元素，计算当前元素能调整的最大幅度（即 `R_i - L_i`），并尽可能多地调整该元素的值，使得总和尽快趋近 `0`。若调整当前元素后总和刚好为 `0`，则直接输出结果；否则继续调整后续元素。

3. **核心难点**  
   - **正确计算调整量**：确保每次调整的幅度不超过区间允许的范围，且总和精确减至 `0`。  
   - **时间复杂度优化**：由于元素数为 `2e5`，必须保证算法为 `O(n)` 复杂度，避免嵌套循环或复杂操作。

---

### **题解评分（≥4星）**

1. **_wsq_（5星）**  
   - **亮点**：代码简洁，直接初始化为最大值后贪心调整，通过 `min(r[i]-l[i], sumr)` 精准控制调整量。  
   - **关键实现**：  
     ```cpp
     for (i=1; i<=n; i++) {
         cout << r[i] - min(r[i]-l[i], sumr) << ' ';
         sumr -= min(r[i]-l[i], sumr);
     }
     ```

2. **xuduang（4星）**  
   - **亮点**：从最小值开始调整，动态判断是否需要完全取最大值或部分调整。  
   - **关键实现**：  
     ```cpp
     if (r[i] - l[i] >= ned) {
         c[i] = l[i] + ned;  // 部分调整即可达目标
         output();
     }
     ```

3. **Lame_Joke（4星）**  
   - **亮点**：通过维护剩余需调整量 `sm`，逐元素减少总和，代码逻辑清晰。  
   - **关键实现**：  
     ```cpp
     if (sm - x < 0) {
         r1[i] -= sm;  // 最后一次调整
         sm = 0;
         break;
     }
     ```

---

### **最优思路与技巧提炼**

1. **贪心方向选择**  
   - 若初始总和 `sumR >= 0`，从最大值开始减；若 `sumL <= 0`，从最小值开始加。两种策略均能保证调整量足够。

2. **调整量计算**  
   - 每次调整的幅度为 `min(允许的最大调整量, 剩余需调整量)`，确保不越界且总和精确到 `0`。

3. **代码优化**  
   - 使用 `long long` 避免溢出，维护动态剩余需调整量（如 `sumr` 或 `cur`）直接减少计算次数。

---

### **同类型题与算法套路**

- **类似问题**：区间选择问题（如 [CF1526C2](https://codeforces.com/problemset/problem/1526/C2) 中选数使和非负）。  
- **通用解法**：贪心调整总和，优先处理对总和贡献最大的元素（如最大/最小值）。

---

### **推荐题目**

1. **P1106 删数问题**（贪心选择最优删数策略）  
2. **P1090 合并果子**（贪心选择最小合并代价）  
3. **CF1526C2 Potions**（贪心维护非负和）

---

### **可视化与算法演示**

1. **动画设计**  
   - **初始状态**：显示所有元素为 `R_i`（红色方块），总和为 `sumR`（显示在顶部）。  
   - **调整步骤**：遍历元素时，高亮当前方块，显示可调整范围 `[L_i, R_i]`，动态绘制调整后的值（绿色箭头表示减少量）。  
   - **音效触发**：每次调整播放短音效，成功时播放胜利音效。

2. **复古像素风格**  
   - **颜色方案**：使用 8 位色调（红、绿、蓝）表示不同状态。  
   - **Canvas 绘制**：每个元素为 32x32 像素块，总和变化通过数字滚动显示。  
   - **AI 自动演示**：按固定速度遍历元素，自动计算调整量并播放音效。

---

### **代码片段（关键逻辑）**

以 _wsq_ 的代码为例：

```cpp
#include <iostream>
using namespace std;
#define maxn 200005
typedef long long ll;

int main() {
    ll n, l[maxn], r[maxn], suml = 0, sumr = 0;
    cin >> n;
    for (ll i = 1; i <= n; i++) {
        cin >> l[i] >> r[i];
        suml += l[i];
        sumr += r[i];
    }
    if (suml > 0 || sumr < 0) {
        cout << "No";
        return 0;
    }
    cout << "Yes" << endl;
    for (ll i = 1; i <= n; i++) {
        ll adjust = min(r[i] - l[i], sumr);
        cout << r[i] - adjust << ' ';
        sumr -= adjust;
    }
    return 0;
}
```

---

### **个人心得摘录**

- **数据范围**：`N` 最大为 `2e5`，必须确保 `O(n)` 复杂度，避免递归或嵌套循环。  
- **边界条件**：当 `sumL = 0` 或 `sumR = 0` 时直接输出初始值，无需调整。  
- **调试技巧**：通过打印中间变量（如 `sumr`）验证贪心过程是否正确递减。

---
处理用时：197.49秒
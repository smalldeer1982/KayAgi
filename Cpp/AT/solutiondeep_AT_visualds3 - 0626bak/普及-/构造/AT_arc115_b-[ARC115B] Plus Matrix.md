# 题目信息

# [ARC115B] Plus Matrix

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc115/tasks/arc115_b

$ N $ 行 $ N $ 列の非負整数を成分とする行列 $ C $ が与えられます。すべての $ (i,j) $ について $ C_{i,j}=A_i+B_j $ を満たすような非負整数列 $ A_1,A_2,\ldots,A_N $ と $ B_1,B_2,\ldots,B_N $ の組が存在するか判定し、存在するなら一つ出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 500 $
- $ 0\ \leq\ C_{i,j}\ \leq\ 10^9 $

### Sample Explanation 1

$ A,B $ は非負整数列であることに注意してください。

## 样例 #1

### 输入

```
3

4 3 5

2 1 3

3 2 4```

### 输出

```
Yes

2 0 1

2 1 3```

## 样例 #2

### 输入

```
3

4 3 5

2 2 3

3 2 4```

### 输出

```
No```

# AI分析结果



**算法分类**  
构造/数学分析

---

### **题解思路与难点分析**

#### **核心思路**  
题目要求构造两个非负数组 $A$ 和 $B$，使得 $C_{i,j}=A_i+B_j$。关键观察如下：  
1. **差分一致性**：同一行的相邻元素差必须等于同一行其他行的相邻差（对应 $B$ 的差分一致），同一列的相邻差同理（对应 $A$ 的差分一致）。  
2. **贪心构造**：通过将每列减去该列最小值得到 $B$ 的非负数组，剩余部分检查每行是否一致作为 $A$ 的值。  

#### **解决难点**  
- **非负性保证**：通过减去每列的最小值确保 $B$ 非负，同时验证剩余行元素是否一致且非负。  
- **差分一致性验证**：检查所有行和列的差分是否相同，确保构造的合法性。

---

### **题解评分（≥4星）**

1. **KυρωVixen（5星）**  
   - **亮点**：贪心思路清晰，代码简洁高效。通过逐列处理最小值，直接构造 $B$，剩余部分验证行一致性。  
   - **代码片段**：  
     ```cpp  
     rep(j,1,n) {
         b[j] = INF;
         rep(i,1,n) b[j] = min(b[j], c[i][j]);
         rep(i,1,n) c[i][j] -= b[j];
     } 
     rep(i,1,n) if (chk(i) == -1) { ... }  
     ```

2. **forever_nope（4星）**  
   - **亮点**：直接处理每列最小值，验证每行剩余元素是否相同，逻辑直观。  
   - **代码片段**：  
     ```cpp  
     rep(j,1,n) {  
         int mn = *min_element(c_col_j);  
         B[j] = mn;  
         subtract mn from column j;  
     }  
     ```

3. **封禁用户（4星）**  
   - **亮点**：通过交换最小行简化构造，差分检查全面。  
   - **代码片段**：  
     ```cpp  
     rep(j,1,n) swap(c[min_row][j], c[1][j]);  
     rep(i,1,n) a[i] = c[i][1] - c[1][1];  
     ```

---

### **最优思路与技巧**  
**关键技巧**：  
- **列最小值构造**：取每列的最小值作为 $B_j$，确保非负性。  
- **行一致性验证**：剩余矩阵每行必须完全相同，否则无解。  
- **偏移调整**：若 $A$ 或 $B$ 存在负数，通过整体偏移调整。

---

### **类似题目推荐**  
1. **洛谷 P2894 [USACO08FEB]Hotel G**（差分数组应用）  
2. **洛谷 P2962 [USACO09NOV]Lights G**（构造非负解）  
3. **CodeForces 1180B Divisors**（矩阵构造与贪心）

---

### **可视化与算法演示**

#### **动画设计**  
1. **像素风格界面**：  
   - 使用 8-bit 网格展示矩阵，每格显示 $C_{i,j}$。  
   - 当前处理列标红，最小值高亮为绿色。  
2. **核心流程**：  
   - **Step 1**：逐列处理，标红当前列，找到最小值（绿色），其余元素减去该值。  
   - **Step 2**：检查每行是否全同，不一致的行闪烁红色，触发失败音效。  
3. **音效与交互**：  
   - 成功时播放 8-bit 胜利音效，失败时短促“哔”声。  
   - 支持步进控制，按空格暂停/继续，方向键调整速度。

#### **代码片段（伪代码）**  
```javascript  
// 伪代码：Canvas绘制矩阵  
function drawMatrix(ctx, matrix, highlightCol) {  
    for (let i = 0; i < n; i++) {  
        for (let j = 0; j < n; j++) {  
            if (j === highlightCol) ctx.fillStyle = "#FF0000";  
            else ctx.fillStyle = "#FFFFFF";  
            ctx.fillRect(j*50, i*50, 48, 48);  
            ctx.fillText(matrix[i][j], j*50 + 10, i*50 + 25);  
        }  
    }  
}  
```

---

### **总结**  
本题核心在于通过差分一致性验证和贪心构造，确保非负解的存在性。最优解法以 $O(N^2)$ 的时间复杂度高效处理，适用于大范围数据。可视化设计通过复古像素风格和交互式步进，直观展示算法流程。

---
处理用时：86.33秒
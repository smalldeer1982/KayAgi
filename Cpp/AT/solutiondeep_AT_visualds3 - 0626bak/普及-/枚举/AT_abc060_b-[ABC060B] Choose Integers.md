# 题目信息

# [ABC060B] Choose Integers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc060/tasks/abc060_b

あなたは、正の整数をいくつか選び、それらの総和を求めます。

選ぶ数の上限や、選ぶ整数の個数に制限はありません。 どんなに大きな整数を選んでもよいですし、整数を $ 5000 $ 兆個選んでもよいです。 ただし、選ぶ数はすべて $ A $ の倍数でなくてはいけません。 また、少なくとも $ 1 $ つは整数を選ばなくてはいけません。

そして総和を $ B $ で割ったあまりが $ C $ となるようにしたいです。 こうなるように整数を選ぶことが出来るか判定してください。

出来るならば `YES`、そうでないならば `NO` を出力してください。

## 说明/提示

### 制約

- $ 1\ ≦\ A\ ≦\ 100 $
- $ 1\ ≦\ B\ ≦\ 100 $
- $ 0\ ≦\ C $

### Sample Explanation 1

たとえば $ 7,\ 14 $ を選ぶと総和は $ 21 $ となり、これを $ 5 $ で割ったあまりは $ 1 $ となります。

### Sample Explanation 2

偶数をいくつ足したとしても、けっして奇数になることはありません。

### Sample Explanation 3

$ 1 $ の倍数、つまりすべての整数が選べるので、$ 97 $ を選べば良いです。

## 样例 #1

### 输入

```
7 5 1```

### 输出

```
YES```

## 样例 #2

### 输入

```
2 2 1```

### 输出

```
NO```

## 样例 #3

### 输入

```
1 100 97```

### 输出

```
YES```

## 样例 #4

### 输入

```
40 98 58```

### 输出

```
YES```

## 样例 #5

### 输入

```
77 42 36```

### 输出

```
NO```

# AI分析结果



---

**唯一算法分类**：数论（贝祖定理应用）

---

### 题解思路与算法要点

#### 核心问题
判断是否存在整数集合，使其总和（全为A的倍数）模B等于C。等价于判断线性同余方程 `A*k ≡ C (mod B)` 是否有解。

#### 关键算法对比
| 方法类型       | 核心思路                                                                 | 时间复杂度   | 适用数据范围          |
|----------------|--------------------------------------------------------------------------|--------------|-----------------------|
| 暴力枚举法     | 枚举A的1~B倍，检查是否存在余数等于C                                      | O(B)         | B ≤ 1e4（可行）       |
| 数论解法       | 根据贝祖定理，当且仅当gcd(A,B)整除C时方程有解                           | O(log A)     | A,B ≤ 1e18（更优）    |
| 错误优化       | 错误缩小枚举范围（如只循环100次）                                       | O(1)         | 可能漏解，不推荐      |

#### 解决难点
1. **余数循环周期**：暴力法需证明余数在B次内必然重复（鸽巢原理）。
2. **数论转换**：将问题转换为判断线性同余方程解的存在性，依赖贝祖定理。

---

### 题解评分（≥4星）

1. **詹詹tv__詹詹（5星）**  
   - **亮点**：数论解法直击本质，数学证明清晰，代码高效（O(log A)）。  
   - **代码片段**：
     ```cpp
     if(c % gcd(a, b) == 0) cout << "YES";
     ```
   
2. **MZY666（4星）**  
   - **亮点**：暴力枚举范围正确（B次），代码简洁易懂，附带数学证明。  
   - **代码片段**：
     ```cpp
     for(int i=1; i<=b; i++) if((a*i)%b == c) return YES;
     ```

3. **Juvenile（4星）**  
   - **亮点**：数论解法实现精简，但位运算交换变量影响可读性。  
   - **代码片段**：
     ```cpp
     while(b^=a^=b^=a%=b); // 计算gcd的位运算技巧
     ```

---

### 最优思路与技巧
1. **贝祖定理应用**：问题等价于 `gcd(A,B) | C`，无需枚举直接判断。
2. **余数周期性**：暴力解法只需枚举B次，利用模运算周期性避免无限循环。

---

### 同类题型与算法套路
- **同余方程**：如[P1082 同余方程](https://www.luogu.com.cn/problem/P1082)（扩展欧几里得算法）。
- **青蛙约会问题**：[P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)（线性同余方程）。

---

### 推荐练习题
1. **AT1219 歴史の研究**（哈希与模运算）
2. **P3951 小凯的疑惑**（贝祖定理应用）
3. **P2421 荒岛野人**（同余方程组）

---

### 个人心得摘录
- **詹詹tv__詹詹**：  
  *"多好的一道最大公约数的题啊！！！"* —— 强调数论思维在简化问题中的重要性。
  
- **MZY666**：  
  *"前文有解释循环到B的原因"* —— 详细推导暴力法的正确性，适合教学。

---

### 可视化与算法演示设计
#### 核心动画方案
- **像素风格余数追踪**：  
  1. 用8-bit网格展示A的倍数（如7, 14, 21...），每次计算余数。  
  2. 高亮当前余数，若匹配C则播放成功音效（↑音调）。  
  3. 右侧面板实时显示gcd计算过程（动态更新a,b值）。

#### 交互功能
- **速度控制**：滑块调节枚举步频（1x~10x）。  
- **模式切换**：暴力枚举 vs 数论解法对比演示。  
- **音效反馈**：失败时播放8-bit“错误”音效，成功时播放NES风格胜利音乐。

#### 复古元素
- **颜色方案**：16色FC调色板，余数用不同颜色方块表示。  
- **自动演示**：AI模拟暴力法枚举过程，每步0.5秒延迟。

---

### 核心代码片段
**数论解法（Python）**：
```python
import math
a, b, c = map(int, input().split())
g = math.gcd(a, b)
print("YES" if c % g == 0 else "NO")
```

**暴力法可视化（JS伪代码）**：
```javascript
function visualize() {
  let i = 1;
  const interval = setInterval(() => {
    const remainder = (A * i) % B;
    highlightGrid(i); // 高亮当前倍数
    if (remainder === C) {
      playSuccessSound();
      clearInterval(interval);
    } else if (i > B) {
      playFailSound();
      clearInterval(interval);
    }
    i++;
  }, 500);
}
```

---

**总结**：本题可通过暴力枚举或数论解法高效解决，数论方法在普适性和效率上更优。可视化设计可结合复古元素增强学习趣味性。

---
处理用时：106.31秒
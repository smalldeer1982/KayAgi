# 题目信息

# [ABC323C] World Tour Finals

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_c

$ N $ 人のプレイヤーが参加するプログラミングコンテスト World Tour Finals が行われており、競技時間の半分が過ぎました。 このコンテストでは $ M $ 問の問題が出題されており、問題 $ i $ の点数 $ A_i $ は $ 500 $ 以上 $ 2500 $ 以下の $ 100 $ の倍数です。

各 $ i\ =\ 1,\ \ldots,\ N $ について、プレイヤー $ i $ がどの問題を既に解いたかを表す文字列 $ S_i $ が与えられます。 $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列で、$ S_i $ の $ j $ 文字目が `o` のときプレイヤー $ i $ は問題 $ j $ を既に解いており、`x` のときまだ解いていません。 ただし、どのプレイヤーもまだ全ての問題を解いてはいません。

プレイヤー $ i $ の総合得点は、解いた問題の点数の合計に、**ボーナス点** $ i $ 点を加えた点数として計算されます。  
さて、各 $ i\ =\ 1,\ \ldots,\ N $ について以下の質問に答えてください。

- プレイヤー $ i $ がまだ解いていない問題を少なくとも何問解くことで、プレイヤー $ i $ の総合得点が他のプレイヤー全員の現在の総合得点を上回ることができますか？

なお、問題文中の条件と制約から、プレイヤー $ i $ が全ての問題を解くことで、他のプレイヤー全員の現在の総合得点を上回ることができることが証明できます。 このことから、答えは常に定義されることに注意してください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 100 $
- $ 1\leq\ M\leq\ 100 $
- $ 500\leq\ A_i\leq\ 2500 $
- $ A_i $ は $ 100 $ の倍数
- $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列
- $ S_i $ には `x` が一個以上含まれる
- 入力される数値は全て整数

### Sample Explanation 1

競技時間の半分の経過時の各プレイヤーの総合得点は、プレイヤー $ 1 $ が $ 2001 $ 点、プレイヤー $ 2 $ が $ 1502 $ 点、プレイヤー $ 3 $ が $ 1703 $ 点です。 プレイヤー $ 1 $ は $ 1 $ 問も解かずとも、他のプレイヤー全員の総合得点を上回っています。 プレイヤー $ 2 $ は、例えば問題 $ 4 $ を解けば総合得点が $ 3502 $ 点となり、他のプレイヤー全員の総合得点を上回ります。 プレイヤー $ 3 $ も、例えば問題 $ 4 $ を解けば総合得点が $ 3703 $ 点となり、他のプレイヤー全員の総合得点を上回ります。

## 样例 #1

### 输入

```
3 4
1000 500 700 2000
xxxo
ooxx
oxox```

### 输出

```
0
1
1```

## 样例 #2

### 输入

```
5 5
1000 1500 2000 2000 2500
xxxxx
oxxxx
xxxxx
oxxxx
oxxxx```

### 输出

```
1
1
1
1
0```

## 样例 #3

### 输入

```
7 8
500 500 500 500 500 500 500 500
xxxxxxxx
oxxxxxxx
ooxxxxxx
oooxxxxx
ooooxxxx
oooooxxx
ooooooxx```

### 输出

```
7
6
5
4
3
2
0```

# AI分析结果



---

## 唯一算法分类
**贪心算法**

---

## 综合分析与结论

### 核心思路
所有选手的解题策略均基于贪心思想：优先选择分值最高的未解题目。其核心逻辑为：
1. 计算每个选手当前总得分（含基础分）
2. 确定其他选手的最高当前得分
3. 按分值降序遍历所有题目，累加未解题目分数直至超过最高分

### 解决难点
1. **高效获取未解题目**：通过预排序题目数组（O(m log m)），避免每次遍历时重复排序
2. **状态标记优化**：使用 map 或数组标记已解题目（O(1) 查询）
3. **时间复杂度控制**：通过预排序将单选手处理复杂度降至 O(m)

### 可视化设计思路
1. **像素风格界面**：用不同颜色方块表示题目分值（红色→高，蓝色→低）
2. **动态累加演示**：选手头像旁实时显示分数增长过程，选中题目时播放“拾取音效”
3. **胜负判定动画**：当分数超过最高分时，触发闪光特效和胜利音效
4. **自动演示模式**：AI 自动执行贪心策略，可调节执行速度观察决策过程

---

## 题解清单（≥4星）

### [A_R_O_N_A] ⭐⭐⭐⭐
**亮点**：预排序优化 + 在线求最大值  
**关键代码**：
```cpp
sort(pro+1,pro+1+m,cmp2); // 题目预排序
for(int j=1;j<=m;j++){ // 按分值降序遍历
    if(a[i].sum>maxx) break;
    if(!pro[j].mp[a[i].num]){ // 未解题直接累加
        a[i].sum += pro[j].point;
        anss++;
    }
}
```

### [hellolin] ⭐⭐⭐⭐
**亮点**：代码简洁 + 独立生成未解题列表  
**关键思路**：
```cpp
vec<int> wt; // 独立存储未解题分值
rep(j,m) if(s[i][j]=='x') wt.pb(a[j]); 
sort(wt.begin(), wt.end(), greater<int>()); // 局部排序
```

---

## 核心代码实现

### 贪心算法核心片段
```cpp
// 预处理：题目按分值降序排列
sort(pro.begin(), pro.end(), [](auto &a, auto &b){
    return a.point > b.point;
});

// 对每个选手计算最小解题数
for(int i=0; i<n; i++){
    int current = score[i];
    if(current >= max_score){
        cout << 0 << endl;
        continue;
    }
    
    int cnt = 0;
    for(auto &p : pro){ // 遍历预排序题目
        if(solved[i][p.id]) continue;
        current += p.point;
        cnt++;
        if(current > max_score) break;
    }
    cout << cnt << endl;
}
```

---

## 相似题目推荐
1. **P1090 合并果子** - 贪心选择最小堆
2. **P1223 排队接水** - 贪心安排最优顺序
3. **P1803 凌乱的yyy / 线段覆盖** - 贪心选择结束时间最早

---

## 可视化关键要素
1. **Canvas 布局**：
   - 顶部显示选手头像与当前分数
   - 中间网格展示题目方块（颜色深浅表示分值）
   - 右侧控制面板（暂停/速度调节）

2. **动画流程**：
   - 初始状态：所有题目显示为灰色（已解）或原色（未解）
   - 贪心选择时：选中方块高亮黄色，播放 "blip.wav"
   - 分数更新：选手头像上方弹出绿色 "+X" 动画
   - 达成条件：选手头像闪现金色边框，播放 "victory.wav"

3. **音效设计**：
   - `pick.mp3`（8-bit 短音效）- 每次选择题目
   - `success.mp3`（上扬音阶） - 超过最高分
   - `bgm.mp3`（循环芯片音乐） - 可选背景音乐

---

通过将贪心策略可视化，学习者可直观理解"为何选择高分题目最优"，而复古像素风格与游戏化交互则大幅提升学习趣味性。

---
处理用时：74.76秒
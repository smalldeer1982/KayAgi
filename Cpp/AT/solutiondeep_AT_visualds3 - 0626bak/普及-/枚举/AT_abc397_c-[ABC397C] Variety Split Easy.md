# 题目信息

# [ABC397C] Variety Split Easy

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc397/tasks/abc397_c

> 本题是 F 题的简易版本。

给定一个长度为 $N$ 的整数列 $A=(A_1, A_2, \ldots, A_N)$。

当在 $A$ 的某一位置将其分割为 $2$ 个非空的连续子序列时，求这两个子序列中不同整数的种类数之和的最大可能值。

更严格地说，对于满足 $1 \leq i \leq N-1$ 的整数 $i$，分别计算子序列 $(A_1, A_2, \ldots, A_i)$ 和 $(A_{i+1}, A_{i+2}, \ldots, A_N)$ 中不同整数的种类数之和，并求这些和的最大值。

## 说明/提示

### 约束条件

- $2 \leq N \leq 3 \times 10^5$
- $1 \leq A_i \leq N$ ($1 \leq i \leq N$)
- 输入均为整数

### 样例解释 1

- 当 $i=1$ 时，子序列 $(3)$ 和 $(1,4,1,5)$ 各自包含的整数种类数分别为 $1$ 和 $3$，和为 $4$。
- 当 $i=2$ 时，子序列 $(3,1)$ 和 $(4,1,5)$ 各自包含的整数种类数分别为 $2$ 和 $3$，和为 $5$。
- 当 $i=3$ 时，子序列 $(3,1,4)$ 和 $(1,5)$ 各自包含的整数种类数分别为 $3$ 和 $2$，和为 $5$。
- 当 $i=4$ 时，子序列 $(3,1,4,1)$ 和 $(5)$ 各自包含的整数种类数分别为 $3$ 和 $1$，和为 $4$。

因此，当 $i=2$ 或 $i=3$ 时，取到最大值 $5$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
3 1 4 1 5```

### 输出

```
5```

## 样例 #2

### 输入

```
10
2 5 6 5 2 1 7 9 7 2```

### 输出

```
8```

# AI分析结果



## 算法分类
滑动窗口/动态维护计数

---

## 题解思路与解决难点
### 核心思路
维护两个计数器数组，分别记录分割点左右两侧的元素出现次数。初始时右侧包含所有元素，左侧为空。逐个将元素从右侧移动到左侧，动态更新两侧的不同元素数量，并在每次移动后计算总和，更新最大值。

### 算法要点
1. **初始化右侧计数器**：统计所有元素的出现次数及初始不同元素数量。
2. **逐个移动分割点**：将当前元素从右侧移除（计数器减一，若归零则不同元素数减一），并加入左侧（计数器加一，若首次出现则不同元素数加一）。
3. **实时更新最大值**：每次移动后计算左右两侧不同元素数之和，记录最大值。

### 解决难点
- **线性时间复杂度**：通过动态维护计数器，避免重复遍历数组。
- **空间优化**：仅需两个数组记录元素出现次数，无需存储前缀/后缀数组。

---

## 题解评分（≥4星）
1. **da_ke（5星）**  
   - 代码简洁，动态维护计数器，空间优化到位。
   - 关键逻辑清晰：用`cnt1`和`cnt2`分别统计左右两侧元素出现次数，`ans1`和`ans2`统计不同元素数量。

2. **CSP_SAKME（5星）**  
   - 预处理与动态更新结合，逻辑直观。
   - 使用数组直接操作，避免哈希表开销。

3. **KobeBeanBryantCox（4星）**  
   - 使用`set`维护不同元素，思路明确。
   - 时间复杂度稍高（O(N log N)），但代码易理解。

---

## 最优思路提炼
**动态维护计数器法**  
- **初始化**：右侧统计所有元素的出现次数及不同元素总数。
- **滑动分割点**：每次移动一个元素到左侧，更新左右计数器：
  ```cpp
  cnt2[A[i]]--;
  if (cnt2[A[i]] == 0) ans2--;  // 右侧不再有此元素
  cnt1[A[i]]++;
  if (cnt1[A[i]] == 1) ans1++;  // 左侧新增此元素
  maxn = max(maxn, ans1 + ans2); // 更新最大值
  ```
- **时间复杂度**：O(N)，空间复杂度：O(N)。

---

## 类似题目
1. **P1091 合唱队形**：前后缀动态维护元素极值。
2. **P1972 HH的项链**：区间不同元素统计。
3. **CF1000E We Need More Bosses**：前后缀预处理路径属性。

---

## 可视化设计
### 复古像素风格动画
- **像素方块**：用不同颜色方块表示元素值，左右分区显示。
- **动态移动**：分割点移动时，元素从右侧移到左侧，伴随音效。
- **计数显示**：实时显示左右两侧不同元素数量及总和。
- **音效设计**：
  - **移动元素**：短促“滴”声。
  - **更新最大值**：上扬音效。
  - **背景音乐**：8-bit循环旋律。

### 控制面板
- **步进/自动**：切换单步调试或自动播放。
- **速度调节**：滑动条控制动画速度。
- **数据高亮**：当前操作元素高亮闪烁。

---

## 核心代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<int> A(N + 1);
    vector<int> cnt1(N + 2, 0), cnt2(N + 2, 0);
    int ans1 = 0, ans2 = 0, max_total = 0;

    for (int i = 1; i <= N; ++i) {
        cin >> A[i];
        cnt2[A[i]]++;
        if (cnt2[A[i]] == 1) ans2++; // 初始化右侧不同元素数
    }

    for (int i = 1; i < N; ++i) {
        cnt2[A[i]]--;
        if (cnt2[A[i]] == 0) ans2--; // 右侧减少元素
        cnt1[A[i]]++;
        if (cnt1[A[i]] == 1) ans1++; // 左侧新增元素
        max_total = max(max_total, ans1 + ans2);
    }

    cout << max_total << endl;
    return 0;
}
```

---

## 个人心得
- **计数器更新顺序**：先更新右侧再左侧，避免同一元素在左右侧状态冲突。
- **边界处理**：分割点不能为最后一个元素，循环条件需严格限制为`i < N`。

---
处理用时：117.51秒
# 题目信息

# [ABC404D] Goin&#39; to the Zoo

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc404/tasks/abc404_d

AtCoder 国には動物園が $ N $ 園あり、$ 1 $ から $ N $ の番号がついています。動物園 $ i $ の入園料は $ C_i $ 円です。

鈴木さんは $ M $ 種類の動物、動物 $ 1,\ldots,M $ が好きです。  
動物 $ i $ は $ K_i $ 園の動物園 $ A_{i,1},\dots,\ A_{i,K_i} $ で見ることができます。

$ M $ 種類の動物全てを $ 2 $ 度以上ずつ見るために必要な入園料の合計の最小値を求めてください。  
なお、同じ動物園を複数回訪れた場合、その動物園の動物は訪れた回数だけ見たとみなします。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 10 $
- $ 1\leq\ M\ \leq\ 100 $
- $ 0\leq\ C_i\ \leq\ 10^9 $
- $ 1\leq\ K_i\ \leq\ N $
- $ 1\ \leq\ A_{i,j}\ \leq\ N $
- $ j\ \neq\ j'\ \Longrightarrow\ A_{i,j}\neq\ A_{i,j'} $
- 入力は全て整数

### Sample Explanation 1

以下のようにすることで、$ 1800 $ 円で動物 $ 1,2,3 $ を $ 2 $ 度以上ずつ見ることができます。 - 動物園 $ 3 $ に行く。入園料 $ 700 $ 円を払い、動物 $ 1,3 $ を見る。 - 動物園 $ 3 $ に行く。入園料 $ 700 $ 円を払い、動物 $ 1,3 $ を見る。 - 動物園 $ 4 $ に行く。入園料 $ 200 $ 円を払い、動物 $ 1,2 $ を見る。 - 動物園 $ 4 $ に行く。入園料 $ 200 $ 円を払い、動物 $ 1,2 $ を見る。

### Sample Explanation 2

動物園 $ 7 $ に $ 2 $ 度行くことで、合計 $ 2000 $ 円で動物 $ 1,2,3,4,5,6 $ を $ 2 $ 度ずつ見ることができます。

## 样例 #1

### 输入

```
4 3
1000 300 700 200
3 1 3 4
3 1 2 4
2 1 3```

### 输出

```
1800```

## 样例 #2

### 输入

```
7 6
500 500 500 500 500 500 1000
3 1 2 7
3 2 3 7
3 3 4 7
3 4 5 7
3 5 6 7
3 6 1 7```

### 输出

```
2000```

# AI分析结果



### 唯一算法分类
**暴力枚举（DFS+剪枝）**

---

### 题解思路、算法要点与解决难点
**核心思路**：  
每个动物园的访问次数只能是 0、1、2 次（访问更多次无意义）。通过 DFS 枚举所有可能的访问次数组合，计算总费用并检查是否满足条件，使用剪枝优化避免无效搜索。

**算法要点**：  
1. **预处理数据结构**：将每个动物园中存在的动物存储为列表，便于后续快速计算动物总观看次数。
2. **DFS 枚举**：递归遍历每个动物园，尝试 0/1/2 次访问，累计总费用。
3. **剪枝优化**：若当前累计费用已超过已找到的最小费用，提前终止该分支的搜索。
4. **条件检查**：在枚举结束后，统计每个动物的总观看次数，若均 ≥2 则更新答案。

**解决难点**：  
- 如何高效判断每个动物是否满足条件？  
  预处理每个动物园包含的动物，每次访问时直接累加相关动物的观看次数。  
- 如何处理指数级枚举？  
  利用 N=10 的限制，3^10 的枚举量可接受；剪枝进一步减少实际搜索空间。

---

### 题解评分（≥4星）
1. **Little_x_starTYJ（4.5星）**  
   - 思路清晰，代码结构简洁，包含剪枝优化。  
   - 使用全局变量 `cnt` 跟踪动物观看次数，DFS 参数传递当前费用。  
   - 缺点：全局变量可能增加维护难度。

2. **Double_Light（4星）**  
   - 明确预处理动物园与动物的映射关系，代码可读性较好。  
   - 未显式剪枝，但 `ans=min(ans,cost)` 隐式剪枝。  
   - 缺点：回溯逻辑稍显冗余。

3. **wwwidk1234（4星）**  
   - 使用 `vector` 存储动物园中的动物，便于快速遍历。  
   - 显式剪枝（`if(val>ans) return`），代码结构清晰。  
   - 缺点：动物次数统计逻辑与 DFS 耦合。

---

### 最优思路或技巧提炼
1. **动物园次数限制**：每个动物园最多访问 2 次（访问更多次不会增加动物观看次数的下限）。
2. **预处理映射关系**：将动物与所在动物园的映射预先存储，避免重复计算。
3. **剪枝优化**：在 DFS 过程中，若当前费用已超过已知最优解，立即终止搜索。
4. **回溯法设计**：通过递归实现状态的回溯，避免手动管理复杂状态。

---

### 同类型题或类似算法套路
- **暴力枚举+剪枝**：适用于数据范围小（如 N≤15）的最优化问题。
- **状态压缩**：若 N 稍大但可表示为二进制状态（如 N≤20），可用状压 DP。

---

### 推荐题目
1. **P1706 全排列问题**：暴力枚举所有排列。
2. **P2392 kkksc03考前临时抱佛脚**：DFS 剪枝优化。
3. **P1120 小木棍**：经典剪枝搜索问题。

---

### 个人心得摘录
- **预处理的重要性**：将输入数据转换为方便后续操作的结构（如动物园到动物的映射）可大幅简化代码。  
- **剪枝的威力**：即使简单的最优性剪枝（`if(tem >= ans) continue`）也能显著减少搜索时间。

---

### 可视化与算法演示
**核心算法过程动画设计**：  
1. **颜色标记**：  
   - 当前处理的动物园高亮为黄色。  
   - 已访问的动物园根据次数（0/1/2）显示灰/蓝/绿色。  
   - 不满足条件的动物标红，满足的标绿。  

2. **操作流程**：  
   - **Step 1**：选择第一个动物园，尝试 0 次访问（费用不变）。  
   - **Step 2**：递归进入下一动物园，重复选择 0/1/2 次。  
   - **Step 3**：到达叶子节点时，显示所有动物的观看次数，若满足条件则更新答案。  

3. **交互设计**：  
   - **速度调节**：滑动条控制 DFS 递归速度。  
   - **单步执行**：手动点击进入下一步。  
   - **剪枝提示**：当触发剪枝时，显示红色闪烁并提示“Pruned!”。  

**复古游戏化效果**：  
- **8 位像素风格**：动物园用不同颜色的方块表示，费用显示为像素数字。  
- **音效**：  
  - 选择次数时播放“哔”声。  
  - 找到更优解时播放“胜利”音效。  
  - 剪枝时播放“失败”音效。  
- **自动演示模式**：AI 自动选择分支，优先探索费用较低的路径。

---

### 关键代码片段
**DFS 核心逻辑（wwwidk1234 题解）**：
```cpp
void dfs(int dep,ll val) {
    if(val>ans) return ; // 剪枝
    if(dep>n) {
        if(check()) ans = min(ans, val);
        return;
    }
    for(int cnt=0; cnt<=2; cnt++) {
        for(int i:z[dep]) seen[i]+=cnt; // 更新动物观看次数
        dfs(dep+1, val+cnt*c[dep]);
        for(int i:z[dep]) seen[i]-=cnt; // 回溯
    }
}
```

**预处理与调用**：
```cpp
vector<int> z[N]; // z[i] 存储动物园 i 中的动物
for(int i=1; i<=m; i++) {
    cin >> k;
    while(k--) {
        cin >> a;
        z[a].push_back(i); // 预处理映射
    }
}
dfs(1, 0);
```

---
处理用时：96.96秒
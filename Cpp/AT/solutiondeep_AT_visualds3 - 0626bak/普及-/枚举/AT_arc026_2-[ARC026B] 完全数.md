# 题目信息

# [ARC026B] 完全数

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc026/tasks/arc026_2

高橋君は完全なものが大好きです。

自然数には、完全数というものがあります。 完全数というのは、自分以外の約数の総和が自分と等しくなる自然数のことです。 例えば $ 6 $ の場合 $ 1\ +\ 2\ +\ 3\ =\ 6 $となるので完全数です。 それに対して、自分以外の約数の総和が自分より小さくなる場合は不足数と言い、大きくなる場合は過剰数と言います。

高橋君には今気になっている自然数があります。高橋君のために、それが完全数なのか不足数なのか過剰数なのか判定してください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1\ ≦\ N\ ≦\ 10^5 $を満たすデータセットに正解した場合は $ 50 $ 点が与えられる。
- $ 1\ ≦\ N\ ≦\ 10^{10} $を満たすデータセットに正解した場合はさらに $ 50 $ 点が与えられる。合計で$ 100 $点となる。

### Sample Explanation 1

$ 1\ +\ 2\ +\ 3\ =\ 6 $なので$ 6 $は完全数です。

### Sample Explanation 2

$ 1\ +\ 2\ +\ 3\ +\ 4\ +\ 6\ +\ 8\ +\ 12\ >\ 24 $なので$ 24 $は過剰数です。

### Sample Explanation 3

$ 1\ +\ 3\ +\ 9\ <\ 27 $なので$ 27 $は不足数です。

## 样例 #1

### 输入

```
6```

### 输出

```
Perfect```

## 样例 #2

### 输入

```
24```

### 输出

```
Abundant```

## 样例 #3

### 输入

```
27```

### 输出

```
Deficient```

## 样例 #4

### 输入

```
945```

### 输出

```
Abundant```

# AI分析结果



## 算法分类
数学（约数之和计算）

---

## 题解思路与解决难点

### 核心思路
1. **约数遍历优化**：通过遍历至sqrt(n)，将时间复杂度从O(n)降为O(sqrt(n))，适用于大数（1e10）。
2. **成对处理因数**：对每个约数i，同时计算其对应的因数n/i，避免重复遍历。
3. **完全平方数特判**：当i² = n时，需减去重复计算的i。
4. **自身约数排除**：最终结果需减去n本身，因为题目要求排除自身。

### 解决难点
- **时间复杂度**：直接遍历1~n会导致TLE，sqrt优化是核心。
- **边界条件**：n=1需单独处理（无其他约数）。
- **完全平方数去重**：如n=4时，i=2会被计算两次，需调整。

---

## 题解评分（≥4星）

1. **珅肐（4.5星）**
   - 思路清晰，代码简洁，正确处理了完全平方数和n=1。
   - 优化到位，代码可读性强。
   - 示例：`sum -= n`明确排除自身。

2. **tiaotiao（4星）**
   - 详细注释和特判处理。
   - 包含调试经验（如输出换行符）。
   - 示例：`sum -= sqn`处理平方数。

3. **EtOH_Lewis（4星）**
   - 逐步优化的过程展示，适合学习调试思路。
   - 最终代码正确且高效。
   - 示例：`counter += i + x/i`优化计算。

---

## 最优思路提炼

1. **sqrt遍历优化**  
   ```cpp
   for (int i=1; i<=sqrt(n); i++) {
       if (n%i == 0) sum += i + n/i;
   }
   ```

2. **完全平方数去重**  
   ```cpp
   if (i == sqrt(n)) sum -= i;  // 避免重复累加
   ```

3. **自身约数排除**  
   ```cpp
   sum -= n;  // 排除自身作为约数
   ```

---

## 同类型题推荐

1. **洛谷P1075**（质因数分解，需优化遍历）
2. **洛谷P1304**（哥德巴赫猜想，涉及因数对处理）
3. **洛谷P1217**（回文质数，质数判断与遍历优化）

---

## 个人心得摘录

- **EtOH_Lewis**：多次提交逐步优化，从TLE到AC的过程体现了调试的重要性。
- **dmslhy**：初始漏掉n=1的特判，强调边界条件需谨慎。
- **zzhz**：未优化导致超时，提醒必须注意时间复杂度。

---

## 可视化算法演示

### 动画方案
1. **像素风格显示**  
   - 使用8位像素风格，将n显示为中央方块，因数对（i, n/i）向两侧展开。
2. **动态约数标记**  
   - 当前遍历的i值高亮为红色，对应的n/i为蓝色。
3. **实时sum更新**  
   - 每次找到因数时，sum数值动态增长并伴随音效。
4. **完全平方数提示**  
   - 当i² =n时，播放特殊音效并闪烁该因数。

### 交互设计
- **步进控制**：允许单步执行，观察每个i的计算过程。
- **音效反馈**：约数匹配时播放“叮”声，平方数时播放“咚”声。

---

## 核心代码实现

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    long long n, sum = 0;
    cin >> n;
    if (n == 1) {
        cout << "Deficient\n";
        return 0;
    }
    for (long long i = 1; i <= sqrt(n); i++) {
        if (n % i == 0) {
            sum += i + n / i;
            if (i * i == n) sum -= i;
        }
    }
    sum -= n; // 排除自身
    if (sum == n) cout << "Perfect\n";
    else if (sum > n) cout << "Abundant\n";
    else cout << "Deficient\n";
    return 0;
}
```

---
处理用时：128.20秒
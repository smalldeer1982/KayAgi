# 题目信息

# [ARC162A] Ekiden Race

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc162/tasks/arc162_a

$ 1 $ から $ N $ までの番号がつけられた $ N $ 人の人がある地点間を往復するレースを行いました。このレースについて、以下の情報が残されています。

- **往路**のタイムの早い順に順位をつけると、どの $ 2 $ 人のタイムも異なっており、人 $ i\ (1\ \leq\ i\ \leq\ N) $ は $ i $ 位であった。
- **往復**のタイム（往路のタイムと復路のタイムの合計）の早い順に順位をつけると、どの $ 2 $ 人のタイムも異なっており、人 $ i\ (1\ \leq\ i\ \leq\ N) $ は $ P_i $ 位であった。
- **復路**のタイムが最も早かった人（複数人いる場合はその全員）に**復路の区間賞**が与えられた。
 
ここで、$ P_1,\ P_2,\ \dots,\ P_N $ は $ 1,\ 2,\ \dots,\ N $ の並べ替えです。

このとき、**復路の区間賞**を与えられた可能性のある人は何人いるでしょうか？

$ T $ 個のテストケースが与えられるので、それぞれについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 500 $
- $ 2\ \leq\ N\ \leq\ 10^3 $
- $ P_1,\ P_2,\ \dots,\ P_N $ は $ 1,\ 2,\ \dots,\ N $ の並べ替えである
- 入力される数値は全て整数
- $ 1 $ つの入力に含まれるテストケースについて、$ N $ の総和は $ 10^3 $ 以下
 
### Sample Explanation 1

\- $ 1 $ つ目のテストケースでは、$ 2 $ 人でレースを行い、復路において人 $ 2 $ が人 $ 1 $ を抜かしています。この場合、復路の区間賞は人 $ 2 $ に与えられます。 - $ 2 $ つ目のテストケースでは、復路で順位が変動しておらず、どの人も復路の区間賞が与えられた可能性があります。

## 样例 #1

### 输入

```
3

2

2 1

4

1 2 3 4

20

13 2 7 1 5 9 3 4 12 10 15 6 8 14 20 16 19 18 11 17```

### 输出

```
1

4

7```

# AI分析结果



**唯一算法分类**  
数组处理

---

**题解思路与算法要点**  
题目要求找出复路时间可能最短的选手数目。核心在于分析总时间排名数组P的性质，发现只有当某选手的P_i是其后缀中的最小值时，其复路时间才可能最短。通过从后向前遍历P数组，维护当前最小值并统计出现次数，即可高效求解。

**解决难点**  
关键在于理解复路时间的数学关系与总时间排名的联系，发现后缀最小值条件能确保复路时间的最优性。这避免了O(n²)的暴力比较，将问题转化为线性遍历。

---

**题解评分（≥4星）**  
1. **Sammy_prime（5星）**  
   - 思路清晰，直接命中核心条件。  
   - O(n)复杂度，代码简洁高效。  
   - 核心逻辑：维护后缀最小值，统计次数。  

2. **zhicheng（4星）**  
   - 通过数组转换将问题转化为前缀最大值统计。  
   - 同样O(n)复杂度，但转换思路较难直接联想。  
   - 正确性与Sammy解法等价，但实现稍复杂。  

---

**最优思路提炼**  
- **后缀最小值统计**：从后向前遍历P数组，记录当前最小值。每次遇到更小值时，该选手可能获得复路奖，计数加一并更新最小值。  
- **等价条件转换**：将总时间排名转换为选手编号数组，统计前缀最大值出现次数，同样可得到正确答案。  

---

**同类型题与算法套路**  
- **后缀最值问题**：如统计数组中每个元素是否是其前缀/后缀的最值。  
- **经典问题**：求最大矩形面积（利用单调栈维护后缀最小值）。  

**推荐题目**  
1. [洛谷 P1901 最大数](https://www.luogu.com.cn/problem/P1901)  
2. [洛谷 P2789 直线交点数](https://www.luogu.com.cn/problem/P2789)  
3. [LeetCode 42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)  

---

**核心代码实现**  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int t,n,p[N]; 
int main(){
    scanf("%d",&t);
    while(t--){
        int ans=0, mn=N;
        scanf("%d",&n);
        for(int i=1;i<=n;++i) scanf("%d",p+i);
        for(int i=n; i>0; --i) {
            if(p[i]<mn) ans++, mn=p[i];
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

**可视化与算法演示**  
**动画方案**：  
1. **像素风格界面**：使用Canvas绘制数组元素，8-bit复古色调（如深蓝背景、亮绿高亮）。  
2. **步进遍历**：从右向左逐个元素扫描，当前元素以黄色高亮。维护的“当前最小值”以红色标记。  
3. **动态更新**：当遇到更小值时，播放“叮”音效，更新最小值并增加计数器（显示于右上角）。  
4. **交互控制**：支持暂停/继续、调整速度（快/中/慢），单步执行按钮用于教学观察。  

**关键动画步骤**：  
- 初始数组显示为灰色方块，数值居中。  
- 遍历时，当前元素变为黄色，若小于最小值则闪红，计数器递增。  
- 最终结果以绿色边框标记所有有效元素，背景播放胜利音效。  

---

**个人心得**  
- **转换视角**：将复路时间问题转化为数组性质分析，避免复杂数学推导。  
- **调试技巧**：构造极端测试用例（如全递增、全递减P数组）验证边界条件。

---
处理用时：406.81秒
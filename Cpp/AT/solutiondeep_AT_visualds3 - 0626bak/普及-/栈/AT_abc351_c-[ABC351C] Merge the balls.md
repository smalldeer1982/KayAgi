# 题目信息

# [ABC351C] Merge the balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_c

空の列と、$ N $ 個のボールがあります。$ i $ 個目 $ (1\leq\ i\leq\ N) $ のボールの大きさは $ 2^{A_i} $ です。

これから $ N $ 回の操作を行います。  
 $ i $ 回目の操作では、$ i $ 個目のボールを列の一番右に付け加えた後、次の手順を繰り返します。

1. 列にあるボールが $ 1 $ つ以下ならば操作を終了する。
2. 列にあるボールのうち右から $ 1 $ 番目のものと $ 2 $ 番目のものの大きさが **異なる** ならば操作を終了する。
3. 列にあるボールのうち右から $ 1 $ 番目のものと $ 2 $ 番目のものの大きさが **等しい** ならば、$ 2 $ つのボールを取り除き、「取り除かれた $ 2 $ つのボールの大きさの和」の大きさのボール $ 1 $ つを列の一番右に付け加える。その後、1. に戻り、手順を繰り返す。
 
$ N $ 回の操作の後で、列にあるボールの数を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\leq\ A_i\leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

操作は次のように行われます。 - $ 1 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^2 $ です。 - $ 2 $ 回目の操作の後、列にあるボールは $ 2 $ つで、大きさは順に $ 2^2 $, $ 2^1 $ です。 - $ 3 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^3 $ です。これは次のようにして得ることができます。 - $ 3 $ 回目の操作において $ 3 $ 個目のボールを付け加えたとき、列にあるボールの大きさは順に $ 2^2,2^1,2^1 $ となります。 - 右から $ 1 $ 番目のボールと $ 2 $ 番目のボールの大きさが等しいため、これらのボールが取り除かれ、大きさが $ 2^1+2^1=2^2 $ のボールが追加されます。このとき、列にあるボールの大きさは $ 2^2 $, $ 2^2 $ となります。 - さらに、再び右から $ 1 $ 番目のボールと $ 2 $ 番目のボールの大きさが等しいため、これらのボールが取り除かれ、大きさが $ 2^2+2^2=2^3 $ のボールが追加され、列にあるボールの大きさは $ 2^3 $ となります。 - $ 4 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^4 $ です。 - $ 5 $ 回目の操作の後、列にあるボールは $ 2 $ つで、大きさは順に $ 2^4 $, $ 2^5 $ です。 - $ 6 $ 回目の操作の後、列にあるボールは $ 3 $ つで、大きさは順に $ 2^4 $, $ 2^5 $, $ 2^3 $ です。 - $ 7 $ 回目の操作の後、列にあるボールは $ 3 $ つで、大きさは順に $ 2^4 $, $ 2^5 $, $ 2^4 $ です。 よって、最後に列にあるボールの数である $ 3 $ を出力します。

### Sample Explanation 2

操作は次のように行われます。 - $ 1 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^0 $ です。 - $ 2 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^1 $ です。 - $ 3 $ 回目の操作の後、列にあるボールは $ 2 $ つで、大きさは順に $ 2^1 $, $ 2^0 $ です。 - $ 4 $ 回目の操作の後、列にあるボールは $ 3 $ つで、大きさは順に $ 2^1 $, $ 2^0 $, $ 2^1 $ です。 - $ 5 $ 回目の操作の後、列にあるボールは $ 4 $ つで、大きさは順に $ 2^1 $, $ 2^0 $, $ 2^1 $, $ 2^2 $ です。 よって、最後に列にあるボールの数である $ 4 $ を出力します。

## 样例 #1

### 输入

```
7

2 1 1 3 5 3 3```

### 输出

```
3```

## 样例 #2

### 输入

```
5

0 0 0 1 2```

### 输出

```
4```

# AI分析结果



### 唯一算法分类
**栈（模拟）**

### 题解思路与核心难点
**核心思路**：利用栈结构维护球的指数，每次新球入栈后，循环检查栈顶两个元素是否相等。若相等则合并为指数+1的新球，直到无法合并。  
**解决难点**：  
1. 发现合并操作等价于指数+1，避免直接计算大数  
2. 正确维护合并操作的循环条件（需连续合并直到无法合并）  
**算法流程**：  
1. 初始化空栈  
2. 遍历每个球，将其压入栈顶  
3. 循环检查栈顶两个元素：  
   - 相等则弹出两元素，压入指数+1的新球  
   - 否则终止循环  
4. 最终栈的大小即为答案  

### 题解评分（≥4星）
1. **HasNoName（5星）**  
   - 使用数组模拟栈，代码简洁高效  
   - 时间复杂度O(N)，空间O(N)  
   - 关键代码：`while(c[top]==x&&top) {top--;x++;}`  

2. **qhr2023（4星）**  
   - 数组模拟栈，逻辑清晰  
   - 直接操作数组指针，减少容器开销  
   - 关键代码：`q[--q[0]]++`  

3. **Houkiseino_Kokoro（4星）**  
   - 使用STL栈容器，代码易读  
   - 显式处理栈弹出与压入逻辑  
   - 关键代码：`while(stk.size()>1 && stk.top()==x)`  

### 最优技巧提炼
- **指数转换**：将球的合并操作转换为指数+1，避免大数计算  
- **栈维护**：用栈结构维护当前序列，只关注栈顶两个元素  
- **循环合并**：必须用`while`而非`if`处理连续合并场景  

### 相似题目推荐
1. [P5788 单调栈](https://www.luogu.com.cn/problem/P5788)  
2. [CF547B 柱状图中最大矩形](https://www.luogu.com.cn/problem/CF547B)  
3. [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)  

### 个人心得摘录
> "发现合并后等价于指数+1是解题的关键，否则会陷入大数计算的泥潭"  
> "必须用while而不是if处理连续合并，否则会漏掉多次合并的情况"  

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, x, top = 0, stk[200005];
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> x;
        while (top && stk[top-1] == x) {
            x++; top--; // 合并操作：指数+1，栈顶下移
        }
        stk[top++] = x; // 新元素入栈
    }
    cout << top;
}
```

---

### 可视化算法设计
**动画方案**：  
1. **像素风格**：  
   - 栈以竖排像素方块表示，每个方块显示指数值  
   - 新入栈元素用绿色闪烁，合并过程用红色高亮  

2. **操作演示**：  
   - 初始化空栈（灰色背景）  
   - 新球入栈时：绿色方块从右侧滑入  
   - 合并时：顶部两个方块变红→爆炸特效→新方块（值+1）下落  

3. **交互控制**：  
   - 步进按钮：单步执行入栈/合并  
   - 速度滑块：调节动画速度（0.5x~3x）  
   - 状态面板：显示当前栈大小/合并次数  

**音效设计**：  
- 入栈："叮"（8-bit短音）  
- 合并："轰"（低频爆炸音）  
- 最终结果：胜利音阶（C大调琶音）  

**复古风格CSS示例**：  
```css
.stack-block {
  width: 32px; height: 32px;
  background: #00FF00; /* 绿色 */
  border: 2px solid #000;
  font-family: 'Press Start 2P', cursive;
}
.merge-effect {
  animation: blink 0.2s 3;
}
@keyframes blink { 50% { opacity: 0; } }
```

---

### 综合结论
本题核心在于将球的合并操作转换为指数运算，通过栈结构高效维护当前序列。所有优质题解均采用栈模拟的思路，区别仅在于具体实现方式（数组/STL容器）。推荐使用数组模拟栈以获得最佳性能，时间复杂度稳定为O(N)。

---
处理用时：85.85秒
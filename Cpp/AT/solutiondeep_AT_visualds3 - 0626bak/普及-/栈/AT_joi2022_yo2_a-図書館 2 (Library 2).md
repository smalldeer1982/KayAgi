# 题目信息

# 図書館 2 (Library 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2022yo2/tasks/joi2022_yo2_a

読書好きのビ太郎は図書館で本を借りて読むことにした．ビ太郎の家は狭いため，床には本 $ 1 $ 冊分の広さのスペースしかない．ただし高さは十分にあるため，ビ太郎はこのスペースに本を積んで管理することにした．

ビ太郎はこれから $ Q $ 回の行動を取る．$ i $ ($ 1\ \leqq\ i\ \leqq\ Q $) 回目の行動は文字列 $ S_i $ で表される．$ S_i $ は 英小文字からなる文字列か `READ` のいずれかであり，その意味は次の通りである．

- 英小文字からなる文字列の場合，ビ太郎は書名が $ S_i $ である本を図書館から借り，スペースの一番上に積む．
- `READ` の場合，ビ太郎はスペースの一番上に積まれている本を読み，図書館に返却する．

あなたはビ太郎がどの本をどのような順番で読んだのかを調べたい．

$ Q $ 回の行動の内容が与えられたとき，ビ太郎が読んだ本の書名を読んだ順に出力するプログラムを作成せよ．

## 说明/提示

### 制約

- $ 2\ \leqq\ Q\ \leqq\ 200\,000 $．
- $ Q $ は整数である．
- $ S_i $ は長さ $ 1 $ 以上 $ 10 $ 以下の文字列である ($ 1\ \leqq\ i\ \leqq\ Q $)．
- $ S_i $ は英小文字からなる文字列または `READ` である ($ 1\ \leqq\ i\ \leqq\ Q $)．
- $ S_i $ が `READ` であるような $ i $ ($ 1\ \leqq\ i\ \leqq\ Q $) は $ 1 $ つ以上存在する．
- $ S_i $ が `READ` のとき，必ずスペースに $ 1 $ 冊以上の本が存在する ($ 1\ \leqq\ i\ \leqq\ Q $) ．

### 小課題

1. ($ 40 $ 点) $ Q\ \leqq\ 2\,000 $．
2. ($ 60 $ 点) 追加の制約はない．

### 採点に関する注意

すべての提出はジャッジシステム上で採点される．

提出されたソースコードは，小課題に対応するすべての採点用入力データについて正しい結果を返したとき，その小課題について正解と認められる．

各提出の得点は，提出されたソースコードについて正解と認められた小課題の得点の合計である．

この課題の得点は，**この課題に対するすべての提出の得点の最大値**である．

現在の得点は「提出結果」タブの「自分の得点状況」から確認できる．

### Sample Explanation 1

この入力例ではビ太郎は以下のように行動する． 1. 書名が `joi` である本をスペースに積む．このとき，スペースに積まれている本の書名は `joi` となる． 2. 書名が `joig` である本をスペースに積む．このとき，スペースに積まれている本の書名は上から順に `joig` ，`joi` となる． 3. 書名が `ioi` である本をスペースに積む．このとき，スペースに積まれている本の書名は上から順に `ioi` ，`joig` ，`joi` となる． 4. 書名が `ioi` である本を読んで返却する．このとき，スペースに積まれている本の書名は上から順に `joig` ，`joi` となる． 5. 書名が `egoi` である本をスペースに積む．このとき，スペースに積まれている本の書名は上から順に `egoi` ，`joig` ，`joi` となる． 6. 書名が `egoi` である本を読んで返却する．このとき，スペースに積まれている本の書名は上から順に `joig` ，`joi` となる． 7. 書名が `joig` である本を読んで返却する．このとき，スペースに積まれている本の書名は `joi` となる． よってビ太郎が読んだ本の書名 `ioi` ，`egoi` ，`joig` を順に改行区切りで出力する． この入力例はすべての小課題の制約を満たす．

### Sample Explanation 2

この入力例はすべての小課題の制約を満たす．

## 样例 #1

### 输入

```
7

joi

joig

ioi

READ

egoi

READ

READ```

### 输出

```
ioi

egoi

joig```

## 样例 #2

### 输入

```
20

one

READ

two

three

four

five

six

seven

READ

eight

nine

READ

ten

eleven

READ

READ

twelve

READ

READ

READ```

### 输出

```
one

seven

nine

eleven

ten

twelve

eight

six```

# AI分析结果



## 算法分类
**栈的应用**

---

## 题解思路、算法要点与解决难点

### 核心逻辑
- **栈结构特性**：先进后出（FILO），完美匹配题目“每次取最上层书”的要求。
- **操作分类**：
  - `非READ指令`：将书名压入栈顶。
  - `READ指令`：弹出栈顶元素并输出。
- **时间复杂度**：每个操作 O(1)，总复杂度 O(Q)，可处理最大数据规模 2e5。

### 解决难点
- **数据结构选择**：必须快速识别栈的特性，直接匹配题目要求。
- **输入输出效率**：C++中需注意 `cin/cout` 与 `scanf/printf` 的速度差异（但本题数据未卡此点）。

---

## 题解评分 (≥4星)

### 5星题解
1. **作者：saixingzhe**  
   - **亮点**：代码最简洁，无冗余；直接使用 STL stack，解释清晰。
   - **代码可读性**：变量命名明确，逻辑一目了然。

2. **作者：nr0728**  
   - **亮点**：注释详细，强调数据规模与可行性；代码结构规范。
   - **优化提示**：指出 `cin` 在 2e5 规模下的可行性。

3. **作者：Leaves_xw**  
   - **亮点**：附题目链接与练习建议，扩展性强；代码风格统一。

---

## 最优思路或技巧提炼

### 关键点
1. **栈的识别**：通过“后进先出”特性匹配题目“取最上层书”的操作。
2. **STL 直接应用**：无需自定义数据结构，利用现成容器实现高效操作。
3. **输入处理优化**：循环内直接处理字符串，避免预存所有指令。

### 代码片段
```cpp
stack<string> stk;
while (q--) {
    string s;
    cin >> s;
    if (s == "READ") {
        cout << stk.top() << endl;
        stk.pop();
    } else {
        stk.push(s);
    }
}
```

---

## 同类型题与算法套路

### 通用解法
- **栈的典型场景**：括号匹配、后缀表达式计算、函数调用栈模拟。

### 推荐题目
1. **P1449 后缀表达式**：直接应用栈计算表达式值。
2. **P1739 表达式括号匹配**：栈判断括号合法性。
3. **P1981 表达式求值**：结合栈处理运算符优先级。

---

## 可视化与算法演示

### 动画设计
1. **数据结构可视化**：  
   - **栈动态变化**：用垂直方块表示书本，新书从上向下堆叠。
   - **颜色标记**：当前操作的书名高亮（压入-绿色，弹出-红色）。

2. **交互功能**：  
   - **步进控制**：支持暂停/继续/单步，观察栈的每一步变化。
   - **速度调节**：滑动条控制动画速度（0.5x~3x）。

3. **复古像素风格**：  
   - **8-bit 效果**：书本用 16x16 像素块表示，背景色为经典 FC 蓝。
   - **音效设计**：压入时播放“放置”音效（短促“哔”声），弹出时播放“翻页”音效。

### 演示截图
![栈操作动图](https://via.placeholder.com/600x400/000000/FFFFFF?text=栈+压入+弹出+动态演示)

---

## 个人心得摘录

> **调试小贴士**：确保每次 `READ` 前栈非空。虽然题目保证输入合法，但在其他类似问题中需注意边界条件。  
> **思维陷阱**：曾误以为需要反向输出结果，后通过样例分析明确栈顶即当前操作对象。

---

## 代码实现（saixingzhe 题解）

```cpp
#include<bits/stdc++.h>
using namespace std;
int q;
string s;
stack<string> a;
int main(){
    cin>>q;
    while(q--){
        cin>>s;
        if(s=="READ"){
            cout<<a.top()<<endl;
            a.pop();
        }
        else a.push(s);
    }
    return 0;
}
```

---
处理用时：60.51秒
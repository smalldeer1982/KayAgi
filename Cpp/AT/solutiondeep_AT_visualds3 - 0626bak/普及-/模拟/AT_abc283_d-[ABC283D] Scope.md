# 题目信息

# [ABC283D] Scope

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc283/tasks/abc283_d

英小文字、`(`、`)` からなる文字列のうち、以下の手順によって空文字列になるものを**良い文字列**と呼びます:

- まず、英小文字をすべて削除する。
- 次に、連続する `()` が存在する限り、それを削除する。
 
例えば、`((a)ba)` は英小文字をすべて削除すると `(())` となり、$ 2 $ 文字目と $ 3 $ 文字目に連続する `()` を削除すると `()` となり、最終的に空文字列にすることができるので良い文字列です。

良い文字列 $ S $ が与えられます。 $ S $ の $ i $ 文字目を $ S_i $ で表します。

各英小文字 `a` , `b` , $ \ldots $ , `z` に対して、その文字が書かれたボールが $ 1 $ つあります。 また、空の箱があります。

高橋君は $ i\ =\ 1,2, $ $ \ldots $ $ ,|S| $ に対してこの順に気を失わない限り操作を行います。

- $ S_i $ が英小文字ならば、その英小文字が書かれたボールを箱に入れる。ただし、そのボールがすでに箱に入っている場合、高橋君は気を失う。
- $ S_i $ が `(` ならば、何もしない。
- $ S_i $ が `)` ならば、$ i $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ i $ 番目までの文字からなる文字列が良い文字列となる最大の整数 $ j $ を取る。（このような整数 $ j $ は必ず存在することが証明できる。）$ j $ 番目から $ i $ 番目までの操作で箱に入れたボールをすべて、箱から取り出す。
 
高橋君が気を失わずに一連の操作を完了させられるか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 3\ \times\ 10^5 $
- $ S $ は良い文字列
 
### Sample Explanation 1

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は何もしません。 $ i\ =\ 3 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 4 $ のとき、$ 4 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 4 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 2 $ であるため、高橋君は `a` の書かれたボールを箱から取り出します。 $ i\ =\ 5 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 6 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 7 $ のとき、$ 7 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 7 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 1 $ であるため、高橋君は `a` の書かれたボールと `b` の書かれたボールを箱から取り出します。 したがってこの場合の答えは `Yes` となります。

### Sample Explanation 2

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 3 $ のとき、高橋君は何もしません。 $ i\ =\ 4 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 5 $ のとき、`a` の書かれたボールはすでに箱に入っているため、高橋君は気を失い、これ以降の操作は行われません。 したがってこの場合の答えは `No` となります。

## 样例 #1

### 输入

```
((a)ba)```

### 输出

```
Yes```

## 样例 #2

### 输入

```
(a(ba))```

### 输出

```
No```

## 样例 #3

### 输入

```
(((())))```

### 输出

```
Yes```

## 样例 #4

### 输入

```
abca```

### 输出

```
No```

# AI分析结果



### 唯一算法分类
栈 + 括号层级状态管理

---

### 题解思路、算法要点与解决难点

**核心问题**：判断操作过程中是否重复放入相同字母，并正确处理括号区间的字母状态回退。

**算法核心**：
1. **括号预处理**：用栈记录每个 `(` 的位置，预处理每个 `)` 对应的左括号位置。
2. **层级状态管理**：维护当前括号层级 `cnt`，每个字母的状态与其所在的层级绑定。
3. **高效回退**：遇到 `)` 时，清除当前层级所有字母的状态，避免遍历整个区间。

**解决难点**：
- **快速匹配括号**：通过栈预处理 `)` 对应的 `(` 位置，实现 O(1) 查询。
- **避免重复遍历**：用层级标记字母状态，每次回退仅需遍历 26 个字母，时间复杂度为 O(n×26)。

---

### 题解评分（≥4星）

1. **作者：szhqwq（4.5星）**
   - **亮点**：利用层级标记字母状态，代码简洁高效。
   - **代码片段**：
     ```cpp
     int cnt = 1;
     for (int i = 0; i < s.size(); i++) {
         if (s[i] == '(') cnt++;
         else if (isalpha(s[i])) {
             if (st[s[i]-'a']) return puts("No");
             st[s[i]-'a'] = cnt;
         } else if (s[i] == ')') {
             for (int j=0; j<26; j++) if (st[j] == cnt) st[j] = 0;
             cnt--;
         }
     }
     ```

2. **作者：_dijkstra_（4星）**
   - **亮点**：预处理括号匹配，使用二维数组保存状态快照。
   - **代码片段**：
     ```cpp
     stack<int> stk;
     for (int i=1; i<=n; i++) {
         if (s[i] == '(') stk.push(i);
         else if (s[i] == ')') {
             for (int j=0; j<26; j++) cnt[i][j] = cnt[stk.top()][j];
             stk.pop();
         }
     }
     ```

3. **作者：MiddleRed（4星）**
   - **亮点**：直接操作栈维护当前有效字符，无需额外预处理。
   - **代码片段**：
     ```cpp
     for (i=idx-1;;i--) {
         if (st[i] == '(') {
             idx = i;
             break;
         }
         alp[st[i]-'a'] = 0;
     }
     ```

---

### 最优思路或技巧提炼

**关键技巧**：
1. **层级标记法**：用整数 `cnt` 表示当前括号层级，字母状态与其层级绑定。
2. **栈快照回退**：每个 `(` 对应一个状态快照，遇到 `)` 时直接回退到快照状态。
3. **预处理匹配**：预先计算每个 `)` 对应的 `(` 位置，避免实时匹配。

**适用场景**：涉及括号嵌套且有状态回退的问题，如表达式求值、作用域管理等。

---

### 可视化与算法演示

**动画设计**：
1. **层级显示**：用不同颜色表示当前括号层级，左侧显示 `cnt` 值。
2. **字母状态**：字母进入盒子时标记颜色（如绿色），清除时变灰。
3. **栈操作**：动态展示栈的压入 (`(`) 和弹出 (`)`)，突出层级变化。
4. **单步调试**：支持暂停/继续，观察每个字符处理后的状态变化。

**复古像素风格**：
- **颜色方案**：8-bit 色调，如 `(` 用蓝色， `)` 用红色，字母用黄色。
- **音效设计**：
  - 放入字母：短促“哔”声。
  - 括号匹配：成功音效（上升音调），错误时“嗡”声警告。

---

### 同类型题推荐

1. **LeetCode 20. Valid Parentheses**（括号有效性判断）
2. **LeetCode 856. Score of Parentheses**（括号嵌套计分）
3. **洛谷 P1944 最长括号匹配**（最长合法括号子串）

---

### 核心代码实现（szhqwq 解法）

```cpp
#include <bits/stdc++.h>
using namespace std;

int st[26];
string s;

int main() {
    cin >> s;
    int cnt = 1;
    for (char c : s) {
        if (c == '(') cnt++;
        else if (c == ')') {
            for (int i=0; i<26; i++) 
                if (st[i] == cnt) st[i] = 0;
            cnt--;
        } else {
            int idx = c - 'a';
            if (st[idx] != 0) {
                cout << "No";
                return 0;
            }
            st[idx] = cnt;
        }
    }
    cout << "Yes";
    return 0;
}
```

**实现思想**：
- 用 `st` 数组记录每个字母所在的括号层级。
- 遇到 `)` 时清除当前层级的字母状态，层级递减。
- 字母冲突时立即终止，保证线性时间复杂度。

---
处理用时：100.91秒
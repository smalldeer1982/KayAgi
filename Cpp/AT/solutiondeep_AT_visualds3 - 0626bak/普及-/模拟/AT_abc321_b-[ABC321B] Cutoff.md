# 题目信息

# [ABC321B] Cutoff

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc321/tasks/abc321_b

以下の手順で行われる試験があります。

- 試験は $ 1 $ ラウンド目から $ N $ ラウンド目までの $ N $ ラウンドからなる。
- 各ラウンドに対し、 $ 0 $ 以上 $ 100 $ 以下の整数でスコアが与えられる。
- $ N $ ラウンドのスコアのうち、最高スコアと最低スコアを除いた $ N-2 $ ラウンドのスコアの合計が最終結果となる。
  - 厳密には、各ラウンドのスコアを昇順に並べた列を $ S=(S_1,S_2,\dots,S_N) $ としたとき、最終結果は $ S_2+S_3+\dots+S_{N-1} $ となる。
 
現在、試験のうち $ N-1 $ ラウンドが終了し、 $ i $ ラウンド目のスコアは $ A_i $ でした。  
 最終結果を $ X $ 以上とするために $ N $ ラウンド目に取るべきスコアの最小値を出力してください。  
 但し、 $ N $ ラウンド目にどのようなスコアを取っても最終結果が $ X $ 以上にならない場合、代わりに `-1` と出力してください。  
 なお、 $ N $ ラウンド目に取りうるスコアは $ 0 $ 以上 $ 100 $ 以下の整数であることに注意してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 3\ \le\ N\ \le\ 100 $
- $ 0\ \le\ X\ \le\ 100\ \times\ (N-2) $
- $ 0\ \le\ A_i\ \le\ 100 $
 
### Sample Explanation 1

$ 4 $ ラウンド目までのスコアは $ 40,60,80,50 $ でした。 $ 5 $ ラウンド目にスコア $ 70 $ を取ると、スコアを昇順に並べた列は $ S=(40,50,60,70,80) $ となり、最終結果は $ 50+60+70=180 $ となります。 なお、最終結果を $ 180 $ 以上にするために取るべきスコアの最小値が $ 70 $ であることが示せます。

### Sample Explanation 2

$ 2 $ ラウンド目までのスコアは $ 100,100 $ でした。 $ 3 $ ラウンド目にスコア $ 0 $ を取ると、スコアを昇順に並べた列は $ S=(0,100,100) $ となり、最終結果は $ 100 $ となります。 最大スコアである $ 100 $ が複数ありますが、そのうち $ 1 $ つしか除かれないことに注意してください。(最小スコアについても同様です) なお、最終結果を $ 100 $ 以上にするために取るべきスコアの最小値が $ 0 $ であることが示せます。

### Sample Explanation 3

$ 4 $ ラウンド目までのスコアは $ 0,0,99,99 $ でした。 $ 5 $ ラウンド目にどのようなスコアを取っても、最終結果を $ 200 $ 以上にすることができないことが示せます。

## 样例 #1

### 输入

```
5 180

40 60 80 50```

### 输出

```
70```

## 样例 #2

### 输入

```
3 100

100 100```

### 输出

```
0```

## 样例 #3

### 输入

```
5 200

0 0 99 99```

### 输出

```
-1```

## 样例 #4

### 输入

```
10 480

59 98 88 54 70 24 8 94 46```

### 输出

```
45```

# AI分析结果



## 算法分类
无算法分类

## 综合分析与结论
题目要求确定第N轮的最小得分，使得去掉最高和最低分后的总和≥X。核心思路是遍历所有可能的得分（0-100），计算每种情况的总和，找到最小满足条件的值。若所有可能都不满足，返回-1。

**核心难点**在于正确模拟所有可能的得分情况，并处理排序后的中间元素总和。需要特别注意当新得分成为新的极值时如何影响结果。算法通过直接模拟每种可能性，保证正确性，时间复杂度可接受。

**可视化设计**：  
- **动画方案**：用滑动条选择s值，动态展示排序后的数组，高亮被移除的最高/最低分，显示中间元素的总和。  
- **颜色标记**：当前测试的s用红色标记，排序后的极值用灰色，中间元素用绿色。  
- **步进控制**：允许逐步增加s值，观察不同情况下的结果变化。  
- **复古效果**：采用8位像素风格，每次s变化时播放音效，当找到解时播放胜利音效，无解时播放失败音效。

## 题解评分（≥4星）
无满足4星及以上题解，以下为通用思路。

## 最优思路提炼
遍历所有可能的得分s（0-100），计算加入后的总和，找到最小满足条件的s。关键在于正确排序并计算中间元素总和，通过从小到大遍历确保第一个满足条件的s即为最小值。

## 代码实现
```python
n, x = map(int, input().split())
a = list(map(int, input().split()))

for s in range(0, 101):
    temp = a + [s]
    temp.sort()
    total = sum(temp[1:-1])  # 排除首尾后的总和
    if total >= x:
        print(s)
        exit()
print(-1)
```

## 同类型题推荐
1. [洛谷P1179 - 数字统计](https://www.luogu.com.cn/problem/P1179)  
2. [洛谷P1055 - ISBN号码](https://www.luogu.com.cn/problem/P1055)  
3. [洛谷P1598 - 垂直柱状图](https://www.luogu.com.cn/problem/P1598)

## 个人心得
调试时需注意排序后元素索引的正确性，特别是当N为3时中间仅一个元素。例如样例2中，当s=0时中间元素为100，确保正确求和。

## 可视化示例
```html
<!DOCTYPE html>
<html>
<body>
<canvas id="canvas" width="400" height="200"></canvas>
<input type="range" id="sSlider" min="0" max="100" value="0">
<div id="status">Testing s=0</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let a = [40,60,80,50]; // 样例1数据
let n = 5, x = 180;

function draw(s) {
    ctx.clearRect(0, 0, 400, 200);
    let temp = [...a, s].sort((a,b)=>a-b);
    let sum = temp.slice(1, -1).reduce((a,b)=>a+b, 0);
    ctx.fillStyle = '#333';
    ctx.fillText(`s=${s}, Sum=${sum} (X=${x})`, 10, 20);
    
    // 绘制排序后的数组
    temp.forEach((val, i) => {
        ctx.fillStyle = i === 0 || i === temp.length-1 ? '#888' : '#0f0';
        ctx.fillRect(50 + i*30, 50, 20, val);
        ctx.fillText(val, 50 + i*30, 45);
    });
    ctx.fillStyle = sum >= x ? '#0f0' : '#f00';
    ctx.fillText(sum >= x ? "Valid ✔️" : "Invalid ❌", 10, 180);
}

document.getElementById('sSlider').oninput = e => {
    let s = parseInt(e.target.value);
    document.getElementById('status').textContent = `Testing s=${s}`;
    draw(s);
};
draw(0);
</script>
</body>
</html>
```  
此代码创建了一个交互式可视化工具，用户可通过滑块调整s值，实时查看排序后的数组及结果判定。绿色柱表示中间元素，灰色表示被排除的极值，动态反馈是否满足条件。

---
处理用时：144.21秒
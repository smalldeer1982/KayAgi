# 题目信息

# [ABC323C] World Tour Finals

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_c

$ N $ 人のプレイヤーが参加するプログラミングコンテスト World Tour Finals が行われており、競技時間の半分が過ぎました。 このコンテストでは $ M $ 問の問題が出題されており、問題 $ i $ の点数 $ A_i $ は $ 500 $ 以上 $ 2500 $ 以下の $ 100 $ の倍数です。

各 $ i\ =\ 1,\ \ldots,\ N $ について、プレイヤー $ i $ がどの問題を既に解いたかを表す文字列 $ S_i $ が与えられます。 $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列で、$ S_i $ の $ j $ 文字目が `o` のときプレイヤー $ i $ は問題 $ j $ を既に解いており、`x` のときまだ解いていません。 ただし、どのプレイヤーもまだ全ての問題を解いてはいません。

プレイヤー $ i $ の総合得点は、解いた問題の点数の合計に、**ボーナス点** $ i $ 点を加えた点数として計算されます。  
さて、各 $ i\ =\ 1,\ \ldots,\ N $ について以下の質問に答えてください。

- プレイヤー $ i $ がまだ解いていない問題を少なくとも何問解くことで、プレイヤー $ i $ の総合得点が他のプレイヤー全員の現在の総合得点を上回ることができますか？

なお、問題文中の条件と制約から、プレイヤー $ i $ が全ての問題を解くことで、他のプレイヤー全員の現在の総合得点を上回ることができることが証明できます。 このことから、答えは常に定義されることに注意してください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 100 $
- $ 1\leq\ M\leq\ 100 $
- $ 500\leq\ A_i\leq\ 2500 $
- $ A_i $ は $ 100 $ の倍数
- $ S_i $ は `o`, `x` からなる長さ $ M $ の文字列
- $ S_i $ には `x` が一個以上含まれる
- 入力される数値は全て整数

### Sample Explanation 1

競技時間の半分の経過時の各プレイヤーの総合得点は、プレイヤー $ 1 $ が $ 2001 $ 点、プレイヤー $ 2 $ が $ 1502 $ 点、プレイヤー $ 3 $ が $ 1703 $ 点です。 プレイヤー $ 1 $ は $ 1 $ 問も解かずとも、他のプレイヤー全員の総合得点を上回っています。 プレイヤー $ 2 $ は、例えば問題 $ 4 $ を解けば総合得点が $ 3502 $ 点となり、他のプレイヤー全員の総合得点を上回ります。 プレイヤー $ 3 $ も、例えば問題 $ 4 $ を解けば総合得点が $ 3703 $ 点となり、他のプレイヤー全員の総合得点を上回ります。

## 样例 #1

### 输入

```
3 4
1000 500 700 2000
xxxo
ooxx
oxox```

### 输出

```
0
1
1```

## 样例 #2

### 输入

```
5 5
1000 1500 2000 2000 2500
xxxxx
oxxxx
xxxxx
oxxxx
oxxxx```

### 输出

```
1
1
1
1
0```

## 样例 #3

### 输入

```
7 8
500 500 500 500 500 500 500 500
xxxxxxxx
oxxxxxxx
ooxxxxxx
oooxxxxx
ooooxxxx
oooooxxx
ooooooxx```

### 输出

```
7
6
5
4
3
2
0```

# AI分析结果



### 唯一算法分类
贪心算法

### 综合分析与结论
题目要求每位选手通过最少的新题数使得总分超过其他所有选手的当前总分。核心思路是贪心选择未解决的最高分题目，直到满足条件。关键步骤包括：

1. **计算当前总分**：每位选手的总分由已解题分数和自身编号组成。
2. **确定目标阈值**：对于每个选手，需找到其他选手中的最大当前总分（`max_other`）。
3. **贪心选择题目**：将未解决的题目按分值降序排序，依次选择，直到总分超过 `max_other`。

**难点**在于正确计算每个选手需要超过的阈值，并高效选择题目。部分题解错误地将全局最大值视为阈值，而忽略其他选手可能有相同最高分的情况。正确的处理应为每个选手单独计算其他选手的最大分。

### 题解清单 (≥4星)
1. **xiaomuyun（4星）**  
   - **亮点**：正确计算每个选手需要超过的阈值，通过贪心选择最高分题目，确保最少题数。
   - **代码简析**：遍历所有其他选手的总分，取最大值作为目标阈值。通过排序未解决题目，依次累加直至超过阈值。

### 最优思路或技巧提炼
- **阈值计算**：对每位选手，单独计算其他选手的最大分 `max_other`，确保严格超过。
- **贪心策略**：按题目分值降序选择未解决问题，确保每次增加的分值最大，从而最小化解题数。
- **数据结构**：利用排序（`sort`）高效处理题目选择，时间复杂度为 O(m log m)，适用于题目规模。

### 同类型题或类似算法套路
- **贪心选择最大值**：常见于背包问题、任务调度等需局部最优的场景。
- **动态阈值计算**：在多人竞赛类题目中，需动态比较其他参与者的状态。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
   **理由**：贪心选择最小值合并，需优先队列实现。
2. [P1208 [USACO1.3]混合牛奶 Mixing Milk](https://www.luogu.com.cn/problem/P1208)  
   **理由**：贪心选择单价最低的牛奶供应商。
3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)  
   **理由**：贪心选择跳跃高度，最大化总能量。

### 代码片段
**核心逻辑（xiaomuyun）**  
```cpp
// 计算每个选手需要超过的最大其他选手分
int need = 0;
for (int j = 1; j <= n; ++j) {
    if (i == j) continue;
    need = max(need, cur[j]); // 其他选手的最大分
}
// 贪心选择未解决的题目
vector<int> unsolved;
for (int j = 1; j <= m; ++j) {
    if (s[i][j] == 'x') unsolved.push_back(a[j]);
}
sort(unsolved.begin(), unsolved.end(), greater<int>());
int ans = 0, sum = cur[i];
for (int score : unsolved) {
    if (sum > need) break;
    sum += score;
    ans++;
}
cout << ans << endl;
```

### 可视化与算法演示
**动画方案**  
- **网格布局**：每个题目显示为方块，颜色表示分值（红→高，蓝→低）。
- **选手状态**：显示当前总分和阈值线，动态更新解题过程。
- **贪心过程**：高亮当前选择的题目，显示总分增长和剩余需超分。
- **像素风格**：使用 8-bit 色彩，音效提示题目选中和总分变化。

**交互设计**  
- **步进控制**：允许单步执行或自动播放，调节动画速度。
- **状态面板**：显示当前选手、已选题目数、总分和阈值。

### 复古游戏化设计
- **像素音效**：选择题目时播放“点击”音效，总分超过阈值时播放胜利音效。
- **积分系统**：每正确解题获得积分，连续正确触发连击奖励。
- **自动演示模式**：AI 自动运行，展示最优解题路径。

---
处理用时：330.94秒
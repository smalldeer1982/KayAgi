# 题目信息

# [ABC329C] Count xxx

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc329/tasks/abc329_c

英小文字からなる長さ $ N $ の文字列 $ S $ が与えられます。

$ S $ の空でない部分文字列であって、$ 1 $ 種類の文字のみからなるものの数を求めてください。 ただし、文字列として等しい部分文字列同士は、取り出し方が異なっても区別**しません**。

なお、$ S $ の空でない部分文字列とは、$ S $ の先頭から $ 0 $ 文字以上、末尾から $ 0 $ 文字以上削除して得られる文字列のうち、長さが $ 1 $ 以上であるもののことをいいます。 例えば、`ab` や `abc` は `abc` の空でない部分文字列ですが、`ac` や空文字列は `abc` の空でない部分文字列ではありません。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
 
### Sample Explanation 1

$ S $ の空でない部分文字列であって、$ 1 $ 種類の文字のみからなるものは `a`, `aa`, `aaa`, `b` の $ 4 $ つです。 $ S $ から `a` や `aa` を取り出す方法は $ 1 $ 通りではありませんが、それぞれ $ 1 $ 回ずつしか数えないことに注意してください。

## 样例 #1

### 输入

```
6

aaabaa```

### 输出

```
4```

## 样例 #2

### 输入

```
1

x```

### 输出

```
1```

## 样例 #3

### 输入

```
12

ssskkyskkkky```

### 输出

```
8```

# AI分析结果



## 算法分类
无算法分类

## 综合分析与结论
该题核心在于统计每个字符在字符串中的最大连续长度，并将这些长度求和。难点在于如何避免重复计数不同连续段中的相同子串。通过遍历字符串时维护每个字符的当前连续长度和最大连续长度，可以高效解决问题。每个字符的贡献仅取决于其最长连续段，因为该段包含所有更短长度的子串，其他段的子串均被覆盖。

### 核心算法流程
1. **初始化**：为每个字符维护最大连续长度数组 `max_len[26]`。
2. **遍历字符串**：维护当前连续长度 `current_len` 和前一个字符 `prev`。
3. **更新逻辑**：
   - 若当前字符与前一个相同，`current_len` 自增。
   - 否则重置 `current_len` 为1，并更新 `prev`。
   - 比较并更新当前字符的最大连续长度。
4. **求和结果**：累加所有字符的最大连续长度。

### 可视化设计思路
- **颜色标记**：在遍历字符串时，高亮当前字符和前一个字符，动态显示 `current_len` 和 `max_len` 的更新。
- **动画演示**：以字符流形式展示字符串，当前连续段用同色背景标注，右侧面板实时更新 `max_len` 的值。
- **复古像素风格**：用8位像素风格显示每个字符的连续块，不同颜色代表不同字符，块长度表示连续长度，最大长度块高亮边框。

## 题解清单 (≥4星)
无具体题解达到4星以上，以下给出通用实现：

## 代码实现
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n;
    string s;
    cin >> n >> s;
    
    int max_len[26] = {0};
    int current_len = 0;
    char prev = 0;
    
    for (char c : s) {
        if (c == prev) {
            current_len++;
        } else {
            current_len = 1;
            prev = c;
        }
        if (current_len > max_len[c - 'a']) {
            max_len[c - 'a'] = current_len;
        }
    }
    
    int ans = 0;
    for (int i = 0; i < 26; i++) {
        ans += max_len[i];
    }
    cout << ans << endl;
    
    return 0;
}
```

## 最优思路或技巧提炼
- **最大连续段统计**：对每个字符只记录最长连续段，避免重复计算子串。
- **线性遍历优化**：仅需一次遍历即可完成所有统计，时间复杂度 O(n)。
- **空间效率**：使用固定大小数组代替哈希表，提升访问速度。

## 同类型题或类似算法套路
- **最长连续子串问题**：如寻找字符串中最长无重复字符子串。
- **分组统计问题**：如统计数组中连续相同元素的分组信息。

## 推荐相似题目
1. [LeetCode 485. 最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)
2. [LeetCode 1446. 连续字符](https://leetcode-cn.com/problems/consecutive-characters/)
3. [洛谷 P1179 数字统计](https://www.luogu.com.cn/problem/P1179)

---
处理用时：108.64秒
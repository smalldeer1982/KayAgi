# 题目信息

# [ABC343D] Diversity of Scores

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc343/tasks/abc343_d

高橋君が主催するコンテストに、$ 1 $ から $ N $ までの番号が付けられた $ N $ 人の選手が参加しています。 このコンテストは各選手がその得点を競うものであり、現在の得点はどの選手も $ 0 $ 点です。

未来予知の能力を持つ高橋君は、今から選手たちの得点がどのように変動するかを知っています。 具体的には、$ i=1,2,\dots,T $ について、今から $ i $ 秒後に選手 $ A_i $ の得点が $ B_i $ 点増加します。 逆に、それ以外に得点の変動はありません。

得点の多様性を好む高橋君は、各時点における選手たちの得点に何種類の値が現れるかを知りたがっています。 $ i=1,2,\dots,T $ それぞれについて、今から $ i+0.5 $ 秒後の選手たちの得点には何種類の値が現れるか求めてください。

例えば、ある時点における選手たちの得点がそれぞれ $ 10,20,30,20 $ 点であった場合、この時点での選手たちの得点には $ 3 $ 種類の値が現れています。

## 说明/提示

### 制約

- $ 1\leq\ N,\ T\leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ N $
- $ 1\leq\ B_i\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

選手 $ 1,2,3 $ の得点をこの順に並べた数列を $ S $ とします。 現在、$ S=\lbrace\ 0,0,0\rbrace $ です。 - $ 1 $ 秒後に選手 $ 1 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,0,0\rbrace $ になります。よって、$ 1.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。 - $ 2 $ 秒後に選手 $ 3 $ の得点が $ 20 $ 点増加し、$ S=\lbrace\ 10,0,20\rbrace $ になります。よって、$ 2.5 $ 秒後の選手たちの得点には $ 3 $ 種類の値が現れます。 - $ 3 $ 秒後に選手 $ 2 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,10,20\rbrace $ になります。よって、$ 3.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。 - $ 4 $ 秒後に選手 $ 2 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,20,20\rbrace $ になります。よって、$ 4.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。

## 样例 #1

### 输入

```
3 4
1 10
3 20
2 10
2 10```

### 输出

```
2
3
2
2```

## 样例 #2

### 输入

```
1 3
1 3
1 4
1 3```

### 输出

```
1
1
1```

## 样例 #3

### 输入

```
10 10
7 2620
9 2620
8 3375
1 3375
6 1395
5 1395
6 2923
10 3375
9 5929
5 1225```

### 输出

```
2
2
3
3
4
4
5
5
6
5```

# AI分析结果



**唯一算法分类**: 数据结构应用

---

### 题解思路、算法要点与解决难点

**核心思路**  
本题要求动态维护分数种类数，每次操作只影响一个选手的分数。通过维护一个哈希表（`map`/`unordered_map`）记录每个分数出现的次数，结合变量跟踪当前种类数，实现高效统计。

**算法要点**  
1. **哈希表维护**：用 `map` 或 `unordered_map` 存储每个分数的出现次数，键为分数，值为出现次数。
2. **动态更新**：每次操作后，旧分减少出现次数，若归零则种类数减一；新分增加出现次数，若首次出现则种类数加一。
3. **初始状态**：所有选手初始分数为0，哈希表初始化为 `{0: N}`，种类数初始为1。

**解决难点**  
- **高效统计**：直接暴力统计时间复杂度为 O(NT)，无法通过。通过仅处理变化的分数，将复杂度降至 O(T log N) 或 O(T)。
- **边界处理**：需正确处理旧分减少至0时移除键（避免影响哈希表大小计算），或通过变量维护种类数。

---

### 题解评分（≥4星）

1. **Little_x_starTYJ（5星）**  
   - **亮点**：维护变量 `number` 跟踪种类数，避免频繁调用 `size` 函数，代码简洁高效。
   - **代码片段**：  
     ```cpp
     m[c[a[i]]]--;
     if (m[c[a[i]]] == 0) number--;
     c[a[i]] += b[i];
     m[c[a[i]]]++;
     if (m[c[a[i]]] == 1) number++;
     ```

2. **OIer_Tan（4星）**  
   - **亮点**：使用 `unordered_map` 并调用 `erase`，直接通过 `size` 获取种类数，代码简洁。
   - **代码片段**：  
     ```cpp
     cnt[s[a [i]]]--;
     if (!cnt[s[a [i]]]) cnt.erase(s[a [i]]);
     s[a [i]] += b[i];
     cnt[s[a [i]]]++;
     ```

3. **f_hxr_（4星）**  
   - **亮点**：代码极简，逻辑清晰，直接通过增减 `ans` 维护种类数。
   - **代码片段**：  
     ```cpp
     mp[val[A[i]]]--;
     if (mp[val[A[i]]] == 0) --ans;
     val[A[i]] += B[i];
     mp[val[A[i]]]++;
     if (mp[val[A[i]]] == 1) ++ans;
     ```

---

### 最优思路或技巧提炼

1. **核心变量维护**：用变量跟踪种类数，避免频繁查询哈希表大小。
2. **条件判断优化**：仅当旧分出现次数归零或新分首次出现时更新种类数。
3. **数据结构选择**：优先使用 `unordered_map` 以降低平均时间复杂度，但需及时 `erase` 归零的键。

---

### 同类型题与算法套路

**类似问题**  
- **动态统计元素种类数**：如实时统计数组中不同元素的数量。
- **哈希表维护频率**：如 LeetCode 347. 前 K 个高频元素，需结合频率统计。

**通用解法**  
- 使用哈希表记录元素出现次数，通过动态增减操作维护统计指标（如种类数、频率等）。

---

### 推荐相似题目

1. **P3369 【模板】普通平衡树**  
   - 动态维护有序集合，支持插入、删除和查询排名。
2. **P3374 【模板】树状数组 1**  
   - 单点修改、区间求和，练习高效维护动态数据。
3. **LeetCode 1244. Design A Leaderboard**  
   - 动态更新选手分数并查询前 K 名，需结合哈希表与堆。

---

### 可视化与算法演示

**动画设计**  
1. **数据结构展示**：左侧为选手列表（编号+分数），右侧为哈希表（分数: 出现次数）和种类数变量。
2. **关键步骤高亮**：操作时，旧分标红并减少计数，新分标绿并增加计数，种类数变量同步更新。
3. **复古像素风格**：  
   - **颜色方案**：使用 8-bit 调色板，选手分数变化时播放 8-bit 音效。
   - **Canvas 绘制**：选手分数变化时，对应像素块颜色渐变，哈希表键值对动态更新。

**交互设计**  
- **步进控制**：允许单步执行，观察哈希表和变量变化。
- **自动模式**：模拟 AI 自动执行操作，展示算法流程。

---

### 代码片段（核心逻辑）

```cpp
#include <unordered_map>
using namespace std;

int main() {
    int n, t;
    cin >> n >> t;
    unordered_map<long long, int> cnt;
    vector<long long> score(n + 1, 0);
    cnt[0] = n;
    int ans = 1;
    
    while (t--) {
        int a, b;
        cin >> a >> b;
        // 处理旧分
        if (--cnt[score[a]] == 0) {
            cnt.erase(score[a]);
            ans--;
        }
        // 更新分数
        score[a] += b;
        // 处理新分
        if (cnt[score[a]]++ == 0) {
            ans++;
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

**总结**：本题通过哈希表与变量维护，高效解决了动态统计分数种类数的需求。核心在于每次仅处理变化的分数，避免全量计算。

---
处理用时：157.70秒
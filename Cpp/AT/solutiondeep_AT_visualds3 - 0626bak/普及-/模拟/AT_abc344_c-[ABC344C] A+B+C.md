# 题目信息

# [ABC344C] A+B+C

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc344/tasks/abc344_c

$ 3 $ 個の数列 $ A=(A_1,\ldots,A_N),\ B=(B_1,\ldots,B_M),\ C=(C_1,\ldots,C_L) $ が与えられます。

さらに数列 $ X=(X_1,\ldots,X_Q) $ が与えられるので、各 $ i=1,\ldots,Q $ に対して次の問題を解いてください。

問題：$ A,B,C $ からそれぞれ $ 1 $ 個ずつ要素を選び、和を $ X_i $ にすることができるか？

## 说明/提示

### 制約

- $ 1\ \leq\ N,M,L\ \leq\ 100 $
- $ 0\ \leq\ A_i,\ B_i\ ,C_i\ \leq\ 10^8 $
- $ 1\ \leq\ Q\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ X_i\ \leq\ 3\times\ 10^8 $
- 入力は全て整数である

### Sample Explanation 1

\- $ A,B,C $ からそれぞれ $ 1 $ 個ずつ要素を選び和を $ 1 $ にすることはできません。 - $ A,B,C $ からそれぞれ $ 1,2,2 $ を選ぶと和を $ 5 $ にすることができます。 - $ A,B,C $ からそれぞれ $ 2,4,4 $ を選ぶと和を $ 10 $ にすることができます。 - $ A,B,C $ からそれぞれ $ 1 $ 個ずつ要素を選び和を $ 50 $ にすることはできません。

## 样例 #1

### 输入

```
3
1 2 3
2
2 4
6
1 2 4 8 16 32
4
1 5 10 50```

### 输出

```
No
Yes
Yes
No```

# AI分析结果



## 算法分类
**哈希表/预处理**

---

## 综合分析与结论
**核心思路**  
所有题解均采用预处理三数组之和的思路，核心步骤为：  
1. 枚举所有可能的 $A_i+B_j+C_k$ 组合，存入高效查询结构  
2. 对每个询问 $X_i$，快速判断其是否存在于预存结构中  

**解决难点**  
- **时间复杂度优化**：将 $O(Q \cdot N^3)$ 暴力降至 $O(N^3 + Q)$  
- **空间优化**：使用哈希表或排序替代大数组，避免数值范围过大导致内存爆炸  

**可视化设计**  
- **核心动画**：  
  1. 三数组元素以像素方块排列，用不同颜色区分  
  2. 遍历所有组合时，高亮当前 $A_i$（红）、$B_j$（绿）、$C_k$（蓝），生成其和并显示为金色方块  
  3. 查询阶段，输入 $X_i$ 后，金色方块闪烁表示匹配成功/失败  
- **复古效果**：  
  - 音效：组合生成时播放“哔”声，查询命中时播放“叮”，未命中播放“咔”  
  - 背景：8-bit 风格网格，组合遍历过程类似俄罗斯方块堆叠  

---

## 题解清单 (≥4星)
1. **OIer_Tan（5星）**  
   - **亮点**：使用 `unordered_set` 实现 $O(1)$ 查询，代码简洁高效  
   - **代码片段**：  
     ```cpp
     unordered_set<ll> cnt;
     for (i,j,k) cnt.insert(a[i]+b[j]+c[k]);
     if (cnt.find(x) != cnt.end()) cout<<"Yes";
     ```

2. **littlebug（4星）**  
   - **亮点**：排序后二分查找，避免哈希冲突风险  
   - **代码片段**：  
     ```cpp
     sort(ans, ans+ai);
     bool exist = binary_search(ans, ans+ai, x);
     ```

3. **ToastBread（4星）**  
   - **亮点**：直接开大数组标记，极致速度（需注意内存限制）  
   - **代码片段**：  
     ```cpp
     bool ans[3e8+5] = {0};
     ans[a[i]+b[j]+c[k]] = 1;
     if (ans[x]) cout<<"Yes";
     ```

---

## 最优思路提炼
**关键技巧**  
- **预处理三数之和**：利用 $N,M,L$ 较小特点，暴力枚举所有组合  
- **哈希表优化查询**：`unordered_set` 实现 $O(1)$ 存在性检查  
- **空间权衡**：数值范围大时优先哈希，范围小时可用数组  

**代码实现核心**  
```cpp
// 预处理
unordered_set<int> sums;
for (int a : A) 
  for (int b : B)
    for (int c : C)
      sums.insert(a + b + c);

// 查询
for (int x : X) 
  cout << (sums.count(x) ? "Yes" : "No");
```

---

## 同类题目推荐
1. **P1214 [USACO1.4] 等差数列**  
   - 预处理两数之和，判断是否存在特定差值  

2. **P1102 A-B 数对**  
   - 哈希表记录数出现次数，查询差值  

3. **LeetCode 1. 两数之和**  
   - 基础哈希应用，实时维护差值  

---

## 可视化算法演示
**动画步骤**  
1. **枚举阶段**：  
   - 三数组元素排列为三列，选中元素高亮  
   - 生成的和以像素方块形式加入右侧“和池”  
   - 音效：每次组合生成时播放短促“哔”声  

2. **查询阶段**：  
   - 输入 $X_i$ 后，“和池”中对应方块闪烁（绿色命中/红色失败）  
   - 显示匹配结果时播放对应音效  

**交互设计**  
- **速度控制**：滑块调节枚举速度（1x-10x）  
- **单步执行**：逐步观察组合生成过程  
- **音效开关**：可关闭背景音乐保留提示音  

**复古风格 CSS 片段**  
```css
.pixel-grid {
  background: #2d2d2d;
  border: 2px solid #8b8b8b;
}
.pixel-cell {
  width: 16px;
  height: 16px;
  background: #4a4a4a;
}
.pixel-highlight {
  background: #ff5555 !important; /* 红绿蓝高亮色 */
}
```

---

## 个人心得摘录
> **xxboyxx**：  
> “序列中的值很大，数组存不下必须用 map，但要注意 $NML$ 的规模是否允许哈希”  
> **经验**：哈希表选择需权衡数据规模与冲突概率  

> **wly09**：  
> “开大数组在本地测试时崩溃，改用排序二分后稳定通过”  
> **教训**：极端数值范围下优先考虑动态结构  

---

**可视化 Demo 截图示意**  
![三数组枚举与和池](https://via.placeholder.com/600x400/000000/FFFFFF?text=8-bit+Style+Sum+Visualization)  
（图示：左侧三色数组，右侧金色和池，当前查询命中高亮）

---
处理用时：103.40秒
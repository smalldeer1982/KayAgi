# 题目信息

# [ABC348C] Colorful Beans

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc348/tasks/abc348_c

$ N $ 種類のビーンズが $ 1 $ 粒ずつあります。 $ i $ 種類目のビーンズはおいしさが $ A_i $ で色が $ C_i $ です。ビーンズは混ぜられており、色でしか区別することができません。

あなたはビーンズの色を $ 1 $ つ選び、その色のビーンズをどれか $ 1 $ 粒食べます。ビーンズの色をうまく選ぶことで、食べる可能性のあるビーンズのおいしさの最小値を最大化してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^{5} $
- $ 1\ \leq\ A_i\ \leq\ 10^{9} $
- $ 1\ \leq\ C_i\ \leq\ 10^{9} $
- 入力は全て整数である。
 
### Sample Explanation 1

同じ色のビーンズは互いに区別がつかないことに注意してください。 選ぶことができる色は 色 $ 1 $ と 色 $ 5 $ です。 - 色 $ 1 $ のビーンズは $ 2 $ 種類あり、美味しさはそれぞれ $ 100,\ 40 $ です。よって、色 $ 1 $ を選んだときのおいしさの最小値は $ 40 $ です。 - 色 $ 5 $ のビーンズは $ 2 $ 種類あり、美味しさはそれぞれ $ 20,\ 30 $ です。よって、色 $ 5 $ を選んだときのおいしさの最小値は $ 20 $ です。 おいしさの最小値を最大化するには 色 $ 1 $ を選べばよいため、そのときの最小値である $ 40 $ を出力します。

## 样例 #1

### 输入

```
4

100 1

20 5

30 5

40 1```

### 输出

```
40```

## 样例 #2

### 输入

```
10

68 3

17 2

99 2

92 4

82 4

10 3

100 2

78 1

3 1

35 4```

### 输出

```
35```

# AI分析结果



### 唯一算法分类
哈希表 / 分组处理

---

### 题解思路与算法要点
**核心思路**：对每个颜色求美味度最小值，再在这些最小值中求最大值。  
**关键难点**：颜色值域大（1e9）无法用数组直接存储，需选择高效的分组方式。

#### 实现方法对比：
1. **哈希表法（主流解法）**
   - 使用 `map/unordered_map` 存储颜色到最小值的映射
   - 遍历时动态更新最小值
   - 时间复杂度：O(n log n)（map）或 O(n)（unordered_map）
   - 空间复杂度：O(n)

2. **排序法（高效解法）**
   - 按颜色为第一关键字、美味度为第二关键字排序
   - 相邻元素颜色不同时，即为当前颜色的最小值
   - 时间复杂度：O(n log n)
   - 空间复杂度：O(1)

**差异点**：哈希表法更直观但常数较大，排序法通过预处理省去哈希开销，更稳定。

---

### 题解评分（≥4星）

1. **Little_x_starTYJ（5星）**  
   - 提供两种实现（哈希表+排序），代码清晰  
   - 注释详细，对比不同方法的性能差异  
   - 亮点：完整覆盖主流解法，适合不同层次学习者

2. **hz_rft（4.5星）**  
   - 结构体排序法实现简洁  
   - 对排序逻辑解释清晰，适合基础训练  
   - 亮点：通过排序避免哈希操作，降低理解门槛

3. **MinimumSpanningTree（4星）**  
   - 使用 `unordered_map` 提升效率  
   - 代码简短，适合竞赛快速编码  
   - 亮点：迭代器遍历方式展示标准操作

---

### 最优思路提炼
**核心技巧**：  
1. **哈希表分组**：用 O(1) 查询快速更新最小值  
2. **排序预分组**：通过排序将同颜色元素连续存储，天然形成分组  
3. **极值复用**：在遍历过程中同时记录当前最小值和全局最大值

**代码片段示例（哈希表法）**：
```cpp
unordered_map<int, int> mp;
for (int i = 0; i < n; ++i) {
    int a, c;
    cin >> a >> c;
    if (!mp.count(c)) mp[c] = a;
    else mp[c] = min(mp[c], a);
}
int ans = 0;
for (auto& [k, v] : mp) ans = max(ans, v);
```

---

### 相似题目推荐
1. **P1097 [NOIP2007 提高组] 统计数字**（哈希统计频次）  
2. **P1908 逆序对**（分组处理与排序结合）  
3. **P5149 会议座位**（字符串哈希与排序）

---

### 可视化算法演示
**动画设计**：  
1. **像素风格界面**：  
   - 豆子显示为不同颜色方块，美味度以数字标注  
   - 当前处理豆子高亮闪烁，所属颜色组边框变色  
2. **关键步骤**：  
   - 哈希表法：显示新颜色插入哈希表，已有颜色更新最小值时的数值跳动  
   - 排序法：展示豆子按颜色、美味度排序过程，同颜色组内最小值标记为金色  
3. **音效提示**：  
   - 发现新颜色时播放“叮”声，更新最小值时播放“咔嚓”声  
   - 最终结果展示时触发胜利音效

**交互控制**：  
- 速度滑块调节动画速度  
- 单步执行按钮观察每一步状态变化  
- 模式切换（哈希表法 vs 排序法）

---

### 个人心得摘录
> "若用 map 需注意初始值处理，未出现的颜色要先赋初值，否则可能误判为 0" —— Little_x_starTYJ  
> "结构体排序时，第二关键字选美味度升序，这样同颜色第一个元素就是最小值" —— hz_rft

---

### 核心算法流程图解
```plaintext
哈希表法：
[输入豆子] → [查询颜色是否存在] → 是 → [比较并更新最小值]
                  ↓
                 否 → [插入新颜色]
                 
排序法：
[按颜色、美味度排序] → [遍历检查颜色边界] → 颜色变化 → [记录前组最小值]
```

---
处理用时：62.48秒
# 题目信息

# [ABC361C] Make Them Narrow

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_c

長さ $ N $ の数列 $ A $ が与えられます。  
 $ A $ のうち丁度 $ K $ 要素を自由に選んで消し、残った要素を順序を保って連結した数列を $ B $ とします。  
 ( $ B $ の最大値 ) $ - $ ( $ B $ の最小値 ) としてありうる最小値を求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K\ <\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
 
### Sample Explanation 1

$ A=(3,1,5,4,9) $ から丁度 $ 2 $ 要素を自由に選んで消すことを考えます。 - 例えば $ 2 $ 要素目の $ 1 $ 、 $ 5 $ 要素目の $ 9 $ を消すと、消した後の数列 $ B=(3,5,4) $ となります。 - このとき $ B $ の最大値は $ 5 $ 、最小値は $ 3 $ なので ( $ B $ の最大値 ) $ - $ ( $ B $ の最小値 ) $ =2 $ となり、これは達成可能な最小値です。

## 样例 #1

### 输入

```
5 2

3 1 5 4 9```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 1 1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
8 3

31 43 26 6 18 36 22 13```

### 输出

```
18```

# AI分析结果



## 算法分类
贪心，排序后滑动窗口

---

## 题解思路与核心难点

### 核心思路
1. **排序必要性**：极差仅由最大值和最小值决定，排序后相邻元素差值更小，便于寻找最优解。
2. **连续子数组最优性**：任何非连续的选法都会保留更大的极差，最优解必定是排序后的一段连续子数组。
3. **滑动窗口枚举**：枚举所有可能的长度为 `n-k` 的连续子数组，计算极差并取最小值。

### 解决难点
- **贪心策略证明**：通过数学归纳或反证法证明最优解必须为连续区间，避免暴力枚举所有组合。
- **边界处理**：正确处理排序后的数组索引，确保窗口右端点不越界。
- **时间复杂度优化**：将复杂度从组合数级别降至 `O(n log n)`，满足 `2e5` 数据量要求。

---

## 题解评分（≥4星）

### 1. juruo5e59（5星）
- **亮点**：代码最简洁，直接转化问题为连续区间极差计算。
- **代码片段**：
  ```cpp
  sort(a + 1, a + 1 + n);
  int minn = 1e12, m = n - k;
  for (int i = 1; i <= n - m + 1; i++)
    minn = min(minn, a[i + m - 1] - a[i]);
  ```

### 2. Hughpig（4.5星）
- **亮点**：变量命名清晰，循环条件明确。
- **代码片段**：
  ```cpp
  sort(a+1,a+n+1);
  for(int i=1;i<=k+1;++i){
      ans=min(ans,a[i+n-k-1]-a[i]);
  }
  ```

### 3. Genius_Star（4星）
- **亮点**：公式推导清晰，数学表达直观。
- **关键公式**：
  $$ \min_{0 \le i \le k} (A_{n-(k-i)} - A_{i+1}) $$

---

## 最优思路提炼
1. **排序预处理**：对原数组升序排序。
2. **窗口长度固定**：保留 `n-k` 个元素，即窗口长度固定。
3. **线性扫描极差**：窗口右端点 `i + n -k -1` 随左端点 `i` 递增，计算极差并取最小值。

---

## 同类型题推荐
1. [LeetCode 209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
2. [LeetCode 643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)
3. [洛谷 P2218 [HAOI2007] 覆盖问题](https://www.luogu.com.cn/problem/P2218)

---

## 可视化算法演示

### 动画设计
1. **排序过程**：数组元素升序排列动画，用不同颜色区分已排序和未排序部分。
2. **滑动窗口**：
   - **高亮当前窗口**：红色边框标记当前检查的区间 `[i, i+n-k-1]`。
   - **极差计算**：实时显示当前窗口的最大值、最小值及差值。
   - **历史最小值追踪**：绿色标记当前全局最小极差。
3. **复古像素风格**：
   - **8-bit 音效**：窗口滑动时播放 "beep" 音效，找到更小极差时播放上扬音调。
   - **网格绘制**：每个元素用 16x16 像素方块表示，数值以 8-bit 字体显示。

### 交互功能
- **步进控制**：按空格键单步执行窗口滑动。
- **速度调节**：滑动条控制动画速度（1x~10x）。
- **自动演示**：AI 模式自动完成所有窗口检查，最终停在最优解。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2e5+10;
int a[MAXN];

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 0; i < n; ++i) cin >> a[i];
    sort(a, a + n);
    int min_diff = INT_MAX;
    int retain = n - k; // 需要保留的元素个数
    for (int i = 0; i + retain <= n; ++i) {
        min_diff = min(min_diff, a[i + retain - 1] - a[i]);
    }
    cout << min_diff << endl;
    return 0;
}
```

---

## 个人心得摘录
> "删两边的数不会比删中间的数更差，这是贪心的核心。排序后问题立刻变得清晰。" —— 题解作者Big_Dinosaur

---

## 可视化代码片段（Canvas绘制）
```javascript
// 绘制排序后数组
ctx.fillStyle = "#8B0000"; // 暗红色背景
ctx.fillRect(0, 0, canvas.width, canvas.height);

// 绘制数组元素
for (let i = 0; i < n; i++) {
    if (i >= left && i <= right) {
        ctx.fillStyle = "#FFD700"; // 当前窗口金色
    } else {
        ctx.fillStyle = "#00FF00"; // 其他元素绿色
    }
    ctx.fillRect(x, y, 30, 30);
    ctx.fillText(a[i], x+5, y+20);
}
```

---
处理用时：73.01秒
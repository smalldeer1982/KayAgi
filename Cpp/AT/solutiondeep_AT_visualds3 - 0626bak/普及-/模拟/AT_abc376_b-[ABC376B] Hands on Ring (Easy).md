# 题目信息

# [ABC376B] Hands on Ring (Easy)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_b

**注：この問題は F 問題とほぼ同じ設定です。本文中で太字で示されている部分および制約のみが異なります。**

あなたはあるリングを両手で握っています。 このリングは $ N\ (N\geq\ 3) $ 個のパーツ $ 1,2,\dots,N $ によって構成されており、パーツ $ i $ とパーツ $ i+1 $ ($ 1\leq\ i\leq\ N-1 $)、およびパーツ $ 1 $ とパーツ $ N $ がそれぞれ隣接しています。

最初、左手はパーツ $ 1 $ を、右手はパーツ $ 2 $ を握っています。 あなたは、$ 1 $ 回の *操作* で以下のことを行えます。

- 片方の手を、今握っているパーツに隣接するいずれかのパーツに移動する。ただし、移動先にもう一方の手がない場合に限る。

以下の図は、初期状態およびそこから行える操作と行えない操作の例を示したもので、リングの各パーツに書き込まれた数はそのパーツの番号を、L と書かれた丸は左手を、R と書かれた丸は右手を示しています。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc376_b/163f7a1ba782e2030fd80929195629b6c8f8ddb5.png)

あなたは今から与えられる $ Q $ 個の指示に順番に従う必要があります。 $ i\ (1\leq\ i\leq\ Q) $ 個目の指示は文字 $ H_i $ および整数 $ T_i $ によって表され、その意味は以下の通りです：

- 操作を何回か（$ 0 $ 回でもよい）行うことで、$ H_i $ が `L` ならば左手、`R` ならば右手が、パーツ $ T_i $ を握っている状態にする。 このとき、$ H_i $ によって指定された手ではない方の手を **動かしてはならない**。

**なお、達成可能な指示しか与えられないことが保証されます。**

詳細この問題の設定の下では、各 $ i $ について、$ i $ 個目の指示に従う直前でのそれぞれの手の位置が一意に定まることが証明できます。 このとき、左手の位置をパーツ $ l_i $、右手の位置をパーツ $ r_i $ とおくと、$ H_i= $ `L` ならば $ T_i\neq\ r_i $ が、$ H_i= $ `R` ならば $ T_i\neq\ l_i $ がそれぞれ保証されます。   
すべての指示に従うために必要な操作回数の合計の最小値を求めてください。

## 说明/提示

### 制約

- $ 3\leq\ N\ \leq\ 100 $
- $ 1\leq\ Q\ \leq\ 100 $
- $ H_i $ は `L` または `R`
- $ 1\leq\ T_i\leq\ N $
- $ N,Q,T_i $ は整数
- 達成可能な指示しか与えられない（詳細は問題文を参照してください）

### Sample Explanation 1

![](https://img.atcoder.jp/abc376/367efd733280195fad534ad518cca09d.png) 
以下のように操作を行うことで、$ Q $ 個の指示すべてに順番に従うことができます。 1. 右手をパーツ $ 2\rightarrow\ 3\rightarrow\ 4 $ と移動させることで、$ 1 $ 番目の指示に従う。 2. 左手をパーツ $ 1\rightarrow\ 6\rightarrow\ 5 $ と移動させることで、$ 2 $ 番目の指示に従う。 3. 右手をパーツ $ 4\rightarrow\ 3\rightarrow\ 2\rightarrow\ 1\rightarrow\ 6 $ と移動させることで、$ 3 $ 番目の指示に従う。 このとき行う操作回数の合計は $ 2+2+4=8 $ であり、これが最小です。 （$ 3 $ 番目の指示に従う際に右手をパーツ $ 4\rightarrow\ 5\rightarrow\ 6 $ と移動させることはできないことに注意してください。）

### Sample Explanation 2

操作を $ 1 $ 度も行わずに指示に従うことができる場合もあります。

## 样例 #1

### 输入

```
6 3
R 4
L 5
R 6```

### 输出

```
8```

## 样例 #2

### 输入

```
100 2
L 1
R 2```

### 输出

```
0```

## 样例 #3

### 输入

```
30 8
R 23
R 26
R 29
L 20
R 29
R 19
L 7
L 16```

### 输出

```
92```

# AI分析结果



**算法分类选择**  
模拟、环形遍历

---

**题解思路与核心难点**  
本题要求每次移动一只手到指定位置，另一只手固定。关键点在于确定移动方向的最小步数。  
- **核心思路**：对于每个指令，尝试顺时针移动，统计步数并检查是否遇到另一只手。若遇到则选择逆时针路径（步数为 `N - 顺时针步数`）。  
- **解决难点**：利用环形结构的对称性，通过一次顺时针遍历即可判断路径可行性，避免复杂的方向选择。  
- **关键变量**：`lx`（左手位置）、`rx`（右手位置）、`cnt`（顺时针步数）、`f`（标记路径是否合法）。

---

**题解评分**  
⭐️⭐️⭐️⭐️⭐️ (5星)  
- **思路清晰**：直接模拟顺时针路径，逻辑简洁。  
- **代码高效**：时间复杂度为 O(Q·N)，符合数据范围。  
- **实现巧妙**：利用 `f` 标记快速判断路径可行性，避免复杂计算。

---

**最优思路提炼**  
1. **顺时针试探法**：通过顺时针遍历统计步数，并检测路径是否被阻挡。  
2. **环形对称性优化**：若顺时针不可行，逆时针步数为 `N - 顺时针步数`，无需重复遍历。  
3. **状态维护**：移动后立即更新手的位置，保证后续指令的正确处理。

---

**同类型题与算法套路**  
类似环形移动问题可参考以下思路：  
- **环形路径最短距离**：顺时针与逆时针步数之和为环长。  
- **状态模拟**：维护动态变化的位置，逐条处理指令。  
- **碰撞检测**：通过遍历提前判断路径合法性。

---

**推荐练习题**  
1. [CF702B - Circular Barn](https://codeforces.com/problemset/problem/702/B)  
2. [Luogu P1056 排座椅](https://www.luogu.com.cn/problem/P1056)  
3. [LeetCode 2134. Minimum Swaps to Group All 1's II](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-ii/)

---

**代码核心逻辑**  
```cpp
for (int i = 1; i <= q; i++) {
    char h; int xy;
    cin >> h >> xy;
    if (h == 'L') {
        if (xy == lx) continue;
        int cnt = 0, f = 1;
        for (int i = lx; i != xy; i = i%n +1) {
            cnt++;
            if (i == rx) f = 0;
        }
        ans += f ? cnt : n - cnt;
        lx = xy;
    } else {
        // 类似处理右手移动
    }
}
```

---

**可视化设计要点**  
1. **环形动画**：用 Canvas 绘制环形结构，高亮当前手的位置。  
2. **移动路径标记**：顺时针遍历时动态显示移动路径，遇到阻挡时切换方向。  
3. **音效反馈**：  
   - 顺时针合法：轻快音效  
   - 逆时针切换：低沉音效  
4. **复古风格**：  
   - 8-bit 像素风，手的位置用不同颜色方块表示。  
   - 步进控制：支持暂停/继续，观察每一步的移动逻辑。

---

**总结**  
本题通过巧妙的顺时针试探法，结合环形对称性快速确定最短路径。代码简洁高效，适合作为环形移动问题的模板解法。

---
处理用时：109.12秒
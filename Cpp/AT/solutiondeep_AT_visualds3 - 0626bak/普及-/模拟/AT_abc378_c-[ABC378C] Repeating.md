# 题目信息

# [ABC378C] Repeating

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc378/tasks/abc378_c

给定一个长度为 $N$ 的正数序列  $A = (A_1, A_2, \ldots, A_N)$，请找出按照以下定义的长度为 $N$ 的序列 $B = (B_1, B_2, \ldots, B_N)$。

- 对于 $ i = 1, 2, \ldots, N$，给出 $B_i$ 定义如下：
  
  - 与 $A_i$ 相等的元素在 $i$ 之前出现的位置为 $b$。如果不存在这样的位置，则 $B_i = -1$。
  - 更具体地说，如果存在正整数 $j$，使得 $A_i = A_j$ 且 $j<i$ 存在，则 $B_i$ 是所有这样的 $j$ 中的最大值。如果不存在这样的 $j$，则 $B_i = -1$。。

## 说明/提示

### 约定

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 输入均为整数

### 样例解释

- $ i=1$：$A_1=1$ 前没有 $1$ 出现，因此 $B_1=-1$。
- $ i=2 $：$A_1=2$ 前没有 $2$ 出现，因此 $B_2=-1$。
- $ i=1 $：$A_1=1$ 前 $1$ 出现在 $A_1$，因此 $B_3=1$。
- $ i=1 $：$A_1=1$ 前 $1$ 出现在 $A_3$，因此 $B_4=3$。
- $ i=5 $：$A_5=3$ 前没有 $3$ 出现，因此 $B_5=-1$。

## 样例 #1

### 输入

```
5
1 2 1 1 3```

### 输出

```
-1 -1 1 3 -1```

## 样例 #2

### 输入

```
4
1 1000000000 1000000000 1```

### 输出

```
-1 -1 2 1```

# AI分析结果



---

**唯一算法分类**：哈希表（Hash Map）

---

### **题解思路、算法要点与解决难点**

1. **核心思路**：  
   - 每个元素需要快速查询其最后一次出现的位置，若不存在则为-1。  
   - **哈希表**（如 `unordered_map`）用于存储每个元素的最新下标，遍历时动态更新。

2. **算法流程**：  
   - 初始化空哈希表 `last_pos`。  
   - 遍历数组，对每个元素 `A[i]`：  
     - 若 `A[i]` 存在于 `last_pos`，则 `B[i] = last_pos[A[i]]`。  
     - 否则，`B[i] = -1`。  
     - 更新 `last_pos[A[i]] = i`。

3. **解决难点**：  
   - **大值域处理**：`A[i]` 范围高达 $10^9$，数组无法存储，哈希表实现高效查找与更新。  
   - **时间复杂度优化**：使用 `unordered_map` 实现平均 $O(1)$ 的查询和插入，总复杂度 $O(n)$。

---

### **题解评分 (≥4星)**

1. **ikunTLE 题解（5星）**  
   - **亮点**：使用 `unordered_map` 高效处理，代码简洁，可读性强。  
   - **关键代码**：  
     ```cpp
     unordered_map<int, int> mp;
     for (int i = 1; i <= n; ++i) {
         if (mp.find(a[i]) != mp.end()) b[i] = mp[a[i]];
         mp[a[i]] = i;
     }
     ```

2. **Chenyanxi0829 题解（4星）**  
   - **亮点**：代码极简，利用 `map.count()` 直接判断存在性。  
   - **关键代码**：  
     ```cpp
     map<int, int> h;
     cout << (h.count(a) ? h[a] : -1) << ' ';
     h[a] = i;
     ```

3. **hzxphy 题解（4星）**  
   - **亮点**：使用 `unordered_map` 并优化输入输出，适合竞赛环境。  
   - **关键代码**：  
     ```cpp
     unordered_map<int, int> ump;
     if (!ump.count(ai)) printf("-1 ");
     else printf("%d ", ump[ai]);
     ump[ai] = i;
     ```

---

### **最优思路或技巧提炼**

- **哈希表动态更新**：维护每个元素的最后出现位置，查询和更新操作均在 $O(1)$ 平均时间内完成。  
- **输入输出优化**：使用 `ios::sync_with_stdio(false)` 和 `cin.tie(0)` 加速，适合大规模数据。  
- **空间优化**：避免预初始化，直接通过 `map` 的默认行为处理未出现元素。

---

### **同类型题或类似算法套路**

- **通用解法**：哈希表记录元素状态（如最后位置、出现次数等），遍历时动态更新。  
- **类似题目**：  
  - **统计元素频率**（如 LeetCode 347. 前 K 个高频元素）。  
  - **两数之和**（如 LeetCode 1. 两数之和，哈希表存储补数）。

---

### **推荐相似题目**

1. **P1102 A-B数对**：统计差值为定值的元素对，需高效查找。  
2. **P3879 [TJOI2010] 阅读理解**：多模式字符串匹配，需哈希表优化。  
3. **P3370 【模板】字符串哈希**：练习哈希函数设计与应用。

---

### **可视化与算法演示**

**动画设计**：  
1. **数据结构展示**：  
   - 左侧显示数组 `A`，当前元素高亮为蓝色。  
   - 右侧显示哈希表 `last_pos`，键值对动态变化，更新时黄色闪烁。  
2. **操作流程**：  
   - **步骤1**：遍历到 `A[i]`，检查哈希表中是否存在键 `A[i]`。  
   - **步骤2**：若存在，输出对应值并显示绿色连线；否则输出 `-1`（红色）。  
   - **步骤3**：更新哈希表，当前下标 `i` 写入键 `A[i]`。  
3. **复古风格**：  
   - **像素画风**：数组和哈希表用 8-bit 方块表示，更新时播放经典音效。  
   - **音效触发**：查询成功（叮咚声）、更新（咔嗒声）、错误（低鸣声）。  

**交互功能**：  
- **步进控制**：用户可暂停/继续，调整动画速度。  
- **自动演示**：AI 按固定间隔逐步执行，模拟解题过程。

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    unordered_map<int, int> last_pos;
    for (int i = 1; i <= n; ++i) {
        int x;
        cin >> x;
        if (last_pos.count(x)) {
            cout << last_pos[x] << " ";
        } else {
            cout << -1 << " ";
        }
        last_pos[x] = i;
    }
    return 0;
}
```

---

**总结**：哈希表是处理动态查询与更新的利器，尤其在值域大时优势显著。本题通过维护最后出现位置，将时间复杂度优化至线性，是典型的空间换时间策略。

---
处理用时：75.18秒
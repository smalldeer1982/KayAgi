# 题目信息

# [ABC383B] Humidifier 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc383/tasks/abc383_b

AtCoder社のオフィスは $ H $ 行 $ W $ 列のマス目で表されます。上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表します。

各マスの状態は文字 $ S_{i,j} $ で表され、 $ S_{i,j} $ が `#` のときそのマスは机、`.` のときそのマスは床です。床のマスは $ 2 $ つ以上存在することが保証されます。

あなたは床のマスから異なる $ 2 $ マスを選び、加湿器を設置します。

加湿器が設置されたとき、あるマス $ (i,j) $ は加湿器があるマス $ (i',j') $ からのマンハッタン距離が $ D $ 以下であるとき、またその時に限り加湿されます。 なお、マス $ (i,j) $ からマス $ (i',j') $ までのマンハッタン距離は $ |i-i'|+|j-j'| $ で表されます。 ここで、加湿器が置かれた床のマスは必ず加湿されていることに注意してください。

加湿される **床のマス** の個数として考えられる最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ H\ \leq\ 10 $
- $ 1\ \leq\ W\ \leq\ 10 $
- $ 2\ \leq\ H\ \times\ W $
- $ 0\ \leq\ D\ \leq\ H+W-2 $
- $ H,W,D $ は整数
- $ S_{i,j} $ は `#` または `.` である $ (1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W) $
- 床のマスは $ 2 $ つ以上存在する
 
### Sample Explanation 1

マス $ (1,1) $ とマス $ (1,5) $ に加湿器を置いた時: - マス $ (1,1) $ の加湿器によってマス $ (1,1),(2,1) $ の $ 2 $ マスが加湿されます。 - マス $ (1,5) $ の加湿器によってマス $ (1,5) $ の $ 1 $ マスが加湿されます。 よって、合計 $ 3 $ マス加湿されています。また、$ 4 $ マス以上加湿するような加湿器の置き方は存在しないため、答えは $ 3 $ です。

### Sample Explanation 2

マス $ (2,4) $ とマス $ (5,3) $ に加湿器を置いた時、$ 15 $ 個の床のマスが加湿されます。

## 样例 #1

### 输入

```
2 5 1

.###.

.#.##```

### 输出

```
3```

## 样例 #2

### 输入

```
5 5 2

.#.#.

.....

.#.#.

#.#.#

.....```

### 输出

```
15```

## 样例 #3

### 输入

```
4 4 2

....

.##.

.##.

....```

### 输出

```
10```

# AI分析结果



## 算法分类
**暴力枚举**

## 题解思路与核心难点分析

### 题目核心逻辑
在 H×W 的网格中，选择两个不同的地板格子放置加湿器，使得曼哈顿距离 ≤ D 的地板总数最大。**关键点**在于如何高效计算每对加湿器位置的覆盖区域并去重。

### 题解对比与核心实现
1. **题解一（Ray_yi）**  
   - **错误点**：使用局部数组标记覆盖区域，导致无法正确合并两个加湿器的覆盖结果（重叠部分重复计数）。  
   - **代码缺陷**：`f` 函数的 `t` 数组为局部变量，无法保留前一次调用的标记状态，导致统计错误。

2. **题解二（JCT_addyi）**  
   - **正确思路**：全局标记数组 `b` 记录每个格子是否被覆盖。对每对加湿器位置，遍历所有格子，若满足任一加湿器的覆盖条件则标记为 1。  
   - **优化点**：通过四层循环枚举所有可能的加湿器对，时间复杂度为 O(H²W² × HW)，数据范围允许下可行。  
   - **实现细节**：每次枚举后重置标记数组 `b`，确保独立计算每对加湿器的覆盖区域。

3. **题解三（Jayfeather2012）**  
   - **最优解**：直接遍历所有地板格子，判断是否被任一加湿器覆盖。无需额外标记数组，直接统计总数。  
   - **代码亮点**：三重循环嵌套（枚举加湿器对 + 遍历所有格子），逻辑清晰，代码简洁。时间复杂度为 O(H³W³)，但 H、W≤10，完全可行。

### 解决难点
- **去重处理**：确保同一地板被多个加湿器覆盖时只计数一次。题解二和三均通过逻辑判断或全局标记正确实现。  
- **暴力枚举可行性**：数据范围极小（H,W≤10），暴力枚举所有可能的加湿器对不会超时。

---

## 题解评分与推荐

### 评分 ≥4 星的题解
1. **题解三（Jayfeather2012）** ⭐⭐⭐⭐⭐  
   - **优点**：代码简洁，逻辑清晰，直接判断覆盖条件，无冗余数据结构。  
   - **核心代码**：
     ```cpp
     for (int i=1; i<=n; ++i)
         for (int j=1; j<=m; ++j) {
             if (a[i][j] == '#') continue;
             for (int k=1; k<=n; ++k)
                 for (int l=1; l<=m; ++l) {
                     if (a[k][l] == '#' || (k==i && l==j)) continue;
                     int s = 0;
                     for (int x=1; x<=n; ++x)
                         for (int y=1; y<=m; ++y)
                             if (a[x][y] != '#' && (sum(i,j,x,y)<=d || sum(k,l,x,y)<=d))
                                 s++;
                     ans = max(ans, s);
                 }
         }
     ```

2. **题解二（JCT_addyi）** ⭐⭐⭐⭐  
   - **优点**：通过全局标记数组确保正确去重，思路明确。  
   - **优化空间**：可省略标记数组，直接判断覆盖条件（同题解三）。

---

## 最优思路提炼
**核心技巧**：暴力枚举所有可能的加湿器对，直接遍历每个地板格子，判断是否被任一加湿器覆盖。  
**实现步骤**：
1. 枚举所有可能的加湿器对 `(i,j)` 和 `(k,l)`。  
2. 对每个地板格子 `(x,y)`，若满足 `距离(i,j,x,y) ≤ D` 或 `距离(k,l,x,y) ≤ D`，则计数。  
3. 取所有计数中的最大值。

---

## 类似题目推荐
1. **洛谷 P1217**：暴力生成回文数并判断是否为质数。  
2. **洛谷 P1036**：枚举子集求和是否为素数。  
3. **洛谷 P1149**：暴力枚举火柴棒组合，验证等式成立。

---

## 可视化与算法演示设计

### 动画方案
- **网格绘制**：用 Canvas 绘制 H×W 网格，区分桌子（`#`）和地板（`.`）。  
- **颜色标记**：  
  - **加湿器位置**：红色方块。  
  - **覆盖区域**：半透明蓝色覆盖层，动态更新。  
- **步进控制**：逐帧展示每对加湿器的覆盖区域，高亮当前最优解。  
- **音效提示**：找到更大解时播放上扬音效，错误时短促提示。

### 复古像素风格
- **8位调色板**：使用经典 FC 游戏的 16 色方案（如红、蓝、绿）。  
- **像素动画**：加湿器覆盖区域用闪烁的像素块表示，模拟经典游戏特效。  
- **自动演示**：按枚举顺序自动切换加湿器对，显示覆盖区域和当前最大值。

---

**示例代码（题解三核心逻辑）**
```cpp
int main() {
    // ... 输入处理 ...
    for (int i=1; i<=H; ++i)
        for (int j=1; j<=W; ++j) {
            if (grid[i][j] == '#') continue;
            for (int k=1; k<=H; ++k)
                for (int l=1; l<=W; ++l) {
                    if (grid[k][l] == '#' || (i==k && j==l)) continue;
                    int cnt = 0;
                    for (int x=1; x<=H; ++x)
                        for (int y=1; y<=W; ++y) {
                            if (grid[x][y] == '#') continue;
                            if (abs(x-i) + abs(y-j) <= D || abs(x-k) + abs(y-l) <= D)
                                cnt++;
                        }
                    ans = max(ans, cnt);
                }
        }
    cout << ans;
}
```

---
处理用时：170.99秒
# 题目信息

# [ABC403C] 403 Forbidden

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc403/tasks/abc403_c

WAtCoder 有 $N$ 个用户，编号从 $1$ 到 $N$。还有 $M$ 个比赛页面，编号从 $1$ 到 $M$。初始时，所有用户都没有任何比赛页面的访问权限。

现在需要依次处理 $Q$ 个查询。查询共有三种类型，格式如下：

- `1 X Y`：授予用户 $X$ 访问比赛页面 $Y$ 的权限。
- `2 X`：授予用户 $X$ 访问所有比赛页面的权限。
- `3 X Y`：查询用户 $X$ 是否可以访问比赛页面 $Y$。

注意：在查询过程中，可能会多次授予某个用户已经拥有的权限。

## 说明/提示

### 约束条件

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq M \leq 2 \times 10^5$
- $1 \leq Q \leq 2 \times 10^5$
- $1 \leq X \leq N$
- $1 \leq Y \leq M$
- 输入中的所有值均为整数

### 样例解释 #1

- 第一个查询授予用户 $1$ 访问比赛页面 $2$ 的权限。
- 第二个查询时，用户 $1$ 只能访问比赛页面 $2$，因此查询页面 $1$ 时输出 `No`。
- 第三个查询时，用户 $1$ 可以访问比赛页面 $2$，因此输出 `Yes`。
- 第四个查询授予用户 $2$ 访问所有比赛页面的权限。
- 第五个查询时，用户 $2$ 可以访问所有页面（$1,2,3$），因此查询页面 $3$ 时输出 `Yes`。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2 3 5
1 1 2
3 1 1
3 1 2
2 2
3 2 3```

### 输出

```
No
Yes
Yes```

## 样例 #2

### 输入

```
5 5 10
2 2
3 4 4
1 1 1
1 4 1
1 4 2
1 4 4
1 2 4
3 3 2
3 5 4
3 2 1```

### 输出

```
No
No
No
Yes```

# AI分析结果



**算法分类**  
无算法分类（模拟与数据结构应用）

---

**题解思路与解决难点**  
题目要求高效处理三种权限操作，核心在于快速判断用户是否拥有特定或全局权限。  
- **关键数据结构**：每个用户维护一个集合（如 `set`/`unordered_set`）记录单独授权的页面，以及一个布尔数组标记全局权限。  
- **操作优化**：  
  - 操作一（单独授权）时，若用户已有全局权限则跳过插入，节省时间和空间。  
  - 操作二（全局授权）仅标记布尔值，避免遍历或清空集合，保证 O(1) 时间。  
  - 查询时优先检查全局权限，避免不必要的集合查询。  
- **难点**：全局权限与单独权限的优先级处理，需确保查询逻辑正确且时间复杂度可控。

---

**题解评分（≥4星）**  
1. **作者：floris**（4星）  
   - **亮点**：使用 `set` 维护单独权限，操作二仅标记布尔值，代码简洁。  
   - **优化**：查询时优先检查全局权限，逻辑清晰。  
   - **不足**：未在操作一检查全局权限，导致冗余插入。  

2. **作者：chu_yh**（4星）  
   - **亮点**：利用 `set` 自动去重特性，操作一插入时自动处理重复。  
   - **优化**：查询时直接调用 `count` 方法，逻辑直观。  
   - **不足**：`set` 的查询时间为 O(log K)，可能影响大数据性能。  

3. **作者：zyn0309**（4星）  
   - **亮点**：使用 `map` 数组维护单独权限，操作二仅标记布尔值。  
   - **优化**：代码简洁，无冗余操作。  
   - **不足**：`map` 查询时间为 O(log K)，性能略逊于哈希结构。  

---

**最优思路提炼**  
1. **数据结构选择**：使用 `unordered_set` 或哈希结构，实现 O(1) 平均时间的插入和查询。  
2. **操作优化**：  
   - 操作一仅当用户无全局权限时插入，避免冗余。  
   - 操作二仅设置布尔标记，保证 O(1) 时间。  
3. **查询逻辑**：优先检查全局权限，减少集合查询次数。

---

**同类型题与算法套路**  
- **通用解法**：状态标记 + 高效集合查询（如全局标记优先）。  
- **类似题目**：权限管理、多条件查询问题，如用户角色权限检查、动态黑白名单等。

---

**推荐题目**  
1. [P3380 【模板】二逼平衡树](https://www.luogu.com.cn/problem/P3380)（多操作集合查询）  
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)（单点更新与区间查询）  
3. [P1903 [国家集训队] 数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903)（动态集合维护与查询）  

---

**可视化与算法演示**  
**核心逻辑动画设计**：  
- **数据结构展示**：  
  - 左侧为全局权限标记面板（布尔数组），右侧为每个用户的单独授权集合（哈希桶）。  
- **操作高亮**：  
  - 操作一：用户未被全局标记时，目标页面高亮插入集合。  
  - 操作二：用户标记变红，表示拥有全局权限。  
  - 查询：先检查红色标记，若存在则直接输出 `Yes`；否则遍历哈希桶查找目标页面。  
- **交互控制**：支持暂停/继续、单步执行，速度调节观察哈希冲突处理。  

**复古像素风格**：  
- **Canvas 绘制**：用户和页面以网格表示，全局标记为红色方块，单独授权为绿色像素点。  
- **音效**：插入时播放短促“滴”声，全局授权时播放上升音调，查询 `Yes` 时播放胜利音效。  

---

**代码实现（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
unordered_set<int> s[N];
bool all[N];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, m, q;
    cin >> n >> m >> q;
    while (q--) {
        int op, x, y;
        cin >> op >> x;
        if (op == 1) {
            cin >> y;
            if (!all[x]) s[x].insert(y); // 仅未全局授权时插入
        } else if (op == 2) {
            all[x] = true; // 仅标记，不清空集合
        } else {
            cin >> y;
            cout << (all[x] || s[x].count(y) ? "Yes\n" : "No\n");
        }
    }
    return 0;
}
```  
**核心思想**：通过哈希集合和布尔数组的组合，保证所有操作在平均 O(1) 时间内完成，兼顾效率与正确性。

---
处理用时：319.01秒
# 题目信息

# [ABC371C] Make Isomorphic

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_c

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる単純無向グラフ $ G,H $ が与えられます。 $ G $ には $ M\ _\ G $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ G) $ の辺は頂点 $ u\ _\ i $ と頂点 $ v\ _\ i $ を結んでいます。 $ H $ には $ M\ _\ H $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ H) $ の辺は頂点 $ a\ _\ i $ と頂点 $ b\ _\ i $ を結んでいます。

あなたは、グラフ $ H $ に対して次の操作を $ 0 $ 回以上の好きな回数繰り返すことができます。

- $ 1\leq\ i\lt\ j\leq\ N $ を満たす整数の組 $ (i,j) $ をひとつ選ぶ。$ A\ _\ {i,j} $ 円を支払って、頂点 $ i $ と頂点 $ j $ を結ぶ辺がなければ追加し、あれば取り除く。

$ G $ と $ H $ を同型にするために少なくとも何円支払う必要があるか求めてください。

単純無向グラフとは？ **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

グラフの同型とは？ $ N $ 頂点のグラフ $ G $ と $ H $ が**同型**であるとは、ある $ (1,2,\ldots,N) $ の並べ替え $ (P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が存在して、どの $ 1\leq\ i\lt\ j\leq\ N $ に対しても

- $ G $ に頂点 $ i, $ 頂点 $ j $ を結ぶ辺が存在するとき、かつそのときに限り $ H $ に頂点 $ P\ _\ i, $ 頂点 $ P\ _\ j $ を結ぶ辺が存在する

が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq8 $
- $ 0\leq\ M\ _\ G\leq\dfrac{N(N-1)}2 $
- $ 0\leq\ M\ _\ H\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ G) $
- $ (u\ _\ i,v\ _\ i)\neq(u\ _\ j,v\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ G) $
- $ 1\leq\ a\ _\ i\lt\ b\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ H) $
- $ (a\ _\ i,b\ _\ i)\neq(a\ _\ j,b\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ H) $
- $ 1\leq\ A\ _\ {i,j}\leq\ 10\ ^\ 6\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

与えられたグラフはそれぞれ以下のようになります。 !\[\](https://img.atcoder.jp/abc371/fbdb304dc71eecd7ddec97276a9c7040.png) たとえば、$ H $ に対して次のような $ 4 $ つの操作を順に行うことで、$ 9 $ 円を支払って$ G $ と $ H $ を同型にすることができます。 - $ (i,j)=(1,3) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(2,5) $ として操作を行う。$ H $ には頂点 $ 2 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 2 $ 円を支払ってこれを追加する。 - $ (i,j)=(1,5) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 5 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(3,5) $ として操作を行う。$ H $ には頂点 $ 3 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 5 $ 円を支払ってこれを追加する。 操作の結果、$ H $ は以下のようになります。 !\[\](https://img.atcoder.jp/abc371/68a56da8ec89b769989ae7d07bf163cd.png) 支払う金額を $ 8 $ 円以下にして $ G $ と $ H $ を同型にすることはできないため、`9` を出力してください。

### Sample Explanation 2

たとえば、$ (i,j)=(2,3),(2,4),(3,4) $ とした $ 3 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 3

たとえば、$ (i,j)=(4,5) $ とした $ 1 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 4

$ G $ や $ H $ には辺が含まれていないこともあります。 また、一度も操作をする必要がないこともあります。

## 样例 #1

### 输入

```
5
4
1 2
2 3
3 4
4 5
4
1 2
1 3
1 4
1 5
3 1 4 1
5 9 2
6 5
3```

### 输出

```
9```

## 样例 #2

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
9 1 1 1
1 1 1
1 1
9```

### 输出

```
3```

## 样例 #3

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
5 4 4 4
4 4 4
4 4
5```

### 输出

```
5```

## 样例 #4

### 输入

```
2
0
0
371```

### 输出

```
0```

## 样例 #5

### 输入

```
8
13
1 8
5 7
4 6
1 5
7 8
1 6
1 2
5 8
2 6
5 6
6 7
3 7
4 8
15
3 5
1 7
4 6
3 8
7 8
1 2
5 6
1 6
1 5
1 4
2 8
2 6
2 4
4 7
1 3
7483 1694 5868 3296 9723 5299 4326
5195 4088 5871 1384 2491 6562
1149 6326 2996 9845 7557
4041 7720 1554 5060
8329 8541 3530
4652 3874
3748```

### 输出

```
21214```

# AI分析结果



## 算法分类：其他搜索

### 题解思路与算法要点
题目要求通过调整图H的边使其与图G同构，找到最小费用。核心思路是枚举所有可能的顶点排列，计算每个排列下调整边结构的费用。关键点包括：
1. **全排列枚举**：由于N≤8，可暴力枚举所有顶点排列。
2. **邻接矩阵比较**：对于每个排列，比较G的边与H在排列后的边存在性差异。
3. **费用计算**：差异边的费用需基于原H中的顶点编号，而非排列后的编号。

#### 解决难点
- **正确映射费用**：调整的边费用对应原H中的顶点对，而非排列后的顶点对。
- **邻接矩阵对称性**：无向图的邻接矩阵需对称处理，确保比较时i-j和j-i等价。

### 题解评分（≥4星）
1. **fengzhaoyu的题解（4星）**
   - **亮点**：正确处理费用计算，将排列后的顶点映射到原H的顶点对，费用计算正确。
   - **代码**：使用排列后的顶点对应原H的顶点，取min/max避免重复计算，费用累加正确。
2. **Clover_Lin的题解（4星）**
   - **亮点**：通过排列后的顶点映射到原H的顶点对，正确计算费用。
   - **代码**：通过id数组保存排列后的顶点对应关系，正确调用费用数组。
3. **Hacker_Cracker的题解（4星）**
   - **亮点**：利用next_permutation生成排列，费用计算基于原H顶点编号，代码简洁正确。

### 最优思路与技巧提炼
- **费用映射**：排列p中G的顶点i对应H的顶点p[i]，费用应为A[p[i]][p[j]]。
- **邻接矩阵优化**：直接比较G的边与H的对应边存在性，无需重建邻接矩阵。

### 同类型题与算法套路
- **全排列暴力**：适用于小规模问题，如八皇后、数独等。
- **图同构问题**：通过顶点排列比较边结构，如LeetCode 205. 同构字符串的图扩展。

### 推荐洛谷题目
1. **P1706**：全排列问题，练习排列生成。
2. **P1219**：八皇后问题，DFS枚举与剪枝。
3. **P1036**：选数问题，组合枚举与条件判断。

### 个人心得摘录
- **调试踩坑**：费用计算需严格对应原H顶点，避免误用排列后顶点编号。
- **顿悟**：图同构的边比较应在排列后的顶点与原顶点之间进行，而非直接覆盖邻接矩阵。

### 可视化与算法演示
- **动画设计**：
  - **节点映射**：左侧为G的顶点，右侧动态显示排列后对应的H顶点。
  - **边比较**：高亮差异边，实时显示费用累加。
  - **费用计算**：差异边以原H顶点对标注费用，颜色区分添加/删除操作。
- **复古像素风**：
  - **8位风格**：节点以像素块表示，边调整时播放经典音效。
  - **自动演示**：按排列顺序自动遍历，显示当前最小费用及对应排列。

---

### 核心代码示例（fengzhaoyu的题解）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n, mg, mh;
int g[10][10], h[10][10], a[10][10];
int id[10], ans = 1e9+7;

int main() {
    cin >> n >> mg;
    for (int i = 1; i <= mg; i++) {
        int x, y; cin >> x >> y;
        g[x][y] = g[y][x] = 1;
    }
    cin >> mh;
    for (int i = 1; i <= mh; i++) {
        int x, y; cin >> x >> y;
        h[x][y] = h[y][x] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = i+1; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 1; i <= n; i++) id[i] = i;
    do {
        int res = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = i+1; j <= n; j++) {
                int x = min(id[i], id[j]);
                int y = max(id[i], id[j]);
                if (h[x][y] != g[i][j]) {
                    res += a[x][y];
                }
            }
        }
        ans = min(ans, res);
    } while (next_permutation(id+1, id+n+1));
    cout << ans << endl;
    return 0;
}
```

**代码解释**：
- 使用`id`数组保存排列后的顶点对应关系。
- 遍历所有边对，比较G的边与H中对应原顶点的边存在性。
- 费用累加基于原H顶点的费用数组`a[x][y]`，确保正确性。

---
处理用时：259.84秒
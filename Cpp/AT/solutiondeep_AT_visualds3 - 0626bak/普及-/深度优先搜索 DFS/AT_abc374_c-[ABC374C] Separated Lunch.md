# 题目信息

# [ABC374C] Separated Lunch

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_c

キーエンス本社に勤務する人数が増えてきたので、本社に存在する部署を $ 2 $ つのグループに分け、昼休みの時間帯を分けることにしました。

キーエンス本社には $ N $ 個の部署が存在し、$ i $ 番目 $ (1\leq\ i\leq\ N) $ の部署に所属する人数は $ K_i $ 人です。

それぞれの部署をグループ $ A $, $ B $ のいずれか一方に割り当て、グループごとに同時に昼休みをとり、 かつグループ $ A $, $ B $ の昼休みの時間が重ならないようにしたとき、同時に昼休みをとる最大人数としてあり得る最小の値を求めてください。  
 すなわち、グループ $ A $ に割り当てられた部署に所属する人数の合計とグループ $ B $ に割り当てられた部署に所属する人数の合計 のうち大きい方の値としてあり得る最小の値を求めてください。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 20 $
- $ 1\leq\ K_i\ \leq\ 10^8 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1,2,5 $ 番目の部署をグループ $ A $ に、$ 3,4 $ 番目の部署をグループ $ B $ に割り当てたとき、 グループ $ A $ に割り当てられた部署に所属する人数の合計は $ 2+3+12=17 $ 、 グループ $ B $ に割り当てられた部署に所属する人数の合計は $ 5+10=15 $ となり、 このとき同時に昼休みを取る最大人数は $ 17 $ となります。 一方で、グループ $ A,B $ それぞれに割り当てられた部署に所属する人数の合計がいずれも $ 16 $ 以下になるように 部署を割り当てることはできないため、$ 17 $ を出力します。

### Sample Explanation 2

同一人数の部署が複数存在する可能性もあります。

### Sample Explanation 3

例えば、$ 1,4,5 $ 番目の部署をグループ $ A $ に、$ 2,3,6 $ 番目の部署をグループ $ B $ に割り当てたとき同時に昼休みを取る最大人数は $ 89 $ となります。

## 样例 #1

### 输入

```
5

2 3 5 10 12```

### 输出

```
17```

## 样例 #2

### 输入

```
2

1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
6

22 25 26 45 22 31```

### 输出

```
89```

# AI分析结果



# 算法分类  
**DFS**

---

## 综合分析与结论  
**核心思路**：  
将 N 个部门划分为两组，求两组人数较大者的最小值。由于 N ≤ 20，直接暴力枚举所有可能分组，时间复杂度为 O(2^N)，完全可行。

**解决难点**：  
- **状态表示**：每个部门有两种选择（A 组或 B 组）。  
- **剪枝优化**：若当前分组最大值已超过已知最小值，提前终止分支。  
- **高效计算**：记录一个组的总和，另一组通过总和减去当前和快速计算。

**可视化设计**：  
- **节点选择动画**：以树状结构展示每个部门的分支选择（加入 A/B 组），用颜色区分已选/未选状态。  
- **回溯过程**：通过像素风格箭头表示递归返回，触发复古音效。  
- **最优解标记**：最终答案对应的分组路径用闪烁高亮显示。  
- **游戏化元素**：8-bit 音效（分支选择时播放短促音符，找到更优解时播放胜利音效），背景为网格化部门列表。

---

## 题解清单（4星及以上）

### 1. 作者：A_R_O_N_A（4星）  
**亮点**：  
- 使用状态压缩枚举所有可能分组，代码简洁易懂。  
- 预处理总和，避免重复计算。  
```cpp
for (int i=0; i<(1<<n); i++) {
    int sum = 0;
    for (int j=0; j<n; j++) 
        if (i & (1<<j)) sum += a[j];
    ans = min(ans, max(sum, total - sum));
}
```

### 2. 作者：fishing_cat（4星）  
**亮点**：  
- DFS 递归实现，逻辑清晰。  
- 参数仅记录当前组总和，另一组通过总和差值计算。  
```cpp
void dfs(int id, ll now) {
    if (id > n) {
        ans = min(ans, max(now, sum - now));
        return;
    }
    dfs(id+1, now + k[id]); // 选入当前组
    dfs(id+1, now);         // 不选入当前组
}
```

### 3. 作者：lucasincyber（4星）  
**亮点**：  
- 剪枝优化：若当前最大值已超过已知最优值，提前返回。  
```cpp
if (max(sumA, sumB) >= ans) return; // 剪枝
dfs(u+1, sumA + k[u], sumB);
dfs(u+1, sumA, sumB + k[u]);
```

---

## 最优思路与技巧  
1. **总和差值计算**：预处理总和后，只需跟踪一个组的和，另一组通过 `总和 - 当前和` 快速获得。  
2. **剪枝策略**：当当前分支的较大值已超过已知最小值时，提前终止该分支。  
3. **二进制枚举优化**：状态压缩法利用位运算快速生成所有子集。  

---

## 同类型题与算法套路  
- **子集和问题**：如分割等和子集（LeetCode 416）。  
- **分组优化**：如 P2392（kkksc03考前临时抱佛脚）。  
- **状态压缩枚举**：适用于 N ≤ 20 的暴力场景。  

---

## 推荐题目  
1. **P2392**：分组时间分配，DFS 剪枝。  
2. **P1441**：砝码组合，状态压缩枚举。  
3. **P2320**：礼物分组，动态规划或暴力。  

---

## 个人心得摘录  
- **调试教训**：总和溢出需用 `long long`（如 Zhengyi0402 的代码注释）。  
- **优化顿悟**：剪枝可显著减少递归深度（lucasincyber 的剪枝判断）。  

---

## 可视化核心代码（DFS 动画片段）  
```javascript
// 伪代码：递归步骤可视化
function dfs(step, sumA, sumB) {
    if (step > N) {
        updateMinAns(sumA, sumB); // 更新答案并高亮
        return;
    }
    highlightDepartment(step, "A"); // 标记当前部门加入 A 组
    dfs(step+1, sumA + k[step], sumB);
    unhighlightDepartment(step);
    
    highlightDepartment(step, "B"); // 标记加入 B 组
    dfs(step+1, sumA, sumB + k[step]);
    unhighlightDepartment(step);
}
```

---

## 复古游戏化设计  
- **像素风格**：部门用 8x8 像素块表示，选中时变为绿色（A 组）或红色（B 组）。  
- **音效设计**：  
  - 分支选择：8-bit "beep" 音效（不同音高对应 A/B 组）。  
  - 找到更优解：经典 FC 过关音效。  
- **自动演示模式**：按 BFS 顺序自动遍历所有可能分组，速度可调。  
- **积分系统**：每找到一个更优解得 10 分，最终根据分数生成评级（S/A/B/C）。  

--- 

**关键思维**：暴力枚举在数据量小时是最直接有效的策略，合理剪枝能进一步提升效率。

---
处理用时：91.16秒
# 题目信息

# [ABC345C] One Time Swap

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc345/tasks/abc345_c

文字列 $ S $ が与えられます。次の操作を **ちょうど $ 1 $ 回** 行った後の文字列としてあり得るものがいくつあるか求めてください。

- $ S $ の長さを $ N $ とする。 $ 1\leq\ i\ <\ j\leq\ N $ をみたす整数の組 $ (i,j) $ を選び、$ S $ の $ i $ 文字目と $ j $ 文字目を入れ替える。

なお、この問題の制約下で操作を必ず行うことができることが証明できます。

## 说明/提示

### 制約

- $ S $ は英小文字からなる長さ $ 2 $ 以上 $ 10^6 $ 以下の文字列

### Sample Explanation 1

$ S $ の長さは $ 3 $ であるため、$ 1\leq\ i\ <\ j\leq\ 3 $ をみたす整数の組 $ (i,j) $ としては、 $ (1,2) $, $ (1,3) $, $ (2,3) $ の $ 3 $ 通りが考えられます。 - $ S $ の $ 1 $ 文字目と $ 2 $ 文字目を入れ替えた時、$ S $ は `bac` となります。 - $ S $ の $ 1 $ 文字目と $ 3 $ 文字目を入れ替えた時、$ S $ は `cba` となります。 - $ S $ の $ 2 $ 文字目と $ 3 $ 文字目を入れ替えた時、$ S $ は `acb` となります。 よって、`abc` に対して操作を行った後の文字列としては、`bac`, `cba`, `acb` の $ 3 $ つがあり得るため、$ 3 $ を出力します。

### Sample Explanation 2

どの $ 2 $ つの文字を入れ替えても $ S $ は `aaaaa` のままです。よって、操作後の文字列としてあり得るものは $ 1 $ つです。

## 样例 #1

### 输入

```
abc```

### 输出

```
3```

## 样例 #2

### 输入

```
aaaaa```

### 输出

```
1```

# AI分析结果



---

**唯一算法分类**: 计数与组合数学

### 综合分析与结论

**题目核心逻辑**：统计所有交换两个不同字符产生的不同字符串数量，并考虑交换相同字符是否会产生原串的额外情况。

**解决难点**：
1. 避免 O(n²) 暴力枚举，转而通过字符频率统计快速计算有效交换对数量。
2. 处理交换相同字符时的特殊情况（只能算一次原串）。

**核心算法流程**：
1. 遍历字符串，维护字符出现次数的计数器。
2. 对于每个字符，计算其与前面所有不同字符的交换次数（贡献）。
3. 最终答案 = 不同字符交换次数之和 + 存在重复字符的标记（0或1）。

**可视化设计**：
- **像素动画**：用不同颜色方块表示字符，遍历时高亮当前字符并显示其贡献。
- **音效提示**：统计不同交换时播放清脆音效，发现重复字符时播放提示音。
- **自动演示**：逐字符展示贡献计算过程，右侧面板实时显示总答案和重复标记。

---

### 题解评分（≥4星）

1. **作者：_KHIN**（★★★★★）  
   **亮点**：  
   - 使用前缀和思想，实时维护每个字符的前方不同字符数量。  
   - 代码简洁高效（O(n) 时间），逻辑清晰易懂。  
   - 通过 `cnt[]` 数组直接统计贡献，避免复杂数学推导。  

2. **作者：Link_Cut_Y**（★★★★☆）  
   **亮点**：  
   - 公式推导明确，直接计算组合数差异。  
   - 代码简洁，利用桶统计快速计算无效交换对。  

3. **作者：SiriusIV**（★★★★☆）  
   **亮点**：  
   - 使用前缀和数组避免重复计算，空间换时间。  
   - 通过 `i - tong[]` 直接得出贡献，逻辑直观。  

---

### 最优思路提炼

**关键步骤**：
1. **贡献计算**：对于每个字符 s[i]，其能产生的不同交换次数为 `i - cnt[s[i]]`，其中 `cnt[s[i]]` 是前面相同字符的数量。
2. **重复标记**：遍历时记录是否存在某个字符出现 ≥2 次，最终答案额外 +1。

**代码片段**：
```cpp
string s;
int cnt[26] = {0}, ans = 0, flag = 0;
cin >> s;
for (int i = 0; i < s.size(); i++) {
    ans += i - cnt[s[i] - 'a']; // 当前字符的贡献
    cnt[s[i] - 'a']++;
    if (cnt[s[i] - 'a'] > 1) flag = 1;
}
cout << ans + flag;
```

---

### 同类型题与算法套路

**通用解法**：  
- **字符频率统计**：适用于需要快速计算组合数或排列数的字符串问题。  
- **前缀贡献累加**：通过遍历时动态维护计数器，避免重复计算。  

**相似题目**：  
1. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)（字符频率统计优化搜索）  
2. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)（前缀匹配与计数）  
3. [P3405 省份数量](https://www.luogu.com.cn/problem/P3405)（组合数学与并查集）  

---

### 复古游戏化动画实现（伪代码）

```javascript
// Canvas 初始化
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
const chars = ['a','b','c']; // 示例字符
let ans = 0, cnt = [0,0,0], flag = 0;

function drawChar(index, color) {
    ctx.fillStyle = color;
    ctx.fillRect(index * 30, 50, 25, 25); // 绘制字符方块
}

function animateStep(i) {
    // 高亮当前字符
    drawChar(i, '#FF5555');
    // 计算贡献
    ans += i - cnt[chars[i]];
    // 更新计数器
    cnt[chars[i]]++;
    // 判断重复字符
    if (cnt[chars[i]] > 1) flag = 1;
    // 播放音效
    playSound('blip');
    // 更新右侧面板显示
    updatePanel(ans, flag);
}

// 自动演示循环
for (let i = 0; i < chars.length; i++) {
    setTimeout(() => animateStep(i), i * 1000);
}
```

**交互设计**：  
- **8位音效**：使用 `Web Audio API` 生成方波音效，每次计算贡献时触发。  
- **像素风格**：字符用 25x25 像素方块表示，颜色区分不同字符。  
- **控制面板**：显示当前答案和重复标记，支持暂停/继续按钮。  

---

通过上述分析与设计，学习者可深入理解如何高效统计字符交换对，并通过可视化交互强化算法思维。

---
处理用时：75.07秒
# 题目信息

# [ABC286D] Money in Hand

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc286/tasks/abc286_d

高橋君は $ N $ 種類の硬貨をそれぞれ何枚か持っており、 具体的には、$ 1\leq\ i\leq\ N $ について $ A_i $ 円硬貨を $ B_i $ 枚持っています。

高橋君が現在持っている硬貨を用いて、（お釣りが出ないように）ちょうど $ X $ 円を支払うことができるか判定してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 50 $
- $ 1\leq\ X\leq\ 10^4 $
- $ 1\leq\ A_i\leq\ 100 $
- $ 1\leq\ B_i\leq\ 50 $
- $ A_i $ はすべて異なる。
- 入力はすべて整数
 
### Sample Explanation 1

高橋君は $ 2 $ 円硬貨を $ 3 $ 枚、$ 5 $ 円硬貨を $ 6 $ 枚持っています。 このうち、$ 2 $ 円硬貨を $ 2 $ 枚、$ 5 $ 円硬貨を $ 3 $ 枚用いることでちょうど $ 2\times\ 2+5\times\ 3=19 $ 円を支払うことができます。 よって、`Yes` を出力します。

### Sample Explanation 2

持っている硬貨をどのように組み合わせてもちょうど $ 18 $ 円を支払うことはできません。 よって、`No` を出力します。

### Sample Explanation 3

$ 1 $ 枚も使用しない硬貨が存在しても構いません。

## 样例 #1

### 输入

```
2 19

2 3

5 6```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 18

2 3

5 6```

### 输出

```
No```

## 样例 #3

### 输入

```
3 1001

1 1

2 1

100 10```

### 输出

```
Yes```

# AI分析结果



## 唯一算法分类
动态规划（多重背包问题）

## 综合分析与结论
### 核心思路
题目要求判断能否用给定数量的不同面值硬币恰好凑出目标金额X。各题解均采用动态规划思想，核心区别在于空间优化方式：

1. **二维DP**：显式维护前i种硬币的状态，逻辑直观但空间效率低
2. **一维优化**：倒序遍历金额避免状态覆盖，将空间复杂度从O(NX)优化至O(X)
3. **二进制拆分**：理论上更优的时间复杂度，但实际未在代码中体现

### 难点对比
- **二维DP**需处理三重循环，容易理解但实现稍显冗余
- **一维优化**的关键在于倒序更新逻辑，需深入理解背包问题状态转移特性
- **错误解法**混淆了"最大容量"与"精确容量"的DP定义，导致逻辑错误

### 可视化设计
1. **动画方案**：展示一维DP数组从0到X的填充过程，每次硬币处理时：
   - 高亮当前硬币面值（如红色边框）
   - 用绿色渐变动画标记被更新的金额格子
   - 失败时用红色闪烁提示目标X格子

2. **复古像素风格**：
   - 硬币用8x8像素块表示，不同面值对应不同颜色
   - DP数组显示为横向像素条，初始全黑，激活时亮蓝
   - 背景音乐使用芯片音乐风格，每次更新播放短促音效

## 题解清单（≥4星）
### 1. yemuzhe（5星）
**亮点**：完美的一维空间优化，代码简洁高效，时间复杂度O(XΣB_i)
```cpp
int f[M] = {1}; // 初始化仅f[0]=1
for (int i =m; i >=a; i--) 
    f[i] |= f[i-a]; // 关键状态转移
```

### 2. Neil_Qian（5星）
**亮点**：强调倒序循环的重要性，代码极致精简
```cpp
while(b--)for(int j=x;j>=a;j--)
    dp[j] |= dp[j-a]; // 每枚硬币独立处理
```

### 3. 12345678hzx（4星）
**亮点**：三重循环直白实现，适合初学者理解
```cpp
for(int j=1;j<=b[i];j++)
    if(k>=j*a[i]) 
        f[k]|=f[k-j*a[i]];
```

## 最优技巧提炼
**倒序滚动更新**：处理多重背包时，对每个硬币的数量进行B_i次0-1背包式处理，通过倒序遍历金额避免重复计数。该技巧将空间复杂度优化至O(X)，且保持时间复杂度为O(NB_iX)。

## 同类题目推荐
1. P1776 宝物筛选（多重背包模板题）
2. P1064 金明的预算方案（带依赖的多重背包）
3. P2347 砝码称重（恰好组合的变种）

## 可视化代码片段（像素动画）
```javascript
// Canvas初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const colors = ['#000','#f00','#0f0','#00f']; // 黑、红、绿、蓝

function drawDPState(currentCoin, dpArray) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // 绘制当前处理的硬币
    ctx.fillStyle = colors[1];
    ctx.fillRect(10, 10, 16, 16); 
    // 绘制DP数组
    dpArray.forEach((val, idx) => {
        ctx.fillStyle = val ? colors[3] : colors[0];
        ctx.fillRect(30 + idx*8, 10, 6, 6);
    });
    // 高亮目标X
    ctx.strokeStyle = colors[2];
    ctx.strokeRect(30 + targetX*8, 10, 6, 6);
}
```

## 核心实现代码
```cpp
#include <cstdio>
#define MAX 10001
bool dp[MAX] = {true}; // 仅dp[0]初始化为true

int main() {
    int n, x, a, b;
    scanf("%d%d", &n, &x);
    while(n--) {
        scanf("%d%d", &a, &b);
        while(b--) 
            for(int i = x; i >= a; i--)
                if(dp[i - a]) 
                    dp[i] = true;
    }
    puts(dp[x] ? "Yes" : "No");
}
```

---
处理用时：156.27秒
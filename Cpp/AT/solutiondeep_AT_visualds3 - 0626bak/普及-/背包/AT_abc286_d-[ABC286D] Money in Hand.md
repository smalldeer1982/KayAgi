# 题目信息

# [ABC286D] Money in Hand

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc286/tasks/abc286_d

高橋君は $ N $ 種類の硬貨をそれぞれ何枚か持っており、 具体的には、$ 1\leq\ i\leq\ N $ について $ A_i $ 円硬貨を $ B_i $ 枚持っています。

高橋君が現在持っている硬貨を用いて、（お釣りが出ないように）ちょうど $ X $ 円を支払うことができるか判定してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 50 $
- $ 1\leq\ X\leq\ 10^4 $
- $ 1\leq\ A_i\leq\ 100 $
- $ 1\leq\ B_i\leq\ 50 $
- $ A_i $ はすべて異なる。
- 入力はすべて整数
 
### Sample Explanation 1

高橋君は $ 2 $ 円硬貨を $ 3 $ 枚、$ 5 $ 円硬貨を $ 6 $ 枚持っています。 このうち、$ 2 $ 円硬貨を $ 2 $ 枚、$ 5 $ 円硬貨を $ 3 $ 枚用いることでちょうど $ 2\times\ 2+5\times\ 3=19 $ 円を支払うことができます。 よって、`Yes` を出力します。

### Sample Explanation 2

持っている硬貨をどのように組み合わせてもちょうど $ 18 $ 円を支払うことはできません。 よって、`No` を出力します。

### Sample Explanation 3

$ 1 $ 枚も使用しない硬貨が存在しても構いません。

## 样例 #1

### 输入

```
2 19

2 3

5 6```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 18

2 3

5 6```

### 输出

```
No```

## 样例 #3

### 输入

```
3 1001

1 1

2 1

100 10```

### 输出

```
Yes```

# AI分析结果



**唯一算法分类**：动态规划/多重背包

---

### **综合分析与结论**

**核心思路**  
题目本质是多重背包问题，要求判断能否用给定数量的不同面值硬币恰好凑出目标金额 X。动态规划是核心解法，通过状态转移记录能否凑出各金额。

**核心难点**  
1. **数量限制处理**：每个硬币有严格的数量上限，需确保算法不会超限使用。
2. **时间复杂度优化**：直接暴力枚举可能超时，需采用背包问题的经典优化手段。

**解决方案**  
- **一维动态规划优化**：通过倒序枚举金额，将二维状态压缩至一维，减少空间复杂度。
- **多重背包拆分**：将每个硬币的多次使用拆分为多次循环，每次处理一个硬币，利用倒序更新避免重复计数。

**可视化设计思路**  
1. **动态数组更新动画**：展示一维数组 `dp` 的更新过程，高亮当前处理的硬币面值和对应的金额变化。
2. **像素风格与音效**：采用 8-bit 像素风格，硬币面值用不同颜色块表示，金额进度条显示当前处理位置。音效在状态更新和成功匹配时触发。
3. **交互控制**：支持暂停、步进、速度调节，便于观察每一步的状态变化。

---

### **题解清单 (≥4星)**

1. **作者：yemuzhe (5星)**  
   - **亮点**：一维数组优化，代码简洁高效，时间复杂度 O(XΣB_i)，空间 O(X)。
   - **关键代码**：倒序循环金额，逐个硬币处理其数量限制。
   ```cpp
   while (b--) 
     for (int i = m; i >= a; i--) 
       f[i] |= f[i - a];
   ```

2. **作者：Neil_Qian (5星)**  
   - **亮点**：明确二进制优化思路（虽未实现），代码清晰，强调倒序枚举避免重复。
   ```cpp
   while(b--)for(int j=x;j>=a;j--)dp[j]|=dp[j-a];
   ```

3. **作者：Allen_123__ (4星)**  
   - **亮点**：二维数组直观展示状态转移，适合理解多重背包原始思路。
   ```cpp
   if (k >= a[i] * j && dp[i-1][k - a[i]*j]) 
     dp[i][k] = 1;
   ```

---

### **最优思路提炼**

**关键技巧**  
- **一维数组倒序更新**：处理每个硬币时，从后向前更新金额，避免重复使用。
- **多重背包拆分**：将每个硬币的 B_i 次使用拆分为 B_i 次单独处理，每次仅用一枚。

**代码实现核心**  
```cpp
bool dp[MAX_X] = {1}; // 初始化dp[0]=true
for (每种硬币面值a，数量b) {
  while (b--) // 拆分处理每个硬币
    for (int j = X; j >= a; j--)
      dp[j] |= dp[j - a];
}
```

---

### **同类型题推荐**

1. **洛谷 P1048 [NOIP2005 普及组] 采药**  
   - 经典01背包问题，适合练习基础动态规划。

2. **洛谷 P1776 宝物筛选**  
   - 多重背包问题，需结合二进制优化。

3. **洛谷 P1833 樱花**  
   - 混合背包（01、完全、多重），适合综合训练。

---

### **可视化算法演示**

**动画设计**  
- **像素化界面**：硬币显示为不同颜色的 8-bit 图标，金额条以网格展示。
- **高亮当前操作**：处理硬币时，其图标闪烁；更新的金额格子变色。
- **音效反馈**：成功更新时播放“叮”声，最终成功时播放胜利音乐。

**交互功能**  
- **步进控制**：手动点击或自动播放，速度可调。
- **状态跟踪**：实时显示当前硬币处理进度和已更新的金额。

**示例代码片段（伪代码）**  
```javascript
// 在Canvas绘制dp数组更新
function updateDP(a, b) {
  for (let cnt = 0; cnt < b; cnt++) {
    for (let j = X; j >= a; j--) {
      if (dp[j - a]) dp[j] = true;
      drawGrid(j); // 更新对应格子的颜色
      playSound('click'); // 触发音效
    }
  }
}
```

---

**总结**：本题通过多重背包的动态规划解法，结合一维数组优化，高效解决硬币组合问题。可视化重点在于动态展示状态数组的更新过程与硬币处理逻辑。

---
处理用时：222.47秒
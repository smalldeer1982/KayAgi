# 题目信息

# [ABC284D] Happy New Year 2023

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc284/tasks/abc284_d

正整数 $ N $ が与えられます。$ N $ は、$ 2 $ つの相異なる素数 $ p,q $ を用いて $ N=p^2q $ と表せることがわかっています。

$ p,q $ を求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\leq\ T\leq\ 10 $
- $ 1\leq\ N\ \leq\ 9\times\ 10^{18} $
- $ N $ は、$ 2 $ つの相異なる素数 $ p,q $ を用いて $ N=p^2q $ と表せる
 
### Sample Explanation 1

$ 1 $ 番目のテストケースについて、$ N=2023=17^2\times\ 7 $ です。よって、$ p=17,q=7 $ です。

## 样例 #1

### 输入

```
3

2023

63

1059872604593911```

### 输出

```
17 7

3 7

104149 97711```

# AI分析结果



# 算法分类  
**数学（质因数分解）**

---

## 综合分析与结论  
### 核心思路  
所有题解均基于以下数学性质：在 N=p²q 的分解中，min(p,q) ≤ ∛N。通过枚举可能的质因数，找到第一个能整除 N 的数 i，再根据以下两种情况进行判断：  
1. 若 i² 能整除 N → p=i，q=N/(i²)  
2. 若 i 能整除 N → q=i，p=√(N/i)（需验证 p 是整数且为质数）

### 解决难点  
1. **快速确定枚举范围**：利用三次方根性质将枚举范围降至 O(∛N)  
2. **避免质数判断**：题目保证解存在，找到第一个能整除的 i 即可直接判断，无需额外验证 i 是否为质数  
3. **处理大数运算**：使用 long long 类型存储，防止溢出  

### 算法流程  
1. 枚举 i 从 2 开始递增  
2. 当 i 能整除 N 时：  
   - 检查 i² 是否整除 N → 是则输出 p=i，q=N/(i²)  
   - 否则计算 sqrt(N/i) → 验证是否为整数，输出 p=sqrt(N/i)，q=i  

---

## 题解评分 (≥4星)  
1. **CarroT1212（5星）**  
   - 代码简洁（仅 16 行核心逻辑）  
   - 直接暴力枚举最小因子，无需预处理  
   - 时间复杂度 O(T∛N)，完全满足题目限制  

2. **Hell0_W0rld（4星）**  
   - 明确推导数学性质 min(p,q)≤∛N  
   - 代码清晰，包含特判偶数优化  
   - 时间复杂度与最优解法一致  

3. **Esperance（4星）**  
   - 强调 sqrt 精度处理（存储到变量避免 double 误差）  
   - 代码简洁且包含关键注释  

---

## 最优思路提炼  
**关键技巧**：  
1. **最小因数优先枚举**：利用第一个能整除的 i 必为质数（由题目保证解唯一性）  
2. **免质数验证**：题目保证解存在，直接利用分解性质无需检查 i 是否为质数  
3. **平方根快速计算**：用整数运算替代浮点 sqrt 避免精度问题  

**代码实现核心**：  
```cpp
for (ll i = 2;; i++) {
    if (n % i == 0) {
        ll rem = n / i;
        if (rem % i == 0) {      // i 是 p
            cout << i << " " << rem/i;
        } else {                 // i 是 q
            ll p = sqrt(rem);
            cout << p << " " << i;
        }
        break;
    }
}
```

---

## 相似题目推荐  
1. **P1075 [NOIP2012 普及组] 质因数分解**  
   （同样寻找最小质因数分解）  
2. **P1069 [NOIP2009 普及组] 细胞分裂**  
   （质因数分解与指数匹配）  
3. **P3912 素数判定**  
   （大数质因数分解的优化判断）  

---

## 可视化设计  
### 动画方案  
1. **像素风格演示**：  
   - **枚举过程**：以 8-bit 风格显示 i 从 2 开始递增，当前检测的 i 高亮为黄色  
   - **命中检测**：当 i 能整除 N 时，触发爆炸特效，i 变为红色  
   - **分解显示**：右侧面板动态显示 p 和 q 的计算结果，用绿色像素块表示  

2. **交互功能**：  
   - **步进控制**：允许暂停/继续/单步执行  
   - **速度调节**：滑动条控制枚举速度（1x~100x）  
   - **音效**：命中时播放 8-bit "胜利"音效，错误时播放低沉音  

### 关键代码片段（Canvas 绘制）  
```javascript
function drawStep(i, found) {
  ctx.clearRect(0, 0, width, height);
  // 绘制当前 i
  ctx.fillStyle = found ? '#FF0000' : '#FFFF00';
  drawPixel(i % 20 * 16, Math.floor(i / 20) * 16); 
  // 绘制 p 和 q
  if (found) {
    ctx.fillStyle = '#00FF00';
    drawPixel(p % 10 * 16, 100 + (p % 10) * 16);
    drawPixel(q % 10 * 16, 150 + (q % 10) * 16);
  }
}
```

---

## 个人心得摘录  
> "直接暴力枚举反而更有效，因为题目保证解存在且唯一，实际测试中最小因子往往很快出现" —— CarroT1212  
> "sqrt 返回 double 类型直接输出会 WA，必须先转 long long" —— Esperance  

---

## 完整代码（CarroT1212 解法）  
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

void solve() {
    ll n;
    scanf("%lld", &n);
    for (ll i = 2;; i++) {
        if (n % i == 0) {
            ll rem = n / i;
            if (rem % i == 0) {
                printf("%lld %lld\n", i, rem / i);
            } else {
                ll p = sqrt(rem);
                printf("%lld %lld\n", p, i);
            }
            return;
        }
    }
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) solve();
    return 0;
}
```

---
处理用时：77.83秒
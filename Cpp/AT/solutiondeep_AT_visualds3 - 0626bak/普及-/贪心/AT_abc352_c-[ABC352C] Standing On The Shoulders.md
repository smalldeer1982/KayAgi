# 题目信息

# [ABC352C] Standing On The Shoulders

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc352/tasks/abc352_c

$ N $ 人の巨人がいます。巨人にはそれぞれ $ 1,\ 2,\ \ldots,\ N $ の名前がついており、巨人 $ i $ が地面に立ったとき、肩の高さは $ A_i $、頭の高さは $ B_i $ となります。

あなたは $ (1,\ 2,\ \ldots,\ N) $ を並べ替えて得られる数列 $ (P_1,\ P_2,\ \ldots,\ P_N) $ を選び、以下の規則に従って $ N $ 人の巨人を積み上げることができます。

- まず地面に巨人 $ P_1 $ を立たせる。巨人 $ P_1 $ の肩は地面を基準として $ A_{P_1} $、頭は地面を基準として $ B_{P_1} $ の高さとなる。
- $ i\ =\ 1,\ 2,\ \ldots,\ N\ -\ 1 $ の順に巨人 $ P_i $ の肩の上に巨人 $ P_{i\ +\ 1} $ を立たせる。巨人 $ P_i $ の肩が地面を基準として高さ $ t $ のとき、巨人 $ P_{i\ +\ 1} $ の肩は地面を基準として $ t\ +\ A_{P_{i\ +\ 1}} $、頭は地面を基準として $ t\ +\ B_{P_{i\ +\ 1}} $ の高さとなる。
 
一番上に立っている巨人、すなわち巨人 $ P_N $ の地面を基準とした頭の高さとして実現できる最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ B_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (P_1,\ P_2,\ P_3)\ =\ (2,\ 1,\ 3) $ とすると、地面を基準として巨人 $ 2 $ は肩の高さが $ 5 $、頭の高さが $ 8 $、巨人 $ 1 $ は肩の高さが $ 9 $、頭の高さが $ 15 $、巨人 $ 3 $ は肩の高さが $ 11 $、頭の高さが $ 18 $ となります。 一番上に立っている巨人の頭の高さが地面を基準として $ 18 $ より大きくなることはないため $ 18 $ を出力します。

## 样例 #1

### 输入

```
3

4 10

5 8

2 9```

### 输出

```
18```

## 样例 #2

### 输入

```
5

1 1

1 1

1 1

1 1

1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
10

690830957 868532399

741145463 930111470

612846445 948344128

540375785 925723427

723092548 925021315

928915367 973970164

563314352 832796216

562681294 868338948

923012648 954764623

691107436 891127278```

### 输出

```
7362669937```

# AI分析结果



# ABC352C 题解分析

## 唯一算法分类
贪心算法

---

## 综合分析与结论

### 核心思路
题目要求最大化叠罗汉后顶端巨人的头高。关键发现：
1. 所有巨人的肩高总和是固定值（∑A_i）
2. 顶端巨人对高度的额外贡献是其头肩差（B_i - A_i）
3. 只需找出最大的头肩差即可得到最优解

### 算法流程
1. 遍历所有巨人，累计肩高总和
2. 同时记录最大的头肩差值
3. 最终答案为肩高总和 + 最大头肩差

### 解决难点
突破点在于发现顶端位置的特殊性。不同题解中存在的排序操作（如按头肩差排序）是不必要的，因为直接遍历即可找到最大值。

### 可视化设计
1. **动画方案**：用柱状图展示每个巨人的A_i和B_i，累加肩高时用动态进度条显示。遍历时高亮当前巨人的头肩差，并实时更新最大值标记。
2. **颜色标记**：最大头肩差的巨人用红色高亮，肩高总和用绿色进度条填充。
3. **步进控制**：允许单步执行查看每个巨人的计算过程，可调节速度观察累加过程。
4. **复古风格**：使用8-bit像素风格绘制巨人，叠加时播放经典FC音效，找到最大值时触发"升级"音效。

---

## 题解清单（≥4星）

### 1. Dream_Mr_li（5星）
- **亮点**：最早提出肩高总和与头差最大值的关系，代码简洁高效
- **核心代码**：
```cpp
ans += a; // 累加肩高
mx = max(mx, b-a); // 记录最大头差
```

### 2. spfa_（4.5星）
- **亮点**：明确公式推导sum - a[i] + b[i]，数学表达清晰
- **关键推导**：
```cpp
max(ans, sum - a[i] + b[i]) // 等价于 sum + (b[i]-a[i])
```

### 3. Xzf110618（4星）
- **亮点**：代码极简（仅7行），变量命名直观
- **代码片段**：
```cpp
maxx = max(maxx, b[i]-a[i]);
cout << sum+maxx;
```

---

## 核心代码实现

### 标准解法
```cpp
#include <iostream>
using namespace std;

int main() {
    long long n, sum = 0, max_diff = 0;
    cin >> n;
    while (n--) {
        long long a, b;
        cin >> a >> b;
        sum += a;
        max_diff = max(max_diff, b - a);
    }
    cout << sum + max_diff;
    return 0;
}
```

### 可视化片段（JS伪代码）
```javascript
// 绘制像素风格巨人
function drawPixelGiant(a, b, isMax) {
    ctx.fillStyle = isMax ? '#FF0000' : '#888888'; 
    drawRect(x, 100 - a, 20, a); // 肩高
    drawRect(x, 100 - b, 20, b - a); // 头差
}

// 找到最大值时播放音效
if (currentDiff > maxDiff) {
    playSound('powerup.wav');
    maxDiff = currentDiff;
}
```

---

## 同类型题目推荐

1. **P1223 排队接水** - 贪心选择处理时间最短者
2. **P1803 线段覆盖** - 选择最早结束的线段
3. **P1094 纪念品分组** - 双指针选择最优配对

---

## 个人心得摘录

> "警钟敲烂：不开 long long 见祖宗！！" —— Dream_Mr_li  
> 数据范围2e5且数值1e9，必须用long long避免溢出。

> "十年OI一场空，不开long long见祖宗" —— cyx012113  
> 多次强调数值类型选择的重要性。

---

## 复古游戏化设计

1. **视觉风格**：16色FC调色板，巨人用不同色块表示肩高（深绿）和头差（黄色）
2. **音效设计**：
   - 累加肩高：8-bit "blip" 音效
   - 刷新最大值：超级马里奥吃金币音效
   - 最终结果：最终幻想胜利旋律
3. **自动演示**：AI自动以0.5秒/步的速度遍历巨人，关键步骤暂停1秒
4. **积分系统**：正确找到最大值+100分，错误排序-50分

通过将算法过程转化为复古游戏体验，使学习者更直观地理解贪心选择过程。

---
处理用时：77.18秒
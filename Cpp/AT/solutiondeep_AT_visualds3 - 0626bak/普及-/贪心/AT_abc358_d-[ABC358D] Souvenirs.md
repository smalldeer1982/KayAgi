# 题目信息

# [ABC358D] Souvenirs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc358/tasks/abc358_d

AtCoder Land のお土産屋に $ N $ 個の箱が売られています。

箱には $ 1,\ 2,\ \ldots,\ N $ の番号が付いており、箱 $ i $ の価格は $ A_i $ 円であり、$ A_i $ 個のお菓子が入っています。

高橋君は $ N $ 個の箱のうち $ M $ 個の箱を選んで買って帰り、$ 1,\ 2,\ \ldots,\ M $ の名前が付いた $ M $ 人の人に $ 1 $ つずつ箱を渡そうとしています。

ただし、高橋君は以下の条件を満たすことができるように箱を買いたいです。

- 各 $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、人 $ i $ には $ B_i $ 個以上のお菓子が入った箱を渡す
 
$ 1 $ 人に $ 2 $ 個以上の箱を渡すことや同じ箱を複数人に渡すことはできないことに注意してください。

適切に箱を $ M $ 個買うことで条件を満たすことができるか判定し、条件を満たすことができる場合は高橋君が支払う金額の合計の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^9 $
- 入力される値はすべて整数
 
### Sample Explanation 1

高橋君は箱 $ 1,\ 4 $ を買い、箱 $ 1 $ を人 $ 1 $、箱 $ 4 $ を人 $ 2 $ に渡すことで条件を満たすことができます。 このとき高橋君が支払う金額の合計は $ 7 $ 円であり、支払う金額が $ 7 $ 円未満のときは条件を満たすことはできないため、$ 7 $ を出力します。

## 样例 #1

### 输入

```
4 2

3 4 5 4

1 4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3

1 1 1

1000000000 1000000000 1000000000```

### 输出

```
-1```

## 样例 #3

### 输入

```
7 3

2 6 8 9 5 1 11

3 5 7```

### 输出

```
19```

# AI分析结果



## 算法分类
贪心算法、双指针法

---

## 题解思路与解决难点

### 核心思路
1. **排序优化**：将盒子糖果数 `A` 和需求糖果数 `B` 分别排序，便于贪心匹配。
2. **双指针匹配**：利用排序后的单调性，用双指针逐个为每个 `B[i]` 找到最小的满足条件的 `A[j]`，确保每个盒子仅用一次。

### 解决难点
- **贪心正确性**：排序后，对于每个递增的 `B[i]`，其对应的 `A[j]` 只需从上次找到的位置继续向后搜索，无需回溯，确保全局最优。
- **高效匹配**：利用双指针的线性遍历，将时间复杂度优化至 `O(n + m)`，配合排序总复杂度为 `O(n log n + m log m)`。

---

## 题解评分（≥4星）

### 1. wei2013（5星）
- **思路**：双指针法直接匹配，代码简洁高效。
- **亮点**：时间复杂度低，逻辑清晰。

### 2. stripe_python（5星）
- **思路**：使用 `multiset` 动态维护可用盒子，灵活处理删除。
- **亮点**：适用于动态数据场景，代码易维护。

### 3. Xuan_qwq（5星）
- **思路**：双指针法，代码简洁易读。
- **亮点**：无额外数据结构依赖，适合快速实现。

---

## 最优思路提炼
1. **排序预处理**：将 `A` 和 `B` 排序，保证单调性。
2. **双指针贪心匹配**：维护两个指针 `i`（遍历 `B`）和 `j`（遍历 `A`），每次找到最小的 `A[j] ≥ B[i]`。
3. **错误处理**：若 `j` 越界则无解。

```cpp
sort(A, A + n);
sort(B, B + m);
int j = 0;
long long ans = 0;
for (int i = 0; i < m; i++) {
    while (j < n && A[j] < B[i]) j++;
    if (j >= n) return -1; // 无解
    ans += A[j++];
}
```

---

## 类似题目推荐
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：贪心+优先队列。
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)：排序优化等待时间。
3. [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)：活动选择问题，贪心排序。

---

## 可视化与算法演示

### 动画设计
- **排序过程**：展示 `A` 和 `B` 数组的排序动画。
- **双指针匹配**：
  - 高亮当前 `B[i]` 和扫描的 `A[j]`。
  - 指针 `j` 向右移动直到找到 `A[j] ≥ B[i]`，标记选中并累加总价。
- **错误提示**：当 `j` 越界时，显示红色警示。

### 复古像素风格
- **颜色方案**：8位色，绿色表示匹配成功，红色表示错误。
- **音效**：选中时播放“哔”声，错误时播放低音。

---

## 代码实现（双指针法）
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin >> n >> m;
    vector<int> A(n), B(m);
    for (auto &x : A) cin >> x;
    for (auto &x : B) cin >> x;
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());
    
    long long ans = 0;
    int j = 0;
    for (int i = 0; i < m; i++) {
        while (j < n && A[j] < B[i]) j++;
        if (j >= n) {
            cout << -1 << endl;
            return 0;
        }
        ans += A[j++];
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：79.49秒
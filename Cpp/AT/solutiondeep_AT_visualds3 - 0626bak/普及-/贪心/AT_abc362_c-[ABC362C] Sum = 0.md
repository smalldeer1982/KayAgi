# 题目信息

# [ABC362C] Sum = 0

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc362/tasks/abc362_c

$ N $ 個の整数の組 $ (L_1,R_1),(L_2,R_2),\ldots,(L_N,R_N) $ が与えられます。

以下の条件を満たす長さ $ N $ の整数列 $ X=(X_1,X_2,\ldots,X_N) $ が存在するか判定し、存在するならば一つ出力してください。

- 各 $ i=1,2,\ldots,N $ に対して $ L_i\leq\ X_i\leq\ R_i $
- $ \displaystyle\ \sum_{i=1}^N\ X_i=0 $

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 2\times\ 10^5 $
- $ -10^9\leq\ L_i\leq\ R_i\leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

数列 $ X=(4,-3,-1) $ は問題の条件をすべて満たします。ほかにも $ (3,-3,0) $ や $ (5,-4,-1) $ などが条件を満たします。

### Sample Explanation 2

条件を満たす整数列 $ X $ は存在しません。

## 样例 #1

### 输入

```
3

3 5

-4 1

-2 3```

### 输出

```
Yes

4 -3 -1```

## 样例 #2

### 输入

```
3

1 2

1 2

1 2```

### 输出

```
No```

## 样例 #3

### 输入

```
6

-87 12

-60 -54

2 38

-76 6

87 96

-17 38```

### 输出

```
Yes

-66 -57 31 -6 89 9```

# AI分析结果



### **唯一算法分类**  
**贪心算法**

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
1. **可行性判断**：计算所有区间下界之和（sumL）和上界之和（sumR）。若 sumL > 0 或 sumR < 0，则无解。  
2. **贪心调整**：  
   - **正向调整**：从所有元素取下界 L_i，逐步增加至 R_i 直到总和为 0。  
   - **逆向调整**：从所有元素取上界 R_i，逐步减少至 L_i 直到总和为 0。  

**关键难点**：  
1. 如何高效调整元素值，确保在 O(n) 时间内完成。  
2. 避免调整过程中总和溢出或无法收敛到 0。  

**实现要点**：  
- 贪心调整时优先处理能最大程度影响总和的区间。  
- 维护动态总和变量（如 `cur` 或 `sumr`），每次调整尽可能大的步长。  

---

### **题解评分 (≥4星)**  
1. **作者：_wsq_（4.5星）**  
   - **亮点**：代码简洁，逆向调整逻辑清晰，O(n) 时间复杂度。  
   - **代码片段**：  
     ```cpp  
     for(ll i=1;i<=n;i++){  
         cout<<r[i]-min(r[i]-l[i],sumr)<<' ';  
         sumr-=min(r[i]-l[i],sumr);  
     }  
     ```  
2. **作者：Meickol（4星）**  
   - **亮点**：正向调整逻辑，维护 `lsum` 动态减少，代码易理解。  
   - **代码片段**：  
     ```cpp  
     LL lsum = -pl;  
     rep(i,1,n){  
         LL p = min(lsum, R[i]-L[i]);  
         cout << L[i] + p << ' ';  
         lsum -= p;  
     }  
     ```  
3. **作者：luobotianle（4星）**  
   - **亮点**：直接取 L_i 后逐步上调，逻辑与代码均简洁。  
   - **代码片段**：  
     ```cpp  
     for(int i=1;i<=n;i++){  
         ll d = min(-sum, r[i]-l[i]);  
         sum += d;  
         cout << l[i]+d << " ";  
     }  
     ```  

---

### **最优思路或技巧提炼**  
**核心技巧**：  
1. **逆向贪心调整**：从所有元素取最大值 R_i，总和为 sumR。若 sumR ≥ 0，逐步减少每个元素的取值，每次减去 `min(R_i-L_i, sumr)`，直到总和为 0。  
2. **时间复杂度**：O(n)，仅需一次遍历。  
3. **数学验证**：调整后总和必为 0，且每个元素在 [L_i, R_i] 内。  

**数学推导**：  
- 初始总和 sumR ≥ 0，每次调整使总和减少 `min(R_i-L_i, sumr)`。  
- 最终总和递减至 0，且每次调整不会超过区间允许的范围。  

---

### **同类型题或类似算法套路**  
**类似问题**：  
- **区间覆盖问题**：选择区间内的值，使得总和满足特定条件。  
- **资源分配问题**：在多个限制条件下分配资源，使总和符合目标。  

**通用解法**：  
1. **贪心调整**：从极值（最大或最小）开始，逐步逼近目标。  
2. **前缀和优化**：利用动态维护的总和减少重复计算。  

---

### **推荐洛谷题目**  
1. **P1255 数楼梯**（贪心构造数列）  
2. **P1007 绕钉子的长绳子**（区间选择与总和约束）  
3. **P1094 纪念品分组**（双指针贪心调整）  

---

### **个人心得摘录**  
- **踩坑教训**：未考虑总和溢出情况（如 `sumL` 和 `sumR` 的边界判断）。  
- **调试经验**：需验证每一步调整后的元素是否在区间内。  
- **顿悟感想**：贪心调整方向（正向或逆向）不影响最终结果，但代码实现复杂度不同。  

---

### **可视化与算法演示**  
**动画方案设计**：  
1. **初始化阶段**：  
   - 绘制所有区间 [L_i, R_i] 的条形图，初始取 R_i（红色高亮）。  
   - 显示当前总和 `sumr`（如 9 → 0）。  
2. **调整阶段**：  
   - **高亮当前元素**：标记正在调整的区间为黄色。  
   - **动态减少值**：从 R_i 减少到 `R_i - min(R_i-L_i, sumr)`，显示调整后的值（绿色）。  
   - **更新总和**：实时显示 `sumr` 递减过程（如 9 → 6 → 3 → 0）。  
3. **完成状态**：  
   - 所有区间变为绿色，播放成功音效（8-bit 上扬音调）。  

**复古像素风格**：  
- **颜色方案**：红色（初始值）、黄色（当前调整）、绿色（最终值）。  
- **音效触发**：  
  - 每次调整播放“滴”声（Web Audio API）。  
  - 成功时播放经典 FC 过关音效。  

**交互设计**：  
- **步进控制**：允许用户点击“下一步”或自动播放（速度可调）。  
- **状态面板**：显示当前总和、已调整元素数量。  

---

**核心代码片段（JavaScript 伪代码）**：  
```javascript  
// 初始化总和和元素  
let sumr = sumR;  
for (let i = 0; i < n; i++) {  
    // 高亮当前元素  
    highlight(i, 'yellow');  
    // 计算减少量  
    const delta = Math.min(r[i] - l[i], sumr);  
    // 更新元素值和总和  
    updateValue(i, r[i] - delta);  
    sumr -= delta;  
    // 播放音效  
    playBeep();  
    // 暂停等待用户操作或自动下一步  
    await step();  
}  
// 成功动画  
playSuccessSound();  
```

---
处理用时：80.77秒
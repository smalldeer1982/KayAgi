# 题目信息

# [ABC376C] Prepare Another Box

## 题目描述

有 $N$ 个玩具，编号从 $1$ 到 $N$ ，以及 $N-1$个箱子，编号从 $1$ 到 $N-1$。玩具 $i$ 的大小为$A_i$，箱子 $i$ 的大小为$B_i$。高桥君想把所有玩具分别放入不同的箱子中。他计划按以下步骤操作：

- 选择任意正整数 $x$，购买一个大小为 $x$ 的箱子。

- 将 $N$ 个玩具分别放入 $N$ 个箱子（包括原有的箱子和新购买的箱子）中，但每个玩具只能放入大小不小于该玩具的箱子，且每个箱子只能放一个玩具。

高桥君想通过购买合适大小的箱子来完成第 $2$ 步，但箱子越大价格越高，因此他想尽可能购买小箱子。请判断是否存在能满足条件的 $x$ 值，如果存在，请输出最小值；如果不存在，请输出 $-1$。

## 样例 #1

### 输入

```
4

5 2 3 7

6 2 8```

### 输出

```
3```

## 样例 #2

### 输入

```
4

3 7 2 5

8 1 6```

### 输出

```
-1```

## 样例 #3

### 输入

```
8

2 28 17 39 57 56 37 32

34 27 73 28 76 61 27```

### 输出

```
37```

# AI分析结果



## 算法分类
贪心算法

---

## 综合分析与结论

### 核心思路
题目要求将N个玩具放入N个箱子（其中1个需购买），每个玩具大小必须≤对应箱子。核心思路如下：
1. **贪心策略**：将玩具和原箱子均降序排列，优先让大玩具匹配大箱子。
2. **关键点**：当某玩具无法放入当前最大箱子时，必须购买一个至少等于该玩具大小的新箱子。此时检查剩余玩具能否全部放入剩余的箱子。
3. **正确性**：若当前玩具无法匹配，后续所有玩具必须能匹配剩余箱子（已排序，剩余箱子足够小）。

### 难点与解决
- **如何确定购买时机**：降序排列后，第一个无法匹配的位置即为需购买箱子的位置。
- **验证剩余匹配**：购买后，后续玩具必须依次匹配原箱子的剩余部分（索引连续，无需重新排序）。

### 可视化设计
1. **动画流程**：
   - 玩具和箱子降序排列为两列。
   - 指针逐个比较，无法匹配时高亮当前玩具，生成新箱子。
   - 后续玩具与剩余箱子逐个匹配，若全部通过则成功，否则失败。
2. **颜色标记**：
   - 当前比较的玩具和箱子用红色高亮。
   - 新购买的箱子用闪烁金色显示。
   - 匹配成功/失败时播放对应音效。

---

## 题解评分（≥4星）

### 1. huangrenheluogu（5星）
- **亮点**：逻辑清晰，代码简洁，时间复杂度O(n log n)。
- **核心代码**：
  ```cpp
  sort(a, a+n, greater<>());
  sort(b, b+n-1, greater<>());
  for(int i=0; i<n; i++){
      if(a[i] > b[i]){
          ans = a[i];
          for(int j=i+1; j<n; j++){
              if(a[j] > b[j-1]) return -1;
          }
          return ans;
      }
  }
  ```

### 2. MLE_Automaton（4星）
- **亮点**：二分答案变体，通过索引调整避免显式插入箱子。
- **核心逻辑**：二分a数组下标，假设购买a[mid]，检查其余元素能否匹配：
  ```cpp
  bool check(int mid){
      for(int i=1; i<=n; i++){
          if(i == mid) continue;
          int idx = i - (i > mid);
          if(a[i] > b[idx]) return false;
      }
      return true;
  }
  ```

### 3. xzz_0611（4星）
- **亮点**：逆向思维，从后向前匹配，更早定位需购买的玩具。
- **代码要点**：
  ```cpp
  sort(a, a+n); sort(b, b+n-1);
  int r = n-1;
  for(int i=n; i>=1; i--){
      if(a[i] > b[r--]){
          if(id) return -1;
          id = i;
      }
  }
  ```

---

## 最优思路提炼
1. **排序降序**：玩具和箱子均降序排列，确保大尺寸优先匹配。
2. **贪心匹配**：逐个尝试将最大玩具放入当前最大箱子，失败时购买。
3. **及时验证**：购买后，剩余玩具必须能连续匹配剩余箱子。

---

## 类似题目推荐
1. **P1090 合并果子**：贪心选择最小堆，每次合并最小两堆。
2. **P1842 奶牛乘船**：排序后双指针匹配，确保每船载重足够。
3. **P1209 修理牛棚**：逆向思维，用最少的板覆盖所有牛棚缺口。

---

## 可视化代码片段（Canvas动画）
```javascript
// 伪代码：降序排列后逐步匹配
function animate() {
    let toys = [7,5,3,2].sort((a,b)=>b-a);
    let boxes = [8,6,2].sort((a,b)=>b-a);
    let newBox = null;
    
    for(let i=0; i<toys.length; i++) {
        highlight(toys[i], 'red');
        highlight(boxes[i], 'blue');
        if(toys[i] > boxes[i]) {
            newBox = toys[i];
            drawNewBox(newBox);
            for(let j=i+1; j<toys.length; j++) {
                if(toys[j] > boxes[j-1]) {
                    playFailSound();
                    return;
                }
            }
            playSuccessSound();
            return newBox;
        }
    }
}
```

---

## 复古像素风格设计
- **颜色方案**：玩具（红色8x8方块），箱子（蓝色方块），新箱子（金色闪烁）。
- **音效**：匹配成功（8-bit上升音阶），失败（短促低音），购买（金币声）。
- **AI演示**：自动高亮当前比较元素，0.5秒/步，按空格暂停/继续。

---

**总结**：贪心降序匹配是本题最优解，正确且高效。通过动画演示可直观理解匹配过程，尤其适合教学场景。

---
处理用时：407.74秒
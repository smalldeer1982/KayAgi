# 题目信息

# [AGC037A] Dividing a String

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc037/tasks/agc037_a

英小文字からなる文字列 $ S $ が与えられます。以下の条件をみたす最大の正整数 $ K $ を求めてください。

- $ S $ の空でない $ K $ 個の文字列への分割 $ S=S_1S_2...S_K $ であって $ S_i\ \neq\ S_{i+1} $ ($ 1\ ≦\ i\ ≦\ K-1 $) を満たすものが存在する。

ただし、$ S_1,S_2,...,S_K $ をこの順に連結して得られる文字列のことを $ S_1S_2...S_K $ によって表しています。

## 说明/提示

### 制約

- $ 1\ ≦\ |S|\ ≦\ 2\ \times\ 10^5 $
- $ S $ は英小文字からなる

### Sample Explanation 1

例えば `aa`,`b`,`ba`,`a` と $ S $ を $ 4 $ つの文字列に分割することができます。

## 样例 #1

### 输入

```
aabbaa```

### 输出

```
4```

## 样例 #2

### 输入

```
aaaccacabaababc```

### 输出

```
12```

# AI分析结果



### 唯一算法分类
贪心

---

### 题解思路、算法要点与解决难点
**核心思路**：贪心策略，每次尽可能分割当前字符，保证相邻子串不同。  
**关键变量**：维护前一个子串 `prev_str` 和当前累积的子串 `current_str`，遇到不同时立即分割。  
**解决难点**：正确判断何时分割，避免相邻相同。通过及时比较当前累积的子串与前一个子串，确保每次分割后的相邻子串不同。  

---

### 题解评分
#### 1. zct_sky (5星)
- **关键亮点**：代码简洁高效，正确实现贪心策略，正确处理连续字符情况。  
- **核心逻辑**：实时比较当前累积子串与前一个，不同时立即分割。  

#### 2. CmsMartin (5星)
- **关键亮点**：清晰的变量命名与初始化，正确处理所有测试样例，包括连续相同字符。  

#### 3. ShineEternal (4星)
- **关键亮点**：代码简洁，但初始变量处理稍显隐晦，仍能正确分割。  

---

### 最优思路或技巧提炼
**核心技巧**：  
1. **贪心分割**：逐个字符累积到当前子串，一旦与前一个子串不同，立即分割。  
2. **实时比较**：用两个变量分别记录当前和前一个子串，确保相邻不同。  
3. **O(n) 时间复杂度**：每个字符仅遍历一次，高效处理长字符串。  

---

### 同类型题或类似算法套路
**通用解法**：  
- **相邻约束分割问题**：通过贪心或动态规划，维护前一个状态，确保当前选择满足条件。  
- **示例题目**：  
  - [LeetCode 763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)  
  - [LeetCode 1221. 分割平衡字符串](https://leetcode.cn/problems/split-a-string-in-balanced-strings/)  

---

### 推荐洛谷题目
1. **P1147 连续字符分割**  
2. **P2678 跳石头（贪心+二分）**  
3. **P1090 合并果子（贪心+优先队列）**  

---

### 个人心得摘录
- **调试教训**：初始变量未清空导致比较错误（如 `a` 和 `b` 初始化为空）。  
- **顿悟点**：贪心分割需及时处理当前子串，避免累积过长导致无法分割。  

---

### 可视化与算法演示
**动画设计**：  
1. **颜色标记**：当前字符（黄色）、当前子串（绿色）、前一个子串（红色）。  
2. **步进控制**：点击单步执行，观察何时触发分割（相邻不同）。  
3. **可视化示例**：  
   - 输入 `aabbaa` → 分割为 `aa | b | ba | a`，每步高亮触发分割的位置。  

**复古游戏化效果**：  
- **8位像素风格**：字符块以像素网格展示，分割时播放“得分”音效。  
- **自动演示模式**：模拟贪心AI，自动分割并显示最大 `K`。  

---

### 核心代码实现
**zct_sky 的正确代码**：  
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b,s;
int l,ans;
int main(){
    cin>>s;
    l=s.length();
    for(int i=0;i<l;i++){
        a+=s[i];
        if(a!=b){
            b=a;
            ans++;
            a="";
        }
    }
    cout<<ans;
    return 0;
}
```

**关键逻辑**：  
- 实时比较 `a`（当前累积子串）和 `b`（前一个子串），不同时分割并重置。

---
处理用时：267.94秒
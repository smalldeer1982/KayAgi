# 题目信息

# [ARC171A] No Attacking

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc171/tasks/arc171_a

縦 $ N $ マス、横 $ N $ マスのチェス盤があります。チェス盤の上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と呼びます。  
 これから駒を盤に並べます。駒は $ 2 $ 種類あり、それぞれ **ルーク**, **ポーン** と呼びます。  
 駒の並び方が次の条件を満たすとき **良い配置** と呼びます。

- $ 1 $ つのマスにつき $ 0 $ 個または $ 1 $ 個の駒が置かれている。
- $ (i,\ j) $ にルークがあるとき、$ k\ \neq\ j $ であるすべての $ k $ $ (1\ \leq\ k\ \leq\ N) $ に対して $ (i,\ k) $ に駒が存在しない。
- $ (i,\ j) $ にルークがあるとき、$ k\ \neq\ i $ であるすべての $ k $ $ (1\ \leq\ k\ \leq\ N) $ に対して $ (k,\ j) $ に駒が存在しない。
- $ (i,\ j) $ にポーンがあり、かつ $ i\ \geq\ 2 $ であるとき、$ (i-1,\ j) $ に駒が存在しない。
 
$ A $ 個のルークと $ B $ 個のポーンを良い配置になるように全て盤に並べることは可能ですか？

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 10^4 $
- $ 0\ \leq\ A,\ B $
- $ 1\ \leq\ A\ +\ B\ \leq\ N^2 $
- 入力される値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のテストケースでは、例えばルークを $ (1,\ 1) $ と $ (2,\ 4) $ に、ポーンを $ (3,\ 3) $ と $ (4,\ 2) $ と $ (5,\ 3) $ に配置することで全ての駒を良い配置になるように並べることが可能です。 $ 2 $ 番目のテストケースでは、全ての駒を良い配置になるように並べることは不可能です。

## 样例 #1

### 输入

```
8

5 2 3

6 5 8

3 2 2

11 67 40

26 22 16

95 91 31

80 46 56

998 2 44353```

### 输出

```
Yes

No

No

No

Yes

No

Yes

Yes```

# AI分析结果



# 算法分类
**贪心**

---

## 综合分析与结论

### 核心思路与算法流程
题目要求在满足条件的前提下，判断能否放置指定数量的车和兵。关键点在于如何最大化兵的可放置区域：
1. **车的最优放置**：优先将车放在偶数行，减少对兵放置的影响。
2. **剩余区域计算**：
   - 当车的数量 \( A \le \lfloor N/2 \rfloor \)，剩余奇数行可放兵，每列最多放 \( \lceil N/2 \rceil \) 个。
   - 当 \( A > \lfloor N/2 \rfloor \)，车占满偶数行后需占用部分奇数行，此时剩余行数为 \( N-A \)，每列可放 \( N-A \) 个。
3. **公式推导**：最大兵数 \( B_{\text{max}} = \min(\lceil N/2 \rceil, N-A) \times (N-A) \)。

### 可视化设计
- **棋盘网格**：用不同颜色标记车、兵和禁用区域。
- **动态调整**：根据当前 \( A \) 和 \( B \) 的值，实时显示剩余可用区域。
- **颜色高亮**：车用红色，兵用绿色，禁用区域用灰色。
- **步进控制**：逐步展示车和兵的放置过程，突出贪心策略。

---

## 题解清单（≥4星）

1. **maomao233（5星）**  
   - **亮点**：公式推导清晰，代码简洁高效，直接通过条件判断解决问题。
   - **关键代码**：`min((n+1)/2, n-a)*(n-a) >= b` 直接计算最大兵数。

2. **rui_er（4星）**  
   - **亮点**：思路明确，代码简短，优先处理偶数行的放置。
   - **核心逻辑**：计算剩余行数和列数的乘积。

3. **Otue（4星）**  
   - **亮点**：分类讨论清晰，代码可读性强，分情况处理车的位置影响。

---

## 最优思路提炼

### 关键公式
最大兵数由以下条件决定：
- \( A \le \lfloor N/2 \rfloor \) 时：\( B_{\text{max}} = \lceil N/2 \rceil \times (N-A) \)
- \( A > \lfloor N/2 \rfloor \) 时：\( B_{\text{max}} = (N-A)^2 \)

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int T; cin >> T;
    while (T--) {
        int n, a, b;
        cin >> n >> a >> b;
        if (a > n) {
            cout << "No\n";
            continue;
        }
        int max_pawn = (a <= n/2) ? ((n+1)/2) * (n-a) : (n-a) * (n-a);
        cout << (max_pawn >= b ? "Yes\n" : "No\n");
    }
    return 0;
}
```

---

## 相似题目

1. **P1219 [八皇后]**  
   - 要求互不攻击的皇后放置，类似行列约束。

2. **P1036 [选数]**  
   - 组合优化问题，类似贪心选择策略。

3. **P1996 约瑟夫问题**  
   - 模拟与数学推导结合，类似分情况处理。

---

## 可视化算法演示

### 核心逻辑动画
1. **棋盘初始化**：绘制 \( N \times N \) 网格。
2. **放置车**：红色标记偶数行优先，动态更新禁用行列。
3. **计算剩余区域**：绿色高亮可放置兵的区域。
4. **验证兵数**：实时计算剩余空间是否满足 \( B \)。

### 复古像素风格
- **颜色方案**：红（车）、绿（兵）、灰（禁用）。
- **音效**：放置棋子时触发8-bit音效，成功/失败播放不同音调。
- **自动演示**：按最优策略自动放置车和兵，展示最大兵数计算。

---

## 个人心得摘录

- **调试教训**：初始误解兵的条件，误以为相邻行不能同时有兵，后通过画图验证正确间隔。
- **优化技巧**：将分情况讨论合并为公式，简化代码逻辑。
- **思维突破**：发现车的位置不影响列的选择，只需关注行数的奇偶性。

---
处理用时：325.17秒
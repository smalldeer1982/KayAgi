# 题目信息

# ニコニコレベル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dwacon2017-prelims/tasks/dwango2017qual_b

ニコニコ文字列とは、`25` を $ 0 $ 回以上繰り返した文字列のことをいいます。たとえば `25` や `252525` や空文字列はニコニコ文字列ですが、`123` や `225` はニコニコ文字列ではありません。

ある文字列 $ S $ がその連続した部分文字列として含む最長のニコニコ文字列の長さを $ S $ の **ニコニコレベル** といいます。 たとえば `52525`, `25025`, `12151` のニコニコレベルはそれぞれ $ 4 $, $ 2 $, $ 0 $ です。

ニワンゴくんは `0` から `9` の数字と `?` からなる文字列 $ T $ を持っており、それぞれの `?` を好きな数字に置き換えることで、数字のみからなる文字列 $ T' $ を作ろうとしています。ニワンゴくんが作ることのできる文字列 $ T' $ のニコニコレベルの最大値を求めて下さい。

## 说明/提示

### 制約

- $ 1\ ≦\ |T|\ ≦\ 10^5 $
- $ T $ の文字は $ 0 $ から $ 9 $ の数字か `?` のいずれかである。

### Sample Explanation 1

`?` を前から順に `5` と `2` に置き換えて `1252567890` とすると、$ 2 $ 文字目から $ 5 $ 文字目が `2525` となり、ニコニコレベル $ 4 $ の文字列を作ることができます。

### Sample Explanation 3

`25` が全く現れない文字列はニコニコレベル $ 0 $ になります。

## 样例 #1

### 输入

```
12??567890```

### 输出

```
4```

## 样例 #2

### 输入

```
65?5?4?```

### 输出

```
2```

## 样例 #3

### 输入

```
314159265358979```

### 输出

```
0```

## 样例 #4

### 输入

```
2???5????```

### 输出

```
8```

## 样例 #5

### 输入

```
52```

### 输出

```
0```

# AI分析结果



## 算法分类
动态规划 (Dynamic Programming)

---

## 题解思路与解决难点

### 核心思路
题目要求将字符串中的 `?` 替换为数字，使得最长的 `25` 重复子串尽可能长。动态规划的核心在于维护两个状态：
- `dp2[i]`：以位置 `i` 结尾且字符为 `2` 的最长 Nico 子串长度。
- `dp5[i]`：以位置 `i` 结尾且字符为 `5` 的最长 Nico 子串长度。

### 状态转移
1. **当前字符为 `2` 或 `?`**：
   - 若当前字符可视为 `2`，则 `dp2[i] = dp5[i-1] + 1`（必须接在 `5` 之后）。
2. **当前字符为 `5` 或 `?`**：
   - 若当前字符可视为 `5` 且前一个字符可形成 `2`（即 `dp2[i-1] ≥ 1`），则 `dp5[i] = dp2[i-1] + 1`。

### 解决难点
- **问号处理**：`?` 可以同时作为 `2` 或 `5`，需分别处理两种可能性。
- **起始边界**：第一个字符不能是 `5`（否则无法形成有效子串），但可以是 `2` 或 `?`（视为 `2` 时长度为 1）。
- **答案选取**：Nico 子串必须以 `5` 结尾，因此最终答案是所有 `dp5[i]` 的最大值。

---

## 最优思路与技巧提炼
- **双状态动态规划**：通过 `dp2` 和 `dp5` 分别跟踪以 `2` 或 `5` 结尾的最长子串。
- **条件转移**：灵活处理字符是否为 `2`/`5`/`?` 的多种情况，确保状态合法。
- **线性时间复杂度**：遍历字符串一次即可完成计算，适合处理长字符串（如长度 1e5）。

---

## 题解评分（≥4星）

### 1. Stone_Xz（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁清晰，状态转移条件明确，处理 `?` 的逻辑直接。
- **核心代码**：
  ```cpp
  if(s[i] == '?' || s[i] == '2')
      dp_2[i] = dp_5[i - 1] + 1;
  if((s[i] == '?' || s[i] == '5') && dp_2[i - 1] >= 1)
      dp_5[i] = dp_2[i - 1] + 1;
  ```

### 2. Kvaratskhelia（⭐⭐⭐⭐）
- **亮点**：使用二维数组 `f[i][1]` 和 `f[i][2]`，代码结构对称，易读性强。
- **核心代码**：
  ```cpp
  if(st[i]=='2'||st[i]=='?') f[i+1][1]=f[i][2]+1;
  if((st[i]=='5'||st[i]=='?')&&f[i][1]>0) f[i+1][2]=f[i][1]+1;
  ```

### 3. jwhou（⭐⭐⭐⭐）
- **亮点**：注释明确，强调 `dp5[i]` 的合法性依赖前驱状态。
- **核心代码**：
  ```cpp
  if(st[i]=='2'||st[i]=='?')
      dp[i+1][1] = dp[i][2] + 1;
  if((st[i]=='5'||st[i]=='?') && dp[i][1]>0)
      dp[i+1][2] = dp[i][1] + 1;
  ```

---

## 代码实现（Stone_Xz 题解）
```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
int dp_2[100005], dp_5[100005];

int main() {
    cin >> s;
    int len = s.size();
    s = "#" + s; // 从索引 1 开始处理
    for(int i = 1; i <= len; i++) {
        // 处理可能为 2 的情况
        if(s[i] == '?' || s[i] == '2')
            dp_2[i] = dp_5[i - 1] + 1;
        // 处理可能为 5 的情况（需前驱为 2）
        if((s[i] == '?' || s[i] == '5') && dp_2[i - 1] >= 1)
            dp_5[i] = dp_2[i - 1] + 1;
    }
    int maxi = 0;
    for(int i = 1; i <= len; i++)
        maxi = max(maxi, dp_5[i]);
    cout << maxi;
    return 0;
}
```

---

## 可视化与算法演示设计
### 动画方案
- **数据结构展示**：在 Canvas 上绘制 `dp2` 和 `dp5` 数组的实时变化，用不同颜色标记当前操作的位置（如绿色为 `2`，红色为 `5`）。
- **步进控制**：支持暂停/继续，单步执行观察状态转移。
- **高亮逻辑**：当前字符处理时，高亮其可能的取值（`2` 或 `5`），并显示对应的 `dp` 值更新。

### 复古像素风格
- **像素网格**：将字符串绘制为像素块，每个字符占据一格，`2` 用蓝色，`5` 用黄色，`?` 用灰色。
- **音效触发**：状态更新时播放 8-bit 音效，找到最大 `dp5` 时播放胜利音效。

---

## 同类型题目推荐
1. **LeetCode 32. 最长有效括号**（动态规划处理连续子串）
2. **LeetCode 647. 回文子串**（中心扩展法与动态规划）
3. **洛谷 P1140 相似基因**（双状态动态规划处理匹配问题）

---
处理用时：75.88秒
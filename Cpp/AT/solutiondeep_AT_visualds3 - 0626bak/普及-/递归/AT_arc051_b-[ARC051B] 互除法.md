# 题目信息

# [ARC051B] 互除法

## 题目描述

高桥君学习了欧几里得算法，他很好奇它能以多快的速度运行。

因此，他写了以下代码。

```cpp
#include <stdio.h>

int counter = 0;
int gcd(int a, int b) {
   if (b == 0) return a;
   counter++;
   return gcd(b, a%b);
}

int main() {
   int a, b;
   scanf("%d %d", &a, &b);
   gcd(a, b);
   printf("%d\n", counter);
}
```

这个代码输入两个整数，然后用欧几里得计算它们的 $\gcd$，然后输出它递归了多少次的代码。 你想让这个程序输出各种各样的值。

具体来说，输入一个 $K$，输出一组可以使得这个程序的输出为 $K$ 的 $A$、$B$。

## 说明/提示

对于 $30\%$ 的数据，$1\le K \le 10$；

对于 $100\%$ 的数据，$1\le K \le 40$。

只输出其中一种可能的解即可。

## 样例 #1

### 输入

```
1```

### 输出

```
1 1```

## 样例 #2

### 输入

```
3```

### 输出

```
4 5```

## 样例 #3

### 输入

```
12```

### 输出

```
314159265 358979323```

# AI分析结果



**唯一算法分类**：数学（斐波那契数列）

---

### **综合分析与结论**
本题要求构造两个数，使得欧几里得算法的递归次数恰好为给定的整数 \( K \)。核心思路是**构造斐波那契数列的相邻项**，利用其性质保证每次递归取模后的余数形成最长的步骤链。具体分析如下：

1. **核心思路**  
   - 斐波那契数列的相邻项 \( F_{n}, F_{n+1} \) 满足 \( F_{n+1} \mod F_{n} = F_{n-1} \)，导致每次递归的余数依次递减，递归次数为 \( K \)。

2. **算法流程**  
   - 构造斐波那契数列的相邻两项 \( F_{K+1} \) 和 \( F_{K+2} \)，输出顺序为 \( (F_{K+1}, F_{K+2}) \)。
   - 例如：当 \( K=3 \) 时，输出 \( (4,5) \)，递归过程为：
     - `gcd(4,5) → gcd(5,4) → gcd(4,1) → gcd(1,0)`，共 3 次调用。

3. **解决难点**  
   - 发现斐波那契数列与递归次数的关系是关键难点。
   - 需处理大数问题（如 \( K=40 \) 时 \( F_{42} \approx 2.6 \times 10^8 \)）。

---

### **题解清单 (≥4星)**

1. **题解作者：_ZhouYuHan_（4.5星）**  
   **亮点**：代码简洁高效，直接生成斐波那契数列的相邻项。  
   **代码片段**：
   ```cpp
   long long fib[42] = {0,1,1};
   for (int i=3; i<=41; i++)
       fib[i] = fib[i-1] + fib[i-2];
   cout << fib[k] << " " << fib[k+1];
   ```

2. **题解作者：Aw顿顿（4星）**  
   **亮点**：详细推导斐波那契数列与递归次数的数学关系，结合表格验证。

3. **题解作者：Tiphereth_A（4星）**  
   **亮点**：通过数学归纳法证明递归次数，并提供斐波那契数列的 OEIS 参考。

---

### **最优思路提炼**
- **关键技巧**：利用斐波那契数列的相邻项 \( F_{n}, F_{n+1} \)，确保每次递归的余数构成最长链。
- **实现要点**：递推生成斐波那契数列，输出 \( F_{K+1} \) 和 \( F_{K+2} \)。

---

### **同类型题与算法套路**
- **通用解法**：当需要构造最坏递归次数的输入时，斐波那契数列是欧几里得算法的经典最坏案例。
- **类似题目**：
  1. **洛谷 P1932**（斐波那契数列的高精度计算）
  2. **洛谷 P1306**（斐波那契数列的快速幂优化）
  3. **洛谷 P1516**（欧几里得算法的扩展应用）

---

### **可视化与算法演示**
**动画设计**：
1. **像素风格递归树**：  
   - 每个节点显示当前 \( (a, b) \)，红色高亮当前余数。
   - 步进播放递归过程，音效提示每次 `counter++`。
2. **交互控制**：  
   - 支持暂停/继续，速度调节（0.5x-3x）。
   - 自动模式演示斐波那契数列的生成与递归过程。

**复古游戏化设计**：
- **8-bit 音效**：递归时播放“哔”声，结束时播放胜利音效。
- **Canvas 动画**：用网格显示斐波那契数的增长，每一步以像素块动态拼接。

---

### **代码实现**
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int k;
    cin >> k;
    long long a = 1, b = 1;
    for (int i = 2; i <= k; i++) {
        long long tmp = a + b;
        a = b;
        b = tmp;
    }
    cout << a << " " << b;
    return 0;
}
```
**核心逻辑**：递推生成斐波那契数列的第 \( K+1 \) 和 \( K+2 \) 项，确保递归次数为 \( K \)。

---
处理用时：347.84秒
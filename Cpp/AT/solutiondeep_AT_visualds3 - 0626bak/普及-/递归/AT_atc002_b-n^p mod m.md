# 题目信息

# n^p mod m

## 题目描述

求 $n^p$ $mod$ $m$ 的值

## 说明/提示

对于100%的数据 $1≤n,m≤10^9$ $1≤p≤10^{14}$

翻译提供者：Ryan_wxn_

## 样例 #1

### 输入

```
12 15 7```

### 输出

```
3```

## 样例 #2

### 输入

```
123456789 234567894 6574837563712```

### 输出

```
120678297```

# AI分析结果



# 算法分类
**快速幂**

---

# 题解思路与核心分析
## 核心难点
1. **指数规模极大**：p 可达 1e14，常规幂运算时间复杂度无法承受
2. **数值溢出问题**：直接计算 n^p 会导致数值超出任何数据类型的范围

## 解决思路对比
### 快速幂（循环实现）
- **核心逻辑**：将指数 p 分解为二进制形式，利用公式 `n^p = n^(2^k) * ... * n^(2^0)`，通过底数平方和结果累乘的方式计算
- **关键操作**：
  ```cpp
  while(p) {
    if(p & 1) ans = ans * n % m; // 乘当前位权重
    n = n * n % m;               // 底数平方
    p >>= 1;                     // 处理下一位
  }
  ```
- **时间复杂度**：O(log p)

### 欧拉定理优化（ueettttuj）
- **适用场景**：当 n 与 m 互质时，可用 `n^φ(m) ≡ 1 (mod m)` 减少指数
- **实现难点**：需要计算欧拉函数 φ(m)，涉及质因数分解的复杂度可能较高

---

# 题解评分（≥4星）
| 作者           | 星级 | 亮点                                                                 |
|----------------|------|----------------------------------------------------------------------|
| ShineEternal   | ★★★★★ | 最简洁的循环实现，包含二进制分解的直观演示                            |
| weak_ddb       | ★★★★★ | 清晰的数学推导，代码与推导过程严格对应                                |
| ueettttuj      | ★★★★☆ | 引入欧拉定理优化思路，拓展了算法的应用边界                            |

---

# 最优思路提炼
**二进制快速幂算法**
1. **核心变量**：
   - `ans`：累乘结果（初始化为 1）
   - `n`：动态平方的底数（每次循环 `n = n^2 % m`）
2. **关键步骤**：
   - 当二进制位为 1 时：`ans = (ans * n) % m`
   - 每次处理下一位：`p = p >> 1`
3. **防溢出技巧**：
   - 所有乘法操作后立即取模
   - 使用 `long long` 防止中间结果溢出

---

# 同类型题目推荐
1. **P1226** 【模板】快速幂||取余运算
2. **P5091** 【模板】扩展欧拉定理
3. **P3390** 【模板】矩阵快速幂

---

# 可视化设计
## 动画方案
```javascript
// 伪代码示例
class FastPowVisualizer {
  constructor(n, p, m) {
    this.steps = [];
    this.currentStep = 0;
    
    // 初始化状态
    this.state = {
      base: n % m,
      exponent: p,
      result: 1,
      binary: p.toString(2).split('').reverse()
    };
  }

  nextStep() {
    const bit = this.state.binary.shift();
    if (bit === '1') {
      this.state.result = (this.state.result * this.state.base) % m;
      this.steps.push({
        action: 'MULTIPLY',
        base: this.state.base,
        result: this.state.result
      });
    }
    this.state.base = (this.state.base ** 2) % m;
    this.steps.push({
      action: 'SQUARE',
      newBase: this.state.base
    });
  }
}
```

## 复古像素风格要素
1. **颜色方案**：
   - 当前位：红色像素块 (0xFF0000)
   - 结果值：绿色渐变动画
   - 底数变化：蓝色闪烁效果
2. **音效设计**：
   - 位为 1 时：8-bit "beep" 音效
   - 平方操作：低音鼓点
3. **控制面板**：
   - 暂停/继续按钮 (16x16 像素)
   - 速度滑块 (复古旋钮样式)

---

# 核心代码实现
```cpp
#include <cstdio>
using namespace std;

long long fast_pow(long long n, long long p, long long m) {
    long long ans = 1;
    n %= m; // 关键：先取模防止初始值过大
    while (p) {
        if (p & 1) ans = ans * n % m;
        n = n * n % m;
        p >>= 1;
    }
    return ans;
}

int main() {
    long long n, p, m;
    scanf("%lld%lld%lld", &n, &m, &p);
    printf("%lld\n", fast_pow(n, p, m));
    return 0;
}
```

---

# 算法演示流程
1. **初始状态**：
   - 显示 n=12, p=7 (二进制 111), m=15
   - 结果值初始化为 1（绿色像素块）

2. **第1步**（p=7）：
   - 当前位 1：结果 = 1*12%15 = 12
   - 底数平方：12²%15 = 144%15 = 9
   - 显示红色闪烁 + 结果更新动画

3. **第2步**（p=3）：
   - 当前位 1：结果 = 12*9%15 = 108%15 = 3
   - 底数平方：9²%15 = 81%15 = 6
   - 触发音效与像素动画

4. **第3步**（p=1）：
   - 当前位 1：结果 = 3*6%15 = 18%15 = 3
   - 底数平方：6²%15 = 36%15 = 6
   - 最终结果保持为 3

---

通过这种可视化方案，学习者可以直观看到二进制位的处理过程、底数的平方规律以及结果值的动态变化，配合复古音效增强记忆点，适合教学演示与交互式学习。

---
处理用时：77.32秒
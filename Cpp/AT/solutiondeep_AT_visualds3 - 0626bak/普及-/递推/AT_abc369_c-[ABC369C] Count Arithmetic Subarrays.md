# 题目信息

# [ABC369C] Count Arithmetic Subarrays

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc369/tasks/abc369_c

長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。

$ 1\leq\ l\leq\ r\leq\ N $ を満たす整数の組 $ (l,r) $ であって、数列 $ (A_l,A_{l+1},\dots,A_r) $ が等差数列であるようなものが何通りあるか求めてください。

なお、数列 $ (x_1,x_2,\dots,x_{|x|}) $ が等差数列であるとは、ある $ d $ が存在して $ x_{i+1}-x_i=d\ (1\leq\ i\ <\ |x|) $ であることをいいます。 特に、長さ $ 1 $ の数列は常に等差数列です。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

条件を満たす整数の組 $ (l,r) $ は $ (1,1),(2,2),(3,3),(4,4),(1,2),(2,3),(3,4),(1,3) $ の $ 8 $ 通りです。 実際、$ (l,r)=(1,3) $ のとき $ (A_l,\dots,A_r)=(3,6,9) $ は等差数列なので条件を満たしますが、 $ (l,r)=(2,4) $ のとき $ (A_l,\dots,A_r)=(6,9,3) $ は等差数列ではないので条件を満たしません。

### Sample Explanation 2

すべての整数の組 $ (l,r)\ (1\leq\ l\leq\ r\leq\ 5) $ が条件を満たします。

## 样例 #1

### 输入

```
4

3 6 9 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5

1 1 1 1 1```

### 输出

```
15```

## 样例 #3

### 输入

```
8

87 42 64 86 72 58 44 30```

### 输出

```
22```

# AI分析结果



## 算法分类
动态规划

---

## 题解思路与核心难点
### 核心思路
题目要求统计所有连续子数组满足等差数列条件的数量。关键观察点在于等差数列的连续性质：若某段区间是等差数列，则其所有连续子区间也必须是等差数列。基于此，可采用以下两种高效思路：

1. **动态规划法**  
   维护状态数组 `b[i]` 表示以位置 `i` 结尾的最长等差数列长度。当 `a[i] - a[i-1] == a[i-1] - a[i-2]` 时，`b[i] = b[i-1] + 1`，否则 `b[i] = 2`。最终答案为所有 `b[i]` 之和。

2. **极长段分解法**  
   将数组分解为多个极长等差数列段，每个长度为 `k` 的极长段贡献 `k*(k+1)/2` 个子数组。需注意相邻段的交叠重复计算问题，通过调整避免重复。

### 难点分析
- **动态规划的状态转移推导**：需正确识别等差数列的连续依赖性，避免漏判或误判。
- **极长段的分割与去重**：处理分段边界时需精确计算贡献，避免重复统计交叠点。

---

## 题解评分（≥4星）
1. **PineappleSummer（5星）**  
   **亮点**：动态规划思路简洁高效，代码仅需单次遍历，逻辑清晰易懂。  
   **代码示例**：  
   ```cpp
   int b[N];
   b[1] = 1, b[2] = 2;
   for (int i = 3; i <= n; i++) {
       if (a[i] - a[i-1] == a[i-1] - a[i-2])
           b[i] = b[i-1] + 1;
       else 
           b[i] = 2;
   }
   ans = sum(b[1..n]);
   ```

2. **ikunTLE（4星）**  
   **亮点**：优化空间复杂度至 `O(1)`，用变量维护当前段长，结合等差数列求和公式快速计算贡献。  
   **代码示例**：  
   ```cpp
   int cnt = 1;
   for (int i = 2; i <= n; i++) {
       if (公差相等) cnt++;
       else {
           ans += cnt*(cnt-1)/2;
           cnt = 2;
       }
   }
   ```

3. **under_the_time（4星）**  
   **亮点**：通过差分数组直接处理极长段，代码紧凑，逻辑直击问题本质。  
   **代码示例**：  
   ```cpp
   for (int i = 2; i <= n; i++) {
       if (d[i] != d[i-1]) j = i;
       ans += i - j + 1;
   }
   ```

---

## 最优思路提炼
**动态规划法**是本题最优解，核心步骤如下：
1. **初始化**：`b[1] = 1`（单元素），`b[2] = 2`（两元素必等差）。
2. **状态转移**：  
   - 若当前差与前序公差一致，延长当前段：`b[i] = b[i-1] + 1`。
   - 否则重置为最小可能长度：`b[i] = 2`。
3. **累加贡献**：最终答案为 `Σb[i]`，每个 `b[i]` 表示以 `i` 结尾的所有连续等差子数组数量。

---

## 同类型题与算法套路
- **连续子数组统计问题**：如统计连续递增子数组、连续相同元素子数组等。
- **极长段分解**：适用于需要计算极长段贡献的场景（如字符串重复模式统计）。

---

## 推荐题目
1. **P1638 连续自然数和**（极长段分解应用）
2. **P2280 最大子序和**（动态规划经典）
3. **P1218 子串分值**（贡献统计思维）

---

## 可视化与算法演示
### 动态规划法动画设计
1. **元素高亮**：当前元素 `i` 显示为绿色，其前两个元素显示为黄色。
2. **公差判断**：若 `a[i]-a[i-1] == a[i-1]-a[i-2]`，显示连接箭头并延长段长。
3. **贡献累加**：右侧动态显示当前 `b[i]` 值及总和更新。
4. **复古像素风格**：  
   - 使用 8-bit 风格颜色（绿、黄、红区分状态）。
   - 音效：延长段时播放上升音调，重置时播放短促“哔”声。

### 交互演示代码片段
```javascript
// Canvas 绘制等差段
ctx.fillStyle = '#00FF00'; // 当前元素
ctx.fillRect(x, y, size, size);
if (isArithmetic) {
    playSound('up'); // 延长段音效
    drawArrow(x - size, y, x, y); // 连接箭头
}
```

---

## 个人心得摘录
- **ikunTLE**：注意最后一段的贡献需在循环外单独计算，否则会遗漏。
- **Happy_mouse**：极长段的子数组数公式 `k*(k+1)/2` 是关键，但需减去重复计算项。
- **woden**：双指针分割段时，右端点需回退一步以避免越界。

---
处理用时：115.97秒
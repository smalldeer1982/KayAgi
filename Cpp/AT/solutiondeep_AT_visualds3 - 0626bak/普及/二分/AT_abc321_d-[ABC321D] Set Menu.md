# 题目信息

# [ABC321D] Set Menu

## 题目描述

餐厅里有 $N$ 个主菜和 $M$ 个副菜，第 $i$ 个主菜的价格为 $A_i$，第 $j$ 个副菜的价格是 $B_j$。餐厅现在要推出一些套餐，每个套餐均由一道主菜和一道副菜组成，对于一个由第 $i$ 个主菜和第 $j$ 个副菜组成的套餐，我们定义 $s=A_i+B_j$，那么这个套餐的价格即为 $\min (s,P)$，$P$ 为一个给定的常数。

请你求出所有可能的套餐的价格总和。

------------

## 样例 #1

### 输入

```
2 2 7

3 5

6 1```

### 输出

```
24```

## 样例 #2

### 输入

```
1 3 2

1

1 1 1```

### 输出

```
6```

## 样例 #3

### 输入

```
7 12 25514963

2436426 24979445 61648772 23690081 33933447 76190629 62703497

11047202 71407775 28894325 31963982 22804784 50968417 30302156 82631932 61735902 80895728 23078537 7723857```

### 输出

```
2115597124```

# AI分析结果



**唯一算法分类**：双指针与排序

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
1. **排序优化**：将主菜数组A和副菜数组B分别排序，利用有序性快速确定每个元素的贡献范围。  
2. **双指针法**：遍历排序后的B数组时，维护一个指针指向A数组的最大元素，使得A[i] + B[j] ≤ P。由于A和B已排序，指针只需单向移动，时间复杂度降至线性。  
3. **前缀和加速**：预处理A数组的前缀和，快速计算满足条件的元素之和。

**解决难点**：  
- **分界点高效查找**：传统二分法需O(log N)时间，双指针法利用单调性将分界点查找时间优化至O(1)。  
- **贡献计算**：通过前缀和与分界点，将总贡献分为两部分：实际和与固定值P的总和。

---

### **题解评分（≥4星）**

1. **Mr_Gengar（★★★★☆）**  
   - **亮点**：思路清晰，代码简洁，利用二分和前缀和快速计算。  
   - **不足**：时间复杂度略高（O(N log N + M log N)）。

2. **dayz_break404（★★★★★）**  
   - **亮点**：双指针法降低时间复杂度至O(N + M)，代码高效。  
   - **代码可读性**：清晰的指针维护逻辑，适合大数据量场景。

3. **cjh20090318（★★★★☆）**  
   - **亮点**：简洁的二分实现，直接处理每个主菜的分界点。  
   - **优化点**：对极端情况的处理（如主菜价格直接超过P）有明确判断。

---

### **最优思路提炼**

1. **双指针法**：  
   - 排序A和B数组，维护指针从A末尾向左移动。  
   - 对每个B[j]，调整指针位置，使得所有A[i] ≤ P - B[j]均被包含。  
   - 贡献计算：实际和（前缀和 + B[j] * 元素数） + 固定值P的总和。

2. **前缀和加速**：  
   - 预处理前缀和数组，避免重复求和。

---

### **同类型题与算法套路**

**相似问题**：  
- **两数之和小于目标值的组合数**（LeetCode 259）  
- **三数之和**（LeetCode 15）  

**通用解法**：  
- 排序后利用双指针或二分法快速查找分界点。  
- 利用前缀和或哈希表优化计算。

---

### **推荐题目**  
1. **P1102 A-B数对**：利用哈希表或双指针统计差值组合数。  
2. **P1638 逛画展**：滑动窗口维护区间最小长度。  
3. **P3067 Balanced Cow Subsets**：折半搜索与双指针结合。

---

### **个人心得摘录**  
- **调试经验**：注意数据溢出问题，必须使用`long long`类型存储结果。  
- **优化思路**：双指针法的移动方向需与排序顺序一致，否则会漏解。

---

### **可视化与算法演示**

**动画设计**：  
1. **排序过程**：展示A和B数组的排序动画，用不同颜色区分元素大小。  
2. **双指针移动**：  
   - 主菜数组A以蓝色方块表示，副菜数组B以绿色方块表示。  
   - 指针初始指向A的末尾，随B[j]增大逐步左移。  
3. **贡献计算**：  
   - 满足条件的区域用黄色高亮，显示前缀和累加。  
   - 不满足区域用红色标记，显示固定值P的累加。  

**复古像素风格**：  
- **颜色方案**：使用8位色调（蓝、绿、黄、红）区分不同状态。  
- **音效设计**：  
  - 指针移动时播放“滴”声。  
  - 分界点确定时播放“叮”声，背景音乐循环8位风格BGM。

**交互控制**：  
- **步进执行**：允许用户逐步观察指针移动和贡献计算。  
- **速度调节**：滑动条控制动画速度，适应不同学习节奏。

---

### **代码实现（双指针法）**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5;

ll n, m, p, a[N], b[N], pre[N], ans;

int main() {
    cin >> n >> m >> p;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i];
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + a[i];
    int r = n; // 指针初始指向A的末尾
    for (int i = 1; i <= m; i++) {
        while (r > 0 && a[r] + b[i] > p) r--;
        ans += pre[r] + b[i] * r + (n - r) * p;
    }
    cout << ans << endl;
    return 0;
}
```

**核心逻辑**：  
- 排序后维护指针`r`，确保`a[r] + b[i] ≤ p`。  
- 前缀和`pre[r]`计算实际和，剩余元素贡献为`(n - r) * p`。

---
处理用时：136.96秒
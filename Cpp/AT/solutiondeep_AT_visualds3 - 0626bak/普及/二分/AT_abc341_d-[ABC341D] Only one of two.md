# 题目信息

# [ABC341D] Only one of two

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc341/tasks/abc341_d

正整数 $ N $, $ M $, $ K $ が与えられます。ここで、$ N $ と $ M $ は異なります。  
正の整数であって、$ N $ と $ M $ のうち **ちょうど一方のみ** で割り切れる数のうち小さい方から $ K $ 番目のものを出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N,\ M\leq\ 10^8 $
- $ 1\leq\ K\leq\ 10^{10} $
- $ N\neq\ M $
- $ N $, $ M $, $ K $ は整数

### Sample Explanation 1

$ 2 $ と $ 3 $ のうちちょうど一方のみで割り切れる正整数は小さい方から順に $ 2,3,4,8,9,10,\ldots $ です。 ここで、$ 6 $ は $ 2 $ と $ 3 $ の両方で割り切れるため条件をみたさないことに注意してください。 条件をみたす正整数のうち小さい方から $ 5 $ 番目の数は $ 9 $ であるため、$ 9 $ を出力します。

### Sample Explanation 2

条件をみたす数は小さい方から順に $ 1,3,5,7,\ldots $ です。

## 样例 #1

### 输入

```
2 3 5```

### 输出

```
9```

## 样例 #2

### 输入

```
1 2 3```

### 输出

```
5```

## 样例 #3

### 输入

```
100000000 99999999 10000000000```

### 输出

```
500000002500000000```

# AI分析结果



## 算法分类
**二分答案**

---

## 题解思路、算法要点与解决难点

### 核心思路对比
1. **二分答案**  
   - **核心公式**：对于任意数 `x`，计算 `x` 前符合条件的数的数量为 `x//n + x//m - 2*(x//lcm(n,m))`。  
   - **推导依据**：容斥原理，排除同时被 `n` 和 `m` 整除的情况（即 `lcm(n,m)` 的倍数）。  
   - **时间复杂度**：`O(log(max_val))`，其中 `max_val` 约 `1e18`，能高效处理 `K` 极大的情况。

2. **周期规律法**  
   - **核心观察**：每 `lcm(n,m)` 的区间内，符合条件的数的数量固定为 `lcm/n + lcm/m - 2`。  
   - **实现方法**：通过计算 `K` 所在的周期和余数，用双指针枚举余数部分的数值。  
   - **缺点**：余数部分的最坏时间复杂度为 `O(n + m)`，可能无法处理 `n, m` 极大但余数较大的情况。

### 解决难点
- **正确计算数量**：确保公式 `x//n + x//m - 2*(x//lcm)` 的正确性，避免重复计算或漏算。  
- **二分边界处理**：二分的初始边界需足够大（如 `1e18`），避免遗漏答案。  
- **周期法的数学验证**：需严格证明每个 `lcm` 区间内的数量固定，避免逻辑漏洞。

---

## 题解评分（≥4星）

1. **midsummer_zyl（5星）**  
   - **亮点**：代码简洁，二分模板清晰，结合容斥公式快速计算，时间复杂度最优。  
   - **代码片段**：  
     ```cpp
     bool check(LL mid) {
         LL sum = mid / n + mid / m - mid / x * 2;
         return sum < k;
     }
     ```

2. **Shunpower（4星）**  
   - **亮点**：详细推导公式，明确解释容斥原理，适合数学基础较弱的学习者。  
   - **代码片段**：  
     ```cpp
     LL check(LL x) {
         return x / n + x / m - 2 * (x / lcm);
     }
     ```

3. **Clay_L（4星）**  
   - **亮点**：代码简洁，使用快速读入优化，适合大输入场景。  
   - **代码片段**：  
     ```cpp
     inline int check(int x) {
         return x/n + x/m - x/lnm*2;
     }
     ```

---

## 最优思路或技巧提炼
1. **二分答案的核心公式**：  
   ```python
   count = x//n + x//m - 2 * (x//lcm(n, m))
   ```
2. **避免重复计算**：利用 `lcm` 计算公共倍数，确保每个数只被统计一次。  
3. **边界优化**：初始右边界设为 `1e18`，通过二分快速收敛到答案。

---

## 同类型题或类似算法套路
1. **二分答案+容斥**：适用于求第 `K` 大/小的满足特定条件的数，如区间内质数数量、特定排列数等。  
2. **周期规律法**：适用于问题具有周期性或重复结构的场景，如模运算、循环节问题。

---

## 推荐洛谷题目
1. **P2440 木材加工**（二分答案）  
2. **P2118 比例简化**（二分+数学验证）  
3. **P2568 GCD**（容斥原理与数论结合）

---

## 可视化与算法演示（核心算法过程）

### 动画设计
1. **二分过程演示**：  
   - **动态调整边界**：用两个箭头标记当前 `l` 和 `r`，中间标出 `mid`。  
   - **颜色标记**：`mid` 高亮为黄色，`l` 和 `r` 分别为绿色和红色。  
   - **公式计算**：在右侧实时显示 `mid//n`, `mid//m`, `mid//lcm` 的值，并计算总数。

2. **周期法演示**：  
   - **双指针移动**：用两个指针分别标记 `n` 和 `m` 的当前倍数，每次移动较小的指针。  
   - **颜色区分**：`n` 的倍数标蓝，`m` 的倍数标红，冲突数标灰。  
   - **周期区块**：用背景色区分每个 `lcm` 区间，展示周期性重复。

### 复古像素风格实现
- **Canvas 绘制**：  
  - 使用 `8-bit` 像素风格，数字用 `16x16` 像素块表示。  
  - 背景音乐：循环播放 `8-bit` 风格的轻快旋律。  
  - 音效：指针移动时播放“嘀”声，找到答案时播放胜利音效。  
- **交互控制**：  
  - 支持暂停/继续、单步执行、调节速度。  
  - 自动模式中，AI 模拟二分过程，每步延迟 `500ms`。

---

## 个人心得摘录
- **调试教训**：初始边界过小导致答案错误，需验证极端情况（如 `K=1e10`）。  
- **顿悟点**：发现 `lcm` 的周期性后，将问题从 `O(K)` 优化到 `O(1)` 周期计算。  
- **代码优化**：用 `__int128` 避免大数溢出（见 cjh20090318 的题解）。

---

## 代码核心片段（二分法）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

int main() {
    LL n, m, k;
    cin >> n >> m >> k;
    LL lcm = n / __gcd(n, m) * m;
    LL l = 1, r = 1e18, ans = 0;
    while (l <= r) {
        LL mid = (l + r) / 2;
        LL cnt = mid / n + mid / m - 2 * (mid / lcm);
        if (cnt < k) l = mid + 1;
        else r = mid - 1, ans = mid;
    }
    cout << l << endl;
    return 0;
}
```

---
处理用时：82.44秒
# 题目信息

# [ABC360D] Ghost Ants

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc360/tasks/abc360_d

数直線上に $ 1 $ から $ N $ の番号がつけられた $ N $ 匹の蟻がいます。 蟻 $ i $ $ (1\ \leq\ i\ \leq\ N) $ ははじめ座標 $ X_i $ にいて、正負どちらかの方向を向いています。はじめに全ての蟻は相異なる座標にいます。各蟻が向いている方向は長さ $ N $ の $ 01 $ 文字列 $ S $ で表され、$ S_i $ が `0` のとき蟻 $ i $ は負の方向を向いており、 `1` のとき蟻 $ i $ は正の方向を向いています。

現在を時刻 $ 0 $ とし、時刻 $ (T+0.1) $ までの $ (T+0.1) $ 単位時間にわたって、$ N $ 匹の蟻がそれぞれの向いている方向に向かって単位時間あたり $ 1 $ の速さで移動します。 複数の蟻が同じ座標に到達すると、それらの蟻はすれ違い、方向や速度を変えずに通り過ぎます。 $ (T+0.1) $ 単位時間が経過したとき、すべての蟻は停止します。

$ 1\ \leq\ i\ <\ j\ \leq\ N $ を満たし、今から時刻 $ (T+0.1) $ までに蟻 $ i $ と蟻 $ j $ がすれ違う整数の組 $ (i,j) $ の個数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^{5} $
- $ 1\ \leq\ T\ \leq\ 10^{9} $
- $ S $ は `0` と `1` からなる長さ $ N $ の文字列
- $ -10^{9}\ \leq\ X_i\ \leq\ 10^{9} $ $ (1\ \leq\ i\ \leq\ N) $
- $ X_i\ \neq\ X_j $ $ (1\ \leq\ i\ <\ j\ \leq\ N) $
- $ N,T,X_i $ $ (1\ \leq\ i\ \leq\ N) $ は整数

### Sample Explanation 1

以下の $ 5 $ つの蟻の組み合わせがすれ違います。 - 蟻 $ 3 $ と蟻 $ 4 $ が時刻 $ 0.5 $ にすれ違う。 - 蟻 $ 5 $ と蟻 $ 6 $ が時刻 $ 1 $ にすれ違う。 - 蟻 $ 1 $ と蟻 $ 2 $ が時刻 $ 2 $ にすれ違う。 - 蟻 $ 3 $ と蟻 $ 6 $ が時刻 $ 2 $ にすれ違う。 - 蟻 $ 1 $ と蟻 $ 4 $ が時刻 $ 3 $ にすれ違う。 これ以外の蟻の組み合わせはすれ違うことはないため、$ 5 $ を出力します。

## 样例 #1

### 输入

```
6 3
101010
-5 -1 0 1 2 4```

### 输出

```
5```

## 样例 #2

### 输入

```
13 656320850
0100110011101
-900549713 -713494784 -713078652 -687818593 -517374932 -498415009 -472742091 -390030458 -379340552 -237481538 -44636942 352721061 695864366```

### 输出

```
14```

# AI分析结果



## 算法分类
排序、二分查找

## 题解思路与算法要点
题目要求统计所有相遇的蚂蚁对(i,j)，其中i<j且蚂蚁i、j方向相反。核心思路是将蚂蚁分为向右和向左两组，利用排序和二分查找高效统计满足条件的对数。

**核心推导**：
1. 相遇条件：方向相反的蚂蚁，向右的蚂蚁在左，向左的蚂蚁在右，且初始距离 ≤ 2T。
2. 分组排序：将向右和向左的蚂蚁分别按坐标排序。
3. 二分查找：对于每个向右的蚂蚁，在向左组中查找满足x_i ≤ x_j ≤ x_i + 2T的数量，通过二分确定上下界。

**解决难点**：
- 确保高效性：通过排序和二分将时间复杂度优化至O(n log n)。
- 避免重复统计：通过分组确保每对只计算一次。

## 题解评分
1. **Size_OIer（5星）**
   - 思路清晰，代码简洁。
   - 正确使用二分查找统计满足条件的区间。
   - 时间复杂度优化到位。
   
2. **Special_Tony（4星）**
   - 双指针实现，降低常数。
   - 代码可读性较好，但变量命名可优化。
   
3. **Liyunze123（4星）**
   - 结构清晰，预处理方向与坐标。
   - 直接使用二分函数，逻辑简明。

## 最优思路提炼
1. **分组排序**：将蚂蚁按方向分为两组并排序。
2. **区间查询**：对于每个向右的蚂蚁，在向左组中二分查找满足x_i ≤ x_j ≤ x_i + 2T的区间。
3. **累加计数**：统计每个区间的元素数量，累加得到总对数。

## 同类型题与算法套路
- **相向运动问题**：处理两队列相向运动的相遇条件，常通过排序+二分或双指针实现。
- **区间覆盖统计**：如统计线段覆盖点、区间交集等。

## 推荐题目
1. P1908 逆序对（分治/树状数组）
2. CF702C Cellular Network（二分查找区间覆盖）
3. P1020 导弹拦截（贪心+二分优化）

## 算法可视化设计
**动画方案**：
1. **数轴展示**：用水平数轴表示蚂蚁初始位置，向右/左箭头区分方向。
2. **移动模拟**：高亮当前处理的向右蚂蚁，动态绘制其可能覆盖的向左蚂蚁区间。
3. **二分过程**：用不同颜色标记二分查找的mid、low、high指针变化。
4. **计数反馈**：实时显示累加的相遇对数。

**复古像素风格**：
- 用8-bit风格绘制蚂蚁，移动时播放经典音效。
- 背景音乐采用循环芯片音乐，命中区间时播放“得分”音效。

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, t;
    string s;
    cin >> n >> t >> s;
    vector<int> right, left;
    for (int i = 0; i < n; ++i) {
        int x; cin >> x;
        if (s[i] == '1') right.push_back(x);
        else left.push_back(x);
    }
    sort(right.begin(), right.end());
    sort(left.begin(), left.end());
    
    long long ans = 0;
    for (int x : right) {
        auto lo = lower_bound(left.begin(), left.end(), x);
        auto hi = upper_bound(left.begin(), left.end(), x + 2*t);
        ans += hi - lo;
    }
    cout << ans << endl;
}
```

## 关键点说明
- **排序**：确保可以二分查找有效区间。
- **二分边界**：`lower_bound`找第一个≥x的位置，`upper_bound`找第一个＞x+2T的位置。
- **时间复杂度**：O(n log n)来自两次排序和n次二分查询。

---
处理用时：403.65秒
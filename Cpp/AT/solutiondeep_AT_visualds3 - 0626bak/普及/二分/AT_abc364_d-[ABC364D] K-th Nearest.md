# 题目信息

# [ABC364D] K-th Nearest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc364/tasks/abc364_d

数直線上に $ N+Q $ 個の点 $ A_1,\dots,A_N,B_1,\dots,B_Q $ があり、点 $ A_i $ の座標は $ a_i $、点 $ B_j $ の座標は $ b_j $ です。

$ j=1,2,\dots,Q $ それぞれについて、以下の問題に答えてください。

- 点 $ A_1,A_2,\dots,A_N $ のうち点 $ B_j $ との距離が $ k_j $ 番目に近い点を $ X $ としたとき、点 $ X $ と点 $ B_j $ との距離を求めよ。 より厳密には、点 $ A_i $ と点 $ B_j $ との距離を $ d_i $ として、$ (d_1,d_2,\dots,d_N) $ を昇順に並び替えてできる列を $ (d_1',d_2',\dots,d_N') $ としたとき、$ d_{k_j}' $ を求めよ。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\ \leq\ 10^5 $
- $ -10^8\leq\ a_i,b_j\ \leq\ 10^8 $
- $ 1\leq\ k_j\leq\ N $
- 入力は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のクエリについて説明します。 点 $ A_1,A_2,A_3,A_4 $ と点 $ B_1 $ との距離は順に $ 1,1,7,8 $ なので、点 $ B_1 $ との距離が $ 3 $ 番目に近いのは点 $ A_3 $ です。 よって、点 $ A_3 $ と点 $ B_1 $ との距離である $ 7 $ を出力します。

### Sample Explanation 2

同じ座標に複数の点がある可能性もあります。

## 样例 #1

### 输入

```
4 3

-3 -1 5 6

-2 3

2 1

10 4```

### 输出

```
7

3

13```

## 样例 #2

### 输入

```
2 2

0 0

0 1

0 2```

### 输出

```
0

0```

## 样例 #3

### 输入

```
10 5

-84 -60 -41 -100 8 -8 -52 -62 -61 -76

-52 5

14 4

-2 6

46 2

26 7```

### 输出

```
11

66

59

54

88```

# AI分析结果



# 算法分类：二分答案

---

## 综合分析与结论
### 核心思路
所有题解均采用**二分答案**策略，核心步骤如下：
1. **预处理**：将数组 `a` 排序，确保后续二分查找可行。
2. **二分答案**：对每个查询点 `b` 和 `k`，二分查找最小距离 `d`，使得在区间 `[b-d, b+d]` 内至少有 `k` 个 `a` 中的点。
3. **统计区间点数**：通过 `lower_bound` 和 `upper_bound` 计算区间内的点数，判断是否满足条件。

### 解决难点
1. **高效统计点数**：利用排序后的数组，通过两次二分查找快速确定区间端点，时间复杂度为 `O(log n)`。
2. **二分边界处理**：初始右边界设置为 `2e8` 以覆盖最大可能距离（`a` 和 `b` 的绝对值上限为 `1e8`）。
3. **代码实现一致性**：所有题解的核心逻辑一致，仅在二分循环条件和边界调整细节上略有差异。

---

## 题解评分（≥4星）
1. **ikunTLE（5星）**  
   - **亮点**：代码简洁，使用标准二分模板，`check` 函数清晰，直接调用 `lower_bound` 和 `upper_bound`。
   - **代码可读性**：变量命名清晰，逻辑紧凑。
   - **优化点**：右边界初始化为 `2e8`，避免溢出。

2. **Guoguo2013（4.5星）**  
   - **亮点**：详细说明思路，强调单调性，代码中使用 `long long` 避免溢出风险。
   - **优化点**：初始右边界设为 `1e18`，覆盖极端情况。

3. **saixingzhe（4星）**  
   - **亮点**：代码精简，直接使用 `lower_bound` 和 `upper_bound`，逻辑与主流一致。
   - **优化点**：函数 `check` 封装明确，便于调试。

---

## 最优思路与技巧提炼
### 关键步骤
1. **预处理排序**：对 `a` 数组排序，确保后续二分操作可行。
2. **二分答案框架**：
   ```cpp
   int l = 0, r = 2e8;
   while (l <= r) {
       int mid = (l + r) >> 1;
       if (check(mid, b, k)) r = mid - 1;
       else l = mid + 1;
   }
   return l;
   ```
3. **区间点数统计**：
   ```cpp
   int check(int d, int b, int k) {
       int left = lower_bound(a+1, a+n+1, b-d) - a;
       int right = upper_bound(a+1, a+n+1, b+d) - a;
       return (right - left) >= k;
   }
   ```

### 实现技巧
- **快速二分边界调整**：根据 `check` 结果调整 `l` 和 `r`，最终 `l` 即为最小满足条件的距离。
- **避免溢出**：使用 `(l + r) >> 1` 而非 `(l + r) / 2`，提升计算效率。

---

## 类似题目与算法套路
### 同类问题
- **第K小距离**：通过二分答案找到满足条件的距离阈值。
- **范围统计问题**：利用排序和二分快速统计区间内点数。

### 推荐题目
1. **洛谷 P2678 [跳石头](https://www.luogu.com.cn/problem/P2678)**  
   - 二分答案求最小最大跳跃距离。
2. **洛谷 P2440 [木材加工](https://www.luogu.com.cn/problem/P2440)**  
   - 二分答案求最大切割长度。
3. **洛谷 P3743 kotori的设备**  
   - 二分答案判断设备能否持续运行。

---

## 可视化与算法演示
### 动画设计
1. **核心流程**：
   - **步骤1**：显示排序后的 `a` 数组。
   - **步骤2**：对每个查询，绘制数轴，标注 `b` 点和当前二分距离 `d` 的区间 `[b-d, b+d]`。
   - **步骤3**：高亮 `lower_bound` 和 `upper_bound` 找到的区间端点，统计点数。
   - **步骤4**：根据统计结果调整二分边界，动态更新区间范围。

2. **交互功能**：
   - **步进控制**：允许单步执行二分过程，观察区间调整。
   - **颜色标记**：当前 `mid` 值用红色标注，满足条件的区间用绿色填充，不满足用灰色。
   - **音效提示**：成功找到区间时播放上扬音效，调整边界时播放点击音效。

### 复古像素风格
- **UI设计**：使用 8-bit 像素字体，数轴用像素点表示，区间端点用不同颜色方块标记。
- **Canvas 动画**：在网格中动态绘制二分过程，每次调整边界时更新数轴显示。
- **音效设计**：采用 FC 风格音效，如 `mid` 更新时的“滴”声，区间满足条件的“叮”声。

---

## 代码实现（核心逻辑）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, q, a[N];

int check(int d, int b, int k) {
    int l = lower_bound(a + 1, a + n + 1, b - d) - a;
    int r = upper_bound(a + 1, a + n + 1, b + d) - a;
    return (r - l) >= k;
}

int main() {
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    sort(a + 1, a + n + 1);
    while (q--) {
        int b, k;
        scanf("%d%d", &b, &k);
        int l = 0, r = 2e8;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (check(mid, b, k)) r = mid - 1;
            else l = mid + 1;
        }
        printf("%d\n", l);
    }
    return 0;
}
```

---
处理用时：90.07秒
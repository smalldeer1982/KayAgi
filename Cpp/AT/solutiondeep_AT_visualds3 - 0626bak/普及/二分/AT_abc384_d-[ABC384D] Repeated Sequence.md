# 题目信息

# [ABC384D] Repeated Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_d

周期 $ N $ をもつ無限数列 $ A=(A\ _\ 1,A\ _\ 2,A\ _\ 3,\dotsc) $ の先頭 $ N $ 項 $ A\ _\ 1,A\ _\ 2,\dotsc,A\ _\ N $ が与えられます。

この数列の空でない連続する部分列のうち、和が $ S $ となるものが存在するか判定してください。

ただし、無限数列 $ A $ が周期 $ N $ をもつとは、$ i\gt\ N $ を満たすすべての整数 $ i $ に対して $ A\ _\ i=A\ _\ {i-N} $ が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ A\ _\ i\leq\ 10\ ^\ 9 $
- $ 1\leq\ S\leq\ 10\ ^\ {18} $
- 入力はすべて整数
 
### Sample Explanation 1

数列 $ A $ は $ (3,8,4,3,8,4,3,8,4,\dotsc) $ のようになります。 $ A $ の部分列 $ (A\ _\ 2,A\ _\ 3,A\ _\ 4,A\ _\ 5,A\ _\ 6,A\ _\ 7,A\ _\ 8,A\ _\ 9)=(8,4,3,8,4,3,8,4) $ について $ 8+4+3+8+4+3+8+4=42 $ が成り立つので、`Yes` を出力してください。

### Sample Explanation 2

$ A $ の要素はすべて $ 3 $ 以上なので、$ A $ の空でない連続する部分列の総和は $ 3 $ 以上です。 よって、総和が $ 1 $ となるような部分列は存在しないため、`No` を出力してください。

## 样例 #1

### 输入

```
3 42

3 8 4```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 1

3 8 4```

### 输出

```
No```

## 样例 #3

### 输入

```
20 83298426

748 169 586 329 972 529 432 519 408 587 138 249 656 114 632 299 984 755 404 772```

### 输出

```
Yes```

## 样例 #4

### 输入

```
20 85415869

748 169 586 329 972 529 432 519 408 587 138 249 656 114 632 299 984 755 404 772```

### 输出

```
No```

# AI分析结果



### 唯一算法分类
滑动窗口/双指针

---

### 题解思路与核心难点
**核心思路**：  
将无限循环序列问题转化为有限处理。利用模运算将大数问题转化为余数问题，再通过双指针在扩展后的两倍长度数组中寻找连续子数组和为余数的情况。  
**算法要点**：  
1. 计算周期总和 `sum`，将 `S` 取模 `sum` 得到余数 `rem`  
2. 将原数组复制两遍形成长度为 `2N` 的扩展数组  
3. 使用双指针维护窗口和，当和等于 `rem` 时返回存在  

**解决难点**：  
- 无限序列无法直接处理，需通过数学转换找到有限观察窗口  
- 余数处理确保中间完整周期被正确消去  
- 双指针高效维护窗口和，避免暴力枚举  

---

### 题解评分（≥4星）
1. **icaijy 的题解（4.5星）**  
   - 思路清晰，双指针直接解决余数问题  
   - 代码简洁，时间复杂度稳定为 `O(N)`  
   - 巧妙利用两倍数组覆盖所有前后缀组合  

2. **zlqwq 的题解（4星）**  
   - 滑动窗口结合队列维护当前和  
   - 直观易懂，正确处理余数边界  
   - 队列操作稍显冗余，但整体高效  

3. **yyycj 的题解（4星）**  
   - 双指针逻辑清晰，正确性易验证  
   - 预处理前缀和简化计算  
   - 代码注释详细，便于理解  

---

### 最优思路与技巧
**关键技巧**：  
1. **模运算转化**：将无限周期问题转化为有限余数问题  
2. **两倍数组扩展**：覆盖所有可能的前后缀组合  
3. **双指针维护窗口和**：线性时间高效处理连续子数组和  

**代码实现要点**（icaijy 的代码片段）：  
```cpp
int main() {
    int n, s;
    cin >> n >> s;
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum += a[i];
        a[i + n] = a[i]; // 复制数组为两倍长度
    }
    s %= sum; // 取余数部分
    // 双指针维护窗口和
    int l = 1, r = 1, current = 0;
    while (r <= 2 * n) {
        current += a[r++];
        while (current > s && l < r) {
            current -= a[l++];
        }
        if (current == s) {
            cout << "Yes";
            return 0;
        }
    }
    cout << "No";
}
```

---

### 相似题目
1. **LeetCode 523. 连续的子数组和**  
   - 检查是否存在和为 `k` 的倍数的子数组  
2. **LeetCode 862. 和至少为 K 的最短子数组**  
   - 双端队列优化的滑动窗口  
3. **洛谷 P1638 逛画展**  
   - 双指针维护最小窗口满足条件  

---

### 可视化设计（双指针动画）
**动画方案**：  
1. **8位像素风格**：数组元素显示为彩色方块，总和为进度条  
2. **指针移动**：左指针（绿色箭头）、右指针（红色箭头）逐步扩展窗口  
3. **音效触发**：  
   - 移动指针时播放 "beep" 音效  
   - 匹配成功时播放胜利音效  
   - 失败时播放低音  

**交互功能**：  
- **速度调节**：滑动条控制动画速度  
- **单步执行**：按钮控制逐步观察指针移动  
- **自动演示**：AI模式自动完成算法流程  

---

### 核心代码实现
icaijy 的完整代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 4e5 + 10;
int a[MAXN];

int main() {
    ios::sync_with_stdio(0);
    int n, s;
    cin >> n >> s;
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum += a[i];
        a[i + n] = a[i];
    }
    if (s % sum == 0) {
        cout << "Yes";
        return 0;
    }
    s %= sum;
    int l = 1, r = 1, current = 0;
    while (r <= 2 * n) {
        current += a[r++];
        while (current > s && l < r) {
            current -= a[l++];
        }
        if (current == s) {
            cout << "Yes";
            return 0;
        }
    }
    cout << "No";
    return 0;
}
```

---

### 个人心得摘录
> "将无限问题有限化是突破口。双指针在连续和问题中总能带来惊喜，尤其当数组元素全为正数时，窗口单调性让复杂度骤降。" —— icaijy  

> "模运算处理大数时，一定要确认余数符号，否则可能引入隐蔽错误。" —— Walrus  

---

### 总结
本题通过模运算将无限序列问题转为有限窗口，双指针在扩展数组中高效扫描。核心在于数学转化与窗口维护，算法时间复杂度 `O(N)`，空间 `O(N)`，适用于大数据场景。

---
处理用时：285.83秒
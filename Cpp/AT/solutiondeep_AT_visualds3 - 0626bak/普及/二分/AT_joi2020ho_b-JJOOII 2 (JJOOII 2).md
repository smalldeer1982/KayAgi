# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果



**算法分类**: 双指针（三指针）法

---

### 题解思路与核心难点

**核心思路**  
题目要求将字符串转换为 `K` 阶 `JOI` 字符串，且最小化中间删除次数。核心思路为：  
1. **预处理字符位置**：将 `J`、`O`、`I` 的位置分别存储到三个数组中。  
2. **三指针法**：枚举每个可能的 `J` 的起始位置，维护 `O` 和 `I` 的指针，找到满足条件的最小区间。  

**解决难点**  
1. **高效定位区间**：通过三指针线性遍历，避免重复计算，时间复杂度优化至 `O(N)`。  
2. **区间合法性验证**：确保每个字符段（`J`、`O`、`I`）的数量均满足 `K` 个。  

---

### 题解评分（≥4星）

1. **saixingzhe（4星）**  
   - **亮点**：使用三指针法线性时间复杂度，代码简洁高效。  
   - **实现**：通过 `vector` 存储位置，维护指针逐步推进。  
   - **代码片段**：  
     ```cpp
     for (int J=0; J<=q[0].size()-k; J++) {
         while (O <= q[1].size()-k && q[0][J+k-1] > q[1][O]) O++;
         while (I <= q[2].size()-k && q[1][O+k-1] > q[2][I]) I++;
         ans = min(ans, q[2][I+k-1] - q[0][J] + 1 - 3*k);
     }
     ```

2. **User_Artist（4星）**  
   - **亮点**：代码逻辑清晰，直接枚举 `J` 段并匹配后续字符。  
   - **实现**：通过数组存储位置，指针逐步更新。  

3. **封禁用户（4星）**  
   - **亮点**：使用 `lower_bound` 实现二分查找，思路易懂。  
   - **实现**：前缀和与二分结合，时间复杂度 `O(N logN)`。  

---

### 最优思路与技巧

**关键技巧**  
1. **位置预存储**：将 `J`、`O`、`I` 的位置分别存入数组，避免遍历时重复扫描。  
2. **指针维护**：每个指针仅单向移动，保证线性时间复杂度。  
3. **区间计算**：区间总长度减去 `3K` 即为中间删除次数。  

---

### 同类型题与算法套路

**通用解法**  
- **双指针法**：适用于需按顺序匹配多个子段的最小区间问题。  
- **前缀和+二分**：适用于区间统计与快速查询。  

**类似题目**  
1. **LeetCode 76. 最小覆盖子串**  
2. **LeetCode 424. 替换后的最长重复字符**  
3. **洛谷 P1147 连续自然数和**  

---

### 可视化与算法演示

**算法流程动画设计**  
1. **像素化展示**：  
   - 用不同颜色方块表示 `J`（红）、`O`（绿）、`I`（蓝）。  
   - 指针移动时，高亮当前检查的字符方块。  
   - 成功匹配 `K` 段时，闪烁显示最终区间。  

2. **交互控制**：  
   - **自动演示**：自动移动指针，展示匹配过程。  
   - **步进控制**：手动点击逐步执行，观察指针变化。  
   - **音效**：匹配成功时播放“叮”声，失败时“哔”声。  

**Canvas 实现要点**  
- **网格布局**：将字符串字符排列为一行，每个字符占一个像素块。  
- **颜色标记**：当前 `J` 段红色高亮，`O` 段绿色，`I` 段蓝色。  

---

### 代码实现（核心逻辑）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k;
    string s;
    cin >> n >> k >> s;
    vector<int> J, O, I;
    for (int i = 0; i < n; i++) {
        if (s[i] == 'J') J.push_back(i);
        else if (s[i] == 'O') O.push_back(i);
        else if (s[i] == 'I') I.push_back(i);
    }
    int ans = INT_MAX;
    int ptrO = 0, ptrI = 0;
    for (int i = 0; i + k <= J.size(); i++) {
        int endJ = J[i + k - 1];
        while (ptrO + k <= O.size() && O[ptrO] <= endJ) ptrO++;
        if (ptrO + k > O.size()) break;
        int endO = O[ptrO + k - 1];
        while (ptrI + k <= I.size() && I[ptrI] <= endO) ptrI++;
        if (ptrI + k > I.size()) break;
        ans = min(ans, I[ptrI + k - 1] - J[i] + 1 - 3 * k);
    }
    cout << (ans == INT_MAX ? -1 : ans);
    return 0;
}
```

---
处理用时：97.84秒
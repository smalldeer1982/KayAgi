# 题目信息

# [ABC320E] Somen Nagashi

## 题目描述

现有 $N$ 个人排成一队，编号从 $1$ 到 $N$，玩一个叫做“流水面条”的游戏，该游戏共有 $M$ 个事件，每个事件含三个变量 $T_i,W_i,S_i$，事件的规则如下：

- 在 $T_i$ 时刻，有 $W_i$ 根面条流了下来，队头的人拿走这些面条，并离开队列，然后于第 $T_i+S_i$ 时刻返回队列，然后返回他的原始位置。

若队列为空，则该事件忽略。

注意：若他于第 $X$ 时刻返回队列，则视为他第 $X$ 时刻在队列。

一开始每个人都有 $0$ 根面条，现要你求出这 $N$ 个人每个人获得了多少面条。

## 说明/提示

#### 样例#1说明：
第 $1$ 个人于 $1$ 时刻拿走 $1$ 根面条，将于 $4$ 时刻返回队列。

第 $2$ 个人于 $2$ 时刻拿走 $10$ 根面条，将于 $102$ 时刻返回队列。

第 $1$ 个人于 $4$ 时刻归队，返回第 $1$ 位，此时他处于队头，然后拿走 $100$ 根面条，将于 $10004$ 时刻返回队列。

第 $3$ 个人于 $10$ 时刻拿走 $1000$ 根面条，将于第 $1000000010$ 时刻归队。

第 $100$ 时刻，队内无人。

最终，这 $3$ 个人分别有 $101,10,1000$ 根面条。

## 样例 #1

### 输入

```
3 5

1 1 3

2 10 100

4 100 10000

10 1000 1000000000

100 1000000000 1```

### 输出

```
101

10

1000```

## 样例 #2

### 输入

```
3 1

1 1 1```

### 输出

```
1

0

0```

## 样例 #3

### 输入

```
1 8

1 1 1

2 2 2

3 3 3

4 4 4

5 5 5

6 6 6

7 7 7

8 8 8```

### 输出

```
15```

# AI分析结果



### 唯一算法分类
**模拟与优先队列**

---

### 题解思路与核心难点
1. **核心思路**  
   - 使用两个优先队列：  
     - **事件队列**：按时间排序，同一时间下返回事件优先于面条事件。  
     - **当前队列**：维护可用人员编号（小根堆，保证每次取最小编号）。  
   - 每次处理事件时，先处理所有已到返回时间的人，将其重新加入当前队列，再处理面条事件。

2. **解决难点**  
   - **时间顺序管理**：返回事件需优先处理，确保队列状态正确。  
   - **动态维护队列**：通过优先队列快速插入和删除人员编号。  
   - **事件分类**：在事件结构体中用标记区分面条事件和返回事件（如 `s=0` 表示返回）。

---

### 题解评分（≥4星）
1. **robertuu（5星）**  
   - 思路清晰，代码简洁，利用优先队列高效处理事件和队列状态。  
   - 关键技巧：通过 `s` 是否为 0 区分事件类型，同一时间下返回事件优先。  
   - 代码可读性强，逻辑直观。

2. **OldDriverTree（4.5星）**  
   - 类似 robertuu 的思路，但更注重事件处理的顺序性。  
   - 代码结构清晰，但变量命名稍显简略。  

3. **Mr_Biantainne（4星）**  
   - 使用两个堆分别管理返回时间和队列编号，逻辑清晰。  
   - 代码注释详细，适合初学者理解。

---

### 最优思路与技巧提炼
1. **双优先队列结构**  
   - **事件队列**：按时间排序，返回事件优先。  
   - **当前队列**：维护可用人员编号（小根堆）。  

2. **事件处理顺序**  
   - 同一时间下，优先处理返回事件，确保队列状态正确后再处理面条事件。

3. **代码优化技巧**  
   - 用 `s=0` 标记返回事件，简化事件比较逻辑。  
   - 使用小根堆快速获取队首编号最小的人。

---

### 同类型题与算法套路
- **类似题目**：  
  1. **P2278 [HNOI2003]操作系统**（进程调度，优先队列管理就绪队列）。  
  2. **P2085 最小函数值**（多函数求最小值，堆维护结果）。  
  3. **P1631 序列合并**（多序列合并，堆优化）。  

- **通用套路**：  
  - **时间驱动模拟**：按时间顺序处理事件。  
  - **状态维护**：优先队列动态管理资源或任务。  

---

### 推荐相似题目
1. **P2278**：模拟进程调度，需按时间处理任务。  
2. **P1631**：堆维护多序列合并的最小值。  
3. **P2085**：优先队列求函数最小值。  

---

### 个人心得摘录
- **robertuu**：通过 `s=0` 标记返回事件，避免复杂的比较逻辑，调试中发现此关键点。  
- **Zkl21**：强调“先处理返回再处理面条”的顺序，否则会导致队列状态错误。  

---

### 可视化与算法演示
1. **动画设计**  
   - **时间轴**：横向展示事件队列，按时间排序，颜色区分事件类型（红：面条，蓝：返回）。  
   - **队列状态**：垂直展示当前队列，编号按小到大排列，高亮队首。  
   - **操作步骤**：  
     1. 处理返回事件：蓝色块弹出，编号加入当前队列。  
     2. 处理面条事件：红色块触发，取当前队首，更新面条数，生成新的返回事件。  

2. **复古游戏化效果**  
   - **像素风格**：用 8-bit 风格绘制队列和事件，音效提示事件处理。  
   - **音效**：  
     - 返回事件：短促“叮”声。  
     - 面条事件：“咔嗒”声。  
   - **自动演示**：按时间步进，可暂停/调速观察队列变化。  

---

### 核心代码片段（robertuu 的实现）
```cpp
priority_queue<noddle> q; // 事件队列，按时间排序
priority_queue<int, vector<int>, greater<int>> l; // 当前队列，按编号排序

while (!q.empty()) {
    noddle tmp = q.top();
    q.pop();
    if (tmp.s == 0) l.push(tmp.w); // 返回事件，加入队列
    else if (!l.empty()) {         // 面条事件，处理队首
        ans[l.top()] += tmp.w;
        q.push({tmp.t + tmp.s, l.top(), 0}); // 生成返回事件
        l.pop();
    }
}
```

---

### 可视化代码示例（伪代码）
```javascript
// 初始化 Canvas
const canvas = document.getElementById('animation');
const ctx = canvas.getContext('2d');

// 绘制队列状态
function drawQueue(queue) {
    queue.forEach((id, index) => {
        drawPixelBlock(id, x, y); // 8-bit 风格方块
    });
}

// 事件处理动画
function processEvent(event) {
    if (event.type === 'return') {
        playSound('return_sound');
        addToQueue(event.id);
    } else {
        playSound('noodle_sound');
        takeNoodle(event.w);
        scheduleReturn(event.id, event.t + event.s);
    }
}
```

---
处理用时：92.94秒
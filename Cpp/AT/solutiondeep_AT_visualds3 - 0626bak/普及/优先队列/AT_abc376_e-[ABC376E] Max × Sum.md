# 题目信息

# [ABC376E] Max × Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_e

長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N),\ B\ =\ (B_1,\ B_2,\ \dots,\ B_N) $ が与えられます。  
$ \lbrace\ 1,\ 2,\ \dots,\ N\ \rbrace $ の部分集合であって大きさが $ K $ のものを $ 1 $ つ選び $ S $ とします。この時、以下の式の値としてあり得る最小値を求めてください。

$ \displaystyle\ \left(\max_{i\ \in\ S}\ A_i\right)\ \times\ \left(\sum_{i\ \in\ S}\ B_i\right) $ 

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^6 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数

### Sample Explanation 1

$ 1 $ 番目のテストケースでは、$ S\ =\ \lbrace\ 2,\ 3\ \rbrace $ を選ぶと式の値が $ 7\ \times\ (2\ +\ 4)\ =\ 42 $ になり、これが最小です。

## 样例 #1

### 输入

```
3
3 2
3 7 6
9 2 4
5 3
6 4 1 5 9
8 6 5 1 7
10 6
61 95 61 57 69 49 46 47 14 43
39 79 48 92 90 76 30 16 30 94```

### 输出

```
42
60
14579```

# AI分析结果



## 算法分类
**贪心算法、排序、优先队列**

---

## 题解思路与难点对比

### 核心思路
1. **排序**：将二元组 $(A_i, B_i)$ 按 $A_i$ 从小到大排序，确保后续枚举时 $A_i$ 作为当前最大值。
2. **枚举最大值**：遍历每个 $i$（从 $K$ 开始），假设 $A_i$ 为子集的最大值。
3. **维护最小和**：在 $[1, i]$ 中选择 $K-1$ 个最小的 $B_j$，结合当前 $B_i$ 计算总和。使用大根堆动态维护前 $K-1$ 小的 $B_j$ 的和。

### 解决难点
- **高效维护部分和**：通过大根堆维护前 $i-1$ 个元素中最小的 $K-1$ 个 $B_j$，堆顶为最大元素。新元素若比堆顶小则替换，保证总和最小。
- **多测处理**：每个测试用例需清空堆并重新初始化，避免数据污染。

---

## 题解评分（≥4星）

1. **Liyunze123（5星）**  
   - **亮点**：代码极简，直接维护堆大小为 $K$，动态计算总和。无需特殊处理 $K=1$，逻辑高度统一。  
   - **代码片段**：
     ```cpp
     for(int w=1;w<=n;w++){
         h.push(s[w].b),sum+=s[w].b;
         while(h.size()>k)sum-=h.top(),h.pop();
         if(h.size()==k)ans=min(ans,sum*s[w].a);
     }
     ```

2. **mysterys（4星）**  
   - **亮点**：使用 `stable_sort` 保证排序稳定性，优先队列维护清晰，处理多测时显式清空堆。  
   - **代码片段**：
     ```cpp
     for(int i=k+1;i<=n;i++){
         while((int)q.size()>=k){
             tot-=q.top();q.pop();
         }
         ans=min(ans,(tot+a[i].y)*a[i].x);
         q.push(a[i].y);tot+=a[i].y;
     }
     ```

3. **Ad_lqz_ht（4星）**  
   - **亮点**：结构清晰，变量命名直观，通过优先队列维护前 $K-1$ 小的元素和。  
   - **代码片段**：
     ```cpp
     for(int i = k; i <= n; i++){
         ans = min(ans, p[i].a * sum);
         sum -= q.top(); q.pop();
         q.push(p[i + 1].b); sum += p[i + 1].b;
     }
     ```

---

## 最优思路提炼
1. **排序策略**：按 $A_i$ 升序排序，确保后续枚举时 $A_i$ 递增，天然满足最大值条件。
2. **堆维护技巧**：使用大根堆动态维护前 $K-1$ 小的 $B_j$ 和。新元素若小于堆顶则替换，保证总和最小。
3. **多测初始化**：每次测试前清空堆并重置总和变量，避免数据残留。

---

## 同类型题推荐
1. **LeetCode 1383. Maximum Performance of a Team**  
   - 类似思路：排序后维护堆求最优组合。
2. **LeetCode 2102. Sequentially Ordinal Rank Tracker**  
   - 动态维护前 $K$ 小元素，结合排序与堆。
3. **洛谷 P1090 [NOIP2004 提高组] 合并果子**  
   - 优先队列经典应用，贪心求最小代价。

---

## 个人心得摘录
- **多测清空**：多个题解提到未清空堆导致 WA，强调初始化重要性（如 Sih_qwq 的罚时教训）。
- **边界处理**：$K=1$ 时需直接选择当前 $B_i$，部分题解通过隐式逻辑处理（如 Liyunze123 的代码）。

---

## 可视化与算法演示

### 动画设计
1. **排序阶段**：展示 $(A_i, B_i)$ 按 $A_i$ 升序排列的过程，高亮排序后的数组。
2. **堆维护**：  
   - **初始填充**：前 $K-1$ 个 $B_i$ 加入堆，颜色标记为绿色。  
   - **动态调整**：新 $B_i$ 若小于堆顶（红色），替换堆顶并更新总和。  
3. **乘积计算**：每次枚举 $i$ 时，显示当前 $A_i$（最大值）和总和，计算乘积并更新最小值。

### 复古像素风格
- **颜色方案**：堆内元素用绿色，当前元素用黄色，堆顶用红色。
- **音效设计**：  
  - **元素入堆**：短促“滴”声。  
  - **堆顶弹出**：低沉“咚”声。  
  - **更新最小值**：上扬音效提示。

### 交互控制
- **步进控制**：允许暂停/继续，调整动画速度观察堆变化。
- **自动演示**：模拟贪吃蛇 AI 自动遍历，展示算法决策流程。

---

## 核心代码实现（Liyunze123 版本）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n,k;
struct node{ int a,b; }s[200005];
bool cmp(node x,node y){ return x.a<y.a; }
priority_queue<int>q;
void solve(){
    cin>>n>>k; ll ans=1e18,sum=0;
    while(!q.empty()) q.pop();
    for(int i=1;i<=n;i++) cin>>s[i].a;
    for(int i=1;i<=n;i++) cin>>s[i].b;
    sort(s+1,s+1+n,cmp);
    for(int i=1;i<=n;i++){
        q.push(s[i].b); sum+=s[i].b;
        while(q.size()>k) sum-=q.top(), q.pop();
        if(q.size()==k) ans=min(ans, sum*s[i].a);
    }
    cout<<ans<<endl;
}
int main(){
    int T; cin>>T; while(T--) solve();
}
```

---
处理用时：98.88秒
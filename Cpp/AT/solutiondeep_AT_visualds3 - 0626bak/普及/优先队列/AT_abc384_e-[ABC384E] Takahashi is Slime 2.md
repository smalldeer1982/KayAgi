# 题目信息

# [ABC384E] Takahashi is Slime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_e

縦 $ H $ 行横 $ W $ 列のマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ H) $、左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ と呼ぶことにします。

はじめ、マス $ (i,j) $ には強さ $ S\ _\ {i,j} $ のスライムがおり、マス $ (P,Q) $ にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（$ 0 $ 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

- 高橋くんに隣接するスライムのうち、強さが高橋くんの強さの $ \dfrac1X $ 倍**未満**のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
 
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq500 $
- $ 1\leq\ P\leq\ H $
- $ 1\leq\ Q\leq\ W $
- $ 1\leq\ X\leq10^9 $
- $ 1\leq\ S_{i,j}\leq10^{12} $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。 
![](https://img.atcoder.jp/abc384/6b3d3bbde4767c7f5070ad0b1f202043.png) 例えば、高橋くんは次のように行動を行うことができます。 
![](https://img.atcoder.jp/abc384/81c0ccdba241277bf0cdd16ae6a7c54d.png) - マス $ (2,1) $ にいるスライムを吸収する。高橋くんの強さは $ 9+4=13 $ となり、新たにマス $ (1,1) $ のスライムとマス $ (3,1) $ のスライムが高橋くんと隣接する。 - マス $ (1,2) $ にいるスライムを吸収する。高橋くんの強さは $ 13+6=19 $ となり、新たにマス $ (1,3) $ のスライムが高橋くんと隣接する。 - マス $ (1,3) $ にいるスライムを吸収する。高橋くんの強さは $ 19+9=28 $ となる。 以上の行動を行ったあと、高橋くんの強さは $ 28 $ となります。 高橋くんがどのように行動を行っても、高橋くんの強さを $ 28 $ より大きくすることはできないため、`28` を出力してください。 高橋くんの強さの $ \dfrac12 $ 倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス $ (1,1) $ にいるスライムを吸収することはできません。

### Sample Explanation 2

高橋くんはどのスライムも吸収できません。

## 样例 #1

### 输入

```
3 3 2

2 2

14 6 9

4 9 20

17 15 7```

### 输出

```
28```

## 样例 #2

### 输入

```
3 4 1

1 1

5 10 1 1

10 1 1 1

1 1 1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
8 10 2

1 5

388 130 971 202 487 924 247 286 237 316

117 166 918 106 336 928 493 391 235 398

124 280 425 955 212 988 227 222 307 226

336 302 478 246 950 368 291 236 170 101

370 200 204 141 287 410 388 314 205 460

291 104 348 337 404 399 416 263 415 339

105 420 302 334 231 481 466 366 401 452

119 432 292 403 371 417 351 231 482 184```

### 输出

```
1343```

# AI分析结果



**唯一算法分类**：贪心算法 + 优先队列（堆）

---

### 题解思路与算法要点

#### 核心思路
1. **贪心策略**：每次优先吸收当前可接触史莱姆中强度最小的（若无法吸收最小值，则后续更无法吸收其他值）
2. **优先队列**：用小根堆维护已接触但未吸收的史莱姆，动态更新候选集合
3. **溢出处理**：将比较条件 `S < C/X` 转换为 `S * X < C` 时使用 `__int128` 或除法规避溢出

#### 关键实现步骤
1. 初始时标记起点，将四周格子加入优先队列
2. 循环取堆顶元素，判断是否满足吸收条件：
   ```python
   if S_ij * X < current_power:
       current_power += S_ij
       将新接触的格子加入队列
   else:
       终止循环
   ```
3. 使用二维数组 `vis[][]` 记录已吸收的格子

#### 解决难点
- **动态边界维护**：吸收后的新接触区域需实时加入候选集合
- **大数运算**：通过 `__int128` 或除法运算避免乘法溢出（如 `S_ij < current_power / X`）

---

### 题解评分（≥4星）

| 题解作者      | 评分 | 亮点                                                                 |
|---------------|------|----------------------------------------------------------------------|
| ikunTLE       | ⭐⭐⭐⭐ | 精准处理大数溢出问题，代码结构清晰，使用 `__int128` 保证正确性        |
| Moya_Rao      | ⭐⭐⭐⭐ | 详细记录调试过程，提供错误思路与修正方法，具有教学意义                |
| xyx404        | ⭐⭐⭐⭐ | 简明扼要直击核心，代码实现简洁，适合快速理解算法逻辑                  |

---

### 最优思路与技巧

1. **贪心选择证明**：若当前最小强度无法吸收，则其他更大值必然无法吸收，反之吸收最小值后可获得最大潜在增益
2. **优先队列优化**：时间复杂度从 O(H²W²) 优化至 O(HW log HW)
3. **数值比较技巧**：
   ```cpp
   // 避免溢出的两种实现方式
   if (S_ij < (current_power + X - 1) / X)  // 除法向上取整
   if ((__int128)S_ij * X < current_power)   // 使用128位整数
   ```

---

### 同类型题与算法套路

**通用解法**：  
当问题需要动态选择最优候选元素，且选择后会影响后续候选集合时，优先队列（堆）+ 贪心是经典解法。

**类似题目**：
1. [洛谷 P1090 合并果子](https://www.luogu.com.cn/problem/P1090)  
   （每次合并最小两堆，优先队列实现）
2. [洛谷 P3366 最小生成树](https://www.luogu.com.cn/problem/P3366)  
   （Prim算法中使用堆优化边选择）
3. [洛谷 P2449 矩形](https://www.luogu.com.cn/problem/P2449)  
   （类似动态边界扩展问题）

---

### 代码核心实现

**关键代码片段（ikunTLE 版）**：
```cpp
priority_queue<node, vector<node>, greater<node>> pq;
vis[p][q] = true;
int power = s[p][q];
// 初始四周加入队列
for (int i=1; i<=4; ++i) {
    int xx = p + dx[i], yy = q + dy[i];
    if (valid(xx, yy)) {
        vis[xx][yy] = true;
        pq.push({xx, yy, s[xx][yy]});
    }
}

while (!pq.empty()) {
    node u = pq.top(); pq.pop();
    if (u.num * X >= power) break; // __int128 比较
    power += u.num;
    // 扩展新接触区域
    for (int i=1; i<=4; ++i) {
        int xx = u.x + dx[i], yy = u.y + dy[i];
        if (valid(xx, yy) && !vis[xx][yy]) {
            vis[xx][yy] = true;
            pq.push({xx, yy, s[xx][yy]});
        }
    }
}
```

---

### 可视化与算法演示设计

**核心动画逻辑**：
1. **网格绘制**：  
   - 使用 Canvas 绘制 H×W 网格，初始高桥位置高亮为绿色
   - 候选队列中的格子用黄色边框标记，已吸收的格子变为灰色
2. **优先队列可视化**：  
   - 右侧显示堆内元素，动态更新最小值位置
3. **步进演示**：  
   - 每次弹出堆顶元素时，红色闪烁该格子
   - 若吸收成功，播放 "coin.wav" 音效，绿色扩散动画
   - 若无法吸收，播放 "error.wav" 音效，终止流程
4. **复古风格**：  
   - 采用 8-bit 像素字体，16色调色板（如 #7C5CFF 紫色背景）
   - 背景音乐循环播放 NES 风格芯片音乐

**交互功能**：
- 速度滑块控制动画间隔（100ms~2000ms）
- 暂停/继续按钮控制流程
- 重置按钮可重新选择起点或调整参数

---

### 个人心得摘录

> "吃了三发罚时才过掉此题，问题出在乘法溢出。当 S=1e12 且 X=1e9 时，乘积会超出 long long 范围。改用除法判断或 __int128 是解题关键。" —— Moya_Rao

---

**通过此分析，读者可深入理解贪心策略在动态扩展问题中的应用，并掌握优先队列与数值处理的关键技巧。**

---
处理用时：80.28秒
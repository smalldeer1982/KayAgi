# 题目信息

# [ABC308E] MEX

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc308/tasks/abc308_e

$ 0,1,2 $ からなる長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ と、 `M`, `E`, `X` からなる長さ $ N $ の文字列 $ S=S_1S_2\dots\ S_N $ が与えられます。

$ 1\ \leq\ i\ <\ j\ <\ k\ \leq\ N $ かつ $ S_iS_jS_k= $ `MEX` を満たす全ての整数の組 $ (i,j,k) $ に対する $ \text{mex}(A_i,A_j,A_k) $ の総和を求めてください。 ここで、$ \text{mex}(A_i,A_j,A_k) $ は $ A_i,A_j,A_k $ のいずれとも一致しない最小の非負整数を意味します。

## 说明/提示

### 制約

- $ 3\leq\ N\ \leq\ 2\times\ 10^5 $
- $ N $ は整数
- $ A_i\ \in\ \lbrace\ 0,1,2\rbrace $
- $ S $ は `M`, `E`, `X` からなる長さ $ N $ の文字列
 
### Sample Explanation 1

$ S_iS_jS_k $ = `MEX` となる $ i,j,k\ (1\ \leq\ i\ <\ j\ <\ k\ \leq\ N) $ の組は $ (i,j,k)=(1,2,4),(1,3,4) $ の $ 2 $ つです。 $ \text{mex}(A_1,A_2,A_4)=\text{mex}(1,1,2)=0,\text{mex}(A_1,A_3,A_4)=\text{mex}(1,0,2)=3 $ より答えは $ 0+3=3 $ です。

## 样例 #1

### 输入

```
4

1 1 0 2

MEEX```

### 输出

```
3```

## 样例 #2

### 输入

```
3

0 0 0

XXX```

### 输出

```
0```

## 样例 #3

### 输入

```
15

1 1 2 0 0 2 0 2 0 0 0 0 0 2 2

EXMMXXXEMEXEXMM```

### 输出

```
13```

# AI分析结果



### 算法分类
**枚举与计数**

### 题解思路与算法要点
**核心思路**：以中间的 `E` 为枢纽，统计其左侧 `M` 的数值分布和右侧 `X` 的数值分布，通过组合计算贡献。  
**关键步骤**：  
1. **预处理前缀与后缀**：维护 `M` 的前缀统计（数值0/1/2的出现次数）和 `X` 的后缀统计。
2. **枚举中间点 `E`**：对每个 `E`，遍历其左侧所有可能的 `M` 值（0/1/2）和右侧所有可能的 `X` 值（0/1/2）。
3. **计算 mex 贡献**：根据 `M`、`E`、`X` 的数值组合，快速计算 mex 值，并累加总贡献。

**解决难点**：  
- **高效组合统计**：通过前缀和后缀数组，将组合数量计算复杂度从 O(n^3) 降至 O(n)。
- **快速 mex 计算**：利用数值范围小（0/1/2）的特性，通过条件判断或预计算表快速求解。

---

### 题解评分（≥4星）
1. **zac2010（★★★★★）**  
   - **亮点**：简洁高效，分阶段维护 `M` 的计数和 `M-E` 的组合，直接枚举 `X` 时计算贡献。
   - **代码可读性**：结构清晰，变量命名合理，逻辑直观。

2. **未来姚班zyl（★★★★☆）**  
   - **亮点**：三进制编码组合，预处理 mex 函数，统一处理 `M-E-X` 的数值组合。
   - **优化点**：通过三进制压缩状态，减少内存访问次数。

3. **CQ_Bob（★★★★☆）**  
   - **亮点**：前缀和后缀数组明确分离，通过组合数学公式直接计算每种 mex 的可能贡献。
   - **实践性**：适合对组合数学有较好理解的读者。

---

### 最优思路提炼
**核心技巧**：  
1. **分阶段维护组合数量**：按 `M` → `E` → `X` 的顺序处理，动态维护组合状态。
2. **数值范围剪枝**：利用数值仅限 0/1/2 的特性，预计算所有可能的 mex 值，避免复杂判断。

**代码实现关键**：  
```cpp
// zac2010 的核心代码片段
L(i, 1, n) {
    if (s[i] == 'M') c[a[i]]++;
    else if (s[i] == 'E') {
        // 维护 M-E 组合：t[a][b] 表示 M=a, E=b 的组合数
        L(j, 0, 2) if (c[j]) t[min(j, a[i])][max(j, a[i])] += c[j];
    } else {
        // 计算 X 的贡献，遍历所有 M-E 组合
        L(j, 0, 2) L(k, j, 2) {
            int mex_val = mex(j, a[i], k);
            ans += t[j][k] * mex_val;
        }
    }
}
```

---

### 同类型题与算法套路
**通用解法**：  
- **中间点枚举法**：适用于需要统计三元组且中间元素可分离贡献的问题（如统计 i<j<k 且满足某条件的三元组）。
- **前缀/后缀计数**：通过预处理前后缀信息快速计算组合数，典型应用如子数组统计、回文串计数。

**相似题目推荐**：  
1. [LeetCode 1534. 统计好三元组](https://leetcode.cn/problems/count-good-triplets/)
2. [洛谷 P1638 逛画展](https://www.luogu.com.cn/problem/P1638)
3. [ABC202E. Count Descendants](https://atcoder.jp/contests/abc202/tasks/abc202_e)

---

### 可视化与算法演示
**动画设计**：  
1. **分步高亮**：  
   - **红色**：当前处理的字符（M/E/X）。
   - **绿色**：已统计的 `M` 前缀和 `X` 后缀区域。
   - **蓝色**：当前 `E` 对应的贡献计算区域。

2. **动态更新计数**：  
   - 展示 `c[]`（M 的数值计数）和 `t[][]`（M-E 组合）的实时变化。
   - 当处理到 `X` 时，显示其与所有 `M-E` 组合的匹配过程。

**复古像素风格**：  
- **Canvas 绘制**：用 8 位风格网格表示数组，不同颜色块代表 `M`/`E`/`X`。
- **音效**：`M` 出现时播放低音，`E` 中音，`X` 高音；贡献计算时播放短促“得分”音效。

---

### 代码实现（zac2010 完整代码）
```cpp
#include <bits/stdc++.h>
#define int long long
#define L(i, a, b) for(int i = (a); i <= (b); i++)
#define R(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 2e5 + 10;
int n, ans, a[N], c[3], t[3][3];
char s[N];
int mex(int a, int b, int c){
    int cnt[4] = {0}; cnt[a] = 1, cnt[b] = 1, cnt[c] = 1;
    L(i, 0, 3) if(!cnt[i]) return i;
}
signed main(){
    scanf("%lld", &n);
    L(i, 1, n) scanf("%lld", &a[i]);
    L(i, 1, n) scanf(" %c", &s[i]);
    L(i, 1, n){
        if(s[i] == 'M') c[a[i]]++;
        else if(s[i] == 'E'){
            L(j, 0, 2) if(c[j]) t[min(j, a[i])][max(j, a[i])] += c[j];
        }
        else{
            L(j, 0, 2) L(k, j, 2){
                if(a[i] < j) ans += t[j][k] * mex(a[i], j, k);
                else if(a[i] >= k) ans += t[j][k] * mex(j, k, a[i]);
                else ans += t[j][k] * mex(j, a[i], k);
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---
处理用时：87.35秒
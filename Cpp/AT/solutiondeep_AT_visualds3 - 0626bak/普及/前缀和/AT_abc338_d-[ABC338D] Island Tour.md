# 题目信息

# [ABC338D] Island Tour

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc338/tasks/abc338_d

AtCoder 諸島は $ N $ 個の島からなり、これらの島々は $ N $ 本の橋によって結ばれています。 島には $ 1 $ から $ N $ までの番号が付けられていて、$ i\ (1\leq\ i\leq\ N-1) $ 本目の橋は島 $ i $ と島 $ i+1 $ を、$ N $ 本目の橋は島 $ N $ と島 $ 1 $ を双方向に結んでいます。 橋を渡る以外に島の間を行き来する方法は存在しません。

AtCoder 諸島では、島 $ X_1 $ から始めて島 $ X_2,X_3,\dots,X_M $ を順に訪れる**ツアー**が定期的に催行されています。 移動の過程で訪れる島とは別の島を経由することもあり、ツアー中に橋を通る回数の合計がツアーの**長さ**と定義されます。

厳密には、**ツアー**とは以下の条件を全て満たす $ l+1 $ 個の島の列 $ a_0,a_1,\dots,a_l $ のことであり、その**長さ** は $ l $ として定義されます。

- 全ての $ j\ (0\leq\ j\leq\ l-1) $ について、島 $ a_j $ と島 $ a_{j+1} $ は橋で直接結ばれている
- ある $ 0\ ＝\ y_1\ <\ y_2\ <\ \dots\ <\ y_M\ =\ l $ が存在して、全ての $ k\ (1\leq\ k\leq\ M) $ について $ a_{y_k}\ =\ X_k $

財政難に苦しむ AtCoder 諸島では、維持費削減のため橋を $ 1 $ 本封鎖することになりました。 封鎖する橋をうまく選んだとき、ツアーの長さの最小値がいくつになるか求めてください。

## 说明/提示

### 制約

- $ 3\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 2\leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ X_k\leq\ N $
- $ X_k\neq\ X_{k+1}\ (1\leq\ k\leq\ M-1) $
- 入力は全て整数

### Sample Explanation 1

\- $ 1 $ 本目の橋を封鎖した場合：通る島の列として $ (a_0,a_1,a_2)=(1,3,2) $ を取ることで島 $ 1,3,2 $ を順に訪れることができ、長さ $ 2 $ のツアーが催行できます。これより短いツアーは存在しません。 - $ 2 $ 本目の橋を封鎖した場合：通る島の列として $ (a_0,a_1,a_2,a_3)=(1,3,1,2) $ を取ることで島 $ 1,3,2 $ を順に訪れることができ、長さ $ 3 $ のツアーが催行できます。これより短いツアーは存在しません。 - $ 3 $ 本目の橋を封鎖した場合：通る島の列として $ (a_0,a_1,a_2,a_3)=(1,2,3,2) $ を取ることで島 $ 1,3,2 $ を順に訪れることができ、長さ $ 3 $ のツアーが催行できます。これより短いツアーは存在しません。 よって、封鎖する橋をうまく選んだときのツアーの長さの最小値は $ 2 $ です。 以下の図は左から順に橋 $ 1,2,3 $ を封鎖した場合を表し、数字の書かれた丸が島、丸同士を結ぶ線が橋、青い矢印が最短のツアーの経路を表します。 !\[\](https://img.atcoder.jp/abc338/ad4a27665d9da939ab495acd3d05181a.png)

### Sample Explanation 2

$ X_1,X_2,\dots,X_M $ の中に同じ島が複数回現れることもあります。

## 样例 #1

### 输入

```
3 3
1 3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4 5
2 4 2 4 2```

### 输出

```
8```

## 样例 #3

### 输入

```
163054 10
62874 19143 77750 111403 29327 56303 6659 18896 64175 26369```

### 输出

```
390009```

# AI分析结果



**唯一算法分类**：差分数组

---

### **题解思路、算法要点与解决难点**
1. **核心思路**  
   - **问题转化**：删除某条桥后，路径必须绕行，计算其对总路程的影响。  
   - **差分数组**：将每个相邻点对的最优路径对应的桥区间标记，通过差分快速计算每条桥删除后的总影响。

2. **算法要点**  
   - 对每对相邻景点，计算最短路径与次短路径的差值。  
   - 若删除最短路径上的桥，总路程增加该差值。差分数组记录影响区间。  
   - 最终遍历差分数组前缀和，找到最小总影响。

3. **解决难点**  
   - **环形处理**：当最短路径跨越环的起点（如从 `n` 绕到 `1`），需拆分为两个区间处理。  
   - **高效区间修改**：差分数组避免暴力遍历，将区间加操作优化至 `O(1)`。

---

### **题解评分 (≥4星)**

1. **作者：spfa_ (5星)**  
   - **亮点**：代码简洁，差分处理清晰，直接通过区间加减法处理环形路径。  
   - **关键代码**：
     ```cpp
     void add(int l, int r, int k) { c[l] += k, c[r+1] -= k; }
     ```

2. **作者：Running_a_way (4星)**  
   - **亮点**：推导详细，解释差值计算逻辑，强调数据类型的正确性（`long long`）。  
   - **关键思路**：最短路径上的边若被删除，总影响为 `r = |原长 - 次长|`。

3. **作者：CQ_Bob (4星)**  
   - **亮点**：线段树实现提供另一种思路，适合理解区间操作，但复杂度稍高。  
   - **代码片段**：通过线段树区间更新和单点查询实现影响统计。

---

### **最优思路或技巧提炼**
1. **差分数组的环形处理**  
   - 当区间跨环时（如 `[5, 2]`），拆分为 `[5, n]` 和 `[1, 2]` 两段处理。  
   - **代码示例**：
     ```cpp
     if (l <= r) add(l, r, val);
     else add(l, n, val), add(1, r, val);
     ```

2. **高效计算路径差值**  
   - 最短路径长度 `min(d, n-d)`，差值 `abs(d - (n-d))`。  
   - **公式推导**：`d = |a - b|`，次长路径为 `n - d`，差值为 `n - 2d`。

---

### **同类型题或类似算法套路**
- **环形差分**：如洛谷 P3406 海底高铁（计算路径覆盖次数）。  
- **区间影响统计**：如 Codeforces 1000C（统计线段覆盖次数）。  
- **最短路径与代价差**：如 LeetCode 2381 字母移位 II（差分处理区间修改）。

---

### **推荐相似题目**
1. **P3406 海底高铁**  
   - 差分统计路径覆盖次数，计算最小费用。  
2. **P1083 借教室**  
   - 差分数组结合二分查找，验证区间操作的可行性。  
3. **ABC223D - Restricted Permutation**  
   - 拓扑排序与优先队列，但包含环形依赖处理。

---

### **个人心得摘录**
- **作者：Running_a_way**：  
  > “注意混淆边的编号和点的编号，开 `long long` 避免溢出。”  
  - **总结**：变量命名需清晰，数据范围大时注意溢出。

- **作者：cjh20090318**：  
  > “线段树代码因 `long long` 问题调试半小时。”  
  - **教训**：线段树的懒标记和节点值需统一数据类型。

---

### **可视化与算法演示**
1. **动画设计**  
   - **环形图**：展示岛屿和桥的环形结构，高亮当前处理的桥。  
   - **差分更新**：动态显示区间 `[l, r]` 的差分标记，颜色区分影响值。  
   - **路径对比**：闪烁显示最短路径和绕行路径，对比长度差值。

2. **复古像素风格**  
   - **Canvas 绘制**：岛屿用色块表示，桥用线条连接，删除桥时显示“爆炸”像素动画。  
   - **音效**：桥删除时播放 8-bit 爆炸音效，计算完成时播放胜利音效。

3. **交互式演示**  
   - **步进控制**：允许用户单步执行差分标记过程，观察每一步的数组变化。  
   - **自动模式**：AI 自动选择最优桥删除，实时显示总路程计算过程。

---

### **代码实现（核心逻辑）**
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int n, m, a[N], d[N];

signed main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> a[i];
    
    int total = 0;
    for (int i = 2; i <= m; i++) {
        int u = a[i-1], v = a[i];
        if (u > v) swap(u, v);
        int d1 = v - u, d2 = n - d1;
        total += min(d1, d2);
        
        int delta = abs(d1 - d2);
        if (d1 < d2) { // 最短路径为 [u, v-1]
            d[u] += delta;
            d[v] -= delta;
        } else { // 最短路径为环的另一侧
            d[1] += delta;
            d[u] -= delta;
            d[v] += delta;
        }
    }
    
    int mn = LLONG_MAX;
    for (int i = 1; i <= n; i++) {
        d[i] += d[i-1];
        mn = min(mn, d[i]);
    }
    cout << total + mn;
    return 0;
}
```

**关键注释**：  
- `d[]` 为差分数组，记录每条桥删除后的总影响。  
- `d1` 和 `d2` 分别表示两种路径长度，`delta` 为差值。  
- 环形处理通过拆分区间 `[1, u-1]` 和 `[v, n]` 实现。

---
处理用时：77.80秒
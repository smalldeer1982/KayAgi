# 题目信息

# [ABC347E] Set Add Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc347/tasks/abc347_e

全ての要素が $ 0 $ で初期化された長さ $ N $ の整数列 $ A=(A_1,A_2,\ldots,A_N) $ があります。また、集合 $ S $ があります。はじめ $ S $ は空です。

以下の $ Q $ 個のクエリを順に行います。$ Q $ 個のクエリを全て処理した後の数列 $ A $ の各要素の値を求めてください。 $ i $ 番目のクエリは以下の形式です。

- 整数 $ x_i $ が与えられる。整数 $ x_i $ が $ S $ に含まれる場合、$ S $ から $ x_i $ を削除する。そうでない場合、$ S $ に $ x_i $ を追加する。次に、$ j=1,2,\ldots,N $ について、$ j\in\ S $ ならば $ A_j $ に $ |S| $ を加算する。

なお、$ |S| $ は集合 $ S $ の要素数を意味します。例えば $ S=\lbrace\ 3,4,7\rbrace $ のとき、$ |S|=3 $ です。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\leq\ 2\times10^5 $
- $ 1\leq\ x_i\leq\ N $
- 入力される数値は全て整数

### Sample Explanation 1

$ 1 $ 番目のクエリでは、$ S $ に $ 1 $ を追加し、$ S=\lbrace\ 1\rbrace $ となります。その後、$ A_1 $ に $ |S|=1 $ を加算します。$ A=(1,0,0) $ となります。 $ 2 $ 番目のクエリでは、$ S $ に $ 3 $ を追加し、$ S=\lbrace\ 1,3\rbrace $ となります。その後、$ A_1,A_3 $ に $ |S|=2 $ を加算します。$ A=(3,0,2) $ となります。 $ 3 $ 番目のクエリでは、$ S $ から $ 3 $ を削除し、$ S=\lbrace\ 1\rbrace $ となります。その後、$ A_1 $ に $ |S|=1 $ を加算します。$ A=(4,0,2) $ となります。 $ 4 $ 番目のクエリでは、$ S $ に $ 2 $ を追加し、$ S=\lbrace\ 1,2\rbrace $ となります。その後、$ A_1,A_2 $ に $ |S|=2 $ を加算します。$ A=(6,2,2) $ となります。 最終的に、$ A=(6,2,2) $ となります。

## 样例 #1

### 输入

```
3 4
1 3 3 2```

### 输出

```
6 2 2```

## 样例 #2

### 输入

```
4 6
1 2 3 2 4 2```

### 输出

```
15 9 12 7```

# AI分析结果



### 唯一算法分类
前缀和与区间贡献计算

### 综合分析与结论
题目要求处理动态集合操作并高效计算数组元素的累加值，核心难点在于避免每次操作遍历所有元素。各题解均采用前缀和与时间区间记录的结合，核心思路如下：

1. **前缀和数组**：维护集合大小的前缀和，快速计算任意时间段内的贡献总和。
2. **状态跟踪**：记录每个元素的加入时间，删除时通过前缀和计算该时间段的贡献。
3. **线性处理**：所有操作均通过数组或哈希表实现 O(1) 时间复杂度的状态更新。

**可视化设计思路**：
- **动画流程**：每次操作高亮当前处理的元素（如绿色表示加入，红色表示删除），并实时更新前缀和数组的显示。
- **时间线展示**：以时间轴形式展示每个元素的加入与删除事件，并用区间色块表示其对答案的贡献。
- **像素风格**：使用 8-bit 像素网格表示元素状态，操作时播放对应音效（如加入时的清脆音、删除时的低沉音）。

---

### 题解清单（≥4星）
1. **fedoralxy（5星）**  
   - 亮点：结构体记录时间点，前缀和数组维护高效查询，代码简洁。
   - 关键代码：用 `ans[x].l` 记录起始时间，`val[step]` 维护前缀和。

2. **DGH_Didi（4星）**  
   - 亮点：利用 `set` 动态维护集合，`his` 数组记录时间点，逻辑清晰。
   - 关键代码：遍历 `his[i]` 计算成对时间段的贡献。

3. **Liyunze123（4星）**  
   - 亮点：代码极简，直接维护 `lasted[x]` 和前缀和数组，高效易读。
   - 关键代码：删除时 `ans[x] += sum[i-1] - sum[last[x]-1]`。

---

### 核心代码实现（以 fedoralxy 为例）
```cpp
ll val[N]; // 前缀和数组
struct node { ll l, v; } ans[N]; // 记录元素的加入时间和贡献

int main() {
    cin >> n >> q;
    for (int step = 1; step <= q; ++step) {
        ll x; cin >> x;
        if (!t[x]) { // 加入集合
            ans[x].l = step;
            t[x] = 1;
            ++len;
        } else { // 删除集合
            ans[x].v += val[step-1] - val[ans[x].l - 1];
            t[x] = 0;
            --len;
        }
        val[step] = val[step-1] + len; // 更新前缀和
    }
    // 处理未删除的元素
    for (int i = 1; i <= n; ++i) {
        if (ans[i].l != -1)
            ans[i].v += val[q] - val[ans[i].l - 1];
    }
    // 输出答案
    for (int i = 1; i <= n; ++i) cout << ans[i].v << " ";
}
```

---

### 相似题目推荐
1. **P3368 树状数组 2**（区间修改、单点查询）
2. **P3372 线段树 1**（区间和动态维护）
3. **AT1219 歴史の研究**（离线查询与贡献计算）

---

### 可视化算法演示
**步骤说明**：
1. **初始化**：显示空集合和全零数组，前缀和数组初始为0。
2. **操作处理**：
   - 加入元素 `x`：标记 `x` 为绿色，记录起始时间 `l`。
   - 删除元素 `x`：标记为红色，计算 `sum[r] - sum[l-1]` 并累加。
3. **前缀和更新**：每次操作后，更新前缀和数组的显示条。
4. **最终处理**：遍历所有元素，对未删除的补充贡献。

**复古像素效果**：
- **Canvas 网格**：每个元素占一格，颜色表示状态（绿/红）。
- **8-bit 音效**：操作时触发对应音效，背景音乐循环播放。
- **自动演示模式**：按时间步进，高亮当前操作和前缀和变化。

**交互设计**：
- **控制面板**：播放/暂停、步进、重置按钮。
- **速度调节**：滑动条控制动画速度。
- **贡献高亮**：点击元素显示其贡献区间和数值。

---
处理用时：79.81秒
# 题目信息

# [ABC384D] Repeated Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_d

周期 $ N $ をもつ無限数列 $ A=(A\ _\ 1,A\ _\ 2,A\ _\ 3,\dotsc) $ の先頭 $ N $ 項 $ A\ _\ 1,A\ _\ 2,\dotsc,A\ _\ N $ が与えられます。

この数列の空でない連続する部分列のうち、和が $ S $ となるものが存在するか判定してください。

ただし、無限数列 $ A $ が周期 $ N $ をもつとは、$ i\gt\ N $ を満たすすべての整数 $ i $ に対して $ A\ _\ i=A\ _\ {i-N} $ が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ A\ _\ i\leq\ 10\ ^\ 9 $
- $ 1\leq\ S\leq\ 10\ ^\ {18} $
- 入力はすべて整数
 
### Sample Explanation 1

数列 $ A $ は $ (3,8,4,3,8,4,3,8,4,\dotsc) $ のようになります。 $ A $ の部分列 $ (A\ _\ 2,A\ _\ 3,A\ _\ 4,A\ _\ 5,A\ _\ 6,A\ _\ 7,A\ _\ 8,A\ _\ 9)=(8,4,3,8,4,3,8,4) $ について $ 8+4+3+8+4+3+8+4=42 $ が成り立つので、`Yes` を出力してください。

### Sample Explanation 2

$ A $ の要素はすべて $ 3 $ 以上なので、$ A $ の空でない連続する部分列の総和は $ 3 $ 以上です。 よって、総和が $ 1 $ となるような部分列は存在しないため、`No` を出力してください。

## 样例 #1

### 输入

```
3 42

3 8 4```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 1

3 8 4```

### 输出

```
No```

## 样例 #3

### 输入

```
20 83298426

748 169 586 329 972 529 432 519 408 587 138 249 656 114 632 299 984 755 404 772```

### 输出

```
Yes```

## 样例 #4

### 输入

```
20 85415869

748 169 586 329 972 529 432 519 408 587 138 249 656 114 632 299 984 755 404 772```

### 输出

```
No```

# AI分析结果



### 唯一算法分类
**滑动窗口/双指针**

---

### 题解思路与核心难点分析

#### 核心算法逻辑
1. **模运算简化问题**：将无限序列问题转化为有限序列问题。计算序列总和 `sum`，将 `S` 对 `sum` 取模得到剩余值 `s_mod`。
2. **构造双周期数组**：将原数组复制一次拼接成 `2N` 长度的数组，处理跨越两个周期的子序列。
3. **滑动窗口求和**：在双周期数组上使用双指针维护一个滑动窗口，动态调整窗口范围使窗口和等于 `s_mod`。

#### 解决难点
- **无限序列处理**：通过模运算将问题限制在有限长度的数组中，避免无限循环的干扰。
- **边界情况处理**：当 `sum = 0` 时直接判断 `S` 是否为 0；当 `s_mod = 0` 时直接返回存在解。

---

### 题解评分（≥4星）

1. **icaijy的题解（5星）**
   - **亮点**：清晰的双指针实现，时间复杂度 O(N)，代码简洁易读。
   - **代码片段**：
     ```cpp
     int l=0,r=0,cur=0;
     while (l<=r && l<=2*n && r<=2*n) {
         while (cur < s && r <= 2*n) cur += a[++r];
         while (cur > s && l <= 2*n) cur -= a[l++];
         if (cur == s) return cout<<"Yes", 0;
     }
     ```

2. **yyycj的题解（4星）**
   - **亮点**：通过复制数组形成双周期，结合滑动窗口直接处理所有可能情况。
   - **关键思路**：直接操作 `2N` 数组，避免复杂的数学推导。

3. **Liuhy2996的题解（4星）**
   - **亮点**：利用前缀和哈希表实现 O(N) 复杂度，代码极简。
   - **核心代码**：
     ```cpp
     mp[0] = 1;
     for (int i=1; i<=2*n; i++) {
         if (mp[sum[i]-s_mod]) return cout<<"Yes",0;
         mp[sum[i]] = 1;
     }
     ```

---

### 最优思路提炼
1. **模运算降维**：`S %= sum` 将问题规模缩小到可处理范围。
2. **双周期数组构造**：处理跨越两个周期的子序列。
3. **滑动窗口/哈希表加速**：O(N) 时间复杂度内完成搜索。

---

### 同类题目推荐
1. [LeetCode 523. 连续的子数组和](https://leetcode.com/problems/continuous-subarray-sum/)
2. [LeetCode 1423. 可获得的最大点数](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)
3. [洛谷 P1121 环状最大两段子段和](https://www.luogu.com.cn/problem/P1121)

---

### 可视化算法演示

#### 动画设计
- **像素风格界面**：使用 8-bit 风格绘制数组元素，双指针以不同颜色方块表示。
- **关键帧展示**：
  1. **初始状态**：显示原数组和复制后的双周期数组。
  2. **滑动窗口扩展**：右指针右移时，窗口区域颜色渐变。
  3. **窗口收缩**：左指针右移时，旧元素变为灰色。
  4. **命中目标**：窗口和等于 `s_mod` 时触发爆炸特效和胜利音效。

#### 交互功能
- **速度调节**：滑动条控制动画速度（0.5x~3x）。
- **单步执行**：点击按钮逐步执行指针移动。
- **音效反馈**：命中时播放经典 FC 游戏“金币收集”音效，失败时播放“错误”提示音。

#### 核心代码片段（Canvas 绘制）
```javascript
function drawPointers(ctx, l, r, sum) {
    ctx.fillStyle = '#FF0000'; // 左指针红色
    ctx.fillRect(l * CELL_SIZE, 50, CELL_SIZE, CELL_SIZE);
    ctx.fillStyle = '#00FF00'; // 右指针绿色
    ctx.fillRect(r * CELL_SIZE, 50, CELL_SIZE, CELL_SIZE);
    ctx.fillText(`Current Sum: ${sum}`, 10, 20);
}
```

---

### 总结
通过模运算将无限序列问题转化为有限长度的双周期数组处理，结合滑动窗口或哈希表实现高效求解。该问题的核心在于识别循环结构中的数学规律，并选择合适的数据结构进行优化。

---
处理用时：76.48秒
# 题目信息

# [ABC388D] Coming of Age Celebration

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc388/tasks/abc388_d

ある星には $ N $ 人の宇宙人がおり、全員未成年です。

$ i $ 人目の宇宙人は現在 $ A_i $ 個の石を所持しており、ちょうど $ i $ 年後に成人します。

この星では誰かが成人するとき、石を $ 1 $ 個以上所持している**成人**全員が、成人する宇宙人に成人祝いとして石を $ 1 $ 個渡します。

$ N $ 年後に各宇宙人が所持している石の個数を求めてください。

ただし、今後新たな宇宙人は産まれないものとします。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 5\ \times\ 10^5 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ i $ 人目の宇宙人が持っている石の個数を $ C_i $ で表します。 はじめ $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ です。 $ 1 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ となります。 $ 2 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (4,\ 1,\ 9,\ 3) $ となります。 $ 3 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (3,\ 0,\ 11,\ 3) $ となります。 $ 4 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (2,\ 0,\ 10,\ 5) $ となります。

## 样例 #1

### 输入

```
4

5 0 9 3```

### 输出

```
2 0 10 5```

## 样例 #2

### 输入

```
5

4 6 7 2 5```

### 输出

```
0 4 7 4 9```

## 样例 #3

### 输入

```
10

2 9 1 2 0 4 6 7 1 5```

### 输出

```
0 2 0 0 0 4 7 10 4 10```

# AI分析结果



## 算法分类
**前缀和与差分**

---

## 题解思路与核心难点

### 核心逻辑
每个外星人成年时，获得此前所有有石头的成年人的1个石头，并在后续给后面的每个成年外星人1个石头，直到石头耗尽或所有人处理完毕。需高效模拟这一过程。

### 解决难点
1. **贡献传递**：每个成年外星人会影响后续连续区间的石头发放。
2. **时间效率**：暴力模拟时间复杂度为 O(n²)，需优化到 O(n) 或 O(n log n)。
3. **状态维护**：动态跟踪当前有效贡献者的数量。

---

## 最优题解评分 (≥4星)

1. **差分数组（作者：yueyan_WZF）** ★★★★★  
   - **亮点**：O(n) 时间复杂度，通过差分数组高效处理区间贡献，代码简洁高效。
   - **代码片段**：
     ```cpp
     int sum = 0;
     for (int i = 1; i <= n; i++) {
         sum += dif[i]; // 累加前缀和
         a[i] += sum;
         sum++, dif[min(n + 1, i + a[i]) + 1]--; // 差分区间更新
         a[i] = max(0, a[i] - (n - i));
     }
     ```

2. **优先队列（作者：ikunTLE）** ★★★★☆  
   - **亮点**：O(n log n) 时间复杂度，优先队列维护有效贡献者，逻辑清晰。
   - **核心代码**：
     ```cpp
     priority_queue<node> pq;
     for (int i = 1; i <= n; i++) {
         while (!pq.empty() && pq.top().x - i <= 0) pq.pop();
         a[i] += pq.size(); // 队列长度即有效贡献者数量
         pq.push({a[i] + i, i});
     }
     ```

3. **树状数组（作者：liluhexuan）** ★★★★☆  
   - **亮点**：树状数组处理区间更新与单点查询，适合理解数据结构应用。
   - **代码关键**：
     ```cpp
     void update(int x, int k) { /*区间加*/ }
     int query(int x) { /*前缀和查询*/ }
     ```

---

## 最优思路提炼
**差分数组法**  
1. **前缀和计算贡献**：用差分数组 `dif` 维护每个外星人成年时获得的石头数。
2. **区间更新**：每个外星人成年后，影响后续 `min(n - i, a[i])` 个外星人，通过 `dif` 快速更新区间。
3. **动态调整**：根据当前外星人的石头数，确定其能影响的区间范围，避免暴力遍历。

---

## 相似题目推荐
1. **P2367 语言月赛**（差分数组应用）
2. **P3368 树状数组模板**（区间更新与单点查询）
3. **CF474F 区间覆盖统计**（前缀和优化）

---

## 可视化设计
### 算法动画演示
1. **Canvas 网格绘制**：  
   - 每个外星人表示为网格中的方块，颜色区分是否成年。
   - **当前操作高亮**：正在处理的外星人标记为黄色，受影响的区间标记为渐变色。

2. **差分数组更新**：  
   - **步骤演示**：在处理外星人i时，展示 `dif[i+1]++` 和 `dif[i+a[i]+1]--` 的更新，并用流动箭头表示区间影响。

3. **复古像素风格**：  
   - **8-bit 音效**：每次更新播放“滴”声，完成所有处理时播放胜利音效。
   - **自动演示**：按时间步进，展示外星人依次成年及差分数组变化。

### 交互控制
- **速度调节**：滑动条控制动画速度（0.5x~3x）。
- **单步执行**：点击按钮逐步观察每个外星人的处理过程。

---

## 核心代码实现（差分数组）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
int a[N], dif[N], n;

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    int sum = 0;
    for (int i = 1; i <= n; ++i) {
        sum += dif[i]; // 累加差分前缀和
        a[i] += sum;   // 获得当前贡献
        int give = min(n - i, a[i]); // 计算能给出的数量
        sum++;         // 当前外星人开始贡献
        dif[i + 1]++;  // 差分起点+1
        if (i + give + 1 <= n) dif[i + give + 1]--; // 终点-1
        a[i] = max(0, a[i] - (n - i)); // 最终剩余
        cout << a[i] << " ";
    }
    return 0;
}
```

---

## 总结
本题通过差分数组高效处理区间贡献，将复杂度优化至 O(n)。关键点在于动态维护每个外星人的影响区间，并结合前缀和快速计算当前状态。类似问题可优先考虑差分或前缀和优化，避免暴力模拟。

---
处理用时：73.40秒
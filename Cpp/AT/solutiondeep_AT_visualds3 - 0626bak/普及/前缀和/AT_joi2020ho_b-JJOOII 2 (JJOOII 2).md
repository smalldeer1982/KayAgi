# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果



**唯一算法分类**: 前缀和与二分查找/双指针

---

### **综合分析与结论**

**核心思路**:  
题目要求将字符串转换为K阶JOI串，需最小化中间删除次数。关键为找到最短满足条件的子序列：连续K个J、K个O、K个I，顺序严格。操作3次数等于子序列长度减去3K。  
**核心难点**:  
1. 如何高效定位满足条件的子序列。  
2. 确保J、O、I顺序正确且数量足够。  

**解决方案**:  
- **前缀和+二分查找**: 预处理前缀和数组，枚举每个可能的J起始点，二分查找后续O、I的结束位置。  
- **双指针/滑动窗口**: 预处理各字符位置数组，用指针维护J、O、I的起始和结束位置，遍历寻找最小区间。  

**算法流程**:  
1. **预处理**: 构建J、O、I的前缀和数组或位置数组。  
2. **枚举起始点**: 遍历每个可能的J起始位置。  
3. **查找后续区间**: 对每个J区间，找到满足条件的O区间，再找到I区间。  
4. **计算最小长度**: 记录所有有效区间的长度，取最小值。  

**可视化设计**:  
- **动画方案**:  
  - **颜色标记**: J段（红色）、O段（绿色）、I段（蓝色），动态显示指针移动。  
  - **步进控制**: 单步展示二分查找或指针移动过程，高亮当前查找区间。  
  - **音效提示**: 找到有效区间时播放成功音效，无效时播放失败音效。  
- **复古像素风格**: 字符以8位像素块表示，指针移动时产生“咔哒”音效，背景播放循环芯片音乐。  

---

### **题解清单 (≥4星)**

1. **Kano_zyc (4星)**  
   - **亮点**: 前缀和与二分查找结合，逻辑清晰，代码结构明确。  
   - **关键代码**:  
     ```cpp  
     int findMinIndex(int l, int k, int n, int prefixSum[]) {  
         // 二分查找满足条件的右端点  
     }  
     ```  

2. **saixingzhe (4星)**  
   - **亮点**: 预处理字符位置数组，双指针高效遍历，时间复杂度O(N)。  
   - **关键代码**:  
     ```cpp  
     vector<int> q[3]; // 存储J/O/I的位置  
     while(O <= q[1].size()-k && q[0][J+k-1] > q[1][O]) O++;  
     ```  

3. **makerlife (4星)**  
   - **亮点**: 直接使用指针维护位置，代码简洁，适合大规模数据。  
   - **关键代码**:  
     ```cpp  
     for(int i=1; i<=totj; i++) {  
         if (i+k-1 > totj) break;  
         int ed = cj[i+k-1];  
         // 后续指针定位O和I  
     }  
     ```  

---

### **最优思路提炼**

1. **预处理位置数组**  
   - 将J、O、I的出现位置分别存入数组，快速定位K个连续字符的起始和结束位置。  
2. **双指针滑动窗口**  
   - 维护三个指针分别指向J、O、I段的起始位置，逐步右移以找到最短有效区间。  
3. **时间复杂度优化**  
   - 通过预处理和指针移动，将时间复杂度降至O(N)，适用于大输入规模。  

---

### **同类型题与类似算法**

- **类似问题**: 寻找最长/最短满足条件的子数组，如连续子数组和、特定字符序列。  
- **通用解法**: 前缀和+二分查找、滑动窗口、双指针。  

**推荐题目**:  
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分答案）  
2. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)（滑动窗口）  
3. [P1868 饥饿的奶牛](https://www.luogu.com.cn/problem/P1868)（双指针优化）  

---

### **个人心得摘录**

- **调试经验**: 初始代码未处理指针越界，导致WA；增加边界检查后通过。  
- **顿悟点**: 发现O和I的起始位置必须严格在J段之后，顺序是关键。  

---

### **可视化与复古游戏化设计**

- **Canvas动画**:  
  - 绘制字符串为像素网格，J/O/I用不同颜色块表示。  
  - 动态显示指针移动和区间选择，高亮当前查找的字符段。  
- **音效设计**:  
  - 指针移动：8-bit“滴”声。  
  - 找到有效区间：上扬音效。  
  - 失败：低沉“哔”声。  
- **自动演示模式**:  
  - 按步执行算法，AI自动移动指针并高亮变化，用户可调节速度观察细节。  

```javascript  
// 伪代码示例：Canvas绘制核心逻辑  
function drawGrid() {  
    ctx.fillStyle = '#FF0000'; // J:红色  
    q[0].forEach(pos => drawPixel(pos));  
    // 类似绘制O和I...  
}  
```  

--- 

**核心代码示例 (saixingzhe解法)**:  
```cpp  
#include<bits/stdc++.h>  
using namespace std;  
int main(){  
    vector<int> q[3]; // 存储J/O/I的位置  
    // 预处理位置  
    for(int i=0; i<s.size(); i++){  
        if(s[i]=='J') q[0].push_back(i);  
        // 类似处理O/I...  
    }  
    int O=0, I=0, ans=INT_MAX;  
    for(int J=0; J<=q[0].size()-k; J++){  
        // 移动O和I的指针...  
        ans = min(ans, q[2][I+k-1] - q[0][J] +1 -3*k);  
    }  
    cout << (ans==INT_MAX ? -1 : ans);  
}  
```  

此代码通过预处理位置数组，用双指针快速定位满足条件的最小区间，时间复杂度O(N)，为最优解法。

---
处理用时：80.01秒
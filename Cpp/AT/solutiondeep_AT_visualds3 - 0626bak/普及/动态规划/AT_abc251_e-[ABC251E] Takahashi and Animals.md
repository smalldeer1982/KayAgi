# 题目信息

# [ABC251E] Takahashi and Animals

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc251/tasks/abc251_e

高橋君と $ N $ 匹の動物がいます。 $ N $ 匹の動物はそれぞれ動物 $ 1 $ 、動物 $ 2 $ 、$ \ldots $ 、動物 $ N $ と呼ばれます。

高橋君は下記の $ N $ 種類の行動をそれぞれ好きな回数だけ（ $ 0 $ 回でも良い）行います。

- $ A_1 $ 円払い、動物 $ 1 $ と動物 $ 2 $ に餌をあげる。
- $ A_2 $ 円払い、動物 $ 2 $ と動物 $ 3 $ に餌をあげる。
- $ A_3 $ 円払い、動物 $ 3 $ と動物 $ 4 $ に餌をあげる。
- $ \cdots $
- $ A_i $ 円払い、動物 $ i $ と動物 $ (i+1) $ に餌をあげる。
- $ \cdots $
- $ A_{N-2} $ 円払い、動物 $ (N-2) $ と動物 $ (N-1) $ に餌をあげる。
- $ A_{N-1} $ 円払い、動物 $ (N-1) $ と動物 $ N $ に餌をあげる。
- $ A_N $ 円払い、動物 $ N $ と動物 $ 1 $ に餌をあげる。

上記の $ N $ 種類目の行動では、「動物 $ N $ と動物 $ 1 $ に」餌をあげることに注意してください。

すべての動物にそれぞれ $ 1 $ 回以上餌をあげるまでにかかる費用の合計として考えられる最小値を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力はすべて整数

### Sample Explanation 1

高橋君が $ 1 $ 種類目、$ 3 $ 種類目、$ 4 $ 種類目の行動をそれぞれ $ 1 $ 回ずつ行うと、 動物 $ 1 $ に $ 1 $ 回、動物 $ 2 $ に $ 1 $ 回、動物 $ 3 $ に $ 1 $ 回、動物 $ 4 $ に $ 2 $ 回、動物 $ 5 $ に $ 1 $ 回餌をあげることになり、すべての動物にそれぞれ $ 1 $ 回以上餌をあげることができます。 このときにかかる費用の合計は $ A_1\ +\ A_3\ +\ A_4\ =\ 2\ +\ 3\ +\ 2\ =\ 7 $ 円であり、これが考えられる最小値です。

## 样例 #1

### 输入

```
5

2 5 3 2 5```

### 输出

```
7```

## 样例 #2

### 输入

```
20

29 27 79 27 30 4 93 89 44 88 70 75 96 3 78 39 97 12 53 62```

### 输出

```
426```

# AI分析结果



# 输出内容

0. **题目翻译**  
   
   ## [ABC251E] 高桥君与动物们

   ### 题目描述

   高桥君和 $N$ 只动物一起生活。这些动物分别被称作动物 $1$、动物 $2$、……、动物 $N$。

   高桥君可以执行以下 $N$ 种操作任意次数（包括 $0$ 次）：
   - 花费 $A_1$ 日元，给动物 $1$ 和动物 $2$ 喂食。
   - 花费 $A_2$ 日元，给动物 $2$ 和动物 $3$ 喂食。
   - ……
   - 花费 $A_i$ 日元，给动物 $i$ 和动物 $(i+1)$ 喂食。
   - ……
   - 花费 $A_{N-1}$ 日元，给动物 $(N-1)$ 和动物 $N$ 喂食。
   - 花费 $A_N$ 日元，给动物 $N$ 和动物 $1$ 喂食。

   特别注意第 $N$ 种操作是环形结构。求让所有动物至少被喂食一次的最小总花费。

   ### 输入输出样例
   （内容与原题一致，此处略）

---

1. **唯一算法分类**  
   **线性DP**

---

2. **综合分析与结论**  
   **核心思路**：将环形问题拆解为两个线性子问题，通过动态规划求解最小值。  
   **关键难点**：处理环形结构中首尾相连的依赖关系。  
   **解决方案**：  
   - 分两种情况处理环形结构：  
     1. 必须选择操作 $1$，此时操作 $N$ 可选可不选  
     2. 必须选择操作 $N$，此时操作 $1$ 不能选  
   - 定义 $dp[i][0/1]$ 表示前 $i$ 个操作中，当前操作是否被选择的最小花费  
   - 状态转移方程：  
     $$ \begin{cases} 
     dp[i][0] = dp[i-1][1] \\
     dp[i][1] = \min(dp[i-1][0], dp[i-1][1]) + A_i 
     \end{cases} $$

   **可视化设计**：  
   - **动态矩阵更新**：在 Canvas 上绘制 DP 矩阵，用两种颜色区分两种情况  
   - **高亮标记**：当前处理的操作用闪烁边框标记，转移路径用箭头连接  
   - **音效反馈**：状态更新时播放电子音效，最优解出现时播放胜利音效  
   - **复古风格**：采用 8-bit 像素字体，DP 矩阵呈现为游戏中的宝箱格子  

---

3. **题解清单 (≥4星)**  
   - **灵茶山艾府（5星）**：  
     - 亮点：空间压缩到 O(1)，分两次初始化处理环形结构  
     - 代码片段：  
       ```go
       notPay, pay := a[n-1], a[n-1]+a[0]
       for _, v := range a[1 : n-1] {
           notPay, pay = pay, min(notPay, pay)+v
       }
       ```
   - **slzx2022YuYihan（4星）**：  
     - 亮点：通过复制数组处理环形，逻辑清晰易理解  
   - **mi_Y13c（4星）**：  
     - 亮点：严格推导边界条件，代码注释详细  

---

4. **最优代码实现**  
   ```cpp
   #include<bits/stdc++.h>
   using namespace std;
   typedef long long ll;
   const ll INF = 1e18;

   int main() {
       int n; cin >> n;
       vector<ll> a(n);
       for (auto &x : a) cin >> x;
       
       // 情况1：选第一个操作
       ll f0 = INF, f1 = a[0];
       for (int i=1; i<n; ++i) {
           tie(f0, f1) = make_pair(f1, min(f0, f1) + a[i]);
       }
       ll ans = min(f0, f1);
       
       // 情况2：不选第一个操作（必须选最后一个）
       f0 = 0, f1 = INF;
       for (int i=1; i<n; ++i) {
           tie(f0, f1) = make_pair(f1, min(f0, f1) + a[i]);
       }
       ans = min(ans, f1);
       
       cout << ans;
   }
   ```

---

5. **同类型题目推荐**  
   - [P6064] SP839-Optimal Marks（环形位运算DP）  
   - [P1453] 城市环路（基环树DP）  
   - [P2602] 数字计数（数位DP与环形思想）  

---

6. **可视化与游戏化设计**  
   **像素风格实现**：  
   - **颜色方案**：  
     - DP 格子底色：#2D2D2D（暗灰）  
     - 选中状态边框：#FFD700（金色）  
     - 转移箭头：#00FF00（荧光绿）  
   - **Canvas 动画**：  
     - 每个 DP 状态用 32x32 像素方块表示  
     - 每帧更新时播放 "beep" 音效（Web Audio API）  
   - **AI 演示模式**：  
     - 自动切换两种环形处理方案  
     - 展示最优路径的逐步推导过程  

---

**总结**：通过拆解环形结构为线性 DP，结合空间压缩技巧，本问题可在 O(N) 时间复杂度和 O(1) 空间复杂度下高效解决。关键点在于状态转移的设计与环形边界处理。

---
处理用时：82.30秒
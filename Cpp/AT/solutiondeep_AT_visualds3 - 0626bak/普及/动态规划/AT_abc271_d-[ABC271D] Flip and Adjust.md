# 题目信息

# [ABC271D] Flip and Adjust

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc271/tasks/abc271_d

両面に整数が書かれたカードが $ N $ 枚あり、$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 枚目のカードの表には $ a_i $ が、裏には $ b_i $ が書かれています。

あなたは、それぞれのカードについて、表を上に向けて置くか裏を上に向けて置くかを自由に決めることができます。

上に向けられた面に書かれた整数の総和がちょうど $ S $ となるようにカードを置くことができるか判定し、可能ならそのようなカードの置き方の一例を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ S\ \leq\ 10000 $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ 100\ \,\ (1\ \leq\ i\ \leq\ N) $
- 入力は全て整数

### Sample Explanation 1

例えば次のように置くことで、上に向けられた面に書かれた整数の総和がちょうど $ S\ (=\ 11) $ となります。 - $ 1 $ 枚目は表、$ 2 $ 枚目は裏、$ 3 $ 枚目は裏を上に向けて置く。 - $ 1 $ 枚目は裏、$ 2 $ 枚目は表、$ 3 $ 枚目は表を上に向けて置く。 よって、`HTT` や `THH` といった出力が正解となります。

### Sample Explanation 2

上に向けられた面に書かれた整数の総和がちょうど $ S\ (=\ 25) $ となるようにカードを置くことはできません。

## 样例 #1

### 输入

```
3 11

1 4

2 3

5 7```

### 输出

```
Yes

THH```

## 样例 #2

### 输入

```
5 25

2 8

9 3

4 11

5 1

12 6```

### 输出

```
No```

# AI分析结果



---

## 题目翻译

### 题目描述  
[problemUrl]: https://atcoder.jp/contests/abc271/tasks/abc271_d  

给定 $N$ 张双面卡牌，第 $i$ 张卡牌的正面写着 $a_i$，背面写着 $b_i$。你需要选择每张卡牌的朝向（正面或背面），使得所有朝上的数字之和恰好等于 $S$。若存在可行方案，输出 `Yes` 及任意一种放置方式；否则输出 `No`。

### 输入格式  
第一行包含两个整数 $N$ 和 $S$。  
接下来 $N$ 行每行包含两个整数 $a_i$ 和 $b_i$。

### 输出格式  
若存在解，第一行输出 `Yes`，第二行输出由 `H`（表示正面）和 `T`（表示背面）组成的长度为 $N$ 的字符串；否则输出 `No`。

### 样例解释  
- 样例1中，选择 `THH` 或 `HTT` 等方式均可得到总和 $11$。  
- 样例2中无可行方案。

---

## 唯一算法分类  
线性DP  

---

## 综合分析与结论  

### 核心思路  
所有题解均基于动态规划，核心为 **二维状态转移**：  
- **状态定义**：`dp[i][j]` 表示前 $i$ 张卡牌能否组成总和 $j$。  
- **转移方程**：  
  $$
  dp[i][j] = dp[i-1][j-a_i] \ \text{OR}\ dp[i-1][j-b_i]
  $$
  若前 $i-1$ 张卡可组成 $j-a_i$（选正面）或 $j-b_i$（选背面），则当前状态可达。  

### 路径回溯  
通过 **递归或迭代** 从最终状态 `dp[N][S]` 反向推导每一步的选择（`H` 或 `T`），例如：  
```cpp
void backtrack(int i, int j) {
    if (i == 0) return;
    if (j >= a[i] && dp[i-1][j-a[i]]) {
        backtrack(i-1, j-a[i]);
        ans += 'H';
    } else {
        backtrack(i-1, j-b[i]);
        ans += 'T';
    }
}
```

### 可视化设计  
1. **DP 矩阵更新动画**：  
   - 以网格形式展示 `dp[i][j]`，初始化为全灰（不可达）。  
   - 第 $i$ 行更新时，若 `dp[i-1][j-a_i]` 或 `dp[i-1][j-b_i]` 为真，则高亮当前格子为绿色。  
   - 路径回溯时，用黄色箭头标记选择路径。  

2. **复古像素风格**：  
   - 使用 8-bit 像素字体，每个状态格子为 16x16 像素，配经典红（不可达）、绿（可达）、黄（路径）。  
   - 音效：状态更新时播放短促「滴」声，路径回溯时播放「金币收集」音效。  

3. **交互功能**：  
   - 支持暂停/继续、单步执行、重置。  
   - 自动演示模式下，AI 以 500ms/步的速度自动更新 DP 矩阵并回溯路径。  

---

## 题解清单（评分≥4星）  

### 1. DYYqwq 题解（★★★★★）  
**亮点**：  
- 状态转移清晰，代码简洁。  
- 递归回溯路径逻辑直观，可读性强。  
- 初始化与边界处理完整。  

**核心代码**：  
```cpp
void output(int x, int y) {
    if (!x) return;
    if (y >= a[x] && dp[x-1][y - a[x]]) {
        output(x-1, y - a[x]);
        ans += 'H';
    } else {
        output(x-1, y - b[x]);
        ans += 'T';
    }
}
```

### 2. Tsawke 题解（★★★★☆）  
**亮点**：  
- 直接维护路径字符串，避免回溯。  
- 空间换时间，适合教学演示。  
**代码片段**：  
```cpp
dp[1][A[1]] += 'H', dp[1][B[1]] += 'T';
for (int i = 2; i <= N; ++i)
    for (int j = 0; j <= S; ++j) {
        if (j - A[i] >= 0 && dp[i-1][j - A[i]].size() == i-1)
            dp[i][j] = dp[i-1][j - A[i]] + 'H';
        // 类似处理 B[i]
    }
```

### 3. xiaoPanda 题解（★★★★）  
**亮点**：  
- 使用辅助数组 `g[i][j]` 记录选择（0/1 表示正/背面）。  
- 逆向迭代构造答案，无递归栈溢出风险。  
**关键逻辑**：  
```cpp
for (int i = n; i >= 1; --i) {
    if (g[i][s] == 0) ans.push_back('H');
    else ans.push_back('T'); 
    s -= (g[i][s] ? b[i] : a[i]);
}
```

---

## 同类型题目与推荐  
1. **0-1背包问题**：每个物品选/不选，求最大价值。  
2. **路径记录型DP**：如「编辑距离」中记录操作序列。  
3. **多维状态DP**：如「股票买卖」系列问题。  

**推荐题目**：  
- 洛谷 P1048（采药-0-1背包）  
- 洛谷 P1434（滑雪-记忆化搜索）  
- 洛谷 P1216（数字三角形-路径和）  

---

## 个人心得摘录  
> **DYYqwq**：  
> “递归回溯时需注意 `y >= a[x]` 的边界检查，否则会数组越界。”  
> **xiaoPanda**：  
> “初始化 `dp[0][0] = true` 是容易被忽略的关键点，它代表空卡牌的合法状态。”  

---

## 可视化代码片段（Canvas + JS）  
```javascript
// 初始化 Canvas 网格
const drawDPGrid = () => {
    ctx.fillStyle = "#2C3E50";
    ctx.fillRect(0, 0, width, height);
    for (let i = 0; i <= N; i++) {
        for (let j = 0; j <= S; j++) {
            if (dp[i][j]) {
                ctx.fillStyle = dp[i][j] ? "#27AE60" : "#E74C3C";
                ctx.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
            }
        }
    }
};

// 自动演示回调
const autoPlay = () => {
    if (currentStep > N) return;
    updateDP(currentStep);
    currentStep++;
    setTimeout(autoPlay, 500);
};
```

---
处理用时：87.57秒
# 题目信息

# [ABC323E] Playlist

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_e

高橋君は $ N $ 曲からなるプレイリストを持っています。 曲 $ i $ $ (1\ \leq\ i\ \leq\ N) $ の長さは $ T_i $ 秒です。  
高橋君は時刻 $ 0 $ にプレイリストのランダム再生を開始しました。

ランダム再生では、$ N $ 曲の中から等確率で $ 1 $ つを選びその曲を最後まで再生することが繰り返されます。 ここで、曲の再生は休みなく行われ、$ 1 $ つの曲が終わったらすぐに次に選ばれた曲が始まります。 また、同じ曲が連続して選ばれる事もあります。

時刻 $ 0 $ から $ (X+0.5) $ 秒後に曲 $ 1 $ が再生されている確率を $ \text{mod}998244353 $ で求めてください。

確率 $ \text{mod\ }\ 998244353 $ の定義この問題で求める確率は必ず有理数になることが証明できます。 また、この問題の制約下では、求める確率を既約分数 $ \frac{y}{x} $ で表したときに $ x $ が $ 998244353 $ で割り切れないことが保証されます。

このとき $ xz\ \equiv\ y\ \pmod{998244353} $ を満たすような $ 0 $ 以上 $ 998244352 $ 以下の整数 $ z $ が一意に定まります。この $ z $ を答えてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\leq\ 10^3 $
- $ 0\ \leq\ X\leq\ 10^4 $
- $ 1\ \leq\ T_i\leq\ 10^4 $
- 入力はすべて整数

### Sample Explanation 1

時刻 $ 0 $ から $ 6.5 $ 秒後に曲 $ 1 $ が流れているパターンとしてあり得るのは、 - 曲 $ 1 $ $ \to $ 曲 $ 1 $ $ \to $ 曲 $ 1 $ - 曲 $ 2 $ $ \to $ 曲 $ 1 $ - 曲 $ 3 $ $ \to $ 曲 $ 1 $ の順で音楽が再生された場合であり、これらのいずれかが起こる確率は $ \frac{7}{27} $ となります。 $ 369720131\times\ 27\equiv\ 7\ \pmod{998244353} $ であるため、$ 369720131 $ を出力します。

### Sample Explanation 2

時刻 $ 0 $ から $ 0.5 $ 秒後には最初に再生された曲が再生されているため、求める確率は $ \frac{1}{5} $ となります。 同じ長さの異なる曲が存在することがあることに注意してください。

## 样例 #1

### 输入

```
3 6
3 5 6```

### 输出

```
369720131```

## 样例 #2

### 输入

```
5 0
1 2 1 2 1```

### 输出

```
598946612```

## 样例 #3

### 输入

```
5 10000
1 2 3 4 5```

### 输出

```
586965467```

# AI分析结果



# 题目翻译

## [ABC323E] Playlist

### 题目描述

高桥君有一个包含 $N$ 首歌曲的播放列表，第 $i$ 首歌曲的时长为 $T_i$ 秒。他在时刻 $0$ 开始随机播放，播放规则如下：

1. 每次从 $N$ 首歌曲中等概率随机选择一首播放
2. 歌曲播放结束后立即开始下一首随机选择
3. 允许同一首歌曲连续播放多次

求在时刻 $(X+0.5)$ 秒时，正在播放第 1 首歌曲的概率，答案对 $998244353$ 取模。

### 输入格式

第一行输入 $N$ 和 $X$
第二行输入 $N$ 个整数表示 $T_1,T_2,...,T_N$

### 输出格式

输出取模后的概率值

### 数据范围

- $2 \leq N \leq 10^3$
- $0 \leq X \leq 10^4$
- $1 \leq T_i \leq 10^4$

---

## 算法分类
`线性DP`

---

## 题解分析与结论

### 核心思路与难点

**关键建模思路**：
1. 歌曲在 $(X+0.5)$ 秒时播放的条件是：该歌曲的播放起始时间 $s$ 满足 $s \leq X+0.5 < s+T_1$
2. 转化数学条件得到 $s \in [X-T_1+1, X]$（考虑离散时间点）

**动态规划设计**：
- 状态定义：`f[i]` 表示在时刻 `i` 恰好结束某一歌曲播放的概率
- 状态转移：`f[i] = sum(f[i-T_j] * inv) for all j`（`inv = 1/N` 的逆元）
- 最终答案：`sum(f[X-T_1+1..X]) * inv`

**算法可视化设计**：
- 使用网格动画展示 `f[]` 数组的更新过程
- 每个时间点 `i` 的高亮显示其依赖的前驱时间点 `i-T_j`
- 最终答案区间用不同颜色框标记

---

## 高分题解推荐 (4★+)

### 1. 梦应归于何处（4.5★）
**亮点**：
- 一维DP实现，时间复杂度严格 O(NX)
- 逆元预处理优化计算
- 代码简洁易实现，适合竞赛场景

### 2. not_clever_syl（4.2★）
**亮点**：
- 明确的状态转移方程推导
- 包含边界条件的特判处理
- 采用滚动数组思想节省空间

### 3. Halberd_Cease（4.0★）
**亮点**：
- 背包式转移的直观解释
- 代码包含详细注释说明
- 模块化计算逆元提高可读性

---

## 最优代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mod = 998244353;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

int main() {
    int n, x;
    cin >> n >> x;
    vector<int> t(n);
    for (auto& v : t) cin >> v;
    
    ll inv = qpow(n, mod-2);
    vector<ll> f(x + 1);
    f[0] = 1;
    
    for (int i = 0; i <= x; ++i) 
        for (int j = 0; j < n; ++j)
            if (i + t[j] <= x)
                f[i + t[j]] = (f[i + t[j]] + f[i] * inv) % mod;
    
    ll ans = 0;
    int L = max(0, x - t[0] + 1);
    for (int i = L; i <= x; ++i)
        ans = (ans + f[i]) % mod;
    cout << ans * inv % mod;
}
```

**核心思想**：
- 预处理逆元避免重复计算
- 正向背包式更新保证无后效性
- 线性扫描答案区间求和

---

## 相似题目推荐

1. **洛谷P1044** - 栈序列计数（线性DP）
2. **洛谷P1832** - 平方数分解（完全背包）
3. **洛谷P1365** - 期望概率DP

---

## 可视化设计说明

### 动态规划动画方案

**界面布局**：
1. 顶部：时间轴滑块控制动画进度
2. 主区域：
   - 左侧：DP数组可视化（0~X的格子）
   - 右侧：当前更新说明与参数显示
3. 控制面板：播放/暂停/步进/速度调节

**动画逻辑**：
1. 初始高亮 `f[0] = 1`（绿色）
2. 每个时间步 `i` 遍历所有歌曲时长 `T_j`
3. 当处理 `i -> i+T_j` 时：
   - 原位置 `i` 闪烁黄色
   - 目标位置 `i+T_j` 显示红色边框
   - 显示数值增量过程
4. 答案区间用蓝色背景高亮

**音效设计**：
- 转移时：8-bit风格 "blip" 音效
- 区间求和：收集金币音效
- 错误操作：经典FC错误音

---

## 个人心得摘录

> "第一次尝试二维DP导致TLE，发现维护sum数组可以将复杂度从O(N^2X)优化到O(NX)，关键在于发现各歌曲转移的共性特征。" —— 题解作者调试经历

> "容易忽略X<T_1时的边界情况，需要特判直接返回1/N的逆元。" —— 某题解作者踩坑总结

> "将连续时间离散化处理是本题最关键的建模突破点，0.5秒的偏移量设计非常巧妙。" —— 解题思路提炼

---
处理用时：82.55秒
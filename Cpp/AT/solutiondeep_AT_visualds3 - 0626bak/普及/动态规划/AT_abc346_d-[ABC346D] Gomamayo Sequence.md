# 题目信息

# [ABC346D] Gomamayo Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc346/tasks/abc346_d

`0`, `1` からなる長さ $ N $ の文字列 $ S $ が与えられます。

`0`, `1` からなる長さ $ N $ の文字列 $ T $ は以下の条件を満たすとき、またそのときに限り **良い文字列** であると定義します。

- $ 1\ \leq\ i\ \leq\ N\ -\ 1 $ を満たす整数 $ i $ であって、$ T $ の $ i $ 文字目と $ i\ +\ 1 $ 文字目が一致するようなものがちょうど $ 1 $ つ存在する。
 
$ i\ =\ 1,2,\ldots,\ N $ について以下の操作を $ 1 $ 度行うか行わないか選ぶことができます。

- $ S $ の $ i $ 文字目が `0` であるとき $ S $ の $ i $ 文字目を `1` に、そうでないとき $ S $ の $ i $ 文字目を `0` に置き換える。操作を行った場合、$ C_i $ のコストがかかる。
 
$ S $ を良い文字列にするために必要なコストの総和の最小値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ S $ は長さ $ N $ の `0`,`1` からなる文字列
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- $ N,\ C_i $ は整数
 
### Sample Explanation 1

$ i\ =\ 1,\ 5 $ に対して操作を行い、$ i\ =\ 2,\ 3,\ 4 $ に対して操作を行わないことで $ S\ = $ `10010` となり、$ S $ は良い文字列となります。このときかかるコストは $ 7 $ であり、コスト $ 7 $ 未満で $ S $ を良い文字列にすることはできないため、$ 7 $ を出力します。

## 样例 #1

### 输入

```
5

00011

3 9 2 6 4```

### 输出

```
7```

## 样例 #2

### 输入

```
4

1001

1 2 3 4```

### 输出

```
0```

## 样例 #3

### 输入

```
11

11111100111

512298012 821282085 543342199 868532399 690830957 973970164 928915367 954764623 923012648 540375785 925723427```

### 输出

```
2286846953```

# AI分析结果



# 题目重写

## [ABC346D] Gomamayo序列

### 题目描述

给定一个长度为 $N$ 的由 `0` 和 `1` 组成的字符串 $S$。

定义满足以下条件的字符串 $T$ 为**好字符串**：
- 存在且仅存在一个整数 $i$（$1 \leq i \leq N-1$），使得 $T$ 的第 $i$ 个字符与第 $i+1$ 个字符相同。

对于每个位置 $i$（$1 \leq i \leq N$），可以进行以下操作（可选）：
- 若 $S_i$ 为 `0`，将其变为 `1`，花费 $C_i$ 的代价；
- 若 $S_i$ 为 `1`，将其变为 `0`，花费 $C_i$ 的代价。

求将 $S$ 变为好字符串所需的最小总代价。

### 输入格式
- 第一行输入整数 $N$
- 第二行输入字符串 $S$
- 第三行输入 $N$ 个整数组成的数组 $C$

### 输出格式
输出最小代价

### 样例解释
样例1中，将第1和5位翻转得到"10010"，总代价3+4=7，满足恰好有一对相邻相同（第3-4位的0）

---

# 算法分类：线性DP

---

# 综合分析

### 核心难点
需要构造的字符串必须满足：
1. 恰好存在一个相邻相同字符对
2. 其余所有相邻字符必须交替（01或10模式）

### 状态设计
采用三维动态规划：
```
f[i][cur][state] 表示前i个字符：
- cur ∈ {0,1}：第i位最终字符
- state ∈ {0,1}：是否已经出现过相邻相同对
```

### 状态转移方程
对于第i位字符s[i]：
```cpp
// 当前字符不翻转的情况
if (保持原字符) {
    f[i][cur][0] = min(f[i-1][!cur][0])  // 延续交替模式
    f[i][cur][1] = min(已出现相同对的状态转移)
}
// 当前字符翻转的情况 
else {
    类似处理，并累加翻转代价c[i]
}
```

### 可视化设计思路
1. **DP矩阵网格**：用Canvas绘制二维网格，行表示字符位置，列表示状态组合（cur×state）
2. **颜色编码**：
   - 绿色：有效转移路径
   - 红色：无效状态
   - 黄色：当前正在更新的状态单元
3. **动效演示**：
   - 步进式显示每个字符位置的状态更新
   - 高亮显示状态转移来源（前驱状态）

---

# 题解清单（4星及以上）

### 1. 2huk（★★★★☆）
**亮点**：
- 简洁的三维状态设计，逻辑清晰
- 代码中直接处理字符比较，避免预处理
- 转移方程数学化表达，便于理解

```cpp
// 状态转移核心代码
f[i][0][0] = f[i-1][1][0] + (s[i] == '1') * c[i];
f[i][1][0] = f[i-1][0][0] + (s[i] == '0') * c[i]; 
f[i][0][1] = min(f[i-1][1][1], f[i-1][0][0]) + (s[i] == '1') * c[i];
f[i][1][1] = min(f[i-1][0][1], f[i-1][1][0]) + (s[i] == '0') * c[i];
```

### 2. KSCD_（★★★★☆）
**亮点**：
- 详细的状态转移说明
- 初始化处理明确（第一位的两种可能）
- 代码包含完整输入输出处理

```cpp
// 初始化处理
f[1][0][a[1]] = 0;
f[1][0][!a[1]] = c[1];
f[1][1][a[1]] = INF; // 无效状态设为极大值
```

### 3. JuRuoOIer（★★★★☆）
**亮点**：
- 提供DP和前缀和两种解法
- 包含详细的分情况讨论
- 代码结构清晰，注释明确

```cpp
// 前缀和解法核心
pre[i][0] = 前i位变为01交替模式的代价
suf[i][1] = 后i位变为10交替模式的代价
ans = min(pre[i] + suf[i+1]) 枚举所有可能的分界点
```

---

# 最优思路提炼

### 关键技巧
1. **状态压缩**：将是否出现相同对的标记压缩为二进制状态
2. **滚动数组优化**：由于只需要前一位状态，可用两行数组交替计算
3. **位运算加速**：使用异或运算快速计算交替模式需求

### 思维突破点
理解最终合法字符串的结构必然形如：
```
[完美交替段] + [连续相同对] + [完美交替段]
```
通过DP同时维护"是否已经出现关键对"的状态，确保最终状态为1。

---

# 同类型题目推荐

1. **LeetCode 256. 粉刷房子**  
   （线性DP，维护不同颜色选择的状态）

2. **洛谷 P1434 最长公共子序列**  
   （经典二维线性DP模型）

3. **Codeforces 455A Boredom**  
   （线性DP结合计数统计）

---

# 可视化实现方案（复古像素版）

### 界面设计
```html
<canvas id="dp-grid"></canvas>
<div class="control-panel">
  <button onclick="step()">▶️ 步进</button>
  <input type="range" id="speed" min="1" max="5">
</div>
<audio id="sfx-update" src="blip.wav"></audio>
```

### 核心动画逻辑
```javascript
function drawGrid() {
  // 绘制8-bit风格网格
  ctx.fillStyle = '#8B8B83'; // 复古灰
  // 绘制状态格子...
}

function updateState(i, cur, state) {
  // 播放音效
  sfxUpdate.currentTime = 0;
  sfxUpdate.play();
  
  // 高亮当前更新单元
  ctx.fillStyle = '#FFD700'; // 金色
  fillRect(...);
  
  // 绘制转移箭头
  drawArrow(fromCell, toCell); 
}
```

### 音效设计
- **状态更新**：8-bit风格的"哔"声（440Hz方波）
- **找到最优解**：上升音阶（C大调琶音）
- **错误操作**：低音爆破声

---

# 个人心得摘录

### 调试经验
"在初始化时忘记将无效状态设为INF，导致错误地计算了最小值。通过打印DP表发现部分状态被0污染。" —— KSCD_题解

### 思维突破
"意识到可以将'是否出现过相同对'作为独立状态，这是将O(n^2)暴力优化为O(n)的关键。" —— 2huk题解

### 优化技巧
"通过观察发现，交替模式的前后缀代价可以预处理，将双重循环优化为线性时间。" —— JuRuoOIer题解

---

# 核心代码实现

### 线性DP标准解法
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const ll INF = 1e18;

int main() {
    int n; 
    string s;
    cin >> n >> s;
    vector<ll> c(n);
    for (auto& x : c) cin >> x;

    // DP数组初始化
    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(2, vector<ll>(2, INF)));
    
    // 处理第一个字符
    int first = s[0] - '0';
    dp[0][first][0] = 0;          // 不翻转
    dp[0][first^1][0] = c[0];      // 翻转
    
    for (int i = 1; i < n; ++i) {
        int cur = s[i] - '0';
        for (int prev : {0, 1}) {   // 前一个字符的状态
            for (int state : {0, 1}) { // 是否已有相同对
                if (dp[i-1][prev][state] == INF) continue;
                
                // 不翻转当前字符
                if (cur == prev) { // 出现相同对
                    if (state == 0) { // 首次出现
                        dp[i][cur][1] = min(dp[i][cur][1], dp[i-1][prev][state]);
                    }
                } else { // 保持交替
                    dp[i][cur][state] = min(dp[i][cur][state], dp[i-1][prev][state]);
                }
                
                // 翻转当前字符（需花费c[i]）
                int flip = cur ^ 1;
                if (flip == prev) { // 翻转后出现相同对
                    if (state == 0) {
                        dp[i][flip][1] = min(dp[i][flip][1], dp[i-1][prev][state] + c[i]);
                    }
                } else { // 翻转后保持交替
                    dp[i][flip][state] = min(dp[i][flip][state], dp[i-1][prev][state] + c[i]);
                }
            }
        }
    }
    
    ll ans = min(dp[n-1][0][1], dp[n-1][1][1]);
    cout << ans << endl;
}
```

### 代码亮点
1. 三维DP数组清晰表达状态组合
2. 双重循环遍历所有可能的前驱状态
3. 同时处理翻转与不翻转的情况
4. 严格的状态有效性检查（INF跳过无效状态）

---
处理用时：107.23秒
# 题目信息

# [ABC365D] AtCoder Janken 3

## 题目描述

高桥和青木玩了 $N$ 次石头剪刀布。注：在这个游戏中，石头赢剪刀，剪刀赢纸，纸赢石头。

青木的动作由长度为 $N$ 的字符串 $S$ 表示，字符串由 `R`、`P` 和 `S` 组成。$S$ 中的第 $i$ 个字符表示青木在第 $i$ 盘棋局中的棋步：`R` 表示石头，`P` 表示 纸，`S` 表示剪刀。

高桥的棋步满足以下条件：

- 高桥从未输给过青木。
- 对于 $i=1,2,…,N−1$，高桥在第 $i$ 对局中的棋步与他在第 $i+1$ 对局中的棋步不同。

求高桥可能赢的最大对局数。

可以保证存在一个满足上述条件的高桥下棋顺序。

## 说明/提示

$1 \le n \le 2\times 10^5$

## 样例 #1

### 输入

```
6

PRSSRS```

### 输出

```
5```

## 样例 #2

### 输入

```
10

SSSSSSSSSS```

### 输出

```
5```

## 样例 #3

### 输入

```
24

SPRPSRRRRRPPRPRPSSRSPRSS```

### 输出

```
18```

# AI分析结果



0. **题目翻译**  
# [ABC365D] AtCoder Janken 3

## 题目描述

高桥和青木进行了 $N$ 次石头剪刀布游戏。游戏规则如下：石头赢剪刀，剪刀赢布，布赢石头。

青木的出法由长度为 $N$ 的字符串 $S$ 表示，字符串由 `R`（石头）、`P`（布）和 `S`（剪刀）组成。$S$ 的第 $i$ 个字符表示青木在第 $i$ 轮使用的招式。

高桥的出法需满足以下条件：
- 高桥从未输给过青木（允许平局）。
- 对于 $i=1,2,...,N-1$，高桥在第 $i$ 轮和第 $i+1$ 轮的招式必须不同。

请计算高桥可能获得的最大胜利次数。

## 输入输出样例
（样例内容与原文保持一致）

---

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**  
**核心思路**：  
所有题解均采用动态规划（DP）解法。通过定义 `dp[i][j]` 表示第 `i` 轮选择招式 `j` 时的最大胜利次数（`j` 为石头/布/剪刀或平局/胜利状态）。状态转移时需满足相邻招式不同且不输的条件。

**关键难点与解决方案**：
- **状态设计**：多数题解采用三维状态（石头、布、剪刀）或二维状态（平局、胜利），通过枚举当前轮次可能的合法招式进行转移。
- **转移方程**：当青木出 `R` 时，高桥只能出 `R`（平局）或 `P`（胜利）。胜利时从之前非 `P` 的状态转移并+1，平局则从非 `R` 的状态转移。
- **空间优化**：部分题解使用滚动数组优化空间，将二维数组压缩为两个一维数组。

**可视化设计**：
- **动态矩阵展示**：用网格显示 `dp[i][j]` 的值，高亮当前轮次更新的格子，箭头标注转移来源。
- **颜色编码**：绿色表示胜利+1，黄色表示平局，红色表示非法转移。
- **音效互动**：在状态更新时播放不同音效（如胜利时的"叮"声，非法时的"哔"声）。

---

3. **题解清单 (≥4星)**  
- **xhxxwcr (4★)**：  
  亮点：首创二维状态设计（平局/胜利），代码简洁，转移逻辑清晰。  
  改进：初始条件处理需注意索引从1开始。  

- **Pink_Cut_Tree (5★)**：  
  亮点：三维状态设计直观，引入 `inf` 处理非法状态，代码鲁棒性强。  
  示例代码片段：  
  ```cpp
  if(s[i]=='R'){
    dp[i][0] = max(dp[i-1][1], dp[i-1][2]);
    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + 1;
  }
  ```

- **I_Love_DS (4★)**：  
  亮点：通过映射表处理招式关系，代码可扩展性强。  
  关键映射：  
  ```cpp
  m1['R'] = 'P'; // 能击败R的招式是P
  ```

---

4. **最优思路提炼**  
- **状态压缩**：仅需保留前一层的状态，空间复杂度从 O(N) 优化到 O(1)。
- **招式预判**：建立 `beat[char]` 数组预处理每个招式对应的胜利招式。
- **非法剪枝**：在转移时直接跳过会导致失败的状态（如青木出R时高桥出S）。

**核心代码实现**：
```cpp
int dp[3] = {0}; // 滚动数组
for(int i=0; i<n; ++i){
    int new_dp[3] = {-INF};
    char c = s[i];
    for(int prev : {0,1,2}){
        for(int curr : {0,1,2}){
            if(curr == prev) continue; // 相邻相同跳过
            if(!is_win(curr, c) && !is_draw(curr, c)) continue; // 不能输
            int gain = (is_win(curr, c)) ? 1 : 0;
            new_dp[curr] = max(new_dp[curr], dp[prev] + gain);
        }
    }
    memcpy(dp, new_dp, sizeof(dp));
}
```

---

5. **同类型题推荐**  
- [AT_dp_c](https://atcoder.jp/contests/dp/tasks/dp_c)（旅行计划，线性DP经典题）  
- [LeetCode 213. House Robber II](https://leetcode.com/problems/house-robber-ii/)（环形DP状态设计）  
- [洛谷 P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)（双向线性DP）

---

6. **可视化与算法演示**  
**动画方案**：  
1. 初始化3×N的网格，列表示轮次，行表示石头/布/剪刀。  
2. 逐帧更新每个单元格的值，用颜色区分：  
   - 绿色：当前选择导致胜利  
   - 黄色：平局  
   - 灰色：非法状态  
3. 用箭头连接前一轮的合法状态到当前状态。  

**复古像素风格实现**：  
```javascript
// 伪代码：Canvas绘制DP网格
ctx.fillStyle = '#8B00FF'; // 紫色背景
ctx.fillRect(0, 0, 480, 320);

// 绘制网格线
for(let i=0; i<=n; i++){
    ctx.strokeStyle = '#00FF00';
    ctx.beginPath();
    ctx.moveTo(i*40, 0); 
    ctx.lineTo(i*40, 240);
    ctx.stroke();
}

// 更新单元格时播放音效
if(gain) playSound('coin.wav');
else playSound('blip.wav');
```

---

7. **个人心得摘录**  
> "本题看似简单，但初始条件处理极易出错。我在WA三次后发现`dp[1][1]`应初始化为1而非0。" ——xhxxwcr  
> "将布定义为1，石头0，剪刀2，通过取模运算处理循环关系，极大简化了代码" ——Pink_Cut_Tree

---

8. **推荐练习**  
1. [洛谷 P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)  
2. [洛谷 P1434 滑雪](https://www.luogu.com.cn/problem/P1434)  
3. [洛谷 P2196 挖地雷](https://www.luogu.com.cn/problem/P2196)

---
处理用时：92.21秒
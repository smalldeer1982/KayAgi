# 题目信息

# [ABC369D] Bonus EXP

## 题目描述

高桥君遇到了 $N$ 只怪物，依次遇到每一只怪物，第 $i$ 只怪物的强度为 $A_i$。

高桥君可以选择对每只怪物是放走还是击败。  
高桥君通过以下的方式获得经验值：

- 如果选择放走怪物，获得的经验值为 $0$。
- 如果击败强度为 $X$ 的怪物，他可以获得 $X$ 的经验值。但是，如果这是他第偶数次击败怪物（即第 $2$ 次、第 $4$ 次、……），他将额外获得 $X$ 的经验值。

请计算高桥君通过击败怪物可以获得的最大总经验值。

## 说明/提示

### 约束条件

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq A_i \leq 10^9$
- 输入的所有数值均为整数

### 样例解释 1

在击败第 1、2、3、5 只怪物并放走第 4 只怪物时，高桥君可以按如下方式获得经验值： 
- 击败强度为 $A_1=1$ 的怪物，获得 $1$ 的经验值。
- 击败强度为 $A_2=5$ 的怪物，获得 $5$ 的经验值。这是高桥君第 2 次击败怪物，因此额外获得 $5$ 的经验值。
- 击败强度为 $A_3=3$ 的怪物，获得 $3$ 的经验值。
- 放走第 4 只怪物，高桥君不获得经验值。
- 击败强度为 $A_5=7$ 的怪物，获得 $7$ 的经验值。这是高桥君第 4 次击败怪物，因此额外获得 $7$ 的经验值。

因此，总共获得的经验值为 $1+(5+5)+3+0+(7+7)=28$。  
由于无论如何行动，总经验值都不会超过 $28$，所以输出 $28$。

请注意，如果击败所有怪物，获得的经验值为 $1+(5+5)+3+(2+2)+7=25$。

### 样例解释 2

请注意，答案可能会超过 32 位整数型的范围。

## 样例 #1

### 输入

```
5

1 5 3 2 7```

### 输出

```
28```

## 样例 #2

### 输入

```
2

1000000000 1000000000```

### 输出

```
3000000000```

# AI分析结果



# 题目翻译

## 题目描述

高桥君遇到了 $N$ 只怪物，依次遇到每一只怪物，第 $i$ 只怪物的强度为 $A_i$。

高桥君可以选择对每只怪物是放走还是击败。  
高桥君通过以下的方式获得经验值：

- 如果选择放走怪物，获得的经验值为 $0$。
- 如果击败强度为 $X$ 的怪物，他可以获得 $X$ 的经验值。但是，如果这是他第偶数次击败怪物（即第 $2$ 次、第 $4$ 次、……），他将额外获得 $X$ 的经验值。

请计算高桥君通过击败怪物可以获得的最大总经验值。

## 说明/提示

### 约束条件

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq A_i \leq 10^9$
- 输入的所有数值均为整数

### 样例解释 1

在击败第 1、2、3、5 只怪物并放走第 4 只怪物时，高桥君可以按如下方式获得经验值： 
- 击败强度为 $A_1=1$ 的怪物，获得 $1$ 的经验值。
- 击败强度为 $A_2=5$ 的怪物，获得 $5$ 的经验值。这是高桥君第 2 次击败怪物，因此额外获得 $5$ 的经验值。
- 击败强度为 $A_3=3$ 的怪物，获得 $3$ 的经验值。
- 放走第 4 只怪物，高桥君不获得经验值。
- 击败强度为 $A_5=7$ 的怪物，获得 $7$ 的经验值。这是高桥君第 4 次击败怪物，因此额外获得 $7$ 的经验值。

因此，总共获得的经验值为 $1+(5+5)+3+0+(7+7)=28$。  
由于无论如何行动，总经验值都不会超过 $28$，所以输出 $28$。

请注意，如果击败所有怪物，获得的经验值为 $1+(5+5)+3+(2+2)+7=25$。

### 样例解释 2

请注意，答案可能会超过 32 位整数型的范围。

## 样例 #1

### 输入

```
5
1 5 3 2 7
```

### 输出

```
28
```

## 样例 #2

### 输入

```
2
1000000000 1000000000
```

### 输出

```
3000000000
```

---

# 算法分类：线性DP

---

# 综合分析与结论

## 核心思路与难点
**问题核心**：在顺序选择的序列中，通过动态规划维护击败次数的奇偶性状态，最大化经验值。  
**关键难点**：偶数次击败的额外奖励需要与前序决策状态联动，需设计能体现奇偶性变化的状态转移方程。

## 动态规划设计
1. **状态定义**：
   - `dp[i][0]`：前 `i` 个怪物中，总共击败了偶数次时的最大经验值。
   - `dp[i][1]`：前 `i` 个怪物中，总共击败了奇数次时的最大经验值。

2. **状态转移方程**：
   - **不选第 `i` 个怪物**：状态直接继承前一步的值。
   - **选第 `i` 个怪物**：
     - 若当前为奇数次击败，则经验增加 `a_i`（由前一步的偶数次转移）。
     - 若当前为偶数次击败，则经验增加 `2*a_i`（由前一步的奇数次转移）。
   ```
   dp[i][0] = max(dp[i-1][0], dp[i-1][1] + 2*a_i)
   dp[i][1] = max(dp[i-1][1], dp[i-1][0] + a_i)
   ```

3. **边界处理**：
   - 初始化 `dp[0][1] = -inf`（不可能存在击败 0 次但状态为奇数次的情况）。

## 可视化设计思路
**动态规划矩阵动画**：
- **网格展示**：用二维网格表示 `dp[i][0]` 和 `dp[i][1]`，每个格子显示当前最大值。
- **颜色标记**：
  - 绿色：当前更新的状态。
  - 黄色：参与转移的前序状态。
- **步进效果**：每一步展示如何从 `i-1` 转移到 `i`，高亮箭头表示转移来源。

**复古像素风格**：
- **Canvas 绘制**：将 DP 数组渲染为 8-bit 像素块，每个块显示数值。
- **音效设计**：
  - 状态转移时播放 "blip" 音效。
  - 更新最大值时播放 "coin" 音效（类似经典游戏奖励音效）。
- **自动演示模式**：按固定时间间隔自动执行转移步骤，展示算法运行流程。

---

# 题解清单（≥4星）

## 1. Alcl000000（5星）
**亮点**：状态转移方程简洁，代码可读性极强，初始化处理清晰。
```cpp
long long f[200005][2];
for (int i=1;i<=n;i++){
    f[i][0]=max(f[i-1][0], f[i-1][1]+a[i]);
    f[i][1]=max(f[i-1][1], f[i-1][0]+2*a[i]);
}
```

## 2. ma_niu_bi（4.5星）
**亮点**：代码结构清晰，初始化采用 `memset` 显式处理边界。
```cpp
memset(dp, -0x3f, sizeof(dp));
dp[0][0] = 0;
for (int i=1; i<=n; i++) {
    dp[i][1] = max(dp[i-1][1], dp[i-1][0] + a[i]);
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + 2 * a[i]); 
}
```

## 3. _H17_（4星）
**亮点**：注释明确，变量命名规范，适合教学。
```cpp
// dp[i][0]: 偶数次击败的最大经验
// dp[i][1]: 奇数次击败的最大经验
f[0][1] = -1e18;
for(int i=1;i<=n;i++){
    f[i][0] = max(f[i-1][0], f[i-1][1] + 2*a[i]);
    f[i][1] = max(f[i-1][1], f[i-1][0] + a[i]);
}
```

---

# 最优代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
ll dp[N][2];

int main() {
    int n; 
    cin >> n;
    dp[0][1] = -1e18; // 初始化非法状态
    for (int i=1; i<=n; i++) {
        ll x; 
        cin >> x;
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + 2*x);
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] + x);
    }
    cout << max(dp[n][0], dp[n][1]);
    return 0;
}
```

---

# 同类型题推荐
1. **P1216 数字三角形**（线性DP，路径选择）
2. **P1280 尼克的任务**（时间轴DP）
3. **P1091 合唱队形**（双向线性DP）

---

# 个人心得摘录
> "初始化 `dp[0][1] = -inf` 是关键，否则第一个怪物作为偶数次击败会被错误计算。" —— Alcl000000  
> "二维数组维度小的放前面可以优化缓存命中率。" —— sakura_21  
> "击败偶数次时，必须从奇数次转移而来，这一对称性是解题的核心。" —— Genius_Star

---

# 可视化与交互设计（伪代码示例）

```javascript
// Canvas 初始化
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 40;

function drawGrid(dp) {
    for (let i=0; i<=n; i++) {
        // 绘制 dp[i][0] 和 dp[i][1] 的像素块
        ctx.fillStyle = (i%2 === 0) ? '#88FF88' : '#FF8888';
        ctx.fillRect(i*CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
        ctx.fillText(dp[i][0], i*CELL_SIZE+5, 20);
        ctx.fillText(dp[i][1], i*CELL_SIZE+5, 60);
    }
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}

// 自动演示循环
let currentStep = 0;
function autoStep() {
    if (currentStep > n) return;
    updateDP(currentStep);
    drawGrid(dp);
    playSound('blip');
    currentStep++;
    setTimeout(autoStep, 1000);
}
```

---
处理用时：110.43秒
# 题目信息

# [ABC375E] 3 Team Division

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc375/tasks/abc375_e

$ N $ 人の人がおり、$ 3 $ つのチームに分かれています。

人には $ 1,\ 2,\ \ldots,\ N $ の番号、チームには $ 1,\ 2,\ 3 $ の番号がついており、現在人 $ i $ はチーム $ A_i $ に所属しています。

各人には**強さ**という値が定まっており、人 $ i $ の強さは $ B_i $ です。また、チームの**強さ**をチームに所属する人の強さの和として定めます。

$ 0 $ 人以上の人が所属するチームを変更することですべてのチームの強さが等しくなるようにできるか判定してください。すべてのチームの強さが等しくなるようにできる場合は所属するチームを変更する人数として考えられる最小値を求めてください。

ただし、チーム $ 1,\ 2,\ 3 $ の他に新たにチームを作ることはできません。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 100 $
- $ A_i\ \in\ \lbrace\ 1,\ 2,\ 3\ \rbrace $
- 各 $ x\ \in\ \lbrace\ 1,\ 2,\ 3\ \rbrace $ に対し、ある $ i $ が存在して $ A_i\ =\ x $
- $ 1\ \leq\ B_i $
- $ \displaystyle\sum_{i\ =\ 1}^{N}\ B_i\ \leq\ 1500 $
- 入力される値はすべて整数
 
### Sample Explanation 1

人 $ 1 $ がチーム $ 3 $、人 $ 4 $ がチーム $ 2 $ へと所属するチームを変更することですべてのチームの強さが $ 8 $ となります。

## 样例 #1

### 输入

```
6

1 2

2 5

1 5

3 3

1 3

3 6```

### 输出

```
2```

## 样例 #2

### 输入

```
4

1 1

1 2

2 3

3 4```

### 输出

```
-1```

## 样例 #3

### 输入

```
3

1 1

2 1

3 1```

### 输出

```
0```

## 样例 #4

### 输入

```
12

2 5

1 4

3 3

2 3

3 9

1 2

2 2

3 9

2 6

1 9

1 1

3 1```

### 输出

```
3```

# AI分析结果



0. **题目翻译**  
```plaintext
# [ABC375E] 三队分配

## 题目描述

现有 N 个人被分到三个队伍中。人员编号为 1 至 N，队伍编号为 1 至 3。初始时，第 i 个人属于队伍 A_i。

每个人员有确定的**强度**值，第 i 人的强度为 B_i。队伍强度定义为该队所有成员强度之和。

请判断是否可以通过改变 0 个或多个人员所属队伍，使得三个队伍的强度相等。若可行，求达成目标所需改变人数的最小值。注意不能创建除 1,2,3 号队伍外的新队伍。

## 输入输出格式

输入包含：
- 首行为整数 N
- 后续 N 行每行两个整数 A_i 和 B_i，表示初始所属队伍及强度

输出：
- 若无法达成输出 -1，否则输出最小改变人数

## 说明/提示

### 约束
- 3 ≤ N ≤ 100
- 各 B_i 之和 ≤ 1500
- 每个队伍初始至少有 1 人

### 样例解释 1
改变人员 1 至队伍 3，人员 4 至队伍 2 后，三个队伍强度均为 8。
```

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**  
**核心思路**：  
- 总强度必须为 3 的倍数，否则直接返回 -1  
- 采用三维动态规划 `dp[i][j][k]` 表示处理前 i 人，队伍1强度为 j，队伍2强度为 k 时的最小改变次数  
- 通过固定第三队强度（总强度 - j - k）省略一维状态，复杂度优化至 O(n * (sum/3)^2)  

**关键状态转移**：  
```math
dp[i][j][k] = min(
    dp[i-1][j-b_i][k] + (原队伍≠1),  // 将 i 加入队伍1
    dp[i-1][j][k-b_i] + (原队伍≠2),  // 将 i 加入队伍2
    dp[i-1][j][k] + (原队伍≠3)      // 将 i 保留在队伍3
)
```

**可视化设计**：  
- **像素网格**：在 Canvas 上绘制二维 DP 矩阵，每个格子表示 (j, k) 状态，颜色深浅表示操作次数  
- **动态高亮**：处理第 i 人时，用闪烁边框标记当前更新的格子，红色箭头表示转移来源  
- **音效系统**：  
  - 成功转移时播放 "哔" 声  
  - 发现更优解时触发 "叮咚" 音效  
  - 最终找到解时播放 FC 风格胜利音乐  

---

3. **题解清单 (≥4星)**  
1. **Binah_cyc 题解（★★★★☆）**  
   - 亮点：状态压缩清晰，代码结构简洁  
   - 关键代码段：  
     ```cpp
     if(j>=b[i]) dp[i][j][k] = min(..., dp[i-1][j-b[i]][k] + (a[i]!=1)); 
     if(k>=b[i]) dp[i][j][k] = min(..., dp[i-1][j][k-b[i]] + (a[i]!=2));
     ```

2. **liuziqin 题解（★★★★☆）**  
   - 亮点：分情况讨论转移逻辑，适合教学理解  
   - 个人心得：通过前缀和计算第三队强度，避免冗余判断  

---

4. **核心代码实现**  
以 Binah_cyc 的优化代码为例：
```cpp
memset(dp, 0x3f, sizeof(dp));
dp[0][0][0] = 0;
int sum = accumulate(b+1, b+n+1, 0);
if(sum % 3 != 0) return -1;
sum /= 3;

for(int i=1; i<=n; ++i) {
    for(int j=0; j<=sum; ++j) {
        for(int k=0; k<=sum; ++k) {
            // 转移至队伍1
            if(j >= b[i]) dp[i][j][k] = min(dp[i][j][k], 
                dp[i-1][j-b[i]][k] + (a[i]!=1));
            // 转移至队伍2 
            if(k >= b[i]) dp[i][j][k] = min(dp[i][j][k],
                dp[i-1][j][k-b[i]] + (a[i]!=2));
            // 留在原队伍3
            dp[i][j][k] = min(dp[i][j][k], 
                dp[i-1][j][k] + (a[i]!=3));
        }
    }
}
```

---

5. **同类型题目推荐**  
1. [洛谷 P1048 - 采药](https://www.luogu.com.cn/problem/P1048)（0-1背包）  
2. [LeetCode 416 - Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)  
3. [CF 687B - Remainders Game](https://codeforces.com/problemset/problem/687/B)（模数分组）

---

6. **可视化代码片段**  
JavaScript 核心动画逻辑：
```javascript
class DPGrid {
    constructor(canvas, sum) {
        this.cellSize = 20;
        this.grid = new Array(sum).fill().map(() => 
            new Array(sum).fill(Infinity));
        // 初始化 Canvas 绘制...
    }

    updateStep(i, j, k, value) {
        // 高亮当前格子
        ctx.fillStyle = `hsl(${240 * (1 - value/maxValue)}, 70%, 50%)`;
        ctx.fillRect(j*cellSize, k*cellSize, cellSize, cellSize);
        // 触发音效
        if(value < prevValue) playSound('upgrade');
    }
}
```

---

7. **总结**  
本题通过压缩状态维度实现高效线性 DP，其核心在于合理设计状态表示与转移方程。在类似分组问题中，固定部分状态、利用问题对称性是常见优化手段。

---
处理用时：84.42秒
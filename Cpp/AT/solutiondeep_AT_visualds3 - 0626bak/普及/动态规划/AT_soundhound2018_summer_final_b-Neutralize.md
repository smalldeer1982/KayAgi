# 题目信息

# Neutralize

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_b

$ N $ 個の薬品が横一列に並んでいます。それぞれの薬品には *効用* という整数値が定まっており、左から $ i $ 番目の薬品の現在の効用は $ b_i $ です。これらの値は正とは限りません。

Kenkoooo さんは、横長の特殊な装置を用いて次の操作を何回でも行えます（行わなくても構いません）。

- 連続して並ぶ $ K $ 個の薬品を選ぶ。選ばれた薬品の効用はすべて $ 0 $ となる。

なお、薬品を移動させることは危険を伴うためできません。

その後、Kenkoooo さんは $ N $ 個の薬品すべてを飲み干します。その前に、$ N $ 個の薬品の効用の和を可能な限り大きくしておきたいです。操作後のこの和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ K\ <\ =\ N\ <\ =\ 2\ ×\ 10^5 $
- $ -10^9\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力中の値はすべて整数である。

### Sample Explanation 1

最適な手順の例を示します。 - $ 1 $ 回目の操作: 左から $ 1,\ 2,\ 3 $ 番目の薬品を選ぶ。 - $ 2 $ 回目の操作: 左から $ 6,\ 7,\ 8 $ 番目の薬品を選ぶ。 - $ 3 $ 回目の操作: 左から $ 7,\ 8,\ 9 $ 番目の薬品を選ぶ。 このとき、$ 9 $ 個の薬品の効用の和は $ 0\ +\ 0\ +\ 0\ +\ 4\ +\ 5\ +\ 0\ +\ 0\ +\ 0\ +\ 0\ =\ 9 $ となります。

### Sample Explanation 2

何もせずこのまま薬品を飲み干すべきです。

## 样例 #1

### 输入

```
9 3

-1

-2

-3

4

5

-6

-7

-8

-9```

### 输出

```
9```

## 样例 #2

### 输入

```
5 4

-1

-1

5

-1

-1```

### 输出

```
1```

## 样例 #3

### 输入

```
9 5

30

-20

40

60

-90

50

-40

10

70```

### 输出

```
120```

## 样例 #4

### 输入

```
10 1

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000

1000000000

-1000000000```

### 输出

```
5000000000```

# AI分析结果



0. **题目翻译**

---

# Neutralize

## 题目描述

$ N $ 个药品排成一列，每个药品有整数类型的**效用**值。左起第 $ i $ 个药品的当前效用为 $ b_i $（可能为负数）。Kenkoooo 可以使用特殊装置进行如下操作（次数不限）：

- 选取连续 $ K $ 个药品，将其效用全部置零。

操作后需使所有药品的效用之和最大化，求该最大值。

## 输入格式

第一行输入 $ N $ 和 $ K $，随后 $ N $ 行依次输入各药品的效用值。

## 输出格式

输出操作后的最大效用和。

## 样例 #1

输入：
```
9 3
-1
-2
-3
4
5
-6
-7
-8
-9
```
输出：
```
9
```

---

1. **唯一算法分类**  
**线性DP**

---

2. **综合分析与结论**  
### 算法核心思路  
问题本质是选择若干**不重叠或重叠的连续区间置零**，使得最终总和最大。动态规划通过定义两种状态刻画操作可能性：  
- `dp[i][0]`：前 `i` 个药品的最大和，允许自由选择是否在后续操作置零  
- `dp[i][1]`：前 `i` 个药品的最大和，且当前处于某个置零操作的覆盖范围内  

### 关键状态转移方程  
```math
dp[i+1][0] = max(dp[i][0], dp[i][1]) + b_i  
dp[i+1][1] = max(dp[i+1-K][0], dp[i][1])  (当 i+1 ≥ K 时)
```
**状态转移逻辑**：  
- `dp[i+1][0]`：当前药品未被置零，总效用在之前最优基础上累加  
- `dp[i+1][1]`：当前药品被置零，需确保其属于某个长为 K 的区间。该区间可从 `i+1-K` 处开始置零，或延续之前的置零操作  

### 可视化设计  
- **动态规划表格**：绘制二维网格，行表示药品索引，列表示两种状态。  
- **颜色标记**：  
  - 黄色高亮当前处理的药品索引  
  - 红色箭头表示从 `dp[i][0]` 转移  
  - 蓝色箭头表示从 `dp[i][1]` 转移  
- **复古像素风格**：用 8-bit 像素块表示状态值，每次更新时播放经典音效（如 FC 游戏金币声）  

### 动画控制  
- **步进模式**：用户可通过方向键逐帧观察状态转移  
- **自动演示**：按 A 键启动自动播放，动态展示最优区间选择过程  
- **音效触发**：状态更新时播放不同音调，最优解出现时播放胜利音乐  

---

3. **题解清单 (≥4星)**  
⭐️⭐️⭐️⭐️ **作者：__delta_epsilon__**  
- **亮点**：代码简洁高效，状态转移逻辑清晰，O(n) 时间复杂度完美适配数据规模  
- **关键代码**：  
  ```cpp
  for (int i = 0; i < n; i++) {
      dp[i + 1][0] = max(dp[i][0], dp[i][1]) + b[i];
      if (i + 1 - k >= 0)
          dp[i + 1][1] = max(dp[i + 1 - k][0], dp[i][1]);
  }
  ```

⭐️⭐️⭐️⭐️ **作者：std_qwq**  
- **亮点**：创新性利用单调队列优化，通过维护窗口最小值降低转移复杂度  
- **关键技巧**：将问题转化为最小化被清零部分，结合前缀和与滑动窗口  

---

4. **最优思路提炼**  
**核心技巧**：  
- **双状态设计**：通过 `0/1` 状态区分是否处于清零区间影响中，覆盖所有操作可能性  
- **逆向思维**：部分题解将最大化保留值转化为最小化清零值，简化状态转移  
- **边界处理**：初始化为极小值避免无效状态干扰，确保转移合法性  

---

5. **同类型题与算法套路**  
**相似问题特征**：  
- 操作涉及连续区间选择（如区间覆盖、区间删除）  
- 允许操作重叠或需要限制操作次数  

**通用解法**：  
1. 定义动态规划状态描述操作影响范围  
2. 利用前缀和/滑动窗口优化区间计算  
3. 通过状态压缩降低空间复杂度  

---

6. **推荐练习题**  
1. **P1115** 最大子段和（基础线性DP）  
2. **P2679** 子串（双状态DP+前缀和）  
3. **P2569** 交替选择问题（区间覆盖与状态转移）  

---

7. **个人心得摘录**  
> "初始化时负无穷要足够小，否则可能溢出导致错误结果。" —— All_Wrong_Answer  
> "将清零操作视为覆盖区间，通过状态设计自然处理重叠情况。" —— Starry_Ocean  

---

8. **代码实现（核心片段）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, k, b[200020], dp[200020][2];

signed main() {
    cin >> n >> k;
    for (int i = 0; i < n; ++i) cin >> b[i];
    memset(dp, 0x80, sizeof(dp)); // 初始化为极小值
    dp[0][0] = dp[0][1] = 0;
    for (int i = 0; i < n; ++i) {
        dp[i+1][0] = max(dp[i][0], dp[i][1]) + b[i];
        if (i+1 >= k) 
            dp[i+1][1] = max(dp[i+1-k][0], dp[i][1]);
    }
    cout << max(dp[n][0], dp[n][1]);
}
```

---
处理用时：111.62秒
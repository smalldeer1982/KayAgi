# 题目信息

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5```

### 输出

```
2```

## 样例 #3

### 输入

```
100000 1

1 100000 100```

### 输出

```
99999```

# AI分析结果



**算法分类**  
并查集

---

### **题解思路与核心难点**  
所有题解均基于并查集解决，核心思想是将条件约束转化为连通块关系。每对条件 $(X_i, Y_i)$ 无论 $Z_i$ 的值如何，均需合并到同一连通块，最终连通块数量即为最小魔法次数。  
**关键点**：  
1. **奇偶关系推导**：条件 $A_{X_i} + A_{Y_i} + Z_i$ 的奇偶性隐含 $A_{X_i}$ 和 $A_{Y_i}$ 的奇偶性关系，但无需记录具体关系，只需合并连通性。  
2. **连通块计数**：每个连通块只需确定一个节点的值即可推断所有节点，故答案为连通块数。  
**难点**：将条件隐含的奇偶约束抽象为连通性问题，忽略 $Z_i$ 的具体值，仅关注变量间的联系。

---

### **高星题解推荐 (≥4星)**  
1. **徐晨轩（5星）**  
   - **亮点**：代码简洁高效，直接使用并查集合并，路径压缩优化明确。  
   - **核心代码**：  
     ```cpp  
     void merge(int x, int y) {  
         int fx = find(x), fy = find(y);  
         if (fx != fy) f[fx] = fy;  
     }  
     ```  
2. **龙潜月十五（5星）**  
   - **亮点**：详细分析条件如何转化为奇偶关系，并给出样例推导。  
   - **核心代码**：  
     ```cpp  
     void con(int x, int y) {  
         x = find(x), y = find(y);  
         if (x != y) fa[x] = y;  
     }  
     ```  
3. **Take_A_Single_6（4星）**  
   - **亮点**：代码注释提醒输入索引调整，强调输出换行符。  
   - **核心代码**：  
     ```cpp  
     q[bcj(x--)] = bcj(y--);  // 注意输入从0开始处理  
     ```  

---

### **最优思路与技巧**  
- **并查集快速合并**：将每个条件视为边，合并对应节点。  
- **路径压缩优化**：确保查询时间复杂度接近常数。  
- **连通块计数**：遍历所有节点，统计根节点数量。  

---

### **同类型题与算法套路**  
- **通用解法**：涉及变量间约束关系的问题（如奇偶性、相等性）可转化为图论连通性问题。  
- **类似题目**：  
  1. 洛谷 P3367（并查集模板）  
  2. 洛谷 P1551（亲戚关系判断）  
  3. 洛谷 P1525（关押罪犯，扩展约束条件）  

---

### **可视化与算法演示**  
**动画设计**：  
1. **初始状态**：每个节点独立显示为不同颜色。  
2. **合并过程**：处理条件时，高亮 $X_i$ 和 $Y_i$，合并后显示同一颜色。  
3. **连通块统计**：最终用不同颜色区分各连通块，统计总数。  
**复古像素效果**：  
- **颜色方案**：每个连通块用不同 8-bit 颜色填充。  
- **音效**：合并时播放短促“连接”音效，统计时播放胜利音效。  
- **Canvas 绘制**：节点以网格排列，合并动画用像素块扩散效果。  

---

### **代码实现（核心逻辑）**  
```cpp  
#include <iostream>  
using namespace std;  
const int MAXN = 1e5 + 5;  
int parent[MAXN];  

int find(int x) {  
    if (parent[x] != x) parent[x] = find(parent[x]);  
    return parent[x];  
}  

void unite(int x, int y) {  
    x = find(x), y = find(y);  
    if (x != y) parent[x] = y;  
}  

int main() {  
    int n, m;  
    cin >> n >> m;  
    for (int i = 1; i <= n; ++i) parent[i] = i;  
    while (m--) {  
        int x, y, z;  
        cin >> x >> y >> z;  
        unite(x, y);  
    }  
    int ans = 0;  
    for (int i = 1; i <= n; ++i)  
        if (find(i) == i) ans++;  
    cout << ans << endl;  
    return 0;  
}  
```  

---

### **个人心得摘录**  
- **龙潜月十五**：通过样例推导发现条件可抽象为连通性，思维转换是解题关键。  
- **Take_A_Single_6**：强调输入索引调整和输出换行符，避免低级错误。  

---

### **总结**  
本题通过并查集将条件约束转化为连通块问题，统计连通块数即最优解。重点在于抽象奇偶关系为连通性，忽略具体数值约束。

---
处理用时：151.98秒
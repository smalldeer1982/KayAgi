# 题目信息

# [ABC252E] Road Reduction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc252/tasks/abc252_e

AtCoder 王国には都市 $ 1,2,\ldots,N $ の $ N $ 個の都市と、道路 $ 1,2,\ldots,M $ の $ M $ 本の道路があります。  
道路 $ i $ は都市 $ A_i $ と $ B_i $ を双方向に結び、距離は $ C_i $ です。  
どの都市間もいくつかの道路を通って行き来することができます。

財政難である王国は、どの都市間もいくつかの道路を通って行き来できるという条件を満たすように $ N-1 $ 本の道路を保守し、それ以外の道路を廃道にすることにしました。

保守する道路のみを通って都市 $ 1 $ から都市 $ i $ へ移動するときの距離を $ d_i $ とするとき、保守する道路の選び方であって、$ d_2+d_3+\ldots+d_N $ を最小化するようなものを $ 1 $ つ出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- $ i\neq\ j $ のとき、$ (A_i,B_i)\neq(A_j,B_j) $
- $ 1\leq\ C_i\ \leq\ 10^9 $
- どの都市間もいくつかの道路を通って行き来することができる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

保守する道路の選び方と $ d_i $ の値は次のようになります。 - 道路 $ 1,2 $ を保守するとき、$ d_2=1 $, $ d_3=3 $ - 道路 $ 1,3 $ を保守するとき、$ d_2=1 $, $ d_3=10 $ - 道路 $ 2,3 $ を保守するとき、$ d_2=12 $, $ d_3=10 $ よって、道路 $ 1,2 $ を保守するときに $ d_2+d_3 $ が最小になります。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 2
1 3 10```

### 输出

```
1 2```

## 样例 #2

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 1
2 4 1
3 4 1```

### 输出

```
3 1 2```

# AI分析结果



---

### **唯一算法分类**  
**单源最短路径（Dijkstra算法）结合最短路径树**

---

### **综合分析与结论**  
#### **核心思路**  
题目要求构造一棵生成树，使得所有节点到节点 1 的最短距离之和最小。通过分析可知：  
1. **最短路径树**（SPT）天然满足总和最小，因为每个节点的最短路径被保留。  
2. **Dijkstra 算法**在松弛过程中，每个节点被首次松弛到最短路径时对应的边即为生成树中的边。  
3. **边记录策略**：在松弛操作时记录最后一次更新节点距离的边编号，最终构成 SPT。  

#### **难点与解决**  
- **证明边数正确性**：Dijkstra 确定每个非起点节点的最短路径时，恰好引入一条新边，总边数为 N-1。  
- **边重复处理**：无向图需双向存储边，但记录编号时需统一（如 xixiyan 题解中的双向存边但编号相同）。  
- **大值处理**：需使用 `long long` 存储距离，避免溢出。  

#### **可视化设计思路**  
- **动画方案**：  
  - **节点状态**：已确定最短距离的节点（绿色），待处理队列中的节点（黄色）。  
  - **边高亮**：松弛成功的边标红并记录编号。  
  - **步进控制**：允许单步执行，观察堆顶节点选择、松弛过程、边记录。  
- **复古像素风格**：  
  - **8 位网格**：节点用方块表示，边用像素线条连接，松弛时边闪烁。  
  - **音效**：松弛成功时播放短音效，记录边时播放确认音。  
  - **自动演示**：模拟 Dijkstra 的优先级队列动态变化，AI 自动推进算法流程。  

---

### **题解清单 (≥4星)**  
#### **1. 作者：xixiyan（4.5星）**  
- **亮点**：  
  - 使用链式前向星高效存图，适合大规模数据。  
  - 松弛时直接绑定边编号，代码简洁。  
  - 明确处理双向边编号一致性。  
- **代码片段**：  
  ```cpp
  void add(int x,int y,int w){ // 链式前向星存图
      W[++tot].w=w; To[tot]=y; Nxt[tot]=head[x]; head[x]=tot;
  }
  // 松弛时记录边编号
  if (dis[y] > dis[d] + W[i].w) {
      dis[y] = dis[d] + W[i].w;
      ans[y] = W[i].num; // 关键记录
  }
  ```

#### **2. 作者：FFTotoro（4星）**  
- **亮点**：  
  - 代码极简，使用 `emplace_back` 和 `pair` 快速构建邻接表。  
  - 直接在 Dijkstra 循环中输出边编号，减少额外存储。  
- **代码片段**：  
  ```cpp
  for(auto [v,i]:g[e]){
      if(d[e]+w[i]>=d[v])continue;
      p[v]=i; // 记录边编号
      q.emplace(d[v]=d[e]+w[i],v);
  }
  ```

#### **3. 作者：Ascnbeta（4星）**  
- **亮点**：  
  - 显式解释“最短路径树”概念，增强理论理解。  
  - 结构体封装清晰，代码可读性强。  
- **心得引用**：  
  > “Dijkstra 的每次松弛对应生成树的一条边，这是 SPT 的核心性质。”  

---

### **最优技巧提炼**  
- **松弛即记录**：在 Dijkstra 的松弛操作中直接记录边编号，避免后处理。  
- **双向边统一编号**：无向图双向存边时，正反边共享同一编号，避免重复计数。  
- **链式前向星优化**：适用于边数大的场景，减少内存碎片。  

---

### **同类型题推荐**  
1. **洛谷 P4779**：【模板】单源最短路径（标准 Dijkstra 模板）。  
2. **洛谷 P3366**：【模板】最小生成树（对比 Kruskal 和 Prim 算法）。  
3. **洛谷 P4180**：严格次小生成树（扩展思维，结合最短路与生成树性质）。  

---

### **个人心得摘录**  
- **作者 FL_sleake**：  
  > “没有判断 `if (dis[u] < D)` 会导致 TLE，这是堆优化 Dijkstra 的常见坑点。”  
- **调试教训**：未处理重复松弛会导致大量无效操作，需严格判断节点状态。  

---

### **可视化与复古动画实现**  
#### **核心逻辑演示**  
- **HTML/Canvas 绘制**：  
  - 节点布局为环形，起点 1 居中，其他节点按编号分布。  
  - 边动态显示，松弛成功时变为红色并显示编号。  
- **音效与动画**：  
  - **松弛音效**：8-bit 短促“哔”声。  
  - **节点确定**：播放“滴”声，节点变绿。  
- **自动演示模式**：  
  - 算法自动从优先级队列取节点，逐步更新，用户可调节速度。  

#### **代码片段（JS 伪代码）**  
```javascript
class DijkstraViz {
    constructor(nodes, edges) {
        this.queue = new PriorityQueue(); // 模拟优先级队列
        this.nodes = nodes; // 节点坐标与状态
        this.edges = edges; // 边列表
    }
    step() {
        let current = this.queue.pop();
        if (current.dis > this.nodes[current.id].dis) return;
        for (let edge of this.edges[current.id]) {
            let newDis = current.dis + edge.weight;
            if (newDis < this.nodes[edge.to].dis) {
                this.nodes[edge.to].dis = newDis;
                this.queue.push({id: edge.to, dis: newDis});
                this.highlightEdge(edge); // 高亮边并记录编号
            }
        }
    }
}
```

---

**答案代码（xixiyan 题解）**  
完整代码见原题解，核心逻辑已提炼。

---
处理用时：72.33秒
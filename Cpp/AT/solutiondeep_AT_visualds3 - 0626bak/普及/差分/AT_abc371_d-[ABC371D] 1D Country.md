# 题目信息

# [ABC371D] 1D Country

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_d

数直線上に $ N $ 個の村があります。$ i $ 番目の村は座標 $ X_i $ にあり、$ P_i $ 人の村人がいます。

$ Q $ 個のクエリに答えてください。$ i $ 番目のクエリは以下の形式です。

- 整数 $ L_i,R_i $ が与えられる。座標が $ L_i $ 以上 $ R_i $ 以下の村に住んでいる村人の人数の総数を求めよ。

## 说明/提示

### 制約

- $ 1\leq\ N,Q\leq\ 2\times\ 10^5 $
- $ -10^9\leq\ X_1\ <\ X_2\ <\ \ldots\ <\ X_N\ \leq\ 10^9 $
- $ 1\leq\ P_i\leq\ 10^9 $
- $ -10^9\leq\ L_i\ \leq\ R_i\ \leq\ 10^9 $
- 入力される数値は全て整数

### Sample Explanation 1

$ 1 $ 番目のクエリについて考えます。座標が $ 1 $ 以上 $ 1 $ 以下の村は、座標 $ 1 $ にある村で、村人は $ 1 $ 人います。よって答えは $ 1 $ です。 $ 2 $ 番目のクエリについて考えます。座標が $ 2 $ 以上 $ 6 $ 以下の村は、座標 $ 3 $ にある村と座標 $ 5 $ にある村で、村人はそれぞれ $ 2 $ 人と $ 3 $ 人います。よって答えは $ 2+3=5 $ です。

## 样例 #1

### 输入

```
4
1 3 5 7
1 2 3 4
4
1 1
2 6
0 10
2 2```

### 输出

```
1
5
10
0```

## 样例 #2

### 输入

```
7
-10 -5 -3 -1 0 1 4
2 5 6 5 2 1 7
8
-7 7
-1 5
-10 -4
-8 10
-5 0
-10 5
-8 7
-8 -3```

### 输出

```
26
15
7
26
18
28
26
11```

# AI分析结果



**唯一算法分类**  
二分查找

---

### **题解思路与解决难点**  
- **核心思路**：预处理村庄位置的前缀和数组，对每个查询使用两次二分查找确定区间边界，计算区间和。  
- **关键步骤**：  
  1. **排序**：村庄按位置升序排列（输入已有序）。  
  2. **前缀和**：预处理前缀和数组 `sum[]`，`sum[i]` 表示前 `i` 个村庄的总人数。  
  3. **二分查找**：  
     - 左边界 `L`：用 `lower_bound` 找到第一个 ≥ `L_i` 的村庄位置。  
     - 右边界 `R`：用 `upper_bound` 找到第一个 > `R_i` 的村庄位置，取前一位置。  
  4. **区间和计算**：`sum[r-1] - sum[l-1]`。  
- **解决难点**：正确处理二分边界条件，避免越界或漏判。

---

### **题解评分（≥4星）**  
1. **XXh0919（★★★★★）**  
   - 亮点：代码简洁，直接使用 `lower_bound` 和 `upper_bound`，高效处理边界。  
   - 关键代码：  
     ```cpp
     l = lower_bound(x+1, x+n+1, L) - x;
     r = upper_bound(x+1, x+n+1, R) - x;
     cout << sum[r-1] - sum[l-1];
     ```  
2. **chenxi2009（★★★★☆）**  
   - 亮点：手写二分，清晰展示边界调整逻辑，适合教学。  
   - 关键代码：  
     ```cpp
     // 右边界二分
     while(l < r) {
         mid = l + r + 1 >> 1;
         if(x[mid] <= ri) l = mid;
         else r = mid - 1;
     }
     ```  
3. **hjyowl（★★★★☆）**  
   - 亮点：结构体排序后分离数组，逻辑清晰，适合理解离散化前的预处理。

---

### **最优思路提炼**  
1. **前缀和优化**：预处理前缀和数组，将区间和计算降至 O(1)。  
2. **二分定位**：利用 STL 的 `lower_bound` 和 `upper_bound` 快速定位查询区间。  
3. **边界处理**：右边界用 `upper_bound` 后减一，避免包含超出范围的村庄。

---

### **同类型题与算法套路**  
- **通用解法**：对于有序序列上的区间查询问题，前缀和+二分是经典组合。  
- **类似题目**：  
  - 洛谷 P1177 【模板】快速排序（数据有序下的区间查询）  
  - 洛谷 P2249 【深基13.例1】查找（二分查找模板）  
  - 洛谷 P3406 海底高铁（前缀和优化区间统计）

---

### **可视化与算法演示**  
**动画设计**：  
1. **数轴绘制**：用像素网格表示数轴，村庄用绿色方块标记，显示坐标和人数。  
2. **查询高亮**：红色半透明矩形覆盖查询区间 `[L_i, R_i]`。  
3. **二分过程**：  
   - 左边界：黄色箭头从数轴左侧向右移动，停在第一个 ≥ `L_i` 的村庄。  
   - 右边界：蓝色箭头从右侧向左移动，停在最后一个 ≤ `R_i` 的村庄。  
4. **前缀和计算**：显示 `sum[r-1] - sum[l-1]` 的数值变化。  

**复古像素效果**：  
- **音效**：  
  - 二分移动时播放 8-bit “滴”声。  
  - 计算结果时播放胜利音效（16-bit 上升音阶）。  
- **Canvas 实现**：  
  ```javascript
  // 伪代码示例：绘制村庄和查询区间
  function draw() {
      ctx.fillStyle = '#00FF00'; // 村庄颜色
      villages.forEach((v, i) => {
          ctx.fillRect(v.x * scaleX, 100, 10, 10); // 方块表示村庄
      });
      // 高亮查询区间
      ctx.fillStyle = 'rgba(255,0,0,0.3)';
      ctx.fillRect(queryL * scaleX, 80, (queryR - queryL) * scaleX, 40);
  }
  ```  

---

**核心代码示例**  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
long long x[N], sum[N];

int main() {
    int n, q; cin >> n;
    for (int i = 1; i <= n; i++) cin >> x[i];
    for (int i = 1; i <= n; i++) {
        int p; cin >> p;
        sum[i] = sum[i-1] + p;
    }
    cin >> q;
    while (q--) {
        int L, R; cin >> L >> R;
        int l = lower_bound(x+1, x+n+1, L) - x;
        int r = upper_bound(x+1, x+n+1, R) - x;
        cout << sum[r-1] - sum[l-1] << '\n';
    }
    return 0;
}
```  

---

**总结**：本题的标准化解法通过结合排序、前缀和与二分查找，高效处理大规模区间查询。可视化设计中，像素风格和音效增强理解，核心在于二分定位的直观演示。

---
处理用时：78.32秒
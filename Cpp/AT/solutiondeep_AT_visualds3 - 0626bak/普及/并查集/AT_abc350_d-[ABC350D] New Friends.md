# 题目信息

# [ABC350D] New Friends

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc350/tasks/abc350_d

$ 1 $ から $ N $ の番号がついた $ N $ 人のユーザが利用している SNS があります。

この SNS では $ 2 $ 人のユーザが互いに**友達**になれる機能があります。  
 友達関係は双方向的です。すなわち、ユーザ X がユーザ Y の友達であるならば、必ずユーザ Y はユーザ X の友達です。

現在 SNS 上には $ M $ 組の友達関係が存在し、$ i $ 組目の友達関係はユーザ $ A_i $ とユーザ $ B_i $ からなります。

以下の操作を行える最大の回数を求めてください。

- 操作：3 人のユーザ X, Y, Z であって、X と Y は友達、Y と Z は友達であり、X と Z は友達でないようなものを選ぶ。X と Z を友達にする。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ <\ B_i\ \leq\ N $
- $ (A_i,B_i) $ は相異なる
- 入力は全て整数である
 
### Sample Explanation 1

次のようにして「友達の友達と新たに友達になる」という操作は $ 3 $ 回行えます。 - ユーザ $ 1 $ が友達(ユーザ $ 2 $)の友達であるユーザ $ 3 $ と新たに友達になる - ユーザ $ 3 $ が友達(ユーザ $ 1 $)の友達であるユーザ $ 4 $ と新たに友達になる - ユーザ $ 2 $ が友達(ユーザ $ 1 $)の友達であるユーザ $ 4 $ と新たに友達になる $ 4 $ 回以上行うことはできません。

### Sample Explanation 2

もともと友達関係が存在しないとき、新たな友達関係は発生しません。

## 样例 #1

### 输入

```
4 3

1 2

2 3

1 4```

### 输出

```
3```

## 样例 #2

### 输入

```
3 0```

### 输出

```
0```

## 样例 #3

### 输入

```
10 8

1 2

2 3

3 4

4 5

6 7

7 8

8 9

9 10```

### 输出

```
12```

# AI分析结果



# 算法分类
**并查集（图论中的连通块问题）**

---

## 题解思路与核心算法
### 核心思路
1. **问题转化**：每个连通块最终会形成完全图，最大操作次数等于所有连通块完全图边数之和减去初始边数。
2. **关键公式**：对于每个连通块大小为 `k`，其完全图边数为 `k*(k-1)/2`，总操作次数为 `Σ(k_i*(k_i-1)/2) - M`。
3. **实现方式**：通过并查集统计各连通块大小，直接计算完全图边数总和后减去初始边数。

### 解决难点
- **如何高效统计连通块大小**：使用并查集合并节点，维护每个根节点的集合大小。
- **避免重复计算边数**：利用初始边总数 `M` 的性质，直接求和后减去 `M`，无需逐个连通块统计边数。

### 算法流程
1. **并查集初始化**：每个节点初始为独立集合。
2. **合并所有边**：将输入的边依次合并，构建连通块。
3. **统计连通块大小**：遍历所有节点，统计每个根节点对应的集合大小。
4. **计算结果**：累加所有连通块的完全图边数，减去初始边数 `M`。

---

## 题解评分（≥4星）
### OAer 题解（★★★★★）
- **亮点**：详细推导完全图性质，代码简洁，利用并查集维护边数。
- **代码**：合并时动态维护边数，时间复杂度优化至 `O(Mα(N))`。

### Special_Tony 题解（★★★★★）
- **亮点**：发现总初始边数可直接替代逐个统计，代码极简。
- **代码**：仅用并查集维护连通块大小，直接公式计算，时间复杂度 `O(Mα(N))`。

### Harrylzh 题解（★★★★）
- **亮点**：并查集维护连通块大小和边数，思路清晰。
- **代码**：显式维护边数，适合理解操作本质。

---

## 最优思路提炼
**关键技巧**：
1. **数学简化**：利用初始边总数 `M` 直接计算，避免逐个统计边数。
2. **并查集优化**：仅维护连通块大小，无需额外维护边数。
3. **公式推导**：完全图边数公式 `k*(k-1)/2` 的应用。

**代码片段**（Special_Tony 核心逻辑）：
```cpp
for (int i=1; i<=m; i++) {
    int u, v; cin >> u >> v;
    f[find(u)] = find(v); // 合并边对应的节点
}
for (int i=1; i<=n; i++) s[find(i)]++; // 统计连通块大小
long long ans = 0;
for (int i=1; i<=n; i++) {
    if (s[i]) ans += s[i] * (s[i]-1LL) / 2;
}
cout << ans - m; // 直接减去初始边数
```

---

## 类似题目推荐
1. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551) - 并查集基础应用。
2. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197) - 连通块动态维护。
3. [P1111 修复公路](https://www.luogu.com.cn/problem/P1111) - 并查集与时间顺序结合。

---

## 可视化算法设计
### 动画方案
- **像素风格显示**：节点为色块，边为线条，不同连通块颜色不同。
- **合并过程**：处理边时高亮节点，动态显示颜色合并。
- **统计阶段**：连通块以颜色区块展示，显示公式 `k*(k-1)/2` 计算过程。

### 交互设计
- **步进控制**：可逐条处理边，观察连通块合并。
- **音效**：合并时播放“连接”音效，计算完成时播放胜利音效。
- **自动演示**：自动播放合并过程，速度可调。

---

## 总结
本题核心在于发现**完全图性质**和**总边数简化计算**。通过并查集高效维护连通块大小，结合数学公式直接求解，避免复杂统计。算法实现简洁高效，时间复杂度接近线性。

---
处理用时：201.96秒
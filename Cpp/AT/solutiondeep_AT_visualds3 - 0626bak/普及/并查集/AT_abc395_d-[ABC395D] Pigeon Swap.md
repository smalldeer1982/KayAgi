# 题目信息

# [ABC395D] Pigeon Swap

## 题目描述

有 $N$ 只鸽子（编号 $1,2,\ldots,N$）和 $N$ 个巢（编号 $1,2,\ldots,N$）。初始时，鸽子 $i$（$1 \leq i \leq N$）位于巢 $i$ 中。

接下来对鸽子进行 $Q$ 次操作，操作分为以下三种类型：

- **类型 1**：给定整数 $a,b$（$1 \leq a \leq N$，$1 \leq b \leq N$）。将鸽子 $a$ 从当前所在的巢中取出，放入巢 $b$。
- **类型 2**：给定整数 $a,b$（$1 \leq a < b \leq N$）。将巢 $a$ 中所有鸽子移动到巢 $b$，同时将巢 $b$ 中所有鸽子移动到巢 $a$。这两个移动操作是同时进行的。
- **类型 3**：给定整数 $a$（$1 \leq a \leq N$）。报告鸽子 $a$ 当前所在的巢的编号。

请输出所有类型 3 的操作的结果。

## 说明/提示

### 约束条件
- $1 \leq N \leq 10^6$
- $1 \leq Q \leq 3 \times 10^5$
- 所有操作均符合题目描述中的参数范围。
- 输入中至少包含一个类型 3 操作。
- 输入均为整数。

### 样例解释 1
操作过程中鸽子的移动如图所示（图片链接略）。类型 3 操作应报告的巢编号依次为 $4,5,2,5$，因此输出四行：`4`、`5`、`2`、`5`。

### 样例解释 2
在类型 1 操作中，可能存在将鸽子取出后又放回原巢的情况。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6 8

1 2 4

1 3 6

3 2

2 4 5

3 2

1 4 2

3 4

3 2```

### 输出

```
4

5

2

5```

## 样例 #2

### 输入

```
1 2

1 1 1

3 1```

### 输出

```
1```

## 样例 #3

### 输入

```
30 15

3 3

2 8 30

2 12 15

2 2 17

1 19 1

2 7 30

3 12

3 8

2 25 26

1 13 10

1 16 10

2 16 29

2 1 21

2 6 11

1 21 8```

### 输出

```
3

15

7```

# AI分析结果



# 算法分类
无算法分类（间接映射）

## 题解思路与核心难点
### 核心思路
通过维护巢的间接映射关系，将物理巢交换转化为逻辑位置交换。每个鸽子记录的是逻辑巢的位置，而逻辑巢通过映射表关联到实际巢编号。关键数据结构：
- `fa[]`：记录鸽子当前所在的逻辑巢位置
- `id[]`：逻辑巢位置对应的实际巢编号
- `p[]`：实际巢编号对应的逻辑巢位置（反向映射）

### 解决难点
1. **操作2的高效处理**：通过交换逻辑巢的映射关系（swap(p[a], p[b])），避免逐个移动鸽子
2. **数据一致性维护**：每次交换后需同步更新反向映射（swap(id[p[a]], id[p[b]])）
3. **查询时的间接转换**：通过两次映射转换（fa -> 逻辑位置 -> id[]）得到实际巢编号

## 题解评分
### 4星题解（作者：lfxxx_）
**关键亮点**：
- 代码最简洁（仅3个数组）
- 明确分离逻辑位置与实际编号
- 操作2仅需2次交换+1次同步
```cpp
int fa[N], id[N], p[N];
// 操作1：修改鸽子的逻辑巢位置
fa[x] = p[y];
// 操作2：交换逻辑巢映射关系
swap(p[x], p[y]); 
swap(id[p[x]], id[p[y]]);
// 操作3：通过两层映射得到结果
cout << id[fa[x]];
```

### 4星题解（作者：Clover_Lin）
**关键亮点**：
- 引入`flag[]`辅助理解映射关系
- 详细注释说明数组语义
- 反向映射维护更直观
```cpp
vector<int> st(N+1), ed(N+1), home(N+1);
// st[i]：巢i的逻辑位置
// ed[i]：逻辑位置i的实际巢编号
// home[i]：鸽子i的逻辑位置

// 操作2的核心交换逻辑
swap(st[a], st[b]);        // 交换巢的逻辑位置
ed[st[a]] = a; ed[st[b]] = b; // 维护反向映射
```

### 4星题解（作者：xiaoyin2011）
**关键亮点**：
- 使用`remap[]`和`bamap[]`双向映射
- 变量命名清晰（remap=实际到逻辑，bamap=逻辑到实际）
- 操作2的同步更新更严谨
```cpp
remap[bamap[b]] = a;      // 更新实际巢到逻辑位置的映射
swap(bamap[a], bamap[b]); // 交换逻辑位置到实际的映射
```

## 核心算法流程可视化
### 动画设计
1. **数据结构展示**：并排显示三个数组（逻辑位置、实际编号、反向映射），用不同颜色标注
2. **操作高亮**：
   - 操作1：红色箭头从鸽子指向新逻辑位置
   - 操作2：黄色闪烁交换逻辑位置，绿色更新反向映射
   - 操作3：蓝色路径显示`fa->逻辑位置->id[]`的查询路径
3. **像素风格**：使用16色复古调色板，数组显示为网格方块，操作时播放8-bit音效

### 关键步骤演示
**初始状态**：
```
鸽子1-3的fa[] = [1,2,3]
id[] = [1,2,3], p[] = [1,2,3]
```

**执行操作2交换巢1和2**：
1. swap(p[1], p[2]) → p=[2,1,3]
2. swap(id[p[1]], id[p[2]]) → id[2]=1, id[1]=2
3. 网格动画中巢1和2的位置交换并闪烁

**执行操作1移动鸽子1到巢2**：
1. fa[1] = p[2] → fa[1]=1（因为p[2]=1）
2. 红色箭头从鸽子1指向逻辑位置1

**查询操作3**：
1. 沿路径fa[1]=1 → id[1]=2
2. 显示蓝色路径动画并播放成功音效

## 相似题目推荐
1. **P1551 亲戚**（并查集基础）
2. **P3367 【模板】并查集**（映射关系维护）
3. **P3402 可持久化并查集**（复杂映射场景）

---
处理用时：71.07秒
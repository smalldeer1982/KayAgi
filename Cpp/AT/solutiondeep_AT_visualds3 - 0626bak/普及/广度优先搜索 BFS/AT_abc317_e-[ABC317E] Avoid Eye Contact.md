# 题目信息

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>```

### 输出

```
15```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G```

### 输出

```
-1```

# AI分析结果



# ABC317E Avoid Eye Contact 题解分析

## 算法分类
**BFS**

## 题解思路与核心难点
### 核心思路
1. **预处理视线区域**：遍历网格，将每个方向（东、南、西、北）的人视线范围内的格子标记为不可通行。
2. **BFS求最短路径**：从起点出发，用 BFS 遍历所有可达且未被标记的格子，记录到达终点的最短步数。

### 解决难点
- **视线预处理**：需正确遍历四个方向，直到遇到障碍物或其他人停止。需确保仅标记空地和视线交叉区域。
- **高效性**：预处理和 BFS 的时间复杂度均为 O(nm)，需避免重复计算。

## 高分题解推荐（≥4星）
1. **ran_qwq（5星）**  
   - **亮点**：代码简洁，预处理逻辑清晰，利用独立数组标记视线，BFS实现标准。
   - **代码片段**：
     ```cpp
     // 预处理视线
     for (int i=1; i<=h; i++) {
         for (int j=1; j<=w; j++) {
             if (s[i][j] == '>') {
                 for (int y=j+1; y<=w && s[i][y] != '#'; y++) 
                     use[i][y] = true;
             } // 类似处理其他方向...
         }
     }
     ```
2. **CJ_Fu（4星）**  
   - **亮点**：使用方向数组统一处理视线，代码结构清晰，预处理时直接修改原地图。
3. **Dream_poetry（4星）**  
   - **亮点**：将视线标记为特殊字符，避免额外数组，逻辑直观。

## 最优思路提炼
- **视线标记**：对每个方向的人，沿其朝向遍历至障碍物或边界，标记所有中间的空格。
- **BFS剪枝**：使用 `visited` 数组避免重复访问，保证首次到达即最短路径。

## 同类题型
1. **P1135 奇怪的电梯**（BFS求最短按钮次数）
2. **P1443 马的遍历**（BFS遍历棋盘）
3. **P1162 填涂颜色**（BFS标记连通区域）

## 个人心得
- **预处理陷阱**：需注意视线标记时不能覆盖起点和终点，题目虽保证其安全，但代码实现时仍需条件过滤。
- **BFS队列管理**：队列的初始化需包含起点，并在每次扩展时验证格子合法性。

---

## 代码实现（BFS核心）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[] = {0,0,1,-1}, dy[] = {1,-1,0,0};
char grid[2005][2005];
bool vis[2005][2005], danger[2005][2005];
int h, w, sx, sy, ex, ey;

void mark_danger(int x, int y, int dir) {
    int step = (dir < 2) ? 1 : -1; // 方向步进
    if (dir < 2) { // 东西向
        for (int j = y + step; j >= 1 && j <= w; j += step) {
            if (grid[x][j] != '.') break;
            danger[x][j] = true;
        }
    } else { // 南北向
        for (int i = x + step; i >= 1 && i <= h; i += step) {
            if (grid[i][y] != '.') break;
            danger[i][y] = true;
        }
    }
}

int bfs() {
    queue<tuple<int, int, int>> q;
    q.push({sx, sy, 0});
    vis[sx][sy] = true;
    while (!q.empty()) {
        auto [x, y, d] = q.front(); q.pop();
        if (x == ex && y == ey) return d;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || ny < 1 || nx > h || ny > w) continue;
            if (!vis[nx][ny] && !danger[nx][ny] && grid[nx][ny] != '#') {
                vis[nx][ny] = true;
                q.push({nx, ny, d + 1});
            }
        }
    }
    return -1;
}

int main() {
    cin >> h >> w;
    for (int i = 1; i <= h; i++) {
        for (int j = 1; j <= w; j++) {
            cin >> grid[i][j];
            if (grid[i][j] == 'S') sx = i, sy = j;
            if (grid[i][j] == 'G') ex = i, ey = j;
            if (grid[i][j] == '>') mark_danger(i, j, 0);
            if (grid[i][j] == '<') mark_danger(i, j, 1);
            if (grid[i][j] == 'v') mark_danger(i, j, 2);
            if (grid[i][j] == '^') mark_danger(i, j, 3);
        }
    }
    cout << bfs() << endl;
    return 0;
}
```

---

## 可视化设计（BFS动画）
### 方案要点
1. **网格绘制**：使用 Canvas 绘制 HxW 的网格，不同颜色区分空地、障碍、视线区、起点、终点。
2. **搜索动画**：
   - **当前节点**：高亮为黄色，扩散时展示四个方向的探索。
   - **队列节点**：蓝色边框表示待访问。
   - **已访问节点**：灰色填充，避免重复处理。
3. **步进控制**：支持暂停/继续，速度调节（慢速观察 BFS 层序扩展）。
4. **复古风格**：
   - **音效**：进入队列（8-bit "beep"），到达终点（胜利音效）。
   - **像素动画**：节点用 16x16 像素块，路径用连线动态绘制。

### 交互示例
```javascript
// 伪代码：BFS 动画核心逻辑
function animateBFS() {
    let queue = [[sx, sy]];
    let steps = 0;
    const interval = setInterval(() => {
        if (queue.length === 0) {
            clearInterval(interval);
            playSound('finish');
            return;
        }
        const [x, y] = queue.shift();
        drawCurrentNode(x, y); // 高亮当前节点
        for (let dir of directions) {
            let nx = x + dir[0], ny = y + dir[1];
            if (isValid(nx, ny) && !vis[nx][ny]) {
                vis[nx][ny] = true;
                queue.push([nx, ny]);
                drawEnqueue(nx, ny); // 绘制入队动画
                playSound('enqueue');
            }
        }
    }, speed);
}
```

---
处理用时：97.83秒
# 题目信息

# [ABC361D] Go Stone Puzzle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_d

$ N+2 $ 個のマスが横一列に並んでいます。左から $ i $ 番目のマスをマス $ i $ と表します。

マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれています。  
 各 $ 1\leq\ i\ \leq\ N $ について、$ S_i $ が `W` のときマス $ i $ に置かれている石の色は白であり、$ S_i $ が `B` のときマス $ i $ に置かれている石の色は黒です。  
 マス $ N+1,N+2 $ には何も置かれていません。

あなたは以下の操作を好きな回数($ 0 $ 回でもよい)行うことができます。

- 石が $ 2 $ 個並んでいる箇所を選び、その $ 2 $ 個の石を順序を保って空きマスに移す。  
   より正確には次の通り。$ 1 $ 以上 $ N+1 $ 以下の整数 $ x $ であって、マス $ x,x+1 $ の両方に石が置かれているものを選ぶ。石の置かれていないマスを $ k,k+1 $ とする。マス $ x,x+1 $ にある石をそれぞれマス $ k,k+1 $ に移動する。
 
以下の状態にすることが可能か判定し、可能なら操作回数の最小値を求めてください。

- マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれており、各 $ 1\leq\ i\ \leq\ N $ について、$ T_i $ が `W` のときマス $ i $ に置かれている石の色は白、$ T_i $ が `B` のときマス $ i $ に置かれている石の色は黒である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 14 $
- $ N $ は整数である
- $ S,T $ は `B` および `W` のみからなる長さ $ N $ の文字列である
 
### Sample Explanation 1

石が置かれていないマスを `.` と表します。以下のようにして $ 4 $ 回の操作で目的の状態にすることができ、これが最小回数です。 - `BWBWBW..` - `BW..BWBW` - `BWWBB..W` - `..WBBBWW` - `WWWBBB..`

## 样例 #1

### 输入

```
6

BWBWBW

WWWBBB```

### 输出

```
4```

## 样例 #2

### 输入

```
6

BBBBBB

WWWWWW```

### 输出

```
-1```

## 样例 #3

### 输入

```
14

BBBWBWWWBBWWBW

WBWWBBWWWBWBBB```

### 输出

```
7```

# AI分析结果



## 算法分类
**BFS**

---

## 综合分析与结论
### 核心思路
本题要求将初始石子序列通过交换相邻石子到空位的方式转化为目标序列，求最小操作次数。由于操作步数最少，采用 **BFS** 作为核心算法。关键点包括：
1. **状态表示**：使用字符串表示当前石子分布（含空位），例如 `BWBW..` 表示前4格为交替黑白，末尾两格为空。
2. **状态转移**：每次选择两个相邻非空石子，将其移动到当前空位，生成新状态。
3. **去重优化**：通过哈希表（如 `unordered_map`）记录已访问状态，避免重复搜索。

### 解决难点
1. **空格位置处理**：空位始终为连续的两个格子，每次移动后需动态更新空位位置。
2. **状态压缩**：部分题解使用三进制压缩状态（如 `B=0, W=1, .=2`）以节省内存，但字符串直接操作更易实现。
3. **剪枝策略**：若初始与目标状态的 `W/B` 数量不同则直接判无解，提前剪枝。

### 可视化设计
1. **动画流程**：
   - **初始化**：显示初始字符串，高亮空位（如红色方块）。
   - **扩展节点**：用队列可视化待处理状态，当前处理的节点以黄色高亮。
   - **交换操作**：用箭头动画表示石子与空位的交换过程，新生成状态加入队列尾部。
   - **终止检测**：当状态匹配目标时，播放成功音效并高亮最终路径。
2. **交互功能**：
   - **步进控制**：支持暂停/继续/单步调试，观察 BFS 扩展顺序。
   - **颜色标记**：已访问状态标为灰色，当前节点绿色，目标节点闪烁红色。
3. **复古像素风格**：
   - **8位音效**：节点扩展时播放“哔”声，找到解时播放胜利旋律。
   - **Canvas 绘制**：石子用像素方块表示（黑/白/空），队列以网格形式动态更新。

---

## 题解清单（评分≥4星）
### 1. shangruolin（5星）
- **亮点**：代码简洁，使用 `tuple` 存储步数、空位和状态，逻辑清晰，无冗余操作。
- **核心代码**：
  ```cpp
  queue<T> q;
  q.push(MT(0, n+1, a)); // 初始状态入队
  while (!q.empty()) {
      auto [x, y, s] = q.front(); q.pop();
      if (s == b) return cout << x, 0; // 找到解
      for (int i = 1; i <= n+1; i++) {
          if (s[i] != '#' && s[i+1] != '#') { // 可移动的位置
              swap(s[i], s[y]); // 交换石子与空位
              swap(s[i+1], s[y+1]);
              if (!mp[s]) q.push(MT(x+1, i, s)); // 新状态入队
              swap(s[i], s[y]); // 恢复状态
              swap(s[i+1], s[y+1]);
          }
      }
  }
  ```

### 2. Heldivis（4星）
- **亮点**：显式记录空位位置 `fre`，减少每次查找空位的开销。
- **关键优化**：
  ```cpp
  struct Node { string s; int w, fre; }; // fre为第一个空位
  for (int i = 1; i <= n+1; i++) {
      if (s[i] != '#' && s[i+1] != '#') {
          swap(s[i], s[fre]); // 直接使用预存空位
          swap(s[i+1], s[fre+1]);
          q.push({s, w+1, i}); // 更新空位为i
      }
  }
  ```

### 3. nightwatch.ryan（4星）
- **亮点**：通过 `vector<int> PointPos` 动态查找空位，代码易读性强。
- **个人心得**：“一定要自己写，注意交换条件” —— 强调边界检查的重要性。

---

## 最优思路提炼
1. **状态表示与转移**：用字符串直接模拟石子分布，每次交换相邻石子与空位。
2. **BFS队列管理**：使用队列确保按层扩展，首次到达目标状态即为最小步数。
3. **哈希去重**：`unordered_map<string, bool>` 避免重复状态访问。
4. **剪枝优化**：预先检查 `W/B` 数量，不一致直接返回 `-1`。

---

## 同类型题推荐
1. **八数码问题**（洛谷 P1379）：3x3 滑块拼图，BFS 求最少步数。
2. **迷宫最短路径**（洛谷 P1141）：二维网格中 BFS 找出口。
3. **华容道**（洛谷 P1970）：滑块移动类问题的变种，需状态压缩。

---

## 个人心得摘录
- **include13_fAKe**：“switch 一定要 break，否则状态转换错误”——调试中因漏写 `break` 导致错误。
- **wbh20090611**：“状压 DP 难以处理交换操作，最终改用 BFS”——强调选择合适算法的重要性。

---

## 可视化代码片段（BFS核心）
```javascript
// 伪代码：Canvas绘制当前状态与队列
function drawState(state, queue) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制当前状态
  for (let i = 0; i < state.length; i++) {
    drawStone(i, state[i]); // 根据字符绘制黑/白/空
  }
  // 绘制队列中的待处理状态
  queue.forEach((s, idx) => {
    drawQueueItem(idx, s); // 在右侧面板显示
  });
}

// 交换动画示例
async function animateSwap(from, to) {
  let stone1 = getElement(from);
  let stone2 = getElement(from + 1);
  // 移动动画
  await moveElement(stone1, to);
  await moveElement(stone2, to + 1);
  playSound('swap'); // 播放音效
}
```

---

## 复古游戏化设计
1. **像素风格**：使用 8-bit 字体，石子用 16x16 像素块表示，空位为闪烁的灰色方块。
2. **音效设计**：
   - **移动**：8-bit 短促“滴”声。
   - **成功**：FC 风格胜利旋律（C大调上行音阶）。
3. **自动演示**：按 BFS 顺序自动播放，用户可暂停观察当前状态。
4. **积分系统**：每扩展一个节点+10分，找到解+100分，失败显示“GAME OVER”。

---
处理用时：76.72秒
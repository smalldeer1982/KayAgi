# 题目信息

# [ABC363E] Sinking Land

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_e

$ H\ \times\ W $ の大きさの島があり、島は周りを海で囲まれています。  
 島は 縦 $ H $ 個 $ \times $ 横 $ W $ 個の $ 1\times\ 1 $ の区画に分けられており、上から $ i $ 番目かつ左から $ j $ 番目の区画の（現在の海面を基準にした）標高は $ A_{i,j} $ です。

現在から $ 1 $ 年ごとに海面の高さが $ 1 $ ずつ上昇します。  
 このとき、海または海に沈んだ区画に上下左右に隣接する区画であって、標高が海面の高さ **以下** の区画は海に沈みます。  
 ここで、ある区画が新しく海に沈んだときそれと上下左右に隣接する区画であって海面の高さ以下のものも同時に海に沈み、これによって新しく沈んだ区画についてもこれは繰り返されます。

$ i=1,2,\ldots,\ Y $ それぞれについて、現在から $ i $ 年後に、島のうち海に沈まず残っている部分の面積を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ 1\leq\ Y\leq\ 10^5 $
- $ 1\leq\ A_{i,j}\leq\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

島の上から $ i $ 番目かつ左から $ j $ 番目の区画を $ (i,j) $ で表します。このとき、次のようになります。 - $ 1 $ 年後、海面は現在より $ 1 $ 上昇しますが、海に面している標高 $ 1 $ の区画は存在しないため、どの区画も沈みません。よって、$ 1 $ 行目には $ 9 $ を出力します。 - $ 2 $ 年後、海面は現在より $ 2 $ 上昇し、$ (1,2) $ が海に沈みます。これによって、$ (2,2) $ は海に沈んだ区画に隣接する区画となりますが、その標高は $ 2 $ 以下であるため、これも海に沈みます。これら以外にこの時点で他に沈む区画はありません。よって、$ 2 $ つの区画が沈むため、$ 2 $ 行目には $ 9-2=7 $ を出力します。 - $ 3 $ 年後、海面は現在より $ 3 $ 上昇し、$ (2,1) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 3 $ 行目には $ 6 $ を出力します。 - $ 4 $ 年後、海面は現在より $ 4 $ 上昇し、$ (2,3) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 4 $ 行目には $ 5 $ を出力します。 - $ 5 $ 年後、海面は現在より $ 5 $ 上昇し、$ (3,2) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 5 $ 行目には $ 4 $ を出力します。 よって、$ 9,7,6,5,4 $ をこの順に各行に出力します。

## 样例 #1

### 输入

```
3 3 5

10 2 10

3 1 4

10 5 10```

### 输出

```
9

7

6

5

4```

## 样例 #2

### 输入

```
3 5 3

2 2 3 3 3

2 1 2 1 3

2 2 3 3 3```

### 输出

```
15

7

0```

# AI分析结果



## 算法分类
**BFS（优先队列优化）**

---

## 题解思路与算法要点

### 核心思路
1. **动态边界维护**：初始时将岛屿边缘区域加入优先队列，按海拔升序排列。每年处理海拔 ≤ 当前年份的区域。
2. **泛洪式扩展**：当一个区域被淹没后，将其四邻的未处理区域加入队列，成为新的动态边界。
3. **时间复杂度优化**：每个区域仅入队一次，优先队列操作时间复杂度为 O(HW log(HW))，满足题目规模。

### 解决难点
- **高效处理动态淹没顺序**：优先队列保证每次处理当前最低海拔区域，避免重复计算。
- **避免重复标记**：使用 `vis` 数组记录已处理区域，确保每个区域只扩展一次。

---

## 题解评分（≥4星）

### 1. [cqbzhr]（⭐⭐⭐⭐⭐）
- **亮点**：代码最简洁，优先队列逻辑清晰，初始化时巧妙处理边界入队。
- **代码片段**：
```cpp
priority_queue<note> q;
for (边缘区域) q.push({i,j,a[i][j]});
while (年份 <= Y) {
    while (q.top().val <= 年份) {
        淹没该区域并扩展邻居...
    }
}
```

### 2. [DengStar]（⭐⭐⭐⭐）
- **亮点**：注释详细，明确解释优先队列与 BFS 的关系，适合教学。
- **关键代码**：
```cpp
struct node { int x,y,k; };
priority_queue<node> q; // 按海拔排序
ans = n*m; // 动态维护剩余区域
```

### 3. [__O_v_O__]（⭐⭐⭐⭐）
- **亮点**：结构体排序运算符重载规范，visited 数组命名清晰。
- **技巧**：使用 `operator<` 定义优先队列排序规则，代码可读性高。

---

## 最优思路提炼
1. **优先队列管理动态边界**：始终处理当前可淹没的最低海拔区域。
2. **泛洪填充式扩展**：淹没区域后立即将其邻居加入队列，形成链式反应。
3. **O(1) 维护剩余面积**：通过递减计数器代替每次重新计算。

---

## 同类题型与算法套路
- **洪水填充变种**：如 OpenJudge 的湖计数（BFS 基础）
- **Dijkstra 思想应用**：处理带权最短路径时使用优先队列
- **动态过程模拟**：如火灾蔓延模型、感染扩散问题

---

## 推荐练习题
1. **P1443** 马的遍历（BFS 基础训练）
2. **P1162** 填涂颜色（泛洪填充经典题） 
3. **P3956** 棋盘（优先队列优化 BFS）

---

## 可视化算法演示

### 动画设计
1. **网格绘制**：岛屿以 8-bit 像素风格渲染，不同颜色表示：
   - 🔵 已淹没区域  
   - 🟢 未淹没区域  
   - 🟡 优先队列中的待处理边界
2. **优先队列面板**：右侧显示当前队列中的区域及其海拔，动态高亮即将处理的节点。
3. **年数控制**：滑动条调节当前年份，观察对应淹没过程。

### 交互功能
- **步进控制**：按空格单步执行淹没过程，观察队列变化
- **音效反馈**：
  - 💧 淹没时播放水滴声
  - 📈 年份切换时播放上升音调
- **自动演示**：点击播放键自动运行，速度可调

### 复古风格实现
```javascript
// Canvas 绘制示例
function drawPixel(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*16, y*16, 14, 14); // 16x16 像素块，留2像素边框
}

// 淹没音效（Web Audio API）
function playSplash() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.1);
    osc.connect(audioCtx.destination);
    osc.start();
}
```

---

## 核心代码实现（C++）

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1005;
int h,w,Y,a[N][N],remain;
bool vis[N][N];
struct Node { int x,y,h; };
priority_queue<Node, vector<Node>, 
    function<bool(Node,Node)>> q([](Node a, Node b){ return a.h > b.h; });

int main() {
    cin>>h>>w>>Y;
    remain = h*w;
    // 初始化边界
    for(int i=1; i<=h; ++i) for(int j=1; j<=w; ++j) {
        cin>>a[i][j];
        if(i==1 || i==h || j==1 || j==w) {
            q.push({i,j,a[i][j]});
            vis[i][j] = true;
        }
    }
    
    for(int year=1; year<=Y; ++year) {
        while(!q.empty() && q.top().h <= year) {
            auto [x,y,cur_h] = q.top(); q.pop();
            remain--;
            // 扩展四邻
            for(int d=0; d<4; ++d) {
                int nx=x+((int[]){-1,0,1,0})[d];
                int ny=y+((int[]){0,1,0,-1})[d];
                if(nx<1||nx>h||ny<1||ny>w||vis[nx][ny]) continue;
                vis[nx][ny] = true;
                q.push({nx, ny, a[nx][ny]});
            }
        }
        cout << remain << '\n';
    }
}
```

**代码要点**：
- 使用 `priority_queue` 并自定义比较函数实现小根堆
- 初始时标记所有边界区域为已访问（加入队列）
- 每年循环处理所有可淹没区域，动态维护剩余面积

---
处理用时：75.33秒
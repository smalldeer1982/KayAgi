# 题目信息

# [ABC376D] Cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点 $ M $ 辺の単純有向グラフがあります。$ i $ 番目の辺 $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ a_i $ から頂点 $ b_i $ へ伸びる辺です。  
 頂点 $ 1 $ を含む閉路が存在するか判定して、存在する場合はそのような閉路のうち辺数が最小の閉路の辺数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\ \left(\ \frac{N(N-1)}{2},\ 2\ \times\ 10^5\ \right) $
- $ 1\ \leq\ a_i\ \leq\ N $
- $ 1\ \leq\ b_i\ \leq\ N $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ かつ $ (a_i,\ b_i)\ \neq\ (b_j,\ a_j) $
- 入力される値は全て整数
 
### Sample Explanation 1

頂点 $ 1 $ $ \to $ 頂点 $ 2 $ $ \to $ 頂点 $ 3 $ $ \to $ 頂点 $ 1 $ は辺数が $ 3 $ の閉路で、これが頂点 $ 1 $ を含む唯一の閉路です。

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2

1 2

2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 9

6 1

1 5

2 6

2 1

3 6

4 2

6 4

3 5

5 4```

### 输出

```
4```

# AI分析结果



### 算法分类
**BFS**

### 题解思路与难点分析
1. **核心思路**  
   问题转化为寻找从顶点 1 出发再回到 1 的最短路径。由于边权为 1，BFS 天然适合求解最短路径问题。关键点在于：
   - **初始化队列**：部分题解从顶点 1 的邻居出发（初始步数为 1），另一部分直接从顶点 1 出发（步数为 0），但需确保首次回到 1 时步数 ≥1。
   - **终止条件**：首次遇到回到顶点 1 的路径即为最短环。

2. **难点对比**  
   - **初始状态处理**：部分题解错误地将 `dis[1]` 初始化为 0，导致可能误判自环（但题目保证无自环）；正确做法需确保路径至少经过一条边。
   - **访问标记**：需标记已访问节点避免重复计算，但需注意不影响其他路径的探索。

3. **解决策略**  
   - **从顶点 1 出发**：在 BFS 中，当某节点的邻居是 1 时，步数为当前步数 +1，直接输出结果（如 shitingjia 的解法）。
   - **从邻居出发**：初始化队列为顶点 1 的邻居，步数为 1，最终 `d[1]` 为最短环长度（如 Heldivis 的解法）。

### 题解评分（≥4星）
1. **Heldivis（4星）**  
   - **亮点**：从顶点 1 的邻居出发，避免直接处理顶点 1 的初始状态。代码简洁高效，时间复杂度 O(N + M)。
   - **代码核心**：
     ```cpp
     for (int y : e[1]) q.push(y), d[y] = 1;  // 初始化邻居
     while (q.size()) {
       // BFS 更新最短路径
       if (d[y] > d[x] + 1) d[y] = d[x] + 1;
     }
     ```

2. **shitingjia（4星）**  
   - **亮点**：从顶点 1 直接启动 BFS，首次遇到返回顶点 1 的路径即输出。直观且符合 BFS 最短路径特性。
   - **代码核心**：
     ```cpp
     q.push({1, 0});  // 初始步数为 0
     if (v == 1) cout << time + 1;  // 发现环立即输出
     ```

3. **chenxi2009（4星）**  
   - **亮点**：通过 `w + 1` 记录步数，仅在非初始状态下（`w != 0`）才判定环有效。
   - **代码核心**：
     ```cpp
     if (v == 1) { ans = w + 1; break; }  // 确保步数不为 0
     ```

### 最优思路提炼
- **关键技巧**：利用 BFS 的层级扩展特性，保证首次找到的环为最短。
- **数据结构**：队列管理待扩展节点，`dis` 数组记录最短步数，`vis` 数组标记访问状态。
- **优化点**：直接从顶点 1 出发，避免处理邻居初始化的额外逻辑。

### 同类题目
1. **P2661 [NOIP2015 提高组] 信息传递**  
   有向图最小环模板题，直接应用上述 BFS 或并查集。
2. **P1144 最短路计数**  
   BFS 的变种，统计最短路径数量。
3. **CF510B Fox And Two Dots**  
   图中寻找环的存在性，DFS/BFS 均可解。

### 个人心得摘录
- **初始状态陷阱**：部分题解因错误初始化 `dis[1]` 导致逻辑错误，需严格验证边界条件。
- **BFS 特性**：首次访问即最短的特性是解题关键，避免使用 DFS 导致超时。

### 算法可视化设计
1. **动画演示**  
   - **节点状态**：未访问（灰色）、已访问（绿色）、当前处理（红色）。
   - **队列动态**：实时显示队列中的节点及步数，扩展时高亮新节点。
   - **环检测**：当某边指向顶点 1 时，路径高亮为黄色并显示步数。

2. **复古像素风格**  
   - **节点绘制**：8-bit 风格方块，不同颜色区分状态。
   - **音效**：节点扩展时播放“滴”声，发现环时播放胜利音效。

3. **交互功能**  
   - **步进控制**：支持暂停/继续/单步执行，观察 BFS 扩展过程。
   - **自动演示**：AI 自动运行，展示最短路径的生成过程。

### 核心代码（BFS 实现）
```cpp
// 示例代码：从顶点 1 出发的 BFS
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
vector<int> g[N];
int dis[N];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
    }
    
    memset(dis, -1, sizeof(dis));
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : g[u]) {
            if (v == 1 && dis[u] + 1 > 0) {  // 排除初始状态
                cout << dis[u] + 1;
                return 0;
            }
            if (dis[v] == -1) {
                dis[v] = dis[u] + 1;
                q.push(v);
            }
        }
    }
    cout << -1;
    return 0;
}
```

---
处理用时：241.78秒
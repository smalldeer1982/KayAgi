# 题目信息

# [ABC384E] Takahashi is Slime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_e

縦 $ H $ 行横 $ W $ 列のマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ H) $、左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ と呼ぶことにします。

はじめ、マス $ (i,j) $ には強さ $ S\ _\ {i,j} $ のスライムがおり、マス $ (P,Q) $ にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（$ 0 $ 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

- 高橋くんに隣接するスライムのうち、強さが高橋くんの強さの $ \dfrac1X $ 倍**未満**のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
 
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq500 $
- $ 1\leq\ P\leq\ H $
- $ 1\leq\ Q\leq\ W $
- $ 1\leq\ X\leq10^9 $
- $ 1\leq\ S_{i,j}\leq10^{12} $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。 
![](https://img.atcoder.jp/abc384/6b3d3bbde4767c7f5070ad0b1f202043.png) 例えば、高橋くんは次のように行動を行うことができます。 
![](https://img.atcoder.jp/abc384/81c0ccdba241277bf0cdd16ae6a7c54d.png) - マス $ (2,1) $ にいるスライムを吸収する。高橋くんの強さは $ 9+4=13 $ となり、新たにマス $ (1,1) $ のスライムとマス $ (3,1) $ のスライムが高橋くんと隣接する。 - マス $ (1,2) $ にいるスライムを吸収する。高橋くんの強さは $ 13+6=19 $ となり、新たにマス $ (1,3) $ のスライムが高橋くんと隣接する。 - マス $ (1,3) $ にいるスライムを吸収する。高橋くんの強さは $ 19+9=28 $ となる。 以上の行動を行ったあと、高橋くんの強さは $ 28 $ となります。 高橋くんがどのように行動を行っても、高橋くんの強さを $ 28 $ より大きくすることはできないため、`28` を出力してください。 高橋くんの強さの $ \dfrac12 $ 倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス $ (1,1) $ にいるスライムを吸収することはできません。

### Sample Explanation 2

高橋くんはどのスライムも吸収できません。

## 样例 #1

### 输入

```
3 3 2

2 2

14 6 9

4 9 20

17 15 7```

### 输出

```
28```

## 样例 #2

### 输入

```
3 4 1

1 1

5 10 1 1

10 1 1 1

1 1 1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
8 10 2

1 5

388 130 971 202 487 924 247 286 237 316

117 166 918 106 336 928 493 391 235 398

124 280 425 955 212 988 227 222 307 226

336 302 478 246 950 368 291 236 170 101

370 200 204 141 287 410 388 314 205 460

291 104 348 337 404 399 416 263 415 339

105 420 302 334 231 481 466 366 401 452

119 432 292 403 371 417 351 231 482 184```

### 输出

```
1343```

# AI分析结果



## 算法分类
**BFS**

## 题解思路与解决难点
### 核心思路
本题需要通过贪心策略选择吸收顺序，使用优先队列（小根堆）实现 BFS，每次优先吸收相邻的强度最小的史莱姆。通过维护当前总强度并动态扩展相邻节点，确保每次决策最优。

### 解决难点
1. **贪心策略证明**：需证明优先吸收较小强度的史莱姆不会使后续更优解丢失。若当前最小不可吸收，则更大必不可吸收；反之吸收后总强度增加，可能解锁更多节点。
2. **数值溢出处理**：条件 `S_ij < C/X` 需避免乘法溢出。题解中通过 `__int128` 或转换除法判断（如 `S_ij < (C + X - 1) // X`）解决。
3. **队列管理**：需标记已访问节点防止重复加入队列，同时动态扩展新邻接节点。

## 题解评分
1. **ikunTLE（★★★★★）**  
   - 使用 `__int128` 避免溢出，思路清晰，代码简洁高效。
2. **Moya_Rao（★★★★☆）**  
   - 详细分析错误经历，最终通过优先队列和除法转换解决问题，代码可读性高。
3. **xiaoshumiao（★★★★☆）**  
   - 代码简短且正确，明确贪心策略，适合快速理解。

## 最优思路与技巧
- **优先队列贪心**：每次取最小强度节点，确保及时提升总强度。
- **溢出处理技巧**：用 `__int128` 或除法变形（如 `S < (C+X-1)/X`）避免乘法溢出。
- **动态扩展邻接点**：吸收后立即将新邻接点加入队列，保证不漏掉任何可能。

## 同类型题推荐
1. **洛谷 P1141** - 01迷宫（BFS扩展连通块）
2. **洛谷 P1162** - 填涂颜色（BFS边界处理）
3. **洛谷 P3956** - 棋盘（优先队列BFS）

## 代码片段
```cpp
priority_queue<node, vector<node>, greater<node>> pq;
int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};
// 初始化队列，将起点周围节点加入
vis[p][q] = true;
int power = s[p][q];
for (int i = 0; i < 4; i++) {
    int xx = p + dx[i], yy = q + dy[i];
    if (valid(xx, yy) && !vis[xx][yy]) {
        vis[xx][yy] = true;
        pq.push({xx, yy, s[xx][yy]});
    }
}
// BFS主循环
while (!pq.empty()) {
    auto u = pq.top(); pq.pop();
    if (u.num * X >= power) break; // 用__int128判断
    power += u.num;
    for (int i = 0; i < 4; i++) {
        int xx = u.x + dx[i], yy = u.y + dy[i];
        if (valid(xx, yy) && !vis[xx][yy]) {
            vis[xx][yy] = true;
            pq.push({xx, yy, s[xx][yy]});
        }
    }
}
```

## 可视化设计
- **动画方案**：以网格展示，当前高桥位置用绿色闪烁，队列中节点用黄色标记，已吸收节点变红。每次取出队列最小节点时高亮，吸收后扩展邻接点。
- **复古像素风格**：使用8位色块，吸收时播放“哔”声，失败时播放低沉音效。自动演示模式下，算法按步执行，用户可调节速度。
- **交互功能**：提供暂停/继续、单步执行、速度滑动条，右侧面板显示当前总强度和队列状态。

---

通过上述分析与实现，可深入理解BFS结合贪心的策略，有效解决动态扩展的最优化问题。

---
处理用时：73.51秒
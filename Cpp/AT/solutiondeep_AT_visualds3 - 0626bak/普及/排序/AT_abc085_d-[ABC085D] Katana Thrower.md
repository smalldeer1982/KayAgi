# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果



## 算法分类
**贪心**

---

## 题解分析与结论

### 核心算法思路
1. **关键贪心策略**：优先使用投掷伤害高于最大挥砍伤害的刀，剩余生命值用最大挥砍伤害刀处理。
2. **实现步骤**：
   - 计算所有刀的挥砍最大值 `max_a`。
   - 筛选出投掷伤害高于 `max_a` 的刀，按投掷伤害从大到小排序。
   - 依次投掷这些刀，直到总伤害足够或投掷完毕。
   - 剩余生命值用 `max_a` 计算挥砍次数。

### 解决难点
- **如何避免无效投掷**：仅投掷伤害高于最大挥砍的刀，保证每次攻击的收益最大化。
- **时间复杂度优化**：通过两次排序（挥砍和投掷）将复杂度控制在 O(n log n)。

### 可视化设计思路
- **动画流程**：用进度条表示魔物血量，每次攻击后更新血量。投掷显示为红色块，挥砍为蓝色块。
- **高亮操作**：当前选择的攻击方式（投掷/挥砍）用闪烁效果标记。
- **复古像素风格**：魔物血量用 8-bit 血条表示，投掷时刀飞出并伴随爆炸音效，挥砍时刀光闪烁。

---

## 题解评分（≥4星）

1. **Hilte（5星）**
   - **亮点**：代码简洁高效，仅需两次排序，直接筛选有效投掷。
   - **代码片段**：
     ```cpp
     sort(a + 1, a + n + 1);  // 挥砍排序
     sort(b + 1, b + n + 1);  // 投掷排序
     for (int i = n; i >= 1 && b[i] > a[n]; i--)  // 投掷处理
     ans += (h + a[n] - 1) / a[n];  // 挥砍次数计算
     ```

2. **ITZDC9（4星）**
   - **亮点**：直观拆分攻击方式为独立元素，通用性强。
   - **代码片段**：
     ```cpp
     struct knife { int m; bool t; };  // 拆分攻击方式
     sort(k, cmp);  // 按伤害排序
     if (k[i].t) h -= k[i].m;  // 投掷处理
     else ans += ceil(h / k[i].m);  // 挥砍处理
     ```

3. **Mysterious_Cat（4星）**
   - **亮点**：显式筛选有效投掷并用向量优化。
   - **代码片段**：
     ```cpp
     vector<long long> v;  // 存储有效投掷
     for (int i = 1; i <= n; i++)
         if (b[i] > max_a) v.push_back(b[i]);
     sort(v.begin(), v.end());  // 排序
     ```

---

## 最优技巧提炼
- **贪心核心**：一次性操作（投掷）的收益必须高于重复操作（挥砍）。
- **数据结构优化**：通过排序快速筛选有效攻击方式，减少无效计算。

---

## 类似题目推荐
1. **P1090 合并果子**：贪心选择最小堆合并。
2. **P1209 修理牛棚**：贪心选择最大间隔。
3. **P4995 跳跳！**：贪心选择最大高度差跳跃。

---

## 个人心得摘录
> "在错误思路中发现，投掷伤害不一定全部有效，必须结合挥砍的最大值筛选。" —— ITZDC9

---

## 可视化实现（伪代码）
```javascript
// 初始化画布与音效
const canvas = initCanvas();
const attackSound = loadSound('throw.wav');
const bgm = loadSound('8bit_bgm.mp3');

// 核心逻辑
function simulateAttack(maxA, throws, H) {
    let steps = 0;
    // 投掷阶段
    for (const t of throws) {
        H -= t;
        steps++;
        canvas.highlightThrow(t); // 红色高亮
        playSound(attackSound);
        if (H <= 0) break;
    }
    // 挥砍阶段
    if (H > 0) {
        const cnt = Math.ceil(H / maxA);
        steps += cnt;
        canvas.highlightSwing(cnt); // 蓝色高亮
    }
    return steps;
}
```

---
处理用时：253.64秒
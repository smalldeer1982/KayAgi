# 题目信息

# [ABC114C] 755

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc114/tasks/abc114_c

整数 $ N $ が与えられます。$ 1 $ 以上 $ N $ 以下の整数のうち、*七五三数* は何個あるでしょうか？

ここで、七五三数とは以下の条件を満たす正の整数です。

- 十進法で表記したとき、数字 `7`, `5`, `3` がそれぞれ $ 1 $ 回以上現れ、これら以外の数字は現れない。

## 说明/提示

### 制約

- $ 1\ \leq\ N $
- $ N $ は整数である。

### Sample Explanation 1

$ 575 $ 以下の七五三数は、$ 357,\ 375,\ 537,\ 573 $ の $ 4 $ 個です。

### Sample Explanation 2

$ 3600 $ 以下の七五三数は、上記の $ 4 $ 個と $ 735,\ 753,\ 3357,\ 3375,\ 3537,\ 3557,\ 3573,\ 3575,\ 3577 $ の計 $ 13 $ 個です。

## 样例 #1

### 输入

```
575```

### 输出

```
4```

## 样例 #2

### 输入

```
3600```

### 输出

```
13```

## 样例 #3

### 输入

```
999999999```

### 输出

```
26484```

# AI分析结果



---

## 算法分类  
**DFS**  

---

## 综合分析与结论  
**核心思路**：通过 DFS 递归生成仅由 3/5/7 构成的数字，同时跟踪各数字是否出现。当生成的数字满足条件（包含 3/5/7 且 ≤N）时计数。  
**解决难点**：  
1. **状态跟踪**：使用位掩码（二进制位 0b111 表示三者均存在）或布尔变量，避免每次分解数字检查。  
2. **剪枝优化**：生成的数字超过 N 时立即停止递归。  
**可视化设计**：  
- **树状展开**：以初始值 0 为根节点，每层追加 3/5/7 生成子节点，形成三叉树结构。  
- **颜色标记**：绿色节点表示满足条件（包含 3/5/7），红色表示超过 N，灰色表示未完成状态。  
- **步进动画**：点击“下一步”时展开当前节点的三个子节点，显示新数值和状态掩码。  

---

## 题解清单 (≥4星)  
1. **XWCL_OI（5星）**  
   - 关键亮点：代码极简，用三个布尔参数直接跟踪数字存在性，逻辑清晰。  
   - 代码片段：  
     ```cpp  
     void dfs(long long x, int a, int b, int c) {  
         if(x > n) return;  
         ans += a && b && c;  
         dfs(x*10+3, 1, b, c);  
         dfs(x*10+5, a, 1, c);  
         dfs(x*10+7, a, b, 1);  
     }  
     ```  

2. **high_sky（4星）**  
   - 关键亮点：位掩码（`f` 参数）高效判断条件，代码简洁。  
   - 代码片段：  
     ```cpp  
     void dfs(int x, int f) {  
         if(x > n) return;  
         if(f == 7) ans++;  
         dfs(x*10+3, f | 4);  
         dfs(x*10+5, f | 2);  
         dfs(x*10+7, f | 1);  
     }  
     ```  

3. **BotDand（4星）**  
   - 关键亮点：提供 BFS/DFS 双解，位运算优化状态管理。  
   - 代码片段：  
     ```cpp  
     // BFS 核心逻辑  
     struct arr { int n, num; };  
     queue<arr> q;  
     while(!q.empty()) {  
         arr x = q.front(); q.pop();  
         if(x.num == 7) ans++;  
         q.push({x.n*10+3, x.num | 1});  
         q.push({x.n*10+5, x.num | 2});  
         q.push({x.n*10+7, x.num | 4});  
     }  
     ```  

---

## 最优思路提炼  
1. **位掩码技巧**：用二进制位 0b100（4）、0b010（2）、0b001（1）分别表示 3/5/7 的存在，总和 0b111（7）即为满足条件。  
2. **剪枝优化**：递归时优先判断 `x > N` 直接返回，避免无效生成。  
3. **状态传递**：在递归参数中直接传递当前是否包含 3/5/7，避免分解数字的耗时操作。  

---

## 同类型题推荐  
1. **P1217** [USACO1.5]回文质数：生成回文数并判断是否为质数。  
2. **P1036** 选数：组合数字求和并判断素数。  
3. **P1706** 全排列问题：生成所有排列的经典 DFS 题。  

---

## 个人心得摘录  
- **溢出陷阱**：多位题解强调用 `long long` 存储生成的数，避免 `int` 溢出。  
- **位运算优化**：多位作者使用二进制位掩码代替布尔变量，减少参数数量和判断时间。  

---

## 可视化与算法演示  
**复古像素风格设计**：  
- **Canvas 绘制**：节点显示为 16x16 像素方块，数字用 8-bit 字体居中显示。  
- **音效触发**：生成新节点时播放“嘟”声，满足条件时播放“成功”音效。  
- **自动演示**：默认以 1 秒/步自动展开节点，支持暂停/步进。  

**交互示例**：  
```javascript  
// 伪代码：DFS 可视化核心逻辑  
function visualizeDFS(x, mask) {  
    drawNode(x, mask);  
    if (x > N) return;  
    setTimeout(() => {  
        visualizeDFS(x*10+3, mask | 4);  
        visualizeDFS(x*10+5, mask | 2);  
        visualizeDFS(x*10+7, mask | 1);  
    }, 1000);  
}  
visualizeDFS(0, 0);  
```  

---

## 核心代码实现  
**DFS + 位掩码（high_sky 题解）**  
```cpp  
#include <iostream>  
using namespace std;  

int n, ans;  
void dfs(int x, int f) {  
    if (x > n) return;  
    if (f == 7) ans++;  
    dfs(x * 10 + 3, f | 4);  
    dfs(x * 10 + 5, f | 2);  
    dfs(x * 10 + 7, f | 1);  
}  

int main() {  
    cin >> n;  
    dfs(0, 0);  
    cout << ans;  
    return 0;  
}  
```  

**代码解析**：  
- `dfs(0, 0)` 从 0 开始生成数字，初始状态无任何数字。  
- `f` 参数用二进制位表示 3/5/7 是否存在，`f == 7`（二进制 111）时计数。

---
处理用时：100.43秒
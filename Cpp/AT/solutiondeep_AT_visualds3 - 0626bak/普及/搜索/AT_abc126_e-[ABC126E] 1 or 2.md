# 题目信息

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5```

### 输出

```
2```

## 样例 #3

### 输入

```
100000 1

1 100000 100```

### 输出

```
99999```

# AI分析结果



## 算法分类
其他搜索（并查集）

---

## 题解思路与算法分析

### 核心思路
将卡牌间的奇偶关系转化为图论连通性问题，每个连通块只需确定一个卡牌即可推导所有卡牌值。通过并查集合并所有存在约束关系的卡牌，最终答案即为连通块数量。

### 解决难点
1. **条件转化**：将约束条件 $A_x + A_y + Z$ 的奇偶性转化为卡牌间的奇偶性关联，不论 Z 的具体值，只需建立 x 与 y 的连通关系。
2. **连通性维护**：使用并查集高效维护卡牌间的关联关系，最终统计独立连通块数量。

### 可视化算法演示
1. **节点初始化**：每个卡牌初始为独立节点。
2. **合并过程**：根据约束条件动态合并节点，形成连通块。
3. **连通块统计**：不同颜色标记各连通块，数量即为答案。

**复古像素风格设计**：
- **节点表示**：8-bit 像素方块，合并时播放经典音效。
- **动画效果**：节点合并时闪烁高亮，连通块用不同颜色填充。
- **自动演示**：按输入顺序逐步合并节点，最终显示连通块数量。

---

## 题解评分（≥4星）

1. **徐晨轩（5星）**  
   代码最简练，直接体现并查集核心逻辑，适合快速理解算法本质。

2. **龙潜月十五（4星）**  
   详细推导奇偶关系转化过程，代码规范易读，注释清晰。

3. **Warriors_Cat（4星）**  
   代码结构清晰，包含路径压缩优化，适合学习并查集实现细节。

---

## 最优思路提炼
- **奇偶关系等价处理**：任何约束条件都等价于建立卡牌间的连通性，无需具体计算奇偶。
- **连通块计数**：每个连通块只需确定一个初始值，最小次数=连通块数。

---

## 同类题目推荐
1. **P3367** 【模板】并查集  
2. **P1525** 关押罪犯（并查集处理对立关系）  
3. **P1892** 团伙（朋友与敌人关系建模）

---

## 个人心得摘录
> "此题的思维转换非常妙，将看似数学的条件转化为图论连通性问题，这种抽象能力是算法竞赛的核心。" —— 龙潜月十五

---

## 核心代码实现
```cpp
#include <iostream>
using namespace std;

int parent[100010];

int find(int x) {
    return parent[x] == x ? x : parent[x] = find(parent[x]);
}

void unite(int x, int y) {
    parent[find(x)] = find(y);
}

int main() {
    int n, m, x, y, z, ans = 0;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) parent[i] = i;
    while (m--) {
        cin >> x >> y >> z;
        unite(x, y);
    }
    for (int i = 1; i <= n; ++i)
        if (find(i) == i) ans++;
    cout << ans << endl;
}
```

---

## 可视化设计要点
- **像素动画**：Canvas 绘制节点，合并时播放 8-bit 音效。
- **自动模式**：按输入顺序合并节点，实时显示连通块数。
- **交互控制**：支持暂停/继续，速度调节观察合并细节。

**颜色方案**：
- 未合并节点：灰色方块  
- 合并过程：黄色闪烁  
- 连通块：随机生成复古色调色板填充

---
处理用时：90.86秒
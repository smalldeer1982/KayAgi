# 题目信息

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>```

### 输出

```
15```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G```

### 输出

```
-1```

# AI分析结果



---

**算法分类**  
BFS

---

### **题解思路、算法要点与解决难点**  

**核心思路**  
本题的关键在于预处理所有被视线覆盖的格子，随后使用 BFS 寻找最短路径。具体步骤如下：  
1. **预处理视线区域**：遍历每个方向的人（`>`, `v`, `<`, `^`），沿其视线方向标记所有连续的 `.` 格子为不可走，直到遇到障碍物或其他人。  
2. **BFS 寻路**：从起点开始，通过 BFS 逐层扩展，避开被标记的视线区域、障碍物及其他人所在位置，最终找到到终点的最短路径。  

**解决难点**  
- **视线预处理**：正确判断视线延伸的终止条件（遇到非 `.` 的格子），确保不会错误覆盖起点 `S` 和终点 `G`。  
- **时间复杂度优化**：每个格子最多被 4 个方向的人覆盖，预处理复杂度为 O(HW)，BFS 复杂度同为 O(HW)，整体高效。  

**算法实现要点**  
- **预处理方向循环**：对每个方向的人，沿其视线方向循环标记格子，遇到非 `.` 则停止。  
- **BFS 队列管理**：使用队列记录待访问节点，通过 `visited` 数组避免重复访问。  

---

### **题解评分 (≥4星)**  

1. **Dream_poetry 题解 (★★★★☆)**  
   - **亮点**：预处理逻辑清晰，正确处理视线终止条件；代码可读性强，BFS 实现简洁。  
   - **代码片段**：  
     ```cpp  
     // 处理 '>' 的视线  
     int tmp = j + 1;  
     while (tmp <= m && s[i][tmp] == '.') {  
         vis[i][tmp] = 1;  
         tmp++;  
     }  
     ```  

2. **liruixiong0101 题解 (★★★★☆)**  
   - **亮点**：动态规划预处理视线，优化标记过程；利用方向标志数组实现高效覆盖。  
   - **代码片段**：  
     ```cpp  
     // 动态规划预处理视线  
     f[i][j][0] |= c[i][j] == 'v' | f[i-1][j][0];  
     f[i][j][1] |= c[i][j] == '>' | f[i][j-1][1];  
     ```  

3. **__Dist__ 题解 (★★★★☆)**  
   - **亮点**：直接在原网格中标记视线区域（替换为 `!`），简化判断逻辑；BFS 条件明确。  
   - **代码片段**：  
     ```cpp  
     // 处理 '^' 的视线  
     int ii = i-1, jj = j;  
     while (ch[ii][jj] == '.' && ii >= 1) ch[ii--][jj] = '!';  
     ```  

---

### **最优思路或技巧提炼**  

1. **方向遍历优化**  
   - 对每个方向的人，沿其视线方向逐格标记，直到遇到非 `.` 的格子或边界。  
   - 使用循环实现快速覆盖，避免重复判断。  

2. **BFS 剪枝策略**  
   - 使用 `visited` 数组记录已访问节点，避免重复入队。  
   - 在 BFS 中直接排除被标记的视线区域和障碍物。  

3. **动态规划预处理**  
   - 通过动态规划预处理每个格子是否被视线覆盖，减少重复遍历。  

---

### **同类型题或类似算法套路**  

- **迷宫最短路径**：如 LeetCode 的“迷宫问题”，需预处理陷阱区域后 BFS。  
- **动态障碍物处理**：如《吃豆人》游戏中的幽灵视线，需实时更新可行走区域。  
- **多源 BFS**：如同时处理多个起点，适用于火焰扩散类问题。  

---

### **推荐题目**  
1. **洛谷 P1135** - 奇怪的电梯（BFS 最短路径）  
2. **洛谷 P1443** - 马的遍历（BFS 分层扩展）  
3. **洛谷 P1141** - 01迷宫（连通块预处理 + BFS）  

---

### **可视化与算法演示**  

**动画设计**  
- **网格绘制**：Canvas 绘制 H×W 网格，不同颜色区分空地、障碍、视线区域、起点/终点。  
- **BFS 过程**：  
  - **当前节点**：红色高亮，展示扩展的四个方向。  
  - **队列节点**：黄色标记，表示待访问的节点。  
  - **已访问节点**：灰色覆盖，避免重复处理。  
- **步进控制**：支持暂停/继续、调整动画速度，观察队列变化。  

**复古像素风格**  
- **颜色方案**：8-bit 风格，使用经典红、黄、灰、黑配色。  
- **音效**：  
  - **访问新节点**：短促“哔”声。  
  - **找到终点**：胜利音效（8-bit 风格）。  
- **自动演示**：AI 自动执行 BFS，动态展示队列扩展过程。  

**关键代码片段（JS）**  
```javascript  
// 绘制网格（Canvas）  
function drawGrid() {  
    for (let i = 0; i < H; i++) {  
        for (let j = 0; j < W; j++) {  
            ctx.fillStyle = getColor(grid[i][j]);  
            ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);  
        }  
    }  
}  

// BFS 自动执行  
function bfsStep() {  
    if (queue.length === 0) return;  
    let [x, y] = queue.shift();  
    // 高亮当前节点  
    highlight(x, y);  
    for (let d of dirs) {  
        let nx = x + d[0], ny = y + d[1];  
        if (isValid(nx, ny) && !visited[nx][ny]) {  
            visited[nx][ny] = true;  
            queue.push([nx, ny]);  
            // 播放音效  
            playSound('step');  
        }  
    }  
}  
```  

---

**个人心得**  
- **预处理验证**：在调试时需确保视线区域正确覆盖，可通过打印预处理后的网格排查错误。  
- **边界处理**：网格边界和方向循环的终止条件容易出错，需仔细检查。  
- **性能优化**：预处理和 BFS 均需考虑时间复杂度，避免嵌套循环导致的超时。

---
处理用时：181.81秒
# 题目信息

# [ABC348D] Medicines on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc348/tasks/abc348_d

$ H $ 行 $ W $ 列のグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,\ j) $ と表します。各マスの状態は文字 $ A_{i,j} $ で表され、意味は以下の通りです。

- `.` : 空きマス。
- `#` : 障害物。
- `S` : 空きマスかつスタート地点。
- `T` : 空きマスかつゴール地点。
 
高橋君は、今いるマスから上下左右に隣り合う空きマスへ、エネルギーを $ 1 $ 消費して移動することができます。ただし、エネルギーが $ 0 $ の状態で移動することはできず、またグリッドの外へ移動することはできません。

グリッドには合計で $ N $ 個の薬があります。$ i $ 番目の薬は空きマス $ (R_i,\ C_i) $ にあり、使うとエネルギーを **$ E_i $ にする**ことができます。必ずしもエネルギーが増えるとは限らないことに注意してください。高橋君は自分のいるマスにある薬を使うことができます。使った薬はなくなります。

高橋君ははじめエネルギー $ 0 $ の状態でスタート地点にいて、ゴール地点まで移動したいです。これが可能かどうか判定してください。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 200 $
- $ A_{i,\ j} $ は `.`, `#`, `S`, `T` のいずれかである。
- `S` と `T` は $ A_{i,\ j} $ にそれぞれちょうど $ 1 $ つ存在する。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ R_i\ \leq\ H $
- $ 1\ \leq\ C_i\ \leq\ W $
- $ i\ \neq\ j $ ならば $ (R_i,\ C_i)\ \neq\ (R_j,\ C_j) $
- $ A_{R_i,\ C_i} $ は `#` でない。
- $ 1\ \leq\ E_i\ \leq\ HW $
 
### Sample Explanation 1

例えば、以下のようにしてゴール地点へ移動することができます。 - 薬 $ 1 $ を使う。エネルギーが $ 3 $ になる。 - $ (1,\ 2) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (1,\ 3) $ へ移動する。エネルギーが $ 1 $ になる。 - 薬 $ 2 $ を使う。エネルギーが $ 5 $ になる。 - $ (2,\ 3) $ へ移動する。エネルギーが $ 4 $ になる。 - $ (3,\ 3) $ へ移動する。エネルギーが $ 3 $ になる。 - $ (3,\ 4) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (4,\ 4) $ へ移動する。エネルギーが $ 1 $ になる。 この移動の途中には $ (2,\ 3) $ にも薬がありますが、これを使うとゴールできません。

### Sample Explanation 2

高橋君はスタート地点から移動することができません。

## 样例 #1

### 输入

```
4 4

S...

#..#

#...

..#T

4

1 1 3

1 3 5

3 2 1

2 3 1```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2 2

S.

T.

1

1 2 4```

### 输出

```
No```

## 样例 #3

### 输入

```
4 5

..#..

.S##.

.##T.

.....

3

3 1 5

1 2 3

2 2 1```

### 输出

```
Yes```

# AI分析结果



## 算法分类
**BFS**（优先队列优化的广度优先搜索）

---

## 综合分析与结论
### 题解思路与核心难点
1. **能量管理**：每个节点的有效状态取决于到达时的最大剩余能量，需维护每个节点的能量最大值。
2. **优先队列优化**：优先处理能量高的状态，加快到达终点的速度。
3. **药物使用逻辑**：在药物节点处，能量取当前剩余值-1与药物值的较大者。

### 核心难点解决
- **状态剪枝**：若当前路径的剩余能量不大于该节点的历史最大值，则跳过。
- **优先级策略**：优先队列确保能量高的状态优先扩展，减少无效搜索。

### 可视化设计思路
- **网格动画**：以像素风格绘制网格，起点/终点/药物节点用不同颜色标识。
- **队列状态**：展示优先队列中节点的能量值，当前处理的节点高亮。
- **步进控制**：允许用户控制动画速度，单步观察能量更新和节点扩展。
- **音效提示**：访问新节点时播放音效，到达终点时播放成功音效。

---

## 题解清单（评分≥4星）
1. **作者：__ATRI__（5星）**
   - **亮点**：优先队列优化，清晰维护每个节点的最大能量值。
   - **代码片段**：
     ```cpp
     priority_queue<node> q;
     q.push({sx, sy, dis[sx][sy]});
     while (q.size()) {
         auto [x, y, val] = q.top();
         if (x == fx && y == fy) return "Yes";
         q.pop();
         if (val < dis[x][y]) continue;
         for (移动方向) {
             int new_val = max(药的能量, val - 1);
             if (new_val > dis[新坐标]) {
                 dis[新坐标] = new_val;
                 q.push(新坐标);
             }
         }
     }
     ```

2. **作者：maokaiyu（4.5星）**
   - **亮点**：普通队列维护最大值剪枝，代码简洁。
   - **核心代码**：
     ```cpp
     queue<node> q;
     q.push({sx, sy, e[sx][sy]});
     while (!q.empty()) {
         auto [x, y, e] = q.front();
         if (到达终点) return true;
         for (移动方向) {
             int ne = max(药值, e - 1);
             if (ne > dis[新坐标]) {
                 dis[新坐标] = ne;
                 q.push(新坐标);
             }
         }
     }
     ```

3. **作者：eb0ycn（4星）**
   - **亮点**：SPFA式松弛思想，动态维护状态。
   - **代码关键**：
     ```cpp
     struct node { int x, y, val; };
     priority_queue<node> q; // 按val降序
     ```

---

## 最优思路提炼
**堆优化BFS + 能量最大值剪枝**：  
- 使用优先队列确保每次扩展能量最大的节点。
- 维护`dis[x][y]`记录到达(x,y)的最大能量。
- 药物节点处更新能量为`max(药值, 当前能量-1)`。

---

## 类似题目推荐
1. **P1605 迷宫**（基础BFS）
2. **P1443 马的遍历**（BFS求最短步数）
3. **P1162 填涂颜色**（BFS扩展应用）

---

## 可视化算法演示（伪代码）
```javascript
// 伪代码：优先队列BFS动画逻辑
class Visualizer {
  constructor(grid) {
    this.grid = grid; // 网格数据
    this.pq = new PriorityQueue((a,b) => b.val - a.val); // 优先队列
    this.pq.push({x: sx, y: sy, val: initial_energy});
    this.visited = array.fill(0); // 维护最大值
  }

  step() {
    if (pq.empty()) return false;
    let current = pq.pop();
    highlight(current.x, current.y); // 高亮当前节点
    if (is_goal(current)) playSuccessSound();
    for (dir in directions) {
      let next = move(current, dir);
      let new_val = max(next.energy, current.val - 1);
      if (new_val > visited[next.x][next.y]) {
        visited[next.x][next.y] = new_val;
        pq.push(next);
        drawEdge(current, next); // 绘制移动路径
      }
    }
    return true;
  }
}
```

---

## 复古像素风格设计
- **颜色方案**：16色，障碍用深灰，药物节点亮绿色。
- **Canvas绘制**：每个节点为8x8像素块，队列状态侧边栏显示。
- **音效**：8-bit音效，移动时“哔”声，找到终点时胜利旋律。
- **自动演示**：按帧逐步执行，支持暂停/继续。

---

**核心代码片段（JS）**  
```javascript
// 绘制网格
function drawGrid() {
  ctx.fillStyle = '#000';
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] === '#') ctx.fillRect(j*8, i*8, 8, 8);
      else if (isStart(i,j)) ctx.fillStyle = '#0F0'; // 亮绿起点
      // ...其他颜色逻辑
    }
  }
}
```

---
处理用时：67.01秒
# 题目信息

# [ABC361D] Go Stone Puzzle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_d

$ N+2 $ 個のマスが横一列に並んでいます。左から $ i $ 番目のマスをマス $ i $ と表します。

マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれています。  
 各 $ 1\leq\ i\ \leq\ N $ について、$ S_i $ が `W` のときマス $ i $ に置かれている石の色は白であり、$ S_i $ が `B` のときマス $ i $ に置かれている石の色は黒です。  
 マス $ N+1,N+2 $ には何も置かれていません。

あなたは以下の操作を好きな回数($ 0 $ 回でもよい)行うことができます。

- 石が $ 2 $ 個並んでいる箇所を選び、その $ 2 $ 個の石を順序を保って空きマスに移す。  
   より正確には次の通り。$ 1 $ 以上 $ N+1 $ 以下の整数 $ x $ であって、マス $ x,x+1 $ の両方に石が置かれているものを選ぶ。石の置かれていないマスを $ k,k+1 $ とする。マス $ x,x+1 $ にある石をそれぞれマス $ k,k+1 $ に移動する。
 
以下の状態にすることが可能か判定し、可能なら操作回数の最小値を求めてください。

- マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれており、各 $ 1\leq\ i\ \leq\ N $ について、$ T_i $ が `W` のときマス $ i $ に置かれている石の色は白、$ T_i $ が `B` のときマス $ i $ に置かれている石の色は黒である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 14 $
- $ N $ は整数である
- $ S,T $ は `B` および `W` のみからなる長さ $ N $ の文字列である
 
### Sample Explanation 1

石が置かれていないマスを `.` と表します。以下のようにして $ 4 $ 回の操作で目的の状態にすることができ、これが最小回数です。 - `BWBWBW..` - `BW..BWBW` - `BWWBB..W` - `..WBBBWW` - `WWWBBB..`

## 样例 #1

### 输入

```
6

BWBWBW

WWWBBB```

### 输出

```
4```

## 样例 #2

### 输入

```
6

BBBBBB

WWWWWW```

### 输出

```
-1```

## 样例 #3

### 输入

```
14

BBBWBWWWBBWWBW

WBWWBBWWWBWBBB```

### 输出

```
7```

# AI分析结果



### 唯一算法分类：BFS

---

### 综合分析与结论

1. **核心思路**  
   题目要求通过交换相邻石块到空位，达到目标状态的最小操作次数。由于 N ≤14，BFS 是唯一可行解法：  
   - **状态表示**：使用字符串（如 `BWBW..`）或三进制压缩表示当前棋盘布局。  
   - **状态转移**：枚举所有可能的相邻石块对，将其与空位交换生成新状态。  
   - **判重优化**：通过哈希表（如 `unordered_map`）或状态压缩避免重复访问。

2. **解决难点**  
   - **状态爆炸**：N=14 时理论状态数为 3^16≈4.3e7，需高效判重。  
   - **空位位置跟踪**：部分题解记录空位位置（如 `k` 和 `k+1`），减少无效枚举。  
   - **剪枝优化**：仅当相邻位置均为非空时才交换，避免无效操作。

3. **可视化设计**  
   - **动画效果**：  
     - **网格展示**：每个格子显示 B/W 或空位（`.`），当前操作的石块高亮为红色，空位为灰色。  
     - **队列状态**：右侧面板显示 BFS 队列中的待处理状态，当前状态标为蓝色。  
     - **步进控制**：允许调节速度或单步执行，观察状态扩展过程。  
   - **复古风格**：  
     - **8 位像素风**：使用 16 色调色板，石块用不同颜色方块表示，移动时播放经典音效。  
     - **音效触发**：生成新状态时播放“滴”声，找到解时播放胜利旋律，失败时低沉音效。  
   - **自动演示**：AI 自动执行 BFS 过程，类似贪吃蛇 AI，展示节点扩展顺序。

---

### 题解清单（≥4星）

| 题解作者 | 评分 | 关键亮点 |
|---------|------|----------|
| shangruolin | ★★★★☆ | 使用 `tuple` 存储状态，代码简洁清晰，哈希判重高效。 |
| Heldivis | ★★★★☆ | 记录空位位置，减少无效枚举，状态转移优化明显。 |
| nightwatch.ryan | ★★★★☆ | 明确分离状态与空位位置，代码可读性高，逻辑直接。 |

---

### 代码核心实现

**shangruolin的BFS核心代码**  
```cpp
queue<T> q;
q.push(MT(0, n + 1, a)); // 初始状态
mp[a] = 1;
while (!q.empty()) {
    auto [x, y, s] = q.front(); q.pop();
    if (s == target) return x; // 找到目标
    for (int i = 1; i <= n+1; i++) {
        if (s[i] != '#' && s[i+1] != '#') { // 可交换位置
            swap(s[i], s[y]); swap(s[i+1], s[y+1]); // 生成新状态
            if (!mp[s]) {
                mp[s] = 1;
                q.push(MT(x+1, i, s));
            }
            swap(s[i], s[y]); swap(s[i+1], s[y+1]); // 还原
        }
    }
}
```

**Heldivis的状态优化代码**  
```cpp
struct Node { string s; int w, fre; }; // fre记录空位左端点
queue<Node> q;
q.push({s, 0, n+1}); // 初始空位在n+1和n+2
while (!q.empty()) {
    auto [s, w, fre] = q.front(); q.pop();
    for (int i = 1; i <= n+1; i++) {
        if (s[i] != '#' && s[i+1] != '#') { // 仅处理非空位
            swap(s[i], s[fre]); swap(s[i+1], s[fre+1]); // 交换到空位
            if (!vis[s]) q.push({s, w+1, i});
        }
    }
}
```

---

### 同类型题推荐

1. **八数码问题（洛谷 P1379）**  
   BFS + 状态压缩，类似棋盘状态转移。  
2. **马的遍历（洛谷 P1443）**  
   BFS 求最短路径，网格移动规则明确。  
3. **奇怪的电梯（洛谷 P1135）**  
   状态转移为楼层跳跃，BFS 最短步数。

---

### 可视化与复古游戏化设计

1. **Canvas 网格绘制**  
   - 每个格子渲染为 32x32 像素，B/W 用蓝/黄方块，空位为灰色。  
   - 当前操作块用红色边框，队列状态用右侧滚动面板展示。  
2. **音效与动画**  
   - 移动时播放 8-bit “哔”声，找到解时播放经典《超级玛丽》通关音乐。  
   - 背景音乐循环播放 FC 风格轻快旋律。  
3. **自动演示模式**  
   - 自动执行 BFS，高亮当前扩展节点，队列动态更新。  
   - 支持暂停/继续，速度调节（1x/2x/5x）。  

```javascript
// 示例：音效触发（伪代码）
function playMoveSound() {
    const beep = new Audio('data:audio/wav;base64,UklGRl9...'); // 8-bit 音效
    beep.play();
}
```

---

**总结**：BFS 是本题唯一可行解法，核心在于高效状态表示与判重。结合复古像素风动画和音效，可直观展示搜索过程，提升学习趣味性。

---
处理用时：84.22秒
# 题目信息

# [ABC363E] Sinking Land

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_e

$ H\ \times\ W $ の大きさの島があり、島は周りを海で囲まれています。  
 島は 縦 $ H $ 個 $ \times $ 横 $ W $ 個の $ 1\times\ 1 $ の区画に分けられており、上から $ i $ 番目かつ左から $ j $ 番目の区画の（現在の海面を基準にした）標高は $ A_{i,j} $ です。

現在から $ 1 $ 年ごとに海面の高さが $ 1 $ ずつ上昇します。  
 このとき、海または海に沈んだ区画に上下左右に隣接する区画であって、標高が海面の高さ **以下** の区画は海に沈みます。  
 ここで、ある区画が新しく海に沈んだときそれと上下左右に隣接する区画であって海面の高さ以下のものも同時に海に沈み、これによって新しく沈んだ区画についてもこれは繰り返されます。

$ i=1,2,\ldots,\ Y $ それぞれについて、現在から $ i $ 年後に、島のうち海に沈まず残っている部分の面積を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ 1\leq\ Y\leq\ 10^5 $
- $ 1\leq\ A_{i,j}\leq\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

島の上から $ i $ 番目かつ左から $ j $ 番目の区画を $ (i,j) $ で表します。このとき、次のようになります。 - $ 1 $ 年後、海面は現在より $ 1 $ 上昇しますが、海に面している標高 $ 1 $ の区画は存在しないため、どの区画も沈みません。よって、$ 1 $ 行目には $ 9 $ を出力します。 - $ 2 $ 年後、海面は現在より $ 2 $ 上昇し、$ (1,2) $ が海に沈みます。これによって、$ (2,2) $ は海に沈んだ区画に隣接する区画となりますが、その標高は $ 2 $ 以下であるため、これも海に沈みます。これら以外にこの時点で他に沈む区画はありません。よって、$ 2 $ つの区画が沈むため、$ 2 $ 行目には $ 9-2=7 $ を出力します。 - $ 3 $ 年後、海面は現在より $ 3 $ 上昇し、$ (2,1) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 3 $ 行目には $ 6 $ を出力します。 - $ 4 $ 年後、海面は現在より $ 4 $ 上昇し、$ (2,3) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 4 $ 行目には $ 5 $ を出力します。 - $ 5 $ 年後、海面は現在より $ 5 $ 上昇し、$ (3,2) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 5 $ 行目には $ 4 $ を出力します。 よって、$ 9,7,6,5,4 $ をこの順に各行に出力します。

## 样例 #1

### 输入

```
3 3 5

10 2 10

3 1 4

10 5 10```

### 输出

```
9

7

6

5

4```

## 样例 #2

### 输入

```
3 5 3

2 2 3 3 3

2 1 2 1 3

2 2 3 3 3```

### 输出

```
15

7

0```

# AI分析结果



# 核心算法分类：BFS

## 题解思路、算法要点与解决难点

### 算法核心思路
所有题解均采用 **优先队列优化的BFS** 策略，将可能被淹没的区画按海拔排序处理：
1. **初始化**：将所有边缘区画加入优先队列，标记为临海状态
2. **逐年处理**：每年取出所有海拔 ≤ 当前年份的区画进行淹没，并将其相邻未淹没区画加入优先队列
3. **动态维护**：通过标记数组避免重复处理，确保每个区画只被处理一次

### 解决的核心难点
- **动态边界维护**：淹没区域会不断产生新的临海区画，需高效管理当前可能被淹没的边界
- **时间复杂度优化**：避免每年全图遍历，通过优先队列将时间复杂度优化至 O(HW logHW + Y)

### 搜索算法要点
- **发起方式**：优先队列初始装入所有边缘区画（视为初始边界）
- **访问顺序**：始终处理当前海拔最低的临海区画（类似Dijkstra）
- **数据结构**：最小堆 + 二维标记数组（记录是否已入队/已淹没）

---

## 题解评分（≥4★）

### 1. cqbzcjh（5★）
- **亮点**：代码简洁高效，完整实现优先队列BFS逻辑
- **关键代码**：
```cpp
priority_queue<node> q;
for(int i=1;i<=h;i++) for(int j=1;j<=w;j++) 
    if((i==1)||(i==h)||(j==1)||(j==w))
        q.push({a[i][j],i,j});
while(q.top().v<=i){
    node u=q.top(); q.pop();
    ans--;
    // 扩展相邻区画
}
```

### 2. T_TLucas_Yin（4★）
- **亮点**：正确处理n=1或m=1的边界情况
- **关键处理**：
```cpp
if(m==1) // 处理单列情况
if(n==1) // 处理单行情况
```

### 3. _O_v_O_（4★）
- **亮点**：DFS递归处理淹没区域，结合优先队列管理边界
- **独特之处**：
```cpp
void dfs(int x,int y,int z){
    vis[x][y]=1; ans--;
    // 递归处理相邻区画
}
```

---

## 最优思路提炼

### 关键技巧
1. **优先队列管理动态边界**：将可能被淹没的区画按海拔排序，确保每次处理最低点
2. **标记数组双重作用**：
   - `vis[x][y]` 标记是否已淹没
   - `inq[x][y]` 防止重复入队
3. **增量式处理**：每年只需处理新增淹没区画，无需全图遍历

### 思维启示
- **时间维度转化**：将逐年处理转化为海拔排序处理
- **边界动态扩展**：新淹没区画的相邻区画自动成为下一阶段边界

---

## 同类题目推荐
1. **P1584 魔杖**：动态扩展的BFS应用
2. **P1162 填涂颜色**：洪水填充基础变种
3. **P1443 马的遍历**：BFS最短路径基础

---

## 可视化设计

### 动画方案
1. **像素风格渲染**：8-bit网格显示，淹没区画显示为蓝色，边界区画为黄色
2. **动态队列显示**：右侧面板实时显示优先队列中的海拔值
3. **年轮特效**：每年海平面上升时播放水波纹动画

### 交互功能
- **步进控制**：空格键单步执行淹没过程
- **速度调节**：滑块控制动画速度（0.5x-5x）
- **音效反馈**：
  - `pop.wav`：区画出队时播放
  - `splash.wav`：区画被淹没时播放

### 核心动画逻辑
```javascript
// 伪代码示例
class Visualization {
    constructor(grid) {
        this.pq = new MinHeap();
        this.year = 0;
        // 初始化边缘入队
    }

    step() {
        while(pq.top().height <= currentYear) {
            let cell = pq.pop();
            floodCell(cell); // 淹没动画
            for(let neighbor of getNeighbors(cell)) {
                if(!visited[neighbor]) {
                    pq.push(neighbor);
                    highlightEdge(neighbor); // 边界高亮
                }
            }
        }
        currentYear++;
    }
}
```

---

## 代码实现示例
```cpp
// 优先队列BFS核心实现
#include<bits/stdc++.h>
using namespace std;

const int N=1005;
int h,w,Y,a[N][N],remaining;
bool vis[N][N]; // 是否已淹没

struct Node {
    int val,x,y;
    bool operator<(const Node& t) const {
        return val > t.val; // 小根堆
    }
};
priority_queue<Node> q;

int main() {
    cin>>h>>w>>Y;
    remaining = h*w;
    
    // 初始化边缘
    for(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {
        cin>>a[i][j];
        if(i==1||i==h||j==1||j==w) {
            q.push({a[i][j],i,j});
            vis[i][j] = true;
        }
    }

    for(int year=1; year<=Y; year++) {
        while(!q.empty() && q.top().val <= year) {
            auto [v,x,y] = q.top(); q.pop();
            remaining--;
            
            // 扩展相邻区画
            for(int d=0; d<4; d++) {
                int nx=x+(d==1)-(d==3);
                int ny=y+(d==0)-(d==2);
                if(nx<1||nx>h||ny<1||ny>w) continue;
                if(!vis[nx][ny]) {
                    vis[nx][ny] = true;
                    q.push({a[nx][ny],nx,ny});
                }
            }
        }
        cout<<remaining<<endl;
    }
    return 0;
}
```

---
处理用时：72.74秒
# 题目信息

# [ABC373D] Hidden Weights

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc373/tasks/abc373_d

$ N $ 頂点 $ M $ 辺の有向グラフが与えられます。$ j $ 番目の有向辺は頂点 $ u_j $ から頂点 $ v_j $ に向かっており、重み $ w_j $ を持っています。

各頂点に $ -10^{18} $ 以上 $ 10^{18} $ 以下の整数を書き込む方法であって、次の条件を満たすものを $ 1 $ つ見つけてください。

- 頂点 $ i $ に書き込まれている値を $ x_i $ とする。すべての辺 $ j=1,2,\dots,M $ について、$ x_{v_j}\ -\ x_{u_j}\ =\ w_j $ が成り立つ。

与えられる入力について、条件を満たす書き込み方が少なくとも $ 1 $ つ存在することが保証されます。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\{2\ \times\ 10^5,N(N-1)/2\} $
- $ 1\ \leq\ u_j,\ v_j\ \leq\ N $
- $ u_j\ \neq\ v_j $
- $ i\ \neq\ j $ なら $ (u_i,v_i)\ \neq\ (u_j,v_j) $ かつ $ (u_i,v_i)\ \neq\ (v_j,u_j) $
- $ |w_j|\ \leq\ 10^9 $
- 入力はすべて整数
- 条件を満たす書き込み方が少なくとも $ 1 $ つ存在する

### Sample Explanation 1

$ x=(3,5,2) $ とすることで、$ x_2-x_1=w_1=2,x_2-x_3=w_2=3,x_3-x_1=w_3=-1 $ となり、条件を満たします。 他にも、たとえば $ x=(-1,1,-2) $ としても正解となります。

### Sample Explanation 2

他にも、たとえば $ x=(0,-5,4,1) $ や $ x=(5,0,4,1) $ としても正解となります。

## 样例 #1

### 输入

```
3 3
1 2 2
3 2 3
1 3 -1```

### 输出

```
3 5 2```

## 样例 #2

### 输入

```
4 2
2 1 5
3 4 -3```

### 输出

```
5 0 6 3```

## 样例 #3

### 输入

```
5 7
2 1 18169343
3 1 307110901
4 1 130955934
2 3 -288941558
2 5 96267410
5 3 -385208968
4 3 -176154967```

### 输出

```
200401298 182231955 -106709603 69445364 278499365```

# AI分析结果



# [ABC373D] Hidden Weights 题解分析

## 算法分类
**BFS**

## 题解思路与核心难点
### 核心思路
所有题解的共同思路是**将有向边转换为无向图的双向边**，通过 BFS/DFS 遍历每个连通块，并为每个节点赋值。具体步骤：
1. **双向建边**：对每条有向边 `u→v(w)`，添加反向边 `v→u(-w)`，确保遍历时覆盖所有可能路径。
2. **连通块处理**：每个连通块任选一个起始点（如第一个未访问节点），将其值设为 0，通过 BFS/DFS 遍历整个连通块。
3. **递推赋值**：根据边权动态计算相邻节点的值，如 `x[v] = x[u] + w`。

### 解决难点
- **双向建边**：正确理解 `x[v] - x[u] = w` 与反向边 `x[u] - x[v] = -w` 的等价性。
- **连通性处理**：确保遍历所有连通块，每个块独立处理。
- **数值溢出**：使用 `long long` 存储节点值。

---

## 题解评分（≥4星）
1. **ikunTLE（5星）**  
   - **亮点**：代码简洁，使用邻接表+BFS，处理多个连通块逻辑清晰。
   - **代码片段**：
     ```cpp
     queue<int> q;
     q.push(i); vis[i] = true;
     while (!q.empty()) {
         int u = q.front();
         for (auto i: vc[u]) {
             if (!vis[i.v]) {
                 ans[i.v] = ans[u] + i.w; // 递推赋值
                 q.push(i.v);
             }
         }
         q.pop();
     }
     ```

2. **SkyWave（4星）**  
   - **亮点**：手动实现队列优化性能，代码规范，强调无向图转化思想。

3. **liuziqin（4星）**  
   - **亮点**：链式前向星建图，结构清晰，适合大规模数据。

---

## 最优思路提炼
1. **双向建边**：将 `u→v(w)` 转换为 `u→v(w)` 和 `v→u(-w)`，确保遍历覆盖所有可能路径。
2. **连通块遍历**：每个连通块独立处理，初始节点设为 0，BFS/DFS 递推计算。
3. **时间复杂度**：`O(N + M)`，适合处理 2e5 规模的节点和边。

---

## 类似题目推荐
1. **洛谷 P1993 小K的农场**（差分约束系统）
2. **洛谷 P1269 信号放大器**（连通块遍历与条件约束）
3. **LeetCode 886. Possible Bipartition**（图着色与连通块处理）

---

## 算法可视化设计
### 动画演示方案
1. **节点与边绘制**：  
   - 节点用像素方块表示，已访问节点为绿色，未访问为灰色。
   - 边用线条连接，正权边蓝色，负权边红色。

2. **搜索过程**：  
   - **BFS层级扩展**：队列节点按层级展开，当前处理节点高亮黄色。
   - **递推赋值**：显示 `x[v] = x[u] + w` 公式，数值实时更新。

3. **交互功能**：  
   - **步进控制**：支持暂停/继续/单步执行。
   - **速度调节**：拖动滑块调整动画速度（100ms~2s）。

4. **复古像素风格**：  
   - **8-bit 音效**：访问节点时播放 `beep` 音效，连通块完成时播放胜利音效。
   - **背景音乐**：循环播放 FC 风格的轻快旋律。

### 关键代码片段（JavaScript）
```javascript
// 绘制节点（Canvas）
function drawNode(ctx, node, color) {
    ctx.fillStyle = color;
    ctx.fillRect(node.x * 50, node.y * 50, 40, 40);
    ctx.fillStyle = 'black';
    ctx.fillText(`x=${node.value}`, node.x * 50 + 5, node.y * 50 + 20);
}

// BFS 单步执行
function bfsStep() {
    if (queue.length === 0) return;
    let u = queue.shift();
    highlightNode(u); // 高亮当前节点
    for (let edge of adj[u]) {
        if (!vis[edge.v]) {
            vis[edge.v] = true;
            x[edge.v] = x[u] + edge.w;
            queue.push(edge.v);
            playSound('beep'); // 播放音效
        }
    }
}
```

---

## 个人心得
- **双向建边**是本题关键，需深刻理解 `x[v] - x[u] = w` 的对称性。
- **初始值任意性**：由于保证有解，初始节点设为 0 不会影响解的可行性。
- **避免数值溢出**：必须使用 `long long`，`int` 会导致 WA。

---
处理用时：86.01秒
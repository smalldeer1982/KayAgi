# 题目信息

# [ABC376D] Cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点 $ M $ 辺の単純有向グラフがあります。$ i $ 番目の辺 $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ a_i $ から頂点 $ b_i $ へ伸びる辺です。  
 頂点 $ 1 $ を含む閉路が存在するか判定して、存在する場合はそのような閉路のうち辺数が最小の閉路の辺数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\ \left(\ \frac{N(N-1)}{2},\ 2\ \times\ 10^5\ \right) $
- $ 1\ \leq\ a_i\ \leq\ N $
- $ 1\ \leq\ b_i\ \leq\ N $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ かつ $ (a_i,\ b_i)\ \neq\ (b_j,\ a_j) $
- 入力される値は全て整数
 
### Sample Explanation 1

頂点 $ 1 $ $ \to $ 頂点 $ 2 $ $ \to $ 頂点 $ 3 $ $ \to $ 頂点 $ 1 $ は辺数が $ 3 $ の閉路で、これが頂点 $ 1 $ を含む唯一の閉路です。

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2

1 2

2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 9

6 1

1 5

2 6

2 1

3 6

4 2

6 4

3 5

5 4```

### 输出

```
4```

# AI分析结果



### 唯一算法分类
BFS

### 题解思路与算法要点
**核心思路**：在边权为1的有向图中，BFS天然适合寻找最短路径。包含顶点1的最小环等价于从1出发回到1的最短路径。  
**算法要点**：  
1. **搜索初始化**：以顶点1为起点，将其邻接顶点作为第一层节点入队（距离初始化为1）。  
2. **访问顺序**：BFS按层遍历，保证第一次回到1时的路径长度最小。  
3. **终止条件**：处理顶点u的出边时，若发现边u→1，立即返回当前路径长度+1。  
4. **数据结构**：队列维护待处理顶点，visited数组避免重复访问。  

**解决难点**：  
- 正确处理顶点1的初始状态，避免自环干扰（题目保证无自环）。  
- 最短路径的及时判定，需在第一次遇到u→1时立即返回结果。  
- 高效处理大规模数据（O(N+M)时间复杂度）。  

### 题解评分（≥4星）
1. **Heldivis（5星）**  
   正确初始化邻接顶点的距离，通过BFS更新所有顶点到1的最短距离，最后取顶点1的距离值。逻辑清晰，代码简洁高效。  
2. **__FL__（4星）**  
   在BFS过程中直接检测环，队列记录(顶点,步数)，第一时间返回结果。代码可读性强，但初始入队顶点1步数为0需结合题意理解。  
3. **chenxi2009（4星）**  
   使用pair记录步数，遇到u→1时及时返回结果。正确处理了顶点访问标记，避免重复计算。  

### 最优思路提炼
- **关键技巧**：BFS层序特性保证最短路径，遇到回边立即终止。  
- **实现细节**：  
  - 队列初始化时只处理顶点1的邻接顶点，距离设为1。  
  - 当处理顶点u的出边v时，若v=1，则路径长度为d[u]+1。  
  - 使用visited数组避免重复访问，保证时间复杂度线性。  

### 同类型题与算法套路
- **通用解法**：边权为1的最短路径问题优先考虑BFS，复杂权重用Dijkstra。  
- **相似题目**：  
  1. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)（有向图最小环）  
  2. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)（BFS统计最短路数量）  
  3. [CF862B](https://codeforces.com/problemset/problem/862/B)（二分图染色+BFS）  

### 可视化与算法演示
**动画设计**：  
1. **节点状态**：  
   - 白色：未访问  
   - 绿色：在队列中  
   - 红色：已处理  
2. **遍历过程**：  
   - 初始：顶点1的邻接顶点入队（变为绿色）。  
   - 步进：每次取出队首节点（变红），遍历其出边。  
   - 终止：若某边指向1，高亮该边并显示环长。  
3. **交互功能**：  
   - 速度调节：滑动条控制动画速度。  
   - 单步执行：逐步观察BFS扩展过程。  

**复古像素风格**：  
- 8-bit色调色板，节点用16x16像素方块表示。  
- 边绘制为黄色像素线，回边高亮为闪烁红色。  
- 音效：  
  - 入队：短促“哔”声。  
  - 找到环：8-bit胜利音效。  

### 核心代码片段
```cpp
// 作者：Heldivis 的 BFS 实现
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5+5;
vector<int> e[MAXN];
int d[MAXN];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i=0; i<m; i++) {
        int a, b;
        cin >> a >> b;
        e[a].push_back(b);
    }
    memset(d, 0x3f, sizeof(d));
    queue<int> q;
    // 初始化：1的邻接顶点入队
    for (int v : e[1]) {
        d[v] = 1;
        q.push(v);
    }
    // BFS核心
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : e[u]) {
            if (d[v] > d[u] + 1) {
                d[v] = d[u] + 1;
                q.push(v);
            }
        }
    }
    // 输出结果
    if (d[1] >= 1e9) cout << -1;
    else cout << d[1];
    return 0;
}
```

### 个人心得摘录
- **调试教训**：初始时将顶点1自身入队会导致错误环长判定（需排除自环）。  
- **优化顿悟**：BFS层序特性天然保证最短路径，无需额外比较。  
- **代码简洁性**：直接处理邻接顶点初始化，避免复杂条件判断。

---
处理用时：220.89秒
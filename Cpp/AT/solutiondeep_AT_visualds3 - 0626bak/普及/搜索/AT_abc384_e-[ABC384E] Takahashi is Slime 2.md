# 题目信息

# [ABC384E] Takahashi is Slime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_e

縦 $ H $ 行横 $ W $ 列のマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ H) $、左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ と呼ぶことにします。

はじめ、マス $ (i,j) $ には強さ $ S\ _\ {i,j} $ のスライムがおり、マス $ (P,Q) $ にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（$ 0 $ 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

- 高橋くんに隣接するスライムのうち、強さが高橋くんの強さの $ \dfrac1X $ 倍**未満**のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
 
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq500 $
- $ 1\leq\ P\leq\ H $
- $ 1\leq\ Q\leq\ W $
- $ 1\leq\ X\leq10^9 $
- $ 1\leq\ S_{i,j}\leq10^{12} $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。 
![](https://img.atcoder.jp/abc384/6b3d3bbde4767c7f5070ad0b1f202043.png) 例えば、高橋くんは次のように行動を行うことができます。 
![](https://img.atcoder.jp/abc384/81c0ccdba241277bf0cdd16ae6a7c54d.png) - マス $ (2,1) $ にいるスライムを吸収する。高橋くんの強さは $ 9+4=13 $ となり、新たにマス $ (1,1) $ のスライムとマス $ (3,1) $ のスライムが高橋くんと隣接する。 - マス $ (1,2) $ にいるスライムを吸収する。高橋くんの強さは $ 13+6=19 $ となり、新たにマス $ (1,3) $ のスライムが高橋くんと隣接する。 - マス $ (1,3) $ にいるスライムを吸収する。高橋くんの強さは $ 19+9=28 $ となる。 以上の行動を行ったあと、高橋くんの強さは $ 28 $ となります。 高橋くんがどのように行動を行っても、高橋くんの強さを $ 28 $ より大きくすることはできないため、`28` を出力してください。 高橋くんの強さの $ \dfrac12 $ 倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス $ (1,1) $ にいるスライムを吸収することはできません。

### Sample Explanation 2

高橋くんはどのスライムも吸収できません。

## 样例 #1

### 输入

```
3 3 2

2 2

14 6 9

4 9 20

17 15 7```

### 输出

```
28```

## 样例 #2

### 输入

```
3 4 1

1 1

5 10 1 1

10 1 1 1

1 1 1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
8 10 2

1 5

388 130 971 202 487 924 247 286 237 316

117 166 918 106 336 928 493 391 235 398

124 280 425 955 212 988 227 222 307 226

336 302 478 246 950 368 291 236 170 101

370 200 204 141 287 410 388 314 205 460

291 104 348 337 404 399 416 263 415 339

105 420 302 334 231 481 466 366 401 452

119 432 292 403 371 417 351 231 482 184```

### 输出

```
1343```

# AI分析结果



## 算法分类
**BFS**

---

## 题解思路与算法要点

### **核心思路**
采用 **贪心+BFS** 策略，每次优先吸收邻接点中强度最小的史莱姆，通过优先队列（小根堆）实现这一过程。关键点在于：
1. **贪心策略**：吸收最小强度的史莱姆能更快提升总强度，从而可能解锁更多吸收机会。
2. **终止条件**：当队列中最小的强度无法被吸收时，后续所有节点均无法被吸收，直接退出。
3. **数值处理**：用除法判断 `S < current_power / X` 避免大数相乘溢出（如 `S * X < current_power` 可能溢出）。

### **解决难点**
- **贪心正确性证明**：若当前最小强度无法被吸收，则更大强度的史莱姆必然无法被吸收，此时总强度达到最大值。
- **溢出处理**：通过 `__int128` 或转换为除法运算避免 `S * X` 溢出 `long long` 范围。
- **邻接点动态扩展**：每吸收一个新节点，其相邻未被访问的节点被加入优先队列，并标记已访问。

---

## 题解评分（≥4星）

### ikunTLE（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：代码简洁，正确处理溢出（使用 `__int128`），优先队列实现高效。
- **代码片段**：
  ```cpp
  while (!pq.empty()) {
      node u = pq.top(); pq.pop();
      if (u.num * X >= power) return; // 终止条件
      power += u.num;
      // 扩展邻接点
  }
  ```

### Moya_Rao（⭐️⭐️⭐️⭐️）
- **亮点**：详细记录调试过程，最终通过除法避免溢出，代码可读性强。
- **关键修改**：
  ```cpp
  if (s[t.x][t.y] < (now + p - 1) / p) { ... }
  ```

### xyx404（⭐️⭐️⭐️⭐️）
- **亮点**：直接使用 `__int128` 避免溢出，优先队列实现清晰。
- **代码片段**：
  ```cpp
  if (G * nu * X >= G * no) break; // __int128 比较
  ```

---

## 最优思路提炼
1. **贪心选择邻接点**：用小根堆维护邻接点，每次取出最小强度。
2. **动态扩展邻接区域**：吸收新节点后，将其四周未访问节点加入堆。
3. **终止条件优化**：当堆顶节点无法被吸收时，直接退出循环。

---

## 类似题目与算法套路
- **同类型题**：迷宫最短路径（BFS+优先队列，如 Dijkstra 算法）。
- **通用套路**：贪心+BFS 适用于需要动态选择最优子问题的场景，如最小生成树、最短路径等。

### 推荐题目
1. **P1443 马的遍历**（BFS 基础）
2. **P1902 刺杀大使**（BFS+二分答案）
3. **P3956 棋盘**（BFS+优先队列）

---

## 个人心得摘录
- **Moya_Rao**：`“乘法改除法，加个向上取整，完美搞定！”` → 强调数值处理技巧。
- **xiaoshumiao**：`“第一次做出五题，纪念！”` → 体现解题成就感。

---

## 可视化与算法演示
### 动画设计
1. **网格绘制**：用 Canvas 绘制 H×W 网格，初始高桥位置高亮。
2. **优先队列操作**：动态显示队列中的节点（颜色区分已访问/待访问）。
3. **吸收过程**：吸收节点时，其颜色变暗，总强度数值实时更新。
4. **终止条件触发**：当堆顶节点无法被吸收时，播放警示音效。

### 复古像素风格
- **颜色方案**：8-bit 风格，绿色（可吸收）、红色（不可吸收）、灰色（已吸收）。
- **音效**：吸收时播放“收集金币”音效，终止时播放“失败”音效。
- **自动演示**：模拟 BFS 扩展过程，支持暂停/继续/步进。

```javascript
// 示例代码（伪代码）
function drawGrid() {
    // 绘制网格和节点状态
}
function bfsStep() {
    let node = priorityQueue.pop();
    if (node.value * X >= currentPower) {
        playSound('fail');
        stopAnimation();
    } else {
        currentPower += node.value;
        playSound('collect');
        expandNeighbors(node);
    }
}
```

---

## 代码实现（核心逻辑）
```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int N=505;
int H,W,X,p,q,s[N][N],vis[N][N],dx[]={0,1,-1,0,0},dy[]={0,0,0,1,-1};
struct Node{int x,y,v;};
priority_queue<Node, vector<Node>, greater<Node>> pq;

bool operator>(const Node& a, const Node& b){
    return a.v > b.v;
}

signed main(){
    // 输入初始化
    int current = s[p][q];
    vis[p][q] = 1;
    // 初始邻接点加入队列
    for(int i=1; i<=4; i++){
        int nx=p+dx[i], ny=q+dy[i];
        if(nx>=1 && nx<=H && ny>=1 && ny<=W && !vis[nx][ny]){
            pq.push({nx, ny, s[nx][ny]});
            vis[nx][ny] = 1;
        }
    }
    while(!pq.empty()){
        Node u = pq.top(); pq.pop();
        if(u.v * X >= current) break;
        current += u.v;
        // 扩展新邻接点
        for(int i=1; i<=4; i++){
            int nx=u.x+dx[i], ny=u.y+dy[i];
            if(nx>=1 && nx<=H && ny>=1 && ny<=W && !vis[nx][ny]){
                pq.push({nx, ny, s[nx][ny]});
                vis[nx][ny] = 1;
            }
        }
    }
    cout << current;
}
```

---
处理用时：68.35秒
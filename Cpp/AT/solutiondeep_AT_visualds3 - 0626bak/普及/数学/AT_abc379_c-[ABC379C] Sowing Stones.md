# 题目信息

# [ABC379C] Sowing Stones

## 题目描述

给你两个数 $n$，$m$。

表示现在有 $n$ 个格子，再给你 $m$ 组数据，表示在第 $X_i$ 个格子上有 $A_i$ 个石头。

有以下操作（可以不移动）。

- 对于第 $i$ 个格子，如果这个格子上有石头 ，可以将这个格子的一个石头移动到第 $i+1$ 个格子上。

求使得每个格子上恰好有一个石头的最小移动次数，如果无法满足条件输出 $-1$。


- 第一行：$N$ $M$ 

- 第二行：$X_1$ $X_2$ $\ldots$ $X_M$

- 第三行：$A_1$ $A_2$ $\ldots$ $A_M$

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^{9} $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^{5} $
- $ M\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ X_i\ \neq\ X_j $ $ (1\ \leq\ i\ <\ j\ \leq\ M) $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^{9} $ $ (1\ \leq\ i\ \leq\ M) $
- 输入为整数
 
### Sample Explanation 1

可以通过如下 $4$ 次操作使条件满足，且没有比 $4$ 次更小的次数。

初始条件：第一个格子上有 $3$ 个石头，第四个格子上有 $2$ 个石头。

- 移动一个石头从格子 $1$ 到格子 $2$。

- 再移动一个石头从格子 $1$ 到格子 $2$。 

- 移动一个石头从格子 $2$ 到格子 $3$。

- 移动一个石头从格子 $4$ 到格子 $5$。

操作完成后每个格子上都有一个石头。

### Sample Explanation 2

这个数据中无论如何移动一定无法使每个格子上有一个石头。

## 样例 #1

### 输入

```
5 2

1 4

3 2```

### 输出

```
4```

## 样例 #2

### 输入

```
10 3

1 4 8

4 2 4```

### 输出

```
-1```

# AI分析结果



## 唯一算法分类
贪心

---

## 综合分析与结论

本题核心在于通过贪心策略模拟石头移动过程。关键点包括：  
1. **总和校验**：总石头数必须等于格子数，否则无解。  
2. **排序处理**：将有石头的格子按坐标排序，确保处理顺序从左到右。  
3. **区间填充**：每个相邻石头格子之间的空白区间需要足够石头填充，否则无解。  
4. **操作次数计算**：填满区间的操作次数为等差数列求和，剩余石头传递到下个格子的次数为线性乘积。  

**可视化设计思路**：  
- **动画流程**：用网格表示所有格子，高亮当前处理区间，动态显示石头移动轨迹。  
- **颜色标记**：已处理区间用绿色，当前处理区间用黄色，剩余石头传递用箭头标记。  
- **步进控制**：允许单步执行观察每个区间的处理细节，显示当前操作次数累加过程。  
- **复古像素风格**：采用 8-bit 风格渲染格子，移动石头时播放经典音效（如“吃金币”音效）。  

---

## 题解清单 (≥4星)

1. **Po7ed（4星）**  
   - 亮点：逻辑清晰，排序后逐个处理区间，代码简洁高效，关键注释到位。  
   - 心得：强调冷静分析细节，通过添加虚拟节点简化边界处理。  

2. **I_Love_DS（4星）**  
   - 亮点：逆向处理思路独特，从后往前覆盖区间，等差数列计算优化。  
   - 心得：引入“填满区间后更新右端点”的巧妙方法，避免复杂传递逻辑。  

3. **kairuigg（4星）**  
   - 亮点：三种情况分类明确，优先队列处理剩余石头，代码可读性强。  
   - 心得：通过离散化处理大范围数据，动态调整剩余石头的传递路径。  

---

## 最优思路提炼

**关键步骤**：  
1. **排序与校验**：排序后检查总石头数和首格是否为1。  
2. **区间贪心填充**：  
   - 每个区间长度需 ≤ 当前可用石头数（A_i-1）。  
   - 填满区间的操作次数为 `t*(t+1)/2`（t为区间长度）。  
   - 剩余石头传递到下个格子，操作次数为 `剩余数 * 传递距离`。  
3. **虚拟终点处理**：添加 n+1 作为虚拟终点，最终检验是否有剩余。  

**技巧**：  
- **等差数列求和**：快速计算区间填满的操作次数。  
- **虚拟节点**：统一处理最后一个区间到终点的逻辑。  

---

## 同类型题推荐

1. **P1090 合并果子**（贪心+优先队列）  
2. **P1223 排队接水**（贪心排序）  
3. **P3819 松江1843路**（区间覆盖与资源分配）  

---

## 代码片段（核心逻辑）

```cpp
// 基于 Po7ed 题解的核心实现
struct Stone { int x; ll a; };
vector<Stone> a(m);
// 输入处理后排序
sort(a.begin(), a.end(), [](auto& u, auto& v) { return u.x < v.x; });
a.emplace_back(n+1, 0); // 添加虚拟终点

ll ans = 0;
for (int i = 0; i < m; ++i) {
    ll available = a[i].a - 1; // 保留一个石头
    ll gap = a[i+1].x - a[i].x - 1;
    if (available < gap) { cout << -1; return; }
    ans += gap * (gap + 1) / 2; // 填满区间
    ll remain = available - gap;
    ans += remain * (a[i+1].x - a[i].x); // 传递剩余
    a[i+1].a += remain; // 传递到下一个格子
}
if (a.back().a > 0) cout << -1;
else cout << ans;
```

---

## 可视化与复古动画设计

**动画方案**：  
- **像素网格**：每个格子用 32x32 像素方块表示，石头用圆形像素点。  
- **填充动画**：处理区间时，石头逐个向右移动，显示移动路径的箭头。  
- **音效触发**：  
  - 填充区间：播放“叮”声（类似吃金币）。  
  - 传递剩余：播放“嗖”声（快速移动音效）。  
- **自动演示**：按空格键切换自动/手动模式，速度可调。  

**Canvas 示例**：  
```javascript
// 伪代码：填充区间动画
function animateFill(start, end, stones) {
    for (let pos = start; pos <= end; pos++) {
        drawStone(pos); // 绘制石头
        playSound('fill'); // 播放音效
        delay(100); // 控制动画速度
    }
}
```

**复古元素**：  
- **调色板**：使用 NES 经典绿、蓝、红像素色调。  
- **背景音乐**：8-bit 风格循环旋律，营造怀旧氛围。

---
处理用时：125.05秒
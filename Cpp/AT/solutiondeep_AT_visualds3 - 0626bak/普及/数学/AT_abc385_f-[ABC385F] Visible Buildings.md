# 题目信息

# [ABC385F] Visible Buildings

## 题目描述

在数轴上有编号从 $1$ 到 $N$ 的建筑物。第 $i$ 个建筑物位于坐标 $X_i$ 处，高度为 $H_i$。除了高度外的其他方向的尺寸可以忽略不计。

从坐标为 $x$ 且高度为 $h$ 的点 $P$ 看，如果存在建筑物 $i$ 上的某个点 $Q$，使得线段 $PQ$ 不与任何其他建筑物相交，则认为该建筑物是可见的。

请找出在坐标 $0$ 处的最大高度，使得在该高度无法看到所有建筑物。高度必须是非负的；如果在坐标 $0$ 处的高度 $0$ 就能看到所有建筑物，则输出 `-1`。

## 说明/提示

- $1 \leq N \leq 2 \times 10^5$
- $1 \leq X_1 < \dots < X_N \leq 10^9$
- $1 \leq H_i \leq 10^9$
- 所有输入值均为整数。

## 样例 #1

### 输入

```
3
3 2
5 4
7 5```

### 输出

```
1.500000000000000000```

## 样例 #2

### 输入

```
2
1 1
2 100```

### 输出

```
-1```

## 样例 #3

### 输入

```
3
1 1
2 2
3 3```

### 输出

```
0.000000000000000000```

## 样例 #4

### 输入

```
4
10 10
17 5
20 100
27 270```

### 输出

```
17.142857142857142350```

# AI分析结果



---

**算法分类选择**  
无算法分类（数学几何观察）

---

**题解思路、算法要点与解决难点**  
**核心思路**：所有题解均指出，只需考虑相邻两建筑物顶点连线与 y 轴的截距，取最大值作为答案。若最大截距为负，输出 `-1`。  
**关键推导**：  
1. **相邻性证明**：三个点中，非相邻点连线产生的截距必然被相邻点覆盖，通过几何斜率递增性可证。  
2. **截距公式**：对相邻点 $(X_i, H_i)$ 和 $(X_{i+1}, H_{i+1})$，截距计算式为 $\frac{H_i X_{i+1} - H_{i+1} X_i}{X_{i+1} - X_i}$。  
3. **精度处理**：使用 `long double` 避免浮点误差，部分题解采用分数形式存储结果。  

**解决难点**：  
- 推导出只需相邻点的结论，避免 $O(N^2)$ 计算。  
- 正确处理边界条件（如 $N=1$ 或所有截距为负）。  

---

**题解评分 (≥4星)**  
1. **Emplace (4星)**  
   - 思路清晰，图示辅助理解。  
   - 代码简洁，直接遍历相邻点。  
2. **wangyizhi (4星)**  
   - 数学证明完整，代码易读。  
   - 包含详细推导过程和代码注释。  
3. **HasNoName (4星)**  
   - 提供交互式几何工具链接，增强理解。  
   - 代码简洁，直接计算相邻点截距。  

---

**最优思路或技巧提炼**  
1. **相邻点截距法**：通过数学观察，仅需遍历相邻两点，计算其连线在 y 轴的截距。  
2. **公式简化**：截距公式可化简为 $\frac{H_i X_{i+1} - H_{i+1} X_i}{X_{i+1} - X_i}$，避免复杂斜率计算。  
3. **边界处理**：若最大截距为负，直接输出 `-1`。  

---

**同类型题或类似算法套路**  
- **几何相邻性优化**：如 [LeetCode 149. Max Points on a Line](https://leetcode.com/problems/max-points-on-a-line/)，利用斜率统计优化时间复杂度。  
- **凸包维护**：如 [洛谷 P2742 [USACO5.1] 圈奶牛](https://www.luogu.com.cn/problem/P2742)，需维护相邻点形成凸包。  

---

**推荐相似题目**  
1. **P1057 [NOIP2008 普及组] 立体图**（几何投影观察）  
2. **P1663 山**（寻找几何截距极值）  
3. **P3199 [HNOI2009] 最小圈**（斜率相关最优化问题）  

---

**个人心得摘录**  
- **hwc2011**：通过画图发现，中间建筑物在连线上方或下方时，相邻点截距更优。  
- **I_Love_FYC**：调试时发现凸包维护错误，最终回归相邻点法。  
- **sjh0626**：最初尝试暴力法，后通过数学推导优化至 $O(N)$。  

---

**可视化与算法演示**  
**动画方案**：  
1. **像素风格显示**：以 8 位像素风格绘制建筑物（竖直线段），坐标 0 处用闪烁像素点表示当前高度。  
2. **关键步骤**：  
   - **遍历相邻点**：高亮当前相邻两点 $(X_i, H_i)$ 和 $(X_{i+1}, H_{i+1})$，绘制连线。  
   - **截距标记**：在 y 轴标记当前截距点，若为新的最大值，显示金色边框。  
   - **历史最大值**：用红色虚线标记历史最大截距位置。  
3. **音效与交互**：  
   - **计算截距**：播放短促“滴”声。  
   - **更新最大值**：播放上扬音效。  
   - **自动演示**：按步进速度自动遍历相邻点，支持暂停/继续。  

**代码片段（JS 动画核心）**  
```javascript
function drawFrame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制建筑物
  buildings.forEach((b, i) => drawBuilding(b.x, b.h, i === currentIndex ? '#FF0000' : '#00FF00'));
  // 绘制当前连线
  if (currentIndex < buildings.length - 1) {
    drawLine(buildings[currentIndex], buildings[currentIndex + 1], '#FFFF00');
    const intercept = calculateIntercept(...);
    // 更新最大截距
    if (intercept > maxIntercept) {
      maxIntercept = intercept;
      playSound('up');
    }
  }
  // 绘制历史最大值线
  drawInterceptLine(maxIntercept, '#FF0000', 'dashed');
}
```

---

**复古游戏化设计**  
- **像素调色板**：16 色，建筑物用绿色，连线用黄色，最大值线用红色。  
- **背景音乐**：8 位风格循环音轨，模拟经典游戏 BGM。  
- **计分规则**：每正确计算一个截距得 10 分，发现新最大值追加 50 分。  
- **AI 自动模式**：AI 按固定速度遍历相邻点，用户可随时接管控制。  

--- 

**核心代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
using ld = long double;

int main() {
    int n;
    cin >> n;
    vector<ld> x(n), h(n);
    for (int i = 0; i < n; ++i) cin >> x[i] >> h[i];
    
    ld max_intercept = -1e18;
    for (int i = 1; i < n; ++i) {
        ld numerator = h[i-1] * x[i] - h[i] * x[i-1];
        ld denominator = x[i] - x[i-1];
        max_intercept = max(max_intercept, numerator / denominator);
    }
    
    if (max_intercept < 0) cout << -1;
    else cout << fixed << setprecision(15) << max_intercept;
}
```

---
处理用时：79.69秒
# 题目信息

# [ABC393D] Swap to Gather

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc393/tasks/abc393_d

给定一个由 `0` 和 `1` 组成的长度为 $ N $ 的字符串 $ S $。保证 $ S $ 中至少包含一个 `1`。

你可以重复以下操作任意次数（包括零次）：

- 选择一个满足 $ 1 \leq i \leq N-1 $ 的整数 $ i $，交换 $ S $ 的第 $ i $ 个字符和第 $ i+1 $ 个字符。

求使所有 `1` 聚集在一起所需的最小操作次数。

这里，所有 `1` 聚集在一起的定义是：存在整数 $ l, r \ (1 \leq l \leq r \leq N) $，使得对于 $ S $ 的第 $ i $ 个字符，当且仅当 $ l \leq i \leq r $ 时为 `1`，否则为 `0`。

## 说明/提示

### 约束条件

- $ 2 \leq N \leq 5 \times 10^5 $
- $ N $ 为整数
- $ S $ 是由 `0` 和 `1` 组成的长度为 $ N $ 的字符串
- $ S $ 中至少包含一个 `1`

### 样例解释 1

例如，按以下步骤进行 $ 3 $ 次操作后，所有 `1` 将聚集在一起：
- 选择 $ i=2 $，交换 $ S $ 的第 $ 2 $ 和第 $ 3 $ 个字符，此时 $ S= $ `0011001`；
- 选择 $ i=6 $，交换 $ S $ 的第 $ 6 $ 和第 $ 7 $ 个字符，此时 $ S= $ `0011010`；
- 选择 $ i=5 $，交换 $ S $ 的第 $ 5 $ 和第 $ 6 $ 个字符，此时 $ S= $ `0011100`。  
由于无法在 $ 2 $ 次或更少操作内完成，因此答案为 $ 3 $。

### 样例解释 2

所有 `1` 已经聚集在一起，因此无需任何操作。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
7

0101001```

### 输出

```
3```

## 样例 #2

### 输入

```
3

100```

### 输出

```
0```

## 样例 #3

### 输入

```
10

0101001001```

### 输出

```
7```

# AI分析结果



**唯一算法分类**  
贪心算法

---

### **综合分析与结论**  
**核心思路**：  
所有 `1` 聚集的最小操作次数等价于将 `1` 移动到中间位置（中位数）的总距离，调整相邻 `1` 的重叠。具体步骤：  
1. 记录所有 `1` 的位置数组 `X`。  
2. 确定中间位置 `X[mid]`（`mid = M//2`，`M` 为 `1` 的个数）。  
3. 计算每个 `1` 移动到目标位置的步数：  
   - 左侧 `1`：`X[mid] - X[i] - (mid - i)`  
   - 右侧 `1`：`X[i] - X[mid] - (i - mid)`  

**难点与解决**：  
- **正确选择中间点**：数学推导证明中位数位置使总距离最小（类似货仓选址问题）。  
- **重叠调整**：移动时已排列的 `1` 会占用相邻位置，需减去已移动的 `1` 数量。  

**可视化设计要点**：  
- **动画方案**：  
  - **网格表示字符串**，`0` 为空格，`1` 为绿色方块，中间 `1` 标记为红色。  
  - **移动轨迹**：左侧 `1` 向右移动（箭头指示），右侧 `1` 向左移动，步数差实时显示。  
  - **颜色高亮**：当前移动的 `1` 变为黄色，步数计算时显示差值。  
- **音效**：移动时播放 "beep" 音效，完成时播放胜利音效。  
- **复古像素风格**：使用 8-bit 像素字体，网格背景模拟经典游戏界面。  

---

### **题解清单 (≥4星)**  
1. **da_ke (5星)**  
   - **亮点**：严谨数学推导，代码清晰处理左右累加。  
   - **核心代码**：  
     ```cpp
     rep(i,1,mid-1) if(S[i]=='1') { 
         cnt++; ans += mid - i - (M - cnt); 
     } // 左侧计算
     rep(i,mid+1,N) if(S[i]=='1') { 
         cnt++; ans += i - mid - (cnt - M); 
     } // 右侧计算
     ```

2. **cqbzhzf (4星)**  
   - **亮点**：简洁转化为排序找中位数，代码极简。  
   - **核心代码**：  
     ```cpp
     for(int i=1;i<=cnt;i++) tt.push_back(X[i]-i); 
     sort(tt.begin(), tt.end());
     int mid = tt[cnt/2]; // 中位数目标
     ans += abs(tt[i] - mid);
     ```

3. **Tomwsc (4星)**  
   - **亮点**：举例说明中位数策略的正确性，代码易理解。  
   - **关键推导**：  
     > 当 `M` 为奇数时，中间位置最优；偶数时两侧等价，统一取 `mid = M//2 + 1`。

---

### **最优思路与技巧提炼**  
**关键技巧**：  
1. **中位数贪心**：选择中间 `1` 作为聚集中心，最小化总移动距离。  
2. **重叠调整公式**：`步数 = 原距离 - 前面已移动的 1 数量`。  
3. **前缀和优化**：部分题解通过维护累计步数避免重复计算。  

**代码实现要点**：  
- 遍历字符串记录 `1` 的位置。  
- 计算中间索引 `mid`，分别处理左右两侧的步数累加。  

---

### **类似题目推荐**  
1. **货仓选址**（洛谷 P10452）  
   - 最小化总距离，直接应用中位数策略。  
2. **移动石子**（洛谷 P7078）  
   - 通过相邻交换使元素聚集，类似贪心思路。  
3. **使数组相等的最小操作**（LeetCode 453）  
   - 数学推导步数公式，与本题调整思路相似。  

---

### **个人心得摘录**  
> "调试时发现未处理 `mid` 左右顺序，导致右侧计算错误。顿悟后调整 `i` 的遍历方向，问题解决。" —— ryf2011  

> "将 `1` 的位置转化为相对目标位置的差值并排序，简化了计算逻辑。" —— cqbzhzf  

---

### **可视化代码片段（JS Canvas）**  
```javascript
// 绘制网格和1的位置
function drawGrid(ctx, positions, midIndex) {
  ctx.fillStyle = "#000000";
  positions.forEach((pos, idx) => {
    if (idx === midIndex) ctx.fillStyle = "#FF0000"; // 中间1红色
    else ctx.fillStyle = "#00FF00"; // 其他1绿色
    ctx.fillRect(pos * 30 + 5, 50, 20, 20); // 30px/格，留边距5
  });
}

// 移动动画（伪代码）
function animateMove(from, to, steps) {
  let current = from;
  const interval = setInterval(() => {
    current += (to > from) ? 1 : -1;
    updatePosition(current); // 更新DOM/CSS
    if (current === to) clearInterval(interval);
  }, 1000 / steps); // 控制移动速度
}
```

---

**总结**：通过中位数贪心策略，结合重叠调整公式，本题可在 O(N) 时间内高效求解。可视化设计可增强对移动过程的理解，复古像素风格增添学习趣味性。

---
处理用时：74.33秒
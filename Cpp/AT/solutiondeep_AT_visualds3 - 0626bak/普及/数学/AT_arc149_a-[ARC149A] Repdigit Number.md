# 题目信息

# [ARC149A] Repdigit Number

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc149/tasks/arc149_a

正整数 $ N,\ M $ が与えられます．次の条件をすべて満たす正整数 $ X $ のうち，最大であるものを答えてください．

- $ X $ は $ 10^N $ 未満の正整数で，$ X $ を $ 10 $ 進法表記したときのどの桁の数字も同じである．
- $ X $ は $ M $ の倍数である．

ただし，条件を満たす正整数 $ X $ が存在しない場合には `-1` と出力してください．

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 10^5 $
- $ 1\leq\ M\leq\ 10^9 $

### Sample Explanation 1

条件を満たす正整数 $ X $ は，$ 444,\ 888,\ 444444,\ 888888 $ の $ 4 $ つです．このうち最大のものである $ 888888 $ が答となります．

### Sample Explanation 2

条件を満たす正整数 $ X $ は，$ 444,\ 888,\ 444444,\ 888888,\ 444444444,\ 888888888 $ の $ 6 $ つです．

### Sample Explanation 3

条件を満たす正整数 $ X $ は，$ 3,\ 6,\ 9 $ の $ 3 $ つです．

### Sample Explanation 4

条件を満たす正整数 $ X $ は存在しません．

## 样例 #1

### 输入

```
7 12```

### 输出

```
888888```

## 样例 #2

### 输入

```
9 12```

### 输出

```
888888888```

## 样例 #3

### 输入

```
1 3```

### 输出

```
9```

## 样例 #4

### 输入

```
1000 25```

### 输出

```
-1```

## 样例 #5

### 输入

```
30 1```

### 输出

```
999999999999999999999999999999```

# AI分析结果



**算法分类**  
无算法分类（主要基于数学模运算和递推式计算）

---

### 题解思路、算法要点与解决难点

**核心思路**  
题目要求构造一个由相同数字组成的最大数，满足该数是 M 的倍数且小于 10^N。直接枚举所有可能的数会导致数值过大，因此通过数学方法优化余数计算：
1. **递推式计算余数**：利用模运算性质，逐位构造数字并计算余数。对于数字 d 重复 k 次组成的数，余数可通过递推式 `f_j = (f_j * 10 + j) % m` 计算。
2. **动态更新最大解**：每次余数为 0 时，记录当前的位数和数字。位数越大、数字越大越优。

**解决难点**  
- **数值过大无法存储**：通过模运算避免直接处理大数。
- **时间复杂度优化**：递推式将时间复杂度降至 O(9N)，适用于 N ≤ 1e5 的约束。

---

### 题解评分

1. **Garbage_fish (5星)**  
   - 关键亮点：代码简洁高效，利用滚动数组优化空间（O(1) 空间复杂度），实时更新最优解。
   - 代码可读性高，逻辑清晰，适合快速实现。

2. **Naro_Ahgnay (4星)**  
   - 亮点：代码结构简洁，直接维护余数数组，实现直观。
   - 稍显冗余的变量命名，但整体逻辑明确。

3. **xiaoPanda (4星)**  
   - 亮点：代码简短，直接枚举每个数字的每一位，逻辑清晰。
   - 缺少注释但实现高效。

---

### 最优思路或技巧提炼

1. **递推式模运算**  
   - 核心公式：`f_j = (f_j * 10 + j) % m`，避免处理大数。
   - 每个数字 d 的余数通过逐位扩展动态计算。

2. **贪心更新最优解**  
   - 余数为 0 时，优先选择位数更大的解；位数相同时选数字更大的。

---

### 同类型题或算法套路

- **余数递推问题**：如求循环节、大数取模等。
- **贪心构造最优解**：如最大数构造、动态规划中的状态更新。

---

### 推荐相似题目

1. **P1111 修复公路**（模运算与贪心）
2. **AT1219 歴史の研究**（余数递推与动态规划）
3. **CF978E 循环数**（构造特定余数条件的数）

---

### 个人心得摘录

- **Garbage_fish**：提到“直接高精度计算不可行”，强调数学优化的必要性。
- **scp020**：通过双重循环的误解引出正确解法，反思时间复杂度的重要性。

---

### 可视化与算法演示

**动画设计**  
- **网格视图**：横向为数字 1-9，纵向为位数 1-N。每个格子显示当前余数。
- **高亮规则**：余数为 0 时，格子变为绿色并标记当前位数和数字。
- **动态更新**：逐步增加位数，箭头指示当前计算的数字和余数变化。

**复古像素风格**  
- **8位色调色板**：使用深蓝背景、亮绿高亮、红色失败提示。
- **音效设计**：余数为 0 时播放“升级”音效，无解时播放“失败”音效。
- **自动演示模式**：算法自动运行，用户可调节速度或单步观察。

**代码片段（JS 动画核心）**  
```javascript
function simulate() {
  let f = new Array(10).fill(0);
  let maxLen = 0, maxDigit = -1;
  for (let i = 1; i <= N; i++) {
    for (let d = 1; d <= 9; d++) {
      f[d] = (f[d] * 10 + d) % M;
      if (f[d] === 0 && (i > maxLen || (i === maxLen && d > maxDigit))) {
        maxLen = i;
        maxDigit = d;
      }
    }
    updateGrid(i, f); // 更新 Canvas 显示
  }
}
```

---

### 代码实现（Garbage_fish 题解）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n, m, f[10] = {0}, cnt = 0, num = -1;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= 9; j++) {
            f[j] = (f[j] * 10 + j) % m;
            if (f[j] == 0) {
                cnt = i;
                num = j;
            }
        }
    }
    if (num == -1) cout << "-1";
    else for (int i = 0; i < cnt; i++) cout << num;
}
```

**核心逻辑**  
- 维护数组 `f` 记录每个数字的当前余数。
- 遍历所有可能的位数和数字，实时更新最优解。

---
处理用时：163.14秒
# 题目信息

# [ARC180A] ABA and BAB

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc180/tasks/arc180_a

`A`, `B` からなる長さ $ N $ の文字列 $ S $ が与えられます．

あなたは以下の $ 2 $ 種類の操作を好きな順序で $ 0 $ 回以上繰り返すことができます．

- $ S $ の中で `ABA` となっている (連続した) 部分を選び，それを `A` で置き換える．
- $ S $ の中で `BAB` となっている (連続した) 部分を選び，それを `B` で置き換える．
 
操作後の $ S $ としてあり得る文字列の個数を $ 10^9+7 $ で割ったあまりを求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 250000 $
- $ S $ は `A`, `B` からなる長さ $ N $ の文字列
 
### Sample Explanation 1

操作後の $ S $ としてあり得るのは以下の $ 2 $ 種類の文字列です． - `ABAB`: $ 0 $ 回の操作を行うことでこの文字列を得ることができます． - `AB`: $ S= $`ABAB` の $ 1 $ 文字目から $ 3 $ 文字目までが `ABA` となっています．これを `A` で置き換えると $ S= $`AB` となります． なお，$ S= $`ABAB` の $ 2 $ 文字目から $ 4 $ 文字目までが `BAB` となっているので，これを `B` に置き換える操作も可能です． ただし，その結果得られる `AB` は重複して数えないことに注意してください．

### Sample Explanation 2

操作を $ 1 $ 度も行うことができません．

### Sample Explanation 4

$ 10^9+7 $ で割ったあまりを求めるのを忘れないようにしてください．

## 样例 #1

### 输入

```
4

ABAB```

### 输出

```
2```

## 样例 #2

### 输入

```
1

A```

### 输出

```
1```

## 样例 #3

### 输入

```
17

BBABABAABABAAAABA```

### 输出

```
18```

## 样例 #4

### 输入

```
100

ABAABAABABBABAABAABAABABBABBABBABBABBABBABBABBABBABBABBABBABBABBABAABABAABABBABBABABBABAABAABAABAABA```

### 输出

```
415919090```

# AI分析结果



**唯一算法分类**  
字符串分段处理与数学规律应用

---

### **题解思路、算法要点与解决难点**

1. **核心逻辑**  
   - **分段处理**：将原字符串分割为多个极长的交替段（如 `ABAB...` 或 `BABA...`）。  
   - **贡献计算**：每个交替段的可能结果数为 $\lceil \text{长度}/2 \rceil$，利用乘法原理相乘所有段的贡献。  
   - **数学规律**：通过观察 `ABA`、`ABAB` 等样例，发现交替段的可能结果数与长度成线性关系。

2. **解决难点**  
   - **分段边界判断**：通过比较当前字符与前一个字符是否交替，确定是否开始新段。  
   - **末尾处理**：确保最后一个段被正确统计。  
   - **高效实现**：线性扫描字符串，时间复杂度 $O(N)$。

3. **关键数据结构**  
   - 仅需维护当前段的长度和类型（`A` 或 `B`），无需复杂结构。

---

### **题解评分 (≥4星)**

1. **Ratio_Y (★★★★☆)**  
   - **亮点**：代码简洁，分段逻辑清晰，注释明确。  
   - **优化点**：变量命名可更直观（如 `n` 改为 `current_length`）。

2. **longhaoyuan (★★★★☆)**  
   - **亮点**：样例分析深入，直观解释交替段贡献规律。  
   - **优化点**：代码中 `s = s + s.back()` 可优化为直接处理原字符串。

3. **Binah_cyc (★★★★☆)**  
   - **亮点**：引入“模板串”术语，递推公式明确。  
   - **优化点**：代码中 `sze` 变量的维护逻辑可进一步简化。

---

### **最优思路或技巧提炼**

1. **分段独立原则**  
   - 交替段之间互不影响，直接相乘贡献。

2. **贡献公式推导**  
   - 交替段长度为 $l$ 时，结果数为 $\lceil l/2 \rceil$，通过打表验证。

3. **边界处理技巧**  
   - 在字符串末尾添加冗余字符（如 `s = s + s.back()`）以统一处理最后一个段。

---

### **同类型题或类似算法套路**

- **通用解法**：将复杂操作分解为独立子问题，利用乘法原理合并结果。  
- **类似题目**：  
  1. **LeetCode 91. 解码方法**（分段计算可能解码数）。  
  2. **Codeforces 1328E. Tree Queries**（路径独立贡献计算）。  
  3. **AtCoder ABC202E. Count Descendants**（分治统计子树节点）。

---

### **推荐洛谷相似题目**

1. **P2679 子串**（分治处理子问题贡献）。  
2. **P1045 麦森数**（分段计算大数性质）。  
3. **P1063 能量项链**（区间分段与乘法原理）。

---

### **个人心得摘录**

- **用户 201012280925LSY**：  
  > “若 `sum` 为偶数，需减一处理，避免重复计算。”  
  **总结**：注意偶数长度交替段的特殊处理。

- **用户 imljw**：  
  > “统计过的不重复统计，直接覆盖原字符。”  
  **总结**：通过修改原字符串避免重复扫描。

---

### **可视化与算法演示设计**

#### **动画方案**  
1. **分段展示**：  
   - 初始字符串显示为像素块序列（`A` 绿色，`B` 蓝色）。  
   - 扫描时，交替段动态合并，颜色渐变突出当前段。  
   - 每段分割时播放 `8-bit` 音效（类似《超级玛丽》金币声）。

2. **贡献计算**：  
   - 每段末尾显示其长度和贡献值（如 `ABAB (4) → 2`）。  
   - 最终结果区域动态累乘，每次更新显示当前乘积。

3. **复古交互**：  
   - **控制面板**：步进按钮（像素风格），速度滑块（龟/兔图标）。  
   - **自动模式**：AI 自动扫描，每步延迟可调。  
   - **音效触发**：分段时播放 `1-up` 音效，错误操作播放 `爆炸` 音效。

#### **代码片段（关键动画逻辑）**  
```javascript
// 伪代码：Canvas 绘制交替段
function drawSegment(start, end, contribution) {
    ctx.fillStyle = '#00FF00'; // 绿色渐变
    for (let i = start; i <= end; i++) {
        drawPixel(i, contribution);
    }
    playSound('segment_split'); // 8-bit 音效
}
```

---

### **代码实现（核心逻辑）**

**Ratio_Y 的代码（优化版）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
int main() {
    int len; string s;
    cin >> len >> s;
    int current_length = 1;
    long long ans = 1;
    char prev = s[0];
    for (int i = 1; i < len; i++) {
        if (s[i] != prev) {
            current_length++;
            prev = s[i];
        } else {
            ans = ans * ((current_length + 1) / 2) % mod;
            current_length = 1;
        }
    }
    ans = ans * ((current_length + 1) / 2) % mod;
    cout << ans;
    return 0;
}
```

**核心思想**：  
- 遍历字符串，动态维护交替段长度。  
- 遇到相同字符时分段，计算贡献并重置长度。  
- 末尾段单独处理。

---
处理用时：88.00秒
# 题目信息

# [ARC185A] mod M Game 2

## 题目描述

Alice 和 Bob 在玩游戏，初始时他们分别有 $n$ 张牌，上面分别写着 $1\sim n$ 的整数。同时他们给出了一个大于 $n$ 的整数 $m$。现在两个人从 Alice 开始轮流取出一张牌放入牌堆中。如果某一次放牌后牌堆中所有牌的数字之和可以被 $m$ 整除，那么放牌的人就输了，另外一个人就赢了。如果所有牌全部放完后依旧没有分出胜负，那么 Alice 将会赢得胜利。现在给出每次对局的 $n$ 和 $m$，请问在两人都绝对聪明的情况下，谁会取得胜利？

## 说明/提示

对于所有数据，$1\le T\le10^5,1\le n<m\le10^9$。

翻译 @Cure_Wing。

## 样例 #1

### 输入

```
8

2 3

3 6

5 9

45 58

39 94

36 54

74 80

61 95```

### 输出

```
Alice

Alice

Bob

Bob

Alice

Bob

Bob

Alice```

# AI分析结果



---

**算法分类**  
无算法分类（基于博弈论与数论的数学推导）

---

### **题解思路与核心难点**

#### **核心思路**
- **胜负条件**：当所有牌总和 `sum = n*(n+1)` 的模 `m` 余数为 `x` 时：
  - 若 `1 ≤ x ≤ n`，Bob 必赢（保留 `x` 牌迫使 Alice 输）。
  - 否则 Alice 赢（Bob 无法构造必胜条件）。

#### **解决难点**
1. **博弈策略推导**：证明当 `x` 存在时，Bob 能保留该牌直至最终回合。
2. **数学验证**：
   - 当两人只剩一张牌时，Bob 的牌 `x` 需满足 `sum - x ≡ 0 (mod m)`。
   - 推导 `x = sum % m` 的范围是否在 `1~n` 内。
3. **反证法**：若 Bob 无法保留 `x`（如中途被迫打出），需证明此时 `x` 不存在或条件不满足。

---

### **题解评分 (≥4星)**

1. **WuMin4 (4星)**  
   - 思路清晰，代码简洁，直接推导 `sum % m` 的范围。
   - 关键代码：
     ```cpp
     if (n*(n+1) % m == 0 || n*(n+1) % m > n) cout << "Alice";
     else cout << "Bob";
     ```

2. **Ratio_Y (4星)**  
   - 通过反证法证明手牌多于一张时不会输。
   - 代码直接判断余数范围，逻辑明确。

3. **hyc42 (4星)**  
   - 结合详细示例和代码注释，突出注意事项（如 `long long`）。
   - 代码：
     ```cpp
     if (n*(n+1) % m ==0 || n*(n+1) % m >n) cout << "Alice";
     else cout << "Bob";
     ```

---

### **最优思路提炼**
1. **关键公式**：计算 `sum = n*(n+1)`，求 `sum % m`。
2. **胜负判定**：
   - `sum % m` 在 `[1, n]` → Bob 胜。
   - 其他情况（包括 `0` 或 `>n`）→ Alice 胜。
3. **数学推导**：利用模运算性质，结合博弈论最优策略，推导出最终条件。

---

### **同类型题与算法套路**
- **通用解法**：将问题转化为模运算条件下的博弈态分析。
- **类似题目**：
  - **洛谷 P1290**：欧几里德的博弈（模运算与取石子）。
  - **洛谷 P2197**：NIM 游戏（异或与必胜态）。
  - **洛谷 P1247**：取火柴游戏（异或和模运算结合）。

---

### **个人心得摘录**
- **调试教训**：必须使用 `long long` 避免溢出（如 `1ll * n * (n+1)`）。
- **核心洞察**：胜负仅由最后一张牌的模余决定，中间回合可安全出牌。

---

### **可视化与算法演示**

#### **动画方案**
1. **流程图展示**：
   - 计算 `sum = n*(n+1)` → 显示公式。
   - 计算 `sum % m` → 动态显示模运算过程。
   - 判断余数范围 → 高亮 `[1, n]` 区间。

2. **像素风格动态演示**：
   - **Canvas 绘制**：用像素方块表示 `sum` 和 `m`，动态显示模运算结果。
   - **音效触发**：
     - 正确区间命中 → 胜利音效（8-bit 风格）。
     - 区间外 → 失败音效。

3. **交互控制**：
   - **参数输入**：允许用户自定义 `n` 和 `m`。
   - **步进执行**：展示每一步的公式推导和条件判断。

#### **复古游戏化设计**
- **颜色方案**：16 色调色板，绿色表示 Alice 胜，红色表示 Bob 胜。
- **自动演示**：模拟 AI 对局，自动运行并展示推导步骤。

---

### **代码实现（核心逻辑）**
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int T; cin >> T;
    while (T--) {
        long long n, m;
        cin >> n >> m;
        long long mod = n * (n + 1) % m;
        cout << (mod == 0 || mod > n ? "Alice" : "Bob") << endl;
    }
    return 0;
}
```

---
处理用时：219.00秒
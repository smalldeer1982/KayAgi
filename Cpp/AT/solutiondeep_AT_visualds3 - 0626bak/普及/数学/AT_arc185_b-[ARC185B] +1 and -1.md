# 题目信息

# [ARC185B] +1 and -1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc185/tasks/arc185_b

長さ $ N $ の整数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ があります。  
 あなたは次の操作を $ 0 $ 回以上好きな回数行うことが出来ます。

- $ 1\ \leq\ i\ \lt\ j\ \leq\ N $ を満たす整数対 $ (i,\ j) $ を選び、$ A_i $ を $ A_i\ +\ 1 $ に、$ A_j $ を $ A_j\ -\ 1 $ に置き換える。
 
操作によって $ A $ を広義単調増加な数列にすることが可能かどうか判定してください。

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のテストケースでは、次のように操作を行うことで $ A $ を広義単調増加な数列にすることが出来ます。 - $ (i,\ j) $ として $ (1,\ 2) $ を選ぶ。操作後の $ A $ は $ (2,\ 6,\ 5) $ になる。 - $ (i,\ j) $ として $ (1,\ 2) $ を選ぶ。操作後の $ A $ は $ (3,\ 5,\ 5) $ になる。 $ 2 $ 番目のテストケースでは、どのように操作しても $ A $ を広義単調増加な数列にすることは出来ません。

## 样例 #1

### 输入

```
3

3

1 7 5

2

9 0

10

607 495 419 894 610 636 465 331 925 724```

### 输出

```
Yes

No

Yes```

# AI分析结果



**唯一算法分类**：贪心

---

### **题解思路与算法分析**

**核心思路**：  
1. **总和不变性**：每次操作总和对数组总和无影响，因此目标数组总和必须等于原数组总和。  
2. **目标数组构造**：构造一个尽可能平均的非递减序列，使得前 $n - s\%n$ 个元素为 $\lfloor s/n \rfloor$，后 $s\%n$ 个元素为 $\lceil s/n \rceil$。  
3. **可行性验证**：从后往前遍历，累加原数组与目标数组的差值。若累计值出现负数，说明无法通过操作调整到目标数组。

**解决难点**：  
- **目标数组构造**：需确保构造的数组非递减且总和与原数组相等。  
- **验证逻辑**：通过从后往前的累加差值，确保每个位置后的资源足够满足前面需求。

---

### **题解评分 (≥4星)**

1. **Super_Cube (5星)**  
   - 思路清晰，代码简洁高效。  
   - 从后往前遍历，累计差值判断可行性，时间复杂度 $O(n)$，适合大规模数据。  
   - 关键代码：构造目标数组后，反向遍历并维护累计差值。

2. **Locix_Elaina_Celome (4星)**  
   - 思路与 Super_Cube 类似，变量命名稍复杂。  
   - 代码正确但可读性稍逊，但仍高效。

3. **Nuclear_Fish_cyq (4星)**  
   - 构造目标数组并反向验证，代码简洁。  
   - 省略了目标数组的显式构造，直接计算差值。

---

### **最优思路与代码实现**

**关键步骤**：  
1. 计算总和 $s$，构造目标数组的每个元素为 $\lfloor s/n \rfloor$ 或 $\lceil s/n \rceil$。  
2. **反向遍历**，维护累计差值 `sum`，若 `sum < 0` 则不可行。

**代码片段**：  
```cpp
int main() {
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<int> a(n);
        ll sum_total = 0;
        for (auto &x : a) {
            cin >> x;
            sum_total += x;
        }
        int avg = sum_total / n;
        int rem = sum_total % n;
        ll sum = 0;
        bool ok = true;
        for (int i = n - 1; i >= 0; i--) {
            int target = (i >= (n - rem)) ? avg + 1 : avg;
            sum += a[i] - target;
            if (sum < 0) {
                ok = false;
                break;
            }
        }
        cout << (ok ? "Yes" : "No") << endl;
    }
}
```

---

### **同类型题与推荐**

**类似题目**：  
1. **洛谷 P1969**：积木大赛（调整操作使数组递增）。  
2. **洛谷 P5019**：铺设道路（最小操作次数填平数组）。  
3. **Codeforces 1585D**：通过交换操作使数组满足条件。

---

### **可视化与算法演示**

**动画设计**：  
1. **像素风格界面**：使用 8 位风格显示数组元素和目标值。  
2. **高亮当前元素**：标记当前遍历的位置和累计差值。  
3. **颜色反馈**：绿色表示累计值非负，红色表示负数（不可行）。  
4. **步进控制**：支持暂停、单步执行，观察差值变化。

**音效设计**：  
- 正确时播放上扬音效，错误时短促提示音。  
- 背景音乐循环播放复古芯片音效。

---

### **总结**

通过构造最优目标数组并反向验证，本题的贪心思路高效且直观。关键点在于理解操作的总和不变性及如何利用差值判断可行性。同类问题可结合差分或前缀和优化思路解决。

---
处理用时：206.19秒
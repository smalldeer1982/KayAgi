# 题目信息

# [ABC281D] Max Multiple

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc281/tasks/abc281_d

非負整数列 $ A=(a_1,a_2,\ldots,a_N) $ が与えられます。

$ A $ の(添え字が相異なる) $ K $ 個の項の和として考えられる非負整数の集合を $ S $ とします。

$ S $ に含まれる $ D $ の倍数の最大値を求めてください。ただし、$ S $ に $ D $ の倍数が含まれない場合、代わりに `-1` と出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ D\ \leq\ 100 $
- $ 0\ \leq\ a_i\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

$ A $ から $ 2 $ 個の項を選ぶ方法を列挙すると - $ a_1 $ と $ a_2 $ を選ぶ。選ばれた項の和は $ 1+2=3 $ となる。 - $ a_1 $ と $ a_3 $ を選ぶ。選ばれた項の和は $ 1+3=4 $ となる。 - $ a_1 $ と $ a_4 $ を選ぶ。選ばれた項の和は $ 1+4=5 $ となる。 - $ a_2 $ と $ a_3 $ を選ぶ。選ばれた項の和は $ 2+3=5 $ となる。 - $ a_2 $ と $ a_4 $ を選ぶ。選ばれた項の和は $ 2+4=6 $ となる。 - $ a_3 $ と $ a_4 $ を選ぶ。選ばれた項の和は $ 3+4=7 $ となる。 となり、$ S=\{3,4,5,6,7\} $ となります。$ S $ に含まれる $ 2 $ の倍数のうち最大のものは $ 6 $ なので、$ 6 $ と出力します。

### Sample Explanation 2

この例では $ S=\{1,3,5\} $ です。$ S $ に含まれる非負整数はいずれも $ 2 $ の倍数でないため、`-1` と出力します。

## 样例 #1

### 输入

```
4 2 2

1 2 3 4```

### 输出

```
6```

## 样例 #2

### 输入

```
3 1 2

1 3 5```

### 输出

```
-1```

# AI分析结果



---

**1. 算法分类**  
动态规划

---

**2. 题解思路与核心难点**  

**算法要点**  
- **状态设计**：三维 DP，`dp[i][j][k]` 表示前 `i` 个数选 `j` 个，余数为 `k` 时的最大和。  
- **转移方程**：  
  1. 不选第 `i` 个数：`dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k])`  
  2. 选第 `i` 个数：`dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][(k-a_i) mod D] + a_i)`  
- **余数处理**：通过 `(k - a_i % D + D) % D` 避免负数取模问题。  
- **初始化**：`dp[0][0][0] = 0`，其余初始化为负无穷表示无效状态。  

**解决难点**  
- **余数动态维护**：确保每次转移的余数正确性，避免因负数导致的状态错误。  
- **无效状态过滤**：仅当 `dp[i-1][j-1][prev_r]` 有效时才允许转移，避免非法组合。  

---

**3. 题解评分 ≥4星**  

1. **作者：_dijkstra_（5星）**  
   - **亮点**：代码简洁清晰，状态转移方程直观，初始化逻辑明确。  
   - **代码片段**：  
     ```cpp  
     memset(dp, -0x3f, sizeof dp);  
     dp[0][0][0] = 0;  
     for (int i = 1; i <= n; i++)  
         for (int j = 0; j <= k; j++)  
             for (int r = 0; r < d; r++)  
                 // 转移逻辑  
     ```  

2. **作者：MoyunAllgorithm（4.5星）**  
   - **亮点**：使用滚动数组优化空间复杂度，代码高效。  
   - **代码片段**：  
     ```cpp  
     for (int i = 1; i <= N; i++)  
         for (int j = K; j >= 1; j--)  
             for (int p = 0; p < D; p++)  
                 if (dp[j-1][(p - a[i]%D + D) % D] != -1)  
                     // 更新状态  
     ```  

3. **作者：c20231020（4星）**  
   - **亮点**：代码可读性强，处理余数逻辑清晰，边界条件处理完善。  
   - **代码片段**：  
     ```cpp  
     memset(dp, -0x3f, sizeof(dp));  
     dp[0][0][0] = 0;  
     for (int i = 1; i <= n; ++i)  
         for (int j = 1; j <= min(i, k); ++j)  
             for (int l = 0; l < d; ++l)  
                 // 转移逻辑  
     ```  

---

**4. 最优思路与技巧**  

1. **余数动态维护**：通过 `(prev_r - a_i % D + D) % D` 确保余数非负。  
2. **滚动数组优化**：通过逆序枚举 `j` 减少空间复杂度至 `O(K*D)`。  
3. **无效状态标记**：初始化为负无穷，避免非法状态干扰最大值计算。  

---

**5. 同类题型推荐**  
- **LeetCode 518. 零钱兑换 II**（完全背包计数问题）  
- **洛谷 P1064 金明的预算方案**（依赖背包）  
- **AtCoder DP Contest E - Knapsack 2**（极大值优化背包）  

---

**6. 可视化与算法演示**  

**核心算法动画设计**  
- **网格展示**：Canvas 绘制 `K×D` 的二维网格，每个单元格表示 `dp[j][k]`。  
- **颜色标记**：  
  - **红色**：当前处理的元素 `a_i`。  
  - **绿色**：选 `a_i` 导致的状态更新。  
  - **蓝色**：不选 `a_i` 的保留状态。  
- **步进控制**：按钮控制逐步执行，显示每个数处理前后的状态变化。  

**复古游戏化设计**  
- **像素风格**：用 8-bit 风格显示网格和数值，背景音乐为 Chiptune 风格循环。  
- **音效设计**：  
  - **点击音效**：处理每个数时播放短促“滴”声。  
  - **成功音效**：找到 `dp[K][0]` 时播放胜利旋律。  
  - **失败音效**：最终无解时播放低沉音效。  
- **自动演示模式**：AI 自动执行算法，高亮当前操作单元格，动态显示余数计算过程。  

---

**7. 代码实现（关键部分）**  

```cpp
// 核心动态规划实现（基于_dijkstra_题解）
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;

ll dp[105][105][105]; // dp[i][j][k]

int main() {
    int n, k, d, x;
    memset(dp, 0x80, sizeof(dp)); // 初始化为极小值
    dp[0][0][0] = 0;
    cin >> n >> k >> d;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        for (int j = 0; j <= k; j++) {
            for (int r = 0; r < d; r++) {
                dp[i][j][r] = max(dp[i-1][j][r], dp[i][j][r]); // 不选
                if (j > 0) { // 选
                    int prev_r = (r - x % d + d) % d;
                    dp[i][j][r] = max(dp[i][j][r], dp[i-1][j-1][prev_r] + x);
                }
            }
        }
    }
    cout << (dp[n][k][0] < 0 ? -1 : dp[n][k][0]);
    return 0;
}
```

---

**8. 个人心得摘录**  
- **余数处理**：“必须用 `(r - a_i % D + D) % D` 而非直接减法，否则负数会导致错误转移。”  
- **初始化教训**：“初始状态必须明确标记有效状态，其余设为极小值避免干扰。”  
- **调试经验**：“通过打印每一步的 `dp[i][j][k]` 发现余数计算错误，修正后AC。”  

--- 

**END**

---
处理用时：104.38秒
# 题目信息

# [ARC167B] Product of Divisors

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc167/tasks/arc167_b

$ A^{B} $ の正の約数の総積は $ A $ で最大何回割り切れますか。

制約から割り切れる回数が有限回であることが示せるので、その答えを $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 2\leq\ A\leq\ 10^{12} $
- $ 0\leq\ B\leq\ 10^{18} $
- 入力は全て整数
 
### Sample Explanation 1

$ A^{B}=8 $ の正の約数は $ 1,2,4,8 $ で、その総積は $ 64 $ となります。 $ 64 $ は $ 2 $ で $ 6 $ 回割り切れるので、$ 6 $ を出力します。

## 样例 #1

### 输入

```
2 3```

### 输出

```
6```

## 样例 #2

### 输入

```
924 167```

### 输出

```
867046524```

## 样例 #3

### 输入

```
167167167167 0```

### 输出

```
0```

# AI分析结果



### 唯一算法分类
数学（质因数分解，约数性质，模运算）

### 综合分析与结论
题目要求计算A^B所有正约数的乘积能被A整除的最大次数。核心在于质因数分解、因数个数计算及奇偶性处理。

1. **质因数分解**：将A分解为质因数形式，得到各质因数的指数。
2. **因数个数计算**：计算A^B的因数个数（即各质因数指数加1的乘积）。
3. **奇偶性处理**：当因数个数为奇数时，需判断A^B是否为平方数（B为偶数或A本身是平方数），此时总次数需拆分为两部分处理。

关键难点在于正确判断奇偶性，确保模运算中除法操作的正确性。通过判断A是否为平方数或B的奇偶性，统一处理总次数为B*product/2，其中product为因数个数。

### 题解评分（≥4星）
1. **樱雪喵（5星）**  
   - 思路清晰，通过质因数分解和因数个数乘积快速推导。
   - 处理奇偶性的方式巧妙，利用平方数判断统一计算。
   - 代码简洁，模运算处理到位。
   
2. **大眼仔Happy（4星）**  
   - 推导详细，明确下取整条件。
   - 代码稍显复杂，但正确性有保障。

### 最优思路与代码实现
核心思路：计算因数个数的乘积，判断A^B是否为平方数，调整总次数为B*product/2。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 998244353;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

int main() {
    ll A, B;
    cin >> A >> B;
    if (B == 0) {
        cout << 0 << endl;
        return 0;
    }
    bool flag = (ll)sqrt(A) * (ll)sqrt(A) == A;
    vector<int> exponents;
    for (ll i = 2; i * i <= A; ++i) {
        if (A % i == 0) {
            int cnt = 0;
            while (A % i == 0) {
                cnt++;
                A /= i;
            }
            exponents.push_back(cnt);
        }
    }
    if (A > 1) exponents.push_back(1);
    
    ll product = 1;
    for (int e : exponents) {
        product = product * ((e * (B % mod) + 1) % mod) % mod;
    }
    
    if (B % 2 == 0 || flag) {
        product = (product - 1 + mod) % mod;
    }
    product = product * qpow(2, mod-2) % mod;
    product = product * (B % mod) % mod;
    if (B % 2 == 0 || flag) {
        product = (product + B / 2 % mod) % mod;
    }
    cout << product << endl;
    return 0;
}
```

### 可视化与算法演示
- **质因数分解**：显示A分解为质因数树状图，动态展示指数增长。
- **因数乘积计算**：通过网格动态演示每个质因数的指数在乘积中的贡献。
- **奇偶性判断**：高亮当前质因数，标记奇偶性，自动判断是否需要调整计算。

**复古像素风设计**：
- **8位像素动画**：质因数分解时，质数块掉落，合并为指数方块。
- **音效触发**：质因数分解成功时播放“收集”音效，错误时播放“失败”音效。
- **自动演示**：展示不同A和B的分解过程，自动计算并显示结果。

### 同类型题推荐
1. **洛谷P1407**（约数研究）  
2. **洛谷P1593**（因子和）  
3. **洛谷P1061**（约数个数）

---
处理用时：463.64秒
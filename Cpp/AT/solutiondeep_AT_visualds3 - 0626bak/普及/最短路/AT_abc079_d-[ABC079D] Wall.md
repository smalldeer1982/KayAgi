# 题目信息

# [ABC079D] Wall

## 题目描述

## 【题目大意】

你面前有一堵墙，墙上有数字，你需要将墙上的数字都变成 ```1``` 。  
现在给出一个 $W\times H$ 的矩阵 $A$ 表示墙上数字的情况。  
其中若 $A_{i,j}=-1$ ，则表示位置 $(i,j)$ 上没有数字，否则 $A_{i,j}$ 的值表示墙上 $(i,j)$ 位置的数字。  
当然，你还有一张 $10\times 10$ 的表 $C$，其中 $C_{i,j}$ 表示把数字 $i$ 转化成数字 $j$ 所需要的花费。  
求花费的最小值。

## 说明/提示

$1\le H,W\le200$  
$1\le C_{i,j}\le 10^3 (i\neq j)$  
$C_{i,j}=0(i=j)$  
$-1\le A_{i,j}\le 9$
所有数据保证在 ```int``` 范围以内。

## 样例 #1

### 输入

```
2 4

0 9 9 9 9 9 9 9 9 9

9 0 9 9 9 9 9 9 9 9

9 9 0 9 9 9 9 9 9 9

9 9 9 0 9 9 9 9 9 9

9 9 9 9 0 9 9 9 9 2

9 9 9 9 9 0 9 9 9 9

9 9 9 9 9 9 0 9 9 9

9 9 9 9 9 9 9 0 9 9

9 9 9 9 2 9 9 9 0 9

9 2 9 9 9 9 9 9 9 0

-1 -1 -1 -1

8 1 1 8```

### 输出

```
12```

## 样例 #2

### 输入

```
5 5

0 999 999 999 999 999 999 999 999 999

999 0 999 999 999 999 999 999 999 999

999 999 0 999 999 999 999 999 999 999

999 999 999 0 999 999 999 999 999 999

999 999 999 999 0 999 999 999 999 999

999 999 999 999 999 0 999 999 999 999

999 999 999 999 999 999 0 999 999 999

999 999 999 999 999 999 999 0 999 999

999 999 999 999 999 999 999 999 0 999

999 999 999 999 999 999 999 999 999 0

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3 5

0 4 3 6 2 7 2 5 3 3

4 0 5 3 7 5 3 7 2 7

5 7 0 7 2 9 3 2 9 1

3 6 2 0 2 4 6 4 2 3

3 5 7 4 0 6 9 7 6 7

9 8 5 2 2 0 4 7 6 5

5 4 6 3 2 3 0 5 4 3

3 6 2 3 4 2 4 0 8 9

4 6 5 4 3 5 3 2 0 8

2 1 3 4 5 7 8 6 4 0

3 5 2 6 1

2 5 3 2 1

6 9 2 5 6```

### 输出

```
47```

# AI分析结果



**唯一算法分类**  
图论 - Floyd-Warshall 算法

---

### 题解思路与算法要点  
1. **问题转化**：将数字转换问题抽象为图论问题，0-9 视为节点，转换代价视为边权  
2. **多源最短路**：由于每个数字可能通过中间数字间接转换更优，需计算所有节点到目标节点 1 的最短路径  
3. **核心算法**：  
   - **Floyd 算法**：三层循环动态规划更新邻接矩阵，时间复杂度 O(10³) 完全可接受  
   - **数据过滤**：原矩阵中的 -1 和 1 无需处理，其他数字累加其到 1 的最短路径值  

**解决难点**  
- **动态规划理解**：Floyd 算法中 k 必须作为中间节点放在最外层循环  
- **边界处理**：输入矩阵中 -1 的特殊处理需要精准条件判断  

---

### 题解评分 (≥4★)  
1. **Erinyes（4★）**  
   - 亮点：详细解释 Floyd 循环顺序原理，代码包含 INF 优化处理  
   - 代码结构：完整可读，输入与处理分离清晰  

2. **cqbztz2（4★）**  
   - 亮点：代码极简风格，在线处理输入数据减少内存占用  
   - 优化：直接复用输入数组存储邻接矩阵  

3. **TRZ_2007（4★）**  
   - 亮点：将问题抽象为图论问题的思路表述清晰  
   - 代码特点：使用更现代的 C++ 头文件与常量定义  

---

### 最优思路提炼  
```cpp
// Floyd 核心代码片段
for(int k=0; k<=9; k++)
    for(int i=0; i<=9; i++)
        for(int j=0; j<=9; j++)
            dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);

// 关键数据过滤与统计
if(a[i][j] != -1 && a[i][j] != 1) 
    sum += dis[a[i][j]][1];
```

---

### 类似题目推荐  
1. **P1119 灾后重建** - Floyd 动态更新中间节点  
2. **P1359 租用游艇** - 最短路径变形问题  
3. **P2935 [USACO09JAN]Best Spot S** - 多源最短路应用  

---

### 可视化算法设计  
**动画方案**：  
1. **像素网格**：  
   - 10×10 网格表示数字转换图，每个格子显示当前数字到 1 的最短路径值  
   - 执行 Floyd 时，高亮当前中间节点 k 的整行整列  
2. **动态更新**：  
   - 当 dis[i][j] 被更新时，对应格子闪烁并显示新数值  
   - 背景色渐变表示路径值大小（冷色调→暖色调表示代价递增）  
3. **音效交互**：  
   - 每次路径更新时播放 "哔" 声，找到更优解时播放上扬音效  
   - 算法完成后播放 8-bit 胜利音乐  

**复古交互功能**：  
- **自动演示**：按空格键切换手动/自动模式  
- **单步调试**：方向键控制算法执行步数  
- **数据跟踪**：鼠标悬浮显示任意两点间详细路径  

---

### 核心代码实现  
```cpp
// Floyd 算法实现（含音效触发伪代码）
void updateFloyd() {
    for(int k=0; k<10; k++) {
        playSound("select"); // 选择中间节点音效
        for(int i=0; i<10; i++) {
            for(int j=0; j<10; j++) {
                if(dis[i][j] > dis[i][k] + dis[k][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                    highlightCell(i, j); // 高亮更新单元格
                    playSound("update"); // 更新成功音效
                }
            }
        }
    }
}
```

---

### 个人心得摘录  
> "Floyd 的 k 循环必须放在最外层——这是动态规划的状态转移需要，错误顺序会导致部分中间路径未被考虑。调试时曾因此 WA 多次，最后画状态转移表才理解原理。" —— Erinyes

---

### 知识拓展  
当节点数增加到 1e3 级别时，Floyd 的 O(n³) 不再适用，此时应改用 Dijkstra 算法为每个节点单独计算最短路。但在本题 10 节点的场景下，Floyd 是最优解。

---
处理用时：60.36秒
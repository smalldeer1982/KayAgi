# 题目信息

# [ABC252E] Road Reduction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc252/tasks/abc252_e

AtCoder 王国には都市 $ 1,2,\ldots,N $ の $ N $ 個の都市と、道路 $ 1,2,\ldots,M $ の $ M $ 本の道路があります。  
道路 $ i $ は都市 $ A_i $ と $ B_i $ を双方向に結び、距離は $ C_i $ です。  
どの都市間もいくつかの道路を通って行き来することができます。

財政難である王国は、どの都市間もいくつかの道路を通って行き来できるという条件を満たすように $ N-1 $ 本の道路を保守し、それ以外の道路を廃道にすることにしました。

保守する道路のみを通って都市 $ 1 $ から都市 $ i $ へ移動するときの距離を $ d_i $ とするとき、保守する道路の選び方であって、$ d_2+d_3+\ldots+d_N $ を最小化するようなものを $ 1 $ つ出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- $ i\neq\ j $ のとき、$ (A_i,B_i)\neq(A_j,B_j) $
- $ 1\leq\ C_i\ \leq\ 10^9 $
- どの都市間もいくつかの道路を通って行き来することができる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

保守する道路の選び方と $ d_i $ の値は次のようになります。 - 道路 $ 1,2 $ を保守するとき、$ d_2=1 $, $ d_3=3 $ - 道路 $ 1,3 $ を保守するとき、$ d_2=1 $, $ d_3=10 $ - 道路 $ 2,3 $ を保守するとき、$ d_2=12 $, $ d_3=10 $ よって、道路 $ 1,2 $ を保守するときに $ d_2+d_3 $ が最小になります。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 2
1 3 10```

### 输出

```
1 2```

## 样例 #2

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 1
2 4 1
3 4 1```

### 输出

```
3 1 2```

# AI分析结果



# 算法分类
**最短路径树（Dijkstra 算法应用）**

---

## 题解思路与核心难点

### 核心思路
所有题解均基于以下核心逻辑：
1. **最短路径树性质**：Dijkstra 算法在求单源最短路时，会自然形成一棵以起点为根的树（每个非根节点仅被最后一次松弛的边连接）。
2. **边记录机制**：在松弛操作中记录导致当前最短距离更新的边，最终这些边构成的最短路径树即为答案。

### 解决难点
- **双向边的处理**：每条无向边需存储两次（正向和反向），但需保证两条边共享同一个编号。
- **正确性验证**：需证明记录的边一定构成生成树且总和最小。基于 Dijkstra 的贪心性质，每个节点只会被松弛一次，因此总边数为 `N-1`。
- **性能优化**：需使用优先队列优化 Dijkstra，时间复杂度 `O(M + N log N)`。

---

## 题解评分（≥4星）

| 作者          | 星级 | 亮点                                                                 |
|---------------|------|----------------------------------------------------------------------|
| xixiyan       | ★★★★☆ | 链式前向星实现清晰，详细解释双向边处理与编号存储逻辑。              |
| FL_sleake     | ★★★★☆ | 邻接表实现简洁，注释明确，特别强调 `dis[u]<D` 的剪枝优化。           |
| FFTotoro      | ★★★★  | 代码极度简洁，利用 `priority_queue` 特性直接在弹出时输出边编号。     |

---

## 最优思路提炼
### 关键技巧
1. **松弛时记录边**：在 Dijkstra 的松弛条件 `if (dis[v] > dis[u] + w)` 成立时，记录当前边的编号。
2. **双向边存储**：每条无向边以两条有向边存储，但共享同一编号（正反边编号相同）。
3. **剪枝优化**：优先队列弹出节点时，若 `dis[u] < D` 则跳过（已存在更优路径）。

### 代码片段（核心逻辑）
```cpp
// FL_sleake 的松弛逻辑
for (auto [v, w, id] : G[u]) {
    if (dis[v] > dis[u] + w) {
        dis[v] = dis[u] + w;
        ans[v] = id; // 记录边编号
        q.push({v, dis[v]});
    }
}
```

---

## 同类型题与算法套路
### 通用解法
- **最短路径树构建**：所有需生成树且边权与最短路径相关的场景。
- **路径记录**：在松弛操作中维护额外信息（如边编号、路径节点序列）。

### 推荐题目
1. [洛谷 P4779](https://www.luogu.com.cn/problem/P4779)：标准 Dijkstra 模板题。
2. [洛谷 P1144](https://www.luogu.com.cn/problem/P1144)：最短路径计数与边记录结合。
3. [洛谷 P1396](https://www.luogu.com.cn/problem/P1396)：最短路径应用场景变形。

---

## 个人心得摘录
- **双向边编号处理**（xixiyan）：正反边需存储相同编号，否则会导致答案错误。
- **剪枝优化必要性**（FL_sleake）：未添加 `dis[u]<D` 判断会在特定数据下 TLE。
- **代码简洁性**（FFTotoro）：优先队列可直接存储边编号，但需验证正确性。

---

## 可视化与算法演示
### 核心算法流程
1. **初始化**：起点 `1` 的 `dis` 设为 `0`，其他节点设为无穷大。
2. **优先队列处理**：每次弹出当前距离最小的节点 `u`。
3. **松弛邻接边**：对 `u` 的每条邻接边 `(u→v)`，尝试更新 `v` 的最短距离。
4. **记录边编号**：若松弛成功，将边 `(u→v)` 的编号存入 `ans[v]`。

### 动画设计
- **颜色标记**：
  - 当前节点 `u`：红色闪烁。
  - 已确定最短路的节点：绿色。
  - 被成功松弛的边：黄色高亮。
- **音效触发**：
  - 松弛成功：短促“哔”声。
  - 节点加入队列：8-bit 点击音效。
  - 所有边处理完成：胜利旋律（8-bit 风格）。

### 复古像素风格
- **Canvas 绘制**：
  - 节点显示为 16x16 像素方块，编号居中。
  - 边用直线连接，颜色随选中状态变化（灰→黄）。
- **自动演示模式**：
  - 初始自动播放，按帧逐步展开 Dijkstra 过程。
  - 支持暂停/继续，速度调节（1x~5x）。

---

## 完整代码（FL_sleake 实现）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node{
    int v,w,id;
    bool operator<(const node &b)const{ return w > b.w; }
};
vector<node> G[200010];
int n,m,ans[200010],dis[200010];

void Dijkstra(){
    memset(dis,0x3f,sizeof(dis));
    priority_queue<node> q;
    q.push({1,0,0}); dis[1]=0;
    while(!q.empty()){
        int u = q.top().v, d = q.top().w; q.pop();
        if(d > dis[u]) continue; // 关键剪枝
        for(auto [v,w,id] : G[u]){
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                ans[v] = id;
                q.push({v, dis[v], 0});
            }
        }
    }
}

signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v,w; cin>>u>>v>>w;
        G[u].push_back({v,w,i});
        G[v].push_back({u,w,i});
    }
    Dijkstra();
    for(int i=2;i<=n;i++) cout<<ans[i]<<" ";
}
```

---
处理用时：88.52秒
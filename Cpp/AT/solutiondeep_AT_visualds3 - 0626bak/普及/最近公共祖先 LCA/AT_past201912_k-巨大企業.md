# 题目信息

# 巨大企業

## 题目描述

### 题目简述

有一个 $n$ 点有向图，每个点的编号由 $1$ 到 $n$ 。除了一个点之外，其它每个点都会有一条边连向另外一个点（不存在重边和自环，也不存在一个点，使得从该点出发，沿着有向边走，能够回到这个点）。现在有 $q$ 组询问，每组询问给定两个点的编号 $a_i$ 和 $b_i$ ，请问能否能从 $a_i$ 出发走到 $b_i$ 。

## 样例 #1

### 输入

```
7

-1

1

1

2

2

3

3

6

7 1

4 1

2 3

5 1

5 2

2 5```

### 输出

```
Yes

Yes

No

Yes

Yes

No```

## 样例 #2

### 输入

```
20

4

11

12

-1

1

13

13

4

6

20

1

1

20

10

8

8

20

10

18

1

20

18 14

11 3

2 13

13 11

10 15

9 5

17 11

18 10

1 16

9 4

19 6

5 10

17 8

15 8

5 16

6 20

3 19

10 12

5 13

18 1```

### 输出

```
No

No

No

No

No

No

No

Yes

No

Yes

No

No

No

Yes

No

Yes

No

No

No

Yes```

# AI分析结果



## 算法分类
**树结构、最近公共祖先（LCA）、DFS序**

---

## 题解思路与核心难点分析
### 核心逻辑
1. **图转树**：题目给出的有向图结构本质上是一棵有向树，其中所有边由子节点指向父节点，唯一没有出边的节点为根。
2. **问题转化**：判断 `a` 能否到达 `b`，等价于判断 `b` 是否为 `a` 的祖先（在树结构中）。
3. **解决方案**：
   - **LCA法**：通过倍增法预处理每个节点的祖先表，查询时若 `LCA(a, b) == b` 则 `Yes`。
   - **DFS序法**：预处理每个节点的进入时间（`dfn`）和子树最大时间（`maxx`），若 `dfn[b] ≤ dfn[a] ≤ maxx[b]` 则 `Yes`。

### 解决难点
- **结构转换**：需识别出边方向隐含的树结构（子节点指向父节点）。
- **祖先判定**：通过 LCA 或 DFS 序高效判断祖先关系，避免暴力遍历。

---

## 题解评分（≥4星）
1. **CatnipQwQ（5星）**  
   - **亮点**：使用 DFS 序实现 O(1) 查询，代码简洁高效。  
   - **核心代码**：
     ```cpp
     void dfs(int p) {
         dfn[p] = ++tot;
         for (auto son : e[p]) dfs(son);
         maxx[p] = tot;
     }
     // 查询条件：dfn[b] ≤ dfn[a] && maxx[b] ≥ dfn[a]
     ```

2. **xzh15960292751（4星）**  
   - **亮点**：标准倍增 LCA 实现，逻辑清晰。  
   - **关键步骤**：
     ```cpp
     int lca(int x, int y) {
         if (depth[x] < depth[y]) swap(x, y);
         while (depth[x] > depth[y]) x = f[x][lg[depth[x] - depth[y]]];
         return (x == y) ? x : f[x][0];
     }
     ```

3. **yedalong（4星）**  
   - **亮点**：简洁的 LCA 实现，预处理深度和祖先表。  
   - **核心片段**：
     ```cpp
     int LCA(int x, int y) {
         if (deep[x] < deep[y]) swap(x, y);
         while (deep[x] > deep[y]) x = f[x][lg[deep[x] - deep[y]] - 1];
         return (x == y) ? x : f[x][0];
     }
     ```

---

## 最优思路提炼
1. **DFS序法**  
   - **核心思想**：将树结构转化为线性区间，通过预处理 `dfn` 和 `maxx` 实现 O(1) 查询。
   - **优势**：查询速度极快，适合大规模数据。
   - **代码片段**：
     ```cpp
     void dfs(int p) {
         dfn[p] = ++tot;
         for (auto son : e[p]) dfs(son);
         maxx[p] = tot;
     }
     ```

2. **倍增LCA法**  
   - **核心思想**：预处理每个节点的 2^k 级祖先，通过二进制跳跃调整深度。
   - **优势**：通用性强，可处理更复杂的树问题。
   - **关键实现**：
     ```cpp
     for (int j = 1; j <= 18; j++)
         for (int i = 1; i <= n; i++)
             f[i][j] = f[f[i][j - 1]][j - 1];
     ```

---

## 同类型题推荐
1. **P3379 【模板】最近公共祖先（LCA）**  
   - 练习 LCA 的多种实现方法（倍增、Tarjan、RMQ）。
2. **P1395 会议**  
   - 结合树的深度和路径统计，巩固树结构操作。
3. **P3884 [JLOI2009]二叉树问题**  
   - 利用 DFS 序和树结构解决实际问题。

---

## 可视化与算法演示
### 动画方案设计
1. **树结构可视化**  
   - 用像素风格绘制树，根节点位于顶部，子节点向下延伸。
   - **颜色标记**：当前查询节点 `a`（红色）、目标节点 `b`（绿色），路径节点高亮为黄色。
   
2. **LCA跳跃演示**  
   - **步进控制**：展示从 `a` 到 `b` 的深度调整和共同跳跃。
   - **音效**：每次跳跃播放“跳跃音效”，匹配 8-bit 风格。

3. **DFS序区间展示**  
   - 显示每个节点的 `dfn` 和 `maxx`，用区间条表示子树范围。
   - **动画效果**：高亮 `a` 的 `dfn`，检查是否落在 `b` 的区间内。

### 复古游戏化设计
- **像素风格**：16色调色板，节点用方块表示，边用线段连接。
- **音效设计**：
  - **跳跃成功**：短促“哔”声。
  - **查询成功**：上扬音调；失败：低沉音效。
- **自动演示模式**：模拟 AI 自动执行查询，展示路径判断逻辑。

---

## 个人心得摘录
1. **反向建树**：将边反向构建为树结构是解题关键，需注意根节点的唯一性。
2. **区间判断优化**：DFS 序法通过预处理线性区间将问题转化为范围查询，显著提升效率。
3. **调试技巧**：验证 LCA 的正确性时，可通过小规模数据手动模拟跳跃过程。

---

## 核心代码片段（DFS序法）
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> e[150005];
int dfn[150005], maxx[150005], tot = 0;

void dfs(int p) {
    dfn[p] = ++tot;
    for (auto son : e[p]) dfs(son);
    maxx[p] = tot;
}

int main() {
    int n, rt;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        int fa;
        scanf("%d", &fa);
        if (fa == -1) rt = i;
        else e[fa].push_back(i);
    }
    dfs(rt);
    int q;
    scanf("%d", &q);
    while (q--) {
        int a, b;
        scanf("%d%d", &a, &b);
        if (dfn[b] <= dfn[a] && maxx[b] >= dfn[a]) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---
处理用时：138.32秒
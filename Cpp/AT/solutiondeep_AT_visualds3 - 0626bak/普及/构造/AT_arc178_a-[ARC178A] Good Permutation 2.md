# 题目信息

# [ARC178A] Good Permutation 2

## 题目描述

给定一个正整数 $N$ 和一个长度为 $M$ 的正整数序列 $A=(1,2,\cdots,A_M)$。

其中，$A$ 中的所有元素都是介于 $1$ 和 $N$ 之间的不同整数。（即 $A$ 是 $N$ 的一个排列）

定义：
- 排列 $P=(P_1,P_2,\cdots,P_N)$ 是一个**好排列**，当且仅当：$P$ 没有连续子序列是 $A=(1,2,⋯ ,A_i)$ 的排列，其中 $1\le i\le M$。


确定是否存在这样的**好排列**，如果存在，找到**字典序最小**的好排列。

## 说明/提示

- $ 1\leq\ M\leq\ N\leq\ 2\times\ 10^{5} $
- $ 1\leq\ A_{i}\leq\ N $
- $ A $ 中的所有元素都是不同的。
- 所有输入值都是整数。

 
### 样例解释1
例如，$(4,2,1,3)$ 不是一个 好排列，因为它包含 $(2,1)$  作为连续子序列。

其他非好排列包括 $(1,2,3,4)$ 和 $(3,4,2,1)$。

一些好排列包括 $(4,1,3,2)$ 和 $(2,3,4,1)$。其中，字典序最小的排列是 $(1,3,2,4)$。

### 样例解释2
好排列的示例包括 $(3,1,4,5,2)$、$(2,4,5,3,1)$ 和 $(4,1,5,2,3)$。

非好排列的示例包括 $(1,2,5,3,4)$、$(2,3,4,1,5)$ 和$(5,3,1,2,4)$。

### 样例解释3
不存在好排列，输出 `-1`。

## 样例 #1

### 输入

```
4 1

2```

### 输出

```
1 3 2 4```

## 样例 #2

### 输入

```
5 3

4 3 2```

### 输出

```
1 3 4 5 2```

## 样例 #3

### 输入

```
92 4

16 7 1 67```

### 输出

```
-1```

## 样例 #4

### 输入

```
43 2

43 2```

### 输出

```
-1```

# AI分析结果



**唯一算法分类**  
贪心

---

### **题解思路、算法要点与解决难点**

**核心思路**  
题目要求构造字典序最小的排列，避免出现特定的连续子序列。通过贪心策略，初始化为递增序列，排序禁止前缀后，依次交换相邻位置破坏可能的前缀条件。

**算法要点**  
1. **无解判断**：若禁止序列包含 `1` 或 `N`，直接无解。  
2. **排序处理**：将禁止前缀按升序排列，确保交换顺序不影响字典序。  
3. **交换策略**：对每个禁止前缀的长度 `x`，交换 `x` 与 `x+1` 位置的元素，破坏其连续前缀的可能。

**解决难点**  
- 如何确保每次交换后不影响后续的字典序？  
  通过排序禁止前缀，从小到大处理，每次交换仅调整最小必要位置，保证整体字典序最小。  
- 如何快速判断无解？  
  直接检查输入中是否存在 `1` 或 `N`，无需复杂计算。

---

### **题解评分 (≥4星)**

1. **Pink_Cut_Tree (5星)**  
   - **亮点**：输入时立即判断无解，提前终止；代码简洁，指针逐步处理。  
   - **代码可读性**：清晰的结构，变量命名合理。  
   - **效率**：时间复杂度 `O(M log M + N)`，适合大规模数据。

2. **Dtw_ (5星)**  
   - **亮点**：提前判断无解，与排序后处理逻辑分离，逻辑清晰。  
   - **实现优化**：直接遍历排序后的数组，避免冗余判断。

3. **xk2013 (5星)**  
   - **亮点**：代码与主流思路一致，注释详细，适合新手理解。  
   - **可操作性**：完整代码包含输入输出处理，便于直接验证。

---

### **最优思路或技巧提炼**

1. **无解快速判断**：禁止前缀包含首尾元素时直接无解。  
2. **贪心交换**：排序后依次交换相邻位置，破坏前缀条件。  
3. **时间复杂度优化**：排序后线性遍历，总复杂度可控。

---

### **同类型题推荐**

1. **LeetCode 31. Next Permutation**  
   贪心构造下一个排列。  
2. **Codeforces 1156E. Special Permutation**  
   构造满足特定条件的排列。  
3. **洛谷 P1706 全排列问题**  
   基础全排列生成，涉及剪枝优化。

---

### **可视化与算法演示**

**动画方案**  
- **网格绘制**：以像素网格展示排列，初始为 `1,2,…,N`。  
- **高亮交换位置**：处理每个禁止前缀时，用红色标记当前交换的相邻位置。  
- **音效提示**：交换时播放“哔”声，完成时播放成功音效。  
- **复古风格**：8-bit 背景音乐，像素字体显示当前步骤。

**交互设计**  
- **步进控制**：支持暂停/继续，调整动画速度。  
- **自动演示**：自动按排序后的顺序处理每个禁止前缀。  
- **错误提示**：若输入包含 `1` 或 `N`，播放失败音效并显示红屏。

---

### **代码实现（核心逻辑）**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int a[N], ans[N];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i=1; i<=m; i++) {
        cin >> a[i];
        if (a[i]==1 || a[i]==n) {
            cout << -1;
            return 0;
        }
    }
    sort(a+1, a+m+1);
    iota(ans+1, ans+n+1, 1); // 初始化1~n
    for (int i=1; i<=m; i++) 
        swap(ans[a[i]], ans[a[i]+1]);
    for (int i=1; i<=n; i++) 
        cout << ans[i] << " ";
}
```

---

### **个人心得摘录**

- **输入即判断**：在读取输入时直接检查 `1` 或 `N`，避免后续冗余处理。  
- **排序必要性**：处理禁止前缀的顺序影响字典序，必须排序后从小到大调整。  
- **交换验证**：通过手动模拟小样例（如样例1）确认交换逻辑的正确性。

---
处理用时：283.16秒
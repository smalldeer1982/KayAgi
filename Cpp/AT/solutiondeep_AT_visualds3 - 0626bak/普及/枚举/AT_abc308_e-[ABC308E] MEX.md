# 题目信息

# [ABC308E] MEX

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc308/tasks/abc308_e

$ 0,1,2 $ からなる長さ $ N $ の数列 $ A=(A_1,A_2,\dots,A_N) $ と、 `M`, `E`, `X` からなる長さ $ N $ の文字列 $ S=S_1S_2\dots\ S_N $ が与えられます。

$ 1\ \leq\ i\ <\ j\ <\ k\ \leq\ N $ かつ $ S_iS_jS_k= $ `MEX` を満たす全ての整数の組 $ (i,j,k) $ に対する $ \text{mex}(A_i,A_j,A_k) $ の総和を求めてください。 ここで、$ \text{mex}(A_i,A_j,A_k) $ は $ A_i,A_j,A_k $ のいずれとも一致しない最小の非負整数を意味します。

## 说明/提示

### 制約

- $ 3\leq\ N\ \leq\ 2\times\ 10^5 $
- $ N $ は整数
- $ A_i\ \in\ \lbrace\ 0,1,2\rbrace $
- $ S $ は `M`, `E`, `X` からなる長さ $ N $ の文字列
 
### Sample Explanation 1

$ S_iS_jS_k $ = `MEX` となる $ i,j,k\ (1\ \leq\ i\ <\ j\ <\ k\ \leq\ N) $ の組は $ (i,j,k)=(1,2,4),(1,3,4) $ の $ 2 $ つです。 $ \text{mex}(A_1,A_2,A_4)=\text{mex}(1,1,2)=0,\text{mex}(A_1,A_3,A_4)=\text{mex}(1,0,2)=3 $ より答えは $ 0+3=3 $ です。

## 样例 #1

### 输入

```
4

1 1 0 2

MEEX```

### 输出

```
3```

## 样例 #2

### 输入

```
3

0 0 0

XXX```

### 输出

```
0```

## 样例 #3

### 输入

```
15

1 1 2 0 0 2 0 2 0 0 0 0 0 2 2

EXMMXXXEMEXEXMM```

### 输出

```
13```

# AI分析结果



## 算法分类
**组合数学 & 前缀和/后缀和**

## 题解思路、算法要点与解决难点
### 核心思路
题目要求统计所有满足 `MEX` 字符顺序的三元组，并计算其 `mex` 值的总和。由于直接枚举所有三元组的时间复杂度为 $O(N^3)$，不可行。核心优化思路是**分阶段维护状态**：
1. **动态维护前缀状态**：对于每个字符 `M`，记录其对应数值的出现次数。
2. **组合中间状态**：对于每个字符 `E`，将其与前面所有可能的 `M` 值组合，保存为中间状态。
3. **快速计算贡献**：对于每个字符 `X`，遍历所有中间状态组合，计算 `mex` 值并累加结果。

### 解决难点
- **高效统计组合数**：通过动态维护前缀和和中间状态，将时间复杂度优化到 $O(N)$。
- **快速计算 `mex`**：由于数值范围为 $\{0,1,2\}$，可通过预计算或直接分类讨论快速求解。

---

## 题解评分 (≥4星)
1. **zac2010 题解（5星）**  
   - **亮点**：代码简洁，动态维护状态，在线处理，无冗余存储。  
   - **核心代码**：  
     ```cpp
     if (s[i] == 'M') c[a[i]]++;
     else if (s[i] == 'E') {
         L(j, 0, 2) if(c[j]) t[min(j, a[i])][max(j, a[i])] += c[j];
     } else {
         L(j, 0, 2) L(k, j, 2) ans += t[j][k] * mex(j, a[i], k);
     }
     ```

2. **未来姚班zyl 题解（4星）**  
   - **亮点**：状态压缩巧妙，将 `M-E` 组合的三进制数映射为十进制索引。  
   - **核心代码**：  
     ```cpp
     rep(j, 0, 2) sme[j * 3 + a[i]] += sm[j];
     rep(j, 0, 8) ans += sme[j] * mex(j * 3 + a[i]);
     ```

3. **梦应归于何处 题解（4星）**  
   - **亮点**：前缀和与后缀和分离，逻辑清晰。  
   - **核心代码**：  
     ```cpp
     ans += cntl[i-1][j] * cntr[i+1][k] * mex(j, a[i], k);
     ```

---

## 最优思路提炼
1. **动态状态维护**：按字符类型分阶段维护计数（如 `M` 维护 `c[]`，`E` 维护 `t[][]`）。
2. **中间组合压缩**：将 `M-E` 的组合保存为数值对，避免重复计算。
3. **快速 `mex` 计算**：  
   ```cpp
   int mex(int a, int b, int c) {
       for (int i = 0; i < 4; i++) 
           if (i != a && i != b && i != c) return i;
       return 3;
   }
   ```

---

## 同类型题与算法套路
- **组合计数优化**：通过分阶段维护状态，将复杂问题分解为线性步骤。
- **前缀和/后缀和**：用于快速统计区间内的数值分布。

### 推荐题目
1. [P2671 求和](https://www.luogu.com.cn/problem/P2671)  
   **相似点**：利用前缀和统计符合条件的组合。
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)  
   **相似点**：差分数组维护区间贡献。
3. [P2241 统计方形](https://www.luogu.com.cn/problem/P2241)  
   **相似点**：组合数学优化，避免暴力枚举。

---

## 可视化与算法演示
### 核心算法流程
1. **初始化**：三个计数器 `c[0], c[1], c[2]` 和二维数组 `t[3][3]`。
2. **处理字符**：  
   - **M**：更新 `c[a[i]]++`（高亮 `c[]` 变化）。  
   - **E**：遍历 `c[]`，将 `min(a[i], j)` 和 `max(a[i], j)` 组合存入 `t[][]`（高亮 `t[][]` 更新）。  
   - **X**：遍历 `t[][]`，计算 `mex` 并累加结果（高亮当前 `X` 值和 `t[][]` 条目）。

### 复古像素风格设计
- **颜色标记**：  
  - `M` 用蓝色，`E` 用黄色，`X` 用红色。  
  - 计数器 `c[]` 和 `t[][]` 用绿色高亮更新。  
- **Canvas 动画**：  
  1. 字符流从左到右滚动，当前字符放大显示。  
  2. 处理 `M/E/X` 时，下方显示对应计数器变化。  
  3. 计算 `mex` 时，弹出数值提示。  
- **音效**：  
  - `M/E/X` 处理时播放不同音调。  
  - 结果更新时播放金币音效。

---

## 代码实现（zac2010 题解）
```cpp
#include <bits/stdc++.h>
#define int long long
#define L(i, a, b) for(int i = (a); i <= (b); i++)
using namespace std;
const int N = 2e5 + 10;
int n, ans, a[N], c[3], t[3][3];
char s[N];

int mex(int a, int b, int c) {
    int cnt[4] = {0}; 
    cnt[a] = cnt[b] = cnt[c] = 1;
    L(i, 0, 3) if (!cnt[i]) return i;
    return 3;
}

signed main() {
    scanf("%lld", &n);
    L(i, 1, n) scanf("%lld", &a[i]);
    L(i, 1, n) scanf(" %c", &s[i]);
    L(i, 1, n) {
        if (s[i] == 'M') c[a[i]]++;
        else if (s[i] == 'E') {
            L(j, 0, 2) if (c[j]) 
                t[min(j, a[i])][max(j, a[i])] += c[j];
        } else {
            L(j, 0, 2) L(k, j, 2) 
                ans += t[j][k] * mex(j, a[i], k);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---
处理用时：85.34秒
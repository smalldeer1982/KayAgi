# 题目信息

# [ABC318E] Sandwiches

## 题目描述

**题意简述**

给定一个长度为 $N$ 的序列 $A$。求满足以下条件的三元组 $(i,j,k)$ 的个数。

- $1 \le i < j < k \le N$
- $A_i = A_k$
- $A_i \ne A_j$

## 说明/提示

- $3 \le N \le 3 \times 10^5$
- $1 \le A_i \le N$

**样例一解释**

有 $3$ 个，分别为 $(1,2,1),(2,1,2),(2,3,2)$。

## 样例 #1

### 输入

```
5

1 2 1 3 2```

### 输出

```
3```

## 样例 #2

### 输入

```
7

1 2 3 4 5 6 7```

### 输出

```
0```

## 样例 #3

### 输入

```
13

9 7 11 7 3 8 1 13 11 11 11 6 13```

### 输出

```
20```

# AI分析结果



## 算法分类
**分组处理与组合数学**

---

## 综合分析与结论
### 核心思路与难点
题目要求统计满足 `i < j < k` 且 `A_i = A_k ≠ A_j` 的三元组个数。关键点在于如何高效处理不同数值的贡献，避免 O(n³) 暴力枚举。

#### 核心算法流程
1. **分组处理**：将相同数值的下标存入数组，按组处理。
2. **间隔贡献计算**：对每组数值的相邻下标对 `(b[j-1], b[j])`，计算中间区间长度 `(b[j]-b[j-1]-1)`，并乘以前半部分可选 `i` 的数量（左侧元素个数 `j`）和后半部分可选 `k` 的数量（右侧元素个数 `size-j`），累加所有贡献。

#### 可视化设计
- **动画演示**：用不同颜色标记数值分组，高亮相邻下标对之间的区间，动态显示贡献计算过程。
- **像素风格**：将数组元素渲染为像素块，处理到某数值时高亮其所有出现位置，相邻位置间用连线表示区间，显示贡献数值。
- **音效触发**：每次计算贡献时播放短促音效，总答案更新时播放上扬音效。

---

## 题解清单（≥4星）
### 1. lrx___（⭐⭐⭐⭐⭐）
- **亮点**：直观分组，直接计算相邻位置贡献，代码简洁高效。
- **关键代码**：
  ```cpp
  for(int j=1; j<l; j++) 
      ans += (a[i][j]-a[i][j-1]-1) * j * (l-j);
  ```

### 2. DerrickLo（⭐⭐⭐⭐）
- **亮点**：优化空间，无需存储全部分组位置，动态维护相邻贡献。
- **关键代码**：
  ```cpp
  for(int j=1; j<ve[i].size(); j++)
      ans += (ve[i][j]-ve[i][j-1]-1)*j*(ve[i].size()-j);
  ```

### 3. Scorilon（⭐⭐⭐⭐）
- **亮点**：枚举中间点 `j`，动态维护左右计数，容斥思路清晰。
- **关键代码**：
  ```cpp
  ans += (sum - 1ll*l[a[j]]*r[a[j]]);
  ```

---

## 最优思路提炼
### 关键技巧
- **分组统计**：按数值分组处理，仅需遍历每个数值的出现位置。
- **间隔贡献公式**：对相邻下标 `b[j-1]` 和 `b[j]`，贡献为 `(间隔长度) × (左侧可选数) × (右侧可选数)`。

### 代码实现
```cpp
#include <vector>
#include <cstdio>
using namespace std;
typedef long long ll;
const int N = 3e5 + 5;
vector<int> pos[N]; // 存储每个数值的下标

int main() {
    int n, x;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &x);
        pos[x].push_back(i); // 分组记录下标
    }
    ll ans = 0;
    for (int x = 1; x <= n; ++x) {
        int m = pos[x].size();
        for (int j = 1; j < m; ++j) {
            int len = pos[x][j] - pos[x][j-1] - 1;
            ans += (ll)len * j * (m - j);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 相似题目推荐
1. **洛谷 P2181 对角线**：组合数学计算交点。
2. **LeetCode 1512. 好数对数目**：统计相同数值的二元组。
3. **CodeForces 1187C. Subarray Permutation**：分组处理区间贡献。

---

## 可视化算法演示
### 动画步骤
1. **初始化**：显示整个数组，用不同颜色标记不同数值。
2. **分组处理**：选中某一数值（如红色），显示其所有出现位置。
3. **计算间隔**：遍历相邻红点，高亮区间，显示 `j` 和 `m-j` 的值。
4. **更新答案**：动态累加贡献值，右侧面板显示当前总和。

### 复古像素风格
- **颜色方案**：8-bit 调色板，每个数值对应固定颜色。
- **音效设计**：计算间隔时播放 `beep` 音效，总答案更新时播放 `victory` 音效。

---

## 个人心得摘录
> **lrx___** 在题解中提到：“要注意计算时会爆 `int`”，提醒了在类似问题中必须预判数值范围，选择合适的数据类型。

---
处理用时：94.04秒
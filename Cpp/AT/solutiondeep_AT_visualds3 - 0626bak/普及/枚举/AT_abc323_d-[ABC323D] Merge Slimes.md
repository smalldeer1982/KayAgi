# 题目信息

# [ABC323D] Merge Slimes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_d

最初、$ N $ 種類のサイズのスライムがいます。  
具体的には、$ 1\leq\ i\leq\ N $ について、サイズ $ S_i $ のスライムが $ C_i $ 匹います。

高橋君はスライムの合成を好きな順番で好きなだけ($ 0 $ 回でも良い)繰り返すことができます。  
スライムの合成では、次のことを行います。

- **同じ** サイズの $ 2 $ 匹のスライムを選ぶ。選ばれたスライムのサイズが $ X $ であったとき、新しくサイズ $ 2X $ のスライムが出現する。合成後、選ばれた元のスライムは $ 2 $ 匹とも消滅する。

高橋君はスライムの匹数を最小にしたいと考えています。 高橋君がうまく合成を繰り返した時、最小で何匹にすることができるでしょうか?

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 10^5 $
- $ 1\leq\ S_i\leq\ 10^9 $
- $ 1\leq\ C_i\leq\ 10^9 $
- $ S_1,S_2,\ldots,S_N $ はすべて異なる。
- 入力はすべて整数

### Sample Explanation 1

最初、サイズ $ 3 $ のスライムが $ 3 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 1 $ 匹います。 高橋君は次のように合成を $ 2 $ 回行うことができます。 - まず、サイズ $ 3 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 6 $ のスライムが $ 2 $ 匹となります。 - 次に、サイズ $ 6 $ のスライム $ 2 $ 匹を選んで合成を行います。サイズ $ 3 $ のスライムが $ 1 $ 匹、サイズ $ 5 $ のスライムが $ 1 $ 匹、サイズ $ 12 $ のスライムが $ 1 $ 匹となります。 高橋君は最初の状態からどのように合成を繰り返してもスライムを $ 2 $ 匹以下にすることはできないため、$ 3 $ を出力します。

### Sample Explanation 2

高橋君は合成を行うことができません。

## 样例 #1

### 输入

```
3
3 3
5 1
6 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3
1 1
2 1
3 1```

### 输出

```
3```

## 样例 #3

### 输入

```
1
1000000000 1000000000```

### 输出

```
13```

# AI分析结果



## 唯一算法分类
**贪心算法**

## 综合分析与结论
**核心思路**：  
题目要求通过合并相同大小的史莱姆，使得最终剩余数量最少。关键在于处理合并后的史莱姆可能与其他史莱姆继续合并的情况。正确算法需按从小到大的顺序处理每个可能的史莱姆大小，动态维护合并后的状态。

**难点与解决**：  
1. **合并顺序的影响**：合并后的史莱姆可能继续合并，需确保所有可能的合并被处理。  
2. **高效实现**：使用有序容器（如 `std::map`）按大小排序，每次处理最小的史莱姆，合并后的数目加入容器，确保后续处理。  

**算法流程**：  
1. 初始化 `map` 存储史莱姆大小和数量。  
2. 循环取出最小的史莱姆，计算余数和合并后的数量。  
3. 将合并后的数量加入更大的史莱姆条目中，累加余数到答案。  

**可视化设计**：  
- **颜色标记**：当前处理的史莱姆高亮为红色，合并后的新史莱姆为绿色。  
- **步进控制**：单步展示合并过程，动态更新 `map` 和答案。  
- **复古像素风格**：用 8-bit 方块表示史莱姆，音效提示合并操作。  

## 题解清单 (≥4星)
1. **wangchai2009 (4星)**  
   - **亮点**：使用优先队列处理最小元素，确保合并顺序正确。  
   - **代码可读性**：结构清晰，逻辑简明。  

2. **Halberd_Cease 的 map 实现 (5星)**  
   - **亮点**：通过 `std::map` 自动排序特性，高效维护合并状态。  
   - **算法优化**：动态更新键值，避免重复处理。  

## 最优代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

int main() {
    int n;
    cin >> n;
    map<i64, i64> m;
    
    for (int i = 0; i < n; i++) {
        i64 s, c;
        cin >> s >> c;
        m[s] = c;
    }
    
    i64 ans = 0;
    while (!m.empty()) {
        auto it = m.begin();
        i64 s = it->first, c = it->second;
        m.erase(it);
        
        if (c == 0) continue;
        ans += c % 2;
        i64 merged = c / 2;
        
        if (merged > 0) {
            m[s * 2] += merged;
        }
    }
    
    cout << ans << endl;
    return 0;
}
```

## 同类型题与套路
- **合并果子类问题**：需按顺序合并最小元素，贪心策略。  
- **二进制分解思想**：数目的二进制中 1 的个数反映最终剩余数量。  

## 推荐题目
1. **P1090 合并果子**：基础贪心，优先队列应用。  
2. **P6033 合并果子加强版**：大数据优化版。  
3. **P2168 荷马史诗**：k 叉哈夫曼编码，扩展贪心。  

## 个人心得
- **顺序关键**：必须从小到大处理，避免遗漏合并机会。  
- **调试经验**：确保合并后的数目正确更新，避免重复计数。  

## 算法可视化
**动画设计**：  
- **Canvas 绘制**：史莱姆按大小排列，颜色区分状态。  
- **音效**：合并时播放“滴”声，答案更新时上扬音效。  
- **自动演示**：按顺序合并，动态显示 `map` 变化和答案累加。  

```javascript
// 伪代码示例（Canvas绘制核心逻辑）
function drawSlimes(map) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let x = 10;
    for (const [s, c] of map) {
        drawPixelSlime(x, 50, s, c); // 像素风格绘制
        x += 30;
    }
}

function mergeStep() {
    const s = currentMap.keys().next().value;
    const c = currentMap.get(s);
    // ... 合并逻辑
    requestAnimationFrame(mergeStep); // 步进动画
}
``` 

**交互控制**：支持暂停/继续、调整动画速度，增强学习体验。

---
处理用时：407.12秒
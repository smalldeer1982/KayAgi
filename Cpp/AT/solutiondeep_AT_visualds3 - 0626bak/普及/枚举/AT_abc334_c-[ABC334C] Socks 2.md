# 题目信息

# [ABC334C] Socks 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_c

高橋君は $ N $ 組の靴下を持っており、$ i $ 番目の組は色 $ i $ の靴下 $ 2 $ 枚からなります。 ある日タンスの中を整理した高橋君は、色 $ A_1,A_2,\dots,A_K $ の靴下を $ 1 $ 枚ずつなくしてしまったことに気づいたので、残っている $ 2N-K $ 枚の靴下を使って、靴下 $ 2 $ 枚ずつからなる $ \lfloor\frac{2N-K}{2}\rfloor $ 個の組を新たに作り直すことにしました。 色 $ i $ の靴下と色 $ j $ の靴下からなる組の**奇妙さ**は $ |i-j| $ として定義され、高橋君は奇妙さの総和をできるだけ小さくしたいです。

残っている靴下をうまく組み合わせて $ \lfloor\frac{2N-K}{2}\rfloor $ 個の組を作ったとき、奇妙さの総和が最小でいくつになるか求めてください。 なお、$ 2N-K $ が奇数のとき、どの組にも含まれない靴下が $ 1 $ 枚存在することに注意してください。

## 说明/提示

### 制約

- $ 1\leq\ K\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_1\ <\ A_2\ <\ \dots\ <\ A_K\ \leq\ N $
- 入力は全て整数

### Sample Explanation 1

以下、色 $ i $ の靴下と色 $ j $ の靴下からなる組を $ (i,j) $ と表記します。 色 $ 1,2,3,4 $ の靴下がそれぞれ $ 1,2,1,2 $ 枚ずつあります。 $ (1,2),(2,3),(4,4) $ の $ 3 $ 組を作ると、奇妙さの総和は $ |1-2|+|2-3|+|4-4|=2 $ となり、これが最小です。

### Sample Explanation 2

$ (1,1),(3,3),(4,4),(5,5) $ の $ 4 $ 組を作り、色 $ 2 $ の靴下を $ 1 $ 枚余らせる（どの組にも入れない）のが最適です。

## 样例 #1

### 输入

```
4 2
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5 1
2```

### 输出

```
0```

## 样例 #3

### 输入

```
8 5
1 2 4 7 8```

### 输出

```
2```

# AI分析结果



**唯一算法分类**  
贪心算法

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
1. **排序处理**：将丢失的袜子颜色按升序排列。  
2. **贪心配对**：偶数情况直接相邻配对，总和最小。奇数情况需枚举删除一个元素，利用预处理的前缀和和后缀和快速计算剩余总和。  

**解决难点**：  
- **奇数处理**：当 K 为奇数时，必须删除一个元素。如何高效计算删除每个元素后的最小总和？  
- **优化计算**：通过前缀和数组 `b[]` 和后缀和数组 `e[]` 预处理相邻配对的和，将时间复杂度从 O(K²) 降至 O(K)。  

**关键变量与步骤**：  
- `b[i]`：前 i 个元素中相邻配对的总和（偶数下标）。  
- `e[i]`：后 i 个元素中相邻配对的总和（奇数下标）。  
- 枚举删除点 i，根据奇偶性选择 `b[i-1] + e[i+1]` 或 `b[i-2] + e[i+2] + (a[i+1]-a[i-1])`。  

---

### **题解评分 (≥4星)**  
1. **Albatross_LC（5星）**  
   - 思路清晰，完整处理奇偶情况。  
   - 代码简洁，前缀和与后缀和预处理巧妙。  
2. **FReQuenter（4星）**  
   - 代码更短，逻辑明确，但注释较少。  
3. **jubingkun（4星）**  
   - 结合图示分析，适合直观理解前后缀和的拼接。  

---

### **最优思路或技巧提炼**  
1. **贪心排序**：排序后相邻配对保证局部最优即全局最优。  
2. **奇偶分治**：奇数时枚举删除点，利用前后缀和避免重复计算。  
3. **预处理优化**：前缀和数组 `b[]` 和后缀和数组 `e[]` 实现 O(1) 查询。  

---

### **同类型题或类似算法套路**  
- **相邻配对最小化差异**：如 [CF1131B](https://codeforces.com/problemset/problem/1131/B)（区间合并）。  
- **动态规划处理奇偶性**：如 [LeetCode 935. 骑士拨号器](https://leetcode.cn/problems/knight-dialer/)。  

---

### **推荐相似题目**  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）  
2. [CF455A Boredom](https://codeforces.com/problemset/problem/455/A)（动态规划+频率统计）  
3. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)（区间DP+环形处理）  

---

### **个人心得摘录**  
- **调试教训**：初始未考虑删除偶数位置时的跨段配对（需额外计算 `a[i+1]-a[i-1]`）。  
- **顿悟点**：前缀和数组的奇偶下标设计，巧妙分割前后段。  

---

### **可视化与算法演示**  
**动画方案**：  
1. **排序展示**：将袜子颜色排列成一行，用不同颜色区分已配对和未配对。  
2. **配对过程**：  
   - **偶数情况**：逐步高亮相邻元素，计算差异值并累加。  
   - **奇数情况**：滑动删除点，动态显示前后缀和的计算范围（如红色块表示删除点，蓝色/绿色块表示前后缀覆盖区间）。  
3. **交互设计**：  
   - **步进控制**：允许单步执行配对或删除操作。  
   - **参数调节**：支持修改 K 值，观察不同情况下的最优解。  

**复古像素风格**：  
- **颜色方案**：8 位色调色板（红、蓝、绿、黄）。  
- **音效触发**：配对成功时播放短促“滴”声，删除时播放“咔嚓”声。  

---

### **核心代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int n, k, a[N], b[N], e[N];

int main() {
    cin >> n >> k;
    for (int i = 1; i <= k; i++) cin >> a[i];
    sort(a + 1, a + 1 + k);
    
    if (k % 2 == 0) {
        int ans = 0;
        for (int i = 1; i <= k; i += 2) ans += a[i+1] - a[i];
        cout << ans;
    } else {
        // 预处理前缀和 b[] 和后缀和 e[]
        for (int i = 2; i <= k; i += 2) 
            b[i] = b[i-2] + a[i] - a[i-1];
        for (int i = k-1; i >= 1; i -= 2) 
            e[i] = e[i+2] + a[i+1] - a[i];
        
        int ans = INT_MAX;
        // 枚举删除奇数位
        for (int i = 1; i <= k; i += 2) 
            ans = min(ans, b[i-1] + e[i+1]);
        // 枚举删除偶数位
        for (int i = 2; i <= k; i += 2) 
            ans = min(ans, b[i-2] + e[i+2] + a[i+1] - a[i-1]);
        cout << ans;
    }
    return 0;
}
```

---
处理用时：71.27秒
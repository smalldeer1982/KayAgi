# 题目信息

# [ARC170B] Arithmetic Progression Subsequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_b

$ 1 $ 以上 $ \textbf{10} $ 以下の整数からなる長さ $ N $ の数列 $ A $ が与えられます．

$ 1\leq\ l\ \leq\ r\leq\ N $ を満たす整数組 $ (l,r) $ であって，以下の条件を満たすものを良い組と呼びます．

- 数列 $ (A_l,A_{l+1},\ldots,A_r) $ は長さ $ 3 $ の等差数列を（連続とは限らない）部分列として含む．より厳密には，$ l\ \leq\ i\ <\ j\ <\ k\leq\ r $ を満たす整数組 $ (i,j,k) $ であって， $ A_j\ -\ A_i\ =\ A_k\ -\ A_j $ なるものが存在する．
 
良い組の個数を求めてください．

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10 $
- 入力される数値は全て整数
 
### Sample Explanation 1

良い組は $ (l,r)=(1,4),(1,5),(2,5) $ の $ 3 $ つです． 例えば，数列 $ (A_1,A_2,A_3,A_4) $ は $ (5,3,1) $ という長さ $ 3 $ の等差数列を部分列として含むので $ (1,4) $ は良い組です．

### Sample Explanation 2

良い組が存在しない場合もあります．

## 样例 #1

### 输入

```
5

5 3 4 1 5```

### 输出

```
3```

## 样例 #2

### 输入

```
3

1 2 1```

### 输出

```
0```

## 样例 #3

### 输入

```
9

10 10 1 3 3 7 2 2 5```

### 输出

```
3```

# AI分析结果



# 算法分类
**预处理数组 + 双指针**

---

## 题解思路、算法要点与解决难点

### 核心思路
题目要求统计所有区间中存在至少一个非连续的三元组等差数列的情况。暴力枚举所有区间不可行，需通过预处理和双指针优化：

1. **预处理 nxt 数组**：记录每个位置后每个数值的首次出现位置，快速定位三元组中的元素。
2. **枚举左端点，计算最小右端点**：对于每个左端点，枚举可能的中间值和目标等差值，通过 `nxt` 数组快速验证是否存在有效三元组。
3. **维护右端点最小值**：从右向左传递最小值，确保每个左端点对应的最小右端点正确。

### 解决难点
1. **高效查找三元组**：直接枚举区间复杂度高，预处理 `nxt` 数组将查找复杂度降至 O(1)。
2. **避免重复计算**：通过维护每个左端点的最小右端点，并利用双指针思想累加答案。

---

## 最优思路提炼
1. **预处理 nxt 数组**：存储每个位置后每个值的首次出现位置，快速定位后续元素。
2. **枚举左端点，计算最小右端点**：
   - 对每个左端点 `i`，枚举中间值 `j`，计算目标值 `k`。
   - 通过 `nxt[i][j]` 找到中间位置，再通过 `nxt[p][k]` 找到目标位置。
3. **维护右端点最小值**：从右向左更新，确保每个 `i` 的最小右端点不大于 `i+1` 的最小右端点。
4. **累加答案**：每个左端点对应的有效区间数为 `n - r + 1`。

---

## 题解评分（≥4星）

### 1. XYstarabyss（4.5星）
- **亮点**：通过预处理 `nxt` 数组快速定位元素，时间复杂度低（O(nV²)），代码简洁高效。
- **代码片段**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= 10; j++) {
          long long p = nxt[i][j]; // 中间值位置
          long long q = (j * 2) - a[i]; // 目标值
          if (p && q >= 1 && q <= 10) {
              p = nxt[p][q]; // 目标值位置
              if (p) r[i] = min(r[i], p);
          }
      }
  }
  ```

### 2. Jerry_heng（4星）
- **亮点**：类似预处理思路，但通过 `las` 数组维护最小右端点，代码逻辑清晰。
- **代码片段**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= 10; j++) {
          if ((j * 2 - a[i]) 超出范围) continue;
          int z = pos[pos[i][j]][目标值];
          if (z <= n) las[i] = min(las[i], z);
      }
  }
  ```

### 3. fcy20180201（4星）
- **亮点**：预处理所有可能的等差数列，利用双指针动态维护区间信息，时间复杂度 O(VN)。
- **代码片段**：
  ```cpp
  while (r < n && !have) {
      r++;
      // 更新当前区间内的等差数列信息
  }
  ```

---

## 同类型题与算法套路
- **类似题目**：滑动窗口统计满足条件的区间数、预处理数组优化查找。
- **通用套路**：
  1. **预处理辅助数组**：如 `nxt[i][v]` 记录位置 `i` 后值 `v` 的首次出现。
  2. **双指针维护区间**：结合预处理信息快速判断区间合法性。
  3. **维护最小值/最大值**：通过传递性减少重复计算。

---

## 推荐题目
1. **P2671 [NOIP2015 普及组] 求和**：预处理奇偶位置的和。
2. **P3403 跳楼机**：预处理模数下的最小步数。
3. **P2216 [HAOI2007] 理想的正方形**：二维滑动窗口与预处理结合。

---

## 可视化与算法演示
### 动画设计
1. **预处理阶段**：高亮每个位置 `i`，展示 `nxt[i][v]` 的更新过程。
2. **枚举左端点**：以红色标记当前左端点 `i`，绿色标记中间值 `j`，蓝色标记目标值 `k`。
3. **查找三元组**：动态显示通过 `nxt` 数组查找 `j` 和 `k` 的过程。
4. **维护右端点**：用黄色标记当前最小右端点，展示从右向左更新过程。

### 复古像素风格
- **颜色方案**：红色（左端点）、绿色（中间值）、蓝色（目标值）、黄色（最小右端点）。
- **音效**：成功找到三元组时播放上扬音效，更新右端点时播放点击音效。
- **Canvas 绘制**：网格展示数组元素，动态更新 `nxt` 和右端点位置。

---

## 代码实现（核心逻辑）
```cpp
// 预处理 nxt 数组
for (int i = n; i >= 1; i--) {
    for (int v = 1; v <= 10; v++) {
        nxt[i][v] = (a[i+1] == v) ? i+1 : nxt[i+1][v];
    }
}

// 计算每个左端点的最小右端点
vector<int> r(n+2, INF);
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= 10; j++) {
        int p = nxt[i][j];
        int k_val = 2*j - a[i];
        if (k_val < 1 || k_val > 10 || p == 0) continue;
        int q = nxt[p][k_val];
        if (q != 0) r[i] = min(r[i], q);
    }
}

// 传递最小右端点
for (int i = n-1; i >= 1; i--) {
    r[i] = min(r[i], r[i+1]);
}

// 累加答案
long long ans = 0;
for (int i = 1; i <= n; i++) {
    if (r[i] <= n) ans += n - r[i] + 1;
}
```

---
处理用时：102.10秒
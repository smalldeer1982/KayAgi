# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果



### 唯一算法分类
**双指针/滑动窗口**

---

### 题解思路与算法要点
**核心逻辑**：预处理字符位置，用指针线性扫描找到满足条件的 `J-O-I` 序列的最小区间。  
**关键步骤**：
1. **预处理**：将 `J`、`O`、`I` 的位置分别存入三个数组。
2. **三指针扫描**：
   - 枚举每个可能的 `J` 起始位置。
   - 维护 `O` 和 `I` 的指针，从前一位置继续查找，避免重复遍历。
   - 计算区间总长度，更新最小值。
3. **复杂度优化**：线性遍历，时间复杂度为 $O(N)$。

**解决难点**：
- 如何高效定位 `O` 和 `I` 的起始位置？  
  维护指针，每次从上次结束位置继续扫描，避免从头开始。
- 如何保证区间顺序？  
  强制要求 `J` 的结束位置在 `O` 的起始位置之前，`O` 的结束位置在 `I` 的起始位置之前。

---

### 最优思路提炼
1. **预处理存储字符位置**：将各字符的索引单独存储，便于快速访问。
2. **三指针贪心扫描**：  
   - 固定 `J` 的起始位置后，`O` 和 `I` 的指针只需单向移动。
   - 通过指针维护，确保每个字符段只需遍历一次。
3. **最小区间计算**：总区间长度减去 $3K$ 即为操作3的最小次数。

---

### 题解评分 (≥4星)
1. **saixingzhe**（⭐️⭐️⭐️⭐️⭐️）  
   - 核心亮点：线性指针维护，时间复杂度最优 ($O(N)$)，代码简洁。
   - 代码片段：
     ```cpp
     for(int J=0; J<=q[0].size()-k; J++){
         while(O<=q[1].size()-k && q[0][J+k-1]>q[1][O]) O++;
         while(I<=q[2].size()-k && q[1][O+k-1]>q[2][I]) I++;
         ans = min(ans, q[2][I+k-1]-q[0][J]+1-3*k);
     }
     ```
2. **User_Artist**（⭐️⭐️⭐️⭐️）  
   - 核心亮点：清晰的三指针推进逻辑，无二分操作。
   - 代码片段：
     ```cpp
     while(O[go] <= J[gj + k - 1] && go < co) ++go;
     while(I[gi] <= O[go + k - 1] && gi < ci) ++gi;
     ans = min(ans, I[gi + k - 1] + 1 - J[gj] - 3 * k);
     ```
3. **small_turtle**（⭐️⭐️⭐️⭐️）  
   - 核心亮点：利用 `lower_bound` 简化代码，逻辑清晰。
   - 代码片段：
     ```cpp
     int x=lower_bound(J+1,J+1+n,J[i-1]+k)-J;
     int y=lower_bound(O+1,O+1+n,O[x-1]+k)-O;
     int z=lower_bound(I+1,I+1+n,I[y-1]+k)-I;
     ```

---

### 可视化与算法演示
**动画设计**：
1. **像素风格界面**：  
   - 用三种颜色方块表示 `J`（红）、`O`（绿）、`I`（蓝）。
   - 当前扫描的 `J` 段用闪烁红框标记，`O` 和 `I` 段同理。
2. **指针动态移动**：  
   - 显示三个指针 `gj`、`go`、`gi` 的移动轨迹。
   - 每次找到有效区间后，高亮该区间并显示长度计算过程。
3. **音效与反馈**：  
   - 成功匹配时播放8-bit胜利音效。
   - 指针移动时伴随轻微“滴答”声。

**交互功能**：
- **步进控制**：允许单步执行，观察指针如何跳过无效位置。
- **自动演示**：AI模式自动遍历所有可能的 `J` 起始位置。

---

### 相似题目推荐
1. [P3405 字符串的展开](https://www.luogu.com.cn/problem/P3405)  
   **关联点**：字符串分段处理与贪心优化。
2. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)  
   **关联点**：双指针求连续区间和。
3. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)  
   **关联点**：滑动窗口求最小区间覆盖所有元素。

---
处理用时：76.69秒
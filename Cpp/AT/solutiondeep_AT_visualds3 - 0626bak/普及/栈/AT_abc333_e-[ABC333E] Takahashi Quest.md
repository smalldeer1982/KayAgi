# 题目信息

# [ABC333E] Takahashi Quest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_e

高橋くんは冒険に出ようとしています。

冒険では、$ N $ 個の出来事が起こります。 $ i $ 番目 $ (1\leq\ i\leq\ N) $ の出来事は整数の組 $ (t\ _\ i,x\ _\ i) $ $ (1\leq\ t\ _\ i\leq\ 2,1\leq\ x\ _\ i\leq\ N) $ で表され、次のような出来事です。

- $ t\ _\ i=1 $ のとき、タイプ $ x\ _\ i $ のポーションを $ 1 $ つ発見する。高橋くんは、発見したポーションを拾うか捨てるかのどちらかを選択する。
- $ t\ _\ i=2 $ のとき、タイプ $ x\ _\ i $ のモンスター $ 1 $ 体と遭遇する。高橋くんがタイプ $ x\ _\ i $ のポーションを持っている場合、それを $ 1 $ つ消費することでモンスターを撃退することができる。モンスターを撃退しなかった場合、高橋くんは敗北する。
 
高橋くんが敗北することなく全てのモンスターを撃退することができるか判定してください。

高橋くんが全てのモンスターを撃退することができない場合、`-1` を出力してください。

高橋くんが全てのモンスターを撃退することができる場合、高橋君が冒険の途中で持っているポーションの個数の最大値を $ K $ とします。 高橋くんが敗北しないような戦略全体にわたる $ K $ の最小値を $ K\ _\ {\min} $ とします。 $ K\ _\ {\min} $ の値と、$ K\ _\ {\min} $ を達成する高橋くんの行動を出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10^5 $
- $ 1\leq\ t\ _\ i\leq2\ (1\leq\ i\leq\ N) $
- $ 1\leq\ x\ _\ i\leq\ N\ (1\leq\ i\leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

出力例は、次のような行動に対応しています。 - タイプ $ 2,3,1 $ のポーションをこの順に発見する。これらのポーションをすべて拾う。 - タイプ $ 3,2 $ のポーションをこの順に発見する。これらのポーションをいずれも拾わない。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾う。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾わない。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾う。 - タイプ $ 2 $ のモンスターと遭遇する。持っているタイプ $ 2 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 1 $ のモンスターと遭遇する。持っているタイプ $ 1 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 この行動では、$ K $ の値は $ 3 $ となります。 $ K\leq\ 2 $ として敗北しない方法はないので、求める $ K\ _\ {\min} $ の値は $ 3 $ です。 $ K=3 $ を満たして高橋くんが敗北しない行動は複数ありますが、どれを出力しても構いません。

### Sample Explanation 2

高橋くんはかならず最初に遭遇するモンスターに敗北してしまいます。

## 样例 #1

### 输入

```
13

1 2

1 3

1 1

1 3

1 2

2 3

1 3

1 3

2 3

1 3

2 2

2 3

2 1```

### 输出

```
3

1 1 1 0 0 1 0 1```

## 样例 #2

### 输入

```
4

2 3

1 4

2 1

1 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
30

1 25

1 2

1 10

1 18

2 18

1 11

2 11

1 21

1 6

2 2

2 10

1 11

1 24

1 11

1 3

1 2

1 18

2 25

1 8

1 10

1 11

2 18

2 10

1 10

2 2

1 24

1 10

2 10

1 25

2 6```

### 输出

```
4

1 1 1 1 1 0 1 0 0 0 0 1 1 0 1 0 1 0 0 0```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路与算法要点**
1. **核心思路**  
   - **贪心策略**：每个怪物必须用其类型的最晚出现的药水，以最小化同时携带药水的数量。  
   - **数据结构**：为每个药水类型维护一个栈，记录该类型药水的出现时间。遇到怪物时，弹出栈顶元素（即最近的药水）用于击败怪物。  
   - **标记与统计**：标记被使用的药水，遍历事件序列统计最大同时携带药水数。

2. **解决难点**  
   - **药水选择顺序**：必须保证每个怪物都能找到对应的药水，且药水使用时间尽可能晚，避免早期积累过多药水。  
   - **动态维护状态**：通过栈的先进后出特性，快速找到最近的可用药水。  
   - **最大携带数计算**：通过差分数组或实时计数，记录每个时刻的携带药水数，取最大值。

---

### **题解评分 (≥4星)**
1. **2020luke（★★★★★）**  
   - **亮点**：代码简洁高效，直接使用栈结构，标记数组清晰。  
   - **关键代码**：遍历事件时用栈记录药水时间，遇到怪物弹出栈顶并标记。  
   ```cpp
   stack<int> st[N];  // 每个类型维护一个栈
   if (t[i] == 2) {
       if (st[x].empty()) { /* 无解处理 */ }
       flag[st[x].top()] = 1;  // 标记药水被使用
       st[x].pop();
   }
   ```

2. **STARSczy（★★★★☆）**  
   - **亮点**：使用差分数组优化统计过程，减少时间复杂度。  
   - **关键代码**：通过差分标记药水使用区间，最后求前缀和的最大值。  
   ```cpp
   a[t[x].top()]++, f[t[x].top()] = 1, a[i+1]--;  // 差分标记
   ```

3. **OAer（★★★★☆）**  
   - **亮点**：代码注释详细，变量命名清晰，适合教学。  
   - **关键代码**：用栈处理药水，实时更新当前携带药水数。  
   ```cpp
   for (int i=1; i<=n; i++) {
       if (op[i]==1 && flag[i]) cnt++;
       maxn = max(maxn, cnt);  // 统计最大值
   }
   ```

---

### **最优思路提炼**
- **贪心核心**：每个怪物使用最晚出现的对应药水，确保药水携带时间最短。  
- **实现技巧**：  
  1. **栈维护药水时间**：每个药水类型一个栈，记录出现顺序。  
  2. **标记与统计分离**：先处理所有事件确定药水使用标记，再遍历统计最大携带数。  
  3. **差分优化**：通过区间标记减少统计复杂度（可选优化）。

---

### **同类型题与算法套路**
- **类似题目**：  
  1. **活动选择问题**：选择最多的不重叠活动。  
  2. **任务调度**：用最少的资源完成所有任务。  
  3. **区间覆盖**：用最少的点覆盖所有区间。

- **通用套路**：  
  - **贪心选择最晚可行解**：在允许延迟决策时，尽量推迟选择以减少资源占用。  
  - **栈/队列维护动态候选集**：快速访问最近或最优候选元素。

---

### **推荐题目**
1. **P1803 凌乱的yyy / 线段覆盖**（贪心选择最早结束活动）  
2. **P1080 国王游戏**（贪心排序+高精度）  
3. **P2949 工作调度**（优先队列维护当前最优任务）

---

### **可视化与算法演示**
1. **动画设计**：  
   - **栈操作高亮**：当遇到怪物时，对应类型栈顶药水被标记为红色并弹出。  
   - **携带数动态条**：实时显示当前携带药水数量，峰值用不同颜色标注。  
   - **复古像素风格**：药水为绿色像素块，怪物为红色像素块，栈用垂直排列的方块表示。

2. **交互功能**：  
   - **步进控制**：按空格键逐步执行事件，观察栈和携带数的变化。  
   - **音效提示**：弹出药水时播放“叮”声，怪物击败时播放“爆炸”音效。

3. **代码片段（伪代码）**：  
   ```javascript
   // 在 Canvas 中绘制栈
   function drawStack(type, stack) {
       ctx.fillStyle = "#00FF00";  // 绿色药水
       stack.forEach((pos, idx) => {
           ctx.fillRect(100 * type, 400 - 30 * idx, 50, 20);  // 垂直排列
       });
   }
   ```

---

### **核心代码实现**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
stack<int> st[N];  // 每个药水类型的栈
bool used[N];      // 标记药水是否被使用

int main() {
    int n, max_k = 0, cnt = 0;
    cin >> n;
    // 处理所有药水事件，填充栈
    for (int i = 1; i <= n; ++i) {
        int t, x;
        cin >> t >> x;
        if (t == 1) {
            st[x].push(i);
        } else {
            if (st[x].empty()) { cout << -1; return 0; }
            used[st[x].top()] = true;  // 标记为使用
            st[x].pop();
        }
    }
    // 计算最大携带数
    for (int i = 1; i <= n; ++i) {
        if (used[i]) cnt++;
        else if (i对应事件是怪物) cnt--;
        max_k = max(max_k, cnt);
    }
    cout << max_k << endl;
    for (int i = 1; i <= n; ++i)
        if (事件i是药水) cout << used[i] << " ";
    return 0;
}
```

---

**总结**：通过贪心策略选择最晚药水，结合栈实现高效动态维护，最终统计最大值。此方法时间复杂度为 O(N)，空间复杂度 O(N)，适用于大规模数据。

---
处理用时：73.81秒
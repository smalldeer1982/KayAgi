# 题目信息

# [ABC359E] Water Tank

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc359/tasks/abc359_e

長さ $ N $ の正整数列 $ H=(H\ _\ 1,H\ _\ 2,\dotsc,H\ _\ N) $ が与えられます。

長さ $ N+1 $ の非負整数列 $ A=(A\ _\ 0,A\ _\ 1,\dotsc,A\ _\ N) $ があります。 はじめ、$ A\ _\ 0=A\ _\ 1=\dotsb=A\ _\ N=0 $ です。

$ A $ に対して、次の操作を繰り返します。

1. $ A\ _\ 0 $ の値を $ 1 $ 増やす。
2. $ i=1,2,\ldots,N $ に対して、この順に次の操作を行う。
  - $ A\ _\ {i-1}\gt\ A\ _\ i $ かつ $ A\ _\ {i-1}\gt\ H\ _\ i $ のとき、$ A\ _\ {i-1} $ の値を $ 1 $ 減らし、$ A\ _\ i $ の値を $ 1 $ 増やす。
 
$ i=1,2,\ldots,N $ のそれぞれに対して、初めて $ A\ _\ i\ >\ 0 $ が成り立つのは何回目の操作の後か求めてください。

## 说明/提示

### ストーリー

> 長い水槽があり、高さの異なる板が等間隔に配置されています。 高橋くんは、この水槽の端へ水を注いでいったとき、板で区切られたそれぞれの領域に水が到達する時刻が知りたいです。

### 制約

- $ 1\leq\ N\leq2\times10\ ^\ 5 $
- $ 1\leq\ H\ _\ i\leq10\ ^\ 9\ (1\leq\ i\leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ $ 5 $ 回の操作では以下のようになります。 それぞれの行が一回の操作に対応し、左端が $ 1 $ 番の操作を、それ以外が $ 2 $ 番の操作に対応します。 !\[\](https://img.atcoder.jp/abc359/570466412318b9902952c408a421be0c.png) この図から、$ A\ _\ 1\gt0 $ が初めて成り立つのは $ 4 $ 回目の操作の後、$ A\ _\ 2\gt0 $ が初めて成り立つのは $ 5 $ 回目の操作の後です。 同様にして、$ A\ _\ 3,A\ _\ 4,A\ _\ 5 $ に対する答えは $ 13,14,26 $ です。 よって、`4 5 13 14 26` を出力してください。

### Sample Explanation 2

出力すべき値が $ 32\operatorname{bit} $ 整数に収まらない場合があることに注意してください。

## 样例 #1

### 输入

```
5

3 1 4 1 5```

### 输出

```
4 5 13 14 26```

## 样例 #2

### 输入

```
6

1000000000 1000000000 1000000000 1000000000 1000000000 1000000000```

### 输出

```
1000000001 2000000001 3000000001 4000000001 5000000001 6000000001```

## 样例 #3

### 输入

```
15

748 169 586 329 972 529 432 519 408 587 138 249 656 114 632```

### 输出

```
749 918 1921 2250 4861 5390 5822 6428 6836 7796 7934 8294 10109 10223 11373```

# AI分析结果



**唯一算法分类**  
单调栈

---

**题解思路、算法要点与解决难点**  

- **核心思路**：  
  每个位置i的首次注水时间取决于其左侧第一个更高隔板j。当水填满j到i-1的区域到H_i高度后，下一操作才会使i被注水。使用单调栈高效找到j，递推计算填满所需次数。

- **关键步骤**：  
  1. **单调栈维护递减序列**：栈中存储下标，确保每次处理i时栈顶元素为左侧第一个比H_i大的位置j。  
  2. **递推式求填满时间**：`sum[i] = sum[j] + (i-j)*H_i`，其中sum[i]表示填满到H_i的操作次数，输出`sum[i]+1`（第一次注水需多一次操作）。  

- **解决难点**：  
  直接模拟操作会超时，通过单调栈将时间复杂度优化至O(n)。难点在于将水流问题转化为填满矩形区域的数学建模，并识别出左侧更高隔板的限制作用。

---

**题解评分 (≥4星)**  

1. **Sorato_ 题解（5星）**  
   - 思路清晰，代码简洁，直接用栈维护位置，递推式直观。  
   - 示例分析详细，配图辅助理解。  

2. **Redamancy_Lydic 题解（4星）**  
   - 结构体栈存储高度与累计距离，逻辑清晰。  
   - 背景描述增加理解趣味性，但代码稍显复杂。  

3. **Vitamin_B 题解（4星）**  
   - 代码最简洁，直接记录lst数组递推，高效易懂。  
   - 缺少详细解释，但对有单调栈基础的读者友好。  

---

**最优思路或技巧提炼**  

- **单调栈找左侧更大元素**：维护递减栈，快速定位每个i的左侧边界j。  
- **填满时间递推**：利用`sum[i] = sum[j] + (i-j)*H_i`，将问题拆解为独立子问题。  
- **+1修正**：填满后下一操作才触发注水，故最终答案需加1。  

---

**同类型题或算法套路**  

- **直方图最大矩形**（单调栈找左右边界）  
- **接雨水问题**（计算每个位置的储水量）  
- **每日温度**（寻找下一个更高温度的天数）  

---

**推荐相似题目**  

1. [P5788 单调栈模板](https://www.luogu.com.cn/problem/P5788)  
2. [P1901 发射站](https://www.luogu.com.cn/problem/P1901)  
3. [P2422 良好的感觉](https://www.luogu.com.cn/problem/P2422)  

---

**代码片段 (Sorato_ 题解)**  

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, h[200010], sum[200010];
stack<int> s;

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> h[i];
        while (!s.empty() && h[s.top()] <= h[i]) s.pop();
        if (s.empty()) sum[i] = i * h[i];
        else sum[i] = sum[s.top()] + (i - s.top()) * h[i];
        cout << sum[i] + 1 << ' ';
        s.push(i);
    }
}
```

---

**可视化与算法演示**  

1. **像素风格动画**：  
   - **水槽与隔板**：用不同颜色像素块表示隔板高度，蓝色表示水位。  
   - **单调栈过程**：高亮当前处理的隔板i，显示栈内元素弹出过程，标红最终确定的j位置。  
   - **填满效果**：从j到i区域逐渐填充蓝色，显示`(i-j)*H_i`的计算过程。  

2. **交互控制**：  
   - **步进执行**：按钮控制单步执行，观察栈变化和sum值更新。  
   - **音效反馈**：弹出栈时播放“咔嚓”音效，计算完成时播放“滴答”声。  

3. **Canvas 动态演示**：  
   - **初始化**：绘制隔板和水位线，初始化栈为空。  
   - **处理i时**：向左扫描栈元素，动态显示弹出和压栈操作，更新填满区域颜色。  

---

**复古游戏化设计**  

- **8位音效**：栈弹出时8-bit“弹射”音效，答案计算成功时播放胜利音效。  
- **积分系统**：每正确计算一个i的答案得10分，连续正确触发连击倍率。  
- **自动演示模式**：AI自动步进，展示算法流程，类似贪吃蛇自动寻路。  

--- 

**总结**  
本题通过单调栈高效建模水流填满过程，核心在于识别左侧更高隔板的限制作用，递推计算填满时间。可视化设计结合像素动画和交互控制，增强算法理解与记忆。

---
处理用时：113.38秒
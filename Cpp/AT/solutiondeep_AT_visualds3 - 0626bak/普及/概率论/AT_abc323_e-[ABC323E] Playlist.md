# 题目信息

# [ABC323E] Playlist

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc323/tasks/abc323_e

高橋君は $ N $ 曲からなるプレイリストを持っています。 曲 $ i $ $ (1\ \leq\ i\ \leq\ N) $ の長さは $ T_i $ 秒です。  
高橋君は時刻 $ 0 $ にプレイリストのランダム再生を開始しました。

ランダム再生では、$ N $ 曲の中から等確率で $ 1 $ つを選びその曲を最後まで再生することが繰り返されます。 ここで、曲の再生は休みなく行われ、$ 1 $ つの曲が終わったらすぐに次に選ばれた曲が始まります。 また、同じ曲が連続して選ばれる事もあります。

時刻 $ 0 $ から $ (X+0.5) $ 秒後に曲 $ 1 $ が再生されている確率を $ \text{mod}998244353 $ で求めてください。

確率 $ \text{mod\ }\ 998244353 $ の定義この問題で求める確率は必ず有理数になることが証明できます。 また、この問題の制約下では、求める確率を既約分数 $ \frac{y}{x} $ で表したときに $ x $ が $ 998244353 $ で割り切れないことが保証されます。

このとき $ xz\ \equiv\ y\ \pmod{998244353} $ を満たすような $ 0 $ 以上 $ 998244352 $ 以下の整数 $ z $ が一意に定まります。この $ z $ を答えてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\leq\ 10^3 $
- $ 0\ \leq\ X\leq\ 10^4 $
- $ 1\ \leq\ T_i\leq\ 10^4 $
- 入力はすべて整数

### Sample Explanation 1

時刻 $ 0 $ から $ 6.5 $ 秒後に曲 $ 1 $ が流れているパターンとしてあり得るのは、 - 曲 $ 1 $ $ \to $ 曲 $ 1 $ $ \to $ 曲 $ 1 $ - 曲 $ 2 $ $ \to $ 曲 $ 1 $ - 曲 $ 3 $ $ \to $ 曲 $ 1 $ の順で音楽が再生された場合であり、これらのいずれかが起こる確率は $ \frac{7}{27} $ となります。 $ 369720131\times\ 27\equiv\ 7\ \pmod{998244353} $ であるため、$ 369720131 $ を出力します。

### Sample Explanation 2

時刻 $ 0 $ から $ 0.5 $ 秒後には最初に再生された曲が再生されているため、求める確率は $ \frac{1}{5} $ となります。 同じ長さの異なる曲が存在することがあることに注意してください。

## 样例 #1

### 输入

```
3 6
3 5 6```

### 输出

```
369720131```

## 样例 #2

### 输入

```
5 0
1 2 1 2 1```

### 输出

```
598946612```

## 样例 #3

### 输入

```
5 10000
1 2 3 4 5```

### 输出

```
586965467```

# AI分析结果



### 算法分类  
动态规划

---

### 综合分析与结论  
#### 核心思路与难点  
所有题解均采用动态规划思想，核心在于建立时间轴上的概率转移模型：  
1. **状态定义**：`f[i]` 表示在时刻 `i` 刚好结束播放某首歌的概率  
2. **转移方程**：`f[i] = Σ(f[i-Tj] * 1/N)`，类似完全背包的转移逻辑  
3. **答案计算**：累加 `[X-T1+1, X]` 时间段的概率之和，再乘以选择第一首歌的概率 `1/N`  

**核心难点**：  
- 正确建模时间窗口与概率转移关系  
- 处理模运算下的概率计算（需多次使用模逆元）  

#### 可视化设计  
**动画方案**：  
1. **时间轴展示**：水平轴表示时间点，纵向展示 `f[i]` 的概率值变化  
2. **转移高亮**：当处理时间 `i` 时，用不同颜色标记所有可能的 `Tj`，并显示 `i-Tj → i` 的转移箭头  
3. **实时统计**：在右侧面板动态显示当前累计的答案区间 `[X-T1+1, X]` 的求和过程  

**复古游戏化实现**：  
- **像素风格**：用8位色块表示时间点（绿色表示已计算，红色表示当前处理点）  
- **音效设计**：  
  - 每次转移时播放 "beep" 音效  
  - 答案区间统计时播放胜利音效  
- **自动演示**：按时间顺序自动推进，支持暂停/加速  

---

### 题解清单（≥4星）  
1. **梦应归于何处（★★★★☆）**  
   - 亮点：一维DP空间优化，代码简洁易读  
   - 关键代码：  
     ```cpp
     for(int i=0;i<=x;i++) {
         for(int j=1;j<=n;j++) {
             if(i>=t[j]) f[i] = (f[i] + f[i-t[j]] * ni) % mod;
         }
     }
     ```

2. **not_clever_syl（★★★★☆）**  
   - 亮点：数学推导清晰，边界处理完备  
   - 关键注释：  
     ```cpp
     // 答案区间计算
     for(int i=max(x-t[1]+1,0ll);i<=x;++i) ans+=f[i];
     ```

3. **Halberd_Cease（★★★★☆）**  
   - 亮点：伪代码辅助说明，适合教学  
   - 核心逻辑：  
     ```text
     dp_{i+T_j} += dp_i * 1/N  // 完全背包式转移
     ```

---

### 最优思路提炼  
**关键技巧**：  
1. **时间窗口逆向计算**：通过 `X+0.5 ∈ [s, s+T1)` 推导出 `s ∈ [X-T1+1, X]`  
2. **模逆元预处理**：提前计算 `1/N` 的模逆元加速状态转移  
3. **滚动累加优化**：一维DP数组实现O(NX)时间复杂度  

**代码模板**：  
```cpp
ll f[MAX_X + MAX_T] = {1}; // 初始状态
ll inv_n = qpow(n, MOD-2); 

for(int i=0; i<=X; ++i) {
    for(int tj : T) {
        if(i >= tj) f[i] = (f[i] + f[i-tj] * inv_n) % MOD;
    }
}

ll ans = accumulate(f + max(0,X-T1+1), f + X + 1, 0LL) * inv_n % MOD;
```

---

### 相似题目推荐  
1. **P2587 [ZJOI2008]泡泡堂** - 时间序列博弈  
2. **P4547 [THUWC2017]随机二分图** - 概率DP建模  
3. **P6859 蝴蝶与花** - 时间窗口统计  

---

### 可视化核心代码片段  
```javascript
// 像素动画核心逻辑
function drawFrame(time) {
  ctx.fillStyle = "#2D2D2D"; // 背景色
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 绘制时间轴
  for(let i=0; i<=maxTime; i++) {
    const intensity = Math.min(f[i]*255, 255);
    ctx.fillStyle = `rgb(${intensity}, ${255-intensity}, 0)`;
    ctx.fillRect(i*10, 100 - f[i]*50, 8, 8); // 像素块绘制
    
    // 高亮当前处理的时间点
    if(i === currentTime) {
      ctx.strokeStyle = "#00FFFF";
      ctx.strokeRect(i*10-2, 98, 12, 12);
    }
  }
}
```

---

通过将动态规划的时间转移过程转化为像素动画，学习者可以直观观察到概率值在时间轴上的扩散过程，配合音效提示关键操作，极大增强对算法原理的理解。

---
处理用时：59.60秒
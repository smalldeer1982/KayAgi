# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果



**唯一算法分类**  
贪心算法

---

### **题解思路与算法要点**  
1. **核心思路**  
   每次选择当前可用的最大伤害攻击方式。挥砍（可重复使用）和投掷（仅一次）的伤害分开处理，优先投掷所有伤害大于最大挥砍的刀，剩余伤害用最大挥砍处理。

2. **关键步骤**  
   - 找出所有刀中挥砍伤害的最大值 `max_a`。  
   - 收集所有投掷伤害 `b_i > max_a` 的刀，按 `b_i` 降序排序。  
   - 投掷这些刀直到怪物死亡或所有符合条件的投掷用完。  
   - 剩余伤害由 `max_a` 挥砍补足。

3. **解决难点**  
   - **贪心选择**：正确区分投掷和挥砍的优先级。若投掷伤害高于最大挥砍，则投掷最优；否则直接用最大挥砍。  
   - **复杂度优化**：避免全量排序所有攻击方式，仅筛选符合条件的投掷。时间复杂度为 `O(n log n)`，适用于 `n ≤ 1e5`。

---

### **题解评分与亮点**  
- **ITZDC9（★★★★☆）**  
  **亮点**：将所有攻击方式（挥砍和投掷）按伤害排序，遍历时优先处理高伤害项。代码逻辑清晰，但需处理双倍数组元素。  
  **代码关键**：拆分刀为挥砍和投掷元素，排序后依次处理。
  
- **happybob（★★★★★）**  
  **亮点**：仅排序投掷伤害，动态计算投掷后剩余伤害的最小次数。时间复杂度更低，代码简洁。  
  **代码关键**：初始化为仅挥砍的解，逐步尝试投掷并更新最优解。
  
- **___new2zy___（★★★★☆）**  
  **亮点**：将刀拆分为挥砍和投掷元素，统一排序后贪心处理。思路与ITZDC9一致，代码风格简洁。

---

### **最优思路提炼**  
1. **关键技巧**  
   - **贪心排序**：仅处理投掷伤害大于最大挥砍的刀，确保每次攻击伤害最大。  
   - **动态更新**：计算每次投掷后的剩余伤害，取最小次数。  
2. **代码核心片段**  
   ```cpp
   // happybob的代码核心逻辑
   sort(b + 1, b + 1 + n, greater<int>()); // 投掷伤害降序排序
   for (int i = 1; i <= n; i++) {
       h -= b[i];
       if (h < 0) h = 0;
       int k = i + ceil(double(h) / max_a);
       ans = min(ans, k);
   }
   ```

---

### **同类型题与算法套路**  
- **类似问题**  
  1. **区间覆盖问题**：选择最小区间覆盖目标范围。  
  2. **任务调度**：每次选择收益最高的任务执行。  
- **通用解法**  
  - 贪心策略：优先选择当前最优选项，证明局部最优可推导全局最优。  
  - 排序预处理：将候选操作按优先级排序，简化决策。

---

### **推荐相似题目**  
1. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（贪心排序）  
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列贪心）  
3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)（最大最小交替贪心）

---

### **个人心得摘录**  
- **ITZDC9**：通过拆分刀为两种攻击方式，避免复杂判断，但需注意数组索引管理。  
- **Mysterious_Cat**：误将最大挥砍刀的投掷排除，导致部分样例错误，需注意筛选条件。

---

### **可视化与算法演示**  
1. **动画设计**  
   - **可视化**：用柱状图表示每把刀的挥砍和投掷伤害，红色柱为投掷，蓝色为挥砍。  
   - **高亮操作**：当前选中的攻击方式（最大伤害）闪烁，投掷后柱状图变灰。  
   - **步进控制**：用户可单步执行，观察剩余血量变化。  
2. **复古像素风格**  
   - **Canvas绘制**：刀以像素方块表示，攻击时播放8位音效。  
   - **AI自动模式**：自动选择最大伤害攻击，背景音乐循环播放。  

**核心代码（动画片段）**  
```javascript
// 伪代码：绘制攻击选择动画
function drawAttack(attackType, damage) {
    ctx.fillStyle = attackType === 'throw' ? '#FF0000' : '#0000FF';
    ctx.fillRect(x, y, 30, damage); // 柱状图高度表示伤害
    playSound('attack.wav'); // 播放攻击音效
}
```

---

**总结**  
贪心策略通过排序和动态选择最优攻击方式，确保最小攻击次数。正确区分投掷和挥砍的优先级是解题关键，时间复杂度优化至 `O(n log n)`。

---
处理用时：346.26秒
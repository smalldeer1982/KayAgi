# 题目信息

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>```

### 输出

```
15```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G```

### 输出

```
-1```

# AI分析结果



---

## **算法分类**
**广度优先搜索（BFS）**

---

## **题解思路与核心难点**

### **核心思路**
1. **预处理视线区域**：遍历所有方向（东、南、西、北）的人，沿其视线方向标记所有可达的空格为不可通行区域，直到遇到障碍物或其他人。
2. **BFS最短路径**：从起点出发，通过BFS搜索最短路径，避开所有视线区域、障碍物和人的位置。

### **解决难点**
1. **视线预处理**：需正确模拟视线延伸逻辑，确保视线被障碍物或其他人阻挡时停止。
2. **高效标记**：每个格子最多被四个方向处理，总时间复杂度为 O(HW)，确保在 2000x2000 网格下可运行。
3. **边界检查**：遍历时必须先检查边界，避免数组越界。

---

## **题解评分（≥4星）**

1. **作者：ran_qwq（★★★★★）**
   - **亮点**：代码简洁，预处理逻辑清晰，BFS实现高效。
   - **关键代码**：
     ```cpp
     for (每个方向的人) {
         while (未越界且未被阻挡) 标记视线区域;
     }
     ```
   - **个人心得**：直接标记视线区域后BFS，无需复杂优化。

2. **作者：Dream_poetry（★★★★）**
   - **亮点**：将视线区域标记为特殊字符，简化BFS条件判断。
   - **关键代码**：
     ```cpp
     if (ch[i][j] == '>') {
         while (标记可视线区域为 '!');
     }
     ```
   - **个人心得**：通过符号替换简化逻辑，避免额外数组。

3. **作者：__Dist__（★★★★）**
   - **亮点**：使用 `step` 数组记录步数，结合队列实现标准BFS。
   - **关键代码**：
     ```cpp
     while (队列非空) {
         扩展四个方向，检查是否合法;
     }
     ```

---

## **最优思路提炼**
1. **视线标记技巧**：按方向遍历每个人的视线，直到阻挡，时间复杂度 O(HW)。
2. **BFS优化**：使用队列和距离数组，避免重复访问。
3. **边界优先检查**：在遍历视线或移动时，先判断是否越界，再处理逻辑。

---

## **同类题目推荐**
1. **洛谷 P1443 马的遍历**（BFS基础）
2. **洛谷 P1162 填涂颜色**（预处理+BFS）
3. **洛谷 P1126 机器人搬重物**（复杂移动规则+BFS）

---

## **可视化与算法演示**

### **动画设计**
1. **预处理阶段**：
   - 用不同颜色标记各方向视线（如红色箭头延伸）。
   - 遇到障碍物时显示阻挡效果（灰色方块）。
2. **BFS阶段**：
   - 队列扩展时高亮当前格子（绿色），新扩展格子（黄色）。
   - 最终路径回显（蓝色路径）。

### **复古像素风格**
- **颜色方案**：8-bit 调色板（红、绿、蓝、灰）。
- **音效**：移动时播放“滴”声，找到路径时播放胜利音效。
- **交互**：支持暂停/继续，速度调节。

### **核心代码片段（JavaScript）**
```javascript
// 预处理视线（示例：向右）
function markSight(grid, x, y) {
    let ny = y + 1;
    while (ny < cols && grid[x][ny] === '.') {
        grid[x][ny] = '!'; // 标记为视线区域
        ny++;
    }
}

// BFS 实现
function bfs(start, end, grid) {
    let queue = [start];
    let visited = Array(rows).fill().map(() => Array(cols).fill(false));
    visited[start.x][start.y] = true;
    while (queue.length > 0) {
        let curr = queue.shift();
        for (let dir of directions) {
            let nx = curr.x + dir[0], ny = curr.y + dir[1];
            if (isValid(nx, ny) && !visited[nx][ny] && grid[nx][ny] === '.') {
                // 更新动画和队列
            }
        }
    }
}
```

---

## **总结**
本题通过预处理视线区域和BFS的组合，高效解决复杂路径问题。关键点在于正确处理视线延伸和边界条件，确保时间与空间复杂度可控。

---
处理用时：217.40秒
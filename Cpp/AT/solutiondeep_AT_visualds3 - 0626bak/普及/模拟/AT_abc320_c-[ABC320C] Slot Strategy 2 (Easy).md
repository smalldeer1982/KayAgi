# 题目信息

# [ABC320C] Slot Strategy 2 (Easy)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc320/tasks/abc320_c

> この問題は G 問題の簡易版です。

$ 3 $ 個のリールからなるスロットがあります。  
 $ i $ 番目のリールの配列は文字列 $ S_i $ によって表されます。ここで、$ S_i $ は数字のみからなる長さ $ M $ の文字列です。

それぞれのリールには対応するボタンがついています。高橋君は各非負整数 $ t $ について、スロットが回り始めてからちょうど $ t $ 秒後にボタンを $ 1 $ つ選んで押す、または何もしないことができます。  
 スロットが回り始めてから $ t $ 秒後に $ i $ 番目のリールに対応するボタンを押すと、$ i $ 番目のリールは $ S_i $ の $ (t\ \bmod\ M)+1 $ 文字目を表示して止まります。  
 ただし、$ t\ \bmod\ M $ で $ t $ を $ M $ で割ったあまりを表します。

高橋君は全てのリールを止めた上で、表示されている文字が全て同じであるようにしたいです。  
 高橋君が目標を達成できるように全てのリールを止めるまでに、スロットが回り始めてから最小で何秒かかるかを求めてください。  
 そのようなことが不可能であればそのことを報告してください。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ 100 $
- $ M $ は整数
- $ S_i $ は数字のみからなる長さ $ M $ の文字列
 
### Sample Explanation 1

高橋君は次のようにそれぞれのリールを止めることでスロットが回り始めてから $ 6 $ 秒後にリールに表示される文字を `8` で揃えることができます。 - スロットの回転開始から $ 0 $ 秒後に $ 2 $ 番目のリールに対応するボタンを押します。$ 2 $ 番目のリールは $ S_2 $ の $ (0\ \bmod\ 10)+1=1 $ 文字目である `8` を表示して止まります。 - スロットの回転開始から $ 2 $ 秒後に $ 3 $ 番目のリールに対応するボタンを押します。$ 3 $ 番目のリールは $ S_3 $ の $ (2\ \bmod\ 10)+1=3 $ 文字目である `8` を表示して止まります。 - スロットの回転開始から $ 6 $ 秒後に $ 1 $ 番目のリールに対応するボタンを押します。$ 1 $ 番目のリールは $ S_1 $ の $ (6\ \bmod\ 10)+1=7 $ 文字目である `8` を表示して止まります。 $ 5 $ 秒以下で全てのリールに表示されている文字を揃える方法はないため、$ 6 $ を出力します。

### Sample Explanation 2

全てのリールを止めた上で、表示されている文字を揃える必要がある事に注意してください。

### Sample Explanation 3

表示されている文字が全て同じであるようにリールを止めることはできません。 このとき `-1` を出力してください。

## 样例 #1

### 输入

```
10

1937458062

8124690357

2385760149```

### 输出

```
6```

## 样例 #2

### 输入

```
20

01234567890123456789

01234567890123456789

01234567890123456789```

### 输出

```
20```

## 样例 #3

### 输入

```
5

11111

22222

33333```

### 输出

```
-1```

# AI分析结果



## 唯一算法分类  
**暴力枚举**

---

## 综合分析与结论  
### 核心思路  
题目要求在三个循环转盘中选择不同的停止时间，使得显示数字相同且时间互异。所有题解均采用暴力枚举思路，通过以下两个核心优化点处理循环特性：  
1. **字符串复制策略**：将每个转盘字符串复制 3 次，模拟转动 3 圈的场景（最坏情况需转 3 圈才能对齐）  
2. **独立时间枚举**：遍历三个转盘的所有可能停止时间组合，检查是否满足条件（数字相同且时间互异）  

### 算法流程  
1. 预处理：将每个字符串复制 3 次，形成 3M 长度的新字符串  
2. 三重循环枚举三个转盘的停止时间点 i, j, k  
3. 检查条件：`a[i] == b[j] == c[k]` 且 `i != j != k`  
4. 记录满足条件的 `max(i, j, k)` 的最小值  

### 可视化设计  
**复古像素动画方案**：  
- **Canvas 网格**：三个转盘纵向排列，每个转盘以 8x8 像素块表示当前显示字符  
- **时间轴**：底部横向时间轴，用不同颜色标记三个按钮的触发时间点  
- **高亮逻辑**：  
  - 遍历到 (i,j,k) 时，转盘 1 的 i%M 位置、转盘 2 的 j%M 位置、转盘 3 的 k%M 位置闪烁黄色边框  
  - 命中有效解时，三个对应位置变为绿色，并播放「成功音效」  
- **音效设计**：  
  - 每次循环步进时播放「滴答」音效  
  - 找到更优解时播放「金币收集」音效  
  - 最终答案出现时播放「胜利小号」音效  

---

## 题解清单（≥4星）  
### 1. 作者：2c_s（5星）  
**亮点**：  
- 代码最简洁，直接复制字符串后三重循环  
- 时间复杂度 O((3M)^3) 但常数极小，实测运行速度极快  
- 通过 `max({i,j,k})` 优雅处理时间最大值  

### 2. 作者：kimidonatsu（4星）  
**亮点**：  
- 使用模运算直接处理循环特性，避免复制字符串  
- 代码中 `% M` 操作清晰体现转盘循环逻辑  

### 3. 作者：Dream_poetry（4星）  
**亮点**：  
- 变量命名与注释简洁，`max({i,j,k})` 写法与 2c_s 类似  
- 明确说明复制字符串的数学依据  

---

## 最优思路与代码实现  
### 关键技巧  
1. **循环覆盖策略**：通过复制字符串 3 次，将无限循环问题转化为有限区间枚举  
2. **时间独立验证**：允许不同转盘在不同周期停止，只需保证字符位置对齐  

### 核心代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, ans = 1e9;
string a, b, c;
int main() {
    cin >> n >> a >> b >> c;
    a = a + a + a;  // 复制3次覆盖3圈转动
    b = b + b + b;
    c = c + c + c;
    n *= 3;  // 新字符串长度
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            for (int k = 0; k < n; ++k)
                if (a[i] == b[j] && b[j] == c[k] && i != j && j != k && i != k)
                    ans = min(ans, max({i, j, k}));
    cout << (ans == 1e9 ? -1 : ans);
    return 0;
}
```

---

## 相似题目推荐  
1. **P1031 [NOIP2002 提高组] 均分纸牌**（多对象平衡问题）  
2. **P1217 [USACO1.5] 回文质数**（循环与条件验证）  
3. **P1518 [USACO2.4] 两只塔姆沃斯牛**（循环坐标追踪）  

---

## 个人心得摘录  
> "复制字符串三次的灵感来源于最坏情况下每个数字仅出现一次且位置相同。此时必须转满 3 圈才能对齐，这是数学归纳的典型应用。" —— 作者：2c_s  

---

## 可视化算法演示  
### 动画控制逻辑  
```javascript
// 伪代码示例：Canvas 绘制与音效触发
function drawFrame(i, j, k) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制三个转盘，高亮当前检查的位置
    drawReel(1, i % M, a[i % M], "#FF0");
    drawReel(2, j % M, b[j % M], "#FF0");
    drawReel(3, k % M, c[k % M], "#FF0");
    // 播放步进音效
    beep(800, 0.1);
}

function checkValid(i, j, k) {
    if (a[i] === b[j] && b[j] === c[k] && i !== j && j !== k) {
        // 高亮成功状态
        drawReel(1, i % M, a[i % M], "#0F0");
        drawReel(2, j % M, b[j % M], "#0F0");
        drawReel(3, k % M, c[k % M], "#0F0");
        playSuccessSound();
        return true;
    }
    return false;
}
```

### 复古风格设计  
- **调色板**：使用 NES 经典 8 色（黑、白、红、蓝、绿、黄、紫、青）  
- **像素字体**：8x8 等宽字体渲染数字  
- **背景音乐**：循环播放《超级马里奥》地下关 BGM 的 8 位改编版

---
处理用时：73.37秒
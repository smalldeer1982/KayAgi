# 题目信息

# [ABC320E] Somen Nagashi

## 题目描述

现有 $N$ 个人排成一队，编号从 $1$ 到 $N$，玩一个叫做“流水面条”的游戏，该游戏共有 $M$ 个事件，每个事件含三个变量 $T_i,W_i,S_i$，事件的规则如下：

- 在 $T_i$ 时刻，有 $W_i$ 根面条流了下来，队头的人拿走这些面条，并离开队列，然后于第 $T_i+S_i$ 时刻返回队列，然后返回他的原始位置。

若队列为空，则该事件忽略。

注意：若他于第 $X$ 时刻返回队列，则视为他第 $X$ 时刻在队列。

一开始每个人都有 $0$ 根面条，现要你求出这 $N$ 个人每个人获得了多少面条。

## 说明/提示

#### 样例#1说明：
第 $1$ 个人于 $1$ 时刻拿走 $1$ 根面条，将于 $4$ 时刻返回队列。

第 $2$ 个人于 $2$ 时刻拿走 $10$ 根面条，将于 $102$ 时刻返回队列。

第 $1$ 个人于 $4$ 时刻归队，返回第 $1$ 位，此时他处于队头，然后拿走 $100$ 根面条，将于 $10004$ 时刻返回队列。

第 $3$ 个人于 $10$ 时刻拿走 $1000$ 根面条，将于第 $1000000010$ 时刻归队。

第 $100$ 时刻，队内无人。

最终，这 $3$ 个人分别有 $101,10,1000$ 根面条。

## 样例 #1

### 输入

```
3 5

1 1 3

2 10 100

4 100 10000

10 1000 1000000000

100 1000000000 1```

### 输出

```
101

10

1000```

## 样例 #2

### 输入

```
3 1

1 1 1```

### 输出

```
1

0

0```

## 样例 #3

### 输入

```
1 8

1 1 1

2 2 2

3 3 3

4 4 4

5 5 5

6 6 6

7 7 7

8 8 8```

### 输出

```
15```

# AI分析结果



## 唯一算法分类  
**优先队列（堆）**

---

## 综合分析与结论  
### 核心思路与解决难点  
1. **双队列管理**：  
   - **可用队列**：维护当前可分配面条的人员编号（小根堆按编号排序）。  
   - **返回队列**：维护暂时离开的人员返回时间和编号（小根堆按时间排序）。  
   - 每次处理事件前，将所有返回时间≤当前时间的离队人员重新加入可用队列。  
   - 确保同一时间下，返回事件优先于面条事件（通过堆排序实现）。  

2. **事件驱动模拟**：  
   - 将每个面条事件和返回事件统一视为事件流，按时间顺序处理。  
   - 同一时间的事件，优先处理返回事件以保证队列状态的及时更新。  

### 可视化设计思路  
- **动画方案**：  
  1. **双队列面板**：左侧显示可用队列（绿色高亮队首），右侧显示返回队列（红色标记最早返回时间）。  
  2. **事件触发**：当前处理的事件（如时间T=5的面条事件）以黄色闪烁显示，触发时展示队首人员被选中。  
  3. **状态变化**：  
     - 离队时：将人员从可用队列移至返回队列，并标注返回时间。  
     - 归队时：将人员从返回队列移回可用队列的原位置（编号插入）。  
  4. **步进控制**：允许单步执行观察队列变化，支持调整动画速度。  

- **复古像素风格**：  
  - **颜色方案**：绿色方块（可用队列）、红色方块（返回队列）、黄色高亮（当前事件）。  
  - **音效**：  
    - 关键操作（分配面条）播放“叮”声，归队播放“咔”声。  
    - 背景音乐为8-bit循环旋律，营造游戏闯关氛围。  

---

## 题解清单（评分≥4星）  
1. **robertuu（5星）**  
   - **亮点**：代码简洁，事件统一为结构体，利用优先队列的排序特性处理时间优先级。  
   - **关键代码**：  
     ```cpp  
     priority_queue<noddle> q; // 事件队列（时间+类型）  
     priority_queue<int, ..., greater<int>> l; // 可用队列（小根堆）  
     ```  
   - **心得**：通过将返回事件的`s`设为0，巧妙实现同一时间下归队优先。  

2. **Zkl21（4星）**  
   - **亮点**：明确分离“可用队列”与“返回队列”，逻辑清晰。  
   - **关键代码**：  
     ```cpp  
     priority_queue<int> available; // 可用队列  
     priority_queue<pair<int, int>> returning; // 返回队列  
     ```  

3. **OldDriverTree（4星）**  
   - **亮点**：直接使用STL优先队列，变量命名易理解。  
   - **关键代码**：  
     ```cpp  
     while (!q.empty() && q.top().first <= t) { // 处理归队  
         p.push(q.top().second);  
         q.pop();  
     }  
     ```  

---

## 最优思路提炼  
1. **双堆维护状态**：  
   - 一个堆管理当前可用人员（编号最小优先）。  
   - 一个堆管理离队人员返回时间（时间最早优先）。  
2. **事件优先级处理**：同一时间下，先处理归队再处理面条分配。  

---

## 同类型题与算法套路  
- **通用解法**：涉及时间驱动和资源分配的问题，优先队列模拟事件流是典型解法。  
- **类似题目**：  
  1. **CF727C：Guards**（时间调度与资源分配）  
  2. **CF1070C：Cloud Computing**（多事件优先队列处理）  

---

## 推荐相似题目  
1. **P7078 [CSP-J2020] 优秀的拆分**（优先队列模拟）  
2. **P2085 最小函数值**（双堆维护极值）  
3. **P1168 中位数**（动态维护序列中的中位数，堆的灵活使用）  

---

## 核心代码实现  
```cpp  
#include <bits/stdc++.h>  
using namespace std;  
struct Event {  
    int t, w, type; // type=0:归队, type=1:面条  
    int id;  
    bool operator<(const Event& e) const {  
        return t == e.t ? type > e.type : t > e.t;  
    }  
};  
priority_queue<Event> events;  
priority_queue<int, vector<int>, greater<int>> available;  

long long ans[200005];  
int main() {  
    int n, m;  
    cin >> n >> m;  
    for (int i = 1; i <= m; ++i) {  
        int t, w, s;  
        cin >> t >> w >> s;  
        events.push({t, w, 1, s});  
    }  
    for (int i = 1; i <= n; ++i) available.push(i);  

    while (!events.empty()) {  
        auto e = events.top();  
        events.pop();  
        if (e.type == 0) {  
            available.push(e.id);  
        } else {  
            while (!events.empty() && events.top().t == e.t &&  
                   events.top().type == 0) {  
                auto ret = events.top();  
                events.pop();  
                available.push(ret.id);  
            }  
            if (!available.empty()) {  
                int u = available.top();  
                available.pop();  
                ans[u] += e.w;  
                events.push({e.t + e.id, 0, 0, u});  
            }  
        }  
    }  
    for (int i = 1; i <= n; ++i) cout << ans[i] << "\n";  
}  
```  

---

## 可视化与游戏化实现方案  
- **Canvas动画**：  
  1. **网格绘制**：每行代表一个人员编号，绿色填充表示在队列中。  
  2. **事件触发**：当前时间线以红色竖条标记，面条事件时队首人物闪烁。  
  3. **归队效果**：离队人员变为灰色，归队时恢复绿色并跳回原位。  

- **音效与积分**：  
  - **得分机制**：每分配一次面条+10分，连续正确处理事件触发连击奖励。  
  - **音效触发**：  
    - `ans[u] += w`时播放硬币音效；  
    - 错误操作（如空队列处理）播放警告音。  

- **自动演示模式**：  
  ```javascript  
  function autoPlay() {  
      let speed = 500; // 毫秒/步  
      const timer = setInterval(() => {  
          if (!nextStep()) clearInterval(timer);  
      }, speed);  
  }  
  ```

---
处理用时：94.31秒
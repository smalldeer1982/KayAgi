# 题目信息

# ヘイホー君と最終試験

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2015-morning-easy/tasks/cf_2015_morning_easy_c

Codefes大学の競技プログラミングの授業では、成績評価のために、$ N $ 回の試験を行うことにしています。 各試験での成績は、$ 0 $ 以上 $ M $ 以下の整数値です。 $ N $ 個の試験成績のうち、上位 $ K $ 個の平均が $ R $ 点以上であれば、めでたく単位が認定されます。 上位 $ K $ 個の平均が $ R $ 点未満の場合には不合格となり、単位は認定されません。

$ N-1 $ 回の試験を終えたヘイホー君は、最終試験に臨もうとしています。 最終試験を除く $ N-1 $ 回の試験におけるヘイホー君の成績は、それぞれ $ S_1 $, $ S_2 $, …, $ S_{N-1} $ 点でした。 ヘイホー君は、最終試験で何点以上取れば単位が認定されるでしょうか？

## 说明/提示

### Sample Explanation 1

ヘイホー君が最終試験で $ 45 $ 点を取った場合、上位 $ 3 $ 個の平均は $ (86+49+45)/3=60 $ となり、単位が認定されます。 もちろん、$ 46 $ 点以上取っても単位は認定されます。 一方、$ 44 $ 点以下の場合には単位が認定されません。

### Sample Explanation 2

最終試験で $ 0 $ 点でも単位が認定されます。

### Sample Explanation 3

残念ながら、最終試験が満点でも単位は認定されません。

### Sample Explanation 4

大きな数が入力されることもあります。オーバーフローに注意しましょう。

## 样例 #1

### 输入

```
5 3 100 60

86

23

49

39```

### 输出

```
45```

## 样例 #2

### 输入

```
5 3 100 60

92

100

95

99```

### 输出

```
0```

## 样例 #3

### 输入

```
5 3 100 60

18

42

29

31```

### 输出

```
-1```

## 样例 #4

### 输入

```
13 10 1000000000 645245296

492014535

611893452

729291030

392019922

293849201

474839528

702912832

341845861

102495671

908590572

812912432

129855439```

### 输出

```
986132796```

# AI分析结果



**唯一算法分类**: 贪心

---

### 综合分析与结论

**题目核心思路**  
本题要求确定最后一次考试的最小分数，使得所有考试中分数最高的前 K 次的平均分不低于 R。核心思路是：  
1. **排序优化**：将已有的成绩降序排列，取前 K 个的和。  
2. **替换策略**：若当前和不足，最后一次考试分数需替换前 K 个中的最小值，从而推导出所需分数。  
3. **边界处理**：特别处理 K=N 的情况，此时所有考试成绩必须被选中。

**关键难点与解决方案**  
- **排序范围错误**：部分题解在排序时未正确处理输入数据范围，导致未初始化元素参与排序。正确应仅排序输入的 N-1 个成绩。  
- **K=N 的特殊情况**：当 K=N 时，必须包含所有已有成绩和最后一次考试的成绩，单独计算总和。  
- **溢出问题**：使用 `long long` 避免大数运算溢出。

---

### 题解评分 (≥4星)

**4星题解**  
1. **Fozz_1024**  
   - **亮点**：正确排序已有成绩，处理 K ≤ N-1 的情况，代码清晰。  
   - **缺点**：未处理 K=N 的情况，可能导致数组越界。  
   ```cpp
   sort(s +1, s +n +1);  // 正确排序范围
   for (int i = n; i >=n -k +1; i--) sum += s[i];
   ```

2. **BZHZS**  
   - **亮点**：避免浮点运算，直接比较总分，逻辑简洁。  
   - **缺点**：未处理 K=N 时的总和计算错误。  
   ```cpp
   if (sum + a[k] >= f) puts("0");
   else if (sum + m < f) puts("-1");
   ```

3. **hyc1026**  
   - **亮点**：正确实现贪心策略，代码可读性高。  
   - **缺点**：未处理 K=N 的边界情况。  
   ```cpp
   sort(a+1, a +n, cmp);  // 正确排序范围
   sum = sum_existing + m;
   ```

---

### 最优思路与代码

**核心逻辑**  
1. 将已有成绩降序排序，计算前 K 大的和。  
2. 若和足够，输出 0；否则，计算替换最小值后的所需分数。  
3. 特别处理 K=N 的情况，直接计算总分需求。

**正确代码实现**  
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int a[100005];

signed main() {
    int n, k, m, r;
    cin >> n >> k >> m >> r;
    for (int i = 1; i < n; i++) cin >> a[i];
    
    if (k == n) {
        int sum = accumulate(a + 1, a + n, 0LL);
        int need = n * r - sum;
        if (need <= 0) cout << 0;
        else if (need > m) cout << -1;
        else cout << need;
        return 0;
    }

    sort(a + 1, a + n, greater<int>());
    int sum = 0, min_k = 0;
    for (int i = 1; i <= k; i++) {
        sum += a[i];
        min_k = a[i];
    }
    if (sum >= k * r) {
        cout << 0;
        return 0;
    }
    sum -= min_k;
    int need = k * r - sum;
    if (need > m) cout << -1;
    else cout << max(0LL, need);
    return 0;
}
```

---

### 可视化与算法演示

**动画设计**  
1. **排序过程**：将成绩以降序排列，高亮前 K 个元素。  
2. **替换最小值**：标记前 K 个中的最小值，动态替换为最后一次考试分数。  
3. **总分计算**：实时显示当前总分与目标分对比。  

**复古像素风格**  
- **颜色标记**：红色表示不足，绿色表示达标。  
- **音效**：成功达标时播放 8-bit 胜利音效，失败时短促提示音。  
- **Canvas 动态更新**：成绩列表以网格展示，每次操作后刷新。  

---

### 类似题目推荐
1. **洛谷 P1093** - 奖学金（排序与贪心）  
2. **洛谷 P1223** - 排队接水（最小化平均等待时间）  
3. **洛谷 P1012** - 拼数（贪心排序策略）

---
处理用时：399.00秒
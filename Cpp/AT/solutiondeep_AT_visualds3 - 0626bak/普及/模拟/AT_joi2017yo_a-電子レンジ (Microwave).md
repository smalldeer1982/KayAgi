# 题目信息

# 電子レンジ (Microwave)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2017yo/tasks/joi2017yo_a

JOI 君は食事の準備のため，$ A $ ℃の肉を電子レンジで $ B $ ℃まで温めようとしている．肉は温度が $ 0 $ ℃未満のとき凍っている．また，温度が $ 0 $ ℃より高いとき凍っていない．温度がちょうど $ 0 $ ℃のときの肉の状態は，凍っている場合と，凍っていない場合の両方があり得る．

JOI 君は，肉の加熱にかかる時間は以下のようになると仮定して，肉を温めるのにかかる時間を見積もることにした．

- 肉が凍っていて，その温度が $ 0 $ ℃より小さいとき： $ C $ 秒で $ 1 $ ℃温まる．
- 肉が凍っていて，その温度がちょうど $ 0 $ ℃のとき： $ D $ 秒で肉が解凍され，凍っていない状態になる．
- 肉が凍っていないとき： $ E $ 秒で $ 1 $ ℃温まる．

この見積もりにおいて，肉を $ B $ ℃にするのに何秒かかるかを求めよ．

- - - - - -

## 说明/提示

### Sample Explanation 1

入出力例 $ 1 $ では，もともとの肉は $ -10 $ ℃で凍っている．かかる時間は以下のようになる． - $ -10 $ ℃から $ 0 $ ℃まで温めるのに $ 5\ \times\ 10\ =\ 50 $ 秒． - $ 0 $ ℃の肉を解凍するのに $ 10 $ 秒． - $ 0 $ ℃から $ 20 $ ℃まで温めるのに $ 3\ \times\ 20\ =\ 60 $ 秒． したがって，かかる時間の合計は $ 120 $ 秒である． - - - - - -

### Sample Explanation 2

入出力例 $ 2 $ では，もともとの肉は凍っていない．したがって，肉を $ 35 $ ℃から $ 92 $ ℃まで温めるのにかかる時間は $ 627 $ 秒である．

## 样例 #1

### 输入

```
-10
20
5
10
3```

### 输出

```
120```

## 样例 #2

### 输入

```
35
92
31
50
11```

### 输出

```
627```

# AI分析结果



### 唯一算法分类
模拟/条件判断

---

### 题解思路与算法要点

#### 核心逻辑
题目需要分三种情况处理：
1. **初始温度 A < 0**  
   - 若目标温度 B ≤ 0：仅需用冻结状态加热速率 `C`，时间为 `(B - A) * C`  
   - 若目标温度 B > 0：需计算冻结加热到0度的时间 `|A|*C` + 解冻时间 `D` + 解冻后加热到 B 的时间 `B*E`  
2. **初始温度 A = 0**  
   - 直接解冻时间 `D` + 解冻后加热时间 `B*E`  
3. **初始温度 A > 0**  
   - 直接计算解冻后加热时间 `(B - A)*E`  

#### 解决难点
- **关键条件判断**：需明确区分 A 的初始状态（冻结/解冻）和目标 B 的位置（是否跨过0度）  
- **数学公式推导**：通过分段计算避免逐度模拟，提升效率  

---

### 题解评分 (≥4星)
1. **Zenith_Yeh (5星)**  
   - 全面覆盖所有情况，代码逻辑清晰  
   - 使用四段式条件判断，处理边界值（如 A=0）  
   - 通过 `abs` 简化计算，代码可读性高  

2. **rui_er (5星)**  
   - 三类条件判断覆盖所有可能  
   - 代码简洁，直接公式计算，无冗余步骤  
   - 提供 Python 和 C++ 双版本实现  

3. **政凯 (4星)**  
   - 正确分情况，利用 `min/max` 简化条件  
   - 变量命名可优化，但逻辑正确  
   - 使用全局变量默认初始值巧妙处理边界  

---

### 最优思路与技巧
1. **分治策略**  
   - 将问题拆解为冻结区、解冻点、解冻后区三个部分，分别计算时间  
2. **数学公式代替逐度模拟**  
   - 直接通过差值计算总时间，避免低效循环（如 `(B - A) * C`）  
3. **边界处理技巧**  
   - 利用 `abs` 处理负数温度差，`min/max` 处理跨区段温度  

---

### 核心代码实现
```cpp
// Zenith_Yeh 的代码（最优实现）
#include<bits/stdc++.h>
using namespace std;
int main() {
    int a=read(),b=read(),c=read(),d=read(),e=read(),ans;
    if(a<0) {
        if(b<=0) ans=(b-a)*c;
        else ans=abs(a)*c + d + b*e;
    } else {
        if(a==0) ans=d + b*e;
        else ans=(b-a)*e;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

### 同类型题推荐
1. **P1042 乒乓球**（模拟比赛计分规则）  
2. **P1424 小鱼的航程**（分段计算时间）  
3. **P1055 ISBN号码**（条件判断与校验）  

---

### 可视化设计
1. **动画流程**  
   - **阶段1**（冻结区）：红色高亮温度从 A 到 0，显示 `|A|*C` 计算  
   - **阶段2**（解冻点）：黄色闪烁显示解冻操作，标记 `+D`  
   - **阶段3**（解冻后区）：蓝色渐变温度从 0 到 B，显示 `B*E` 计算  

2. **复古像素风格**  
   - **温度条**：8-bit 风格温度条，分冻结（冰蓝色）和解冻（橙色）两段  
   - **音效**：加热时播放 "哔" 声，解冻时播放 "咔嚓" 声，完成时播放胜利音效  

3. **交互控制**  
   - 速度滑块调节动画步进速度  
   - 手动模式下按空格键分步执行  

---

### 个人心得摘录
- **Zenith_Yeh**：注意当 A=0 时必须单独处理解冻步骤  
- **政凯**：利用 `min(b,0)` 巧妙处理冻结区终点  
- **rui_er**：通过三类条件覆盖所有可能，避免冗余判断  

---

### 总结
本题通过细致的状态划分和数学公式计算，避免了低效的逐度模拟。关键点在于正确处理跨0度的情况，并通过分段公式直接计算结果。最优解法时间复杂度为 O(1)，空间复杂度 O(1)，完美覆盖所有边界情况。

---
处理用时：173.90秒
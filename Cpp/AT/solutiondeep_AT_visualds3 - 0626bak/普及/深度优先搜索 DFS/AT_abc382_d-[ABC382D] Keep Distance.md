# 题目信息

# [ABC382D] Keep Distance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_d

整数 $ N $ と $ M $ が与えられます。

以下の条件をすべて満たす長さ $ N $ の整数列 $ (A_1,\ A_2,\ \ldots,\ A_N) $ を辞書順にすべて出力してください。

- $ 1\ \leq\ A_i $
- $ 2 $ 以上 $ N $ 以下の各整数 $ i $ に対して $ A_{i\ -\ 1}\ +\ 10\ \leq\ A_i $
- $ A_N\ \leq\ M $
 
  数列の辞書順とは長さ $ N $ の数列 $ S\ =\ (S_1,\ S_2,\ \ldots,\ S_N) $ が長さ $ N $ の数列 $ T\ =\ (T_1,\ T_2,\ \ldots,\ T_N) $ より**辞書順で小さい**とは、ある整数 $ 1\ \leq\ i\ \leq\ N $ が存在して下記の $ 2 $ つがともに成り立つことをいいます。

- $ (S_1,\ S_2,\ \ldots,\ S_{i-1})\ =\ (T_1,\ T_2,\ \ldots,\ T_{i-1}) $
- $ S_i $ が $ T_i $ より（数として）小さい。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 12 $
- $ 10N\ -\ 9\ \leq\ M\ \leq\ 10N $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (1,\ 11,\ 21),\ (1,\ 11,\ 22),\ (1,\ 11,\ 23),\ (1,\ 12,\ 22),\ (1,\ 12,\ 23),\ (1,\ 13,\ 23),\ (2,\ 12,\ 22),\ (2,\ 12,\ 23),\ (2,\ 13,\ 23),\ (3,\ 13,\ 23) $ の $ 10 $ 個の数列が条件を満たします。

## 样例 #1

### 输入

```
3 23```

### 输出

```
10

1 11 21

1 11 22

1 11 23

1 12 22

1 12 23

1 13 23

2 12 22

2 12 23

2 13 23

3 13 23```

# AI分析结果



## 算法分类
DFS

---

### 题解思路与解决难点
**核心思路**：DFS + 剪枝。通过递归生成满足递增条件的序列，关键剪枝条件是当前元素加上后续最小增量（10 * 剩余元素数）不能超过 m。

**解决难点**：
1. **字典序生成**：DFS 按从小到大的顺序枚举每个位置的候选值，自然满足字典序。
2. **剪枝优化**：每个位置的上界由 `m - 10*(n-pos)` 确定，避免无效分支。
3. **初始条件处理**：第一个元素的起始值设为 1，后续元素起始值为前驱+10。

**算法要点**：
- **搜索起点**：第一个元素从 1 开始枚举，后续元素从前驱+10 开始。
- **剪枝条件**：`a[i] + 10*(n-i) ≤ m`，确保后续元素有足够空间。
- **数据结构**：使用数组暂存当前路径，递归结束时保存结果。

---

### 题解评分（≥4星）
1. **ThomasNO1 (★★★★☆)**  
   - 思路清晰，剪枝条件明确。初始化 `a[0]=-9` 巧妙处理起始条件。  
   - 代码简洁，可读性强，适合学习DFS基础实现。

2. **Zskioaert1106 (★★★★☆)**  
   - 直接枚举每个位置的候选值，剪枝条件 `i + (n-x)*10 <= m` 正确高效。  
   - 使用二维数组存储结果，输出逻辑清晰。

3. **hjyowl (★★★★☆)**  
   - 剪枝条件 `a[u] + (n-u)*10 ≤ m` 与主流解法一致。  
   - 代码结构简洁，全局数组存储结果，适合快速实现。

---

### 最优思路提炼
**关键技巧**：
1. **剪枝公式**：当前元素的上界为 `m - 10*(剩余元素数)`。
2. **字典序生成**：DFS 按升序枚举候选值，天然保证结果有序。
3. **差分转换**（_zqh_ 题解）：将原序列转换为差分数组，问题转化为调整增量之和，减少状态维度。

**代码片段**：
```cpp
// ThomasNO1 的核心剪枝逻辑
void dfs(int pos) {
    if (pos > n) { 保存结果; return; }
    for (int i = a[pos-1]+10; i <= m - 10*(n-pos); i++) {
        a[pos] = i;
        dfs(pos+1);
    }
}
```

---

### 类似题目推荐
1. **P1706 全排列问题** - 基础DFS生成排列
2. **P1036 选数** - 组合数+质数判断
3. **P1019 单词接龙** - DFS+剪枝优化

---

### 可视化设计
**动画方案**：
1. **像素风格节点**：每个序列位置显示为彩色方块，当前选择的值高亮显示。
2. **剪枝提示**：当分支被剪掉时，显示红色叉号并播放低沉音效。
3. **递归树展示**：左侧面板显示递归树，当前路径用黄色线条连接。

**交互功能**：
- **步进控制**：按钮控制单步执行/自动播放。
- **音效反馈**：
  - 访问节点：8-bit "beep" 音效
  - 找到解：胜利音效（类似《超级马里奥》吃金币）
  - 剪枝：短促错误音

**复古风格**：
- **调色板**：使用NES的经典蓝、绿、红色调。
- **背景音乐**：循环播放《塞尔达传说》风格8-bit音乐。

---

### 核心代码（ThomasNO1 实现）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=0,a[13];
vector<int> A;

void dfs(int pos){
    if(pos > n){
        for(int i=1;i<=n;i++) A.push_back(a[i]);
        ans++; A.push_back(-1); return;
    }
    for(int i=a[pos-1]+10; i <= m - 10*(n-pos); i++){
        a[pos] = i;
        dfs(pos+1);
    }
}

int main(){
    scanf("%d%d",&n,&m);
    a[0] = -9; // 关键初始化
    dfs(1);
    printf("%d\n",ans);
    for(auto x : A){
        if(x == -1) printf("\n");
        else printf("%d ",x);
    }
    return 0;
}
```

---
处理用时：58.15秒
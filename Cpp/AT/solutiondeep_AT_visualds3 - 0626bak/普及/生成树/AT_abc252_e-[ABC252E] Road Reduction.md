# 题目信息

# [ABC252E] Road Reduction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc252/tasks/abc252_e

AtCoder 王国には都市 $ 1,2,\ldots,N $ の $ N $ 個の都市と、道路 $ 1,2,\ldots,M $ の $ M $ 本の道路があります。  
道路 $ i $ は都市 $ A_i $ と $ B_i $ を双方向に結び、距離は $ C_i $ です。  
どの都市間もいくつかの道路を通って行き来することができます。

財政難である王国は、どの都市間もいくつかの道路を通って行き来できるという条件を満たすように $ N-1 $ 本の道路を保守し、それ以外の道路を廃道にすることにしました。

保守する道路のみを通って都市 $ 1 $ から都市 $ i $ へ移動するときの距離を $ d_i $ とするとき、保守する道路の選び方であって、$ d_2+d_3+\ldots+d_N $ を最小化するようなものを $ 1 $ つ出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- $ i\neq\ j $ のとき、$ (A_i,B_i)\neq(A_j,B_j) $
- $ 1\leq\ C_i\ \leq\ 10^9 $
- どの都市間もいくつかの道路を通って行き来することができる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

保守する道路の選び方と $ d_i $ の値は次のようになります。 - 道路 $ 1,2 $ を保守するとき、$ d_2=1 $, $ d_3=3 $ - 道路 $ 1,3 $ を保守するとき、$ d_2=1 $, $ d_3=10 $ - 道路 $ 2,3 $ を保守するとき、$ d_2=12 $, $ d_3=10 $ よって、道路 $ 1,2 $ を保守するときに $ d_2+d_3 $ が最小になります。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 2
1 3 10```

### 输出

```
1 2```

## 样例 #2

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 1
2 4 1
3 4 1```

### 输出

```
3 1 2```

# AI分析结果



---

**唯一算法分类**：最短路径树（Dijkstra 算法）

---

### **综合分析与结论**

#### **核心思路**
题目要求构造一棵生成树，使得从节点 1 到其他所有节点的路径距离之和最小。通过分析可知，这等价于构建一棵以节点 1 为根的**最短路径树**。所有题解均基于以下核心逻辑：  
1. **Dijkstra 算法**：计算节点 1 到所有节点的最短距离，并在松弛过程中记录每个节点被最后一次更新的边。  
2. **边选择**：每个节点（除根节点）的父边即为最短路径树中的边，这些边的编号构成答案。

#### **解决难点**
- **生成树性质**：需证明 Dijkstra 松弛过程中记录的边形成一棵树。由于每个节点仅被最后一次松弛的边更新，且总边数为 \(N-1\)，因此构成树结构。  
- **边编号处理**：双向边存储时需统一编号（如链式前向星中正反边共享原边编号）。  
- **性能优化**：使用优先队列的 Dijkstra 实现，时间复杂度 \(O(M \log N)\)，适用于题目约束的 \(N, M \leq 2 \times 10^5\)。

#### **可视化设计**
- **动画流程**：  
  1. **初始化**：以像素网格表示城市，边用线条连接，初始颜色为灰色。  
  2. **Dijkstra 执行**：高亮当前处理的节点（如红色），遍历其邻边时显示为黄色。  
  3. **松弛成功**：若某边被选中更新距离，将其标记为绿色并记录编号。  
  4. **生成树展示**：最终以蓝色高亮所有选中边的路径。  
- **交互功能**：支持暂停/继续、单步执行、速度调节。  
- **复古风格**：使用 8-bit 像素字体，边更新时播放「滴」声，完成时播放「通关」音效。

---

### **题解清单（评分≥4星）**

1. **xixiyan（4.5星）**  
   - **亮点**：链式前向星实现，明确处理双向边编号，代码结构清晰。  
   - **代码片段**：松弛时直接记录边编号到 `ans[y] = W[i].num`。  
   - **心得**：强调开 `long long`，避免溢出。

2. **ChuYilin2011（4星）**  
   - **亮点**：理论分析最短路径树性质，解释生成树必然性。  
   - **代码片段**：使用 `vector<node>` 存边，松弛时更新父边 `ans[v] = G[u][i].id`。

3. **FL_sleake（4星）**  
   - **亮点**：代码简洁，注释明确，通过 `vis` 数组过滤已处理节点。  
   - **关键逻辑**：优先队列中存储 `{v, dis[v]}`，保证每次取出最小距离节点。

---

### **最优思路与技巧**

#### **关键步骤**
- **Dijkstra 松弛记录边**：在每次成功松弛 `dis[v] = dis[u] + w` 时，记录该边编号到 `ans[v]`。  
- **双向边处理**：存储双向边时保持同一编号（如链式前向星中正反边共享 `num`）。

#### **代码实现**
```cpp
// 松弛过程核心代码（xixiyan 题解）
if (dis[y] > dis[d] + W[i].w) {
    dis[y] = dis[d] + W[i].w;
    ans[y] = W[i].num; // 记录边编号
    o_o.push((qwq){dis[y], y});
}
```

---

### **同类型题与算法套路**

- **通用解法**：最短路径树问题均可通过 Dijkstra/BFS 记录父边实现。  
- **类似题目**：  
  1. **洛谷 P4779**：标准单源最短路径（需输出距离，非边编号）。  
  2. **洛谷 P3371**：单源最短路径模板题。  
  3. **Codeforces 1005E2**：隐含最短路径树性质的中等题。

---

### **推荐题目**
1. **P4779** 【模板】单源最短路径（标准 Dijkstra 应用）。  
2. **ABC235E** （最短路径树边选择变种）。  
3. **POJ 3169** （差分约束与最短路径结合）。

---

### **个人心得摘录**
- **xixiyan**：链式前向星中正反边共享原边编号，避免重复计数。  
- **FFTotoro**：在优先队列中需跳过已处理的节点（`if(f>d[e])continue`），否则超时。  
- **Ascnbeta**：Dijkstra 的每个节点一旦确定最短距离，其父边即固定，形成树结构。

---

### **可视化与算法演示（核心逻辑）**

#### **动画伪代码**
```javascript
// 初始化
let cities = 绘制网格节点(1, 2, ..., N);
let edges = 绘制所有边(Ai, Bi)为灰色;
let selectedEdges = [];

// Dijkstra 执行
while (!priorityQueue.isEmpty()) {
    let u = 取出队列最小距离节点;
    if (u 已处理) continue;
    高亮u为红色;
    for (邻边 e : u 的邻接边) {
        let v = e.另一端;
        高亮e为黄色;
        if (dis[u] + e.w < dis[v]) {
            dis[v] = dis[u] + e.w;
            selectedEdges[v] = e.id; // 记录边
            播放音效("select");
            更新队列;
        }
    }
    取消高亮u;
}
// 最终展示 selectedEdges 为蓝色路径
```

#### **复古像素风格**
- **颜色方案**：节点用 8-bit 调色板（红、蓝、黄、绿）。  
- **音效触发**：每次选中边时播放 8-bit 短音效，完成时播放 FC 风格通关音乐。

---
处理用时：71.30秒
# 题目信息

# [ABC400E] Ringo's Favorite Numbers 3

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc400/tasks/abc400_e

对于正整数 $N$，当且仅当满足以下两个条件时，$N$ 被称为 **400 number**：

- $N$ 恰好有 $2$ 种不同的素因数。
- 对于 $N$ 的每个素因数 $p$，$N$ 被 $p$ 整除的次数为偶数次。更严格地说，对于 $N$ 的每个素因数 $p$，使得 $p^k$ 是 $N$ 的约数的最大非负整数 $k$ 是偶数。

给定 $Q$ 个查询，请回答每个查询。每个查询给出一个整数 $A$，请找出不超过 $A$ 的最大 400 number 的值。在本问题的约束条件下，保证 $A$ 以下必定存在至少一个 400 number。

## 说明/提示

### 约束条件

- $1 \leq Q \leq 2 \times 10^5$
- 对于每个查询，$36 \leq A \leq 10^{12}$
- 输入中的所有值均为整数

### 样例解释 1

以第一个查询为例：  
$400$ 的素因数恰好为 $2$ 和 $5$ 两种。$400$ 被 $2$ 整除的次数为 $4$ 次（偶数次），被 $5$ 整除的次数为 $2$ 次（偶数次），因此 $400$ 是 400 number。而 $401$、$402$、$403$、$404$ 均不是 400 number，故答案为 $400$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5

404

36

60

1000000000000

123456789```

### 输出

```
400

36

36

1000000000000

123454321```

# AI分析结果



**唯一算法分类**：筛法预处理

---

### 题解思路与核心难点

**核心思路**：  
400数可表示为 \( N = (p^a q^b)^2 \)，其中 \( p, q \) 为不同素数，\( a, b \geq 1 \。转化为寻找不超过 \( \sqrt{A} \) 的最大数 \( k \)，且 \( k \) 恰好有两个不同素因数。

**解决难点**：  
1. **高效预处理**：需快速计算每个数的不同素因数个数。  
2. **快速查询**：对每个查询，需在 \( O(1) \) 或 \( O(\log n) \) 时间内找到最大符合条件的数。

**关键步骤**：  
1. **筛法预处理**：用埃氏筛或欧拉筛统计每个数的不同素因数个数。  
2. **维护前缀最大值数组**：记录每个数之前最大的满足条件的数。  
3. **查询时取平方根**：计算 \( \sqrt{A} \)，查表返回平方值。

---

### 题解评分（≥4星）

1. **ctw123 题解（5星）**  
   - **亮点**：使用欧拉筛预处理最小素因子，递推计算质因数数量，维护前缀最大值数组，查询复杂度 \( O(1) \)。  
   - **代码简洁性**：逻辑清晰，预处理与查询分离，适合大规模输入。

2. **I_am_kunzi 题解（4.5星）**  
   - **亮点**：埃氏筛统计素因数个数，维护动态前缀最大值数组，代码简洁高效。  
   - **优化点**：直接维护最大值的记录数组，省去额外排序步骤。

3. **ikunTLE 题解（4星）**  
   - **亮点**：类似筛法预处理，通过遍历维护最大值，代码简短。  
   - **缺点**：未显式处理前缀数组，每次查询需遍历到当前值。

---

### 最优思路与技巧

**核心技巧**：  
1. **筛法统计质因数个数**：在筛素数时，动态更新每个数的不同质因数数量。  
2. **前缀最大值数组**：维护每个位置之前最大的合法值，实现 \( O(1) \) 查询。  
3. **平方根转换**：将原问题转化为平方根的质因数条件判断，简化问题规模。

**代码片段（I_am_kunzi 题解核心逻辑）**：  
```cpp
void init() {
    for (int i = 2; i <= N; ++i) {
        if (!vis[i]) { // i 是素数
            for (int j = i; j <= N; j += i) {
                vis[j] = true;
                cnt[j]++; // 每个倍数增加质因数计数
            }
        }
    }
    int p = 0;
    for (int i = 2; i <= N; ++i) {
        if (cnt[i] == 2) p = i;
        rec[i] = p; // 维护前缀最大值
    }
}
```

---

### 类似题目推荐

1. **P2429 质数方阵**：质因数分解与筛法应用。  
2. **P1075 质因数分解**：基础质因数分解练习。  
3. **P3383 线性筛素数**：筛法模板题。

---

### 可视化设计

**核心动画设计**：  
1. **筛法过程**：用不同颜色标记素数及其倍数，显示质因数计数变化。  
2. **平方根查询**：高亮当前查询的平方根值，回溯前缀最大值路径。  
3. **像素风格**：  
   - **素数为蓝色**，合数为灰色，符合条件的数为绿色。  
   - **音效**：质数标记时播放“滴”声，符合条件时播放“成功”音效。  

**交互功能**：  
- **步进控制**：单步执行筛法步骤，观察计数变化。  
- **查询演示**：输入不同 \( A \)，动态展示平方根计算与结果查找。

---

### 总结

通过筛法预处理质因数个数并维护前缀最大值数组，将查询复杂度优化至 \( O(1) \)，是本题的最优解法。此方法结合数论与高效数据结构，适用于大规模查询场景。

---
处理用时：103.79秒
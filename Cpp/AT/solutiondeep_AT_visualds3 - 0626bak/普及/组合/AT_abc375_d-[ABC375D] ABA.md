# 题目信息

# [ABC375D] ABA

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc375/tasks/abc375_d

英大文字からなる文字列 $ S $ が与えられます。

整数の組 $ (i,\ j,\ k) $ であって、以下の条件をともに満たすものの個数を求めてください。

- $ 1\ \leq\ i\ <\ j\ <\ k\ \leq\ |S| $
- $ S_i $, $ S_j $, $ S_k $ をこの順に結合して得られる長さ $ 3 $ の文字列が回文となる
 
ただし、$ |S| $ は文字列 $ S $ の長さ、$ S_x $ は $ S $ の $ x $ 番目の文字を指します。

## 说明/提示

### 制約

- $ S $ は長さ $ 1 $ 以上 $ 2\ \times\ 10^5 $ 以下の英大文字からなる文字列
 
### Sample Explanation 1

$ (i,\ j,\ k)\ =\ (1,\ 2,\ 4),\ (1,\ 3,\ 4),\ (3,\ 4,\ 5),\ (3,\ 4,\ 6),\ (3,\ 5,\ 6) $ が条件を満たします。

## 样例 #1

### 输入

```
ABCACC```

### 输出

```
5```

## 样例 #2

### 输入

```
OOOOOOOO```

### 输出

```
56```

## 样例 #3

### 输入

```
XYYXYYXYXXX```

### 输出

```
75```

# AI分析结果



**唯一算法分类**：前缀和与数学优化

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
题目要求统计满足条件的三元组 $(i,j,k)$，其中首尾字符相同，中间字符任意。通过观察，每个三元组的贡献仅与首尾字符的位置差相关。对于每个字符 $S_k$，其贡献为前面所有相同字符 $S_i$ 的位置差之和，即 $\sum_{i}(k-i-1)$。通过数学变换，可将总和拆解为前缀和的形式，实现 $O(1)$ 时间计算每个位置的贡献。

**算法流程**：  
1. 维护两个数组 `cnt` 和 `sum`，分别记录每个字符的出现次数和位置前缀和。
2. 遍历字符串，对每个字符 $S_k$：
   - 当前贡献为 `cnt[c] * (k-1) - sum[c]`（`c` 是当前字符的索引）。
   - 更新 `sum[c] += k` 和 `cnt[c] += 1`。
3. 累加所有位置的贡献。

**解决难点**：  
- **数学拆分**：将贡献公式 $\sum_{i}(k-i-1)$ 转化为前缀和形式，避免暴力枚举。
- **空间优化**：仅需维护字符级别的计数，无需记录所有位置。

---

### **题解评分 (≥4星)**

1. **Anins (5星)**  
   - **亮点**：代码简洁高效，时间复杂度 $O(n)$，直接维护前缀和。
   - **关键代码**：
     ```cpp
     ans += cnt[k] * (i-1) - sum[k];
     sum[k] += i;
     cnt[k]++;
     ```

2. **small_lemon_qwq (4星)**  
   - **亮点**：思路与 Anins 一致，但变量命名稍显模糊。
   - **关键代码**：
     ```cpp
     ans += cnt[s[i]] * (i-1) - mp[s[i]];
     mp[s[i]] += i;
     cnt[s[i]]++;
     ```

3. **cjh_trailblazer (4星)**  
   - **亮点**：通过前缀和后缀相乘统计贡献，思路清晰但复杂度略高（$O(n \cdot 26)$）。
   - **关键代码**：
     ```cpp
     for (int j=0; j<26; j++)
         ans += sum[i-1][j] * suf[i+1][j];
     ```

---

### **最优思路提炼**

**关键技巧**：  
- **贡献拆分**：利用 $\sum_{i}(k-i-1) = \text{cnt} \cdot (k-1) - \text{sum\_positions}$ 实现快速计算。
- **前缀和优化**：维护字符级别的计数和位置总和，避免重复遍历。

---

### **同类型题与算法套路**

**相似问题**：  
1. 统计满足 `A[i] = A[j]` 且 `i < j` 的区间和。
2. 计算回文子序列中固定首尾的变种问题。

**通用解法**：  
- **前缀和哈希**：记录每个元素的累计信息（如出现次数、位置和）。
- **数学公式转换**：将暴力枚举转化为数学表达式，利用前缀和优化。

---

### **推荐题目**

1. **洛谷 P2671 [NOIP2015 普及组] 求和**  
   - 类似前缀和优化与贡献拆分。

2. **洛谷 P1564 膜拜**  
   - 利用前缀和统计区间条件。

3. **洛谷 P3406 海底高铁**  
   - 差分与前缀和的综合应用。

---

### **可视化与算法演示**

**动画设计**：  
1. **网格表示**：将字符串映射为像素网格，不同颜色表示不同字符。
2. **贡献高亮**：处理字符 `S_k` 时，高亮前面所有相同字符 `S_i`，显示中间区域（`i+1` 到 `k-1`）的方块。
3. **实时更新**：动态显示 `sum` 和 `cnt` 的值，以及总贡献的变化。

**复古像素风格**：  
- **颜色方案**：每个字符对应 8-bit 颜色，如 `A` 为红色，`B` 为蓝色。
- **音效设计**：每次更新贡献时播放短促音效，总分更新时播放胜利音效。

**交互功能**：  
- **步进控制**：允许单步执行观察每个字符的处理。
- **自动演示**：AI 模式自动遍历字符，展示贡献计算过程。

---

**示例代码片段（关键动画逻辑）**：  
```javascript
// 伪代码：更新贡献的动画
function processChar(k, c) {
    highlightChar(k); // 高亮当前字符
    let prevSum = sum[c];
    let prevCnt = cnt[c];
    // 显示公式：贡献 = cnt*(k-1) - sum
    showContribution(prevCnt * (k-1) - prevSum);
    // 更新前缀和与计数
    sum[c] += k;
    cnt[c]++;
    playSound('beep'); // 播放音效
}
```

---

**总结**：通过前缀和与数学优化，将 $O(n^2)$ 暴力枚举转化为 $O(n)$ 高效计算，是此类问题的通用解法。

---
处理用时：100.70秒
# 题目信息

# [ABC271D] Flip and Adjust

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc271/tasks/abc271_d

両面に整数が書かれたカードが $ N $ 枚あり、$ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 枚目のカードの表には $ a_i $ が、裏には $ b_i $ が書かれています。

あなたは、それぞれのカードについて、表を上に向けて置くか裏を上に向けて置くかを自由に決めることができます。

上に向けられた面に書かれた整数の総和がちょうど $ S $ となるようにカードを置くことができるか判定し、可能ならそのようなカードの置き方の一例を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ S\ \leq\ 10000 $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ 100\ \,\ (1\ \leq\ i\ \leq\ N) $
- 入力は全て整数

### Sample Explanation 1

例えば次のように置くことで、上に向けられた面に書かれた整数の総和がちょうど $ S\ (=\ 11) $ となります。 - $ 1 $ 枚目は表、$ 2 $ 枚目は裏、$ 3 $ 枚目は裏を上に向けて置く。 - $ 1 $ 枚目は裏、$ 2 $ 枚目は表、$ 3 $ 枚目は表を上に向けて置く。 よって、`HTT` や `THH` といった出力が正解となります。

### Sample Explanation 2

上に向けられた面に書かれた整数の総和がちょうど $ S\ (=\ 25) $ となるようにカードを置くことはできません。

## 样例 #1

### 输入

```
3 11

1 4

2 3

5 7```

### 输出

```
Yes

THH```

## 样例 #2

### 输入

```
5 25

2 8

9 3

4 11

5 1

12 6```

### 输出

```
No```

# AI分析结果



# ABC271D Flip and Adjust 题解分析

## 唯一算法分类
动态规划（DP）

---

## 综合分析与结论

### 核心思路
使用动态规划维护可达性，并通过递归回溯构造方案。定义 `dp[i][j]` 表示前 i 张卡片能否组成总和 j。状态转移方程为：
- `dp[i][j+a[i]] |= dp[i-1][j]`
- `dp[i][j+b[i]] |= dp[i-1][j]`

### 解决难点
1. **路径回溯**：通过递归从终点 `dp[N][S]` 反向遍历，判断每个卡片的选择（H/T）。
2. **初始化**：`dp[0][0] = true` 作为初始条件，表示 0 张卡片的和为 0。
3. **可行性判断**：最终检查 `dp[N][S]` 是否为 true。

### 可视化设计
1. **动态表格填充**：在 Canvas 中绘制二维 DP 表格，用不同颜色标记转移过程（绿：a[i]转移，蓝：b[i]转移）。
2. **回溯路径高亮**：最终路径用红色箭头连接，展示从 S 到 0 的路径。
3. **8位音效**：转移成功时播放短音效，找到解时播放胜利音效。

---

## 题解清单（≥4星）

### 1. DYYqwq（5星）
- **亮点**：清晰的二维 DP 实现，递归回溯路径直观。
- **关键代码**：
  ```cpp
  void output(int x, int y) {
      if (y >= a[x] && dp[x-1][y-a[x]]) {
          output(x-1, y-a[x]);
          ans += 'H';
      } else {
          output(x-1, y-b[x]);
          ans += 'T';
      }
  }
  ```

### 2. xiaoPanda（4星）
- **亮点**：使用辅助数组 `g` 记录选择，反向遍历构造答案。
- **关键代码**：
  ```cpp
  while(n) {
      ans.push_back(g[n][s] ? 'T' : 'H');
      s -= (g[n][s] ? b[n] : a[n]);
      n--;
  }
  ```

### 3. Mr_Gengar（4星）
- **亮点**：标准 DP 框架，代码简洁易读。
- **关键代码**：
  ```cpp
  void print(int i, int s) {
      if (s >= a[i] && dp[i-1][s-a[i]]) {
          print(i-1, s-a[i]);
          cout << 'H';
      } else {
          print(i-1, s-b[i]);
          cout << 'T';
      }
  }
  ```

---

## 最优思路与技巧

### 关键思路
1. **动态规划维护可达性**：通过布尔数组记录每个状态的可达性。
2. **递归回溯路径**：从最终状态反向推导每一步的选择。

### 优化技巧
- **滚动数组**：可将二维数组优化为一维数组，节省空间。
- **提前剪枝**：在转移时若 `j + a[i]/b[i] > S` 则跳过。

---

## 类似题目推荐
1. **P2347 砝码称重**：类似的多重选择可达性问题。
2. **P1048 采药**：01背包问题的经典变种。
3. **P1064 金明的预算方案**：带依赖的选择问题。

---

## 核心代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, S, a[105], b[105];
bool dp[105][10005]; // dp[i][j]: 前i张卡能否组成j

void trace(int i, int j) {
    if (!i) return;
    if (j >= a[i] && dp[i-1][j - a[i]]) {
        trace(i-1, j - a[i]);
        cout << 'H';
    } else {
        trace(i-1, j - b[i]);
        cout << 'T';
    }
}

int main() {
    cin >> n >> S;
    dp[0][0] = true;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i] >> b[i];
        for (int j = 0; j <= S; ++j) {
            if (dp[i-1][j]) {
                if (j + a[i] <= S) dp[i][j + a[i]] = true;
                if (j + b[i] <= S) dp[i][j + b[i]] = true;
            }
        }
    }
    if (!dp[n][S]) cout << "No";
    else {
        cout << "Yes\n";
        trace(n, S);
    }
    return 0;
}
```

---

## 可视化方案设计

### 动画演示
1. **初始化阶段**：展示空表格，高亮 `dp[0][0]` 为绿色。
2. **转移阶段**：对于每个卡片，用箭头从 `dp[i-1][j]` 指向 `j+a[i]` 和 `j+b[i]`。
3. **回溯阶段**：用红色路径从 `dp[n][S]` 回退到 `dp[0][0]`。

### 复古风格设计
- **调色板**：使用 8 位风格的绿色（可行）、红色（路径）、灰色（不可达）。
- **音效**：转移时播放「哔」声，回溯时播放「啾」声，成功时播放胜利旋律。

---

通过上述分析和代码实现，可以高效解决该问题，并通过可视化加深对动态规划过程的理解。

---
处理用时：81.80秒
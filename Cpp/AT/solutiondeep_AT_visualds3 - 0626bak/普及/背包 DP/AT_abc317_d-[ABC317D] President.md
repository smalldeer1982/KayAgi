# 题目信息

# [ABC317D] President

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_d

高橋君と青木君が選挙で戦っています。  
 選挙区は $ N $ 個あります。$ i $ 番目の選挙区には $ X_i\ +\ Y_i $ 人の有権者がいて、そのうち $ X_i $ 人が高橋派、$ Y_i $ 人が青木派です。($ X_i\ +\ Y_i $ はすべて奇数です)  
 それぞれの区では、多数派がその区の $ Z_i $ 議席を全て獲得します。そして、$ N $ 個の選挙区全体として過半数の議席を獲得した方が選挙に勝利します。($ \displaystyle\ \sum_{i=1}^N\ Z_i $ は奇数です)  
 高橋君が選挙で勝利するには最低で何人を青木派から高橋派に鞍替えさせる必要がありますか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 0\ \leq\ X_i,\ Y_i\ \leq\ 10^9 $
- $ X_i\ +\ Y_i $ は奇数
- $ 1\ \leq\ Z_i $
- $ \displaystyle\ \sum_{i=1}^N\ Z_i\ \leq\ 10^5 $
- $ \displaystyle\ \sum_{i=1}^N\ Z_i $ は奇数
 
### Sample Explanation 1

選挙区が $ 1 $ 個しかないので、$ 1 $ 番目の選挙区で議席を獲得した人が選挙に勝利します。 $ 1 $ 番目の選挙区の青木派 $ 3 $ 人を高橋派に鞍替えさせると、$ 1 $ 番目の選挙区にいる有権者のうち高橋派は $ 6 $ 人、青木派は $ 5 $ 人になり、高橋君は議席を獲得できます。

### Sample Explanation 2

$ 1 $ 番目の選挙区の議席数よりも $ 2 $ 番目の選挙区の議席数の方が多いため、高橋君が選挙に勝つには $ 2 $ 番目の選挙区で高橋派を多数派にする必要があります。 $ 2 $ 番目の選挙区の青木派の $ 4 $ 人を鞍替えさせると高橋君は $ 5 $ 議席を獲得できます。このとき青木君の獲得する議席は $ 2 $ 議席なので、高橋君は選挙に勝利できます。

### Sample Explanation 3

青木派から高橋派に鞍替えする人が $ 0 $ 人でも高橋君が選挙で勝つ場合は $ 0 $ 人が答えになります。

## 样例 #1

### 输入

```
1

3 8 1```

### 输出

```
3```

## 样例 #2

### 输入

```
2

3 6 2

1 8 5```

### 输出

```
4```

## 样例 #3

### 输入

```
3

3 4 2

1 2 3

7 2 6```

### 输出

```
0```

## 样例 #4

### 输入

```
10

1878 2089 16

1982 1769 13

2148 1601 14

2189 2362 15

2268 2279 16

2394 2841 18

2926 2971 20

3091 2146 20

3878 4685 38

4504 4617 29```

### 输出

```
86```

# AI分析结果



**唯一算法分类**  
动态规划（01背包）

---

### **题解思路、算法要点与解决难点**  
**核心思路**：将每个选区视为一个物品，转换所需人数为重量，获得的议席为价值，使用01背包求解最小转换人数。  
**算法要点**：  
1. **预处理每个选区的转换成本**：若当前选区青木派占优，计算需转换人数为`max(0, (Y_i - X_i +1)//2)`。  
2. **动态规划状态定义**：`dp[j]`表示获得j个议席所需的最小转换人数。  
3. **状态转移**：逆序遍历议席数，更新`dp[j] = min(dp[j], dp[j-Z_i] + cost_i)`。  
4. **结果选取**：找到超过总议席半数的最小`dp[j]`。  

**解决难点**：  
- **正确建模为背包问题**：将议席数作为背包容量，转换人数作为价值。  
- **处理大范围容量**：总议席数可达1e5，需优化为一维数组滚动更新。  

---

### **题解评分**  
1. **ran_qwq（5星）**：代码简洁，正确使用一维背包优化，处理初始条件清晰。  
2. **zhangjiting（4星）**：逻辑正确，但变量命名可优化。  
3. **sunkuangzheng（4星）**：代码高效，直接计算总需议席，但注释较少。  

---

### **最优思路或技巧提炼**  
1. **背包容量反向更新**：避免重复选择同一物品，确保01背包正确性。  
2. **初始状态设定**：`dp[0]=0`其余为无穷大，保证不可达状态正确处理。  
3. **阈值计算**：总议席数奇数的半数向上取整为`(sum_z +1)//2`。  

---

### **同类型题或类似算法套路**  
- **相似问题**：最小代价选择物品达到目标，如硬币问题、资源分配。  
- **通用解法**：01背包用于“选或不选”决策，代价最小化或价值最大化。  

---

### **推荐相似题目**  
1. **P1048 采药**（01背包基础）  
2. **P1060 开心的金明**（背包价值最大化）  
3. **P1164 小A点菜**（恰好装满的方案数）  

---

### **个人心得摘录**  
- **初始化陷阱**：未正确设置`dp[0] = 0`导致全不可达。  
- **数据范围检查**：议席总和可能超过1e5，需合理设置数组大小。  

---

### **可视化与算法演示**  
**核心逻辑动画**：  
1. **选区展示**：每个选区显示为像素块，颜色区分已选/未选。  
2. **背包更新**：高亮当前处理的物品，滑动条显示当前容量。  
3. **状态变化**：`dp[j]`更新时颜色闪烁，右侧显示当前最小人数。  

**复古游戏化设计**：  
- **8位像素风格**：选区用16x16像素块，绿色（已选）、红色（未选）。  
- **音效触发**：物品选中时播放“哔”声，成功时播放胜利旋律。  
- **自动演示模式**：AI逐步选择物品，动态显示`dp`数组变化。  

```python
# 伪代码示例：背包更新核心逻辑
for i in 所有选区:
    if X_i < Y_i:
        cost = (Y_i - X_i + 1) // 2
        for j in 总议席数 downto Z_i:
            if dp[j - Z_i] + cost < dp[j]:
                dp[j] = dp[j - Z_i] + cost
                # 触发动画：选区i高亮，dp[j]变色
```

---

**代码片段（关键DP部分）**  
```cpp
memset(dp, 0x3f, sizeof(dp));
dp[0] = 0;
int total_z = 0;
for (int i = 0; i < n; i++) {
    int x, y, z;
    cin >> x >> y >> z;
    if (x >= y) {
        ans += z; // 直接获得议席
    } else {
        int cost = (y - x + 1) / 2;
        total_z += z;
        for (int j = total_z; j >= z; j--) {
            dp[j] = min(dp[j], dp[j - z] + cost);
        }
    }
}
int required = (total_seats + 1) / 2;
int min_cost = *min_element(dp + required, dp + total_z + 1);
cout << min_cost << endl;
```

---
处理用时：98.73秒
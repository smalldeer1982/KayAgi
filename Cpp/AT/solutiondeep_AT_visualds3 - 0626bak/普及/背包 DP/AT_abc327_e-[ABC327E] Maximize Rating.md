# 题目信息

# [ABC327E] Maximize Rating

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc327/tasks/abc327_e

高橋君は $ N $ 回コンテストに参加し、$ i $ 回目に参加したコンテストにおいてパフォーマンス $ P_i $ を獲得しました。  
高橋君はこの中から ($ 1 $ つ以上) いくつかのコンテストを選び、それらの結果から計算される高橋君のレートを最大にしたいと考えています。

コンテストをうまく選んだとき、高橋君のレートとしてあり得る最大の値を求めてください。

ただし、高橋君のレート $ R $ は、高橋君の選んだコンテストの数が $ k $ 個であり、 選んだコンテストにおけるパフォーマンスが **参加した順に** それぞれ $ (Q_1,Q_2,\ldots,Q_k) $ であるとき、

$ \displaystyle\ R=\frac{\sum_{i=1}^k\ (0.9)^{k-i}Q_i}{\sum_{i=1}^k\ (0.9)^{k-i}}-\frac{1200}{\sqrt{k}} $ によって計算されます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 5000 $
- $ 1\leq\ P_i\leq\ 5000 $
- 入力はすべて整数

### Sample Explanation 1

高橋君が $ 1 $ 回目と $ 3 $ 回目のコンテストを選んだ時、レートは、 $ \displaystyle\ R=\frac{0.9\times\ 1000+\ 1.0\times\ 1200}{0.9+1.0}-\frac{1200}{\sqrt{2}}=256.73502... $ となり、この時レートが最大となります。

### Sample Explanation 2

$ 1,2,3 $ 回目のコンテストすべてを選んだとき、レートが最大となります。

### Sample Explanation 3

レートは負になることもあります。

## 样例 #1

### 输入

```
3
1000 600 1200```

### 输出

```
256.735020470879931```

## 样例 #2

### 输入

```
3
600 1000 1200```

### 输出

```
261.423219407873376```

## 样例 #3

### 输入

```
1
100```

### 输出

```
-1100.000000000000000```

# AI分析结果



## **算法分类**
动态规划（DP）

---

## **题解思路、算法要点与解决难点**

### **核心思路**
所有题解均采用动态规划，核心在于预处理分母部分，并DP维护选k个元素时的最大分子值。难点在于处理权重衰减（0.9的幂次）对状态转移的影响。通过将权重变化融入状态转移，使得每次新选元素时，之前的权重自动衰减。

### **关键步骤**
1. **状态定义**  
   `f[i][j]` 表示前i场比赛中选j场的最大分子值（`∑(0.9)^{j-1}Q_i`）。
2. **状态转移**  
   对每个元素，分选与不选两种情况：  
   - 不选：`f[i][j] = f[i-1][j]`  
   - 选：`f[i][j] = f[i-1][j-1] * 0.9 + P[i]`  
   转移时通过`0.9`系数实现权重衰减。
3. **预处理分母**  
   计算`sum[k] = ∑_{i=1}^k (0.9)^{k-i}`，递推公式：`sum[k] = sum[k-1] * 0.9 + 1`。
4. **结果计算**  
   遍历所有可能的k，计算`R = f[n][k]/sum[k] - 1200/sqrt(k)`，取最大值。

### **解决难点**
- **权重衰减处理**：通过转移时乘以0.9，将权重衰减隐含在状态中，避免显式计算幂次。
- **时间复杂度优化**：状态转移为O(1)，总时间复杂度为O(N²)，满足N=5000的约束。

---

## **题解评分 (≥4星)**

1. **qqqaaazzz_qwq（★★★★☆）**  
   - 思路清晰，代码简洁。  
   - 明确状态转移方程，注释提醒常见错误（循环边界）。  
   - 代码可读性高，预处理分母与DP分离。

2. **yydfj（★★★★☆）**  
   - 反转数组简化权重计算，巧妙利用01背包的滚动数组优化空间。  
   - 代码实现高效，但反转思路需一定思维跳跃。

3. **naroanah（★★★★☆）**  
   - 使用秦九韶算法简化权重计算，代码简洁。  
   - 预处理`sum`数组，最终遍历取最大值逻辑清晰。

---

## **最优思路或技巧提炼**
1. **动态规划状态设计**：将权重衰减隐含在状态转移中，避免显式计算复杂幂次。
2. **预处理分母**：利用递推公式`sum[k] = 0.9*sum[k-1] + 1`，快速计算分母值。
3. **滚动数组优化**（部分题解）：通过倒序更新j值，将二维DP压缩为一维数组，节省空间。

---

## **同类型题或类似算法套路**
- **带权重的背包问题**：如物品价值随时间衰减的背包问题。
- **时间序列选择问题**：如股票买卖中考虑时间衰减的最优选择。
- **递推预处理辅助项**：如斐波那契数列、组合数预处理等。

---

## **推荐题目**
1. **洛谷 P1048**：01背包基础模板题，熟悉状态转移。  
2. **洛谷 P1064**：依赖背包问题，练习复杂状态设计。  
3. **洛谷 P1156**：时间相关动态规划，模拟垃圾掉落与生存策略。

---

## **个人心得摘录**
- **qqqaaazzz_qwq**：提醒注意循环边界（`j <= i`而非`j <= n`），避免低级错误。
- **yydfj**：反转数组使权重计算更直观，提供新视角优化思维。
- **2huk**：详细推导状态转移中的权重变化，强调公式拆解的重要性。

---

## **可视化与算法演示**

### **动画方案**
1. **动态表格展示**  
   - 以网格显示`f[i][j]`的值，颜色标记当前更新的单元格（如黄色高亮）。  
   - 每一步展示选或不选第i个元素的转移过程（红色箭头表示选，蓝色表示不选）。

2. **权重衰减可视化**  
   - 用柱状图展示选k个元素时各元素的权重（0.9^{k-i}），动态调整柱高。

3. **音效与交互**  
   - **音效**：更新状态时播放“点击”声，找到更大值时播放“叮咚”声。  
   - **控制面板**：支持暂停/继续、单步执行、调整动画速度（0.5x~2x）。

### **复古像素风格设计**
- **8位像素UI**：用16色调色板渲染网格，仿FC风格显示状态值和权重柱状图。  
- **Canvas绘制**：用像素方块表示DP状态，每步更新时方块闪烁提示。  
- **自动演示模式**：AI自动运行算法，类似“贪吃蛇AI”路径展示，可随时切换手动控制。

---

## **代码实现（核心片段）**
```cpp
// 预处理分母
double sum[5010] = {0};
for (int k = 1; k <= n; k++) {
    sum[k] = sum[k-1] * 0.9 + 1;
}

// DP转移（滚动数组优化）
double f[5010] = {0};
for (int i = 1; i <= n; i++) {
    for (int j = i; j >= 1; j--) {
        f[j] = max(f[j], f[j-1] * 0.9 + p[i]);
    }
}

// 计算结果
double ans = -1e18;
for (int k = 1; k <= n; k++) {
    ans = max(ans, f[k] / sum[k] - 1200 / sqrt(k));
}
```

---
处理用时：104.83秒
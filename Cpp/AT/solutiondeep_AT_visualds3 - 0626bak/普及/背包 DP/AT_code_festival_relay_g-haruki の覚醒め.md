# 题目信息

# haruki の覚醒め

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2014-relay/tasks/code_festival_relay_g

haruki さんは朝に弱いことで有名です。haruki さんの家には目覚まし時計が $ n $ 個あり、$ i $ 番目の目覚まし時計の音量は $ a_i $ です。

   
haruki さんは鳴っている目覚まし時計の音量の合計が $ m $ 以上にならない限り、目を覚ますことはありません。しかしながら、必要以上に目覚まし時計をセットすると、うるさくて近所迷惑になってしまいます。

   
そこで、合計の音量が $ m $ 以上でかつ最小となるように目覚まし時計を選んだとき、その合計の音量を求めてください。

## 样例 #1

### 输入

```
3 30

25

10

23```

### 输出

```
33```

## 样例 #2

### 输入

```
4 101

10

20

30

40```

### 输出

```
-1```

# AI分析结果



**唯一算法分类**: 动态规划（01背包）

---

### 算法分析与结论

#### 核心思路
题目转化为在总和限制下求最大未选子集和。设总音量之和为 `sum`，需满足 `sum - 未选子集和 ≥ m`。等价于在背包容量 `sum - m` 下，求最大可装的物品（音量）之和。最终答案为 `sum - 最大未选和`。

#### 难点解决
- **转化思维**：将原问题转化为01背包，逆向求未被选中部分的最大值。
- **空间优化**：使用一维数组滚动更新，逆序遍历容量避免覆盖。

#### 复杂度
时间复杂度：O(n*(sum - m))  
空间复杂度：O(sum)

---

### 题解评分（≥4星）

1. **MattL（★★★★★）**  
   - 思路清晰，背包转化巧妙，代码简洁高效。  
   - 关键点：总和减m的容量转化，逆序更新。  
   - 代码亮点：明确注释和变量命名。

2. **zjyqwq（★★★★）**  
   - 使用布尔型DP记录可达和，直接遍历找最小解。  
   - 优点：直观易懂；缺点：sum较大时效率略低。

3. **Cambridge（★★★★）**  
   - 布尔数组标记可行解，从m开始遍历求最小。  
   - 代码清晰，适合快速理解子集和可能性。

---

### 最优思路提炼

1. **逆向背包转化**  
   将问题转化为求 `sum - m` 容量下的最大子集和，未被选中的部分最大化，从而最小化选中部分。
2. **动态规划优化**  
   使用一维数组逆序更新，节省空间并避免重复计算。

**代码片段**：
```cpp
int sum = accumulate(a, a + n, 0);
if (sum < m) return -1;
int target = sum - m;
vector<int> dp(target + 1, 0);
for (int num : a) {
    for (int j = target; j >= num; j--) {
        dp[j] = max(dp[j], dp[j - num] + num);
    }
}
return sum - dp[target];
```

---

### 类似题目推荐

1. **P1048 采药** - 基础01背包问题。
2. **P1060 开心的金明** - 带权价值的01背包变种。
3. **P4161 [SCOI2005]最大子矩阵** - 子集和的扩展应用。

---

### 可视化设计（复古像素风格）

1. **动画逻辑**  
   - **背包填充**：每个物品处理时，用像素方块表示当前物品大小，右侧显示容量条逐步填充。
   - **颜色标记**：已处理的物品为绿色，当前物品为红色，更新位置闪烁黄光。
2. **音效与交互**  
   - **音效**：物品处理时播放“哔”声，找到解时播放胜利音效。
   - **控制面板**：支持暂停/继续，拖动进度条调节速度。
3. **像素风格示例**  
   ```javascript
   // 伪代码：绘制背包更新
   function drawDP(j, value) {
       ctx.fillStyle = '#8BDBFF'; // 背包格子颜色
       ctx.fillRect(j * 10, 0, 9, 9);
       ctx.fillStyle = '#FF6B6B'; // 更新值高亮
       ctx.fillText(value, j * 10, 8);
   }
   ```

---

### 个人心得摘录

- **MattL**：在转化问题时卡壳，意识到总和减m的容量是关键。
- **Yang818**：DFS剪枝不彻底导致超时，改用背包后效率提升显著。

---

### 核心算法演示

**步骤说明**：
1. 初始化总和 `sum` 和背包容量 `sum - m`。
2. 对每个音量值逆序更新背包数组，记录最大可装载值。
3. 最终结果 `sum - dp[target]` 即为最小合法总和。

**动态效果**：  
![背包填充动画](https://via.placeholder.com/400x200/FF6B6B/8BDBFF?text=DP+Update+Visual)  
（示例：红色方块为当前处理物品，黄色高亮更新位置）

---
处理用时：112.53秒
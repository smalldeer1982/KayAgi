# 题目信息

# [ABC317D] President

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_d

高橋君と青木君が選挙で戦っています。  
 選挙区は $ N $ 個あります。$ i $ 番目の選挙区には $ X_i\ +\ Y_i $ 人の有権者がいて、そのうち $ X_i $ 人が高橋派、$ Y_i $ 人が青木派です。($ X_i\ +\ Y_i $ はすべて奇数です)  
 それぞれの区では、多数派がその区の $ Z_i $ 議席を全て獲得します。そして、$ N $ 個の選挙区全体として過半数の議席を獲得した方が選挙に勝利します。($ \displaystyle\ \sum_{i=1}^N\ Z_i $ は奇数です)  
 高橋君が選挙で勝利するには最低で何人を青木派から高橋派に鞍替えさせる必要がありますか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 0\ \leq\ X_i,\ Y_i\ \leq\ 10^9 $
- $ X_i\ +\ Y_i $ は奇数
- $ 1\ \leq\ Z_i $
- $ \displaystyle\ \sum_{i=1}^N\ Z_i\ \leq\ 10^5 $
- $ \displaystyle\ \sum_{i=1}^N\ Z_i $ は奇数
 
### Sample Explanation 1

選挙区が $ 1 $ 個しかないので、$ 1 $ 番目の選挙区で議席を獲得した人が選挙に勝利します。 $ 1 $ 番目の選挙区の青木派 $ 3 $ 人を高橋派に鞍替えさせると、$ 1 $ 番目の選挙区にいる有権者のうち高橋派は $ 6 $ 人、青木派は $ 5 $ 人になり、高橋君は議席を獲得できます。

### Sample Explanation 2

$ 1 $ 番目の選挙区の議席数よりも $ 2 $ 番目の選挙区の議席数の方が多いため、高橋君が選挙に勝つには $ 2 $ 番目の選挙区で高橋派を多数派にする必要があります。 $ 2 $ 番目の選挙区の青木派の $ 4 $ 人を鞍替えさせると高橋君は $ 5 $ 議席を獲得できます。このとき青木君の獲得する議席は $ 2 $ 議席なので、高橋君は選挙に勝利できます。

### Sample Explanation 3

青木派から高橋派に鞍替えする人が $ 0 $ 人でも高橋君が選挙で勝つ場合は $ 0 $ 人が答えになります。

## 样例 #1

### 输入

```
1

3 8 1```

### 输出

```
3```

## 样例 #2

### 输入

```
2

3 6 2

1 8 5```

### 输出

```
4```

## 样例 #3

### 输入

```
3

3 4 2

1 2 3

7 2 6```

### 输出

```
0```

## 样例 #4

### 输入

```
10

1878 2089 16

1982 1769 13

2148 1601 14

2189 2362 15

2268 2279 16

2394 2841 18

2926 2971 20

3091 2146 20

3878 4685 38

4504 4617 29```

### 输出

```
86```

# AI分析结果



## 算法分类
动态规划（01背包）

## 题解思路、算法要点与解决难点
### 核心思路
1. **问题转化**：每个选区若需转换，其成本为将青木派转为高桥派所需人数，价值为该选区的席位。目标是总席位过半。
2. **初始计算**：统计初始高桥已赢得的席位（`num1`），其余选区视为可转换的背包物品。
3. **动态规划**：使用01背包模型，求达到剩余所需席位的最小成本。

### 关键步骤
1. **预处理选区**：对每个选区，若高桥已赢，直接累加席位；否则，计算转换所需人数（`w_i`）并将该选区视为物品（价值`Z_i`，成本`w_i`）。
2. **背包求解**：`dp[j]`表示获得`j`席位的最小成本。遍历物品，逆序更新状态，最后找到满足剩余所需席位的最小成本。

### 解决难点
- **正确处理初始席位**：需分离已赢选区，避免重复计算。
- **背包优化**：逆序更新确保每个物品仅选一次，降低空间复杂度。

## 题解评分（≥4星）
1. **Fire_flame（4星）**  
   思路清晰，正确分离初始席位，处理转换选区的贡献为差额的2倍，优化背包容量。

2. **WilliamFranklin（4星）**  
   简明扼要，正确计算转换成本，代码简洁高效。

3. **Jorisy（4星）**  
   正确预处理选区，动态规划实现准确，代码可读性强。

## 最优思路或技巧提炼
- **差额处理**：将转换贡献视为2倍席位差，减少背包容量需求。
- **初始席位分离**：避免重复计算，确保逻辑正确。
- **逆序背包更新**：优化空间复杂度，确保正确性。

## 同类型题或类似算法套路
- **01背包变种**：如最小成本覆盖目标值、多维约束背包。
- **贪心与动态规划结合**：当物品具有特殊性质时，可结合贪心优化。

## 推荐题目
1. **P1060 [NOIP2006 普及组] 开心的金明**  
2. **P1048 [NOIP2005 普及组] 采药**  
3. **P2871 [USACO07DEC] Charm Bracelet**

## 个人心得摘录
- **初始席位的重要性**：未正确分离已赢选区会导致重复计算，需仔细处理。
- **背包方向选择**：逆序更新是01背包的关键，避免状态覆盖。

## 可视化与算法演示
### 核心算法过程
1. **选区分类**：高亮已赢选区（绿色），需转换选区（红色）。
2. **背包更新**：动态显示`dp`数组，当前处理物品的`Z_i`和`w_i`。
3. **结果展示**：标出满足阈值的最小成本。

### 复古游戏化设计
- **像素风格**：选区用像素方块表示，颜色区分状态。
- **音效提示**：选中物品时播放音效，成功找到解时播放胜利音乐。
- **自动演示**：AI自动选择物品，动态显示背包更新过程。

```cpp
// 核心代码示例（WilliamFranklin的题解）
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e2 + 5, MAXV = 1e5 + 5;
long long dp[MAXV];

int main() {
    int n, sum = 0;
    cin >> n;
    vector<pair<int, int>> items;
    int num1 = 0, total_z = 0;
    for (int i = 0; i < n; i++) {
        int x, y, z;
        cin >> x >> y >> z;
        total_z += z;
        if (x > y) {
            num1 += z;
        } else {
            int cost = max(0, (y - x + 1) / 2);
            items.emplace_back(z, cost);
        }
    }
    int threshold = (total_z + 1) / 2;
    if (num1 >= threshold) {
        cout << 0 << endl;
        return 0;
    }
    int req = threshold - num1;
    memset(dp, 0x3f, sizeof(dp));
    dp[0] = 0;
    for (auto [z, cost] : items) {
        for (int j = MAXV - 1; j >= z; j--) {
            dp[j] = min(dp[j], dp[j - z] + cost);
        }
    }
    long long ans = LLONG_MAX;
    for (int j = req; j < MAXV; j++) {
        ans = min(ans, dp[j]);
    }
    cout << ans << endl;
    return 0;
}
```

## 可视化设计要点
- **Canvas绘制**：选区为方块，颜色区分状态，背包数组实时更新。
- **步进控制**：支持暂停/继续，观察每一步的背包状态。
- **差额动态显示**：当前总席位与阈值对比，高亮满足条件的最小值。

---
处理用时：489.44秒
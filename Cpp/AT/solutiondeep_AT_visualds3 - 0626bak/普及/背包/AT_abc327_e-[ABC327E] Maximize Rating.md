# 题目信息

# [ABC327E] Maximize Rating

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc327/tasks/abc327_e

高橋君は $ N $ 回コンテストに参加し、$ i $ 回目に参加したコンテストにおいてパフォーマンス $ P_i $ を獲得しました。  
高橋君はこの中から ($ 1 $ つ以上) いくつかのコンテストを選び、それらの結果から計算される高橋君のレートを最大にしたいと考えています。

コンテストをうまく選んだとき、高橋君のレートとしてあり得る最大の値を求めてください。

ただし、高橋君のレート $ R $ は、高橋君の選んだコンテストの数が $ k $ 個であり、 選んだコンテストにおけるパフォーマンスが **参加した順に** それぞれ $ (Q_1,Q_2,\ldots,Q_k) $ であるとき、

$ \displaystyle\ R=\frac{\sum_{i=1}^k\ (0.9)^{k-i}Q_i}{\sum_{i=1}^k\ (0.9)^{k-i}}-\frac{1200}{\sqrt{k}} $ によって計算されます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 5000 $
- $ 1\leq\ P_i\leq\ 5000 $
- 入力はすべて整数

### Sample Explanation 1

高橋君が $ 1 $ 回目と $ 3 $ 回目のコンテストを選んだ時、レートは、 $ \displaystyle\ R=\frac{0.9\times\ 1000+\ 1.0\times\ 1200}{0.9+1.0}-\frac{1200}{\sqrt{2}}=256.73502... $ となり、この時レートが最大となります。

### Sample Explanation 2

$ 1,2,3 $ 回目のコンテストすべてを選んだとき、レートが最大となります。

### Sample Explanation 3

レートは負になることもあります。

## 样例 #1

### 输入

```
3
1000 600 1200```

### 输出

```
256.735020470879931```

## 样例 #2

### 输入

```
3
600 1000 1200```

### 输出

```
261.423219407873376```

## 样例 #3

### 输入

```
1
100```

### 输出

```
-1100.000000000000000```

# AI分析结果



---

## **算法分类**  
动态规划（0-1背包变种）

---

## **题解思路与算法要点**  

### **核心难点**  
1. **公式分解**：公式中的权重项（0.9的幂次）和分母项均与选择的子序列长度 $k$ 相关，需动态维护不同 $k$ 下的最优值。  
2. **动态规划状态设计**：需高效计算每个 $k$ 对应的最大加权和 $\sum (0.9)^{k-i}Q_i$，同时满足顺序约束。  

### **解决思路**  
1. **动态规划状态定义**：  
   - **二维状态**：$f[i][j]$ 表示前 $i$ 个元素中选 $j$ 个的最大加权和。  
   - **一维优化**：逆序更新 $f[j]$ 以节省空间（类似背包问题）。  
2. **预处理分母项**：预计算 $\sum_{i=1}^k (0.9)^{k-i}$，避免重复计算。  
3. **转移方程**：  
   $$f[j] = \max(f[j], f[j-1] \times 0.9 + P_i)$$  
   其中 $P_i$ 为当前元素的值，$j$ 表示已选元素数量。  

### **关键对比**  
- **数组反转**：部分题解将输入数组反转，使新增元素的权重为 $0.9^j$，简化计算（如 yydfj 的解法）。  
- **空间优化**：一维数组逆序更新比二维实现更节省内存（如 PikachuQAQ 的代码）。  

---

## **题解评分（≥4星）**  
1. **qqqaaazzz_qwq（5星）**  
   - **亮点**：清晰的二维状态设计，转移方程推导完整。  
   - **调试经验**：强调循环条件错误（`j<=i` vs `j<=n`），具有警示意义。  
2. **yydfj（4.5星）**  
   - **亮点**：数组反转与一维背包结合，代码简洁高效。  
   - **优化**：预处理权重系数，避免重复计算幂次。  
3. **PikachuQAQ（4星）**  
   - **亮点**：一维滚动数组优化，代码易读且内存高效。  
   - **调试提示**：初始值设为极小值避免未选状态干扰。  

---

## **最优思路提炼**  
1. **动态规划核心方程**：  
   - 选当前元素：$f[j] = f[j-1] \times 0.9 + P_i$（权重逐步累积）。  
   - 不选当前元素：保留前 $i-1$ 个元素的最优值。  
2. **预处理分母项**：利用递推式 $sum[k] = sum[k-1] \times 0.9 + 1$。  
3. **空间优化**：逆序更新一维数组，将空间复杂度从 $O(n^2)$ 降为 $O(n)$。  

---

## **类似题目推荐**  
1. **洛谷 P1064 [金明的预算方案]**（依赖型背包问题）  
2. **洛谷 P1541 [乌龟棋]**（多维动态规划）  
3. **洛谷 P4158 [粉刷匠]**（分组决策与动态规划）  

---

## **代码实现（核心片段）**  
```cpp
// 基于 PikachuQAQ 的一维优化实现
#include <iostream>
#include <cmath>
using namespace std;

const int N = 5005;
double f[N], sum[N], ans = -1e18;

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) {
        int p; cin >> p;
        for (int j = i; j >= 1; j--) {
            f[j] = max(f[j], f[j-1] * 0.9 + p);
        }
        sum[i] = sum[i-1] * 0.9 + 1; // 预处理分母项
    }
    for (int k = 1; k <= n; k++) {
        ans = max(ans, f[k] / sum[k] - 1200 / sqrt(k));
    }
    printf("%.10lf\n", ans);
    return 0;
}
```

---

## **可视化与算法演示**  
### **动画设计**  
1. **动态规划表更新**：  
   - **网格视图**：Canvas 绘制二维网格，每个格子 $(i,j)$ 表示 $f[j]$ 的值。  
   - **颜色高亮**：当前更新的格子用绿色标记，旧值用灰色。  
2. **权重系数动态显示**：  
   - 每个元素 $P_i$ 加入时，显示其权重 $0.9^{j-1}$ 的指数衰减过程。  
3. **音效与交互**：  
   - **音效**：每次更新播放短促“滴”声，完成计算后播放胜利音效。  
   - **步进控制**：用户可调节动画速度或单步执行观察状态转移。  

### **复古像素风格**  
- **8位调色板**：使用经典 FC 红/绿/蓝三色渲染网格和数值。  
- **自动演示模式**：AI 按最优路径自动更新状态，类似贪吃蛇移动。  

---

## **个人心得摘录**  
1. **qqqaaazzz_qwq**：  
   > 赛时把 `j<=i` 写成 `j<=n`，交了13发都没过。  
   **教训**：循环边界需严格验证，尤其在二维DP中。  

2. **yydfj**：  
   > 将数组反转，权重变为 $0.9^j$，简化了转移逻辑。  
   **优化技巧**：逆向思维处理顺序依赖问题。

---
处理用时：89.94秒
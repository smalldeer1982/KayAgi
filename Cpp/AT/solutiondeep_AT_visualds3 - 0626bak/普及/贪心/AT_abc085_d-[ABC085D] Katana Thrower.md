# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果



## 唯一算法分类
贪心算法

---

## 综合分析与结论

### 题目核心思路
本题核心是贪心策略：优先使用最高效的攻击方式，尽可能减少总攻击次数。关键在于：
1. **投掷高伤害刀**：投掷所有投掷伤害（b_i）大于最大挥砍伤害（max_a）的刀，每次攻击伤害最大化。
2. **剩余血量补刀**：用最大挥砍伤害的刀处理剩余血量。

### 解决难点
- **贪心顺序选择**：投掷伤害高的刀必须优先使用，但投掷后无法再挥砍。
- **最优补刀策略**：计算剩余血量时需确定用挥砍的刀，需处理除法和取余逻辑。

### 算法流程
1. **预处理**：找到所有刀中最大的挥砍伤害（max_a）。
2. **投掷处理**：按投掷伤害从高到低排序，选择所有投掷伤害大于 max_a 的刀进行投掷。
3. **补刀计算**：若投掷后怪物未死亡，用 max_a 的挥砍次数补足剩余血量。

### 可视化设计思路
- **动画演示**：用条形图展示每次攻击的伤害值，投掷操作高亮为红色，挥砍为蓝色。动态更新剩余血量。
- **步进控制**：允许用户逐次查看攻击顺序，观察投掷和挥砍的选择逻辑。
- **状态标记**：当前使用的刀和攻击类型（投掷/挥砍）在动画中明确标注。

---

## 题解清单 (≥4星)

### 1. Hilte 的题解（5星）
- **亮点**：明确分离投掷和挥砍逻辑，直接找出 max_a 后处理，代码简洁高效。
- **核心代码**：
  ```cpp
  for (int i = n; i >= 1 && b[i] > a[n] && h > 0; i--)
    h -= b[i], ans++;
  if (h > 0)
    ans += (h / a[n] + (h % a[n] != 0));
  ```

### 2. ITZDC9 的题解（4星）
- **亮点**：将挥砍和投掷统一排序处理，逻辑清晰，但需注意投掷与挥砍的排序细节。
- **核心代码**：
  ```cpp
  sort(k+1, k+c+1, cmp); // 按伤害排序
  while (h > 0) {
    if (k[i].t == 1) h -= k[i].m; // 投掷
    else { // 挥砍补刀
      ans += h / k[i].m + (h % k[i].m != 0);
      break;
    }
  }
  ```

### 3. Mysterious_Cat 的题解（4星）
- **亮点**：通过 vector 动态收集有效投掷刀，优化空间效率。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= n; ++i)
    if (i != p && b[i] >= a[p])
      v.push_back(b[i]);
  sort(v.begin(), v.end());
  ```

---

## 最优思路或技巧提炼

### 关键思路
1. **贪心选择**：投掷所有 b_i > max_a 的刀，确保每次攻击伤害最大化。
2. **补刀计算**：剩余血量用最大挥砍伤害的刀处理，需注意除法的向上取整。

### 实现技巧
- **预处理排序**：将投掷伤害按降序排列，便于顺序处理。
- **数学计算优化**：用 `h / a + (h % a != 0)` 快速计算挥砍次数，避免循环。

---

## 同类型题或类似算法套路

### 类似题目
1. **背包问题的贪心变种**：选择性价比最高的物品优先使用。
2. **区间覆盖问题**：选择覆盖范围最大的区间，逐步缩小目标范围。

### 通用解法
- **排序预处理**：将操作按效率排序。
- **分阶段处理**：先处理高效操作，剩余部分用基础操作补足。

---

## 推荐题目
1. **P1223 排队接水**（贪心排序）
2. **P1094 纪念品分组**（双指针贪心）
3. **P3817 小A的糖果**（贪心分配）

---

## 个人心得摘录

### 调试教训
- **变量初始化**：未初始化 max_a 可能导致错误（Hilte 题解）。
- **类型混淆**：误将投掷和挥砍伤害比较时未统一数据类型（ITZDC9 题解）。

### 优化经验
- **数学代替循环**：用除法和取余快速计算补刀次数，避免超时（Hilte 题解）。

---

## 可视化与算法演示

### 动画设计
- **像素风格**：用 8-bit 像素块表示刀的攻击，红色为投掷，蓝色为挥砍。
- **步进演示**：点击按钮逐步执行攻击，显示当前伤害和剩余血量。
- **音效提示**：投掷时播放“投掷音效”，挥砍时播放“挥砍音效”。

### 核心逻辑演示
```javascript
// 伪代码示例
function simulateAttack() {
  let maxSlash = Math.max(...a); // 最大挥砍伤害
  let throws = b.filter(d => d > maxSlash).sort((x,y) => y-x);
  let total = 0, damage = 0;
  
  for (let t of throws) {
    if (damage >= H) break;
    damage += t;
    total++;
    drawAttack(t, 'throw'); // 绘制投掷动画
  }
  
  if (damage < H) {
    let remain = H - damage;
    let count = Math.ceil(remain / maxSlash);
    total += count;
    drawSlashRepeatedly(maxSlash, count); // 绘制多次挥砍
  }
}
```

### 交互设计
- **速度调节**：滑动条控制动画速度。
- **自动播放**：AI 自动执行最优攻击序列，高亮当前操作。

---
处理用时：284.73秒
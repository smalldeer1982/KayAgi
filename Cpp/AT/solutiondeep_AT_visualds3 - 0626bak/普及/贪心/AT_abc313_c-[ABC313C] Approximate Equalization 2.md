# 题目信息

# [ABC313C] Approximate Equalization 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc313/tasks/abc313_c

整数列 $ A=(A_1,A_2,\dots,A_N) $ があります。 あなたは次の操作を好きな回数（$ 0 $ 回でもよい）行うことができます。

- $ 1\leq\ i,j\ \leq\ N $ を満たす整数 $ i,j $ を選ぶ。$ A_i $ を $ 1 $ 減らし、$ A_j $ を $ 1 $ 増やす。
 
$ A $ の最小値と最大値の差を $ 1 $ 以下にするために必要な最小の操作回数を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

以下のように $ 3 $ 回の操作を行うことで、$ A $ の最小値と最大値の差を $ 1 $ 以下にすることができます。 - $ i=2,j=3 $ として操作を行う。$ A=(4,6,4,7) $ になる。 - $ i=4,j=1 $ として操作を行う。$ A=(5,6,4,6) $ になる。 - $ i=4,j=3 $ として操作を行う。$ A=(5,6,5,5) $ になる。 $ 3 $ 回未満の操作で $ A $ の最小値と最大値の差を $ 1 $ 以下にすることはできません。よって答えは $ 3 $ です。

## 样例 #1

### 输入

```
4

4 7 3 7```

### 输出

```
3```

## 样例 #2

### 输入

```
1

313```

### 输出

```
0```

## 样例 #3

### 输入

```
10

999999997 999999999 4 3 2 4 999999990 8 999999991 999999993```

### 输出

```
2499999974```

# AI分析结果



### 唯一算法分类
贪心算法 / 数学推导

---

### 题解思路、算法要点与解决难点

#### 核心思路
所有题解均基于以下数学观察：
1. **总和守恒**：操作不改变数组总和，最终数组元素只能是 `floor(sum/n)` 和 `ceil(sum/n)` 两种值。
2. **目标数组构造**：最终有 `sum%n` 个元素为 `ceil(sum/n)`，其余为 `floor(sum/n)`。
3. **排序对齐**：将原数组排序后，与构造的目标数组一一对应，计算绝对差之和后除以 2。

#### 算法步骤
1. **计算总和** `sum = Σa[i]`，确定基准值 `base = sum//n`，余数 `r = sum%n`。
2. **构造目标数组**：后 `r` 个元素为 `base+1`，其余为 `base`。
3. **排序原数组**，使其与目标数组按升序一一对应。
4. **计算绝对差之和** `Σ|a[i]-b[i]|`，除以 2 得到操作次数。

#### 解决难点
- **正确构造目标数组**：必须将 `base+1` 分配给较大的原数组元素，确保差值和最小。
- **操作次数计算**：每次操作同时影响两个元素的差值，总操作次数为绝对差之和的 ½。

---

### 题解评分（≥4星）

1. **Dream_poetry（5星）**
   - 思路清晰，直接构造目标数组并排序对齐。
   - 代码简洁，逻辑明确，时间复杂度 `O(n log n)`。
   - 关键代码：
     ```cpp
     sort(a,a+n); 
     for(int i=0;i<sum%n;i++) b[n-1-i]++;
     ```

2. **Frictional（4星）**
   - 逆向排序后直接计算差值，无需显式构造目标数组。
   - 使用降序排序优化差值计算：
     ```cpp
     sort(a,a+n,cmp); // 降序排序
     if(i < r) ans += abs(base+1 - a[i]); 
     ```

3. **liangbob（4星）**
   - 通过数学推导明确操作次数公式 `k = |a_i-b_i| / 2`。
   - 显式构造目标数组，逻辑易于理解：
     ```cpp
     for(int i=1;i<=n - r;i++) b[i] = base;
     for(int i=1;i<=r;i++) b[n-i+1]++;
     ```

---

### 最优思路或技巧提炼

1. **数学建模**
   - 利用总和守恒推导目标数组形式，避免复杂动态调整。

2. **排序对齐**
   - 原数组与目标数组均排序后一一对应，保证差值和最小。

3. **差值计算优化**
   - 绝对差之和除以 2 即为操作次数，避免逐个模拟操作。

---

### 同类型题与算法套路

1. **分配类问题**：如 [CF609C](https://codeforces.com/problemset/problem/609/C)，要求元素平均化。
2. **数学构造题**：通过总和或均值确定目标状态，如 [LeetCode 462. Minimum Moves to Equal Array Elements II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)。

---

### 推荐相似题目

1. **P1031 均分纸牌** - 线性分配问题，贪心求解。
2. **P1968 美元汇率** - 数学推导最优交易策略。
3. **P3143 [USACO16OPEN] Diamond Collector S** - 排序后滑动窗口求最大区间。

---

### 可视化与算法演示设计

#### 核心动画流程
1. **原数组排序**：显示数组元素升序排列过程。
2. **目标数组构造**：高亮后 `r` 个元素为 `base+1`（红色），其余为 `base`（蓝色）。
3. **差值计算**：以连线连接原数组与目标数组对应元素，显示绝对差值。
4. **操作次数统计**：动态累加差值，最后显示除以 2 的结果。

#### 复古像素风格实现
- **颜色方案**：8-bit 风格，原数组绿色，目标数组红/蓝，差值黄色。
- **音效**：
  - 排序完成：8-bit 上升音阶。
  - 差值计算：每对元素匹配时播放 "blip" 音效。
- **Canvas 绘制**：元素表示为像素方块，差值连线为虚线动画。

#### 交互功能
- **步进控制**：按空格键逐步执行排序、构造、计算步骤。
- **速度调节**：滑块控制动画速度（0.5x~2x）。

---

### 关键代码片段（Python伪代码）

```python
# 构造目标数组
base, r = sum(a) // n, sum(a) % n
target = [base] * (n - r) + [base + 1] * r

# 计算绝对差之和
sorted_a = sorted(a)
total_diff = sum(abs(x - y) for x, y in zip(sorted_a, target))
print(total_diff // 2)
```

---

### 个人心得摘录

> "最初尝试逐个调整最大最小值，发现超时后才意识到数学构造是唯一可行解。排序后对齐的差值和除以 2 的推导让我豁然开朗。" —— 用户「梦应归于何处」

---
处理用时：73.90秒
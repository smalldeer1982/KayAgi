# 题目信息

# [ABC333E] Takahashi Quest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_e

高橋くんは冒険に出ようとしています。

冒険では、$ N $ 個の出来事が起こります。 $ i $ 番目 $ (1\leq\ i\leq\ N) $ の出来事は整数の組 $ (t\ _\ i,x\ _\ i) $ $ (1\leq\ t\ _\ i\leq\ 2,1\leq\ x\ _\ i\leq\ N) $ で表され、次のような出来事です。

- $ t\ _\ i=1 $ のとき、タイプ $ x\ _\ i $ のポーションを $ 1 $ つ発見する。高橋くんは、発見したポーションを拾うか捨てるかのどちらかを選択する。
- $ t\ _\ i=2 $ のとき、タイプ $ x\ _\ i $ のモンスター $ 1 $ 体と遭遇する。高橋くんがタイプ $ x\ _\ i $ のポーションを持っている場合、それを $ 1 $ つ消費することでモンスターを撃退することができる。モンスターを撃退しなかった場合、高橋くんは敗北する。
 
高橋くんが敗北することなく全てのモンスターを撃退することができるか判定してください。

高橋くんが全てのモンスターを撃退することができない場合、`-1` を出力してください。

高橋くんが全てのモンスターを撃退することができる場合、高橋君が冒険の途中で持っているポーションの個数の最大値を $ K $ とします。 高橋くんが敗北しないような戦略全体にわたる $ K $ の最小値を $ K\ _\ {\min} $ とします。 $ K\ _\ {\min} $ の値と、$ K\ _\ {\min} $ を達成する高橋くんの行動を出力してください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq2\times10^5 $
- $ 1\leq\ t\ _\ i\leq2\ (1\leq\ i\leq\ N) $
- $ 1\leq\ x\ _\ i\leq\ N\ (1\leq\ i\leq\ N) $
- 入力はすべて整数
 
### Sample Explanation 1

出力例は、次のような行動に対応しています。 - タイプ $ 2,3,1 $ のポーションをこの順に発見する。これらのポーションをすべて拾う。 - タイプ $ 3,2 $ のポーションをこの順に発見する。これらのポーションをいずれも拾わない。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾う。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾わない。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のポーションを発見する。このポーションを拾う。 - タイプ $ 2 $ のモンスターと遭遇する。持っているタイプ $ 2 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 3 $ のモンスターと遭遇する。持っているタイプ $ 3 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 - タイプ $ 1 $ のモンスターと遭遇する。持っているタイプ $ 1 $ のポーションを $ 1 $ つ消費してモンスターを撃退する。 この行動では、$ K $ の値は $ 3 $ となります。 $ K\leq\ 2 $ として敗北しない方法はないので、求める $ K\ _\ {\min} $ の値は $ 3 $ です。 $ K=3 $ を満たして高橋くんが敗北しない行動は複数ありますが、どれを出力しても構いません。

### Sample Explanation 2

高橋くんはかならず最初に遭遇するモンスターに敗北してしまいます。

## 样例 #1

### 输入

```
13

1 2

1 3

1 1

1 3

1 2

2 3

1 3

1 3

2 3

1 3

2 2

2 3

2 1```

### 输出

```
3

1 1 1 0 0 1 0 1```

## 样例 #2

### 输入

```
4

2 3

1 4

2 1

1 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
30

1 25

1 2

1 10

1 18

2 18

1 11

2 11

1 21

1 6

2 2

2 10

1 11

1 24

1 11

1 3

1 2

1 18

2 25

1 8

1 10

1 11

2 18

2 10

1 10

2 2

1 24

1 10

2 10

1 25

2 6```

### 输出

```
4

1 1 1 1 1 0 1 0 0 0 0 1 1 0 1 0 1 0 0 0```

# AI分析结果



**唯一算法分类**：贪心算法

---

## 综合分析与结论

### 核心思路与难点
- **核心思路**：  
  采用贪心策略，每次遇到怪物时优先使用**最近捡到的对应类型药水**。通过栈结构保存每种药水的出现时间，确保每次取药水时选择最晚出现的那瓶，从而最小化药水在背包中的停留时间。

- **解决难点**：  
  1. **贪心正确性**：需证明选择最晚出现的药水能保证最大持有量最小。  
  2. **数据结构优化**：用栈按时间逆序处理事件，动态维护药水使用顺序。  
  3. **统计最大值**：通过遍历事件记录药水数量变化，实时更新最大值。

### 算法流程
1. **预处理**：遍历所有事件，用栈保存每个药水类型的出现时间。  
2. **处理怪物事件**：遇到怪物时，检查对应栈是否为空。若为空则无解；否则弹出栈顶药水（最近出现的），标记该药水被使用。  
3. **统计最大值**：再次遍历事件，根据标记动态计算每个时刻的药水数量，记录最大值。

---

## 题解清单 (≥4星)

1. **作者：2020luke (5星)**  
   **亮点**：  
   - 简洁清晰的栈实现，代码易读。  
   - 实时统计最大值，逻辑直接。  
   **代码片段**：  
   ```cpp
   stack<int> st[N]; // 维护每种药水的出现时间
   for (int i = 1; i <= n; i++) {
       if (t[i] == 1) st[x[i]].push(i);
       else {
           flag[st[x[i]].top()] = 1; // 标记被使用的药水
           st[x[i]].pop();
       }
   }
   ```

2. **作者：OAer (4星)**  
   **亮点**：  
   - 通过差分数组优化统计过程。  
   - 使用 `exit(0)` 提前终止，减少冗余计算。  
   **代码片段**：  
   ```cpp
   for (int i = n; i >= 1; i--) {
       if (a[i].x == 1) ans[sta[i]] = 1; // 差分标记区间
   }
   ```

3. **作者：STARSczy (4星)**  
   **亮点**：  
   - 使用逆向思维处理事件。  
   - 代码注释详细，适合初学者理解。  
   **代码片段**：  
   ```cpp
   for (int i = n; i >= 1; i--) {
       if (a[i].x == 1) t[x].push(i); // 逆向处理药水
   }
   ```

---

## 最优思路与技巧

- **贪心选择**：优先使用最近出现的药水，缩短其在背包中的停留时间。  
- **数据结构**：栈结构天然支持后进先出，符合“最近使用”需求。  
- **差分优化**：通过区间标记减少统计复杂度，避免重复遍历。

---

## 类似题目推荐

1. **P1540 [NOIP2010 提高组] 机器翻译**  
   - 类似利用队列维护最近使用的数据。  
2. **P1165 日志分析**  
   - 维护最大值，结合栈的贪心策略。  
3. **P4387 【深基15.习9】验证栈序列**  
   - 栈的动态操作与本题药水选择逻辑相似。

---

## 可视化设计

### 动画方案
- **像素风格**：药水为蓝色方块，怪物为红色骷髅头，栈用垂直柱状图表示。  
- **关键步骤**：  
  1. **捡药水**：药水压入对应栈，播放“拾取”音效。  
  2. **遇怪物**：栈顶药水弹出并飞向怪物，播放“使用”音效。  
  3. **统计图**：底部动态折线图显示当前药水数量，峰值高亮。

### 交互功能
- **步进控制**：允许暂停/继续/单步执行，速度可调。  
- **自动演示**：按事件顺序自动播放，背景音乐为8位循环曲。  
- **音效设计**：  
  - 成功使用药水：清脆“叮”声。  
  - 无解：低沉错误音效。  

---

## 代码实现（核心逻辑）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
stack<int> st[N];
int t[N], x[N], flag[N], n;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> t[i] >> x[i];
        if (t[i] == 1) st[x[i]].push(i);
        else {
            if (st[x[i]].empty()) { cout << "-1"; return 0; }
            flag[st[x[i]].top()] = 1;
            st[x[i]].pop();
        }
    }
    int cnt = 0, max_k = 0;
    for (int i = 1; i <= n; i++) {
        if (flag[i]) cnt++;
        else if (t[i] == 2) cnt--;
        max_k = max(max_k, cnt);
    }
    cout << max_k << "\n";
    for (int i = 1; i <= n; i++) 
        if (t[i] == 1) cout << flag[i] << " ";
    return 0;
}
```

---

**个人心得**：  
调试时需注意栈的实时状态，确保每个怪物都有对应药水。逆向处理事件时，需注意索引越界问题。

---
处理用时：107.75秒
# 题目信息

# [ABC334C] Socks 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_c

高橋君は $ N $ 組の靴下を持っており、$ i $ 番目の組は色 $ i $ の靴下 $ 2 $ 枚からなります。 ある日タンスの中を整理した高橋君は、色 $ A_1,A_2,\dots,A_K $ の靴下を $ 1 $ 枚ずつなくしてしまったことに気づいたので、残っている $ 2N-K $ 枚の靴下を使って、靴下 $ 2 $ 枚ずつからなる $ \lfloor\frac{2N-K}{2}\rfloor $ 個の組を新たに作り直すことにしました。 色 $ i $ の靴下と色 $ j $ の靴下からなる組の**奇妙さ**は $ |i-j| $ として定義され、高橋君は奇妙さの総和をできるだけ小さくしたいです。

残っている靴下をうまく組み合わせて $ \lfloor\frac{2N-K}{2}\rfloor $ 個の組を作ったとき、奇妙さの総和が最小でいくつになるか求めてください。 なお、$ 2N-K $ が奇数のとき、どの組にも含まれない靴下が $ 1 $ 枚存在することに注意してください。

## 说明/提示

### 制約

- $ 1\leq\ K\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_1\ <\ A_2\ <\ \dots\ <\ A_K\ \leq\ N $
- 入力は全て整数

### Sample Explanation 1

以下、色 $ i $ の靴下と色 $ j $ の靴下からなる組を $ (i,j) $ と表記します。 色 $ 1,2,3,4 $ の靴下がそれぞれ $ 1,2,1,2 $ 枚ずつあります。 $ (1,2),(2,3),(4,4) $ の $ 3 $ 組を作ると、奇妙さの総和は $ |1-2|+|2-3|+|4-4|=2 $ となり、これが最小です。

### Sample Explanation 2

$ (1,1),(3,3),(4,4),(5,5) $ の $ 4 $ 組を作り、色 $ 2 $ の靴下を $ 1 $ 枚余らせる（どの組にも入れない）のが最適です。

## 样例 #1

### 输入

```
4 2
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
5 1
2```

### 输出

```
0```

## 样例 #3

### 输入

```
8 5
1 2 4 7 8```

### 输出

```
2```

# AI分析结果



# 算法分类
**贪心+前缀和优化**

---

## 题解思路与解决难点

### 核心思路
1. **贪心配对**：将丢失的袜子颜色排序后，相邻配对可得到最小差异值。
2. **奇数处理**：当丢失袜子数为奇数时，需枚举舍弃的袜子，利用前缀和和后缀和快速计算最优解。

### 关键步骤
- **排序**：将丢失的袜子颜色数组排序。
- **前缀/后缀和预处理**：
  - `b[i]` 表示前 `i` 项中相邻配对的总差异。
  - `e[i]` 表示从 `i` 开始到末尾的相邻配对总差异。
- **奇数枚举**：枚举每个可能的舍弃点，计算 `b[i-1] + e[i+1]`（舍弃奇数位）或 `b[i-2] + e[i+2] + 跨越差异`（舍弃偶数位）。

### 解决难点
- **时间复杂度优化**：通过预处理前缀和和后缀和，将枚举操作的时间复杂度从 O(K²) 降为 O(K)。
- **边界处理**：正确处理奇偶位置的舍弃点对前缀/后缀和的影响。

---

## 题解评分（≥4星）

### 1. Albatross_LC（5星）
- **亮点**：完整的前缀/后缀和推导，清晰的奇偶分治逻辑，代码结构清晰。
- **核心代码**：
```cpp
for (int i = 2; i <= k; i += 2)
    b[i] = b[i - 2] + a[i] - a[i - 1];
for (int i = k - 1; i > 0; i -= 2)
    e[i] = e[i + 2] + a[i + 1] - a[i];
```

### 2. FReQuenter（4.5星）
- **亮点**：简洁的前缀和实现，直接利用数组下标处理奇偶。
- **核心代码**：
```cpp
for (int i = 2; i <= k; i += 2)
    zs[i] = zs[i - 2] + a[i] - a[i - 1];
for (int i = k - 1; i >= 1; i--)
    ds[i] = ds[i + 2] + a[i + 1] - a[i];
```

### 3. Jubingkun（4星）
- **亮点**：结合图示解释前缀/后缀和的作用，代码注释详细。
- **核心代码**：
```cpp
for (int i = 2; i <= k; i += 2)
    pre_f[i >> 1] = pre_f[(i >> 1) - 1] + a[i] - a[i - 1];
for (int i = k; i >= 1; i -= 2)
    pre_b[...] = pre_b[...] + a[i] - a[i - 1];
```

---

## 最优思路提炼
1. **相邻配对最优性**：排序后相邻配对可最小化单次差异。
2. **前缀/后缀和加速**：预处理奇偶位置的前缀和后缀和，快速计算舍弃点的总差异。
3. **枚举舍弃点**：仅需线性遍历所有可能的舍弃点，利用预计算值快速比较。

---

## 类似题目推荐
1. **洛谷 P1090**（合并果子）：贪心选择最小代价合并。
2. **LeetCode 1167**（连接木棍的最小代价）：类似相邻合并优化思想。
3. **Atcoder ABC220D**（线性动态规划与前缀和）。

---

## 可视化设计
### 动画流程
1. **排序展示**：将袜子颜色按升序排列，用不同颜色标记每对相邻元素。
2. **前缀/后缀和构建**：
   - 前缀和：从左到右逐步累加相邻差异，高亮当前处理的对。
   - 后缀和：从右到左反向累加，用不同颜色区分。
3. **舍弃点枚举**：
   - 用闪烁效果标记当前舍弃的袜子。
   - 显示对应的前缀和和后缀和部分，动态更新总差异值。

### 复古像素风格
- **颜色方案**：16色调色板，绿色表示正常配对，红色表示舍弃点。
- **音效**：配对时播放8-bit点击音效，舍弃点切换时播放短促音效。

### 交互设计
- **步进控制**：允许用户单步执行前缀/后缀和构建。
- **自动模式**：AI自动选择最优舍弃点，展示计算路径。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int a[N], b[N], e[N];

int main() {
    int n, k; cin >> n >> k;
    for (int i = 1; i <= k; ++i) cin >> a[i];
    sort(a + 1, a + k + 1);
    
    if (k % 2 == 0) {
        int ans = 0;
        for (int i = 1; i <= k; i += 2)
            ans += a[i + 1] - a[i];
        cout << ans;
    } else {
        // 前缀和（从左到右）
        for (int i = 2; i <= k; i += 2)
            b[i] = b[i - 2] + a[i] - a[i - 1];
        // 后缀和（从右到左）
        for (int i = k - 1; i >= 1; i -= 2)
            e[i] = e[i + 2] + a[i + 1] - a[i];
        
        int ans = INT_MAX;
        // 枚举舍弃奇数位
        for (int i = 1; i <= k; i += 2)
            ans = min(ans, b[i - 1] + e[i + 1]);
        // 枚举舍弃偶数位
        for (int i = 2; i <= k; i += 2)
            ans = min(ans, b[i - 2] + e[i + 2] + a[i + 1] - a[i - 1]);
        cout << ans;
    }
    return 0;
}
```

---
处理用时：83.98秒
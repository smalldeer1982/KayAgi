# 题目信息

# [ABC376E] Max × Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_e

長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N),\ B\ =\ (B_1,\ B_2,\ \dots,\ B_N) $ が与えられます。  
$ \lbrace\ 1,\ 2,\ \dots,\ N\ \rbrace $ の部分集合であって大きさが $ K $ のものを $ 1 $ つ選び $ S $ とします。この時、以下の式の値としてあり得る最小値を求めてください。

$ \displaystyle\ \left(\max_{i\ \in\ S}\ A_i\right)\ \times\ \left(\sum_{i\ \in\ S}\ B_i\right) $ 

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^6 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数

### Sample Explanation 1

$ 1 $ 番目のテストケースでは、$ S\ =\ \lbrace\ 2,\ 3\ \rbrace $ を選ぶと式の値が $ 7\ \times\ (2\ +\ 4)\ =\ 42 $ になり、これが最小です。

## 样例 #1

### 输入

```
3
3 2
3 7 6
9 2 4
5 3
6 4 1 5 9
8 6 5 1 7
10 6
61 95 61 57 69 49 46 47 14 43
39 79 48 92 90 76 30 16 30 94```

### 输出

```
42
60
14579```

# AI分析结果



## 算法分类
贪心、优先队列（堆）

---

## 综合分析与结论

### 核心思路
1. **排序预处理**：将数组按 A 值升序排序，确保后续枚举的每个元素的 A 值为当前最大值。
2. **贪心维护最小和**：对于每个元素 A[i]，其对应的 B[i] 必须被选中。剩下的 K-1 个元素需从前 i-1 个元素中选 B 值最小的 K-1 个。
3. **优先队列优化**：使用最大堆维护当前已选元素中的最大 B 值。动态调整堆的大小，保证堆中始终保留最小的 K 个 B 值之和。

### 解决难点
- **动态维护最小和**：通过最大堆实时调整，确保每次计算时能快速获取前 K 个最小 B 值的和。
- **时间复杂度控制**：排序 O(N log N) + 堆操作 O(N log K)，满足题目约束。

### 可视化设计
- **动画效果**：展示数组按 A 排序后的状态，用不同颜色标记当前枚举的 A[i]（最大值）。堆动态变化，每次插入新 B 值后弹出较大元素，高亮当前堆顶元素。
- **步进控制**：允许单步执行观察堆的调整过程，显示当前总和和候选答案的更新。
- **复古像素风格**：用 8-bit 风格显示堆的调整，每次弹出/插入时触发音效，背景播放循环芯片音乐。

---

## 题解清单（评分≥4星）

### 1. light_searcher（5星）
- **亮点**：代码简洁，直接维护 K 个最小 B 值，通过堆自动调整。
- **核心代码**：
```cpp
priority_queue<int> q;
for(int i=1;i<k;i++) q.push(a[i].b);
for(int i=k;i<=n;i++) {
    q.push(a[i].b);
    sum += a[i].b;
    if(q.size()>k) {
        sum -= q.top();
        q.pop();
    }
    ans = min(ans, a[i].a*sum);
}
```

### 2. Sih_qwq（5星）
- **亮点**：正确处理必须包含当前 B[i] 的逻辑，动态维护堆的大小。
```cpp
priority_queue<int> q;
for(int i=1;i<=k;i++) q.push(a[i].b), sum += a[i].b;
ans = sum * a[k].a;
for(int i=k+1;i<=n;i++) {
    if(a[i].b < q.top()) {
        sum += a[i].b - q.top();
        q.pop();
        q.push(a[i].b);
    }
    ans = min(ans, sum*a[i].a);
}
```

### 3. chenxi2009（4星）
- **亮点**：明确维护 K-1 个最小 B 值，逐步扩展候选集。
```cpp
priority_queue<int> q;
for(int i=1;i<k;i++) q.push(a[i].b);
for(int i=k;i<=n;i++) {
    ans = min(ans, (sum + a[i].b)*a[i].a);
    q.push(a[i].b);
    sum += a[i].b;
    if(q.size() > k-1) {
        sum -= q.top();
        q.pop();
    }
}
```

---

## 最优思路提炼
1. **排序定序**：按 A 升序排序，确保枚举的每个元素可作为当前最大值。
2. **堆维护极值**：用最大堆维护前 K 个最小 B 值，动态调整保证堆大小。
3. **实时更新答案**：每次枚举时计算当前可能的最小乘积，逐步更新全局答案。

---

## 相似题目推荐
1. [P2947 Look Up](https://www.luogu.com.cn/problem/P2947)（单调栈维护右侧第一个更大元素）
2. [P1631 序列合并](https://www.luogu.com.cn/problem/P1631)（堆维护前 K 小和）
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)（单调队列维护极值）

---

## 可视化算法演示
**核心步骤动画**：
1. 初始数组按 A 排序，B 跟随调整。
2. 最大堆初始填充前 K-1 个 B 值。
3. 枚举每个 A[i] 时：
   - 插入当前 B[i] 至堆，调整堆大小。
   - 计算当前总和，更新答案。
   - 高亮当前堆顶和答案变化。

**复古像素效果**：
- 数组元素显示为 16x16 像素块，A 值用高度表示，B 值用颜色区分。
- 堆调整时播放 8-bit 音效，成功更新答案时播放胜利音效。

---
处理用时：449.67秒
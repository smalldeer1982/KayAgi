# 题目信息

# [ABC379C] Sowing Stones

## 题目描述

给你两个数 $n$，$m$。

表示现在有 $n$ 个格子，再给你 $m$ 组数据，表示在第 $X_i$ 个格子上有 $A_i$ 个石头。

有以下操作（可以不移动）。

- 对于第 $i$ 个格子，如果这个格子上有石头 ，可以将这个格子的一个石头移动到第 $i+1$ 个格子上。

求使得每个格子上恰好有一个石头的最小移动次数，如果无法满足条件输出 $-1$。


- 第一行：$N$ $M$ 

- 第二行：$X_1$ $X_2$ $\ldots$ $X_M$

- 第三行：$A_1$ $A_2$ $\ldots$ $A_M$

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^{9} $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^{5} $
- $ M\ \leq\ N $
- $ 1\ \leq\ X_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ X_i\ \neq\ X_j $ $ (1\ \leq\ i\ <\ j\ \leq\ M) $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^{9} $ $ (1\ \leq\ i\ \leq\ M) $
- 输入为整数
 
### Sample Explanation 1

可以通过如下 $4$ 次操作使条件满足，且没有比 $4$ 次更小的次数。

初始条件：第一个格子上有 $3$ 个石头，第四个格子上有 $2$ 个石头。

- 移动一个石头从格子 $1$ 到格子 $2$。

- 再移动一个石头从格子 $1$ 到格子 $2$。 

- 移动一个石头从格子 $2$ 到格子 $3$。

- 移动一个石头从格子 $4$ 到格子 $5$。

操作完成后每个格子上都有一个石头。

### Sample Explanation 2

这个数据中无论如何移动一定无法使每个格子上有一个石头。

## 样例 #1

### 输入

```
5 2

1 4

3 2```

### 输出

```
4```

## 样例 #2

### 输入

```
10 3

1 4 8

4 2 4```

### 输出

```
-1```

# AI分析结果



---

## **唯一算法分类**  
**贪心算法**

---

## **综合分析与结论**  
### **题解思路与核心难点**  
题目要求通过移动石子使每个格子恰好一个，需最小操作次数。核心思路为：  
1. **排序**：按石子位置排序，确保处理顺序正确。  
2. **边界检查**：首个石子必在位置1，否则无法覆盖前面格子；石子总数必须等于n。  
3. **区间处理**：对相邻石子间的空白区，计算填满所需石子数。  
   - 若当前石子不足以覆盖区间，无解。  
   - 若足够，用等差数列求和计算填满操作的步数，并将多余石子传递至下一位置。  
4. **传递优化**：将多余石子视为下一位置的初始值，继续处理后续区间。  

**难点**：正确计算移动步数（尤其涉及等差数列和传递叠加）和严格处理边界条件。

### **可视化设计思路**  
- **动画流程**：  
  1. 初始石子位置高亮显示，按排序后顺序逐个处理。  
  2. 对每个区间，动态显示石子填充空白区的过程（如从左到右逐步填满），颜色标记当前操作区间。  
  3. 传递多余石子时，用箭头动画表示移动路径，并实时更新下一位置的石子数。  
- **交互功能**：  
  - **步进控制**：允许单步执行，观察每个区间的处理细节。  
  - **高亮关键变量**：如当前区间长度、剩余石子数、累计步数。  
- **复古像素风格**：  
  - 用8-bit风格渲染格子，石子用像素方块表示，移动时播放经典音效（如“移动”音效为短促滴答声）。  
  - 错误提示时播放低音效，成功时播放欢快旋律。  

---

## **题解评分 (≥4星)**  
1. **Po7ed 题解 (4.5星)**  
   - **亮点**：代码清晰，严格处理边界条件，巧妙添加虚拟终点（n+1）简化逻辑。  
   - **引用心得**：“赛时吃了5发罚时，细节多的题要冷静分析。”  

2. **I_Love_DS 题解 (4星)**  
   - **亮点**：逆向思维（从后往前填充），用等差数列公式直接计算贡献。  
   - **代码简洁性**：变量命名清晰，逻辑紧凑。  

3. **kairuigg 题解 (4星)**  
   - **亮点**：分类讨论三种情况，直观展示不同场景的处理逻辑。  
   - **注释丰富**：关键步骤配有详细注释，便于理解。  

---

## **最优思路与技巧提炼**  
1. **排序预处理**：确保处理顺序正确，避免漏判边界。  
2. **等差数列求和**：填满区间的步数为 `(长度 * (长度-1)) / 2`。  
3. **石子传递机制**：将多余石子传递至下一位置，叠加计算移动步数（长度 * 剩余数）。  
4. **虚拟终点技巧**：添加 `n+1` 位置统一处理最后一段区间。  

---

## **同类型题与算法套路**  
- **类似问题**：区间覆盖、资源分配问题（如均分纸牌）。  
- **通用解法**：排序后贪心处理相邻区间，动态维护剩余资源。  

---

## **推荐相似题目**  
1. **P1223 排队接水**（贪心排序，最小等待时间）  
2. **P1094 纪念品分组**（双指针处理区间配对）  
3. **P1031 均分纸牌**（传递机制与步数计算）  

---

## **个人心得摘录**  
- **Po7ed**：强调冷静处理细节，如首位置必须为1。  
- **CaoSheng_zzz**：提醒注意“石子总数是否等于n”的隐蔽条件。  

---

## **核心代码实现**  
```cpp
// 基于 Po7ed 题解的精简版代码
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXM = 2e5 + 5;

struct Node { ll x, a; } a[MAXM];

int main() {
    ll n, m; cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> a[i].x;
    for (int i = 1; i <= m; i++) cin >> a[i].a, a[i].a--;
    sort(a + 1, a + m + 1, [](Node& p, Node& q) { return p.x < q.x; });
    if (a[1].x != 1) { cout << -1; return 0; }

    a[m + 1].x = n + 1; // 虚拟终点
    ll ans = 0;
    for (int i = 1; i <= m; i++) {
        ll tmp = a[i + 1].x - a[i].x - 1;
        if (a[i].a < tmp) { cout << -1; return 0; }
        ans += tmp * (tmp + 1) / 2; // 填满区间步数
        a[i].a -= tmp;
        ans += (tmp + 1) * a[i].a; // 传递多余石子步数
        a[i + 1].a += a[i].a;
    }
    if (a[m + 1].a > 0) cout << -1;
    else cout << ans;
    return 0;
}
```

---

## **可视化实现片段（JS伪代码）**  
```javascript
// Canvas 渲染石子移动动画（关键逻辑）
function drawStep(ctx, stones, currentIndex) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    stones.forEach((stone, idx) => {
        drawStone(ctx, stone.x, stone.count, idx === currentIndex ? 'red' : 'green');
    });
}

function animateTransfer(src, dest, steps) {
    let step = 0;
    const interval = setInterval(() => {
        if (step >= steps) {
            clearInterval(interval);
            return;
        }
        playSound('move'); // 播放移动音效
        drawArrow(src.x, dest.x);
        step++;
    }, 500);
}
```

---
处理用时：97.29秒
# 题目信息

# [ABC393D] Swap to Gather

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc393/tasks/abc393_d

给定一个由 `0` 和 `1` 组成的长度为 $ N $ 的字符串 $ S $。保证 $ S $ 中至少包含一个 `1`。

你可以重复以下操作任意次数（包括零次）：

- 选择一个满足 $ 1 \leq i \leq N-1 $ 的整数 $ i $，交换 $ S $ 的第 $ i $ 个字符和第 $ i+1 $ 个字符。

求使所有 `1` 聚集在一起所需的最小操作次数。

这里，所有 `1` 聚集在一起的定义是：存在整数 $ l, r \ (1 \leq l \leq r \leq N) $，使得对于 $ S $ 的第 $ i $ 个字符，当且仅当 $ l \leq i \leq r $ 时为 `1`，否则为 `0`。

## 说明/提示

### 约束条件

- $ 2 \leq N \leq 5 \times 10^5 $
- $ N $ 为整数
- $ S $ 是由 `0` 和 `1` 组成的长度为 $ N $ 的字符串
- $ S $ 中至少包含一个 `1`

### 样例解释 1

例如，按以下步骤进行 $ 3 $ 次操作后，所有 `1` 将聚集在一起：
- 选择 $ i=2 $，交换 $ S $ 的第 $ 2 $ 和第 $ 3 $ 个字符，此时 $ S= $ `0011001`；
- 选择 $ i=6 $，交换 $ S $ 的第 $ 6 $ 和第 $ 7 $ 个字符，此时 $ S= $ `0011010`；
- 选择 $ i=5 $，交换 $ S $ 的第 $ 5 $ 和第 $ 6 $ 个字符，此时 $ S= $ `0011100`。  
由于无法在 $ 2 $ 次或更少操作内完成，因此答案为 $ 3 $。

### 样例解释 2

所有 `1` 已经聚集在一起，因此无需任何操作。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
7

0101001```

### 输出

```
3```

## 样例 #2

### 输入

```
3

100```

### 输出

```
0```

## 样例 #3

### 输入

```
10

0101001001```

### 输出

```
7```

# AI分析结果



## 算法分类
**贪心算法**

---

## 题解分析

### 核心思路与难点
- **核心思路**：所有 `1` 应聚集到中间某个位置（中位数位置），使得移动总代价最小。具体步骤为：
  1. 收集所有 `1` 的原始位置，记为数组 `pos`
  2. 选择中间位置的 `1`（即 `pos[mid]`，`mid = M/2`，`M` 为 `1` 的总数）
  3. 计算每个 `1` 移动到目标位置所需调整后的距离之和

- **难点与解决**：
  - **正确推导调整项**：相邻 `1` 移动时，后续 `1` 的移动步数会因前序调整减少（如左数第 `i` 个 `1` 的目标位置是 `mid - (mid - i)`）
  - **高效计算总和**：通过数学公式直接计算调整后的总步数，避免暴力枚举

---

## 题解评分（≥4星）

### 1. 作者：da_ke（★★★★☆）
- **亮点**：
  - 详细数学推导，证明中位数策略的最优性
  - 代码直接体现公式，逻辑清晰
  - 包含补充证明，解释 `0` 的影响
- **代码片段**：
  ```cpp
  // 核心计算逻辑
  rep(i,1,mid-1) if(S[i]=='1') { 
      ans += mid - i - (M - cnt); // 左侧调整
  }
  rep(i,mid+1,N) if(S[i]=='1') {
      ans += i - mid - (cnt - M); // 右侧调整
  }
  ```

### 2. 作者：ryf2011（★★★★☆）
- **亮点**：
  - 动态调整 `1` 的目标位置，直观模拟移动过程
  - 代码简洁，适合快速理解
- **代码片段**：
  ```cpp
  for(int i=omid-1; i>=1; i--) { // 向左合并
      ans += abs(onel[i] - onel[i+1]) - 1;
      onel[i] = onel[i+1] - 1;
  }
  ```

### 3. 作者：Tomwsc（★★★★☆）
- **亮点**：
  - 通过举例说明奇偶情况，增强理解
  - 代码直接计算差值，简洁高效
- **代码片段**：
  ```cpp
  for(int i=k-1; i>=0; i--) { // 向左调整
      ans += k - i - 1 - cnt;
  }
  ```

---

## 最优思路提炼
1. **中位数基准**：选择中间位置的 `1` 作为聚集中心
2. **调整公式**：对每个 `1` 的移动步数计算为 `实际距离 - 已调整的1数量`
3. **线性计算**：通过一次遍历完成左右两侧的累加，时间复杂度 `O(N)`

---

## 类似题目
1. [P10452 货仓选址](https://www.luogu.com.cn/problem/P10452)
2. [CF1526C2 Potions (Hard Version)](https://codeforces.com/problemset/problem/1526/C2)
3. [洛谷 P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)

---

## 核心代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N; string S;
    cin >> N >> S;
    vector<int> ones;
    for (int i = 0; i < N; ++i)
        if (S[i] == '1') ones.push_back(i);
    
    int M = ones.size();
    int mid = ones[M / 2]; // 中位数位置
    
    long long ans = 0;
    int cnt = 0;
    // 左侧计算
    for (int i = mid - 1; i >= 0; --i) {
        if (S[i] == '1') {
            ans += mid - i - 1 - cnt;
            cnt++;
        }
    }
    // 右侧计算
    cnt = 0;
    for (int i = mid + 1; i < N; ++i) {
        if (S[i] == '1') {
            ans += i - mid - 1 - cnt;
            cnt++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 可视化设计（复古像素风格）
### 动画方案
1. **数据结构表示**：
   - `1` 用绿色像素块表示，`0` 用灰色
   - 中间基准 `1` 高亮为红色
2. **移动过程**：
   - 左侧 `1` 向右移动时，播放 `8-bit` 滑动音效
   - 右侧 `1` 向左移动时，播放不同音调
3. **控制面板**：
   - 速度滑块调节动画帧率
   - 单步执行按钮观察每步细节
4. **Canvas 绘制**：
   ```javascript
   function drawGrid() {
       ctx.fillStyle = "#2D2D2D"; // 背景色
       ctx.fillRect(0, 0, width, height);
       ones.forEach((pos, idx) => {
           ctx.fillStyle = idx === midIndex ? "#FF0000" : "#00FF00";
           ctx.fillRect(pos * blockSize, 0, blockSize, blockSize);
       });
   }
   ```

---

## 个人心得
- **调试关键**：需验证中间位置的选择是否准确，特别是在偶数个 `1` 时
- **优化顿悟**：调整公式中的 `cnt` 变量用于动态减少后续步数，避免重复计算

---
处理用时：75.97秒
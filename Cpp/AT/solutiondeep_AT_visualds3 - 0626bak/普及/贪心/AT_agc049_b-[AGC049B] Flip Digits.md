# 题目信息

# [AGC049B] Flip Digits

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc049/tasks/agc049_b

`0` と `1` からなる長さ $ N $ の文字列 $ S $ 及び $ T $ が与えられます． あなたは，$ S $ に以下の操作を好きな回数行うことができます．

- $ S_i= $`1` となる $ i $ ($ 2\ \leq\ i\ \leq\ N $) を選ぶ． そして，$ S_i $ を `0` で置き換える． さらに，$ S_{i-1} $ を今と異なる文字へ変更する．つまり，操作の直前で $ S_{i-1} $ が `0` であれば `1` に，`1` であれば `0` に変更する．

$ S $ を $ T $ に一致させることは可能でしょうか？ また可能な場合は，そのために必要な最小の操作回数はいくらでしょうか？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ S $ は `0`,`1` からなる長さ $ N $ の文字列．
- $ T $ は `0`,`1` からなる長さ $ N $ の文字列．

### Sample Explanation 1

`001` → ($ i=3 $ で操作) → `010` → ($ i=2 $ で操作) → `100` とすればよいです．

## 样例 #1

### 输入

```
3

001

100```

### 输出

```
2```

## 样例 #2

### 输入

```
3

001

110```

### 输出

```
-1```

## 样例 #3

### 输入

```
5

10111

01010```

### 输出

```
5```

# AI分析结果



# 算法分类

**贪心**

---

## 题解思路与核心算法

### 核心思路
从左到右遍历每个字符，当发现 `S[i] != T[i]` 时，必须找到右边最近的 `1`（位置 `j`），并通过 `j-i` 次操作将其移动到 `i` 的位置。每次操作将 `j` 处的 `1` 左移一位，最终使 `S[i]` 变为 `T[i]`。关键在于维护一个指针 `j`，避免重复扫描，确保时间复杂度为 `O(n)`。

### 解决难点
1. **高效查找右侧的1**：维护指针 `j`，每次从 `max(i+1, j)` 开始查找，确保每个位置只扫描一次。
2. **操作合法性验证**：每次操作选择的 `j` 必须满足 `j >= i+1`（0-based），且 `S[j]` 必须为 `1`。
3. **正确性保证**：通过贪心策略，每个位置的处理不会影响前面的已处理部分，操作顺序不影响最终结果。

---

## 题解评分 (≥4星)

1. **a18981826590 的题解 (4.5星)**  
   - **亮点**：代码简洁，维护指针 `l` 高效查找 `1`，直接累加操作次数，时间复杂度明确。
   - **代码可读性**：清晰简洁，逻辑直接。

2. **SilverLi 的题解 (4.2星)**  
   - **亮点**：预处理 `1` 的位置，使用双指针优化查找，代码结构清晰。
   - **优化点**：预处理所有 `1` 的位置，避免动态查找。

3. **I_Like_Play_Genshin 的题解 (4.0星)**  
   - **亮点**：双指针策略直观，强调贪心的正确性，代码简短。
   - **不足**：注释较少，但逻辑明确。

---

## 最优思路提炼

### 关键步骤
1. **从左到右遍历**，维护指针 `j` 记录已查找的最近 `1` 的位置。
2. **遇到不匹配时**，从 `j` 开始找右侧第一个 `1`，若找不到则无解。
3. **累加操作次数** `j-i`，并更新 `j` 为 `j+1` 避免重复。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
    int n;
    string s, t;
    cin >> n >> s >> t;
    int j = 0, ans = 0;
    for (int i = 0; i < n; ++i) {
        if (s[i] == t[i]) continue;
        j = max(j, i + 1);
        while (j < n && s[j] == '0') j++;
        if (j == n) {
            cout << -1;
            return 0;
        }
        ans += j - i;
        s[j] = '0'; // 将j处的1左移到i
        s[i] = t[i]; // 更新i处为正确值
        j++; // 跳过已处理的1
    }
    cout << ans;
    return 0;
}
```

---

## 同类问题推荐

1. **LeetCode 1702. 修改后的最大二进制字符串**  
   - 贪心调整 `0` 的位置，类似操作优化。

2. **Codeforces 1370D. Odd-Even Subsequence**  
   - 贪心选择最小化极差，涉及双指针优化。

3. **洛谷 P1090 [NOIP2004 提高组] 合并果子**  
   - 贪心策略选择最小代价合并，使用优先队列。

---

## 可视化算法演示

### 动画设计
1. **网格表示字符串**：每个字符显示为像素块，`1` 为红色，`0` 为蓝色。
2. **指针标记**：当前处理的 `i` 用绿色框标记，查找的 `j` 用黄色框标记。
3. **操作过程**：当找到 `j` 时，显示 `j` 到 `i` 的路径，逐步左移 `1` 并翻转颜色，步进速度为 500ms/步。
4. **音效**：每次操作触发“哔”声，成功时播放胜利音效，失败时播放低音。

### 复古风格
- **8位像素字体**：字符显示为 16x16 像素块。
- **背景音乐**：循环播放 8-bit 风格旋律。
- **自动演示模式**：按空格键切换自动/手动，自动模式下算法逐步执行。

---

## 个人心得摘录

1. **调试教训**：未维护指针导致超时，需确保每次查找从上次结束位置开始。
2. **顿悟点**：操作顺序不影响结果，贪心策略的正确性基于操作的独立性。

---
处理用时：258.74秒
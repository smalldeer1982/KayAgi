# 题目信息

# [ARC170A] Yet Another AB Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_a

`A`, `B` からなる長さ $ N $ の文字列 $ S,T $ が与えられます．$ S $ の左から $ i $ 番目の文字を $ S_i $ と表します．

あなたは以下の操作を好きな回数（$ 0 $ 回でもよい）繰り返すことができます．

- $ 1\leq\ i\ <\ j\ \leq\ N $ を満たす整数 $ i,j $ を選ぶ． $ S_i $ を `A` で， $ S_j $ を `B` で置き換える．
 
$ S $ を $ T $ に一致させることが可能か判定し，可能な場合必要な最小の操作回数を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ S,T $ は `A`, `B` からなる長さ $ N $ の文字列
- 入力される数値は全て整数
 
### Sample Explanation 1

$ i=1,j=3 $ として操作を行うと $ S $ は `AABBA` に変化します． 次に，$ i=4,j=5 $ として操作を行うと $ S $ は `AABAB` に変化します． よって $ 2 $ 回の操作で $ S $ を $ T $ と一致させることが可能です．また，これが必要な最小の操作回数であることが証明できるので答えは $ 2 $ です．

### Sample Explanation 2

何回操作を行っても $ S $ を $ T $ と一致させることは不可能であることが証明できます．

## 样例 #1

### 输入

```
5

BAABA

AABAB```

### 输出

```
2```

## 样例 #2

### 输入

```
2

AB

BA```

### 输出

```
-1```

# AI分析结果



---

## 唯一算法分类  
**贪心**

---

## 综合分析与结论  
### 核心思路  
题目要求通过最少的操作将字符串 S 转换为 T，每次操作可同时修改两个字符（i 处改为 A，j 处改为 B，且 i<j）。关键点在于：  
1. **预处理无解条件**：若 T 的前缀有连续 B 而 S 对应位置存在 A，或 T 的后缀有连续 A 而 S 对应位置存在 B，则无法转换。  
2. **贪心匹配**：优先将 S 中需要 B→A 的位置与需要 A→B 的位置配对，通过一次操作完成两处修改。  
3. **处理剩余位置**：无法配对的 B→A 必须右侧有 B，A→B 必须左侧有 A，否则无解。  

### 算法流程  
1. **预处理**：检查 T 的极左 B 和极右 A 是否与 S 兼容。  
2. **统计总差异数**：初始答案为 S 与 T 不同字符的数量。  
3. **贪心减少操作**：从左到右扫描，用变量 j 记录可用的 B→A 位置，每遇到一个 A→B 则减少 j，答案减 1。  

### 可视化设计  
- **动画方案**：  
  - 用网格展示 S 和 T，差异字符高亮（红色为 B→A，蓝色为 A→B）。  
  - 配对操作时，红色块与蓝色块连线，同时变为正确字符，伴随音效。  
  - 剩余未配对的红色块右侧需有绿色 B 块（否则红屏报错）。  
- **复古风格**：  
  - 8-bit 像素字体，操作计数器用 LED 样式。  
  - 音效：配对成功（↑音调）、失败（↓音调）、背景 8-bit 循环音乐。  

---

## 题解清单 (≥4星)  
1. **Register_int（5星）**  
   - 亮点：代码简洁，预处理清晰，贪心策略高效（O(n) 时间，O(1) 空间）。  
   - 关键代码：通过单次扫描动态维护可配对的 B→A 数量。  

2. **Lame_Joke（4星）**  
   - 亮点：栈管理 B→A 位置，处理剩余位置时检查右侧是否有 B。  
   - 个人心得：强调栈的匹配逻辑和剩余位置的后验检查。  

3. **Cure_Wing（4星）**  
   - 亮点：极左/右无解判断后，直接处理中间段的配对与计数。  
   - 关键代码：`cnt = max(cnt, 0)` 防止负数干扰。  

---

## 最优思路提炼  
```cpp
// 预处理：检查极左 B 和极右 A 是否合法
for (int i = 1; i <= n; i++) {
    if (t[i] == 'A') break;
    if (s[i] == 'A') return puts("-1"), 0;
}
for (int i = n; i; i--) {
    if (t[i] == 'B') break;
    if (s[i] == 'B') return puts("-1"), 0;
}

// 统计总差异数并贪心匹配
int ans = 0;
for (int i = 1; i <= n; i++) ans += (s[i] != t[i]);
for (int i = 1, j = 0; i <= n; i++) {
    if (s[i] == t[i]) continue;
    if (t[i] == 'A') j++; // 记录 B→A 的需求
    else if (j > 0) j--, ans--; // 匹配一个 A→B
}
printf("%d", ans);
```

---

## 类似题目  
1. **LeetCode 1247. Minimum Swaps to Make Strings Equal**  
   - 交换字符使两字符串相同，贪心统计差异类型。  
2. **Codeforces 1251B. Binary Palindromes**  
   - 通过交换操作构造回文，贪心处理奇偶性。  
3. **洛谷 P1106 删数问题**  
   - 贪心删除数字使剩余数最小，类似最优匹配思想。  

---

## 可视化代码片段（JS 伪代码）  
```javascript
// Canvas 绘制网格与字符
function drawGrid() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, width, height);
    for (let i = 0; i < n; i++) {
        drawChar(S[i], i, 0, S[i] !== T[i] ? "red" : "white");
        drawChar(T[i], i, 1, "gray");
    }
}

// 自动演示配对过程
function autoMatch() {
    let j = 0;
    for (let i = 0; i < n; i++) {
        if (S[i] === T[i]) continue;
        if (T[i] === 'A') j++;
        else if (j > 0) {
            j--;
            highlight(i, 'blue'); // 显示配对
            playSound('match');
            await sleep(500);
        }
    }
}
```

---

## 个人心得摘录  
- **Lame_Joke**：  
  > “遇到 B→A 先入栈，A→B 时弹栈匹配，若栈空则检查前方是否有 A，否则无解。”  
- **Cure_Wing**：  
  > “极左极右的特殊情况必须优先处理，否则后续逻辑会复杂化。”  

---

## 复古游戏化设计  
- **像素风格**：16 色 palette，字符块 16x16 像素，计数器仿 FC 数字。  
- **音效触发**：  
  - 配对成功：`beep(440, 100)`  
  - 剩余未配对：`beep(220, 200)`  
  - 背景音乐：chiptune 版《Super Mario Bros》地下关 BGM。  
- **自动演示**：按空格切换手动/自动模式，方向键控制单步。

---
处理用时：100.10秒
# 题目信息

# [ARC185B] +1 and -1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc185/tasks/arc185_b

長さ $ N $ の整数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ があります。  
 あなたは次の操作を $ 0 $ 回以上好きな回数行うことが出来ます。

- $ 1\ \leq\ i\ \lt\ j\ \leq\ N $ を満たす整数対 $ (i,\ j) $ を選び、$ A_i $ を $ A_i\ +\ 1 $ に、$ A_j $ を $ A_j\ -\ 1 $ に置き換える。
 
操作によって $ A $ を広義単調増加な数列にすることが可能かどうか判定してください。

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のテストケースでは、次のように操作を行うことで $ A $ を広義単調増加な数列にすることが出来ます。 - $ (i,\ j) $ として $ (1,\ 2) $ を選ぶ。操作後の $ A $ は $ (2,\ 6,\ 5) $ になる。 - $ (i,\ j) $ として $ (1,\ 2) $ を選ぶ。操作後の $ A $ は $ (3,\ 5,\ 5) $ になる。 $ 2 $ 番目のテストケースでは、どのように操作しても $ A $ を広義単調増加な数列にすることは出来ません。

## 样例 #1

### 输入

```
3

3

1 7 5

2

9 0

10

607 495 419 894 610 636 465 331 925 724```

### 输出

```
Yes

No

Yes```

# AI分析结果



### 【唯一算法分类】
数学分析 + 贪心

---

### 【题解思路、算法要点与解决难点】
1. **核心思路**  
   - **总和不变**：操作不影响数组总和，因此目标数组的总和必须与原数组相同。
   - **构造目标数组**：将总和均分成 `floor(s/n)` 和 `ceil(s/n)`，前 `n - (s % n)` 个元素为 `floor(s/n)`，后 `s % n` 个为 `ceil(s/n)`，确保非递减。
   - **逆向检查**：从后往前遍历，累计原数组与目标数组的差值。若累计值 `<0`，说明无法调整。

2. **解决难点**  
   - **目标数组构造**：需保证非递减且总和一致。
   - **调整可行性验证**：通过逆向累加差值判断是否所有位置的后缀调整量足够。

---

### 【题解评分 (≥4星)】
1. **Locix_Elaina_Celome (4.5星)**  
   - **亮点**：代码简洁高效，逆向检查逻辑清晰，时间复杂度 O(n)。  
   - **代码片段**：
     ```cpp
     for(int i=n;i;i--) {
         sm += a[i]-g[i];
         if(sm<0) { puts("No"); break; }
     }
     ```

2. **Nuclear_Fish_cyq (4星)**  
   - **亮点**：逆向检查思路相同，变量命名清晰，适合快速理解核心逻辑。

3. **Super_Cube (4星)**  
   - **亮点**：理论推导严谨，明确目标数组构造方式，未提供代码但思路完整。

---

### 【最优思路或技巧提炼】
- **目标数组构造**：将总和均分，确保非递减。
- **逆向差值累加**：从后往前维护可用调整量，若不足则失败。
- **关键条件**：每个位置的后缀调整量必须非负。

---

### 【同类型题或类似算法套路】
- **差分数组应用**：如洛谷 P2367，通过差分维护区间操作。
- **前缀和约束**：类似问题需验证前缀和是否满足特定条件。

---

### 【推荐洛谷题目】
1. **P2367 语文成绩**  
   - 差分数组维护区间加减，验证最小值是否达标。
2. **P3406 海底高铁**  
   - 前缀和统计路径经过次数，优化费用计算。
3. **P2879 [USACO07JAN] Tallest Cow S**  
   - 差分数组处理区间限制，求最大可能高度。

---

### 【个人心得摘录】
- **逆向思维**：从后往前处理可避免调整后影响后续判断。
- **目标数组构造**：均分总和并保证非递减是核心，需细致推导。

---

### 【可视化与算法演示】
#### **动画设计**
- **核心步骤**：
  1. **构造目标数组**：显示均分过程，前段为 `floor(s/n)`，后段为 `ceil(s/n)`。
  2. **逆向遍历**：高亮当前元素，计算差值并更新累计值 `sum`，颜色标记 `sum` 正负（绿/红）。
  3. **失败判定**：若 `sum <0`，触发红色闪烁和音效，停止动画。

- **交互功能**：
  - **步进控制**：手动点击或自动播放。
  - **音效**：正差（清脆音效），负差（低沉音效），失败（警报声）。

#### **复古像素风格**
- **Canvas 绘制**：数组元素以像素方块表示，颜色区分原数组与目标数组。
- **8-bit 音效**：操作时播放经典芯片音乐，增强沉浸感。
- **自动演示**：AI 模拟算法流程，展示每一步的差值累积。

---

### 【代码实现（核心片段）】
```cpp
// Locix_Elaina_Celome 的代码（关键逻辑）
int main() {
    int T; read(T);
    while(T--) {
        read(n);
        int sm=0;
        for(int i=1;i<=n;i++) {
            read(a[i]); sm += a[i];
        }
        // 构造目标数组 g
        for(int i=1;i<=n;i++) {
            if(i <= (n - sm%n)) g[i] = sm/n;
            else g[i] = sm/n +1;
        }
        sm=0;
        bool ok = true;
        for(int i=n; i>=1; i--) {
            sm += a[i] - g[i];
            if(sm <0) { ok=false; break; }
        }
        puts(ok ? "Yes" : "No");
    }
    return 0;
}
```

---

### **可视化设计要点**
- **Canvas 初始化**：绘制网格，每列表示数组元素，颜色区分原数组（蓝色）和目标数组（绿色）。
- **差値显示**：当前处理位置高亮黄色，累计 `sum` 显示于右侧，颜色随正负变化。
- **音效触发**：使用 Web Audio API 播放 8-bit 音效，增强操作反馈。

---
处理用时：382.68秒
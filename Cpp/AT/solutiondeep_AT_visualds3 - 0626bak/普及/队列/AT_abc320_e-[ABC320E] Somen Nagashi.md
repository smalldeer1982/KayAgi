# 题目信息

# [ABC320E] Somen Nagashi

## 题目描述

现有 $N$ 个人排成一队，编号从 $1$ 到 $N$，玩一个叫做“流水面条”的游戏，该游戏共有 $M$ 个事件，每个事件含三个变量 $T_i,W_i,S_i$，事件的规则如下：

- 在 $T_i$ 时刻，有 $W_i$ 根面条流了下来，队头的人拿走这些面条，并离开队列，然后于第 $T_i+S_i$ 时刻返回队列，然后返回他的原始位置。

若队列为空，则该事件忽略。

注意：若他于第 $X$ 时刻返回队列，则视为他第 $X$ 时刻在队列。

一开始每个人都有 $0$ 根面条，现要你求出这 $N$ 个人每个人获得了多少面条。

## 说明/提示

#### 样例#1说明：
第 $1$ 个人于 $1$ 时刻拿走 $1$ 根面条，将于 $4$ 时刻返回队列。

第 $2$ 个人于 $2$ 时刻拿走 $10$ 根面条，将于 $102$ 时刻返回队列。

第 $1$ 个人于 $4$ 时刻归队，返回第 $1$ 位，此时他处于队头，然后拿走 $100$ 根面条，将于 $10004$ 时刻返回队列。

第 $3$ 个人于 $10$ 时刻拿走 $1000$ 根面条，将于第 $1000000010$ 时刻归队。

第 $100$ 时刻，队内无人。

最终，这 $3$ 个人分别有 $101,10,1000$ 根面条。

## 样例 #1

### 输入

```
3 5

1 1 3

2 10 100

4 100 10000

10 1000 1000000000

100 1000000000 1```

### 输出

```
101

10

1000```

## 样例 #2

### 输入

```
3 1

1 1 1```

### 输出

```
1

0

0```

## 样例 #3

### 输入

```
1 8

1 1 1

2 2 2

3 3 3

4 4 4

5 5 5

6 6 6

7 7 7

8 8 8```

### 输出

```
15```

# AI分析结果



### 唯一算法分类
优先队列（堆）模拟

---

### 综合分析与结论

#### 核心思路与难点
题目要求模拟一个动态排队过程，核心难点在于：
1. **事件优先级**：当同一时间既有归队事件又有面条事件时，归队事件需优先处理
2. **队列维护**：需动态维护编号最小的可用成员
3. **时间管理**：需高效处理未来归队成员的状态更新

最优解法使用两个优先队列：
- **事件队列**：按时间排序，归队事件优先于面条事件
- **当前队列**：维护可用的最小编号成员

#### 算法流程
1. **事件队列初始化**：所有面条事件按时间入队
2. **当前队列初始化**：初始所有成员按编号顺序入队
3. **循环处理事件**：
   - **归队事件**：将成员编号重新加入当前队列
   - **面条事件**：取当前队列队首成员，更新其面条数量，生成对应的归队事件

#### 可视化设计
- **动画效果**：
  - 用红色高亮当前处理的事件（面条/归队）
  - 当前队列显示为绿色编号块，事件队列显示为时间轴
  - 成员归队时播放“滴”声，拿走面条时播放“叮”声
- **复古风格**：
  - 使用16色调色板（如#FF0000红、#00FF00绿、#0000FF蓝）
  - 队列用8x8像素块表示，事件时间轴以横向滚动条展示
- **交互功能**：
  - 步进控制：空格键单步执行
  - 速度调节：方向键控制动画速度
  - 自动模式：AI自动执行时显示“AUTO”标志

---

### 题解评分 (≥4星)

| 题解作者 | 评分 | 核心亮点 |
|---------|------|---------|
| robertuu | ⭐⭐⭐⭐ | 代码简洁，利用`s=0`区分事件类型 |
| zengziqvan | ⭐⭐⭐⭐ | 使用`multiset`处理重复时间 |
| 白简 | ⭐⭐⭐⭐ | 完整注释，代码可读性极佳 |

---

### 最优思路代码实现
```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> eventQ; // {时间, 类型(0:归队)}
priority_queue<int, vector<int>, greater<>> memberQ; // 当前可用成员

// 处理事件主循环
while (!eventQ.empty()) {
    auto [time, type] = eventQ.top();
    eventQ.pop();
    
    if (type == 0) { // 归队事件
        memberQ.push(returnMember);
    } else { // 面条事件
        if (!memberQ.empty()) {
            int member = memberQ.top();
            memberQ.pop();
            ans[member] += w;
            eventQ.push({time + s, 0}); // 生成归队事件
        }
    }
}
```

---

### 相似题目推荐
1. [P2278 操作系统](https://www.luogu.com.cn/problem/P2278) - 进程调度模拟
2. [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085) - 多序列合并
3. [P6033 合并果子](https://www.luogu.com.cn/problem/P6033) - 优先队列经典应用

---

### 复古像素动画代码片段
```javascript
// 初始化Canvas
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const palette = ['#000000','#FF0000','#00FF00','#0000FF','#FFFFFF'];

// 绘制队列
function drawQueue() {
    ctx.fillStyle = palette[2]; // 绿色
    memberQ.forEach((member, index) => {
        ctx.fillRect(10 + index*20, 50, 16, 16); // 8x8像素块
        ctx.fillText(member, 12 + index*20, 62);
    });
}

// 播放音效
function playSound(type) {
    const sfx = {
        noodle: new Audio('data:audio/wav;base64,UklGRl9v...'), // 叮声
        return: new Audio('data:audio/wav;base64,UklGRk9...')  // 滴声
    };
    sfx[type].play();
}
```

---

### 关键思路总结
通过双优先队列实现：
1. **时间维度**：事件队列保证处理顺序正确
2. **空间维度**：当前队列维护最优选择
3. **事件生成**：动态插入归队事件实现状态更新

此解法的时间复杂度为O(M log M)，空间复杂度O(N + M)，能高效处理1e5级别的数据规模。

---
处理用时：76.56秒
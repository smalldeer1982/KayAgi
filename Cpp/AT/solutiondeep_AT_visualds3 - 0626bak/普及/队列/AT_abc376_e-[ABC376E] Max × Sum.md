# 题目信息

# [ABC376E] Max × Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_e

長さ $ N $ の数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N),\ B\ =\ (B_1,\ B_2,\ \dots,\ B_N) $ が与えられます。  
$ \lbrace\ 1,\ 2,\ \dots,\ N\ \rbrace $ の部分集合であって大きさが $ K $ のものを $ 1 $ つ選び $ S $ とします。この時、以下の式の値としてあり得る最小値を求めてください。

$ \displaystyle\ \left(\max_{i\ \in\ S}\ A_i\right)\ \times\ \left(\sum_{i\ \in\ S}\ B_i\right) $ 

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ 10^6 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数

### Sample Explanation 1

$ 1 $ 番目のテストケースでは、$ S\ =\ \lbrace\ 2,\ 3\ \rbrace $ を選ぶと式の値が $ 7\ \times\ (2\ +\ 4)\ =\ 42 $ になり、これが最小です。

## 样例 #1

### 输入

```
3
3 2
3 7 6
9 2 4
5 3
6 4 1 5 9
8 6 5 1 7
10 6
61 95 61 57 69 49 46 47 14 43
39 79 48 92 90 76 30 16 30 94```

### 输出

```
42
60
14579```

# AI分析结果



**唯一算法分类**  
贪心算法（结合排序与优先队列）

---

### **题解思路、算法要点与解决难点**  
1. **排序与贪心策略**  
   - 将数组按A升序排序后，枚举每个元素作为最大值，此时只需在前i个元素中选取B的和最小的K-1个元素（需包含当前元素）。  
   - 贪心核心：当前元素的A值作为最大值时，总和需尽可能小，因此优先选取B值较小的元素。

2. **优先队列维护最小值**  
   - 使用大根堆维护当前选中的K-1个最小的B值。堆顶为当前选中元素中的最大值，若新元素更小则替换堆顶，保持总和最小。  
   - 动态维护总和：每次加入新元素后，若堆大小超过K-1，弹出堆顶，确保堆中始终保留最小的K-1个元素。

3. **时间复杂度优化**  
   - 排序复杂度为O(N log N)，堆操作复杂度为O(N log K)，整体复杂度O(N log N + N log K)，适用于大规模数据。

---

### **题解评分（≥4星）**  
1. **yszkddzyh（5星）**  
   - 思路清晰，详细解释了排序和堆维护的逻辑。  
   - 代码用大根堆维护前K-1个元素，初始化和更新过程明确。  
   - 核心亮点：通过堆的微调避免重复排序，时间复杂度严格保证。

2. **chenxi2009（4.5星）**  
   - 代码简洁，注释明确，优先队列动态维护K-1个最小元素。  
   - 处理了K=1的特殊情况，鲁棒性强。

3. **Xuan_qwq（4星）**  
   - 代码可读性高，使用稳定排序确保正确性。  
   - 堆操作逻辑简洁，适合快速实现。

---

### **最优思路或技巧提炼**  
1. **排序后枚举最大值**  
   - 将问题转化为固定最大值的最小和问题，简化计算。

2. **优先队列动态维护**  
   - 用大根堆维护最小的K-1个元素，实时更新总和。

3. **边界处理**  
   - 处理K=1的特殊情况，确保代码鲁棒性。

---

### **同类型题或类似算法套路**  
- **极值与部分和组合问题**：如选择子集使得某属性的极值与另一属性的和满足条件。  
- **贪心+堆维护极值**：如合并果子（洛谷P1090）、动态维护中位数（洛谷P1801）。

---

### **推荐相似题目**  
1. **P1090 [NOIP2004 提高组] 合并果子**  
   - 贪心选择最小两堆合并，优先队列维护。

2. **P1801 黑匣子**  
   - 动态维护区间内的第K大值，堆的应用。

3. **P3812 【模板】线性基**  
   - 贪心策略处理异或极值问题。

---

### **可视化与算法演示**  
**核心流程动画设计**：  
1. **排序可视化**  
   - 数组按A升序排列，元素以不同颜色块表示A和B值。  
   - 当前枚举的A[i]高亮为红色，堆中元素高亮为绿色。

2. **堆操作动态展示**  
   - 插入新元素时，若堆大小超过K-1，弹出堆顶（最大值）。  
   - 堆结构以树状图展示，堆顶元素标红。

3. **乘积计算与更新**  
   - 每一步计算A[i] * sum，当前最小值以动态文本显示。

**复古像素风格设计**：  
- **颜色方案**：8-bit风格调色板，A值用蓝色渐变，B值用绿色渐变。  
- **音效**：插入元素时播放“滴”声，弹出堆顶时播放“咔”声，找到新最小值时播放胜利音效。  
- **自动演示模式**：按帧逐步执行，可暂停/继续，速度可调。

---

### **代码片段（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

struct Node { int a, b; };
priority_queue<int> q; // 大根堆维护最小的K-1个B值

void solve() {
    int n, k; cin >> n >> k;
    vector<Node> arr(n);
    for (auto &x : arr) cin >> x.a;
    for (auto &x : arr) cin >> x.b;
    sort(arr.begin(), arr.end(), [](auto &x, auto &y) { return x.a < y.a; });

    int sum = 0, ans = LLONG_MAX;
    for (int i = 0; i < n; ++i) {
        q.push(arr[i].b);
        sum += arr[i].b;
        if (q.size() > k - 1) { // 保持堆大小为K-1
            sum -= q.top();
            q.pop();
        }
        if (i >= k - 1) { // 从第K个元素开始统计答案
            ans = min(ans, arr[i].a * (sum + arr[i].b));
        }
    }
    cout << ans << endl;
    while (!q.empty()) q.pop();
}

signed main() {
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T--) solve();
    return 0;
}
```

**核心思想**：  
- 排序后，用大根堆动态维护前i个元素中最小的K-1个B值的和。  
- 每次枚举i时，当前元素必选，总和为堆中元素和加当前B值，计算乘积并更新最小值。

---
处理用时：131.69秒
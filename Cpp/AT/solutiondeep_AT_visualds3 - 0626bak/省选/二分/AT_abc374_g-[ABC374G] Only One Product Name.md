# 题目信息

# [ABC374G] Only One Product Name

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_g

キーエンスの商品名はすべて **英大文字 $ 2 $ 文字** からなります。  
 すでに $ N $ 個の商品名を使用しており、$ i $ 個目 $ (1\leq\ i\leq\ N) $ の商品名は $ S_i $ です。  
 一度使用した商品名は再び使うことができないので、過去に使用した商品名の一覧がすぐわかるように NG リストを作ることにしました。

NGリストは次の条件をみたす必要があります。

- $ 1 $ つ以上の文字列からなり、各文字列は英大文字のみからなる。
- すでに使用されている商品名それぞれについて、その商品名を（連続する）部分文字列として含む文字列が $ 1 $ つ以上存在する。
- リスト内のすべての文字列は、すでに使用されている商品名でない長さ $ 2 $ の文字列を（連続する）部分文字列として含まない。
 
NG リストの文字列の数としてあり得る最小の値を求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 26^2 $
- $ N $ は整数
- $ S_i $ は英大文字のみからなる長さ $ 2 $ の文字列
- $ S_1,S_2,\ldots,S_N $ はすべて異なる。
 
### Sample Explanation 1

条件をみたす NG リストとしては例えば次の $ 3 $ つの文字列からなるようなものが考えられます。 - `CABCDE` - `DF` - `XX` これは $ 3 $ つの文字列からなり、$ 2 $ つ以下の文字列からなり条件をみたす NG リストは存在しないため、 $ 3 $ を出力します。

### Sample Explanation 2

条件をみたす NG リストとしては例えば次の $ 2 $ つの文字列からなるようなものが考えられます。 - `ACDE` - `BCDF` すでに使用されている商品名は NG リスト内の複数の文字列に登場したり、同一文字列に複数回含まれたりしていても良いことに注意してください。

### Sample Explanation 3

例えば、`ABACBADB` のみからなる NG リストが条件をみたしています。

## 样例 #1

### 输入

```
7

AB

BC

CA

CD

DE

DF

XX```

### 输出

```
3```

## 样例 #2

### 输入

```
5

AC

BC

CD

DE

DF```

### 输出

```
2```

## 样例 #3

### 输入

```
6

AB

AC

CB

AD

DB

BA```

### 输出

```
1```

# AI分析结果



### 算法分类
无算法分类

---

### 题解思路与解决难点

#### 核心思路
1. **图论建模**：将每个给定的 2 字符字符串视为图中的一个节点，若字符串 A 的末字符等于字符串 B 的首字符，则建立有向边 A→B。
2. **强连通分量缩点**：处理环状结构（SCC），将每个强连通分量缩成一个超级节点，形成 DAG。
3. **传递闭包处理**：对 DAG 进行传递闭包操作，使任意可到达的节点间均有直接边。
4. **二分图匹配**：将缩点后的 DAG 转化为二分图，左部为超级节点，右部为相同节点，边表示可达关系。最小路径覆盖数 = 节点数 - 二分图最大匹配数。

#### 解决难点
- **环处理**：通过 SCC 缩点消除环结构，将原图转换为 DAG。
- **可交路径覆盖**：传递闭包后，原问题等价于 DAG 的不可交路径覆盖问题。
- **高效建图**：传递闭包后边数可能爆炸，需用匈牙利算法或 Dinic 网络流处理稀疏图。

---

### 题解评分（≥4星）

#### 1. Angraecum（★★★★☆）
- **亮点**：代码简洁，缩点与传递闭包逻辑清晰，直接应用匈牙利算法实现。
- **核心代码**：
  ```cpp
  // 缩点后传递闭包 + 匈牙利匹配
  for (int i=1; i<=n; ++i) ans -= dfs(i,i);
  ```

#### 2. Register_int（★★★★☆）
- **亮点**：Dinic 网络流实现，处理复杂边关系效率更高。
- **关键优化**：通过虚拟源汇点构造二分图，适合大规模数据。

#### 3. xiezheyuan（★★★★★）
- **亮点**：利用 AtCoder Library 简化代码，缩点与传递闭包逻辑高度精炼。
- **代码片段**：
  ```cpp
  auto scc = g.scc(); // 使用库函数求 SCC
  for (int k=1; k<=cnt; k++) // 传递闭包
    for (int i=1; i<=cnt; i++)
      for (int j=1; j<=cnt; j++) f[i][j] |= f[i][k] & f[k][j];
  ```

---

### 最优思路提炼
1. **强连通分量缩点**：将环结构压缩为单个节点，消除环对路径覆盖的影响。
2. **传递闭包重构图**：将可达关系转化为直接边，使路径覆盖问题转化为不可交覆盖。
3. **二分图匹配技巧**：拆点构造二分图，左部为起点，右部为终点，用匈牙利或网络流求最大匹配。

---

### 同类型题与算法套路
- **DAG 最小路径覆盖**：如洛谷 P2764（最小路径覆盖问题）。
- **SCC 缩点应用**：涉及环处理的图论问题（如 Codeforces 1213F）。
- **二分图匹配**：需快速判断可达性后再匹配，类似棋盘覆盖问题。

---

### 推荐题目
1. **P2764**：最小路径覆盖模板题。
2. **CF510C**：基于字符顺序的图论建模。
3. **ABC344G**：图论建模与网络流结合。

---

### 可视化与算法演示
1. **图构建动画**：动态展示字符串间连边，用不同颜色标记 SCC。
2. **缩点过程**：以气泡合并效果展示 SCC 收缩为超级节点。
3. **传递闭包**：高亮新增边，逐层展示 Floyd-Warshall 算法扩展。
4. **二分图匹配**：用流动效果模拟匈牙利算法的增广路径搜索。

#### 复古像素化设计
- **颜色方案**：SCC 用 8 位色块（如红、蓝、绿），边用白色像素线。
- **音效**：节点合并时播放“合成音”，匹配成功时播放“得分音效”。
- **自动演示**：按空格键逐步执行 SCC 缩点→传递闭包→匹配计算。

---

### 核心代码（匈牙利算法实现）
```cpp
bool dfs(int u, int tag) {
    if (vi[u] == tag) return 0;
    vi[u] = tag;
    for (int v : g[u]) {
        if (!p[v] || dfs(p[v], tag)) {
            p[v] = u;
            return 1;
        }
    }
    return 0;
}
// 主逻辑：ans = n - 最大匹配数
for (int i=1; i<=n; ++i) ans -= dfs(i, i);
```

---

### 个人心得摘录
> “会了真不难”——Angraecum  
> **总结**：正确识别问题本质（最小路径覆盖）是关键，缩点与传递闭包是核心跳板。

---
处理用时：66.75秒
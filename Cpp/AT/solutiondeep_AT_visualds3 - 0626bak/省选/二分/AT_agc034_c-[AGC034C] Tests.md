# 题目信息

# [AGC034C] Tests

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc034/tasks/agc034_c

高橋くんと青木くんは $ 1 $ から $ N $ までの番号がついたテストを受けようとしています。 二人はこのテストの結果を使って勝負することにしました。 具体的には、次のようにして勝敗を決めます。

- 高橋くんが各テスト $ i $ について、その重要度 $ c_i $ を決める。ただしこの値は $ l_i $ 以上 $ u_i $ 以下の整数である必要がある。
- $ \sum_{i=1}^{N}\ c_i\ \times $ (高橋くんのテスト $ i $ の点数) を $ A $, $ \ $ $ \sum_{i=1}^{N}\ c_i\ \times $ (青木くんのテスト $ i $ の点数) を $ B $ とする。 $ A\ \geq\ B $ なら高橋くんの勝ち、$ A\ <\ B $ なら青木くんの勝ち。

高橋くんはエスパーなので、青木くんがテスト $ i $ で $ b_i $ 点をとることがわかっています。

高橋くんはこのままだとすべてのテストで $ 0 $ 点をとってしまいますが、 $ 1 $ 時間勉強するごとに、好きなテストの点数を $ 1 $ だけ上げることができます。($ 1 $ 時間単位でしか勉強できません。) ただしテストはすべて **$ X $ 点満点**なので、 $ X $ より大きい点数にすることはできません。

高橋くんが勝つために必要な最小の勉強時間を出力してください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ X\ ≦\ 10^5 $
- $ 0\ ≦\ b_i\ ≦\ X $ $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ ≦\ l_i\ ≦\ u_i\ ≦\ 10^5 $ $ (1\ \leq\ i\ \leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

例えば次のようにするのが最適です。 - $ c_1\ =\ 3,\ c_2\ =\ 1 $ とする。 - テスト $ 1 $ で $ 100 $ 点、テスト $ 2 $ で $ 15 $ 点とるように勉強する。 このとき $ A\ =\ 3\ \times\ 100\ +\ 1\ \times\ 15\ =\ 315 $, $ B\ =\ 3\ \times\ 85\ +\ 1\ \times\ 60\ =\ 315 $ なので高橋くんが勝ちます。

## 样例 #1

### 输入

```
2 100

85 2 3

60 1 1```

### 输出

```
115```

## 样例 #2

### 输入

```
2 100

85 2 3

60 10 10```

### 输出

```
77```

## 样例 #3

### 输入

```
1 100000

31415 2718 2818```

### 输出

```
31415```

## 样例 #4

### 输入

```
10 1000

451 4593 6263

324 310 6991

378 1431 7068

71 1757 9218

204 3676 4328

840 6221 9080

684 1545 8511

709 5467 8674

862 6504 9835

283 4965 9980```

### 输出

```
2540```

# AI分析结果



# 算法分类：二分

## 题解思路与解决难点

### 核心思路
题目要求找到最小学习时间 $s$，使得高桥的总分 $A \geq B$。通过二分法确定 $s$ 的最小值，每次判断给定 $s$ 是否可行。关键难点在于如何快速计算最大可能的 $A-B$。

### 算法要点
1. **二分框架**：在区间 $[0, \text{总时间上限}]$ 内搜索最小 $s$。
2. **贡献函数**：每个测试 $i$ 的贡献分为两段：
   - 当 $a_i \leq b_i$：贡献为 $l_i \cdot a_i$。
   - 当 $a_i > b_i$：贡献为 $l_i \cdot b_i + r_i \cdot (a_i - b_i)$。
3. **最优结构**：最多一个测试的 $a_i$ 不是 $0$ 或 $X$，其余测试全取 $0$ 或 $X$。
4. **贪心排序**：按全取 $X$ 时的贡献差值排序，取前 $k = \lfloor s/X \rfloor$ 个最大贡献，剩余时间 $r = s \bmod X$ 分配给最优测试。

### 解决难点
1. **贡献差排序**：预处理每个测试取 $X$ 与 $0$ 的贡献差，排序后利用前缀和快速计算。
2. **枚举余数分配**：对每个可能的测试计算余数分配后的总贡献，取最大值判断可行性。
3. **边界处理**：如 $s/X \geq n$ 时的全取 $X$ 的特殊情况。

---

## 题解评分（≥4星）

1. **Mophie（★★★★☆）**
   - **亮点**：清晰的预处理排序和前缀和优化，代码结构简洁。
   - **代码**：通过 `get_val` 函数动态计算贡献差，二分逻辑清晰。

2. **Rainybunny（★★★★★）**
   - **亮点**：详细分段函数分析，数学推导严谨，可读性极高。
   - **代码**：模块化设计，`contr` 函数分离贡献计算，逻辑复用性强。

3. **Super_Cube（★★★★☆）**
   - **亮点**：极简代码实现，`check` 函数高效枚举余数分配。
   - **优化**：利用 `stable_sort` 保证稳定性，避免冗余计算。

---

## 最优思路提炼

### 关键步骤
1. **二分搜索**：初始区间 `[0, sum(b_i)]`，逐步缩小范围。
2. **贡献排序**：按 `f_i(X) - f_i(0)` 降序排序，取前 $k$ 项。
3. **余数枚举**：对每个测试计算余数 $r$ 的贡献，取最大值。

### 代码片段
```cpp
bool check(ll s) {
    int q = s / x, rr = s % x;
    ll max_sum = 0;
    // 计算前 q 个 X 的贡献总和
    for (int i = 1; i <= q; i++) sum += f(ord[i], X);
    // 枚举余数分配
    for (int i = 1; i <= n; i++) {
        ll curr = sum + f(i, rr) - (i <= q ? f(i, X) : 0);
        max_sum = max(max_sum, curr);
    }
    return max_sum >= target;
}
```

---

## 类似题目推荐
1. **P3743 kotori的设备**（二分能量供给时间）
2. **P4343 [SHOI2015]自动刷题机**（二分提交次数）
3. **P2920 [USACO08NOV]Time Management**（二分最晚开始时间）

---

## 可视化设计（二分过程）

### 动画方案
1. **区间动态更新**：Canvas 绘制区间条，`left`、`right` 用蓝色标记，`mid` 用红色闪烁。
2. **高亮比较结果**：若 `check(mid)` 成功，右区间收缩为橙色；否则左区间扩展为黄色。
3. **像素风格**：使用 8-bit 色块表示区间，音效在每次收缩时播放“哔”声，成功时播放通关音效。

### 交互功能
- **步进控制**：按钮控制单步执行或自动播放（速度可调）。
- **音效触发**：每次更新 `mid` 播放点击声，找到解时播放胜利音效。

### 代码片段（JS）
```javascript
function visualizeBinarySearch() {
    let left = 0, right = maxS;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        drawInterval(left, mid, right); // 绘制区间
        if (check(mid)) {
            playSound('success');
            right = mid - 1;
        } else {
            playSound('fail');
            left = mid + 1;
        }
    }
}
```

---

## 个人心得
- **调试关键**：初始区间的正确设置和余数分配的边界处理容易出错，需仔细验证。
- **顿悟点**：发现“唯一中间值”结论后，问题复杂度骤降，排序+前缀和的组合是典型优化手段。

---

通过上述分析，结合二分法与贪心策略，能够高效解决此类最优化问题。可视化设计增强了二分过程的直观理解，适合教学与自学。

---
处理用时：73.30秒
# 题目信息

# [AGC034D] Manhattan Max Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc034/tasks/agc034_d

すぬけくんは、二次元平面上に赤いボールと青いボールを置いて遊んでいます。

すぬけくんはまず、赤いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (RX_i,RY_i) $ に $ RC_i $ 個の赤いボールを置きました。 すぬけくんは次に、青いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (BX_i,BY_i) $ に $ BC_i $ 個の青いボールを置きました。 ここで、すぬけくんが置いた赤いボールの個数の総和と青いボールの個数の総和は等しいです。 つまり、$ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $ です。 以後、この値を $ S $ とおきます。

すぬけくんはこれから、赤いボールと青いボールのペアを $ S $ 個作ろうとしています。 どのボールも、ちょうど $ 1 $ つのペアに属するようにします。 ここで、座標 $ (rx,ry) $ にある赤いボールと座標 $ (bx,by) $ にある青いボールのペアのスコアを、 $ |rx-bx|\ +\ |ry-by| $ と定義します。

すぬけくんは、ペアのスコアの総和を最大化したいです。 すぬけくんのために、ペアのスコアの総和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 0\ \leq\ RX_i,RY_i,BX_i,BY_i\ \leq\ 10^9 $
- $ 1\ \leq\ RC_i,BC_i\ \leq\ 10 $
- $ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $
- 入力される値はすべて整数である。

### Sample Explanation 1

座標 $ (0,0) $ に置いてある赤いボールと座標 $ (2,2) $ に置いてある青いボールをペアにすると、 そのスコアは $ |0-2|\ +\ |0-2|=4 $ です。 また、座標 $ (3,2) $ に置いてある赤いボールと座標 $ (5,0) $ に置いてある青いボールをペアにすると、 そのスコアは $ |3-5|\ +\ |2-0|=4 $ です。 この $ 2 $ つのペアを作ると、スコアの総和は $ 8 $ になり、これが最大です。

### Sample Explanation 2

同じ座標に複数回操作を行うこともあります。

## 样例 #1

### 输入

```
2

0 0 1

3 2 1

2 2 1

5 0 1```

### 输出

```
8```

## 样例 #2

### 输入

```
3

0 0 1

2 2 1

0 0 2

1 1 1

1 1 1

3 3 2```

### 输出

```
16```

## 样例 #3

### 输入

```
10

582463373 690528069 8

621230322 318051944 4

356524296 974059503 6

372751381 111542460 9

392867214 581476334 6

606955458 513028121 5

882201596 791660614 9

250465517 91918758 3

618624774 406956634 6

426294747 736401096 5

974896051 888765942 5

726682138 336960821 3

715144179 82444709 6

599055841 501257806 6

390484433 962747856 4

912334580 219343832 8

570458984 648862300 6

638017635 572157978 10

435958984 585073520 7

445612658 234265014 6```

### 输出

```
45152033546```

# AI分析结果



**唯一算法分类**: 无算法分类

---

### 题解思路、算法要点与解决难点

#### 核心思路
本题要求最大化曼哈顿距离匹配的总和，需将问题转化为**网络流模型**。关键点在于利用曼哈顿距离的数学性质，拆解绝对值表达式为四种可能的最大值情况，并通过建立四个中间节点优化边数至 $O(n)$。

#### 算法要点
1. **曼哈顿距离拆解**：  
   $$|x_1-x_2| + |y_1-y_2| = \max \begin{cases} 
   (x_1+y_1) + (-x_2-y_2) \\
   (x_1-y_1) + (-x_2+y_2) \\
   (-x_1+y_1) + (x_2-y_2) \\
   (-x_1-y_1) + (x_2+y_2) 
   \end{cases}$$
2. **中间节点设计**：创建四个中间节点，分别对应上述四种情况，红球节点向中间节点连边（边权为拆分后的正项），蓝球节点从中间节点连边（边权为负项）。
3. **费用流模型**：源点连接红球节点，蓝球节点连接汇点，中间节点保证费用最大化路径被选择。

#### 解决难点
- **边数优化**：直接暴力建边会导致 $O(n^2)$ 复杂度，通过中间节点拆解，边数降为 $O(n)$。
- **费用正确性**：费用流自动选择最大费用路径，确保曼哈顿距离的最大值被正确计算。

---

### 题解评分（≥4星）

1. **justin_cao（★★★★☆）**  
   - 思路清晰，代码简洁，直接展示中间节点建图。
   - 使用 SPFA 实现费用流，适合负权边场景。
   - 关键代码片段明确，易读性强。

2. **Aleph1022（★★★★☆）**  
   - 提出模拟费用流优化思路，维护多个堆管理增广路径。
   - 分析关键点间的最短路逻辑，适合进阶学习。
   - 时间复杂度分析详细，但代码复杂度较高。

3. **OldDriverTree（★★★★☆）**  
   - 分步骤解释建图逻辑，对比暴力与优化方法。
   - 提供多种实现参考（费用流与模拟费用流）。
   - 关联类似题目 CF730I，拓展性强。

---

### 最优思路或技巧提炼

1. **曼哈顿距离拆解**：将绝对值转化为四种符号组合，独立计算红蓝球贡献。
2. **中间节点设计**：通过四个中间节点将边数降至线性，确保费用流高效运行。
3. **费用流自动选择最大路径**：利用网络流特性，无需显式比较所有情况。

---

### 同类型题或类似算法套路

- **套路**：几何性质拆解优化网络流（如曼哈顿距离、切比雪夫距离）。
- **类似题目**：
  1. **洛谷 P3967 [TJOI2014] 匹配**：二分图最大权匹配，需优化建图。
  2. **洛谷 P1251 餐巾计划问题**：流量分阶段控制，拆点优化。
  3. **CF730I 奖杯分配**：多优先级匹配，模拟费用流思想。

---

### 推荐相似知识点题目

1. **AT4541 [AGC024F] Simple Subsequence Problem**（字符串匹配与位运算优化）
2. **洛谷 P4003 无限之环**（网络流拆点与旋转费用设计）
3. **CF1082G Petya and Graph**（最大权闭合子图与边权处理）

---

### 个人心得摘录

- **justin_cao**：强调曼哈顿距离拆解的正确性验证，需通过数学证明确保费用流路径对应实际最大值。
- **OldDriverTree**：提到模拟费用流中堆维护的复杂性，建议先掌握基础费用流再尝试优化。

---

### 可视化与算法演示（费用流核心逻辑）

#### 动画方案设计
1. **节点与边展示**：  
   - 红球节点（红色）、蓝球节点（蓝色）、中间节点（黄/绿/紫/橙）及边权动态显示。
   - 高亮当前增广路径，显示费用累加过程。

2. **费用流动态演示**：  
   - **增广路径搜索**：以流动效果显示 SPFA 搜索最短路过程。
   - **流量调整**：路径上的边宽随流量减少动态变化，反向边增宽。

3. **交互控制**：  
   - **步进执行**：单步展示增广路径选择与流量更新。
   - **速度调节**：滑动条控制动画速度，适应不同学习节奏。

#### 复古像素风格设计
- **8位风格界面**：节点用像素方块表示，中间节点以不同颜色区分。
- **音效反馈**：  
  - 路径发现时播放“滴”声，流量更新时“咔嚓”声。
  - 背景音乐采用 8-bit 循环旋律，增强沉浸感。

---

### 关键代码片段（以 justin_cao 题解为例）

```cpp
// 建图核心代码
for (int i = 1; i <= n; i++) {
    addx(s, i, RC_i, 0); // 源点→红球
    addx(i, p1, inf, x + y); // 红球→中间节点（四种情况）
    addx(i, p2, inf, x - y);
    addx(i, p3, inf, -x + y);
    addx(i, p4, inf, -x - y);
}
for (int i = 1; i <= n; i++) {
    addx(i + n, t, BC_i, 0); // 蓝球→汇点
    addx(p1, i + n, inf, -x - y); // 中间节点→蓝球
    addx(p2, i + n, inf, -x + y);
    addx(p3, i + n, inf, x - y);
    addx(p4, i + n, inf, x + y);
}
// 费用流主循环
while (spfa()) {
    // 更新流量与费用
}
```

---

### 总结

本题通过曼哈顿距离拆解与中间节点优化，将网络流边数降至线性，是费用流经典优化技巧的典型应用。掌握几何性质转化与网络流建图思维，可有效解决同类复杂匹配问题。

---
处理用时：97.04秒
# 题目信息

# [AGC069B] Pair Guessing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc069/tasks/agc069_b

$ N $ 個の、長さ $ N $ の $ 01 $ 文字列 $ S_1,\ldots,S_N $ が与えられます。$ S_i $ の $ j $ 文字目を $ S_{i,j} $ と表します。ここで、$ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在することが制約より保証されています。

高橋君と青木君が以下のようなゲームを行います。

1. 高橋君が $ 1\ \leq\ i,j\ \leq\ N,\ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ を $ 1 $ つ選ぶ。
2. $ 0 $ 回以上 $ N $ 回以下、青木君が高橋君に質問を行う。各質問では青木君が $ 1\leq\ i',j'\ \leq\ N $ を満たす整数組 $ (i',j') $ を選び、「$ i=i' $ と $ j=j' $ のうち少なくとも一方が成り立つ」の真偽を高橋君から教えてもらう。
3. 青木君が $ (i,j) $ を予想する。予想が当たっていれば青木君の勝ち、そうでなければ負けとなる。
 
青木君は高橋君が選ぶ $ (i,j) $ の候補、すなわち $ S_1,\ldots,S_N $ を知った状態でゲームを行います。また、上記2では以前の質問に対する返事を聞いたうえで $ (i',\ j') $ を選ぶことができます。

青木君が適切な戦略を取った場合、高橋君の $ (i,j) $ の選び方や運によらず必ずゲームに勝てるかどうかを判定してください。

$ 1 $ つの入力につきテストケースは $ T $ 個あります。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 500 $
- $ 1 $ つの入力の中のテストケースすべてにわたる $ N^2 $ の総和は $ 500^2 $ 以下である
- $ S_i $ は長さ $ N $ の $ 01 $ 文字列
- $ S_{i,j}=\ $ `1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在する
 
### Sample Explanation 1

$ 1 $ 番目のテストケースに対するゲームの一例を以下に示します。 1. 高橋君が $ S_{i,j}=\ $`1` を満たす $ (i,j) $ として $ (2,2) $ を選ぶ。 2. 青木君が $ 2 $ 回質問を行う。$ 1 $ 回目の質問では $ (i',j')=(1,1) $ として、高橋君から「$ i=1 $ と $ j=1 $ のうち少なくとも一方が成り立つ」が偽であると教えてもらう。$ 2 $ 回目の質問では $ (i',j')=(2,2) $ として、高橋君から「$ i=2 $ と $ j=2 $ の少なくとも一方が成り立つ」が真であると教えてもらう。 3. 青木君が $ (i,j)=(2,2) $ と予想する。この予想は当たっているため、青木君の勝ちである。 これはあくまでゲームの一例であり、青木君の戦略が適切とは限りません。しかし、青木君が適切な戦略を取った場合には必ず青木君がゲームに勝つため、$ 1 $ 番目のテストケースに対する出力は `Yes` になります。

## 样例 #1

### 输入

```
3

2

01

11

2

11

11

10

0101011110

1100100001

1101100000

0111101010

1000011001

1110101010

1110110100

1110000110

0000001011

1001111100```

### 输出

```
Yes

No

Yes```

# AI分析结果



# 算法分类
无算法分类

---

# 综合分析与结论

## 核心思路
题目转化为判断是否存在足够的「0」位置，使得每次提问可排除一行或一列。通过构建二分图模型，将每个「0」视为连接行与列的边，利用并查集统计连通块大小。当满足以下条件时青木君必胜：
- **n=2**：至少存在一个0（sum≥1）
- **n>2**：所有连通块贡献的边数总和≥n-2

## 难点与解决
1. **模型转换**：将行列关系映射为二分图节点，通过0的位置建立连边
2. **条件推导**：发现当n>2时条件可放宽，通过数学归纳验证其正确性
3. **并查集优化**：高效维护连通性，快速计算各连通块贡献边数

## 可视化设计
1. **像素风格演示**：
   - 用两种颜色块表示行/列节点
   - 动态绘制连通过程，每次合并显示像素爆炸特效
   - 统计面板实时显示sum值与条件阈值
2. **音效交互**：
   - 合并成功时播放8-bit "ping" 音
   - 条件满足时播放胜利旋律
3. **自动模式**：
   - 按最优顺序合并0的位置，展示条件达成过程
   - 支持暂停观察当前连通状态

---

# 题解清单

## Eraine 题解（★★★★☆）
**亮点**：
- 提出关键转化思路：将问题映射为二分图连通性
- 分析初始条件漏洞并修正
**不足**：
- 未完整给出n>2时的数学证明

## gdf_yhm 题解（★★★★★）
**亮点**：
- 给出完整代码实现
- 正确处理n>2的特殊情况
- 明确条件判断式 `ans>=n-1 || (n>2 && ans>=n-2)`

---

# 核心代码实现
```cpp
int main() {
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<string> grid(n);
        for (auto& s : grid) cin >> s;
        
        UnionFind uf(2*n);
        for (int i=0; i<n; ++i)
            for (int j=0; j<n; ++j)
                if (grid[i][j] == '0')
                    uf.unite(i, n+j);
        
        int ans = 0;
        for (int i=0; i<2*n; ++i)
            if (uf.find(i) == i)
                ans += uf.size[i] - 1;
        
        if ((n == 2 && ans >= 1) || (n > 2 && ans >= n-2))
            cout << "Yes\n";
        else 
            cout << "No\n";
    }
}
```

---

# 同类型题目
1. **P3386** 二分图最大匹配
2. **P1263** 行列覆盖问题
3. **P1330** 封锁阳光大学（二分图判定）

---

# 个人心得摘录
> "WA 18个点后发现n>2时条件可放宽，通过构造极端样例验证才找到正确条件。调试时需特别注意边界情况，数学归纳法是验证条件的有效手段。"

---

# 可视化演示设计
```javascript
// 伪代码示例
class Viz {
    constructor(n, grid) {
        this.ctx = canvas.getContext('2d');
        this.nodes = [...行节点, ...列节点]; // 行用红色，列用蓝色
        this.edges = grid.filter(c => c == '0').map(toEdge);
    }

    animate() {
        this.edges.forEach(edge => {
            if (!isConnected(edge)) {
                connectWithParticleEffect();
                playSound('merge');
                updateSumCounter();
            }
        });
        flashFinalConditionCheck();
    }
}
```
**交互特性**：
- 空格键切换自动/手动模式
- 方向键控制动画速度
- 失败时显示红色警告边框

---
处理用时：86.02秒
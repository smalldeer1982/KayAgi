# 题目信息

# [ARC168E] Subsegments with Large Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc168/tasks/arc168_e

長さ $ N $ の正整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます．

この数列を $ K $ 個の非空な連続部分列に分割することを考えます． この $ K $ 個の連続部分列のうち，要素の総和が $ S $ 以上であるものの個数を**スコア**と呼ぶことにします． スコアの最大値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 250000 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ S\ \leq\ 10^{15} $
- 入力される値はすべて整数．
 
### Sample Explanation 1

数列を $ (1),(4,2),(8) $ と分割すると，スコアが $ 2 $ になります． これより大きいスコアは達成できないため，答えは $ 2 $ です．

## 样例 #1

### 输入

```
4 3 6

1 4 2 8```

### 输出

```
2```

## 样例 #2

### 输入

```
10 5 2

1 1 1 1 1 1 1 1 1 1```

### 输出

```
5```

## 样例 #3

### 输入

```
10 5 3

1 1 1 1 1 1 1 1 1 1```

### 输出

```
2```

## 样例 #4

### 输入

```
20 6 946667802

786820955 250480341 710671229 946667801 19271059 404902145 251317818 22712439 520643153 344670307 274195604 561032101 140039457 543856068 521915711 857077284 499774361 419370025 744280520 249168130```

### 输出

```
6```

# AI分析结果



# 【算法分类】
二分

# 【题解思路与解决难点】

### 核心思路
1. **二分答案**：确定最大可能的满足条件的子段数x，转化为判定问题。
2. **wqs二分优化**：处理最小化满足x段的代价函数，利用凸性进行斜率优化。
3. **预处理转移点**：双指针预处理每个位置i的最左合法起点，加速DP转移。

### 解决难点
- **凸性证明**：需证明代价函数f(x)下凸（官方题解利用极短段相交性质）。
- **双层二分嵌套**：外层二分x，内层wqs二分处理凸优化，时间复杂度优化至O(n log²n)。
- **边界处理**：需处理三点共线情况，通过额外调整确定最终答案。

### 二分过程详解
- **外层二分区间**：left=1, right=k，检查mid是否满足总段数≥k。
- **内层wqs二分**：确定最优斜率，每次计算DP时记录最小代价与段数。
- **收缩条件**：若当前斜率对应段数≤x，调整右边界，否则左移。

# 【题解评分（≥4星）】
1. **Harry27182（4星）**  
   - 清晰的双层二分框架，代码结构规范，时间复杂度合理。  
   - 预处理转移点优化显著，但缺少凸性详细证明。

2. **DaiRuiChen007（4.5星）**  
   - 代码简洁高效，外层二分与wqs结合紧密。  
   - 通过预处理极大优化查询速度，边界处理严谨。

3. **Missa（4星）**  
   - 引入极短段相交理论证明凸性，逻辑严谨。  
   - 提供官方代码参考，优化思路明确。

# 【最优思路提炼】
1. **二分答案转判定**：将最优化问题转化为存在性检查，缩小问题规模。
2. **代价函数设计**：以段长度-1为代价，将段数约束转化为代价最小化问题。
3. **凸优化加速**：利用wqs二分处理凸函数极值，O(n)完成单次判定。
4. **极短段预处理**：双指针维护每个右端点对应的最左起点，O(1)转移。

# 【同类型题与算法套路】
- **通用模式**：当答案具有单调性且判定问题可转化为凸优化时，采用二分答案+wqs二分组合。
- **类似题目**：  
  1. 洛谷P4383 [八省联考2018] 林克卡特树（wqs二分经典）  
  2. 洛谷P4983 忘情（凸优化+斜率DP）  
  3. 洛谷P6246 [IOI2000] 邮局（二分答案+决策单调性）

# 【可视化与算法演示】
### 动画设计
1. **外层二分展示**：  
   - 用滑动条表示当前检查的x值，绿色区域表示可行解区间。  
   - 每次mid计算时高亮，红色表示不满足条件，绿色反之。

2. **内层wqs二分**：  
   - 绘制凸函数曲线，动态显示当前切点位置。  
   - 每次调整斜率时，显示DP转移路径及代价变化。

3. **像素风格交互**：  
   - 使用16色调色板，区间用不同色块表示合法/非法。  
   - 音效：收缩区间时播放“滴”声，找到解时触发胜利音效。

### 代码片段（JS动画核心）
```javascript
// 模拟二分过程
function visualize() {
  let left = 1, right = k, ans = 0;
  while (left <= right) {
    const mid = (left + right) >> 1;
    ctx.fillStyle = `hsl(${mid*10},70%,50%)`; // 动态颜色
    drawMidMarker(mid);
    if (check(mid)) {
      ans = mid;
      left = mid + 1;
      playSound('success'); 
    } else {
      right = mid - 1;
      playSound('fail');
    }
  }
}
```

# 【核心代码实现】
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+5;
int n,k,s,a[N],pre[N];
pair<int,int> dp[N];

bool check(int x){
    int l=1,r=n,res=0;
    while(l<=r){
        int mid=(l+r)>>1;
        for(int i=1;i<=n;i++) dp[i]=dp[i-1];
        if(pre[i]) dp[i]=min(dp[i],{dp[pre[i]-1].first+(i-pre[i])-mid, dp[pre[i]-1].second+1});
        if(dp[n].second<=x) res=mid, l=mid+1;
        else r=mid-1;
    }
    return dp[n].first + res*x <= n-k;
}

signed main(){
    cin>>n>>k>>s;
    for(int i=1,p=0;i<=n;i++){
        cin>>a[i]; a[i]+=a[i-1];
        while(a[i]-a[p]>=s) p++;
        pre[i]=p;
    }
    int l=1,r=k,ans=0;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)) ans=mid, l=mid+1;
        else r=mid-1;
    }
    cout<<ans;
    return 0;
}
```

---
处理用时：62.90秒
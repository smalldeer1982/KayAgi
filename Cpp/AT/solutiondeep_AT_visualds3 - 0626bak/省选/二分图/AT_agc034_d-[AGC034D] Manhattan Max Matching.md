# 题目信息

# [AGC034D] Manhattan Max Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc034/tasks/agc034_d

すぬけくんは、二次元平面上に赤いボールと青いボールを置いて遊んでいます。

すぬけくんはまず、赤いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (RX_i,RY_i) $ に $ RC_i $ 個の赤いボールを置きました。 すぬけくんは次に、青いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (BX_i,BY_i) $ に $ BC_i $ 個の青いボールを置きました。 ここで、すぬけくんが置いた赤いボールの個数の総和と青いボールの個数の総和は等しいです。 つまり、$ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $ です。 以後、この値を $ S $ とおきます。

すぬけくんはこれから、赤いボールと青いボールのペアを $ S $ 個作ろうとしています。 どのボールも、ちょうど $ 1 $ つのペアに属するようにします。 ここで、座標 $ (rx,ry) $ にある赤いボールと座標 $ (bx,by) $ にある青いボールのペアのスコアを、 $ |rx-bx|\ +\ |ry-by| $ と定義します。

すぬけくんは、ペアのスコアの総和を最大化したいです。 すぬけくんのために、ペアのスコアの総和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 0\ \leq\ RX_i,RY_i,BX_i,BY_i\ \leq\ 10^9 $
- $ 1\ \leq\ RC_i,BC_i\ \leq\ 10 $
- $ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $
- 入力される値はすべて整数である。

### Sample Explanation 1

座標 $ (0,0) $ に置いてある赤いボールと座標 $ (2,2) $ に置いてある青いボールをペアにすると、 そのスコアは $ |0-2|\ +\ |0-2|=4 $ です。 また、座標 $ (3,2) $ に置いてある赤いボールと座標 $ (5,0) $ に置いてある青いボールをペアにすると、 そのスコアは $ |3-5|\ +\ |2-0|=4 $ です。 この $ 2 $ つのペアを作ると、スコアの総和は $ 8 $ になり、これが最大です。

### Sample Explanation 2

同じ座標に複数回操作を行うこともあります。

## 样例 #1

### 输入

```
2

0 0 1

3 2 1

2 2 1

5 0 1```

### 输出

```
8```

## 样例 #2

### 输入

```
3

0 0 1

2 2 1

0 0 2

1 1 1

1 1 1

3 3 2```

### 输出

```
16```

## 样例 #3

### 输入

```
10

582463373 690528069 8

621230322 318051944 4

356524296 974059503 6

372751381 111542460 9

392867214 581476334 6

606955458 513028121 5

882201596 791660614 9

250465517 91918758 3

618624774 406956634 6

426294747 736401096 5

974896051 888765942 5

726682138 336960821 3

715144179 82444709 6

599055841 501257806 6

390484433 962747856 4

912334580 219343832 8

570458984 648862300 6

638017635 572157978 10

435958984 585073520 7

445612658 234265014 6```

### 输出

```
45152033546```

# AI分析结果



## **唯一算法分类**
**最大费用最大流**

---

## **综合分析与结论**

### **核心思路**
题目要求将红球与蓝球两两匹配，使得曼哈顿距离总和最大。暴力建图直接连所有红蓝点对会导致边数 $O(n^2)$，不可行。优化思路基于曼哈顿距离的拆分性质：
$$
|x_1-x_2|+|y_1-y_2| = \max \begin{cases} 
(x_1+y_1) + (-x_2-y_2) \\
(x_1-y_1) + (-x_2+y_2) \\
(-x_1+y_1) + (x_2-y_2) \\
(-x_1-y_1) + (x_2+y_2) 
\end{cases}
$$
通过引入**四个中间节点**分别表示四种符号组合，将边数从 $O(n^2)$ 降至 $O(n)$，从而可用费用流高效求解。

### **难点与解决**
- **难点**：直接暴力建图边数爆炸。
- **解决**：利用曼哈顿距离拆分的性质，将红球和蓝球分别连接到四个中间节点，保证费用流自动选择最大值的路径。

### **可视化设计**
- **动画方案**：动态展示费用流增广过程，红球节点→中间节点→蓝球节点的路径高亮。
- **颜色标记**：红球（红色）、蓝球（蓝色）、中间节点（黄色），增广路径用绿色闪烁。
- **交互控制**：支持暂停/继续、单步执行，调整流量和费用观察路径选择。
- **像素风格**：使用 8-bit 风格网格，节点用像素块表示，费用数值以复古字体显示。

---

## **题解清单 (≥4星)**

### **1. justin_cao（★★★★☆）**
- **亮点**：代码简洁，直接利用四个中间节点，清晰展示费用流建图逻辑。
- **代码片段**：
  ```cpp
  addx(i, p1, inf, x + y);       // 红球连到中间节点 p1
  addx(p1, i + n, inf, -x - y); // p1 连到蓝球，费用为负
  ```

### **2. xht（★★★★☆）**
- **亮点**：详细注释和变量命名，适合初学者理解。
- **关键点**：使用 `Dinic` 模板实现最大费用流，通过反向边处理费用。

### **3. FutaRimeWoawaSete（★★★★☆）**
- **亮点**：代码中明确拆分四种符号组合，逻辑清晰。
- **个人心得**：强调符号相反性（红球 `x+y` 对应蓝球 `-x-y`），避免符号错误。

---

## **最优思路提炼**

### **关键步骤**
1. **中间节点设计**：四个中间节点分别表示四种曼哈顿距离拆分形式。
2. **红球与中间节点连接**：红球连向中间节点的费用为 `x+y`、`x-y`、`-x+y`、`-x-y`。
3. **中间节点与蓝球连接**：蓝球从中间节点连出的费用为 `-bx-by`、`-bx+by`、`bx-by`、`bx+by`。
4. **费用流计算**：通过最大费用流自动选择最优路径，确保总和最大。

### **代码实现**
```cpp
// 建图核心代码
for (int i = 1; i <= n; i++) {
    addx(s, i, rc[i], 0);  // 源点→红球
    addx(i, p1, inf, rx[i] + ry[i]);  // 红球→中间节点1
    addx(i, p2, inf, rx[i] - ry[i]);  // 红球→中间节点2
    addx(i, p3, inf, -rx[i] + ry[i]); // 红球→中间节点3
    addx(i, p4, inf, -rx[i] - ry[i]); // 红球→中间节点4
}
for (int i = 1; i <= n; i++) {
    addx(i + n, t, bc[i], 0);        // 蓝球→汇点
    addx(p1, i + n, inf, -bx[i] - by[i]); // 中间节点1→蓝球
    addx(p2, i + n, inf, -bx[i] + by[i]); // 中间节点2→蓝球
    addx(p3, i + n, inf, bx[i] - by[i]);  // 中间节点3→蓝球
    addx(p4, i + n, inf, bx[i] + by[i]);  // 中间节点4→蓝球
}
```

---

## **同类型题推荐**
1. **P4015 运输问题**（费用流经典问题）
2. **P2153 [SDOI2009]晨跑**（费用流与流量限制）
3. **CF730I 程序员分配**（类似拆点优化）

---

## **可视化与算法演示**

### **像素风格动画设计**
- **Canvas 网格**：红球、蓝球、中间节点用不同颜色方块表示。
- **增广路径高亮**：绿色线条动态流动，显示当前选择的中间节点。
- **音效触发**：每次增广成功播放 8-bit 上升音效，流量更新时伴随“滴”声。

### **交互功能**
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **单步执行**：按空格键逐步执行 SPFA 和增广过程。
- **自动模式**：AI 自动运行，展示费用流如何选择最优路径。

---

## **个人心得摘录**
> “**符号相反性**是本题关键，红球的 `x+y` 必须对应蓝球的 `-x-y`，否则费用计算错误。”（摘自 FutaRimeWoawaSete 的题解）  
> “费用流模板中，反向边的费用为原边的负数，这是保证正确性的核心。”（摘自 xht 的题解）

---

## **复古游戏化演示（JS 伪代码）**
```javascript
// Canvas 初始化与绘图
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");

function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 32, y * 32, 32, 32); // 32x32 像素块
}

// 播放音效
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}

// 动态增广路径演示
function animateAugmentingPath(path) {
    path.forEach((node, idx) => {
        setTimeout(() => {
            highlightNode(node); // 高亮当前节点
            if (idx > 0) drawFlowLine(path[idx-1], node); // 画流动线
            playSound("step");
        }, idx * 500);
    });
}
```

---
处理用时：102.68秒
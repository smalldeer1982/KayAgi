# 题目信息

# [AGC069B] Pair Guessing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc069/tasks/agc069_b

$ N $ 個の、長さ $ N $ の $ 01 $ 文字列 $ S_1,\ldots,S_N $ が与えられます。$ S_i $ の $ j $ 文字目を $ S_{i,j} $ と表します。ここで、$ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在することが制約より保証されています。

高橋君と青木君が以下のようなゲームを行います。

1. 高橋君が $ 1\ \leq\ i,j\ \leq\ N,\ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ を $ 1 $ つ選ぶ。
2. $ 0 $ 回以上 $ N $ 回以下、青木君が高橋君に質問を行う。各質問では青木君が $ 1\leq\ i',j'\ \leq\ N $ を満たす整数組 $ (i',j') $ を選び、「$ i=i' $ と $ j=j' $ のうち少なくとも一方が成り立つ」の真偽を高橋君から教えてもらう。
3. 青木君が $ (i,j) $ を予想する。予想が当たっていれば青木君の勝ち、そうでなければ負けとなる。
 
青木君は高橋君が選ぶ $ (i,j) $ の候補、すなわち $ S_1,\ldots,S_N $ を知った状態でゲームを行います。また、上記2では以前の質問に対する返事を聞いたうえで $ (i',\ j') $ を選ぶことができます。

青木君が適切な戦略を取った場合、高橋君の $ (i,j) $ の選び方や運によらず必ずゲームに勝てるかどうかを判定してください。

$ 1 $ つの入力につきテストケースは $ T $ 個あります。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 500 $
- $ 1 $ つの入力の中のテストケースすべてにわたる $ N^2 $ の総和は $ 500^2 $ 以下である
- $ S_i $ は長さ $ N $ の $ 01 $ 文字列
- $ S_{i,j}=\ $ `1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在する
 
### Sample Explanation 1

$ 1 $ 番目のテストケースに対するゲームの一例を以下に示します。 1. 高橋君が $ S_{i,j}=\ $`1` を満たす $ (i,j) $ として $ (2,2) $ を選ぶ。 2. 青木君が $ 2 $ 回質問を行う。$ 1 $ 回目の質問では $ (i',j')=(1,1) $ として、高橋君から「$ i=1 $ と $ j=1 $ のうち少なくとも一方が成り立つ」が偽であると教えてもらう。$ 2 $ 回目の質問では $ (i',j')=(2,2) $ として、高橋君から「$ i=2 $ と $ j=2 $ の少なくとも一方が成り立つ」が真であると教えてもらう。 3. 青木君が $ (i,j)=(2,2) $ と予想する。この予想は当たっているため、青木君の勝ちである。 これはあくまでゲームの一例であり、青木君の戦略が適切とは限りません。しかし、青木君が適切な戦略を取った場合には必ず青木君がゲームに勝つため、$ 1 $ 番目のテストケースに対する出力は `Yes` になります。

## 样例 #1

### 输入

```
3

2

01

11

2

11

11

10

0101011110

1100100001

1101100000

0111101010

1000011001

1110101010

1110110100

1110000110

0000001011

1001111100```

### 输出

```
Yes

No

Yes```

# AI分析结果



1. **算法分类**  
   Ad-hoc（基于二分图建模与并查集）

---

### **综合分析与结论**

#### **核心思路**
- **问题转化**：将每个 `0` 的位置视为连接行与列的边，构建二分图模型。
- **连通块统计**：用并查集计算二分图的连通块大小，每个连通块贡献 `siz-1` 次有效操作。
- **条件判断**：
  - `n ≤ 2` 时单独处理（如 `n=2` 要求存在至少一个 `0`）。
  - `n > 2` 时要求总贡献 `≥ n-2`（允许部分冗余操作）。

#### **可视化设计**
- **网格绘制**：以像素风格显示 `n×n` 的网格，`0` 为红色方块，`1` 为蓝色方块。
- **连通块动态合并**：点击 `0` 时，触发行与列的合并动画（黄色高亮），同时播放“连接音效”。
- **统计面板**：实时显示连通块贡献总和 `ans` 与条件阈值 `n-2`。
- **复古音效**：合并成功时播放短促的 `8-bit` 音效；条件达成时播放胜利音调。

---

### **题解清单 (≥4星)**

1. **gdf_yhm (4星)**  
   - **亮点**：正确处理 `n>2` 的边界条件，代码简洁。
   - **代码关键**：通过并查集统计连通块，动态调整条件判断。

2. **complete_binary_tree (4星)**  
   - **亮点**：独立处理 `n=2` 的特殊情况，逻辑清晰。
   - **个人心得**：手模发现 `n>2` 时的条件差异，调整贡献阈值。

---

### **最优思路提炼**

1. **二分图建模**  
   - 每个 `0` 的位置 `(i,j)` 对应边 `i → j+n`，将行列映射为二分图的两部分节点。
2. **并查集统计**  
   - 合并连通块后，每个块的贡献为 `siz[block] - 1`。
3. **动态条件调整**  
   - 根据 `n` 的大小动态判断总贡献是否足够（`n-1` 或 `n-2`）。

---

### **同类型题推荐**

1. **P3386 二分图最大匹配**  
   - 核心：匈牙利算法的应用。
2. **P1197 星球大战**  
   - 逆向并查集与连通块统计。
3. **P1967 货车运输**  
   - 最大生成树与路径查询。

---

### **代码实现（核心逻辑）**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
int fa[N<<1], t, n, ans;

void init(int n) {
    for(int i=1; i<=2*n; ++i) fa[i] = i;
}

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void solve() {
    cin >> n;
    init(n);
    ans = 0;
    for(int i=1; i<=n; ++i) {
        string s; cin >> s;
        for(int j=1; j<=n; ++j) {
            if(s[j-1] == '0') {
                int u = find(i), v = find(j + n);
                if(u != v) fa[u] = v, ans++;
            }
        }
    }
    bool ok;
    if(n <= 2) {
        ok = (n == 1) || (ans >= 1); // n=2需至少一个0
    } else {
        ok = ans >= n - 2;
    }
    cout << (ok ? "Yes\n" : "No\n");
}

int main() {
    ios::sync_with_stdio(false);
    cin >> t;
    while(t--) solve();
    return 0;
}
```

---

### **可视化与游戏化设计**

#### **像素动画方案**
- **Canvas 初始化**：绘制 `n×n` 网格，每个单元格为 `16×16` 像素。
- **操作高亮**：选中 `0` 时，其所在行和列闪烁黄色边框。
- **连通块合并**：动态显示行与列的合并，合并后的区域用绿色填充。

#### **音效设计**
- **点击音效**：8-bit 短音（类似 FC 按键声）。
- **合并成功**：上升音调（频率 `440Hz → 880Hz`）。
- **条件达成**：播放经典 FC 过关音乐片段。

#### **自动演示模式**
- **AI 策略**：优先选择能最大化连通块贡献的 `0` 进行合并。
- **速度调节**：支持 `0.5x/1x/2x` 速度切换，适应不同学习节奏。

---

### **个人心得摘录**

- **边界条件陷阱**：`n=2` 时全 `1` 矩阵必败，需单独判断。
- **条件调整经验**：WA 后发现 `n>2` 的贡献阈值应降为 `n-2`，避免过度严格。

---

**可视化示例（伪代码）**  
```javascript
// 绘制网格
function drawGrid(n) {
    for(let i=0; i<n; i++) {
        for(let j=0; j<n; j++) {
            ctx.fillStyle = grid[i][j] ? 'blue' : 'red';
            ctx.fillRect(j*16, i*16, 16, 16);
        }
    }
}

// 合并动画
function mergeAnimation(i, j) {
    highlightRow(i, 'yellow');
    highlightColumn(j, 'yellow');
    playSound('merge_sound');
    setTimeout(() => updateBlocks(), 500);
}
```

---
处理用时：96.14秒
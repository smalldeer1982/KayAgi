# 题目信息

# [AGC003D] Anticube

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc003/tasks/agc003_d

高橋君は誕生日にお母さんから正の整数 $ s_1,...,s_N $ をもらいました。ただし、要素の重複は許されます。 高橋君は、これらの$ N $個の整数のうちのいくつかを丸で囲みます。

高橋君は立方数が嫌いなので、$ s_i,s_j(i\ ≠\ j) $の両方が丸で囲まれているなら、その積$ s_is_j $は立方数とならないようにしたいです。 例えば、$ s_1=1,s_2=1,s_3=2,s_4=4 $のとき、$ s_1 $と$ s_2 $を同時に丸で囲むことはできません。また、$ s_3 $と$ s_4 $を同時に丸で囲むこともできません。

高橋君が丸で囲むことができる整数の個数の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ s_i\ ≦\ 10^{10} $
- 入力はすべて整数である。

### Sample Explanation 1

$ 1,2,3,5,6,7 $ を丸で囲むことができます。

## 样例 #1

### 输入

```
8

1

2

3

4

5

6

7

8```

### 输出

```
6```

## 样例 #2

### 输入

```
6

2

4

8

16

32

64```

### 输出

```
3```

## 样例 #3

### 输入

```
10

1

10

100

1000000007

10000000000

1000000009

999999999

999

999

999```

### 输出

```
9```

# AI分析结果



## 算法分类
**数论、质因数分解、哈希映射**

---

## 题解思路与算法要点

### 核心思路
- **质因数标准化**：将每个数的质因数指数模3，使得两个数的乘积为立方数当且仅当它们的标准化形式互为补数。
- **补数匹配**：对于每个数，计算其补数（即每个质因数指数为3减去原指数后的结果），用哈希表统计各标准化形式及其补数的出现次数，取较大值加入答案。

### 解决难点
1. **高效质因数分解**：预处理小质数（≤2160）的立方因子，去除后剩余部分分为大质数、平方数或两质数乘积。
2. **大数处理**：剩余部分若为大于1e5的质数或无法形成补数，则直接计入答案。
3. **特殊处理**：立方数（如1）仅能选一个。

---

## 最优思路提炼
1. **预处理小质数立方因子**，快速分解每个数。
2. **分类讨论剩余部分**，判断是否为质数、平方数或乘积。
3. **哈希映射记录出现次数**，统计补数对的最大值。
4. **时间复杂度优化**：通过预处理质数，将分解复杂度降至O(n³√s)。

---

## 可视化算法演示
### 动画方案
1. **分解过程**：展示每个数逐步去除小质数的立方因子，剩余部分以不同颜色标记（质数、平方数、乘积）。
2. **补数匹配**：用箭头连接互为补数的数对，动态统计哈希表中两者的数量。
3. **高亮关键步骤**：
   - 立方因子去除步骤（如红色方块标记被除去的因子）。
   - 剩余部分分类判断（如绿色表示可匹配，灰色表示无法匹配）。
4. **复古像素风格**：
   - 质数以8位像素方块表示，颜色按大小区分。
   - 分解过程伴随经典音效（如“分解完成”音效）。

### 交互设计
- **步进控制**：用户可逐帧观察分解和匹配过程。
- **自动演示**：模拟“AI贪吃蛇”模式自动完成所有步骤，背景音乐为8位风格循环曲。

---

## 题解评分（≥4星）
1. **CYJian (5星)**：思路清晰，预处理质数立方因子，剩余部分分类高效，代码结构简洁。
2. **K8He (4.5星)**：直接计算补数，哈希统计，逻辑简明，但代码可读性稍逊。
3. **yijan (4星)**：巧妙处理大质数，优化分解步骤，但实现细节复杂。

---

## 核心代码实现
```cpp
// 预处理质数立方因子
void init(int n) {
    for (int i = 1; i <= tot; i++) {
        ll cube = pri[i] * pri[i] * pri[i];
        while (x % cube == 0) x /= cube;
    }
}

// 标准化与补数计算
pair<ll, ll> compute_pair(ll x) {
    ll norm = 1, pair = 1;
    for (int i = 1; i <= tot; i++) {
        if (x % pri[i] == 0) {
            int cnt = 0;
            while (x % pri[i] == 0) x /= pri[i], cnt++;
            cnt %= 3;
            if (cnt == 1) {
                norm *= pri[i];
                pair *= pri[i] * pri[i];
            } else if (cnt == 2) {
                norm *= pri[i] * pri[i];
                pair *= pri[i];
            }
        }
    }
    // 处理剩余部分...
    return {norm, pair};
}
```

---

## 相似题目
1. **洛谷 P1069**：细胞分裂（质因数分解与指数匹配）
2. **洛谷 P2043**：质因数分解（分解技巧）
3. **洛谷 P2423**：质数方阵（质数性质与组合）

---
处理用时：63.09秒
# 题目信息

# [AGC045B] 01 Unbalanced

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc045/tasks/agc045_b

文字列 $ S $ が与えられます． $ S $ の各文字は，`0`,`1`,`?` のいずれかです．

$ S $ に含まれる全ての `?` を `0` か `1` に変えて（`?` ごとに変換後の文字を選択できます），文字列 $ S' $ を作ることを考えます． ここで，$ S' $ のアンバランス度を，次のように定義します．

- $ S' $ のアンバランス度 $ =\ \max\ \{\ S' $ の $ l $ 文字目から $ r $ 文字目までに含まれる `0` の個数と `1` の個数の差の絶対値 $ :\ 1\ \leq\ l\ \leq\ r\ \leq\ |S|\} $

$ S' $ のアンバランス度としてありうる最小の値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 10^6 $
- $ S $ の各文字は `0`,`1`,`?` のいずれかである．

### Sample Explanation 1

$ S'= $`010` とすれば，アンバランス度は $ 1 $ になり，これが最小です．

## 样例 #1

### 输入

```
0??```

### 输出

```
1```

## 样例 #2

### 输入

```
0??0```

### 输出

```
2```

## 样例 #3

### 输入

```
??00????0??0????0?0??00??1???11?1?1???1?11?111???1```

### 输出

```
4```

# AI分析结果



# 【AGC045B】01 Unbalanced 题解分析

## 唯一算法分类
**贪心算法**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **前缀和极差转化**  
   将 `0` 视为 -1，`1` 视为 +1，问题转化为最小化前缀和数组的极差（最大值 - 最小值）。

2. **初始贪心构造**  
   先将所有 `?` 设为 -1（即 `0`），计算初始前缀和的最大值（记为 `max_sum`）。

3. **动态调整策略**  
   从左到右遍历，尝试将部分 `?` 改为 +1（即 `1`），但需保证调整后的前缀和不超过某个限制值。通过预处理后缀信息（如后缀可能的最大前缀和）辅助决策。

4. **仅需两种限制值**  
   观察到当限制值增加 2 时，极差不会更优，因此只需计算 `max_sum` 和 `max_sum + 1` 两种情况。

### 解决难点
- **极差的动态性**：调整一个 `?` 会影响整个前缀和数组的极差，需高效维护。
- **正确性证明**：需证明只需处理两种限制值即可，依赖数学观察（极差随限制值变化的单调性）。

---

## 题解评分（≥4星）

1. **Tokai__Teio（★★★★☆）**  
   - 思路清晰，代码简洁，预处理后缀最大值辅助贪心决策。
   - 关键代码逻辑清晰，注释明确，易于理解。

2. **Vasily0959（★★★★☆）**  
   - 提出“打表找规律”的实战技巧，代码紧凑，预处理后缀最大值。
   - 实现高效，但代码可读性稍差。

3. **未来姚班zyl（★★★★☆）**  
   - 代码简洁，核心逻辑与Tokai__Teio一致，但未处理后缀最大值。

---

## 最优思路或技巧提炼

### 核心技巧
- **前缀和极差转化**：将区间问题转化为前缀和极差问题。
- **贪心调整策略**：优先将 `?` 设为 -1，再在不超过限制值的前提下尽可能改为 +1。
- **后缀预处理**：计算每个位置的后缀最大值，支持快速判断是否可调整。

### 代码实现
```cpp
int calc(int limit) {
    int cnt = 0, mn = 0;
    for (int i = 1; i <= len; ++i) {
        if (a[i] == '0') cnt--;
        else if (a[i] == '1') cnt++;
        else {
            // 检查改为 +1 后是否仍满足限制
            if (cnt + sum[i+1] + 1 <= limit) cnt++;
            else cnt--;
        }
        mn = min(mn, cnt); // 维护最小值
    }
    return limit - mn; // 极差
}
```

---

## 同类型题或类似算法套路

1. **极差最小化问题**：通常转化为固定一端，优化另一端（如固定最大值，求最大最小值）。
2. **前缀和+贪心**：如 [LeetCode 678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)，通过维护可能的区间极值。

---

## 推荐题目
1. **P1115 最大子段和**（前缀和极差变体）
2. **AT1219 歴史の研究**（滑动窗口极值）
3. **CF1526C2 Potions (Hard Version)**（贪心维护极值）

---

## 可视化与算法演示

### 动画方案
1. **前缀和曲线**  
   - 绘制前缀和折线图，初始所有 `?` 为 -1，曲线向下走。
   - 遍历时高亮当前字符，若为 `?` 显示可能的两种选择（+1/-1）。

2. **调整决策**  
   - 颜色标记：红色表示调整为 +1，蓝色表示保持 -1。
   - 显示当前限制值（如 `max_sum`），若调整为 +1 后曲线超过限制，触发红色警告。

3. **动态极差计算**  
   - 实时显示当前最大值和最小值，极差用垂直距离表示。

### 复古像素风格设计
- **颜色方案**：8-bit 调色板（绿、红、蓝、黄）。
- **音效**：调整字符时播放“哔”声，极差更新时播放上升音调。
- **Canvas 绘制**：网格化前缀和曲线，每步动画更新一格。

---

## 个人心得摘录
- **Vasily0959**：“少证一点，你在打比赛”——强调实战中快速验证思路的重要性。
- **wosile**：“初始代码 WA 后发现需考虑两种限制值”——调试经验的关键性。

---
处理用时：69.28秒
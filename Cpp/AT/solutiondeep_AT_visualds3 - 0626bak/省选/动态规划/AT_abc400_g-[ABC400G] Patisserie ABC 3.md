# 题目信息

# [ABC400G] Patisserie ABC 3

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc400/tasks/abc400_g

在 ABC 西点店工作的糕点师高桥君决定为纪念 AtCoder Beginner Contest 400 推出特别蛋糕套装。

ABC 西点店销售 $N$ 种蛋糕，分别为蛋糕 $1$，蛋糕 $2$，……，蛋糕 $N$。  
每个蛋糕具有三个非负整数值属性：美观度、美味度和人气度。具体来说，蛋糕 $i$ 的美观度、美味度、人气度分别为 $X_i$，$Y_i$，$Z_i$。

高桥君计划将蛋糕无重复地组成 $K$ 对进行销售。  
形式化地说，需要选出 $2K$ 个**互不相同**的 $1$ 到 $N$ 之间的整数 $a_1, b_1, a_2, b_2, \ldots, a_K, b_K$，并将蛋糕 $a_i$ 与蛋糕 $b_i$ 组成一对。  
当蛋糕 $a_i$ 与蛋糕 $b_i$ 组成一对时，该对的价格定义为 $\max(X_{a_i} + X_{b_i},\ Y_{a_i} + Y_{b_i},\ Z_{a_i} + Z_{b_i})$。  
其中 $\max(P, Q, R)$ 表示 $P, Q, R$ 中的最大值。

请计算这 $K$ 对蛋糕价格总和的可能最大值。

给定 $T$ 个测试用例，请对每个用例输出答案。

## 说明/提示

### 约束条件

- $1 \leq T \leq 1000$
- $2 \leq N \leq 10^5$
- 对于每个输入文件，所有测试用例的 $N$ 总和不超过 $10^5$。
- $1 \leq K \leq \lfloor \frac{N}{2} \rfloor$（对于实数 $x$，$\lfloor x \rfloor$ 表示不超过 $x$ 的最大整数）。
- $0 \leq X_i, Y_i, Z_i \leq 10^9$
- 输入中的所有值均为整数

### 样例解释 1

从 $3$ 个蛋糕中选择 $1$ 对：  
- 蛋糕 $1$ 和 $2$ 组成的对价格为 $\max(6+3, 3+5, 8+0) = 9$  
- 蛋糕 $1$ 和 $3$ 组成的对价格为 $\max(6+2, 3+7, 8+3) = 11$  
- 蛋糕 $2$ 和 $3$ 组成的对价格为 $\max(3+2, 5+7, 0+3) = 12$  
因此选择蛋糕 $2$ 和 $3$ 组成的对，输出 $12$。

### 样例解释 2

注意每个蛋糕最多只能出现在一个对中。此外，即使不同种类的蛋糕，其美观度、美味度、人气度也可能完全相同。  
对于第一个测试用例，选择蛋糕 $1$ 和 $2$（价格 $6$）以及蛋糕 $3$ 和 $5$（价格 $203$），总价格为 $209$。  
对于第二个测试用例，选择蛋糕 $2$ 和 $3$（价格 $176$）以及蛋糕 $4$ 和 $5$（价格 $157$），总价格为 $333$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
1

3 1

6 3 8

3 5 0

2 7 3```

### 输出

```
12```

## 样例 #2

### 输入

```
2

5 2

1 2 3

1 2 3

1 2 3

1 2 3

100 100 200

6 2

21 74 25

44 71 80

46 28 96

1 74 24

81 83 16

55 31 1```

### 输出

```
209

333```

# AI分析结果



## 算法分类  
动态规划、状态压缩、贪心排序  

## 题解思路与核心难点  
### 问题转化  
将每对蛋糕的贡献拆解为三个属性（x,y,z）的线性组合，要求每个属性的总选取次数为偶数。此时问题转化为：  
- 从所有蛋糕中选择 2K 个元素  
- 每个元素可贡献 x/y/z 中的一个值  
- 保证 x/y/z 三者的总选取次数均为偶数  
- 最大化总贡献值  

### 关键突破点  
1. **贪心预处理**：按 max(x,y,z) 降序排列，优先考虑能产生高贡献的蛋糕  
2. **调整证明**：前 2K 个元素中最多有 3 个未被选中，可大幅减少状态维度  
3. **状态压缩 DP**：用 3 位二进制表示三个属性的奇偶性，结合前后两段 DP 合并结果  

### 解决难点对比  
| 题解 | 核心方法 | 时间复杂度 | 优化思路 |  
|------|----------|------------|----------|  
| Disjoint_cat | 分段 DP + 状态压缩 | O(n log n) | 利用调整上限证明，将状态维度从 O(k) 压缩到 O(1) |  
| luanyanjia | 全序列状态压缩 DP | O(n) | 直接处理奇偶性约束，无贪心预处理 |  
| xiao7_Mr_10_ | WQS 二分 | O(n log V) | 通过凸性优化去掉 K 的限制 |  

## 最优题解评分  
⭐️⭐️⭐️⭐️⭐️ **Disjoint_cat**  
- **思路清晰度**：严格数学证明调整上限，逻辑严密  
- **代码可读性**：状态转移简洁，注释明确  
- **算法优化**：巧妙结合贪心与状态压缩，复杂度最优  

⭐️⭐️⭐️⭐️ **ax_by_c**  
- **实现简洁性**：状态定义与转移高度对称  
- **实践可操作性**：代码结构清晰，易于调试  

⭐️⭐️⭐️ **luanyanjia**  
- **理论完备性**：完整处理奇偶性约束  
- **局限性**：未利用贪心优化，实际运行效率较低  

## 最优思路提炼  
### 贪心排序预处理  
```cpp  
sort(a+1, a+n+1, [](auto x, auto y) { 
    return max({x[0],x[1],x[2]}) > max({y[0],y[1],y[2]});
});
```  
按每个蛋糕可能产生的最大贡献降序排列，确保优先处理高价值候选  

### 分段动态规划  
**前段 DP** (`f[i][j][S]`): 处理前 2K 个元素  
- `j`: 跳过的元素数 (0 ≤ j ≤ 3)  
- `S`: 三属性奇偶状态 (3 位二进制)  
**后段 DP** (`g[i][j][S]`): 处理剩余元素  
- 倒序转移，与前段对称  

### 状态转移核心  
```cpp  
// 前段转移：选属性或跳过  
ck(dp[i][j], dp[i-1][j] + a[i][0]); 
ck(dp[i][j^1], dp[i-1][j] + a[i][1]);
ck(dp[i][j^2], dp[i-1][j] + a[i][2]);
if(j < 8) ck(dp[i][j+4], dp[i-1][j]);

// 后段转移：倒序处理  
if(j < 8) ck(dp[i][j+4], dp[i+1][j] + a[i][0]);
```  
每次转移同时维护跳过的元素数和奇偶状态  

## 同类型题推荐  
1. **CF1398E** - 带权匹配与状态压缩  
2. **LOJ#6045** - 多重约束下的最优配对  
3. **Luogu P2893** - 奇偶性约束的动态规划  

## 可视化设计  
### 动态规划状态机演示  
![状态转移示意图](https://i.imgur.com/7YqGJkH.gif)  
- **颜色标记**：  
  - 红色：当前处理元素  
  - 绿色：x 属性选中  
  - 蓝色：y 属性选中  
  - 黄色：z 属性选中  
- **状态面板**：显示当前奇偶状态与跳过计数  
- **音效设计**：  
  - 选中属性：8-bit "beep" 音  
  - 状态变更：低频 "click" 音  

### 复古像素风格实现  
```javascript  
// Canvas 绘制示例  
function drawCake(ctx, x, y, selected) {
    ctx.fillStyle = selected ? '#FF5555' : '#5555FF'; 
    ctx.fillRect(x*32, y*32, 28, 28); // 像素方块绘制
    // 绘制属性标记...
}
```  
使用 32x32 像素网格，每个蛋糕对应一个闪烁方块，选中时播放经典 FC 音效  

## 核心代码实现  
```cpp  
memset(dp, 0xc0, 8*12*(n+3)); 
dp[0][0] = dp[n+1][0] = 0;

// 前段 DP
for(int i=1; i<=k<<1; i++) {
    for(int j=0; j<12; j++) {
        ck(dp[i][j], dp[i-1][j] + a[i][0]);
        ck(dp[i][j^1], dp[i-1][j] + a[i][1]);
        ck(dp[i][j^2], dp[i-1][j] + a[i][2]);
        if(j < 8) ck(dp[i][j+4], dp[i-1][j]);
    }
}

// 后段 DP 
for(int i=n; i>k<<1; i--) {
    for(int j=0; j<12; j++) {
        if(j < 8) ck(dp[i][j+4], dp[i+1][j] + a[i][0]);
        // 类似处理 y/z 属性...
        ck(dp[i][j], dp[i+1][j]);
    }
}

// 合并结果
ll ans = 0;
for(int i=0; i<12; i++) 
    ck(ans, dp[k<<1][i] + dp[(k<<1)+1][i]);
```  
完整代码见原题解提交

---
处理用时：72.58秒
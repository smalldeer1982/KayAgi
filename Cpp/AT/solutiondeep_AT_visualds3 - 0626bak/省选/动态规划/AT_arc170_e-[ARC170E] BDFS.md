# 题目信息

# [ARC170E] BDFS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_e

整数 $ N,P $ が与えられます．

頂点に $ 1 $ から $ N $ の番号が付いた $ N $ 頂点 $ N $ 辺のグラフがあります．$ i $ 番目の辺は頂点 $ i $ と頂点 $ i+1 $ を双方向に結んでいます．ここで頂点 $ N+1 $ は頂点 $ 1 $ を意味します．

以下のアルゴリズムを行い，長さ $ N $ の数列 $ D=(D_1,D_2,\ldots,D_N) $ を得ます．

- 長さ $ N $ の整数列 $ D $ を $ D=(D_1,\ldots,D_N)=(-1,\ldots,-1) $ で定める．また，数のペアの列 $ Q $ を $ Q=((1,0)) $ で定める．$ Q $ が空でない限り，以下の処理を繰り返す．
  
  
  - $ Q $ の先頭の要素を $ (v,d) $ とする．先頭の要素を削除する．
  - $ D_v\ =\ -1 $ の場合，$ D_v\ :=\ d $ とし，頂点 $ v $ に隣接して $ D_x=-1 $ を満たすような各頂点 $ x $ に対して以下の処理を行う．ただし条件を満たす $ x $ が複数存在する場合，頂点番号の小さい順に処理を行う．
      
      
      1. 確率 $ \frac{P}{100} $ で $ Q $ の**先頭**に $ (x,d+1) $ を追加する．
      2. $ Q $ の先頭への $ (x,d+1) $ の追加を行わなかった場合，$ Q $ の**末尾**に $ (x,d+1) $ を追加する．
 
最終的に得られる $ D $ の要素の総和の期待値を $ \text{mod\ }\ 998244353 $ で求めてください．

$ T $ 個のテストケースが与えられるので，それぞれについて答えてください．

   期待値 $ \text{mod\ }\ 998244353 $ の定義  求める期待値は必ず有理数になることが証明できます． また，この問題の制約下では，その値を既約分数 $ \frac{P}{Q} $ で表したときに $ Q $ が $ 998244353 $ で割り切れないことが保証されます． このとき $ R\times\ Q\ \equiv\ P\pmod{998244353} $ を満たすような $ 0 $ 以上 $ 998244352 $ 以下の整数 $ R $ が一意に定まります．この $ R $ を 答えてください．

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^4 $
- $ 3\ \leq\ N\ \leq\ 10^{18} $
- $ 1\leq\ P\ \leq\ 99 $
- 入力される数値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のテストケースでは，例えば以下のようにアルゴリズムは動きます． - はじめ，$ D=(-1,-1,-1),\ Q=((1,0)) $ である．$ Q $ の先頭の要素 $ (1,0) $ を削除する． - $ D_1\ =\ -1 $ なので，$ D_1\ :=\ 0 $ とする．頂点 $ 1 $ に隣接して $ D_x=\ -1 $ を満たすような頂点 $ x $ は $ 2,3 $ が考えられる． - $ Q $ の先頭に $ (2,1) $ を追加する．$ Q $ の末尾に $ (3,1) $ を追加する．$ Q=((2,1),(3,1)) $ となる． - $ Q $ の先頭の要素 $ (2,1) $ を削除する． - $ D_2\ =\ -1 $ なので，$ D_2\ :=\ 1 $ とする．頂点 $ 2 $ に隣接して $ D_x=\ -1 $ を満たすような頂点 $ x $ は $ 3 $ が考えられる． - $ Q $ の先頭に $ (3,2) $ を追加する．$ Q=((3,2),(3,1)) $ となる． - $ Q $ の先頭の要素 $ (3,2) $ を削除する． - $ D_3\ =\ -1 $ なので，$ D_3\ :=\ 2 $ とする．頂点 $ 3 $ に隣接して $ D_x=\ -1 $ を満たすような頂点 $ x $ は存在しないので何もしない． - $ Q $ の先頭の要素 $ (3,1) $ を削除する． - $ D_3\ =2 $ なので何もしない． - $ Q $ が空になったので処理を終了する． この場合，最終的に $ D=(0,1,2) $ が得られます．アルゴリズムが上記の動作をする確率は $ \frac{1}{8} $ であり，$ D $ の要素の総和の期待値は $ \frac{5}{2} $ です．

## 样例 #1

### 输入

```
3

3 50

4 1

1000000000000000000 70```

### 输出

```
499122179

595552585

760296751```

# AI分析结果



0. **题目翻译**

---

# [ARC170E] BDFS

## 题目描述

给定整数 $ N,P $。

一个由 $ N $ 个顶点 $ N $ 条边构成的环状图中（顶点编号为 $ 1 \sim N $，其中顶点 $ N+1 $ 视为顶点 $ 1 $），执行如下算法生成序列 $ D=(D_1,D_2,\ldots,D_N) $：

1. 初始化 $ D=(-1,\ldots,-1) $，队列 $ Q=((1,0)) $
2. 当 $ Q $ 非空时循环执行：
   - 取出队首元素 $ (v,d) $
   - 若 $ D_v=-1 $，则：
     - 设置 $ D_v=d $
     - 将 $ v $ 的未访问邻接点按编号升序处理：
       - 以 $ P\% $ 概率将 $ (x,d+1) $ **插入队首**
       - 否则插入队尾

求最终 $ D $ 的元素总和的期望值，结果对 $ 998244353 $ 取模。

**输入格式**  
$ T $ 组测试数据，每组输入 $ N,P $。

**数据范围**  
- $ 1 \leq T \leq 10^4 $
- $ 3 \leq N \leq 10^{18} $
- $ 1 \leq P \leq 99 $

---

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**

### 核心思路
将环状图的BFS过程抽象为双向扩展模型：初始区间为单点 $ [1,1] $，每次操作以概率 $ p $ 向左扩展，或以 $ 1-p $ 向右扩展。最终需要计算所有节点的深度期望总和。

### 动态规划建模
定义状态：
- $ f_0 $：当前优先扩展方向的累计深度期望
- $ f_1 $：另一方向的累计深度期望
- $ ans $：总期望

状态转移方程：
$$
\begin{aligned}
f_0' &= p \cdot f_0 + (1-p) \cdot f_1 + 1 \\
f_1' &= (1-p) \cdot f_0 + p \cdot f_1 \\
ans' &= ans + p \cdot f_0 + (1-p) \cdot f_1 + 1
\end{aligned}
$$

### 矩阵加速
将递推式转化为矩阵形式，通过快速幂在 $ O(\log N) $ 时间完成计算：

$$
\begin{pmatrix}
f_0' \\
f_1' \\
ans' \\
1
\end{pmatrix}
=
\begin{pmatrix}
p & 1-p & 1 & 0 \\
1-p & p & 0 & 0 \\
p & 1-p & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
f_0 \\
f_1 \\
ans \\
1
\end{pmatrix}
$$

### 可视化设计
**动画方案**：  
- **像素网格**：以 16x16 像素块展示矩阵元素，不同颜色区分转移系数（如红色表示 $ p $，蓝色表示 $ 1-p $）
- **音效提示**：矩阵乘法运算时播放 8-bit 风格音效，步进时播放"滴答"声
- **自动演示**：按二进制分解展示快速幂过程，高亮当前位是否为1
- **交互控制**：支持暂停/继续、单步执行、速度调节（1x/2x/0.5x）

---

3. **题解清单 (≥4星)**

| 作者          | 评分 | 核心亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| NobodyThere   | ★★★★☆ | 将复杂BFS抽象为双指针模型，推导出简洁的线性递推式，矩阵构造清晰          |
| DaiRuiChen007 | ★★★★☆ | 使用4维状态矩阵，代码实现简洁高效，包含取模优化和矩阵乘法模板            |

---

4. **代码实现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
typedef array<array<ll,4>,4> Mat;
const int MOD=998244353, inv=828542813; // 100的逆元

inline Mat operator*(const Mat &u, const Mat &v) {
    Mat w{}; // 初始化零矩阵
    for(int i=0; i<4; ++i)
        for(int k=0; k<4; ++k)
            if(u[i][k]) // 稀疏性优化
                for(int j=0; j<4; ++j) 
                    w[i][j] = (w[i][j] + u[i][k]*v[k][j]) % MOD;
    return w;
}

void solve() {
    ll n, p;
    scanf("%lld%lld", &n, &p);
    --n; // 转换为操作次数
    p = 1LL * p * inv % MOD; // 概率取模
    
    Mat I = {{
        {p, (1-p+MOD)%MOD, 1, 0},        // f0' = p*f0 + (1-p)*f1 + 1
        {(1-p+MOD)%MOD, p, 0, 0},        // f1' = (1-p)*f0 + p*f1
        {p, (1-p+MOD)%MOD, 1, 0},        // ans'= ans + p*f0 + (1-p)*f1 +1
        {0, 0, 0, 1}                     // 常数项
    }}, X = {}; 
    X[0][2] = 1; // 初始状态: ans=0, 其他由常数项推导
    
    // 矩阵快速幂核心
    for(; n; n >>= 1, I = I*I)
        if(n & 1) X = X * I;
    
    printf("%lld\n", X[0][3]); // 输出最终ans
}

int main() {
    int T; scanf("%d", &T);
    while(T--) solve();
    return 0;
}
```

**实现要点**：
- 矩阵乘法利用稀疏性优化计算
- 统一使用long long防止溢出
- 预计算概率逆元优化取模运算

---

5. **相似题目推荐**

1. [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)  
   **标签**：矩阵快速幂  
   **关键点**：线性递推的矩阵表示

2. [P1939 矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)  
   **标签**：递推优化  
   **技巧**：多维状态矩阵构造

3. [CF1182E Product Oriented Recurrence](https://codeforces.com/problemset/problem/1182/E)  
   **扩展**：复合式矩阵加速

---

6. **可视化代码片段（像素动画）**

```javascript
// 矩阵块绘制（伪代码）
class MatrixPixel {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.palette = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']; 
    }
    
    draw(mat, bits) {
        this.ctx.clearRect(0, 0, 256, 256);
        for(let i=0; i<4; ++i) {
            for(let j=0; j<4; ++j) {
                const val = mat[i][j];
                // 8-bit风格绘制
                this.ctx.fillStyle = this.palette[(val%4 +4)%4];
                this.ctx.fillRect(j*64, i*64, 60, 60);
                
                // 显示二进制位
                if(bits) 
                    drawBinary(val, j*64+8, i*64+8); 
            }
        }
    }
}

// 快速幂动画控制器
class FastPowAnim {
    constructor(matrix) {
        this.stack = [];
        while(n > 0) {
            this.stack.push(n%2);
            n = Math.floor(n/2);
        }
    }
    
    nextStep() {
        const bit = this.stack.pop();
        if(bit) {
            playSound('power_up'); // 播放位激活音效
            highlightMatrix(currentBit); 
        }
        applyMatrixSquare();
    }
}
```

---

7. **个人心得摘录**

> "本题的难点在于将队列操作转化为双指针模型。调试时发现初始方向概率容易搞反，通过构造n=3的手算样例验证了转移系数的正确性。" —— NobodyThere

> "矩阵维度的设计是关键，最初尝试3维矩阵无法包含ans的累计项，扩展为4维后立即得到正确结果。" —— DaiRuiChen007

---

8. **游戏化扩展设计**

**积分规则**：
- 成功完成一次矩阵乘法 +100分
- 快速幂步骤正确 +50/步
- 连击奖励：连续正确步骤获得1.5倍加成

**音效设计**：
- `power_up.wav`：二进制位为1时播放
- `matrix_multiply.wav`：矩阵相乘时播放芯片合成音
- `error_beep.wav`：计算结果超出模数时提示

**AI演示模式**：
```javascript
function autoPlay() {
    const solver = new FastPowSolver();
    while(!solver.done) {
        const step = solver.getOptimalStep(); // AI选择最优计算路径
        visualizer.draw(step.matrix);
        playSound(step.sound);
        delay(step.duration); 
    }
}
```

---
处理用时：100.54秒
# 题目信息

# [ARC186A] Underclued

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc186/tasks/arc186_a

各成分が $ 0,1 $ である $ N $ 次正方行列 $ A,B $ について、以下の条件を満たしているとき $ A $ と $ B $ は **似ている** と言います。

- 各行の総和が等しい。つまり、どの $ i=1,\dots,N $ についても $ A_{i,1}\ +\ \dots\ +\ A_{i,N}\ =\ B_{i,1}\ +\ \dots\ +\ B_{i,N} $
- 各列の総和が等しい。つまり、どの $ j=1,\dots,N $ についても $ A_{1,j}\ +\ \dots\ +\ A_{N,j}\ =\ B_{1,j}\ +\ \dots\ +\ B_{N,j} $

また、各成分が $ 0,1 $ である $ N $ 次正方行列 $ A $ と整数 $ i,j $ ($ 1\ \leq\ i,j\ \leq\ N $) について、$ A $ と似ているどの行列 $ B $ についても $ A_{i,j}\ =\ B_{i,j} $ が成り立つとき、$ A $ の $ i $ 行 $ j $ 列成分は **固定されている** と言います。

以下の $ Q $ 個のクエリに答えてください。

- $ i $ 番目のクエリ：各成分が $ 0,1 $ である $ N $ 次正方行列であって、固定されている成分がちょうど $ K_i $ 個であるようなものが存在するなら `Yes`、そうでないなら `No` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \le\ N\ \le\ 30 $
- $ 1\ \le\ Q\ \le\ N^2+1 $
- $ 0\ \le\ K_i\ \le\ N^2 $
- $ K_i\ \ne\ K_j\ (1\ \le\ i\ <\ j\ \le\ Q) $
- 入力はすべて整数

### Sample Explanation 1

$ 1 $ 番目のクエリ： 例えば、以下のような行列 $ X $ は、固定されている成分が $ 0 $ 個です。 ``` 1 0 0 0 1 0 0 0 1 ``` なぜなら、次のように列を循環シフトさせていったものはすべて $ X $ と似ており、どの成分も $ 0 $ にも $ 1 $ にもなりうるためです。 ``` 0 0 1 1 0 0 0 1 0 ``` ``` 0 1 0 0 0 1 1 0 0 ``` $ 2 $ 番目のクエリ： 例えば、以下のような行列 $ X $ は、固定されている成分が $ 9 $ 個です。 ``` 0 0 1 0 1 1 1 1 1 ``` なぜなら、似ている行列は $ X $ 以外に存在せず、すべての成分が固定されているためです。 $ 3 $ 番目のクエリ： 固定されている成分がちょうど $ 7 $ 個であるような行列は存在しません。

## 样例 #1

### 输入

```
3 3
0
9
7```

### 输出

```
Yes
Yes
No```

## 样例 #2

### 输入

```
29 6
186
681
18
108
123
321```

### 输出

```
No
Yes
No
Yes
No
Yes```

# AI分析结果



0. **题目翻译**

---

# [ARC186A] Underclued

## 题目描述

对于由 $0,1$ 构成的 $N$ 阶方阵 $A$ 和 $B$，若满足以下条件，则称它们**相似**：

- 每行元素和相等：对所有 $i=1,\dots,N$，$A_{i,1}+\dots+A_{i,N} = B_{i,1}+\dots+B_{i,N}$
- 每列元素和相等：对所有 $j=1,\dots,N$，$A_{1,j}+\dots+A_{N,j} = B_{1,j}+\dots+B_{N,j}$

若对于所有与 $A$ 相似的矩阵 $B$，都有 $A_{i,j}=B_{i,j}$，则称 $A$ 的 $(i,j)$ 位置是**固定的**。给定 $Q$ 个询问，每个询问给出整数 $K_i$，判断是否存在恰好有 $K_i$ 个固定位置的矩阵。

## 输入输出

输入样例 1：
```
3 3
0
9
7
```
输出样例 1：
```
Yes
Yes
No
```

---

1. **唯一算法分类**  
   **线性DP**

---

2. **综合分析与结论**

### 核心思路与算法要点
- **二分图建模**：将矩阵元素 $A_{i,j}$ 转换为二分图边定向（$A_{i,j}=1$ 时左部 $i$ 向右部 $j$ 连边，反之右部 $j$ 向左部 $i$ 连边）
- **环边判定**：固定位置对应不在任何环中的边，非固定位置对应环边
- **动态规划**：定义 $dp[i][j][k]$ 表示左部选 $i$ 个点、右部选 $j$ 个点时环边数为 $k$ 是否可行，通过枚举强连通分量进行转移

### 动态规划可视化设计
- **网格状态**：以左部点数 $i$ 为行，右部点数 $j$ 为列，环边数 $k$ 为第三维
- **更新高亮**：每次添加新强连通分量时，高亮新增的 $u×v$ 环边区域（如 $u=2, v=3$ 时，标红对应 6 个环边）
- **转移动画**：展示从 $(i-u, j-v)$ 到 $(i,j)$ 的箭头，动态叠加环边数

### 复古像素风格实现
- **8位调色板**：使用 16 色经典 FC 风格（深蓝背景、亮绿网格线、红黄状态块）
- **音效触发**：
  - 状态转移时播放 "blip" 音效（类似《吃豆人》吃豆音）
  - 找到可行解时播放《超级马里奥》金币音效
- **自动演示**：按强连通分量从小到大逐步填充网格，速度可调（50ms~2s/步）

---

3. **题解清单 (≥4星)**

### ① 解方橙（5星）
- **亮点**：通过构造法揭示矩形覆盖规律，结合动态规划处理多重矩形叠加
- **创新点**：将固定位置转化为行列约束的覆盖问题，给出明确的构造示例

### ② lfxxx（4星）
- **亮点**：简洁的 DP 实现，清晰展示状态转移核心逻辑
- **代码优势**：仅 30 行实现完整 DP 流程，适合快速理解算法骨架

### ③ Sky_Maths（4星）
- **亮点**：深入解析环边与固定位置的关系，提供严谨的图论证明
- **可视化友好**：明确将问题分解为强连通分量枚举，便于动画设计

---

4. **核心代码实现**

```cpp
// lfxxx 的 DP 实现核心片段
int f[50][50][1000]; // DP状态数组
int main() {
    cin >> n >> q;
    f[0][0][0] = 1;
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= n; j++)
            for (int k = 0; k <= n*n; k++)
                // 枚举新增的强连通分量 (u,v)
                for (int u = 0; u <= i; u++)
                    for (int v = 0; v <= j; v++)
                        if (u*v <= k && (u>=2 || v>=2))
                            f[i][j][k] |= f[i-u][j-v][k - u*v];
    // 查询时检查n² -k是否可达
}
```

---

5. **相似题目推荐**
1. [洛谷 P4381 岛屿](https://www.luogu.com.cn/problem/P4381) - 环基树DP
2. [CF1519E Off by One](https://codeforces.com/problemset/problem/1519/E) - 二分图环覆盖
3. [洛谷 P6773 命运](https://www.luogu.com.cn/problem/P6773) - 线性DP与位运算优化

---

6. **可视化代码片段（Canvas 动画）**

```javascript
// 伪代码：DP网格绘制
const palette = ["#000000","#1D2B53","#7E2553","#008751","#AB5236","#5F574F","#C2C3C7","#FFF1E8","#FF004D","#FFA300","#FFEC27","#00E436","#29ADFF","#83769C","#FF77A8","#FFCCAA"];

function drawDPGrid() {
    ctx.fillStyle = palette[1]; // 深蓝背景
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    // 绘制网格线
    ctx.strokeStyle = palette[6]; // 浅灰
    for(let i=0; i<=n; i++) {
        drawLine(i*cellW, 0, i*cellW, canvas.height);
        drawLine(0, i*cellH, canvas.width, i*cellH);
    }
    
    // 高亮当前转移
    ctx.fillStyle = palette[9]; // 橙色
    ctx.fillRect(u*cellW, v*cellH, cellW, cellH);
    
    // 播放音效
    if(kUpdated) playSound('blip.wav');
}
```

---

**注**：完整实现需结合具体参数与动画循环，此处展示核心可视化逻辑与风格设计。

---
处理用时：85.99秒
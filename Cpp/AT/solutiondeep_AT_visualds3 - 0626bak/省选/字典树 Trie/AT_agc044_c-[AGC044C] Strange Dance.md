# 题目信息

# [AGC044C] Strange Dance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc044/tasks/agc044_c

$ 3^N $ 人の人が輪になって踊っています。 輪の中の人がいる位置に、$ 0,1,\dots,\ 3^{N}-1 $ の番号を、適当な場所から始めて時計回りに付けます。はじめ、これらの位置それぞれに一人の人が立っています。

これから二種類の曲、サルサとルンバが流れ、人々はそれに合わせて踊ります。

- サルサが流れたら、位置 $ i $ にいる人は以下で述べるような位置 $ j $ に移動します。$ j $ は、$ i $ を $ 3 $ 進法で表記し、$ 1 $ という桁をそれぞれ $ 2 $ に、$ 2 $ という桁をそれぞれ $ 1 $ に置き換えて得られる数です (例えば、位置 $ 46 $ の人は位置 $ 65 $ に移動します)。
- ルンバが流れたら、位置 $ i $ にいる人は位置 $ i+1 $ に移動します。ここで、位置 $ 3^N $ は位置 $ 0 $ とみなします。

文字列 $ T=T_1T_2\cdots\ T_{|T|} $ が与えられます。これは、$ T_i= $`S` なら $ i $ 番目に流れる曲がサルサであり、$ T_i= $`R` ならルンバであることを表します。 はじめ位置 $ i $ に立っていた人が、すべての曲が流れたあとに位置 $ P_i $ に立っているとします。 列 $ P_0,P_1,\dots,\ P_{3^N-1} $ を求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 12 $
- $ 1\ \le\ |T|\ \le\ 200,000 $
- $ T $ は `S`、`R` からなる。

### Sample Explanation 1

最初の曲が流れる前に位置 $ i $ に立っていた人を人 $ i $ とします。 1. サルサが一度目に流れたあと、人 $ 0,\ 1,\ 2 $ はそれぞれ位置 $ 0,\ 2,\ 1 $ に立っています。 2. ルンバが流れたあと、人 $ 0,\ 1,\ 2 $ はそれぞれ位置 $ 1,\ 0,\ 2 $ に立っています。 3. サルサが二度目に流れたあと、人 $ 0,\ 1,\ 2 $ はそれぞれ位置 $ 2,\ 0,\ 1 $ に立っています。

## 样例 #1

### 输入

```
1

SRS```

### 输出

```
2 0 1```

## 样例 #2

### 输入

```
2

RRSRSSSSR```

### 输出

```
3 8 1 0 5 7 6 2 4```

## 样例 #3

### 输入

```
3

SRSRRSRRRSRRRR```

### 输出

```
23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10```

# AI分析结果



## 算法分类
**Trie树、懒标记、递归处理进位**

---

## 题解思路与算法要点

### 核心思路
1. **三进制Trie树**：将数字按三进制从**低位到高位**建立满三叉树，叶子节点存储初始位置。
2. **S操作处理**：交换每个节点的1/2子节点，通过懒标记延迟处理。
3. **R操作处理**：轮换节点的三个子节点（0→1→2→0），并递归处理进位（仅0子节点需要进位）。

### 解决难点
- **进位处理**：R操作需模拟三进制加法进位，通过递归处理0子节点实现。
- **时间复杂度优化**：S操作O(1)打标记，R操作O(n)递归处理，总复杂度O(|T|·n + 3ⁿ)。
- **空间压缩**：通过动态建树或预分配避免3ⁿ显式存储。

---

## 题解评分 (≥4星)

### 1. rui_er ⭐⭐⭐⭐⭐
- **亮点**：代码结构清晰，递归进位处理简洁，标记下放逻辑明确。
- **关键代码**：
  ```cpp
  void add(int u) { // R操作递归进位处理
    if(!son[u][0]) return;
    pushdown(u);
    swap(son[u][0], son[u][1]);
    swap(son[u][0], son[u][2]);
    add(son[u][0]);
  }
  ```

### 2. Arghariza ⭐⭐⭐⭐
- **亮点**：类比二进制全局加1，解释三进制递归进位机制。
- **心得**："DS好闪，拜谢DS" 体现对数据结构灵活性的赞叹。

### 3. GIFBMP ⭐⭐⭐⭐
- **亮点**：详细推导R操作子节点轮换过程，代码注释明确。
- **实现**：
  ```cpp
  void chg2(int x) { // 子节点轮换
    int tmp = ch[x][0];
    ch[x][0] = ch[x][2], ch[x][2] = ch[x][1], ch[x][1] = tmp;
  }
  ```

---

## 最优思路提炼

### 关键技巧
1. **低位优先建树**：匹配三进制加法进位方向。
2. **懒标记传递**：S操作交换1/2子节点时延迟到实际访问节点。
3. **递归进位处理**：R操作仅需递归0子节点，避免全树遍历。

---

## 同类题目推荐
1. **P6018 [Ynoi2010] Fusion tree**  
   （三叉Trie处理异或与加法）
2. **CF1553H XOR and Distance**  
   （二进制Trie动态维护异或最小值）
3. **ABC247E Max Min**  
   （位运算与区间约束结合）

---

## 可视化设计

### 动画方案
1. **Trie树结构**：  
   - **颜色标记**：当前操作节点红色，懒标记节点黄色。
   - **步进控制**：单步展示S/R操作对节点的影响。

2. **R操作递归**：  
   - 高亮当前处理的0子节点链，逐步轮换子节点并递归。

3. **复古像素风格**：  
   - **8位音效**：节点交换时播放"哔"声，递归深度增加时音调升高。
   - **Canvas网格**：每个节点显示为3×3像素块，子节点按位置排列。

### 交互功能
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **操作回放**：独立回放S/R操作对树结构的影响。

---

## 核心代码实现

### R操作递归处理（rui_er）
```cpp
void add(int u) {
  if(!son[u][0]) return;
  pushdown(u);
  // 轮换子节点：0→1→2→0
  int tmp = son[u][0];
  son[u][0] = son[u][2];
  son[u][2] = son[u][1];
  son[u][1] = tmp;
  add(son[u][0]); // 递归处理进位
}
```

### 懒标记下放
```cpp
void pushdown(int u) {
  if(!tag[u]) return;
  swap(son[u][1], son[u][2]);
  for(int i=0; i<3; ++i) tag[son[u][i]] ^= 1;
  tag[u] = 0;
}
```

---

通过将三进制运算转化为Trie树操作，本解法在O(n)时间复杂度内处理每次舞蹈，完美平衡效率与代码简洁性。

---
处理用时：160.66秒
# 题目信息

# [ABC280G] Do Use Hexagon Grid 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc280/tasks/abc280_g

以下のような、無限に広い六角形のグリッドがあります。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc280_g/992f7292cb6316e33ee0c40605e4a519c5d857df.png)

六角形のマスは $ 2 $ つの整数 $ i,j $ を用いて $ (i,j) $ と表されます。  
 マス $ (i,j) $ は以下の $ 6 $ つのマスと辺で隣接しています。

- $ (i-1,j-1) $
- $ (i-1,j) $
- $ (i,j-1) $
- $ (i,j+1) $
- $ (i+1,j) $
- $ (i+1,j+1) $
 
$ 2 $ つのマス $ X,Y $ の距離を、辺で隣接しているマスをたどってマス $ X $ からマス $ Y $ まで移動するときの、移動回数の最小値と定めます。  
 例えばマス $ (0,0) $ とマス $ (1,1) $ の距離は $ 1 $、マス $ (2,1) $ とマス $ (-1,-1) $ の距離は $ 3 $ です。

$ N $ 個のマス $ (X_1,Y_1),\ldots,(X_N,Y_N) $ が与えられます。  
 この $ N $ マスの中から $ 1 $ つ以上のマスを選ぶ方法のうち、選んだマスのうちどの $ 2 $ マスの距離も $ D $ 以下になるようなものは何通りありますか？  
 $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 300 $
- $ -10^9\leq\ X_i,Y_i\ \leq\ 10^9 $
- $ 1\leq\ D\ \leq\ 10^{10} $
- $ (X_i,Y_i) $ は相異なる
- 入力は全て整数である
 
### Sample Explanation 1

選ぶマスの集合として考えられるのは $ \{(0,0)\},\{(0,1)\},\{(1,0)\},\{(0,0),(0,1)\},\{(0,0),(1,0)\} $ の $ 5 $ 通りです。

## 样例 #1

### 输入

```
3 1

0 0

0 1

1 0```

### 输出

```
5```

## 样例 #2

### 输入

```
9 1

0 0

0 1

0 2

1 0

1 1

1 2

2 0

2 1

2 2```

### 输出

```
33```

## 样例 #3

### 输入

```
5 10000000000

314159265 358979323

846264338 -327950288

-419716939 937510582

-97494459 -230781640

628620899 862803482```

### 输出

```
31```

# AI分析结果



## 算法分类
动态规划（三维状态转移）

---

## 题解思路与核心难点

### 思路核心
1. **六边形距离转换**：将二维坐标转换为三维空间中的点 `(x, y, x-y)`，两点间距离为三个坐标差绝对值的最大值。
2. **动态规划状态设计**：定义 `f[i][x][y]` 表示以点 `i` 为当前处理的点，`x` 和 `y` 分别代表当前区域右限横坐标和下限纵坐标的约束条件，`z` 通过差值隐含维护。
3. **状态转移**：遍历已处理点，若新点与旧点满足距离约束，则更新三维限制条件，累加合法子集数目。

### 解决难点
- **三维约束合并**：通过动态规划维护立方体的三个维度限制，避免重复计算。
- **剪枝优化**：排序后按坐标差提前终止无效循环，将复杂度优化至 `O(n^3)`。

---

## 最优思路提炼

1. **坐标转换**：将六边形网格的距离问题转化为三维空间的切比雪夫距离。
2. **动态规划状态转移**：通过维护三维约束条件，逐步扩展合法区域。
3. **排序剪枝**：对点按坐标排序，减少无效状态转移。

---

## 关键代码实现

```cpp
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int maxn=305,mod=998244353;
ll n,d,f[maxn][maxn][maxn],ans;
pair<ll, ll> a[maxn];
int main(){
    cin>>n>>d;
    for(int i=1;i<=n;i++) cin>>a[i].first>>a[i].second;
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        f[i][i][i]=1;
        for(int x=1;x<i;x++){
            if(a[i].first -a[x].first >d) continue;
            for(int y=x;y<i;y++){
                if(a[i].second -a[y].second >d) continue;
                for(int z=x;z<i;z++){
                    if(!f[x][y][z] || (a[i].first -a[z].first - (a[i].second -a[z].second))>d) continue;
                    ans = (ans + f[x][y][z]) % mod;
                    int new_y = (a[i].second < a[y].second) ? i : y;
                    int new_z = (a[i].first -a[i].second < a[z].first -a[z].second) ? i : z;
                    f[x][new_y][new_z] = (f[x][new_y][new_z] + f[x][y][z]) % mod;
                }
            }
        }
    }
    cout << (ans + n) % mod;
    return 0;
}
```

---

## 可视化设计

### 动态规划状态转移动画
- **像素风格网格**：用不同颜色方块表示每个点，红色方块为当前处理点，绿色为合法区域边界。
- **立方体扩展**：每次添加新点时，用半透明蓝色方块扩展三维边界，显示约束条件的更新。
- **音效触发**：合法转移时播放上升音调，非法转移时播放低沉音效。

### 复古游戏化元素
- **8位计数器**：显示当前答案数值，采用LED像素字体。
- **自动演示模式**：按帧逐步展示每个点的处理过程，支持暂停/继续。

---

## 相似题目推荐
1. **洛谷 P3184**：二维平面内最近点对计数。
2. **洛谷 P3513**：三维空间内最大子立方体。
3. **洛谷 P4562**：动态规划维护多维状态。

---
处理用时：81.85秒
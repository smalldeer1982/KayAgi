# 题目信息

# [ABC361G] Go Territory

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_g

$ 2 $ 次元平面上に $ N $ 個の石が置かれています。$ i $ 番目の石は座標 $ (X_i,Y_i) $ にあります。石は全て第一象限(軸上含む)の格子点にあります。

石の置かれていない格子点 $ (x,y) $ であって、上下左右のいずれかに $ 1 $ 移動することを繰り返すことで、石の置かれている座標を通らずに $ (-1,-1) $ に到達することが**できない**ものの個数を求めてください。

より正確には、石の置かれていない格子点 $ (x,y) $ であって、以下の $ 4 $ 条件を全て満たすような整数の組の有限列 $ (x_0,y_0),\ldots,(x_k,y_k) $ が存在**しない**ものの個数を求めてください。

- $ (x_0,y_0)=(x,y) $
- $ (x_k,y_k)=(-1,-1) $
- 全ての $ 0\leq\ i\ <\ k $ で $ |x_i-x_{i+1}|+|y_i-y_{i+1}|=1 $
- どの $ 0\ \leq\ i\ \leq\ k $ でも、$ (x_i,y_i) $ に石はない

## 说明/提示

### 制約

- $ 0\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ X_i,Y_i\ \leq\ 2\times\ 10^5 $
- $ (X_i,Y_i) $ は相異なる
- 入力は全て整数

### Sample Explanation 1

$ (1,1) $ から $ (-1,-1) $ に到達することができません。 !\[\](https://img.atcoder.jp/abc361/77ce335c7ebd31af0860ce2aa43ae32a.png)

### Sample Explanation 2

石が $ 1 $ つも置かれていないこともあります。

### Sample Explanation 3

$ (6,1),(6,2),(6,3),(7,1),(7,2),(7,3) $ の $ 6 $ 個が該当します。 !\[\](https://img.atcoder.jp/abc361/95ffd845cfab71f0cd6b3c8122eb1ac9.png)

## 样例 #1

### 输入

```
5
1 0
0 1
2 3
1 2
2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
0```

### 输出

```
0```

## 样例 #3

### 输入

```
22
0 1
0 2
0 3
1 0
1 4
2 0
2 2
2 4
3 0
3 1
3 2
3 4
5 1
5 2
5 3
6 0
6 4
7 0
7 4
8 1
8 2
8 3```

### 输出

```
6```

# AI分析结果



### 算法分类
**并查集**（结合扫描线与双指针优化）

---

### 题解思路与核心分析

#### 核心思路
题目要求统计无法通过上下左右移动到达边界点 (-1,-1) 的非障碍点数量。关键点在于将问题转化为连通块问题：
1. **行分割**：将每行按障碍点分割为多个连续白块（区间）。
2. **块连通性**：通过并查集维护相邻行的块之间的连通性。
3. **边界处理**：标记与边界相连的块，统计无法连接边界的块的总点数。

#### 解决难点
1. **大坐标范围**：直接处理每个点不可行，需将问题转化为块级别操作。
2. **高效合并**：利用双指针技术快速判断相邻行块的相交关系，合并连通块。
3. **边界判定**：左右边界或顶底行的块直接与超级源点连接，代表可到达边界。

---

### 题解评分（≥4星）

1. **Rosabel（5星）**
   - **亮点**：清晰描述块分割与双指针合并逻辑，代码高效，时间复杂度严格证明。
   - **代码亮点**：通过排序分割行块，双指针合并实现线性复杂度。

2. **DrAlfred（4.5星）**
   - **亮点**：使用 `map` 预处理行块，结构清晰，超级源点设计巧妙。
   - **代码亮点**：显式处理边界块，双指针合并逻辑简洁。

3. **lingziyi2025（4星）**
   - **亮点**：代码简洁，块合并逻辑直观，适合快速理解。
   - **优化点**：缺少对边界块的显式处理说明。

---

### 最优思路提炼

1. **行分割与块表示**  
   每行按障碍点分割为连续区间，如 `(y, l, r)` 表示纵坐标为 `y` 的行中横坐标从 `l` 到 `r` 的连续白块。

2. **并查集维护连通性**  
   - 块之间的上下相邻关系通过双指针判断区间是否相交。
   - 合并相交的块，形成连通块。

3. **边界处理**  
   - 左右边界或顶底行的块直接连接到超级源点（代表可到达边界）。
   - 最终统计无法连接到源点的块的总点数。

---

### 可视化设计（复古像素风格）

1. **动画效果**  
   - **像素网格**：以网格表示平面，障碍点为黑色，白块用不同颜色表示。
   - **块合并动画**：当两个块合并时，颜色渐变为同一色，并播放“连接成功”音效。
   - **源点扩散**：超级源点以波浪动画向外扩散，标记可到达边界的块。

2. **交互设计**  
   - **步进控制**：允许用户单步执行块合并，观察双指针移动与合并过程。
   - **自动模式**：AI 自动运行，以贪吃蛇式路径展示块合并顺序。

3. **音效与风格**  
   - **音效**：块合并时播放 8-bit 风格“哔”声，边界块连接时播放上扬音调。
   - **颜色方案**：使用 FC 红白机经典色调（红、蓝、绿、黄），背景循环播放低比特率音乐。

---

### 核心代码实现（以 Rosabel 思路为例）

```cpp
// 行分割与块初始化
vector<array<int, 3>> segs;
for (auto &[x, ys] : mp) {
    if (ys.empty()) {
        segs.push_back({x, -inf, inf});
    } else {
        sort(ys.begin(), ys.end());
        // 分割行块
        segs.push_back({x, -inf, ys[0] - 1});
        for (int i = 0; i < ys.size() - 1; i++) {
            if (ys[i + 1] - ys[i] > 1) {
                segs.push_back({x, ys[i] + 1, ys[i + 1] - 1});
            }
        }
        segs.push_back({x, ys.back() + 1, inf});
    }
}

// 双指针合并相邻行块
for (int i = 0, j = 0; i < segs.size(); i++) {
    while (j < segs.size() && (segs[j][0] < segs[i][0] + 1 || segs[j][2] < segs[i][1])) j++;
    while (j < segs.size() && segs[j][0] == segs[i][0] + 1 && segs[j][1] <= segs[i][2]) {
        DSU.merge(i, j++);
    }
    j--;
}
```

---

### 同类型题目推荐

1. **洛谷 P1162 填涂颜色**  
   - 核心：判断闭合区域并填充，需优化大网格处理。

2. **洛谷 P1141 01迷宫**  
   - 核心：连通块预处理，应对多次查询。

3. **LeetCode 200. 岛屿数量**  
   - 核心：网格连通块计数，可拓展至大规模数据优化。

---
处理用时：74.77秒
# 题目信息

# [AGC069B] Pair Guessing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc069/tasks/agc069_b

$ N $ 個の、長さ $ N $ の $ 01 $ 文字列 $ S_1,\ldots,S_N $ が与えられます。$ S_i $ の $ j $ 文字目を $ S_{i,j} $ と表します。ここで、$ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在することが制約より保証されています。

高橋君と青木君が以下のようなゲームを行います。

1. 高橋君が $ 1\ \leq\ i,j\ \leq\ N,\ S_{i,j}=\ $`1` を満たす整数組 $ (i,j) $ を $ 1 $ つ選ぶ。
2. $ 0 $ 回以上 $ N $ 回以下、青木君が高橋君に質問を行う。各質問では青木君が $ 1\leq\ i',j'\ \leq\ N $ を満たす整数組 $ (i',j') $ を選び、「$ i=i' $ と $ j=j' $ のうち少なくとも一方が成り立つ」の真偽を高橋君から教えてもらう。
3. 青木君が $ (i,j) $ を予想する。予想が当たっていれば青木君の勝ち、そうでなければ負けとなる。
 
青木君は高橋君が選ぶ $ (i,j) $ の候補、すなわち $ S_1,\ldots,S_N $ を知った状態でゲームを行います。また、上記2では以前の質問に対する返事を聞いたうえで $ (i',\ j') $ を選ぶことができます。

青木君が適切な戦略を取った場合、高橋君の $ (i,j) $ の選び方や運によらず必ずゲームに勝てるかどうかを判定してください。

$ 1 $ つの入力につきテストケースは $ T $ 個あります。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 500 $
- $ 1 $ つの入力の中のテストケースすべてにわたる $ N^2 $ の総和は $ 500^2 $ 以下である
- $ S_i $ は長さ $ N $ の $ 01 $ 文字列
- $ S_{i,j}=\ $ `1` を満たす整数組 $ (i,j) $ が少なくとも一つ存在する
 
### Sample Explanation 1

$ 1 $ 番目のテストケースに対するゲームの一例を以下に示します。 1. 高橋君が $ S_{i,j}=\ $`1` を満たす $ (i,j) $ として $ (2,2) $ を選ぶ。 2. 青木君が $ 2 $ 回質問を行う。$ 1 $ 回目の質問では $ (i',j')=(1,1) $ として、高橋君から「$ i=1 $ と $ j=1 $ のうち少なくとも一方が成り立つ」が偽であると教えてもらう。$ 2 $ 回目の質問では $ (i',j')=(2,2) $ として、高橋君から「$ i=2 $ と $ j=2 $ の少なくとも一方が成り立つ」が真であると教えてもらう。 3. 青木君が $ (i,j)=(2,2) $ と予想する。この予想は当たっているため、青木君の勝ちである。 これはあくまでゲームの一例であり、青木君の戦略が適切とは限りません。しかし、青木君が適切な戦略を取った場合には必ず青木君がゲームに勝つため、$ 1 $ 番目のテストケースに対する出力は `Yes` になります。

## 样例 #1

### 输入

```
3

2

01

11

2

11

11

10

0101011110

1100100001

1101100000

0111101010

1000011001

1110101010

1110110100

1110000110

0000001011

1001111100```

### 输出

```
Yes

No

Yes```

# AI分析结果



**唯一算法分类**：二分图/并查集

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **问题转化**：将每个 `0` 点视为连接行与列的边，构建二分图模型
2. **连通块统计**：通过并查集统计行、列的连通块大小
3. **条件判断**：计算所有连通块的 `siz-1` 总和是否满足：
   - `n > 2` 时要求总和 ≥ `n-2`
   - `n = 2` 时特殊处理（需存在至少一个 `0`）

#### **算法流程**
1. **初始化并查集**：将 `1~n` 视为行，`n+1~2n` 视为列
2. **连接边**：对每个 `S[i][j] = 0` 的点，合并行 `i` 和列 `j+n`
3. **统计连通块**：计算每个连通块大小 `siz`，累加 `siz-1` 总和
4. **条件判断**：根据 `n` 的大小调整阈值

#### **解决难点**
- **二分图建模**：将行与列抽象为二分图节点，`0` 点作为边
- **连通块计算**：通过并查集快速统计连通性
- **阈值调整**：发现 `n > 2` 时允许少一次操作（可通过后续策略弥补）

---

### **题解评分 (≥4星)**

1. **complete_binary_tree 的题解**（⭐⭐⭐⭐⭐）  
   - 亮点：代码最简洁，直接处理 `n > 2` 的特殊条件  
   - 关键代码片段：
     ```cpp
     for(int i=1;i<=n;++i)for(int j=1;j<=n;++j){
         if(ch=='0'&&get(i)!=get(n+j))fa[get(i)]=get(n+j),++ans;
     }
     if(n>2 && ans>=n-2) puts("Yes");
     ```

2. **gdf_yhm 的题解**（⭐⭐⭐⭐）  
   - 亮点：详细分析阈值调整原因，处理 `n=2` 全 `1` 矩阵  
   - 心得引用：*“发现 WA 18 个点后修正为 `n-2` 条件”*

3. **Eraine 的题解**（⭐⭐⭐）  
   - 亮点：最早提出二分图模型，但未给出完整代码

---

### **最优思路与技巧提炼**

- **关键数据结构**：并查集快速合并行、列节点
- **条件优化**：`n > 2` 时允许 `sum(siz-1) ≥ n-2`
- **建模技巧**：将行列关系映射为二分图边，利用连通性简化问题

---

### **同类型题与算法套路**

1. **网格图连通性问题**：如[CF920E Connected Components](https://codeforces.com/problemset/problem/920/E)
2. **行列操作建模**：如[LC 2003. 每棵子树内缺失的最小基因值](https://leetcode.cn/problems/smallest-missing-genetic-value-in-subtree/)
3. **并查集求连通块**：如[洛谷 P3367 并查集模板](https://www.luogu.com.cn/problem/P3367)

---

### **可视化与算法演示**

#### **核心动画设计**
- **像素风格网格**：用 8-bit 网格显示 `0/1` 矩阵，红色高亮当前操作的 `0` 点
- **并查集合并动画**：动态显示行（蓝色）与列（绿色）的合并过程
- **音效提示**：合并成功时播放 "beep" 音效，条件满足时播放胜利音效

#### **交互功能**
- **步进控制**：按空格单步执行并查集合并
- **自动模式**：点击播放键自动演示合并流程
- **阈值显示**：实时更新 `sum(siz-1)` 与目标阈值

---

### **代码实现（核心逻辑）**

```cpp
int main() {
    int T, n;
    cin >> T;
    while (T--) {
        cin >> n;
        vector<int> parent(2 * n + 1);
        iota(parent.begin(), parent.end(), 0);
        function<int(int)> find = [&](int x) {
            return parent[x] == x ? x : parent[x] = find(parent[x]);
        };

        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            string s;
            cin >> s;
            for (int j = 1; j <= n; ++j) {
                if (s[j-1] == '0') {
                    int a = find(i), b = find(j + n);
                    if (a != b) {
                        parent[a] = b;
                        ans++;
                    }
                }
            }
        }

        if (n == 2) {
            cout << (ans >= 1 ? "Yes\n" : "No\n");
        } else {
            cout << (ans >= n - 2 ? "Yes\n" : "No\n");
        }
    }
}
```

---

### **个人心得摘录**

- **gdf_yhm**：*“WA 18 个点后发现 `n>2` 时的特殊阈值，修正后 AC”*
- **Eraine**：*“原条件只是充分条件，需结合实际操作分析”*

---

### **推荐相似题目**

1. [CF1027D Mouse Hunt](https://codeforces.com/problemset/problem/1027/D)  
   （并查集找环）

2. [洛谷 P3387 缩点](https://www.luogu.com.cn/problem/P3387)  
   （连通分量应用）

3. [AGC032B Balanced Neighbors](https://atcoder.jp/contests/agc032/tasks/agc032_b)  
   （构造性图论问题）

---
处理用时：81.39秒
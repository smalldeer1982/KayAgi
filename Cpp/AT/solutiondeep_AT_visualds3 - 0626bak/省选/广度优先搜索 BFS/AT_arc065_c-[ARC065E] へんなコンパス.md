# 题目信息

# [ARC065E] へんなコンパス

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc065/tasks/arc065_c

$ xy $ 平面上に $ N $ 個の穴があります。$ i $ 番目の穴の位置は $ (x_i,y_i) $ です。

$ i $ 番目の穴と $ j $ 番目の穴のマンハッタン距離を $ d(i,j)(=|x_i-x_j|+|y_i-y_j|) $ と表します。

あなたはマンハッタンコンパスを持っています。 このコンパスは、常に $ 2 $ 個の穴を指します。 コンパスが $ p,\ q $ 番目の穴を指している状態と、$ q,\ p $ 番目の穴を指している状態は区別しません。

また、$ d(p,q)=d(p,r) $ で、$ p $ 番目の穴と $ q $ 番目の穴を指しているとき、$ p $ 番目の穴と $ r $ 番目の穴を指すよう動かすことができます。

はじめ、コンパスは $ a $ 番目の穴と $ b $ 番目の穴を指しています。 コンパスが指すことのできる穴の組の数を求めてください。

## 说明/提示

### 制約

- $ 2≦N≦10^5 $
- $ 1≦x_i,\ y_i≦10^9 $
- $ 1≦a\ <\ b≦N $
- $ i\ ≠\ j $ のとき $ (x_i,\ y_i)\ ≠\ (x_j,\ y_j) $
- $ x_i,\ y_i $ は整数である

### Sample Explanation 1

はじめ、コンパスは 穴 $ 1,\ 2 $ を指しています。 $ d(1,2)\ =\ d(1,3) $ なので、穴 $ 1,\ 3 $を指すことができます。 $ d(1,3)\ =\ d(3,4) $ なので、穴 $ 3,\ 4 $を指すことができます。 $ d(1,2)\ =\ d(2,5) $ なので、穴 $ 2,\ 5 $を指すことができます。 他の穴の組でコンパスが指せるものはないため、答えは $ 4 $ となります。

## 样例 #1

### 输入

```
5 1 2

1 1

4 3

6 1

5 5

4 8```

### 输出

```
4```

## 样例 #2

### 输入

```
6 2 3

1 3

5 3

3 5

8 4

4 7

2 5```

### 输出

```
4```

## 样例 #3

### 输入

```
8 1 2

1 5

4 3

8 2

4 7

8 8

3 3

6 6

4 8```

### 输出

```
7```

# AI分析结果



## 【ARC065E】へんなコンパス 题解分析

### 算法分类
**BFS**

---

### 思路与难点分析

#### **核心思路**
1. **曼哈顿距离转切比雪夫距离**  
   将坐标 $(x, y)$ 转换为 $(x+y, x-y)$，曼哈顿距离转化为切比雪夫距离（$\max(|x_1-x_2|, |y_1-y_2|)$），使得合法点对位于正方形的四条边上。
2. **BFS扩展连通块**  
   初始状态为点对 $(a, b)$，通过 BFS 遍历所有可达点。每次从队列取出一个点，查找其四个方向上的合法点（满足曼哈顿距离等于初始值 $D$），并将这些点加入队列。
3. **数据结构优化查询**  
   使用 `set` 或 `map` 维护每个坐标轴上的点集合，利用二分快速定位合法区间，遍历后删除已访问点避免重复处理。

#### **解决难点**
- **高效查找合法点**：通过坐标转换，将斜正方形转为正正方形，每条边对应固定 $x$ 或 $y$ 的范围，用二分查找优化。
- **避免重复计算**：在 BFS 过程中，每访问一个点立即从集合中删除，确保每个点只被处理一次，时间复杂度 $O(n \log n)$。
- **去重统计**：正方形的四个角可能在两条边上被重复统计，需特殊处理。

---

### 最优题解评分（≥4星）

1. **noone___ 题解（★★★★☆）**  
   - **亮点**：利用并查集维护连通性，代码简洁，通过两次排序和二分快速统计合法区间。
   - **代码可读性**：结构清晰，变量命名明确，但并查集合并逻辑需仔细理解。
   - **优化点**：合并区间时通过前缀和优化重复计算。

2. **Krimson 题解（★★★★☆）**  
   - **亮点**：动态开点线段树与 `set` 结合，严格处理四个方向，避免重复统计。
   - **代码可读性**：实现较复杂，但注释和变量名清晰，适合深入学习数据结构应用。

3. **dengchengyu 题解（★★★★☆）**  
   - **亮点**：直接通过 BFS + `set` 删除已访问点，逻辑直观，适合快速理解核心思路。
   - **优化点**：使用 `map` 维护坐标轴，减少离散化步骤。

---

### 关键代码实现（以 BFS 为核心）

```cpp
// 坐标转换与初始化
for (int i = 1; i <= n; i++) {
    x[i] = original_x + original_y;
    y[i] = original_x - original_y;
    col[x[i]].insert({y[i], i});
    row[y[i]].insert({x[i], i});
}

// BFS 核心逻辑
queue<int> q;
q.push(a); q.push(b);
vis[a] = vis[b] = true;
while (!q.empty()) {
    int u = q.front(); q.pop();
    // 处理四个方向：上下左右的合法点
    for (auto &dir : {左, 右, 上, 下}) {
        auto &s = (dir 是横向) ? col[x[u] ± D] : row[y[u] ± D];
        auto it_low = s.lower_bound(y[u] - D);
        auto it_high = s.upper_bound(y[u] + D);
        for (auto it = it_low; it != it_high; it = s.erase(it)) {
            if (!vis[it->second]) {
                vis[it->second] = true;
                q.push(it->second);
                ans += num[it->second]; // 累加度数
            }
        }
    }
}
```

---

### 可视化与游戏化设计

#### **BFS 动画演示**
1. **网格绘制**：在 Canvas 中绘制转换后的坐标平面，节点按 $(x', y')$ 排列。
2. **颜色标记**：
   - **当前节点**：红色高亮。
   - **待访问队列**：黄色边框。
   - **已访问节点**：灰色填充。
3. **步进控制**：用户可暂停/继续，观察队列如何从初始点 $(a, b)$ 向外扩散。
4. **音效触发**：
   - **新节点加入**：短促“滴”声。
   - **搜索完成**：8-bit 胜利音效。

#### **复古像素风格**
- **调色板**：16 色 FC 风格，使用深蓝（背景）、红（当前节点）、绿（合法边）。
- **节点绘制**：8x8 像素方块，带闪烁边框表示活跃状态。
- **自动演示**：AI 按 BFS 顺序自动播放，速度可调（1x/2x/4x）。

---

### 同类型题目推荐
1. **P1141 01迷宫**：BFS 统计连通块大小。
2. **P1162 填涂颜色**：BFS 处理闭合区域。
3. **P2967 交通信号**：曼哈顿距离与图搜索结合。

---

### 总结
本题核心在于坐标转换与高效 BFS 遍历，通过切比雪夫距离简化几何条件，结合数据结构优化查询。代码实现需注意去重与连通性维护，适合作为 BFS 与几何结合的典型例题。

---
处理用时：73.91秒
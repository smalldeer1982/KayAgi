# 题目信息

# [AGC035D] Add and Remove

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_d

非負整数のひとつ書かれたカードが $ N $ 枚積まれた山があります。上から $ i $ 番目のカードに書かれた整数は $ A_i $ です。

すぬけ君は、以下の操作をカードが $ 2 $ 枚になるまで繰り返します。

- 連続して積まれている $ 3 $ 枚のカードを選ぶ。
- $ 3 $ 枚のうち真ん中のカードを食べる。
- あとの $ 2 $ 枚のカードに書かれている整数を、その整数に食べたカードに書かれていた整数を足してできる整数に書き換える。
- 食べなかった $ 2 $ 枚のカードを、順序を保ったまま山のもとの位置に戻す。

最終的に残る $ 2 $ 枚のカードに書かれた整数の和の最小値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 18 $
- $ 0\ \leq\ A_i\ \leq\ 10^9\ (1\leq\ i\leq\ N) $
- 入力はすべて整数である

### Sample Explanation 1

以下の操作を行うことで、最終的に残る $ 2 $ 枚のカードに書かれた整数の和を最小にできます。 - 最初、カードに書かれた整数は順に $ 3,1,4,2 $ である。 - $ 1,2,3 $ 番目のカードを選ぶ。$ 1 $ の書かれた $ 2 $ 枚目のカードを食べ、残ったカードに書かれた整数に $ 1 $ を足し、山のもとの位置に戻す。カードに書かれた整数は順に $ 4,5,2 $ となる。 - $ 1,2,3 $ 番目のカードを選ぶ。$ 5 $ の書かれた $ 2 $ 枚目のカードを食べ、残ったカードに書かれた整数に $ 5 $ を足し、山のもとの位置に戻す。カードに書かれた整数は順に $ 9,7 $ となる。 - 最後に残った $ 2 $ 枚のカードに書かれた整数の和は $ 16 $ になる。

## 样例 #1

### 输入

```
4

3 1 4 2```

### 输出

```
16```

## 样例 #2

### 输入

```
6

5 2 4 1 6 9```

### 输出

```
51```

## 样例 #3

### 输入

```
10

3 1 4 1 5 9 2 6 5 3```

### 输出

```
115```

# AI分析结果



# 算法分类：DFS

## 题解思路与核心难点
题目要求通过不断删除中间元素并累加其值到两侧，最终使剩余两数之和最小。核心难点在于如何高效计算每个元素的贡献次数。各题解通过以下思路解决：

1. **倒序贡献分析**：从只剩首尾两个元素的状态倒推，每个中间元素的贡献次数等于其左右两侧元素贡献次数之和。
2. **DFS+记忆化搜索**：递归分解区间，维护左右端点的贡献系数，通过记忆化优化重复状态计算。
3. **状态转移方程**：`dp(l,r,xl,xr) = min(左区间贡献 + 右区间贡献 + 当前元素贡献)`，其中贡献系数动态合并。

## 题解评分（≥4星）

### 1. StudyingFather（5星）
- **亮点**：代码极简，直接递归实现动态规划思路，完美体现DFS分解子问题的核心。
- **代码片段**：
```cpp
long long dfs(int l,int r,int xl,int xr) {
 if(r-l<=1)return 0;
 long long ans=1e18;
 for(int i=l+1;i<=r-1;i++)
  ans=min(ans,dfs(l,i,xl,xl+xr)+dfs(i,r,xl+xr,xr)+a[i]*(xl+xr));
 return ans;
}
```

### 2. 小粉兔（4星）
- **亮点**：详细推导状态转移方程，明确系数合并的数学原理，复杂度分析清晰。

### 3. xht（4星）
- **亮点**：明确将贡献系数建模为状态参数，提供严谨的DP状态定义和转移说明。

## 最优思路提炼
**倒序贡献系数法**：将最终结果视为每个元素乘以其贡献系数之和。通过递归分解区间，动态维护左右端点的系数，每次合并时中间元素的系数为左右系数之和，极大简化了贡献计算。

## 同类型题推荐
1. P1880 [NOI1995] 石子合并（区间DP）
2. P1775 石子合并（弱化版）（区间分解）
3. P1063 [NOIP2006 提高组] 能量项链（环形区间DP）

## 可视化设计
### 算法演示（DFS递归分解）
1. **节点表示**：将序列元素显示为像素方块，初始颜色统一。
2. **递归过程**：
   - 选择中间元素时高亮显示，播放“选择音效”。
   - 分裂为左右子区间时，左右方块颜色渐变（如左蓝右红）。
   - 显示当前区间的贡献系数（如`xl=2, xr=3`）。
3. **贡献跟踪**：右侧面板实时显示每个元素的累计贡献系数。
4. **复古风格**：8-bit音效（选择、分裂、完成），背景芯片音乐循环。

### 交互功能
- **步进控制**：按空格暂停/继续，方向键单步前进/回退。
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **自动演示**：AI自动选择最优中间点，绿色高亮推荐路径。

## 核心代码实现
```cpp
#include <iostream>
using namespace std;
long long a[20];

long long dfs(int l, int r, int xl, int xr) {
    if (r - l <= 1) return 0;
    long long ans = 1e18;
    for (int i = l + 1; i < r; ++i) {
        long long left = dfs(l, i, xl, xl + xr);
        long long right = dfs(i, r, xl + xr, xr);
        ans = min(ans, left + right + a[i] * (xl + xr));
    }
    return ans;
}

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    cout << a[1] + a[n] + dfs(1, n, 1, 1);
    return 0;
}
```

---
处理用时：65.84秒
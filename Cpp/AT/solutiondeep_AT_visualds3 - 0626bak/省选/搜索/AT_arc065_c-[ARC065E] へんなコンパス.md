# 题目信息

# [ARC065E] へんなコンパス

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc065/tasks/arc065_c

$ xy $ 平面上に $ N $ 個の穴があります。$ i $ 番目の穴の位置は $ (x_i,y_i) $ です。

$ i $ 番目の穴と $ j $ 番目の穴のマンハッタン距離を $ d(i,j)(=|x_i-x_j|+|y_i-y_j|) $ と表します。

あなたはマンハッタンコンパスを持っています。 このコンパスは、常に $ 2 $ 個の穴を指します。 コンパスが $ p,\ q $ 番目の穴を指している状態と、$ q,\ p $ 番目の穴を指している状態は区別しません。

また、$ d(p,q)=d(p,r) $ で、$ p $ 番目の穴と $ q $ 番目の穴を指しているとき、$ p $ 番目の穴と $ r $ 番目の穴を指すよう動かすことができます。

はじめ、コンパスは $ a $ 番目の穴と $ b $ 番目の穴を指しています。 コンパスが指すことのできる穴の組の数を求めてください。

## 说明/提示

### 制約

- $ 2≦N≦10^5 $
- $ 1≦x_i,\ y_i≦10^9 $
- $ 1≦a\ <\ b≦N $
- $ i\ ≠\ j $ のとき $ (x_i,\ y_i)\ ≠\ (x_j,\ y_j) $
- $ x_i,\ y_i $ は整数である

### Sample Explanation 1

はじめ、コンパスは 穴 $ 1,\ 2 $ を指しています。 $ d(1,2)\ =\ d(1,3) $ なので、穴 $ 1,\ 3 $を指すことができます。 $ d(1,3)\ =\ d(3,4) $ なので、穴 $ 3,\ 4 $を指すことができます。 $ d(1,2)\ =\ d(2,5) $ なので、穴 $ 2,\ 5 $を指すことができます。 他の穴の組でコンパスが指せるものはないため、答えは $ 4 $ となります。

## 样例 #1

### 输入

```
5 1 2

1 1

4 3

6 1

5 5

4 8```

### 输出

```
4```

## 样例 #2

### 输入

```
6 2 3

1 3

5 3

3 5

8 4

4 7

2 5```

### 输出

```
4```

## 样例 #3

### 输入

```
8 1 2

1 5

4 3

8 2

4 7

8 8

3 3

6 6

4 8```

### 输出

```
7```

# AI分析结果



## 算法分类
**BFS**

---

## 题解思路与核心难点

### **核心思路**
1. **曼哈顿转切比雪夫距离**  
   将点 $(x,y)$ 转换为 $(x+y, x-y)$，使曼哈顿距离问题转化为切比雪夫距离下的正方形边界判定。
2. **BFS 扩展连通块**  
   初始点对 $(a,b)$ 的曼哈顿距离 $d$ 作为基准，通过 BFS 扩展所有可达点。对于每个点，检查其切比雪夫坐标下四条边上的点（对应原坐标斜正方形边界），用 `set` 维护未访问点，动态删除已访问点避免重复遍历。
3. **统计合法点对**  
   统计所有连通点对的度数（满足距离 $d$ 的相邻点数），最终答案为度数总和除以 2（消除无序对重复计数）。

### **解决难点**
- **高效查找邻接点**：通过离散化坐标后二分查找，或利用 `set` 的 `lower_bound` 快速定位边界点区间。
- **避免重复统计**：用 `visited` 数组标记已访问点，并在 `set` 中实时删除已处理点，保证每个点仅入队一次。
- **边角去重**：正方形四个角的坐标可能在两条边的交界处被重复统计，需特判减掉重复计数。

---

## 题解评分（≥4星）

### **1. Krimson（4.5星）**
- **亮点**：详细解释 BFS 过程，使用 `set` 动态维护点集，处理重复统计逻辑清晰。
- **代码**：通过四条边的二分查找实现邻接点扩展，用 `set.erase` 保证线性复杂度。
- **关键代码**：
  ```cpp
  set<pll> &s = f[0][now];
  for (auto it = s.lower_bound(...); it != s.end() && ...; it = s.erase(it))
    q.push(it->second);
  ```

### **2. dengchengyu（4星）**
- **亮点**：直接处理曼哈顿距离，利用 `set` 维护斜线点，代码简洁。
- **关键思路**：在斜线上二分查找邻接点，通过 `erase` 保证每个点只被处理一次。

### **3. noone___（4星）**
- **亮点**：结合并查集与排序二分，预处理度数后统计连通块总度数。
- **代码片段**：
  ```cpp
  for (rei i=1;i<=n;++i) if(get_fa(i)==get_fa(a)) ans+=cnt[i];
  ```

---

## 最优思路提炼

1. **坐标转换降维**  
   曼哈顿转切比雪夫后，正方形的边对齐坐标轴，极大简化邻接点判定。
2. **BFS 动态维护未访问点**  
   用 `set` 按坐标轴离散化存储点，扩展时动态删除已访问点，保证线性时间复杂度。
3. **度数统计优化**  
   预处理每个点的邻接点数（对应边上的点数量），最终只需累加连通块内度数。

---

## 同类型题推荐

1. **[ABC190E] Magical Ornament**  
   BFS + 状态压缩动态规划，处理多源最短路径后的排列组合。
2. **[P5096] [USACO18OPEN]Cave Painting**  
   曼哈顿距离与连通块扩展的结合问题。
3. **[P3967] [TJOI2014] 匹配**  
   图论中边权与距离约束的匹配问题，需高效邻接点搜索。

---

## 可视化设计

### **动画演示**
- **坐标转换展示**：将原坐标点旋转 45 度，用不同颜色区分曼哈顿与切比雪夫坐标系。
- **BFS 队列扩展**：  
  - **当前节点**：高亮为红色，显示其切比雪夫坐标下的四条边。
  - **待访问点**：蓝色方块，位于四条边的合法区间内。
  - **已访问点**：灰色方块，从 `set` 中移除。
- **音效与提示**：  
  - **新节点入队**：播放“哔”声。
  - **边角去重**：闪烁黄色提示重复点。

### **复古像素风格**
- **Canvas 绘制**：8-bit 风格网格，节点用 16x16 像素方块表示。
- **自动演示模式**：按 BFS 顺序自动扩展，速度可调。
- **代码片段**（JS）：
  ```javascript
  function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 16, y * 16, 14, 14); // 留1像素边框
  }
  ```

---

## 关键代码实现

### **BFS 核心逻辑（Krimson 题解）**
```cpp
queue<int> q;
q.push(a), q.push(b);
while (!q.empty()) {
    int u = q.front(); q.pop();
    // 处理四条边上的点
    for (int dx : {-dis, +dis}) {
        auto &s = f_x[u_x + dx]; // x 坐标对应 set
        auto it = s.lower_bound({u_y - dis, 0});
        while (it != s.end() && it->y <= u_y + dis) {
            q.push(it->id);
            s.erase(it++);
        }
    }
    // 同理处理 y 轴方向
}
```

---

## 个人心得摘录

> **Krimson 的调试经验**：  
> “初始代码未处理正方形四个角的重复统计，导致答案偏大。通过特判四个顶点是否被多边重复统计，最终修正答案。”

> **dengchengyu 的顿悟**：  
> “意识到 `set.erase` 可以保证每个点只被遍历一次，从而将复杂度从 $O(n^2)$ 优化到 $O(n \log n)$。”

---

通过以上分析与实现，可系统掌握 BFS 在曼哈顿距离扩展问题中的应用，并借助坐标转换与动态维护数据结构高效解题。

---
处理用时：71.71秒
# 题目信息

# [ARC156D] Xor Sum 5

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc156/tasks/arc156_d

長さ $ N $ の非負整数列 $ A=(A_1,A_2,\dots,A_N) $ 、および正整数 $ K $ が与えられます。

$ 1\ \leq\ X_i\ \leq\ N\ (1\leq\ i\ \leq\ K) $ を満たす長さ $ K $ の正整数列 $ X=(X_1,X_2,\dots,X_K) $ は $ N^K $ 通り考えられますが、それらすべてに対する $ \displaystyle\ \sum_{i=1}^{K}\ A_{X_i} $ のビット単位 $ \mathrm{XOR} $ を求めてください。

   ビット単位 $ \mathrm{XOR} $ 演算とは  非負整数 $ A,\ B $ のビット単位 $ \mathrm{XOR} $ 、$ A\ \oplus\ B $ は、以下のように定義されます。

- $ A\ \oplus\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \oplus\ 101\ =\ 110 $)。  
 一般に $ k $ 個の非負整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 $ \mathrm{XOR} $ は $ (\dots\ ((p_1\ \oplus\ p_2)\ \oplus\ p_3)\ \oplus\ \dots\ \oplus\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ の順番によらないことが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ K\ \leq\ 10^{12} $
- $ 0\ \leq\ A_i\ \leq\ 1000 $
- 与えられる入力はすべて整数
 
### Sample Explanation 1

$ X $ として考えられるのは $ (X_1,X_2)=(1,1),(1,2),(2,1),(2,2) $ の $ 4 $ 通りであり、それぞれに対する $ A_{X_1}+A_{X_2} $ は $ 20,40,40,60 $ です。よって答えは $ 20\ \oplus\ 40\ \oplus\ 40\ \oplus\ 60=40 $ となります。

## 样例 #1

### 输入

```
2 2

10 30```

### 输出

```
40```

## 样例 #2

### 输入

```
4 10

0 0 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
11 998244353

314 159 265 358 979 323 846 264 338 327 950```

### 输出

```
236500026047```

# AI分析结果



**唯一算法分类**: 数位动态规划（数位DP）

---

### **题解思路与解决难点**

1. **核心思路**  
   - **异或抵消**：由于相同的数异或两次抵消，只需统计出现次数为奇数的和。  
   - **组合数奇偶性**：利用Lucas定理，发现组合数为奇数当且仅当次数构成K的二进制划分。  
   - **数位分解**：将K二进制分解，逐位动态规划维护进位状态，统计每位贡献。

2. **算法要点**  
   - **状态定义**：`f[i][j]`表示处理到第`i`位时，进位值为`j`的方案异或和。  
   - **转移方式**：  
     - 若当前位为0，直接右移进位：`f[i+1][j/2]`。  
     - 若当前位为1，枚举所有可能数`A_p`，更新进位：`f[i+1][(j+A_p)/2]`。  
   - **贡献统计**：每位处理完后，根据奇偶性和后续方案数判断该位是否贡献答案。

3. **解决难点**  
   - **高效处理大K**：通过二进制分解将指数级规模转化为对数级步骤。  
   - **进位维护**：动态规划中维护进位值的状态，避免重复计算。  
   - **异或叠加**：正确统计每位可能的奇数次出现和。

---

### **最优思路提炼**

1. **数位DP框架**  
   - 逐位处理K的二进制位，维护进位状态。  
   - 对每个二进制位，枚举所有可能的数更新状态。  

2. **奇偶性优化**  
   - 当N为偶数时，非最高位的贡献需额外判断奇偶性。  
   - 利用位运算快速判断进位奇偶性。  

3. **状态压缩**  
   - 进位值的上限为`2 * max(A)`，通过bitset优化状态维护。  

---

### **题解评分（≥4星）**

1. **Sol1（5星）**  
   - 思路清晰，利用回文序列抵消非回文贡献，递归处理奇偶。  
   - 代码简洁，记忆化搜索实现高效。  

2. **mod998244353（5星）**  
   - 数位DP标准实现，状态定义明确，转移逻辑清晰。  
   - 结合组合数奇偶性理论，时间复杂度最优。  

3. **DaiRuiChen007（4星）**  
   - 简洁的bitset优化实现，适合快速理解核心逻辑。  
   - 代码短小精悍，适合竞赛场景。  

---

### **核心代码实现**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, a[1005];
ll k, dp[77][1005];
bool vis[77][1005];

long long Dfs(int dep, int pls) {
    if (vis[dep][pls]) return dp[dep][pls];
    if ((k >> dep) == 1) { // 递归边界
        for (int i = 1; i <= n; i++) dp[dep][pls] ^= (a[i] + pls);
        vis[dep][pls] = 1;
        return dp[dep][pls];
    }
    vis[dep][pls] = 1;
    if (!((k >> dep) & 1)) { // 当前位为0
        return dp[dep][pls] = (Dfs(dep + 1, pls >> 1) << 1) | ((pls & 1) && (n & 1));
    } else { // 当前位为1，枚举所有数
        for (int i = 1; i <= n; i++) {
            int new_pls = (pls + a[i]) >> 1;
            ll val = Dfs(dep + 1, new_pls) << 1;
            if ((pls + a[i]) & 1 && (n & 1)) val ^= 1;
            dp[dep][pls] ^= val;
        }
        return dp[dep][pls];
    }
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    cout << Dfs(0, 0) << endl;
}
```

---

### **同类型题与算法套路**

- **相似题目**:  
  - [CF1770E] 二进制位贡献统计  
  - [ABC281G] 大数异或和  
  - [洛谷P4127] 数位DP与异或性质  

---

### **可视化与算法演示**

**动画设计**:  
1. **数位处理演示**：  
   - 以二进制树形式逐层展开K的二进制位（如第0位、第1位...）。  
   - 当前处理位高亮（红色边框），进位值显示在节点旁。  

2. **状态转移动画**:  
   - 点击某一位时，展示该位的所有可能转移（如选择不同A_i）。  
   - 用箭头表示转移路径，颜色区分奇偶进位（蓝色偶，橙色奇）。  

3. **贡献统计**:  
   - 每位处理完后，右侧显示该位是否贡献答案（绿色勾/红叉）。  

**复古像素风格**:  
- **8位音效**: 每位处理时播放“滴”声，贡献确认时播放“噔”声。  
- **Canvas绘制**: 用16x16像素块表示二进制位，进位值以二进制数显示。  

---

### **个人心得摘录**

> "异或抵消性质是本题突破口，回文序列的观察让问题规模指数级缩小。数位DP的核心在于如何将大问题分解为独立位处理，而进位状态的维护是优雅解决此问题的关键。" —— Sol1题解作者

---

**推荐题目**:  
1. [洛谷P2114] 位运算与动态规划  
2. [洛谷P2657] 数位DP基础  
3. [ABC269G] 二进制拆分与贡献统计

---
处理用时：84.79秒
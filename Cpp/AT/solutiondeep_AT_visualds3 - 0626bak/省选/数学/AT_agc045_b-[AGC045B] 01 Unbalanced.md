# 题目信息

# [AGC045B] 01 Unbalanced

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc045/tasks/agc045_b

文字列 $ S $ が与えられます． $ S $ の各文字は，`0`,`1`,`?` のいずれかです．

$ S $ に含まれる全ての `?` を `0` か `1` に変えて（`?` ごとに変換後の文字を選択できます），文字列 $ S' $ を作ることを考えます． ここで，$ S' $ のアンバランス度を，次のように定義します．

- $ S' $ のアンバランス度 $ =\ \max\ \{\ S' $ の $ l $ 文字目から $ r $ 文字目までに含まれる `0` の個数と `1` の個数の差の絶対値 $ :\ 1\ \leq\ l\ \leq\ r\ \leq\ |S|\} $

$ S' $ のアンバランス度としてありうる最小の値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 10^6 $
- $ S $ の各文字は `0`,`1`,`?` のいずれかである．

### Sample Explanation 1

$ S'= $`010` とすれば，アンバランス度は $ 1 $ になり，これが最小です．

## 样例 #1

### 输入

```
0??```

### 输出

```
1```

## 样例 #2

### 输入

```
0??0```

### 输出

```
2```

## 样例 #3

### 输入

```
??00????0??0????0?0??00??1???11?1?1???1?11?111???1```

### 输出

```
4```

# AI分析结果



## 唯一算法分类
组合数学

## 综合分析与结论
**核心思路**：将问题转化为前缀和极差的最小化问题，通过贪心策略预处理后缀极值信息，枚举两种可能的上界候选值求得最优解。

**关键公式推导**：
- 将字符0视为-1，1视为1，构造前缀和数组S
- 不平衡度等价于$\max(S_i) - \min(S_i)$的极差
- 预处理后缀最大前缀和数组sum[i]，表示从位置i开始的最大可能前缀和

**解决难点**：
1. **极差的动态维护**：通过预处理后缀信息sum[i]，在遍历时快速判断能否将?替换为1
2. **贪心策略证明**：当上界增加2时，最多改变一个位置的替换选择，保证只需检查两个候选值

**可视化设计**：
1. 动态绘制前缀和折线图，初始状态所有?设为0（红色线段）
2. 遍历每个字符时，若满足sum[i+1]+当前值≤limit，则将该点替换为1（绿色高亮）
3. 实时显示当前前缀和极差（最大值-最小值），用不同颜色标记极值点
4. 步进播放时可调节速度，观察每个替换决策对极差的影响

## 题解清单 (≥4星)
1. **Tokai__Teio（5星）**
   - 亮点：清晰的预处理逻辑与极差候选值推导，代码可读性强
   - 核心代码片段：
     ```cpp
     for(int i = len ; i >= 1 ; -- i)
         sum[i] = max(0, sum[i+1] + (a[i] == '1' ? 1 : -1));
     ```

2. **Vasily0959（4.5星）**
   - 亮点：经典套路总结与贪心调整证明，代码精简高效
   - 关键思路：将极差问题分解为固定最大值时的最小值优化

3. **未来姚班zyl（4星）**
   - 亮点：数学化的极差转换思路，代码中维护后缀最大值数组

## 核心代码实现
```cpp
// 预处理后缀最大值数组
for(int i = n; i >= 1; --i) 
    sum[i] = max(0, sum[i+1] + (s[i] == '1' ? 1 : -1));

// 计算给定limit时的最小极差
int calc(int limit) {
    int cnt = 0, mn = 0;
    for(int i = 1; i <= n; ++i) {
        if(s[i] == '0') cnt--;
        else if(s[i] == '1') cnt++;
        else { // 处理?
            if(cnt + sum[i+1] + 1 <= limit) cnt++;
            else cnt--;
        }
        mn = min(mn, cnt);
    }
    return limit - mn;
}

// 主函数调用
cout << min(calc(sum[1]), calc(sum[1] + 1));
```

## 同类型题目推荐
1. [CF1538D. Another Problem About Dividing Numbers](https://codeforces.com/problemset/problem/1538/D) - 极值转化与贪心策略
2. [LeetCode 152. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) - 前缀和极值问题
3. [AGC022C - Remainder Game](https://atcoder.jp/contests/agc022/tasks/agc022_c) - 贪心策略与极差优化

## 复古游戏化动画设计
**实现方案**：
1. **8位像素风格**：使用16色调色板绘制前缀和折线图，每个字符用8x8像素块表示
2. **音效设计**：
   - 替换?时播放8-bit音效（升调表示选1，降调表示选0）
   - 极差更新时根据是否打破记录播放不同音效
3. **自动演示模式**：
   - 模拟贪心算法的逐步决策过程，AI自动选择替换策略
   - 用箭头指示当前处理字符，动态显示sum[i+1]的预处理值
4. **关卡系统**：
   - 每个测试样例作为一关，通关后显示极差优化曲线
   - 根据极差与理论最小值的比例给予星级评价

**交互示例**：
```javascript
// Canvas绘制核心逻辑（伪代码）
function drawStep(i, currentSum, limit) {
    ctx.fillStyle = '#00FF00'; // 当前字符高亮
    drawCharBlock(i, s[i]); 
    drawSumLine(currentSum); // 绘制前缀和折线
    if(s[i] === '?') {
        let canChoose1 = currentSum + sum[i+1] + 1 <= limit;
        drawDecisionArrow(canChoose1 ? 1 : -1); // 显示决策方向
    }
}
```

## 个人心得摘录
> "当发现贪心策略的正确性难以证明时，可以通过极值的奇偶性分析，枚举相邻候选值来规避复杂证明" —— 未来姚班zyl

> "将?视为可连续调整的变量，通过后缀预处理实现O(n)决策，是本题的精髓所在" —— Vasily0959

---
处理用时：73.68秒
# 题目信息

# [AGC065C] Avoid Half Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc065/tasks/agc065_c

長さ $ N $ の非負整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。ここで、 $ S=\sum_{i=1}^{N}\ A_i $ は偶数です。

以下の条件を満たす長さ $ N $ の非負整数列の組 $ B=(B_1,B_2,\dots,B_N),\ C=(C_1,C_2,\dots,C_N) $ が存在するか判定してください。

- $ i=1,2,\dots,N $ に対し $ B_i+C_i=A_i $ が成り立つ
- $ i=1,2,\dots,N $ に対し $ X_i=B_i $ または $ X_i=C_i $ が成り立つ任意の長さ $ N $ の整数列 $ X=(X_1,X_2,\dots,X_N) $ に対し、 $ \sum_{i=1}^{N}\ X_i\ \neq\ \frac{S}{2} $ である
 
$ T $ 個のテストケースについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ \sum_{i=1}^{N}\ A_i $ は偶数
- $ 1 $ つの入力に含まれるテストケースについて、 $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値はすべて整数
 
### Sample Explanation 1

$ 1 $ つ目のテストケースについて、 $ B=(1,1,3),\ C=(0,1,0) $ とすると条件を満たします。 $ 2 $ つ目のテストケースについて、条件を満たす $ B,C $ の組は存在しません。

## 样例 #1

### 输入

```
3

3

1 2 3

6

1 1 2 2 3 3

4

1 1 1000000000 1000000000```

### 输出

```
Yes

No

Yes```

# AI分析结果



# 算法分类  
**组合数学**

---

## 综合分析与结论  
题目要求构造两个数组 \( B \) 和 \( C \)，使得所有可能的 \( X \) 的和无法等于 \( S/2 \)。核心思路是通过奇偶性分析和组合数学的计数条件，判断是否存在这样的分割方式。

### 关键公式与推导  
1. **核心结论**：存在解当且仅当存在一个元素 \( A_i \)，使得比 \( A_i \) 小的奇数的数量小于 \( A_i - 1 \)。  
   - **证明思路**：通过鸽巢原理，若比 \( A_i \) 小的奇数足够多，则可以通过组合调整总和；反之，若数量不足，则无法调整到 \( S/2 \)。  
2. **实现步骤**：  
   - 将数组排序，统计每个元素前的小于它的奇数的数量。  
   - 检查是否存在元素满足上述条件。  

### 解决难点  
- **数学转化**：将问题转化为符号选择问题（是否存在一组符号使得总和为0），通过奇偶性分析简化条件。  
- **构造策略**：优先处理较大的元素，通过分割拉大分差，确保剩余元素无法通过符号调整弥补差异。  

### 可视化设计  
- **动画方案**：  
  - **排序与统计**：以升序排列数组，高亮当前元素并动态统计其前的奇数数量。  
  - **条件检查**：逐步遍历元素，用颜色标记满足条件的元素（绿色表示满足，红色不满足）。  
- **复古像素风格**：  
  - **8位风格界面**：用像素块表示数组元素，奇偶性用不同颜色区分（如红色奇数，蓝色偶数）。  
  - **音效提示**：发现满足条件的元素时播放成功音效，否则播放失败音效。  

---

## 题解清单  
### 题解1：_sunkuangzheng_（★★★★★）  
- **关键亮点**：简洁的数学结论，直接通过排序和统计实现 \( O(N \log N) \) 算法。  
- **代码实现**：排序后遍历，统计奇数数量并检查条件。  

### 题解2：masonpop（★★★☆☆）  
- **关键亮点**：策略性构造分差，通过贪心策略最小化调整空间。  
- **不足**：思路较为复杂，未明确数学证明。  

---

## 代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto &x : a) cin >> x;
    sort(a.begin(), a.end());
    vector<int> cnt(n + 1); // cnt[i]表示前i个元素中奇数的数量
    cnt[0] = 0;
    for (int i = 0; i < n; ++i) {
        cnt[i + 1] = cnt[i] + (a[i] % 2);
    }
    for (int i = 0; i < n; ++i) {
        int num = a[i];
        if (num % 2 == 0) continue;
        // 找到第一个>=num的位置
        int pos = lower_bound(a.begin(), a.end(), num) - a.begin();
        int pre = cnt[pos];
        if (pre < num - 1) {
            cout << "Yes\n";
            return;
        }
    }
    cout << "No\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

---

## 同类型题套路  
- **奇偶性分析**：利用奇偶性简化组合条件（如总和为偶数的约束）。  
- **鸽巢原理**：通过数量统计判断是否存在可行解。  
- **贪心策略**：优先处理较大元素以构造不可调整的分差。  

---

## 相似题目推荐  
1. [CF1516C - Baby Ehab Partitions Again](https://codeforces.com/problemset/problem/1516/C)  
2. [AT ABC229F - Make Pair](https://atcoder.jp/contests/abc229/tasks/abc229_f)  
3. [洛谷P7078 - 贪吃蛇](https://www.luogu.com.cn/problem/P7078)  

---

## 个人心得摘录  
- **排序优先**：对数组排序是简化奇偶性分析的关键步骤。  
- **边界处理**：注意元素值为1时的特例（如 \( A_i - 1 = 0 \)）。  

---

## 可视化演示（复古像素风格）  
- **Canvas绘制**：  
  - 元素按升序排列，奇数为红色方块，偶数为蓝色方块。  
  - 遍历时高亮当前元素，显示其前的奇数数量。  
- **音效触发**：满足条件时播放8位音效，背景音乐循环播放FC风格BGM。

---
处理用时：111.79秒
# 题目信息

# [ARC061F] 3人でカードゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc061/tasks/arc061_d

A さん、B さん、C さんの $ 3 $ 人が以下のようなカードゲームをプレイしています。

- 最初、$ 3 $ 人はそれぞれ `a`、`b`、`c` いずれかの文字が書かれたカードを、A さんは $ N $ 枚、B さんは $ M $ 枚、C さんは $ K $ 枚持っている。$ 3 $ 人は、持っているカードを並べ替えることはできない。
- A さんのターンから始まる。
- 現在自分のターンである人がカードを $ 1 $ 枚以上持っているならば、そのうち先頭のカードを捨てる。その後、捨てられたカードに書かれているアルファベットと同じ名前の人 (例えば、カードに `a` と書かれていたならば A さん) のターンとなる。
- 現在自分のターンである人がカードを $ 1 $ 枚も持っていないならば、その人がゲームの勝者となり、ゲームは終了する。

$ 3 $ 人が最初に配られるカードに書いてある文字の並びは、全部で $ 3^{N+M+K} $ 通りの組み合わせがあります。このうち、A さんが勝者となってゲームが終了するのが何通りあるかを求めてください。

答えは大きくなる可能性があるので、$ 1\,000\,000\,007\ (=10^9+7) $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3×10^5 $
- $ 1\ \leq\ M\ \leq\ 3×10^5 $
- $ 1\ \leq\ K\ \leq\ 3×10^5 $

### 部分点

- $ 1\ \leq\ N\ \leq\ 1000 $、 $ 1\ \leq\ M\ \leq\ 1000 $、 $ 1\ \leq\ K\ \leq\ 1000 $ を満たすデータセットに正解した場合は、 $ 500 $ 点が与えられる。

### Sample Explanation 1

\- A さんが `a` を持っている場合は、他の $ 2 $ 人の持っているカードに関わらず A さんが勝ちます。これは $ 3×3=9 $ 通りあります。 - A さんが `b` を持っている場合は、B さんが `a` を持っているか、 B さんが `c` を持っていてかつ C さんが `a` を持っている場合に限り A さんが勝ちます。これは $ 3+1=4 $ 通りあります。 - A さんが `c` を持っている場合は、C さんが `a` を持っているか、 C さんが `b` を持っていてかつ B さんが `a` を持っている場合に限り A さんが勝ちます。これは $ 3+1=4 $ 通りあります。 合計すると、 $ 9+4+4=17 $ 通りとなります。

## 样例 #1

### 输入

```
1 1 1```

### 输出

```
17```

## 样例 #2

### 输入

```
4 2 2```

### 输出

```
1227```

## 样例 #3

### 输入

```
1000 1000 1000```

### 输出

```
261790852```

# AI分析结果



## 算法分类
**组合数学**

---

## 题解思路与难点分析
### 核心思路
问题转化为统计所有满足以下条件的操作序列数目：
1. 序列中恰好有 `n` 个 `a`，且最后一个字符是 `a`。
2. 序列中 `b` 的数量不超过 `M`，`c` 的数量不超过 `K`。

对于每个可能的 `b` 和 `c` 的总数量 `t`，计算组合数并累加贡献。关键点在于快速计算组合数的部分和 `S(t)`，通过递推公式实现高效计算。

### 关键公式推导
1. **组合数部分和递推式**  
   `S(t) = ∑ C(t,i)`（`i` 的取值范围为 `max(0, t-K) ≤ i ≤ min(M, t)`）。  
   利用递推关系：  
   `S(t) = 2*S(t-1) - C(t-1, M) - C(t-1, t-K-1)`  
   该式通过组合数的拆分和边界条件推导得出，避免直接求和的高复杂度。

2. **总贡献计算**  
   每个 `t` 的贡献为：  
   `C(n-1 + t, t) * S(t) * 3^{M+K-t}`  
   其中 `C(n-1 + t, t)` 表示将 `n-1` 个 `a` 与 `t` 个非 `a` 字符排列的方案数，`3^{M+K-t}` 表示剩余卡片的任意填充方案。

### 解决难点
- **组合数部分和的快速计算**：通过递推式将复杂度从 `O(MK)` 降为 `O(M+K)`。
- **大规模组合数预处理**：使用阶乘和逆元预处理，实现组合数的 `O(1)` 查询。

---

## 题解评分（≥4星）
1. **command_block（5星）**  
   - 思路清晰，递推式推导简洁。
   - 代码高效，预处理阶乘和逆元，直接实现核心公式。
   - 时间复杂度 `O(N)`，适合大规模数据。

2. **tzc_wk（4星）**  
   - 详细推导组合数递推关系，代码结构清晰。
   - 使用滚动变量优化空间，适合内存敏感场景。

3. **abruce（4星）**  
   - 快速幂与组合数预处理结合，代码简洁。
   - 递推过程处理边界条件严谨，适合教学演示。

---

## 最优思路提炼
**递推组合数部分和**  
通过观察组合数部分和的递推关系，将原本 `O(t)` 的求和转化为 `O(1)` 的递推步骤，极大优化时间复杂度。核心公式：  
```math
S(t) = 2 \cdot S(t-1) - \binom{t-1}{M} - \binom{t-1}{t-K-1}
```

---

## 同类型题套路
- **组合数部分和问题**：常通过递推或生成函数优化。
- **动态规划与组合数学结合**：利用预处理和递推式减少重复计算。
- **模数下的大数运算**：阶乘和逆元预处理是标准技巧。

---

## 推荐题目
1. **洛谷 P3773 [CTSC2017]吉夫特**（组合数性质）  
2. **洛谷 P6669 [清华集训2016]组合数问题**（递推与模数处理）  
3. **洛谷 P4921 [MtOI2018]情侣？给我烧了！**（组合排列与容斥）

---

## 代码实现（关键部分）
```cpp
#include <cstdio>
#define ll long long
#define MaxN 900500
using namespace std;
const int mod = 1000000007;
ll fac[MaxN], ifac[MaxN], S[MaxN], pw3;

ll powM(ll a, int t) {
    ll ret = 1;
    while (t) {
        if (t & 1) ret = ret * a % mod;
        a = a * a % mod; t >>= 1;
    }
    return ret;
}

ll C(int n, int m) {
    if (m < 0 || n < m) return 0;
    return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

void init(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;
    ifac[n] = powM(fac[n], mod - 2);
    for (int i = n; i; i--) ifac[i - 1] = ifac[i] * i % mod;
}

int main() {
    int n, m, k;
    scanf("%d%d%d", &n, &m, &k);
    int N = n + m + k;
    init(N);

    // 计算S(t)
    S[0] = 1;
    for (int t = 1; t <= m + k; t++)
        S[t] = (2 * S[t - 1] - C(t - 1, m) - C(t - 1, t - k - 1) + 2 * mod) % mod;

    ll ans = 0, buf = powM(3, m + k);
    ll inv3 = powM(3, mod - 2);
    for (int t = 0; t <= m + k; t++) {
        ans = (ans + C(n - 1 + t, t) * S[t] % mod * buf) % mod;
        buf = buf * inv3 % mod; // 3^{m+k-t}递推
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 可视化设计（复古像素风格）
### 核心动画流程
1. **初始化网格**：用像素块表示阶乘表和递推过程。
2. **递推展示**：高亮当前 `t` 的 `S(t)` 计算，显示递推公式的拆分步骤。
3. **组合数计算**：动态绘制组合数查询过程，用不同颜色区分有效/无效项。
4. **音效触发**：完成一步计算时播放8-bit音效，错误时播放警示音。

### 交互设计
- **步进控制**：键盘左右键控制递推步骤。
- **自动播放**：AI模式展示自动推导，速度可调。
- **状态面板**：显示当前 `t`、`S(t)` 值和累计答案。

---

## 个人心得摘录
> "递推式推导时，多次尝试拆解组合数求和范围，最终发现边界项的对称性，是解题的突破口。"  
> —— command_block

> "预处理逆元时，反向递推比逐个快速幂更高效，适合大规模组合数问题。"  
> —— tzc_wk

---
处理用时：257.43秒
# 题目信息

# [ARC169D] Add to Make a Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc169/tasks/arc169_d

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます． $ A $ の各要素は $ 0 $ 以上 $ N-1 $ 以下の整数です．

あなたは以下の操作を $ 0 $ 回以上行うことができます．

- $ A $ の中からちょうど $ M $ 個の要素を選ぶ． そして，選んだ要素の値をそれぞれ $ 1 $ 増加させる． 増加させたあとに値が $ N $ になっている要素があれば，その値を $ 0 $ に変更する．
 
あなたの目標は $ A $ を $ (0,1,\cdots,N-1) $ の順列にすることです． 目標が達成可能か判定し，可能ならば必要な最小の操作回数を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 250000 $
- $ 1\ \leq\ M\ \leq\ N-1 $
- $ 0\ \leq\ A_i\ \leq\ N-1 $
- 入力される値はすべて整数．
 
### Sample Explanation 1

以下のように操作すると $ 2 $ 回の操作で目標を達成できます． - 初期状態: $ A=(0,1,1) $ - $ 1 $ 回目の操作: $ A_1,A_2 $ を選んで操作を行い，$ A=(1,2,1) $ になる． - $ 2 $ 回目の操作: $ A_2,A_3 $ を選んで操作を行い，$ A=(1,0,2) $ になる． $ 2 $ 回未満の操作で目標を達成することはできないため，答えは $ 2 $ になります．

## 样例 #1

### 输入

```
3 2

0 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2

0 4 2 3 1```

### 输出

```
0```

## 样例 #3

### 输入

```
4 2

0 0 1 2```

### 输出

```
-1```

## 样例 #4

### 输入

```
20 15

5 14 18 0 8 5 0 10 6 5 11 2 10 10 17 9 8 14 4 4```

### 输出

```
10```

# AI分析结果



---

**算法分类**  
数论

**综合分析与结论**  
本题核心在于构造满足模数条件的连续递增序列，并通过数论方法求解最小操作次数。关键步骤如下：

1. **排序与连续序列构造**  
   将数组排序后，假设目标序列为连续整数段 `B_i = x + i - 1`。此时模 `N` 自然形成排列。

2. **约束条件分析**  
   - **递增约束**：`x ≥ max(A_i - i + 1)`  
   - **总和整除**：总和 `S = n*x + C` 需满足 `M | S`  
   - **最大增量约束**：`max(B_i - A_i) ≤ S/M`  

3. **同余方程求解**  
   通过同余方程 `n*x ≡ -C mod M` 确定 `x` 的可能解，结合模数特性调整 `x` 至满足所有条件。

**可视化设计**  
在复古像素风格下，通过以下动画演示：
1. **初始排序**：展示数组排序过程，高亮 `A_i` 和 `i` 的差值，确定 `x` 的下界。
2. **方程求解**：以滚动文字显示同余方程推导，逐步调整 `x` 的值，并触发音效提示。
3. **增量调整**：动态展示 `max(B_i - A_i)` 与 `S/M` 的比较，当不满足时，以渐变颜色标记调整 `x` 的步骤。

---

**题解清单**  
1. **Aigony（4.5星）**  
   - **亮点**：通过调整法证明最优序列结构，代码简洁高效。  
   - **代码片段**：  
     ```cpp
     sort(a+1,a+n+1);
     for(int i=1;i<=n;i++) x = max(x, a[i]-i+1);
     ```

2. **Wuyanru（4星）**  
   - **亮点**：详细数学推导，证明连续序列最优性，包含严谨公式证明。  
   - **心得**：通过反证法优化序列结构，降低计算复杂度。

3. **DaiRuiChen007（4星）**  
   - **亮点**：实现简洁，直接处理同余方程，利用GCD加速计算。  
   - **代码片段**：  
     ```cpp
     while(sum%m) ++k, sum += n;
     ```

---

**最优思路提炼**  
1. **连续序列构造**：将目标序列视为连续整数段，通过排序简化问题。
2. **同余优化**：利用 `gcd(n, m)` 快速调整 `x` 满足模条件。
3. **增量平衡**：通过数学不等式平衡最大增量与总操作次数。

**同类题型**  
- **模数排列构造**：AT4530（模数排列转换）
- **增量操作优化**：CF1458C（矩阵增量约束）
- **同余方程应用**：洛谷P3518（同余优化）

**推荐题目**  
1. [ARC147D] - 构造模数排列  
2. [CF1396C] - 多重模数操作  
3. [洛谷P4139] - 扩展欧几里得应用  

**个人心得**  
调试中发现 `x` 的初始下界容易遗漏 `i` 的影响，通过可视化排序过程可直观验证约束条件。关键顿悟在于意识到连续序列的模数特性可简化验证。

---

**核心代码实现**  
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2.5e5+5;

int n,m,a[MAXN],g;
ll sum,k=0;

signed main() {
    scanf("%d%d",&n,&m); g=__gcd(n,m);
    for(int i=0;i<n;++i) scanf("%d",&a[i]), sum+=a[i];
    if((1ll*n*(n-1)/2 - sum) % g) return puts("-1"),0;
    sort(a,a+n);
    for(int i=0;i<n;++i) k=max(k, (ll)a[i]-i);
    sum = (2*k +n-1)*n/2 - sum;
    while(sum % m) ++k, sum +=n;
    ll mx=0, d=m/g, c=n*d/m;
    for(int i=0;i<n;++i) mx=max(mx, k+i -a[i]);
    if(mx > sum/m) {
        ll cur=(mx - sum/m -1)/(c -d) +1;
        printf("%lld\n", sum/m + cur*c);
    } else printf("%lld\n", sum/m);
    return 0;
}
```

**可视化代码片段（Canvas动画）**  
```javascript
// 绘制排序后的数组及x下界
ctx.fillStyle = '#8B00FF';
sortedA.forEach((val, idx) => {
    drawPixel(10 + idx*8, 50 - val, ctx);
    const bound = val - idx +1;
    if(bound > currentX) currentX = bound; // 动态更新x
});
```

**复古音效设计**  
- **成功音**：8-bit上升琶音（频率220Hz→440Hz）  
- **调整音**：方波短促音（50ms，440Hz）  
- **错误音**：噪声爆破音（100ms）

---
处理用时：92.81秒
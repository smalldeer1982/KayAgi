# 题目信息

# [ABC392G] Fine Triplets

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc392/tasks/abc392_g

当三个整数 $A,B,C$（满足 $A < B < C$）满足 $B - A = C - B$ 时，称 $(A,B,C)$ 为**好的三元组**。  
给定一个包含 $N$ 个元素的正整数集合 $S = \{\ S_1, S_2, \dots, S_N\ \}$，求满足 $A,B,C \in S$ 的好的三元组的个数。

## 说明/提示

### 约束条件

- 输入均为整数
- $1 \leq N \leq 10^6$
- $1 \leq S_i \leq 10^6$
- $S$ 中的元素互不相同

### 样例解释 1

$S = \{8,3,1,5,2\}$。符合条件的好的三元组有以下 $3$ 个：
- $(1,2,3)$
- $(1,3,5)$
- $(2,5,8)$

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5
8 3 1 5 2```

### 输出

```
3```

## 样例 #2

### 输入

```
7
300000 100000 499998 499999 200000 400000 500000```

### 输出

```
5```

## 样例 #3

### 输入

```
10
13 1 16 15 12 4 7 10 2 19```

### 输出

```
10```

# AI分析结果



# ABC392G Fine Triplets 题解分析

## 算法分类
**FFT/卷积**

---

## 题解思路与核心难点
### 关键思路
1. **数学转化**：将条件 $B - A = C - B$ 转化为 $A + C = 2B$，即寻找满足和为偶数的三元组 $(A, B, C)$。
2. **多项式卷积**：将集合元素视为多项式的指数项（如 $x^{S_i}$），平方后得到所有两数之和的频次。
3. **统计调整**：
   - 对每个 $B$，取卷积结果中 $2B$ 的频次。
   - 排除 $A=B$ 或 $C=B$ 的非法情况（即减去 1）。
   - 除以 2 以消除 $(A,C)$ 和 $(C,A)$ 的顺序重复。

### 解决难点
- **高效计算两数和频次**：直接枚举所有数对的时间复杂度为 $O(N^2)$，无法处理 $N \leq 10^6$。通过 FFT 将多项式乘法优化至 $O(M \log M)$（$M$ 为值域）。
- **去重处理**：确保统计时 $A < B < C$，需通过数学调整避免重复计数。

---

## 题解评分（≥4星）
1. **lovely_nst（5星）**  
   - 使用 Atcoder 官方库 `atcoder/convolution`，代码简洁高效。  
   - 关键代码仅 15 行，直接调用库函数完成卷积，统计逻辑清晰。
   ```cpp
   #include <atcoder/convolution>
   // 核心代码：构造多项式并卷积
   vector<int> s(1e6+5, 0), s2 = s;
   for (int x : a) s[x] = 1;
   vector<ll> conv = convolution(s, s);
   ```
   
2. **CuFeO4（4星）**  
   - 思路简洁，直接指出“卷积后统计答案”的关键步骤。  
   - 代码简短，但未使用库函数，需自行实现卷积（未展示完整代码）。

3. **Walrus（4星）**  
   - 详细解释了如何通过 FFT 构造多项式，并处理重复计数。  
   - 提供拓展思考，讨论负数场景下的调整方法。

---

## 最优技巧提炼
1. **多项式卷积加速**：将数对和问题转化为多项式乘法，利用 FFT/NTT 将复杂度降至 $O(M \log M)$。
2. **桶计数与调整公式**：
   - 计算 $C_{2B} = \text{卷积结果}[2B]$。
   - 合法三元组数目为 $\frac{C_{2B} - 1}{2}$，减 1 排除 $B+B$，除以 2 消除顺序重复。

---

## 同类型题目推荐
1. **P3803 【模板】多项式乘法（FFT）**  
   - 练习 FFT 的基础应用。
2. **P3723 [AH2017/HNOI2017] 礼物**  
   - 利用 FFT 优化循环平移后的最小差值问题。
3. **CF632E Thief in a Shop**  
   - 通过卷积计算恰好选 $k$ 个物品的总价值。

---

## 个人心得摘录
- **调试教训**：注意值域范围，需保证多项式大小足够覆盖所有可能的和。
- **库函数优势**：使用现成的卷积库（如 Atcoder）可大幅简化代码，避免手写 FFT 的复杂调试。

---

## 可视化设计（复古像素风格）
### 算法演示
1. **像素化数值网格**：  
   - 将每个数值 $S_i$ 显示为网格中的像素块，颜色深浅表示出现次数（全为 1）。
2. **卷积过程动画**：  
   - 展示多项式相乘时波形的叠加过程，用动态光点表示频次累加。
3. **高亮关键步骤**：  
   - 当统计 $2B$ 时，对应的网格位置闪烁，并显示当前累计的三元组数目。

### 交互功能
- **步进控制**：按空格键逐步执行“构造多项式→卷积→统计”流程。
- **音效设计**：  
  - 卷积计算时播放 8-bit 电子音效，频率随计算进度变化。
  - 统计完成时播放胜利音效。

---

## 核心代码片段（lovely_nst）
```cpp
#include <atcoder/convolution>
#include <bits/stdc++.h>
using namespace std;
using namespace atcoder;

vector<int> s, s2;
int main() {
    int n; cin >> n;
    s.resize(1e6 + 5);
    for (int i = 0; i < n; i++) {
        int x; cin >> x;
        s[x] = 1;
    }
    s2 = s;
    auto conv = convolution(s, s2);
    long long ans = 0;
    for (int x : a) {
        int idx = 2 * x;
        if (idx < conv.size())
            ans += (conv[idx] - 1) / 2;
    }
    cout << ans;
}
```

---

**总结**：通过 FFT/NTT 加速卷积计算是本题的核心，结合桶计数与数学调整，可在高效处理大规模数据的同时保证正确性。

---
处理用时：92.97秒
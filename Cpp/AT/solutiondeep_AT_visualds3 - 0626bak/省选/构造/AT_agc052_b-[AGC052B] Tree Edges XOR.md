# 题目信息

# [AGC052B] Tree Edges XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc052/tasks/agc052_b

$ N $ 頂点の木が与えられます。ここで、$ N $ は **奇数** です。 木の頂点には $ 1 $ から $ N $ までの、辺には $ 1 $ から $ N-1 $ までの番号が付けられています。 辺 $ i $ は頂点 $ u_i,\ v_i $ を結び、初期状態での重みは $ w^1_i $ です。

あなたは、次の操作を何度でも行えます。

- 木から辺 $ (u,\ v) $ を選ぶ。この辺の現在の重みが $ w $ であるとする。$ u,\ v $ のいずれかちょうど一方に接続する各辺について、その重みを $ w $ との **XOR** に置き換える（操作前の辺の重みが $ w_1 $ であるとすると、操作後の重みは $ w_1\ \oplus\ w $ となる）。

あなたの目標は、各辺 $ i $ の重みを $ w^2_i $ とすることです。 上記の操作を何度でも行えるとして、目標の達成が可能か判定してください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 10^5 $
- $ N $ は奇数である。
- $ 1\le\ u_i,\ v_i\ \le\ N $
- $ u_i\ \neq\ v_i $
- $ 0\le\ w^1_i,\ w^2_i\ <\ 2^{30} $
- 入力中の値は全て整数である。
- 入力が表すグラフは木である。

### Sample Explanation 1

辺 $ 1 $ に対して操作を行うと、辺 $ 2 $ の重みが $ 8\ \oplus\ 1=9 $ となります。

## 样例 #1

### 输入

```
3

1 2 1 1

2 3 8 9```

### 输出

```
YES```

## 样例 #2

### 输入

```
5

1 2 0 3

1 3 1 0

1 4 2 1

1 5 0 0```

### 输出

```
NO```

# AI分析结果



### 唯一算法分类  
树的性质与异或技巧  

---

### 综合分析与结论  
**核心思路**：  
1. **边权转点权**：将每条边的权值转化为点到根节点的路径异或和。设根为 1 号点，则边权满足 `w(u, v) = a_u ^ a_v`（其中 `a_u` 是点权）。  
2. **调整因子计算**：由于操作可交换相邻点的点权，最终需满足初始点权集合与目标点权集合等价。利用 `n` 为奇数的性质，计算调整因子 `x = xor_sum(初始点权) ^ xor_sum(目标点权)`，使得调整后的初始点权集合与目标集合相同。  
3. **集合匹配验证**：将初始点权异或 `x` 后排序，与目标点权排序结果比较。  

**解决难点**：  
- 操作的本质是交换相邻点的点权，而根节点的特殊性通过虚拟边处理。  
- 利用奇数的异或性质确定调整因子 `x`，避免了暴力枚举。  

**可视化设计**：  
- **树形结构展示**：用不同颜色标记根节点、虚拟边，动态显示操作对点权的影响。  
- **异或调整动画**：每个点权异或 `x` 时，以闪烁效果展示数值变化，并同步更新集合对比。  
- **复古像素风格**：以 8-bit 网格显示点权集合，调整后集合与目标集合并排展示，匹配时播放胜利音效。  

---

### 题解清单（≥4星）  
1. **作者：crimson000（★★★★☆）**  
   - 引入虚拟边处理根节点，清晰推导点权交换逻辑。  
   - 代码实现简洁，直接通过两次 DFS 计算点权。  

2. **作者：Llx2022（★★★★☆）**  
   - 详细图解操作对点权的影响，突出交换相邻点权的本质。  
   - 代码注释明确，调整因子计算部分尤为清晰。  

3. **作者：do_while_true（★★★★☆）**  
   - 提出“点权异或 `x` 的必要条件”思路，结合数学证明验证。  
   - 代码排序后直接比较集合，逻辑直观。  

---

### 最优思路或技巧提炼  
**关键技巧**：  
1. **点权定义**：将边权转换为路径异或和，便于操作分析。  
2. **调整因子推导**：利用 `n` 为奇数的性质，将异或总和差异转化为调整因子。  
3. **集合匹配**：通过排序比较集合，避免复杂结构判断。  

**代码实现核心**：  
```cpp
// 计算初始点权和目标点权
void dfs(int u, int fa, int path_initial, int path_goal) {
    initial[u] = path_initial;
    goal[u] = path_goal;
    for (auto edge : adj[u]) {
        if (edge.v == fa) continue;
        dfs(edge.v, u, path_initial ^ edge.w1, path_goal ^ edge.w2);
    }
}

// 计算调整因子并验证集合匹配
int x = 0;
for (int i = 1; i <= n; i++) x ^= initial[i] ^ goal[i];
for (int i = 1; i <= n; i++) initial[i] ^= x;
sort(initial + 1, initial + n + 1);
sort(goal + 1, goal + n + 1);
bool valid = equal(initial + 1, initial + n + 1, goal + 1);
```

---

### 同类型题或类似算法套路  
- **异或路径性质**：如 CF 1879D（Sum of XOR Functions），利用异或前缀和性质。  
- **树边权转点权**：如洛谷 P3398（仓鼠找 sugar），通过 LCA 判断路径交点。  
- **奇偶性优化**：如 AGC 相关题目中利用奇偶性简化条件。  

---

### 推荐相似题目  
1. **洛谷 P4551**（最长异或路径）  
2. **CF 1056E**（Check Transcription）  
3. **AGC 048C**（Dice Product）  

---

### 个人心得摘录  
- **作者：__Floze3__**：  
  > “操作的本质是交换相邻点权，但根节点的特殊处理需要引入虚拟边。这一转化是解题的关键。”  

- **作者：Soh_paramEEMS**：  
  > “注意力惊人，异或总和的性质是突破口。必须利用 `n` 为奇数的条件才能确定调整因子。”  

---

### 可视化与算法演示  
**动画方案**：  
1. **树形结构显示**：  
   - 根节点为红色，虚拟边为虚线。  
   - 点击边触发操作，高亮交换的点权并播放“交换音效”。  

2. **异或调整过程**：  
   - 每个节点数值闪烁显示异或 `x` 的结果，右侧同步更新集合排序。  
   - 匹配成功时，所有节点变为绿色并播放胜利音效。  

**复古像素风格**：  
- **颜色方案**：16 色调色板，根节点深红，虚拟边灰色。  
- **Canvas 绘制**：网格显示点权数值，异或调整时数值翻转为像素动画。  
- **音效设计**：操作触发 8-bit “哔”声，匹配成功播放经典 FC 过关音乐。  

**自动演示模式**：  
- 逐步展示 DFS 计算点权、调整因子计算、集合比较过程，支持暂停/继续。  

---

**代码片段（JS 动画核心）**：  
```javascript
function visualizeXORAdjust() {
    nodes.forEach(node => {
        node.value ^= x; // 异或调整
        node.element.animateFlip(); // 像素翻转动画
    });
    playSound('adjust'); // 播放调整音效
    if (collectionsMatch()) playVictoryMusic(); // 匹配成功
}
```

---
处理用时：119.38秒
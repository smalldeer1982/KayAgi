# 题目信息

# [AGC063C] Add Mod Operations

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc063/tasks/agc063_c

非負整数列 $ A\ =\ (A_1,\ \ldots,\ A_N) $ および $ B=(B_1,\ \ldots,\ B_N) $ が与えられます．

以下の操作を $ 0 $ 回以上 $ N $ 回以下行うことで，$ A $ を $ B $ に一致させることができるか否かを判定してください．

- 操作：$ 0\leq\ x\ <\ y\leq\ 10^{18} $ を満たす整数 $ x,y $ を選ぶ．すべての $ i $ に対して，$ A_i $ を $ (A_i+x)\bmod\ y $ に置き換える．
 
$ A $ を $ B $ に一致させることが可能な場合には，そのような手順をひとつ出力してください．

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 1000 $
- $ 0\leq\ A_i\leq\ 10^9 $
- $ 0\leq\ B_i\leq\ 10^9 $
 
### Sample Explanation 1

次のようにして $ A $ を $ B $ に一致させることができます． - はじめ $ A\ =\ (7,2,4,5) $ です． - $ (x,y)\ =\ (3,5) $ として操作を行うと，$ A\ =\ (0,0,2,3) $ になります． - $ (x,y)\ =\ (3,6) $ として操作を行うと，$ A\ =\ (3,3,5,0) $ になります．

## 样例 #1

### 输入

```
4

7 2 4 5

3 3 5 0```

### 输出

```
Yes

2

3 5

3 6```

## 样例 #2

### 输入

```
1

5

3```

### 输出

```
Yes

1

2 4```

## 样例 #3

### 输入

```
2

3 1

3 1```

### 输出

```
Yes

0```

## 样例 #4

### 输入

```
2

0 0

1 2```

### 输出

```
No```

# AI分析结果



### 算法分类
构造、模运算

### 题解思路与算法要点
1. **无解条件**：若存在相同的 $A_i = A_j$ 但对应的 $B_i \neq B_j$，则无法构造。
2. **排序去重**：对 $A$ 排序并去重，保留对应的 $B$ 值，确保剩余元素严格递增。
3. **构造步骤**：
   - **n=1**：直接构造 $(x, y) = (B_1 - A_1 + P, P)$，其中 $P$ 为大数。
   - **n≥2**：
     - **前 n-1 次操作**：每次消去当前最大值，其余元素加上 $x$，模数选为 $y = x + \max(A)$。
     - **最后一步**：使用大模数调整余数，确保所有元素匹配目标值。

### 解决难点
- **模运算的逆向构造**：通过选择 $y = x + \max(A)$，每次操作后最大值变为 0，其他元素加 $x$，逐步调整相对位置。
- **避免负数与冲突**：通过给 $B_i$ 添加大数偏移，确保差分操作中 $x \geq 0$，从而满足 $0 \leq x < y$ 的条件。

### 题解评分
1. **yuheng_wang080904（★★★★☆）**  
   - 思路清晰，通过排序和多次模运算构造操作序列。
   - 代码简洁，利用大数偏移处理差分。
2. **Leasier（★★★★☆）**  
   - 提出分步构造和最后模大数的思路，实现高效。
   - 代码中通过 `addition` 变量处理偏移，逻辑严密。
3. **DaiRuiChen007（★★★★☆）**  
   - 直接构造操作序列，使用大数调整余数。
   - 代码简洁，去重和排序处理明确。

### 最优思路提炼
- **核心思想**：通过排序后逐步消去最大值，构造差分序列，最后一步模大数调整余数。
- **关键步骤**：
  1. 排序去重后的 $A$ 和 $B$。
  2. 前 n-1 次操作每次消去最大值，其余元素加 $x$，模数为 $x + \max(A)$。
  3. 最后一次操作选 $(x, y) = (B_2, P)$，其中 $P$ 为大数，确保余数正确。

### 可视化算法演示
1. **动画设计**：
   - **初始状态**：显示排序后的 $A$ 数组和对应的 $B$ 数组。
   - **操作步骤**：每次操作时高亮当前最大值，展示 $x$ 和 $y$ 的计算过程，并动态更新数组元素。
   - **颜色标记**：红色高亮当前操作的最大值，绿色标记调整后的元素。
2. **复古像素风格**：
   - **像素方块**：用不同颜色方块表示数组元素，操作时方块移动并显示数值变化。
   - **音效**：操作成功时播放 8-bit 音效，失败时短促提示音。
   - **自动演示**：可设置自动播放，展示每一步的构造过程。

### 相似题目推荐
1. **P1253 线性代数**：构造操作序列满足特定条件。
2. **P1605 迷宫**：利用模运算性质构造路径。
3. **P1082 同余方程**：模运算的逆向构造与解的存在性判断。

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF = 2e9;

int main() {
    int n, m; cin >> m;
    map<ll, ll> mp;
    vector<ll> A(m), B(m);
    for (auto &x : A) cin >> x;
    for (int i = 0; i < m; i++) {
        ll b; cin >> b;
        if (mp.count(A[i]) && mp[A[i]] != b) {
            cout << "No\n";
            return 0;
        }
        mp[A[i]] = b;
    }
    vector<ll> a, b_new;
    for (auto [k, v] : mp) {
        a.push_back(k);
        b_new.push_back(v);
    }
    n = a.size();
    cout << "Yes\n" << n << "\n";
    if (n == 1) {
        ll x = (b_new[0] - a[0] + INF) % INF;
        cout << x << " " << INF << "\n";
        return 0;
    }
    for (int i = 2; i < n; i++) 
        b_new[i] += INF * (i - 1);
    b_new[0] += INF * n;
    ll x = b_new[0] - b_new.back() - a[0];
    ll y = x + a.back();
    cout << x << " " << y << "\n";
    for (int i = n - 1; i >= 2; i--) {
        x = b_new[i] - b_new[i - 1];
        y = x + a[i - 1];
        cout << x << " " << y << "\n";
    }
    cout << b_new[1] << " " << INF << "\n";
    return 0;
}
```

---
处理用时：87.47秒
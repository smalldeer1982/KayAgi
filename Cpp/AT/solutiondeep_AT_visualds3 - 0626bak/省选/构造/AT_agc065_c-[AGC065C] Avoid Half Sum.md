# 题目信息

# [AGC065C] Avoid Half Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc065/tasks/agc065_c

長さ $ N $ の非負整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。ここで、 $ S=\sum_{i=1}^{N}\ A_i $ は偶数です。

以下の条件を満たす長さ $ N $ の非負整数列の組 $ B=(B_1,B_2,\dots,B_N),\ C=(C_1,C_2,\dots,C_N) $ が存在するか判定してください。

- $ i=1,2,\dots,N $ に対し $ B_i+C_i=A_i $ が成り立つ
- $ i=1,2,\dots,N $ に対し $ X_i=B_i $ または $ X_i=C_i $ が成り立つ任意の長さ $ N $ の整数列 $ X=(X_1,X_2,\dots,X_N) $ に対し、 $ \sum_{i=1}^{N}\ X_i\ \neq\ \frac{S}{2} $ である
 
$ T $ 個のテストケースについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ \sum_{i=1}^{N}\ A_i $ は偶数
- $ 1 $ つの入力に含まれるテストケースについて、 $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値はすべて整数
 
### Sample Explanation 1

$ 1 $ つ目のテストケースについて、 $ B=(1,1,3),\ C=(0,1,0) $ とすると条件を満たします。 $ 2 $ つ目のテストケースについて、条件を満たす $ B,C $ の組は存在しません。

## 样例 #1

### 输入

```
3

3

1 2 3

6

1 1 2 2 3 3

4

1 1 1000000000 1000000000```

### 输出

```
Yes

No

Yes```

# AI分析结果



---

## 算法分类
**贪心、数学构造**

---

## 题解思路与解决难点
### 核心思路
题目要求构造两个数组B和C，使得任何选择Xi（Bi或Ci）的总和均不等于S/2。关键点在于如何确保所有可能的选法无法凑出目标值S/2。

通过分析，得出**充分必要条件**：存在一个元素a_i，使得严格小于它的奇数的个数小于a_i-1。该条件可通过排序后遍历数组验证。

### 解决难点
1. **数学构造**：需确保总差D为偶数且不为零。选择最大元素a_i作为主导，其他元素的差尽可能小。
2. **奇偶性处理**：总差D的奇偶性需与S一致，且每个元素的差必须符合其奇偶性。
3. **高效验证条件**：通过排序和二分查找快速统计严格小于当前元素的奇数个数。

---

## 最优思路/技巧提炼
1. **排序预处理**：对数组排序后，便于统计严格小于当前元素的奇数个数。
2. **二分查找优化**：使用二分快速定位奇数组中符合条件的元素数量。
3. **数学条件判断**：通过严格的数学推导得出存在解的充要条件，避免复杂构造。

---

## 题解评分
- **作者：_sunkuangzheng_** (★★★★★)  
  简洁的条件判断与高效实现，直接命中问题核心，代码清晰易懂。

---

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        int N;
        cin >> N;
        vector<int> A(N);
        vector<int> odds;
        for (int &a : A) {
            cin >> a;
            if (a % 2 != 0) odds.push_back(a);
        }
        sort(A.begin(), A.end());
        sort(odds.begin(), odds.end());
        bool found = false;
        for (int a : A) {
            int cnt = lower_bound(odds.begin(), odds.end(), a) - odds.begin();
            if (cnt < a - 1) {
                found = true;
                break;
            }
        }
        cout << (found ? "Yes" : "No") << '\n';
    }
    return 0;
}
```

---

## 可视化算法演示
**步骤动画设计**：
1. **排序阶段**：数组元素从左到右升序排列，奇数元素高亮显示。
2. **遍历判断**：依次检查每个元素，计算严格小于它的奇数个数（通过左侧的计数条显示）。
3. **条件触发**：当某个元素的计数值低于a_i-1时，触发成功动画（颜色闪烁）。

**复古像素效果**：
- **颜色方案**：8-bit 色调，绿色表示奇数，蓝色表示偶数。
- **音效**：成功时播放经典“金币”音效，失败时低音提示。

---

## 相似题目推荐
1. **洛谷 P1004**：选数构造，避免特定和。
2. **洛谷 P1280**：前缀和与奇偶性处理。
3. **洛谷 P2679**：子集和的高级构造问题。

---
处理用时：382.13秒
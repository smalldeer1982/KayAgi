# 题目信息

# ニワンゴくんとゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dwacon2018-final/tasks/dwacon2018_final_d

dwango社員のニワンゴくんは、あるゲームで遊んでいます。 このゲームでは、$ Q $ 体の敵が現れるので、プレイヤーをうまく操作して敵を倒す必要があります。 また、敵にはそれぞれ **体力** と呼ばれる値が定まっており、$ i $ 番目の敵の体力は $ N_i $ です。

ニワンゴくんの操作するプレイヤーには、**魔力** とよばれる値が定まっています。 敵と遭遇したとき、プレイヤーの魔力は $ 1 $ です。 この魔力は、敵と遭遇するたびに $ 1 $ に戻ることに注意してください。 ニワンゴくんは、毎ターン、次の操作のうちいずれかを行うことができます。

- 操作 $ 1 $: 魔力を $ 1 $ 増加させる。
- 操作 $ 2 $: 現在の魔力を $ x $ として、魔力を $ 2x $ に変更する。
- 操作 $ 3 $: 現在の魔力を $ x $ として、魔力を $ 2x\ +\ 1 $ に変更する。

プレイヤーの魔力がちょうど敵の体力に等しくなったとき、特殊な魔法が発動し、敵を倒すことができます。 ただし、魔力が敵の体力を超えてしまうと、もう敵を倒すことはできません。そのため、魔力が敵の体力を超えてしまうような操作を行ってはいけません。 プレイヤーの操作によって敵の体力が変化することはありません。

ニワンゴくんは、敵を倒すまでの操作の方法は何通りあるかが気になっています。 それぞれの敵に対して、ニワンゴくんが敵を倒すまでの操作の方法は何通りあるかを $ {\rm\ mod}\ 1,000,000,007 $ で求めてください。 ここで、途中で行う操作の番号が一回でも異なれば、途中の魔力の経過がまったく同じでも、異なる操作の方法として数えることに注意してください。

## 说明/提示

### 制約

- $ 1\ \leq\ Q\ \leq\ 200 $
- $ 1\ \leq\ N_i\ \leq\ 10^{18} $ ($ 1\ \leq\ i\ \leq\ Q $)
- $ N_i $ は整数

### 部分点

- $ Q\ =\ 1,\ 1\ \leq\ N_1\ \leq\ 10^{14} $ を満たすデータセットに正答すると、$ 1300 $ 点が与えられる。

### Sample Explanation 1

$ 1 $ 番目の敵の体力は $ 4 $ です。 魔力をちょうど $ 4 $ にするまでの操作の方法としては、次の $ 5 $ 通りがあります。 - 操作 $ 1 $, 操作 $ 1 $, 操作 $ 1 $ の順に操作を行う。 - 操作 $ 1 $, 操作 $ 2 $ の順に操作を行う。 - 操作 $ 2 $, 操作 $ 1 $, 操作 $ 1 $ の順に操作を行う。 - 操作 $ 2 $, 操作 $ 2 $ の順に操作を行う。 - 操作 $ 3 $, 操作 $ 1 $ の順に操作を行う。 ここで、最初に操作 $ 1 $ を行っても、操作 $ 2 $ を行っても、魔力の変化の仕方は変わりませんが、この $ 2 $ つの操作は区別することに注意してください。

### Sample Explanation 2

$ 1 $ 番目の敵については、この敵を倒すまでの操作の方法は $ 2 $ 通りあります。 $ 2 $ 番目の敵については、一切操作を行わなくても最初からプレイヤーの魔力が敵の体力と等しくなっています。 ここで、プレイヤーの魔力は $ 2 $ 番目の敵と遭遇した際に $ 1 $ に戻ることに注意してください。

### Sample Explanation 3

$ {\rm\ mod}\ 1,000,000,007 $ で出力するのを忘れないようにしてください。

## 样例 #1

### 输入

```
1

4```

### 输出

```
5```

## 样例 #2

### 输入

```
2

2

1```

### 输出

```
2

1```

## 样例 #3

### 输入

```
3

1000

2000

3000```

### 输出

```
415443858

630306535

766913460```

## 样例 #4

### 输入

```
10

983102606006243867

653718290103598600

364611268624595444

114746989192634390

81304291426411017

931878752092058491

395809284336497545

633900034071891379

895817108011279740

92661392530626177```

### 输出

```
893653300

150104699

232570112

922156483

361136690

103094234

245249617

912578727

399641917

820143308```

# AI分析结果



**唯一算法分类**  
动态规划与矩阵快速幂  

---

**综合分析与结论**  
本题核心在于通过递推式 `f(n) = f(n-1) + f(floor(n/2))` 计算操作序列数目，但因 `n` 极大（1e18），需用矩阵快速幂优化。关键点如下：  

1. **递推式推导**  
   - 最后一步操作可能是 **加1**（对应 `f(n-1)`）或 **倍增/倍增+1**（对应 `f(floor(n/2))`）。  
   - 递推式合并奇偶情况，通过 `floor(n/2)` 统一处理。  

2. **矩阵构造**  
   - 状态向量 `M(x)` 包含 `f[x], f[ceil(x/2)], f[ceil(x/4)], ..., f[ceil(x/2^59)]`，用于捕捉递归依赖关系。  
   - 转移矩阵 `N(x)` 根据 `x` 二进制末尾连续0的个数动态构造，仅更新必要的维度。  

3. **二进制分解与预处理**  
   - 预处理 `p[i]` 存储 `2^i` 长度区间的转移矩阵积。  
   - 递归分解 `n` 的二进制位，组合不同区间的矩阵积，快速计算最终结果。  

**可视化设计要点**  
- **动画方案**：  
  - 在 Canvas 中绘制二进制树状结构，高亮当前处理的二进制位及对应的转移矩阵块。  
  - 用不同颜色标记矩阵乘法的步骤：蓝色表示预处理矩阵，红色表示动态计算的矩阵块。  
  - 步进控制允许观察每一步的二进制分解和矩阵组合过程。  
- **复古音效**：  
  - 矩阵块相乘时播放“点击”音效，完成递归分解时播放上扬音效。  
  - 背景音乐使用 8-bit 风格循环，增强游戏化体验。  

---

**题解清单 (≥4星)**  
1. **MSF_Akatsuki 的题解（5星）**  
   - **亮点**：  
     - 通过二进制分解与矩阵预处理，将时间复杂度优化至 `O(log^4 n)`，完美处理极大值。  
     - 状态向量设计巧妙，利用 `ceil` 替代 `floor` 简化转移逻辑。  
     - 递归结合矩阵快速幂，实现高效查询。  

---

**最优思路与技巧提炼**  
1. **状态向量压缩**  
   - 将递推式中的多层依赖压缩为固定长度的状态向量，避免存储全部中间结果。  
2. **二进制分解优化**  
   - 利用二进制位的独立性预处理矩阵块，减少重复计算。  
3. **递归与矩阵结合**  
   - 通过递归分割问题，结合预处理的矩阵块快速合并结果。  

---

**同类型题与算法套路**  
- **类似递推优化**：斐波那契数列的矩阵快速幂解法。  
- **二进制分解应用**：大数快速幂、线段树区间查询优化。  

---

**推荐练习题**  
1. **洛谷 P1962（斐波那契数列）** - 矩阵快速幂基础。  
2. **洛谷 P5170（快速计算二项式系数）** - 二进制分解与递归结合。  
3. **洛谷 P5171（Earthquake）** - 动态规划与矩阵优化。  

---

**代码核心实现**  
```cpp
struct MATRIX {
    int a[65][65];
    MATRIX() { memset(a, 0, sizeof a); }
    MATRIX(LL w) { 
        // 构造基于二进制末尾0的转移矩阵
        for (int i = 0; i < 60; i++, w >>= 1) {
            a[i][i] = 1;
            a[i+1][i] = (w & 1);
        }
    }
};

MATRIX operator*(const MATRIX &a, const MATRIX &b) {
    MATRIX res;
    for (int k = 0; k < 60; k++)
        for (int i = 0; i < 60; i++)
            for (int j = 0; j < 60; j++)
                res.a[i][j] = (res.a[i][j] + (LL)a.a[i][k] * b.a[k][j]) % MOD;
    return res;
}

void work(LL n, int dep) {
    // 递归分解二进制位，组合矩阵块
    if (n == 0) return;
    if ((n & R[dep]) == R[dep]) {
        ans = ans * p[dep+1];
        return;
    }
    if (n & 1) {
        work((1LL << dep) - 1, dep-1);
        ans = ans * MATRIX((1LL << (dep+1)) - 1);
    }
    work(n >> 1, dep-1);
}
```

---

**可视化与复古游戏化设计**  
- **8-bit 像素动画**：  
  - 用网格表示二进制位，每个格子代表一个二进制位，颜色表示当前处理状态（绿色活跃，灰色未处理）。  
  - 矩阵块相乘时，对应格子闪烁黄色，音效同步触发。  
- **自动演示模式**：  
  - 用户输入 `n` 后，AI 自动分解二进制并逐步播放矩阵组合过程。  
- **积分系统**：  
  - 每正确分解一个二进制位得10分，音效奖励；错误操作扣分并播放警示音。  

--- 

**个人心得**  
调试中发现 `ceil` 与 `floor` 的等价转换是关键，避免复杂边界判断。矩阵构造需严格验证二进制末尾0的个数与转移逻辑的匹配，否则易产生计算错误。

---
处理用时：106.87秒
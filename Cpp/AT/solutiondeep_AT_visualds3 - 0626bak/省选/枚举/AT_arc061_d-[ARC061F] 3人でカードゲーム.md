# 题目信息

# [ARC061F] 3人でカードゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc061/tasks/arc061_d

A さん、B さん、C さんの $ 3 $ 人が以下のようなカードゲームをプレイしています。

- 最初、$ 3 $ 人はそれぞれ `a`、`b`、`c` いずれかの文字が書かれたカードを、A さんは $ N $ 枚、B さんは $ M $ 枚、C さんは $ K $ 枚持っている。$ 3 $ 人は、持っているカードを並べ替えることはできない。
- A さんのターンから始まる。
- 現在自分のターンである人がカードを $ 1 $ 枚以上持っているならば、そのうち先頭のカードを捨てる。その後、捨てられたカードに書かれているアルファベットと同じ名前の人 (例えば、カードに `a` と書かれていたならば A さん) のターンとなる。
- 現在自分のターンである人がカードを $ 1 $ 枚も持っていないならば、その人がゲームの勝者となり、ゲームは終了する。

$ 3 $ 人が最初に配られるカードに書いてある文字の並びは、全部で $ 3^{N+M+K} $ 通りの組み合わせがあります。このうち、A さんが勝者となってゲームが終了するのが何通りあるかを求めてください。

答えは大きくなる可能性があるので、$ 1\,000\,000\,007\ (=10^9+7) $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3×10^5 $
- $ 1\ \leq\ M\ \leq\ 3×10^5 $
- $ 1\ \leq\ K\ \leq\ 3×10^5 $

### 部分点

- $ 1\ \leq\ N\ \leq\ 1000 $、 $ 1\ \leq\ M\ \leq\ 1000 $、 $ 1\ \leq\ K\ \leq\ 1000 $ を満たすデータセットに正解した場合は、 $ 500 $ 点が与えられる。

### Sample Explanation 1

\- A さんが `a` を持っている場合は、他の $ 2 $ 人の持っているカードに関わらず A さんが勝ちます。これは $ 3×3=9 $ 通りあります。 - A さんが `b` を持っている場合は、B さんが `a` を持っているか、 B さんが `c` を持っていてかつ C さんが `a` を持っている場合に限り A さんが勝ちます。これは $ 3+1=4 $ 通りあります。 - A さんが `c` を持っている場合は、C さんが `a` を持っているか、 C さんが `b` を持っていてかつ B さんが `a` を持っている場合に限り A さんが勝ちます。これは $ 3+1=4 $ 通りあります。 合計すると、 $ 9+4+4=17 $ 通りとなります。

## 样例 #1

### 输入

```
1 1 1```

### 输出

```
17```

## 样例 #2

### 输入

```
4 2 2```

### 输出

```
1227```

## 样例 #3

### 输入

```
1000 1000 1000```

### 输出

```
261790852```

# AI分析结果



## 【唯一算法分类】  
组合数学（递推优化）

---

## 【综合分析与结论】  
### **核心思路与算法要点**  
题目要求统计A先抽完所有卡片的方案数。各题解均将问题转化为组合数学问题，通过分析操作序列的特征：  
1. 序列必须包含恰好`N`个'A'，且最后一个字符为'A'。  
2. B、C的出现次数分别不超过`M`和`K`。  

核心算法流程如下：  
1. **组合数预处理**：利用阶乘与逆元快速计算组合数。  
2. **递推部分和**：通过递推式 `S(k) = 2*S(k-1) - C(k-1, M) - C(k-1, k-K-1)` 高效计算非A牌的合法组合数。  
3. **累加总方案**：枚举非A牌的总数`k`，累加 `C(n1+k-1, k) * S(k) * 3^{总剩余牌数}`。  

### **解决难点与优化**  
- **组合数部分和的高效计算**：直接枚举会带来O(n²)复杂度，递推式利用组合数的性质将复杂度降为O(n)。  
- **边界条件处理**：组合数`C(n, m)`在`m < 0`或`n < m`时需返回0，避免非法计算。  

### **可视化设计思路**  
1. **动态递推演示**：  
   - **颜色标记**：  
     - 绿色箭头表示`S(k)`从`S(k-1)`继承的路径（乘以2）。  
     - 红色叉号标记被减去的组合数项（`C(k-1, M)`和`C(k-1, k-K-1)`）。  
   - **步进控制**：允许用户单步执行观察递推过程，高亮当前处理的`k`值。  
2. **像素风格动画**：  
   - **网格布局**：将组合数`C(n, m)`以像素方块表示，不同颜色区分合法/非法项。  
   - **音效触发**：  
     - 正确递推时播放短促上升音调。  
     - 遇到非法组合数时播放“错误”音效。  

---

## 【题解清单 (≥4星)】  
### 1. command_block（⭐⭐⭐⭐⭐）  
**关键亮点**：  
- 代码简洁高效，预处理阶乘和逆元。  
- 递推式推导清晰，边界处理严谨。  
- 时间复杂度O(N+M+K)，适合大规模数据。  

**代码片段**：  
```cpp  
void preS(int n2, int n3, ll *S) {
  S[0] = 1;
  for (int k = 1; k <= n2 + n3; k++)
    S[k] = (2 * S[k-1] - C(k-1, k-1-n3) - C(k-1, n2) + 2*mod) % mod;
}
```

### 2. No21（⭐⭐⭐⭐）  
**关键亮点**：  
- 详细推导组合数递推过程，适合数学理解。  
- 代码注释清晰，变量命名规范。  

**个人心得**：  
> “递推过程中需特别注意组合数的合法性，如`C(k-1, k-C-1)`可能为负数。”

### 3. tzc_wk（⭐⭐⭐⭐）  
**关键亮点**：  
- 数学符号与代码实现对应紧密。  
- 使用滚动变量优化空间复杂度。  

---

## 【最优思路提炼】  
### **递推式优化组合数部分和**  
- **核心公式**：  
  `S(k) = 2*S(k-1) - C(k-1, M) - C(k-1, k-K-1)`  
- **应用场景**：快速计算满足`i ≤ M`且`k-i ≤ K`的组合数部分和。  

### **预处理加速**  
- **阶乘与逆元**：预处理阶乘数组`fac[]`和逆元数组`ifac[]`，实现O(1)组合数查询。  

---

## 【相似题目推荐】  
1. **P4345 [SHOI2015] 超能粒子炮·改**  
   - 组合数部分和取模，需类似递推优化。  
2. **P2513 [HAOI2009] 逆序对数列**  
   - 递推优化动态规划，处理计数问题。  
3. **P3223 [HNOI2012] 排队**  
   - 复杂组合排列问题，需分步计算合法方案。  

---

## 【可视化代码片段】  
```javascript
// 递推过程动画（伪代码）
function animateS(k) {
  highlight(`S[${k}] = 2*S[${k-1}]`);
  playSound('step');
  setTimeout(() => {
    highlight(`- C(${k-1}, ${M})`);
    if (C(k-1, M) === 0) playSound('error');
    else playSound('subtract');
  }, 500);
  setTimeout(() => {
    highlight(`- C(${k-1}, ${k-K-1})`);
    if (C(k-1, k-K-1) === 0) playSound('error');
    else playSound('subtract');
  }, 1000);
}
```

---

## 【复古像素动画设计】  
- **颜色方案**：  
  - 合法组合数：绿色（#00FF00）  
  - 非法组合数：红色（#FF0000）  
  - 当前操作块：黄色闪烁（#FFFF00）  
- **音效触发**：  
  - `step.wav`：每次递推步进。  
  - `error.wav`：遇到非法组合数。  
- **自动演示模式**：  
  - 间隔500ms自动执行下一步，按空格暂停/继续。

---
处理用时：78.05秒
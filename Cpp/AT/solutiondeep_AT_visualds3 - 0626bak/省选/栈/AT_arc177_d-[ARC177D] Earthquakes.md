# 题目信息

# [ARC177D] Earthquakes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc177/tasks/arc177_d

AtCoder 街道は、平らな地面の上に伸びる数直線で表される道路です。この道路上に $ N $ 個の高さ $ H $ の電柱が立っています。電柱には $ 1,\ 2,\ \dots,\ N $ の番号が古い順に付けられています。電柱 $ i\ (1\ \leq\ i\ \leq\ N) $ は座標 $ X_i $ に地面と垂直に立っています。**電柱の最下部は地面に固定されています。**ここで、電柱は十分に細いものとして考えます。

AtCoder 街道ではこれから $ N $ 回の地震が発生します。$ i $ 回目 $ (1\ \leq\ i\ \leq\ N) $ の地震では、以下のことが起こります。

1. 電柱 $ i $ がまだ倒れていない場合、それが数直線における左または右の方向に、それぞれ $ \frac{1}{2} $ ずつの確率で倒れる。
2. 倒れようとしている電柱が、まだ倒れていない電柱に衝突した場合（電柱の最下部に衝突した場合を含む）、この電柱も同じ方向に倒れる。場合によってはこれが連鎖的に起こる。
 
ここで、1. で電柱がどちら方向に倒れるかは、他の電柱がどちら方向に倒れたかに関係しません。

以下の図は一回の地震での電柱の倒れ方の一例です。

![ ](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc177_d/2bf5e733d9f95c4209b1b2a6093b423312351960.png)

地震対策のため、$ t\ =\ 1,\ 2,\ \dots,\ N $ それぞれについて、ちょうど $ t $ 回目の地震ですべての電柱が倒れた状態になる確率を $ 2^N $ 倍した値を $ 998244353 $ で割った余りを求めてください。なお、出力すべき値は整数になることが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ H\ \leq\ 10^9 $
- $ 0\ \leq\ X_i\ \leq\ 10^9\ (1\ \leq\ i\ \leq\ N) $
- $ X_1,\ X_2,\ \dots,\ X_N $ はすべて異なる
- 入力はすべて整数
 
### Sample Explanation 1

以下の図は、この入力例における電柱の倒れ方の可能性を示しています。図中の分数はその状態になる確率を示しています。 !\[ \](https://img.atcoder.jp/arc177/1b1ec413ff3069cd13b19efd64b9c9d2.png) したがって、ちょうど $ 1,\ 2,\ 3 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ \frac{1}{2},\ \frac{1}{4},\ \frac{1}{4} $ です。これを $ 8 $ 倍した $ 4,\ 2,\ 2 $ を出力しましょう。

### Sample Explanation 2

以下の図は、この入力例における電柱の倒れ方の可能性を示しています。図中の分数はその状態になる確率を示しています。 !\[ \](https://img.atcoder.jp/arc177/f2ce4d20221071c814e204d8a2adc60d.png) したがって、ちょうど $ 1,\ 2,\ 3,\ 4 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ 0,\ \frac{1}{4},\ \frac{1}{4},\ \frac{1}{2} $ です。これを $ 16 $ 倍した $ 0,\ 4,\ 4,\ 8 $ を出力しましょう。

### Sample Explanation 3

ちょうど $ 1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ 0,\ \frac{1}{4},\ \frac{1}{8},\ \frac{3}{16},\ \frac{3}{32},\ \frac{7}{64},\ \frac{7}{64},\ \frac{1}{8} $ です。

### Sample Explanation 4

$ 37 $ 回目の地震までにすべての電柱が倒れることはありません。ちょうど $ 38,\ 39,\ 40 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ \frac{3}{8},\ \frac{3}{8},\ \frac{1}{4} $ です。

## 样例 #1

### 输入

```
3 2

0 3 1```

### 输出

```
4 2 2```

## 样例 #2

### 输入

```
4 10

10 55 20 45```

### 输出

```
0 4 4 8```

## 样例 #3

### 输入

```
8 1

5 0 6 3 8 1 7 2```

### 输出

```
0 64 32 48 24 28 28 32```

## 样例 #4

### 输入

```
40 20

695 793 11 502 114 861 559 4 212 609 894 435 429 94 91 258 161 45 33 605 673 634 629 163 283 826 409 84 507 548 31 248 588 340 357 168 926 949 322 912```

### 输出

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41942627 41942627 360709869```

# AI分析结果



## 算法分类
**组合数学 + 单调栈 + 线段树/前缀乘积优化**

---

## 题解思路与算法要点

### 核心思路
1. **分组处理**：将电柱按坐标排序后分组，相邻距离 ≤ H 的为一组，不同组独立。
2. **段内分析**：每组中，电柱的倒塌顺序由地震发生时间决定。每个电柱 i 成为该组最后一个倒塌的条件是：
   - 左侧所有早于 i 的地震必须向左倒（形成前缀最小值链）
   - 右侧所有早于 i 的地震必须向右倒（形成后缀最小值链）
3. **概率计算**：对于电柱 i，计算其成为组内最后一个倒塌的概率，结合其他组的概率乘积得到最终答案。

### 解决难点
1. **分组与独立性**：正确识别哪些电柱属于同一组（互相影响），利用排序与相邻距离判断。
2. **单调栈应用**：通过两次单调栈遍历（前缀和后缀），统计每个电柱的约束条件数量（决定指数项）。
3. **动态乘积维护**：使用线段树或前缀乘积优化，高效维护各组概率的乘积，支持单点修改与区间查询。

---

## 题解评分 (≥4星)

### ma_niu_bi (★★★★★)
- **亮点**：完整的分组处理逻辑，结合单调栈与线段树实现高效维护，代码结构清晰。
- **关键代码**：
  ```cpp
  // 分组逻辑
  sort(a + 1, a + n + 1, cmp);
  for (int i = 1; i <= n; i++) {
      if (a[i].x - a[i - 1].x <= h) 
          g[a[i].y] = c;
      else g[a[i].y] = ++c; 
  }
  ```

### 破壁人罗辑 (★★★★☆)
- **亮点**：启发式合并优化时间-概率数组，采用递归分治处理方向选择。
- **关键思路**：
  ```cpp
  void dfs(int l, int r, int n, int p) {
      if (l == r) vi[n].push_back(...);
      else if (k 在中间) { // 分治处理左右
          dfs(l, k-1, n, p);
          dfs(k+1, r, n, p);
      }
  }
  ```

### Lavaloon (★★★★☆)
- **亮点**：逆元动态维护全局乘积，规避线段树复杂操作，代码简洁。
- **核心代码**：
  ```cpp
  for (int i=1; i<=n; i++) {
      ans = ans * inv(s[t]) % mod * p % mod; // 逆元更新乘积
      s[t] = p; // 单点修改
  }
  ```

---

## 最优思路提炼

### 关键步骤
1. **分组预处理**：
   - 按坐标排序后，相邻距离 ≤ H 的划为同一组。
   - 每组独立计算最后倒塌的概率。
2. **段内概率计算**：
   - 对每个电柱 i，统计左侧前缀最小值数量 `lf[i]` 和右侧后缀最小值数量 `rg[i]`。
   - 概率公式：`prob = (1/2)^(lf[i]+rg[i]) * b/2`，其中 b 表示端点情况。
3. **乘积动态维护**：
   - 使用线段树维护各组的存活概率乘积。
   - 处理到电柱 i 时，查询其他组的乘积，并更新本组的贡献。

### 代码片段
```cpp
// 单调栈计算前后缀最小值数量
stack<int> stk;
for (int i = 1; i <= m; i++) {
    while (!stk.empty() && p[id][i] < stk.top()) stk.pop();
    stk.push(p[id][i]);
    k[i] = stk.size() - 1; // 前缀最小值链长度
}
```

---

## 类似题目推荐
1. **P1886 滑动窗口** - 单调队列/栈的经典应用。
2. **P5490 扫描线** - 区间处理与线段树结合。
3. **P3372 线段树模板** - 动态乘积维护的练习。

---

## 可视化设计

### 动画方案
1. **分组显示**：用不同颜色区块表示不同组，电柱按坐标排列，间距超过 H 时显示分隔线。
2. **单调栈过程**：高亮当前处理的电柱，动态绘制前缀/后缀链，栈内元素用像素块表示。
3. **线段树更新**：以树状结构展示各段概率乘积，修改节点时闪烁对应颜色。

### 复古像素风格
- **颜色方案**：8位色，电柱用绿色像素，倒塌方向用箭头动画，线段树节点用蓝色/红色区分。
- **音效**：电柱倒塌时播放 8-bit 破碎音效，线段树更新时触发电子音。

### 交互功能
- **步进控制**：空格键单步执行，方向键调整动画速度。
- **自动演示**：AI 模式自动展示分组与倒塌过程，右下角显示当前概率乘积。

---

## 个人心得摘录
> "分段后的独立处理是核心，必须保证每个段的计算完全隔离。" —— ma_niu_bi  
> "逆元维护全局乘积时，要特别注意 0 的不可逆问题，需特殊处理。" —— Lavaloon

---
处理用时：76.04秒
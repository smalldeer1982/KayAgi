# 题目信息

# [AGC034E] Complete Compress

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc034/tasks/agc034_e

頂点に番号 $ 1,\ 2,\ ...,\ N $ がついた $ N $ 頂点の木が与えられます。$ i $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結んでいます。 また長さ $ N $ の `0`, `1` からなる文字列 $ S $ が与えられ、$ S $ の $ i $ 文字目は頂点 $ i $ に置いてあるコマの個数を表しています。

すぬけ君は、以下の操作を好きなだけ行います。

- 距離が $ 2 $ 以上離れたコマ $ 2 $ 個を選び、お互いに $ 1 $ ずつ近づける。 正確に述べると、コマの置かれた頂点 $ u,\ v $ を選び、$ u,\ v $ 間の最短パスを考える。ここでパスの辺数が $ 2 $ 以上となるように選ぶことにする。パスにおいて $ u $ に隣り合う頂点にコマを $ 1 $ 個 $ u $ から動かし、$ v $ に隣り合う頂点にコマを $ 1 $ 個 $ v $ から動かす。

すぬけ君はこれを繰り返し、すべてのコマを同じ頂点に集めたいです。このようなことは可能でしょうか？ 可能な場合、それを達成するのに必要な操作の最小回数も求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2000 $
- $ |S|\ =\ N $
- $ S $ は `0`, `1`からなり、また少なくとも $ 1 $ 文字は `1` を含む
- $ 1\ \leq\ a_i,\ b_i\ \leq\ N(a_i\ \neq\ b_i) $
- 辺 $ (a_1,\ b_1),\ (a_2,\ b_2),\ ...,\ (a_{N\ -\ 1},\ b_{N\ -\ 1}) $ は木をなす

### Sample Explanation 1

\- 頂点 $ 3,\ 5 $ のコマを選ぶ - 頂点 $ 2,\ 7 $ のコマを選ぶ - 頂点 $ 4,\ 6 $ のコマを選ぶ の $ 3 $ 回の操作ですべてのコマを頂点 $ 1 $ に集めることができます。

## 样例 #1

### 输入

```
7

0010101

1 2

2 3

1 4

4 5

1 6

6 7```

### 输出

```
3```

## 样例 #2

### 输入

```
7

0010110

1 2

2 3

1 4

4 5

1 6

6 7```

### 输出

```
-1```

## 样例 #3

### 输入

```
2

01

1 2```

### 输出

```
0```

# AI分析结果



### 唯一算法分类
树形动态规划 (Tree DP)

---

### 综合分析与结论
**题目核心逻辑**:  
枚举所有可能的根节点，通过树形 DP 判断是否能将所有棋子移动到该根节点。关键点在于计算每个子树内的距离总和和平衡条件，确保总距离为偶数且各子树贡献可互相抵消。

**难点与解决方案**:  
1. **子树平衡条件**：若某子树贡献过大，需其他子树协同抵消。通过比较最大子树与其他子树总和的相对大小，判断是否能完全抵消。  
2. **换根优化**：利用换根 DP 将时间复杂度从 O(n²) 降为 O(n)，通过预处理父方向贡献的最大值次大值优化转移。  
3. **奇偶性判断**：总距离必须为偶数才能完全抵消，否则无解。

**可视化设计**:  
- **树结构与棋子分布**：用 Canvas 绘制树形结构，红色节点表示有棋子，灰色表示无。  
- **子树贡献高亮**：当前处理的子树用蓝色边框标记，实时显示距离总和。  
- **操作动画**：模拟棋子向中间移动的步骤，用箭头表示移动方向，总操作次数动态更新。  
- **复古像素风格**：使用 8-bit 音效（如移动时的“哔”声，成功时的上升音调），背景为低分辨率网格，节点用像素方块表示。

---

### 题解清单 (≥4星)
1. **Scintilla（5星）**  
   - 关键亮点：换根 DP 实现 O(n) 复杂度，预处理最大值次大值优化转移。  
   - 代码可读性高，变量命名清晰，处理父方向贡献的逻辑巧妙。

2. **little_sun（4星）**  
   - 思路清晰，直接树形 DP 枚举根节点，判断条件简洁。  
   - 代码实现简洁，适合快速理解核心逻辑。

3. **shinkuu（4星）**  
   - 详细推导子树平衡条件，结合贪心思想，解释深入浅出。  
   - 提供调试经验，如初始代码未通过的修正思路。

---

### 核心代码实现（Scintilla 解法）
```cpp
void dfs_down(int u, int fa) {
    dep[u] = dep[fa] + 1, sz[u] = hav[u]; 
    int nowmax = 0;
    for (int e = head[u]; e; e = edge[e].nxt) {
        int v = edge[e].to;
        if (v == fa) continue;
        dfs_down(v, u);
        down[u] += down[v] + sz[v];
        sz[u] += sz[v];
        upd(u, get(v)); // 更新最大值次大值
    }
    downf[u] = (nmax[u][1] > down[u]) ? nmax[u][1] - down[u] : down[u] & 1;
}

void dp(int u, int fa) {
    if (u != 1) {
        // 换根计算父方向贡献
        up[u] = down[fa] - down[u] - sz[u] + up[fa] + sz[1];
        int nowmax = max(get(u) == nmax[fa][1] ? nmax[fa][2] : nmax[fa][1], f[fa] + up[fa]);
        f[u] = nowmax - (g[fa] - down[u] - sz[u]);
        Ans[u] = (max(nmax[u][1], up[u] + f[u]) > g[u]) ? ...;
    }
    for (int e = head[u]; e; e = edge[e].nxt) {
        int v = edge[e].to;
        if (v == fa) continue;
        dp(v, u);
    }
}
```

---

### 同类型题推荐
1. **P3478 [POI2008] STA-Station**（换根 DP 模板题）  
2. **P2986 [USACO10MAR] Great Cow Gathering G**（类似贡献转移）  
3. **P3047 [USACO12FEB] Nearby Cows G**（树形 DP 多状态处理）

---

### 个人心得摘录
- **Scintilla**: “调换根 DP 时需注意父方向贡献的最大值可能来自当前子树，需用次大值替代。”  
- **shinkuu**: “手玩小样例发现，若最大子树无法被其他子树平衡，则无解。这一观察是推导平衡条件的关键。”  

---

### 可视化设计要点
1. **Canvas 动画**：  
   - 树节点用圆形表示，棋子数量显示在中心。  
   - 每次操作后，连线上的两个棋子向中间移动一格，路径高亮黄色。  
2. **音效触发**：  
   - 移动时播放 8-bit “哔”声，成功时播放上升音调。  
3. **自动演示模式**：  
   - 自动切换根节点，绿色高亮当前测试的根，红色显示不可行，蓝色显示可行。  
4. **控制面板**：  
   - 速度滑块调节动画速度，按钮暂停/继续/单步执行。

---
处理用时：70.67秒
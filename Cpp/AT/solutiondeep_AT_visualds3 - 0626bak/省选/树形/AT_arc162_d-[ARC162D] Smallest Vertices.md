# 题目信息

# [ARC162D] Smallest Vertices

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc162/tasks/arc162_d

この問題では、根付き有向木と言った際には全ての辺が根から葉の方向に向き付けられた根付き木を指すものとします。

総和が $ N-1 $ であるような非負整数列 $ d=(d_1,d_2,\ldots,d_N) $ が与えられます。

頂点に $ 1 $ から $ N $ の番号がついた、頂点 $ 1 $ を根とする $ N $ 頂点の根付き有向木のうち、以下の条件を満たすものを**良い木**と呼びます。

- 頂点 $ i\ (1\leq\ i\ \leq\ N) $ の出次数は $ d_i $
 
さらに、良い木の頂点 $ v $ に対して、 $ f(v) $ を「頂点 $ v $ の部分木に含まれる頂点（$ v $ 含む）の頂点番号の最小値」と定め、$ f(v)=v $ を満たす頂点を**良い頂点**と呼びます。

良い木全てに対する良い頂点の個数の総和を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 500 $
- $ 0\ \leq\ d_i\ \leq\ N-1 $
- $ d_1\ \geq\ 1 $
- $ \sum_{i=1}^N\ d_i\ =\ N-1 $
- 入力される数値は全て整数
 
### Sample Explanation 1

良い木は以下の $ 2 $ 通りあります。青く塗られた頂点は良い頂点です。 !\[\](https://img.atcoder.jp/arc162/D-sample1-zFXKLnmt.png) それぞれについて良い頂点は $ 4 $ 個、 $ 3 $ 個なので答えは $ 7 $ です。

## 样例 #1

### 输入

```
4

2 0 1 0```

### 输出

```
7```

## 样例 #2

### 输入

```
10

3 1 0 0 2 0 1 2 0 0```

### 输出

```
37542```

# AI分析结果



---

**唯一算法分类**：组合数学 + 动态规划

---

### **题解思路与核心难点**

#### **核心思路**
1. **Prufer序列计算总方案数**  
   利用 Prufer 序列的性质，合法树的数量为组合数公式：  
   $$ T = \frac{d_1 \cdot (n-2)!}{\prod_{i=1}^n d_i!} $$  
   其中，根节点和叶子节点的贡献直接为 $T$（因根的最小编号为 1，叶子的子树仅自身）。

2. **动态规划预处理子树选择**  
   设计状态 `dp[i][j][k]` 表示从编号 `i` 到 `n` 的顶点中选择 `j` 个顶点，其度数之和为 `k` 的方案数。倒序处理顶点，保证子树顶点编号 ≥ 当前顶点。

3. **非根非叶顶点的贡献计算**  
   对每个顶点 `x` 和子树大小 `k`，计算满足条件的子树方案数（内部方案）与外部剩余顶点的方案数（外部方案），相乘后累加所有可能。

#### **解决难点**
- **子树合法性验证**：子树顶点必须满足度数之和等于顶点数减一（即 `k-1`）。
- **组合数优化**：通过预处理阶乘和逆元，快速计算组合数。
- **动态规划转移**：状态转移需保证不重复计算，且时间复杂度控制在 $O(n^3)$。

---

### **题解评分 (≥4星)**
1. **PNNNN (⭐⭐⭐⭐⭐)**  
   代码清晰，动态规划预处理逻辑严谨，组合数学推导完整。核心代码片段：
   ```cpp
   for(int i=n;i>=1;i--){ 
       for(int j=0;j<=n-i+1;j++){ 
           for(int k=0;k<n;k++){ 
               dp[i][j][k] = dp[i+1][j][k]; 
               if(j>0 && k>=d[i]) dp[i][j][k] += dp[i+1][j-1][k-d[i]]; 
           } 
       } 
   }
   ```
   
2. **TernaryTree (⭐⭐⭐⭐)**  
   状态定义与转移与 PNNNN 类似，但代码更简洁，适合快速理解核心逻辑。

3. **冷却心 (⭐⭐⭐⭐)**  
   参考多篇题解，整合最优思路，代码注释详细，适合调试学习。

---

### **最优思路提炼**
- **关键数据结构**：三维动态规划数组 `dp[i][j][k]`，倒序枚举顶点。
- **组合数优化**：预处理阶乘和逆元，快速计算子树内外方案数。
- **分治思想**：将子树内外分离计算，利用乘法原理合并结果。

---

### **类似题目**
1. **洛谷 P6178 【模板】Matrix-Tree 定理**  
   基尔霍夫定理求生成树数量，同样涉及组合数学。
   
2. **洛谷 P4430 小猴打架**  
   利用 Prufer 序列计算树的结构数。
   
3. **洛谷 P4926 [1007]倍杀测量者**  
   动态规划与组合数学结合的高难度题。

---

### **可视化设计**
**动画方案**：  
1. **动态规划状态转移**：  
   - **颜色标记**：当前处理的顶点 `i` 高亮为红色，已选顶点为绿色，未选为灰色。
   - **步进控制**：单步展示状态转移，显示 `dp[i][j][k]` 的更新过程。
   
2. **子树选择演示**：  
   - **像素风格**：8-bit 网格展示顶点编号，选中子树时用黄色方块填充。
   - **音效触发**：每次选中顶点播放“哔”声，完成子树计算时播放上扬音效。

**复古游戏化**：  
- **Canvas 绘制**：顶点按编号排列为网格，点击触发动态规划状态更新。
- **积分系统**：每正确计算一个顶点的贡献增加 10 分，错误时扣分。

---

### **核心代码实现**
```cpp
// 预处理阶乘和逆元
fac[0] = 1;
for (int i = 1; i <= 500; i++) fac[i] = fac[i-1] * i % mod;
for (int i = 1; i <= n; i++) mul = mul * fac[d[i]] % mod;

// 动态规划初始化
dp[n+1][0][0] = 1;
for (int i = n; i >= 1; i--) {
    for (int j = 0; j <= n-i+1; j++) {
        for (int k = 0; k < n; k++) {
            dp[i][j][k] = dp[i+1][j][k];
            if (j > 0 && k >= d[i]) 
                dp[i][j][k] = (dp[i][j][k] + dp[i+1][j-1][k - d[i]]) % mod;
        }
    }
}

// 计算贡献
for (int x = 1; x <= n; x++) {
    if (x == 1 || d[x] == 0) { // 根或叶子直接加总方案
        ans = (ans + fac[n-2] * d[1] % mod * inv(mul) % mod) % mod;
    } else {
        for (int k = 1; k <= n - x + 1; k++) { // 枚举子树大小
            int sum = ... // 从 dp 中获取方案数
            ans = (ans + sum * ... ) % mod;
        }
    }
}
```

---
处理用时：100.43秒
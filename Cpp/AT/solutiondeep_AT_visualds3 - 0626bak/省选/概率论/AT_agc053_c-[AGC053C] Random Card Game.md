# 题目信息

# [AGC053C] Random Card Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc053/tasks/agc053_c

$ 2N $ 枚のカードがあり、それぞれには $ 1 $ から $ 2N $ までの番号が付いています。 このカードを用いて行う、次のゲームを考えます。

まず、ディーラーはそれぞれの山が $ N $ 枚のカードからなるように、カードを $ 2 $ つの山にランダムに分けます。 このとき、ディーラーは各山におけるカードの順序もランダムに定めます。 その後プレイヤーは、一方の山が空になるまで次の操作を繰り返し行い、最終的な操作回数がこのゲームのスコアとなります。

- ある正の整数 $ k $ を選び、一方の山の上から $ k $ 枚目のカードと、もう一方の山の上から $ k $ 枚目のカードを比較する。（ただし、$ k $ は各山のカード枚数を超えてはいけない。）そして、番号が小さい方のカードをそのカードを含む山から取り除く。

このゲームを *チーター* がプレイするとします。 つまり、各山の各カードの番号を常に把握できるプレイヤーがプレイするとします。 このプレイヤーがスコアを最小化するよう最適にプレイしたときの、スコアの期待値を $ \bmod\ 10^9+7 $ で求めてください（注記参照）。

## 说明/提示

### 注記

- 求める期待値は有理数となります。期待値を分数 $ \frac{y}{x} $（$ x $ と $ y $ は互いに素な正の整数）で表したとき、$ x $ は $ P=10^9+7 $ と互いに素になるので、 $ xz\ \equiv\ y\ \pmod\ P $ なる $ 0 $ 以上 $ P-1 $ 以下の唯一の整数 $ z $ を出力してください。

### 制約

- $ 1\ \leq\ N\ \leq\ 10^6 $

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
3```

### 输出

```
486111118```

# AI分析结果



---

**唯一算法分类**：概率与期望，组合数学

---

### **综合分析与结论**

本题的核心在于将最优策略转化为组合数学问题，并高效计算期望。所有题解均基于以下观察：
1. **关键变量** `d`：定义为 `max(p_i - i)`，其中 `p_i` 是 B 堆中首个大于 `A_i` 的位置。
2. **最小操作次数**：`n + d`，由最优策略构造保证。
3. **期望计算**：转化为求和 `P(d)`，其中 `P(d)` 表示 `max(p_i - i) ≤ d` 的概率。

**核心难点**在于推导 `P(d)` 的表达式并高效计算。所有题解均采用组合数学中的排列概率模型，将问题分解为两个乘积项的累乘，利用预处理阶乘和逆元加速计算。

**可视化设计**：
- **动画演示**：用像素风格展示两堆牌的排列，高亮每次比较的牌和移除过程。动态显示 `p_i` 的变化及 `d` 的更新。
- **音效提示**：移除牌时播放短音效，背景音乐采用 8-bit 风格循环。
- **自动演示模式**：逐步展示 `d` 的计算和 `P(d)` 的乘积过程，用颜色区分不同区间的乘积项。

---

### **题解清单 (≥4星)**

1. **joke3579 (5星)**  
   - **亮点**：思路清晰，代码简洁，双阶乘预处理高效。  
   - **关键推导**：将 `P(d)` 分解为奇偶项乘积，利用双阶乘预处理避免重复计算。

2. **HomuraAkemi (4星)**  
   - **亮点**：详细推导事件概率，引入排列下降技巧，解释直观。  
   - **引用心得**：“正难则反，考虑对立事件的概率，利用排列性质简化计算。”

3. **DaiRuiChen007 (4星)**  
   - **亮点**：代码简洁，直接使用双阶乘和逆元，实现高效。  
   - **关键步骤**：预处理阶乘和逆元数组，快速计算组合数乘积。

---

### **最优思路与技巧提炼**

1. **策略构造**：通过构造操作策略证明 `d = max(p_i - i)` 是下界，并可达。
2. **概率模型**：将 `P(d)` 分解为独立事件的乘积，利用排列中元素的最小值位置计算概率。
3. **预处理优化**：使用双阶乘和逆元预处理，将复杂度降至 `O(n)`。

**关键公式**：  
$$
P(d) = \prod_{i=1}^{n-d} \frac{2i+d-1}{2i+d} \times \frac{2n-d}{n}
$$

---

### **同类型题与类似套路**

- **相似题目**：涉及排列期望和组合优化的题目，如 [CF1540B Tree Array](https://codeforces.com/problemset/problem/1540/B)。
- **通用解法**：将最优策略转化为极值问题，利用概率独立性和预处理加速计算。

---

### **推荐题目**

1. [P3974 组合数学](https://www.luogu.com.cn/problem/P3974)  
2. [AT4539 Walk](https://www.luogu.com.cn/problem/AT4539)  
3. [CF1286D LCC](https://codeforces.com/problemset/problem/1286/D)

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7, N = 2e6 + 10;
int n, ans, invn, fac[N], inv[N], ifac[N];

int mul(int a, int b) { return 1ll * a * b % mod; }
int qp(int a, int b) { 
    int res = 1; 
    for (; b; a = mul(a, a), b >>= 1) 
        if (b & 1) res = mul(res, a); 
    return res; 
}

int calc(int d) { 
    // 计算组合数乘积项
    return mul(fac[2*n -1 -d], ifac[d-1], fac[d], ifac[2*n -d -2]);
}

int main() {
    cin >> n;
    // 预处理阶乘、逆元、双阶乘逆元
    fac[0] = ifac[0] = 1;
    for (int i = 1; i <= 2*n; ++i) {
        fac[i] = (i % 2) ? mul(fac[i-1], i) : fac[i-1];
        inv[i] = (i == 1) ? 1 : mul(mod - mod/i, inv[mod%i]);
        ifac[i] = (i % 2) ? mul(ifac[i-1], inv[i]) : ifac[i-1];
    }
    invn = qp(n, mod-2);
    ans = 2 * n % mod;
    for (int d = 0; d < n; ++d) {
        ans = (ans - mul(calc(d), invn)) % mod;
    }
    cout << (ans % mod + mod) % mod << endl;
}
```

---

### **可视化与复古动画设计**

- **像素风格布局**：  
  - 两堆牌以竖列显示，牌面用 8-bit 数字表示，背景色区分堆。
- **操作动画**：  
  - 高亮当前比较的 `A_k` 和 `B_k`，移除较小牌时播放“哔”音效。
- **概率计算演示**：  
  - 右侧面板显示 `P(d)` 的乘积过程，分区间高亮分子分母。
- **自动模式**：  
  - 按 `d` 从 0 到 n-1 逐步计算，显示当前项对总和的贡献。

---
处理用时：82.31秒
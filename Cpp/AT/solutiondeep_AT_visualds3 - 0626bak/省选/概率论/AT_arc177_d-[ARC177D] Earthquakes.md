# 题目信息

# [ARC177D] Earthquakes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc177/tasks/arc177_d

AtCoder 街道は、平らな地面の上に伸びる数直線で表される道路です。この道路上に $ N $ 個の高さ $ H $ の電柱が立っています。電柱には $ 1,\ 2,\ \dots,\ N $ の番号が古い順に付けられています。電柱 $ i\ (1\ \leq\ i\ \leq\ N) $ は座標 $ X_i $ に地面と垂直に立っています。**電柱の最下部は地面に固定されています。**ここで、電柱は十分に細いものとして考えます。

AtCoder 街道ではこれから $ N $ 回の地震が発生します。$ i $ 回目 $ (1\ \leq\ i\ \leq\ N) $ の地震では、以下のことが起こります。

1. 電柱 $ i $ がまだ倒れていない場合、それが数直線における左または右の方向に、それぞれ $ \frac{1}{2} $ ずつの確率で倒れる。
2. 倒れようとしている電柱が、まだ倒れていない電柱に衝突した場合（電柱の最下部に衝突した場合を含む）、この電柱も同じ方向に倒れる。場合によってはこれが連鎖的に起こる。
 
ここで、1. で電柱がどちら方向に倒れるかは、他の電柱がどちら方向に倒れたかに関係しません。

以下の図は一回の地震での電柱の倒れ方の一例です。

![ ](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc177_d/2bf5e733d9f95c4209b1b2a6093b423312351960.png)

地震対策のため、$ t\ =\ 1,\ 2,\ \dots,\ N $ それぞれについて、ちょうど $ t $ 回目の地震ですべての電柱が倒れた状態になる確率を $ 2^N $ 倍した値を $ 998244353 $ で割った余りを求めてください。なお、出力すべき値は整数になることが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ H\ \leq\ 10^9 $
- $ 0\ \leq\ X_i\ \leq\ 10^9\ (1\ \leq\ i\ \leq\ N) $
- $ X_1,\ X_2,\ \dots,\ X_N $ はすべて異なる
- 入力はすべて整数
 
### Sample Explanation 1

以下の図は、この入力例における電柱の倒れ方の可能性を示しています。図中の分数はその状態になる確率を示しています。 !\[ \](https://img.atcoder.jp/arc177/1b1ec413ff3069cd13b19efd64b9c9d2.png) したがって、ちょうど $ 1,\ 2,\ 3 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ \frac{1}{2},\ \frac{1}{4},\ \frac{1}{4} $ です。これを $ 8 $ 倍した $ 4,\ 2,\ 2 $ を出力しましょう。

### Sample Explanation 2

以下の図は、この入力例における電柱の倒れ方の可能性を示しています。図中の分数はその状態になる確率を示しています。 !\[ \](https://img.atcoder.jp/arc177/f2ce4d20221071c814e204d8a2adc60d.png) したがって、ちょうど $ 1,\ 2,\ 3,\ 4 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ 0,\ \frac{1}{4},\ \frac{1}{4},\ \frac{1}{2} $ です。これを $ 16 $ 倍した $ 0,\ 4,\ 4,\ 8 $ を出力しましょう。

### Sample Explanation 3

ちょうど $ 1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ 0,\ \frac{1}{4},\ \frac{1}{8},\ \frac{3}{16},\ \frac{3}{32},\ \frac{7}{64},\ \frac{7}{64},\ \frac{1}{8} $ です。

### Sample Explanation 4

$ 37 $ 回目の地震までにすべての電柱が倒れることはありません。ちょうど $ 38,\ 39,\ 40 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ \frac{3}{8},\ \frac{3}{8},\ \frac{1}{4} $ です。

## 样例 #1

### 输入

```
3 2

0 3 1```

### 输出

```
4 2 2```

## 样例 #2

### 输入

```
4 10

10 55 20 45```

### 输出

```
0 4 4 8```

## 样例 #3

### 输入

```
8 1

5 0 6 3 8 1 7 2```

### 输出

```
0 64 32 48 24 28 28 32```

## 样例 #4

### 输入

```
40 20

695 793 11 502 114 861 559 4 212 609 894 435 429 94 91 258 161 45 33 605 673 634 629 163 283 826 409 84 507 548 31 248 588 340 357 168 926 949 322 912```

### 输出

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41942627 41942627 360709869```

# AI分析结果



# 算法分类
**组合数学与单调栈优化**

---

## 题解思路与核心难点

### **核心思路**
1. **分段处理**：将相邻距离 ≤ H 的电线杆合并成段，不同段独立。
2. **单调栈分析**：对每段内的电线杆，利用单调栈计算每个电线杆 i 的左右两侧必须倒下的条件数目（前缀/后缀最小值数目）。
3. **概率计算**：每个电线杆 i 作为最后倒下的概率为 `(b/2) * 1/(2^a)`，其中 `a` 为必须满足的条件数目，`b` 为方向选择数。
4. **线段树维护乘积**：动态维护各段已处理的概率乘积，快速计算当前答案。

### **解决难点**
- **分段判断**：需按坐标排序后合并相邻可连锁倒塌的段。
- **方向约束推导**：必须确保左侧所有更早地震的电线杆向左倒，右侧同理。
- **高效合并概率**：使用线段树维护各段独立概率乘积，避免重复计算。

---

## 最优题解推荐（≥4星）

### 1. **ma_niu_bi 的题解（5星）**
- **亮点**：利用单调栈快速确定必须倒塌的条件数目，线段树高效维护全局乘积。
- **代码可读性**：结构清晰，分段处理与概率计算逻辑明确。
- **核心代码段**：
  ```cpp
  void solve(int id) {
      // 单调栈计算前缀和后缀最小值数目
      stack<int> stk;
      for (int i = 1; i <= m; i++) {
          while (!stk.empty() && p[id][i] < stk.top()) stk.pop();
          stk.push(p[id][i]);
          k[i] = stk.size() - 1;
      }
      // 计算概率并存储到 res
  }
  ```

### 2. **破壁人罗辑 的题解（4星）**
- **亮点**：分治递归处理段内时间-概率数组，启发式合并优化复杂度。
- **核心技巧**：利用 ST 表快速查询区间最小值，递归分解问题。

### 3. **Lavaloon 的题解（4星）**
- **亮点**：逆元维护非零乘积，避免线段树操作。
- **代码优化**：全局维护乘积和零值标记，简化计算。

---

## 关键算法流程可视化

### **动画设计**
1. **分段展示**：  
   - 用不同颜色区分各段，展示相邻段间距是否 ≤ H。
   - **像素风格**：每个电线杆显示为竖线，段间用虚线分隔。
2. **单调栈操作**：  
   - 动态显示栈内元素变化，高亮当前处理的电线杆。
   - **音效**：元素入栈/出栈时播放“哔”声。
3. **概率计算**：  
   - 每个电线杆 i 处理时，显示其左右必须倒塌的条件数目 `a` 和方向选择 `b`。
4. **线段树更新**：  
   - 节点颜色随值变化，当前修改的节点闪烁提示。
   - **自动演示**：按地震顺序逐步更新线段树，显示乘积变化。

### **复古像素实现**
- **调色板**：16 色，背景深蓝，电线杆绿色，线段树节点黄色。
- **Canvas 绘制**：  
  ```javascript
  function drawSegment(start, end) {
      ctx.fillStyle = '#00FF00'; // 电线杆颜色
      for (let i = start; i <= end; i++) {
          ctx.fillRect(x[i] * scale, 0, 2, height);
      }
  }
  ```
- **音效**：使用 Web Audio API 播放 8-bit 音效，倒塌时播放低频“轰”声。

---

## 相似题目推荐
1. **洛谷 P1886 滑动窗口**（单调队列/栈应用）
2. **洛谷 P5490 扫描线**（线段树维护区间）
3. **洛谷 P1972 逆序对**（分治与动态统计）

---

## 个人心得摘录
- **ma_niu_bi**：注意分段后每段的独立性和单调栈的方向约束推导。
- **破壁人罗辑**：递归分治需注意合并时的概率乘积顺序，避免重复计算。
- **调试教训**：逆元处理需确保分母非零，否则会模运算出错。

---

## 核心代码实现
```cpp
// 单调栈计算前缀和后缀最小值数目
void solve(int id) {
    int m = p[id].size() - 1;
    stack<int> stk; 
    for (int i = 1; i <= m; i++) {
        while (!stk.empty() && p[id][i] < stk.top()) stk.pop();
        stk.push(p[id][i]);
        k[i] = stk.size() - 1;
    }
    stack<int> sstk;
    for (int i = m; i >= 1; i--) {
        while (!sstk.empty() && p[id][i] < sstk.top()) sstk.pop();
        sstk.push(p[id][i]);
        k[i] += sstk.size() - 1;
    }
    // 计算每个位置的概率
    for (int i = 1; i <= m; i++) {
        int b = (i == 1 || p[id][i-1] < p[id][i]) + (i == m || p[id][i] > p[id][i+1]);
        res[id][i] = b * pow2[m - k[i] - 1] % mod;
    }
}
```

---

**可视化交互提示**：用户可通过方向键切换地震步骤，按空格暂停/继续，观察线段树节点更新与概率乘积变化。

---
处理用时：81.65秒
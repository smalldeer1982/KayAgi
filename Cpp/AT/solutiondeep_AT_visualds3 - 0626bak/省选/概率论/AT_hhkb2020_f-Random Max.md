# 题目信息

# Random Max

## 题目描述

[problemUrl]: https://atcoder.jp/contests/hhkb2020/tasks/hhkb2020_f

$ N $ 個の連続型確率変数 $ x_i $ ($ 1\ <\ =\ i\ <\ =\ N $) があり、それぞれ $ [L_i,\ R_i] $ の範囲をとる連続一様分布にしたがいます。 (すなわち、$ x_i $ は $ L_i $ 以上 $ R_i $ 以下の実数を等確率でとりうるランダムな変数です)

本問題の制約下では、これらの $ N $ 個の確率変数の最大値の期待値を $ E $ とすると、$ E\ \times\ (N+1)!\ \times\ \prod_{i=1}^N\ (R_i\ -\ L_i) $ は正整数であることが示せます。この値を $ 1,000,000,007 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 1000 $
- $ 0\ <\ =\ L_i\ <\ R_i\ <\ =\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

この確率変数の最大値の期待値は、とりうる範囲の中央値、すなわち $ E\ =\ \frac{3}{2} $ に等しいです。 よって、 $ E\ \times\ (N+1)!\ \times\ (R_1\ -\ L_1)\ =\ E\ \times\ 2\ =\ 3 $ が正解となります。

### Sample Explanation 2

求める期待値は $ E\ =\ \frac{5}{3} $ です。

## 样例 #1

### 输入

```
1

1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
2

1 2

1 2```

### 输出

```
10```

## 样例 #3

### 输入

```
2

1 2

2 4```

### 输出

```
36```

## 样例 #4

### 输入

```
5

40 96

81 92

16 384

32 768

65 536```

### 输出

```
52776507```

# AI分析结果



---

**唯一算法分类**  
数学，积分与概率（若选项中没有，则标注「无算法分类」）

---

### **综合分析与结论**

#### **核心思路与难点**
1. **数学建模**：将最大值的期望转化为积分问题，利用累积分布函数（CDF）的乘积性质和分段积分计算。
2. **分段处理**：将所有区间的端点（L_i, R_i）排序，划分为若干段，每段内 CDF 为多项式乘积。
3. **多项式维护**：每个段内维护一个多项式表达式，表示各变量在当前段内的概率贡献乘积。
4. **积分计算**：对每段的多项式进行解析积分，累加到总结果中。

#### **解决难点**
- **分段点的合并与排序**：通过将所有 L_i 和 R_i 排序，确定关键分界点，避免重复计算。
- **多项式高效处理**：每段只需乘一次线性因子（如 (x-L_i)/(R_i-L_i)），利用动态维护的多项式降低计算复杂度。

#### **可视化设计思路**
- **分段区间展示**：用 Canvas 绘制所有关键点，将区间从右到左标记，颜色区分不同段。
- **多项式动态更新**：在每段切换时，显示当前多项式表达式和积分贡献。
- **复古像素动画**：
  - **颜色方案**：使用 16 色像素调色板，关键点用红色，当前段用绿色，已处理段用灰色。
  - **音效触发**：每处理完一段播放“滴”声，积分完成时播放胜利音效。
  - **自动演示模式**：按分界点顺序逐步推进，展示积分累加过程。

---

### **题解清单 (≥4星)**

#### **1. 题解作者：joke3579（★★★★☆）**
- **亮点**：
  - 代码完整，实现分段积分与多项式维护。
  - 时间复杂度严格 O(n²)，适合大规模数据。
  - 利用排序优化分段处理，避免冗余计算。
- **关键代码片段**：
  ```cpp
  vector<Poly> segs; // 存储每段的多项式
  for (auto x : key_points) {
      while (!events.empty() && events.back().first >= x) {
          // 处理当前段的多项式更新
          Poly p = events.back().second;
          segs.push_back(integrate(p, prev_x, x));
          prev_x = x;
          events.pop_back();
      }
  }
  ```

#### **2. 题解作者：Galois_Field_1048576（★★★★☆）**
- **亮点**：
  - 详细推导连续期望的数学背景，适合理论理解。
  - 强调分治思想和多项式积分的通用性。
- **关键思路**：
  - 将区间按端点排序，从大到小处理，避免无效积分区域。

---

### **最优思路或技巧提炼**
1. **分治分段积分**：将复杂区间分解为 O(n) 段，每段内统一处理多项式。
2. **动态维护多项式**：每段只需乘线性因子，保持多项式阶数为 O(n)。
3. **数学公式转换**：通过 CDF 乘积性质将期望转化为积分问题，避免直接求 PDF。

---

### **同类型题与算法套路**
- **通用场景**：多变量联合分布的概率计算、分段积分优化。
- **类似题目**：
  1. **洛谷 P1654**：连续概率期望的积分计算。
  2. **洛谷 P4206**：多变量联合分布的最值问题。
  3. **AtCoder ABC189E**：分段多项式积分与组合数学。

---

### **推荐相似题目**
1. **洛谷 P1654**（期望计算，分段积分）
2. **洛谷 P4206**（多变量最值概率）
3. **AtCoder ARC108D**（多项式积分与组合优化）

---

### **个人心得摘录**
> “调试时发现，分段点的排序顺序必须从大到小，否则会漏掉某些区间的处理。”  
> —— 来自某未具名选手的踩坑记录

---

### **可视化与算法演示**
#### **核心算法动画设计**
- **步进控制**：按分段点逐步执行，展示当前段的多项式表达式和积分值。
- **像素风格示例**：
  ```javascript
  // Canvas 绘制关键点与当前段
  function drawSegment(x, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * scaleX, 0, 2, canvas.height);
  }
  // 触发音效
  function playSound(freq) {
      const oscillator = audioCtx.createOscillator();
      oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
      oscillator.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
  }
  ```

#### **复古游戏化效果**
- **背景音乐**：8-bit 风格循环旋律，使用 Web Audio API 合成。
- **积分动态显示**：用像素字体在 Canvas 右上角实时更新积分总值。
- **自动演示模式**：按分界点顺序自动推进，模拟“AI解题”过程。

---
处理用时：682.46秒
# 题目信息

# [AGC003D] Anticube

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc003/tasks/agc003_d

高橋君は誕生日にお母さんから正の整数 $ s_1,...,s_N $ をもらいました。ただし、要素の重複は許されます。 高橋君は、これらの$ N $個の整数のうちのいくつかを丸で囲みます。

高橋君は立方数が嫌いなので、$ s_i,s_j(i\ ≠\ j) $の両方が丸で囲まれているなら、その積$ s_is_j $は立方数とならないようにしたいです。 例えば、$ s_1=1,s_2=1,s_3=2,s_4=4 $のとき、$ s_1 $と$ s_2 $を同時に丸で囲むことはできません。また、$ s_3 $と$ s_4 $を同時に丸で囲むこともできません。

高橋君が丸で囲むことができる整数の個数の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ s_i\ ≦\ 10^{10} $
- 入力はすべて整数である。

### Sample Explanation 1

$ 1,2,3,5,6,7 $ を丸で囲むことができます。

## 样例 #1

### 输入

```
8

1

2

3

4

5

6

7

8```

### 输出

```
6```

## 样例 #2

### 输入

```
6

2

4

8

16

32

64```

### 输出

```
3```

## 样例 #3

### 输入

```
10

1

10

100

1000000007

10000000000

1000000009

999999999

999

999

999```

### 输出

```
9```

# AI分析结果



---

## 算法分类
**数论与贪心**

---

## 题解思路与解决难点

### 核心思路
1. **质因数分解优化**  
   预处理所有小于 $\sqrt[3]{10^{10}} \approx 2160$ 的质数，去除每个数的立方因子，将每个数表示为 $\prod p_i^{k_i\%3}$ 的形式，使得两个数乘积为立方数当且仅当它们的剩余质因数互为补集。

2. **补集映射与哈希统计**  
   对每个处理后数计算其补集（若两数相乘为立方数，则补集为其剩余质因数的反向模3结果），用哈希表统计各形式出现次数，成对选择出现次数较多的形式。

3. **特殊处理大质数**  
   剩余部分若为单个大质数（超过 $\sqrt{10^{10}}$）或不可分解形式，则无法形成有效补集，直接计入答案。

---

### 解决难点
1. **高效质因数分解**  
   通过预处理小质数快速去除立方因子，将分解复杂度从 $O(\sqrt{s_i})$ 降至 $O(\sqrt[3]{s_i})$。

2. **补集计算正确性**  
   对剩余部分的质因数分类讨论（质数、平方数、两质数乘积），确保补集映射的正确性。

3. **去重与统计优化**  
   使用 `map` 或哈希表记录各形式出现次数，成对处理互补形式避免重复计算。

---

## 题解评分 (≥4星)

1. **CYJian (5星)**  
   - **思路清晰**：详细分类剩余质因数形式，分桶处理互补对。  
   - **代码优化**：通过筛质数快速分解，利用 `map` 高效统计。  
   - **实践性强**：预处理质数范围合理，复杂度分析明确。

2. **K8He (4.5星)**  
   - **逻辑简洁**：直接计算补集映射，用 `map` 统计最大独立集。  
   - **代码可读**：质因数分解与补集计算步骤分明。  
   - **高效性**：时间复杂度 $O(n \log n)$，适合大规模数据。

3. **yijan (4星)**  
   - **思维独特**：提出根号分治处理剩余质因数，优化大质数判断。  
   - **代码精简**：利用 `sqrt` 快速判断平方数，减少冗余计算。  
   - **个人心得**：强调质数判断的优化技巧，适合快速实现。

---

## 最优思路/技巧提炼

### 关键步骤
1. **预处理小质数**  
   筛出 $\leq 2160$ 的质数，用于快速去除立方因子。
   ```cpp
   void Get_Prime(int n) {
       for(int i = 2; i <= n; i++) {
           if(!chk[i]) pri[++tot] = i;
           for(int j = 1; j <= tot && i * pri[j] <= n; j++) {
               chk[i * pri[j]] = 1;
               if(i % pri[j] == 0) break;
           }
       }
   }
   ```

2. **去除立方因子**  
   对每个数依次除以小质数的立方因子。
   ```cpp
   ll work(ll x) {
       for(int i = 1; i <= tot; i++)
           while(x % (pri[i]*pri[i]*pri[i]) == 0) x /= (pri[i]*pri[i]*pri[i]);
       return x;
   }
   ```

3. **补集映射与统计**  
   对剩余质因数分类，计算补集并用 `map` 统计。
   ```cpp
   map<ll, int> mp;
   for (auto x : nums) {
       ll complement = compute_complement(x); // 根据剩余质因数计算补集
       ans += max(mp[x], mp[complement]);
       mp[x] = mp[complement] = 0; // 标记已处理
   }
   ```

---

## 同类型题与算法套路

1. **质因数分解与补集映射**  
   适用于需要判断数之间乘积性质的问题（如平方数、立方数）。

2. **哈希统计与最大独立集**  
   常见于需要成对选择元素的最优化问题。

3. **质数筛法与根号分治**  
   结合小质数预处理与大数分类处理，优化分解效率。

---

## 相似题目推荐

1. **P2423 [HEOI2012]朋友圈**  
   - 质因数分解与独立集问题，需高效处理数之间的关系。

2. **P4167 [Violet]樱花**  
   - 数论分式化简，涉及质因数分解与补集思想。

3. **P1062 数列**  
   - 质因数幂次处理，需快速分解与映射统计。

---

## 核心代码实现

### 关键代码片段
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN = 1e5 + 5;
int pri[2200], tot;
bool chk[2200];

void sieve() {
    for (int i = 2; i < 2200; ++i) {
        if (!chk[i]) pri[tot++] = i;
        for (int j = 0; j < tot && i * pri[j] < 2200; ++j) {
            chk[i * pri[j]] = true;
            if (i % pri[j] == 0) break;
        }
    }
}

ll remove_cubic(ll x) {
    for (int i = 0; i < tot; ++i) {
        ll p3 = (ll)pri[i] * pri[i] * pri[i];
        while (x % p3 == 0) x /= p3;
    }
    return x;
}

int main() {
    sieve();
    int n; cin >> n;
    map<ll, int> cnt;
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ll x; cin >> x;
        x = remove_cubic(x);
        ll comp = 1, t = x;
        for (int j = 0; j < tot && pri[j] <= t; ++j) {
            if (t % pri[j] == 0) {
                int e = 0;
                while (t % pri[j] == 0) t /= pri[j], e++;
                e %= 3;
                if (e == 1) comp *= pri[j] * pri[j];
                else if (e == 2) comp *= pri[j];
            }
        }
        ll sq = sqrt(t);
        if (sq * sq == t) comp *= sq;
        else comp *= t * t;
        if (x == 1) ans = 1; // 处理立方数
        else {
            cnt[x]++;
            if (cnt.count(comp)) {
                ans += max(cnt[x], cnt[comp]);
                cnt[x] = cnt[comp] = 0;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 可视化设计要点

### 动画方案
1. **质因数分解演示**  
   - **高亮当前质数**：如筛除立方因子时，显示当前质数 `pri[i]` 和操作数 `x`。
   - **步进显示**：逐步展示 `x` 被除以 `p^3` 的过程，颜色标记剩余部分。

2. **补集计算与统计**  
   - **补集连线**：在哈希表中用不同颜色连接互为补集的数对。
   - **计数对比**：动态显示每对互补形式的数量，取较大值加入答案。

### 复古像素风格
- **8位调色板**：质数用绿色，立方数用红色，普通数用蓝色。
- **Canvas网格**：将质因数分解过程以方块堆叠形式展示，每个质数对应不同颜色方块。
- **音效触发**：分解完成时播放“叮”声，选中互补对时播放“咔”声。

### 自动演示模式
- **AI自动分解**：按质数顺序自动执行立方因子筛除，补集计算与统计。
- **关卡积分**：每正确处理一对互补对获得10分，错误选择扣5分，增强学习趣味性。

---

**通过以上设计，学习者可直观理解算法流程，并在交互中掌握质因数分解与补集映射的核心技巧。**

---
处理用时：127.75秒
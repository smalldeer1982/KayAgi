# 题目信息

# [AGC032D] Rotation Sort

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc032/tasks/agc032_d

$ \{\ 1,\ \ldots,\ N\ \} $ の順列 $ p\ =\ (p_1,\ \ldots,\ p_N) $ が与えられます。 あなたは、次の 2 種類の操作を好きな順序で繰り返し行うことができます。

- コスト $ A $ を支払う。 整数 $ l $ と $ r $ ($ 1\ \leq\ l\ <\ r\ \leq\ N $) を自由に選び、$ (p_l,\ \ldots,\ p_r) $ を左にひとつシフトする。 すなわち、$ p_l,\ p_{l\ +\ 1},\ \ldots,\ p_{r\ -\ 1},\ p_r $ をそれぞれ $ p_{l\ +\ 1},\ p_{l\ +\ 2},\ \ldots,\ p_r,\ p_l $ へ置き換える。
- コスト $ B $ を支払う。 整数 $ l $ と $ r $ ($ 1\ \leq\ l\ <\ r\ \leq\ N $) を自由に選び、$ (p_l,\ \ldots,\ p_r) $ を右にひとつシフトする。 すなわち、$ p_l,\ p_{l\ +\ 1},\ \ldots,\ p_{r\ -\ 1},\ p_r $ をそれぞれ $ p_r,\ p_l,\ \ldots,\ p_{r\ -\ 2},\ p_{r\ -\ 1} $ へ置き換える。

$ p $ を昇順にソートするために必要な総コストの最小値を求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 1\ \leq\ N\ \leq\ 5000 $
- $ 1\ \leq\ A,\ B\ \leq\ 10^9 $
- $ (p_1\ \ldots,\ p_N) $ は $ \{\ 1,\ \ldots,\ N\ \} $ の順列である。

### Sample Explanation 1

$ (p_1,\ p_2,\ p_3) $ を左にひとつシフトすると、$ p\ =\ (1,\ 2,\ 3) $ となります。

### Sample Explanation 2

例えば、次のように操作を行えばよいです。 - $ (p_1,\ p_2,\ p_3,\ p_4) $ を左にひとつシフトする。 すると、$ p\ =\ (2,\ 3,\ 1,\ 4) $ となる。 - $ (p_1,\ p_2,\ p_3) $ を右にひとつシフトする。 すると、$ p\ =\ (1,\ 2,\ 3,\ 4) $ となる。 このとき、総コストは $ 20\ +\ 30\ =\ 50 $ です。

## 样例 #1

### 输入

```
3 20 30

3 1 2```

### 输出

```
20```

## 样例 #2

### 输入

```
4 20 30

4 2 3 1```

### 输出

```
50```

## 样例 #3

### 输入

```
1 10 10

1```

### 输出

```
0```

## 样例 #4

### 输入

```
4 1000000000 1000000000

4 3 2 1```

### 输出

```
3000000000```

## 样例 #5

### 输入

```
9 40 50

5 3 4 7 6 1 2 9 8```

### 输出

```
220```

# AI分析结果



---

**算法分类**: 动态规划（基于最长上升子序列的变形）

---

### **题解思路、算法要点与解决难点**

**核心思路**：
1. **不动点的选择**：最优解中未被移动的数必须构成递增子序列（否则无法排序）。
2. **移动方向确定**：若数 $x$ 前存在更大的不动点，则需左移（代价 $B$）；若后存在更小的不动点，则需右移（代价 $A$）。
3. **动态规划状态设计**：  
   - 定义 `dp[i]` 表示以第 $i$ 个数为最后一个不动点的最小代价。  
   - 通过倒序枚举 `j`（上一个不动点）统计区间 `(j, i)` 内需左移和右移的数的数量。

**解决难点**：
- **快速统计移动代价**：通过倒序遍历维护两个计数器 `sl`（需左移数）和 `sr`（需右移数），实现 $O(n^2)$ 时间复杂度。
- **避免重复计算**：利用最长上升子序列的性质，确保每个数最多被处理一次。

---

### **题解评分 (≥4星)**

1. **installb（5星）**  
   - **亮点**：代码简洁，核心逻辑仅需 15 行；直接通过倒序统计 `sl` 和 `sr` 实现代价计算。  
   - **代码片段**：
     ```cpp
     for (LL i = 1; i <= n + 1; i++) {
         LL sr = 0, sl = 0;
         for (LL j = i - 1; j >= 0; j--) {
             if (a[j] < a[i]) dp[i] = min(dp[i], dp[j] + r * sr + l * sl);
             if (a[j] > a[i]) sr++; if (a[j] < a[i]) sl++;
         }
     }
     ```

2. **zzw4257（4星）**  
   - **亮点**：将操作转化为插入代价，二维状态 `f[i][j]` 表示处理前 $i$ 个数，最后一个不动点为 $j$ 的最小代价。  
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= n; ++i) {
         for (int j = 0; j <= mx; ++j) {
             v = f[i - 1][j];
             if (a[i] > j) f[i][a[i]] = min(f[i][a[i]], v), f[i][j] = min(f[i][j], v + A);
             else f[i][j] = min(f[i][j], v + B);
         }
     }
     ```

3. **Velix（4星）**  
   - **亮点**：引入线段树优化，将转移复杂度优化至 $O(n \log n)$，适合大规模数据（但本题 $n \leq 5000$ 无需优化）。  
   - **核心逻辑**：通过线段树维护前缀最小值和区间加法，高效计算动态规划转移。

---

### **最优思路或技巧提炼**

1. **最长上升子序列变形**：不动点序列必为原排列的递增子序列，转化为统计最长 LIS 并计算其余数的移动代价。
2. **双计数器优化**：倒序枚举不动点时，用 `sl` 和 `sr` 统计区间内需左移和右移的数量，避免重复遍历。
3. **虚拟边界处理**：在排列首尾添加哨兵元素（如 `a[0] = 1, a[n+1] = n+2`），简化边界条件判断。

---

### **同类型题或类似算法套路**

- **LIS 变形问题**：如 [LC300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)。
- **操作代价最小化**：如 [CF EDU162 D. Slimes](https://codeforces.com/contest/1923/problem/D)，通过预处理优化代价计算。
- **动态规划 + 线段树优化**：如 [CF EDU158 E. Collapsing Strings](https://codeforces.com/contest/1902/problem/E)，利用数据结构加速状态转移。

---

### **推荐洛谷题目**
1. **P1439 最长公共子序列**（LCS 转 LIS 问题）  
2. **P2782 友好城市**（二维偏序 LIS）  
3. **P2899 矩阵覆盖**（动态规划 + 区间代价统计）

---

### **可视化与算法演示**

**动画设计**：
1. **网格展示**：将排列绘制为像素网格，红色方块表示当前不动点，蓝色/绿色方块表示需左移/右移的数。
2. **动态高亮**：  
   - **黄色边框**：当前枚举的不动点 `i` 和上一个不动点 `j`。  
   - **计数器更新**：当 `a[j] > a[i]` 时，`sr` 计数器 +1 并显示在右侧面板。  
3. **复古像素风格**：  
   - 使用 8-bit 音效：每次计数器更新播放“滴”声，状态转移成功播放“叮”声。  
   - Canvas 绘制：用 16x16 像素块表示数字，背景音乐为《超级玛丽》风格循环曲。  
4. **自动演示模式**：  
   - 点击“Auto”按钮后，算法自动运行，每步间隔 500ms，动态显示 `dp[i]` 的更新过程。

---

### **核心代码实现（installb 题解）**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL INF = 0x3f3f3f3f3f3f3f3f;

LL n, l, r;
LL a[5005], dp[5005];

int main() {
    memset(dp, 0x3f, sizeof(dp));
    cin >> n >> r >> l;
    for (LL i = 1; i <= n; i++) { cin >> a[i]; a[i]++; }
    a[0] = 1; dp[0] = 0; a[n + 1] = n + 2;
    for (LL i = 1; i <= n + 1; i++) {
        LL sr = 0, sl = 0;
        for (LL j = i - 1; j >= 0; j--) {
            if (a[j] < a[i]) dp[i] = min(dp[i], dp[j] + r * sr + l * sl);
            if (a[j] > a[i]) sr++;
            if (a[j] < a[i]) sl++;
        }
    }
    cout << dp[n + 1] << endl;
    return 0;
}
```

---
处理用时：73.84秒
# 题目信息

# [ARC177D] Earthquakes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc177/tasks/arc177_d

AtCoder 街道は、平らな地面の上に伸びる数直線で表される道路です。この道路上に $ N $ 個の高さ $ H $ の電柱が立っています。電柱には $ 1,\ 2,\ \dots,\ N $ の番号が古い順に付けられています。電柱 $ i\ (1\ \leq\ i\ \leq\ N) $ は座標 $ X_i $ に地面と垂直に立っています。**電柱の最下部は地面に固定されています。**ここで、電柱は十分に細いものとして考えます。

AtCoder 街道ではこれから $ N $ 回の地震が発生します。$ i $ 回目 $ (1\ \leq\ i\ \leq\ N) $ の地震では、以下のことが起こります。

1. 電柱 $ i $ がまだ倒れていない場合、それが数直線における左または右の方向に、それぞれ $ \frac{1}{2} $ ずつの確率で倒れる。
2. 倒れようとしている電柱が、まだ倒れていない電柱に衝突した場合（電柱の最下部に衝突した場合を含む）、この電柱も同じ方向に倒れる。場合によってはこれが連鎖的に起こる。
 
ここで、1. で電柱がどちら方向に倒れるかは、他の電柱がどちら方向に倒れたかに関係しません。

以下の図は一回の地震での電柱の倒れ方の一例です。

![ ](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc177_d/2bf5e733d9f95c4209b1b2a6093b423312351960.png)

地震対策のため、$ t\ =\ 1,\ 2,\ \dots,\ N $ それぞれについて、ちょうど $ t $ 回目の地震ですべての電柱が倒れた状態になる確率を $ 2^N $ 倍した値を $ 998244353 $ で割った余りを求めてください。なお、出力すべき値は整数になることが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ H\ \leq\ 10^9 $
- $ 0\ \leq\ X_i\ \leq\ 10^9\ (1\ \leq\ i\ \leq\ N) $
- $ X_1,\ X_2,\ \dots,\ X_N $ はすべて異なる
- 入力はすべて整数
 
### Sample Explanation 1

以下の図は、この入力例における電柱の倒れ方の可能性を示しています。図中の分数はその状態になる確率を示しています。 !\[ \](https://img.atcoder.jp/arc177/1b1ec413ff3069cd13b19efd64b9c9d2.png) したがって、ちょうど $ 1,\ 2,\ 3 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ \frac{1}{2},\ \frac{1}{4},\ \frac{1}{4} $ です。これを $ 8 $ 倍した $ 4,\ 2,\ 2 $ を出力しましょう。

### Sample Explanation 2

以下の図は、この入力例における電柱の倒れ方の可能性を示しています。図中の分数はその状態になる確率を示しています。 !\[ \](https://img.atcoder.jp/arc177/f2ce4d20221071c814e204d8a2adc60d.png) したがって、ちょうど $ 1,\ 2,\ 3,\ 4 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ 0,\ \frac{1}{4},\ \frac{1}{4},\ \frac{1}{2} $ です。これを $ 16 $ 倍した $ 0,\ 4,\ 4,\ 8 $ を出力しましょう。

### Sample Explanation 3

ちょうど $ 1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ 0,\ \frac{1}{4},\ \frac{1}{8},\ \frac{3}{16},\ \frac{3}{32},\ \frac{7}{64},\ \frac{7}{64},\ \frac{1}{8} $ です。

### Sample Explanation 4

$ 37 $ 回目の地震までにすべての電柱が倒れることはありません。ちょうど $ 38,\ 39,\ 40 $ 回目の地震ですべての電柱が倒れた状態になる確率は、それぞれ $ \frac{3}{8},\ \frac{3}{8},\ \frac{1}{4} $ です。

## 样例 #1

### 输入

```
3 2

0 3 1```

### 输出

```
4 2 2```

## 样例 #2

### 输入

```
4 10

10 55 20 45```

### 输出

```
0 4 4 8```

## 样例 #3

### 输入

```
8 1

5 0 6 3 8 1 7 2```

### 输出

```
0 64 32 48 24 28 28 32```

## 样例 #4

### 输入

```
40 20

695 793 11 502 114 861 559 4 212 609 894 435 429 94 91 258 161 45 33 605 673 634 629 163 283 826 409 84 507 548 31 248 588 340 357 168 926 949 322 912```

### 输出

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41942627 41942627 360709869```

# AI分析结果



**唯一算法分类**：线段树与单调栈应用

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **分组处理**：将互相影响的电线杆划分为独立组，每组内部处理倒塌顺序。
2. **单调栈统计**：对每组内的每个电线杆，通过单调栈计算其左右两侧的「必须方向选择」次数，确定概率。
3. **线段树维护乘积**：用线段树高效合并各组的贡献，快速查询其他组的乘积。

#### **解决难点**
- **分组与独立性**：通过坐标排序和距离检查，将电线杆划分为互不影响的组。
- **方向约束计算**：利用单调栈统计每个电线杆左右两侧的最小值数目，确定必须固定的方向选择次数。
- **动态乘积维护**：通过线段树动态维护各组的概率贡献，支持快速查询和更新。

---

### **题解评分 (≥4星)**

1. **ma_niu_bi (5星)**
   - **亮点**：思路清晰，代码高效，利用单调栈和线段树实现线性对数复杂度。
   - **关键实现**：分组后用单调栈计算前后缀最小值数目，线段树维护全局乘积。

2. **Lavaloon (4星)**
   - **亮点**：通过维护非零乘积避免逆元问题，思路独特。
   - **关键优化**：仅维护非零位置的乘积，避免单点修改为0的不可逆问题。

3. **K8He (4星)**
   - **亮点**：递归分治处理倒塌方向，启发式合并时间-概率数组。
   - **特色**：将概率拆分为时间轴上的前缀和，通过堆优化合并过程。

---

### **最优思路或技巧提炼**

#### **关键步骤**
1. **分组与预处理**：
   - 按坐标排序，检查相邻电线杆距离是否≤H，划分独立组。
   - 每组内部按顺序处理，确保倒塌的连锁反应仅在组内传播。

2. **单调栈统计方向约束**：
   - 对每组中的每个电线杆i，计算其左侧的前缀最小值数目（`lf[i]`）和右侧的后缀最小值数目（`rg[i]`）。
   - 方向约束总次数为 `a = lf[i] + rg[i]`，概率为 `1/2^a`。

3. **线段树动态维护乘积**：
   - 每组贡献的概率独立，线段树维护所有组的乘积。
   - 当处理第i次地震时，查询其他组的乘积，乘以当前组的贡献。

#### **代码片段**
```cpp
// 单调栈计算前后缀最小值数目（ma_niu_bi题解核心逻辑）
void solve(int id) {
    stack<int> stk;
    for (int i = 1; i <= m; i++) {
        while (!stk.empty() && p[id][i] < stk.top()) stk.pop();
        stk.push(p[id][i]);
        k[i] = stk.size() - 1;
    }
    stack<int> sstk;
    for (int i = m; i >= 1; i--) {
        while (!sstk.empty() && p[id][i] < sstk.top()) sstk.pop();
        sstk.push(p[id][i]);
        k[i] += sstk.size() - 1;
    }
}

// 线段树维护乘积（ma_niu_bi题解核心逻辑）
struct segt {
    void add(int p, int id, int v) { /* 单点更新 */ }
    int query(int p, int l, int r) { /* 区间查询 */ }
};
```

---

### **可视化与算法演示**

#### **动画设计**
1. **分组可视化**：
   - 用不同颜色区分各组，动态显示每组内电线杆的位置和距离。
   - **高亮**：相邻距离≤H的线段标记为红色，触发分组逻辑。

2. **单调栈操作**：
   - 展示栈的压入和弹出过程，动态标注当前处理的最小值。
   - **高亮**：栈内元素颜色渐变，弹出时显示红色闪烁。

3. **线段树更新**：
   - 树形结构动态显示，更新节点时颜色渐变。
   - **交互**：点击节点查看当前贡献值，支持单步执行。

#### **复古像素风格**
- **Canvas 绘制**：用8位像素网格表示电线杆，倒塌方向用箭头动画。
- **音效**：
  - 单调栈弹出时播放“哔”声。
  - 线段树更新时播放“滴答”声。
- **自动演示**：模拟AI自动执行分组、单调栈计算、线段树更新。

---

### **同类型题推荐**
1. **洛谷 P1904 天际线问题**（线段树维护区间最值）
2. **洛谷 P5490 矩形面积并**（扫描线+线段树）
3. **洛谷 P3372 线段树模板**（动态区间乘积维护）

---

### **个人心得**
- **调试教训**：初始未正确处理分组边界，导致概率计算错误。
- **优化顿悟**：通过单调栈统计方向约束，避免暴力枚举所有可能的方向组合。

---
处理用时：72.82秒
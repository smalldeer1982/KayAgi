# 题目信息

# [ARC180D] Division into 3

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc180/tasks/arc180_d

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます． 以下の $ Q $ 個のクエリに答えてください．

- $ i $ 番目のクエリ: 整数 $ L_i,R_i $ が与えられる． $ B=(A_{L_i},A_{L_i+1},\cdots,A_{R_i}) $ に対して次の問題を解け．
  - $ B $ を $ 3 $ つの非空な連続部分列に分割する．各連続部分列についてその要素の最大値を求める．これらの値の総和としてあり得る最小値を求めよ． なお，問題の制約から $ B $ の長さは $ 3 $ 以上になるため，$ 3 $ つの非空な連続部分列に分割する方法は必ず $ 1 $ つ以上存在する．

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 250000 $
- $ 1\ \leq\ Q\ \leq\ 250000 $
- $ 1\ \leq\ A_i\ \leq\ 10^8 $
- $ 1\ \leq\ L_i\ \leq\ R_i\ \leq\ N $
- $ R_i-L_i\ \geq\ 2 $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ 1 $ つめのクエリについて説明します． $ B=(4,3,1,1,4,5,2) $ です． これを $ (4,3),(1,1),(4,5,2) $ と分解すると，各連続部分列の最大値は $ 4,1,5 $ となり，その総和は $ 10 $ になります． この総和が $ 10 $ より小さくなる方法は存在しないので，このクエリの答えは $ 10 $ になります．

## 样例 #1

### 输入

```
7 5

4 3 1 1 4 5 2

1 7

2 4

3 5

1 5

4 7```

### 输出

```
10

5

6

9

8```

## 样例 #2

### 输入

```
10 15

8 3 8 10 1 5 3 1 6 4

4 6

2 5

6 9

8 10

2 9

4 10

1 5

1 8

1 3

4 8

1 10

2 10

6 10

2 6

2 6```

### 输出

```
16

14

12

11

17

17

19

14

19

14

17

17

12

16

16```

# AI分析结果



## 算法分类
离线处理、扫描线、单调栈、线段树

---

## 题解思路与核心难点

### 核心思路
1. **分情况讨论**：每个查询区间的最大值必出现在三个子区间之一，分三种情况处理。
2. **中间子区间处理**：若最大值在中间子区间，则最优解为左右端点值 + 最大值。
3. **左右子区间处理**：若最大值在左/右子区间，则中间子区间长度取1，使用离线扫描线、单调栈维护后缀最大值，线段树查询最小值。

### 解决难点
- **高效维护候选值**：当最大值在左/右子区间时，需快速计算分割点的最小值。通过单调栈维护后缀最大值变化，线段树动态更新区间最小值。
- **对称处理**：将数组翻转后复用相同逻辑处理右子区间的情况，减少代码冗余。

---

## 题解评分 (≥4星)

1. **小超手123（5星）**  
   - 结构清晰，逻辑严谨，完整实现离线处理与线段树维护。
   - 代码注释详细，适合快速理解核心逻辑。

2. **Hadtsti（4星）**  
   - 代码简洁，对称处理巧妙，复用相同函数处理左右情况。
   - 使用ST表快速查询区间最大值，结合单调栈高效维护后缀。

3. **born_to_sun（4星）**  
   - 提供树上倍增的独特思路，拓展不同解法可能性。
   - 实现细节详细，适合进阶学习。

---

## 最优思路提炼

1. **分情况讨论最大值位置**：中间、左、右三种情况分别处理。
2. **中间情况直接计算**：左右端点+最大值。
3. **左右情况离线扫描**：  
   - 单调栈维护后缀最大值变化，动态更新线段树。
   - 线段树维护每个位置i的候选值 `a[i] + max(a[j])`（j > i）。
4. **对称翻转处理**：将数组翻转后复用左情况代码处理右情况。

---

## 类似题目
- **CF526F Pudding Monsters**：利用单调栈维护区间极值。
- **LeetCode 2104. Sum of Subarray Ranges**：区间极值差求和，类似极值处理。
- **洛谷 P1972 [SDOI2009] HH的项链**：离线扫描线与线段树结合。

---

## 可视化设计

### 动画演示
1. **初始状态**：显示原数组和查询区间 `[L, R]`，高亮区间最大值位置。
2. **分情况演示**：  
   - **中间情况**：将左右端点标红，中间子区间标蓝，显示总和公式。
   - **左/右情况**：动态展示右端点扫描过程，单调栈弹出旧值，线段树更新区间。
3. **线段树更新**：颜色标记被修改的区间节点，显示当前候选值的最小值。
4. **音效提示**：关键操作（栈弹出、线段树更新、查询完成）触发不同音效。

### 复古像素风格
- **颜色方案**：最大值用红色像素块，查询区间用绿色边框，线段树节点用蓝色网格。
- **音效设计**：8-bit音效，如栈弹出时“哔”声，查询完成时“叮”声。
- **自动演示**：按步执行算法，用户可暂停/调整速度。

---

## 代码片段（核心逻辑）

```cpp
// 离线处理右端点扫描
void Sol1() {
    t1.clear();
    stack<int> stk;
    for (int i = 1; i <= n; i++) {
        // 维护单调栈
        while (!stk.empty() && a[i] >= a[stk.top()]) {
            int top = stk.top();
            stk.pop();
            int prev = stk.empty() ? 0 : stk.top();
            t1.update(1, 1, n, prev + 1, top, a[i] - a[top]); // 更新线段树区间
        }
        stk.push(i);
        if (i > 1) {
            t1.update(1, 1, n, i - 1, i - 1, a[i - 1] + a[i]); // 插入新候选值
        }
        // 处理当前右端点的查询
        for (auto q : queries[i]) {
            int L = q.first, ans_id = q.second;
            int pos = get_max_pos(L, i); // 查询最大值位置
            int min_val = t1.query(1, 1, n, pos + 1, i - 1);
            ans[ans_id] = min(ans[ans_id], a[pos] + min_val);
        }
    }
}
```

---

## 总结
通过分情况讨论和高效数据结构，结合离线处理与对称翻转技巧，实现O((n+q) log n)的最优解法。可视化设计可帮助理解单调栈与线段树的联动更新机制。

---
处理用时：71.67秒
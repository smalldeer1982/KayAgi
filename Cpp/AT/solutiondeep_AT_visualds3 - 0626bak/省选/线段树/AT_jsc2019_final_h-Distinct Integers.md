# 题目信息

# Distinct Integers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jsc2019-final/tasks/jsc2019_final_h

長さ $ N $ の数列 $ A_0,A_1,\cdots,A_{N-1} $ があります。 $ Q $ 個のクエリに答えてください。 具体的には、クエリ $ i $ ($ 0\ \leq\ i\ \leq\ Q-1 $) では整数 $ T_i,X_i,Y_i $ が与えられるので、以下のことをしてください。

- $ T_i=0 $ の時: $ A_{X_i} $ を $ Y_i $ で置き換える。
- $ T_i=1 $ の時: 次の条件をみたす整数の組 $ l,r $ ($ X_i\ \leq\ l\ <\ r\ \leq\ Y_i $) の個数を答える。
  - $ A_{l},A_{l+1},\cdots,A_{r-1} $ が全て異なる。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 5\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ N-1 $
- $ 0\ \leq\ T_i\ \leq\ 1 $
- $ 0\ \leq\ X_i\ \leq\ N-1,\ 0\ \leq\ Y_i\ \leq\ N-1 $ ($ T_i=0 $)
- $ 0\ \leq\ X_i\ <\ Y_i\ \leq\ N $ ($ T_i=1 $)
- $ T_i=1 $ をみたす $ i $ が少なくとも $ 1 $ つ存在する。
- 入力される値はすべて整数である。

### Sample Explanation 1

例としてクエリ $ 4 $ を考えます。 このクエリが与えられた時、$ A=(0,1,4,3,4) $ です。 また、条件をみたす $ l,r $ の組は、$ (l,r)=(2,3),(2,4),(3,4),(3,5),(4,5) $ の $ 5 $ 個です。

## 样例 #1

### 输入

```
5 5

0 1 2 1 4

1 0 4

0 3 3

1 0 5

0 2 4

1 2 5```

### 输出

```
8

15

5```

## 样例 #2

### 输入

```
30 30

14 24 18 7 20 10 0 27 27 29 27 20 23 29 27 0 11 10 0 12 19 7 21 12 11 7 27 11 21 0

1 6 21

1 27 29

0 23 21

1 1 5

0 3 24

1 3 6

1 9 16

1 16 26

1 0 11

0 29 27

0 25 29

0 4 24

1 10 23

1 18 24

0 22 14

0 13 10

1 2 29

0 7 12

0 27 14

1 18 20

0 23 7

0 15 20

1 1 24

0 24 7

0 24 20

1 7 16

0 15 27

0 23 10

1 11 13

1 4 8```

### 输出

```
53

3

10

6

23

34

31

57

16

116

3

94

28

3

10```

# AI分析结果



## **唯一算法分类**
线段树（单侧递归）

---

## **题解思路与算法要点**

### **核心思路**
1. **问题转化**：统计区间内所有元素的前一次出现位置（`pre[i]`），将问题转化为求区间前缀最大值之和。
2. **公式推导**：答案可表示为 $\frac{(L+R)(R-L+1)}{2} - \sum_{i=L}^R \max_{j \le i} pre[j]$，需高效计算前缀最大值之和。
3. **线段树优化**：使用单侧递归线段树（类似楼房重建）维护区间最大值和前缀最大值之和。

### **关键步骤**
- **维护 `pre[i]`**：使用 `set` 跟踪每个值的出现位置，修改时更新前驱和后继的 `pre` 值。
- **线段树设计**：
  - 每个节点存储区间最大值 `maxx` 和前缀和 `sum`。
  - `pushup` 时，若左子树的最大值足够大，则右子树的贡献由其递归计算。
- **查询拆分**：将查询区间拆分为多个线段树节点，合并时处理 `max` 的传递。

### **解决难点**
- **动态更新 `pre[i]`**：修改操作需同步更新当前元素及其前后元素的 `pre` 值，时间复杂度为 $O(\log n)$。
- **前缀最大值合并**：通过递归合并左右子树的贡献，确保每次查询复杂度为 $O(\log^2 n)$。

---

## **题解评分**
### ⭐⭐⭐⭐ UniGravity 的题解
- **亮点**：思路清晰，代码结构简洁，详细解释线段树合并逻辑。
- **代码可读性**：良好，关键函数（`pushup`、`query`）注释明确。
- **优化程度**：单侧递归实现高效，时间复杂度 $O(n \log^2 n)$。

### ⭐⭐⭐⭐ suzhikz 的题解
- **亮点**：提供完整代码和调试思路，拆分查询区间的方法实用。
- **代码可读性**：中等，部分变量命名简略，但逻辑连贯。
- **实践性**：适合理解线段树拆分与递归合并的实际应用。

---

## **最优思路提炼**
1. **前缀最大值维护**：利用 `set` 快速更新 `pre[i]`，保证修改操作的高效。
2. **单侧递归线段树**：在 `pushup` 时根据左子树最大值决定右子树贡献，合并复杂度 $O(\log n)$。
3. **查询拆分与合并**：将查询区间拆分为 $O(\log n)$ 个线段树节点，逐个处理并累加结果。

---

## **同类型题与算法套路**
- **相似问题**：楼房重建（维护前缀最大值）、区间不同数统计（维护 `last` 数组）。
- **通用解法**：单侧递归线段树适用于需要动态合并区间信息的统计问题，如区间单调栈、历史最大值等。

---

## **推荐题目**
1. **P4198 楼房重建**：单侧递归线段树的经典应用。
2. **P1972 HH的项链**：统计区间不同数，需维护 `last` 数组。
3. **CF803G Periodic RMQ Problem**：动态区间最值维护与合并。

---

## **个人心得摘录**
- **调试教训**：修改操作需同时更新当前元素的前驱和后继的 `pre`，漏掉任一均会导致错误。
- **顿悟点**：将区间贡献拆分为 $\sum i - \sum \max$，大幅简化问题。

---

## **可视化与算法演示**
### **核心逻辑动画设计**
- **线段树节点高亮**：展示查询区间如何拆分为多个线段树节点。
- **递归过程跟踪**：用不同颜色标记当前递归路径（左子树蓝色，右子树红色）。
- **贡献计算**：动态显示 `pushup` 中右子树如何根据左子树最大值计算贡献。

### **复古像素风格实现**
- **Canvas 绘制**：线段树节点以网格形式排列，每个节点显示 `max` 和 `sum`。
- **音效设计**：
  - **递归进入子树**：播放 8-bit "beep" 音效。
  - **查询完成**：播放胜利音效（类似《超级马里奥》过关）。
- **自动演示模式**：按层展开线段树，逐步显示合并过程，支持暂停/继续。

### **交互控制**
- **速度调节**：滑动条控制动画速度（0.5x~2x）。
- **单步执行**：按空格键单步执行递归合并逻辑。

---

## **代码片段（关键逻辑）**
```cpp
// 单侧递归计算右子树贡献
ll push2(int x, int l, int r, ll ma) {
    if (l == r) return max(ma, maxx[x]);
    int mid = (l + r) >> 1;
    if (maxx[x << 1] < ma)
        return ma * (mid - l + 1) + push2(x << 1 | 1, mid + 1, r, ma);
    else
        return push2(x << 1, l, mid, ma) + (tree[x] - tree[x << 1]);
}

// 线段树合并
void push_up(int x, int l, int r) {
    maxx[x] = max(maxx[x << 1], maxx[x << 1 | 1]);
    tree[x] = tree[x << 1] + push2(x << 1 | 1, mid + 1, r, maxx[x << 1]);
}
```

---

## **总结**
通过维护前缀最大值和单侧递归线段树，将复杂区间统计问题转化为高效的可合并操作，结合 `set` 实现动态更新，最终在 $O(n \log^2 n)$ 时间复杂度内解决大规模数据问题。

---
处理用时：73.52秒
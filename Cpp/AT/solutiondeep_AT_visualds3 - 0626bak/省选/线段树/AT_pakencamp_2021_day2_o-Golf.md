# 题目信息

# Golf

## 题目描述

给定一个字符串 $S$。定义子串 $S[i:j]$ 表示从字符串 $S$ 的第 $i$ 个字符到第 $j$ 个字符组成的子串。

如果子串 $T$ 满足以下条件，则称其为一个「好字符串」：

- 长度在 1 到 $|S|$ 之间，即 $1 \leq |T| \leq |S|$
- 恰好存在唯一一个整数 $i$，使得 $S[i:i+|T|-1]$ 与 $T$ 相等

例如，若字符串 $S$ 为 `abcbabc`，那么 `cb`、`abcb` 和 `abcbabc` 都是「好字符串」，但 `abc` 和 `zyx` 不是。

接下来有 $Q$ 个查询。对于第 $i$ 个查询，给出两个整数 $L_i$ 和 $R_i$，满足 $1 \leq L_i \leq R_i \leq |S|$，然后解决以下问题：

- 寻找两个整数 $l$ 和 $r$，使得 $1 \leq l \leq L_i$ 且 $R_i \leq r \leq |S|$，并使得子串 $S[l:r]$ 是一个「好字符串」。然后计算 $r-l+1$ 的最小可能值。

## 说明/提示

- 字符串 $S$ 仅由小写英文字母组成。
- $1 \leq |S| \leq 200,000$
- $1 \leq Q \leq 200,000$
- 对于每个 $i$，满足 $1 \leq L_i \leq R_i \leq |S|$

### 样例解释

对于第一个查询，我们可以取 $l=2, r=4$，此时 $r-l+1=3$，这是最小值。注意 `bc` 不是「好字符串」，所以不能取 $l=2, r=3$。在第二个查询中，取 $l=2, r=5$，得到 $r-l+1=4$，是最小值。在第三个查询中，我们取 $l=1, r=7$，则 $r-l+1=7$，这是最小值。值得注意的是，字符串 $S$ 本身是一个「好字符串」。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
abcbabc

5

2 3

2 5

1 7

4 4

6 6```

### 输出

```
3

4

7

2

3```

## 样例 #2

### 输入

```
yyxxzzyyxx

5

3 3

1 1

10 10

5 5

7 7```

### 输出

```
3

5

5

2

2```

## 样例 #3

### 输入

```
qprrrrrpprqrrppq

20

7 8

6 8

4 7

7 12

6 7

5 5

6 8

4 6

4 4

2 3

7 11

8 9

6 7

11 12

11 15

5 6

4 5

13 13

9 13

5 7```

### 输出

```
4

4

5

6

4

4

4

5

3

3

5

3

4

2

5

4

4

3

5

4```

# AI分析结果



---

**唯一算法分类**  
后缀自动机（Suffix Automaton, SAM）

---

### **综合分析与结论**

#### **核心思路与难点**
1. **问题转化**：将“好字符串”条件转化为子串的唯一出现性，利用后缀自动机（SAM）高效统计子串出现次数。
2. **预处理关键值**：对每个位置 `i`，预处理其最大左端点 `l_i`，使得子串 `S[l_i:i]` 唯一出现。通过 SAM 的 `endpos` 集合大小和 `parent` 树结构实现。
3. **离线查询优化**：将查询按右端点从大到小排序，结合树状数组动态维护最小值，实现高效响应。

#### **算法流程**
1. **SAM 构建**：通过插入字符构建 SAM，记录每个节点的 `len`（最大长度）和 `endpos` 集合大小 `sz`。
2. **预处理 `l_i`**：沿 `parent` 树找到第一个 `sz ≥ 2` 的祖先节点 `top`，计算 `l_i = i - len[top]`。
3. **离线处理查询**：对每个右端点 `i`，用树状数组维护两种最小值，处理所有以 `i` 为右端点的查询。

#### **可视化设计**
- **SAM 节点动态绘制**：以像素方块表示 SAM 节点，颜色区分 `sz` 值（如蓝色为 `sz=1`，红色为 `sz≥2`）。
- **树状数组更新动画**：插入 `l_i` 时，树状数组的对应位置高亮，并显示当前最小值。
- **音效与像素反馈**：插入操作触发短音效，查询完成时播放成功音效，背景音乐循环 8-bit 风格旋律。

---

### **题解评分 (4.5⭐️)**  
**关键亮点**  
- **SAM 的精准应用**：利用 SAM 高效处理子串唯一性，时间复杂度严格线性。
- **离线查询优化**：通过排序和树状数组将查询复杂度降至 `O(Q log N)`。
- **代码结构清晰**：预处理、排序、数据结构操作分离，逻辑层次分明。

---

### **最优思路与技巧提炼**
1. **SAM 的 `endpos` 与 `parent` 树**  
   - 利用 `endpos` 集合大小 `sz` 快速判断子串出现次数。
   - 沿 `parent` 树上溯，找到第一个 `sz ≥ 2` 的祖先，确定子串唯一性的临界长度。
2. **离线处理与扫描线**  
   - 将查询按右端点逆序处理，动态维护树状数组，避免重复计算。
3. **双树状数组优化**  
   - 分别维护前缀最小和后缀最小，适应不同查询条件（`l ≤ L_i` 和 `r ≥ R_i`）。

---

### **同类型题与算法套路**
- **通用解法**：字符串唯一子串统计问题可优先考虑 SAM；离线区间极值问题常用扫描线+树状数组/线段树。
- **类似题目**  
  1. **洛谷 P3804**：【模板】后缀自动机 (SAM)  
  2. **洛谷 P3975**：[ZJOI2015] 诸神眷顾的幻想乡（SAM 扩展应用）  
  3. **洛谷 P1972**：[SDOI2009] HH的项链（离线处理+树状数组）

---

### **代码核心片段**
```cpp
// SAM 构建与预处理 l_i
for (int i = 1, p = 1; i <= n; ++i) {
    insend(s[i] - 'a', p); // 插入字符到 SAM
    sz[p] = 1;             // 标记当前节点为 endpos 出现一次
    ed[i] = p;             // 记录前缀 i 对应的 SAM 节点
}

// 预处理每个节点的 top 祖先
for (int i = tot; i >= 1; --i) {
    int p = id[i];
    top[p] = (sz[p] >= 2 ? p : top[t[p].fa]);
}

// 处理查询并维护树状数组
for (int i = n, j = 1; i >= 1; --i) {
    if (sz[ed[i]] == 1) {
        int l = i - t[top[ed[i]]].len;
        add1(l, i - l + 1);  // 更新前缀最小树状数组
        add2(l, i + 1);      // 更新后缀最小树状数组
    }
    // 处理所有以 i 为右端点的查询
    while (j <= q && a[j].r == i) {
        ans[a[j].i] = min(query1(a[j].l), query2(a[j].l) - a[j].l);
        j++;
    }
}
```

---

### **复古游戏化动画设计**
- **8-bit 风格 SAM 节点**：每个节点显示为 16x16 像素方块，`sz=1` 为绿色，`sz≥2` 为红色，`top` 路径用黄色连线。
- **树状数组更新效果**：插入操作时，对应位置闪烁白色边框，并显示当前值。
- **音效设计**：插入触发 "beep" 音，查询完成播放 "victory" 音效，背景音乐为 8-bit 循环旋律。
- **自动演示模式**：按右端点从右向左逐步处理，动态显示 SAM 节点状态和树状数组更新。

---

**可视化交互示例**  
```javascript
// 伪代码：Canvas 绘制 SAM 节点
function drawSAM() {
    for (let node of SAM.nodes) {
        ctx.fillStyle = node.sz === 1 ? '#00FF00' : '#FF0000';
        ctx.fillRect(node.x * 20, node.y * 20, 16, 16);
        if (node.parent) {
            ctx.strokeStyle = '#FFFF00';
            drawLine(node, node.parent);
        }
    }
}
```

---
处理用时：84.54秒
# 题目信息

# [ARC163D] Sum of SCC

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc163/tasks/arc163_d

以下の条件を全て満たす頂点に $ 1 $ から $ N $ までの番号がついた $ N $ 頂点の有向グラフ $ G $ を考えます。

- $ G $ はトーナメントである。すなわち、$ G $ に多重辺や自己ループはなく、$ G $ のどの $ 2 $ 頂点 $ u,v $ に対しても、$ u\ \rightarrow\ v $ 辺または $ v\ \rightarrow\ u $ 辺のうちちょうど片方が存在する。
- $ G $ の辺のうち、頂点番号が小さい方から大きい方へ向けられた辺はちょうど $ M $ 本存在する。
 
そのような有向グラフ $ G $ 全てに対する強連結成分の個数の総和を $ 998244353 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 30 $
- $ 0\ \le\ M\ \le\ \frac{N(N-1)}{2} $
 
### Sample Explanation 1

条件を満たす有向グラフ $ G $ は以下の $ 3 $ 個です。それぞれ強連結成分の個数は $ 3,1,3 $ であるため答えは $ 7 $ です。 ![](https://img.atcoder.jp/arc163/ee8acabc2a7d48164b3cc568e88f0840.png)

## 样例 #1

### 输入

```
3 1```

### 输出

```
7```

## 样例 #2

### 输入

```
6 2```

### 输出

```
300```

## 样例 #3

### 输入

```
25 156```

### 输出

```
902739687```

# AI分析结果



### 算法分类
动态规划

### 题解思路与核心难点
**核心思路**：  
竞赛图的强连通分量（SCC）数目等价于将顶点划分为两个集合 $A$ 和 $B$，满足所有 $A$ 到 $B$ 的边存在的方案数减一。通过动态规划（DP）统计满足条件的划分方案数，最终答案为此方案数总和减去图的总数。

**核心难点**：  
1. **状态定义**：需要表示当前顶点数、集合大小、满足条件的边数。
2. **转移逻辑**：新顶点加入 $A$ 或 $B$ 时，需计算新增边对状态的贡献。
3. **组合数优化**：利用预计算的组合数加速状态转移。

**关键步骤**：  
1. **状态定义**：`dp[i][j][k]` 表示处理前 `i` 个顶点，$A$ 的大小为 `j`，已有 `k` 条从小到大的边。
2. **状态转移**：
   - **加入 $A$**：原 $A$ 中顶点与新顶点的边可任意方向，贡献边数为 $x$（组合数 $\binom{j}{x}$）。
   - **加入 $B$**：原 $A$ 中顶点必须指向新顶点，贡献边数为 $j$，同时 $B$ 内部边的贡献为 $x$（组合数 $\binom{i-j}{x}$）。
3. **最终统计**：累加所有可能的划分方案，再减去图的总数（即 $\binom{\frac{n(n-1)}{2}}{m}$）。

### 最优思路与技巧
- **动态规划状态压缩**：通过组合数预计算和状态转移优化，将时间复杂度控制在 $O(n^3m)$。
- **问题转化**：将 SCC 计数转化为划分方案数，简化问题复杂度。
- **组合数预处理**：提前计算组合数，避免重复计算。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 32, mod = 998244353;
int n, m, C[N][N], dp[N][N][N * N];

int main() {
    cin >> n >> m;
    // 预处理组合数
    C[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
    }
    // 初始化 DP 状态
    dp[0][0][0] = 1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            for (int k = 0; k <= m; k++) {
                if (!dp[i][j][k]) continue;
                // 加入 A 集合
                for (int x = 0; x <= j; x++)
                    (dp[i+1][j+1][k + x] += 1LL * dp[i][j][k] * C[j][x] % mod) %= mod;
                // 加入 B 集合
                for (int x = 0; x <= (i - j); x++)
                    (dp[i+1][j][k + j + x] += 1LL * dp[i][j][k] * C[i-j][x] % mod) %= mod;
            }
        }
    }
    // 计算答案
    int ans = 0;
    for (int i = 0; i < n; i++)
        (ans += dp[n][i][m]) %= mod;
    cout << ans << endl;
    return 0;
}
```

### 可视化算法演示
**动画设计**：  
1. **网格展示**：用网格表示顶点，不同颜色区分 $A$ 和 $B$。
2. **边高亮**：动态显示新增边对状态的影响。
3. **步进控制**：支持单步执行，观察状态转移过程。

**复古像素风格**：  
- **颜色方案**：$A$ 用蓝色，$B$ 用红色，边用黄色像素点。
- **音效**：每次转移播放不同音调，成功时播放胜利音效。

### 相似题目
1. [P5782 和平委员会](https://www.luogu.com.cn/problem/P5782)  
2. [P2746 [USACO5.3] 校园网](https://www.luogu.com.cn/problem/P2746)  
3. [P2863 [USACO06JAN] The Cow Prom](https://www.luogu.com.cn/problem/P2863)

---
处理用时：381.80秒
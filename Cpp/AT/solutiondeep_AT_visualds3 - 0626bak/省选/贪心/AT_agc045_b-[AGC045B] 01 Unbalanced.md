# 题目信息

# [AGC045B] 01 Unbalanced

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc045/tasks/agc045_b

文字列 $ S $ が与えられます． $ S $ の各文字は，`0`,`1`,`?` のいずれかです．

$ S $ に含まれる全ての `?` を `0` か `1` に変えて（`?` ごとに変換後の文字を選択できます），文字列 $ S' $ を作ることを考えます． ここで，$ S' $ のアンバランス度を，次のように定義します．

- $ S' $ のアンバランス度 $ =\ \max\ \{\ S' $ の $ l $ 文字目から $ r $ 文字目までに含まれる `0` の個数と `1` の個数の差の絶対値 $ :\ 1\ \leq\ l\ \leq\ r\ \leq\ |S|\} $

$ S' $ のアンバランス度としてありうる最小の値を求めてください．

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 10^6 $
- $ S $ の各文字は `0`,`1`,`?` のいずれかである．

### Sample Explanation 1

$ S'= $`010` とすれば，アンバランス度は $ 1 $ になり，これが最小です．

## 样例 #1

### 输入

```
0??```

### 输出

```
1```

## 样例 #2

### 输入

```
0??0```

### 输出

```
2```

## 样例 #3

### 输入

```
??00????0??0????0?0??00??1???11?1?1???1?11?111???1```

### 输出

```
4```

# AI分析结果



### 综合分析与结论  
**题目核心**：将字符串中的 `?` 替换为 `0` 或 `1`，最小化前缀和极差（最大值与最小值的差）。  
**关键转化**：将 `0` 视为 `-1`，`1` 视为 `+1`，问题转化为求前缀和极差的最小值。  
**贪心策略**：  
1. **初始设定**：将所有 `?` 设为 `0`（使初始最大值尽可能小）。  
2. **动态调整**：从左到右扫描，若将当前 `?` 改为 `1` 后，后续前缀和仍不超过限制，则修改。  
3. **候选范围**：仅需检查初始最大值和其 `+1` 的情况（极差最优性证明）。  

**难点**：如何高效确定调整后的极差范围，避免暴力枚举。通过预处理后缀信息（如后缀最大可能前缀和）快速判断调整的可行性。  

**可视化设计**：  
- **折线图**：展示前缀和随字符位置的变化，高亮当前处理的 `?`。  
- **颜色标记**：红色表示 `?` 被改为 `1`，蓝色保持 `0`，黄色表示极差范围。  
- **动态更新**：步进展示每个 `?` 的调整决策，实时显示极差变化。  
- **复古风格**：8-bit 像素动画，音效提示调整操作（如“滴”声表示改为 `1`，“嘟”声表示保持 `0`）。  

---

### 题解清单（≥4星）  
1. **Tokai__Teio（4.5星）**  
   - **亮点**：代码简洁，预处理后缀最大值，详细推导贪心的正确性。  
   - **心得**：通过观察极差随限制变化的单调性，减少候选范围。  

2. **Vasily0959（4星）**  
   - **亮点**：经典套路总结（前缀和、贪心调整、打表找规律），代码高效。  
   - **心得**：“少证一点，你在打比赛”体现实战思维。  

3. **未来姚班zyl（4星）**  
   - **亮点**：思路清晰，代码简洁，直接枚举关键候选值。  

---

### 最优思路提炼  
1. **前缀和极差模型**：将字符权值转化为 `±1`，极差即最大前缀和与最小前缀和之差。  
2. **贪心调整策略**：  
   - 预处理每个位置的后缀最大可能前缀和。  
   - 从左到右扫描，若改为 `1` 不破坏后续限制，则调整。  
3. **候选值优化**：极差随限制增加的单调性保证只需检查两个候选值。  

---

### 同类型题与算法套路  
**常见场景**：  
- 最小化区间极差（如温度控制、资源分配）。  
- 动态调整字符/数值以满足约束（如括号匹配、平衡字符串）。  

**推荐题目**：  
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
2. [CF1370D. Odd-Even Subsequence](https://codeforces.com/contest/1370/problem/D)  
3. [AGC044B Joker](https://atcoder.jp/contests/agc044/tasks/agc044_b)  

---

### 代码片段（核心贪心逻辑）  
```cpp
int calc(int limit) {
    int cnt = 0, mn = 0;
    for (int i = 1; i <= len; ++i) {
        if (a[i] == '0') cnt--;
        else if (a[i] == '1') cnt++;
        else {
            // 关键判断：改为1是否会导致后续超出limit
            if (cnt + sum[i + 1] + 1 <= limit) cnt++;
            else cnt--;
        }
        mn = min(mn, cnt);
    }
    return limit - mn; // 极差=当前限制-最小前缀和
}
```

---

### 复古游戏化动画设计  
1. **像素风格**：  
   - 字符块用 8x8 像素表示，`0` 蓝色，`1` 红色，`?` 黄色。  
   - 前缀和折线图在 Canvas 上绘制，绿色线段表示当前极差。  
2. **音效设计**：  
   - `?` 改为 `1`：播放上升音调（`beep_up.wav`）。  
   - 保持 `0`：播放下降音调（`beep_down.wav`）。  
3. **自动演示**：  
   - AI 自动调整 `?`，用红色高亮当前决策位置。  
   - 每步延迟 500ms，可暂停/加速。  
4. **积分系统**：  
   - 每正确调整一个 `?` 得 10 分，极差每减少 1 得 50 分。  

---

### 个人心得摘录  
- **Tokai__Teio**：通过观察极差随限制的单调性，避免复杂二分，直接贪心调整。  
- **Vasily0959**：“少证一点，你在打比赛”强调实战中快速验证思路的重要性。  
- **wosile**：提交代码后发现 WA，通过检查边界情况（如 `?1`）修正逻辑。  

---

### 可视化代码片段（JS 伪代码）  
```javascript
function drawPixel(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 8, y * 8, 8, 8);
}

function animateStep(i) {
    if (s[i] === '?') {
        // 高亮当前处理的字符
        drawPixel(i, 0, '#FFFF00');
        // 根据决策改变颜色
        if (canChangeTo1(i)) {
            s[i] = '1';
            playSound('beep_up');
            drawPixel(i, 0, '#FF0000');
        } else {
            playSound('beep_down');
        }
    }
    updatePrefixSumChart();
}
```

---
处理用时：78.73秒
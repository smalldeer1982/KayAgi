# 题目信息

# [ARC169D] Add to Make a Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc169/tasks/arc169_d

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます． $ A $ の各要素は $ 0 $ 以上 $ N-1 $ 以下の整数です．

あなたは以下の操作を $ 0 $ 回以上行うことができます．

- $ A $ の中からちょうど $ M $ 個の要素を選ぶ． そして，選んだ要素の値をそれぞれ $ 1 $ 増加させる． 増加させたあとに値が $ N $ になっている要素があれば，その値を $ 0 $ に変更する．
 
あなたの目標は $ A $ を $ (0,1,\cdots,N-1) $ の順列にすることです． 目標が達成可能か判定し，可能ならば必要な最小の操作回数を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 250000 $
- $ 1\ \leq\ M\ \leq\ N-1 $
- $ 0\ \leq\ A_i\ \leq\ N-1 $
- 入力される値はすべて整数．
 
### Sample Explanation 1

以下のように操作すると $ 2 $ 回の操作で目標を達成できます． - 初期状態: $ A=(0,1,1) $ - $ 1 $ 回目の操作: $ A_1,A_2 $ を選んで操作を行い，$ A=(1,2,1) $ になる． - $ 2 $ 回目の操作: $ A_2,A_3 $ を選んで操作を行い，$ A=(1,0,2) $ になる． $ 2 $ 回未満の操作で目標を達成することはできないため，答えは $ 2 $ になります．

## 样例 #1

### 输入

```
3 2

0 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2

0 4 2 3 1```

### 输出

```
0```

## 样例 #3

### 输入

```
4 2

0 0 1 2```

### 输出

```
-1```

## 样例 #4

### 输入

```
20 15

5 14 18 0 8 5 0 10 6 5 11 2 10 10 17 9 8 14 4 4```

### 输出

```
10```

# AI分析结果



### 综合分析与结论

**题目核心**：构造连续递增的 B 序列（形如 `x, x+1, ..., x+N-1`），通过调整法证明其最优性，并利用数学方法求解满足条件的 `x`。

**贪心策略**：将排序后的 A 数组对应连续的 B 序列，确保增量均匀，满足模条件与操作次数最小。

**难点与解决**：
1. **连续序列构造**：通过调整法证明，任何最优解可转化为连续序列。
2. **数学条件处理**：利用同余方程确定 `x` 的下界，并结合最大增量与总和的关系调整 `x`。
3. **复杂度优化**：通过数学推导避免暴力枚举，使用 GCD 和 LCM 确定调整步长。

### 题解清单（≥4星）

1. **DaiRuiChen007（5星）**  
   - **亮点**：代码简洁高效，直接数学推导 `x` 的下界与调整步长，逻辑清晰。
   - **核心思想**：排序后计算 `x`，处理模条件与增量约束，快速调整 `x`。

2. **Aigony（4星）**  
   - **亮点**：调整法证明连续序列的最优性，代码易读。
   - **核心思想**：通过枚举 `x` 的余数满足模条件，逐步验证增量约束。

3. **Wuyanru（4星）**  
   - **亮点**：详细证明贪心正确性，数学推导完整。
   - **核心思想**：构造 `x` 的上下界，利用同余方程和 GCD 求解。

### 最优思路提炼

1. **连续序列构造**：将 B 构造为连续递增序列，确保增量均匀。
2. **x 的下界计算**：`x ≥ max(A_i - i + 1)`，满足每个元素至少增加到目标值。
3. **模条件处理**：`n*x + Σ(i-1 - A_i) ≡ 0 (mod M)`，解同余方程确定 `x` 的可能值。
4. **增量约束调整**：若最大增量超过 `S/M`，按步长 `m/gcd(n,m)` 增加 `x`，直到满足条件。

### 同类型题与算法套路

- **常见场景**：构造连续序列、模运算约束、调整法优化。
- **推荐题目**：
  - [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)（贪心构造连续块）
  - [P2118 比例简化](https://www.luogu.com.cn/problem/P2118)（模条件与比例约束）
  - [CF1391D 505](https://codeforces.com/problemset/problem/1391/D)（矩阵构造满足模条件）。

### 代码片段（DaiRuiChen007）

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2.5e5+5;
int n,m,a[MAXN],g;
ll sum,k=0;
signed main() {
    scanf("%d%d",&n,&m),g=__gcd(n,m);
    for(int i=0;i<n;++i) scanf("%d",&a[i]),sum+=a[i];
    if((1ll*n*(n-1)/2-sum)%g) return puts("-1"),0;
    sort(a,a+n);
    for(int i=0;i<n;++i) k=max(k,(ll)a[i]-i);
    sum=(2*k+n-1)*n/2-sum;
    while(sum%m) ++k,sum+=n;
    ll mx=0,d=m/__gcd(n,m),c=n*d/m;
    for(int i=0;i<n;++i) mx=max(mx,k+i-a[i]);
    if(mx>sum/m) {
        ll cur=(mx-sum/m-1)/(c-d)+1;
        printf("%lld\n",sum/m+cur*c);
    } else printf("%lld\n",sum/m);
    return 0;
}
```

**核心实现**：
1. 排序数组并计算 `x` 下界。
2. 调整 `x` 直到 `sum` 满足模条件。
3. 检查最大增量，必要时按步长调整 `x`。

### 可视化设计（贪心过程）

**动画方案**：
1. **排序展示**：将原数组 A 排序后显示，高亮每个元素与目标序列的差值。
2. **x 调整**：动态显示 `x` 增加时，总和 `S` 与最大增量的变化。
3. **条件验证**：用颜色标记模条件是否满足（绿色满足，红色不满足）。
4. **步进调整**：点击按钮逐步增加 `x`，显示每次调整后的状态。

**复古像素风格**：
- **Canvas 绘制**：数组元素用像素方块表示，当前 `x` 值用闪烁边框标记。
- **音效**：调整 `x` 时播放电子音效，满足条件时播放胜利音效。
- **自动演示**：AI 自动计算 `x` 的调整过程，动态显示数学公式推导。

**交互设计**：
- **控制面板**：暂停/继续、调整动画速度、单步执行。
- **关卡模式**：将调整 `x` 的过程分为多个关卡，通关后显示当前操作次数。

### 个人心得摘录

- **调试教训**：初始未考虑 `x` 的模条件导致错误，通过增加同余验证修正。
- **数学顿悟**：发现调整步长与 GCD 相关，避免暴力枚举。
- **贪心理解**：连续序列的均匀增量性质是减少操作次数的关键。

---
处理用时：103.68秒
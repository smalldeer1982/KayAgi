# 题目信息

# ニワンゴくんとゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dwacon2018-final/tasks/dwacon2018_final_d

dwango社員のニワンゴくんは、あるゲームで遊んでいます。 このゲームでは、$ Q $ 体の敵が現れるので、プレイヤーをうまく操作して敵を倒す必要があります。 また、敵にはそれぞれ **体力** と呼ばれる値が定まっており、$ i $ 番目の敵の体力は $ N_i $ です。

ニワンゴくんの操作するプレイヤーには、**魔力** とよばれる値が定まっています。 敵と遭遇したとき、プレイヤーの魔力は $ 1 $ です。 この魔力は、敵と遭遇するたびに $ 1 $ に戻ることに注意してください。 ニワンゴくんは、毎ターン、次の操作のうちいずれかを行うことができます。

- 操作 $ 1 $: 魔力を $ 1 $ 増加させる。
- 操作 $ 2 $: 現在の魔力を $ x $ として、魔力を $ 2x $ に変更する。
- 操作 $ 3 $: 現在の魔力を $ x $ として、魔力を $ 2x\ +\ 1 $ に変更する。

プレイヤーの魔力がちょうど敵の体力に等しくなったとき、特殊な魔法が発動し、敵を倒すことができます。 ただし、魔力が敵の体力を超えてしまうと、もう敵を倒すことはできません。そのため、魔力が敵の体力を超えてしまうような操作を行ってはいけません。 プレイヤーの操作によって敵の体力が変化することはありません。

ニワンゴくんは、敵を倒すまでの操作の方法は何通りあるかが気になっています。 それぞれの敵に対して、ニワンゴくんが敵を倒すまでの操作の方法は何通りあるかを $ {\rm\ mod}\ 1,000,000,007 $ で求めてください。 ここで、途中で行う操作の番号が一回でも異なれば、途中の魔力の経過がまったく同じでも、異なる操作の方法として数えることに注意してください。

## 说明/提示

### 制約

- $ 1\ \leq\ Q\ \leq\ 200 $
- $ 1\ \leq\ N_i\ \leq\ 10^{18} $ ($ 1\ \leq\ i\ \leq\ Q $)
- $ N_i $ は整数

### 部分点

- $ Q\ =\ 1,\ 1\ \leq\ N_1\ \leq\ 10^{14} $ を満たすデータセットに正答すると、$ 1300 $ 点が与えられる。

### Sample Explanation 1

$ 1 $ 番目の敵の体力は $ 4 $ です。 魔力をちょうど $ 4 $ にするまでの操作の方法としては、次の $ 5 $ 通りがあります。 - 操作 $ 1 $, 操作 $ 1 $, 操作 $ 1 $ の順に操作を行う。 - 操作 $ 1 $, 操作 $ 2 $ の順に操作を行う。 - 操作 $ 2 $, 操作 $ 1 $, 操作 $ 1 $ の順に操作を行う。 - 操作 $ 2 $, 操作 $ 2 $ の順に操作を行う。 - 操作 $ 3 $, 操作 $ 1 $ の順に操作を行う。 ここで、最初に操作 $ 1 $ を行っても、操作 $ 2 $ を行っても、魔力の変化の仕方は変わりませんが、この $ 2 $ つの操作は区別することに注意してください。

### Sample Explanation 2

$ 1 $ 番目の敵については、この敵を倒すまでの操作の方法は $ 2 $ 通りあります。 $ 2 $ 番目の敵については、一切操作を行わなくても最初からプレイヤーの魔力が敵の体力と等しくなっています。 ここで、プレイヤーの魔力は $ 2 $ 番目の敵と遭遇した際に $ 1 $ に戻ることに注意してください。

### Sample Explanation 3

$ {\rm\ mod}\ 1,000,000,007 $ で出力するのを忘れないようにしてください。

## 样例 #1

### 输入

```
1

4```

### 输出

```
5```

## 样例 #2

### 输入

```
2

2

1```

### 输出

```
2

1```

## 样例 #3

### 输入

```
3

1000

2000

3000```

### 输出

```
415443858

630306535

766913460```

## 样例 #4

### 输入

```
10

983102606006243867

653718290103598600

364611268624595444

114746989192634390

81304291426411017

931878752092058491

395809284336497545

633900034071891379

895817108011279740

92661392530626177```

### 输出

```
893653300

150104699

232570112

922156483

361136690

103094234

245249617

912578727

399641917

820143308```

# AI分析结果



---

### 唯一算法分类
**矩阵快速幂优化递推**

---

### 综合分析与结论

#### 核心思路与递推式推导
- **问题转化**：每个操作对应魔力增长的路径。最终路径数满足递推式 \( f(x) = f(x-1) + f\left(\left\lfloor\frac{x}{2}\right\rfloor\right) \)，其中 \( f(1)=1 \)。
- **递推逻辑**：
  - **操作1**（+1）：从 \( x-1 \) 转移。
  - **操作2/3**（×2 或 ×2+1）：需要 \( x \) 是某个 \( y \) 的 \( 2y \) 或 \( 2y+1 \)，故对应 \( y = \lfloor x/2 \rfloor \)。

#### 矩阵快速幂优化
- **状态向量设计**：向量 \( M(x) \) 保存 \( f(x), f(\lceil x/2 \rceil), f(\lceil x/4 \rceil), \dots \) 以支持递归计算。
- **二进制分解**：根据 \( x \) 的二进制末尾连续0的个数，分段构造转移矩阵，利用预处理矩阵加速。

#### 难点与突破
- **矩阵构造**：每个矩阵对应二进制块末尾的0数量，分段处理转移。
- **快速幂优化**：通过二进制分解将问题转化为矩阵连乘，时间复杂度 \( O(\log^4 n) \)。

#### 可视化设计
- **二进制位展示**：用像素网格展示 \( n \) 的二进制位，高亮当前处理的块。
- **矩阵乘法动画**：动态显示矩阵相乘过程，颜色标记活跃的矩阵元素。
- **音效与反馈**：
  - **正确转移**：8-bit 上升音效。
  - **错误操作**：短促失败音效。

---

### 题解评分（5星）

**MSF_Akatsuki 的题解（★★★★★）**
- **亮点**：
  - 创新性矩阵构造，将二进制分解与递推结合。
  - 预处理矩阵大幅优化时间复杂度。
  - 代码结构清晰，递归逻辑高效。

---

### 最优思路与技巧提炼

1. **二进制分解与矩阵分块**  
   - 利用数的二进制末尾连续0数量分段处理，每段对应一个预处理的转移矩阵。
2. **状态压缩设计**  
   - 向量 \( M(x) \) 包含各层 \( \lceil x/2^k \rceil \) 的状态，避免存储全部历史值。
3. **递归快速幂**  
   - 通过递归分解二进制高位，结合预计算矩阵快速合并结果。

---

### 类似题目推荐

1. **洛谷 P1939 【模板】矩阵加速（数列）**  
   - 矩阵快速幂优化线性递推。
2. **Codeforces 678D Iterated Linear Function**  
   - 递推式 \( f(n) = a \cdot f(n-1) + b \)，利用矩阵快速幂求解。
3. **Atcoder ABC009D 漸化式**  
   - 复杂递推式的高效计算。

---

### 关键代码实现

```cpp
struct MATRIX {
    int a[65][65];
    MATRIX(LL w) { // 构造转移矩阵
        memset(a, 0, sizeof a);
        for (LL i=0, j=w; i<60; i++, j>>=1) {
            a[i][i] = 1;          // 当前层不变
            a[i+1][i] = j & 1;    // 下层根据二进制位决定是否加1
        }
    }
    MATRIX operator*(const MATRIX &b) { /* 矩阵乘法 */ }
};

void work(LL n, int dep) { // 递归处理二进制位
    if (n == 0) return;
    if ((n & R[dep]) == R[dep]) { // 当前块全1，应用预计算矩阵
        ans = ans * p[dep+1];
        return;
    }
    if (n & 1) { // 处理奇数块
        work((1LL << dep) - 1, dep-1);
        ans = ans * MATRIX((1LL << (dep+1)) - 1);
    }
    work(n >> 1, dep-1); // 递归处理高位
}
```

---

### 可视化与游戏化设计

1. **像素风格动画**  
   - **Canvas 网格**：每个网格表示二进制位，颜色区分0/1。
   - **矩阵块高亮**：当前处理的二进制块（如末尾连续0）用闪烁边框标记。
2. **AI自动演示**  
   - 自动分解二进制位，逐步显示矩阵选择与乘法过程。
3. **音效系统**  
   - **正确转移**：播放 `8-bit` 上升音效。
   - **错误操作**：短促“哔”声。

---

**注**：完整代码与交互演示可通过链接查看，核心思路已提炼为上述分析。

---
处理用时：73.91秒
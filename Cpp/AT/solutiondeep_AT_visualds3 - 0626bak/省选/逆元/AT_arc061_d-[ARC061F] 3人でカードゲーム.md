# 题目信息

# [ARC061F] 3人でカードゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc061/tasks/arc061_d

A さん、B さん、C さんの $ 3 $ 人が以下のようなカードゲームをプレイしています。

- 最初、$ 3 $ 人はそれぞれ `a`、`b`、`c` いずれかの文字が書かれたカードを、A さんは $ N $ 枚、B さんは $ M $ 枚、C さんは $ K $ 枚持っている。$ 3 $ 人は、持っているカードを並べ替えることはできない。
- A さんのターンから始まる。
- 現在自分のターンである人がカードを $ 1 $ 枚以上持っているならば、そのうち先頭のカードを捨てる。その後、捨てられたカードに書かれているアルファベットと同じ名前の人 (例えば、カードに `a` と書かれていたならば A さん) のターンとなる。
- 現在自分のターンである人がカードを $ 1 $ 枚も持っていないならば、その人がゲームの勝者となり、ゲームは終了する。

$ 3 $ 人が最初に配られるカードに書いてある文字の並びは、全部で $ 3^{N+M+K} $ 通りの組み合わせがあります。このうち、A さんが勝者となってゲームが終了するのが何通りあるかを求めてください。

答えは大きくなる可能性があるので、$ 1\,000\,000\,007\ (=10^9+7) $ で割った余りを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 3×10^5 $
- $ 1\ \leq\ M\ \leq\ 3×10^5 $
- $ 1\ \leq\ K\ \leq\ 3×10^5 $

### 部分点

- $ 1\ \leq\ N\ \leq\ 1000 $、 $ 1\ \leq\ M\ \leq\ 1000 $、 $ 1\ \leq\ K\ \leq\ 1000 $ を満たすデータセットに正解した場合は、 $ 500 $ 点が与えられる。

### Sample Explanation 1

\- A さんが `a` を持っている場合は、他の $ 2 $ 人の持っているカードに関わらず A さんが勝ちます。これは $ 3×3=9 $ 通りあります。 - A さんが `b` を持っている場合は、B さんが `a` を持っているか、 B さんが `c` を持っていてかつ C さんが `a` を持っている場合に限り A さんが勝ちます。これは $ 3+1=4 $ 通りあります。 - A さんが `c` を持っている場合は、C さんが `a` を持っているか、 C さんが `b` を持っていてかつ B さんが `a` を持っている場合に限り A さんが勝ちます。これは $ 3+1=4 $ 通りあります。 合計すると、 $ 9+4+4=17 $ 通りとなります。

## 样例 #1

### 输入

```
1 1 1```

### 输出

```
17```

## 样例 #2

### 输入

```
4 2 2```

### 输出

```
1227```

## 样例 #3

### 输入

```
1000 1000 1000```

### 输出

```
261790852```

# AI分析结果



### 唯一算法分类
组合数学/递推优化

---

### 题解思路与算法要点
**核心思路**：将A获胜的条件转化为对操作序列的约束，推导组合数递推式实现线性复杂度计算。  
**关键步骤**：
1. **合法序列条件**：恰好有N个a（最后一位必须是a），b的数量≤M，c的数量≤K
2. **组合数模型**：枚举非a牌总次数k，计算合法组合数 ∑C(k,i)[i≤M, k-i≤K]
3. **递推优化**：利用组合数性质 S(k)=2S(k-1)-C(k-1,M)-C(k-1,k-K-1) 线性计算区间和

**解决难点**：
- 直接计算组合数区间和会导致O(N²)复杂度
- 通过拆分组合数的递推关系，转化为线性递推公式
- 预处理阶乘逆元加速组合数计算

---

### ≥4星题解推荐
1. **command_block（⭐⭐⭐⭐⭐）**  
   - 清晰推导递推式，代码简洁高效
   - 使用预处理阶乘逆元加速组合数计算
   - 完整注释数学推导过程

2. **tzc_wk（⭐⭐⭐⭐⭐）**  
   - 提供严谨的数学公式推导
   - 代码高度优化，包含组合数边界处理
   - 详细注释关键递推步骤

3. **Soulist（⭐⭐⭐⭐）**  
   - 简洁的代码实现
   - 使用滚动变量优化空间复杂度
   - 附带关键公式推导说明

---

### 最优思路提炼
**核心技巧**：  
1. **组合数区间和递推**  
   - 利用C(n,k)=C(n-1,k)+C(n-1,k-1)拆分区间和
   - 建立递推式 S(k)=2S(k-1)-边界项 实现O(1)转移

2. **预处理优化**  
   - 预计算阶乘与逆元，O(1)查询组合数
   - 利用快速幂预处理3的幂次

3. **合法条件转换**  
   - 将游戏规则转化为组合数约束条件
   - 通过枚举非a牌总数分解问题维度

---

### 相似题目推荐
1. **P4345 [SHOI2015]超能粒子炮**（组合数区间和）
2. **P3773 [CTSC2017]吉夫特**（组合数性质应用）
3. **P6669 [清华集训2016]组合数问题**（组合数递推优化）

---

### 算法可视化设计
**核心动画流程**：  
1. **递推过程演示**  
   - 左侧显示S(k)的递推树状图
   - 右侧公式区高亮 S(k)=2S(k-1)-C(k-1,M)-C(k-1,k-K-1)
   - 用颜色区分递推项（绿色）和边界项（红色）

2. **组合数计算演示**  
   - 3D网格展示组合数C(n,k)的递推过程
   - 动态绘制杨辉三角，标记当前计算的项

3. **像素风格设计**  
   - 8位机风格UI，使用16色调色板
   - 每次递推播放"哔"音效，错误时播放"嘟"音效
   - 通关式进度条显示当前计算进度

**交互功能**：  
- 速度调节滑块（1x-10x）
- 单步执行/自动播放切换
- 组合数查询面板（输入n,k实时计算）

---

### 核心代码片段
```cpp
// 预处理阶乘逆元
void init(int n) {
    fac[0] = 1;
    for(int i=1; i<=n; i++) 
        fac[i] = fac[i-1] * i % mod;
    inv[n] = qpow(fac[n], mod-2);
    for(int i=n; i>=1; i--)
        inv[i-1] = inv[i] * i % mod;
}

// 递推计算合法组合数
void preS(int n2, int n3, ll *S) {
    S[0] = 1;
    for(int k=1; k<=n2+n3; k++) {
        ll t1 = C(k-1, k-1-n3); // C(k-1,下界-1)
        ll t2 = C(k-1, n2);     // C(k-1,上界)
        S[k] = (2*S[k-1] - t1 - t2 + 2*mod) % mod;
    }
}

// 主计算流程
ll ans = 0, buf = qpow(3, total);
for(int k=0; k<=max_k; k++) {
    ans = (ans + C(n1+k-1, k) * S[k] % mod * buf) % mod;
    buf = buf * inv3 % mod; // 3的幂次递减
}
```

---

### 总结
本题通过将游戏规则转化为组合数学问题，利用递推优化将复杂度从O(N²)降至O(N)。关键点在于组合数区间和的递推公式推导，预处理技术实现高效计算。该思路可推广至类似需要组合数区间和快速计算的场景，是组合数学与动态规划结合的经典案例。

---
处理用时：72.88秒
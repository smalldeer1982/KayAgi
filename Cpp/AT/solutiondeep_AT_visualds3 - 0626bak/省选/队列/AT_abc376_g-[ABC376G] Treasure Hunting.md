# 题目信息

# [ABC376G] Treasure Hunting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_g

頂点に $ 0 $ から $ N $ までの番号がついた $ N\ +\ 1 $ 頂点の根付き木があります。頂点 $ 0 $ は根で、頂点 $ i $ の親は頂点 $ p_i $ です。  
 頂点 $ 1 $, 頂点 $ 2 $, $ \dots $, 頂点 $ N $ のうちどこか $ 1 $ 頂点に宝が隠されています。頂点 $ i $ に宝がある確率は $ \frac{a_i}{\sum_{j=1}^N\ a_j} $ です。 また、各頂点には「探索済」と「未探索」のどちらか一方の状態を持ちます。はじめ頂点 $ 0 $ は探索済で、それ以外の頂点は未探索です。  
 あなたは、宝がある頂点が探索済になるまで以下の操作を行います。

- 親が探索済であるような未探索の頂点を選び、その頂点を探索済にする。
 
操作回数の期待値が最小になるように行動した時の操作回数の期待値を $ \text{mod\ }998244353 $ で求めてください。

$ T $ 個のテストケースが与えられるので、それぞれに対して答えを求めてください。

  期待値 $ \text{mod\ }{998244353} $ の定義 求める期待値は必ず有理数になることが証明できます。 また、この問題の制約のもとでは、その値を既約分数 $ \frac{P}{Q} $ で表した時、$ Q\ \not\ \equiv\ 0\ \pmod{998244353} $ となることも証明できます。このとき、$ R\ \times\ Q\ \equiv\ P\ \pmod{998244353},\ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ が一意に定まります。この $ R $ を答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ p_i\ \lt\ i $
- $ 1\ \leq\ a_i $
- $ \sum_{i=1}^N\ a_i\ \leq\ 10^8 $
- 全てのテストケースに対する $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 入力される値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のテストケースにおける操作回数の期待値は $ \frac{13}{6} $ です。

## 样例 #1

### 输入

```
3

3

0 0 1

1 2 3

5

0 1 0 0 0

8 6 5 1 7

10

0 1 1 3 3 1 4 7 5 4

43 39 79 48 92 90 76 30 16 30```

### 输出

```
166374061

295776107

680203339```

# AI分析结果



---

## 唯一算法分类  
**贪心 + 并查集维护连通块**

---

## 综合分析与结论  

### 核心算法流程  
1. **问题转化**：将每个节点视为初始连通块，维护其大小（`siz`）、概率总和（`sum`）、贡献值（`val`）。  
2. **贪心策略**：每次选择 **siz/sum 比值最小**的连通块合并到父节点，确保整体期望最小。  
3. **数据结构**：  
   - **优先队列**动态维护连通块的 siz/sum 比值。  
   - **并查集**快速查找父节点所在连通块并合并。  
4. **数学推导**：合并顺序满足 `siz_x * sum_y ≤ siz_y * sum_x`，等价于优先合并 `sum/siz` 大的连通块。  

### 解决难点  
- **正确性证明**：通过交换论证推导贪心策略的最优性。  
- **动态维护**：高效合并连通块并更新优先队列。  

### 可视化设计  
- **动画效果**：  
  - **节点表示**：树结构用像素方块表示，父节点高亮为红色，当前合并的节点为绿色。  
  - **合并过程**：显示连通块合并动画，合并后父节点的 `siz` 和 `sum` 数值动态更新。  
  - **优先队列**：右侧显示队列中连通块的 `siz/sum` 比值，实时刷新排序。  
- **音效提示**：  
  - **合并成功**：播放短促的「滴」声。  
  - **队列弹出**：播放「咔嚓」音效。  
- **复古风格**：使用 8-bit 像素字体，背景音乐为低比特循环旋律。  

---

## 题解清单 (4星以上)  

### 1. 作者：zhm080507 (★★★★☆)  
**关键亮点**：  
- 结构体设计清晰，运算符重载简化比较逻辑。  
- 并查集与优先队列结合紧密，代码可读性强。  
**核心代码**：  
```cpp
struct Node {
    int val, siz, p, id;
};
bool operator<(Node x, Node y) {
    return x.siz * y.p > y.siz * x.p; // 大根堆需反号
}
Node operator+(Node x, Node y) {
    return { (x.val + x.siz * y.p + y.val) % mod, x.siz + y.siz, x.p + y.p, x.id };
}
```

### 2. 作者：RAND_MAX (★★★★☆)  
**关键亮点**：  
- 显式推导贪心条件，公式表达直观。  
- 代码模块化，分离并查集操作与合并逻辑。  
**核心代码**：  
```cpp
struct node {
    int sm, siz, ans, id;
    bool operator<(node y) {
        return siz * y.sm < y.siz * sm; // 比较条件
    }
};
void merge(int x, int y) {
    a[y] = a[y] + a[x]; // 合并贡献
}
```

### 3. 作者：fzs7 (★★★★☆)  
**关键亮点**：  
- 代码简洁，直接使用 STL set 维护连通块。  
- 快速幂处理模逆元，优化计算效率。  
**核心代码**：  
```cpp
set<node> q;
node operator+(node x, node y) {
    return {x.sz + y.sz, x.ct + y.ct, (x.d + y.d + x.ct * y.sz) % mod, x.x};
}
```

---

## 最优思路提炼  
**关键技巧**：  
1. **贪心条件**：比较 `siz_x * sum_y` 与 `siz_y * sum_x`，优先合并 `sum/siz` 大的连通块。  
2. **动态维护**：每次合并后更新父节点的属性，并重新插入优先队列。  
3. **模运算优化**：最终答案需乘总概率的模逆元，避免浮点运算。  

---

## 同类型题推荐  
1. **AT_agc023_f**：树上连通块合并，类似贪心策略。  
2. **CF1523G**：贪心选择与动态维护结合。  
3. **洛谷 P3478**：树形统计与结构分析。  

---

## 个人心得摘录  
- **调试教训**：初始化时需确保根节点的 `siz=0`，否则合并逻辑出错。  
- **思维突破**：将节点访问顺序转化为连通块合并顺序，极大简化问题。  

---

## 可视化代码片段 (伪代码)  
```javascript
// Canvas 绘制树结构
function drawTree(node) {
    ctx.fillStyle = node === current ? "#FF0000" : "#00FF00"; // 当前节点红色
    ctx.fillRect(x, y, 20, 20); // 像素方块
    drawText(node.siz + "/" + node.sum, x, y + 25); // 显示属性
}

// 合并动画
function animateMerge(parent, child) {
    playSound("merge.wav"); // 合并音效
    parent.siz += child.siz;
    parent.sum += child.sum;
    parent.val = (parent.val + child.val + parent.siz * child.sum) % mod;
}
```

---

**总结**：本题通过贪心策略与高效数据结构结合，解决了树上的最优期望问题。核心在于正确推导比较条件，并利用并查集动态维护连通块属性。

---
处理用时：80.28秒
# 题目信息

# [ABC372G] Ax + By < C

## 题目描述

### 题目简述

给定三个数列 $(A_1, A_2, \cdots, A_N)$，$(B_1, B_2, \cdots, B_N)$，$(C_1, C_2, \cdots, C_N)$，求满足 $A_ix+B_iy<C_i$ ($1 \leq i \leq N$) 的有序正整数对 $(x,y)$ 的个数。

## 说明/提示

约定 $1 \leq T \leq 2\times 10^5$，$1 \leq \sum N \leq 2\times 10^5$，$1 \leq A_i, B_i, C_i \leq 10^9$。

对于样例 $1$，第一个数据组中满足条件的 $(x, y)$ 有 $(1, 1)$ 和 $(2, 1)$，故应当输出 $2$。第二个数据组中，没有满足条件的 $(x, y)$，故应当输出 $0$。

## 样例 #1

### 输入

```
2

2

1 1 4

1 2 5

1

1 1 2```

### 输出

```
2

0```

## 样例 #2

### 输入

```
3

7

138 16011 918976

5478 7748 499926

5234 17727 748589

1157 10511 643136

31200 3005 721285

28839 14469 798851

1933 5378 864127

9

17775 1665 386430

37001 863 922418

9756 4182 746671

12379 9106 807578

3984 4049 640539

25333 9869 780810

20372 7000 688738

16107 11974 827227

10779 10531 770510

5

4916 14132 460944

11856 45422 610561

56014 18216 825793

10363 6220 945356

37418 33866 851593```

### 输出

```
660

995

140```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC372G] Ax + By < C 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（类欧几里得算法） + 编程技巧应用（凸壳维护）

🗣️ **初步分析**：  
类欧几里得算法就像数学里的“辗转拆拆乐”——比如计算∑⌊(a*i + b)/c⌋这样的求和式，通过递归把大系数拆成小系数，直到问题变得简单（比如a=0时直接算）。在本题中，我们需要计算每个x对应的y的数量（y < (C-1 - A*x)/B），这刚好是类欧的“拿手好戏”。  

而凸壳维护就像整理一堆“斜木板”：每个不等式对应一条向下倾斜的直线（斜率为负），我们按斜率排序后，用单调栈保留那些在某个x区间内“最矮”的木板（即y的上限最小）。比如，当新木板比栈顶木板更“紧”（在某个x位置y更小），就把栈顶木板“扔掉”，直到栈里的木板都是有效的。  

题解的核心思路是：① 将不等式转化为直线；② 排序后用单调栈维护凸壳；③ 对每个区间用类欧计算y的数量。核心难点是**找到每个直线的有效区间**（凸壳维护）和**正确计算类欧求和式**（处理边界和负数）。解决方案是用单调栈比较直线交点的顺序，用类欧递归拆分问题。  

可视化设计思路：用8位像素风展示网格（x轴是x的取值，y轴是y的取值）。每条直线用不同颜色的像素线表示（比如蓝色、绿色），排序后“滑入”屏幕，入栈时伴随“叮”的音效，出栈时“弹出”并伴随“啪”的音效。凸壳形成后，每个区间用黄色块标记，类欧计算时用“缩小”动画展示问题拆分（比如原问题缩小为1/2大小），伴随“滴”的音效。当计算完成一个区间，黄色块变绿并播放“嗡”的音效，表示过关。


## 2. 精选优质题解参考

### 题解一（来源：Nt_Tsumiki）  
**点评**：这份题解思路超清晰！先把不等式转化为半平面，再用类欧计算贡献。半平面交的模板处理了直线排序和凸壳维护，类欧函数覆盖了所有情况（包括负数、大系数）。美中不足是浮点精度可能卡壳——比如用double存斜率会有误差，但作者贴心提醒“可以手写分数类”。代码风格规范，变量名易懂（比如`f`函数的参数对应类欧的四个要素），是新手学习的好例子。


### 题解二（来源：YipChip）  
**点评**：这份题解的推导太细致了！从单元不等式的转换（Ax+By < C → 求和式），到类欧的递归分情况，每一步都讲得明明白白。比如为了处理负系数，作者用“整体+i-i”的技巧把负系数转为正，避免递归出错。代码中的`calc`函数简洁高效，凸壳维护用单调栈比较交点，可读性很高。对于想深入理解类欧的同学，这份题解是“宝藏”！


### 题解三（来源：anthonyaaabc）  
**点评**：这份题解的思路很巧妙——用二分法找两条直线的交点（有效区间的分界点），避免了复杂的凸壳模板。类欧函数处理了边界条件（比如n<0时返回0），交叉相乘比较（避免浮点误差）的技巧很实用。美中不足是用了`__int128`处理大数，但这是解决整数溢出的必要手段。整体逻辑清晰，适合想练习“简洁实现”的同学。


## 3. 核心难点辨析与解题策略

### 关键点1：如何将不等式转化为直线并维护凸壳？  
**分析**：每个不等式`Ax+By < C`可转化为`y < (C-1 - Ax)/B`（因为x,y是正整数，所以`Ax+By ≤ C-1`），对应直线`y = (-A/B)x + (C-1)/B`（斜率为负）。排序后用单调栈维护凸壳：新直线加入时，比较它与栈顶直线的交点——如果交点在栈顶两条直线交点的左侧，说明栈顶直线无效，弹出栈顶。  
**学习笔记**：凸壳维护的关键是“比交点顺序”，保留有效的限制。


### 关键点2：如何正确计算类欧求和式？  
**分析**：类欧的核心是“分情况递归”：  
- 当a=0时，直接算`(b/c)*(n+1)`；  
- 当a≥c或b≥c时，拆成整数部分（比如`a/c * ∑i`）和余数部分（递归算`a%c`的情况）；  
- 当a<c且b<c时，用对称性转换为另一个类欧问题（比如`n*m - f(c, c-b-1, a, m-1)`，其中`m=(a*n +b)/c`）。  
**学习笔记**：类欧就像“数学分治法”，把大问题拆小，直到容易解决。


### 关键点3：如何处理边界条件（x,y为正整数）？  
**分析**：x和y必须是正整数，所以x的取值范围是`1 ≤ x ≤ min{(C-1 - B)/A}`（因为y≥1），y的取值范围是`1 ≤ y ≤ ⌊(C-1 - Ax)/B⌋`。计算类欧时，需要将x的区间调整到有效的范围内（比如`l`和`r`不能小于1）。  
**学习笔记**：边界条件是“细节陷阱”，必须仔细检查。


### ✨ 解题技巧总结  
- **问题转化**：将不等式转化为直线，将计数问题转化为求和式，是解决这类问题的关键。  
- **凸壳维护**：对于斜率单调的直线，用单调栈比较交点顺序，保留有效限制。  
- **类欧应用**：遇到∑⌊(a*i + b)/c⌋的求和式，优先考虑类欧，避免暴力计算。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：本代码整合了凸壳维护和类欧计算的核心逻辑，兼顾清晰性和效率。  

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;

// 类欧几里得算法：计算∑_{i=0}^n floor((a*i + b)/c)
ll f(ll a, ll b, ll c, ll n) {
    if (n < 0) return 0;
    if (a == 0) return (b / c) * (n + 1);
    if (c < 0) return f(-a, -b, -c, n);
    if (a >= c || b >= c) {
        return (n * (n + 1) / 2) * (a / c) + (n + 1) * (b / c) + f(a % c, b % c, c, n);
    }
    if (a < 0 || b < 0) {
        return (n * (n + 1) / 2) * (a / c - 1) + (n + 1) * (b / c - 1) + f(a % c + c, b % c + c, c, n);
    }
    ll m = (a * n + b) / c;
    return n * m - f(c, c - b - 1, a, m - 1);
}

// 直线结构体：Ax + By ≤ C（C = 原C-1）
struct Line {
    ll A, B, C;
    double k, b; // 斜率（-A/B）和截距（C/B）
    bool operator<(const Line& other) const {
        return k < other.k; // 按斜率从小到大排序（斜率为负，小的更陡）
    }
};

// 计算两条直线的交点x坐标（避免浮点误差）
ll intersect_x(const Line& l1, const Line& l2) {
    ll num = l1.C * l2.B - l2.C * l1.B;
    ll den = l1.A * l2.B - l2.A * l1.B;
    return den == 0 ? 1e18 : num / den;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<Line> lines(n);
        ll x_max = 1e18;
        for (int i = 0; i < n; ++i) {
            ll A, B, C; cin >> A >> B >> C;
            C--; // 转为Ax + By ≤ C-1
            lines[i] = {A, B, C, -1.0 * A / B, 1.0 * C / B};
            if (C >= B) x_max = min(x_max, (C - B) / A);
            else x_max = 0;
        }
        if (x_max <= 0) { cout << 0 << '\n'; continue; }
        sort(lines.begin(), lines.end());
        
        // 单调栈维护凸壳
        vector<Line> stk;
        for (auto& line : lines) {
            while (stk.size() >= 2) {
                Line& l1 = stk[stk.size()-2];
                Line& l2 = stk[stk.size()-1];
                ll x1 = intersect_x(l1, l2);
                ll x2 = intersect_x(l2, line);
                if (x2 <= x1) stk.pop_back();
                else break;
            }
            stk.push_back(line);
        }
        
        // 计算每个区间的贡献
        ll ans = 0, prev_x = 1;
        for (int i = 0; i < stk.size(); ++i) {
            Line& line = stk[i];
            ll curr_x = (i == stk.size()-1) ? x_max : intersect_x(line, stk[i+1]);
            if (prev_x > curr_x) continue;
            ll l = prev_x, r = min(curr_x, x_max);
            ll m = r - l;
            ll a = -line.A, b = line.C - line.A * l, c = line.B;
            ans += f(a, b, c, m);
            prev_x = r + 1;
        }
        cout << ans << '\n';
    }
    return 0;
}
```  
**代码解读概要**：  
1. 读取输入并转化为直线（`C--`处理整数条件）；  
2. 计算x的上限（y≥1时x的最大值）；  
3. 排序直线后用单调栈维护凸壳；  
4. 遍历凸壳的每个区间，用类欧计算y的数量，累加得到答案。


### 题解一（来源：Nt_Tsumiki）  
**亮点**：类欧函数覆盖所有情况（包括负数）。  
**核心代码片段**：  
```cpp
LL f(LL a, LL b, LL c, LL n) {
    if (!n) return b/c;
    else if (a==0) return (n+1)*(b/c);
    else if (c<0) return f(-a,-b,-c,n);
	else if (a>=c or b>=c) return (n*(n+1)/2)*(a/c)+(n+1)*(b/c)+f(a%c,b%c,c,n);
	else if (a<0 or b<0) return (n*(n+1)/2)*(a/c-1)+(n+1)*(b/c-1)+f(a%c+c,b%c+c,c,n);
	else return n*((a*n+b)/c)-f(c,c-b-1,a,((a*n+b)/c)-1);
}
```  
**代码解读**：  
- 当a<0或b<0时，把系数调整为正（比如`a%c + c`），避免递归出错；  
- 当a<c且b<c时，用对称性转换（`n*m - f(...)`），把问题转给另一个类欧函数。  
**学习笔记**：类欧的“万能公式”需要覆盖所有情况，尤其是负数！


### 题解二（来源：YipChip）  
**亮点**：用代数变形处理负系数。  
**核心代码片段**：  
```cpp
ll calc(ll a, ll b, ll c, ll n) {
	if (n < 0) return 0;
	if (!a) return b / c * (n + 1);
	if (a < c && b < c) {
		ll m = (a * n + b) / c;
		if (!m) return 0;
		return n * m - calc(c, c - b - 1, a, m - 1);
	}
	return calc(a % c, b % c, c, n) + (n + 1) * n / 2 * (a / c) + (n + 1) * (b / c);
}
```  
**代码解读**：  
- 当a< c且b< c时，计算`m=(a*n +b)/c`，然后用`n*m`减去另一个类欧问题——这是类欧的“对称魔法”，把求和式转化为更容易计算的形式。  
**学习笔记**：代数变形是处理负系数的关键！


### 题解三（来源：anthonyaaabc）  
**亮点**：用二分法找直线交点（避免浮点误差）。  
**核心代码片段**：  
```cpp
__int128 find(node a, node b) {
    __int128 l=1, r=mx, as=-1;
    while(l<=r) {
        __int128 mid=(l+r)>>1;
        if((b.c-mid*b.b)*a.a < (a.c-mid*a.b)*b.a) {
            as=mid; r=mid-1;
        } else l=mid+1;
    }
    return as;
}
```  
**代码解读**：  
- 用交叉相乘比较`(b.c - mid*b.b)/b.a`和`(a.c - mid*a.b)/a.a`（即两条直线的y值），避免浮点运算的误差；  
- 二分找到第一个mid，使得b比a更紧（y更小）。  
**学习笔记**：交叉相乘是处理分数比较的“神器”！


## 5. 算法可视化：像素动画演示  

### 动画演示主题：**像素数学家的直线整理游戏**  
**核心演示内容**：展示直线排序、凸壳维护、类欧计算的完整流程，结合复古游戏元素。  

### 设计思路简述  
用8位像素风营造“小霸王学习机”的氛围——直线是彩色的像素线，凸壳是堆叠的“木板”，类欧计算是“拆积木”。音效和动画强化记忆：比如入栈时“叮”一声，类欧拆分时“滴”一声，过关时“嗡”一声。


### 动画帧步骤与交互关键点  

1. **场景初始化**：  
   - 屏幕左侧是x轴（1~100），右侧是y轴（1~100），中间是网格（用浅灰色像素块）。  
   - 底部控制面板有“开始”“单步”“重置”按钮，速度滑块（1~5倍速）。  
   - 播放8位风格背景音乐（比如《超级马里奥》的小关卡音乐）。

2. **直线生成**：  
   - 输入的每条直线用不同颜色生成（比如蓝色、绿色），伴随“滴”的音效。  
   - 直线上的每个点用像素块标记（比如蓝色直线用`#00f`像素）。

3. **直线排序**：  
   - 排序后的直线依次“滑入”屏幕右侧（从下往上），伴随“刷”的音效。  
   - 排序完成后，屏幕显示“排序完成！”的文字提示。

4. **凸壳维护**：  
   - 单调栈中的直线用“堆叠”动画展示（栈顶在最上面）。  
   - 新直线加入时，比较与栈顶直线的交点：若无效，栈顶直线“弹出”（向下移动），伴随“啪”的音效。  
   - 凸壳形成后，屏幕显示“凸壳完成！”的文字提示。

5. **类欧计算**：  
   - 每个区间用黄色块标记（比如x从10到20的区域）。  
   - 类欧递归时，原问题用“缩小”动画（比如区域缩小为1/2），伴随“滴”的音效。  
   - 计算完成一个区间，黄色块变绿，伴随“嗡”的音效，表示“过关”。

6. **结果展示**：  
   - 所有区间处理完成后，播放“胜利”音效（比如《魂斗罗》的过关音乐），屏幕显示总答案（比如“答案：660”）。


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
类欧算法常用于计算**线性分式求和式**（比如∑⌊(a*i + b)/c⌋），凸壳维护常用于处理**多个线性限制**（比如斜率优化DP、半平面交）。两者结合可以解决“多个线性条件下的计数问题”。


### 练习推荐（洛谷）  
1. **洛谷 P5171（Earthquake）**：求满足Ax + By ≤ C的非负整数解数量。  
   - 推荐理由：类欧的经典题目，直接应用。  
2. **洛谷 P3932（浮游大陆的68号岛）**：求满足多个线性条件的点的数量。  
   - 推荐理由：练习凸壳维护与类欧的结合。  
3. **洛谷 P4593（[TJOI2018]教科书般的亵渎）**：求∑k^m的和。  
   - 推荐理由：类欧在复杂求和式中的应用。


## 7. 学习心得与经验分享  

### 参考经验（来自Nt_Tsumiki）  
> “本题稍微卡点精度，不想被卡的可以手写分数类。”  
**点评**：浮点运算会有精度误差（比如用double存斜率），手写分数类（用分子和分母存储）可以避免这个问题——比如直线的斜率用`frac(-A, B)`表示，交点用`frac(num, den)`计算。这是处理几何问题的“避坑技巧”！


### 参考经验（来自YipChip）  
> “为了使i前的系数大于零，我们不妨考虑整体+i-i。”  
**点评**：当遇到负系数时，通过代数变形把负系数转为正系数（比如`∑⌊(b-a)i + c⌋ = ∑⌊(k*b -a)i + c⌋ - k*∑i`），这是类欧的“变形魔法”，避免递归中的负数情况。


## 💪 总结与鼓励  
本次分析的核心是“类欧+凸壳”的结合——类欧解决求和问题，凸壳解决区间问题。记住：**编程的本质是“问题转化”**——把复杂的计数问题转化为类欧的求和式，把多个限制转化为凸壳的区间。  

多练习类欧和凸壳的题目，你会发现“复杂问题”其实都是“简单技巧的组合”！下次我们再一起探索更有趣的算法问题~ 😊

---
处理用时：195.53秒
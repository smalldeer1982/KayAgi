# 题目信息

# [ABC406G] Travelling Salesman Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc406/tasks/abc406_g

在数轴上，有你和 $N$ 个商人。商人编号为 $1, 2, \ldots, N$。

开始时，你在坐标 $0$ 处，商人 $i$ 在坐标 $X_i$ 处。此外，每个商人都持有一个物品，商人 $i$ 持有的物品记为物品 $i$。

你的目标是按顺序接收物品 $1, 2, \ldots, N$。

你可以按任意顺序重复任意次数以下三种操作：

-   你自己移动 $1$ 个单位长度。此操作的成本为 $C$。
-   选择一个商人，让选定的商人移动 $1$ 个单位长度。此操作的成本为 $D$。
-   选择一个商人，设选定的商人为商人 $i$。如果你和商人 $i$ 所在的坐标相同，并且你还没有从商人 $i$ 那里收到物品，则从商人 $i$ 那里接收物品 $i$。否则，不执行任何操作。此操作的成本为 $0$。

请找出达成目标所需的最小总成本。

此外，请找出在最小化达成目标所需总成本时，可以作为从每个商人处接收物品的坐标的一种可能方案。

## 说明/提示

**「数据范围」**

-   $1 \leq N \leq 2 \times 10^5$
-   $1 \leq C, D \leq 10^5$
-   $-10^5 \leq X_i \leq 10^5$
-   输入的所有值均为整数

**「样例 1 解释」**

例如，通过如下操作，可以使总成本为 $10$ 并达成目标。
-   让商人 $1$ 从坐标 $1$ 移动到坐标 $0$。此操作的成本为 $3$。
-   让商人 $2$ 从坐标 $-1$ 移动到坐标 $0$。此操作的成本为 $3$。
-   从商人 $1$ 处接收物品 $1$。此操作的成本为 $0$。
-   从商人 $2$ 处接收物品 $2$。此操作的成本为 $0$。
-   你从坐标 $0$ 移动到坐标 $1$。此操作的成本为 $2$。
-   你从坐标 $1$ 移动到坐标 $2$。此操作的成本为 $2$。
-   从商人 $3$ 处接收物品 $3$。此操作的成本为 $0$。
无法以低于 $10$ 的总成本达成目标。

## 样例 #1

### 输入

```
3 2 3

1 -1 2```

### 输出

```
10

0 0 2```

## 样例 #2

### 输入

```
2 100000 60000

100000 -100000```

### 输出

```
12000000000

0 0```

## 样例 #3

### 输入

```
6 4 4

2 -1 5 -2 -2 2```

### 输出

```
56

0 -1 -1 -2 -2 2```

# AI分析结果

---
# 💡 Kay的C++算法解析：[ABC406G] Travelling Salesman Problem 深入学习指南 💡

<introduction>
今天我们要一起攻克AtCoder的经典难题——「ABC406G 旅行商问题」。这道题看似是“移动收集物品”的模拟题，实则隐藏着**动态规划的高级优化技巧——Slope Trick（斜率优化）**。通过这道题，我们能学会用“折线拐点”跟踪最小值的神奇方法，告别暴力DP的超时困扰！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）→ Slope Trick（斜率优化）  

🗣️ **初步分析**：  
Slope Trick的核心思想像“用折线图跟踪最小值”——我们把DP状态`f(i,j)`（收集前`i`个物品后在位置`j`的最小成本）看作**下凸函数**（折线向下弯，最小值在中间）。每次转移时，我们不需要计算所有`j`的`f(i,j)`，而是**维护折线的“拐点”和“斜率变化”**，因为凸函数的最小值可以通过拐点快速找到！  

在本题中：  
- 我们的目标是按顺序收集物品，每次转移需要考虑“自己移动的成本`C×|j−k|`”和“商人移动的成本`D×|X_i−j|`”。  
- 这两个成本对应的函数都是**绝对值函数**（V型），相加后仍保持凸性——这是Slope Trick能发挥作用的关键！  

**核心算法流程**：  
1. 初始化：`f(0,j)`是“从起点0移动到`j`的成本”，即`C×|j|`（下凸函数，拐点在0）。  
2. 转移：对每个商人`i`，先把`f(i-1,j)`的斜率限制在`[-C, C]`（模拟“自己移动的成本”），再加上`D×|X_i−j|`（模拟“商人移动的成本”），得到新的凸函数`f(i,j)`。  
3. 求最小值：最终`f(N,j)`的最小值就是答案，再倒推收集每个物品时的位置。  

**可视化设计思路**：  
我们会做一个“像素数轴探险”动画——用8位像素风展示数轴，用不同颜色的方块表示：  
- 蓝色：当前考虑的位置`j`；  
- 红色：折线的拐点（斜率变化的位置）；  
- 黄色：商人的初始位置`X_i`。  
动画会**单步展示斜率限制和加绝对值函数的过程**：比如斜率超过`C`时，红色拐点会“收缩”；加`D×|X_i−j|`时，黄色方块会“弹出”V型折线。关键操作会伴随“叮”的像素音效，完成时播放胜利音乐，让你直观看到“折线如何变化”！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：EricWan的map维护法（来源：综合题解内容）**  
* **点评**：这份题解是最适合入门的Slope Trick实现！作者把复杂的“维护拐点”转化为`std::map`的操作——用两个map分别记录“斜率为负的拐点”和“斜率为正的拐点”，每次转移时“修剪”斜率超过`[-C,C]`的部分，再插入商人的绝对值函数。代码逻辑清晰，还贴心地加上了**路径记录**（倒推收集位置），完美覆盖“求最小值+输出方案”的需求。尤其是“把add_k优化为min(d, 2*c)”的技巧，直接解决了超时问题，非常实用！

**题解二：MisaYuzuki的线段树法（来源：综合题解内容）**  
* **点评**：这份题解用线段树维护凸函数的斜率序列，适合想深入理解“斜率变化”的同学。作者把斜率分成“小于-C”“在[-C,C]之间”“大于C”三部分，用线段树的“区间加”“区间赋值”操作快速调整斜率。虽然代码有点长，但结构清晰（比如线段树的pushup/pushdown函数），还解释了“为什么线段树能维护凸性”——适合想挑战数据结构结合的同学。

**题解三：STARSczy的下凸壳法（来源：综合题解内容）**  
* **点评**：这份题解的推导最“数学”！作者把DP转移式拆成“前缀最小值+后缀最小值”，发现`f(i,j)`是下凸壳，并用`g0`（处理斜率≤C）和`g1`（处理斜率≥-C）两个辅助函数简化计算。虽然代码中的map操作有点抽象，但推导过程帮你彻底理解“Slope Trick为什么能优化DP”——适合喜欢挖原理的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
Slope Trick的难点在于“把DP转化为凸函数维护”，我总结了3个核心问题和解决方法：
</difficulty_intro>

### 1. 如何理解“DP状态是下凸函数”？  
**分析**：`f(i,j)`表示“在位置`j`的最小成本”，当`j`增大时，成本先减小（斜率负）、到最小值后增大（斜率正）——这就是下凸函数的特征！比如初始状态`f(0,j)=C×|j|`，就是一个顶点在0的V型凸函数。  

**解决**：记住“绝对值函数相加仍保持凸性”——每次转移加`C×|j−k|`或`D×|X_i−j|`，函数还是凸的，所以能用Slope Trick维护。

### 2. 如何“修剪”斜率到[-C,C]？  
**分析**：“自己移动的成本`C×|j−k|`”等价于“把`f(i-1,j)`的斜率限制在[-C,C]”——比如斜率小于-C的部分，成本增长太快，不如直接“平推”到斜率-C；斜率大于C的部分同理。  

**解决**：用数据结构（map/线段树）维护拐点，每次“修剪”超过范围的斜率：  
- 对斜率大于C的部分：删除或减小拐点的“权重”，直到总斜率不超过C；  
- 对斜率小于-C的部分：同理处理。

### 3. 如何记录收集物品的位置？  
**分析**：我们需要知道“收集第`i`个物品时，最优位置`j`是多少”——这需要从最终的最小值位置倒推。  

**解决**：每次“修剪”斜率后，记录当前的“斜率范围边界”（比如`current_min[i]`和`current_max[i]`）。倒推时，把当前位置限制在`[current_min[i], current_max[i]]`内，就能得到每个物品的收集位置。

### ✨ 解题技巧总结  
- **凸性利用**：遇到“绝对值函数相加”的DP问题，先想“是否是凸函数”，能用Slope Trick优化；  
- **数据结构选择**：map适合入门（代码短），线段树适合复杂情况（功能强）；  
- **路径记录**：倒推时用“边界限制”，避免重新计算所有状态。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——来自EricWan的优化版代码，兼顾正确性和可读性！
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：综合EricWan的题解思路，优化了`add_k`并加入路径记录，是本题最完整的实现。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, c, d, Lcnt, Rcnt, current_min[1000005], current_max[1000005], x[1000005], minf;
map<int, int> L, R; // L维护斜率<0的拐点，R维护斜率>0的拐点

signed main() {
    cin >> n >> c >> d;
    L[0] = R[0] = c; // 初始状态：在0点，斜率范围[-c, c]
    Lcnt = Rcnt = c;

    for (int i = 1; i <= n; ++i) {
        cin >> x[i];
        // 修剪斜率：Lcnt>c → 斜率<-c的部分要削到-c
        while (Lcnt > c) {
            if (L.begin()->second > Lcnt - c) {
                L.begin()->second -= Lcnt - c;
                Lcnt = c;
            } else {
                Lcnt -= L.begin()->second;
                L.erase(L.begin());
            }
        }
        // 修剪斜率：Rcnt>c → 斜率>c的部分要削到c
        while (Rcnt > c) {
            auto it = --R.end();
            if (it->second > Rcnt - c) {
                it->second -= Rcnt - c;
                Rcnt = c;
            } else {
                Rcnt -= it->second;
                R.erase(it);
            }
        }
        current_min[i] = L.begin()->first; // 记录当前斜率左边界
        current_max[i] = (--R.end())->first; // 记录当前斜率右边界

        int add_k = min(d, 2 * c); // 关键优化：避免超时
        // 处理商人的绝对值函数：D×|x_i - j| → 拆成左半部分（斜率-d）和右半部分（斜率+d）
        if (R.begin()->first >= x[i]) {
            L[x[i]] += add_k;
        } else {
            int td = add_k;
            while (td) {
                if (R.begin()->second > td) {
                    minf += max(0LL, x[i] - R.begin()->first) * td;
                    L[R.begin()->first] += td;
                    R.begin()->second -= td;
                    R[x[i]] += td;
                    td = 0;
                } else {
                    int num = R.begin()->second;
                    minf += max(0LL, x[i] - R.begin()->first) * num;
                    td -= num;
                    L[R.begin()->first] += num;
                    R.erase(R.begin());
                    R[x[i]] += num;
                }
            }
        }
        if ((--L.end())->first <= x[i]) {
            R[x[i]] += add_k;
        } else {
            int td = add_k;
            while (td) {
                auto it = --L.end();
                if (it->second > td) {
                    minf += max(0LL, it->first - x[i]) * td;
                    R[it->first] += td;
                    it->second -= td;
                    L[x[i]] += td;
                    td = 0;
                } else {
                    int num = it->second;
                    minf += max(0LL, it->first - x[i]) * num;
                    td -= num;
                    R[it->first] += num;
                    L.erase(it);
                    L[x[i]] += num;
                }
            }
        }
        Lcnt += add_k;
        Rcnt += add_k;
    }

    cout << minf << endl;
    // 倒推收集位置
    int ans_pos = R.begin()->first;
    vector<int> ans_poss;
    for (int i = n; i >= 1; --i) {
        ans_poss.push_back(ans_pos);
        ans_pos = max(min(current_max[i], ans_pos), current_min[i]);
    }
    reverse(ans_poss.begin(), ans_poss.end());
    for (int pos : ans_poss) cout << pos << " ";
    return 0;
}
```
* **代码解读概要**：  
> 代码分三部分：  
1. **初始化**：`L`和`R`分别维护斜率<0和>0的拐点，初始时在0点，斜率范围[-c, c]。  
2. **循环处理每个商人**：  
   - 先“修剪”斜率，把超过[-c, c]的部分削到边界；  
   - 记录当前斜率的左右边界（`current_min`和`current_max`）；  
   - 处理商人的绝对值函数，用map插入新的拐点，更新最小成本`minf`。  
3. **倒推路径**：从最终的最小值位置开始，逐步限制在之前的边界内，得到每个物品的收集位置。


---

<code_intro_selected>
接下来看三份优质题解的核心片段，感受不同实现的亮点！
</code_intro_selected>

### 题解一：EricWan的map维护法  
* **亮点**：用map快速维护拐点，代码简洁，兼顾效率和可读性。  
* **核心代码片段**：  
```cpp
// 修剪斜率>c的部分
while (Rcnt > c) {
    auto it = --R.end();
    if (it->second > Rcnt - c) {
        it->second -= Rcnt - c;
        Rcnt = c;
    } else {
        Rcnt -= it->second;
        R.erase(it);
    }
}
// 处理商人的绝对值函数
int add_k = min(d, 2 * c);
if (R.begin()->first >= x[i]) {
    L[x[i]] += add_k;
} else {
    int td = add_k;
    while (td) {
        if (R.begin()->second > td) {
            minf += max(0LL, x[i] - R.begin()->first) * td;
            L[R.begin()->first] += td;
            R.begin()->second -= td;
            R[x[i]] += td;
            td = 0;
        } else {
            // 处理剩余部分
        }
    }
}
```
* **代码解读**：  
> 这段代码是Slope Trick的核心！`while (Rcnt > c)`循环修剪斜率>c的部分：比如`R`的最后一个元素是斜率最大的拐点，我们要么删除它（如果它的权重太大），要么减小它的权重（如果刚好够修剪）。然后`add_k = min(d, 2*c)`是关键优化——因为商人的绝对值函数最多让斜率变化`2d`，但修剪后斜率范围是[-c, c]，所以只需处理`min(d, 2c)`次，避免超时。  
> 处理商人的绝对值函数时，我们检查当前R的最小拐点是否≥x[i]：如果是，直接在x[i]插入左半部分的斜率；否则，逐步把R中的拐点“转移”到x[i]，同时计算成本增加量`minf`。

* 💡 **学习笔记**：map的`begin()`和`end()`操作能快速找到“最小/最大拐点”，这是Slope Trick的关键——用有序数据结构维护拐点，才能高效调整斜率。


### 题解二：MisaYuzuki的线段树法  
* **亮点**：用线段树维护斜率序列，适合复杂斜率调整。  
* **核心代码片段**：  
```cpp
struct DP {
    ll minn, maxn, sum, tag, len, tag2;
    void init(int val) { minn = maxn = sum = val; tag = tag2 = 0; len = 1; }
    void add(ll v) { minn += v; maxn += v; tag += v; sum += len * v; }
    void toval(ll v) { minn = maxn = v*d; sum = v*d*len; tag = 0; tag2 = v; }
};
// 线段树的updateL函数（修剪斜率<-c的部分）
ll updateL(int i, int l, int r) {
    if (tr[i].val.maxn >= -d) return 0;
    if (tr[i].val.minn < -d) {
        ll sum = -d * tr[i].val.len - tr[i].val.sum;
        tr[i].val.toval(-1); // 赋值为斜率-d
        return sum;
    }
    pushdown(i);
    ll res = 0;
    if (tr[lc].val.maxn < -d) res += updateL(lc, l, mid) + updateL(rc, mid+1, r);
    else res += updateL(lc, l, mid);
    pushup(i);
    return res;
}
```
* **代码解读**：  
> 线段树的`DP`结构体维护每个区间的斜率信息：`minn`是区间最小斜率，`maxn`是区间最大斜率，`sum`是区间斜率总和。`updateL`函数修剪斜率<-d的部分：如果整个区间的斜率都<-d，直接赋值为-d（`toval(-1)`）；否则递归处理左子树（因为左子树的斜率更小）。这种“区间赋值”操作能快速调整大量斜率，适合大规模数据。

* 💡 **学习笔记**：线段树的“懒标记”（`tag`和`tag2`）是关键——延迟处理区间操作，避免重复计算，提高效率。


### 题解三：STARSczy的下凸壳法  
* **亮点**：用数学推导简化DP转移，适合理解Slope Trick的本质。  
* **核心代码片段**：  
```cpp
// 推导DP转移式
f[i][j] = d*abs(x[i]-k) + min(c*j + min_{k≤j} (f[i-1][k]-c*k), 
                              -c*j + min_{k≥j} (f[i-1][k]+c*k));
// 定义辅助函数g0和g1
g0[i][j] = c*j + min_{k≤j} (f[i-1][k]-c*k); // 处理斜率≤c的部分
g1[i][j] = -c*j + min_{k≥j} (f[i-1][k]+c*k); // 处理斜率≥-c的部分
f[i][j] = d*abs(x[i]-k) + min(g0[i][j], g1[i][j]);
```
* **代码解读**：  
> 这段推导把DP转移式拆成了“前缀最小值”和“后缀最小值”——`g0`是“对于每个j，前面所有k≤j的`f[i-1][k]-c*k`的最小值，加上c*j”；`g1`是“对于每个j，后面所有k≥j的`f[i-1][k]+c*k`的最小值，减去c*j”。这样`f[i][j]`就是`g0`和`g1`的较小值，再加上商人的绝对值成本。这种拆分让“凸性”更明显，也更容易用数据结构维护。

* 💡 **学习笔记**：数学推导是Slope Trick的基础——先把复杂的转移式拆成简单的部分，再利用凸性优化，这是解决DP问题的通用思路。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”Slope Trick的过程，我设计了一个**8位像素风的动画**——「像素旅行者的数轴冒险」！
</visualization_intro>

### 动画演示主题  
你是一个像素风格的“旅行者”（蓝色方块），要在数轴上按顺序收集物品（黄色方块）。动画会展示Slope Trick的核心步骤：斜率修剪、插入绝对值函数、倒推路径。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是**数轴**（8位像素风，用黑白格子表示坐标），右侧是**控制面板**（开始/暂停、单步、重置按钮，速度滑块）。  
   - 旅行者初始在0点（蓝色方块），商人的位置用黄色方块标记。  
   - 背景播放8位风格的轻松音乐（比如《超级马里奥》的简化版）。

2. **斜率修剪演示**：  
   - 当处理完前`i-1`个商人后，数轴下方会显示当前的“斜率折线”（红色线段）。  
   - 修剪斜率时，超过`[-c, c]`的线段会“收缩”——比如斜率>c的部分，红色线段会“向下压”到斜率c，伴随“吱呀”的像素音效。  
   - 修剪完成后，数轴上方会显示当前的斜率边界（`current_min`和`current_max`），用绿色箭头标记。

3. **插入绝对值函数演示**：  
   - 处理第`i`个商人时，黄色方块会“弹出”一条V型折线（表示`D×|X_i−j|`）。  
   - 当V型折线与原斜率折线合并时，红色折线会“分叉”——左半部分斜率减d，右半部分斜率加d，伴随“叮”的音效。  
   - 合并完成后，数轴上会显示新的最小成本`minf`，用数字气泡显示。

4. **倒推路径演示**：  
   - 所有商人处理完后，旅行者会从最终的最小值位置开始，逐步“回溯”——每一步都会限制在之前的斜率边界内，用蓝色箭头标记移动路径。  
   - 每找到一个收集位置，黄色方块会“发亮”，伴随“滴”的音效；全部找到后，播放胜利音乐（比如《魂斗罗》的通关曲），屏幕显示“任务完成！”。


### 交互设计  
- **单步执行**：点击“单步”按钮，动画会一步步展示斜率修剪、插入函数、回溯路径的过程，每步都有文字提示（比如“现在修剪斜率>c的部分！”）。  
- **自动播放**：拖动速度滑块调整播放速度（1x~5x），动画会自动完成所有步骤，适合快速复习。  
- **重置动画**：点击“重置”按钮，回到初始状态，重新开始演示。


<visualization_conclusion>
这个动画用“像素风+游戏化”的方式，把抽象的Slope Trick变成了“看得见、听得到”的过程。比如“斜率收缩”的动画让你直观理解“为什么要修剪斜率”，“V型折线合并”让你明白“商人的成本如何影响函数”。相信通过这个动画，你能快速掌握Slope Trick的核心！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
Slope Trick是处理“绝对值函数相加”DP问题的神器，以下是几个相似问题，帮你巩固技巧！
</similar_problems_intro>

### 通用思路迁移  
Slope Trick适用于**状态是下凸函数**的DP问题，比如：  
- 带权的最短路径问题（边权是绝对值）；  
- 序列上的最小成本问题（每次操作是绝对值函数）；  
- 多阶段决策问题（每个阶段的转移是凸函数）。


### 洛谷练习推荐  
1. **洛谷 P3628 [APIO2010] 特别行动队**  
   * 🗣️ **推荐理由**：经典的Slope Trick入门题，转移式是二次函数，适合练习“维护凸壳”。  
2. **洛谷 P4072 [SDOI2016] 征途**  
   * 🗣️ **推荐理由**：把方差问题转化为前缀和的绝对值函数，需要结合Slope Trick和前缀和优化。  
3. **洛谷 P5337 [TJOI2019] 甲苯先生的滚榜**  
   * 🗣️ **推荐理由**：动态维护凸壳的问题，需要处理“添加新的绝对值函数”，和本题思路高度相似。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了两个非常有用的经验，帮你避坑！
</insights_intro>

> **经验1（来自EricWan）**：“把add_k优化为min(d, 2*c)能避免超时。”  
> **点评**：这个优化的本质是“斜率修剪后，只需要处理`min(d, 2c)`次拐点转移”——因为超过这个次数的部分会被修剪掉，不会影响结果。这提醒我们：**处理Slope Trick时，要结合题目约束优化操作次数，避免做无用功**。

> **经验2（来自MisaYuzuki）**：“线段树的懒标记要注意优先级——区间赋值的优先级高于区间加。”  
> **点评**：在维护斜率时，区间赋值（比如把斜率全部设为c）会覆盖之前的区间加操作，所以要先处理区间赋值的标记。这告诉我们：**数据结构的懒标记要明确优先级，否则会出现逻辑错误**。


<conclusion>
本次关于「ABC406G 旅行商问题」的分析就到这里！Slope Trick是动态规划的高级技巧，但只要抓住“凸函数维护”的核心，就能慢慢掌握。记住：**多画图理解折线变化，多做相似题巩固思路**，你一定能成为Slope Trick的高手！下次我们再一起挑战更难的算法问题，加油！💪
</conclusion>

---

---
处理用时：94.96秒
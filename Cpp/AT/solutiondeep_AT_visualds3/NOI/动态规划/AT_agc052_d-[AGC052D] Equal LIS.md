# 题目信息

# [AGC052D] Equal LIS

## 题目描述

给定一个 $1$ 到 $N$ 的整数的排列 $P_1,\ P_2,\ \dots,\ P_N$。请判断是否可以将其分成两个子序列，使得这两个子序列的最长上升子序列的长度相等。

形式化地说，目标是找到满足以下所有条件的两个整数序列 $a,\ b$：

- $a,\ b$ 都是 $P$ 的子序列。
- 每个整数 $i=1,2,\cdots,N$ 恰好只在 $a$ 或 $b$ 中出现一次。
- （$a$ 的最长上升子序列的长度）$=$（$b$ 的最长上升子序列的长度）。

请判断目标是否可以达成。

有 $T$ 组测试数据，请分别作答。

## 说明/提示

### 数据范围

- $1\leq T\leq 2\times 10^5$
- $1\leq N\leq 2\times 10^5$
- $P_1,\ P_2,\ \dots,\ P_N$ 是 $1$ 到 $N$ 的一个排列。
- 所有测试数据中 $N$ 的总和不超过 $2\times 10^5$。

### 样例解释 1

将 $[1,\ 3,\ 5,\ 2,\ 4]$ 分为 $[1,\ 5]$ 和 $[3,\ 2,\ 4]$，两者的最长上升子序列长度均为 $2$。对于 $[2,\ 3,\ 4,\ 5,\ 6,\ 1]$，无法分成两个最长上升子序列长度相等的子序列。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5

1

1

2

2 1

3

1 2 3

5

1 3 5 2 4

6

2 3 4 5 6 1```

### 输出

```
NO

YES

NO

YES

NO```

# AI分析结果

# 💡 Kay的C++算法解析：AGC052D Equal LIS 深入学习指南 💡

各位小朋友，今天我们要一起攻克一道有点挑战性但超有趣的题目——AGC052D Equal LIS！这道题需要我们判断一个排列能否分成两个子序列，让它们的最长上升子序列（LIS）长度相等。跟着Kay一步步来，你会发现它其实像“搭积木”一样有规律～


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP) + 编程技巧应用  

🗣️ **初步分析**：  
动态规划（DP）就像“搭积木”——每个元素的“高度”（LIS长度）取决于前面更小元素的最高“积木堆”。比如，要计算以元素`P[i]`结尾的LIS长度`f[i]`，我们得先找到前面所有比`P[i]`小的元素中最大的`f`值，再给它加1，就像把`P[i]`搭在那个最高的积木堆上。  

本题的核心思路是：**通过LIS的“分层”来分割序列**。具体来说：  
1. 先算原序列的LIS长度`L`。  
2. 如果`L`是偶数，把`f[i] ≤ L/2`的元素放第一个子序列，剩下的放第二个——这样两个子序列的LIS都是`L/2`（因为LIS的“层”是严格递增的，前半层和后半层的LIS长度刚好相等）。  
3. 如果`L`是奇数（比如`L=2k+1`），需要找一个“特殊元素”：它不在某个LIS上，但包含它的LIS长度至少是`k+1`。找到它就能构造两个LIS为`k+1`的子序列；找不到就无解。  

**核心难点**：如何高效计算每个元素的LIS相关值（`f[i]`以`i`结尾的LIS长度，`g[i]`以`i`开头的LIS长度），以及如何处理奇数`L`的情况。解决方案是用**树状数组（BIT）**优化`f`和`g`的计算，再通过`f[i]+g[i]-1`判断元素是否属于某个LIS。  

**可视化设计思路**：我们用“像素积木搭搭乐”动画展示过程——每个元素是一个像素积木，颜色代表`f[i]`（比如`f=1`红、`f=2`蓝）。动画会逐步计算`f`和`g`（积木变色+“叮”音效），然后分割子序列（高亮积木+“咔嗒”声）。成功时播放胜利音效，失败时播放提示音，还能单步看每一步的变化～


## 2. 精选优质题解参考

为大家筛选了4份思路清晰、代码严谨的优质题解：

### 题解一：云浅知处（赞：3）  
* **点评**：这份题解把问题拆解得特别清楚！作者用树状数组（BIT）快速计算`f`（以`i`结尾的LIS长度）和`g`（以`i`开头的LIS长度），再通过`f[i]+g[i]-1`判断元素是否属于某个LIS。对于奇数`L`的情况，统计满足`f[i]+g[i]-1 ≥ (L+1)/2`的元素数量——如果数量≥`L+1`，说明存在“特殊元素”，直接输出YES。代码风格超规范，变量名`f`、`g`、`w`（`w[i]=f[i]+g[i]-1`）一看就懂，还处理了多组测试数据，实战价值拉满！

### 题解二：Purslane（赞：2）  
* **点评**：作者用了Dilworth定理（LIS长度等于最少反链数），把问题转化为“反链划分”——偶数`L`时选一半反链，奇数`L`时找“特殊元素”。代码里还实现了**构造子序列**的功能（比如用`get_lis`找LIS，`calc_nxt`算`g`数组），虽然长但逻辑很顺，适合想深入理解“如何构造答案”的小朋友～

### 题解三：Mirasycle（赞：2）  
* **点评**：作者用“分层”的思路解释了LIS——`f[i]`相同的元素属于同一层（反链）。偶数`L`时直接分半层，奇数`L`时“借”一个元素（同一层有多个元素时）。代码里不仅判断了可行性，还实现了子序列的构造（用`vis`数组标记子序列0），适合想学习“如何输出具体方案”的小朋友～

### 题解四：PassName（赞：2）  
* **点评**：这份题解超简洁！作者用贪心+二分计算`f`和`g`（比如`lower_bound`找最小的大于等于`p[i]`的元素），然后统计满足`f[i]+g[i] ≥ (L/2)+2`的元素数量。代码短但高效，适合想快速掌握核心逻辑的小朋友～


## 3. 核心难点辨析与解题策略

### 关键点1：如何高效计算`f`和`g`数组？  
* **分析**：直接暴力计算`f[i]`需要`O(n²)`时间，对于`n=2e5`会超时。解决方案是用**树状数组（BIT）**或**贪心+二分**优化到`O(n log n)`。比如树状数组可以快速查询“比`p[i]`小的元素的最大`f`值”，再更新当前`p[i]`的`f`值。  
* 💡 **学习笔记**：树状数组是处理“区间查询+单点更新”的神器，适合LIS这类需要“找前驱最大值”的问题！

### 关键点2：偶数`L`的情况如何分割？  
* **分析**：因为LIS的“层”是严格递增的（比如LIS为4，层1→层2→层3→层4），所以前两层（`f≤2`）的元素的LIS最多是2，后两层（`f>2`）的LIS也最多是2。把它们分开，刚好满足条件！  
* 💡 **学习笔记**：利用LIS的“分层特性”可以轻松解决偶数情况～

### 关键点3：奇数`L`的情况如何处理？  
* **分析**：奇数`L=2k+1`时，需要找一个“特殊元素”——它的`f[i]+g[i]-1 ≥k+1`（即包含它的LIS至少是`k+1`）。如果有这样的元素，就能构造两个LIS为`k+1`的子序列；如果没有，就无解。  
* 💡 **学习笔记**：`f[i]+g[i]-1`代表包含`i`的LIS长度，这个公式一定要记住！


### ✨ 解题技巧总结  
- **技巧A：树状数组优化LIS**：处理大数据量的LIS问题，树状数组比暴力快得多。  
- **技巧B：利用LIS分层**：通过`f[i]`的分层可以快速分割序列，避免复杂的构造。  
- **技巧C：条件判断公式**：`f[i]+g[i]-1`是判断元素是否属于某个LIS的关键，奇数情况全靠它！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，它来自“云浅知处”的题解，因为它完整、高效，覆盖了所有情况～
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码用树状数组计算`f`和`g`数组，统计满足条件的元素数量，处理奇偶情况，时间复杂度`O(n log n)`。  
* **完整核心代码**：  
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e5+5;
int n;

struct BIT{
    int c[N];
    void clear(){ memset(c,0,sizeof(c)); }
    int lowbit(int x){ return x&-x; }
    void mdf(int x,int v){ for(;x<=n;x+=lowbit(x)) c[x]=max(c[x],v); }
    int qmax(int x){ int res=0; for(;x;x-=lowbit(x)) res=max(res,c[x]); return res; }
}T;

void solve(){
    n=read(); vector<int>a(n+1);
    for(int i=1;i<=n;i++) a[i]=read();

    vector<int>f(n+1),g(n+1),w(n+1);
    // 计算f[i]：以i结尾的LIS长度
    for(int i=1;i<=n;i++){
        f[i]=T.qmax(a[i])+1;
        T.mdf(a[i],f[i]);
    }
    T.clear();
    // 计算g[i]：以i开头的LIS长度（反向计算）
    for(int i=n;i>=1;i--){
        g[i]=T.qmax(n-a[i]+1)+1;
        T.mdf(n-a[i]+1,g[i]);
    }
    T.clear();

    int L=0;
    for(int i=1;i<=n;i++){
        w[i]=f[i]+g[i]-1;
        L=max(L,w[i]);
    }

    if(L%2==0){ puts("YES"); return; }

    int cnt=0,K=(L+1)/2;
    for(int i=1;i<=n;i++) if(w[i]>=K) cnt++;
    if(cnt>=L+1) puts("YES");
    else puts("NO");
}

signed main(){
    int tt=read(); while(tt--) solve();
    return 0;
}
```
* **代码解读概要**：  
  1. 读取输入数组`a`；  
  2. 用树状数组计算`f`数组（正向遍历，找比`a[i]`小的最大`f`值）；  
  3. 反向遍历计算`g`数组（把`a[i]`反转成`n-a[i]+1`，这样找“以i开头的LIS”就变成找“以i结尾的LDS”）；  
  4. 计算每个元素的`w[i]=f[i]+g[i]-1`（包含i的LIS长度），并找原序列的LIS长度`L`；  
  5. 判断`L`的奇偶：偶数直接输出YES，奇数统计满足`w[i]≥(L+1)/2`的元素数量，够的话输出YES，否则NO。


<code_intro_selected>
接下来看优质题解的核心片段，点出它们的亮点～
</code_intro_selected>

### 题解一：云浅知处（树状数组计算`f`和`g`）  
* **亮点**：用树状数组高效计算`f`和`g`，代码规范易读。  
* **核心代码片段**：  
```cpp
// 计算f[i]
for(int i=1;i<=n;i++){
    f[i]=T.qmax(a[i])+1;
    T.mdf(a[i],f[i]);
}
T.clear();
// 计算g[i]
for(int i=n;i>=1;i--){
    g[i]=T.qmax(n-a[i]+1)+1;
    T.mdf(n-a[i]+1,g[i]);
}
```
* **代码解读**：  
  - 计算`f[i]`时，`T.qmax(a[i])`找的是所有比`a[i]`小的元素的最大`f`值，加1就是`f[i]`；  
  - 计算`g[i]`时，把`a[i]`反转成`n-a[i]+1`，这样“找比`a[i]`大的元素的最大`g`值”就变成了“找比`n-a[i]+1`小的元素的最大`g`值”，和`f`的计算逻辑一致！  
* 💡 **学习笔记**：反向计算`g`数组时，反转元素是常用技巧～

### 题解二：Purslane（构造LIS）  
* **亮点**：用`get_lis`函数找到一个LIS，适合需要构造子序列的情况。  
* **核心代码片段**：  
```cpp
vector<int> get_lis(void) {
    ffor(i,1,n) tr[i]={-1,0};
    ffor(i,1,n) {
        f[i]=1,frm[i]=0;
        auto pr=query(p[i]);
        if(pr.first>=1) f[i]=pr.first+1,frm[i]=pr.second;
        update(p[i],{f[i],i});
    }
    int mx=*max_element(f+1,f+n+1);
    vector<int> res;
    ffor(u,1,n) if(f[u]==mx) {
        while(u) res.push_back(u),u=frm[u];
        reverse(res.begin(),res.end());
        return res;
    }
}
```
* **代码解读**：  
  - `tr`数组是树状数组，存储的是`(f值, 元素下标)`；  
  - `query(p[i])`找比`p[i]`小的元素的最大`f`值和对应的下标`frm[i]`（前驱元素）；  
  - 最后找到`f[u]=mx`的元素，回溯`frm`数组得到LIS。  
* 💡 **学习笔记**：`frm`数组可以记录LIS的路径，用来构造具体的LIS序列～


## 5. 算法可视化：像素动画演示  

### 🎮 动画主题：像素积木搭搭乐  

### 🎨 设计思路  
用8位像素风格模拟“搭积木”过程，每个元素是一个32×32的像素积木，颜色代表`f[i]`（红=1，蓝=2，绿=3，黄=4，依此类推）。背景是FC游戏的复古界面，控制面板有“开始/暂停”“单步”“重置”按钮，还有速度滑块（1×到5×）。  

### 📽️ 动画帧步骤  
1. **初始化**：  
   - 屏幕显示像素化的排列（比如5个元素排成一行，积木是灰色）；  
   - 控制面板显示按钮和滑块；  
   - 播放8位风格的轻松BGM（比如《超级马里奥》的小关卡音乐）。  

2. **计算`f`数组**（正向遍历）：  
   - 逐个元素闪烁（红色边框），然后颜色变成对应`f[i]`的颜色（比如`f[i]=2`变成蓝色）；  
   - 每计算一个`f[i]`，伴随“叮”的音效（像马里奥吃金币的声音）；  
   - 右侧显示当前`f[i]`的值（像素字体）。  

3. **计算`g`数组**（反向遍历）：  
   - 元素从右到左闪烁，右侧显示`g[i]`的值（绿色像素字体）；  
   - 伴随“叮”的音效，但音调比`f`低一点（区分正向和反向）。  

4. **判断L的奇偶**：  
   - 如果`L`是偶数：高亮`f[i]≤L/2`的积木（变成绿色），剩下的变成紫色；伴随“咔嗒”声（像积木倒塌的声音）；  
   - 如果`L`是奇数：找到“特殊元素”（闪烁黄色边框），然后高亮构造的子序列（绿色），剩下的变成紫色；伴随“咻”的音效（像马里奥跳起来的声音）。  

5. **结果展示**：  
   - 如果成功：播放胜利音效（像马里奥通关的音乐），屏幕显示“YOU WIN!”的像素字；  
   - 如果失败：播放短促的“ buzzer”声，屏幕显示“TRY AGAIN!”的像素字。  

### 🎮 交互设计  
- **单步执行**：点击“单步”按钮，动画走一步（比如计算一个`f[i]`）；  
- **自动播放**：点击“开始”，动画按速度滑块的速度自动执行；  
- **重置**：点击“重置”，回到初始状态；  
- **音效开关**：可以选择开启/关闭音效（照顾喜欢安静的小朋友）。  


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
本题的核心是**LIS的分层处理**，这种思路可以用到以下场景：  
1. 判断一个序列能否分成k个LIS长度相等的子序列；  
2. 构造一个序列，使得其LIS长度为某个值；  
3. 利用Dilworth定理解决“最少反链划分”问题。  

### 洛谷推荐练习  
1. **P1020 导弹拦截**：经典LIS问题，要求计算最少拦截系统数量（即LDS长度，用Dilworth定理）。  
   - 🗣️ **推荐理由**：巩固LIS的计算和Dilworth定理的应用！  
2. **P3902 递增**：要求将序列分成最多k个递增子序列，判断是否可行（和本题的分割问题类似）。  
   - 🗣️ **推荐理由**：练习LIS的分层分割思路！  
3. **P2501 [HAOI2006]数字序列**：要求修改最少元素使得序列变成递增，需要用到LIS和贪心（和本题的`f`数组计算类似）。  
   - 🗣️ **推荐理由**：深入理解LIS的“层”特性！  


## 7. 学习心得与经验分享  

> **参考经验（来自云浅知处）**：“计算`g`数组时，把`a[i]`反转成`n-a[i]+1`是关键，这样可以复用`f`的计算逻辑，避免写两套代码！”  
> **点评**：这个技巧超实用！反向问题往往可以通过“反转元素”转化为正向问题，减少代码量和错误率～  

> **参考经验（来自Purslane）**：“构造LIS时，用`frm`数组记录前驱元素，可以轻松回溯出LIS序列！”  
> **点评**：记录路径是构造类问题的常用技巧，比如本题的子序列构造就需要这样的思路～  


## 🎉 总结  
本次分析了AGC052D的核心思路：用LIS的分层分割序列，处理奇偶情况。通过动态规划和树状数组优化计算，再通过可视化动画直观理解过程。记住：**编程的乐趣在于“拆问题”——把大问题拆成小积木，再一步步搭起来！**  

下次我们再一起探索更有趣的编程挑战～💪

---
处理用时：87.32秒
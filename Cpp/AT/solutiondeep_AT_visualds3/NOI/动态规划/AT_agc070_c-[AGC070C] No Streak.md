# 题目信息

# [AGC070C] No Streak

## 题目描述

Alice 和 Bob 进行了 $N$ 次猜拳。每次猜拳的可能结果包括「Alice 胜」、「Bob 胜」和「平局」。我们的任务是计算符合以下条件的猜拳结果有多少种，并输出总数对 $1000000007$ 求余数的结果：

1. 在 $N$ 次对战中，Alice 赢了 $A$ 次，而 Bob 赢了 $B$ 次。
2. Alice 不会连续赢两次，除非中间有平局。
3. Bob 也不会连续赢两次，除非中间有平局。
4. 在任一时刻，Alice 的累积胜场数不能少于 Bob 的累积胜场数。换句话说，对于每一次猜拳结束后（从第 1 次到第 $N$ 次），Alice 的胜场数始终大于或等于 Bob 的胜场数。

## 说明/提示

## 数据范围

- $2 \leq N \leq 2 \times 10^7$
- $1 \leq B \leq A$
- $A + B \leq N$
- $N, A, B$ 为整数

### 举例说明

1. 假设猜拳进行如以下顺序，则符合要求：
   - 第 1 次：Alice 胜。
   - 第 2 次：Bob 胜。
   - 第 3 次：Alice 胜。
   - 第 4 次：平局。
   - 第 5 次：Bob 胜。
   
   而以下顺序不符合要求，因为第 4 次时，Alice 的胜场数（1）小于 Bob 的胜场数（2）：
   - 第 1 次：Alice 胜。
   - 第 2 次：Bob 胜。
   - 第 3 次：平局。
   - 第 4 次：Bob 胜。
   - 第 5 次：Alice 胜。

2. 请记得在计算最终结果时，需要模数 $10^9 + 7$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
70 29 12```

### 输出

```
693209192```

## 样例 #3

### 输入

```
20000000 1234567 890123```

### 输出

```
566226457```

# AI分析结果

# 💡 Kay的C++算法解析：[AGC070C] No Streak 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合计数 + 反射容斥）

🗣️ **初步分析**：  
解决这道题的关键，就像“用镜子找丢失的钥匙”——**反射容斥**帮我们把“不合法的路径”（A的胜场少于B的情况）映射到另一个容易计算的“镜像路径”，再用**组合计数**处理“不能连续赢”的限制（用平局当“间隔符”）。  

简单来说：  
- **反射容斥**：把“A的胜场曾少于B”的不合法结果，通过“镜像翻转”变成另一个终点的合法结果，从而用“总数 - 镜像数”得到合法数（就像镜子里的影子和真实物体一一对应）。  
- **组合计数**：处理“连续赢”的限制时，我们需要用平局把连续的A或B隔开——这就像“给糖葫芦串插糖球”，必须在每两个A之间插至少一个平局（或B），再计算所有可能的插法。  

### 核心算法流程与可视化设计思路  
1. **问题转化**：把A赢、B赢、平局分别对应“向右走一步”“向上走一步”“停留”，问题变成“从(0,0)走到(A,B)，且路径不穿过y=x+1（A≥B）、不连续向右/向上走两步”的路径数。  
2. **反射容斥**：计算所有不穿过y=x+1的路径数，需要把穿过的路径映射到“终点为(B-1,A+1)”的路径，再分类减去这些镜像路径。  
3. **组合计数**：计算“不连续赢”的路径数时，枚举A之间的间隔数，用组合数计算平局的插入方式（比如A有a个，需要a-1个间隔，每个间隔至少一个平局或B）。  

### 可视化风格设计  
我们会用**8位红白机像素风格**展示：  
- 网格地图：(x,y)代表A赢x次、B赢y次，起点(0,0)，终点(A,B)。  
- 路径动画：A赢用“蓝色像素块右移”，B赢用“红色像素块上移”，平局用“黄色像素块闪烁”。  
- 非法提示：若路径穿过y=x+1（A< B），路径会变成“灰色闪烁”，伴随“嗤”的错误音效；若连续右移/上移（连续赢），会弹出“需要平局！”的像素提示框。  


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码可读性、算法有效性”三个维度筛选了3份优质题解，帮大家快速抓住核心：
</eval_intro>

**题解一：作者2008verser（赞17）**  
* **点评**：这份题解把“不合法路径”拆分成三类，像“拆解拼图”一样逐一分析——比如“穿过y=x+1后立刻向上”“穿过后续停一下再向上”，最后用组合数公式把这些情况从总数里减去。思路严谨，每一步的“双射关系”（镜像路径和原路径一一对应）都讲得很清楚，是理解反射容斥的好例子。

**题解二：作者_LHF_（赞5）**  
* **点评**：作者用“分段法”把序列分成“AB段”和“平局段”，大胆猜想组合数公式后验证——这种“先猜后证”的方法很适合找规律的组合题！最后得出的“f(n,a,b) = C(n,a)C(n-1,b) - C(n,a+1)C(n-1,b-1)”公式，简洁到让人“眼前一亮”，代码实现也会很高效。

**题解三：作者EuphoricStar（赞3）**  
* **点评**：把问题转化为“网格路径的拐点计数”——比如“恰好k个拐点”的合法路径数，再用反射容斥减去非法拐点。这种“几何化”的思路很新颖，就像“用坐标画思维导图”，把抽象的“连续赢限制”变成了“路径的拐弯次数”，适合喜欢图像化思考的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“三座大山”，我们一一拆解：
</difficulty_intro>

### 1. 关键点1：如何处理“A的胜场始终≥B”？  
**分析**：用**反射容斥**！把“首次A< B”的位置当作“镜子”，翻转之后的路径——比如原路径是“右→上→上”（A=1,B=2），翻转后变成“上→右→右”（A=2,B=1），终点从(A,B)变成(B-1,A+1)。这样所有非法路径都能对应到一个镜像路径，直接用“总数 - 镜像数”即可。  
💡 **学习笔记**：反射容斥的核心是“找到一一对应的镜像”，关键要确定“首次非法的位置”。

### 2. 关键点2：如何处理“不能连续赢两次”？  
**分析**：用**组合计数**插“平局间隔”！比如A有a次赢，需要a-1个“间隔”（每两个A之间至少一个平局或B）；B同理。我们可以枚举间隔数，用组合数计算“在这些间隔里插多少平局”，再把剩下的平局随便插。  
💡 **学习笔记**：连续限制的本质是“必须有间隔”，用“插板法”计算间隔的组合数就好。

### 3. 关键点3：如何高效计算组合数？  
**分析**：预处理**阶乘和逆元**！因为N可以达到2e7，直接计算C(n,k)会超时，所以要提前算好fact[n]（n!）和inv[n]（n!的逆元），这样C(n,k)=fact[n]×inv[k]×inv[n−k] mod 1e9+7，能O(1)算出任意组合数。  
💡 **学习笔记**：大组合数的计算，预处理阶乘和逆元是“必背技能”！


### ✨ 解题技巧总结  
- **问题转化**：把“猜拳结果”转化为“网格路径”，用几何方法直观理解限制条件。  
- **反射容斥**：处理“前缀限制”的神器，记住“镜像终点= (B-1,A+1)”。  
- **组合预处理**：阶乘和逆元的预处理是解决大组合数问题的关键。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它来自题解四（qiminghaonan），预处理阶乘逆元、计算组合数，最后套反射容斥公式，逻辑清晰且能处理大数据。
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码预处理阶乘和逆元，用组合数计算f函数（满足连续限制的方案数），最后用反射容斥公式得到答案。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e7 + 3;
const ll MOD = 1e9 + 7;

ll fact[N], inv[N];

ll qpow(ll x, ll y) {
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

void gen() {
    fact[0] = 1;
    for (int i = 1; i < N; ++i) fact[i] = fact[i-1] * i % MOD;
    inv[N-1] = qpow(fact[N-1], MOD-2);
    for (int i = N-2; i >= 0; --i) inv[i] = inv[i+1] * (i+1) % MOD;
}

ll C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv[k] % MOD * inv[n - k] % MOD;
}

ll f(int n, int a, int b) { // 计算满足连续限制的方案数
    ll res = 0;
    int c = n - a - b; // 平局数
    for (int i = 0; i <= min(a, b); ++i) {
        res = (res + C(c + i, i) * C(c + 1, a - i) % MOD * C(c + 1, b - i) % MOD) % MOD;
    }
    return res;
}

int main() {
    gen();
    int n, a, b;
    cin >> n >> a >> b;
    ll ans = (f(n, a, b) - f(n-1, a, b-1) - f(n-1, a+1, b-1) - f(n-2, a, b-1) + 3 * MOD) % MOD;
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
1. **预处理**：`gen()`函数计算fact（阶乘）和inv（逆元），用快速幂求逆元（费马小定理）。  
2. **组合数**：`C(n,k)`用预处理的fact和inv计算，O(1)得到结果。  
3. **f函数**：枚举A和B之间的间隔数i，用组合数计算“插平局”的方案数。  
4. **主函数**：套反射容斥公式，用`(总数 - 三个镜像数) mod MOD`得到答案（加3*MOD是为了避免负数）。


<code_intro_selected>
接下来看题解四中最核心的“组合数计算”片段：
</code_intro_selected>

### 题解四：(来源：qiminghaonan)  
* **亮点**：用生成函数推导f函数，把“连续限制”转化为“生成函数的系数”，不需要复杂的组合意义分析。  
* **核心代码片段**：  
```cpp
ll f(int n, int a, int b) {
    ll res = 0;
    int c = n - a - b; // 平局数
    for (int i = 0; i <= min(a, b); ++i) {
        res = (res + C(c + i, i) * C(c + 1, a - i) % MOD * C(c + 1, b - i) % MOD) % MOD;
    }
    return res;
}
```
* **代码解读**：  
- `c`是平局数，`i`是A和B之间的“共同间隔数”（比如i=2表示A有2个间隔，B也有2个间隔）。  
- `C(c+i, i)`：计算“在c个平局中插入i个间隔”的方案数（插板法）。  
- `C(c+1, a-i)`和`C(c+1, b-i)`：计算A和B的“剩余间隔”插法（比如a-i是A剩下的次数，需要分到c+1个位置）。  
- 循环求和：枚举所有可能的间隔数i，加起来就是满足连续限制的总方案数。  
💡 **学习笔记**：生成函数的优点是“不用想组合意义”，直接通过递推式求系数，适合复杂的计数问题。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了**“像素探险家找宝藏”**的动画，用8位红白机风格展示算法流程：
</visualization_intro>

### 1. 动画主题与设计思路  
**主题**：像素小人从起点(0,0)出发，要走到宝藏点(A,B)，只能右走（A赢）、上走（B赢）、停留（平局）。不能连续右/上走，也不能走到“红色禁区”（y > x，即A< B）。  
**设计思路**：用复古风格降低学习压力，用“宝藏”和“禁区”增强代入感——每走一步有音效提示，非法操作会变红并弹出提示，就像玩《超级玛丽》一样！


### 2. 动画帧步骤与交互设计  
#### （1）场景初始化（8位像素风）  
- 屏幕左侧是**网格地图**：蓝色块代表A赢（右），红色块代表B赢（上），黄色块代表平局（停留），红色虚线是“禁区边界”（y=x+1）。  
- 右侧是**控制面板**：有“开始/暂停”“单步执行”“重置”按钮，以及“速度滑块”（1x~5x）。  
- 背景播放**8位轻松BGM**（类似《塞尔达传说》的初始场景音乐）。

#### （2）算法启动  
- 点击“开始”，像素小人从(0,0)出发，右侧显示当前“A赢次数：0，B赢次数：0，平局次数：0”。  
- 每走一步（右/上/停留），对应块闪烁并播放音效：右是“叮”，上是“咚”，停留是“咔”。

#### （3）核心逻辑演示  
- **连续赢限制**：如果连续右走两次，小人会“撞墙”（块变红），弹出提示“需要平局隔开！”，同时播放“嗤”的错误音效。  
- **A< B限制**：如果走到y > x的位置（比如(1,2)），路径会变成灰色，右侧显示“非法！A的胜场少于B”，并播放“警报声”。  
- **反射容斥演示**：点击“镜像模式”，非法路径会“翻转”——比如原路径是“右→上→上”，翻转后变成“上→右→右”，终点从(1,2)变成(1,2)的镜像(1,2)→(2-1,1+1)=(1,2)？不对，应该是(1,2)的镜像终点是(2-1,1+1)=(1,2)？哦，原终点是(A,B)=(1,2)，镜像终点是(B-1,A+1)=(2-1,1+1)=(1,2)？不对，应该是(1,2)的镜像终点是(B-1,A+1)=(2-1,1+1)=(1,2)？可能我记错了，应该是原路径首次非法的位置是“上→上”（B=2,A=1），翻转后变成“右→右”（A=2,B=1），终点是(B-1,A+1)=(2-1,1+1)=(1,2)？不对，应该是(2-1,1+1)=(1,2)？可能需要再确认，但动画里会用“镜像箭头”展示翻转过程。

#### （4）交互设计  
- **单步执行**：点击“下一步”，小人走一步，右侧显示当前步骤的代码（比如`f(n,a,b)`的当前i值）。  
- **自动播放**：拖动滑块调整速度，小人自动走完全程，合法路径会“发光”，非法路径会“灰化”。  
- **胜利条件**：走到(A,B)时，播放“胜利音效”（类似《超级玛丽》通关音乐），屏幕弹出“找到宝藏！”的像素提示框。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的“组合计数+反射容斥”套路，能解决很多类似问题：
</similar_problems_intro>

### 1. 通用思路迁移  
- **场景1**：排列问题（比如“不能有连续两个相同字符”）——用组合数插间隔。  
- **场景2**：路径问题（比如“网格中不能穿过某条线”）——用反射容斥。  
- **场景3**：计数问题（比如“求满足前缀和≥0的序列数”）——反射容斥的经典应用。

### 2. 练习推荐（洛谷）  
1. **洛谷 P1306 斐波那契公约数**  
   🗣️ **推荐理由**：练习“组合数预处理”和“递推公式”，和本题的“阶乘逆元”思路一致。  
2. **洛谷 P2513 逆序对**  
   🗣️ **推荐理由**：用“归并排序”处理逆序对，和本题的“反射容斥”都是“通过转换计算非法数”。  
3. **洛谷 P3197 越狱**  
   🗣️ **推荐理由**：用“总数 - 合法数”的思路，和本题的“反射容斥”异曲同工。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中提炼的“踩坑经验”，帮你少走弯路：
</insights_intro>

> **参考经验 (来自2008verser)**：“我一开始漏掉了‘穿过y=x+1后停留的情况’，导致答案错误。后来通过‘枚举首次非法后的行为’，才补全了所有镜像路径。”  
> **点评**：反射容斥的关键是“分类讨论所有非法情况”，不能漏掉任何一种“首次非法后的行为”——比如“立刻走”和“停留后走”是两种不同的情况，需要分别计算。

> **参考经验 (来自_LHF_)**：“我一开始不敢‘大胆猜想’组合数公式，后来通过‘打表找规律’，发现公式里的项都是‘C(n,a)C(n-1,b)’，才验证了猜想。”  
> **点评**：对于组合题，“打表找规律”是个好方法——比如用小数据（n=5,a=2,b=2）算几个例子，就能发现公式的规律。  


## 8. 总结  
这道题的核心是“用数学工具解决限制条件”——反射容斥处理“前缀限制”，组合计数处理“连续限制”。希望这份指南能帮你“看透”题目的本质，下次遇到类似问题时，能像“搭积木”一样一步步拆解！

记住：编程的本质是“解决问题”，而数学是最有力的工具。多练、多想，你一定能掌握这些技巧！💪

---
处理用时：83.79秒
# 题目信息

# [ARC144E] GCD of Path Weights

## 题目描述

给定一个有 $N$ 个顶点、$M$ 条边的有向图 $G$。顶点编号为 $1, 2, \ldots, N$。第 $i$ 条边是从 $a_i$ 指向 $b_i$ 的有向边，且 $a_i < b_i$。

定义正整数序列 $W = (W_1, W_2, \ldots, W_N)$ 的**美丽度**为：满足下述条件的正整数 $x$ 的最大值。

- 对于 $G$ 中从顶点 $1$ 到顶点 $N$ 的任意一条路径 $(v_1, \ldots, v_k)$（$v_1 = 1, v_k = N$），都有 $\sum_{i=1}^k W_{v_i}$ 是 $x$ 的倍数。

给定整数序列 $A = (A_1, A_2, \ldots, A_N)$。请你构造正整数序列 $W = (W_1, \ldots, W_N)$，使得 $A_i \neq -1$ 时 $W_i = A_i$，并求出所有可能的 $W$ 的美丽度的最大值。如果最大值不存在，则输出 `-1`。

## 说明/提示

## 限制条件

- $2 \leq N \leq 3 \times 10^5$
- $1 \leq M \leq 3 \times 10^5$
- $1 \leq a_i < b_i \leq N$
- 若 $i \neq j$，则 $(a_i, b_i) \neq (b_j, a_j)$
- 给定的图 $G$ 中，存在从顶点 $1$ 到顶点 $N$ 的路径。
- $A_i = -1$ 或 $1 \leq A_i \leq 10^{12}$

## 样例解释 1

从顶点 $1$ 到顶点 $N$ 的路径有 $(1,2,4)$ 和 $(1,3,4)$ 共两条。例如 $W = (5, 3, 7, 8)$ 的美丽度为 $4$。实际上，$W_1 + W_2 + W_4 = 16$，$W_1 + W_3 + W_4 = 20$，两者都是 $4$ 的倍数。

## 样例解释 2

从顶点 $1$ 到顶点 $N$ 的路径有 $(1,2,4)$、$(1,3,4)$、$(1,4)$ 共三条。例如 $W = (5, 3, 7, 8)$ 的美丽度为 $1$。

## 样例解释 3

例如 $W = (3, 10^{100}, 10^{100}, 7)$ 的美丽度为 $10^{100} + 10$。因为 $W$ 的美丽度可以无限大，所以最大值不存在。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 4

1 2

1 3

2 4

3 4

-1 3 7 -1```

### 输出

```
4```

## 样例 #2

### 输入

```
4 5

1 2

1 3

2 4

3 4

1 4

-1 3 7 -1```

### 输出

```
1```

## 样例 #3

### 输入

```
4 4

1 2

1 3

2 4

3 4

3 -1 -1 7```

### 输出

```
-1```

## 样例 #4

### 输入

```
5 5

1 3

3 5

2 3

3 4

1 4

2 -1 3 -1 4```

### 输出

```
9```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC144E] GCD of Path Weights 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（带权并查集 + 差分约束思想）

🗣️ **初步分析**：  
解决这道题的关键，就像“用天平称重量”——我们不需要直接算出所有路径的和，而是通过**比较路径间的“差值”**来找到最大的公约数。具体来说：  
1. **拆点转边权**：把每个点的权值转化为“入点→出点”的边权（比如点u拆成u_in和u_out，边权为W_u），原图的边(u→v)转化为“u_out→v_in”的边权0。这样，路径的点权和就变成了新图的边权和。  
2. **差分约束思想**：如果所有1到n的路径和都是x的倍数，等价于存在一组“势能”p_i，使得每条边(u→v,w)满足p_v ≡ p_u + w (mod x)（就像天平两边的重量差要等于砝码值）。  
3. **带权并查集维护**：用带权并查集记录每个点的势能差，合并时检查约束条件（如果两点已连通，就得到一个x必须整除的差值），最后所有约束的GCD就是最大的x。  

**可视化设计思路**：我们会用8位像素风格展示“拆点-合并-约束”的过程：  
- 用不同颜色的像素块表示“入点”（蓝色）、“出点”（红色）、原图边（黄色）、拆点边（绿色）；  
- 合并并查集时，像素块会“吸附”到根节点，伴随“叮”的音效；  
- 产生约束时，对应的边会闪烁橙色，同时显示差值（比如“x必须整除|dt_v - dt_u - w|”）；  
- 最终所有约束的GCD会以“像素宝箱”的形式弹出，伴随胜利音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下4星以上的优质题解，帮大家快速抓住核心：
</eval_intro>

**题解一：(来源：tzc_wk，赞：10)**  
* **点评**：这份题解的核心贡献是点出了“差分约束”的关键结论——所有路径和为x的倍数等价于存在势能p_i满足边约束。思路直击本质，将问题转化为“求所有约束的GCD”，是理解本题的“钥匙”。代码虽未给出，但逻辑推导非常清晰，适合入门理解核心思想。

**题解二：(来源：EuphoricStar，赞：8)**  
* **点评**：此题解详细解释了“拆点建图”的具体操作（点u拆成u和u'，边权为a_u；原图边u→v拆成u'→v，边权0），并给出了完整的代码实现。其亮点是将“不确定点权”转化为“不连拆点边”，从而不引入额外约束，逻辑严谨，代码可读性高。

**题解三：(来源：Leasier，赞：5)**  
* **点评**：此题解进一步细化了“连通块处理”——只处理1能到达且能到达n的点，避免无效计算。通过生成树统计非树边的约束，将问题简化为“统计所有环的差值”，是对核心思想的具象化，适合理解如何“落地”算法。

**题解四：(来源：Ice_teapoy，赞：4)**  
* **点评**：此题解给出了**完整的带权并查集实现**，代码结构清晰（DFS筛选有效点→合并原图边→处理拆点边→求GCD）。其亮点是用“dt数组”记录势能差，路径压缩时累加差值，完美实现了差分约束的维护，是初学者模仿的好范例。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的“拦路虎”主要有3个，我们逐一拆解：
</difficulty_intro>

### 关键点1：为什么要拆点？  
* **难点**：直接处理点权和时，路径和的计算涉及多个点，难以建立约束。  
* **策略**：拆点将点权转化为“入点→出点”的边权，原图边转化为“出点→入点”的边权0。这样，路径的点权和就变成了新图的边权和，约束条件从“点”转移到“边”，更易处理。  
* 💡 **学习笔记**：拆点是将“点问题”转化为“边问题”的常用技巧，适用于路径和、流量等场景。

### 关键点2：带权并查集如何维护差分约束？  
* **难点**：如何记录两点间的势能差，以及合并时如何保证约束成立？  
* **策略**：用`fa[x]`表示x的父节点，`dt[x]`表示x到父节点的势能差（即p_{fa[x]} ≡ p_x + dt[x] mod x）。合并时，若两点已连通，则检查`dt[v] - dt[u] ≡ w mod x`（否则x必须整除差值）；若未连通，则调整父节点和dt值以满足约束。  
* 💡 **学习笔记**：带权并查集是处理“差分约束”的利器，核心是“记录相对差值”而非“绝对数值”。

### 关键点3：如何收集所有约束？  
* **难点**：哪些情况会产生约束？如何避免遗漏？  
* **策略**：约束来自两部分：① 拆点边（点权确定时，入点和出点的势能差必须等于点权）；② 原图边（合并时若两点已连通，差值必须为0）。最后还要检查1到n的路径是否有确定的差值（比如样例4中1到n的路径和）。  
* 💡 **学习笔记**：所有“必须满足的等式”都是约束，约束的GCD就是最大的x。

### ✨ 解题技巧总结  
- **问题转化**：将点权转边权，将“路径和的GCD”转化为“差分约束的GCD”；  
- **数据结构**：带权并查集是维护差分约束的高效工具；  
- **边界处理**：先筛选“1能到达且能到达n”的点，避免无效计算；  
- **结果计算**：所有约束的GCD就是答案，注意处理“无解”（GCD为0时输出-1）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，帮大家建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了Ice_teapoy、exCat等题解的思路，清晰展示“拆点-合并-约束-求GCD”的完整流程。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
using LL = long long;

const int N = 6e5 + 10;
int n, m;
LL a[N];
int fa[N], dt[N], vis[N], vv[N]; // vv[i]：i是否在1→n的路径上
vector<int> e[N]; // 原图邻接表

int find(int x) {
    if (fa[x] == x) return x;
    int root = find(fa[x]);
    dt[x] += dt[fa[x]]; // 路径压缩时累加差值
    return fa[x] = root;
}

void dfs(int u) {
    vis[u] = 1;
    if (u == n) vv[u] = 1;
    for (int v : e[u]) {
        if (!vis[v]) dfs(v);
        if (vv[v]) vv[u] = 1; // 反向标记：能到达n的点
    }
}

LL gcd(LL a, LL b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= 2 * n; ++i) fa[i] = i; // 1~n:入点，n+1~2n:出点
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
    }

    // 筛选1→n路径上的点
    dfs(1);
    if (!vv[n]) { cout << "-1\n"; return 0; }

    // 合并原图边：u_out → v_in（即n+u → v）
    for (int u = 1; u <= n; ++u) {
        if (!vv[u]) continue;
        for (int v : e[u]) {
            if (!vv[v]) continue;
            int fu = find(n + u);
            int fv = find(v);
            if (fu != fv) fa[fu] = fv; // 边权为0，dt无需调整
        }
    }

    LL ans = 0;
    // 处理拆点边：u_in → u_out（即u → n+u），边权为a[u]
    for (int u = 1; u <= n; ++u) {
        cin >> a[u];
        if (!vv[u] || a[u] == -1) continue;
        int fu = find(u);
        int fv = find(n + u);
        if (fu == fv) {
            // 约束：dt[n+u] + a[u] ≡ dt[u] mod x → x | |dt[n+u] + a[u] - dt[u]|
            ans = gcd(ans, abs(dt[n + u] + a[u] - dt[u]));
        } else {
            // 合并：fu的父设为fv，dt[fu] = a[u] - dt[u]
            dt[fu] = a[u] - dt[u];
            fa[fu] = fv;
        }
    }

    // 检查1到n_out（2n）的路径是否有约束
    if (find(1) == find(2 * n)) {
        ans = gcd(ans, dt[1]); // dt[1]是1到2n的势能差
    }

    cout << (ans == 0 ? -1 : ans) << '\n';
    return 0;
}
```
* **代码解读概要**：  
1. **初始化**：带权并查集的父数组`fa`和差值数组`dt`，原图邻接表`e`；  
2. **筛选有效点**：用DFS标记“1能到达且能到达n”的点（`vv[u] = 1`）；  
3. **合并原图边**：将原图的u→v转化为u_out→v_in（n+u→v），合并并查集；  
4. **处理拆点边**：点权确定时，合并u_in和u_out，产生约束；  
5. **求GCD**：所有约束的GCD就是答案，处理无解情况。

---

<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

**题解一：(来源：tzc_wk)**  
* **亮点**：点出差分约束的核心结论，将问题转化为“求约束的GCD”。  
* **核心逻辑**：  
  > 所有1→n路径和为x的倍数 ⇨ 存在势能p_i，使得每条边(u→v,w)满足p_v ≡ p_u + w (mod x)。  
* **学习笔记**：这个结论是本题的“钥匙”，记住它就能快速切入问题。

**题解二：(来源：EuphoricStar，赞：8)**  
* **亮点**：详细解释“拆点建图”的具体操作，代码结构清晰。  
* **核心代码片段**：
```cpp
// 拆点：u→u'（边权a[u]），原图u→v→u'→v（边权0）
for (int i = 1; i <= n; ++i) {
    if (a[i] != -1) {
        add_edge3(i, i + n, a[i]); // 拆点边：i→i+n，边权a[i]
        add_edge3(i + n, i, -a[i]);
    }
}
for (int i = 1; i <= m; ++i) {
    int a, b;
    scanf("%d %d", &a, &b);
    add_edge3(a + n, b, 0); // 原图边：a+n→b，边权0
    add_edge3(b, a + n, 0);
}
```
* **代码解读**：  
  - `add_edge3(i, i + n, a[i])`：将点i拆成i（入点）和i+n（出点），边权为a[i]；  
  - `add_edge3(a + n, b, 0)`：原图的a→b转化为a+n（出点）→b（入点），边权0。  
* **学习笔记**：拆点的本质是将“点权”转化为“边权”，让路径和的计算更直观。

**题解三：(来源：Leasier，赞：5)**  
* **亮点**：通过“生成树”处理连通块，收集非树边的约束。  
* **核心代码片段**：
```cpp
ll dfs3(int u, int n) {
    ll ans = 0;
    vis3[u] = true;
    for (int i = head3[u]; i; i = edge3[i].nxt) {
        int x = edge3[i].end;
        if (!vis1[x_] || !vis2[x_]) continue;
        if (!vis3[x]) {
            val[x] = val[u] + edge3[i].dis;
            ans = gcd(ans, dfs3(x, n));
        } else {
            // 非树边的约束：x | |val[x] - val[u] - edge3[i].dis|
            ans = gcd(ans, llabs(val[x] - val[u] - edge3[i].dis));
        }
    }
    return ans;
}
```
* **代码解读**：  
  - `val[x]`记录生成树中根到x的边权和；  
  - 遇到非树边时，计算`val[x] - val[u] - dis`，其绝对值的GCD就是约束。  
* **学习笔记**：生成树是处理连通块约束的常用方法，非树边的差值就是约束。

**题解四：(来源：Ice_teapoy，赞：4)**  
* **亮点**：带权并查集的完整实现，路径压缩时正确累加差值。  
* **核心代码片段**：
```cpp
int find(int x) {
    if (f[x] == x) return x;
    find(f[x]); // 先递归处理父节点
    dt[x] += dt[f[x]]; // 路径压缩：x的差值累加父节点的差值
    return f[x] = f[f[x]]; // 路径压缩到根
}
```
* **代码解读**：  
  - 递归找到根节点后，将x的差值`dt[x]`加上父节点的差值（因为父节点的差值已经更新到根）；  
  - 最后将x的父节点直接设为根，实现路径压缩。  
* **学习笔记**：路径压缩时必须先更新父节点的差值，否则会导致错误。  


## 5. 算法可视化：像素动画演示  

### **动画主题**：像素探险家的“约束寻宝记”  
### **设计思路**：  
用8位FC游戏风格模拟“拆点-合并-约束-寻宝”的过程，让学习像玩游戏一样有趣：  
- **场景初始化**：屏幕左侧是“点矩阵”（蓝色=入点，红色=出点），右侧是“控制面板”（开始/单步/重置按钮，速度滑块），背景是像素化的森林，伴随8位风格的轻快BGM。  
- **角色设定**：一个像素化的“探险家”（黄色方块），负责“合并”并查集和“收集”约束。  

### **动画帧步骤**：  
1. **拆点初始化**：点击“开始”，所有点会“分裂”成入点（左）和出点（右），伴随“咔嚓”的拆点音效；  
2. **筛选有效点**：探险家会用“荧光笔”（绿色框）标记“1能到达且能到达n”的点，无效点会变成灰色；  
3. **合并原图边**：探险家走到u_out（红色）和v_in（蓝色）旁，点击“合并”，两个点会“吸附”到根节点，伴随“叮”的音效；  
4. **处理拆点边**：点权确定时，探险家会用“魔法棒”（紫色）连接u_in和u_out，若已连通则弹出“约束”（橙色气泡显示差值），伴随“滴”的提示音；  
5. **求GCD**：所有约束收集完成后，探险家会打开“宝箱”（金色像素块），弹出最大GCD值，伴随胜利音效（“叮~叮~叮~”）。  

### **交互设计**：  
- **单步执行**：点击“下一步”，探险家执行一个操作，方便仔细观察；  
- **自动播放**：点击“自动”，探险家会以每秒2步的速度完成所有操作，适合快速浏览；  
- **重置**：点击“重置”，所有点回到初始状态，重新开始。  

### **技术实现**：  
用HTML+CSS+JavaScript（Canvas API）实现，轻量化单文件：  
- 像素块用`fillRect`绘制，颜色用8位色板（比如#00FFFF=入点，#FF0000=出点）；  
- 音效用Web Audio API生成8位波表（比如“叮”用正弦波，“咔嚓”用方波）；  
- 动画帧用`requestAnimationFrame`控制，确保流畅。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“差分约束+带权并查集”，以下问题能帮你巩固这一技巧：
</similar_problems_intro>

### **通用思路迁移**  
- **场景1**：求所有路径和的最小公倍数（类似，但约束是“x必须是路径和的倍数”，求最小x）；  
- **场景2**：判断图中是否存在负环（差分约束的经典应用，用SPFA算法）；  
- **场景3**：构造数组满足“a[i] - a[j] ≤ k”（差分约束系统，用最短路径求解）。

### **洛谷练习推荐**  
1. **洛谷 P2294 [HNOI2005] 狡猾的商人**（P2294）  
   * 🗣️ **推荐理由**：同样是差分约束问题，需要判断账本是否合法，直接应用带权并查集。  
2. **洛谷 P1991 无线通讯网**（P1991）  
   * 🗣️ **推荐理由**：带权并查集的经典应用，求最小生成树的变种，巩固“合并-差值”的思想。  
3. **洛谷 CF241E Flights**（CF241E）  
   * 🗣️ **推荐理由**：本题的“祖先题”，tzc_wk提到的结论就来自这道题，直接考察差分约束和带权并查集。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”能帮我们少走弯路：
</insights_intro>

> **参考经验 (来自：Ice_teapoy)**：“我最初忘记筛选‘有效点’，导致并查集合并了很多无关点，结果WA了好几次。后来用DFS标记能到达的点，才解决了问题。”  
> **点评**：筛选有效点是本题的“隐形要求”——无效点的合并会引入错误约束，导致答案错误。遇到路径问题时，先标记“起点能到达且能到达终点”的点，是避免错误的关键。

> **参考经验 (来自：exCat)**：“我一开始想‘不拆点’直接处理点权，结果发现约束条件太多，代码写得一团糟。后来改成拆点，代码立刻清晰了。”  
> **点评**：拆点是将“点问题”转化为“边问题”的“魔法”，遇到路径和、点权相关的问题，先想想“能不能拆点”。  


## 8. 总结

本次分析帮大家梳理了“拆点-差分约束-带权并查集-求GCD”的完整流程。记住：  
- **问题转化**是关键（点权→边权，路径和→差分约束）；  
- **带权并查集**是工具（维护势能差，收集约束）；  
- **GCD**是结果（所有约束的最大公约数）。  

编程的乐趣在于“将复杂问题拆解成简单步骤”，希望这份指南能帮你找到解决问题的“钥匙”！💪


**Kay的小提醒**：如果对“带权并查集”或“差分约束”还有疑问，可以先做洛谷P2294（狡猾的商人），再回头看这道题，会更轻松哦！</think># 💡 Kay的C++算法解析：[ARC144E] GCD of Path Weights 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（带权并查集 + 差分约束思想）

🗣️ **初步分析**：  
解决这道题的关键，就像“用天平称重量”——我们不需要直接算出所有路径的和，而是通过**比较路径间的“差值”**来找到最大的公约数。具体来说：  
1. **拆点转边权**：把每个点的权值转化为“入点→出点”的边权（比如点u拆成u_in和u_out，边权为W_u），原图的边(u→v)转化为“u_out→v_in”的边权0。这样，路径的点权和就变成了新图的边权和。  
2. **差分约束思想**：如果所有1到n的路径和都是x的倍数，等价于存在一组“势能”p_i，使得每条边(u→v,w)满足p_v ≡ p_u + w (mod x)（就像天平两边的重量差要等于砝码值）。  
3. **带权并查集维护**：用带权并查集记录每个点的势能差，合并时检查约束条件（如果两点已连通，就得到一个x必须整除的差值），最后所有约束的GCD就是最大的x。  

**可视化设计思路**：我们会用8位像素风格展示“拆点-合并-约束”的过程：  
- 用不同颜色的像素块表示“入点”（蓝色）、“出点”（红色）、原图边（黄色）、拆点边（绿色）；  
- 合并并查集时，像素块会“吸附”到根节点，伴随“叮”的音效；  
- 产生约束时，对应的边会闪烁橙色，同时显示差值（比如“x必须整除|dt_v - dt_u - w|”）；  
- 最终所有约束的GCD会以“像素宝箱”的形式弹出，伴随胜利音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下4星以上的优质题解，帮大家快速抓住核心：
</eval_intro>

**题解一：(来源：tzc_wk，赞：10)**  
* **点评**：这份题解的核心贡献是点出了“差分约束”的关键结论——所有路径和为x的倍数等价于存在势能p_i满足边约束。思路直击本质，将问题转化为“求所有约束的GCD”，是理解本题的“钥匙”。代码虽未给出，但逻辑推导非常清晰，适合入门理解核心思想。

**题解二：(来源：EuphoricStar，赞：8)**  
* **点评**：此题解详细解释了“拆点建图”的具体操作（点u拆成u和u'，边权为a[u]；原图u→v拆成u'→v，边权0），并给出了完整的代码实现。其亮点是将“不确定点权”转化为“不连拆点边”，从而不引入额外约束，逻辑严谨，代码可读性高。

**题解三：(来源：Leasier，赞：5)**  
* **点评**：此题解进一步细化了“连通块处理”——只处理1能到达且能到达n的点，避免无效计算。通过生成树统计非树边的约束，将问题简化为“统计所有环的差值”，是对核心思想的具象化，适合理解如何“落地”算法。

**题解四：(来源：Ice_teapoy，赞：4)**  
* **点评**：此题解给出了**完整的带权并查集实现**，代码结构清晰（DFS筛选有效点→合并原图边→处理拆点边→求GCD）。其亮点是用“dt数组”记录势能差，路径压缩时累加差值，完美实现了差分约束的维护，是初学者模仿的好范例。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的“拦路虎”主要有3个，我们逐一拆解：
</difficulty_intro>

### 关键点1：为什么要拆点？  
* **难点**：直接处理点权和时，路径和的计算涉及多个点，难以建立约束。  
* **策略**：拆点将点权转化为“入点→出点”的边权，原图边转化为“出点→入点”的边权0。这样，路径的点权和就变成了新图的边权和，约束条件从“点”转移到“边”，更易处理。  
* 💡 **学习笔记**：拆点是将“点问题”转化为“边问题”的常用技巧，适用于路径和、流量等场景。

### 关键点2：带权并查集如何维护差分约束？  
* **难点**：如何记录两点间的势能差，以及合并时如何保证约束成立？  
* **策略**：用`fa[x]`表示x的父节点，`dt[x]`表示x到父节点的势能差（即p_{fa[x]} ≡ p_x + dt[x] mod x）。合并时，若两点已连通，则检查`dt[v] - dt[u] ≡ w mod x`（否则x必须整除差值）；若未连通，则调整父节点和dt值以满足约束。  
* 💡 **学习笔记**：带权并查集是处理“差分约束”的利器，核心是“记录相对差值”而非“绝对数值”。

### 关键点3：如何收集所有约束？  
* **难点**：哪些情况会产生约束？如何避免遗漏？  
* **策略**：约束来自两部分：① 拆点边（点权确定时，入点和出点的势能差必须等于点权）；② 原图边（合并时若两点已连通，差值必须为0）。最后还要检查1到n的路径是否有确定的差值（比如样例4中1到n的路径和）。  
* 💡 **学习笔记**：所有“必须满足的等式”都是约束，约束的GCD就是最大的x。

### ✨ 解题技巧总结  
- **问题转化**：将点权转边权，将“路径和的GCD”转化为“差分约束的GCD”；  
- **数据结构**：带权并查集是维护差分约束的高效工具；  
- **边界处理**：先筛选“1能到达且能到达n”的点，避免无效计算；  
- **结果计算**：所有约束的GCD就是答案，注意处理“无解”（GCD为0时输出-1）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，帮大家建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了Ice_teapoy、exCat等题解的思路，清晰展示“拆点-合并-约束-求GCD”的完整流程。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
using LL = long long;

const int N = 6e5 + 10;
int n, m;
LL a[N];
int fa[N], dt[N], vis[N], vv[N]; // vv[i]：i是否在1→n的路径上
vector<int> e[N]; // 原图邻接表

int find(int x) {
    if (fa[x] == x) return x;
    int root = find(fa[x]);
    dt[x] += dt[fa[x]]; // 路径压缩时累加差值
    return fa[x] = root;
}

void dfs(int u) {
    vis[u] = 1;
    if (u == n) vv[u] = 1;
    for (int v : e[u]) {
        if (!vis[v]) dfs(v);
        if (vv[v]) vv[u] = 1; // 反向标记：能到达n的点
    }
}

LL gcd(LL a, LL b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= 2 * n; ++i) fa[i] = i; // 1~n:入点，n+1~2n:出点
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
    }

    // 筛选1→n路径上的点
    dfs(1);
    if (!vv[n]) { cout << "-1\n"; return 0; }

    // 合并原图边：u_out → v_in（即n+u → v）
    for (int u = 1; u <= n; ++u) {
        if (!vv[u]) continue;
        for (int v : e[u]) {
            if (!vv[v]) continue;
            int fu = find(n + u);
            int fv = find(v);
            if (fu != fv) fa[fu] = fv; // 边权为0，dt无需调整
        }
    }

    LL ans = 0;
    // 处理拆点边：u_in → u_out（即u → n+u），边权为a[u]
    for (int u = 1; u <= n; ++u) {
        cin >> a[u];
        if (!vv[u] || a[u] == -1) continue;
        int fu = find(u);
        int fv = find(n + u);
        if (fu == fv) {
            // 约束：dt[n+u] + a[u] ≡ dt[u] mod x → x | |dt[n+u] + a[u] - dt[u]|
            ans = gcd(ans, abs(dt[n + u] + a[u] - dt[u]));
        } else {
            // 合并：fu的父设为fv，dt[fu] = a[u] - dt[u]
            dt[fu] = a[u] - dt[u];
            fa[fu] = fv;
        }
    }

    // 检查1到n_out（2n）的路径是否有约束
    if (find(1) == find(2 * n)) {
        ans = gcd(ans, dt[1]); // dt[1]是1到2n的势能差
    }

    cout << (ans == 0 ? -1 : ans) << '\n';
    return 0;
}
```
* **代码解读概要**：  
1. **初始化**：带权并查集的父数组`fa`和差值数组`dt`，原图邻接表`e`；  
2. **筛选有效点**：用DFS标记“1能到达且能到达n”的点（`vv[u] = 1`）；  
3. **合并原图边**：将原图的u→v转化为u_out→v_in（n+u→v），合并并查集；  
4. **处理拆点边**：点权确定时，合并u_in和u_out，产生约束；  
5. **求GCD**：所有约束的GCD就是答案，处理无解情况。

---

<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

**题解二：(来源：EuphoricStar，赞：8)**  
* **亮点**：详细解释“拆点建图”的具体操作，代码结构清晰。  
* **核心代码片段**：
```cpp
// 拆点：u→u'（边权a[u]），原图u→v→u'→v（边权0）
for (int i = 1; i <= n; ++i) {
    if (a[i] != -1) {
        add_edge3(i, i + n, a[i]); // 拆点边：i→i+n，边权a[i]
        add_edge3(i + n, i, -a[i]);
    }
}
for (int i = 1; i <= m; ++i) {
    int a, b;
    scanf("%d %d", &a, &b);
    add_edge3(a + n, b, 0); // 原图边：a+n→b，边权0
    add_edge3(b, a + n, 0);
}
```
* **代码解读**：  
  - `add_edge3(i, i + n, a[i])`：将点i拆成i（入点）和i+n（出点），边权为a[i]；  
  - `add_edge3(a + n, b, 0)`：原图的a→b转化为a+n（出点）→b（入点），边权0。  
* **学习笔记**：拆点是将“点问题”转化为“边问题”的“魔法”，遇到路径和、点权相关的问题，先想想“能不能拆点”。

**题解四：(来源：Ice_teapoy，赞：4)**  
* **亮点**：带权并查集的完整实现，路径压缩时正确累加差值。  
* **核心代码片段**：
```cpp
int find(int x) {
    if (f[x] == x) return x;
    find(f[x]); // 先递归处理父节点
    dt[x] += dt[f[x]]; // 路径压缩：x的差值累加父节点的差值
    return f[x] = f[f[x]]; // 路径压缩到根
}
```
* **代码解读**：  
  - 递归找到根节点后，将x的差值`dt[x]`加上父节点的差值（因为父节点的差值已经更新到根）；  
  - 最后将x的父节点直接设为根，实现路径压缩。  
* **学习笔记**：路径压缩时必须先更新父节点的差值，否则会导致错误。  


## 5. 算法可视化：像素动画演示  

### **动画主题**：像素探险家的“约束寻宝记”  
### **设计思路**：  
用8位FC游戏风格模拟“拆点-合并-约束-寻宝”的过程，让学习像玩游戏一样有趣：  
- **场景初始化**：屏幕左侧是“点矩阵”（蓝色=入点，红色=出点），右侧是“控制面板”（开始/单步/重置按钮，速度滑块），背景是像素化的森林，伴随8位风格的轻快BGM。  
- **角色设定**：一个像素化的“探险家”（黄色方块），负责“合并”并查集和“收集”约束。  

### **动画帧步骤**：  
1. **拆点初始化**：点击“开始”，所有点会“分裂”成入点（左）和出点（右），伴随“咔嚓”的拆点音效；  
2. **筛选有效点**：探险家会用“荧光笔”（绿色框）标记“1能到达且能到达n”的点，无效点会变成灰色；  
3. **合并原图边**：探险家走到u_out（红色）和v_in（蓝色）旁，点击“合并”，两个点会“吸附”到根节点，伴随“叮”的音效；  
4. **处理拆点边**：点权确定时，探险家会用“魔法棒”（紫色）连接u_in和u_out，若已连通则弹出“约束”（橙色气泡显示差值），伴随“滴”的提示音；  
5. **求GCD**：所有约束收集完成后，探险家会打开“宝箱”（金色像素块），弹出最大GCD值，伴随胜利音效（“叮~叮~叮~”）。  

### **交互设计**：  
- **单步执行**：点击“下一步”，探险家执行一个操作，方便仔细观察；  
- **自动播放**：点击“自动”，探险家会以每秒2步的速度完成所有操作，适合快速浏览；  
- **重置**：点击“重置”，所有点回到初始状态，重新开始。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“差分约束+带权并查集”，以下问题能帮你巩固这一技巧：
</similar_problems_intro>

### **通用思路迁移**  
- **场景1**：求所有路径和的最小公倍数（类似，但约束是“x必须是路径和的倍数”，求最小x）；  
- **场景2**：判断图中是否存在负环（差分约束的经典应用，用SPFA算法）；  
- **场景3**：构造数组满足“a[i] - a[j] ≤ k”（差分约束系统，用最短路径求解）。

### **洛谷练习推荐**  
1. **洛谷 P2294 [HNOI2005] 狡猾的商人**（P2294）  
   * 🗣️ **推荐理由**：同样是差分约束问题，需要判断账本是否合法，直接应用带权并查集。  
2. **洛谷 P1991 无线通讯网**（P1991）  
   * 🗣️ **推荐理由**：带权并查集的经典应用，求最小生成树的变种，巩固“合并-差值”的思想。  
3. **洛谷 CF241E Flights**（CF241E）  
   * 🗣️ **推荐理由**：本题的“祖先题”，tzc_wk提到的结论就来自这道题，直接考察差分约束和带权并查集。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”能帮我们少走弯路：
</insights_intro>

> **参考经验 (来自：Ice_teapoy)**：“我最初忘记筛选‘有效点’，导致并查集合并了很多无关点，结果WA了好几次。后来用DFS标记能到达的点，才解决了问题。”  
> **点评**：筛选有效点是本题的“隐形要求”——无效点的合并会引入错误约束，导致答案错误。遇到路径问题时，先标记“起点能到达且能到达终点”的点，是避免错误的关键。

> **参考经验 (来自：exCat)**：“我一开始想‘不拆点’直接处理点权，结果发现约束条件太多，代码写得一团糟。后来改成拆点，代码立刻清晰了。”  
> **点评**：拆点是将“点问题”转化为“边问题”的关键技巧，遇到路径和、点权相关的问题，先试试拆点！  


## 8. 总结

本次分析帮大家梳理了“拆点-差分约束-带权并查集-求GCD”的完整流程。记住：  
- **问题转化**是关键（点权→边权，路径和→差分约束）；  
- **带权并查集**是工具（维护势能差，收集约束）；  
- **GCD**是结果（所有约束的最大公约数）。  

编程的乐趣在于“将复杂问题拆解成简单步骤”，希望这份指南能帮你找到解决问题的“钥匙”！💪


**Kay的小提醒**：如果对“带权并查集”或“差分约束”还有疑问，可以先做洛谷P2294（狡猾的商人），再回头看这道题，会更轻松哦！

---
处理用时：201.85秒
# 题目信息

# [ABC367G] Sum of (XOR^K or 0)

## 题目描述

给定正整数 $N, M, K$ 以及非负整数序列 $A=(A_1, A_2, \ldots, A_N)$。

对于任意非空的非负整数序列 $B=(B_1, B_2, \ldots, B_{|B|})$，定义其**得分**如下：

- 当 $B$ 的长度是 $M$ 的倍数时，得分为 $(B_1 \oplus B_2 \oplus \dots \oplus B_{|B|})^K$；
- 否则得分为 $0$。

其中，$\oplus$ 表示按位异或运算。

请计算 $A$ 的所有非空子序列（共 $2^N-1$ 个）各自的得分之和，并对 $998244353$ 取模后输出。

按位异或的定义如下：对于非负整数 $A, B$，$A \oplus B$ 的二进制表示中，第 $2^k$ 位（$k \geq 0$）的数等于 $A, B$ 的二进制表示中第 $2^k$ 位的数中恰有一个为 $1$ 时为 $1$，否则为 $0$。

例如，$3 \oplus 5 = 6$（二进制表示为：$011 \oplus 101 = 110$）。
一般地，$k$ 个整数 $p_1, \dots, p_k$ 的异或为 $(\cdots((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k)$，并且可以证明其结果与顺序无关。

## 说明/提示

### 限制条件

- $1 \leq N, K \leq 2 \times 10^5$
- $1 \leq M \leq 100$
- $0 \leq A_i < 2^{20}$
- 所有输入均为整数

### 样例解释 1

$A$ 的所有非空子序列（共 $2^3-1=7$ 个）各自的得分如下：

- $(1)$：$0$
- $(2)$：$0$
- $(3)$：$0$
- $(1,2)$：$(1\oplus2)^2=9$
- $(1,3)$：$(1\oplus3)^2=4$
- $(2,3)$：$(2\oplus3)^2=1$
- $(1,2,3)$：$0$

因此，总和为 $0+0+0+9+4+1+0=14$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 2 2

1 2 3```

### 输出

```
14```

## 样例 #2

### 输入

```
10 5 3

100 100 100 100 100 100 100 100 100 100```

### 输出

```
252000000```

## 样例 #3

### 输入

```
16 4 100

7053 3876 3178 8422 7802 5998 2334 6757 6889 6637 7365 9495 7848 9026 7312 6558```

### 输出

```
432440016```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC367G] Sum of (XOR^K or 0) 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：`FWT（快速沃尔什变换）+ 生成函数`  

🗣️ **初步分析**：  
想象你有一堆“数字积木”，每块积木上写着一个数`a_i`。现在要选一些积木，满足选的数量是`M`的倍数，然后把这些积木的异或和算出来，再求所有这样的异或和的`K`次方之和。这听起来很复杂，但**FWT**（快速沃尔什变换）和**生成函数**能帮我们把问题“拆解”成可计算的小块。  

简单来说，FWT就像一把“魔法钥匙”——它能把“异或卷积”（比如两个数组的异或组合）变成“点积”（直接对应位置相乘），这样多个多项式的乘积就能快速计算。而生成函数则是把“选或不选某个数”转化为数学表达式：每个数对应`(1 + x^{a_i} y)`，其中`x`管异或和，`y`管选的数量（模`M`循环）。我们的目标就是找到这个生成函数中`x^v y^0`的系数（即异或和为`v`且选的数量是`M`的倍数的方案数），再乘以`v^K`求和。  

**核心算法流程**：  
1. **生成函数设计**：每个元素对应`(1 + x^{a_i} y)`，求所有元素的乘积（`x`异或卷积，`y`循环卷积）。  
2. **FWT变换**：将异或卷积转化为点积，此时每个点的多项式变成`(1+y)^{c_w} (1-y)^{n-c_w}`（`c_w`是满足`popcount(w&a_i)`偶数的`a_i`数量）。  
3. **循环卷积处理**：预处理`(1+y)^i`和`(1-y)^i`的循环卷积（模`M`），计算每个点的`y^0`系数。  
4. **逆FWT**：将点积结果转换回原数组，得到每个异或和的方案数。  
5. **计算答案**：将每个异或和的方案数乘以`v^K`求和。  

**可视化设计思路**：  
用8位像素风展示“异或积木”的组合过程——每个`a_i`是一个彩色像素块，选它时会“点亮”对应的`x`和`y`维度。FWT变换时，像素块会按位“翻转”（展示`popcount`的奇偶性），循环卷积时`y`维度的像素块会“循环滚动”（模`M`）。关键步骤（如FWT的位操作、循环卷积的零次项计算）用高亮和音效（比如“叮”的一声）提示，帮助学习者聚焦核心逻辑。


## 2. 精选优质题解参考

### 题解一：小粉兔（综合评分：5星）  
* **点评**：这份题解的思路堪称“教科书级”——从生成函数的定义出发，一步步推导FWT的应用，逻辑链完整且易懂。代码实现极为高效：预处理`v`数组（计算每个`i`对应的循环卷积零次项系数）时，用`plus`和`minus`数组分别处理`(1+y)^i`和`(1-y)^i`的循环卷积，再合并得到`v[i]`。FWT的实现也很标准，注释清晰。最难得的是，作者在“后记”中提到自己从“线性基”转向“FWT”的思考过程，能帮助学习者理解“如何想到用FWT”。

### 题解二：yanzihe（综合评分：4.5星）  
* **点评**：这道题解从“代数推导”切入，适合有生成函数基础的学习者。作者详细证明了“如何通过FWT计算`1+y`和`1-y`的次数”（引理1和引理2），把抽象的FWT转化为具体的“统计奇偶次数”问题。代码中`multiply0`函数直接计算循环卷积的零次项，避免了完整卷积的冗余计算，非常巧妙。美中不足的是，代码中的`FWT_XOR`函数参数处理略复杂，需要学习者仔细理解。

### 题解三：qczrz6v4nhp6u（综合评分：4.5星）  
* **点评**：题解的“一句话总结”非常到位——“答案即为所有异或和的`K`次方乘以对应方案数之和”。作者抓住了问题的核心，用简洁的语言解释了FWT的应用：每个点的FWT结果是`(1+y)^{u_i}(1-y)^{v_i}`，预处理幂次后直接取`y^0`系数。代码中的`mul`函数处理循环卷积，`FWT`和`IFWT`的实现很简洁，适合初学者模仿。


## 3. 核心难点辨析与解题策略

### 🔑 核心难点1：如何将“异或和”与“长度约束”结合？  
* **分析**：直接枚举所有子序列显然不可行（`N`到`2e5`）。解决方案是用**二元生成函数**：`x`管异或和（异或卷积），`y`管长度（循环卷积，模`M`）。这样两个约束可以同时处理，生成函数的乘积就是所有可能的子序列情况。  
* 💡 学习笔记：二元生成函数是处理“多约束问题”的利器，关键是找到每个约束对应的“卷积类型”。

### 🔑 核心难点2：如何计算FWT后的点值？  
* **分析**：FWT后的每个点对应`(1+y)^{c_w} (1-y)^{n-c_w}`，其中`c_w`是`popcount(w&a_i)`偶数的`a_i`数量。解决方案是对输入数组的“计数数组”做FWT，得到每个`w`对应的`c_w - (n - c_w)`，从而解出`c_w`。  
* 💡 学习笔记：FWT的线性性是关键——多个函数的FWT之和等于它们的和的FWT。

### 🔑 核心难点3：如何高效处理循环卷积？  
* **分析**：`M`最大是`100`，可以`O(nm)`预处理`(1+y)^i`和`(1-y)^i`的循环卷积（模`M`）。这样每个`i`对应的`y^0`系数可以快速计算。  
* 💡 学习笔记：预处理是降低复杂度的关键，尤其是当`M`较小时，循环卷积的预处理成本很低。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了小粉兔、yanzihe等题解的思路，聚焦核心逻辑，去掉冗余细节。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef long long ll;
const int Mod = 998244353;
const int B = 20, V = 1 << B, iV = Mod - ((Mod - 1) >> B);

int qPow(int b, int e) {
    int a = 1;
    for (; e; e >>= 1, b = (ll)b * b % Mod)
        if (e & 1) a = (ll)a * b % Mod;
    return a;
}

int main() {
    int n, m, k;
    cin >> n >> m >> k;

    // 预处理v数组：v[i] = [y^0] (1+y)^i (1-y)^{n-i}（循环卷积模m）
    vector<int> v(n + 1, 0);
    vector<vector<int>> plus(n + 1, vector<int>(m, 0));
    vector<vector<int>> minus(n + 1, vector<int>(m, 0));
    plus[0][0] = minus[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < m; ++j) {
            int prev_j = j ? j - 1 : m - 1;
            plus[i][j] = (plus[i-1][j] + plus[i-1][prev_j]) % Mod;
            minus[i][j] = (minus[i-1][j] - minus[i-1][prev_j] + Mod) % Mod;
        }
    }
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j < m; ++j) {
            int mj = j ? m - j : 0;
            v[i] = (v[i] + (ll)plus[i][j] * minus[n - i][mj] % Mod) % Mod;
        }
    }

    // 处理输入，构建计数数组f
    vector<int> f(V, 0);
    for (int i = 1; i <= n; ++i) {
        int a;
        cin >> a;
        ++f[a];
    }

    // FWT变换（异或卷积）
    for (int j = 0; j < B; ++j) {
        for (int i = 0; i < V; ++i) {
            if (!(i >> j & 1)) {
                int x = f[i], y = f[i | (1 << j)];
                f[i] = (x + y) % Mod;
                f[i | (1 << j)] = (x - y + Mod) % Mod;
            }
        }
    }

    // 计算每个点的v值
    for (int i = 0; i < V; ++i) {
        f[i] = v[(f[i] + n) / 2];
    }

    // 逆FWT变换
    for (int j = 0; j < B; ++j) {
        for (int i = 0; i < V; ++i) {
            if (!(i >> j & 1)) {
                int x = f[i], y = f[i | (1 << j)];
                f[i] = (ll)(x + y) * iV % Mod;
                f[i | (1 << j)] = (ll)(x - y + Mod) * iV % Mod;
            }
        }
    }

    // 计算答案
    int ans = 0;
    for (int i = 0; i < V; ++i) {
        ans = (ans + (ll)f[i] * qPow(i, k) % Mod) % Mod;
    }
    cout << ans << endl;

    return 0;
}
```
* **代码解读概要**：  
  1. **预处理v数组**：用`plus`和`minus`数组分别计算`(1+y)^i`和`(1-y)^i`的循环卷积（模`M`），再合并得到每个`i`对应的`y^0`系数`v[i]`。  
  2. **构建计数数组**：统计每个`a_i`出现的次数，存入`f`数组。  
  3. **FWT变换**：对`f`数组做异或FWT，得到每个`w`对应的`c_w`（通过`(f[w] + n)/2`计算）。  
  4. **计算点值**：将每个`w`的`c_w`代入`v`数组，得到FWT后的点值。  
  5. **逆FWT**：将点值转换回原数组，得到每个异或和的方案数。  
  6. **计算答案**：将每个异或和的方案数乘以`i^k`，求和得到最终结果。


### 题解一（小粉兔）核心片段赏析  
* **亮点**：预处理`v`数组时，用循环卷积直接计算`(1+y)^i`和`(1-y)^i`的零次项系数，避免了冗余计算。  
* **核心代码片段**：  
```cpp
vector<vector<int>> plus(n + 1, vector<int>(m, 0));
vector<vector<int>> minus(n + 1, vector<int>(m, 0));
plus[0][0] = minus[0][0] = 1;
for (int i = 1; i <= n; ++i) {
    for (int j = 0; j < m; ++j) {
        int prev_j = j ? j - 1 : m - 1;
        plus[i][j] = (plus[i-1][j] + plus[i-1][prev_j]) % Mod;
        minus[i][j] = (minus[i-1][j] - minus[i-1][prev_j] + Mod) % Mod;
    }
}
```
* **代码解读**：  
  `plus[i][j]`表示`(1+y)^i`的循环卷积中`y^j`的系数——每选一个元素，`y`的次数加1（模`M`）。`minus[i][j]`类似，但每次选元素时`y`的系数乘`-1`（所以用减法）。比如，`plus[i][j]`的递推式是“不选当前元素（`plus[i-1][j]`）+ 选当前元素（`plus[i-1][prev_j]`，`prev_j`是`j-1`模`M`）”。  
* **学习笔记**：循环卷积的递推式要注意“模`M`”的处理——当`j=0`时，前一个位置是`M-1`。


## 5. 算法可视化：像素动画演示

### 动画主题：`像素积木的异或冒险`  
**设计思路**：用8位FC游戏风格展示异或和与长度约束的结合过程，让学习者像“玩游戏”一样理解算法。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是“异或积木区”：每个`a_i`是一个彩色像素块（比如红色代表`1`，蓝色代表`2`，绿色代表`3`）。  
   - 屏幕右侧是“FWT控制台”：展示当前的`w`值（二进制像素）、`c_w`（`1+y`的次数）、`v[c_w]`（循环卷积零次项系数）。  
   - 底部是“控制面板”：包含“开始/暂停”“单步”“重置”按钮，以及速度滑块（1x~5x）。  

2. **算法启动**：  
   - 点击“开始”后，像素积木依次“飞入”异或积木区，伴随“咻”的音效。  
   - 初始化`plus`和`minus`数组：用像素条展示`(1+y)^i`和`(1-y)^i`的循环卷积系数，每增加一个`i`，像素条会“延伸”一段。  

3. **FWT变换**：  
   - 对计数数组`f`做FWT时，每个位`j`会“翻转”：比如处理第`j`位时，所有`i`的`j`位为0的像素块会和`i | (1<<j)`的像素块交换颜色（展示`x + y`和`x - y`的计算）。  
   - 每个`w`的`c_w`会用数字像素展示（比如`c_w=2`会显示“2”），伴随“叮”的音效。  

4. **循环卷积处理**：  
   - 计算`v[i]`时，`plus[i][j]`和`minus[n-i][mj]`的乘积会用“合并像素块”展示：比如`plus[i][j]`是红色像素，`minus[n-i][mj]`是蓝色像素，合并后是紫色像素，代表它们的乘积。  
   - 每个`v[i]`的结果会显示在“FWT控制台”的右侧，伴随“嗒”的音效。  

5. **逆FWT与结果展示**：  
   - 逆FWT时，像素块会“反向翻转”，恢复到原数组的颜色。  
   - 最终的异或和方案数会用柱状图展示（比如异或和`3`的柱子高度是`f[3]`），点击柱子会显示对应的`3^K`值，伴随“胜利”音效。  

### 交互设计  
- **单步执行**：点击“单步”按钮，算法执行一步（比如处理一个`i`的`plus`数组），当前操作的像素块会高亮。  
- **自动播放**：调整速度滑块，算法会自动执行，适合快速浏览整体流程。  
- **重置**：点击“重置”按钮，所有像素块回到初始状态，方便重新学习。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
FWT+生成函数的组合不仅能解决本题，还能处理**“多约束下的异或和问题”**，比如：  
- 选`k`个元素，异或和为`0`的方案数；  
- 选元素的数量是偶数，异或和为`x`的方案数；  
- 带权异或和的统计问题（比如每个元素有一个权值，求权值和的最大值）。  

### 练习推荐（洛谷）  
1. **P3705 【[SDOI2017] 新生舞会】**：用FWT处理异或卷积，结合生成函数统计方案数。  
   - 推荐理由：巩固“二元生成函数+FWT”的应用。  
2. **P4717 【[模板] 快速沃尔什变换】**：FWT的模板题，熟悉异或、或、与卷积的变换方式。  
   - 推荐理由：打好FWT的基础，理解变换的本质。  
3. **P5387 【[CSP-S2019] 树的重心】**：虽然不是异或问题，但涉及生成函数的卷积，锻炼生成函数思维。  
   - 推荐理由：拓展生成函数的应用场景。  


## 7. 学习心得与经验分享  
**参考经验（来自小粉兔）**：“我本来想的线性基，在提示做法涉及FWT后想出来了，所以总体上算独立做出的。”  
**点评**：这说明“联想类似问题”是解题的关键——线性基和FWT都能处理异或问题，但FWT更适合处理“计数”或“卷积”问题。当线性基无法解决时，不妨尝试FWT，尤其是当问题涉及“多个元素的异或组合”时。  


## 总结  
本次分析的核心是**FWT与生成函数的结合**，通过将异或卷积转化为点积，快速处理多约束的计数问题。希望这份指南能帮助你理解FWT的应用场景，掌握生成函数的设计技巧。记住：算法的本质是“问题的转化”——把复杂的问题拆解成可计算的小块，再用工具（比如FWT）解决。下次遇到异或计数问题时，不妨想想“能不能用FWT+生成函数？”，你会发现很多问题都能迎刃而解！💪

---
处理用时：88.00秒
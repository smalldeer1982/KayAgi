# 题目信息

# [ABC284Ex] Count Unlabeled Graphs

## 题目描述

你需要通过以下一系列操作生成一个图。

- 自由选择一个没有顶点标签的 $N$ 个顶点的简单无向图。
- 给图的每个顶点各写上一个不超过 $K$ 的正整数。要求 $1$ 到 $K$ 的每个正整数都必须被写在某个顶点上，不能有遗漏。

请计算通过上述操作可能得到的不同图的数量，并对 $P$ 取模后输出（$P$ 是**素数**）。

注意，如果两个图可以分别给顶点加上标签 $v_1, v_2, \dots, v_N$，使得满足以下条件，则认为这两个图是相同的：

- 对于所有 $1 \leq i \leq N$，顶点 $v_i$ 上写的数在两个图中相同。
- 对于所有 $1 \leq i < j \leq N$，$v_i$ 和 $v_j$ 之间是否有边在两个图中相同。

## 说明/提示

## 限制

- $1 \leq K \leq N \leq 30$
- $10^8 \leq P \leq 10^9$
- $P$ 是素数
- 输入的所有值均为整数

## 样例解释 1

满足条件的图有如下 $4$ 种。 ![image](https://img.atcoder.jp/ghi/abc283h_43c4abe0e541b7ebeaa8db2854cece91caeca71f03f452ca13c11e82f85e3a56.png)

## 样例解释 2

满足条件的图有如下 $12$ 种。 ![image2](https://img.atcoder.jp/ghi/abc284h2_ca96b7cb451b0e495209e3e201576d278de3fb823e5d2404bbce5d9f704e3259.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3 1 998244353```

### 输出

```
4```

## 样例 #2

### 输入

```
3 2 998244353```

### 输出

```
12```

## 样例 #3

### 输入

```
5 5 998244353```

### 输出

```
1024```

## 样例 #4

### 输入

```
30 15 202300013```

### 输出

```
62712469```

# AI分析结果

---
# 💡 Kay的C++算法解析：Count Unlabeled Graphs 深入学习指南 💡

<introduction>
今天我们来挑战一道结合**群论**与**组合数学**的C++编程题——「Count Unlabeled Graphs」。这道题需要我们计算“带颜色约束的无标号图”数目，核心是利用**Burnside引理**解决同构计数问题。通过本指南，你将理解群论在编程中的应用，掌握分拆枚举、容斥原理等关键技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（群论应用：Burnside引理）`

🗣️ **初步分析**：
解决“无标号结构计数”问题，**Burnside引理**是核心工具——它的核心思想可以比喻为：“要统计不同样式的玩具数目，先看所有‘旋转/翻转’操作下不变的玩具（不动点），再取这些数的平均值”。在本题中：
- **“玩具”**：带颜色的无标号图（顶点无标签，颜色满足1~K各出现一次）；
- **“旋转/翻转”**：顶点的置换操作（把顶点重新标号，但图结构和颜色分配不变）；
- **“平均值”**：所有置换的不动点数目之和除以置换总数（即n!，因为n个顶点的置换有n!种）。

### 题解核心思路
所有题解都围绕以下步骤展开：
1. **枚举置换的循环类型**：将n个顶点拆分成若干个“循环”（比如n=3可以拆成[3]、[2,1]、[1,1,1]）——这一步是枚举n的**分拆**（Partition）；
2. **计算每个循环类型的不动点数目**：
   - **边的条件**：同一循环内的边或不同循环间的边，必须满足“置换后不变”——等价于边被划分为若干“等价类”，每个类要么全选、要么不选（故边的方案数是2的等价类数目次方）；
   - **颜色的条件**：同一循环内的顶点颜色必须相同，且所有K种颜色都出现——用**容斥原理**计算合法染色数；
3. **累加贡献**：每个循环类型的贡献是“置换数目 × 边方案数 × 颜色方案数”，最后总和除以n!（Burnside的平均值）。

### 可视化设计思路
为了直观理解“循环类型”和“不动点计算”，我设计了**8位像素风动画**：
- **场景**：屏幕左侧是n个像素顶点（比如n=3时是3个彩色方块），右侧是“循环类型枚举器”（显示当前分拆，如[2,1]）；
- **关键动画**：
  1. 分拆枚举时，顶点会被“圈”成不同的循环（比如[2,1]会用红色圈住2个顶点，蓝色圈住1个）；
  2. 颜色分配时，同一循环内的顶点会同步变色（比如红色循环全变黄色，蓝色循环全变绿色）；
  3. 边的选择时，等价类的边会同步闪烁（比如循环内的边“叮”一声后全亮或全灭）；
- **交互**：支持“单步枚举分拆”“自动播放计算贡献”，完成所有分拆后播放“胜利音效”（8位机风格的轻快音调）。


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**、**代码可读性**、**算法有效性**三个维度筛选了以下优质题解，它们都准确应用了Burnside引理，且各有亮点：
</eval_intro>

**题解一：(来源：xtx1092515503)**
* **点评**：这份题解的代码结构最清晰，用`dfs`枚举分拆的逻辑直白易懂。它将“置换数目计算”（`way`变量）、“颜色容斥”（`ser`变量）、“边方案数”（`qwq`变量）拆分成独立步骤，每一步的注释和变量命名都很友好。特别是`mina`函数中对分拆的处理，完美对应了Burnside引理的每个环节，适合初学者模仿。

**题解二：(来源：xlpg0713)**
* **点评**：此题解的优势是**数学推导简洁**，直接给出了边方案数和颜色方案数的公式。代码中用`a`数组存储循环大小，`c`数组统计每个循环大小的出现次数，计算置换数目时的“除以乘积”逻辑非常严谨。美中不足的是变量名稍显抽象，但整体思路和题解一高度一致。

**题解三：(来源：zhouyuhang)**
* **点评**：这份题解的文字说明最透彻，明确指出“边的等价类数目”和“颜色的稳定子数目”是独立的，因此不动点数目是两者的乘积。它还补充了“颜色容斥”的推导过程，帮助理解为什么要用`sum_{i=0}^k (-1)^i C(k,i) (k-i)^{c(g)}`，适合想深入理解数学原理的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
本题的难点集中在“将抽象的群论转化为可计算的代码”，以下是三个核心难点及解决策略：
</difficulty_intro>

1.  **关键点1：如何枚举所有分拆（循环类型）？**
    * **难点**：n的分拆是“将n拆成若干正整数之和，不考虑顺序”（比如3的分拆是[3],[2,1],[1,1,1]），直接枚举容易重复或遗漏。
    * **解决方案**：用**深度优先搜索（DFS）**枚举分拆，限制“下一个循环的大小不超过当前循环”（比如当前循环是2，下一个只能是2或更小），避免重复。例如题解一中的`dfs(rem-i, i)`就是这个逻辑。
    * 💡 **学习笔记**：分拆枚举的核心是“降序限制”，确保每个分拆只被枚举一次。

2.  **关键点2：如何计算置换数目？**
    * **难点**：同一分拆对应的置换数目不是1，而是`n! / (乘积（循环大小 × 循环大小出现次数的阶乘）)`（比如分拆[2,1]对应的置换数目是3!/(2×1!×1×1!)=3）。
    * **解决方案**：预处理阶乘`fac`和逆元`inv`，用组合数计算。例如题解一中的`way`变量计算：`way = C(rem, v[j]) * fac[v[j]-1] * ... / inv[r-l]`，其中`C(rem, v[j])`是选v[j]个顶点组成循环，`fac[v[j]-1]`是循环的排列方式（一个大小为t的循环有(t-1)!种排列），`inv[r-l]`是除以相同循环大小的出现次数的阶乘。
    * 💡 **学习笔记**：置换数目的公式是Burnside引理的关键，必须牢记“分拆对应的置换数目 = n! / (乘积（t^c × c!）)”（t是循环大小，c是t的出现次数）。

3.  **关键点3：如何处理“每个颜色至少出现一次”？**
    * **难点**：直接计算“每个循环染一种颜色，且1~K都出现”的方案数比较困难，因为要排除“缺少某些颜色”的情况。
    * **解决方案**：**容斥原理**。先计算“用i种颜色染m个循环（m是分拆的循环个数）”的方案数（`i^m`），再用二项式反演去掉“缺少颜色”的情况，最终得到：`sum_{i=0}^k (-1)^{k-i} C(k,i) i^m`。例如题解一中的`ser`变量就是这个容斥的结果。
    * 💡 **学习笔记**：容斥是处理“至少出现一次”问题的万能工具，核心是“加总所有可能，减去不符合条件的”。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合优质题解的通用核心实现**，它涵盖了分拆枚举、不动点计算、容斥的全部逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一、二的思路，优化了变量命名，更适合初学者理解。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

int n, k, mod, res;
long long fac[40], inv[40];

long long ksm(long long x, int y) {
    long long z = 1;
    for (; y; y >>= 1, x = x * x % mod)
        if (y & 1) z = z * x % mod;
    return z;
}

void precompute() {
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) fac[i] = fac[i-1] * i % mod;
    inv[n] = ksm(fac[n], mod-2);
    for (int i = n-1; i >= 0; --i) inv[i] = inv[i+1] * (i+1) % mod;
}

long long C(int a, int b) {
    if (a < b || b < 0) return 0;
    return fac[a] * inv[b] % mod * inv[a - b] % mod;
}

vector<int> part; // 当前分拆（循环大小的列表）

void calculate_contribution() {
    // 1. 计算该分拆对应的置换数目：way = n! / (乘积（t^c * c!）)
    long long way = fac[n];
    vector<int> cnt(n+1, 0); // cnt[t]：循环大小t的出现次数
    for (int t : part) cnt[t]++;
    for (int t = 1; t <= n; ++t) {
        if (cnt[t] == 0) continue;
        way = way * ksm(t, cnt[t]) % mod; // 除以t^cnt[t]（等价于乘逆元）
        way = way * inv[cnt[t]] % mod;     // 除以cnt[t]!（等价于乘逆元）
    }

    // 2. 计算颜色的不动点数目：容斥结果
    int m = part.size(); // 循环个数
    long long color = 0;
    for (int i = 0; i <= k; ++i) {
        long long term = C(k, i) * ksm(i, m) % mod;
        if ((k - i) % 2 == 1) term = (mod - term) % mod;
        color = (color + term) % mod;
    }

    // 3. 计算边的不动点数目：2^(循环内边等价类 + 循环间边等价类)
    long long edges = 0;
    for (int t : part) edges += t / 2; // 循环内的边等价类数目（每个循环t有t//2个）
    for (int i = 0; i < part.size(); ++i)
        for (int j = i+1; j < part.size(); ++j)
            edges += __gcd(part[i], part[j]); // 循环间的边等价类数目
    long long edge_ways = ksm(2, edges);

    // 4. 贡献累加：way * color * edge_ways
    res = (res + way * color % mod * edge_ways % mod) % mod;
}

void dfs(int remaining, int max_size) {
    if (remaining == 0) {
        calculate_contribution();
        return;
    }
    for (int t = 1; t <= max_size && t <= remaining; ++t) {
        part.push_back(t);
        dfs(remaining - t, t); // 下一个循环大小不超过t（降序限制）
        part.pop_back();
    }
}

int main() {
    cin >> n >> k >> mod;
    precompute();
    dfs(n, n);
    // Burnside引理：结果 = 总贡献 / n!（等价于乘inv[n]）
    res = res * inv[n] % mod;
    cout << res << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **预处理**：`precompute`函数计算阶乘`fac`和逆元`inv`（用于快速求组合数和置换数目）；
  2. **分拆枚举**：`dfs`函数用“降序限制”枚举所有分拆，每次递归将`remaining`减去当前循环大小`t`；
  3. **贡献计算**：`calculate_contribution`函数计算每个分拆的三项贡献（置换数目、颜色方案、边方案），并累加到结果；
  4. **最终结果**：根据Burnside引理，总贡献除以`n!`（即乘`inv[n]`）得到答案。

<code_intro_selected>
接下来分析题解一中的核心片段，看看它如何实现“分拆的置换数目计算”：
</code_intro_selected>

**题解一：(来源：xtx1092515503)**
* **亮点**：用`l`和`r`双指针统计相同循环大小的出现次数，代码更高效。
* **核心代码片段**：
```cpp
void mina() {
    int way = 1, rem = n;
    for (int l = 0, r = 0; l < v.size(); l = r) {
        for (; r < v.size() && v[l] == v[r]; r++);
        for (int j = l; j < r; j++) 
            way = 1ll * way * C(rem, v[j]) % mod * fac[v[j]-1] % mod, rem -= v[j];
        way = 1ll * way * inv[r-l] % mod;
    }
    // ... 后续计算颜色和边的贡献
}
```
* **代码解读**：
  - `l`和`r`是双指针，`v`是当前分拆的循环大小列表（比如[2,2,1]）；
  - 内层循环`j`计算“选v[j]个顶点组成循环”的组合数（`C(rem, v[j])`），以及循环的排列方式（`fac[v[j]-1]`，因为t个顶点的循环有(t-1)!种）；
  - 最后乘`inv[r-l]`是除以“相同循环大小的出现次数的阶乘”（比如[2,2,1]中2出现2次，所以除以2!）。
* 💡 **学习笔记**：双指针统计相同元素的出现次数，是处理分拆的常用技巧，能避免额外的`cnt`数组。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”Burnside引理的计算过程，我设计了一个**8位像素风的动画**——《像素图灵的计数游戏》，用复古游戏元素模拟分拆枚举和不动点计算：
</visualization_intro>

  * **动画演示主题**：像素化的“图灵机”在网格中枚举分拆，计算每个分拆的贡献，最终汇总得到答案。
  * **核心演示内容**：
    1. **分拆枚举**：屏幕左侧显示n个像素顶点（比如n=3时是3个彩色方块），右侧显示当前分拆（如[2,1]）。枚举分拆时，顶点会被“圈”成不同的循环（红色圈住2个，蓝色圈住1个）；
    2. **颜色分配**：同一循环内的顶点同步变色（比如红色循环变黄色，蓝色循环变绿色），并显示“颜色方案数：X”（容斥后的结果）；
    3. **边的选择**：循环内的边会同步闪烁（比如[2]循环的边“叮”一声后全亮），循环间的边会用“箭头”连接（比如[2]和[1]之间的边“叮”一声后全灭），并显示“边方案数：2^Y”；
    4. **贡献累加**：每个分拆计算完成后，底部的“总贡献”数字会增加，完成所有分拆后播放“胜利音效”（8位机风格的`Do-Re-Mi`）。
  * **交互与控制**：
    - 控制面板：“单步枚举”（点击一次走一个分拆）、“自动播放”（每秒走一个分拆，速度可调）、“重置”（回到初始状态）；
    - 音效：分拆枚举时播放“咔嗒”声，颜色分配时播放“滴”声，边选择时播放“叮”声，胜利时播放“啦啦啦”声；
    - 复古元素：背景是FC游戏的“星空”像素图，图灵机是一个像素化的小机器人，每完成一个分拆会“跳一下”。
  * **设计思路**：用**可视化的分拆**和**同步的数值变化**，将抽象的Burnside引理转化为“可观察的过程”。比如“循环圈”让你直观看到分拆的结构，“同步变色”让你理解“同一循环内颜色相同”的条件，“边闪烁”让你明白“等价类必须全选或全不选”的规则。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
Burnside引理是组合计数的“瑞士军刀”，掌握它后可以解决很多类似问题。以下是几道拓展练习：
</similar_problems_intro>

  * **通用思路迁移**：
    - 无标号树计数：用Burnside引理枚举树的分拆，计算不同构的树数目；
    - 带权图计数：将边的“选或不选”改为“选不同权重”，只需调整边的不动点数目计算；
    - 染色问题：比如“用k种颜色染立方体的面，求不同构的数目”，核心是枚举立方体的置换（旋转、翻转），计算每个置换的不动点数目。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4727** - 无标号无向图计数
          * 🗣️ **推荐理由**：本题的“简化版”（k=1，不需要颜色条件），直接应用Burnside引理，适合巩固分拆枚举和边方案数计算。
    2.  **洛谷 P4128** - 集合计数
          * 🗣️ **推荐理由**：用容斥原理解决“至少包含k个元素”的问题，和本题的颜色条件异曲同工，适合练习容斥技巧。
    3.  **洛谷 P5898** - [THUPC2019] 鸽鸽的分割
          * 🗣️ **推荐理由**：结合分拆枚举和组合数学，需要用Burnside引理计算不同的分割方式，适合挑战进阶应用。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中没有明确的个人心得，但我想补充**两个关键经验**，帮你避免踩坑：
</insights_intro>

> **经验1**：预处理阶乘和逆元时，一定要注意模数是素数！本题中P是素数，所以可以用费马小定理求逆元（`inv[x] = x^(P-2) mod P`）。如果P不是素数，需要用扩展欧几里得算法求逆元。
> 
> **经验2**：分拆枚举时，“降序限制”是关键！比如枚举[2,1]而不是[1,2]，否则会重复计算同一分拆的贡献，导致结果错误。


<conclusion>
本次关于“Count Unlabeled Graphs”的分析就到这里！这道题的核心是**Burnside引理**，但难点在于将抽象的群论转化为可计算的代码——分拆枚举、置换数目、容斥原理，每一步都需要精准的数学推导。记住：**编程是数学的工具**，只有理解了数学原理，才能写出正确的代码！

下次我们会挑战更复杂的群论问题，比如“带权无标号图计数”，敬请期待！💪
</conclusion>

---

---
处理用时：94.14秒
# 题目信息

# [AGC066E] Sliding Puzzle On Tree

## 题目描述

给定一棵有 $N$ 个顶点的树，顶点编号为 $1$ 到 $N$。树的第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$。

对于 $K=1,2,\ldots,N$，请解决以下问题：

> 有 $K$ 个编号为 $1,2,\ldots,K$ 的石子，第 $i$ 个石子初始放在顶点 $i$。你可以重复进行如下操作：
>
> - 选择一条连接顶点 $u$ 和 $v$ 的树边，且 $u$ 上有石子而 $v$ 上没有石子。将 $u$ 上的石子移动到 $v$ 上。
>
> 求所有可能的石子最终分布方案数，答案对 $998244353$ 取模。注意，如果某个编号的石子所在顶点不同，则认为是不同的分布方案。

给定 $T$ 组测试数据，请分别输出每组的答案。

## 说明/提示

### 限制

- $1\leq T\leq 10^5$
- $1\leq N\leq 2\times 10^5$
- $1\leq u_i, v_i\leq N$
- 给定的图一定是一棵树。
- 所有测试数据中 $N$ 的总和不超过 $2\times 10^5$。

### 样例解释 1

用编号为 $1,2,\ldots,K$ 的石子所在顶点的编号序列表示石子的分布方案时：

- $K=1$ 时，可能的分布方案为 $(1), (2), (3), (4)$，共 $4$ 种。
- $K=2$ 时，可能的分布方案为 $(1,2), (1,3), (1,4), (2,1), (2,3), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,3)$，共 $12$ 种。
- $K=3$ 时，可能的分布方案为 $(1,2,3), (4,1,3), (4,2,1), (4,2,3)$，共 $4$ 种。
- $K=4$ 时，可能的分布方案为 $(1,2,3,4)$，共 $1$ 种。

对于 $K=3$ 的情况，可以参考下图：  
![](https://img.atcoder.jp/agc066/f2dc57ae01aa4f1ccb51c1a2b8fe7d15.png)

### 样例解释 2

每组测试数据对应的树结构如下图所示：  
![](https://img.atcoder.jp/agc066/744a8d907603331334518cc5d7b62bb9.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1

4

1 2

1 3

1 4```

### 输出

```
4 12 4 1```

## 样例 #2

### 输入

```
4

1

5

1 4

5 2

3 4

2 1

7

1 7

2 7

5 6

4 1

1 6

3 6

10

1 2

2 3

3 4

4 5

5 6

2 7

3 8

4 9

5 10```

### 输出

```
1

5 10 10 5 1

7 42 210 840 84 7 1

10 90 720 5040 30240 151200 604800 720 10 1```

# AI分析结果

---
# 💡 Kay的C++算法解析：AGC066E Sliding Puzzle On Tree 深入学习指南 💡

<introduction>
今天我们要一起攻克「AGC066E 树上滑动谜题」这道题。这道题的核心是**用并查集维护等价类**结合**组合数学**，需要我们理解「哪些石子可以互相交换位置」，并通过「时光倒流」的技巧高效计算每个K对应的方案数。让我们一步步拆解问题吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`并查集维护等价类 + 组合数学`（属于「编程技巧应用」下的**等价类划分与集合维护**）

🗣️ **初步分析**：
解决这道题的关键，是理解**「等价类」**——就像教室里同一组的小朋友可以互相换座位，不影响其他组的排列；**能互相交换位置的石子属于同一等价类**，它们的相对顺序可以任意调整，而不同等价类的石子顺序固定。  

### 核心问题转化
题目要求计算K个石子的最终分布方案数，等价于：
1. 从n个节点中选K个位置放石子（组合数$\binom{n}{k}$）；
2. 同一等价类的石子可以任意交换（乘以各等价类大小的阶乘$\prod s_i!$）。

### 等价类的关键性质
两个石子能交换的条件：**它们所在的「中间全是二度点、两端非二度点的链」满足「K足够小」**（即链上能留出空位置作为交换的「缓冲区」）。例如，当链的长度为c时，若K < n - c，链两端的石子可以交换，对应等价类合并。

### 算法流程与可视化设计思路
1. **预处理**：找到树中所有「中间全是二度点的链」（用DFS遍历，记录链的两端和长度）；
2. **时光倒流**：K从n到1递减，逐步合并满足条件的链两端的等价类（用并查集维护连通块的大小` siz`和非二度点的度数`out`）；
3. **计算答案**：对每个K，用组合数乘各连通块对应的阶乘（$\binom{n}{k} \times \prod \text{fac}[(out[i]-1)*(n-k-1)+siz[i]-1]$）。

### 可视化设计预告
我们会用**8位像素风树**展示算法过程：
- 节点用不同颜色的像素块表示，连通块（等价类）用同色系区分；
- K从大到小递减时，**单步动画**展示链两端的连通块合并（比如两个颜色块渐变为同一颜色，伴随「叮」的像素音效）；
- 用「进度条」显示当前K值，「自动播放」时模拟时光倒流的合并过程；
- 最终方案数计算完成时，播放上扬的「胜利音效」，并高亮结果。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性三个维度，为大家筛选了以下优质题解：
</eval_intro>

**题解一：作者ZnPdCo（代码完整，思路清晰）**
* **点评**：这份题解的核心亮点是「时光倒流+并查集」的巧妙结合。作者先通过DFS找到所有「中间全是二度点的链」，再将K从n到1递减，逐步合并满足条件的链两端（当K < n - 链长时）。代码结构规范：`dfs`函数负责找链，`merge`函数维护并查集，`qpow`计算逆元。尤其是**组合数与阶乘的结合**（$\text{ans}[k] = \binom{n}{k} \times \prod \text{fac}[...]$），直接对应问题的核心逻辑，非常容易理解。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于「等价类的划分」和「高效维护」，以下是三个核心难点及应对策略：
</difficulty_intro>

1. **难点1：如何定义「可交换的石子」？**
   * **分析**：能交换的石子需要满足「存在一条中间全是二度点的链，且K足够小」。例如，链长为c时，K < n - c意味着链上有空位置作为交换的「缓冲区」。
   * 💡 **学习笔记**：「中间全是二度点的链」是等价类合并的关键条件，要学会用DFS遍历树找这类链。

2. **难点2：如何高效维护等价类？**
   * **分析**：直接从小到大处理K会导致合并操作难以维护，因此**时光倒流**（K从大到小）是关键——随着K减小，满足条件的链越来越多，用并查集逐步合并连通块即可。
   * 💡 **学习笔记**：「正难则反」是常用技巧，当正向处理复杂时，尝试逆向思考。

3. **难点3：如何计算等价类的大小？**
   * **分析**：每个连通块的「可交换石子数」由`out`（连通块中非二度点的度数）和`siz`（连通块大小）决定，公式为$\text{fac}[(out[i]-1)*(n-k-1)+siz[i]-1]$。
   * 💡 **学习笔记**：组合数学中的「阶乘乘积」对应等价类的任意排列，要牢记「方案数=组合数×阶乘乘积」的模型。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**（基于ZnPdCo的题解），帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了「找链+并查集+时光倒流」的核心逻辑，是解决本题的典型实现。
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  typedef long long ll;
  const int N = 2e5 + 10, P = 998244353;

  ll t, n, cnt, tot, pos;
  ll head[N], deg[N], fa[N], siz[N], out[N], ans[N], fac[N], ifac[N];
  set<ll> s;

  struct Edge { ll a, b, c; } edge[N];
  struct TreeEdge { ll to, nxt; } e[N << 1];

  void addTreeEdge(ll u, ll v) {
    e[++cnt] = {v, head[u]}; head[u] = cnt;
    e[++cnt] = {u, head[v]}; head[v] = cnt;
  }

  ll find(ll x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

  void merge(ll a, ll b, ll c) {
    a = find(a), b = find(b);
    fa[a] = b;
    siz[b] += siz[a] + c - 2;
    out[b] += out[a] - 2;
    s.erase(a);
  }

  void dfs(ll u, ll f, ll rt, ll c) {
    if (deg[u] != 2) {
      if (rt) edge[++tot] = {u, rt, c};
      c = 1; rt = u;
    }
    for (ll i = head[u]; i; i = e[i].nxt) {
      ll v = e[i].to;
      if (v == f) continue;
      dfs(v, u, rt, c + 1);
    }
  }

  ll qpow(ll x, ll y) {
    ll res = 1;
    for (; y; y >>= 1, x = x * x % P)
      if (y & 1) res = res * x % P;
    return res;
  }

  int main() {
    scanf("%lld", &t);
    while (t--) {
      scanf("%lld", &n);
      memset(head, 0, sizeof head);
      memset(deg, 0, sizeof deg);
      cnt = tot = pos = 0; s.clear();

      for (ll i = 1; i < n; ++i) {
        ll u, v; scanf("%lld%lld", &u, &v);
        addTreeEdge(u, v); deg[u]++; deg[v]++;
      }

      for (ll i = 1; i <= n; ++i) {
        if (deg[i] != 2) {
          fa[i] = i; siz[i] = 1; out[i] = deg[i];
          s.insert(i);
        }
      }

      dfs(*s.begin(), 0, 0, 0);
      sort(edge + 1, edge + 1 + tot, [](const Edge& x, const Edge& y) { return x.c < y.c; });

      fac[0] = 1;
      for (ll i = 1; i <= n; ++i) fac[i] = fac[i-1] * i % P;
      ifac[n] = qpow(fac[n], P-2);
      for (ll i = n-1; i >= 0; --i) ifac[i] = ifac[i+1] * (i+1) % P;

      ans[n] = 1;
      for (ll k = n-1; k >= 1; --k) {
        while (pos < tot && k < n - edge[pos+1].c) {
          pos++; merge(edge[pos].a, edge[pos].b, edge[pos].c);
        }
        ans[k] = fac[n] * ifac[k] % P * ifac[n - k] % P;
        for (ll i : s) {
          ll tmp = (out[i] - 1) * (n - k - 1) + siz[i] - 1;
          ans[k] = ans[k] * fac[tmp] % P;
        }
      }

      for (ll i = 1; i <= n; ++i) printf("%lld ", ans[i]);
      puts("");
    }
    return 0;
  }
  ```
* **代码解读概要**：
  1. **输入处理**：读入树的边，统计每个节点的度数；
  2. **初始化并查集**：非二度点作为初始连通块，`fa`、`siz`、`out`分别记录父节点、连通块大小、非二度点度数；
  3. **DFS找链**：遍历树，找到所有「中间全是二度点的链」，记录链的两端和长度；
  4. **时光倒流合并**：K从n到1递减，合并满足条件的链两端（K < n - 链长）；
  5. **计算答案**：用组合数$\binom{n}{k}$乘各连通块的阶乘，输出结果。

---

<code_intro_selected>
接下来剖析题解中的核心片段：
</code_intro_selected>

**题解一：作者ZnPdCo**
* **亮点**：用DFS高效找链，并用并查集维护连通块的关键属性（`siz`和`out`）。
* **核心代码片段（DFS找链）**：
  ```cpp
  void dfs(ll u, ll f, ll rt, ll c) {
    if (deg[u] != 2) {  // 遇到非二度点，记录链
      if (rt) edge[++tot] = {u, rt, c};
      c = 1; rt = u;  // 重置链的起点和长度
    }
    for (ll i = head[u]; i; i = e[i].nxt) {
      ll v = e[i].to;
      if (v == f) continue;
      dfs(v, u, rt, c + 1);  // 继续遍历子节点，链长度+1
    }
  }
  ```
* **代码解读**：
  - 函数参数`rt`表示当前链的起点（非二度点），`c`表示链的长度；
  - 当遇到非二度点`u`时，如果`rt`存在（说明之前在处理一条链），就记录链的两端`u`和`rt`，以及长度`c`；
  - 遍历子节点时，传递当前链的起点和长度，继续找下一段链。
* 💡 **学习笔记**：DFS是处理树结构的「瑞士军刀」，本题用它找「中间全是二度点的链」，关键是「遇到非二度点就截断链」。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了**「像素树的等价类合并」**动画，用8位复古风格直观展示算法过程：
</visualization_intro>

### 动画主题与风格
- **主题**：像素探险家在树中合并「可交换的石子组」（等价类）；
- **风格**：FC红白机像素风，树的节点用3×3像素块表示，连通块用红、蓝、绿等纯色区分，背景为浅灰色网格。

### 核心动画内容
1. **初始化场景**：
   - 屏幕左侧显示像素树（节点按输入的树结构排列），右侧是「控制面板」（开始/暂停、单步、重置按钮，K值进度条，速度滑块）；
   - 非二度点用「带边框的像素块」表示，二度点用「实心像素块」表示；
   - 播放8位风格的轻快BGM（如《超级马里奥》的背景音）。

2. **DFS找链演示**：
   - 用「黄色箭头」模拟DFS遍历树的过程，遇到非二度点时，箭头暂停并闪烁，同时弹出文字提示：「找到链的端点！」；
   - 链的路径用「淡蓝色虚线」连接，链的长度显示在旁边。

3. **时光倒流合并**：
   - K从n到1递减，进度条从右到左移动；
   - **单步执行**：点击「单步」，满足条件的链两端的连通块（如红色和蓝色块）渐变为同一颜色（如紫色），伴随「叮」的像素音效；
   - **自动播放**：按设定速度（如1秒/步）连续合并，合并的连通块数量逐渐减少，最终所有节点合并为一个连通块（K=1时）。

4. **答案计算与结果展示**：
   - 每个K对应的方案数计算完成后，右侧面板显示「当前K值：X，方案数：Y」，文字用8位字体；
   - 全部计算完成时，播放「胜利音效」（如《塞尔达传说》的宝箱打开声），并将最终结果用「金色像素块」高亮。

### 交互设计
- **步进控制**：支持「单步」（逐K递减）、「自动播放」（可调速度）、「重置」（回到初始状态）；
- **信息同步**：当前合并的链信息（两端节点、长度）显示在面板下方，对应的代码片段（如`merge`函数）同步高亮；
- **音效开关**：允许用户开启/关闭背景音乐和操作音效。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心技巧「等价类划分+并查集」可迁移到以下场景：
</similar_problems_intro>

### 通用思路迁移
- **树的置换问题**：如「求树中可以互相交换的节点对数量」；
- **集合合并问题**：如「动态维护多个集合的属性（大小、阶乘）」；
- **时光倒流技巧**：如「逆向处理动态连通性问题」（如Kruskal算法的逆向应用）。

### 洛谷练习推荐
1. **P6277 [USACO06NOV] Corn Fields G**  
   - 🗣️ **推荐理由**：这是本题的「原题变形」，考察「状态压缩DP+集合划分」，可巩固「等价类」的思想。
2. **P1197 [JSOI2008] 星球大战**  
   - 🗣️ **推荐理由**：用「时光倒流+并查集」处理动态连通性问题，与本题的「逆向合并」技巧完全一致。
3. **P3369 【模板】普通平衡树**  
   - 🗣️ **推荐理由**：练习「维护集合的大小和阶乘」，本题的「$\prod s_i!$」计算需要类似的技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，作者ZnPdCo提到「正難则反」的思路——当K从小到大难以维护时，尝试从大到小处理。这给我们的启示是：
</insights_intro>

> **参考经验**：「遇到动态连通性问题，若正向处理复杂，试试时光倒流！」
> **点评**：本题的「时光倒流」是关键技巧，它将「K从小到大的合并减少」转化为「K从大到小的合并增加」，用并查集轻松维护。这种「逆向思维」是解决编程问题的「金钥匙」，比如求「删除边后的连通块数量」，也可以用「逆向加边+并查集」解决。


<conclusion>
本次关于「AGC066E 树上滑动谜题」的分析就到这里。这道题的核心是**等价类划分**和**时光倒流的并查集应用**，关键是理解「哪些石子可以互相交换」。记住：编程的本质是「问题转化」——把复杂的「分布方案数」转化为「组合数×阶乘乘积」，再用算法高效计算！

下次我们再一起挑战更有趣的编程题吧！💪
</conclusion>

---

---
处理用时：76.22秒
# 题目信息

# [AGC070C] No Streak

## 题目描述

Alice 和 Bob 进行了 $N$ 次猜拳。每次猜拳的可能结果包括「Alice 胜」、「Bob 胜」和「平局」。我们的任务是计算符合以下条件的猜拳结果有多少种，并输出总数对 $1000000007$ 求余数的结果：

1. 在 $N$ 次对战中，Alice 赢了 $A$ 次，而 Bob 赢了 $B$ 次。
2. Alice 不会连续赢两次，除非中间有平局。
3. Bob 也不会连续赢两次，除非中间有平局。
4. 在任一时刻，Alice 的累积胜场数不能少于 Bob 的累积胜场数。换句话说，对于每一次猜拳结束后（从第 1 次到第 $N$ 次），Alice 的胜场数始终大于或等于 Bob 的胜场数。

## 说明/提示

## 数据范围

- $2 \leq N \leq 2 \times 10^7$
- $1 \leq B \leq A$
- $A + B \leq N$
- $N, A, B$ 为整数

### 举例说明

1. 假设猜拳进行如以下顺序，则符合要求：
   - 第 1 次：Alice 胜。
   - 第 2 次：Bob 胜。
   - 第 3 次：Alice 胜。
   - 第 4 次：平局。
   - 第 5 次：Bob 胜。
   
   而以下顺序不符合要求，因为第 4 次时，Alice 的胜场数（1）小于 Bob 的胜场数（2）：
   - 第 1 次：Alice 胜。
   - 第 2 次：Bob 胜。
   - 第 3 次：平局。
   - 第 4 次：Bob 胜。
   - 第 5 次：Alice 胜。

2. 请记得在计算最终结果时，需要模数 $10^9 + 7$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
70 29 12```

### 输出

```
693209192```

## 样例 #3

### 输入

```
20000000 1234567 890123```

### 输出

```
566226457```

# AI分析结果

# 💡 Kay的C++算法解析：[AGC070C] No Streak 深入学习指南 💡

<introduction>
今天我们来挑战一道**组合数学+容斥原理**的经典题目——[AGC070C] No Streak。这道题需要我们计算满足多重条件的猜拳结果数，核心是用「反射容斥」处理前缀限制，用「组合数」解决连续胜利的限制。通过这道题，我们能学会如何把复杂的条件拆解成可计算的数学模型，一起加油吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（组合数+反射容斥）`

🗣️ **初步分析**：
解决这道题的关键，就像「用镜子找错路，用积木拼合法」——  
- **反射容斥**：想象你在网格里走路径（A胜=右走，B胜=上走），前缀条件要求路径不能穿过`y=x+1`（Bob胜场超过Alice）。这时我们用「镜子」把不合法的路径映射到另一个网格（比如把起点换到`(0,-1)`），计算这些「镜中路径」的数量，再从总数里减去，就像把错路从总路径里扣掉。  
- **组合数**：连续胜利的限制（AA/BB不能出现），就像用「平局积木」分隔A或B。比如要放A胜的次数，不能连续放两个A，就得在A之间插至少一个平局；同理B也是。我们用组合数计算「插积木」的方式数。  

**题解思路**：大部分题解的核心是「先算满足AA/BB限制的总方案数，再用反射容斥减去不满足前缀条件的方案数」。比如题解一用`f(a,b,x)`表示无前置限制的方案数，再减去反射后的不合法数；题解三先算AB串的合法方案数，再插平局。  
**核心难点**：如何正确映射不合法路径（反射容斥的双射性）、如何计算满足AA/BB限制的组合数。  
**可视化设计思路**：我们用「像素路径探险家」动画——网格里的小方块代表A（右）、B（上）、平局（灰），不合法路径会被「镜子特效」反射到另一个网格，连续的A/B会闪红色叉号，插入平局时会有「叮」的音效和积木掉落动画。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了3份优质题解，帮大家快速理解核心逻辑：
</eval_intro>

**题解一：(来源：2008verser)**
* **点评**：这份题解的「反射容斥推导」非常透彻！作者把不合法路径（穿过`y=x+1`）分成两类——「立刻向上」和「停歇后向上」，并对应到`f`函数的不同参数，最终得到答案公式`f(a,b,x)-f(a,b-1,x)-f(a+1,b-1,x-1)-f(a,b-1,x-1)`。虽然公式有点复杂，但每一步的「双射性」（不合法路径和镜中路径一一对应）解释得很清楚，适合想深入理解容斥原理的同学。

**题解二：(来源：_LHF_)**
* **点评**：作者的「序列转化」思路很巧妙！把问题转化为长度为`2n`的序列`t`，要求前缀和非负，然后通过打表发现`f(n,a,b)`的组合数公式。这种「从特殊到一般」的归纳方法，能帮我们快速找到规律，适合喜欢「找模式」的同学。公式`f(n,a,b)=C(n,a)*C(n-1,b)-C(n,a+1)*C(n-1,b-1)`简洁好记，是本题的「快捷解法」。

**题解三：(来源：EuphoricStar)**
* **点评**：这份题解的「分步计算」思路最清晰！作者先算AB串的合法方案数`F(a,b,k)`（k是相邻不同的次数），再用插板法插平局。`F(a,b,k)`的计算结合了「组合数插板」和「反射容斥」，把复杂问题拆成「算总方案→减不合法」，每一步都有明确的目标，适合新手跟着一步步走。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的三个「拦路虎」，我们一一拆解：
</difficulty_intro>

### 1. 如何处理「前缀Alice胜场≥Bob」的限制？
**难点**：直接计算满足前缀条件的路径数很难，因为要检查每一步的前缀和。  
**解决策略**：用**反射容斥**。把不合法的路径（首次穿过`y=x+1`的路径）映射到「从`(0,-1)`到`(a,b)`的路径」，计算这些映射后的路径数，再从总数里减去。比如题解一的公式，就是把不合法的情况分成三类，分别用`f`函数计算。  
💡 **学习笔记**：反射容斥的关键是「找到双射」——每一条不合法路径都对应唯一的镜中路径，反之亦然。

### 2. 如何处理「不能连续赢两次」的限制？
**难点**：不能出现AA或BB，意味着A和B之间必须有平局或对方的胜利。  
**解决策略**：用**组合数插板法**。比如要放`a`个A，不能连续放，就得在A之间插至少一个「分隔符」（平局或B）；同理B也是。我们用组合数计算「插分隔符」的方式数，比如题解三中的`F(a,b,k)`就是计算AB串的合法方式数，再插平局。  
💡 **学习笔记**：把限制转化为「插东西」的问题，是组合数的常用技巧。

### 3. 如何结合两个条件？
**难点**：两个条件相互影响，直接算「同时满足」的情况很复杂。  
**解决策略**：用「分步计算」——先算满足AA/BB限制的总方案数，再用反射容斥减去其中不满足前缀条件的方案数。比如题解一的`f(a,b,x)`是无前置限制的方案数，再减去反射后的不合法数，就是最终答案。  
💡 **学习笔记**：复杂问题拆成「先算总数，再减不合法」，是容斥原理的核心。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，它综合了题解四的代码框架和题解一的公式，清晰易懂：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自题解四的调整，预处理组合数后，用反射容斥公式计算答案，逻辑简洁。
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MOD = 1e9 + 7;
const int MAXN = 2e7 + 10; // 注意：N最大是2e7，需要足够大的数组

ll fact[MAXN], inv[MAXN];

ll qpow(ll base, ll exp) {
    ll res = 1;
    while (exp > 0) {
        if (exp % 2 == 1) res = res * base % MOD;
        base = base * base % MOD;
        exp /= 2;
    }
    return res;
}

void precompute() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = fact[i-1] * i % MOD;
    }
    inv[MAXN-1] = qpow(fact[MAXN-1], MOD-2);
    for (int i = MAXN-2; i >= 0; i--) {
        inv[i] = inv[i+1] * (i+1) % MOD;
    }
}

ll C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv[k] % MOD * inv[n - k] % MOD;
}

// 计算满足AA/BB限制的方案数（无前置限制）
ll f(int n, int a, int b) {
    int c = n - a - b; // 平局次数
    ll res = 0;
    for (int i = 0; i <= min(a, b); i++) {
        res = (res + C(c + i, i) * C(c + 1, a - i) % MOD * C(c + 1, b - i) % MOD) % MOD;
    }
    return res;
}

int main() {
    precompute();
    int N, A, B;
    cin >> N >> A >> B;
    ll total = f(N, A, B);
    ll invalid1 = f(N-1, A, B-1); // 反射情况1
    ll invalid2 = f(N-1, A+1, B-1); // 反射情况2
    ll invalid3 = f(N-2, A, B-1); // 反射情况3
    ll ans = (total - invalid1 - invalid2 - invalid3 + 3LL * MOD) % MOD;
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **预处理组合数**：`precompute`函数计算阶乘`fact`和逆元`inv`，用于快速求组合数`C(n,k)`。
  2. **计算无前置限制的方案数**：`f`函数用组合数计算满足AA/BB限制的方案数，遍历`i`（A和B的共同分隔次数），用插板法计算。
  3. **反射容斥求答案**：用`total`减去三个不合法的情况（`invalid1`、`invalid2`、`invalid3`），得到最终答案。


<code_intro_selected>
接下来看优质题解的核心片段：
</code_intro_selected>

### 题解一（来源：2008verser）
* **亮点**：反射容斥的公式推导，覆盖所有不合法情况。
* **核心代码片段**：
```cpp
// 答案公式：f(a,b,x) - f(a,b-1,x) - f(a+1,b-1,x-1) - f(a,b-1,x-1)
ll ans = (f(A,B,X) - f(A,B-1,X) - f(A+1,B-1,X-1) - f(A,B-1,X-1) + 3*MOD) % MOD;
```
* **代码解读**：
  - `f(A,B,X)`是无前置限制的方案数（X是平局次数）。
  - 后面三个`f`分别对应三种不合法情况：首次穿过`y=x+1`后立刻向上、停歇后向上、连续向上。
  - 加`3*MOD`是为了避免负数（取模后负数加MOD变正数）。
💡 **学习笔记**：反射容斥的公式需要覆盖所有不合法情况，不能漏也不能多。

### 题解二（来源：_LHF_）
* **亮点**：简洁的组合数公式，直接计算满足前缀条件的方案数。
* **核心代码片段**：
```cpp
ll f(int n, int a, int b) {
    return (C(n,a)*C(n-1,b) - C(n,a+1)*C(n-1,b-1) + MOD) % MOD;
}
```
* **代码解读**：
  - `C(n,a)*C(n-1,b)`是无前置限制的方案数（长度为2n的序列）。
  - `C(n,a+1)*C(n-1,b-1)`是反射后的不合法方案数。
  - 相减就是满足前缀条件的方案数。
💡 **学习笔记**：打表找规律是发现简洁公式的好方法，比如作者通过打表发现了这个公式。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家「看」到算法的运行过程，我设计了**像素路径探险家**动画，用8位像素风格展示每一步的计算！
</visualization_intro>

### 动画演示主题
**像素路径探险家**：小方块代表A（蓝色，右走）、B（红色，上走）、平局（灰色，停留），网格的x轴是A胜次数，y轴是B胜次数。我们的目标是从`(0,0)`走到`(A,B)`，满足：
1. 不能连续走蓝色或红色（不能AA/BB）。
2. 不能穿过`y=x+1`（Bob胜场不能超过Alice）。

### 设计思路简述
用8位像素风营造复古游戏感，让学习像玩游戏！比如：
- 连续的A/B会闪红色叉号，提醒「不能这样走」；
- 插入平局时会有「叮」的音效和灰色方块掉落动画；
- 不合法路径会被「镜子特效」反射到另一个网格，显示「这是错路」；
- 完成合法路径后会播放「胜利音效」，屏幕弹出「通关！」的像素字。

### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕显示16x16的像素网格，起点`(0,0)`是黄色方块，终点`(A,B)`是绿色方块。
   - 控制面板有「开始/暂停」「单步」「重置」按钮，速度滑块（1~5倍速）。
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

2. **算法启动**：
   - 小方块从`(0,0)`出发，第一次走A（右）或B（上），平局则停留。
   - 连续走A会闪红色叉号，提示「不能连续走A！」，必须插平局或B。

3. **反射容斥演示**：
   - 当小方块首次穿过`y=x+1`（比如走到`(1,2)`），屏幕会弹出「镜子」特效，把路径反射到`(0,-1)`的网格，显示「这是不合法路径」。
   - 反射后的路径用紫色方块显示，旁边标注「映射到镜中路径」。

4. **组合数插板演示**：
   - 插入平局时，灰色方块从上方掉落，落到A和B之间，伴随「叮」的音效，屏幕显示「插入平局，分隔连续的A/B！」。
   - 每插入一个平局，组合数的计算会在右上角更新，比如`C(5,2)`变成`C(6,2)`。

5. **交互控制**：
   - 「单步」按钮：每按一次走一步，显示当前步骤的代码片段（比如`f(N,A,B)`的计算）。
   - 「自动播放」：小方块自动走合法路径，速度可调，适合快速看整体流程。
   - 「重置」：回到起点，重新开始动画。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了这道题的技巧，可以挑战以下相似问题，巩固所学：
</similar_problems_intro>

### 通用思路迁移
- **反射容斥**：适用于「前缀和限制」的问题，比如卡特兰数（括号匹配、出栈序列）、网格路径计数。
- **组合数插板**：适用于「分隔元素」的问题，比如安排座位（不能连续坐某人）、分配物品（每堆至少一个）。

### 洛谷推荐练习
1. **洛谷 P1044 [NOIP2003 普及组] 栈**：
   - 🗣️ **推荐理由**：经典的卡特兰数问题，用反射容斥计算出栈序列数，巩固前缀限制的处理。
2. **洛谷 P2532 [AHOI2012] 树屋阶梯**：
   - 🗣️ **推荐理由**：用组合数计算阶梯的搭建方式，巩固插板法的应用。
3. **洛谷 P3200 [HNOI2009] 有趣的数列**：
   - 🗣️ **推荐理由**：用反射容斥计算满足前缀条件的数列数，拓展反射容斥的应用场景。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的「经验教训」很宝贵，比如：
</insights_intro>

> **参考经验 (来自题解一作者2008verser)**：「反射容斥时，要注意分类讨论所有不合法的情况，比如我一开始漏了‘停歇后向上’的情况，导致答案错误。后来通过画图才发现，必须把不合法的情况分成三类。」
> 
> **点评**：这位作者的经验提醒我们，反射容斥的公式不能想当然，必须通过「画图」或「举例」验证每一类情况的双射性。比如不合法的路径可能有「立刻向上」「停歇后向上」「连续向上」三种，都要考虑到。


<conclusion>
通过这道题的学习，我们掌握了「反射容斥」和「组合数插板」的核心技巧，学会了把复杂的条件拆解成可计算的数学模型。记住：**数学是编程的工具，而理解模型是关键**！下次遇到类似的计数问题，不妨想想「有没有反射容斥的可能？有没有组合数的插板方式？」，你会发现问题变得简单多了。加油，下次我们再一起挑战更难的题目！💪
</conclusion>

---
处理用时：87.98秒
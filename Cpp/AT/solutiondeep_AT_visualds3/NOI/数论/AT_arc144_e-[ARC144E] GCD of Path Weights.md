# 题目信息

# [ARC144E] GCD of Path Weights

## 题目描述

给定一个有 $N$ 个顶点、$M$ 条边的有向图 $G$。顶点编号为 $1, 2, \ldots, N$。第 $i$ 条边是从 $a_i$ 指向 $b_i$ 的有向边，且 $a_i < b_i$。

定义正整数序列 $W = (W_1, W_2, \ldots, W_N)$ 的**美丽度**为：满足下述条件的正整数 $x$ 的最大值。

- 对于 $G$ 中从顶点 $1$ 到顶点 $N$ 的任意一条路径 $(v_1, \ldots, v_k)$（$v_1 = 1, v_k = N$），都有 $\sum_{i=1}^k W_{v_i}$ 是 $x$ 的倍数。

给定整数序列 $A = (A_1, A_2, \ldots, A_N)$。请你构造正整数序列 $W = (W_1, \ldots, W_N)$，使得 $A_i \neq -1$ 时 $W_i = A_i$，并求出所有可能的 $W$ 的美丽度的最大值。如果最大值不存在，则输出 `-1`。

## 说明/提示

## 限制条件

- $2 \leq N \leq 3 \times 10^5$
- $1 \leq M \leq 3 \times 10^5$
- $1 \leq a_i < b_i \leq N$
- 若 $i \neq j$，则 $(a_i, b_i) \neq (b_j, a_j)$
- 给定的图 $G$ 中，存在从顶点 $1$ 到顶点 $N$ 的路径。
- $A_i = -1$ 或 $1 \leq A_i \leq 10^{12}$

## 样例解释 1

从顶点 $1$ 到顶点 $N$ 的路径有 $(1,2,4)$ 和 $(1,3,4)$ 共两条。例如 $W = (5, 3, 7, 8)$ 的美丽度为 $4$。实际上，$W_1 + W_2 + W_4 = 16$，$W_1 + W_3 + W_4 = 20$，两者都是 $4$ 的倍数。

## 样例解释 2

从顶点 $1$ 到顶点 $N$ 的路径有 $(1,2,4)$、$(1,3,4)$、$(1,4)$ 共三条。例如 $W = (5, 3, 7, 8)$ 的美丽度为 $1$。

## 样例解释 3

例如 $W = (3, 10^{100}, 10^{100}, 7)$ 的美丽度为 $10^{100} + 10$。因为 $W$ 的美丽度可以无限大，所以最大值不存在。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 4

1 2

1 3

2 4

3 4

-1 3 7 -1```

### 输出

```
4```

## 样例 #2

### 输入

```
4 5

1 2

1 3

2 4

3 4

1 4

-1 3 7 -1```

### 输出

```
1```

## 样例 #3

### 输入

```
4 4

1 2

1 3

2 4

3 4

3 -1 -1 7```

### 输出

```
-1```

## 样例 #4

### 输入

```
5 5

1 3

3 5

2 3

3 4

1 4

2 -1 3 -1 4```

### 输出

```
9```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC144E] GCD of Path Weights 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（带权并查集 + 差分约束思想的结合）  

🗣️ **初步分析**：  
解决这道题的关键，在于把“点权和的gcd最大化”问题，转化为“边权差的约束问题”——这就像我们想知道全班同学身高和的最大公约数，不如先记录每个人与班长的身高差，这样不用算总和也能找到约束条件。  

### 核心算法比喻与应用
带权并查集就像给每个节点贴了一张“**与根节点的差值标签**”。比如，若节点A的标签是`+3`，根节点是R，说明A的值 = R的值 + 3；若节点B的标签是`-2`，则B的值 = R的值 - 2。这样，不用知道R的绝对 value，也能算出A和B的差值（3 - (-2) = 5）。  

在本题中，我们需要让**所有1→n的路径点权和都是x的倍数**。通过“拆点”技巧（把点权转成边权），这个条件可以转化为：**对拆点后的每条边(u→v, w)，必须满足v的标签 - u的标签 ≡ w (mod x)**。带权并查集正好用来维护这种“标签差值”的约束关系。  


### 题解核心思路与难点
题解的通用思路可以总结为3步：  
1. **删无关点**：去掉1无法到达或无法到达n的点（这些点不影响结果）；  
2. **拆点转边**：把点u拆成`u_in`（入点）和`u_out`（出点），`u_in→u_out`的边权是点u的权值；原图的边`u→v`转成`u_out→v_in`，边权0；  
3. **带权并查集约束**：用带权并查集维护拆点后的节点标签，收集所有“冲突差值”（这些差值的gcd就是最大的x）。  

**核心难点**：  
- 如何把点权转化为边权？（拆点是关键）  
- 带权并查集路径压缩时，如何正确维护标签差值？（递归更新父节点的差值）  


### 可视化设计思路
为了直观理解“拆点+带权并查集”的过程，我设计了一个**8位像素风的动画**：  
- **场景**：FC游戏风格的DAG图，`u_in`是蓝色2x2像素块，`u_out`是绿色块，边用白色线条连接；  
- **拆点动画**：每个点分裂成两个块（蓝→绿），中间用黄色线连接（代表点权边）；  
- **并查集合并**：合并时根节点“滑向”另一个根，同时显示差值计算（如`dt[fu] = -dt[u_out]`），播放“叮”的音效；  
- **冲突提示**：冲突边闪烁红色，弹出差值框（如“差值：5”），播放“滴”的音效，gcd值实时更新。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，筛选了4份评分≥4星的优质题解，帮你快速理解核心逻辑：
</eval_intro>


### 题解一：来源（tzc_wk，赞10）
**点评**：  
这份题解直接点出了问题的核心——**CF241E的经典结论**（DAG路径和为x倍数的充要条件是存在标签序列满足边约束）。它把点权转边权的思路讲得很透，并且明确了“带权并查集维护约束”的解法，是理解本题的“入门钥匙”。


### 题解二：来源（EuphoricStar，赞8）
**点评**：  
题解详细解释了“拆点后的生成树森林”——通过生成树收集非树边的约束（非树边的差值必须是x的因数）。代码中的生成树遍历逻辑简洁，还提到了“不确定点权的边可以忽略”，帮你避开了“无效约束”的坑。


### 题解三：来源（Leasier，赞5）
**点评**：  
这份题解进一步细化了“连通块处理”：对每个连通块跑生成树，统计非树边的差值。代码中的`dfs3`函数巧妙地遍历连通块，收集所有约束，时间复杂度分析（O((n+m)logw)）也很清晰，适合学习“高效处理大规模数据”的技巧。


### 题解四：来源（Ice_teapoy，赞4）
**点评**：  
题解用**样例图示**展示了拆点后的图结构（比如样例1的拆点图），并详细讲解了带权并查集的路径压缩（递归更新父节点差值）。代码中的`find`函数实现非常标准，是学习“带权并查集”的绝佳模板。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键，在于突破3个核心难点。我结合优质题解，帮你提炼了针对性的解决策略：
</difficulty_intro>


### 1. 难点：如何把点权转化为边权？
**分析**：点权是路径的一部分，直接处理点权和的gcd很难。但通过“拆点”，可以把点权转成边权——点u的权值变成`u_in→u_out`的边权，原图的边`u→v`变成`u_out→v_in`的边权0。这样，路径的点权和就等于拆点后的边权和。  
**策略**：记住“点拆成入点+出点”的技巧，点权对应入点到出点的边，原图边对应出点到入点的边。


### 2. 难点：带权并查集的路径压缩如何维护差值？
**分析**：带权并查集的核心是“标签差值”，路径压缩时如果直接把父节点设为根，会丢失中间的差值信息。  
**策略**：递归处理父节点！比如`find`函数中，先找到根节点，再更新当前节点的差值（`dt[x] += dt[fa[x]]`），最后把父节点设为根。这样就能保证差值的正确性。


### 3. 难点：如何收集所有约束条件？
**分析**：所有约束来自“冲突的边”——当两个节点已在同一并查集，合并时的差值必须是x的因数。  
**策略**：合并时检查是否连通：若连通，计算差值并加入gcd；若不连通，合并并更新差值。最后，所有差值的gcd就是最大的x。


### ✨ 解题技巧总结
- **拆点技巧**：点→入点+出点，点权转边权；  
- **带权并查集**：递归路径压缩，维护差值；  
- **约束收集**：冲突差值取gcd，就是最大解；  
- **无效点删除**：先删1无法到达或无法到达n的点，减少计算量。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，它综合了优质题解的思路，帮你快速把握整体框架：
</code_intro_overall>


### 本题通用核心C++实现参考
* **说明**：综合优质题解的拆点逻辑、带权并查集实现，是解决本题的标准模板。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
using LL = long long;

const int N = 6e5 + 10;
int n, m;
LL a[N];
vector<int> e[N], ne[N];
bool vis1[N], vis2[N];
int fa[N];
LL dt[N];

int find(int x) {
    if (fa[x] == x) return x;
    int root = find(fa[x]);
    dt[x] += dt[fa[x]];
    return fa[x] = root;
}

void dfs1(int u) {
    vis1[u] = true;
    for (int v : e[u]) if (!vis1[v]) dfs1(v);
}

void dfs2(int u) {
    vis2[u] = true;
    for (int v : ne[u]) if (!vis2[v]) dfs2(v);
}

LL gcd(LL a, LL b) {
    return b == 0 ? a : gcd(b, a % b);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        ne[v].push_back(u);
    }
    // 删去无关点
    dfs1(1);
    dfs2(n);
    // 初始化带权并查集
    for (int i = 1; i <= 2 * n; ++i) fa[i] = i, dt[i] = 0;
    // 处理原图边（拆点后的u_out→v_in，边权0）
    for (int u = 1; u <= n; ++u) {
        if (!vis1[u] || !vis2[u]) continue;
        for (int v : e[u]) {
            if (!vis1[v] || !vis2[v]) continue;
            int u_out = u + n;
            int v_in = v;
            int fu = find(u_out);
            int fv = find(v_in);
            if (fu != fv) {
                dt[fu] = -dt[u_out];
                fa[fu] = fv;
            }
        }
    }
    // 处理固定点权（u_in→u_out，边权a[u]）
    LL ans = 0;
    for (int u = 1; u <= n; ++u) {
        if (!vis1[u] || !vis2[u]) continue;
        cin >> a[u];
        if (a[u] == -1) continue;
        int u_in = u;
        int u_out = u + n;
        int fu = find(u_in);
        int fv = find(u_out);
        if (fu == fv) {
            ans = gcd(ans, abs(dt[u_out] + a[u] - dt[u_in]));
        } else {
            dt[fu] = dt[u_out] - (dt[u_in] + a[u]);
            fa[fu] = fv;
        }
    }
    // 处理1→n的路径约束
    int f1 = find(1);
    int fn = find(n + n);
    if (f1 == fn) ans = gcd(ans, abs(dt[1]));
    cout << (ans == 0 ? -1 : ans) << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **删点**：用两次DFS标记1可达和可达n的点，删去无关点；  
  2. **拆点与边处理**：原图边转成`u_out→v_in`（边权0），用带权并查集合并；  
  3. **固定点权处理**：处理`u_in→u_out`的边（权值a[u]），收集冲突差值；  
  4. **结果计算**：所有差值的gcd就是最大解，若gcd为0则输出-1。


<code_intro_selected>
接下来，赏析优质题解的核心片段：
</code_intro_selected>


### 题解四（Ice_teapoy）：带权并查集路径压缩
* **亮点**：递归路径压缩，正确维护差值。  
* **核心代码片段**：
```cpp
int find(int x) {
    if (f[x] == x) return x;
    find(f[x]);
    dt[x] = dt[x] + dt[f[x]];
    return f[x] = f[f[x]];
}
```
* **代码解读**：  
  这段代码是带权并查集的核心！比如，假设x的父节点是y，y的父节点是根r。递归找到r后，先更新y的差值（`dt[y] += dt[r]`），再更新x的差值（`dt[x] += dt[y]`），最后把x的父节点直接设为r。这样，x的差值就直接是与r的差值了。  
* 💡 **学习笔记**：递归是维护带权并查集差值的关键！


### 题解三（Leasier）：连通块约束收集
* **亮点**：DFS遍历连通块，收集非树边的差值。  
* **核心代码片段**：
```cpp
ll dfs3(int u, int n) {
    ll ans = 0;
    vis3[u] = true;
    for (int i = head3[u]; i != 0; i = edge3[i].nxt) {
        int x = edge3[i].end, x_ = x <= n ? x : x - n;
        if (vis1[x_] && vis2[x_]) {
            if (!vis3[x]) {
                val[x] = val[u] + edge3[i].dis;
                ans = gcd(ans, dfs3(x, n));
            } else {
                ans = gcd(ans, llabs(val[x] - val[u] - edge3[i].dis));
            }
        }
    }
    return ans;
}
```
* **代码解读**：  
  这段DFS遍历连通块，`val[x]`是节点x的标签值。遇到未访问的节点，递归处理并更新标签；遇到已访问的节点，计算差值并加入gcd。这样就收集了连通块内的所有约束。  
* 💡 **学习笔记**：连通块遍历是处理大规模图约束的有效方法！


## 5. 算法可视化：像素动画演示

### 动画演示主题：“像素拆点探险家”
**设计思路**：用8位像素风营造复古游戏感，通过“探险家拆点→并查集合并→收集约束”的流程，让算法变得“看得见、听得着”。


### 核心演示内容与交互
1. **场景初始化**：  
   - 8位像素DAG图：节点是2x2像素块（u_in蓝，u_out绿），边是白色线条；  
   - 控制面板：单步/自动播放/重置按钮，速度滑块，当前gcd显示；  
   - BGM：8位风格的轻快旋律（如《超级马里奥》小关卡BGM）。

2. **删点动画**：  
   - 1无法到达的点（灰色）和无法到达n的点（深灰）逐渐消失，剩下的点保持彩色。

3. **拆点过程**：  
   - 每个点u分裂成两个块（蓝u_in、绿u_out），中间用黄色线连接（代表点权边）；  
   - 原图边u→v变成绿u_out到蓝v_in的白色线（代表边权0）。

4. **并查集合并**：  
   - 合并时，根节点“滑向”另一个根，同时显示差值计算（如`dt[fu] = -dt[u_out]`）；  
   - 播放“叮”的音效，gcd值实时更新。

5. **冲突处理**：  
   - 冲突边闪烁红色，弹出差值框（如“差值：5”）；  
   - 播放“滴”的音效，gcd值更新。

6. **完成动画**：  
   - 显示最终gcd值，播放胜利音效（如《塞尔达传说》宝箱声）；  
   - 所有节点高亮，提示“完成！”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的技巧，可以挑战以下相似问题：
</similar_problems_intro>


### 通用思路迁移
本题的“拆点转边权+带权并查集维护约束”思路，可用于解决**DAG路径和的约束问题**（如求路径和的最大公约数、最小公倍数等）。


### 推荐练习
1. **CF241E**：本题的“前辈”，同样考察DAG路径和的约束；  
2. **洛谷P1991**：无线通讯网，带权并查集的经典应用；  
3. **洛谷P2294**：深基13.例1，差分约束系统的入门题；  
4. **洛谷P3275**：糖果，差分约束系统的进阶题。


## 7. 学习心得与经验分享

<insights_intro>
优质题解中的经验，帮你避开坑：
</insights_intro>

> **参考经验（来自Ice_teapoy）**：“带权并查集的路径压缩一定要递归！我一开始直接设父节点为根，结果差值全错了，后来递归处理才对。”  
> **点评**：递归是带权并查集的“灵魂”！直接路径压缩会丢失中间差值，一定要先递归处理父节点，再更新当前节点的差值。


## 💪 结语
本次分析就到这里！记住：**拆点转边权是关键，带权并查集维护差值，冲突约束取gcd**。多练相似题，你一定能掌握这个技巧！下次我们再探索更有趣的算法挑战～


--- 
**提示**：可视化动画可通过HTML/CSS/JS实现（用Canvas绘制像素块，Web Audio API播放音效），你可以尝试写一个简单的demo，观察算法的每一步！

---
处理用时：139.97秒
# 题目信息

# [AGC064E] Cross Sum Construction

## 题目描述

给定一个正整数 $N$ 和两个长度为 $N$ 的整数序列 $A=(a_1,\ldots,a_N),\ B=(b_1,\ldots,b_N)$。  
另外，定义多重集合 $X$，其包含 $N^2$ 个值 $(a_i+b_j)\ (1\leq i,j\leq N)$。

对于每个元素都在 $[-10^{18},\ 10^{18}]$ 范围内的 $N\times N$ 整数矩阵 $M$，定义其分数如下：

- 设 $S$ 为一个多重集合，包含 $N^2$ 个值，分别为“$M$ 的第 $i$ 行或第 $j$ 列中属于的 $2N-1$ 个元素的总和”$(1\leq i,j\leq N)$。此时，分数为对所有整数 $z$，$\min($$X$ 中 $z$ 的出现次数, $S$ 中 $z$ 的出现次数$)$ 的总和。

请你对于每个测试用例，求出一个能使分数最大的矩阵 $M$。

$T$ 组测试数据，请分别解决上述问题。

## 说明/提示

### 限制条件

- $1\leq T\leq 2.5\times 10^5$
- $1\leq N\leq 500$
- $-10^9\leq a_i,b_i\leq 10^9$
- 所有测试用例中 $N^2$ 的总和不超过 $2.5\times 10^5$
- 输入均为整数

### 样例说明 1

第 $1$ 个测试用例中，$X=\{-5\},\ S=\{-5\}$，分数为 $1$。  
第 $2$ 个测试用例中，$X=\{8,-11,7,-12\},\ S=\{7,8,-11,-10\}$，分数为 $3$。  
第 $3$ 个测试用例中，$X=\{21,22,23,24,25,26,27,28,29\},\ S=\{28,21,26,23,25,27,24,29,22\}$，分数为 $9$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3

1

5

-10

2

0 -1

8 -11

3

20 23 26

1 2 3```

### 输出

```
-5

8 9

-10 -9

2 9 4

7 5 3

6 1 8```

# AI分析结果

---
# 💡 Kay的C++算法解析：AGC064E Cross Sum Construction 深入学习指南 💡

<introduction>
今天我们来一起分析AtCoder AGC064E“Cross Sum Construction”这道C++编程题。这道题需要我们通过**数学推导+构造技巧**，打造一个特殊的矩阵，让它的“交叉和”集合尽可能匹配给定的目标集合。本指南会帮你理清思路，掌握核心构造方法！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（构造法与数学推导结合）

🗣️ **初步分析**：
解决这道题的关键，就像“根据菜谱逆向找食材”——我们需要先明确**目标集合S**（每个位置的“行和+列和-M[i][j]”，称为“交叉和”），再反推矩阵M的元素。这里的“菜谱”是题解中推导的数学公式：  
M[i][j] = (r_i + c_j - 2*sum/(2n-1))/(n-1) - s[i][j]  
其中，r_i是S的第i行和，c_j是S的第j列和，sum是S的总和。我们的目标是让S尽可能等于X（所有a_i+b_j的集合），这样匹配度最高。

### 核心算法流程
1. **构造S矩阵**：分奇偶n处理，确保r_i和c_j满足同余条件（r_i ≡ r_x mod n-1，c_j ≡ c_y mod n-1）；  
2. **调整sum**：让sum能被2n-1整除（否则M元素不是整数）；  
3. **计算r和c**：求S的行和与列和；  
4. **生成M矩阵**：用公式计算每个元素。

### 可视化设计思路
我们用**8位像素风**模拟“矩阵构造工厂”：  
- 用不同颜色的像素块代表S和M的元素（比如S用蓝/红，M用紫/绿）；  
- 构造S时，高亮当前处理的(i,j)位置，播放“叮”的音效；  
- 调整sum时，闪烁s[0][0]并播放“滴答”声；  
- 生成M时，同步显示公式推导过程，用箭头指向当前用到的r_i和c_j。  
**游戏化元素**：将构造过程分为“构造S→调整sum→生成M”三个小关卡，完成每个关卡播放“胜利”音效，增加成就感！


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了一份评分4.5星的优质题解，它在数学推导、代码实现和边界处理上都表现出色，非常适合学习构造法的应用！
</eval_intro>

**题解一：来源：Y204335**
* **点评**：这份题解的核心优势是“数学推导与代码实现的完美衔接”。作者首先详细推导了S与M的关系，清晰解释了r_i和c_j的同余条件，让我们明白“为什么要这样构造S”。代码部分：  
  - 分奇偶n处理S的构造（奇数n直接模n，偶数n预处理a数组避免模数冲突）；  
  - 用循环调整sum的方法简单有效（加n-1直到满足整除）；  
  - 变量命名（s、r、c、sum）含义明确，逻辑链完整。  
  它是构造题的优秀参考模板！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于“将数学公式转化为可执行的代码”，以及“处理各种边界条件”。结合题解的思路，我为大家提炼了3个核心难点和解决策略：
</difficulty_intro>

### 1. 关键点1：理解S与M的数学关系
- **分析**：题目中S的每个元素是“第i行和+第j列和-M[i][j]”，作者通过代数推导得出M的表达式。这个公式是构造M的核心——其实是通过联立方程消去了其他变量，只保留r_i和c_j。  
- 💡 **学习笔记**：数学推导是构造题的“蓝图”，先搞懂公式再写代码！

### 2. 关键点2：满足r_i和c_j的同余条件
- **分析**：为了让M的元素是整数，必须保证r_i ≡ r_x (mod n-1)且c_j ≡ c_y (mod n-1)。作者通过构造S的方式满足这个条件：  
  - 奇数n时，s[i][j] = a[(j-i)mod n] + b[(j-2i)mod n]（每行每列的和都是所有a和b的和，自然同余）；  
  - 偶数n时，预处理a数组，交换冲突元素，避免模数问题。  
- 💡 **学习笔记**：构造题中，“满足约束条件”比“直接生成结果”更重要！

### 3. 关键点3：处理sum不被2n-1整除的情况
- **分析**：sum必须能被2n-1整除才能让M是整数。作者用**循环调整s[0][0]**的方法——每次加n-1（n-1和2n-1互质，总能调整到满足条件）。  
- 💡 **学习笔记**：小调整解决大问题，找“互质”的增量是常见技巧！

### ✨ 解题技巧总结
- **技巧A**：数学推导优先，先明确变量关系再写代码；  
- **技巧B**：分情况构造，根据n的奇偶性设计不同的S生成方式；  
- **技巧C**：增量调整法，用互质的增量解决整除问题；  
- **技巧D**：用long long类型避免大数溢出！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合了题解思路的通用核心代码，帮你把握整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：此代码来自题解Y204335，是构造法的典型实现，处理了奇偶n、模数冲突和sum调整。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 510;
int t, n;
ll s[N][N], sum, r[N], c[N], cnt[N], a[N], b[N];

void solve() {
    cin >> n;
    sum = 0;
    memset(r, 0, sizeof(r));
    memset(c, 0, sizeof(c));
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) cin >> b[i];
    
    if (n == 1) { cout << a[0] + b[0] << '\n'; return; }
    
    // 构造S矩阵
    if (n % 2) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                s[i][j] = a[(n + j - i) % n] + b[(2 * n - 2 * i + j) % n];
    } else {
        memset(cnt, -1, sizeof(cnt));
        for (int i = 0; i < n; i++) {
            int mod = (n-1 + a[i]%(n-1)) % (n-1);
            if (cnt[mod] != -1) {
                swap(a[cnt[mod]], a[0]); swap(a[i], a[n/2]); break;
            }
            cnt[mod] = i;
        }
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                s[i][j] = (i==j || (n+j-i)%n==n/2) ? a[(i%2)*n/2] : a[(n+j-i)%n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                int x = (2*(i/2) + (i%2)*n/2 + j) % n;
                int y = (2*(i/2) + 2*j + (j>=n/2)) % n;
                s[x][y] += b[i];
            }
    }
    
    // 调整sum
    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) sum += s[i][j];
    while (sum % (2*n-1)) { s[0][0] += n-1; sum += n-1; }
    
    // 计算r和c（S的行和、列和）
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) { r[i] += s[i][j]; c[j] += s[i][j]; }
    
    // 生成M矩阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            ll numerator = r[i] + c[j] - 2 * sum / (2 * n - 1);
            cout << numerator / (n-1) - s[i][j] << ' ';
        }
        cout << '\n';
    }
}

int main() {
    ios::sync_with_stdio(0); cin.tie(nullptr);
    cin >> t; while (t--) solve();
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读取n、a、b数组；  
  2. **特殊情况**：n=1时直接输出a[0]+b[0]；  
  3. **构造S**：分奇偶n处理，奇数直接模n，偶数预处理a数组避免模数冲突；  
  4. **调整sum**：循环加s[0][0]直到sum满足整除；  
  5. **计算r和c**：累加S的行和与列和；  
  6. **生成M**：用公式计算每个元素并输出。


### 关键代码片段赏析

#### 片段1：奇偶n的S构造
```cpp
if (n % 2) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            s[i][j] = a[(n + j - i) % n] + b[(2 * n - 2 * i + j) % n];
} else {
    // 预处理a数组，解决模数冲突
    memset(cnt, -1, sizeof(cnt));
    for (int i = 0; i < n; i++) {
        int mod = (n-1 + a[i]%(n-1)) % (n-1);
        if (cnt[mod] != -1) { swap(a[cnt[mod]], a[0]); swap(a[i], a[n/2]); break; }
        cnt[mod] = i;
    }
    // 构造S的a部分
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            s[i][j] = (i==j || (n+j-i)%n==n/2) ? a[(i%2)*n/2] : a[(n+j-i)%n];
    // 构造S的b部分
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            int x = (2*(i/2) + (i%2)*n/2 + j) % n;
            int y = (2*(i/2) + 2*j + (j>=n/2)) % n;
            s[x][y] += b[i];
        }
}
```
* **解读**：  
  - **奇数n**：直接用`(j-i)mod n`作为a的下标，`(j-2i)mod n`作为b的下标，确保r_i和c_j同余；  
  - **偶数n**：先预处理a数组——用cnt数组检测a[i] mod (n-1)的冲突，若有冲突则交换a[0]和a[n/2]；然后构造S的a部分（对角线用特定元素），最后将b的元素加到S的对应位置。  
* **学习笔记**：构造题中，“预处理输入数组”是解决模数冲突的常用技巧！

#### 片段2：sum调整与M生成
```cpp
while (sum % (2 * n - 1)) { s[0][0] += n - 1; sum += n - 1; }
// ...
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        ll numerator = r[i] + c[j] - 2 * sum / (2 * n - 1);
        cout << numerator / (n-1) - s[i][j] << ' ';
    }
}
```
* **解读**：  
  1. **sum调整**：n-1和2n-1互质，所以每次加n-1总能让sum满足整除（比如n=2时，2n-1=3，n-1=1，加1直到sum mod3=0）；  
  2. **M生成**：公式中的`numerator`是分子，除以(n-1)后减去s[i][j]，得到M的元素。  
* **学习笔记**：处理大数时，一定要用`long long`类型，否则会溢出！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了让大家直观看到“构造S→调整sum→生成M”的过程，我设计了一个“像素构造工厂”的动画，用8位复古风格模拟矩阵的生成，结合音效和小关卡，让学习更有趣！
\</visualization_intro\>

### 动画演示主题
**像素工匠的“矩阵制造车间”**——你将看到S矩阵如何被一步步构造，sum如何调整，最后M矩阵如何“诞生”。

### 核心演示内容
1. **构造S矩阵**（分奇偶n）；  
2. **调整sum**使其满足2n-1整除；  
3. **计算r和c**（S的行和列和）；  
4. **生成M矩阵**。

### 动画帧步骤与交互设计
1. **场景初始化**：  
   - 屏幕左侧显示“待构造的S矩阵”（32x32像素块，初始灰色），右侧显示“M矩阵”（初始黑色）；  
   - 底部控制面板：开始/暂停、单步、重置按钮；速度滑块；“自动演示”开关；  
   - 播放8位风格背景音乐（如《超级马里奥》轻松版）。

2. **构造S**：  
   - **奇数n**：光标从(0,0)开始，逐行移动，每到(i,j)，S的像素块变为a[(j-i)mod n]+b[(j-2i)mod n]的颜色（蓝+红=紫），播放“叮”的音效；  
   - **偶数n**：先显示“预处理a数组”动画——a数组的像素块闪烁，若检测到模数冲突，交换a[0]和a[n/2]的像素块，播放“交换”音效；然后构造S的a部分（对角线用绿色），再构造b部分（加黄色）。  
   - S完成后，播放“关卡胜利”音效，S矩阵闪烁3次。

3. **调整sum**：  
   - sum的数值用像素数字显示在屏幕上方，若sum mod(2n-1)≠0，s[0][0]的像素块闪烁红色，同时数值增加n-1，sum同步增加，直到满足条件。每调整一次播放“滴答”音效。  
   - 调整完成后，sum变为绿色，播放“确认”音效。

4. **计算r和c**：  
   - 逐行遍历S，r[i]的数值显示在每行右侧，每累加一个元素，r[i]增加，对应像素块闪烁黄色，播放“累加”音效；  
   - 同理计算c[j]，数值显示在每列下方。

5. **生成M**：  
   - 光标从(0,0)开始，逐行计算M[i][j]——先显示公式“(r[i]+c[j] - 2*sum/(2n-1))/(n-1) - s[i][j]”，然后逐步计算每一步，对应数值用像素数字显示，最后M的像素块变为对应颜色（如橙色），播放“生成”音效。  
   - M完成后，播放“通关”音效，M矩阵闪烁，屏幕显示“构造完成！”的像素文字。

### 交互控制
- **单步模式**：点击“单步”按钮，动画执行一步，便于仔细观察；  
- **自动演示**：开启后，动画自动执行，速度可通过滑块调整；  
- **重置**：恢复初始状态，重新开始。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
构造法的关键是“**找到目标结构的数学特征，然后按特征生成**”。比如本题中S的特征是r_i和c_j同余，M的特征是由S的行和列和推导而来。这种思路可以用于解决：  
- 构造数组/矩阵满足特定行和列和；  
- 构造图的邻接矩阵满足特定路径数；  
- 构造字符串满足特定子串条件。

### 练习推荐 (洛谷)
1. **洛谷 P2679 子串**：构造子串的选择方式，锻炼“预处理+动态规划”的构造思路；  
2. **洛谷 P3195 玩具装箱**：推导动态规划的状态转移方程，强化数学推导能力；  
3. **洛谷 P1002 过河卒**：构造路径计数矩阵，练习逐行计算的构造技巧；  
4. **洛谷 P4017 最大食物链计数**：构造图的邻接矩阵，锻炼数据结构构造能力。


## 7. 学习心得与经验分享 (若有)

\<insights_intro\>
本题解中没有明确的作者个人心得，但通过代码和推导，我们可以总结出隐性经验：
\</insights_intro\>

> **参考经验**：在构造题中，“**先处理输入数组的模数冲突**”是避免后续错误的关键——比如本题偶数n时，作者用cnt数组检测a的模数冲突，并用交换的方法解决，这比在构造S时处理冲突更高效。  
> **点评**：这种“预处理”的思路非常重要——提前解决输入的问题，能让后续构造更顺畅。比如在其他构造题中，预处理输入数组的排序、去重、模数调整，都是常见的技巧！


\<conclusion\>
本次关于AGC064E的分析就到这里！这道题的核心是“数学推导+构造技巧”，通过推导公式找到S和M的关系，再分情况构造S，最后调整sum生成M。记住，构造题的关键是“先想清楚数学条件，再写代码”，多练习类似的题目能让你更快掌握这种思路。下次我们再一起探索新的编程挑战！💪
\</conclusion\>

---
处理用时：143.45秒
# 题目信息

# [AGC012E] Camel and Oases

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc012/tasks/agc012_e

$ N $ 箇所のオアシスが数直線上に並んでおり、左から $ i $ 番目のオアシスは座標 $ x_i $ にあります。

ラクダはこれらのオアシス全てを訪れたいです。 ラクダははじめ、体積 $ V $ のこぶを持っています。こぶの体積を $ v $ としたとき、ラクダは水を最大で $ v $ 蓄えることができます。ラクダはオアシスにいるときのみ、水を補給することができます。オアシスでは蓄えられるだけ水を補給することができ、同じオアシスで何回でも水を補給することができます。

ラクダは数直線上を歩くか、ジャンプするかのどちらかの方法で移動することができます。

- ラクダが距離 $ d $ だけ歩いたとき、蓄えている水を $ d $ だけ消費します。ただし、蓄えられた水の量が負になるようには移動できません。
- 蓄えられた水の量を $ v $ として $ v\ >\ 0 $ のとき、ラクダはジャンプをすることで数直線上の任意の地点へと移動することができます。その後、こぶの体積が $ v/2 $(小数点以下は切り捨て) となり、蓄えられた水の量が $ 0 $ になります。

ラクダが $ 1,2,3,...,N $ 番目のオアシスから出発したとき、全てのオアシスを訪れることが可能かどうかをそれぞれ判定してください。

## 说明/提示

### 制約

- $ 2\ ≦\ N,V\ ≦\ 2\ ×\ 10^5 $
- $ -10^9≦\ x_1\ <\ x_2\ <\ ...\ <\ x_N\ ≦10^9 $
- $ V,\ x_i $ はいずれも整数

### Sample Explanation 1

以下のように移動することで、$ 1 $ 番のオアシスから出発して全てのオアシスを訪れることが可能です。 - $ 1 $ 番のオアシスから $ 2 $ 番のオアシスへと歩いて移動する。蓄えられた水の量は $ 0 $ となる。 - $ 2 $ 番のオアシスで水を補給する。蓄えられた水の量は $ 2 $ となる。 - $ 2 $ 番のオアシスから $ 3 $ 番のオアシスへとジャンプして移動する。蓄えられた水の量は $ 0 $ となり、こぶの体積は $ 1 $ となる。

### Sample Explanation 2

オアシスは何度訪れても構いません。

## 样例 #1

### 输入

```
3 2

1 3 6```

### 输出

```
Possible

Possible

Possible```

## 样例 #2

### 输入

```
7 2

-10 -4 -2 0 2 4 10```

### 输出

```
Impossible

Possible

Possible

Possible

Possible

Possible

Impossible```

## 样例 #3

### 输入

```
16 19

-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84```

### 输出

```
Possible

Possible

Possible

Possible

Possible

Possible

Possible

Possible

Possible

Possible

Possible

Possible

Impossible

Impossible

Impossible

Impossible```

# AI分析结果

# 💡 Kay的C++算法解析：[AGC012E] Camel and Oases 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：状压DP + 区间预处理

🗣️ **初步分析**：  
解决这道题的关键，就像**用有限的拼图块拼出完整的图案**——骆驼最多能跳`log₂V`次（因为每次跳跃后驼峰体积减半，最多18次左右），每次跳跃对应一块“拼图”（一个最大行走距离`v=V/(2ᵏ)`）。每块拼图能覆盖一段连续的绿洲（相邻绿洲距离≤v就能走过去），我们需要选这些拼图，加上初始V对应的“固定拼图”（每个起点的初始区间），正好拼满1~n的所有绿洲。

- **核心思路**：  
  1. **预处理区间**：对每个跳跃次数k（对应v=V/(2ᵏ)），预处理每个点能走到的最左`L[k][i]`和最右`R[k][i]`（连续区间）。  
  2. **状压DP**：用二进制状态`S`表示选了哪些k对应的拼图，`f[S]`记录选`S`能覆盖的最长前缀右端点，`g[S]`记录选`S`能覆盖的最长后缀左端点。  
  3. **判断答案**：对每个起点的初始区间`[L0, R0]`，找是否存在`S`使得`f[S]≥L0-1`（前缀覆盖到初始区间左边）且`g[全集\S]≤R0+1`（后缀覆盖到初始区间右边），这样三者合并就覆盖了整个1~n。

- **核心难点与解决**：  
  - 难点1：如何快速得到每个v对应的连续区间？→ 用递推：`L[k][i] = (x[i]-x[i-1]≤v) ? L[k][i-1] : i`（同理`R[k][i]`），因为相邻距离≤v就能连起来。  
  - 难点2：如何高效合并拼图？→ 状压DP，状态数只有`2¹⁸=262144`，完全可行。  
  - 难点3：如何快速判断初始区间是否合法？→ 利用`f[S]`和`g[补集]`的性质，只需枚举`S`即可。

- **可视化设计思路**：  
  我们设计一个**8位像素风的拼图游戏**：  
  - 屏幕左侧是1~n的绿洲（像素块），右侧是logV块拼图（每个拼图对应一个v，显示能覆盖的区间）。  
  - 初始时，每个起点对应的初始拼图（绿色块）固定在屏幕中间。  
  - 点击“单步执行”，会选一块拼图（比如v=V/2），对应的区间会变成蓝色，`f[S]`和`g[S]`实时更新（显示在屏幕顶部）。  
  - 当所有绿洲被覆盖时，播放“胜利”音效（8位机风格的“叮~叮~”），屏幕弹出“拼图完成！”的像素文字。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速掌握核心逻辑：
</eval_intro>

### **题解一：Ebola（赞19）**  
* **点评**：这份题解的思路“一刀见血”——直接点出跳跃次数是log级，然后用状压DP维护前缀和后缀的覆盖范围。代码极其简洁（50行不到），预处理`L`和`R`数组的方式非常巧妙（递推相邻距离），状态转移也很直接（`exL[s] = max(exL[s], R[i][exL[s^(1<<i)]+1]`）。最难得的是作者分享了调试经历（一开始写二分卡了3小时，后来简化跳跃指针才AC），提醒我们“复杂的思路不一定是对的，简洁才是王道”。

### **题解二：JohnJoeZhu（赞13）**  
* **点评**：这份题解是“手把手教学”的典范——分步骤讲解思路（从暴力到状压），代码注释详细（比如预处理`l`和`r`数组的逻辑），还画了示意图。特别是状压DP的转移部分（`L[(1<<j)|i] = max(L[(1<<j)|i], r[j][L[i]+1]`），解释得很清楚。适合刚开始接触状压DP的同学，能帮你快速理解“如何用状态合并区间”。

### **题解三：DaiRuiChen007（赞0）**  
* **点评**：这份题解的亮点是“离线处理答案”——先把初始区间分成若干块（同一块的答案相同），然后枚举`S`判断块是否合法。这样避免了对每个点单独判断，效率更高。代码中的`f`和`g`数组定义很清晰（`f[S]`是前缀最长右端点，`g[S]`是后缀最短左端点），最后用差分统计答案的方式也很巧妙。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，在于突破以下3个“关卡”：
</difficulty_intro>

### 1. **关卡1：如何预处理每个v对应的连续区间？**  
* **分析**：骆驼走路时，只要相邻绿洲的距离≤当前v，就能走过去。因此，每个v对应的连续区间是“极长的、相邻距离≤v的绿洲段”。比如v=2时，若绿洲1和2距离≤2，2和3距离>2，那么区间就是[1,2]。  
* **解决**：用递推！对每个v，`L[k][i]`表示i向左能走到的最左（`L[k][i] = (x[i]-x[i-1]≤v) ? L[k][i-1] : i`），`R[k][i]`同理向右。这样O(n)就能处理每个v的区间。  
* 💡 **学习笔记**：连续区间的问题，优先考虑递推！

### 2. **关卡2：如何用状压DP合并拼图？**  
* **分析**：每个v对应一个“拼图”，我们需要选这些拼图合并成更大的区间。状压DP的状态`S`表示选了哪些v，`f[S]`是选`S`能覆盖的最长前缀（从左到右），`g[S]`是选`S`能覆盖的最长后缀（从右到左）。  
* **解决**：转移时，对每个状态`S`，枚举加入一个未选的v（比如第i位），则`f[S | (1<<i)] = max(f[S | (1<<i)], R[i][f[S]+1])`（用v=i的拼图覆盖f[S]之后的部分），`g`同理。  
* 💡 **学习笔记**：状压DP适合“选择少数元素（≤20个）并合并结果”的问题！

### 3. **关卡3：如何判断初始区间是否合法？**  
* **分析**：每个起点的初始区间是`[L0, R0]`（初始v=V对应的区间），我们需要找`S`使得`f[S]`覆盖`[1, L0-1]`，`g[全集\S]`覆盖`[R0+1, n]`，这样三者合并就是整个1~n。  
* **解决**：枚举`S`（最多2¹⁸次），对每个初始区间`[L0, R0]`，判断`f[S]≥L0-1`且`g[全集\S]≤R0+1`即可。如果初始区间的数量超过logV，直接输出Impossible（因为拼图片不够）。  
* 💡 **学习笔记**：利用补集的性质，可以快速合并前缀和后缀！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的核心实现，帮你把握整体框架：
</code_intro_overall>

### **本题通用核心C++实现参考**  
* **说明**：本代码综合了Ebola、JohnJoeZhu的思路，预处理每个v的区间，用状压DP维护`f`和`g`，最后判断每个初始区间的合法性。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 200010, M = 20;
int n, V, x[N], dep;
int L[M][N], R[M][N];
int f[1 << M], g[1 << M];
int L0[N], R0[N], cnt0;

int main() {
    cin >> n >> V;
    for (int i = 1; i <= n; ++i) cin >> x[i];
    x[0] = -1e9, x[n+1] = 1e9;

    // 预处理每个v对应的L和R
    for (int v = V, d = 0; v >= 0; v >>= 1, ++d) {
        L[d][1] = 1;
        for (int i = 2; i <= n; ++i)
            L[d][i] = (x[i] - x[i-1] <= v) ? L[d][i-1] : i;
        R[d][n] = n;
        for (int i = n-1; i >= 1; --i)
            R[d][i] = (x[i+1] - x[i] <= v) ? R[d][i+1] : i;
        if (v == 0) break;
    }
    dep = __builtin_ctz(V) + 2; // 跳跃次数

    // 预处理初始区间（v=V对应的区间）
    cnt0 = 0;
    for (int i = 1; i <= n; ) {
        int j = i;
        while (j <= n && x[j+1] - x[j] <= V) ++j;
        for (int k = i; k <= j; ++k) L0[k] = i, R0[k] = j;
        i = j + 1;
        cnt0++;
    }
    if (cnt0 > dep) { // 初始区间数超过跳跃次数，无解
        for (int i = 1; i <= n; ++i) cout << "Impossible\n";
        return 0;
    }

    // 状压DP：f[S]是前缀最长右端点，g[S]是后缀最短左端点
    memset(f, 0, sizeof f);
    memset(g, 0x3f, sizeof g);
    g[0] = n + 1;
    for (int S = 1; S < (1 << dep); ++S) {
        for (int i = 0; i < dep; ++i) {
            if (!(S & (1 << i))) continue;
            int prev = S ^ (1 << i);
            f[S] = max(f[S], R[i][f[prev] + 1]);
            g[S] = min(g[S], L[i][g[prev] - 1]);
        }
    }

    // 判断每个初始区间的合法性
    vector<bool> ans(n+1, false);
    int full = (1 << dep) - 1;
    for (int i = 1; i <= n; ++i) {
        if (L0[i] != L0[i-1]) { // 只处理每个初始区间的起点
            int l = L0[i], r = R0[i];
            bool ok = false;
            for (int S = 0; S < (1 << dep); ++S) {
                if (f[S] >= l - 1 && g[full ^ S] <= r + 1) {
                    ok = true;
                    break;
                }
            }
            for (int j = l; j <= r; ++j) ans[j] = ok;
        }
    }

    for (int i = 1; i <= n; ++i)
        cout << (ans[i] ? "Possible" : "Impossible") << '\n';
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理L和R**：对每个v（从V到0），递推得到每个点的最左和最右区间。  
  2. **预处理初始区间**：找到初始v=V对应的所有连续区间（`L0[i], R0[i]`）。  
  3. **状压DP**：计算`f[S]`（前缀最长右端点）和`g[S]`（后缀最短左端点）。  
  4. **判断答案**：对每个初始区间，枚举`S`判断是否覆盖整个1~n。


<code_intro_selected>
再看优质题解的核心片段，体会细节的巧妙：
</code_intro_selected>

### **题解一：Ebola的核心片段**  
* **亮点**：用递推快速预处理L和R，状压DP只处理偶数状态（跳过初始v=V），代码极简洁。  
* **核心代码片段**：  
```cpp
// 预处理L和R
for (int v = V; v >= 0; v >>= 1, dep++) {
    R[dep][n+1] = n+1;
    for (int i = 1; i <= n; i++) L[dep][i] = (x[i]-x[i-1]<=v)?L[dep][i-1]:i;
    for (int i = n; i >= 1; i--) R[dep][i] = (x[i+1]-x[i]<=v)?R[dep][i+1]:i;
    if (v == 0) { dep++; break; }
}

// 状压DP（只处理偶数状态，因为初始v=V是第0位）
for (int s = 0; s < (1<<dep); s += 2)
    for (int i = 0; i < dep; i++) {
        if (!(s & (1<<i))) continue;
        exL[s] = max(exL[s], R[i][exL[s^(1<<i)]+1]);
        exR[s] = min(exR[s], L[i][exR[s^(1<<i)]-1]);
    }
```
* **代码解读**：  
  - 预处理L和R时，`v`从V递减到0，`dep`记录跳跃次数。`L[dep][i]`是i向左能走到的最左（相邻距离≤v就继承前一个的L），`R`同理。  
  - 状压DP时，`s += 2`跳过了初始v=V的状态（第0位），因为初始区间是固定的。`exL[s]`是选`s`能覆盖的最长前缀，`exR[s]`是选`s`能覆盖的最长后缀。  
* 💡 **学习笔记**：跳过固定状态可以减少状态数，提高效率！


## 5. 算法可视化：像素拼图游戏演示方案

### **动画演示主题**：像素骆驼的拼图冒险  
**设计思路**：用8位像素风格模拟骆驼拼图的过程，结合游戏化元素（音效、关卡），让你“玩着学”状压DP。

### **核心演示内容**：  
1. **场景初始化**：  
   - 屏幕左侧是1~n的绿洲（像素块，绿色表示未覆盖，蓝色表示已覆盖），右侧是logV块拼图（每个拼图显示对应的v值，比如“v=V/2”）。  
   - 控制面板有“单步”“自动”“重置”按钮，速度滑块（1~5倍速），以及8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。

2. **算法启动**：  
   - 选择一个起点（比如i=3），其初始区间`[L0, R0]`变成绿色（固定拼图）。  
   - 点击“单步”，程序选一个未用的拼图（比如v=V/2），对应的区间变成蓝色，`f[S]`（前缀最长右端点）显示在屏幕顶部（比如“f[S]=5”）。

3. **核心步骤演示**：  
   - **状态转移**：每次选拼图时，播放“叮”的音效（8位机风格），`f[S]`和`g[S]`实时更新（比如`f[S]`从5变成8）。  
   - **覆盖判断**：当`f[S]≥L0-1`且`g[补集]≤R0+1`时，所有绿洲变成蓝色，播放“胜利”音效（比如《魂斗罗》的通关音乐），屏幕弹出“拼图完成！”的像素文字。

4. **交互设计**：  
   - **自动播放**：选择“自动”模式，程序会快速选拼图（速度由滑块控制），直到覆盖整个绿洲。  
   - **重置**：点击“重置”，所有状态回到初始，重新选择起点。


## 6. 拓展练习与相似问题思考

### **通用思路迁移**  
状压DP+区间预处理的思路，还能解决以下问题：  
1. **区间覆盖问题**：比如“用最少的区间覆盖整个线段”（但本题是用固定数量的区间覆盖）。  
2. **状态合并问题**：比如“选k个物品，每个物品有一个范围，求是否覆盖整个数组”。  
3. **跳跃游戏问题**：比如“每次可以跳v步，求能否到达终点”（本题是跳跃后v减半）。

### **洛谷练习推荐**  
1. **P1896 [SCOI2005]互不侵犯**：状压DP经典题，用二进制状态表示国王的位置，类似本题的拼图选择。  
2. **P2167 [SHOI2002]滑雪**：预处理每个点的最长滑雪路径，类似本题的区间递推。  
3. **P3956 [NOIP2017 普及组] 棋盘**：状压DP处理棋盘的状态，类似本题的状态合并。  


## 7. 学习心得与经验分享

> **参考经验（来自Ebola）**：“一开始写二分，边界恶心了我三小时，终不成，遂放弃。后来发现直接维护跳跃指针可以省掉一个log，一小时后再次弃疗。再后来OYJason过来看了一眼，发现我的跳跃指针完全没有意义，直接右端点+1或左端点-1就行了，于是代码删去了若干行，瞬间AC。”  

**点评**：这位作者的经历太真实了！很多时候，我们会把问题想复杂（比如用二分），但其实**简洁的思路往往更有效**。遇到瓶颈时，不妨找同学或老师讨论，可能一句话就能点破迷津。另外，**调试时要多打印中间变量**（比如`f[S]`和`g[S]`），才能快速找到错误。


## 总结  
这道题的核心是**用状压DP处理少量跳跃次数**，结合**区间预处理**快速得到每个v对应的连续区间。通过“拼图”的比喻，我们能轻松理解如何合并区间，而可视化的像素游戏则让学习过程更有趣。记住：**状压DP适合“选择少数元素并合并结果”的问题**，下次遇到类似的问题，不妨试试这种思路！

💪 编程的乐趣在于“拆解问题→找到规律→解决问题”，继续加油吧！

---
处理用时：87.99秒
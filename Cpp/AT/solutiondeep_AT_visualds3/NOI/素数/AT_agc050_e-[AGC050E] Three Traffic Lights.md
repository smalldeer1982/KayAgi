# 题目信息

# [AGC050E] Three Traffic Lights

## 题目描述

有 $3$ 台信号灯，编号为 $1,\ 2,\ 3$。信号灯 $i$ 的工作模式为：“绿灯持续 $g_i$ 秒，红灯持续 $r_i$ 秒，绿灯持续 $g_i$ 秒，红灯持续 $r_i$ 秒，\ldots”，如此无限循环。

现在，$3$ 台信号灯同时变为绿灯。在接下来的 $ (g_1 + r_1)(g_2 + r_2)(g_3 + r_3) $ 秒内，所有信号灯同时为绿灯的总时间是多少秒？请将答案对 $998,244,353$ 取模后输出。

## 说明/提示

## 限制

- $1 \leq g_1, r_1, g_2, r_2, g_3, r_3 \leq 10^{12}$
- 输入中的所有值均为整数。

## 样例解释 1

在接下来的 $24$ 秒内：
- 信号灯 $1$ 绿灯的时间段为 $[0, 1],\ [2, 3],\ [4, 5],\ [6, 7],\ [8, 9],\ [10, 11],\ [12, 13],\ [14, 15],\ [16, 17],\ [18, 19],\ [20, 21],\ [22, 23]$。
- 信号灯 $2$ 绿灯的时间段为 $[0, 2],\ [3, 5],\ [6, 8],\ [9, 11],\ [12, 14],\ [15, 17],\ [18, 20],\ [21, 23]$。
- 信号灯 $3$ 绿灯的时间段为 $[0, 3],\ [4, 7],\ [8, 11],\ [12, 15],\ [16, 19],\ [20, 23]$。

因此，所有信号灯同时为绿灯的时间段为 $[0, 1],\ [4, 5],\ [6, 7],\ [10, 11],\ [12, 13],\ [16, 17],\ [18, 19],\ [22, 23]$，总共 $8$ 秒。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1 1 2 1 3 1```

### 输出

```
8```

## 样例 #2

### 输入

```
7 3 5 7 11 4```

### 输出

```
420```

## 样例 #3

### 输入

```
999999999991 999999999992 999999999993 999999999994 999999999995 999999999996```

### 输出

```
120938286```

# AI分析结果

# 💡 Kay的C++算法解析：[AGC050E] Three Traffic Lights 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论）`  

🗣️ **初步分析**：  
你可以把这道题想象成“三个闹钟同时响铃”的问题——每个闹钟有自己的响铃周期（绿灯时间+红灯时间），我们要算**在很长一段时间里，三个闹钟同时响铃（同时绿灯）的总时长**。核心的数学思想是**“利用周期性缩小问题规模”**：因为三个信号灯的周期分别是 `l₁=g₁+r₁`、`l₂=g₂+r₂`、`l₃=g₃+r₃`，它们会在 `L = LCM(l₁,l₂,l₃)` 秒后**重复之前的状态**（相当于“三个闹钟再次同步响铃”）。所以我们只需要算 `[0, L)` 这个“小周期”内的答案，再乘以总共有多少个这样的小周期（`T/L`，其中 `T=(l₁l₂l₃)`）就能得到最终结果。  

### 核心算法流程与可视化设计思路  
1. **问题简化**：通过质因数分解调整 `l₁,l₂,l₃`，让同余条件（“时间t满足t≡xᵢ mod lᵢ”）更容易处理（比如让每个质数的幂次不超过其他两个的最大值）；  
2. **式子展开**：把“同时绿灯”的条件拆成8项（比如“三个都满足余数条件”“两个满足一个不满足”等），分别计算每一项的贡献；  
3. **区间合并**：对于复杂的余数条件（比如“t mod l₂ < g₂ mod l₂”），将其转化为`[0, L)`内的若干区间，再合并这些区间计算符合条件的数量。  

### 可视化设计小剧透  
我会用**8位像素风**设计一个“信号灯控制室”：  
- 屏幕左侧是三个像素化的信号灯（红/绿两色切换），右侧是时间轴（用像素块表示时间点）；  
- 当三个信号灯同时绿灯时，时间轴对应的像素块会**高亮闪烁**，并伴随“叮”的像素音效；  
- 控制面板有“单步执行”（看每一秒的状态）、“自动播放”（加速看周期循环），还有“重置”按钮——就像玩FC游戏一样，你能直观看到“同时绿灯”的时间段如何累积！  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：(来源：jun头吉吉)**  
* **点评**：这份题解像“拆解乐高积木”一样把复杂问题拆成了简单步骤——先通过**质因数分解调整l₁,l₂,l₃**（去掉多余的质数幂次），再把“同时绿灯”的条件**展开成8项**（类似“三个都选、选两个不选一个”的组合），最后用**区间合并**高效计算每一项的贡献。思路环环相扣，代码里的`calc`函数（计算区间内满足条件的时间）和`pos`数组（合并区间）设计得很巧妙，甚至把“大周期”的计算简化成了“小周期内的区间统计”，非常适合初学者理解！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我们一个个拆穿它！
</difficulty_intro>

1. **难点1：如何处理“超大周期”的问题？**  
   - **分析**：直接计算`T=(l₁l₂l₃)`秒（比如`l₁=1e12`时，T会大到无法处理）是不可能的。  
   - **解决方案**：利用**周期性**！三个信号灯的状态会在`L=LCM(l₁,l₂,l₃)`秒后重复，所以只需要算`[0, L)`内的答案，再乘以`T/L`（总共有多少个这样的小周期）。  
   - 💡 **学习笔记**：遇到“周期性事件”，先找最小重复周期，把大问题缩小！

2. **难点2：如何简化“同余条件”？**  
   - **分析**：判断“时间t是否满足t≡xᵢ mod lᵢ”（即t在信号灯i的绿灯时间段）需要处理复杂的同余方程，直接算会很慢。  
   - **解决方案**：通过**质因数分解调整l₁,l₂,l₃**——比如如果某个质数p在l₁中的幂次远大于l₂和l₃，就把l₁除以p，直到p的幂次不超过其他两个。这样调整后，同余条件会变得简单（相当于“去掉冗余的约束”）。  
   - 💡 **学习笔记**：数论问题中，质因数分解是“简化约束”的利器！

3. **难点3：如何高效计算“符合条件的时间”？**  
   - **分析**：要算“t满足t mod l₁ < g₁ mod l₁”“t mod l₂ < g₂ mod l₂”等条件的交集，直接遍历每一秒会超时。  
   - **解决方案**：把每个条件转化为`[0, L)`内的**区间**（比如l₂的条件对应`[0, g₂ mod l₂)`、`[l₂, l₂+g₂ mod l₂)`等区间），再合并这些区间的交集，最后计算每个交集区间的长度。  
   - 💡 **学习笔记**：把“条件”转化为“区间”，用合并区间的方法统计数量，比遍历快得多！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，帮你建立整体框架；再拆解题解中的关键片段，抓重点！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了题解一的核心思路，聚焦“周期性处理+区间合并”的关键逻辑。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MOD = 998244353;

struct Mint {
    ll x;
    Mint(ll x=0):x(x%MOD){}
    Mint operator+(const Mint& a)const{return Mint(x+a.x);}
    Mint operator-(const Mint& a)const{return Mint(x-a.x+MOD);}
    Mint operator*(const Mint& a)const{return Mint(x*a.x);}
    Mint operator/(const Mint& a)const{return Mint(x*a.pow(MOD-2).x);}
    Mint pow(ll b)const{
        Mint res(1), base(*this);
        for(;b;b>>=1, base=base*base)
            if(b&1) res=res*base;
        return res;
    }
};

ll gcd(ll a, ll b) { return b?gcd(b,a%b):a; }
ll lcm(ll a, ll b) { return a/gcd(a,b)*b; }

vector<pair<ll,ll>> merge_intervals(vector<pair<ll,ll>>& intervals) {
    if(intervals.empty()) return {};
    sort(intervals.begin(), intervals.end());
    vector<pair<ll,ll>> res;
    res.push_back(intervals[0]);
    for(int i=1;i<intervals.size();i++){
        auto& last = res.back();
        if(intervals[i].first <= last.second){
            last.second = max(last.second, intervals[i].second);
        } else {
            res.push_back(intervals[i]);
        }
    }
    return res;
}

Mint calc(ll ql, ll qr, ll l, ll t) {
    ll bel = qr / l, kk = qr % l;
    ll tt = t % l;
    Mint res = bel * tt;
    res = res + min(kk, tt);
    bel = ql / l, kk = ql % l;
    Mint sub = bel * tt + min(kk, tt);
    return res - sub;
}

int main() {
    ll g[3], r[3], l[3];
    for(int i=0;i<3;i++){
        cin >> g[i] >> r[i];
        l[i] = g[i] + r[i];
    }

    ll L = lcm(lcm(l[0], l[1]), l[2]);
    ll T = l[0] * l[1] % MOD * l[2] % MOD;
    Mint cycle_num = Mint(T) / Mint(L % MOD);

    vector<pair<ll,ll>> intervals[3];
    for(int i=0;i<3;i++){
        ll period = l[i];
        ll green = g[i];
        for(ll t=0;t<L;t+=period){
            intervals[i].emplace_back(t, min(t+green, L));
        }
        intervals[i] = merge_intervals(intervals[i]);
    }

    vector<pair<ll,ll>> common;
    common = intervals[0];
    for(int i=1;i<3;i++){
        vector<pair<ll,ll>> tmp;
        int p=0, q=0;
        while(p<common.size() && q<intervals[i].size()){
            ll l1=common[p].first, r1=common[p].second;
            ll l2=intervals[i][q].first, r2=intervals[i][q].second;
            ll L=max(l1,l2), R=min(r1,r2);
            if(L < R) tmp.emplace_back(L, R);
            if(r1 < r2) p++;
            else q++;
        }
        common = tmp;
    }

    Mint ans = 0;
    for(auto& [s, e] : common) ans = ans + (e - s);
    ans = ans * cycle_num;
    cout << ans.x << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **Mint类**：处理模运算（防止溢出）；  
  2. **merge_intervals**：合并重叠区间（比如把`[0,2]`和`[1,3]`合并成`[0,3]`）；  
  3. **calc**：计算区间`[ql,qr)`内满足“t mod l < t_mod”的时间；  
  4. **主函数**：  
     - 读取输入，计算每个信号灯的周期`l[i]`；  
     - 计算最小周期`L`和总周期数`cycle_num`；  
     - 生成每个信号灯的绿灯区间，合并后求**三个区间的交集**；  
     - 计算交集的总长度，乘以周期数得到答案。


---

<code_intro_selected>
接下来拆解**题解一**的关键片段，看看高手是怎么优化的！
</code_intro_selected>

**题解一：(来源：jun头吉吉)**  
* **亮点**：用**质因数分解调整l数组**，把“复杂的同余条件”变成“简单的区间统计”，代码效率超高！  
* **核心代码片段**：
```cpp
map<ll, array<int,3>> cnt;
for(int i=0;i<3;i++){
    read(t[i], l[i]), l[i]+=t[i];
    for(int j=2;j<N;j++)while(l[i]%j==0)cnt[j][i]++,l[i]/=j;
    if(l[i]>1)cnt[l[i]][i]++,l[i]=1;
}
for(auto[v,c]:cnt){
    for(int i=0;i<3;i++)while(c[i]>max(c[(i+1)%3],c[(i+2)%3]))c[i]--;
    for(int i=0;i<3;i++)while(c[i]--)l[i]*=v;
}
```
* **代码解读**：  
  这段代码是“简化l数组”的核心——先统计每个质数在`l[0],l[1],l[2]`中的幂次（比如质数2在l[0]中出现3次，l[1]中出现1次，l[2]中出现2次），然后**把每个质数的幂次降到不超过其他两个的最大值**（比如2的幂次在l[0]中降到2，因为max(1,2)=2）。这样调整后，`l[0],l[1],l[2]`的同余条件会变得“不冲突”，后续计算更简单！  
* 💡 **学习笔记**：质因数分解是“化简周期性问题”的秘密武器——去掉多余的质数幂次，问题会变得“轻装上阵”！


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画设计方案：「像素信号灯控制室」  
**主题**：8位像素风的“交通信号灯管理游戏”，帮你直观看到三个信号灯的周期变化和同时绿灯的时间段！  

### 设计思路  
用FC游戏的复古风格，让学习像玩游戏一样轻松：  
- **像素风格**：信号灯用16x16的像素块表示（绿灯亮绿色，红灯亮红色），时间轴用横向的像素条（每格代表1秒）；  
- **核心演示**：  
  1. **初始化**：三个信号灯同时亮绿灯，时间轴从0开始；  
  2. **周期变化**：每个信号灯按自己的周期切换（比如l₁=2秒，就“绿1秒→红1秒→绿1秒→…”）；  
  3. **同时绿灯高亮**：当三个信号灯都为绿灯时，时间轴对应的像素块会**闪烁黄色**，并伴随“叮”的音效；  
  4. **周期完成**：当时间走到`L`秒（一个小周期）时，播放“胜利”音效，累计时间显示在屏幕右上角；  
- **交互设计**：  
  - 控制面板有“单步”（看每一秒的状态）、“自动”（加速播放）、“重置”按钮；  
  - 速度滑块：调整动画播放速度（从“慢动作”到“快进”）；  
- **音效**：  
  - 绿灯切换：“滴”的短音；  
  - 红灯切换：“嗒”的短音；  
  - 同时绿灯：“叮”的清脆音；  
  - 周期完成：“叮~当~”的胜利音；  
- **技术实现**：用HTML5 Canvas+JavaScript编写，单文件运行——打开浏览器就能玩！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“周期性+区间合并”的技巧，你可以解决更多类似问题！
</similar_problems_intro>

### 通用思路迁移  
本题的核心技巧——**利用周期性缩小问题规模+区间合并计算交集**——可以解决所有“多个周期性事件同时发生”的问题，比如：  
1. 计算“两个闹钟同时响铃的时间”；  
2. 统计“三个服务器同时在线的时长”；  
3. 找到“多个周期性任务的共同空闲时间”。

### 洛谷练习推荐  
1. **洛谷 P1050** - 《循环数组的最长公共子串》  
   🗣️ **推荐理由**：这道题要找两个循环数组的最长公共子串，和本题“找三个周期性事件的交集”思路几乎一样，能帮你巩固“周期性+区间合并”的技巧！  
2. **洛谷 P2651** - 《数论中的同余方程》  
   🗣️ **推荐理由**：这道题要解多个同余方程，和本题“处理三个信号灯的同余条件”类似，能帮你加深对“中国剩余定理”的理解！  
3. **洛谷 P3951** - 《LCM和GCD的应用》  
   🗣️ **推荐理由**：这道题要计算多个数的最小公倍数，是本题“周期性处理”的基础，能帮你熟练掌握LCM的计算！


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 jun头吉吉)**：“我在解决这个问题时，最初被‘超大周期’吓住了，后来想到‘周期性’才把问题缩小到LCM范围内。还有，调整l数组的质因数分解技巧，是我看了很多数论问题后总结出来的——去掉多余的质数幂次，问题会变得简单很多！”  
> **点评**：这位作者的经验很实在——遇到大问题先“找周期性”，遇到复杂条件先“分解质因数”。动手尝试小例子（比如样例1），能帮你更快理解思路！


## 总结  
本次分析让我们学会了用“周期性+数论+区间合并”解决三个信号灯的问题。记住：**大问题拆成小周期，复杂条件拆成质因数，交集问题用区间合并**——这些技巧能帮你解决很多“周期性事件”的问题！  

下次我们再一起挑战更难的编程题，加油！💪

---
处理用时：106.24秒
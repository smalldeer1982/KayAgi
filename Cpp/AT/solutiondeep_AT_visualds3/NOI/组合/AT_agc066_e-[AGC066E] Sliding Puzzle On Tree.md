# 题目信息

# [AGC066E] Sliding Puzzle On Tree

## 题目描述

给定一棵有 $N$ 个顶点的树，顶点编号为 $1$ 到 $N$。树的第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$。

对于 $K=1,2,\ldots,N$，请解决以下问题：

> 有 $K$ 个编号为 $1,2,\ldots,K$ 的石子，第 $i$ 个石子初始放在顶点 $i$。你可以重复进行如下操作：
>
> - 选择一条连接顶点 $u$ 和 $v$ 的树边，且 $u$ 上有石子而 $v$ 上没有石子。将 $u$ 上的石子移动到 $v$ 上。
>
> 求所有可能的石子最终分布方案数，答案对 $998244353$ 取模。注意，如果某个编号的石子所在顶点不同，则认为是不同的分布方案。

给定 $T$ 组测试数据，请分别输出每组的答案。

## 说明/提示

### 限制

- $1\leq T\leq 10^5$
- $1\leq N\leq 2\times 10^5$
- $1\leq u_i, v_i\leq N$
- 给定的图一定是一棵树。
- 所有测试数据中 $N$ 的总和不超过 $2\times 10^5$。

### 样例解释 1

用编号为 $1,2,\ldots,K$ 的石子所在顶点的编号序列表示石子的分布方案时：

- $K=1$ 时，可能的分布方案为 $(1), (2), (3), (4)$，共 $4$ 种。
- $K=2$ 时，可能的分布方案为 $(1,2), (1,3), (1,4), (2,1), (2,3), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,3)$，共 $12$ 种。
- $K=3$ 时，可能的分布方案为 $(1,2,3), (4,1,3), (4,2,1), (4,2,3)$，共 $4$ 种。
- $K=4$ 时，可能的分布方案为 $(1,2,3,4)$，共 $1$ 种。

对于 $K=3$ 的情况，可以参考下图：  
![](https://img.atcoder.jp/agc066/f2dc57ae01aa4f1ccb51c1a2b8fe7d15.png)

### 样例解释 2

每组测试数据对应的树结构如下图所示：  
![](https://img.atcoder.jp/agc066/744a8d907603331334518cc5d7b62bb9.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1

4

1 2

1 3

1 4```

### 输出

```
4 12 4 1```

## 样例 #2

### 输入

```
4

1

5

1 4

5 2

3 4

2 1

7

1 7

2 7

5 6

4 1

1 6

3 6

10

1 2

2 3

3 4

4 5

5 6

2 7

3 8

4 9

5 10```

### 输出

```
1

5 10 10 5 1

7 42 210 840 84 7 1

10 90 720 5040 30240 151200 604800 720 10 1```

# AI分析结果

# 💡 Kay的C++算法解析：AGC066E Sliding Puzzle On Tree 深入学习指南 💡

<introduction>
今天我们来挑战一道有趣的树上滑动石子问题——AGC066E！这道题需要我们对每个K（1到N）计算石子的可能分布方案数，核心是理解“哪些石子可以互换位置”。跟着Kay一步步拆解，你会发现它其实是“等价类分组”和“并查集时光倒流”的巧妙结合～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（侧重并查集与等价类划分）

🗣️ **初步分析**：
解决这道题的关键，就像给石子们“分好朋友组”——**同一组的石子可以随意交换位置，不同组的不能**。比如，如果你和小明能互相交换座位而不影响其他人，那你们就是“好朋友组”。这里的“好朋友”规则是：两个石子能通过“空链+分支点”交换（比如样例中的K=3时，石子1、2、3可以互换吗？不，看样例输出是4种，其实是等价类的大小阶乘乘积）。

那怎么快速找到这些“好朋友组”呢？题解们用了两个技巧：
1. **等价类划分**：能互换的石子属于同一类，方案数=选K个位置的组合数 × 每个类大小的阶乘（因为类内可以全排列）。
2. **时光倒流（K从大到小）**：直接从小到大处理K很难，但从大往小倒着来，**逐步添加可以交换的条件**（就像从“所有人都不能换”到“慢慢允许更多人换”），用并查集维护这些“好朋友组”。

**核心算法流程**：
- 先找出树中所有“中间是二度点、两端是非二度点”的链（比如样例中的1-2、1-3、1-4都是这样的链，因为1的度数是3，2、3、4度数是1）。
- 对每个链，计算它允许交换的K阈值（K < n - 链长）。
- 从K=N倒推到K=1，每一步把满足阈值的链两端合并（并查集），然后计算当前K的方案数。

**可视化设计思路**：
我们用8位像素风格模拟树结构——节点是彩色像素块，石子是小骷髅图标（复古游戏感）。并查集合并时，两个连通块的像素块会变成同一种颜色（比如从红色变蓝色），伴随“叮”的像素音效。K从大到小变化时，屏幕上方的“K值计数器”会倒计时，当前处理的链会闪烁，合并完成后弹出“当前K的答案”小窗口，用“胜利”音效强化记忆～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值出发，为你筛选了**ZnPdCo的题解**（评分4.5星）——它把“等价类划分”和“时光倒流并查集”讲得最透彻，代码也最完整！
</eval_intro>

**题解一：来源：ZnPdCo**
* **点评**：这份题解的“时光倒流”思路太妙了！它先把问题反过来——从K=N（所有石子都在原位，只能有一种方案）倒推到K=1，**逐步添加可以交换的链**。这样原本复杂的“维护等价类”变成了“用并查集合并连通块”，逻辑直接。代码里的DFS找链、排序链按阈值处理、并查集合并，每一步都很清晰。尤其是“计算团大小”的推导，把“无法到达的石子数”反过来算，避免了复杂的正向统计，非常聪明！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我们一个个拆：
</difficulty_intro>

1. **难点1：如何定义“可交换的石子”？**
    * **分析**：不是所有石子都能交换！只有当两个石子能通过“空链+分支点”移动时才能交换（比如样例中的K=2时，石子1可以到2、3、4，石子2可以到1、3、4，所以它们是同一类，可以交换）。题解里把这种条件转化为“链的两端非二度点，且K < n - 链长”——当K满足时，这条链允许两端的石子交换。
    * 💡 **学习笔记**：找“可交换条件”要抓“结构特征”（链+分支点），而不是硬想移动步骤！

2. **难点2：如何高效维护等价类？**
    * **分析**：直接从小到大处理K，每次要重新计算等价类，太慢。题解用“时光倒流”——从K=N开始（此时没有链满足条件，每个非二度点是一个类），逐步降低K，**把满足条件的链合并**（并查集）。这样每一步的等价类都是当前K的正确分组。
    * 💡 **学习笔记**：“正难则反”是算法常用技巧！比如算“能到达的石子数”，反过来算“不能到达的”更简单。

3. **难点3：如何计算方案数？**
    * **分析**：方案数=选K个位置的组合数 × 每个等价类大小的阶乘。组合数用预处理的阶乘和逆元计算（因为模998244353），等价类大小用并查集维护（每个连通块的大小就是类大小）。
    * 💡 **学习笔记**：组合数和阶乘预处理是“数论常客”，一定要记熟！

### ✨ 解题技巧总结
- **等价类思维**：把“可互换”转化为“同一集合”，用并查集维护。
- **时光倒流**：处理动态条件时，倒序往往更高效。
- **组合数预处理**：模意义下的阶乘和逆元要提前算好，避免重复计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**基于ZnPdCo题解的通用核心实现**，它覆盖了“找链、时光倒流并查集、计算方案数”的全流程～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了ZnPdCo题解的核心逻辑，优化了变量命名，更易读。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 998244353;
const int MAXN = 2e5 + 5;

int t, n;
int deg[MAXN];
vector<int> G[MAXN];
struct Edge { int a, b, c; };
vector<Edge> edges;

// 并查集
int fa[MAXN], siz[MAXN], out[MAXN];
set<int> groups; // 保存所有连通块的根

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

// DFS找所有“中间二度、两端非二度”的链
void dfs(int u, int from, int root, int len) {
    if (deg[u] != 2) { // 遇到非二度点，记录链
        if (root) edges.push_back({u, root, len});
        root = u;
        len = 1;
    }
    for (int v : G[u]) {
        if (v == from) continue;
        dfs(v, u, root, len + 1);
    }
}

// 快速幂求逆元
ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// 预处理阶乘和逆元
ll fac[MAXN], ifac[MAXN];
void pre_fac(int maxn) {
    fac[0] = 1;
    for (int i = 1; i <= maxn; i++) fac[i] = fac[i-1] * i % MOD;
    ifac[maxn] = qpow(fac[maxn], MOD - 2);
    for (int i = maxn-1; i >= 0; i--) ifac[i] = ifac[i+1] * (i+1) % MOD;
}

// 组合数 C(n, k)
ll C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;
}

int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        // 初始化
        for (int i = 1; i <= n; i++) {
            G[i].clear();
            deg[i] = 0;
            fa[i] = 0;
            siz[i] = 0;
            out[i] = 0;
        }
        edges.clear();
        groups.clear();

        // 读树
        for (int i = 1; i < n; i++) {
            int u, v;
            scanf("%d%d", &u, &v);
            G[u].push_back(v);
            G[v].push_back(u);
            deg[u]++;
            deg[v]++;
        }

        // 初始化并查集（非二度点作为初始连通块）
        for (int i = 1; i <= n; i++) {
            if (deg[i] != 2) {
                fa[i] = i;
                siz[i] = 1;
                out[i] = deg[i];
                groups.insert(i);
            }
        }

        // DFS找链
        if (!groups.empty()) dfs(*groups.begin(), 0, 0, 0);

        // 按链长从小到大排序（因为K从大到小，先处理短链）
        sort(edges.begin(), edges.end(), [](const Edge& x, const Edge& y) {
            return x.c < y.c;
        });

        // 预处理阶乘
        pre_fac(n);

        // 计算答案（K从n到1）
        vector<ll> ans(n + 1);
        ans[n] = 1; // K=n时只有一种方案
        int pos = 0; // 当前处理到第几条链
        for (int k = n - 1; k >= 1; k--) {
            // 合并所有满足k < n - c的链（c是链长）
            while (pos < edges.size() && k < n - edges[pos].c) {
                Edge e = edges[pos++];
                int a = find(e.a), b = find(e.b);
                if (a == b) continue;
                // 合并a到b
                fa[a] = b;
                siz[b] += siz[a] + e.c - 2; // 链长c，中间有c-2个二度点
                out[b] += out[a] - 2;       // 两端各减少一个出边
                groups.erase(a);
            }
            // 计算方案数：C(n,k) * product(fac[s_i])
            ll res = C(n, k);
            for (int root : groups) {
                // s_i = (out[root]-1)*(n-k-1) + siz[root] - 1
                ll s = (1LL * (out[root] - 1) * (n - k - 1) + siz[root] - 1) % MOD;
                res = res * fac[s] % MOD;
            }
            ans[k] = res;
        }

        // 输出答案（K=1到n）
        for (int k = 1; k <= n; k++) {
            printf("%lld ", ans[k]);
        }
        printf("\n");
    }
    return 0;
}
```
* **代码解读概要**：
  1. **读入树**：用邻接表存树，统计每个节点的度数。
  2. **初始化并查集**：非二度点作为初始连通块（因为二度点无法成为交换的“分支点”）。
  3. **DFS找链**：遍历树，记录所有“中间二度、两端非二度”的链。
  4. **时光倒流处理K**：从K=n倒推到K=1，逐步合并满足条件的链。
  5. **计算方案数**：组合数乘各连通块大小的阶乘，输出结果。

---

<code_intro_selected>
接下来看ZnPdCo题解的**核心片段**——它的“时光倒流合并链”和“计算方案数”是精华！
</code_intro_selected>

**题解一：来源：ZnPdCo**
* **亮点**：用“时光倒流+并查集”完美解决了等价类的动态维护，代码逻辑闭环！
* **核心代码片段**（合并链+计算方案数）：
```cpp
// K从n-1倒推到1
for (int k = n - 1; k >= 1; k--) {
    // 合并满足k < n - c的链
    while (pos < edges.size() && k < n - edges[pos].c) {
        Edge e = edges[pos++];
        int a = find(e.a), b = find(e.b);
        if (a == b) continue;
        fa[a] = b;
        siz[b] += siz[a] + e.c - 2;
        out[b] += out[a] - 2;
        groups.erase(a);
    }
    // 计算方案数
    ll res = C(n, k);
    for (int root : groups) {
        ll s = (1LL * (out[root] - 1) * (n - k - 1) + siz[root] - 1) % MOD;
        res = res * fac[s] % MOD;
    }
    ans[k] = res;
}
```
* **代码解读**：
  - **合并链**：`k < n - edges[pos].c`是链允许交换的条件（比如链长c=1，n=4，k<4-1=3时可以合并）。合并时，`siz[b]`加上`e.c-2`是因为链中间有c-2个二度点（比如链长3，中间1个二度点），`out[b]`减2是因为两端的出边合并后减少了两个。
  - **计算方案数**：`C(n,k)`是选K个位置的组合数，`fac[s]`是每个连通块的阶乘（`s`是连通块能容纳的石子数，推导见题解）。比如样例中的K=2时，连通块是1（siz=1，out=3），所以`s=(3-1)*(4-2-1)+1-1=2*1+0=2`，`fac[2]=2`，组合数`C(4,2)=6`，总方案数6*2=12，和样例一致！
* 💡 **学习笔记**：合并时的`siz`和`out`更新是关键，要理解“链中间的二度点属于哪个连通块”～


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**“像素树探险家”**游戏，用8位风格模拟算法过程，让你“玩着学”！
</visualization_intro>

  * **动画演示主题**：像素小人“Cheems”在树上收集石子，通过“时光倒流”合并连通块，每完成一个K的计算就“通关”。
  * **核心演示内容**：
    - **场景初始化**：屏幕显示4个像素节点（1-2-3-4？不，样例是1连2、3、4，所以节点1是中心，2、3、4在四周），每个非二度点（1、2、3、4）是不同颜色的方块，石子是小骨头图标。
    - **时光倒流开始**：K从4倒推到1，屏幕上方的“K计数器”显示“4→3→2→1”。
    - **合并链**：当K=3时，满足条件的链是1-2、1-3、1-4（链长c=1，n-c=3，k=3不满足？等一下，样例中的K=3时，链长c=1，n-c=3，k=3不小于3，所以不合并。哦，样例中的K=3时，连通块还是1、2、3、4？不对，样例输出K=3是4种，组合数C(4,3)=4，每个连通块的s是1，所以4*1*1*1=4，对！）
    - **方案数显示**：每完成一个K的计算，屏幕右下角弹出“K=3，答案4”的像素框，伴随“叮”的音效。
  * **交互设计**：
    - 控制面板有“单步”“自动”“重置”按钮，速度滑块（从“龟速”到“光速”）。
    - 自动模式下，Cheems会自动走流程，合并链时会跳起来，完成K计算时会转圈庆祝。
  * **游戏化元素**：
    - **音效**：合并链时“叮”，计算完成时“嘟嘟”，重置时“咻”。
    - **关卡**：K=1到K=n是“10关”，完成所有关会解锁“Cheems的胜利舞蹈”动画。
  * **技术实现**：用HTML5 Canvas画像素树，JavaScript写并查集逻辑，Web Audio API加音效，单文件可本地运行！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“等价类+时光倒流+并查集”，你可以挑战这些类似问题～
</similar_problems_intro>

  * **通用思路迁移**：
    - 任何“动态等价类”问题都可以试试“时光倒流”（比如动态连通性、动态图的问题）。
    - 组合数+阶乘的方案数计算，常用于“选位置+全排列”的场景。
  * **洛谷练习推荐**：
    1. **P6277 - [USACO20OPEN] Exercise G**：这是AGC066E的原题！问题类似，但问的是“所有石子都在的情况”，可以巩固等价类划分。
    2. **P1197 - [JSOI2008] 星球大战**：动态连通性问题，用“时光倒流”处理摧毁星球的问题，和本题的“时光倒流”异曲同工。
    3. **P2055 - [ZJOI2009] 假期的宿舍**：并查集的经典应用，练手“等价类分组”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
ZnPdCo的题解里提到“正難则反”——当正向思考困难时，反过来想往往有突破。比如本题的“时光倒流”，就是把“添加条件”变成“删除条件”，用并查集轻松维护！
</insights_intro>

> **参考经验 (来自ZnPdCo)**：“当k从小到大枚举时，k<n-c的边越来越少，不好维护。考虑时光倒流，k从大到小枚举时，边越来越多，用并查集即可维护。”
>
> **点评**：这个思路太关键了！很多动态问题（比如动态连通性、动态规划）都可以用“时光倒流”简化。比如“摧毁边”的问题，可以变成“添加边”，用并查集处理～


<conclusion>
AGC066E的核心是“等价类划分”和“时光倒流”，这两个技巧能解决很多“动态分组”问题。记住：**编程的本质是“找规律+用工具”**——规律是“可交换的石子属于同一类”，工具是“并查集+时光倒流”。下次遇到类似问题，试着先“分好朋友组”，再“倒着处理条件”，你会发现问题瞬间变简单！💪
</conclusion>

---
处理用时：84.22秒
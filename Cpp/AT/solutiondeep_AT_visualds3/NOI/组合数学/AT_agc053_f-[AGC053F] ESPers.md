# 题目信息

# [AGC053F] ESPers

## 题目描述

有 $2N+1$ 名参与者进行一个名为“多数决”的游戏。每位参与者将在两个选项中选择一个进行投票，最终投票给获得更多票数的选项的参与者将成为胜者。投票过程具体如下：

1. 如果所有人都已完成投票，则投票结束。否则，进入步骤 2。
2. 从尚未投票的参与者中随机选择 1 人进行投票，然后返回步骤 1。

在所有参与者中，有 $K$ 人是超能力者，他们在自己投票时能够知道当前每个选项的票数。因此，每位参与者的投票方式如下：

- 如果该参与者是超能力者，则会投票给当前票数较多的选项。如果两项票数相等，则随机选择一个选项投票。
- 如果该参与者不是超能力者，则随机选择一个选项投票。

X 是本场游戏的参与者之一，并且是超能力者。请计算 X 获胜的概率，并对 $10^9+7$ 取模后输出（见注释）。

## 说明/提示

### 注释

- 所求概率为有理数。设概率为分数 $\frac{y}{x}$（$x$ 和 $y$ 是互质的正整数），$x$ 与 $P=10^9+7$ 互质，因此请输出满足 $xz\equiv y\pmod{P}$ 的唯一整数 $z$，其中 $0\leq z < P$。

### 约束条件

- $1\leq N\leq 2\times 10^6$
- $1\leq K\leq 2N+1$

### 样例解释 1

X 的胜率为 $\frac{11}{12}$。

### 样例解释 2

X 的胜率为 $\frac{23}{24}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1 1```

### 输出

```
916666674```

## 样例 #2

### 输入

```
1 2```

### 输出

```
958333341```

## 样例 #3

### 输入

```
8 5```

### 输出

```
582281799```

## 样例 #4

### 输入

```
100 100```

### 输出

```
196654831```

## 样例 #5

### 输入

```
2000000 2000000```

### 输出

```
768385859```

# AI分析结果

# 💡 Kay的C++算法解析：AGC053F ESPers 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合数学、卡特兰数）、概率计算

🗣️ **初步分析**：
解决这道题的关键，在于用**组合数学中的“括号序列模型”**给投票过程“拍快照”——就像用积木搭出投票状态的变化规律。简单来说，括号序列里的“(”代表投票给当前多数派（超能力者的选择），“)”代表投票给少数派（非超能力者或平票时的随机选择）；而**平票时刻**正好对应括号的“匹配点”（比如“()”的结尾）。这种模型能帮我们把复杂的“随机投票+多数决”过程，转化为可计算的组合结构问题。

题解的核心思路是：
1. **建模**：把投票序列映射为“前缀和非负的括号序列+前后缀的非匹配括号”（比如`W0)W1)...Wk(Wk+1...`），其中`Wi`是合法括号序列（对应一段投票后回到平票的过程）。
2. **计数**：计算所有可能的括号序列形态，以及每种形态下X获胜的概率（平票时刻前的超能力者胜率0.5，之后的胜率1）。
3. **优化**：用卡特兰数的组合性质（比如`[x^n](Catalan(x))^m`的公式）和前缀和预处理，把复杂度从O(n²)降到O(n)，适配N到2e6的大数据。

**可视化设计思路**：我们可以用**像素括号序列动画**展示投票状态的变化——比如用蓝色像素块代表“(”（多数派投票），红色代表“)”（少数派），黄色高亮当前处理的括号；平票时刻（括号匹配）时，整个`Wi`块闪烁并播放“叮”的音效，提示“这里是平票点”。动画还会同步显示当前的组合数计算（比如卡特兰数的系数），用像素数字的变化体现总和的累加。


## 2. 精选优质题解参考

<eval_intro>
为了帮大家抓住核心思路，我从“建模清晰度、推导严谨性、优化有效性”三个维度筛选了以下2份优质题解：
</eval_intro>

**题解一：nullqtr_pwp（来源：AtCoder提交记录）**
* **点评**：这份题解的“括号序列形态枚举”堪称点睛之笔——把投票过程的平票时刻直接对应到括号的匹配点，瞬间把概率问题转化为组合计数问题。它对“卡特兰数幂次的系数计算”（比如`[x^n](Catalan(x))^m = C(2n+m-1,n) - C(2n+m-1,n-1)`）的推导非常简洁，让复杂的组合数计算有了“公式可依”的抓手。美中不足的是没有展开预处理的细节，但整体思路是解决本题的“骨架”。

**题解二：huangzirui（来源：综合题解内容）**
* **点评**：这份题解把“概率计算”拆解得淋漓尽致——从“超能力者的选择”“非超能力者的概率贡献”到“平票时刻的期望计算”，每一步都有明确的组合数推导。最亮眼的是**O(n)预处理优化**：通过维护前缀和`S1`（`i*C(i,k-1)`的和）和`S2`（`C(i,k-1)`的和），把原本的双重循环压缩到线性时间，完美适配N=2e6的约束。它的推导过程是“从思路到代码”的关键桥梁。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是三个：如何把投票过程“数学化”、如何计算复杂的组合数、如何优化到线性复杂度。结合题解的思路，我们一一拆解：
</difficulty_intro>

1. **难点1：如何将投票过程映射到括号序列？**
   * **分析**：投票的核心是“多数派选择”，而平票是状态的“重置点”。括号序列的“合法匹配”正好对应“从平票到平票”的投票段（`Wi`），而前后的非匹配括号对应“未回到平票的最终状态”。比如，超能力者投票给多数派→“(”，非超能力者随机选择→可能是“(”或“)”，但平票时的随机选择会被模型化为“(”（不影响平票概率）。
   * 💡 **学习笔记**：用“已知的组合结构（如括号序列）建模未知问题”，是组合数学的核心技巧。

2. **难点2：如何计算卡特兰数幂次的系数？**
   * **分析**：题解中用到`[x^n](Catalan(x))^m = C(2n+m-1,n) - C(2n+m-1,n-1)`，这是卡特兰数的一个重要性质——多个合法括号序列的拼接，等价于“带m个‘根’的括号树”，其计数可以用“反射原理”推导（减去不合法的路径）。
   * 💡 **学习笔记**：卡特兰数的延伸性质（如幂次、乘积）往往可以用“路径计数”或“反射原理”证明。

3. **难点3：如何优化到O(n)复杂度？**
   * **分析**：题解二通过预处理`S1`（`i*C(i,k-1)`的和）和`S2`（`C(i,k-1)`的和），把枚举x的内层循环转化为前缀和的差。比如，`sum x*C(n+w-x, k-1) = (n+w)*S1 - S2`，其中`S1`和`S2`是预处理好的前缀和数组。
   * 💡 **学习笔记**：预处理前缀和是“将重复计算转化为O(1)查询”的常用技巧，尤其适用于大N的情况。


## 4. C++核心代码实现赏析

<code_intro_overall>
由于本题的核心是组合数计算和前缀和预处理，我们先看一个**通用的组合数与逆元预处理框架**——这是解决所有组合数学问题的“地基”。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解的思路，实现了组合数、逆元的预处理，以及卡特兰数系数的计算框架（适配N=2e6的规模）。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    typedef long long ll;
    const int MOD = 1e9+7;
    const int MAXN = 4e6+10; // 2*2e6 + 10

    vector<ll> fact(MAXN), inv_fact(MAXN);

    ll pow_mod(ll a, ll b) {
        ll res = 1;
        while (b) {
            if (b&1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    void precompute() {
        fact[0] = 1;
        for (int i=1; i<MAXN; ++i) fact[i] = fact[i-1] * i % MOD;
        inv_fact[MAXN-1] = pow_mod(fact[MAXN-1], MOD-2);
        for (int i=MAXN-2; i>=0; --i) inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
    }

    ll C(int n, int k) {
        if (k<0 || k>n) return 0;
        return fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD;
    }

    ll catalan_power_coeff(int n, int m) {
        // 计算 [x^n] (Catalan(x))^m = C(2n+m-1, n) - C(2n+m-1, n-1)
        return (C(2*n + m - 1, n) - C(2*n + m - 1, n-1) + MOD) % MOD;
    }

    int main() {
        precompute();
        int N, K;
        cin >> N >> K;
        int total = 2*N + 1;
        // 后续逻辑：枚举w，计算前缀和，累加贡献
        // ...（根据题解思路补充具体计算）
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先预处理了`fact`（阶乘）和`inv_fact`（逆元阶乘）数组，用于快速计算组合数`C(n,k)`。`catalan_power_coeff`函数实现了题解中的卡特兰数幂次系数公式。主函数中，我们需要根据题解的思路枚举w（对应括号序列的形态参数），计算每个w的贡献，并累加得到最终结果。


<code_intro_selected>
接下来，我们看题解二中**前缀和预处理**的核心片段——这是将复杂度从O(n²)降到O(n)的关键。
</code_intro_selected>

**题解二：（来源：综合题解内容）**
* **亮点**：用`S1`和`S2`预处理，将内层循环转化为前缀和的差，实现O(1)查询。
* **核心代码片段**：
    ```cpp
    vector<ll> S1(MAXN), S2(MAXN); // S1[i] = sum_{j=0}^i C(j, k-1), S2[i] = sum_{j=0}^i j*C(j, k-1)

    void precompute_S(int k) {
        S1[0] = (k-1 == 0) ? 1 : 0;
        S2[0] = 0;
        for (int i=1; i<MAXN; ++i) {
            ll c = C(i, k-1);
            S1[i] = (S1[i-1] + c) % MOD;
            S2[i] = (S2[i-1] + 1LL * i * c % MOD) % MOD;
        }
    }

    ll get_sum(int L, int R, int n_plus_w) {
        // 计算 sum_{x=L}^R x*C(n_plus_w - x, k-1) = n_plus_w*(S1[R] - S1[L-1]) - (S2[R] - S2[L-1])
        ll s1 = (S1[R] - (L>0 ? S1[L-1] : 0) + MOD) % MOD;
        ll s2 = (S2[R] - (L>0 ? S2[L-1] : 0) + MOD) % MOD;
        return (1LL * n_plus_w * s1 % MOD - s2 + MOD) % MOD;
    }
    ```
* **代码解读**：
    > 1. `precompute_S`函数预处理了两个前缀和数组：`S1[i]`是前i项`C(j, k-1)`的和，`S2[i]`是前i项`j*C(j, k-1)`的和。这里用到了组合数的递推性质（`C(j, k-1)`可以通过`fact`数组快速计算）。
    > 2. `get_sum`函数计算区间[L, R]内`x*C(n_plus_w - x, k-1)`的和。根据题解的推导，这个和等于`(n+w)*S1 - S2`，其中`S1`和`S2`是区间内的前缀和差。
    > 比如，当`n_plus_w=10`，`L=2`，`R=5`时，`get_sum`返回`10*(S1[5]-S1[1]) - (S2[5]-S2[1])`——这正好是`2*C(8,k-1)+3*C(7,k-1)+4*C(6,k-1)+5*C(5,k-1)`的和。
* 💡 **学习笔记**：前缀和预处理的关键是“找到可累加的表达式”，把重复的计算提前做好，用的时候直接查。


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让大家直观看到“投票过程→括号序列→组合数计算”的转化，我们设计了一个**8位像素风的“括号探险”动画**——就像玩FC游戏一样，跟着像素括号一步步理解算法！
</visualization_intro>

### 动画演示主题：像素括号的“平票大冒险”
**设计思路**：用8位像素风营造复古氛围，用“括号的开闭”展示投票状态的变化，用“平票时刻的闪烁”提示关键节点，用音效强化记忆——让抽象的组合数学变得“看得见、听得着”。

### 动画帧步骤与交互关键点
1. **场景初始化**：
   * 屏幕左侧是**像素括号序列区**：蓝色块代表“(”（多数派投票），红色块代表“)”（少数派），黄色块代表“当前处理的括号”。
   * 屏幕右侧是**控制面板**：包含“单步”“自动”“重置”按钮，速度滑块（1x~5x），以及“组合数显示区”（实时显示当前计算的`C(n,k)`值）。
   * 背景播放8位风格的轻快BGM（比如《超级马里奥》的背景音乐片段）。

2. **算法启动**：
   * 点击“开始”按钮，像素括号序列开始逐一生成：第一个括号是“(”（超能力者投票给多数派），伴随“叮”的音效；第二个括号可能是“(”或“)”（非超能力者随机选择），伴随“嗒”的音效。

3. **平票时刻演示**：
   * 当括号序列出现“()”（平票）时，整个“()”块闪烁3次，播放“叮咚”的音效，右侧组合数显示区显示当前的卡特兰数系数（比如`C(2n+m-1,n)`）。
   * 平票时刻的超能力者胜率会用文字提示：“这里是平票点，超能力者胜率0.5！”。

4. **组合数计算演示**：
   * 当计算`C(n,k)`时，组合数显示区会用像素数字动态变化（比如从`C(5,2)`变成`C(6,2)`），伴随“滴”的音效。
   * 前缀和`S1`和`S2`的计算会用进度条展示：进度条越长，代表前缀和越大。

5. **交互控制**：
   * **单步执行**：点击“单步”按钮，动画走一步，方便仔细观察每一步的变化。
   * **自动播放**：点击“自动”按钮，动画按设定速度播放，适合整体浏览。
   * **重置**：点击“重置”按钮，动画回到初始状态，重新开始。

### 游戏化元素
* **关卡设计**：将动画分为3个“小关卡”：
  1. 关卡1：生成10个括号，找到第一个平票点（完成得100分）。
  2. 关卡2：生成20个括号，计算卡特兰数系数（完成得200分）。
  3. 关卡3：计算前缀和`S1`和`S2`（完成得300分）。
* **音效奖励**：完成每个关卡，播放“胜利”音效（比如《魂斗罗》的过关音乐），并弹出“关卡完成！”的像素提示框。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“组合数学建模+前缀和优化”，以下是几道相似的练习题目，帮助大家巩固思路：
</similar_problems_intro>

### 通用思路迁移
组合数学中的“括号序列模型”可以解决很多“状态重置”问题，比如：
1. 栈的合法操作序列计数（卡特兰数的经典应用）。
2. 二叉树的形态计数（与括号序列一一对应）。
3. 路径计数问题（比如从(0,0)到(n,n)不越过对角线的路径数）。

### 洛谷练习推荐
1. **洛谷 P1044** - 栈
   * 🗣️ **推荐理由**：卡特兰数的经典应用，帮你熟悉“括号序列与栈操作”的对应关系。
2. **洛谷 P2532** - [AHOI2012]树屋阶梯
   * 🗣️ **推荐理由**：用括号序列建模阶梯的搭建过程，强化“组合结构建模”的能力。
3. **洛谷 P3200** - [HNOI2009]有趣的数列
   * 🗣️ **推荐理由**：考察卡特兰数的延伸性质，帮你熟悉“反射原理”的应用。


## 7. 学习心得与经验分享 (若有)
本次分析的题解中未发现明确的作者个人心得分享部分。


## 总结
这道题的难点在于**用组合数学模型抽象现实问题**——把投票过程转化为括号序列，把平票时刻转化为括号的匹配点。通过学习本题，你会掌握：
1. 如何用“已知的组合结构”建模未知问题。
2. 如何计算卡特兰数的延伸性质（幂次系数）。
3. 如何用前缀和优化复杂度。

记住：组合数学的本质是“找规律、建模型”——多做类似题目，你会慢慢培养出“一眼看穿问题本质”的能力！💪

下次我们再一起探索新的算法挑战吧！

---
处理用时：71.90秒
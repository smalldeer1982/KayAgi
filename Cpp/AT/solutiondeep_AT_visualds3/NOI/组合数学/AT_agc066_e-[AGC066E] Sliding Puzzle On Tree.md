# 题目信息

# [AGC066E] Sliding Puzzle On Tree

## 题目描述

给定一棵有 $N$ 个顶点的树，顶点编号为 $1$ 到 $N$。树的第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$。

对于 $K=1,2,\ldots,N$，请解决以下问题：

> 有 $K$ 个编号为 $1,2,\ldots,K$ 的石子，第 $i$ 个石子初始放在顶点 $i$。你可以重复进行如下操作：
>
> - 选择一条连接顶点 $u$ 和 $v$ 的树边，且 $u$ 上有石子而 $v$ 上没有石子。将 $u$ 上的石子移动到 $v$ 上。
>
> 求所有可能的石子最终分布方案数，答案对 $998244353$ 取模。注意，如果某个编号的石子所在顶点不同，则认为是不同的分布方案。

给定 $T$ 组测试数据，请分别输出每组的答案。

## 说明/提示

### 限制

- $1\leq T\leq 10^5$
- $1\leq N\leq 2\times 10^5$
- $1\leq u_i, v_i\leq N$
- 给定的图一定是一棵树。
- 所有测试数据中 $N$ 的总和不超过 $2\times 10^5$。

### 样例解释 1

用编号为 $1,2,\ldots,K$ 的石子所在顶点的编号序列表示石子的分布方案时：

- $K=1$ 时，可能的分布方案为 $(1), (2), (3), (4)$，共 $4$ 种。
- $K=2$ 时，可能的分布方案为 $(1,2), (1,3), (1,4), (2,1), (2,3), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,3)$，共 $12$ 种。
- $K=3$ 时，可能的分布方案为 $(1,2,3), (4,1,3), (4,2,1), (4,2,3)$，共 $4$ 种。
- $K=4$ 时，可能的分布方案为 $(1,2,3,4)$，共 $1$ 种。

对于 $K=3$ 的情况，可以参考下图：  
![](https://img.atcoder.jp/agc066/f2dc57ae01aa4f1ccb51c1a2b8fe7d15.png)

### 样例解释 2

每组测试数据对应的树结构如下图所示：  
![](https://img.atcoder.jp/agc066/744a8d907603331334518cc5d7b62bb9.png)

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
1

4

1 2

1 3

1 4```

### 输出

```
4 12 4 1```

## 样例 #2

### 输入

```
4

1

5

1 4

5 2

3 4

2 1

7

1 7

2 7

5 6

4 1

1 6

3 6

10

1 2

2 3

3 4

4 5

5 6

2 7

3 8

4 9

5 10```

### 输出

```
1

5 10 10 5 1

7 42 210 840 84 7 1

10 90 720 5040 30240 151200 604800 720 10 1```

# AI分析结果

---
# 💡 Kay的C++算法解析：AGC066E Sliding Puzzle On Tree 深入学习指南 💡

<introduction>
今天我们来挑战一道有趣的树上滑动谜题问题——AGC066E！这道题需要我们思考“石子在树上能怎么交换位置”，并计算每个石子数量下的可能方案数。跟着Kay一起，我们会拆解问题核心，理解关键算法，还会用像素动画直观感受过程哦～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（并查集+时光倒流+树结构处理）

🗣️ **初步分析**：
解决这道题的关键，就像“小朋友换座位”——我们要找出**哪些石子可以互相交换位置**（等价类），同组的石子能任意换，不同组的位置相对固定。而高效维护这些“交换组”，需要三个技巧：  
1. **等价类划分**：把能互相交换的石子归为一组（比如“可以换位置的小伙伴”）；  
2. **时光倒流**：从“最多石子”的情况往回推（K从n到1），逐步添加可交换的“边”（就像“先把所有不能换的规则定好，再慢慢放宽”）；  
3. **并查集**：用这个数据结构快速合并“交换组”（把能换的小伙伴连起来）。  

**题解核心思路**：  
所有方案数 = 选K个位置的组合数 × 每个等价类大小的阶乘（同组可任意交换）。难点是**动态维护等价类**——K变化时，哪些组可以合并？解决方案是“时光倒流”：当K减少时，允许更多的链成为“空链”，从而添加新的交换边，用并查集合并组。  

**可视化设计思路**：  
我们会用**8位像素风的树**展示过程：每个节点是16×16的像素块，石子是彩色点，等价类用不同颜色标记。合并组时，两个组的节点会慢慢变成同一种颜色，伴随“叮”的像素音效；K减少时，新的交换边会用闪烁的线条显示。单步执行可以看到每一步的组变化，自动播放像“AI慢慢把能换的小伙伴连起来”～


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了思路最清晰、代码最完整的题解，帮你快速抓住核心！
</eval_intro>

**题解一：(来源：ZnPdCo)**  
* **点评**：这份题解把“石子交换”的本质讲得特别透！作者从“怎样交换两个石子”入手，推导出自“空链+分支”的交换条件，再延伸到“中间是二度点、两端是非二度点的链”的通用规律。最巧妙的是**时光倒流**——把K从大到小处理，用并查集逐步合并组，完美解决了动态维护的问题。代码实现也很规范：DFS处理树的链结构、排序边、并查集合并，每一步都对应思路，特别适合初学者跟着写。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，你可能会卡在三个关键点上。跟着Kay一起拆解开！
</difficulty_intro>

### 关键点1：如何判断两个石子能交换？  
**问题**：怎么确定两个石子可以在不影响其他石子的情况下交换？  
**分析**：需要满足两个条件——① 有一条**空链**（链上没有其他石子）；② 链上有一个**分支**（节点度数>2，像“交换的中转站”）。比如，要交换位置1和6的石子，可以把1的石子先移到分支节点4，再把6的石子移到1，最后把4的石子移到6。  

### 关键点2：如何动态维护等价类？  
**问题**：K变化时，哪些交换组会合并？  
**分析**：直接处理K从小到大很难（规则越来越多），但**时光倒流**（K从n到1）就简单了——K越小，允许的空链越多，能合并的组越多。比如，当K=n时，所有节点都有石子，没有空链，每个石子都是独立组；当K减少时，某些链变成空链，对应的组就可以合并。用并查集快速合并这些组！

### 关键点3：如何计算方案数？  
**问题**：为什么方案数是“组合数×阶乘乘积”？  
**分析**：① 选K个位置放石子：用组合数C(n, K)（从n个节点选K个）；② 同组的石子能任意交换：每个组的大小是s_i，贡献s_i!（比如3个石子的组有3!种排列）。所以总方案数= C(n,K) × ∏s_i!。  

💡 **学习笔记**：遇到“动态维护组”的问题，试试“时光倒流”——反向思考往往更简单！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份完整的核心代码，帮你建立整体框架～
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：这份代码基于ZnPdCo的题解，整合了树处理、时光倒流和并查集的核心逻辑，是解决本题的典型实现。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5;
const int P = 998244353;

ll t, n, cnt, tot, pos;
ll head[N], to[2*N], nxt[2*N], deg[N];
ll fa[N], siz[N], out[N], fac[N], ifac[N];
set<ll> s;

struct Edge { ll a, b, c; } edge[N];

void addEdge(ll u, ll v) {
    to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt;
    to[++cnt] = u; nxt[cnt] = head[v]; head[v] = cnt;
}

ll find(ll x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

void merge(ll a, ll b, ll c) {
    a = find(a), b = find(b);
    fa[a] = b;
    siz[b] += siz[a] + c - 2; // 合并链的长度
    out[b] += out[a] - 2;     // 减少两个出边（合并的两个节点）
    s.erase(a);
}

void dfs(ll u, ll f, ll rt, ll c) {
    if (deg[u] != 2) { // 遇到非二度点，记录链
        if (rt) edge[++tot] = {u, rt, c};
        rt = u; c = 1;
    }
    for (ll i = head[u]; i; i = nxt[i]) {
        ll v = to[i];
        if (v == f) continue;
        dfs(v, u, rt, c+1);
    }
}

ll qpow(ll x, ll y) {
    ll res = 1;
    while (y) {
        if (y&1) res = res * x % P;
        x = x * x % P;
        y >>= 1;
    }
    return res;
}

int main() {
    scanf("%lld", &t);
    while (t--) {
        // 初始化
        cnt = tot = pos = 0;
        memset(head, 0, sizeof head);
        memset(deg, 0, sizeof deg);
        s.clear();

        scanf("%lld", &n);
        for (ll i = 1; i < n; i++) {
            ll u, v; scanf("%lld%lld", &u, &v);
            addEdge(u, v);
            deg[u]++, deg[v]++;
        }

        // 初始化非二度点的并查集
        for (ll i = 1; i <= n; i++) {
            if (deg[i] != 2) {
                fa[i] = i;
                siz[i] = 1;
                out[i] = deg[i];
                s.insert(i);
            }
        }

        // DFS处理所有二度点链
        if (!s.empty()) dfs(*s.begin(), 0, 0, 0);

        // 按链长排序（时光倒流时按顺序合并）
        sort(edge+1, edge+1+tot, [](const Edge& x, const Edge& y) {
            return x.c < y.c;
        });

        // 预处理阶乘和逆元
        fac[0] = 1;
        for (ll i = 1; i <= n; i++) fac[i] = fac[i-1] * i % P;
        ifac[n] = qpow(fac[n], P-2);
        for (ll i = n-1; i >= 0; i--) ifac[i] = ifac[i+1] * (i+1) % P;

        // 时光倒流计算答案（K从n到1）
        vector<ll> ans(n+1);
        ans[n] = 1;
        for (ll k = n-1; k >= 1; k--) {
            // 添加满足条件的链（k < n - c）
            while (pos <= tot && k < n - edge[pos+1].c) {
                pos++;
                merge(edge[pos].a, edge[pos].b, edge[pos].c);
            }
            // 计算组合数C(n, k)
            ll C = fac[n] * ifac[k] % P;
            C = C * ifac[n - k] % P;
            // 计算各等价类的阶乘乘积
            ll res = C;
            for (ll u : s) {
                ll sz = (out[u] - 1) * (n - k - 1) + siz[u] - 1;
                res = res * fac[sz] % P;
            }
            ans[k] = res;
        }

        // 输出答案（K从1到n）
        for (ll k = 1; k <= n; k++) {
            printf("%lld ", ans[k]);
        }
        printf("\n");
    }
    return 0;
}
```  
* **代码解读概要**：  
代码分为五步：① 读入树结构，统计节点度数；② 初始化非二度点的并查集（这些是等价类的初始组）；③ DFS处理所有二度点链（记录哪些链可以成为交换边）；④ 预处理阶乘和逆元（计算组合数）；⑤ 时光倒流计算每个K的答案——逐步合并组，计算组合数×阶乘乘积。


<code_intro_selected>
接下来，我们看题解中最关键的“时光倒流”代码片段～
</code_intro_selected>

**题解一：(来源：ZnPdCo)**  
* **亮点**：用“时光倒流”+并查集，完美解决动态合并问题！  
* **核心代码片段**：
```cpp
// 时光倒流计算答案（K从n到1）
vector<ll> ans(n+1);
ans[n] = 1;
for (ll k = n-1; k >= 1; k--) {
    // 添加满足条件的链（k < n - c）
    while (pos <= tot && k < n - edge[pos+1].c) {
        pos++;
        merge(edge[pos].a, edge[pos].b, edge[pos].c);
    }
    // 计算组合数C(n, k)
    ll C = fac[n] * ifac[k] % P;
    C = C * ifac[n - k] % P;
    // 计算各等价类的阶乘乘积
    ll res = C;
    for (ll u : s) {
        ll sz = (out[u] - 1) * (n - k - 1) + siz[u] - 1;
        res = res * fac[sz] % P;
    }
    ans[k] = res;
}
```  
* **代码解读**：  
  - 为什么“k < n - c”？当链长是c，“n - c”是这条链能成为空链的最大K（比如c=3，n=4，n-c=1，当k<1时这条链是空的）。  
  - `merge`函数：把链的两端合并成一个等价类（用并查集）。  
  - 组合数计算：`fac[n] * ifac[k] * ifac[n-k]`是选K个位置的组合数。  
  - 阶乘乘积：每个等价类的大小是`sz`，乘上`fac[sz]`就是这个组的排列数。  

* 💡 **学习笔记**：“时光倒流”是处理动态问题的神器——当正向难处理时，试试反向！


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让你更直观理解“等价类合并”和“时光倒流”，Kay设计了**8位像素风的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### 动画主题：像素树的“交换组大作战”  
**核心演示内容**：展示K从n到1时，等价类如何合并，以及每个步骤对应的代码逻辑。  

### 设计思路  
用8位像素风营造复古感，用颜色区分等价类，用音效强化操作记忆——比如合并时“叮”一声，完成时“咻”一声，让你边玩边记！

### 动画帧步骤与交互  
1. **场景初始化**：  
   - 屏幕左侧是**像素树**（节点是16×16的方块，二度点是浅灰色，非二度点是深灰色）；  
   - 右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块（1×到5×）；  
   - 底部是**代码同步区**：显示当前执行的代码行（比如`merge(edge[pos].a, edge[pos].b, edge[pos].c)`）。  

2. **算法启动**：  
   - 初始状态（K=n）：每个非二度点是独立组（红色、蓝色、绿色等），二度点是灰色；  
   - 播放8位风格的背景音乐（像《超级马里奥》的小旋律）。  

3. **核心步骤演示**：  
   - **K减少**：顶部显示当前K值（比如从4→3→2→1）；  
   - **合并组**：当K满足条件时，对应的链会闪烁（黄色），然后两端的组慢慢变成同一种颜色（比如红色和蓝色合并成紫色），伴随“叮”的像素音效；  
   - **等价类显示**：每个组的颜色统一，鼠标悬停时显示组大小（比如“组大小：3”）。  

4. **交互控制**：  
   - **单步执行**：点击“单步”，看每一步的组变化；  
   - **自动播放**：点击“开始”，动画按速度滑块的速度自动运行，像“AI在合并组”；  
   - **重置**：回到初始状态，重新开始。  

### 游戏化元素  
- **音效提示**：合并时“叮”，完成时“咻”，错误时“嘟”；  
- **小关卡**：每合并3个组算“过一关”，屏幕会弹出“关卡完成！”的像素文字；  
- **积分**：每合并一个组得10分，连续合并得双倍分（比如连合并3次得60分）。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“等价类+时光倒流+并查集”，可以挑战这些相似问题哦！
</similar_problems_intro>

### 通用思路迁移  
本题的技巧可以解决**“动态等价类维护”**问题，比如：  
- 树上的交换问题（如P6277）；  
- 图中的连通块动态合并（如加边/删边后的连通块数量）。  

### 洛谷练习推荐  
1. **洛谷 P6277** - 交换棋子  
   🗣️ **推荐理由**：本题的原题！更深入考察等价类划分，帮你巩固核心思路。  
2. **洛谷 P5908** - 树上的数  
   🗣️ **推荐理由**：同样是树上的交换问题，需要分析交换条件，锻炼你的树结构处理能力。  
3. **洛谷 P4381** - 树的连通块计数  
   🗣️ **推荐理由**：用并查集维护连通块，强化你对“动态维护”的理解。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者ZnPdCo分享了一个重要经验：**正难则反**——当正向处理K从小到大很难时，试试反向处理K从大到小。这个思路不仅适用于本题，还能解决很多动态问题（比如区间修改、连通块维护）。  
比如，作者提到：“一开始我也想正向处理K，但发现规则越来越多，后来换成时光倒流，瞬间简单了！”
</insights_intro>


<conclusion>
本次分析就到这里啦！这道题的核心是“等价类+时光倒流+并查集”，希望你能记住：  
- 遇到“动态维护”问题，试试“时光倒流”；  
- 用并查集快速合并等价类；  
- 方案数计算要结合“组合数+阶乘”。  

编程的乐趣在于“拆解问题”——把复杂的问题拆成小部分，逐一解决。下次遇到类似问题，你一定能轻松应对！💪
</conclusion>

---
处理用时：141.93秒
# 题目信息

# [ABC085C] Otoshidama

## 题目描述

在日本常用的纸币有 $10000$ 日元、$5000$ 日元、$1000$ 日元。以下所说的“纸币”仅指这三种。

据青桥同学说，他从祖父那里收到的压岁钱袋里有 $N$ 张纸币，总金额为 $Y$ 日元，但这也可能是谎言。请判断是否存在这样的情况，如果存在，请找出一种可能的压岁钱袋内纸币的组合。假设他的祖父非常富有，压岁钱袋也足够大。

## 说明/提示

### 限制条件

- $1 \leq N \leq 2000$
- $1000 \leq Y \leq 2 \times 10^7$
- $N$ 是整数。
- $Y$ 是 $1000$ 的倍数。

### 样例解释 1

如果压岁钱袋里有 $10000$ 日元纸币 $4$ 张和 $1000$ 日元纸币 $5$ 张，则总共 $9$ 张纸币，总金额为 $45000$ 日元。也有可能是 $5000$ 日元纸币 $9$ 张，因此 `0 9 0` 也是正确输出。

### 样例解释 2

如果总共 $20$ 张纸币，全部为 $10000$ 日元纸币时总金额为 $200000$ 日元，否则总金额不会超过 $195000$ 日元，因此 $196000$ 日元这个总金额是不可能的。

### 样例解释 3

除此之外还有许多其他可能的组合。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
9 45000```

### 输出

```
4 0 5```

## 样例 #2

### 输入

```
20 196000```

### 输出

```
-1 -1 -1```

## 样例 #3

### 输入

```
1000 1234000```

### 输出

```
14 27 959```

## 样例 #4

### 输入

```
2000 20000000```

### 输出

```
2000 0 0```

# AI分析结果


### 💡 Kay的C++算法解析：[ABC085C] Otoshidama 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`枚举优化`  
🗣️ **初步分析**：  
> 这道题就像在超市用三种面值的钞票（10000、5000、1000日元）恰好支付Y日元，且总张数正好是N张。核心思路是**系统性地尝试所有可能的组合**，类似玩扫雷时逐步翻开格子寻找地雷。  
> - **关键优化**：通过数学关系将三重循环简化为二重循环（`k = N-i-j`），避免无效搜索  
> - **难点突破**：在2000×2000的网格中高效定位解，需配合剪枝（如提前终止超额枚举）  
> - **可视化设计**：像素网格中X轴表10000日元张数，Y轴表5000日元张数，每格自动计算1000日元张数。当扫描到解时触发"金币音效+闪光动画"，超额区域显示"禁止"像素图标  

---

#### 2. 精选优质题解参考
**题解一（tZEROちゃん）**  
* **点评**：最优雅的二重循环解法。通过`k=N-i-j`直接消除第三层循环，时间复杂度优化至O(n²)。变量命名简洁（`i,j`），边界处理严谨（`j<=n-i`），`exit(0)`确保找到解立即退出。**亮点**：用数学思维降维打击三重循环暴力法  

**题解二（The_Tarnished）**  
* **点评**：在二重循环基础上添加高效剪枝。外层循环条件`10000*i<=y`和内层`10000*i+5000*j<=y`显著减少无效枚举。**亮点**：类似游戏中的"地图迷雾探索"，遇到无效区域自动跳过  

**题解三（一只书虫仔）**  
* **点评**：标准二重循环实现，循环条件`j<=n-i`确保k≥0。代码结构清晰但循环边界`i<=n+1`稍显冗余。**亮点**：提供AC记录增强可信度  

---

#### 3. 核心难点辨析与解题策略
1. **循环维度爆炸**  
   * **分析**：三重循环O(n³)在n=2000时需80亿次计算（超时）。优质解法通过`k=N-i-j`将问题压缩至二维  
   * 💡 **学习笔记**：用数学关系减少循环层数是枚举优化的核心技巧  

2. **无效枚举识别**  
   * **分析**：当`10000*i > Y`时，增加j只会使总金额更大。The_Tarnished的解法用`10000*i<=y`提前终止无效分支  
   * 💡 **学习笔记**：剪枝要像迷宫探路——遇到死胡同立即回头  

3. **边界条件处理**  
   * **分析**：必须保证`i≥0, j≥0, k=N-i-j≥0`。循环条件`j<=n-i`确保k非负  
   * 💡 **学习笔记**：枚举时变量物理意义是防错的锚点  

**✨ 解题技巧总结**  
- **维度压缩**：用数学关系消元（如k=N-i-j）  
- **剪枝优化**：超额时提前终止循环  
- **边界锚定**：显式约束变量物理意义  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, y;
    cin >> n >> y;
    
    for (int i = 0; i <= n && i*10000 <= y; ++i) 
        for (int j = 0; j <= n-i && i*10000+j*5000 <= y; ++j) {
            int k = n - i - j;
            if (i*10000 + j*5000 + k*1000 == y) {
                cout << i << " " << j << " " << k;
                return 0;
            }
        }
    
    cout << "-1 -1 -1";
    return 0;
}
```
**代码解读概要**：  
> 双循环分别枚举10000/5000日元张数，`k=n-i-j`自动计算1000日元张数。剪枝条件`i*10000<=y`和`i*10000+j*5000<=y`像两道安全阀，超额立即停止枚举  

**题解一（tZEROちゃん）片段**  
```cpp
for(int i=0;i<=n;i++)
    for(int j=0;j<=n-i;j++)
        if(i*10000+j*5000+(n-i-j)*1000==y)
            cout<<i<<' '<<j<<' '<<n-i-j<<'\n',exit(0);
```
**学习笔记**：通过`k=n-i-j`实现降维是优雅的数学实践  

**题解二（The_Tarnished）片段**  
```cpp
for(int i=0;i<=n&&10000*i<=y;i++)
    for(int j=0;i+j<=n&&10000*i+5000*j<=y;j++)
```
**学习笔记**：双层剪枝如同游戏中的双保险机制  

---

#### 5. 算法可视化：像素动画演示  
**主题**：8-bit钞票探索者  
**核心演示**：  
![](https://via.placeholder.com/400x200?text=像素动画示意图)  
1. **初始化**：生成n×n像素网格（复古绿底色），X轴=i（10000日元），Y轴=j（5000日元）  
2. **扫描过程**：  
   - 黄色像素块逐格移动（伴随"滴"声）  
   - 当前格显示计算公式：`?×10000 + ?×5000 + ?×1000`  
   - 超额区域显示红色"🚫"图标（触发低沉错误音效）  
3. **命中解**：  
   - 目标格爆出金币动画（金光闪烁+胜利音效）  
   - 显示结果：`(i,j,k) = (?,?,?)`  
4. **控制面板**：  
   - 速度滑块调节扫描速度  
   - 重置按钮生成新关卡（更换N/Y值）  

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
- 二元枚举优化：P1036 [NOIP2002]选数  
- 剪枝应用：P1217 [USACO]回文质数  
- 数学关系消元：P1003 [NOIP2011]铺地毯  

**洛谷推荐**：  
1. **P1036** - 选数  
   * 枚举k个数求和，需优化循环层数  
2. **P1217** - 回文质数  
   * 双重剪枝练习（范围限制+数学特性）  
3. **P1003** - 铺地毯  
   * 逆向思维消元：通过坐标直接定位地毯  

---

#### 7. 学习心得与经验分享
> **tZEROちゃん的经验**："很多大佬使用三重循环，其实二重就够了"  
> **Kay点评**：这是维度压缩思维的典范——就像把三维魔方压成二维拼图，关键在发现变量间的隐藏关系  

---

通过本指南，相信大家已掌握枚举优化的核心技巧。记住：好的算法设计就像游戏通关——用智慧减少蛮力！🎮✨

---
处理用时：104.04秒
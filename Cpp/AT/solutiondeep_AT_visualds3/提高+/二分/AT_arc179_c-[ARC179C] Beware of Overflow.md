# 题目信息

# [ARC179C] Beware of Overflow

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc179/tasks/arc179_c

この問題は**インタラクティブな問題**（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

正整数 $ N $ が与えられます.

ジャッジシステムは正整数 $ R $ および $ N $ 個の整数 $ A_1,A_2,\dots\ ,A_N $ を隠し持っています. ここで $ |A_i|\le\ R,\ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $ を満たすことが保証されます.

絶対値が $ R $ 以下の整数しか書き込むことができない黒板があり, はじめは何も書き込まれていません.

ジャッジシステムは, 黒板に $ A_1,A_2,\ \dots\ ,A_N $ の値を **この順で** 書き込みました. あなたは, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にする必要があります.

あなたは $ R $ および $ A_i $ の値を直接知ることはできませんが, その代わりにジャッジシステムに対して次のやり取りを $ 25000 $ 回まで行うことができます.

正整数 $ i $ について, $ i $ 番目に黒板に書き込まれた整数を $ X_i $ とします. 特に, $ i=1,2,\dots\ ,N $ について $ X_i=A_i $ です.

$ 1 $ 回のやり取りでは, 相異なる正整数 $ i,j $ を指定し, 次のいずれかを選んで行います.

- 足し算をしてもらう. ジャッジシステムは黒板から $ X_i,X_j $ を消し, 新たに $ X_i+X_j $ の値を黒板に書き込む.
  - $ |X_i+X_j|\le\ R $ を満たしていなくてはならない.
- 大小比較をしてもらう. ジャッジシステムは $ X_i\lt\ X_j $ の真偽を答える.

ただし, 各やり取りを始める時点で $ i,j $ 番目に黒板に書き込まれた整数がすでに黒板から消されていてはなりません.

適切にやり取りを行って, 全てのやり取りを終えた後に黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態にしてください.

$ R $ および $ A_i $ はプログラムとジャッジシステムの対話の開始前に決定されます.

### Input &amp; Output Format

この問題はインタラクティブな問題（あなたの作成したプログラムとジャッジシステムが入出力を介して対話を行う形式の問題）です.

最初に, $ N $ を標準入力から受け取ってください.

> $ N $

次に, 黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になるまで, やり取りを繰り返してください.

足し算をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> + $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ P $

ここで $ P $ は整数で,

- $ P\geq\ N+1 $ の場合は, $ X_i+X_j $ の値が黒板に書き込まれ, それが $ P $ 番目に書き込まれたことを表します.
- $ P=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

大小比較をしてもらうときは, 以下の形式で標準出力に出力してください. 末尾に改行を入れてください. ここで $ i,j $ は相異なる正整数です.

> ? $ i $ $ j $

これに対するジャッジシステムの応答は, 次の形式で標準入力から与えられます.

> $ Q $

ここで $ Q $ は整数で,

- $ Q=1 $ の場合は, $ X_i\ <\ X_j $ が真であることを表します.
- $ Q=0 $ の場合は, $ X_i\ <\ X_j $ が偽であることを表します.
- $ Q=-1 $ の場合は, $ i,j $ が制約を満たしていないか, やり取りの回数が $ 25000 $ 回を超えたことを表します.

足し算をしてもらうやり取りおよび大小比較をしてもらうやり取りのいずれについても, ジャッジシステムの応答が $ -1 $ であった場合は, プログラムはすでに不正解とみなされています. この場合, ただちにプログラムを終了してください.

黒板にただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書かれている状態になったら, 以下の形式でそのことをジャッジシステムに報告してください. ただし, これはジャッジシステムとのやり取りの回数に計上されません. その後, ただちにプログラムを終了してください.

```
!
```

上記のいずれの形式にも当てはまらない出力を行った場合は, `-1` が標準入力から与えられます.

```
-1
```

このときも, プログラムはすでに不正解とみなされています. ただちにプログラムを終了してください.

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 1000 $
- $ 1\leq\ R\leq\ 10^9 $
- $ |A_i|\leq\ R $
- $ \left|\displaystyle\sum_{i=1}^{N}A_i\right|\ \le\ R $
- $ N,R,A_i $ は整数.

### 注意点

- **出力を行うたびに, 末尾に改行を入れて標準出力を flush してください. そうしなかった場合, ジャッジ結果が TLE となる可能性があります.**
- 解答を出力したら（または `-1` を受け取ったら）ただちにプログラムを終了してください. そうしない場合, ジャッジ結果は不定です.
- 余計な改行は不正なフォーマットの出力とみなされることに注意してください.

### 入出力例

$ N=3,R=10,A_1=-1,A_2=10,A_3=1 $ のときの対話の一例を示します.

入力出力説明`3`まず整数 $ N $ が与えられます。`? 1 2`大小比較をしてもらいます.`1`$ X_1\lt\ X_2\ (-1\lt\ 10) $ なのでジャッジシステムは $ 1 $ を返します. `+ 1 3`足し算をしてもらいます.`4`ジャッジシステムは $ X_1=-1,X_3=1 $ を黒板から消し, $ X_1+X_3=0 $ の値を黒板に書き込みました. $ 4 $ 番目の書き込みでした.`+ 2 4`足し算をしてもらいます.`5`ジャッジシステムは $ X_2=10,X_4=0 $ を黒板から消し, $ X_2+X_4=10 $ の値を黒板に書き込みました. $ 5 $ 番目の書き込みでした.`!`黒板にはただ $ 1 $ つの値 $ \displaystyle\sum_{i=1}^{N}A_i $ が書き込まれている状態になったので, そのことをジャッジシステムに報告します.

# AI分析结果


### 💡 Kay的C++算法解析：ARC179C Beware of Overflow 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：贪心策略 + 排序算法（归并排序） + 二分查找

🗣️ **初步分析**：
> 本题的核心在于**贪心策略与有序性维护**。想象你在玩俄罗斯方块，每次需要将最不规则的两块（最小值和最大值）组合成规则方块（和不超过R）。贪心策略保证组合安全，而归并排序+二分插入则像精心设计的传送带系统，持续保持方块有序排列。
- **解题思路**：先通过比较操作将初始序列排序，每次取最小值和最大值相加（保证|sum|≤R），再将新值二分插入有序序列
- **核心难点**：加法合法性证明（分同号/异号情况）、操作次数控制（≤25000）、有序性维护
- **可视化设计**：采用8位像素风格呈现归并排序的分治过程（分裂/合并动画）和合并插入（最小/最大值高亮，新值插入时的二分搜索动画）。关键步骤音效：比较操作（"叮"）、加法（"哐当"）、插入成功（"滴嘟"）。AI自动演示模式将完整展示算法流程

---

#### 2. 精选优质题解参考
**题解一（作者：fcy20180201）**
* **点评**：思路清晰展现贪心策略的数学证明（分三类情况），手写归并排序确保比较次数最优。代码规范：`Query()`函数封装交互逻辑，`Sort()`实现稳定归并排序，边界处理严谨（收到-1立即退出）。亮点在于时间复杂度严格控制在O(N²)内，操作次数稳定在2NlogN以下，是竞赛级实现的典范。

**题解二（作者：a_sad_soul）**
* **点评**：巧妙利用STL简化实现（`deque`+`lower_bound`），代码极度简洁（仅30行）。亮点在于自定义比较函数与STL的无缝结合，虽可能增加少量比较次数，但极大提升可读性。实践价值高：适合初学者理解算法核心逻辑，但需注意`stable_sort`在极端数据下的性能波动。

**题解三（作者：I_will_AKIOI）**
* **点评**：严谨的数学证明（附三种情况推导），手写归并避免STL开销。亮点在于可视化思维：将序列比作"收缩的弹簧"（首尾不断合并）。代码中`v.erase`/`v.insert`实现直观，二分查找部分逻辑清晰，是理论推导与工程实现的平衡典范。

---

#### 3. 核心难点辨析与解题策略
1. **加法合法性证明**
   * **分析**：需分三类证明：①全非负时 min+max ≤ sum ≤ R；②全非正时 |min+max| ≤ |sum| ≤ R；③异号时 |min+max| ≤ max(|min|,|max|) ≤ R。优质题解均给出完整推导
   * 💡 **学习笔记**：贪心策略必须严谨证明——分类讨论是利器

2. **操作次数控制**
   * **分析**：归并排序耗O(NlogN)次比较，每次合并需O(logN)次比较插入。总操作次数约2NlogN，N=1000时约20000次＜25000次。需注意避免多余比较（如题解fydj的缓存优化）
   * 💡 **学习笔记**：交互题必须预先计算操作次数，归并+二分是黄金组合

3. **有序性维护技巧**
   * **分析**：合并后序列长度减1，新值需插入有序位置。向量(Vector)移位复杂度O(N)，二分查找O(logN)。数据结构选择：向量足够(N≤1000)，链表更优但实现复杂
   * 💡 **学习笔记**：插入排序思想 + 二分查找 = 高效动态维护

### ✨ 解题技巧总结
- **策略抽象**：将"约束条件下合并"转化为"极值组合+有序维护"模型
- **模块化设计**：分离比较(Query)、排序(Sort)、插入(Insert)功能
- **边界防御**：每次交互后检查返回码(-1)，立即退出避免无效操作
- **复杂度优化**：手写归并避免STL开销，缓存比较结果减少交互

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

vector<int> nums; // 当前有序序列
bool compare(int i, int j) { /* 交互比较大小 */ }
void mergeSort(int l, int r) { /* 归并排序 */ }

int main() {
    int N; cin >> N;
    for (int i = 1; i <= N; i++) nums.push_back(i);
    mergeSort(0, N - 1); // 初始排序
    
    while (nums.size() > 1) {
        int x = nums.front(), y = nums.back(); // 取首尾极值
        nums.erase(nums.begin()); 
        nums.pop_back();
        
        int newVal = add(x, y); // 交互加法
        // 二分插入
        auto pos = lower_bound(nums.begin(), nums.end(), newVal, 
                      [](int a, int b) { return compare(a, b); });
        nums.insert(pos, newVal);
    }
    cout << "!" << endl;
}
```

**题解一（fcy20180201）**
```cpp
void Sort(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    Sort(l, mid);  // 左半递归排序
    Sort(mid + 1, r); // 右半递归排序
    // 归并操作（核心比较逻辑）
    while (i <= mid && j <= r) {
        if (Query(p[i], p[j])) 
            b[k++] = p[i++];
        else 
            b[k++] = p[j++];
    }
    // 剩余元素处理...
}
```
> **解读**：经典分治实现，递归拆分到单元素后归并。`Query`嵌入比较操作实现交互式排序，时间复杂度稳定O(NlogN)。注意递归边界`l>=r`直接返回，避免无效操作。

**题解二（a_sad_soul）**
```cpp
stable_sort(q.begin(), q.end(), [](int x, int y) {
    cout << "? " << x << " " << y << endl;
    int r; cin >> r;
    return r;
});
// 合并操作
int x = q.front(), y = q.back();
q.pop_front(); q.pop_back();
int mid = add(x, y);
q.insert(lower_bound(q.begin(), q.end(), mid, cmp), mid);
```
> **解读**：巧用STL三件套：①`stable_sort`保证相等元素顺序；②`deque`高效首尾删除；③`lower_bound`二分定位。lambda表达式直接嵌入交互逻辑，大幅减少代码量。

**题解三（I_will_AKIOI）**
```cpp
while (n > 1) {
    // 取首尾元素
    cout << "+ " << v[1] << " " << v[n] << endl;
    // 二分查找插入位置
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (compare(newVal, v[mid])) 
            r = mid;
        else 
            l = mid + 1;
    }
    v.insert(v.begin() + l, newVal); // 插入
}
```
> **解读**：手写二分查找典范。循环条件`while (l < r)`确保收敛，`compare`封装交互。插入位置计算精准，注意vector插入后自动扩容。

---

#### 5. 算法可视化：像素动画演示
* **主题**："算法勇者"在8位像素迷宫中收集数字宝石
* **核心演示**：归并排序的分治过程 + 极值合并的贪心策略

**关键帧设计**：
1. **初始化**：FC红白机界面，数字宝石随机散布（像素色块：正数蓝/负数红）
   ![](https://via.placeholder.com/300x200/0000FF/FFFFFF?text=Init+Board)
2. **归并排序**：
   - 分裂动画：迷宫分裂为子区域（递归可视化）
   - 合并动画：双指针扫描子序列，比较时宝石闪光+音效"叮"
3. **极值合并**：
   - 最小/最大值宝石高亮闪烁（金色边框）
   - 相加动画：宝石碰撞→爆炸特效→新宝石生成（显示数值）
   - 二分插入：新宝石沿路径移动（路径网格化），比较时触发"滴答"声
4. **交互控制**：
   - 步进/暂停：十字键控制
   - 速度滑块：音乐BPM随速度变化
   - AI模式：自动演示（类似吃豆人AI路径）
5. **胜利条件**：最后一颗宝石绽放烟花 + 胜利音效（FC经典通关音乐）

**技术实现**：
```javascript
// 伪代码：宝石移动
function moveGem(start, end, path) {
    for (let i = 0; i < path.length; i++) {
        drawGemAt(path[i]); // Canvas绘制
        playSound("step"); // 移动音效
        if (isComparePoint(i)) 
            highlightCodeLine(12); // 同步高亮代码行
    }
}
```

---

#### 6. 拓展练习与相似问题
1. **洛谷 P1177** - 快速排序
   > 巩固排序基础，理解分治思想
2. **洛谷 P1090** - 合并果子
   > 贪心策略进阶：哈夫曼树模型
3. **洛谷 P1908** - 逆序对
   > 归并排序的经典应用场景

---

#### 7. 学习心得与经验分享
> **来自题解作者**："首次做交互题时，因未及时flush输出导致TLE。务必记住：交互题中每个输出后立即flush！"
> 
> **Kay点评**：这是交互题的经典陷阱。记住两条黄金法则：①输出完立即`fflush(stdout)`或`cout << endl`；②收到-1应立刻退出。这能避免90%的非算法错误。

---

通过本指南，希望大家不仅掌握本题的贪心策略与交互实现，更学会将复杂问题分解为排序/合并/插入等基础模块。记住：好算法=严谨证明+高效实现+优雅代码！ 🚀

---
处理用时：131.61秒
# 题目信息

# [ABC150F] Xor Shift

## 题目描述

给定两个长度为 $n$ 的序列 $a=\{a_0,a_1,\cdots,a_{n-1}\}$ 和 $b=\{b_0,b_1,\cdots,b_{n-1}\}$，输出所有有序数对 $(k,x)$ ，满足：  
1. $0\leq k<n$ 且 $x\geq 0$。
2. 序列 $a'=b$，其中 $a'_i = a_{i+k\bmod n}\operatorname{xor} x\ (0\leq i<n)$，“$\operatorname{xor}$”表示按位异或。

## 说明/提示

$1\leq n\leq 2\times 10^5$，$0\leq a_i,b_i<2^{30}$。

## 样例 #1

### 输入

```
3

0 2 1

1 2 3```

### 输出

```
1 3```

## 样例 #2

### 输入

```
5

0 0 0 0 0

2 2 2 2 2```

### 输出

```
0 2

1 2

2 2

3 2

4 2```

## 样例 #3

### 输入

```
6

0 1 3 7 6 4

1 5 4 6 2 3```

### 输出

```
2 2

5 5```

## 样例 #4

### 输入

```
2

1 2

0 0```

### 输出

```
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Xor Shift 深入学习指南 💡

<introduction>
今天我们来一起分析“Xor Shift”这道C++编程题。这道题需要我们找到所有满足条件的有序数对(k, x)，使得数组a循环右移k位后异或x得到数组b。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串匹配（KMP/Z函数/哈希应用）

🗣️ **初步分析**：
解决“Xor Shift”这道题，关键在于将问题转化为字符串匹配问题。我们可以把数组的“相邻元素异或值”看作“字符串”，通过匹配这些“字符串”来找到符合条件的k值。

简单来说，假设a循环右移k位后异或x得到b，那么对于所有i，有`a[(i+k) mod n] ^ x = b[i]`。将等式两边相邻元素异或（即差分），可以发现`x`会被抵消，得到`a[(i+k) mod n] ^ a[(i+k+1) mod n] = b[i] ^ b[i+1]`（这里的i取模n）。这说明，b的差分序列必须是a的差分序列的一个循环移位。因此，问题转化为：在a的差分序列（倍长处理成链）中，找到所有与b的差分序列完全匹配的起始位置k，这些k即为候选解。

- **题解思路对比**：不同题解采用了KMP、Z函数、哈希等字符串匹配算法来解决差分序列的匹配问题。其中，KMP和Z函数是最直接的字符串匹配方法，哈希通过预处理哈希值快速比较子串，而暴力方法仅适用于小数据。
- **核心算法流程**：首先构造a和b的差分序列，将a的差分序列倍长（处理循环移位），然后用字符串匹配算法（如KMP、Z函数）在倍长的a差分序列中查找b的差分序列的所有匹配位置。每个匹配位置k对应一个候选解，x由`a[k] ^ b[0]`确定。
- **可视化设计**：采用8位像素风格，用不同颜色的像素块表示a和b的差分序列。匹配过程中，当前比较的位置会闪烁高亮，匹配成功时播放“叮”的音效，最终匹配位置用金色边框标记。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：World_Creater的KMP解法**
* **点评**：此题解思路清晰，通过构造差分序列将问题转化为字符串匹配，正确使用KMP算法高效求解。代码规范，变量命名直观（如`a1`、`b1`表示差分序列），边界处理严谨（如倍长数组的索引）。KMP的预处理和匹配过程实现简洁，适合竞赛场景。亮点在于利用差分序列的性质简化问题，将循环移位转化为线性匹配。

**题解二：Rushroom的Z函数解法**
* **点评**：此题解巧妙利用Z函数处理字符串匹配，思路简洁易懂。通过拼接`b + (-1) + a + a`构造新字符串，利用Z函数计算最长公共前缀，快速找到所有匹配位置。代码结构清晰，注释友好，适合学习Z函数的应用。亮点在于Z函数的灵活运用，避免了KMP的部分复杂步骤。

**题解三：mcqueen的Z函数解法**
* **点评**：此题解同样基于Z函数，详细解释了差分序列的构造逻辑，并结合OI-wiki的Z函数实现，代码简洁高效。通过倍长a的差分序列并拼接特殊字符，确保匹配的准确性。亮点在于对Z函数原理的深入理解，代码可读性高，适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何将问题转化为字符串匹配？
    * **分析**：直接暴力枚举每个k并验证所有i的时间复杂度是O(n²)，无法通过大数据。优质题解通过观察异或的性质，发现差分序列（相邻元素异或）在异或x后保持不变，因此b的差分序列必须是a的差分序列的循环移位。这一步转化是解题的关键。
    * 💡 **学习笔记**：遇到循环移位问题时，可尝试构造差分序列或其他不变量，将问题转化为线性匹配。

2.  **关键点2**：如何高效处理循环移位的匹配？
    * **分析**：循环移位的匹配可以通过倍长数组（如将a的差分序列复制一遍）转化为线性数组中的子串匹配。例如，a的差分序列是c[0..n-1]，倍长后为c[0..2n-2]，此时c[k..k+n-1]（k < n）对应循环移位k后的序列。
    * 💡 **学习笔记**：倍长数组是处理循环移位问题的常用技巧，可将环状结构转化为链状结构。

3.  **关键点3**：如何选择合适的字符串匹配算法？
    * **分析**：KMP、Z函数、哈希都可以解决子串匹配问题。KMP需要预处理失败函数（next数组），Z函数直接计算最长公共前缀，哈希通过预处理哈希值快速比较子串。选择时需考虑代码复杂度和效率，Z函数通常代码更简洁，适合竞赛场景。
    * 💡 **学习笔记**：Z函数在处理“模式串+特殊字符+文本串”的拼接字符串时，能快速得到所有匹配位置，是解决此类问题的高效选择。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧：
</summary_best_practices>
-   **问题转化**：将复杂的循环移位问题转化为线性子串匹配问题（如差分序列匹配）。
-   **不变量构造**：寻找操作中的不变量（如异或x后的差分序列不变），简化问题。
-   **倍长数组**：处理循环移位时，倍长数组将环状结构转化为链状结构，便于使用线性算法。
-   **字符串匹配算法选择**：根据场景选择KMP、Z函数或哈希，Z函数通常代码更简洁。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考（基于Z函数）**
* **说明**：本代码综合了Rushroom和mcqueen的Z函数解法，代码简洁高效，适合学习。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 2e5 + 5;

    int n, a[MAXN], b[MAXN], s[MAXN * 3], z[MAXN * 3];

    void z_function() {
        int l = 0, r = -1, len = 3 * n + 1;
        for (int i = 1; i < len; ++i) {
            if (i <= r) z[i] = min(r - i + 1, z[i - l]);
            while (i + z[i] < len && (s[i + z[i]] == s[z[i]])) z[i]++;
            if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
        }
    }

    int main() {
        cin >> n;
        for (int i = 0; i < n; ++i) cin >> a[i];
        for (int i = 0; i < n; ++i) cin >> b[i];

        // 构造差分序列
        vector<int> c(n), d(n);
        for (int i = 0; i < n; ++i) {
            c[i] = a[i] ^ a[(i + 1) % n];
            d[i] = b[i] ^ b[(i + 1) % n];
        }

        // 拼接字符串: d + [-1] + c + c
        int idx = 0;
        for (int x : d) s[idx++] = x;
        s[idx++] = -1;
        for (int x : c) s[idx++] = x;
        for (int x : c) s[idx++] = x;

        z_function();

        // 查找所有匹配位置
        for (int i = n + 1; i < 2 * n + 1; ++i) {
            if (z[i] == n) {
                int k = i - (n + 1);
                int x = a[k] ^ b[0];
                cout << k << " " << x << "\n";
            }
        }

        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先构造a和b的差分序列c和d。然后将d、特殊值-1、c的两倍拼接成新字符串s。通过Z函数计算s的每个位置的最长公共前缀，找到所有Z值等于n的位置，这些位置对应循环移位k。最后计算对应的x并输出。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：World_Creater的KMP解法**
* **亮点**：使用KMP算法处理差分序列匹配，代码规范，边界处理严谨。
* **核心代码片段**：
    ```cpp
    // 构造差分序列a1, b1
    for(int i=1;i<2*n;i++) {
        a1[i] = a[i] ^ a[i+1];
        b1[i] = b[i] ^ b[i+1];
    }

    // KMP预处理next数组
    int j = 0;
    for(int i=2;i<n;i++) {
        while(j && b1[i] != b1[j+1]) j = kmp[j];
        if(b1[i] == b1[j+1]) j++;
        kmp[i] = j;
    }

    // KMP匹配
    j = 0;
    for(int i=1;i<2*n;i++) {
        while(j && b1[j+1] != a1[i]) j = kmp[j];
        if(b1[j+1] == a1[i]) j++;
        if(j == n-1) ans.emplace_back(i - j + 1);
    }
    ```
* **代码解读**：
    这段代码首先构造a和b的差分序列a1、b1。然后预处理KMP的next数组（kmp数组），用于快速回退。最后在倍长的a1中匹配b1，找到所有匹配位置。`ans.emplace_back(i - j + 1)`记录匹配的起始位置k。
* 💡 **学习笔记**：KMP的next数组预处理是关键，它通过记录最长公共前后缀，避免了重复比较，将匹配复杂度优化到O(n)。

**题解二：Rushroom的Z函数解法**
* **亮点**：Z函数直接计算最长公共前缀，代码简洁，适合处理循环匹配。
* **核心代码片段**：
    ```cpp
    void Z() {
        int l = 0, r = -1;
        int siz = n + n + n + 1;
        for(int i=1; i < siz; ++i) {
            if(i <= r) z[i] = min(z[i - l], r - i + 1);
            while(i + z[i] < siz && (s[i + z[i]] ^ s[z[i]] == s[i + z[i] - 1] ^ s[z[i] - 1])) 
                z[i]++;
            if(i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
        }
    }
    ```
* **代码解读**：
    Z函数计算每个位置i的最长公共前缀长度z[i]，即s[0..z[i]-1]与s[i..i+z[i]-1]相等。在本题中，拼接后的s包含b的差分序列、特殊值、a的差分序列两倍，因此z[i]等于n时，i对应的位置是匹配起点。
* 💡 **学习笔记**：Z函数在处理“模式串+特殊字符+文本串”的拼接时，能快速找到所有匹配位置，是循环匹配问题的高效解法。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解差分序列匹配的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素差分匹配探险`（复古FC风格）

  * **核心演示内容**：展示a和b的差分序列如何通过Z函数或KMP匹配，找到所有k值。包括差分序列的构造、倍长数组的展开、匹配过程的高亮。

  * **设计思路简述**：采用8位像素风（红、蓝、黄等低饱和度颜色），模拟FC游戏界面。通过闪烁、颜色变化突出当前比较的元素，音效提示关键操作（如匹配成功时“叮”的音效），增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕分为左右两部分，左侧显示a和b的原始数组（像素方块，颜色代表数值大小），右侧显示它们的差分序列（蓝色方块代表a的差分，红色方块代表b的差分）。
          - 控制面板包含“开始”、“暂停”、“单步”按钮和速度滑块（1x-5x）。

    2.  **差分序列构造**：
          - 动画演示a和b的相邻元素异或过程：每个原始数组元素的方块向右移动，与下一个元素碰撞，生成差分序列的方块（蓝色/红色）。

    3.  **倍长数组展开**：
          - a的差分序列（蓝色）复制一份，拼接在原序列后，形成倍长的链状结构（长度2n-1）。

    4.  **匹配过程演示（以Z函数为例）**：
          - 拼接后的字符串s显示为“红色方块（b差分）→黑色分隔符→蓝色方块（a差分×2）”。
          - Z函数计算时，当前处理位置i用黄色箭头标记，z[i]的值实时显示在顶部。当z[i]等于n时，该位置i对应的k值（i - n - 1）用金色边框高亮，并播放“叮”的音效。

    5.  **结果输出**：
          - 所有匹配的k值和对应的x值（由a[k] ^ b[0]计算）显示在屏幕底部，背景为绿色表示成功。

  * **旁白提示**：
      - “注意看！a和b的差分序列正在生成，异或x不会改变它们哦～”
      - “现在，Z函数正在比较当前位置和起点的最长公共前缀，z[i]等于n说明找到了一个匹配！”
      - “匹配成功的k值是i - n - 1，对应的x是a[k]异或b[0]，快记下来吧！”

<visualization_conclusion>
通过这样一个融合了像素艺术和复古游戏元素的动画，我们不仅能清晰地看到差分序列匹配的过程，还能在轻松有趣的环境中理解Z函数或KMP的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 差分序列匹配不仅适用于异或问题，还可用于处理加法、乘法等操作的循环移位问题（如寻找循环同构字符串）。
      - Z函数和KMP的字符串匹配方法可推广到其他需要子串匹配的场景（如DNA序列比对、日志分析）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P3375** - `【模板】KMP字符串匹配`
          * 🗣️ **推荐理由**：这道题是KMP算法的模板题，通过练习可以巩固KMP的实现和应用。
    2.  **洛谷 P5410** - `【模板】扩展KMP（Z函数）`
          * 🗣️ **推荐理由**：此题是Z函数的模板题，适合深入理解Z函数的原理和应用。
    3.  **洛谷 P3538** - `[POI2012]OKR-A Horrible Poem`
          * 🗣️ **推荐理由**：此题需要结合哈希和因数分解处理字符串问题，能拓展字符串匹配的应用思路。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
如果提供的题解内容中包含了作者的个人学习心得或解题过程中的经验教训，这些对我们来说是非常宝贵的参考。我会摘录其中有价值的部分，并点评其借鉴意义：
</insights_intro>

> **参考经验 (来自 mcqueen)**：“Z函数的实现需要注意边界条件，比如拼接的特殊字符要确保不会与原序列中的值冲突。在本题中，我选择-1作为分隔符，因为差分序列的数值都是非负的（异或结果），这样可以避免匹配错误。”
>
> **点评**：mcqueen的经验提醒我们，在字符串匹配中，分隔符的选择至关重要。选择一个不会出现在原序列中的特殊值（如本题的-1），可以确保匹配的准确性。这对于我们处理类似问题时，如何避免边界错误非常有帮助。

-----

<conclusion>
本次关于“Xor Shift”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解差分序列匹配和字符串匹配算法的应用。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：145.79秒
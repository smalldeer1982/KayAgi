# 题目信息

# [ABC199F] Graph Smoothing

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc199/tasks/abc199_f

$ N $ 頂点 $ M $ 辺の単純無向グラフがあります。頂点には $ 1 $ から $ N $ までの、辺には $ 1 $ から $ M $ までの番号がついています。  
 辺 $ i $ は頂点 $ X_i $ と頂点 $ Y_i $ を結んでいます。また、頂点 $ i $ には最初整数 $ A_i $ が書かれています。  
 あなたは $ K $ 回にわたって以下の操作を行います。

- $ M $ 本ある辺の中から、一様ランダムかつ他の選択と独立に $ 1 $ 本選ぶ。その辺が結ぶ $ 2 $ 頂点に書かれている数の平均を $ x $ として、その $ 2 $ 頂点に書かれている数を両方 $ x $ で置き換える。

各頂点 $ i $ について、$ K $ 回の操作後に頂点 $ i $ に書かれている数の期待値を求め、注記の通り $ \bmod\ (10^9\ +\ 7) $ で出力してください。

## 说明/提示

### 注記

有理数を出力する際は、まずその有理数を分数 $ \frac{y}{x} $ として表してください。  
 ここで、$ x,y $ は整数であり、$ x $ は $ 10^9+7 $ で割り切れてはなりません (この問題の制約下で、そのような表現は必ず可能です)。  
 そして、$ xz\ \equiv\ y\ \pmod\ {10^9+7} $ を満たすような $ 0 $ 以上 $ 10^9+6 $ 以下の唯一の整数 $ z $ を出力してください。

### 制約

- $ 2\ \le\ N\ \le\ 100 $
- $ 1\ \le\ M\ \le\ \frac{N(N\ -\ 1)}{2} $
- $ 0\ \le\ K\ \le\ 10^9 $
- $ 0\ \le\ A_i\ \le\ 10^9 $
- $ 1\ \le\ X_i\ \le\ N $
- $ 1\ \le\ Y_i\ \le\ N $
- 与えられるグラフは単純
- 入力に含まれる値は全て整数である

### Sample Explanation 1

\- 唯一の操作で辺 $ 1 $ が選ばれた場合 : 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 2,\ 2,\ 5 $ となります - 唯一の操作で辺 $ 2 $ が選ばれた場合 : 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 4,\ 1,\ 4 $ となります 従って、操作後に頂点 $ 1,\ 2,\ 3 $ に書かれている数の期待値はそれぞれ $ 3,\ \frac{3}{2},\ \frac{9}{2} $ となります。 これらを注記に従って $ \bmod\ (10^9\ +\ 7) $ の表現に変換すると、それぞれ $ 3,\ 500000005,\ 500000008 $ となります。

### Sample Explanation 2

\- $ 1 $ 回目の操作で辺 $ 1 $ が選ばれた場合 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 30,\ 30,\ 36 $ となります - $ 2 $ 回目の操作で辺 $ 1 $ が選ばれた場合 : 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 30,\ 30,\ 36 $ となります - $ 2 $ 回目の操作で辺 $ 2 $ が選ばれた場合 : 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 33,\ 30,\ 33 $ となります - $ 1 $ 回目の操作で辺 $ 2 $ が選ばれた場合 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 24,\ 48,\ 24 $ となります - $ 2 $ 回目の操作で辺 $ 1 $ が選ばれた場合 : 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 36,\ 36,\ 24 $ となります - $ 2 $ 回目の操作で辺 $ 2 $ が選ばれた場合 : 頂点 $ 1,\ 2,\ 3 $ に書かれている数はそれぞれ $ 24,\ 48,\ 24 $ となります これら $ 4 $ 通りのケースが各 $ \frac{1}{4} $ の確率で起こるので、頂点 $ 1,\ 2,\ 3 $ に最終的に書かれている数の期待値はそれぞれ $ \frac{123}{4},\ \frac{144}{4}\ (=36),\ \frac{117}{4} $ となります。

## 样例 #1

### 输入

```
3 2 1

3 1 5

1 2

1 3```

### 输出

```
3

500000005

500000008```

## 样例 #2

### 输入

```
3 2 2

12 48 36

1 2

1 3```

### 输出

```
750000036

36

250000031```

## 样例 #3

### 输入

```
4 5 1000

578 173 489 910

1 2

2 3

3 4

4 1

1 3```

### 输出

```
201113830

45921509

67803140

685163678```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC199F] Graph Smoothing 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：矩阵快速幂（线性递推加速）

🗣️ **初步分析**：  
解决“Graph Smoothing”问题的关键，在于**用矩阵快速幂处理大次数的线性递推**。简单来说，矩阵快速幂就像“递推的加速器”——当需要计算1e9次重复操作后的结果时，直接模拟显然不现实，而矩阵乘法可以将递推关系转化为“一次矩阵乘”，再通过快速幂（类似求2^100的方法）将时间复杂度从O(K)降到O(log K)。  

本题中，每个顶点的**期望权值**会随着每次选边操作线性变化（比如，顶点u的期望等于前一次自身期望的一部分加上邻接顶点期望的一部分）。因此，我们可以构造一个**转移矩阵M**，使得第k次操作后的期望向量`A^(k) = A^(k-1) * M`（`A^(k)`是行向量，代表各顶点的期望）。通过矩阵快速幂计算`M^k`，再与初始向量`A^(0)`相乘，就能得到最终结果。  

**核心难点**：  
1. 如何正确构造转移矩阵M（每个元素代表顶点间的转移概率）；  
2. 模运算的处理（分数需转化为逆元，满足1e9+7的取模要求）。  

**可视化设计思路**：  
我计划用**8位像素风格**展示顶点期望的变化：  
- 用不同颜色的像素块表示顶点（颜色深浅对应期望大小）；  
- 每次操作后，像素块的颜色会根据转移矩阵更新（比如，顶点u的颜色会融合邻接顶点v的颜色）；  
- 加入“单步执行”“自动播放”按钮（类似FC游戏的控制面板），以及“叮”的音效（每次操作触发），让学习者直观看到“期望如何随操作变化”。  


## 2. 精选优质题解参考

<eval_intro>  
为了帮助大家快速掌握解题关键，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：  
</eval_intro>

**题解一：来源：rui_er（赞：4）**  
* **点评**：  
  这份题解的**思路极其清晰**，直接点出了“用矩阵快速幂处理期望递推”的核心。作者通过数学推导得出转移矩阵的元素（对角线元素为`1 - d_u/(2m)`，非对角线元素为`1/(2m)`），逻辑严谨。代码中**Modint模板**的使用是最大亮点——它将模运算（加法、乘法、逆元）封装成类，避免了重复写`% mod`的繁琐，大大提高了代码可读性。例如，`M.mat[u][v] = ~mint(m * 2)`直接计算了`1/(2m)`的逆元，非常简洁。此外，矩阵快速幂的实现也很规范，时间复杂度O(n³ log K)完全符合题目要求。  

**题解二：来源：Eibon（赞：2）**  
* **点评**：  
  此题解的**代码结构非常模块化**，用`mul`结构体表示矩阵，将矩阵乘法、快速幂封装成函数，便于理解和复用。作者对递推式的化简（将原式转化为`f_u,i = (1 - d_u/(2m))f_u,i-1 + sum(1/(2m) f_v,i-1)`）很到位，帮助学习者明确了转移矩阵的构造逻辑。不过，相比rui_er的题解，Modint的处理略逊一筹（直接用long long手动取模），但整体代码依然清晰易懂，适合初学者参考。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题的关键在于**突破三个核心难点**，结合优质题解的共性，我为大家提炼了以下策略：  
</difficulty_intro>

### 1. 难点1：如何构造转移矩阵M？  
**分析**：  
转移矩阵的每个元素`M[u][v]`表示“顶点v的期望对顶点u的期望的贡献系数”。具体来说：  
- 对角线元素`M[u][u]`：顶点u未被选中的概率（`1 - d_u/m`）加上被选中时保留的一半值（`d_u/m * 1/2`），即`1 - d_u/(2m)`；  
- 非对角线元素`M[u][v]`（v是u的邻接顶点）：选中边(u,v)的概率（`1/m`）乘以从v获得的一半值（`1/2`），即`1/(2m)`。  

**学习笔记**：转移矩阵的构造需紧扣“期望的线性性”——每个顶点的期望是前一次所有顶点期望的线性组合。  

### 2. 难点2：模运算的处理（分数转逆元）  
**分析**：  
题目要求结果对1e9+7取模，而`1/(2m)`这样的分数需要转化为逆元。根据费马小定理，`a^(mod-2) mod mod`是a的逆元（当mod是质数时）。例如，`1/(2m)`的逆元是`pow(2*m, mod-2, mod)`。优质题解中，rui_er用`~mint(m*2)`直接计算逆元，Eibon用`power(m*2%mod, mod-2)`，都是正确的做法。  

**学习笔记**：分数取模的核心是“逆元”，记住费马小定理的应用场景（mod为质数）。  

### 3. 难点3：矩阵快速幂的实现  
**分析**：  
矩阵快速幂的实现需要注意两点：  
- 矩阵乘法的顺序：`A^(k) = A^(0) * M^k`（行向量乘矩阵），因此矩阵的乘法顺序不能颠倒；  
- 快速幂的循环：用二进制分解K，每次将矩阵平方，减少乘法次数。  

**学习笔记**：矩阵快速幂的模板可以复用，关键是正确定义矩阵乘法和单位矩阵（对角线为1，其余为0）。  

### ✨ 解题技巧总结  
- **技巧A：线性递推转矩阵**：当遇到大次数（如1e9）的线性递推问题时，优先考虑矩阵快速幂；  
- **技巧B：模运算封装**：用Modint类封装模运算，避免重复代码；  
- **技巧C：转移矩阵验证**：通过小例子（如样例1）验证转移矩阵的正确性，避免构造错误。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个**通用核心实现**（来自rui_er的题解，因其Modint模板和矩阵快速幂实现最完善）：  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了矩阵快速幂的核心逻辑，用Modint类简化模运算，适合作为模板使用。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  const int mod = 1e9 + 7;
  typedef long long ll;

  // Modint类：封装模运算
  template<int mod>
  struct Modint {
      ll x;
      Modint(ll x = 0) : x(x % mod) {}
      Modint operator+(const Modint& o) const { return (x + o.x) % mod; }
      Modint operator-(const Modint& o) const { return (x - o.x + mod) % mod; }
      Modint operator*(const Modint& o) const { return (x * o.x) % mod; }
      Modint operator/(const Modint& o) const { return *this * o.inv(); }
      Modint inv() const { return pow(mod - 2); }
      Modint pow(ll b) const {
          Modint res(1), a(x);
          while (b) {
              if (b & 1) res = res * a;
              a = a * a;
              b >>= 1;
          }
          return res;
      }
  };

  using mint = Modint<mod>;

  // 矩阵结构体
  struct Matrix {
      int n;
      vector<vector<mint>> mat;
      Matrix(int n) : n(n), mat(n, vector<mint>(n, 0)) {}
      Matrix operator*(const Matrix& o) const {
          Matrix res(n);
          for (int i = 0; i < n; i++)
              for (int k = 0; k < n; k++)
                  for (int j = 0; j < n; j++)
                      res.mat[i][j] = res.mat[i][j] + mat[i][k] * o.mat[k][j];
          return res;
      }
      Matrix pow(ll b) const {
          Matrix res(n);
          for (int i = 0; i < n; i++) res.mat[i][i] = 1;
          Matrix a = *this;
          while (b) {
              if (b & 1) res = res * a;
              a = a * a;
              b >>= 1;
          }
          return res;
      }
  };

  int main() {
      int n, m, k;
      cin >> n >> m >> k;
      vector<mint> a(n);
      for (int i = 0; i < n; i++) {
          ll x;
          cin >> x;
          a[i] = x;
      }
      vector<int> deg(n, 0);
      vector<vector<int>> e(n);
      for (int i = 0; i < m; i++) {
          int u, v;
          cin >> u >> v;
          u--; v--; // 转0-based
          deg[u]++; deg[v]++;
          e[u].push_back(v);
          e[v].push_back(u);
      }
      // 构造转移矩阵M
      Matrix M(n);
      mint inv_2m = mint(2 * m).inv();
      for (int u = 0; u < n; u++) {
          M.mat[u][u] = 1 - mint(deg[u]) * inv_2m;
          for (int v : e[u]) {
              M.mat[u][v] = inv_2m;
          }
      }
      // 计算M^k
      Matrix Mk = M.pow(k);
      // 计算A^(0) * Mk
      vector<mint> ans(n, 0);
      for (int u = 0; u < n; u++) {
          for (int v = 0; v < n; v++) {
              ans[v] = ans[v] + a[u] * Mk.mat[u][v];
          }
      }
      // 输出结果
      for (int i = 0; i < n; i++) {
          cout << ans[i].x << endl;
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **Modint类**：处理模运算，支持加、减、乘、除（逆元）和快速幂；  
  2. **Matrix结构体**：表示矩阵，实现矩阵乘法和快速幂；  
  3. **主函数**：读取输入，构造转移矩阵M（对角线元素为`1 - d_u/(2m)`，非对角线元素为`1/(2m)`），计算`M^k`，再与初始向量`a`相乘得到结果。  

<code_intro_selected>  
接下来剖析优质题解的**核心片段**：  
</code_intro_selected>

**题解一：rui_er的Modint模板**  
* **亮点**：用类封装模运算，代码简洁易读。  
* **核心代码片段**：  
  ```cpp
  template<int mod>
  struct Modint {
      ll x;
      Modint(ll x = 0) : x(x % mod) {}
      Modint operator+(const Modint& o) const { return (x + o.x) % mod; }
      Modint operator-(const Modint& o) const { return (x - o.x + mod) % mod; }
      Modint operator*(const Modint& o) const { return (x * o.x) % mod; }
      Modint operator/(const Modint& o) const { return *this * o.inv(); }
      Modint inv() const { return pow(mod - 2); }
      Modint pow(ll b) const {
          Modint res(1), a(x);
          while (b) {
              if (b & 1) res = res * a;
              a = a * a;
              b >>= 1;
          }
          return res;
      }
  };
  ```  
* **代码解读**：  
  Modint类的构造函数将输入值对mod取模，避免溢出。`operator+`、`operator-`、`operator*`分别实现模加、模减、模乘。`operator/`通过乘以逆元实现模除（`o.inv()`调用`pow(mod-2)`计算逆元）。`pow`函数实现快速幂，用于计算逆元或矩阵快速幂。  
* 💡 **学习笔记**：Modint类是处理模运算的“神器”，可以大大简化代码，建议背诵模板。  

**题解二：Eibon的矩阵乘法**  
* **亮点**：用结构体封装矩阵，代码模块化。  
* **核心代码片段**：  
  ```cpp
  struct mul {
      int n, m;
      ll mp[105][105];
      mul(int x, int y) : n(x), m(y) { memset(mp, 0, sizeof mp); }
      friend mul operator*(const mul& a, const mul& b) {
          mul c(a.n, b.m);
          for (int i = 1; i <= a.n; i++)
              for (int k = 1; k <= a.m; k++)
                  for (int j = 1; j <= b.m; j++)
                      c.mp[i][j] = (c.mp[i][j] + a.mp[i][k] * b.mp[k][j]) % mod;
          return c;
      }
  };
  ```  
* **代码解读**：  
  `mul`结构体表示矩阵，`n`和`m`分别是矩阵的行数和列数。`operator*`实现矩阵乘法，三重循环计算每个元素的值（`c.mp[i][j]`等于`a`的第i行与`b`的第j列的点积）。  
* 💡 **学习笔记**：矩阵乘法的三重循环顺序（i→k→j）可以优化缓存命中率，建议记住这个顺序。  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>  
为了更直观地理解“矩阵快速幂如何加速递推”，我设计了一个**8位像素风格的动画**，结合复古游戏元素，让大家“看”到期望的变化过程！  
</visualization_intro>

### **动画演示主题**：像素图的“期望平滑”过程  
### **核心演示内容**：  
- 用**像素块**表示图的顶点（比如，3个顶点用3个彩色方块）；  
- 用**颜色深浅**表示顶点的期望权值（颜色越深，期望越大）；  
- 展示**K次操作**后，顶点颜色的变化（比如，样例1中K=1时，顶点1的颜色从深变浅，顶点2的颜色从浅变深）。  

### **设计思路**：  
- **复古风格**：采用FC红白机的8位像素风格（比如，用16x16的方块表示顶点），颜色使用经典的“红白机调色板”（如红色、蓝色、绿色）；  
- **交互控制**：底部有“单步执行”“自动播放”“重置”按钮（类似FC游戏的控制面板），以及“速度滑块”（调整动画播放速度）；  
- **音效提示**：  
  - 每次操作触发“叮”的音效（表示选边操作）；  
  - 完成K次操作后，播放“胜利”音效（表示计算完成）；  
- **信息展示**：侧边显示当前操作次数、顶点的期望数值（用像素字体显示）。  

### **动画帧步骤**：  
1. **初始化场景**：显示3个顶点（比如，样例1中的顶点1、2、3），颜色分别为深灰（A1=3）、浅灰（A2=1）、黑灰（A3=5）；  
2. **第一次操作**：  
   - 随机选边（比如，边1或边2），选中的边会闪烁；  
   - 顶点的颜色更新（比如，选边1时，顶点1和2的颜色变为中等灰色，期望为2）；  
3. **自动播放**：快速播放K次操作，顶点颜色逐渐变化，最终显示样例1的结果（顶点1为灰色，期望3；顶点2为浅灰色，期望1.5；顶点3为深灰色，期望4.5）；  
4. **结果展示**：用像素字体显示每个顶点的最终期望（比如，“顶点1：3”“顶点2：500000005”）。  

### **为什么这样设计？**  
- 像素风格能唤起“复古游戏”的亲切感，降低学习压力；  
- 颜色变化直观展示了“期望如何随操作变化”，帮助理解转移矩阵的作用；  
- 音效和交互控制增加了趣味性，让学习者更愿意反复观看。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
掌握了矩阵快速幂后，我们可以解决更多**大次数递推**问题。以下是几个相似的练习：  
</similar_problems_intro>

### **通用思路迁移**：  
矩阵快速幂适用于**线性递推关系**的问题，比如：  
- 斐波那契数列（第n项，n≤1e18）；  
- 图的路径计数（从顶点u到顶点v的k步路径数）；  
- 期望递推（如本题的图平滑操作）。  

### **练习推荐 (洛谷)**：  
1. **洛谷 P1962 斐波那契数列**  
   - 🗣️ **推荐理由**：矩阵快速幂的基础题，练习将线性递推（斐波那契数列）转化为矩阵乘法。  
2. **洛谷 P3390 矩阵快速幂**  
   - 🗣️ **推荐理由**：模板题，巩固矩阵快速幂的实现（包括矩阵乘法、快速幂循环）。  
3. **洛谷 P4783 矩阵快速幂（加强版）**  
   - 🗣️ **推荐理由**：处理更大的矩阵（n≤100），练习优化矩阵乘法（如缓存优化）。  
4. **洛谷 P2233 皇后游戏**  
   - 🗣️ **推荐理由**：虽然不是矩阵题，但涉及递推和期望，练习“将问题转化为线性关系”的思维。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>  
从题解中，我提炼了以下**宝贵经验**，希望对大家有帮助：  
</insights_intro>

> **经验1：Modint模板的重要性**（来自rui_er的题解）  
> 作者用Modint类封装了模运算，避免了重复写`% mod`的繁琐。这提醒我们，**代码复用**是提高编程效率的关键——将常用的功能（如模运算）封装成类或函数，可以减少代码量，降低错误率。  

> **经验2：转移矩阵的验证**（来自Eibon的题解）  
> 作者在化简递推式时，通过数学推导验证了转移矩阵的正确性。这告诉我们，**数学推导是编程的基础**——在写代码前，一定要先理清逻辑，避免“盲目编码”。  

> **经验3：矩阵快速幂的调试技巧**（来自Register_int的题解）  
> 作者在代码中加入了`print`函数，用于输出矩阵的中间结果。这提醒我们，**调试时要打印中间值**——通过观察矩阵的变化，可以快速定位错误（比如，转移矩阵构造错误）。  


## 🎉 总结  
本次分析的“Graph Smoothing”问题，核心是**用矩阵快速幂处理大次数的线性递推**。通过构造转移矩阵、使用Modint类处理模运算、实现矩阵快速幂，我们可以高效解决这类问题。  

记住：**矩阵快速幂是处理大次数递推的“神器”**，只要掌握了它的核心思想（线性递推转矩阵），就能解决很多看似“不可能”的问题！  

下次我们再一起探索新的编程挑战，加油！💪

---
处理用时：500.07秒
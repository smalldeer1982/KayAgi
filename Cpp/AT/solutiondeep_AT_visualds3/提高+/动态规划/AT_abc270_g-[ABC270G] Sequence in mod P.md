# 题目信息

# [ABC270G] Sequence in mod P

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc270/tasks/abc270_g

次の漸化式で定められる数列 $ X=(X_0,X_1,\ldots) $ があります。

$ X_i\ =\ \left\{
\begin{array}{ll}
S\  \ (i\ =\ 0)\\
(A\ X_{i-1}+B)\ \bmod\ P\  \ (i\ \geq\ 1)
\end{array}
\right. $

$ X_i=G $ となる $ i $ が存在するか判定し、存在するならばそのような最小の $ i $ を求めてください。  
ここで、$ x\ \bmod\ y $ は、$ x $ を $ y $ で割ったあまり(最小非負剰余)を表すものとします。

$ 1 $ ファイルにつき $ T $ 個のテストケースが与えられます。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 100 $
- $ 2\ \leq\ P\ \leq\ 10^9 $
- $ P $ は素数
- $ 0\leq\ A,B,S,G\ <\ P $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

$ 1 $ 番目のケースについて、$ X=(1,3,2,0,\ldots) $ であることから、$ X_i=0 $ となる最小の $ i $ は $ 3 $ です。 $ 2 $ 番目のケースについて、$ X=(3,3,3,3,\ldots) $ であることから、$ X_i=0 $ となる $ i $ は存在しません。

## 样例 #1

### 输入

```
3
5 2 1 1 0
5 2 2 3 0
11 1 1 0 10```

### 输出

```
3
-1
10```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC270G] Sequence in mod P 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（BSGS算法）  

🗣️ **初步分析**：  
解决“Sequence in mod P”的关键，是将线性递推数列转化为**离散对数问题**，再用**BSGS（大步小步算法）**快速求解。简单来说，BSGS就像“字典查词”——把一个大的查找任务分成“前半本”和“后半本”，分别预处理和查找，从而将时间复杂度从O(P)降低到O(√P)。  

本题中，数列的递推式是线性的（Xi = A·Xi-1 + B mod P），我们可以通过**通项公式推导**，将其转化为求Aⁿ ≡ K mod P的形式（K是某个常数）。这一步是解题的核心，而BSGS则是解决这个离散对数问题的“钥匙”。  

### 核心算法流程与可视化设计思路  
1. **通项公式推导**：通过“待定系数法”将线性递推转化为等比数列（比如设Yi = Xi + C，使得Yi = A·Yi-1），从而得到Xi的通项公式。  
2. **转化为离散对数问题**：将题目要求的Xi=G代入通项，得到Aⁿ ≡ (G+C)/(S+C) mod P（其中C是推导中的常数）。  
3. **BSGS求解**：将Aⁿ拆分为A^(m·k - r)（m=√P），预处理右边的Aʳ·K，然后查找左边的A^(m·k)是否匹配。  

**可视化设计**：用**8位像素风**模拟“探险家找钥匙”的过程——  
- 屏幕左侧显示“前半本字典”（预处理的Aʳ·K），右侧显示“后半本字典”（A^(m·k)）；  
- 探险家（代表算法）逐步“翻页”（计算A^(m·k)），每翻一页就检查左侧是否有匹配的“钥匙”（Aʳ·K）；  
- 匹配成功时，播放“叮”的音效，并用闪烁的像素块标记找到的n；  
- 特殊情况（如A=0、A=1）用不同的像素场景表示（比如A=0时，探险家站在固定位置，检查是否有“钥匙”）。  


## 2. 精选优质题解参考

### 题解一：（来源：August_Light，赞3）  
* **点评**：这份题解的亮点是**矩阵BSGS的应用**，将线性递推转化为矩阵乘法问题（Xi+1 = M·Xi，其中M是2x2矩阵）。思路清晰，对矩阵逆元的存在条件（A≠0）分析到位，特判了A=0的情况。代码中矩阵的定义和乘法实现规范，BSGS的逻辑正确，但使用map导致时间复杂度略高（O(√P log √P)）。不过，矩阵方法为解决类似线性递推问题提供了通用框架，值得学习。  

### 题解二：（来源：yukimianyan，赞3）  
* **点评**：此题解的**通项公式推导简洁明了**，直接得出Xi的表达式，并转化为Aⁿ ≡ K mod P的形式。代码处理了所有特殊情况（A=0、A=1、S=G），逻辑严谨。BSGS的实现采用map，但代码风格简洁，变量命名清晰（如qpow表示快速幂，inv表示逆元）。特别是对A=1时的等差数列处理，直接求解i=(G-S)/B mod P，非常直观，适合初学者理解。  

### 题解三：（来源：一只小咕咕，赞2）  
* **点评**：这份题解的**待定系数法推导详细**， step-by-step 解释了如何将线性递推转化为等比数列（设Yi = Xi + C）。代码中BSGS的实现正确，处理了A=0、A=1等特殊情况，且用了更高效的map（虽然时间复杂度略高，但代码易读）。特别是对“等比数列通项”的推导，适合青少年学习者跟随思路一步步理解。  


## 3. 核心难点辨析与解题策略

### 1. 关键点1：线性递推的通项公式推导  
**分析**：线性递推式Xi = A·Xi-1 + B的通项公式需要通过“待定系数法”转化为等比数列。设Yi = Xi + C，则Yi = A·Yi-1，解得C = B/(A-1)（模P下用逆元计算）。这一步是将问题转化为离散对数的关键，若推导错误，后续步骤无法进行。  
💡 **学习笔记**：线性递推转等比数列的核心是“消去常数项”，通过添加一个常数C，让递推式只包含变量的线性组合。  

### 2. 关键点2：特殊情况的处理  
**分析**：当A=0时，Xi从X1开始恒等于B，直接判断B是否等于G；当A=1时，Xi是等差数列（Xi = S + B·i），求解i=(G-S)/B mod P（需特判B=0）；当S=G时，直接返回0。这些特殊情况若遗漏，会导致代码错误。  
💡 **学习笔记**：特殊情况是“边界条件”，解题时需先处理，再解决一般情况。  

### 3. 关键点3：BSGS算法的应用  
**分析**：BSGS用于求解Aⁿ ≡ K mod P的最小n。其核心思想是将n拆分为m·k - r（m=√P），预处理右边的K·Aʳ，然后查找左边的A^(m·k)是否匹配。实现时需注意模运算的正确性（如逆元的计算）和哈希表的选择（map vs unordered_map）。  
💡 **学习笔记**：BSGS是解决离散对数问题的常用算法，其时间复杂度为O(√P log √P)，适合处理大模数问题。  

### ✨ 解题技巧总结  
- **问题转化**：将线性递推转化为等比数列，再转化为离散对数问题。  
- **特殊情况优先**：先处理A=0、A=1、S=G等简单情况，再解决一般情况。  
- **模运算细节**：所有运算都要取模，逆元用费马小定理计算（因为P是质数）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合yukimianyan和一只小咕咕的题解，提炼出简洁的核心实现，处理了所有特殊情况，BSGS算法正确。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <map>
#include <cmath>
using namespace std;
typedef long long ll;

ll qpow(ll a, ll b, ll p) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

ll inv(ll a, ll p) {
    return qpow(a, p-2, p);
}

ll bsgs(ll a, ll b, ll p) {
    if (b % p == 1) return 0;
    map<ll, ll> mp;
    ll m = sqrt(p) + 1;
    ll tmp = b;
    for (ll i = 0; i <= m; i++) {
        mp[tmp] = i;
        tmp = tmp * a % p;
    }
    ll t = qpow(a, m, p);
    tmp = 1;
    for (ll i = 1; i <= m; i++) {
        tmp = tmp * t % p;
        if (mp.count(tmp)) return i * m - mp[tmp];
    }
    return -1;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        ll p, a, b, s, g;
        cin >> p >> a >> b >> s >> g;
        if (s == g) {
            cout << 0 << endl;
            continue;
        }
        if (a == 0) {
            cout << (b == g ? 1 : -1) << endl;
            continue;
        }
        if (a == 1) {
            if (b == 0) {
                cout << -1 << endl;
            } else {
                ll ans = ((g - s + p) % p) * inv(b, p) % p;
                cout << ans << endl;
            }
            continue;
        }
        ll c = b * inv(a-1, p) % p;
        ll numerator = (g + c) % p;
        ll denominator = (s + c) % p;
        ll k = numerator * inv(denominator, p) % p;
        ll ans = bsgs(a, k, p);
        cout << ans << endl;
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. **快速幂与逆元**：`qpow`计算a^b mod p，`inv`用费马小定理计算逆元。  
  2. **BSGS算法**：`bsgs`函数求解Aⁿ ≡ K mod P的最小n，用map存储预处理的结果。  
  3. **主函数**：处理T组测试用例，依次判断S=G、A=0、A=1等特殊情况，再计算通项公式中的常数C，转化为离散对数问题，调用BSGS求解。  


### 针对各优质题解的片段赏析  

#### 题解一（来源：August_Light）  
* **亮点**：矩阵BSGS的应用，将线性递推转化为矩阵乘法。  
* **核心代码片段**：  
```cpp
struct Matrix {
    ll M[2][2];
    Matrix() { memset(M, 0, sizeof(M)); }
    Matrix operator*(const Matrix& other) const {
        Matrix res;
        for (int i = 0; i < 2; i++)
            for (int k = 0; k < 2; k++)
                for (int j = 0; j < 2; j++)
                    res.M[i][j] = (res.M[i][j] + M[i][k] * other.M[k][j]) % MOD;
        return res;
    }
};

ll bsgs(Matrix a, Matrix v1, Matrix v2) {
    map<Matrix, ll> mp;
    ll t = sqrt(MOD) + 1;
    Matrix cur;
    cur.M[0][0] = cur.M[1][1] = 1; // 单位矩阵
    for (ll i = 1; i <= t; i++) {
        cur = cur * a;
        Matrix tmp = cur * v2;
        mp[tmp] = i;
    }
    // 后续查找逻辑...
}
```  
* **代码解读**：  
  - 矩阵`Matrix`表示2x2矩阵，重载`*`运算符实现矩阵乘法。  
  - `bsgs`函数中，`cur`是矩阵的幂次（A^i），`v1`是初始向量（[S; 1]），`v2`是目标向量（[G; 1]）。预处理`cur * v2`（即A^i * [G; 1]），然后查找`cur2 * v1`（即A^(m·k) * [S; 1]）是否匹配。  
* 💡 **学习笔记**：矩阵方法是解决线性递推问题的通用框架，适合处理多变量递推。  

#### 题解二（来源：yukimianyan）  
* **亮点**：通项公式推导简洁，特殊情况处理全面。  
* **核心代码片段**：  
```cpp
if (a == 1) {
    if (b == 0) {
        puts("-1");
    } else {
        ll ans = ((g - s + p) % p) * inv(b, p) % p;
        printf("%lld\n", ans);
    }
}
```  
* **代码解读**：当A=1时，Xi是等差数列（Xi = S + B·i），求解i=(G-S)/B mod P。用逆元计算除法，确保结果正确。  
* 💡 **学习笔记**：等差数列的求解是线性递推的特殊情况，直接用数学公式即可。  

#### 题解三（来源：一只小咕咕）  
* **亮点**：待定系数法推导详细，BSGS实现正确。  
* **核心代码片段**：  
```cpp
ll c = b * inv(a-1, p) % p;
ll numerator = (g + c) % p;
ll denominator = (s + c) % p;
ll k = numerator * inv(denominator, p) % p;
ll ans = bsgs(a, k, p);
```  
* **代码解读**：计算常数C = B/(A-1)，然后将通项公式转化为Aⁿ ≡ (G+C)/(S+C) mod P，调用BSGS求解。  
* 💡 **学习笔记**：待定系数法是转化线性递推的关键，需熟练掌握。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**《像素探险家找钥匙》**：用8位像素风模拟BSGS算法的执行过程，探险家需要找到“钥匙”（即满足Aⁿ ≡ K mod P的n）。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是“前半本字典”（预处理的K·Aʳ），用像素块表示，每个块显示r和对应的K·Aʳ值；  
   - 屏幕右侧是“后半本字典”（A^(m·k)），用像素块表示，每个块显示k和对应的A^(m·k)值；  
   - 中间是探险家（像素小人），初始位置在右侧起点。  

2. **预处理阶段**：  
   - 探险家从左侧起点开始，逐步计算K·Aʳ（r从0到m），每计算一个值，就将对应的像素块点亮（颜色为蓝色），并播放“滴”的音效。  

3. **查找阶段**：  
   - 探险家从右侧起点开始，逐步计算A^(m·k)（k从1到m），每计算一个值，就检查左侧是否有对应的蓝色块（即K·Aʳ = A^(m·k)）；  
   - 若找到匹配，探险家走到对应的蓝色块前，播放“叮”的音效，并用闪烁的红色块标记找到的n（n = m·k - r）；  
   - 若未找到，播放“嗡”的音效，显示“无解”。  

4. **特殊情况处理**：  
   - 当A=0时，探险家站在固定位置（左侧中间），检查B是否等于G，若等于，播放“叮”的音效，标记n=1；  
   - 当A=1时，探险家站在右侧中间，计算i=(G-S)/B mod P，若B≠0，播放“叮”的音效，标记i。  

### 交互与控制  
- **步进控制**：“单步”按钮让探险家每走一步（计算一个值），“自动播放”按钮让探险家快速走完所有步骤（速度可调）；  
- **重置按钮**：恢复初始场景；  
- **音效控制**：可以开启/关闭音效（默认开启）。  

### 设计思路  
- **像素风格**：模拟FC红白机的画面，让学习者感到亲切；  
- **游戏化元素**：用“找钥匙”的任务激发学习兴趣，音效提示增强反馈；  
- **可视化逻辑**：将BSGS的“预处理”和“查找”过程转化为探险家的行动，让抽象的算法变得直观。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **线性递推问题**：所有形如Xi = A·Xi-1 + B的线性递推，都可以用待定系数法转化为等比数列，再用BSGS求解；  
- **离散对数问题**：所有形如Aⁿ ≡ K mod P的问题，都可以用BSGS解决；  
- **模运算问题**：当P是质数时，逆元可以用费马小定理计算（inv(a) = a^(P-2) mod P）。  

### 练习推荐 (洛谷)  
1. **洛谷 P3846** - 【模板】BSGS  
   🗣️ **推荐理由**：这是BSGS的模板题，帮助你熟悉BSGS的实现细节。  
2. **洛谷 P4195** - 扩展BSGS  
   🗣️ **推荐理由**：处理P不是质数的情况，扩展BSGS的应用。  
3. **洛谷 P3306** - 【模板】斐波那契公约数  
   🗣️ **推荐理由**：用矩阵快速幂解决斐波那契数列的公约数问题，巩固矩阵方法。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自August_Light)**：“矩阵BSGS需要特判A=0的情况，因为矩阵的逆元存在的条件是行列式非零（即A≠0）。我一开始没特判，导致代码在A=0的测试用例中出错。”  
**点评**：这位作者的经验提醒我们，**矩阵方法的前提条件**（如逆元存在）需要特别注意。在编程中，特判特殊情况是避免bug的关键。  


## 结语  
本次关于“[ABC270G] Sequence in mod P”的分析，我们学习了线性递推的通项公式推导、BSGS算法的应用，以及特殊情况的处理。希望这份指南能帮助你理解数学算法的魅力，下次遇到类似问题时，能举一反三！💪  

如果有任何疑问，欢迎随时向Kay提问~ 😊

---
处理用时：343.45秒
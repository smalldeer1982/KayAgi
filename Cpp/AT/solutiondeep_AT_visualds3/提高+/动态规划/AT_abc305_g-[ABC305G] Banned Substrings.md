# 题目信息

# [ABC305G] Banned Substrings

## 题目描述

给定一个由 $M$ 个长度不超过 $6$ 的仅由字母 $\texttt a$ 和 $\texttt b$ 组成的非空字符串集合 $S=\{s_1, s_2, ..., s_M\}$。

求有多少个字符串 $T$ 满足以下条件：

- 长度为 $N$ 且仅由字母 $\texttt a$ 和 $\texttt b$ 组成。
- 对于任意 $s_i\in S$，$T$ 中不包含 $s_i$ 作为连续的子串。

由于答案可能很大，所以对 $998244353$ 取模。

## 说明/提示

$1\leq N\leq 10^{18}$

$1\leq M\leq 126$

$N$ 和 $M$ 是整数。

$s_i$ 是由字母 $a$ 和 $b$ 组成的长度不超过 $6$ 的非空字符串。

$s_i \neq s_j$（$1\leq i<j\leq M$）。

## 样例 #1

### 输入

```
4 3

aab

bbab

abab```

### 输出

```
10```

## 样例 #2

### 输入

```
20 1

aa```

### 输出

```
17711```

## 样例 #3

### 输入

```
1000000007 28

bbabba

bbbbaa

aabbab

bbbaba

baaabb

babaab

bbaaba

aabaaa

aaaaaa

aabbaa

bbaaaa

bbaabb

bbabab

aababa

baaaba

ababab

abbaba

aabaab

ababaa

abbbba

baabaa

aabbbb

abbbab

baaaab

baabbb

ababbb

baabba

abaaaa```

### 输出

```
566756841```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC305G] Banned Substrings 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：AC自动机 + 矩阵快速幂优化动态规划  

🗣️ **初步分析**：  
解决“禁止子串计数”问题，关键在于**高效处理多模式串匹配**和**大长度下的状态转移**。简单来说，AC自动机像一个“智能字典”，能快速判断字符串是否包含任何禁止子串；而矩阵快速幂则像“时间加速器”，能把原本需要O(N)次的DP转移压缩到O(logN)次，应对N=1e18的极端情况。  

### 核心思路拆解  
1. **问题转化**：我们需要统计长度为N的a/b字符串，不包含任何禁止子串。直接枚举所有字符串显然不可能（2^1e18种），因此需要用**动态规划（DP）**记录状态。  
2. **状态定义**：设`dp[i][j]`表示长度为i的字符串，匹配到AC自动机的第j个节点（未触发任何禁止子串）的方案数。  
3. **转移逻辑**：从节点j出发，添加字符a或b，转移到下一个节点k（通过AC自动机的`ch[j][0/1]`）。若k不是禁止节点，则`dp[i+1][k] += dp[i][j]`。  
4. **优化手段**：由于N极大，常规DP无法处理，需将转移逻辑转化为**矩阵乘法**，用快速幂计算矩阵的N次幂，从而快速得到结果。  

### 可视化设计思路  
为了直观展示AC自动机的转移和矩阵快速幂的过程，我设计了一个**8位像素风格的“字符串探险家”游戏**：  
- **场景**：用像素块表示AC自动机的节点（绿色为起始节点，红色为禁止节点），箭头表示字符转移（a→左，b→右）。  
- **动态演示**：  
  - 初始化时，起始节点（0号）高亮，显示“初始状态”。  
  - 每添加一个字符（a或b），像素箭头移动，节点切换，同时显示当前字符串的末尾部分（如最后6个字符）。  
  - 若转移到禁止节点，触发“警告”音效（短促的“滴滴”声），并重置当前路径。  
- **矩阵快速幂**：用“齿轮转动”动画表示矩阵乘法，每完成一次快速幂迭代，显示当前的“加速倍数”（如2^k次转移）。  


## 2. 精选优质题解参考

<eval_intro>  
为了帮助大家快速掌握核心思路，我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了以下优质题解：  
</eval_intro>

### **题解一：Neil_Qian（5星）**  
* **来源**：洛谷/Atcoder提交记录  
* **点评**：  
  这份题解是**AC自动机+矩阵快速幂的标准实现**，思路清晰且代码规范。作者详细解释了AC自动机的构建（插入字符串、失配指针）和矩阵快速幂的应用，尤其是**“结束标记随失配指针传递”**的细节（避免遗漏禁止子串），体现了对算法的深刻理解。代码中的`mat`结构体封装了矩阵乘法，逻辑严谨；`build`函数处理失配指针的方式简洁高效，适合初学者模仿。  

### **题解二：_•́へ•́╬_（5星）**  
* **来源**：Atcoder提交记录  
* **点评**：  
  此题解的**代码简洁性**是最大亮点。作者用`deque`处理AC自动机的BFS构建，`matrix`结构体的乘法重载简洁明了，尤其是状态转移矩阵的构建（`a.a[i][tre[i][0]]++`），直接对应DP的转移逻辑。虽然注释较少，但代码结构清晰，适合有一定基础的学习者快速理解核心逻辑。  

### **题解三：Disjoint_cat（4星）**  
* **来源**：洛谷题解  
* **点评**：  
  作者提出了“用最后5个字符作为状态”的DP思路，虽然不如AC自动机通用，但启发了我们**“状态压缩”**的思考。不过，该思路未实现AC自动机，对于禁止子串长度超过5的情况无法处理，因此实用性略低，但仍是理解DP状态设计的好例子。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题的核心难点在于**AC自动机的正确构建**和**矩阵快速幂的转移矩阵设计**。结合优质题解，我总结了以下关键策略：  
</difficulty_intro>

### 1. **难点1：AC自动机的失配指针与结束标记传递**  
* **问题**：若一个节点的失配指针指向的节点是禁止节点，那么该节点也应被标记为禁止（否则会遗漏包含禁止子串的情况）。  
* **解决方案**：在构建失配指针时，通过`ban[u] |= ban[fail[u]]`（如_•́へ•́╬_的代码）传递结束标记。这一步是AC自动机处理多模式串的关键，必须牢记。  
* 💡 **学习笔记**：失配指针不仅用于快速跳转，还能传递“是否包含禁止子串”的状态。  

### 2. **难点2：矩阵快速幂的转移矩阵构建**  
* **问题**：如何将DP的转移逻辑转化为矩阵乘法？  
* **解决方案**：设矩阵`M`的大小为`cnt×cnt`（`cnt`为AC自动机节点数），`M[i][j]`表示从节点`j`转移到节点`i`的方案数（即添加a或b后能到达`i`的次数）。例如，若从`j`添加a到`k`，则`M[k][j]++`（如Neil_Qian的代码）。  
* 💡 **学习笔记**：矩阵的行对应“目标状态”，列对应“源状态”，乘法的顺序需注意。  

### 3. **难点3：大N情况下的状态初始化与结果统计**  
* **问题**：N=1e18时，如何初始化DP状态？  
* **解决方案**：初始状态`dp[0][0] = 1`（长度为0的字符串，位于起始节点）。矩阵快速幂计算`M^N`后，统计所有非禁止节点的`dp[N][j]`之和（如_•́へ•́╬_的代码）。  
* 💡 **学习笔记**：结果统计时需排除所有禁止节点，否则会包含无效字符串。  

### ✨ 解题技巧总结  
- **技巧A：多模式串匹配用AC自动机**：当禁止子串数量多且长度短（≤6）时，AC自动机是最优选择。  
- **技巧B：大N的DP用矩阵快速幂**：若DP转移是线性的（如`dp[i+1] = M × dp[i]`），则矩阵快速幂能将时间复杂度从O(N)降到O(logN)。  
- **技巧C：状态压缩**：AC自动机的节点数由禁止子串的总长度决定（≤2^7=128），因此状态数很小，适合矩阵运算。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
以下是**AC自动机+矩阵快速幂**的通用核心实现，综合了Neil_Qian和_•́へ•́╬_的代码优点：  
</code_intro_overall>

### **本题通用核心C++实现参考**  
* **说明**：本代码实现了AC自动机的构建、矩阵快速幂的转移，适用于所有禁止子串长度≤6的情况。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <queue>
  #include <cstring>
  using namespace std;
  typedef long long ll;
  const ll MOD = 998244353;
  const int MAX_NODE = 130; // 禁止子串长度≤6，节点数≤2^7=128

  // AC自动机结构
  int ch[MAX_NODE][2]; // ch[u][0]表示u节点添加'a'后的下一个节点
  int fail[MAX_NODE];
  bool ban[MAX_NODE]; // 标记该节点是否为禁止节点
  int cnt = 0; // 节点数（起始节点为0）

  // 矩阵结构
  struct Matrix {
      ll a[MAX_NODE][MAX_NODE];
      Matrix() { memset(a, 0, sizeof(a)); }
      Matrix operator*(const Matrix& other) const {
          Matrix res;
          for (int i = 0; i <= cnt; i++) {
              for (int k = 0; k <= cnt; k++) {
                  if (a[i][k] == 0) continue;
                  for (int j = 0; j <= cnt; j++) {
                      res.a[i][j] = (res.a[i][j] + a[i][k] * other.a[k][j]) % MOD;
                  }
              }
          }
          return res;
      }
  };

  // 插入禁止字符串到AC自动机
  void insert(const string& s) {
      int u = 0;
      for (char c : s) {
          int idx = (c == 'a') ? 0 : 1;
          if (!ch[u][idx]) ch[u][idx] = ++cnt;
          u = ch[u][idx];
      }
      ban[u] = true;
  }

  // 构建AC自动机的失配指针
  void build() {
      queue<int> q;
      for (int i = 0; i < 2; i++) {
          if (ch[0][i]) {
              fail[ch[0][i]] = 0;
              q.push(ch[0][i]);
          }
      }
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          // 传递禁止标记：若失配指针指向的节点是禁止的，则当前节点也禁止
          ban[u] |= ban[fail[u]];
          for (int i = 0; i < 2; i++) {
              if (ch[u][i]) {
                  fail[ch[u][i]] = ch[fail[u]][i];
                  q.push(ch[u][i]);
              } else {
                  ch[u][i] = ch[fail[u]][i];
              }
          }
      }
  }

  // 矩阵快速幂
  Matrix quick_pow(Matrix base, ll power) {
      Matrix res;
      // 初始化单位矩阵：res.a[i][i] = 1
      for (int i = 0; i <= cnt; i++) res.a[i][i] = 1;
      while (power > 0) {
          if (power & 1) res = res * base;
          base = base * base;
          power >>= 1;
      }
      return res;
  }

  int main() {
      ll n;
      int m;
      cin >> n >> m;
      for (int i = 0; i < m; i++) {
          string s;
          cin >> s;
          insert(s);
      }
      build();

      // 构建转移矩阵：M[i][j]表示从j转移到i的方案数
      Matrix trans;
      for (int j = 0; j <= cnt; j++) {
          if (ban[j]) continue; // 禁止节点无法转移
          for (int i = 0; i < 2; i++) {
              int next = ch[j][i];
              if (!ban[next]) { // 转移后的节点必须非禁止
                  trans.a[next][j]++;
              }
          }
      }

      // 计算trans^n，初始状态是dp[0][0] = 1
      Matrix mat_pow = quick_pow(trans, n);
      ll ans = 0;
      for (int i = 0; i <= cnt; i++) {
          if (!ban[i]) {
              ans = (ans + mat_pow.a[i][0]) % MOD;
          }
      }
      cout << ans << endl;

      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **AC自动机构建**：`insert`函数将禁止字符串插入到Trie树中，`build`函数通过BFS构建失配指针，并传递禁止标记。  
  2. **矩阵构建**：`trans`矩阵表示DP的转移逻辑，`trans.a[next][j]++`表示从节点`j`添加字符后转移到`next`的方案数。  
  3. **矩阵快速幂**：`quick_pow`函数计算转移矩阵的`n`次幂，得到长度为`n`的字符串的状态分布。  
  4. **结果统计**：累加所有非禁止节点的`mat_pow.a[i][0]`（初始状态为0号节点），得到最终答案。  

---

<code_intro_selected>  
以下是优质题解的核心片段赏析：  
</code_intro_selected>

### **题解一：Neil_Qian的AC自动机构建**  
* **亮点**：**结束标记的传递**（`suc[u] |= suc[fail[u]]`）  
* **核心代码片段**：  
  ```cpp
  inline void build(){//构建fail指针
      for(i=0;i<2;i++)if(ch[0][i])q.push(ch[0][i]);
      while(!q.empty()){
          u=q.front(),q.pop(),suc[u]|=suc[fail[u]];//关键：传递禁止标记
          for(i=0;i<2;i++)
              if(ch[u][i])fail[ch[u][i]]=ch[fail[u]][i],
                  q.push(ch[u][i]);
              else ch[u][i]=ch[fail[u]][i];
      }
  }
  ```  
* **代码解读**：  
  这段代码是AC自动机的核心。`suc[u] |= suc[fail[u]]`表示：若`u`的失配指针指向的节点`fail[u]`是禁止的（`suc[fail[u]]=true`），则`u`也应被标记为禁止（`suc[u]=true`）。例如，若禁止子串是“ab”，那么字符串“aab”中的“ab”会被`fail`指针检测到，从而`u`节点（对应“aab”的末尾）被标记为禁止。  
* 💡 **学习笔记**：结束标记的传递是AC自动机处理多模式串的关键，否则会遗漏包含禁止子串的情况。  

### **题解二：_•́へ•́╬_的矩阵乘法**  
* **亮点**：**简洁的矩阵乘法实现**  
* **核心代码片段**：  
  ```cpp
  inline void operator*=(const matrix&kkk)
  {
      int ans[N][N]={};
      for(int i=0;i<=sz;++i)for(int j=0;j<=sz;++j)if(a[i][j])
          for(int k=0;k<=sz;++k)
              ans[i][k]=(ans[i][k]+(long long)(a[i][j])*kkk.a[j][k])%mod;
      for(int i=0;i<=sz;++i)for(int j=0;j<=sz;++j)a[i][j]=ans[i][j];
  }
  ```  
* **代码解读**：  
  这段代码重载了矩阵的`*=`运算符，实现了矩阵乘法。作者用`long long`防止溢出，并用`if(a[i][j])`跳过零元素，优化了效率。矩阵乘法的顺序是“行×列”，即`ans[i][k] += a[i][j] * kkk.a[j][k]`，对应DP的转移逻辑（从`j`转移到`i`）。  
* 💡 **学习笔记**：矩阵乘法的顺序和溢出问题是实现中的关键细节，需特别注意。  


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>  
为了更直观地理解**AC自动机的转移**和**矩阵快速幂的加速过程**，我设计了一个**8位像素风格的“字符串探险家”游戏**，结合复古游戏元素（如FC红白机的音效和画面），帮助大家“看”到算法的每一步！  
\</visualization\_intro\>

### **动画演示主题**：字符串探险家的“禁止子串躲避之旅”  
### **核心演示内容**：  
1. **AC自动机节点展示**：用绿色像素块表示起始节点（0号），红色像素块表示禁止节点（如包含“aab”的节点），灰色像素块表示普通节点。  
2. **字符转移动画**：当添加字符`a`或`b`时，用蓝色箭头从当前节点指向目标节点（如从0号节点添加`a`到1号节点），同时显示当前字符串的末尾6个字符（如“a”→“aa”→“aab”）。  
3. **禁止节点触发**：若转移到红色节点，屏幕闪烁红色，播放“滴滴”警告音效，并重置当前路径（回到起始节点）。  
4. **矩阵快速幂加速**：用“齿轮转动”动画表示矩阵乘法，每完成一次快速幂迭代（如计算`M^2`→`M^4`→`M^8`），屏幕右上角显示“加速倍数：2^k”，同时当前字符串的长度快速增加（如从1→2→4→8）。  

### **设计思路简述**：  
- **像素风格**：8位像素风营造复古游戏氛围，降低学习压力；  
- **音效提示**：关键操作（如转移、禁止节点触发）用音效强化记忆（如“叮”表示转移成功，“滴滴”表示禁止）；  
- **游戏化元素**：将“避免禁止子串”设计为“躲避障碍物”，增加趣味性；将“矩阵快速幂”设计为“加速道具”，让学习者直观感受算法的效率。  

### **关键帧示例**：  
- **帧1**：初始状态，绿色节点（0号）高亮，显示“当前长度：0”；  
- **帧2**：添加字符`a`，蓝色箭头从0号指向1号节点，显示“当前字符串：a”；  
- **帧3**：添加字符`a`，箭头从1号指向2号节点，显示“当前字符串：aa”；  
- **帧4**：添加字符`b`，箭头从2号指向3号节点（禁止节点），屏幕闪烁红色，播放“滴滴”声，显示“禁止子串：aab”，重置到0号节点；  
- **帧5**：点击“加速”按钮，齿轮转动，显示“加速倍数：2^3=8”，当前长度从0跳到8，显示“当前字符串：aaaaaaaa”（未触发禁止子串）。  

### **交互设计**：  
- **控制按钮**：“开始/暂停”（控制动画播放）、“单步”（逐字符添加）、“加速”（触发矩阵快速幂）、“重置”（回到初始状态）；  
- **速度滑块**：调整动画播放速度（从“慢”到“快”）；  
- **算法比较**：可切换“普通DP”和“矩阵快速幂”模式，对比两者的效率（普通DP需逐帧播放，矩阵快速幂可快速跳跃）。  


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>  
掌握了“AC自动机+矩阵快速幂”的套路后，我们可以解决**所有“大长度字符串计数+禁止子串”**的问题。以下是几个相似的练习：  
\</similar\_problems\_intro\>

### **通用思路迁移**：  
- **场景1**：禁止子串包含数字或其他字符（如“123”“abc”），只需将AC自动机的字符集扩展即可；  
- **场景2**：要求字符串包含至少一个目标子串（反问题），可通过“总方案数-不包含任何目标子串的方案数”计算；  
- **场景3**：禁止子串长度超过6（如≤10），AC自动机的节点数仍在可接受范围内（≤2^11=2048），矩阵快速幂仍适用。  

### **练习推荐 (洛谷)**：  
1. **洛谷 P3375** - 【模板】AC自动机（简单版）  
   🗣️ **推荐理由**：AC自动机的基础模板题，帮助你巩固“插入字符串、构建失配指针”的实现。  
2. **洛谷 P1363** - 幻象迷宫  
   🗣️ **推荐理由**：矩阵快速幂的应用题，要求计算大步数下的路径数，与本题的转移逻辑类似。  
3. **洛谷 P4051** -  [JSOI2007]字符加密  
   🗣️ **推荐理由**：AC自动机的进阶题，要求处理循环字符串的禁止子串，需要结合后缀数组或其他技巧。  


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>  
以下是题解作者分享的**踩坑教训**，对初学者非常有帮助：  
\</insights\_intro\>

> **参考经验 (来自 Neil_Qian)**：“我最初在构建AC自动机时，忘记传递结束标记（`suc[u] |= suc[fail[u]]`），导致测试用例2（禁止子串“aa”）的结果错误。后来通过打印中间节点的`suc`值，才发现问题出在失配指针的处理上。”  
> **点评**：这位作者的经历提醒我们，**调试时打印中间状态**是定位错误的有效方法。AC自动机的结束标记传递是容易遗漏的细节，必须通过测试用例验证。  


## 结语  
本次关于“[ABC305G] Banned Substrings”的分析，我们学习了**AC自动机**（处理多模式串）和**矩阵快速幂**（优化大N的DP）的结合。记住，**算法的核心是“状态转移”**，而AC自动机和矩阵快速幂是“工具”，帮助我们高效处理复杂问题。  

下次遇到“大长度字符串计数”问题时，不妨想想：“是否可以用AC自动机压缩状态？是否可以用矩阵快速幂加速转移？” 持续思考，你会越来越擅长算法！💪  

---  
**Kay的提示**：如果对AC自动机的失配指针还有疑问，可以尝试手动模拟“插入字符串‘aab’和‘ab’”的过程，画出每个节点的`fail`指针和`ban`标记，相信你会有更深刻的理解！

---
处理用时：499.41秒
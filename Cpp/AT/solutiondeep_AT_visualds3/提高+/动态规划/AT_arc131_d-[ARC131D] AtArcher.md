# 题目信息

# [ARC131D] AtArcher

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc131/tasks/arc131_d

りんごさんはアーチェリーの大会「AtArcher」に出場しました。

AtArcher では、数直線上に表される的に $ N $ 本の矢を撃って合計得点を競います。的の中心は座標 $ 0 $ であり、矢が当たった位置に応じて以下のように得点が定められています。

- $ i\ =\ 0,\ 1,\ \dots,\ M-1 $ に対して、中心からの距離が $ r_i $ から $ r_{i+1} $ までの場所に当てると $ s_i $ 点を獲得し、中心からの距離が $ r_M $ より大きい場所に当てると $ 0 $ 点を獲得する。**境界に当たった場合は高い方の得点になる。**
- 中心から近いほど高得点が得られるようになっている。すなわち、次を満たす。
  - $ 0\ =\ r_0\ \lt\ r_1\ \lt\ \cdots\ \lt\ r_{M-1}\ \lt\ r_M $
  - $ s_0\ \gt\ s_1\ \gt\ \cdots\ \gt\ s_{M-1}\ \gt\ 0 $

例えば、$ r\ =\ (0,\ 2,\ 7,\ 9),\ s\ =\ (100,\ 70,\ 30) $ の場合、得点は下図のようになります。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc131_d/87bb83172b692d63b862011e8b84e6414b495125.png) 

さらに、AtArcher では「どの $ 2 $ 本の矢も距離 $ D $ 以上の間隔を空ける」という特殊ルールがあります。これに違反した場合は失格となり、全体の得点が $ 0 $ 点になります。

さて、りんごさんが全ての矢を撃ち終わった時点で、最大何点獲得できるでしょう？

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ D\ \leq\ 10^6 $
- $ 0\ =\ r_0\ \lt\ r_1\ \lt\ \cdots\ \lt\ r_{M-1}\ \lt\ r_M\ \leq\ 10^{11} $
- $ 10^{11}\ \geq\ s_0\ \gt\ s_1\ \gt\ \cdots\ \gt\ s_{M-1}\ \gt\ 0 $
- 入力はすべて整数

### Sample Explanation 1

この入力例は問題文中の例に対応していますが、$ D\ =\ 3 $ となっています。 例えば、$ N\ =\ 3 $ 本の矢が座標 $ -6,\ -2,\ 1 $ に当たると、それぞれ $ 70,\ 100,\ 100 $ 点を獲得します。このとき合計得点は $ 270 $ 点となり、実現可能なものとしては最大です。 !\[\](https://img.atcoder.jp/arc131/3b9fbfbeaf90d953098e650d7b070e0d.png) なお、すべての矢を $ 100 $ 点のエリアに当てて $ 300 $ 点を取ることはできません。なぜなら、どの $ 2 $ 本の矢も距離 $ D\ =\ 3 $ 以上の間隔を空けなければ、失格で $ 0 $ 点になるからです。

### Sample Explanation 2

この入力例も問題文中の例に対応していますが、$ D\ =\ 8 $ となっています。 例えば、$ N\ =\ 3 $ 本の矢が座標 $ -7,\ 1,\ 9 $ に当たると、それぞれ $ 70,\ 100,\ 30 $ 点を獲得します。このとき合計得点は $ 200 $ 点となり、実現可能なものとしては最大です。 !\[\](https://img.atcoder.jp/arc131/aefdd113cd212d29142783d0ffb1ea1e.png)

### Sample Explanation 3

例えば、下図のように矢を当てると、合計得点は $ 111 $ 点となり、これが最大です。 !\[\](https://img.atcoder.jp/arc131/2058c9b1e1deeea3bc6bae11da70b210.png)

### Sample Explanation 4

$ N\ =\ 100 $ 本の矢を当てることができますが、失格にならないためには、得点が入るゾーンに $ 3 $ 本までしか入れることができません。

## 样例 #1

### 输入

```
3 3 3

0 2 7 9

100 70 30```

### 输出

```
270```

## 样例 #2

### 输入

```
3 3 8

0 2 7 9

100 70 30```

### 输出

```
200```

## 样例 #3

### 输入

```
7 5 47

0 10 40 100 160 220

50 25 9 6 3```

### 输出

```
111```

## 样例 #4

### 输入

```
100 1 5

0 7

100000000000```

### 输出

```
300000000000```

## 样例 #5

### 输入

```
15 10 85

0 122 244 366 488 610 732 854 976 1098 1220

10 9 8 7 6 5 4 3 2 1```

### 输出

```
119```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC131D] AtArcher 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心 + 前缀和/差分优化`  

🗣️ **初步分析**：  
解决“AtArcher”问题的关键，在于**用贪心策略确定箭的最优排列**（相邻箭间距恰好为D），并**用前缀和/差分快速计算平移后的得分变化**。  

简单来说，**贪心**的核心思想是“选择当前最优的局部决策，从而得到全局最优解”——因为得分随距离中心的远近单调递减，所以将箭尽可能密集地排列在中心附近（间距为D），一定能获得最高得分。而**前缀和/差分**则用于高效处理“箭平移时，得分区域变化”的问题，避免重复计算每个位置的得分。  

在本题中，贪心策略体现在：  
- 所有箭的间距必须为D（否则可以通过调整箭的位置，让更靠外的箭靠近中心，得分更高）；  
- 中心箭的位置必须在`[0, D)`区间内（通过对称性，只需枚举这个区间内的位置，就能覆盖所有可能的最优情况）。  

**核心算法流程**：  
1. 将箭分为左右两部分（左半部分有`floor(N/2)`支，右半部分有`ceil(N/2)`支）；  
2. 计算右半部分（以0为起点，间距D排列）在平移`p`（`0≤p<D`）后的得分`sd[1][p]`；  
3. 计算左半部分（以-D为起点，间距D排列）在平移`p`后的得分`sd[0][p]`；  
4. 枚举中心箭的位置`i`（`0≤i<D`），计算`sd[1][i] + sd[0][d-i]`（左半部分平移`d-i`等价于右移`i`），取最大值。  

**可视化设计思路**：  
- 用**8位像素风格**绘制数轴（中心为0，左右延伸），箭用彩色方块表示（比如红色代表右半部分，蓝色代表左半部分）；  
- 得分区域用不同颜色的条纹表示（比如深绿色代表100分，浅绿色代表70分，黄色代表30分）；  
- 平移时，箭的位置随鼠标或滑块移动，得分区域的变化用**闪烁**提示（比如箭从100分区域进入70分区域时，该区域闪烁）；  
- 用**音效**增强反馈：平移时播放“沙沙”声，得分变化时播放“叮”的提示音，找到最大值时播放“胜利”音效。  


## 2. 精选优质题解参考

<eval_intro>  
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面，筛选出以下优质题解：  
</eval_intro>  

**题解一：来源：Phartial（赞：2）**  
* **点评**：  
  这份题解的**思路极其清晰**，通过四个结论（箭间距为D、中心箭位置在`[0,D)`）将问题简化为“枚举中心箭位置，计算左右两部分得分”。**代码实现高效**：用`G`函数预处理左右两部分的得分，`l`数组记录每个模D的位置对应的得分分界点，`sd`数组存储平移后的得分。**实践价值高**：代码逻辑简洁，时间复杂度`O(N+D+M)`，完全满足1e5级别的数据要求。其中，“将左右两部分分开计算，再合并结果”的技巧，是解决对称问题的常用方法，值得学习。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
在解决这个问题时，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了对应的解决策略：  
</difficulty_intro>  

### 1. **难点1：为什么箭的间距必须为D？**  
* **分析**：  
  假设两支箭的间距大于D，那么可以将更靠外的箭向中心移动（保持间距≥D），这样该箭的得分会更高（因为更靠近中心）。因此，最优情况下，箭的间距必须恰好为D。  
* 💡 **学习笔记**：  
  贪心策略的关键是“利用单调性”——得分随距离中心的远近单调递减，所以密集排列在中心附近的箭得分更高。  


### 2. **难点2：如何高效计算平移后的得分变化？**  
* **分析**：  
  当箭平移时，部分箭会从一个得分区域进入另一个得分区域。直接计算每个平移位置的得分会超时（`O(ND)`），因此需要用**前缀和/差分**优化。例如，`l`数组记录每个模D的位置对应的得分分界点，当平移`p`时，只需更新这些分界点对应的得分变化，就能快速得到`sd[p]`。  
* 💡 **学习笔记**：  
  前缀和/差分是处理“区间更新、单点查询”或“单点更新、区间查询”的常用技巧，能将时间复杂度从`O(N)`降低到`O(1)`或`O(log N)`。  


### 3. **难点3：如何合并左右两部分的得分？**  
* **分析**：  
  左半部分的箭排列在`-D, -2D, ...`（以-D为起点），右半部分的箭排列在`0, D, ...`（以0为起点）。当中心箭平移`i`时，右半部分的箭平移`i`（位置变为`i, i+D, ...`），左半部分的箭需要平移`d-i`（位置变为`-(d-i), -(d-i)-D, ...`），这样左右两部分的箭间距仍为D。因此，合并得分的方式是`sd[1][i] + sd[0][d-i]`。  
* 💡 **学习笔记**：  
  对称性是解决此类问题的关键——左右两部分的得分计算逻辑相同，只需调整平移量即可合并结果。  


### ✨ 解题技巧总结  
- **技巧A：利用单调性**：当得分随距离中心的远近单调递减时，贪心策略（密集排列在中心附近）一定有效；  
- **技巧B：前缀和/差分优化**：处理“平移后的得分变化”时，用前缀和/差分记录分界点的变化，避免重复计算；  
- **技巧C：对称性合并**：左右两部分的得分计算逻辑相同，只需调整平移量即可合并结果。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个**通用核心C++实现**（来自Phartial的题解），它完整覆盖了解题的核心逻辑：  
</code_intro_overall>  

**本题通用核心C++实现参考**  
* **说明**：  
  此代码来自Phartial的题解，逻辑清晰、实现高效，是解决本题的典型方案。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  using LL = long long;

  const int kM = 1e5 + 1, kD = 1e6 + 1;

  int n, m, d;
  LL r[kM], s[kM], ans, ns, sd[2][kD];
  vector<int> l[kD];

  void G(LL cnt, int o) {
    ns = 0;
    for (int i = 0, j = 0; i < cnt; ++i) {
      while (j < m && 1LL * i * d > r[j + 1]) ++j;
      ns += s[j];
    }
    sd[o][0] = ns;
    for (int p = 1; p <= d; ++p) {
      for (int i : l[p - 1]) {
        if (r[i + 1] < p + (cnt - 1LL) * d) {
          ns += s[i + 1] - s[i];
        }
      }
      sd[o][p] = ns;
    }
  }

  int main() {
    ios_base::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m >> d;
    for (int i = 0; i <= m; ++i) cin >> r[i];
    for (int i = 0; i < m; ++i) {
      cin >> s[i];
      l[r[i + 1] % d].push_back(i);
    }
    G(n / 2, 0), G((n + 1) / 2, 1);
    for (int i = 0; i < d; ++i) {
      ans = max(ans, sd[1][i] + sd[0][d - i]);
    }
    cout << ans;
    return 0;
  }
  ```  
* **代码解读概要**：  
  1. `G`函数：计算某一侧（左或右）的得分。`cnt`是该侧的箭数量，`o`是侧标记（0为左，1为右）。  
     - 首先计算以0为起点的得分（`sd[o][0]`）；  
     - 然后枚举平移量`p`（`1≤p≤d`），更新得分（`sd[o][p]`）。  
  2. `main`函数：  
     - 读取输入，预处理`l`数组（记录每个模D的位置对应的得分分界点）；  
     - 调用`G`函数计算左右两部分的得分；  
     - 枚举中心箭的位置`i`，计算合并后的得分，取最大值。  


<code_intro_selected>  
接下来，剖析`G`函数的**核心代码片段**，看看它是如何高效计算得分的：  
</code_intro_selected>  

**题解一：来源：Phartial**  
* **亮点**：  
  用`l`数组记录得分分界点的模D位置，当平移`p`时，只需更新这些分界点对应的得分变化，就能快速得到`sd[o][p]`。  
* **核心代码片段**：  
  ```cpp
  void G(LL cnt, int o) {
    ns = 0;
    for (int i = 0, j = 0; i < cnt; ++i) {
      while (j < m && 1LL * i * d > r[j + 1]) ++j;
      ns += s[j];
    }
    sd[o][0] = ns;
    for (int p = 1; p <= d; ++p) {
      for (int i : l[p - 1]) {
        if (r[i + 1] < p + (cnt - 1LL) * d) {
          ns += s[i + 1] - s[i];
        }
      }
      sd[o][p] = ns;
    }
  }
  ```  
* **代码解读**：  
  - 第一部分（计算`sd[o][0]`）：遍历该侧的每支箭（`i`从0到`cnt-1`），找到它所在的得分区域（`j`是得分区域的索引），累加得分`ns`。  
  - 第二部分（计算`sd[o][p]`）：枚举平移量`p`（`1≤p≤d`），遍历`l[p-1]`中的得分分界点`i`（即`r[i+1]`模D等于`p-1`的分界点），如果该分界点在平移后的箭范围内（`r[i+1] < p + (cnt-1)*d`），则更新得分`ns`（减去旧得分`s[i]`，加上新得分`s[i+1]`）。  
* 💡 **学习笔记**：  
  `l`数组的作用是“预处理得分分界点的模D位置”，这样当平移`p`时，只需处理这些分界点，避免遍历所有分界点，从而将时间复杂度从`O(M*D)`降低到`O(M+D)`。  


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>  
为了更直观地理解“中心箭平移”和“得分变化”的过程，我设计了一个**8位像素风格的动画**，融合了复古游戏元素：  
\</visualization\_intro\>  

### **动画演示主题**：《像素弓箭手》  
- **场景**：一个8位像素风格的数轴（中心为0，左右延伸至±20D），得分区域用不同颜色的条纹表示（比如100分是深绿色，70分是浅绿色，30分是黄色）；  
- **角色**：右半部分的箭用红色方块表示（排列在`0, D, 2D, ...`），左半部分的箭用蓝色方块表示（排列在`-D, -2D, ...`）；  
- **控制面板**：包含“开始/暂停”、“单步平移”、“重置”按钮，以及一个“平移速度”滑块。  


### **核心演示内容**  
1. **初始化**：  
   - 数轴显示得分区域（深绿色：0~2，浅绿色：2~7，黄色：7~9）；  
   - 右半部分的箭（红色）排列在`0, 3, 6`（样例1中的D=3），左半部分的箭（蓝色）排列在`-3, -6`；  
   - 得分显示为`100+100+70=270`（样例1的输出）。  

2. **平移过程**：  
   - 当用户拖动“平移速度”滑块时，中心箭（红色的第一个箭）向右平移`i`（`0≤i<3`）；  
   - 右半部分的箭位置变为`i, i+3, i+6`，左半部分的箭位置变为`-(3-i), -(3-i)-3`；  
   - 当箭从一个得分区域进入另一个区域时，该区域闪烁（比如红色箭从深绿色进入浅绿色时，浅绿色区域闪烁），并播放“叮”的提示音。  

3. **最大值提示**：  
   - 当合并后的得分达到最大值时（比如样例1中的`i=1`，得分`100+100+70=270`），数轴上方显示“最大值！”的像素文字，并播放“胜利”音效。  


### **游戏化元素设计**  
- **AI自动演示**：点击“AI自动演示”按钮，动画会自动遍历`i=0`到`i=D-1`，展示每个位置的得分变化，帮助学习者快速找到最大值；  
- **关卡设计**：将“平移`i`”分为`D`个小关卡，完成每个关卡（遍历一个`i`）会获得“像素星星”奖励，激励学习者完成所有关卡；  
- **音效反馈**：平移时播放“沙沙”声，得分变化时播放“叮”的提示音，最大值时播放“胜利”音效，增强学习的趣味性。  


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>  
理解了“贪心+前缀和/差分”的思路后，我们可以尝试解决以下类似问题：  
\</similar\_problems\_intro\>  

### **通用思路/技巧迁移**  
- **贪心策略**：适用于“得分随某一变量单调变化”的问题（比如合并果子、国王游戏）；  
- **前缀和/差分**：适用于“区间更新、单点查询”或“单点更新、区间查询”的问题（比如树状数组、线段树的基础应用）。  


### **练习推荐 (洛谷)**  
1. **洛谷 P1208 混合牛奶**  
   - 🗣️ **推荐理由**：这道题考察贪心策略（选择最便宜的牛奶），与本题的“贪心选择中心附近的箭”思路一致，帮助巩固贪心的应用。  

2. **洛谷 P1080 国王游戏**  
   - 🗣️ **推荐理由**：这道题考察贪心策略（排序规则）和大数处理，与本题的“利用单调性”思路类似，是贪心的进阶练习。  

3. **洛谷 P3374 【模板】树状数组1**  
   - 🗣️ **推荐理由**：这道题是前缀和/差分的模板题，帮助巩固“区间更新、单点查询”的技巧，是本题的基础。  

4. **洛谷 P1880 石子合并**  
   - 🗣️ **推荐理由**：这道题考察前缀和+动态规划，与本题的“前缀和优化”思路类似，帮助拓展前缀和的应用场景。  


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>  
Phartial的题解中提到的“结论推导”是解决本题的关键，以下是值得借鉴的经验：  
\</insights\_intro\>  

> **参考经验 (来自Phartial)**：“最优方案中，中心箭的位置必定在`[0, D)`区间内。因为如果中心箭的位置超过D，那么可以将所有箭向左平移D，这样箭的位置更靠近中心，得分更高。”  
> **点评**：  
> 这个经验提醒我们，**对称性**是解决对称问题的关键。通过对称性，我们可以将枚举范围从“所有可能的位置”缩小到“`[0, D)`区间”，从而降低时间复杂度。在编程中，我们应该多思考问题的对称性，寻找优化的突破口。  


\<conclusion\>  
本次关于“[ARC131D] AtArcher”的C++解题分析就到这里。希望这份学习指南能帮助大家理解“贪心+前缀和/差分”的思路，掌握解决对称问题的技巧。记住，编程的乐趣在于“用简洁的代码解决复杂的问题”，继续加油吧！💪  
\</conclusion\>

---
处理用时：447.29秒
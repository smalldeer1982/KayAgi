# 题目信息

# Permutation

## 题目描述

给定一个正整数 $N$ 和一个由小于号 `<` 和大于号 `>` 组成的长度为 $N-1$ 的字符串 $s$。

你需要找到一个排列 $(p_1,\ p_2,\ p_3,\ ...,\ p_N)$，满足对于任意 $i\ (1 \leq i \leq N-1)$，如果 $s_i$ 为 `<` 则 $p_i < p_{i+1}$，如果 $s_i$ 为 `>` 则 $p_i > p_{i+1}$。求满足性质的排列 $p$ 的方案数**对 ${10}^{9}+7$ 取模**后的值。

## 说明/提示

### 数据范围与约定

- $N$ 是正整数
- $2 \leq N \leq 3000$
- $s$ 是一个长度为 $N-1$ 的字符串
- 字符串 $s$ 包含字符 `<` 和 `>`

### 样例解释 1

有 $5$ 个满足条件的排列，分别是：

- $(1,\ 3,\ 2,\ 4)$
- $(1,\ 4,\ 2,\ 3)$
- $(2,\ 3,\ 1,\ 4)$
- $(2,\ 4,\ 1,\ 3)$
- $(3,\ 4,\ 1,\ 2)$

### 样例解释 2

有 $1$ 个满足条件的排列 $(1,\ 2,\ 3,\ 4,\ 5)$。

### 样例解释 3

**注意输出结果要对 ${10}^{9}+7$ 取模。**

## 样例 #1

### 输入

```
4

<><```

### 输出

```
5```

## 样例 #2

### 输入

```
5

<<<<```

### 输出

```
1```

## 样例 #3

### 输入

```
20

>>>><>>><>><>>><<>>```

### 输出

```
217136290```

# AI分析结果


### 💡 Kay的C++算法解析：Permutation 深入学习指南 💡

**引言**  
今天我们来分析“Permutation”这道动态规划题目。本指南将帮助你理解核心算法、掌握解题技巧，并通过像素动画直观感受算法执行过程。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划（DP）` 与 `前缀和优化`

🗣️ **初步分析**：  
> 解决排列计数问题的关键在于**相对排名思想**。想象在游戏中逐步放置数字方块，我们只关心当前方块在已放置方块中的大小排名（如第2小），而非具体数值。这种思想完美适配DP：  
> - 定义 `dp[i][j]` 表示前 `i` 个位置中，第 `i` 个位置数字排名第 `j` 小的方案数
> - 根据符号 `>` 或 `<` 从上一状态转移：
>   - 若 `s[i] = '<'`：需从排名 `1~j-1` 转移（当前数比前一个数大）
>   - 若 `s[i] = '>'`：需从排名 `j~i-1` 转移（当前数比前一个数小）
> - **前缀和优化**：用 `sum[i][j]` 记录 `dp[i][1]` 到 `dp[i][j]` 的和，将转移复杂度从 O(n³) 降至 O(n²)

**可视化设计思路**：  
采用 **8位像素风格** 模拟数字方块放置过程：
- 网格行表示位置 `i`，列表示排名 `j`
- 放置方块时高亮来源区间（如 `'<'` 时高亮左侧绿色区域）
- 音效设计：放置方块（"滴"声），正确转移（"叮"声），完成（胜利音效）
- 控制面板支持步进/暂停/调速，实时显示 `dp[i][j]` 值

---

## 2. 精选优质题解参考

<eval_intro>
根据思路清晰性、代码规范性和算法优化度，精选3份优质题解：
</eval_intro>

**题解一（作者：云浅知处）**  
* **点评**：  
  状态定义清晰（`dp[i][j]` 表排名），完整推导转移方程。代码规范：  
  - 使用 `sum[i][j]` 前缀和优化  
  - 边界处理严谨（`mod` 运算防负数）  
  - 循环内联计算，无冗余变量  
  **亮点**：用 `(s+1)` 使字符串下标对齐，提升可读性

**题解二（作者：FelFa_1414666）**  
* **点评**：  
  创新性递推优化：  
  - `'<'` 时：`dp[i][j] = dp[i][j-1] + dp[i-1][j-1]`  
  - `'>'` 时：`dp[i][j] = dp[i][j+1] + dp[i-1][j]`  
  **亮点**：省去额外前缀和数组，空间效率更高

**题解三（作者：_GaP）**  
* **点评**：  
  独立维护前缀和数组 `sum`，与 `dp` 分离。代码注释详尽，特别适合初学者理解前缀和优化原理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此类问题的三大核心难点与应对策略：
</difficulty_intro>

1.  **难点：状态设计抽象**  
    * **分析**：需理解**相对排名**思想——新数字插入时，只需确定其在当前序列的排名位置，而非具体值。例如插入 "3" 到 [1,4,2] 中时，只需知它排名第2（值实际为3）。
    * 💡 **学习笔记**：DP状态应剥离具体值，关注相对关系

2.  **难点：转移范围推导**  
    * **分析**：符号 `>`/`<` 对应不同的转移区间：  
      - `'<'` 时：前一个数排名必须 **小于** `j`（新区间 [1, j-1]）  
      - `'>'` 时：前一个数排名必须 **大于等于** `j`（新区间 [j, i-1]）  
    * 💡 **学习笔记**：转移方向由符号决定，新区间包含原排名

3.  **难点：优化实现**  
    * **分析**：直接遍历区间求和会导致 O(n³)。前缀和数组 `sum[i][j] = Σdp[i][1..j]` 将单次转移降至 O(1)
    * 💡 **学习笔记**：区间求和问题优先考虑前缀和/差分

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：问题降维**  
  将排列具体值转化为相对排名，减少状态维度
- **技巧2：预处理优化**  
  前缀和/差分是优化区间求和DP的利器
- **技巧3：边界防御**  
  `(a - b + mod) % mod` 避免负数取模错误

---

## 4. C++核心代码实现赏析

<code_intro_overall>
**通用核心实现**（综合优质题解优化版）：
</code_intro_overall>

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 3005, mod = 1e9+7;

int n, dp[N][N], sum[N];
char s[N];

int main() {
    cin >> n >> (s + 1);  // s[1]对应第1-2位间符号
    dp[1][1] = 1;
    for (int i = 1; i <= n; i++) 
        sum[i] = sum[i-1] + dp[1][i];  // 初始化前缀和

    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            if (s[i-1] == '<') 
                dp[i][j] = sum[j-1];          // 从[1, j-1]转移
            else 
                dp[i][j] = (sum[i-1] - sum[j-1] + mod) % mod; // [j, i-1]
        }
        memset(sum, 0, sizeof sum);           // 重置前缀和
        for (int j = 1; j <= i; j++) 
            sum[j] = (sum[j-1] + dp[i][j]) % mod; // 更新前缀和
    }
    cout << sum[n] << endl;  // sum[n] = Σdp[n][1..n]
    return 0;
}
```
**代码解读概要**：  
- 第1行：数字1排名第1的方案数为1  
- 第7行：初始化前缀和数组  
- 第10-15行：核心转移逻辑，根据符号选择区间  
- 第16行：防负数取模技巧  
- 第18行：实时更新前缀和

---
<code_intro_selected>
**题解片段赏析**：
</code_intro_selected>

**题解二（递推优化）**  
* **亮点**：无前缀和数组，转移自包含  
* **核心代码**：
  ```cpp
  for (int i = 2; i <= n; i++) {
      if (s[i-2] == '<') 
          for (int j = 1; j <= i; j++)
              dp[i][j] = (dp[i][j-1] + dp[i-1][j-1]) % mod;
      else 
          for (int j = i-1; j >= 1; j--)  // 注意倒序！
              dp[i][j] = (dp[i][j+1] + dp[i-1][j]) % mod;
  }
  ```
* **代码解读**：  
  > - `'<'` 正序转移：`dp[i][j]` 继承 `dp[i][j-1]` 并新增 `dp[i-1][j-1]`  
  > - `'>'` 倒序关键：从右向左计算，利用已更新的 `dp[i][j+1]`  
  > - 空间复杂度降至 O(n)  
* 💡 **学习笔记**：递推方向影响状态依赖关系

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素探险家：动态规划排名之旅**  
通过8位像素风格演示DP状态转移，直观理解排名变化：
</visualization_intro>

* **场景设计**：
  - 16色像素网格：行=位置 `i`，列=排名 `j`
  - 控制面板：开始/暂停，步进按钮，速度滑块
  - 信息栏：显示当前 `dp[i][j]` 和 `sum[i][j]`

* **关键动画流程**：
  1. **初始化**：`(1,1)` 格子亮起（值=1），播放 "叮" 声
  2. **步进转移**（以 `i=3`, `s[2]='<'` 为例）：
     - 高亮当前格子 `(3,2)` 为黄色
     - 高亮来源区间 `[1,1]`（绿色闪烁）
     - 显示转移公式：`dp[3][2] = sum[2][1]`
     - 更新后播放 "滴" 声
  3. **前缀和更新**：  
     - 蓝色进度条从左到右填充 `sum[3][1..3]`
     - 数值实时显示在网格底部
  4. **完成效果**：  
     - 最终结果 `sum[n][n]` 金色闪烁
     - 播放胜利音效 + 像素烟花动画

* **游戏化设计**：
  - 每完成一行=通过一小关，奖励金币动画
  - 错误操作（如反向转移）触发 "错误" 音效
  - 背景音乐：8-bit 风格循环旋律

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握相对排名DP后，可解决更多约束类排列问题：
</similar_problems_intro>

1. **洛谷 P2513 [HAOI2009]逆序对数列**  
   🗣️ *推荐理由*：强化排名思想，需要推导逆序对与排名的关系
   
2. **洛谷 P4071 [SDOI2016]排列计数**  
   🗣️ *推荐理由*：结合组合数学，练习容斥原理与DP的融合
   
3. **洛谷 P1754 球迷购票问题**  
   🗣️ *推荐理由*：二维约束拓展，训练状态设计灵活性

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验：
</insights_intro>

> **参考经验（多位作者）**：  
> “初学时常错误理解转移区间方向，通过打印 `dp` 表才发现问题”  
> “忘记 `(a-b+mod)%mod` 导致负值，输出异常”  
>
> **Kay的总结**：  
> - 调试DP必备：打印中间状态表格  
> - 防负值技巧：`(x % mod + mod) % mod`  
> - 对拍验证：用小数据（如n=3）手动计算验证

---

**结语**  
通过相对排名思想，我们高效解决了带约束的排列计数问题。动态规划的精妙之处在于将复杂问题分解为状态转移，而前缀和优化则是提升效率的利器。继续加油，你也能成为DP大师！🚀

---
处理用时：180.33秒
# 题目信息

# Grid 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/dp/tasks/dp_y

縦 $ H $ 行、横 $ W $ 列のグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ で表します。

グリッドのうち、$ N $ 個のマス $ (r_1,\ c_1),\ (r_2,\ c_2),\ \ldots,\ (r_N,\ c_N) $ は壁のマスであり、それら以外のマスはすべて空マスです。 マス $ (1,\ 1) $ および $ (H,\ W) $ は空マスであることが保証されています。

太郎君は、マス $ (1,\ 1) $ から出発し、右または下に隣り合う空マスへの移動を繰り返すことで、マス $ (H,\ W) $ まで辿り着こうとしています。

マス $ (1,\ 1) $ から $ (H,\ W) $ までの太郎君の経路は何通りでしょうか？ $ 10^9\ +\ 7 $ で割った余りを求めてください。

## 说明/提示

### 制約

- 入力はすべて整数である。
- $ 2\ \leq\ H,\ W\ \leq\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 3000 $
- $ 1\ \leq\ r_i\ \leq\ H $
- $ 1\ \leq\ c_i\ \leq\ W $
- マス $ (r_i,\ c_i) $ はすべて相異なる。
- マス $ (1,\ 1) $ および $ (H,\ W) $ は空マスである。

### Sample Explanation 1

経路は次図の $ 3 $ 通りです。 !\[\](https://img.atcoder.jp/dp/grid\_1\_0\_muffet.png)

### Sample Explanation 2

経路が存在しない場合もあります。

### Sample Explanation 4

答えを $ 10^9\ +\ 7 $ で割った余りを出力することを忘れずに。

## 样例 #1

### 输入

```
3 4 2

2 2

1 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2 2

2 1

4 2```

### 输出

```
0```

## 样例 #3

### 输入

```
5 5 4

3 1

3 5

1 3

5 3```

### 输出

```
24```

## 样例 #4

### 输入

```
100000 100000 1

50000 50000```

### 输出

```
123445622```

# AI分析结果



---
# 💡 Kay的C++算法解析：Grid 2 深入学习指南 💡

<introduction>
今天我们来一起分析“Grid 2”这道C++编程题。这道题要求我们计算从网格起点到终点的路径数，避开所有障碍物。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划(DP) + 组合数学`

🗣️ **初步分析**：
解决“Grid 2”这道题，关键在于结合动态规划（DP）和组合数学。动态规划用于处理路径计数中的状态转移，而组合数学则用于快速计算无障碍时的路径数。简单来说，动态规划的核心思想是“将复杂问题分解为子问题，利用子问题的解推导原问题的解”，就像搭积木一样，每一步的状态都依赖于前面的结果。在本题中，我们通过定义`dp[i]`表示从起点到第`i`个障碍物（含终点）且不经过其他障碍物的路径数，结合组合数计算初始值，再通过容斥排除经过其他障碍物的路径。

- **题解思路**：所有题解的核心思路一致：将终点视为第`N+1`个障碍物，按坐标排序障碍物后，用动态规划计算`dp[i]`，即从起点到第`i`个障碍物且不经过其他障碍物的路径数。初始值由组合数计算（无障碍时的路径数），再减去所有前面障碍物的贡献（经过其他障碍物到达当前障碍物的路径数）。
- **核心难点**：如何高效处理障碍物的影响，避免重复计算路径数；如何利用组合数快速计算无障碍路径数。
- **可视化设计思路**：设计像素动画展示障碍物排序过程（按x、y升序排列），用不同颜色标记当前处理的障碍物`i`和其前驱障碍物`j`，动态更新`dp[i]`的值（如通过数字变化或颜色渐变），并高亮组合数计算的关键步骤（如阶乘预处理、组合数公式的展开）。动画将采用8位像素风格，背景为复古网格，障碍物用红色方块表示，路径用绿色线条动态绘制。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的评估（思路清晰性、代码规范性、算法有效性等），以下题解因逻辑严谨、代码规范且优化得当，评分≥4星：
</eval_intro>

**题解一：作者GaryH**
* **点评**：此题解思路清晰，明确指出了动态规划的状态定义（`dp[i]`表示到第`i`个障碍物且不经过其他障碍物的路径数），并详细推导了状态转移方程。代码规范，变量名（如`dp`、`inv`、`fiv`）含义明确，预处理阶乘和逆元的逻辑高效。算法时间复杂度为`O(N²)`，符合题目要求。亮点在于将终点视为第`N+1`个障碍物，简化了最终答案的计算。

**题解二：作者ZolaWatle**
* **点评**：此题解对问题的分解非常到位，从无障碍情况入手，逐步引入障碍物的影响，逻辑推导过程易懂。代码结构工整，关键步骤（如排序、组合数计算、状态转移）均有注释。亮点在于对状态转移的解释（“减去所有由起点经前驱障碍物到达当前障碍物的路径数”），帮助学习者理解容斥的核心思想。

**题解三：作者DengDuck**
* **点评**：此题解代码简洁高效，通过将终点直接加入障碍物数组并排序，统一了状态转移的处理逻辑。组合数预处理部分（`ksm`快速幂求逆元）实现巧妙，确保了计算的高效性。亮点在于将动态规划与组合数学的结合，代码可读性强，适合作为参考模板。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何定义动态规划的状态？**
    * **分析**：状态定义需满足“不经过其他障碍物”的条件。优质题解中，`dp[i]`被定义为从起点到第`i`个障碍物（按坐标排序后）且不经过其他障碍物的路径数。这一定义确保了状态的无后效性（后续状态仅依赖于前面的状态）。
    * 💡 **学习笔记**：状态定义需紧扣问题核心约束（如本题的“不经过其他障碍物”），并通过排序确保状态转移的顺序性。

2.  **关键点2：如何计算无障碍时的路径数？**
    * **分析**：无障碍时，从`(x1,y1)`到`(x2,y2)`的路径数为组合数`C((x2-x1)+(y2-y1), x2-x1)`。这是因为需要走`(x2-x1)+(y2-y1)`步，其中`x2-x1`步向下，其余向右。优质题解通过预处理阶乘和逆元，实现了组合数的`O(1)`计算。
    * 💡 **学习笔记**：组合数的快速计算依赖于阶乘和逆元的预处理，这是解决大数组合问题的关键技巧。

3.  **关键点3：如何处理障碍物的影响？**
    * **分析**：通过容斥原理，状态转移时需减去所有前驱障碍物的贡献（即从起点到前驱障碍物且不经过其他障碍物的路径数，乘以前驱到当前障碍物的路径数）。排序确保了前驱障碍物的坐标均小于当前障碍物，避免重复计算。
    * 💡 **学习笔记**：排序是处理依赖关系的常用手段，确保状态转移的顺序性和正确性。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解与抽象**：将复杂问题（含障碍物的路径计数）分解为子问题（无障碍路径数、排除前驱障碍物的贡献）。
- **预处理优化**：预处理阶乘和逆元，快速计算组合数，避免重复计算。
- **排序处理依赖**：按坐标排序障碍物，确保状态转移的顺序性，避免遗漏或重复。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，采用动态规划+组合数学的经典解法，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MOD = 1e9 + 7;
    const int MAXN = 3005; // 障碍物最多3000+1（终点）
    const int MAXM = 2e5 + 10; // 阶乘预处理范围（H+W最大2e5）

    struct Point {
        int x, y;
        bool operator<(const Point& other) const {
            if (x != other.x) return x < other.x;
            return y < other.y;
        }
    };

    ll fact[MAXM], inv_fact[MAXM];
    Point obs[MAXN];
    ll dp[MAXN];

    ll qpow(ll a, ll b) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    void precompute() {
        fact[0] = 1;
        for (int i = 1; i < MAXM; ++i)
            fact[i] = fact[i - 1] * i % MOD;
        inv_fact[MAXM - 1] = qpow(fact[MAXM - 1], MOD - 2);
        for (int i = MAXM - 2; i >= 0; --i)
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
    }

    ll C(int n, int k) {
        if (k < 0 || k > n) return 0;
        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
    }

    int main() {
        int H, W, N;
        cin >> H >> W >> N;
        for (int i = 1; i <= N; ++i)
            cin >> obs[i].x >> obs[i].y;
        obs[++N] = {H, W}; // 将终点视为第N+1个障碍物
        sort(obs + 1, obs + N + 1);

        precompute();

        for (int i = 1; i <= N; ++i) {
            int x = obs[i].x, y = obs[i].y;
            dp[i] = C(x + y - 2, x - 1); // 初始值：无障碍时的路径数
            for (int j = 1; j < i; ++j) {
                int xj = obs[j].x, yj = obs[j].y;
                if (xj <= x && yj <= y) {
                    int dx = x - xj, dy = y - yj;
                    dp[i] = (dp[i] - dp[j] * C(dx + dy, dx) % MOD + MOD) % MOD;
                }
            }
        }

        cout << dp[N] << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入并将终点加入障碍物数组，按坐标排序。预处理阶乘和逆元后，计算每个障碍物（含终点）的初始路径数（无障碍时的组合数），再通过动态规划减去所有前驱障碍物的贡献，最终输出终点的`dp`值（即所求路径数）。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：作者GaryH**
* **亮点**：巧妙将终点视为第`N+1`个障碍物，统一状态转移逻辑；预处理阶乘和逆元的代码简洁高效。
* **核心代码片段**：
    ```cpp
    dp[i] = C(p[i].fi + p[i].se - 2, p[i].fi - 1) % mod;
    rep(j, 1, i - 1) {
        if (p[j].fi > p[i].fi || p[j].se > p[i].se) continue;
        int XL = p[i].fi - p[j].fi, YL = p[i].se - p[j].se;
        dp[i] -= dp[j] * C(XL + YL, XL) % mod;
        dp[i] = (dp[i] + mod) % mod;
    }
    ```
* **代码解读**：
    > 这段代码计算`dp[i]`的初始值（无障碍时的路径数），然后遍历所有前驱障碍物`j`，若`j`在`i`的左上方，则减去`dp[j]`乘以前驱到当前障碍物的路径数（组合数`C(XL+YL, XL)`），确保不重复计算经过`j`的路径。
* 💡 **学习笔记**：动态规划的状态转移需严格排除所有前驱障碍物的贡献，确保`dp[i]`仅表示不经过其他障碍物的路径数。

**题解二：作者ZolaWatle**
* **亮点**：代码结构工整，注释清晰，组合数计算与状态转移逻辑分离，可读性强。
* **核心代码片段**：
    ```cpp
    rep(i, 1, n) {
        int x = a[i].x, y = a[i].y;
        dp[i] = C((ll)x + y, (ll)x);
        rep(j, 1, i - 1) if (a[j].x <= x && a[j].y <= y) {
            int lx = x - a[j].x, ly = y - a[j].y;
            dp[i] = (dp[i] - dp[j] * C((ll)lx + ly, (ll)lx) % mod + mod) % mod;
        }
    }
    ```
* **代码解读**：
    > 此片段中，`dp[i]`的初始值为从起点到`(x,y)`的无障碍路径数（组合数`C(x+y, x)`）。通过嵌套循环遍历前驱障碍物`j`，若`j`在`i`的左上方，则减去`dp[j] * C(lx+ly, lx)`（`j`到`i`的路径数），确保`dp[i]`仅包含不经过其他障碍物的路径。
* 💡 **学习笔记**：状态转移的条件（`j`在`i`的左上方）是关键，确保前驱障碍物的路径能到达当前障碍物。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解动态规划与组合数的结合过程，我们设计了一个“像素探险队”主题的8位像素动画，模拟障碍物排序、路径计算和状态转移的过程。
</visualization_intro>

  * **动画演示主题**：`像素探险队的网格冒险`

  * **核心演示内容**：展示障碍物排序过程、`dp`数组的计算逻辑（初始值、减去前驱贡献），以及最终路径数的生成。

  * **设计思路简述**：采用8位像素风格（如FC红白机画面），用不同颜色标记障碍物（红色）、起点（绿色）、终点（金色）。通过动态绘制路径（绿色线条）和数字变化（`dp`值），直观展示状态转移过程。音效方面，每完成一次`dp[i]`的计算，播放“叮”的提示音；最终得到答案时播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        * 屏幕显示像素网格（20×20），起点`(1,1)`为绿色方块，终点`(H,W)`为金色方块，障碍物为红色方块。
        * 控制面板包含“单步执行”“自动播放”“重置”按钮，以及速度滑块（1-10倍速）。

    2.  **障碍物排序**：
        * 红色方块按x、y升序排列，动画中用“滑动”效果将障碍物移动到正确位置，伴随“唰唰”的音效。

    3.  **组合数预处理**：
        * 屏幕右侧显示阶乘数组（`fact[]`）和逆元数组（`inv_fact[]`），用数字逐个填充，背景色渐变（从灰到绿）表示计算完成。

    4.  **动态规划计算**：
        * 当前处理障碍物`i`（用黄色边框高亮），显示其坐标`(x,y)`。
        * 初始值`C(x+y-2, x-1)`以数字形式从起点“飞”到`dp[i]`位置，伴随“咻”的音效。
        * 遍历前驱障碍物`j`（用蓝色边框高亮），若`j`在`i`左上方，显示`dp[j] * C(dx+dy, dx)`的计算过程（数字相乘），结果从`j`“飞”到`i`并减去，`dp[i]`的值更新（颜色从红变绿表示完成）。

    5.  **最终结果**：
        * 终点`dp[N]`的数字用金色高亮，播放胜利音效（如“啦~啦~”），并显示“路径数为：XXX”。

  * **旁白提示**：
      * （排序时）“障碍物需要按x和y升序排列，确保处理顺序正确！”
      * （计算初始值时）“这里用组合数算出无障碍时的路径数，比如从起点到当前障碍物需要走x+y-2步，选x-1步向下~”
      * （状态转移时）“现在要减去所有前驱障碍物的贡献，这些路径已经被前面的`dp[j]`计算过啦！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到动态规划如何逐步排除障碍物的影响，最终得到正确的路径数。像素风格和音效设计让复杂的算法过程变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 动态规划+组合数学的方法不仅适用于网格路径计数，还可用于：
        1. **带权路径计数**：路径有不同权重，需计算总权重和（如“上学路线”问题）。
        2. **多维网格问题**：扩展到三维或更高维网格（需调整组合数公式）。
        3. **限制条件路径**：如限制某些方向不能走，或必须经过某些点（通过容斥调整状态转移）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1006** - `传纸条`
        * 🗣️ **推荐理由**：经典的二维动态规划问题，需处理两条路径的状态转移，巩固动态规划思维。
    2.  **洛谷 P3811** - `【模板】组合数问题`
        * 🗣️ **推荐理由**：练习组合数的预处理和快速计算，为解决类似问题打基础。
    3.  **洛谷 CF559C** - `Gerald and Giant Chess`
        * 🗣️ **推荐理由**：与本题高度相似（带障碍物的网格路径计数），但障碍物更多，需优化动态规划实现，适合进阶练习。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：“预处理阶乘时需注意范围，H+W最大为2e5，所以阶乘数组要开到2e5+10，否则会越界。”
</insights_intro>

> **参考经验 (来自作者GaryH)**：“在预处理阶乘和逆元时，一开始忘记将数组大小设为H+W的最大值，导致运行时越界报错。后来检查发现，H和W最大为1e5，所以H+W最大为2e5，阶乘数组需要预处理到2e5+10。”

> **点评**：这位作者的经验提醒我们，预处理数组的大小必须覆盖所有可能的输入范围。在组合数问题中，阶乘数组的大小通常由问题中的最大步数（如H+W）决定，需提前计算并预留足够空间。这是避免运行时错误的关键技巧。

-----

<conclusion>
本次关于“Grid 2”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解动态规划与组合数学的结合应用。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：155.46秒
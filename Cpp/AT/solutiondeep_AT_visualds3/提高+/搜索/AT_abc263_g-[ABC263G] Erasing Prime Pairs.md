# 题目信息

# [ABC263G] Erasing Prime Pairs

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc263/tasks/abc263_g

黒板に $ N $ 種類の整数が書かれています。 $ i $ 種類目の整数は $ A_i $ で、書かれている個数は $ B_i $ 個です。

あなたは次の操作を可能な限り繰り返すことができます。

- 黒板に書かれている $ 2 $ 個の整数 $ x,y $ であって、$ x+y $ が素数であるものを選ぶ。 選んだ $ 2 $ 個の整数を黒板から消す。

操作を最大で何回行えるか求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100 $
- $ 1\ \leq\ A_i\ \leq\ 10^7 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $
- $ A_i $ は全て異なる
- 入力は全て整数

### Sample Explanation 1

$ 2\ +\ 3\ =\ 5 $ であり、$ 5 $ は素数なので、$ 2 $ と $ 3 $ を選んで消す操作が行えます。また、それ以外の操作は行えません。 $ 2 $ は $ 4 $ 個、 $ 3 $ は $ 3 $ 個あるので、操作を $ 3 $ 回行うことができます。

### Sample Explanation 2

$ 1+\ 1\ =\ 2 $ であり、$ 2 $ は素数なので、$ 1 $ と $ 1 $ を選んで消す操作が行えます。$ 1 $ は $ 4 $ 個あるので、操作を $ 2 $ 回行うことができます。

## 样例 #1

### 输入

```
3

3 3

2 4

6 2```

### 输出

```
3```

## 样例 #2

### 输入

```
1

1 4```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：Erasing Prime Pairs 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`网络流建模`与`二分图匹配`

🗣️ **初步分析**：
> 本题的核心是将数字配对问题转化为图论模型。想象数字们是舞池中的舞者，奇数在左边，偶数在右边（1是奇数但可以和自己跳舞）。只有当两个数字的和是质数时才能配对跳舞（即消去）。网络流算法就像智能匹配系统，计算最大匹配数。
>
> - **核心难点**：特殊处理1+1=2的情况，避免影响其他配对
> - **算法流程**：1) 建二分图（奇→偶连边）；2) 跑网络流；3) 单独处理1的配对
> - **可视化设计**：用像素风舞池模拟配对过程，奇数为蓝方偶数为红方。当配对成功时播放8bit音效，1+1配对时显示特殊闪光特效。高亮当前配对数字和流量变化。

---

## 2. 精选优质题解参考

**题解一：liangbowen（最小费用流）**
* **点评**：思路创新性地使用最小费用流处理1的配对问题。代码结构清晰（s/t节点定义明确），关键变量`cost`精准统计1的消耗量。算法亮点在于通过费用控制最小化1的消耗，最后巧妙利用剩余1的数量计算额外配对。边界处理严谨，可直接用于竞赛。

**题解二：rizynvu（两阶段最大流）**
* **点评**：采用分阶段网络流解决核心问题。首次建图排除1保证最优匹配，二次建图加入1处理特殊配对。代码中`Dinic()`函数封装规范，残量网络处理正确。亮点在于清晰分离普通配对和特殊配对，避免1干扰其他匹配。

**题解三：Take_A_Single_6（两阶段最大流）**
* **点评**：实现简洁高效，变量命名直观（如`ans`/`flow`）。关键优化在于精准清空1相关边（`e[i].val=e[i^1].val=0`）。亮点是完整保持残量网络状态，二次增流时直接利用已有流量结果。

---

## 3. 核心难点辨析与解题策略

1.  **特殊数字1的处理**
    * **分析**：1既能与其他数配对（1+偶数），又能和自己配对（1+1）。优质解法通过最小费用流或分阶段网络流优先保证高价值匹配
    * 💡 **学习笔记**：特殊元素应单独处理，避免破坏整体匹配最优性

2.  **质数配对的二分图建模**
    * **分析**：利用"质数=奇+偶"(除2)的特性构建二分图。左部为奇数，右部为偶数，连边条件为a_i+a_j∈P
    * 💡 **学习笔记**：将数学特性转化为图结构是算法设计的关键突破口

3.  **网络流边权设计**
    * **分析**：源点→奇数点的边权为b_i（可用数量），奇数→偶数边权为∞（可无限配对），偶数→汇点边权为b_i
    * 💡 **学习笔记**：合理设置∞边权可避免冗余约束，简化问题

### ✨ 解题技巧总结
- **技巧1：分阶段处理** - 先解决标准匹配，再处理特殊情况
- **技巧2：残量网络利用** - 二次增流时复用已有流量状态
- **技巧3：数学特性转化** - 将数字奇偶性转化为二分图模型

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF = 1e18;

struct Network {
    // 网络流实现(以Dinic为例)
    // ...
};

int main() {
    int n; cin >> n;
    vector<int> a(n), b(n);
    for(int i=0; i<n; i++) cin >> a[i] >> b[i];
    
    Network flow(n+2, 0, n+1); // S=0, T=n+1
    
    // 第一阶段：构建二分图（排除1）
    for(int i=0; i<n; i++) {
        if(a[i] == 1) continue;  // 暂不处理1
        if(a[i] % 2) flow.add(0, i+1, b[i]); // 奇数→S
        else flow.add(i+1, n+1, b[i]);       // 偶数→T
    }
    
    // 添加奇偶配对边
    for(int i=0; i<n; i++) {
        if(a[i] % 2 == 0 || a[i]==1) continue;
        for(int j=0; j<n; j++) {
            if(a[j] % 2 || isPrime(a[i]+a[j])) 
                flow.add(i+1, j+1, INF);
        }
    }
    
    ll ans = flow.calc();
    
    // 第二阶段：加入1的配对
    // ...（具体实现因解法而异）
    
    cout << ans + left1/2; // 总操作数
}
```

**题解一核心代码片段**
```cpp
// 最小费用流处理1的配对
add(S, i, cnt[i], val[i]==1); // 关键费用设置
EK(flow, cost); // 执行费用流
ans = flow + (cnt1 - cost)/2; // 最终结果
```
**学习笔记**：费用流中特殊边的成本设置可精准控制资源消耗

**题解二核心代码片段**
```cpp
// 两阶段网络流
ans = Dinic(); // 第一阶段（不含1）
add(S, one_node, b[one]); // 加入1
ans += Dinic(); // 第二阶段
ans += (b[one] - flow1) / 2; // 剩余1配对
```
**学习笔记**：分阶段处理确保各匹配类型独立优化

---

## 5. 算法可视化：像素动画演示

* **主题**：8-bit舞池配对模拟
* **核心演示**：  
  ![像素演示](https://via.placeholder.com/400x200?text=Bipartite+Matching+Visual)  
  1. 初始化像素网格：蓝方（奇数）左列，红方（偶数）右列
  2. 配对高亮：当数字配对时，两格像素闪烁黄色并播放"叮"声
  3. 流量显示：顶部条形图显示当前匹配数/剩余数字
  4. 特殊1处理：1的格子显示为紫色，1+1配对时触发闪光特效
  5. 控制面板：步进/暂停/调速滑块，实时显示代码执行位置

* **交互设计**：
  - 成功配对：播放上升音阶
  - 1+1配对：触发像素烟花特效
  - 错误配对：播放低沉警示音

---

## 6. 拓展练习与相似问题思考

1.  **洛谷P3386** - 二分图最大匹配
    * **推荐理由**：巩固二分图建模基础
2.  **洛谷P3254** - 圆桌问题
    * **推荐理由**：网络流经典问题，强化流量分配思维
3.  **洛谷P2761** - 软件补丁问题
    * **推荐理由**：特殊约束下的状态转移，提升建模灵活性

---

## 7. 学习心得与经验分享

> **rizynvu的调试经验**："在残量网络处理时，最初错误清空了所有源点边，导致结果错误。通过打印中间流量值才发现问题"
>
> **Kay点评**：这提醒我们网络流调试时，应逐阶段检查边权变化。建议使用可视化工具或打印残量矩阵验证

---

通过本指南，希望大家掌握网络流建模的核心技巧：将实际问题转化为图结构，并合理处理特殊约束。记住，好的算法设计如同编排舞蹈——需要兼顾整体规则与特殊个体的需求！💪

---
处理用时：156.99秒
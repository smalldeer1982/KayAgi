# 题目信息

# [ABC020D] LCM Rush

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc020/tasks/abc020_d

$ 2 $ つの正整数 $ a, $ $ b $ の最小公倍数 $ LCM(a,\ b) $ とは、 $ a $ の倍数であり、かつ $ b $ の倍数でもあるような正整数のうち最小のものをいいます。

$ 2 $ つの正整数 $ N, $ $ K $ が与えられます。 $ 1 $ 以上 $ N $ 以下のすべての整数 $ i $ について $ LCM(i,\ K) $ を足しあわせたものを $ 1,000,000,007 $ で割った余りを求めてください。

## 说明/提示

### 部分点

この問題は AtCoder Beginner Contest の問題としては非常に難しいため、通常 ($ 100 $ 点満点) と異なり $ 101 $ 点満点であり、部分点が設定されている。

- $ 5 $ 点分のテストケースは $ 1 $ $ ≦ $ $ N, $ $ K $ $ ≦ $ $ 100 $ を満たす。
- 別の $ 10 $ 点分のテストケースは $ 1 $ $ ≦ $ $ N $ $ ≦ $ $ 10^4, $ $ 1 $ $ ≦ $ $ K $ $ ≦ $ $ 100 $ を満たす。
- さらに別の $ 85 $ 点分のテストケースは $ 1 $ $ ≦ $ $ N $ $ ≦ $ $ 10^9, $ $ 1 $ $ ≦ $ $ K $ $ ≦ $ $ 100 $ を満たす。以上で合計 $ 100 $ 点となる。

### Sample Explanation 1

$ LCM(1,\ 2)\ +\ LCM(2,\ 2)\ +\ LCM(3,\ 2)\ +\ LCM(4,\ 2)\ =\ 2\ +\ 2\ +\ 6\ +\ 4\ =\ 14 $ となります。

## 样例 #1

### 输入

```
4 2```

### 输出

```
14```

## 样例 #2

### 输入

```
10000 100```

### 输出

```
865504986```

## 样例 #3

### 输入

```
1000000000 90```

### 输出

```
50001213```

## 样例 #4

### 输入

```
1000000000 999999900```

### 输出

```
231285006```

# AI分析结果


# 💡 Kay的C++算法解析：ABC020D LCM Rush 深入学习指南 💡

**引言**  
今天我们来分析AtCoder经典题目「LCM Rush」。这道题要求计算所有$i$（$1≤i≤N$）与$K$的最小公倍数之和。本指南将帮助你理解核心数学推导、优化技巧，并通过生动的像素动画演示算法执行过程。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学推导与莫比乌斯反演`

🗣️ **初步分析**  
> 解决本题的关键在于**数学变换与因子枚举**。想象你在破解一个数学宝藏箱：  
> 1. 将LCM转化为GCD：$\text{lcm}(i,K)=\frac{iK}{\gcd(i,K)}$  
> 2. 枚举$K$的因子$d$作为$\gcd$，问题转化为计算与$K/d$互质的$i$之和  
> 3. 通过**莫比乌斯反演**解决互质求和问题  
>  
> **可视化设计**：采用8位像素风格，设计"因子探险"游戏。主角在因子森林中探索：  
> - 绿色方块：正贡献（$\mu>0$），音效清脆  
> - 红色方块：负贡献（$\mu<0$），音效低沉  
> - 黄色闪光：完成子问题计算  
> 控制面板支持单步执行和自动播放，速度可调。

---

## 2. 精选优质题解参考

### 题解一：EnofTaiPeople
* **点评**  
  思路清晰推导完整，独创"魔力筛"高效预处理莫比乌斯函数。代码规范：  
  - 变量名含义明确（如`mu[]`存储莫比乌斯函数）  
  - 边界处理严谨（负数取模修正）  
  - 时间复杂度$O(d(K)^2)$完美契合数据范围  
  亮点：**魔力筛技术**将埃氏筛与狄利克雷卷积结合，提升预处理效率。

### 题解二：EastPorridge
* **点评**  
  标准线性筛预处理，代码结构工整。亮点在于：  
  - 函数封装合理（`f()`处理互质求和）  
  - 数论分块思想降低复杂度  
  - 取模运算严谨（`(res%p+p)%p`避免负数）  
  实践价值高，可直接用于竞赛场景。

### 题解三：Mikefeng
* **点评**  
  推导过程简洁明了，代码模块化优秀：  
  - 独立`get_mu()`函数处理大小规模数据  
  - 向量存储因子提高可读性  
  - 等差数列求和公式优化计算  
  特别适合初学者理解莫比乌斯反演的应用场景。

---

## 3. 核心难点辨析与解题策略

1. **难点：LCM求和转化为可计算形式**  
   *分析*：直接计算LCM不可行，需利用$\text{lcm}(a,b)=\frac{ab}{\gcd(a,b)}$转化，并枚举$K$的因子$d$作为$\gcd$。  
   💡 **学习笔记**：数学变换是数论问题的破题关键。

2. **难点：互质求和的高效计算**  
   *分析*：定义$f(n,m)=\sum_{i=1}^n i·[\gcd(i,m)=1]$，通过莫比乌斯反演得：  
   $f(n,m)=\sum_{d|m}\mu(d)·d·\frac{\lfloor n/d\rfloor(\lfloor n/d\rfloor+1)}{2}$  
   💡 **学习笔记**：莫比乌斯函数$\mu(d)$的本质是容斥系数。

3. **难点：大范围莫比乌斯函数计算**  
   *分析*：$K≤10^9$导致部分因子超出预处理范围。  
   *解决方案*：  
   - 预处理$≤5×10^6$的$\mu$值  
   - 大数通过分解质因数现场计算  
   💡 **学习笔记**：预处理+暴力分解是数论函数计算的黄金组合。

### ✨ 解题技巧总结
- **因子分解术**：$O(\sqrt{K})$时间枚举因子，`vector`存储优化  
- **模块化编程**：分离互质求和函数，提高代码复用性  
- **负数取模修正**：`ans = (ans%MOD + MOD)%MOD`避免负值  
- **等差数列优化**：用公式$\frac{n(n+1)}{2}$替代循环求和

---

## 4. C++核心代码实现赏析

### 通用核心实现
```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;
const int N = 5000000, MOD = 1e9+7;

int mu[N+10], prime[N+10], cnt;
bool vis[N+10];

void init() { // 线性筛预处理莫比乌斯函数
    mu[1] = 1;
    for (int i = 2; i <= N; i++) {
        if (!vis[i]) prime[++cnt] = i, mu[i] = -1;
        for (int j = 1; j <= cnt && i*prime[j] <= N; j++) {
            vis[i*prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i*prime[j]] = 0; break;
            } else mu[i*prime[j]] = -mu[i];
        }
    }
}

int get_mu(int x) { // 大数暴力计算莫比乌斯函数
    if (x <= N) return mu[x];
    int cnt = 0, tmp = x;
    for (int i = 1; prime[i]*prime[i] <= tmp; i++) {
        if (tmp % prime[i]) continue;
        int t = 0;
        while (tmp % prime[i] == 0) t++, tmp /= prime[i];
        if (t > 1) return 0;
        cnt++;
    }
    if (tmp > 1) cnt++;
    return (cnt & 1) ? -1 : 1;
}

ll S(ll n) { // 等差数列求和
    return n % MOD * (n + 1) % MOD * 500000004 % MOD; // 2的逆元
}

int main() {
    init();
    ll n, k, ans = 0;
    cin >> n >> k;
    vector<ll> divs;
    
    // 枚举k的因子
    for (ll i = 1; i*i <= k; i++) {
        if (k % i) continue;
        divs.push_back(i);
        if (i != k/i) divs.push_back(k/i);
    }
    
    for (ll d : divs) { // 枚举因子d
        ll sum_f = 0;
        ll m = n / d, kd = k / d;
        
        // 枚举kd的因子t
        for (ll t : divs) {
            if (kd % t || t > kd) continue;
            ll mu_t = get_mu(t);
            if (!mu_t) continue;
            sum_f = (sum_f + mu_t * t % MOD * S(m / t)) % MOD;
        }
        ans = (ans + sum_f) % MOD;
    }
    ans = (ans % MOD + MOD) % MOD; // 负数修正
    ans = ans * k % MOD;
    cout << ans << endl;
}
```

### 代码解读概要
1. **预处理阶段**：`init()`线性筛预处理$≤5×10^6$的$\mu$值  
2. **因子枚举**：$O(\sqrt{K})$时间获取$K$的所有因子存入`divs`  
3. **双重循环**：外层枚举$\gcd$因子$d$，内层枚举互质求和参数$t$  
4. **贡献计算**：$\mu(t)×t×\text{等差数列和}$，注意跳过非法因子  
5. **最终修正**：乘以$K$并确保结果非负

### 题解片段赏析

**题解一：魔力筛技术**  
```cpp
mu[1] = 1;
for (int x = 2; x <= n; ++x) {
    if (vs[x]) continue;
    p[++pt] = x;
    for (int y = n/x; y; --y)
        vs[x*y] = 1, (mu[x*y] -= mu[y]) %= M;
}
```
> **亮点**：埃氏筛与狄利克雷卷积的完美融合  
> **解读**：对每个未标记数$x$（必为质数），枚举其倍数$x×y$，通过`mu[x*y] -= mu[y]`实现卷积更新  
> **学习笔记**：此技术可扩展至其他积性函数的快速预处理

**题解二：互质求和函数**  
```cpp
ll f(ll n, ll m) {
    ll res = 0;
    for (int x : divs) {
        if (x > m) break;
        if (m % x) continue;
        res = (res + x * get_mu(x) % MOD * S(n/x)) % MOD;
    }
    return res;
}
```
> **亮点**：优雅的因子遍历与提前终止  
> **解读**：仅枚举$m$的因子，当`x > m`时立即终止循环  
> **学习笔记**：因子排序后遍历可显著提升效率

**题解三：因子分解术**  
```cpp
vector<ll> v;
for (ll i = 1; i*i <= k; i++) {
    if (k % i == 0) {
        v.push_back(i);
        if (i != k/i) v.push_back(k/i);
    }
}
sort(v.begin(), v.end());
```
> **亮点**：标准$O(\sqrt{K})$因子枚举范式  
> **解读**：$i$从$1$遍历到$\sqrt{K}$，同时收集$i$与$k/i$  
> **学习笔记**：排序后便于后续二分查找等操作

---

## 5. 算法可视化：像素动画演示

### 主题：因子森林探险
**设计思路**  
采用8位像素风格，将因子枚举过程转化为探险游戏：  
- 🌳 **场景设计**：左侧为$K$的因子树（像素方块），右侧为计算面板  
- 🧙 **角色控制**：像素小人逐层探索因子洞穴（$d→t$）  
- 🎨 **视觉编码**：  
  - 绿色方块：$\mu>0$的正贡献  
  - 红色方块：$\mu<0$的负贡献  
  - 金色闪光：完成子问题计算  

### 动画帧步骤
1. **初始化场景**  
   - 背景：16色调色板，复古森林风格  
   - 控制面板：开始/暂停、单步、速度滑块（1x-5x）  
   - BGM：8-bit循环音乐  

2. **外层循环（枚举$d$）**  
   ```markdown
   [小人走到因子d的方块] 
   → 播放脚步声效
   → 方块高亮闪烁（蓝色边框）
   → 显示当前d值
   ```

3. **进入洞穴（枚举$t$）**  
   ```markdown
   [洞穴内显示K/d的因子树]
   → 小人移动到t位置
   → 计算面板显示：μ(t)·t·S(floor(n/(dt)))
   → 根据μ(t)正负播放不同音效（正：↑叮，负：↓咚）
   ```

4. **贡献可视化**  
   - 正贡献：绿色像素块从洞穴飞出→右侧累加器  
   - 负贡献：红色像素块飞出→累加器数值减少  
   - 累计贡献：右侧面板实时更新  

5. **AI自动演示模式**  
   - 角色自动遍历所有因子路径  
   - 速度滑块控制探险速度  
   - 完成时播放胜利音效+烟花特效  

### 技术实现要点
- **Canvas绘制**：网格绘制因子树，精灵图动画  
- **音效触发**：Web Audio API绑定关键事件  
- **状态同步**：当前计算行代码高亮显示在侧边栏  

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
最小公倍数与因子枚举技巧还可用于：  
1. 多集合的LCM计算  
2. 带LCM的计数问题  
3. 互质集合的统计问题  

### 洛谷推荐练习
1. **P1891 疯狂LCM**  
   → 同类型LCM求和问题，强化因子分解技巧  
2. **P2303 Longge的问题**  
   → GCD求和变体，训练因子枚举思维  
3. **P2398 GCD SUM**  
   → 二维GCD求和，拓展莫比乌斯反演应用  

---

## 7. 学习心得与经验分享

> **来自优质题解的启示**：  
> - "魔力筛的核心是逆向思维：用已知小因子更新大因子"  
> - "处理10^9规模数据时，O(√n)算法是生命线"  
> - "负数取模修正是数论题的隐藏陷阱"  
>  
> **Kay的总结**：  
> 调试数论题的核心技巧：  
> 1. 小数据验证（如N,K=100）  
> 2. 中间变量打印（因子列表、μ值）  
> 3. 边界测试（K=1, N=1）  

---

**结语**  
通过本次分析，我们深入理解了LCM求和的数学本质与高效实现方法。记住，编程能力=数学思维+工程实践+调试技巧。下次探险再见！🚀

---
处理用时：241.65秒
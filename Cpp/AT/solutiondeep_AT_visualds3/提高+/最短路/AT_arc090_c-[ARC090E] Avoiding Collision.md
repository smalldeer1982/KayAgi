# 题目信息

# [ARC090E] Avoiding Collision

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc090/tasks/arc090_c

$ N $ 頂点 $ M $ 辺からなるグラフがあり、このグラフの上に高橋くんと青木くんがいます。

グラフの $ i $ 番目の辺は頂点 $ U_i $ と頂点 $ V_i $ を結んでいます。 この辺を通るのにかかる時間は、通る人 (高橋くんまたは青木くん) によらず、また通る方向によらず、$ D_i $ 分です。

高橋くんは頂点 $ S $ を、青木くんは頂点 $ T $ を同時に出発し、それぞれ頂点 $ T $ および頂点 $ S $ へ最短の時間で移動します。 二人の最短路の選び方の組であって、移動の途中で二人が (辺または頂点上で) 出会うことのないようなものの個数を $ 10^9\ +\ 7 $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 100,000 $
- $ 1\ \leq\ M\ \leq\ 200,000 $
- $ 1\ \leq\ S,\ T\ \leq\ N $
- $ S\ \neq\ T $
- $ 1\ \leq\ U_i,\ V_i\ \leq\ N $ ($ 1\ \leq\ i\ \leq\ M $)
- $ 1\ \leq\ D_i\ \leq\ 10^9 $ ($ 1\ \leq\ i\ \leq\ M $)
- $ i\ \neq\ j $ のとき、$ (U_i,\ V_i)\ \neq\ (U_j,\ V_j) $ かつ $ (U_i,\ V_i)\ \neq\ (V_j,\ U_j) $
- $ U_i\ \neq\ V_i $ ($ 1\ \leq\ i\ \leq\ M $)
- $ D_i $ は整数である
- 与えられるグラフは連結である

### Sample Explanation 1

条件を満たす最短路の選び方は以下の 2 通りあります。 - 高橋くんが頂点 $ 1\ \rightarrow\ 2\ \rightarrow\ 3 $ という経路で、青木くんが頂点 $ 3\ \rightarrow\ 4\ \rightarrow\ 1 $ という経路で移動する。 - 高橋くんが頂点 $ 1\ \rightarrow\ 4\ \rightarrow\ 3 $ という経路で、青木くんが頂点 $ 3\ \rightarrow\ 2\ \rightarrow\ 1 $ という経路で移動する。

## 样例 #1

### 输入

```
4 4

1 3

1 2 1

2 3 1

3 4 1

4 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

1 3

1 2 1

2 3 1

3 1 2```

### 输出

```
2```

## 样例 #3

### 输入

```
3 3

1 3

1 2 1

2 3 1

3 1 2```

### 输出

```
2```

## 样例 #4

### 输入

```
8 13

4 2

7 3 9

6 2 3

1 6 4

7 6 9

3 8 9

1 2 2

2 8 12

8 6 9

2 5 5

4 2 18

5 3 7

5 1 515371567

4 8 6```

### 输出

```
6```

# AI分析结果


# 💡 Kay的C++算法解析：[ARC090E] Avoiding Collision 深入学习指南 💡

<introduction>
今天我们来分析「避免碰撞」这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过本指南，你将学会如何利用最短路算法和容斥原理解决复杂路径规划问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`最短路计数` + `容斥原理`

🗣️ **初步分析**：
> 解决这道题的关键在于运用「最短路计数」和「容斥原理」。想象两个探险家分别从山谷两侧出发，以最短路径相向而行。我们需要计算他们不会在途中相遇的方案数。就像规划两条不会交叉的登山路线，既要保证各自是最短路径，又要避免在任何地点或路径上相遇。
> 
> - 核心思路：总方案数（两人都走最短路）减去相遇方案数（在点或边上相遇）
> - 算法流程：1) 计算从S/T出发的最短路和路径数；2) 用容斥原理减去相遇方案
> - 可视化设计：在像素动画中，用蓝色/红色光点表示两人移动轨迹，当满足相遇条件时触发闪光特效。边相遇场景将展示两人在像素路径上"擦肩而过"的动画，配合8-bit音效增强理解。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法优化等维度，我精选了以下高质量题解：

**题解一（小粉兔）**
* **点评**：思路清晰度极佳，对容斥原理的推导直白易懂。代码规范性强，变量名`d1/g1`和`d2/g2`分别表示S/T出发的数据，含义明确。算法有效性高，在Dijkstra松弛过程中同步更新路径数，时间复杂度O((n+m)logn)。实践价值突出，完整处理了负权边和取模边界问题。亮点：对点/边相遇的分类讨论完整，推导过程严谨。

**题解二（DengDuck）**
* **点评**：代码简洁性突出，主函数仅50行完成核心逻辑。变量命名简洁但含义清晰（dis/del表示距离/路径数）。算法实现巧妙，在边相遇判断中重用同一条边的双向处理。实践参考性强，适合竞赛快速编码。亮点：正难则反的解题思路体现良好算法直觉。

**题解三（NaVi_Awson）**
* **点评**：边界处理严谨，对边相遇条件`d1[u]+w>d2[v]`的解释深入。代码结构工整，模块化设计便于调试。算法优化到位，使用优先队列确保最短路效率。亮点：将相遇问题转化为数学约束，提升抽象思维能力。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点：

1.  **最短路计数更新逻辑**
    * **分析**：在Dijkstra松弛过程中，当找到更短路径时重置计数器，当路径等长时累加计数器。优质题解通过`if(dis[v]>dis[u]+w)...else if(...==...)`结构实现。
    * 💡 **学习笔记**：路径计数需同步距离更新，类似动态规划的"状态转移"。

2.  **点/边相遇的判定条件**
    * **分析**：点相遇要求：①d1[u]+d2[u]=总长 ②d1[u]=d2[u]；边相遇要求：①d1[u]+w+d2[v]=总长 ②d1[u]+w>d2[v]（避免在点相遇）。题解通过遍历所有点和边实现判定。
    * 💡 **学习笔记**：边相遇的条件②确保两人在边上擦肩而过而非在顶点相遇。

3.  **容斥的数学转化**
    * **分析**：将"不相遇方案"转化为"总方案-点相遇-边相遇"。关键在保证相遇方案不重不漏，特别是无向边需正反两次判断。
    * 💡 **学习笔记**：容斥时注意取模运算：(a-b)%mod需转为(a%mod-b%mod+mod)%mod。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题的分析，总结以下通用技巧：
</summary_best_practices>
-   **正难则反**：当直接求解困难时（如不相遇方案），考虑用全集减子集（容斥原理）
-   **同步计数法**：在最短路径算法中同步更新路径数量，避免二次遍历
-   **边界音效化**：编写代码时，对边界条件（如起点计数=1）添加注释"提示音"，调试更高效
-   **模块化验证**：将点相遇/边相遇拆分为独立函数，单元测试后再整合

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现：

**本题通用核心C++实现参考**
* **说明**：综合小粉兔和DengDuck的解法，优化变量命名和边界处理
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5, M=2e5+5;
const ll INF=1e18, Mod=1e9+7;
vector<pair<int,int>> G[N];
ll d1[N], d2[N], g1[N], g2[N];
int n,m,S,T;

void dijk(int s, ll* dis, ll* cnt) {
    priority_queue<pair<ll,int>> pq;
    fill(dis+1, dis+n+1, INF);
    dis[s]=0; cnt[s]=1;
    pq.push({0,s});
    while(!pq.empty()) {
        auto [d,u] = pq.top(); pq.pop();
        if(-d != dis[u]) continue;
        for(auto [v,w] : G[u]) {
            if(dis[v] == dis[u]+w) 
                (cnt[v] += cnt[u]) %= Mod;
            else if(dis[v] > dis[u]+w) {
                dis[v] = dis[u]+w;
                cnt[v] = cnt[u];
                pq.push({-dis[v], v});
            }
        }
    }
}

int main() {
    cin>>n>>m>>S>>T;
    while(m--) {
        int u,v,w; cin>>u>>v>>w;
        G[u].push_back({v,w});
        G[v].push_back({u,w});
    }
    dijk(S, d1, g1);
    dijk(T, d2, g2);
    ll total = g1[T] * g1[T] % Mod;
    ll dist = d1[T];

    // 点相遇容斥
    for(int i=1; i<=n; i++) {
        if(d1[i]+d2[i]==dist && d1[i]==d2[i]) 
            total = (total - g1[i]*g1[i]%Mod *g2[i]%Mod *g2[i]%Mod + Mod) % Mod;
    }
    // 边相遇容斥
    for(int u=1; u<=n; u++) {
        for(auto [v,w] : G[u]) {
            if(d1[u]+w+d2[v]==dist && d1[u]+w>d2[v] && d2[v]+w>d1[u]) 
                total = (total - g1[u]*g1[u]%Mod *g2[v]%Mod *g2[v]%Mod + Mod) % Mod;
        }
    }
    cout<<total;
}
```
* **代码解读概要**：
  - `dijk()`封装最短路计数，使用优先队列优化
  - 主函数：建图→计算S/T出发的数据→总方案减点/边相遇方案
  - 容斥部分：遍历点（检查中点条件）和边（检查边相遇条件）

---
<code_intro_selected>
精选题解片段赏析：

**题解一（小粉兔）片段**
```cpp
// 点相遇判断
if(d1[i]+d2[i]==Dist && d1[i]==d2[i])
    Ans=(Ans-g1[i]*g1[i]%Mod*g2[i]%Mod*g2[i]%Mod)%Mod;
```
* **亮点**：数学公式直译为代码，清晰体现容斥思想
* **学习笔记**：点相遇方案数为(g1[i]*g2[i])²，平方因两人独立选择路径

**题解二（DengDuck）片段**
```cpp
// 边相遇双向处理
if(dis[u]+w+dis2[v]==dis1[t]&&dis[u]+w>dis2[v]&&dis2[v]+w>dis[u])
    ans=(ans-...);
swap(u,v); // 重用同一条边的反向判断
```
* **亮点**：通过swap避免重复写反向逻辑，代码复用性高
* **学习笔记**：无向图需考虑边的双向通行特性

**题解三（NaVi_Awson）片段**
```cpp
// 最短路计数更新
if(dis[v] > dis[u]+w) 
    cnt[v] = cnt[u]; // 重置计数
else if(dis[v] == dis[u]+w) 
    cnt[v] = (cnt[v]+cnt[u]) % Mod; // 累加路径
```
* **亮点**：严格遵循Dijkstra的松弛原则，计数更新与距离同步
* **学习笔记**：类比动态规划——找到更优解时重置状态，找到等价解时合并状态

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观理解最短路相遇问题，我设计了像素化动画方案，模仿经典8-bit游戏风格：

  * **主题**："山谷探险家"——两位像素小人（蓝/红）从S/T出发，沿最短路向目标移动
  * **核心演示**：Dijkstra算法执行过程 + 点/边相遇判定逻辑
  * **设计思路**：像素风格降低理解门槛，游戏化元素增强参与感。通过关卡设计（点相遇关/边相遇关）分解复杂概念

  * **动画帧步骤**：
    1. **场景初始化**：FC风格网格地图，顶点为彩色像素方块（S=绿色，T=红色，普通点=灰色）
    2. **算法执行**：蓝红小人逐帧移动，当前处理点闪烁黄光，队列以像素方块堆动态展示
    3. **相遇检测**：
       - 点相遇：当两人坐标重合且`d1[u]=d2[u]`时，触发爆炸特效+警报音
       - 边相遇：当两人相向进入同一边时，边线闪烁红光，播放"叮"音效
    4. **交互控制**：
       - 控制面板：开始/暂停/单步执行按钮 + 速度滑块
       - 模式切换：独立查看"总方案"/"点相遇"/"边相遇"的统计面板
    5. **关卡设计**：
       - 关卡1：仅有一个相遇点 → 理解点相遇条件
       - 关卡2：含一条相遇边 → 理解边相遇不等式约束
       - 关卡3：复杂地图 → 综合应用容斥原理
    6. **信息展示**：
       - 左上角显示：当前路径长度/方案数
       - 代码同步：底部实时高亮执行的C++代码行（如松弛操作/容斥判断）
       - 画外音提示："注意！蓝红路径在此点重合，触发点相遇容斥"

  * **技术实现**：
    - Canvas绘制网格和动画，色块代表顶点/边状态
    - 音效触发：Web Audio API播放8-bit音效（入队声/相遇警报）
    - 自动演示模式：类似贪吃蛇AI，按最优路径逐步推进

<visualization_conclusion>
通过像素动画，抽象的最短路约束转化为可见的移动轨迹，容斥原理通过关卡设计自然呈现，有效提升学习趣味性。
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可进一步挑战以下相似问题：

  * **通用技巧迁移**：
    最短路计数+容斥原理可解决：① 路径不交叉问题 ② 并行任务调度 ③ 网络流中的不相交路径

  * **推荐练习（洛谷）**：
    1. **P1144 最短路计数**  
       🗣️ **推荐理由**：最短路计数的入门题，巩固Dijkstra计数基础
    2. **P1608 路径统计**  
       🗣️ **推荐理由**：带权最短路计数，强化边权处理能力
    3. **P3953 逛公园**  
       🗣️ **推荐理由**：K短路径问题，拓展最短路算法的边界思维

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者分享的调试经验极具参考价值：

> **小粉兔的调试心得**：  
> "我在处理边相遇条件时，最初忽略了无向边的双向判断，导致漏算。通过打印`u->v`和`v->u`的中间变量才发现问题。"

> **Kay的总结**：  
> 多维度验证是调试关键——当算法涉及双向关系时，可：  
> ① 打印正向/反向的中间结果对比  
> ② 构造对称测试用例（如样例1的环状图）  
> ③ 边界测试：单边图/两点一线图

<conclusion>
本次「避免碰撞」的解析就到这里。记住，算法能力的提升在于将复杂问题拆解为可管理的子问题（如点相遇+边相遇）。继续挑战下一座算法高峰吧！💪
</conclusion>

-----

---
处理用时：146.89秒
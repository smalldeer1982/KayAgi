# 题目信息

# [ABC239F] Construct Highway

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc239/tasks/abc239_f

Atcoder 国には $ 1 $ から $ N $ の番号がついた $ N $ 個の街と $ 1 $ から $ M $ の番号がついた $ M $ 個の高速道路があります。  
 高速道路 $ i $ は街 $ A_i $ と街 $ B_i $ を双方向に結んでいます。

国王の高橋君は、新たに $ N-M-1 $ 本の高速道路を建設し、次の $ 2 $ つの条件をともに満たそうとしています。

- すべての街同士は、高速道路をいくつか通って互いに行き来できる
- 各 $ i=1,\ldots,N $ について、街 $ i $ はちょうど $ D_i $ 本の高速道路と直接つながっている

条件を満たすような建設方法が存在するか判定し、存在するなら $ 1 $ つ出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ M\ \lt\ N-1 $
- $ 1\ \leq\ D_i\ \leq\ N-1 $
- $ 1\leq\ A_i\ \lt\ B_i\ \leq\ N $
- $ i\neq\ j $ ならば、$ (A_i,\ B_i)\ \neq\ (A_j,B_j) $
- 入力に含まれる値は全て整数である

### Sample Explanation 1

出力例のように、街 $ 6 $ と$ 2 $、街 $ 5 $ と $ 6 $、街 $ 4 $ と $ 5 $ をそれぞれ結ぶ高速道路を建設すると条件を満たすことができます。 この他にも、例えば 街 $ 6 $ と$ 4 $、街 $ 5 $ と $ 6 $、街 $ 2 $ と $ 5 $ を結ぶような高速道路を建設しても条件を満たすことができます。

## 样例 #1

### 输入

```
6 2

1 2 1 2 2 2

2 3

1 4```

### 输出

```
6 2

5 6

4 5```

## 样例 #2

### 输入

```
5 1

1 1 1 1 4

2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 0

3 3 3 3```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC239F] Construct Highway 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论构造（树的生成） + 并查集应用 + 度数调整技巧  

🗣️ **初步分析**：  
解决“Construct Highway”问题，本质是**在已有边的基础上，构造一棵满足每个节点度数要求的树**（因为最终要加`N-M-1`条边，总边数为`N-1`，恰好是树的边数）。关键在于两点：  
1. **度数合法性**：所有节点的度数之和必须等于`2(N-1)`（树的总边数×2）；  
2. **连通性维护**：用并查集管理已有边的连通块，确保新边不形成环，且最终所有节点连通。  

**核心算法流程**：  
- 第一步：检查度数总和是否合法（`sum(D_i) == 2(N-1)`），否则直接无解；  
- 第二步：用并查集合并已有边的节点，同时减少对应节点的剩余度数（`D_i`减去已有边的数量）；  
- 第三步：分类连通块：  
  - **第一类**：连通块的剩余度数总和为1（即该连通块需要1条新边连接到其他连通块）；  
  - **第二类**：连通块的剩余度数总和≥2（需要多条新边连接）；  
- 第四步：优先用第二类连通块的剩余度数连接第一类连通块（避免形成环），最后处理剩余的第一类连通块（必须恰好2个，否则无解）。  

**可视化设计思路**：  
用**8位像素风格**模拟城市和高速公路：  
- 城市用不同颜色的像素块表示（比如红色代表未连通，绿色代表已连通）；  
- 已有边用灰色线条连接，新边用蓝色线条动态绘制；  
- 剩余度数用数字标注在城市下方，减少时用“-1”动画提示；  
- 连通块合并时，用“闪烁”效果突出显示，并播放“叮”的音效；  
- 无解情况用“红色叉号”和“错误提示音”提醒。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速掌握核心逻辑：
</eval_intro>

**题解一：(来源：OIer rui_er，赞：4)**  
* **点评**：这份题解的思路非常**严谨且全面**，完美覆盖了所有无解情况（比如度数总和不对、剩余度数为负、连通块数量不符等）。代码结构清晰，用并查集维护连通性的逻辑直白，尤其是“分类连通块”的步骤（第一类/第二类）设计巧妙，确保了新边不会形成环。此外，代码中的`nds`数组存储每个连通块的剩余度数点，`nd1`和`nd2`分别管理两类连通块，这种分类处理的方式非常值得学习——它将复杂的图构造问题拆解成了“连接不同类型连通块”的简单步骤，大大降低了思考难度。  

**题解二：(来源：Mirasycle，赞：1)**  
* **点评**：此题解的思路与题解一类似，但用**队列**代替数组管理连通块（`q1`存第一类连通块，`q2`存第二类），代码更简洁。不过，队列的处理逻辑 slightly 抽象（比如`q[z]`存储每个连通块的剩余度数点），对初学者来说可能需要多花时间理解。但它的“度数序”思路（优先处理度数小的节点）值得借鉴，能帮助你更直观地理解“如何避免环”。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于**处理“已有边”与“度数要求”的冲突**，以下是三个核心难点及解决策略：
</difficulty_intro>

1. **难点1：如何处理已有边后的剩余度数？**  
   * **分析**：已有边会占用节点的度数（比如节点`u`和`v`之间有一条边，那么`D_u`和`D_v`都要减1）。如果减后`D_i < 0`，说明已有边超过了度数要求，直接无解。  
   * 💡 **学习笔记**：处理已有边时，一定要及时更新剩余度数，并检查合法性！

2. **难点2：如何分类连通块并优先连接？**  
   * **分析**：第二类连通块（剩余度数≥2）需要“消耗”自己的度数来连接第一类连通块（剩余度数=1），这样才能避免形成环。比如，一个第二类连通块有3个剩余度数，那么它需要连接2个第一类连通块（消耗2个度数），剩下1个度数变成第一类连通块。  
   * 💡 **学习笔记**：分类连通块是为了“有序连接”，优先用多度数的连通块连接少度数的，确保最终能连成一棵树。

3. **难点3：如何处理各种无解情况？**  
   * **分析**：本题的无解情况很多，比如：  
     - 度数总和不等于`2(N-1)`；  
     - 已有边导致某个节点的剩余度数为负；  
     - 第二类连通块连接时没有足够的第一类连通块；  
     - 最后剩余的第一类连通块数量≠2；  
     - 最终图不连通。  
   * 💡 **学习笔记**：写代码前一定要列全所有无解情况，避免遗漏！


### ✨ 解题技巧总结
- **技巧A：并查集的正确使用**：并查集是维护连通性的神器，一定要熟练掌握`find`和`merge`操作；  
- **技巧B：分类处理问题**：将连通块分为两类，将复杂的图构造问题拆解成简单的“连接步骤”；  
- **技巧C：边界条件检查**：每一步操作后都要检查合法性（比如剩余度数是否为负、连通块数量是否符合要求），避免后续错误。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**（来自题解一，逻辑清晰、覆盖所有情况），帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了题解一的思路，完整覆盖了所有无解情况，是解决本题的典型实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <numeric>
  using namespace std;

  const int N = 2e5 + 5;

  int n, m, deg[N];
  vector<int> nds[N], nd1;
  vector<vector<int>> nd2;
  vector<pair<int, int>> ans;

  struct Dsu {
      int fa[N];
      void init(int x) { for (int i = 1; i <= x; i++) fa[i] = i; }
      int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
      bool merge(int x, int y) {
          x = find(x), y = find(y);
          if (x == y) return false;
          fa[x] = y;
          return true;
      }
  } dsu;

  int main() {
      cin >> n >> m;
      for (int i = 1; i <= n; i++) cin >> deg[i];
      if (accumulate(deg + 1, deg + 1 + n, 0LL) != 2LL * (n - 1)) {
          cout << "-1" << endl;
          return 0;
      }
      dsu.init(n);
      for (int i = 1; i <= m; i++) {
          int u, v;
          cin >> u >> v;
          dsu.merge(u, v);
          deg[u]--, deg[v]--;
          if (deg[u] < 0 || deg[v] < 0) {
              cout << "-1" << endl;
              return 0;
          }
      }
      for (int i = 1; i <= n; i++) {
          for (int j = 1; j <= deg[i]; j++) {
              nds[dsu.find(i)].push_back(i);
          }
      }
      for (int i = 1; i <= n; i++) {
          if (nds[i].size() == 1) nd1.push_back(nds[i][0]);
          if (nds[i].size() > 1) nd2.push_back(nds[i]);
      }
      for (auto& block : nd2) {
          for (int j = 1; j < block.size(); j++) {
              if (nd1.empty()) {
                  cout << "-1" << endl;
                  return 0;
              }
              dsu.merge(block[j], nd1.back());
              ans.emplace_back(block[j], nd1.back());
              nd1.pop_back();
          }
          nd1.push_back(block[0]);
      }
      if (nd1.size() != 2) {
          cout << "-1" << endl;
          return 0;
      }
      dsu.merge(nd1[0], nd1[1]);
      ans.emplace_back(nd1[0], nd1[1]);
      for (int i = 1; i <= n; i++) {
          if (!dsu.same(i, 1)) {
              cout << "-1" << endl;
              return 0;
          }
      }
      for (auto& [u, v] : ans) {
          cout << u << " " << v << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取输入并检查度数总和；  
  2. 用并查集合并已有边，更新剩余度数；  
  3. 分类连通块（`nd1`存第一类，`nd2`存第二类）；  
  4. 连接第二类连通块与第一类连通块；  
  5. 处理剩余的第一类连通块（必须恰好2个）；  
  6. 检查最终连通性，输出结果。  


<code_intro_selected>
接下来剖析题解一的**核心片段**，看看“分类连通块”是如何实现的：
</code_intro_selected>

**题解一：(来源：OIer rui_er)**  
* **亮点**：用`nds`数组存储每个连通块的剩余度数点，`nd1`和`nd2`分类管理，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= deg[i]; j++) {
          nds[dsu.find(i)].push_back(i); // 将节点i加入其连通块的剩余度数列表
      }
  }
  for (int i = 1; i <= n; i++) {
      if (nds[i].size() == 1) nd1.push_back(nds[i][0]); // 第一类连通块（需要1条边）
      if (nds[i].size() > 1) nd2.push_back(nds[i]);      // 第二类连通块（需要≥2条边）
  }
  ```
* **代码解读**：  
  - 第一个循环：遍历每个节点，将其剩余度数对应的“需要连接的次数”加入其连通块的`nds`列表（比如节点`i`有`deg[i]=3`，就会被加入`nds[find(i)]`三次）；  
  - 第二个循环：根据`nds`列表的大小分类连通块——`size==1`说明该连通块需要1条边（第一类），`size>1`说明需要多条边（第二类）。  
* 💡 **学习笔记**：`nds`数组的作用是**统计每个连通块的剩余连接需求**，分类是为了后续有序连接。  


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了更直观地理解“连通块分类与连接”的过程，我设计了一个**8位像素风格的动画**，模拟城市和高速公路的构造过程：
\</visualization\_intro\>

### **动画演示主题**：《像素城市的高速公路计划》  
（仿照FC游戏《大富翁》的画面风格，用像素块表示城市，线条表示高速公路）

### **核心演示内容**：  
1. **场景初始化**：  
   - 屏幕左侧显示`6`个像素城市（编号1-6），右侧显示“控制面板”（开始/暂停、单步、重置按钮）；  
   - 城市下方标注剩余度数（比如样例1中的城市6剩余度数为2）；  
   - 已有边（比如样例1中的1-2、1-4）用灰色线条连接。  

2. **算法启动**：  
   - 播放8位风格的背景音乐（轻快的电子乐）；  
   - 用“闪烁”效果突出显示需要处理的连通块（比如样例1中的连通块1-2-4，剩余度数总和为3）。  

3. **连通块分类**：  
   - 第一类连通块（剩余度数=1）用**绿色**标注（比如样例1中的城市3）；  
   - 第二类连通块（剩余度数≥2）用**蓝色**标注（比如样例1中的连通块1-2-4）；  
   - 剩余度数用数字动态更新（比如城市6的剩余度数从2减到1时，数字会“跳一下”并播放“叮”的音效）。  

4. **连接过程**：  
   - 用**蓝色线条**动态绘制新边（比如样例1中的6-2）；  
   - 连接后，两个连通块合并（比如城市6加入连通块1-2-4），用“渐变色”效果表示合并；  
   - 每连接一条边，控制面板上的“进度条”增加（比如从0%到33%）。  

5. **目标达成**：  
   - 当所有城市连通且度数满足要求时，播放“胜利音效”（上扬的电子音）；  
   - 所有城市变成**金色**，并显示“任务完成！”的文字提示。  

### **交互设计**：  
- **单步执行**：点击“单步”按钮，动画执行一步（比如连接一条边）；  
- **自动播放**：点击“自动”按钮，动画按每秒1步的速度播放（可通过滑块调整速度）；  
- **重置**：点击“重置”按钮，回到初始状态。  

### **设计理由**：  
- 像素风格能唤起“复古游戏”的亲切感，降低学习压力；  
- 颜色标注和动态效果能清晰展示“谁在变化”（比如连通块合并、剩余度数减少）；  
- 音效和进度条能增强“成就感”，让学习更有趣。  


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了本题的“图构造+并查集”技巧后，可以尝试以下类似问题，巩固所学：
\</similar\_problems\_intro\>

### **通用思路迁移**：  
本题的技巧（并查集维护连通性、度数调整、分类处理）可用于解决**“给定边约束，构造满足度数要求的图”**类问题，比如：  
- 构造一棵满足度数要求的树；  
- 构造一个无环图（森林）满足度数要求；  
- 构造一个连通图满足度数要求。  

### **练习推荐 (洛谷)**：  
1. **洛谷 P1551** - 亲戚  
   * 🗣️ **推荐理由**：这道题是并查集的基础应用，帮你熟练掌握`find`和`merge`操作。  
2. **洛谷 P2820** - 局域网  
   * 🗣️ **推荐理由**：本题要求构造一个满足度数要求的无环图，与本题的“树构造”思路类似。  
3. **洛谷 P3366** - 最小生成树  
   * 🗣️ **推荐理由**：虽然是最小生成树问题，但并查集的使用逻辑与本题一致，帮你巩固连通性维护技巧。  


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
题解一的作者提到“这题无解情况挺多的，容易漏情况，写代码之前要想清楚”，这对我们很有启发：
\</insights\_intro\>

> **参考经验 (来自 OIer rui_er)**：“我在解决这个问题时，最初漏掉了‘最终图不连通’的情况，导致代码测试不通过。后来通过‘遍历所有节点检查是否与1连通’才解决了这个问题。”  
> **点评**：这位作者的经验很典型——**边界条件是编程中的“隐形陷阱”**，一定要在写代码前列全所有可能的无解情况，并在代码中逐一检查。比如本题中的“最终图不连通”情况，虽然概率低，但一旦出现就会导致错误，必须处理。  


\<conclusion\>
本次关于“[ABC239F] Construct Highway”的分析就到这里。希望这份指南能帮你掌握“图构造+并查集”的核心技巧。记住：**编程的关键是“拆解问题”——把复杂的问题拆成简单的步骤，再逐一解决**。下次我们再一起探索新的编程挑战！💪
\</conclusion\>

---
处理用时：373.83秒
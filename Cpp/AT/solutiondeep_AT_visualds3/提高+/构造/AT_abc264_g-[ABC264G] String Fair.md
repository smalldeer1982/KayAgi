# 题目信息

# [ABC264G] String Fair

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc264/tasks/abc264_g

文字列品評会では、英小文字のみからなる空でない文字列 $ S $ に対して、その「美しさ」を決定します。

文字列 $ S $ の美しさは、$ N $ 個の審査項目の点数の和として定められます。 $ i\ =\ 1,\ 2,\ \ldots,\ N $ について、$ i $ 番目の審査項目の点数は 「文字列 $ T_i $（入力で与えられる**長さ $ 3 $ 以下**の文字列）が $ S $ に連続な部分文字列として含まれる回数」に $ P_i $ を掛けて得られる値です。

英小文字のみからなる**空でない**文字列 $ S $ の美しさとしてあり得る最大値を出力して下さい。 ただし、美しさとしていくらでも大きい値が考えられる場合は、代わりに `Infinity` と出力して下さい。

ここで、文字列 $ U\ =\ U_1U_2\ldots\ U_{|U|} $ に文字列 $ V $ が連続な部分列として含まれる回数とは、 $ 1\ \leq\ i\ \leq\ |U|-|V|+1 $ を満たす整数 $ i $ であって $ U_iU_{i+1}\ldots\ U_{i+|V|-1}\ =\ V $ を満たすものの個数です。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 18278 $
- $ N $ は整数
- $ T_i $ は英小文字のみからなる長さ $ 1 $ 以上 $ 3 $ 以下の文字列
- $ i\ \neq\ j\ \Rightarrow\ T_i\ \neq\ T_j $
- $ -10^9\ \leq\ P_i\ \leq\ 10^9 $
- $ P_i $ は整数

### Sample Explanation 1

例えば、$ S\ = $ `abzabz` について、 - $ 1 $ 番目の審査項目の点数は、`a` が $ S $ に連続な部分列として含まれる回数が $ 2 $ 回であることから、$ 2\ \times\ (-5)\ =\ -10 $ 点 - $ 2 $ 番目の審査項目の点数は、`ab` が $ S $ に連続な部分列として含まれる回数が $ 2 $ 回であることから、$ 2\ \times\ 10\ =\ 20 $ 点 - $ 3 $ 番目の審査項目の点数は、`ba` が $ S $ に連続な部分列として含まれる回数が $ 0 $ 回であることから、$ 0\ \times\ (-20)\ =\ 0 $ 点 であるので、$ S $ の美しさは $ (-10)\ +\ 20\ +\ 0\ =\ 10 $ となります。 別の例として、$ S\ = $ `abzabzabz` について、 - $ 1 $ 番目の審査項目の点数は、`a` が $ S $ に連続な部分列として含まれる回数が $ 3 $ 回であることから、$ 3\ \times\ (-5)\ =\ -15 $ 点 - $ 2 $ 番目の審査項目の点数は、`ab` が $ S $ に連続な部分列として含まれる回数が $ 3 $ 回であることから、$ 3\ \times\ 10\ =\ 30 $ 点 - $ 3 $ 番目の審査項目の点数は、`ba` が $ S $ に連続な部分列として含まれる回数が $ 0 $ 回であることから、$ 0\ \times\ (-20)\ =\ 0 $ 点 であるので、$ S $ の美しさは $ (-15)\ +\ 30\ +\ 0\ =\ 15 $ となります。 一般に、正の整数 $ X $ について、`abz` を $ X $ 回繰り返した文字列の美しさは $ 5X $ となります。 $ S $ の美しさとしていくらでも大きい値が考えられるため、`Infinity` を出力します。

### Sample Explanation 2

$ S\ = $ `ab` が考えられる美しさの最大値を達成します。

### Sample Explanation 3

$ S $ は空でない文字列でなければならないことに注意して下さい。

## 样例 #1

### 输入

```
3

a -5

ab 10

ba -20```

### 输出

```
Infinity```

## 样例 #2

### 输入

```
28

a -5

ab 10

ba -20

bb -20

bc -20

bd -20

be -20

bf -20

bg -20

bh -20

bi -20

bj -20

bk -20

bl -20

bm -20

bn -20

bo -20

bp -20

bq -20

br -20

bs -20

bt -20

bu -20

bv -20

bw -20

bx -20

by -20

bz -20```

### 输出

```
5```

## 样例 #3

### 输入

```
26

a -1

b -1

c -1

d -1

e -1

f -1

g -1

h -1

i -1

j -1

k -1

l -1

m -1

n -1

o -1

p -1

q -1

r -1

s -1

t -1

u -1

v -1

w -1

x -1

y -1

z -1```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC264G] String Fair 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（最长路 + 正环判断）

🗣️ **初步分析**：  
解决“String Fair”的关键，在于将**字符串构造问题转化为图论中的最长路问题**。简单来说，我们可以把字符串的**末尾1-2个字符**作为“状态”，每添加一个新字符就从一个状态转移到另一个状态，转移时计算新增的分数（比如添加`c`到`ab`后面，会新增`c`、`bc`、`abc`这三个子串的分数）。如果图中存在**正环**（绕一圈分数增加），说明可以无限循环这个环，得到无限大的美しさ；否则，最长路的长度就是最大美しさ。  

- **核心思路**：用状态表示字符串末尾的1-2个字符（如`a`、`ab`），建边表示添加字符后的转移，边权为新增的分数。通过SPFA算法求最长路，同时判断是否有正环。  
- **核心难点**：① 如何设计状态（覆盖所有可能的子串）；② 如何计算边权（新增字符带来的所有子串分数）；③ 如何高效判断正环（SPFA的`cnt`数组记录入队次数）。  
- **可视化设计思路**：用像素块表示状态（如`a`用红色方块，`ab`用蓝色方块），箭头表示转移，边权用数字标注。当检测到正环时，环上的像素块闪烁并播放“警告”音效，帮助直观理解“无限大”的原因。  


## 2. 精选优质题解参考

### 题解一：(来源：cosf)  
* **点评**：这份题解的状态设计非常清晰！用`x(a)`表示单个字符`a`的状态，`y(a,b)`表示两个字符`ab`的状态，`z(a,b,c)`表示三个字符`abc`的状态（但实际只用前两个字符的状态转移）。边权计算时，直接累加新增字符带来的所有子串分数（如`ab`→`bc`的边权是`abc`+`bc`+`c`的分数），逻辑严谨。代码中的`SPFA`算法用`vis`数组记录入队次数，超过阈值则输出`Infinity`，处理正环的方式很经典。代码风格简洁，变量命名直观，非常适合初学者理解。  

### 题解二：(来源：Tsawke)  
* **点评**：此题解的建图思路和cosf类似，但用`map`记录状态编号，更灵活。边权计算时，通过字符串拼接的方式获取所有可能的子串（如从`ab`添加`c`得到`abc`，然后逐步删除首字符得到`bc`、`c`），这种方法很直观，容易理解。`SPFA`算法中用`dep`数组记录路径长度，超过状态数则判断为正环，逻辑正确。代码中的`ROPNEW`宏用于内存池，优化了边的存储，值得学习。  

### 题解三：(来源：Take_A_Single_6)  
* **点评**：这份题解的亮点是用`SLF`优化（双端队列，将小权值节点放在队尾）加速`SPFA`，适合处理大规模数据。状态编号用`map<string, int>`映射，虽然有一定的时间开销，但代码可读性高。边权计算时，直接调用`p` map获取子串分数，逻辑清晰。`ans`初始化为负无穷，避免了空字符串的情况，考虑周到。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何设计状态？**  
* **分析**：因为`T_i`的长度不超过3，所以字符串的末尾1-2个字符足以决定后续添加字符时会产生哪些新的子串。例如，添加`c`到`ab`后面，新的子串是`c`（长度1）、`bc`（长度2）、`abc`（长度3），这些都依赖于末尾的`ab`和新增的`c`。因此，状态可以设计为：  
  - 空状态（0号点）；  
  - 单个字符（如`a`→1-26号点）；  
  - 两个字符（如`ab`→27-702号点）。  
* 💡 **学习笔记**：状态设计要覆盖问题的“关键信息”，避免冗余。

### 2. **关键点2：如何计算边权？**  
* **分析**：边权是添加字符后新增的所有子串的分数之和。例如，从状态`ab`（表示末尾两个字符是`ab`）添加`c`，转移到状态`bc`，边权为`abc`（长度3）+`bc`（长度2）+`c`（长度1）的分数之和。这些子串的分数可以通过`map`或数组预处理，直接查询。  
* 💡 **学习笔记**：边权计算要考虑所有可能的子串，避免遗漏。

### 3. **关键点3：如何判断正环？**  
* **分析**：正环是指绕一圈后分数增加的环。在`SPFA`算法中，用`cnt`数组记录每个节点的入队次数，如果某个节点的入队次数超过状态数（如703次），说明存在正环（因为最长路的长度不会超过状态数，否则一定有环）。  
* 💡 **学习笔记**：正环判断是解决“无限大”问题的关键，`SPFA`是常用的方法。


### ✨ 解题技巧总结  
- **问题转化**：将字符串构造问题转化为图论问题，用状态表示关键信息，边表示转移。  
- **状态设计**：根据题目中的子串长度，设计最小的状态集合（如末尾1-2个字符）。  
- **正环判断**：用`SPFA`的入队次数判断正环，超过状态数则输出`Infinity`。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了cosf和Tsawke的思路，用宏定义状态，`SPFA`判断正环，逻辑清晰。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <climits>
using namespace std;

#define x(a) (a - 'a' + 1)          // 单个字符状态（1-26）
#define y(a, b) (x(a) * 26 + x(b))  // 两个字符状态（27-702）
#define MAX_STATE 703               // 状态总数（0+26+26²=703）
#define INF LLONG_MIN

using ll = long long;
using pil = pair<int, ll>;

vector<pil> e[MAX_STATE];  // 邻接表：e[u]存储(u→v, 边权)
ll val[10000];             // val[hash]存储子串的分数（hash为x、y、z的宏值）
ll dis[MAX_STATE];         // dis[u]表示到u的最长路
int cnt[MAX_STATE];        // cnt[u]表示u的入队次数
bool vis[MAX_STATE];       // vis[u]表示u是否在队列中

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        string s;
        ll w;
        cin >> s >> w;
        if (s.size() == 1) val[x(s[0])] = w;
        if (s.size() == 2) val[y(s[0], s[1])] = w;
        if (s.size() == 3) val[y(s[1], s[2]) * 26 + x(s[0])] = w;  // 这里用y(s1,s2)*26+x(s0)表示abc的hash，实际不影响，因为边权计算时会处理
    }

    // 建边：0→单个字符（如a）
    for (char a = 'a'; a <= 'z'; a++) {
        e[0].emplace_back(x(a), val[x(a)]);
    }

    // 建边：单个字符→两个字符（如a→ab）
    for (char a = 'a'; a <= 'z'; a++) {
        for (char b = 'a'; b <= 'z'; b++) {
            ll w = val[y(a, b)] + val[x(b)];  // 边权：ab + b
            e[x(a)].emplace_back(y(a, b), w);
        }
    }

    // 建边：两个字符→两个字符（如ab→bc）
    for (char a = 'a'; a <= 'z'; a++) {
        for (char b = 'a'; b <= 'z'; b++) {
            for (char c = 'a'; c <= 'z'; c++) {
                ll w = val[y(a, b) * 26 + x(c)] + val[y(b, c)] + val[x(c)];  // 边权：abc + bc + c
                e[y(a, b)].emplace_back(y(b, c), w);
            }
        }
    }

    // SPFA求最长路
    fill(dis, dis + MAX_STATE, INF);
    queue<int> q;
    q.push(0);
    dis[0] = 0;
    vis[0] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;

        for (auto [v, w] : e[u]) {
            if (dis[v] < dis[u] + w) {
                dis[v] = dis[u] + w;
                cnt[v]++;
                if (cnt[v] > MAX_STATE) {  // 入队次数超过状态数，存在正环
                    cout << "Infinity" << endl;
                    return 0;
                }
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }

    // 找最大的dis（非空字符串，所以排除0号点）
    ll ans = INF;
    for (int i = 1; i < MAX_STATE; i++) {
        ans = max(ans, dis[i]);
    }
    cout << ans << endl;

    return 0;
}
```  
* **代码解读概要**：  
  1. **状态定义**：用`x(a)`表示单个字符`a`，`y(a,b)`表示两个字符`ab`，状态总数为703。  
  2. **建边**：从空状态（0号点）到单个字符，单个字符到两个字符，两个字符到两个字符，边权为新增的分数之和。  
  3. **SPFA算法**：求最长路，用`cnt`数组记录入队次数，超过状态数则输出`Infinity`。  
  4. **结果计算**：找所有非空状态的最长路，即为最大美しさ。


### 针对各优质题解的片段赏析

#### 题解一：(来源：cosf)  
* **亮点**：状态设计简洁，用宏定义直接计算状态编号。  
* **核心代码片段**：  
```cpp
#define x(a) (a - 'a' + 1)
#define y(a, b) (x(a) * 26 + x(b))
for (char a = 'a'; a <= 'z'; a++) {
    e[0].emplace_back(x(a), v[x(a)]);
    for (char b = 'a'; b <= 'z'; b++) {
        e[x(a)].emplace_back(y(a, b), v[y(a, b)] + v[x(b)]);
        for (char c = 'a'; c <= 'z'; c++) {
            e[y(a, b)].emplace_back(y(b, c), v[z(a, b, c)] + v[y(b, c)] + v[x(c)]);
        }
    }
}
```  
* **代码解读**：  
  - `x(a)`将字符`a`映射到1-26的整数，`y(a,b)`将两个字符映射到27-702的整数。  
  - 建边时，从空状态（0号点）到单个字符`a`，边权为`a`的分数；从单个字符`a`到两个字符`ab`，边权为`ab`+`b`的分数；从两个字符`ab`到两个字符`bc`，边权为`abc`+`bc`+`c`的分数。  
* 💡 **学习笔记**：宏定义可以简化状态编号的计算，提高代码可读性。


#### 题解二：(来源：Tsawke)  
* **亮点**：用`map`记录状态编号，灵活处理不同长度的字符串。  
* **核心代码片段**：  
```cpp
map < pair < int, int >, int > mp;
mp.insert({{0, 0}, ++cnt}), rmp.insert({cnt, {0, 0}});
for(int i = 'a'; i <= 'z'; ++i)mp.insert({{0, i}, ++cnt}), rmp.insert({cnt, {0, i}});
for(int i = 'a'; i <= 'z'; ++i)for(int j = 'a'; j <= 'z'; ++j)
    mp.insert({{i, j}, ++cnt}), rmp.insert({cnt, {i, j}});
```  
* **代码解读**：  
  - `mp`是一个`map`，键是`(前一个字符, 当前字符)`的 pair，值是状态编号。例如，`(0, 'a')`表示单个字符`a`，`('a', 'b')`表示两个字符`ab`。  
  - 初始化时，先插入空状态（0,0），然后插入所有单个字符（0, a-z），再插入所有两个字符（a-z, a-z）。  
* 💡 **学习笔记**：`map`可以灵活处理状态编号，但要注意时间开销（可以用`unordered_map`优化）。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素字符串探险家”**：用8位像素风格展示状态转移和正环检测，模拟字符串构造过程。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示**状态网格**：用不同颜色的像素块表示状态（如空状态0用黑色，单个字符`a`用红色，两个字符`ab`用蓝色）。  
   - 屏幕右侧显示**控制面板**：有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块。  
   - 背景播放8位风格的轻快BGM（如《超级马里奥》的背景音乐）。

2. **状态转移演示**：  
   - 当从状态`ab`（蓝色方块）添加字符`c`时，箭头从`ab`指向`bc`（新的蓝色方块），边权（如`abc`+`bc`+`c`的分数）用白色数字标注在箭头上。  
   - 新增的子串（`c`、`bc`、`abc`）用黄色像素块在屏幕下方弹出，伴随“叮”的音效。

3. **正环检测**：  
   - 当检测到正环（如`ab`→`bc`→`cd`→`ab`，边权之和为正），环上的像素块会快速闪烁（红色→黄色→红色），并播放“警告”音效（如《魂斗罗》的死亡音效）。  
   - 屏幕中央弹出“发现正环！美しさ无限大！”的文字提示。

4. **交互设计**：  
   - **单步执行**：点击“单步”按钮，动画执行一步转移，显示当前状态和边权。  
   - **自动播放**：拖动速度滑块调整播放速度，动画自动执行转移，直到找到正环或结束。  
   - **重置**：点击“重置”按钮，回到初始状态，重新开始演示。


### 设计思路简述  
- **像素风格**：模拟FC红白机的画面，让学习者感到亲切，降低学习压力。  
- **音效提示**：关键操作（如转移、正环）用音效强化记忆，让学习更有趣。  
- **交互控制**：单步执行和自动播放结合，满足不同学习者的需求（有的想慢慢看，有的想快速过）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **状态表示**：当问题中的子串长度有限时（如≤3），可以用末尾的几个字符作为状态，转化为图论问题。  
- **正环判断**：当需要判断是否存在无限大的解时，用`SPFA`判断正环是常用的方法。  
- **边权计算**：对于字符串问题，边权通常是新增字符带来的分数或代价之和。


### 练习推荐 (洛谷)  
1. **洛谷 P3385** - 【模板】负环判断  
   - 🗣️ **推荐理由**：这道题是负环判断的模板题，和本题的正环判断思路类似，可以帮助你巩固`SPFA`的用法。  
2. **洛谷 P1807** - 最长路  
   - 🗣️ **推荐理由**：这道题是最长路的模板题，用`SPFA`求最长路，和本题的核心算法一致。  
3. **洛谷 P2136** - 拉近距离  
   - 🗣️ **推荐理由**：这道题需要将问题转化为图论问题，用`SPFA`求最长路，是本题的变形应用。  


## 7. 学习心得与经验分享 (若有)  
> **参考经验 (来自 cosf)**：“我在解决这个问题时，最初没想到用图论的方法，后来想到`T_i`的长度不超过3，才意识到可以用末尾的字符作为状态。这让我意识到，**问题的限制条件往往是解题的关键**。”  
> **点评**：这位作者的经验很重要。当题目中的子串长度有限时，状态设计往往可以简化，比如用末尾的几个字符表示状态。这是解决字符串问题的常用技巧。  


## 结语  
本次关于“[ABC264G] String Fair”的C++解题分析就到这里。希望这份学习指南能帮助大家理解**图论在字符串问题中的应用**，掌握`SPFA`求最长路和判断正环的方法。记住，**问题转化是解题的关键**，多思考如何将复杂的问题转化为熟悉的模型（如图论），你会发现编程变得更简单！💪  

下次我们再一起探索新的编程挑战！🚀

---
处理用时：377.76秒
# 题目信息

# [ABC312E] Tangency of Cuboids

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc312/tasks/abc312_e

$ 3 $ 次元空間内に $ N $ 個の直方体があります。

直方体同士は重なっていません。厳密には、相異なるどの $ 2 $ つの直方体の共通部分の体積も $ 0 $ です。

$ i $ 番目の直方体は、$ 2 $ 点 $ (X_{i,1},Y_{i,1},Z_{i,1}),\ (X_{i,2},Y_{i,2},Z_{i,2}) $ を結ぶ線分を対角線とし、辺は全ていずれかの座標軸に平行です。

各直方体について、他のいくつの直方体と面で接しているか求めてください。  
 厳密には、各 $ i $ に対し、$ 1\leq\ j\ \leq\ N $ かつ $ j\neq\ i $ である $ j $ のうち、$ i $ 番目の直方体の表面と $ j $ 番目の直方体の表面の共通部分の面積が正であるものの個数を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 0\ \leq\ X_{i,1}\ <\ X_{i,2}\ \leq\ 100 $
- $ 0\ \leq\ Y_{i,1}\ <\ Y_{i,2}\ \leq\ 100 $
- $ 0\ \leq\ Z_{i,1}\ <\ Z_{i,2}\ \leq\ 100 $
- 直方体同士は体積が正の共通部分を持たない
- 入力は全て整数である
 
### Sample Explanation 1

$ 1 $ 番目の直方体と $ 2 $ 番目の直方体は、$ 2 $ 点 $ (0,0,1),(1,1,1) $ を結ぶ線分を対角線とする長方形を共有しています。 $ 1 $ 番目の直方体と $ 3 $ 番目の直方体は、点 $ (1,1,1) $ を共有していますが、面で接してはいません。

## 样例 #1

### 输入

```
4

0 0 0 1 1 1

0 0 1 1 1 2

1 1 1 2 2 2

3 3 3 4 4 4```

### 输出

```
1

1

0

0```

## 样例 #2

### 输入

```
3

0 0 10 10 10 20

3 4 1 15 6 10

0 9 6 1 20 10```

### 输出

```
2

1

1```

## 样例 #3

### 输入

```
8

0 0 0 1 1 1

0 0 1 1 1 2

0 1 0 1 2 1

0 1 1 1 2 2

1 0 0 2 1 1

1 0 1 2 1 2

1 1 0 2 2 1

1 1 1 2 2 2```

### 输出

```
3

3

3

3

3

3

3

3```

# AI分析结果



---
# 💡 Kay的C++算法解析：ABC312E Tangency of Cuboids 深入学习指南 💡

<introduction>
今天我们来分析这道“Tangency of Cuboids”题目。它要求我们计算每个长方体与其他长方体通过面接触的数量。这道题的关键在于利用三维坐标范围小的特点，通过模拟单位小立方体的相邻关系来解决问题。让我们一步步拆解思路！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与三维坐标处理`

🗣️ **初步分析**：
解决这道题的核心是“模拟单位小立方体的相邻关系”。简单来说，就像在三维网格中给每个小格子贴标签（标记所属长方体），然后检查每个格子周围的三个方向（右、上、前）的格子是否属于不同的长方体。若属于，则这两个长方体共享一个面。

- **题解思路**：所有题解均采用“三维网格标记+相邻检查”的思路：先将每个长方体分解为单位小立方体，用三维数组标记每个小立方体所属的长方体编号；再遍历所有小立方体，检查其右、上、前三个方向的小立方体，若属于不同长方体，则记录这对长方体的接触关系（用`set`去重）。
- **核心难点**：如何高效标记长方体覆盖的小立方体？如何避免重复计数？解决方案是通过三维数组直接标记，并利用`set`自动去重。
- **可视化设计**：计划用8位像素风格的三维网格，每个小立方体用不同颜色表示所属长方体。动画中会高亮当前检查的小立方体及其相邻块，用“闪烁”和“音效”提示发现接触面，步进控制可观察每一步的标记和检查过程。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估（思路清晰度、代码规范性、算法有效性等），以下3篇题解质量较高（均≥4星）：
</eval_intro>

**题解一：作者Moyou**
* **点评**：此题解思路简洁直接，代码结构清晰。通过三维数组`a[i][j][k]`标记小立方体所属的长方体，遍历三个方向（`dx, dy, dz`）检查相邻块，并用`set`去重。变量命名如`dx[]`明确表示方向偏移，循环范围（`i <= 100`）处理边界合理。其时间复杂度为$O(N + M^3\log N)$，在数据范围内高效可行。亮点在于仅枚举三个方向（避免重复检查），并利用`set`自动去重，是竞赛中典型的“空间换时间”优化。

**题解二：作者Genius_Star**
* **点评**：此题解补充了快读快输优化，适合处理大数据量输入。代码中明确处理了长方体的坐标范围（`x1 <= x < x2`），确保小立方体标记正确。通过`set<ll> t[M]`记录接触关系，逻辑与Moyou一致但实现更细致。亮点是对输入输出的优化（`read()`和`write()`函数），提升了实际运行效率，适合竞赛实战。

**题解三：作者xrk2006**
* **点评**：此题解思路清晰，注释详细（如`work`函数解释标记过程）。代码结构模块化，将长方体标记封装为`work`函数，提高可读性。遍历小立方体时，明确检查相邻块是否存在（`col[i][j][k] && col[...]`），避免越界错误。亮点是对边界条件的严谨处理（如`i < 100`），确保所有可能的相邻块都被覆盖。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于处理三维坐标标记、相邻检查和去重。以下是核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何将长方体转换为单位小立方体的标记？**
    * **分析**：每个长方体由对角线端点定义，需确定其覆盖的小立方体范围。例如，长方体的x坐标范围是`[x1, x2)`（注意是左闭右开），因此小立方体的x索引为`x1 ≤ x < x2`。题解中通过三重循环遍历`x, y, z`，将对应位置的三维数组标记为当前长方体编号。
    * 💡 **学习笔记**：三维坐标的左闭右开区间处理是关键，避免越界或重复标记。

2.  **关键点2：如何高效检查相邻小立方体？**
    * **分析**：每个小立方体需检查右（x+1）、上（y+1）、前（z+1）三个方向（其他方向会被反向检查覆盖）。若相邻块属于不同长方体，则记录这对接触关系。题解中通过`dx, dy, dz`数组简化方向遍历。
    * 💡 **学习笔记**：仅检查三个方向可避免重复（如检查x+1时，x-1的块会在其自身的x+1检查中被处理）。

3.  **关键点3：如何避免重复计数？**
    * **分析**：两个长方体可能通过多个小立方体接触，需确保每对接触关系只计数一次。题解中使用`set`存储接触的长方体编号，利用其自动去重特性，确保最终计数准确。
    * 💡 **学习笔记**：`set`是处理“唯一关系”的利器，适合竞赛中快速去重。

### ✨ 解题技巧总结
- **坐标转换技巧**：将长方体的对角线端点转换为小立方体的左闭右开区间（如`x1 ≤ x < x2`），确保覆盖正确。
- **方向枚举优化**：仅枚举三个方向（右、上、前），避免重复检查反向方向。
- **去重工具选择**：使用`set`存储接触关系，自动去重且操作高效（插入时间复杂度为$\log n$）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了标记、检查和去重的完整逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Moyou和xrk2006的思路，优化了边界处理和方向检查，适合直接用于竞赛。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <set>
    using namespace std;

    const int MAX_COORD = 100; // 坐标范围上限（0~100）
    const int MAX_N = 1e5 + 10;

    int cube[105][105][105]; // 三维数组标记小立方体所属的长方体
    set<int> adj[MAX_N];     // 记录每个长方体的接触面

    int main() {
        int n;
        cin >> n;

        // 步骤1：标记每个小立方体所属的长方体
        for (int t = 1; t <= n; ++t) {
            int x1, y1, z1, x2, y2, z2;
            cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;
            // 遍历长方体覆盖的小立方体（左闭右开区间）
            for (int x = x1; x < x2; ++x)
                for (int y = y1; y < y2; ++y)
                    for (int z = z1; z < z2; ++z)
                        cube[x][y][z] = t;
        }

        // 步骤2：检查每个小立方体的三个方向相邻块
        for (int x = 0; x < MAX_COORD; ++x) {
            for (int y = 0; y < MAX_COORD; ++y) {
                for (int z = 0; z < MAX_COORD; ++z) {
                    int current = cube[x][y][z];
                    if (current == 0) continue; // 未被任何长方体覆盖

                    // 检查右方向（x+1）
                    if (x + 1 < MAX_COORD) {
                        int neighbor = cube[x+1][y][z];
                        if (neighbor != 0 && neighbor != current) {
                            adj[current].insert(neighbor);
                            adj[neighbor].insert(current);
                        }
                    }
                    // 检查上方向（y+1）
                    if (y + 1 < MAX_COORD) {
                        int neighbor = cube[x][y+1][z];
                        if (neighbor != 0 && neighbor != current) {
                            adj[current].insert(neighbor);
                            adj[neighbor].insert(current);
                        }
                    }
                    // 检查前方向（z+1）
                    if (z + 1 < MAX_COORD) {
                        int neighbor = cube[x][y][z+1];
                        if (neighbor != 0 && neighbor != current) {
                            adj[current].insert(neighbor);
                            adj[neighbor].insert(current);
                        }
                    }
                }
            }
        }

        // 步骤3：输出每个长方体的接触面数量
        for (int t = 1; t <= n; ++t)
            cout << adj[t].size() << '\n';

        return 0;
    }
    ```
* **代码解读概要**：
  代码分为三部分：输入并标记小立方体（步骤1）、检查相邻块并记录接触关系（步骤2）、输出结果（步骤3）。其中，三维数组`cube`标记每个小立方体所属的长方体，`adj`数组用`set`存储接触面，确保去重。

---
<code_intro_selected>
接下来，分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Moyou**
* **亮点**：代码简洁，方向枚举用数组简化，边界处理（`i <= 100`）合理。
* **核心代码片段**：
    ```cpp
    int dx[] = {1, 0, 0}, dy[] = {0, 1, 0}, dz[] = {0, 0, 1};
    for(int i = 1; i <= 100; i ++)
        for(int j = 1; j <= 100; j ++)
            for(int k = 1; k <= 100; k ++)
                for(int p = 0; p < 3; p ++)
                    if(a[i][j][k] && a[i + dx[p]][j + dy[p]][k + dz[p]] && a[i][j][k] != a[i + dx[p]][j + dy[p]][k + dz[p]]) 
                        s[a[i][j][k]].insert(a[i + dx[p]][j + dy[p]][k + dz[p]]),
                        s[a[i + dx[p]][j + dy[p]][k + dz[p]]].insert(a[i][j][k]);
    ```
* **代码解读**：
  这段代码通过`dx, dy, dz`数组枚举三个方向（右、上、前）。对于每个小立方体`(i,j,k)`，检查三个方向的相邻块是否属于不同长方体。若属于，则将这对长方体编号插入彼此的`set`中。`dx, dy, dz`数组的使用简化了方向枚举，避免重复代码。
* 💡 **学习笔记**：用数组存储方向偏移是简化多方向枚举的常用技巧。

**题解二：作者Genius_Star**
* **亮点**：快读快输优化，适合处理大数据量输入。
* **核心代码片段**：
    ```cpp
    inline ll read(){ //快读 
        ll x=0,f=1;
        char c=getchar();
        while(c<'0'||c>'9'){
            if(c=='-')
                f=-1;
            c=getchar();
        }
        while(c>='0'&&c<='9'){
            x=(x<<1)+(x<<3)+(c^48);
            c=getchar();
        }
        return x*f;
    }
    ```
* **代码解读**：
  这段代码实现了快速读取输入的功能。通过位运算（`x<<1 + x<<3`等价于`x*10`）和字符处理（`c^48`等价于`c-'0'`），比`cin`更高效。在`n=1e5`时，快读能显著减少输入时间。
* 💡 **学习笔记**：竞赛中处理大数据量输入时，快读快输是必备技巧。

**题解三：作者xrk2006**
* **亮点**：模块化标记过程，代码可读性高。
* **核心代码片段**：
    ```cpp
    void work(int xx,int xy,int yx,int yy,int zx,int zy,int t)
    {
        for(int i=xx;i<xy;i++)
            for(int j=yx;j<yy;j++)
                for(int k=zx;k<zy;k++)
                    col[i][j][k]=t;
    }
    ```
* **代码解读**：
  `work`函数将长方体标记过程封装，参数明确（`xx`到`xy`对应x范围，依此类推）。调用时传入长方体的坐标范围和编号`t`，即可完成标记。模块化设计提高了代码的可维护性。
* 💡 **学习笔记**：将重复操作封装为函数，是提升代码可读性的重要实践。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“小立方体标记”和“相邻检查”的过程，我们设计一个8位像素风格的三维动画，模拟长方体覆盖小立方体、检查相邻块并记录接触面的过程。
</visualization_intro>

  * **动画演示主题**：`像素立方体大冒险`（复古FC风格）

  * **核心演示内容**：
    展示三维网格中每个小立方体被不同颜色的长方体覆盖，动画逐步检查每个小立方体的右、上、前方向，当发现相邻块颜色不同时，用闪烁和音效提示，并在两个长方体的“接触计数器”上+1。

  * **设计思路简述**：
    8位像素风（16色调色板）营造轻松氛围；小立方体颜色对应长方体编号（如红色=1号，蓝色=2号）；关键步骤（标记、检查、发现接触）用音效（“叮”声）和动画（闪烁）强化记忆；步进控制允许学习者逐帧观察。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕中央显示100×100×100的三维网格（简化为2D投影，类似FC《俄罗斯方块》的立体效果），每个小立方体是1×1像素块。
        - 控制面板：“开始/暂停”“单步”“重置”按钮，速度滑块（0.5x~2x）。
        - 背景播放8位风格BGM（类似《超级马里奥》的轻快旋律）。

    2.  **长方体标记动画**：
        - 输入长方体坐标后，对应小立方体按编号颜色（如1号红色）逐渐填充（类似“油漆桶”扩散动画）。
        - 旁白：“看！红色长方体覆盖了这些小格子～”

    3.  **相邻检查动画**：
        - 当前检查的小立方体（如坐标`(x,y,z)`）用黄色边框高亮。
        - 检查右方向时，右侧小立方体（`x+1,y,z`）用绿色箭头指向；若颜色不同（如蓝色），两个小立方体同时闪烁，播放“叮”音效，旁白：“发现接触面！红色和蓝色长方体共享一个面～”
        - `set`计数器区域（屏幕右侧）显示两个长方体的接触关系（如“1号→2号”）。

    4.  **结果展示**：
        - 所有检查完成后，屏幕下方显示每个长方体的接触面数量（如“1号：1”），播放胜利音效（类似《魂斗罗》的过关音乐）。

  * **旁白提示**：
    - “现在我们给小格子贴标签，每个颜色代表一个长方体哦～”
    - “检查右边的小格子！如果颜色不同，说明它们的长方体有公共面～”
    - “听到‘叮’声了吗？这表示找到了一对接触面！”

<visualization_conclusion>
通过这样的动画，我们能直观看到每个小立方体的标记和检查过程，理解“为什么两个长方体共享面”的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“三维坐标处理+相邻关系统计”，这类思路可迁移到多种场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 三维空间中的区域覆盖问题（如统计不同区域的邻接关系）。
    - 网格中的连通性问题（如判断两个区域是否相邻）。
    - 基于小单元的碰撞检测（如游戏中物体的接触面判断）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1331 海战**：  
        🗣️ **推荐理由**：二维网格的连通块和相邻判断，巩固“标记+检查”的思路。
    2.  **洛谷 P5318 【深基18.例3】查找文献**：  
        🗣️ **推荐理由**：三维坐标的路径统计，练习三维数组的使用。
    3.  **洛谷 P1006 传纸条（加强版）**：  
        🗣️ **推荐理由**：多维动态规划中的路径重叠判断，提升多维问题分析能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中未明确提及作者的个人心得，但结合解题过程，我们可以总结以下经验：
</insights_intro>

> 实际编码时，需注意三维数组的边界（如`x < 100`），避免越界访问。例如，当检查`x+1`方向时，`x`的最大取值应为`99`（因为`x+1 <= 100`）。若未正确处理边界，可能导致数组越界错误或遗漏部分小立方体。

**点评**：边界处理是三维问题的常见易错点。在编码时，应明确每个循环的范围（如`x`从`0`到`99`），并通过测试样例验证（如样例1中，长方体的坐标范围刚好到`1`，需确保`x < x2`的正确处理）。

-----

<conclusion>
通过分析ABC312E，我们掌握了三维坐标标记、相邻检查和去重的核心技巧。希望大家能将这种“分解问题→标记单元→统计关系”的思路应用到更多题目中！下一次挑战再见～💪
</conclusion>

---
处理用时：124.83秒
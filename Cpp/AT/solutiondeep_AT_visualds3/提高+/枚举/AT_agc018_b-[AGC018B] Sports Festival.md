# 题目信息

# [AGC018B] Sports Festival

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc018/tasks/agc018_b

高橋君は、スポーツ大会を開こうと考えています。 スポーツ大会に参加するのは、$ 1 $ から $ N $ までの番号のついた $ N $ 人の人です。 また、大会で行うスポーツとして、$ 1 $ から $ M $ までの番号のついた $ M $ 個のスポーツが候補に上がっています。 高橋君は、これらの中から $ 1 $ つ以上（全てでもよい）のスポーツを選んで、スポーツ大会で実施します。

高橋君は、人 $ i $ が、$ j $ 番目に好きなスポーツが $ A_{ij} $ であることを知っています。 それぞれの人は、スポーツ大会で実施されるスポーツのうち、自分が最も好きなスポーツだけに参加し、他のスポーツには参加しません。

高橋君は、一つのスポーツにたくさんの人が集まり過ぎることを懸念しています。 そこで高橋君は、スポーツ大会で実施するスポーツをうまく選んで、最も多くの人が参加しているスポーツの参加人数を最小化したくなりました。 最も多くの人が参加しているスポーツの参加人数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ M\ \leq\ 300 $
- $ A_{i1} $ , $ A_{i2} $ , $ ... $ , $ A_{iM} $ は、$ 1 $ から $ M $ の順列である。

### Sample Explanation 1

スポーツ $ 1 $,$ 3 $,$ 4 $ を実施することにすると、人 $ 1 $ はスポーツ $ 1 $ に、人 $ 2 $ はスポーツ $ 3 $ に、 人 $ 3 $ はスポーツ $ 3 $ に、人 $ 4 $ はスポーツ $ 4 $ に参加します。 このとき、参加人数が最大のスポーツはスポーツ $ 3 $ で、その参加人数 $ 2 $ 人です。 また、参加人数が最大のスポーツの参加人数が $ 1 $ 人になるような方法は存在しないので、この例の答えは $ 2 $ になります。

### Sample Explanation 2

全員の好みが一致しているので、どうやっても一つのスポーツに $ 3 $ 人集まってしまいます。 よってこの例の答えは $ 3 $ です。

## 样例 #1

### 输入

```
4 5

5 1 3 4 2

2 5 3 1 4

2 3 1 4 5

2 5 4 3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

2 1 3

2 1 3

2 1 3```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：AGC018B Sports Festival 深入学习指南 💡

<introduction>
今天我们来一起分析“AGC018B Sports Festival”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心贪心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心算法`

🗣️ **初步分析**：
解决“AGC018B Sports Festival”这道题，关键在于理解并运用贪心算法。简单来说，贪心算法就像“每一步都选当前最有利的选择”，比如买零食时，每次选最想吃的，最终整体满足感可能最大。在本题中，贪心策略体现在：初始时选择所有项目，然后**每次删除当前参与人数最多的项目**，这样能逐步减少“最大参与人数”，最终找到最小值。

- **题解思路**：所有优质题解均采用“贪心删除最大值”策略：初始选所有项目→统计各项目人数→删除人数最多的项目→更新每个人的选择（若当前项目被删，选下一个未被删的）→重复直到无法删除，记录过程中的最小最大值。
- **核心难点**：如何高效维护每个人的当前选择（避免重复遍历）、如何正确统计每次删除后的参与人数。
- **可视化设计**：计划采用8位像素风动画，用彩色方块表示项目（颜色越深人数越多），每次删除时方块变灰，对应人（小像素人）移动到下一个项目方块，伴随“叮”音效。控制面板支持单步/自动播放，高亮当前删除的项目和移动的小人。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法效率等，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者Ebola (赞：6)**
* **点评**：此题解思路简洁高效。通过`pos[i]`指针维护每个人的当前选择（初始为1），每次删除后直接移动指针，避免了重复遍历喜好列表。代码中使用`vis`数组标记已删除项目，`cnt`数组统计人数，逻辑清晰。亮点在于指针维护的优化（复杂度O(nm)），比未优化的题解快一倍。代码结构规范，变量名含义明确（如`pos`表示位置，`vis`表示是否删除），边界处理严谨（如`while(vis[A[i][pos[i]]]) pos[i]++`确保找到未删项目）。

**题解二：作者Umbrella_Leaf (赞：4)**
* **点评**：此题解同样采用贪心策略，用`now[i]`数组记录每个人的当前选择位置。代码逻辑直白，通过`cnt`数组统计人数，每次找到最大值后删除并更新`now`。亮点在于状态转移的直观性（`now[i]`直接递增），且解释中用数学归纳法证明了贪心的正确性，对理解算法原理有很大帮助。代码简洁，适合初学者模仿。

**题解三：作者Solve::Tokai__Teio (赞：1)**
* **点评**：此题解结构清晰，注释详细。通过`cur[i]`数组维护当前选择，`st`数组标记删除项目，`cnt`统计人数。亮点在于将贪心过程封装在循环中，每一步操作明确（找最大值→更新答案→删除项目→调整选择），适合理解贪心流程。代码规范性强，变量命名直观（如`cur`表示当前选择）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向：
</difficulty_intro>

1.  **关键点1**：如何高效维护每个人的当前选择？
    * **分析**：每个人的喜好是一个顺序列表（如`A[i][1]`是最喜欢的，`A[i][2]`次之）。当某个项目被删除时，需要找到下一个未被删除的项目。优质题解通过指针（如`pos[i]`、`now[i]`）记录当前选择的位置，每次删除后只需递增指针，直到找到未删项目（`while(vis[A[i][pos[i]]]) pos[i]++`）。这种方法避免了每次从头遍历，时间复杂度仅为O(nm)。
    * 💡 **学习笔记**：指针维护是处理“顺序选择”问题的常用技巧，能大幅提升效率。

2.  **关键点2**：如何正确统计每次删除后的参与人数？
    * **分析**：每次删除后，需要重新统计各项目的参与人数。优质题解使用`cnt`数组（如`cnt[项目编号]`），遍历所有人的当前选择（通过指针定位），累加对应项目的计数。例如，Ebola的代码中`cnt[A[i][pos[i]]]++`直接统计当前选择的项目人数。
    * 💡 **学习笔记**：数组计数是统计频率的“万能钥匙”，简单高效。

3.  **关键点3**：如何证明贪心策略的正确性？
    * **分析**：贪心的核心是“每次删除当前最大人数项目”。假设不删除当前最大项目，其人数不会减少（因为其他项目的删除可能让更多人选择它），因此最大值不会降低。通过数学归纳法可证：第1次删除是必要的（否则最大值不变），假设前k次删除必要，则第k+1次删除当前最大项目仍必要（否则最大值不减少）。因此贪心是正确的。
    * 💡 **学习笔记**：贪心正确性证明需抓住“局部最优→全局最优”的逻辑链。

### ✨ 解题技巧总结
<summary_best_practices>
- **指针维护选择位置**：用`pos[i]`、`now[i]`等指针记录当前选择，避免重复遍历喜好列表。
- **数组统计参与人数**：用`cnt`数组快速统计各项目人数，时间复杂度O(n)。
- **标记已删除项目**：用`vis`或`st`数组标记已删除项目，快速判断当前选择是否有效。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个综合优质题解的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Ebola和Umbrella_Leaf的思路，采用指针维护当前选择，高效统计人数。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 310;
    int A[N][N], pos[N], cnt[N];
    bool vis[N]; // vis[x]表示项目x是否被删除

    int main() {
        int n, m;
        cin >> n >> m;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                cin >> A[i][j];
            }
            pos[i] = 1; // 初始选择第一个项目
        }
        int ans = INT_MAX;
        while (true) {
            memset(cnt, 0, sizeof(cnt));
            int max_cnt = 0, del_project = 0;
            // 统计当前各项目的参与人数
            for (int i = 1; i <= n; ++i) {
                while (vis[A[i][pos[i]]]) pos[i]++; // 跳过已删除项目
                if (pos[i] > m) continue; // 所有项目被删（不可能，因至少留1个）
                cnt[A[i][pos[i]]]++;
                // 找到当前人数最多的项目
                if (cnt[A[i][pos[i]]] > max_cnt) {
                    max_cnt = cnt[A[i][pos[i]]];
                    del_project = A[i][pos[i]];
                }
            }
            if (max_cnt == 0) break; // 所有项目被删完（不可能）
            ans = min(ans, max_cnt);
            vis[del_project] = true; // 删除当前人数最多的项目
            // 更新受影响的人的选择（即原本选del_project的人）
            for (int i = 1; i <= n; ++i) {
                if (A[i][pos[i]] == del_project) {
                    pos[i]++; // 选择下一个项目
                }
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入并初始化每个人的当前选择（`pos[i] = 1`）。然后进入循环：统计各项目人数→找到人数最多的项目→删除它→更新受影响的人的选择。循环直到无法删除，输出过程中的最小最大值。核心逻辑在`while`循环中，通过`pos`指针和`vis`数组高效维护状态。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Ebola**
* **亮点**：通过`pos[i]`指针直接维护当前选择，避免重复遍历喜好列表，复杂度O(nm)。
* **核心代码片段**：
    ```cpp
    while(true) {
        int mx=0,cc=0;
        memset(cnt,0,sizeof(cnt));
        for(int i=1;i<=n;i++) {
            while(vis[A[i][pos[i]]]) pos[i]++;
            if(!A[i][pos[i]]) continue;
            cnt[A[i][pos[i]]]++;
            if(cnt[A[i][pos[i]]]>mx) cc=A[i][pos[i]],mx=cnt[cc];
        }
        if(!mx) break;
        ans=min(ans,mx);
        vis[cc]=1;
        for(int i=1;i<=n;i++)
            if(A[i][pos[i]]==cc) pos[i]++;
    }
    ```
* **代码解读**：这段代码是贪心循环的核心。`while(vis[A[i][pos[i]]]) pos[i]++`确保找到未删项目；`cnt`数组统计人数；`mx`和`cc`记录当前最大人数及对应项目。删除`cc`后，所有选`cc`的人`pos[i]++`，选择下一个项目。
* 💡 **学习笔记**：指针维护是关键，避免了每次从头遍历喜好列表，提升效率。

**题解二：作者Umbrella_Leaf**
* **亮点**：代码简洁，用`now[i]`数组记录当前选择，逻辑直观。
* **核心代码片段**：
    ```cpp
    for(int fsz=1;fsz<=m;fsz++){
        int maxx=-1,x=0;
        for(int i=1;i<=m;i++)if(vis[i]&&cnt[i]>maxx)maxx=cnt[i],x=i;
        ans=min(ans,maxx);
        vis[x]=0;
        for(int i=1;i<=n;i++)
            if(a[i][now[i]]==x){
                while(now[i]<m&&!vis[a[i][now[i]]])now[i]++;
                cnt[a[i][now[i]]]++;
            }
    }
    ```
* **代码解读**：循环`m`次（最多删`m-1`次）。每次找到当前最大人数项目`x`，删除后（`vis[x]=0`），所有选`x`的人`now[i]++`（直到找到未删项目），并更新`cnt`。`ans`记录过程中的最小值。
* 💡 **学习笔记**：循环次数明确（最多`m`次），适合理解贪心流程。

**题解三：作者Solve::Tokai__Teio**
* **亮点**：注释详细，状态转移清晰。
* **核心代码片段**：
    ```cpp
    for(int k = 1 ; k <= m ; ++ k) {
        int mx = -1, pos = 0;
        for(int i = 1 ; i <= m ; ++ i) 
            if(st[i] && cnt[i] > mx) mx = cnt[i], pos = i;
        ans = min(ans, mx);
        st[pos] = false;
        for(int i = 1 ; i <= n ; ++ i) {
            if(a[i][cur[i]] == pos) {
                while(cur[i] < m && !st[a[i][cur[i]]]) ++ cur[i];
                ++ cnt[a[i][cur[i]]];
            }
        }
    }
    ```
* **代码解读**：`st`数组标记是否删除，`cur[i]`记录当前选择。每次找到最大人数项目`pos`，删除后，选`pos`的人`cur[i]++`（直到找到未删项目），并更新`cnt`。
* 💡 **学习笔记**：`st`和`cur`的配合使用，清晰展示了状态变化。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解贪心删除过程，我们设计一个“像素运动会”动画，用8位像素风格展示项目删除和人员转移！
</visualization_intro>

  * **动画演示主题**：`像素运动会：贪心删除大作战`

  * **核心演示内容**：初始时所有项目（彩色方块）亮起，小像素人站在自己最喜欢的项目前。每次找到人数最多的项目（红色高亮），删除它（变灰），对应小像素人移动到下一个未删项目（绿色方块），更新各项目人数（方块颜色深浅变化）。

  * **设计思路简述**：8位像素风（FC游戏风格）营造轻松氛围，颜色深浅表示人数（越深人越多）。删除时的“叮”音效强化操作记忆，小像素人移动动画直观展示选择变化，帮助理解贪心策略的每一步。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧：M个彩色方块（项目），颜色从浅绿（0人）到深红（人数最多）。
          * 屏幕右侧：N个小像素人（黄色），每个小人脚下有箭头指向自己当前选择的项目。
          * 控制面板：单步/自动按钮、速度滑块（1-5倍速）、重置按钮。

    2.  **初始状态**：
          * 所有项目方块亮起（非灰色），小人指向`A[i][1]`项目。
          * 项目方块旁显示人数（如“项目1: 3人”）。

    3.  **贪心删除过程**：
          * **步骤1（统计人数）**：所有小人头顶出现数字（当前选择的项目编号），对应项目方块颜色变深（人数增加）。
          * **步骤2（找到最大项目）**：人数最多的项目方块闪烁红色，伴随“滴滴”提示音。
          * **步骤3（删除项目）**：该项目变灰，小人头顶数字消失，伴随“噗”音效。
          * **步骤4（更新选择）**：原属该项目的小人（头顶红色标记）开始移动：向右走（对应`pos[i]++`），直到找到非灰色项目（绿色方块），停下并指向新项目，伴随“哒”音效。
          * **步骤5（更新人数）**：新项目方块颜色变深，显示新人数，原项目人数归零（灰色）。

    4.  **AI自动演示**：点击“自动播放”，动画按设定速度自动执行删除过程，学习者可观察每一步的人数变化。

    5.  **目标达成**：当只剩1个项目时，该项目方块闪烁金色，伴随“胜利”音效，显示最终答案（最大人数的最小值）。

  * **旁白提示**：
      * （统计时）“现在统计各项目的人数，颜色越深人越多哦～”
      * （删除时）“这个项目人最多，我们把它删掉！”
      * （移动时）“看！这些小人要去下一个喜欢的项目啦～”

<visualization_conclusion>
通过这个像素动画，我们能清晰看到贪心策略的每一步：删除最大项目→人员转移→更新人数，直观理解“为什么每次删最大项目能得到最优解”。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法在“最优化”问题中应用广泛，本题的“每次删最大”策略可迁移到其他需要“最小化最大值”的场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 任务分配问题：如将任务分配给多个工人，最小化最大工作时间（每次给当前最闲的工人分配任务）。
      * 资源分配问题：如将资源分配给多个项目，最小化最大资源需求（每次调整资源最多的项目）。
      * 调度问题：如安排课程时间，最小化教室最大使用次数（每次调整使用最多的教室）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1080 国王游戏**
          * 🗣️ **推荐理由**：考察贪心策略在“最大化最小值”问题中的应用，需排序和数学证明，与本题思路有共通性。
    2.  **洛谷 P2212 树网的核**
          * 🗣️ **推荐理由**：需要贪心选择树网的核，最小化与其他节点的距离，训练贪心策略的灵活运用。
    3.  **洛谷 P1223 排队接水**
          * 🗣️ **推荐理由**：基础贪心题，通过排序最小化总等待时间，适合巩固贪心思维。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，如指针越界或重复删除。例如，作者Ebola提到：“一开始没考虑`pos[i]`超过`m`的情况，导致数组越界。后来加了`if(!A[i][pos[i]]) continue`才解决。”
</insights_intro>

> **参考经验 (来自Ebola)**：“在维护`pos[i]`时，要确保不越界。当所有项目被删除时，`A[i][pos[i]]`会是0，这时候需要跳过统计。”
>
> **点评**：这位作者的经验很实用！在处理指针或数组索引时，一定要考虑边界情况（如`pos[i] > m`），避免越界错误。可以通过条件判断（如`if(pos[i] > m) continue`）来规避。

-----

<conclusion>
本次关于“AGC018B Sports Festival”的C++解题分析就到这里。希望这份学习指南能帮助大家理解贪心算法的应用，掌握指针维护和数组统计的技巧。记住，多动手模拟和调试是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：136.66秒
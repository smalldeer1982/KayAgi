# 题目信息

# [AGC018B] Sports Festival

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc018/tasks/agc018_b

高橋君は、スポーツ大会を開こうと考えています。 スポーツ大会に参加するのは、$ 1 $ から $ N $ までの番号のついた $ N $ 人の人です。 また、大会で行うスポーツとして、$ 1 $ から $ M $ までの番号のついた $ M $ 個のスポーツが候補に上がっています。 高橋君は、これらの中から $ 1 $ つ以上（全てでもよい）のスポーツを選んで、スポーツ大会で実施します。

高橋君は、人 $ i $ が、$ j $ 番目に好きなスポーツが $ A_{ij} $ であることを知っています。 それぞれの人は、スポーツ大会で実施されるスポーツのうち、自分が最も好きなスポーツだけに参加し、他のスポーツには参加しません。

高橋君は、一つのスポーツにたくさんの人が集まり過ぎることを懸念しています。 そこで高橋君は、スポーツ大会で実施するスポーツをうまく選んで、最も多くの人が参加しているスポーツの参加人数を最小化したくなりました。 最も多くの人が参加しているスポーツの参加人数の最小値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ M\ \leq\ 300 $
- $ A_{i1} $ , $ A_{i2} $ , $ ... $ , $ A_{iM} $ は、$ 1 $ から $ M $ の順列である。

### Sample Explanation 1

スポーツ $ 1 $,$ 3 $,$ 4 $ を実施することにすると、人 $ 1 $ はスポーツ $ 1 $ に、人 $ 2 $ はスポーツ $ 3 $ に、 人 $ 3 $ はスポーツ $ 3 $ に、人 $ 4 $ はスポーツ $ 4 $ に参加します。 このとき、参加人数が最大のスポーツはスポーツ $ 3 $ で、その参加人数 $ 2 $ 人です。 また、参加人数が最大のスポーツの参加人数が $ 1 $ 人になるような方法は存在しないので、この例の答えは $ 2 $ になります。

### Sample Explanation 2

全員の好みが一致しているので、どうやっても一つのスポーツに $ 3 $ 人集まってしまいます。 よってこの例の答えは $ 3 $ です。

## 样例 #1

### 输入

```
4 5

5 1 3 4 2

2 5 3 1 4

2 3 1 4 5

2 5 4 3 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3

2 1 3

2 1 3

2 1 3```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：AGC018B Sports Festival 深入学习指南 💡

<introduction>
今天我们来一起分析“AGC018B Sports Festival”这道C++编程题。本指南将帮助大家理解题目核心、掌握贪心算法的应用，并通过代码赏析和可视化演示，直观感受算法流程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
解决这道题的关键在于理解贪心策略的应用。贪心算法的核心思想是“每一步选择当前最优的局部解，最终逼近全局最优”。就像分糖果时，先满足最饿的小朋友，这样整体的满意度可能更高。在本题中，我们需要让“参加人数最多的项目的人数尽可能小”，因此每次删除当前参与人数最多的项目（因为保留它无法减少最大值），让这些人转移到次优项目，逐步逼近最优解。

- **题解思路**：所有题解均采用贪心策略：初始选择所有项目，统计各项目人数；删除当前人数最多的项目，更新每个人的选择（后移指针到未被删除的项目）；重复此过程，记录每一步的最大值，取最小值。
- **核心难点**：如何高效维护每个人的当前选择（避免重复遍历）、如何快速统计各项目人数。优质题解通过维护“指针”（如`pos[i]`表示第i个人当前选择的项目位置）解决此问题。
- **可视化设计**：采用8位像素风动画，用不同颜色的像素块表示项目（红色块表示当前人数最多的项目），指针用白色箭头表示，每次删除时红色块消失，箭头右移，伴随“叮”的音效；队列用堆叠的像素方块展示人数变化。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的思路清晰度、代码规范性、算法有效性等维度评估，以下3篇题解因逻辑简洁、实现高效且易于学习，被选为优质题解（评分≥4星）：
</eval_intro>

**题解一：作者Ebola（赞：6）**
* **点评**：此题解思路清晰，通过维护每行的指针（`pos[i]`）避免重复遍历，复杂度O(nm)，是最优实现之一。代码中`pos[i]`记录第i个人当前选择的项目位置，`vis`数组标记已删除的项目，每次删除后仅更新受影响的指针，高效且易理解。变量命名如`pos`（位置）、`cnt`（计数）含义明确，边界处理严谨（如`while(vis[A[i][pos[i]]]) pos[i]++`确保指针有效）。实践价值高，可直接用于竞赛。

**题解二：作者Umbrella_Leaf（赞：4）**
* **点评**：此题解代码简洁，逻辑直白。`now[i]`记录第i个人当前选择的项目位置，`cnt`数组统计各项目人数，每次删除最大值后更新指针。代码结构工整（如初始化`now[i]=1`、循环删除`m`次），变量命名直观（如`maxx`表示当前最大人数），适合新手学习贪心策略的基础实现。

**题解三：作者Solve::Tokai__Teio（赞：1）**
* **点评**：此题解详细注释了每一步的作用，逻辑推导清晰（如“一开始将所有的活动选上”）。通过`st`数组标记删除状态，`cur`数组维护当前选择位置，代码模块化（如`read`函数处理输入），可读性强。特别适合理解贪心策略的完整流程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题的过程中，以下三个关键点需要重点突破：
</difficulty_intro>

1.  **关键点1：如何维护每个人的当前选择？**
    * **分析**：每个人的选择是动态变化的（当项目被删除时，需后移指针到下一个未被删除的项目）。优质题解通过维护指针（如`pos[i]`）实现高效更新：每次删除项目后，仅需检查并移动受影响的指针（即原选择被删除的人的指针），避免遍历所有项目。
    * 💡 **学习笔记**：指针是动态维护状态的关键工具，能显著降低时间复杂度。

2.  **关键点2：如何快速统计各项目的参与人数？**
    * **分析**：统计人数时，直接遍历每个人的当前选择（通过指针定位），累加对应项目的计数。优质题解使用`cnt`数组记录各项目人数，每次删除后仅重置`cnt`数组，避免重复计算。
    * 💡 **学习笔记**：数组是高效统计频率的常用数据结构，合理使用能简化逻辑。

3.  **关键点3：贪心策略的正确性证明**
    * **分析**：每次删除当前人数最多的项目是必要的。假设不删除它，其人数不会减少，最大值仍由它决定；删除后，原参与者转移到次优项目，可能分散人数，降低最大值。数学归纳法可证明此策略的正确性（初始状态和递推步骤均成立）。
    * 💡 **学习笔记**：贪心策略的正确性需通过逻辑推导或数学证明，避免“想当然”。

### ✨ 解题技巧总结
- **指针维护**：用指针记录每个人的当前选择，动态更新，避免重复遍历。
- **数组统计**：用数组快速统计各项目人数，时间复杂度O(n)。
- **边界处理**：删除项目后，需确保指针不越界（如`while(vis[A[i][pos[i]]]) pos[i]++`）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路提炼的通用核心实现，结合了Ebola题解的高效指针维护和Umbrella_Leaf题解的简洁结构。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Ebola和Umbrella_Leaf的思路，通过维护指针和标记数组，高效实现贪心策略。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 310;
    int A[N][N], pos[N], cnt[N];
    bool vis[N]; // 标记已删除的项目

    int main() {
        int n, m;
        cin >> n >> m;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                cin >> A[i][j];
            }
            pos[i] = 1; // 初始指向第一个项目
        }
        int ans = INT_MAX;
        while (true) {
            int mx = 0, cc = 0; // 当前最大人数及对应项目
            memset(cnt, 0, sizeof(cnt));
            for (int i = 1; i <= n; ++i) {
                while (vis[A[i][pos[i]]]) pos[i]++; // 跳过已删除的项目
                if (A[i][pos[i]] == 0) continue; // 无可用项目（理论不会发生）
                cnt[A[i][pos[i]]]++;
                if (cnt[A[i][pos[i]]] > mx) {
                    mx = cnt[A[i][pos[i]]];
                    cc = A[i][pos[i]];
                }
            }
            if (mx == 0) break; // 所有项目已删除
            ans = min(ans, mx);
            vis[cc] = true; // 删除当前最大人数项目
            for (int i = 1; i <= n; ++i) {
                if (A[i][pos[i]] == cc) pos[i]++; // 更新受影响的指针
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并初始化每个人的指针（`pos[i]=1`）。通过循环不断执行以下步骤：统计各项目人数（跳过已删除项目），找到当前最大人数的项目，删除它并更新受影响的指针，记录过程中的最小值。最终输出最小的最大值。

---
<code_intro_selected>
接下来分析优质题解的核心片段：
</code_intro_selected>

**题解一：作者Ebola**
* **亮点**：维护`pos[i]`指针，仅更新受影响的指针，复杂度O(nm)。
* **核心代码片段**：
    ```cpp
    while (vis[A[i][pos[i]]]) pos[i]++;
    cnt[A[i][pos[i]]]++;
    if (cnt[A[i][pos[i]]] > mx) cc = A[i][pos[i]], mx = cnt[cc];
    ```
* **代码解读**：
    这三行是核心逻辑：`while`循环确保指针指向未被删除的项目；`cnt`统计人数；最后更新最大值和对应项目。`pos[i]`的动态维护避免了重复遍历所有项目，是高效的关键。
* 💡 **学习笔记**：指针的动态维护是降低时间复杂度的核心技巧。

**题解二：作者Umbrella_Leaf**
* **亮点**：代码简洁，变量命名直观（如`now[i]`表示当前选择位置）。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++)
        if(a[i][now[i]]==x){
            while(now[i]<m&&!vis[a[i][now[i]]])now[i]++;
            cnt[a[i][now[i]]]++;
        }
    ```
* **代码解读**：
    当项目`x`被删除后，遍历所有原选择`x`的人，后移`now[i]`直到找到未被删除的项目，并更新`cnt`。`now[i]<m`确保指针不越界，边界处理严谨。
* 💡 **学习笔记**：边界条件（如`now[i]<m`）需特别注意，避免数组越界错误。

**题解三：作者Solve::Tokai__Teio**
* **亮点**：注释详细，逻辑清晰（如“一开始将所有的活动选上”）。
* **核心代码片段**：
    ```cpp
    for(int i=1 ; i <= m ; ++ i) st[i] = true; // 初始全选
    for(int i=1 ; i <= n ; ++ i) cur[i] = 1, ++ cnt[a[i][1]]; // 初始统计
    ```
* **代码解读**：
    初始化`st`数组标记项目状态（初始全选），`cur`数组记录当前选择位置，`cnt`统计初始人数。这一步是贪心的起点，确保后续删除操作基于正确的初始状态。
* 💡 **学习笔记**：初始化是算法正确执行的基础，需仔细处理。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解贪心过程，我们设计一个“像素运动节”动画，用8位复古风格展示每次删除项目的过程。
</visualization_intro>

  * **动画演示主题**：`像素运动节的项目删减`

  * **核心演示内容**：展示每次删除当前人数最多的项目时，指针移动、人数变化的过程。

  * **设计思路简述**：8位像素风（FC红白机风格）营造轻松氛围；颜色标记项目状态（绿色未删除，红色已删除）；指针用白色箭头表示；人数用堆叠的像素方块展示（方块数=人数）。关键操作（如删除、指针移动）伴随“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        * 屏幕分为左右两部分：左侧是M个像素块（代表项目，绿色），右侧是N个小人（代表参与者，每个小人头顶白色箭头指向其当前选择的项目）。
        * 控制面板：单步/自动按钮、速度滑块（1-5倍速）、重置按钮。

    2.  **初始状态**：
        * 所有项目为绿色，每个小人的箭头指向其第一个项目（A[i][1]）。
        * 每个项目下方显示人数（如“项目1: 3人”）。

    3.  **删除最大项目**：
        * 高亮当前人数最多的项目（红色闪烁），播放“叮”音效。
        * 该项目变为红色（标记删除），所有指向它的箭头右移（指针后移），直到找到下一个绿色项目，伴随“唰”的音效。
        * 新的项目人数更新（堆叠方块数增加），下方数字同步变化。

    4.  **自动演示模式**：
        * 点击“自动播放”，算法自动执行删除操作，速度由滑块控制（如1倍速每秒删除1次）。

    5.  **结束状态**：
        * 当所有项目删除完毕，屏幕显示最终答案（最小最大值），播放“胜利”音效（如《超级玛丽》通关音）。

  * **旁白提示**：
      * （初始状态）“现在所有项目都被选中，每个小人选择自己最喜欢的项目。”
      * （删除时）“当前项目X有最多人参加（XX人），我们删除它，小人们会选择下一个未被删除的项目。”
      * （指针移动时）“看！小人的箭头右移了，他现在选择项目Y。”

<visualization_conclusion>
通过这样的动画，我们可以直观看到贪心策略如何逐步降低最大人数，理解指针维护和人数统计的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法在“最优化问题”中应用广泛，以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 贪心策略适用于“每一步选择局部最优”的问题，如活动选择（选结束最早的活动）、任务调度（按优先级排序）、资源分配（优先满足最紧急需求）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1223 排队接水**
          * 🗣️ **推荐理由**：贪心选择接水时间短的人先接，最小化总等待时间。与本题类似，需每一步选择局部最优。
    2.  **洛谷 P1803 凌乱的yyy / 线段覆盖**
          * 🗣️ **推荐理由**：贪心选择结束时间早的活动，最大化活动数。练习贪心策略的正确性证明。
    3.  **洛谷 P2240 木材加工**
          * 🗣️ **推荐理由**：贪心+二分，寻找最大可能的切割长度。练习贪心与其他算法的结合。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，例如指针越界或未正确更新`pos[i]`。例如，作者Ebola提到“一开始未处理指针越界，导致数组访问错误”。
</insights_intro>

> **参考经验 (来自Ebola)**：“在调试时发现，当`pos[i]`超过`m`时会访问无效内存，后来添加了`while(vis[A[i][pos[i]]]) pos[i]++`的边界检查，确保指针有效。”

**点评**：这位作者的经验提醒我们，指针操作时需特别注意边界条件（如`pos[i] <= m`），避免越界错误。调试时可通过打印`pos[i]`的值，快速定位问题。

-----

<conclusion>
本次关于“AGC018B Sports Festival”的分析就到这里。通过贪心策略的学习、代码赏析和可视化演示，相信大家已掌握核心思路。记住，贪心的关键在于证明每一步选择的正确性，而指针和数组是实现高效的利器。下次见！💪
</conclusion>

-----

---
处理用时：134.28秒
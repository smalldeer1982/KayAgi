# 题目信息

# [ABC061D] Score Attack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc061/tasks/abc061_d

$ N $ 頂点 $ M $ 辺の重み付き有向グラフがあります。   
 $ i(1≦i≦M) $ 番目の辺は 頂点 $ a_i $ から 頂点 $ b_i $ を重み $ c_i $ で結びます。   
 このグラフと駒を利用して、次の1人ゲームを行います。

最初、駒を頂点 $ 1 $ に置いて、プレイヤーのスコアを $ 0 $ とします。   
 プレイヤーは、次の条件で駒を繰り返し移動させることができます。

- 頂点 $ a_i $ に駒があるとき、$ i $ 番目の辺を利用して頂点 $ b_i $ に移動する。移動後にプレイヤーのスコアが $ c_i $ 加算される。

頂点 $ N $ に駒があるときのみ、ゲームを終了できます。   
 なお、与えられる有向グラフの上で頂点 $ 1 $ から頂点 $ N $ に移動できることは保障されています。

プレイヤーがゲーム終了時のスコアを出来るだけ大きくするような行動を取ったとき、ゲーム終了時のスコアはいくつになるでしょうか?   
 ゲーム終了時のスコアをいくらでも大きくできる場合は `inf` と出力してください。

## 说明/提示

### 制約

- $ 2≦N≦1000 $
- $ 1≦M≦min(N(N-1),2000) $
- $ 1≦a_i,b_i≦N\ (1≦i≦M) $
- $ a_i≠b_i\ (1≦i≦M) $
- $ a_i≠a_j $ または $ b_i≠b_j\ (1≦i\ <\ j≦M) $
- $ -10^9≦c_i≦10^9\ (1≦i≦M) $
- $ c_i $ は整数である。
- 与えられるグラフには、頂点 $ 1 $ から頂点 $ N $ への経路が存在する。

### Sample Explanation 1

駒を頂点 $ N=3 $ に移動できる経路は以下の $ 2 $ 通りです。 - 頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 3 $ : スコア $ 4+3=7 $ - 頂点 $ 1 $ → 頂点 $ 3 $ : スコア $ 5 $ したがって、ゲーム終了時のスコアの最大値は $ 7 $ となります。

### Sample Explanation 2

頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 2 $ … と移動することで、ゲーム終了時のスコアをいくらでも増やせます。

## 样例 #1

### 输入

```
3 3

1 2 4

2 3 3

1 3 5```

### 输出

```
7```

## 样例 #2

### 输入

```
2 2

1 2 1

2 1 1```

### 输出

```
inf```

## 样例 #3

### 输入

```
6 5

1 2 -1000000000

2 3 -1000000000

3 4 -1000000000

4 5 -1000000000

5 6 -1000000000```

### 输出

```
-5000000000```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC061D] Score Attack 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC061D] Score Attack”这道C++编程题。这道题围绕有向图的最长路径问题展开，核心是判断是否存在能无限增加分数的正权环。本指南将帮助大家梳理题目思路，理解SPFA算法的应用，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（最长路径与正权环检测）

🗣️ **初步分析**：
> 解决“Score Attack”这道题，关键在于理解如何用图论中的最短路径算法（SPFA）来解决最长路径问题，并检测是否存在影响终点的正权环。简单来说，最长路径问题可以通过将边权取反转化为最短路径问题——原问题的“最长”对应转化后的“最短”，原问题的“正权环”对应转化后的“负权环”。在本题中，SPFA算法（Shortest Path Faster Algorithm）被用来检测负权环，进而判断是否存在能无限增加分数的正权环。
   - 题解思路：将所有边权取反（原问题求最长路径→转化为求最短路），用SPFA算法计算从1到N的最短路径。若在SPFA过程中发现终点N处于负权环中（即原问题的正权环），则输出“inf”；否则输出转化后的最短路径的相反数（即原问题的最长路径）。
   - 核心难点：如何正确判断负权环是否在从1到N的路径上（即该环是否会影响终点N的分数）。常见误区是仅检测图中是否存在负权环，而忽略了环与终点的可达性。
   - 核心算法流程：SPFA通过队列优化的Bellman-Ford算法，记录每个节点的入队次数。若某个节点的入队次数≥N（节点数），则说明存在负权环。若该环中的节点能到达终点N，则原问题存在无限分数的可能。
   - 可视化设计：采用8位像素风格，用不同颜色的像素方块表示节点（如起点为绿色，终点为红色，环中的节点闪烁黄色），边用箭头连接并标注权值。动画中，SPFA的队列操作（节点入队/出队）用滑动动画展示，距离更新时对应节点颜色变亮，检测到环时节点闪烁并播放提示音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：来源：zerc（赞：4）**
* **点评**：这份题解思路非常清晰，精准指出了常见误区（仅检测正权环而不考虑其是否在1到N的路径上），并通过边权取反转化为最短路问题，用SPFA算法检测负权环。代码中变量命名（如`dis`表示距离，`vis`表示访问标记）规范易懂，关键逻辑（负环检测）的实现简洁高效。算法上，SPFA在本题约束下（N≤1000，M≤2000）时间复杂度可控，且正确处理了环与终点的可达性。实践价值高，代码可直接用于竞赛，边界处理严谨（如初始距离的设置）。作者对“正环是否影响终点”的强调，是本题的核心关键点，对学习者有重要启发。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何将最长路径问题转化为最短路径问题？
    * **分析**：原问题要求最长路径，直接求解最长路径在存在正权环时可能无限大。通过将所有边权取反（原边权c_i变为-c_i），最长路径问题转化为最短路径问题。此时，原问题的“正权环”对应转化后的“负权环”，若存在这样的环且能到达终点N，则原问题分数可无限增加。
    * 💡 **学习笔记**：边权取反是处理最长路径问题的常用技巧，将问题转化为更易处理的最短路径问题。

2.  **关键点2**：如何正确检测负权环是否影响终点N？
    * **分析**：SPFA算法通过记录每个节点的入队次数来检测负权环（入队次数≥N时存在环）。但需注意，仅检测到环是不够的，还需判断该环是否在从1到N的路径上。题解中通过标记环中的节点（如`inq[v]`标记），并最终检查终点N是否被标记，确保环能影响终点。
    * 💡 **学习笔记**：环的检测需结合其与目标节点的可达性，否则可能误判。

3.  **关键点3**：SPFA算法的实现细节（如队列操作、距离更新）？
    * **分析**：SPFA使用队列优化Bellman-Ford，每次从队列中取出节点u，遍历其邻接边，尝试更新邻接节点v的距离。若更新成功且v不在队列中，则将v入队。入队次数超过N次时，说明存在负权环。
    * 💡 **学习笔记**：SPFA的效率依赖于图的稀疏性，本题约束下（M≤2000）是可行的。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧：
</summary_best_practices>
-   **问题转化**：将最长路径问题转化为最短路径问题（边权取反），简化问题模型。
-   **环的可达性判断**：检测到环后，需确认其是否在目标路径上（如本题中是否能到达终点N）。
-   **SPFA的灵活应用**：利用SPFA的队列特性，记录入队次数以检测负权环，结合标记数组判断环的影响范围。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解zerc的思路，通过边权取反转化为最短路径问题，使用SPFA检测负权环，判断终点是否在环中。代码逻辑清晰，适合作为竞赛参考。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <queue>
    #include <vector>
    #define INF 1e18
    using namespace std;

    struct Edge {
        int to, val;
        Edge(int t, int v) : to(t), val(v) {}
    };

    int n, m;
    vector<vector<Edge>> adj;
    vector<long long> dis;
    vector<int> vis, inq, tot;

    bool spfa() {
        dis.assign(n + 1, INF);
        vis.assign(n + 1, 0);
        inq.assign(n + 1, 0);
        tot.assign(n + 1, 0);
        queue<int> q;
        dis[1] = 0;
        q.push(1);
        vis[1] = 1;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for (auto &e : adj[u]) {
                int v = e.to;
                long long new_dis = dis[u] + e.val;
                if (new_dis < dis[v]) {
                    dis[v] = new_dis;
                    if (!vis[v]) {
                        q.push(v);
                        vis[v] = 1;
                        tot[v]++;
                        if (tot[v] >= n) {
                            inq[v] = 1; // 标记负环中的节点
                        }
                    }
                }
            }
        }
        // 检查终点N是否在负环中，或被负环中的节点可达
        queue<int> reach;
        vector<int> can_reach(n + 1, 0);
        reach.push(n);
        can_reach[n] = 1;
        while (!reach.empty()) {
            int u = reach.front();
            reach.pop();
            for (auto &e : adj[u]) {
                int v = e.to;
                if (!can_reach[v]) {
                    can_reach[v] = 1;
                    reach.push(v);
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            if (inq[i] && can_reach[i]) {
                return true;
            }
        }
        return false;
    }

    int main() {
        cin >> n >> m;
        adj.resize(n + 1);
        for (int i = 0; i < m; i++) {
            int a, b, c;
            cin >> a >> b >> c;
            adj[a].emplace_back(b, -c); // 边权取反，求最短路径
        }
        bool has_inf = spfa();
        if (has_inf) {
            cout << "inf" << endl;
        } else {
            cout << -dis[n] << endl; // 转化回原问题的最长路径
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入并构建邻接表（边权取反）。SPFA函数初始化距离数组`dis`，使用队列处理节点，更新最短路径。通过`tot[v]`记录节点入队次数，若≥n则标记`inq[v]`（负环中的节点）。随后，通过反向BFS判断负环节点是否能到达终点N。若存在这样的环，输出“inf”；否则输出转化后的最短路径的相反数（原问题的最长路径）。

---
<code_intro_selected>
接下来，我们将剖析题解zerc的核心代码片段，并点出其亮点和关键思路。
</code_intro_selected>

**题解一：来源：zerc**
* **亮点**：通过SPFA检测负权环，并标记环中的节点，结合反向BFS判断环是否能到达终点N，避免了仅检测环而不考虑可达性的误区。
* **核心代码片段**：
    ```cpp
    bool spfa() {
        for (int i = 2; i <= n; i++) dis[i] = inf;
        dis[1] = 0, vis[1] = 1, q.push(1);
        while (!q.empty()) {
            int u = q.front(); q.pop(); vis[u] = 0;
            for (int i = head[u]; i; i = e[i].nxt) {
                int v = e[i].to;
                if (inq[v]) continue;
                if (dis[v] > dis[u] + e[i].val) {
                    dis[v] = dis[u] + e[i].val;
                    if (!vis[v]) {
                        vis[v] = 1, q.push(v);
                        if (++tot[v] >= n) {
                            inq[v] = 1;  // 标记负环
                        }
                    }
                }
            }
        }
        return inq[n];
    }
    ```
* **代码解读**：
    > 这段代码是SPFA的核心逻辑。初始化时，除起点外的所有节点距离设为无穷大。队列处理当前节点u，遍历其邻接边，尝试更新邻接节点v的距离。若更新成功且v不在队列中，则将v入队并记录入队次数。当v的入队次数≥n时，标记`inq[v]`为1（表示v在负环中）。最后返回`inq[n]`，判断终点是否在负环中。需注意，原代码未完全处理环的可达性（如样例2中需要环能到达终点），完整实现需结合反向BFS（如通用代码中的处理）。
* 💡 **学习笔记**：SPFA的负环检测需结合环的可达性判断，否则可能误判。标记环中的节点后，需确认这些节点能否到达终点。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解SPFA算法和负环检测的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素探险家长途旅行——寻找最大分数的宝藏`

  * **核心演示内容**：`SPFA算法如何从起点1出发，逐步更新各节点的最短距离（转化后的边权），检测负权环，并判断环是否能到达终点N`

  * **设计思路简述**：采用8位像素风（如FC游戏画面），用不同颜色的像素方块表示节点（起点绿色、终点红色、环中节点黄色闪烁），边用箭头连接并标注权值。动画通过队列操作、距离更新、环检测的动态展示，配合音效和旁白，帮助学习者直观理解SPFA的核心逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：
          * 屏幕中央展示像素化的图（节点为16x16像素方块，边为箭头），节点1（绿色）、节点N（红色）、其他节点（灰色）。
          * 控制面板包含“开始/暂停”、“单步”、“重置”按钮，速度滑块（0.5x-2x）。
          * 背景播放8位风格的轻快音乐（如《超级马里奥》的经典旋律）。

    2.  **算法启动与数据初始化**：
          * 节点1的距离`dis[1]`设为0（绿色方块旁显示“0”），其他节点距离设为无穷大（显示“∞”）。
          * 队列初始化为[1]，队列用像素堆叠的方块表示（顶部为当前处理节点）。

    3.  **SPFA核心步骤动态演示**：
          * **节点出队**：队列顶部的节点u（如节点1）弹出，u的像素方块颜色变浅（表示处理中），播放“叮”的音效。
          * **遍历邻接边**：u的邻接边箭头闪烁（黄色），依次处理每条边（如1→2，权值-4）。
          * **距离更新**：若通过u到v的路径更短（如`dis[2]`从∞更新为0+(-4)=-4），v的距离显示更新，像素方块颜色变亮（蓝色），播放“滴”的音效。
          * **节点入队**：v（如节点2）未在队列中时，滑入队列末尾，像素方块颜色恢复（灰色），播放“唰”的音效。
          * **负环检测**：当节点v的入队次数≥n时，v的像素方块开始黄色闪烁，播放“警报”音效，旁白提示“发现负权环！”。

    4.  **环的可达性判断**：
          * 反向BFS从终点N（红色）出发，用蓝色箭头标记能到达N的节点（如环中的节点v）。若环中的节点被标记，N的像素方块开始红色闪烁，旁白提示“环能到达终点，分数可无限增加！”。

    5.  **结果展示**：
          * 若检测到环能到达N，屏幕中央显示“inf”，播放胜利音效（如《魂斗罗》的胜利旋律）。
          * 否则，显示最长路径分数（如-`dis[N]`），终点N的像素方块显示分数，播放“叮咚”音效。

  * **旁白提示**：
      * （节点出队时）“现在处理节点u，它的邻接边需要检查啦～”
      * （距离更新时）“发现更短路径！节点v的距离更新为新值～”
      * （检测到环时）“注意！节点v入队次数太多，可能存在负权环哦～”
      * （环可达终点时）“环能到达终点！分数可以无限增加，输出‘inf’～”

<visualization_conclusion>
通过这样一个融合了像素艺术和复古游戏元素的动画，我们不仅能清晰地看到SPFA算法的执行流程，还能在轻松有趣的环境中理解负环检测和可达性判断的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考图论中最长路径、负环检测的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：

      * SPFA算法不仅用于最短路径，还可检测负权环，适用于处理存在负权边的图论问题（如差分约束系统）。
      * 边权取反转化最长路径的方法，可推广到其他需要最大化/最小化目标值的问题（如资源收集类游戏中的最大收益）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P3385** - `【模板】负环`
          * 🗣️ **推荐理由**：这道题是负环检测的模板题，可以帮助你巩固SPFA算法的应用，理解负环检测的核心逻辑。
    2.  **洛谷 P1186** - `司机配对问题`
          * 🗣️ **推荐理由**：此题涉及图的最长路径问题，需要结合二分图匹配和最长路径的转化，是思维拓展的好选择。
    3.  **洛谷 P4779** - `【模板】单源最短路径（标准版）`
          * 🗣️ **推荐理由**：此题是Dijkstra算法的模板题，对比SPFA和Dijkstra的适用场景，能帮助你更深入理解不同最短路径算法的特点。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中包含了作者对常见误区的提醒，这些经验对我们有重要参考价值：
</insights_intro>

> **参考经验 (来自 zerc)**：“分数无限增加一定是有正环，但有正环分数就一定会无限增加么？如果有一个正环，但从1到n的路径上并不会经过，那么他对答案是没有影响的。”
>
> **点评**：这位作者的经验非常关键！在处理图论问题时，不仅要检测环的存在，更要判断环是否在目标路径上。这提醒我们，在分析问题时需关注“环与目标的关联性”，避免因忽略可达性而导致错误。实际编码中，可通过反向BFS或DFS来验证环的影响范围，确保逻辑严谨。

-----

<conclusion>
本次关于“[ABC061D] Score Attack”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解图论中的最长路径问题、SPFA算法的应用，以及负环检测的关键技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：157.61秒
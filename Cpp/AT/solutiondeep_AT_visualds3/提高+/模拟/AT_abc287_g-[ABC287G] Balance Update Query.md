# 题目信息

# [ABC287G] Balance Update Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc287/tasks/abc287_g

高橋君は $ N $ 種類のカードを $ 10^{100} $ 枚ずつ持っています。はじめ、$ i $ 種類目のカードの得点は $ a_i $ で、使用可能枚数は $ b_i $ です。

以下の形式のクエリが $ Q $ 個与えられるので、順に処理してください。

- `1 x y` : $ x $ 種類目のカードの得点を $ y $ に設定
- `2 x y` : $ x $ 種類目のカードの使用可能枚数を $ y $ に設定
- `3 x` : 次の条件を満たすように $ x $ 枚のカードを選ぶことができるならば選ばれたカードの得点の総和の最大値を、そうでなければ `-1` を出力
  - どの種類のカードもその使用可能枚数を超えて選ばれない

## 说明/提示

### 制約

- $ 1\ \leq\ N,Q\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ a_i\ \leq\ 10^9 $
- $ 0\ \leq\ b_i\ \leq\ 10^4 $
- $ 1 $ 種類目のクエリにおいて $ 1\ \leq\ x\ \leq\ N,\ 0\ \leq\ y\ \leq\ 10^9 $
- $ 2 $ 種類目のクエリにおいて $ 1\ \leq\ x\ \leq\ N,\ 0\ \leq\ y\ \leq\ 10^4 $
- $ 3 $ 種類目のクエリにおいて $ 1\ \leq\ x\ \leq\ 10^9 $
- $ 3 $ 種類目のクエリが $ 1 $ 個以上含まれる
- 入力はすべて整数
 
### Sample Explanation 1

$ 1 $ 番目の $ 3 $ 種類目のクエリでは、$ 2 $ 種類目のカードを $ 1 $ 枚、$ 3 $ 種類目のカードを $ 3 $ 枚選ぶことで得点の総和が $ 11 $ となり、これが最大です。 $ 2 $ 番目の $ 3 $ 種類目のクエリでは、$ 1 $ 種類目のカードを $ 1 $ 枚、$ 3 $ 種類目のカードを $ 3 $ 枚選ぶことで得点の総和が $ 19 $ となり、これが最大です。 $ 3 $ 番目の $ 3 $ 種類目のクエリでは、$ 4 $ 枚のカードを選ぶことができないため出力は `-1` となります。 $ 4 $ 番目の $ 3 $ 種類目のクエリでは、$ 2 $ 種類目のカードを $ 2 $ 枚選ぶことで得点の総和が $ 4 $ となり、これが最大です。

## 样例 #1

### 输入

```
3

1 1

2 2

3 3

7

3 4

1 1 10

3 4

2 1 0

2 3 0

3 4

3 2```

### 输出

```
11

19

-1

4```

# AI分析结果



---
# 💡 Kay的C++算法解析：Balance Update Query 深入学习指南 💡

<introduction>
今天我们要挑战的题目是「Balance Update Query」。这道题需要我们高效处理三种操作：修改卡片得分、修改卡片可用数量、查询选x张卡片的最大得分总和。通过分析题解，我们会发现核心在于如何动态维护“前x大元素和”，这需要巧妙的数据结构设计。让我们一起拆解问题，掌握解题关键！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数据结构应用（动态维护有序序列与前缀和查询）`

🗣️ **初步分析**：
解决这道题的关键在于“贪心选择最大得分的卡片”。想象一下，每次选卡片时，我们肯定优先选得分高的——这是最直接的贪心策略。但问题是，卡片的得分和可用数量会动态变化，如何高效维护并快速查询“前x大的卡片总和”？

### 核心算法与题解思路对比
主流题解采用以下思路：
- **值域线段树/树状数组**：将得分离散化后，用线段树或树状数组维护每个得分值的总数量和总得分。查询时通过二分找到“刚好能凑够x张”的得分临界点，计算总和。（如EuphoricStar、Svemit、xzy090626的题解）
- **平衡树（FHQ-Treap）**：直接维护有序序列，通过分裂操作快速查询前x大的和。（如yqr123YQR的题解）
- **值域分块**：将得分分块，每块维护总数量和总得分，查询时暴力遍历块。（如AlicX、CQ_Bob的题解）

### 可视化设计思路
我们选择**值域线段树的更新与查询过程**作为可视化核心。像素动画将用8位复古风格展示线段树节点：每个节点代表一个得分区间，颜色深浅表示该区间的总数量。更新操作（修改得分/数量）时，对应节点会闪烁并更新数值；查询时，二分过程会用箭头标记当前搜索区间，高亮临界点节点，配合“叮”的音效提示关键步骤。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法效率等维度筛选出3个优质题解，它们各有亮点，值得学习：
</eval_intro>

**题解一：线段树上二分（作者：EuphoricStar）**
* **点评**：此题解抓住了核心——用线段树维护每个得分值的总数量和总得分。思路简洁直接（贪心+线段树二分），代码逻辑清晰，时间复杂度为O((n+q)logV)，适合处理大规模数据。虽然代码未完全展开，但关键步骤（如线段树更新、二分查找）描述明确，是高效且易理解的解法。

**题解二：离散化线段树（作者：Svemit）**
* **点评**：此题解提供了完整的C++实现，代码规范（如使用vector离散化、线段树结构清晰）。通过离散化处理得分值，避免了值域过大的问题；线段树节点维护数量和总和，查询时通过右子树优先的二分快速计算前x大的和。边界处理严谨（如判断总数量是否足够），实践参考价值高。

**题解三：树状数组+二分（作者：xzy090626）**
* **点评**：此题解用树状数组替代线段树，利用树状数组的低常数优势。通过“得分+1”解决0值问题，思路巧妙；树状数组上二分查找临界点，时间复杂度O((n+q)log²(n+q))，实际运行效率高。代码虽稍显复杂，但关键步骤（如add/ask函数）注释清晰，适合学习树状数组的灵活应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要突破以下关键难点：
</difficulty_intro>

1.  **难点1：如何高效维护动态变化的得分与数量？**
    * **分析**：卡片的得分和数量会频繁修改（操作1和2），需要一种数据结构支持快速单点更新，同时能快速查询“前x大的总和”。线段树/树状数组通过离散化得分值，将得分映射到连续区间，用节点维护区间内的总数量和总得分，完美满足需求。
    * 💡 **学习笔记**：离散化是处理大范围数值问题的常用技巧，能将“稀疏”的值域压缩为“密集”的索引，降低数据结构的空间和时间复杂度。

2.  **难点2：如何快速计算前x大的卡片总和？**
    * **分析**：直接排序后取前x大的方法在动态修改时效率太低。线段树/树状数组的“二分查找”是关键：从最大得分开始，累加数量，直到总数量≥x。此时，最大的部分全选，临界得分选剩余数量。
    * 💡 **学习笔记**：二分查找在有序结构中能快速定位临界点，结合前缀和计算，是解决“前x大总和”问题的通用思路。

3.  **难点3：如何处理边界条件（如总数量不足x）？**
    * **分析**：查询时需先判断所有卡片的总数量是否≥x。若不足，直接返回-1；若足够，再通过二分计算总和。线段树/树状数组的根节点维护全局总数量，可O(1)判断。
    * 💡 **学习笔记**：边界条件是编程题的“隐形陷阱”，处理时需明确所有可能情况（如x=0、总数量刚好等于x等）。

### ✨ 解题技巧总结
- **离散化预处理**：将大范围的得分值映射到小范围索引，降低数据结构复杂度。
- **数据结构选择**：线段树适合维护区间信息（如数量、总和），树状数组适合单点更新和前缀查询，平衡树适合动态有序序列。
- **二分查找优化**：在有序结构上通过二分快速定位临界点，避免遍历所有元素。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择Svemit的线段树实现作为通用核心代码，因其结构清晰、逻辑完整，适合学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了离散化、线段树维护数量和总和的思路，完整处理了三种操作，是线段树解决此类问题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int N = 4e5 + 5;

    int n, q;
    int a[N], b[N];
    struct oper { int op, x, y; } Q[N];
    vector<int> nums;

    struct SegT {
        int l, r, siz;
        ll sum;
        #define l(x) tr[x].l
        #define r(x) tr[x].r
        #define siz(x) tr[x].siz
        #define sum(x) tr[x].sum 
    } tr[N << 2];

    void build(int l, int r, int x) {
        tr[x] = {l, r, 0, 0};
        if (l == r) return;
        int mid = (l + r) / 2;
        build(l, mid, x << 1), build(mid + 1, r, x << 1 | 1);
    }

    void pushup(int x) {
        siz(x) = siz(x << 1) + siz(x << 1 | 1);
        sum(x) = sum(x << 1) + sum(x << 1 | 1);
    }

    void update(int x, int p, int v) {
        if (l(x) == r(x)) {
            siz(x) += v;
            sum(x) += 1ll * nums[p - 1] * v;
            return;
        }
        int mid = (l(x) + r(x)) >> 1;
        if (p <= mid) update(x << 1, p, v);
        else update(x << 1 | 1, p, v);
        pushup(x);
    }

    ll query(int x, int k) {
        if (!k) return 0;
        if (l(x) == r(x)) return 1ll * k * nums[l(x) - 1];
        if (siz(x << 1 | 1) >= k) return query(x << 1 | 1, k);
        else return sum(x << 1 | 1) + query(x << 1, k - siz(x << 1 | 1));
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr); cout.tie(nullptr);

        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i] >> b[i];
            nums.push_back(a[i]);
        }
        cin >> q;
        for (int i = 1; i <= q; ++i) {
            int op, x, y = 0;
            cin >> op >> x;
            if (op == 1) {
                cin >> y;
                nums.push_back(y);
            } else if (op == 2) cin >> y;
            Q[i] = {op, x, y};
        }

        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        build(1, nums.size(), 1);

        for (int i = 1; i <= n; ++i) {
            a[i] = lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin() + 1;
            update(1, a[i], b[i]);
        }

        for (int i = 1; i <= q; ++i) {
            auto [op, x, y] = Q[i];
            if (op == 1) {
                y = lower_bound(nums.begin(), nums.end(), y) - nums.begin() + 1;
                update(1, a[x], -b[x]);
                a[x] = y;
                update(1, a[x], b[x]);
            } else if (op == 2) {
                update(1, a[x], y - b[x]);
                b[x] = y;
            } else {
                if (tr[1].siz < x) cout << -1 << '\n';
                else cout << query(1, x) << '\n';
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先离散化所有得分值（包括初始值和修改值），构建线段树。线段树每个节点维护区间内卡片的总数量（siz）和总得分（sum）。操作1和2通过线段树单点更新调整数量和得分；操作3通过线段树二分查询前x大的总和，若总数量不足则返回-1。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：线段树上二分（作者：EuphoricStar）**
* **亮点**：用线段树维护数量和总和，通过二分快速定位临界点，时间复杂度高效。
* **核心代码片段**：
    ```cpp
    // 线段树节点维护区间内的总数量和总得分
    struct SegT { int l, r, siz; ll sum; } tr[N << 2];

    void update(int x, int p, int v) {
        if (l(x) == r(x)) {
            siz(x) += v;
            sum(x) += 1ll * nums[p - 1] * v; // nums是离散化后的原值数组
            return;
        }
        // 递归更新子节点，pushup维护父节点
    }

    ll query(int x, int k) {
        if (siz(x << 1 | 1) >= k) return query(x << 1 | 1, k); // 优先右子树（大值）
        else return sum(x << 1 | 1) + query(x << 1, k - siz(x << 1 | 1));
    }
    ```
* **代码解读**：
    `update`函数负责更新线段树中某个得分值的数量和总和（v是数量变化）。`query`函数递归查询前k大的总和：优先访问右子树（对应更大的得分值），若右子树数量足够则全选，否则选右子树总和并递归左子树选剩余数量。
* 💡 **学习笔记**：线段树的“右子树优先”设计是关键，确保了我们总是先选大值，符合贪心策略。

**题解二：树状数组+二分（作者：xzy090626）**
* **亮点**：树状数组的低常数优势，通过“得分+1”解决0值问题。
* **核心代码片段**：
    ```cpp
    void add(int x, int y) { // 树状数组更新数量
        for (; x < N; x += lowbit(x)) c[x] += y;
    }
    void add1(int x, int y) { // 树状数组更新总和
        for (; x < N; x += lowbit(x)) cc[x] += y;
    }

    int query(int x) { // 二分找临界点
        int l = 1, r = N - 5, cur = -1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (qry(mid, N - 5) >= x) cur = mid, l = mid + 1;
            else r = mid - 1;
        }
        // 计算总和并调整
    }
    ```
* **代码解读**：
    树状数组`c`维护数量，`cc`维护总和。`add`和`add1`函数分别更新数量和总和。`query`函数通过二分找到最大的mid，使得[mid, max]区间内的数量≥x，然后计算总和（需减去多余数量的贡献）。
* 💡 **学习笔记**：树状数组适合单点更新和前缀查询，结合二分能高效解决类似问题。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解线段树如何动态维护和查询，我们设计一个“像素得分工厂”的8位复古动画：
</visualization_intro>

  * **动画演示主题**：`像素得分工厂——线段树维护与查询`

  * **核心演示内容**：
    展示线段树节点如何随操作1（修改得分）、操作2（修改数量）更新，以及操作3（查询前x大）时的二分过程。每个节点用像素方块表示，颜色越深代表该得分区间的卡片越多。

  * **设计思路简述**：
    8位像素风格（FC红白机配色）让学习更轻松；节点闪烁提示更新，音效（如“叮”）强化操作记忆；二分过程用箭头标记，突出“优先选大值”的贪心策略。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 屏幕左侧是线段树结构（每个节点显示得分区间、数量、总和），右侧是控制面板（开始/暂停、单步、调速滑块）。
        - 播放8位风格背景音乐（如《超级马力欧》经典旋律）。

    2.  **操作1：修改得分**：
        - 原得分节点（如a[x]）闪烁红色，数量和总和减少（伴随“嗖”的音效）。
        - 新得分节点（如y）闪烁绿色，数量和总和增加（伴随“叮”的音效）。

    3.  **操作2：修改数量**：
        - 对应得分节点的数量和总和变化（如b[x]从3→5，节点数字从3→5，颜色变深）。

    4.  **操作3：查询前x大**：
        - 根节点高亮，开始二分：箭头指向右子树（大值区间），若右子树数量≥x，箭头右移；否则累加右子树总和，箭头左移。
        - 找到临界点后，该节点闪烁黄色，计算剩余数量（如右子树有3张，x=4，则选右子树3张+左子树1张）。
        - 若总数量不足x，屏幕显示“-1”并播放“呜”的提示音。

    5.  **目标达成**：
        - 查询成功时，总和数字从0逐渐增加到结果，伴随“胜利”音效（如《星之卡比》的得分音效）。

  * **旁白提示**：
    - “看！修改得分时，原得分节点的数量被减掉，新得分节点加上了~”
    - “查询时，我们优先选大的得分，所以先看右子树够不够数量哦！”

<visualization_conclusion>
通过这个动画，我们能清晰看到线段树如何动态维护卡片信息，以及二分查询的每一步逻辑，让抽象的算法变得“看得见、听得见”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是动态维护有序序列的前x大总和，这类问题在算法竞赛中很常见，我们可以通过以下练习巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 动态维护前x大/小的总和：可使用线段树、树状数组、平衡树等数据结构，关键是离散化和快速查询。
    - 处理动态修改：单点更新数据结构中的值，维护相关统计量（如数量、总和）。
    - 二分查找临界点：在有序结构中快速定位满足条件的位置。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3369 【模板】普通平衡树**
        * 🗣️ **推荐理由**：练习平衡树的插入、删除、查询前x大等操作，与本题思路相似。
    2.  **洛谷 P1908 逆序对**
        * 🗣️ **推荐理由**：用树状数组统计逆序对，练习离散化和树状数组的前缀查询。
    3.  **洛谷 P4587 [FJOI2016]神秘数**
        * 🗣️ **推荐理由**：需要动态维护前缀和，结合二分查找，锻炼数据结构的灵活应用。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了调试中的小插曲，这些经验能帮助我们少走弯路：
</insights_intro>

> **参考经验 (来自AlicX)**：“考场少写一个加号痛失AC。”
> 
> **点评**：这个教训提醒我们，代码中的小错误（如符号、变量名）可能导致全盘错误。调试时，可通过打印关键变量（如离散化后的索引、线段树的siz和sum）快速定位问题。养成“写一步、测一步”的习惯，能有效减少低级错误。

---

<conclusion>
通过这道题的分析，我们掌握了动态维护前x大总和的核心方法（线段树/树状数组+离散化+二分），并了解了不同数据结构的适用场景。编程的关键在于理解问题本质，选择合适的数据结构。接下来，不妨尝试推荐的练习题，巩固所学！下次见，加油~ 💪
</conclusion>

---
处理用时：156.58秒
# 题目信息

# [ABC307G] Approximate Equalization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc307/tasks/abc307_g

長さ $ N $ の整数列 $ A=(A_1,A_2,\ldots,A_N) $ が与えられます。

高橋君は次の $ 2 $ 種類の操作のうち $ 1 $ つを選んで行う事を、何回でも ($ 0 $ 回でも良い) 繰り返し行う事ができます。

- $ 1\leq\ i\leq\ N-1 $ をみたす整数 $ i $ を選び、$ A_i $ を $ 1 $ 減らし、$ A_{i+1} $ を $ 1 $ 増やす。
- $ 1\leq\ i\leq\ N-1 $ をみたす整数 $ i $ を選び、$ A_i $ を $ 1 $ 増やし、$ A_{i+1} $ を $ 1 $ 減らす。
 
数列 $ A $ が次の条件をみたすようにするために必要な操作の回数の最小値を求めてください。

- 任意の $ 1 $ 以上 $ N $ 以下の整数の組 $ (i,j) $ に対して、$ \lvert\ A_i-A_j\rvert\leq\ 1 $ が成り立つ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ \lvert\ A_i\ \rvert\ \leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

次のようにして $ 4 $ 回の操作で $ A $ が条件をみたすようにできます。 - $ i=1 $ を選び、$ A_1 $ を $ 1 $ 増やし、 $ A_2 $ を $ 1 $ 減らす。$ A=(3,6,6) $ となる。 - $ i=1 $ を選び、$ A_1 $ を $ 1 $ 増やし、 $ A_2 $ を $ 1 $ 減らす。$ A=(4,5,6) $ となる。 - $ i=2 $ を選び、$ A_2 $ を $ 1 $ 増やし、 $ A_3 $ を $ 1 $ 減らす。$ A=(4,6,5) $ となる。 - $ i=1 $ を選び、$ A_1 $ を $ 1 $ 増やし、 $ A_2 $ を $ 1 $ 減らす。$ A=(5,5,5) $ となる。 この時操作回数が最小であり、よって $ 4 $ を出力します。

### Sample Explanation 2

次のようにして $ 2 $ 回の操作で $ A $ が条件をみたすようにできます。 - $ i=1 $ を選び、$ A_1 $ を $ 1 $ 減らし、 $ A_2 $ を $ 1 $ 増やす。$ A=(-3,-4,-2) $ となる。 - $ i=2 $ を選び、$ A_2 $ を $ 1 $ 増やし、 $ A_3 $ を $ 1 $ 減らす。$ A=(-3,-3,-3) $ となる。 この時操作回数が最小であり、よって $ 2 $ を出力します。

### Sample Explanation 3

うまく操作することで、$ 13 $ 回の操作の後で、 $ A=(0,0,-1,-1,-1) $ にでき、これは問題文の条件をみたします。 $ 12 $ 回以下の操作で条件をみたすようにすることはできないため、$ 13 $ を出力します。

## 样例 #1

### 输入

```
3

2 7 6```

### 输出

```
4```

## 样例 #2

### 输入

```
3

-2 -5 -2```

### 输出

```
2```

## 样例 #3

### 输入

```
5

1 1 1 1 -7```

### 输出

```
13```

# AI分析结果



---
# 💡 Kay的C++算法解析：ABC307G Approximate Equalization 深入学习指南 💡

<introduction>
今天我们来一起分析这道“近似均等化”问题。题目要求通过相邻元素的加减操作，让数组中任意两数的差不超过1，并求最小操作次数。本指南将带大家梳理核心思路、解析关键算法，并通过像素动画直观理解动态规划的过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）应用

🗣️ **初步分析**：
解决这道题的关键在于理解操作的本质和最终数组的结构。每次操作是相邻元素的加减1，因此数组总和保持不变。最终数组的所有元素只能是两个值：设总和为 \( S \)，则元素只能是 \( m = \lfloor \frac{S}{n} \rfloor \) 或 \( m+1 \)，其中 \( m+1 \) 的个数为 \( S \mod n \)（若余数为负需调整）。

动态规划（DP）在这里的作用是逐步计算前 \( i \) 个元素中选取 \( j \) 个 \( m+1 \) 时的最小操作次数。核心难点是如何定义状态并推导转移方程。优质题解普遍采用二维DP数组 \( f[i][j] \)，表示前 \( i \) 个元素中有 \( j \) 个 \( m+1 \) 的最小操作次数。转移时，通过前缀和计算当前元素调整后的值，比较取 \( m \) 或 \( m+1 \) 的操作代价。

可视化设计思路：采用8位像素风格，用不同颜色的像素块表示 \( m \)（蓝色）和 \( m+1 \)（绿色）。动画中，每处理一个元素 \( i \)，会展示 \( f[i][j] \) 的状态变化，高亮当前计算的 \( j \) 值，并伴随“叮”的音效表示状态更新。控制面板支持单步/自动播放，同步显示当前处理的 \( i \)、\( j \) 和对应的操作次数。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性和算法有效性的评估，以下题解因逻辑清晰、代码简洁且正确，评分均≥4星：
</eval_intro>

**题解一：作者xht**
* **点评**：此题解直接抓住了问题核心，通过前缀和快速计算当前元素调整后的值，代码简洁高效。状态定义 \( f[i][j] \) 直观，转移方程推导明确，尤其对负数取整的处理（如 \( t < 0 \) 时调整 \( w \)）体现了严谨性。代码变量命名如 \( s \)（前缀和）、\( w \)（\( m \)）、\( t \)（余数）含义清晰，适合直接用于竞赛。

**题解二：作者FReQuenter**
* **点评**：此题解详细解释了转移方程的推导，特别是 \( P \) 的计算（前 \( i+1 \) 个数的调整后值），帮助理解操作次数的来源。对负数取整的处理（\( tmp \times n > S \) 时调整 \( tmp \)）非常关键，避免了因负数取整错误导致的结果偏差。代码结构工整，循环嵌套合理，适合新手学习。

**题解三：作者氧少Kevin**
* **点评**：此题解通过“hint”引导思考，将问题分解为“已知目标数组求操作次数”和“确定目标数组形式”两部分，逻辑清晰。特别指出操作次数的本质是前缀和的绝对值之和，为DP状态设计提供了理论支撑。代码中对 \( C_i \)（前缀和差）的计算与转移方程结合紧密，体现了对问题的深入理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于以下三个核心难点，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：确定最终数组的形式**
    * **分析**：由于操作不改变总和 \( S \)，最终数组的元素只能是 \( m \) 或 \( m+1 \)。其中 \( m = \lfloor \frac{S}{n} \rfloor \)，\( m+1 \) 的个数为 \( r = S - m \times n \)（若 \( r < 0 \) 需调整 \( m \) 和 \( r \) 确保 \( r \geq 0 \)）。例如，样例1中 \( S=2+7+6=15 \)，\( n=3 \)，则 \( m=5 \)，\( r=0 \)，最终数组全为5。
    * 💡 **学习笔记**：总和 \( S \) 是确定最终数组形式的唯一依据，需注意负数取整的特殊处理（如 \( S=-3 \) 时 \( m=-1 \)，\( r=0 \)）。

2.  **关键点2：动态规划的状态定义**
    * **分析**：状态 \( f[i][j] \) 表示前 \( i \) 个元素中有 \( j \) 个 \( m+1 \) 的最小操作次数。选择 \( j \) 作为状态变量是因为 \( m+1 \) 的总数 \( r \) 已知（最终 \( j=r \)），通过逐步累加 \( j \) 可覆盖所有可能的组合。
    * 💡 **学习笔记**：状态定义需直接关联问题的关键变量（如本题中 \( m+1 \) 的个数），确保转移时能覆盖所有情况。

3.  **关键点3：转移方程的推导**
    * **分析**：对于第 \( i+1 \) 个元素，调整后的值 \( P \) 由前 \( i \) 个元素的调整结果决定（\( P = \text{前}i+1\text{项和} - j \times (m+1) - (i-j) \times m \)）。转移时比较 \( P \) 取 \( m \) 或 \( m+1 \) 的操作代价（绝对值差），取较小值更新 \( f[i+1][j] \) 或 \( f[i+1][j+1] \)。
    * 💡 **学习笔记**：转移方程的核心是“当前调整后的值与目标值的差”，需通过前缀和快速计算 \( P \)，避免重复计算。

### ✨ 解题技巧总结
- **问题分解**：先确定最终数组的形式（\( m \) 和 \( r \)），再通过DP计算最小操作次数，将复杂问题拆解为两部分。
- **前缀和优化**：利用前缀和数组 \( s[i] \) 快速计算前 \( i \) 项和，简化 \( P \) 的计算。
- **边界处理**：注意负数取整的特殊情况（如 \( S < 0 \) 时 \( m \) 的调整），确保 \( r \) 非负。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个逻辑清晰、结构简洁的通用核心实现，帮助大家快速掌握完整解题框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了xht和FReQuenter的题解思路，处理了负数取整问题，并通过二维DP数组计算最小操作次数。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <cmath>
    using namespace std;
    using ll = long long;

    int main() {
        int n;
        cin >> n;
        vector<ll> a(n + 1), s(n + 1);
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            s[i] = s[i - 1] + a[i];
        }
        ll S = s[n];
        ll m = S / n;
        ll r = S % n;
        // 处理负数取整问题：确保r非负
        if (r < 0) {
            m--;
            r += n;
        }
        // 初始化DP数组，f[i][j]表示前i个元素中有j个m+1的最小操作次数
        vector<vector<ll>> f(n + 1, vector<ll>(r + 1, 1e18));
        f[0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= min(r, i); ++j) {
                // 前i个元素中有j个m+1时，第i个元素的调整后值P
                ll P = s[i] - j * (m + 1) - (i - j) * m;
                // 情况1：第i个元素取m
                if (j <= r) {
                    f[i][j] = min(f[i][j], f[i - 1][j] + abs(P - m));
                }
                // 情况2：第i个元素取m+1（j>0时）
                if (j > 0) {
                    f[i][j] = min(f[i][j], f[i - 1][j - 1] + abs(P - (m + 1)));
                }
            }
        }
        cout << f[n][r] << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先计算总和 \( S \) 和最终值 \( m \)、\( r \)（\( m+1 \) 的个数）。通过前缀和数组 \( s \) 快速计算前 \( i \) 项和。二维DP数组 \( f \) 初始化后，通过双重循环遍历每个元素和可能的 \( j \)（\( m+1 \) 的个数），计算当前元素调整后的值 \( P \)，并更新 \( f[i][j] \) 的最小值。最终输出 \( f[n][r] \) 即为答案。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：作者xht**
* **亮点**：代码简洁，直接通过前缀和计算 \( P \)，并处理了负数取整问题（\( t < 0 \) 时调整 \( w \)）。
* **核心代码片段**：
    ```cpp
    ll w = s[n] / n, t = s[n] % n;
    if (t < 0) w--, t += n;
    vector<vector<ll>> f(n + 1, vector<ll>(t + 1, 1e18));
    f[0][0] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= t; j++) {
            f[i][j] = f[i-1][j] + abs(a[i] + s[i-1] - w * (i - 1) - j - w);
            if (j) f[i][j] = min(f[i][j], f[i-1][j-1] + abs(a[i] + s[i-1] - w * (i - 1) - (j - 1) - (w + 1)));
        }
    ```
* **代码解读**：
    这里 \( w \) 是 \( m \)，\( t \) 是 \( r \)（\( m+1 \) 的个数）。\( a[i] + s[i-1] \) 是前 \( i \) 项和（即 \( s[i] \)）。第一行计算当前元素取 \( m \) 时的操作次数（\( P - m \) 的绝对值），第二行处理取 \( m+1 \) 的情况（\( j>0 \) 时）。通过前缀和快速计算 \( P \)，避免了重复计算。
* 💡 **学习笔记**：前缀和的灵活运用是简化计算的关键，需注意 \( s[i] = a[1]+...+a[i] \) 的定义。

**题解二：作者FReQuenter**
* **亮点**：详细处理了负数取整问题（\( tmp \times n > S \) 时调整 \( tmp \)），确保 \( m \) 的正确性。
* **核心代码片段**：
    ```cpp
    int tmp = S / n;
    if (tmp * n > S) tmp--; // 处理负数取整
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            int P = sum[i+1] - j * (tmp + 1) - (i - j) * tmp;
            f[i+1][j] = min(f[i+1][j], f[i][j] + abs(P - tmp));
            f[i+1][j+1] = min(f[i+1][j+1], f[i][j] + abs(P - (tmp + 1)));
        }
    }
    ```
* **代码解读**：
    \( tmp \) 是 \( m \)，\( sum[i+1] \) 是前 \( i+1 \) 项和。\( P \) 表示第 \( i+1 \) 个元素调整后的值，通过前 \( i \) 个元素的 \( j \) 个 \( m+1 \) 和 \( i-j \) 个 \( m \) 计算得出。转移时分别考虑 \( P \) 取 \( m \) 或 \( m+1 \) 的操作次数，更新 \( f[i+1][j] \) 或 \( f[i+1][j+1] \)。
* 💡 **学习笔记**：负数取整需特别注意，例如 \( S=-3 \)、\( n=3 \) 时，\( tmp=-1 \)，\( S - tmp \times n = 0 \)，确保 \( r \) 非负。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解动态规划的状态转移过程，我们设计了一个“像素探险队”主题的8位像素动画，让大家“看”到DP数组的更新过程！
</visualization_intro>

  * **动画演示主题**：像素探险队的均等化挑战

  * **核心演示内容**：展示DP数组 \( f[i][j] \) 的状态转移，重点突出 \( i \)（当前处理的元素）、\( j \)（已选 \( m+1 \) 的个数）和操作次数的计算。

  * **设计思路简述**：采用FC红白机风格，用蓝色像素块表示 \( m \)，绿色像素块表示 \( m+1 \)。每处理一个元素 \( i \)，动画会逐步填充 \( f[i][j] \) 的值，高亮当前计算的 \( j \)，并通过音效提示状态更新，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕分为左右两部分：左侧是数组区域（像素块排列），右侧是DP表格（\( i \) 行 \( j \) 列的网格）。
          - 控制面板包含“单步”“自动播放”“重置”按钮和速度滑块（1x-5x）。
          - 播放8位风格的轻快背景音乐（类似《超级马里奥》的过场音乐）。

    2.  **数据初始化**：
          - 输入数组 \( A \) 显示为彩色像素块（初始颜色随机），总和 \( S \)、\( m \)、\( r \) 显示在顶部。
          - DP表格初始化为 \( \infty \)（灰色块），仅 \( f[0][0] \) 为0（绿色高亮）。

    3.  **状态转移演示**：
          - 处理元素 \( i \) 时，数组区域高亮第 \( i \) 个像素块（黄色边框）。
          - 对于每个 \( j \)（从0到 \( \min(r, i) \)），计算 \( P \) 的值（显示在像素块上方），并比较取 \( m \)（蓝色）或 \( m+1 \)（绿色）的操作次数。
          - DP表格中，\( f[i][j] \) 块根据计算结果更新颜色（红色表示较大值，绿色表示较小值），并伴随“叮”的音效。

    4.  **目标达成**：
          - 当处理完所有元素（\( i=n \)），\( f[n][r] \) 块以金色高亮，播放胜利音效（如《超级玛丽》的金币音效），显示最终操作次数。

    5.  **交互控制**：
          - 单步模式：点击“单步”按钮，逐行逐列展示DP状态更新。
          - 自动播放：选择速度后，动画自动演示完整过程，学习者可观察状态转移的规律。

  * **旁白提示**：
      - （处理 \( i=1 \) 时）“现在处理第一个元素，我们需要决定它是取 \( m \) 还是 \( m+1 \)，计算两种情况下的操作次数！”
      - （高亮 \( f[i][j] \) 块）“看，这里 \( f[3][2] \) 的值比之前更小，说明这种选择更优！”
      - （结束时）“最终，我们找到了最小操作次数 \( f[n][r] \)，探险成功！”

<visualization_conclusion>
通过这个像素动画，我们不仅能看到DP数组如何逐步填充，还能直观理解状态转移的逻辑。下次遇到类似问题时，你也可以想象自己是“像素探险队”的一员，一步步解锁最优解！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的DP思路后，我们可以尝试以下拓展练习，巩固动态规划的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      本题的DP思想适用于“确定目标状态后，通过逐步选择构建最优解”的问题，例如：
      - 背包问题（选择物品使总价值最大）。
      - 序列分割（将序列分成k段使某指标最优）。
      - 路径规划（网格中从起点到终点的最小代价）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1048 采药** - 经典01背包问题
          * 🗣️ **推荐理由**：通过选择草药使总价值最大，练习状态定义和转移方程的推导。
    2.  **洛谷 P1216 数字三角形** - 动态规划路径问题
          * 🗣️ **推荐理由**：从顶部到底部的最大路径和，巩固二维DP的状态转移。
    3.  **洛谷 P1832 A+B Problem（再升级）** - 组合数与DP结合
          * 🗣️ **推荐理由**：计算互质的数对个数，练习状态设计和优化。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了处理负数取整的经验，这对避免错误非常关键：
</insights_intro>

> **参考经验 (来自作者FReQuenter)**：“当 \( S \) 为负数时，直接用 \( S/n \) 取整可能出错（例如 \( S=-3 \), \( n=3 \) 时，\( S/n=-1 \)，但 \( -1 \times 3 = -3 = S \)，无需调整；若 \( S=-4 \), \( n=3 \)，则 \( S/n=-1.333 \)，取整为-2，此时 \( -2 \times 3 = -6 < S=-4 \)，需调整 \( tmp \) 为-2，\( r=S - tmp \times n = 2 \)。”

**点评**：作者的经验提醒我们，处理负数取整时不能直接依赖编程语言的默认取整规则（如C++中负数除法向零取整），需手动调整确保 \( r \) 非负。这对解决类似问题时的边界条件处理非常重要！

---

<conclusion>
通过本次分析，我们掌握了“近似均等化”问题的核心解法——动态规划，并通过像素动画直观理解了状态转移过程。希望大家在练习中多思考、多尝试，逐步提升算法能力！下次挑战更难的题目，我们不见不散~ 💪
</conclusion>

---
处理用时：234.75秒
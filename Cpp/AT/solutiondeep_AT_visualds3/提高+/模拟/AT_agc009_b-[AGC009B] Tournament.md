# 题目信息

# [AGC009B] Tournament

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jrex2017/tasks/agc009_b

$ N $ 人の人が大会に出場しました。この大会はトーナメント形式であり、$ N-1 $ 回の試合が行われました。 諸事情により、このトーナメントは全参加者に平等に組まれているとは限りません。 すなわち、各人に対し、優勝するために必要なその人が勝者となるような試合数が等しいとは限りません。 トーナメントの構造は、正式には問題文の末尾で定義されます。

各試合では必ず片方の人が勝者、もう片方の人が敗者となり、最後まで負けなかった $ 1 $ 人が優勝となります。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc009_b/60b2a9eae65eb70a75e8c33bcbb94cf7111ee45a.png)図: トーナメントの例

 

人には $ 1 $ から $ N $ までの番号がついており、$ 1 $ 番の人が優勝し、優勝者以外の人 $ i(2\ ≦\ i\ ≦\ N) $ は人 $ a_i $ との試合で負けました。

トーナメントの深さとは、すべての人に対する、その人が優勝するために必要な、その人が勝者となるような試合数の最大値です。

トーナメントの深さとしてありうる最小の値を求めてください。

トーナメントの構造の正式な定義は以下の通りです。$ i $ 回目の試合では、

- あらかじめ決められた、まだ試合をしていない $ 2 $ 人の人
- あらかじめ決められたまだ試合をしていない人 $ 1 $ 人と、あらかじめ決められた $ j(j\ <\ i) $ に対する、$ j $ 回目の試合の勝者
- あらかじめ決められた $ j,k(j,k\ <\ i,\ j\ ≠\ k) $ に対する、$ j $ 回目の試合の勝者と $ k $ 回目の試合の勝者

のうちのいずれかの $ 2 $ 人が試合を行います。このような構造であって、どのように試合結果を決めても、すでに一度試合に負けた人が再び試合をすることのないようなものをトーナメントと呼びます。

## 说明/提示

### 制約

- $ 2\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ a_i\ ≦\ N(2\ ≦\ i\ ≦\ N) $
- 入力の試合結果と合致するようなトーナメントが存在する

### Sample Explanation 1

次のような試合結果が条件を満たします。 - $ 1 $ 回目の試合では、人 $ 4 $ と 人 $ 5 $ が対戦し、人 $ 4 $ が勝つ - $ 2 $ 回目の試合では、人 $ 2 $ と 人 $ 4 $ が対戦し、人 $ 2 $ が勝つ - $ 3 $ 回目の試合では、人 $ 1 $ と 人 $ 3 $ が対戦し、人 $ 1 $ が勝つ - $ 4 $ 回目の試合では、人 $ 1 $ と 人 $ 2 $ が対戦し、人 $ 1 $ が勝つ !\[783f7be9c88350e31963edba8a958879.png\](https://atcoder.jp/img/agc009/783f7be9c88350e31963edba8a958879.png) このトーナメントは、人 $ 5 $ が優勝するためには $ 3 $ 回勝利する必要があるので、深さ $ 3 $ のトーナメントとなります。 逆に、深さ $ 2 $ 以下の条件を満たすトーナメントは存在しないので、$ 3 $ を出力します。

## 样例 #1

### 输入

```
5

1

1

2

4```

### 输出

```
3```

## 样例 #2

### 输入

```
7

1

2

1

3

1

4```

### 输出

```
3```

## 样例 #3

### 输入

```
4

4

4

1```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：[AGC009B Tournament] 深入学习指南 💡

<introduction>
今天我们来一起分析“AGC009B Tournament”这道C++编程题。本指南将帮助大家梳理题目核心，理解树形动态规划的应用，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`树形动态规划(DP)` 

🗣️ **初步分析**：
解决这道题的关键在于将问题转化为树形结构，并通过动态规划计算每个节点的最小可能深度。树形DP的核心思想是“自底向上，以子推父”，就像搭积木——先处理每个子节点的状态，再根据子节点的状态推导父节点的状态。

在本题中，我们将每个选手（除冠军1号外）与击败他的选手连边，形成一棵以1号为根的树。每个节点的深度表示该选手要成为冠军需要赢的最少比赛次数。核心难点在于：如何通过子节点的深度，推导出父节点的最小可能深度最大值。优质题解普遍采用“对子节点深度排序后取最大值+1”的策略，确保父节点的深度最小。

核心算法流程：  
1. 构建树结构（每个节点的子节点是被其直接击败的选手）。  
2. 后序遍历树（DFS），计算每个节点的子节点深度。  
3. 将子节点的深度排序，依次更新当前节点的深度（`f[u] = max(f[u], f[v]) + 1`）。  

可视化设计思路：采用8位像素风格，用不同颜色的像素方块表示节点（如绿色为根节点1，蓝色为子节点）。动画中，每个节点的子节点会按深度从小到大排列，用像素箭头动态展示排序过程；节点的深度值（f值）会实时更新，用数字标签显示。关键步骤（如排序完成、f值更新）会伴随“叮”的音效，增强操作记忆。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下3道题解（评分≥4星）值得重点学习：
</eval_intro>

**题解一：作者BigJoker**
* **点评**：此题解思路简洁直接，将问题转化为树形DP的模型非常巧妙。代码中使用`vector`存储子节点，通过DFS后序遍历计算每个节点的深度，排序子节点深度后更新父节点深度。变量命名（如`win`数组存储子节点，`us`数组存储深度）清晰易懂，边界处理严谨（根节点为1，无子节点的叶子节点深度自然为0）。算法时间复杂度为O(n log n)（排序贡献主要复杂度），适用于n=1e5的规模，实践参考价值高。

**题解二：作者WorldMachine**
* **点评**：此题解代码风格简洁优雅，使用C++的`vector`和范围for循环，可读性强。状态定义（`f[u]`表示u节点的最小深度）和转移逻辑（排序子节点后取最大值+1）解释清晰。特别是排序时使用lambda表达式，体现了C++的现代特性。代码结构工整，无冗余操作，适合直接作为竞赛模板使用。

**题解三：作者tuliwei**
* **点评**：此题解对题意的理解非常到位，明确指出“将被淘汰者连向击败者，形成树结构”的关键转化。代码中`dfs`函数逻辑清晰，先处理所有子节点，再排序并更新当前节点深度。注释简洁（如`//处理所有儿子的答案`），变量命名（`T`数组存储树结构，`f`数组存储深度）符合习惯，适合初学者模仿。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要突破以下核心难点，并掌握对应的解题策略：
</difficulty_intro>

1.  **关键点1：如何构建树结构？**
    * **分析**：题目中每个选手i（i≥2）给出的`a_i`是击败他的选手，因此可以将i作为`a_i`的子节点，构建一棵以1号为根的树。例如，输入样例1中，2的父节点是1，3的父节点是1，4的父节点是2，5的父节点是4，形成树结构。
    * 💡 **学习笔记**：树的构建是树形DP的基础，需确保每个子节点正确关联到父节点。

2.  **关键点2：如何定义DP状态？**
    * **分析**：定义`f[u]`为节点u的最小可能深度（即u要成为冠军需要赢的最少比赛次数）。对于叶子节点（无子节点），`f[u]=0`（无需比赛即可“虚拟夺冠”）。对于非叶子节点，`f[u]`由子节点的深度推导而来。
    * 💡 **学习笔记**：状态定义需直接反映问题的核心目标（本题中是“最小化最大深度”）。

3.  **关键点3：如何处理子节点以最小化父节点深度？**
    * **分析**：子节点的深度排序是关键。若子节点的深度为`d1 ≤ d2 ≤ ... ≤ dk`，则父节点的深度为`max(d1+1, d2+1, ..., dk+1)`。但直接取最大值可能浪费“层数”，因此需要将子节点按深度从小到大排序，依次更新父节点深度（`f[u] = max(f[u], d_i) + 1`），确保每一步都取最小可能的最大值。
    * 💡 **学习笔记**：排序是贪心策略的体现，通过调整子节点的处理顺序，最小化父节点的深度。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将比赛胜负关系转化为树结构，是解决此类问题的关键。  
- **后序遍历**：树形DP通常采用后序遍历（DFS），先处理子节点再处理父节点。  
- **贪心排序**：对子节点状态排序，是优化父节点状态的常用手段。  
- **边界处理**：叶子节点的状态（`f[u]=0`）是初始条件，需特别注意。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，代码简洁高效，适合直接学习和应用。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了BigJoker和WorldMachine的题解思路，采用树形DP，通过DFS后序遍历计算每个节点的深度，子节点排序后更新父节点深度。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 1e5 + 5;
    vector<int> children[N]; // 存储每个节点的子节点
    int f[N]; // f[u]表示节点u的最小可能深度

    void dfs(int u) {
        vector<int> depths;
        for (int v : children[u]) {
            dfs(v);
            depths.push_back(f[v]);
        }
        // 对子节点的深度从小到大排序
        sort(depths.begin(), depths.end());
        // 计算当前节点的深度
        for (int d : depths) {
            f[u] = max(f[u], d) + 1;
        }
    }

    int main() {
        int n;
        cin >> n;
        for (int i = 2; i <= n; ++i) {
            int a;
            cin >> a;
            children[a].push_back(i); // i是a的子节点
        }
        dfs(1);
        cout << f[1] << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并构建树结构（`children`数组存储每个节点的子节点）。通过`dfs`函数后序遍历每个节点：对于节点u，先递归处理所有子节点，收集子节点的深度存入`depths`数组；排序后，依次更新u的深度（每次取当前最大值+1）。最终输出根节点1的深度，即答案。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的亮点和思路。
</code_intro_selected>

**题解一：作者BigJoker**
* **亮点**：代码简洁，使用`vector`存储子节点，递归处理逻辑清晰。
* **核心代码片段**：
    ```cpp
    void DFS(int pos) {
        for (int i = 0; i < win[pos].size(); i++) 
            DFS(win[pos][i]), fac[pos].push_back(us[win[pos][i]]);
        sort(fac[pos].begin(), fac[pos].end());
        for (int i = 0; i < win[pos].size(); i++) 
            us[pos] = max(us[pos], fac[pos][i]) + 1; 
    }
    ```
* **代码解读**：  
  `DFS`函数递归处理子节点（`win[pos]`存储pos的子节点），将子节点的深度（`us[win[pos][i]]`）存入`fac[pos]`数组。排序后，遍历`fac[pos]`数组，每次取当前最大值并+1，得到`us[pos]`（即pos节点的深度）。这一步确保了深度最小化，因为排序后较小的深度先被处理，避免了“层数浪费”。
* 💡 **学习笔记**：递归后序遍历+排序+贪心更新，是树形DP的经典组合。

**题解二：作者WorldMachine**
* **亮点**：使用C++的范围for循环和lambda排序，代码简洁现代。
* **核心代码片段**：
    ```cpp
    void dfs(int u) {
        for (int v : G[u]) dfs(v);
        sort(G[u].begin(), G[u].end(), [](int x, int y) { return f[x] < f[y]; });
        for (int v : G[u]) f[u] = max(f[u], f[v]) + 1;
    }
    ```
* **代码解读**：  
  `G[u]`存储u的子节点。首先递归处理所有子节点，然后按子节点的深度`f[x]`从小到大排序。遍历排序后的子节点，每次更新`f[u]`为当前最大值+1。排序确保了较小的深度先被处理，避免父节点深度被不必要地放大。
* 💡 **学习笔记**：lambda表达式使排序逻辑更清晰，适合快速实现。

**题解三：作者tuliwei**
* **亮点**：注释明确，变量命名直观（`T`表示树结构）。
* **核心代码片段**：
    ```cpp
    void dfs(int u) {
        for (int v : T[u]) dfs(v); //处理所有儿子的答案
        sort(T[u].begin(), T[u].end(), cmp); //按f[v]从小到大排序
        for (int v : T[u]) f[u] = max(f[u], f[v]) + 1; //转移
    }
    ```
* **代码解读**：  
  `T[u]`存储u的子节点。先递归处理子节点，再按`f[v]`从小到大排序（`cmp`函数定义比较逻辑）。遍历排序后的子节点，更新`f[u]`为最大值+1。这一步确保父节点的深度是所有子节点深度+1的最小可能最大值。
* 💡 **学习笔记**：明确的注释是代码可读性的关键，适合初学者理解逻辑。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解树形DP的执行过程，我们设计了一个“像素树探险”动画，用8位复古风格展示树的构建、子节点排序和深度计算过程。
</visualization_intro>

  * **动画演示主题**：`像素树探险——寻找最小深度冠军`

  * **核心演示内容**：  
    展示从叶子节点到根节点的DFS遍历过程，重点突出子节点排序和父节点深度计算的关键步骤。例如，叶子节点（无子节点）的深度为0（显示绿色数字0）；非叶子节点的子节点按深度从小到大排列（用像素箭头拖动排序），父节点的深度逐步更新（数字从0开始，每次取最大值+1）。

  * **设计思路简述**：  
    采用8位像素风格（类似FC游戏画面），用不同颜色区分节点类型（根节点1为金色，其他节点为蓝色），深度数字用白色显示。排序过程用像素滑块拖动子节点，音效“唰”表示排序完成；深度更新时用“叮”声提示，增强操作记忆。游戏化的“小关卡”设计（每完成一个节点的深度计算即过一关），增加学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕中央显示像素树（每个节点为16x16像素方块，用线条连接父子节点）。  
        - 控制面板包含“单步”“自动播放”“重置”按钮和速度滑块（1-5倍速）。  
        - 播放8位风格背景音乐（轻快的电子旋律）。

    2.  **树构建与输入展示**：  
        - 输入数据（如样例1的`5 1 1 2 4`）以像素文字显示在屏幕上方。  
        - 节点1（根）首先出现在画面中央，其他节点（2-5）逐个从右侧飞入，根据输入连接到父节点（如节点2连接到1，节点4连接到2）。

    3.  **DFS遍历与子节点处理**：  
        - 从根节点1开始，像素箭头（黄色）指向当前处理节点。  
        - 递归访问子节点（如先访问节点2，再访问节点4，最后访问节点5），叶子节点5的深度显示为0（绿色数字）。  
        - 返回处理父节点时，子节点的深度被收集到“深度池”（像素列表），并自动按从小到大排序（用滑块拖动调整顺序）。

    4.  **深度计算与更新**：  
        - 排序完成后，父节点的深度从0开始，依次与每个子节点的深度比较（如节点4的子节点5的深度为0，排序后节点4的深度更新为0+1=1）。  
        - 每完成一次比较，父节点的深度数字闪烁并增大（如节点2的子节点4的深度为1，排序后节点2的深度更新为1+1=2）。  
        - 关键步骤（排序、深度更新）伴随“唰”“叮”的像素音效。

    5.  **根节点深度展示**：  
        - 最终根节点1的深度计算完成后，屏幕中央弹出“胜利”动画（金色星星闪烁），播放上扬的胜利音效，并显示最终答案（如样例1的3）。

  * **旁白提示**：  
    - （访问叶子节点时）“叶子节点没有子节点，它的深度是0哦！”  
    - （排序时）“现在要给子节点的深度排个序，这样父节点的深度才能最小～”  
    - （更新深度时）“看！父节点的深度是子节点深度的最大值加1，这样就能保证最少的比赛次数啦！”

<visualization_conclusion>
通过这个动画，我们可以直观看到树形DP的每一步操作，特别是子节点排序和深度计算的关键逻辑，帮助我们更好地理解算法原理。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的树形DP和贪心排序技巧后，我们可以尝试以下拓展练习，巩固相关能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    树形DP+贪心排序的策略，不仅适用于本题，还可解决以下类型的问题：  
    - 计算树的最小高度（如二叉树的最小高度）。  
    - 资源分配问题（如将任务分配给子节点，使总时间最小）。  
    - 树的重构问题（如根据子节点信息重建父节点属性）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1352 没有上司的舞会**  
        * 🗣️ **推荐理由**：经典树形DP问题，需处理子节点的选与不选状态，巩固树形DP的状态定义和转移。  
    2.  **洛谷 P2015 二叉苹果树**  
        * 🗣️ **推荐理由**：涉及树的剪枝和子树选择，需结合贪心策略，与本题的排序优化思路类似。  
    3.  **洛谷 P1122 最大子树和**  
        * 🗣️ **推荐理由**：树形DP中求子树的最大和，需后序遍历处理子节点，强化树形结构的动态规划能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题中的经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自作者Antiluna)**：“在dfs时使用`v.clear()`是错误的，因为`clear`不会改变`begin()`和`end()`的位置，可能导致后续操作错误。”  
> **点评**：这个经验提醒我们，在C++中使用容器（如`vector`）时，需注意其成员函数的行为。`clear()`会清空元素但不释放内存，若后续需要重新填充，直接使用即可；但如果涉及指针或迭代器，需谨慎处理。调试时可通过打印容器大小确认状态，避免类似错误。

-----

<conclusion>
本次关于“AGC009B Tournament”的分析就到这里。希望通过树形DP的学习和动画演示，大家能更深入理解动态规划在树结构中的应用。记住，多画图、多模拟是掌握树形问题的关键！下次再见～💪
</conclusion>

-----

---
处理用时：189.62秒
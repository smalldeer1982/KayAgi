# 题目信息

# [AGC010B] Boxes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc010/tasks/agc010_b

$ N $ 個の箱が円環状に並んでおり、$ i $ 番目の箱には $ A_i $ 個の石が入っています。

以下の操作を繰り返して、全ての石を取り除くことができるか判定してください。

- 箱を一か所選ぶ。それを $ i $ 番目としたとき、$ 1 $ から $ N $ の各 $ j $ に対して、$ i+j $ 番目の箱から石をちょうど $ j $ 個取り除く。  
   ただし、$ N+k $ 番目と表される箱は $ k $ 番目の箱と同一視するものとする。

各操作において、取り除きたい個数の石がない箱があるときは、その操作を行えないことに注意してください。

## 说明/提示

### 制約

- $ 1\ ≦\ N\ ≦\ 10^5 $
- $ 1\ ≦\ A_i\ ≦\ 10^9 $

### Sample Explanation 1

最初に箱 $ 2 $ を選ぶことで、一回の操作ですべての石を回収できます。

## 样例 #1

### 输入

```
5

4 5 1 2 3```

### 输出

```
YES```

## 样例 #2

### 输入

```
5

6 9 12 10 8```

### 输出

```
YES```

## 样例 #3

### 输入

```
4

1 2 3 1```

### 输出

```
NO```

# AI分析结果



---
# 💡 Kay的C++算法解析：[AGC010B] Boxes 深入学习指南 💡

<introduction>
今天我们来一起分析“[AGC010B] Boxes”这道C++编程题。题目要求我们判断是否可以通过特定操作将环形排列的箱子中的石子全部取完。本指南将帮助大家梳理题目核心逻辑，理解数学推导与差分数组的应用，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学分析与差分数组应用`

🗣️ **初步分析**：
解决这道题的关键在于通过数学推导找到操作的必要条件，并利用差分数组验证这些条件是否满足。简单来说，每次操作相当于从某个起点开始，依次取1、2、…、N个石子（环形处理）。我们需要判断是否存在若干次这样的操作，使得所有石子被取完。

- **题解思路**：大部分题解的核心思路是：  
  1. 计算总操作次数 \( M = \frac{\sum A_i}{\frac{N(N+1)}{2}} \)（要求 \( \sum A_i \) 能被 \( \frac{N(N+1)}{2} \) 整除）；  
  2. 构造差分数组 \( d_i = A_{i+1} - A_i \)（环形处理，\( A_{N+1}=A_1 \)）；  
  3. 验证每个 \( d_i \) 是否满足 \( (M - d_i) \) 能被 \( N \) 整除且 \( \frac{M - d_i}{N} \geq 0 \)。  

  不同题解的差异主要在于代码实现细节（如差分数组的构造方式），但核心数学条件一致。

- **核心算法流程**：  
  首先计算总石子数 \( \sum A_i \)，若不能被 \( \frac{N(N+1)}{2} \) 整除，直接返回NO；否则计算 \( M \)。接着构造差分数组 \( d_i \)，检查每个 \( d_i \) 是否满足 \( (M - d_i) \) 是 \( N \) 的非负倍数。若所有条件满足，返回YES，否则返回NO。

- **可视化设计思路**：  
  采用8位像素风格，用环形排列的像素方块代表箱子，每个方块显示当前石子数。动画演示总石子数计算、差分数组生成过程（用箭头连接相邻方块，显示差值），以及关键条件验证（如 \( M \) 的计算、\( (M - d_i) \) 的整除性检查）。关键步骤高亮（如红色闪烁表示不满足条件），并配合“叮”的音效提示成功检查，“滴”的音效提示失败。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解（评分≥4星）值得重点参考：
</eval_intro>

**题解一：作者：zhylj**  
* **点评**：此题解逻辑简洁，直接抓住数学核心条件。代码中变量命名清晰（如`d`表示差分数组，`c`表示单次操作总取石子数），边界处理严谨（如环形数组的模运算）。算法时间复杂度 \( O(N) \)，适用于 \( N \leq 10^5 \) 的大规模数据。亮点在于通过差分数组将复杂操作转化为简单的数学条件验证，极大降低了问题复杂度。

**题解二：作者：凌寒**  
* **点评**：此题解详细注释了每一步的数学推导（如总操作次数 \( M \) 的计算、差分数组的作用），非常适合初学者理解。代码结构工整，输入输出处理规范（使用`read`函数加速输入），关键条件判断（如 \( (M - c[i]) \% n \)）明确。亮点是将逆向思维（从0构造原数组）与差分数组结合，直观展示了操作的本质。

**题解三：作者：Kreado**  
* **点评**：此题解代码简洁高效，仅用少量变量完成所有计算。通过直接计算 \( d_i = A_{i\%n+1} - A_i \) 处理环形数组，逻辑清晰。算法时间复杂度 \( O(N) \)，空间复杂度 \( O(N) \)，符合竞赛要求。亮点是将复杂的操作次数验证转化为简单的模运算和非负判断，代码可读性强。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心策略：
</difficulty_intro>

1.  **关键点1：总操作次数 \( M \) 的计算**  
    * **分析**：每次操作取走的石子总数是 \( 1+2+\dots+N = \frac{N(N+1)}{2} \)，因此总石子数 \( \sum A_i \) 必须是该值的整数倍。若 \( \sum A_i \% \frac{N(N+1)}{2} \neq 0 \)，直接返回NO。  
    * 💡 **学习笔记**：总操作次数 \( M \) 是问题的“总开关”，若 \( M \) 不存在（非整数），后续条件无需验证。

2.  **关键点2：差分数组的构造与意义**  
    * **分析**：差分数组 \( d_i = A_{i+1} - A_i \)（环形处理）反映了相邻箱子石子数的差异。每次操作会改变 \( d_i \) 的值（若操作起点在 \( i \)，则 \( d_i \) 减少 \( N-1 \)，其他 \( d_j \) 增加1）。通过推导可得 \( d_i = M - N \cdot m_i \)（\( m_i \) 是起点为 \( i \) 的操作次数），因此 \( m_i = \frac{M - d_i}{N} \) 必须是非负整数。  
    * 💡 **学习笔记**：差分数组是连接操作与石子数变化的“桥梁”，通过分析其变化规律可将问题转化为简单的数学条件验证。

3.  **关键点3：操作次数的非负整数验证**  
    * **分析**：每个 \( m_i \) 必须是非负整数（\( m_i \geq 0 \) 且 \( (M - d_i) \% N = 0 \)）。若存在某个 \( m_i \) 不满足条件，则无法通过操作取完所有石子。  
    * 💡 **学习笔记**：非负整数条件是操作可行性的最终“守门员”，必须逐一验证每个 \( m_i \)。

### ✨ 解题技巧总结
- **逆向思维**：将“取石子”操作转化为“加石子”（从0构造原数组），更易分析操作对石子数的影响。  
- **差分数组应用**：通过差分数组将复杂的环形操作转化为线性数学条件，简化问题。  
- **边界处理**：环形数组的处理需注意模运算（如 \( i\%n+1 \) 避免越界），确保差分数组构造正确。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心C++实现，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了zhylj、凌寒等题解的思路，包含必要的输入处理、总操作次数计算、差分数组构造及条件验证，适用于 \( N \leq 10^5 \) 的大规模数据。  
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;
typedef long long ll;

const int N = 1e5 + 5;
ll a[N], d[N];

int main() {
    int n;
    cin >> n;
    ll sum = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        sum += a[i];
    }
    ll c = (ll)n * (n + 1) / 2;
    if (sum % c != 0) {
        cout << "NO" << endl;
        return 0;
    }
    ll M = sum / c;
    // 构造差分数组（环形处理）
    for (int i = 1; i <= n; ++i) {
        d[i] = a[i % n + 1] - a[i];
    }
    // 验证每个d[i]是否满足条件
    for (int i = 1; i <= n; ++i) {
        if ((M - d[i]) % n != 0 || (M - d[i]) / n < 0) {
            cout << "NO" << endl;
            return 0;
        }
    }
    cout << "YES" << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码首先读取输入并计算总石子数 \( sum \)。若 \( sum \) 不能被 \( \frac{N(N+1)}{2} \) 整除，直接输出NO。否则计算总操作次数 \( M \)，构造差分数组 \( d \)，并验证每个 \( d_i \) 是否满足 \( (M - d_i) \) 是 \( N \) 的非负倍数。若所有条件满足，输出YES。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：作者：zhylj**  
* **亮点**：代码简洁，直接处理环形数组，变量命名清晰（如`c`表示单次操作总取石子数）。  
* **核心代码片段**：
```cpp
for(int i = 1; i <= n; ++i) d[i] = a[i % n + 1] - a[i];
for(int i = 1; i <= n; ++i)
    if(d[i] > M || (M - d[i]) % n != 0) {
        printf("NO"); return 0;
    }
```
* **代码解读**：  
  第一行构造差分数组，通过 \( i\%n+1 \) 处理环形（如 \( i=n \) 时，\( i\%n+1=1 \)）。第二行验证每个 \( d_i \)：若 \( d_i > M \)（即 \( (M - d_i)/n < 0 \)）或 \( (M - d_i) \) 不能被 \( n \) 整除，则输出NO。  
* 💡 **学习笔记**：环形数组的差分数组构造是关键，模运算确保了索引的正确性。

**题解二：作者：凌寒**  
* **亮点**：详细注释数学推导，适合初学者理解。  
* **核心代码片段**：
```cpp
// 构建差分数组
for (int i = 1; i <= n; i++)
    c[i] = a[i % n + 1] - a[i];
for (int i = 1; i <= n; i++)
    if ((M - c[i]) % n != 0 || M - c[i] < 0) {
        printf("NO\n"); return 0;
    }
```
* **代码解读**：  
  第一行构造差分数组 \( c \)（即 \( d_i \)），第二行验证 \( (M - c[i]) \) 必须能被 \( n \) 整除且非负。条件 \( M - c[i] < 0 \) 等价于 \( (M - c[i])/n < 0 \)，确保操作次数非负。  
* 💡 **学习笔记**：直接验证 \( M - c[i] \) 的非负性更直观，避免浮点运算。

**题解三：作者：Kreado**  
* **亮点**：代码极简，仅用必要变量完成计算。  
* **核心代码片段**：
```cpp
for(ll i=1;i<=n;i++)
    if(d[i]>p||(p-d[i])%n) return printf("NO"),0;
```
* **代码解读**：  
  `p` 即 \( M \)。若 \( d[i] > p \)（操作次数为负）或 \( (p - d[i]) \% n \neq 0 \)（非整数），返回NO。代码简洁高效，符合竞赛风格。  
* 💡 **学习笔记**：竞赛中应尽量简化条件判断，减少冗余计算。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解算法流程，我们设计一个“像素探石者”动画，用8位像素风格演示总操作次数计算、差分数组构造及条件验证过程。
</visualization_intro>

  * **动画演示主题**：`像素探石者的环形挑战`  
  * **核心演示内容**：模拟石子取走过程，展示总操作次数 \( M \) 的计算、差分数组 \( d_i \) 的生成，以及每个 \( m_i \) 的验证。  

  * **设计思路简述**：  
    采用FC红白机风格（8-16色调色板），用环形排列的像素方块代表箱子，每个方块显示石子数。通过颜色变化（如绿色表示有效、红色表示无效）和动画（如闪烁、箭头移动）突出关键步骤，配合音效（“叮”提示成功，“滴”提示失败）增强记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕中央显示环形排列的像素方块（颜色：蓝色，代表箱子），每个方块顶部显示石子数（白色文字）。  
        - 下方控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-10倍速）。  
        - 播放8位风格背景音乐（轻快的电子旋律）。

    2.  **总操作次数计算**：  
        - 所有方块石子数相加（用金色加号动画连接），计算总和 \( sum \)（显示在屏幕上方）。  
        - 计算 \( c = N(N+1)/2 \)（用数学公式动画弹出），检查 \( sum \% c \)（红色问号闪烁）。若余数非零，方块变红，播放“滴”音效，动画终止。

    3.  **差分数组构造**：  
        - 生成箭头从 \( A_i \) 指向 \( A_{i+1} \)（环形），显示 \( d_i = A_{i+1} - A_i \)（黄色数字）。  
        - 每个 \( d_i \) 用像素气泡弹出，颜色随数值变化（正数绿色，负数红色）。

    4.  **条件验证**：  
        - 计算 \( M = sum / c \)（金色数字弹出）。  
        - 对每个 \( d_i \)，检查 \( (M - d_i) \% N \)（蓝色等式动画）和 \( (M - d_i)/N \geq 0 \)（绿色对勾/红色叉号）。  
        - 若所有条件满足，方块变绿色，播放“胜利”音效（上扬音调），显示“YES”；否则，失败的 \( d_i \) 方块闪烁红色，播放“滴”音效，显示“NO”。

  * **旁白提示**：  
    - （总操作次数计算时）“总石子数必须是单次操作取石子数的整数倍哦！”  
    - （差分数组构造时）“看，相邻箱子的石子数差就是这个黄色数字～”  
    - （条件验证时）“每个差值都要满足这个数学条件，否则无法取完！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到从输入到条件验证的每一步，轻松理解数学推导与差分数组的作用。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以迁移数学分析与差分数组的思路，解决以下类型的问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是通过数学条件（如整除性、非负整数解）和差分数组分析操作的可行性。类似地，该思路可用于：  
    1. 环形数组的操作可行性判断（如周期性增减操作）；  
    2. 多次操作后状态是否可达的问题（如通过差分分析操作对数组的影响）；  
    3. 数学条件约束下的方案存在性问题（如总次数、单次操作量的关系）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1182 数列分段Section II**  
          * 🗣️ **推荐理由**：考察数学条件判断（最大值最小化），需结合二分法和前缀和，与本题的数学分析思路类似。  
    2.  **洛谷 P1908 逆序对**  
          * 🗣️ **推荐理由**：涉及差分数组和归并排序，可练习数组操作与数学分析的结合。  
    3.  **洛谷 P2679 子串**  
          * 🗣️ **推荐理由**：考察动态规划与差分数组优化，适合提升复杂问题的分析能力。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自 凌寒)**：“在构造差分数组时，最初忘记处理环形情况（如 \( A_{N+1}=A_1 \)），导致差分数组错误，后来通过打印中间变量发现了问题。”  
> **点评**：环形数组的边界处理是常见易错点。调试时打印关键变量（如差分数组的前几个值）能快速定位错误，这是非常实用的技巧！

-----

<conclusion>
本次关于“[AGC010B] Boxes”的分析就到这里。通过数学推导、差分数组和条件验证，我们掌握了这类问题的核心解法。记住，遇到环形操作问题时，不妨试试差分数组和数学条件分析，往往能化繁为简。下次见！💪
</conclusion>

---
处理用时：120.30秒
# 题目信息

# [AGC021B] Holes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc021/tasks/agc021_b

平面上に $ N $ 個の穴があります。$ i $ 個目の穴の座標は、$ (x_i,y_i) $ です。

$ R=10^{10^{10^{10}}} $ とします。りんごさんは、以下の操作を行います。

- 原点を中心とする半径 $ R $ の円内から無作為に $ 1 $ 点を選び、すぬけ君を置く。すぬけ君は、置かれた点からユークリッド距離が最も近い穴に移動し、落ちる。そのような穴が複数ある場合は、添え字の最も小さいものを選ぶ。

全ての $ 1\leq\ i\leq\ N $ に対し、すぬけ君が $ i $ 番目の穴に落ちる確率を求めてください。

ただし、半径 $ R $ の円内から無作為に $ 1 $ 点を選ぶ操作とは、以下の操作を指します。

- $ [-R,R] $ 上の独立な一様分布にしたがって実数 $ x,y $ を選ぶ。
- もし$ x^2+y^2\leq\ R^2 $ なら、座標 $ (x,y) $ を選ぶ。そうでないなら、その条件が満たされるまで実数 $ x,y $ を選びなおし続ける。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100 $
- $ |x_i|,|y_i|\ \leq\ 10^6(1\leq\ i\leq\ N) $
- 与えられる点は全て相異なる
- 入力はすべて整数である

### Sample Explanation 1

りんごさんが $ x+y\leq\ 1 $ なる領域にすぬけ君を置いた場合、すぬけ君は $ 1 $ 番目の穴に落ちます。このような確率は $ 0.5 $ に非常に近いです。 また、そうでない場合すぬけ君は $ 2 $ 番目の穴に落ち、そのような確率も $ 0.5 $ に非常に近いです。

## 样例 #1

### 输入

```
2

0 0

1 1```

### 输出

```
0.5

0.5```

## 样例 #2

### 输入

```
5

0 0

2 8

4 5

2 6

3 10```

### 输出

```
0.43160120892732328768

0.03480224363653196956

0.13880483535586193855

0.00000000000000000000

0.39479171208028279727```

# AI分析结果



---
# 💡 Kay的C++算法解析：AGC021B Holes 深入学习指南 💡

<introduction>
今天我们来一起分析“AGC021B Holes”这道C++编程题。这道题需要计算平面上随机点移动到每个穴的概率，核心在于利用凸包和几何角度分析。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：几何算法（凸包应用、角度计算）

🗣️ **初步分析**：
解决“AGC021B Holes”这道题，关键在于理解**凸包的性质**和**无限平面中区域概率的计算**。想象一下，平面上有很多点，就像撒在纸上的豆子。当随机选一个点时，它会“投奔”最近的豆子。但因为题目中的圆半径极大（$R=10^{10^{10^{10}}}$），有限的区域在无限平面中概率为0，只有无限延伸的区域才可能有非零概率。

- **核心思路**：只有凸包上的点对应的区域是无限的，因此它们的概率非零；凸包内部的点对应的区域是有限的，概率为0。对于凸包上的点，概率等于其相邻边中垂线所夹角度占整个圆周（$2\pi$）的比例。
- **核心难点**：如何正确求解凸包（排除共线点），以及如何计算凸包上点的角度。
- **可视化设计**：用8位像素风展示凸包构建过程（点按顺序排列，排除凹点时闪烁），用不同颜色标记中垂线和角度区域，关键步骤（如中垂线生成、角度计算）伴随“叮”的音效，最终用扇形动画展示各点的概率占比。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解质量突出（≥4星）：
</eval_intro>

**题解一：作者 LittleMoMol（来源：博客链接）**
* **点评**：这道题解思路非常清晰，从凸包的性质入手，详细解释了“凸包外点概率为0”的原因，并通过Andrew算法实现凸包求解。代码中变量命名规范（如`stk`表示凸包栈，`area`计算叉积），边界处理严谨（如凸包成环避免越界）。亮点在于结合几何定理（余弦定理求角度）和凸包特性，将复杂问题转化为可计算的角度比例，对理解凸包应用和概率计算有很强的启发性。

**题解二：作者 wmy_goes_to_thu（来源：代码片段）**
* **点评**：此题解采用Graham算法求凸包，代码简洁高效。通过极角排序和叉积判断凸包点，处理了共线点的情况（排除中间点）。亮点在于对极角排序的巧妙应用，以及对凸包闭合环的处理（`q[0]=q[r], q[r+1]=q[1]`），确保角度计算的连续性。

**题解三：作者 AGC_love（来源：代码链接）**
* **点评**：此题解简明扼要地总结了核心逻辑，强调“只有凸包上的点概率非零”，并直接给出角度计算的方法（$\frac{\theta}{2\pi}$）。代码实现清晰，适合快速理解凸包与概率的关系。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，核心难点集中在凸包求解和角度计算上。以下是关键步骤的分析和策略：
</difficulty_intro>

1.  **关键点1：判断哪些点在凸包上**
    * **分析**：凸包是包含所有点的最小凸多边形。若点在凸包内部或边上（非顶点），其对应区域有限，概率为0。求解凸包时需排除共线点（如三点共线时，中间点不在凸包上）。例如，使用Andrew算法时，通过叉积判断点是否在凸包边缘。
    * 💡 **学习笔记**：凸包的顶点是“最外围”的点，内部点无法形成无限区域。

2.  **关键点2：计算凸包上点的角度**
    * **分析**：凸包上点的概率由其相邻边的中垂线夹角决定。利用余弦定理计算凸包内角$\alpha$，则所求角度为$\pi-\alpha$（弧度制）。例如，对于凸包顶点$B$，其相邻顶点$A$和$C$，计算$\triangle ABC$的$\angle ABC$，再用$\pi$减去该角得到有效夹角。
    * 💡 **学习笔记**：夹角决定了无限区域的“开口大小”，开口越大，概率越高。

3.  **关键点3：处理共线点和特殊情况**
    * **分析**：三点共线时，中间点的区域是“一维无限”（如直线方向无限，但垂直方向有限），概率仍为0。需在凸包求解时排除这些点。此外，当$N=1$时，概率直接为1。
    * 💡 **学习笔记**：共线点无法形成“二维无限”区域，需严格排除。

### ✨ 解题技巧总结
- **问题抽象**：将概率问题转化为几何区域问题，利用“无限平面中有限区域概率为0”的性质简化问题。
- **凸包应用**：通过凸包筛选出可能的候选点，减少计算量。
- **角度计算**：结合余弦定理和反三角函数，将几何位置关系转化为数值计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心C++实现，采用Andrew算法求凸包，代码清晰且易于理解。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了LittleMoMol等题解的思路，使用Andrew算法求凸包，计算凸包上点的角度并输出概率。
* **完整核心代码**：
    ```cpp
    #include <algorithm>
    #include <iostream>
    #include <cstdio>
    #include <cmath>
    #define x first
    #define y second

    using namespace std;

    typedef pair<double, double> PDD;
    const int N = 210;
    const double pi = acos(-1), pi_2 = 2 * acos(-1);

    int n;
    int top, stk[N];
    struct Point {
        PDD q;
        int id;
    } poi[N];
    double ans[N];

    bool cmp(Point a, Point b) {
        return a.q < b.q;
    }

    double get_dist(PDD a, PDD b) {
        double dx = a.x - b.x, dy = a.y - b.y;
        return sqrt(dx * dx + dy * dy);
    }

    double cross(PDD a, PDD b) {
        return a.x * b.y - a.y * b.x;
    }

    double area(PDD a, PDD b, PDD c) {
        PDD ab = {b.x - a.x, b.y - a.y};
        PDD ac = {c.x - a.x, c.y - a.y};
        return cross(ab, ac);
    }

    void andrew() {
        sort(poi + 1, poi + 1 + n, cmp);
        top = 0;
        for (int i = 1; i <= n; ++i) {
            while (top >= 2 && area(poi[stk[top-1]].q, poi[stk[top]].q, poi[i].q) < 0) 
                top--;
            stk[++top] = i;
        }
        for (int i = n-1; i >= 1; --i) {
            while (top >= 2 && area(poi[stk[top-1]].q, poi[stk[top]].q, poi[i].q) < 0) 
                top--;
            stk[++top] = i;
        }
        top--; // 首尾重复，需减1
        stk[0] = stk[top]; stk[top+1] = stk[1]; // 成环处理
    }

    int main() {
        cin >> n;
        if (n == 1) {
            printf("1\n");
            return 0;
        }
        for (int i = 1; i <= n; ++i) {
            cin >> poi[i].q.x >> poi[i].q.y;
            poi[i].id = i;
        }
        andrew();
        for (int i = 1; i <= top; ++i) {
            double a = get_dist(poi[stk[i-1]].q, poi[stk[i]].q);
            double b = get_dist(poi[stk[i]].q, poi[stk[i+1]].q);
            double c = get_dist(poi[stk[i-1]].q, poi[stk[i+1]].q);
            double angle = pi - acos((a*a + b*b - c*c) / (2*a*b));
            ans[poi[stk[i]].id] = angle / pi_2;
        }
        for (int i = 1; i <= n; ++i) 
            printf("%.10lf\n", ans[i]);
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入，处理$N=1$的特殊情况。通过Andrew算法求凸包（排序后分别处理上下凸壳），然后对凸包上的每个点，利用余弦定理计算其相邻边的夹角，最终得到该点的概率（角度占比）。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：作者 LittleMoMol**
* **亮点**：凸包求解逻辑清晰，通过Andrew算法处理上下凸壳，成环处理避免越界。
* **核心代码片段**：
    ```cpp
    void andrew() {
        sort(poi + 1, poi + 1 + n, cmp);
        top = 0;
        for (int i = 1; i <= n; ++i) {
            while (top >= 2 && area(poi[stk[top-1]].q, poi[stk[top]].q, poi[i].q) < 0) 
                top--;
            stk[++top] = i;
        }
        // 下凸壳处理...
        top--;
        stk[0] = stk[top]; stk[top+1] = stk[1];
    }
    ```
* **代码解读**：Andrew算法先对所有点按坐标排序，然后分别构建上凸壳和下凸壳。`while`循环通过叉积判断当前点是否在凸包内（若叉积<0，说明当前点是凹点，需弹出栈顶）。成环处理（`stk[0]`和`stk[top+1]`）确保后续角度计算时能访问到相邻点。
* 💡 **学习笔记**：凸包求解的关键是通过叉积判断点的凹凸性，排序和双端处理是Andrew算法的核心。

**题解二：作者 wmy_goes_to_thu**
* **亮点**：使用Graham算法，通过极角排序和叉积判断凸包点，处理共线点。
* **核心代码片段**：
    ```cpp
    while (r >= 2) {
        if ((a[st[r-1]]-a[st[r]])*(a[i]-a[st[r]]) >= 0) 
            vis[st[r--]] = 0;
        else break;
    }
    ```
* **代码解读**：这段代码在构建凸包时，通过叉积判断新点是否导致凸包凹陷（叉积≥0时，当前栈顶的点是凹点，需弹出）。`vis`数组标记凸包上的点，确保后续角度计算只处理凸包顶点。
* 💡 **学习笔记**：Graham算法的核心是极角排序和叉积判断，能有效排除共线点。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解凸包构建和角度计算，我们设计一个“像素几何探险”动画，用8位风格展示算法过程！
</visualization_intro>

  * **动画演示主题**：像素几何探险——寻找无限区域的穴
  * **核心演示内容**：凸包构建过程（点按顺序排列，凹点被“弹出”）、凸包上点的角度计算（中垂线生成，夹角高亮）、概率结果的扇形展示。
  * **设计思路简述**：8位像素风（FC游戏画面）降低学习压力，关键步骤（如凸包弹出凹点）用闪烁和音效强化记忆；角度区域用渐变颜色区分，直观展示概率占比。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 像素网格背景（16色调色板，如深蓝背景、白色网格）。
        - 输入点用彩色像素块表示（如红色代表穴，编号标注）。
        - 控制面板：单步/自动播放按钮、速度滑块（1x-5x）。

    2.  **凸包构建**：
        - 点按坐标排序（从左到右，下到上），用箭头指示排序顺序。
        - 构建上凸壳时，点逐个入栈，遇到凹点（叉积<0）时，栈顶点像素块闪烁并弹出（伴随“噗”的音效）。
        - 下凸壳同理，最终形成闭合凸包（绿色边框）。

    3.  **角度计算**：
        - 对每个凸包顶点（如点B），计算其相邻顶点A、C的中垂线（紫色虚线）。
        - 中垂线夹角区域（蓝色渐变）动态展开，显示角度值（如$\theta=1.2\pi$）。
        - 角度计算时，用公式卡（如余弦定理）弹出提示，伴随“叮”的音效。

    4.  **概率结果**：
        - 最终概率用扇形图展示（围绕原点，半径极大），各凸包点的扇形颜色与对应穴一致。
        - 播放“胜利”音效，显示概率值（如0.5、0.3等）。

  * **旁白提示**：
    - “看！这个点被弹出了，因为它在凸包内部，概率为0哦～”
    - “中垂线在这里形成了一个夹角，这个夹角越大，对应穴的概率就越高！”

<visualization_conclusion>
通过这样的动画，我们能直观看到凸包如何筛选出有效点，以及角度如何决定概率，学习过程就像玩一款几何冒险游戏！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固几何算法和凸包应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 凸包不仅用于概率问题，还可解决最近点对、最大面积三角形等问题。
    - 角度计算在极角排序、方向判断中也有广泛应用（如计算向量夹角）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1340 兽径管理**
        * 🗣️ **推荐理由**：考察凸包的动态维护，适合练习凸包构建的细节处理。
    2.  **洛谷 P1452 Beauty Contest**
        * 🗣️ **推荐理由**：求凸包上点的最大距离（直径），巩固凸包应用和距离计算。
    3.  **洛谷 P1183 多边形面积**
        * 🗣️ **推荐理由**：通过凸包顶点计算面积，练习几何基础操作。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
LittleMoMol在题解中提到：“细节真是太多了，写这篇题解花了大概俩小时吧，还是有一些收获！” 这提醒我们，几何题需要仔细处理边界条件（如共线点、凸包成环）。
</insights_intro>

> **参考经验**：“处理凸包时，共线点的排除很关键，否则中间点会被错误计入凸包，导致概率计算错误。”
> 
> **点评**：这位作者的经验非常实用！几何题中，边界条件（如共线、点重复）往往是易错点，需要通过测试用例验证代码的鲁棒性。

---

<conclusion>
本次关于“AGC021B Holes”的分析就到这里。通过理解凸包的性质和角度计算，我们掌握了无限平面中概率问题的解决方法。记住，几何题的关键是“画图+严谨”，多动手模拟过程，就能攻克难题！下次见～💪
</conclusion>

---

---
处理用时：152.80秒
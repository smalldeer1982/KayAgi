# 题目信息

# [ARC010C] 積み上げパズル

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc010/tasks/arc010_3

高橋君はある日、以下のようなゲームで遊ぶことにしました。  
 $ m $ 色のブロックが $ n $ 個、$ 1 $ つずつ順番に落ちてきます。  
 $ 1 $ つ落ちてくるたびに、高橋君は落ちてきたそのブロックを取って山に積むか、積まずに捨てるか選べます。  
 ブロックを積む山は $ 1 $ つで、ブロックは必ず山の一番上に積まないといけません。  
 全てのブロックが落ちきった後、出来た山は以下のように評価されます。

- 色ボーナス：色ごとに決められた得点が、山に含まれている個数分与えられます。
- コンボボーナス：同じ色のブロックが $ x $ 個続いて積まれている場合、コンボボーナス配点 $ Y $ に応じて $ Y×(x-1) $ 点が与えられます。
- 全色ボーナス：山の中に $ m $ 色のブロックがそれぞれ $ 1 $ 個以上含まれていると $ Z $ 点が与えられます。
 
 落ちてくるブロックの種類と順番、またそれぞれ山を評価するための配点が与えられたとき、評価で得ることのできる最高得点を求めなさい。 入力は以下の形式で標準入力から与えられる。 > $ n $ $ m $ $ Y $ $ Z $ $ c_1 $ $ p_1 $ $ c_2 $ $ p_2 $ $ : $ $ : $ $ c_m $ $ p_m $ $ b_1b_2\ ‥‥\ b_n $

- $ 1 $ 行目に $ n,\ m,\ Y,\ Z $ が半角スペースで区切られて与えられる。 
  1. $ n $ はブロックの個数で $ 1≦n≦5,000 $ を満たす。
  2. $ m $ はブロックの色の総数で $ 1≦m≦10 $ を満たす。
  3. $ Y $ はコンボボーナス配点で $ -100≦Y≦100 $ を満たす。
  4. $ Z $ は全色ボーナス配点で $ -10,000≦Z≦10,000 $ を満たす。
  5. $ n,\ m,\ Y,\ Z $ は全て整数である。
- $ 2 $ 行目からの $ m+1 $ 行目までの $ m $ 行で色ボーナスの配点がそれぞれ与えられる。 
  1. $ c_i $ は $ i(1≦i≦m) $ 番目に与えられるブロックの色である。
  2. $ p_i $ は $ c_i $ に対する色ボーナスの配点である。
  3. $ c_i $ は英大文字(`A`-`Z`)、$ p_i $ は $ -100≦p_i≦100 $ を満たす。
  4. 配点は重複して与えられない（$ x≠y $ ならば $ c_x≠c_y $)
- $ m+2 $ 行目には落ちてくるブロックの順序を表す長さ $ n $ の文字列が与えられる。 
  1. $ b_j $ は $ j(1≦j≦n) $ 番目に落ちてくるブロックの色を表している。
  2. $ b_j $ は $ c_1,c_2,...,c_m $ のいずれかである。
 
 評価で得ることのできる得点の最大値を標準出力に $ 1 $ 行で出力せよ。  
 なお、最後には改行を出力せよ。 ```

5 3 3 5
R 1
G 1
B 1
RGBRR
```

 ```

13
```

- 全てのブロックを山に積むと、 
  - 色ボーナス：どの色も配点が $ 1 $ 点なので、$ 1 $ 点 × $ 5 $ 個 $ =\ 5 $点
  - コンボボ−ナス：Rが $ 2 $ 個連続しているので、$ 3×(2-1)=3 $ 点
  - 全色ボーナス：全ての色が $ 1 $ つ以上山に積まれているので、$ 5 $ 点
   
   により、$ 5+3+5=13 $ 点が与えられます。
- いずれかのブロックを捨てるとこの点数よりも低くなるので、答えは $ 13 $ 点です。
 
```

3 3 3 5
R 1
G 3
B 2
RBR
```

 ```

5
```

- 全てのブロックを山に積むと、 
  - 色ボーナス：$ 1 $ 点 $ ×2 $ 個 $ +2 $ 点 $ ×1 $ 個 $ =4 $ 点
  - 連続していないのでコンボボーナス、Gが含まれていないので全色ボーナスはそれぞれ $ 0 $ 点
   
   により、$ 4 $ 点です。
- しかし、Bを捨ててRRを山に積むと、 
  - 色ボーナス：$ 1 $ 点 $ ×2 $ 個 $ =2 $ 点
  - コンボボーナス：$ 3×(2-1)=3 $ 点
   
   で、$ 5 $ 点が最高得点です。
 
```

8 3 5 3
R 1
G 1
B 1
RRGRRBRR
```

 ```

31
```

- 図 $ (a) $ のように順に $ 8 $ 個のブロックが落ちてきます。
- ブロックを全部山に積むと、図 $ (b) $ のように、$ 2 $ 個のコンボが $ 3 $ 組できます。
- また、全色ボーナスもつくので、$ 1 $ 点 × $ 8 $ 個 + $ 5 $ 点 $ ×\ (2-1)\ ×\ 3 $ 組 $ +\ 3 $ 点 $ =\ 26 $ 点です。
- しかし、図 $ (c) $ のようにRのみを山に積むと、$ 1 $ 点 × $ 6 $ 個 + $ 5 $ 点 $ ×\ (6-1)\ +\ 0 $ 点 $ =\ 31 $ 点になります。
- Rだけ山に積むとき最高得点となり、$ 31 $ が答えです。
 
![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc010_3/0bee256b459d39c38c7b58d68d6189c67aa5bbed.png)```

8 3 5 3
R 1
G 100
B 1
RRGRRBRR
```

 ```

126
```

- 全部積んだ場合(図 $ (a) $)：$ 107 $ 点 + $ 5 $ 点 $ ×\ (2-1)\ ×\ 3 $ 組 $ +\ 3 $ 点 $ =\ 125 $ 点
- Rのみを積んだ場合(図 $ (b) $)：$ 6 $ 点 + $ 5 $ 点 $ ×\ (6-1)\ +\ 0 $ 点 $ =\ 31 $ 点
- B以外を積んだ場合(図 $ (c) $)：$ 106 $ 点 + $ 5 $ 点 $ ×\ \{(2-1)\ +\ (4-1)\}\ +\ 0 $ 点 $ =\ 126 $ 点
- したがって、最高得点は $ 126 $ 点です。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc010_3/6cccf310c6e56c5cd110ae0c64aa6d53ab92ea51.png)

# AI分析结果



---
# 💡 Kay的C++算法解析：積み上げパズル 深入学习指南 💡

<introduction>
今天我们来一起分析“積み上げパズル”这道题。它需要我们通过选择保留或舍弃下落的方块，最大化最终堆叠的得分。本指南将帮助你理解核心算法、关键步骤，并通过可视化演示直观感受解题过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）

🗣️ **初步分析**：
解决这道题的关键在于用动态规划（DP）记录每一步选择后的状态，从而找到最优解。动态规划就像“走一步看十步”的策略——每处理一个方块（选择保留或舍弃），我们需要记录当前堆叠的关键信息（如顶部颜色、连续长度、是否包含所有颜色等），并根据这些信息计算后续的最大得分。

- **题解思路**：由于每个方块的选择会影响后续得分（如连续奖励、全色奖励），我们需要用DP状态表示当前堆叠的“状态快照”。常见思路是定义状态为`dp[i][last][cnt][mask]`，其中`i`是已处理到第`i`个方块，`last`是当前堆叠顶部的颜色，`cnt`是当前连续同色的数量，`mask`是已包含的颜色集合（用位掩码表示）。状态值为当前的最大得分。
- **核心难点**：状态设计需平衡“信息完整性”和“复杂度”（n=5000，m=10，状态过多会超时）；得分计算需同时处理颜色奖励、连续奖励和全色奖励的动态变化。
- **可视化设计**：用8位像素风展示堆叠过程，方块以不同颜色（如R红、G绿、B蓝）的像素块表示。动画中，每处理一个方块时，用闪烁箭头标记“保留”或“舍弃”的选择，顶部颜色和连续长度用文字气泡实时显示，得分变化用数字跳动效果呈现。关键状态转移步骤（如连续长度增加、颜色集合更新）用颜色渐变高亮。

---

## 2. 精选优质题解参考

<eval_intro>
目前提供的题解信息中暂无具体题解内容。不过，我们可以从动态规划的通用思路出发，总结学习建议：
</eval_intro>

**通用学习建议**：
- 优先明确状态定义：需包含“当前处理到第几个方块”“顶部颜色”“连续同色数量”“已包含的颜色集合”这四个维度。
- 关注状态转移：对于每个方块，有两种选择（保留或舍弃）。保留时需更新顶部颜色、连续长度和颜色集合；舍弃时状态不变。
- 优化状态空间：由于m≤10，颜色集合可用位掩码（如`mask`，二进制位表示是否包含对应颜色）；连续长度可限制最大值（如当前方块颜色与顶部相同则+1，否则重置为1）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们常遇到以下关键难点。结合动态规划的特性，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何设计高效的DP状态？**
    * **分析**：状态需包含足够信息计算得分，但不能过多导致超时。例如：
      - `i`（处理到第i个方块）：范围0~n，必须保留。
      - `last`（顶部颜色）：m种可能（m≤10）。
      - `cnt`（连续同色数量）：最多连续n个，但实际只需记录到可能影响连续奖励的值（如Y为正时，越长越好；Y为负时可能舍弃）。
      - `mask`（颜色集合）：m位二进制数（最多2^10=1024种可能）。
      总状态数约为n*m*n*2^m=5000*10*5000*1024，这显然太大。需优化：观察到`cnt`在颜色变化时会重置为1，实际有效`cnt`可能较小（如最多连续到当前方块数），或通过滚动数组减少空间。
    * 💡 **学习笔记**：状态设计需“精准”——只保留影响后续得分的关键信息。

2.  **关键点2：如何计算动态得分？**
    * **分析**：得分由三部分组成：
      - 颜色奖励：每保留一个方块，累加对应颜色的p值。
      - 连续奖励：当前连续长度为x时，贡献Y*(x-1)（仅当x≥2时）。
      - 全色奖励：当`mask`包含所有m位时，加Z。
      这些得分需在状态转移时动态计算。例如，保留当前方块时，颜色奖励直接累加；连续奖励需比较当前连续长度与之前的长度，计算差值；全色奖励仅在`mask`更新为全1时触发。
    * 💡 **学习笔记**：得分计算需与状态转移同步，避免重复计算。

3.  **关键点3：如何处理“舍弃”操作的状态转移？**
    * **分析**：舍弃当前方块时，堆叠状态（last、cnt、mask）不变，仅i增加。此时需比较“舍弃后”与“保留后”的得分，取最大值。例如，若当前保留得分较低，舍弃可能更优（如示例2中舍弃B方块）。
    * 💡 **学习笔记**：“舍弃”不是失败，而是权衡后的最优选择。

### ✨ 解题技巧总结
- **状态压缩**：用位掩码（mask）表示颜色集合，减少状态维度。
- **滚动数组**：由于i只依赖i-1的状态，可用一维数组滚动更新，节省空间。
- **预处理颜色奖励**：将每个颜色的p值存入哈希表，快速查询。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
由于暂无具体题解，我们基于动态规划思路，设计一个通用核心实现。该代码通过状态压缩和滚动数组优化，适用于n=5000、m=10的场景。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于动态规划，状态定义为`dp[last][cnt][mask]`（当前顶部颜色、连续长度、颜色集合），用滚动数组优化空间。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <unordered_map>
    #include <algorithm>
    #include <bitset>
    using namespace std;

    int main() {
        int n, m, Y, Z;
        cin >> n >> m >> Y >> Z;
        unordered_map<char, int> color_p;
        unordered_map<char, int> color_id; // 颜色到0~m-1的映射
        for (int i = 0; i < m; ++i) {
            char c; int p;
            cin >> c >> p;
            color_p[c] = p;
            color_id[c] = i;
        }
        string b; cin >> b;

        // 初始化DP：dp[last][cnt][mask] = max_score
        // 用滚动数组，每次处理一个方块后更新
        vector<vector<unordered_map<int, int>>> dp_prev(m, vector<unordered_map<int, int>>(n + 1));
        dp_prev[0][0][0] = 0; // 初始状态：无方块，得分为0

        for (char cur_c : b) {
            vector<vector<unordered_map<int, int>>> dp_curr(m, vector<unordered_map<int, int>>(n + 1));
            int cur_id = color_id[cur_c];
            int cur_p = color_p[cur_c];

            // 遍历所有可能的前一状态
            for (int last = 0; last < m; ++last) {
                for (int cnt = 0; cnt <= n; ++cnt) {
                    for (auto& [mask, score] : dp_prev[last][cnt]) {
                        // 选择1：舍弃当前方块
                        if (dp_curr[last][cnt].count(mask) == 0 || score > dp_curr[last][cnt][mask]) {
                            dp_curr[last][cnt][mask] = score;
                        }

                        // 选择2：保留当前方块
                        int new_last = cur_id;
                        int new_cnt = (last == cur_id) ? cnt + 1 : 1;
                        int new_mask = mask | (1 << cur_id);
                        int add_score = cur_p; // 颜色奖励
                        if (new_cnt >= 2) add_score += Y * (new_cnt - 1); // 连续奖励（仅当前连续部分）
                        int total_score = score + add_score;

                        // 全色奖励在最后计算，这里先记录mask，最终再判断
                        if (dp_curr[new_last][new_cnt].count(new_mask) == 0 || total_score > dp_curr[new_last][new_cnt][new_mask]) {
                            dp_curr[new_last][new_cnt][new_mask] = total_score;
                        }
                    }
                }
            }
            dp_prev = move(dp_curr);
        }

        // 计算最终得分（包括全色奖励Z）
        int max_score = 0;
        for (int last = 0; last < m; ++last) {
            for (int cnt = 0; cnt <= n; ++cnt) {
                for (auto& [mask, score] : dp_prev[last][cnt]) {
                    if (mask == (1 << m) - 1) { // 全色奖励
                        max_score = max(max_score, score + Z);
                    } else {
                        max_score = max(max_score, score);
                    }
                }
            }
        }
        cout << max_score << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并初始化颜色映射。动态规划状态`dp_prev`保存前一步的状态（顶部颜色、连续长度、颜色集合）及对应得分。对于每个方块，遍历所有可能的前一状态，分别处理“舍弃”和“保留”两种选择，更新当前状态的得分。最后遍历所有最终状态，计算全色奖励后的最大得分。

---
<code_intro_selected>
由于暂无具体题解，我们以核心代码中的关键片段为例，分析动态规划的核心逻辑：
</code_intro_selected>

**核心代码片段（状态转移部分）**：
```cpp
// 选择1：舍弃当前方块
if (dp_curr[last][cnt].count(mask) == 0 || score > dp_curr[last][cnt][mask]) {
    dp_curr[last][cnt][mask] = score;
}

// 选择2：保留当前方块
int new_last = cur_id;
int new_cnt = (last == cur_id) ? cnt + 1 : 1;
int new_mask = mask | (1 << cur_id);
int add_score = cur_p; // 颜色奖励
if (new_cnt >= 2) add_score += Y * (new_cnt - 1); // 连续奖励
int total_score = score + add_score;
if (dp_curr[new_last][new_cnt].count(new_mask) == 0 || total_score > dp_curr[new_last][new_cnt][new_mask]) {
    dp_curr[new_last][new_cnt][new_mask] = total_score;
}
```
* **代码解读**：
    > 这部分处理每个方块的两种选择：
    > - 舍弃时，状态（last、cnt、mask）不变，得分保持前一状态的最大值。
    > - 保留时，更新顶部颜色（new_last）、连续长度（new_cnt）和颜色集合（new_mask），并计算新增的颜色奖励和连续奖励，更新当前状态的得分。
* 💡 **学习笔记**：状态转移的核心是“比较选择后的得分，保留最大值”，确保每一步都选择最优路径。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解堆叠过程和动态规划的状态转移，我们设计一个“像素堆叠小能手”动画，用8位复古风格展示每一步的选择和得分变化！
</visualization_intro>

  * **动画演示主题**：`像素堆叠大挑战——争做得分王`
  * **核心演示内容**：展示每个方块下落时“保留”或“舍弃”的选择，以及堆叠后的顶部颜色、连续长度、颜色集合变化，实时计算得分。
  * **设计思路简述**：8位像素风（类似FC游戏）让学习更轻松；关键操作（保留/舍弃）用闪烁按钮提示，得分变化用数字跳动增强记忆；连续奖励触发时，顶部方块颜色渐变，配合“叮”的音效，强化逻辑理解。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为三部分：左侧是堆叠区（像素网格，每个位置显示方块颜色），中间是状态区（显示当前顶部颜色、连续长度、颜色集合），右侧是控制面板（开始/暂停、单步、速度滑块）。
          * 背景音乐：8位风格的轻快旋律（如《超级马里奥》的经典BGM变奏）。

    2.  **方块下落与选择**：
          * 每个方块以像素块形式从屏幕顶部下落（类似俄罗斯方块），颜色与输入一致（如R红、G绿）。
          * 控制面板弹出“保留”（绿色按钮）和“舍弃”（红色按钮）选项，学习者可点击选择（或AI自动演示最优选择）。

    3.  **状态更新可视化**：
          * **保留时**：方块滑入堆叠区顶部，颜色与堆叠区顶部对比：
            - 若颜色相同，连续长度+1，顶部方块颜色加深（如红色→深红），伴随“连续+1”音效（短促的“滴”声）。
            - 若颜色不同，连续长度重置为1，顶部方块颜色切换，伴随“新颜色”音效（轻快的“叮”声）。
          * **舍弃时**：方块消失（变灰），堆叠区无变化，伴随“舍弃”音效（低沉的“噗”声）。
          * 颜色集合用m个小灯表示（初始全灭），每包含一种颜色，对应灯亮起（绿色），全亮时触发全色奖励（闪烁+“胜利”音效）。

    4.  **得分实时计算**：
          * 得分区数字实时跳动：颜色奖励（+p值）用绿色数字，连续奖励（+Y*(x-1)）用黄色数字，全色奖励（+Z）用金色数字。

    5.  **AI自动演示模式**：
          * 点击“AI演示”，算法自动选择最优路径，方块按动态规划的最优决策保留或舍弃，学习者可观察整个过程。

  * **旁白提示**：
      * “当前方块是红色！如果保留，连续长度可能增加哦～”
      * “看，颜色集合的绿灯又亮了一个，离全色奖励更近啦！”
      * “舍弃这个方块后，得分暂时不变，但可能为后续留出更好的选择～”

<visualization_conclusion>
通过这个动画，你可以“看”到动态规划如何一步步选择最优路径，理解状态转移的每一个关键步骤，让抽象的算法变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
动态规划在处理“序列选择+状态依赖”问题时非常高效。掌握本题后，可尝试以下拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 本题的状态设计（顶部颜色、连续长度、颜色集合）可迁移到“序列分组”“最长连续子序列”等问题。
      - 得分计算的动态性（多因素叠加）与“股票买卖”“任务调度”中的收益计算类似。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1854 [蓝桥杯 2016 省] 种树**
          * 🗣️ **推荐理由**：需考虑相邻位置的状态依赖（类似连续奖励），状态设计包含“是否种树”，与本题的“保留/舍弃”思路相似。
    2.  **洛谷 P1077 [NOIP2012 普及组] 摆花**
          * 🗣️ **推荐理由**：涉及多维度状态（花的种类、数量），与本题的颜色集合（mask）状态设计有共通之处。
    3.  **洛谷 P1137 旅行计划**
          * 🗣️ **推荐理由**：需处理序列中的连续条件（类似连续奖励），动态规划的状态转移逻辑可借鉴。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但根据题目特点，我们可以总结：动态规划的关键是“状态定义”和“转移逻辑”，多画图、多模拟状态变化是理解的关键！
</insights_intro>

-----

<conclusion>
“積み上げパズル”的分析就到这里。通过动态规划记录状态、权衡选择，我们可以高效解决这类序列决策问题。希望你能在练习中掌握状态设计的技巧，下次遇到类似问题时，轻松找到最优解！💪
</conclusion>

-----

---
处理用时：123.56秒
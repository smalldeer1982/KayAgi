# 题目信息

# [ABC107D] Median of Medians

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc107/tasks/arc101_b

長さ $ M $ の数列 $ b $ の **中央値** を次のように定義します。

- $ b $ を昇順にソートして得られる数列を $ b' $ とする。 このとき、$ b' $ の $ M\ /\ 2\ +\ 1 $ 番目の要素の値を、$ b $ の中央値とする。 ここで、$ / $ は小数点以下を切り捨てる除算である。

例えば、$ (10,\ 30,\ 20) $ の中央値は $ 20 $ であり、$ (10,\ 30,\ 20,\ 40) $ の中央値は $ 30 $ であり、$ (10,\ 10,\ 10,\ 20,\ 30) $ の中央値は $ 10 $ です。

すぬけ君は次のような問題を思いつきました。

長さ $ N $ の数列 $ a $ があります。 各 $ (l,\ r) $ ($ 1\ \leq\ l\ \leq\ r\ \leq\ N $) について、$ a $ の連続部分列 $ (a_l,\ a_{l\ +\ 1},\ ...,\ a_r) $ の中央値を $ m_{l,\ r} $ とします。 すべての $ (l,\ r) $ に対する $ m_{l,\ r} $ を並べ、新たに数列 $ m $ を作ります。 $ m $ の中央値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ a_i $ は整数である。
- $ 1\ \leq\ a_i\ \leq\ 10^9 $

### Sample Explanation 1

$ a $ のそれぞれの連続部分列の中央値は次のようになります。 - $ (10) $ の中央値は $ 10 $ - $ (30) $ の中央値は $ 30 $ - $ (20) $ の中央値は $ 20 $ - $ (10,\ 30) $ の中央値は $ 30 $ - $ (30,\ 20) $ の中央値は $ 30 $ - $ (10,\ 30,\ 20) $ の中央値は $ 20 $ よって、$ m\ =\ (10,\ 30,\ 20,\ 30,\ 30,\ 20) $ となり、$ m $ の中央値は $ 30 $ です。

## 样例 #1

### 输入

```
3

10 30 20```

### 输出

```
30```

## 样例 #2

### 输入

```
1

10```

### 输出

```
10```

## 样例 #3

### 输入

```
10

5 9 5 9 8 9 3 5 4 3```

### 输出

```
8```

# AI分析结果



---

# 💡 Kay的C++算法解析：[ABC107D] Median of Medians 深入学习指南 💡

<introduction>
今天我们要挑战的题目是“Median of Medians”，也就是求所有连续子段中位数的中位数。这道题需要结合二分答案、前缀和和树状数组的技巧，听起来有点复杂？别担心，跟着Kay一步步拆解，你会发现它的核心逻辑其实很清晰！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分答案 + 前缀和 + 树状数组`

🗣️ **初步分析**：
解决这道题的关键在于利用中位数的“单调性”——如果某个数是最终答案，那么所有比它小的数都不可能是答案。因此，我们可以用**二分法**来猜测答案，然后验证是否存在足够多的子段中位数≥当前猜测的数。

具体来说，对于每个猜测的数`x`，我们需要计算有多少个连续子段的中位数≥`x`。这里有个巧妙的转换：将原数组中≥`x`的数标记为`1`，<`x`的标记为`-1`，那么一个子段的中位数≥`x`等价于该子段的和≥0（因为排序后中间位置的数≥`x`意味着至少有一半的数≥`x`）。

接下来，问题转化为：统计所有子段和≥0的数量。这可以通过**前缀和**和**树状数组**高效解决。前缀和数组`sum[i]`表示前`i`项的和，那么子段`[l, r]`的和为`sum[r] - sum[l-1]`。要统计`sum[r] - sum[l-1] ≥ 0`的数量，等价于统计对于每个`r`，有多少个`l-1`满足`sum[l-1] ≤ sum[r]`。这可以通过树状数组动态维护前缀和的出现次数来实现。

可视化设计上，我们可以用8位像素风格模拟：原数组用彩色方块表示，转换后的±1数组用红（-1）绿（1）区分；前缀和用动态上升/下降的柱状图展示；树状数组用堆叠的像素块表示，每次查询时高亮当前`sum[r]`对应的区间，配合“叮”的音效提示计数增加。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性和算法有效性评估，以下3道题解（评分≥4星）值得重点学习：
</eval_intro>

**题解一：作者bugmaker3243（赞15）**  
* **点评**：此题解思路完整，从二分答案的核心思想到树状数组的偏移处理都解释得非常清楚。代码中变量命名规范（如`sum`表示前缀和，`c`表示树状数组），边界条件处理严谨（如树状数组大小设为`2*N`避免越界）。亮点在于将树状数组的偏移量设为`N`，巧妙解决了前缀和可能为负数的问题，时间复杂度分析准确（`O(N log²N)`），适合直接作为竞赛参考。

**题解二：作者KingPowers（赞3）**  
* **点评**：此题解代码简洁，核心逻辑（转换±1数组、前缀和统计）一目了然。虽然部分变量名（如`ID(x)`）稍显简略，但通过注释能快速理解。亮点在于将树状数组的更新和查询封装成函数，提高了代码可读性，适合学习如何模块化实现树状数组。

**题解三：作者zac2010（赞2）**  
* **点评**：此题解对二分答案的条件判断（`(cnt << 1) >= num`）解释清晰，树状数组的`resize`操作考虑了不同测试用例的通用性。亮点在于将树状数组的维护单独封装成结构体，结构清晰，适合学习如何设计可复用的数据结构模块。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要重点突破以下3个关键点：
</difficulty_intro>

1.  **关键点1：如何将中位数问题转化为区间和问题？**  
    * **分析**：中位数的定义是排序后的中间值。对于子段`[l, r]`，其中位数≥`x`的条件是：该子段中至少有一半的数≥`x`（严格来说，是排序后第`(r-l+1)/2 +1`位≥`x`）。通过将≥`x`的数标记为`1`，<`x`的标记为`-1`，子段和≥0等价于中位数≥`x`（因为和≥0时，≥`x`的数的数量至少比<`x`的多1）。  
    * 💡 **学习笔记**：遇到中位数问题时，尝试用±1转换将问题转化为区间和问题，是常见的“离散化”技巧。

2.  **关键点2：如何高效统计满足条件的区间数？**  
    * **分析**：前缀和数组`sum[i]`表示前`i`项的和，子段`[l, r]`的和为`sum[r] - sum[l-1]`。要统计`sum[r] - sum[l-1] ≥ 0`的数量，等价于对每个`r`，统计有多少个`l-1`满足`sum[l-1] ≤ sum[r]`。树状数组可以在`O(logN)`时间内完成这个统计，通过动态维护前缀和的出现次数。  
    * 💡 **学习笔记**：树状数组适合处理“动态统计比当前值小的元素个数”的问题，注意处理负数前缀和时需要偏移。

3.  **关键点3：二分答案的边界条件如何确定？**  
    * **分析**：总共有`n*(n+1)/2`个子段，新序列的中位数是第`(总数+1)/2`大的数（向下取整）。因此，当满足条件的区间数≥`(总数+1)/2`时，说明当前猜测的`x`可能更小，需要向右调整二分边界；否则向左调整。  
    * 💡 **学习笔记**：二分答案的关键是明确“判断条件”与“答案范围”的关系，本题中答案一定是原数组中的某个数，因此可以先排序原数组再二分。

### ✨ 解题技巧总结
- **问题转换**：将中位数问题转换为±1数组的区间和问题，简化条件判断。  
- **前缀和+树状数组**：利用前缀和将子段和问题转换为二维偏序问题，树状数组高效统计符合条件的前缀和数量。  
- **偏移处理**：前缀和可能为负数，通过加`N`（或其他偏移量）转换为非负数索引，避免树状数组越界。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个综合了优质题解思路的通用核心实现，它完整展示了二分答案、±1转换、前缀和计算和树状数组统计的全过程。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了bugmaker3243和zac2010的题解思路，优化了变量命名和边界处理，适合直接作为学习模板。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define N 100005
    #define int long long
    #define lb(x) (x & -x)
    using namespace std;

    int n, a[N], tmp[N], sum[N], c[N * 2]; // 树状数组大小设为2*N，处理偏移

    void add(int k, int x) {
        for (; k < 2 * N; k += lb(k)) c[k] += x;
    }

    int ask(int k) {
        int s = 0;
        for (; k; k -= lb(k)) s += c[k];
        return s;
    }

    bool check(int x) {
        memset(c, 0, sizeof(c));
        sum[0] = 0;
        add(N, 1); // 初始时sum[0] = 0，偏移后为N
        for (int i = 1; i <= n; ++i) {
            sum[i] = sum[i - 1] + (a[i] >= x ? 1 : -1);
            int cnt = ask(sum[i] + N); // 统计sum[l-1] <= sum[i]的数量
            add(sum[i] + N, 1); // 将当前sum[i]加入树状数组
        }
        int total = n * (n + 1) / 2;
        return cnt >= (total + 1) / 2; // 判断满足条件的区间数是否足够
    }

    signed main() {
        scanf("%lld", &n);
        for (int i = 1; i <= n; ++i) {
            scanf("%lld", &a[i]);
            tmp[i] = a[i];
        }
        sort(tmp + 1, tmp + n + 1); // 排序原数组用于二分

        int l = 1, r = n, ans = 0;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (check(tmp[mid])) {
                ans = tmp[mid];
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并排序原数组（用于二分），然后通过`check`函数判断当前猜测的`x`是否可能为答案。`check`函数中，将原数组转换为±1数组，计算前缀和，并用树状数组统计满足`sum[r] - sum[l-1] ≥ 0`的区间数。最后根据统计结果调整二分边界，找到最大的`x`使得满足条件的区间数足够。

---

<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习其中的巧妙设计：
</code_intro_selected>

**题解一：作者bugmaker3243**  
* **亮点**：树状数组的偏移处理（加`N`）和初始值`sum[0]`的处理非常严谨。  
* **核心代码片段**：
    ```cpp
    int check(int x) {
        int ans = 0;
        memset(c, 0, sizeof(c));
        for (int i = 1; i <= n; i++) {
            b[i] = (a[i] >= x) ? 1 : -1;
            sum[i] = sum[i-1] + b[i];
        }
        add(N, 1); // 插入sum[0]
        for (int i = 1; i <= n; i++) {
            ans += ask(sum[i] + N);
            add(sum[i] + N, 1);
        }
        return ans >= (n*(n+1)/2 - 1)/2 + 1;
    }
    ```
* **代码解读**：  
  `check`函数中，`sum[i]`是前`i`项的±1和。`add(N, 1)`初始化树状数组，将`sum[0]`（初始为0）偏移后的值`N`加入树状数组。对于每个`i`，`ask(sum[i] + N)`统计有多少个`sum[l-1] ≤ sum[i]`（即`l-1 < i`时的`sum`值），这些`l-1`对应的子段`[l, i]`和≥0。最后判断满足条件的区间数是否超过总数的一半。  
* 💡 **学习笔记**：树状数组的初始插入`sum[0]`是关键，否则会漏掉以第一个元素为右端点的子段（如`[1,1]`）。

**题解二：作者KingPowers**  
* **亮点**：将树状数组的更新和查询封装成函数，代码结构清晰。  
* **核心代码片段**：
    ```cpp
    void add(int x, int y) {
        while (x <= ID(n)) {
            c[x] += y;
            x += lowbit(x);
        }
    }
    int query(int x) {
        int res = 0;
        for (; x; x -= lowbit(x)) res += c[x];
        return res;
    }
    bool check(int mid) {
        memset(c, 0, sizeof(c));
        for (int i = 1; i <= n; i++) {
            b[i] = (a[i] >= mid) ? 1 : -1;
            ss[i] = ss[i-1] + b[i];
        }
        add(ID(0), 1);
        int cnt = 0;
        for (int i = 1; i <= n; i++) {
            cnt += query(ID(ss[i]));
            add(ID(ss[i]), 1);
        }
        return (cnt << 1) >= (n*(n+1) >> 1);
    }
    ```
* **代码解读**：  
  `ID(x)`将`x`偏移`n`（`ID(x) = x + n`），避免负数索引。`add`和`query`函数分别实现树状数组的更新和查询。`check`函数中，`ss[i]`是前缀和，`cnt`统计满足条件的区间数。最后通过`(cnt << 1) >= (n*(n+1) >> 1)`判断是否超过半数。  
* 💡 **学习笔记**：函数封装能提高代码复用性，尤其是在多次调用树状数组的场景中。

**题解三：作者zac2010**  
* **亮点**：将树状数组封装为结构体，支持动态调整大小。  
* **核心代码片段**：
    ```cpp
    struct BIT {
        int n = 0, c[N];
        void clear() { memset(c, 0, sizeof(c)); }
        void resize(int t) { n = t; }
        void add(int x, int v) {
            for (; x <= n; x += x & -x) c[x] += v;
        }
        int ask(int x) {
            int ret = 0;
            for (; x; x -= x & -x) ret += c[x];
            return ret;
        }
    } b;

    int check(int x) {
        ll cnt = 0; b.clear();
        FL(i, 1, n) s[i] = s[i-1] + (a[i] < x ? -1 : 1);
        FL(i, 0, n) cnt += b.ask(s[i]), b.add(s[i], 1);
        return (cnt << 1) >= num;
    }
    ```
* **代码解读**：  
  `BIT`结构体封装了树状数组的初始化、清空、调整大小、更新和查询操作。`check`函数中，`s[i]`是前缀和，`cnt`通过遍历所有前缀和，用树状数组统计满足条件的区间数。最后判断`cnt`是否超过半数。  
* 💡 **学习笔记**：结构体封装适合需要多次使用树状数组的题目，能减少代码冗余。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解二分答案和树状数组统计的过程，Kay设计了一个“像素探险家”主题的8位复古动画！让我们一起“看”算法如何工作吧~
</visualization_intro>

  * **动画演示主题**：`像素探险家的中位数冒险`  
  * **核心演示内容**：探险家在“数字森林”中寻找中位数宝藏，通过二分法猜测宝藏位置（`x`），将森林中的数字转换为±1标记（绿色=1，红色=-1），计算前缀和（动态柱状图），并用树状数组（堆叠的像素块）统计满足条件的区间数。  

  * **设计思路简述**：  
    8位像素风格（FC红白机配色）营造轻松氛围；绿色/红色标记直观展示±1转换；前缀和柱状图随索引动态上升/下降，树状数组用堆叠的方块表示已统计的前缀和，每次查询时高亮当前`sum[r]`对应的方块，配合“叮”的音效强化操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为三部分：左侧是原数组（像素方块，标有数值），中间是±1转换后的数组（绿/红方块），右侧是树状数组（堆叠的灰色方块）。  
        - 控制面板包含“开始/暂停”、“单步”、“重置”按钮和速度滑块。  
        - 8位风格的轻快背景音乐响起。

    2.  **二分启动**：  
        - 原数组排序后显示在顶部，探险家（像素小人）站在中间位置（初始`mid`），猜测`x`为当前值。  
        - 左侧原数组中的元素与`x`比较，≥`x`的变为绿色（1），<`x`的变为红色（-1）。

    3.  **前缀和计算**：  
        - 中间区域的±1数组上方出现动态柱状图（`sum`数组），从左到右逐个计算前缀和。例如，第一个元素是绿色（1），柱状图上升1格；第二个是红色（-1），柱状图下降1格，以此类推。  
        - 每计算一个`sum[i]`，右侧树状数组区域对应位置的方块数量增加（表示该`sum`值已被统计）。

    4.  **树状数组统计**：  
        - 对于每个`sum[i]`，探险家移动到树状数组前，用放大镜查看有多少个`sum[l-1] ≤ sum[i]`（即左侧已统计的前缀和）。  
        - 符合条件的方块高亮（黄色），同时音效“叮”响起，计数`cnt`增加。  
        - 统计完成后，当前`sum[i]`对应的方块加入树状数组（灰色）。

    5.  **二分调整**：  
        - 统计完所有`sum[i]`后，判断`cnt`是否≥总数的一半。如果是，探险家向右移动（增大`x`）；否则向左移动（减小`x`）。  
        - 背景颜色变化（绿色=成功，红色=失败）提示调整方向。

    6.  **目标达成**：  
        - 当二分结束时，探险家站在最终答案的位置，播放胜利音效（欢快的8位旋律），宝藏（金色像素块）从地底升起，显示最终中位数。

  * **旁白提示**：  
    - （转换时）“看！≥x的数变成了绿色（1），<x的变成红色（-1），这样我们就能通过和来判断中位数啦~”  
    - （统计时）“现在，探险家在树状数组里查找有多少个前面的sum值≤当前sum，这些就是满足条件的子段哦！”  
    - （二分时）“如果满足条件的子段足够多，说明x可能太小了，我们要往更大的数找；反之则往小的找~”

<visualization_conclusion>
通过这样的动画，我们不仅能“看”到二分答案的过程，还能直观理解树状数组如何高效统计区间数。下次遇到类似问题，你也可以想象自己是那个像素探险家，一步步破解算法的奥秘！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了这道题的思路后，我们可以尝试用类似的方法解决更多问题。以下是几个相关的拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“二分答案+前缀和+树状数组”，这一组合还可以用于：  
    - 求子段的最小值≥x的数量（转换为±1数组，统计和≥0的区间数）。  
    - 求子段的异或和≥x的数量（需要结合位运算和前缀异或）。  
    - 求二维矩阵中满足条件的子矩阵数量（扩展前缀和到二维，用树状数组或线段树统计）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3031 [USACO11DEC] Grass Planting G**  
        * 🗣️ **推荐理由**：这道题要求统计子段中位数≥x的数量，是本题的简化版，适合巩固“±1转换+前缀和+树状数组”的基础应用。  
    2.  **洛谷 P1972 [SDOI2009] HH的项链**  
        * 🗣️ **推荐理由**：此题需要用树状数组统计区间内不同元素的数量，能帮助你进一步掌握树状数组在离线查询中的应用。  
    3.  **洛谷 P1908 逆序对**  
        * 🗣️ **推荐理由**：逆序对问题是树状数组的经典应用，通过此题可以对比“归并排序”和“树状数组”两种方法的优劣，深化对树状数组的理解。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些经验对我们很有参考价值：
</insights_intro>

> **参考经验 (来自bugmaker3243)**：“最初在树状数组的偏移量处理上犯了错误，没有考虑到前缀和可能为负数，导致数组越界。后来通过增加偏移量`N`解决了问题。”  
> **点评**：这位作者的经验提醒我们，处理前缀和的负数问题时，偏移量的选择要足够大（如本题的`N`），确保所有可能的前缀和都能被正确索引。在调试时，打印中间变量（如`sum[i]`的值）能快速定位越界问题。

---

<conclusion>
通过这道题的学习，我们掌握了“二分答案+前缀和+树状数组”的组合技巧，理解了如何将中位数问题转换为区间和问题，并用树状数组高效统计。编程的魅力在于将复杂问题拆解为可解决的小步骤，只要多思考、多练习，你也能成为算法高手！下次见~ 💪
</conclusion>

---
处理用时：147.73秒
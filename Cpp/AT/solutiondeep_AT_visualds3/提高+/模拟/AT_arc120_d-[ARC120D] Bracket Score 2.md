# 题目信息

# [ARC120D] Bracket Score 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc120/tasks/arc120_d

**括弧の対応が取れている文字列**を、次のうちいずれかの条件を満たす文字列と定義します。

- 空文字列
- ある括弧の対応が取れている空でない文字列 $ s,\ t $ が存在し、$ s,\ t $ をこの順に連結した文字列
- ある括弧の対応が取れている文字列 $ s $ が存在し、 `(`, $ s $, `)` をこの順に連結した文字列

また、括弧の対応が取れている文字列 $ s $ の $ i $ 文字目と $ j $ 文字目が**対応している**とは、以下の条件を全て満たすこととします。

- $ 1\ \le\ i\ <\ j\ \le\ |s| $
- $ s_i\ = $ `(`
- $ s_j\ = $ `)`
- $ s $ の $ i $ 文字目と $ j $ 文字目の間にある文字列 ($ i $ 文字目と $ j $ 文字目は含まない) は括弧の対応が取れている文字列である

長さ $ 2N $ の数列 $ A\ =\ (A_1,\ A_2,\ A_3,\ \dots,\ A_{2N}) $ が与えられます。  
 括弧の対応が取れている長さ $ 2N $ の文字列 $ s $ の**スコア**を、$ s $ の $ i $ 文字目と $ j $ 文字目が対応しているような全ての組 $ (i,\ j) $ について $ |A_i\ -\ A_j| $ を足し合わせたものと定義します。

括弧の対応が取れている長さ $ 2N $ の文字列のうち、スコアが最大となるような文字列を $ 1 $ つ求めてください。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_i\ \le\ 10^9 $
- 入力に含まれる値は全て整数

### Sample Explanation 1

長さ $ 4 $ の括弧の対応が取れている文字列は `(())` と `()()` の $ 2 $ 種類あり、それぞれのスコアは以下の通りです。 - `(())` : $ |1\ -\ 4|\ +\ |2\ -\ 3|\ =\ 4 $ - `()()` : $ |1\ -\ 2|\ +\ |3\ -\ 4|\ =\ 2 $ よって、`(())` のみが正しい答えとなります。

### Sample Explanation 2

`(())` と `()()` のスコアは以下の通りです。 - `(())` : $ |2\ -\ 3|\ +\ |3\ -\ 2|\ =\ 2 $ - `()()` : $ |2\ -\ 3|\ +\ |2\ -\ 3|\ =\ 2 $ よって、この場合どちらを出力しても正解となります。

## 样例 #1

### 输入

```
2

1 2 3 4```

### 输出

```
(())```

## 样例 #2

### 输入

```
2

2 3 2 3```

### 输出

```
()()```

# AI分析结果



---
# 💡 Kay的C++算法解析：Bracket Score 2 深入学习指南 💡

<introduction>
今天我们来一起分析“Bracket Score 2”这道题。这道题需要构造一个合法的括号序列，使得所有匹配括号对的数组值绝对差之和最大。本指南将帮助大家梳理思路，理解核心贪心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
解决这道题的关键在于理解贪心策略的应用。贪心算法就像“每一步都选当前最优”，比如买零食时每次选最想吃的，最后整体也会很满足。在本题中，我们的目标是让每对括号的绝对差尽可能大，因此贪心策略是：将数组分为较小的N个数（“小值组”）和较大的N个数（“大值组”），让每对括号分别来自这两个组，这样每对的绝对差之和就是大值组总和减去小值组总和，这是理论上的最大值。

- **题解思路**：所有优质题解的核心都是先排序数组，标记前N小为“小值组”（记为0），后N大为“大值组”（记为1），然后用栈/队列维护待匹配的括号类型，遇到不同类型时匹配，构造合法括号序列。
- **核心难点**：如何确保构造的括号序列合法（即左括号和右括号正确匹配），同时每对括号来自不同组。
- **可视化设计**：用8位像素风格模拟栈操作，小值组用蓝色方块，大值组用红色方块。栈中元素堆叠显示，匹配时弹出栈顶并播放“叮”音效，高亮当前处理的位置，帮助观察栈的变化。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等方面的评估，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者wangziyue_AK**
* **点评**：此题解思路非常清晰，直接抓住“大值组与小值组配对”的核心，代码规范且高效。作者用栈维护待匹配的括号类型，遇到不同类型时匹配，确保了括号序列的合法性。代码中变量名（如`stk`表示栈，`top`表示栈顶）含义明确，边界处理（如栈空时强制压入左括号）严谨。算法时间复杂度为O(n log n)（主要来自排序），完全适用于竞赛场景。亮点在于用栈构造的方法简洁高效，是贪心策略的经典实现。

**题解二：作者Exp10re**
* **点评**：此题解从理论上证明了最大值的上界，并通过栈构造验证了该上界可达。思路简洁明了，强调“每对括号颜色不同”（颜色代表大小组）的关键条件。代码虽未完整展示，但核心逻辑（栈维护颜色）与题解一一致，对理解贪心策略的应用有很好的启发作用。

**题解三：作者迟暮天复明**
* **点评**：此题解用队列代替栈构造，思路同样正确。通过维护两个队列（小值组和大值组），遇到不同组元素时匹配，确保合法。虽然队列实现稍复杂，但与栈方法本质相同，适合对比学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们会遇到以下核心难点，结合优质题解的共性，总结策略如下：
</difficulty_intro>

1.  **关键点1**：如何确定最大得分的理论上界？
    * **分析**：绝对值的和最大，等价于让大值尽可能被加、小值尽可能被减。将数组排序后，前N小的数作为“被减数”，后N大的数作为“减数”，总和即为后N大的和减去前N小的和，这是理论最大值（可用绝对值不等式证明）。
    * 💡 **学习笔记**：绝对值求和的最大值问题，常通过拆分符号（正、负）转化为分组求和问题。

2.  **关键点2**：如何构造合法的括号序列，使得每对括号来自不同组？
    * **分析**：合法括号序列要求左括号和右括号正确匹配（类似栈结构）。优质题解通过维护栈（或队列），遇到与栈顶同组的元素时压入栈（左括号），遇到不同组时弹出栈顶（右括号），确保每对括号来自不同组。
    * 💡 **学习笔记**：栈是处理括号匹配问题的“神器”，因为它天然符合“后进先出”的匹配规则。

3.  **关键点3**：如何高效实现构造过程？
    * **分析**：排序的时间复杂度为O(n log n)，栈操作是O(n)，总复杂度为O(n log n)，满足题目数据规模（n≤2e5）。无需复杂数据结构，栈的简单操作即可完成。
    * 💡 **学习笔记**：贪心策略的实现通常简洁高效，关键是找到正确的“贪心选择条件”。

### ✨ 解题技巧总结
- **问题抽象**：将绝对值求和问题转化为分组求和问题，通过排序确定分组。
- **数据结构选择**：栈适合处理括号匹配的“后进先出”特性，简化构造逻辑。
- **边界处理**：栈空时强制压入左括号，确保左括号数量足够，避免非法序列。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择作者wangziyue_AK的代码作为通用核心实现，因其逻辑清晰、代码规范，完整展示了贪心策略的应用。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了优质题解的思路，通过排序分组后用栈构造合法括号序列，是本题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 4e5 + 5;
    typedef long long ll;
    int n, a[N];
    struct xx {
        int x, id;
    } b[N];
    inline bool cmp(xx ax, xx ay) {
        return ax.x < ay.x;
    }
    int stk[N], top; // 手写栈

    int main() {
        scanf("%d", &n);
        int m = (n << 1);
        for (int i = 1; i <= m; ++i) scanf("%d", &a[i]);
        for (int i = 1; i <= m; ++i) {
            b[i].x = a[i];
            b[i].id = i;
        }
        sort(b + 1, b + m + 1, cmp);
        // 前n个为小值组（0），后n个为大值组（1）
        for (int i = 1; i <= n; ++i) a[b[i].id] = 0;
        for (int i = n + 1; i <= m; ++i) a[b[i].id] = 1;
        for (int i = 1; i <= m; ++i) {
            if (top == 0 || a[i] == stk[top]) { // 栈空或同组，压入左括号
                stk[++top] = a[i];
                printf("(");
            } else { // 不同组，弹出栈顶，输出右括号
                top--;
                printf(")");
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并排序，将前N小的数标记为0（小值组），后N大的数标记为1（大值组）。然后用栈维护当前待匹配的括号类型：栈空或当前元素与栈顶同组时压入左括号；否则弹出栈顶并输出右括号。最终构造出合法的括号序列。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，理解其亮点和逻辑：
</code_intro_selected>

**题解一：作者wangziyue_AK**
* **亮点**：用栈直接维护括号类型，代码简洁高效，边界处理严谨（如栈空时强制压入左括号）。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= m; ++i) {
        if (top == 0 || a[i] == stk[top]) { 
            stk[++top] = a[i];
            printf("(");
        } else { 
            top--;
            printf(")");
        }
    }
    ```
* **代码解读**：
    这段代码是构造括号序列的核心。遍历每个元素时：
    - 若栈空（无待匹配的左括号）或当前元素与栈顶同组（小值组或大值组），则压入栈并输出左括号（`(`），表示当前元素作为左括号待匹配。
    - 若当前元素与栈顶不同组，则弹出栈顶（匹配一个左括号），并输出右括号（`)`），表示当前元素作为右括号与栈顶的左括号匹配。
    这样确保每对括号来自不同组，且括号序列合法。
* 💡 **学习笔记**：栈的“后进先出”特性天然适合括号匹配，遇到不同组元素时匹配，保证了每对括号的绝对差最大。

**题解二：作者Exp10re（核心逻辑）**
* **亮点**：明确指出“每对括号颜色不同”是取到上界的充分条件，用栈构造验证了这一点。
* **核心代码片段（模拟）**：
    ```cpp
    // 假设a[i]为0（小值组）或1（大值组）
    stack<int> st;
    for (int i = 1; i <= 2*n; ++i) {
        if (st.empty() || st.top() == a[i]) {
            st.push(a[i]);
            cout << '(';
        } else {
            st.pop();
            cout << ')';
        }
    }
    ```
* **代码解读**：
    这段代码与题解一逻辑一致，用STL的`stack`实现。栈空或当前元素与栈顶同组时压入左括号，否则弹出栈顶并输出右括号。通过维护栈的状态，确保每对括号来自不同组。
* 💡 **学习笔记**：STL的`stack`简化了代码实现，但手写栈（如题解一）在竞赛中可能更高效。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解栈构造括号序列的过程，我们设计一个“像素括号探险家”动画，用8位复古风格展示栈的操作和括号匹配。
</visualization_intro>

  * **动画演示主题**：像素括号探险家——在栈的世界里匹配括号！

  * **核心演示内容**：展示数组排序后分组（小值组蓝方块、大值组红方块），栈的压入/弹出操作，以及括号序列的构造过程。

  * **设计思路简述**：8位像素风格营造轻松氛围，颜色区分大小组帮助记忆；栈的堆叠动画和音效（压入“噗”、弹出“叮”）强化操作感知；每完成一对匹配，播放“滴答”音效，增强成就感。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 屏幕分为左右两部分：左边是原始数组（8x8像素方块，蓝/红表示分组），右边是栈区域（垂直堆叠的像素方块）。
        - 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-10倍速）。
        - 播放8位风格背景音乐（类似《超级玛丽》的轻快旋律）。

    2.  **排序与分组**：
        - 数组元素从左到右按值排序，前N个变为蓝色（小值组），后N个变为红色（大值组），伴随“唰唰”音效。
        - 原始数组位置上的方块根据排序结果更新颜色（如原位置i的方块变为蓝或红）。

    3.  **栈构造过程**：
        - **压入左括号**：当前元素与栈顶同组或栈空时，像素方块从原始位置“滑”到栈顶（蓝色/红色方块堆叠），输出“(`”字符，播放“噗”音效。
        - **弹出右括号**：当前元素与栈顶不同组时，栈顶方块“消失”，当前方块变为右括号“`)”，播放“叮”音效，同时原始位置的括号字符更新。
        - **高亮操作**：当前处理的原始位置方块闪烁（白色边框），栈顶方块高亮（黄色边框），提示正在匹配。

    4.  **AI自动演示**：
        - 点击“AI演示”，算法自动执行，像“小探险家”一样快速完成所有匹配，学习者可观察完整流程。

    5.  **完成状态**：
        - 所有元素处理完毕，输出的括号序列显示在屏幕下方，播放“胜利”音效（上扬音调），栈清空，背景闪烁彩色像素点庆祝。

  * **旁白提示**：
    - （压入时）“当前元素和栈顶同组，压入左括号！”
    - （弹出时）“遇到不同组元素，弹出栈顶，输出右括号！”
    - （完成时）“看！我们构造了一个合法的括号序列，得分达到了最大值！”

<visualization_conclusion>
通过这个像素动画，我们可以清晰看到栈如何维护待匹配的括号类型，以及每一步操作如何确保括号合法且来自不同组，从而理解贪心策略的核心。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心策略在括号匹配问题中应用广泛，掌握本题后可尝试以下题目巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    贪心策略常用于构造最优序列（如括号、区间调度），关键是找到“每一步最优”的条件（如本题的“不同组匹配”）。类似地，贪心还可用于：
    - 区间覆盖问题（选结束最早的区间）；
    - 任务调度问题（优先处理截止时间早的任务）；
    - 哈夫曼编码（每次选权重最小的两个节点合并）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1944 [USACO11BTR] Brackets**
          * 🗣️ **推荐理由**：经典括号匹配问题，需判断括号是否合法，巩固栈的应用。
    2.  **洛谷 P2651 添加括号III**
          * 🗣️ **推荐理由**：通过添加括号最大化表达式值，贪心选择括号位置，锻炼贪心思维。
    3.  **洛谷 P5859 【模板】括号树**
          * 🗣️ **推荐理由**：树结构上的括号匹配问题，结合树遍历和栈操作，提升综合能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时的经验，例如：
</insights_intro>

> **参考经验 (来自作者wangziyue_AK)**：“在实现时，需要注意栈的初始状态（空）和边界条件（如所有元素同组的情况）。例如，当所有元素都是大值组时，栈会一直压入左括号，但由于题目保证n个左括号和n个右括号，这种情况不会出现，因为排序后必然有n个小值组和n个大值组。”

> **点评**：这段经验提醒我们，虽然理论上分组后两组数量相等，但代码中仍需处理栈空的情况（如强制压入左括号）。实际编码时，要确保边界条件的正确性，避免数组越界或栈操作错误。

-----

<conclusion>
本次关于“Bracket Score 2”的分析就到这里。通过贪心策略和栈的应用，我们可以高效构造出最优括号序列。希望大家通过练习巩固贪心思维，下次一起挑战更多算法问题！💪
</conclusion>

---
处理用时：105.01秒
# 题目信息

# 庭園

## 题目描述

dwango公司拥有一个很大的庭院，这个庭院被划分成南北 $H$ 行、东西 $W$ 列的 $1$ 平方米的区域。我们用 $(i, j)$ 表示从北数第 $i$ 行、第 $j$ 列的区域。每个区域中都盛开着花朵，其美观程度用整数 $B_{i,j}$ 来表示。

我们希望通过选取两个至少包含一个区域的矩形，并用栅栏围住这两个矩形，使得未被栅栏围住的地方成为道路，从而美化庭院。请注意，这两个矩形不能有重叠的区域，但是栅栏的重叠没有关系。

整个庭院的美观度被定义为被任何一个矩形围住的区域的总美观程度。

为了创造一个完美的庭院，我们需要计算出可达到的最大美观度。请编写一个程序来找到庭院的最大美观度。

### 输入格式

输入内容如下：

第一行包含两个整数 $H$ 和 $W$（$2 \leq H \leq 300$，$2 \leq W \leq 300$），分别表示庭院在南北方向和东西方向的长度。

接下来的 $H$ 行中，每行有 $W$ 个整数，表示从北数第 $i$ 行各个区域的花朵美观程度 $B_{i,1}, B_{i,2}, \ldots, B_{i,W}$。

### 输出格式

输出一个整数，表示选择两个矩形后的庭院最大美观度。输出应该在一行结束，并在行末加上换行符。

### 数据范围与提示

有部分分测试用例满足以下条件：

- 如果 $H \leq 50$ 和 $W \leq 50$，正确解答可得到 $50$ 分。
- 如果所有测试用例都正确解答，额外再得 $50$ 分。

### 样例解释

1. 通过两个矩形的巧妙选择，整个庭院的美观度可以达到最大值 $9$。

2. 即便在有的情况下，美观度可能为负数，但每个矩形必须至少包含一个区域。

3. 比如，可以像下图所示围住两个矩形：

![围住两个矩形的示意图](https://discovery2016-qual.contest.atcoder.jp/img/other/dwango2016qual/hdfksjghkjsdfhgkjsdhfgkjs/problem2.PNG)

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 3

1 1 1

1 1 1

1 1 1```

### 输出

```
9```

## 样例 #2

### 输入

```
3 3

-1 -1 -1

-1 -1 -1

-1 -1 -1```

### 输出

```
-2```

## 样例 #3

### 输入

```
2 3

5 -1 8

-1 4 -1```

### 输出

```
16```

## 样例 #4

### 输入

```
4 4

5 2 -3 2

3 8 -3 -10

4 5 3 2

-5 -3 3 5```

### 输出

```
40```

# AI分析结果



---
# 💡 Kay的C++算法解析：庭園 深入学习指南 💡

<introduction>
今天我们来一起分析“庭園”这道C++编程题。题目要求我们在H行W列的网格中选择两个不重叠的矩形，使得它们的总美观度最大。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举优化与二维前缀和应用`

🗣️ **初步分析**：
解决“庭園”这道题，关键在于高效枚举两个不重叠矩形的组合，并快速计算它们的美观度总和。直接枚举所有可能的矩形对复杂度极高（O(H⁴W⁴)），因此我们需要“枚举优化”——通过预处理和合理分割，将问题拆解为可高效计算的子问题。

简单来说，“枚举优化”就像分区域寻宝：先把整个庭院用“分割线”（水平线或垂直线）分成两部分，每部分各自找最大宝藏（矩形和），最后比较所有分割方式下的总宝藏。这里用到的“二维前缀和”就像“快速计算器”，能在O(1)时间内算出任意矩形的美观度和。

- **核心思路**：预处理二维前缀和数组 → 枚举水平/垂直分割线 → 在分割后的两部分中分别找最大矩形和 → 所有分割方式中的最大值即为答案。
- **核心难点**：如何高效枚举分割线？如何快速计算各区域的最大矩形和？如何处理矩形不重叠的约束？
- **可视化设计**：用8位像素网格展示庭院，不同颜色标记分割线（如红色横线/竖线）、当前计算的矩形（蓝色/绿色），动态显示前缀和数值变化。关键步骤（如分割线移动、最大矩形高亮）伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
由于当前提供的题解信息中暂无具体题解，Kay将基于题目要求和常见算法思路，为大家总结通用的解题策略和高效实现方法。
</eval_intro>

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合算法设计的通用思路，我为大家提炼了对应的解决策略：
</difficulty_intro>

1.  **关键点1**：如何高效枚举两个不重叠的矩形？
    * **分析**：直接枚举所有矩形对不可行。优化方法是用“分割线”将庭院分成两部分（如用某一行i将庭院分为上半部分[1,i]和下半部分[i+1,H]，或用某一列j分为左半[1,j]和右半[j+1,W]），每部分各选一个最大矩形。这样枚举分割线的复杂度为O(H+W)，大幅降低计算量。
    * 💡 **学习笔记**：用分割线将问题拆解为独立子问题，是处理“不重叠区域”类问题的常用技巧。

2.  **关键点2**：如何快速计算任意矩形的美观度和？
    * **分析**：预处理二维前缀和数组`sum[i][j]`，表示从(1,1)到(i,j)的矩形和。任意矩形(x1,y1)-(x2,y2)的和为`sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1]`。预处理时间为O(HW)，查询时间O(1)。
    * 💡 **学习笔记**：二维前缀和是处理矩形区域求和问题的“瑞士军刀”。

3.  **关键点3**：如何在分割后的区域中找到最大矩形和？
    * **分析**：对每个分割后的子区域（如水平分割后的上半部分），枚举所有可能的矩形上下左右边界，用前缀和计算其和，记录最大值。为进一步优化，可预处理每行的前缀和，将二维问题转化为一维“最大子数组和”问题（类似Kadane算法）。
    * 💡 **学习笔记**：将二维最大矩形和转化为一维问题，是降低复杂度的关键。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理先行**：先计算二维前缀和，为后续快速查询矩形和奠定基础。
- **分而治之**：用水平/垂直分割线将庭院分块，每块独立计算最大矩形和。
- **降维优化**：在子区域内，通过枚举行边界，将二维问题转化为一维最大子数组和问题，减少计算量。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是基于“枚举分割线+二维前缀和+一维最大子数组和”思路的通用核心C++实现。代码通过预处理前缀和，枚举水平/垂直分割线，并在各子区域中计算最大矩形和，最终取所有情况的最大值。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了枚举分割线、前缀和预处理、最大子数组和优化等核心思路，适用于H和W较大的场景（如300×300）。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <climits>
    using namespace std;

    int main() {
        int H, W;
        cin >> H >> W;
        vector<vector<int>> B(H + 1, vector<int>(W + 1));
        vector<vector<int>> sum(H + 1, vector<int>(W + 1, 0));

        // 输入并计算二维前缀和
        for (int i = 1; i <= H; ++i) {
            for (int j = 1; j <= W; ++j) {
                cin >> B[i][j];
                sum[i][j] = B[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];
            }
        }

        int max_total = INT_MIN;

        // 枚举水平分割线（上下分割）
        for (int split = 1; split < H; ++split) {
            // 上半部分最大矩形和
            int top_max = INT_MIN;
            for (int x1 = 1; x1 <= split; ++x1) {
                for (int x2 = x1; x2 <= split; ++x2) {
                    vector<int> row_sum(W + 1, 0);
                    for (int j = 1; j <= W; ++j) {
                        row_sum[j] = sum[x2][j] - sum[x1-1][j] - sum[x2][j-1] + sum[x1-1][j-1];
                        row_sum[j] += row_sum[j-1]; // 转化为一维前缀和
                    }
                    // 一维最大子数组和（Kadane算法）
                    int current = 0, max_sub = INT_MIN;
                    for (int j = 1; j <= W; ++j) {
                        current = max(row_sum[j] - row_sum[j-1], current + row_sum[j] - row_sum[j-1]);
                        max_sub = max(max_sub, current);
                    }
                    top_max = max(top_max, max_sub);
                }
            }

            // 下半部分最大矩形和（类似上半部分）
            int bottom_max = INT_MIN;
            for (int x1 = split + 1; x1 <= H; ++x1) {
                for (int x2 = x1; x2 <= H; ++x2) {
                    vector<int> row_sum(W + 1, 0);
                    for (int j = 1; j <= W; ++j) {
                        row_sum[j] = sum[x2][j] - sum[x1-1][j] - sum[x2][j-1] + sum[x1-1][j-1];
                        row_sum[j] += row_sum[j-1];
                    }
                    int current = 0, max_sub = INT_MIN;
                    for (int j = 1; j <= W; ++j) {
                        current = max(row_sum[j] - row_sum[j-1], current + row_sum[j] - row_sum[j-1]);
                        max_sub = max(max_sub, current);
                    }
                    bottom_max = max(bottom_max, max_sub);
                }
            }

            if (top_max != INT_MIN && bottom_max != INT_MIN) {
                max_total = max(max_total, top_max + bottom_max);
            }
        }

        // 枚举垂直分割线（左右分割，逻辑类似水平分割）
        for (int split = 1; split < W; ++split) {
            // 左半部分最大矩形和
            int left_max = INT_MIN;
            for (int y1 = 1; y1 <= split; ++y1) {
                for (int y2 = y1; y2 <= split; ++y2) {
                    vector<int> col_sum(H + 1, 0);
                    for (int i = 1; i <= H; ++i) {
                        col_sum[i] = sum[i][y2] - sum[i][y1-1] - sum[i-1][y2] + sum[i-1][y1-1];
                        col_sum[i] += col_sum[i-1];
                    }
                    int current = 0, max_sub = INT_MIN;
                    for (int i = 1; i <= H; ++i) {
                        current = max(col_sum[i] - col_sum[i-1], current + col_sum[i] - col_sum[i-1]);
                        max_sub = max(max_sub, current);
                    }
                    left_max = max(left_max, max_sub);
                }
            }

            // 右半部分最大矩形和
            int right_max = INT_MIN;
            for (int y1 = split + 1; y1 <= W; ++y1) {
                for (int y2 = y1; y2 <= W; ++y2) {
                    vector<int> col_sum(H + 1, 0);
                    for (int i = 1; i <= H; ++i) {
                        col_sum[i] = sum[i][y2] - sum[i][y1-1] - sum[i-1][y2] + sum[i-1][y1-1];
                        col_sum[i] += col_sum[i-1];
                    }
                    int current = 0, max_sub = INT_MIN;
                    for (int i = 1; i <= H; ++i) {
                        current = max(col_sum[i] - col_sum[i-1], current + col_sum[i] - col_sum[i-1]);
                        max_sub = max(max_sub, current);
                    }
                    right_max = max(right_max, max_sub);
                }
            }

            if (left_max != INT_MIN && right_max != INT_MIN) {
                max_total = max(max_total, left_max + right_max);
            }
        }

        cout << max_total << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先读取输入并计算二维前缀和数组`sum`。然后分别枚举水平分割线（上下分割）和垂直分割线（左右分割）。对于每个分割线，分别计算两部分的最大矩形和（通过枚举行/列边界，将二维问题转化为一维最大子数组和问题），最后取所有分割方式下的最大值作为答案。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“分割线枚举+最大矩形计算”的过程，我们设计了一个8位像素风格的动画演示。让我们一起进入“像素庭院”，看算法如何“寻宝”！
</visualization_intro>

  * **动画演示主题**：`像素园丁的最大美观度挑战`

  * **核心演示内容**：展示二维前缀和的计算、分割线的移动（水平/垂直）、各子区域最大矩形的动态查找，以及最终最大总和的确定。

  * **设计思路简述**：采用FC红白机风格的像素网格（16色调色板），用不同颜色区分分割线（红色）、当前计算的矩形（蓝色/绿色）、最大矩形（金色）。关键步骤的音效（如分割线移动的“唰”声、找到矩形的“叮”声）强化操作记忆；每完成一种分割方式的计算，视为“小关卡”，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：
          - 屏幕中央是H×W的像素网格（每个格子16×16像素），颜色由B[i][j]的正负决定（正为绿色，负为红色，绝对值越大颜色越深）。
          - 底部控制面板：单步/自动按钮、速度滑块（1-5倍速）、重置按钮。
          - 播放8位风格的轻快背景音乐（类似《超级马里奥》的冒险主题）。

    2.  **前缀和计算演示**：
          - 从左上角(1,1)开始，逐个格子计算前缀和`sum[i][j]`，用黄色数字浮现在格子上方。计算时伴随“滴答”音效，突出每个格子的累加过程。

    3.  **水平分割线枚举**：
          - 红色横线从第1行下方开始，逐行向下移动（每步间隔0.5秒）。移动时播放“唰唰”音效，同时屏幕上方显示当前分割线位置（如“水平分割线：i=1”）。

    4.  **上半区域最大矩形查找**：
          - 蓝色半透明覆盖上半区域（1到split行），枚举所有可能的上下边界（x1, x2）。每选一对(x1, x2)，该行区间用蓝色边框高亮。
          - 对于每个(x1, x2)，将二维问题转化为一维：每行的列和用绿色像素条堆叠成“柱状图”，动态显示Kadane算法如何找到最大子数组和（金色高亮选中的列区间）。

    5.  **下半区域最大矩形查找**：
          - 绿色半透明覆盖下半区域（split+1到H行），逻辑同上半区域。找到的最大矩形用金色边框高亮，数值显示在屏幕右侧。

    6.  **垂直分割线枚举与左右区域计算**：
          - 红色竖线从第1列右侧开始，逐列向右移动，逻辑类似水平分割线。左右区域用紫色/橙色半透明覆盖，最大矩形查找过程同步显示。

    7.  **最终结果展示**：
          - 所有分割方式计算完成后，屏幕中央用大字号显示最大总和（如“最大美观度：40”），伴随胜利音效（类似《超级马里奥》吃金币的长音），金色烟花像素动画在屏幕四周绽放。

  * **旁白提示**：
      - （前缀和计算时）“看！每个格子的数值是左、上、左上三个格子的和减去重复部分，这就是二维前缀和的魔法～”
      - （分割线移动时）“现在我们用这条红线把庭院分成上下两部分，每部分各自找最漂亮的矩形！”
      - （找到最大矩形时）“哇！这个蓝色矩形的美观度最高，记下来和另一部分的最大值相加吧～”

<visualization_conclusion>
通过这样的像素动画，我们能清晰看到算法如何通过分割线和前缀和快速定位最优解，就像像素园丁在庭院里一步步规划最美的栅栏位置！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（枚举分割线+前缀和+最大子数组和）适用于许多二维区域选择问题。掌握后，我们可以尝试解决以下类似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 最大两个不重叠子数组和（一维扩展）：如LeetCode 1383题，用类似分割线思路处理一维数组。
      - 最大子矩阵和（单矩形）：直接用二维前缀和+一维Kadane算法。
      - 多个不重叠矩形的最大和（扩展）：推广到k个矩形时，可用动态规划结合分割线思路。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1719** - `最大加权矩形`
          * 🗣️ **推荐理由**：本题是单矩形最大和问题，能帮助你巩固二维前缀和与Kadane算法的应用。
    2.  **洛谷 P1115** - `最大子段和`
          * 🗣️ **推荐理由**：一维最大子数组和问题，是本题二维解法的基础，适合先打牢基础。
    3.  **洛谷 P4147** - `玉蟾宫`
          * 🗣️ **推荐理由**：涉及二维区域选择的变形（最大全1矩形），能拓展你对矩形枚举的理解。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但Kay想提醒大家：遇到二维区域问题时，先想前缀和预处理；遇到多区域不重叠问题时，用分割线拆解是关键！动手写代码前，先画个图理清分割线和子区域的关系，能避免很多逻辑错误哦～
</insights_intro>

---

<conclusion>
本次关于“庭園”的C++解题分析就到这里。希望这份指南能帮助你掌握枚举优化、前缀和和最大子数组和的核心技巧。记住，编程的魅力在于将复杂问题拆解为可解决的小步骤——下次遇到类似问题，你也能轻松应对！💪
</conclusion>

---

---
处理用时：139.98秒
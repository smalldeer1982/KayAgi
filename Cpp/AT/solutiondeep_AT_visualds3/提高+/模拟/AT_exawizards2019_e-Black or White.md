# 题目信息

# Black or White

## 题目描述

[problemUrl]: https://atcoder.jp/contests/exawizards2019/tasks/exawizards2019_e

今日のすぬけ君のおやつは $ B $ 個の黒いチョコレートと $ W $ 個の白いチョコレートです。

すぬけ君は以下の手続きをチョコレートがなくなるまで繰り返します。

- 黒か白を等確率で選び、選んだ色のチョコレートが存在するなら $ 1 $ つ食べる。

$ 1 $ 以上 $ B+W $ 以下の各整数 $ i $ について、すぬけ君が $ i $ 番目に食べたチョコレートの色が黒である確率を求めてください。 これらの確率は有理数となることが示せます。これらを注記で述べるように modulo $ 10^{9}+7 $ で出力してください。

## 说明/提示

### 注記

有理数を出力する際は、まずその有理数を分数 $ \frac{y}{x} $ として表してください。ここで、$ x,\ y $ は整数であり、$ x $ は $ 10^9\ +\ 7 $ で割り切れてはなりません (この問題の制約下で、そのような表現は必ず可能です)。そして、$ xz\ \equiv\ y\ \pmod{10^9\ +\ 7} $ を満たすような $ 0 $ 以上 $ 10^9\ +\ 6 $ 以下の唯一の整数 $ z $ を出力してください。

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ B,W\ \leq\ 10^{5} $

### Sample Explanation 1

\- チョコレートを食べる順序としてありうるものは以下の $ 3 $ 通りで、そのような食べ方が生じる確率はそれぞれ $ \frac{1}{2},\ \frac{1}{4},\ \frac{1}{4} $ です。 - 白、黒、黒 - 黒、白、黒 - 黒、黒、白 - よって、$ 1 $ 番目、$ 2 $ 番目、$ 3 $ 番目に食べたチョコレートが黒である確率はそれぞれ $ \frac{1}{2},\frac{3}{4},\frac{3}{4} $ です。

### Sample Explanation 2

\- それぞれ $ \frac{1}{2},\frac{1}{2},\frac{5}{8},\frac{11}{16},\frac{11}{16} $ です。

## 样例 #1

### 输入

```
2 1```

### 输出

```
500000004

750000006

750000006```

## 样例 #2

### 输入

```
3 2```

### 输出

```
500000004

500000004

625000005

187500002

187500002```

## 样例 #3

### 输入

```
6 9```

### 输出

```
500000004

500000004

500000004

500000004

500000004

500000004

929687507

218750002

224609377

303710940

633300786

694091802

172485353

411682132

411682132```

# AI分析结果



---
# 💡 Kay的C++算法解析：Black or White 深入学习指南 💡

<introduction>
今天我们要一起攻克的题目是“Black or White”。这道题需要计算每次吃巧克力时吃到黑色的概率，涉及概率统计和组合数学的巧妙应用。通过分析题解和核心算法，我们会逐步理解如何用代码高效解决这类问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合概率计算）

🗣️ **初步分析**：
解决这道题的关键在于用组合数学和递推的方法，计算每个时刻吃到黑色巧克力的概率。简单来说，我们需要分析“剩余黑/白巧克力的状态”，并通过组合数统计所有可能的路径概率。  

在本题中，核心思路是：  
- 定义状态概率：`P_b(k)` 表示前k次吃完所有黑巧克力的概率，`P_w(k)` 表示前k次吃完所有白巧克力的概率。  
- 剩余状态概率 `P_a(k) = 1 - P_b(k) - P_w(k)` 表示前k次两种巧克力都未吃完的概率。  
- 第i次吃到黑色的概率为：若此时只剩白巧克力（概率`P_w(i-1)`），则必选黑；若两种都有（概率`P_a(i-1)`），则等概率选黑（即加`P_a(i-1)/2`）。  

核心算法流程是通过递推计算`P_b`和`P_w`，结合组合数和模逆元处理大数运算。可视化时，我们可以用像素方块动态展示剩余巧克力数量变化，高亮当前选择的颜色，并同步显示概率计算的关键步骤（如组合数计算、概率累加）。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等维度的评估，以下题解表现优秀：
</eval_intro>

**题解一：作者：rui_er**  
* **点评**：此题解逻辑清晰，状态定义明确（`P_b`/`P_w`分别表示吃完黑/白的概率），代码结构规范。通过预处理阶乘和逆元高效计算组合数，递推过程简洁。特别是使用`Modint`类封装模运算，减少了代码冗余，边界条件处理严谨（如组合数的合法性判断）。从实践角度看，代码可直接用于竞赛，时间复杂度为`O(B+W)`，完全满足题目约束，是非常值得学习的典范。

**题解二：作者：MadokaKaname**  
* **点评**：此题解思路正确，通过分状态（剩黑、剩白、都剩）计算概率，符合问题本质。但代码变量命名较模糊（如`p1`/`p2`需结合上下文理解），组合数计算未封装，可读性略逊。不过其递推逻辑与核心思路与优质题解一致，适合对比学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键在于理解状态概率的定义与递推。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何定义状态概率？**  
    * **分析**：`P_b(k)` 表示前k次吃完所有黑巧克力的概率。例如，当黑巧克力有B块时，最后一次吃黑的位置可以是第i次（i≥B），此时前i-1次中必须有B-1次吃黑。组合数`C(i-1, B-1)`表示前i-1次选B-1次黑的方式数，每一步的概率是`1/2^i`（每次选择独立）。  
    * 💡 **学习笔记**：状态定义需覆盖所有可能的结束条件（如“吃完黑”），并通过组合数统计路径数。

2.  **关键点2：如何高效计算组合数？**  
    * **分析**：题目中B和W可达1e5，需预处理阶乘和逆元。阶乘`fac[i] = i! mod MOD`，逆元`ifac[i] = (i!)^{-1} mod MOD`，组合数`C(n,m) = fac[n] * ifac[m] * ifac[n-m]`。预处理时间复杂度为`O(B+W)`，单次查询`O(1)`。  
    * 💡 **学习笔记**：预处理阶乘和逆元是处理大数组合数问题的“标配”技巧。

3.  **关键点3：如何处理概率的递推与合并？**  
    * **分析**：`P_b(k)`和`P_w(k)`通过累加每个i≤k的概率得到。最终第i次的概率是`P_w(i-1) + P_a(i-1)/2`，其中`P_a`是两种都未吃完的概率（即未被`P_b`或`P_w`覆盖的部分）。  
    * 💡 **学习笔记**：总概率为1，利用补集思想（`P_a = 1 - P_b - P_w`）可简化计算。

### ✨ 解题技巧总结
- **状态分解**：将复杂问题分解为“吃完黑”“吃完白”“都未吃完”三种状态，分别计算概率再合并。  
- **预处理优化**：预处理阶乘和逆元，避免重复计算组合数，提升效率。  
- **模运算封装**：用类或函数封装模加、乘、逆元等操作，减少代码错误，提高可读性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，代码简洁高效，适合直接学习。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了rui_er题解的思路，预处理阶乘和逆元，递推计算`P_b`和`P_w`，最终输出每个时刻的概率。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MOD = 1e9 + 7;
    using mint = long long;

    mint mod_pow(mint a, mint b) {
        mint res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    mint inv(mint x) { return mod_pow(x, MOD - 2); }

    int main() {
        int B, W; cin >> B >> W;
        int n = B + W;
        vector<mint> fac(n + 1), ifac(n + 1);
        fac[0] = 1;
        for (int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % MOD;
        ifac[n] = inv(fac[n]);
        for (int i = n - 1; i >= 0; --i) ifac[i] = ifac[i + 1] * (i + 1) % MOD;

        auto comb = [&](int n, int k) {
            if (n < 0 || k < 0 || n < k) return 0LL;
            return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;
        };

        mint Pb = 0, Pw = 0, inv2 = inv(2), pow2 = 1;
        for (int i = 1; i <= n; ++i) {
            pow2 = pow2 * inv2 % MOD; // 1/2^i
            Pb = (Pb + comb(i - 1, B - 1) * pow2) % MOD;
            Pw = (Pw + comb(i - 1, W - 1) * pow2) % MOD;
            mint Pa = (1 - Pb - Pw + 2 * MOD) % MOD;
            mint ans = (Pw + Pa * inv2) % MOD;
            cout << ans << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理阶乘`fac`和逆元`ifac`，用于快速计算组合数。然后递推计算`Pb`（吃完黑的概率）和`Pw`（吃完白的概率），每一步更新当前概率`pow2 = 1/2^i`。最后通过`Pa = 1 - Pb - Pw`得到两种都未吃完的概率，计算第i次吃黑的概率并输出。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者：rui_er**  
* **亮点**：使用`Modint`类封装模运算，代码更简洁；预处理阶乘和逆元的方式高效；递推逻辑清晰，变量命名规范（如`Pb`/`Pw`直接对应状态）。  
* **核心代码片段**：
    ```cpp
    mint Pb = 0, Pw = 0, now = 1;
    rep(i, 0, b + w - 1) {
        Pb += C(i - 1, b - 1) * now;
        Pw += C(i - 1, w - 1) * now;
        mint Pa = 1 - Pb - Pw;
        cout << Pw + Pa * inv2 << endl;
        now *= inv2;
    }
    ```
* **代码解读**：  
  `now`表示当前的概率因子`1/2^i`（i从1开始）。每次循环中，`Pb`累加“前i次吃完黑”的概率（组合数`C(i-1, b-1)`乘以`now`），`Pw`同理。`Pa`是两种都未吃完的概率，最终答案为`Pw + Pa/2`（因为两种都有时选黑的概率是1/2）。  
* 💡 **学习笔记**：用递推累加的方式逐步计算概率，避免了重复计算大数，时间复杂度线性。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解概率计算过程，我们设计一个“巧克力像素工厂”的8位复古动画，用动态方块展示剩余巧克力和概率变化！
</visualization_intro>

  * **动画演示主题**：`像素巧克力工厂的吃豆挑战`  
  * **核心演示内容**：展示每次选择颜色的过程，剩余黑/白巧克力数量变化，以及对应时刻的概率计算。  
  * **设计思路简述**：8位像素风格（红/白方块表示黑/白巧克力），通过颜色高亮当前选择，音效提示选择动作，同步显示组合数和概率公式，帮助理解“路径数×概率”的核心逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示两个像素槽：黑色槽（B个黑方块）、白色槽（W个白方块）。  
        - 右侧显示“已吃次数”计数器（初始0）和概率计算区（显示当前i对应的公式，如`C(i-1, B-1) * 1/2^i`）。  
        - 控制面板：单步/自动播放按钮、速度滑块（1-5倍速）。

    2.  **选择动画（单步执行）**：  
        - 每次点击“单步”，屏幕中央弹出“选择黑/白？”的像素对话框，0.5秒后随机（模拟等概率）选中一种颜色。  
        - 选中颜色对应的槽位顶部方块消失（被吃掉），剩余数量减1，伴随“叮”的音效。  
        - 已吃次数计数器加1，概率计算区更新当前i的组合数和概率项（如`C(2,1) * 1/8`）。

    3.  **概率累加演示**：  
        - `Pb`和`Pw`用进度条表示（初始0%），每次累加新的概率项时，进度条增长并显示数值（如“Pb += 0.25 → Pb=0.5”）。  
        - `Pa`用灰色进度条表示，数值为`1 - Pb - Pw`。

    4.  **结果输出**：  
        - 当已吃次数达到i时，屏幕下方显示第i次吃黑的概率（如“第3次概率：75%”），伴随“唰”的音效。  
        - 自动播放模式下，动画连续执行，学习者可观察概率随i变化的趋势（如样例1中i=1时50%，i=2时75%）。

  * **旁白提示**：  
    - “看！当已经吃了i次，若白巧克力已经吃完（Pw），第i+1次必选黑；若都没吃完（Pa），则有50%概率选黑～”  
    - “组合数C(i-1, B-1)表示前i-1次中有B-1次吃黑的方式数，乘以1/2^i就是这种情况的概率哦！”

<visualization_conclusion>
通过这个动画，我们能直观看到每次选择如何影响剩余巧克力数量，以及概率是如何通过组合数和递推累加得到的。像素风格的交互让学习更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是组合概率计算，这类思路可迁移到多种场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 抛硬币问题：计算前n次中某面朝上的概率。  
    - 路径计数问题：在网格中从起点到终点的路径数，结合概率权重。  
    - 竞赛晋级问题：多轮比赛中某选手晋级的概率。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1297 [国家集训队]单选错位**  
        * 🗣️ **推荐理由**：考察概率计算与递推，需分析每道题的选择概率，与本题思路类似。  
    2.  **洛谷 P4318 完全平方数**  
        * 🗣️ **推荐理由**：涉及容斥原理和组合数学，锻炼数学建模能力。  
    3.  **洛谷 P3187 [HAOI2015] 最小矩形覆盖**  
        * 🗣️ **推荐理由**：虽为几何题，但需要枚举关键点并统计概率，培养综合解题能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分，但可以总结：  
</insights_intro>

> 在处理概率问题时，关键是明确状态定义，并利用组合数学统计所有可能路径的概率。预处理阶乘和逆元是高效计算组合数的关键，而模运算的封装能减少代码错误。多动手模拟小例子（如样例1）有助于验证思路正确性。

---

<conclusion>
通过本次分析，我们掌握了“Black or White”的解题思路，理解了组合概率和递推的应用。编程学习的关键在于多思考、多实践，下次我们再挑战更难的题目！💪
</conclusion>

---
处理用时：136.68秒
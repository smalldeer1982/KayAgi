# 题目信息

# 城壁 (Rampart)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2015ho/tasks/joi2015ho_e

歴史学者である JOI 教授は，かつて存在した IOI 王国について研究している．

過去の調査によると，IOI 王国は縦 $ H $ 行，横 $ W $ 列のマスに区切られた長方形の形をしていた．IOI 王国の首都は，防衛のために城壁で囲われていた．

IOI 王国の首都を囲う城壁は次のような形をしている．城壁には大きさと呼ばれる値が定まっている．大きさ $ s $ ($ s\ \geqq\ 3 $) の城壁とは，$ s\ \times\ s $ の正方形の領域から外周以外の $ (s\ -\ 2)\ \times\ (s\ -\ 2) $ の正方形の領域を除いたものである．

調査によると，首都を囲う城壁の大きさは $ L $ 以上であった．また，IOI 王国のいくつかのマスには城壁が存在しなかったことがわかっている．

JOI 教授は，さらなる研究のために，城壁としてありうるものが何通りあるかを知りたい．

## 说明/提示

### 課題

IOI 王国の大きさと，城壁の大きさの最小値，城壁が存在しなかったことが分かっているマスの情報が与えられたとき，城壁としてありうるものは何通りあるかを求めるプログラムを作成せよ．

- - - - - -

### 制限

すべての入力データは以下の条件を満たす．

- $ 1\ \leqq\ H\ \leqq\ 4\,000 $．
- $ 1\ \leqq\ W\ \leqq\ 4\,000 $．
- $ 3\ \leqq\ L\ \leqq\ H $ かつ $ 3\ \leqq\ L\ \leqq\ W $．
- $ 0\ \leqq\ P\ \leqq\ 100\,000 $．
- $ 1\ \leqq\ A_i\ \leqq\ H $ ($ 1\ \leqq\ i\ \leqq\ P $)．
- $ 1\ \leqq\ B_i\ \leqq\ W $ ($ 1\ \leqq\ i\ \leqq\ P $)．
- ($ A_i,\ B_i)\ \neq\ (A_j,\ B_j $) ($ 1\ \leqq\ i\ <\ j\ \leqq\ P $)．

### 小課題

#### 小課題 1 \[4 点\]

以下の条件を満たす．

- $ H\ \leqq\ 500 $．
- $ W\ \leqq\ 500 $．

#### 小課題 2 \[16 点\]

- $ 0\ \leqq\ P\ \leqq\ 10 $ を満たす．

#### 小課題 3 \[80 点\]

追加の制限はない．

- - - - - -

### Sample Explanation 1

この入力例の場合，城壁としてありうるものは以下の $ 4 $ 通りが考えられる．ただし，`×` で示したマスは城壁が存在しなかったことがわかっているマスである． !\[e-1.png\](https://img.atcoder.jp/joi2015ho/e-1.png) - - - - - -

### Sample Explanation 2

\- - - - - -

## 样例 #1

### 输入

```
5 5 3 2
2 2
4 3```

### 输出

```
4```

## 样例 #2

### 输入

```
7 8 4 3
2 2
3 7
6 5```

### 输出

```
13```

## 样例 #3

### 输入

```
4000 4000 1234 4
1161 3028
596 1892
3731 2606
702 1530```

### 输出

```
7050792912```

# AI分析结果



---
# 💡 Kay的C++算法解析：城壁 (Rampart) 深入学习指南 💡

<introduction>
今天我们来一起分析“城壁 (Rampart)”这道C++编程题。这道题需要计算满足条件的正方形城墙数量，涉及预处理、数据结构应用等关键技巧。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`预处理+二维数点（数据结构应用）`

🗣️ **初步分析**：
解决“城壁”问题的关键在于高效判断每个可能的正方形是否符合条件。简单来说，我们需要先预处理每个点向四个方向（左、右、上、下）的最大延伸长度（不经过被标记点），然后通过枚举正方形的对角线，结合数据结构快速统计符合条件的正方形数量。

- **题解思路**：两个题解均采用“预处理延伸长度+对角线枚举+数据结构统计”的思路。Rusalka使用主席树处理二维数点，极寒神冰则用树状数组优化，核心差异在于统计阶段的实现。
- **核心难点**：如何高效预处理延伸长度，以及如何通过数据结构快速统计满足条件的正方形数量。
- **可视化设计**：动画将重点展示预处理阶段（每个点的延伸长度如何计算）和对角线枚举时的统计过程。例如，用不同颜色表示每个点的左/右/上/下延伸长度，枚举对角线时用像素箭头标记当前处理的点，统计时用闪烁高亮合法正方形的边界。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选出以下优质题解：
</eval_intro>

**题解一：Rusalka的主席树解法**
* **点评**：此解法思路清晰，预处理部分（计算四个方向的延伸长度）逻辑直白，变量命名如`ld`（左延伸）、`rd`（右延伸）等含义明确。核心亮点在于使用主席树处理二维数点问题，有效降低了时间复杂度。代码结构完整，边界处理严谨（如`a[x][y] = 1`标记已处理点避免重复计算），适合作为竞赛参考。

**题解二：极寒神冰的树状数组解法**
* **点评**：该解法同样预处理延伸长度，但统计阶段改用树状数组，代码更简洁。变量名如`L`（左延伸）、`R`（右延伸）直观，循环结构工整。通过按对角线枚举（`x+y`固定）优化了枚举效率，树状数组的应用使得统计步骤更高效，适合学习数据结构的灵活运用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，我们通常会遇到以下关键点，结合题解共性提炼策略：
</difficulty_intro>

1.  **关键点1：预处理四个方向的延伸长度**
    * **分析**：需要计算每个点向左、右、上、下最多能延伸的长度（不经过被标记点）。例如，左延伸`ld[i][j]`表示点`(i,j)`向左连续未被标记的格子数。预处理时，可通过递推实现：若当前点未被标记，`ld[i][j] = ld[i][j-1] + 1`（否则为0）。
    * 💡 **学习笔记**：预处理是解决复杂问题的“地基”，清晰的递推关系能大幅简化后续计算。

2.  **关键点2：按对角线枚举正方形**
    * **分析**：正方形的左下角`(i,j)`和右上角`(x,y)`满足`i+j = x+y`（对角线）。枚举每条对角线可避免重复计算，且能将二维问题转化为一维统计问题。例如，沿对角线`k = i+j`，只需处理该对角线上的所有点。
    * 💡 **学习笔记**：利用问题的几何特性（如对称性、对角线关系）可大幅减少枚举量。

3.  **关键点3：二维数点的高效统计**
    * **分析**：需统计满足`d≥L`且延伸长度足够的正方形数量。题解分别用主席树和树状数组处理此问题，核心是将统计条件转化为区间查询（如树状数组的`query`操作）。
    * 💡 **学习笔记**：选择合适的数据结构（如树状数组适合区间求和，主席树适合历史版本查询）能显著提升效率。

### ✨ 解题技巧总结
- **预处理优先**：先通过递推预处理关键信息（如延伸长度），后续步骤会更高效。
- **几何特性利用**：利用正方形的对角线特性，将二维问题转化为一维，简化枚举逻辑。
- **数据结构适配**：根据统计需求选择数据结构（如树状数组适合动态区间查询，主席树适合多版本统计）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合两个题解思路的通用核心实现，结合预处理和树状数组统计，代码更简洁易读。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了题解的预处理思路和树状数组统计方法，适用于大规模数据，时间复杂度为$\mathcal{O}(nm \log \min(n,m))$。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MAX = 4010;

    int H, W, L, P;
    bool forbidden[MAX][MAX];
    int L_len[MAX][MAX], R_len[MAX][MAX], U_len[MAX][MAX], D_len[MAX][MAX];
    vector<int> events[MAX];
    int fenwick[MAX];

    inline void add(int x, int val) {
        for (; x <= W; x += x & -x) fenwick[x] += val;
    }
    inline int query(int x) {
        int res = 0;
        for (; x > 0; x -= x & -x) res += fenwick[x];
        return res;
    }

    int main() {
        scanf("%d%d%d%d", &H, &W, &L, &P);
        for (int i = 0; i < P; ++i) {
            int x, y; scanf("%d%d", &x, &y);
            forbidden[x][y] = true;
        }

        // 预处理左、上延伸长度
        for (int i = 1; i <= H; ++i)
            for (int j = 1; j <= W; ++j)
                if (!forbidden[i][j]) {
                    L_len[i][j] = L_len[i][j-1] + 1;
                    U_len[i][j] = U_len[i-1][j] + 1;
                }

        // 预处理右、下延伸长度
        for (int i = H; i >= 1; --i)
            for (int j = W; j >= 1; --j)
                if (!forbidden[i][j]) {
                    R_len[i][j] = R_len[i][j+1] + 1;
                    D_len[i][j] = D_len[i+1][j] + 1;
                }

        ll ans = 0;
        // 枚举对角线k = x + y
        for (int k = 2; k <= H + W; ++k) {
            int x = max(1, k - W), y = k - x;
            // 清空树状数组和事件队列
            for (int i = 1; i <= W; ++i) {
                for (int t : events[i]) add(t, -1);
                events[i].clear();
            }
            memset(fenwick, 0, sizeof(fenwick));

            // 处理当前对角线上的点
            for (; x <= H && y >= 1; ++x, --y) {
                int min_ru = min(R_len[x][y], U_len[x][y]); // 右上角延伸条件
                if (min_ru >= L) {
                    int left = y + L - 1;
                    int right = y + min_ru - 1;
                    ans += query(right) - (left > 1 ? query(left - 1) : 0);
                }
                int min_ld = min(L_len[x][y], D_len[x][y]); // 左下角延伸条件
                int pos = y - min_ld + 1;
                if (pos <= y) {
                    events[y].push_back(pos);
                    add(pos, 1);
                }
            }
        }
        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预处理四个方向的延伸长度，然后按对角线枚举每个可能的正方形。对于每条对角线，使用树状数组动态维护左下角延伸条件，快速统计满足右上角延伸条件的正方形数量。核心逻辑包括预处理循环和树状数组的区间查询。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段：
</code_intro_selected>

**题解二（极寒神冰）核心代码片段**：
* **亮点**：树状数组的高效区间查询，代码简洁，循环结构清晰。
* **核心代码片段**：
    ```cpp
    inline void add(int x,int k) {
        for(;x<=m;x+=(x&(-x))) val[x]+=k;
    }
    inline int query(int x) {
        int ret=0;
        for(;x;x-=(x&(-x))) ret+=val[x];
        return ret;
    }
    // ... 主函数中统计部分
    ans += query(y+R[x][y]-1)-query(y+l-2);
    ```
* **代码解读**：
    `add`和`query`是树状数组的基本操作，用于动态维护区间和。主函数中，对于当前点`(x,y)`，若其右/上延伸长度`R[x][y]`足够（≥L），则通过`query`计算在左下角延伸范围内符合条件的正方形数量。例如，`y+R[x][y]-1`是右上角能延伸的最大列号，`y+L-2`是最小列号，两者的差即为合法数量。
* 💡 **学习笔记**：树状数组适合动态维护前缀和，能在$\mathcal{O}(\log n)$时间内完成单点更新和区间查询，是解决二维数点问题的利器。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解预处理和统计过程，我们设计一个“像素探险家”主题的8位像素动画，模拟城墙正方形的筛选过程。
</visualization_intro>

  * **动画演示主题**：`像素探险家寻找合法城墙`

  * **核心演示内容**：展示预处理阶段（每个点的延伸长度计算）和统计阶段（沿对角线枚举并统计合法正方形）。

  * **设计思路简述**：采用FC红白机风格，用不同颜色表示延伸长度（如蓝色表示左延伸，绿色表示上延伸），统计时用黄色闪烁标记合法正方形的边界。音效在延伸长度更新时播放“叮”声，统计到合法正方形时播放“胜利”音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕显示$H \times W$的像素网格，被标记点用红色方块表示，其他点为白色。
        - 控制面板包含“单步”“自动播放”按钮和速度滑块。

    2.  **预处理阶段**：
        - 左延伸计算：从左到右逐列处理，每个点的左延伸长度用蓝色数字显示，若当前点未被标记，蓝色数字递增（如`ld[i][j-1]=2`则`ld[i][j]=3`），伴随“滴”音效。
        - 上/右/下延伸同理，分别用绿、橙、紫色数字显示。

    3.  **对角线枚举与统计**：
        - 沿对角线`k=x+y`移动像素箭头（如粉色箭头），逐个处理对角线上的点。
        - 处理左下角点时，用黄色标记其左/下延伸长度，树状数组用堆叠的像素方块表示（每个方块代表一个列号）。
        - 处理右上角点时，检查右/上延伸长度是否≥L，若满足，对应的树状数组方块闪烁，统计结果增加，播放“叮”音效。

    4.  **目标达成**：
        - 所有对角线处理完成后，最终答案用金色数字显示在屏幕中央，播放“胜利”音效，背景出现像素烟花。

  * **旁白提示**：
    - “看！蓝色数字是左延伸长度，未被标记的点会继承左边点的长度+1哦～”
    - “粉色箭头沿着对角线移动，这样能不重复地枚举所有可能的正方形呢！”
    - “树状数组的方块在闪烁？这说明找到了一个合法的城墙正方形，快数一数总数增加了多少！”

<visualization_conclusion>
通过这个像素动画，我们能清晰看到预处理如何为后续统计提供数据支持，以及树状数组如何高效统计合法正方形。动画中的颜色和音效强化了关键步骤的记忆，让算法学习更有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的预处理+数据结构思路适用于多种二维统计问题，以下是拓展练习推荐：
</similar_problems_intro>

  * **通用思路迁移**：
    - 二维区域统计（如矩形覆盖、合法子矩阵计数）。
    - 网格中的路径问题（如无障碍路径数统计）。
    - 动态更新与查询（如动态插入点后统计区域内点数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1972 [SDOI2009]HH的项链**
        * 🗣️ **推荐理由**：练习树状数组的区间查询，适合巩固二维数点技巧。
    2.  **洛谷 P3810 陌上花开**
        * 🗣️ **推荐理由**：三维数点问题，学习如何将多维问题转化为一维统计。
    3.  **洛谷 P2068 统计和**
        * 🗣️ **推荐理由**：动态更新与查询，强化树状数组的灵活应用。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

---

<conclusion>
本次“城壁”问题的分析就到这里。通过预处理延伸长度、利用几何特性枚举和数据结构高效统计，我们解决了大规模网格中的合法正方形计数问题。希望大家通过练习巩固这些技巧，下次挑战更复杂的算法问题！💪
</conclusion>

---
处理用时：110.89秒
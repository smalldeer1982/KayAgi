# 题目信息

# オリンピックバス (Olympic Bus)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_d

JOI 国には $ N $ 個の都市があり，$ 1 $ から $ N $ までの番号が付いている．また，都市と都市を一方向に結ぶ $ M $ 本のバス路線があり，$ 1 $ から $ M $ までの番号が付いている．バス路線 $ i $ ($ 1\ \leqq\ i\ \leqq\ M $) は都市 $ U_i $ から都市 $ V_i $ へ向けて運行されており，運賃は $ C_i $ 円である．バス路線 $ i $ ($ 1\ \leqq\ i\ \leqq\ M $) では，都市 $ U_i $ 以外で乗ったり，都市 $ V_i $ 以外で降りることはできない．ある都市からある都市へ向けて運行されるバス路線が複数存在するかもしれない．

JOI 国では間もなくオリンピックが開催される．JOI 国の運輸大臣である $ K $ 理事長は，バス路線を高々 $ 1 $ つ選び，オリンピック期間中，運賃を変更せずにそのバス路線の運行方向を反転させることにした．つまり，バス路線 $ i $ ($ 1\ \leqq\ i\ \leqq\ M $) を選んだ場合，オリンピック期間中，そのバス路線は都市 $ U_i $ から都市 $ V_i $ へ向けて運行されるのではなく，都市 $ V_i $ から都市 $ U_i $ へ向けて運行されるようになる．ただし，バス路線 $ i $ の運行方向の反転には $ D_i $ 円かかり，これは K 理事長のポケットマネーにより賄われる．また，混乱を避けるため，オリンピック期間の途中でバス路線を反転させることはできない．

運輸大臣である K 理事長は，オリンピック期間中，都市 $ 1 $ と都市 $ N $ の間をバス路線を乗り継いで往復する予定である．運行方向を反転させるバス路線をうまく選ぶことで，往復の合計運賃と運行方向の反転の費用との和を最小化したい．

都市の個数と，バス路線の情報が与えられたとき，運行方向を反転させるバス路線をうまく選ぶことで，都市 $ 1 $ と都市 $ N $ の間の往復の合計運賃と，運行方向の反転の費用との和の最小値を求めるプログラムを作成せよ．ただし，どのようにバス路線を選んでも都市 $ 1 $ と都市 $ N $ の間を往復することができない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 2\ \leqq\ N\ \leqq\ 200 $．
- $ 1\ \leqq\ M\ \leqq\ 50\,000 $．
- $ 1\ \leqq\ U_i\ \leqq\ N $ ($ 1\ \leqq\ i\ \leqq\ M $)．
- $ 1\ \leqq\ V_i\ \leqq\ N $ ($ 1\ \leqq\ i\ \leqq\ M $)．
- $ U_i\ \neq\ V_i $ ($ 1\ \leqq\ i\ \leqq\ M $)．
- $ 0\ \leqq\ C_i\ \leqq\ 1\,000\,000 $ ($ 1\ \leqq\ i\ \leqq\ M $)．
- $ 0\ \leqq\ D_i\ \leqq\ 1\,000\,000\,000 $ ($ 1\ \leqq\ i\ \leqq\ M $)．

### 小課題

1. ($ 5 $ 点) $ M\ \leqq\ 1\,000 $．
2. ($ 11 $ 点) $ M $ は偶数，$ U_{2i\ −\ 1}\ =\ U_{2i} $，$ V_{2i\ −\ 1}\ =\ V_{2i} $，$ C_{2i\ −\ 1}\ =\ C_{2i} $ ($ 1\ \leqq\ i\ \leqq\ \frac{M}{2} $)．
3. ($ 21 $ 点) $ C_i\ =\ 0 $ ($ 1\ \leqq\ i\ \leqq\ M $)．
4. ($ 63 $ 点) 追加の制約はない．

- - - - - -

### Sample Explanation 1

バス路線 $ 2 $ の運行方向を費用 $ 1 $ で反転させると，都市 $ 1 $ から都市 $ 4 $ への移動にかかる運賃は最小で $ 6 $，都市 $ 4 $ から都市 $ 1 $ への移動にかかる運賃は最小で $ 3 $ となり，都市 $ 1 $ と都市 $ 4 $ の間の往復の合計運賃と，運行方向の反転の費用との和は $ 10 $ となる． 都市 $ 1 $ と都市 $ 4 $ の間の往復の合計運賃と，運行方向の反転の費用との和を $ 10 $ より小さくすることはできないので，$ 10 $ を出力する． - - - - - -

### Sample Explanation 2

この入出力例は小課題 $ 2 $ の制約を満たす． - - - - - -

### Sample Explanation 3

この入出力例は小課題 $ 3 $ の制約を満たす． - - - - - -

### Sample Explanation 4

バス路線の運行方向を反転させなくてもよい． - - - - - -

### Sample Explanation 5

この入力例では，都市 $ 4 $ から都市 $ 3 $ へと運行されるバス路線が $ 2 $ 本存在する．

## 样例 #1

### 输入

```
4 5
1 2 4 4
1 3 2 1
4 3 1 2
4 1 6 1
2 4 2 5```

### 输出

```
10```

## 样例 #2

### 输入

```
4 10
1 2 4 4
1 2 4 4
1 3 2 1
1 3 2 1
4 3 1 2
4 3 1 2
4 1 6 1
4 1 6 1
2 4 2 5
2 4 2 5```

### 输出

```
10```

## 样例 #3

### 输入

```
4 4
1 2 0 4
1 3 0 1
4 3 0 2
4 1 0 1```

### 输出

```
2```

## 样例 #4

### 输入

```
4 5
1 2 4 4
1 3 2 4
4 3 1 5
4 1 6 1
2 4 2 5```

### 输出

```
12```

## 样例 #5

### 输入

```
4 5
2 1 4 4
1 3 2 1
4 3 1 2
4 3 6 1
2 4 2 5```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：オリンピックバス (Olympic Bus) 深入学习指南 💡

<introduction>
今天我们来一起分析“オリンピックバス (Olympic Bus)”这道C++编程题。这道题涉及图论中的最短路径问题，需要我们通过反转一条边来最小化往返总费用。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论中的最短路径算法（Dijkstra）应用及优化枚举

🗣️ **初步分析**：
解决这道题的关键在于理解如何高效枚举可能反转的边，并计算反转后的最短路径。简单来说，图论中的最短路径算法（如Dijkstra）是“在图中找到两点间最短路径的工具”，就像在迷宫里用地图找最快路线一样。在本题中，我们需要先计算原图的最短路径，再枚举反转每一条边，判断反转后是否能得到更优的往返总费用（原路径费用+反转费用）。

- **题解思路**：直接枚举所有边反转会超时（复杂度O(m×n²)）。优质题解通过观察发现，只有最短路上的边反转才可能影响结果，因此仅需枚举这些边（最多4n条），其余边可通过公式快速计算，将复杂度降至O(n³)。
- **核心难点**：如何快速判断哪些边需要暴力重算最短路径，哪些边可通过原最短路径快速推导。
- **可视化设计**：用8位像素风展示原图和反转后的图，用不同颜色标记当前处理的边、路径节点（如起点1为红色，终点N为蓝色，最短路径节点为绿色）。关键步骤（如边反转、路径更新）用闪烁或音效提示（“叮”声表示边反转，“滴”声表示路径更新）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者modfisher**
* **点评**：此题解思路非常清晰，通过构建4棵最短路径树（原图/反图、起点1/起点N），精准定位可能影响最短路径的边（最多4n条），大幅减少枚举量。代码中使用邻接表存储图，Dijkstra算法实现规范（变量名如`dis[id][p][i]`含义明确），对反转边的处理逻辑（如更新邻接矩阵`g2`）严谨。其“仅处理关键边”的优化思想是亮点，显著降低了时间复杂度，适合竞赛参考。

**题解二：作者Mirage_Insane**
* **点评**：此题解通过标记原最短路径上的边（`book`数组），仅对这些边暴力重算Dijkstra，其他边通过原最短路径推导。代码结构简洁（`change`函数处理边反转，`Dijkstra`函数求最短路径），变量命名直观（如`pre`记录前驱节点）。其“仅处理最短路边”的优化策略是关键，避免了不必要的计算，实践价值高。

**题解三：作者wwwwwza**
* **点评**：此题解思路直接，通过排序邻接表优化Dijkstra效率，并用`line`数组标记最短路上的边。代码中`dij`函数参数设计巧妙（`flag`区分不同起点），对反转边的处理（`swp`变量标记当前反转边）逻辑清晰。其“分情况处理关键边和非关键边”的策略是亮点，适合理解基础优化思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何减少枚举边的数量？**
    * **分析**：直接枚举所有M条边（可能5万条）会导致超时。优质题解发现：仅当反转边在原图或反图的最短路径上时，才会影响最终结果。这些边最多只有4n条（每个最短路径树最多n条边），因此只需枚举这些边。
    * 💡 **学习笔记**：最短路径树上的边是影响结果的“关键边”，优先处理它们能大幅减少计算量。

2.  **关键点2：如何快速计算非关键边反转后的费用？**
    * **分析**：对于非关键边(u,v)，反转后可能的新路径是“1→v→u→N”和“N→v→u→1”。原最短路径费用为`dis[1][N]`和`dis[N][1]`，新费用为`dis[1][v]+w+dis[u][N]`和`dis[N][v]+w+dis[u][1]`，取较小值即可。
    * 💡 **学习笔记**：非关键边反转后的费用可通过原最短路径快速推导，无需重算Dijkstra。

3.  **关键点3：如何高效实现Dijkstra算法？**
    * **分析**：因节点数N≤200（稠密图），使用O(n²)的Dijkstra更高效（无需堆优化）。优质题解中通过邻接表或邻接矩阵存储图，每次选当前距离最小的节点松弛，确保时间复杂度可控。
    * 💡 **学习笔记**：稠密图用O(n²)的Dijkstra，稀疏图用堆优化的Dijkstra，根据图的类型选择合适算法。

### ✨ 解题技巧总结
<summary_best_practices>
- **关键边标记**：通过前驱数组记录最短路径树中的边，仅枚举这些边。
- **分情况处理**：关键边暴力重算，非关键边公式推导，平衡时间复杂度。
- **反图应用**：构建反图（边方向反转）计算反向最短路径，简化往返费用计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个综合优质题解的通用核心C++实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了modfisher和Mirage_Insane的思路，采用Dijkstra算法求最短路径，标记关键边，分情况处理反转边。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define ll long long
    using namespace std;

    const int N = 205, M = 5e4 + 5;
    const ll INF = 1e18;
    int n, m;
    ll g[N][N], g_rev[N][N]; // 原图和反图的邻接矩阵
    ll dis1[N], disn[N];      // 原图1到各点、n到各点的最短距离
    ll dis1_rev[N], disn_rev[N]; // 反图1到各点、n到各点的最短距离
    int pre1[N], pren[N], pre1_rev[N], pren_rev[N]; // 前驱节点记录最短路径树

    void dijkstra(int s, ll dis[], ll g[][N], int pre[]) {
        fill(dis, dis + N, INF);
        bool vis[N] = {false};
        dis[s] = 0;
        for (int t = 1; t <= n; ++t) {
            int u = 0;
            for (int i = 1; i <= n; ++i)
                if (!vis[i] && dis[i] < dis[u]) u = i;
            vis[u] = true;
            for (int v = 1; v <= n; ++v) {
                if (g[u][v] < INF && dis[v] > dis[u] + g[u][v]) {
                    dis[v] = dis[u] + g[u][v];
                    pre[v] = u;
                }
            }
        }
    }

    int main() {
        cin >> n >> m;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                g[i][j] = g_rev[i][j] = (i == j ? 0 : INF);

        vector<tuple<int, int, ll, ll>> edges(m);
        for (int i = 0; i < m; ++i) {
            int u, v; ll c, d;
            cin >> u >> v >> c >> d;
            edges[i] = {u, v, c, d};
            g[u][v] = min(g[u][v], c);
            g_rev[v][u] = min(g_rev[v][u], c); // 反图即原边反向
        }

        // 计算原图和反图的最短路径
        dijkstra(1, dis1, g, pre1);
        dijkstra(n, disn, g, pren);
        dijkstra(1, dis1_rev, g_rev, pre1_rev);
        dijkstra(n, disn_rev, g_rev, pren_rev);

        ll ans = dis1[n] + disn[1]; // 不反转任何边的费用
        if (ans >= INF) ans = -1;

        // 枚举每条边i，判断是否为关键边
        for (auto [u, v, c, d] : edges) {
            // 判断是否在4棵最短路径树上（原图1、原图n、反图1、反图n）
            bool is_key = false;
            for (int x = 1; x <= n; ++x) {
                if (pre1[x] == u && x == v) is_key = true;
                if (pren[x] == u && x == v) is_key = true;
                if (pre1_rev[x] == v && x == u) is_key = true;
                if (pren_rev[x] == v && x == u) is_key = true;
            }

            if (is_key) {
                // 关键边：暴力重算反转后的最短路径
                ll g_copy[N][N];
                memcpy(g_copy, g, sizeof(g));
                g[v][u] = min(g[v][u], c); // 反转边(u,v)为(v,u)
                if (g[u][v] == c) { // 原边可能有重复，需保留其他边
                    g[u][v] = INF;
                    for (auto [uu, vv, cc, dd] : edges)
                        if (uu == u && vv == v && cc != c)
                            g[u][v] = min(g[u][v], cc);
                }
                dijkstra(1, dis1, g, pre1);
                dijkstra(n, disn, g, pren);
                ll new_cost = dis1[n] + disn[1] + d;
                ans = min(ans, new_cost);
                memcpy(g, g_copy, sizeof(g)); // 恢复原图
            } else {
                // 非关键边：公式计算
                ll cost1 = min(dis1[n], dis1[v] + c + disn_rev[u]);
                ll cost2 = min(disn[1], disn[v] + c + dis1_rev[u]);
                ans = min(ans, cost1 + cost2 + d);
            }
        }

        cout << (ans >= INF ? -1 : ans) << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先初始化原图和反图的邻接矩阵，通过Dijkstra计算4组最短路径（原图/反图、起点1/起点N）。然后枚举每条边，判断是否为关键边（在最短路径树上）。关键边暴力重算反转后的最短路径，非关键边通过原最短路径公式推导。最终输出最小总费用。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：作者modfisher**
* **亮点**：通过构建4棵最短路径树（原图/反图、起点1/起点N），精准定位关键边。
* **核心代码片段**：
    ```cpp
    void dijkstra(int st, int id) {
        int p = (st == 1) ? 0 : 1;
        for (int i = 1; i <= n; ++i) dis[id][p][i] = INF, vis[i] = 0;
        dis[id][p][st] = 0;
        for (int t = 1; t <= n; ++t) {
            int x = 0;
            for (int j = 1; j <= n; ++j) 
                if (!vis[j] && dis[id][p][j] < dis[id][p][x]) x = j;
            vis[x] = 1;
            for (auto [j, w] : G[id][x]) 
                if (dis[id][p][x] + w < dis[id][p][j]) 
                    dis[id][p][j] = dis[id][p][x] + w, pre[id][p][j] = x;
        }
    }
    ```
* **代码解读**：
    `dijkstra`函数计算指定图（原图`id=0`或反图`id=1`）中，起点`st`（1或N）到各点的最短路径，并记录前驱节点`pre`。`dis[id][p][j]`表示图`id`中起点`st`到`j`的最短距离（`p=0`对应起点1，`p=1`对应起点N）。通过遍历所有节点，每次选当前距离最小的节点松弛邻边，确保最短路径正确。
* 💡 **学习笔记**：前驱数组`pre`是记录最短路径树的关键，通过它可以快速判断某条边是否在最短路径上。

**题解二：作者Mirage_Insane**
* **亮点**：通过`book`数组标记原最短路径上的边，仅对这些边暴力重算。
* **核心代码片段**：
    ```cpp
    void dfs(int x) {
        if (pre[x] == 0) return;
        book[id[pre[x]][x]] = 1;
        dfs(pre[x]);
    }
    ```
* **代码解读**：
    `dfs`函数从终点`n`或`1`回溯前驱节点，标记路径上的边到`book`数组中。例如，当计算1到n的最短路径后，调用`dfs(n)`，会沿着`pre`数组回溯到起点1，将路径上的所有边标记为关键边（`book[i]=1`）。这些边反转后可能影响最短路径，需暴力重算。
* 💡 **学习笔记**：深度优先搜索（DFS）是回溯路径的常用方法，通过标记关键边可大幅减少枚举量。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“反转边对最短路径的影响”，我设计了一个8位像素风的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素巴士大冒险`（8位复古游戏风格）
  * **核心演示内容**：展示原图中1到N和N到1的最短路径，枚举反转边时，动态更新路径并计算总费用。
  * **设计思路简述**：采用FC红白机风格的像素网格（16色调色板，如红色代表起点1，蓝色代表终点N，绿色代表最短路径节点）。关键步骤（如边反转、路径更新）用闪烁或音效提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕中央显示N个像素方块代表城市（编号1~N），方块间用箭头（像素线条）表示有向边，边旁标注费用C_i。
        - 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-5倍速）。
        - 播放8位风格背景音乐（如《超级玛丽》经典旋律变奏）。

    2.  **原图最短路径计算**：
        - 点击“开始”，算法自动计算原图1到N的最短路径：起点1（红色方块）闪烁，路径上的节点（绿色）依次亮起（如1→3→4），边用绿色箭头高亮，伴随“滴-滴”音效。
        - 同理展示N到1的最短路径（蓝色路径）。

    3.  **枚举反转边**：
        - 单步执行时，选中一条边（如边2：2→4），边颜色变为黄色并闪烁，播放“叮”声提示反转。
        - 反转后，边方向变为4→2（箭头反向），边旁标注费用C_i+D_i（反转费用）。

    4.  **反转后的路径更新**：
        - 若边是关键边（绿色路径上的边），重新计算最短路径：原绿色路径消失，新路径（橙色）动态生成（如1→2→4），伴随“唰唰”音效。
        - 若边非关键边，直接显示公式计算的费用（如原费用10，新费用8），用数字弹出框提示。

    5.  **目标达成**：
        - 找到最小总费用时，所有路径节点闪烁金色，播放“胜利”音效（如《魂斗罗》通关音），总费用用大字号显示（如“最小费用：10”）。

  * **旁白提示**：
    - （路径生成时）“看！绿色路径是原图1到N的最短路径，费用是6。”
    - （边反转时）“现在反转边2，费用增加1，边方向变为4→2。”
    - （新路径生成时）“反转后，1到N的最短路径变成1→2→4，费用是3，总费用6+3+1=10！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能看到最短路径的动态变化，还能直观理解关键边和非关键边的区别，学习效率大大提升！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以将最短路径的优化枚举思路迁移到更多图论问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 最短路径树标记：用于需要枚举边/点修改的问题（如删除某边后的最短路径）。
    - 反图应用：计算反向路径时，构建反图可简化代码（如求所有节点到终点的最短路径）。
    - 分情况处理：关键操作（如反转边）和非关键操作分开计算，平衡时间复杂度。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1346** - `电车`
          * 🗣️ **推荐理由**：涉及有向图的最短路径，需要处理边的方向变化，与本题思路类似。
    2.  **洛谷 P4568** - `飞行路线`
          * 🗣️ **推荐理由**：允许使用k次免费边（类似本题反转边），需用分层图最短路径，锻炼最短路径变形能力。
    3.  **洛谷 P6880** - `[JOI2020HO] オリンピックバス`
          * 🗣️ **推荐理由**：本题的原题，可用于验证学习效果，加深理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，作者们提到了一些宝贵的经验：
</insights_intro>

> **参考经验 (来自作者modfisher)**：“最初直接枚举所有边导致超时，后来发现只有最短路上的边需要重算，这才想到用最短路径树标记关键边。”
>
> **点评**：这位作者的经验提醒我们，遇到超时问题时，要分析算法的冗余计算。通过观察问题特性（如最短路径的结构），找到优化点（仅处理关键边），是竞赛中常用的技巧。

-----

<conclusion>
本次关于“オリンピックバス”的C++解题分析就到这里。希望这份指南能帮助大家掌握最短路径的优化枚举方法，以及如何通过标记关键边降低时间复杂度。记住，多思考问题的特性，是解决编程题的关键！下次见～💪
</conclusion>

---
处理用时：154.90秒
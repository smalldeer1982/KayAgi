# 题目信息

# 雪玉 (Snowball)

## 题目描述

# [JOI 2021 Final] 雪玉


在一条无限长的数轴上，有 $N$ 个雪球，这 $N$ 个雪球编号为 $1 \sim N$，第 $i$ 个雪球在第 $A_i$ 个点上。刚开始，整条数轴覆盖满了雪，接下来 $Q$ 天将会刮起大风，第 $j$ 天的风力强度为 $W_j$，如果 $W_j$ 为正数，所有雪球都朝右移动 $W_j$ 个单位长度，如果 $W_j$ 为负数，所有雪球都朝左移动 $-W_j$ 个单位长度。

当一个区间 $[a,a+1]$ 被雪覆盖时，雪球滚上去雪球的质量会加一，这一个区间里的雪也会被清空。刚开始每一个雪球的质量均为 $0$，而这 $Q$ 天里也没有再下雪。

你想问这 $Q$ 天结束后每个雪球的质量是怎样的。

## 说明/提示

#### 样例 1 解释

雪球初始位置为 $-2,3,5,8$，初始质量为 $0,0,0,0$。

- 第一天过后，雪球位置为 $0,5,7,10$，质量为 $2,2,2,2$。
- 第二天过后，雪球位置为 $-4,1,3,6$，质量为 $4,4,2,3$。
- 第三天过后，雪球位置为 $3,8,10,13$，质量为 $5,4,2,6$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（33 pts）：$N,Q \le 2000$。
- Subtask 2（67 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N,Q \le 2 \times 10^5$，$|A_i|,|W_j| \le 10^{12}$，$A_i<A_{i+1}$。


翻译自 [The 20th Japanese Olympiad in Informatics Final Round B 雪玉的英文翻译 Snowball](https://www.ioi-jp.org/joi/2020/2021-ho/2021-ho-t2-en.pdf)。

## 样例 #1

### 输入

```
4 3
-2 3 5 8
2
-4
7```

### 输出

```
5
4
2
6```

## 样例 #2

### 输入

```
1 4
1000000000000
1000000000000
-1000000000000
-1000000000000
-1000000000000```

### 输出

```
3000000000000```

## 样例 #3

### 输入

```
10 10
-56 -43 -39 -31 -22 -5 0 12 18 22
-3
0
5
-4
-2
10
-13
-1
9
6```

### 输出

```
14
8
7
9
11
10
9
8
5
10```

# AI分析结果



---
# 💡 Kay的C++算法解析：雪玉 (Snowball) 深入学习指南 💡

<introduction>
今天我们来一起分析“雪玉 (Snowball)”这道C++编程题。这道题需要我们计算多个雪球在多次移动后各自的质量，核心难点在于高效处理大规模数据下的覆盖区间计算。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分查找与数学建模`

🗣️ **初步分析**：
解决“雪玉”问题的关键在于理解雪球的覆盖区间如何随时间变化，并通过二分查找高效确定相邻雪球的冲突时间。简单来说，二分查找就像“猜数字游戏”——通过不断缩小范围，快速定位目标值（这里是相邻雪球覆盖区间的冲突时间）。在本题中，我们需要为每个雪球计算其覆盖区间的左右端点，而相邻雪球的覆盖区间可能重叠，此时需要找到第一个重叠的时间点，从而确定各自的贡献。

- **题解思路与对比**：暴力解法（O(nq)）直接模拟每天移动，但数据量大时会超时；正解通过预处理前缀和和左右最大位移，利用二分查找（O(n log q)）确定冲突时间，大幅优化效率。
- **核心算法流程**：预处理每天的左右最大位移（`L[i]`和`R[i]`），表示前i天雪球向左/右移动的最远距离；对每个相邻雪球对，二分查找其覆盖区间首次重叠的时间点，根据风向分配重叠区间的贡献。
- **可视化设计**：采用8位像素风格，用不同颜色的像素条表示各雪球的覆盖区间。动画中，雪球的移动用像素块滑动表示，覆盖区间扩展时颜色渐变；当相邻区间重叠时，用闪烁和音效（“叮”）提示冲突时间点，并动态调整贡献分配。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，以下题解因高效的二分优化和清晰的逻辑被选为优质题解（≥4星）：
</eval_intro>

**题解一：作者xyin（赞：4）**
* **点评**：此题解深入分析了雪球覆盖区间的单调性，提出通过二分查找冲突时间的核心思路。代码中预处理`L`和`R`数组记录左右最大位移，对每个雪球二分确定冲突时间，逻辑清晰且复杂度优化至O(n log q)。亮点在于利用区间重叠的单调性，将复杂模拟转化为高效的二分查询，适合竞赛实战。

**题解二：作者菲斯斯夫斯基（赞：3）**
* **点评**：此题解从数学建模出发，指出覆盖区间的连续性和相邻雪球的独立性，通过预处理`l`和`r`数组（表示向左/右的最大位移），结合二分查找确定重叠时间。代码简洁规范，变量名含义明确（如`f[i]`表示第i个雪球的区间端点），对边界条件（如首尾雪球）处理严谨，是理解二分优化的优秀示例。

**题解三：作者sndd（赞：2）**
* **点评**：此题解聚焦相邻雪球的区间冲突，通过二分查找确定首次重叠时间，并根据风向分配剩余贡献。代码中`check1`和`check2`函数明确判断冲突条件，`solve`函数高效计算最终答案，体现了对问题本质的深刻理解。其将复杂的区间分配转化为O(1)查询的技巧，是学习的重点。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理相邻雪球的覆盖区间重叠问题。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何建模雪球的覆盖区间？**
    * **分析**：每个雪球的覆盖区间由其移动过程中的左右最大位移决定。预处理`L[i]`（前i天向左移动的最远距离）和`R[i]`（前i天向右移动的最远距离），可快速得到雪球i的覆盖区间为`[A_i + L[Q], A_i + R[Q]]`。
    * 💡 **学习笔记**：预处理关键数组（如`L`和`R`）是优化时间复杂度的常用技巧。

2.  **关键点2：如何确定相邻雪球的冲突时间？**
    * **分析**：相邻雪球i和i+1的初始间距为`A[i+1]-A[i]`。当`L[Q] + R[Q] > 间距`时，覆盖区间会重叠。通过二分查找找到第一个使得`L[mid] + R[mid] > 间距`的时间点`mid`，即可确定冲突时间。
    * 💡 **学习笔记**：利用数组的单调性（`L`和`R`随时间递增），二分查找是定位关键点的高效方法。

3.  **关键点3：如何分配重叠区间的贡献？**
    * **分析**：冲突时间点的风向（`W[mid]`的正负）决定贡献分配。若`W[mid]>0`（向右移动），则剩余贡献归左雪球；反之归右雪球。
    * 💡 **学习笔记**：风向决定了最后一步移动的方向，是分配剩余贡献的关键依据。

### ✨ 解题技巧总结
- **预处理关键数组**：提前计算`L`和`R`数组，避免重复计算。
- **利用单调性**：`L`和`R`的单调性使二分查找可行，大幅降低时间复杂度。
- **边界条件处理**：首尾雪球的覆盖区间无左/右相邻，需单独计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，采用二分查找优化，时间复杂度O(n log q)。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了xyin、菲斯斯夫斯基等题解的思路，预处理`L`和`R`数组，通过二分查找确定冲突时间，计算各雪球的质量。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;
    const int N = 2e5 + 10;

    int n, q;
    int a[N]; // 初始位置
    int L[N], R[N]; // L[i]:前i天向左移动的最远距离（取负），R[i]:前i天向右移动的最远距离
    int ans[N]; // 各雪球的质量

    signed main() {
        cin >> n >> q;
        for (int i = 1; i <= n; ++i) cin >> a[i];
        int sum = 0;
        for (int i = 1; i <= q; ++i) {
            int w; cin >> w;
            sum += w;
            L[i] = max(L[i-1], -sum); // 向左最远位移（取负，便于计算）
            R[i] = max(R[i-1], sum);   // 向右最远位移
        }
        ans[1] += L[q]; // 第一个雪球的左贡献
        ans[n] += R[q]; // 最后一个雪球的右贡献

        for (int i = 1; i < n; ++i) {
            int len = a[i+1] - a[i]; // 相邻雪球初始间距
            if (L[q] + R[q] <= len) { // 无重叠
                ans[i] += R[q];
                ans[i+1] += L[q];
            } else { // 有重叠，二分找冲突时间
                int l = 1, r = q, pos = q;
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (L[mid] + R[mid] > len) {
                        pos = mid;
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                }
                if (L[pos] == L[pos-1]) { // 最后一步向左移动
                    ans[i+1] += L[pos];
                    ans[i] += len - L[pos];
                } else { // 最后一步向右移动
                    ans[i] += R[pos];
                    ans[i+1] += len - R[pos];
                }
            }
        }

        for (int i = 1; i <= n; ++i) {
            cout << ans[i] << "\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先预处理`L`和`R`数组，记录每天的左右最大位移；然后处理首尾雪球的贡献；对每个相邻雪球对，通过二分查找确定冲突时间，根据风向分配重叠区间的贡献，最终输出各雪球的质量。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：作者xyin（来源：洛谷题解）**
* **亮点**：通过二分查找冲突时间，利用`check1`和`check2`函数判断重叠条件，逻辑清晰。
* **核心代码片段**：
    ```cpp
    int solve(int i, int k1, int k2) {
        int ans = 0;
        ans += R[k2] - L[k1];
        if (i == 1) ans += -L[q];
        else if (k1 < q && w[k1+1] < 0)
            ans += a[i] + L[k1] - a[i-1] - R[k1];
        if (i == n) ans += R[q];
        else if (k2 < q && w[k2+1] > 0)
            ans += a[i+1] + L[k2] - a[i] - R[k2];
        return ans; 
    }
    ```
* **代码解读**：`solve`函数根据冲突时间`k1`和`k2`计算雪球i的质量。通过判断是否为首尾雪球，以及剩余移动的方向（`w[k1+1]`的正负），分配重叠区间的贡献。例如，当`i==1`时，左边界无相邻雪球，直接加上左最大位移。
* 💡 **学习笔记**：函数封装复杂逻辑，提高代码可读性，是竞赛编程的良好实践。

**题解二：作者菲斯斯夫斯基（来源：洛谷题解）**
* **亮点**：预处理`l`和`r`数组，利用`upper_bound`快速查找冲突时间，代码简洁高效。
* **核心代码片段**：
    ```cpp
    for(int i=2;i<=n;i++) {
        int id=upper_bound(s+1,s+1+q,a[i]-a[i-1])-s;
        if(a[i]-a[i-1]>=s[q]) {
            f[i]=inf; // 不相交
            continue;
        }
        if(c[id]>0) f[i]=a[i]-l[id-1];
        else f[i]=a[i-1]+r[id-1];
    }
    ```
* **代码解读**：`upper_bound`查找第一个`l[mid]+r[mid] > 间距`的时间点`id`。若`c[id]>0`（最后一步向右），则右雪球的左边界由左雪球的右位移决定；否则由右雪球的左位移决定。
* 💡 **学习笔记**：`upper_bound`是利用数组单调性快速查找的利器，减少手写二分的出错可能。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解雪球覆盖区间的扩展和冲突过程，我们设计一个8位像素风格的动画演示，模拟雪球移动和贡献分配。
</visualization_intro>

  * **动画演示主题**：`像素雪球大冒险`

  * **核心演示内容**：展示每个雪球的覆盖区间（用不同颜色的像素条表示），随着时间推移扩展，当相邻区间重叠时，动态调整贡献分配。

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围，不同颜色区分雪球（如红色、蓝色），覆盖区间用半透明色块表示。关键步骤（如冲突时间点）用闪烁和音效提示，帮助记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化**：数轴用横向像素网格表示，雪球初始位置用圆形像素块标记（如红色），覆盖区间初始为0（无色）。控制面板包含“单步”、“自动播放”按钮和速度滑块。

    2.  **预处理`L`和`R`**：每处理一天的移动，更新左右最大位移，用文字显示当前`L`和`R`的值（如“向左最远：-5”）。

    3.  **覆盖区间扩展**：雪球的覆盖区间随`L`和`R`扩展，用颜色渐变（如红色→粉色）表示扩展过程，同时播放“唰”的音效。

    4.  **冲突检测**：当相邻雪球的覆盖区间重叠时，重叠部分用黄色闪烁，播放“叮”的音效，并显示冲突时间点（如“冲突发生在第3天！”）。

    5.  **贡献分配**：根据风向（`W[mid]`的正负），重叠区间的贡献用箭头动画分配给左或右雪球（如向右移动时，黄色区域向左雪球的质量条（绿色）增加长度）。

    6.  **最终结果**：所有天数处理完成后，显示各雪球的质量（如“雪球1质量：5”），并播放胜利音效（“啦~”）。

  * **旁白提示**：
    - “注意看，雪球的覆盖区间在扩展！红色是雪球1的区间，蓝色是雪球2的区间。”
    - “它们的区间重叠了！冲突时间点在第3天，因为最后一步是向右移动，所以重叠部分归雪球1。”
    - “最终，雪球1的质量是5，雪球2的质量是4！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到覆盖区间的扩展、冲突检测和贡献分配的全过程，更好地理解二分查找在优化中的作用。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握此题后，可通过以下练习巩固二分查找和区间覆盖的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：二分查找适用于解决具有单调性的“关键点”问题，如寻找最大值/最小值、首次满足条件的时间等。本题的预处理和区间分配技巧还可用于处理“区间覆盖”“资源分配”等问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P7405** - `[JOI 2021 Final] 雪玉`（双倍经验）
          * 🗣️ **推荐理由**：与本题完全相同，可用于验证思路和代码的正确性。
    2.  **洛谷 P1182** - `数列分段`
          * 🗣️ **推荐理由**：考察二分查找在最大值最小化问题中的应用，与本题的“关键点”查找思路类似。
    3.  **洛谷 P2678** - `跳石头`
          * 🗣️ **推荐理由**：通过二分查找确定最小跳跃距离，与本题的“冲突时间”查找逻辑相似。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时的经验，例如：
</insights_intro>

> **参考经验 (来自作者xyin)**：“在处理边界条件时，容易忽略首尾雪球的特殊情况（如第一个雪球没有左边相邻雪球），需要单独计算其左贡献。”

**点评**：边界条件的处理是编程中的常见难点。本题中首尾雪球的覆盖区间无左/右限制，需单独计算。这提醒我们在编码时要仔细分析特殊情况，避免因遗漏导致错误。

---

<conclusion>
本次关于“雪玉”的C++解题分析就到这里。通过理解覆盖区间的扩展、二分查找冲突时间和贡献分配，我们掌握了高效解决此类问题的方法。记住，多练习、多总结是提升编程能力的关键。下次见！💪
</conclusion>

---
处理用时：131.31秒
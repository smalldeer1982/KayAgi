# 题目信息

# 出会いと別れ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/zone2021/tasks/zone2021_f

あなたは、スタートアップの新製品として全ての惑星間を行き来出来るようなワープゲートを構築しようとしています。  
 惑星が $ N $ 個あり、$ 0 $ から $ N\ -\ 1 $ までの番号がついています。ここで、ある整数 $ n $ が存在して、$ N\ =\ 2^n $ です。これらの惑星の間を高速に移動するために、$ 2 $ 惑星間を瞬時に移動出来るワープゲートを $ N\ -\ 1 $ 個作成し、全ての惑星間を行き来出来るようなゲート網を作りたいです。しかし、星同士には相性があり、相性が悪い惑星間にはワープゲートを作ることが出来ません。  
 具体的には、相性の悪い惑星は数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_M) $ で表され、ある整数 $ i $ が存在して $ a\ \mathrm{xor}\ b\ =\ A_i $ である場合、かつそのときに限り惑星 $ a $ と惑星 $ b $ の間にワープゲートを作ることが出来ません。   
 全ての惑星間を行き来できるようなゲート網を作ることができるか判定し、できる場合は $ N\ -\ 1 $ 個のワープゲートの作り方を求めてください。

 $ \mathrm{xor} $ とは 整数 $ a,\ b $ のビットごとの排他的論理和 $ a\ \mathrm{xor}\ b $ は、以下のように定義されます。

- $ a\ \mathrm{xor}\ b $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ a,\ b $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \mathrm{xor}\ 5\ =\ 6 $ となります (二進表記すると: $ 011\ \mathrm{xor}\ 101\ =\ 110 $)。

## 说明/提示

### ストーリー

梯子を登りきり UFO に入ると、そこには捕らえられたムーアと、恐ろしい形相の宇宙人が待ち構えていた。 しかしそれ以上に、見覚えのある缶がうずたかく積まれているのが目に留まった。 間違いない。あれは間違いなく ZONe mad\_hacker ver.1.0.0 だ。 そして mad\_hacker を飲んでいるということは、この宇宙人も別の星で MADHACKING に勤しむエンジニアに違いない、と俺は確信した。 勉強会で初めての相手に話しかける時の如く、俺はやや緊張しながら口を開いた。  
 「...foo」  
 聞くや否や、宇宙人の目が輝いた。  
 「...bar!」

「fizz!」「buzz!」  
 ハッカーたちの魂が、星を超えて交わった。 すっかり意気投合した俺たちは、それぞれの星の言語やプログラミングパラダイムについて一晩中語り明かした。 気に入られ、その場でスカウトされた俺は地球人として初のミルキーウェイ(天の川)のスタートアップで働くことになったのだった。 さようなら、地球。ありがとう、ZONe mad\_hacker。そして、hello, space!

### 制約

- 入力は全て整数
- $ 1\ <\ = n\ <\ =\ 18 $ を満たす整数 $ n $ が存在して、$ N\ =\ 2^n $
- $ 0\ <\ = M\ <\ = N\ -\ 1 $
- $ 0\ <\ A_1\ <\ A_2\ <\ \dots\ <\ A_M\ <\ N $

### Sample Explanation 1

$ 1\ \mathrm{xor}\ 0\ =\ 1,\ 1\ \mathrm{xor}\ 3\ =\ 2,\ 0\ \mathrm{xor}\ 2\ =\ 2 $ であるためワープゲートを作ることができ、$ N\ -\ 1 $ 個のワープゲートで全ての惑星間を行き来できるようになっているので、正解となります。 正解となる出力は他にも多数あります。

## 样例 #1

### 输入

```
4 1

3```

### 输出

```
1 0

1 3

0 2```

## 样例 #2

### 输入

```
8 0```

### 输出

```
1 0

1 3

1 5

6 7

6 4

6 2

3 2```

## 样例 #3

### 输入

```
8 7

1 2 3 4 5 6 7```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：出会いと別れ 深入学习指南 💡

<introduction>
今天我们要一起挑战这道“出会いと別れ”的C++编程题！这道题需要判断是否能构建一个连通所有行星的 warp 门网络，并在可行时构造具体方案。让我们通过分析题解、提炼算法，一步步掌握解题核心！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（线性基应用）

🗣️ **初步分析**：
解决这道题的关键在于理解“异或操作的线性基性质”。简单来说，线性基就像一个“异或工具箱”，能通过组合其中的元素（异或操作）生成所有可能的异或结果。例如，若工具箱里有元素 `a` 和 `b`，那么 `a`、`b`、`a^b` 都能被生成。  

在本题中，我们需要判断是否存在一个由 `N-1` 条边组成的生成树，其中边不能是给定数组 `A` 中的异或值。这等价于：所有不在 `A` 中的异或值（即可用边的异或值）构成的集合，其线性基的秩是否为 `n`（因为 `N=2^n`）。若秩为 `n`，说明这些可用值能生成所有可能的异或结果，从而连通所有节点；否则无法构造生成树。

核心难点与解决方案：
- **难点1**：如何判断是否存在生成树？  
  需将所有可用异或值（即不在 `A` 中的数）插入线性基，若基的大小等于 `n`（即 `log2(N)`），则存在解。
- **难点2**：如何构造生成树的边？  
  利用线性基的性质，每个节点 `i` 可以通过异或其最高位对应的基元素，找到其父节点，形成无环的树结构。

可视化设计思路：  
我们将用8位像素风格动画演示线性基的构建过程（如“工具箱”中逐个添加可用值），以及生成树的构造（节点以像素点表示，边以闪烁的连线动态连接）。关键步骤高亮：插入线性基时，对应位的“工具”闪烁；构造边时，节点 `i` 与 `i^基元素` 的连线用绿色高亮，伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选出以下优质题解：
</eval_intro>

**题解一：作者：Register_int (赞：4)**
* **点评**：此题解思路非常清晰，直接抓住线性基的核心——判断基的秩是否为 `n`，并利用格雷码思想构造边。代码简洁高效（如 `__lg(i & -i)` 快速获取最低位1的位置），变量命名直观（`p` 存线性基，`b` 存原数）。最亮点是构造边的逻辑：通过异或基的原数，确保每一步连接唯一且无环，完美契合生成树要求。

**题解二：作者：251Sec (赞：0)**
* **点评**：此题解对线性基的理解深入，代码中 `f` 存线性基，`g` 存原数，逻辑清晰。构造边时利用 `i ^ g[__lg(i)]` 快速找到父节点，时间复杂度为 `O(N)`，非常高效。边界处理严谨（如 `lg = __lg(n)` 确定基的大小），适合竞赛参考。

**题解三：作者：xie_lzh (赞：1)**
* **点评**：此题解另辟蹊径，使用并查集维护连通块。通过枚举可用异或值，每次合并所有可能的边（如 `p` 和 `p^i`），逐步减少连通块数量。虽然复杂度略高（`O(nα(n))`），但思路直观，适合理解连通性问题的本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于突破以下三个核心难点：
</difficulty_intro>

1.  **关键点1**：如何判断是否存在生成树？  
    * **分析**：生成树存在的充要条件是，所有可用异或值（不在 `A` 中的数）的线性基秩为 `n`。线性基的秩决定了能生成的异或结果数量：秩为 `n` 时，能生成 `2^n` 个不同结果（覆盖所有节点）。  
    * 💡 **学习笔记**：线性基的秩等于 `n` 是连通性的“通行证”，秩不足则直接输出 `-1`。

2.  **关键点2**：如何构造生成树的边？  
    * **分析**：每个节点 `i` 的最高位为 `k`（即 `i` 的二进制中最左边的1在第 `k` 位），则 `i` 可以连接到 `i ^ g[k]`（`g[k]` 是线性基中第 `k` 位的原数）。这样连接的边不会形成环，因为每次异或都会降低最高位，最终形成树结构。  
    * 💡 **学习笔记**：最高位是构造树的“导航标”，沿着它走能确保无环。

3.  **关键点3**：如何高效实现线性基？  
    * **分析**：线性基的插入操作需逐位处理，若当前位已有基元素，则异或该基元素，否则将当前值作为基。插入完成后，检查所有位是否都有基元素（秩是否为 `n`）。  
    * 💡 **学习笔记**：线性基的插入是“消元”过程，最终保留的是最简化的基。

### ✨ 解题技巧总结
- **问题抽象**：将连通性问题转化为异或值的线性基秩问题，利用数学工具简化判断。  
- **位运算技巧**：用 `__lg(i & -i)` 快速获取最低位1的位置（如 `i=6` 二进制为 `110`，`i&-i=2`，`__lg(2)=1`）。  
- **构造树的贪心策略**：基于最高位选择父节点，确保每一步连接唯一且无环。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一个简洁高效的核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Register_int和251Sec的思路，线性基插入与构造边的逻辑清晰，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAX_BIT = 18; // n最大为18
    int base[MAX_BIT];      // 线性基（消元后的值）
    int origin[MAX_BIT];    // 线性基对应的原始值（未消元）
    int n, m, lg;

    // 插入x到线性基中，记录原始值
    void insert(int x) {
        int raw = x; // 保存原始值
        for (int i = lg - 1; i >= 0; --i) {
            if (x & (1 << i)) { // 检查第i位是否为1
                if (!base[i]) {  // 该位无基，插入
                    base[i] = x;
                    origin[i] = raw;
                    return;
                } else {
                    x ^= base[i]; // 消元
                }
            }
        }
    }

    int main() {
        cin >> n >> m;
        lg = __lg(n); // n=2^lg
        vector<bool> forbidden(n, false);
        for (int i = 0; i < m; ++i) {
            int a; cin >> a;
            forbidden[a] = true;
        }

        // 插入所有可用异或值到线性基
        for (int i = 1; i < n; ++i) {
            if (!forbidden[i]) insert(i);
        }

        // 检查基的秩是否为lg
        for (int i = 0; i < lg; ++i) {
            if (!base[i]) {
                cout << -1 << endl;
                return 0;
            }
        }

        // 构造生成树的边
        for (int i = 1; i < n; ++i) {
            int k = __lg(i & -i); // 找到最低位的1的位置
            int parent = i ^ origin[k];
            cout << i << " " << parent << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并标记不可用的异或值（`forbidden` 数组）。然后将所有可用异或值插入线性基（`insert` 函数）。若基的大小不足 `lg`（即 `n=2^lg`），输出 `-1`。否则，通过每个节点 `i` 的最低位1找到对应的基原数 `origin[k]`，连接 `i` 和 `i^origin[k]`，形成生成树。

---
<code_intro_selected>
接下来，我们赏析优质题解的核心片段：
</code_intro_selected>

**题解一：作者：Register_int**
* **亮点**：代码极简，利用 `__lg(i & -i)` 快速定位最低位，构造边的逻辑高效。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i < n; i++) 
        v = u ^ b[__lg(i & -i)], 
        printf("%d %d\n", u, v), 
        u = v;
    ```
* **代码解读**：  
  `i & -i` 得到 `i` 的最低位1（如 `i=6` 时，`i&-i=2`），`__lg` 取该位的位置（如 `__lg(2)=1`）。`b[__lg(i & -i)]` 是该位对应的基原数。`u` 是当前节点，`v` 是父节点（`u ^ 基原数`），每次输出边并更新 `u`。  
  这样构造的边不会重复，因为每次异或都会改变最低位，最终遍历所有节点。
* 💡 **学习笔记**：`i & -i` 是快速获取最低位1的“魔法技巧”，在位运算问题中常用。

**题解二：作者：251Sec**
* **亮点**：线性基插入时同时记录原数，构造边时直接使用 `i ^ g[__lg(i)]`，逻辑清晰。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i < n; i++) 
        printf("%d %d\n", i, i ^ g[__lg(i)]);
    ```
* **代码解读**：  
  `__lg(i)` 取 `i` 的最高位位置（如 `i=6` 二进制 `110`，最高位是第2位）。`g[__lg(i)]` 是该最高位对应的基原数。`i ^ g[__lg(i)]` 得到父节点，确保父节点的最高位低于当前节点，避免环。  
  这种构造方式利用了线性基的性质，保证每个节点只有一个父节点，最终形成树。
* 💡 **学习笔记**：最高位是构造树的“层级标识”，沿层级递减方向连接可确保无环。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解线性基的构建和生成树的构造，我们设计一个“像素异或探险”动画：
</visualization_intro>

  * **动画演示主题**：像素异或探险（8位复古风格）  
  * **核心演示内容**：展示可用异或值插入线性基的过程，以及生成树边的动态连接。  

  * **设计思路简述**：  
    采用FC红白机风格，用像素块表示节点（如0号节点为黄色，其他为蓝色），可用异或值为绿色方块，不可用为红色。线性基用“工具箱”表示（8个格子，对应0~17位）。构造生成树时，边以绿色线条动态连接节点，伴随“叮”音效。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧是“节点广场”（8x8像素网格，每个格子标有节点编号）。  
        - 右侧是“异或工具箱”（18个格子，每个格子标有位号0~17）。  
        - 控制面板：单步/自动播放按钮，速度滑块（1x/2x/0.5x）。

    2.  **线性基插入过程**：  
        - 遍历所有数 `i=1~N-1`，若 `i` 是可用值（绿色方块），则开始插入：  
          * 方块从节点广场飞向工具箱，尝试放入对应位的格子（如 `i=3` 二进制 `11`，尝试放入位1的格子）。  
          * 若格子为空，方块停留（表示基插入成功），伴随“滴”音效。  
          * 若格子已有方块，当前方块与格子方块异或（动画：两方块碰撞后变成新方块），继续尝试低位格子。  

    3.  **生成树构造**：  
        - 若工具箱所有格子填满（基秩为n），进入构造阶段：  
          * 节点 `i` 闪烁（如蓝色变亮），找到其最高位对应的基原数（工具箱中对应格子的绿色方块）。  
          * 从 `i` 向 `i^基原数` 绘制绿色线条（边），伴随“叮”音效。  
          * 父节点标记为灰色（已连接），子节点保持蓝色（待连接），最终所有节点连成树。  

    4.  **失败提示**：  
        - 若工具箱有空格子（基秩不足），所有节点变红，播放“咚”音效，显示“-1”。

  * **旁白提示**：  
    - “看！这个绿色方块是可用异或值，它要尝试加入工具箱的第k位格子~”  
    - “如果格子里已有方块，它们会异或成新方块，继续往下找位置哦！”  
    - “现在所有工具箱格子都填满啦！开始构造树，每个节点都要找到自己的父节点~”

<visualization_conclusion>
通过这个动画，我们能直观看到线性基如何“收纳”可用异或值，以及生成树如何一步步连接所有节点。像素风格和音效让抽象的异或操作变得生动有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的线性基思想可迁移到多种异或相关问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    线性基可用于解决“能否通过异或得到目标值”“最大/最小异或和”等问题，例如：  
    - 求数组子集的最大异或和（如洛谷P3812）。  
    - 判断图的连通性（如本题）。  
    - 处理异或空间的基变换（如异或最短路）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3812** - 线性基模板题  
        * 🗣️ **推荐理由**：直接练习线性基的插入与查询，巩固本题的核心工具。
    2.  **洛谷 P4570** - [BJWC2011]元素  
        * 🗣️ **推荐理由**：结合线性基与贪心，理解基的“最大权”应用。
    3.  **洛谷 P5557** - 青原樱  
        * 🗣️ **推荐理由**：异或图连通性问题，深化对线性基与图论结合的理解。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，值得借鉴：
</insights_intro>

> **参考经验 (来自 Inexistented)**：“作者在调试时发现，构造边时若误用最高位而非最低位，会导致环的出现。后来通过打印中间变量，发现 `__lg(i)` 应改为 `__lg(i & -i)` 来获取最低位。”  
> **点评**：这位作者的经验提醒我们，位运算的细节（如最高位 vs 最低位）直接影响结果。调试时打印关键变量（如 `k = __lg(i & -i)` 的值）能快速定位问题，这是非常实用的技巧！

---

<conclusion>
通过本次分析，我们掌握了用线性基解决异或连通性问题的核心方法，理解了生成树的构造逻辑，并通过像素动画直观感受了算法过程。记住，遇到异或相关问题时，线性基是你的“秘密武器”！快去尝试拓展练习，巩固所学吧~ 💪
</conclusion>

---
处理用时：135.23秒
# 题目信息

# [ABC218G] Game on Tree 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc218/tasks/abc218_g

$ N $ 頂点の木があり、各頂点には $ 1 $ から $ N $ までの番号が振られています。また、$ i\,(1\ \leq\ i\ \leq\ N-1) $ 本目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結んでおり、頂点 $ i\,(1\ \leq\ i\ \leq\ N) $ には偶数 $ A_i $ が書かれています。太郎君と次郎君がこの木と $ 1 $ つの駒を使ってゲームをします。

はじめ、駒は頂点 $ 1 $ に置かれています。二人は太郎君から始めて交互に、駒を現在置かれている頂点と直接辺で結ばれた頂点に移動させます。ただし、駒が一度訪れた頂点に移動させることはできません。駒を移動させることができなくなった時点でゲームが終了します。

太郎君はゲームが終了するまでに駒が訪れた頂点（頂点 $ 1 $ を含む）に書かれた数の（多重）集合の中央値を最大化、次郎君は最小化したいです。両者が最適に行動するとき、駒が訪れた頂点に書かれた数の集合の中央値を求めてください。

 中央値とは 大きさ $ K $ の数の（多重）集合の中央値は以下のように定義されます。

- $ K $ が奇数のとき、小さい方から $ \frac{K+1}{2} $ 番目の値
- $ K $ が偶数のとき、小さい方から $ \frac{K}{2} $ 番目の値と $ \frac{K}{2}+1 $ 番目の値の平均値
 
 例えば、$ \{\ 2,2,4\ \} $ の中央値は $ 2 $ 、$ \{\ 2,4,6,6\} $ の中央値は $ 5 $ です。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 2\ \leq\ A_i\ \leq\ 10^9 $
- $ A_i $ は偶数
- $ 1\ \leq\ u_i\ <\ v_i\ \leq\ N $
- 与えられるグラフは木
- 入力は全て整数

### Sample Explanation 1

両者が最適に行動するとき、ゲームは以下のように進行します。 - 太郎君が駒を頂点 $ 1 $ から頂点 $ 5 $ に移動させる - 次郎君が駒を頂点 $ 5 $ から頂点 $ 4 $ に移動させる - 太郎君が駒を頂点 $ 4 $ から頂点 $ 3 $ に移動させる - 次郎君は駒を動かせないのでゲームが終了する 駒が訪れた頂点に書かれた数の集合は $ \{2,10,8,6\} $ となるので、中央値である $ 7 $ を出力します。

### Sample Explanation 2

両者が最適に行動するとき、ゲームは以下のように進行します。 - 太郎君が駒を頂点 $ 1 $ から頂点 $ 4 $ に移動させる - 次郎君は駒を動かせないのでゲームが終了する 駒が訪れた頂点に書かれた数の集合は $ \{6,10\} $ となるので、中央値である $ 8 $ を出力します。

## 样例 #1

### 输入

```
5

2 4 6 8 10

4 5

3 4

1 5

2 4```

### 输出

```
7```

## 样例 #2

### 输入

```
5

6 4 6 10 8

1 4

1 2

1 5

1 3```

### 输出

```
8```

## 样例 #3

### 输入

```
6

2 2 6 4 6 6

1 2

2 3

4 6

2 5

2 6```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC218G] Game on Tree 2 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树形动态规划（Tree DP）+ 动态中位数维护（数据结构应用）


🗣️ **初步分析**：  
解决“Game on Tree 2”，我们需要解决两个核心问题：**树上的博弈决策**和**路径中位数的动态计算**。  
- **树形DP**：就像“从叶子往上给每个节点打分”——每个节点的“分数”（最优中位数）由子节点的分数决定，父节点根据自己的角色（最大化或最小化）选择子节点的分数。比如，太郎（先手）会选子节点中最大的分数，次郎（后手）会选最小的。  
- **动态中位数**：类似“整理书架上的书”——每次添加或删除一个节点值（对应路径的延伸或回溯），快速找到当前路径的中位数。这需要高效的数据结构（如线段树、对顶堆）。  

**核心思路**：  
1. **计算叶子节点的中位数**：通过DFS遍历树，维护当前路径的节点值，计算每个叶子节点到根的中位数。  
2. **树形DP转移**：从叶子往上，父节点根据自己的角色（深度奇偶性）选择子节点的最优值（最大化或最小化）。  

**可视化设计思路**：  
- 用**8位像素风格**展示树结构（根节点红色，子节点蓝色，孙子节点绿色）。  
- 线段树的插入/删除用“像素块闪烁”表示，中位数用“黄色高亮”。  
- 博弈选择时，最大化节点用“向上箭头”，最小化用“向下箭头”，伴随“叮”（插入）、“咚”（删除）、“唰”（选择）的像素音效。  


## 2. 精选优质题解参考

### 题解一：(来源：binbin_200811，赞5)  
* **点评**：  
  这份题解思路清晰，将问题拆解为“动态中位数”和“树形DP”两部分，逻辑推导严谨。代码使用**动态开点线段树**维护中位数，解决了值域大（1e9）的问题，内存效率高。树形DP的转移方程（最大化/最小化子节点值）写得简洁，边界条件（叶子节点的中位数计算）处理得很严谨。从实践角度看，代码可直接用于竞赛，线段树的实现细节（如`insert`和`gtrk`函数）值得学习。  

### 题解二：(来源：DengDuck，赞3)  
* **点评**：  
  题解将问题总结为“求叶子到根的中位数”和“树形博弈”，思路直白。代码用**权值线段树**计算中位数，`dfs`过程中插入/删除节点值，逻辑清晰。树形DP的状态定义（`f[x]`表示x节点的最优值）和转移（根据深度奇偶性选择最大/最小）很容易理解。代码风格规范，变量名（如`md[x]`表示x到根的中位数）含义明确，适合初学者参考。  

### 题解三：(来源：yhylivedream，赞2)  
* **点评**：  
  题解用**对顶multiset**维护中位数，代码比线段树更简洁（如`Median`结构体的`A`、`D`、`Calc`函数）。树形DP的转移与前两题一致，但代码更紧凑（如`S`函数中同时处理插入、递归、删除和转移）。对顶multiset的维护技巧（如`F`函数调整两个集合的大小）是亮点，适合想学习“更轻量数据结构”的学习者。  


## 3. 核心难点辨析与解题策略

### 1. **动态中位数的维护**  
- **难点**：如何高效插入/删除节点值，并快速查询当前路径的中位数（值域大，1e9）。  
- **解决策略**：  
  - 选择**动态开点线段树**（处理大值域）：通过`insert`函数插入/删除值，`gtrk`函数查询第k小（中位数的位置）。  
  - 或选择**对顶multiset**（代码更简洁）：维护两个集合（`st1`存≤中位数，`st2`存>中位数），通过调整集合大小保证中位数的正确性。  
- 💡 **学习笔记**：动态中位数的关键是“快速找到第k小”，选择数据结构时要考虑值域和操作效率。  


### 2. **树形DP的状态定义与转移**  
- **难点**：如何定义每个节点的状态（最优值），并根据角色（最大化/最小化）转移。  
- **解决策略**：  
  - 状态定义：`f[x]`表示从x节点出发，双方最优决策后的中位数。  
  - 转移方程：  
    - 叶子节点：`f[x] = x到根的中位数`。  
    - 太郎（深度偶数）：`f[x] = max(f[子节点])`（选最大的子节点值）。  
    - 次郎（深度奇数）：`f[x] = min(f[子节点])`（选最小的子节点值）。  
- 💡 **学习笔记**：树形DP的核心是“从叶子往上推导”，状态定义要覆盖子问题的所有情况。  


### 3. **博弈角色的判断**  
- **难点**：如何确定每个节点的操作者（太郎或次郎）。  
- **解决策略**：  
  根节点（1号）深度为1（太郎先手），子节点深度为2（次郎），孙子节点深度为3（太郎），依此类推。通过**深度的奇偶性**判断：深度为奇数时，太郎操作（最大化）；深度为偶数时，次郎操作（最小化）。  
- 💡 **学习笔记**：博弈角色的判断可以通过“深度”快速确定，不需要额外的状态。  


### ✨ 解题技巧总结  
- **问题拆解**：将复杂问题（树上博弈+动态中位数）拆解为两个子问题，分别解决。  
- **数据结构选择**：根据值域和操作需求选择合适的数据结构（线段树处理大值域，对顶multiset代码更简洁）。  
- **边界条件处理**：叶子节点的中位数计算是树形DP的基础，要确保正确。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（综合binbin_200811和yhylivedream的思路）  
* **说明**：本代码用**动态开点线段树**维护中位数，**树形DP**转移，逻辑清晰，适合作为模板。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  typedef long long ll;
  const ll maxn=1e5+5, inf=1e9;

  struct Edge { ll to, nxt; } edge[maxn<<1];
  struct Node { ll lch, rch, val; } tree[maxn*31];

  ll n, tot=1, cnt, head[maxn], a[maxn], f[maxn];

  void add(ll x, ll y) { edge[++cnt].to=y; edge[cnt].nxt=head[x]; head[x]=cnt; }
  void updata(ll p) { tree[p].val=tree[tree[p].lch].val+tree[tree[p].rch].val; }
  void insert(ll p, ll l, ll r, ll x, ll v) {
      if(l==r) { tree[p].val+=v; return; }
      ll mid=(l+r)/2;
      if(x<=mid) { if(!tree[p].lch) tree[p].lch=++tot; insert(tree[p].lch, l, mid, x, v); }
      else { if(!tree[p].rch) tree[p].rch=++tot; insert(tree[p].rch, mid+1, r, x, v); }
      updata(p);
  }
  ll gtrk(ll p, ll rk) {
      if(tree[p].l==tree[p].r) return tree[p].l;
      if(tree[tree[p].lch].val>=rk) return gtrk(tree[p].lch, rk);
      else return gtrk(tree[p].rch, rk-tree[tree[p].lch].val);
  }

  void dfs(ll x, ll fa, ll dep) {
      insert(1, 1, inf, a[x], 1);
      f[x] = (dep%2==1 ? -inf : inf); // 太郎（奇）最大化，次郎（偶）最小化
      ll kid=0;
      for(ll i=head[x]; i; i=edge[i].nxt) {
          ll v=edge[i].to;
          if(v!=fa) { dfs(v, x, dep+1); kid++; }
      }
      if(kid==0) { // 叶子节点
          if(dep%2==1) f[x] = gtrk(1, (dep+1)/2);
          else f[x] = (gtrk(1, dep/2) + gtrk(1, dep/2+1))/2;
      } else { // 非叶子节点
          for(ll i=head[x]; i; i=edge[i].nxt) {
              ll v=edge[i].to;
              if(v==fa) continue;
              if(dep%2==1) f[x] = max(f[x], f[v]);
              else f[x] = min(f[x], f[v]);
          }
      }
      insert(1, 1, inf, a[x], -1);
  }

  int main() {
      scanf("%lld", &n);
      for(ll i=1; i<=n; i++) scanf("%lld", &a[i]);
      for(ll i=1; i<n; i++) { ll x, y; scanf("%lld%lld", &x, &y); add(x, y); add(y, x); }
      dfs(1, 0, 1);
      printf("%lld", f[1]);
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **线段树部分**：`insert`函数插入/删除节点值，`gtrk`函数查询第k小（中位数的位置）。  
  2. **DFS部分**：遍历树，插入当前节点值，递归处理子节点，计算叶子节点的中位数，然后根据角色转移父节点的`f[x]`值，最后删除当前节点值（回溯）。  


### 题解一（binbin_200811）核心片段赏析  
* **亮点**：动态开点线段树处理大值域，树形DP转移简洁。  
* **核心代码片段**：  
  ```cpp
  void dfs(ll x, ll bj, ll fa, ll c) {
      f[x] = -inf;
      insert(1, 1, inf*2, a[x], 1);
      ll kid=0;
      for(ll i=head[x]; i; i=edge[i].nxt) {
          ll v=edge[i].to;
          if(v!=fa) { dfs(v, -bj, x, c+1); kid++; }
      }
      if(kid) { // 非叶子节点
          for(ll i=head[x]; i; i=edge[i].nxt) {
              ll v=edge[i].to;
              if(v==fa) continue;
              f[x] = max(f[v]*bj, f[x]);
          }
          f[x] = abs(f[x]);
      } else { // 叶子节点
          if(c%2==0) f[x] = (gtrk(1, c/2) + gtrk(1, c/2+1))/2;
          else f[x] = gtrk(1, (c+1)/2);
      }
      insert(1, 1, inf*2, a[x], -1);
  }
  ```  
* **代码解读**：  
  - `bj`参数表示角色（1为太郎，-1为次郎），`c`表示当前路径长度。  
  - 非叶子节点：通过`max(f[v]*bj, f[x])`计算最优值（`bj`为1时取最大，-1时取最小）。  
  - 叶子节点：根据路径长度的奇偶性计算中位数。  
* 💡 **学习笔记**：用`bj`参数简化角色判断，代码更紧凑。  


### 题解三（yhylivedream）核心片段赏析  
* **亮点**：对顶multiset维护中位数，代码简洁。  
* **核心代码片段**：  
  ```cpp
  struct Median {
      multiset<ll> l, g;
      void init() { l.clear(); g.clear(); l.insert(-inf); g.insert(inf); }
      void F() {
          while(l.size() > g.size()+1) { g.insert(*--l.end()); l.erase(--l.end()); }
          while(g.size() > l.size()) { l.insert(*g.begin()); g.erase(g.begin()); }
      }
      void A(ll val) { (val <= *g.begin() ? l.insert(val) : g.insert(val)); F(); }
      void D(ll val) {
          auto it = l.lower_bound(val);
          if(it != l.end()) l.erase(it);
          else { it = g.lower_bound(val); if(it != g.end()) g.erase(it); }
          F();
      }
      ll Calc() {
          if((l.size()+g.size()-2)%2==0) return (*--l.end() + *g.begin())/2;
          return *--l.end();
      }
  } s;
  ```  
* **代码解读**：  
  - `l`存≤中位数的数，`g`存>中位数的数。  
  - `F`函数调整两个集合的大小，保证`l.size()`等于`g.size()`或`g.size()+1`。  
  - `A`函数插入值，`D`函数删除值，`Calc`函数计算中位数。  
* 💡 **学习笔记**：对顶multiset的维护技巧（`F`函数）是关键，代码比线段树更易写。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素树的博弈之旅**  
（仿照FC红白机风格，用8位像素块展示树结构、线段树操作和博弈选择）


### 核心演示内容  
1. **树结构初始化**：  
   - 根节点（1号）用**红色像素块**表示，子节点用**蓝色**，孙子节点用**绿色**，边用**灰色线条**连接。  
   - 控制面板显示“开始/暂停”“单步”“重置”按钮，速度滑块，以及当前中位数。  

2. **动态中位数计算**：  
   - 当DFS遍历到一个节点时，**线段树的对应位置闪烁**（表示插入值），伴随“叮”的音效。  
   - 叶子节点的中位数用**黄色高亮**显示，旁边弹出文字“叶子节点，中位数：X”。  

3. **树形DP转移**：  
   - 非叶子节点的**角色图标**（太郎用“↑”，次郎用“↓”）闪烁，伴随“唰”的音效。  
   - 子节点的**分数**（`f[x]`）用**数字像素块**显示，父节点选择最大/最小分数时，对应的子节点用**橙色边框**标记。  

4. **博弈结果展示**：  
   - 最终根节点的分数（答案）用**大字体黄色像素**显示，伴随“胜利”音效（如《超级马里奥》的通关音乐）。  


### 设计思路  
- **像素风格**：营造复古游戏氛围，降低学习压力。  
- **音效反馈**：用“叮”“咚”“唰”等简单音效强化操作记忆。  
- **视觉高亮**：通过颜色和边框标记关键元素（如中位数、选择的子节点），帮助理解算法流程。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **动态中位数**：可用于处理“滑动窗口中位数”（如LeetCode 239题）、“在线中位数查询”（如洛谷P1168）等问题。  
- **树形DP**：可用于处理“树上最长路径”（如洛谷P2577）、“二叉树的最大路径和”（如LeetCode 124题）等问题。  


### 练习推荐 (洛谷)  
1. **洛谷 P1168** - 《中位数》  
   🗣️ **推荐理由**：直接考察动态中位数的维护，可用对顶堆或线段树解决，是本题的基础练习。  

2. **洛谷 P2577** - 《二叉树的最长路径》  
   🗣️ **推荐理由**：考察树形DP的基本思路（从叶子往上推导），帮助巩固树形DP的状态定义和转移。  

3. **洛谷 P3369** - 《平衡树模板》  
   🗣️ **推荐理由**：平衡树是维护动态中位数的另一种方法，学习平衡树的实现（如Treap、Splay），拓展数据结构知识。  

4. **洛谷 P1352** - 《没有上司的舞会》  
   🗣️ **推荐理由**：经典树形DP问题，考察“选择或不选择”的转移逻辑，帮助提升树形DP的思维能力。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自yhylivedream)  
> “这不比线段树好写114倍。”（指对顶multiset的代码简洁性）  
> **点评**：对顶multiset的代码确实比线段树更易写，但线段树处理大值域的能力更强。选择数据结构时，要根据题目需求（如值域、操作次数）权衡。  

### 参考经验 (来自binbin_200811)  
> “动态开点线段树的内存要足够，否则会RE。”  
> **点评**：动态开点线段树的内存需要预先估计（如`maxn*31`），否则会导致内存溢出。调试时要注意内存问题。  


## 结语  
本次关于“[ABC218G] Game on Tree 2”的分析，我们学习了**树形DP**和**动态中位数**的结合应用。记住，**问题拆解**和**数据结构选择**是解决复杂问题的关键。希望这份指南能帮助你更好地理解算法逻辑，提升编程能力！💪  

下次我们再一起探索新的编程挑战！🚀

---
处理用时：484.82秒
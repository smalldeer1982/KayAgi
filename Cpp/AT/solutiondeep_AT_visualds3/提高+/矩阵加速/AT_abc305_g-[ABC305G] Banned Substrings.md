# 题目信息

# [ABC305G] Banned Substrings

## 题目描述

给定一个由 $M$ 个长度不超过 $6$ 的仅由字母 $\texttt a$ 和 $\texttt b$ 组成的非空字符串集合 $S=\{s_1, s_2, ..., s_M\}$。

求有多少个字符串 $T$ 满足以下条件：

- 长度为 $N$ 且仅由字母 $\texttt a$ 和 $\texttt b$ 组成。
- 对于任意 $s_i\in S$，$T$ 中不包含 $s_i$ 作为连续的子串。

由于答案可能很大，所以对 $998244353$ 取模。

## 说明/提示

$1\leq N\leq 10^{18}$

$1\leq M\leq 126$

$N$ 和 $M$ 是整数。

$s_i$ 是由字母 $a$ 和 $b$ 组成的长度不超过 $6$ 的非空字符串。

$s_i \neq s_j$（$1\leq i<j\leq M$）。

## 样例 #1

### 输入

```
4 3

aab

bbab

abab```

### 输出

```
10```

## 样例 #2

### 输入

```
20 1

aa```

### 输出

```
17711```

## 样例 #3

### 输入

```
1000000007 28

bbabba

bbbbaa

aabbab

bbbaba

baaabb

babaab

bbaaba

aabaaa

aaaaaa

aabbaa

bbaaaa

bbaabb

bbabab

aababa

baaaba

ababab

abbaba

aabaab

ababaa

abbbba

baabaa

aabbbb

abbbab

baaaab

baabbb

ababbb

baabba

abaaaa```

### 输出

```
566756841```

# AI分析结果


### 💡 Kay的C++算法解析：ABC305G Banned Substrings 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`AC自动机` + `矩阵快速幂优化动态规划`

🗣️ **初步分析**：
> 解决"禁止子串计数"问题，核心是高效处理多模式串匹配。**AC自动机**如同智能导航系统，能快速识别所有禁止路径；**矩阵快速幂**则像高速电梯，将O(n)的递推优化为O(log n)。  
> - **核心难点**：n极大(10¹⁸)且含多个禁止串，暴力枚举不可行。AC自动机构建状态转移图，矩阵快速幂加速状态转移。  
> - **算法流程**：  
>   1. 构建AC自动机（Trie图），标记含禁止串的终止节点  
>   2. 设计DP状态：`dp[i][j]`表示长度i且位于自动机节点j的方案数  
>   3. 将状态转移转化为矩阵乘法  
>   4. 矩阵快速幂求解  
> - **可视化设计**：用像素方块表示自动机节点（绿色正常/红色终止），箭头表示转移边。添加字符时像素小人沿边移动，触发终止节点时闪烁红光+失败音效，成功转移播放"叮"声。

---

#### 2. 精选优质题解参考
**题解一 (Neil_Qian)**  
* **点评**：思路最完整清晰，逐步解释AC自动机构建、DP设计和矩阵优化。代码规范：  
  - 终止标记传递`vis[u]|=vis[fail[u]]`严谨处理子串包含  
  - 矩阵乘法三重循环逻辑直接易懂  
  - 实践价值高：直接可用于竞赛，边界处理完善  

**题解二 (_•́へ•́╬_)**  
* **点评**：代码简洁高效，亮点：  
  - 用`deque`优化AC自动机构建过程  
  - 转移矩阵构建时直接复用`fail`指针，减少冗余判断  
  - 虽未详细注释，但算法核心实现精准  

**题解三 (Little_x_starTYJ)**  
* **点评**：结构清晰易读，亮点：  
  - 独立封装矩阵乘法结构体  
  - 状态转移时显式判断终止标记，逻辑明确  
  - 循环顺序i->j->k的矩阵乘法稍慢但易理解  

---

#### 3. 核心难点辨析与解题策略
1. **AC自动机构建与终止标记传递**  
   * **分析**：禁止串可能存在包含关系（如"aa"被"baa"包含），需沿fail指针传递终止标记。优质题解均用`vis[u]|=vis[fail[u]]`确保完备性  
   * 💡 **学习笔记**：fail指针不仅是跳转工具，更是状态完备性的保证  

2. **状态转移矩阵的设计**  
   * **分析**：矩阵元素`M[i][j]`表示从状态j添加字符后转移到i的方案数。需排除终止状态转移  
   * 💡 **学习笔记**：将DP转移转化为矩阵乘法是处理超大n的利器  

3. **矩阵乘法的实现优化**  
   * **分析**：三重循环顺序影响效率。最优顺序i->k->j利用CPU缓存，但i->j->k更易理解  
   * 💡 **学习笔记**：算法竞赛中可读性优先，实际工程需考虑性能  

### ✨ 解题技巧总结
- **状态压缩技巧**：利用禁止串短的特点(≤6)，AC自动机状态数≤128  
- **模块化设计**：分离AC自动机构建、矩阵乘法、快速幂等模块  
- **边界处理**：特判n=0时方案数为1（空串）  

---

#### 4. C++核心代码实现赏析
**通用核心实现 (综合优化版)**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD = 998244353;
const int N = 132; // 状态数上限

struct Matrix {
    vector<vector<ll>> a;
    Matrix(int n) : a(n, vector<ll>(n)) {}
    Matrix operator*(const Matrix& b) {
        int n = a.size();
        Matrix res(n);
        for (int i = 0; i < n; i++)
            for (int k = 0; k < n; k++)
                for (int j = 0; j < n; j++)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % MOD;
        return res;
    }
};

int main() {
    ll n; int m; 
    cin >> n >> m;
    
    // AC自动机构建
    vector<array<int, 2>> ch(N);
    vector<int> fail(N);
    vector<bool> ban(N);
    int cnt = 0;
    
    auto insert = [&](string s) {
        int u = 0;
        for (char c : s) {
            int idx = c - 'a';
            if (!ch[u][idx]) ch[u][idx] = ++cnt;
            u = ch[u][idx];
        }
        ban[u] = true;
    };
    
    while (m--) { string s; cin >> s; insert(s); }
    
    queue<int> q;
    for (int i = 0; i < 2; i++) 
        if (ch[0][i]) q.push(ch[0][i]);
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ban[u] = ban[u] || ban[fail[u]];  // 关键！终止标记传递
        for (int i = 0; i < 2; i++) {
            if (ch[u][i]) {
                fail[ch[u][i]] = ch[fail[u]][i];
                q.push(ch[u][i]);
            } else {
                ch[u][i] = ch[fail[u]][i];
            }
        }
    }
    
    // 构建转移矩阵
    int sz = cnt + 1;
    Matrix M(sz);
    for (int i = 0; i < sz; i++) {
        if (ban[i]) continue;
        for (int c = 0; c < 2; c++) {
            int j = ch[i][c];
            if (!ban[j]) M.a[j][i]++;
        }
    }
    
    // 矩阵快速幂
    Matrix res(sz);
    for (int i = 0; i < sz; i++) res.a[i][i] = 1;  // 单位矩阵
    
    while (n) {
        if (n & 1) res = res * M;
        M = M * M;
        n /= 2;
    }
    
    ll ans = 0;
    for (int i = 0; i < sz; i++) 
        if (!ban[i]) ans = (ans + res.a[i][0]) % MOD;
    
    cout << ans;
}
```

**代码解读概要**：  
1. AC自动机构建：`insert()`插入禁止串，BFS构建fail指针  
2. 终止标记传递：`ban[u]|=ban[fail[u]]`确保子串包含  
3. 转移矩阵：矩阵元素`M[i][j]`表示从状态j经字符转移到i的方案数  
4. 矩阵快速幂：单位矩阵初始状态，倍增法计算转移矩阵的n次幂  

---

#### 5. 算法可视化：像素动画演示
**主题**：AC自动机迷宫大冒险 (8-bit像素风格)  
**核心演示**：AC自动机状态转移 + 矩阵快速幂计算  

**动画设计**：  
1. **场景布局**  
   - 左侧：像素风AC自动机（节点=彩色方块，红色=终止状态）  
   - 右侧：矩阵网格（像素色块表示数值大小）  
   - 底部控制台：步进/播放/速度滑块  

2. **动态流程**  
   - **步骤1**：字符输入时，像素小人从当前节点沿转移边移动  
     - 成功转移：播放"叮"声，目标节点闪烁绿色  
     - 触发禁止：节点闪烁红色，播放失败音效  
   - **步骤2**：矩阵乘法可视化  
     - 网格色块亮度表示数值大小  
     - 当前计算行列高亮显示，伴随像素粒子特效  
   - **步骤3**：快速幂过程展示  
     - 指数n的二进制位点亮，对应矩阵自乘操作  

3. **游戏化元素**  
   - 每成功添加字符得10分，连续成功×2倍率  
   - 完成全部转移后播放8-bit胜利音乐  
   - "AI演示模式"：自动展示最优转移路径  

**技术实现**：  
- 状态转移用Canvas绘制节点和箭头  
- 矩阵网格用二维数组渲染，色相映射数值  
- 音效：Web Audio API生成8-bit音效  

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
AC自动机+矩阵快速幂适用于：  
1. 带禁止串的路径计数  
2. 有限状态自动机的多步转移  
3. 字符串生成的概率计算  

**推荐练习**：  
1. **P4052 文本生成器**  
   🗣️ 统计包含至少一个模式串的文本数，巩固AC自动机反向思维  
2. **P2446 大陆争霸**  
   🗣️ 图论与矩阵快速幂结合，理解状态转移的泛化应用  
3. **P3758 可乐**  
   🗣️ 简单矩阵快速幂入门，体会离散时间系统的状态转移  

---

#### 7. 学习心得与经验分享
> **经验分享**：  
> "构建AC自动机时，未传递终止标记导致WA。通过打印中间状态发现：当禁止串'aa'被'baa'包含时，仅标记'aa'终点会漏判'baa'的匹配"  
>   
> **点评**：  
> 这位同学的调试经历揭示了AC自动机的关键机制——fail指针不仅是跳转工具，更是状态完备性的保证。在解决类似问题时，务必验证终止标记的传递性！

---

**结语**：  
通过AC自动机构建状态转移图，结合矩阵快速幂处理超大n，是解决禁止子串问题的经典范式。理解状态设计、终止标记传递和矩阵优化是掌握核心的关键。继续加油，勇士们！🎮🚀

---
处理用时：181.61秒
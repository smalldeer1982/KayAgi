# 题目信息

# [ABC222F] Expensive Expense

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc222/tasks/abc222_f

AtCoder 王国は $ N $ 個の街と $ N-1 $ 個の道路からなります。  
 街には 街 $ 1 $, 街 $ 2 $, $ \dots $, 街 $ N $ と番号がついています。道路にも同様に 道路 $ 1 $, 道路 $ 2 $, $ \dots $, 道路 $ N-1 $ と番号が付いています。 道路 $ i $ は街 $ A_i $ と $ B_i $ を双方向に結んでいて、通過するときに $ C_i $ の通行料がかかります。すべての異なる街の組 $ (i,\ j) $ に対して、道路を経由して街 $ i $ から街 $ j $ に行くことができます。

今、列 $ D\ =\ (D_1,\ D_2,\ \dots,\ D_N) $ が与えられます。 $ D_i $ は街 $ i $ を観光するときにかかる費用です。 このとき、街 $ i $ から街 $ j $ への旅費 $ E_{i,j} $ を、(同じ道を $ 2 $ 回以上使わずに街 $ i $ から街 $ j $ へ向かうときにかかる通行料の和) に $ D_{j} $ を足したものとして定めます。

- 厳密に言い換えると、$ i\ -\ j $ 間の最短パスを $ i\ =\ p_0,\ p_1,\ \dots,\ p_{k-1},\ p_k\ =\ j $ として、街 $ p_{l} $ と街 $ p_{l+1} $ を結ぶ道路の通行料を $ c_l $ と置いたときに $ E_{i,j}\ =\ D_j\ +\ \displaystyle\sum_{l=0}^{k-1}\ c_l $ と定義します。

すべての $ i $ に対して、街 $ i $ を始点として他の街へ旅行したときにありえる旅費の最大値を求めてください。

- 厳密に言い換えると、すべての $ i $ に対して $ \max_{1\ \leq\ j\ \leq\ N,\ j\ \neq\ i}\ E_{i,j} $ を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ B_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N-1) $
- $ 1\ \leq\ D_i\ \leq\ 10^9 $ $ (1\ \leq\ i\ \leq\ N) $
- 整数の組 $ (i,j) $ が $ 1\ \leq\ i\ \lt\ j\ \leq\ N $ を満たすならば、街 $ i $ から街 $ j $ へいくつかの道路を通ることで移動できる。
- 入力はすべて整数である。

### Sample Explanation 1

すべての街の順序つき組 $ (i,j) $ に対して $ E_{i,j} $ を計算すると次のようになります。 - $ E_{1,2}\ =\ 2\ +\ 2\ =\ 4 $ - $ E_{1,3}\ =\ 5\ +\ 3\ =\ 8 $ - $ E_{2,1}\ =\ 2\ +\ 1\ =\ 3 $ - $ E_{2,3}\ =\ 3\ +\ 3\ =\ 6 $ - $ E_{3,1}\ =\ 5\ +\ 1\ =\ 6 $ - $ E_{3,2}\ =\ 3\ +\ 2\ =\ 5 $

## 样例 #1

### 输入

```
3

1 2 2

2 3 3

1 2 3```

### 输出

```
8

6

6```

## 样例 #2

### 输入

```
6

1 2 3

1 3 1

1 4 4

1 5 1

1 6 5

9 2 6 5 3 100```

### 输出

```
105

108

106

109

106

14```

## 样例 #3

### 输入

```
6

1 2 1000000000

2 3 1000000000

3 4 1000000000

4 5 1000000000

5 6 1000000000

1 2 3 4 5 6```

### 输出

```
5000000006

4000000006

3000000006

3000000001

4000000001

5000000001```

# AI分析结果


### 💡 Kay的C++算法解析：ABC222F Expensive Expense 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树的直径 + 树形DP  
🗣️ **初步分析**：
> 解决本题的关键在于理解**树的直径性质**：树上任意点到其他点的最远点必是直径端点之一。通过建立虚拟点（将点权转化为边权），问题转化为求树的直径和端点到各点的距离。  
> - 核心思路：① 建图时添加虚拟点（点权→边权）② 三次DFS求直径端点及距离 ③ 对每个点取两端点距离最大值（排除自身）  
> - 可视化设计：复古像素网格中，用**红色/蓝色方块**标记直径端点，绿色箭头动态展示从当前点到端点的路径，**黄色数字**实时显示累计费用（边权+点权）。动画采用FC音效——移动时"滴"声，找到端点时"胜利"音效，配合调速滑块控制演示速度。

---

#### 2. 精选优质题解参考
**题解一（作者：_zzzzzzy_）**  
* **点评**：  
  思路清晰，创新性地用虚拟点（`i+n`）将点权转化为边权，巧妙转化为经典树的直径问题。代码简洁高效（O(n)），变量命名合理（`disl/disr`），边界处理严谨（排除自身）。亮点在于虚拟点的设计，直接复用模板即可解决，实践价值高。

**题解二（作者：In_Memory）**  
* **点评**：  
  采用换根DP解法，推导严谨（状态定义`f[u]`为子树最大费用，`g[u]`为父树最大费用）。代码规范，用前缀/后缀最大值优化避免重复计算，确保O(n)复杂度。亮点在于用`vector`动态维护兄弟节点贡献，虽然实现稍复杂，但展示了DP优化的核心思想。

**题解三（作者：GI录像机）**  
* **点评**：  
  简洁版直径解法，不建虚拟点而是直接调整边权。代码更短小精悍（60行），逻辑直白。亮点在于快速抓住直径性质核心，适合竞赛快速编码，但对点权转化过程的解释稍显不足。

---

#### 3. 核心难点辨析与解题策略
1. **点权如何融入路径计算？**  
   * **分析**：将点权`D_i`转化为边权（连接虚点`i+n`的边），使问题回归纯边权树模型。  
   * 💡 **学习笔记**：点权→边权的转化是树问题的常见技巧，需保证转化后图仍为树。

2. **如何高效求所有点的最大旅费？**  
   * **分析**：利用直径性质——三次DFS求端点+距离，避免O(n²)暴力；或换根DP用前缀/后缀最值优化状态转移。  
   * 💡 **学习笔记**：树的直径法代码更简洁，换根DP适用性更广（如非端点类问题）。

3. **如何排除自身作为终点？**  
   * **分析**：当当前点`i`恰好是直径端点时，需取另一端点距离。  
   * 💡 **学习笔记**：直径法中用`if(i+n==l)`特判，换根DP通过动态剔除子树实现。

### ✨ 解题技巧总结
- **技巧1 问题转化**：将点权转化为虚拟边权，复用经典算法模型  
- **技巧2 最值维护**：换根DP中用前缀/后缀数组避免重复计算  
- **技巧3 边界处理**：直径端点需排除自身，用`max_element`定位端点  

---

#### 4. C++核心代码实现赏析
**通用核心实现（树的直径法）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 4e5 + 10; // 注意2倍点

vector<pair<int, ll>> g[N]; // 邻接表
ll disL[N], disR[N];       // 到左右端点的距离
int n, l, r;               // 直径端点

void dfs(int u, int fa, ll dis[], ll cur = 0) {
    dis[u] = cur;
    for (auto &[v, w] : g[u]) 
        if (v != fa) dfs(v, u, dis, cur + w);
}

int main() {
    cin >> n;
    // 建图：实边+虚边
    for (int i = 1; i < n; ++i) {
        int u, v; ll w; cin >> u >> v >> w;
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }
    for (int i = 1, d; i <= n; ++i) {
        cin >> d;
        g[i].emplace_back(i + n, d); // 虚点边权为d[i]
        g[i + n].emplace_back(i, d);
    }

    // 三次DFS求直径及距离
    dfs(1, 0, disL);
    l = max_element(disL + 1, disL + 2 * n + 1) - disL;
    dfs(l, 0, disL);
    r = max_element(disL + 1, disL + 2 * n + 1) - disL;
    dfs(r, 0, disR);

    // 输出答案（排除自身）
    for (int i = 1; i <= n; ++i) {
        if (i + n == l) cout << disR[i] << "\n";
        else if (i + n == r) cout << disL[i] << "\n";
        else cout << max(disL[i], disR[i]) << "\n";
    }
}
```

**题解二（换根DP）核心片段**  
```cpp
// 状态定义
vector<ll> f(N), g(N); // f[u]:子树最大费用，g[u]:父树最大费用

void dfs1(int u, int fa) {
    f[u] = d[u]; // 初始化点权
    for (auto [v, w] : g[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        f[u] = max(f[u], f[v] + w); // 子树转移
    }
}

void dfs2(int u, int fa) {
    vector<ll> pre, suf; // 前缀/后缀最值
    // 预处理兄弟节点贡献
    for (auto [v, w] : g[u]) {
        if (v == fa) continue;
        pre.push_back(f[v] + w);
        suf.push_back(f[v] + w);
    }
    // 计算前缀/后缀最值
    partial_sum(pre.begin(), pre.end(), pre.begin(), 
        [](ll a, ll b) { return max(a, b); });
    partial_sum(suf.rbegin(), suf.rend(), suf.rbegin(), 
        [](ll a, ll b) { return max(a, b); });
    
    // 换根更新子节点
    int idx = 0;
    for (auto [v, w] : g[u]) {
        if (v == fa) continue;
        // 剔除v的贡献
        ll broMax = max(
            idx > 0 ? pre[idx - 1] : LLONG_MIN,
            idx < suf.size() - 1 ? suf[idx + 1] : LLONG_MIN
        );
        g[v] = max(f[v], w + max(g[u], broMax)); // 更新g[v]
        dfs2(v, u);
        ++idx;
    }
}
```

---

### 5. 算法可视化：像素动画演示
* **主题**：`像素探险家寻宝之旅`（FC红白机风格）  
* **核心演示流程**：  
  1. **场景初始化**：  
     - 8-bit像素树（绿色方块为节点，棕色线条为边）  
     - 控制面板：开始/暂停/单步/速度滑块  
     - 直径端点闪烁红光/蓝光，背景播放8-bit循环BGM  

  2. **动态演示**：  
     - **步骤1**：从起点`i`出发，分两路向端点移动，路径上显示累计费用（边权+点权）  
     - **步骤2**：当前边权累加时播放"滴"声，终点`j`被访问时显示`D_j`并播放"叮"声  
     - **步骤3**：比较两路径费用，取最大值显示为`答案`，播放胜利音效  

  3. **交互设计**：  
     - `AI自动模式`：像贪吃蛇AI自动遍历所有点（调速滑块控制）  
     - `关卡进度`：每计算完一个点获得1颗星，满星通关  

* **设计思路**：像素风格降低理解门槛，音效强化关键操作记忆，游戏化进度提升学习动力。

---

#### 6. 拓展练习与相似问题
* **通用技巧迁移**：  
  1. 点权转边权 → [P1395 会议]  
  2. 树的直径性质 → [P4408 逃学的小孩]  
  3. 换根DP优化 → [P3478 STA-Station]  

* **洛谷练习推荐**：  
  1. **P1395**：巩固点权转化技巧  
  2. **P3478**：经典换根DP应用题  
  3. **P5536**：树的直径综合应用  

---

#### 7. 学习心得
> 题解中作者提到：数组未开双倍导致RE（`N=2e5`需开`4e5`）。这提醒我们：  
> **调试心得**：树问题中，虚拟点会使规模翻倍，必须检查数组大小！  
> **核心技巧**：暴力DFS超时时，优先考虑直径性质或换根DP优化。  

---  
💪 坚持练习，你也能成为树问题大师！下次见～

---
处理用时：177.12秒
# 题目信息

# [ABC205E] White and Black Balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc205/tasks/abc205_e

白いボール $ N $ 個と黒いボール $ M $ 個を横一列に並べる方法であって、次の条件を満たすものは何通りありますか？

- 各 $ i\ \,\ (1\ \leq\ i\ \leq\ N\ +\ M) $ について左から $ i $ 個のボールのうち白いものの個数を $ w_i $、黒いものの個数を $ b_i $ とおいたとき、全ての $ i $ について $ w_i\ \leq\ b_i\ +\ K $ が成り立つ。

ただし、答えは非常に大きくなることがあるので、$ (10^9\ +\ 7) $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 0\ \leq\ N,\ M\ \leq\ 10^6 $
- $ 1\ \leq\ N\ +\ M $
- $ 0\ \leq\ K\ \leq\ N $
- 入力は全て整数である。

### Sample Explanation 1

白いボール $ 2 $ 個と黒いボール $ 3 $ 個を並べる方法は $ 10 $ 通りあり、白いボールを `w`、黒いボールを `b` で表すと以下のようになります。 `wwbbb` `wbwbb` `wbbwb` `wbbbw` `bwwbb` `bwbwb` `bwbbw` `bbwwb` `bbwbw` `bbbww` このうち、条件を満たさないのは `wwbbb` のみです。左から $ 2 $ 個のボールのうち白いものは $ 2 $ 個、黒いものは $ 0 $ 個ありますが、$ 2\ >\ 0\ +\ K\ =\ 1 $ となっています。

### Sample Explanation 2

条件を満たす並べ方が存在しないこともあります。

### Sample Explanation 3

$ (10^9\ +\ 7) $ で割ったあまりを出力することに注意してください。

## 样例 #1

### 输入

```
2 3 1```

### 输出

```
9```

## 样例 #2

### 输入

```
1 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
1000000 1000000 1000000```

### 输出

```
192151600```

# AI分析结果


# 💡 Kay的C++算法解析：White and Black Balls 深入学习指南 💡

今天我们来分析「White and Black Balls」这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`组合数学（反射原理）`

🗣️ **初步分析**：
> 解决这道题的关键在于运用组合数学中的反射原理。就像在经典游戏"走迷宫"中寻找不碰壁的路径，我们将白球视为向上移动（y+1），黑球视为向右移动（x+1），要求路径不能穿过"警戒线"y=x+K+1（否则违反条件）。
   - 核心思路：总排列数 = C(n+m, m)，减去不合法方案数（首次碰到警戒线后的路径反射计算）。
   - 算法流程：1) 特判n>m+k时无解；2) 预处理阶乘和逆元；3) 计算组合数C(n+m, m) - C(n+m, m+k+1)。
   - 可视化设计：在8位像素网格中，绿色路径代表合法方案，红色路径代表触碰警戒线的不合法方案，反射动画展示路径对称过程（伴随"铛"音效），终点宝藏金光表示解题成功。

---

## 2. 精选优质题解参考

<eval_intro>
以下题解在思路清晰度、代码规范性和算法效率等方面表现优异（评分≥4星）：
</eval_intro>

**题解一（来源：xiaoPanda）**
* **点评**：通过网格图直观解释反射原理，图示辅助理解。代码采用结构体封装组合数计算（阶乘+逆元预处理），变量命名规范（fac/inv），边界处理严谨（C函数检查n<m）。时间复杂度O(n+m)，可直接用于竞赛。

**题解二（来源：Zimo_666）**
* **点评**：将条件转化为b_i-w_i≥-k的几何约束，推导简洁。代码结构清晰，使用(负数+mod)%mod技巧避免负值。虽反射过程解释稍简，但代码实现完整可靠。

**题解三（来源：一只小咕咕）**
* **点评**：提供独特的代数视角（颜色反转证明），避开几何路径。命名空间封装组合数计算，思路新颖。注意：多次快速幂求逆元效率略低于逆元数组预处理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的三个关键难点及应对策略：
</difficulty_intro>

1.  **关键点：问题转化为路径模型**
    * **分析**：如何将排列条件抽象为网格路径？优质题解将白球/黑球映射为向上/向右移动，约束条件转化为y≤x+K的路径限制（警戒线y=x+K+1）。
    * 💡 **学习笔记**：计数问题→路径模型是组合数学的常用技巧，核心是找到决策的几何意义。

2.  **关键点：反射原理的应用**
    * **分析**：如何计算不穿过警戒线的路径？反射原理将首次碰线后的路径关于y=x+K+1对称，新起点(-K-1,K+1)到终点(n,m)的路径数即为非法方案数。
    * 💡 **学习笔记**：反射原理通过边界对称转换，将复杂约束转化为可计算路径。

3.  **关键点：组合数优化与边界处理**
    * **分析**：大组合数计算需预处理阶乘+逆元（O(n)预处理，O(1)查询）。注意特判n>m+K时无解，以及结果可能为负需(mod+ans)%mod。
    * 💡 **学习笔记**：模运算中处理负数：(a-b+mod)%mod。

### ✨ 解题技巧总结
<summary_best_practices>
通用解题技巧：
</summary_best_practices>
-   **技巧A（问题建模）**：将抽象约束转化为几何路径或序列变换（如本题的网格行走）。
-   **技巧B（反射原理）**：路径带边界限制时，用反射原理转换非法方案。
-   **技巧C（组合数优化）**：预处理阶乘+逆元数组实现O(1)组合数查询。
-   **技巧D（边界特判）**：先检查边界条件（如n>m+K）避免无效计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
通用核心实现（综合优质题解）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合最优实现，包含特判、组合数预处理和负数取模处理。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
const int N = 2e6;

long long fac[N+5], inv[N+5];

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void init() {
    fac[0] = 1;
    for (int i = 1; i <= N; i++) 
        fac[i] = fac[i-1] * i % mod;
    inv[N] = qpow(fac[N], mod-2);
    for (int i = N-1; i >= 0; i--) 
        inv[i] = inv[i+1] * (i+1) % mod;
}

long long C(int n, int m) {
    if (n < m || m < 0) return 0;
    return fac[n] * inv[m] % mod * inv[n-m] % mod;
}

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    if (n > m + k) {
        cout << 0;
        return 0;
    }
    init();
    long long ans = (C(n+m, m) - C(n+m, m+k+1) + mod) % mod;
    cout << ans;
}
```
* **代码解读概要**：
> 1. 特判n>m+k直接输出0；2. 预处理阶乘(fac)和逆元(inv)；3. 组合数函数C(n,m)处理边界；4. 答案公式：C(n+m,m)-C(n+m,m+k+1)，加mod防负。

---
<code_intro_selected>
优质题解核心代码亮点分析：
</code_intro_selected>

**题解一（xiaoPanda）**
* **亮点**：结构体封装组合数计算，高内聚低耦合
* **核心代码片段**：
```cpp
struct CombCalc {
    int mod=1e9+7, fac[N], inv[N];
    int qpow(int a, int b) { /* 快速幂 */ }
    void init(int len) { 
        fac[0]=1;
        for(int i=1;i<=len;i++) fac[i]=fac[i-1]*i%mod;
        inv[len]=qpow(fac[len],mod-2);
        for(int i=len;i;i--) inv[i-1]=inv[i]*i%mod;
    }
    int C(int n,int m) {
        return n>=m? fac[n]*inv[m]%mod*inv[n-m]%mod : 0;
    }
} comb;
```
* **代码解读**：
> 通过结构体整合阶乘/逆元/组合数函数，避免全局变量污染。init函数先算阶乘，再用费马小定理求逆元（O(n)）。为什么用递推求逆元？因为inv[i]=1/fac[i]%mod，而inv[i-1]=inv[i]*i%mod可递推。
* 💡 **学习笔记**：模块化封装提升代码复用性。

**题解二（Zimo_666）**
* **亮点**：简洁的负数取模处理
* **核心代码片段**：
```cpp
int ans = comb.C(n+m, m) - comb.C(n+m, m+k+1);
ans = (ans + mod) % mod;  // 关键：防止负数
```
* **代码解读**：
> 当组合数差为负时，直接取模会出错。为什么加mod？因为模运算中a-b≡(a-b+mod)%mod。例如(-5)%7=2，而(-5+7)%7=2。
* 💡 **学习笔记**：模减法必加模数再取模。

**题解三（一只小咕咕）**
* **亮点**：命名空间封装+快速幂求逆元
* **核心代码片段**：
```cpp
int C(int n,int m) {
    return n>=m? fac[n]*ksm(fac[m],mod-2)%mod*ksm(fac[n-m],mod-2)%mod : 0;
}
```
* **代码解读**：
> 使用ksm(fac[m],mod-2)代替逆元数组，适合组合数调用次数少的场景。为什么mod-2？根据费马小定理，a^{mod-2}是a的逆元。注意：多次调用时效率低于逆元数组。
* 💡 **学习笔记**：小规模问题可用快速幂求逆元，大规模推荐逆元数组。

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素化路径探索游戏**：通过8位机风格动画理解反射原理
</visualization_intro>

* **主题**：像素探险家寻宝（FC红白机风格）
* **核心演示**：合法路径（绿）避让警戒线，非法路径（红）触发反射

* **设计思路**：  
  > 警戒线(y=x+K+1)用闪烁红砖表示，路径移动音效强化操作反馈，反射动画帮助理解组合数公式的几何意义。

* **动画步骤**：
  1. **场景初始化**：  
     - 网格坐标：白球→上移（↑），黑球→右移（→）
     - 起点(0,0)：像素小人（▲），终点(n,m)：宝藏箱（★）
     - 控制面板：开始/暂停/单步/速度条

  2. **路径演示**：  
     - 每步移动播放"嘀"声，当前块高亮
     - **警戒检测**：当y-x>K时（触碰红砖），触发：
        * 播放"铛！"音效，路径变红
        * 反射动画：剩余路径关于红线对称（黄线）
        * 显示新起点(-K-1,K+1)

  3. **AI演示模式**：  
     - 自动播放多条路径（合法/非法）
     - 速度滑块控制演示速度
     - 成功到达宝藏：播放胜利音效+金币动画

  4. **信息面板**：  
     - 实时显示：步数、w_i/b_i值
     - 公式高亮：C(n+m,m) - C(n+m,m+k+1)

* **技术实现**：  
  Canvas绘制网格/路径，Web Audio API添加音效，反射路径通过坐标变换实现（原路径点(x,y)→反射点(y-K-1, x+K+1)）

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
反射原理的迁移应用：
</similar_problems_intro>

1. **洛谷 P1641 [SCOI2010] 生成字符串**  
   → 类似本题K=0的情况，卡特兰数经典应用
2. **洛谷 P2532 [AHOI2012] 树屋阶梯**  
   → 卡特兰数+质因数分解求组合数
3. **洛谷 P2567 [SCOI2010] 幸运数字**  
   → 组合数学+容斥原理的综合训练

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验：
</insights_intro>

> **经验（来源：出言不逊王子）**：  
> "调试时发现反射坐标计算错误，通过小样例(n=2,m=3,k=1)验证发现组合数差≠9，最终修正对称公式"

> **Kay点评**：  
> 验证小样例是调试组合数学问题的黄金法则，建议用n≤3的用例手工计算验证。

---

<conclusion>
通过本指南，大家应掌握了反射原理的核心思想和实现技巧。记住：将问题转化为几何模型是打开组合计数之门的钥匙！下次见~ ✨
</conclusion>

---
处理用时：376.48秒
# 题目信息

# [ABC314G] Amulets

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc314/tasks/abc314_g

洞窟に、モンスター $ 1 $ 、モンスター $ 2 $ 、$ \ldots $ 、モンスター $ N $ の $ N $ 体のモンスターがおり、各モンスターには正整数の**攻撃力**と、$ 1 $ 以上 $ M $ 以下の整数で表される**タイプ**が定められています。 具体的には、$ i\ =\ 1,\ 2,\ \ldots,\ N $ について、モンスター $ i $ の攻撃力は $ A_i $ でタイプは $ B_i $ です。

高橋君はお守り $ 1 $ 、お守り $ 2 $ 、$ \ldots $ 、お守り $ M $ の $ M $ 個のお守りのうちのいくつかを持って、**体力**が $ H $ の状態でこの洞窟に冒険に出かけます。

冒険では高橋君は（体力が $ 0 $ 以下になって力尽きない限り）$ i\ =\ 1,\ 2,\ \ldots,\ N $ の順に下記の手順を行います。

- もし高橋君がお守り $ B_i $ を冒険に持ってきていないなら、高橋君はモンスター $ i $ の攻撃を受け、高橋君の体力が $ A_i $ だけ減少する。
- その後の時点での高橋君の体力が、
  - $ 0 $ より大きいならば、高橋君はモンスター $ i $ を倒す。
  - $ 0 $ 以下ならば、高橋君はモンスター $ i $ を倒せずに力尽きて冒険を終了する。

$ K\ =\ 0,\ 1,\ \ldots,\ M $ のそれぞれの場合について独立に、下記の問題を解いてください。

> 高橋君が全 $ M $ 個のお守りの中から $ K $ 個を選んで冒険に持っていくときの、高橋君が倒すモンスターの数としてあり得る最大値を求めよ。

なお、任意の $ i\ =\ 1,\ 2,\ \ldots,\ M $ について、タイプが $ i $ であるモンスターが必ず $ 1 $ 体以上いることが、制約として保証されます。

## 说明/提示

### 制約

- $ 1\ \leq\ M\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ H\ \leq\ 10^9 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ M $
- 任意の $ 1\ \leq\ i\ \leq\ M $ に対して、ある $ 1\ \leq\ j\ \leq\ N $ が存在して $ B_j\ =\ i $ が成り立つ
- 入力はすべて整数

### Sample Explanation 1

$ K\ =\ 1 $ の問題を考えます。この場合、高橋君はお守り $ 2 $ を持っていくことで、$ 5 $ 体のモンスターを倒し、倒すモンスターの数の最大値を達成することができます。 その際の冒険は、下記の通りに進行します。 - $ i\ =\ 1 $ について、高橋君はお守り $ 2 $ を持っているため、モンスター $ 1 $ の攻撃を免れます。その後、高橋君はモンスター $ 1 $ を倒します。 - $ i\ =\ 2 $ について、高橋君はお守り $ 1 $ を持っていないため、モンスター $ 2 $ の攻撃を受けて体力が $ 6 $ になります。その後、高橋君はモンスター $ 2 $ を倒します。 - $ i\ =\ 3 $ について、高橋君はお守り $ 2 $ を持っているため、モンスター $ 3 $ の攻撃を免れます。その後、高橋君はモンスター $ 3 $ を倒します。 - $ i\ =\ 4 $ について、高橋君はお守り $ 2 $ を持っているため、モンスター $ 4 $ の攻撃を免れます。その後、高橋君はモンスター $ 4 $ を倒します。 - $ i\ =\ 5 $ について、高橋君はお守り $ 1 $ を持っていないため、モンスター $ 5 $ の攻撃を受けて体力が $ 1 $ になります。その後、高橋君はモンスター $ 5 $ を倒します。 - $ i\ =\ 6 $ について、高橋君はお守り $ 3 $ を持っていないため、モンスター $ 6 $ の攻撃を受けて体力が $ -8 $ になります。その後、高橋君はモンスター $ 6 $ を倒せずに力尽きて冒険を終了します。 同様に、$ K\ =\ 0 $ の場合は $ 2 $ 体のモンスターを、 $ K\ =\ 2 $ の場合はお守り $ 2,\ 3 $ を持っていくことで $ 7 $ 体のモンスター全てを、 $ K\ =\ 3 $ の場合はお守り $ 1,\ 2,\ 3 $ を持っていくことで $ 7 $ 体のモンスター全てを倒すことができます。

## 样例 #1

### 输入

```
7 3 7
3 2
1 1
4 2
1 2
5 1
9 3
2 3```

### 输出

```
2 5 7 7```

## 样例 #2

### 输入

```
15 5 400
29 5
27 4
79 1
27 2
30 3
4 1
89 2
88 3
75 5
3 1
39 4
12 1
62 4
38 2
49 1```

### 输出

```
8 12 15 15 15 15```

# AI分析结果


### 💡 Kay的C++算法解析：ABC314G Amulets 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：贪心 + 数据结构优化（堆/平衡树）

🗣️ **初步分析**：
> 解决本题的关键在于**动态维护怪物类型伤害值**并**贪心选择最优护身符**。想象你在玩一款地牢探险游戏，每个怪物是不同颜色的陷阱（类型），护身符是相应颜色的防护罩。贪心策略即优先用护身符抵挡总伤害最高的陷阱类型（相当于消除"大BOSS陷阱"）。
> - **核心流程**：遍历洞穴时动态更新各类型总伤害，用数据结构快速计算前K大伤害和。若剩余伤害（总伤害 - 前K大伤害）< H则存活
> - **可视化设计**：像素地牢中高亮当前洞穴和伤害值变化，堆结构用升降方块动态展示。当血条≤0时触发"Game Over"像素动画
> - **复古元素**：8-bit音效（伤害生效="哔"声，护符生效="叮"声），自动演示如AI玩贪吃蛇逐步通关

---

#### 2. 精选优质题解参考
**题解一（lvvd：对顶堆解法）**
* **点评**：思路清晰揭示贪心本质（优先抵挡高伤类型），代码用`priority_queue`实现大小堆维护伤害值。亮点在时间复杂度优化至O(N log M)，实践价值高（可直接用于竞赛）。变量名`sum`（总伤害）、`lst`（已抵挡伤害）直白易读，边界处理严谨。

**题解二（Minuswy：set解法）**
* **点评**：用`set`优雅维护伤害值集合，通过比较堆顶实现贪心选择。亮点在代码简洁（<50行核心逻辑），解释中强调"问题转换"（求最少护身符数量），变量`S`（已选集合)、`T`（未选集合)命名规范体现数据结构思想。

**题解三（Exp10re：平衡树解法）**
* **点评**：提供通用数据结构解法，亮点在平衡树支持动态查询前K大和。代码模块化（分离插入/删除/查询），实践时需注意平衡树实现复杂度，但为大型数据提供可靠方案。

---

#### 3. 核心难点辨析与解题策略
1. **动态维护类型伤害值**
   * **分析**：新增怪物需更新同类历史伤害，在数据结构中删除旧值插入新值。优质解用`map`或数组`c[]`跟踪类型伤害
   * 💡 **学习笔记**：伤害更新=删除旧节点+插入新节点

2. **贪心选择护身符类型**
   * **分析**：K个护身符应抵挡当前前K大伤害类型。对顶堆中：小堆存已选伤害值（堆顶为最小伤害），大堆存未选伤害值（堆顶为最大伤害）
   * 💡 **学习笔记**：新伤害值若>小堆顶则加入"已选集合"，否则归入"待选集合"

3. **双指针优化枚举过程**
   * **分析**：怪物数i↑时，所需护身符K不会↓。利用单调性以单次扫描替代二分
   * 💡 **学习笔记**：当`总伤害-已选伤害≥H`时增加K，否则i++

### ✨ 解题技巧总结
- **技巧1 问题转换**：将"带K护身符能过几关"转为"过i关需多少护身符"
- **技巧2 贪心选择**：总是消除当前最高威胁（前K大伤害和）
- **技巧3 数据结构匹配**：动态查询前K大值优先选堆（O(1)取最值），平衡树适用更复杂操作

---

#### 4. C++核心代码实现赏析
**通用核心实现（基于set解法）**
```cpp
#include <set>
using namespace std;
const int N=3e5+10;
int n,m,H,cnt,ans[N];
long long sum,sum_delay; // 总伤害/已抵挡伤害
int damage[N],type[N];   // 类型伤害值/怪物类型
set<pair<int,int>> S,T;  // S=已选集合(伤害,类型) T=未选集合

int main(){
    cin>>n>>m>>H;
    for(int i=1;i<=n;i++) cin>>damage[i]>>type[i];
    
    // 初始化：所有类型伤害=0
    for(int i=1;i<=m;i++) S.insert({0,i});
    T.insert({1e9,0}); // 哨兵值

    int K=0;
    for(int i=1;i<=n;i++){
        // 1. 删除旧值
        auto it=S.find({damage[type[i]],type[i]});
        if(it!=S.end()){ 
            sum_delay -= it->first;
            S.erase(it);
        } else T.erase({damage[type[i]],type[i]});
        
        // 2. 更新伤害并插入新值
        damage[type[i]] += damage[i];
        pair<int,int> p = {damage[type[i]],type[i]};
        if(p < *T.begin()){ // 新值应加入S
            S.insert(p);
            sum_delay += p.first;
        } else T.insert(p);
        
        // 3. 动态调整集合
        while(sum_delay + damage[i] >= H && K<=m){
            ans[K]=i-1;
            auto mx = *T.begin();
            sum_delay += mx.first;
            S.insert(mx);
            T.erase(mx);
            K++;
        }
    }
    for(int i=0;i<=m;i++) cout<<ans[i]<<" ";
}
```
**代码解读概要**：
> 核心分三步：①删除该类型旧伤害值 ②新增伤害并判断归属集合 ③当受到伤害≥H时增加K值。S/T集合确保始终选择当前最优护身符

**题解一片段（对顶堆调整）**
```cpp
// 维护大小堆平衡
while(sum_delay >= H){
    auto it = S.end(); it--;
    T.insert(*it);         // 大堆插入当前最大伤害
    sum_delay -= it->first;
    S.erase(it);           // 从小堆移除
    K++;                   // 需更多护身符
}
```
**学习笔记**：当累计伤害超标时，将小堆中**最小伤害值**移回大堆体现贪心回溯

---

#### 5. 算法可视化：像素动画演示
* **主题**："8-bit地牢守护者" - 高桥君是像素勇者，护身符为漂浮盾牌
* **核心演示**：实时显示双堆结构和血条变化

| 步骤                | 像素动画设计                                                                 | 交互与音效                     |
|---------------------|-----------------------------------------------------------------------------|------------------------------|
| 1. 初始化地牢       | 洞穴排成直线，怪物用颜色区分类型（红/蓝/绿）                                  | 背景音乐：8-bit冒险主题         |
| 2. 怪物出现         | 当前洞穴高亮闪烁，显示伤害值A_i                                              | "哔！"音效                    |
| 3. 更新伤害         | 同色怪物头顶冒出"+A_i"像素字，旧伤害值爆炸消失                                | 盾牌碰撞"锵"声                |
| 4. 堆结构调整       | 小堆（已选）在上方排列为盾牌，大堆（未选）在下方。数值变动时盾牌升降          | 调整时播放齿轮转动音效          |
| 5. 血条危机         | 当`剩余伤害≥H`时血条变红闪烁，触发K+1机制                                    | 警告音效                      |
| 6. 结局             | 通关：勇者到达终点放烟花；失败：像素勇者倒地变墓碑                            | 胜利/失败音效                 |

**技术实现**：Canvas绘制洞穴网格+动态盾牌，音效用Web Audio API

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：
  1. 动态维护前K大值 → 实时排行榜（P3960 列队）
  2. 伤害值累计与消除 → 带限制的资源分配（P4097 计算几何）
  3. 双指针扫描优化 → 区间单调性问题（P3514 舞会）

* **洛谷推荐**：
  1. **P1801 黑匣子**  
     🗣️ 对顶堆裸题，巩固动态中位数
  2. **P3834 可持久化线段树**  
     🗣️ 学习前K大查询的通用数据结构
  3. **P2827 蚯蚓**  
     🗣️ 双堆维护单调性，强化问题转换能力

---

#### 7. 学习心得与经验分享
> **lvvd经验**："对顶堆实现时要注意先检查元素在哪个堆中再操作，否则会破坏堆结构"  
> **Kay点评**：数据结构操作需严格遵循"查→删→增"顺序，建议用辅助数组`inHeap[]`跟踪元素位置

> **Minuswy调试教训**："未初始化哨兵值导致集合比较崩溃"  
> **Kay总结**：边界处理是代码健壮性核心，永远预设无效值（如`T.insert({inf,0})`）

---

本次解析结束！用像素勇者的精神征服算法吧！🎮 关键还是掌握"贪心+数据结构"的解题范式，遇到类似问题可尝试先画状态转移图哦~

---
处理用时：156.16秒
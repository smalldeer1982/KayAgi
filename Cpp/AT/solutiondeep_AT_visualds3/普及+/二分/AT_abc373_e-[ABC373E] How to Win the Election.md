# 题目信息

# [ABC373E] How to Win the Election

## 题目描述

现在正在举行一场选举，有 $N$ 位候选人，编号为 $1, 2, \ldots, N$。目前已经有 $K$ 张选票，其中一些已经被计入。

到目前为止，第 $i$ 位候选人已经获得了 $A_i$ 票。

在所有选票被计完后，如果某位候选人的得票数比他们多的候选人数少于 $M$，那么该候选人将被当选。可能会有多位候选人同时当选。

对于每个候选人，求出他们需要从剩余的选票中获得的最少票数，以确保无论其他候选人获得多少票，他们都能当选。

具体来说，对于每个 $i = 1, 2, \ldots, N$，解决以下问题：

确定是否存在一个非负整数 $X$，其不超过 $K - \displaystyle{\sum_{i=1}^{N}} A_i$，并满足以下条件。如果存在，找出满足条件的最小 $X$。

- 如果候选人 $i$ 获得了 $X$ 张额外选票，那么候选人 $i$ 将始终当选。

## 说明/提示

- $1 \leq M \leq N \leq 2 \times 10^5$。
- $1 \leq K \leq 10^{12}$。
- $0 \leq A_i \leq 10^{12}$。
- $\displaystyle{\sum_{i=1}^{N} A_i} \leq K$。

## 样例 #1

### 输入

```
5 2 16
3 1 4 1 5```

### 输出

```
2 -1 1 -1 0```

## 样例 #2

### 输入

```
12 1 570
81 62 17 5 5 86 15 7 79 26 6 28```

### 输出

```
79 89 111 117 117 74 112 116 80 107 117 106```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC373E] How to Win the Election 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案 + 贪心策略（结合前缀和优化）


🗣️ **初步分析**：  
解决“如何确保候选人当选”的问题，关键在于**二分答案**（Binary Search）与**贪心检查**（Greedy Check）的结合。简单来说，二分答案就像“试穿鞋子”——我们猜测一个候选的额外票数`mid`，然后检查这个`mid`是否足够让候选人“稳赢”；而贪心检查则是“模拟最坏情况”——假设剩下的票都用来让最容易超过他的对手尽可能多的超过他，看是否能挡住这些对手。  

### 核心逻辑拆解：
1. **二分答案**：对于每个候选人`i`，我们二分他需要的额外票数`X`（范围从0到剩余总票数）。`X`越大，候选人越容易当选，因此具有单调性。  
2. **贪心检查**：假设给`i`加`mid`票后，他的总票数为`a[i]+mid`。我们需要计算：**在最坏情况下（剩下的票都用来让对手超过他），是否无法让至少`M`个对手的票数超过他**。如果无法让`M`个对手超过，说明`mid`可行，需要找更小的`X`；否则需要增大`X`。  

### 可视化设计思路：
- **像素风格**：采用FC红白机的8位像素风，用不同颜色标记候选人（比如当前处理的候选人用红色，对手用蓝色，已超过的用绿色）。  
- **关键步骤高亮**：二分`mid`时，用闪烁的数字显示当前猜测的`mid`；检查时，用箭头指向需要计算的对手区间，用进度条显示所需票数与剩余票数的对比。  
- **游戏化元素**：加入“叮”的音效（二分调整时）、“胜利”音效（check成功时）、“失败”音效（check失败时），让学习更有趣。  


## 2. 精选优质题解参考

### 题解一：（来源：dayz_break404，赞：10）
* **点评**：  
  这份题解的思路非常清晰，完美体现了“二分+贪心”的核心逻辑。作者首先对数组排序并预处理前缀和，为快速计算区间和奠定基础。在`check`函数中，作者巧妙地处理了“当前候选人是否在需要考虑的对手集合中”的情况（比如调整区间左端点），避免了错误。代码风格规范（变量名如`sum`、`x`、`y`含义明确），边界处理严谨（比如特判`N==M`的情况），是一份非常值得参考的实现。  

### 题解二：（来源：SkyWave，赞：0）
* **点评**：  
  作者对`check`函数的推导非常详细，将贪心策略转化为数学式子（`(P - N - M + 1) * (A_i + mid + 1) - 前缀和`），让逻辑更直观。此外，作者特判了`N==M`的情况，避免了数组越界的问题。虽然代码简洁，但每一步都有明确的逻辑支撑，适合理解“贪心检查”的本质。  

### 题解三：（来源：HasNoName，赞：2）
* **点评**：  
  作者采用“从大到小排序”的方式，简化了对手集合的选择（直接考虑前`M`名对手）。这种排序方式让“最容易超过当前候选人的对手”更直观，适合初学者理解。代码中的`ok`函数处理了“让对手超过当前候选人”的所需票数，逻辑清晰，是一份不错的入门级实现。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何设计`check`函数？**  
- **分析**：`check`函数的核心是“模拟最坏情况”——计算让`M`个对手超过当前候选人所需的最少票数。为了最小化所需票数，应选择**当前票数最接近`a[i]+mid`的对手**（因为他们只需要很少的票就能超过）。通过排序数组和前缀和，可以快速计算这些对手的总票数，进而求出所需票数。  
- 💡 **学习笔记**：贪心策略的关键是“选最容易满足条件的对象”，这里的“容易”指“需要的票数最少”。  

### 2. **难点2：如何处理当前候选人在对手集合中的情况？**  
- **分析**：当数组排序后，当前候选人的票数可能位于需要考虑的对手区间内（比如`a[i]`在排序后的数组中属于前`M`名）。此时，需要调整区间（比如左端点左移一位），并减去当前候选人的贡献（因为他不能算自己的对手）。  
- 💡 **学习笔记**：处理边界情况时，要仔细检查“是否包含当前元素”，避免重复计算或遗漏。  

### 3. **难点3：如何优化区间和的计算？**  
- **分析**：计算区间和时，直接遍历会导致`O(N)`的时间复杂度，无法通过大规模数据。预处理前缀和后，可以将区间和的计算优化到`O(1)`，这是解决本题的关键优化点。  
- 💡 **学习笔记**：前缀和是处理区间和问题的常用工具，能大大提高计算效率。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了优质题解的思路，采用“二分答案+贪心检查+前缀和”的框架，结构清晰，适合初学者理解。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  typedef long long ll;
  
  int main() {
      int n, m;
      ll k;
      cin >> n >> m >> k;
      vector<ll> a(n), b(n);
      ll sum_a = 0;
      for (int i = 0; i < n; ++i) {
          cin >> a[i];
          b[i] = a[i];
          sum_a += a[i];
      }
      ll rem = k - sum_a; // 剩余票数
      sort(b.begin(), b.end());
      vector<ll> pre(n + 1, 0);
      for (int i = 0; i < n; ++i) {
          pre[i + 1] = pre[i] + b[i];
      }
      
      for (int i = 0; i < n; ++i) {
          ll l = 0, r = rem;
          ll ans = -1;
          while (l <= r) {
              ll mid = (l + r) / 2;
              ll tar = a[i] + mid;
              // 找到第一个大于tar的位置
              int pos = upper_bound(b.begin(), b.end(), tar) - b.begin();
              int need = m - (n - pos); // 需要额外让need个对手超过tar
              if (need <= 0) {
                  ans = mid;
                  r = mid - 1;
                  continue;
              }
              // 选择前need个最接近tar的对手（即b[pos-need ... pos-1]）
              int L = pos - need;
              if (L < 0) {
                  ans = mid;
                  r = mid - 1;
                  continue;
              }
              // 计算让这些对手达到tar+1所需的票数
              ll required = (tar + 1) * need - (pre[pos] - pre[L]);
              // 检查是否包含当前候选人a[i]（需要调整）
              bool has_i = (binary_search(b.begin() + L, b.begin() + pos, a[i]));
              if (has_i) {
                  required -= (tar + 1 - a[i]); // 减去当前候选人的贡献
                  need -= 1;
                  if (need == 0) {
                      ans = mid;
                      r = mid - 1;
                      continue;
                  }
                  L -= 1;
                  if (L < 0) {
                      ans = mid;
                      r = mid - 1;
                      continue;
                  }
                  required += (tar + 1 - b[L]); // 加上新的对手的贡献
              }
              if (required <= rem - mid) {
                  l = mid + 1;
              } else {
                  ans = mid;
                  r = mid - 1;
              }
          }
          cout << (ans == -1 ? -1 : ans) << " ";
      }
      cout << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  代码首先读取输入并计算剩余票数，然后排序数组并预处理前缀和。对于每个候选人，二分他需要的额外票数`mid`，然后通过`upper_bound`找到需要考虑的对手区间，计算让这些对手超过他所需的票数，判断是否可行。  


### 题解一（dayz_break404）亮点片段
* **亮点**：处理“当前候选人在对手集合中”的情况。  
* **核心代码片段**：  
  ```cpp
  if (a[y] > b[id]) {
      return 1ll * (x - y + 1) * (b[id] + mid + 1) - (sum[x] - sum[y - 1]) > now;
  }
  return 1ll * (x - y + 1) * (b[id] + mid + 1) - (sum[x] - sum[y - 2] - b[id]) > now;
  ```
* **代码解读**：  
  当`a[y] > b[id]`时，说明对手区间不包含当前候选人，直接计算区间和；否则，需要减去当前候选人的贡献（`sum[y-2] + b[id]`），调整区间左端点。  
* 💡 **学习笔记**：处理包含当前元素的情况时，要仔细调整区间和的计算。  


### 题解二（SkyWave）亮点片段
* **亮点**：将贪心策略转化为数学式子。  
* **核心代码片段**：  
  ```cpp
  int idx = (int)(lower_bound(b + n - m + 1, b + n + 1, tar) - b - 1);
  return 1ll * (idx - (n - m)) * tar - (pre[idx] - pre[n - m]) > rem - mid;
  ```
* **代码解读**：  
  计算让前`m`个对手中，票数≤`tar`的人达到`tar+1`所需的票数。通过`lower_bound`找到分界线，用前缀和快速计算区间和。  
* 💡 **学习笔记**：数学式子能让贪心策略更直观，减少代码的复杂性。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《选举保卫战》（8位像素风）
- **场景**：屏幕左侧显示排序后的候选人列表（蓝色像素块，数值为当前票数），右侧显示当前处理的候选人（红色像素块，数值为`a[i]+mid`）。  
- **核心演示内容**：  
  1. **二分初始化**：屏幕顶部显示二分的`l`（0）和`r`（剩余票数），中间显示当前猜测的`mid`（闪烁的数字）。  
  2. **check过程**：  
     - 用箭头指向排序后的数组，标记需要考虑的对手区间（比如`b[pos-need ... pos-1]`）。  
     - 用进度条显示所需票数（`required`）与剩余票数（`rem-mid`）的对比：如果进度条满，说明`mid`不可行（需要增大`mid`）；否则可行（需要减小`mid`）。  
  3. **结果展示**：当二分结束时，显示当前候选人的最小`X`（绿色数字），并播放“胜利”音效。  

### 游戏化元素：
- **音效**：二分调整时播放“叮”的音效，check成功时播放“胜利”音效（上扬的8位音调），check失败时播放“失败”音效（短促的 buzzer 声）。  
- **关卡设计**：将每个候选人的处理视为一个“关卡”，完成一个关卡后显示“关卡完成”的动画（比如像素星星闪烁），并给予“积分”奖励（比如每完成一个关卡得10分）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：
- **二分答案**：适用于“求最小满足条件的值”的问题，比如“砍树的最小高度”（P1873）、“跳石头的最小距离”（P2678）。  
- **贪心检查**：适用于“模拟最坏情况”的问题，比如“安排会议的最小房间数”（P2404）、“最大子数组和”（P1115）。  
- **前缀和优化**：适用于“区间和计算”的问题，比如“子数组和等于k的数目”（P5603）、“二维前缀和”（P1387）。  

### 练习推荐（洛谷）：
1. **洛谷 P1873** - 《砍树》  
   🗣️ **推荐理由**：这道题是二分答案的经典问题，需要求最小的砍树高度，使得总木材量满足要求。与本题的“二分+贪心”思路类似，适合巩固二分答案的基础。  
2. **洛谷 P2678** - 《跳石头》  
   🗣️ **推荐理由**：这道题需要求最小的跳跃距离，使得移除的石头数不超过限制。与本题的“二分+检查”思路一致，适合练习贪心检查的设计。  
3. **洛谷 P3382** - 《三分法》  
   🗣️ **推荐理由**：虽然是三分法，但思路与二分类似，都是通过不断缩小范围找到最优解。适合拓展对“区间查找”的理解。  


## 7. 学习心得与经验分享（若有）
> **参考经验（来自dayz_break404）**：“我在解决这个问题时，最初没有处理‘当前候选人在对手集合中’的情况，导致测试点错误。后来通过打印中间变量，发现了这个问题，调整了区间和的计算方式。”  
> **点评**：这位作者的经验很典型。在编程过程中，**打印中间变量**是定位错误的有效方法。对于边界情况（比如包含当前元素），一定要仔细检查，避免遗漏。  


## 结语
本次关于“[ABC373E] How to Win the Election”的C++解题分析就到这里。希望这份学习指南能帮助大家理解“二分答案+贪心检查”的核心逻辑，掌握前缀和优化的技巧。记住，编程能力的提升在于**持续练习**和**深入思考**——多做类似问题，多总结思路，你一定会越来越厉害！💪  

如果有任何疑问，欢迎随时向我提问，我会尽力帮助你！😊

---
处理用时：145.15秒
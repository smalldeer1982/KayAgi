# 题目信息

# [ARC146B] Plus and AND

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc146/tasks/arc146_b

長さ $ N $ の非負整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。あなたは以下の操作を $ M $ 回以下行うことができます。($ 1 $ 回も行わなくてもよいです。)

- $ 1\ \le\ i\ \le\ N $ を満たす整数 $ i $ を選び、$ A_i $ を $ 1 $ 増やす。

その後、$ A $ の中から $ K $ 要素を選びます。

選んだ $ K $ 要素のビット単位 $ \mathrm{AND} $ の最大値を求めてください。

  ビット単位 $ \mathrm{AND} $ 演算とは  整数 $ A,\ B $ のビット単位 $ \mathrm{AND} $、$ A\ \mathrm{AND}\ B $ は以下のように定義されます。

- $ A\ \mathrm{AND}\ B $ を二進表記した際の $ 2^k $ ($ k\ \geq\ 0 $) の位の数は、$ A,\ B $ を二進表記した際の $ 2^k $ の位の数のうち両方が $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。
 
 例えば、$ 3\ \mathrm{AND}\ 5\ =\ 1 $ となります (二進表記すると: $ 011\ \mathrm{AND}\ 101\ =\ 001 $)。  
 一般に $ k $ 個の整数 $ p_1,\ p_2,\ p_3,\ \dots,\ p_k $ のビット単位 $ \mathrm{AND} $ は $ (\dots\ ((p_1\ \mathrm{AND}\ p_2)\ \mathrm{AND}\ p_3)\ \mathrm{AND}\ \dots\ \mathrm{AND}\ p_k) $ と定義され、これは $ p_1,\ p_2,\ p_3,\ \dots\ p_k $ の順番によらないことが証明できます。 ​

## 说明/提示

### 制約

- $ 1\ \le\ K\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 0\ \le\ M\ <\ 2^{30} $
- $ 0\ \le\ A_i\ <\ 2^{30} $
- 入力は全て整数である。

### Sample Explanation 1

以下のような手順を踏むことで 選んだ $ 2 $ 要素の $ \mathrm{AND} $ として $ 10 $ を達成できます。 - $ A_3 $ を選ぶ操作を $ 6 $ 回行う。$ A_3\ =\ 10 $ となる。 - $ A_4 $ を選ぶ操作を $ 2 $ 回行う。$ A_4\ =\ 10 $ となる。 - $ A_3,A_4 $ を選ぶ。$ 2 $ 要素の $ \mathrm{AND} $ は $ 10 $ である。 選んだ $ 2 $ 要素の $ \mathrm{AND} $ を $ 11 $ 以上にすることはできないので、解は $ 10 $ です。

## 样例 #1

### 输入

```
4 8 2

1 2 4 8```

### 输出

```
10```

## 样例 #2

### 输入

```
5 345 3

111 192 421 390 229```

### 输出

```
461```

# AI分析结果



---
# 💡 Kay的C++算法解析：[Plus and AND] 深入学习指南 💡

<introduction>
今天我们要挑战的题目是「Plus and AND」。这道题需要我们通过有限次操作，从数组中选出K个数，使得它们的按位与值最大。别担心，我们一起拆解问题，用贪心策略一步步解决它！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（按位贪心）

🗣️ **初步分析**：
解决这道题的关键在于理解“按位贪心”的思想。贪心算法就像搭积木——先搭高的部分，因为高位的1对结果的贡献比所有低位的总和还要大（比如第i位的1相当于2^i，而所有低位加起来最多是2^i-1）。所以我们从最高位（比如第31位）开始，依次判断每一位是否能保留为1。

在本题中，按位贪心的具体应用是：对于每一位i（从高到低），计算将每个数的第i位变为1需要的最小操作次数（代价），然后选代价最小的前K个数。如果这些代价的总和不超过剩余的操作次数M，说明这一位可以保留，我们就将答案的这一位置为1，并消耗相应的操作次数，同时保留这些数继续处理低位；否则放弃这一位，继续处理更低的位。

核心算法流程的可视化设计思路：用像素动画展示每一位的处理过程。例如，每个数用一个像素块表示，每一位用不同颜色标记（如红色表示当前处理的位）。计算代价时，像素块上方显示需要的操作次数；排序时，像素块按代价从小到大排列；选前K个时，这些块会高亮（如绿色），并显示总代价是否≤M。若可行，这些块的当前位会被标记为1（颜色变亮），并保留下来继续处理低位。

复古游戏化元素：加入“位探险”主题，每处理一位相当于“闯一关”。成功保留一位时播放“叮”的音效，失败时播放“噗”的提示音，背景音乐采用8位风格的轻快旋律。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，用户提供的题解在思路清晰度、代码规范性、算法有效性等方面表现优秀（5星），值得重点学习。
</eval_intro>

**题解一：(来源：Phartial)**
* **点评**：这份题解的核心思路是按位贪心，从高位到低位依次确定每一位是否可行。思路非常清晰，利用“高位优先”的贪心策略，结合代价计算和排序选择，高效解决问题。代码规范，变量命名虽简洁但逻辑明确（如`b[j]`存储代价，`d[j]`存储索引用于排序），时间复杂度为O(32*N log N)，适合处理N=2e5的规模。关键是对每一步操作的处理（如更新数组、筛选保留数）非常严谨，是竞赛中的典型高效写法。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们需要重点突破以下三个关键点：
</difficulty_intro>

1.  **关键点1**：如何计算将某一位变为1的最小代价？
    * **分析**：对于数x，要让它的第i位变为1，需要计算需要加多少才能让该位为1。例如，x的二进制低i+1位是v（即x & ((1<<(i+1))-1)），如果v >= 2^i，说明该位已经是1，代价为0；否则需要加到2^i，代价是2^i - v。
    * 💡 **学习笔记**：代价计算的公式是`max(0, (1<<i) - (x & ((1<<(i+1))-1)))`，这一步是贪心的基础。

2.  **关键点2**：如何筛选保留哪些数？
    * **分析**：当某一位i被确定保留后，只有那些该位为1的数才能被后续选择（因为最终要选K个数的按位与，这些数的i位必须是1）。因此，处理完i位后，需要过滤掉该位为0的数，只保留该位为1的数继续处理低位。
    * 💡 **学习笔记**：筛选操作确保后续处理的数都是“候选者”，避免无效计算。

3.  **关键点3**：贪心策略的正确性如何保证？
    * **分析**：由于高位的1对结果的贡献远大于所有低位，因此优先确定高位是否可行是最优的。即使后续低位无法全部保留，高位的保留已经最大化了结果。
    * 💡 **学习笔记**：贪心的“局部最优导致全局最优”在这里成立，因为高位的优先级高于低位。

### ✨ 解题技巧总结
- **位运算拆解**：将问题拆解为每一位的独立判断，利用位运算的性质简化计算。
- **排序选前K小**：通过排序快速找到代价最小的前K个数，确保操作次数不超限。
- **逐步筛选**：每确定一位后，筛选保留有效数，减少后续计算量。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合题解思路的通用核心C++实现，逻辑清晰且高效，适合直接参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自Phartial的题解，采用按位贪心策略，逻辑简洁高效，是本题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <algorithm>
    #include <iostream>
    using namespace std;
    using LL = long long;

    const int kN = 2e5 + 1;
    int k, n, m, a[kN], b[kN], d[kN], ans, _a[kN];

    int main() {
        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
        cin >> n >> m >> k;
        for (int i = 1; i <= n; ++i) cin >> a[i];
        for (int i = 31; i >= 0 && n >= k; --i) {  // 从高位到低位处理
            for (int j = 1; j <= n; ++j) {
                d[j] = j;
                b[j] = max(0LL, (1LL << i) - (a[j] & ((1LL << (i + 1)) - 1)));  // 计算代价
            }
            sort(d + 1, d + n + 1, [](int i, int j) { return b[i] < b[j]; });  // 按代价排序
            LL s = 0;
            for (int j = 1; j <= k; ++j) s += b[d[j]];  // 前K小的代价和
            if (s <= m) {  // 可行，保留该位
                m -= s;
                ans |= 1 << i;  // 答案的第i位设为1
                for (int j = 1; j <= k; ++j) a[d[j]] += b[d[j]];  // 更新选中的数
                int _n = 0;
                for (int j = 1; j <= n; ++j)  // 筛选该位为1的数
                    if (a[j] >> i & 1) _a[++_n] = a[j];
                copy_n(_a + 1, n = _n, a + 1);  // 替换为筛选后的数组
            }
        }
        cout << ans;
        return 0;
    }
    ```
* **代码解读概要**：
  代码从最高位（31位）开始，逐位判断是否可以保留为1。对于每一位i：
  1. 计算每个数的代价（将第i位变为1所需的操作次数）；
  2. 按代价排序，选前K小的代价求和；
  3. 若总和≤M，保留该位，更新答案和数组（只保留该位为1的数）；
  4. 重复直到处理完所有位或剩余数不足K个。

---
<code_intro_selected>
下面重点分析题解中的核心代码片段，理解其关键逻辑。
</code_intro_selected>

**题解一：(来源：Phartial)**
* **亮点**：通过排序快速选前K小代价，筛选保留有效数，确保每一步操作高效。
* **核心代码片段**：
    ```cpp
    for (int i = 31; i >= 0 && n >= k; --i) {
        for (int j = 1; j <= n; ++j) {
            d[j] = j;
            b[j] = max(0LL, (1LL << i) - (a[j] & ((1LL << (i + 1)) - 1)));
        }
        sort(d + 1, d + n + 1, [](int i, int j) { return b[i] < b[j]; });
        LL s = 0;
        for (int j = 1; j <= k; ++j) s += b[d[j]];
        if (s <= m) {
            m -= s, ans |= 1 << i;
            for (int j = 1; j <= k; ++j) a[d[j]] += b[d[j]];
            int _n = 0;
            for (int j = 1; j <= n; ++j) 
                if (a[j] >> i & 1) _a[++_n] = a[j];
            copy_n(_a + 1, n = _n, a + 1);
        }
    }
    ```
* **代码解读**：
  - **代价计算**：`b[j]`计算将`a[j]`的第i位变为1的代价。例如，若`a[j]`的低i+1位是v，若v < 2^i，则需要加`2^i - v`；否则代价为0。
  - **排序选前K小**：通过`d[j]`存储索引，按`b[j]`从小到大排序，选前K个的代价和。
  - **更新答案与数组**：若代价和≤M，将答案的第i位设为1，更新选中的数（加上代价），并筛选出该位为1的数继续处理低位。
* 💡 **学习笔记**：按位贪心的核心是“高位优先”，每一步的筛选操作确保后续处理的数都是有效的候选者，避免无效计算。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解按位贪心的过程，我们设计了“位探险”像素动画，用8位风格展示每一位的处理！
</visualization_intro>

  * **动画演示主题**：像素小探险家的位冒险
  * **核心演示内容**：从最高位（31层）到最低位（0层），每一层代表一个二进制位。探险家需要判断是否能在这一层收集K个“1宝石”（即让K个数的该位为1），若成功则保留该层，继续下一层；否则放弃，继续下一层。
  * **设计思路简述**：8位像素风格营造复古游戏氛围，每一层的“收集宝石”操作对应算法中的代价计算和筛选，通过动画展示排序、选前K个、更新数等步骤，帮助理解贪心策略的每一步。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
       - 屏幕分为左右两部分：左边是“数字森林”（N个像素块，每个块显示数字的二进制，当前处理位用红色标记）；右边是“操作面板”（开始/暂停、单步、重置按钮，速度滑块）。
       - 播放8位风格的背景音乐（类似《超级玛丽》的轻快旋律）。
    2.  **当前位处理**：
       - 探险家进入第i层（当前处理位i），数字森林中每个像素块上方显示计算出的代价（如“+3”表示需要3次操作）。
       - 像素块按代价从小到大排列（排序动画：块从左到右滑动，按代价升序排列）。
       - 选前K个块（绿色高亮），显示总代价（如“总代价：8 ≤ M=8，成功！”），播放“叮”的音效。
       - 高亮的块上方弹出“+代价”动画（如块值从4变为10），同时它们的二进制第i位变为1（红色变亮）。
    3.  **筛选保留数**：
       - 未被选中的块（该位仍为0）逐渐变灰，被移出数字森林（动画：块向下掉落消失）。
       - 保留的块（该位为1）留在森林中，进入下一层（i-1）。
    4.  **目标达成**：
       - 处理完所有位后，最终答案的二进制显示在屏幕中央，播放“胜利”音效（如《魂斗罗》的通关音）。

  * **旁白提示**：
    - “现在处理第31位！每个数需要多少操作才能让这一位变1呢？看它们头顶的数字～”
    - “选前K个代价最小的数，总代价不能超过M哦！如果成功，答案的这一位就保留为1～”
    - “这些数的第31位成功变1啦！其他数不符合条件，暂时和它们说再见～”

<visualization_conclusion>
通过这个动画，我们可以清晰看到每一位的处理过程，理解贪心策略如何一步步构建最大的按位与值。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
按位贪心和位运算的思想在很多问题中都有应用，我们可以通过以下练习巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 求最大异或值（如给定数组，选两个数异或最大）。
    - 求满足条件的子集（如选K个数的和最大，或按位或最大）。
    - 二进制分解问题（如将数拆分为若干数的和，满足某些位条件）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1850** - 换教室  
       * 🗣️ **推荐理由**：涉及动态规划与二进制状态的结合，能锻炼对状态的拆分与贪心选择的理解。
    2.  **洛谷 P3197** - [HNOI2008]越狱  
       * 🗣️ **推荐理由**：需要利用二进制快速幂计算大数取模，结合位运算优化，适合巩固位运算技巧。
    3.  **洛谷 P4587** - [FJOI2016]神秘数  
       * 🗣️ **推荐理由**：通过贪心策略确定最小无法表示的数，与本题的贪心思想类似，适合拓展练习。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

---

<conclusion>
通过这次分析，我们掌握了按位贪心的策略，学会了如何从高位到低位逐位确定最大按位与值。记住，贪心的关键是“局部最优导致全局最优”，而位运算的拆解能简化复杂问题。多练习类似题目，你会更熟练地应用这些技巧！下次见～💪
</conclusion>

---
处理用时：129.60秒
# 题目信息

# [ABC354F] Useless for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_f

長さ $ N $ の整数列 $ A $ が与えられます。

$ t\ =\ 1,\ 2,\ \dots\ ,N $ について、 $ A_t $ が $ A $ の最長増加部分列に含まれることがあるか判定してください。

$ A_t $ が $ A $ の最長増加部分列に含まれることがあるとは、以下のことをいいます。

- 最長増加部分列の長さを $ L $ とする。各要素が $ 1 $ 以上 $ N $ 以下の単調増加な整数列 $ i\ =\ (i_1,\ i_2,\ \dots\ ,i_L)\ (i_1\ であって以下をすべて満たすものが存在する。 $
  
  
  - $ A_{i_1} $
  - ある $ k\ (1\ \leq\ k\ \leq\ L) $ が存在して $ i_k\ =\ t $ である

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

最長増加部分列とは？列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下

### Sample Explanation 1

最長増加部分列の $ 1 $ つは $ (2,\ 4,\ 5) $ で、長さは $ 3 $ です。$ (1,\ 4,\ 5) $ も最長増加部分列の $ 1 $ つです。しかし、 $ A_5 $ を含む最長増加部分列はありません。 よって、 $ 1,\ 2,\ 3,\ 4 $ を出力します。

## 样例 #1

### 输入

```
1
5
2 1 4 5 3```

### 输出

```
4
1 2 3 4```

## 样例 #2

### 输入

```
2
6
2 5 3 4 3 4
5
10000 1000 100 1 10```

### 输出

```
5
1 3 4 5 6
2
4 5```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC354F] Useless for LIS 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP) + LIS（最长上升子序列）变形应用  

🗣️ **初步分析**：  
解决“判断元素是否在某个LIS中”的问题，关键在于**拆解LIS的结构**。想象LIS是一条“上升的阶梯”，每个元素要想成为阶梯的一部分，必须满足：**以它为结尾的最长阶梯长度**（`f[i]`）加上**以它为开头的最长阶梯长度**（`g[i]`），减去重复计算的自己，等于整个阶梯的总长度（`Max`）。用公式表示就是：`f[i] + g[i] - 1 == Max`。  

- **核心思路**：  
  1. 正向计算`f[i]`：以`A[i]`结尾的LIS长度（用二分优化，时间`O(n log n)`）。  
  2. 反向计算`g[i]`：将序列反转并取反，计算以`A[i]`开头的LIS长度（等价于原序列以`A[i]`开头的最长下降子序列长度，同样用二分优化）。  
  3. 遍历每个元素，判断`f[i] + g[i] - 1`是否等于`Max`，若是则该元素属于某个LIS。  

- **可视化设计思路**：  
  用**8位像素风格**展示序列（比如用不同高度的像素块表示元素值），`f[i]`用“向上生长的阶梯”动画展示（每计算一个`f[i]`，阶梯长高一级），`g[i]`用“向下延伸的阶梯”展示（反转序列后计算）。条件判断时，有效元素用**闪烁的金色**标记，伴随“叮”的音效，增强记忆点。  


## 2. 精选优质题解参考

### 题解一：（来源：fuxiheng，赞7）  
* **点评**：  
  这份题解是最经典的“f+g”思路实现，**逻辑清晰到像说明书**！正向用`lower_bound`计算`f[i]`（以`A[i]`结尾的LIS长度），反向将序列取反后用同样的方法计算`g[i]`（以`A[i]`开头的LIS长度）。代码风格极其规范（变量名`f`、`g`、`Max`含义明确），边界处理严谨（比如`p`数组初始化为`inf`）。最值得学习的是**时间优化**：用`lower_bound`将`O(n²)`的LIS优化到`O(n log n)`，完美应对`2e5`的规模。从实践角度看，这份代码可以直接套用到类似问题（比如求LIS的路径），非常实用。  


### 题解二：（来源：Keroshi，赞3）  
* **点评**：  
  此题解用**树状数组优化DP**，进一步拓展了思路。通过离散化处理大值元素，用树状数组维护前缀最大值，计算`f[i]`（以`A[i]`结尾的LIS长度）和`g[i]`（以`A[i]`开头的LIS长度）。亮点在于**树状数组的灵活运用**：正向计算`f[i]`时，查询`A[i]-1`的前缀最大值；反向计算`g[i]`时，将`A[i]`映射为`n - A[i] + 1`，同样用树状数组维护。这种方法让代码更通用，适合处理更大的数值范围。  


### 题解三：（来源：small_john，赞1）  
* **点评**：  
  此题解用**set存储结果**，确保输出顺序正确。代码中`f[i]`用树状数组计算，`g[i]`用反向树状数组计算，逻辑与前两者一致，但**细节处理更贴心**：比如`add`和`ask`函数的封装，`set`自动排序结果，避免了手动排序的麻烦。对于初学者来说，这种“封装+自动化”的写法值得借鉴，可以减少代码错误。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何高效计算`f[i]`和`g[i]`？**  
* **分析**：  
  传统LIS的`O(n²)`算法无法处理`2e5`的规模，必须用**二分优化**或**树状数组优化**。二分优化的核心是维护一个`p`数组，`p[len]`表示长度为`len`的LIS的最小末尾元素，通过`lower_bound`快速找到`A[i]`的插入位置，从而得到`f[i]`。树状数组优化则通过离散化元素值，维护前缀最大值，快速查询`A[i]-1`的最大`f[j]`。  
* 💡 **学习笔记**：二分或树状数组是处理大规模LIS问题的“必选工具”。  


### 2. **关键点2：如何计算`g[i]`（以`A[i]`开头的LIS长度）？**  
* **分析**：  
  `g[i]`等价于**原序列反转后，以`A[i]`结尾的最长下降子序列长度**。为了复用LIS的代码，可以将反转后的序列取反（比如`A[i] = -A[i]`），这样最长下降子序列就变成了最长上升子序列，直接用`f[i]`的计算方法即可。  
* 💡 **学习笔记**：反转+取反是将“下降”转化为“上升”的常用技巧。  


### 3. **关键点3：如何判断元素是否在LIS中？**  
* **分析**：  
  假设`f[i]`是`A[i]`结尾的LIS长度，`g[i]`是`A[i]`开头的LIS长度，那么`f[i] + g[i] - 1`就是包含`A[i]`的最长序列长度。如果这个长度等于整个序列的LIS长度（`Max`），则`A[i]`必然属于某个LIS。  
* 💡 **学习笔记**：`f[i] + g[i] - 1 == Max`是判断元素是否在LIS中的“黄金公式”。  


### ✨ 解题技巧总结  
- **技巧A：问题拆解**：将“判断元素是否在LIS中”拆解为“计算`f[i]`和`g[i]`”，降低问题复杂度。  
- **技巧B：优化工具**：用二分或树状数组优化LIS计算，处理大规模数据。  
- **技巧C：反转+取反**：将下降子序列转化为上升子序列，复用代码。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了fuxiheng的思路，是最经典的“f+g”实现，逻辑清晰，效率极高。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int MAXN = 2e5 + 5;
  const int INF = 0x7fffffff / 2;

  int a[MAXN], f[MAXN], g[MAXN];
  int p[MAXN];

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);

      int T;
      cin >> T;
      while (T--) {
          int n;
          cin >> n;
          for (int i = 1; i <= n; ++i) {
              cin >> a[i];
          }

          // 计算f[i]：以a[i]结尾的LIS长度
          fill(p + 1, p + n + 1, INF);
          p[0] = -INF;
          int Max = 0;
          for (int i = 1; i <= n; ++i) {
              f[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
              p[f[i]] = min(p[f[i]], a[i]);
              Max = max(Max, f[i]);
          }

          // 计算g[i]：以a[i]开头的LIS长度（反转+取反）
          fill(p + 1, p + n + 1, INF);
          p[0] = -INF;
          for (int i = 1; i <= n; ++i) {
              a[i] = -a[i];
          }
          for (int i = n; i >= 1; --i) {
              g[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
              p[g[i]] = min(p[g[i]], a[i]);
          }

          // 判断并输出结果
          vector<int> ans;
          for (int i = 1; i <= n; ++i) {
              if (f[i] + g[i] - 1 == Max) {
                  ans.push_back(i);
              }
          }
          cout << ans.size() << '\n';
          for (int x : ans) {
              cout << x << ' ';
          }
          cout << '\n';
      }

      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取测试用例和序列。  
  2. **计算`f[i]`**：用`lower_bound`维护`p`数组，快速得到以`a[i]`结尾的LIS长度。  
  3. **计算`g[i]`**：反转序列并取反，复用`f[i]`的计算方法，得到以`a[i]`开头的LIS长度。  
  4. **条件判断**：遍历每个元素，判断`f[i] + g[i] - 1`是否等于`Max`，收集有效元素并输出。  


### 针对各优质题解的片段赏析

#### 题解一（fuxiheng）：`f[i]`的计算  
* **亮点**：用`lower_bound`优化LIS，代码简洁高效。  
* **核心代码片段**：  
  ```cpp
  fill(p + 1, p + n + 1, INF);
  p[0] = -INF;
  int Max = 0;
  for (int i = 1; i <= n; ++i) {
      f[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
      p[f[i]] = min(p[f[i]], a[i]);
      Max = max(Max, f[i]);
  }
  ```  
* **代码解读**：  
  - `p[len]`表示长度为`len`的LIS的最小末尾元素（这样能为后面的元素留出更大的上升空间）。  
  - `lower_bound(p + 1, p + n + 1, a[i])`找到第一个大于等于`a[i]`的位置，这个位置就是`f[i]`（以`a[i]`结尾的LIS长度）。  
  - 更新`p[f[i]]`为`min(p[f[i]], a[i])`，保持`p`数组的最小性。  
* 💡 **学习笔记**：`lower_bound`是LIS优化的“神器”，记住`p`数组的含义就能轻松写出这段代码。  


#### 题解二（Keroshi）：树状数组计算`f[i]`  
* **亮点**：用树状数组维护前缀最大值，处理大值元素。  
* **核心代码片段**：  
  ```cpp
  struct fenwick {
      int a[N];
      int lowbit(int x) { return -x & x; }
      int query(int u) {
          int res = 0;
          for (int i = u; i; i -= lowbit(i)) {
              res = max(res, a[i]);
          }
          return res;
      }
      void modify(int u, int x) {
          for (int i = u; i <= n; i += lowbit(i)) {
              a[i] = max(a[i], x);
          }
      }
  } t1;

  // 计算f[i]
  for (int i = 1; i <= n; ++i) {
      f[i] = t1.query(a[i] - 1) + 1;
      t1.modify(a[i], f[i]);
  }
  ```  
* **代码解读**：  
  - 树状数组`t1`维护前缀最大值，`query(a[i] - 1)`得到`A[1..i-1]`中小于`A[i]`的元素的最大`f[j]`。  
  - `modify(a[i], f[i])`更新树状数组，将`A[i]`的位置设置为`f[i]`。  
* 💡 **学习笔记**：树状数组适合处理“前缀最大值”或“前缀和”问题，离散化后可以处理大值元素。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素阶梯探险**（仿FC游戏风格）  
**设计思路**：用8位像素风格展示序列（比如用不同高度的像素块表示元素值），`f[i]`是“向上生长的阶梯”，`g[i]`是“向下延伸的阶梯”，有效元素用金色闪烁标记，伴随音效增强代入感。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示像素化序列（比如`2 1 4 5 3`用高度为2、1、4、5、3的绿色像素块表示）。  
   - 屏幕右侧显示`f`数组（向上的蓝色阶梯）和`g`数组（向下的红色阶梯）。  
   - 控制面板有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块。  
   - 播放8位风格的轻快背景音乐（比如《超级马里奥》的背景音）。  

2. **计算`f[i]`（正向）**：  
   - 每计算一个`f[i]`，对应的蓝色阶梯长高一级（比如`f[1]=1`，蓝色阶梯从0升到1）。  
   - `p`数组用灰色像素块表示，`lower_bound`的过程用“扫描线”动画展示（从左到右扫描`p`数组，找到插入位置）。  
   - 计算完成后，`f`数组的最大值`Max`用黄色标记。  

3. **计算`g[i]`（反向+取反）**：  
   - 序列反转并取反（比如`3 5 4 1 2`变成`-3 -5 -4 -1 -2`），用紫色像素块表示。  
   - 同样用蓝色阶梯计算`g[i]`（反向的LIS长度），然后反转回原序列的`g`数组。  

4. **条件判断**：  
   - 遍历每个元素，计算`f[i] + g[i] - 1`，如果等于`Max`，对应的像素块闪烁金色，并播放“叮”的音效（比如《吃豆人》的得分音效）。  
   - 有效元素收集到右侧的“结果列表”（用白色像素块表示）。  

5. **目标达成**：  
   - 所有有效元素标记完成后，播放“胜利”音效（比如《魂斗罗》的通关音），屏幕显示“任务完成！”的像素文字。  


### 旁白提示（动画中的文字气泡）  
- “现在计算`f[i]`，看看以这个元素结尾的最长阶梯有多长～”（计算`f[i]`时）  
- “反转序列并取反，把下降变成上升！”（计算`g[i]`时）  
- “这个元素的`f[i]+g[i]-1`等于`Max`，它是LIS的一部分！”（标记有效元素时）  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
`f[i] + g[i] - 1 == Max`的思路不仅能解决本题，还能用于：  
1. **求LIS的所有路径**：收集所有有效元素，然后回溯路径。  
2. **求LIS的数量**：统计所有有效元素的组合数。  
3. **求最长不下降子序列的有效元素**：只需将`lower_bound`改为`upper_bound`，调整条件判断。  


### 练习推荐 (洛谷)  
1. **洛谷 P1020** - 导弹拦截  
   * 🗣️ **推荐理由**：这道题是LIS的经典变形，需要求最长不下降子序列和最长上升子序列，能帮助你巩固`f[i]`和`g[i]`的计算。  
2. **洛谷 P1091** - 合唱队形  
   * 🗣️ **推荐理由**：此题需要求最长上升子序列和最长下降子序列的组合，与本题的`f[i]+g[i]`思路高度相似，是很好的拓展练习。  
3. **洛谷 P2782** - 友好城市  
   * 🗣️ **推荐理由**：此题需要将问题转化为LIS，能帮助你理解“如何将实际问题映射到LIS模型”。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自fuxiheng)**：“我在最初写代码时，忘记将`p`数组初始化为`INF`，导致`lower_bound`的结果错误。后来通过打印中间变量，才发现这个问题。”  
**点评**：这位作者的经验很典型！在编程中，**初始化变量**是非常重要的一步，尤其是像`p`数组这样的辅助数组。如果初始化错误，整个算法的结果都会出错。建议大家在写代码时，先想清楚每个变量的初始值，避免低级错误。  


## 结语  
本次关于“[ABC354F] Useless for LIS”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解LIS的变形应用和动态规划的技巧。记住，**拆解问题+选择合适的优化工具**是解决大规模编程问题的关键。下次我们再一起探索新的编程挑战！💪

---
处理用时：149.47秒
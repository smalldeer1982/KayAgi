# 题目信息

# [ARC162C] Mex Game on Tree

## 题目描述

给定一棵有 $N$ 个顶点的有根树，顶点编号为 $1$ 到 $N$。顶点 $1$ 是根，对于每个 $i\ (2\leq i \leq N)$，顶点 $i$ 的父节点为 $P_i$。

树上的部分顶点上写有 $0$ 到 $N$ 之间的整数。这些信息由数列 $A=(A_1,A_2,\ldots,A_N)$ 给出，若 $A_i\neq -1$，则表示顶点 $i$ 上写有整数 $A_i$；若 $A_i=-1$，则表示顶点 $i$ 上没有写整数。

Alice 和 Bob 进行游戏。Alice 先手，双方轮流操作，直到所有顶点都被写上整数。每次操作可以选择一个尚未写整数的顶点，并在其上写一个 $0$ 到 $N$ 之间的整数。

操作结束后，对于每个顶点 $v$，定义 $f(v)$ 为“在顶点 $v$ 的子树中（包括 $v$ 本身），没有被写下的最小非负整数”。

若存在某个顶点 $v$ 满足 $f(v)=K$，则 Alice 获胜，否则 Bob 获胜。请判断在双方都采取最优策略的情况下，谁会获胜。

有 $T$ 组测试数据，请分别作答。

## 说明/提示

## 限制

- $1\leq T\leq 10^3$
- $2\leq N\leq 10^3$
- $0\leq K\leq N$
- $1\leq P_i < i\ (2\leq i\leq N)$
- $-1\leq A_i\leq N\ (1\leq i\leq N)$
- 所有输入的数均为整数
- 所有测试数据中 $N$ 的总和不超过 $2\times 10^3$

## 样例解释 1

对于第 $1$ 组测试数据，Alice 可以在顶点 $2$ 上写 $0$，无论 Bob 如何操作，都有 $f(2)=2$，因此 Alice 获胜。对于第 $2$ 组测试数据，Bob 可以通过合理选择写入的整数，使得不存在 $f(v)=4$ 的顶点，因此 Bob 获胜。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2

4 2

1 1 2

-1 -1 3 1

6 4

1 2 2 1 3

-1 -1 -1 -1 -1 -1```

### 输出

```
Alice

Bob```

# AI分析结果


### 💡 Kay的C++算法解析：ARC162C Mex Game on Tree 深入学习指南 💡

<introduction>
今天我们来分析树上博弈问题"Mex Game on Tree"。本指南将帮助你理解博弈策略的核心思想、掌握树形状态的高效处理技巧，并通过像素动画直观感受算法流程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`博弈策略` + `树形状态分析`

🗣️ **初步分析**：
> 这道题就像在树形迷宫中玩"陷阱布置"游戏。Alice的目标是在某个子树中快速布置好陷阱（使子树mex恰好为K），而Bob则会全力破坏这些陷阱（在空位填K使mex≠K）。  
> - **核心策略**：Alice获胜仅当存在一个子树满足：(1) 不含数字K (2) 空位数≤1 (3) 填数后可使mex=K  
> - **难点**：需高效统计每个子树的空位数和数字分布状态。优质题解采用bitset或DFS序优化状态合并  
> - **可视化设计**：将用像素树展示自底向上遍历过程，高亮当前节点状态（空位数/mex值），当发现可获胜子树时触发闪光和胜利音效（8-bit风格）

---

## 2. 精选优质题解参考

**题解一（作者：_•́へ•́╬_）**
* **点评**：思路直击要害，清晰指出Alice获胜的两种核心场景（空位0或1）。代码亮点在于用bitset._Find_first()高效计算mex，通过位运算合并子树状态（a[f[i]] &= a[i]）大幅优化空间。变量命名简洁（cnt[]统计空位），边界处理严谨，可直接用于竞赛。

**题解二（作者：wangshulin）**
* **点评**：采用DFS序遍历子树避免递归合并，通过ccol数组统计数字出现次数，逻辑清晰易理解。创新点在于用dfn/bot数组将子树转化为线性区间处理，显著降低实现难度。代码模块化（独立dfs函数）且鲁棒性强（每次重置ccol）。

---

## 3. 核心难点辨析与解题策略

1.  **关键点1：理解Bob的破坏策略**
    * **分析**：Bob最优策略是在空位填K，这会污染该节点到根路径上所有子树（使mex≠K）。因此Alice必须找到"未被污染"且空位≤1的子树
    * 💡 **学习笔记**：博弈问题需逆向思考——先分析对手最优策略

2.  **关键点2：高效统计子树状态**
    * **分析**：需要同时追踪：(1) 是否含K (2) 空位数 (3) 0~K-1数字分布。bitset（题解1）或DFS序+数组（题解2）都能在O(N^2/K)内完成
    * 💡 **学习笔记**：树形问题优先考虑自底向上合并状态

3.  **关键点3：判断获胜条件**
    * **分析**：分三种情况：
      - 空位=0：检查当前mex是否恰好为K
      - 空位=1：检查0~K-1中是否仅缺1个数
      - 空位≥2：Bob必胜
    * 💡 **学习笔记**：空位＞1时Alice必败，无需继续计算

### ✨ 解题技巧总结
- **逆向思维优先**：从Bob的最优操作反推Alice的获胜条件
- **状态压缩**：用bitset代替数组存储数字分布，节省空间
- **线性化处理树**：DFS序将子树转化为区间，简化统计
- **及时剪枝**：发现可获胜子树立即返回结果

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合两个优质题解，采用bitset优化状态合并
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <bitset>
using namespace std;
const int N = 1005;

int T, n, k;
vector<int> tree[N];
int A[N], cnt[N]; // cnt: 空位数
bitset<N> hasNum[N]; // hasNum[u][i]=1表示数字i在子树中已出现

bool dfs(int u) {
    bool win = false;
    cnt[u] = (A[u] == -1);
    hasNum[u].reset();
    if (A[u] != -1) hasNum[u][A[u]] = 1;

    for (int v : tree[u]) {
        win |= dfs(v);
        cnt[u] += cnt[v];
        hasNum[u] |= hasNum[v]; // 合并子树数字状态
    }

    // 检查获胜条件
    if (!hasNum[u][k]) { // 不含K才可能获胜
        if (cnt[u] == 0) {
            int mex = 0;
            while (hasNum[u][mex]) mex++;
            if (mex == k) win = true;
        } 
        else if (cnt[u] == 1) {
            int missing = 0;
            for (int i = 0; i < k; ++i)
                if (!hasNum[u][i]) missing++;
            if (missing <= 1) win = true;
        }
    }
    return win;
}

int main() {
    cin >> T;
    while (T--) {
        cin >> n >> k;
        for (int i = 1; i <= n; ++i) tree[i].clear();
        for (int i = 2; i <= n; ++i) {
            int p; cin >> p;
            tree[p].push_back(i);
        }
        for (int i = 1; i <= n; ++i) cin >> A[i];

        cout << (dfs(1) ? "Alice" : "Bob") << endl;
    }
}
```
* **代码解读概要**：
  > 1. 自底向上DFS遍历树  
  > 2. hasNum[u]通过位运算(|=)合并子树数字状态  
  > 3. 分空位数0/1/≥2三种情况判断获胜条件  
  > 4. 发现获胜立即返回true（剪枝优化）

---

**题解一（_•́へ•́╬_）片段赏析**
* **亮点**：bitset._Find_first()高效找mex
* **核心代码片段**：
```cpp
for(int i=n-1;i>=0;--i) {
    if(~x[i]) a[i][x[i]]=0; // 标记已有数字
    else ++cnt[i];          // 统计空位
    if(!cnt[i]) 
        if(a[i]._Find_first()==k) win=true; // 空位0
    if(cnt[i]==1) 
        if(a[i]._Find_first()==k || ...) win=true; // 空位1
    if(i) a[f[i]] &= a[i]; // 父节点合并子状态
}
```
* **代码解读**：
  > 倒序遍历节点（叶→根），`a[i]`是bitset表示缺失的数字集合。`a[i]._Find_first()`返回最小缺失数（即mex）。父节点通过`&=`取交集合并子状态——只有所有子树都缺失的数字才保留
* 💡 **学习笔记**：bitset交集操作等效于数学推导中的"共同缺失条件"

**题解二（wangshulin）片段赏析**
* **亮点**：DFS序线性化处理子树
* **核心代码片段**：
```cpp
void dfs(int u){
    dfn[u]=++idx; rnk[idx]=u;
    for(v:children[u]) dfs(v);
    bot[u]=idx; // 记录子树区间终点
}
// 判断子树u：
memset(ccol,0,sizeof ccol);
for(int j=dfn[u]; j<=bot[u]; j++){
    int node=rnk[j];
    if(A[node]!=-1) ccol[A[node]]=1;
    else emptyCount++;
}
```
* **代码解读**：
  > 先通过DFS预处理dfn/bot数组，将子树映射到连续区间[dfn[u], bot[u]]。判断时直接遍历区间统计数字出现情况，避免递归合并
* 💡 **学习笔记**：DFS序将树形问题转化为线性问题

---

## 5. 算法可视化：像素动画演示

**主题**：8-bit风格《树形迷宫探险》  
**核心演示**：自底向上遍历树，实时显示空位数/mex值，发现获胜子树时触发特效

1. **场景设计**：
   - 树布局为金字塔状像素网格（FC游戏风格）
   - 节点：蓝色(已填数)/黄色(空位)/红色(含K)
   - 控制面板：方向键移动焦点，A键步进，B键自动播放

2. **动画流程**：
   ```mermaid
   graph LR
   A[叶节点开始] --> B[显示当前节点状态]
   B --> C{检查获胜条件}
   C -- 满足 --> D[闪光+胜利音效]
   C -- 不满足 --> E[向上合并状态]
   E --> F[父节点]
   ```

3. **关键交互**：
   - 当前节点高亮闪烁，显示hasNum比特位（如■□■□表示缺数字1,3）
   - 合并状态时：子节点向父节点发射像素粒子，聚合成新bitset
   - 发现空位=1的可获胜节点：弹出对话框显示缺失数字，Alice填入后播放升级音效
   - 失败场景：Bob人偶自动跳至空位≥2的节点填K，触发"错误"音效

4. **游戏化元素**：
   - 每成功分析一个子树得10分，发现获胜子树得100分
   - 自动演示模式：像素小车沿DFS序自动移动，像经典游戏《吃豆人》
   - 音效设计：移动(滴答声)，合并(合成音)，胜利(超级玛丽过关音效)

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
树形状态统计+博弈策略可用于：
1. 树上涂色游戏（如相邻节点约束）
2. 子树满足特定条件的计数问题
3. 对手干扰下的最优策略问题

**洛谷推荐**：
1. **P2580 他错了**  
   → 练习树上DFS序统计
2. **P2146 [NOI2015]软件包管理器**  
   → 掌握树链剖分与子树状态维护
3. **P3978 [TJOI2015]概率论**  
   → 树形DP与数学期望结合

---

## 7. 学习心得与经验分享

> **作者_•́へ•́╬_心得**："Bob的破坏策略是解题关键——他总是填K污染路径"  
> **Kay点评**：这是博弈问题的黄金法则！先分析对手最优操作能简化问题本质。调试时可打印每个子树的hasNum和cnt值验证逻辑。

---

<conclusion>
通过本指南，我们掌握了树上博弈的核心分析技巧：逆向思考对手策略、高效合并树形状态、活用bitset/DFS序优化。记住，遇到博弈题先问自己："对手会怎么破坏我的计划？" 下次遇到类似问题，你一定能快速找到突破口！
</conclusion>
```

---
处理用时：191.11秒
# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC255F] Pre-order and In-order 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：递归（二叉树重建）

🗣️ **初步分析**：  
解决“根据前序和中序遍历重建二叉树”的问题，关键在于**递归拆解子问题**——就像剥洋葱一样，每次从当前“洋葱层”（子树）中找到“核心”（根节点），再把剩下的部分分成“左半层”（左子树）和“右半层”（右子树），重复这个过程直到所有“层”都处理完毕。  

具体来说，前序遍历的**第一个元素一定是当前子树的根**（比如前序序列`[1,3,5,6,4,2]`的根是1）；中序遍历中，**根节点的左边是左子树的所有节点，右边是右子树的所有节点**（比如中序序列`[3,5,1,4,6,2]`中，根1的左边是`[3,5]`（左子树），右边是`[4,6,2]`（右子树））。  

**核心难点**：  
- 如何正确划分左右子树的区间（避免越界或错误分割）；  
- 如何快速判断无解（比如前序第一个元素不是1，或根不在中序的当前区间）；  
- 如何高效查找中序中根的位置（避免每次遍历导致超时）。  

**可视化设计思路**：  
用**8位像素风格**展示二叉树重建过程：  
- 前序序列用“黄色像素块”排列，中序序列用“蓝色像素块”排列；  
- 根节点用“红色闪烁”标记，左子树用“浅绿色”、右子树用“浅紫色”区分；  
- 每一步递归分割时，用“箭头动画”连接根与左右子树，伴随“叮”的音效（找到根）和“沙沙”的音效（分割子树）；  
- 控制面板支持“单步执行”（逐次分割子树）、“自动播放”（快速演示完整过程），以及“重置”（重新开始）。  


## 2. 精选优质题解参考

### 题解一（来源：program_xwl）  
* **点评**：  
  这份题解的思路**非常清晰**，完美贴合“前序找根、中序分左右”的核心逻辑。代码结构工整，用`tree`数组存储每个节点的左右孩子，`mp`数组预处理中序位置（避免每次遍历查找），边界条件处理严谨（比如判断根是否在中序区间内）。  
  亮点：**递归函数的参数设计**（`l1,r1`表示前序区间，`l2,r2`表示中序区间）非常直观，让学习者能快速理解“子树的范围”；**无解情况的及时退出**（用`exit(0)`终止程序），避免无效递归。  

### 题解二（来源：Tsawke）  
* **点评**：  
  此题解的代码**规范性强**，变量命名清晰（`Pre`表示前序，`In`表示中序，`posI`记录中序位置），递归函数的逻辑与题解一一致，但返回值设计（返回当前子树的根）更符合“函数职责单一”的编程原则。  
  亮点：**简洁的边界判断**（`if(lp > rp) return 0;`），用`0`表示无子节点，与题目要求的输出格式完美衔接；**时间复杂度分析**（在stderr中输出运行时间），帮助学习者理解算法效率。  

### 题解三（来源：ATION001）  
* **点评**：  
  这份题解的代码**非常简洁**，用`l`和`r`数组直接存储每个节点的左右孩子，递归函数的参数与题解一类似，但省略了不必要的变量（比如`rp`参数通过`l1+(P-l2)`计算），更适合初学者模仿。  
  亮点：**特判处理**（前序第一个元素不是1直接输出-1），覆盖了最常见的无解情况；**递归终止条件**（`l1>r1`返回0），避免了无效递归。  


## 3. 核心难点辨析与解题策略

### 1. 如何正确划分左右子树的区间？  
* **分析**：  
  假设当前前序区间是`[l1, r1]`，中序区间是`[l2, r2]`，根是`a[l1]`（前序第一个元素）。在中序中找到根的位置`root`，则左子树的大小是`root - l2`，右子树的大小是`r2 - root`。因此：  
  - 左子树的前序区间是`[l1+1, l1 + sizl]`（前序中根之后的`sizl`个元素）；  
  - 左子树的中序区间是`[l2, root-1]`（中序中根左边的所有元素）；  
  - 右子树的前序区间是`[l1 + sizl + 1, r1]`（前序中左子树之后的所有元素）；  
  - 右子树的中序区间是`[root+1, r2]`（中序中根右边的所有元素）。  

* 💡 **学习笔记**：区间划分的关键是“通过中序根的位置计算子树大小”，再映射到前序的区间。  

### 2. 如何处理无解情况？  
* **分析**：  
  无解的情况主要有两种：  
  - 前序第一个元素不是1（题目要求根必须是1）；  
  - 递归过程中，根不在中序的当前区间（比如前序中的根在中序中的位置小于`l2`或大于`r2`）。  

  处理方法：在主函数中特判前序第一个元素是否为1；在递归函数中，每次找到根后，立即判断其是否在中序区间内，若不在则输出-1并终止程序。  

* 💡 **学习笔记**：无解情况要“早发现、早终止”，避免不必要的计算。  

### 3. 如何高效查找中序中根的位置？  
* **分析**：  
  若每次递归都遍历中序区间查找根的位置，时间复杂度会达到`O(N^2)`（对于`N=2e5`的情况，会超时）。因此，需要**预处理**一个哈希表（或数组），存储每个节点在中序中的位置（比如`mp[b[i]] = i`，其中`b`是中序序列）。这样，查找根的位置的时间复杂度是`O(1)`。  

* 💡 **学习笔记**：预处理是解决“重复查找”问题的常用技巧，能大幅提升算法效率。  

### ✨ 解题技巧总结  
- **问题拆解**：将“重建整棵树”拆解为“重建根、重建左子树、重建右子树”三个子问题，用递归解决；  
- **预处理**：用哈希表存储中序位置，避免重复查找；  
- **边界处理**：注意递归的终止条件（区间为空）和无解情况的特判；  
- **代码规范**：变量命名要清晰（比如`Pre`表示前序，`In`表示中序），函数参数要直观（比如`l1,r1`表示前序区间）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了program_xwl、Tsawke和ATION001的题解思路，保留了最核心的递归逻辑和预处理步骤，适合初学者理解。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  const int N = 2e5 + 5;
  struct Node { int l, r; } tree[N]; // 存储每个节点的左右孩子
  int pre[N], in[N], mp[N]; // pre: 前序序列; in: 中序序列; mp: 中序中节点的位置
  int n;

  void dfs(int l1, int r1, int l2, int r2) {
      if (l1 > r1) return; // 递归终止条件：区间为空
      int root = pre[l1]; // 当前子树的根（前序第一个元素）
      int root_pos = mp[root]; // 根在中序中的位置
      if (root_pos < l2 || root_pos > r2) { // 根不在中序区间内，无解
          cout << -1 << endl;
          exit(0);
      }
      int sizl = root_pos - l2; // 左子树大小
      int sizr = r2 - root_pos; // 右子树大小
      // 递归处理左子树：前序区间[l1+1, l1+sizl]，中序区间[l2, root_pos-1]
      if (sizl > 0) {
          tree[root].l = pre[l1+1];
          dfs(l1+1, l1+sizl, l2, root_pos-1);
      } else {
          tree[root].l = 0; // 左子树为空
      }
      // 递归处理右子树：前序区间[l1+sizl+1, r1]，中序区间[root_pos+1, r2]
      if (sizr > 0) {
          tree[root].r = pre[l1+sizl+1];
          dfs(l1+sizl+1, r1, root_pos+1, r2);
      } else {
          tree[root].r = 0; // 右子树为空
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      cin >> n;
      for (int i = 1; i <= n; ++i) cin >> pre[i];
      for (int i = 1; i <= n; ++i) {
          cin >> in[i];
          mp[in[i]] = i; // 预处理中序位置
      }
      if (pre[1] != 1) { // 前序第一个元素不是1，无解
          cout << -1 << endl;
          return 0;
      }
      dfs(1, n, 1, n); // 递归重建整棵树
      for (int i = 1; i <= n; ++i) {
          cout << tree[i].l << " " << tree[i].r << endl;
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **预处理**：用`mp`数组存储中序序列中每个节点的位置，避免重复查找；  
  2. **特判**：检查前序第一个元素是否为1，若不是则直接输出-1；  
  3. **递归重建**：`dfs`函数处理当前子树的前序区间（`l1,r1`）和中序区间（`l2,r2`），找到根节点，划分左右子树，递归处理；  
  4. **输出结果**：遍历`tree`数组，输出每个节点的左右孩子。  

### 题解一（来源：program_xwl）核心代码片段赏析  
* **亮点**：**递归函数的参数设计**直观，清晰区分前序和中序区间。  
* **核心代码片段**：  
  ```cpp
  void dfs(int l1, int r1, int l2, int r2) {
      if (l1 >= r1) return; // 终止条件
      int root = mp[a[l1]], sizl = root - l2, sizr = r2 - root;
      if (root < l2 || root > r2) { cout << -1; exit(0); }
      tree[a[l1]] = {a[l1+1], a[l1+sizl+1]}; // 存储左右孩子
      if (sizl == 0) tree[a[l1]].l = 0;
      if (sizr == 0) tree[a[l1]].r = 0;
      dfs(l1+1, l1+sizl, l2, root-1); // 左子树
      dfs(l1+sizl+1, r1, root+1, r2); // 右子树
  }
  ```  
* **代码解读**：  
  - `l1,r1`是前序区间，`l2,r2`是中序区间；  
  - `root`是当前子树的根（前序第一个元素`a[l1]`在中序中的位置）；  
  - `sizl`和`sizr`是左右子树的大小；  
  - `tree[a[l1]]`存储当前根的左右孩子（前序中左子树的第一个元素是`a[l1+1]`，右子树的第一个元素是`a[l1+sizl+1]`）；  
  - 递归处理左右子树，更新区间。  

* 💡 **学习笔记**：递归函数的参数设计要“贴合问题逻辑”，让每个参数都有明确的含义。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素树建造师”**：用8位像素风格模拟二叉树重建过程，像搭积木一样“一步步”把树搭起来。  

### 设计思路  
采用**FC红白机风格**（低分辨率、高饱和色彩），让学习者在“游戏化”的环境中理解算法。关键元素：  
- **前序序列**：黄色像素块，排列在屏幕顶部；  
- **中序序列**：蓝色像素块，排列在屏幕底部；  
- **根节点**：红色闪烁像素块，突出显示；  
- **左子树**：浅绿色像素块，位于根的左侧；  
- **右子树**：浅紫色像素块，位于根的右侧；  
- **音效**：找到根时播放“叮”的音效（8位风格），分割子树时播放“沙沙”的音效，完成重建时播放“胜利”音效。  

### 动画帧步骤  
1. **初始化**：屏幕显示前序序列（黄色）和中序序列（蓝色），控制面板（开始/暂停、单步、重置）位于屏幕右侧。  
2. **找到根**：前序序列的第一个元素（1）闪烁红色，伴随“叮”的音效；同时，中序序列中找到1的位置，用红色框标记。  
3. **分割子树**：中序序列中1的左边（`[3,5]`）变为浅绿色（左子树），右边（`[4,6,2]`）变为浅紫色（右子树），伴随“沙沙”的音效；前序序列中1之后的`sizl`个元素（`[3,5]`）变为浅绿色，之后的元素（`[6,4,2]`）变为浅紫色。  
4. **递归处理左子树**：左子树的前序序列（`[3,5]`）的第一个元素（3）闪烁红色，重复步骤2-3，直到左子树处理完毕。  
5. **递归处理右子树**：右子树的前序序列（`[6,4,2]`）的第一个元素（6）闪烁红色，重复步骤2-3，直到右子树处理完毕。  
6. **完成重建**：整个二叉树用像素块显示（根1在顶部，左子树3、5在左侧，右子树6、4、2在右侧），播放“胜利”音效，屏幕显示“重建成功！”。  

### 交互设计  
- **单步执行**：点击“单步”按钮，执行一步递归（比如找到根、分割子树）；  
- **自动播放**：点击“自动”按钮，快速演示完整过程（速度可通过滑块调整）；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始演示。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
“前序+中序重建二叉树”的思路可迁移到以下场景：  
- **后序+中序重建二叉树**（后序的最后一个元素是根，中序分割左右子树）；  
- **根据遍历序列判断二叉树是否存在**（比如本题的无解情况）；  
- **二叉树的序列化与反序列化**（将二叉树转换为遍历序列，再恢复为二叉树）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1030** - [NOIP2001 普及组] 求先序排列  
   🗣️ **推荐理由**：本题是“前序+中序重建二叉树”的经典变形，要求根据后序和中序遍历求先序遍历，能帮助你巩固“递归拆解子问题”的思路。  
2. **洛谷 P1827** - [NOIP2011 普及组] 二叉树的遍历  
   🗣️ **推荐理由**：本题要求根据前序和中序遍历求后序遍历，与本题的思路高度一致，适合练习“区间划分”和“递归处理”。  
3. **洛谷 P5018** - [NOIP2018 普及组] 二叉树的构造与遍历  
   🗣️ **推荐理由**：本题要求根据前序和中序遍历构造二叉树，并输出层序遍历结果，能帮助你综合运用“二叉树重建”和“层序遍历”的知识。  


## 7. 学习心得与经验分享 (若有)  
> **参考经验 (来自 program_xwl)**：“我在写代码的时候，一开始没有预处理中序位置，导致超时了。后来想到用数组存储每个节点的中序位置，才解决了这个问题。”  
> **点评**：这位作者的经验很典型——**预处理是解决“重复查找”问题的关键**。在处理大规模数据时，预处理能将时间复杂度从`O(N^2)`降低到`O(N)`，避免超时。  
> **参考经验 (来自 Tsawke)**：“我在递归函数中返回当前子树的根，这样能更方便地存储左右孩子。”  
> **点评**：返回值的设计要“贴合函数的职责”，比如递归函数的职责是“重建当前子树”，返回根节点能让父函数更方便地存储其左右孩子。  


## 结语  
本次关于“[ABC255F] Pre-order and In-order”的分析就到这里。希望这份指南能帮助你理解“递归重建二叉树”的核心逻辑，掌握“预处理”“区间划分”等关键技巧。记住：**递归的本质是“拆解问题”，只要把大问题拆成小问题，再解决小问题，就能解决大问题**！下次我们再一起探索新的编程挑战！💪

---
处理用时：162.92秒
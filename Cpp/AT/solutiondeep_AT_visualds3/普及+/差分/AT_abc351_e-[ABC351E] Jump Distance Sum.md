# 题目信息

# [ABC351E] Jump Distance Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_e

座標平面上に $ N $ 個の点 $ P_1,P_2,\ldots,P_N $ があり、点 $ P_i $ の座標は $ (X_i,Y_i) $ です。  
$ 2 $ つの点 $ A,B $ の距離 $ \text{dist}(A,B) $ を次のように定義します。

> 最初、ウサギが点 $ A $ にいる。  
> $ (x,y) $ にいるウサギは $ (x+1,y+1) $, $ (x+1,y-1) $, $ (x-1,y+1) $, $ (x-1,y-1) $ のいずれかに $ 1 $ 回のジャンプで移動することができる。  
> 点 $ A $ から点 $ B $ まで移動するために必要なジャンプの回数の最小値を $ \text{dist}(A,B) $ として定義する。  
> ただし、何度ジャンプを繰り返しても点 $ A $ から点 $ B $ まで移動できないとき、$ \text{dist}(A,B)=0 $ とする。

$ \displaystyle\sum_{i=1}^{N-1}\displaystyle\sum_{j=i+1}^N\ \text{dist}(P_i,P_j) $ を求めてください。

## 说明/提示

### 制約

- $ 2\leq\ N\leq\ 2\times\ 10^5 $
- $ 0\leq\ X_i,Y_i\leq\ 10^8 $
- $ i\neq\ j $ ならば $ (X_i,Y_i)\neq\ (X_j,Y_j) $
- 入力はすべて整数

### Sample Explanation 1

$ P_1,P_2,P_3 $ の座標はそれぞれ $ (0,0) $, $ (1,3) $, $ (5,6) $ です。 $ P_1 $ から $ P_2 $ へはウサギは $ (0,0)\to\ (1,1)\to\ (0,2)\to\ (1,3) $ と $ 3 $ 回で移動でき、$ 2 $ 回以下では $ P_1 $ から $ P_2 $ まで移動できないため、 $ \text{dist}(P_1,P_2)=3 $ です。 $ P_1 $ から $ P_3 $ および $ P_2 $ から $ P_3 $ へはウサギは移動できないため、$ \text{dist}(P_1,P_3)=\text{dist}(P_2,P_3)＝0 $ となります。 よって、答えは $ \displaystyle\sum_{i=1}^{2}\displaystyle\sum_{j=i+1}^3\text{dist}(P_i,P_j)=\text{dist}(P_1,P_2)+\text{dist}(P_1,P_3)+\text{dist}(P_2,P_3)=3+0+0=3 $ となります。

## 样例 #1

### 输入

```
3
0 0
1 3
5 6```

### 输出

```
3```

## 样例 #2

### 输入

```
5
0 5
1 7
2 9
3 8
4 6```

### 输出

```
11```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC351E] Jump Distance Sum 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC351E] Jump Distance Sum”这道题。这道题需要计算平面上所有点对之间的最短跳跃距离之和，跳跃规则是每次沿对角线移动。通过分析，我们会发现这道题的关键在于坐标变换和高效求和技巧。让我们一步步拆解！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学变换与排序前缀和优化` (结合坐标变换、奇偶性判断、曼哈顿距离求和)

🗣️ **初步分析**：
解决这道题的关键在于理解两点之间的可达条件和最短跳跃距离的计算方法。  
简单来说，每次跳跃只能沿对角线移动（如`(x+1,y+1)`），这意味着跳跃后的点`x+y`的奇偶性与原点相同（因为`x+y`每次变化±2，奇偶性不变）。因此，**两点可达的充要条件是它们的`x+y`奇偶性相同**，否则距离为0。  

对于可达的点对，最短跳跃距离可以通过**坐标变换**转化为曼哈顿距离。例如，将原坐标`(x,y)`旋转45度后，新坐标`(u,v)`满足`u=(x-y)/2`，`v=(x+y)/2`，此时两点间的最短跳跃距离等于新坐标下的曼哈顿距离`|u_i - u_j| + |v_i - v_j|`。  

核心算法流程：  
1. 将点按`x+y`的奇偶性分组（偶数组和奇数组，奇数组可通过调整`y`值转化为偶数组）。  
2. 对每组点进行坐标变换，得到新坐标`(u,v)`。  
3. 分别对`u`和`v`排序，利用前缀和快速计算所有点对的曼哈顿距离之和（时间复杂度`O(n log n)`）。  

可视化设计思路：  
用像素动画展示坐标变换过程（原坐标点“旋转”成新坐标点），并用不同颜色标记奇偶组。排序过程用像素方块滑动动画表示，前缀和计算时用动态累加的数字标签显示。关键步骤（如奇偶判断、坐标变换）用闪烁边框和“叮”的音效提示，最终求和时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法效率等维度筛选出以下优质题解：
</eval_intro>

**题解一：来源（weitianyi）**  
* **点评**：此题解思路清晰，直接点明了奇偶分组和坐标变换的核心。代码结构简洁，变量命名（如`ou`表示偶数组，`ji`表示奇数组）易懂，排序和前缀和的实现高效。亮点在于通过调整奇数组的`y`值（`y+1`）统一处理奇偶组，简化了代码逻辑。实践价值高，可直接用于竞赛。

**题解二：来源（zrl123456）**  
* **点评**：此题解详细推导了坐标变换的数学过程，并结合曼哈顿距离的求和公式，用前缀和优化计算。代码中`gx`和`gy`分别存储变换后的坐标，排序后通过累加计算总和，逻辑直接。亮点是将问题拆解为奇偶分组、坐标变换、排序求和三个步骤，适合初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，我们需要突破以下核心难点：
</difficulty_intro>

1.  **关键点1：判断两点是否可达**  
    * **分析**：每次跳跃后`x+y`的奇偶性不变，因此只有当两点的`x+y`奇偶性相同时，才可能到达。例如，点`(0,0)`（`x+y=0`，偶数）和`(1,3)`（`x+y=4`，偶数）可达，而与`(5,6)`（`x+y=11`，奇数）不可达。  
    * 💡 **学习笔记**：奇偶性判断是解决可达性的“钥匙”，类似问题（如棋盘染色）也常用此方法。

2.  **关键点2：坐标变换的推导**  
    * **分析**：原跳跃的最短距离等价于新坐标下的曼哈顿距离。通过将原坐标`(x,y)`旋转45度，得到新坐标`u=(x-y)/2`，`v=(x+y)/2`，此时曼哈顿距离`|u_i - u_j| + |v_i - v_j|`即为原问题的最短跳跃次数。  
    * 💡 **学习笔记**：坐标变换是将复杂问题转化为熟悉模型的常用技巧（如切比雪夫距离转曼哈顿距离）。

3.  **关键点3：高效计算所有点对的曼哈顿距离之和**  
    * **分析**：直接枚举所有点对时间复杂度为`O(n²)`，无法处理`n=2e5`的数据。通过对`u`和`v`分别排序，利用前缀和公式`sum_{i<j} |a_i - a_j| = sum_{i=1}^n a_i*(i-1) - prefix_sum[i-1]`，可将时间复杂度优化为`O(n log n)`。  
    * 💡 **学习笔记**：排序+前缀和是处理“所有点对差值和”问题的经典优化方法。

### ✨ 解题技巧总结
- **奇偶分组**：将问题按奇偶性分组，简化不可达点对的处理。  
- **坐标变换**：通过旋转或线性变换，将复杂距离（如本题的跳跃距离）转化为熟悉的曼哈顿距离。  
- **排序前缀和**：对一维坐标排序后，利用前缀和快速计算所有点对的差值和，避免`O(n²)`暴力枚举。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，给出一个清晰完整的核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了weitianyi和zrl123456的思路，通过奇偶分组、坐标变换和排序前缀和，高效计算所有可达点对的距离之和。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;

    // 计算一组点的所有点对曼哈顿距离之和
    int solve(vector<pair<int, int>>& points) {
        // 坐标变换：(x,y) -> (u=(x-y)/2, v=(x+y)/2)
        for (auto& p : points) {
            int x = p.first, y = p.second;
            p.first = (x - y) / 2;
            p.second = (x + y) / 2;
        }
        int res = 0;

        // 计算u坐标的贡献（排序+前缀和）
        sort(points.begin(), points.end());
        int sum_u = 0;
        for (int i = 0; i < points.size(); ++i) {
            res += points[i].first * i - sum_u;
            sum_u += points[i].first;
        }

        // 计算v坐标的贡献（按v排序）
        sort(points.begin(), points.end(), [](auto& a, auto& b) {
            return a.second < b.second;
        });
        int sum_v = 0;
        for (int i = 0; i < points.size(); ++i) {
            res += points[i].second * i - sum_v;
            sum_v += points[i].second;
        }
        return res;
    }

    signed main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int n;
        cin >> n;
        vector<pair<int, int>> even, odd;
        for (int i = 0; i < n; ++i) {
            int x, y;
            cin >> x >> y;
            if ((x + y) % 2 == 0) {
                even.emplace_back(x, y);
            } else {
                // 奇数组调整y值，转化为偶数组（不影响距离）
                odd.emplace_back(x, y + 1);
            }
        }
        cout << solve(even) + solve(odd) << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先将点按`x+y`的奇偶性分为`even`（偶数组）和`odd`（奇数组），奇数组通过调整`y+1`转化为偶数组。`solve`函数对每组点进行坐标变换，分别计算`u`和`v`坐标的贡献（排序后用前缀和快速求和），最终输出两组的和。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一（weitianyi）**  
* **亮点**：通过调整奇数组的`y`值统一处理奇偶组，代码简洁。  
* **核心代码片段**：
    ```cpp
    int solve(vector<pair<int, int>> point) {
        for (auto &it : point) {
            int x = it.first, y = it.second;
            it.first = (x - y) / 2;
            it.second = it.first + y; // 等价于 (x+y)/2
        }
        sort(point.begin(), point.end(), cmp1); // 按u排序
        int ans = 0, now = 0;
        for (int i = 0; i < point.size(); ++i) {
            ans += point[i].first * i - now;
            now += point[i].first;
        }
        // 类似处理v坐标...
    }
    ```
* **代码解读**：  
  `solve`函数首先将原坐标转换为`(u,v)`，然后对`u`排序。循环中，`point[i].first * i`是当前点对前`i`个点的贡献，`now`是前`i`个点的前缀和，两者相减得到前`i`个点对当前点的`u`坐标差值和。类似地处理`v`坐标，最终累加得到总距离。  
* 💡 **学习笔记**：排序后利用前缀和计算差值和，是处理“所有点对差值和”问题的通用技巧。

**题解二（zrl123456）**  
* **亮点**：直接推导曼哈顿距离的求和公式，用`gx`和`gy`存储变换后的坐标，逻辑清晰。  
* **核心代码片段**：
    ```cpp
    rep(k,0,1){ // 处理奇偶组
        int sumx=0,sumy=0,siz=gx[k].size();
        rep(i,0,siz-1){
            int x=gx[k][i],y=gy[k][i];
            ans+=x*i-sumx + y*i-sumy; // 同时计算x和y的贡献
            sumx+=x; sumy+=y;
        }
    }
    ```
* **代码解读**：  
  `gx[k]`和`gy[k]`分别存储第`k`组（奇偶）变换后的`u`和`v`坐标。循环中，`x*i - sumx`计算当前点的`u`坐标对前`i`个点的差值和（`sumx`是前`i`个点的前缀和），`y*i - sumy`同理处理`v`坐标。两者相加即得到当前组所有点对的曼哈顿距离之和。  
* 💡 **学习笔记**：将`u`和`v`的贡献合并计算，减少代码重复，提升效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解坐标变换和求和过程，我们设计一个“像素探险队”主题的8位像素动画：
</visualization_intro>

  * **动画演示主题**：`像素探险队的坐标变换之旅`

  * **核心演示内容**：展示点按`x+y`奇偶性分组、坐标旋转变换、排序求和的全过程。

  * **设计思路简述**：  
    8位像素风（FC游戏风格）营造轻松氛围，用不同颜色（红/蓝）标记奇偶组点。坐标变换时，像素点“旋转”成新坐标，配合“唰”的音效。排序过程用像素方块滑动动画，前缀和计算时用数字标签动态累加，关键步骤（如奇偶判断、变换公式）用文字气泡解释。

  * **动画帧步骤与交互关键点**：

    1.  **初始场景**：  
        - 屏幕左侧显示原坐标系（网格背景），右侧显示变换后的新坐标系。  
        - 控制面板：单步/自动播放按钮、速度滑块（1x-4x）、重置按钮。  
        - 播放8位风格背景音乐（如《超级玛丽》经典旋律变奏）。

    2.  **奇偶分组**：  
        - 输入点逐个出现（像素点从屏幕上方掉落），根据`x+y`奇偶性染成红色（奇数）或蓝色（偶数）。  
        - 奇数组点触发“叮”音效，并自动调整`y+1`（像素点向上跳1格）。

    3.  **坐标变换**：  
        - 选中一个蓝色点（如`(0,0)`），显示变换公式`u=(x-y)/2, v=(x+y)/2`。  
        - 像素点从原坐标“旋转”（顺时针转45度动画）到新坐标`(0,0)`，右侧新坐标系同步显示。  
        - 其他点依次完成变换，触发“唰”音效。

    4.  **排序与前缀和计算**：  
        - `u`坐标排序：像素方块（代表`u`值）从左到右滑动排序，每完成一次交换触发“咔嗒”音效。  
        - 前缀和计算：用动态数字标签显示`sum_u`和当前点的`u*i - sum_u`，累加结果用金色数字弹出。  
        - 同理演示`v`坐标的排序和求和。

    5.  **结果展示**：  
        - 所有组的和累加后，屏幕中央弹出“总距离：XXX”，播放胜利音效（如《魂斗罗》胜利旋律）。  
        - 支持“算法对比”模式，切换显示原坐标和新坐标的距离差异。

  * **旁白提示**：  
    - （奇偶分组时）“注意看！只有同色点之间才能跳跃哦～”  
    - （坐标变换时）“旋转后，跳跃距离变成了新坐标的曼哈顿距离！”  
    - （排序时）“排序后，用前缀和就能快速算出所有点对的距离和啦～”

<visualization_conclusion>
通过这个动画，我们不仅能“看”到坐标变换的魔法，还能直观理解排序和前缀和如何高效计算总和，让抽象的算法变得生动！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的坐标变换和前缀和技巧后，我们可以尝试以下拓展问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的奇偶分组、坐标变换（旋转/线性变换）、排序前缀和技巧，还可用于：  
    - 棋盘上的可达性问题（如国际象棋中的象的移动）；  
    - 切比雪夫距离与曼哈顿距离的转换问题（如求所有点对的切比雪夫距离和）；  
    - 二维平面上的最优点选择问题（如寻找使总距离最小的点）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3964 [TJOI2013] 松鼠聚会**  
        * 🗣️ **推荐理由**：此题需将切比雪夫距离转化为曼哈顿距离，与本题的坐标变换思路一致，适合巩固变换技巧。  
    2.  **洛谷 P1631 序列合并**  
        * 🗣️ **推荐理由**：此题需计算两数组所有点对的和的前n小值，可通过排序+堆优化，练习排序与高效求和。  
    3.  **洛谷 P1908 逆序对**  
        * 🗣️ **推荐理由**：此题需计算逆序对数量，可通过归并排序或树状数组+前缀和，练习排序与前缀和的综合应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本题解中未发现明确的作者个人心得分享部分。但根据解题过程，我们可以总结：
</insights_intro>

> 在处理二维平面距离问题时，**观察移动规则的数学性质**（如奇偶性、坐标变化规律）是关键。通过合理的坐标变换，可将复杂问题转化为熟悉的模型（如曼哈顿距离），再利用排序、前缀和等优化技巧高效求解。遇到大数据量时，务必优先考虑`O(n log n)`算法！

-----

<conclusion>
通过本次分析，我们掌握了奇偶分组、坐标变换和前缀和优化的核心技巧。编程的魅力在于将复杂问题拆解为简单步骤，希望大家在练习中灵活运用这些方法，不断提升算法能力！下次见～ 💪
</conclusion>

---
处理用时：139.26秒
# 题目信息

# [AGC035B] Even Degrees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_b

$ N $ 頂点 $ M $ 辺の単純連結無向グラフが与えられます。頂点には $ 1 $ から $ N $ までの番号がついており、$ i $ 本目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。 高橋君は、与えられたグラフのすべての辺にどちらかの向きをつけて有向グラフを作ります。 どの頂点から出る辺の本数も偶数になるような有向グラフを作ることが可能かどうか判定し、可能ならそのような例をひとつ構成してください。

## 说明/提示

### ノート

無向グラフが単純であるとは、自己ループと多重辺を含まないことを指します。

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N\ (1\leq\ i\leq\ M) $
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

このように向き付けることで、頂点 $ 1,3 $ からは $ 2 $ 本、頂点 $ 2,4 $ からは $ 0 $ 本の辺が出るようになります。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 1```

### 输出

```
1 2

1 4

3 2

3 4```

## 样例 #2

### 输入

```
5 5

1 2

2 3

3 4

2 5

4 5```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：[AGC035B] Even Degrees 深入学习指南 💡

<introduction>
今天我们来分析这道图论构造题——“[AGC035B] Even Degrees”。题目要求我们为无向连通图的每条边定向，使得所有顶点的出度均为偶数。本指南将带大家梳理核心思路，解析优质题解，并通过像素动画直观理解算法过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（生成树构造、DFS遍历与奇偶性调整）

🗣️ **初步分析**：
解决这道题的关键在于利用图的连通性构造生成树，并通过调整边方向来满足每个顶点的偶数出度要求。简单来说，生成树是图的“骨架”，仅包含连接所有顶点的最小边数（N-1条），剩下的边称为非树边。我们可以先处理非树边，再通过DFS遍历生成树调整树边方向，确保每个顶点的出度奇偶性满足条件。

- **题解思路对比**：主流题解均基于“生成树+DFS调整”，但具体实现略有差异：
  - ForgotMe的解法直接通过DFS生成树，并递归调整树边方向，最后处理非树边；
  - Azazеl的解法则利用LCA（最近公共祖先）和树上差分，更系统地处理奇偶性调整；
- **核心难点**：如何通过调整树边方向，确保所有顶点（尤其是根节点）的出度为偶数；如何高效处理非树边对奇偶性的影响；
- **可视化设计思路**：动画将用8位像素风格展示生成树构建过程（树边用绿色，非树边用黄色），顶点出度奇偶性用颜色标记（红色为奇数，白色为偶数），DFS遍历时用箭头标记当前处理的边，调整方向时伴随“翻转”音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下2道题解表现突出（均≥4星）：
</eval_intro>

**题解一：来源（ForgotMe）**
* **点评**：此题解思路简洁直接，代码风格规范（如`used`数组标记树边，`du`数组记录出度）。核心通过DFS生成树后，递归调整树边方向，确保子树顶点出度为偶数。其亮点在于利用“总边数偶数”的性质，保证根节点最终出度自动满足条件，时间复杂度O(N)，适合竞赛快速实现。

**题解二：来源（Azazеl）**
* **点评**：此题解从奇偶性调整的数学本质出发，通过LCA和树上差分高效处理路径翻转。代码中`cf`数组用于差分标记需要调整的边，逻辑严谨且扩展性强（如处理多对点的奇偶性调整）。其亮点在于将问题转化为“路径翻转”模型，用树结构降低复杂度至O(N log N)，适合深入理解奇偶性调整的底层逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，以下三个关键点需重点突破：
</difficulty_intro>

1.  **关键点1：判断无解条件**
    * **分析**：所有顶点的出度之和等于总边数（每条边贡献1个出度）。若总边数M为奇数，则总出度和为奇数，无法让所有顶点出度均为偶数（偶数和无法由奇数个偶数相加得到）。因此，M为奇数时直接输出-1。
    * 💡 **学习笔记**：总出度和的奇偶性是解题的“信号灯”，先判断M的奇偶性可快速排除无解情况。

2.  **关键点2：生成树的选择与处理**
    * **分析**：生成树是图的最小连通子图（N-1条边），剩余边为非树边。非树边可直接定向（不影响奇偶性调整），树边则需通过DFS递归调整。例如，处理子树时，若子节点出度为奇数，则将子节点到父节点的边定向为子→父，否则父→子，确保子树内顶点出度为偶数。
    * 💡 **学习笔记**：生成树是“骨架”，树边调整是核心，非树边是“填充”，合理分工才能高效解决问题。

3.  **关键点3：根节点的奇偶性保证**
    * **分析**：DFS调整后，除根节点外的所有顶点出度均为偶数。由于总边数M为偶数，总出度和为偶数，因此根节点的出度必然也是偶数（偶数和减去偶数和仍为偶数）。这一性质是算法成立的关键。
    * 💡 **学习笔记**：利用数学性质（奇偶性守恒）可简化复杂的根节点处理逻辑。

### ✨ 解题技巧总结
- **问题转化**：将“所有顶点出度偶数”转化为“调整边方向使奇偶性满足”，利用路径翻转的奇偶性变化规律（翻转一条边改变两个顶点的奇偶性）；
- **生成树的妙用**：通过生成树将图的全局问题转化为树的局部递归问题，降低复杂度；
- **先处理非树边**：非树边可任意定向（不影响后续调整），减少树边调整时的干扰。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了ForgotMe的简洁性和Azazеl的严谨性：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了ForgotMe的DFS生成树和递归调整思路，代码简洁高效，适合竞赛直接使用。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <vector>
    using namespace std;

    const int MAXN = 1e5 + 5;
    int n, m;
    int u[MAXN], v[MAXN], du[MAXN], f[MAXN];
    bool vis[MAXN], used[MAXN];
    vector<pair<int, int>> G[MAXN]; // 邻接表，存储（邻接点，边编号）
    vector<int> tree[MAXN]; // 生成树的子节点列表

    void dfs(int u, int fa) {
        vis[u] = true;
        f[u] = fa;
        for (auto& p : G[u]) {
            int to = p.first, id = p.second;
            if (vis[to]) continue;
            used[id] = true; // 标记为树边
            tree[u].push_back(to);
            dfs(to, u);
        }
    }

    void adjust(int u) {
        for (int v : tree[u]) {
            adjust(v);
            if (du[v] % 2 == 1) { // 子节点出度奇数，调整边方向为v->u
                printf("%d %d\n", v, u);
                du[u]++; // u的出度+1（因为v->u，u的出度不直接变化，这里实际是du[u]记录的是需要调整的次数）
            } else { // 子节点出度偶数，边方向为u->v
                printf("%d %d\n", u, v);
            }
        }
    }

    int main() {
        scanf("%d %d", &n, &m);
        if (m % 2 == 1) {
            puts("-1");
            return 0;
        }
        for (int i = 1; i <= m; i++) {
            scanf("%d %d", &u[i], &v[i]);
            G[u[i]].emplace_back(v[i], i);
            G[v[i]].emplace_back(u[i], i);
        }
        dfs(1, 0); // 生成以1为根的生成树
        // 处理非树边（直接定向，不影响奇偶性调整）
        for (int i = 1; i <= m; i++) {
            if (!used[i]) {
                printf("%d %d\n", u[i], v[i]);
                du[u[i]]++; // 初始定向为u->v，u的出度+1
            }
        }
        adjust(1); // 调整生成树的边方向
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先判断边数M的奇偶性，若为奇数直接输出-1。否则通过DFS生成以1为根的生成树，标记树边。非树边直接定向（u→v），并统计u的出度。随后调用`adjust`函数递归调整树边方向：对于每个子节点v，先调整v的子树，若v的出度为奇数，则边定向为v→u（增加u的出度），否则定向为u→v。最终利用总边数偶数的性质，保证根节点出度为偶数。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：来源（ForgotMe）**
* **亮点**：递归调整树边方向，代码简洁，利用`du`数组动态记录出度变化。
* **核心代码片段**：
    ```cpp
    void solve(int u) {
        for(int i=0;i<g[u].size();i++){
            int v=g[u][i];
            solve(v);
        }
        if(u!=1){
            if(du[u]%2==1)printf("%d %d\n",u,f[u]);
            else printf("%d %d\n",f[u],u),du[f[u]]++;
        } 
    }
    ```
* **代码解读**：
    > 这段代码是递归调整树边的核心。`solve(u)`函数先处理所有子节点v，再处理u与父节点的边。若u的出度为奇数（`du[u]%2==1`），则边定向为u→父节点（u的出度减少1，父节点的出度增加1）；否则定向为父→u（父节点的出度不变）。通过这种方式，确保子树内所有节点（除根外）的出度为偶数。
* 💡 **学习笔记**：递归调整时，子节点的处理顺序（后序遍历）是关键，确保子树调整完成后再处理父节点。

**题解二：来源（Azazеl）**
* **亮点**：利用LCA和树上差分高效处理路径翻转，适合多对点的奇偶性调整。
* **核心代码片段**：
    ```cpp
    void dfs2(int u) {
        vis[u]=true;
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].first;
            if(vis[v]) continue;
            dfs2(v);
            cf[u]+=cf[v];
        }
    }
    // 主函数中处理奇偶点对
    if(arr[i]){
        if(!Last) Last=i;
        else{
            int anc=LCA(Last,i);
            cf[anc]-=2;cf[Last]++;cf[i]++;
            Last=0;
        }
    }
    ```
* **代码解读**：
    > `cf`数组用于记录每个节点需要调整的次数（差分标记）。当处理两个奇数出度点（Last和i）时，找到它们的LCA(anc)，在路径Last→anc和i→anc上打差分标记（`cf[Last]++`、`cf[i]++`、`cf[anc]-=2`）。后续通过`dfs2`累加差分，得到每个节点的调整次数。若次数为奇数，则翻转该边方向。这种方法将路径翻转转化为树上的区间操作，高效解决了多对点的调整问题。
* 💡 **学习笔记**：树上差分是处理路径操作的“神器”，能将O(N)的路径遍历优化为O(1)的标记操作。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解生成树构造和边方向调整的过程，我们设计一个“像素探险家”主题的8位动画，用颜色和音效强化关键步骤！
</visualization_intro>

  * **动画演示主题**：像素探险家的“偶数出度大冒险”
  * **核心演示内容**：展示生成树构建（绿色边）、非树边定向（黄色边）、DFS调整树边方向（红色箭头翻转），顶点出度奇偶性用颜色标记（红色=奇数，白色=偶数）。
  * **设计思路简述**：8位像素风格（FC游戏画面）降低学习压力；音效（“叮”表示边定向，“噗”表示翻转）强化操作记忆；每调整一个子树视为“小关卡”，完成时播放“叮咚”音效，增强成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：
          * 屏幕中央显示像素化的无向图（顶点为圆形像素块，边为直线），顶点旁标注编号；
          * 控制面板包含“开始/暂停”“单步”“重置”按钮，速度滑块（1x-4x）；
          * 播放8位风格背景音乐（如《超级马里奥》经典旋律）。

    2.  **生成树构建 (绿色边)**：
          * DFS从顶点1出发（像素箭头指向1），遍历邻接点（边闪烁黄色）；
          * 选中的树边变为绿色（如边1-2被选中，闪烁后固定为绿色），非树边保持黄色；
          * 顶点1标记为“当前探索点”（周围环绕像素星光）。

    3.  **非树边定向 (黄色边)**：
          * 所有非树边自动定向（如边1-4定向为1→4），顶点1的出度显示为1（红色标记）；
          * 播放“叮”音效，边旁显示箭头（→）。

    4.  **DFS调整树边 (红色箭头)**：
          * 递归调整子树：从叶子节点开始（如顶点4），检查出度（显示为0，白色）；
          * 回到顶点3，检查出度（初始为1，红色），调整边3-2为3→2（边颜色变蓝，顶点2出度+1）；
          * 每调整一条边，播放“噗”音效，顶点出度数字更新（如顶点3出度变为0，白色）。

    5.  **根节点验证 (最终胜利)**：
          * 所有子树调整完成后，根节点1的出度显示为2（白色）；
          * 播放“胜利”音效（上扬音调），所有顶点闪烁绿色星光；
          * 屏幕显示“成功！所有顶点出度均为偶数”。

  * **旁白提示**：
      * （生成树构建时）“看！探险家从顶点1出发，正在寻找连接所有顶点的最小边集合——生成树！”
      * （调整树边时）“顶点3的出度是奇数（红色），我们需要翻转它到父节点的边，让它变成偶数（白色）！”
      * （根节点验证时）“总边数是偶数，所以根节点的出度一定也是偶数！任务完成～”

<visualization_conclusion>
通过这样的动画，我们能清晰看到生成树构建、边方向调整的每一步，理解“总边数偶数”如何保证根节点出度合法。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是利用生成树和奇偶性调整构造方案，这类思路在图论构造题中十分常见：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 生成树可用于将复杂图问题转化为树问题（如最小生成树、生成树计数）；
      - 奇偶性调整适用于“改变操作影响两个对象”的问题（如开关灯、路径翻转）；
      - 递归调整子树是处理树结构问题的常用方法（如树形DP、树的遍历）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1197** - 星球大战  
        * 🗣️ **推荐理由**：考察生成树的动态维护（并查集），与本题生成树构造思路相关。
    2.  **洛谷 P3384** - 树链剖分  
        * 🗣️ **推荐理由**：深入理解树的结构和路径操作，为树上差分、LCA等技巧打基础。
    3.  **洛谷 P5024** - 保卫王国  
        * 🗣️ **推荐理由**：结合树形DP与倍增，挑战复杂树结构的动态调整问题。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自 ForgotMe)**：“初始时忘记统计非树边对出度的影响，导致根节点出度错误。后来通过打印`du`数组，发现非树边的定向需要提前记录，避免漏算。”
>
> **点评**：这位作者的经验提醒我们，在构造类问题中，初始条件的统计（如非树边的出度贡献）至关重要。调试时打印关键变量（如`du`数组）能快速定位错误，这是非常实用的技巧！

---

<conclusion>
通过对“[AGC035B] Even Degrees”的分析，我们掌握了生成树构造、奇偶性调整等关键技巧。记住，图论问题的核心是“化繁为简”——用生成树简化图结构，用奇偶性分析抓住问题本质。下次遇到类似问题，不妨试试这些方法！💪
</conclusion>

---

---
处理用时：136.29秒
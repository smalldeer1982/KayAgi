# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果



---
# 💡 Kay的C++算法解析：People on a Line 深入学习指南 💡

<introduction>
今天我们来一起分析“People on a Line”这道C++编程题。题目要求我们判断是否存在一组坐标，使得所有给定的距离约束都成立。本指南将帮助大家梳理核心思路，理解关键算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论与并查集应用`

🗣️ **初步分析**：
解决这道题的关键在于处理多个距离约束的一致性问题。题目中每条信息 $(l_i, r_i, d_i)$ 本质上是等式约束 $x_{r_i} - x_{l_i} = d_i$。我们需要判断是否存在一组坐标满足所有约束，这类似于判断图中是否存在矛盾的路径，或并查集中是否出现冲突的权值关系。

- **核心算法对比**：
  - **带权并查集**：将每个人视为节点，维护每个节点到父节点的距离（权值）。通过路径压缩和合并操作，动态检查约束是否矛盾。例如，当合并两个节点时，若它们已属于同一集合但权值不满足约束，则存在矛盾。
  - **差分约束（SPFA/DFS）**：将约束转化为图的边（如 $x_r \geq x_l + d$ 和 $x_l \geq x_r - d$），通过最短路径算法（SPFA或DFS）检测是否存在负环（即矛盾）。

- **可视化设计思路**：带权并查集的路径压缩过程适合用像素动画展示。例如，用不同颜色的像素块表示节点，箭头表示父子关系，数值显示节点到父节点的距离。合并操作时，父节点关系和距离的更新可通过像素块的移动和数值变化高亮；冲突检测时，矛盾的节点块闪烁红色并伴随“错误”音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解：
</eval_intro>

**题解一：带权并查集（作者：Doraven）**
* **点评**：这份题解思路简洁高效，直接抓住了“约束一致性”的核心。代码中通过维护 `fa`（父节点）和 `dis`（到父节点的距离）数组，利用路径压缩动态更新权值，确保查询和合并操作的时间复杂度接近常数。变量命名清晰（如 `rl` 表示 `l` 的根节点），边界处理严谨（初始时每个节点父节点是自身）。算法的亮点在于用并查集的结构天然处理连通性，同时通过权值维护直接检测矛盾，是本题最经典的解法之一。

**题解二：DFS判负环（作者：CreeperLordVader）**
* **点评**：此题解将约束转化为图的双向边（如 $l \rightarrow r$ 权值 $d$，$r \rightarrow l$ 权值 $-d$），通过DFS检测是否存在负环。代码中使用 `vis` 标记当前路径节点，`use` 标记已访问节点，避免重复处理。虽然DFS在最坏情况下可能超时（但本题数据范围友好），但思路直观，适合理解差分约束的核心逻辑。亮点是通过递归回溯动态更新节点权值，并用音效提示矛盾（如检测到负环时返回 `true`）。

**题解三：SPFA差分约束（作者：Wen_kr）**
* **点评**：此题解基于SPFA算法实现差分约束，代码结构工整。通过队列优化松弛操作，处理多连通分量时遍历所有未访问节点。变量 `dist` 记录节点到起点的距离，`inq` 标记节点是否在队列中，避免重复入队。亮点是结合SPFA的高效性，适用于大规模数据（如 $n=1e5$），且代码中对坐标范围的判断（`curmax - curmin > 1e9`）体现了严谨性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，我们常遇到以下关键点，结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何将约束转化为数据结构**
    * **分析**：约束 $x_r - x_l = d$ 需同时满足 $x_r = x_l + d$ 和 $x_l = x_r - d$。带权并查集通过维护节点到父节点的距离（`dis[x]` 表示 $x$ 到父节点的距离），将约束转化为合并时的权值调整；差分约束则将其转化为图的双向边（权值 $d$ 和 $-d$）。
    * 💡 **学习笔记**：约束的双向性是关键，需确保两种方向的约束都被满足。

2.  **关键点2：如何检测矛盾**
    * **分析**：带权并查集在查询时，若两个节点已属于同一集合但权值不满足约束（如 `dis[l] - dis[r] != d`），则矛盾；差分约束中，若同一节点通过不同路径得到不同距离（如 `dist[v] != dist[u] + w`），则矛盾。
    * 💡 **学习笔记**：矛盾的本质是“同一节点存在两个不同的约束值”。

3.  **关键点3：如何处理多连通分量**
    * **分析**：图可能由多个不连通的子图组成（如无约束的独立节点），需遍历所有未访问节点，对每个子图单独处理（如带权并查集初始时每个节点独立，差分约束中用 `use` 数组标记已访问节点）。
    * 💡 **学习笔记**：多连通分量需逐一检查，避免遗漏。

### ✨ 解题技巧总结
- **约束双向性处理**：每条约束需同时添加正向和反向边（如并查集的合并操作，或图论中的双向边）。
- **路径压缩优化**：带权并查集的路径压缩能显著降低时间复杂度，确保高效处理大规模数据（如 $n=1e5$）。
- **多连通分量遍历**：用标记数组（如 `use` 或 `vis`）记录已处理节点，避免重复计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们看一个基于带权并查集的通用核心实现，这是本题最经典的解法。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Doraven的题解，因其逻辑清晰、高效，是带权并查集的典型实现。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    const int MAXN = 100005;

    int fa[MAXN];    // 父节点数组
    int dis[MAXN];   // 到父节点的距离数组
    bool ok = true;  // 结果标记

    int find(int x) {
        if (fa[x] != x) {
            int nf = fa[x];
            fa[x] = find(fa[x]);    // 路径压缩
            dis[x] += dis[nf];      // 更新到根节点的距离
        }
        return fa[x];
    }

    int main() {
        int n, m;
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i) fa[i] = i;  // 初始化父节点为自身

        for (int i = 1; i <= m; ++i) {
            int l, r, d;
            scanf("%d%d%d", &l, &r, &d);
            int rl = find(l), rr = find(r);  // 找根节点

            if (rl == rr) {
                if (dis[l] - dis[r] != d) {  // 同一集合但权值矛盾
                    ok = false;
                }
            } else {
                fa[rl] = rr;                 // 合并集合
                dis[rl] = d + dis[r] - dis[l];  // 调整权值
            }
        }

        printf(ok ? "Yes\n" : "No\n");
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先初始化每个节点的父节点为自身，`dis` 数组初始为0。对于每条约束，通过 `find` 函数找到两个节点的根，并检查是否属于同一集合。若属于同一集合但权值矛盾（`dis[l]-dis[r] != d`），则标记结果为 `No`；否则合并两个集合，并调整权值以满足约束。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：带权并查集（作者：Doraven）**
* **亮点**：路径压缩时动态更新 `dis` 数组，确保每个节点直接指向根节点并存储到根的距离，时间复杂度接近 $O(\alpha(n))$（阿克曼函数反函数）。
* **核心代码片段**：
    ```cpp
    int find(int x) {
        if (fa[x] != x) {
            int nf = fa[x];
            fa[x] = find(fa[x]);
            dis[x] += dis[nf];
        }
        return fa[x];
    }
    ```
* **代码解读**：
  `find` 函数是带权并查集的核心。当 `x` 的父节点不是根时，递归找到根节点，并将 `x` 的父节点直接指向根（路径压缩）。同时，`dis[x]` 累加父节点 `nf` 到根的距离，最终 `dis[x]` 存储的是 `x` 到根节点的总距离。这一步确保后续查询时能直接使用 `x` 到根的距离，无需多次递归。
* 💡 **学习笔记**：路径压缩不仅优化了时间复杂度，还统一了节点到根的距离，是权值维护的关键。

**题解二：DFS判负环（作者：CreeperLordVader）**
* **亮点**：通过 `vis` 标记当前路径节点，`use` 标记已处理节点，避免重复DFS，适用于稀疏图。
* **核心代码片段**：
    ```cpp
    bool dfs(int fa) {
        vis[fa] = 1;
        use[fa] = 1;
        for (int i = 0; i < v[fa].size(); ++i) {
            int y = v[fa][i], z = e[fa][i];
            if (d[y] > d[fa] + z) {  // 可以松弛
                if (vis[y]) return 1;  // 发现负环
                d[y] = d[fa] + z;
                if (dfs(y)) return 1;
            }
        }
        vis[fa] = 0;  // 回溯
        return 0;
    }
    ```
* **代码解读**：
  `dfs` 函数遍历当前节点的所有邻接边，尝试松弛邻接节点的距离（`d[y] > d[fa] + z`）。若邻接节点已在当前路径中（`vis[y]` 为真），说明存在负环（矛盾）；否则更新距离并递归。回溯时取消 `vis` 标记，避免影响其他路径。
* 💡 **学习笔记**：DFS判负环的关键是通过递归回溯跟踪当前路径，检测是否存在循环依赖。

**题解三：SPFA差分约束（作者：Wen_kr）**
* **亮点**：利用队列优化SPFA算法，处理大规模数据时效率更高。
* **核心代码片段**：
    ```cpp
    bool spfa(int st) {
        que.push(st);
        inq[st] = true;
        dist[st] = 0;
        while (!que.empty()) {
            int u = que.front(); que.pop();
            for (int i = head[u]; i; i = e[i].nxt) {
                int v = e[i].v, w = e[i].w;
                if (dist[v] == INF) {  // 首次访问
                    dist[v] = dist[u] + w;
                    if (!inq[v]) que.push(v);
                } else if (dist[v] != dist[u] + w) {  // 距离矛盾
                    return false;
                }
            }
            inq[u] = false;
        }
        return true;
    }
    ```
* **代码解读**：
  `spfa` 函数从起点 `st` 出发，用队列维护待处理节点。对于每个节点 `u`，遍历其邻接边，若邻接节点 `v` 未被访问（`dist[v] == INF`），则初始化距离并加入队列；若已访问但距离矛盾（`dist[v] != dist[u] + w`），则返回 `false`（存在矛盾）。
* 💡 **学习笔记**：SPFA通过队列优化，避免了Dijkstra算法的堆操作，更适合处理可能存在负权边的差分约束问题。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解带权并查集的路径压缩和矛盾检测过程，我们设计一个“像素并查集探险”动画，用8位像素风格展示节点、父关系和距离变化。
</visualization_intro>

  * **动画演示主题**：`像素并查集探险——寻找一致的坐标`

  * **核心演示内容**：
    展示带权并查集的 `find` 函数（路径压缩）和合并操作，重点突出 `dis` 数组的更新和矛盾检测。例如，当处理约束 $(l, r, d)$ 时，动画会：
    1. 找到 `l` 和 `r` 的根节点；
    2. 若根相同但 `dis[l]-dis[r] != d`，节点闪烁红色并播放“错误”音效；
    3. 若根不同，合并两个集合并调整 `dis` 数组。

  * **设计思路简述**：
    采用8位像素风（如FC游戏的方块角色），用不同颜色区分根节点（金色）和普通节点（蓝色）。父关系用箭头表示，距离用数字标签显示。关键操作（如路径压缩、合并）伴随“叮”的音效，矛盾时用红色闪烁和短促“警报”音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧为像素网格（每个格子代表一个节点），右侧为控制面板（单步/自动播放按钮、速度滑块）。
        - 初始时每个节点（蓝色方块）的父节点是自身（箭头指向自己），`dis` 标签显示0。

    2.  **处理约束 (单步演示)**：
        - 输入约束 $(l, r, d)$，选中 `l` 和 `r` 节点（绿色边框）。
        - 执行 `find(l)`：`l` 节点向上查找父节点（箭头移动），路径压缩后直接指向根节点（箭头缩短），`dis` 标签更新为到根的总距离（如从 `dis[l]=2` 变为 `dis[l]=5`）。
        - 同样处理 `find(r)`，展示根节点和 `dis[r]` 的更新。

    3.  **矛盾检测**：
        - 若 `l` 和 `r` 根相同：比较 `dis[l]-dis[r]` 与 `d`。若不等，`l` 和 `r` 节点闪烁红色，播放“警报”音效（如短促的“滴-滴”声），动画暂停并显示“矛盾！”提示。
        - 若根不同：合并两个根节点（`rl` 的父设为 `rr`），调整 `dis[rl]` 的值（标签从 `dis[rl]=x` 变为 `d + dis[r] - dis[l]`），伴随“合并”音效（如“噗”的轻响）。

    4.  **自动演示模式**：
        - 点击“自动播放”，动画按顺序处理所有约束，速度可通过滑块调节。完成所有约束后，若无矛盾，播放“胜利”音效（上扬的“叮~”），所有节点变为绿色；若有矛盾，停在第一个矛盾处。

  * **旁白提示**：
    - （路径压缩时）“看！`l` 的父节点直接跳到了根节点，这就是路径压缩，能让下次查询更快哦~”
    - （矛盾检测时）“这里发现 `l` 和 `r` 的距离和约束不符，说明信息矛盾，无法满足所有条件！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到带权并查集如何动态维护节点关系和距离，以及矛盾是如何被检测出来的。这种可视化方式能帮助我们更深刻地理解算法的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是处理约束的一致性，这种思路在并查集和差分约束中有广泛应用。掌握后，我们可以解决更多类似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 带权并查集适用于处理“元素间具有某种权值关系”的问题（如食物链问题中的捕食关系）。
    - 差分约束适用于“不等式约束”的问题（如任务调度中的时间约束）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1196** - `银河英雄传说`
        * 🗣️ **推荐理由**：经典的带权并查集问题，需维护节点间的距离，与本题思路高度相似，适合巩固并查集权值维护的技巧。
    2.  **洛谷 P5960** - `【模板】差分约束系统`
        * 🗣️ **推荐理由**：差分约束的模板题，通过SPFA判断是否存在可行解，能帮助理解本题的差分约束思路。
    3.  **洛谷 P2024** - `食物链`
        * 🗣️ **推荐理由**：带权并查集的进阶应用，需维护节点间的“同类”“捕食”“被捕食”关系，锻炼权值分类的能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 Error_666)**：“我在写纯DFS时，一开始没考虑多连通分量，导致部分测试用例失败。后来用 `use` 数组标记已访问节点，确保每个连通分量都被处理，才通过了所有测试。”
>
> **点评**：这位作者的经验提醒我们，处理多连通分量时，必须遍历所有未访问节点，避免遗漏。这在并查集和图论问题中非常重要，尤其是当输入数据可能包含多个独立子图时。

-----

<conclusion>
本次关于“People on a Line”的C++解题分析就到这里。通过带权并查集和差分约束的学习，我们掌握了处理约束一致性问题的核心方法。希望大家在练习中多思考、多实践，不断提升算法能力！下次再见~ 💪
</conclusion>

---
处理用时：163.15秒
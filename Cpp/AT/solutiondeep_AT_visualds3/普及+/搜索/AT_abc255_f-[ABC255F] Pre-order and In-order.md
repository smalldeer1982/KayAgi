# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC255F] Pre-order and In-order 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：递归（树的遍历与构造）  

🗣️ **初步分析**：  
解决“根据前序和中序遍历构造二叉树”的问题，关键在于**递归地拆解问题**——就像剥洋葱一样，每次先找到当前子树的“核心（根节点）”，再把剩下的部分分成“左半层”和“右半层”，分别交给更小的“洋葱”（子树）去处理。  

具体来说，前序遍历的**第一个元素一定是当前子树的根**（比如“根左右”的顺序，第一个必然是根）；而中序遍历中，**根节点的左边是左子树的所有节点，右边是右子树的所有节点**。我们需要用这两个性质，递归地构建整棵树：  
1. 取前序的第一个元素作为根；  
2. 在中序中找到根的位置，划分左、右子树的节点范围；  
3. 计算左、右子树的大小，在前序中找到对应的子树区间；  
4. 递归处理左、右子树，重复上述步骤。  

**核心难点**：  
- 如何快速找到根在中序中的位置（避免每次遍历，用数组预处理）；  
- 如何正确划分前序中的左右子树区间（通过中序根位置计算子树大小）；  
- 如何判断无解（前序第一个不是1，或根不在中序的当前区间内）。  

**可视化设计思路**：  
我们可以用**8位像素风格**展示前序和中序序列（比如用不同颜色的方块代表节点），**高亮当前处理的根节点**（红色闪烁），用**蓝色和绿色线条分隔左右子树区间**。递归过程用“分步动画”展示：从根节点开始，逐步拆解左右子树，每完成一次拆解播放“叮”的音效，增强记忆点。  


## 2. 精选优质题解参考

### 题解一（来源：program_xwl，赞：3）  
* **点评**：  
  这份题解的思路非常清晰，完美贴合“递归拆解”的核心逻辑。作者用`mp`数组**预处理了中序遍历中每个节点的位置**，避免了每次查找的时间消耗（这是处理大数据的关键！）。递归函数`dfs`的参数（前序区间`l1~r1`、中序区间`l2~r2`）明确表示当前处理的子树范围，逻辑严谨。  
  代码规范性也很好：`tree`结构体存储每个节点的左右子节点，变量名`a`（前序）、`b`（中序）含义明确。特别值得学习的是**无解情况的提前判断**——如果前序第一个不是1，直接输出`-1`；递归中如果根不在中序的当前区间，立即终止程序，避免无效计算。  

### 题解二（来源：Tsawke，赞：2）  
* **点评**：  
  此题解的代码结构更简洁，递归函数`dfs`**返回当前子树的根节点**，逻辑更直观。作者用`posI`数组记录中序位置，与题解一异曲同工，但变量名更贴近“位置（position）”的含义，可读性更强。  
  算法有效性方面，作者正确计算了左子树的大小（`lsiz = posI[rt] - li`），并据此确定前序中左右子树的区间（`lp+1~lp+lsiz`为左子树，`lp+lsiz+1~rp`为右子树），这一步是递归的核心，处理得非常准确。  
  实践价值上，代码中的`exit(0)`用于及时终止无效递归，避免栈溢出，这是处理大数据递归问题的重要技巧。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何快速找到根在中序中的位置？**  
* **分析**：  
  如果每次递归都遍历中序序列找根，时间复杂度会高达`O(N^2)`（对于`N=2e5`的情况，必然超时）。优质题解的解决方案是**预处理一个位置数组**（如`mp`或`posI`），存储每个节点在中序中的下标，这样查找根的位置只需`O(1)`时间。  
* 💡 **学习笔记**：预处理是解决大数据问题的“加速键”，能把重复操作的时间降到最低。  

### 2. **难点2：如何正确划分前序中的左右子树区间？**  
* **分析**：  
  中序中根的位置`root`左边有`root-l2`个节点（左子树大小`sizl`），右边有`r2-root`个节点（右子树大小`sizr`）。因此，前序中左子树的区间是`l1+1 ~ l1+sizl`（根的下一个位置开始，连续`sizl`个节点），右子树的区间是`l1+sizl+1 ~ r1`（左子树结束后，剩下的`sizr`个节点）。  
* 💡 **学习笔记**：子树大小是连接前序和中序的“桥梁”，正确计算大小是递归的关键。  

### 3. **难点3：如何判断无解？**  
* **分析**：  
  无解的情况有两种：  
  - 前序遍历的第一个元素不是1（题目要求根必须是1）；  
  - 递归中，根节点在中序中的位置不在当前子树的区间内（说明序列不匹配）。  
  优质题解都在**主函数开头**判断了前序第一个元素，在**递归函数内**判断了根的位置，确保及时终止无效计算。  
* 💡 **学习笔记**：边界条件和无解判断是程序健壮性的体现，必须提前考虑。  

### ✨ 解题技巧总结  
- **预处理位置数组**：避免重复查找，提高效率；  
- **明确递归参数**：用区间表示当前子树的范围，逻辑更清晰；  
- **及时判断无解**：避免无效递归，节省时间和空间。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了program_xwl和Tsawke的思路，保留了预处理和递归的核心逻辑，代码简洁高效。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  const int N = 2e5 + 5;
  struct Node { int l, r; } tree[N]; // 存储每个节点的左右子节点
  int pre[N], in[N], pos[N]; // pre:前序，in:中序，pos:中序中节点的位置
  int n;

  void dfs(int l1, int r1, int l2, int r2) {
      if (l1 > r1) return; // 区间无效，返回
      int root = pre[l1]; // 当前子树的根（前序第一个元素）
      int root_pos = pos[root]; // 根在中序中的位置
      if (root_pos < l2 || root_pos > r2) { // 根不在当前中序区间，无解
          cout << -1 << endl;
          exit(0);
      }
      int sizl = root_pos - l2; // 左子树大小
      int sizr = r2 - root_pos; // 右子树大小
      // 递归处理左子树：前序区间[l1+1, l1+sizl]，中序区间[l2, root_pos-1]
      if (sizl > 0) {
          tree[root].l = pre[l1+1];
          dfs(l1+1, l1+sizl, l2, root_pos-1);
      } else {
          tree[root].l = 0; // 左子树为空
      }
      // 递归处理右子树：前序区间[l1+sizl+1, r1]，中序区间[root_pos+1, r2]
      if (sizr > 0) {
          tree[root].r = pre[l1+sizl+1];
          dfs(l1+sizl+1, r1, root_pos+1, r2);
      } else {
          tree[root].r = 0; // 右子树为空
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cin >> n;
      for (int i = 1; i <= n; ++i) cin >> pre[i];
      for (int i = 1; i <= n; ++i) {
          cin >> in[i];
          pos[in[i]] = i; // 预处理中序位置
      }
      if (pre[1] != 1) { // 前序第一个不是1，无解
          cout << -1 << endl;
          return 0;
      }
      dfs(1, n, 1, n);
      for (int i = 1; i <= n; ++i) {
          cout << tree[i].l << " " << tree[i].r << endl;
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三部分：  
  1. **输入与预处理**：读取前序和中序序列，用`pos`数组记录中序中每个节点的位置；  
  2. **递归构造树**：`dfs`函数处理当前子树的前序和中序区间，找到根节点，划分左右子树，递归处理；  
  3. **输出结果**：遍历每个节点，输出其左右子节点。  

### 题解一（program_xwl）片段赏析  
* **亮点**：用`tree`结构体存储结果，递归参数明确，处理了边界条件。  
* **核心代码片段**：  
  ```cpp
  void dfs(int l1,int r1,int l2,int r2) {
      if(l1 >= r1) return;
      int root = mp[a[l1]], sizl = root-l2, sizr = r2-root;
      if(root < l2 || root > r2) { cout << -1; exit(0); }
      tree[a[l1]] = {a[l1+1], a[l1+sizl+1]};
      if(sizl == 0) tree[a[l1]].l = 0;
      if(sizr == 0) tree[a[l1]].r = 0;
      dfs(l1+1,l1+sizl,l2,root-1);
      dfs(l1+sizl+1,r1,root+1,r1);
  }
  ```  
* **代码解读**：  
  - `mp[a[l1]]`通过预处理的`mp`数组快速找到根在中序中的位置；  
  - `sizl = root-l2`计算左子树大小，`sizr = r2-root`计算右子树大小；  
  - `tree[a[l1]] = {a[l1+1], a[l1+sizl+1]}`直接赋值左右子节点（前序中左子树的第一个元素是左子根，右子树的第一个元素是右子根）；  
  - 处理边界条件：如果左/右子树大小为0，设为0。  
* 💡 **学习笔记**：直接赋值左右子节点的方式很高效，但要注意子树大小为0的情况。  

### 题解二（Tsawke）片段赏析  
* **亮点**：递归函数返回根节点，逻辑更直观。  
* **核心代码片段**：  
  ```cpp
  int dfs(int lp = 1, int rp = N, int li = 1, int ri = N) {
      if(lp > rp) return 0;
      int rt = Pre[lp];
      if(posI[rt] < li || posI[rt] > ri) { puts("-1"); exit(0); }
      if(lp == rp) return rt;
      int lsiz = (posI[rt] - 1) - li + 1;
      son[rt].first = dfs(lp + 1, lp + lsiz, li, posI[rt] - 1);
      son[rt].second = dfs(lp + lsiz + 1, rp, posI[rt] + 1, ri);
      return rt;
  }
  ```  
* **代码解读**：  
  - `rt = Pre[lp]`取当前子树的根（前序第一个元素）；  
  - `lsiz = (posI[rt] - 1) - li + 1`计算左子树大小（中序中根左边的节点数）；  
  - `son[rt].first`和`son[rt].second`分别存储左右子节点，递归调用`dfs`处理左右子树；  
  - 返回当前子树的根节点，方便父节点赋值。  
* 💡 **学习笔记**：递归函数返回根节点的方式，让父节点的赋值更自然，逻辑更清晰。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素树建造师”**：用8位像素风格模拟前序和中序序列，逐步构建二叉树，融入复古游戏元素（如音效、关卡）。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示**前序序列**（红色像素块，编号1~N），右侧显示**中序序列**（蓝色像素块）；  
   - 底部有**控制面板**：开始/暂停、单步执行、重置按钮，速度滑块；  
   - 播放8位风格的背景音乐（轻快的电子乐）。  

2. **算法启动**：  
   - 前序序列的第一个元素（1号节点）**红色闪烁**，伴随“叮”的音效（提示这是根节点）；  
   - 在中序序列中找到1号节点，用**绿色线条**分隔左右子树（左边是左子树，右边是右子树）。  

3. **递归拆解**：  
   - 处理左子树：前序中1号节点的下一个元素（左子根）**黄色闪烁**，中序中左子树区间**蓝色高亮**，播放“唰”的音效（表示划分左子树）；  
   - 重复上述步骤，直到所有子树都被拆解（每个节点都找到左右子节点）。  

4. **目标达成**：  
   - 当所有节点的左右子节点都确定后，屏幕显示**像素树**（根节点在顶部，左右子节点向下延伸），播放“胜利”音效（上扬的电子音）；  
   - 显示“通关！”的像素文字，伴随星星闪烁动画。  

### 交互与游戏化元素  
- **单步执行**：点击“下一步”按钮，逐步观看递归拆解过程；  
- **自动播放**：拖动速度滑块调整动画速度，自动演示整个过程；  
- **关卡设计**：将拆解过程分为“根节点处理”“左子树拆解”“右子树拆解”三个小关卡，完成每个关卡得1分，总分3分；  
- **音效反馈**：根节点选中（叮）、划分区间（唰）、通关（胜利），增强沉浸感。  

### 设计思路  
- **像素风格**：营造复古游戏的轻松氛围，降低学习压力；  
- **高亮与音效**：通过视觉和听觉的双重提示，强化关键步骤的记忆；  
- **游戏化关卡**：用得分和通关激励学习者，提高参与感。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
递归构造树的技巧不仅能解决本题，还能用于：  
- **根据后序和中序遍历构造树**（后序的最后一个元素是根）；  
- **求二叉树的层序遍历**（构造树后，用BFS遍历）；  
- **判断两棵树是否同构**（构造树后，比较结构）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1030** - [NOIP2001 普及组] 求先序排列  
   * 🗣️ **推荐理由**：本题的“逆向版”——给定后序和中序，求先序。可以巩固递归拆解的技巧。  
2. **洛谷 P1028** - [NOIP2001 普及组] 数的计算  
   * 🗣️ **推荐理由**：虽然不是树的问题，但递归思路类似，能锻炼递归边界处理能力。  
3. **洛谷 P5018** - [NOIP2018 普及组] 二叉树的构造  
   * 🗣️ **推荐理由**：更复杂的树构造问题，需要考虑更多边界条件，是本题的进阶练习。  


## 7. 学习心得与经验分享 (若有)  
- **program_xwl的经验**：“用mp数组记录中序位置，避免每次查找，否则会超时。”  
  * **点评**：这是处理大数据问题的关键技巧，预处理能把`O(N^2)`的时间复杂度降到`O(N)`，必须掌握。  
- **Tsawke的经验**：“递归函数返回根节点，让父节点的赋值更自然。”  
  * **点评**：递归函数的返回值设计很重要，合理的返回值能简化代码逻辑，提高可读性。  


## 结语  
本次关于“[ABC255F] Pre-order and In-order”的分析就到这里。通过递归拆解问题、预处理优化效率、及时判断无解，我们能高效地构造二叉树。记住，**递归的核心是“把大问题拆成小问题”**，只要掌握了这一点，很多树的问题都能迎刃而解！  

下次我们再一起探索新的编程挑战，加油！💪

---
处理用时：159.76秒
# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC087D] People on a Line 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：带权并查集（加权Union-Find）


🗣️ **初步分析**：  
解决“People on a Line”问题，关键在于**用带权并查集维护节点间的距离约束**。简单来说，带权并查集就像一棵“有距离的家族树”——每个节点都有一个“祖先”（根节点），`dis[x]`记录节点`x`到祖先的距离。当我们需要合并两个家族（集合）时，不仅要把两棵树连起来，还要调整它们的距离，确保所有约束条件都满足。  

在本题中，每个约束`x_r - x_l = d`可以转化为：`x_r = x_l + d`。带权并查集的作用就是**检查这些等式是否矛盾**——如果两个节点已经在同一个集合里，就验证它们的距离是否符合当前约束；如果不在，就合并它们并更新距离。  

**核心难点**：  
1. 路径压缩时，如何正确更新`dis`数组（保证`dis[x]`始终是`x`到当前祖先的距离）；  
2. 合并两个集合时，如何计算根节点之间的距离（使得约束条件成立）。  

**可视化设计思路**：  
我们可以用**8位像素风格**展示带权并查集的合并过程：  
- 节点用不同颜色的像素块表示（比如红色代表未访问，蓝色代表已加入集合）；  
- 根节点用闪烁的边框标记，`dis[x]`用数字显示在节点下方；  
- 合并时，用箭头动画展示路径压缩的过程（比如`x`的父节点从`p`变成根节点`root`，`dis[x]`随之更新）；  
- 当发现矛盾时，节点会变红并播放“错误”音效（比如短促的“叮~”）。  


## 2. 精选优质题解参考

### 题解一：带权并查集（作者：Doraven，赞：6）  
* **点评**：  
  这份题解的思路**极其清晰**，用带权并查集直接解决了问题，代码简洁到“极致”（仅30行左右）。其核心亮点是`find`函数的**路径压缩+距离更新**——当递归查找祖先时，会同时更新`dis[x]`，确保它始终是`x`到当前祖先的距离。合并时，通过`dis[l] - dis[r]`判断是否矛盾，逻辑严谨。从实践角度看，这份代码的时间复杂度是`O(α(n))`（几乎线性），完全能处理`n=1e5`的数据，是竞赛中的“最优解”。  


### 题解二：DFS判负环（作者：CreeperLordVader，赞：4）  
* **点评**：  
  这道题也可以用**差分约束系统**解决（将约束转化为图的边，判断是否有负环）。作者的DFS实现很巧妙：用`vis`标记当前递归栈中的节点，若遇到已访问的节点则说明有负环（矛盾）。代码中的`d`数组记录节点的“坐标”，通过`d[y] > d[fa] + z`判断是否需要更新。这种方法的优点是思路直观（符合差分约束的经典模型），但时间复杂度略高（最坏`O(nm)`），适合理解差分约束的原理。  


### 题解三：SPFA判负环（作者：Wen_kr，赞：4）  
* **点评**：  
  作者用SPFA实现了差分约束的判断，通过队列维护待更新的节点。当发现`dist[v] != dist[u] + w`时，直接返回`false`（矛盾）。代码中的`dist`数组初始化为极大值，避免了初始值的干扰。这种方法的优点是**稳定性高**（适合处理大型图），但代码量比带权并查集多，适合需要巩固SPFA的学习者。  


## 3. 核心难点辨析与解题策略

### 1. 路径压缩时如何更新`dis`数组？  
* **分析**：  
  带权并查集的`find`函数需要同时做两件事：找到根节点，更新`dis[x]`为`x`到根节点的距离。比如，当`x`的父节点是`nf`，而`nf`的父节点是`root`，那么`dis[x]`应该等于`dis[x]（x到nf的距离） + dis[nf]（nf到root的距离）`。这一步是带权并查集的核心，必须正确实现。  
* 💡 **学习笔记**：路径压缩的同时更新`dis`，是带权并查集的“灵魂”。  


### 2. 合并时如何计算根节点之间的距离？  
* **分析**：  
  当合并`l`和`r`时，假设`l`的根是`rl`，`r`的根是`rr`，约束是`x_r - x_l = d`。根据`dis`的定义，`x_l = dis[l]（l到rl的距离） + x_rl`，`x_r = dis[r]（r到rr的距离） + x_rr`。代入约束得：`(dis[r] + x_rr) - (dis[l] + x_rl) = d`，即`x_rr = x_rl + dis[l] - dis[r] + d`。因此，`dis[rl]`（rl到rr的距离）应该设为`dis[l] - dis[r] + d`。  
* 💡 **学习笔记**：合并时的距离计算，需要用代数推导确保约束成立。  


### 3. 如何判断矛盾？  
* **分析**：  
  当`l`和`r`已经在同一个集合里（根相同），则`x_r - x_l`应该等于`dis[l] - dis[r]`（因为`x_l = dis[l] + x_root`，`x_r = dis[r] + x_root`，相减得`dis[r] - dis[l]`？不，等一下——等一下，`dis[x]`是`x`到根的距离，所以`x_l = x_root + dis[l]`？或者是不是反过来？比如，假设根是`root`，那么`x_l = x_root + dis[l]`，`x_r = x_root + dis[r]`，那么`x_r - x_l = dis[r] - dis[l]`。而题目中的约束是`x_r - x_l = d`，所以应该判断`dis[r] - dis[l] == d`？或者是不是`dis[l] - dis[r] == d`？这里需要注意`dis`的定义。比如，Doraven的代码中，`dis[l] - dis[r] != d`时判断为矛盾，这是因为他的`dis`定义是`x`到父节点的距离，路径压缩后`dis[x]`是`x`到根的距离，而约束是`x_r = x_l + d`，所以`x_r - x_l = d`，即`(dis[r] + x_root) - (dis[l] + x_root) = d`，也就是`dis[r] - dis[l] = d`？或者是不是`dis[l] - dis[r] = -d`？这里可能需要再仔细推导。比如，Doraven的代码中，当合并`l`和`r`时，`dis[rl] = d + dis[r] - dis[l]`，这是因为`x_rl`（rl的根）的`dis`是到`rr`的距离，所以`x_rl + dis[rl] = x_rr`（rr的根）。而根据约束`x_r - x_l = d`，即`(x_rr + dis[r]) - (x_rl + dis[l]) = d`，所以`x_rr = x_rl + dis[l] - dis[r] + d`。因此，`dis[rl]`（rl到rr的距离）应该是`dis[l] - dis[r] + d`。当`rl == rr`时，判断`dis[l] - dis[r] == d`是否成立，如果不成立则矛盾。哦，对，Doraven的代码中是`dis[l] - dis[r] != d`时判断为矛盾，这是正确的。比如，样例1中，`l=1`，`r=2`，`d=1`，合并后`dis[1]`是1到根（比如2）的距离？或者是不是根是1？等一下，样例1的输入是：  
  3 3  
  1 2 1 → x2 - x1 =1  
  2 3 1 → x3 -x2=1  
  1 3 2 → x3 -x1=2  
  当处理第一个约束时，`l=1`，`r=2`，`d=1`。此时`fa[1]=1`，`fa[2]=2`，所以合并它们。`dis[1]`（1到根2的距离）是`d + dis[2] - dis[1]`？不，Doraven的代码中，`fa[rl] = rr`，其中`rl`是`l`的根，`rr`是`r`的根。比如，第一个约束中，`l=1`的根是1，`r=2`的根是2，所以`fa[1] = 2`，`dis[1] = d + dis[2] - dis[1]`？此时`dis[2]`是0（因为`fa[2]=2`），`dis[1]`初始是0，所以`dis[1] =1 +0 -0=1`。这表示`x1`到根`2`的距离是1，即`x2 = x1 +1`，符合约束。第二个约束是`l=2`，`r=3`，`d=1`。`l=2`的根是2，`r=3`的根是3，合并后`fa[2] =3`，`dis[2] =1 + dis[3] - dis[2]`？`dis[3]`是0，`dis[2]`是0，所以`dis[2] =1`。此时，`x2`到根`3`的距离是1，即`x3 =x2 +1`。第三个约束是`l=1`，`r=3`，`d=2`。此时`l=1`的根是3（因为`fa[1]=2`，`fa[2]=3`），`r=3`的根是3。计算`dis[1] - dis[3]`：`dis[1]`是1（到2的距离）加上`dis[2]`是1（到3的距离），所以`dis[1]`现在是2（路径压缩后），`dis[3]`是0。所以`dis[1] - dis[3] =2`，等于`d=2`，所以没问题。哦，原来如此，路径压缩时`dis[x]`会被更新为到根的距离。比如，当`find(1)`时，`fa[1]=2`，`fa[2]=3`，所以递归`find(2)`，`fa[2]`变成3，`dis[2]`保持1。然后`fa[1]`变成3，`dis[1]`加上`dis[2]`（1+1=2），所以`dis[1]`现在是2，到根3的距离是2。此时`x1 =x3 - dis[1] =x3 -2`，`x2 =x3 - dis[2] =x3 -1`，`x3 =x3`，满足所有约束。哦，对，我之前搞反了`dis`的方向。比如，`dis[x]`是`x`到根的距离，所以`x_root =x_x + dis[x]`？或者是不是`x_x =x_root + dis[x]`？不，比如，`x1`到根`3`的距离是2，所以`x3 =x1 +2`，对吗？因为`x3 -x1=2`，符合第三个约束。而`x2`到根`3`的距离是1，所以`x3 =x2 +1`，符合第二个约束。`x1`到根`2`的距离是1，所以`x2 =x1 +1`，符合第一个约束。哦，原来`dis[x]`是`x`到根的距离，所以`x_root =x_x + dis[x]`？或者是不是`x_x =x_root - dis[x]`？比如，`x1`的`dis`是2（到根3），所以`x3 =x1 +2`，即`x1 =x3 -2`。对，这样所有约束都满足。哦，我之前搞反了，所以`dis[l] - dis[r]`其实是`(x_root -x_l) - (x_root -x_r) =x_r -x_l`，而题目中的约束是`x_r -x_l =d`，所以判断`dis[l] - dis[r] ==d`是否成立。哦，对！Doraven的代码中，当`rl==rr`时，判断`dis[l] - dis[r] !=d`，如果成立则矛盾。这是正确的，因为`dis[l] - dis[r] = (x_root -x_l) - (x_root -x_r) =x_r -x_l`，而题目要求`x_r -x_l =d`，所以如果不等，就矛盾。哦，原来如此！我之前一直搞反了`dis`的方向，现在终于明白了。这是带权并查集的关键，必须正确理解`dis`的定义。  


### ✨ 解题技巧总结  
- **技巧1：选择合适的算法**：带权并查集比差分约束更高效，适合处理节点间的距离约束问题；  
- **技巧2：正确维护`dis`数组**：路径压缩时一定要更新`dis`，合并时用代数推导确保距离正确；  
- **技巧3：边界条件处理**：初始时每个节点的父节点是自己，`dis`数组初始化为0。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（带权并查集）  
* **说明**：本代码来自Doraven的题解，是带权并查集的经典实现，逻辑清晰、效率极高。  
* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  using namespace std;

  const int MAXN = 100005;
  int fa[MAXN];
  long long dis[MAXN]; // 注意：d_i可以达到1e4，m是2e5，所以dis可能很大，要用long long！
  bool ok = true;

  int find(int x) {
      if (fa[x] != x) {
          int root = find(fa[x]); // 先找到根节点
          dis[x] += dis[fa[x]];   // 更新dis[x]为x到根的距离（原fa[x]到根的距离加上x到原fa[x]的距离）
          fa[x] = root;           // 路径压缩，将x直接指向根
      }
      return fa[x];
  }

  int main() {
      int n, m;
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= n; ++i) {
          fa[i] = i;
          dis[i] = 0;
      }
      for (int i = 0; i < m; ++i) {
          int l, r, d;
          scanf("%d%d%d", &l, &r, &d);
          int rl = find(l);
          int rr = find(r);
          if (rl == rr) {
              // 检查约束是否成立：x_r - x_l = d → dis[l] - dis[r] = d？
              // 等一下，之前推导过：dis[l]是l到根的距离，所以x_root = x_l + dis[l]；同理x_root = x_r + dis[r]。
              // 所以x_l + dis[l] = x_r + dis[r] → x_r - x_l = dis[l] - dis[r]。
              // 题目要求x_r - x_l = d，所以判断dis[l] - dis[r]是否等于d。
              if (dis[l] - dis[r] != d) {
                  ok = false;
              }
          } else {
              // 合并两个集合，设置rl的父节点为rr，并更新dis[rl]
              // 根据约束x_r - x_l = d → (x_rr + dis[r]) - (x_rl + dis[l]) = d → x_rr = x_rl + dis[l] - dis[r] + d。
              // 而rl的父节点是rr，所以dis[rl]（rl到rr的距离）应该等于x_rr - x_rl = dis[l] - dis[r] + d。
              fa[rl] = rr;
              dis[rl] = dis[l] - dis[r] + d;
          }
      }
      printf("%s\n", ok ? "Yes" : "No");
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **初始化**：每个节点的父节点是自己，`dis`数组初始化为0；  
  2. **处理每个约束**：  
     - 找到`l`和`r`的根节点；  
     - 如果根相同，检查`dis[l] - dis[r]`是否等于`d`（约束是否成立）；  
     - 如果根不同，合并两个集合，并更新根节点之间的距离（`dis[rl]`）；  
  3. **输出结果**：如果所有约束都满足，输出`Yes`，否则输出`No`。  


### 针对各优质题解的片段赏析

#### 题解一：带权并查集（作者：Doraven）  
* **亮点**：`find`函数的路径压缩+距离更新，逻辑严谨且高效。  
* **核心代码片段**：  
  ```cpp
  int find(int x) {
      if (fa[x] != x) {
          int root = find(fa[x]);
          dis[x] += dis[fa[x]];
          fa[x] = root;
      }
      return fa[x];
  }
  ```  
* **代码解读**：  
  这段代码是带权并查集的“核心”。当`x`的父节点不是根时，递归查找父节点的根（`root`），然后将`x`的`dis`更新为“`x`到原父节点的距离”加上“原父节点到根的距离”（`dis[fa[x]]`），最后将`x`直接指向根（路径压缩）。这样，`dis[x]`始终是`x`到当前根的距离。  
* 💡 **学习笔记**：路径压缩的同时更新`dis`，是带权并查集的关键。  


#### 题解二：DFS判负环（作者：CreeperLordVader）  
* **亮点**：用DFS实现差分约束的负环判断，思路直观。  
* **核心代码片段**：  
  ```cpp
  bool dfs(int fa) {
      vis[fa] = 1;
      use[fa] = 1;
      for (int i = 0; i < v[fa].size(); ++i) {
          int y = v[fa][i];
          int z = e[fa][i];
          if (d[y] > d[fa] + z) {
              if (vis[y]) return true; // 发现负环
              d[y] = d[fa] + z;
              if (dfs(y)) return true;
          }
      }
      vis[fa] = 0;
      return false;
  }
  ```  
* **代码解读**：  
  这段代码用`vis`标记当前递归栈中的节点（防止循环），`use`标记已访问的节点（避免重复处理）。当发现`d[y]`可以更新（`d[y] > d[fa] + z`）时，如果`y`已在递归栈中（`vis[y] == 1`），则说明有负环（矛盾）；否则更新`d[y]`并递归处理`y`。  
* 💡 **学习笔记**：DFS判负环的关键是标记递归栈中的节点。  


#### 题解三：SPFA判负环（作者：Wen_kr）  
* **亮点**：用SPFA实现差分约束的判断，稳定性高。  
* **核心代码片段**：  
  ```cpp
  bool spfa(int st) {
      queue<int> q;
      q.push(st);
      dist[st] = 0;
      inq[st] = true;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          inq[u] = false;
          for (int i = head[u]; i; i = e[i].nxt) {
              int v = e[i].v;
              if (dist[v] == 12345678987654321) {
                  dist[v] = dist[u] + e[i].w;
                  if (!inq[v]) {
                      q.push(v);
                      inq[v] = true;
                  }
              } else if (dist[v] != dist[u] + e[i].w) {
                  return false;
              }
          }
      }
      return true;
  }
  ```  
* **代码解读**：  
  这段代码用队列维护待更新的节点（`inq`标记是否在队列中）。当`dist[v]`未初始化时，更新它并加入队列；如果`dist[v]`已初始化且不等于`dist[u] + e[i].w`，则说明有矛盾（返回`false`）。  
* 💡 **学习笔记**：SPFA判负环的关键是检查是否有节点被更新超过`n`次，但本题中直接检查`dist[v]`是否符合约束更高效。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：带权并查集的“家族合并”游戏  
**设计思路**：用8位像素风格模拟带权并查集的合并过程，结合游戏化元素（如“家族树”生长、音效提示），让学习者直观理解`dis`数组的变化。  


### 📺 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示`n`个像素节点（比如10x10的方块），编号从1到`n`；  
   - 右侧显示“控制面板”：开始/暂停按钮、单步执行滑块、速度调节滑块；  
   - 背景播放8位风格的轻快BGM（比如《超级马里奥》的背景音乐）。  

2. **初始化节点**：  
   - 每个节点的父节点是自己（用“→”指向自己），`dis`数组显示为0；  
   - 节点颜色为浅蓝色（未加入集合）。  

3. **处理约束**：  
   - 当处理第`i`个约束（`l, r, d`）时，节点`l`和`r`闪烁（提示当前处理的约束）；  
   - 调用`find(l)`和`find(r)`：  
     - 路径压缩时，节点`l`的父节点从`p`变成根节点`root`，`dis[l]`随之更新（比如从0变成1），用箭头动画展示路径压缩的过程；  
     - 根节点用黄色边框标记，`dis`数组用红色数字显示；  
   - 如果根相同，检查`dis[l] - dis[r]`是否等于`d`：  
     - 如果等于，节点`l`和`r`变成绿色（提示约束满足）；  
     - 如果不等于，节点`l`和`r`变成红色，播放“错误”音效（短促的“叮~”）；  
   - 如果根不同，合并两个集合：  
     - 节点`rl`（`l`的根）的父节点指向`rr`（`r`的根），`dis[rl]`更新为`dis[l] - dis[r] + d`，用动画展示“家族树”的合并（比如`rl`的方块移动到`rr`的下方）；  
     - 播放“合并”音效（柔和的“咻~”）。  

4. **交互控制**：  
   - **单步执行**：点击“下一步”按钮，处理下一个约束；  
   - **自动播放**：拖动速度滑块，设置动画播放速度（比如1x、2x、3x）；  
   - **重置动画**：点击“重置”按钮，恢复初始状态。  


### 📝 旁白提示（动画中的文字气泡）  
- “现在处理约束（1,2,1），看看1和2的家族树！”；  
- “路径压缩中，1的父节点从1变成2，dis[1]更新为1（1到2的距离）！”；  
- “根相同，检查dis[1]-dis[2]是否等于1：是的，约束满足！”；  
- “合并成功，1和2的家族树连在一起了！”。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路/技巧迁移  
带权并查集不仅能解决本题，还能处理以下问题：  
1. **银河英雄传说**（P1196）：维护舰队之间的距离和数量；  
2. **食物链**（P2024）：维护物种之间的关系（捕食、被捕食）；  
3. **区间合并**（如合并区间并维护区间长度）。  


### 📚 练习推荐 (洛谷)  
1. **洛谷 P1196** - 银河英雄传说  
   * 🗣️ **推荐理由**：这道题是带权并查集的经典应用，需要维护舰队之间的距离和数量，能帮助你巩固`dis`数组的维护技巧。  
2. **洛谷 P2024** - 食物链  
   * 🗣️ **推荐理由**：这道题需要维护物种之间的三种关系（同类、捕食、被捕食），是带权并查集的变形，能拓展你的思维。  
3. **洛谷 P3385** - 负环判断  
   * 🗣️ **推荐理由**：这道题需要用DFS或SPFA判断图中的负环，能帮助你巩固差分约束的原理。  


## 7. 学习心得与经验分享 (若有)  
> **参考经验 (来自 Doraven)**：“这题其实只是一道基础的带权并查集，用不着差分约束。”  
> **点评**：这位作者的经验很重要——选择合适的算法能让问题变得简单。带权并查集比差分约束更高效，适合处理节点间的距离约束问题。在解题时，要先分析问题的核心特征，再选择对应的算法。  


## 🎉 结语  
本次关于“[ABC087D] People on a Line”的C++解题分析就到这里。希望这份学习指南能帮助你掌握带权并查集的核心思想和解题技巧。记住，编程的关键是**理解问题本质**，选择合适的算法，并正确实现细节。下次我们再一起探索新的编程挑战！💪

---
处理用时：194.22秒
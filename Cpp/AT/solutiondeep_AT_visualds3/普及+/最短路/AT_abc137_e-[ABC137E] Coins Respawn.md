# 题目信息

# [ABC137E] Coins Respawn

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc137/tasks/abc137_e

$ 1 $ から $ N $ までの番号がつけられた $ N $ 頂点と $ M $ 辺からなる有向グラフがあります。 $ i $ 番目の辺は頂点 $ A_i $ から頂点 $ B_i $ へと向かい、この辺の上には $ C_i $ 枚のコインが置かれています。 また、頂点 $ N $ にはボタンが設置されています。

このグラフ上でゲームを行います。 あなたは頂点 $ 1 $ でコインを $ 0 $ 枚持ってゲームを開始し、辺をたどってコインを拾いながら頂点 $ N $ を目指します。 $ 1 $ 本の辺を通るには $ 1 $ 分の時間がかかり、辺を通るたびにその辺の上に置かれているすべてのコインを拾うことができます。 ゲームの世界ではよくあるように、ある辺を通ってその上のコインを拾っても、その辺を次に通る際には同じ枚数のコインが再び出現しており、それらを再び拾うことができます。

頂点 $ N $ に到着したとき、ボタンを押してゲームを終了することができます。(ボタンを押さずに移動を続けることもできます。) ただし、ゲームを終了する際に、ゲーム開始からの経過時間を $ T $ 分として $ T\ \times\ P $ 枚のコインの支払いが要求されます。持っているコインの枚数が $ T\ \times\ P $ 枚未満の場合は、代わりに持っているコインをすべて支払います。

この支払いの後に残ったコインの枚数があなたのスコアとなります。 獲得できるスコアの最大値が存在するか判定し、存在する場合はその最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2500 $
- $ 1\ \leq\ M\ \leq\ 5000 $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N $
- $ 1\ \leq\ C_i\ \leq\ 10^5 $
- $ 0\ \leq\ P\ \leq\ 10^5 $
- 入力中の値はすべて整数である。
- 頂点 $ 1 $ から頂点 $ N $ に到達することが可能である。

### Sample Explanation 1

!\[入力例 1 で与えられるグラフの図\](https://img.atcoder.jp/ghi/5cb074e2d7c3282da137ac4ab2fbc700.png) 頂点 $ 1 $ から頂点 $ 3 $ に移動する方法は以下の $ 2 $ 通りです。 - 頂点 $ 1\ \rightarrow\ 2\ \rightarrow\ 3 $: 道中でコインを $ 20\ +\ 30\ =\ 50 $ 枚拾う。ゲーム開始から $ 2 $ 分後に頂点 $ 3 $ に着き、ボタンを押してコインを $ 2\ \times\ 10\ =\ 20 $ 枚支払い、$ 50\ -\ 20\ =\ 30 $ 枚残る。 - 頂点 $ 1\ \rightarrow\ 3 $: 道中でコインを $ 45 $ 枚拾う。ゲーム開始から $ 1 $ 分後に頂点 $ 3 $ に着き、ボタンを押してコインを $ 1\ \times\ 10\ =\ 10 $ 枚支払い、$ 45\ -\ 10\ =\ 35 $ 枚残る。 よって、獲得できるスコアの最大値は $ 35 $ です。

### Sample Explanation 2

!\[入力例 2 で与えられるグラフの図\](https://img.atcoder.jp/ghi/eb2188ad1e8189f963d233415fb293b6.png) 頂点 $ 1 $ から伸びる辺を通ると頂点 $ 2 $ に着き、ここで頂点 $ 2 $ から自分自身へと向かう辺を $ t $ 回通ってからボタンを押すとスコアは $ 90\ +\ 90t $ となります。よってスコアは無限に高めることができ、獲得できるスコアの最大値は存在しません。

### Sample Explanation 3

!\[入力例 3 で与えられるグラフの図\](https://img.atcoder.jp/ghi/217f7a224b80a05d8e25140c57e65ae7.png) 頂点 $ 1 $ から頂点 $ 4 $ へと直接向かう辺を通ること以外に頂点 $ 1 $ から頂点 $ 4 $ に移動する方法はありません。この辺の上で $ 1 $ 枚のコインを拾いますが、ゲーム終了時に $ 10 $ 枚のコインの支払いを要求されてスコアは $ 0 $ となります。 なお、頂点 $ 1 $ から頂点 $ 2 $ へと向かう辺を通るとその後コインを無限に拾えますが、頂点 $ 4 $ に到達してゲームを終了することができなくなるため無意味です。

## 样例 #1

### 输入

```
3 3 10

1 2 20

2 3 30

1 3 45```

### 输出

```
35```

## 样例 #2

### 输入

```
2 2 10

1 2 100

2 2 100```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 5 10

1 2 1

1 4 1

3 4 1

2 2 100

3 3 100```

### 输出

```
0```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC137E] Coins Respawn 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最长路问题（SPFA判正环）+ 图的可达性分析


### 🗣️ 初步分析  
想象你在一个**像素风格的迷宫**里寻宝，从起点（1号节点）走到终点（N号节点）。每走一条路（边）能捡到金币，但每走一步都会消耗“时间成本”——最终结束时，总时间（步数）× P就是你要支付的“过路费”。你的目标是让“捡到的金币 - 过路费”最大化。  

**核心思路**：  
把每条边的“净收益”算出来——**边权 = 金币数C_i - 时间成本P**。这样，问题就转化为：**从1到N的最长路**（因为要最大化净收益）。如果存在一个**能到达N的正权环**（绕圈走能无限赚金币），那么得分会无限大，输出-1。  

**关键难点**：  
- 如何处理“时间成本”？→ 边权转化为C_i - P，把总过路费分摊到每一步。  
- 如何判断“无限大”？→ 用SPFA判正环，但必须保证正环**能到达N**（否则绕圈没用，因为到不了终点）。  
- 结果处理？→ 如果最长路是负数，输出0（因为最多把金币扣光，不会欠债）。  

**可视化设计思路**：  
用**8位像素风格**展示图结构（节点是彩色方块，边是箭头）。SPFA过程中，**队列中的节点闪烁**（表示正在处理），**松弛操作时边变亮**（表示更新路径），**正环检测时节点变红并播放警告音效**（比如“滴滴”声）。最终，最长路用“金币堆”动画展示，负数则显示“空钱包”。  


## 2. 精选优质题解参考

### 题解一（来源：Lynkcat，赞6）  
* **点评**：  
  这份题解的思路**简洁到“一句话就能说清”**——边权转C_i-P，反图DFS标记能到N的点，SPFA判正环求最长路。代码结构非常清晰，变量命名（如`vis_in_dfs`标记可达点）易懂，边界处理（`max(0LL, dis[n])`）严谨。特别是**反图DFS**的技巧，完美解决了“正环是否有效”的问题，避免了误判（比如样例3中的无效环）。  

### 题解二（来源：Stone_Xz，赞3）  
* **点评**：  
  此题解的**代码注释非常详细**，适合初学者理解。比如用`lian`数组标记能到N的点，`spfa`函数中特意注释“注意如果nxt无法到达点n就不能去”，强调了可达性的重要性。另外，作者提到“不开long long见祖宗”，提醒了数据范围的问题（金币数可能很大）。  

### 题解三（来源：GHD3，赞4）  
* **点评**：  
  这份题解补充了**时间复杂度分析**（O(N+M+NM)），让学习者明白算法的效率是否符合题目要求。作者还举了样例3的例子，解释为什么需要反图DFS——避免把“到不了终点的环”当成有效环，逻辑非常严谨。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何处理“时间成本”？**  
* **分析**：  
  题目中的“T×P”是总过路费，而T是步数（边数）。因此，每走一条边的“净收益”就是**C_i - P**（捡到的金币减去这一步的过路费）。这样，总收益就是所有边的净收益之和，直接求最长路即可。  
* 💡 **学习笔记**：把“全局成本”分摊到“每一步”，是解决这类问题的常用技巧。  

### 2. **难点2：如何判断“无限大”？**  
* **分析**：  
  无限大的情况是存在**能到达N的正权环**（绕圈走能无限赚金币）。判断正环可以用SPFA（当节点入队次数超过N时，存在环），但必须保证环**能到达N**。如何判断？**建反图，从N出发DFS，标记所有能到达的点**——只有这些点中的环才是有效的。  
* 💡 **学习笔记**：反图DFS是“过滤无效环”的关键，避免“白绕圈”。  

### 3. **难点3：结果如何处理？**  
* **分析**：  
  题目要求“如果金币少于T×P，支付全部金币”，所以最终得分是**max(最长路结果, 0)**（负数的话，相当于扣光所有金币，得0分）。  
* 💡 **学习笔记**：边界条件不要忘，否则会WA（比如样例3）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了Lynkcat、Stone_Xz等优质题解的思路，代码简洁且包含所有核心逻辑。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <cstring>
  #define int long long
  using namespace std;

  const int N = 2505;
  vector<pair<int, int>> g[N]; // 原图：u->v，边权w=C_i-P
  vector<int> rev_g[N];        // 反图：v->u，用于DFS标记可达点
  bool vis[N];                 // 标记反图中能到达N的点
  int dis[N], cnt[N];          // dis[]: 最长路距离；cnt[]: 节点入队次数
  bool in_queue[N];            // 标记节点是否在队列中

  void dfs(int u) {
      if (vis[u]) return;
      vis[u] = true;
      for (int v : rev_g[u]) {
          dfs(v);
      }
  }

  bool spfa(int s) {
      memset(dis, -0x3f, sizeof(dis));
      memset(cnt, 0, sizeof(cnt));
      memset(in_queue, false, sizeof(in_queue));
      queue<int> q;
      dis[s] = 0;
      q.push(s);
      in_queue[s] = true;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          in_queue[u] = false;
          for (auto &[v, w] : g[u]) {
              if (!vis[v]) continue; // 跳过不能到达N的点
              if (dis[v] < dis[u] + w) {
                  dis[v] = dis[u] + w;
                  cnt[v]++;
                  if (cnt[v] >= N) { // 入队次数超过N，存在正环
                      return true;
                  }
                  if (!in_queue[v]) {
                      q.push(v);
                      in_queue[v] = true;
                  }
              }
          }
      }
      return false;
  }

  signed main() {
      int n, m, p;
      cin >> n >> m >> p;
      for (int i = 0; i < m; i++) {
          int u, v, c;
          cin >> u >> v >> c;
          g[u].emplace_back(v, c - p); // 边权转化为C_i-P
          rev_g[v].push_back(u);       // 建反图
      }
      dfs(n); // 从N出发，标记反图中能到达的点（即原图中能到达N的点）
      if (spfa(1)) {
          cout << -1 << endl;
      } else {
          cout << max(0LL, dis[n]) << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **反图DFS**：从N出发，标记所有能到达的点（`vis[]`数组），这些点是“有效点”（只有这些点中的环才会影响结果）。  
  2. **SPFA求最长路**：初始化`dis[1] = 0`，其他为负无穷。遍历队列中的节点，松弛其邻接边。如果节点入队次数超过N，说明存在正环，返回true。  
  3. **结果处理**：如果有正环，输出-1；否则输出`max(0LL, dis[n])`（避免负数）。  


### 针对各优质题解的片段赏析  

#### 题解一（Lynkcat）：反图DFS片段  
* **亮点**：用反图DFS标记能到达N的点，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  void dfs(int u) {
      if (vis_in_dfs[u]) return;
      vis_in_dfs[u] = 1;
      for (auto i : vec[u])
          dfs(i);
  }
  ```
* **代码解读**：  
  `vec`是反图（边是v->u），从N出发DFS，标记所有能到达的点（`vis_in_dfs[]`）。这些点在原图中是“能到达N的点”，只有这些点中的环才是有效的。  
* 💡 **学习笔记**：反图是解决“可达性”问题的常用技巧，比如判断“从A到B是否有路径”可以转化为“从B到A是否有路径”（反图）。  

#### 题解二（Stone_Xz）：SPFA判正环片段  
* **亮点**：用`cnt[]`数组记录节点入队次数，超过N则存在正环。  
* **核心代码片段**：  
  ```cpp
  if (cnt[nxt] > n - 1) return true;
  ```
* **代码解读**：  
  根据图论知识，如果一个节点入队次数超过N（节点数），说明存在环（因为最短路径的边数最多是N-1）。这里求最长路，所以正环的判断条件相同。  
* 💡 **学习笔记**：SPFA判环的核心是“节点入队次数超过节点数”。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：《像素迷宫寻宝记》  
**风格**：8位FC红白机风格，用彩色方块表示节点（1号是“起点”，N号是“终点”），箭头表示边，金币图标表示边权。  

### 🚀 核心演示内容  
1. **初始化**：  
   - 屏幕显示像素迷宫（节点是彩色方块，边是箭头），终点（N号）闪烁“目标”字样。  
   - 控制面板有“开始”“单步”“自动播放”按钮，速度滑块（1x~5x）。  
   - 背景音乐：8位风格的“冒险曲”（循环播放）。  

2. **反图DFS标记**：  
   - 从终点（N号）出发，反图中的边变成“绿色”，标记能到达的点（节点变成“亮蓝色”）。  
   - 旁白：“这些点是能到达终点的，只有它们中的环才有用哦！”  

3. **SPFA过程**：  
   - 队列中的节点（比如1号）闪烁“正在处理”。  
   - 松弛操作时，边变成“黄色”，目标节点的`dis`值增加（显示“+X金币”）。  
   - 当节点入队次数超过N时，节点变成“红色”，播放“警告音效”（滴滴声），旁白：“发现正环！得分无限大！”  

4. **结果展示**：  
   - 如果有正环，屏幕显示“-1”和“无限金币！”的动画。  
   - 否则，显示“最长路结果”（比如35），用“金币堆”动画展示，负数则显示“空钱包”（0分）。  

### 🎯 设计思路  
- **像素风格**：符合青少年的“复古游戏”审美，降低学习压力。  
- **音效与动画**：用“叮”的声音表示松弛操作，“滴滴”声表示正环，增强记忆点。  
- **交互性**：单步播放让学习者仔细观察每一步，自动播放让学习者快速了解整体流程。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
- **最长路问题**：比如“求从A到B的最大收益路径”（边权是收益）。  
- **判环问题**：比如“判断图中是否存在能到达终点的正环”（如本题）。  
- **可达性分析**：比如“判断哪些点能到达终点”（反图DFS）。  

### 📚 洛谷练习推荐  
1. **洛谷 P1807** - 《最长路》  
   - 🗣️ **推荐理由**：直接考察最长路问题，用SPFA解决，适合巩固本题的核心思路。  
2. **洛谷 P3385** - 《负环判断》  
   - 🗣️ **推荐理由**：虽然是负环，但判断逻辑和正环类似（SPFA入队次数超过N），可以练习“环的判断”。  
3. **洛谷 P2850** - 《[USACO06DEC]Wormholes G》  
   - 🗣️ **推荐理由**：需要判断是否存在“时间循环”（正环），与本题的“无限金币”逻辑一致，适合拓展思维。  


## 7. 学习心得与经验分享 (若有)  
- **反图的重要性**：题解中多次提到“反图DFS标记能到达N的点”，这是避免误判的关键。比如样例3中的2号点有正环，但到不了终点，所以不需要考虑。  
- **边界条件**：结果要与0取max，否则会WA（比如样例3的输出是0）。  
- **数据范围**：金币数可能很大，必须用`long long`（否则会溢出）。  


## 🎉 总结  
本题的核心是**最长路问题**，但需要解决两个关键问题：**边权转化**（处理时间成本）和**有效正环判断**（反图DFS）。通过SPFA算法，可以同时解决最长路和正环判断的问题。  

希望这份指南能帮助你理解图论中的“最长路”和“环判断”技巧，下次遇到类似问题时，能快速想到解决方案！💪  

如果有疑问，欢迎在评论区留言，Kay会帮你解答！😊

---
处理用时：167.39秒
# 题目信息

# [AGC023B] Find Symmetries

## 题目描述

Snuke 有两块板子。每块板都是一个 $n$ 行 $n$ 列的网格。对于这两块板子，记第 $i$ 行 $j$ 列的格子为 $(i,j)$。

第一块板子的每个格子上都写着一个小写字母：格子 $(i,j)$ 上的字母为 $S_{i,j}$。第二块板子上没有写任何东西。

Snuke 将以以下方法在第二块板子上写下字母：

首先，选择两个整数 $A$，$B$；然后在第二块板子的每个格子上写下一个字母。具体的说，第二块板子的格子 $(i+A,j+B)$ 将写上 $S_{i,j}$。这里第 $n+k$ 行即第 $k$ 行，第 $n+k$ 列即为第 $k$ 列。

此操作后，若对任意的 $i,j$，第二块板的格子 $(j,i)$ 上的字母和格子 $(i,j)$ 上的字母相同，则称第二块板为“好板”。

请你求出有多少 $A,B$ 满足 $0\le A,B<n$，且经过上述操作后第二块板为“好板”。

## 说明/提示

- $1\le n\le 300$。
- $S_{i,j}$ 都是小写字母。

#### 样例解释：

对于样例 1：对于所有可能的 $A$ 和 $B$，二号板上的字母如下所示：

![](https://img.atcoder.jp/agc023/2414e26dc3abb6dd7bfa0c800bb4af0c.png)

当且仅当 $(A,B)=(0,1)$ 或 $(A,B)=(1,0)$ 时满足第二块板是“好板”，因此答案是 $22$。

对于样例 2，所有被选中的 $A$ 和 $B$ 都会使第二块板成为“好板”。

对于样例 3，没有 $A$ 和 $B$ 可以使第二块板成为“好板”。

## 样例 #1

### 输入

```
2

ab

ca```

### 输出

```
2```

## 样例 #2

### 输入

```
4

aaaa

aaaa

aaaa

aaaa```

### 输出

```
16```

## 样例 #3

### 输入

```
5

abcde

fghij

klmno

pqrst

uvwxy```

### 输出

```
0```

# AI分析结果

# 💡 Kay的C++算法解析：[AGC023B] Find Symmetries 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举优化与矩阵对称性判断`  

🗣️ **初步分析**：  
解决“Find Symmetries”问题，关键在于**高效统计满足条件的循环移位参数(A,B)**。简单来说，我们需要找到所有(A,B)，使得将原矩阵`S`循环移动`A`行、`B`列后，得到的新矩阵是**对称矩阵**（即任意(i,j)位置的字符等于(j,i)位置的字符）。  

### 核心思路与难点
直接枚举所有`A`（0≤A<n）和`B`（0≤B<n），然后检查每个移位后的矩阵是否对称，会导致**O(n⁴)**的时间复杂度（n=300时，300⁴=8.1×10¹⁰，完全无法通过）。因此，**优化枚举量**是解题的关键。  

### 关键优化结论
通过观察对称矩阵的性质，我们发现：**如果将矩阵循环移动`A`行后得到的矩阵是对称的，那么无论`B`取何值（0≤B<n），循环移动`B`列后的矩阵仍然是对称的**。  
为什么？因为循环移动列`B`位相当于将矩阵的列循环右移，而对称矩阵的列循环移动后，其转置矩阵（即行循环移动）仍然是对称的。因此，只需枚举`A`（0≤A<n），检查移动`A`行后的矩阵是否对称即可。若对称，则所有`B`都满足条件，贡献`n`个解。  

### 可视化设计思路
我们可以用**8位像素风格**展示矩阵循环移位与对称检查的过程：  
- **场景初始化**：用像素块表示原矩阵，每个块的颜色对应字符（如`a`用红色，`b`用蓝色）。  
- **移位动画**：选择`A=1`时，将最后一行的像素块“滑”到第一行（模拟循环移动行）。  
- **对称检查**：逐个检查(i,j)和(j,i)位置的像素块颜色，用**绿色**标记相等，**红色**标记不等。若所有位置都为绿色，则显示“成功”动画（如像素星星闪烁），并将答案加`n`。  
- **交互设计**：支持“单步执行”（逐行检查）、“自动播放”（快速遍历所有`A`），以及“重置”（回到原矩阵）。  


## 2. 精选优质题解参考

<eval_intro>  
为了帮助大家快速掌握解题思路，我从**思路清晰度**、**代码可读性**、**复杂度合理性**三个方面，筛选了以下3份优质题解（评分≥4星）：  
</eval_intro>


### **题解一：(来源：zmza，赞：2)**  
* **点评**：  
  这份题解的思路**非常直白**，直接枚举`A`（0≤A<n），将矩阵的行循环移动`A`位，然后检查移动后的矩阵是否对称。如果对称，则所有`B`都满足条件，贡献`n`个解。  
  代码风格**简洁规范**（变量名如`mp`表示原矩阵，`tmp`表示移动后的矩阵），逻辑清晰易懂。虽然时间复杂度是`O(n³)`（n=300时，300³=2.7×10⁷，完全可以通过），但由于循环内的操作非常简单（仅字符比较），常数很小，实际运行速度很快。  
  **亮点**：通过“枚举A+检查对称”的策略，将问题从`O(n⁴)`优化到`O(n³)`，是最容易理解和实现的解法。  


### **题解二：(来源：火车司机，赞：1)**  
* **点评**：  
  这份题解的**代码更简洁**，通过**扩展矩阵**（将原矩阵复制为2n×2n的矩阵），避免了循环移动行的计算。例如，移动`A`行后的矩阵，就是扩展矩阵中从第`A+1`行到第`A+n`行、第1列到第n列的子矩阵。  
  代码中的`s[i+n][j] = s[i][j]`（扩展行）和`s[i][j+n] = s[i][j]`（扩展列），将原矩阵扩展为2n×2n，这样循环移动后的子矩阵可以直接取，无需计算模运算，简化了代码逻辑。  
  **亮点**：扩展矩阵的技巧减少了循环移动的计算量，使代码更简洁，可读性更高。  


### **题解三：(来源：cosf，赞：0)**  
* **点评**：  
  这份题解的**思路更巧妙**，发现`A`和`B`之间的关系：**如果`A-B`的差相同，那么条件相同**。例如，`A=2`、`B=1`与`A=3`、`B=2`的条件是一样的（差为1）。因此，只需枚举`A-B=0`的情况（即`A=B`），然后将结果乘以`n`即可。  
  代码中的`mp[j][k+i] != mp[k][j+i]`（检查扩展后的矩阵），其实是在判断`A=i`、`B=0`的情况，然后将结果乘以`n`（因为所有`B`都满足）。  
  **亮点**：通过数学分析减少枚举量，使代码更高效（虽然复杂度仍是`O(n³)`，但逻辑更简洁）。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
在解决本题时，我们需要突破两个核心难点：**如何优化枚举量**和**如何快速判断循环移动后的矩阵是否对称**。结合优质题解的共性，我为大家提炼了以下策略：  
</difficulty_intro>


### 1. **关键点1：如何优化枚举量？**  
* **分析**：  
  直接枚举所有`A`和`B`（0≤A,B<n）会导致`O(n⁴)`的时间复杂度，无法通过。通过观察对称矩阵的性质，我们发现：**如果移动`A`行后的矩阵是对称的，那么所有`B`都满足条件**。因此，只需枚举`A`（0≤A<n），检查移动`A`行后的矩阵是否对称即可。  
* 💡 **学习笔记**：  
  优化枚举量的关键是**发现问题中的对称性或不变量**，将“枚举两个变量”转化为“枚举一个变量”。  


### 2. **关键点2：如何快速判断循环移动后的矩阵是否对称？**  
* **分析**：  
  循环移动`A`行后的矩阵，相当于将原矩阵的最后`A`行移到最前面。例如，`A=1`时，原矩阵的第`n`行变为第1行，第1行变为第2行，…，第`n-1`行变为第`n`行。  
  为了快速获取移动后的矩阵，我们可以**扩展矩阵**（将原矩阵复制为2n×2n的矩阵），这样移动`A`行后的矩阵就是扩展矩阵中从第`A+1`行到第`A+n`行、第1列到第n列的子矩阵。例如，原矩阵是`n×n`，扩展后的矩阵是`2n×2n`，那么移动`A`行后的矩阵就是`s[A+1..A+n][1..n]`。  
* 💡 **学习笔记**：  
  扩展矩阵是处理循环移位问题的常用技巧，能避免模运算，简化代码逻辑。  


### 3. **关键点3：如何高效检查矩阵是否对称？**  
* **分析**：  
  检查矩阵是否对称，需要判断每个(i,j)位置的字符是否等于(j,i)位置的字符。对于`n×n`的矩阵，这需要`O(n²)`的时间复杂度。由于`n=300`，`O(n²)`的时间复杂度是完全可以接受的（300²=9×10⁴）。  
* 💡 **学习笔记**：  
  对于矩阵对称性检查，直接遍历所有(i,j)位置是最直接、最有效的方法。  


### ✨ 解题技巧总结  
- **技巧A：枚举优化**：通过观察问题中的对称性，将枚举量从`O(n²)`减少到`O(n)`。  
- **技巧B：扩展矩阵**：处理循环移位问题时，扩展矩阵可以避免模运算，简化代码。  
- **技巧C：直接检查**：对于矩阵对称性检查，直接遍历所有(i,j)位置是最有效的方法。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
在深入分析具体题解的精妙片段之前，让我们先来看一个**通用核心C++实现**（综合了题解二和题解三的思路），帮助大家把握整体解题框架：  
</code_intro_overall>


### **本题通用核心C++实现参考**  
* **说明**：  
  本代码综合了“扩展矩阵”和“枚举A+检查对称”的思路，代码简洁、高效，适合n=300的情况。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstdio>
  #include <string>
  using namespace std;

  const int MAXN = 605; // 扩展为2n×2n，所以MAXN=2*300+5=605
  char s[MAXN][MAXN]; // 扩展后的矩阵

  int main() {
      int n;
      scanf("%d", &n);
      for (int i = 1; i <= n; ++i) {
          scanf("%s", s[i] + 1); // 读取原矩阵的第i行（1-based）
          // 扩展行：将原矩阵的第i行复制到第i+n行
          for (int j = 1; j <= n; ++j) {
              s[i + n][j] = s[i][j];
          }
          // 扩展列：将原矩阵的第i行复制到第j+n列（可选，本题不需要）
          // for (int j = 1; j <= n; ++j) {
          //     s[i][j + n] = s[i][j];
          // }
      }

      int ans = 0;
      // 枚举A（0≤A<n）：移动A行后的矩阵是s[A+1..A+n][1..n]
      for (int A = 0; A < n; ++A) {
          bool ok = true;
          // 检查移动A行后的矩阵是否对称：s[A+i][j] == s[A+j][i]（i,j从1到n）
          for (int i = 1; i <= n; ++i) {
              for (int j = 1; j <= n; ++j) {
                  if (s[A + i][j] != s[A + j][i]) {
                      ok = false;
                      break;
                  }
              }
              if (!ok) break;
          }
          if (ok) {
              ans += n; // 所有B都满足条件，贡献n个解
          }
      }

      printf("%d\n", ans);
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **扩展矩阵**：将原矩阵复制为2n×2n的矩阵，避免循环移动的计算。  
  2. **枚举A**：遍历所有可能的`A`（0≤A<n），检查移动`A`行后的矩阵是否对称。  
  3. **检查对称**：遍历所有(i,j)位置，判断`s[A+i][j]`（移动A行后的(i,j)位置）是否等于`s[A+j][i]`（移动A行后的(j,i)位置）。  
  4. **统计答案**：如果移动`A`行后的矩阵对称，则所有`B`都满足条件，贡献`n`个解。  


<code_intro_selected>  
接下来，我们逐一剖析优质题解中的**核心代码片段**，点出各自的亮点：  
</code_intro_selected>


### **题解二：(来源：火车司机)**  
* **亮点**：扩展矩阵，避免循环移动的计算。  
* **核心代码片段**：  
  ```cpp
  // 扩展矩阵：将原矩阵复制为2n×2n
  for (int i = 1; i <= n; ++i) {
      scanf("%s", s[i] + 1);
      for (int j = 1; j <= n; ++j) {
          s[i + n][j] = s[i][j]; // 扩展行
          s[i][j + n] = s[i][j]; // 扩展列（本题不需要，但可以处理列循环移动）
      }
  }

  // 枚举A，检查移动A行后的矩阵是否对称
  for (int A = 0; A < n; ++A) {
      bool ok = true;
      for (int i = 1; i <= n; ++i) {
          for (int j = 1; j <= n; ++j) {
              if (s[A + i][j] != s[A + j][i]) { // 移动A行后的(i,j)和(j,i)
                  ok = false;
                  break;
              }
          }
          if (!ok) break;
      }
      if (ok) ans += n;
  }
  ```  
* **代码解读**：  
  扩展矩阵后，移动`A`行后的矩阵就是`s[A+1..A+n][1..n]`，无需计算模运算。例如，`A=1`时，移动后的矩阵是`s[2..n+1][1..n]`，即原矩阵的第2行到第n行，加上第1行（因为`s[n+1][j] = s[1][j]`）。  
* 💡 **学习笔记**：  
  扩展矩阵是处理循环移位问题的“神器”，能大幅简化代码逻辑。  


### **题解三：(来源：cosf)**  
* **亮点**：发现`A`和`B`的关系，减少枚举量。  
* **核心代码片段**：  
  ```cpp
  // 读取原矩阵，并扩展列（将原矩阵的列复制到列n+1到2n）
  for (int i = 1; i <= n; ++i) {
      cin >> mp[i];
      mp[i] = " " + mp[i] + mp[i]; // 前面加空格，使列从1开始
  }

  // 枚举A（0≤A<n），检查移动A行后的矩阵是否对称（B=0的情况）
  for (int A = 1; A <= n; ++A) {
      bool ok = true;
      for (int i = 1; i <= n; ++i) {
          for (int j = 1; j <= n; ++j) {
              if (mp[i][j + A] != mp[j][i + A]) { // 移动A行后的(i,j)和(j,i)
                  ok = false;
                  break;
              }
          }
          if (!ok) break;
      }
      if (ok) res += 1; // 每个A贡献n个解，最后乘以n
  }

  cout << res * n << endl;
  ```  
* **代码解读**：  
  这里的`mp[i][j + A]`表示移动`A`行后的(i,j)位置（因为列扩展了，所以`j + A`不会超过2n）。`res`统计满足条件的`A`的数量，最后乘以`n`（所有`B`都满足）。  
* 💡 **学习笔记**：  
  数学分析能帮助我们发现问题中的隐藏关系，减少枚举量。  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>  
为了更直观地理解“枚举A+检查对称”的过程，我设计了一个**8位像素风格的动画**（仿照FC红白机的UI），让我们一起“看”算法如何工作！  
</visualization_intro>


### **动画演示主题**：`像素矩阵的循环移位与对称检查`  
### **设计思路**：  
采用8位像素风格（如《超级马里奥》的画面），用**不同颜色的像素块**表示矩阵中的字符，通过**动画**展示循环移位的过程，用**颜色标记**表示对称检查的结果。这样既能保持趣味性，又能清晰展示算法逻辑。  


### **动画帧步骤与交互关键点**：  
1. **场景初始化**：  
   - 屏幕左侧显示**原矩阵**（n×n的像素块，每个块的颜色对应字符，如`a`用红色，`b`用蓝色）。  
   - 屏幕右侧显示**控制面板**（包含“开始”、“单步”、“重置”按钮，以及“速度滑块”）。  
   - 背景播放**8位风格的轻松BGM**（如《坦克大战》的背景音乐）。  

2. **选择A**：  
   - 用户通过控制面板选择`A`的值（如`A=1`），点击“开始”按钮。  
   - 动画展示**循环移动行**的过程：原矩阵的最后一行（红色像素块）“滑”到第一行，其他行依次下移（如《俄罗斯方块》的方块移动）。  

3. **对称检查**：  
   - 动画逐个检查(i,j)和(j,i)位置的像素块颜色：  
     - 如果相等，用**绿色**标记这两个位置（如《吃豆人》的豆子）。  
     - 如果不等，用**红色**标记这两个位置（如《魂斗罗》的敌人），并停止检查。  
   - 检查过程中，播放**轻微的“叮”声**（每检查一个位置），增强反馈。  

4. **结果展示**：  
   - 如果所有位置都为绿色（矩阵对称），显示**“成功！”**动画（如像素星星闪烁），并在屏幕顶部显示“答案+ n”（如“答案：2 → 4”）。  
   - 如果有位置为红色（矩阵不对称），显示**“失败！”**动画（如像素爆炸），并提示“请尝试其他A”。  

5. **交互设计**：  
   - **单步执行**：逐行检查(i,j)位置，用户可以随时暂停，查看当前状态。  
   - **自动播放**：快速遍历所有`A`的值，展示每个`A`的检查结果。  
   - **重置**：回到原矩阵，重新选择`A`。  


### **旁白提示**（动画中的文字气泡）：  
- “现在选择A=1，我们要将最后一行移到第一行！”（循环移动行时）  
- “检查(i=1,j=2)和(j=2,i=1)的位置，颜色是否相同？”（对称检查时）  
- “所有位置都相等，成功！答案加n（n=2）！”（成功时）  


<visualization_conclusion>  
通过这个像素动画，我们不仅能清晰看到**循环移位**和**对称检查**的过程，还能在轻松的游戏氛围中理解算法逻辑。赶紧试试吧！  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
理解了本题的解法后，我们可以将**枚举优化**和**扩展矩阵**的技巧应用到其他类似问题中。下面是几道洛谷上的推荐练习：  
</similar_problems_intro>


### **通用思路/技巧迁移**  
- **枚举优化**：适用于需要枚举多个变量，但变量之间存在某种关系（如对称性、不变量）的问题。  
- **扩展矩阵**：适用于处理循环移位、子矩阵查询等问题。  


### **练习推荐 (洛谷)**  
1. **洛谷 P1550 循环移动后的对称矩阵**  
   - 🗣️ **推荐理由**：本题与“Find Symmetries”高度相似，需要判断循环移动后的矩阵是否对称。通过练习，你可以巩固“枚举优化”和“扩展矩阵”的技巧。  

2. **洛谷 P2294 循环矩阵的对称性**  
   - 🗣️ **推荐理由**：本题考察循环矩阵的对称性质，需要你进一步理解循环移位与对称性的关系。  

3. **洛谷 P3397 矩阵的循环移位**  
   - 🗣️ **推荐理由**：本题需要处理矩阵的循环移位，并判断是否满足某些条件。通过练习，你可以提高“扩展矩阵”的应用能力。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>  
在分析题解的过程中，我发现了一些**有价值的学习心得**，分享给大家：  
</insights_intro>


> **参考经验 (来自 zmza 的题解)**：  
> “我最初想过用哈希优化，但后来发现直接枚举A+检查对称的方法虽然复杂度是O(n³)，但对于n=300来说完全可以通过。”  
> **点评**：  
> 这位作者的经验提醒我们，**不一定需要最优化的复杂度**，只要常数小，足够通过题目即可。在编程中，“简单有效”往往比“复杂优化”更重要。  


> **参考经验 (来自 火车司机 的题解)**：  
> “扩展矩阵是处理循环移位问题的好方法，能避免模运算，简化代码。”  
> **点评**：  
> 扩展矩阵是一种“以空间换时间”的技巧，虽然需要额外的空间，但能大幅简化代码逻辑，提高可读性。  


## 结论  
本次关于“[AGC023B] Find Symmetries”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握**枚举优化**和**扩展矩阵**的技巧，理解矩阵对称性的判断方法。  

记住：**编程能力的提升在于持续学习、勤于思考和勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：290.32秒
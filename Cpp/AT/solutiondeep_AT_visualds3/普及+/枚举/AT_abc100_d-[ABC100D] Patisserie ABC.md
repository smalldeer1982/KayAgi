# 题目信息

# [ABC100D] Patisserie ABC

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc100/tasks/abc100_d

高橋君はプロのパティシエになり, AtCoder Beginner Contest 100 を記念して, 「ABC洋菓子店」というお店を開いた.

ABC洋菓子店では, $ N $ 種類のケーキを売っている.  
 各種類のケーキには「綺麗さ」「おいしさ」「人気度」の $ 3 $ つの値を持ち, $ i $ 種類目のケーキの綺麗さは $ x_i $, おいしさは $ y_i $, 人気度は $ z_i $ である.  
 これらの値は $ 0 $ 以下である可能性もある.

りんごさんは, ABC洋菓子店で $ M $ 個のケーキを食べることにした. 彼は次のように, 食べるケーキの組み合わせを選ぶことにした.

- 同じ種類のケーキを $ 2 $ 個以上食べない.
- 上の条件を満たしつつ, (綺麗さの合計の絶対値) + (おいしさの合計の絶対値) + (人気度の合計の絶対値) が最大になるように選ぶ.

このとき, りんごさんが選ぶケーキの (綺麗さの合計の絶対値) + (おいしさの合計の絶対値) + (人気度の合計の絶対値) の最大値を求めなさい.

## 说明/提示

### 制約

- $ N $ は $ 1 $ 以上 $ 1\ 000 $ 以下の整数
- $ M $ は $ 0 $ 以上 $ N $ 以下の整数
- $ x_i,\ y_i,\ z_i\ (1\ \leq\ i\ \leq\ N) $ は, それぞれ $ -10\ 000\ 000\ 000 $ 以上 $ 10\ 000\ 000\ 000 $ 以下の整数.

### Sample Explanation 1

$ 2,\ 4,\ 5 $ 種類目のケーキを食べることを考える. そのとき, 「綺麗さ」「おいしさ」「人気度」の合計はそれぞれ次のようになる. - 綺麗さ：$ 1\ +\ 3\ +\ 9\ =\ 13 $ - おいしさ：$ 5\ +\ 5\ +\ 7\ =\ 17 $ - 人気度：$ 9\ +\ 8\ +\ 9\ =\ 26 $ このときの (綺麗さの合計の絶対値) + (おいしさの合計の絶対値) + (人気度の合計の絶対値) は $ 13\ +\ 17\ +\ 26\ =\ 56 $ となり, これが最大になる.

### Sample Explanation 2

$ 1,\ 3,\ 5 $ 種類目のケーキを食べることを考える. そのとき, 「綺麗さ」「おいしさ」「人気度」の合計はそれぞれ次のようになる. - 綺麗さ：$ 1\ +\ 7\ +\ 13\ =\ 21 $ - おいしさ：$ (-2)\ +\ (-8)\ +\ (-14)\ =\ -24 $ - 人気度：$ 3\ +\ (-9)\ +\ 15\ =\ 9 $ このときの (綺麗さの合計の絶対値) + (おいしさの合計の絶対値) + (人気度の合計の絶対値) は $ 21\ +\ 24\ +\ 9\ =\ 54 $ となり, これが最大になる.

### Sample Explanation 3

$ 3,\ 4,\ 5,\ 7,\ 10 $ 種類目のケーキを食べると, 綺麗さの合計は $ -323 $, おいしさの合計は $ 66 $, 人気度の合計は $ 249 $ となる. このときの (綺麗さの合計の絶対値) + (おいしさの合計の絶対値) + (人気度の合計の絶対値) は $ 323\ +\ 66\ +\ 249\ =\ 638 $ となり, これが最大になる.

### Sample Explanation 4

ケーキの綺麗さ, おいしさ, 人気度や出力すべき値が, 32bit 整数に収まらない場合もある.

## 样例 #1

### 输入

```
5 3

3 1 4

1 5 9

2 6 5

3 5 8

9 7 9```

### 输出

```
56```

## 样例 #2

### 输入

```
5 3

1 -2 3

-4 5 -6

7 -8 -9

-10 11 -12

13 -14 15```

### 输出

```
54```

## 样例 #3

### 输入

```
10 5

10 -80 21

23 8 38

-94 28 11

-26 -2 18

-69 72 79

-26 -86 -54

-72 -50 59

21 65 -32

40 -94 87

-62 18 82```

### 输出

```
638```

## 样例 #4

### 输入

```
3 2

2000000000 -9000000000 4000000000

7000000000 -5000000000 3000000000

6000000000 -1000000000 8000000000```

### 输出

```
30000000000```

# AI分析结果



---
# 💡 Kay的C++算法解析：Patisserie ABC 深入学习指南 💡

<introduction>
今天我们来分析这道“Patisserie ABC”编程题。题目要求从N个蛋糕中选M个，使得三个属性（美观度、美味度、人气度）的总和的绝对值之和最大。这道题的关键在于巧妙处理绝对值，通过枚举符号组合将问题转化为贪心选择问题。让我们一步步拆解！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举+贪心`  

🗣️ **初步分析**：  
解决这道题的核心在于“如何消除绝对值的影响”。绝对值的麻烦之处在于它需要考虑正负两种情况，而三个属性的绝对值之和共有 \(2^3=8\) 种符号组合（每个属性的和可以是正或负）。我们可以枚举这8种符号组合，将问题转化为：在每种符号组合下，计算每个蛋糕的“综合得分”（即 \(x_i \times s1 + y_i \times s2 + z_i \times s3\)，其中 \(s1,s2,s3\) 为±1），然后贪心选择前M个得分最高的蛋糕，求和即为该符号组合下的最大值。最终取所有8种情况的最大值即可。

- **题解思路**：所有优质题解均采用“枚举8种符号组合+贪心选择前M大”的思路，差异主要在代码实现细节（如符号枚举方式、排序方向等）。  
- **核心难点**：如何想到枚举符号组合消除绝对值，以及如何高效计算每种组合下的最大值。  
- **可视化设计**：用8位像素风格展示枚举过程（每个符号组合作为一个“关卡”），动态显示每个蛋糕的综合得分变化、排序过程（像素块上下移动）、前M个的高亮选择，最终对比8种情况的最大值。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解值得重点参考（均≥4星）：
</eval_intro>

**题解一：作者：linjinxi666**  
* **点评**：此题解思路直白，代码简洁。通过三重循环枚举符号组合（±1），计算每个蛋糕的综合得分，排序后取前M个求和。变量命名（如`h[l]`表示当前符号下的得分）清晰，边界处理（如`m=0`时直接返回0）隐含在逻辑中。算法时间复杂度为 \(O(8 \times n \log n)\)，完全满足题目要求，适合竞赛快速实现。

**题解二：作者：μηδσ**  
* **点评**：此题解代码结构工整，使用结构体存储蛋糕属性，排序函数明确。通过`i,j,k`三重循环枚举符号（±1），排序后累加前M个得分。代码中`typedef long long ll`避免了溢出问题，细节处理严谨（如初始化`ans`为极小值），适合学习基础实现。

**题解三：作者：cly312**  
* **点评**：此题解采用现代C++风格（使用`vector`存储数据），代码简洁高效。符号枚举与得分计算逻辑清晰，排序时直接使用`greater()`降序，避免手动编写比较函数。变量`sum`累加前M大值的过程直观，适合学习C++容器的使用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于突破以下三个核心难点：
</difficulty_intro>

1.  **关键点1：如何消除绝对值的影响？**  
    * **分析**：绝对值的存在让直接求和困难，但观察到 \(|A| + |B| + |C|\) 的最大值等价于 \(s1 \times A + s2 \times B + s3 \times C\) 的最大值（其中 \(s1,s2,s3 \in \{±1\}\)）。枚举这8种符号组合，即可将问题转化为无绝对值的求和问题。  
    * 💡 **学习笔记**：绝对值的最大值问题，可通过枚举符号组合转化为线性求和问题。

2.  **关键点2：如何高效枚举所有符号组合？**  
    * **分析**：三个符号各有±1两种可能，共8种组合。用三重循环枚举（`i,j,k`从-1到1，步长2）即可覆盖所有情况，时间复杂度仅 \(O(8)\)，可忽略不计。  
    * 💡 **学习笔记**：当组合数为常数（如\(2^3=8\)）时，枚举是高效且可行的。

3.  **关键点3：如何选择前M个最大的综合得分？**  
    * **分析**：对每个符号组合下的综合得分数组排序（降序），取前M个累加即可。排序的时间复杂度为 \(O(n \log n)\)，总时间复杂度 \(O(8n \log n)\)，适合N=1000的规模。  
    * 💡 **学习笔记**：贪心选择前M大值是解决此类“最大化总和”问题的常用策略。

### ✨ 解题技巧总结
- **符号枚举简化问题**：遇到多维度绝对值问题时，枚举符号组合是消除绝对值的有效方法。  
- **排序优化选择**：当需要选前M大/小值时，排序后直接取前M个是最直观的贪心策略。  
- **数据类型防溢出**：题目中数值范围大（\(±10^{10}\)），需用`long long`存储，避免溢出。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，代码简洁清晰，覆盖所有关键逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了linjinxi666和μηδσ的题解思路，采用三重循环枚举符号组合，排序后取前M大值，适合竞赛快速实现。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define int long long // 防止溢出

    int n, m, a[1005], b[1005], c[1005], h[1005], ans;

    bool cmp(int x, int y) { return x > y; } // 降序排序

    signed main() {
        cin >> n >> m;
        for (int i = 1; i <= n; ++i)
            cin >> a[i] >> b[i] >> c[i];
        
        // 枚举8种符号组合（s1,s2,s3 ∈ {-1,1}）
        for (int s1 = -1; s1 <= 1; s1 += 2)
            for (int s2 = -1; s2 <= 1; s2 += 2)
                for (int s3 = -1; s3 <= 1; s3 += 2) {
                    // 计算每个蛋糕的综合得分
                    for (int i = 1; i <= n; ++i)
                        h[i] = s1 * a[i] + s2 * b[i] + s3 * c[i];
                    // 降序排序，取前M大值
                    sort(h + 1, h + n + 1, cmp);
                    int sum = 0;
                    for (int i = 1; i <= m; ++i)
                        sum += h[i];
                    ans = max(ans, sum); // 更新最大值
                }
        
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入数据，然后通过三重循环枚举所有8种符号组合（s1, s2, s3）。对于每种组合，计算每个蛋糕的综合得分（考虑符号后的线性和），排序后取前M个得分累加，最终取所有组合的最大值作为答案。

---

<code_intro_selected>
接下来分析优质题解的核心片段：
</code_intro_selected>

**题解一：作者：linjinxi666**  
* **亮点**：代码极简，用宏定义简化`long long`，排序和求和逻辑清晰。  
* **核心代码片段**：
    ```cpp
    for(int i=-1;i<=1;i+=2)
        for(int j=-1;j<=1;j+=2)
            for(int k=-1;k<=1;k+=2){
                for(int l=1;l<=n;l++){
                    h[l]=i*a[l]+j*b[l]+k*c[l];
                }
                sort(h+1,h+n+1,cmp);
                int res=0;
                for(int l=1;l<=m;l++){
                    res+=h[l];
                }
                ans=max(res,ans);
            }
    ```
* **代码解读**：  
  三重循环枚举符号组合（i,j,k为±1），计算每个蛋糕的综合得分`h[l]`，排序后累加前M个值。`cmp`函数确保降序排序，`ans`不断更新最大值。  
* 💡 **学习笔记**：符号枚举+排序+贪心选择，是解决此类问题的“三板斧”。

**题解二：作者：μηδσ**  
* **亮点**：使用结构体存储蛋糕属性，代码结构清晰，适合理解数据组织。  
* **核心代码片段**：
    ```cpp
    struct CAKE{ ll a; ll b; ll c; } cake[MAXN];
    bool cmp(CAKE a, CAKE b) { 
        return a.a * i + a.b * j + a.c * k > b.a * i + b.b * j + b.c * k; 
    }
    sort(cake + 1, cake + n + 1, cmp);
    ```
* **代码解读**：  
  结构体`CAKE`存储三个属性，排序函数`cmp`根据当前符号组合（i,j,k）计算综合得分并降序排序。直接对结构体数组排序，避免额外数组存储得分。  
* 💡 **学习笔记**：结构体可以更直观地组织数据，适合属性较多的场景。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“符号枚举+贪心选择”的过程，我们设计一个8位像素风格的动画——**「蛋糕探险记」**！让我们一起“看”到算法如何工作！
</visualization_intro>

  * **动画演示主题**：`像素蛋糕店的符号探险`  
  * **核心演示内容**：展示枚举8种符号组合时，每个蛋糕的综合得分变化、排序过程，以及前M个蛋糕的选择。  
  * **设计思路简述**：采用FC红白机风格（8色调色板、像素方块），通过颜色区分不同符号组合（如红色代表s1=1，蓝色s1=-1），排序时用像素块滑动动画，选择时高亮前M个，配合音效增强记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左侧是8个“符号关卡”按钮（对应8种组合），右侧是蛋糕列表（每个蛋糕用像素方块表示，显示x,y,z值）。  
        - 控制面板包含“开始/暂停”“单步”“自动播放”按钮，速度滑块（1x-4x）。  
        - 播放8位复古BGM（如《超级马里奥》风格）。

    2.  **符号枚举与得分计算**：  
        - 点击“开始”后，依次点亮8个符号关卡（如第一个关卡：s1=1, s2=1, s3=1）。  
        - 每个蛋糕的像素方块颜色变化（如从白色变为红色），上方弹出得分（如“+x+y+z=15”），伴随“叮”的音效。

    3.  **排序过程演示**：  
        - 蛋糕方块开始上下滑动排序（降序），得分高的蛋糕向上移动，得分低的向下。  
        - 排序完成后，前M个蛋糕被金色边框高亮，显示“选中！”文字，播放“叮咚”音效。

    4.  **最大值对比**：  
        - 8个关卡完成后，屏幕中央弹出所有关卡的得分，用柱状图对比，最高得分的关卡闪烁，播放“胜利”音效（如《魂斗罗》通关音）。

    5.  **交互控制**：  
        - 单步模式：每按一次“单步”，执行一个符号关卡的计算和排序。  
        - 自动播放：按速度滑块设定的速率自动切换关卡，适合观察整体流程。

  * **旁白提示**：  
    - （符号关卡点亮时）“现在我们选择的是s1=1, s2=1, s3=1！每个蛋糕的得分是x+y+z哦～”  
    - （排序时）“看！得分高的蛋糕正在往上跑，它们会被优先选中～”  
    - （选中时）“前3个蛋糕被选中啦！它们的得分总和是当前关卡的最大值～”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到符号枚举如何消除绝对值，贪心选择如何得到最大值，让抽象的算法变得“看得见，摸得着”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的“符号枚举+贪心选择”思路可迁移到多种多维度绝对值问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - **多维度优化**：当问题涉及多个维度的绝对值最大化时（如二维的|x|+|y|），枚举符号组合是通用策略。  
    - **贪心选择**：当需要选前M个最优元素时，排序后取前M个是高效方法（如任务调度、资源分配）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1772 [ZJOI2006] 物流运输**  
        * 🗣️ **推荐理由**：涉及路径选择与成本计算，需枚举关键节点，锻炼多条件下的贪心策略。  
    2.  **洛谷 P1856 [IOI1998] 多边形**  
        * 🗣️ **推荐理由**：处理环形数组的最大值，需枚举断环位置，与符号枚举思路类似。  
    3.  **洛谷 P2392 kkksc03考前临时抱佛脚**  
        * 🗣️ **推荐理由**：多科目时间分配问题，需枚举科目顺序，锻炼枚举与贪心结合的能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到“必须使用long long，否则会溢出”，这是关键的实践经验：
</insights_intro>

> **参考经验 (来自多位题解作者)**：“题目中x,y,z的范围很大（±1e10），M最多是1000，总和可能达到1e13，必须用long long存储，否则会溢出导致错误。”  

**点评**：数据范围是编程题的“隐形陷阱”。本题中，即使单个值不大，累加后也可能超出int的范围（约±2e9）。使用`long long`（范围±9e18）能有效避免溢出。这提醒我们，处理大数问题时，一定要注意数据类型的选择！

---

<conclusion>
通过分析“Patisserie ABC”的解题思路，我们掌握了枚举符号组合+贪心选择的核心技巧。记住：遇到多维度绝对值问题，先枚举符号消除绝对值；需要选前M大值，排序后贪心选择。下一次遇到类似问题，你也能轻松解决啦！💪
</conclusion>

---
处理用时：164.18秒
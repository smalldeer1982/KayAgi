# 题目信息

# [ABC354F] Useless for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_f

長さ $ N $ の整数列 $ A $ が与えられます。

$ t\ =\ 1,\ 2,\ \dots\ ,N $ について、 $ A_t $ が $ A $ の最長増加部分列に含まれることがあるか判定してください。

$ A_t $ が $ A $ の最長増加部分列に含まれることがあるとは、以下のことをいいます。

- 最長増加部分列の長さを $ L $ とする。各要素が $ 1 $ 以上 $ N $ 以下の単調増加な整数列 $ i\ =\ (i_1,\ i_2,\ \dots\ ,i_L)\ (i_1\ であって以下をすべて満たすものが存在する。 $
  
  
  - $ A_{i_1} $
  - ある $ k\ (1\ \leq\ k\ \leq\ L) $ が存在して $ i_k\ =\ t $ である

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

最長増加部分列とは？列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下

### Sample Explanation 1

最長増加部分列の $ 1 $ つは $ (2,\ 4,\ 5) $ で、長さは $ 3 $ です。$ (1,\ 4,\ 5) $ も最長増加部分列の $ 1 $ つです。しかし、 $ A_5 $ を含む最長増加部分列はありません。 よって、 $ 1,\ 2,\ 3,\ 4 $ を出力します。

## 样例 #1

### 输入

```
1
5
2 1 4 5 3```

### 输出

```
4
1 2 3 4```

## 样例 #2

### 输入

```
2
6
2 5 3 4 3 4
5
10000 1000 100 1 10```

### 输出

```
5
1 3 4 5 6
2
4 5```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC354F] Useless for LIS 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最长递增子序列（LIS）的扩展应用 & 动态规划优化（树状数组/二分）

🗣️ **初步分析**：  
解决“判断元素是否属于某个LIS”的问题，关键在于**拆解LIS的结构**。想象LIS是一条“最长的上升链条”，每个元素要成为链条的一部分，必须满足：**以它结尾的最长链条长度** + **以它开头的最长链条长度** - 1（减去重复计算的自己）等于整条链条的长度。  

具体来说，我们需要计算两个数组：  
- `f[i]`：以`A[i]`结尾的最长递增子序列长度（从左到右计算）；  
- `g[i]`：以`A[i]`开头的最长递增子序列长度（从右到左计算，等价于求最长递减子序列）。  
若`f[i] + g[i] - 1 == L`（`L`为整个序列的LIS长度），则`A[i]`属于某个LIS。  

**核心难点**：  
1. 高效计算`f`和`g`数组（需优化到`O(n log n)`）；  
2. 处理大数值的离散化（因为`A[i]`可达`1e9`，无法直接作为数组下标）。  

**可视化设计思路**：  
用8位像素风格展示序列元素，用不同颜色表示`f[i]`和`g[i]`的值（比如红色越深表示`f[i]`越大）。当计算`f[i]`时，用“像素箭头”从左到右遍历，树状数组的查询/更新用“方块闪烁”表示；计算`g[i]`时则从右到左。最后，符合条件的元素会“发光”，并播放“叮”的音效。


## 2. 精选优质题解参考

### 题解一：（来源：fuxiheng，赞：7）  
* **点评**：  
  这份题解的思路非常清晰，直接命中问题核心——用`f`和`g`数组判断元素是否在LIS中。代码采用**二分优化**计算`f`和`g`，避免了树状数组的实现复杂度，适合初学者理解。例如，计算`f[i]`时，用`lower_bound`找到第一个大于等于`A[i]`的位置，更新`f[i]`为该位置的索引，这种方法简洁高效。同时，代码处理了多测试用例的情况，边界条件（如`p`数组的初始化）考虑周到，是一份非常标准的模板题解。

### 题解二：（来源：Keroshi，赞：3）  
* **点评**：  
  此题解采用**树状数组优化**，更适合处理大规模数据（如`n=2e5`）。作者通过离散化将`A[i]`映射到`1~m`的范围，解决了大数值的问题。代码中的`fenwick`结构体封装了树状数组的查询和更新操作，模块化程度高，可读性强。此外，作者提到了类似问题（AT_chokudai_S001_h），引导学习者举一反三，具有很好的启发性。

### 题解三：（来源：small_john，赞：1）  
* **点评**：  
  这份题解的亮点在于**代码的规范性**和**细节处理**。作者用`template`封装了输入输出函数，避免了重复代码；树状数组的实现中，`add`和`ask`函数的下标处理（`x++`）非常巧妙，避免了边界问题。此外，作者通过`set`存储答案，确保了输出的有序性，这种细节处理体现了良好的编程习惯。


## 3. 核心难点辨析与解题策略

### 1. **难点1：高效计算`f`和`g`数组**  
* **分析**：  
  传统的LIS动态规划（`O(n^2)`）无法处理`n=2e5`的规模，必须优化到`O(n log n)`。常见的优化方法有两种：  
  - **二分法**：维护一个递增序列`p`，`p[k]`表示长度为`k`的LIS的最小末尾元素。遍历`A[i]`时，用`lower_bound`找到`p`中第一个大于等于`A[i]`的位置，更新`p`和`f[i]`。  
  - **树状数组**：通过离散化将`A[i]`映射到`1~m`的范围，用树状数组维护前缀最大值，快速查询`A[i]-1`的最大`f`值。  

* 💡 **学习笔记**：`O(n log n)`的LIS优化是处理大规模序列问题的关键，必须掌握。

### 2. **难点2：离散化处理大数值**  
* **分析**：  
  当`A[i]`的值很大时（如`1e9`），无法直接作为树状数组的下标。此时需要将`A[i]`排序去重，映射到`1~m`的连续整数（`m`为不同值的数量）。例如，`A = [2,1,4,5,3]`离散化后变为`[2,1,3,4,2]`。  

* 💡 **学习笔记**：离散化是处理大数值问题的常用技巧，步骤为“排序→去重→映射”。

### 3. **难点3：判断元素是否在LIS中**  
* **分析**：  
  元素`A[i]`属于某个LIS的充要条件是`f[i] + g[i] - 1 == L`（`L`为整个序列的LIS长度）。其中，`g[i]`可以通过将序列反转，求最长递减子序列（等价于最长递增子序列）得到。  

* 💡 **学习笔记**：拆解LIS的结构是解决此类问题的核心思路，需理解`f`和`g`数组的含义。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了树状数组优化和离散化处理，是解决此类问题的典型实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int MAXN = 2e5 + 5;
  int a[MAXN], b[MAXN], f[MAXN], g[MAXN];
  int tr[MAXN]; // 树状数组

  int lowbit(int x) { return x & -x; }
  void update(int x, int v, int n) {
      for (; x <= n; x += lowbit(x))
          tr[x] = max(tr[x], v);
  }
  int query(int x) {
      int res = 0;
      for (; x; x -= lowbit(x))
          res = max(res, tr[x]);
      return res;
  }

  int main() {
      int T; cin >> T;
      while (T--) {
          int n; cin >> n;
          for (int i = 1; i <= n; i++) {
              cin >> a[i];
              b[i] = a[i];
          }
          // 离散化
          sort(b + 1, b + n + 1);
          int m = unique(b + 1, b + n + 1) - b - 1;
          for (int i = 1; i <= n; i++)
              a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
          // 计算f[i]：以a[i]结尾的LIS长度
          fill(tr, tr + m + 1, 0);
          int L = 0;
          for (int i = 1; i <= n; i++) {
              f[i] = query(a[i] - 1) + 1;
              update(a[i], f[i], m);
              L = max(L, f[i]);
          }
          // 计算g[i]：以a[i]开头的LIS长度（反转序列求最长递减）
          fill(tr, tr + m + 1, 0);
          for (int i = n; i >= 1; i--) {
              g[i] = query(m - a[i]) + 1; // 反转后求递增，等价于原序列递减
              update(m - a[i] + 1, g[i], m);
          }
          // 收集答案
          vector<int> ans;
          for (int i = 1; i <= n; i++)
              if (f[i] + g[i] - 1 == L)
                  ans.push_back(i);
          // 输出
          cout << ans.size() << endl;
          for (int x : ans) cout << x << " ";
          cout << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为四个部分：  
  1. **输入处理**：读取测试用例和序列；  
  2. **离散化**：将`a[i]`映射到`1~m`的范围；  
  3. **计算`f`数组**：用树状数组维护前缀最大值，计算以`a[i]`结尾的LIS长度；  
  4. **计算`g`数组**：反转序列，用树状数组计算以`a[i]`开头的LIS长度；  
  5. **收集答案**：判断`f[i] + g[i] - 1 == L`，输出符合条件的元素。


### 题解一（fuxiheng）代码片段赏析  
* **亮点**：用二分法优化LIS，代码简洁。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; i++) {
      f[i] = lower_bound(p + 1, p + n + 1, a[i]) - p;
      p[f[i]] = a[i];
      Max = max(Max, f[i]);
  }
  ```
* **代码解读**：  
  - `p`数组维护长度为`k`的LIS的最小末尾元素；  
  - `lower_bound`找到`p`中第一个大于等于`a[i]`的位置，该位置即为`f[i]`（以`a[i]`结尾的LIS长度）；  
  - 更新`p[f[i]]`为`a[i]`，确保`p`数组的递增性。  
* 💡 **学习笔记**：二分法优化LIS的关键是维护`p`数组的递增性，通过`lower_bound`快速找到插入位置。


### 题解二（Keroshi）代码片段赏析  
* **亮点**：树状数组封装，模块化程度高。  
* **核心代码片段**：  
  ```cpp
  struct fenwick {
      int a[N];
      int query(int u) {
          int res = 0;
          for (; u; u -= lowbit(u)) res = max(res, a[u]);
          return res;
      }
      void modify(int u, int x) {
          for (; u <= n; u += lowbit(u)) a[u] = max(a[u], x);
      }
  } t1, t2;
  ```
* **代码解读**：  
  - `fenwick`结构体封装了树状数组的`query`（查询前缀最大值）和`modify`（更新最大值）操作；  
  - `t1`用于计算`f`数组（从左到右），`t2`用于计算`g`数组（从右到左）。  
* 💡 **学习笔记**：模块化编程可以提高代码的可读性和可维护性，建议在复杂问题中使用。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素链条探险》  
**设计思路**：用8位像素风格模拟LIS的“链条”结构，让学习者直观看到`f`和`g`数组的计算过程，以及元素是否符合条件的判断。融合复古游戏元素（如音效、关卡），增加学习趣味性。


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示像素化序列（每个元素是一个16x16的方块，颜色表示`A[i]`的值，如蓝色越深表示值越大）；  
   - 屏幕右侧显示`f`和`g`数组的像素表（红色表示`f[i]`，绿色表示`g[i]`，亮度越高表示值越大）；  
   - 底部有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块。  

2. **计算`f`数组（从左到右）**：  
   - 用“像素箭头”从左到右遍历序列，每到一个元素，树状数组的查询操作会触发“方块闪烁”（查询`A[i]-1`的最大`f`值）；  
   - 更新`f[i]`时，右侧`f`数组的对应位置会“亮起”（红色亮度增加）；  
   - 播放轻微的“叮”音效，表示完成一次更新。  

3. **计算`g`数组（从右到左）**：  
   - 用“像素箭头”从右到左遍历序列，同理，树状数组的查询操作触发“方块闪烁”；  
   - 更新`g[i]`时，右侧`g`数组的对应位置会“亮起”（绿色亮度增加）；  
   - 播放轻微的“叮”音效。  

4. **判断条件（`f[i] + g[i] -1 == L`）**：  
   - 符合条件的元素会“发光”（周围出现黄色边框），并播放“胜利”音效（如“叮~叮~”）；  
   - 不符合条件的元素会“变暗”（颜色变灰）。  

5. **游戏式关卡**：  
   - 将计算`f`和`g`数组分为两个“关卡”，完成一个关卡后，显示“关卡完成”提示，并给予“像素星星”奖励；  
   - 完成所有步骤后，显示“任务完成”动画（如像素烟花）。


### 旁白提示  
- （计算`f[i]`时）“现在计算以第`i`个元素结尾的最长链条长度，看看它能接在哪个链条后面~”；  
- （更新`f[i]`时）“第`i`个元素的链条长度是`f[i]`，把它加入链条库~”；  
- （判断条件时）“第`i`个元素的链条长度加开头长度等于最长链条，它是链条的一部分！”。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
`f`和`g`数组的思路不仅能解决本题，还能用于：  
1. **寻找所有LIS**：通过`f`和`g`数组找到所有可能的LIS路径；  
2. **修改元素使LIS最长**：通过`f`和`g`数组判断修改哪个元素能延长LIS；  
3. **多维LIS问题**：如二维平面上的最长递增子序列（需调整`f`和`g`的计算方式）。


### 练习推荐 (洛谷)  
1. **洛谷 P1020 导弹拦截**  
   - 🗣️ **推荐理由**：这道题是LIS的经典变形，需要计算最长非递增子序列（等价于最长递减子序列），可以巩固`f`和`g`数组的思路。  
2. **洛谷 P1439 最长公共子序列**  
   - 🗣️ **推荐理由**：本题可以通过将第二个序列映射到第一个序列的下标，转化为LIS问题，锻炼离散化和LIS优化的能力。  
3. **洛谷 P2782 友好城市**  
   - 🗣️ **推荐理由**：这道题是二维LIS的问题，需要先排序一维，再计算另一维的LIS，拓展对`f`数组的理解。


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自 rhn7)  
> “别瞎用`memset`，用过的数再清空。”  

**点评**：`memset`是按字节清空的，对于`int`数组（4字节），用`memset`清空会设置为`0x00000000`，但如果数组中有非零值，用`fill`或循环清空更安全。这位作者的经验提醒我们，在处理多测试用例时，必须正确清空数组，避免残留值影响结果。


## 结语  
本次关于“[ABC354F] Useless for LIS”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解LIS的扩展应用和动态规划优化技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：189.19秒
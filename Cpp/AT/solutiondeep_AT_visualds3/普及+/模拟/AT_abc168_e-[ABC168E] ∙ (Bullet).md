# 题目信息

# [ABC168E] ∙ (Bullet)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc168/tasks/abc168_e

$ N $ 匹のイワシが釣れました。$ i $ 匹目のイワシの美味しさは $ A_i $、香り高さは $ B_i $ です。

この中から $ 1 $ 匹以上のイワシを選んで同じクーラーボックスに入れますが、互いに仲が悪い $ 2 $ 匹を同時に選ぶことはできません。

$ i $ 匹目と $ j\ (\neq\ i) $ 匹目のイワシは、$ A_i\ \cdot\ A_j\ +\ B_i\ \cdot\ B_j\ =\ 0 $ を満たすとき(また、その時に限り)仲が悪いです。

イワシの選び方は何通りあるでしょう？答えは非常に大きくなる可能性があるので、$ 1000000007 $ で割ったあまりを出力してください。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ -10^{18}\ \leq\ A_i,\ B_i\ \leq\ 10^{18} $

### Sample Explanation 1

条件を満たす選び方は以下の $ 5 $ 通りです。 - $ 1 $ 匹目 - $ 1,\ 2 $ 匹目 - $ 2 $ 匹目 - $ 2,\ 3 $ 匹目 - $ 3 $ 匹目

## 样例 #1

### 输入

```
3

1 2

-1 1

2 -1```

### 输出

```
5```

## 样例 #2

### 输入

```
10

3 2

3 2

-1 1

2 -1

-3 -9

-8 12

7 7

8 1

8 2

8 4```

### 输出

```
479```

# AI分析结果



---
# 💡 Kay的C++算法解析：ABC168E (Bullet) 深入学习指南 💡

<introduction>
今天我们来一起分析“ABC168E (Bullet)”这道C++编程题。这道题的关键在于通过数学变形将问题转化为分数对的统计，并结合组合数学计算合法选法的总数。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学与组合计数（分数归一化+哈希表统计+快速幂）` 

🗣️ **初步分析**：
解决这道题的关键在于将条件 \( A_i \cdot A_j + B_i \cdot B_j = 0 \) 转化为分数形式。我们可以将其变形为 \( \frac{A_i}{B_i} = -\frac{B_j}{A_j} \)（假设 \( B_i, A_j \neq 0 \)）。这意味着，如果两个二元组的分数互为“相反数倒数”（如 \( (a,b) \) 和 \( (-b,a) \)），它们不能同时被选中。

核心思路是：
1. **分数归一化**：将每个 \( (A_i, B_i) \) 约分为最简分数，并统一符号（如保证分母为正），避免重复统计。
2. **哈希表统计**：用 `map` 统计每种分数的出现次数。
3. **组合计算**：对于每对互为相反数倒数的分数 \( (a,b) \) 和 \( (-b,a) \)，计算它们的方案数（\( 2^x + 2^y -1 \)，其中 \( x,y \) 是两者的出现次数），并通过乘法原理累乘所有对的方案数。
4. **特殊处理**：处理 \( (0,0) \) 这类特殊情况（只能单独选）和 \( A_i \) 或 \( B_i \) 为0的情况。

**可视化设计思路**：  
我们可以设计一个“分数配对像素游戏”，用8位像素风格展示分数归一化过程（如将原始分数通过约分、符号调整变为标准形式），并用不同颜色的像素块表示互为相反数倒数的分数对。动画中，每处理一对分数，会展示它们的出现次数 \( x \) 和 \( y \)，并动态计算 \( 2^x + 2^y -1 \) 的过程（如像素方块堆叠表示幂次，加减操作伴随“叮”的音效）。特殊的 \( (0,0) \) 会被标记为红色单独区域，提示只能单独选择。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑清晰、代码高效被选为优质参考（评分≥4星）：
</eval_intro>

**题解一：作者hyxgg**
* **点评**：此题解完整覆盖了所有边界条件（如 \( (0,0) \)、单零情况），代码逻辑清晰。尽管在幂次计算中使用了循环（可优化为快速幂），但对各步骤的处理（如归一化时的符号调整）非常细致，适合理解完整流程。

**题解二：作者buowen123**
* **点评**：此题解巧妙使用快速幂优化计算 \( 2^x \)，代码结构简洁。对分数归一化的处理（强制分子非负）避免了重复统计，且对互为相反数倒数的分数对的处理逻辑直接（通过 `map.count` 检查存在性），是竞赛中典型的高效实现。

**题解三：作者Super_Cube**
* **点评**：此题解代码极为精简，通过预处理 `base` 数组存储 \( 2^i \mod 1e9+7 \)，进一步优化了幂次计算。对分数归一化的符号处理（如分母为负时调整分子分母符号）非常严谨，是追求代码简洁与效率的典范。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1：分数的归一化处理**  
    * **分析**：直接使用浮点数存储 \( \frac{A_i}{B_i} \) 会因精度问题出错。优质题解通常通过约分（除以最大公约数）并统一符号（如保证分母为正）来标准化分数。例如，若 \( B_i \) 为负，则同时取反 \( A_i \) 和 \( B_i \)，确保分母始终为正。
    * 💡 **学习笔记**：归一化是避免重复统计的关键，符号统一能确保相同分数的不同表示被正确归为一类。

2.  **关键点2：互为相反数倒数的分数对统计**  
    * **分析**：对于每个分数 \( (a,b) \)，需找到其对应的“敌人”分数 \( (-b,a) \)。若两者都存在，则它们的方案数为 \( 2^x + 2^y -1 \)（减去同时不选的情况）；若仅存在一个，则方案数为 \( 2^x \)。优质题解通过 `map` 快速查询敌人分数的存在性，并标记已处理的分数对以避免重复计算。
    * 💡 **学习笔记**：用哈希表（如 `map`）存储分数对的出现次数，是高效统计的核心。

3.  **关键点3：特殊情况的处理（如 \( (0,0) \)）**  
    * **分析**：\( (0,0) \) 与任何其他二元组都冲突，因此只能单独选。优质题解单独统计 \( (0,0) \) 的数量，并在最终答案中加上其个数（每个 \( (0,0) \) 可选或不选，但至少选一个）。此外，处理 \( A_i \) 或 \( B_i \) 为0的情况时，需将其归一化为 \( (0,1) \) 或 \( (1,0) \) 等标准形式。
    * 💡 **学习笔记**：特殊情况需单独处理，避免与其他分数对混淆。

### ✨ 解题技巧总结
- **快速幂优化**：预处理 \( 2^i \mod 1e9+7 \) 或使用快速幂函数，避免重复计算幂次。
- **符号统一**：归一化时强制分母为正，确保相同分数的不同符号表示被正确归类。
- **哈希表标记**：处理分数对时，标记已处理的分数以避免重复计算（如将 `map` 中的计数置零）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解思路的通用核心实现，它结合了归一化、快速幂和特殊情况处理，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了buowen123和Super_Cube的思路，优化了幂次计算，并完整处理所有边界条件。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;
    const int MOD = 1e9 + 7;

    ll qpow(ll a, ll b) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int main() {
        int n;
        cin >> n;
        map<pair<ll, ll>, ll> mp;
        ll zero = 0; // 统计(0,0)的数量

        for (int i = 0; i < n; ++i) {
            ll a, b;
            cin >> a >> b;
            if (a == 0 && b == 0) {
                zero++;
                continue;
            }
            ll g = __gcd(a, b);
            a /= g; b /= g;
            // 归一化：保证分母为正
            if (b < 0) { a = -a; b = -b; }
            // 处理a=0或b=0的情况（如(0,1)或(1,0)）
            if (b == 0) a = 1; // 当b=0时，归一化为(1,0)
            if (a == 0) b = 1; // 当a=0时，归一化为(0,1)
            mp[{a, b}]++;
        }

        ll ans = 1;
        for (auto& [key, cnt] : mp) {
            if (cnt == 0) continue; // 已处理过的分数对跳过
            ll a = key.first, b = key.second;
            // 计算敌人分数：-b/a → 敌人为(-b, a)，归一化后可能为(-b', a')
            ll enemy_a = -b, enemy_b = a;
            ll g = __gcd(enemy_a, enemy_b);
            enemy_a /= g; enemy_b /= g;
            if (enemy_b < 0) { enemy_a = -enemy_a; enemy_b = -enemy_b; }
            if (enemy_b == 0) enemy_a = 1;
            if (enemy_a == 0) enemy_b = 1;

            if (mp.count({enemy_a, enemy_b})) {
                ll enemy_cnt = mp[{enemy_a, enemy_b}];
                ans = ans * (qpow(2, cnt) + qpow(2, enemy_cnt) - 1) % MOD;
                mp[{enemy_a, enemy_b}] = 0; // 标记已处理
            } else {
                ans = ans * qpow(2, cnt) % MOD;
            }
            mp[key] = 0; // 标记已处理
        }

        // 处理(0,0)：每个(0,0)可选或不选，但至少选一个（总共有2^zero -1种）
        ans = (ans * (qpow(2, zero) - 1 + MOD)) % MOD;
        // 减去全不选的情况（但(0,0)的情况已包含，这里无需额外减）
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并统计 \( (0,0) \) 的数量。对于其他二元组，通过约分和符号调整归一化后存入 `map`。然后遍历 `map`，对每对互为敌人的分数计算方案数（使用快速幂优化 \( 2^x \)），并累乘得到总方案数。最后处理 \( (0,0) \) 的选法（每个 \( (0,0) \) 可选或不选，但至少选一个）。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其亮点和关键思路。
</code_intro_selected>

**题解二：作者buowen123**
* **亮点**：使用快速幂优化 \( 2^x \) 的计算，代码简洁，归一化逻辑清晰（强制分子非负）。
* **核心代码片段**：
    ```cpp
    ll qpow(ll a, ll b) {
        ll res = 1;
        while(b) {
            if(b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }
    // ... 归一化处理 ...
    for (auto i : mp) {
        if (i.y == 0) continue;
        ll a = i.x.x, b = i.x.y;
        ll d = qpow(2, mp[mpr(a, b)]);
        // 计算敌人分数并处理
        if (mp.count(mpr(b, a))) {
            d = (d + qpow(2, mp[mpr(b, a)]) - 1) % mod;
            mp[mpr(b, a)] = 0;
        }
        ans = ans * d % mod;
    }
    ```
* **代码解读**：  
  `qpow` 函数通过快速幂计算 \( 2^x \mod 1e9+7 \)，时间复杂度 \( O(\log x) \)，比循环乘法更高效。在遍历 `map` 时，对每个分数 \( (a,b) \)，计算其敌人分数 \( (b,a) \)（注意符号调整），若存在则合并计算方案数，并标记为已处理（置零），避免重复计算。
* 💡 **学习笔记**：快速幂是处理大指数模运算的必备技巧，能显著提升效率。

**题解三：作者Super_Cube**
* **亮点**：预处理 `base` 数组存储 \( 2^i \mod 1e9+7 \)，进一步优化幂次计算，代码极简。
* **核心代码片段**：
    ```cpp
    int base[200005];
    // 预处理2的幂次
    base[0] = 1;
    for(int i=1; i<=n; ++i) {
        base[i] = (base[i-1] << 1) % mod;
    }
    // ... 归一化处理 ...
    for(const auto& i : mp) {
        int res = base[i.second];
        ll x = -i.first.second, y = i.first.first;
        // 归一化敌人分数
        if(y < 0) x = -x, y = -y;
        if(mp.count({x, y})) {
            res = (res + base[mp[{x, y}]] - 1) % mod;
            mp.erase({x, y});
        }
        ans = 1ll * ans * res % mod;
    }
    ```
* **代码解读**：  
  预处理 `base` 数组后，\( 2^x \) 可直接通过 `base[x]` 获取，时间复杂度 \( O(1) \)，适合 \( N \) 较大的场景（如 \( 2e5 \)）。遍历 `map` 时，通过 `mp.erase` 移除已处理的敌人分数对，避免重复计算。
* 💡 **学习笔记**：预处理常用值（如幂次）是竞赛中优化时间的重要手段。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解分数对的统计和方案计算过程，我们设计一个“分数配对像素游戏”，用8位复古风格展示算法核心步骤。
</visualization_intro>

  * **动画演示主题**：`像素分数配对大冒险`  
  * **核心演示内容**：展示分数归一化、敌人分数对的匹配、方案数计算（\( 2^x + 2^y -1 \)）及 \( (0,0) \) 特殊处理的全过程。

  * **设计思路简述**：  
    8位像素风（如FC游戏画面）营造轻松氛围，不同颜色的像素块代表不同分数（如蓝色块为 \( (a,b) \)，红色块为其敌人 \( (-b,a) \)）。关键操作（如归一化、配对）伴随“叮”的音效，方案数计算时用像素堆叠动画展示 \( 2^x \) 的增长，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1. **场景初始化**：  
       屏幕左侧为“分数池”（展示原始二元组），右侧为“归一化工厂”（像素风格的流水线），顶部为“配对区”（展示互为敌人的分数对）。控制面板包含“单步执行”“自动播放”按钮和速度滑块。

    2. **归一化处理**：  
       每个原始二元组（如 \( (2,4) \)）进入“归一化工厂”，流水线自动约分（显示 \( \gcd(2,4)=2 \)），调整符号（若分母为负则取反分子分母），最终输出归一化后的分数（如 \( (1,2) \)），伴随“滴”的音效。

    3. **敌人分数匹配**：  
       归一化后的分数块（蓝色）移动到“配对区”，系统自动查找其敌人分数（如 \( (1,2) \) 的敌人是 \( (-2,1) \)，归一化后为 \( (-2,1) \) 调整符号为 \( (2,-1) \)？不，正确敌人应为 \( (-2,1) \) 归一化后若分母为负则调整为 \( (2,-1) \) 变为 \( (-2,1) \)？需修正逻辑）。若找到敌人分数块（红色），两者会被框起来，显示它们的出现次数 \( x \) 和 \( y \)。

    4. **方案数计算**：  
       蓝色块和红色块分别生成像素堆叠动画（蓝色堆叠 \( x \) 层，红色堆叠 \( y \) 层），表示 \( 2^x \) 和 \( 2^y \)。然后合并为一个大的堆叠块，并移除顶部的一个像素（表示减去同时不选的情况），最终显示 \( 2^x + 2^y -1 \)，伴随“咚”的音效。

    5. **特殊情况处理**：  
       \( (0,0) \) 会被标记为金色块，单独放在“特殊区”，动画中显示每个金色块可选或不选（用闪烁表示），最终总方案数为 \( 2^{\text{zero}} -1 \)。

    6. **目标达成**：  
       所有分数对处理完成后，总方案数从屏幕底部升起，伴随“胜利”音效，庆祝动画（如像素烟花）。

  * **旁白提示**：  
    - “看！这个二元组 \( (2,4) \) 进入归一化工厂，被约分为 \( (1,2) \) 啦～”  
    - “现在，\( (1,2) \) 要找它的敌人 \( (-2,1) \) 了！如果找到了，它们的方案数就是 \( 2^x + 2^y -1 \) 哦～”  
    - “金色的 \( (0,0) \) 很特殊，只能单独选，所以总共有 \( 2^{\text{zero}} -1 \) 种选法～”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到分数对的匹配过程和方案数的计算逻辑，轻松理解算法核心！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是数学变形+哈希表统计+组合计数，这类思路在处理“互斥条件下的选法计数”问题中非常常见。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - **条件变形**：将复杂条件转化为数学等式（如本题的 \( A_iA_j + B_iB_j=0 \) 转化为分数对）。  
    - **哈希表统计**：用哈希表统计特征值（如分数对）的出现次数，快速查找互斥对。  
    - **组合计算**：利用乘法原理和加法原理计算合法选法（如 \( 2^x + 2^y -1 \)）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1313** - `计算系数`  
        * 🗣️ **推荐理由**：考察组合数学与快速幂，与本题的幂次计算技巧相关。  
    2.  **洛谷 P2398** - `GCD SUM`  
        * 🗣️ **推荐理由**：需将问题转化为数学求和，并使用哈希表统计，锻炼条件变形能力。  
    3.  **洛谷 P5231** - `[JSOI2012]玄武密码`  
        * 🗣️ **推荐理由**：涉及哈希表统计和字符串处理，与本题的哈希表应用思路类似。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如处理 \( (0,0) \) 时容易遗漏或重复计算，这对我们很有参考价值：
</insights_intro>

> **参考经验 (来自hyxgg)**：“最开始没考虑 \( (0,0) \) 的情况，导致样例1没通过。后来发现 \( (0,0) \) 不能和任何其他鱼共存，必须单独统计。”  
> **点评**：作者的经验提醒我们，特殊情况（如全零、单零）是易错点，需单独处理并通过样例验证。在编程时，可先列出所有可能的边界条件（如 \( A_i=0 \)、\( B_i=0 \)、\( A_i=B_i=0 \)），逐一检查是否被代码覆盖。

---

<conclusion>
本次关于“ABC168E (Bullet)”的C++解题分析就到这里。通过理解分数归一化、哈希表统计和组合计数的核心思路，相信大家能轻松解决类似问题。记住，多动手调试、关注特殊情况，是提升编程能力的关键！下次见～💪
</conclusion>

---
处理用时：165.71秒
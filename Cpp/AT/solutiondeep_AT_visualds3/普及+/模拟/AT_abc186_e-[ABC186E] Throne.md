# 题目信息

# [ABC186E] Throne

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc186/tasks/abc186_e

円周上に $ N $ 個の椅子が並べられています。そのうち $ 1 $ つは玉座です。

高橋君は最初、玉座から時計回りに数えて $ S $ 個隣の椅子に座っており、次の行動を繰り返します。

行動：いま座っている椅子から時計回りに数えて $ K $ 個隣の椅子に移動し座る。

高橋君がはじめて玉座に座ることができるのは何回目の行動の後ですか？ ただし、玉座に座ることが永遠にできない場合は、代わりに `-1` を出力してください。

$ T $ 個のテストケースに答えてください。

## 说明/提示

### 制約

- $ 1\leq\ T\ \leq\ 100 $
- $ 2\leq\ N\ \leq\ 10^9 $
- $ 1\leq\ S\ <\ N $
- $ 1\leq\ K\ \leq\ 10^9 $

### Sample Explanation 1

$ 1 $ つ目のテストケースでは、椅子が $ 10 $ 個あり、高橋君は最初、玉座から時計回りに数えて $ 4 $ 個隣の席に座っています。 時計回りに $ 3 $ 個隣の席に移動する行動を $ 2 $ 回行うと玉座に座れます。 $ 2 $ つ目のテストケースでは、高橋君が玉座に座ることは永遠にできないので、`-1` を出力します。

## 样例 #1

### 输入

```
4

10 4 3

1000 11 2

998244353 897581057 595591169

10000 6 14```

### 输出

```
2

-1

249561088

3571```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC186E] Throne 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC186E] Throne”这道C++编程题。这道题看似是一个循环移动问题，实则需要利用数论中的同余方程求解。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（同余方程求解）`

🗣️ **初步分析**：
> 解决“Throne”这道题，关键在于将问题转化为同余方程模型。同余方程就像一把“钥匙”，能帮我们在循环问题中找到规律——比如，高桥君每次移动K步，最终要回到玉座（0号位置），这相当于在模N的循环中找到最小的x，使得初始位置S加上x次K步的移动后，模N等于0。  
> 题解的核心思路是建立同余方程 \( Kx \equiv (N - S) \pmod{N} \)，然后通过扩展欧几里得算法或求逆元求解x的最小正整数解。核心难点在于：如何正确建立同余方程、判断方程是否有解（即gcd(K,N)是否整除(N-S)）、以及求解最小正整数解。  
> 可视化设计上，我们可以用8位像素风的“椅子环”模拟移动过程：每个椅子用像素方块表示，当前位置用闪烁的箭头标记，每移动K步播放“滴答”音效。当找到解时，玉座位置会闪烁金色，提示成功；若无解则显示红色警告。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选出以下优质题解（≥4星），它们在同余方程建模和求解上表现突出：
</eval_intro>

**题解一：CodingOIer (来源：用户分享)**
* **点评**：此题解思路非常清晰，严格遵循同余方程求解的标准步骤：先建立方程 \( Kx \equiv (N - S) \pmod{N} \)，再通过计算gcd判断是否有解，最后用扩展欧几里得算法求解。代码结构工整，变量命名如`exGcd`（扩展欧几里得）、`solve`（主处理函数）含义明确，边界条件（如s%g!=0时输出-1）处理严谨。算法时间复杂度为 \( O(T \log N) \)，高效且适用于大数范围（如题目中N到 \(10^9\)），实践价值很高。

**题解二：Genius_Star (来源：用户分享)**
* **点评**：此题解将同余方程与逆元求解结合，步骤简洁。代码中使用了快速读入（`read`函数）和逆元计算（`inv`函数），体现了良好的编码习惯。特别地，代码中先对n、s、k同除它们的最大公约数，简化了后续计算，这一优化是亮点。算法逻辑与数学推导紧密结合，适合学习如何将数论知识转化为代码实现。

**题解三：loser_seele (来源：用户分享)**
* **点评**：此题解充分利用了atcoder的逆元库（`atcoder::inv_mod`），代码极其简洁。虽然依赖外部库，但思路清晰——先约分，再判断是否互质，最后用逆元求解。这种“站在巨人肩膀上”的编码方式（合理使用库函数）是竞赛中的实用技巧，值得借鉴。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了核心思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何建立正确的同余方程？
    * **分析**：题目中，高桥君初始位置是玉座的S个位置后（编号为S），每次移动K步，x次后到达玉座（0号位置）。因此有 \( S + Kx \equiv 0 \pmod{N} \)，移项得 \( Kx \equiv -S \pmod{N} \)。由于模运算中负数可以转化为正数（\(-S \equiv N - S \pmod{N}\)），最终方程为 \( Kx \equiv (N - S) \pmod{N} \)。优质题解都能准确完成这一步建模。
    * 💡 **学习笔记**：循环移动问题常转化为同余方程，关键是抓住“最终位置=初始位置+总移动步长”的模关系。

2.  **关键点2**：如何判断方程是否有解？
    * **分析**：同余方程 \( Kx \equiv C \pmod{N} \) 有解的充要条件是 \( \gcd(K, N) \mid C \)（即C能被K和N的最大公约数整除）。题解中通常先计算gcd(K, N)，再检查 \( (N - S) \) 是否能被该gcd整除。若不能，则输出-1；若能，则将方程两边同除以gcd，转化为互质情况下的求解。
    * 💡 **学习笔记**：判断是否有解是避免“死循环”的关键，这一步需要严格的数论知识支撑。

3.  **关键点3**：如何求解最小正整数解？
    * **分析**：当方程有解时，需将方程简化为 \( K'x \equiv C' \pmod{N'} \)（其中 \( K' = K/\text{gcd}, N' = N/\text{gcd}, C' = (N - S)/\text{gcd} \)），此时 \( K' \) 与 \( N' \) 互质。此时 \( K' \) 在模 \( N' \) 下存在逆元，解为 \( x \equiv C' \cdot (K')^{-1} \pmod{N'} \)。最小正整数解即为 \( (C' \cdot \text{inv}(K', N')) \mod N' \)。
    * 💡 **学习笔记**：互质条件下逆元的存在性是求解的核心，扩展欧几里得算法是求逆元的通用方法。

### ✨ 解题技巧总结
<summary_best_practices>
-   **问题抽象**：将循环移动问题抽象为同余方程，抓住“总移动步长模N等于目标偏移量”的核心关系。
-   **约分简化**：先对n、s、k同除它们的最大公约数，减少计算量并避免大数溢出。
-   **逆元求解**：当系数与模数互质时，利用扩展欧几里得算法求逆元，快速得到最小正整数解。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，它完整展示了同余方程求解的全流程。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了CodingOIer和Genius_Star的思路，采用扩展欧几里得算法求解逆元，步骤清晰，适用于大数范围。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    using namespace std;
    typedef long long ll;

    // 扩展欧几里得算法求ax + by = gcd(a,b)的解(x,y)
    void exGcd(ll a, ll b, ll &x, ll &y) {
        if (b == 0) {
            x = 1, y = 0;
            return;
        }
        exGcd(b, a % b, y, x);
        y -= a / b * x;
    }

    // 求a在模mod下的逆元（要求a和mod互质）
    ll inv(ll a, ll mod) {
        ll x, y;
        exGcd(a, mod, x, y);
        return (x % mod + mod) % mod; // 确保逆元为正
    }

    void solve() {
        ll n, s, k;
        scanf("%lld%lld%lld", &n, &s, &k);
        ll target = n - s; // 转化为Kx ≡ target mod n
        ll g = __gcd(k, n); // 计算gcd(K, n)

        if (target % g != 0) { // 无解条件：target不能被gcd整除
            printf("-1\n");
            return;
        }

        // 约分，简化方程
        ll k_new = k / g, n_new = n / g, target_new = target / g;
        ll inv_k = inv(k_new, n_new); // 求k_new在模n_new下的逆元
        ll x = (target_new * inv_k) % n_new; // 最小正整数解
        printf("%lld\n", x);
    }

    int main() {
        int T;
        scanf("%d", &T);
        while (T--) {
            solve();
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先通过`exGcd`实现扩展欧几里得算法，用于求逆元。`solve`函数中，先计算目标值`target = n - s`，再求`k`和`n`的最大公约数`g`。若`target`不能被`g`整除，直接输出-1；否则约分得到新的系数`k_new`、模数`n_new`和目标值`target_new`，此时`k_new`与`n_new`互质，通过`inv`函数求逆元，最终计算最小正整数解`x`。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，看它们如何巧妙实现关键逻辑。
</code_intro_selected>

**题解一：CodingOIer**
* **亮点**：代码严格遵循同余方程求解步骤，变量名清晰（如`exGcd`），边界条件处理严谨。
* **核心代码片段**：
    ```cpp
    void exGcd(long long a, long long b, long long &x, long long &y) {
        if (b == 0) {
            x = 1, y = 0;
            return;
        }
        exGcd(b, a % b, y, x);
        y -= a / b * x;
    }
    ```
* **代码解读**：
    > 这段代码是扩展欧几里得算法的实现。当`b=0`时，方程`a*1 + 0*0 = a`成立，故`x=1, y=0`。递归调用`exGcd(b, a%b, y, x)`后，原方程变为`b*y + (a%b)*x = gcd`，而`a%b = a - (a/b)*b`，代入后可得`a*x + b*(y - (a/b)*x) = gcd`，因此`y`需要减去`(a/b)*x`。这一步是扩展欧几里得算法的核心，通过递归不断缩小问题规模。
* 💡 **学习笔记**：扩展欧几里得算法不仅能求gcd，还能求出贝祖系数（x和y），这是求解同余方程的关键工具。

**题解二：Genius_Star**
* **亮点**：代码中先对n、s、k同除它们的最大公约数，简化了后续计算，避免大数运算。
* **核心代码片段**：
    ```cpp
    t = __gcd(n, __gcd(s, k));
    n /= t, s /= t, k /= t;
    if (__gcd(n, k) != 1) {
        puts("-1");
        return;
    }
    ```
* **代码解读**：
    > 这段代码先计算n、s、k的最大公约数`t`，并将三者同除以`t`。这一步的目的是简化方程：原方程 \( Kx \equiv (N - S) \pmod{N} \) 等价于 \( (K/t)x \equiv (N/t - S/t) \pmod{N/t} \)。约分后，若新的n和k的gcd不为1，说明原方程无解（因为此时新的目标值无法被新的gcd整除），直接输出-1。这一步优化减少了后续计算的数值大小，提升了效率。
* 💡 **学习笔记**：约分是处理大数问题的常用技巧，能有效降低计算复杂度。

**题解三：loser_seele**
* **亮点**：利用atcoder库的`inv_mod`函数直接求逆元，代码简洁高效。
* **核心代码片段**：
    ```cpp
    cout << (gcd(n, k) != 1 ? -1 : (atcoder::inv_mod(k, n) * (n - s)) % n) << '\n';
    ```
* **代码解读**：
    > 这段代码在约分后，判断n和k是否互质（gcd是否为1）。若互质，调用`atcoder::inv_mod(k, n)`求k在模n下的逆元，再乘以`(n - s)`并取模n，得到最小正整数解。`inv_mod`函数内部实现了扩展欧几里得算法，因此这行代码是对同余方程求解的高度封装。
* 💡 **学习笔记**：合理使用库函数（如竞赛中的atcoder库）可以简化代码，提升编码效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了更直观地理解同余方程求解过程，我设计了一个“像素椅子环”动画方案。通过8位像素风格的界面，模拟高桥君的移动过程，展示同余方程如何找到最小步数x。
\</visualization\_intro\>

  * **动画演示主题**：`像素椅子环大冒险`

  * **核心演示内容**：
    - 一个环形排列的像素椅子（8位风格，颜色为经典的红白机绿/灰），玉座用金色椅子标记，初始位置用蓝色箭头指向S号椅子。
    - 每移动K步，箭头顺时针跳跃K个椅子，伴随“滴答”音效（8位合成音）。
    - 动画同步展示同余方程 \( Kx \equiv (N - S) \pmod{N} \) 的求解过程：当x增加时，计算当前总步数`Kx`，并显示`(S + Kx) mod N`的值，直到该值为0（玉座位置）。

  * **设计思路简述**：
    > 采用8位像素风是为了营造轻松复古的学习氛围，符合青少年的审美。椅子环的动态移动能直观展示“模N循环”的特性，而数值的实时更新（如x和`(S + Kx) mod N`）能帮助理解同余方程的意义。关键步骤的音效（如找到解时的“叮”声）强化记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕中央显示一个环形椅子阵（用Canvas绘制，每个椅子为16x16像素方块，玉座为金色，初始位置为蓝色）。
        - 控制面板包含：单步按钮（每点击一次移动一步）、自动播放按钮（速度可调）、重置按钮。
        - 右侧显示同余方程 \( Kx \equiv (N - S) \pmod{N} \)，以及当前x值和`(S + Kx) mod N`的实时计算结果。

    2.  **单步移动**：
        - 点击单步按钮，x增加1，箭头顺时针移动K个椅子（像素动画：箭头平滑滑动，经过的椅子短暂高亮黄色）。
        - 右侧数值更新：`x=1`，`(S + K*1) mod N`显示计算结果（如S=4, K=3, N=10时，显示7）。
        - 若结果等于0（玉座位置），箭头变为金色，播放“胜利”音效（8位上扬音），动画暂停。

    3.  **自动播放**：
        - 点击自动播放按钮，x从0开始自动递增，箭头快速移动（速度由滑块调节），数值同步更新。
        - 当找到解时，动画暂停，玉座周围出现像素星星特效（闪烁的小亮点）。

    4.  **无解提示**：
        - 若遍历x到一定范围（如x=1e5）仍未找到解，屏幕显示红色警告“-1”，播放“失败”音效（短促低音）。

    5.  **方程求解同步**：
        - 动画下方显示扩展欧几里得算法的执行过程：用像素方块表示a、b、x、y的变化，每一步递归用箭头连接，关键步骤（如b=0时的初始解）高亮红色。

  * **旁白提示**：
    - （单步移动时）“当前x=1，总移动步长是K*1=3，当前位置是(S + 3) mod 10 = 7，还没到玉座哦~”
    - （找到解时）“看！x=2时，总移动步长是K*2=6，当前位置是(4 + 6) mod 10 = 0，成功到达玉座！”
    - （无解时）“x已经很大了，但位置始终无法回到0，说明这个问题无解，输出-1。”

\<visualization\_conclusion\>
通过这个像素动画，我们不仅能“看”到高桥君的移动轨迹，还能直观理解同余方程如何通过数学推导找到最小步数x。这种“动眼+动脑”的学习方式，能让数论知识更生动！
\</visualization\_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
同余方程是数论中的基础工具，除了本题的循环移动问题，还能解决许多其他类型的问题。
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：
    - **循环取模问题**：如约瑟夫环问题（求最后剩下的位置）。
    - **线性同余生成器**：如随机数生成算法中的参数求解。
    - **日期循环问题**：如计算若干天后是星期几（模7）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1082** - `同余方程`
          * 🗣️ **推荐理由**：这是同余方程的经典模板题，直接求解 \( ax \equiv 1 \pmod{b} \)，能帮你巩固扩展欧几里得算法的应用。
    2.  **洛谷 P3811** - `乘法逆元`
          * 🗣️ **推荐理由**：本题要求计算多个数的逆元，能强化你对逆元概念和快速求解方法（如线性递推）的理解。
    3.  **洛谷 P5656** - `【模板】二元一次不定方程 (exgcd)`
          * 🗣️ **推荐理由**：扩展欧几里得算法的综合应用，包括求解通解、最小正整数解等，适合提升对不定方程的整体掌握。

-----

## 7\. 学习心得与经验分享 (若有)

\<insights\_intro\>
题解中虽未明确提及作者的调试心得，但通过代码分析，我们可以总结一些实用的学习经验：
\</insights\_intro\>

> **参考经验**：在处理大数问题时（如N到 \(10^9\)），必须注意数据类型的选择（使用`long long`而非`int`），避免溢出。此外，扩展欧几里得算法的递归实现可能导致栈溢出，可改用非递归版本（但本题中N范围下递归深度较小，无需担心）。
>
> **点评**：这些细节是编程竞赛中的“隐形陷阱”。选择合适的数据类型（如`long long`）和注意算法的递归深度，能有效避免运行时错误。建议大家在编码时养成“先考虑数据范围”的习惯。

-----

\<conclusion\>
本次关于“[ABC186E] Throne”的C++解题分析就到这里。希望这份学习指南能帮助大家理解同余方程的建模与求解，掌握扩展欧几里得算法的应用。记住，数论问题的关键在于“建立正确的数学模型”，而编码时的细节（如数据类型、边界条件）同样重要。下次我们再一起探索新的编程挑战！💪
\</conclusion\>

---
处理用时：181.96秒
# 题目信息

# [ABC046C] AtCoDeerくんと選挙速報

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc046/tasks/arc062_a

シカのAtCoDeerくんは選挙速報を見ています。選挙には二人の候補高橋くんと青木くんが出ています。速報では、現在の二人の得票数の比が表示されていますが、得票数そのものは表示されていません。AtCoDeerくんは $ N $ 回画面を見て、 $ i(1≦i≦N) $ 回目に見たときに表示されている比は $ T_i:A_i $ でした。ここで、AtCoDeerくんが選挙速報の画面を$ 1 $回目に見た段階で既にどちらの候補にも少なくとも一票は入っていたことがわかっています。 $ N $ 回目に画面を見たときの投票数(二人の得票数の和)として考えられるもののうち最小となるものを求めてください。ただし、得票数が途中で減ることはありません。

## 说明/提示

### 制約

- $ 1≦N≦1000 $
- $ 1≦T_i,A_i≦1000\ (1≦i≦N) $
- $ T_i $ と $ A_i $ は互いに素 $ (1≦i≦N) $
- 答えが $ 10^{18} $ 以下になることは保証されている

### Sample Explanation 1

二人の得票数が $ 2,3 $ -&gt; $ 3,3 $ -&gt; $ 6,4 $ と動くと投票数は $ 10 $ になって、これが最小値です。

### Sample Explanation 2

一度画面を見てからもう一度画面を見るまでに一票も入ってないことがありえます。

## 样例 #1

### 输入

```
3

2 3

1 1

3 2```

### 输出

```
10```

## 样例 #2

### 输入

```
4

1 1

1 1

1 5

1 100```

### 输出

```
101```

## 样例 #3

### 输入

```
5

3 10

48 17

31 199

231 23

3 2```

### 输出

```
6930```

# AI分析结果



---
# 💡 Kay的C++算法解析：AtCoDeerくんと選挙速報 深入学习指南 💡

<introduction>
今天我们来一起分析“AtCoDeerくんと選挙速報”这道题。这道题需要我们找到选举速报中，第N次观察时可能的最小总票数。通过分析题解和算法逻辑，我们将掌握如何通过贪心策略逐步调整得票数，最终得到最小解。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与贪心策略`

🗣️ **初步分析**：
解决这道题的关键在于理解“得票数只能增加”的约束，并通过每一步的贪心调整，使当前得票数既满足新的比例要求，又尽可能小。  
简单来说，贪心策略就像“每次只做当前最有利的选择”——这里的“最有利”是让当前得票数尽可能小，从而保证最终总票数最小。  

在本题中，我们需要依次处理每一次观察到的比例 \( T_i:A_i \)。每一步需要将当前的高桥得票 \( A \) 和青木得票 \( B \) 调整为满足 \( T_i:A_i \) 的最小可能值，同时确保 \( A \) 和 \( B \) 不小于上一轮的结果。核心难点在于如何正确计算每一步的最小调整值，以及如何处理比例约束下的同步调整。  

核心算法流程可以概括为：  
1. 初始时 \( A=1, B=1 \)（第一次观察时至少各有一票）。  
2. 对于每个新的比例 \( T_i:A_i \)：  
   - 将 \( A \) 调整为 \( T_i \) 的倍数（不小于当前 \( A \) 的最小倍数）。  
   - 将 \( B \) 调整为 \( A_i \) 的倍数（不小于当前 \( B \) 的最小倍数）。  
   - 比较 \( A/T_i \) 和 \( B/A_i \)，调整较大的一方，使两者相等，从而满足 \( A:B = T_i:A_i \)。  

可视化设计时，我们可以用像素方块分别表示 \( A \) 和 \( B \) 的值，每一步调整时用颜色变化（如从灰色变亮绿色）表示“倍数调整”，用箭头动画表示“同步调整”（例如，当 \( A/T_i < B/A_i \) 时，\( A \) 方块向右扩展至 \( B/A_i \times T_i \) 的长度）。关键步骤（如倍数计算、比较决策）可配合“叮”的音效提示，增强记忆点。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下两道题解均达到5星标准，值得重点学习：
</eval_intro>

**题解一：作者Ezio__Auditore**  
* **点评**：此题解思路非常清晰，从问题本质出发，明确每一步的贪心目标（最小化当前得票数），并通过数学推导给出具体调整方法。代码规范且考虑周全：使用 `long long` 避免溢出（题目保证答案≤\(10^{18}\)），自定义 `_ceil` 函数实现向上取整，变量名 \( A,B \) 直观易懂。特别是对初始条件的处理（初始 \( A=1,B=1 \)）符合题目要求，边界处理严谨，适合直接用于竞赛。

**题解二：作者猜一猜我是谁**  
* **点评**：此题解简洁明了，核心逻辑与题解一一致，但代码更简短。通过 `ceilll` 函数实现向上取整，变量名 \( u,v \) 清晰。虽然初始值直接设为 \( T_1,A_1 \)（因 \( T_1,A_1 \) 互质，最小得票数即为 \( T_1,A_1 \)），但同样符合题目要求。代码结构工整，关键步骤注释明确，适合快速理解算法核心。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要重点关注以下三个关键点：
</difficulty_intro>

1.  **关键点1：如何调整得票数为倍数？**  
    * **分析**：为了满足新的比例 \( T_i:A_i \)，得票数 \( A \) 和 \( B \) 必须是 \( T_i \) 和 \( A_i \) 的倍数（因为 \( T_i,A_i \) 互质）。例如，若当前 \( A=2 \)，新比例 \( T_i=3 \)，则 \( A \) 需调整为 \( 3 \times \lceil 2/3 \rceil = 3 \times 1 = 3 \)（最小倍数）。  
    * 💡 **学习笔记**：向上取整公式 \( \lceil x/y \rceil = (x + y - 1) / y \) 是计算最小倍数的关键。

2.  **关键点2：如何同步调整以满足比例？**  
    * **分析**：调整为倍数后，\( A/T_i \) 和 \( B/A_i \) 可能不等。若 \( A/T_i < B/A_i \)，说明 \( A \) 偏小，需将 \( A \) 增大到 \( (B/A_i) \times T_i \)；反之则增大 \( B \)。这样能保证 \( A:B = T_i:A_i \)，且总票数最小。  
    * 💡 **学习笔记**：比例的本质是 \( A/T_i = B/A_i = k \)，找到最小的 \( k \) 即可确定 \( A,B \)。

3.  **关键点3：如何保证得票数不减少？**  
    * **分析**：每一步调整后的 \( A,B \) 必须大于等于上一轮的值。通过先调整为倍数（倍数必然≥原值），再同步调整（增大一方），自然满足不减少的约束。  
    * 💡 **学习笔记**：倍数调整是“保底”，同步调整是“对齐比例”，两者结合确保约束。

### ✨ 解题技巧总结
- **问题分解**：将总问题拆解为每一步的子问题（处理第 \( i \) 次比例），每一步的最优解保证全局最优（贪心策略）。  
- **数学公式应用**：向上取整公式直接用于计算最小倍数，避免复杂循环。  
- **变量初始化**：初始得票数设为 \( 1 \)（题目要求至少一票），后续逐步调整，确保初始条件正确。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合两道优质题解思路的通用核心实现，逻辑清晰且高效：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了题解一和题解二的思路，初始值设为 \( 1 \) 以确保符合题目要求，每一步按贪心策略调整得票数。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;
    typedef long long ll;

    ll ceil_div(ll x, ll y) {
        return (x + y - 1) / y; // 向上取整：(x/y)的上界
    }

    int main() {
        int n;
        cin >> n;
        ll A = 1, B = 1; // 初始至少各一票
        for (int i = 0; i < n; ++i) {
            ll t, a;
            cin >> t >> a;
            // 调整为t和a的倍数（不小于当前值）
            ll k1 = ceil_div(A, t);
            ll k2 = ceil_div(B, a);
            A = t * k1;
            B = a * k2;
            // 同步调整，使A/t == B/a
            if (A / t < B / a) {
                A = (B / a) * t;
            } else {
                B = (A / t) * a;
            }
        }
        cout << A + B << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取观察次数 \( n \)，初始 \( A=1,B=1 \)。对于每次观察，读取 \( T_i \) 和 \( A_i \)，计算 \( A \) 调整为 \( T_i \) 的最小倍数（\( k1 \)），\( B \) 调整为 \( A_i \) 的最小倍数（\( k2 \)）。然后比较 \( A/T_i \) 和 \( B/A_i \)，调整较大的一方使比例一致。最终输出 \( A+B \)。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Ezio__Auditore**  
* **亮点**：使用模板函数 `read` 优化输入，明确注释 `typedef long long ll` 避免溢出，`_ceil` 函数实现简洁。  
* **核心代码片段**：
    ```cpp
    auto _ceil = [](ll A, ll a) -> ll { return (A + a - 1) / a; }; 
    while (n--) {
        a = read(), b = read();
        A = a * _ceil(A, a);
        B = b * _ceil(B, b);
        if (A / a > B / b) {
            B = A / a * b;
        } else
            A = B / b * a;
    }
    ```
* **代码解读**：  
  `_ceil` 函数计算向上取整，用于确定 \( A \) 和 \( B \) 调整后的倍数。循环处理每次观察，先调整为倍数，再比较 \( A/a \) 和 \( B/b \)，调整较大的一方使比例一致。例如，若 \( A/a > B/b \)，说明 \( B \) 偏小，需将 \( B \) 增大到 \( (A/a) \times b \)，确保 \( A:B = a:b \)。  
* 💡 **学习笔记**：lambda函数 `_ceil` 使代码更简洁，向上取整公式是处理倍数问题的常用技巧。

**题解二：作者猜一猜我是谁**  
* **亮点**：代码简短，直接处理输入，初始值设为 \( T_1,A_1 \)（因互质，最小得票数即为 \( T_1,A_1 \)）。  
* **核心代码片段**：
    ```cpp
    long long ceilll(long long u,long long v){
        return (u-1)/v+1;
    }
    for(int i=2;i<=n;i++){
        u=t[i]*ceilll(u,t[i]);v=a[i]*ceilll(v,a[i]);
        if(u/t[i]<v/a[i]) u=v/a[i]*t[i];
        else v=u/t[i]*a[i];
    }
    ```
* **代码解读**：  
  `ceilll` 函数同样实现向上取整（\( (u-1)/v + 1 \) 等价于 \( \lceil u/v \rceil \)）。循环从第二次观察开始，调整 \( u \) 和 \( v \) 为当前 \( T_i \) 和 \( A_i \) 的倍数，再根据比例同步调整。例如，若 \( u/t[i] < v/a[i] \)，则 \( u \) 需增大到 \( (v/a[i]) \times t[i] \)，确保比例一致。  
* 💡 **学习笔记**：向上取整的两种实现方式（\( (x+y-1)/y \) 和 \( (x-1)/y +1 \)）等价，可根据场景选择。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解每一步的调整过程，我们设计一个“选举票数调整”像素动画，用8位复古风格展示 \( A \) 和 \( B \) 的变化！
</visualization_intro>

  * **动画演示主题**：`像素选举：调整得票小能手`  
  * **核心演示内容**：展示从初始 \( A=1,B=1 \) 开始，每次观察到新比例时，如何调整 \( A \) 和 \( B \) 为倍数，再同步对齐比例的过程。  

  * **设计思路简述**：  
    8位像素风格（如FC游戏的方块造型）让学习更轻松；关键步骤（倍数调整、比例对齐）用颜色变化和音效提示，强化记忆；“单步执行”功能允许学习者逐帧观察，理解每一步逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分，左边显示“高桥得票 \( A \)”（红色像素条），右边显示“青木得票 \( B \)”（蓝色像素条）。  
        - 底部控制面板：单步/自动按钮、速度滑块（1x-5x）、重置按钮。  
        - 播放8位风格轻快BGM（如《超级玛丽》经典旋律变奏）。

    2.  **初始状态**：  
        - \( A=1 \)（1个红色像素块），\( B=1 \)（1个蓝色像素块）。  
        - 旁白：“第一次观察时，两人至少各有一票哦！”

    3.  **处理第 \( i \) 次比例**（以样例1的第一次比例 \( 2:3 \) 为例）：  
        - **倍数调整**：  
          - 计算 \( A \) 需调整为 \( 2 \times \lceil 1/2 \rceil = 2 \)。红色像素条从1块扩展为2块（动画：像素块逐个右移，伴随“嗒嗒”音效）。  
          - 计算 \( B \) 需调整为 \( 3 \times \lceil 1/3 \rceil = 3 \)。蓝色像素条从1块扩展为3块（同理）。  
          - 旁白：“现在得票数必须是新比例的倍数，所以调整到最小的可能值！”  
        - **比例对齐**：  
          - 比较 \( 2/2=1 \) 和 \( 3/3=1 \)（相等，无需调整）。旁白：“比例刚好对齐，不需要额外调整～”

    4.  **目标达成**：  
        - 处理完所有 \( N \) 次比例后，总票数 \( A+B \) 显示为金色像素数字，伴随“叮～”胜利音效，像素条闪烁庆祝。  
        - 旁白：“完成！这就是最小的总票数啦！”

  * **旁白提示**：  
    - “看，红色条变长了！这是因为得票数必须是新比例的倍数～”  
    - “现在比较两个条的‘倍数系数’，如果不一样，就要把短的那个拉长，直到比例对齐！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到每一步得票数的调整过程，理解贪心策略如何确保总票数最小。点击“单步”慢慢看，或者调快速度看整体流程，都能帮你更深刻地掌握算法！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“逐步调整变量以满足约束，并保持最小”，这种思路在许多问题中都有应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    贪心调整策略适用于：  
    - 资源分配问题（如分糖果，每次分配最小满足条件的量）。  
    - 时间安排问题（如调整任务时间，满足先后顺序且总时间最短）。  
    - 比例约束问题（如混合溶液浓度调整，保持最小总量）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1208 [USACO1.3] 混合牛奶**  
        * 🗣️ **推荐理由**：需要贪心选择单价最低的牛奶，调整购买量满足需求，与本题“每一步选最小”的思路类似。  
    2.  **洛谷 P1094 [NOIP2007 提高组] 纪念品分组**  
        * 🗣️ **推荐理由**：通过调整分组方式使总组数最少，需贪心选择配对策略，锻炼逐步优化思维。  
    3.  **洛谷 P1803 凌乱的yyy / 线段覆盖**  
        * 🗣️ **推荐理由**：贪心选择结束时间最早的比赛，调整时间安排，与本题“每一步选最优”的思路一致。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分，但可以总结以下经验：
</insights_intro>

> 在处理类似“逐步调整”的问题时，关键是明确每一步的最小调整目标，并通过数学公式（如向上取整）简化计算。此外，使用 `long long` 类型避免溢出是竞赛中的常见操作，需特别注意！

-----

<conclusion>
本次关于“AtCoDeerくんと選挙速報”的分析就到这里。通过贪心策略和逐步调整，我们可以高效解决这类比例约束下的最小总票数问题。希望大家通过练习和动画演示，能更熟练地掌握这类问题的解法！下次见～💪
</conclusion>

---
处理用时：136.53秒
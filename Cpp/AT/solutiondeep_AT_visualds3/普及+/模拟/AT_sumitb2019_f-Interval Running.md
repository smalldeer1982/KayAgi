# 题目信息

# Interval Running

## 题目描述

[problemUrl]: https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_f

高橋君と青木君は、西から東に向けて一直線に果てしなく続くランニングコースで長距離走の練習をしています。

彼らは同じ地点から同時にスタートし、**東に向かって**次のように移動します。

- 高橋君は最初の $ T_1 $ 分間、分速 $ A_1 $ メートルで走り、次の $ T_2 $ 分間、分速 $ A_2 $ メートルで走り、これを交互にいつまでも繰り返す。
- 青木君は最初の $ T_1 $ 分間、分速 $ B_1 $ メートルで走り、次の $ T_2 $ 分間、分速 $ B_2 $ メートルで走り、これを交互にいつまでも繰り返す。

さて、高橋君と青木君は何回出会う、すなわち、同じ位置に来るでしょうか？スタート地点にいる時は数えません。無限回出会う場合は、その旨を報告してください。

## 说明/提示

### 制約

- $ 1\ \leq\ T_i\ \leq\ 100000 $
- $ 1\ \leq\ A_i\ \leq\ 10^{10} $
- $ 1\ \leq\ B_i\ \leq\ 10^{10} $
- $ A_1\ \neq\ B_1 $
- $ A_2\ \neq\ B_2 $
- 入力中の値はすべて整数

### Sample Explanation 1

彼らはスタートしてから $ \frac{4}{3} $ 分後に $ 1 $ 回だけ、スタート地点から $ \frac{40}{3} $ メートルの位置で出会います。

### Sample Explanation 2

彼らはスタートしてから $ 101,\ 202,\ 303,\ 404,\ 505,\ 606,\ ... $ 分後に出会うので、無限回出会うことになります。

### Sample Explanation 3

入力中の値は $ 32 $ ビット整数型に収まらないことがあります。

## 样例 #1

### 输入

```
1 2

10 10

12 4```

### 输出

```
1```

## 样例 #2

### 输入

```
100 1

101 101

102 1```

### 输出

```
infinity```

## 样例 #3

### 输入

```
12000 15700

3390000000 3810000000

5550000000 2130000000```

### 输出

```
113```

# AI分析结果



---
# 💡 Kay的C++算法解析：Interval Running 深入学习指南 💡

<introduction>
今天我们来一起分析“Interval Running”这道题。这道题需要我们计算两位跑者在周期性变速跑步过程中相遇的次数。通过本指南，你将理解如何通过数学分析周期性运动的相对距离变化，掌握解题的核心逻辑和代码实现。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学分析与周期性运动模拟

🗣️ **初步分析**：
解决这道题的关键在于分析两位跑者（高桥和青木）在周期性变速过程中的相对距离变化。我们可以将问题抽象为“相对运动的周期性累积”问题——每完成一个周期（即高桥和青木各完成一次T₁和T₂的变速跑），他们的相对距离会变化一定量。通过分析这个变化量的规律，我们可以判断相遇次数是有限还是无限。

简单来说，这就像两个小朋友在操场上跑步，一个快一个慢，但速度会周期性变化。我们需要观察他们的“距离差”如何随时间变化：如果每轮变化后距离差的总和为0（即两人每轮刚好“扯平”），那么他们会无限次相遇；如果距离差越来越大（同方向累积），则永远不会相遇；如果距离差在缩小但最终停止，则相遇次数有限。

- **题解思路对比**：多个题解均围绕“计算每周期相对距离差（s₁和s₂）”展开，但对条件判断的表述略有不同。例如，ICE__LX的题解直接通过s₁+s₂是否为0判断无限次相遇，而ZH_qaq的题解通过x（T₁后的距离差）和y（T₂后的距离差）的符号和总和判断趋势。
- **核心算法流程**：首先计算每段的相对距离差s₁=(A₁-B₁)*T₁和s₂=(A₂-B₂)*T₂，然后根据s₁+s₂的符号及绝对值关系判断相遇次数。
- **可视化设计思路**：用像素动画展示两位跑者的位置变化：初始时两人在起点（像素点），每经过T₁分钟，高桥和青木分别移动s₁的相对距离（用不同颜色的方块表示）；再经过T₂分钟，移动s₂的相对距离。相遇时用闪烁的星星标记，音效“叮”提示。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：作者 ICE__LX**
* **点评**：此题解思路非常清晰，通过分类讨论s₁和s₂的关系直接得出结论。代码简洁规范（如使用`read()`和`write()`处理大整数输入输出），边界条件处理严谨（如判断s₁是否能被s₁+s₂整除）。特别是对“无限次相遇”和“有限次相遇”的条件判断，逻辑严密，是竞赛题解的典范。

**题解二：作者 ZH_qaq**
* **点评**：此题解用更简洁的变量命名（x、y表示每段距离差），代码结构清晰。虽然条件判断的表述与ICE__LX略有不同，但核心逻辑一致。对“相遇次数计算”的推导（`d1/df*2`加余数判断）直观易懂，适合初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们需要突破以下核心难点：
</difficulty_intro>

1.  **关键点1：如何定义“周期”内的相对距离差？**
    * **分析**：周期由T₁和T₂组成，每周期内高桥和青木的相对距离变化为s₁（T₁分钟的距离差）和s₂（T₂分钟的距离差）。例如，s₁=(A₁-B₁)*T₁表示T₁分钟后，高桥比青木多跑的距离（若为负则相反）。
    * 💡 **学习笔记**：周期内的相对距离差是分析相遇次数的基础，需明确每段时间的速度差与时间的乘积。

2.  **关键点2：如何判断“无限次相遇”的条件？**
    * **分析**：若每周期的总相对距离差s₁+s₂=0，说明两人每完成一个周期后，相对位置回到初始状态（即相遇）。由于周期无限重复，因此会无限次相遇。
    * 💡 **学习笔记**：s₁+s₂=0是无限次相遇的充要条件。

3.  **关键点3：如何计算有限次相遇的次数？**
    * **分析**：若s₁和s₂符号相反（如s₁>0，s₂<0），且总差s₁+s₂的绝对值小于s₁的绝对值，则每周期会缩小一定的距离差。相遇次数由初始距离差s₁和每周期缩小量（s₁+s₂）的比值决定，需考虑余数是否为0（余数为0时最后一次相遇不额外计数）。
    * 💡 **学习笔记**：有限次相遇次数=初始距离差//每周期缩小量×2（每周期两次相遇）+（余数≠0时+1）。

### ✨ 解题技巧总结
- **符号统一**：将相对距离差统一为正数处理（如取绝对值），简化条件判断。
- **边界处理**：特别注意s₁和s₂的符号是否相同（同号则距离差越来越大，无相遇）。
- **大整数处理**：输入数据可能超过32位整数范围，需用`long long`或`int long`类型。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，逻辑清晰且处理了大整数问题：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了ICE__LX和ZH_qaq的思路，通过计算s₁和s₂的符号及总和，判断相遇次数，代码简洁高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdlib>
    using namespace std;
    using ll = long long;

    int main() {
        ll t1, t2, a1, a2, b1, b2;
        cin >> t1 >> t2 >> a1 >> a2 >> b1 >> b2;
        
        ll s1 = (a1 - b1) * t1; // T1分钟后的相对距离差
        ll s2 = (a2 - b2) * t2; // T2分钟后的相对距离差

        if (s1 + s2 == 0) { // 每周期总差为0，无限次相遇
            cout << "infinity" << endl;
        } else if ((s1 > 0 && s2 > 0) || (s1 < 0 && s2 < 0)) { // 同号，距离差越来越大
            cout << "0" << endl;
        } else {
            ll total = abs(s1 + s2); // 每周期缩小的距离差绝对值
            ll initial = abs(s1);    // 初始距离差绝对值
            ll cnt = initial / total * 2; // 每周期两次相遇
            if (initial % total != 0) cnt++; // 余数不为0时多一次相遇
            cout << cnt << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先计算T₁和T₂后的相对距离差s₁和s₂。通过判断s₁+s₂是否为0确定无限次相遇；若s₁和s₂同号则无相遇；否则计算初始距离差与每周期缩小量的比值，得到相遇次数。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者 ICE__LX**
* **亮点**：代码规范，使用`read()`和`write()`处理大整数输入输出，条件判断覆盖所有情况。
* **核心代码片段**：
    ```cpp
    if(s1+s2==0) puts("infinity");
    else if((s1<0&&s2<0)||(s1>0&&s2>0)||abs(s1)>(s1<0?s2:-s2)) puts("0");
    else write(abs(s1)%abs(s1+s2)==0?abs(s1)/abs(s1+s2)*2:abs(s1)/abs(s1+s2)*2+1);
    ```
* **代码解读**：  
  第一行判断无限次相遇（s₁+s₂=0）；第二行判断同号或距离差无法缩小的情况（输出0）；第三行计算有限次相遇次数：若初始距离差能被每周期缩小量整除（余数为0），则次数为`abs(s1)/total*2`，否则加1。  
  例如，初始距离差为4，每周期缩小3，则4/3=1余1，次数为1×2+1=3次。
* 💡 **学习笔记**：条件判断需覆盖所有边界，余数的处理是关键。

**题解二：作者 ZH_qaq**
* **亮点**：变量命名简洁（x、y表示每段距离差），逻辑清晰。
* **核心代码片段**：
    ```cpp
    ll x = (a1 - b1) * t1; 
    ll y = (a2 - b2) * t2;
    if (x + y == 0) {
        cout << "infinity" << endl; 
        return 0;
    }
    if ((x > 0 && x + y > 0) || (x < 0 && x + y < 0)) {
        cout << "0" << endl; 
        return 0;
    }
    ll df = abs(x + y);
    ll d1 = abs(x);
    ll c = (d1 / df) * 2;
    if (d1 % df != 0) c++; 
    cout << c << endl;
    ```
* **代码解读**：  
  先计算x（T₁后的距离差）和y（T₂后的距离差）。若x+y=0则无限相遇；若x和x+y同号（距离差越来越大）则无相遇；否则计算df（每周期缩小量）和d1（初始距离差），次数为`(d1/df)*2`加余数判断。  
  例如，d1=4，df=3，则4/3=1，余数1≠0，次数为1×2+1=3次。
* 💡 **学习笔记**：通过绝对值统一处理正负，简化逻辑。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解相遇次数的计算过程，我们设计一个“像素跑者”动画，用8位像素风格模拟两人的跑步过程！
</visualization_intro>

  * **动画演示主题**：像素跑者的相遇挑战（FC红白机风格）

  * **核心演示内容**：展示高桥（红色方块）和青木（蓝色方块）在无限跑道（像素网格）上的移动，每T₁分钟切换一次速度，标记相遇点。

  * **设计思路简述**：8位像素风格让动画更亲切；用不同颜色区分跑者，闪烁的星星标记相遇点；音效“叮”强化关键事件记忆；单步控制让学习者看清每一步变化。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕下方显示像素跑道（横向网格线），起点（绿色圆点）在左。  
        - 控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（1x-5x）。  
        - 播放8位风格背景音乐（轻快的电子音效）。

    2.  **初始状态**：  
        - 高桥（红色方块）和青木（蓝色方块）在起点（x=0）。  
        - 顶部显示当前时间（0分钟）、相对距离差（0米）。

    3.  **T₁分钟运动**：  
        - 时间从0→T₁分钟，高桥和青木分别以A₁、B₁速度移动。  
        - 红色方块向右移动A₁*T₁像素，蓝色方块移动B₁*T₁像素。  
        - 顶部显示相对距离差s₁=(A₁-B₁)*T₁（正数为红在前，负数为蓝在前）。  
        - 若相遇（s₁=0），播放“叮”音效，星星闪烁标记。

    4.  **T₂分钟运动**：  
        - 时间从T₁→T₁+T₂分钟，速度切换为A₂、B₂。  
        - 红色方块继续移动A₂*T₂像素，蓝色方块移动B₂*T₂像素。  
        - 顶部显示总相对距离差s₁+s₂。  
        - 若相遇（s₁+s₂=0），播放“胜利”音效，显示“无限次相遇！”。

    5.  **循环与相遇计数**：  
        - 每完成一个周期（T₁+T₂分钟），重复步骤3-4。  
        - 有限次相遇时，每次相遇（红色和蓝色方块重叠）播放“叮”音效，计数加1。  
        - 最后一次相遇后，显示总次数，播放“结束”音效。

  * **旁白提示**：  
    - “现在高桥以A₁速度跑，青木以B₁速度跑，注意他们的距离变化！”  
    - “看，他们相遇了！这是第1次相遇！”  
    - “如果每轮结束后距离差为0，他们会一直相遇哦～”

<visualization_conclusion>
通过这个动画，你可以直观看到两人的位置变化和相遇时机，理解s₁、s₂和总距离差如何影响相遇次数！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下类似问题，巩固数学分析和周期性运动的解题思路：
</similar_problems_intro>

  * **通用思路迁移**：  
    本题的核心是分析周期性运动的相对距离变化，这种思路还适用于：  
    - 钟表指针重合次数（周期性旋转，计算角度差）。  
    - 环形跑道相遇问题（周期性绕圈，计算速度差）。  
    - 交替工作的机器完成任务时间（周期性效率变化，计算总工作量）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1886 滑动窗口最大值**  
        * 🗣️ **推荐理由**：考察滑动窗口的周期性变化，需分析窗口内元素的最值，锻炼周期性问题的数学分析能力。
    2.  **洛谷 P1036 选数**  
        * 🗣️ **推荐理由**：涉及组合数学的周期性枚举，需判断质数，巩固边界条件处理技巧。
    3.  **洛谷 P1060 开心的金明**  
        * 🗣️ **推荐理由**：动态规划的周期性应用，需计算物品价值的最优组合，提升问题分解能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本题解中，ICE__LX提到“处理大整数时需注意溢出，使用`long long`类型”，这是一个关键的经验：
</insights_intro>

> **参考经验 (来自 ICE__LX)**：“输入数据可能超过32位整数范围，必须用`long long`类型存储，否则会溢出导致错误。”
>
> **点评**：大整数溢出是竞赛中的常见错误。本题中，A_i和T_i可能很大（如1e10×1e5=1e15），超出`int`范围（约2e9）。使用`long long`能避免溢出，这是处理大数问题的基本技巧。

-----

<conclusion>
通过分析“Interval Running”，我们掌握了周期性运动的相对距离分析方法，学会了通过数学推导判断相遇次数。编程时注意大整数处理和边界条件，多通过动画模拟理解过程。下次我们再一起挑战更复杂的算法题！💪
</conclusion>

---
处理用时：126.41秒
# 题目信息

# [ABC035D] トレジャーハント

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc035/tasks/abc035_d

高橋君が住む国には $ N $ 箇所の町と町同士をつなぐ一方通行の道が $ M $ 本あり、それぞれの町には $ 1 $ から $ N $ の番号が割りふられています。 $ i $ 番目の道は $ a_i $ 番の町から $ b_i $ 番の町へ移動することが可能であり、移動に $ c_i $ 分だけかかります。

所持金が $ 0 $ 円の高橋君は $ T $ 分間のトレジャーハントに出かけることにしました。高橋君は開始 $ 0 $ 分の時点で $ 1 $ 番の町にいます。また、開始から $ T $ 分の時点にも $ 1 $ 番の町にいなくてはなりません。高橋君が $ i $ 番の町に $ 1 $ 分間滞在すると、 $ A_i $ 円が高橋君の所持金に加算されます。

$ T $ 分間のトレジャーハントによって高橋君の所持金は最大いくらになるか求めてください。

## 说明/提示

### 部分点

この問題には部分点が設定されている。

- $ 1≦N≦200 $ を満たすデータセットに正解した場合 $ 50 $ 点が与えられる。
- 追加制約のないデータセットに正解した場合は、追加で $ 50 $ 点が与えられ、合計 $ 100 $ 点が得られる。

### Sample Explanation 1

\- 開始から $ 0 $ 分の時点から $ 2 $ 分かけて町 $ 1 $ から町 $ 2 $ に移動します。 - 開始から $ 2 $ 分の時点から $ 2 $ 分間、町 $ 2 $ に滞在します。所持金は $ 6 $ 円になります。 - 開始から $ 4 $ 分の時点から $ 1 $ 分かけて町 $ 2 $ から町 $ 1 $ に移動します。 - 開始から $ 5 $ 分の時点で町 $ 1 $ にいます。トレジャーハントが終了します。 - このケースは部分点の制約を満たします。

### Sample Explanation 2

\- 開始 $ 0 $ 分の時点から $ 3 $ 分間、町 $ 1 $ に滞在するのが最適であり、所持金を $ 3 $ 円にすることができます。 - このケースは部分点の制約を満たします。

### Sample Explanation 3

\- このケースは部分点の制約を満たします。

## 样例 #1

### 输入

```
2 2 5

1 3

1 2 2

2 1 1```

### 输出

```
6```

## 样例 #2

### 输入

```
2 2 3

1 3

1 2 2

2 1 1```

### 输出

```
3```

## 样例 #3

### 输入

```
8 15 120

1 2 6 16 1 3 11 9

1 8 1

7 3 14

8 2 13

3 5 4

5 7 5

6 4 1

6 8 17

7 8 5

1 4 2

4 7 1

6 1 3

3 1 10

2 6 5

2 4 12

5 1 30```

### 输出

```
1488```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC035D] トレジャーハント 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最短路径算法（Dijkstra）的应用  

🗣️ **初步分析**：  
解决“トレジャーハント”（宝藏 hunt）问题，关键在于**用最短路径腾出最多时间赚钱**。想象一下，你是高桥君，要在T分钟内从1号 town出发再回来。每个 town停留1分钟能赚A_i元，所以**要选一个能往返的 town，让路上时间最短，这样停留时间最长，赚的钱最多**。  

- **核心思路**：枚举每个 town i，计算从1→i的最短时间（去程）和i→1的最短时间（返程），总路上时间是`dis[i] + disr[i]`。如果这个时间≤T，那么停留时间就是`T - dis[i] - disr[i]`，赚的钱是`A[i] × 停留时间`。取所有i中的最大值即可。  
- **核心难点**：如何高效计算“去程”和“返程”的最短路径？  
- **解决方案**：用两次Dijkstra算法——第一次计算1到所有点的最短路径（去程，`dis`数组）；第二次通过**反向图**计算所有点到1的最短路径（返程，`disr`数组）。  
- **可视化设计思路**：用像素风格展示 town（方块）和道路（箭头），Dijkstra算法执行时，用颜色渐变标记已访问的节点，优先队列的变化用“跳动”动画表示。当计算某个i的往返时间时，用“闪烁”提示该节点，同时显示停留时间和赚钱金额。  


## 2. 精选优质题解参考

**题解一：(来源：Erica_N_Contina)**  
* **点评**：这份题解的思路非常巧妙，抓住了“最短路径→最长停留时间”的核心逻辑。作者没有直接考虑环（因为环的情况太多），而是**枚举每个点作为停留点**，用两次Dijkstra计算往返时间，这样既覆盖了所有可能的环（比如1→i→1就是一个环），又简化了问题。代码风格规范，变量名（如`dis`表示去程最短时间，`disr`表示返程最短时间）清晰易懂。特别是**反向图的构建**（`add2`函数），用Dijkstra计算“从i到1”的最短路径，这个技巧非常实用。从实践角度看，代码处理了边界情况（比如`dis[i]`或`disr[i]`为INF时跳过该点），能正确应对样例2（一直在1号点的情况，此时`dis[1] + disr[1] = 0`，停留时间为T，赚`A[1]×T`）。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：为什么要用两次Dijkstra？**  
* **分析**：问题需要计算“1→i”和“i→1”的最短路径。直接计算“i→1”的最短路径，对于每个i都跑一次Dijkstra，时间复杂度会很高（O(N×M log N)）。而**反向图**的技巧可以将“i→1”的最短路径转化为“1→i”的最短路径（在反向图中），这样只需要跑一次Dijkstra就能得到所有i的返程时间，时间复杂度降到O(M log N)。  
* 💡 **学习笔记**：反向图是处理“多源到单源”最短路径的常用技巧，能大幅优化时间。  


### 2. **关键点2：为什么要枚举每个点作为停留点？**  
* **分析**：假设最优路径是“1→a→b→…→i→…→1”，那么高桥君在i点停留的时间最长（因为A_i是最大的）。如果我们枚举所有i，计算“1→i→1”的最短时间，那么最大的`A[i]×(T - 时间)`就是答案。这覆盖了所有可能的环情况，因为任何环都可以拆分为“1→i→1”的路径（i是环上的某个点）。  
* 💡 **学习笔记**：枚举可能的“关键点”（比如这里的停留点）是解决优化问题的常用思路。  


### 3. **关键点3：如何处理时间不够的情况？**  
* **分析**：如果`dis[i] + disr[i] > T`，说明高桥君无法在T分钟内往返i点，此时不能选这个点。代码中通过判断`dis[i]`和`disr[i]`是否为INF（表示无法到达），以及它们的和是否≤T，来跳过这些无效情况。  
* 💡 **学习笔记**：边界条件处理是编程的重要部分，要考虑“无法到达”“时间不够”等情况。  


### ✨ 解题技巧总结  
- **技巧A：反向图优化**：将“多源到单源”的最短路径转化为“单源到多源”，减少Dijkstra的次数。  
- **技巧B：枚举关键点**：通过枚举可能的最优解点（如停留点），简化问题。  
- **技巧C：边界条件处理**：用INF标记无法到达的节点，判断时间是否足够，避免无效计算。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：此代码来自题解一，是解决本题的典型实现，逻辑清晰，覆盖了所有核心步骤。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  #define int long long
  const int N=100005;
  const int INF=1e9;

  int a[N];
  int n,m,T;
  int vis[N];
  int dis[N],disr[N];
  struct node {
      int nxt, dis;
  };

  vector<node> e[N], r[N]; // e是原图，r是反向图

  priority_queue<pair<int,int>> pq; // 优先队列（最大堆，用负数实现最小堆）

  void add(int a,int b,int dis) {
      e[a].push_back((node){b, dis});
  }

  void add2(int a,int b,int dis) { // 构建反向图
      r[a].push_back((node){b, dis});
  }

  // Dijkstra算法，计算从rt出发到所有点的最短路径（存到dis数组）
  void dijkstra(int rt, vector<node> g[], int dist[]) {
      memset(vis, 0, sizeof(vis));
      fill(dist, dist + N, INF);
      dist[rt] = 0;
      pq.push(make_pair(0, rt));
      while(!pq.empty()) {
          int u = pq.top().second;
          pq.pop();
          if(vis[u]) continue;
          vis[u] = 1;
          for(auto &edge : g[u]) {
              int v = edge.nxt;
              int w = edge.dis;
              if(dist[v] > dist[u] + w) {
                  dist[v] = dist[u] + w;
                  pq.push(make_pair(-dist[v], v)); // 用负数实现最小堆
              }
          }
      }
  }

  signed main(){
      scanf("%lld%lld%lld",&n,&m,&T);
      for(int i=1;i<=n;i++) scanf("%d",&a[i]);
      for(int i=1;i<=m;i++){
          int u,v,w;
          scanf("%lld%lld%lld",&u,&v,&w);
          add(u,v,w);
          add2(v,u,w); // 构建反向图
      }
      dijkstra(1, e, dis); // 计算1→所有点的最短路径（去程）
      dijkstra(1, r, disr); // 计算所有点→1的最短路径（返程，用反向图）
      int ans=0;
      for(int i=1;i<=n;i++){
          if(dis[i]==INF || disr[i]==INF) continue;
          if(dis[i] + disr[i] > T) continue;
          ans=max(ans, a[i]*(T - dis[i] - disr[i]));
      }
      cout<<ans<<endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取n、m、T，以及每个town的A_i，还有每条道路的信息。  
  2. **构建图**：用`e`存储原图（正向边），用`r`存储反向图（反向边）。  
  3. **计算最短路径**：调用两次`dijkstra`函数，分别计算去程（`dis`数组）和返程（`disr`数组）的最短路径。  
  4. **枚举计算答案**：遍历每个town i，计算能赚的钱，取最大值。  


### 针对优质题解的片段赏析  
**题解一：(来源：Erica_N_Contina)**  
* **亮点**：反向图的构建与Dijkstra的复用。  
* **核心代码片段**：  
  ```cpp
  void dijkstra(int rt, vector<node> g[], int dist[]) {
      memset(vis, 0, sizeof(vis));
      fill(dist, dist + N, INF);
      dist[rt] = 0;
      pq.push(make_pair(0, rt));
      while(!pq.empty()) {
          int u = pq.top().second;
          pq.pop();
          if(vis[u]) continue;
          vis[u] = 1;
          for(auto &edge : g[u]) {
              int v = edge.nxt;
              int w = edge.dis;
              if(dist[v] > dist[u] + w) {
                  dist[v] = dist[u] + w;
                  pq.push(make_pair(-dist[v], v));
              }
          }
      }
  }
  ```  
* **代码解读**：  
  这段代码是Dijkstra算法的通用实现，通过参数`g`（图）和`dist`（存储最短路径的数组），可以复用计算原图和反向图的最短路径。比如，计算去程时，传入`e`（原图）和`dis`数组；计算返程时，传入`r`（反向图）和`disr`数组。优先队列用负数实现最小堆（因为C++的`priority_queue`默认是最大堆），这样每次取出的是当前最短路径的节点。  
* 💡 **学习笔记**：函数的复用可以减少代码冗余，提高可读性。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素探险家的宝藏之旅》（8位像素风）  
**设计思路**：用FC红白机的风格，将town表示为彩色方块（1号town是红色，其他是蓝色），道路表示为箭头（正向边是绿色，反向边是黄色）。通过动画展示Dijkstra算法的执行过程，以及枚举每个点的赚钱计算，增加“闯关”和“得分”元素，提高趣味性。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧是像素化的town地图（1号town在左上角，其他town分布在网格中）。  
   - 右侧是控制面板：“开始”“单步”“重置”按钮，速度滑块，以及“当前得分”显示。  
   - 背景音乐：8位风格的轻快旋律（如《超级马里奥》的背景音乐）。  

2. **Dijkstra算法执行（去程）**：  
   - 1号town（红色方块）开始闪烁，表示算法启动。  
   - 优先队列用“跳动的数字”表示，每次取出最短路径的节点（如u=1），用绿色箭头标记已访问的道路（1→v）。  
   - 每个节点的`dis`值显示在方块下方，当更新时，数字会“弹起”并变色（从灰色变为绿色）。  

3. **Dijkstra算法执行（返程）**：  
   - 反向图的道路变为黄色，算法从1号town出发，计算所有点到1的最短路径（`disr`数组）。  
   - 节点的`disr`值显示在方块上方，更新时同样有“弹起”动画。  

4. **枚举计算答案**：  
   - 每个town i依次闪烁（从1到n），显示“去程时间：dis[i]”“返程时间：disr[i]”“停留时间：T - dis[i] - disr[i]”“赚钱：a[i]×停留时间”。  
   - 当计算到最优解时（比如样例1中的i=2），屏幕会弹出“最高分！”的提示，伴随“叮”的音效。  

5. **游戏式关卡**：  
   - 将算法执行分为3个“小关”：① 构建图；② 计算去程；③ 计算返程。完成每个关卡会获得“星星”奖励（显示在屏幕右上角）。  
   - 当找到最优解时，播放“胜利”音效（如《魂斗罗》的通关音乐），并显示“闯关成功！”的动画。  


### 旁白提示  
- （Dijkstra启动时）“探险家从1号town出发，寻找最短路径到各个town！”  
- （更新`dis`值时）“哦，到v号town的路径变短了，现在是dis[v]分钟！”  
- （枚举i=2时）“如果在2号town停留，能赚6元，这是目前的最高分！”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
最短路径算法（Dijkstra）不仅能解决本题，还能用于：  
- **邮递员送信**：计算从邮局到各个地点的最短路径，再返回邮局（类似本题的往返问题）。  
- **导航系统**：计算从起点到终点的最短时间或最短距离。  
- **网络路由**：寻找网络中两个节点之间的最短路径（如IP路由）。  


### 练习推荐 (洛谷)  
1. **洛谷 P1629** - 《邮递员送信》  
   🗣️ **推荐理由**：这道题需要计算从邮局到各个地点的最短路径，再返回邮局，和本题的“往返”逻辑完全一致，能帮助你巩固反向图的技巧。  

2. **洛谷 P3371** - 《单源最短路径（弱化版）》  
   🗣️ **推荐理由**：这是Dijkstra算法的模板题，能帮助你熟悉算法的基本实现（优先队列、距离数组更新）。  

3. **洛谷 P4779** - 《单源最短路径（标准版）》  
   🗣️ **推荐理由**：这道题是Dijkstra算法的进阶版，需要处理更大的数据量（用堆优化），能提高你的代码效率意识。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自题解作者)**：“注意有一种情况是一直在点1不动！（样例2）”  
**点评**：作者的这句话提醒我们，**边界条件是编程中容易忽略的地方**。比如样例2中，高桥君不需要移动，直接在1号town停留T分钟，就能赚最多的钱。这时候`dis[1] + disr[1] = 0`，所以停留时间是T，赚`a[1]×T`。在代码中，枚举i=1时，会正确计算这个情况。  


## 总结  
本次分析的“トレジャーハント”问题，核心是**用最短路径腾出最多时间赚钱**。通过两次Dijkstra算法计算往返时间，枚举每个点作为停留点，我们能找到最优解。希望这份指南能帮助你理解最短路径算法的应用，以及如何用编程解决实际问题。记住，**多练习、多思考**是提高编程能力的关键！💪

---
处理用时：151.62秒
# 题目信息

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2```

## 样例 #2

### 输入

```
2
2 1
1 2```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC255F] Pre-order and In-order 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：递归（Recursion）与二叉树遍历构造


🗣️ **初步分析**：  
解决“根据前序和中序遍历构造二叉树”的问题，核心是**用递归拆分左右子树**。想象一下，二叉树就像一棵“分杈的树”——前序遍历（根→左→右）告诉我们“每棵子树的根是谁”，中序遍历（左→根→右）告诉我们“根的左右子树有哪些节点”。比如，前序的第一个元素一定是整棵树的根，而中序中根的左边是左子树，右边是右子树。我们需要不断用这个逻辑递归处理每个子树，直到所有节点都被正确放置。  

**核心思路**：  
1. 前序遍历的第一个元素是当前子树的根。  
2. 在中序遍历中找到根的位置，划分左子树（根左边的所有节点）和右子树（根右边的所有节点）。  
3. 计算左子树的大小，在前序中找到左子树的区间（根的下一个元素开始，长度为左子树大小）和右子树的区间（左子树区间结束后开始）。  
4. 递归处理左、右子树，重复上述步骤。  

**核心难点**：  
- 如何正确划分左右子树的区间（避免越界或错误）？  
- 如何快速找到根在中序中的位置（避免遍历导致超时）？  
- 如何处理无解情况（比如前序第一个不是1，或根不在中序的当前区间）？  

**可视化设计思路**：  
我们会用**8位像素风格**演示递归过程：  
- 屏幕左侧显示前序数组，右侧显示中序数组，根节点用**红色像素块**标记。  
- 划分左右子树时，用**蓝色边框**圈出左子树区间，**绿色边框**圈出右子树区间。  
- 递归处理子树时，屏幕下方显示当前处理的子树区间，并用**像素箭头**指向当前根节点。  
- 加入**音效**：找到根节点时播放“叮”的提示音，划分区间时播放“唰”的滑动音，构造完成时播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一（来源：program_xwl）  
* **点评**：这份题解的思路非常清晰，完美体现了“递归拆分左右子树”的核心逻辑。代码风格规范，变量名（如`tree`存子节点、`mp`存中序位置）含义明确，容易理解。其亮点在于**严格的无解判断**：不仅检查了前序第一个元素是否为1，还在递归中判断根是否在中序的当前区间，避免了无效递归。从实践角度看，代码处理了边界情况（如叶子节点的子节点设为0），非常严谨，适合作为入门参考。  

### 题解二（来源：Tsawke）  
* **点评**：此题解的代码结构简洁，用`pair`存储子节点，递归函数返回根节点，逻辑更紧凑。其亮点在于**参数设计**：`dfs`函数的参数直接对应前序和中序的区间，让递归过程更直观。此外，代码中用`posI`数组预处理中序位置，避免了重复查找，提高了效率。对于初学者来说，这种“直接映射”的方式很容易模仿。  

### 题解三（来源：ATION001）  
* **点评**：这份题解的代码非常简洁，去掉了冗余的变量，保留了核心逻辑。其亮点在于**递归函数的返回值**：`dfs`函数返回当前子树的根节点，让父节点可以直接赋值子节点，简化了代码。此外，代码中用`mp`数组预处理中序位置，同样避免了超时，适合追求代码简洁的学习者。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何正确划分左右子树的区间？**  
* **分析**：假设当前子树的前序区间是`[l1, r1]`，中序区间是`[l2, r2]`。前序的第一个元素`a[l1]`是根，在中序中的位置是`root`。左子树的大小是`root - l2`，因此左子树的前序区间是`[l1+1, l1 + (root - l2)]`，中序区间是`[l2, root-1]`；右子树的前序区间是`[l1 + (root - l2) + 1, r1]`，中序区间是`[root+1, r2]`。  
* 💡 **学习笔记**：区间划分的关键是“左子树大小”，它连接了前序和中序的区间。  

### 2. **关键点2：如何快速找到根在中序中的位置？**  
* **分析**：如果每次都遍历中序数组找根，时间复杂度会是`O(N^2)`，对于`N=2e5`的情况会超时。因此，我们需要用**哈希表**（或数组）预处理中序数组，将每个元素的位置存起来，这样查找根的位置只需`O(1)`时间。  
* 💡 **学习笔记**：预处理是解决大数据问题的常用技巧，能大幅提高效率。  

### 3. **关键点3：如何处理无解情况？**  
* **分析**：无解的情况有两种：① 前序第一个元素不是1（题目要求根为1）；② 递归中发现根不在中序的当前区间（说明遍历序列不匹配）。遇到这两种情况，直接输出`-1`并终止程序。  
* 💡 **学习笔记**：特判是避免无效计算的重要步骤，能快速处理边界情况。  


### ✨ 解题技巧总结  
- **预处理**：用数组存储中序元素的位置，避免重复查找。  
- **递归边界**：当区间长度为0时停止递归（叶子节点）。  
- **无解判断**：提前检查前序第一个元素，递归中检查根的位置。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了program_xwl、Tsawke等题解的思路，保留了核心逻辑，结构清晰，适合入门学习。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  struct Node { int l, r; } tree[200005]; // 存储每个节点的左右子节点
  int n, pre[200005], in[200005], mp[200005]; // pre:前序，in:中序，mp:中序元素的位置

  void dfs(int l1, int r1, int l2, int r2) {
      if (l1 > r1) return; // 区间无效，返回
      int root = pre[l1]; // 当前子树的根（前序第一个元素）
      int root_pos = mp[root]; // 根在中序中的位置
      if (root_pos < l2 || root_pos > r2) { // 根不在中序的当前区间，无解
          cout << -1;
          exit(0);
      }
      int left_size = root_pos - l2; // 左子树大小
      // 左子树：前序[l1+1, l1+left_size]，中序[l2, root_pos-1]
      if (left_size > 0) {
          tree[root].l = pre[l1+1];
          dfs(l1+1, l1+left_size, l2, root_pos-1);
      } else {
          tree[root].l = 0; // 左子树为空
      }
      // 右子树：前序[l1+left_size+1, r1]，中序[root_pos+1, r2]
      int right_size = r2 - root_pos; // 右子树大小
      if (right_size > 0) {
          tree[root].r = pre[l1+left_size+1];
          dfs(l1+left_size+1, r1, root_pos+1, r2);
      } else {
          tree[root].r = 0; // 右子树为空
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cin >> n;
      for (int i = 1; i <= n; ++i) cin >> pre[i];
      for (int i = 1; i <= n; ++i) {
          cin >> in[i];
          mp[in[i]] = i; // 预处理中序元素的位置
      }
      if (pre[1] != 1) { // 前序第一个元素不是1，无解
          cout << -1;
          return 0;
      }
      dfs(1, n, 1, n);
      for (int i = 1; i <= n; ++i) {
          cout << tree[i].l << ' ' << tree[i].r << '\n';
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. 读取输入：前序数组`pre`和中序数组`in`。  
  2. 预处理`mp`数组：存储中序每个元素的位置。  
  3. 特判：前序第一个元素是否为1，否则输出`-1`。  
  4. 递归`dfs`函数：处理每个子树的区间，划分左右子树，更新`tree`数组。  
  5. 输出`tree`数组：每个节点的左右子节点。  


### 针对各优质题解的片段赏析  

#### 题解一（来源：program_xwl）  
* **亮点**：严格的边界处理（如叶子节点的子节点设为0）。  
* **核心代码片段**：  
  ```cpp
  void dfs(int l1, int r1, int l2, int r2) {
      if (l1 >= r1) return; // 叶子节点
      int root = mp[a[l1]], sizl = root - l2, sizr = r2 - root;
      if (root < l2 || root > r2) { cout << -1; exit(0); }
      tree[a[l1]] = {a[l1+1], a[l1+sizl+1]};
      if (sizl == 0) tree[a[l1]].l = 0;
      if (sizr == 0) tree[a[l1]].r = 0;
      dfs(l1+1, l1+sizl, l2, root-1);
      dfs(l1+sizl+1, r1, root+1, r2);
  }
  ```  
* **代码解读**：  
  - `l1 >= r1`：处理叶子节点，直接返回。  
  - `sizl`和`sizr`：计算左右子树大小。  
  - `tree[a[l1]] = {a[l1+1], a[l1+sizl+1]}`：直接赋值左右子节点（前序中左子树的第一个元素是左子节点，右子树的第一个元素是右子节点）。  
  - `sizl == 0`：左子树为空，设为0。  
* 💡 **学习笔记**：直接赋值子节点的方式很直观，适合理解递归过程。  


#### 题解二（来源：Tsawke）  
* **亮点**：用`pair`存储子节点，递归函数返回根节点。  
* **核心代码片段**：  
  ```cpp
  pair<int, int> son[210000];
  int dfs(int lp, int rp, int li, int ri) {
      if (lp > rp) return 0;
      int rt = Pre[lp];
      if (posI[rt] < li || posI[rt] > ri) { puts("-1"); exit(0); }
      int lsiz = posI[rt] - li;
      son[rt].first = dfs(lp+1, lp+lsiz, li, posI[rt]-1);
      son[rt].second = dfs(lp+lsiz+1, rp, posI[rt]+1, ri);
      return rt;
  }
  ```  
* **代码解读**：  
  - `pair<int, int> son[210000]`：存储每个节点的左右子节点（first是左，second是右）。  
  - `dfs`函数返回根节点：父节点可以直接用返回值赋值子节点。  
  - `lsiz = posI[rt] - li`：计算左子树大小，用于划分前序区间。  
* 💡 **学习笔记**：`pair`存储子节点的方式很简洁，适合代码优化。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**《像素树建造师》**：模拟递归构造二叉树的过程，用8位像素风格展示前序和中序数组，以及二叉树的生长过程。  


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示前序数组（用**灰色像素块**表示，每个元素下方标注值），右侧显示中序数组（同样用灰色像素块）。  
   - 屏幕下方显示一棵空的二叉树（用**棕色像素块**表示根节点1，初始时没有子节点）。  
   - 控制面板包含：开始/暂停按钮（**红色像素块**）、单步执行按钮（**蓝色像素块**）、重置按钮（**绿色像素块**）、速度滑块（**灰色长条**）。  

2. **算法启动**：  
   - 前序数组的第一个元素（1）用**红色像素块**标记（根节点）。  
   - 中序数组中找到1的位置，用**红色像素块**标记，并用**蓝色边框**圈出左子树区间（1左边的元素），**绿色边框**圈出右子树区间（1右边的元素）。  
   - 播放“叮”的提示音。  

3. **递归处理左子树**：  
   - 前序数组中左子树的第一个元素（比如样例1中的3）用**红色像素块**标记（左子树的根）。  
   - 中序数组中找到3的位置，用**红色像素块**标记，圈出其左右子树区间。  
   - 二叉树中根节点1的左子节点显示为3（**绿色像素块**），播放“唰”的滑动音。  

4. **递归处理右子树**：  
   - 前序数组中右子树的第一个元素（比如样例1中的2）用**红色像素块**标记（右子树的根）。  
   - 中序数组中找到2的位置，用**红色像素块**标记，圈出其左右子树区间。  
   - 二叉树中根节点1的右子节点显示为2（**蓝色像素块**），播放“唰”的滑动音。  

5. **目标达成**：  
   - 所有节点都被正确放置，二叉树完整显示。  
   - 播放“胜利”音效（8位风格的上扬音调），屏幕下方显示“构造成功！”的像素文字。  


### 交互与控制  
- **单步执行**：点击蓝色按钮，逐步执行递归步骤，观察每一步的变化。  
- **自动播放**：点击红色按钮，算法自动执行，速度可通过滑块调节（从慢到快）。  
- **重置**：点击绿色按钮，恢复初始状态，重新开始演示。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
“递归拆分左右子树”的思路不仅能解决本题，还能解决以下问题：  
- **求后序遍历**：给定前序和中序，求后序（如洛谷P1030）。  
- **求二叉树的深度**：递归计算左右子树的深度，取最大值加1。  
- **求二叉树的节点数**：递归计算左右子树的节点数，相加加1。  


### 练习推荐 (洛谷)  
1. **洛谷 P1030** - [NOIP2001 普及组] 求先序排列  
   * 🗣️ **推荐理由**：本题是“根据中序和后序求先序”，思路与本题类似，能巩固递归拆分的技巧。  
2. **洛谷 P1028** - [NOIP2001 普及组] 二叉树的遍历  
   * 🗣️ **推荐理由**：本题要求根据前序遍历构建二叉树，然后输出后序遍历，能锻炼二叉树的构建和遍历能力。  
3. **洛谷 P1827** - [USACO4.2] 美国血统（American Heritage）  
   * 🗣️ **推荐理由**：本题是“根据中序和后序求前序”，难度稍高，能挑战更复杂的递归逻辑。  
4. **洛谷 P2014** - [NOIP2009 普及组] 选课  
   * 🗣️ **推荐理由**：本题虽然是动态规划问题，但需要用递归构建树结构，能综合运用递归和动态规划技巧。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自 program_xwl)**：“我在解决这个问题时，最初没有预处理中序位置，导致超时。后来用数组存储中序位置，才通过了所有测试点。”  
**点评**：预处理是解决大数据问题的关键！如果每次都遍历中序数组找根，时间复杂度会很高，无法通过大测试点。用数组存储中序位置，能将查找时间从`O(N)`降到`O(1)`，大幅提高效率。  


## 结语  
本次关于“[ABC255F] Pre-order and In-order”的分析就到这里。希望这份指南能帮助你理解递归构造二叉树的核心逻辑，掌握预处理、区间划分等技巧。记住，递归的关键是“拆分问题”——把大问题拆成小问题，逐个解决，最后合并结果。下次我们再一起探索新的编程挑战！💪

---
处理用时：179.03秒
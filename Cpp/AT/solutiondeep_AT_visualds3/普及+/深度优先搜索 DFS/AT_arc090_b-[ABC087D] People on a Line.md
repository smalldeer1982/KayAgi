# 题目信息

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5```

### 输出

```
No```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100```

### 输出

```
No```

## 样例 #5

### 输入

```
100 0```

### 输出

```
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC087D] People on a Line 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：带权并查集（Union-Find with Weights）

🗣️ **初步分析**：  
解决“People on a Line”的关键，是判断**人与人之间的距离关系是否一致**。比如，若已知“1号在2号左边1米”（$x_2 - x_1 = 1$），“2号在3号左边1米”（$x_3 - x_2 = 1$），那么“1号在3号左边2米”（$x_3 - x_1 = 2$）必须成立，否则信息矛盾。  

这里可以用**带权并查集**来解决——它像一棵“家族树”，每个节点记录自己到“祖先”（根节点）的距离。当合并两个家族时，我们会调整距离，确保所有关系一致；当查询两个节点的关系时，通过路径压缩快速得到它们到根的距离，从而判断是否矛盾。  

**核心难点**：  
- 路径压缩时，如何正确更新节点到根的距离？  
- 合并两个集合时，如何计算两个根之间的距离，保证关系成立？  

**可视化设计思路**：  
用8位像素风格展示“家族树”：  
- 每个节点是一个彩色像素块（比如蓝色），根节点用红色标记。  
- 节点下方显示到根的距离（如`dis[2] = 1`表示2号到根的距离是1）。  
- 路径压缩时，节点的父节点箭头从“父节点”直接指向“根”，同时距离数值更新（伴随“叮”的像素音效）。  
- 合并时，两个根节点的箭头连接，距离数值调整（伴随“咚”的音效）；若发现矛盾，节点闪烁红色并播放“错误”音效。  


## 2. 精选优质题解参考

### 题解一：带权并查集（作者：Doraven，赞：6）  
* **点评**：  
  这份题解是本题的“最优解”，思路清晰、代码简洁，完美贴合题目需求。它用带权并查集高效处理了1e5规模的数据，时间复杂度几乎线性（$O(\alpha(n))$，$\alpha$是阿克曼函数的反函数，增长极慢）。  
  - **思路亮点**：通过`fa`数组记录父节点，`dis`数组记录节点到父节点的距离。路径压缩时，递归更新`dis`数组，确保每个节点直接指向根并正确记录到根的距离。  
  - **代码亮点**：`find`函数的路径压缩逻辑（`dis[x] += dis[nf]`）和合并时的距离计算（`dis[rl] = d + dis[r] - dis[l]`）是核心，完美解决了关系一致性问题。  
  - **实践价值**：代码可直接用于竞赛，边界处理（如`l != r`）和矛盾判断（`dis[l] - dis[r] != d`）非常严谨。


### 题解二：DFS判负环（作者：CreeperLordVader，赞：4）  
* **点评**：  
  这份题解用差分约束系统的思路，将问题转化为“判断图中是否存在负环”（若存在，则关系矛盾）。DFS方法直观，但对于大数据（如1e5节点）可能超时（最坏情况$O(nm)$）。  
  - **思路亮点**：通过`d`数组记录节点的“最短距离”，若在DFS中发现可以更新已访问节点的距离，则存在负环（矛盾）。  
  - **代码亮点**：`vis`数组标记当前DFS路径中的节点，`use`数组标记已处理的连通块，避免重复计算。  
  - **局限性**：对于大规模数据，DFS可能栈溢出或超时，不如带权并查集高效。


### 题解三：SPFA判差分约束（作者：Wen_kr，赞：4）  
* **点评**：  
  这份题解用SPFA算法处理差分约束系统，通过队列优化判断是否存在可行解。SPFA是差分约束的经典解法，但同样可能在最坏情况下超时。  
  - **思路亮点**：将每个关系$x_r - x_l = d$转化为两个不等式（$x_r \leq x_l + d$和$x_l \leq x_r - d$），建图后跑SPFA判断是否存在负环。  
  - **代码亮点**：`dist`数组记录节点的最短距离，若发现`dist[v] != dist[u] + w`则返回矛盾。  
  - **局限性**：SPFA的时间复杂度不稳定，对于1e5规模的数据，可能无法通过。


## 3. 核心难点辨析与解题策略

### 1. 关键点1：带权并查集的路径压缩与距离更新  
* **分析**：  
  带权并查集的`find`函数不仅要找到根节点，还要更新节点到根的距离。例如，当`fa[x] = y`，`fa[y] = root`时，`dis[x]`是x到y的距离，`dis[y]`是y到root的距离。路径压缩后，`fa[x] = root`，`dis[x]`应更新为`dis[x] + dis[y]`（x到root的总距离）。  
  优质题解中的`find`函数（`dis[x] += dis[nf]`）完美解决了这个问题。  
* 💡 **学习笔记**：路径压缩时，一定要同步更新距离，否则会导致后续判断错误。


### 2. 关键点2：合并两个集合时的距离计算  
* **分析**：  
  当合并`l`和`r`时（已知$x_r - x_l = d$），假设`rl`是`l`的根，`rr`是`r`的根。若`rl != rr`，需要将`fa[rl] = rr`，并计算`dis[rl]`（rl到rr的距离）。根据关系$x_r - x_l = d$，可以推导：  
  $x_r = x_l + d$  
  而$x_l = dis[l]$（l到rl的距离） + $x_{rl}$（rl的坐标）  
  $x_r = dis[r]$（r到rr的距离） + $x_{rr}$（rr的坐标）  
  代入得：$dis[r] + x_{rr} = dis[l] + x_{rl} + d$  
  因为合并后$x_{rl} = x_{rr} + dis[rl]$（rl到rr的距离），代入得：  
  $dis[r] + x_{rr} = dis[l] + (x_{rr} + dis[rl]) + d$  
  化简得：$dis[rl] = d + dis[r] - dis[l]$  
  这就是合并时`dis[rl]`的计算方式。  
* 💡 **学习笔记**：合并时的距离计算是带权并查集的核心，必须理解推导过程。


### 3. 关键点3：矛盾判断  
* **分析**：  
  当`l`和`r`的根相同（`rl == rr`）时，需要判断`dis[l] - dis[r]`是否等于`d`（因为$x_l = dis[l] + x_{rl}$，$x_r = dis[r] + x_{rr}$，而$x_{rl} = x_{rr}$，所以$x_r - x_l = dis[r] - dis[l]$，应等于`d`）。若不等，则矛盾。  
* 💡 **学习笔记**：矛盾判断是最后一步，也是最容易忽略的细节，必须确保条件正确。


### ✨ 解题技巧总结  
- **技巧A：选择合适的数据结构**：带权并查集是处理“关系一致性”问题的神器，比DFS/SPFA更高效。  
- **技巧B：推导数学关系**：合并时的距离计算需要通过数学推导得出，不能凭感觉写。  
- **技巧C：边界条件处理**：必须判断`l != r`（题目保证），但合并时仍需注意根节点是否相同。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（带权并查集）  
* **说明**：本代码来自Doraven的题解，是带权并查集的经典实现，逻辑清晰、高效。  
* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  using namespace std;

  const int MAXN = 100005;
  int fa[MAXN];
  long long dis[MAXN]; // 注意：距离可能很大，用long long
  bool ok = true;

  int find(int x) {
      if (fa[x] != x) {
          int nf = fa[x];
          fa[x] = find(fa[x]); // 递归找根，路径压缩
          dis[x] += dis[nf]; // 更新x到根的距离
      }
      return fa[x];
  }

  int main() {
      int n, m;
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= n; ++i) {
          fa[i] = i;
          dis[i] = 0;
      }
      for (int i = 0; i < m; ++i) {
          int l, r, d;
          scanf("%d%d%d", &l, &r, &d);
          int rl = find(l);
          int rr = find(r);
          if (rl == rr) {
              // 检查矛盾
              if (dis[l] - dis[r] != d) {
                  ok = false;
              }
          } else {
              // 合并两个集合
              fa[rl] = rr;
              dis[rl] = d + dis[r] - dis[l];
          }
      }
      printf("%s\n", ok ? "Yes" : "No");
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **初始化**：`fa`数组初始化为每个节点的父节点是自己，`dis`数组初始化为0（每个节点到自己的距离是0）。  
  2. **处理每个关系**：对于每个`(l, r, d)`，找到`l`和`r`的根节点。  
     - 若根相同，检查`dis[l] - dis[r]`是否等于`d`（矛盾判断）。  
     - 若根不同，合并两个集合，并计算`dis[rl]`（保证关系成立）。  
  3. **输出结果**：若所有关系都一致，输出`Yes`，否则输出`No`。


### 题解一：带权并查集（作者：Doraven）  
* **亮点**：路径压缩与距离更新的完美结合，代码简洁高效。  
* **核心代码片段**：  
  ```cpp
  int find(int x) {
      if (fa[x] != x) {
          int nf = fa[x];
          fa[x] = find(fa[x]);
          dis[x] += dis[nf];
      }
      return fa[x];
  }
  ```
* **代码解读**：  
  - 递归找根：`find(fa[x])`会找到`x`的父节点的根，并压缩路径。  
  - 更新距离：`dis[x] += dis[nf]`表示`x`到原来的父节点`nf`的距离，加上`nf`到根的距离，得到`x`到根的总距离。  
* 💡 **学习笔记**：递归路径压缩是带权并查集的关键，必须掌握。


### 题解二：DFS判负环（作者：CreeperLordVader）  
* **亮点**：用DFS处理差分约束，直观易懂。  
* **核心代码片段**：  
  ```cpp
  bool dfs(int fa) {
      vis[fa] = 1;
      use[fa] = 1;
      for (int i = 0; i < v[fa].size(); ++i) {
          int y = v[fa][i];
          int z = e[fa][i];
          if (d[y] > d[fa] + z) {
              if (vis[y]) return true; // 存在负环
              d[y] = d[fa] + z;
              if (dfs(y)) return true;
          }
      }
      vis[fa] = 0;
      return false;
  }
  ```
* **代码解读**：  
  - `vis`数组标记当前DFS路径中的节点，避免循环。  
  - 若发现`d[y] > d[fa] + z`（可以更新距离），则递归处理`y`；若`y`已在当前路径中（`vis[y] = 1`），则存在负环（矛盾）。  
* 💡 **学习笔记**：DFS判负环的关键是标记当前路径中的节点，避免遗漏。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：带权并查集的“家族合并”游戏  
**设计思路**：  
用8位像素风格（类似FC游戏）展示带权并查集的操作，让学习者直观看到“家族树”的变化。通过音效和动画增强记忆，比如路径压缩时的“叮”声、合并时的“咚”声、矛盾时的“错误”音效。


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示“家族树”（每个节点是蓝色像素块，根节点是红色），右侧显示“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。  
   - 背景播放8位风格的轻松BGM（如《超级马里奥》的背景音乐）。  

2. **节点初始化**：  
   - 每个节点显示为“[编号] (dis: 0)”（如“1 (dis: 0)”），父节点箭头指向自己。  

3. **路径压缩演示**：  
   - 当执行`find(3)`时，节点3的父节点是2，节点2的父节点是1（根）。  
   - 动画显示节点3的箭头从2指向1，同时`dis[3]`从“dis: 2”（假设3到2的距离是1，2到1的距离是1）更新为“dis: 2”（1+1）。  
   - 伴随“叮”的像素音效。  

4. **合并演示**：  
   - 处理关系`(1, 3, 2)`时，节点1的根是1，节点3的根是3。  
   - 动画显示节点1的箭头指向3，同时`dis[1]`更新为“dis: 2”（根据公式`dis[rl] = d + dis[r] - dis[l]`，这里`rl=1`，`rr=3`，`d=2`，`dis[r]=0`，`dis[l]=0`，所以`dis[1] = 2+0-0=2`）。  
   - 伴随“咚”的音效。  

5. **矛盾判断演示**：  
   - 若处理关系`(1, 3, 5)`时，节点1和3的根相同（都是3），检查`dis[1] - dis[3]`是否等于5（`dis[1] = 2`，`dis[3] = 0`，差为2≠5）。  
   - 节点1和3闪烁红色，伴随“错误”音效（如《魂斗罗》的死亡音效），屏幕显示“矛盾！”。  

6. **交互控制**：  
   - 学习者可以通过“单步”按钮逐步观看每个操作，“自动播放”按钮调整速度（如1x、2x、4x），“重置”按钮回到初始状态。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
带权并查集不仅能解决本题，还能处理以下问题：  
- **银河英雄传说（P1196）**：维护每个节点到根的距离和所在集合的大小，查询两个节点的位置关系。  
- **食物链（P2024）**：维护每个节点的种类（相对于根的关系），判断两个节点是否属于同一类或捕食关系。  
- **区间关系判断**：比如判断“区间[a,b]的和为s”是否一致。  


### 练习推荐 (洛谷)  
1. **洛谷 P1196** - 银河英雄传说  
   * 🗣️ **推荐理由**：带权并查集的经典应用题，需要维护距离和大小，巩固路径压缩和合并逻辑。  
2. **洛谷 P2024** - 食物链  
   * 🗣️ **推荐理由**：带权并查集的变种，维护节点的种类关系，锻炼逻辑推导能力。  
3. **洛谷 P3367** - 并查集模板  
   * 🗣️ **推荐理由**：普通并查集的模板题，熟悉并查集的基本操作，为学习带权并查集打基础。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自 Error_666)**：  
“我一开始想用差分约束，但觉得纯DFS可行，于是敲了一发上去就A掉了。纯DFS的思路很简单，就是建图后扩展，若发现一个点有两个不同的坐标就输出No。”  
* **点评**：这位作者的经验提醒我们，**不要局限于固定思路**，有时候简单的DFS也能解决问题（虽然效率可能不高）。但对于大规模数据，还是要选择更高效的算法（如带权并查集）。  


## 结语  
本次关于“[ABC087D] People on a Line”的分析就到这里。带权并查集是处理“关系一致性”问题的强大工具，希望大家通过练习掌握它的核心逻辑。记住，**算法的选择取决于问题的规模和需求**，选择合适的算法能让你的代码更高效、更简洁。下次我们再一起探索新的编程挑战！💪

---
处理用时：191.01秒
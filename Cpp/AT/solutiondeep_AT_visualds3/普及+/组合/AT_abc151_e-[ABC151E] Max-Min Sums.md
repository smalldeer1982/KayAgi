# 题目信息

# [ABC151E] Max-Min Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc151/tasks/abc151_e

有限個の整数からなる集合 $ X $ に対し $ f(X)=\max\ X\ -\ \min\ X $ と定義します。

$ N $ 個の整数 $ A_1,...,A_N $ が与えられます。

このうち $ K $ 個を選び、それらからなる集合を $ S $ とします。同じ値であっても添字が異なる要素を区別すると、そのような選び方は $ {}_N\ C_K $ 通りありますが、その全てについての $ f(S) $ の合計を求めてください。

答えは非常に大きくなる可能性があるので、$ \bmod\ 10^9+7 $ で出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ |A_i|\ \leq\ 10^9 $

### Sample Explanation 1

$ S $ の選び方は $ \{1,1\},\{1,3\},\{1,4\},\{1,3\},\{1,4\},\{3,4\} $ の $ 6 $ 通りあり (ふたつの $ 1 $ は区別します)、$ f(S) $ はそれぞれ $ 0,2,3,2,3,1 $ となるので、合計は $ 11 $ です。

### Sample Explanation 2

$ S $ の選び方は $ 20 $ 通りあり、そのうち $ 18 $ 通りで $ f(S)=20 $、$ 2 $ 通りで $ f(S)=0 $ となります。

### Sample Explanation 4

合計は $ \bmod\ 10^9+7 $ で出力してください。

## 样例 #1

### 输入

```
4 2

1 1 3 4```

### 输出

```
11```

## 样例 #2

### 输入

```
6 3

10 10 10 -10 -10 -10```

### 输出

```
360```

## 样例 #3

### 输入

```
3 1

1 1 1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 6

1000000000 1000000000 1000000000 1000000000 1000000000 0 0 0 0 0```

### 输出

```
999998537```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC151E] Max-Min Sums 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：组合数学（贡献拆分+逆元计算组合数）  

🗣️ **初步分析**：  
题目要求计算所有大小为$K$的子集的`max-min`之和。直接枚举所有子集显然会超时（$N$可达$10^5$），因此需要**拆分贡献**——将总和拆分为“所有子集的最大值之和”减去“所有子集的最小值之和”（线性性质：$\sum (a-b) = \sum a - \sum b$）。  

可以用一个简单的比喻理解：假设你要计算班级里所有$3$人小组的“最高身高-最矮身高”总和，不需要逐个小组计算，只需先算所有小组的最高身高之和，再算所有小组的最矮身高之和，最后相减即可。  

**核心思路**：  
1. **排序**：将数组升序排序（排序后，元素的大小关系更明确，方便计算贡献）。  
2. **计算最大值贡献**：对于排序后的第$i$个元素（$a[i]$），它能作为多少个$K$元子集的最大值？答案是从它前面的$i-1$个元素中选$K-1$个（因为前面的元素都比它小），即组合数$C(i-1, K-1)$。因此，$a[i]$对最大值之和的贡献是$a[i] \times C(i-1, K-1)$。  
3. **计算最小值贡献**：同理，$a[i]$能作为多少个$K$元子集的最小值？答案是从它后面的$n-i$个元素中选$K-1$个（后面的元素都比它大），即$C(n-i, K-1)$。因此，$a[i]$对最小值之和的贡献是$a[i] \times C(n-i, K-1)$。  
4. **总和**：最大值之和减去最小值之和，即为答案。  

**可视化设计思路**：  
用8位像素风展示数组排序后的状态，每个元素用不同颜色的方块表示。计算最大值贡献时，当前元素（如第$i$个）会“发光”，前面的$i-1$个元素中选$K-1$个的区域会闪烁，同时显示组合数$C(i-1, K-1)$；计算最小值贡献时同理，后面的$n-i$个元素闪烁。每完成一个元素的计算，播放“叮”的音效，增强记忆。


## 2. 精选优质题解参考

为大家筛选了3份思路清晰、代码规范的优质题解，评分均≥4星：  

### **题解一（作者：TonyYin，赞：8）**  
* **点评**：  
  这份题解是本题的“标准解法模板”，思路**直白易懂**——明确拆分最大值和最小值的贡献，并用排序+组合数计算。代码**规范严谨**：变量名（如`fac`表示阶乘、`inv`表示逆元）含义明确，注释详细（如“算一遍最大值”“算一遍最小值”），非常适合初学者理解。  
  亮点：**逆元计算组合数**的实现非常标准（用快速幂求逆元），处理了取模的边界情况（如`(ans % mod + mod) % mod`避免负数），可直接用于竞赛。  

### **题解二（作者：_determination_，赞：3）**  
* **点评**：  
  代码**简洁高效**，用`ios::sync_with_stdio(false)`加速输入输出，组合数计算逻辑与题解一一致，但代码行数更少。亮点：将最大值和最小值的贡献分别用`ans1`和`ans2`存储，最后相减，逻辑更清晰。  

### **题解三（作者：WaterSun，赞：2）**  
* **点评**：  
  用宏定义（如`Add`、`Sub`、`Mul`）简化了取模操作，代码可读性强。亮点：**预处理阶乘和逆元**的方式更高效（从后往前计算逆元），适合处理大数量级的组合数问题。  


## 3. 核心难点辨析与解题策略

在解决本题时，初学者常遇到以下3个难点，结合优质题解的共性，给出解决策略：  

### 1. **难点1：如何想到拆分贡献？**  
* **分析**：直接计算`max-min`的总和很难，但`max`和`min`的总和可以分开计算（线性性质）。这是组合数学中的常见技巧——将复杂的总和拆分为多个简单总和的组合。  
* 💡 **学习笔记**：遇到“总和=A-B”的问题，先考虑拆分A和B的贡献，可能会简化问题。  

### 2. **难点2：如何计算组合数$C(n,k)$模$10^9+7$？**  
* **分析**：$N$可达$10^5$，需要预处理阶乘和逆元，用公式$C(n,k) = fac[n] \times inv[fac[k]] \times inv[fac[n-k]] \% mod$（其中`fac`是阶乘数组，`inv`是逆元数组）。  
* **解决策略**：  
  - 预处理阶乘：`fac[0] = 1`，`fac[i] = fac[i-1] * i % mod`。  
  - 预处理逆元：用快速幂求`inv[fac[n]]`，再从后往前计算`inv[fac[i-1]] = inv[fac[i]] * i % mod`。  
* 💡 **学习笔记**：组合数取模问题，预处理阶乘和逆元是“万能解法”，记住这个模板！  

### 3. **难点3：排序后如何确定元素的贡献次数？**  
* **分析**：排序后，元素的大小关系固定，因此：  
  - 第$i$个元素作为最大值的次数：前面有$i-1$个元素，选$K-1$个，即$C(i-1, K-1)$（$i \geq K$，否则前面不够选$K-1$个）。  
  - 第$i$个元素作为最小值的次数：后面有$n-i$个元素，选$K-1$个，即$C(n-i, K-1)$（$i \leq n-K+1$，否则后面不够选$K-1$个）。  
* 💡 **学习笔记**：排序是组合数学问题的“常用预处理步骤”，能将无序的问题转化为有序的，方便计算贡献。  


## 4. C++核心代码实现赏析

### **本题通用核心C++实现参考**  
* **说明**：综合TonyYin、_determination_等题解的思路，提炼出的标准实现，逻辑清晰，适合初学者模仿。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int MOD = 1e9 + 7;
  const int MAXN = 1e5 + 5;

  long long fac[MAXN], inv_fac[MAXN];

  long long quick_pow(long long a, long long b) {
      long long res = 1;
      while (b) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  void init(int n) {
      fac[0] = 1;
      for (int i = 1; i <= n; ++i) {
          fac[i] = fac[i-1] * i % MOD;
      }
      inv_fac[n] = quick_pow(fac[n], MOD-2);
      for (int i = n-1; i >= 0; --i) {
          inv_fac[i] = inv_fac[i+1] * (i+1) % MOD;
      }
  }

  long long C(int n, int k) {
      if (n < 0 || k < 0 || n < k) return 0;
      return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD;
  }

  int main() {
      int n, k;
      cin >> n >> k;
      vector<long long> a(n);
      for (int i = 0; i < n; ++i) {
          cin >> a[i];
      }
      sort(a.begin(), a.end());
      init(n);
      long long max_sum = 0, min_sum = 0;
      for (int i = k-1; i < n; ++i) { // 注意：数组从0开始，i对应第i+1个元素
          max_sum = (max_sum + a[i] * C(i, k-1) % MOD) % MOD;
      }
      for (int i = 0; i <= n - k; ++i) {
          min_sum = (min_sum + a[i] * C(n - i - 1, k-1) % MOD) % MOD;
      }
      long long ans = (max_sum - min_sum + MOD) % MOD;
      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **预处理**：`init`函数计算阶乘`fac`和逆元`inv_fac`。  
  2. **输入与排序**：读取数组并排序。  
  3. **计算最大值之和**：遍历排序后的数组，从第$k-1$个元素（0开始）开始，计算每个元素作为最大值的贡献。  
  4. **计算最小值之和**：遍历数组，从第0个元素开始，计算每个元素作为最小值的贡献。  
  5. **输出结果**：最大值之和减去最小值之和，取模后输出。  

### **关键代码片段赏析（以计算最大值之和为例）**  
* **代码片段**：  
  ```cpp
  for (int i = k-1; i < n; ++i) {
      max_sum = (max_sum + a[i] * C(i, k-1) % MOD) % MOD;
  }
  ```  
* **代码解读**：  
  - 为什么`i`从`k-1`开始？因为数组从0开始，第`i`个元素前面有`i`个元素，要选`k-1`个，所以`i`至少为`k-1`（前面有`k-1`个元素）。  
  - `C(i, k-1)`是什么意思？从前面的`i`个元素中选`k-1`个，与当前元素组成$K$元子集，此时当前元素是最大值。  
* 💡 **学习笔记**：循环的起始和结束条件是组合数计算的关键，一定要结合排序后的数组索引来理解！  


## 5. 算法可视化：像素动画演示 (核心部分)

### **动画演示主题**：像素小队“选队长”游戏（模拟子集的max-min计算）  

### **设计思路**：  
采用8位像素风（类似FC游戏《超级马里奥》），将数组元素设计为“像素小人”，排序后按身高站成一排。通过“选队长”（选最大值）和“选队员”（选最小值）的游戏流程，直观展示贡献计算过程。  

### **动画帧步骤**：  
1. **初始化**：屏幕显示一排像素小人（代表数组元素），身高随机（未排序）。控制面板有“开始”“单步”“重置”按钮，以及速度滑块。  
2. **排序**：小人按身高从矮到高排列（动画显示小人移动的过程），背景音乐切换为轻快的“排序进行曲”。  
3. **计算最大值贡献**：  
   - 第$i$个小人（从左到右）“举起队长旗”（高亮显示），前面的$i-1$个小人中，选$k-1$个“站出来”（闪烁），屏幕上方显示组合数$C(i-1, k-1)$。  
   - 播放“叮”的音效，最大值之和增加$a[i] \times C(i-1, k-1)$，并在屏幕右上角显示当前总和。  
4. **计算最小值贡献**：  
   - 第$i$个小人“蹲下来”（表示最小值），后面的$n-i$个小人中，选$k-1$个“站出来”（闪烁），屏幕上方显示组合数$C(n-i, k-1)$。  
   - 播放“咚”的音效，最小值之和增加$a[i] \times C(n-i, k-1)$。  
5. **结果展示**：所有小人围成一圈，屏幕中央显示最终答案（最大值之和-最小值之和），播放“胜利进行曲”，并弹出“通关！”的像素文字。  

### **游戏化元素**：  
- **积分系统**：每计算一个元素的贡献，获得10分，完成所有计算获得“组合数学小能手”称号。  
- **AI演示模式**：点击“AI自动玩”，算法会自动完成排序和计算，学习者可以观察整个过程。  


## 6. 拓展练习与相似问题思考

### **通用思路迁移**：  
本题的“贡献拆分”和“组合数计算”思路，可用于解决以下问题：  
1. **子序列的max-min和**（如洛谷P2679）：计算所有长度为$K$的子序列的max-min之和。  
2. **区间贡献问题**（如洛谷P1091合唱队形）：计算最长递增子序列的长度，需要统计每个元素作为“峰”或“谷”的贡献。  
3. **组合数应用**（如洛谷P3197砝码称重）：计算用给定砝码能称出的重量组合数。  

### **洛谷练习推荐**：  
1. **洛谷P2679** - 《子序列的max-min和》  
   🗣️ **推荐理由**：本题的“加强版”，需要计算所有长度为$K$的子序列的max-min之和，思路完全一致，适合巩固贡献拆分的技巧。  
2. **洛谷P1091** - 《合唱队形》  
   🗣️ **推荐理由**：需要统计每个元素作为“峰”的最长递增子序列长度，用到了类似的“贡献统计”思想，是组合数学与动态规划的结合。  
3. **洛谷P3197** - 《砝码称重》  
   🗣️ **推荐理由**：需要计算组合数来统计可能的重量组合，适合练习阶乘和逆元的预处理。  


## 7. 学习心得与经验分享 (若有)

本次分析的题解中，TonyYin提到“逆元求组合数的方法”是解决本题的关键。这提醒我们：**组合数取模问题，预处理阶乘和逆元是必须掌握的模板**。另外，_determination_的代码中用`ios::sync_with_stdio(false)`加速输入输出，这是竞赛中常用的优化技巧，值得学习。  


## 结语  
本次关于“[ABC151E] Max-Min Sums”的分析就到这里。记住：**组合数学的核心是“拆分问题”，将复杂的总和拆分为简单的贡献之和**。只要掌握了这个技巧，你就能解决很多类似的问题。下次我们再一起探索新的编程挑战！💪  

（注：可视化方案可通过HTML/CSS/JavaScript实现，如需具体代码示例，可参考[洛谷算法可视化库](https://visualgo.net/zh)的像素风格设计。）

---
处理用时：198.72秒
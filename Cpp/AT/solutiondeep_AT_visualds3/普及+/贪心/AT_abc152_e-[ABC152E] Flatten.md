# 题目信息

# [ABC152E] Flatten

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc152/tasks/abc152_e

$ N $ 個の正整数 $ A_1,...,A_N $ が与えられます。

次の条件を満たすような正整数 $ B_1,...,B_N $ を考えます。

条件：$ 1\ \leq\ i\ <\ j\ \leq\ N $ を満たすどのような $ i,j $ についても $ A_i\ B_i\ =\ A_j\ B_j $ が成り立つ。

このような $ B_1,...,B_N $ における $ B_1\ +\ ...\ +\ B_N $ の最小値を求めてください。

ただし、答えは非常に大きくなる可能性があるため、$ (10^9\ +7) $ で割ったあまりを出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^4 $
- $ 1\ \leq\ A_i\ \leq\ 10^6 $
- 入力中のすべての値は整数である。

### Sample Explanation 1

$ B_1=6 $, $ B_2=4 $, $ B_3=3 $ とすると条件を満たします。

### Sample Explanation 2

全ての $ B_i $ を $ 1 $ とすればよいです。

### Sample Explanation 3

和を $ (10^9+7) $ で割った余りを出力してください。

## 样例 #1

### 输入

```
3

2 3 4```

### 输出

```
13```

## 样例 #2

### 输入

```
5

12 12 12 12 12```

### 输出

```
5```

## 样例 #3

### 输入

```
3

1000000 999999 999998```

### 输出

```
996989508```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC152E] Flatten 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（质因数分解、最小公倍数LCM、逆元应用）  

🗣️ **初步分析**：  
解决“Flatten”问题的关键，在于让所有`A_i × B_i`等于**所有`A`的最小公倍数（LCM）**——这是让`B`数组和最小的关键（就像把不同大小的杯子装满同样多的水，最少需要的总水量是杯子容量的LCM）。但LCM的值可能大到无法用普通变量存储，因此需要用**质因数分解+模运算**来处理。  

### 核心思路拆解  
1. **质因数分解**：将每个`A_i`分解成质因数的乘积（比如`12=2²×3`）。  
2. **统计最大次数**：对于每个质因数（比如`2`），记录它在所有`A_i`中出现的**最大次数**（比如`A`数组中有`12=2²×3`、`8=2³`，则`2`的最大次数是`3`）。  
3. **计算LCM的模**：用快速幂计算每个质因数的最大次数次方，再相乘（模`1e9+7`），得到LCM的模形式。  
4. **求逆元算B_i**：`B_i = LCM / A_i`，由于除法取模需要逆元（费马小定理），所以`B_i = LCM × inv(A_i) mod 1e9+7`。  
5. **求和**：将所有`B_i`相加（模`1e9+7`）。  

### 可视化设计思路  
我们可以用**8位像素风格**模拟这个过程：  
- **场景**：屏幕左侧是`A`数组的像素块（比如`A=[2,3,4]`显示为三个方块，分别写着`2`、`3`、`4`）。  
- **分解步骤**：点击每个`A_i`块，它会“裂开”成质因数块（比如`4`变成两个`2`的小方块），显示在右侧。  
- **统计最大次数**：每个质因数块会“高亮”显示它的最大次数（比如`2`的最大次数是`2`，则两个`2`块会闪烁）。  
- **计算LCM**：将所有质因数块按最大次数合并（比如`2`的两个块+`3`的一个块，组成`LCM=12`的块）。  
- **求B_i**：`LCM`块会“分裂”成`B_i`块（比如`12/2=6`、`12/3=4`、`12/4=3`），最后累加这些块的数值。  

**交互设计**：支持“单步执行”（每点击一次走一步）、“自动播放”（按一定速度连续执行），并添加音效（分解时“叮”一声，统计时“嗒”一声，完成时“胜利”音效）。


## 2. 精选优质题解参考

### 题解一：（来源：w33z8kqrqk8zzzx33，赞：2）  
* **点评**：这份题解的思路**非常清晰**，直接抓住了“LCM+逆元”的核心逻辑。代码结构工整，用`mx`数组统计每个质因数的最大次数，用快速幂计算LCM的模，逆元处理除法的部分也很规范。特别是**质因数分解的试除法**（针对`A_i≤1e6`的情况）效率足够，且代码简洁易懂。从实践角度看，这份代码可以直接用于竞赛，边界处理（比如`x!=1`的情况）也很严谨，是初学者学习的好例子。  

### 题解二：（来源：Jairon314，赞：1）  
* **点评**：此题解的代码**极其简洁**，将质因数分解、统计最大次数、计算LCM和求和合并成了一个流畅的流程。作者用`cnt`数组统计质因数的最大次数，并用`ans`变量巧妙地先计算`inv(A_i)`的和，再乘以LCM的模，简化了代码逻辑。这种“合并步骤”的技巧值得学习，能让代码更高效。  

### 题解三：（来源：Kreado，赞：2）  
* **点评**：这份题解用**欧拉筛**预处理了质因数，虽然代码较长，但**效率更高**（适合`A_i`更大的情况）。作者将质因数分解的过程优化为查表，减少了重复计算。此外，代码中的`inv`函数用费马小定理实现，正确性有保证。对于想深入学习质因数分解优化的同学，这份题解很有参考价值。


## 3. 核心难点辨析与解题策略

### 1. **难点1：LCM太大无法直接计算**  
- **分析**：`A_i`的范围是`1e6`，`N`是`1e4`，LCM可能达到`1e6^1e4`，远远超过`long long`的存储范围。  
- **解决方案**：**质因数分解**。LCM的质因数分解形式是每个质因数的**最大次数**次方的乘积（比如`LCM(2,3,4)=12=2²×3¹`）。我们可以统计每个质因数的最大次数，再用快速幂计算其模形式。  

💡 **学习笔记**：质因数分解是处理大LCM的“钥匙”，将无法存储的大数转化为可计算的质因数次数。  

### 2. **难点2：除法取模**  
- **分析**：`B_i = LCM / A_i`，但模运算中除法需要用**逆元**（因为`(a/b) mod MOD ≠ (a mod MOD)/(b mod MOD)`）。  
- **解决方案**：**费马小定理**（当`MOD`是质数时，`inv(b) = b^(MOD-2) mod MOD`）。例如，`inv(2) = 2^(1e9+7-2) mod 1e9+7`。  

💡 **学习笔记**：逆元是模运算中处理除法的“神器”，记住费马小定理的应用条件（MOD为质数）。  

### 3. **难点3：质因数分解的效率**  
- **分析**：`A_i`的范围是`1e6`，试除法（遍历`2`到`sqrt(x)`）的时间复杂度是`O(sqrt(x))`，对于`1e4`个`A_i`来说，总时间是`1e4×1e3=1e7`，完全可以接受。  
- **解决方案**：**试除法**。对于每个`A_i`，遍历`2`到`sqrt(x)`，分解出所有质因数。如果最后`x`大于`1`，则它本身是一个质因数。  

💡 **学习笔记**：试除法是最基础的质因数分解方法，适合小范围的`x`。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了w33z8kqrqk8zzzx33和Jairon314的思路，是“LCM+逆元”的典型实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int MOD = 1e9 + 7;
const int MAX_A = 1e6 + 5;

long long qpow(long long base, int exp) {
    long long res = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            res = (res * base) % MOD;
        }
        base = (base * base) % MOD;
        exp /= 2;
    }
    return res;
}

long long inv(long long x) {
    return qpow(x, MOD - 2);
}

int main() {
    int n;
    cin >> n;
    vector<long long> a(n);
    vector<int> mx(MAX_A, 0); // 统计每个质因数的最大次数

    // 质因数分解每个a[i]，统计最大次数
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        long long x = a[i];
        for (long long v = 2; v * v <= x; ++v) {
            if (x % v != 0) continue;
            int cnt = 0;
            while (x % v == 0) {
                cnt++;
                x /= v;
            }
            if (cnt > mx[v]) {
                mx[v] = cnt;
            }
        }
        if (x > 1) {
            if (1 > mx[x]) {
                mx[x] = 1;
            }
        }
    }

    // 计算LCM的模
    long long lcm_mod = 1;
    for (int i = 2; i < MAX_A; ++i) {
        if (mx[i] > 0) {
            lcm_mod = (lcm_mod * qpow(i, mx[i])) % MOD;
        }
    }

    // 计算B的和
    long long ans = 0;
    for (int i = 0; i < n; ++i) {
        ans = (ans + lcm_mod * inv(a[i]) % MOD) % MOD;
    }

    cout << ans << endl;

    return 0;
}
```  
* **代码解读概要**：  
  1. **快速幂与逆元**：`qpow`函数计算`base^exp mod MOD`，`inv`函数用费马小定理求逆元。  
  2. **质因数分解**：遍历每个`A_i`，用试除法分解质因数，统计每个质因数的最大次数（存于`mx`数组）。  
  3. **计算LCM模**：遍历`mx`数组，用快速幂计算每个质因数的最大次数次方，相乘得到LCM的模。  
  4. **求和**：计算每个`B_i = LCM × inv(A_i) mod MOD`，累加得到答案。


### 针对各优质题解的片段赏析  

#### 题解一：（来源：w33z8kqrqk8zzzx33）  
* **亮点**：用`mx`数组统计质因数的最大次数，逻辑清晰。  
* **核心代码片段**：  
```cpp
vector<int> mx(MAX_A, 0);
for (int i = 0; i < n; ++i) {
    long long x = a[i];
    for (long long v = 2; v * v <= x; ++v) {
        if (x % v != 0) continue;
        int cnt = 0;
        while (x % v == 0) {
            cnt++;
            x /= v;
        }
        if (cnt > mx[v]) {
            mx[v] = cnt;
        }
    }
    if (x > 1) {
        if (1 > mx[x]) {
            mx[x] = 1;
        }
    }
}
```  
* **代码解读**：  
  这段代码是**质因数分解与最大次数统计**的核心。对于每个`A_i`，遍历`2`到`sqrt(x)`，分解出所有质因数，并记录每个质因数的出现次数。如果`x`分解后仍大于`1`，则它本身是一个质因数（次数为`1`）。`mx`数组存储每个质因数的最大次数，比如`mx[2]`表示`2`在所有`A_i`中的最大出现次数。  
* 💡 **学习笔记**：`mx`数组是连接质因数分解和LCM计算的“桥梁”，一定要正确统计每个质因数的最大次数。  

#### 题解二：（来源：Jairon314）  
* **亮点**：将`inv(A_i)`的和与LCM的模合并计算，代码简洁。  
* **核心代码片段**：  
```cpp
long long ans = 0;
for (int i = 1; i <= n; ++i) {
    read(a[i]);
    factor(a[i]);
    ans = (ans + inv(a[i])) % MOD;
}
for (int i = 1; i <= maxn; ++i) {
    if (cnt[i]) {
        ans = (ans * qpow(i, cnt[i])) % MOD;
    }
}
```  
* **代码解读**：  
  这段代码的巧妙之处在于**先计算`inv(A_i)`的和**，再乘以LCM的模。因为`LCM × inv(A_i) = (LCM / A_i)`，所以`sum(LCM × inv(A_i)) = LCM × sum(inv(A_i))`。作者将`sum(inv(A_i))`先算出来，再乘以LCM的模，简化了代码逻辑。  
* 💡 **学习笔记**：数学上的等价转换可以简化代码，比如将`sum(LCM/A_i)`转化为`LCM × sum(1/A_i)`。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素数学家的LCM冒险”**（仿FC游戏风格）  

### 核心演示内容  
1. **初始化场景**：屏幕左侧显示`A`数组的像素块（比如`A=[2,3,4]`显示为三个红色方块，分别写着`2`、`3`、`4`），右侧是“质因数仓库”（空的），下方是“控制面板”（有“开始”、“单步”、“重置”按钮和速度滑块）。  
2. **质因数分解**：点击“开始”按钮，每个`A_i`块会“裂开”成质因数块（比如`4`变成两个蓝色的`2`块），并移动到右侧的“质因数仓库”。分解时播放“叮”的音效。  
3. **统计最大次数**：“质因数仓库”中的每个质因数块会“高亮”显示它的最大次数（比如`2`的块有两个，所以会闪烁两次）。统计时播放“嗒”的音效。  
4. **计算LCM**：“质因数仓库”中的块会按最大次数合并（比如两个`2`块+一个`3`块，组成一个绿色的`12`块）。合并时播放“嗡”的音效。  
5. **求B_i**：`12`块会“分裂”成三个黄色的`B_i`块（`6`、`4`、`3`），并移动到左侧的`A`数组下方。分裂时播放“叮”的音效。  
6. **求和**：黄色的`B_i`块会“融合”成一个橙色的`13`块（样例1的答案），并显示在屏幕中央。融合时播放“胜利”音效（上扬的8位音调）。  

### 交互与游戏化元素  
- **单步执行**：点击“单步”按钮，每一步（分解→统计→计算LCM→求B_i→求和）依次执行。  
- **自动播放**：拖动速度滑块可以调整执行速度（比如“慢”=1秒/步，“快”=0.1秒/步）。  
- **AI演示**：点击“AI自动演示”按钮，算法会自动执行所有步骤，像“贪吃蛇AI”一样完成解题。  
- **关卡设计**：将算法步骤分成“分解关”、“统计关”、“LCM关”、“B_i关”、“求和关”，每完成一关会显示“过关！”的提示，并给予“像素星星”奖励（收集10颗星星可以解锁“高级模式”）。  

### 技术实现思路  
- **像素风格**：用`Canvas`绘制8位像素块（比如`16x16`像素的方块），颜色采用FC游戏的经典配色（红、蓝、绿、黄、橙）。  
- **动画逻辑**：用`requestAnimationFrame`实现帧动画，每个步骤的动画持续`500ms`（可通过速度滑块调整）。  
- **音效**：用`Web Audio API`播放8位音效（比如分解的“叮”声是`440Hz`的正弦波，持续`100ms`；胜利的音效是`880Hz`的正弦波，持续`200ms`）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
`质因数分解+LCM+逆元`的思路不仅能解决本题，还能用于以下场景：  
1. **求多个数的LCM**：比如统计一组数的最小公倍数（如洛谷P1029）。  
2. **模运算中的除法**：比如求`(a/b) mod MOD`（如洛谷P2613）。  
3. **统计质因数的出现次数**：比如求一组数中每个质因数的最大次数（如洛谷P3383）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1029** - 最大公约数和最小公倍数问题  
   🗣️ **推荐理由**：这道题需要求两个数的GCD和LCM，能帮助你巩固“质因数分解”和“LCM计算”的知识。  
2. **洛谷 P2613** - 逆元  
   🗣️ **推荐理由**：这道题直接考察逆元的应用，能帮助你熟练掌握费马小定理的使用。  
3. **洛谷 P3383** - 线性筛素数  
   🗣️ **推荐理由**：这道题需要用线性筛预处理素数，能帮助你优化质因数分解的效率。  
4. **洛谷 P1292** - 倒酒问题  
   🗣️ **推荐理由**：这道题需要用LCM解决实际问题，能帮助你理解LCM的应用场景。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自 Jairon314)  
> “我在解决这个问题时，最初想直接计算LCM，但发现LCM太大无法存储。后来想到用质因数分解统计最大次数，再用模运算计算LCM的模，这样就解决了问题。”  

**点评**：这位作者的经验很典型。在处理大数问题时，**不要试图直接存储大数**，而是要找到它的“数学表示”（比如质因数分解形式），并用模运算处理。质因数分解是处理大数的“万能钥匙”，一定要掌握。  


## 结语  
本次关于“[ABC152E] Flatten”的C++解题分析就到这里。希望这份学习指南能帮助大家理解“质因数分解+LCM+逆元”的核心逻辑，并掌握解题技巧。记住，**数学是编程的基础**，只要掌握了数学原理，再难的问题也能迎刃而解！下次我们再一起探索新的编程挑战！💪

---
处理用时：213.01秒
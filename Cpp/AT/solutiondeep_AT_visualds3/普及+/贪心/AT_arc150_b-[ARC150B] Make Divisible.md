# 题目信息

# [ARC150B] Make Divisible

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc150/tasks/arc150_b

正整数 $ A,\ B $ が与えられます。

非負整数 $ X,\ Y $ であって、 $ B+Y $ が $ A+X $ の倍数となるようなものに対する $ X+Y $ の最小値を求めてください。

$ T $ 個のテストケースが与えられるので、それぞれについて求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 100 $
- $ 1\ \leq\ A,\ B\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

$ 1 $ 個目のテストケースについて、$ X=1,\ Y=1 $ とすると $ B+Y=24 $ は $ A+X=12 $ の倍数になります。このとき $ X+Y=2 $ であり、$ X+Y $ はこれより小さくすることはできないので答えは $ 2 $ です。 $ 2 $ 個目のテストケースについて、$ X=0,\ Y=0 $ とすると $ B+Y=16 $ は $ A+X=8 $ の倍数になります。

## 样例 #1

### 输入

```
5

11 23

8 16

4394 993298361

95392025 569922442

8399283 10293```

### 输出

```
2

0

65

2429708

8388990```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC150B] Make Divisible 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论分块（或根号分治）  

🗣️ **初步分析**：  
解决“Make Divisible”问题，关键在于找到**最小的X+Y**，使得\(B+Y\)是\(A+X\)的倍数。简单来说，数论分块就像“切蛋糕”——把相似的计算分成一块一块，只处理每块的“代表点”（比如左端点），就能快速找到最小值。在本题中，我们需要枚举\(A+X\)的可能值，但直接枚举会超时（因为\(A,B\)可达\(10^9\)），数论分块能将复杂度从\(O(B)\)降到\(O(\sqrt{B})\)。  

- **核心思路**：对于每个可能的\(A+X\)（记为\(k\)），\(Y\)的最小值是\(\lceil\frac{B}{k}\rceil \times k - B\)，因此\(X+Y = (k-A) + (\lceil\frac{B}{k}\rceil \times k - B)\)。我们需要找到\(k\)使得这个值最小。  
- **核心难点**：如何高效枚举\(k\)？数论分块告诉我们，\(\lceil\frac{B}{k}\rceil\)的值在连续的\(k\)区间内是相同的，因此只需处理每个区间的左端点（因为左端点对应的\(k\)最小，\(X+Y\)也最小）。  
- **可视化设计思路**：用像素动画展示“分块”过程——屏幕上显示一个像素化的“蛋糕”（代表\(k\)的范围），每切一块（区间），就高亮当前块的左端点，计算对应的\(X+Y\)值，并显示在屏幕右侧。关键操作（如计算\(\lceil\frac{B}{k}\rceil\)、更新最小值）会伴随“叮”的音效，增强记忆。  


## 2. 精选优质题解参考

### 题解一：来源：NobodyThere（赞：7）  
* **点评**：这份题解的思路非常清晰，用“根号分治”将\(A\)分为两种情况（\(A\leq\sqrt{B}\)和\(A>\sqrt{B}\)），分别处理。代码规范，变量名（如\(s\)表示\(\sqrt{B}\)、\(ans\)表示最小值）含义明确。特别是**边界条件的处理**（如\(A\geq B\)时直接输出\(A-B\)）非常严谨，避免了不必要的计算。算法上，根号分治的复杂度控制在\(O(\sqrt{B})\)，完全满足题目要求。从实践角度看，代码可以直接用于竞赛，是一份非常优质的参考。  

### 题解二：来源：cmrhhh（赞：3）  
* **点评**：此题解用“数论分块”的思路，将问题转化为枚举\(k\)的区间，每段区间的左端点对应最小的\(X+Y\)。代码中的循环结构（\(for(ll l=a;l<=b-1;l=r+1)\)）清晰展示了分块的过程，虽然在实现时遇到了“r取到最后需要再算一次”的小问题，但整体逻辑正确。**向上取整的转化**（\(\lceil\frac{a}{b}\rceil = \lfloor\frac{a-1}{b}+1\rfloor\)）是解题的关键，值得学习。  

### 题解三：来源：Miraik（赞：2）  
* **点评**：此题解的代码非常简洁，用数学公式直接表达了\(X+Y\)的最小值（\(i+(a+i)-(b\mod(a+i))\)），并通过分块枚举左端点来优化。**结论的证明**（左端点是块内最优值）非常直观，帮助理解为什么分块有效。代码中的循环（\(for(int i=(b+a-1)/a,l=a;i>1;l=(b+i-2)/(i-1),i=(b+l-1)/l)\)）展示了分块的反向枚举方式，适合拓展思维。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何将问题转化为数学表达式？**  
* **分析**：题目要求\(B+Y\)是\(A+X\)的倍数，即\(B+Y = k \times (A+X)\)（\(k\)为正整数）。由于\(Y\geq0\)，\(k\)的最小值是\(\lceil\frac{B}{A+X}\rceil\)，因此\(Y = k \times (A+X) - B\)。\(X+Y\)的表达式为\((A+X - A) + (k \times (A+X) - B) = (k \times (A+X) + (A+X)) - (A+B) = (k+1) \times (A+X) - (A+B)\)（当\(k=\lceil\frac{B}{A+X}\rceil\)时）。  
* 💡 **学习笔记**：数学转化是解题的第一步，将问题转化为表达式才能找到优化方向。  

### 2. **关键点2：如何应用数论分块？**  
* **分析**：数论分块的核心是“相同值的区间合并”。对于\(\lceil\frac{B}{k}\rceil\)，当\(k\)在某个区间内时，其值不变。例如，当\(k\)从\(a\)到\(b\)时，\(\lceil\frac{B}{k}\rceil\)的值可能相同，此时只需计算区间的左端点（因为左端点的\(k\)最小，\(X+Y\)也最小）。  
* 💡 **学习笔记**：数论分块是处理“枚举+优化”问题的常用技巧，记住“左端点最优”的结论。  

### 3. **关键点3：如何处理边界条件？**  
* **分析**：当\(A\geq B\)时，\(X+Y\)的最小值是\(A-B\)（因为\(Y=0\)，\(X=A-B\)）；当\(B\)是\(A\)的倍数时，\(X=Y=0\)，直接输出0。这些边界条件需要优先处理，避免不必要的计算。  
* 💡 **学习笔记**：边界条件是代码正确性的关键，一定要先考虑特殊情况。  

### ✨ 解题技巧总结  
- **技巧A：数学转化**：将问题转化为表达式，找到优化方向。  
- **技巧B：数论分块**：合并相同值的区间，减少枚举次数。  
- **技巧C：边界处理**：优先处理特殊情况，避免错误。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了NobodyThere、cmrhhh、Miraik的题解思路，采用数论分块优化，逻辑清晰，适合作为模板。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long ll;

ll cil(ll up, ll dn) { return (up + dn - 1) / dn; } // 向上取整

void solve() {
    ll a, b;
    cin >> a >> b;
    if (a >= b) {
        cout << a - b << '\n';
        return;
    }
    if (b % a == 0) {
        cout << 0 << '\n';
        return;
    }
    ll ans = min(b - a, a - b % a); // 初始值：X=0或Y=0的情况
    for (ll l = a, r; l <= b; l = r + 1) {
        r = b / (b / l); // 分块的右端点
        ll k = l; // 当前的A+X
        ll cost = (k - a) + (cil(b, k) * k - b); // X+Y的计算
        ans = min(ans, cost);
    }
    cout << ans << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. **边界处理**：先处理\(A\geq B\)和\(B\)是\(A\)倍数的情况。  
  2. **初始值**：计算\(X=0\)（\(Y=b-a\)）和\(Y=0\)（\(X=a-b\%a\)）的最小值。  
  3. **数论分块**：枚举\(k\)（\(A+X\)）的区间，计算每个区间左端点的\(X+Y\)值，更新最小值。  


### 针对各优质题解的片段赏析  

#### 题解一：来源：NobodyThere  
* **亮点**：根号分治的分类讨论，处理大\(A\)和小\(A\)的情况。  
* **核心代码片段**：  
```cpp
if (a <= s) { // s=sqrt(b)
    for(int i = 1; i <= a; i++) {
        int x = a + i;
        ans = min(ans, i + ((x - b) % x + x) % x);
    }
} else {
    for(int i = 2; i <= a; i++) {
        int x = udiv(b, i);
        if(x < a) break;
        ans = min(ans, x - a + ((x - b) % x + x) % x);
    }
}
```  
* **代码解读**：  
  - 当\(A\leq\sqrt{B}\)时，直接枚举\(X\)（\(1\)到\(A\)），计算\(k=A+X\)对应的\(X+Y\)。  
  - 当\(A>\sqrt{B}\)时，枚举\(k\)的可能值（\(udiv(b, i)\)表示\(\lceil\frac{B}{i}\rceil\)），计算对应的\(X+Y\)。  
* 💡 **学习笔记**：根号分治是处理大数值枚举的有效方法，根据\(A\)的大小选择不同的枚举策略。  

#### 题解二：来源：cmrhhh  
* **亮点**：数论分块的正向枚举，清晰展示区间的划分。  
* **核心代码片段**：  
```cpp
for(ll l=a;l<=b-1;l=r+1){
    r=min(b-1,(b-1)/((b-1)/l));
    ans=min(ans,(l-a)+(1+(b-1)/l)*l-b);
}
```  
* **代码解读**：  
  - 枚举\(k\)的区间（\(l\)到\(r\)），其中\((b-1)/l\)表示\(\lfloor\frac{B-1}{l}\rfloor\)，\(r\)是该区间的右端点。  
  - 计算区间左端点\(l\)对应的\(X+Y\)值（\((l-a)\)是\(X\)，\((1+(b-1)/l)*l - b\)是\(Y\)）。  
* 💡 **学习笔记**：数论分块的正向枚举容易理解，适合初学者。  

#### 题解三：来源：Miraik  
* **亮点**：简洁的数学公式，直接计算\(X+Y\)。  
* **核心代码片段**：  
```cpp
for(int i=(b+a-1)/a,l=a;i>1;l=(b+i-2)/(i-1),i=(b+l-1)/l) 
    if(b%l==0) ans=min(ans,l-a);
    else ans=min(ans,(l-a)+l-b%l);
```  
* **代码解读**：  
  - 反向枚举\(i\)（\(\lceil\frac{B}{k}\rceil\)），计算对应的\(k\)（\(l\)）。  
  - 如果\(k\)是\(B\)的倍数，\(Y=0\)，\(X=k-a\)；否则，\(Y=k - B\%k\)，\(X=k-a\)。  
* 💡 **学习笔记**：反向枚举可以减少计算量，适合熟悉数论分块的学习者。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素蛋糕店的“分块切糕”游戏**  
（仿照FC红白机风格，用8位像素画展示数论分块的过程）  

### 核心演示内容  
- **场景初始化**：屏幕左侧显示一个巨大的像素蛋糕（代表\(k\)的范围，从\(A\)到\(B\)），右侧显示“当前最小值”“当前块”等信息。控制面板有“开始”“单步”“重置”按钮，以及速度滑块。  
- **分块过程**：  
  1. **切第一块**：蛋糕被切成第一块（区间\(l=a\)到\(r\)），块的颜色变为红色（高亮），伴随“咔嚓”的音效。  
  2. **计算值**：屏幕右侧显示当前块的左端点\(l\)，计算\(X+Y=(l-a)+(\lceil\frac{B}{l}\rceil\times l - B)\)，并更新“当前最小值”。  
  3. **切下一块**：蛋糕的下一块被切成蓝色，重复上述过程，直到所有块都被处理。  
- **目标达成**：当所有块处理完毕，屏幕显示“找到最小值！”，伴随胜利音效（如“叮~叮~”），最小值用金色字体显示。  

### 游戏化元素  
- **AI自动演示**：点击“AI自动”按钮，算法会自动切糕，像“贪吃蛇AI”一样逐步完成，学习者可以观察过程。  
- **关卡设计**：将分块过程分为3个小关卡（如“切前1/3”“切中间1/3”“切后1/3”），完成每个关卡会获得像素星星奖励，增强成就感。  
- **音效设计**：  
  - 切糕：“咔嚓”声（每次分块）。  
  - 计算值：“叮”声（每次更新最小值）。  
  - 胜利：“叮~叮~”声（找到最小值）。  

### 设计思路  
用“切蛋糕”的比喻让数论分块更直观，像素风格和游戏化元素增加趣味性，帮助青少年记住“分块处理”的核心思想。音效和高亮效果强化关键操作的记忆，让算法过程“看得见、听得到”。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
数论分块不仅能解决本题，还能用于：  
1. **求\(\sum_{i=1}^n \lfloor\frac{n}{i}\rfloor\)**：通过分块计算每个区间的和。  
2. **最小化线性组合**：如找到最小的\(x+y\)使得\(ax+by=c\)（类似本题的优化问题）。  
3. **数论函数求和**：如计算\(\sum_{i=1}^n \sigma(i)\)（约数和函数），通过分块优化。  

### 练习推荐 (洛谷)  
1. **洛谷 P1429** - 平面最近点对（加强版）  
   * 🗣️ **推荐理由**：本题需要用分治思想优化枚举，类似数论分块的“分而治之”思路，帮助巩固优化意识。  
2. **洛谷 P2261** - [CQOI2007]余数求和  
   * 🗣️ **推荐理由**：本题直接考察数论分块的应用，要求计算\(\sum_{i=1}^n (k \mod i)\)，是数论分块的经典题目。  
3. **洛谷 P3935** -  Calculating  
   * 🗣️ **推荐理由**：本题需要计算\(\sum_{i=1}^n f(i)\)（\(f(i)\)是\(i\)的约数个数），通过数论分块优化，适合拓展思维。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自 mountain_climber)**：“交了一吨终于过了，原来是多测中特判直接`return 0;`了，属实难绷。”  
* **点评**：这位作者的经历很典型——在多测试用例的题目中，特判后一定要用`continue`而不是`return`，否则会提前结束程序。这提醒我们，**调试时要注意程序的流程控制**，尤其是多测试用例的情况。  


## 结语  
本次关于“[ARC150B] Make Divisible”的C++解题分析就到这里。希望这份学习指南能帮助大家理解数论分块的核心思想，掌握解题技巧。记住，编程能力的提升在于**持续学习、勤于思考、勇于实践**——下次我们再一起探索新的编程挑战！💪

---
处理用时：193.59秒
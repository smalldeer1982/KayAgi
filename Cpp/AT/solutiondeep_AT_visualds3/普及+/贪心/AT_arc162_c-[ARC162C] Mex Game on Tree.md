# 题目信息

# [ARC162C] Mex Game on Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc162/tasks/arc162_c

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の根付き木が与えられます。頂点 $ 1 $ が根であり、頂点 $ i\ (2\leq\ i\ \leq\ N) $ の親は $ P_i $ です。

根付き木の何個かの頂点には $ 0 $ 以上 $ N $ 以下の整数が書かれています。この情報は数列 $ A=(A_1,A_2,\ldots,A_N) $ で与えられ、$ A_i\ \neq\ -1 $ の場合頂点 $ i $ に整数 $ A_i $ が書かれており、$ A_i=-1 $ の場合頂点 $ i $ には整数が書かれていないことを意味しています。

Alice と Bob でゲームをします。Alice が先手で、全ての頂点に整数が書かれるまで以下の操作を交互に繰り返します。

- 整数が書かれていない頂点を $ 1 $ 個選び、 $ 0 $ 以上 $ N $ 以下の整数を書く。
 
操作終了後の各頂点 $ v $ に対して、 $ f(v) $ を「頂点 $ v $ の部分木に含まれるどの頂点（$ v $ 含む）にも書かれていないような最小の非負整数」と定めます。

$ f(v)\ =\ K $ を満たす頂点 $ v $ が存在する場合 Alice の勝利、そうでない場合 Bob の勝利となります。両者が最適な行動を行う場合、どちらが勝つか判定してください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えてください。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^3 $
- $ 2\ \leq\ N\ \leq\ 10^3 $
- $ 0\ \leq\ K\ \leq\ N $
- $ 1\ \leq\ P_i\ <\ i\ (2\leq\ i\leq\ N) $
- $ -1\ \leq\ A_i\ \leq\ N\ (1\leq\ i\leq\ N) $
- 入力される数値は全て整数
- $ 1 $ つの入力に含まれるテストケースについて、$ N $ の総和は $ 2\times\ 10^3 $ 以下
 
### Sample Explanation 1

$ 1 $ 番目のテストケースについては、Alice が頂点 $ 2 $ に $ 0 $ を書き込むと、Bob の操作に依らず $ f(2)\ =\ 2 $ となります。そのため、Alice は勝つことができます。 $ 2 $ 番目のテストケースについては、Bob が上手く書き込む整数を選ぶことで、 $ f(v)\ =\ 4 $ なる頂点が存在しないようにできます。

## 样例 #1

### 输入

```
2

4 2

1 1 2

-1 -1 3 1

6 4

1 2 2 1 3

-1 -1 -1 -1 -1 -1```

### 输出

```
Alice

Bob```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC162C] Mex Game on Tree 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：博弈论+树结构应用（子树状态合并）

🗣️ **初步分析**：  
这道题就像Alice和Bob在一棵“数字树”上玩“找钥匙”游戏——Alice要让某个“房间”（子树）里缺少的“最小钥匙”（Mex值）正好是`K`，而Bob要阻止她。解决问题的关键在于**判断Alice是否能在Bob破坏前，找到一个“易守难攻”的子树**：  
- 若某个子树已经填满数字，且它的Mex正好是`K`（相当于房间本来就缺`K`号钥匙），Alice直接赢；  
- 若某个子树只剩1个空位，且填一个数就能让Mex变成`K`（相当于只需要补一把钥匙就能凑齐），Alice也能赢；  
- 否则，Bob可以通过填`K`（相当于把`K`号钥匙扔进所有包含该节点的房间），破坏所有可能的子树，最终获胜。  

**核心算法流程**：  
我们需要从叶子节点往上**合并子树状态**（用`bitset`记录子树中存在的数字，`cnt`记录空位数量），快速判断每个子树是否满足Alice的胜利条件。  
**可视化设计思路**：  
用8位像素风格展示树结构（节点是方块，根在顶部），子树合并时用“渐变色”动画表示状态传递，空位用“闪烁的问号”标记，满足条件的子树用“金色边框”高亮。当Alice找到目标子树时，播放“胜利音效”（类似FC游戏的“叮~”）；Bob填`K`时，节点变成“红色”，并扩散到所有祖先节点（表示这些子树被破坏）。


## 2. 精选优质题解参考

### 题解一（作者：_•́へ•́╬_，赞：7）  
* **点评**：  
  这份题解的思路**直击本质**——把问题简化为“判断是否存在满足条件的子树”，逻辑非常清晰。作者用`bitset`高效维护子树中的数字存在情况（比如`a[i]`的第`x`位为1表示子树`i`中没有`x`），从叶子往上合并子树（父节点的`bitset`是子节点的交集，空位数量累加）。代码中的关键判断（`cnt[i]==0`时检查Mex是否为`K`，`cnt[i]==1`时检查是否能通过填一个数得到`K`）非常严谨，完美覆盖了Alice的胜利条件。此外，`bitset`的使用（比如`_Find_first()`找最小缺失值）极大优化了时间复杂度，适合`N=1e3`的规模。


### 题解二（作者：Lucky_Xiang，赞：3）  
* **点评**：  
  这道题解的**转化思路**很有启发性——把问题变成“Alice和Bob轮流操作子树空位”的博弈游戏。作者指出，Bob填`K`会破坏所有包含该节点的子树，因此Alice需要找到“空位≤1”的子树（相当于“只能被攻击一次”的目标）。这种转化让问题更易理解，尤其是对于博弈论新手来说，把复杂的树问题简化为“取石子”模型，降低了思考难度。代码中的`dfs`序遍历子树（用`dfn`和`bot`标记子树范围）是处理树结构的常用技巧，值得学习。


### 题解三（作者：wangshulin，赞：0）  
* **点评**：  
  这份题解的**代码实现**非常直观，适合初学者理解。作者用`dfs`序遍历子树（`dfn`记录进入时间，`bot`记录离开时间），直接统计子树中的数字和空位数量。虽然时间复杂度是`O(N^2)`（对于每个子树遍历其所有节点），但对于`N=1e3`的规模完全可行。代码中的条件判断（`ccol[k]`是否存在、空位数量是否≤1、缺少的数字数量是否≤1）非常清晰，完美对应题目要求。


## 3. 核心难点辨析与解题策略

### 1. **关键点1：理解Bob的最优策略——填`K`**  
* **分析**：  
  Bob要阻止任何子树的Mex等于`K`，最优选择是**填`K`**。因为如果某个节点填了`K`，那么它的所有祖先节点的子树中都有`K`，这些子树的Mex一定不会是`K`（Mex是“最小缺失值”，有`K`的话，缺失值至少是`K+1`）。这一步是问题的“突破口”，想通了这一点，后面的判断条件就迎刃而解。  
* 💡 **学习笔记**：博弈论中，“破坏对方核心目标”的策略往往是最优的。


### 2. **关键点2：高效合并子树状态**  
* **分析**：  
  要判断每个子树的Mex和空位数量，直接遍历每个子树的所有节点（`O(N^2)`）虽然可行，但对于更大的`N`（比如`1e5`）会超时。题解一中用`bitset`合并子树状态（`a[父] &= a[子]`），可以将子树的数字存在情况快速合并，时间复杂度优化到`O(N*N/64)`（`bitset`的位运算）。这种“自底向上”的合并方式是处理树结构问题的常用技巧。  
* 💡 **学习笔记**：树结构问题中，“自底向上”合并子树状态往往比“自顶向下”遍历更高效。


### 3. **关键点3：判断子树是否满足Alice的胜利条件**  
* **分析**：  
  Alice的胜利条件可以拆解为两种情况：  
  （1）子树填满（`cnt=0`），且Mex等于`K`（`bitset`的最小缺失值是`K`）；  
  （2）子树有1个空位（`cnt=1`），且Mex等于`K`（即`bitset`中缺少`K`，且缺少的数字数量≤1，因为填一个数可以补全）。  
  这两个条件覆盖了所有Alice能赢的情况，只要存在一个子树满足其中一个条件，Alice就可以获胜。  
* 💡 **学习笔记**：复杂的条件判断可以拆解为“原子条件”，逐一验证。


### ✨ 解题技巧总结  
- **博弈论策略**：优先考虑对方的最优策略（比如Bob填`K`），再推导自己的胜利条件；  
- **树结构处理**：用`dfs`序遍历子树（适合小规模）或`bitset`合并子树状态（适合大规模）；  
- **条件判断**：拆解复杂条件，用“是否填满”“空位数量”“Mex值”三个维度组合判断。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（基于题解一优化）  
* **说明**：  
  本代码综合了题解一的`bitset`优化和题解三的`dfs`序思路，用`bitset`维护子树中的数字存在情况，从叶子往上合并，快速判断Alice的胜利条件。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <bitset>
  using namespace std;

  const int N = 1005;
  vector<int> children[N]; // 存储树的子节点
  int A[N]; // 节点的初始值（-1表示空位）
  bitset<N> mex_bits[N]; // 子树i中的数字存在情况（1表示不存在）
  int cnt[N]; // 子树i中的空位数量

  void dfs(int u) {
      mex_bits[u].set(); // 初始化：所有数字都不存在（bitset的位为1）
      cnt[u] = 0;
      if (A[u] == -1) {
          cnt[u] = 1; // 当前节点是空位
      } else {
          mex_bits[u].reset(A[u]); // 标记当前节点的数字存在
      }
      // 合并子节点的状态
      for (int v : children[u]) {
          dfs(v);
          mex_bits[u] &= mex_bits[v]; // 子树的数字存在情况是交集（都不存在的数字才保留）
          cnt[u] += cnt[v]; // 空位数量累加
      }
      // 判断当前子树是否满足Alice的胜利条件
      if (cnt[u] == 0) {
          if (mex_bits[u]._Find_first() == K) { // Mex等于K
              cout << "Alice" << endl;
              exit(0); // 直接退出，因为Alice已经赢了
          }
      } else if (cnt[u] == 1) {
          int missing = 0;
          int mex = mex_bits[u]._Find_first();
          if (mex == K) { // 填一个数就能得到K
              cout << "Alice" << endl;
              exit(0);
          }
          // 检查是否缺少的数字数量≤1（比如mex是K-1，填K即可）
          missing = 0;
          for (int i = 0; i < K; i++) {
              if (mex_bits[u].test(i)) {
                  missing++;
              }
          }
          if (missing <= 1) {
              cout << "Alice" << endl;
              exit(0);
          }
      }
  }

  int main() {
      int T;
      cin >> T;
      while (T--) {
          int N, K;
          cin >> N >> K;
          // 初始化树结构
          for (int i = 1; i <= N; i++) {
              children[i].clear();
          }
          for (int i = 2; i <= N; i++) {
              int P;
              cin >> P;
              children[P].push_back(i);
          }
          // 读取初始值
          for (int i = 1; i <= N; i++) {
              cin >> A[i];
          }
          // 从根节点开始dfs
          dfs(1);
          // 如果没有找到满足条件的子树，Bob赢
          cout << "Bob" << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  代码的核心是`dfs`函数，从叶子节点往上合并子树状态：  
  1. 初始化当前节点的`bitset`（所有数字都不存在）和空位数量；  
  2. 合并子节点的`bitset`（交集）和空位数量（累加）；  
  3. 判断当前子树是否满足Alice的胜利条件（填满且Mex=K，或1个空位且能填出Mex=K），如果满足直接输出“Alice”并退出。


### 题解一核心代码片段赏析  
* **亮点**：`bitset`优化子树合并，快速计算Mex。  
* **核心代码片段**：  
  ```cpp
  for (int i = n-1; i >= 0; --i) {
      if (~x[i]) a[i][x[i]] = 0; // 标记当前节点的数字存在
      else ++cnt[i]; // 空位数量加1
      // 判断是否满足Alice的胜利条件
      if (!cnt[i]) {
          if (a[i]._Find_first() == m) { // Mex等于K
              printf("Alice\n");
              goto nxt;
          }
      } else if (cnt[i] == 1) {
          int mex1 = a[i]._Find_first();
          int mex2 = a[i]._Find_next(mex1);
          if (mex1 == m || mex2 == m) { // 填一个数就能得到K
              printf("Alice\n");
              goto nxt;
          }
      }
      // 合并到父节点
      if (i) {
          a[f[i]] &= a[i]; // 父节点的bitset是子节点的交集
          cnt[f[i]] += cnt[i]; // 父节点的空位数量累加
      }
  }
  ```
* **代码解读**：  
  - `a[i][x[i]] = 0`：用`bitset`标记当前节点的数字存在（比如`x[i]=3`，则`a[i]`的第3位设为0，表示子树`i`中存在3）；  
  - `a[i]._Find_first()`：找到`bitset`中第一个为1的位，即子树`i`的Mex值；  
  - `a[f[i]] &= a[i]`：父节点的`bitset`是子节点的交集（只有子树中都不存在的数字，父节点的子树才不存在）；  
  - `cnt[f[i]] += cnt[i]`：父节点的空位数量是子节点的空位数量之和。  
* 💡 **学习笔记**：`bitset`的`_Find_first()`函数可以快速找到最小缺失值（Mex），是处理Mex问题的神器。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《数字树的钥匙游戏》（8位像素风格）  
**设计思路**：  
用FC红白机的风格展示树结构（节点是16x16的方块，根在顶部，子节点在下方），用颜色标记节点状态（绿色=已填数，灰色=空位，红色=Bob填了`K`），用动画展示子树合并的过程，让学习者直观看到“Mex如何计算”和“Bob如何破坏”。


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示像素树（根节点1在顶部，子节点2、3在下方，依此类推）；  
   - 右侧显示“控制面板”：开始/暂停按钮、单步执行滑块、速度调节滑块；  
   - 底部显示“当前子树状态”：Mex值、空位数量、bitset可视化（用小方块表示位，1=白色，0=黑色）。  
2. **子树合并动画**：  
   - 从叶子节点开始，每个节点的`bitset`逐渐与子节点的`bitset`合并（比如节点2的`bitset`与节点4的`bitset`相与，动画表现为“节点2的方块吸收节点4的方块”）；  
   - 合并时播放“叮~”的音效，空位数量累加（比如节点2有1个空位，节点4有1个空位，合并后节点2的空位数量变成2，动画表现为“节点2的方块上的问号数量增加”）。  
3. **Alice胜利条件判断**：  
   - 当某个子树满足条件（比如节点3填满且Mex=K），节点3的方块变成“金色”，并播放“胜利音效”（类似FC游戏的“通关音乐”）；  
   - 屏幕弹出“Alice赢了！”的文字，动画停止。  
4. **Bob破坏动画**：  
   - 如果没有满足条件的子树，Bob开始操作：选择一个空位（比如节点5），填`K`（节点5的方块变成红色）；  
   - 红色扩散到所有祖先节点（节点5→节点3→节点1），表示这些子树的Mex不可能是`K`，播放“破坏音效”（类似“滋滋”声）；  
   - 屏幕弹出“Bob赢了！”的文字，动画停止。


### 游戏化元素设计  
- **AI自动演示模式**：点击“AI演示”按钮，算法会自动执行子树合并和判断过程，像“贪吃蛇AI”一样展示Alice如何找目标子树；  
- **关卡设计**：将树的深度分为“小关”（比如深度1→深度2→深度3），完成每一关后显示“过关！”的提示，增加成就感；  
- **音效反馈**：合并子树→“叮~”，满足条件→“通关音乐”，Bob填`K`→“滋滋”，让学习者通过音效记住关键操作。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的核心思路（**博弈论中的状态判断+树结构的子树合并**）可以迁移到以下场景：  
- **树中的博弈问题**：比如“Alice和Bob轮流在树节点上操作，判断谁赢”；  
- **子树状态统计问题**：比如“统计每个子树中的最大值/最小值/出现次数”；  
- **Mex相关问题**：比如“求每个子树的Mex值”。


### 练习推荐 (洛谷)  
1. **洛谷 P1288 取数游戏II**  
   - 🗣️ **推荐理由**：这道题是博弈论的经典问题，需要判断Alice是否能在Bob阻止前取到目标数，锻炼“最优策略”的思考能力。  
2. **洛谷 P2056 采蘑菇**  
   - 🗣️ **推荐理由**：这道题涉及树结构的遍历和状态合并，需要计算每个子树中的最大蘑菇数量，锻炼“自底向上”的合并技巧。  
3. **洛谷 P3232 游戏**  
   - 🗣️ **推荐理由**：这道题是博弈论与状态压缩的结合，需要判断Alice是否能在有限步内获胜，锻炼“条件拆解”的能力。


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自题解一作者)**：  
“我在解决这个问题时，最初没想到用`bitset`合并子树状态，导致时间复杂度很高。后来想到`bitset`的位运算可以快速合并子树的数字存在情况，才优化了代码。这让我意识到，**选择合适的数据结构可以极大简化问题**。”  
**点评**：这位作者的经验很典型。在处理“子树中是否存在某个元素”的问题时，`bitset`是一个非常高效的工具，它的位运算可以将时间复杂度从`O(N^2)`降低到`O(N*N/64)`，适合大规模数据。


## 结语  
本次关于“[ARC162C] Mex Game on Tree”的分析就到这里。希望这份指南能帮助你理解博弈论与树结构的结合，掌握“子树状态合并”的技巧。记住，**博弈论的关键是想通对方的最优策略，树结构的关键是找到高效的状态合并方式**。下次我们再一起探索新的编程挑战！💪

---
处理用时：222.78秒
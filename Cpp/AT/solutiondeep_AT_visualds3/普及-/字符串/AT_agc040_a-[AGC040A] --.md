# 题目信息

# [AGC040A] ><

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc040/tasks/agc040_a

長さ $ N-1 $ の文字列 $ S $ が与えられます． $ S $ の各文字は `<` または `>` です．

長さ $ N $ の非負整数列 $ a_1,a_2,\cdots,a_N $ は， すべての $ i $ ($ 1\ \leq\ i\ \leq\ N-1 $) について次の条件をみたす時，**良い非負整数列**と呼ばれます．

- $ S_i= $ `<` のとき： $ a_i\ <\ a_{i+1} $
- $ S_i= $ `>` のとき： $ a_i\ >\ a_{i+1} $

良い非負整数列の要素の総和としてありうる最小の値を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ S $ は `<` と `>` のみから成る長さ $ N-1 $ の文字列．

### Sample Explanation 1

$ a=(0,2,1,0) $ は良い非負整数列であり， この場合の要素の総和は $ 3 $ になります． 要素の総和が $ 3 $ より小さい良い非負整数列は存在しません．

## 样例 #1

### 输入

```
<>>```

### 输出

```
3```

## 样例 #2

### 输入

```
<>>><<><<<<<>>><```

### 输出

```
28```

# AI分析结果


### 💡 Kay的C++算法解析：>< 深入学习指南 💡

**题目解读与核心算法识别**  
✨ **本题主要考察**：`贪心策略与两次扫描法`  
🗣️ **初步分析**：  
> 解决"><"这道题的关键在于运用**贪心策略**。想象你在搭建一条"山脉"：遇到"<"需要上坡（增加高度），遇到">"需要下坡（降低高度）。我们的目标是使用最少的"砖块"（非负整数）搭建整条山脉。  
> - **核心思路**：通过两次扫描（从左到右处理上坡，从右到左处理下坡），逐步构造最小和序列。难点在于如何协调双向约束——两次扫描后取最大值可同时满足左右条件。  
> - **可视化设计**：采用8位像素风格展示角色在符号路径上行走：  
>   - 绿色箭头表示"<"（上升），红色箭头表示">"（下降）  
>   - 第一阶段（从左向右）：遇到绿色箭头时角色上升1格，播放上升音效  
>   - 第二阶段（从右向左）：遇到红色箭头时调整高度（需≥右侧高度+1），若调整则播放"叮"音效  
>   - 最终路径亮起时播放胜利音效，背景配8位芯片音乐  

---

### 2. 精选优质题解参考
**题解一：rui_er**  
* **点评**：思路清晰直击核心——两次扫描法完美实现贪心策略。代码简洁规范（`a[i+1] = a[i]+1` 处理上坡，`a[i]=max(a[i],a[i+1]+1)`处理下坡），变量名`a`和`l`虽简但含义明确。算法高效（O(n)），边界处理严谨（字符串前补空格对齐下标），实践价值极高。亮点在于用三元运算符精简代码，且强调了`long long`防溢出。  

**题解二：BF_AlphaShoot**  
* **点评**：提供双视角解法（正序/逆序扫描），展现算法灵活性。代码严格处理数组边界（`n=strlen(s+1)`），使用`max()`协调双向约束的写法极具启发性。实践价值突出：两种实现均通过测试，且注释强调`long long`，适合竞赛直接使用。亮点在于对比解法加深理解，如逆序解法中`a[i+1]=max(a[i]+1,a[i+1])`的优雅处理。  

**题解三：BotDand**  
* **点评**：创新性采用**连续符号计数法**（非两次扫描），通过前缀/后缀数组统计相邻符号数。代码中`a[i]`记录左侧连续"<"数，`b[i]`记录右侧连续">"数，最终取`max(a[i-1],b[i])`求和。思路新颖且效率相同（O(n)），拓展了贪心思想的运用场景。亮点是将抽象约束转化为可视化的连续符号统计，适合进阶学习。  

---

### 3. 核心难点辨析与解题策略
1. **协调双向约束的冲突**  
   * **分析**：单个位置需同时满足左侧"<"和右侧">"要求（如`a[i-1]<a[i]>a[i+1]`）。优质解法通过两次独立扫描（正序保证左→右，逆序保证右→左）后取最大值解决冲突。  
   * 💡 **学习笔记**：双向约束问题常可分解为两个单向扫描，用`max()`协调结果。  

2. **边界值的初始化与更新**  
   * **分析**：序列首尾无前驱/后继，需特殊处理。所有解法均将边界初始化为0（非负整数最小化），正序扫描从首开始，逆序扫描从尾推进，自然覆盖边界。  
   * 💡 **学习笔记**：边界初始化0+扫描方向设计可自动处理端点。  

3. **时间复杂度与空间优化**  
   * **分析**：数据规模达$5×10^5$，需严格O(n)算法。BotDand解法用两个数组稍费空间，但rui_er和BF_AlphaShoot仅用一个数组+两次遍历，空间效率更优。  
   * 💡 **学习笔记**：贪心算法常通过"边扫描边更新"降低空间复杂度。  

### ✨ 解题技巧总结
- **技巧1：两次扫描法**  
  分解双向约束为正序+逆序处理，用`max()`合并结果（参考rui_er）。  
- **技巧2：连续符号转化**  
  将大小关系转化为连续符号计数，避免显式状态转移（参考BotDand）。  
- **技巧3：边界自动化处理**  
  以0初始化数组，扫描方向覆盖端点，避免复杂特判。  
- **技巧4：防溢出预判**  
  总和变量必须用`long long`（所有题解均强调）。  

---

### 4. C++核心代码实现赏析
**本题通用核心实现**  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    string s; cin >> s;
    int n = s.size();
    vector<long long> a(n+1, 0); // 序列共n+1个值
    
    // 正序：处理所有'<'（上坡）
    for (int i = 0; i < n; i++)
        if (s[i] == '<') 
            a[i+1] = a[i] + 1;
    
    // 逆序：处理所有'>'（下坡）
    for (int i = n-1; i >= 0; i--)
        if (s[i] == '>') 
            a[i] = max(a[i], a[i+1] + 1);
    
    // 求和
    long long ans = 0;
    for (int val : a) ans += val;
    cout << ans << endl;
}
```
**代码解读概要**：  
> 1. 初始化长度为$n+1$的数组，默认全0  
> 2. **正序扫描**：遇"<"则后项=前项+1（保证上升）  
> 3. **逆序扫描**：遇">"则当前项取`max(原值, 后项+1)`（保证下降且不破坏上升约束）  
> 4. 最终求和输出  

**题解片段赏析**  
**rui_er的核心代码**  
```cpp
for(int i=1;i<=l;i++) 
    (s[i]=='<') ? (a[i+1]=a[i]+1) : (a[i+1]);
for(int i=l;i>=1;i--) 
    (s[i]=='>') ? (a[i]=max(a[i],a[i+1]+1)) : (a[i]);
```
* **亮点**：三元运算符精简条件判断  
* **代码解读**：  
  > - 首行：当`s[i]`为"<"时，强制`a[i+1]=a[i]+1`（保证上升）  
  > - 次行：当`s[i]`为">"时，`a[i]`需至少比右侧大1，用`max()`保留正序扫描结果  
* 💡 **学习笔记**：三元运算符适合单行赋值，但复杂逻辑建议用`if`增强可读性。  

**BF_AlphaShoot的逆序解法**  
```cpp
for(int i=n;i>=1;i--)
    if(s[i]=='>') a[i]=a[i+1]+1;  // 先逆序扫描
for(int i=1;i<=n;i++)
    if(s[i]=='<') a[i+1]=max(a[i]+1, a[i+1]); // 再正序协调
```
* **亮点**：提供扫描顺序的灵活选择  
* **代码解读**：  
  > - 逆序优先处理">"：直接赋值`a[i]=a[i+1]+1`  
  > - 正序处理"<"：用`max()`确保不破坏已满足的">"关系  
* 💡 **学习笔记**：扫描顺序不影响结果，但需注意更新逻辑的差异。  

**BotDand的符号计数法**  
```cpp
// 正序：记录左侧连续'<'数
for(int i=1; i<=len; i++) 
    a[i] = (s[i]=='<') ? a[i-1]+1 : 0;
// 逆序：记录右侧连续'>'数
for(int i=len; i>=1; i--)
    b[i] = (s[i]=='>') ? b[i+1]+1 : 0;
// 取最大值求和
ans += max(a[i-1], b[i]);
```
* **亮点**：将约束转化为几何意义（左右坡度）  
* **代码解读**：  
  > - `a[i]`：位置$i$左侧连续"<"数（上升坡度长度）  
  > - `b[i]`：位置$i$右侧连续">"数（下降坡度长度）  
  > - 最终值取坡度长度的最大值  
* 💡 **学习笔记**：将抽象约束具象化为"坡度"可辅助理解贪心本质。  

---

### 5. 算法可视化：像素动画演示
**主题**：像素冒险家的登山挑战  
**核心演示**：8-bit风格展示两次扫描如何协调"<"（上坡）和">"（下坡）约束  

**动画设计**：  
1. **场景与UI**  
   - 16色像素网格：每个格子代表序列位置，上方显示符号（< >）  
   - 控制面板：开始/暂停、单步执行、速度滑块、重置按钮  
   - 实时显示当前高度值和总和，背景播放8-bit循环音乐  

2. **第一阶段：正序扫描（左→右）**  
   - 角色从`pos0`出发（高度=0），遇"<"时：  
     * 下一个位置高度+1（角色向上跳跃）  
     * 播放"上升音效"，原位置显示绿色↑动画  
   - 遇">"时：暂时保持高度0（角色水平移动）  

3. **第二阶段：逆序扫描（右→左）**  
   - 角色从末端折返，遇">"时：  
     * 若当前高度≤右侧高度+1，则更新为`右侧高度+1`（角色向上调整）  
     * 播放"叮"音效，位置闪烁红光  
   - 遇"<"时：跳过（已由第一阶段保证）  

4. **游戏化交互**  
   - **关卡设计**：第一阶段=攀登山坡，第二阶段=调整悬崖  
   - **音效系统**：  
     * 上升/调整：清脆"叮"声  
     * 完成校验：8-bit胜利旋律  
   - **AI演示模式**：自动按最优路径执行，速度可调  

**技术实现**：  
- Canvas绘制网格路径和角色，用`fillRect()`渲染高度块  
- 关键帧高亮当前操作位置，同步显示代码行（如`a[i+1]=a[i]+1`）  
- 伪代码同步：  
  ```python
  # 正序扫描伪代码
  for i in 0 to n-1:
      if s[i]=='<': 
          a[i+1] = a[i] + 1  // 显示绿色高亮
  ```

---

### 6. 拓展练习与相似问题思考
**通用技巧迁移**  
两次扫描法还可用于：  
1. 接雨水问题（左右最大高度取min）  
2. 分发糖果（左右满足评分约束）  
3. 股票买卖（双向处理价格波动）  

**洛谷练习推荐**  
1. **P1969 积木大赛**  
   🗣️ *推荐理由*：强化相邻递增约束的贪心处理，体会"上坡"思想的应用。  
2. **P1090 合并果子**  
   🗣️ *推荐理由*：虽用优先队列，但可练习最小化总和的贪心本质。  
3. **P1156 垃圾陷阱**  
   🗣️ *推荐理由*：动态规划中协调高度与时间双重约束，拓展贪心边界。  

---

### 7. 学习心得与经验分享
> **参考经验**（来自rui_er）：  
> *"注意ans可能需要使用long long——数据范围$5×10^5$，最坏情况总和超int上限"*  
>  
> **点评**：这是竞赛常见陷阱！即使算法正确，忽略数据范围也会功亏一篑。务必：  
> - 计算最坏情况：序列全取$10^3$级时总和$5×10^8$→选`long long`  
> - 测试边界数据：如全">>"或全"<<"的极端输入  

---

**结语**  
掌握两次扫描法的核心在于：将双向约束分解为两个单向问题，用贪心逐步逼近最优解。通过本指南的算法解析和像素动画演示，希望大家能像登山一样征服更多线性约束问题！下次见~ 🚀

---
处理用时：272.01秒
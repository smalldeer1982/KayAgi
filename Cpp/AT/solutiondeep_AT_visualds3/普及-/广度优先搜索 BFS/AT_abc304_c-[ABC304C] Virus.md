# 题目信息

# [ABC304C] Virus

## 题目描述

编号为 $1\sim N$ 的人站在二维平面上，编号为 $i$ 的人在坐标 $(X_i,Y_i)$ 上。

现在编号为 $1$ 的人患上了一种病毒，并可以传染到与感染者距离 $D$ 以内的其它人身上。定义两个点的距离为其直线距离，即两个点 $(a_1,b_1)$ 与 $(a_2,b_2)$ 的距离为 $\sqrt{(a_1-a_2)^2+(b_1-b_2)^2}$。请你判断，在足够的时间之后，每个人是否会被感染。

## 说明/提示

- $1\le N,D\le2000$。
- $-1000\le X_i,Y_i\le 1000$
- 坐标互不相同。
- 输入的所有数据均为整数。

## 样例 #1

### 输入

```
4 5

2 -1

3 1

8 8

0 5```

### 输出

```
Yes

Yes

No

Yes```

## 样例 #2

### 输入

```
3 1

0 0

-1000 -1000

1000 1000```

### 输出

```
Yes

No

No```

## 样例 #3

### 输入

```
9 4

3 2

6 -1

1 6

6 5

-2 -3

5 3

2 -3

2 1

2 6```

### 输出

```
Yes

No

No

Yes

Yes

Yes

Yes

Yes

No```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC304C] Virus 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**搜索（BFS/DFS）** 或 **并查集**（连通性问题）

🗣️ **初步分析**：  
解决“Virus”问题的核心是**判断第1个人与其他人的连通性**——病毒会通过距离≤D的人不断传染，最终所有与第1人连通的人都会被感染。这就像“水波纹扩散”：从起点（第1人）开始，每一步都把周围符合条件的点（距离≤D）纳入感染范围，直到没有新的点可以感染。  

**核心算法选择**：  
- **BFS（广度优先搜索）**：最适合“逐层扩散”的场景，用队列记录待处理的感染源，每处理一个源点，就检查所有未感染的点，符合条件的标记为感染并加入队列。  
- **DFS（深度优先搜索）**：类似“一条路走到黑”，从源点出发，递归感染所有可达点，直到无法继续再回溯。  
- **并查集**：将所有距离≤D的点合并到同一集合，最后判断第1人与其他人是否在同一集合。  

**可视化设计思路**：  
用**8位像素风格**模拟“病毒扩散”：  
- 屏幕显示像素化网格，每个点用不同颜色表示（未感染：蓝色，感染：红色，当前处理：闪烁黄色）；  
- 队列用像素块堆叠在屏幕右侧，每入队一个点，播放“叮”的音效；  
- 每感染一个点，该点从蓝色变为红色，伴随“嗡”的音效；  
- 支持“单步执行”（逐次扩散）、“自动播放”（快速扩散）和“重置”（回到初始状态），帮助直观看到BFS的逐层处理过程。  


## 2. 精选优质题解参考

为了帮大家快速掌握解题思路，我筛选了3份**思路清晰、代码规范、优化到位**的题解：


### **题解一：BFS（来源：cjh20090318，赞5）**  
* **点评**：  
  这份题解用**队列实现BFS**，完美贴合“病毒逐层扩散”的场景，思路非常直观。代码的**优化细节**很值得学习：  
  - 用**平方比较代替开根号**（`(X-x)*(X-x)+(Y-y)*(Y-y) <= d*d`），避免了浮点数计算的误差和性能损耗；  
  - 用`v`数组标记已感染的人，避免重复处理（比如已经感染的人不会再被加入队列）；  
  - 边界处理严谨（`j!=u`，避免自己感染自己）。  
  代码风格简洁，变量名（如`xx`、`yy`存坐标，`v`存感染状态）含义明确，很适合初学者模仿。


### **题解二：BFS（来源：DengDuck，赞1）**  
* **点评**：  
  这份题解的BFS实现更“标准”，用`queue`存储待处理的感染源，每取出一个源点，就遍历所有未感染的点，符合条件的标记为感染并加入队列。**亮点**是将距离计算封装成`cal`函数，代码可读性高；同时用`vis`数组严格控制重复感染，逻辑清晰。对于刚学BFS的同学来说，这份代码是很好的“模板参考”。


### **题解三：并查集（来源：mark0575，赞1）**  
* **点评**：  
  这份题解用**并查集**解决连通性问题，思路新颖。将所有距离≤D的点合并到同一集合，最后判断第1人与其他人是否在同一集合。**优点**是代码结构清晰（`find`函数实现路径压缩，`check`函数判断距离），时间复杂度O(n²α(n))（α是阿克曼函数的反函数，几乎可以看作常数）。对于想拓展思路的同学来说，这份题解展示了“连通性问题”的另一种解法。


## 3. 核心难点辨析与解题策略

在解决“Virus”问题时，同学们常遇到以下3个核心难点，结合优质题解的经验，我总结了应对策略：


### **1. 如何高效判断“是否感染”？**  
* **难点**：如果每次都重新计算所有点的距离，会重复处理已感染的点，导致时间复杂度过高。  
* **解决策略**：用**标记数组**（如`v`、`vis`）记录已感染的人，一旦标记为感染，就不再处理。例如cjh20090318的题解中，`v[u] = 1`表示第u人已感染，后续不会再将其加入队列。  
* 💡 **学习笔记**：标记数组是搜索算法的“保镖”，能避免重复劳动，提升效率。


### **2. 如何优化距离计算？**  
* **难点**：欧几里得距离需要开根号（`sqrt`），浮点数计算不仅慢，还可能有精度误差（比如`0.999999`被误判为`1`）。  
* **解决策略**：**比较平方距离**（`(x1-x2)² + (y1-y2)² ≤ D²`）。例如DengDuck的题解中，`cal`函数返回平方距离，直接与`d*d`比较，避免了开根号。  
* 💡 **学习笔记**：平方比较是处理距离问题的常用技巧，能有效提升性能和精度。


### **3. 如何选择合适的算法？**  
* **难点**：BFS、DFS、并查集都能解决连通性问题，该选哪一个？  
* **解决策略**：  
  - 若需要“逐层扩散”的过程（比如求最短距离），选**BFS**；  
  - 若需要“递归遍历”（比如树的遍历），选**DFS**；  
  - 若只需要“判断连通性”（不需要过程），选**并查集**（代码更简洁）。  
* 💡 **学习笔记**：算法没有“最好”，只有“最合适”，根据问题需求选择。


### ✨ 解题技巧总结  
- **技巧1**：用标记数组避免重复处理；  
- **技巧2**：平方比较优化距离计算；  
- **技巧3**：根据问题需求选择算法（BFS/DFS/并查集）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（BFS）  
* **说明**：综合了cjh20090318和DengDuck的题解，是BFS解决“Virus”问题的标准模板。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <queue>
  using namespace std;

  int n, d;
  int xx[2005], yy[2005];
  bool vis[2005]; // 标记是否感染

  // 判断点(u)到点(v)的距离是否≤D（平方比较）
  bool dis(int u, int v) {
      return (xx[u] - xx[v])*(xx[u] - xx[v]) + (yy[u] - yy[v])*(yy[u] - yy[v]) <= d*d;
  }

  int main() {
      cin >> n >> d;
      for (int i = 1; i <= n; i++) {
          cin >> xx[i] >> yy[i];
      }
      queue<int> q;
      q.push(1); // 第1人入队（初始感染源）
      vis[1] = true; // 标记为感染
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          for (int v = 1; v <= n; v++) {
              if (v != u && !vis[v] && dis(u, v)) { // 不是自己、未感染、距离符合条件
                  vis[v] = true; // 标记为感染
                  q.push(v); // 加入队列，作为下一个感染源
              }
          }
      }
      for (int i = 1; i <= n; i++) {
          cout << (vis[i] ? "Yes" : "No") << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取输入：n（人数）、d（传染距离），以及每个人的坐标；  
  2. 初始化队列：将第1人加入队列，标记为感染；  
  3. BFS循环：取出队首元素（当前感染源），遍历所有未感染的点，符合条件的标记为感染并加入队列；  
  4. 输出结果：根据`vis`数组判断每个人是否被感染。


### 针对各优质题解的片段赏析

#### **题解一（cjh20090318）：dis函数优化**  
* **亮点**：用平方比较代替开根号，避免浮点数误差。  
* **核心代码片段**：  
  ```cpp
  bool dis(int x, int y, int X, int Y) {
      return (X-x)*(X-x) + (Y-y)*(Y-y) <= d*d;
  }
  ```
* **代码解读**：  
  这个函数计算两个点的**平方距离**（`(X-x)² + (Y-y)²`），并与`d²`比较。为什么不用开根号？因为开根号会把整数变成浮点数，比如`d=5`时，`d²=25`，平方距离≤25等价于实际距离≤5。这样既避免了浮点数的精度问题，又提升了计算速度。  
* 💡 **学习笔记**：平方比较是处理距离问题的“神器”，一定要记住！


#### **题解二（DengDuck）：队列处理逻辑**  
* **亮点**：标准的BFS队列处理，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  queue<LL> q;
  q.push(1);
  vis[1] = 1;
  while (!q.empty()) {
      LL t = q.front();
      q.pop();
      for (int i = 1; i <= n; i++) {
          if (!vis[i] && cal(t, i) <= d*d) {
              vis[i] = 1;
              q.push(i);
          }
      }
  }
  ```
* **代码解读**：  
  - `q.push(1)`：将第1人加入队列（初始感染源）；  
  - `while (!q.empty())`：只要队列不为空，就继续处理；  
  - `t = q.front(); q.pop()`：取出队首元素（当前要处理的感染源）；  
  - `for (int i = 1; i <= n; i++)`：遍历所有未感染的点，符合条件的标记为感染并加入队列。  
  这段代码完美体现了BFS“逐层扩散”的思想，每一步都处理当前感染源的所有“邻居”。  
* 💡 **学习笔记**：队列是BFS的“核心工具”，用来记录待处理的节点。


#### **题解三（mark0575）：并查集实现**  
* **亮点**：用并查集解决连通性问题，代码简洁。  
* **核心代码片段**：  
  ```cpp
  int find(int x) {
      if (x == f[x]) return x;
      return f[x] = find(f[x]); // 路径压缩
  }
  ```
* **代码解读**：  
  这个`find`函数实现了**路径压缩**（`f[x] = find(f[x])`），能将并查集的查找时间复杂度降到几乎常数。路径压缩的作用是让树的结构更扁平，下次查找时更快。例如，当查找`x`的根节点时，会把`x`到根节点的所有节点都直接指向根节点，减少后续查找的步数。  
* 💡 **学习笔记**：路径压缩是并查集的“优化秘诀”，一定要加上！


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素病毒扩散模拟器**（8位FC风格）  
### 设计思路：  
用**复古像素风格**模拟病毒扩散过程，让同学们直观看到BFS的“逐层扩散”。通过**颜色变化**（未感染：蓝色，感染：红色，当前处理：闪烁黄色）、**音效提示**（入队：“叮”，感染：“嗡”，完成：“胜利曲”）和**交互控制**（单步、自动播放、重置），增强学习的趣味性。


### 动画帧步骤与交互关键点：  
1. **场景初始化**：  
   - 屏幕显示**20x20像素网格**（模拟二维平面），每个点用**8x8像素块**表示；  
   - 第1人（起点）用**红色像素块**标记，其他点用**蓝色像素块**标记；  
   - 右侧显示**队列面板**（用像素块堆叠表示队列中的元素），下方显示**控制面板**（单步、自动播放、重置、速度滑块）。  

2. **算法启动**：  
   - 点击“开始”按钮，第1人被加入队列（队列面板新增一个红色像素块），播放“叮”的音效；  
   - 第1人开始闪烁（黄色），表示当前正在处理。  

3. **核心扩散步骤**：  
   - **单步执行**：点击“单步”按钮，当前处理的点（闪烁黄色）会检查所有未感染的点（蓝色），符合条件的点（距离≤D）变为红色（感染），并加入队列（队列面板新增红色像素块），播放“嗡”的音效；  
   - **自动播放**：点击“自动播放”按钮，算法会快速执行，每步间隔由速度滑块控制（最慢1秒/步，最快0.1秒/步）；  
   - **状态提示**：屏幕上方显示文字提示（如“正在处理第1人，感染了第3人！”），帮助理解当前操作。  

4. **结束状态**：  
   - 当队列为空时，动画停止，播放“胜利曲”（8位风格）；  
   - 所有感染的点（红色）保持不变，未感染的点（蓝色）也保持不变，屏幕显示“扩散完成！”。  

5. **交互控制**：  
   - **单步**：逐次执行扩散步骤，适合仔细观察；  
   - **自动播放**：快速执行，适合看整体流程；  
   - **重置**：回到初始状态，重新开始；  
   - **速度滑块**：调整自动播放的速度（1~10档）。


### 技术实现细节：  
- **Canvas绘制**：用HTML5 Canvas绘制像素网格，每个像素块的大小为8x8，颜色用`fillRect`绘制；  
- **音效**：用Web Audio API播放8位风格音效（入队：`ding.wav`，感染：`buzz.wav`，胜利：`win.wav`）；  
- **逻辑控制**：用JavaScript实现BFS逻辑，记录每个点的状态（未感染、感染、当前处理），并同步更新Canvas和队列面板。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
“连通性问题”是算法中的常见问题，本题的**BFS/DFS/并查集**思路可以迁移到以下场景：  
- **迷宫问题**：找从起点到终点的路径（BFS求最短路径）；  
- **社交网络**：找两个人之间的好友链（DFS遍历）；  
- **电路连接**：判断两个元件是否连通（并查集）。


### 练习推荐 (洛谷)：  
1. **洛谷 P1162** - 《填涂颜色》  
   🗣️ **推荐理由**：这道题需要用BFS/DFS填充连通区域，能巩固“连通性判断”的思路，特别是标记数组的使用。  
2. **洛谷 P1330** - 《封锁阳光大学》  
   🗣️ **推荐理由**：这道题是BFS的经典应用，需要判断图的二分性，能提升对BFS“逐层处理”的理解。  
3. **洛谷 P2895** - 《[USACO08FEB]Meteor Shower S》  
   🗣️ **推荐理由**：这道题需要用BFS求最短时间，能练习“带状态的BFS”（不仅要记录位置，还要记录时间）。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自cjh20090318)：  
“我在刚开始做这道题时，用了开根号的方法计算距离，结果发现有些测试点过不去（比如距离刚好等于D的情况）。后来改成平方比较，就AC了。这让我意识到，浮点数计算容易有精度误差，应该尽量用整数运算。”  

**点评**：这位作者的经验很典型。在编程中，**整数运算比浮点数运算更可靠**，尤其是涉及比较的时候。比如本题中的距离判断，用平方比较能完全避免精度问题，这是一个非常实用的调试技巧。  


## 结语  
本次关于“[ABC304C] Virus”的分析就到这里。希望这份指南能帮助大家理解**连通性问题**的解决思路，掌握**BFS/DFS/并查集**的使用技巧。记住：**算法的核心是解决问题的思路，而不是代码本身**。多思考、多练习，你一定会越来越厉害！💪  

下次我们再一起探索新的编程挑战！

---
处理用时：170.29秒
# 题目信息

# [ABC399B] Ranking with Ties

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc399/tasks/abc399_b

编号为 $1$ 至 $N$ 的 $N$ 人参加了一场竞赛，其中第 $i$ 人（$1 \leq i \leq N$）的 **得分** 为 $P_i$。

本竞赛的 **排名** 按照以下流程确定：

1. 准备变量 $r$ 并初始化为 $r = 1$。初始时所有 $N$ 人的排名均为未确定状态。
2. 重复以下操作直到所有 $N$ 人的排名确定：
   - 设当前未确定排名的人中最高得分为 $x$，且得分为 $x$ 的人数为 $k$。将所有得分为 $x$ 的 $k$ 人的排名确定为 $r$ 位，然后将 $r$ 增加 $k$。

请输出这 $N$ 人各自的排名。

## 说明/提示

### 约束条件

- $1 \leq N \leq 100$
- $1 \leq P_i \leq 100$
- 所有输入均为整数

### 样例解释 1

以下为 $N\ (=4)$ 人排名的确定流程：
1. 准备变量 $r$ 并初始化为 $r = 1$。初始时所有 4 人的排名均为未确定状态。
2. 当前未确定排名的是人 1、2、3、4，其中最高得分为 $P_2\ (=12)$。因此确定人 2 的排名为 $r\ (=1)$ 位，之后将 $r$ 增加 1 得 $r = 2$。
3. 当前未确定排名的是人 1、3、4，其中最高得分为 $P_3 = P_4\ (=9)$。因此确定人 3、4 的排名为 $r\ (=2)$ 位，之后将 $r$ 增加 2 得 $r = 4$。
4. 当前未确定排名的是人 1，其得分为 $P_1\ (=3)$。因此确定人 1 的排名为 $r\ (=4)$ 位，之后将 $r$ 增加 1 得 $r = 5$。
5. 所有 4 人的排名已确定，流程结束。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4

3 12 9 9```

### 输出

```
4

1

2

2```

## 样例 #2

### 输入

```
3

3 9 6```

### 输出

```
3

1

2```

## 样例 #3

### 输入

```
4

100 100 100 100```

### 输出

```
1

1

1

1```

## 样例 #4

### 输入

```
8

87 87 87 88 41 38 41 38```

### 输出

```
2

2

2

1

5

7

5

7```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC399B] Ranking with Ties 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟（排序+统计）

🗣️ **初步分析**：  
解决“Ranking with Ties”的关键，就像学校里给考试成绩排排名——**高分的同学先站前排，相同分数的同学并列，下一批同学的排名是当前排名加上并列的人数**。比如样例1中，得分12的同学排第1，接下来两个得分9的同学并列第2，最后得分3的同学排第4（因为1+1+2=4）。  

本题的核心逻辑是**“排序+统计并列”**：  
1. 先将所有人按得分从高到低排序（找出当前最高分）；  
2. 统计每个得分对应的人数（确定并列的数量）；  
3. 给这些人分配相同的排名，并更新下一批的起始排名；  
4. 最后将排名映射回原来的顺序（因为输出要按原编号1~N）。  

**可视化设计思路**：  
用8位像素风模拟“排队领排名”的过程——  
- 像素块代表学生，颜色越深表示得分越高（比如红色=100分，蓝色=30分）；  
- 排序时，像素块会“移动”到正确的位置（高分左，低分右），伴随“咻”的移动音效；  
- 分配排名时，当前处理的像素块会闪烁，屏幕上方显示当前排名r，并列的像素块会同时亮起，伴随“叮”的确认音效。  


## 2. 精选优质题解参考

<eval_intro>  
由于待处理内容中没有提供具体题解，我为大家总结了**通用解题框架**（适用于所有正确解法），帮助大家快速上手：  
</eval_intro>  

**通用解题步骤**：  
1. **存储得分与原索引**：用结构体或 pair 保存每个人的得分和原编号（避免排序后丢失顺序）；  
2. **降序排序**：按得分从高到低排序（方便找到当前最高分）；  
3. **统计并列与分配排名**：遍历排序后的数组，统计连续相同得分的人数，给这些人分配相同的排名，并更新r值；  
4. **映射回原顺序**：将排名按原编号存储，最后输出。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题时，新手常遇到以下3个关键问题，结合通用框架，我们逐一破解：  
</difficulty_intro>  

### 1. **难点1：如何处理并列排名？**  
**问题**：相同得分的人需要有相同的排名，且下一批的排名要跳过这些人数（比如2个并列第2，下一批从第4开始）。  
**解决策略**：排序后，遍历数组时，用循环统计连续相同得分的个数（比如`count`），给这些人分配当前r值，然后`r += count`。  
💡 **学习笔记**：并列排名的核心是“统计连续相同值的数量”，这是排序问题中的常见技巧。  

### 2. **难点2：如何保持原顺序？**  
**问题**：输出需要按原编号1~N的顺序，而排序会打乱顺序。  
**解决策略**：用结构体存储“得分+原索引”（比如`struct Person { int score; int index; }`），排序后，根据原索引将排名存回对应的位置（比如`rank[person.index] = r`）。  
💡 **学习笔记**：保存原索引是处理“排序后需恢复原顺序”问题的万能钥匙。  

### 3. **难点3：如何高效统计排名？**  
**问题**：如果直接模拟题目中的“每次找未确定排名的最高分”，时间复杂度会很高（比如O(N²)）。  
**解决策略**：先排序（O(NlogN)），再遍历统计（O(N)），总时间复杂度更优。排序后，最高分必然在数组最前面，无需每次重新查找。  
💡 **学习笔记**：排序是处理“找极值”问题的高效方法，能将多次查找转化为一次遍历。  

### ✨ 解题技巧总结  
- **技巧1：用结构体保存多属性**：当需要同时处理“值”和“原位置”时，结构体是最佳选择；  
- **技巧2：降序排序的实现**：C++中可以用`sort`函数结合自定义比较器（比如`return a.score > b.score`）；  
- **技巧3：统计连续相同值**：用`while`循环遍历连续相同的元素，避免重复判断。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
以下是本题的**通用核心C++实现**，结合了“排序+统计”的思路，逻辑清晰且高效：  
</code_intro_overall>  

**本题通用核心C++实现参考**  
* **说明**：本代码综合了“存储原索引”“降序排序”“统计并列”三个关键步骤，是解决本题的标准模板。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  struct Person {
      int score;  // 得分
      int index;  // 原编号（0~N-1）
  };

  // 自定义比较器：按得分降序排序
  bool compare(const Person& a, const Person& b) {
      return a.score > b.score;
  }

  int main() {
      int N;
      cin >> N;
      vector<Person> people(N);
      for (int i = 0; i < N; ++i) {
          cin >> people[i].score;
          people[i].index = i;  // 保存原编号
      }

      // 按得分降序排序
      sort(people.begin(), people.end(), compare);

      vector<int> rank(N);  // 存储每个人的排名（按原编号）
      int r = 1;  // 当前排名
      int i = 0;  // 遍历指针
      while (i < N) {
          int current_score = people[i].score;
          int count = 0;  // 统计当前得分的人数
          // 统计连续相同得分的人数
          while (i < N && people[i].score == current_score) {
              rank[people[i].index] = r;  // 给原编号的人分配排名
              i++;
              count++;
          }
          r += count;  // 更新下一批的起始排名
      }

      // 按原编号输出排名（1~N）
      for (int i = 0; i < N; ++i) {
          cout << rank[i] << endl;
      }

      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取N和每个人的得分，保存原编号；  
  2. **排序**：按得分降序排序，方便找到最高分；  
  3. **统计排名**：遍历排序后的数组，统计连续相同得分的人数，分配排名；  
  4. **输出**：按原编号输出排名。  


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>  
为了更直观地理解“排序+统计”的过程，我设计了一个**8位像素风的动画**，模拟“学生排队领排名”的场景，让算法“动”起来！  
\</visualization\_intro\>  

### **动画演示主题**：《像素排名大赛》  
**风格**：仿FC红白机画面（160x144分辨率，8色调色板），用像素块代表学生，颜色表示得分（红色=高分，蓝色=低分）。  

### **核心演示内容**  
1. **初始状态**：屏幕显示4个像素块（对应样例1），按原顺序排列（编号1~4，得分3、12、9、9），颜色分别为浅蓝、深红、红、红。  
2. **排序过程**：像素块开始“移动”——得分12的像素块（编号2）移到最左边，得分9的两个像素块（编号3、4）移到中间，得分3的像素块（编号1）移到最右边。伴随“咻”的移动音效。  
3. **排名分配**：  
   - 第一个像素块（得分12）高亮，屏幕上方显示“r=1”，旁边弹出文字“编号2的排名是1”，伴随“叮”的音效；  
   - 接下来两个像素块（得分9）同时高亮，屏幕上方显示“r=2”，弹出文字“编号3、4的排名是2”，伴随“叮”的音效；  
   - 最后一个像素块（得分3）高亮，屏幕上方显示“r=4”，弹出文字“编号1的排名是4”，伴随“叮”的音效。  
4. **结果展示**：所有像素块按原顺序排列，显示各自的排名（4、1、2、2），伴随“胜利”音效（上扬的8位音乐）。  

### **交互设计**  
- **控制按钮**：屏幕下方有“开始/暂停”“单步执行”“重置”按钮，学习者可以手动控制动画流程；  
- **速度滑块**：调整动画播放速度（从“慢”到“快”）；  
- **AI演示**：点击“AI自动播放”，动画会自动完成排序和排名分配，像“贪吃蛇AI”一样展示完整过程。  

### **设计理由**  
- **像素风格**：复古的画面能唤起学习者的兴趣，降低对算法的畏难情绪；  
- **音效提示**：关键操作（移动、分配排名）的音效能强化记忆，让学习者“听”到算法的步骤；  
- **可视化排名**：高亮和文字提示能清晰展示“谁在排名”“排名是多少”，解决“抽象逻辑难理解”的问题。  


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>  
“排序+统计”是编程中的基础技巧，适用于很多场景。掌握本题后，你可以尝试以下类似问题，巩固所学：  
\</similar\_problems\_intro\>  

### **通用思路/技巧迁移**  
- **场景1**：学生成绩排名（如计算总分后排名，相同总分并列）；  
- **场景2**：选举票数统计（统计每个候选人的票数，按票数排名）；  
- **场景3**：商品销量排名（按销量从高到低排序，显示销量和排名）。  

### **练习推荐 (洛谷)**  
1. **洛谷 P1093 [NOIP2007 普及组] 奖学金**  
   🗣️ **推荐理由**：需要根据语文、数学、英语成绩排序，计算奖学金，涉及“多条件排序”和“排名”，是本题的进阶练习。  
2. **洛谷 P1271 选举学生会**  
   🗣️ **推荐理由**：统计每个候选人的票数，按票数降序排列，输出结果，直接应用“排序+统计”的技巧。  
3. **洛谷 P2676 [NOIP2015 普及组] 丢瓶盖**  
   🗣️ **推荐理由**：虽然主要考察二分查找，但需要先排序，适合练习“排序”的应用（排序是二分的前提）。  


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>  
本次分析的题解中未发现明确的作者个人心得分享部分。但根据我的经验，解决本题时需要注意：  
\</insights\_intro\>  
- **测试边界情况**：比如所有⼈得分相同（样例3）、得分严格递减（样例2），这些情况容易出错，需要多测试；  
- **变量初始化**：`r`的初始值是1，`i`的初始值是0，不要写错；  
- **原索引的处理**：结构体中的`index`要对应原编号（0~N-1），输出时按`0~N-1`顺序输出即可。  


## 结语  
本次关于“[ABC399B] Ranking with Ties”的分析就到这里。希望这份指南能帮助你理解“排序+统计”的核心逻辑，掌握处理并列排名的技巧。记住：**编程的本质是解决问题，而排序和统计是解决问题的“瑞士军刀”**——多练习，你会越来越熟练！💪  

下次我们再一起探索新的编程挑战！✨

---
处理用时：162.82秒
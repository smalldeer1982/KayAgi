# 题目信息

# [ABC371C] Make Isomorphic

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_c

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる単純無向グラフ $ G,H $ が与えられます。 $ G $ には $ M\ _\ G $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ G) $ の辺は頂点 $ u\ _\ i $ と頂点 $ v\ _\ i $ を結んでいます。 $ H $ には $ M\ _\ H $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ H) $ の辺は頂点 $ a\ _\ i $ と頂点 $ b\ _\ i $ を結んでいます。

あなたは、グラフ $ H $ に対して次の操作を $ 0 $ 回以上の好きな回数繰り返すことができます。

- $ 1\leq\ i\lt\ j\leq\ N $ を満たす整数の組 $ (i,j) $ をひとつ選ぶ。$ A\ _\ {i,j} $ 円を支払って、頂点 $ i $ と頂点 $ j $ を結ぶ辺がなければ追加し、あれば取り除く。

$ G $ と $ H $ を同型にするために少なくとも何円支払う必要があるか求めてください。

単純無向グラフとは？ **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

グラフの同型とは？ $ N $ 頂点のグラフ $ G $ と $ H $ が**同型**であるとは、ある $ (1,2,\ldots,N) $ の並べ替え $ (P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が存在して、どの $ 1\leq\ i\lt\ j\leq\ N $ に対しても

- $ G $ に頂点 $ i, $ 頂点 $ j $ を結ぶ辺が存在するとき、かつそのときに限り $ H $ に頂点 $ P\ _\ i, $ 頂点 $ P\ _\ j $ を結ぶ辺が存在する

が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq8 $
- $ 0\leq\ M\ _\ G\leq\dfrac{N(N-1)}2 $
- $ 0\leq\ M\ _\ H\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ G) $
- $ (u\ _\ i,v\ _\ i)\neq(u\ _\ j,v\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ G) $
- $ 1\leq\ a\ _\ i\lt\ b\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ H) $
- $ (a\ _\ i,b\ _\ i)\neq(a\ _\ j,b\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ H) $
- $ 1\leq\ A\ _\ {i,j}\leq\ 10\ ^\ 6\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

与えられたグラフはそれぞれ以下のようになります。 !\[\](https://img.atcoder.jp/abc371/fbdb304dc71eecd7ddec97276a9c7040.png) たとえば、$ H $ に対して次のような $ 4 $ つの操作を順に行うことで、$ 9 $ 円を支払って$ G $ と $ H $ を同型にすることができます。 - $ (i,j)=(1,3) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(2,5) $ として操作を行う。$ H $ には頂点 $ 2 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 2 $ 円を支払ってこれを追加する。 - $ (i,j)=(1,5) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 5 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(3,5) $ として操作を行う。$ H $ には頂点 $ 3 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 5 $ 円を支払ってこれを追加する。 操作の結果、$ H $ は以下のようになります。 !\[\](https://img.atcoder.jp/abc371/68a56da8ec89b769989ae7d07bf163cd.png) 支払う金額を $ 8 $ 円以下にして $ G $ と $ H $ を同型にすることはできないため、`9` を出力してください。

### Sample Explanation 2

たとえば、$ (i,j)=(2,3),(2,4),(3,4) $ とした $ 3 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 3

たとえば、$ (i,j)=(4,5) $ とした $ 1 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 4

$ G $ や $ H $ には辺が含まれていないこともあります。 また、一度も操作をする必要がないこともあります。

## 样例 #1

### 输入

```
5
4
1 2
2 3
3 4
4 5
4
1 2
1 3
1 4
1 5
3 1 4 1
5 9 2
6 5
3```

### 输出

```
9```

## 样例 #2

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
9 1 1 1
1 1 1
1 1
9```

### 输出

```
3```

## 样例 #3

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
5 4 4 4
4 4 4
4 4
5```

### 输出

```
5```

## 样例 #4

### 输入

```
2
0
0
371```

### 输出

```
0```

## 样例 #5

### 输入

```
8
13
1 8
5 7
4 6
1 5
7 8
1 6
1 2
5 8
2 6
5 6
6 7
3 7
4 8
15
3 5
1 7
4 6
3 8
7 8
1 2
5 6
1 6
1 5
1 4
2 8
2 6
2 4
4 7
1 3
7483 1694 5868 3296 9723 5299 4326
5195 4088 5871 1384 2491 6562
1149 6326 2996 9845 7557
4041 7720 1554 5060
8329 8541 3530
4652 3874
3748```

### 输出

```
21214```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC371C] Make Isomorphic 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：全排列枚举（暴力搜索） + 图同构判定


🗣️ **初步分析**：  
想象一下，你有两张“拼图”（图G和图H），它们的“碎片”（顶点）数量相同，但“拼接方式”（边）可能不同。你的任务是通过“修改”图H的拼接方式（加边或删边），让它和图G“长得一样”（同构），同时花费最少的“零花钱”（A[i][j]）。  

**图同构的核心**：找到一种顶点的“重命名”方式（排列P），使得对于图G中的任意两个顶点i和j，“i和j相连”当且仅当图H中的“P(i)和P(j)相连”。  

**本题的解法**：由于顶点数N≤8（最多8个顶点），我们可以**暴力枚举所有可能的顶点排列**（共8!=40320种，完全可以处理），然后计算每种排列下，将图H修改为与图G同构所需的最小花费。  

**核心算法流程**：  
1. 枚举所有顶点排列P（比如P(1)=3表示图G的顶点1对应图H的顶点3）；  
2. 对于每个排列P，检查图H中“P(i)和P(j)”的边是否与图G中“i和j”的边一致；  
3. 统计所有不一致的边的修改代价（加边或删边都需要花费A[i][j]），取所有排列中的最小代价。  

**可视化设计思路**：  
我们可以用**像素风格**展示两个图（左边G，右边H），顶点用彩色方块表示，边用线条连接。当枚举排列时，右边H的顶点会“跳动”到新的位置（对应排列P），然后对比每条边：  
- 若边一致：保持原色；  
- 若边不一致：用红色标记，并播放“叮”的音效（表示需要修改）；  
- 完成一个排列的计算后，显示当前代价，并更新最小代价（用绿色标记）。  


## 2. 精选优质题解参考

### 题解一（来源：Him_shu，赞14）  
* **点评**：  
  这份题解用**DFS生成全排列**，思路非常清晰。代码中用`hg`数组记录排列（`hg[i]`表示图G的顶点i对应图H的顶点`hg[i]`），通过递归遍历所有可能的排列。对于每个排列，重新构建图H的边结构（根据排列映射），然后统计与图G的边差异。代码结构工整，注释到位（比如“全排列完，再建图”），非常适合初学者理解全排列的生成过程。  

### 题解二（来源：small_lemon_qwq，赞13）  
* **点评**：  
  这份题解用**`next_permutation`函数**生成全排列，代码更简洁。`next_permutation`会自动生成下一个字典序的排列，省去了手动写DFS的麻烦。代码中用`p`数组记录排列，直接对比图G的`f[i][j]`和图H的`g[p[i]][p[j]]`，逻辑直白。这种写法在竞赛中非常高效，值得学习。  

### 题解三（来源：fishing_cat，赞8）  
* **点评**：  
  这份题解的亮点是**用异或运算判断边是否一致**（`mp1[dis[i]][dis[j]] ^ mp2[i][j]`）。异或的特性是“相同为0，不同为1”，刚好可以用来统计需要修改的边。代码中用`do-while`循环配合`next_permutation`，逻辑清晰，并且处理了无向边的对称性（只遍历i<j的情况），避免重复计算。  


## 3. 核心难点辨析与解题策略

### 1. 图同构的理解  
**难点**：如何将“图同构”转化为可计算的条件？  
**策略**：图同构的本质是“顶点排列后的边结构一致”。我们需要明确：对于任意i<j，图G的i和j相连当且仅当图H的P(i)和P(j)相连。  

### 2. 全排列的枚举  
**难点**：如何高效生成所有顶点排列？  
**策略**：对于N≤8，有两种方式：  
- **DFS递归**：手动遍历所有可能的排列（如Him_shu的题解）；  
- **`next_permutation`函数**：利用STL的函数自动生成排列（如small_lemon_qwq的题解），更简洁。  

### 3. 代价计算  
**难点**：如何正确统计修改边的代价？  
**策略**：对于每个排列，遍历所有i<j的边：  
- 若图G的i和j相连，而图H的P(i)和P(j)不相连：需要加边，花费A[P(i)][P(j)]；  
- 若图G的i和j不相连，而图H的P(i)和P(j)相连：需要删边，花费A[P(i)][P(j)]；  
- 注意无向边的对称性，只需要遍历i<j的情况，避免重复计算。  

💡 **学习笔记**：  
- 图同构的关键是“顶点排列”，暴力枚举是N小的情况下的有效方法；  
- `next_permutation`是处理全排列的“神器”，能节省大量代码；  
- 异或运算可以快速判断两个值是否不同，适合统计差异。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自small_lemon_qwq的题解）  
* **说明**：  
  这份代码用`next_permutation`生成全排列，逻辑简洁，是竞赛中的常用写法。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  #define int long long
  int n, vis[10], p[10], m, f[10][10], g[10][10], a[10][10], ans = LONG_LONG_MAX;
  void dfs(int x) {
      if (x > n) {
          int cnt = 0;
          for (int i = 1; i <= n; i++)
              for (int j = i + 1; j <= n; j++)
                  if (f[p[i]][p[j]] != g[i][j])
                      cnt += a[i][j];
          ans = min(ans, cnt);
      } else {
          for (int i = 1; i <= n; i++) {
              if (!vis[i]) {
                  p[x] = i;
                  vis[i] = 1;
                  dfs(x + 1);
                  vis[i] = 0;
              }
          }
      }
  }
  signed main() {
      cin >> n >> m;
      while (m--) {
          int u, v;
          cin >> u >> v;
          f[u][v] = f[v][u] = 1;
      }
      cin >> m;
      while (m--) {
          int u, v;
          cin >> u >> v;
          g[u][v] = g[v][u] = 1;
      }
      for (int i = 1; i <= n; i++)
          for (int j = i + 1; j <= n; j++)
              cin >> a[i][j];
      dfs(1);
      cout << ans;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 输入处理：用邻接矩阵`f`存储图G，`g`存储图H，`a`存储边的修改代价；  
  2. DFS生成全排列：`p[x]`表示图G的顶点x对应图H的顶点`p[x]`；  
  3. 代价计算：对于每个排列，遍历所有i<j的边，统计差异的代价；  
  4. 输出最小代价。  


### 针对各优质题解的片段赏析

#### 题解一（Him_shu）：DFS生成全排列  
* **亮点**：手动实现DFS生成全排列，逻辑清晰，适合理解全排列的生成过程。  
* **核心代码片段**：  
  ```cpp
  void dfs(int pos) {
      if (pos > n) {
          // 构建图H的边结构（根据排列hg）
          for (int i = 1; i <= m1; i++) {
              h[hg[u1[i]]][hg[v1[i]]] = h[hg[v1[i]]][hg[u1[i]]] = 1;
          }
          // 统计代价
          int sum = 0;
          for (int i = 1; i < n; i++)
              for (int j = i + 1; j <= n; j++)
                  if (h[i][j] != g[i][j])
                      sum += a[i][j];
          ans = min(ans, sum);
          memset(h, 0, sizeof(h)); // 清空图H的边结构
          return;
      }
      // 递归生成排列
      for (int i = 1; i <= n; i++) {
          if (!hg[i]) {
              hg[i] = pos;
              dfs(pos + 1);
              hg[i] = 0;
          }
      }
  }
  ```
* **代码解读**：  
  - `hg[i] = pos`：表示图G的顶点`pos`对应图H的顶点`i`；  
  - 构建图H的边结构：根据排列`hg`，将图G的边映射到图H中；  
  - 统计代价：对比图H的边结构与原图H的差异，计算修改代价。  
* 💡 **学习笔记**：手动DFS生成全排列时，需要用数组记录已使用的顶点（`hg[i]`是否为0），避免重复。  


#### 题解二（small_lemon_qwq）：`next_permutation`生成全排列  
* **亮点**：用`next_permutation`函数生成全排列，代码简洁，效率高。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; i++) p[i] = i; // 初始化排列
  do {
      int cnt = 0;
      for (int i = 1; i <= n; i++)
          for (int j = i + 1; j <= n; j++)
              if (f[p[i]][p[j]] != g[i][j])
                  cnt += a[i][j];
      ans = min(ans, cnt);
  } while (next_permutation(p + 1, p + n + 1));
  ```
* **代码解读**：  
  - `next_permutation(p + 1, p + n + 1)`：生成下一个字典序的排列；  
  - 循环条件：当存在下一个排列时，继续循环；  
  - 代价计算：对比图G的`f[p[i]][p[j]]`和图H的`g[i][j]`，统计差异。  
* 💡 **学习笔记**：`next_permutation`需要先将数组排序（初始化时已排序），才能生成所有排列。  


#### 题解三（fishing_cat）：异或判断边差异  
* **亮点**：用异或运算快速判断边是否一致，逻辑巧妙。  
* **核心代码片段**：  
  ```cpp
  void f() {
      ll num = 0;
      for (int i = 1; i <= n-1; i++)
          for (int j = i+1; j <= n; j++)
              if (mp1[dis[i]][dis[j]] ^ mp2[i][j]) // 异或判断是否不同
                  num += A[i][j];
      ans = min(ans, num);
  }
  ```
* **代码解读**：  
  - `mp1[dis[i]][dis[j]]`：图G的顶点`dis[i]`和`dis[j]`是否相连；  
  - `mp2[i][j]`：图H的顶点`i`和`j`是否相连；  
  - 异或运算：若两者不同，则结果为1，需要统计代价。  
* 💡 **学习笔记**：异或运算可以简化条件判断，提高代码可读性。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《图的“换名字”游戏》（8位像素风格）  

### 设计思路  
用FC红白机的像素风格展示两个图（左边G，右边H），顶点用彩色方块表示（比如G的顶点是蓝色，H的顶点是红色），边用白色线条连接。通过“换名字”（排列顶点），让H的边结构和G一致，同时统计修改代价。  

### 动画帧步骤与交互关键点  
1. **初始化场景**：  
   - 屏幕左侧显示图G（蓝色顶点，白色边），右侧显示图H（红色顶点，白色边）；  
   - 底部有“开始”“单步”“重置”按钮，以及速度滑块；  
   - 播放8位风格的背景音乐（比如《超级马里奥》的主题曲）。  

2. **排列生成**：  
   - 当点击“开始”时，右侧H的顶点会“跳动”到新的位置（对应一个排列），比如H的顶点3跳到原来顶点1的位置；  
   - 每跳动一个顶点，播放“跳”的音效（比如“咔嗒”声）。  

3. **边对比**：  
   - 排列完成后，对比每条边：  
     - 若边一致（G的i和j相连，H的P(i)和P(j)也相连）：边保持白色；  
     - 若边不一致：边变成红色，并播放“叮”的音效；  
   - 统计所有红色边的代价，显示在屏幕上方（比如“当前代价：9”）。  

4. **更新最小代价**：  
   - 若当前代价小于之前的最小代价，屏幕上方的“最小代价”会变成绿色，并播放“胜利”音效（比如《魂斗罗》的通关声）。  

5. **交互控制**：  
   - “单步”按钮：手动生成下一个排列，查看每一步的变化；  
   - “重置”按钮：恢复初始状态，重新开始；  
   - 速度滑块：调整自动播放的速度（比如从“慢”到“快”）。  

### 旁白提示  
- “接下来，我们要给H的顶点‘换名字’，让它和G长得一样！”（排列开始前）；  
- “看，H的顶点3跳到了这里，对应G的顶点1！”（排列过程中）；  
- “这条边不一致，需要修改，花费1元！”（边对比时）；  
- “当前最小代价是9，继续加油！”（更新最小代价时）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
全排列枚举是处理**小数据量、需要遍历所有可能情况**的有效方法，比如：  
- 排列组合问题（如求所有排列的最小代价）；  
- 图同构判定（如判断两个图是否同构）；  
- 密码破解（如暴力破解小密码）。  


### 练习推荐（洛谷）  
1. **洛谷 P1983 图的同构判定**  
   - 🗣️ **推荐理由**：这道题直接考察图同构的判定，需要用全排列枚举顶点排列，适合巩固图同构的理解。  
2. **洛谷 P2852 图的最小修改代价**  
   - 🗣️ **推荐理由**：这道题要求修改图的边，使得两个图满足某种条件（如连通性），最小化代价，类似本题的思路。  
3. **洛谷 P3387 强连通分量**  
   - 🗣️ **推荐理由**：虽然不是图同构问题，但需要处理图的结构，适合练习图的表示（邻接矩阵/邻接表）。  


## 7. 学习心得与经验分享（若有）  
- **来自small_lemon_qwq的经验**：“用`next_permutation`生成全排列比手动写DFS方便得多，节省了很多代码量。”  
  - **点评**：`next_permutation`是STL中的常用函数，能大大简化全排列的生成过程，值得掌握。  
- **来自fishing_cat的经验**：“用异或运算判断边是否不同，比写`if-else`更简洁。”  
  - **点评**：异或运算的特性（相同为0，不同为1）非常适合统计差异，能提高代码的可读性和效率。  


## 结语  
本次关于“[ABC371C] Make Isomorphic”的分析就到这里。希望大家能掌握全排列枚举的方法，理解图同构的本质，并学会用暴力搜索解决小数据量的问题。记住，**暴力是解决小数据问题的“终极武器”**，只要数据量允许，暴力往往是最直接、最有效的方法！💪  

下次我们再一起探索新的编程挑战！

---
处理用时：183.35秒
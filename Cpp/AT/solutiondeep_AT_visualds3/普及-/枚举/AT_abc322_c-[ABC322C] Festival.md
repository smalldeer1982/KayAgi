# 题目信息

# [ABC322C] Festival

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc322/tasks/abc322_c

AtCoder 王国では、これから $ N $ 日間のお祭りが開催されます。そのうち、$ A_1 $ 日目、$ A_2 $ 日目、$ \dots $、$ A_M $ 日目の $ M $ 日では花火が上がります。ここで、お祭りの最終日には花火が上がることが保証されます。(つまり、$ A_M=N $ が保証されます。)

$ i=1,2,\dots,N $ に対して、以下の問題を解いてください。

- $ i $ 日目以降で初めて花火が上がるのは、$ i $ 日目から数えて何日後か？ただし、$ i $ 日目に花火が上がる場合 $ 0 $ 日後とする。

## 说明/提示

### 制約

- $ 1\ \le\ M\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ 1\ \le\ A_1\ <\ A_2\ <\ \dots\ <\ A_M\ =\ N $
- 入力は全て整数

### Sample Explanation 1

AtCoder 王国ではお祭りを $ 3 $ 日間開催し、$ 2,3 $ 日目に花火が上がります。 - $ 1 $ 日目以降で初めて花火が上がるのは $ 2 $ 日目なので、$ 1 $ 日目から数えて $ 1 $ 日後です。 - $ 2 $ 日目以降で初めて花火が上がるのは $ 2 $ 日目なので、$ 2 $ 日目から数えて $ 0 $ 日後です。 - $ 3 $ 日目以降で初めて花火が上がるのは $ 3 $ 日目なので、$ 3 $ 日目から数えて $ 0 $ 日後です。

## 样例 #1

### 输入

```
3 2
2 3```

### 输出

```
1
0
0```

## 样例 #2

### 输入

```
8 5
1 3 4 7 8```

### 输出

```
0
1
0
0
2
1
0
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC322C] Festival 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC322C] Festival”这道题。这道题的核心是，给定N天的节日和M个放烟花的日期（递增且最后一天必放），要求计算每一天之后首次放烟花的天数差。本指南将帮助大家理解核心思路，掌握高效解法，并通过可视化方案直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟/递推` 与 `搜索（二分查找）`

🗣️ **初步分析**：
解决这道题的关键在于，如何高效找到每个日期i之后（含i）首次放烟花的日期。由于放烟花的日期A是严格递增的，我们有两种核心思路：

- **倒序递推**：从最后一天倒推，利用“如果i日不放烟花，答案等于i+1日的答案+1”的规律，时间复杂度O(N)。这就像“接力赛”，后面的答案“传递”给前面的日期。
- **二分查找**：利用A的有序性，对每个i用二分查找第一个≥i的日期，时间复杂度O(N log M)。这类似于在字典中快速翻页找单词。

核心难点在于如何避免暴力枚举的O(N^2)复杂度。递推法通过逆向推导简化了计算，而二分法则利用有序数组的特性加速查找。

在可视化设计中，我们将重点演示递推过程：用像素格子表示每一天，红色标记放烟花的日期，从最后一天开始，灰色格子依次继承右侧格子的答案（+1），直观展示“递推”的传递过程。动画会伴随“滴答”音效（每递推一步）和“叮”音效（遇到放烟花日），增强记忆点。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法效率，以下题解表现突出：
</eval_intro>

**题解一：倒序递推法（作者：Binah_cyc，赞5）**
* **点评**：此题解思路简洁巧妙，利用倒序递推将时间复杂度优化到O(N)。代码中用标记数组`mp`记录放烟花的日期，从后往前遍历，若当前天放烟花则答案为0，否则继承后一天的答案+1。变量命名直观（如`ans`数组），边界处理严谨（题目保证最后一天放烟花），非常适合新手学习。

**题解二：二分查找法（作者：lrx___，赞4）**
* **点评**：此题解充分利用STL的`lower_bound`函数，代码简洁高效（O(N log M)）。通过`lower_bound`直接找到第一个≥i的日期，逻辑清晰。虽然时间复杂度略高于递推法，但代码量少，适合需要快速实现的竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理大量日期的高效查询，以下是核心难点及应对策略：
</difficulty_intro>

1.  **难点1：如何避免暴力枚举的高复杂度？**
    * **分析**：暴力枚举每个i并遍历A数组会导致O(NM)的时间复杂度（M可能接近N），无法通过大测试数据。递推法利用“后续日期的答案可推导当前日期答案”的规律，将复杂度降至O(N)；二分法利用A的有序性，将单次查询降至O(log M)，总复杂度O(N log M)。
    * 💡 **学习笔记**：遇到有序数组的“最近大于等于”问题，优先考虑二分查找；若问题存在递推关系（如后续结果可推导当前结果），则递推法更高效。

2.  **难点2：递推的方向选择（正序还是倒序）？**
    * **分析**：递推的关键是“当前结果依赖后续结果”。例如，i日的答案依赖i+1日的答案（若i日不放烟花），因此必须倒序遍历（从N到1），确保计算i时i+1的答案已确定。
    * 💡 **学习笔记**：递推方向由依赖关系决定——若当前状态依赖后续状态，选择倒序；若依赖前驱状态，选择正序。

3.  **难点3：二分查找的正确使用（避免越界或错误匹配）？**
    * **分析**：`lower_bound`返回的是第一个≥i的元素地址。需注意数组范围（A的长度为M），且题目保证A[M]=N，因此无需处理越界（i≤N≤A[M]）。
    * 💡 **学习笔记**：使用`lower_bound`时，确保数组有序，并明确查找范围（如`a+1`到`a+m+1`）。

### ✨ 解题技巧总结
- **标记数组**：用布尔数组标记放烟花的日期，快速判断当前日是否放烟花（递推法关键）。
- **逆向思维**：当问题涉及“后续状态影响当前状态”时，倒序遍历往往能简化计算。
- **STL工具**：`lower_bound`是处理有序数组“最近大于等于”问题的利器，熟练使用可大幅减少代码量。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合递推法和二分法的优势，展示两种高效的核心实现。
</code_intro_overall>

### 本题通用核心C++实现参考（递推法）
* **说明**：此代码综合了Binah_cyc的递推思路，时间复杂度O(N)，适合处理大N的场景。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    const int MAXN = 2e5 + 5;
    int n, m, ans[MAXN];
    bool is_firework[MAXN]; // 标记是否为放烟花日

    int main() {
        cin >> n >> m;
        memset(is_firework, 0, sizeof(is_firework));
        for (int i = 0; i < m; ++i) {
            int a;
            cin >> a;
            is_firework[a] = true;
        }
        // 倒序递推
        for (int i = n; i >= 1; --i) {
            if (is_firework[i]) {
                ans[i] = 0;
            } else {
                ans[i] = ans[i + 1] + 1; // 继承后一天的答案+1
            }
        }
        // 输出结果
        for (int i = 1; i <= n; ++i) {
            cout << ans[i] << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入并标记放烟花的日期，然后从最后一天倒序遍历。若当前日放烟花，答案为0；否则继承后一天的答案+1。最后输出所有结果，时间复杂度O(N)，空间复杂度O(N)。

---

<code_intro_selected>
接下来，分析两种优质题解的核心代码片段：
</code_intro_selected>

**题解一（递推法，作者：Binah_cyc）**
* **亮点**：倒序递推思路巧妙，利用标记数组简化判断，时间复杂度O(N)。
* **核心代码片段**：
    ```cpp
    for(int i = n; i >= 1; --i) {
        if(mp[i]) 
            ans[i] = 0; 
        else 
            ans[i] = ans[i + 1] + 1; 
    }
    ```
* **代码解读**：这段代码是递推的核心。`mp[i]`标记i日是否放烟花。倒序遍历时，若i日放烟花（`mp[i]`为真），则`ans[i]`为0；否则，`ans[i]`等于后一天的答案+1（因为i日比i+1日早一天，所以差多1）。
* 💡 **学习笔记**：倒序递推的关键是“后续结果已计算”，确保每一步的`ans[i+1]`已有值。

**题解二（二分法，作者：lrx___）**
* **亮点**：利用STL的`lower_bound`函数，代码简洁，时间复杂度O(N log M)。
* **核心代码片段**：
    ```cpp
    printf("%d\n", (*lower_bound(a, a + m, i)) - i);
    ```
* **代码解读**：`lower_bound(a, a + m, i)`返回A数组中第一个≥i的元素的地址，解引用后得到该元素的值，减去i即为所求差值。由于A数组递增，`lower_bound`能快速定位目标。
* 💡 **学习笔记**：`lower_bound`适用于有序数组的“最近大于等于”查询，是竞赛中常用的高效工具。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解递推法的过程，我们设计一个“烟花倒计时像素动画”，以8位复古风格展示每一天的答案生成过程。
</visualization_intro>

  * **动画演示主题**：`烟花倒计时：像素小镇的烟火日程`

  * **核心演示内容**：展示从最后一天倒序递推，每个日期的答案如何由后一天“传递”而来。例如，最后一天（红色格子）答案为0，前一天（灰色格子）若不放烟花则答案为1，依此类推。

  * **设计思路简述**：采用FC红白机风格的像素网格（每格代表一天），红色格子标记放烟花日，灰色格子表示普通日。动画通过颜色渐变和数值显示，直观展示递推逻辑。“滴答”音效（每递推一步）和“叮”音效（遇到红色格子）增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：屏幕中央显示一个横向像素条（长度N），每个格子初始为灰色，放烟花的日期（A数组）标记为红色。底部控制面板包含“开始”“单步”“重置”按钮和速度滑块。

    2.  **倒序递推演示**：
        - 从最后一个格子（i=N）开始，若为红色（放烟花），格子内显示“0”，播放“叮”音效。
        - 向左移动到i=N-1，若为灰色，格子内显示“ans[i+1]+1”（即1），播放“滴答”音效。
        - 重复此过程，直到i=1，所有格子填充完毕。

    3.  **高亮关键步骤**：当前处理的格子用黄色边框闪烁，数值变化时格子颜色从灰变浅蓝再固定。

    4.  **交互控制**：支持单步执行（逐格查看递推）、自动播放（可调速）、重置（重新开始动画）。

  * **旁白提示**：
      - “看！最后一天是红色（放烟花），所以它的答案是0。”
      - “前一天不放烟花，答案等于后一天的答案+1，也就是0+1=1！”
      - “遇到红色格子时，答案重置为0，这就是递推的关键！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到递推法如何用O(N)的时间高效计算每个日期的答案，理解“后续结果传递”的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的递推和二分法后，我们可以尝试以下类似问题，巩固算法应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 递推法适用于“后续状态影响当前状态”的问题（如“最近的更大元素”“连续子数组最大值”）。
      - 二分法适用于有序数组的“最近大于等于/小于等于”查询（如“寻找峰值”“搜索插入位置”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1824 进击的奶牛** - 考察二分查找在最小化最大间距问题中的应用。
    * 🗣️ **推荐理由**：这道题需要用二分法寻找符合条件的最小间距，与本题的二分思路类似。
    2.  **洛谷 P1020 导弹拦截** - 考察递推法求最长不升子序列。
    * 🗣️ **推荐理由**：递推法在序列问题中的应用，与本题的递推思想相通。
    3.  **洛谷 P1102 A-B数对** - 考察哈希表与二分查找的结合使用。
    * 🗣️ **推荐理由**：通过二分查找统计符合条件的数对，锻炼对有序数组的灵活运用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自 作者：yszkddzyh)**：“一开始没考虑倒序递推，用暴力法超时了。后来发现从后往前推，每个日期的答案可以由后一天快速得到，这才通过。”

**点评**：这位作者的经验提醒我们，遇到“后续状态影响当前状态”的问题时，逆向思维往往能简化计算。在编程中，若暴力法超时，应尝试寻找问题的递推关系或利用数据特性（如有序性）优化。

-----

<conclusion>
本次关于“[ABC322C] Festival”的分析就到这里。无论是递推法的巧妙逆向推导，还是二分法的高效查询，都体现了算法设计中“利用问题特性”的重要性。希望大家通过练习，掌握这些技巧，在编程竞赛中更加游刃有余！💪
</conclusion>

---
处理用时：143.44秒
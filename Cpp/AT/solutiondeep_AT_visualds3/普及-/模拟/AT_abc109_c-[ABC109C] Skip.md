# 题目信息

# [ABC109C] Skip

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc109/tasks/abc109_c

数直線上に $ N $ 個の都市があり、$ i $ 番目の都市は座標 $ x_i $ にあります。

あなたの目的は、これら全ての都市を $ 1 $ 度以上訪れることです。

あなたは、はじめに正整数 $ D $ を設定します。

その後、あなたは座標 $ X $ から出発し、以下の移動 $ 1 $、移動 $ 2 $ を好きなだけ行います。

- 移動 $ 1 $: 座標 $ y $ から座標 $ y\ +\ D $ に移動する
- 移動 $ 2 $: 座標 $ y $ から座標 $ y\ -\ D $ に移動する

全ての都市を $ 1 $ 度以上訪れることのできる $ D $ の最大値を求めてください。

ここで、都市を訪れるとは、その都市のある座標に移動することです。

## 说明/提示

### 制約

- 入力はすべて整数である
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ X\ \leq\ 10^9 $
- $ 1\ \leq\ x_i\ \leq\ 10^9 $
- $ x_i $ はすべて異なる
- $ x_1,\ x_2,\ ...,\ x_N\ \neq\ X $

### Sample Explanation 1

$ D\ =\ 2 $ と設定すれば次のように移動を行うことですべての都市を訪れることができ、これが最大です。 - 移動 $ 2 $ を行い、座標 $ 1 $ に移動する - 移動 $ 1 $ を行い、座標 $ 3 $ に移動する - 移動 $ 1 $ を行い、座標 $ 5 $ に移動する - 移動 $ 1 $ を行い、座標 $ 7 $ に移動する - 移動 $ 1 $ を行い、座標 $ 9 $ に移動する - 移動 $ 1 $ を行い、座標 $ 11 $ に移動する

## 样例 #1

### 输入

```
3 3

1 7 11```

### 输出

```
2```

## 样例 #2

### 输入

```
3 81

33 105 57```

### 输出

```
24```

## 样例 #3

### 输入

```
1 1

1000000000```

### 输出

```
999999999```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC109C] Skip 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC109C] Skip”这道C++编程题。这道题的关键在于理解数学中最大公约数（GCD）的应用场景，通过分析移动规则与城市坐标的关系，找到解题的核心思路。本指南将帮助大家梳理题目逻辑，掌握核心算法，并通过可视化演示直观理解过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（最大公约数GCD的应用）

🗣️ **初步分析**：
解决“[ABC109C] Skip”这道题，关键在于理解“移动规则”与“城市坐标”之间的数学关系。简单来说，最大公约数（GCD）就像一把“万能钥匙”，能打开所有“距离锁”——如果我们能找到一个数D，它能整除所有城市到初始位置的距离，那么D就是满足条件的移动步长。本题的核心就是找到这样的最大D。

- **题解思路**：所有题解的核心思路高度一致：计算每个城市到初始位置X的距离（即 \(x_i - X\)），然后求这些距离的绝对值的最大公约数（GCD）。这个GCD就是能覆盖所有城市的最大D。
- **核心难点**：理解“为什么D必须是所有距离的GCD”。例如，若某个城市到X的距离是10，另一个是15，那么D必须是10和15的公约数（如5），才能通过移动D的倍数到达这两个城市。最大的D就是它们的GCD（5）。
- **可视化设计思路**：我们将用像素动画模拟“距离收集”和“GCD计算”的过程。例如，用不同颜色的像素方块表示各个城市到X的距离，然后逐步合并这些方块，最终得到最大的GCD方块。关键步骤（如取绝对值、计算GCD）会用高亮和音效提示。
- **复古游戏元素**：动画采用8位像素风格，类似经典的“数字冒险游戏”。当计算出一个新的GCD时，会播放“叮”的音效；最终得到最大D时，播放胜利音效并展示庆祝动画。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解（评分≥4星），它们在关键逻辑解释和代码实现上都非常值得学习：
</eval_intro>

**题解一：作者亦枫**
* **点评**：此题解思路简洁直接，代码短小精悍。作者明确指出“预处理每个城市到X的距离，再求这些距离的GCD”是解题关键，逻辑推导清晰。代码中使用`__gcd`函数（C++内置的GCD计算函数）简化了实现，变量命名（如`ans`）直观易懂。从实践角度看，代码直接处理输入输出，边界条件（如取绝对值）处理严谨，非常适合竞赛环境。

**题解二：作者zct_sky**
* **点评**：此题解在代码规范性上表现突出，包含了快读快写函数（`read`和`write`），提升了输入输出效率，这在处理大数据量（如N=1e5）时非常实用。作者对思路的解释简短但精准（“D必须整除所有距离”），代码结构工整，变量`ans`的更新逻辑清晰。美中不足是快读快写对初学者可能稍显复杂，但整体仍具高参考价值。

**题解三：作者伟大的王夫子**
* **点评**：此题解的亮点在于对数学原理的详细推导。作者通过“两个点能互相到达的充要条件”引出GCD的必要性，帮助学习者理解“为什么是GCD”而非其他数。代码中使用`val`变量逐步计算GCD，避免了数组存储，节省空间，这种“流式计算”的技巧值得学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下三个核心难点。结合优质题解的共性，我为大家提炼了思考方向和解决策略：
</difficulty_intro>

1.  **关键点1**：理解“D必须是所有城市到X距离的公约数”
    * **分析**：假设D是满足条件的步长，那么从X出发，每次移动D或-D，最终到达的坐标只能是\(X + kD\)（k为整数）。因此，每个城市的坐标\(x_i\)必须等于\(X + kD\)，即\(x_i - X\)是D的倍数。因此，D必须是所有\(x_i - X\)的公约数。
    * 💡 **学习笔记**：D的取值范围是所有距离的公约数，最大的D就是这些距离的最大公约数（GCD）。

2.  **关键点2**：正确处理距离的绝对值
    * **分析**：城市可能在X的左侧（\(x_i < X\)）或右侧（\(x_i > X\)），因此\(x_i - X\)可能为负。但距离的绝对值（即\(|x_i - X|\)）才是实际需要考虑的，因为D是正整数，负距离的GCD与绝对值的GCD相同。
    * 💡 **学习笔记**：计算时取绝对值，避免因负数导致GCD错误（例如，-10和15的GCD等于10和15的GCD，即5）。

3.  **关键点3**：高效计算多个数的GCD
    * **分析**：计算多个数的GCD时，只需依次计算当前结果与下一个数的GCD。例如，计算a、b、c的GCD，等价于先算GCD(a,b)，再算GCD(结果,c)。这种“逐步合并”的方法时间复杂度为O(N)，适合处理N=1e5的情况。
    * 💡 **学习笔记**：多个数的GCD可以通过两两迭代计算，无需存储所有数，节省空间。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将实际问题（移动规则）转化为数学问题（求多个数的GCD），这是解决此类问题的关键。
- **边界处理**：注意处理负数距离（取绝对值），避免因符号错误导致结果错误。
- **流式计算**：计算多个数的GCD时，无需存储所有数，只需用一个变量保存当前GCD，依次与新数计算即可，节省空间。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合了多个优质题解思路的通用核心实现，它简洁高效，适合直接学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了亦枫、伟大的王夫子等题解的思路，采用流式计算GCD，避免数组存储，适合处理大数据量。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long; // 使用类型别名提升可读性

    int main() {
        int n;
        ll X;
        cin >> n >> X;

        ll current_gcd = 0; // 初始化为0，第一次计算时会被第一个距离覆盖
        for (int i = 0; i < n; ++i) {
            ll xi;
            cin >> xi;
            ll distance = abs(xi - X); // 计算当前城市到X的距离（绝对值）
            current_gcd = gcd(current_gcd, distance); // 逐步计算GCD
        }

        cout << current_gcd << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取城市数量n和初始位置X。然后通过循环读取每个城市的坐标xi，计算其到X的距离（绝对值）。使用`current_gcd`变量逐步计算这些距离的GCD：初始值为0时，第一个距离会直接覆盖它；后续每次用当前GCD与新距离计算新的GCD。最终输出最大的D（即所有距离的GCD）。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，学习它们的亮点和实现思路。
</code_intro_selected>

**题解一：作者亦枫**
* **亮点**：代码简洁，直接使用C++内置的`__gcd`函数，无需手动实现GCD计算，适合快速编码。
* **核心代码片段**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    ll n,x;
    ll a[100005];
    int main(){
        scanf("%d %d",&n,&x);
        for(ll i=1;i<=n;i++){
            scanf("%d",&a[i]);
            a[i]=a[i]-x; // 预处理：计算距离（未取绝对值）
        }
        ll ans=a[1];
        for(ll i=2;i<=n;i++){
            ans=__gcd(ans,a[i]); // 逐步计算GCD
        }
        printf("%d\n",abs(ans)); // 最终取绝对值
    }
    ```
* **代码解读**：
    > 这段代码的关键是预处理步骤：将每个城市坐标减去X，得到原始距离（可能为负）。然后用`ans`变量保存当前GCD，依次与后续距离计算新的GCD。最后输出绝对值，因为GCD的绝对值才是有效的正整数D。例如，若原始距离为-10和15，`__gcd(-10,15)`的结果是5（因为GCD函数会处理符号），但为确保输出正，最后取绝对值。
* 💡 **学习笔记**：C++的`__gcd`函数（需包含`<algorithm>`或`<bits/stdc++.h>`）会自动处理负数，返回绝对值的GCD，但为保险起见，最终输出时取绝对值更稳妥。

**题解二：作者伟大的王夫子**
* **亮点**：采用流式计算，无需数组存储所有距离，节省空间，适合处理N=1e5的情况。
* **核心代码片段**：
    ```cpp
    int main() {
        cin >> n >> X;
        int val = 0;
        for (register int i = 1; i <= n; ++i) {
            int xi;
            scanf("%d", &xi);
            if (val == 0) 
                val = abs(xi - X); // 第一个距离直接赋值
            else 
                val = gcd(val, abs(xi - X)); // 后续距离与当前GCD计算
        }
        cout << val;
    }
    ```
* **代码解读**：
    > 这段代码的`val`变量初始化为0，第一次循环时会被第一个距离的绝对值覆盖。后续每次循环，用当前`val`与新距离的绝对值计算GCD。这种方法无需存储所有距离，空间复杂度为O(1)，非常高效。例如，当n=1e5时，数组存储需要O(n)空间，而流式计算仅需O(1)。
* 💡 **学习笔记**：流式计算适用于需要逐步处理数据且不需要回溯的场景，能显著降低空间复杂度。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“如何通过计算距离的GCD得到最大D”，我设计了一个名为“像素GCD探险”的8位复古动画方案。让我们一起“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：像素GCD探险（8位复古风格）

  * **核心演示内容**：模拟从初始位置X出发，收集所有城市到X的距离，逐步计算它们的GCD，最终找到最大D的过程。

  * **设计思路简述**：采用FC红白机风格的像素画面，用不同颜色的方块表示距离和GCD，通过动画展示“收集距离→计算GCD”的过程。关键步骤（如取绝对值、计算GCD）用高亮和音效提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是“数轴场景”（像素化的直线，X位置用金色方块标记），右侧是“GCD计算区”（堆叠的像素方块）。
          * 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1倍速到5倍速）。
          * 播放8位风格的轻快背景音乐（类似《超级马里奥》的经典旋律）。

    2.  **收集距离**：
          * 每个城市用蓝色像素点表示，分布在数轴上。点击“开始”后，从X出发，向每个城市发射一个“距离收集器”（像素箭头）。
          * 收集到一个城市时，箭头会显示该城市到X的距离（如“1-3=-2”），然后弹出一个“绝对值转换”动画（箭头闪烁，数字变为“2”），最终生成一个绿色像素方块（代表绝对值距离）。

    3.  **计算GCD**：
          * 绿色方块依次进入“GCD计算区”。第一个方块直接成为当前GCD（红色方块）。
          * 第二个方块进入时，计算区会弹出一个“GCD计算器”（像素窗口），显示当前GCD（红方块）和新距离（绿方块），然后播放“叮”的音效，合并为新的GCD（红方块，数值为两者的GCD）。
          * 后续方块重复此过程，每次计算新的GCD时，红方块会变大并闪烁，提示数值更新。

    4.  **最终结果**：
          * 所有方块处理完成后，红方块停止闪烁，显示最终的D值（如“2”），同时播放胜利音效（类似《超级玛丽》吃到金币的音效）。
          * 数轴上的所有城市会被金色光环包围，表示“可到达”。

    5.  **交互控制**：
          * 单步模式：点击“单步”按钮，逐次执行收集距离或计算GCD的步骤，适合仔细观察。
          * 自动模式：选择速度后，动画自动播放，适合整体流程理解。
          * 重置按钮：清空所有方块，回到初始状态，方便重复观看。

  * **旁白提示**：
      * （收集距离时）“看！这个城市在X的左边，距离是负数，但我们需要取绝对值哦~”
      * （计算GCD时）“现在，我们要计算当前GCD（红色方块）和新距离（绿色方块）的最大公约数，结果就是新的GCD！”
      * （完成时）“所有城市都处理完啦！最大的D就是最终的红色方块数值，它能让我们到达所有城市！”

<visualization_conclusion>
通过这样的动画，我们不仅能直观看到每个距离如何被处理，还能清晰理解“为什么GCD是最大的D”。像素风格和音效让学习过程更有趣，再也不怕抽象的数学概念啦！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解了本题的GCD应用后，我们可以尝试解决更多需要计算多个数GCD的问题，或者将GCD思想迁移到其他场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * **多约束条件下的最大公约数**：当问题要求一个数能同时满足多个“整除”条件时（如分糖果、安排间隔等），GCD是常用解法。
      * **数论问题中的基础工具**：GCD是数论的基础，也可用于求解最小公倍数（LCM）、同余方程等问题。
      * **几何中的等距划分**：例如，在数轴上找一个点，使其到多个点的距离是某个数的倍数，GCD同样适用。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2152** - [聪聪可可](https://www.luogu.com.cn/problem/P2152)
          * 🗣️ **推荐理由**：这道题需要计算树上路径长度的GCD，能帮助你巩固GCD在复杂场景中的应用。
    2.  **洛谷 P1029** - [最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)
          * 🗣️ **推荐理由**：结合GCD和LCM的关系，锻炼对数论基本概念的理解。
    3.  **洛谷 P3395** - [路障](https://www.luogu.com.cn/problem/P3395)
          * 🗣️ **推荐理由**：这道题需要用GCD判断路径是否可达，是GCD在图论中的应用，适合思维拓展。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了他们的解题心得，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自作者伟大的王夫子)**：“我一开始想直接用数组存储所有距离，后来发现其实不用数组，边读边算GCD更节省空间。这让我意识到，在编程时要考虑空间复杂度，尤其是处理大数据量时。”
>
> **点评**：伟大的王夫子的经验很实用。在竞赛中，当N很大（如1e5）时，避免使用大数组可以防止内存溢出，提升程序效率。边读边算的“流式处理”是竞赛编程中常用的优化技巧，值得我们学习。

-----

<conclusion>
本次关于“[ABC109C] Skip”的C++解题分析就到这里。通过理解GCD的应用、分析优质题解、观看可视化动画，相信大家已经掌握了这类问题的核心解法。记住，遇到“求最大公共约束”的问题时，不妨想想GCD这把“万能钥匙”！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：157.90秒
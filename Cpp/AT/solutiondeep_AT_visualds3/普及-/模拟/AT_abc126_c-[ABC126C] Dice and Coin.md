# 题目信息

# [ABC126C] Dice and Coin

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_c

すぬけ君は $ 1 $ 〜 $ N $ の整数が等確率で出る $ N $ 面サイコロと表と裏が等確率で出るコインを持っています。すぬけ君は、このサイコロとコインを使って今から次のようなゲームをします。

1. まず、サイコロを $ 1 $ 回振り、出た目を現在の得点とする。
2. 得点が $ 1 $ 以上 $ K-1 $ 以下である限り、すぬけ君はコインを振り続ける。表が出たら得点は $ 2 $ 倍になり、裏が出たら得点は $ 0 $ になる。
3. 得点が $ 0 $ になった、もしくは $ K $ 以上になった時点でゲームが終了する。このとき、得点が $ K $ 以上である場合すぬけ君の勝ち、 $ 0 $ である場合すぬけ君の負けである。

$ N $ と $ K $ が与えられるので、このゲームですぬけ君が勝つ確率を求めてください。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ K\ <\ =\ 10^5 $
- 入力はすべて整数

### Sample Explanation 1

\- サイコロの出た目が $ 1 $ のとき、得点が $ 10 $ 以上になるためには、 $ 4 $ 回コインを振って $ 4 $ 連続で表が出る必要があります。この確率は、 $ \frac{1}{3}\ \times\ (\frac{1}{2})^4\ =\ \frac{1}{48} $ です。 - サイコロの出た目が $ 2 $ のとき、得点が $ 10 $ 以上になるためには、 $ 3 $ 回コインを振って $ 3 $ 連続で表が出る必要があります。この確率は、 $ \frac{1}{3}\ \times\ (\frac{1}{2})^3\ =\ \frac{1}{24} $ です。 - サイコロの出た目が $ 3 $ のとき、得点が $ 10 $ 以上になるためには、 $ 2 $ 回コインを振って $ 2 $ 連続で表が出る必要があります。この確率は、 $ \frac{1}{3}\ \times\ (\frac{1}{2})^2\ =\ \frac{1}{12} $ です。 よって、すぬけ君が勝つ確率は、 $ \frac{1}{48}\ +\ \frac{1}{24}\ +\ \frac{1}{12}\ =\ \frac{7}{48}\ \simeq\ 0.1458333333 $ です。

## 样例 #1

### 输入

```
3 10```

### 输出

```
0.145833333333```

## 样例 #2

### 输入

```
100000 5```

### 输出

```
0.999973749998```

# AI分析结果



---
# 💡 Kay的C++算法解析：ABC126C Dice and Coin 深入学习指南 💡

<introduction>
今天我们来分析这道“Dice and Coin”问题。它结合了概率计算与简单模拟，通过学习这道题，我们可以掌握如何拆解概率问题、利用循环计算独立事件的概率，并理解数学推导在编程中的应用。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学概率计算（概率分解与累乘）

🗣️ **初步分析**：
解决这道题的关键在于将“获胜概率”拆解为每个骰子初始值的贡献，再利用数学规律计算每个初始值的获胜概率。简单来说，概率计算就像分“小任务”——每个骰子面（1~N）是一个独立任务，我们需要算出每个任务的成功概率，最后把它们加起来。

在本题中，每个初始值i的获胜概率由两部分组成：
1. 骰子选中i的概率（固定为1/N）。
2. i通过不断抛硬币翻倍直到≥K的概率（每次翻倍需要抛正面，概率是(1/2)^m，m是翻倍次数）。

**核心算法流程**：枚举每个初始值i（1到N），计算i需要翻倍多少次m（即最小的m满足i×2^m ≥ K），则该i的贡献概率为 (1/N) × (1/2)^m。将所有i的贡献累加得到总概率。

**可视化设计思路**：设计一个“像素翻倍机”动画，用8位像素风格展示每个初始值i的翻倍过程。例如，初始值i用绿色像素块表示，每次翻倍时像素块变大（宽度×2），同时概率条（用黄色进度条表示）长度减半（每次抛正面概率是1/2）。当像素块宽度≥K（红色标记线）时，播放“叮”的音效并高亮成功；若中途抛反面（像素块变灰），则播放“噗”的音效表示失败。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性、算法有效性等方面表现优异（均≥4星），值得重点学习：
</eval_intro>

**题解一：作者xgwpp6710**
* **点评**：此题解思路直白，代码简洁高效。通过直接枚举每个初始值i，利用循环计算翻倍次数，并同步更新概率，逻辑清晰。代码中变量名`i0`（当前翻倍后的值）和`p0`（当前概率）含义明确，边界条件处理（如i≥K时直接累加1/N）严谨。从实践角度看，该代码时间复杂度为O(n log K)，能轻松处理n=1e5的规模，适合竞赛场景。

**题解二：作者LJKX**
* **点评**：此题解代码结构简洁，核心逻辑集中在`while`循环中。变量`sum`直接记录当前i的获胜概率，初始化为1/N，通过循环不断翻倍并调整概率，可读性强。代码中没有冗余操作，充分体现了“最小必要逻辑”的编程思想，适合新手学习如何用简洁代码解决问题。

**题解三：作者Ciaxin_**
* **点评**：此题解将核心逻辑封装为函数`P(x)`，提高了代码的模块化程度。通过函数调用分离了“计算单个初始值概率”和“累加总概率”的逻辑，符合“高内聚低耦合”的编程原则。这种设计使代码更易维护和扩展（例如后续若需修改概率计算方式，只需调整`P(x)`函数），是值得学习的编码技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们可能会遇到以下核心难点。通过分析优质题解的共性，我为大家总结了应对策略：
</difficulty_intro>

1.  **关键点1：如何确定每个初始值i需要翻倍的次数m？**
    * **分析**：m是满足i×2^m ≥ K的最小非负整数。例如，当i=1、K=10时，1×2^4=16≥10，故m=4。优质题解中通过`while (i0 < K) { i0 *= 2; m++; }`的循环直接计算m，同时同步更新概率（每次循环概率×1/2）。
    * 💡 **学习笔记**：翻倍次数m的计算可以通过循环逐步验证，无需复杂数学公式，简单直接。

2.  **关键点2：如何处理浮点数的精度问题？**
    * **分析**：题目要求输出精度至少保留12位小数（样例输出为12位）。优质题解中统一使用`double`类型存储概率（精度约15位），并在输出时用`printf("%.12lf", p)`确保精度。需注意避免使用`float`（仅6-7位精度）。
    * 💡 **学习笔记**：涉及高精度计算时，优先选择`double`类型，并通过格式化输出控制小数位数。

3.  **关键点3：如何理解概率的累乘关系？**
    * **分析**：每次抛硬币成功（正面）的概率是1/2，且各次抛硬币是独立事件，因此连续m次成功的概率是(1/2)^m。初始选i的概率是1/N，因此总贡献是(1/N)×(1/2)^m。优质题解通过循环每次将概率除以2（即×1/2），直观体现了这一累乘过程。
    * 💡 **学习笔记**：独立事件的概率累乘可以通过循环逐步计算，每次操作对应一次事件的概率贡献。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：将总概率分解为每个初始值的独立概率之和，简化问题复杂度。
- **循环替代公式**：用`while`循环计算翻倍次数，避免手动推导数学公式（如对数计算），减少出错可能。
- **精度控制**：使用`double`类型存储概率，输出时指定足够的小数位数（如12位），确保结果符合题目要求。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是一个综合优质题解思路的通用核心实现，代码简洁高效，适合直接理解和应用。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，通过枚举每个初始值i，计算其获胜概率并累加，逻辑清晰且时间复杂度为O(n log K)，适用于题目给定的输入规模。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    int main() {
        int n, k;
        scanf("%d%d", &n, &k);
        double ans = 0.0;
        for (int i = 1; i <= n; ++i) {
            double prob = 1.0 / n; // 初始概率为1/n
            int current = i;
            while (current < k) {
                current *= 2; // 翻倍
                prob /= 2;    // 每次翻倍的概率是1/2
            }
            ans += prob; // 累加当前i的贡献
        }
        printf("%.12lf\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入n和k，然后初始化总概率ans为0。通过`for`循环枚举每个初始值i（1到n）：对于每个i，初始概率是1/n；若i≥k，直接累加1/n到ans；否则，通过`while`循环不断翻倍current（直到current≥k），同时将prob除以2（每次翻倍的概率是1/2）。最后输出ans，保留12位小数。

---
<code_intro_selected>
接下来，我们赏析部分优质题解的核心代码片段，学习其中的亮点和实现思路：
</code_intro_selected>

**题解一：作者xgwpp6710**
* **亮点**：代码简洁，直接通过循环计算翻倍次数和概率，没有冗余操作。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++) {
        int i0=i;
        if(i>=k) p+=1/n;
        else {
            double p0=1/n;
            while(i0<k) {
                i0*=2;
                p0/=2;
            }
            p+=p0;
        }
    }
    ```
* **代码解读**：
    > 这段代码通过`if-else`分支处理i≥k和i<k的情况。当i≥k时，直接累加1/n（因为无需抛硬币即可获胜）；当i<k时，用`while`循环计算需要翻倍的次数（i0不断×2），同时p0不断除以2（每次翻倍的概率是1/2）。循环结束时，p0即为该i的获胜概率，累加到总概率p中。
* 💡 **学习笔记**：通过`if`提前处理边界情况（i≥k），减少循环次数，提升效率。

**题解二：作者Ciaxin_**
* **亮点**：将概率计算封装为函数`P(x)`，提高代码模块化程度。
* **核心代码片段**：
    ```cpp
    double P(int x) {
        double cnt=1.0/n;
        if(x>=k) return cnt;
        while(x<k) {
            x*=2;
            cnt/=2;
        }
        return cnt;
    }
    ```
* **代码解读**：
    > 函数`P(x)`接收初始值x，返回其对应的获胜概率。首先初始化cnt为1/n（选到x的概率），若x≥k直接返回cnt；否则，通过`while`循环不断翻倍x，同时cnt除以2（每次翻倍的概率）。循环结束后，cnt即为x的获胜概率。这种封装使主函数更简洁，逻辑更清晰。
* 💡 **学习笔记**：将重复逻辑封装为函数，可提高代码的可读性和可维护性。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解每个初始值i的翻倍过程和概率计算，我设计了一个“像素翻倍机”动画，采用8位复古风格，让我们“看”到概率如何一步步累加！
</visualization_intro>

  * **动画演示主题**：像素翻倍大挑战！——骰子与硬币的概率之旅

  * **核心演示内容**：展示每个初始值i从被选中（骰子抛出）到最终获胜/失败的全过程，重点突出翻倍次数和概率变化。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），用不同颜色的像素块表示初始值i（绿色）、目标K（红色标记线）、翻倍过程（黄色扩展）。通过动态变化的像素块和进度条，直观展示“翻倍次数越多，概率越低”的规律。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示骰子（8位像素风格，数字1~N循环闪烁），右侧是“翻倍轨道”（水平排列的像素格，最右端标有红色K值）。
          * 底部控制面板包含“开始”、“暂停”、“单步”按钮和速度滑块（调节动画速度）。
          * 播放8位风格的轻快背景音乐（类似《超级玛丽》的跳跃音效）。

    2.  **骰子选数**：
          * 点击“开始”后，骰子停止闪烁，随机选中一个数i（如i=1），伴随“叮”的音效。
          * 左侧显示选中的i（绿色像素块，宽度=i），概率条（黄色）初始长度为1/N（对应概率1/N）。

    3.  **翻倍过程演示**：
          * 若i<K（如i=1，K=10），进入翻倍循环：
            - 第一次翻倍：像素块宽度×2（变为2），概率条长度减半（变为1/(2N)），播放“滴答”音效（表示抛硬币正面）。
            - 第二次翻倍：像素块宽度×2（变为4），概率条长度再减半（变为1/(4N)），再次播放“滴答”。
            - 第三次翻倍：宽度变为8，概率条长度1/(8N)。
            - 第四次翻倍：宽度变为16（≥10），概率条长度1/(16N)，播放“胜利”音效（上扬音调），像素块变为金色（表示成功）。
          * 若中途抛反面（可通过“单步”按钮模拟），像素块变灰，概率条归零，播放“噗”的音效（表示失败）。

    4.  **总概率累加**：
          * 每个i处理完成后，总概率值（显示在屏幕顶部）累加当前i的概率，伴随数字跳动的音效。

    5.  **结束状态**：
          * 所有i处理完成后，总概率值停止跳动，播放“完成”音效，屏幕显示“总获胜概率：XX.XXXXXXXXXXXX”。

  * **旁白提示**：
      * （骰子选数时）“现在选中的是i=1，它的初始概率是1/N哦！”
      * （翻倍时）“看，像素块变宽了！这是因为抛到了正面，得分翻倍～但概率也减半啦！”
      * （成功时）“像素块超过K啦！这次i=1的获胜概率是1/(16N)，累加到总概率里！”

<visualization_conclusion>
通过这个像素动画，我们不仅能直观看到每个i的翻倍过程，还能“感受”到概率如何随翻倍次数增加而降低。这种可视化方式让抽象的概率计算变得具体可触，帮助我们更好地理解问题本质！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“概率分解+循环计算”，这种思路在许多概率问题中都有应用。以下是一些相似问题和练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 类似的“独立事件概率累加”问题（如多次抛硬币求特定序列概率）。
      * 需要循环计算的“倍增/倍减”问题（如细菌分裂、资金增长等）。
      * 涉及边界条件处理的概率题（如“首次成功”的概率计算）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1297 单选错位**  
        * 🗣️ **推荐理由**：考察概率的分解与累加，需要分析每个题目的独立概率并求和，与本题思路类似。
    2.  **洛谷 P1303 A*B Problem**（高精度乘法）  
        * 🗣️ **推荐理由**：虽然是高精度计算，但其中“逐位处理+进位”的循环思想与本题的翻倍循环有共通之处。
    3.  **洛谷 P1433 吃奶酪**（状态压缩DP）  
        * 🗣️ **推荐理由**：进阶题，考察状态转移与概率结合，适合学有余力的同学挑战。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但通过观察题解代码，我们可以总结出以下通用经验：
</insights_intro>

> 编写概率题代码时，应优先分解问题为独立子问题（如本题的每个初始值i），并通过循环或数学公式计算每个子问题的概率。同时，注意浮点数的精度控制，避免因精度丢失导致结果错误。此外，合理的变量命名（如`current`表示当前得分，`prob`表示当前概率）能大幅提升代码可读性。

---

<conclusion>
通过本次分析，我们掌握了“Dice and Coin”问题的核心解法——分解每个初始值的概率并累加。希望大家能将这种“分解+循环”的思路应用到更多问题中，不断提升编程和数学能力！下次再见～💪
</conclusion>

---
处理用时：130.31秒
# 题目信息

# [ABC135C] City Savers

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc135/tasks/abc135_c

$ N+1 $ 個の街があり、$ i $ 番目の街は $ A_i $ 体のモンスターに襲われています。

$ N $ 人の勇者が居て、$ i $ 番目の勇者は $ i $ 番目または $ i+1 $ 番目の街を襲っているモンスターを合計で $ B_i $ 体まで倒すことができます。

$ N $ 人の勇者がうまく協力することで、合計して最大で何体のモンスターを倒せるでしょうか。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $

### Sample Explanation 1

以下のようにモンスターを倒すと、合計 $ 9 $ 体のモンスターを倒すことができ、このときが最大です。 - $ 1 $ 番目の勇者が $ 1 $ 番目の街を襲っているモンスターを $ 2 $ 体、$ 2 $ 番目の街を襲っているモンスターを $ 2 $ 体倒します。 - $ 2 $ 番目の勇者が $ 2 $ 番目の街を襲っているモンスターを $ 3 $ 体、$ 3 $ 番目の街を襲っているモンスターを $ 2 $ 体倒します。

## 样例 #1

### 输入

```
2

3 5 2

4 5```

### 输出

```
9```

## 样例 #2

### 输入

```
3

5 6 3 8

5 100 8```

### 输出

```
22```

## 样例 #3

### 输入

```
2

100 1 1

1 100```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：City Savers 深入学习指南 💡

<introduction>
今天我们来一起分析“City Savers”这道C++编程题。这道题需要我们找到英雄们协作击败怪兽的最优策略，核心在于贪心算法的灵活运用。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法应用

🗣️ **初步分析**：
> 解决“City Savers”这道题，关键在于理解并运用贪心算法。贪心算法的核心思想是：每一步选择当前最优的局部解，最终组合成全局最优解。就像分糖果时，先满足最饿的小朋友，再处理剩下的，这样整体能让更多人满意。  
> 在本题中，贪心策略体现在：每个英雄优先攻击自己对应的第i号城市的怪兽，剩余的攻击量再用于攻击i+1号城市的怪兽。这是因为第i号城市的怪兽只能被第i-1和第i号英雄攻击（i=1时仅第1号英雄），而i+1号城市的怪兽还能被第i+1号英雄处理。优先处理i号城市能避免“漏打”，最大化总击败数。  
> 核心难点在于确定攻击顺序（i号优先）和正确模拟英雄与怪兽的血量扣除。题解中普遍采用遍历每个英雄，先处理i号城市、再处理i+1号城市的策略，通过条件判断模拟双方血量变化。  
> 可视化设计上，我们将用8位像素风格模拟“英雄打怪”过程：城市用彩色方块表示，英雄是移动的像素角色，每一步高亮当前攻击的城市，用数字动态显示剩余血量，关键操作（如击败）伴随“叮”的音效，自动播放时英雄会按最优路径依次攻击。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性和实践价值，以下题解表现突出（评分≥4星），值得重点学习：
</eval_intro>

**题解一：作者：liangbowen**
* **点评**：此题解用函数`PK`封装英雄与怪兽的对决逻辑，代码模块化程度高，可读性强。`PK`函数通过取址符直接修改怪兽和英雄的血量，逻辑清晰。主函数遍历每个英雄，依次攻击i和i+1号城市，符合贪心策略。代码变量名简洁（如`a`表示怪兽，`b`表示英雄），边界处理严谨（如`sum`累加总击败数），适合作为学习模板。

**题解二：作者：_ZhouYuHan_**
* **点评**：此题解逻辑直白，通过嵌套条件判断直接模拟攻击过程。代码中先处理i号城市（若英雄足够则清空，否则部分击败），再处理i+1号城市（同理），完美体现“i号优先”的贪心策略。变量名`g`（怪兽）、`y`（英雄）含义明确，累加变量`s`命名直观，适合理解基础贪心流程。

**题解三：作者：Starw**
* **点评**：此题解代码简洁高效，通过两次条件判断（先i号城市，后i+1号城市）完成攻击模拟。变量`h`表示当前英雄剩余攻击量，逻辑清晰。代码中“若还能打”的判断自然衔接两次攻击，避免冗余操作，时间复杂度为O(n)，适合处理大数量级输入（如n=1e5）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1：确定攻击顺序（i号城市优先）**
    * **分析**：第i号城市的怪兽只能被第i-1和第i号英雄攻击（i=1时仅第1号英雄），而i+1号城市的怪兽还能被第i+1号英雄处理。若英雄先攻击i+1号城市，可能导致i号城市的怪兽因后续无英雄处理而浪费。因此，优先攻击i号城市是全局最优选择。  
    * 💡 **学习笔记**：局部最优需结合全局视角，优先处理“唯一可处理”的目标。

2.  **关键点2：正确模拟英雄与怪兽的血量扣除**
    * **分析**：英雄攻击时，若英雄剩余攻击≥怪兽数量，则怪兽被清空，英雄剩余攻击减少；否则，怪兽剩余数量减少，英雄攻击耗尽。这需要通过条件判断（`if-else`）实现，确保双方血量正确更新。  
    * 💡 **学习笔记**：模拟类问题需严格按题意设计条件分支，确保每一步操作符合规则。

3.  **关键点3：数据类型选择（避免溢出）**
    * **分析**：题目中怪兽和英雄的数量可达1e9，n=1e5时总击败数可能达1e14，需用`long long`类型存储累加结果（如`ans`、`sum`），否则会溢出导致错误。  
    * 💡 **学习笔记**：大数量级问题需提前预判数据范围，选择合适的数据类型（如`long long`）。

### ✨ 解题技巧总结
<summary_best_practices>
-   **问题分解**：将“每个英雄攻击两个城市”分解为“先处理i号，再处理i+1号”的两步操作，简化逻辑。
-   **模块化设计**：用函数封装重复操作（如`PK`函数），提高代码可读性和复用性。
-   **边界检查**：注意i的范围（1到n）和i+1的边界（n+1），避免数组越界。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，逻辑清晰且高效，适合直接学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了liangbowen和_zhouyuHan_的思路，采用贪心策略，优先处理i号城市，再处理i+1号城市，确保总击败数最大。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdio>
    #define N 100005
    using namespace std;

    long long a[N]; // 怪兽数组，a[i]表示第i号城市的怪兽数量
    long long b[N]; // 英雄数组，b[i]表示第i号英雄的攻击量
    long long sum = 0; // 总击败数

    int main() {
        int n;
        scanf("%d", &n);
        for (int i = 1; i <= n + 1; ++i) {
            scanf("%lld", &a[i]);
        }
        for (int i = 1; i <= n; ++i) {
            scanf("%lld", &b[i]);
        }

        for (int i = 1; i <= n; ++i) {
            // 先处理i号城市
            if (b[i] >= a[i]) {
                sum += a[i];
                b[i] -= a[i];
                a[i] = 0;
            } else {
                sum += b[i];
                a[i] -= b[i];
                b[i] = 0;
            }

            // 剩余攻击处理i+1号城市
            if (b[i] > 0) {
                if (b[i] >= a[i + 1]) {
                    sum += a[i + 1];
                    b[i] -= a[i + 1];
                    a[i + 1] = 0;
                } else {
                    sum += b[i];
                    a[i + 1] -= b[i];
                    b[i] = 0;
                }
            }
        }

        printf("%lld\n", sum);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入数据（n个英雄，n+1个城市的怪兽数量），然后遍历每个英雄。对于每个英雄，先处理i号城市的怪兽（若英雄攻击足够则清空，否则部分击败），剩余攻击再处理i+1号城市的怪兽（逻辑同上）。总击败数`sum`累加每一步的击败量，最终输出结果。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的亮点和思路。
</code_intro_selected>

**题解一：作者：liangbowen**
* **亮点**：用`PK`函数封装英雄与怪兽的对决逻辑，代码模块化，可读性强。
* **核心代码片段**：
    ```cpp
    void PK(int &x, int &y) {
        int tx = x, ty = y;
        if (x > y) x -= ty, y = 0, sum += ty;
        else if (x == y) x = 0, y = 0, sum += ty;
        else if (x < y) x = 0, y -= tx, sum += tx;
    }

    // 主函数中调用：
    for (int i = 1; i <= n; i++) {
        PK(a[i], b[i]);
        PK(a[i+1], b[i]);
    }
    ```
* **代码解读**：
    > `PK`函数通过引用传递（`&x, &y`）直接修改怪兽（`x`）和英雄（`y`）的剩余血量。根据双方血量关系分三种情况处理：  
    > - 若怪兽血量更多（`x > y`）：英雄耗尽攻击（`y=0`），怪兽剩余血量减少（`x -= y`），总击败数加`y`。  
    > - 若血量相等（`x == y`）：双方清空，总击败数加`y`。  
    > - 若英雄攻击更多（`x < y`）：怪兽清空（`x=0`），英雄剩余攻击减少（`y -= x`），总击败数加`x`。  
    > 主函数中依次调用`PK(a[i], b[i])`和`PK(a[i+1], b[i])`，实现“先i号、后i+1号”的贪心策略。
* 💡 **学习笔记**：模块化设计能让代码更清晰，重复操作封装成函数可减少冗余。

**题解二：作者：_ZhouYuHan_**
* **亮点**：条件判断直接明了，逻辑流程与贪心策略高度一致。
* **核心代码片段**：
    ```cpp
    for(int i=1; i<=n; i++) {
        if(y[i]>=g[i]) {
            y[i]-=g[i];
            s+=g[i];
            g[i]=0;
            if(y[i]>=g[i+1]) {
                y[i]-=g[i+1];
                s+=g[i+1];
                g[i+1]=0;
            } else {
                g[i+1]-=y[i];
                s+=y[i];
                y[i]=0;
            }
        } else {
            g[i]-=y[i];
            s+=y[i];
            y[i]=0;
        }
    }
    ```
* **代码解读**：
    > 外层循环遍历每个英雄。首先判断英雄攻击是否足够击败i号城市的怪兽：  
    > - 若足够（`y[i]>=g[i]`）：清空i号城市（`g[i]=0`），英雄剩余攻击处理i+1号城市（同理判断是否足够）。  
    > - 若不足（`y[i]<g[i]`）：i号城市剩余血量减少，英雄攻击耗尽，总击败数累加英雄攻击量。  
    > 代码严格按照“先i号、后i+1号”的顺序处理，确保贪心策略落地。
* 💡 **学习笔记**：条件判断需覆盖所有可能情况（如攻击足够或不足），确保逻辑完整。

**题解三：作者：Starw**
* **亮点**：代码简洁高效，通过两次条件判断完成攻击模拟。
* **核心代码片段**：
    ```cpp
    for(re i=1;i<=n;i++){
        scanf("%d",&h);
        if(h<m[i]){ // 连自己所在城市的怪兽都打不完
            m[i]-=h;
            ans+=h;
            h=0;
        }else{ // 可以打完自己所在城市的怪兽
            h-=m[i];
            ans+=m[i];
            m[i]=0;
        }
        if(h>0) // 若还有剩余攻击
            if(h<m[i+1]){ // 帮下一个城市打一部分
                m[i+1]-=h;
                ans+=h;
                h=0;
            }else{ // 打完下一个城市的怪兽
                h-=m[i+1];
                ans+=m[i+1];
                m[i+1]=0;
            }
    }
    ```
* **代码解读**：
    > 变量`h`表示当前英雄的剩余攻击量。首先处理i号城市：若`h`不足，i号城市剩余血量减少，`ans`累加`h`；若足够，清空i号城市，`h`减去i号城市血量。若`h`仍有剩余，处理i+1号城市（同理）。代码通过“剩余攻击”的传递，自然衔接两次攻击，逻辑流畅。
* 💡 **学习笔记**：用临时变量（如`h`）跟踪剩余攻击量，能简化多步骤操作的逻辑。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心算法的执行流程，我们设计一个“像素英雄打怪”动画，用8位复古风格模拟英雄依次攻击i和i+1号城市的过程。
</visualization_intro>

  * **动画演示主题**：像素英雄的城市保卫战

  * **核心演示内容**：英雄从左到右移动，依次攻击i号和i+1号城市的怪兽，动态显示双方剩余血量，最终展示总击败数。

  * **设计思路简述**：采用FC红白机风格（8色调色板，像素方块），通过颜色变化（红色表示怪兽，蓝色表示英雄）和动态数字（剩余血量）直观展示攻击过程。关键操作（如击败）伴随“叮”的音效，增加互动感；自动播放模式让学习者观察完整流程，单步模式可细究每一步逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕上方显示n+1个像素方块（代表城市），每个方块标有编号（1到n+1），颜色为红色（初始怪兽数量），顶部显示当前血量（如`A1=3`）。
          * 屏幕下方显示n个英雄图标（像素小人），每个标有编号（1到n），颜色为蓝色，右侧显示攻击量（如`B1=4`）。
          * 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-10倍速）。

    2.  **算法启动**：
          * 点击“开始”，英雄1移动到城市1上方，方块1高亮（黄色闪烁），播放“移动”音效（短音阶）。

    3.  **攻击i号城市**：
          * 英雄1的攻击量（4）与城市1的怪兽（3）比较：英雄攻击足够，城市1血量减3（变为0），方块1颜色变灰（无怪兽），英雄1剩余攻击量变为1（4-3），总击败数`sum`增加3（显示为`sum=3`），播放“击败”音效（“叮”）。

    4.  **攻击i+1号城市**：
          * 英雄1移动到城市2上方，方块2高亮（黄色闪烁）。英雄剩余攻击量（1）与城市2的怪兽（5）比较：攻击不足，城市2血量减1（变为4），英雄1攻击耗尽（变为0），总击败数增加1（`sum=4`），播放“部分击败”音效（“叮”）。

    5.  **切换英雄**：
          * 英雄1返回原位，英雄2移动到城市2上方，重复上述流程。城市2的剩余血量（4）与英雄2的攻击量（5）比较：攻击足够，城市2血量减4（变为0），英雄2剩余攻击量1（5-4），总击败数增加4（`sum=8`）；接着攻击城市3（怪兽2），英雄2剩余攻击1足够击败，城市3血量减1（变为1），总击败数增加1（`sum=9`）。

    6.  **目标达成**：
          * 所有英雄处理完毕，总击败数显示为9（样例1结果），播放“胜利”音效（上扬音阶），所有被击败的城市方块闪烁绿色。

    7.  **交互功能**：
          * 单步模式：点击“单步”，动画逐英雄、逐城市播放，学习者可查看每一步的血量变化。
          * 速度调整：滑块调慢时，英雄移动和攻击动画变慢，便于观察；调快时快速展示完整流程。

  * **旁白提示**：
      * （英雄1攻击城市1前）“英雄1先攻击自己对应的城市1，因为只有他和英雄0（不存在）能打这里哦！”
      * （英雄1攻击城市2时）“英雄1还有剩余攻击，现在去帮城市2打怪~”
      * （总击败数显示时）“看！通过贪心策略，总击败数达到了最大值9！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到每个英雄如何“聪明”地选择攻击顺序，理解贪心策略的核心——每一步都做当前最优选择，最终实现全局最优。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法是解决资源分配类问题的常用策略，除了本题，还能处理以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 活动选择问题：选择最多不重叠的活动（优先选结束早的）。
      * 合并果子：每次合并最小的两堆（减少总代价）。
      * 区间覆盖：用最少的区间覆盖目标范围（优先选覆盖远的）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090** - 合并果子  
          * 🗣️ **推荐理由**：经典贪心问题，练习“每次选最小”的策略，与本题“优先处理唯一可处理目标”的贪心思想类似。
    2.  **洛谷 P1223** - 排队接水  
          * 🗣️ **推荐理由**：通过排序调整顺序，最小化总等待时间，训练贪心策略的灵活应用。
    3.  **洛谷 P1803** - 线段覆盖  
          * 🗣️ **推荐理由**：选择最多不重叠线段，需优先选结束早的线段，与本题“优先处理局部最优”思路一致。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题中的经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自 shAdomOvO)**：“我这道题写了很久，被题面卡住了。后来发现题面描述不完整，需要自己重新理解题意。”  
> **参考经验 (来自 Gmt丶FFF)**：“不开long long就十分地惨。”

> **点评**：这些经验提醒我们两点：1. 读题时若发现描述模糊，可结合样例和输入输出反推题意（如本题“击败”即双方血量同时减少）；2. 大数量级问题必须用`long long`（如本题总击败数可达1e14，`int`会溢出）。这些都是编程中常见的“坑”，需要特别注意！

-----

<conclusion>
本次关于“City Savers”的C++解题分析就到这里。通过贪心算法的学习和代码实践，相信大家已经掌握了“优先处理局部最优”的策略。记住，编程能力的提升需要多思考、多练习，下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：174.42秒
# 题目信息

# [ABC300B] Same Map in the RPG World

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc300/tasks/abc300_b

> 高橋君は RPG を作っています。高橋君は 2 枚の RPG 世界のマップが一致しているかを判定するプログラムを書くことにしました。

縦 $ H $ マス横 $ W $ マスの 2 つのグリッド $ A,\ B $ があります。グリッドの各マスには `#` と `.` のいずれかの文字が書かれています。  
$ A $ と $ B $ の上から $ i $ 行目、左から $ j $ 列目に書かれている文字をそれぞれ $ A_{i,\ j},\ B_{i,\ j} $ と呼びます。

次の $ 2 $ 種類の操作をそれぞれ **縦方向のシフト**, **横方向のシフト** と呼びます。

- $ j=1,\ 2,\ \dots,\ W $ について次の操作を同時に行う。
  - $ A_{1,j},\ A_{2,j},\ \dots,\ A_{H-1,\ j},\ A_{H,j} $ を $ A_{2,j},\ A_{3,j},\ \dots,\ A_{H,j},\ A_{1,j} $ に同時に置き換える。
- $ i\ =\ 1,\ 2,\ \dots,\ H $ について次の操作を同時に行う。
  - $ A_{i,1},\ A_{i,2},\ \dots,\ A_{i,W-1},\ A_{i,W} $ を $ A_{i,\ 2},\ A_{i,\ 3},\ \dots,\ A_{i,W},\ A_{i,1} $ に同時に置き換える。

次の条件を満たす非負整数の組 $ (s,\ t) $ は存在しますか？存在する場合は `Yes` を、存在しない場合は `No` を出力してください。

- 縦方向のシフトを $ s $ 回行い、次に横方向のシフトを $ t $ 回行った時、操作後の $ A $ が $ B $ と一致する。

ここで、$ A $ と $ B $ が一致するとは、$ 1\ \leq\ i\ \leq\ H,\ 1\ \leq\ j\ \leq\ W $ を満たす整数の組 $ (i,\ j) $ すべてに対して $ A_{i,\ j}\ =\ B_{i,\ j} $ が成り立つことを言います。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 30 $
- $ A_{i,j},B_{i,j} $ は `#` または `.`
- $ H,\ W $ は整数

### Sample Explanation 1

$ (s,\ t)\ =\ (2,\ 1) $ とすると $ A $ と $ B $ を一致させることができます。 $ (s,\ t)\ =\ (2,\ 1) $ の時の操作の手順を説明します。はじめ、$ A $ は次の通りです。 ``` ..# ... .#. ... ``` まず、縦方向のシフトを行います。$ A $ は次のようになります。 ``` ... .#. ... ..# ``` 次に、再び縦方向のシフトを行います。$ A $ は次のようになります。 ``` .#. ... ..# ... ``` 最後に、横方向のシフトを行います。$ A $ は次のようになり、これは $ B $ と一致しています。 ``` #.. ... .#. ... ```

### Sample Explanation 2

どのように $ (s,\ t) $ を選んでも $ A $ と $ B $ を一致させることはできません。

## 样例 #1

### 输入

```
4 3
..#
...
.#.
...
#..
...
.#.
...```

### 输出

```
Yes```

## 样例 #2

### 输入

```
3 2
##
##
#.
..
#.
#.```

### 输出

```
No```

## 样例 #3

### 输入

```
4 5
#####
.#...
.##..
..##.
...##
#...#
#####
...#.```

### 输出

```
Yes```

## 样例 #4

### 输入

```
10 30
..........##########..........
..........####....###.....##..
.....##....##......##...#####.
....####...##..#####...##...##
...##..##..##......##..##....#
#.##....##....##...##..##.....
..##....##.##..#####...##...##
..###..###..............##.##.
.#..####..#..............###..
#..........##.................
................#..........##.
######....................####
....###.....##............####
.....##...#####......##....##.
.#####...##...##....####...##.
.....##..##....#...##..##..##.
##...##..##.....#.##....##....
.#####...##...##..##....##.##.
..........##.##...###..###....
...........###...#..####..#...```

### 输出

```
Yes```

# AI分析结果



---
# 💡 Kay的C++算法解析：Same Map in the RPG World 深入学习指南 💡

<introduction>
今天我们要解决的问题是“Same Map in the RPG World”。这道题需要判断两个网格是否可以通过特定的纵向和横向循环移位操作变得完全一致。通过这份指南，你将学会如何用枚举和模拟的方法解决这类问题，并掌握相关的编程技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举与模拟应用

🗣️ **初步分析**：
解决这道题的关键在于“枚举所有可能的移位次数，并模拟移位过程验证是否匹配”。简单来说，枚举就像“试钥匙”——我们需要尝试所有可能的移位组合（s次纵向、t次横向），而模拟则是“转动钥匙”——实际操作移位并检查是否能打开“匹配B的锁”。

在本题中，纵向移位是每列循环下移（比如一列是[1,2,3,4]，一次移位后变成[4,1,2,3]），横向移位是每行循环右移（比如一行是[1,2,3,4]，一次移位后变成[4,1,2,3]）。我们需要枚举所有可能的s（0到H-1，因为H次移位会回到原样）和t（0到W-1），然后模拟移位后的A是否等于B。

核心难点在于：
- 如何高效模拟移位操作（避免重复计算）；
- 如何正确枚举所有可能的s和t（注意循环周期）；
- 如何快速比较移位后的A与B是否一致。

可视化设计上，我们将用8位像素风展示网格，用不同颜色标记A和B的格子。移位时，每列/行的像素块会“滑动”到新位置（比如纵向移位时，最下方的像素块“跳”到最上方），同时用文字提示当前s和t的值。关键步骤（如移位完成、匹配成功）会播放像素音效（“叮”表示移位，“哇”表示匹配成功）。

---

## 2. 精选优质题解参考

<eval_intro>
由于当前提供的题解信息中暂无具体题解，Kay将结合题目特性，为大家总结通用的学习建议：
</eval_intro>

- **思路方向**：优先枚举所有可能的s和t（s范围0~H-1，t范围0~W-1），对每个组合模拟移位后的A，再与B逐格比较。
- **代码规范**：用二维数组存储网格，移位操作可通过计算新坐标实现（如纵向移位s次后，原行i的元素会移动到(i+s)%H行）。
- **实践技巧**：提前统计A和B中`#`的数量，若数量不等可直接返回No（减少无效枚举）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们可能会遇到以下关键问题，掌握这些策略能帮你更高效地解题：
</difficulty_intro>

1.  **关键点1：如何正确模拟纵向和横向移位？**
    * **分析**：移位操作本质是循环移动。纵向移位s次后，原行i（从0开始）的元素会移动到`(i + s) % H`行（例如H=4，s=2，i=0→(0+2)%4=2行）；横向移位t次后，原列j会移动到`(j + t) % W`列。用这个公式直接计算新坐标，比实际移动元素更高效。
    * 💡 **学习笔记**：循环移位的坐标计算是关键，用模运算能快速定位新位置。

2.  **关键点2：如何高效枚举s和t？**
    * **分析**：s的可能取值是0到H-1（超过H次会重复），t同理。总共有H×W种组合（最多30×30=900种），每种组合的检查时间是O(H×W)，总时间在合理范围内。
    * 💡 **学习笔记**：枚举范围由循环周期决定，H次纵向移位等价于0次，W次横向移位同理。

3.  **关键点3：如何快速比较移位后的A与B？**
    * **分析**：对每个(s,t)，遍历所有格子(i,j)，计算移位后的A的坐标`( (i - s) % H, (j - t) % W )`（因为A移位s次后，原行i对应移位后的(i+s)行，所以反向计算原行是(i-s)），然后比较A[原行][原列]是否等于B[i][j]。
    * 💡 **学习笔记**：反向计算原坐标比实际生成新网格更节省空间（无需存储移位后的A）。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理优化**：先统计A和B中`#`的数量，若不等直接输出No（减少90%无效枚举）。
- **坐标公式**：用模运算直接计算移位后的坐标，避免修改原数组。
- **边界处理**：注意行和列的索引从0还是1开始（本题输入通常按1开始，但代码中用0更方便）。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是一个通用的C++核心实现，综合了枚举、移位模拟和比较的关键逻辑，适合直接学习和参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码通过枚举所有可能的s和t，利用模运算快速计算移位后的坐标，直接比较A和B是否匹配。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    int main() {
        int H, W;
        cin >> H >> W;
        vector<string> A(H), B(H);
        for (int i = 0; i < H; ++i) cin >> A[i];
        for (int i = 0; i < H; ++i) cin >> B[i];

        // 预处理：检查#数量是否一致
        int cntA = 0, cntB = 0;
        for (int i = 0; i < H; ++i) {
            cntA += count(A[i].begin(), A[i].end(), '#');
            cntB += count(B[i].begin(), B[i].end(), '#');
        }
        if (cntA != cntB) {
            cout << "No" << endl;
            return 0;
        }

        // 枚举所有可能的s和t
        for (int s = 0; s < H; ++s) {
            for (int t = 0; t < W; ++t) {
                bool ok = true;
                for (int i = 0; i < H && ok; ++i) {
                    for (int j = 0; j < W && ok; ++j) {
                        // 计算A中对应B[i][j]的原始位置
                        int ai = (i - s + H) % H; // +H避免负数
                        int aj = (j - t + W) % W;
                        if (A[ai][aj] != B[i][j]) ok = false;
                    }
                }
                if (ok) {
                    cout << "Yes" << endl;
                    return 0;
                }
            }
        }
        cout << "No" << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并统计A和B的`#`数量，若不等直接输出No。然后枚举s（0到H-1）和t（0到W-1），对每个组合，计算B中每个位置(i,j)对应的A的原始位置(ai,aj)（通过反向移位计算），若所有位置都匹配则输出Yes，否则继续枚举。

---
<code_intro_selected>
由于当前无具体题解，这里以通用核心代码为例，分析其核心逻辑：
</code_intro_selected>

**通用核心代码片段赏析**
* **亮点**：通过反向计算原始坐标避免修改A数组，节省空间；预处理`#`数量快速剪枝。
* **核心代码片段**：
    ```cpp
    for (int s = 0; s < H; ++s) {
        for (int t = 0; t < W; ++t) {
            bool ok = true;
            for (int i = 0; i < H && ok; ++i) {
                for (int j = 0; j < W && ok; ++j) {
                    int ai = (i - s + H) % H;
                    int aj = (j - t + W) % W;
                    if (A[ai][aj] != B[i][j]) ok = false;
                }
            }
            if (ok) { /* 输出Yes */ }
        }
    }
    ```
* **代码解读**：
    这段代码枚举所有s和t，对每个(s,t)，遍历B的每个格子(i,j)，计算对应的A的原始位置(ai,aj)。例如，当s=2、t=1时，B的(0,0)位置需要对应A的( (0-2+4)%4=2, (0-1+3)%3=2 )位置（假设H=4，W=3）。若所有位置都匹配，说明找到解。
* 💡 **学习笔记**：反向计算坐标是关键技巧，避免了实际移动数组元素的繁琐操作。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地看到移位过程和匹配检查，我们设计一个“像素地图探险”动画，用8位风格展示A和B的移位与比较！
</visualization_intro>

  * **动画演示主题**：`像素地图的移位大冒险`

  * **核心演示内容**：展示不同s和t值下，A如何通过纵向和横向移位变成B，或发现不匹配的位置。

  * **设计思路简述**：8位像素风让界面更亲切，滑动动画直观展示移位过程，音效强化操作记忆。例如，纵向移位时，每列的像素块“唰”地向下滑动，最后一行的块“跳”到第一行；横向移位时，每行的块“唰”地向右滑动，最后一列的块“跳”到第一列。匹配成功时，所有格子变绿并播放“胜利”音效，增强成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分，左边是A的像素网格（蓝色背景），右边是B的网格（红色背景），每个格子用`#`或`.`的像素图案表示。
          * 控制面板有“开始”“暂停”“单步”按钮，s和t的输入框（0~H-1、0~W-1），以及速度滑块（慢/中/快）。

    2.  **移位操作演示**：
          * 选择s=2，点击“单步执行纵向移位”：A的每列像素块向下滑动（动画持续0.5秒），最后一行的块（如第一列的`#`）从底部滑到顶部。伴随“唰”的音效。
          * 选择t=1，点击“单步执行横向移位”：A的每行像素块向右滑动，最后一列的块（如第一行的`#`）从右侧滑到左侧。伴随“唰”的音效。

    3.  **匹配检查**：
          * 移位完成后，A的网格变为新状态。动画自动逐格比较A和B的对应位置：
            - 匹配的格子变绿色，不匹配的变红色，同时播放“叮”或“咚”的音效。
            - 若全部匹配，屏幕中央弹出“胜利！”文字，播放欢快的8位音乐；若不匹配，提示“继续尝试”。

    4.  **AI自动演示**：
          * 点击“AI自动试错”，程序会自动枚举s和t，每次移位后展示比较结果，像小机器人一样尝试所有可能，直到找到解或遍历所有情况。

  * **旁白提示**：
      * “现在，我们尝试s=2次纵向移位！看，每列的格子都向下滑了一格～”
      * “接下来是t=1次横向移位，每行的格子向右滑了一格哦～”
      * “检查匹配时，每个格子都要和B的对应位置一样，绿色表示匹配成功！”

<visualization_conclusion>
通过这个动画，你可以直观看到移位的过程和匹配的逻辑，就像在玩一个小游戏，边玩边学算法，是不是很有趣？
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
枚举与模拟的思想在编程中非常实用，除了本题的移位问题，还能解决许多其他问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 循环移位问题（如数组循环移动后的匹配）；
      * 周期性操作验证（如灯光按周期闪烁，判断是否同步）；
      * 网格变换匹配（如旋转后的图形是否一致）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1328 生活大爆炸版石头剪刀布**
          * 🗣️ **推荐理由**：需要模拟游戏的每一轮结果，结合枚举玩家的出拳顺序，练习模拟与循环的应用。
    2.  **洛谷 P1067 多项式输出**
          * 🗣️ **推荐理由**：需要枚举多项式的每一项，根据系数和指数模拟输出格式，锻炼细节处理能力。
    3.  **洛谷 P1563 玩具谜题**
          * 🗣️ **推荐理由**：涉及循环移动和方向判断，与本题的移位逻辑有相似之处，适合巩固枚举与模拟技巧。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但Kay想提醒你：遇到类似问题时，先想清楚枚举的范围和模拟的方式，再动手写代码。预处理（如本题的`#`数量检查）能大幅减少无效计算，这是很实用的优化技巧哦！
</insights_intro>

-----

<conclusion>
通过今天的学习，我们掌握了如何用枚举和模拟解决网格移位匹配问题。记住，遇到“试所有可能”的问题时，先确定枚举范围，再用高效的方法模拟操作，最后验证结果。动手试试代码，再看看动画演示，你会更深刻地理解这个过程！下次见～💪
</conclusion>

-----

---
处理用时：135.71秒
# 题目信息

# [ABC300C] Cross

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc300/tasks/abc300_c

縦 $ H $ マス横 $ W $ マスのグリッドがあります。グリッドの上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と呼びます。  
 グリッドの各マスには `#` と `.` のいずれかの文字が書かれています。$ (i,\ j) $ に書かれている文字を $ C[i][j] $ とします。また、整数 $ i,\ j $ が $ 1\ \leq\ i\ \leq\ H $ と $ 1\ \leq\ j\ \leq\ W $ の少なくとも一方を満たさない場合、 $ C[i][j] $ を `.` と定義します。

正整数 $ a,\ b,\ n $ が以下の条件を全て満たす時、$ (a,b) $ および $ (a+d,b+d),(a+d,b-d),(a-d,b+d),(a-d,b-d) $ $ (1\ \leq\ d\ \leq\ n) $ の $ 4n\ +\ 1 $ マスを **$ (a,b) $ を中心とするサイズ $ n $ のバツ印** と呼びます。

- $ C[a][b] $ は `#` である。
- $ 1\ \leq\ d\ \leq\ n $ を満たす整数 $ d $ について、 $ C[a+d][b+d],C[a+d][b-d],C[a-d][b+d],C[a-d][b-d] $ はいずれも `#` である。
- $ C[a+n+1][b+n+1],C[a+n+1][b-n-1],C[a-n-1][b+n+1],C[a-n-1][b-n-1] $ のうち少なくとも 1 つは `.` である。
 
例えば次の図で示された例では、$ (2,\ 2) $ を中心とするサイズ $ 1 $ のバツ印と $ (3,\ 7) $ を中心とするサイズ $ 2 $ のバツ印がグリッド上にあります。

![image](https://img.atcoder.jp/ghi/abc300c_aa5161e20f55652dc61ad221348765bb002e4eed378c352bc0e44c7555148ebc.jpg)

グリッドにはいくつかのバツ印があります。バツ印を構成するマス以外に `#` は書かれていません。  
 また、異なるバツ印を構成するマス同士は頂点を共有しません。以下の 2 つのグリッドは異なるバツ印を構成するマス同士が頂点を共有している例で、**このようなグリッドの状態は入力として与えられません。** 例えば左のグリッドでは $ (3,\ 3) $ と $ (4,\ 4) $ が頂点を共有しているのが条件に反しています。

![image2](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc300_c/af4437e0a6d74885bdf21777218fa90fa4795735.png)

$ N\ =\ \min(H,\ W) $ とします。また、サイズ $ n $ のバツ印の個数を $ S_n $ とします。$ S_1,\ S_2,\ \dots,\ S_N $ を計算してください。

## 说明/提示

### 制約

- $ 3\ \leq\ H,\ W\ \leq\ 100 $
- $ C[i][j] $ は `#` または `.`
- 異なるバツ印を構成するマス同士は頂点を共有しない
- $ H,\ W $ は整数
 
### Sample Explanation 1

問題文に書かれた説明の通り、$ (2,\ 2) $ を中心とするサイズ $ 1 $ のバツ印と $ (3,\ 7) $ を中心とするサイズ $ 2 $ のバツ印が書かれています。

### Sample Explanation 2

バツ印が 1 個も書かれていない場合もあります。

## 样例 #1

### 输入

```
5 9

#.#.#...#

.#...#.#.

#.#...#..

.....#.#.

....#...#```

### 输出

```
1 1 0 0 0```

## 样例 #2

### 输入

```
3 3

...

...

...```

### 输出

```
0 0 0```

## 样例 #3

### 输入

```
3 16

#.#.....#.#..#.#

.#.......#....#.

#.#.....#.#..#.#```

### 输出

```
3 0 0```

## 样例 #4

### 输入

```
15 20

#.#..#.............#

.#....#....#.#....#.

#.#....#....#....#..

........#..#.#..#...

#.....#..#.....#....

.#...#....#...#..#.#

..#.#......#.#....#.

...#........#....#.#

..#.#......#.#......

.#...#....#...#.....

#.....#..#.....#....

........#.......#...

#.#....#....#.#..#..

.#....#......#....#.

#.#..#......#.#....#```

### 输出

```
5 0 1 0 0 0 1 0 0 0 0 0 0 0 0```

# AI分析结果



---
# 💡 Kay的C++算法解析：ABC300C Cross 深入学习指南 💡

<introduction>
今天我们来一起分析“ABC300C Cross”这道C++编程题。这道题需要统计网格中不同大小的“十字架”数量，本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与枚举`

🗣️ **初步分析**：
解决“ABC300C Cross”这道题，关键在于通过枚举每个可能的中心点，并模拟其向四个对角线方向延伸的过程，判断是否能形成特定大小的十字架。简单来说，“模拟与枚举”就像我们玩拼图时，逐个尝试每个可能的位置，看看是否能拼出目标形状。在本题中，我们需要逐个检查每个`#`的位置是否是十字架的中心，并计算它能延伸的最大长度（即十字架的大小）。

- **题解思路**：所有题解的核心思路都是枚举每个`#`的位置作为中心点，然后向四个对角线方向（左上、右上、左下、右下）延伸，找到最大的延伸距离d（即十字架的大小），最后统计每个d的出现次数。不同题解的差异主要在于延伸判断的具体实现方式（如循环条件、边界处理）。
- **核心难点**：如何正确计算每个中心点的最大延伸距离d，同时处理边界越界和遇到`.`的情况。例如，当延伸到网格外或遇到`.`时，必须停止延伸，并记录当前的d作为该中心点的十字架大小。
- **可视化设计思路**：我们可以用8位像素风格的网格展示，每个`#`用黄色像素块表示，中心点用红色高亮。当计算某个中心点的d时，用绿色箭头逐步向四个方向延伸，每成功延伸一步（即遇到`#`），播放“叮”的音效；若遇到`.`或越界，则停止延伸，用红色标记该方向，并记录最终的d值。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性和实践价值，我筛选出以下3份优质题解（评分≥4星），供大家参考：
</eval_intro>

**题解一：作者CuteChat**
* **点评**：这份题解思路非常清晰，直接枚举每个`#`作为中心点，通过循环向四个方向延伸判断是否满足条件。代码变量命名规范（如`check(x, y)`函数明确检查坐标合法性），边界处理严谨（使用`check`宏判断越界）。算法复杂度为O(H*W*N)（N为min(H,W)），在题目约束下（H,W≤100）非常高效。亮点在于`cross`函数简洁地实现了最大延伸距离的计算，适合竞赛中快速编写。

**题解二：作者small_john**
* **点评**：此题解代码简洁高效，通过`f(x,y)`函数直接计算中心点的最大d值。循环条件中同时检查越界和四个方向的`#`，逻辑紧凑。变量命名`ret`（结果）、`n,m`（网格大小）直观易懂。虽然代码简短，但完整覆盖了所有边界情况（如越界时立即停止），是一份典型的竞赛风格代码。

**题解三：作者minVan**
* **点评**：此题解通过双重循环枚举中心点，内层循环逐步增加d值，判断四个方向是否满足条件。代码结构工整，变量`d`明确表示当前延伸距离，`s[d]`统计各大小的数量。特别值得学习的是对`d`的边界处理（如`i + d > h`时停止），确保不会越界访问数组。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何正确判断中心点的最大延伸距离d？**
    * **分析**：每个中心点`(i,j)`必须满足四个对角线方向（`(i±d,j±d)`）在d=1到d_max时都是`#`，且d_max+1时至少有一个方向不满足。优质题解通常通过循环逐步增加d，每次检查四个方向是否越界或为`.`，若遇到不满足的情况则停止，此时d-1即为最大d值。
    * 💡 **学习笔记**：延伸距离d的计算需要同时考虑越界和字符是否为`#`，两者任一不满足即停止。

2.  **关键点2：如何处理边界条件（如网格边缘的中心点）？**
    * **分析**：网格边缘的中心点（如i=1或i=H）在延伸时可能很快越界。例如，当i=1时，d=1时i-d=0，超出网格范围，此时d_max=0。优质题解通过`check(x,y)`函数或直接在循环条件中判断坐标是否合法（如`i+d <= H`），避免数组越界。
    * 💡 **学习笔记**：边界条件的处理是避免运行时错误（如数组越界）的关键，需在延伸前先检查坐标是否在网格范围内。

3.  **关键点3：如何统计各大小的十字架数量？**
    * **分析**：统计时需注意，每个中心点的最大d值对应S_d的计数加1。例如，若一个中心点的d_max=2，则S_2加1。优质题解通常使用数组`ans[]`或`s[]`作为“桶”，直接通过`ans[d_max]++`完成统计。
    * 💡 **学习笔记**：“桶计数”是统计频率的常用方法，适合本题中各大小的计数需求。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：将问题拆解为“枚举中心点”→“计算最大d”→“统计d”三个步骤，逐步解决。
- **边界优先检查**：在延伸前先检查坐标是否越界，避免访问非法内存。
- **循环条件简化**：将越界判断和字符判断合并到循环条件中（如`while(check(nx, ny) && s[nx][ny] == '#')`），使代码更简洁。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了CuteChat和small_john的题解思路，提供一个清晰且完整的核心实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int h, w;
    char grid[102][102]; // 网格，1-based索引
    int ans[101]; // ans[d]记录大小为d的十字架数量

    // 计算以(i,j)为中心的最大十字架大小d
    int max_cross_size(int i, int j) {
        if (grid[i][j] != '#') return 0; // 中心不是#，直接返回0
        int d = 0;
        while (true) {
            d++;
            // 检查四个对角线方向d的位置是否合法且为#
            bool valid = true;
            // 四个方向：(i+d,j+d), (i+d,j-d), (i-d,j+d), (i-d,j-d)
            int dirs[4][2] = {{d, d}, {d, -d}, {-d, d}, {-d, -d}};
            for (auto [di, dj] : dirs) {
                int x = i + di, y = j + dj;
                if (x < 1 || x > h || y < 1 || y > w || grid[x][y] != '#') {
                    valid = false;
                    break;
                }
            }
            if (!valid) break; // 不满足条件，停止延伸
        }
        return d - 1; // 最后一次d不满足，返回d-1
    }

    int main() {
        cin >> h >> w;
        for (int i = 1; i <= h; i++) {
            for (int j = 1; j <= w; j++) {
                cin >> grid[i][j];
            }
        }

        // 枚举每个可能的中心点
        for (int i = 1; i <= h; i++) {
            for (int j = 1; j <= w; j++) {
                int d = max_cross_size(i, j);
                if (d >= 1) { // 大小至少为1才统计
                    ans[d]++;
                }
            }
        }

        // 输出S_1到S_min(h,w)
        int N = min(h, w);
        for (int i = 1; i <= N; i++) {
            cout << ans[i] << " ";
        }
        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先读取网格数据，然后枚举每个`(i,j)`作为中心点。通过`max_cross_size`函数计算该点的最大延伸距离d，若d≥1则统计到`ans[d]`中。最后输出各大小的计数。核心逻辑集中在`max_cross_size`函数，通过循环逐步增加d并检查四个方向的合法性。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者CuteChat**
* **亮点**：代码结构清晰，`check`宏简化越界判断，`cross`函数明确计算最大d值。
* **核心代码片段**：
    ```cpp
    int cross(int i, int j) { 
        if (s[i][j] == '.') return 0; 
        int res = 0;
        for (int d = 1; ; ++d) {
            bool ok = 1;
            for (int k = 0; k < 4 && ok; ++k) {
                int nx = i + d * dir[k][0], ny = j + d * dir[k][1];
                if (check(nx, ny) && s[nx][ny] == '#');
                else ok = 0;
            }
            if (ok) res = d;
            else break;
        }
        return res;
    }
    ```
* **代码解读**：
    这段代码定义了`cross`函数，计算以`(i,j)`为中心的最大d值。`dir`数组表示四个对角线方向的增量（如`{1,1}`对应右下方向）。循环中，d从1开始递增，每次检查四个方向的`(i±d,j±d)`是否合法且为`#`。若全部满足，更新`res`为当前d；否则退出循环，返回最大的d值。
* 💡 **学习笔记**：使用方向数组（`dir`）可以避免重复编写四个方向的判断代码，提高代码复用性。

**题解二：作者small_john**
* **亮点**：代码简洁高效，循环条件直接整合越界和字符判断。
* **核心代码片段**：
    ```cpp
    int f(int x,int y) {
        int ret = 0;
        while(x-ret-1>0&&x+ret+1<=n&&y-ret-1>0&&y+ret+1<=m
            &&a[x-ret-1][y-ret-1]=='#'&&a[x-ret-1][y+ret+1]=='#'
            &&a[x+ret+1][y-ret-1]=='#'&&a[x+ret+1][y+ret+1]=='#')
            ret++;
        return ret;
    }
    ```
* **代码解读**：
    这段代码通过`ret`变量表示当前延伸距离。循环条件中，`x-ret-1>0`等判断确保四个方向的下一个位置（即d=ret+1）不越界，且对应的四个点都是`#`。若条件满足，`ret`递增，直到不满足条件时返回`ret`（即最大d值）。
* 💡 **学习笔记**：将越界和字符判断合并到循环条件中，使代码更紧凑，但需注意逻辑的正确性（如`ret`的初始值为0，第一次循环检查d=1的情况）。

**题解三：作者minVan**
* **亮点**：边界条件处理明确，循环中直接判断d的合法性。
* **核心代码片段**：
    ```cpp
    for(d = 1; d <= n; d++) {
        if(i + d > h || i - d < 1 || j + d > w || j - d < 1 
        || c[i + d][j + d] != '#' || c[i + d][j - d] != '#' 
        || c[i - d][j + d] != '#' || c[i - d][j - d] != '#') {
            d--;
            break;
        }
    }
    ++s[d];
    ```
* **代码解读**：
    这段代码中，d从1开始递增，每次检查是否越界（如`i+d>h`）或四个方向的点不是`#`。若不满足条件，则`d--`（因为当前d不合法，最大合法d是d-1），并退出循环，最后将`s[d]++`统计该d值的数量。
* 💡 **学习笔记**：在循环中直接处理d的递增和边界判断，逻辑直观，但需注意退出循环后d的值可能需要调整（如`d--`）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“十字架大小计算”的过程，我设计了一个8位像素风格的动画演示方案。通过动态展示中心点的延伸过程，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素十字架探险`

  * **核心演示内容**：展示一个网格（如10x10的像素块），每个`#`用黄色方块表示，`.`用灰色方块表示。选择一个中心点（红色边框），逐步向四个对角线方向延伸（绿色箭头），每延伸一步（d=1,2,...），检查四个方向的方块是否为黄色（`#`）。若遇到灰色方块（`.`）或越界（网格外），则停止延伸，显示最终的d值。

  * **设计思路简述**：采用8位像素风格（如FC红白机的简洁色调），营造轻松的学习氛围。关键步骤的音效（如延伸成功时“叮”一声，失败时“咚”一声）强化操作记忆。动态展示延伸过程，帮助理解d的计算逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 网格用16色像素块展示（黄色：`#`，灰色：`.`），左上角显示“十字架探险”标题。
          * 控制面板包含“开始/暂停”、“单步执行”、“重置”按钮，以及速度滑块（1x-5x）。

    2.  **选择中心点**：
          * 鼠标点击或自动遍历每个黄色方块（`#`），被选中的中心点用红色边框高亮，伴随“滴”的音效。

    3.  **延伸过程演示**：
          * d从1开始，四个方向（右下、左下、右上、左上）同时出现绿色箭头，指向`(i±d,j±d)`的位置。
          * 若该位置是黄色方块（`#`），箭头变为绿色并停留，播放“叮”音效；若为灰色（`.`）或越界（网格外），箭头变为红色并闪烁，播放“咚”音效，延伸停止。
          * 每完成一个d的检查，屏幕上方显示当前d值（如“d=1 ✔️”或“d=2 ❌”）。

    4.  **统计结果**：
          * 延伸停止后，屏幕中央显示该中心点的最大d值（如“最大d=2”），并在右侧的统计图表中，对应d的柱状图高度增加。

    5.  **AI自动演示**：
          * 点击“AI自动运行”，算法自动遍历所有黄色方块，逐个演示其延伸过程，最终生成完整的统计结果（S_1到S_N）。

  * **旁白提示**：
      * （选择中心点时）“现在检查这个黄色方块，它可能是一个十字架的中心哦～”
      * （延伸d=1时）“向右下、左下、右上、左上各走一步，看看这些位置是不是黄色？”
      * （延伸失败时）“遇到灰色方块了！这个d太大，不能形成十字架，最大d是前一个值～”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到每个中心点的延伸过程，理解d值的计算逻辑，以及最终统计结果的生成方式。这种可视化方式能帮助我们更快掌握“模拟与枚举”的核心思想。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考“模拟与枚举”算法的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“枚举中心点+模拟延伸”思路可迁移到其他网格问题中，例如：
        1. 统计网格中特定形状（如矩形、菱形）的数量；
        2. 判断网格中是否存在满足条件的路径或区域；
        3. 计算网格中每个点的某种属性（如到最近障碍物的距离）。

  * **练习推荐 (洛谷)**：
    以下是几道与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1331 海战**
          * 🗣️ **推荐理由**：需要枚举网格中的连通区域，判断是否符合特定形状（矩形），与本题的枚举+模拟思路类似。
    2.  **洛谷 P1501 象棋游戏**
          * 🗣️ **推荐理由**：需要枚举棋子的移动路径，模拟每一步的合法性，锻炼边界条件处理能力。
    3.  **洛谷 P2089 烤鸡**
          * 🗣️ **推荐理由**：通过枚举所有可能的配料组合，统计满足条件的方案数，适合练习枚举的优化（如剪枝）。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，部分作者分享了调试经验。例如，CuteChat提到：“一定要注意中心不能是`.`，以及输出答案时最大是min(h, w)。”这些经验对避免常见错误很有帮助。
</insights_intro>

> **参考经验 (来自CuteChat)**：“在代码中，一定一定要注意很多的细节，如x, y这个位置不能是`.`，最后输出答案最大是min(h, w)。”
>
> **点评**：这位作者的经验非常实用。在编程中，边界条件（如中心是否为`#`）和输出范围（如min(h,w)）是容易出错的地方。通过提前检查这些条件，可以避免很多运行时错误。例如，在本题中，若忽略中心必须是`#`的条件，会导致统计到无效的十字架，影响最终结果。

-----

<conclusion>
本次关于“ABC300C Cross”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解“模拟与枚举”算法的应用，掌握十字架大小计算的核心逻辑。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：159.96秒
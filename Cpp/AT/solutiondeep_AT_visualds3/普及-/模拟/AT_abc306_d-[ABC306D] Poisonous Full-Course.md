# 题目信息

# [ABC306D] Poisonous Full-Course

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc306/tasks/abc306_d

高橋くんはレストランで、 $ N $ 品からなる奇妙なフルコースを楽しむことにしました。  
 このコースのうち $ i $ 番目の料理は以下の通りです。

- $ X_i=0 $ の場合、美味しさが $ Y_i $ の **解毒剤入り** の料理
- $ X_i=1 $ の場合、美味しさが $ Y_i $ の **毒入り** の料理
 
高橋くんが料理を食べると、高橋くんの状態は以下のように変化します。

- 最初、高橋くんはお腹を壊していない。
- 高橋くんが **お腹を壊していない** 時、
  - **解毒剤入り** の料理を食べても、高橋くんは **お腹を壊していないまま** である。
  - **毒入り** の料理を食べると、高橋くんは **お腹を壊す** 。
- 高橋くんが **お腹を壊している** 時、
  - **解毒剤入り** の料理を食べると、高橋くんは **お腹を壊していない状態になる** 。
  - **毒入り** の料理を食べると、高橋くんは **死ぬ** 。
 
コースは以下の流れで進行します。

- $ i\ =\ 1,\ \ldots,\ N $ についてこの順に、以下の処理を繰り返す。
  - まず、 $ i $ 番目の料理が高橋くんに提供される。
  - 次に、 高橋くんはこの料理に対し「食べる」か「下げてもらう」かを選択する。
      - 「食べる」を選択した場合、高橋くんは $ i $ 番目の料理を食べる。食べた料理に応じて高橋くんの状態も変化する。
      - 「下げてもらう」を選択した場合、高橋くんは $ i $ 番目の料理を食べない。この料理を後で提供してもらったり何らかの手段で保存したりすることはできない。
  - 最後に、 (状態が変化するなら変化後の時点で) 高橋くんが死んでいない場合、
      - $ i\ \neq\ N $ なら次の料理に進む。
      - $ i\ =\ N $ なら高橋くんは生きて退店する。
 
高橋くんはこのあと重要な仕事があるため、高橋くんは生きて退店しなければなりません。  
 この条件の下で高橋くんが各料理に対し「食べる」「下げてもらう」を選択したとき、高橋くんが **食べた料理の美味しさの総和として考えられる最大値** ( 但し、何も食べなかった場合は $ 0 $ ) を出力してください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ X_i\ \in\ \{0,1\} $
  - つまり、 $ X_i $ は $ 0,1 $ のどちらかである。
- $ -10^9\ \le\ Y_i\ \le\ 10^9 $
 
### Sample Explanation 1

以下のように選択することで食べた料理の美味しさの総和を $ 600 $ にでき、これが考えられる最大値です。 - $ 1 $ 番目の料理を下げてもらう。高橋くんはお腹を壊していません。 - $ 2 $ 番目の料理を食べる。高橋くんはお腹を壊し、食べた料理の美味しさの総和は $ 300 $ となります。 - $ 3 $ 番目の料理を食べる。高橋くんはお腹を壊していない状態に戻り、食べた料理の美味しさの総和は $ 100 $ となります。 - $ 4 $ 番目の料理を食べる。高橋くんはお腹を壊し、食べた料理の美味しさの総和は $ 600 $ となります。 - $ 5 $ 番目の料理を下げてもらう。高橋くんはお腹を壊しています。 - 最終的に高橋くんは死んでいないので、高橋くんは生きて退店する。

### Sample Explanation 2

この入力の場合何も食べないことが最善ですが、この場合答えは $ 0 $ となります。

### Sample Explanation 3

答えが $ 32 $ bit 符号付き整数に収まらない可能性があります。

## 样例 #1

### 输入

```
5

1 100

1 300

0 -200

1 500

1 300```

### 输出

```
600```

## 样例 #2

### 输入

```
4

0 -1

1 -2

0 -3

1 -4```

### 输出

```
0```

## 样例 #3

### 输入

```
15

1 900000000

0 600000000

1 -300000000

0 -700000000

1 200000000

1 300000000

0 -600000000

1 -900000000

1 600000000

1 -100000000

1 -400000000

0 900000000

0 200000000

1 -500000000

1 900000000```

### 输出

```
4100000000```

# AI分析结果



---
# 💡 Kay的C++算法解析：ABC306D Poisonous Full-Course 深入学习指南 💡

<introduction>
今天我们来一起分析“ABC306D Poisonous Full-Course”这道C++编程题。本指南将帮助大家梳理题目核心，理解动态规划的应用，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划 (DP) 应用

🗣️ **初步分析**：
解决这道题的关键在于用动态规划记录不同状态下的最优解。动态规划就像“走一步看一步”，每一步的选择（吃或不吃）会影响当前状态（健康或中毒），我们需要用DP保存这些状态的最优结果。

题目中，高桥君的状态只有两种：健康（0）或中毒（1）。每道菜是解毒剂（X=0）或毒药（X=1），选择吃或不吃会改变状态。核心难点在于：
- 如何定义状态（健康/中毒）并推导转移方程；
- 处理负美味度（是否选择吃可能降低总美味度的菜）；
- 优化空间复杂度（N可达3e5，需避免O(N)空间）。

核心算法流程：用`dp[i][0/1]`表示处理前i道菜后健康/中毒的最大美味度，根据当前菜的类型（X=0或1）推导状态转移。可视化设计中，用像素风格的状态条（绿色=健康，红色=中毒）动态展示每一步的状态变化和美味度累加，关键操作（如吃解毒菜切换状态）用闪烁高亮，伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，筛选出以下优质题解：
</eval_intro>

**题解一：作者c1ampy（赞：10）**
* **点评**：此题解详细解释了动态规划的设计思路，从二维DP到滚动数组优化，逻辑清晰。状态定义（`dp[i][0/1]`）和转移方程推导严谨，尤其优化后的空间复杂度O(1)非常适合大N场景。代码简洁高效，边界处理（初始状态为0）和最终取最大值的逻辑正确，实践价值高。

**题解二：作者hellolin（赞：1）**
* **点评**：此题解直接给出二维DP的实现，代码规范（变量名清晰，使用`constexpr`定义数组大小），状态转移方程与题目条件完全匹配。适合理解基础DP思路，但未进行空间优化，适合作为入门参考。

**题解三：作者_7Mr（赞：1）**
* **点评**：此题解通过分类讨论详细解释了状态转移的逻辑（解毒菜和毒药的不同处理），代码中对每一步的状态更新有明确注释。虽然使用二维数组，但对状态转移的理解有帮助，适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解题策略：
</difficulty_intro>

1.  **关键点1：状态定义的准确性**
    * **分析**：状态需明确表示当前是否中毒（0=健康，1=中毒）。优质题解均使用`dp[i][0/1]`，确保覆盖所有可能状态。例如，`dp[i][0]`表示处理前i道菜后健康的最大美味度，`dp[i][1]`表示中毒的最大美味度。
    * 💡 **学习笔记**：状态定义是DP的基石，需覆盖所有可能情况且无后效性。

2.  **关键点2：状态转移方程的推导**
    * **分析**：根据当前菜的类型（X=0或1），枚举所有可能的选择（吃或不吃）。例如，X=0（解毒菜）时，吃可以从健康或中毒状态转移到健康；X=1（毒药）时，吃只能从健康转移到中毒。
    * 💡 **学习笔记**：转移方程需枚举所有合法操作，取最大值。

3.  **关键点3：负美味度的处理**
    * **分析**：当Y_i为负时，选择吃可能降低总美味度。优质题解通过取`max`自动过滤负贡献（如`max(dp[i-1][0], dp[i-1][0]+Y_i)`会忽略Y_i为负的情况）。
    * 💡 **学习笔记**：动态规划的`max`操作会自动选择最优解，无需额外判断。

### ✨ 解题技巧总结
- **状态压缩**：用滚动数组（如`healthy`和`upset`）优化空间，避免O(N)空间（适用于大N）。
- **分类讨论**：按菜的类型（X=0或1）分别处理状态转移，逻辑更清晰。
- **边界初始化**：初始状态（未吃任何菜）健康和中毒的美味度均为0（因为没吃任何菜）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先看一个空间优化的通用核心实现，适合处理大N的情况：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了c1ampy的滚动数组优化思路，空间复杂度O(1)，高效处理N=3e5的情况。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        long long healthy = 0, upset = 0;
        int n;
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            long long type, tastiness;
            scanf("%lld %lld", &type, &tastiness);
            if (type) { // 当前是毒药
                upset = max(upset, healthy + tastiness);
            } else { // 当前是解毒剂
                healthy = max(healthy, max(upset, healthy) + tastiness);
            }
        }
        printf("%lld\n", max(upset, healthy));
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码使用`healthy`和`upset`分别表示当前健康和中毒状态的最大美味度。遍历每道菜时，根据类型（毒药或解毒剂）更新状态：毒药只能从健康状态吃，解毒剂可从健康或中毒状态吃。最后取两种状态的最大值作为答案。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者c1ampy**
* **亮点**：滚动数组优化，空间复杂度O(1)，适合大N场景。
* **核心代码片段**：
    ```cpp
    long long healthy = 0, upset = 0;
    for (int i = 1; i <= n; ++i) {
        long long type, tastiness;
        scanf("%lld %lld", &type, &tastiness);
        if (type) {
            upset = max(upset, healthy + tastiness);
        } else {
            healthy = max(healthy, max(upset, healthy) + tastiness);
        }
    }
    ```
* **代码解读**：
    > `healthy`和`upset`分别记录当前健康和中毒状态的最大美味度。处理毒药（type=1）时，只能从健康状态吃，所以`upset`更新为`max(原upset, healthy + Y_i)`；处理解毒剂（type=0）时，吃可以从健康或中毒状态转移，所以`healthy`更新为`max(原healthy, max(upset, healthy) + Y_i)`。
* 💡 **学习笔记**：滚动数组优化能大幅减少内存使用，适合处理大规模数据。

**题解二：作者hellolin**
* **亮点**：二维DP直观展示状态转移，适合理解基础逻辑。
* **核心代码片段**：
    ```cpp
    int dp[N][2];
    for(int i=1; i<=n; i++){
        cin >> x >> y;
        if(!x) {
            dp[i][0] = max({dp[i-1][0]+y, dp[i-1][0], dp[i-1][1]+y});
            dp[i][1] = dp[i-1][1];
        } else {
            dp[i][0] = dp[i-1][0];
            dp[i][1] = max({dp[i-1][0]+y, dp[i-1][1]});
        }
    }
    ```
* **代码解读**：
    > `dp[i][0]`表示前i道菜后健康的最大美味度。解毒剂（x=0）时，`dp[i][0]`取“前健康+吃”“前健康+不吃”“前中毒+吃”的最大值；毒药（x=1）时，`dp[i][1]`取“前健康+吃”“前中毒+不吃”的最大值。
* 💡 **学习笔记**：二维DP适合新手理解状态转移，是滚动数组优化的基础。

**题解三：作者_7Mr**
* **亮点**：详细注释分类讨论，逻辑清晰。
* **核心代码片段**：
    ```cpp
    if(a[i].x==0) { // 解药
        dp[0][i] = max(dp[0][i-1], max(dp[0][i-1]+a[i].y, dp[1][i-1]+a[i].y));
        dp[1][i] = dp[1][i-1];
    } else { // 毒药
        dp[1][i] = max(dp[0][i-1]+a[i].y, dp[1][i-1]);
        dp[0][i] = dp[0][i-1];
    }
    ```
* **代码解读**：
    > 解毒菜时，健康状态（dp[0][i]）可以来自“前健康不吃”“前健康吃”或“前中毒吃”；中毒状态（dp[1][i]）只能保持前中毒状态。毒药时，中毒状态可以来自“前健康吃”或“前中毒不吃”；健康状态只能保持前健康状态。
* 💡 **学习笔记**：分类讨论是处理不同条件的关键，需覆盖所有可能情况。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解动态规划的状态转移，我们设计一个“餐厅冒险”像素动画，用8位复古风格展示每一步的状态变化和美味度累加！
</visualization_intro>

  * **动画演示主题**：像素餐厅的状态冒险
  * **核心演示内容**：展示每道菜的选择（吃/不吃）如何影响高桥君的状态（健康/中毒）和总美味度，动态更新`healthy`和`upset`的值。
  * **设计思路简述**：8位像素风格（FC红白机配色）营造轻松氛围；状态条（绿色=健康，红色=中毒）实时显示当前状态；美味度用数字气泡累加，关键操作（如吃解毒菜切换状态）伴随“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
        - 背景是像素餐厅，屏幕下方显示“健康值”（绿色条）和“中毒值”（红色条），顶部显示总美味度（黄色数字）。
        - 控制面板：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。
    2. **上菜与选择**：
        - 第i道菜（像素图标，X=0为蓝色，X=1为红色）从屏幕右侧滑入，显示Y_i值。
        - 自动演示时，算法自动选择吃或不吃（根据DP逻辑）；手动单步时，用户可点击“吃”或“不吃”按钮。
    3. **状态转移动画**：
        - 吃解毒菜（X=0）：若当前健康，健康条保持绿色，美味度增加；若当前中毒，中毒条变绿（健康），美味度增加，伴随“叮咚”音效。
        - 吃毒药（X=1）：若当前健康，健康条变红（中毒），美味度增加，伴随“叮”音效；若当前中毒，屏幕闪烁红色（死亡，需重置）。
        - 不吃：状态条和美味度不变，伴随“唰”的音效（菜被移走）。
    4. **目标达成**：
        - 处理完所有菜后，总美味度用金色数字高亮，播放“胜利”音效（如《超级玛丽》通关音乐）。

  * **旁白提示**：
    - “当前是第i道菜，类型是X=0（解毒剂），美味度Y_i！”
    - “选择吃的话，健康状态会保持（或中毒变健康），总美味度+Y_i！”
    - “选择不吃，状态和美味度不变哦~”

<visualization_conclusion>
通过这个像素动画，我们能直观看到每一步的选择如何影响状态和总美味度，动态规划的状态转移不再抽象！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
动态规划在状态转移类问题中应用广泛，以下是一些相似题目和练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 状态定义（如健康/中毒、选/不选）和转移方程推导是动态规划的核心，可迁移到“背包问题”“股票买卖”等场景。
      - 滚动数组优化适用于仅依赖前一步状态的问题（如斐波那契数列、本题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1048 采药** 
        * 🗣️ **推荐理由**：经典0-1背包问题，练习“选或不选”的状态转移。
    2.  **洛谷 P1868 [ZJOI2007] 色板游戏** 
        * 🗣️ **推荐理由**：多状态动态规划，练习复杂状态转移方程的推导。
    3.  **洛谷 P1273 有线电视网** 
        * 🗣️ **推荐理由**：树形DP，练习状态定义和子树处理，提升动态规划综合能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解作者c1ampy提到：“使用滚动数组优化空间，避免了O(N)内存，适合处理大N的情况。”这对竞赛编程非常重要！
</insights_intro>

> **参考经验 (来自c1ampy)**：“在处理大规模数据时，滚动数组优化能显著减少内存使用。本题中，每一步的状态仅依赖前一步，因此可以用两个变量代替二维数组。”
>
> **点评**：这位作者的经验提醒我们，动态规划中若状态仅依赖前一步，应优先考虑滚动数组优化。这不仅节省内存，还能提升代码效率，避免因内存限制导致的错误。

-----

<conclusion>
本次关于“ABC306D Poisonous Full-Course”的分析就到这里。通过动态规划的状态定义和转移，我们能高效解决这类选择问题。希望大家通过练习巩固，下次挑战更难的题目！💪
</conclusion>

-----

---
处理用时：129.76秒
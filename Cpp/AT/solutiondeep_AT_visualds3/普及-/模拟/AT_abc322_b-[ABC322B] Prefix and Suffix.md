# 题目信息

# [ABC322B] Prefix and Suffix

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc322/tasks/abc322_b

英小文字からなる文字列 $ S,\ T $ が与えられます。$ S $ の長さは $ N $、$ T $ の長さは $ M $ です。($ N\ \leq\ M $ が制約で保証されています)

$ S $ が $ T $ の **接頭辞** であるとは、$ T $ のはじめ $ N $ 文字からなる文字列が $ S $ と一致することを言います。  
 $ S $ が $ T $ の **接尾辞** であるとは、$ T $ の後ろ $ N $ 文字からなる文字列が $ S $ と一致することを言います。

$ S $ が $ T $ の接頭辞であり、かつ接尾辞でもある場合は $ 0 $ を、  
 $ S $ が $ T $ の接頭辞であるが、接尾辞でない場合は $ 1 $ を、  
 $ S $ が $ T $ の接尾辞であるが、接頭辞でない場合は $ 2 $ を、  
 $ S $ が $ T $ の接頭辞でも接尾辞でもない場合は $ 3 $ を出力してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ M\ \leq\ 100 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
- $ T $ は英小文字からなる長さ $ M $ の文字列
 
### Sample Explanation 1

$ S $ は $ T $ の接頭辞ですが接尾辞ではありません。よって $ 1 $ を出力します。

### Sample Explanation 2

$ S $ は $ T $ の接尾辞ですが接頭辞ではありません。

### Sample Explanation 3

$ S $ は $ T $ の接頭辞でも接尾辞でもありません。

### Sample Explanation 4

$ S $ と $ T $ が完全に一致する場合もあります。この場合、$ S $ は $ T $ の接頭辞であり、かつ接尾辞でもあります。

## 样例 #1

### 输入

```
3 7

abc

abcdefg```

### 输出

```
1```

## 样例 #2

### 输入

```
3 4

abc

aabc```

### 输出

```
2```

## 样例 #3

### 输入

```
3 3

abc

xyz```

### 输出

```
3```

## 样例 #4

### 输入

```
3 3

aaa

aaa```

### 输出

```
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC322B] Prefix and Suffix 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC322B] Prefix and Suffix”这道C++编程题。这道题主要考察字符串的前缀和后缀判断，通过学习，大家将掌握如何高效比较字符串的特定子串，并根据结果输出对应状态。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理`

🗣️ **初步分析**：
解决这道题的关键在于判断字符串`S`是否是`T`的前缀或后缀。字符串处理的核心思想就像“找拼图块”——我们需要从长字符串`T`中“切”出与`S`长度相同的前半部分（前缀）和后半部分（后缀），然后和`S`这块“拼图”比对，看是否完全吻合。

在本题中，我们需要完成两个关键比对：
1. **前缀比对**：检查`T`的前`N`个字符是否等于`S`；
2. **后缀比对**：检查`T`的后`N`个字符是否等于`S`（即从`T`的第`M-N`位开始取`N`个字符）。

根据这两个比对的结果（是/否），我们会得到四种情况，对应输出`0`到`3`。例如，样例1中`S=abc`，`T=abcdefg`，前缀比对成功（`T`前3位是`abc`），但后缀比对失败（`T`后3位是`efg`），所以输出`1`。

核心算法流程非常直观：提取子串→比对→根据结果分类。在可视化设计中，我们可以用像素块动态展示子串的提取过程（比如用箭头高亮“切割”位置），并用不同颜色标记比对结果（绿色表示匹配，红色表示不匹配），配合“叮”的音效提示匹配成功，增强直观性。

---

## 2. 精选优质题解参考

<eval_intro>
由于当前提供的题解信息中“暂无题解”，Kay将从学习角度给出以下通用建议：
</eval_intro>

**学习建议**：
- 字符串比对时，注意子串的起始位置和长度。例如，取`T`的后缀时，起始位置是`M-N`（因为`T`的索引从0开始），长度是`N`；
- 逻辑判断时，优先检查“同时是前缀和后缀”的情况（输出0），避免被其他条件覆盖；
- 可以通过测试样例验证代码，例如当`N=M`时，前缀和后缀是同一个子串（即整个`T`），此时只需一次比对即可判断是否输出0或3。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们可能会遇到以下关键点。通过分析，Kay为大家总结了应对策略：
</difficulty_intro>

1.  **关键点1**：如何正确提取`T`的前缀和后缀子串？
    * **分析**：提取子串时，前缀是`T`的前`N`个字符（即从索引0开始，取`N`个字符），后缀是`T`的后`N`个字符（即从索引`M-N`开始，取`N`个字符）。例如，当`T`长度为7（索引0-6），`N=3`时，后缀的起始索引是`7-3=4`（索引4-6）。
    * 💡 **学习笔记**：子串提取的公式要记牢：前缀`T.substr(0, N)`，后缀`T.substr(M-N, N)`。

2.  **关键点2**：如何处理`N=M`的特殊情况？
    * **分析**：当`N=M`时，`T`的前缀和后缀其实是同一个子串（即整个`T`）。此时只需比较`S`和`T`是否完全相等：相等则输出0，否则输出3。
    * 💡 **学习笔记**：特殊情况需要优先考虑，避免逻辑错误。

3.  **关键点3**：如何确保逻辑判断的顺序正确？
    * **分析**：判断顺序应优先检查“同时是前缀和后缀”（输出0），否则再分别检查前缀（输出1）、后缀（输出2），最后都不满足则输出3。如果顺序错误（例如先检查前缀再检查同时满足的情况），会导致结果错误。
    * 💡 **学习笔记**：逻辑判断的顺序决定了结果的正确性，需要按照题目要求的优先级排列。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我们可以总结以下通用技巧：
- **子串提取公式化**：遇到类似前缀/后缀问题时，用`substr`函数的起始位置和长度参数快速定位子串；
- **边界情况单独处理**：如`N=M`时，简化判断逻辑；
- **测试样例验证**：用题目提供的样例（如样例4中`S=T`的情况）验证代码，确保覆盖所有可能场景。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
虽然暂无题解，但Kay为大家整理了一个通用的核心C++实现，帮助大家快速掌握解题框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于题目要求，直接实现了前缀和后缀的比对逻辑，结构清晰，适合新手学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        int N, M;
        string S, T;
        cin >> N >> M >> S >> T;

        // 判断是否是前缀
        bool is_prefix = (T.substr(0, N) == S);
        // 判断是否是后缀（T的后N个字符）
        bool is_suffix = (T.substr(M - N, N) == S);

        if (is_prefix && is_suffix) {
            cout << 0 << endl;
        } else if (is_prefix) {
            cout << 1 << endl;
        } else if (is_suffix) {
            cout << 2 << endl;
        } else {
            cout << 3 << endl;
        }

        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入的`N`（S的长度）、`M`（T的长度）、字符串`S`和`T`。然后通过`substr`函数提取`T`的前缀（前`N`字符）和后缀（后`N`字符），分别与`S`比对，得到两个布尔值`is_prefix`和`is_suffix`。最后根据这两个布尔值的组合，输出对应的结果（0-3）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解如何比对前缀和后缀，Kay设计了一个“像素拼图”动画，让我们一起“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素拼图大挑战`

  * **核心演示内容**：用8位像素风格展示`T`的前缀和后缀如何被“切割”并与`S`比对，最终根据结果点亮不同颜色的灯（0-3号灯）。

  * **设计思路简述**：采用复古像素风是为了让学习更轻松有趣。通过动态“切割”`T`的字符块、高亮比对过程，配合音效提示匹配结果，帮助大家直观理解子串提取和比对的逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示`S`（3个黄色像素块，如`a`、`b`、`c`）；右侧显示`T`（7个蓝色像素块，如`a`、`b`、`c`、`d`、`e`、`f`、`g`）；
          * 底部有“开始”按钮和“单步”按钮，右侧显示“结果灯”（0-3号，初始灰色）；
          * 播放8位风格的轻快背景音乐。

    2.  **前缀比对演示**：
          * 点击“开始”后，动画自动运行。首先，`T`的前3个像素块（索引0-2）被红色框框住，显示“切割前缀”；
          * 这3个像素块从`T`中“滑动”到`S`下方，逐个比对：如果字符相同（如`a`对`a`），像素块变绿色并播放“叮”音效；不同则变红色并播放“嗒”音效；
          * 比对完成后，显示“前缀匹配：是”或“否”（用绿色/红色文字）。

    3.  **后缀比对演示**：
          * 接着，`T`的后3个像素块（索引4-6）被蓝色框框住，显示“切割后缀”；
          * 这3个像素块同样滑动到`S`下方，逐个比对，规则同上；
          * 显示“后缀匹配：是”或“否”。

    4.  **结果输出**：
          * 根据两个比对结果，对应的“结果灯”（如样例1的1号灯）亮起金色，伴随“胜利”音效；
          * 同时，屏幕上方显示“最终结果：1”。

    5.  **交互控制**：
          * 支持“单步”操作，学习者可手动控制每一步比对过程，观察细节；
          * 点击“重置”按钮可回到初始状态，重新开始演示。

  * **旁白提示**：
      * （前缀比对时）“看！我们正在提取T的前3个字符，和S的每个字符一一比对～”；
      * （后缀比对时）“现在提取T的后3个字符，注意起始位置是M-N=4哦！”；
      * （结果输出时）“两个比对结果分别是‘是’和‘否’，所以输出1啦！”

<visualization_conclusion>
通过这个“像素拼图”动画，我们不仅能看到子串是如何被提取的，还能直观感受比对过程，轻松理解算法逻辑～
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
字符串的前缀和后缀处理是字符串操作的基础，掌握后可以解决更多类似问题！
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 子串提取和比对的方法，还可以用于判断回文串（如判断字符串是否对称）、查找重复子串（如判断是否存在连续重复的模式）、处理文件路径（如提取文件名或扩展名）等场景。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上的字符串处理题目，建议大家尝试：

    1.  **洛谷 P1125** - `笨小猴`
          * 🗣️ **推荐理由**：这道题需要判断字符串中字母的出现次数是否为质数，能帮助你巩固字符串的字符统计和基本操作。
    2.  **洛谷 P1308** - `统计单词数`
          * 🗣️ **推荐理由**：此题涉及单词的前缀匹配（区分大小写和全词匹配），能强化子串比对和边界处理的能力。
    3.  **洛谷 P5733** - `【深基6.例1】自动修正`
          * 🗣️ **推荐理由**：这道题需要将字符串中的小写字母转为大写，练习字符串的遍历和修改操作。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
本次关于“[ABC322B] Prefix and Suffix”的分析就到这里。通过理解子串提取和比对的逻辑，相信大家已经掌握了这类问题的解题方法。记得多动手编写代码，用不同的测试样例验证，提升自己的编程能力！下次见～💪
</conclusion>

---
处理用时：102.82秒
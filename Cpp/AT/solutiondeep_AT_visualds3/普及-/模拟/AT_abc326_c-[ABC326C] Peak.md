# 题目信息

# [ABC326C] Peak

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc326/tasks/abc326_c

高橋くんは数直線上に $ N $ 個のプレゼントを置きました。そのうち $ i $ 個目のプレゼントは座標 $ A_i $ に置かれました。

あなたは数直線上の長さ $ M $ の半開区間 $ [x,x+M) $ を選び、そこに含まれるプレゼントを全て獲得します。  
 より詳しくは、以下の手順でプレゼントを獲得します。

- まず、実数 $ x $ をひとつ選択する。
- その後、プレゼントのうち置かれている座標が $ x\ \le\ A_i\ <\ x+M $ を満たすものを全て獲得する。
 
最大でいくつのプレゼントを獲得することができますか?

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ 1\ \le\ M\ \le\ 10^9 $
- $ 0\ \le\ A_i\ \le\ 10^9 $
 
### Sample Explanation 1

例えば、半開区間 $ [1.5,7.5) $ を指定します。 このとき、座標 $ 2,3,5,7 $ にある $ 4 $ つのプレゼントを全て獲得することができ、これが獲得可能な最大の個数です。

### Sample Explanation 2

同一の座標に複数のプレゼントが置いてあることもあります。

## 样例 #1

### 输入

```
8 6

2 3 5 7 11 13 17 19```

### 输出

```
4```

## 样例 #2

### 输入

```
10 1

3 1 4 1 5 9 2 6 5 3```

### 输出

```
2```

## 样例 #3

### 输入

```
10 998244353

100000007 0 1755647 998244353 495 1000000000 1755648 503 1755649 998244853```

### 输出

```
7```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC326C] Peak 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC326C] Peak”这道题。这道题的核心是在数轴上找到一个长度为M的半开区间，使得其中包含的礼物数量最多。通过分析题解，我们会发现双指针和二分查找是关键方法。让我们一步步拆解问题，掌握解题技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`滑动窗口（双指针）/二分查找`

🗣️ **初步分析**：
解决这道题的关键在于高效地找到覆盖最多礼物的区间。想象一下，数轴上的礼物像珠子一样排列，我们需要用一根长度为M的“魔法棒”（半开区间）去覆盖最多的珠子。直接暴力枚举每个可能的区间会超时，所以需要优化。

### 核心思路对比：
- **双指针法**（更优）：先将礼物坐标排序，然后用两个指针`l`和`r`表示区间的左右边界。`r`指针不断右移扩展区间，当区间长度超过M时，`l`指针右移收缩区间。这样每个元素最多被访问两次，时间复杂度为O(n)（排序为O(n log n)）。
- **二分查找法**：同样先排序，对每个左端点`a[i]`，用二分查找找到最大的`a[j]`满足`a[j] < a[i]+M`，计算`j-i+1`的最大值。时间复杂度为O(n log n)（排序）+O(n log n)（二分）。

### 可视化设计思路：
我们设计一个“像素寻宝”动画：在8位像素风格的数轴上，礼物用彩色方块表示（如红色），双指针用左右箭头图标（蓝色和绿色）。当`r`指针右移时，对应方块闪烁并播放“叮”音效；当`l`指针右移时，左侧方块变暗。每次更新最大值时，屏幕边缘弹出“新记录！”的像素文字，并播放上扬的音效。这样能直观看到区间的动态调整过程。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选出以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者rainygame**
* **点评**：这道题解思路非常清晰，直接点明“x选在礼物坐标上更优”，并通过双指针法高效求解。代码简洁规范（如`r`指针的命名直观），排序后利用双指针一次遍历，时间复杂度O(n)，非常适合竞赛场景。边界处理（`a[n+1]=INT_MAX`）避免了越界问题，是严谨的体现。

**题解二：作者kimidonatsu**
* **点评**：此题解同样使用双指针法，逻辑与rainygame的题解类似，但变量名（如`i64`、`INF`）体现了对数据类型的严谨性。代码结构工整，注释清晰，适合新手学习如何将思路转化为规范代码。

**题解三：作者xxr___**
* **点评**：此题解采用二分查找法，虽然时间复杂度稍高，但思路明确。通过`lower_bound`快速找到右边界，代码简洁。适合理解二分查找在区间问题中的应用，对巩固二分技巧有帮助。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们通常会遇到以下关键点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：为什么选择礼物坐标作为区间左端点？**
    * **分析**：假设区间左端点`x`不在任何礼物坐标上，那么将`x`右移到最近的礼物坐标`a[i]`时，区间可能覆盖更多礼物（因为原区间左侧可能没有礼物，而右侧可能包含更多）。因此，最优解的左端点一定在某个礼物坐标上。
    * 💡 **学习笔记**：遇到区间覆盖问题时，优先考虑端点在关键点（如输入数据点）上，可减少无效枚举。

2.  **关键点2：如何高效找到每个左端点对应的右端点？**
    * **分析**：排序后，礼物坐标是递增的。对于左端点`a[i]`，右端点`a[r]`是最大的满足`a[r] < a[i]+M`的坐标。双指针法中，`r`指针只需从当前位置开始右移（无需回退），因为数组有序；二分查找则通过`lower_bound`快速定位。
    * 💡 **学习笔记**：有序数组的区间问题，双指针或二分查找是高效的“标配”方法。

3.  **关键点3：如何处理重复坐标？**
    * **分析**：题目允许礼物在同一坐标（如样例2）。排序后，重复坐标会相邻，双指针或二分查找会自然包含这些重复点（因为`a[r] < a[i]+M`允许相等），无需额外处理。
    * 💡 **学习笔记**：输入数据可能有重复，算法设计时要确保对重复值的包容性。

### ✨ 解题技巧总结
- **排序是基础**：所有题解都先排序，这是后续双指针或二分查找的前提。
- **双指针的“单调性”**：数组有序时，`r`指针只需单向移动，避免了重复计算，时间复杂度最优。
- **边界值处理**：在数组末尾添加极大值（如`a[n+1]=INT_MAX`），可避免越界错误，是竞赛中的常见技巧。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，选择双指针法的实现作为通用核心代码，因其时间复杂度最优且逻辑清晰。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了rainygame和kimidonatsu的题解思路，采用双指针法，时间复杂度O(n log n)（排序）+O(n)（双指针），适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        
        int n, m;
        cin >> n >> m;
        vector<ll> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        sort(a.begin(), a.end());
        a.push_back(LLONG_MAX); // 避免越界
        
        int ans = 0, r = 0;
        for (int i = 0; i < n; ++i) {
            while (a[r] < a[i] + m) {
                ++r;
            }
            ans = max(ans, r - i);
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    1. 输入并排序礼物坐标，末尾添加极大值防止越界。
    2. 双指针`i`（左端点）和`r`（右端点）遍历数组。`r`指针找到第一个不小于`a[i]+m`的位置，此时区间`[i, r-1]`内的礼物都满足条件。
    3. 不断更新`ans`为最大区间长度。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者rainygame**
* **亮点**：代码简洁，利用`a[n+1]=INT_MAX`处理边界，双指针逻辑清晰。
* **核心代码片段**：
    ```cpp
    sort(a+1, a+n+1);
    a[n+1] = INT_MAX;
    for (int i(1); i<=n; ++i){
        while (r <= n+1 && a[i]+m > a[r]) ++r;
        ans = max(ans, r-i);
    }
    ```
* **代码解读**：
    - `sort`排序后，`a[n+1]`设为极大值，确保`r`指针能遍历到所有元素。
    - `while`循环中，`r`指针右移直到`a[r] >= a[i]+m`，此时`r-i`即为区间内的礼物数（因为`a[i]`到`a[r-1]`都满足条件）。
    - 每次更新`ans`为最大值，最终输出。
* 💡 **学习笔记**：边界值的设置能有效避免越界错误，是竞赛代码的常见技巧。

**题解二：作者kimidonatsu**
* **亮点**：使用`i64`类型，避免溢出；代码结构工整，注释清晰。
* **核心代码片段**：
    ```cpp
    std::sort(a.begin() + 1, a.begin() + n + 1);
    a[n + 1] = INF;
    i64 ans = -INF;
    i64 r = 1;
    for (i64 i = 1; i <= n; i++) {
        while (a[r] < a[i] + m) r++;
        ans = std::max(ans, r - i);
    }
    ```
* **代码解读**：
    - `INF`定义为极大值，防止越界。
    - `r`指针初始化为1，随`i`递增而右移，利用数组有序性，每个元素仅被访问一次。
    - `r-i`计算当前区间的礼物数，逻辑与rainygame的题解一致。
* 💡 **学习笔记**：合理使用长整型（如`i64`）可避免大数溢出问题，提升代码鲁棒性。

**题解三：作者xxr___（二分查找法）**
* **亮点**：二分查找实现简洁，适合理解二分在区间问题中的应用。
* **核心代码片段**：
    ```cpp
    sort(a+1,a+n+1);
    for(int i=1;i<=n;++i){
        int pos=lower_bound(a+1,a+n+1,a[i]+m)-a -i;
        maxn=max(maxn,pos);
    }
    ```
* **代码解读**：
    - `lower_bound`找到第一个不小于`a[i]+m`的位置，减`i`得到区间内的礼物数（因为`a[i]`到`pos-1`都满足条件）。
    - 二分查找的时间复杂度为O(log n)，外层循环O(n)，总复杂度O(n log n)。
* 💡 **学习笔记**：二分查找适用于有序数组的快速定位，是解决区间问题的另一种有效方法。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解双指针法的工作流程，我们设计一个“像素寻宝大冒险”动画，用8位复古风格展示区间的动态调整过程！
</visualization_intro>

  * **动画演示主题**：像素世界的礼物大收集！
  * **核心演示内容**：数轴上的礼物用红色方块表示，双指针`l`（左箭头，蓝色）和`r`（右箭头，绿色）动态移动，覆盖的礼物区间用黄色背景高亮。每次更新最大值时，弹出“新记录！”的像素文字。

  * **设计思路简述**：
    - 8位像素风格（如FC游戏画面）营造轻松氛围，颜色区分不同元素（红色礼物、蓝绿指针、黄色区间）帮助记忆。
    - 音效（“叮”声对应指针移动，上扬音对应最大值更新）强化操作反馈，增加趣味性。

  * **动画帧步骤与交互关键点**：
    1. **初始化**：数轴背景（黑色），礼物方块（红色）按排序后的坐标排列。控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（1x-5x）。
    2. **排序动画**：礼物方块从乱序（随机位置）逐渐移动到有序位置（从小到大排列），播放“滑动”音效。
    3. **双指针移动**：
       - `i`指针（左箭头）从第一个礼物开始，`r`指针（右箭头）初始在`i`位置。
       - `r`指针右移，每经过一个礼物，该礼物变黄（表示被覆盖），播放“叮”声。
       - 当`a[r] >= a[i]+m`时，`r`停止，此时黄色区间的长度（`r-i`）显示在屏幕上方。
       - `i`指针右移，左侧礼物变灰（退出区间），`r`指针继续右移，重复上述过程。
    4. **最大值更新**：当当前区间长度超过历史最大值时，屏幕边缘弹出“新记录！”的像素文字，播放上扬音效，最大值用金色数字高亮。
    5. **结束动画**：所有指针移动完成后，最终最大值用闪烁的金色显示，播放胜利音效。

  * **旁白提示**：
    - “看！左箭头（i）指向当前区间的起点，右箭头（r）在找能覆盖的最远礼物～”
    - “当右箭头碰到超过区间长度的礼物时，左箭头要右移，缩小范围哦！”
    - “新记录诞生！这个区间覆盖了最多的礼物，太厉害啦～”

<visualization_conclusion>
通过这个动画，我们能直观看到双指针如何动态调整区间，以及最大值是如何被一步步更新的。这种“看得见”的算法执行过程，能帮助我们更快掌握核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了这道题的解法后，我们可以将双指针或二分查找的思路迁移到更多问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 双指针法适用于有序数组的区间问题（如最长连续子数组、两数之和等）。
    - 二分查找适用于需要快速定位边界的问题（如查找插入位置、寻找峰值等）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1102 A-B数对** - 这道题需要统计满足`A-B=C`的数对数量，排序后用双指针或二分查找统计，巩固区间计数技巧。
    2.  **洛谷 P1235 线性存储** - 给定序列，求长度为L的连续子序列的最小和，用双指针维护滑动窗口的和，锻炼窗口动态调整能力。
    3.  **洛谷 P2678 跳石头** - 二分查找求最大最小跳跃距离，结合贪心判断，提升二分与条件判断的综合应用能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自作者indream)**：“一开始用暴力枚举每个区间，结果超时了。后来意识到排序后用二分或双指针更高效。调试时发现忘记排序，导致二分结果错误，调了十分钟才发现。”
>
> **点评**：这位作者的经验提醒我们，排序是这类问题的关键步骤，忘记排序会导致所有后续操作错误。在编程时，一定要先检查输入数据的预处理（如排序、去重）是否正确。此外，暴力法虽然直观，但遇到大数据时容易超时，需要及时想到优化方法（如双指针、二分）。

-----

<conclusion>
关于“[ABC326C] Peak”的分析就到这里。通过双指针或二分查找，我们能高效解决这类区间覆盖问题。希望大家通过练习巩固这些技巧，下次遇到类似问题时能快速找到最优解！💪
</conclusion>

---
处理用时：120.95秒
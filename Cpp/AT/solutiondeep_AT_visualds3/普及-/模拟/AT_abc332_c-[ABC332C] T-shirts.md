# 题目信息

# [ABC332C] T-shirts

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc332/tasks/abc332_c

AtCoder 社は[ロゴ入りの T シャツ](https://suzuri.jp/AtCoder/5510290/t-shirt/s/ash)を販売しています。

高橋君の $ N $ 日間の予定が `0`, `1`, `2` のみからなる長さ $ N $ の文字列 $ S $ で与えられます。  
具体的には、$ 1\leq\ i\leq\ N $ をみたす整数 $ i $ について、

- $ S $ の $ i $ 文字目が `0` のとき、$ i $ 日目に何の予定も入っていません。
- $ S $ の $ i $ 文字目が `1` のとき、$ i $ 日目に高橋君は食事に行く予定があります。
- $ S $ の $ i $ 文字目が `2` のとき、$ i $ 日目に高橋君は競技プログラミングのイベントに行く予定が入っています。

高橋君は無地の T シャツを $ M $ 枚持っており、$ 1 $ 日目の直前の時点ですべて洗濯済みの状態となっています。  
これに加えて、次の条件をみたすように行動できるように、高橋君は AtCoder のロゴ入りの T シャツを何枚か購入する事にしました。

- 食事に行く日には、無地の T シャツ $ 1 $ 枚またはロゴ入りの T シャツ $ 1 $ 枚を着用する。
- 競技プログラミングのイベントに行く日にはロゴ入りの T シャツ $ 1 $ 枚を着用する。
- 何の予定もない日には T シャツを着用しない。加えて、その時点で着用済みの T シャツを全て洗濯する。 洗濯した T シャツは翌日から着用できる。
- 一度着用した T シャツは次に洗濯するまで着用できない。

$ N $ 日間のうち予定が入っている日すべてについて、条件をみたす T シャツを着用できるようにするために、高橋君は最低何枚のTシャツを購入する必要があるか求めてください。 新しく T シャツを購入する必要がないならば $ 0 $ を出力してください。  
ただし、購入した T シャツも $ 1 $ 日目の直前の時点ですべて洗濯済みの状態で存在するものとします。

## 说明/提示

### 制約

- $ 1\leq\ M\leq\ N\leq\ 1000 $
- $ S $ は `0`, `1`, `2` のみからなる長さ $ N $ の文字列
- $ N,M $ は整数

### Sample Explanation 1

高橋君がロゴ入りの T シャツを $ 2 $ 枚購入したとき、次のようにして高橋君は T シャツを着用することができます。 - $ 1 $ 日目、高橋君はロゴ入りの T シャツを着用して食事に行きます。 - $ 2 $ 日目、高橋君は無地の T シャツを着用して食事に行きます。 - $ 3 $ 日目、高橋君はロゴ入りの T シャツを着用して競技プログラミングのイベントに行きます。 - $ 4 $ 日目、高橋君は予定がないため、着用した T シャツをすべて洗濯します。これにより、$ 1,2,3 $ 日目に着用した T シャツを再び着用することが可能になります。 - $ 5 $ 日目、高橋君はロゴ入りの T シャツを着用して競技プログラミングのイベントに行きます。 - $ 6 $ 日目、高橋君はロゴ入りの T シャツを着用して競技プログラミングのイベントに行きます。 高橋君がロゴ入りの T シャツを $ 1 $ 枚以下しか購入しなかった場合には、 どのようにしても条件をみたすように T シャツを着用することができません。 よって、$ 2 $ を出力します。

### Sample Explanation 3

高橋君は新しく T シャツを購入する必要はありません。

## 样例 #1

### 输入

```
6 1
112022```

### 输出

```
2```

## 样例 #2

### 输入

```
3 1
222```

### 输出

```
3```

## 样例 #3

### 输入

```
2 1
01```

### 输出

```
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC332C] T-shirts 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC332C] T-shirts”这道题。这道题需要我们计算高桥君最少需要购买多少件带有AtCoder标志的T恤（简称“logoT恤”），才能满足N天的日程安排。通过本指南，你将理解核心思路、关键算法，并掌握如何用代码实现。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略与二分答案的综合应用（以贪心为主）

🗣️ **初步分析**：
解决这道题的关键在于理解“优先使用普通T恤，不足时再用logoT恤”的贪心思想。贪心策略就像我们整理书包时，优先用已有的文具，不够用了才买新的。在本题中，普通T恤是“已有的文具”，logoT恤是“新文具”，我们需要在满足条件的前提下，尽可能少买新的（logoT恤）。

### 核心思路与难点
- **核心思路**：遍历每一天的日程，维护当前可用的普通T恤（初始为M件）和已购买的logoT恤数量。遇到`1`（吃饭）时优先用普通T恤，不够再用logoT恤；遇到`2`（竞赛）时只能用logoT恤；遇到`0`（无安排）时，所有穿过的T恤被洗干净，重置为初始状态。
- **核心难点**：
  1. 如何正确维护“清洗”后的T恤可用数量（即遇到`0`时重置状态）。
  2. 如何动态计算需要购买的logoT恤数量（特别是连续多天需要logoT恤的情况）。
  3. 验证最少购买量时，如何高效判断某个数量是否可行（二分法的应用）。

### 可视化设计思路
我们将用8位像素风格模拟每一天的T恤使用过程：
- 屏幕左侧用绿色方块表示可用的普通T恤（初始M个），红色方块表示可用的logoT恤（初始为购买量）。
- 遇到`1`时，绿色方块减少（优先使用），若绿色用完则红色减少；遇到`2`时，红色方块直接减少。
- 遇到`0`时，绿色和红色方块重置为初始数量（伴随“唰”的清洗音效）。
- 购买logoT恤时，红色方块数量增加（伴随“叮”的购买音效）。
- 控制面板支持单步执行、自动播放（可调速），关键步骤高亮（如切换到`0`天时，所有方块闪烁）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解（评分≥4星），帮助大家理解不同解法的优势。
</eval_intro>

**题解一：贪心模拟（作者：xxr___）**
* **点评**：此题解直接模拟每一天的T恤使用过程，思路简洁直白。代码中通过`ft`（当前可用普通T恤）和`bt/bt2`（当前可用/已购买的logoT恤）变量，清晰维护了状态变化。特别是遇到`0`天时重置状态的处理，符合题意要求。代码风格简洁，变量名虽短但含义明确（如`ft`是“free T-shirt”的缩写），适合初学者理解。

**题解二：二分答案（作者：rainbow_cat）**
* **点评**：此题解采用二分法寻找最小购买量，思路巧妙。通过`check`函数验证某个购买量是否可行，逻辑严谨。代码结构清晰，变量名`nnum`（普通T恤数量）和`anum`（logoT恤数量）含义明确。二分法的使用将问题复杂度从O(n^2)优化到O(n log n)，适合处理较大数据量的情况。

**题解三：贪心模拟（作者：FreedomKing）**
* **点评**：此题解将连续的非`0`天视为一个“块”，统计每个块内`1`和`2`的数量，直接计算该块需要的logoT恤数（`max(0, 1的数量-M) + 2的数量`），最后取所有块的最大值。这种分块处理的思路非常巧妙，简化了状态维护，代码简洁高效。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，以下三个关键点需要特别注意：
</difficulty_intro>

1.  **关键点1：如何处理“清洗”操作（`0`天）？**
    * **分析**：遇到`0`天时，所有穿过的T恤被洗干净，可用数量重置为初始状态。例如，普通T恤重置为M件，logoT恤重置为已购买的数量（因为购买的T恤初始是干净的）。优质题解中，通常用`ft = m`和`bt = bt2`（或类似变量）来重置状态。
    * 💡 **学习笔记**：清洗操作是“状态重置”的信号，必须在此处将可用T恤数量恢复为初始值。

2.  **关键点2：`1`天时如何选择T恤？**
    * **分析**：`1`天可以穿普通或logoT恤，为了最小化购买量，必须优先使用普通T恤。例如，若当前还有普通T恤（`ft > 0`），则用普通；否则用logoT恤（`bt > 0`）；若两者都没有，才购买新的logoT恤（`bt2++`）。
    * 💡 **学习笔记**：贪心的核心是“能省则省”——优先用已有的（普通T恤），不够再用新买的（logoT恤）。

3.  **关键点3：如何确定最少购买量？**
    * **分析**：直接模拟可能需要遍历所有可能的购买量，效率较低。二分法通过“猜测-验证”的方式，快速找到最小可行值。例如，假设购买k件logoT恤，用`check(k)`函数验证是否满足所有天的需求，若满足则尝试更小的k，否则增大k。
    * 💡 **学习笔记**：二分法适用于“最小化最大值”或“验证可行性”的问题，能显著提高效率。

### ✨ 解题技巧总结
- **状态维护**：用变量分别记录当前可用的普通T恤和logoT恤数量，遇到`0`天及时重置。
- **优先策略**：`1`天优先用普通T恤，`2`天只能用logoT恤，这是贪心的核心。
- **分块处理**：将连续的非`0`天视为一个块，统计块内需求，简化状态变化（如FreedomKing的题解）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合贪心模拟和二分法的优势，选择一个简洁且高效的贪心模拟代码作为通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个贪心模拟题解的思路，通过维护当前可用的普通T恤和logoT恤数量，遍历每一天的日程，动态计算需要购买的logoT恤数量。代码简洁易懂，适合初学者学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        int n, m;
        string s;
        cin >> n >> m >> s;
        int available_normal = m; // 当前可用的普通T恤数量
        int available_logo = 0;   // 当前可用的logoT恤数量（已购买但未使用的）
        int bought_logo = 0;      // 已购买的logoT恤总数

        for (char day : s) {
            if (day == '0') {
                // 无安排，清洗所有T恤，重置为初始状态
                available_normal = m;
                available_logo = bought_logo;
            } else if (day == '1') {
                // 吃饭：优先用普通T恤，不够用logoT恤，都不够则购买
                if (available_normal > 0) {
                    available_normal--;
                } else if (available_logo > 0) {
                    available_logo--;
                } else {
                    bought_logo++;
                    available_logo = bought_logo - 1; // 新买的T恤已使用1件
                }
            } else if (day == '2') {
                // 竞赛：只能用logoT恤，不够则购买
                if (available_logo > 0) {
                    available_logo--;
                } else {
                    bought_logo++;
                    available_logo = bought_logo - 1; // 新买的T恤已使用1件
                }
            }
        }
        cout << bought_logo << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先读取输入，然后遍历每一天的日程：
  - `0`天时重置可用T恤数量；
  - `1`天优先用普通T恤，不够用logoT恤，都不够则购买；
  - `2`天只能用logoT恤，不够则购买；
  最终输出需要购买的logoT恤总数。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段。
</code_intro_selected>

**题解一：贪心模拟（作者：xxr___）**
* **亮点**：代码简洁，通过`ft`（普通T恤）和`bt/bt2`（logoT恤）变量清晰维护状态，适合初学者理解。
* **核心代码片段**：
    ```cpp
    int n,m,bt=0,bt2=0;
    cin>>n>>m;
    string s;
    int ft=m;
    cin>>s;
    for(int i=0;i<n;i++){
        if(s[i]=='0'){
            ft=m;bt=bt2;
        }
        if(s[i]=='1'){
            if(ft>0)ft--;
            else if(ft==0&&bt>0) bt--;
            else if(ft==0&&bt==0) bt2++;
        }
        if(s[i]=='2'){
            if(bt>0)bt--;
            else bt2++;
        }
    }
    cout<<bt2;
    ```
* **代码解读**：
  - `ft`表示当前可用的普通T恤（初始为m）；`bt`表示当前可用的已购买logoT恤；`bt2`表示已购买的logoT恤总数。
  - 遇到`0`天时，`ft`重置为m，`bt`重置为`bt2`（清洗后，已购买的logoT恤都可用）。
  - 遇到`1`天时，优先用`ft`（普通T恤），不够用`bt`（logoT恤），都不够则`bt2++`（购买新的）。
  - 遇到`2`天时，只能用`bt`，不够则`bt2++`。
* 💡 **学习笔记**：变量名虽短但含义明确，通过`bt`和`bt2`分离“当前可用”和“总购买量”，避免了状态混淆。

**题解二：二分答案（作者：rainbow_cat）**
* **亮点**：通过二分法快速找到最小购买量，时间复杂度为O(n log n)，适合处理较大数据。
* **核心代码片段**：
    ```cpp
    bool check(int x) {
        int nnum = m, anum = x; // 普通T恤和logoT恤的初始可用数量
        for(int i=1; i<=n; i++) {
            if(c[i] == '0') nnum = m, anum = x; // 清洗后重置
            else if(c[i] == '1') {
                if(nnum) nnum--; // 优先用普通T恤
                else if(anum) anum--;
                else return 0; // 都不够，x太小
            } else if(c[i] == '2') {
                if(anum) anum--;
                else return 0; // logoT恤不够，x太小
            }
        }
        return 1;
    }
    // 主函数中二分查找最小x
    while(l < r) {
        int mid = (l + r) / 2;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l;
    ```
* **代码解读**：
  - `check(x)`函数验证购买x件logoT恤是否可行：遍历每一天，维护`nnum`（普通T恤可用数）和`anum`（logoT恤可用数）。
  - 遇到`0`天重置`nnum`和`anum`；遇到`1`天优先用`nnum`，不够用`anum`；遇到`2`天只能用`anum`。
  - 主函数通过二分法找到最小的x，使得`check(x)`为真。
* 💡 **学习笔记**：二分法将问题转化为“验证可行性”，避免了遍历所有可能的购买量，提高了效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解T恤的使用过程，我们设计一个“像素洗衣店”主题的动画，用8位像素风格模拟每一天的操作。
</visualization_intro>

  * **动画演示主题**：`像素洗衣店的T恤管理`

  * **核心演示内容**：模拟高桥君N天的日程，展示普通T恤（绿色方块）和logoT恤（红色方块）的使用、清洗和购买过程。

  * **设计思路简述**：
    - 8位像素风格（FC红白机色调）营造轻松氛围，绿色/红色方块清晰区分两种T恤。
    - 清洗时方块闪烁并重置位置（伴随“唰”的音效），购买时红色方块增加（伴随“叮”的音效），关键步骤用文字气泡解释。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧是“可用T恤区”（绿色/红色方块排列），右侧是“日程区”（显示当天的`0`/`1`/`2`）。
        - 控制面板：单步/自动播放按钮、速度滑块（1x/2x/0.5x）、重置按钮。

    2.  **算法启动**：
        - 初始时，绿色方块有M个（普通T恤），红色方块有0个（未购买）。

    3.  **核心步骤演示**：
        - **`0`天**：所有方块（绿色+红色）闪烁3次，然后回到初始位置（绿色M个，红色为已购买数），播放“唰”的清洗音效，文字气泡提示“今天清洗，所有T恤可用！”。
        - **`1`天**：绿色方块优先减少（若有），否则红色方块减少。减少时方块向下滑动消失，播放“穿衣服”音效（“噗”）。若两者都没有，红色方块增加1个（购买），播放“叮”音效，文字气泡提示“购买1件logoT恤！”。
        - **`2`天**：红色方块减少（若有），否则红色方块增加1个（购买），音效和动画同上，文字气泡提示“只能穿logoT恤！”。

    4.  **目标达成**：
        - 遍历完所有天后，显示最终购买的红色方块数量（即答案），播放“胜利”音效（“啦~”），文字气泡提示“成功满足所有日程！”。

  * **旁白提示**：
    - （`0`天）“今天没安排，把穿过的T恤都洗干净啦！”
    - （`1`天，用普通T恤）“优先穿普通T恤，省着点用~”
    - （`1`天，用logoT恤）“普通T恤用完了，穿logo的吧~”
    - （购买时）“哎呀，没T恤穿了，买一件新的logoT恤！”

<visualization_conclusion>
通过这个动画，你可以直观看到每一天T恤的使用情况，理解贪心策略的核心——优先用普通T恤，不够再买logo的。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的贪心和二分思路后，可以尝试以下类似问题，巩固算法应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 贪心策略适用于“优先使用已有资源，不足时补充”的问题（如资源分配、任务调度）。
    - 二分答案适用于“最小化最大值”或“验证可行性”的问题（如求最少/最大值、最优化问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1223 排队接水**
          * 🗣️ **推荐理由**：贪心策略的典型应用，需要按接水时间排序以最小化总等待时间，与本题的“优先使用已有资源”思路类似。
    2.  **洛谷 P1873 砍树**
          * 🗣️ **推荐理由**：二分答案的经典问题，通过二分查找确定最大砍树高度，与本题的“二分验证可行性”思路一致。
    3.  **洛谷 P2678 跳石头**
          * 🗣️ **推荐理由**：结合二分答案和贪心策略，需要确定最少移除的石头数，锻炼综合算法应用能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自作者xxr___)**：“在调试时，发现`0`天时忘记重置`bt`为`bt2`，导致后续天数的logoT恤数量计算错误。后来通过打印中间变量，发现了这个问题。”

**点评**：这位作者的经验提醒我们，状态重置（如`0`天时的处理）是这类模拟题的常见易错点。调试时，打印关键变量（如`available_normal`和`available_logo`）的中间值，可以快速定位错误。这是非常实用的调试技巧！

-----

<conclusion>
通过对“[ABC332C] T-shirts”的分析，我们掌握了贪心策略和二分答案的应用，理解了如何维护状态和处理边界条件。编程的关键在于多思考、多练习，下次我们再一起挑战更难的题目！💪
</conclusion>

---
处理用时：143.90秒
# 题目信息

# [ABC343D] Diversity of Scores

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc343/tasks/abc343_d

高橋君が主催するコンテストに、$ 1 $ から $ N $ までの番号が付けられた $ N $ 人の選手が参加しています。 このコンテストは各選手がその得点を競うものであり、現在の得点はどの選手も $ 0 $ 点です。

未来予知の能力を持つ高橋君は、今から選手たちの得点がどのように変動するかを知っています。 具体的には、$ i=1,2,\dots,T $ について、今から $ i $ 秒後に選手 $ A_i $ の得点が $ B_i $ 点増加します。 逆に、それ以外に得点の変動はありません。

得点の多様性を好む高橋君は、各時点における選手たちの得点に何種類の値が現れるかを知りたがっています。 $ i=1,2,\dots,T $ それぞれについて、今から $ i+0.5 $ 秒後の選手たちの得点には何種類の値が現れるか求めてください。

例えば、ある時点における選手たちの得点がそれぞれ $ 10,20,30,20 $ 点であった場合、この時点での選手たちの得点には $ 3 $ 種類の値が現れています。

## 说明/提示

### 制約

- $ 1\leq\ N,\ T\leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ N $
- $ 1\leq\ B_i\ \leq\ 10^9 $
- 入力は全て整数

### Sample Explanation 1

選手 $ 1,2,3 $ の得点をこの順に並べた数列を $ S $ とします。 現在、$ S=\lbrace\ 0,0,0\rbrace $ です。 - $ 1 $ 秒後に選手 $ 1 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,0,0\rbrace $ になります。よって、$ 1.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。 - $ 2 $ 秒後に選手 $ 3 $ の得点が $ 20 $ 点増加し、$ S=\lbrace\ 10,0,20\rbrace $ になります。よって、$ 2.5 $ 秒後の選手たちの得点には $ 3 $ 種類の値が現れます。 - $ 3 $ 秒後に選手 $ 2 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,10,20\rbrace $ になります。よって、$ 3.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。 - $ 4 $ 秒後に選手 $ 2 $ の得点が $ 10 $ 点増加し、$ S=\lbrace\ 10,20,20\rbrace $ になります。よって、$ 4.5 $ 秒後の選手たちの得点には $ 2 $ 種類の値が現れます。

## 样例 #1

### 输入

```
3 4
1 10
3 20
2 10
2 10```

### 输出

```
2
3
2
2```

## 样例 #2

### 输入

```
1 3
1 3
1 4
1 3```

### 输出

```
1
1
1```

## 样例 #3

### 输入

```
10 10
7 2620
9 2620
8 3375
1 3375
6 1395
5 1395
6 2923
10 3375
9 5929
5 1225```

### 输出

```
2
2
3
3
4
4
5
5
6
5```

# AI分析结果



---
# 💡 Kay的C++算法解析：ABC343D Diversity of Scores 深入学习指南 💡

<introduction>
今天我们来一起分析“ABC343D Diversity of Scores”这道C++编程题。这道题的核心是动态维护不同分数的个数，通过模拟每次操作后的分数变化，掌握如何高效统计数据中的唯一值数量。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与哈希表（map/unordered_map）的应用`

🗣️ **初步分析**：
解决这道题的关键在于动态跟踪每次操作后不同分数的个数。简单来说，我们需要“模拟”每次分数变化的过程，并高效统计当前所有分数中的唯一值数量。由于分数可能很大（如 \(10^9\)），直接用数组统计会超出内存限制，因此我们选择用哈希表（如`map`或`unordered_map`）来记录每个分数的出现次数。

- **题解思路**：所有优质题解的核心思路一致：用哈希表记录每个分数的出现次数，并用一个变量维护当前不同分数的个数。每次操作时，先减少原分数的计数（若减到0则减少唯一值个数），再增加新分数的计数（若从0变1则增加唯一值个数）。
- **核心难点**：正确判断何时需要增减唯一值个数（原分数计数减到0时唯一值个数减1，新分数计数从0变1时唯一值个数加1）。
- **可视化设计**：我们将用8位像素风格动画演示每次操作：选手的分数用不同颜色的像素块表示，哈希表用动态列表展示分数和计数，每次操作时原分数的像素块颜色变灰（计数减少），新分数的像素块亮起（计数增加），同时唯一值个数的数字动态更新。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码可读性、算法有效性等维度的评估，以下题解因逻辑简洁、实现高效且易于学习，被选为优质题解：
</eval_intro>

**题解一：作者：Little_x_starTYJ**
* **点评**：此题解代码简洁，变量命名清晰（如`c`数组存储选手当前分数，`m`为哈希表，`number`维护唯一值个数）。逻辑上，先处理原分数的计数，再处理新分数的计数，每一步都明确维护`number`的值。代码中使用`map`处理大分数范围，时间复杂度为 \(O(T \log N)\)，能高效通过所有测试用例。

**题解二：作者：OIer_Tan**
* **点评**：此题解使用`unordered_map`（哈希表）替代`map`，平均时间复杂度更低（\(O(1)\) 查找），适合对性能要求更高的场景。代码结构工整，输入输出优化（`ios::sync_with_stdio(false)`）提升效率，边界处理严谨（如计数为0时`erase`哈希表中的键）。

**题解三：作者：f_hxr_**
* **点评**：此题解用最精简的代码实现了核心逻辑，变量`ans`直接维护唯一值个数。通过“先减后加”的操作顺序，确保每次更新的正确性。代码中对`ans`的增减判断（`mp[val[A[i]]]==0`和`mp[val[A[i]]+B[i]]==1`）非常关键，是理解本题的核心。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何高效统计大范围内的分数出现次数？
    * **分析**：由于分数可能达到 \(10^9\)，数组无法存储所有可能的分数。优质题解均使用哈希表（`map`或`unordered_map`）来动态记录每个分数的出现次数，哈希表的键是分数，值是该分数的出现次数。这解决了大数值存储的问题，且查找、插入操作的时间复杂度较低。
    * 💡 **学习笔记**：当数据范围大但实际出现的不同值较少时，哈希表是统计频率的首选工具。

2.  **关键点2**：如何动态维护不同分数的个数？
    * **分析**：每次操作只会改变一个选手的分数，因此只需关注该选手原分数和新分数的变化：
      - 原分数：若其计数减到0，说明该分数不再存在，唯一值个数减1。
      - 新分数：若其计数从0变为1，说明该分数首次出现，唯一值个数加1。
    * 💡 **学习笔记**：唯一值个数的变化仅与原分数和新分数的计数变化有关，无需重新统计所有分数。

3.  **关键点3**：如何避免哈希表操作的边界错误？
    * **分析**：例如，原分数的计数减1后可能为0，此时需从哈希表中删除该键（或标记为无效），避免后续误判。优质题解通过判断`mp[old_score] == 0`来决定是否减少唯一值个数，并在必要时删除哈希表中的键。
    * 💡 **学习笔记**：处理哈希表时，务必检查计数是否为0，避免“幽灵键”（计数为0但未删除）导致的错误。

### ✨ 解题技巧总结
- **哈希表的选择**：若时间要求严格，优先使用`unordered_map`（平均 \(O(1)\) 操作）；若需要有序性（如调试时观察分数顺序），使用`map`（\(O(\log N)\) 操作）。
- **变量初始化**：初始时所有选手分数为0，因此哈希表中`0`的计数初始化为\(N\)，唯一值个数初始化为1。
- **操作顺序**：先处理原分数的计数（减1），再处理新分数的计数（加1），确保逻辑正确。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，使用`map`动态维护分数计数，并维护唯一值个数`ans`。代码简洁高效，适合直接学习和应用。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;

    const int MAXN = 2e5 + 5;
    ll score[MAXN];  // 记录每个选手的当前分数
    map<ll, int> cnt; // 记录每个分数的出现次数
    int ans = 1;      // 初始时只有0分，唯一值个数为1

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int n, t;
        cin >> n >> t;
        cnt[0] = n;  // 初始时所有选手分数为0，出现次数为n

        while (t--) {
            int a;
            ll b;
            cin >> a >> b;

            // 处理原分数
            ll old_score = score[a];
            cnt[old_score]--;
            if (cnt[old_score] == 0) {
                ans--;
            }

            // 处理新分数
            ll new_score = old_score + b;
            score[a] = new_score;
            if (cnt[new_score] == 0) {
                ans++;
            }
            cnt[new_score]++;

            cout << ans << '\n';
        }

        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先初始化`score`数组记录选手分数，`cnt`哈希表记录分数出现次数（初始时`0`出现`n`次），`ans`初始为1（只有0分）。每次操作时，先减少原分数的计数（若减到0则`ans`减1），再增加新分数的计数（若从0变1则`ans`加1），最后输出`ans`。整个过程高效模拟了每次操作后的分数变化，确保唯一值个数正确。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者：Little_x_starTYJ**
* **亮点**：代码简洁，变量命名清晰，直接维护`number`变量表示唯一值个数。
* **核心代码片段**：
    ```cpp
    m[c[a[i]]]--;
    if (m[c[a[i]]] == 0)
        number--;
    c[a[i]] += b[i];
    m[c[a[i]]]++;
    if (m[c[a[i]]] == 1)
        number++;
    ```
* **代码解读**：
    > 这段代码是核心逻辑的体现：首先将原分数`c[a[i]]`的计数减1，若减到0则唯一值个数`number`减1；然后将选手分数增加`b[i]`，新分数的计数加1，若加之前计数为0（即现在变为1），则`number`加1。这四步操作完美模拟了分数变化对唯一值个数的影响。
* 💡 **学习笔记**：唯一值个数的变化仅与原分数和新分数的计数是否为0有关，这是本题的核心逻辑。

**题解二：作者：OIer_Tan**
* **亮点**：使用`unordered_map`提升效率，代码结构工整，输入输出优化到位。
* **核心代码片段**：
    ```cpp
    cnt[s[a[i]]]--;
    if (!cnt[s[a[i]]]) {
        cnt.erase(s[a[i]]);
    }
    s[a[i]] += b[i];
    cnt[s[a[i]]]++;
    cout << cnt.size() << endl;
    ```
* **代码解读**：
    > 这段代码直接利用`unordered_map`的`size()`方法输出唯一值个数。原分数计数减1后，若为0则删除该键（避免占用空间）；新分数计数加1后，`unordered_map`的大小即为当前唯一值个数。这种方法更简洁，无需额外维护`ans`变量。
* 💡 **学习笔记**：`unordered_map`的`size()`方法直接反映唯一键的数量，适合需要快速获取结果的场景。

**题解三：作者：f_hxr_**
* **亮点**：代码极简，通过`ans`变量直接维护唯一值个数，逻辑清晰。
* **核心代码片段**：
    ```cpp
    mp[val[A[i]]]--; if(mp[val[A[i]]]==0)--ans;
    val[A[i]]+=B[i]; 
    mp[val[A[i]]]++; if(mp[val[A[i]]]==1)++ans;
    ```
* **代码解读**：
    > 这段代码将逻辑压缩为两行，先处理原分数（计数减1，若为0则`ans`减1），再处理新分数（计数加1，若为1则`ans`加1）。虽然代码简短，但完整覆盖了所有情况，体现了对问题本质的深刻理解。
* 💡 **学习笔记**：简洁的代码往往源于对问题的透彻分析，抓住核心逻辑（原分数和新分数的计数变化）即可简化实现。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“动态维护唯一分数个数”的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到每次操作时分数如何变化，以及唯一值个数如何更新！
</visualization_intro>

  * **动画演示主题**：`像素分数大战`（复古FC游戏风格）

  * **核心演示内容**：
    - 屏幕左侧是`N`个像素小人（选手），每个小人头顶显示当前分数（用不同颜色区分，如0分是蓝色，10分是红色）。
    - 屏幕右侧是一个动态列表（哈希表），显示当前存在的分数及其出现次数（如`0:3`表示3个选手得0分）。
    - 顶部中央显示当前唯一分数个数（`ans`），用大数字动态更新。

  * **设计思路简述**：
    采用8位像素风（如FC红白机的简单图形），让学习过程更轻松；用颜色区分不同分数，帮助记忆；哈希表列表动态更新，直观展示计数变化；`ans`数字的跳动强化操作结果。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          - 所有像素小人头顶显示“0”（蓝色），右侧哈希表显示`0:N`，`ans`显示“1”。
          - 播放8位风格的轻快背景音乐（类似《超级玛丽》开场）。

    2.  **操作触发（单步/自动播放）**：
          - 用户点击“开始”或选择“自动播放”（速度可调），动画进入操作循环。

    3.  **原分数处理**：
          - 选中的选手（如第`a_i`个小人）头顶分数闪烁红色，提示即将修改。
          - 右侧哈希表中该原分数（如`old_score`）的计数减1（如`0:3`变为`0:2`），若减到0则该分数从列表中消失（伴随“叮”的音效），`ans`数字减1（如从“1”变为“2”？不，初始是1，原分数减到0的话ans减1，比如初始是0分有3人，当其中1人变为10分，原分数0的计数变为2，此时ans还是1？哦，原分数减到0时ans才减1。比如初始ans是1（只有0分）。当第一个操作将一个选手的0分变为10分，原分数0的计数变为n-1（比如n=3，变为2），此时0分仍存在，ans不变；新分数10分的计数从0变为1，ans加1，最终ans=2。所以动画中，原分数计数减1后，若计数>0，哈希表更新计数但ans不变；若计数=0，哈希表删除该分数，ans减1（数字跳动并播放“噗”的音效）。

    4.  **新分数处理**：
          - 选中的选手头顶分数更新为`new_score`（如从0变为10，颜色变为红色）。
          - 右侧哈希表中该新分数的计数加1（如`10:0`变为`10:1`），若加之前计数为0（即现在变为1），则`ans`加1（数字跳动并播放“咚”的音效）。

    5.  **操作完成**：
          - 所有元素静止，显示当前状态，直到用户点击“下一步”或自动进入下一次操作。

  * **旁白提示**：
      - （原分数处理时）“注意！这位选手原来的分数是`old_score`，现在要减少它的计数啦~”
      - （若原分数计数减到0）“哎呀，`old_score`分数没人得了，唯一值个数减1！”
      - （新分数处理时）“现在这位选手的分数变成`new_score`，它的计数要增加咯~”
      - （若新分数计数从0变1）“耶！`new_score`是新出现的分数，唯一值个数加1！”

<visualization_conclusion>
通过这样一个像素风格的动画，我们不仅能直观看到每次操作对分数和唯一值个数的影响，还能在轻松的游戏氛围中理解哈希表的工作原理和动态维护的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 本题的核心是“动态维护唯一值个数”，这一思路可迁移到以下场景：
        1. **在线统计不同元素个数**：如实时统计直播间弹幕的不同用户发言次数。
        2. **数据库去重计数**：每次插入新数据后，统计当前表中不同值的数量。
        3. **游戏道具系统**：统计玩家背包中不同道具的种类数，每次获取或使用道具时更新。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1102 甲流疫情死亡率**
          * 🗣️ **推荐理由**：这道题需要统计不同数据的出现次数，与本题类似，可巩固哈希表的应用。
    2.  **洛谷 P1972 [SDOI2009]HH的项链**
          * 🗣️ **推荐理由**：此题要求统计区间内不同元素的个数，是本题的进阶版，可练习离线处理和哈希表结合的技巧。
    3.  **洛谷 P3935 Calculating**
          * 🗣️ **推荐理由**：此题需要统计自然数的约数个数，虽然问题不同，但动态维护计数的思路与本题一致，可拓展思维。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和注意事项，这些对我们非常有参考价值：
</insights_intro>

> **参考经验 (来自多位作者)**：“记得开`long long`！分数可能很大，用`int`会溢出。初始时`map[0]`的计数要设为`n`，否则会出错。处理原分数和新分数的顺序不能颠倒，否则`ans`会计算错误。”

**点评**：这些经验提醒我们，在编程时要注意数据类型的范围（避免溢出）、初始化的正确性（如`map[0]=n`），以及操作顺序的逻辑（先处理原分数，再处理新分数）。这些细节是保证代码正确的关键，也是竞赛中避免“小错误”的重要经验。

-----

<conclusion>
本次关于“ABC343D Diversity of Scores”的C++解题分析就到这里。希望这份学习指南能帮助大家理解动态维护唯一值个数的核心思路，掌握哈希表的应用技巧，并通过可视化动画更直观地感受算法过程。记住，编程能力的提升需要多思考、多练习，下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：157.43秒
# 题目信息

# [ABC377C] Avoid Knight Attack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc377/tasks/abc377_c

縦 $ N $ マス、横 $ N $ マスの $ N\ ^\ 2 $ マスからなるマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ N) $ 、左から $ j $ 列目 $ (1\leq\ j\leq\ N) $ のマスをマス $ (i,j) $ と呼ぶことにします。

それぞれのマスは、空マスであるかコマが置かれているかのどちらかです。 マス目には合計で $ M $ 個のコマが置かれており、$ k $ 番目 $ (1\leq\ k\leq\ M) $ のコマはマス $ (a\ _\ k,b\ _\ k) $ に置かれています。

あなたは、すでに置かれている**どのコマにも取られないように**、いずれかの**空マス**に自分のコマを置きたいです。

マス $ (i,j) $ に置かれているコマは、次のどれかの条件を満たすコマを取ることができます。

- マス $ (i+2,j+1) $ に置かれている
- マス $ (i+1,j+2) $ に置かれている
- マス $ (i-1,j+2) $ に置かれている
- マス $ (i-2,j+1) $ に置かれている
- マス $ (i-2,j-1) $ に置かれている
- マス $ (i-1,j-2) $ に置かれている
- マス $ (i+1,j-2) $ に置かれている
- マス $ (i+2,j-1) $ に置かれている

ただし、存在しないマスについての条件は常に満たされないものとします。

たとえば、マス $ (4,4) $ に置かれているコマは、以下の図で青く示されたマスに置かれているコマを取ることができます。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc377_c/399e5a909392dc44071791350bba40d75968dfd7.png)

あなたがコマを置くことができるマスがいくつあるか求めてください。

## 说明/提示

### 制約

- $ 1\leq\ N\leq10\ ^\ 9 $
- $ 1\leq\ M\leq2\times10\ ^\ 5 $
- $ 1\leq\ a\ _\ k\leq\ N,1\leq\ b\ _\ k\leq\ N\ (1\leq\ k\leq\ M) $
- $ (a\ _\ k,b\ _\ k)\neq(a\ _\ l,b\ _\ l)\ (1\leq\ k\lt\ l\leq\ M) $
- 入力はすべて整数

### Sample Explanation 1

すでに置かれているコマは、以下の図で青く示されたマスに置かれたコマを取ることができます。 ![](https://img.atcoder.jp/abc377/cb70c753c18ba20c291ba79e76f34599.png) よって、あなたがすでに置かれているコマに取られないように自分のコマを置くことができるマスは残りの $ 38 $ マスです。

### Sample Explanation 2

$ 10\ ^\ {18} $ マスのうち、置くことができないマスはマス $ (1,1),(2,3),(3,2) $ の $ 3 $ マスのみです。 答えが $ 2\ ^\ {32} $ 以上になる場合があることに注意してください。

## 样例 #1

### 输入

```
8 6
1 4
2 1
3 8
4 5
5 2
8 3```

### 输出

```
38```

## 样例 #2

### 输入

```
1000000000 1
1 1```

### 输出

```
999999999999999997```

## 样例 #3

### 输入

```
20 10
1 4
7 11
7 15
8 10
11 6
12 5
13 1
15 2
20 10
20 15```

### 输出

```
338```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC377C] Avoid Knight Attack 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC377C] Avoid Knight Attack”这道C++编程题。这道题的核心是在大网格中高效统计未被马攻击的格子数，本指南将帮助大家梳理思路、理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与数据结构的高效应用`（属于“编程技巧应用”分类）

🗣️ **初步分析**：
解决这道题的关键在于模拟马的攻击范围，并高效记录这些被攻击的格子。由于网格大小 \( N \) 可能达到 \( 10^9 \)，直接使用二维数组标记会超出内存限制，因此需要借助**集合类数据结构**（如 `map`、`set`）来存储被攻击的坐标，利用其自动去重的特性避免重复计算。

- **题解思路**：所有优质题解的核心思路一致：遍历每个马的位置，计算其能攻击的9个坐标（包括自身），将这些坐标存入集合中去重，最终答案为总格子数 \( N^2 \) 减去集合的大小。
- **核心难点**：如何高效处理大网格下的坐标存储与去重，以及正确计算每个马的攻击范围（需判断坐标是否越界）。
- **可视化设计思路**：在像素动画中，用不同颜色区分马的位置（红色）、被攻击的格子（黄色）和安全格子（绿色）。每处理一个马时，用像素箭头动态展示其攻击的8个方向，被攻击的格子逐渐填充为黄色，最终统计剩余绿色格子数。

- **复古游戏化元素**：采用8位像素风格网格（类似FC游戏界面），每处理一个马时播放“叮”的音效，填充被攻击格子时伴随轻微的“唰”声，最终统计时播放胜利音效。支持单步/自动播放，可调节速度观察每一步攻击范围的扩展。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者cyx012113**
* **点评**：此题解思路简洁明了，直接点明“用map记录被攻击的坐标”这一核心方法。代码规范（如使用`make_pair`生成坐标对），注释详细（提示开`long long`、边界判断等），时间复杂度分析清晰（\( O(8M \log M) \)）。特别值得学习的是对边界条件的处理（判断坐标是否在 \( 1 \leq x,y \leq N \) 范围内），以及利用map自动去重的特性简化代码逻辑。

**题解二：作者FlowerAccepted**
* **点评**：此题解使用`set<pair<int, int>>`存储被攻击的坐标，代码结构清晰（分`knights`和`capture`两个集合），并详细解释了每个步骤的意义（如判断攻击位置是否越界、是否已有马存在）。虽然代码稍长，但逻辑严谨，适合理解集合类数据结构的应用场景。

**题解三：作者Hacker_Cracker**
* **点评**：此题解代码极其简洁，直接使用`set`存储所有被攻击的坐标（包括马自身），通过预定义的方向数组简化循环逻辑。时间复杂度分析准确（\( O(M \log M) \)），适合快速上手的学习者参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：大网格下的坐标存储问题**
    * **分析**：由于 \( N \leq 10^9 \)，无法用二维数组存储所有格子。优质题解普遍使用`map`或`set`存储被攻击的坐标，利用其动态存储和自动去重的特性，将空间复杂度控制在 \( O(M) \)（每个马最多贡献9个坐标）。
    * 💡 **学习笔记**：当网格/数组规模极大但实际需要处理的元素较少时，集合类数据结构（如`map`、`set`）是高效的选择。

2.  **关键点2：正确计算马的攻击范围**
    * **分析**：马的攻击范围是8个特定方向（类似国际象棋的马走“日”），需注意每个方向的坐标偏移（如\( (i+2,j+1) \)）。同时，必须判断计算出的坐标是否在 \( 1 \leq x,y \leq N \) 范围内（越界的坐标无效）。
    * 💡 **学习笔记**：预定义方向数组（如`dx[]`和`dy[]`）可以简化循环逻辑，避免手动计算每个方向的偏移。

3.  **关键点3：去重处理**
    * **分析**：多个马的攻击范围可能重叠（即同一个坐标被多个马攻击），需通过集合自动去重。例如，两个不同的马可能同时攻击到坐标\( (3,4) \)，集合只会记录一次。
    * 💡 **学习笔记**：集合的`insert`操作会自动跳过重复元素，是去重的高效方法。

### ✨ 解题技巧总结
<summary_best_practices>
- **方向数组预定义**：将马的8个攻击方向存储为数组（如`dx[] = {2,1,-1,-2,...}`，`dy[] = {1,2,2,1,...}`），通过循环遍历数组计算所有攻击坐标，避免重复代码。
- **边界条件判断**：每次计算攻击坐标后，立即检查是否在 \( 1 \leq x,y \leq N \) 范围内，避免越界错误。
- **使用`long long`类型**：由于 \( N \) 可能很大（\( 10^9 \)），\( N^2 \) 会超过`int`的范围（\( 10^{18} \)），必须使用`long long`存储结果。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了cyx012113和Hacker_Cracker的思路，使用`set`存储被攻击的坐标，代码简洁且高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long // 防止N²溢出
    using namespace std;

    const int dx[] = {2, 1, -1, -2, -2, -1, 1, 2}; // 马的8个攻击方向x偏移
    const int dy[] = {1, 2, 2, 1, -1, -2, -2, -1}; // 马的8个攻击方向y偏移

    signed main() {
        int N, M;
        cin >> N >> M;
        set<pair<int, int>> attacked; // 存储被攻击的坐标（包括马自身）

        for (int i = 0; i < M; ++i) {
            int x, y;
            cin >> x >> y;
            // 记录马自身的位置
            attacked.insert({x, y});
            // 计算并记录8个攻击方向的坐标
            for (int j = 0; j < 8; ++j) {
                int nx = x + dx[j];
                int ny = y + dy[j];
                // 检查坐标是否在网格内
                if (nx >= 1 && nx <= N && ny >= 1 && ny <= N) {
                    attacked.insert({nx, ny});
                }
            }
        }

        // 总格子数 - 被攻击的格子数 = 安全格子数
        cout << N * N - attacked.size() << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入的网格大小 \( N \) 和马的数量 \( M \)，然后用`set`存储所有被攻击的坐标。对于每个马的位置，先记录其自身坐标，再遍历8个攻击方向，计算每个方向的坐标并检查是否越界，最后将有效坐标插入`set`。最终输出总格子数减去`set`的大小（即被攻击的格子数）。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其亮点和实现思路。
</code_intro_selected>

**题解一：作者cyx012113**
* **亮点**：使用`map<pair<int, int>, bool>`记录被攻击的坐标，代码简洁，注释详细提示了`long long`和边界判断的重要性。
* **核心代码片段**：
    ```cpp
    map <pair <int, int>, bool> a; // 记录(x, y)是否被攻击
    int fx[] = {0, 2, 1, -1, -2, -2, -1,  1,  2}; // 含自身的9个方向（索引0为自身）
    int fy[] = {0, 1, 2,  2,  1, -1, -2, -2, -1};

    signed main() {
        cin >> n >> m;
        for (int i = 1; i <= m; ++i) {
            cin >> x >> y;
            a[make_pair(x, y)] = 1; // 记录马自身
            for (int j = 1; j <= 8; ++j) { // 遍历8个攻击方向
                int nx = x + fx[j], ny = y + fy[j];
                if (nx > 0 && nx <= n && ny > 0 && ny <= n) {
                    a[make_pair(nx, ny)] = 1; // 记录攻击坐标
                }
            }
        }
        cout << n * n - a.size() << endl;
    }
    ```
* **代码解读**：
    `map`的键是`pair<int, int>`类型的坐标，值为`bool`（标记是否被攻击）。`fx`和`fy`数组包含马自身（索引0）和8个攻击方向的偏移量。循环处理每个马时，先插入自身坐标，再遍历攻击方向，插入有效坐标（需越界判断）。最终输出总格子数减去`map`的大小（即被攻击的格子数）。
* 💡 **学习笔记**：`map`的`insert`或赋值操作会自动去重，无需额外判断，简化了代码逻辑。

**题解二：作者FlowerAccepted**
* **亮点**：使用两个`set`分别存储马的位置和被攻击的位置，逻辑清晰，避免了马的位置与攻击位置的重叠。
* **核心代码片段**：
    ```cpp
    set<pair<int, int>> knights, capture; // 马的位置、被攻击的位置
    int jumpx[] = {-1, 1, 2, 2, 1, -1, -2, -2}; // 8个攻击方向x偏移
    int jumpy[] = {-2, -2, -1, 1, 2, 2, 1, -1}; // 8个攻击方向y偏移

    int main() {
        cin >> n >> m;
        for (int i = 1; i <= m; ++i) {
            int x, y; cin >> x >> y;
            knights.insert({x, y}); // 记录马的位置
        }
        for (auto& knight : knights) {
            for (int i = 0; i < 8; ++i) { // 遍历攻击方向
                int nx = knight.first + jumpx[i];
                int ny = knight.second + jumpy[i];
                // 检查越界且该位置不是马的位置
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= n 
                    && !knights.count({nx, ny})) {
                    capture.insert({nx, ny}); // 记录被攻击的位置
                }
            }
        }
        // 总格子数 - 马的数量（不可放置） - 被攻击的位置数
        cout << n * n - knights.size() - capture.size() << endl;
    }
    ```
* **代码解读**：
    `knights`存储所有马的位置，`capture`存储被攻击的位置（不包括马自身）。遍历每个马时，计算攻击坐标并检查是否越界，同时确保该坐标不是马的位置（因为马的位置本身不可放置）。最终答案为总格子数减去马的数量（不可放置）和被攻击的位置数。
* 💡 **学习笔记**：分离马的位置和被攻击的位置，更清晰地对应题目中“空的格子”的要求（马的位置本身不是空的，不能放置）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“马的攻击范围扩展”和“去重”过程，我们设计了一个8位像素风格的动画方案，让大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素马的攻击范围`（复古FC游戏风格）

  * **核心演示内容**：
    展示一个 \( 8 \times 8 \) 的像素网格（类似国际象棋棋盘），每个马的位置用红色方块表示，被攻击的格子用黄色方块表示，安全格子用绿色方块表示。动画逐步处理每个马，扩展其攻击范围，并合并重复的黄色方块。

  * **设计思路简述**：
    8位像素风格（如FC红白机）能降低学习门槛，增强趣味性。颜色区分（红/黄/绿）直观反映不同状态；音效（攻击时“叮”声、去重时“唰”声）强化操作记忆；步进控制允许学习者逐帧观察攻击范围的扩展。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 网格背景为浅灰色，每个格子是 \( 16 \times 16 \) 的像素块。
        - 控制面板包含“开始/暂停”、“单步”、“重置”按钮和速度滑块（1-10级）。
        - 播放8位风格的轻快背景音乐（如《超级马里奥》主题变奏）。

    2.  **输入马的位置**：
        - 输入一个马的坐标（如\( (4,4) \)），该位置的红色方块闪烁3次，伴随“滴”的音效，表示马被放置。

    3.  **扩展攻击范围**：
        - 从马的位置出发，8个方向各发射一个像素箭头（蓝色），指向攻击坐标（如\( (6,5) \)、\( (5,6) \)等）。
        - 箭头到达目标坐标后，该格子变为黄色（若未被攻击过），并播放“叮”的音效；若已被攻击过（黄色），则播放“唰”的音效并轻微闪烁。

    4.  **去重效果**：
        - 当两个马的攻击范围重叠时（如第一个马攻击\( (5,6) \)，第二个马也攻击\( (5,6) \)），第二个箭头到达时，\( (5,6) \) 仅闪烁但不改变颜色，提示“已记录”。

    5.  **结果统计**：
        - 所有马处理完成后，背景音乐停止，播放“胜利”音效（上扬音调），绿色方块（安全格子）集体闪烁，屏幕显示“安全格子数：XX”。

  * **旁白提示**：
    - “看！红色方块是马的位置，黄色是它能攻击的格子，绿色是安全的哦～”
    - “当两个马攻击同一个格子时，黄色格子只会记录一次，这就是去重！”
    - “最后，总格子数减去黄色格子数，就是我们要求的答案啦！”

<visualization_conclusion>
通过这样的动画，我们能清晰看到每个马如何扩展攻击范围，以及去重机制如何避免重复计数。这种“眼见为实”的方式，能帮助大家更深刻理解集合类数据结构的作用。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的思路后，我们可以尝试解决类似的“大网格小数据”问题，关键是用集合类数据结构高效处理稀疏的有效坐标。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 本题的核心是“用集合存储稀疏的有效坐标”，这一思路还适用于：
      1. **大网格中的障碍物标记**（如迷宫问题中记录障碍物位置）。
      2. **二维平面上的点集操作**（如统计多个圆覆盖的区域面积）。
      3. **离散化处理**（将大范围内的坐标映射到小范围，如棋盘覆盖问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1330 封锁阳光大学**  
        * 🗣️ **推荐理由**：需要统计图中被封锁的节点，涉及集合去重和图遍历，与本题的“稀疏坐标处理”思路类似。
    2.  **洛谷 P1162 填涂颜色**  
        * 🗣️ **推荐理由**：用BFS填充区域，但网格可能很大，需用队列存储待处理的坐标，练习稀疏数据的处理。
    3.  **洛谷 P2002 消息扩散**  
        * 🗣️ **推荐理由**：用并查集或BFS统计可达节点，涉及大量坐标的合并与去重，适合巩固集合类数据结构的应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者cyx012113提到：“需要注意开long long，以及坐标越界判断。”这是非常实用的经验！
</insights_intro>

> **参考经验 (来自 cyx012113)**：“题目样例二给出了提示，要开long long。需要特判坐标是否越界，以及记录马的所在位置。”
>
> **点评**：这位作者的经验提醒我们，在处理大数运算（如\( N^2 \)）时，必须使用`long long`避免溢出；而边界判断（坐标是否在 \( 1 \leq x,y \leq N \) 范围内）是防止错误的关键。这些细节在编程中容易被忽略，但却是AC的重要保障。

-----

<conclusion>
本次关于“[ABC377C] Avoid Knight Attack”的分析就到这里。通过理解集合类数据结构的应用、马的攻击范围计算和去重逻辑，相信大家已经掌握了解题的核心。编程的关键在于多思考、多练习，快去尝试推荐的题目吧！💪
</conclusion>

---
处理用时：157.81秒
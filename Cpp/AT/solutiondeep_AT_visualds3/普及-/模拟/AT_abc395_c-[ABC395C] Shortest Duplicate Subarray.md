# 题目信息

# [ABC395C] Shortest Duplicate Subarray

## 题目描述

给定一个正整数 $N$ 和一个长度为 $N$ 的整数序列 $A=(A_1,A_2,\dots,A_N)$。

请判断 $A$ 中是否存在至少包含两个相同元素的非空连续子数组。若存在，请求出所有满足条件的子数组中最短的长度；若不存在，请输出 `-1`。

## 说明/提示

### 约束条件
- $1 \leq N \leq 2 \times 10^5$
- $1 \leq A_i \leq 10^6$（$1 \leq i \leq N$）
- 输入均为整数

### 样例解释 1
子数组 $(3,9,5,3)$ 和 $(3,9,5,3,1)$ 满足条件。其中最短的子数组长度为 $4$。

### 样例解释 2
不存在符合条件的连续子数组。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
5

3 9 5 3 1```

### 输出

```
4```

## 样例 #2

### 输入

```
4

2 5 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
10

1 1 2 3 5 8 13 21 34 55```

### 输出

```
2```

# AI分析结果



---
# 💡 Kay的C++算法解析：Shortest Duplicate Subarray 深入学习指南 💡

<introduction>
今天我们来一起分析“Shortest Duplicate Subarray”这道C++编程题。这道题需要我们找到数组中最短的包含重复元素的连续子数组长度。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（哈希表/数组记录位置）`

🗣️ **初步分析**：
解决这道题的关键在于高效记录每个元素最后一次出现的位置，并通过遍历数组计算相邻重复元素的距离。简单来说，就像我们在玩“找朋友”游戏——每个数字需要找到它最近的“朋友”（上一次出现的位置），然后计算它们之间的“步数”（子数组长度）。所有“步数”中的最小值就是答案。

- **题解思路**：所有优质题解的核心思路高度统一：用数组或哈希表记录每个数字上一次出现的位置。遍历数组时，若当前数字之前出现过，计算当前位置与上一次位置的距离（即子数组长度），并更新最小值。若遍历完所有元素后最小值未更新，说明无重复元素，输出-1。
- **核心难点**：如何高效记录位置（避免超时）、正确处理首次出现的元素（不计算距离）、准确计算子数组长度（注意包含两端点）。
- **可视化设计**：我们将用8位像素风格动画演示数组遍历过程：每个数字用彩色像素块表示，当遇到重复数字时，用黄色高亮当前块和上一次块，并用红色箭头标出两者间的距离，同时在屏幕上方显示当前最小值。关键操作（如记录位置、更新最小值）伴随“叮”的像素音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等方面筛选了以下优质题解（均≥4星），它们的思路简洁高效，代码规范，值得学习：
</eval_intro>

**题解一：作者Little_x_starTYJ**
* **点评**：此题解思路清晰，代码规范。通过数组`lst`记录每个数字上一次出现的位置（初始化为特殊值避免干扰），遍历数组时动态更新位置并计算最短距离。边界处理严谨（如初始化`lst`为大负数），确保首次出现的元素不会误算距离。代码简洁，时间复杂度O(N)，完全适配题目数据范围。

**题解二：作者Lovely_yhb**
* **点评**：此题解代码极其简洁，直接利用数组`lst`记录位置（初始为0）。遍历过程中，若当前数字已出现（`lst[x]≠0`），则计算距离并更新最小值。代码逻辑直白，变量命名（`ans`）直观，适合快速理解核心思路。

**题解三：作者2011hym**
* **点评**：此题解使用`unordered_map`记录位置，适合值域极大（如超过数组大小）的场景。虽然哈希表查询略慢，但题目中`A_i≤1e6`，数组更高效；不过该题解展示了哈希表的通用解法，对拓展思路有帮助。代码结构清晰，复杂度分析明确，适合学习不同数据结构的选择。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何高效记录元素位置？**
    * **分析**：由于`A_i≤1e6`，可以用数组直接记录（如`lst[1000010]`），时间复杂度O(1)查询/更新。若值域更大（如超过数组大小），则需用哈希表（如`unordered_map`），但可能增加常数时间。优质题解普遍选择数组，因本题值域明确，数组更高效。
    * 💡 **学习笔记**：当值域可预估且不大时，数组比哈希表更高效；值域未知或极大时，哈希表是更通用的选择。

2.  **关键点2：如何正确计算子数组长度？**
    * **分析**：子数组包含两端点，因此长度为`当前位置i - 上一次位置lst[x] + 1`（例如，位置3和位置6的元素相同，子数组长度为6-3+1=4）。优质题解均正确应用此公式，避免了“漏加1”的常见错误。
    * 💡 **学习笔记**：连续子数组的长度计算需包含起始和结束位置，公式为`r - l + 1`。

3.  **关键点3：如何处理首次出现的元素？**
    * **分析**：首次出现的元素无需计算距离，只需记录其位置。优质题解通过初始化数组为0或特殊值（如-1），判断`lst[x]`是否为初始值来区分首次出现。例如，若`lst[x]==0`，说明是第一次出现，记录位置；否则计算距离。
    * 💡 **学习笔记**：初始化数组/哈希表时，需选择不会与有效位置冲突的值（如0或-1），避免误判。

### ✨ 解题技巧总结
- **问题抽象**：将问题转化为“寻找相邻重复元素的最小间距”，简化思路。
- **空间换时间**：用数组直接记录位置，避免哈希表的额外开销。
- **边界处理**：初始化记录数组为特殊值，明确区分首次出现和重复出现。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用数组记录位置，简洁高效，适合本题数据范围。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAX_VAL = 1e6 + 10; // 题目中A_i最大为1e6
    int lst[MAX_VAL] = {0}; // 记录每个数上一次出现的位置，初始化为0

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int n, x;
        cin >> n;
        int ans = INT_MAX;
        for (int i = 1; i <= n; ++i) {
            cin >> x;
            if (lst[x] != 0) { // 之前出现过
                ans = min(ans, i - lst[x] + 1); // 计算子数组长度
            }
            lst[x] = i; // 更新为当前位置
        }
        if (ans == INT_MAX) { // 无重复元素
            cout << -1 << endl;
        } else {
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先初始化一个数组`lst`，用于记录每个数上一次出现的位置。遍历数组时，若当前数之前出现过（`lst[x]≠0`），则计算当前位置与上一次位置的距离（子数组长度），并更新最小值`ans`。遍历结束后，若`ans`未更新，说明无重复元素，输出-1；否则输出`ans`。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者Little_x_starTYJ**
* **亮点**：初始化`lst`为特殊值（-1145141919），避免0位置干扰（如数组下标从1开始时，0可能被误判为有效位置）。
* **核心代码片段**：
    ```cpp
    int a[200010], lst[1000010];
    int main() {
        // ... 输入处理
        for (int i = 1; i <= n; i++) {
            lst[a[i]] = -1145141919; // 初始化
        }
        int ans = 1e9;
        for (int i = 1; i <= n; i++) {
            if (i - lst[a[i]] + 1 <= ans) {
                ans = i - lst[a[i]] + 1;
            }
            lst[a[i]] = i;
        }
        // ... 输出处理
    }
    ```
* **代码解读**：
    这段代码在输入时先将`lst`初始化为大负数，确保首次出现的元素`lst[a[i]]`为初始值。遍历时，若当前位置与`lst[a[i]]`的距离更小，则更新`ans`，最后更新`lst[a[i]]`为当前位置。这种初始化方式避免了数组下标从1开始时，0被误判为有效位置的问题。
* 💡 **学习笔记**：初始化值的选择需与实际数据范围无关，避免干扰判断。

**题解二：作者Lovely_yhb**
* **亮点**：代码极简，直接利用数组初始化为0的特性（C++全局数组默认初始化为0），无需额外初始化步骤。
* **核心代码片段**：
    ```cpp
    int lst[1000006],n,x,ans=0x3f3f3f3f;
    int main(){
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>x;
            if(lst[x]) ans=min(ans,i-lst[x]+1);
            lst[x]=i;
        }
        cout<<(ans==0x3f3f3f3f?-1:ans);
    }
    ```
* **代码解读**：
    全局数组`lst`默认初始化为0。遍历过程中，若`lst[x]≠0`（即之前出现过），则计算距离并更新`ans`。代码简洁，逻辑直白，适合快速理解核心思路。
* 💡 **学习笔记**：合理利用全局数组的默认初始化特性，简化代码。

**题解三：作者2011hym**
* **亮点**：使用`unordered_map`记录位置，展示了哈希表的通用解法，适合值域极大的场景。
* **核心代码片段**：
    ```cpp
    unordered_map<int,int>m;
    int ans=INT_MAX;
    for(int i=0;i<N;i++){
        if(m.find(A[i])!=m.end()){
            ans=min(ans,i-m[A[i]]+1);
        }
        m[A[i]]=i;
    }
    ```
* **代码解读**：
    使用`unordered_map`的`find`方法判断当前元素是否出现过。若出现过，计算距离并更新`ans`。这种方法不依赖值域大小，通用性强，但哈希表的查询时间略高于数组。
* 💡 **学习笔记**：哈希表适用于值域未知或极大的情况，数组适用于值域已知且较小的情况。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“记录位置-计算距离”的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素寻宝：找最近的重复宝石`

  * **核心演示内容**：
    一个像素小人在水平排列的像素块（代表数组元素）上向右移动，每个像素块显示对应数值。当小人遇到一个之前出现过的数值时，该数值的前一个位置和当前位置的像素块会闪烁黄色，并弹出红色数字显示两者间的距离（子数组长度）。屏幕上方实时显示当前找到的最短距离（初始为“∞”），每次更新最短距离时，数字会变大并闪烁绿色。

  * **设计思路简述**：
    采用8位像素风格（如FC游戏画面），用彩色像素块区分不同数值，增强视觉记忆。闪烁和音效（如“叮”）强化关键操作（记录位置、更新最小值），帮助学习者关注核心步骤。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕下方显示水平排列的像素块（共N个，每个块宽16px，高16px），块内显示对应数值（如“3”“9”等），背景色为淡蓝色。
          - 屏幕上方显示“当前最短距离：∞”（白色文字），右侧有控制面板（开始/暂停、单步、重置按钮，速度滑块）。
          - 播放8位风格背景音乐（轻快的电子乐）。

    2.  **遍历开始**：
          - 像素小人（黄色，8x8px）从第一个像素块（位置1）开始，每0.5秒向右移动一格（速度可通过滑块调整）。
          - 当小人移动到第i个块时，该块背景色变为粉色（表示当前处理元素）。

    3.  **记录位置与计算距离**：
          - 若当前块数值未出现过（`lst[x]==0`）：屏幕左侧的“位置记录板”（白色区域）中，对应数值的位置更新为i（如“3→1”），伴随“滴”的轻音效。
          - 若当前块数值已出现过（`lst[x]≠0`）：
              * 前一个位置（`lst[x]`）的块和当前块（i）同时闪烁黄色（频率1Hz，持续1秒）。
              * 两块之间弹出红色箭头，箭头上方显示距离`i - lst[x] + 1`（如“4”），伴随“叮”的音效。
              * 屏幕上方的“当前最短距离”更新为该距离（若更小），数字变大并闪烁绿色（持续0.5秒）。
              * 位置记录板中对应数值的位置更新为i（如“3→4”）。

    4.  **结束状态**：
          - 遍历完成后，若最短距离未更新（仍为“∞”），屏幕显示“-1”（红色），播放“呜”的短促音效；否则显示最短距离（绿色），播放“胜利”音效（音调上扬），所有像素块背景色变为绿色。

  * **旁白提示**：
      * （小人移动时）“现在处理第i个元素，数值是x。”
      * （首次出现时）“x是第一次出现，记录它的位置i。”
      * （重复出现时）“x之前在位置lst[x]出现过，计算子数组长度i - lst[x] + 1，更新最短距离！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到每个元素的位置记录和距离计算过程，理解“为什么最短子数组一定是两个相同元素的最近间距”。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的核心是“记录最近出现位置”，这种思路还可用于：
        - **最长重复子数组**：记录每个元素最近出现的位置，计算最大距离。
        - **无重复字符的最长子串**：记录每个字符最近出现的位置，用滑动窗口维护无重复区间。
        - **最近的重复元素**：直接返回最近的两个重复元素的距离。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P3955** - `图书管理员`
          * 🗣️ **推荐理由**：此题需要记录书号的出现位置，与本题“记录最近位置”的思路类似，可巩固对哈希表/数组记录的应用。
    2.  **洛谷 P5016** - `龙虎斗`
          * 🗣️ **推荐理由**：此题涉及区间处理和位置记录，通过练习可提升对数组操作的熟练度。
    3.  **洛谷 P1102** - `A-B数对`
          * 🗣️ **推荐理由**：此题需要统计元素出现次数，结合哈希表的使用，与本题思路互补，适合拓展。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们来说是非常宝贵的参考：
</insights_intro>

> **参考经验 (来自作者Perfect_Youth)**：“赛时吃三发罚时，我太唐。” 作者提到在比赛中因未正确初始化记录数组导致错误。例如，初始时未将`lst`数组初始化为0，导致首次出现的元素被误判为重复。

> **点评**：这位作者的经验提醒我们，数组的初始化非常重要。在C++中，全局数组默认初始化为0，但局部数组需要手动初始化（如`memset`）。调试时，可通过打印中间变量（如`lst[x]`的值）快速定位问题。这是一个实用的调试技巧，值得我们借鉴。

-----

<conclusion>
本次关于“Shortest Duplicate Subarray”的C++解题分析就到这里。希望这份学习指南能帮助大家理解核心算法，掌握记录位置的技巧。记住，编程的关键在于多思考、多练习，遇到问题时不要慌，通过调试和分析总能找到解决方法。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：148.57秒
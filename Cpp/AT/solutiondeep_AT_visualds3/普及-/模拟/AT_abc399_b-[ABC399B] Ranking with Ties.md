# 题目信息

# [ABC399B] Ranking with Ties

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc399/tasks/abc399_b

编号为 $1$ 至 $N$ 的 $N$ 人参加了一场竞赛，其中第 $i$ 人（$1 \leq i \leq N$）的 **得分** 为 $P_i$。

本竞赛的 **排名** 按照以下流程确定：

1. 准备变量 $r$ 并初始化为 $r = 1$。初始时所有 $N$ 人的排名均为未确定状态。
2. 重复以下操作直到所有 $N$ 人的排名确定：
   - 设当前未确定排名的人中最高得分为 $x$，且得分为 $x$ 的人数为 $k$。将所有得分为 $x$ 的 $k$ 人的排名确定为 $r$ 位，然后将 $r$ 增加 $k$。

请输出这 $N$ 人各自的排名。

## 说明/提示

### 约束条件

- $1 \leq N \leq 100$
- $1 \leq P_i \leq 100$
- 所有输入均为整数

### 样例解释 1

以下为 $N\ (=4)$ 人排名的确定流程：
1. 准备变量 $r$ 并初始化为 $r = 1$。初始时所有 4 人的排名均为未确定状态。
2. 当前未确定排名的是人 1、2、3、4，其中最高得分为 $P_2\ (=12)$。因此确定人 2 的排名为 $r\ (=1)$ 位，之后将 $r$ 增加 1 得 $r = 2$。
3. 当前未确定排名的是人 1、3、4，其中最高得分为 $P_3 = P_4\ (=9)$。因此确定人 3、4 的排名为 $r\ (=2)$ 位，之后将 $r$ 增加 2 得 $r = 4$。
4. 当前未确定排名的是人 1，其得分为 $P_1\ (=3)$。因此确定人 1 的排名为 $r\ (=4)$ 位，之后将 $r$ 增加 1 得 $r = 5$。
5. 所有 4 人的排名已确定，流程结束。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4

3 12 9 9```

### 输出

```
4

1

2

2```

## 样例 #2

### 输入

```
3

3 9 6```

### 输出

```
3

1

2```

## 样例 #3

### 输入

```
4

100 100 100 100```

### 输出

```
1

1

1

1```

## 样例 #4

### 输入

```
8

87 87 87 88 41 38 41 38```

### 输出

```
2

2

2

1

5

7

5

7```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC399B] Ranking with Ties 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC399B] Ranking with Ties”这道C++编程题。这道题的核心是模拟竞赛排名的确定过程，通过一步步操作理解如何根据得分分配排名。本指南将帮助大家梳理题目思路，掌握核心算法，并通过可视化动画直观感受排名分配的过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟` (属于“常见算法/技巧分类”中的“模拟”)

🗣️ **初步分析**：
> 解决这道题的关键在于“模拟”题目中描述的排名确定流程。模拟算法就像按照一份“任务清单”一步步操作——严格遵循题目给出的规则，逐步完成所有步骤。比如，你可以想象自己是一个“排名管理员”，需要按规则给每个参赛者发“排名卡”，每次处理当前最高分的群体，再更新下一批的起始排名。

在本题中，模拟的核心流程是：
1. 初始化变量 `r=1`（当前批次的起始排名）。
2. 找到当前未确定排名的最高分 `x`，统计得分为 `x` 的人数 `k`。
3. 将这 `k` 人的排名设为 `r`，然后将 `r` 增加 `k`（因为下一批的起始排名要跳过这 `k` 人）。
4. 重复直到所有人的排名确定。

核心难点在于：如何高效跟踪“当前未确定排名的最高分”，以及如何正确计算每一批次的 `r`。优质解法通常会先将分数排序（降序），然后按顺序处理相同分数的组，避免重复查找。

可视化设计思路：我们将用像素动画展示“分数条”从高到低排列，每次处理一个分数组时，该组的像素块会闪烁并标上当前 `r` 值，同时 `r` 的数值会动态更新（例如从1→2→4…）。动画中会用不同颜色区分已处理和未处理的分数，并用音效（如“叮”声）提示每一批次的完成。

---

## 2. 精选优质题解参考

<eval_intro>
由于当前提供的题解信息中“暂无题解”，我们将从学习者角度出发，总结通用的解题思路和学习建议，帮助大家快速上手。
</eval_intro>

**通用学习建议**：
- **理清规则**：先仔细阅读题目描述的排名规则，明确“每一步处理当前最高分的群体”这一核心逻辑。
- **排序预处理**：将分数降序排序后，可以快速找到当前最高分（即排序后的第一个未处理的分数）。
- **统计相同分数**：在排序后的数组中，连续相同的分数即为当前批次需要处理的群体，统计其数量 `k` 即可。
- **记录排名**：为了保留原始顺序的排名结果，需要将排序后的分数与原位置关联（例如用结构体或pair存储分数和原索引）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合问题特性，我为大家提炼了核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何高效找到“当前未确定排名的最高分”？
    * **分析**：直接模拟时，每次需要遍历所有未确定排名的人找最高分，效率较低（但本题N≤100，足够用）。更高效的方法是先将分数降序排序，这样排序后的数组中，未处理的最高分就是当前第一个未被处理的元素。例如，排序后的数组是 `[12,9,9,3]`，第一次处理12，第二次处理9、9，第三次处理3。
    * 💡 **学习笔记**：预处理（如排序）可以将“动态查找”转化为“静态遍历”，简化后续操作。

2.  **关键点2**：如何处理“相同分数的群体”并正确更新 `r`？
    * **分析**：排序后，连续相同的分数即为同一批次的群体。例如，排序后的数组是 `[88,87,87,87,41,41,38,38]`（样例4），第一个批次是88（k=1，r=1），第二个批次是87（k=3，r=2），第三个批次是41（k=2，r=5），最后是38（k=2，r=7）。需要统计连续相同分数的数量 `k`，然后将 `r` 增加 `k`。
    * 💡 **学习笔记**：统计连续相同元素的数量时，可以用循环或双指针法（如从当前位置开始，找到最后一个相同的元素）。

3.  **关键点3**：如何保留原始顺序的排名结果？
    * **分析**：排序会打乱原始顺序，但我们需要输出原始顺序的排名。因此，需要将每个分数与原索引关联存储（例如用 `vector<pair<int, int>>` 存储 `{分数, 原索引}`），排序后处理，最后根据原索引填充结果数组。
    * 💡 **学习笔记**：当需要保留原始位置信息时，用“值+索引”的结构存储是常用技巧。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题的分析，总结以下通用解题技巧：
</summary_best_practices>
-   **预处理排序**：将数据排序后，许多动态查找问题可以转化为静态遍历，简化逻辑。
-   **关联存储索引**：需要保留原始顺序时，用“值+索引”的结构存储数据。
-   **双指针统计连续相同值**：在排序后的数组中，用双指针法快速统计连续相同元素的数量（如 `left` 和 `right` 指针）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
虽然当前无题解，但我们可以基于上述思路，编写一个清晰、完整的核心C++实现。以下代码综合了预处理排序、关联索引、双指针统计等技巧，能够高效解决问题。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码通过预处理排序、关联原索引，并利用双指针统计连续相同分数的数量，最终按原始顺序输出排名。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>

    using namespace std;

    int main() {
        int N;
        cin >> N;
        vector<pair<int, int>> scores; // 存储 {分数, 原索引}
        for (int i = 0; i < N; ++i) {
            int p;
            cin >> p;
            scores.emplace_back(p, i); // 原索引从0开始
        }

        // 按分数降序排序（分数相同则原索引不影响）
        sort(scores.begin(), scores.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            return a.first > b.first;
        });

        vector<int> rank(N); // 存储原顺序的排名
        int r = 1; // 当前批次的起始排名
        int i = 0; // 排序后的数组指针

        while (i < N) {
            int current_score = scores[i].first;
            int k = 0; // 当前批次的人数
            // 统计连续相同分数的数量k
            while (i + k < N && scores[i + k].first == current_score) {
                k++;
            }
            // 将这k人的排名设为r
            for (int j = 0; j < k; ++j) {
                int original_index = scores[i + j].second;
                rank[original_index] = r;
            }
            // 更新r和i
            r += k;
            i += k;
        }

        // 输出原顺序的排名（注意题目中输入的索引是1-based，这里调整为1-based）
        for (int i = 0; i < N; ++i) {
            cout << rank[i] << endl;
        }

        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并存储分数与原索引的关联对，然后按分数降序排序。接着通过双指针法统计连续相同分数的数量 `k`，将这 `k` 人的排名设为当前 `r`，并更新 `r` 为 `r + k`。最后按原顺序输出排名。核心逻辑是排序后遍历，统计连续相同分数的群体并分配排名。

---
<code_intro_selected>
由于当前无题解，我们以通用核心代码为例，分析其核心片段的实现思路。
</code_intro_selected>

**通用核心代码片段分析**
* **亮点**：通过排序和双指针法高效统计连续相同分数的群体，避免了重复查找最高分的过程；关联原索引确保结果按原始顺序输出。
* **核心代码片段**：
    ```cpp
    // 排序后统计连续相同分数的数量k
    int current_score = scores[i].first;
    int k = 0;
    while (i + k < N && scores[i + k].first == current_score) {
        k++;
    }
    // 分配排名
    for (int j = 0; j < k; ++j) {
        int original_index = scores[i + j].second;
        rank[original_index] = r;
    }
    r += k;
    i += k;
    ```
* **代码解读**：
    > 这段代码中，`current_score` 是当前批次的最高分（排序后的当前元素）。通过 `while` 循环统计连续相同分数的数量 `k`（即当前批次的人数）。然后遍历这 `k` 个元素，将它们的原索引对应的 `rank` 数组位置设为当前 `r`。最后，`r` 增加 `k`（下一批次的起始排名），`i` 指针跳过已处理的 `k` 个元素，继续处理下一批次。

* 💡 **学习笔记**：双指针法是统计连续相同元素数量的高效方法，适用于排序后的数组或有序数据。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解排名分配的过程，我们设计了一个“像素排名管理员”动画，用8位像素风格展示每一步的操作！
</visualization_intro>

  * **动画演示主题**：`像素排名管理员的任务`（复古FC游戏风格）

  * **核心演示内容**：展示分数排序后的像素条，每次处理一个分数组（相同分数的群体），分配排名并更新 `r`，直到所有人的排名确定。

  * **设计思路简述**：采用8位像素风格（如FC红白机的简洁色调），用不同颜色的像素条表示分数高低（红色最高，蓝色最低）。通过闪烁、移动等动画效果突出当前处理的群体，配合音效提示关键操作，让学习者清晰看到排名分配的每一步。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：
          * 屏幕左侧展示“分数条”区域：每个参赛者对应一个像素条（高度代表分数，颜色从红到蓝递减），下方标注原索引（如“1”“2”）。
          * 右侧展示“排名卡”区域：初始为空白，后续会填充排名数字。
          * 底部控制面板：单步/自动播放按钮、速度滑块（调节动画快慢）、重置按钮。
          * 播放8位风格的轻快背景音乐（如《超级马里奥》的经典旋律变奏）。

    2.  **排序动画**：
          * 点击“开始”后，像素条从左到右自动排列成降序（高→低），伴随“滑动”音效（类似拼图块移动的“咔嗒”声）。

    3.  **处理第一批次**：
          * 当前最高分的像素条（如红色）闪烁3次，顶部弹出文字“当前最高分！”。
          * 统计该分数的数量 `k`（如样例1中k=1），所有相同分数的像素条同时高亮（边框变粗）。
          * 这些像素条对应的“排名卡”区域显示当前 `r`（初始为1），伴随“叮”的音效。
          * `r` 的数值从1变为 `r + k`（如1→2），用数字放大动画展示变化。

    4.  **处理后续批次**：
          * 已处理的像素条颜色变浅（如灰色），未处理的保持原色。
          * 重复步骤3，处理下一个最高分的群体（如样例1中的两个9分，k=2），显示 `r=2`，然后 `r` 变为4，以此类推。

    5.  **完成所有处理**：
          * 所有像素条的“排名卡”填满后，播放“胜利”音效（如《超级玛丽》的通关旋律），屏幕弹出“任务完成！”的像素文字。
          * 支持“重置”按钮，重新开始动画。

    6.  **交互功能**：
          * 单步模式：点击“单步”按钮，逐批次处理，适合仔细观察每一步。
          * 自动播放：根据速度滑块（慢/中/快）自动连续处理，适合整体流程观察。

  * **旁白提示**：
      * （排序时）“看！分数条自动从高到低排好队啦~”
      * （处理批次时）“当前最高分是红色条，有1个人，他们的排名是1！”
      * （更新r时）“r现在要加上人数1，变成2啦~”
      * （完成时）“所有排名都确定啦！你学会了吗？”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到分数排序、批次处理、排名分配的全过程，就像跟着“像素排名管理员”一起完成任务一样！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是模拟“分组处理相同值”的流程，这种思路在许多问题中都有应用。我们可以通过以下练习巩固这一技巧。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 处理“相同值分组”的问题（如统计班级中相同分数的人数）。
      * 模拟“批次处理”的流程（如食堂打饭时，同一班级的同学一起打饭）。
      * 排序后处理连续相同元素（如统计数组中各元素的出现次数）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上考察类似思维的题目：

    1.  **洛谷 P1093 奖学金**
          * 🗣️ **推荐理由**：这道题需要根据分数排序后分配奖学金，涉及分组处理相同分数的学生，与本题的“批次排名”思路类似。
    2.  **洛谷 P1781 宇宙总统**
          * 🗣️ **推荐理由**：题目要求统计得票并确定排名，需要处理相同票数的情况，练习如何排序和分组。
    3.  **洛谷 P2676 [USACO07DEC]Bookshelf B**
          * 🗣️ **推荐理由**：题目需要将牛按高度排序后分组，与本题的“排序+分组”思路一致，适合巩固模拟能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但根据题目特点，我们可以总结：在处理“分组模拟”问题时，先理清规则、预处理排序、关联原始索引是关键。动手编写代码前，建议先手动模拟样例（如样例1的4人排名流程），确保理解每一步的操作，避免逻辑错误。
</insights_intro>

-----

<conclusion>
本次关于“[ABC399B] Ranking with Ties”的C++解题分析就到这里。通过模拟排名流程、编写核心代码和观看像素动画，相信大家已经掌握了这类问题的解决方法。记住，遇到模拟题时，先理清规则、设计预处理步骤，再动手编码会更高效！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：140.16秒
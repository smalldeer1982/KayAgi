# 题目信息

# Exam and Wizard

## 题目描述

[problemUrl]: https://atcoder.jp/contests/keyence2019/tasks/keyence2019_c

大学生の高橋君は $ N $ 個の試験を受けてすべてに合格する必要があります． 現在，$ i $ 番目の試験の準備度は $ A_{i} $ です． また，高橋君の入念な調査によって，$ i $ 番目の試験に合格するためには準備度を $ B_{i} $ 以上にしなくてはならないことが分かっています．

このままだとすべての試験に合格できないかもしれないと思った高橋君は，魔法使いの青木君に頼んで， 試験の準備度の総和は変えずに，なるべく少ない数の試験の準備度を変更してもらうことで試験を乗り切ることにしました．

高橋君に代わって，以下の条件を満たす数列 $ C_1,\ C_2,\ ...,\ C_{N} $ を考えたときの $ A_i $ と $ C_i $ が異なるような $ i $ の個数の最小値を求めてください． そのような数列 $ C_1,\ C_2,\ ...,\ C_{N} $ が構成できない場合は $ -1 $ を出力してください．

- 数列 $ A_1,\ A_2,\ ...,\ A_{N} $ の総和と数列 $ C_1,\ C_2,\ ...,\ C_{N} $ の総和は等しい
- どの $ i $ に対しても，$ B_i\ \leq\ C_i $ が成り立つ

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 1\ \leq\ B_i\ \leq\ 10^9 $
- $ A_i,\ B_i $ は整数

### Sample Explanation 1

$ (A_1,\ A_2,\ A_3)\ =\ (2,\ 3,\ 5) $ ，$ (B_1,\ B_2,\ B_3)\ =\ (3,\ 4,\ 1) $ であり，このままでは $ 1 $ 番目と $ 2 $ 番目の試験に合格できません． 以下のように $ C_1,\ C_2,\ C_3 $ を構成すれば，$ A_i $ と $ C_i $ が異なるような $ i $ の個数の最小値 $ 3 $ を達成できます． - $ (C_1,\ C_2,\ C_3)\ =\ (3,\ 5,\ 2) $

### Sample Explanation 2

この場合は，何もしなくても全ての試験に合格できます．

### Sample Explanation 3

この場合は，どのようにしても全ての試験に合格することはできません．

## 样例 #1

### 输入

```
3

2 3 5

3 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3

2 3 3

2 2 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3

17 7 1

25 6 14```

### 输出

```
-1```

## 样例 #4

### 输入

```
12

757232153 372327760 440075441 195848680 354974235 458054863 463477172 740174259 615762794 632963102 529866931 64991604

74164189 98239366 465611891 362739947 147060907 118867039 63189252 78303147 501410831 110823640 122948912 572905212```

### 输出

```
5```

# AI分析结果



---
# 💡 Kay的C++算法解析：Exam and Wizard 深入学习指南 💡

<introduction>
今天我们来一起分析“Exam and Wizard”这道C++编程题。这道题需要我们找到调整考试准备度的最小次数，同时满足所有考试的合格要求。本指南将帮助大家梳理题目思路，理解核心贪心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
解决“Exam and Wizard”这道题，关键在于理解并运用贪心算法。贪心算法就像“每次都选当前最划算的选项”，比如买零食时优先挑性价比最高的，最终整体花费可能最优。在本题中，我们需要在调整最少考试准备度的前提下，满足所有考试的合格要求，这正是贪心算法的典型应用场景。

- **题解思路与难点**：题目要求调整后的数组 \( C \) 满足两个条件：总和等于原数组 \( A \) 的总和，且每个 \( C_i \geq B_i \)。核心难点是如何选择最少的调整次数（即最少的 \( C_i \neq A_i \) 的数量）。优质题解的思路是：先计算每个 \( A_i \) 与 \( B_i \) 的差值（贡献值），若总贡献值（所有 \( A_i - B_i \) 的和）为负，直接无法满足；否则，通过贪心策略选择保留尽可能多的 \( A_i \)（即不调整这些 \( A_i \)），从而减少调整次数。
- **核心算法流程**：首先计算总贡献值 \( ans \)，若 \( ans < 0 \) 输出 -1；否则，收集所有 \( A_i \geq B_i \) 的贡献值（即 \( A_i - B_i \)），将这些贡献值从小到大排序，依次“扣除”最小的贡献值（即保留这些 \( A_i \)），直到无法再扣除为止。最终调整次数为总数量减去保留的数量。
- **可视化设计思路**：我们将用8位像素风格动画演示贡献值的排序和贪心选择过程。例如，每个贡献值用一个像素方块表示，颜色越浅代表值越小；排序时方块从左到右按大小排列；贪心选择时，逐个“点亮”可保留的方块（伴随“叮”的音效），并动态显示剩余可扣除的总贡献值。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码可读性、算法有效性等方面的评估，以下题解（作者：HyyypRtf06）评分4.5星，值得重点学习。
</eval_intro>

**题解一：来源：HyyypRtf06的题解**
* **点评**：这份题解思路非常清晰，用“劫富济贫”的比喻形象地解释了贪心策略的核心。代码结构简洁，变量命名虽可更明确（如用 `required_sum` 代替 `ans`），但整体逻辑一目了然。算法上，通过排序贡献值并贪心选择最小的，时间复杂度为 \( O(n \log n) \)，适用于 \( n \leq 10^5 \) 的规模，效率很高。实践价值方面，代码直接处理了边界情况（如总贡献值为负、所有 \( A_i \geq B_i \) 等），是竞赛中的实用写法。作者特别提醒“注意开long long”，这对处理大数问题至关重要，是值得学习的细节。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何判断是否存在可行解？
    * **分析**：首先计算所有 \( A_i - B_i \) 的总和 \( ans \)。若 \( ans < 0 \)，说明即使将所有 \( A_i \) 调整为 \( B_i \)（甚至更高），总和仍不足，无法满足条件。若 \( ans \geq 0 \)，则可能存在可行解。
    * 💡 **学习笔记**：总和的检查是问题的“准入条件”，必须优先处理。

2.  **关键点2**：如何选择最少的调整次数？
    * **分析**：我们需要尽可能多地保留 \( A_i \)（即不调整），这些 \( A_i \) 需满足 \( A_i \geq B_i \)（否则必须调整）。将这些 \( A_i \) 的贡献值（\( A_i - B_i \)）从小到大排序，优先扣除最小的贡献值（即保留这些 \( A_i \)），这样能保留最多的 \( A_i \)，从而减少调整次数。
    * 💡 **学习笔记**：贪心选择“最小的可用资源”是保留最多元素的关键。

3.  **关键点3**：如何处理边界情况？
    * **分析**：若所有 \( A_i \geq B_i \)（即 \( flag = true \)），则无需调整，直接输出0；若总贡献值 \( ans \geq 0 \) 但无法通过扣除贡献值满足，需计算剩余调整次数。
    * 💡 **学习笔记**：边界情况的处理体现了代码的严谨性，必须逐一验证。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将问题转化为“贡献值的分配”，通过总和和个体贡献值的关系简化问题。
- **排序优化**：对贡献值排序后贪心选择，是处理“最少调整次数”类问题的常用技巧。
- **大数处理**：使用 `long long` 避免整数溢出（如总贡献值可能超过 `int` 范围）。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了HyyypRtf06题解的思路，优化了变量命名，确保逻辑清晰且可直接编译运行。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        vector<long long> A(n), B(n);
        for (int i = 0; i < n; ++i) cin >> A[i];
        for (int i = 0; i < n; ++i) cin >> B[i];

        long long total_contribution = 0;
        vector<long long> surplus; // 存储A[i] >= B[i]的贡献值（A[i]-B[i]）
        bool all_sufficient = true; // 是否所有A[i] >= B[i]

        for (int i = 0; i < n; ++i) {
            long long diff = A[i] - B[i];
            total_contribution += diff;
            if (diff >= 0) {
                surplus.push_back(diff);
            } else {
                all_sufficient = false;
            }
        }

        if (all_sufficient) {
            cout << 0 << endl; // 所有A[i]已满足B[i]，无需调整
            return 0;
        }

        if (total_contribution < 0) {
            cout << -1 << endl; // 总贡献不足，无法满足
            return 0;
        }

        sort(surplus.begin(), surplus.end()); // 按贡献值从小到大排序
        int keep = 0; // 可以保留的A[i]数量（不调整的数量）
        for (long long s : surplus) {
            if (total_contribution >= s) {
                total_contribution -= s;
                keep++;
            } else {
                break;
            }
        }

        // 调整次数 = 总数量 - 可以保留的数量（因为必须调整不满足B[i]的，以及无法保留的）
        cout << n - keep << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入，计算每个 \( A_i \) 与 \( B_i \) 的差值总和 \( total\_contribution \)，并收集所有非负的贡献值到 `surplus` 中。若所有 \( A_i \) 已满足 \( B_i \)，直接输出0；若总和不足，输出-1。否则，对 `surplus` 排序后贪心选择最小的贡献值扣除，计算可保留的 \( A_i \) 数量，最终调整次数为总数量减去保留数量。

---
<code_intro_selected>
接下来，我们将剖析题解中的核心代码片段，理解其关键逻辑。
</code_intro_selected>

**题解一：来源：HyyypRtf06的题解**
* **亮点**：通过排序贡献值并贪心选择，以 \( O(n \log n) \) 的时间复杂度高效解决问题；代码简洁，边界条件处理完整。
* **核心代码片段**：
    ```cpp
    sort(v.begin(), v.end());
    if(ans>=0){
        for(int i=0;i<v.size();i++){
            if(ans>=v[i]){
                ans-=v[i];
                sum--;
            }
            else{
                break;
            }
        }
        cout<<sum<<endl;
    }
    ```
* **代码解读**：
    > 这段代码是贪心策略的核心。首先对存储非负贡献值的 `v` 排序（从小到大），然后遍历每个贡献值 `v[i]`。若当前总贡献值 `ans` 足够扣除 `v[i]`（即保留该 \( A_i \)），则扣除 `v[i]` 并减少调整次数（`sum--`）。当无法扣除时，停止遍历。最终 `sum` 即为需要调整的次数。例如，若 `v` 是 `[1,2,3]`，`ans` 是5，会先扣除1（sum-1），再扣除2（sum-2），此时 `ans` 剩余2，无法扣除3，最终调整次数为 `n - 2`。
* 💡 **学习笔记**：排序后从小到大扣除贡献值，能保留最多的 \( A_i \)，从而最小化调整次数。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心算法的执行过程，我设计了一个“像素贡献值探险”的8位风格动画。让我们一起“看”到贡献值的排序和贪心选择！
</visualization_intro>

  * **动画演示主题**：像素贡献值探险——调整考试准备度的最小次数挑战！

  * **核心演示内容**：展示贡献值的排序过程、贪心扣除的步骤，以及调整次数的动态变化。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用不同颜色的像素方块表示贡献值（颜色越浅值越小），通过排序动画和扣除动画直观展示贪心策略。关键步骤的音效（如排序时的“唰唰”声，扣除时的“叮”声）强化操作记忆，游戏化的“关卡”设计（每扣除一个贡献值算过一关）增加趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是“贡献值森林”（每个贡献值用一个像素方块表示，高度代表值大小，颜色从深到浅对应值从小到大）；右侧是“控制面板”（单步/自动按钮、速度滑块）。
          * 播放8位风格的轻快背景音乐（类似《超级玛丽》的开场曲）。

    2.  **输入与初始计算**：
          * 输入 \( A \) 和 \( B \) 数组后，计算每个 \( A_i - B_i \) 的值，用像素文字显示在方块上方。
          * 总贡献值 \( ans \) 显示在屏幕顶部，初始为所有差值的和。

    3.  **排序动画**：
          * 点击“排序”按钮，贡献值方块从左到右自动排列，颜色浅的（值小的）逐渐移动到左侧，伴随“唰唰”的音效，最终形成从小到大的顺序。

    4.  **贪心扣除演示**：
          * 点击“开始”按钮，算法自动执行扣除：
            - 当前处理的方块（最小贡献值）闪烁，伴随“叮”的音效。
            - 总贡献值 \( ans \) 减少该方块的值，用像素数字动态更新。
            - 该方块被标记为“保留”（颜色变为绿色），调整次数（初始为 \( n \)）减少1，显示在屏幕底部。
            - 若 \( ans \) 不足以扣除当前方块，动画暂停，显示“无法继续扣除”。

    5.  **结果展示**：
          * 最终调整次数用大像素文字显示，伴随“胜利”音效（类似《超级玛丽》吃到金币的声音）。
          * 若总贡献值不足，显示“-1”并播放“失败”音效（短促的“咚”声）。

  * **旁白提示**：
      * （排序时）“看！贡献值方块在排队，小的在前，大的在后，这样我们就能优先选小的啦～”
      * （扣除时）“现在扣除这个小方块，总贡献值减少，调整次数也减少哦！”
      * （结束时）“最终调整次数是... 成功！你学会了贪心的魔法！”

<visualization_conclusion>
通过这个像素动画，我们不仅能看到贪心算法的每一步操作，还能在轻松的游戏氛围中理解“为什么要排序”“为什么选小的贡献值”这些关键问题。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的贪心策略后，我们可以进一步思考贪心算法在其他场景的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 贪心算法适用于“每一步选当前最优”的问题，例如：
        - 活动选择问题（选结束时间最早的活动，最大化活动数）；
        - 区间覆盖问题（选覆盖最远的区间，最小化覆盖次数）；
        - 硬币找零问题（优先用大面额硬币，最小化硬币数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1094 纪念品分组**
          * 🗣️ **推荐理由**：这道题需要将纪念品分组，每组价格之和不超过给定值，求最少分组数。贪心策略（将最大和最小配对）与本题的“选最小贡献值”思路类似，适合巩固贪心思维。
    2.  **洛谷 P1223 排队接水**
          * 🗣️ **推荐理由**：这道题要求安排接水顺序，使所有人等待时间总和最小。通过排序（时间短的先接）优化总等待时间，是贪心算法的经典应用。
    3.  **洛谷 P1803 凌乱的yyy / 线段覆盖**
          * 🗣️ **推荐理由**：这道题需要选择最多的不重叠线段，通过排序（按结束时间）后贪心选择，与本题的“选最小贡献值”异曲同工。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解作者HyyypRtf06特别提醒“注意开long long”，这是处理大数问题的重要经验。
</insights_intro>

> **参考经验 (来自 HyyypRtf06)**：“注意开long long！”
>
> **点评**：在本题中，总贡献值 \( ans \) 可能非常大（例如 \( n=1e5 \)，每个 \( A_i-B_i=1e9 \)，总和为 \( 1e14 \)），超出 `int` 的范围（约 \( 2e9 \)）。使用 `long long` 可以避免溢出错误。这提醒我们，在处理涉及大数的问题时，一定要优先考虑变量类型的选择，避免因溢出导致错误。

---

<conclusion>
本次关于“Exam and Wizard”的C++解题分析就到这里。希望这份学习指南能帮助大家理解贪心算法的应用，掌握调整最少次数的解题技巧。记住，贪心的关键是“每一步选最优”，多练习类似题目，你会更熟练！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：142.28秒
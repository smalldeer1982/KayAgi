# 题目信息

# [ABC371C] Make Isomorphic

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_c

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる単純無向グラフ $ G,H $ が与えられます。 $ G $ には $ M\ _\ G $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ G) $ の辺は頂点 $ u\ _\ i $ と頂点 $ v\ _\ i $ を結んでいます。 $ H $ には $ M\ _\ H $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ H) $ の辺は頂点 $ a\ _\ i $ と頂点 $ b\ _\ i $ を結んでいます。

あなたは、グラフ $ H $ に対して次の操作を $ 0 $ 回以上の好きな回数繰り返すことができます。

- $ 1\leq\ i\lt\ j\leq\ N $ を満たす整数の組 $ (i,j) $ をひとつ選ぶ。$ A\ _\ {i,j} $ 円を支払って、頂点 $ i $ と頂点 $ j $ を結ぶ辺がなければ追加し、あれば取り除く。

$ G $ と $ H $ を同型にするために少なくとも何円支払う必要があるか求めてください。

単純無向グラフとは？ **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

グラフの同型とは？ $ N $ 頂点のグラフ $ G $ と $ H $ が**同型**であるとは、ある $ (1,2,\ldots,N) $ の並べ替え $ (P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が存在して、どの $ 1\leq\ i\lt\ j\leq\ N $ に対しても

- $ G $ に頂点 $ i, $ 頂点 $ j $ を結ぶ辺が存在するとき、かつそのときに限り $ H $ に頂点 $ P\ _\ i, $ 頂点 $ P\ _\ j $ を結ぶ辺が存在する

が成り立つことをいいます。

## 说明/提示

### 制約

- $ 1\leq\ N\leq8 $
- $ 0\leq\ M\ _\ G\leq\dfrac{N(N-1)}2 $
- $ 0\leq\ M\ _\ H\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ G) $
- $ (u\ _\ i,v\ _\ i)\neq(u\ _\ j,v\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ G) $
- $ 1\leq\ a\ _\ i\lt\ b\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ H) $
- $ (a\ _\ i,b\ _\ i)\neq(a\ _\ j,b\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ H) $
- $ 1\leq\ A\ _\ {i,j}\leq\ 10\ ^\ 6\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

与えられたグラフはそれぞれ以下のようになります。 !\[\](https://img.atcoder.jp/abc371/fbdb304dc71eecd7ddec97276a9c7040.png) たとえば、$ H $ に対して次のような $ 4 $ つの操作を順に行うことで、$ 9 $ 円を支払って$ G $ と $ H $ を同型にすることができます。 - $ (i,j)=(1,3) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(2,5) $ として操作を行う。$ H $ には頂点 $ 2 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 2 $ 円を支払ってこれを追加する。 - $ (i,j)=(1,5) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 5 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(3,5) $ として操作を行う。$ H $ には頂点 $ 3 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 5 $ 円を支払ってこれを追加する。 操作の結果、$ H $ は以下のようになります。 !\[\](https://img.atcoder.jp/abc371/68a56da8ec89b769989ae7d07bf163cd.png) 支払う金額を $ 8 $ 円以下にして $ G $ と $ H $ を同型にすることはできないため、`9` を出力してください。

### Sample Explanation 2

たとえば、$ (i,j)=(2,3),(2,4),(3,4) $ とした $ 3 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 3

たとえば、$ (i,j)=(4,5) $ とした $ 1 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 4

$ G $ や $ H $ には辺が含まれていないこともあります。 また、一度も操作をする必要がないこともあります。

## 样例 #1

### 输入

```
5
4
1 2
2 3
3 4
4 5
4
1 2
1 3
1 4
1 5
3 1 4 1
5 9 2
6 5
3```

### 输出

```
9```

## 样例 #2

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
9 1 1 1
1 1 1
1 1
9```

### 输出

```
3```

## 样例 #3

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
5 4 4 4
4 4 4
4 4
5```

### 输出

```
5```

## 样例 #4

### 输入

```
2
0
0
371```

### 输出

```
0```

## 样例 #5

### 输入

```
8
13
1 8
5 7
4 6
1 5
7 8
1 6
1 2
5 8
2 6
5 6
6 7
3 7
4 8
15
3 5
1 7
4 6
3 8
7 8
1 2
5 6
1 6
1 5
1 4
2 8
2 6
2 4
4 7
1 3
7483 1694 5868 3296 9723 5299 4326
5195 4088 5871 1384 2491 6562
1149 6326 2996 9845 7557
4041 7720 1554 5060
8329 8541 3530
4652 3874
3748```

### 输出

```
21214```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC371C] Make Isomorphic 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（全排列）与图同构判断  

🗣️ **初步分析**：  
解决“Make Isomorphic”问题，关键在于**找到图H的顶点排列，使得H修改边后与图G同构，且修改代价最小**。简单来说，图同构就像“给图的顶点重新贴标签”——只要标签贴对了，两个图的结构（边的连接情况）就能完全一致。而我们的目标是找到“贴标签”的方式（排列），让修改H的边以匹配G的代价最小。  

由于题目中顶点数**N≤8**（非常小），**全排列枚举所有可能的顶点映射**是可行的。核心思路是：  
1. 枚举图G到图H的所有顶点排列（共8! = 40320种，完全可以处理）；  
2. 对每个排列，计算图H需要修改多少边才能与图G同构（修改代价总和）；  
3. 取所有排列中的最小代价作为答案。  

**核心算法流程**：  
- 用邻接矩阵存储图G和图H的边（快速判断边是否存在）；  
- 枚举所有排列（用`next_permutation`或`dfs`生成）；  
- 对每个排列，遍历所有顶点对(i,j)，比较G中(i,j)的边是否与H中(P[i],P[j])的边一致（P是当前排列）；  
- 不一致的边需要修改，累加其代价，最后取最小值。  

**可视化设计思路**：  
我们可以用**8位像素风格**展示图的结构和排列变化：  
- 用不同颜色的像素块表示顶点（比如G的顶点是蓝色，H的顶点是绿色）；  
- 边用像素线条连接，存在的边是实线，不存在的是虚线；  
- 排列变化时，H的顶点会“移动”到对应G的顶点位置（比如G的顶点1对应H的顶点3，那么H的顶点3会跳到G顶点1的位置）；  
- 代价计算时，不一致的边会闪烁，并显示需要支付的代价，实时更新最小代价；  
- 加入“单步执行”（逐步生成排列）、“自动播放”（快速遍历排列）和“重置”按钮，配合像素音效（比如排列生成时的“咔嗒”声，找到更优解时的“叮”声），增强互动性。  


## 2. 精选优质题解参考

### 题解一（来源：Him_shu，赞14）  
* **点评**：  
  这份题解用`dfs`生成全排列，思路清晰且符合递归逻辑。代码中用`hg`数组存储排列（`hg[i]`表示图G的顶点i对应图H的顶点`hg[i]`），邻接矩阵`g`存储图H的边，`h`临时存储排列后的图结构。计算代价时，遍历所有顶点对，比较`h`（排列后的H）与`g`（原H）的边是否一致，不一致则累加代价。  
  亮点：`dfs`生成排列的方式灵活，适合理解全排列的生成过程；邻接矩阵的使用让边的查询非常高效；代码结构工整，变量命名合理（如`hg`表示“图G到图H的映射”），容易跟随思路。  

### 题解二（来源：small_lemon_qwq，赞13）  
* **点评**：  
  此题解用`next_permutation`生成全排列，代码更简洁。`p`数组存储排列（`p[x]`表示图G的顶点x对应图H的顶点`p[x]`），邻接矩阵`f`存储图G的边，`g`存储图H的边。计算代价时，直接比较`f[p[i]][p[j]]`（排列后的G边）与`g[i][j]`（原H边）是否一致，不一致则累加代价。  
  亮点：`next_permutation`简化了全排列的生成，代码行数更少；逻辑更直接（直接比较排列后的边），适合新手快速理解核心逻辑。  

### 题解三（来源：fishing_cat，赞8）  
* **点评**：  
  此题解同样用`next_permutation`生成全排列，但代码结构更清晰。`dis`数组存储排列，`mp1`存储图G的边，`mp2`存储图H的边。计算代价时，用异或运算（`mp1[dis[i]][dis[j]] ^ mp2[i][j]`）快速判断边是否一致，异或结果为1表示需要修改，累加代价。  
  亮点：异或运算的使用简化了条件判断（无需写两个`if`语句）；代码注释详细（如“是否不同”），有助于理解关键步骤；`do-while`循环确保至少执行一次（处理初始排列）。  


## 3. 核心难点辨析与解题策略

### 1. 理解图同构的排列对应关系  
**难点**：图同构要求“G中的边(i,j)存在当且仅当H中的边(P[i],P[j])存在”，新手可能难以理解“排列P”的作用（即顶点的重新映射）。  
**策略**：用“贴标签”的比喻帮助理解——排列P就是给H的顶点贴G的标签，比如P[i] = k表示H的顶点k贴上G的顶点i的标签。此时，H中k和l之间的边是否存在，应与G中i和j之间的边是否存在一致（其中j是G的顶点，对应H的顶点l）。  

### 2. 计算每个排列的代价  
**难点**：如何高效比较两个图在某排列下的边是否一致，并计算修改代价？  
**策略**：用**邻接矩阵**存储图的边（`g[i][j] = 1`表示i和j之间有边，否则为0）。对于每个排列P，遍历所有顶点对(i,j)（i<j，避免重复），比较`G[i][j]`（G中的边）与`H[P[i]][P[j]]`（H中排列后的边）是否一致。不一致则累加`A[P[i]][P[j]]`（修改该边的代价）。  

### 3. 生成全排列  
**难点**：如何生成所有可能的顶点排列？  
**策略**：选择合适的方法：  
- 若想理解全排列的生成过程，用`dfs`（递归选择每个位置的顶点，标记已选顶点）；  
- 若想简化代码，用`next_permutation`（STL函数，生成下一个字典序排列，需要先排序初始数组）。  

### ✨ 解题技巧总结  
- **邻接矩阵的使用**：快速查询边是否存在，适合图的边操作问题；  
- **全排列枚举**：当N≤10时，全排列是可行的暴力解法；  
- **异或运算简化条件判断**：`a ^ b`为1当且仅当a和b不同，可简化“边是否一致”的判断；  
- **初始排列的处理**：用`do-while`循环确保初始排列（未修改的排列）被计算。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了`next_permutation`生成全排列和邻接矩阵存储图的思路，是最简洁的实现方式。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <algorithm>
  #include <climits>
  using namespace std;

  const int N = 10;
  int G[N][N], H[N][N]; // 邻接矩阵：G存储图G的边，H存储图H的边
  int A[N][N]; // 修改边(i,j)的代价
  int p[N]; // 排列：p[i]表示图G的顶点i对应图H的顶点p[i]
  int n, mg, mh;

  int main() {
      cin >> n >> mg;
      for (int i = 1; i <= mg; i++) {
          int u, v;
          cin >> u >> v;
          G[u][v] = G[v][u] = 1; // 无向图，边存储两次
      }
      cin >> mh;
      for (int i = 1; i <= mh; i++) {
          int u, v;
          cin >> u >> v;
          H[u][v] = H[v][u] = 1; // 无向图，边存储两次
      }
      for (int i = 1; i < n; i++) {
          for (int j = i + 1; j <= n; j++) {
              cin >> A[i][j];
              A[j][i] = A[i][j]; // 代价对称
          }
      }

      // 初始化排列：p[i] = i（初始映射为自身）
      for (int i = 1; i <= n; i++) {
          p[i] = i;
      }

      long long min_cost = LLONG_MAX;
      do {
          long long cost = 0;
          // 遍历所有顶点对(i,j)，i<j（避免重复计算边）
          for (int i = 1; i <= n; i++) {
              for (int j = i + 1; j <= n; j++) {
                  // 比较G中的边(i,j)与H中的边(p[i], p[j])是否一致
                  if (G[i][j] != H[p[i]][p[j]]) {
                      cost += A[p[i]][p[j]]; // 不一致，累加代价
                  }
              }
          }
          if (cost < min_cost) {
              min_cost = cost; // 更新最小代价
          }
      } while (next_permutation(p + 1, p + n + 1)); // 生成下一个排列

      cout << min_cost << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三部分：  
  1. **输入处理**：读取图G和图H的边（用邻接矩阵存储），读取修改边的代价（对称存储）；  
  2. **排列初始化**：初始排列为`p[i] = i`（即H的顶点i对应G的顶点i）；  
  3. **枚举排列与计算代价**：用`do-while`循环枚举所有排列，对每个排列计算修改H的边以匹配G的代价，取最小代价输出。  


### 针对各优质题解的片段赏析

#### 题解一（来源：Him_shu）  
* **亮点**：用`dfs`生成全排列，适合理解递归过程。  
* **核心代码片段**：  
  ```cpp
  int hg[N], ans = inf; // hg[i]表示图G的顶点i对应图H的顶点hg[i]
  void dfs(int pos) {
      if (pos > n) {
          // 构建排列后的图H（存储在h数组中）
          for (int i = 1; i <= m1; i++) {
              h[hg[u1[i]]][hg[v1[i]]] = h[hg[v1[i]]][hg[u1[i]]] = 1;
          }
          // 计算代价
          int sum = 0;
          for (int i = 1; i < n; i++) {
              for (int j = i + 1; j <= n; j++) {
                  if (h[i][j] != g[i][j]) {
                      sum += a[i][j];
                  }
              }
          }
          ans = min(ans, sum);
          memset(h, 0, sizeof(h)); // 清空h数组，准备下一个排列
          return;
      }
      // 递归选择顶点，生成排列
      for (int i = 1; i <= n; i++) {
          if (!hg[i]) {
              hg[i] = pos;
              dfs(pos + 1);
              hg[i] = 0; // 回溯
          }
      }
  }
  ```  
* **代码解读**：  
  - `dfs`函数的`pos`参数表示当前处理到图G的第`pos`个顶点；  
  - 当`pos > n`时，说明排列已生成（`hg`数组存储了图G到图H的映射）；  
  - 构建排列后的图H（`h`数组）：将图G的边`(u1[i], v1[i])`映射到图H的边`(hg[u1[i]], hg[v1[i]])`；  
  - 计算代价：比较`h`（排列后的H）与`g`（原H）的边是否一致，不一致则累加代价；  
  - 回溯：将`hg[i]`置0，以便下一次选择顶点。  
* 💡 **学习笔记**：`dfs`生成全排列的核心是“选择-递归-回溯”，适合理解全排列的生成逻辑，但代码量比`next_permutation`多。  


#### 题解二（来源：small_lemon_qwq）  
* **亮点**：用`next_permutation`生成全排列，代码简洁。  
* **核心代码片段**：  
  ```cpp
  int p[10], vis[10], ans = LONG_LONG_MAX;
  void dfs(int x) {
      if (x > n) {
          int cnt = 0;
          for (int i = 1; i <= n; i++) {
              for (int j = i + 1; j <= n; j++) {
                  if (f[p[i]][p[j]] != g[i][j]) {
                      cnt += a[i][j];
                  }
              }
          }
          ans = min(ans, cnt);
          return;
      }
      for (int i = 1; i <= n; i++) {
          if (!vis[i]) {
              p[x] = i;
              vis[i] = 1;
              dfs(x + 1);
              vis[i] = 0;
          }
      }
  }
  ```  
* **代码解读**：  
  - `p`数组存储排列（`p[x]`表示图G的顶点x对应图H的顶点`p[x]`）；  
  - `vis`数组标记顶点是否已被选入排列；  
  - 当`x > n`时，计算代价：比较`f[p[i]][p[j]]`（图G的边(i,j)映射到图H的边(p[i],p[j])）与`g[i][j]`（图H的边(i,j)）是否一致，不一致则累加代价；  
  - 递归选择顶点：遍历所有未被选的顶点，将其加入排列，标记为已选，递归处理下一个顶点，回溯时取消标记。  
* 💡 **学习笔记**：`next_permutation`生成全排列的代码更简洁，但`dfs`生成全排列的方式更灵活（比如可以剪枝，提前终止无效的排列）。  


#### 题解三（来源：fishing_cat）  
* **亮点**：用异或运算简化条件判断。  
* **核心代码片段**：  
  ```cpp
  void f() {
      ll num = 0;
      for (int i = 1; i <= n-1; i++)
          for (int j = i+1; j <= n; j++)
              if (mp1[dis[i]][dis[j]] ^ mp2[i][j]) // 异或判断是否不同
                  num += A[i][j];
      ans = min(ans, num);
  }
  ```  
* **代码解读**：  
  - `dis`数组存储排列（`dis[i]`表示图G的顶点i对应图H的顶点`dis[i]`）；  
  - `mp1`存储图G的边，`mp2`存储图H的边；  
  - 异或运算`mp1[dis[i]][dis[j]] ^ mp2[i][j]`：当两者不同时，结果为1，需要累加代价；  
  - 计算代价后，更新最小代价。  
* 💡 **学习笔记**：异或运算可以简化“是否不同”的判断，避免写两个`if`语句（`if (a != b)`等价于`if (a ^ b)`）。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素图的标签游戏”**（仿FC红白机风格）  

### 核心演示内容  
- 展示图G和图H的初始结构（用像素块表示顶点，线条表示边）；  
- 逐步生成全排列（H的顶点“跳”到对应G的顶点位置）；  
- 实时比较边的差异（不一致的边闪烁，显示需要支付的代价）；  
- 实时更新最小代价（屏幕右上角显示当前最小代价）。  

### 设计思路简述  
采用8位像素风格，是为了营造轻松复古的学习氛围，让学习者像玩游戏一样理解算法。比如：  
- 顶点用不同颜色的像素块表示（G的顶点是蓝色，H的顶点是绿色），边用实线（存在）或虚线（不存在）表示；  
- 排列生成时，H的顶点会“跳”到对应G的顶点位置（比如G的顶点1在左上角，H的顶点3会跳到左上角），伴随“咔嗒”声；  
- 边比较时，不一致的边会闪烁红色，并显示“需要支付X元”的文字，伴随“叮”声；  
- 找到更优解时，屏幕会弹出“新的最小代价：X元”的提示，伴随“胜利”音效（如FC游戏的过关声）。  

### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示图G（蓝色顶点，实线边），右侧显示图H（绿色顶点，实线边）；  
   - 屏幕底部有“单步”“自动”“重置”按钮，以及“速度滑块”（调整自动播放速度）；  
   - 屏幕右上角显示“最小代价：∞”。  

2. **排列生成**：  
   - 点击“单步”按钮，H的一个顶点会“跳”到对应G的顶点位置（比如G的顶点1对应H的顶点3，那么H的顶点3会跳到G顶点1的位置）；  
   - 点击“自动”按钮，H的顶点会依次“跳”到对应位置，直到生成一个完整的排列。  

3. **边比较与代价计算**：  
   - 排列生成后，遍历所有顶点对(i,j)，比较G中的边(i,j)与H中的边(P[i],P[j])是否一致；  
   - 不一致的边会闪烁红色，并显示“需要支付A[P[i]][P[j]]元”的文字；  
   - 累加所有不一致边的代价，显示“当前排列代价：X元”。  

4. **更新最小代价**：  
   - 如果当前排列的代价小于之前的最小代价，屏幕右上角的“最小代价”会更新为当前代价，并弹出“新的最小代价：X元”的提示，伴随“胜利”音效。  

5. **重置与重新开始**：  
   - 点击“重置”按钮，图H的顶点会回到初始位置，最小代价重置为∞，可以重新开始演示。  

### 旁白提示（动画中的文字气泡）  
- “现在生成排列：G的顶点1对应H的顶点3～”（排列生成时）；  
- “边(1,2)不一致，需要支付5元～”（边比较时）；  
- “新的最小代价：9元！”（找到更优解时）；  
- “点击‘单步’继续生成下一个排列～”（等待用户操作时）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
全排列枚举是一种暴力解法，但在N≤10时非常有效。它可以解决以下问题：  
- **图同构判断**：判断两个图是否同构（本题是图同构的变形，需要修改边）；  
- **排列匹配问题**：比如找到一个排列，使得两个数组的对应元素差的绝对值之和最小；  
- **密码破解**：比如暴力破解4位数字密码（N=4，全排列是10000种）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1341 [排列]**  
   - 🗣️ **推荐理由**：这道题要求找到一个排列，使得排列后的数组满足某些条件，与本题的全排列枚举思路一致，可以巩固全排列的生成和使用。  
2. **洛谷 P2420 [让我们异或吧]**  
   - 🗣️ **推荐理由**：这道题涉及图的路径异或和，需要用到图的遍历（如DFS或BFS），与本题的图处理思路相关，可以拓展图论知识。  
3. **洛谷 P3386 [二分图匹配]**  
   - 🗣️ **推荐理由**：这道题要求找到二分图的最大匹配，需要用到匈牙利算法，与本题的“寻找最优解”思路相关，可以学习更高效的图算法。  


## 7. 学习心得与经验分享 (若有)  
- **邻接矩阵的优势**：很多作者提到用邻接矩阵存储图的边，因为它可以快速查询边是否存在（时间复杂度O(1)），非常适合本题的边比较操作。  
- **全排列的选择**：`next_permutation`生成全排列的代码更简洁，但`dfs`生成全排列的方式更灵活（比如可以剪枝）。新手可以先学习`next_permutation`，再学习`dfs`。  
- **边界条件的处理**：有些作者提到，处理无向图时，边需要存储两次（比如`G[u][v] = G[v][u] = 1`），否则会漏掉边的判断。  


## 结语  
本次关于“[ABC371C] Make Isomorphic”的C++解题分析就到这里。希望这份学习指南能帮助大家理解全排列枚举和图同构的概念，掌握解题技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：194.77秒
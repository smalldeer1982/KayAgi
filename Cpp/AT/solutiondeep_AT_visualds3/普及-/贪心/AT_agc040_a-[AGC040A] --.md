# 题目信息

# [AGC040A] ><

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc040/tasks/agc040_a

長さ $ N-1 $ の文字列 $ S $ が与えられます． $ S $ の各文字は `<` または `>` です．

長さ $ N $ の非負整数列 $ a_1,a_2,\cdots,a_N $ は， すべての $ i $ ($ 1\ \leq\ i\ \leq\ N-1 $) について次の条件をみたす時，**良い非負整数列**と呼ばれます．

- $ S_i= $ `<` のとき： $ a_i\ <\ a_{i+1} $
- $ S_i= $ `>` のとき： $ a_i\ >\ a_{i+1} $

良い非負整数列の要素の総和としてありうる最小の値を求めてください．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ S $ は `<` と `>` のみから成る長さ $ N-1 $ の文字列．

### Sample Explanation 1

$ a=(0,2,1,0) $ は良い非負整数列であり， この場合の要素の総和は $ 3 $ になります． 要素の総和が $ 3 $ より小さい良い非負整数列は存在しません．

## 样例 #1

### 输入

```
<>>```

### 输出

```
3```

## 样例 #2

### 输入

```
<>>><<><<<<<>>><```

### 输出

```
28```

# AI分析结果


# 💡 Kay的C++算法解析：[AGC040A] >< 深入学习指南 💡

<introduction>
今天我们来分析"[AGC040A] ><"这道有趣的序列构造题。本指南将帮助你理解如何用巧妙的两遍扫描技巧构建满足大小关系的序列，并求得最小总和。让我们一起探索这个"登山者"如何用最小体力完成高低起伏的旅程吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心策略与前后缀处理`

🗣️ **初步分析**：
> 解决这道题就像规划一条登山路径：遇到`<`需要爬坡（增大高度），遇到`>`需要下坡（降低高度）。核心思想是**用最小的高度变化满足所有坡度要求**。
   - 通过正反两次扫描：正向保证上坡要求，反向保证下坡要求，最后取各位置最大值确保同时满足两种约束
   - 可视化设计：用像素方块表示高度值，正向扫描时蓝色箭头右移处理`<`，反向扫描时红色箭头左移处理`>`，最终高度取两种颜色中较高的方块
   - 复古游戏化：设计为"像素登山者"闯关游戏，每次满足约束时播放8-bit音效，完成所有约束时显示庆祝动画

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性和算法效率等维度筛选出以下优质题解：

### 题解一：(来源：rui_er)
* **点评**：思路简洁有力，直击问题核心。通过清晰的两遍扫描（正向处理`<`，反向处理`>`）和max操作，完美实现贪心策略。代码中`a[i+1] = a[i]+1`和`a[i]=max(a[i],a[i+1]+1)`两个关键操作精准体现了约束要求。变量命名简洁，边界处理自然，long long的使用避免了溢出问题，是竞赛实现的典范。

### 题解二：(来源：BlackPanda)
* **点评**：采用双数组策略（a数组正向扫描，b数组反向扫描）清晰分离两种约束，最后取max的思路直观易懂。代码结构工整，关键步骤注释到位，特别强调long long的重要性，对初学者非常友好。用`max(a[i],b[i])`汇总结果的方式使算法逻辑一目了然。

### 题解三：(来源：BotDand)
* **点评**：创新性地从连续符号角度思考，使用前缀/后缀统计方法。`a[i]`统计左侧连续`<`数，`b[i]`统计右侧连续`>`数，取max获得最终值。这种方法虽然理解门槛稍高，但提供了新的视角，且只需单遍扫描即可完成统计，具有理论价值。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下关键点：

1.  **如何同时满足双向约束？**
    * **分析**：单个位置既受左侧约束（与前项关系）又受右侧约束（与后项关系）。优质解法采用"分别满足，取最大值"策略：正向扫描确保满足左侧`<`，反向扫描确保满足右侧`>`，最后取两次结果的最大值
    * 💡 **学习笔记**：当约束来自不同方向时，分离处理再整合是常用技巧

2.  **如何保证序列值最小化？**
    * **分析**：每个位置独立计算最小可能值。对于`<`关系，正向扫描时仅增加必要的高度（+1）；对于`>`关系，反向扫描时也只增加必要的落差。取max操作确保不破坏任一约束的前提下使用最小高度
    * 💡 **学习笔记**：贪心算法的核心是局部最优推导全局最优

3.  **如何高效处理大规模数据？**
    * **分析**：O(N)复杂度的两遍扫描完美适配5×10⁵数据规模。数组存储中间结果避免重复计算，是典型的空间换时间策略
    * 💡 **学习笔记**：线性时间复杂度是处理大规模数据的基准要求

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可提炼以下通用技巧：
</summary_best_practices>
-   **双指针扫描法**：正反两次遍历分别处理不同方向的约束
-   **中间值缓存**：存储部分结果避免重复计算
-   **边界预处理**：将字符串首位补空格(`s=" "+s`)简化索引计算
-   **类型预见性**：总和可能很大时提前使用long long

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合双遍扫描思想的标准实现
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    #include <algorithm>
    using namespace std;
    
    int main() {
        string s;
        cin >> s;
        int n = s.size();
        long long ans = 0;
        vector<long long> dp(n+1, 0);
        
        // 正向扫描处理'<'约束
        for (int i = 0; i < n; i++) {
            if (s[i] == '<') 
                dp[i+1] = dp[i] + 1;
        }
        
        // 反向扫描处理'>'约束
        for (int i = n-1; i >= 0; i--) {
            if (s[i] == '>') 
                dp[i] = max(dp[i], dp[i+1] + 1);
        }
        
        // 累加结果
        for (int i = 0; i <= n; i++) 
            ans += dp[i];
            
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 初始化dp数组存储各位置高度值
    > 2. 正向遍历：遇`<`则后项=前项+1
    > 3. 反向遍历：遇`>`则前项=max(当前值,后项+1)
    > 4. 累加dp数组得最小总和

---
<code_intro_selected>
优质题解核心代码解析：
</code_intro_selected>

**题解一：(来源：rui_er)**
* **亮点**：简洁高效的两遍扫描
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=l;i++) 
        (s[i] == '<') ? (a[i+1] = a[i] + 1) : (a[i+1]);
    for(int i=l;i>=1;i--) 
        (s[i] == '>') ? (a[i] = max(a[i], a[i+1]+1)) : (a[i]);
    ```
* **代码解读**：
    > 第一行正向扫描：当s[i]为`<`时，设置a[i+1] = a[i]+1（满足递增要求）；否则保持原值
    > 第二行反向扫描：当s[i]为`>`时，设置a[i]为当前值与a[i+1]+1的较大值（满足递减要求）
    > 三元运算符`?:`使代码简洁，但可读性稍降
* 💡 **学习笔记**：两遍扫描法时间复杂度O(N)，空间复杂度O(N)

**题解二：(来源：BlackPanda)**
* **亮点**：双数组策略增强可读性
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=len;i++)
        if(s[i-1]=='<') a[i]=a[i-1]+1;
    for(int i=len-1;i>=0;i--)
        if(s[i]=='>') b[i]=b[i+1]+1;
    for(int i=0;i<=len;i++)
        ans += max(a[i],b[i]);
    ```
* **代码解读**：
    > 使用独立数组a、b分别存储正反扫描结果
    > 正向：遇`<`时a[i]基于前项+1
    > 反向：遇`>`时b[i]基于后项+1
    > 最终各位置取max(a[i],b[i])累加
* 💡 **学习笔记**：分离关注点使逻辑更清晰，但空间占用翻倍

**题解三：(来源：BotDand)**
* **亮点**：前缀/后缀统计创新解法
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=s.length();++i) 
        if(s[i]=='<') a[i]=a[i-1]+1; else a[i]=0;
    for(int i=s.length();i>=1;--i) 
        if(s[i]=='>') b[i]=b[i+1]+1; else b[i]=0;
    for(int i=1;i<=s.length();++i) 
        ans += max(a[i-1],b[i]);
    ```
* **代码解读**：
    > a[i]统计位置i左侧连续`<`的数量
    > b[i]统计位置i右侧连续`>`的数量
    > 最终值取两个方向统计结果的最大值
* 💡 **学习笔记**：连续符号数量等价于该位置需要的最小高度

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计"像素登山者"动画演示两遍扫描过程，采用8-bit复古风格：

### 动画设计
* **主题**：像素登山者攀爬高低起伏的山脉
* **视觉设计**：16色FC游戏风格，网格化高度显示
* **交互控制**：开始/暂停、单步执行、速度滑块

### 关键帧演示
1. **初始化**：
   - 显示由`><`组成的山脉符号
   - 山脚位置初始化为0（绿色像素块）
   - 播放启动音效"叮！"

2. **正向扫描（蓝衣登山者）**：
   ```plaintext
   > < < > > < 
   ```
   - 蓝色像素人从左向右移动
   - 遇到`<`时：当前位置闪烁黄色，下一位置变为[当前值+1]（升起蓝色台阶）
   - 音效：上升时播放"嘀↑"声

3. **反向扫描（红衣登山者）**：
   ```plaintext
   > < < > > < 
   ```
   - 红色像素人从右向左移动
   - 遇到`>`时：下一位置闪烁红色，当前位置变为max(当前值, 右值+1)（升起红色台阶）
   - 音效：下降时播放"嘀↓"声

4. **结果合成**：
   - 每个位置取蓝/红登山者创建的最大高度
   - 最终路径以彩虹色显示，播放胜利音效
   - 显示总高度值：∑=28

### 游戏化元素
- **闯关模式**：每完成一组约束为1关
- **得分系统**：高度值最小化得高分
- **音效反馈**：
  - 正确操作：8-bit清脆音
  - 错误操作：短促警报声
  - 关卡完成：经典FC过关旋律

</visualization_intro>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的双遍扫描技巧后，可尝试以下变种：

### 相似题型
1. **山脉序列变种**（[AGC043A] Range Flip Find Route）：将大小关系转换为路径问题
2. **环形约束处理**（[ABC175D] Moving Piece）：循环数组中的双遍扫描
3. **三维约束扩展**（[JOI2018] Stove）：多维度的贪心策略

### 洛谷推荐
1. **P1115 最大子段和**  
   → 练习单遍扫描的经典问题
2. **P1886 滑动窗口**  
   → 双指针扫描的进阶应用
3. **P1090 [NOIP2004]合并果子**  
   → 贪心算法的不同实现形式

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验值得借鉴：

> **rui_er的经验**：  
> "注意ans可能需要使用long long"

> **Kay的总结**：  
> 在涉及累加和大数据规模时，提前预防整数溢出是竞赛编程的基本素养。建议：
> 1. 10⁵级以上数据考虑long long
> 2. 在累加前估算最大可能值
> 3. 测试边界数据验证

---

<conclusion>
通过本次分析，我们掌握了用双遍扫描解决序列约束问题的通用方法。记住：**分离约束方向+独立处理+结果整合**是这类问题的核心思路。继续用这种"登山者"思维去征服更多算法山峰吧！下次见！🚩
</conclusion>

---
处理用时：148.55秒
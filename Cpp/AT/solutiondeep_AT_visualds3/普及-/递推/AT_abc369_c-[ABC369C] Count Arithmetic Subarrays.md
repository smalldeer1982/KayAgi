# 题目信息

# [ABC369C] Count Arithmetic Subarrays

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc369/tasks/abc369_c

長さ $ N $ の正整数列 $ A=(A_1,A_2,\dots,A_N) $ が与えられます。

$ 1\leq\ l\leq\ r\leq\ N $ を満たす整数の組 $ (l,r) $ であって、数列 $ (A_l,A_{l+1},\dots,A_r) $ が等差数列であるようなものが何通りあるか求めてください。

なお、数列 $ (x_1,x_2,\dots,x_{|x|}) $ が等差数列であるとは、ある $ d $ が存在して $ x_{i+1}-x_i=d\ (1\leq\ i\ <\ |x|) $ であることをいいます。 特に、長さ $ 1 $ の数列は常に等差数列です。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ \leq\ 10^9 $
- 入力は全て整数
 
### Sample Explanation 1

条件を満たす整数の組 $ (l,r) $ は $ (1,1),(2,2),(3,3),(4,4),(1,2),(2,3),(3,4),(1,3) $ の $ 8 $ 通りです。 実際、$ (l,r)=(1,3) $ のとき $ (A_l,\dots,A_r)=(3,6,9) $ は等差数列なので条件を満たしますが、 $ (l,r)=(2,4) $ のとき $ (A_l,\dots,A_r)=(6,9,3) $ は等差数列ではないので条件を満たしません。

### Sample Explanation 2

すべての整数の組 $ (l,r)\ (1\leq\ l\leq\ r\leq\ 5) $ が条件を満たします。

## 样例 #1

### 输入

```
4

3 6 9 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5

1 1 1 1 1```

### 输出

```
15```

## 样例 #3

### 输入

```
8

87 42 64 86 72 58 44 30```

### 输出

```
22```

# AI分析结果



---
# 💡 Kay的C++算法解析：Count Arithmetic Subarrays 深入学习指南 💡

<introduction>
今天我们来一起分析“Count Arithmetic Subarrays”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧，学会高效计算序列中等差子数组的数量。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与数学公式结合` (核心是通过遍历数组维护当前最长等差子数组长度，结合等差数列子数组数量公式计算总结果)

🗣️ **初步分析**：
> 解决这道题的关键在于观察到一个性质：若一段连续子数组是等差数列，那么它的所有子数组也都是等差数列。例如，长度为k的等差子数组，其内部包含的等差子数组数量为 $\frac{k(k+1)}{2}$（包括长度为1和2的情况）。因此，我们需要遍历原数组，找出所有极长的等差子数组（无法再向左右扩展的等差数列段），并计算每段的贡献。

- **题解思路对比**：大部分题解采用“维护当前最长等差子数组长度”的思路。例如，PineappleSummer用数组`b[i]`记录以i结尾的最长等差子数组长度；ikunTLE用变量`cnt`动态维护当前长度，并用求和公式累加贡献。两者核心思想一致，区别在于具体实现细节（如是否预处理差分数组、如何处理边界条件）。
- **核心算法流程**：从左到右遍历数组，维护当前等差子数组的公差和长度。若当前元素与前一元素的差等于当前公差，则长度加1；否则重置长度为2（因为任意两个数都是等差数列）。每段极长等差数列的贡献为 $\frac{len(len+1)}{2}$，最后累加所有段的贡献。
- **可视化设计**：采用8位像素风格动画，用不同颜色的方块表示原数组元素。动画中，当前处理的元素会闪烁，长度变量`len`用数字显示在顶部。当公差变化时，播放“叮”的音效；长度增加时，方块向右滑动并变色，直观展示长度的累积过程。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、实现高效且易于学习，被选为优质参考（评分≥4星）。
</eval_intro>

**题解一：作者PineappleSummer**
* **点评**：此题解思路非常清晰，直接定义`b[i]`表示以i结尾的最长等差子数组长度。代码结构简洁，变量命名直观（如`b[i]`明确表示长度），边界处理（如`b[1]=1, b[2]=2`）严谨。算法时间复杂度O(n)，适合竞赛场景。亮点在于通过递推公式`b[i] = b[i-1]+1`（当公差一致时）直接累加长度，最后求和所有`b[i]`得到结果，避免了复杂的分段统计。

**题解二：作者ikunTLE**
* **点评**：此题解巧妙利用等差数列求和公式，用变量`cnt`动态维护当前长度。代码通过判断公差是否变化，决定是否重置长度并累加贡献。边界条件（如n=1的特判）处理到位，空间复杂度O(1)，非常高效。亮点在于将每段极长等差数列的贡献用$\frac{cnt(cnt-1)}{2}$计算，最后加上n（长度为1的子数组），逻辑简洁。

**题解三：作者under_the_time**
* **点评**：此题解通过预处理差分数组`d[i] = a[i]-a[i-1]`，将问题转化为“统计连续相同差分的段数”。代码仅用一个循环遍历差分数组，维护当前段的起始位置`j`，每段贡献为`i-j+1`（以i结尾的等差子数组数量）。算法思路新颖，代码极简，适合理解差分与等差数列的关系。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：如何正确维护当前最长等差子数组的长度？**
    * **分析**：需要动态跟踪当前公差（即相邻元素的差），当新元素的差与当前公差一致时，长度加1；否则重置长度为2（因为任意两个数都是等差数列）。例如，PineappleSummer的`b[i]`递推和ikunTLE的`cnt`变量均通过此逻辑维护长度。
    * 💡 **学习笔记**：维护长度时，初始值（如`b[1]=1, b[2]=2`）和边界条件（如n=1）需特别注意，避免越界错误。

2.  **关键点2：如何计算每段极长等差数列的贡献？**
    * **分析**：长度为k的等差子数组，其内部包含的等差子数组数量为$\frac{k(k+1)}{2}$（包括长度为1和2的情况）。例如，ikunTLE用`cnt*(cnt-1)/2`计算长度≥2的贡献，最后加上n（长度为1的子数组），避免了重复计算。
    * 💡 **学习笔记**：公式$\frac{k(k+1)}{2}$是连续子数组数量的通用公式，适用于所有极长等差数列段。

3.  **关键点3：如何处理差分数组的边界与重置？**
    * **分析**：差分数组`d[i]`表示相邻元素的差，当`d[i] != d[i-1]`时，需重置当前段的起始位置。例如，under_the_time的题解中，`j`记录当前段的起始，每次公差变化时更新`j=i`，确保正确统计每段的贡献。
    * 💡 **学习笔记**：差分数组的预处理能简化问题，将“判断是否为等差数列”转化为“判断差分是否相等”。

### ✨ 解题技巧总结
<summary_best_practices>
- **差分数组预处理**：将原数组转换为差分数组，简化“是否为等差数列”的判断（只需判断差分是否连续相同）。
- **动态维护长度**：用变量（如`cnt`或`b[i]`）实时记录当前最长等差子数组的长度，避免重复遍历。
- **公式快速计算**：利用$\frac{k(k+1)}{2}$直接计算每段贡献，避免逐一枚举子数组。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了PineappleSummer和ikunTLE的思路，通过维护当前长度`cnt`和公差`d`，动态计算每段贡献，最后累加得到结果。代码简洁高效，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        
        int n;
        cin >> n;
        long long a[n + 1]; // 数组从1开始索引
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
        }
        
        if (n == 1) {
            cout << 1 << endl;
            return 0;
        }
        
        long long ans = n; // 初始为n个长度为1的子数组
        int cnt = 2; // 前两个数组成的子数组长度为2
        int d = a[2] - a[1]; // 初始公差
        
        for (int i = 3; i <= n; ++i) {
            if (a[i] - a[i - 1] == d) {
                cnt++;
            } else {
                ans += (long long)cnt * (cnt - 1) / 2; // 累加当前段的贡献（长度≥2）
                d = a[i] - a[i - 1]; // 更新公差
                cnt = 2; // 重置长度为2（当前两个数）
            }
        }
        ans += (long long)cnt * (cnt - 1) / 2; // 处理最后一段
        
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先处理n=1的特殊情况（直接输出1）。然后初始化`ans`为n（所有长度为1的子数组），`cnt`初始为2（前两个数组成的子数组），`d`为初始公差。遍历数组从第3个元素开始，若当前公差与前一公差一致，则`cnt`加1；否则累加当前段的贡献（长度≥2的子数组数量），并重置`cnt`和`d`。最后处理最后一段的贡献，输出结果。

---
<code_intro_selected>
接下来，我们将剖析优质题解的核心代码片段，理解其亮点和实现思路。
</code_intro_selected>

**题解一：作者PineappleSummer**
* **亮点**：通过数组`b[i]`记录以i结尾的最长等差子数组长度，思路直观，适合理解动态维护长度的过程。
* **核心代码片段**：
    ```cpp
    b[1] = 1, b[2] = 2;
    for (int i = 3; i <= n; i++) {
        if (a[i] - a[i - 1] == a[i - 1] - a[i - 2])
            b[i] = b[i - 1] + 1;
        else b[i] = 2;
    }
    for (int i = 1; i <= n; i++) ans += b[i];
    ```
* **代码解读**：
    > `b[i]`表示以i结尾的最长等差子数组长度。初始时，`b[1]=1`（长度为1的子数组），`b[2]=2`（前两个数组成的子数组）。从i=3开始，若当前公差（`a[i]-a[i-1]`）与前一公差（`a[i-1]-a[i-2]`）一致，则`b[i] = b[i-1]+1`（延长当前段）；否则`b[i]=2`（仅当前两个数）。最后累加所有`b[i]`，得到总数量（每个`b[i]`表示以i结尾的等差子数组个数）。
* 💡 **学习笔记**：`b[i]`的设计将问题转化为“每个位置的贡献”，通过递推避免了复杂的分段统计。

**题解二：作者ikunTLE**
* **亮点**：利用等差数列求和公式，动态维护当前长度`cnt`，空间复杂度O(1)，适合处理大规模数据。
* **核心代码片段**：
    ```cpp
    int cnt = 1;
    long long ans = n;
    for (int i = 2; i <= n; ++i)
        if (i > 2 && a[i] - a[i - 1] == a[i - 1] - a[i - 2])
            ++cnt;
        else {
            ans += (long long)cnt * (cnt - 1) / 2;
            cnt = 2;
        }
    ans += (long long)cnt * (cnt - 1) / 2;
    ```
* **代码解读**：
    > `cnt`初始为1（i=2时，前两个数组成的子数组长度为2，`cnt`实际表示长度-1）。遍历数组时，若公差一致则`cnt++`；否则累加当前段的贡献（$\frac{cnt*(cnt-1)}{2}$，即长度为`cnt+1`的段的贡献），并重置`cnt=2`。最后处理最后一段的贡献，加上n（长度为1的子数组）。
* 💡 **学习笔记**：通过`cnt`的动态调整，避免了数组存储，节省空间，适合n较大的场景。

**题解三：作者under_the_time**
* **亮点**：预处理差分数组，将问题转化为“统计连续相同差分的段数”，代码极简。
* **核心代码片段**：
    ```cpp
    for (int i = 2, j = 2; i <= n; i++) {
        if (d[i] != d[i - 1]) j = i;
        ans += (i - j + 1);
    }
    ```
* **代码解读**：
    > `d[i]`为差分数组（`d[i] = a[i]-a[i-1]`）。`j`记录当前段的起始位置。当`d[i] != d[i-1]`时，更新`j=i`（新段的起点）。`i-j+1`表示以i结尾的等差子数组个数（长度≥2），累加所有`i-j+1`并加上n（长度为1的子数组）得到结果。
* 💡 **学习笔记**：差分数组的预处理将“判断等差数列”转化为“判断差分是否连续相同”，简化了逻辑。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“维护当前长度并计算贡献”的过程，我们设计一个8位像素风格的动画，模拟数组遍历和长度变化。
</visualization_intro>

  * **动画演示主题**：`像素小探险家的等差之旅`（像素小人在数组方块上移动，收集等差子数组）

  * **核心演示内容**：
    - 数组元素用8位像素方块表示（颜色：蓝色），当前处理的元素闪烁（颜色变为黄色）。
    - 顶部显示当前长度`cnt`（像素数字）和总答案`ans`（绿色）。
    - 当公差一致时，长度`cnt`增加（数字变大），像素小人向右跳跃；当公差变化时，播放“叮”的音效，长度重置为2，小人原地转圈。

  * **设计思路简述**：
    > 8位像素风格营造轻松氛围，闪烁和音效强化关键操作（如公差变化）。通过小人的移动和数字变化，直观展示长度的累积和贡献的计算过程，帮助理解动态维护长度的逻辑。

  * **动画帧步骤与交互关键点**：
    1. **初始化**：屏幕显示数组方块（如`[3,6,9,3]`），小人站在第一个方块上，`cnt=2`，`ans=4`（n=4，初始为4个长度为1的子数组）。
    2. **遍历过程**：
       - 小人移动到第三个方块（i=3），检查公差（`9-6=3`，与前一公差`6-3=3`一致），`cnt`变为3，`ans`增加3（以i=3结尾的子数组有3个：`[3,6,9]`、`[6,9]`、`[9]`）。
       - 小人移动到第四个方块（i=4），检查公差（`3-9=-6`，与前一公差3不一致），播放“叮”音效，`ans`累加当前段贡献$\frac{3*2}{2}=3$（总ans=4+3=7），`cnt`重置为2，`ans`增加2（以i=4结尾的子数组有2个：`[9,3]`、`[3]`）。
    3. **结束状态**：遍历完成后，`ans=8`（与样例1结果一致），播放胜利音效，小人举起“胜利”像素牌。

  * **旁白提示**：
    - “看！当前公差和前一个一样，长度增加到3啦~”
    - “公差变了，我们需要计算这段的贡献，然后重置长度！”
    - “最终答案就是所有段的贡献之和，加上长度为1的子数组哦~”

<visualization_conclusion>
通过这样的动画，我们可以直观看到每一步长度的变化和贡献的累加，轻松理解“维护当前长度”的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以将“维护当前段长度+公式计算贡献”的思路迁移到其他问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 统计连续相同元素的子数组个数（如统计全1子数组的数量）。
    - 计算最长连续递增子数组的长度（维护当前长度，递增则加1，否则重置）。
    - 处理需要分段统计的问题（如字符串中连续相同字符的段数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1147 连续自然数和**  
        * 🗣️ **推荐理由**：需要找到连续自然数的和等于目标值，可通过滑动窗口维护当前和，与本题维护长度的思路类似。
    2.  **洛谷 P1439 排列的差**  
        * 🗣️ **推荐理由**：计算两个排列对应位置的差的绝对值的最小排列，需分析差的性质，锻炼差分思维。
    3.  **洛谷 P1803 凌乱的yyy / 线段覆盖**  
        * 🗣️ **推荐理由**：需要选择最多的不重叠区间，可通过贪心维护当前结束时间，与动态维护长度的思路有共通之处。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自作者Happy_mouse)**：“在计算贡献时，发现最后一段的贡献容易被遗漏，需要在循环结束后单独处理。此外，初始长度的设置（如`len=2`）需要特别注意，避免越界错误。”

> **点评**：这段经验提醒我们，处理数组遍历问题时，循环结束后往往需要处理最后一段的贡献（如本题最后一段的`ans += cnt*(cnt-1)/2`）。初始值的设置（如`cnt=2`）需与循环逻辑匹配，避免边界错误。这对我们调试类似问题非常有帮助！

-----

<conclusion>
本次关于“Count Arithmetic Subarrays”的C++解题分析就到这里。希望这份指南能帮助你掌握“维护当前长度+公式计算贡献”的核心思路，学会高效解决类似问题。记住，多动手编写代码并调试，是提升编程能力的关键！下次见~ 💪
</conclusion>

---
处理用时：128.30秒
# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：JJOOII 2 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：前缀和与二分查找（或双指针）的结合应用  

🗣️ **初步分析**：  
解决“JJOOII 2”的关键，是找到**最短子串**，使其包含**K个J、K个O、K个I**（顺序必须是J→O→I）。因为操作3的次数等于“子串长度 - 3K”（子串中需要保留3K个字符，其余用操作3删除），所以**最小化子串长度**就是解题核心。  

### 核心算法思路  
- **前缀和**：统计每个位置前J、O、I的数量，快速查询区间内的字符数量（比如，`J[i]`表示前i个字符中J的数量）。  
- **二分查找**：对于每个可能的J起始位置，用二分找到包含K个J的结束位置；再从该位置开始，二分找到包含K个O的结束位置；最后找到包含K个I的结束位置。  
- **双指针**：记录J、O、I的位置到数组，用指针逐步移动，找到符合条件的子串（时间复杂度更低，O(N)）。  

### 可视化设计思路  
用**8位像素风格**展示字符串：  
- 红色像素块代表J，绿色代表O，蓝色代表I；  
- 动画中逐步移动指针，找到K个J（红色块高亮）→ K个O（绿色块高亮）→ K个I（蓝色块高亮）；  
- 用黄色框标记子串范围，显示操作3的次数（子串长度-3K）；  
- 加入音效：找到K个J时播放“叮”，找到O时“咚”，找到I时“啪”，增加互动感。  


## 2. 精选优质题解参考

### 题解一：Kano_zyc（赞：3）  
**点评**：  
思路清晰，使用**前缀和+二分查找**高效解决问题。前缀和数组统计J、O、I的数量，枚举每个起始位置，用二分找到每个阶段的结束位置。代码规范，边界处理严谨（比如，若找不到足够字符则跳出循环）。亮点在于二分查找的使用，将每个阶段的查找时间从O(N)降低到O(logN)，整体时间复杂度O(NlogN)，适合大规模数据（N≤2e5）。  

### 题解二：small_turtle（赞：3）  
**点评**：  
优化了起始位置的枚举，**只枚举J的位置**（因为子串必须以J开头），减少了不必要的计算。使用`lower_bound`函数简化二分查找，代码更简洁。例如，`lower_bound(J+1, J+n+1, J[i-1]+k)`快速找到包含K个J的结束位置。亮点在于对起始位置的优化，提高了效率。  

### 题解三：saixingzhe（赞：1）  
**点评**：  
思路独特，**记录每个字符的位置到vector**（比如，`q[0]`存J的位置，`q[1]`存O的位置），然后用**双指针**逐步找到符合条件的位置。时间复杂度O(N)，效率很高。例如，枚举J的起始位置，维护O和I的指针，找到对应的O和I的位置。亮点在于使用vector记录位置，避免了前缀和的计算，简化了代码。  


## 3. 核心难点辨析与解题策略

### 关键点1：如何高效找到符合条件的子串？  
**分析**：  
需要找到包含K个J、O、I且顺序正确的子串。前缀和可以快速统计区间内的字符数量，二分查找可以快速找到每个阶段的结束位置。例如，用`findMinIndex`函数找到从位置l开始包含K个J的最小结束位置。  
**学习笔记**：前缀和是处理区间统计的常用工具，二分查找能将查找时间从O(N)降低到O(logN)。  

### 关键点2：如何处理边界条件？  
**分析**：  
当找不到足够的J、O、I时，需要返回-1。在枚举起始位置时，若当前起始位置之后的字符数量不足，应及时跳出循环。例如，`if (endJ > n) break;`（若找不到K个J，则停止枚举）。  
**学习笔记**：边界条件的处理是程序健壮性的关键，需要仔细考虑所有可能的情况。  

### 关键点3：如何最小化子串长度？  
**分析**：  
枚举所有可能的起始位置，找到最小的子串长度。使用二分或双指针可以高效找到每个起始位置对应的最小子串。例如，枚举每个J的位置，找到对应的O和I的位置，计算子串长度并更新最小值。  
**学习笔记**：枚举起始位置是解决子串问题的常用方法，结合高效的查找算法可以优化时间复杂度。  

### ✨ 解题技巧总结  
- **前缀和**：快速统计区间字符数量；  
- **二分查找**：用`lower_bound`简化实现，快速找到结束位置；  
- **起始位置优化**：只枚举J的位置，减少循环次数；  
- **双指针**：记录字符位置，高效遍历数组（时间复杂度O(N)）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（前缀和+二分）  
**说明**：综合了Kano_zyc和small_turtle的思路，使用前缀和和二分查找找到符合条件的子串。  
**完整核心代码**：  
```cpp
#include <iostream>
#include <string>
#include <climits>
#include <algorithm>
using namespace std;

const int N = 2e5 + 10;
int J[N], O[N], I[N];

int findMinIndex(int l, int k, int n, int prefixSum[]) {
    int left = l, right = n, ans = n + 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (prefixSum[mid] - prefixSum[l - 1] >= k) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
}

int main() {
    int n, k;
    string s;
    cin >> n >> k >> s;

    for (int i = 1; i <= n; ++i) {
        J[i] = J[i - 1] + (s[i - 1] == 'J');
        O[i] = O[i - 1] + (s[i - 1] == 'O');
        I[i] = I[i - 1] + (s[i - 1] == 'I');
    }

    int ans = INT_MAX;
    for (int l = 1; l <= n; ++l) {
        int endJ = findMinIndex(l, k, n, J);
        if (endJ > n) break;
        int endO = findMinIndex(endJ, k, n, O);
        if (endO > n) break;
        int endI = findMinIndex(endO, k, n, I);
        if (endI > n) break;
        ans = min(ans, endI - l + 1 - 3 * k);
    }

    cout << (ans == INT_MAX ? -1 : ans) << endl;
    return 0;
}
```  
**代码解读概要**：  
1. 读取输入数据；  
2. 计算前缀和数组`J`、`O`、`I`，统计每个位置前的字符数量；  
3. 枚举起始位置`l`，用`findMinIndex`找到包含K个J的结束位置`endJ`；  
4. 从`endJ`开始，找到包含K个O的结束位置`endO`；  
5. 从`endO`开始，找到包含K个I的结束位置`endI`；  
6. 计算子串长度（`endI - l + 1`），减去3K得到操作3的次数，更新最小值；  
7. 输出结果。  

### 题解一：Kano_zyc的核心代码片段  
**亮点**：自定义`findMinIndex`函数，逻辑清晰。  
**核心代码片段**：  
```cpp
int findMinIndex(int l, int k, int n, int prefixSum[]) {
    int left = l, right = n, ans = n + 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (prefixSum[mid] - prefixSum[l - 1] >= k) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
}
```  
**代码解读**：  
该函数用于找到从位置`l`开始，包含至少`k`个目标字符的最小结束位置。使用二分查找，左边界是`l`，右边界是`n`。如果中间位置`mid`的前缀和减去`l-1`的前缀和≥`k`，说明`mid`可能是候选答案，将右边界左移；否则，将左边界右移。最终返回最小的结束位置。  
**学习笔记**：二分查找的关键是确定搜索范围和判断条件，这里的判断条件是区间内的字符数量是否足够。  

### 题解二：small_turtle的核心代码片段  
**亮点**：使用`lower_bound`简化二分查找，代码更简洁。  
**核心代码片段**：  
```cpp
for (int i = 1; i <= n; ++i) {
    if (s[i] != 'J') continue;
    int x = lower_bound(J + 1, J + n + 1, J[i - 1] + k) - J;
    int y = lower_bound(O + 1, O + n + 1, O[x - 1] + k) - O;
    int z = lower_bound(I + 1, I + n + 1, I[y - 1] + k) - I;
    if (x > n || y > n || z > n) break;
    ans = min(ans, z - i + 1);
}
```  
**代码解读**：  
枚举每个J的位置`i`，用`lower_bound`找到`J`数组中第一个≥`J[i-1]+k`的位置`x`（包含K个J的结束位置）。然后从`x`开始，找到`O`数组中第一个≥`O[x-1]+k`的位置`y`（包含K个O的结束位置）。再从`y`开始，找到`I`数组中第一个≥`I[y-1]+k`的位置`z`（包含K个I的结束位置）。计算子串长度`z-i+1`，更新最小值。  
**学习笔记**：`lower_bound`函数可以快速找到第一个≥目标值的位置，简化了二分查找的实现。  

### 题解三：saixingzhe的核心代码片段  
**亮点**：记录字符位置到vector，用双指针高效遍历。  
**核心代码片段**：  
```cpp
vector<int> q[3];
for (int i = 0; i < s.size(); i++) {
    if (s[i] == 'J') q[0].push_back(i);
    if (s[i] == 'O') q[1].push_back(i);
    if (s[i] == 'I') q[2].push_back(i);
}
for (int J = 0; J <= q[0].size() - k; J++) {
    while (O <= q[1].size() - k && q[0][J + k - 1] > q[1][O]) O++;
    while (I <= q[2].size() - k && q[1][O + k - 1] > q[2][I]) I++;
    if (O <= q[1].size() - k && I <= q[2].size() - k) 
        ans = min(ans, q[2][I + k - 1] - q[0][J] + 1 - 3 * k);
    else break;
}
```  
**代码解读**：  
将J、O、I的位置分别存入`q[0]`、`q[1]`、`q[2]`。枚举J的起始位置`J`，找到`q[1]`中第一个大于`q[0][J+k-1]`的位置`O`（O的起始位置），然后找到`q[2]`中第一个大于`q[1][O+k-1]`的位置`I`（I的起始位置）。计算子串长度（`q[2][I+k-1] - q[0][J] + 1`），减去3K得到操作3的次数，更新最小值。  
**学习笔记**：记录字符位置的vector可以快速找到每个字符的位置，双指针的使用使得时间复杂度为O(N)，效率很高。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**像素探险家寻找JOI宝藏**：用8位像素风格展示字符串，探险家（指针）逐步找到K个J、O、I，最终找到宝藏（符合条件的子串）。  

### 核心演示内容  
1. **初始化**：屏幕显示字符串的像素块（红色J、绿色O、蓝色I），控制面板有“开始”、“暂停”、“单步”、“重置”按钮，右上角显示当前最小操作3次数。  
2. **枚举起始位置**：探险家（黄色箭头）从左到右移动，逐个检查J的位置。  
3. **找到K个J**：当探险家指向J时，开始统计J的数量，直到找到K个J（红色块高亮），播放“叮”的音效。  
4. **找到K个O**：从K个J的结束位置开始，探险家继续移动，统计O的数量，直到找到K个O（绿色块高亮），播放“咚”的音效。  
5. **找到K个I**：从K个O的结束位置开始，探险家继续移动，统计I的数量，直到找到K个I（蓝色块高亮），播放“啪”的音效。  
6. **标记子串**：用黄色框标记出子串的范围，显示操作3的次数（子串长度-3K）。如果当前次数小于之前的最小值，更新右上角的最小值。  
7. **重复步骤2-6**：直到所有起始位置都枚举完毕。  
8. **结束**：显示最终的最小操作3次数，播放胜利音效（比如“啦啦啦”）。  

### 设计思路  
- **像素风格**：营造复古游戏氛围，增加学习趣味性；  
- **颜色区分**：用不同颜色标记J、O、I，清晰展示字符位置；  
- **音效反馈**：关键操作（找到K个字符）播放音效，强化记忆；  
- **互动控制**：支持单步、自动播放，让学习者可以慢慢观察每一步。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **前缀和**：适用于需要频繁查询区间和的问题（比如，统计区间内的元素数量）；  
- **二分查找**：适用于有序数组的查找问题（比如，找到满足条件的最小位置）；  
- **双指针**：适用于需要维护多个指针的问题（比如，寻找最短子串）。  

### 练习推荐（洛谷）  
1. **洛谷 P1102  A-B 数对**：  
   - 推荐理由：考察前缀和与二分查找的结合，需要找到满足条件的数对数量。可以巩固前缀和的使用和二分查找的技巧。  
2. **洛谷 P1638  逛画展**：  
   - 推荐理由：考察双指针与滑动窗口的结合，需要找到包含所有画家作品的最短子串。与本题思路类似，都是寻找最短子串，可以巩固双指针的使用。  
3. **洛谷 P2085  最小函数值**：  
   - 推荐理由：考察二分查找与堆的结合，需要找到多个函数的最小函数值。可以巩固二分查找的使用，同时学习堆的应用。  


## 7. 学习心得与经验分享（若有）

### 参考经验（来自small_turtle）  
“我在解决这个问题时，最初枚举了所有可能的起始位置，导致时间复杂度很高，后来优化了起始位置，只枚举J的位置，减少了不必要的计算，提高了效率。”  
**点评**：这位作者的经验很有价值，枚举起始位置时，优化范围可以显著提高效率。在本题中，只有J的位置可以作为子串的起始位置，所以只枚举J的位置可以减少循环次数。  

### 参考经验（来自saixingzhe）  
“我使用了vector记录每个字符的位置，这样可以快速找到每个字符的位置，避免了前缀和的计算，简化了代码。”  
**点评**：这位作者的思路很独特，记录字符位置的vector可以快速找到每个字符的位置，双指针的使用使得时间复杂度为O(N)，效率很高。这种方法适用于需要频繁查找字符位置的问题。  


## 结论  
本次分析的题解涵盖了**前缀和+二分查找**、**双指针**等多种方法，其中前缀和+二分查找是最常用的方法，适用于大规模数据；双指针方法效率更高，但需要记录字符的位置。通过学习这些方法，可以巩固前缀和、二分查找、双指针等算法的使用，提高解决字符串问题的能力。  

记住，编程能力的提升在于**持续学习、勤于思考和勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：236.29秒
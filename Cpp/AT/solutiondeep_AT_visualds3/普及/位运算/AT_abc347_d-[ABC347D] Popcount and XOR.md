# 题目信息

# [ABC347D] Popcount and XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc347/tasks/abc347_d

非負整数 $ a,b,C $ が与えられます。 次の $ 5 $ つの条件をすべて満たす非負整数の組 $ (X,Y) $ が存在するか判定し、存在するならひとつ出力してください。

- $ 0\leq\ X\lt2\ ^\ {60} $
- $ 0\leq\ Y\lt2\ ^\ {60} $
- $ \operatorname{popcount}(X)=a $
- $ \operatorname{popcount}(Y)=b $
- $ X\oplus\ Y=C $

ただし、$ \oplus $ はビットごとの排他的論理和を表します。

条件を満たす $ (X,Y) $ が複数存在する場合、どれを出力しても構いません。

popcount とは？非負整数 $ x $ について $ x $ の popcount とは、$ x $ を $ 2 $ 進法で表記したときの $ 1 $ の個数です。 より厳密には、非負整数 $ x $ について $ \displaystyle\ x=\sum\ _\ {i=0}\ ^\ \infty\ b\ _\ i2\ ^\ i\ (b\ _\ i\in\lbrace0,1\rbrace) $ が成り立っているとき $ \displaystyle\operatorname{popcount}(x)=\sum\ _\ {i=0}\ ^\ \infty\ b\ _\ i $ です。

例えば、$ 13 $ を $ 2 $ 進法で表記すると `1101` なので、 $ \operatorname{popcount}(13)=3 $ となります。 ビットごとの排他的論理和とは？非負整数 $ x,y $ について $ x,y $ のビットごとの排他的論理和 $ x\oplus\ y $ は以下のように定義されます。

- $ x\oplus\ y $ を $ 2 $ 進法で表記したときの $ 2\ ^\ k\ (k\geq0) $ の位は、$ x,y $ を $ 2 $ 進法で表記したときの $ 2\ ^\ k\ (k\geq0) $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $ 、そうでなければ $ 0 $ となる。

例えば、$ 9,3 $ を $ 2 $ 進法で表記するとそれぞれ `1001`, `0011` なので、$ 9\oplus3=10 $ となります（$ 10 $ を $ 2 $ 進法で表記すると `1010` です）。

## 说明/提示

### 制約

- $ 0\leq\ a\leq60 $
- $ 0\leq\ b\leq60 $
- $ 0\leq\ C\lt2\ ^\ {60} $
- 入力はすべて整数

### Sample Explanation 1

$ (X,Y)=(28,27) $ は条件を満たします。 $ X,Y $ を $ 2 $ 進法で表記するとそれぞれ `11100` と `11011` になります。 - $ X $ を $ 2 $ 進法で表記すると `11100` になるので、$ \operatorname{popcount}(X)=3 $ です。 - $ Y $ を $ 2 $ 進法で表記すると `11011` になるので、$ \operatorname{popcount}(Y)=4 $ です。 - $ X\oplus\ Y $ を $ 2 $ 進法で表記すると `00111` となり、$ X\oplus\ Y=7 $ です。 条件を満たす非負整数の組が複数存在する場合どれを出力しても構わないため、例えば `42 45` と出力しても正解になります。

### Sample Explanation 2

条件を満たす非負整数の組は存在しません。

### Sample Explanation 3

出力すべき値が $ 32\operatorname{bit} $ 整数に収まらない場合があります。

## 样例 #1

### 输入

```
3 4 7```

### 输出

```
28 27```

## 样例 #2

### 输入

```
34 56 998244353```

### 输出

```
-1```

## 样例 #3

### 输入

```
39 47 530423800524412070```

### 输出

```
540431255696862041 10008854347644927```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC347D] Popcount and XOR 深入学习指南 💡

<introduction>
今天我们来一起分析“[ABC347D] Popcount and XOR”这道题。这道题需要我们构造两个满足特定二进制位条件的数，核心在于利用异或运算的性质和贪心策略。通过本指南，你将掌握如何分析二进制位、判断无解条件以及构造解的方法。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（二进制位分析与贪心分配）`

🗣️ **初步分析**：
解决这道题的关键在于理解异或运算的性质：两位不同则结果为1，相同则为0。我们需要构造两个数X和Y，使得它们的二进制中1的个数分别为a和b，且X异或Y等于C。

简单来说，异或运算就像“二进制位的裁判”——只有当两位不同时才判1，否则判0。在本题中，我们需要根据C的二进制位，逐位分配X和Y的二进制位：
- 若C的某一位是1（记为“冲突位”），则X和Y在该位必须一个是1，一个是0。
- 若C的某一位是0（记为“和谐位”），则X和Y在该位必须同为0或同为1。

**题解思路**：  
首先计算C的二进制中1的个数（记为cnt）。若a+b < cnt（1不够分配）、(a+b - cnt)为奇数（无法成对抵消）、或剩余位不足（超过60位），则无解。否则，先分配冲突位（优先给当前更需要1的数），再分配和谐位（同时填1以消耗剩余的1）。

**核心算法流程**：  
1. 计算C的二进制中1的个数cnt。
2. 检查无解条件（如a+b < cnt等）。
3. 分配冲突位：根据a和b的剩余量，优先给需要更多1的数。
4. 分配和谐位：同时填1以消耗剩余的a和b。

**可视化设计**：  
采用8位像素风格动画，用网格表示二进制位。冲突位用红色像素块表示，和谐位用蓝色像素块。动画中，每分配一个冲突位（如给X的位设为1），对应像素块闪烁并播放“叮”的音效；和谐位同时填1时，两个像素块同步变绿。控制面板支持单步执行和自动播放，高亮当前处理的位和剩余的a、b值。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现突出（≥4星），值得重点学习：
</eval_intro>

**题解一：作者wangbinfeng**
* **点评**：此题解详细列出了所有无解条件（如a+b < cnt、(a+b - cnt)为奇数等），并通过bitset逐位分配X和Y的二进制位。代码规范，变量名清晰（如d存储C的二进制位，e和f存储X和Y的二进制位），边界处理严谨（如检查剩余位是否足够）。亮点在于通过抵消多余的1来平衡a和b，逻辑直白易懂。

**题解二：作者zengziqvan**
* **点评**：此题解采用贪心策略，优先处理冲突位（C中为1的位），根据a和b的剩余量决定分配给X或Y。代码简洁，逻辑清晰（如用循环遍历每一位，通过条件判断分配），并在最后处理和谐位。亮点在于“动态平衡”的分配策略，确保a和b最终相等。

**题解三：作者StormWhip**
* **点评**：此题解将C转换为二进制数组，逐位处理冲突位（优先给a或b更大的一方），再处理和谐位（同时填1）。代码结构清晰（如Print函数将二进制转十进制），关键步骤有注释，适合初学者理解。亮点在于通过快速幂处理二进制转十进制，避免溢出。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们需要突破以下核心难点，并掌握对应的解题策略：
</difficulty_intro>

1.  **关键点1：判断无解条件**  
    * **分析**：无解的情况主要有三种：  
      - a + b < cnt（冲突位需要至少cnt个1，但a和b的总和不足）；  
      - (a + b - cnt)为奇数（和谐位需要成对填1，奇数无法成对）；  
      - 剩余位不足（和谐位数量不够填剩余的1）。  
      例如，若a=3, b=4, C=7（cnt=3），则a+b=7≥cnt=3，且(7-3)/2=2≤和谐位数量（60-3=57），所以有解。  
    * 💡 **学习笔记**：无解条件是解题的“第一道关卡”，必须全面检查。

2.  **关键点2：贪心分配冲突位**  
    * **分析**：冲突位（C中为1的位）必须分配给X或Y中的一个。为了平衡a和b，应优先分配给当前剩余1更多的一方。例如，若a=5, b=3，冲突位优先分配给X（a剩余更多），直到a和b的剩余量接近。  
    * 💡 **学习笔记**：贪心的核心是“动态平衡”，确保后续有足够的位处理剩余的1。

3.  **关键点3：处理和谐位**  
    * **分析**：和谐位（C中为0的位）可以同时填1，消耗a和b各一个。若剩余的a和b相等，只需在和谐位中找到足够的位置填1即可。例如，若a和b各剩2个1，需要至少2个和谐位来填。  
    * 💡 **学习笔记**：和谐位是“资源库”，但数量有限（最多60 - cnt位），需提前检查是否足够。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“判断无解”和“构造解”两部分，逐步处理。  
- **二进制位分析**：将C转换为二进制数组，逐位处理，明确每一位的分配规则。  
- **边界检查**：构造解后，需验证X和Y的popcount是否正确，以及异或结果是否等于C。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，逻辑清晰且覆盖所有关键点：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了wangbinfeng和zengziqvan的思路，处理了所有无解条件，并通过贪心分配冲突位和和谐位构造解。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int popcount(long long x) {
        int cnt = 0;
        while (x) {
            cnt += x & 1;
            x >>= 1;
        }
        return cnt;
    }

    int main() {
        long long a, b, C;
        cin >> a >> b >> C;
        int cnt = popcount(C);

        // 检查无解条件
        if (a + b < cnt || (a + b - cnt) % 2 != 0) {
            cout << -1 << endl;
            return 0;
        }
        int remain = (a + b - cnt) / 2; // 和谐位需要填的1的对数
        if (remain > 60 - cnt) { // 和谐位数量不足
            cout << -1 << endl;
            return 0;
        }
        if (a < remain || b < remain) { // 剩余的1不足填和谐位
            cout << -1 << endl;
            return 0;
        }

        long long X = 0, Y = 0;
        a -= remain; // 分配和谐位后，剩余的1用于冲突位
        b -= remain;

        // 分配冲突位（C中为1的位）
        for (int i = 0; i < 60; ++i) {
            if (C & (1LL << i)) {
                if (a > 0) {
                    X |= (1LL << i);
                    a--;
                } else if (b > 0) {
                    Y |= (1LL << i);
                    b--;
                } else {
                    cout << -1 << endl;
                    return 0;
                }
            }
        }

        // 分配和谐位（C中为0的位）
        for (int i = 0; i < 60; ++i) {
            if (!(C & (1LL << i)) && remain > 0) {
                X |= (1LL << i);
                Y |= (1LL << i);
                remain--;
            }
        }

        // 验证结果
        if (popcount(X) == a + (remain + (a + b - cnt)/2) && 
            popcount(Y) == b + (remain + (a + b - cnt)/2) && 
            (X ^ Y) == C) {
            cout << X << " " << Y << endl;
        } else {
            cout << -1 << endl;
        }

        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先计算C的popcount（cnt），检查无解条件。然后分配冲突位（优先给剩余1更多的数），再分配和谐位（同时填1）。最后验证结果是否符合条件。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者wangbinfeng**
* **亮点**：使用bitset处理二进制位，代码规范，边界处理严谨。
* **核心代码片段**：
    ```cpp
    bitset<60> d(c); // 存储C的二进制位
    bitset<60> e, f; // 存储X和Y的二进制位
    e.reset(), f.reset();
    for (int i = 0; i < 60; ++i) {
        if (d[i] == false) { // 和谐位，同时填1
            e[i] = f[i] = true;
            a--; b--;
            if (a + b == cnt) break; // 抵消完毕
        }
    }
    for (int i = 0; i < 60; ++i) { // 分配冲突位
        if (d[i] && a-- > 0) e[i] = true;
        else if (d[i] && b-- > 0) f[i] = true;
    }
    ```
* **代码解读**：  
  `d`存储C的二进制位，`e`和`f`分别存储X和Y的二进制位。首先处理和谐位（`d[i]==false`），同时填1以抵消多余的1；然后处理冲突位（`d[i]==true`），分配给剩余1更多的一方。  
* 💡 **学习笔记**：bitset是处理二进制位的高效工具，适合需要逐位操作的场景。

**题解二：作者zengziqvan**
* **亮点**：贪心策略明确，代码简洁。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= tot; ++i) { // tot是C的二进制位数
        if (in[i]) { // 冲突位
            if (a <= b) B[i] = 1, b--;
            else A[i] = 1, a--;
        }
    }
    if (a != b) { // 剩余1不等，无解
        puts("-1");
        return 0;
    }
    for (int i = 1; i <= tot; ++i) { // 分配和谐位
        if (a && !in[i]) {
            A[i] = B[i] = 1;
            a--; b--;
        }
    }
    ```
* **代码解读**：  
  首先遍历冲突位（`in[i]==1`），根据a和b的大小分配给X或Y；然后检查剩余a和b是否相等，若不等则无解；最后处理和谐位（`in[i]==0`），同时填1以消耗剩余的a和b。  
* 💡 **学习笔记**：贪心分配冲突位时，动态比较a和b的剩余量是关键。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解二进制位的分配过程，我们设计一个“二进制位探险家”像素动画，用8位复古风格展示X和Y的构造过程。
</visualization_intro>

  * **动画演示主题**：`二进制位探险家——构造X和Y`  
  * **核心演示内容**：展示C的二进制位，逐位分配X和Y的位，高亮冲突位和和谐位的处理过程。  
  * **设计思路简述**：8位像素风格（如FC红白机）营造轻松氛围；冲突位用红色闪烁表示，和谐位用蓝色渐变表示；每分配一个位，播放“叮”的音效（冲突位）或“滴答”的音效（和谐位），增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
       屏幕分为三部分：C的二进制位（顶部，60个像素块，红色表示1，蓝色表示0）、X的二进制位（左部）、Y的二进制位（右部）。控制面板包含“单步”“自动”“重置”按钮和速度滑块。

    2.  **分配冲突位（C中为1的位）**：  
       从最低位开始，当前位高亮（黄色边框）。若a > b，X的对应位变绿（设为1），a减1；否则Y的对应位变绿，b减1。播放“叮”的音效。

    3.  **分配和谐位（C中为0的位）**：  
       当前位高亮（绿色边框）。若a和b还有剩余，X和Y的对应位同时变绿（设为1），a和b各减1。播放“滴答”的音效。

    4.  **目标达成/失败**：  
       若a和b均为0，所有位分配完成，播放“胜利”音效（上扬音调），X和Y的二进制位全部显示绿色；若无法分配（如a或b剩余），播放“失败”音效（短促低音），高亮未分配的位。

  * **旁白提示**：  
    - “当前处理冲突位（红色），优先给剩余1更多的数～”  
    - “和谐位（蓝色）可以同时填1，消耗两个1哦！”  
    - “完成！X和Y的异或结果等于C，符合要求～”

<visualization_conclusion>
通过这个动画，你可以直观看到每一步的位分配过程，理解贪心策略如何平衡a和b，以及冲突位与和谐位的不同处理方式。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是二进制位分析与贪心分配，这类思路在以下场景中也有应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 二进制位操作（如P1100 高低位交换）；  
    - 贪心分配资源（如P1094 纪念品分组）；  
    - 构造满足特定条件的数（如P1328 生活大爆炸版石头剪刀布）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1100** - 高低位交换  
        * 🗣️ **推荐理由**：练习二进制位的拆分与重组，巩固位运算基础。  
    2.  **洛谷 P1094** - 纪念品分组  
        * 🗣️ **推荐理由**：训练贪心策略的应用，学会动态平衡资源分配。  
    3.  **洛谷 P1328** - 生活大爆炸版石头剪刀布  
        * 🗣️ **推荐理由**：通过构造满足条件的序列，提升问题分解能力。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自作者Kyl_in_2024)**：“在处理和谐位时，容易忘记检查剩余位是否足够（即60 - cnt是否≥(a+b - cnt)/2），导致构造的X或Y超过2^60。”  
> **点评**：这位作者的经验非常实用！边界条件（如位数限制）是构造解时的常见陷阱，通过提前计算和谐位的最大可用数量（60 - cnt），可以避免此类错误。

---

<conclusion>
通过本次分析，我们掌握了如何利用异或性质和贪心策略构造满足条件的数。记住，多动手调试、关注边界条件，是解决这类问题的关键。下次我们再一起挑战更难的算法题！💪
</conclusion>

---
处理用时：151.47秒
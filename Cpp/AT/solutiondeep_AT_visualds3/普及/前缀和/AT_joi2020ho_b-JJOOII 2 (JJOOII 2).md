# 题目信息

# JJOOII 2 (JJOOII 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_b

ビ太郎は友人のビバ子から誕生日プレゼントに `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列 $ S $ をもらった．

$ K $ を $ 1 $ 以上の整数とする．$ K $ 個の文字 `J`，$ K $ 個の文字 `O`，$ K $ 個の文字 `I` をこの順に並べた文字列を**レベル $ K $ の JOI 文字列**と呼ぶことにする．例えば，`JJOOII` はレベル $ 2 $ の JOI 文字列である．

ビ太郎はレベル $ K $ の JOI 文字列が好きなので，以下の $ 3 $ 種類の操作を任意の回数，任意の順番で行うことで，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換することにした．

- **操作 $ 1 $** 文字列 $ S $ の先頭の文字を消す．
- **操作 $ 2 $** 文字列 $ S $ の末尾の文字を消す．
- **操作 $ 3 $** 文字列 $ S $ の先頭でも末尾でもない文字を消す．

操作 $ 3 $ を行うのは面倒なので，操作 $ 3 $ を行う回数をできるだけ少なくして，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換したい．

長さ $ N $ の文字列 $ S $ と $ 1 $ 以上の整数 $ K $ が与えられたとき，文字列 $ S $ をレベル $ K $ の JOI 文字列に変換するのに必要な操作 $ 3 $ の回数の最小値を出力するプログラムを作成せよ．ただし，どのように操作を行っても文字列 $ S $ をレベル $ K $ の JOI 文字列に変換できない場合は，代わりに $ −1 $ を出力せよ．

- - - - - -

## 说明/提示

### 制約

- $ 3\ \leqq\ N\ \leqq\ 200\,000 $．
- $ 1\ \leqq\ K\ \leqq\ \frac{N}{3} $．
- $ S $ は `J`，`O`，`I` の $ 3 $ 種類の文字からなる長さ $ N $ の文字列である．

### 小課題

1. ($ 1 $ 点) $ N\ \leqq\ 21 $.
2. ($ 12 $ 点) $ N\ \leqq\ 3\,000 $.
3. ($ 87 $ 点) 追加の制約はない.

- - - - - -

### Sample Explanation 1

次のように操作を行うことで，文字列 $ S $ をレベル $ K $ のJOI文字列に変換できる． 1. まず操作 $ 1 $ を行う．文字列 $ S $ は `JIJOIOIIJ` になる． 2. 次に操作 $ 2 $ を行う．文字列 $ S $ は `JIJOIOII` になる． 3. 次に操作 $ 3 $ を行い，先頭から $ 2 $ 文字目を消す．文字列 $ S $ は `JJOIOII` になる． 4. 最後に操作 $ 3 $ を行い，先頭から $ 4 $ 文字目を消す．文字列 $ S $ は `JJOOII` になる． $ 2 $ 回未満の操作 $ 3 $ で変換することは不可能なので，$ 2 $ を出力する． - - - - - -

### Sample Explanation 2

操作を行わなくてもよい． - - - - - -

### Sample Explanation 3

この入力例では，どのように操作を行っても文字列 $ S $ をレベル $ 1 $ の JOI 文字列に変換できない．

## 样例 #1

### 输入

```
10 2
OJIJOIOIIJ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3
JJJOOOIII```

### 输出

```
0```

## 样例 #3

### 输入

```
9 1
IIIOOOJJJ```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：JJOOII 2 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与指针维护（或前缀和+二分）`（编程技巧应用）


🗣️ **初步分析**：  
解决“JJOOII 2”的关键，是找到字符串中**最短的子串**，使得它能通过删除中间字符（操作3）变成K阶JOI字符串（K个J→K个O→K个I）。因为删首尾（操作1、2）不花钱，所以我们要最小化“子串长度 - 3K”（这就是操作3的次数）。  

### 核心思想类比  
想象你在玩“找宝藏”游戏：字符串是一条路，J、O、I是不同颜色的宝石。你需要找到一段路，里面有**至少K个红宝石（J）、K个绿宝石（O）、K个蓝宝石（I）**，而且红宝石必须在绿宝石前面，绿宝石在蓝宝石前面。这段路越短，你需要挖掉的“多余石头”（操作3）就越少。


### 解题思路与核心难点  
**常见思路**：  
1. **记录位置**：把J、O、I的位置分别存到三个列表（比如`vector`）里，方便快速查找。  
2. **枚举起点**：从第一个J开始，依次枚举每一组K个J的起始位置（比如第i个J到第i+K-1个J）。  
3. **找后续字符**：以这组J的结束位置为起点，找到下一组K个O的位置；再以O的结束位置为起点，找到下一组K个I的位置。  
4. **计算区间**：这组J的起始位置到I的结束位置，就是一个符合条件的子串，计算它的长度减去3K，取最小值。  

**核心难点**：  
- 如何**高效找到后续字符的位置**（避免暴力遍历）？  
- 如何**保证字符顺序**（J在O前，O在I前）？  
- 如何**优化时间复杂度**（处理2e5的大数据）？  


### 可视化设计思路  
为了让大家直观看到算法过程，我设计了一个**8位像素风格的动画**：  
- **场景**：字符串用红（J）、绿（O）、蓝（I）像素块排列，像一条“宝石路”。  
- **步骤演示**：  
  1. 枚举J的起始位置（比如第i个J），用**黄色框**高亮它。  
  2. 找到第i+K-1个J（比如第i+1个J，K=2），用**红色闪烁**标记这组J的结束位置。  
  3. 从J的结束位置往后，找到第一个O（绿宝石），用**绿色框**高亮它，再找到第o+K-1个O，标记结束位置。  
  4. 从O的结束位置往后，找到第一个I（蓝宝石），用**蓝色框**高亮它，再找到第i+K-1个I，标记结束位置。  
  5. 用**大框**圈出整个符合条件的子串，旁边显示“操作3次数：X”（子串长度-3K）。  
- **交互设计**：支持“单步执行”（一步步看指针移动）、“自动播放”（像游戏一样跑起来），还有“重置”按钮。关键操作会有音效（比如找到J时“叮”的一声，找到O时“咚”的一声），增加趣味性。  


## 2. 精选优质题解参考

为了帮大家找到最易理解、最高效的解法，我筛选了3份**思路清晰、代码简洁**的题解：


### **题解一：vector+指针法（作者：saixingzhe，赞1）**  
* **点评**：  
  这份题解的**核心亮点**是用`vector`记录每个字符的位置，再用**指针维护**O和I的起始位置，时间复杂度只有O(N)（每个指针只会移动一次），非常高效！  
  思路很直白：先把J、O、I的位置分别存到`q[0]`、`q[1]`、`q[2]`里，然后枚举J的起始位置i（第i个J），找到第i+K-1个J的位置，再移动O的指针找到第一个大于该位置的O，取第o+K-1个O的位置，最后移动I的指针找到第一个大于O结束位置的I，取第i+K-1个I的位置。计算区间长度，取最小值。  
  代码风格很干净，变量名（比如`q[0]`代表J的位置）容易理解，适合初学者模仿。


### **题解二：前缀和+lower_bound法（作者：small_turtle，赞3）**  
* **点评**：  
  这份题解用**前缀和数组**统计每个位置之前的J、O、I数量，再用`lower_bound`（二分查找）快速找到符合条件的位置，时间复杂度O(NlogN)，适合大数据。  
  思路：比如`J[i]`表示前i个字符中J的数量，枚举每个起始位置i（如果s[i]是J），用`lower_bound`找到第一个`J[x] = J[i-1]+k`的位置x（即包含k个J的结束位置），再用同样的方法找O和I的位置。  
  代码中的`lower_bound`用法很巧妙，简化了二分过程，值得学习！


### **题解三：vector+枚举法（作者：User_Artist，赞0）**  
* **点评**：  
  这份题解的**思路最直观**，适合刚学编程的同学。它把J、O、I的位置存到数组里，然后枚举每个J的起始位置，依次找后面的O和I的位置。虽然代码看起来有点“暴力”，但逻辑很清晰，容易理解。  
  比如，枚举J的起始位置`gj`，如果`gj +k > cj`（不够k个J）就跳出循环；然后找O的起始位置`go`（第一个大于J[gj+k-1]的O），如果`go +k > co`就跳出；再找I的起始位置`gi`（第一个大于O[go+k-1]的I），如果`gi +k > ci`就跳出。最后计算区间长度，取最小值。  


## 3. 核心难点辨析与解题策略

在解决这个问题时，大家常遇到以下3个难点，我结合优质题解总结了应对方法：


### **1. 如何高效找到后续字符的位置？**  
* **问题**：如果暴力遍历每个字符找O和I，时间复杂度会是O(N²)，无法处理2e5的大数据。  
* **解决方法**：  
  - 用`vector`记录每个字符的位置（比如`q[0]`存所有J的索引），这样可以快速通过索引找到对应的位置。  
  - 用**指针维护**O和I的起始位置（比如`go`表示当前O的起始位置），每次枚举J的起始位置时，只需要移动`go`和`gi`指针，不需要重新遍历，时间复杂度降到O(N)。  


### **2. 如何保证字符顺序？**  
* **问题**：如果O的位置在J的结束位置之前，或者I的位置在O的结束位置之前，那么这个子串无法变成K阶JOI字符串。  
* **解决方法**：  
  - 在找O的起始位置时，必须保证O的位置**大于**J的结束位置（比如`O[go] > J[gj+k-1]`）。  
  - 在找I的起始位置时，必须保证I的位置**大于**O的结束位置（比如`I[gi] > O[go+k-1]`）。  


### **3. 如何优化时间复杂度？**  
* **问题**：前缀和+二分的方法时间复杂度是O(NlogN)，对于2e5的数据来说是可行的，但有没有更高效的方法？  
* **解决方法**：  
  - 用`vector+指针`的方法，时间复杂度是O(N)，因为每个指针（`go`、`gi`）只会从左到右移动一次，不会回头。比如saixingzhe的题解，`go`和`gi`只会递增，不会减少，所以整个循环的次数是O(N)。  


### ✨ 解题技巧总结  
1. **记录位置**：把每个字符的位置存到`vector`里，方便快速查找。  
2. **指针维护**：用指针记录后续字符的起始位置，避免重复遍历。  
3. **条件判断**：每次找字符时，必须保证顺序正确（J→O→I）。  
4. **边界处理**：如果某一步找不到足够的字符（比如不够k个O），就跳出循环，避免无效计算。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自saixingzhe的题解）  
* **说明**：这份代码用`vector`记录字符位置，用指针维护O和I的起始位置，时间复杂度O(N)，是最高效的解法之一。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,k,O,I,ans=INT_MAX;
  string s;
  vector<int>q[3]; // q[0]存J的位置，q[1]存O的位置，q[2]存I的位置
  int main(){
      cin>>n>>k>>s;
      for(int i=0;i<s.size();i++){
          if(s[i]=='J')	q[0].push_back(i);
          if(s[i]=='O')	q[1].push_back(i);
          if(s[i]=='I')	q[2].push_back(i);
      }
      for(int J=0;J<=q[0].size()-k;J++){ // 枚举J的起始位置（第J个J）
          while(O<=q[1].size()-k&&q[0][J+k-1]>q[1][O])	O++; // 找到第一个O在J的结束位置之后
          while(I<=q[2].size()-k&&q[1][O+k-1]>q[2][I])	I++; // 找到第一个I在O的结束位置之后
          if(O<=q[1].size()-k&&I<=q[2].size()-k)	ans=min(ans,q[2][I+k-1]-q[0][J]+1-3*k);
          else	break;
      }
      if(ans==INT_MAX)	ans=-1;
      printf("%d",ans); 
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取n、k和字符串s。  
  2. **记录位置**：把J、O、I的位置分别存到`q[0]`、`q[1]`、`q[2]`里。  
  3. **枚举J的起始位置**：从第0个J开始，枚举每一组k个J的起始位置（`J`到`J+k-1`）。  
  4. **找O的位置**：用`while`循环移动`O`指针，找到第一个`q[1][O]`大于`q[0][J+k-1]`的位置（即O在J的结束位置之后）。  
  5. **找I的位置**：用`while`循环移动`I`指针，找到第一个`q[2][I]`大于`q[1][O+k-1]`的位置（即I在O的结束位置之后）。  
  6. **计算区间长度**：如果找到符合条件的O和I，计算区间长度（`q[2][I+k-1] - q[0][J] +1`）减去3k，取最小值。  


### 题解片段赏析（来自saixingzhe的题解）  
* **亮点**：用指针维护O和I的起始位置，避免重复遍历。  
* **核心代码片段**：  
  ```cpp
  while(O<=q[1].size()-k&&q[0][J+k-1]>q[1][O])	O++; // 找O的起始位置
  while(I<=q[2].size()-k&&q[1][O+k-1]>q[2][I])	I++; // 找I的起始位置
  ```  
* **代码解读**：  
  - `q[0][J+k-1]`是第J组k个J的结束位置（比如J=0，k=2，就是第1个J的位置）。  
  - `while`循环的条件是“当前O的位置`O`对应的`q[1][O]`小于等于J的结束位置”，并且`O`后面还有足够的k个O（`O<=q[1].size()-k`）。如果满足条件，就把`O`指针往后移，直到找到第一个大于J结束位置的O。  
  - 同样的，`q[1][O+k-1]`是第O组k个O的结束位置，`while`循环找第一个大于该位置的I。  
* 💡 **学习笔记**：指针维护是一种高效的技巧，适合处理“需要顺序查找”的问题，比如本题中的字符顺序要求。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：`像素JOI探险家`  
用8位像素风格展示字符串，J、O、I分别用红、绿、蓝像素块表示，像一条“宝石路”。探险家（一个小像素人）会沿着路走，寻找符合条件的子串。


### 核心演示内容  
1. **初始化场景**：屏幕上显示字符串的像素块（红J、绿O、蓝I），底部有“单步”、“自动”、“重置”按钮，还有一个速度滑块。  
2. **枚举J的起始位置**：探险家走到第i个J的位置，用**黄色框**高亮它，旁边显示“当前J起始位置：i”。  
3. **找J的结束位置**：探险家走到第i+K-1个J的位置，用**红色闪烁**标记，旁边显示“J结束位置：i+K-1”。  
4. **找O的起始位置**：探险家从J的结束位置往后走，找到第一个O（绿宝石），用**绿色框**高亮，旁边显示“O起始位置：o”。  
5. **找O的结束位置**：探险家走到第o+K-1个O的位置，用**绿色闪烁**标记，旁边显示“O结束位置：o+K-1”。  
6. **找I的起始位置**：探险家从O的结束位置往后走，找到第一个I（蓝宝石），用**蓝色框**高亮，旁边显示“I起始位置：i”。  
7. **找I的结束位置**：探险家走到第i+K-1个I的位置，用**蓝色闪烁**标记，旁边显示“I结束位置：i+K-1”。  
8. **显示结果**：用**大框**圈出整个符合条件的子串，旁边显示“操作3次数：X”（子串长度-3K），同时播放“胜利”音效（上扬的8位音乐）。  


### 设计思路  
- **像素风格**：营造复古游戏氛围，让学习更有趣。  
- **颜色区分**：用红、绿、蓝区分J、O、I，让字符位置更直观。  
- **动画步骤**：一步步展示指针移动过程，帮助理解“如何找到符合条件的子串”。  
- **音效反馈**：关键操作（比如找到J、O、I）有不同的音效，强化记忆。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的`枚举+指针`或`前缀和+二分`方法，可以用于解决以下问题：  
1. **寻找包含特定字符顺序的最短子串**（比如“找到包含A→B→C的最短子串”）。  
2. **统计符合条件的子串数量**（比如“统计有多少个子串包含K个J、K个O、K个I”）。  
3. **处理大字符串的区间查询**（比如“查询某个区间内的字符数量”）。  


### 练习推荐 (洛谷)  
1. **洛谷 P6878** - `[JOI 2020 Final] JJOOII 2`  
   🗣️ **推荐理由**：原题，巩固`枚举+指针`的方法，熟悉题目的核心逻辑。  
2. **洛谷 P1102** - `A-B 数对`  
   🗣️ **推荐理由**：练习前缀和的应用，学习如何统计区间内的字符数量。  
3. **洛谷 P1873** - `[COCI 2011/2012 #5] EKO`  
   🗣️ **推荐理由**：练习二分查找，学习如何用二分找到符合条件的区间。  
4. **洛谷 P2090** - `[NOIP 2016 提高组] 货币系统`  
   🗣️ **推荐理由**：练习动态规划，但其中的“枚举+判断”思路与本题类似。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自User_Artist的题解)  
> “我在解决这个问题时，最初没有考虑到‘如果后面不够k个O或I就跳出循环’，导致代码运行时间很长。后来加上这个条件，代码速度快了很多。”  

**点评**：这个经验很重要！在枚举J的起始位置时，如果后面不够k个O或I，就不需要继续枚举后面的J了，因为后面的J的起始位置更靠后，后面的O和I会更少。加上这个条件，可以避免很多无效计算，提高代码效率。  


## 💪 总结  
本次分析的“JJOOII 2”问题，核心是**找到符合条件的最短子串**，关键技巧是`枚举+指针维护`或`前缀和+二分`。通过学习这些技巧，你可以解决很多类似的字符串问题。记住，编程的关键是**多思考、多练习**，只要坚持，你一定能掌握这些技巧！  

下次我们再一起探索新的编程挑战！🚀

---
处理用时：200.55秒
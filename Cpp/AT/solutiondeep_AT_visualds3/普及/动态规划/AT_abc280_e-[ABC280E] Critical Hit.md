# 题目信息

# [ABC280E] Critical Hit

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc280/tasks/abc280_e

最初、体力が $ N $ であるモンスターが $ 1 $ 体います。  
 高橋君はモンスターに対し、モンスターの体力が $ 1 $ 以上残っている限り繰り返し攻撃を行います。

高橋君は $ 1 $ 回の攻撃で、$ \frac{P}{100} $ の確率でモンスターの体力を $ 2 $ 減らし、 $ 1-\frac{P}{100} $ の確率でモンスターの体力を $ 1 $ 減らします。

モンスターの体力が $ 0 $ 以下になるまでに行う攻撃回数の期待値を $ \text{mod\ }\ 998244353 $ で出力してください（注記参照）。

## 说明/提示

### 注記

求める期待値は必ず有限値かつ有理数となることが証明できます。また、この問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、$ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ一つ存在することが証明できます。この $ R $ を出力してください。

### 制約

- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ P\ \leq\ 100 $
- 入力は全て整数
 
### Sample Explanation 1

高橋君は $ 1 $ 回の攻撃で、 $ \frac{10}{100}=\frac{1}{10} $ の確率でモンスターの体力を $ 2 $ 減らし、 $ 1-\frac{10}{100}=\frac{9}{10} $ の確率でモンスターの体力を $ 1 $ 減らします。 - 最初、モンスターの体力は $ 3 $ です。 - $ 1 $ 回目の攻撃の後、$ \frac{9}{10} $の確率でモンスターの体力は $ 2 $、$ \frac{1}{10} $の確率でモンスターの体力は $ 1 $ となります。 - $ 2 $ 回目の攻撃の後、$ \frac{81}{100} $の確率でモンスターの体力は $ 1 $、$ \frac{18}{100} $ の確率でモンスターの体力は $ 0 $、$ \frac{1}{100} $ の確率でモンスターの体力は $ -1 $ となります。 $ \frac{18}{100}+\frac{1}{100}=\frac{19}{100} $ の確率で体力は $ 0 $ 以下となり、高橋君は $ 2 $ 回で攻撃をやめます。 - $ 2 $ 回目の攻撃の後で体力が $ 1 $ 残っている場合、$ 3 $ 回目の攻撃の後でモンスターの体力は必ず $ 0 $ 以下となり、高橋君は $ 3 $ 回で攻撃をやめます。 よって、期待値は $ 2\times\ \frac{19}{100}+3\times\left(1-\frac{19}{100}\right)=\frac{281}{100} $ となります。$ 229596204\ \times\ 100\ \equiv\ 281\pmod{998244353} $ であるため、$ 229596204 $ を出力します。

### Sample Explanation 2

高橋君は $ 1 $ 回の攻撃で、つねにモンスターの体力を $ 2 $ 減らします。 $ 2 $ 回目の攻撃が終わった時点では体力が $ 5-2\times\ 2=1 $ 残っているため、$ 3 $ 回目の攻撃を行う必要があります。

## 样例 #1

### 输入

```
3 10```

### 输出

```
229596204```

## 样例 #2

### 输入

```
5 100```

### 输出

```
3```

## 样例 #3

### 输入

```
280 59```

### 输出

```
567484387```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC280E] Critical Hit 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（期望DP）

🗣️ **初步分析**：  
解决“Critical Hit”问题的关键是**期望动态规划（DP）**——它像“搭积木”一样，把“计算N点体力的期望攻击次数”拆成“计算1点、2点……N-1点体力的期望”，用子问题的解一步步推导出原问题的解。  

### 核心思路
我们需要计算“击败i点体力怪物”的期望攻击次数（记为`dp[i]`）。攻击有两种可能：  
- 以`p`（`P/100`的模逆元）的概率减2点，此时需要先解决`i-2`点的情况，再加1次攻击；  
- 以`1-p`的概率减1点，此时需要先解决`i-1`点的情况，再加1次攻击。  

因此，状态转移方程为：  
`dp[i] = dp[i-1]*(1-p) + dp[i-2]*p + 1`（正向DP，`i`从2到N）  
或 `dp[i] = dp[i+1]*(1-p) + dp[i+2]*p + 1`（反向DP，`i`从N-1到0）。  

### 核心难点
- **状态定义**：选择正向（`i`表示当前体力）还是反向（`i`表示剩余体力）？正向更符合直觉，反向边界条件更简单（`dp[N] = 0`）。  
- **模运算处理**：分数取模需要用**费马小定理**求逆元（比如`1/100 ≡ 100^(998244353-2) mod 998244353`）。  
- **边界条件**：`dp[0] = 0`（0点体力不需要攻击），`dp[1] = 1`（1点体力攻击1次必败）。  

### 可视化设计思路
我们用**8位像素风格**设计动画，展示正向DP的计算过程：  
- **场景**：屏幕左侧是“体力进度条”（从1到N的像素块），右侧是“DP值面板”（显示每个`dp[i]`的当前值）。  
- **关键步骤**：计算`dp[i]`时，`i-1`和`i-2`的像素块会**闪烁**，并弹出“+1”的动画（表示加1次攻击），同时播放“叮”的音效。  
- **交互**：支持“单步执行”（逐步计算`dp[2]`到`dp[N]`）和“自动播放”（快速演示整个过程），用户可以拖动滑块调整速度。  


## 2. 精选优质题解参考

### 题解一：正向DP（来源：泥土笨笨，赞11）
* **点评**：  
  此题解**思路直白**，采用正向DP（`dp[i]`表示i点体力的期望次数），边界条件`dp[0]=0`、`dp[1]=1`非常清晰。代码中`hit1`（减1点的概率）和`hit2`（减2点的概率）的计算用了费马小定理求逆元，模运算处理严谨。**亮点**是将概率预先转换为模逆元，避免了重复计算，提高了代码效率。从实践角度看，代码结构工整，变量名含义明确（如`hit1`、`hit2`），非常适合初学者模仿。

### 题解二：反向DP（来源：liangbowen，赞16）
* **点评**：  
  此题解**边界处理巧妙**，采用反向DP（`dp[i]`表示剩余i点体力的期望次数），`dp[N] = 0`（已击败）的边界条件自然。转移方程`dp[i] = dp[i+1]*(1-p) + dp[i+2]*p + 1`逆向推导，避免了处理`i-2`为负数的情况。**亮点**是代码简洁，循环从`N-1`到`0`，逻辑清晰。这种反向思维在类似问题（如“路径计数”）中也常用，值得学习。

### 题解三：记忆化搜索（来源：Fire_flame，赞1）
* **点评**：  
  此题解**思路新颖**，用记忆化搜索（`dfs(x)`表示x点体力的期望次数）实现DP，递归过程中存储已计算的`f[x]`，避免重复计算。**亮点**是将DP的“递推”转化为“递归+记忆化”，更直观地体现了子问题的依赖关系。虽然递归在大规模数据下可能有栈溢出风险，但本题`N≤2e5`，用数组存储`f[x]`完全可行。


## 3. 核心难点辨析与解题策略

### 1. 状态定义的选择：正向 vs 反向？
* **分析**：  
  正向DP（`dp[i]`表示i点体力的期望）更符合“从少到多”的直觉，边界条件`dp[0]=0`、`dp[1]=1`容易理解，但需要处理`i-2`为负数的情况（如`i=1`时，`i-2=-1`，此时`dp[-1]`视为0）。  
  反向DP（`dp[i]`表示剩余i点体力的期望）边界条件`dp[N]=0`更自然，循环从`N-1`到`0`，无需处理负数，代码更简洁。  
* 💡 **学习笔记**：状态定义要优先考虑**边界条件的简洁性**。

### 2. 模运算：分数取模如何处理？
* **分析**：  
  题目要求结果对`998244353`取模，而概率是分数（如`P/100`）。根据**费马小定理**，`a/b ≡ a*b^(mod-2) mod mod`（其中`mod`是质数）。因此，`P/100`的模逆元是`P * qpow(100, mod-2) % mod`。  
* 💡 **学习笔记**：分数取模的关键是求分母的模逆元，费马小定理是常用工具。

### 3. 边界条件：如何确定`dp[0]`和`dp[1]`？
* **分析**：  
  `dp[0]`表示0点体力的期望次数，显然为0（不需要攻击）。`dp[1]`表示1点体力的期望次数，攻击1次必败（无论减1还是减2），因此`dp[1] = 1`。  
* 💡 **学习笔记**：边界条件是DP的“地基”，必须通过**实际场景推导**（如`i=1`时的攻击结果）。

### ✨ 解题技巧总结
- **问题分解**：将“N点体力的期望”拆成“i-1”和“i-2”的子问题，用转移方程连接。  
- **模逆元预处理**：预先计算`100`的逆元，避免重复计算（如`inv_100 = qpow(100, mod-2)`）。  
- **代码模块化**：将快速幂（`qpow`）、逆元计算（`inv`）封装成函数，提高代码可读性。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（正向DP）
* **说明**：综合泥土笨笨、Moyou等题解的思路，采用正向DP，代码清晰易懂，适合初学者。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  using namespace std;
  typedef long long LL;
  const int N = 2e5 + 10;
  const int MOD = 998244353;

  LL qpow(LL a, LL b) { // 快速幂求逆元
      LL res = 1;
      while (b) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  LL dp[N]; // dp[i]表示i点体力的期望攻击次数

  int main() {
      LL n, p;
      cin >> n >> p;
      LL inv_100 = qpow(100, MOD - 2); // 100的逆元
      LL hit2 = p * inv_100 % MOD; // 减2点的概率（模逆元）
      LL hit1 = (100 - p) * inv_100 % MOD; // 减1点的概率（模逆元）

      dp[0] = 0;
      dp[1] = 1;
      for (LL i = 2; i <= n; ++i) {
          dp[i] = (hit1 * dp[i-1] % MOD + hit2 * dp[i-2] % MOD + 1) % MOD;
      }

      cout << dp[n] << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 预处理：用快速幂计算`100`的逆元（`inv_100`），将概率`P/100`和`(100-P)/100`转换为模逆元（`hit2`、`hit1`）。  
  2. 初始化：`dp[0] = 0`（0点体力不需要攻击），`dp[1] = 1`（1点体力攻击1次必败）。  
  3. 递推：从`i=2`到`n`，用转移方程计算`dp[i]`，每次取模避免溢出。  


### 题解二：反向DP（来源：liangbowen）
* **亮点**：反向DP，边界条件更简洁。  
* **核心代码片段**：  
  ```cpp
  const int mod = 998244353;
  LL dp[200005];

  void solve() {
      int n, p;
      scanf("%d%d", &n, &p);
      LL inv_100 = qpow(100, mod - 2);
      p = p * inv_100 % mod; // p = P/100的模逆元

      dp[n] = 0;
      for (int i = n - 1; i >= 0; i--) {
          dp[i] = (dp[i+1] * (mod + 1 - p) % mod + dp[i+2] * p % mod) % mod + 1;
      }
      cout << dp[0] << '\n';
  }
  ```
* **代码解读**：  
  - `dp[n] = 0`：剩余n点体力时，已击败怪物，期望次数为0。  
  - 循环从`n-1`到`0`：计算剩余i点体力的期望次数，`dp[i]`依赖`dp[i+1]`（减1点的情况）和`dp[i+2]`（减2点的情况），加1次攻击。  
* 💡 **学习笔记**：反向DP的关键是**从结果倒推原因**，适合处理“剩余状态”的问题。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素怪物讨伐记》
采用**8位FC风格**，模拟“攻击怪物”的过程，展示DP数组的计算。

### 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是“怪物体力条”（1~N的像素块，初始为红色），右侧是“DP值面板”（显示每个`dp[i]`的当前值，初始为0）。  
   - 底部有“控制面板”：开始/暂停按钮、单步执行按钮、速度滑块（1~5倍速）。  
   - 背景播放8位风格的轻快BGM（如《超级马里奥》的背景音乐）。

2. **算法启动**：  
   - 点击“开始”按钮，`dp[0]`和`dp[1]`的像素块变为绿色（`dp[0]=0`，`dp[1]=1`），同时播放“滴”的音效。

3. **核心步骤演示**：  
   - 计算`dp[i]`时（从2到N）：  
     - `i-1`和`i-2`的像素块**闪烁黄色**（表示依赖这两个子问题）。  
     - 弹出“+1”的像素动画（表示加1次攻击），同时播放“叮”的音效。  
     - `dp[i]`的像素块变为蓝色，显示当前计算结果（如`dp[2] = hit1*dp[1] + hit2*dp[0] + 1`）。

4. **目标达成**：  
   - 当计算完`dp[N]`时，怪物体力条变为灰色（表示已击败），播放“胜利”音效（如《魂斗罗》的通关音乐），并弹出“期望次数：dp[N]”的提示框。

5. **交互设计**：  
   - 单步执行：点击“下一步”按钮，逐步计算`dp[2]`到`dp[N]`，方便观察每一步的变化。  
   - 自动播放：拖动速度滑块，调整计算速度（1倍速=1秒/步，5倍速=0.2秒/步）。  
   - 重置：点击“重置”按钮，恢复初始状态，重新演示。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
期望DP的核心是**状态转移方程**，它可以解决：  
- **路径期望**：如“从起点到终点的期望步数”（类似本题的攻击次数）。  
- **收益期望**：如“游戏中获得的期望分数”（将攻击次数替换为分数）。  
- **概率期望**：如“成功概率的期望”（将攻击次数替换为成功概率）。

### 练习推荐 (洛谷)
1. **洛谷 P1850 换教室**  
   - 🗣️ **推荐理由**：这道题是期望DP的经典题，需要处理“换教室”的概率和期望，状态转移方程更复杂，适合巩固期望DP的思路。  
2. **洛谷 P2613 【模板】有理数取余**  
   - 🗣️ **推荐理由**：本题是模逆元的模板题，需要掌握费马小定理求逆元的方法，是解决本题的基础。  
3. **洛谷 P3802 小魔女帕琪**  
   - 🗣️ **推荐理由**：这道题是期望DP的变形，需要计算“连续释放技能”的期望次数，状态转移方程与本题类似，适合拓展思维。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自泥土笨笨)
> “我在刚开始做这道题时，没注意到模运算的顺序，导致结果错误。后来通过打印中间变量（如`hit1`、`hit2`的值），发现是逆元计算时没有取模。这让我意识到，模运算必须**每一步都取模**，避免溢出。”

**点评**：这位作者的经验很典型。在编程中，**中间变量的打印**是排查错误的有效方法。对于模运算，每一步都要取模，否则会导致数值溢出（尤其是`long long`类型）。


## 🎉 结语
本次关于“[ABC280E] Critical Hit”的分析就到这里！希望这份指南能帮助你理解期望DP的核心思路，掌握模运算的处理技巧。记住：**动态规划的关键是“状态定义”和“转移方程”**，多做练习就能熟能生巧。下次我们再一起探索新的编程挑战！💪

---
处理用时：154.67秒
# 题目信息

# [ABC211D] Number of Shortest paths

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc211/tasks/abc211_d

AtCoder 国には $ 1 $ から $ N $ の番号がついた $ N $ 個の都市と、$ 1 $ から $ M $ の番号がついた $ M $ 個の道路があります。

道路 $ i $ を通ると都市 $ A_i $ と都市 $ B_i $ の間を双方向に $ 1 $ 時間で移動することができます。

都市 $ 1 $ から都市 $ N $ へ最も早く移動することができる経路は何通りありますか？  
 答えは非常に大きくなる可能性があるので $ (10^9+7) $ で割ったあまりを求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- $ (A_i,B_i) $ は相異なる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

都市 $ 1 $ から都市 $ 4 $ へは最短 $ 2 $ 時間で移動することができ、それを実現する経路は $ 1\ \to\ 2\ \to\ 4 $ と $ 1\ \to\ 3\ \to\ 4 $ の $ 2 $ つです。

### Sample Explanation 2

都市 $ 1 $ から都市 $ 4 $ へは最短 $ 3 $ 時間で移動することができ、それを実現する経路は $ 1\ \to\ 3\ \to\ 2\ \to\ 4 $ の $ 1 $ つです。

### Sample Explanation 3

都市 $ 1 $ から都市 $ 2 $ に移動することはできません。この場合 $ 0 $ を出力してください。

## 样例 #1

### 输入

```
4 5

2 4

1 2

2 3

1 3

3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3

1 3

2 3

2 4```

### 输出

```
1```

## 样例 #3

### 输入

```
2 0```

### 输出

```
0```

## 样例 #4

### 输入

```
7 8

1 3

1 4

2 3

2 4

2 5

2 6

5 7

6 7```

### 输出

```
4```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC211D] Number of Shortest paths 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**最短路计数（BFS应用）**  

🗣️ **初步分析**：  
解决“最短路径数目”问题，关键在于**用BFS求最短路的同时统计路径数**。可以把BFS想象成“洪水扩散”——从起点1开始，每一步扩散到相邻节点，第一次到达某个节点时的步数就是最短路径长度（因为边权都是1）。而路径数目呢？就像“水流分支”：如果节点A的最短路径是通过节点B来的，那么A的路径数就等于所有能到达A的最短路径节点的路径数之和。  

- **核心思路**：用`dist[]`数组记录从1到每个节点的最短距离（初始化为无穷大），`cnt[]`数组记录最短路径数目（初始化为0，`cnt[1]=1`因为起点只有1种方式）。BFS过程中，对于当前节点`u`的邻居`v`：  
  1. 如果`dist[v] > dist[u]+1`（发现更短路径），则更新`dist[v] = dist[u]+1`，并将`cnt[v]`设为`cnt[u]`（路径数继承自`u`）；  
  2. 如果`dist[v] == dist[u]+1`（发现相同长度的最短路径），则将`cnt[v]`加上`cnt[u]`（路径数累加）。  
- **核心难点**：如何保证`cnt[]`的正确性（避免重复计数或遗漏）、如何高效处理大规模数据（N和M到2e5）。  
- **可视化设计思路**：用像素风格展示BFS的“扩散”过程——起点1是红色，每一步扩散的节点变成黄色（已入队），处理完的节点变成绿色（已确定最短路径）。队列用像素块堆叠展示，每次入队/出队时有“叮”的音效。`dist[]`和`cnt[]`的变化用数字动态更新，比如`cnt[v]`增加时，数字会闪烁并播放“加分”音效。  


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速掌握核心逻辑：  
</eval_intro>  

**题解一：（来源：2020luke）**  
* **点评**：这份题解的思路非常直白——用BFS求最短路，同时用`cnt[]`统计路径数。代码结构清晰，变量命名（`dist`表示距离，`cnt`表示数目）非常直观，符合“见名知意”的编程规范。最值得学习的是**边处理逻辑**：当`dist[it] >= dist[u]+1`时，先更新`dist[it]`，再累加`cnt[it]`，并将未入队的节点加入队列。这种处理方式既保证了最短路径的正确性，又高效统计了路径数，适合作为入门模板。  

**题解二：（来源：Jasonshan10）**  
* **点评**：此题解用`step[]`代替`dist[]`，`cnt[]`统计路径数，思路与题解一一致，但增加了`push[]`数组标记节点是否已入队，避免重复入队。这种优化对于大规模数据（如2e5节点）非常有用，能减少队列的操作次数，提高效率。代码中的`scanf`和`printf`也符合竞赛中的输入输出优化习惯，值得借鉴。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题时，以下3个关键点需要特别注意：  
</difficulty_intro>  

1. **如何保证`cnt[]`的正确性？**  
   * **分析**：`cnt[v]`的更新必须基于**最短路径**。只有当`dist[v] == dist[u]+1`时，`u`到`v`的路径才是最短路径，此时才能将`cnt[u]`加到`cnt[v]`中。如果`dist[v]`还未被更新（即`dist[v]`是无穷大），则`u`是第一个到达`v`的节点，`cnt[v]`直接等于`cnt[u]`。  
   * 💡 **学习笔记**：`cnt[]`的更新必须与`dist[]`的更新同步，否则会统计到非最短路径的数目。  

2. **如何选择合适的算法？**  
   * **分析**：本题边权都是1，BFS是最优选择（时间复杂度O(N+M)）。如果用Dijkstra（时间复杂度O(M log N)），虽然也能解决，但效率不如BFS。因为BFS的“层次遍历”特性天然适合处理边权为1的最短路问题。  
   * 💡 **学习笔记**：边权为1时，优先用BFS；边权为正整数时，用Dijkstra；边权有负数时，用SPFA。  

3. **如何处理模运算？**  
   * **分析**：题目要求答案对`1e9+7`取模，因此每一步更新`cnt[]`时都要取模，避免整数溢出。比如`cnt[it] = (cnt[it] + cnt[u]) % mod`。  
   * 💡 **学习笔记**：模运算要“早做”，不要等到最后再取模，否则可能会因为中间结果过大而溢出。  


### ✨ 解题技巧总结  
- **技巧A：用BFS处理边权为1的最短路**：BFS的层次遍历能保证第一次到达节点时的步数是最短的。  
- **技巧B：同步更新距离和数目**：`dist[]`和`cnt[]`的更新要放在同一个条件判断中，确保逻辑一致。  
- **技巧C：输入输出优化**：对于大规模数据，用`scanf`和`printf`代替`cin`和`cout`，避免超时。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个通用的BFS实现，帮你快速理解整体框架：  
</code_intro_overall>  

**本题通用核心C++实现参考**  
* **说明**：本代码综合了题解一和题解二的思路，是最简洁的BFS实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <cstring>
  using namespace std;
  const int N = 2e5 + 10;
  const int mod = 1e9 + 7;
  vector<int> g[N]; // 图的邻接表
  int dist[N]; // 从1到每个节点的最短距离
  long long cnt[N]; // 从1到每个节点的最短路径数目
  int main() {
      int n, m;
      cin >> n >> m;
      for (int i = 0; i < m; i++) {
          int u, v;
          cin >> u >> v;
          g[u].push_back(v);
          g[v].push_back(u);
      }
      memset(dist, 0x3f, sizeof(dist)); // 初始化距离为无穷大
      dist[1] = 0;
      cnt[1] = 1;
      queue<int> q;
      q.push(1);
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          for (int v : g[u]) {
              if (dist[v] > dist[u] + 1) { // 发现更短路径
                  dist[v] = dist[u] + 1;
                  cnt[v] = cnt[u]; // 路径数继承自u
                  q.push(v); // 将v加入队列
              } else if (dist[v] == dist[u] + 1) { // 发现相同长度的最短路径
                  cnt[v] = (cnt[v] + cnt[u]) % mod; // 路径数累加
              }
          }
      }
      cout << cnt[n] << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取节点数`n`和边数`m`，用邻接表`g[]`存储图。  
  2. **初始化**：`dist[]`初始化为无穷大（`0x3f`），`dist[1] = 0`（起点距离为0），`cnt[1] = 1`（起点只有1种方式）。  
  3. **BFS循环**：从队列中取出当前节点`u`，遍历其所有邻居`v`：  
     - 如果`v`的距离大于`u`的距离+1，更新`v`的距离和路径数，并将`v`加入队列。  
     - 如果`v`的距离等于`u`的距离+1，累加`v`的路径数。  
  4. **输出结果**：输出`cnt[n]`（从1到n的最短路径数目）。  


<code_intro_selected>  
接下来看题解一的核心片段，帮你理解BFS的具体执行过程：  
</code_intro_selected>  

**题解一：（来源：2020luke）**  
* **亮点**：用`memset`初始化`dist`为无穷大，代码简洁；边处理逻辑清晰，兼顾了距离更新和数目统计。  
* **核心代码片段**：  
  ```cpp
  void bfs() {
      memset(d, 0x3f, sizeof(d));
      d[1] = 0; s[1] = 1;
      queue<int> q;
      q.push(1);
      while(!q.empty()) {
          int u = q.front(); q.pop();
          for(auto it : g[u]) {
              if(d[it] >= d[u] + 1) {
                  if(d[it] > 1e8) q.push(it); // 未入队的节点加入队列
                  d[it] = d[u] + 1;
                  s[it] = (s[it] + s[u]) % mod;
              }
          }
      }
  }
  ```  
* **代码解读**：  
  - `memset(d, 0x3f, sizeof(d))`：将`d`数组初始化为`0x3f3f3f3f`（约1e9），表示无穷大。  
  - `d[1] = 0; s[1] = 1`：起点1的距离为0，路径数为1。  
  - `for(auto it : g[u])`：遍历`u`的所有邻居`it`。  
  - `if(d[it] >= d[u] + 1)`：如果`it`的距离大于等于`u`的距离+1（即`u`到`it`是最短路径）：  
    - `if(d[it] > 1e8)`：如果`it`的距离还未被更新（即`d[it]`是无穷大），将`it`加入队列。  
    - `d[it] = d[u] + 1`：更新`it`的距离。  
    - `s[it] = (s[it] + s[u]) % mod`：累加`it`的路径数。  
* 💡 **学习笔记**：`d[it] > 1e8`的判断是为了避免重复入队，提高效率。因为`d[it]`初始化为`0x3f3f3f3f`（约1e9），所以当`d[it]`大于1e8时，说明`it`还未被处理过。  


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>  
为了更直观地理解BFS的“扩散”过程，我设计了一个**8位像素风格的动画**，结合复古游戏元素，让你“看”到算法的每一步！  
\</visualization\_intro\>  

### **动画演示主题**：《像素探险家：最短路径大冒险》  
- **场景**：一个由像素块组成的网格地图，节点是彩色的方块（1号节点是红色，目标节点N是金色），边是灰色的线条。  
- **角色**：一个像素风格的探险家（小矮人），从1号节点出发，逐步探索周围的节点。  


### **核心演示内容**  
1. **初始化**：  
   - 屏幕显示网格地图，1号节点（红色）闪烁，旁边显示`dist[1]=0`、`cnt[1]=1`。  
   - 控制面板有“开始”“单步”“重置”按钮，速度滑块（从“慢”到“快”）。  
   - 播放8位风格的背景音乐（轻快的电子乐）。  

2. **BFS扩散过程**：  
   - **第一步**：探险家从1号节点出发，遍历其所有邻居（比如2号和3号节点）。这些邻居变成黄色（已入队），队列（屏幕右侧）显示2、3。此时`dist[2]=1`、`cnt[2]=1`；`dist[3]=1`、`cnt[3]=1`。播放“叮”的音效（入队提示）。  
   - **第二步**：队列弹出2号节点（变成绿色，已处理），遍历其邻居（比如4号节点）。4号节点变成黄色，队列显示3、4。此时`dist[4]=2`、`cnt[4]=1`（来自2号节点）。  
   - **第三步**：队列弹出3号节点（变成绿色），遍历其邻居（比如4号节点）。此时`dist[4] == dist[3]+1`（2==1+1），所以`cnt[4]`增加到2（1+1）。4号节点的`cnt`数字闪烁，播放“加分”音效。  
   - **目标达成**：当探险家到达N号节点（金色）时，播放胜利音效（上扬的电子音），屏幕显示“最短路径数目：2”（对应样例1）。  

3. **交互设计**：  
   - **单步执行**：点击“单步”按钮，动画执行一步（比如弹出一个节点，处理其邻居）。  
   - **自动播放**：拖动速度滑块，动画自动执行，速度可调（慢：每步1秒，快：每步0.1秒）。  
   - **重置**：点击“重置”按钮，动画回到初始状态。  


### **设计思路**  
- **像素风格**：模拟FC红白机的画面，让学习者感到亲切，减少对算法的恐惧感。  
- **游戏化元素**：探险家的角色、音效、胜利提示，增加学习的趣味性。比如“加分”音效能强化“路径数累加”的记忆，胜利音效能让学习者感受到成就感。  
- **数据可视化**：`dist`和`cnt`的动态更新，让学习者直观看到每个节点的状态变化，理解BFS的“层次遍历”特性。  


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>  
掌握了本题的BFS最短路计数后，你可以尝试以下问题，巩固知识点：  
\</similar\_problems\_intro\>  

### **通用思路/技巧迁移**  
- **场景1**：求无向图中从起点到所有节点的最短路径数目（如洛谷P1144）。  
- **场景2**：求有向图中从起点到终点的最短路径数目（边权为1）。  
- **场景3**：求网格图中从左上角到右下角的最短路径数目（障碍物阻挡）。  


### **练习推荐 (洛谷)**  
1. **洛谷 P1144** - 《最短路计数》  
   * 🗣️ **推荐理由**：本题是ABC211D的原题，要求求从1到所有节点的最短路径数目，直接应用BFS即可，适合巩固基础。  
2. **洛谷 P3371** - 《【模板】单源最短路径（弱化版）》  
   * 🗣️ **推荐理由**：本题要求求单源最短路径（边权为正），可以用Dijkstra算法，帮助你理解不同最短路算法的应用场景。  
3. **洛谷 P4779** - 《【模板】单源最短路径（标准版）》  
   * 🗣️ **推荐理由**：本题是Dijkstra算法的标准版（堆优化），适合学习如何处理大规模数据（N=1e5，M=2e5）。  


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>  
从题解中，我提炼了以下有价值的经验，帮你避免踩坑：  
\</insights\_intro\>  

> **参考经验（来自2020luke）**：“我在调试时，一开始忘记了模运算，导致答案溢出。后来每一步都加了`% mod`，才通过了所有测试用例。”  
> **点评**：模运算的重要性不容忽视！对于大数问题，一定要在每一步更新时取模，否则会因为中间结果过大而导致整数溢出（比如`cnt[v]`可能达到1e9，超过`int`的范围）。  


## 结语  
本次关于“[ABC211D] Number of Shortest paths”的分析就到这里。希望你能掌握BFS最短路计数的核心逻辑，学会用像素动画直观理解算法，并且通过拓展练习巩固知识点。记住：编程的乐趣在于“解决问题”，慢慢来，你一定能学会！💪  

---  
**Kay的小提示**：如果遇到问题，可以尝试用“手动模拟”的方法（比如拿样例1，一步步走BFS流程），这样能快速理解算法的执行过程。加油！

---
处理用时：154.14秒
# 题目信息

# [ABC376D] Cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点 $ M $ 辺の単純有向グラフがあります。$ i $ 番目の辺 $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ a_i $ から頂点 $ b_i $ へ伸びる辺です。  
 頂点 $ 1 $ を含む閉路が存在するか判定して、存在する場合はそのような閉路のうち辺数が最小の閉路の辺数を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\ \left(\ \frac{N(N-1)}{2},\ 2\ \times\ 10^5\ \right) $
- $ 1\ \leq\ a_i\ \leq\ N $
- $ 1\ \leq\ b_i\ \leq\ N $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ かつ $ (a_i,\ b_i)\ \neq\ (b_j,\ a_j) $
- 入力される値は全て整数
 
### Sample Explanation 1

頂点 $ 1 $ $ \to $ 頂点 $ 2 $ $ \to $ 頂点 $ 3 $ $ \to $ 頂点 $ 1 $ は辺数が $ 3 $ の閉路で、これが頂点 $ 1 $ を含む唯一の閉路です。

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2

1 2

2 3```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 9

6 1

1 5

2 6

2 1

3 6

4 2

6 4

3 5

5 4```

### 输出

```
4```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC376D] Cycle 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**BFS（广度优先搜索）**（搜索类别）

🗣️ **初步分析**：  
解决“找包含顶点1的有向图最小环”问题，关键在于**将环转化为“从1出发→经过其他点→回到1”的最短路径**。想象一下，BFS就像“洪水从1号点扩散”，每一步都探索所有可能的方向，而**最短环**就是洪水“第一次流回1号点”的路径长度。  

在本题中，BFS的核心作用是**计算从1到每个点的最短距离**，当遇到某点有边指向1时，该点的距离+1就是一个环的长度（比如点x到1的距离是d，那么1→x→1的环长就是d+1）。我们需要找到所有这样的环中的最小值。  

**核心算法流程**：  
1. 用邻接表存储有向图（因为N和M很大，邻接矩阵会超时）；  
2. 从1号点开始BFS，记录每个点的最短距离（`dis`数组）；  
3. 遍历所有边，若某条边的终点是1（即`b_i=1`），则计算`dis[a_i]+1`（`a_i`到1的距离+这条边），取所有结果的最小值；  
4. 若没有这样的边，输出-1。  

**可视化设计思路**：  
我们可以做一个“像素迷宫探险”动画：  
- 用8位像素块表示节点（1号点用红色，其他点用蓝色）；  
- 用箭头表示有向边（比如从a到b的边是黄色箭头）；  
- BFS过程中，每扩展一个节点，该节点会“闪烁”（表示被访问），并显示当前距离；  
- 当遇到指向1的边时，箭头会变成绿色，同时弹出“找到环！长度为X”的提示框；  
- 加入“单步执行”和“自动播放”按钮，让你能慢慢看清楚每一步的扩散过程。  


## 2. 精选优质题解参考

为了帮你快速掌握核心思路，我筛选了以下**思路清晰、代码规范**的题解（评分≥4星）：


### **题解一（作者：Heldivis，赞3）**  
* **点评**：  
  这道题解的**思路转化非常巧妙**——把“找包含1的环”变成“找从1到x再回到1的最短路径”。代码用邻接表存图，从1的邻居开始BFS（避免直接回到1），记录每个邻居到1的距离（`d[y] = 1`），然后逐层扩展。最后看`d[1]`的值（如果能回到1，`d[1]`就是环的长度）。逻辑简洁，时间复杂度O(N+M)，完全符合题目要求。  


### **题解二（作者：shitingjia，赞2）**  
* **点评**：  
  这道题解的**代码可读性很高**。用队列存`(节点, 距离)`，当遍历到某条边的终点是1时，直接输出`距离+1`（比如当前节点u的距离是time，那么u→1的边就构成环长time+1）。同时用`vis`数组标记已访问的节点，避免重复遍历。逻辑直观，适合初学者理解。  


### **题解三（作者：zjj2024，赞1）**  
* **点评**：  
  这道题解的**细节处理很到位**。用`vis`数组记录节点的访问顺序（即距离），当遇到指向1的边时，`vis[x]`就是从1到x的距离，直接输出`vis[x]`（因为x→1的边加1，刚好是环长）。代码简洁，边界条件处理得好（比如`vis[1]`初始化为1，避免一开始就返回）。  


## 3. 核心难点辨析与解题策略

在解决本题时，你可能会遇到以下**核心难点**，结合优质题解的经验，我总结了应对策略：


### **1. 如何避免BFS一开始就回到1？**  
**问题**：如果直接从1开始BFS，第一步就会遍历1的所有邻居，此时如果有邻居指向1（比如边1→2→1），会误判环长为2，但实际上环长是2吗？不，1→2→1的环长是2（两条边），但此时BFS会在第一步就找到吗？  
**策略**：  
- 方法一：从1的邻居开始BFS（比如Heldivis的题解），即初始时把1的所有邻居加入队列，距离设为1，这样避免直接处理1→1的情况；  
- 方法二：在BFS过程中，当遇到指向1的边时，判断当前节点是否已经被访问过（比如shitingjia的题解），确保不是第一步就返回。  


### **2. 如何正确计算环的长度？**  
**问题**：环的长度是“从1出发→经过其他点→回到1”的边数，比如1→2→3→1的环长是3。  
**策略**：  
- 对于边`a→b`，如果`b=1`，那么环长是`dis[a] + 1`（`dis[a]`是1到a的距离，加这条边就是环的长度）；  
- 比如shitingjia的题解中，当遍历到`v=1`时，输出`time+1`（`time`是当前节点u的距离，u→1的边加1）。  


### **3. 如何处理有向图的遍历？**  
**问题**：有向图的边是单向的，比如a→b的边不能反向走，所以BFS时只能沿着边的方向扩展。  
**策略**：  
- 用邻接表存储有向图（比如`e[u]`存u能到达的所有节点）；  
- BFS时，只遍历`e[u]`中的节点，确保方向正确。  


### ✨ 解题技巧总结  
- **问题转化**：把“找环”转化为“找最短路径”，这是解决图论问题的常用技巧；  
- **数据结构选择**：用邻接表存图，避免邻接矩阵的高时间复杂度；  
- **边界条件处理**：注意1号点的初始状态，避免误判；  
- **BFS的应用**：边权为1时，BFS是找最短路径的最优选择（时间复杂度O(N+M)）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了Heldivis、shitingjia等题解的思路，提供一个清晰的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <cstring>
  using namespace std;
  
  const int N = 2e5 + 10;
  vector<int> e[N]; // 邻接表
  int dis[N]; // 存储1到每个点的最短距离
  int n, m;
  
  int main() {
      cin >> n >> m;
      for (int i = 1; i <= m; ++i) {
          int a, b;
          cin >> a >> b;
          e[a].push_back(b);
      }
  
      memset(dis, -1, sizeof(dis)); // 初始化距离为-1（未访问）
      queue<int> q;
  
      // 从1的邻居开始BFS，避免直接回到1
      for (int y : e[1]) {
          dis[y] = 1;
          q.push(y);
      }
  
      while (!q.empty()) {
          int x = q.front();
          q.pop();
          for (int y : e[x]) {
              if (dis[y] == -1) { // 未访问过
                  dis[y] = dis[x] + 1;
                  q.push(y);
              }
          }
      }
  
      // 找所有指向1的边，计算环长
      int ans = -1;
      for (int a = 1; a <= n; ++a) {
          for (int b : e[a]) {
              if (b == 1 && dis[a] != -1) { // a能到1，且1能到a
                  if (ans == -1 || dis[a] + 1 < ans) {
                      ans = dis[a] + 1;
                  }
              }
          }
      }
  
      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. 用邻接表`e`存储有向图；  
  2. 初始化`dis`数组为-1（未访问）；  
  3. 从1的邻居开始BFS，记录每个邻居到1的距离（`dis[y] = 1`）；  
  4. 逐层扩展，更新每个点的距离；  
  5. 遍历所有边，找到指向1的边，计算环长（`dis[a] + 1`），取最小值。  


### 针对优质题解的片段赏析

#### **题解一（Heldivis）**  
* **亮点**：从1的邻居开始BFS，避免直接处理1→1的情况。  
* **核心代码片段**：  
  ```cpp
  for (int y : e[1]) q.push(y), d[y] = 1;
  while (q.size()) {
      int x = q.front();
      q.pop();
      for (int y : e[x])
          if (d[y] > d[x] + 1) d[y] = d[x] + 1, q.push(y);
  }
  ```  
* **代码解读**：  
  - 初始时，把1的所有邻居加入队列，距离设为1（因为从1到邻居需要1条边）；  
  - BFS过程中，每扩展一个节点x，就更新其邻居y的距离（`d[y] = d[x] + 1`）；  
  - 最后，`d[1]`就是从1的邻居回到1的最短距离（即环长）。  
* 💡 **学习笔记**：从邻居开始BFS是处理“包含起点的环”的常用技巧，避免了起点的干扰。  


#### **题解二（shitingjia）**  
* **亮点**：用队列存`(节点, 距离)`，直接判断指向1的边。  
* **核心代码片段**：  
  ```cpp
  queue<pair<int, int>> q;
  q.push({1, 0});
  while (!q.empty()) {
      int u = q.front().first, time = q.front().second;
      q.pop();
      for (auto v : e[u]) {
          if (v == 1) {
              cout << time + 1;
              return 1;
          }
          if (!vis[v]) {
              vis[v] = 1;
              q.push({v, time + 1});
          }
      }
  }
  ```  
* **代码解读**：  
  - 队列中的每个元素是`(当前节点, 从1到当前节点的距离)`；  
  - 当遍历到`v=1`时，输出`time+1`（当前节点u的距离+u→1的边，就是环长）；  
  - 用`vis`数组标记已访问的节点，避免重复遍历。  
* 💡 **学习笔记**：这种方法直观易懂，适合初学者理解“环”的形成过程。  


## 5. 算法可视化：像素动画演示 (核心部分)

### **动画演示主题**：像素迷宫中的“环”探险  
**设计思路**：用8位像素风格模拟BFS过程，让你直观看到“洪水扩散”和“找环”的过程。


### **核心演示内容**  
1. **场景初始化**：  
   - 屏幕左侧是像素化的图（节点用蓝色方块表示，1号点用红色方块）；  
   - 屏幕右侧是控制面板（有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块）；  
   - 背景音乐是8位风格的“冒险曲”（比如《超级马里奥》的背景音乐）。  

2. **BFS启动**：  
   - 1号点开始“发光”（表示起点）；  
   - 1的邻居（比如2号点）被“点亮”（变成黄色），并显示距离1（比如2号点上方显示“1”）；  
   - 队列用像素块堆叠的形式显示在屏幕下方（比如2号点的像素块在队列中）。  

3. **核心步骤演示**：  
   - 每一步，队列中的第一个节点（比如2号点）被“取出”（从队列中消失）；  
   - 2号点的所有邻居（比如3号点）被“点亮”（变成黄色），显示距离2（3号点上方显示“2”）；  
   - 当3号点有边指向1号点时，这条边会变成绿色，同时弹出提示框：“找到环！长度为3（1→2→3→1）”；  
   - 此时，1号点会“闪烁”，并播放“胜利”音效（比如《魂斗罗》的通关音效）。  

4. **交互设计**：  
   - 你可以点击“单步执行”，一步步看BFS的扩展过程；  
   - 也可以拖动速度滑块，调整自动播放的速度；  
   - 如果没有找到环，屏幕会显示“没有包含1的环”，并播放“失败”音效（比如《坦克大战》的爆炸音效）。  


## 6. 拓展练习与相似问题思考

### **通用思路/技巧迁移**  
BFS找最短路径的思路不仅能解决本题，还能解决以下问题：  
- **迷宫问题**：找从起点到终点的最短路径；  
- **单词接龙**：找从一个单词到另一个单词的最短转换路径（每步改一个字母）；  
- **社交网络问题**：找两个人之间的最短好友链。  


### **练习推荐 (洛谷)**  
1. **洛谷 P2661** - 信息传递  
   🗣️ **推荐理由**：这道题是“找有向图中的最小环”的经典题，和本题思路几乎一样，只是需要找所有点的最小环，适合巩固BFS的应用。  

2. **洛谷 P1144** - 最短路计数  
   🗣️ **推荐理由**：这道题需要计算从1到所有点的最短路径数目，用BFS就能解决，适合练习BFS的扩展应用。  

3. **洛谷 P3916** - 图的遍历  
   🗣️ **推荐理由**：这道题需要找每个点能到达的最大节点，用反向图+BFS就能解决，适合练习有向图的处理。  


## 7. 学习心得与经验分享 (若有)

### **参考经验 (来自 Heldivis)**  
“直接求环比较难处理，所以我把问题转化为‘从1出发到x再回到1的最短路径’。这样用BFS就能轻松解决。”  

**点评**：这位作者的思路转化非常关键。很多图论问题都需要“换个角度看问题”，比如把“环”转化为“往返路径”，这样就能用熟悉的算法（比如BFS）解决。  


### **参考经验 (来自 shitingjia)**  
“我在写代码时，一开始忘了标记已访问的节点，导致队列中出现重复节点，超时了。后来加上`vis`数组就好了。”  

**点评**：这是初学者常犯的错误。BFS中标记已访问的节点是为了避免重复遍历，提高效率。记住：**每扩展一个节点，就要标记它为已访问**。  


## 结语  
本次关于“[ABC376D] Cycle”的分析就到这里。希望这份指南能帮你理解BFS的应用，以及如何将复杂问题转化为熟悉的模型。记住：**编程的关键是“思路”，而不是“代码”**——先想清楚“怎么做”，再写“怎么实现”。下次我们再一起探索新的编程挑战！💪

---
处理用时：150.13秒
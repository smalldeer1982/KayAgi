# 题目信息

# [ABC156D] Bouquet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc156/tasks/abc156_d

あかりさんは $ n $ 種類の花を $ 1 $ 本ずつ持っています。

あかりさんは、これらの花から $ 1 $ 本以上を選び、花束を作ろうとしています。

ただし、あかりさんは $ a $ と $ b $ の $ 2 $ つの数を苦手としていて、いずれかと一致するような本数の花からなる花束は作ることができません。

あかりさんが作ることのできる花束は何種類あるでしょうか。

$ (10^9\ +\ 7) $ で割った余りを求めてください。

ここで $ 2 $ つの花束は、一方では使われているが、 もう一方では使われていない種類の花があるとき、別の種類の花束であるとみなします。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ n\ \leq\ 10^9 $
- $ 1\ \leq\ a\ <\ b\ \leq\ \textrm{min}(n,\ 2\ \times\ 10^5) $

### Sample Explanation 1

この場合、あかりさんは $ 2 $ 本または $ 4 $ 本の花を選んで花束を作ることができます。 $ 4 $ 本ある花の中から $ 2 $ 本を選ぶ方法は $ 6 $ 通り、$ 4 $ 本を選ぶ方法は $ 1 $ 通りあるので、 あかりさんが作ることができる花束の種類数は合わせて $ 7 $ 通りです。

### Sample Explanation 2

$ (10^9\ +\ 7) $ で割った余りを出力してください。

## 样例 #1

### 输入

```
4 1 3```

### 输出

```
7```

## 样例 #2

### 输入

```
1000000000 141421 173205```

### 输出

```
34076506```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC156D] Bouquet 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：组合数学（组合数计算）、快速幂、逆元（费马小定理）  

🗣️ **初步分析**：  
解决“Bouquet”问题，关键在于理解**组合数的高效计算**和**模运算的处理**。简单来说，题目要求从`n`种花中选至少1朵，但不能选`a`或`b`朵，方案数等于“总方案数”减去“不合法方案数”。  
- **总方案数**：每种花有选或不选两种可能，共`2^n`种，减去空集（1种），即`2^n - 1`。  
- **不合法方案数**：选`a`朵的方案数`C(n,a)`和选`b`朵的方案数`C(n,b)`。  

**核心难点**：`n`可达`1e9`，无法直接预处理阶乘，但`a`和`b`很小（≤`2e5`），因此可以**暴力计算组合数的分子**（`n*(n-1)*...*(n-a+1)`），再用**逆元计算分母**（`a!`的逆元）。  

**可视化设计思路**：  
我们可以用**8位像素风格**展示组合数`C(n,a)`的计算过程：  
- 用像素块表示`n`、`a`、`b`等变量，用不同颜色区分分子（乘积过程）、分母（逆元计算）。  
- 每一步乘法或逆元运算伴随“叮”的音效，完成组合数计算时播放“胜利”音效。  
- 加入“单步执行”和“自动播放”功能，让学习者直观看到`C(n,a)`的计算流程。  


## 2. 精选优质题解参考

为了帮助大家快速掌握解题思路，我筛选了以下**评分≥4星**的优质题解：


### **题解一：作者Xu__（赞：5）**  
* **点评**：  
  这份题解**思路清晰、代码规范**，完美贴合题目要求。作者直接给出了核心公式`2^n - 1 - C(n,a) - C(n,b)`，并正确处理了组合数的计算——利用`a`和`b`小的特点，暴力计算分子（`n*(n-1)*...*(n-a+1)`），再用费马小定理求分母（`a!`）的逆元。代码中的`F_Pow`（快速幂）、`Fac`（阶乘）、`Inv`（逆元）函数分工明确，变量命名易懂（如`Mod`表示模数），边界处理严谨（如加`Mod`防止负数）。从实践角度看，这份代码可以直接用于竞赛，是非常好的参考。  


### **题解二：作者DengDuck（赞：3）**  
* **点评**：  
  此题解**预处理逆元的方法更高效**。作者预处理了`inv`数组到`3e5`，然后计算`C(n,m)`时，逐次乘`(n-m+i)`再乘`inv[i]`（`i`从1到`m`），这样可以避免先算分子再算分母的两步操作，节省了代码量。思路与题解一一致，但代码更简洁，适合学习“组合数的递推计算”技巧。  


### **题解三：作者orpg（赞：3）**  
* **点评**：  
  此题解**思路正确**，但代码中有冗余（如`D`数组是错排的，题目不需要）。不过，作者正确使用了快速幂和逆元计算组合数，并且处理了模运算中的负数问题（加`2*Mod`再取模）。适合学习“如何避免冗余代码”的反面例子——**不需要的变量或函数不要写**，否则会影响代码可读性。  


## 3. 核心难点辨析与解题策略

在解决本题时，大家通常会遇到以下**3个核心难点**，结合优质题解的做法，我为大家总结了应对策略：


### **1. 组合数`C(n,a)`的计算（`n`大，`a`小）**  
* **难点**：`n`可达`1e9`，无法预处理`n!`，但`a`很小（≤`2e5`）。  
* **策略**：利用组合数的公式`C(n,a) = (n*(n-1)*...*(n-a+1)) / a!`。  
  - 分子：暴力循环`a`次，计算`n*(n-1)*...*(n-a+1)`（模`1e9+7`）。  
  - 分母：计算`a!`的逆元（用费马小定理，`inv(a!) = (a!)^(1e9+7-2) mod 1e9+7`）。  
* 💡 **学习笔记**：当`n`很大但`k`很小时，暴力计算组合数的分子是最优选择。  


### **2. 逆元的应用（费马小定理）**  
* **难点**：模运算中的除法需要转化为乘法（因为`(a/b) mod p ≠ (a mod p)/(b mod p)`）。  
* **策略**：利用费马小定理，若`p`是质数，则`b^(p-2) mod p`是`b`的逆元。因此，`a/b mod p = a * b^(p-2) mod p`。  
* 💡 **学习笔记**：费马小定理是竞赛中求逆元的常用方法，适用于`p`是质数的情况。  


### **3. 模运算中的负数处理**  
* **难点**：`2^n - 1 - C(n,a) - C(n,b)`可能为负数（如`2^n`很小，而`C(n,a)`很大时）。  
* **策略**：每次减法后都加上`Mod`，再取模，确保结果非负。例如：`(ans - C(n,a) + Mod) % Mod`。  
* 💡 **学习笔记**：模运算中的负数处理是必做步骤，否则会得到错误结果。  


### ✨ 解题技巧总结  
- **问题转化**：将“选至少1朵”转化为“总方案数减空集”，简化计算。  
- **组合数优化**：当`n`大`k`小时，暴力计算分子+逆元分母是最优解。  
- **模运算规范**：每次加减乘后都取模，避免溢出；减法后加`Mod`防止负数。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了优质题解的思路，实现了快速幂、逆元、组合数计算，是解决本题的标准模板。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  using namespace std;
  const int Mod = 1e9 + 7;

  // 快速幂：计算a^b mod p
  long long qpow(long long a, long long b) {
      long long res = 1;
      while (b) {
          if (b & 1) res = res * a % Mod;
          a = a * a % Mod;
          b >>= 1;
      }
      return res;
  }

  // 计算组合数C(n, m)：n选m的方案数
  long long C(long long n, long long m) {
      if (n < m) return 0;
      long long numerator = 1; // 分子：n*(n-1)*...*(n-m+1)
      for (long long i = n - m + 1; i <= n; ++i) {
          numerator = numerator * i % Mod;
      }
      long long denominator = 1; // 分母：m!
      for (long long i = 1; i <= m; ++i) {
          denominator = denominator * i % Mod;
      }
      // 分母的逆元：denominator^(Mod-2) mod Mod
      long long inv_denominator = qpow(denominator, Mod - 2);
      return numerator * inv_denominator % Mod;
  }

  int main() {
      long long n, a, b;
      cin >> n >> a >> b;
      long long total = qpow(2, n); // 总方案数：2^n
      long long ans = (total - 1 - C(n, a) - C(n, b) + 3 * Mod) % Mod;
      // 加3*Mod防止负数：(total-1)可能为负，减C(a)和C(b)也可能为负
      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三个部分：  
  1. `qpow`：快速幂函数，用于计算`2^n`和逆元。  
  2. `C`：组合数函数，暴力计算分子（`n*(n-1)*...*(n-m+1)`），再计算分母（`m!`）的逆元，最后相乘得到组合数。  
  3. `main`：读取输入，计算总方案数`2^n`，减去空集（1）和不合法组合数（`C(n,a)`、`C(n,b)`），处理负数后输出结果。  


### 针对各优质题解的片段赏析

#### **题解一（Xu__）：组合数计算**  
* **亮点**：明确区分分子和分母的计算，代码逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  long long C(long long n, long long m) {
      if (n < m) return 0;
      long long ans = 1;
      for (long long i = n - m + 1; i <= n; ++i) {
          ans = ans * i % Mod;
      }
      return ans * qpow(Fac(m), Mod - 2) % Mod;
  }
  ```  
* **代码解读**：  
  - 循环计算分子：`n*(n-1)*...*(n-m+1)`（共`m`次循环）。  
  - 调用`Fac(m)`计算`m!`，再用`qpow`求其逆元（`Fac(m)^(Mod-2)`）。  
  - 分子乘逆元得到组合数，模`Mod`防止溢出。  
* 💡 **学习笔记**：`Fac(m)`是预处理`m!`的函数，当`m`≤`2e5`时，预处理可以提高效率。  


#### **题解二（DengDuck）：预处理逆元**  
* **亮点**：预处理`inv`数组，避免重复计算逆元。  
* **核心代码片段**：  
  ```cpp
  const int N = 3e5 + 5;
  long long inv[N];
  void init() {
      inv[1] = 1;
      for (int i = 2; i < N; ++i) {
          inv[i] = (Mod - Mod / i) * inv[Mod % i] % Mod;
      }
  }
  long long C(long long n, long long m) {
      long long ans = 1;
      for (int i = 1; i <= m; ++i) {
          ans = ans * (n - m + i) % Mod * inv[i] % Mod;
      }
      return ans;
  }
  ```  
* **代码解读**：  
  - `init`函数：预处理`inv`数组，`inv[i]`表示`i`的逆元（用递推式`inv[i] = (Mod - Mod/i) * inv[Mod%i] % Mod`）。  
  - `C`函数：逐次计算`(n-m+i)*inv[i]`（`i`从1到`m`），等价于`(n*(n-1)*...*(n-m+1)) / m!`。  
* 💡 **学习笔记**：预处理逆元可以减少重复计算，适合需要多次计算组合数的场景。  


#### **题解三（orpg）：模运算处理**  
* **核心代码片段**：  
  ```cpp
  cout << (qpow(2, n) - 1 - C(n, a) - C(n, b) + 2 * Mod) % Mod;
  ```  
* **代码解读**：  
  - 加`2*Mod`是为了防止负数：`qpow(2, n) - 1`可能为负（如`n=0`，但本题`n≥2`），减`C(n,a)`和`C(n,b)`也可能为负。加`2*Mod`后取模，确保结果非负。  
* 💡 **学习笔记**：模运算中的负数处理是细节，但直接影响结果的正确性，必须重视。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**《像素组合数计算器》**（8位像素风格，仿FC游戏）  


### 核心演示内容  
展示组合数`C(n,a)`的计算过程，包括：  
1. 分子的乘法（`n*(n-1)*...*(n-a+1)`）；  
2. 分母的逆元计算（`a!`的逆元）；  
3. 分子乘逆元得到组合数。  


### 设计思路简述  
- **像素风格**：用8位像素块表示变量（如`n`是红色方块，`a`是蓝色方块），用不同颜色区分分子（绿色）、分母（黄色）、逆元（紫色）。  
- **音效**：每一步乘法伴随“叮”的音效，逆元计算完成伴随“嗡”的音效，组合数计算完成伴随“胜利”音效（如FC游戏的通关音乐）。  
- **交互**：提供“单步执行”（点击“下一步”按钮）、“自动播放”（滑动条调整速度）、“重置”（重新开始）功能。  


### 动画帧步骤  
1. **初始化场景**：  
   - 屏幕左侧显示`n`、`a`、`b`的像素值（如`n=4`，`a=2`）；  
   - 中间区域显示分子（绿色方块，初始为`1`）、分母（黄色方块，初始为`1`）、逆元（紫色方块，初始为`1`）；  
   - 右侧显示组合数结果（灰色方块，初始为`0`）。  

2. **计算分子**：  
   - 循环`a`次，每次取出`n-m+1`（`m`从1到`a`）的像素值，与分子相乘，分子方块的数值更新（如`4*3=12`）；  
   - 每一步乘法伴随“叮”的音效，当前相乘的因子用闪烁效果突出。  

3. **计算分母**：  
   - 循环`a`次，每次取出`i`（`i`从1到`a`）的像素值，与分母相乘，分母方块的数值更新（如`1*2=2`）；  
   - 每一步乘法伴随“叮”的音效。  

4. **计算逆元**：  
   - 调用快速幂函数计算分母的逆元（`2^(1e9+7-2) mod 1e9+7`）；  
   - 逆元方块的数值逐渐更新（如`2`的逆元是`500000004`），伴随“嗡”的音效。  

5. **计算组合数**：  
   - 分子乘逆元，结果显示在右侧的组合数方块中（如`12*500000004 mod 1e9+7=6`）；  
   - 组合数方块闪烁，伴随“胜利”音效。  


### 旁白提示  
- “现在计算分子：4*3=12，这是选2朵花的排列数！”  
- “分母是2! = 2，需要求它的逆元！”  
- “逆元计算完成：2的逆元是500000004！”  
- “组合数C(4,2)=12*500000004 mod 1e9+7=6，对啦！”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的核心技巧（**组合数的暴力计算+逆元**）可以迁移到以下场景：  
1. **求`C(n,k)`，其中`n`很大（`1e9`），`k`很小（`≤2e5`）**；  
2. **模运算中的除法处理**（如求`(a/b) mod p`，其中`p`是质数）；  
3. **快速幂的应用**（如计算`2^n`、`a^b mod p`）。  


### 练习推荐（洛谷）  
以下题目可以帮助你巩固本题的知识点：  
1. **洛谷 P3811** - 《乘法逆元》  
   🗣️ **推荐理由**：这是逆元的模板题，要求预处理`1~n`的逆元，适合学习逆元的递推方法。  
2. **洛谷 P1010** - 《组合数问题》  
   🗣️ **推荐理由**：要求计算`C(n,k)`的末尾0的个数，需要掌握组合数的质因数分解方法，是组合数的拓展练习。  
3. **洛谷 P1616** - 《快速幂》  
   🗣️ **推荐理由**：快速幂的模板题，要求计算`a^b mod p`，适合巩固快速幂的实现。  
4. **洛谷 P2613** - 《组合数模运算》  
   🗣️ **推荐理由**：要求计算`C(n,k) mod 1e9+7`，其中`n`和`k`都很大（`≤1e5`），需要预处理阶乘和逆元，是组合数的进阶练习。  


## 7. 学习心得与经验分享（若有）

### 参考经验（来自Hog_Dawa_IOI）  
> “我在赛时写快速幂的时候，把`x`打成了`rt`，导致结果错误。后来调试了很久才发现这个问题。”  

**点评**：这位作者的经历提醒我们，**代码中的变量名要准确**，尤其是在复制粘贴代码时，要注意变量的正确性。快速幂中的`x`是底数，`rt`是中间结果，不能混淆。**调试时可以打印中间变量，快速定位错误**。  


## 结语  
本次关于“[ABC156D] Bouquet”的C++解题分析就到这里。希望这份指南能帮助你掌握组合数的高效计算、快速幂和逆元的应用。记住，**细节决定成败**——模运算的负数处理、变量名的准确性、代码的简洁性都是竞赛中的关键。下次我们再一起探索新的编程挑战！💪  

如果有任何疑问，欢迎随时向我提问～

---
处理用时：168.75秒
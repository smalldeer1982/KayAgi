# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果



---
# 💡 Kay的C++算法解析：[Katana Thrower] 深入学习指南 💡

<introduction>
今天我们来一起分析“Katana Thrower”这道C++编程题。这道题需要我们找到用最少攻击次数击败怪物的策略，核心在于贪心算法的灵活运用。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
解决“Katana Thrower”这道题，关键在于理解并运用贪心算法。贪心算法的核心思想是“每一步都选择当前最优的选项”，就像你去买零食，每次都选当前最想吃的，最终组合起来就是最满足的选择。在本题中，我们需要在“投掷”和“劈砍”两种攻击方式中，每一步都选择能造成更大伤害的操作，从而最小化总攻击次数。

- **题解思路与核心难点**：题目难点在于如何平衡“投掷高伤害但只能用一次”和“劈砍低伤害但可以无限次使用”的选择。优质题解普遍采用两种策略：一种是将所有可能的攻击（投掷和劈砍）按伤害排序，优先选伤害高的；另一种是先确定劈砍的最优刀（最大a_i），再投掷其他比该刀劈砍伤害更高的刀，最后用最优刀劈砍剩余伤害。后者更高效，避免了同一刀被重复使用的问题。
  
- **核心算法流程**：首先找到劈砍伤害最大的刀（记为max_a），然后收集所有投掷伤害b_i大于max_a的刀（因为这些刀的投掷伤害比无限劈砍更划算），按投掷伤害从高到低排序。依次投掷这些刀，直到剩余伤害可以用max_a的劈砍解决。若投掷过程中已击败怪物，则直接返回次数；否则计算剩余伤害用max_a劈砍所需次数，总次数即为投掷次数+劈砍次数。

- **可视化设计思路**：采用8位像素风格，用不同颜色的方块表示“投掷”（红色）和“劈砍”（蓝色）攻击。动画中，先展示所有刀的b_i和a_i值，排序后红色方块依次“飞”向怪物（伴随“咻”的音效），每投掷一次，怪物剩余血量减少并显示当前总次数。当遇到蓝色方块（劈砍）时，展示连续的“砍击”动画（快速闪烁的蓝色刀影，伴随“唰”的音效），直到怪物血量归零。关键步骤高亮当前选择的刀和剩余血量变化。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：来源：Mysterious_Cat**
* **点评**：此题解思路非常清晰，首先明确“劈砍应选伤害最大的刀”这一关键点，避免了拆分刀的逻辑错误。代码中通过遍历找到最优劈砍刀（p），并收集所有投掷伤害高于该刀劈砍伤害的刀（存入vector），排序后依次投掷。剩余伤害用最优刀劈砍，逻辑严谨。代码变量命名合理（如p表示最优劈砍刀，v存储投掷候选刀），边界处理（如特判剩余伤害是否需要额外一次劈砍）非常细致，实践价值高，适合竞赛场景。

**题解二：来源：happybob**
* **点评**：此题解采用“先计算仅劈砍的次数，再枚举投掷次数”的策略，通过排序投掷伤害并依次尝试，找到最小总次数。思路简洁高效，时间复杂度O(n log n)（排序），适合处理大规模数据（n=1e5）。代码中“ceil”函数的使用和“min(ans, k)”的更新逻辑，体现了对问题的深刻理解。虽然未显式处理最优劈砍刀，但通过取max_a隐含了这一关键点，是贪心思想的灵活应用。

**题解三：来源：Hilte（补充）**
* **点评**：此题解通过排序a和b数组，直接投掷比最大a大的b值，逻辑简洁。虽然未显式处理所有边界（如投掷后剩余伤害可能小于b[p]的情况），但核心思路正确，适合快速理解贪心策略。代码简短，变量命名清晰，适合初学者参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼了几个核心思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何选择最优的劈砍刀？**
    * **分析**：劈砍可以无限次使用，因此应选择劈砍伤害最大的刀（记为max_a）。这是因为用max_a劈砍每次造成的伤害最大，能最小化劈砍次数。优质题解通常通过遍历所有a_i找到max_a（如Mysterious_Cat的p变量，happybob的max_a变量）。
    * 💡 **学习笔记**：无限次操作的最优选择，一定是单次效率最高的那个。

2.  **关键点2：如何确定需要投掷哪些刀？**
    * **分析**：投掷的刀只能用一次，因此只有当投掷伤害b_i大于max_a时，投掷才比用max_a劈砍更划算。例如，若b_i=10，max_a=5，投掷一次相当于劈砍两次（10>5×2）。优质题解通过筛选b_i>max_a的刀并排序（如Mysterious_Cat的vector v），确保每次投掷都是当前最优选择。
    * 💡 **学习笔记**：投掷的价值在于“单次伤害高于无限次劈砍的效率”。

3.  **关键点3：如何计算剩余伤害的劈砍次数？**
    * **分析**：投掷后剩余的伤害需要用max_a劈砍，次数为“剩余伤害除以max_a，向上取整”。例如，剩余伤害=7，max_a=3，则需要3次（3×3=9≥7）。优质题解通过“h % a[p] == 0”判断是否需要额外一次劈砍（如Mysterious_Cat的delta处理）。
    * 💡 **学习笔记**：向上取整的公式为 (h + a - 1) / a，等价于h/a + (h%a != 0)。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将问题拆分为“投掷高价值刀”和“用最优刀劈砍”两阶段，简化决策过程。
- **排序优化**：对投掷候选刀按伤害降序排序，确保每次投掷都是当前最优。
- **边界特判**：处理剩余伤害为0或刚好整除的情况，避免多算或少算次数。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Mysterious_Cat和happybob的思路，优先投掷高价值刀，再用最优刀劈砍，逻辑清晰且高效。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;

    int main() {
        int n;
        ll h;
        cin >> n >> h;
        vector<ll> a(n), b(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i] >> b[i];
        }

        // 找到劈砍伤害最大的刀
        ll max_a = *max_element(a.begin(), a.end());
        vector<ll> throwable;
        for (int i = 0; i < n; ++i) {
            if (b[i] > max_a) { // 仅保留投掷伤害大于max_a的刀
                throwable.push_back(b[i]);
            }
        }
        sort(throwable.rbegin(), throwable.rend()); // 降序排序

        ll ans = LLONG_MAX;
        ll sum = 0;
        int cnt = 0;

        // 尝试投掷k把刀（k从0到throwable.size()）
        for (int k = 0; k <= throwable.size(); ++k) {
            if (k > 0) {
                sum += throwable[k - 1];
                cnt++;
            }
            ll remain = h - sum;
            if (remain <= 0) {
                ans = min(ans, (ll)cnt);
                break; // 投掷k把已足够，后续k更大次数不会更优
            }
            // 剩余伤害用max_a劈砍的次数
            ll hit = (remain + max_a - 1) / max_a;
            ans = min(ans, cnt + hit);
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入并找到劈砍伤害最大的刀（max_a）。然后收集所有投掷伤害大于max_a的刀，按降序排序。通过枚举投掷0到全部候选刀的情况，计算每种情况下的总次数（投掷次数+劈砍次数），取最小值。这种方法确保了所有可能的投掷次数都被考虑，避免了遗漏最优解。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段，点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：来源：Mysterious_Cat**
* **亮点**：明确最优劈砍刀，仅投掷比其伤害高的刀，避免无效投掷，时间复杂度O(n log n)。
* **核心代码片段**：
    ```cpp
    int p = 1;
    for (int i = 1; i <= n; ++i) {
        if (a[p] < a[i] || a[p] == a[i] && b[p] > b[i]) p = i;
    }
    vector<long long> v;
    for (int i = 1; i <= n; ++i) {
        if (i != p && b[i] >= a[p]) {
            v.push_back(b[i]);
        }
    }
    sort(v.begin(), v.end(), greater<ll>());
    ```
* **代码解读**：
    > 这段代码首先遍历所有刀，找到劈砍伤害最大的刀（p）。然后收集其他刀中投掷伤害≥a[p]的刀（存入v），并按降序排序。为什么这样做？因为只有投掷伤害≥a[p]的刀，投掷一次的收益才不低于用p刀劈砍多次（例如，b[i]=10，a[p]=5，投掷一次相当于劈砍两次）。排序后，后续投掷时优先选伤害高的，确保每一步都是最优选择。
* 💡 **学习笔记**：明确“核心工具”（最优劈砍刀）是简化问题的关键。

**题解二：来源：happybob**
* **亮点**：通过枚举投掷次数，动态更新最小总次数，逻辑简洁且覆盖所有可能情况。
* **核心代码片段**：
    ```cpp
    ans = ceil(double(h) / max_a); // 仅劈砍的次数
    sort(b + 1, b + 1 + n, greater<int>());
    for (int i = 1; i <= n; i++) {
        h -= b[i];
        if (h < 0) h = 0;
        k = i + ceil(double(h) / max_a);
        ans = min(ans, k);
    }
    ```
* **代码解读**：
    > 这段代码首先计算仅用最优刀劈砍的次数（ans）。然后将投掷伤害降序排序，依次尝试投掷1到n把刀，每次计算总次数（投掷i把+剩余伤害劈砍次数），并更新ans的最小值。例如，投掷前i把刀后，剩余伤害h'=h - sum(b[1..i])，总次数为i + ceil(h'/max_a)。这种方法通过枚举所有可能的投掷次数，确保找到全局最优解。
* 💡 **学习笔记**：枚举+贪心是处理“有限次高收益操作”的常用策略。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心算法的执行过程，我设计了一个“像素刀客”主题的8位复古动画，帮助大家“看”到每一步的最优选择！
</visualization_intro>

  * **动画演示主题**：像素刀客的打怪挑战（8位FC风格）

  * **核心演示内容**：展示如何选择投掷高伤害刀，再用最优刀劈砍的全过程，包括伤害累加、攻击次数增加和怪物血量变化。

  * **设计思路简述**：采用FC红白机的像素风格（16色调色板，方块化角色），用红色方块表示投掷的刀（仅出现一次），蓝色方块表示劈砍的刀（连续出现）。关键操作伴随音效（投掷“咻~”，劈砍“唰！”，怪物死亡“叮！”），增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示怪物（像素化的绿色怪兽，头顶血量条H），右侧显示N把刀（每把刀用两个方块表示：蓝色是劈砍a_i，红色是投掷b_i）。
          * 控制面板：单步/自动按钮、速度滑块（1x-4x）、重置按钮。

    2.  **确定最优劈砍刀**：
          * 所有蓝色方块（a_i）开始闪烁，最终最大的蓝色方块（max_a）停止闪烁并高亮（金色边框），显示“最优劈砍刀！”文字气泡。

    3.  **筛选投掷候选刀**：
          * 红色方块（b_i）与max_a比较，大于max_a的红色方块变为亮红色（候选），否则变暗（不投掷）。

    4.  **投掷高伤害刀**（自动/单步模式）：
          * 亮红色方块按伤害从高到低排序，依次“飞”向怪物（像素动画：红色方块从右侧滑动到左侧，碰撞怪物时爆炸）。
          * 每投掷一次，怪物血量条减少b_i值，攻击次数+1，播放“咻~”音效。
          * 若血量≤0，播放“叮！”胜利音效，显示“怪物被击败！总次数：X”。

    5.  **剩余伤害劈砍**（若未击败）：
          * 金色边框的蓝色方块（max_a）开始快速闪烁，连续“砍击”怪物（蓝色刀影快速重复出现）。
          * 每砍一次，血量条减少max_a值，攻击次数+1，播放“唰！”音效。
          * 血量归零后，播放“叮！”音效，显示总次数。

    6.  **交互控制**：
          * 单步模式：点击“下一步”，手动控制投掷或劈砍的每一步。
          * 自动模式：根据速度滑块，自动播放整个过程（速度越快，动画越快）。
          * 重置按钮：回到初始状态，重新选择参数（H和刀的a_i、b_i）。

  * **旁白提示**：
      * （确定最优劈砍刀时）“看！这把刀的劈砍伤害最大，之后我们主要用它来补刀~”
      * （投掷候选刀时）“这些红色刀的投掷伤害比最优劈砍刀还高，先扔它们更划算！”
      * （劈砍阶段）“剩下的伤害用最优刀连续劈砍，每次都能造成最大伤害~”

<visualization_conclusion>
通过这样一个融合像素动画和游戏音效的演示，我们能清晰看到贪心算法如何每一步选择最优攻击，从而最小化总次数。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的贪心策略后，我们可以进一步思考该算法在其他场景的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 贪心算法适用于“每一步选择局部最优，最终达到全局最优”的问题，例如：
        1. 任务调度（优先处理耗时短或收益高的任务）。
        2. 区间覆盖（选择结束最早的区间，覆盖更多区域）。
        3. 硬币找零（优先用面值大的硬币，减少数量）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1223 排队接水**
          * 🗣️ **推荐理由**：贪心经典题，通过排序使总等待时间最小，与本题“优先高收益操作”思路类似。
    2.  **洛谷 P1090 合并果子**
          * 🗣️ **推荐理由**：使用优先队列选择最小的两堆合并，体现“每一步局部最优”的贪心思想。
    3.  **洛谷 P2240 硬币问题**
          * 🗣️ **推荐理由**：在硬币数量有限时，贪心选择面值大的硬币，与本题“投掷仅一次”的限制类似。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 Mysterious_Cat)**：“感谢老师cookiebus带我调了一年的代码，刚开始总忘记特判投掷后剩余伤害是否需要额外一次劈砍，后来通过打印中间变量才定位到问题。”

> **点评**：Mysterious_Cat的经验提醒我们，在处理边界条件（如剩余伤害是否整除）时，通过打印中间变量（如delta的值）可以有效定位错误。这是调试贪心问题的常用技巧，尤其是在涉及向上取整的场景中。

---

<conclusion>
本次关于“Katana Thrower”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握贪心算法的应用，理解如何通过每一步的最优选择解决问题。记住，多动手调试、分析边界条件，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---

---
处理用时：142.80秒
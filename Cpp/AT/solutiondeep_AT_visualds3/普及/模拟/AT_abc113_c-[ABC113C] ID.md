# 题目信息

# [ABC113C] ID

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc113/tasks/abc113_c

Atcoder国には $ N $ 個の県があり、これらの県には合計で $ M $ 個の市が属しています。

市 $ i $ が誕生したのは $ Y_i $ 年であり、県 $ P_i $ に属しています。

ただし、同じ年に誕生した市が複数存在することはないとします。

それぞれの市に $ 12 $ 桁の認識番号を割り振ることとなりました。

市 $ i $ が 県 $ P_i $ に属する市の中で $ x $ 番目に誕生した市のとき、市 $ i $ の認識番号の上 $ 6 $ 桁は $ P_i $、下 $ 6 $ 桁は $ x $ となります。

ただし、$ P_i $ や $ x $ が $ 6 $ 桁に満たない場合は $ 6 $ 桁になるまで $ 0 $ を左に追加するものとします。

全ての市の認識番号を求めてください。

ただし、市が $ 1 $ つも属さない県がある場合に注意してください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ P_i\ \leq\ N $
- $ 1\ \leq\ Y_i\ \leq\ 10^9 $
- $ Y_i $ は全て異なる
- 入力は全て整数

### Sample Explanation 1

\- 市 $ 1 $ は県 $ 1 $ に属する市の中で $ 2 $ 番目に誕生したので、認識番号は $ 000001000002 $ となります。 - 市 $ 2 $ は県 $ 2 $ に属する市の中で $ 1 $ 番目に誕生したので、認識番号は $ 000002000001 $ となります。 - 市 $ 3 $ は県 $ 1 $ に属する市の中で $ 1 $ 番目に誕生したので、認識番号は $ 000001000001 $ となります。

## 样例 #1

### 输入

```
2 3

1 32

2 63

1 12```

### 输出

```
000001000002

000002000001

000001000001```

## 样例 #2

### 输入

```
2 3

2 55

2 77

2 99```

### 输出

```
000002000001

000002000002

000002000003```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC113C] ID 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：排序与二分查找（编程技巧应用）

🗣️ **初步分析**：  
解决“ID”问题的关键，就像给每个“县”里的“市”按“出生年份”排好队，再给每个市发一个“队号”。简单来说，**排序**是把每个县的市按年份从小到大排好，**二分查找**是快速找到每个市在队伍中的位置（第几个出生）。在本题中，这两个技巧组合起来，就能高效计算每个市的12位ID（前6位是县号，后6位是队号）。  

- **核心思路**：先把每个县的市年份收集起来（分组），排序后，用二分查找快速定位每个市的排名，最后格式化输出ID。  
- **核心难点**：① 如何高效分组存储每个县的市年份？② 如何快速找到每个市在县内的排名？③ 如何输出6位补0的数字？  
- **解决方案**：用`vector`数组分组存储（每个县对应一个`vector`），用`sort`排序每个`vector`，用`lower_bound`二分查找排名，用`printf`的`%012lld`格式补0。  

**可视化设计思路**：  
我会设计一个“像素县排队”动画——每个县是一个像素框，里面的小方块代表市（颜色越深，年份越晚）。排序时，小方块会“交换位置”（比如从乱序到有序），伴随“叮”的音效；查找时，会有一个像素箭头“指向”目标市的位置，旁边显示“第x位”。动画支持“单步执行”（看每一步排序/查找）和“自动播放”（快速过流程），帮助大家直观看到“分组→排序→查找”的全过程。


## 2. 精选优质题解参考

**题解一：(来源：Chouquet)**  
* **点评**：这份题解的思路像“整理抽屉”一样清晰——先把每个县的市年份放进对应的“抽屉”（`vector`数组），再把每个抽屉里的年份“排好序”（`sort`），最后从抽屉里“找到”每个市的位置（`lower_bound`）。代码风格非常规范，`p[i]`代表县号，`y[i]`代表年份，`a[p[i]]`代表第`p[i]`个县的市年份列表，变量名一看就懂。算法上，排序用了`sort`（时间复杂度O(K log K)，K是每个县的市数量），查找用了`lower_bound`（O(log K)），整体效率很高，完全能处理1e5的数据规模。从实践角度看，代码直接用`printf`的`%012lld`解决了补0问题，边界处理很严谨（比如`lower_bound`的结果加1，因为`vector`下标从0开始），直接复制就能通过测试用例，非常适合作为模板学习。


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何高效分组存储每个县的市年份？**  
* **分析**：每个县可能有多个市，我们需要把同一个县的市年份放在一起。用`vector`数组（`a[100003]`）刚好解决这个问题——`a[p]`就是第`p`个县的所有市年份的列表。比如输入中“县1”的市年份是32、12，那么`a[1]`就会存储`[32, 12]`，之后排序成`[12, 32]`。  
* 💡 **学习笔记**：`vector`数组是处理“分组存储”的好工具，灵活且节省空间。


### 2. **关键点2：如何快速找到每个市在县内的排名？**  
* **分析**：排序后的`vector`是有序的，我们可以用`lower_bound`快速找到`y[i]`的位置（第一个大于等于`y[i]`的元素的迭代器）。因为`y[i]`都是唯一的，所以这个位置就是`y[i]`在排序后的`vector`中的下标，加1就是排名（比如下标0对应第1位）。比如`a[1]`排序后是`[12, 32]`，`y=32`的下标是1，排名就是2。  
* 💡 **学习笔记**：排序+二分查找是“快速找排名”的经典组合，时间复杂度低。


### 3. **关键点3：如何输出6位补0的数字？**  
* **分析**：题目要求ID是12位，前6位是县号（补0），后6位是排名（补0）。我们可以把县号乘以1e6（即1000000），加上排名，得到一个12位的数字（比如县号1+排名2=1000002），然后用`printf`的`%012lld`格式输出——`%012`表示占12位，不足补0，`lld`表示长整型（防止溢出）。  
* 💡 **学习笔记**：`printf`的格式控制是处理“补0”问题的利器，记住`%0nd`（n是位数）的用法。


### ✨ 解题技巧总结  
- **分组处理**：用`vector`数组将同一类数据（比如同一个县的市）放在一起，便于后续操作。  
- **排序+二分**：对于“找排名”问题，先排序再用二分查找，效率比遍历高很多。  
- **格式控制**：用`printf`的`%0nd`解决补0问题，简单又高效。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：此代码来自Chouquet的题解，是“分组→排序→查找→输出”的典型实现，逻辑清晰、高效。  
* **完整核心代码**：  
  ```cpp
  #include <stdio.h>
  #include <algorithm>
  #include <vector>
  using namespace std; // 注意：原代码省略了using namespace std;，这里补充以便编译

  int n, m, p[100003], y[100003];
  vector<int> a[100003]; // a[p]存储第p个县的所有市年份

  int main() {
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= m; i++) {
          scanf("%d%d", &p[i], &y[i]);
          a[p[i]].push_back(y[i]); // 将市i的年份加入对应的县列表
      }
      for (int i = 1; i <= n; i++) {
          sort(a[i].begin(), a[i].end()); // 对每个县的市年份排序
      }
      for (int i = 1; i <= m; i++) {
          // 用lower_bound找y[i]在a[p[i]]中的位置，加1得到排名
          long long rank = lower_bound(a[p[i]].begin(), a[p[i]].end(), y[i]) - a[p[i]].begin() + 1;
          printf("%012lld\n", (long long)p[i] * 1000000 + rank); // 输出12位ID
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为四步：① 读取输入（县数`n`、市数`m`，每个市的县号`p[i]`和年份`y[i]`）；② 分组存储（将每个市的年份加入对应的县`vector`）；③ 排序（每个县的`vector`按年份升序排序）；④ 查找并输出（用`lower_bound`找每个市的排名，格式化输出12位ID）。


### 针对优质题解的片段赏析  
**题解一：(来源：Chouquet)**  
* **亮点**：用`vector`数组分组存储，`sort`+`lower_bound`高效解决“找排名”问题，代码简洁到极致。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; i++) {
      sort(a[i].begin(), a[i].end()); // 对每个县的市年份排序
  }
  for (int i = 1; i <= m; i++) {
      long long rank = lower_bound(a[p[i]].begin(), a[p[i]].end(), y[i]) - a[p[i]].begin() + 1;
      printf("%012lld\n", (long long)p[i] * 1000000 + rank);
  }
  ```  
* **代码解读**：  
  - 第一部分：`sort(a[i].begin(), a[i].end())`——对每个县的市年份排序，比如县1的`vector`从`[32,12]`变成`[12,32]`，这样年份早的市排在前面。  
  - 第二部分：`lower_bound`返回`y[i]`在`a[p[i]]`中的迭代器，减去`a[p[i]].begin()`得到下标（比如`y=32`在`[12,32]`中的下标是1），加1得到排名（1+1=2）。  
  - 第三部分：`(long long)p[i] * 1000000 + rank`——将县号（前6位）和排名（后6位）合并成一个12位数字，`%012lld`输出补0。  
* 💡 **学习笔记**：`lower_bound`的返回值是迭代器，减去`begin()`得到下标，这是C++中常用的技巧；`long long`防止整数溢出（比如`p[i]`是1e5，乘以1e6是1e11，刚好在`long long`范围内）。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：《像素县的市排队记》  
（仿照FC红白机风格，用8位像素块展示“分组→排序→查找”过程）


### 📝 核心演示内容  
1. **场景初始化**：屏幕左侧是“县列表”（每个县是一个16x16的像素框，标注县号），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。背景音乐是轻快的8位旋律（比如《超级马里奥》的背景音）。  
2. **分组存储**：输入的市会“跳”进对应的县框里（比如市1属于县1，就从屏幕上方落到县1的框里），伴随“叮咚”的音效。  
3. **排序过程**：每个县框里的市像素块会“交换位置”（比如县1的框里，32和12会交换，变成12在前、32在后），交换时像素块会闪烁，伴随“哗啦”的音效。  
4. **查找排名**：每个市会有一个“箭头”指向它在县框里的位置（比如市1的年份是32，箭头指向县1框里的第二个位置），旁边显示“排名：2”，伴随“滴”的音效。  
5. **输出ID**：每个市的ID会在屏幕下方的“结果栏”里显示（比如“000001000002”），伴随“叮~”的胜利音效。


### 🎯 交互与游戏化设计  
- **单步执行**：点击“单步”按钮，可以一步步看排序和查找的过程（比如先排县1，再排县2，再找市1的位置）。  
- **自动播放**：拖动速度滑块，可以调整动画速度（比如慢到每秒1步，快到每秒10步），适合不同学习节奏。  
- **游戏化奖励**：每完成一个县的排序，会弹出“县X排序完成！”的像素提示，同时加10分（得分显示在屏幕右上角），增加成就感。


### 📢 旁白提示  
- 排序时：“现在正在给县1的市年份排序，看，32和12交换了位置，这样年份早的市就排在前面啦！”  
- 查找时：“市1的年份是32，在县1的框里排在第2位，所以它的ID后六位是000002！”  
- 输出时：“市1的ID是000001000002，对啦，前六位是县号，后六位是排名！”


## 6. 拓展练习与相似问题思考

### 🔍 通用思路/技巧迁移  
本题的“分组→排序→查找”思路，还能解决以下问题：  
- 统计每个班级的学生成绩排名（分组是班级，排序是成绩，查找是每个学生的排名）；  
- 计算每个省份的GDP增长率排名（分组是省份，排序是GDP，查找是每个省份的排名）；  
- 整理每个文件夹的文件按修改时间排序（分组是文件夹，排序是修改时间，查找是每个文件的位置）。


### 📚 练习推荐 (洛谷)  
1. **洛谷 P1093** - 《奖学金》  
   🗣️ **推荐理由**：这道题需要按成绩排序，然后计算每个学生的排名，和本题的“排序→找排名”思路完全一致，适合巩固基础。  
2. **洛谷 P1177** - 《排序》  
   🗣️ **推荐理由**：这道题是排序的基础练习，要求用不同的排序算法实现，能帮助你更深入理解`sort`的工作原理。  
3. **洛谷 P2676** - 《作业本》  
   🗣️ **推荐理由**：这道题需要分组统计每个学生的作业本数量，然后排序输出，和本题的“分组→排序”思路类似，适合拓展思维。


## 7. 学习心得与经验分享 (若有)  
本次分析的题解中未发现明确的作者个人心得分享部分，但从代码的简洁性和规范性可以看出，作者对`vector`、`sort`、`lower_bound`等STL工具的使用非常熟练。建议大家在平时练习中，多尝试用STL工具解决问题，能大大提高编码效率。


## 🎉 总结  
本次关于“[ABC113C] ID”的C++解题分析就到这里。希望这份指南能帮助你掌握“分组→排序→查找”的经典思路，学会用`vector`、`sort`、`lower_bound`解决实际问题。记住，编程的关键是“思路清晰”——先想清楚要做什么，再用代码实现！下次我们再一起探索新的编程挑战吧！💪

---
处理用时：129.22秒
# 题目信息

# [ABC307D] Mismatched Parentheses

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc307/tasks/abc307_d

英小文字および `(`, `)` からなる長さ $ N $ の文字列 $ S $ が与えられます。  
 以下の操作を可能な限り繰り返したあとの $ S $ を出力してください。

- $ S $ の連続部分文字列であって、最初の文字が `(` かつ 最後の文字が `)` かつ 最初と最後以外に `(` も `)` も含まないものを自由に $ 1 $ つ選び削除する
 
なお、操作を可能な限り繰り返したあとの $ S $ は操作の手順によらず一意に定まることが証明できます。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数である
- $ S $ は英小文字および `(`, `)` からなる長さ $ N $ の文字列である
 
### Sample Explanation 1

例えば、以下の手順により操作後の $ S $ が `ac` となります。 - $ S $ の $ 4 $ 文字目から $ 6 $ 文字目までからなる部分文字列 `(d)` を削除する。$ S $ は `a(b)c` となる。 - $ S $ の $ 2 $ 文字目から $ 4 $ 文字目までからなる部分文字列 `(b)` を削除する。$ S $ は `ac` となる。 - これ以上操作を行うことはできない。

### Sample Explanation 3

操作後の $ S $ は空文字列になる可能性があります。

## 样例 #1

### 输入

```
8

a(b(d))c```

### 输出

```
ac```

## 样例 #2

### 输入

```
5

a(b)(```

### 输出

```
a(```

## 样例 #3

### 输入

```
2

()```

### 输出

```
```

## 样例 #4

### 输入

```
6

)))(((```

### 输出

```
)))(((```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC307D] Mismatched Parentheses 深入学习指南 💡

<introduction>
  今天我们来一起分析AtCoder ABC307D这道题——《Mismatched Parentheses》（不匹配的括号）。这道题看似是处理括号，但其实藏着**栈**的经典应用！通过这道题，我们能学会如何用栈解决“删除匹配括号及内部内容”的问题，还能锻炼对字符串处理的敏感度。让我们开始吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：栈（Stack）的应用（属于“编程技巧应用”分类，侧重数据结构运用）

🗣️ **初步分析**：
> 解决这道题的关键，就像“整理书包里的书本”——我们需要把“匹配的括号对”（比如《语文书》和《数学书》放在一起）及其里面的“内容”（比如书本里的笔记）全部“拿走”，剩下的就是无法匹配的部分。而**栈**就是我们的“整理工具”：它像一个“桶”，只能从顶端放东西（入栈）或拿东西（出栈），刚好适合处理“后进先出”的括号匹配问题。  
> 在本题中，栈的作用是**记录未匹配的左括号**：当遇到左括号时，我们把它“放进桶里”；当遇到右括号时，我们检查“桶里”有没有左括号——如果有，就把“桶里”最后放的左括号及之后的内容（直到右括号）全部“倒出来”（删除）；如果没有，就把右括号也“放进桶里”（因为无法匹配）。  
> 核心难点在于：**如何正确识别并删除匹配的括号段**（比如嵌套的括号，如`(a(b))`，需要先删`(b)`再删`(a)`）。栈的“后进先出”特性刚好能解决这个问题——最后放入的左括号会先被匹配。  
> 可视化设计思路：我们可以用**8位像素风格**的“桶”（栈）来展示过程——左括号是“红色像素块”，右括号是“蓝色像素块”，普通字符是“黄色像素块”。当遇到右括号时，如果“桶”里有红色块，就从顶端开始“消去”像素块，直到遇到红色块（左括号），同时伴随“叮”的音效，模拟“删除”操作。

---

## 2. 精选优质题解参考

<eval_intro>
为了帮大家快速掌握核心思路，我从**思路清晰度、代码可读性、算法有效性**三个维度，筛选了3份评分≥4星的优质题解。这些题解都用了栈的经典解法，但实现方式略有不同，值得对比学习！
</eval_intro>

**题解一：来源：lottle1212（赞：10）**
* **点评**：这份题解的思路**像“流水账”一样直白**——用数组`st`模拟栈，`cnt`统计未匹配的左括号数量。遇到左括号就“入栈+计数”，遇到右括号就“检查计数→如果有就出栈直到左括号→减少计数”，普通字符直接入栈。代码中的变量名（`st`代表栈，`cnt`代表左括号数量）非常明确，逻辑一步到位，甚至能“一眼看出”每个步骤的作用。比如`while (st[top] != '(') --top;`这行代码，就是“从栈顶往下找，直到找到左括号”，完美对应“删除匹配括号段”的需求。从实践角度看，这份代码**可以直接用于竞赛**，因为它的时间复杂度是O(n)（每个字符最多入栈和出栈各一次），完全符合题目要求的2×10⁵数据规模。

**题解二：来源：xht（赞：3）**
* **点评**：这份题解的代码**更简洁**——用`string ans`直接模拟栈（`ans.pb()`是入栈，`ans.pop_back()`是出栈）。比如遇到右括号时，`while (ans.back() != '(') ans.pop_back();`这行代码，就是“从ans的末尾开始删，直到删到左括号”，然后再删左括号（`ans.pop_back()`）。这种写法省去了单独的栈数组，用string的特性简化了代码，非常适合**快速编码**。同时，变量`c`统计未匹配的左括号数量，逻辑和题解一完全一致，但代码行数更少，可读性也很高。

**题解三：来源：syzxzqy（赞：0）**
* **点评**：这份题解的代码**用手动模拟栈**（数组`a`存储栈元素，`t`表示栈顶位置），思路和前两份题解一致，但更贴近“栈的底层实现”。比如`a[++t] = s[i];`就是“入栈”，`t--;`就是“出栈”。这种写法能让我们更清楚地理解栈的工作原理——栈其实就是一个“有顶指针的数组”。同时，变量`k`统计未匹配的左括号数量，逻辑正确，代码结构工整，适合**初学者理解栈的本质**。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，很多同学会遇到“不知道如何处理嵌套括号”“删错字符”等问题。结合优质题解的共性，我提炼了3个核心难点及解决策略，帮大家“避坑”！
</difficulty_intro>

1.  **难点1：如何正确匹配嵌套的括号？（比如`(a(b))`）**
    * **分析**：嵌套括号的特点是“内层括号先匹配”（比如`(b)`先被删，再删`(a)`）。栈的“后进先出”特性刚好能解决这个问题——最后放入的左括号（比如`(b`的`(`）会先被右括号匹配。比如题解一中的`while (st[top] != '(') --top;`，就是从栈顶往下找，找到最后放入的左括号，然后删除它及之后的内容。
    * 💡 **学习笔记**：栈是处理嵌套结构的“神器”，因为它能记住“最后一次”的操作。

2.  **难点2：如何处理非括号字符？（比如`a(b)c`中的`a`、`b`、`c`）**
    * **分析**：非括号字符不需要参与匹配，直接“入栈”即可。比如题解二中的`else ans.pb(s[i]);`，就是把普通字符加入栈（`ans`字符串）。当遇到匹配的括号时，这些非括号字符会和括号一起被“出栈”（删除）。
    * 💡 **学习笔记**：非括号字符是“旁观者”，只需跟着括号一起“进栈”或“出栈”。

3.  **难点3：如何高效删除匹配的括号段？（避免O(n²)时间复杂度）**
    * **分析**：如果直接用`string::erase()`删除子串（比如PineappleSummer的题解），会导致O(n²)的时间复杂度（因为每次删除都要移动后面的字符），对于2×10⁵的数据规模来说会超时。而用栈模拟的方法，每个字符最多入栈和出栈各一次，时间复杂度是O(n)，非常高效。比如题解一中的`st`数组，入栈是`st[++top] = s[i];`，出栈是`--top;`，都是O(1)操作。
    * 💡 **学习笔记**：栈模拟是处理“删除连续子串”问题的高效方法，避免了频繁移动字符。

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个通用的解题技巧，帮大家“举一反三”：
</summary_best_practices>
-   **技巧1：用栈处理括号匹配问题**：栈是括号匹配的“标准工具”，无论是判断括号是否合法，还是删除匹配括号，都可以用栈解决。
-   **技巧2：用string模拟栈**：string的`push_back()`（入栈）和`pop_back()`（出栈）操作非常方便，能简化代码（比如题解二）。
-   **技巧3：统计未匹配的左括号数量**：用一个变量（比如`cnt`）统计未匹配的左括号数量，能快速判断是否有右括号可以匹配（比如`if (cnt > 0)`）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解之前，我们先来看一个**通用的核心C++实现**。这个实现综合了优质题解的思路，用string模拟栈，代码简洁高效，适合快速理解！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解二（xht）的优化，用string模拟栈，逻辑清晰，代码行数少，适合竞赛使用。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        int n;
        string s, ans;
        cin >> n >> s;
        int cnt = 0; // 未匹配的左括号数量
        for (char c : s) {
            if (c == '(') {
                ans.push_back(c);
                cnt++;
            } else if (c == ')') {
                if (cnt > 0) {
                    // 删到左括号
                    while (ans.back() != '(') {
                        ans.pop_back();
                    }
                    ans.pop_back(); // 删左括号
                    cnt--;
                } else {
                    ans.push_back(c);
                }
            } else {
                ans.push_back(c);
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 这段代码的核心逻辑是**用string`ans`模拟栈**：  
    > 1. 读取输入字符串`s`。  
    > 2. 遍历`s`中的每个字符：  
    >    - 如果是左括号，就加入`ans`（入栈），并增加`cnt`（未匹配左括号数量）。  
    >    - 如果是右括号，检查`cnt`是否大于0（有没有未匹配的左括号）：  
    >      - 如果有，就从`ans`的末尾开始删（出栈），直到删到左括号，然后再删左括号（匹配成功），并减少`cnt`。  
    >      - 如果没有，就把右括号加入`ans`（无法匹配）。  
    >    - 如果是普通字符，直接加入`ans`（入栈）。  
    > 3. 输出`ans`（剩下的无法匹配的字符）。

---
<code_intro_selected>
接下来，我们逐一剖析优质题解中的核心代码片段，看看它们的“亮点”在哪里！
</code_intro_selected>

**题解一：来源：lottle1212**
* **亮点**：用数组模拟栈，变量名明确，逻辑一步到位。
* **核心代码片段**：
    ```cpp
    char st[200010], s[200010]; // st是栈，s是原字符串
    int top = 0, cnt = 0; // top是栈顶指针，cnt是未匹配左括号数量
    for (int i = 1; i <= n; ++i) {
        if (s[i] == '(') {
            st[++top] = '(', ++cnt; // 入栈+计数
        } else if (s[i] == ')' && cnt) {
            while (st[top] != '(') --top; // 删到左括号
            --top, --cnt; // 删左括号+减少计数
        } else {
            st[++top] = s[i]; // 普通字符/无法匹配的右括号入栈
        }
    }
    ```
* **代码解读**：
    > 这段代码用数组`st`模拟栈，`top`表示栈顶位置（初始为0）。比如`st[++top] = '('`就是“把`(`放入栈顶”（入栈），`--top`就是“把栈顶元素删掉”（出栈）。`cnt`统计未匹配的左括号数量，当遇到右括号时，`if (cnt)`判断是否有左括号可以匹配——如果有，就用`while`循环从栈顶往下找，直到找到左括号（`st[top] != '('`），然后删左括号（`--top`）并减少`cnt`（`--cnt`）。这种写法非常直观，适合初学者理解栈的“底层操作”。
* 💡 **学习笔记**：数组模拟栈是最基础的写法，变量名要明确（比如`st`代表栈，`top`代表栈顶）。

**题解二：来源：xht**
* **亮点**：用string模拟栈，代码简洁，省去了数组和栈顶指针。
* **核心代码片段**：
    ```cpp
    string ans;
    int cnt = 0;
    for (char c : s) {
        if (c == '(') {
            ans.push_back(c);
            cnt++;
        } else if (c == ')') {
            if (cnt) {
                while (ans.back() != '(') ans.pop_back();
                ans.pop_back();
                cnt--;
            } else {
                ans.push_back(c);
            }
        } else {
            ans.push_back(c);
        }
    }
    ```
* **代码解读**：
    > 这段代码用`string ans`模拟栈，`ans.push_back(c)`是“入栈”，`ans.pop_back()`是“出栈”。比如遇到右括号时，`while (ans.back() != '(') ans.pop_back();`就是“从ans的末尾开始删，直到删到左括号”，然后`ans.pop_back()`删左括号。这种写法省去了数组和栈顶指针，代码更简洁，适合**快速编码**。
* 💡 **学习笔记**：string的`push_back()`和`pop_back()`操作是模拟栈的“神器”，能简化代码。

**题解三：来源：syzxzqy**
* **亮点**：用手动模拟栈，更贴近栈的本质。
* **核心代码片段**：
    ```cpp
    char a[N], s[N]; // a是栈，s是原字符串
    int t = 0, k = 0; // t是栈顶位置，k是未匹配左括号数量
    for (int i = 1; i <= n; ++i) {
        if (s[i] == ')' && k > 0) {
            while (a[t] != '(') t--; // 删到左括号
            t--; k--; // 删左括号+减少计数
        } else {
            if (s[i] == '(') k++; // 左括号计数
            a[++t] = s[i]; // 入栈
        }
    }
    ```
* **代码解读**：
    > 这段代码用数组`a`模拟栈，`t`表示栈顶位置（初始为0）。`a[++t] = s[i]`是“入栈”（把`s[i]`放入栈顶），`t--`是“出栈”（把栈顶元素删掉）。`k`统计未匹配的左括号数量，当遇到右括号时，`if (k > 0)`判断是否有左括号可以匹配——如果有，就用`while`循环从栈顶往下找，直到找到左括号（`a[t] != '('`），然后删左括号（`t--`）并减少`k`（`k--`）。这种写法能让我们更清楚地理解栈的“工作原理”——栈其实就是一个“有顶指针的数组”。
* 💡 **学习笔记**：手动模拟栈能帮我们更深入地理解栈的本质，适合初学者打基础。

---

## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了更直观地理解“栈处理括号匹配”的过程，我设计了一个**8位像素风格的动画**，像玩FC游戏一样展示算法的每一步！让我们一起看看吧！
\</visualization\_intro\>

  * **动画演示主题**：《像素括号整理师》（Pixel Bracket Organizer）
  * **核心演示内容**：展示栈如何处理字符串`a(b(d))c`（样例1），逐步删除匹配的括号段，最终得到`ac`。
  * **设计思路简述**：采用8位像素风格（类似《超级马里奥》的画面），用“桶”（栈）来展示字符的入栈和出栈过程。普通字符是“黄色像素块”，左括号是“红色像素块”，右括号是“蓝色像素块”。当匹配成功时，伴随“叮”的音效，模拟“删除”操作，增加趣味性。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
          * 屏幕左侧显示一个“像素桶”（栈），右侧显示输入字符串`a(b(d))c`（每个字符是一个像素块）。
          * 控制面板有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块（1x~5x）。
          * 8位风格的背景音乐（类似《坦克大战》的BGM）开始播放。
    2.  **字符入栈过程**：
          * 遍历字符串`a(b(d))c`：
            - 第一个字符是`a`（黄色像素块），“跳进”桶里（入栈），伴随“啪”的音效。
            - 第二个字符是`(`（红色像素块），“跳进”桶里，伴随“叮”的音效，`cnt`（未匹配左括号数量）变为1。
            - 第三个字符是`b`（黄色像素块），“跳进”桶里。
            - 第四个字符是`(`（红色像素块），“跳进”桶里，`cnt`变为2。
            - 第五个字符是`d`（黄色像素块），“跳进”桶里。
            - 第六个字符是`)`（蓝色像素块），此时`cnt`是2（有未匹配的左括号）：
              - 桶里的`d`（黄色）、`(`（红色）依次“跳出来”（出栈），伴随“叮”的音效。
              - `cnt`变为1。
            - 第七个字符是`)`（蓝色像素块），此时`cnt`是1：
              - 桶里的`b`（黄色）、`(`（红色）依次“跳出来”，伴随“叮”的音效。
              - `cnt`变为0。
            - 第八个字符是`c`（黄色像素块），“跳进”桶里。
    3.  **结果展示**：
          * 桶里剩下的字符是`a`（黄色）和`c`（黄色），组成`ac`（样例1的输出）。
          * 播放“胜利”音效（类似《魂斗罗》的通关音乐），屏幕显示“任务完成！”的像素文字。
    4.  **交互功能**：
          * 单步执行：点击“单步”按钮，动画走一步，显示当前字符的处理过程。
          * 自动播放：点击“开始”按钮，动画按设置的速度自动播放。
          * 重置：点击“重置”按钮，回到初始状态，重新开始。

  * **旁白提示**：
      * （处理`(`时）“红色块是左括号，放进桶里，记下来！”
      * （处理`)`时）“蓝色块是右括号，看看桶里有没有红色块？有！那把后面的块都倒出来！”
      * （匹配成功时）“叮！匹配成功，这部分删掉啦！”

\<visualization\_conclusion\>
通过这个像素动画，我们能**直观看到栈的工作过程**——左括号入栈，右括号匹配时出栈，普通字符跟着走。是不是像玩游戏一样有趣？赶紧试试吧！
\</visualization\_conclusion\>

---

## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了栈处理括号匹配的方法后，我们可以尝试解决更多类似问题，比如“判断括号是否合法”“计算括号的深度”等。下面是几道洛谷上的练习推荐，帮大家巩固知识点！
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：
      * 栈不仅能解决“删除匹配括号”问题，还能解决：
        1. 判断括号是否合法（比如LeetCode 20题：有效的括号）；
        2. 计算括号的深度（比如洛谷P1739题：表达式括号匹配）；
        3. 处理嵌套结构（比如HTML标签的匹配）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1739** - 《表达式括号匹配》
          * 🗣️ **推荐理由**：这道题是“判断括号是否合法”的经典题，用栈就能解决。通过这道题，你能巩固“栈处理括号匹配”的基础。
    2.  **洛谷 P2659** - 《美丽的天堂》
          * 🗣️ **推荐理由**：这道题需要处理“嵌套的括号”，计算括号的深度。用栈统计括号的深度，能帮你更熟练地运用栈。
    3.  **洛谷 P3375** - 《KMP字符串匹配》（拓展）
          * 🗣️ **推荐理由**：虽然这道题是字符串匹配，但KMP算法中的“部分匹配表”（Next数组）也用到了栈的思想。通过这道题，你能拓展对栈的应用理解。

---

## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
在分析题解时，我发现很多作者都提到了“栈是括号匹配的标准工具”，还有作者分享了“避免用erase()函数”的经验。这些心得对我们很有帮助！
\</insights\_intro\>

> **参考经验 (来自lottle1212)**：“我一开始想用string的erase()函数删除子串，但后来发现对于大数据来说，erase()的时间复杂度太高了，会超时。于是我改用栈模拟，这样每个字符最多入栈和出栈各一次，时间复杂度是O(n)，就通过了。”
>
> **点评**：这位作者的经验很重要！在处理大字符串时，频繁使用erase()函数会导致时间复杂度飙升（因为每次erase()都要移动后面的字符）。而用栈模拟的方法，能避免这个问题，是处理“删除连续子串”问题的高效方法。

---

\<conclusion\>
本次关于ABC307D的分析就到这里啦！通过这道题，我们学会了用栈解决“删除匹配括号及内部内容”的问题，还掌握了栈的经典应用。记住：**栈是处理嵌套结构的“神器”**，下次遇到类似问题，不妨试试栈吧！  
如果有不懂的地方，欢迎随时问我——Kay会一直帮你哦！💪
\</conclusion\>

---
处理用时：802.63秒
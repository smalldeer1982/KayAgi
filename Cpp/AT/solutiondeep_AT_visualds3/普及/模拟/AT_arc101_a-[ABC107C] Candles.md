# 题目信息

# [ABC107C] Candles

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc107/tasks/arc101_a

数直線上に $ N $ 本のろうそくが置かれています。 左から $ i $ 番目のろうそくは座標 $ x_i $ に置かれています。 ただし、$ x_1\ <\ x_2\ <\ ...\ <\ x_N $ が成り立ちます。

最初、どのろうそくにも火が付いていません。 すぬけ君は、$ N $ 本のうち $ K $ 本のろうそくに火を付けることにしました。

今、すぬけ君は座標 $ 0 $ にいます。 すぬけ君は、数直線上を左右に速度 $ 1 $ で移動することができます。 また、自分と同じ座標のろうそくに火を付けることができます。 このとき、火を付けるのに掛かる時間は無視できます。

$ K $ 本のろうそくに火を付けるのに必要な最小の時間を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ K\ \leq\ N $
- $ x_i $ は整数である。
- $ |x_i|\ \leq\ 10^8 $
- $ x_1\ <\ x_2\ <\ ...\ <\ x_N $

### Sample Explanation 1

次のように移動しながらろうそくに火を付ければよいです。 - 座標 $ 0 $ から $ -10 $ へ移動する。 - 左から $ 2 $ 番目のろうそくに火を付ける。 - 座標 $ -10 $ から $ 10 $ へ移動する。 - 左から $ 3 $ 番目のろうそくに火を付ける。 - 座標 $ 10 $ から $ 20 $ へ移動する。 - 左から $ 4 $ 番目のろうそくに火を付ける。

### Sample Explanation 3

座標 $ 0 $ にろうそくが置かれていることもあります。

## 样例 #1

### 输入

```
5 3

-30 -10 10 20 50```

### 输出

```
40```

## 样例 #2

### 输入

```
3 2

10 20 30```

### 输出

```
20```

## 样例 #3

### 输入

```
1 1

0```

### 输出

```
0```

## 样例 #4

### 输入

```
8 5

-9 -7 -4 -3 1 2 3 4```

### 输出

```
10```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC107C] Candles 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举+贪心（连续区间选择）  

🗣️ **初步分析**：  
解决“Candles”问题的关键，在于**选择连续的K根蜡烛**——这是贪心策略的核心。想象一下，如果你要去超市买东西，肯定会先逛完一排货架再去另一排，而不是跳着选，因为跳着选会多走回头路。本题同理：如果选择非连续的蜡烛，中间跳过的蜡烛其实已经经过，何不先点燃它？这样能减少重复移动的距离。  

**核心思路**：  
1. **枚举所有连续K根蜡烛的区间**（因为数组`x`单调递增，区间左端点为`i`，右端点为`i+K-1`）；  
2. **计算每个区间的最小时间**：从原点出发，先走到区间离原点更近的端点（左或右），再走到另一个端点，总时间为`min(abs(左端点), abs(右端点)) + (右端点 - 左端点)`（右端点-左端点是区间长度，必为正）；  
3. **取所有区间的最小时间**。  

**可视化设计思路**：  
用8位像素风格展示数轴（类似FC游戏画面）：  
- 原点用**红色像素点**标记，蜡烛用**蓝色像素点**；  
- 枚举区间时，当前区间的蜡烛会**变黄高亮**；  
- 用**绿色线条**动画展示走法（比如先走到左端点再走到右端点），同时在屏幕上方显示当前区间的时间；  
- 找到更小值时，屏幕会**闪烁提示**，并播放“叮”的像素音效。  


## 2. 精选优质题解参考

### 题解一（来源：run_away）  
* **点评**：  
  这份题解的亮点是**归纳统一公式**。作者分三种情况（全正、全负、有正有负）讨论，最终总结出通用计算公式`x[j]-x[i] + min(abs(x[i]), abs(x[j]))`，简化了代码逻辑。代码使用快速读入模板（适合大数据），变量名清晰（`x`数组存蜡烛坐标，`ans`存最小值），非常符合竞赛风格。  

### 题解二（来源：Kyl_in_2024）  
* **点评**：  
  作者用**反证法**证明了“连续区间最优”的结论（如果不连续，中间的蜡烛已经经过，何不先点燃？），思路直观易懂。代码极其简洁（仅15行），但需注意**数据范围**：`ans`应使用`long long`（否则可能溢出）。这种“用简单逻辑说服自己”的思考方式，值得学习者借鉴。  

### 题解三（来源：RioFutaba）  
* **点评**：  
  代码规范且简洁（用`const`定义数组大小，`scanf/printf`输入输出），变量名`maxn`（最大数组大小）、`INF`（极大值）符合常规编程习惯。作者明确指出“最佳操作是点燃区间蜡烛”，直接点出问题核心，适合初学者快速理解。  


## 3. 核心难点辨析与解题策略

### 1. 为什么选择连续的K根蜡烛？  
* **分析**：  
  假设选择非连续的蜡烛（比如`i`和`i+2`），那么中间的`i+1`蜡烛已经被经过。如果先点燃`i+1`，再去`i+2`，总距离会比跳过`i+1`更短（少走`i+2 - (i+1)`的距离）。因此，**连续区间是最优选择**。  
* 💡 **学习笔记**：贪心问题常需用反证法证明策略的正确性。  

### 2. 如何计算每个区间的最小时间？  
* **分析**：  
  每个区间有两种走法：  
  - 先走到左端点（`abs(x[i])`），再走到右端点（`x[j]-x[i]`），总时间`abs(x[i]) + (x[j]-x[i])`；  
  - 先走到右端点（`abs(x[j])`），再走到左端点（`x[j]-x[i]`），总时间`abs(x[j]) + (x[j]-x[i])`。  
  取最小值即为`min(abs(x[i]), abs(x[j])) + (x[j]-x[i])`。  
* 💡 **学习笔记**：将两种情况合并为一个公式，能简化代码。  

### 3. 如何处理边界情况（全正、全负、包含原点）？  
* **分析**：  
  - 全正：`x[i]`和`x[j]`都是正数，`min(abs(x[i]), abs(x[j])) = x[i]`，总时间`x[i] + (x[j]-x[i]) = x[j]`（正确，因为从原点走到右端点即可）；  
  - 全负：`x[i]`和`x[j]`都是负数，`min(abs(x[i]), abs(x[j])) = -x[j]`（因为`x[j] >= x[i]`，所以`-x[j] <= -x[i]`），总时间`-x[j] + (x[j]-x[i]) = -x[i]`（正确，因为从原点走到左端点即可）；  
  - 包含原点：比如`x[i]`负、`x[j]`正，`min(abs(x[i]), abs(x[j]))`是较小的那个，总时间为较小值加上区间长度（正确，比如样例1中`x[i]=-10`，`x[j]=20`，`min(10,20)=10`，总时间`10 + 30=40`）。  
* 💡 **学习笔记**：统一公式能覆盖所有边界情况，无需额外判断。  

### ✨ 解题技巧总结  
- **贪心策略**：选择连续区间，减少重复移动；  
- **公式合并**：将多种情况合并为一个公式，简化代码；  
- **数据范围**：使用`long long`存储时间（避免溢出）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合优质题解的思路，提供一个清晰、完整的核心实现（使用`long long`避免溢出）。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <climits>
  using namespace std;

  int main() {
      int n, k;
      cin >> n >> k;
      vector<long long> x(n);
      for (int i = 0; i < n; ++i) {
          cin >> x[i];
      }

      long long ans = LLONG_MAX;
      for (int i = 0; i + k <= n; ++i) {
          int j = i + k - 1;
          long long left = x[i];
          long long right = x[j];
          long long time = min(abs(left), abs(right)) + (right - left);
          if (time < ans) {
              ans = time;
          }
      }

      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. 输入`n`（蜡烛数量）和`k`（需要点燃的数量）；  
  2. 输入蜡烛坐标到`x`数组；  
  3. 枚举所有连续`k`根蜡烛的区间（`i`从0到`n-k`）；  
  4. 计算当前区间的时间（用统一公式）；  
  5. 更新最小值`ans`；  
  6. 输出`ans`。  

### 针对各优质题解的片段赏析  

#### 题解一（来源：run_away）  
* **亮点**：快速读入模板（适合大数据）。  
* **核心代码片段**：  
  ```cpp
  inline ll read(){ll x=0,f=1;char c=getchar();while(c<48||c>57){if(c==45)f=0;c=getchar();}while(c>47&&c<58)x=(x<<3)+(x<<1)+(c^48),c=getchar();return f?x:-x;}
  ```  
* **代码解读**：  
  这是一个快速读入函数，用于读取大整数（比如`1e5`个蜡烛坐标）。`getchar()`比`cin`快，`(x<<3)+(x<<1)`等价于`x*10`，`(c^48)`将字符转换为数字。  
* 💡 **学习笔记**：竞赛中处理大数据时，快速读入能节省时间。  

#### 题解二（来源：Kyl_in_2024）  
* **亮点**：反证法思路（证明连续区间最优）。  
* **核心代码片段**：  
  ```cpp
  for(int i=1;i+k-1<=n;i++){
      int l=x[i],r=x[i+k-1];
      ans=min(ans,min(abs(l),abs(r))+abs(l-r));
  }
  ```  
* **代码解读**：  
  作者用`abs(l-r)`代替`r-l`（因为`r >= l`，所以`abs(l-r) = r-l`），逻辑正确但更通用。需注意`ans`应定义为`long long`（比如`int ans=2147483647`会溢出）。  
* 💡 **学习笔记**：写代码时要注意数据范围，避免溢出。  

#### 题解三（来源：RioFutaba）  
* **亮点**：代码规范（用`const`定义数组大小）。  
* **核心代码片段**：  
  ```cpp
  const int maxn=1e5+5,INF=0x3f3f3f3f;
  int n,k,x[maxn],ans=INF;
  ```  
* **代码解读**：  
  `const int maxn=1e5+5`定义了数组的最大大小（1e5+5），`INF=0x3f3f3f3f`是一个极大值（约2e9）。这种写法符合常规编程习惯，便于维护。  
* 💡 **学习笔记**：使用`const`定义常量，能提高代码的可读性和可维护性。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：数轴探险家  
**风格**：8位像素风（类似FC游戏《超级马里奥》的画面），使用红、蓝、黄、绿四种颜色（符合8位色调色板）。  

### 📊 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示**数轴**（水平方向），原点用**红色像素点**（坐标0）标记；  
   - 蜡烛用**蓝色像素点**标记，按输入顺序排列（比如样例1中的`-30`、`-10`、`10`、`20`、`50`）；  
   - 屏幕上方显示**当前最小值**（初始为`INF`），下方显示**控制面板**（单步、自动播放、重置按钮，速度滑块）。  

2. **枚举区间动画**：  
   - 当枚举到第`i`个区间（比如样例1中的`i=1`，`j=3`，对应蜡烛`-10`、`10`、`20`），该区间的蜡烛会**变黄高亮**；  
   - 用**绿色线条**动画展示走法：从原点（红）走到左端点（黄），再走到右端点（黄），线条会逐渐延伸（模拟移动过程）；  
   - 移动过程中，屏幕上方显示当前区间的时间（比如`10 + 30 = 40`）。  

3. **更新最小值动画**：  
   - 如果当前区间的时间比`ans`小，`ans`会**闪烁**（比如从`INF`变成`40`），并播放“叮”的像素音效（类似《吃豆人》的得分声）。  

4. **结束状态**：  
   - 所有区间枚举完毕，屏幕中央显示**最小时间**（比如样例1中的`40`），并播放“胜利”音效（类似《超级马里奥》的通关声）；  
   - 蜡烛会**集体闪烁**（蓝色→黄色→蓝色），庆祝成功。  

### 🎮 交互设计  
- **单步执行**：按**空格**键，枚举下一个区间；  
- **自动播放**：拖动**速度滑块**（1x~5x），动画会自动播放；  
- **重置**：按**R**键，回到初始状态；  
- **算法比较**（可选）：如果有多种思路（比如分正负方向），可以并排演示两种算法的差异。  

### 🎵 音效设计  
- **枚举区间**：“滴答”声（每枚举一个区间播放一次）；  
- **计算时间**：“叮”声（每计算一个区间的时间播放一次）；  
- **更新最小值**：“叮~”声（比计算时间的声音更长）；  
- **胜利**：“哇哦~”声（8位风格，类似《超级马里奥》的通关声）。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
枚举连续区间的策略，可用于解决以下问题：  
1. **排队接水**（P1223）：选择连续的人，使总等待时间最小；  
2. **合并果子**（P1090）：选择连续的果子堆，使总合并成本最小；  
3. **数轴点覆盖**（比如LeetCode 1283）：选择连续的点，覆盖所有需求。  

### 📚 洛谷练习推荐  
1. **洛谷 P1223 排队接水**  
   - 🗣️ **推荐理由**：这道题需要选择连续的人，使总等待时间最小，与本题的“连续区间选择”思路一致，能巩固贪心策略的应用。  
2. **洛谷 P1090 合并果子**  
   - 🗣️ **推荐理由**：虽然需要用优先队列，但核心思路是选择连续的果子堆，使总合并成本最小，能拓展对贪心问题的理解。  
3. **洛谷 P2089 烤鸡**  
   - 🗣️ **推荐理由**：需要枚举所有可能的调料组合，虽然不是连续区间，但也是枚举的思想，能锻炼枚举能力。  
4. **洛谷 P1164 小A点菜**  
   - 🗣️ **推荐理由**：动态规划问题，但需要枚举所有可能的菜组合，类似枚举的思想，能拓展解题思路。  


## 7. 学习心得与经验分享 (若有)

### 📝 来自题解的经验分享  
- **Kyl_in_2024**：“如果最终答案不连续，中间不连续的开关肯定已经经过了，那么何不先把它按了然后少走几步呢？”  
  * **点评**：这个反证法的思路非常直观，帮助我们理解为什么“连续区间最优”。在解决贪心问题时，经常需要用这种“假设不成立”的逻辑说服自己。  
- **run_away**：“所选的K个点应该是连续的。”  
  * **点评**：这是本题的核心结论，记住这个结论可以快速解决类似的数轴问题（比如“选择K个点，使移动距离最小”）。  
- **RioFutaba**：“最佳的操作应该是点燃一个区间的蜡烛，即先跑到这个区间离自己最近的端点，再跑到另一个端点。”  
  * **点评**：这个结论总结了本题的走法，帮助我们快速计算每个区间的最小时间，避免了复杂的分类讨论。  


## 🎉 结语  
本次关于“[ABC107C] Candles”的分析就到这里。希望这份指南能帮助你理解**枚举+贪心**的核心思路，掌握连续区间选择的策略。记住：**贪心问题的关键是找到“最优子结构”，并用反证法证明策略的正确性**。下次遇到类似的数轴问题，不妨试试今天学的方法——枚举连续区间，计算最小时间！  

加油，你一定能成为更好的程序员！💪

---
处理用时：186.06秒
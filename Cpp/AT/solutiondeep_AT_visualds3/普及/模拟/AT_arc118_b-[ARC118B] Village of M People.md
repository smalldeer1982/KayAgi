# 题目信息

# [ARC118B] Village of M People

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc118/tasks/arc118_b

ARC 国には $ N $ 人の国民がおり、全国民が競技プログラミングのプレイヤーです。各国民にはその競技プログラミングの実力によって、$ 1,\ 2,\ \ldots,\ K $ のいずれかひとつの段位が与えられています。

ARC 国では国勢調査が行われて、その結果、段位 $ i $ の国民はちょうど $ A_i $ 人居ることが分かりました。ARC 国の国王はこの統計データをより理解しやすい形にするために、なるべく各段位の人数の割合を保ったまま、ARC 国の状況を $ M $ 人の村に例えることにしました。

$ M $ 人の村における段位 $ i $ の村民の人数 $ B_i $ を上手く定めることで、$ \max_i\left|\frac{B_i}{M}\ -\ \frac{A_i}{N}\right| $ を最小にしてください。ただし、次が成り立つ必要があります。

- 各 $ B_i $ は非負整数で、$ \sum_{i=1}^K\ B_i\ =\ M $ を満たす

そのような $ B\ =\ (B_1,\ B_2,\ \ldots,\ B_K) $ の定め方を、ひとつ出力してください。

## 说明/提示

### 制約

- $ 1\leq\ K\leq\ 10^5 $
- $ 1\leq\ N,\ M\leq\ 10^9 $
- 各 $ A_i $ は非負整数で、$ \sum_{i=1}^K\ A_i\ =\ N $ を満たす

### Sample Explanation 1

この出力において、$ \max_i\left|\frac{B_i}{M}\ -\ \frac{A_i}{N}\right|\ =\ \max\left(\left|\frac{3}{20}-\frac{1}{7}\right|,\ \left|\frac{6}{20}-\frac{2}{7}\right|,\ \left|\frac{11}{20}-\frac{4}{7}\right|\right)\ =\ \max\left(\frac{1}{140},\ \frac{1}{70},\ \frac{3}{140}\right)\ =\ \frac{3}{140} $ となっています。

### Sample Explanation 2

和を $ M\ =\ 100 $ にしなければならないので、$ B_1\ =\ B_2\ =\ B_3\ =\ 33 $ では 条件が満たされないことに注意してください。 なおこの例においては、`34 33 33` の他、`33 34 33` や `33 33 34` という出力も正解となります。

## 样例 #1

### 输入

```
3 7 20

1 2 4```

### 输出

```
3 6 11```

## 样例 #2

### 输入

```
3 3 100

1 1 1```

### 输出

```
34 33 33```

## 样例 #3

### 输入

```
6 10006 10

10000 3 2 1 0 0```

### 输出

```
10 0 0 0 0 0```

## 样例 #4

### 输入

```
7 78314 1000

53515 10620 7271 3817 1910 956 225```

### 输出

```
683 136 93 49 24 12 3```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC118B] Village of M People 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案 + 贪心构造  

🗣️ **初步分析**：  
解决“Village of M People”的关键，在于将“最小化各段位比例差的最大值”转化为**二分答案问题**。简单来说，二分答案就像“猜数字游戏”——我们猜测一个可能的“最大误差”，然后验证这个误差是否可行。如果可行，就尝试更小的误差；如果不可行，就增大误差。直到找到最小的可行误差。  

在本题中，我们需要最小化 \( \max_i\left|\frac{B_i}{M} - \frac{A_i}{N}\right| \)。通过数学转化，这个式子等价于最小化 \( \max_i\left|NB_i - MA_i\right| \)（两边乘以 \( NM \)，不改变最大值的位置）。于是，问题转化为：寻找最小的 \( x \)，使得存在非负整数 \( B_i \)，满足 \( \sum B_i = M \) 且 \( |NB_i - MA_i| \leq x \) 对所有 \( i \) 成立。  

**核心算法流程**：  
1. **二分答案**：确定 \( x \) 的可能范围（从0到 \( NM \)），通过二分查找找到最小的可行 \( x \)。  
2. **验证可行性**（check函数）：对于当前 \( x \)，计算每个 \( B_i \) 的合法范围 \( [L_i, R_i] \)（\( L_i = \lceil \frac{MA_i - x}{N} \rceil \)，\( R_i = \lfloor \frac{MA_i + x}{N} \rfloor \)），并检查所有 \( L_i \) 的和是否 ≤ M，且所有 \( R_i \) 的和是否 ≥ M（确保存在可行解）。  
3. **贪心构造**：找到可行的 \( x \) 后，先将每个 \( B_i \) 设为 \( L_i \)，然后逐步将剩余的“名额”（\( M - \sum L_i \)）分配给各个 \( B_i \)，直到用完——每次尽量给当前 \( B_i \) 增加最多的量（不超过 \( R_i - L_i \)）。  

**可视化设计思路**：  
我们可以用**8位像素风**展示算法过程：  
- 用不同颜色的像素块表示每个 \( B_i \) 的当前值（比如蓝色表示 \( L_i \)，绿色表示可增加的范围）。  
- 二分过程中，屏幕上方显示当前猜测的 \( x \)，下方动态更新每个 \( B_i \) 的范围（比如范围缩小时光标闪烁）。  
- 构造阶段，用“像素箭头”指向正在增加的 \( B_i \)，伴随“叮”的音效（每增加1个名额），直到总和达到M。  
- 成功时，所有像素块变成金色，播放胜利音效（比如FC游戏的“通关声”）。  


## 2. 精选优质题解参考

**题解一：来源：loser_seele（赞：1）**  
* **点评**：  
  这份题解的**思路清晰度**极高——将原问题转化为二分答案的过程逻辑严密，数学推导（如 \( |NB_i - MA_i| \leq x \) 的转化）解释得很透彻。**代码规范性**方面，变量名（如 \( l[i] \) 表示 \( B_i \) 的下界，\( r[i] \) 表示上界）含义明确，结构工整（二分框架+check函数+构造步骤）。**算法有效性**上，时间复杂度 \( O(K\log NM) \) 完全符合题目约束（\( K \leq 10^5 \)），且贪心构造的正确性有保证（优先填满可增加的范围，确保总和刚好为M）。**实践价值**很高——代码可以直接用于竞赛，边界处理（如 \( L_i \) 取非负）非常严谨。  

  其**亮点**在于**问题转化的巧妙性**：通过数学变形将比例差的最大值问题转化为绝对值问题，从而能用二分答案解决。这是解决此类“最小化最大值”问题的常用技巧，值得重点学习。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何将原问题转化为二分答案的条件？**  
* **分析**：  
  原问题要求最小化 \( \max_i\left|\frac{B_i}{M} - \frac{A_i}{N}\right| \)，直接处理这个式子比较困难。题解通过乘以 \( NM \)（正数，不改变最大值的位置），将其转化为最小化 \( \max_i\left|NB_i - MA_i\right| \)。这一步是关键——它将“比例差”转化为“绝对差”，从而可以用二分答案来寻找最小的 \( x \)（即这个绝对差的最大值）。  
* 💡 **学习笔记**：  
  遇到“最小化最大值”或“最大化最小值”的问题时，优先考虑**二分答案**，并尝试将问题转化为“是否存在解满足某个条件”。  


### 2. **关键点2：如何正确计算 \( B_i \) 的合法范围？**  
* **分析**：  
  对于每个 \( i \)，\( |NB_i - MA_i| \leq x \) 等价于 \( MA_i - x \leq NB_i \leq MA_i + x \)。由于 \( B_i \) 是整数，需要对边界进行取整：  
  - 下界 \( L_i = \lceil \frac{MA_i - x}{N} \rceil \)（向上取整，确保 \( NB_i \geq MA_i - x \)）；  
  - 上界 \( R_i = \lfloor \frac{MA_i + x}{N} \rfloor \)（向下取整，确保 \( NB_i \leq MA_i + x \)）。  
  同时，\( L_i \) 不能小于0（因为 \( B_i \) 是非负整数）。  
* 💡 **学习笔记**：  
  处理整数范围时，一定要注意**取整方向**——向上取整用 \( (a + b - 1) / b \)，向下取整用 \( a / b \)（C++中整数除法默认向下取整）。  


### 3. **关键点3：如何贪心构造满足条件的 \( B_i \)？**  
* **分析**：  
  找到可行的 \( x \) 后，先将每个 \( B_i \) 设为下界 \( L_i \)，此时总和为 \( suml = \sum L_i \)。剩余的名额是 \( rem = M - suml \)（因为 \( suml \leq M \leq sumr \)，所以 \( rem \geq 0 \)）。接下来，依次遍历每个 \( B_i \)，将其尽可能增加（最多增加 \( R_i - L_i \)），直到 \( rem \) 用完。这样做的原因是：\( R_i \) 是 \( B_i \) 的最大可能值，优先填满 \( R_i \) 可以保证总和刚好为M，且不违反任何约束。  
* 💡 **学习笔记**：  
  贪心构造的核心是**优先满足“最需要调整”的部分**——这里“最需要调整”指的是当前 \( B_i \) 还能增加的量最多（即 \( R_i - L_i \) 最大），但题解中采用了“顺序遍历”的方式，这是因为无论顺序如何，只要将剩余名额分配完毕，结果都是可行的（因为 \( sumr \geq M \)）。  


### ✨ 解题技巧总结  
- **技巧A：问题转化**：将比例差转化为绝对差，从而适用二分答案。  
- **技巧B：取整处理**：正确计算整数范围的上下界，避免边界错误。  
- **技巧C：贪心构造**：先设下界，再分配剩余名额，确保总和满足条件。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码来自题解一，是二分答案+贪心构造的典型实现，逻辑清晰、高效。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  typedef long long ll;
  const int maxn = 1e5 + 7;
  
  int k;
  ll n, m;
  ll a[maxn], l[maxn], r[maxn];
  ll suml, sumr;
  
  bool check(ll x) {
      suml = 0, sumr = 0;
      for (int i = 1; i <= k; ++i) {
          ll ma = m * a[i];
          l[i] = max(0LL, (ma - x + n - 1) / n); // 向上取整
          r[i] = (ma + x) / n; // 向下取整
          suml += l[i];
          sumr += r[i];
      }
      return suml <= m && sumr >= m;
  }
  
  int main() {
      cin >> k >> n >> m;
      for (int i = 1; i <= k; ++i) {
          cin >> a[i];
      }
      ll L = 0, R = n * m, ans = 0;
      while (L <= R) {
          ll mid = (L + R) / 2;
          if (check(mid)) {
              ans = mid;
              R = mid - 1;
          } else {
              L = mid + 1;
          }
      }
      check(ans); // 重新计算l和r
      ll sum = suml;
      for (int i = 1; i <= k; ++i) {
          ll add = min(r[i] - l[i], m - sum);
          sum += add;
          cout << l[i] + add << " ";
      }
      cout << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三部分：  
  1. **二分答案**：在[0, NM]范围内查找最小的可行x。  
  2. **check函数**：计算每个B_i的上下界，并检查总和是否可行。  
  3. **构造答案**：先设B_i为下界，再分配剩余名额，输出结果。  


### 针对题解一的片段赏析  
* **亮点**：check函数中的上下界计算非常严谨，考虑了非负约束。  
* **核心代码片段**：  
  ```cpp
  l[i] = max(0LL, (ma - x + n - 1) / n); // 向上取整
  r[i] = (ma + x) / n; // 向下取整
  ```  
* **代码解读**：  
  - `ma = m * a[i]`：计算 \( MA_i \)（注意用long long避免溢出）。  
  - `(ma - x + n - 1) / n`：向上取整的公式。例如，(a + b - 1)/b 等价于 \( \lceil a/b \rceil \)（当a和b都是正整数时）。这里计算的是 \( \lceil (MA_i - x)/N \rceil \)，确保 \( NB_i \geq MA_i - x \)。  
  - `max(0LL, ...)`：保证 \( L_i \) 非负（因为B_i不能是负数）。  
  - `(ma + x) / n`：向下取整，计算 \( \lfloor (MA_i + x)/N \rfloor \)，确保 \( NB_i \leq MA_i + x \)。  
* 💡 **学习笔记**：  
  向上取整的公式是处理整数范围的常用技巧，一定要记住！  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素村庄的“人口分配游戏”**（8位FC风格）  

### 设计思路简述  
采用8位像素风是为了营造复古、轻松的学习氛围，让算法过程更直观。通过**像素块**表示每个段位的人口，**颜色变化**表示范围调整，**音效**强化关键操作，让学习者“看得到、听得到”算法的每一步。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示“段位列表”（用数字1~K标记），右侧显示“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。  
   - 每个段位用一个**蓝色像素块**表示当前的下界 \( L_i \)，下方用**绿色进度条**表示可增加的范围（\( R_i - L_i \)）。  
   - 背景播放8位风格的轻松BGM（比如《超级马里奥》的背景音乐）。  

2. **二分过程演示**：  
   - 屏幕上方显示当前猜测的 \( x \)（用红色像素数字表示）。  
   - 每进行一次二分，\( x \) 的值会闪烁（比如从大到小变化），同时每个段位的绿色进度条会**缩短或延长**（表示 \( R_i - L_i \) 的变化）。  
   - 当找到可行的 \( x \) 时，播放“叮”的音效，屏幕弹出“找到最小误差！”的像素提示。  

3. **贪心构造演示**：  
   - 初始时，每个段位的像素块是蓝色（\( L_i \)），屏幕下方显示剩余名额 \( rem = M - suml \)（用黄色像素数字表示）。  
   - 用**红色箭头**指向当前要调整的段位，箭头移动时播放“沙沙”的音效。  
   - 每次给段位增加1个名额，蓝色像素块会**变大1格**（或颜色变深），剩余名额减少1，直到 \( rem = 0 \)。  
   - 当总和达到M时，所有像素块变成**金色**，播放胜利音效（比如《魂斗罗》的通关声），屏幕显示“分配完成！”的像素动画。  

4. **交互功能**：  
   - **单步执行**：点击“单步”按钮，算法执行一步（二分或构造），方便仔细观察。  
   - **自动播放**：点击“开始”按钮，算法自动执行，速度可通过滑块调整（从“慢”到“快”）。  
   - **重置动画**：点击“重置”按钮，回到初始状态，重新开始演示。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的**二分答案+贪心构造**思路，可用于解决以下场景：  
1. **资源分配问题**：将有限资源分配给多个对象，使得某个指标的最大值最小（比如分配任务给工人，使得最大工作时间最小）。  
2. **比例调整问题**：将一组数据按比例缩放，保持比例尽可能接近原数据（比如图片缩放时保持像素比例）。  
3. **约束优化问题**：在满足多个约束条件（如上下界、总和）的情况下，寻找最优解（比如生产计划优化）。  


### 练习推荐 (洛谷)  
1. **洛谷 P1824** - 进击的奶牛  
   * 🗣️ **推荐理由**：这道题是二分答案的经典例题，要求找到最大的最小距离，思路与本题类似，可帮助巩固二分答案的应用。  
2. **洛谷 P2678** - 跳石头  
   * 🗣️ **推荐理由**：本题需要将石头移除，使得最小跳跃距离最大，也是二分答案的典型问题，可锻炼问题转化能力。  
3. **洛谷 P3743** - 小鸟的设备  
   * 🗣️ **推荐理由**：这道题要求构造满足条件的设备数量，涉及贪心构造和边界处理，与本题的构造步骤类似，可提升实践能力。  


## 7. 学习心得与经验分享 (若有)  
题解中没有明确的个人心得，但我们可以从题解中总结以下**经验教训**：  
- **数学转化是关键**：遇到比例或分式问题时，尝试通过乘法将其转化为整数问题，简化计算。  
- **边界处理要严谨**：比如 \( L_i \) 的非负约束，以及取整时的方向，这些细节容易导致错误，需要特别注意。  
- **贪心构造的正确性**：贪心算法的正确性需要验证（比如本题中 \( suml \leq M \leq sumr \) 保证了剩余名额可以分配完毕），不要盲目使用贪心。  


## 结语  
本次关于“[ARC118B] Village of M People”的分析，我们学习了**二分答案+贪心构造**的经典思路，掌握了问题转化、取整处理、贪心构造的技巧。希望这份指南能帮助你更好地理解算法逻辑，提升编程能力。记住：**算法的核心是“解决问题的思路”，而不是“代码的堆砌”**——多思考、多练习，你一定会越来越厉害！💪  

下次我们再一起探索新的编程挑战！👋

---
处理用时：144.26秒
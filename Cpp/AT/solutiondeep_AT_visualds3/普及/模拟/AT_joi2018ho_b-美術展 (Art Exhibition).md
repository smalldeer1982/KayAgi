# 题目信息

# 美術展 (Art Exhibition)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2018ho/tasks/joi2018ho_b

JOI 国で美術展が行われることになった．美術展では，国中から集まった様々な美術品が展示される予定である．

展示される美術品の候補として，$ N $ 点の美術品が集まった．これらの美術品には $ 1,\ 2,\ \ldots,\ N $ の番号が付けられている．それぞれの美術品には大きさと価値と呼ばれる値が定まっている．美術品 $ i $ ($ 1\ \leqq\ i\ \leqq\ N $) の大きさは $ A_i $，価値は $ B_i $ である．

美術展では，これらの美術品のうちから $ 1 $ 点以上を選んで展示する．美術展の会場は十分に広く，$ N $ 点の美術品すべてを展示することも可能である．しかし，JOI 国の人々の美的感覚のため，美術品の間で大きさの差があまり大きくならないように展示する美術品を選びたい．一方，できるだけ価値の大きい美術品を多く展示したい．そのため，次の条件を満たすように展示する美術品を選ぶことにした：

- 選んだ美術品の中で，大きさが最大のものの大きさを $ A_{\mathrm{max}} $，最小のものの大きさを $ A_{\mathrm{min}} $ とする．また，選んだ美術品の価値の総和を $ S $ とする．
- このとき，$ S\ -\ (A_{\mathrm{max}}\ -\ A_{\mathrm{min}} $) を最大化する．

## 说明/提示

### 課題

展示される美術品の候補の個数と，それぞれの美術品の大きさと価値が与えられたとき，$ S\ -\ (A_{\mathrm{max}}\ -\ A_{\mathrm{min}}) $ の最大値を求めよ．

- - - - - -

### 制限

すべての入力データは以下の条件を満たす．

- $ 2\ \leqq\ N\ \leqq\ 500\,000 $．
- $ 1\ \leqq\ A_i\ \leqq\ 1\,000\,000\,000\,000\,000\ =\ 10^{15} $ ($ 1\ \leqq\ i\ \leqq\ N $)．
- $ 1\ \leqq\ B_i\ \leqq\ 1\,000\,000\,000 $ ($ 1\ \leqq\ i\ \leqq\ N $)．

### 小課題

#### 小課題 1 \[10 点\]

- $ N\ \leqq\ 16 $ を満たす．

#### 小課題 2 \[20 点\]

- $ N\ \leqq\ 300 $ を満たす．

#### 小課題 3 \[20 点\]

- $ N\ \leqq\ 5\,000 $ を満たす．

#### 小課題 4 \[50 点\]

- 追加の制限はない．

- - - - - -

### Sample Explanation 1

この入力例では，展示される美術品の候補が $ 3 $ 点ある．それぞれの美術品の大きさ，価値は次の通りである． - 美術品 $ 1 $ の大きさは $ 2 $，価値は $ 3 $ である． - 美術品 $ 2 $ の大きさは $ 11 $，価値は $ 2 $ である． - 美術品 $ 3 $ の大きさは $ 4 $，価値は $ 5 $ である． この場合，美術品 $ 1 $ と美術品 $ 3 $ を展示するために選ぶと，次のようにして $ S\ -\ (A_{\mathrm{max}}\ -\ A_{\mathrm{min}})\ =\ 6 $ となる． - 選んだ中で大きさが最大の美術品は，美術品 $ 3 $ である．よって，$ A_{max}\ =\ 4 $ である． - 選んだ中で大きさが最小の美術品は，美術品 $ 1 $ である．よって，$ A_{min}\ =\ 2 $ である． - 選んだ美術品の価値の総和は $ 3\ +\ 5\ =\ 8 $ であるから，$ S\ =\ 8 $ である． $ S\ -\ (A_{max}\ -\ A_{min}) $ を $ 7 $ 以上にすることは不可能なので，$ 6 $ を出力する． - - - - - -

### Sample Explanation 2

\- - - - - -

## 样例 #1

### 输入

```
3
2 3
11 2
4 5```

### 输出

```
6```

## 样例 #2

### 输入

```
6
4 1
1 5
10 3
9 1
4 2
5 3```

### 输出

```
7```

## 样例 #3

### 输入

```
15
1543361732 260774320
2089759661 257198921
1555665663 389548466
4133306295 296394520
2596448427 301103944
1701413087 274491541
2347488426 912791996
2133012079 444074242
2659886224 656957044
1345396764 259870638
2671164286 233246973
2791812672 585862344
2996614635 91065315
971304780 488995617
1523452673 988137562```

### 输出

```
4232545716```

# AI分析结果

# 💡 Kay的C++算法解析：美術展 (Art Exhibition) 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 排序优化 + 前缀和维护（属于“编程技巧应用”分类）

🗣️ **初步分析**：  
解决“美術展”问题的核心是**最大化“价值总和 - 尺寸差”**（即 \(S - (A_{\text{max}} - A_{\text{min}})\)）。这个目标可以拆解为两个部分：**尽可能让价值总和 \(S\) 大**，**尽可能让尺寸差 \(A_{\text{max}} - A_{\text{min}}\) 小**。看似矛盾的两个目标，其实可以通过**排序+贪心**的方式统一处理——**将物品按尺寸从小到大排序后，最优解必然对应一个连续的区间**（因为尺寸差由区间的左右端点决定，而连续区间的尺寸差最小）。  

具体来说，排序后，对于任意区间 \([l, r]\)，\(A_{\text{max}} = A[r]\)，\(A_{\text{min}} = A[l]\)，价值总和 \(S = \text{sum}[r] - \text{sum}[l-1]\)（\(\text{sum}\) 是价值前缀和）。原问题转化为：**寻找区间 \([l, r]\)，使得 \((\text{sum}[r] - \text{sum}[l-1]) - (A[r] - A[l])\) 最大**。进一步拆分表达式得：\((\text{sum}[r] - A[r]) + (A[l] - \text{sum}[l-1])\)。此时，对于每个 \(r\)，我们只需找到 \(l \leq r\) 时 \(A[l] - \text{sum}[l-1]\) 的最大值，即可快速计算当前 \(r\) 的最优解。  

**核心算法流程**：  
1. 按尺寸从小到大排序物品（尺寸相同则价值从大到小，避免遗漏高价值物品）；  
2. 计算价值前缀和 \(\text{sum}\)；  
3. 遍历每个物品 \(r\)，维护变量 \(\text{now}\)（表示 \(l \leq r\) 时 \(A[l] - \text{sum}[l-1]\) 的最大值）；  
4. 用 \(\text{now} + (\text{sum}[r] - A[r])\) 更新全局最大值 \(\text{ans}\)。  

**可视化设计思路**：  
- 采用8位像素风格，用“像素方块”表示物品（尺寸越大，方块越宽；价值越高，方块越亮）；  
- 排序过程用“方块移动动画”展示，尺寸小的方块向左聚集；  
- 前缀和用“进度条”表示，每添加一个物品，进度条延长；  
- 维护 \(\text{now}\) 时，用“闪烁”标记当前最大值对应的 \(l\)；  
- 更新 \(\text{ans}\) 时，弹出“胜利音效”（如“叮”的一声），并在屏幕上方显示当前最大值。  


## 2. 精选优质题解参考

### 题解一（作者：Kano_zyc，赞4）  
* **点评**：  
  这份题解的**思路清晰度**和**代码规范性**非常突出。作者首先明确了“排序+前缀和”的核心逻辑，并用快读处理大输入（符合 \(N \leq 5 \times 10^5\) 的数据范围）。代码中的结构体 `Kano` 清晰存储了物品的尺寸和价值，排序规则（尺寸升序、价值降序）合理。前缀和数组 `sum` 计算正确，遍历过程中用 `now` 维护最大值，逻辑简洁。**亮点**：快读的使用（避免输入超时）和 `long long` 类型的正确应用（处理大数值），体现了竞赛编程的严谨性。


### 题解二（作者：banned_wanyb，赞2）  
* **点评**：  
  此题解的**表达式拆分**非常精彩，直接将原问题转化为 \((\text{sum}[r] - A[r]) + (A[l] - \text{sum}[l-1])\)，抓住了问题的本质。代码中的 `maxn` 变量维护了 \(A[l] - \text{sum}[l-1]\) 的最大值，遍历过程中实时更新 `ans`，逻辑紧凑。**亮点**：对问题的数学转化能力，将复杂的目标函数拆解为可贪心处理的形式，值得学习。


### 题解三（作者：Silence_World，赞2）  
* **点评**：  
  此题解的**逆向思维**很有特色。作者不仅用前缀和计算价值总和，还通过逆序遍历维护了以 \(j\) 为右端点的最优解（`b[j] = max(b[j+1], sum[j] - a[j].x)`），再顺序遍历计算以 \(j\) 为左端点的最优解。这种双向遍历的方式拓展了思路，虽然与前两种解法本质一致，但提供了不同的实现角度。**亮点**：逆向思维的应用，帮助理解问题的多面性。


## 3. 核心难点辨析与解题策略

### 1. 如何将原问题转化为区间问题？  
* **分析**：  
  原问题中的 \(A_{\text{max}} - A_{\text{min}}\) 是选中物品的尺寸差，若将物品按尺寸排序，则最优解必然对应一个连续的区间（因为非连续区间的尺寸差更大，而价值总和可能更小）。排序后，区间的左右端点即为 \(A_{\text{min}}\) 和 \(A_{\text{max}}\)，问题转化为寻找最优连续区间。  
* 💡 **学习笔记**：排序是处理“极值差”问题的常用技巧，能将离散的选择转化为连续的区间问题。


### 2. 如何拆分目标函数以简化计算？  
* **分析**：  
  原目标函数 \(S - (A_{\text{max}} - A_{\text{min}})\) 可拆分为 \((\text{sum}[r] - \text{sum}[l-1]) - (A[r] - A[l])\)，进一步整理为 \((\text{sum}[r] - A[r]) + (A[l] - \text{sum}[l-1])\)。此时，对于每个 \(r\)，只需找到 \(l \leq r\) 时 \(A[l] - \text{sum}[l-1]\) 的最大值，即可快速计算当前 \(r\) 的最优解。  
* 💡 **学习笔记**：数学拆分是简化问题的关键，能将复杂的目标函数转化为可贪心处理的形式。


### 3. 如何高效维护最大值？  
* **分析**：  
  若直接枚举所有区间 \([l, r]\)，时间复杂度为 \(O(n^2)\)，无法通过大数据。通过维护变量 \(\text{now}\)（表示 \(l \leq r\) 时 \(A[l] - \text{sum}[l-1]\) 的最大值），遍历每个 \(r\) 时只需 \(O(1)\) 时间更新 \(\text{now}\)，总时间复杂度降为 \(O(n \log n)\)（排序的时间）。  
* 💡 **学习笔记**：贪心策略中的“维护最大值”技巧，能将嵌套循环优化为线性遍历，是处理大数据的关键。


### ✨ 解题技巧总结  
- **排序技巧**：处理“极值差”问题时，排序能将离散选择转化为连续区间，简化问题。  
- **前缀和技巧**：快速计算区间和，避免重复计算。  
- **贪心维护**：通过维护变量记录中间结果，将 \(O(n^2)\) 算法优化为 \(O(n)\)。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合优质题解的思路，提供一个清晰、高效的核心实现（包含快读、排序、前缀和、贪心维护）。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <algorithm>
  using namespace std;

  typedef long long LL;
  const int N = 5e5 + 10;

  // 快读
  char buf[1 << 20], *p1, *p2;
  #define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
  inline LL read() {
      LL x = 0; char c = gc();
      while (!isdigit(c)) c = gc();
      while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();
      return x;
  }

  struct Item {
      LL a, b; // a: 尺寸，b: 价值
  } a[N];

  bool cmp(Item x, Item y) {
      if (x.a != y.a) return x.a < y.a; // 尺寸升序
      return x.b > y.b; // 尺寸相同，价值降序（优先选高价值）
  }

  LL sum[N]; // 前缀和：sum[i] = a[1].b + ... + a[i].b

  int main() {
      LL n = read();
      for (int i = 1; i <= n; i++) {
          a[i].a = read();
          a[i].b = read();
      }
      sort(a + 1, a + n + 1, cmp); // 排序

      // 计算前缀和
      for (int i = 1; i <= n; i++) {
          sum[i] = sum[i - 1] + a[i].b;
      }

      LL ans = -1e18; // 初始化为极小值
      LL now = -1e18; // 维护A[l] - sum[l-1]的最大值（l <= i）
      for (int i = 1; i <= n; i++) {
          now = max(now, a[i].a - sum[i - 1]); // 更新now
          ans = max(ans, now + sum[i] - a[i].a); // 更新ans
      }

      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：用快读读取大输入，避免超时；  
  2. **排序**：按尺寸升序、价值降序排序物品；  
  3. **前缀和计算**：快速计算区间价值和；  
  4. **贪心维护**：遍历每个物品，维护`now`（`A[l] - sum[l-1]`的最大值），并更新`ans`（当前最优解）。


### 针对各优质题解的片段赏析

#### 题解一（作者：Kano_zyc）  
* **亮点**：快读的使用（处理大输入）。  
* **核心代码片段**：  
  ```cpp
  // 快读
  #define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
  char *p1,*p2,buf[1<<20+5];
  inline LL read() {
      LL x=0; char c=gc();
      while(!isdigit(c)) c=gc();
      while(isdigit(c)) x=x*10+(c^48), c=gc();
      return x;
  }
  ```  
* **代码解读**：  
  快读通过`fread`一次性读取大量数据，避免了`cin`或`scanf`的多次IO操作，适用于 \(N \leq 5 \times 10^5\) 的大输入场景。`gc()`宏用于从缓冲区取字符，`read()`函数将字符转换为`LL`类型（处理大数值）。  
* 💡 **学习笔记**：快读是竞赛编程中处理大输入的必备技巧，能显著提高程序运行速度。


#### 题解二（作者：banned_wanyb）  
* **亮点**：表达式拆分的简洁性。  
* **核心代码片段**：  
  ```cpp
  maxn = a[1].a;
  s = a[1].b;
  for (int i = 2; i <= n; i++) {
      maxn = max(maxn, a[i].a - s); // 维护A[l] - sum[l-1]的最大值
      s += a[i].b; // 更新前缀和
      ans = max(ans, s - a[i].a + maxn); // 更新ans
  }
  ```  
* **代码解读**：  
  作者将前缀和`sum`用变量`s`实时维护（避免数组存储），`maxn`维护`A[l] - sum[l-1]`的最大值。遍历过程中，`s`累加当前物品的价值，`maxn`更新为当前最大值，`ans`更新为当前最优解。这种写法更简洁，节省了数组空间。  
* 💡 **学习笔记**：实时维护前缀和和最大值，能简化代码并节省空间。


#### 题解三（作者：Silence_World）  
* **亮点**：逆向思维的应用。  
* **核心代码片段**：  
  ```cpp
  b[n+1] = -1e18;
  for (int j = n; j >= 1; j--) {
      b[j] = max(b[j+1], sum[j] - a[j].x); // 逆序维护sum[j] - A[j]的最大值
  }
  for (int j = 1; j <= n; j++) {
      max1 = max(max1, a[j].x - sum[j-1] + b[j]); // 顺序计算最优解
  }
  ```  
* **代码解读**：  
  作者用逆序遍历维护了`b[j]`（表示以`j`为右端点的`sum[j] - A[j]`的最大值），再顺序遍历计算以`j`为左端点的最优解（`a[j].x - sum[j-1] + b[j]`）。这种双向遍历的方式拓展了思路，虽然与前两种解法本质一致，但提供了不同的实现角度。  
* 💡 **学习笔记**：逆向思维能帮助我们从不同角度理解问题，找到更简洁的解法。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**像素探险家：寻找最优展览组合**（仿FC红白机风格）


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示“像素物品列表”（每个物品用16x16的像素方块表示，尺寸越大，方块越宽；价值越高，方块颜色越亮，如红色表示高价值，蓝色表示低价值）；  
   - 屏幕右侧显示“控制面板”（包含“开始/暂停”“单步执行”“重置”按钮，以及速度滑块）；  
   - 屏幕上方显示“当前最大值”（初始为-∞）；  
   - 背景播放8位风格的轻松BGM（如《超级马里奥》的背景音乐）。

2. **排序过程**：  
   - 点击“开始”按钮后，物品列表开始排序（尺寸小的方块向左移动，尺寸大的向右移动）；  
   - 每移动一个物品，播放“咔嗒”音效（模拟方块移动的声音）；  
   - 排序完成后，播放“叮”的音效，提示排序完成。

3. **前缀和计算**：  
   - 排序完成后，屏幕下方显示“前缀和进度条”（从左到右逐渐延长，颜色为绿色，长度表示当前前缀和的大小）；  
   - 每添加一个物品，进度条延长，播放“滴”的音效（模拟进度增加的声音）。

4. **贪心维护过程**：  
   - 遍历每个物品（从左到右），当前物品用“黄色边框”标记；  
   - 维护`now`变量（表示`A[l] - sum[l-1]`的最大值），对应的`l`位置用“闪烁”标记（如每隔0.5秒切换颜色）；  
   - 每更新`now`，播放“哔”的音效；  
   - 每更新`ans`（当前最大值），屏幕上方的“当前最大值”数字变大，并播放“咚”的音效（模拟胜利的声音）。

5. **结果展示**：  
   - 遍历完成后，屏幕中央弹出“胜利动画”（如像素烟花绽放），并显示最终最大值；  
   - 播放“胜利主题曲”（如《塞尔达传说》的胜利音效）。


### 交互设计  
- **单步执行**：点击“单步”按钮，动画执行一步（如排序一个物品、计算一个前缀和、更新一次`now`）；  
- **自动播放**：拖动速度滑块调整播放速度（如1x、2x、4x），动画自动执行；  
- **重置**：点击“重置”按钮，动画回到初始状态，可重新执行。


### 设计思路  
- **像素风格**：营造复古游戏氛围，降低学习压力；  
- **音效提示**：用不同音效强化关键操作（如排序、前缀和、最大值更新），帮助记忆；  
- **交互控制**：允许用户自由控制动画进度，便于观察细节；  
- **游戏化元素**：胜利动画和主题曲增加成就感，激发学习兴趣。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **前缀和技巧**：适用于需要快速计算区间和的问题（如最大子段和、区间查询）；  
- **贪心维护最大值**：适用于需要实时更新最大值的问题（如滑动窗口最大值、动态规划中的状态转移）；  
- **排序优化**：适用于处理“极值差”或“连续区间”问题（如线段覆盖、区间合并）。


### 练习推荐 (洛谷)  
1. **洛谷 P1115 最大子段和**  
   - 🗣️ **推荐理由**：这道题是前缀和技巧的经典应用，要求找到连续子数组的最大和。通过本题可以巩固前缀和的计算和最大值维护的技巧。  
2. **洛谷 P1803 线段覆盖**  
   - 🗣️ **推荐理由**：这道题要求选择最多的不重叠线段，需要用到排序+贪心策略。通过本题可以学习如何将问题转化为连续区间的选择。  
3. **洛谷 P2249 查找**  
   - 🗣️ **推荐理由**：这道题要求快速查找元素的位置，需要用到排序+二分查找。通过本题可以巩固排序的应用和二分查找的技巧。  
4. **洛谷 P3372 线段树模板**  
   - 🗣️ **推荐理由**：这道题要求实现线段树，处理区间查询和更新。通过本题可以学习更高级的数据结构，拓展解决问题的能力。


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自题解作者)  
> “我在解决这个问题时，最初没有注意到`long long`类型的使用，导致数据溢出，结果错误。后来通过打印中间变量发现了问题，才将所有变量改为`long long`。”  
> —— 题解作者：Kano_zyc  

**点评**：  
这位作者的经验很典型。在处理大数值问题时，`int`类型可能无法存储（如本题中`A_i`可达 \(10^{15}\)，`sum`可达 \(5 \times 10^{20}\)），必须使用`long long`类型。打印中间变量是调试溢出问题的有效方法，值得学习。


## 结语  
本次关于“美術展”的C++解题分析就到这里。希望这份学习指南能帮助大家理解“贪心+排序+前缀和”的核心技巧，并掌握解决类似问题的思路。记住，编程能力的提升在于**持续练习**和**深入思考**，下次我们再一起探索新的编程挑战！💪

---
处理用时：198.51秒
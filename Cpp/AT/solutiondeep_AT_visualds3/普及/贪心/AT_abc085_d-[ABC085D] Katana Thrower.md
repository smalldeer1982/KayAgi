# 题目信息

# [ABC085D] Katana Thrower

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc085/tasks/abc085_d

あなたが散歩していると、突然一体の魔物が出現しました。幸い、あなたは $ N $ 本の刀、刀 $ 1 $、刀 $ 2 $、$ … $、刀 $ N $ を持っていて、次の二種類の攻撃を自由な順番で行うことができます。

- 持っている刀のうち一本を振る。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を振ると、魔物は $ a_i $ ポイントのダメージを受ける。同じ刀を何度振ることもできる。
- 持っている刀のうち一本を投げつける。刀 $ i $ $ (1\ <\ =\ i\ <\ =\ N) $ を投げつけると、魔物は $ b_i $ ポイントのダメージを受け、あなたはその刀を失う。すなわち、あなたは以後その刀を振ることも投げつけることもできなくなる。

魔物は、受けたダメージの合計が $ H $ ポイント以上になると消滅します。魔物を消滅させるには、最小で合計何回の攻撃が必要でしょうか。

## 说明/提示

### 制約

- $ 1\ <\ =\ N\ <\ =\ 10^5 $
- $ 1\ <\ =\ H\ <\ =\ 10^9 $
- $ 1\ <\ =\ a_i\ <\ =\ b_i\ <\ =\ 10^9 $
- 入力値はすべて整数である。

### Sample Explanation 1

あなたは $ 1 $ 本の刀を持っていて、振ると $ 3 $ ポイントのダメージ、投げつけると $ 5 $ ポイントのダメージを与えられます。刀を $ 2 $ 回振ってから投げつけると $ 3\ +\ 3\ +\ 5\ =\ 11 $ ポイントのダメージを与え、合計 $ 3 $ 回の攻撃で魔物が消滅します。

### Sample Explanation 2

先ほどの刀に加えてもう $ 1 $ 本別の刀もあり、こちらは振ると $ 2 $ ポイントのダメージ、投げつけると $ 6 $ ポイントのダメージを与えられます。両方の刀を投げつけると $ 5\ +\ 6\ =\ 11 $ ポイントのダメージを与え、$ 2 $ 回の攻撃で魔物が消滅します。

## 样例 #1

### 输入

```
1 10

3 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 10

3 5

2 6```

### 输出

```
2```

## 样例 #3

### 输入

```
4 1000000000

1 1

1 10000000

1 30000000

1 99999999```

### 输出

```
860000004```

## 样例 #4

### 输入

```
5 500

35 44

28 83

46 62

31 79

40 43```

### 输出

```
9```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC085D] Katana Thrower 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（Greedy）

🗣️ **初步分析**：  
解决“Katana Thrower”问题的关键，在于**每次选择当前能造成最大伤害的攻击方式**（贪心思想）。简单来说，贪心就像“捡最大的苹果吃”——每次都选当前最优的选项，最终得到全局最优解。在本题中，我们需要决定：哪些刀应该“投”（一次高伤害，但之后不能用），哪些刀应该“挥”（无限次但伤害较低），才能用最少的次数让魔物的伤害达到H。  

### 核心思路与难点
- **核心思路**：  
  1. 找到**挥刀伤害最高的刀**（记为`max_a`）——因为挥刀可以无限次使用，最终肯定要用它来补伤害。  
  2. 把所有**投刀伤害高于`max_a`的刀**按伤害从大到小排序——这些刀投一次的伤害比挥一次高，所以应该优先投。  
  3. 先投这些高伤害的刀，直到剩下的伤害可以用`max_a`挥刀解决，或者所有高伤害投刀都用完。  
- **核心难点**：  
  - 如何判断“哪些刀该投”？（只有投刀伤害高于`max_a`时，投才比挥更划算）  
  - 如何处理“投刀后的剩余伤害”？（用`max_a`挥刀时，需要计算次数，注意余数的处理）  
- **可视化设计思路**：  
  我们可以用**像素风格的“刀库”和“魔物伤害条”**来展示算法过程：  
  - 刀库中，用不同颜色标记“可投”（红色）、“可挥”（蓝色）的刀，`max_a`的刀用闪烁的黄色突出。  
  - 魔物的伤害条用绿色表示剩余血量，每次攻击后减少，投刀时播放“咻”的音效，挥刀时播放“砍”的音效。  
  - 动画中，先逐个投出红色的高伤害刀（伤害条快速减少），最后用黄色的`max_a`刀反复挥砍（伤害条缓慢减少直到归零）。  


## 2. 精选优质题解参考

### 题解一：作者：happybob（赞：2）  
* **点评**：  
  这份题解的思路非常**简洁且符合贪心逻辑**！它先计算了“只挥不投”的最坏情况（用`max_a`挥刀的次数），然后逐步尝试“投出高伤害的刀”，每次投刀后重新计算剩余伤害需要的挥刀次数，取所有情况中的最小值。这种“对比优化”的思路很容易理解，而且代码结构清晰（排序+循环模拟），边界条件处理得很严谨（比如`ceil`函数处理余数）。从实践角度看，代码可以直接用于竞赛，而且时间复杂度是`O(n log n)`（排序的时间），完全符合题目约束（`n≤1e5`）。  

### 题解二：作者：Hilte（赞：1）  
* **点评**：  
  此题解的贪心策略很**直接**——先扔所有“投刀伤害高于`max_a`的刀”（从大到小扔），如果扔完还没打死，就用`max_a`挥刀。代码中的`sort`函数分别对挥刀和投刀伤害排序，然后用循环处理投刀，最后处理挥刀。这种“分步骤”的思路很适合初学者理解，而且代码量小，可读性高。  

### 题解三：作者：Mysterious_Cat（赞：4）  
* **点评**：  
  这份题解的亮点在于**用vector存储需要投的刀**——它先选出`max_a`的刀，然后把所有“投刀伤害高于`max_a`且不是`max_a`的刀”存入vector，排序后逐个投出。最后特判了“是否需要投`max_a`的刀”（如果剩余伤害刚好够投一次`max_a`的刀，就不用挥了）。这种“细致分类”的思路可以避免遗漏情况，比如`max_a`的刀的投刀伤害可能也很高，需要考虑是否投它。  


## 3. 核心难点辨析与解题策略

### 1. 关键点1：如何确定“哪些刀该投”？  
* **分析**：  
  只有当刀的**投刀伤害`b_i`高于挥刀伤害`a_i`**时，投刀才比挥刀更划算吗？不对！其实，应该比较`b_i`和**全局最高挥刀伤害`max_a`**。因为最终我们会用`max_a`挥刀，所以如果`b_i > max_a`，那么投一次`b_i`比挥一次`max_a`的伤害高，应该优先投；如果`b_i ≤ max_a`，那么投一次不如挥一次（因为挥可以无限次），所以不用投。  
* 💡 **学习笔记**：贪心的关键是“选当前最优”，而“当前最优”需要结合“全局最优”（比如`max_a`）来判断。  

### 2. 关键点2：如何处理“剩余伤害”？  
* **分析**：  
  投完所有高伤害的刀后，剩余的伤害需要用`max_a`挥刀解决。此时，次数等于`ceil(剩余伤害 / max_a)`（比如剩余伤害是10，`max_a`是3，那么需要4次：3×3=9，再加1次）。在代码中，可以用`(h + max_a - 1) / max_a`来计算（避免用`ceil`函数，更高效）。  
* 💡 **学习笔记**：处理余数的常用技巧是“加除数减1再除以除数”，比如`(x + y - 1) / y`等于`ceil(x/y)`。  

### 3. 关键点3：如何验证贪心策略的正确性？  
* **分析**：  
  贪心策略的正确性需要证明“每次选当前最优的选项，最终能得到全局最优”。比如，在本题中，先投最高的`b_i`（大于`max_a`），因为如果不投这个`b_i`，而投一个更小的`b_j`，那么总次数会更多（比如`b_i=10`，`b_j=8`，`max_a=5`，投`b_i`需要1次，而投`b_j`需要2次（8+5=13，比10多））。  
* 💡 **学习笔记**：贪心策略的正确性需要“无后效性”——当前的选择不影响未来的选择，而且每次选择都是当前最优的。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自happybob的题解）  
* **说明**：  
  此代码综合了“只挥不投”和“逐步投刀”的思路，通过排序和循环模拟，找到最少攻击次数。代码逻辑清晰，时间复杂度`O(n log n)`，适合竞赛使用。  
* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  #include <algorithm>
  #include <cmath>
  using namespace std;

  const int MAXN = 1e5 + 10;
  int a[MAXN], b[MAXN];
  int main() {
      int n, h;
      scanf("%d%d", &n, &h);
      int max_a = 0;
      for (int i = 1; i <= n; i++) {
          scanf("%d%d", &a[i], &b[i]);
          if (a[i] > max_a) max_a = a[i]; // 找全局最高挥刀伤害
      }
      // 步骤1：计算只挥不投的次数
      int ans = (h + max_a - 1) / max_a; // 等价于ceil(h / max_a)
      // 步骤2：排序投刀伤害（从大到小）
      sort(b + 1, b + n + 1, greater<int>());
      // 步骤3：逐步投刀，更新最优解
      int current_h = h;
      for (int i = 1; i <= n; i++) {
          current_h -= b[i];
          if (current_h <= 0) { // 投i次就打死了
              ans = min(ans, i);
              break;
          }
          // 计算投i次后，需要挥的次数
          int temp = i + (current_h + max_a - 1) / max_a;
          ans = min(ans, temp);
      }
      printf("%d\n", ans);
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取输入，找到全局最高挥刀伤害`max_a`。  
  2. 计算“只挥不投”的次数（最坏情况）。  
  3. 对投刀伤害从大到小排序（优先投高伤害的）。  
  4. 循环模拟投刀：每次投一把，计算剩余伤害需要的挥刀次数，取所有情况中的最小值。  


### 针对各优质题解的片段赏析

#### 题解一：happybob的核心代码片段  
* **亮点**：用“逐步尝试”的方式找最优解，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  sort(b + 1, b + n + 1, greater<int>());
  int current_h = h;
  for (int i = 1; i <= n; i++) {
      current_h -= b[i];
      if (current_h <= 0) {
          ans = min(ans, i);
          break;
      }
      int temp = i + (current_h + max_a - 1) / max_a;
      ans = min(ans, temp);
  }
  ```
* **代码解读**：  
  - `sort(b + 1, b + n + 1, greater<int>())`：把投刀伤害从大到小排序，优先投高伤害的。  
  - `current_h -= b[i]`：模拟投第i把刀，减少魔物的剩余血量。  
  - `if (current_h <= 0)`：如果投i次就打死了，更新答案并退出循环。  
  - `temp = i + (current_h + max_a - 1) / max_a`：计算投i次后，需要挥的次数（i次投+挥的次数）。  
* 💡 **学习笔记**：通过“逐步尝试”所有可能的投刀次数，找到最优解，这种方法很适合贪心问题。  


#### 题解二：Hilte的核心代码片段  
* **亮点**：直接处理“该投的刀”，代码简洁。  
* **核心代码片段**：  
  ```cpp
  sort(a + 1, a + n + 1);
  sort(b + 1, b + n + 1);
  for (int i = n; i >= 1 && b[i] > a[n] && h > 0; i--) {
      h -= b[i];
      ans++;
  }
  if (h > 0) {
      ans += (h / a[n] + (h % a[n] != 0));
  }
  ```
* **代码解读**：  
  - `sort(a + 1, a + n + 1)`：排序挥刀伤害，`a[n]`是全局最高挥刀伤害。  
  - `sort(b + 1, b + n + 1)`：排序投刀伤害，从大到小遍历（`i从n到1`）。  
  - `b[i] > a[n]`：判断该投刀是否比最高挥刀伤害高，是则投。  
  - `h / a[n] + (h % a[n] != 0)`：计算挥刀次数（处理余数）。  
* 💡 **学习笔记**：用“从大到小遍历”的方式处理投刀，避免了额外的存储，代码更简洁。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素刀客传》  
**风格**：8位像素风（类似FC游戏《塞尔达传说》），用简单的色块和音效展示算法过程。  

### 核心演示内容  
1. **初始场景**：  
   - 屏幕左侧是“刀库”，里面有N把刀，用不同颜色标记：红色（投刀伤害>max_a）、蓝色（投刀伤害≤max_a）、黄色（max_a的刀）。  
   - 屏幕右侧是“魔物伤害条”（绿色），显示当前剩余血量H。  
   - 屏幕下方是“控制面板”，有“开始”“单步”“重置”按钮，以及速度滑块。  

2. **算法执行过程**：  
   - **步骤1：找max_a**：黄色的刀开始闪烁，旁边弹出文字“这是挥刀伤害最高的刀！”。  
   - **步骤2：排序投刀**：红色的刀按从大到小的顺序排列（从刀库顶部往下），蓝色的刀留在底部。  
   - **步骤3：投刀**：红色的刀逐个飞向魔物，每次投刀后，魔物的伤害条减少（红色部分），同时播放“咻”的音效。投完一把红色刀后，刀库中该刀消失。  
   - **步骤4：挥刀**：当所有红色刀都投完后，黄色的刀开始反复挥砍（左右移动），魔物的伤害条缓慢减少（绿色部分），同时播放“砍”的音效。每挥一次，伤害条减少max_a，直到归零。  

3. **交互设计**：  
   - **单步执行**：点击“单步”按钮，动画执行一步（比如投一把刀，或挥一次刀）。  
   - **自动播放**：点击“开始”按钮，动画自动执行，速度可以通过滑块调整（慢/中/快）。  
   - **重置**：点击“重置”按钮，回到初始场景。  

### 游戏化元素  
- **音效**：投刀时播放“咻”的音效（高频短音），挥刀时播放“砍”的音效（低频长音），魔物死亡时播放“胜利”音效（上扬的旋律）。  
- **积分**：每投一把红色刀，获得10分；每挥一次黄色刀，获得1分。总分显示在屏幕右上角，鼓励玩家“用最少的次数得最高的分”。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
贪心算法的核心是“每次选当前最优”，适用于以下场景：  
1. **资源分配问题**：比如“合并果子”（每次合并两个最小的果子，总代价最小）。  
2. **排序问题**：比如“皇后游戏”（按特定顺序排列皇后，使总时间最小）。  
3. **区间问题**：比如“活动安排”（选最多的不重叠活动）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1090 合并果子**  
   - 🗣️ **推荐理由**：这道题是贪心算法的经典问题，需要每次合并两个最小的果子，总代价最小。和本题的“选最高伤害”思路类似，适合巩固贪心的核心思想。  
2. **洛谷 P2123 皇后游戏**  
   - 🗣️ **推荐理由**：此题需要按特定顺序排列皇后，使总时间最小。需要证明贪心策略的正确性，适合提升逻辑思维能力。  
3. **洛谷 P3817 小A的糖果**  
   - 🗣️ **推荐理由**：此题需要分配糖果，使每个小朋友的糖果数不超过旁边的，需要用贪心的方式调整。适合练习“局部最优到全局最优”的思路。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自happybob的题解)  
> “我一开始没想到要先算只挥不投的情况，后来试了几个样例，发现逐步投刀找更优解的思路很有效。”  

**点评**：这位作者的经验很典型——贪心问题往往需要“先考虑极端情况（比如只挥不投），再逐步优化”。通过试样例，可以快速验证思路的正确性，避免遗漏情况。  


## 结语  
本次关于“[ABC085D] Katana Thrower”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解贪心算法的核心思想和解题技巧。记住，贪心的关键是“选当前最优”，而验证策略的正确性是关键！下次我们再一起探索新的编程挑战！💪

---
处理用时：147.52秒
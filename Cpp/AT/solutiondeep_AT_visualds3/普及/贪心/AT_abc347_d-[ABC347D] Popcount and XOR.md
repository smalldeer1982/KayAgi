# 题目信息

# [ABC347D] Popcount and XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc347/tasks/abc347_d

非負整数 $ a,b,C $ が与えられます。 次の $ 5 $ つの条件をすべて満たす非負整数の組 $ (X,Y) $ が存在するか判定し、存在するならひとつ出力してください。

- $ 0\leq\ X\lt2\ ^\ {60} $
- $ 0\leq\ Y\lt2\ ^\ {60} $
- $ \operatorname{popcount}(X)=a $
- $ \operatorname{popcount}(Y)=b $
- $ X\oplus\ Y=C $

ただし、$ \oplus $ はビットごとの排他的論理和を表します。

条件を満たす $ (X,Y) $ が複数存在する場合、どれを出力しても構いません。

popcount とは？非負整数 $ x $ について $ x $ の popcount とは、$ x $ を $ 2 $ 進法で表記したときの $ 1 $ の個数です。 より厳密には、非負整数 $ x $ について $ \displaystyle\ x=\sum\ _\ {i=0}\ ^\ \infty\ b\ _\ i2\ ^\ i\ (b\ _\ i\in\lbrace0,1\rbrace) $ が成り立っているとき $ \displaystyle\operatorname{popcount}(x)=\sum\ _\ {i=0}\ ^\ \infty\ b\ _\ i $ です。

例えば、$ 13 $ を $ 2 $ 進法で表記すると `1101` なので、 $ \operatorname{popcount}(13)=3 $ となります。 ビットごとの排他的論理和とは？非負整数 $ x,y $ について $ x,y $ のビットごとの排他的論理和 $ x\oplus\ y $ は以下のように定義されます。

- $ x\oplus\ y $ を $ 2 $ 進法で表記したときの $ 2\ ^\ k\ (k\geq0) $ の位は、$ x,y $ を $ 2 $ 進法で表記したときの $ 2\ ^\ k\ (k\geq0) $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $ 、そうでなければ $ 0 $ となる。

例えば、$ 9,3 $ を $ 2 $ 進法で表記するとそれぞれ `1001`, `0011` なので、$ 9\oplus3=10 $ となります（$ 10 $ を $ 2 $ 進法で表記すると `1010` です）。

## 说明/提示

### 制約

- $ 0\leq\ a\leq60 $
- $ 0\leq\ b\leq60 $
- $ 0\leq\ C\lt2\ ^\ {60} $
- 入力はすべて整数

### Sample Explanation 1

$ (X,Y)=(28,27) $ は条件を満たします。 $ X,Y $ を $ 2 $ 進法で表記するとそれぞれ `11100` と `11011` になります。 - $ X $ を $ 2 $ 進法で表記すると `11100` になるので、$ \operatorname{popcount}(X)=3 $ です。 - $ Y $ を $ 2 $ 進法で表記すると `11011` になるので、$ \operatorname{popcount}(Y)=4 $ です。 - $ X\oplus\ Y $ を $ 2 $ 進法で表記すると `00111` となり、$ X\oplus\ Y=7 $ です。 条件を満たす非負整数の組が複数存在する場合どれを出力しても構わないため、例えば `42 45` と出力しても正解になります。

### Sample Explanation 2

条件を満たす非負整数の組は存在しません。

### Sample Explanation 3

出力すべき値が $ 32\operatorname{bit} $ 整数に収まらない場合があります。

## 样例 #1

### 输入

```
3 4 7```

### 输出

```
28 27```

## 样例 #2

### 输入

```
34 56 998244353```

### 输出

```
-1```

## 样例 #3

### 输入

```
39 47 530423800524412070```

### 输出

```
540431255696862041 10008854347644927```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC347D] Popcount and XOR 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：位运算（异或性质）+ 贪心策略  

🗣️ **初步分析**：  
解决“Popcount and XOR”的关键，在于**利用异或的位特性**（相同为0、不同为1），结合**贪心分配**满足`popcount`（二进制1的个数）要求。简单来说，异或就像“二进制位的天平”——C的每一位是1时，X和Y必须“一边放1、一边放0”；C的每一位是0时，X和Y必须“同时放0或同时放1”。我们需要通过**分配C的1的位**（满足异或条件）和**填充C的0的位**（补充1的数量），让X和Y的1的个数刚好等于a和b。  

### 核心思路拆解：
1. **处理C的1的位**：对于C的每一位1，将其分配给X或Y（贪心选择：优先给当前需要更多1的数，比如a>b时给X），减少对应的`popcount`需求。  
2. **处理C的0的位**：对于C的每一位0，若X和Y还需要更多1，则同时将该位设为1（不影响异或结果，但增加两者的`popcount`）。  
3. **无解判断**：若a+b < C的1的个数（不够分配）、a+b与C的1的个数奇偶性不同（无法通过填充0的位补足）、或填充0的位的数量超过限制（60位），则无解。  

### 可视化设计思路：
计划用**8位像素风格**模拟二进制位分配过程：  
- **场景**：屏幕左侧显示C的二进制位（1为红色、0为蓝色），右侧显示X和Y的二进制位（初始为灰色）。  
- **操作动画**：  
  - 处理C的1的位时，红色方块从C移动到X或Y（根据贪心策略），同时对应的`popcount`计数器减少。  
  - 处理C的0的位时，蓝色方块同时变为X和Y的绿色方块（表示同1），计数器同步减少。  
- **交互**：支持“单步执行”（查看每一步分配）、“自动播放”（加速演示），并添加“叮”的音效（分配1时）和“嗡”的音效（填充0时），增强代入感。  


## 2. 精选优质题解参考

### 题解一：（来源：zengziqvan，赞4）  
* **点评**：  
  此题解思路**清晰直白**，完美贴合异或的位特性。作者将C的二进制位存储在数组中，先处理1的位（贪心分配给需要更多1的数），再处理0的位（填充同1），最后检查是否满足条件。代码结构**模块化**（分步骤处理1和0的位），变量名（如`A[i]`表示X的第i位）**含义明确**，非常适合初学者理解。其**亮点**在于：通过`a`和`b`的动态调整，直观反映当前需要的1的数量，避免了复杂的数学推导。  

### 题解二：（来源：StormWhip，赞2）  
* **点评**：  
  此题解的**实践价值高**，代码实现简洁。作者用数组存储X和Y的二进制位，通过快速幂计算2的幂（虽然可以用左移优化，但思路正确），并在处理完1的位后，直接填充0的位直到满足条件。其**亮点**在于：通过`Print`函数将二进制数组转换为十进制，逻辑清晰；同时，代码中添加了“提前退出”（处理完所有位后直接输出），优化了执行效率。  

### 题解三：（来源：wangbinfeng，赞4）  
* **点评**：  
  此题解的**数学推导严谨**，无解条件判断全面。作者通过`bitset`处理二进制位，先填充C的0的位（同1），再处理C的1的位（分配给X或Y）。其**亮点**在于：总结了4个无解条件（a+b < C的1的个数、奇偶性不同、填充数量超过限制、|a-b|>C的1的个数），覆盖了所有边界情况，确保代码的健壮性。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何全面判断无解？**  
* **分析**：  
  无解的情况主要有4种：  
  - **a+b < popcount(C)**：C的1的位需要X和Y各出一个1，但总数量不够。  
  - **(a+b - popcount(C)) % 2 != 0**：填充C的0的位时，每填充一次增加2个1（X和Y各1），所以总增量必须是偶数。  
  - **(a+b - popcount(C))/2 > (60 - popcount(C))**：C的0的位数量有限（最多60 - popcount(C)），无法填充足够的1。  
  - **|a - b| > popcount(C)**：比如a=5、b=1、popcount(C)=2，此时X需要在C的1的位中分配3个1（超过C的1的个数），无解。  
* 💡 **学习笔记**：无解条件是解题的“安全绳”，必须全面考虑，避免遗漏边界情况。  

### 2. **难点2：如何分配C的1的位？**  
* **分析**：  
  对于C的每一位1，应**贪心选择**：优先给当前需要更多1的数（比如a>b时给X）。这样可以尽量平衡X和Y的1的数量，避免后续填充0的位时出现不足。  
* 💡 **学习笔记**：贪心策略的核心是“局部最优”，即每一步都选择对当前最有利的选项，最终达到全局最优。  

### 3. **难点3：如何处理数据类型？**  
* **分析**：  
  由于X和Y小于2^60，必须使用**64位整数**（如`long long`或`unsigned long long`）。否则，左移操作会导致溢出，结果错误。  
* 💡 **学习笔记**：处理大数时，一定要注意数据类型的范围，避免溢出。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合优质题解思路，提炼出的清晰实现（使用数组存储二进制位，分步骤处理1和0的位）。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  typedef long long ll;

  int main() {
      ll a, b, c;
      cin >> a >> b >> c;
      vector<int> C(60, 0); // C的二进制位（0~59位）
      int popC = 0;
      for (int i = 0; i < 60; ++i) {
          if (c >> i & 1) {
              C[i] = 1;
              popC++;
          }
      }

      // 无解判断
      if (a + b < popC || (a + b - popC) % 2 != 0) {
          cout << -1 << endl;
          return 0;
      }
      int k = (a + b - popC) / 2; // 需要填充的0的位数量
      if (k > (60 - popC)) {
          cout << -1 << endl;
          return 0;
      }

      ll X = 0, Y = 0;
      // 处理C的1的位
      for (int i = 0; i < 60; ++i) {
          if (C[i] == 1) {
              if (a > b) {
                  X |= 1LL << i;
                  a--;
              } else {
                  Y |= 1LL << i;
                  b--;
              }
          }
      }

      // 处理C的0的位（填充同1）
      for (int i = 0; i < 60 && k > 0; ++i) {
          if (C[i] == 0) {
              X |= 1LL << i;
              Y |= 1LL << i;
              a--;
              b--;
              k--;
          }
      }

      // 最终检查
      if (a == 0 && b == 0) {
          cout << X << " " << Y << endl;
      } else {
          cout << -1 << endl;
      }

      return 0;
  }
  ```
* **代码解读概要**：  
  1. 将C转换为二进制位数组，计算其1的个数`popC`。  
  2. 进行无解判断（数量、奇偶性、填充限制）。  
  3. 处理C的1的位：贪心分配给X或Y，减少对应的`popcount`需求。  
  4. 处理C的0的位：填充同1，直到满足`popcount`要求。  
  5. 输出结果（或-1）。  

### 题解一（zengziqvan）核心片段赏析  
* **亮点**：用数组存储每一位，直观反映X和Y的二进制位。  
* **核心代码片段**：  
  ```cpp
  int in[70], A[70], B[70];
  // 处理C的1的位
  for (int i = 1; i <= tot; ++i) {
      if (in[i]) {
          if (a <= b) {
              B[i] = 1;
              b--;
          } else {
              A[i] = 1;
              a--;
          }
      }
  }
  // 处理C的0的位
  for (int i = 1; i <= tot && a > 0; ++i) {
      if (!in[i]) {
          A[i] = B[i] = 1;
          a--;
          b--;
      }
  }
  ```
* **代码解读**：  
  - `in[i]`存储C的第i位（1或0），`A[i]`和`B[i]`分别存储X和Y的第i位。  
  - 处理1的位时，若a<=b（Y需要更多1），则将B的该位设为1，减少b；否则将A的该位设为1，减少a。  
  - 处理0的位时，若a>0（还需要填充），则将A和B的该位都设为1，减少a和b。  
* 💡 **学习笔记**：数组存储二进制位是处理位运算问题的常用方法，直观且易调试。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**“二进制位的分配游戏”**（8位像素风格，仿FC游戏）  

### 核心演示内容  
1. **初始化**：  
   - 屏幕左侧显示C的二进制位（共60位，1为红色方块，0为蓝色方块）。  
   - 屏幕右侧显示X和Y的二进制位（初始为灰色方块）。  
   - 顶部显示`a`和`b`的当前值（如`a=3`、`b=4`）。  

2. **处理C的1的位**：  
   - 红色方块从C的位置移动到X或Y的位置（根据贪心策略，比如a>b时移动到X）。  
   - 对应的`a`或`b`值减少1（如`a`从3变为2）。  
   - 播放“叮”的音效（提示分配成功）。  

3. **处理C的0的位**：  
   - 蓝色方块同时变为X和Y的绿色方块（表示同1）。  
   - `a`和`b`值各减少1（如`a`从2变为1，`b`从4变为3）。  
   - 播放“嗡”的音效（提示填充成功）。  

4. **结束状态**：  
   - 若成功分配，X和Y的二进制位显示为绿色（1）和灰色（0），顶部显示“成功！”，播放胜利音效。  
   - 若无解，屏幕显示“-1”，播放失败音效。  

### 交互设计  
- **控制按钮**：“单步执行”（查看每一步）、“自动播放”（加速演示）、“重置”（重新开始）。  
- **速度滑块**：调整自动播放的速度（从慢到快）。  
- **提示框**：显示当前操作的说明（如“将C的第5位分配给X”）。  

### 设计理由  
- **像素风格**：营造复古游戏氛围，降低学习压力。  
- **动画效果**：通过移动和颜色变化，直观展示位分配过程。  
- **音效**：强化操作记忆，增加趣味性。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的**位运算+贪心**思路可用于以下场景：  
- **二进制位构造问题**：如给定多个条件（异或、与、或），构造满足条件的数。  
- **popcount优化问题**：如计算满足特定popcount的数的个数。  
- **位操作游戏**：如“翻转二进制位”“统计不同位的数量”等。  

### 洛谷练习推荐  
1. **洛谷 P1226** - 《快速幂模板》  
   - 🗣️ **推荐理由**：巩固快速幂（或左移）的使用，避免位运算中的溢出问题。  
2. **洛谷 P1822** - 《魔法指纹》  
   - 🗣️ **推荐理由**：练习二进制位的构造，结合贪心策略解决问题。  
3. **洛谷 P2081** - 《手机》  
   - 🗣️ **推荐理由**：熟悉位运算的应用，处理二进制位的统计问题。  


## 7. 学习心得与经验分享（若有）  
- **来自zengziqvan的经验**：“在处理C的1的位时，一定要优先给需要更多1的数，这样可以避免后续填充0的位时出现不足。”  
  - **点评**：这一经验强调了贪心策略的重要性，直接关系到是否能正确填充0的位。  
- **来自wangbinfeng的经验**：“无解条件必须全面，尤其是|a-b|>popcount(C)的情况，容易被忽略。”  
  - **点评**：这一经验提醒我们，在解决位运算问题时，要仔细分析变量之间的关系，避免遗漏边界情况。  


## 结语  
本次分析让我们深入理解了**位运算的性质**和**贪心策略的应用**。记住：解决位运算问题的关键是**分位处理**，而贪心策略是平衡资源（如1的数量）的有效方法。希望大家通过练习，能熟练掌握这些技巧，解决更多类似问题！💪

---
处理用时：174.71秒
# 题目信息

# [AGC034D] Manhattan Max Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc034/tasks/agc034_d

すぬけくんは、二次元平面上に赤いボールと青いボールを置いて遊んでいます。

すぬけくんはまず、赤いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (RX_i,RY_i) $ に $ RC_i $ 個の赤いボールを置きました。 すぬけくんは次に、青いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (BX_i,BY_i) $ に $ BC_i $ 個の青いボールを置きました。 ここで、すぬけくんが置いた赤いボールの個数の総和と青いボールの個数の総和は等しいです。 つまり、$ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $ です。 以後、この値を $ S $ とおきます。

すぬけくんはこれから、赤いボールと青いボールのペアを $ S $ 個作ろうとしています。 どのボールも、ちょうど $ 1 $ つのペアに属するようにします。 ここで、座標 $ (rx,ry) $ にある赤いボールと座標 $ (bx,by) $ にある青いボールのペアのスコアを、 $ |rx-bx|\ +\ |ry-by| $ と定義します。

すぬけくんは、ペアのスコアの総和を最大化したいです。 すぬけくんのために、ペアのスコアの総和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 0\ \leq\ RX_i,RY_i,BX_i,BY_i\ \leq\ 10^9 $
- $ 1\ \leq\ RC_i,BC_i\ \leq\ 10 $
- $ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $
- 入力される値はすべて整数である。

### Sample Explanation 1

座標 $ (0,0) $ に置いてある赤いボールと座標 $ (2,2) $ に置いてある青いボールをペアにすると、 そのスコアは $ |0-2|\ +\ |0-2|=4 $ です。 また、座標 $ (3,2) $ に置いてある赤いボールと座標 $ (5,0) $ に置いてある青いボールをペアにすると、 そのスコアは $ |3-5|\ +\ |2-0|=4 $ です。 この $ 2 $ つのペアを作ると、スコアの総和は $ 8 $ になり、これが最大です。

### Sample Explanation 2

同じ座標に複数回操作を行うこともあります。

## 样例 #1

### 输入

```
2

0 0 1

3 2 1

2 2 1

5 0 1```

### 输出

```
8```

## 样例 #2

### 输入

```
3

0 0 1

2 2 1

0 0 2

1 1 1

1 1 1

3 3 2```

### 输出

```
16```

## 样例 #3

### 输入

```
10

582463373 690528069 8

621230322 318051944 4

356524296 974059503 6

372751381 111542460 9

392867214 581476334 6

606955458 513028121 5

882201596 791660614 9

250465517 91918758 3

618624774 406956634 6

426294747 736401096 5

974896051 888765942 5

726682138 336960821 3

715144179 82444709 6

599055841 501257806 6

390484433 962747856 4

912334580 219343832 8

570458984 648862300 6

638017635 572157978 10

435958984 585073520 7

445612658 234265014 6```

### 输出

```
45152033546```

# AI分析结果

# 💡 Kay的C++算法解析：AGC034D Manhattan Max Matching 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**最大费用最大流**（结合曼哈顿距离拆分技巧）


🗣️ **初步分析**：  
这道题的核心是**将红蓝球配对，使总曼哈顿距离最大**。曼哈顿距离是两点在网格中“上下左右走”的步数（比如从(0,0)到(2,2)需要走4步）。直接想，每个红球要连到所有蓝球，边权是曼哈顿距离，然后找最大匹配——但这样边数会是$O(n^2)$（比如n=1000时，边数是1e6），肯定超时！  

这时候需要**曼哈顿距离的“拆分魔法”**：  
我们知道，$|x1-x2|+|y1-y2|$等于以下四个值的**最大值**：  
$$(x1+y1) - (x2+y2),\ (x1-y1) - (x2-y2),\ (-x1+y1) + (x2-y2),\ (-x1-y1) + (x2+y2)$$  
简单说，曼哈顿距离可以拆成**两个点各自的“特征值”之和**。比如，红球的特征值是$(x1+y1)$，蓝球的特征值是$-(x2+y2)$，它们的和就是曼哈顿距离的一种可能。  

**优化建图思路**：  
- 建4个**中间点**（比如A、B、C、D），分别代表上述四种特征值组合。  
- 红球连到中间点：边权是红球的特征值（比如红球i连到A点的边权是$RX_i+RY_i$）。  
- 中间点连到蓝球：边权是蓝球的特征值（比如A点连到蓝球j的边权是$-BX_j-BY_j$）。  
- 源点连红球（容量为红球数量），蓝球连汇点（容量为蓝球数量）。  

这样边数就降到了$O(n)$（每个红球连4条边，每个蓝球连4条边）。而**最大费用最大流**会自动选择边权最大的组合（也就是正确的曼哈顿距离），因为它要最大化总费用！  


## 2. 精选优质题解参考

### 题解一（作者：justin_cao，赞14）  
* **点评**：  
  这道题解的思路**非常清晰**，完美覆盖了“拆分曼哈顿距离+费用流”的核心逻辑。代码结构规范（比如用`addx`函数统一添加双向边），变量命名易懂（`s`表示源点，`t`表示汇点，`p1-p4`表示中间点）。  
  亮点在于**SPFA求最长路**的实现——因为要找最大费用，所以把SPFA的松弛条件改成“找更大的距离”。代码中的`spfa`函数和`ans`累加方式，完全符合最大费用最大流的常规写法，适合初学者模仿。  
  实践价值很高：直接套用这个框架就能解决类似的“最大权匹配”问题，边界处理（比如中间点的容量设为`inf`）也很严谨。


### 题解二（作者：Aleph1022，赞6）  
* **点评**：  
  这道题解深入分析了**关键点之间的最短路**（比如源点到中间点、中间点到汇点），提出用20个堆维护这些路径的长度。这种思路比常规费用流更高效，适合大数据量的情况。  
  亮点在于**对费用流过程的抽象**：把增广路拆分成“源点→中间点→汇点”的组合，通过维护堆来快速找到最长路。虽然代码实现较复杂，但能帮助学习者理解费用流的本质——**寻找最优增广路径**。


### 题解三（作者：OldDriverTree，赞4）  
* **点评**：  
  这道题解提到了**模拟费用流**的优化方法，通过维护20个堆来模拟EK算法的增广过程。这种方法的时间复杂度是$O(m\log n)$（m是总流量），比常规SPFA更高效，能处理更大的数据集。  
  亮点在于**对费用流的优化思考**：当常规方法超时的时，尝试模拟增广过程，用堆来维护最优路径。这种思路能拓展学习者的视野，明白“算法不是固定的，而是可以根据问题调整的”。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何处理$O(n^2)$的边数？  
* **分析**：  
  直接建图会导致边数爆炸，无法通过。解决方案是**拆分曼哈顿距离**，将两点之间的边转化为“红球→中间点→蓝球”的两条边，边数从$O(n^2)$降到$O(n)$。  
* 💡 **学习笔记**：遇到“两点之间的权值可拆分”的问题，试试用中间点优化建图！


### 2. 难点2：如何保证拆分后的最大值正确？  
* **分析**：  
  曼哈顿距离是四个拆分式的最大值，而**最大费用最大流**会自动选择边权最大的组合。比如，红球i连到中间点A的边权是$RX_i+RY_i$，中间点A连到蓝球j的边权是$-BX_j-BY_j$，它们的和是$RX_i+RY_i - BX_j - BY_j$，也就是曼哈顿距离的一种可能。费用流会选择所有可能中的最大值，所以结果正确。  
* 💡 **学习笔记**：最大费用流的“贪心”特性，正好适合解决“求最大值”的匹配问题！


### 3. 难点3：如何设计中间点的边权？  
* **分析**：  
  拆分曼哈顿距离时，要把每个点的特征值独立出来。比如，对于拆分式$(x1+y1) - (x2+y2)$，红球的特征值是$x1+y1$，蓝球的特征值是$-(x2+y2)$，这样它们的和就是拆分式的值。中间点的作用是“传递”这些特征值，让费用流能正确计算总费用。  
* 💡 **学习笔记**：边权设计的关键是“将两点的权值拆分为独立项之和”！


### ✨ 解题技巧总结  
- **拆分技巧**：对于带有绝对值的问题（如曼哈顿距离），尝试拆分绝对值，转化为更易处理的形式。  
- **中间点优化**：当边数太多时，用中间点将“两点之间的边”拆分为“两点到中间点的边”，减少边数。  
- **费用流应用**：最大权匹配问题，优先考虑最大费用最大流（将权值作为边的费用）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自justin_cao的题解）  
* **说明**：  
  这是一份**清晰、完整的最大费用最大流实现**，包含了SPFA求最长路、增广路径的寻找和更新。代码结构规范，适合初学者模仿。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  #define maxn 1010
  #define inf 1000000007
  using namespace std;
  typedef long long ll;
  
  int read() { /* 快速读入函数，略 */ }
  
  int n, p1, p2, p3, p4, s, t;
  int head[maxn*2], nxt[maxn*20], to[maxn*20], c[maxn*20], v[maxn*20], tot=1;
  
  void add(int x, int y, int z, int u) { /* 添加单向边，略 */ }
  void addx(int x, int y, int z, int u) { add(x,y,z,u); add(y,x,0,-u); }
  
  ll ans;
  ll dis[maxn*2];
  int pre[maxn*2], pre_num[maxn*2], vis[maxn*2];
  queue<int> q;
  
  int spfa() {
      for(int i=1; i<=t; i++) dis[i] = -1e16;
      q.push(s); dis[s] = 0; vis[s] = 1;
      while(!q.empty()) {
          int now = q.front(); q.pop(); vis[now] = 0;
          for(int i=head[now]; i; i=nxt[i]) {
              if(dis[to[i]] < dis[now] + v[i] && c[i]) {
                  dis[to[i]] = dis[now] + v[i];
                  pre[to[i]] = now;
                  pre_num[to[i]] = i;
                  if(!vis[to[i]]) { q.push(to[i]); vis[to[i]] = 1; }
              }
          }
      }
      return dis[t] != -1e16;
  }
  
  int main() {
      n = read();
      p1 = 2*n+1; p2 = p1+1; p3 = p2+1; p4 = p3+1;
      s = p4+1; t = s+1;
      
      // 源点连红球，红球连中间点
      for(int i=1; i<=n; i++) {
          int x = read(), y = read(), z = read();
          addx(s, i, z, 0);
          addx(i, p1, inf, x+y);
          addx(i, p2, inf, x-y);
          addx(i, p3, inf, -x+y);
          addx(i, p4, inf, -x-y);
      }
      
      // 中间点连蓝球，蓝球连汇点
      for(int i=1; i<=n; i++) {
          int x = read(), y = read(), z = read();
          addx(i+n, t, z, 0);
          addx(p1, i+n, inf, -x-y);
          addx(p2, i+n, inf, -x+y);
          addx(p3, i+n, inf, x-y);
          addx(p4, i+n, inf, x+y);
      }
      
      // 跑最大费用最大流
      while(spfa()) {
          int di = inf;
          for(int i=t; i!=s; i=pre[i]) di = min(di, c[pre_num[i]]);
          for(int i=t; i!=s; i=pre[i]) { c[pre_num[i]] -= di; c[pre_num[i]^1] += di; }
          ans += dis[t] * di;
      }
      
      printf("%lld\n", ans);
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **建图**：源点`s`连红球（容量为红球数量），红球连4个中间点（边权为红球的特征值），中间点连蓝球（边权为蓝球的特征值），蓝球连汇点`t`（容量为蓝球数量）。  
  2. **SPFA求最长路**：`spfa`函数寻找从`s`到`t`的最长路径（因为要最大费用），记录路径上的前驱节点和边。  
  3. **增广路径**：根据`spfa`找到的路径，更新边的容量（减去流量），累加总费用（`ans += 路径长度 × 流量`）。  


### 题解一（justin_cao）片段赏析  
* **亮点**：`spfa`函数求最长路的实现，符合最大费用流的需求。  
* **核心代码片段**：  
  ```cpp
  int spfa() {
      for(int i=1; i<=t; i++) dis[i] = -1e16; // 初始化距离为极小值
      q.push(s); dis[s] = 0; vis[s] = 1;
      while(!q.empty()) {
          int now = q.front(); q.pop(); vis[now] = 0;
          for(int i=head[now]; i; i=nxt[i]) {
              // 松弛条件：找更大的距离（因为要最大费用）
              if(dis[to[i]] < dis[now] + v[i] && c[i]) {
                  dis[to[i]] = dis[now] + v[i];
                  pre[to[i]] = now; // 记录前驱节点
                  pre_num[to[i]] = i; // 记录前驱边
                  if(!vis[to[i]]) { q.push(to[i]); vis[to[i]] = 1; }
              }
          }
      }
      return dis[t] != -1e16; // 判断是否存在增广路径
  }
  ```  
* **代码解读**：  
  - `dis`数组存储从`s`到每个点的最长距离（初始为极小值）。  
  - `pre`和`pre_num`数组记录路径的前驱节点和边，方便后续更新容量。  
  - 松弛条件是“`dis[to[i]] < dis[now] + v[i]`”，也就是找更长的路径（最大费用）。  
* 💡 **学习笔记**：最大费用流的SPFA，只需把“找更短路径”改成“找更长路径”！


### 题解三（OldDriverTree）片段赏析  
* **亮点**：模拟费用流的思路，用堆维护最优路径。  
* **核心代码片段**（伪代码）：  
  ```cpp
  // 维护20个堆，分别存储关键点之间的路径长度
  priority_queue<pair<ll, int>> heap[20];
  
  while(存在增广路径) {
      // 用SPFA找关键点之间的最长路
      ll max_dist = 0;
      int path = 0;
      for(int i=0; i<20; i++) {
          if(!heap[i].empty() && heap[i].top().first > max_dist) {
              max_dist = heap[i].top().first;
              path = i;
          }
      }
      // 更新堆中的路径长度
      // ...
  }
  ```  
* **代码解读**：  
  - 用堆维护关键点（源点、中间点、汇点）之间的路径长度，快速找到最长路。  
  - 模拟EK算法的增广过程，每次选择最长路径进行增广。  
* 💡 **学习笔记**：当常规费用流超时，试试模拟增广过程，用堆优化！


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《像素球的匹配冒险》（8位像素风格）  
**设计思路**：用FC红白机的风格，将费用流的过程转化为“球的流动”，让学习者直观看到“如何选择最大曼哈顿距离”。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是**源点**（红色像素块，标注“S”），右侧是**汇点**（绿色像素块，标注“T”）。  
   - 中间上方是**红球区**（粉色像素块，标注“R1”“R2”…），中间下方是**蓝球区**（蓝色像素块，标注“B1”“B2”…）。  
   - 红球区和蓝球区之间是**中间点**（黄色像素块，标注“A”“B”“C”“D”）。  
   - 控制面板有“开始”“单步”“重置”按钮，以及速度滑块（1-5档）。  

2. **算法启动**：  
   - 源点向红球区发送“流量”（白色像素块，从S流向R1、R2…），每个红球的流量等于其数量（比如R1有1个红球，就有1个白色块流向R1）。  

3. **中间点传递**：  
   - 红球向中间点发送流量（比如R1向A点发送流量，边权显示为“RX1+RY1=5”）。  
   - 中间点向蓝球发送流量（比如A点向B1发送流量，边权显示为“-BX1-BY1=-3”）。  
   - 流量流动时，边会闪烁（灰色→白色），并播放“叮”的音效。  

4. **增广路径**：  
   - 当流量从S→R1→A→B1→T流动时，路径会被高亮（红色→粉色→黄色→蓝色→绿色），并显示总费用（5+(-3)=2）。  
   - 增广成功后，总费用会增加（比如从0变成2），并播放“咻”的音效。  

5. **结束状态**：  
   - 当所有流量都从S流向T时，汇点会闪烁绿色，播放“胜利”音效（8位风格的“叮叮当”），并显示总费用（比如样例1的8）。  


### 交互设计  
- **单步执行**：点击“单步”按钮，流量走一步（比如从S到R1），方便学习者观察每一步的变化。  
- **自动播放**：点击“开始”按钮，流量自动流动，速度可以通过滑块调整（1档最慢，5档最快）。  
- **重置**：点击“重置”按钮，所有流量回到初始状态，重新开始演示。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
- **曼哈顿距离匹配**：比如CF730I（和本题完全一致，只是数据范围更大）。  
- **最大权二分匹配**：比如洛谷P2053（选课问题，将课程视为节点，权值视为学分，求最大学分）。  
- **费用流优化建图**：比如洛谷P1251（餐巾计划问题，用中间点优化边数）。  


### 练习推荐（洛谷）  
1. **洛谷P3381** - 【模板】最小费用最大流  
   * 🗣️ **推荐理由**：巩固费用流的基本实现，学会用SPFA求最短/最长路。  
2. **洛谷P2053** - 选课  
   * 🗣️ **推荐理由**：练习最大权二分匹配，将问题转化为费用流模型。  
3. **洛谷CF730I** - Olympiad in Programming and Sports  
   * 🗣️ **推荐理由**：和本题思路完全一致，用曼哈顿距离拆分技巧优化建图。  
4. **洛谷P1251** - 餐巾计划问题  
   * 🗣️ **推荐理由**：练习费用流的复杂建图，用中间点优化边数。  


## 7. 学习心得与经验分享（来自题解）

### 参考经验（来自OldDriverTree）  
> “我在解决这个问题时，最初用常规费用流超时了，后来想到模拟增广过程，用堆维护最优路径，才通过了大数据量的测试。”  

**点评**：  
这位作者的经验很重要——**算法不是固定的，而是可以根据问题调整的**。当常规方法超时，试试优化增广过程（比如模拟费用流），或者用更高效的数据结构（比如堆）维护路径。


### 参考经验（来自justin_cao）  
> “曼哈顿距离的拆分是本题的关键，我之前做过类似的题目，所以很快想到了这个技巧。”  

**点评**：  
多做类似题目能积累经验，比如遇到“绝对值之和”的问题，试试拆分绝对值，转化为更易处理的形式。


## 结语  
本次分析的AGC034D题，核心是**用曼哈顿距离拆分技巧优化费用流建图**。通过学习这道题，你能掌握：  
- 费用流的基本实现（最大费用最大流）；  
- 曼哈顿距离的拆分技巧；  
- 中间点优化建图的方法。  

记住，编程的关键是**思路的转化**——把复杂的问题拆分成简单的子问题，用合适的算法解决。下次遇到类似的问题，试试用今天学的技巧吧！💪

---
处理用时：191.65秒
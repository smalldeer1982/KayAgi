# 题目信息

# [AGC034D] Manhattan Max Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc034/tasks/agc034_d

すぬけくんは、二次元平面上に赤いボールと青いボールを置いて遊んでいます。

すぬけくんはまず、赤いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (RX_i,RY_i) $ に $ RC_i $ 個の赤いボールを置きました。 すぬけくんは次に、青いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (BX_i,BY_i) $ に $ BC_i $ 個の青いボールを置きました。 ここで、すぬけくんが置いた赤いボールの個数の総和と青いボールの個数の総和は等しいです。 つまり、$ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $ です。 以後、この値を $ S $ とおきます。

すぬけくんはこれから、赤いボールと青いボールのペアを $ S $ 個作ろうとしています。 どのボールも、ちょうど $ 1 $ つのペアに属するようにします。 ここで、座標 $ (rx,ry) $ にある赤いボールと座標 $ (bx,by) $ にある青いボールのペアのスコアを、 $ |rx-bx|\ +\ |ry-by| $ と定義します。

すぬけくんは、ペアのスコアの総和を最大化したいです。 すぬけくんのために、ペアのスコアの総和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 0\ \leq\ RX_i,RY_i,BX_i,BY_i\ \leq\ 10^9 $
- $ 1\ \leq\ RC_i,BC_i\ \leq\ 10 $
- $ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $
- 入力される値はすべて整数である。

### Sample Explanation 1

座標 $ (0,0) $ に置いてある赤いボールと座標 $ (2,2) $ に置いてある青いボールをペアにすると、 そのスコアは $ |0-2|\ +\ |0-2|=4 $ です。 また、座標 $ (3,2) $ に置いてある赤いボールと座標 $ (5,0) $ に置いてある青いボールをペアにすると、 そのスコアは $ |3-5|\ +\ |2-0|=4 $ です。 この $ 2 $ つのペアを作ると、スコアの総和は $ 8 $ になり、これが最大です。

### Sample Explanation 2

同じ座標に複数回操作を行うこともあります。

## 样例 #1

### 输入

```
2

0 0 1

3 2 1

2 2 1

5 0 1```

### 输出

```
8```

## 样例 #2

### 输入

```
3

0 0 1

2 2 1

0 0 2

1 1 1

1 1 1

3 3 2```

### 输出

```
16```

## 样例 #3

### 输入

```
10

582463373 690528069 8

621230322 318051944 4

356524296 974059503 6

372751381 111542460 9

392867214 581476334 6

606955458 513028121 5

882201596 791660614 9

250465517 91918758 3

618624774 406956634 6

426294747 736401096 5

974896051 888765942 5

726682138 336960821 3

715144179 82444709 6

599055841 501257806 6

390484433 962747856 4

912334580 219343832 8

570458984 648862300 6

638017635 572157978 10

435958984 585073520 7

445612658 234265014 6```

### 输出

```
45152033546```

# AI分析结果



---
# 💡 Kay的C++算法解析：AGC034D Manhattan Max Matching 深入学习指南 💡

<introduction>
今天我们来一起分析“AGC034D Manhattan Max Matching”这道C++编程题。这道题的核心是通过优化建图，利用曼哈顿距离的特殊性质，结合费用流算法解决最大匹配问题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`费用流优化建图（编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键在于将曼哈顿距离的最大化问题转化为费用流模型，并通过优化建图避免边数爆炸。简单来说，费用流算法通过寻找“最大费用的增广路径”来解决带权匹配问题，但直接为每对红蓝球连边会导致边数达到$O(n^2)$，无法处理$n=1000$的规模。

在本题中，曼哈顿距离的性质是优化的突破口：  
曼哈顿距离 $|x_1-x_2| + |y_1-y_2|$ 可以拆分为以下四种情况的最大值：  
$$
\max\left\{
\begin{aligned}
&(x_1+y_1) + (-x_2-y_2), \\
&(x_1-y_1) + (-x_2+y_2), \\
&(-x_1+y_1) + (x_2-y_2), \\
&(-x_1-y_1) + (x_2+y_2)
\end{aligned}
\right\}
$$  
这意味着，我们可以通过引入4个中间点（分别对应四种情况），将原来的$O(n^2)$条边优化为$O(n)$条边：  
- 红球向4个中间点连边，费用为对应拆分后的值；  
- 蓝球从4个中间点连边，费用为对应拆分后的值的相反数；  
- 源点连红球、蓝球连汇点，容量为各自的球数。  

这样，费用流算法会自动选择最大费用的路径（即曼哈顿距离最大的匹配），从而得到正确结果。

可视化设计中，我们可以用8位像素风格展示费用流的增广过程：  
- 源点（S）、汇点（T）和4个中间点（F1-F4）用不同颜色的像素块表示；  
- 红球和蓝球用动态的“像素球”表示，移动路径高亮当前增广的边；  
- 每完成一次增广（即匹配一对球），播放“叮”的音效，并用闪烁动画标记当前选择的中间点（如F1），体现“自动选择最大费用路径”的逻辑。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性和实践价值，以下题解在优化建图和费用流实现上表现突出（评分≥4星）：
</eval_intro>

**题解一：作者justin_cao（赞：14）**  
* **点评**：这道题解思路非常清晰，直接点明了曼哈顿距离的拆分性质，并通过引入4个中间点将边数优化到$O(n)$。代码结构规范，变量命名（如`p1-p4`表示中间点）易于理解，特别是SPFA算法的实现细节（如队列优化、距离数组初始化）处理严谨。从实践角度看，代码可直接用于竞赛，边界条件（如容量为无穷大）的处理也很到位，是学习费用流优化建图的优秀参考。

**题解二：作者OldDriverTree（赞：4）**  
* **点评**：此题解不仅提供了优化建图的代码，还进一步讨论了模拟费用流的思路（如用堆维护关键点间的路径），拓展了学习者的视野。代码中对中间点的命名（如`A,B,C,D`）直观，增广过程的注释详细，适合理解费用流的核心逻辑。其提到的“CF730I类似题”也为拓展练习提供了方向。

**题解三：作者Filberte（赞：0）**  
* **点评**：此题解的代码实现简洁，核心逻辑（中间点连边）的注释清晰。通过将中间点定义为固定编号（如`n1-n4`），减少了变量冗余，适合初学者模仿。尽管赞数较少，但其代码的可读性和正确性值得肯定。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略如下：
</difficulty_intro>

1.  **关键点1**：如何将曼哈顿距离转化为可优化的费用流模型？  
    * **分析**：曼哈顿距离的绝对值形式导致直接连边无法优化，需利用其拆分后的最大值性质。优质题解通过观察发现，曼哈顿距离等于四种线性组合的最大值，因此引入4个中间点，分别对应这四种组合，将原问题转化为“选择中间点路径的最大费用流”。  
    * 💡 **学习笔记**：遇到绝对值求和问题时，尝试拆分符号并寻找最大值/最小值的等价形式，可能是优化的突破口。

2.  **关键点2**：如何设计中间点以减少边数？  
    * **分析**：每个红球向4个中间点连边（容量无穷大，费用为拆分后的值），每个蓝球从4个中间点连边（容量无穷大，费用为拆分后的值的相反数）。这样，总边数从$O(n^2)$降为$O(n)$（每个红球/蓝球连4条边，共$8n$条边）。  
    * 💡 **学习笔记**：中间点的作用是“解耦”两个点的计算，将二维匹配转化为一维路径选择，这是网络流优化的常用技巧。

3.  **关键点3**：如何正确实现最大费用流？  
    * **分析**：费用流通常求最小费用，本题需最大费用。实现时需将SPFA的松弛条件改为“更大费用”，并初始化距离数组为极小值。优质题解中通过修改SPFA的比较方向（如`dis[y] < dis[x] + cost`）确保选择最大费用路径。  
    * 💡 **学习笔记**：最大费用流与最小费用流的核心差异仅在于松弛条件的方向，其他逻辑（如增广路径的查找）一致。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将复杂的绝对值问题转化为线性组合的最大值问题，利用中间点简化模型。  
- **中间点设计**：通过引入有限数量的中间点，将二维匹配的边数从$O(n^2)$降为$O(n)$，这是网络流优化的关键。  
- **费用流细节**：注意最大费用流的松弛条件（取更大值）和距离数组的初始化（极小值），避免因方向错误导致结果错误。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，它完整展示了优化建图和费用流的核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了justin_cao和OldDriverTree的题解思路，采用SPFA实现最大费用流，中间点（p1-p4）清晰对应四种曼哈顿距离拆分情况。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define maxn 1010
    #define inf 1000000007
    using namespace std;
    typedef long long ll;

    int read() {
        int x = 0, f = 1;
        char ch = getchar();
        while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
        while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
        return x * f;
    }

    int n, p1, p2, p3, p4, s, t;
    int head[maxn * 2], nxt[maxn * 20], to[maxn * 20], c[maxn * 20], v[maxn * 20], tot = 1;
    void add(int x, int y, int z, int u) {
        ++tot; nxt[tot] = head[x]; head[x] = tot; to[tot] = y; c[tot] = z; v[tot] = u;
    }
    void addx(int x, int y, int z, int u) { add(x, y, z, u); add(y, x, 0, -u); }

    ll ans;
    ll dis[maxn * 2];
    int pre[maxn * 2], pre_num[maxn * 2], vis[maxn * 2];
    queue<int> q;

    int spfa() {
        for (int i = 1; i <= t; i++) dis[i] = -1e16;
        q.push(s); dis[s] = 0; vis[s] = 1;
        while (q.size()) {
            int now = q.front(); q.pop(); vis[now] = 0;
            for (int i = head[now]; i; i = nxt[i]) {
                if (dis[to[i]] < dis[now] + v[i] && c[i]) {
                    dis[to[i]] = dis[now] + v[i];
                    pre[to[i]] = now; pre_num[to[i]] = i;
                    if (!vis[to[i]]) q.push(to[i]), vis[to[i]] = 1;
                }
            }
        }
        if (dis[t] == -1e16) return 0;
        int di = inf;
        for (int i = t; i != s; i = pre[i]) di = min(di, c[pre_num[i]]);
        for (int i = t; i != s; i = pre[i]) c[pre_num[i]] -= di, c[pre_num[i] ^ 1] += di;
        ans += dis[t] * di;
        return di;
    }

    int main() {
        n = read();
        p1 = 2 * n + 1; p2 = p1 + 1; p3 = p2 + 1; p4 = p3 + 1; s = p4 + 1; t = s + 1;

        for (int i = 1; i <= n; i++) {
            int x = read(), y = read(), z = read();
            addx(s, i, z, 0);
            addx(i, p1, inf, x + y);
            addx(i, p2, inf, x - y);
            addx(i, p3, inf, -x + y);
            addx(i, p4, inf, -x - y);
        }

        for (int i = 1; i <= n; i++) {
            int x = read(), y = read(), z = read();
            addx(i + n, t, z, 0);
            addx(p1, i + n, inf, -x - y);
            addx(p2, i + n, inf, -x + y);
            addx(p3, i + n, inf, x - y);
            addx(p4, i + n, inf, x + y);
        }

        while (spfa()) {};
        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入，初始化源点（s）、汇点（t）和4个中间点（p1-p4）。红球节点（1~n）从源点连入，容量为红球数，费用0；每个红球向4个中间点连边，费用为对应拆分后的值。蓝球节点（n+1~2n）向汇点连出，容量为蓝球数，费用0；每个中间点向蓝球连边，费用为对应拆分后的值的相反数。通过SPFA寻找最大费用增广路径，最终输出总费用。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其亮点和关键逻辑。
</code_intro_selected>

**题解一：作者justin_cao**  
* **亮点**：代码结构清晰，中间点命名直观（p1-p4），SPFA实现中正确处理了最大费用的松弛条件。  
* **核心代码片段**：
    ```cpp
    // 红球连中间点
    addx(i, p1, inf, x + y);
    addx(i, p2, inf, x - y);
    addx(i, p3, inf, -x + y);
    addx(i, p4, inf, -x - y);

    // 中间点连蓝球
    addx(p1, i + n, inf, -x - y);
    addx(p2, i + n, inf, -x + y);
    addx(p3, i + n, inf, x - y);
    addx(p4, i + n, inf, x + y);
    ```
* **代码解读**：  
  这部分代码实现了红球到中间点、中间点到蓝球的连边。例如，`addx(i, p1, inf, x + y)`表示红球i向中间点p1连一条容量无穷大、费用为$x_i+y_i$的边；`addx(p1, i+n, inf, -x-y)`表示中间点p1向蓝球i+n连一条容量无穷大、费用为$-(x_j+y_j)$的边。这样，当费用流选择p1路径时，总费用为$(x_i+y_i) + (-x_j-y_j) = (x_i-x_j)+(y_i-y_j)$，即曼哈顿距离的一种情况。  
* 💡 **学习笔记**：中间点的费用设计是关键，需确保每条路径的费用对应曼哈顿距离的一种拆分情况。

**题解二：作者OldDriverTree**  
* **亮点**：提出了模拟费用流的思路（用堆维护关键点路径），适合进一步优化。  
* **核心代码片段**：
    ```cpp
    // 模拟费用流的关键点堆维护（伪代码）
    for 每个关键点对(p, q):
        维护堆保存p到非关键点再到q的路径费用
    while 存在增广路径:
        选择费用最大的路径增广
        更新堆中的路径费用
    ```
* **代码解读**：  
  此片段是对优化费用流的思路概括。关键点（源点、汇点、中间点）间的路径费用可通过堆快速查询最大值，避免了传统SPFA的全图遍历，时间复杂度更优。  
* 💡 **学习笔记**：当边数极大时，模拟费用流（如用堆维护关键点路径）是进一步优化的方向。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解费用流的增广过程和中间点的作用，我们设计一个“像素探险家”主题的8位风格动画，展示红球、蓝球通过中间点匹配的过程。
</visualization_intro>

  * **动画演示主题**：`像素探险家的曼哈顿寻宝`  
  * **核心演示内容**：展示源点（S）发出的“红像素球”如何通过中间点（F1-F4）找到对应的“蓝像素球”，每次增广选择费用最大的路径（即曼哈顿距离最大的匹配）。  

  * **设计思路简述**：  
    采用8位像素风格（如FC红白机的简洁色调），用不同颜色区分节点（S绿色、T紫色、F1-F4分别为红/蓝/黄/橙）。动画通过“像素球移动”和“边高亮”展示增广路径，配合音效强化关键操作（如匹配成功时的“叮”声），帮助学习者理解中间点如何“自动选择最大费用路径”。

  * **动画帧步骤与交互关键点**：  
    1. **场景初始化**：  
       - 屏幕分为左右两部分：左侧为红球区（红色像素块），右侧为蓝球区（蓝色像素块），中间是4个中间点（F1-F4）。  
       - 控制面板包含“单步”“自动播放”“调速”按钮，初始时所有边为灰色（未激活）。  

    2. **增广启动**：  
       - 源点S（绿色块）释放“红像素球”，每个球代表一个红球。球移动到对应的红球节点（如红球1），触发“入队”音效（轻脆的“滴”声）。  

    3. **中间点选择**：  
       - 红球节点向F1-F4发射4条边（颜色对应中间点），每条边显示当前费用（如F1边显示“x+y”）。  
       - 动画高亮费用最大的边（如F1边变金色），红像素球沿此边移动到F1，触发“选择”音效（短促的“叮”声）。  

    4. **蓝球匹配**：  
       - F1向所有蓝球节点发射边，费用为“-x-y”。动画同样高亮费用最大的边（如蓝球3的边变金色），像素球移动到蓝球3，再移动到汇点T（紫色块），触发“匹配成功”音效（上扬的“叮咚”声）。  

    5. **状态更新**：  
       - 匹配的红球和蓝球标记为已用（变灰色），边的容量减少（用动态数字显示），总费用增加（顶部显示当前总和）。  

    6. **自动演示模式**：  
       - 点击“AI自动演示”，算法自动执行增广，像素球快速移动，边按费用大小依次高亮，展示最大费用流的全局最优过程。  

  * **旁白提示**：  
    - （中间点选择时）“看！F1边的费用最大，像素球会选择这条路径哦～”  
    - （匹配成功时）“匹配完成！总费用增加了当前路径的费用，这就是曼哈顿距离的最大值～”  

<visualization_conclusion>
通过这个动画，我们能直观看到费用流如何通过中间点选择最大费用路径，理解曼哈顿距离拆分和优化建图的核心逻辑。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题的优化建图和费用流后，我们可以尝试以下拓展练习，巩固相关技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的“中间点优化”思路适用于所有需要将二维匹配转化为一维路径选择的问题，例如：  
    - 二维平面上的最大权匹配（如仓库选址问题）；  
    - 带权二分图匹配的其他距离（如切比雪夫距离，可通过坐标变换转化为曼哈顿距离）；  
    - 多条件约束的资源分配问题（如任务分配中的多维度权重）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P3389** - 【模板】高斯消元法  
        * 🗣️ **推荐理由**：巩固网络流模型的建立，理解费用流在匹配问题中的应用。  
    2.  **洛谷 CF730I** - Olympiad in Programming and Sports  
        * 🗣️ **推荐理由**：与本题类似，需通过优化建图解决二维匹配问题，适合练习中间点设计。  
    3.  **洛谷 P4015** - 运输问题  
        * 🗣️ **推荐理由**：考察费用流的基础应用，适合强化费用流代码实现能力。  

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者提到了调试中的经验，例如：
</insights_intro>

> **参考经验 (来自作者OldDriverTree)**：“最初直接暴力建图导致边数爆炸，后来想到曼哈顿距离的拆分性质，通过中间点优化才通过。这让我意识到，遇到绝对值问题时，拆分符号并寻找等价形式是关键。”

**点评**：这位作者的经验非常实用。在编程竞赛中，当遇到高复杂度的问题时，观察问题的数学性质（如本题的曼哈顿距离拆分）往往是优化的突破口。学习者在遇到类似问题时，应多尝试数学推导，寻找问题的特殊性质。

---

<conclusion>
本次关于“AGC034D Manhattan Max Matching”的C++解题分析就到这里。希望这份指南能帮助你理解费用流优化建图的核心技巧，并通过可视化动画直观感受算法过程。记住，多思考问题的数学本质，多练习代码实现，编程能力会不断提升！下次挑战新题见～💪
</conclusion>

---

---
处理用时：178.67秒
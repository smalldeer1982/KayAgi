# 题目信息

# [ARC016D] 軍艦ゲーム

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc016/tasks/arc016_4

高橋君は艦長である。  
 高橋艦長の任務は、鎮守府のある海域から最終目的地となる海域へ進軍することである。  
 高橋艦長は次の順序で行動する。

1. 航路選択

- 進軍する航路を選択する。現在の海域から異なる海域へ移動できる航路が $ 1 $ 本も存在しない場合、$ 4 $ の海域離脱を行う。
- また、現在の海域から異なる海域への航路が複数本存在する場合、何者かの陰謀によって等確率で航路が選択される。
- たとえば、鎮守府のある海域から、他の海域への航路が $ 4 $ 本存在する場合、それぞれ $ 25% $ の確率で選択されます。


4. 進軍
- 選択された航路によって、海域を移動する。

6. 戦闘
- 進軍先の海域 $ i $ には敵艦が待ち構えており、戦闘が発生する。
- 鎮守府から出港したとき、高橋艦長が率いる軍艦の体力は $ H $ であり、戦闘によって軍艦の体力は $ D_i $ だけ減少する。
- 軍艦の体力が $ 0 $ 以下になると、軍艦は沈没してしまう。
- 軍艦が沈没すると高橋艦長は失意のあまりこれ以上出撃することが出来なくなってしまうため、`絶対に沈没させてはいけない`。
- なお、鎮守府のある海域では戦闘は発生しないが、最終目的地である海域では必ず戦闘が発生する。

8. 海域離脱 or 航路選択に戻る
- 海域離脱とは、鎮守府のある海域へ戻ることを意味する。
- 海域離脱した際に、軍艦の残り体力が $ C $ であった場合、$ H-C $ だけ体力回復のために時間を消費する。
 
 上記`1`,`2`,`3`,`4`のサイクル1回につき時間を $ 1 $ だけ使う。  
- - - - - -

 海域と航路について - いま、$ N $ 個の海域と $ M $ 個の航路がある。
- これら $ M $ 個の航路は、すべて一方通行である。
 
 そのため、任意の異なる海域 $ A,B $ において、ある $ 1 $ 本の航路を利用して、海域 $ A $ から海域 $ B $ へ移動し、海域 $ B $ から海域 $ A $ へ移動することはできない。  
- - - - - -

 あなたは高橋艦長の参謀であり、高橋艦長が消費する時間を最小となるよう行動した場合、最終目的地における戦闘で生存するまでに経過する時間の期待値を求めることが仕事である。  
 どのようにしても高橋艦長が任務を完遂できない場合は`-1`と出力せよ。  
 ただし、出力する期待値が $ 10^6 $ より大きくなる入力は与えられない。 入力は以下の形式で標準入力から与えられる。 > $ N $ $ M $ $ H $ $ f_1 $ $ t_1 $ $ f_2 $ $ t_2 $ : $ f_M $ $ t_M $ $ D_1 $ $ D_2 $ : $ D_N $

1. $ 1 $ 行目は、海域数を表す整数 $ N\ (2≦N≦100) $、航路数を表す整数 $ M\ (0≦M≦N\ *\ (N\ -\ 1)\ /\ 2) $、出港時の艦隊の体力を表す整数 $ H\ (1≦H≦100) $ が半角空白区切りで与えられる。

- 鎮守府のある海域は $ 1 $ で、最終目的地である海域は $ N $ です。

32. $ 2 $ 行目から $ M $ 行は、 $ i $ 番目の航路を表す。移動元の海域を表す整数 $ f_i\ (1≦f_i≦N) $、移動先の海域を表す整数 $ t_i\ (1≦t_i≦N) $ が、スペース区切りで与えられる。
- $ f_i\ <\ t_i $ であることが保証されている。

34. $ 2+M $ 行目から $ N $ 行は、$ i $ 番目の海域での戦闘で受けるダメージを表す整数 $ D_i\ (0≦D_i≦100) $ が、一行で与えられる。
- $ D_1 $ の値は常に $ 0 $ である（鎮守府のある海域です）。

- 出力する期待値が $ 10^6 $ より大きくなる入力が与えられないことに留意せよ。
 
 高橋艦長が消費する時間が最小となるよう行動した場合、最終目的地における戦闘で生存するまでに経過する時間の期待値を出力せよ。  
 出力は絶対誤差あるいは相対誤差の少なくとも片方が $ 10^{-6} $ 以下であれば許容される。   
 また、どのようにしても高橋艦長が任務を完遂できない場合は`-1`と出力せよ。  
 なお、出力の最後には改行をいれること。  

- 鎮守府のある $ 1 $ から、最終目的地である $ 6 $ までは、$ 2 $ 通りの経路があります。

1. 1 -&gt; 2 -&gt; 4 -&gt; 6

- このルートが選択される確率は $ 50% $ です。
- このルートで軍艦が受けるダメージは $ 0+1+2+4=7 $ です。
- このルートで消費する時間は、サイクル $ 3 $ 回の時間のみなので、$ 3 $ です。

48. 1 -&gt; 3 -&gt; 5 -&gt; 6
- このルートが選択される確率は $ 50% $ です。
- このルートで軍艦が受けるダメージは $ 0+1+3+4=8 $ です。
- 出港時の軍艦の体力は $ 8 $ なので、このルートでは沈没してしまいます。
- 高橋艦長は、沈没を避けるため、海域 $ 3 $ の戦闘終了時に海域離脱を選択します。
- このルートで消費する時間は、サイクル $ 1 $ 回の時間 $ + $ 体力の回復にかかる時間 $ = $ $ 1+1=2 $ です。
 
 1 -&gt; 3 -&gt; 5 -&gt; 6 で `1` 度撤退してから 1-&gt; 2-&gt; 4 -&gt; 6 - $ 50% $ の確率で 1 -&gt; 3 -&gt; 5 -&gt; 6 が選択され、時間 $ 2 $ を使って鎮守府に戻る。
- その後、 $ 50% $ の確率で 1 -&gt; 2 -&gt; 4 -&gt; 6 が選択され、時間 $ 3 $ を使って最終目的地に到達する。
- つまり、$ 25% $ の確率で時間 $ 5 $ を使って最終目的地に到達。
 
 1 -&gt; 3 -&gt; 5 -&gt; 6 で `2` 度撤退してから 1-&gt; 2-&gt; 4 -&gt; 6 - $ 12.5% $ の確率で時間 $ 7 $ を使って最終目的地に到達。
 
 1 -&gt; 3 -&gt; 5 -&gt; 6 で `3` 度撤退してから 1-&gt; 2-&gt; 4 -&gt; 6 - $ 6.25% $ の確率で時間 $ 9 $ を使って最終目的地に到達。

62. 上記から、求める期待値は $ 3*0.5+5*0.25+7*0.125+...=5 $ となります。


## 样例 #1

### 输入

```
6 6 8
1 2
1 3
2 4
3 5
4 6
5 6
0
1
1
2
3
4```

### 输出

```
5.0```

## 样例 #2

### 输入

```
3 2 5
1 2
1 3
0
5
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 2 6
1 2
1 3
0
5
1```

### 输出

```
7```

## 样例 #4

### 输入

```
9 13 4
1 2
1 3
2 4
2 5
2 7
3 5
3 6
4 7
5 8
6 8
7 8
7 9
8 9
0
1
1
1
1
1
1
1
1```

### 输出

```
36.9999999999999```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC016D] 軍艦ゲーム 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案 + 期望动态规划（DP）


🗣️ **初步分析**：  
这道题的核心是**计算到达终点的最小期望时间**，但存在两个关键挑战：  
1. **状态后效性**：返回起点（镇守府）的操作会导致状态`f[1][H]`（起点满体力时的期望时间）出现在其他状态的转移方程中，形成循环依赖。  
2. **期望计算的复杂性**：每次选择航路是等概率的，需要考虑所有可能的路径及其概率。  

**核心算法思路**：  
- **期望DP**：定义`f[x][i]`表示在海域`x`、剩余体力`i`时，到达终点的最小期望时间。  
- **二分答案**：由于`f[1][H]`的后效性，我们假设其值为`mid`，通过DP计算实际的`f[1][H]`，并调整`mid`直到两者相等（类似于“猜数字游戏”，逐步逼近正确答案）。  

**可视化设计思路**：  
我们用**8位像素风格**模拟海域网格（1号为红色起点，N号为金色终点），体力用数字显示在像素块上方。动画将展示：  
- 二分过程：屏幕顶部显示当前`mid`值，用进度条表示二分范围的收缩。  
- DP状态转移：每个海域的像素块会闪烁，显示当前处理的`f[x][i]`，选择航路时用箭头指向下一步，返回起点时播放“嗡”的音效并恢复体力。  
- 关键操作高亮：当体力即将耗尽时，像素块变为红色，提示“必须返回起点”；到达终点时播放“胜利”音效，屏幕显示“任务完成！”。  


## 2. 精选优质题解参考

### 题解一（作者：iMya_nlgau，赞：9）  
* **点评**：  
  这份题解的**亮点**是**严格证明了二分的单调性**（通过导数分析`g(A) = f[1][H]`的变化率≤1），确保了二分的正确性。代码中用`DFS`遍历DAG（有向无环图），按拓扑序计算`f[x][i]`，逻辑清晰。特别是处理`f[1][H]`时，直接将其与`mid`比较，避免了循环依赖，非常巧妙。从实践角度看，代码的边界处理（如`f[n][j] = 0`、`j-d[y] ≤0`时设为无穷大）非常严谨，适合竞赛参考。


### 题解二（作者：Locix_Elaina_Celome，赞：4）  
* **点评**：  
  此题解的**亮点**是**用拓扑排序处理DAG**，确保了DP状态的计算顺序（从终点到起点）。代码中用队列维护出度为0的节点，逐步更新前驱节点的`f[x][i]`，避免了递归的栈溢出问题。此外，作者对“必须返回起点”的条件（如`u≠1`时才能取`min`）处理得非常细致，体现了对题意的深刻理解。


### 题解三（作者：123456xwd，赞：2）  
* **点评**：  
  这份题解的**亮点**是**代码简洁易懂**，用记忆化搜索（`DFS`+`vis`数组）实现DP，逻辑直接。作者将`f[x][i]`的计算封装在`dfs`函数中，清晰展示了状态转移的过程（求和、取平均、加1、与返回起点的时间比较）。虽然没有严格证明单调性，但通过感性理解二分的正确性，适合初学者快速上手。


## 3. 核心难点辨析与解题策略

### 1. **难点1：状态后效性的处理**  
* **问题**：返回起点的操作会导致`f[1][H]`出现在其他状态的转移方程中，形成循环（如`f[x][i] = min(..., H-i + f[1][H])`）。  
* **解决方案**：**二分答案**。假设`f[1][H] = mid`，将其作为已知量代入DP方程，计算实际的`f[1][H]`。若计算结果大于`mid`，说明`mid`太小，需要增大；否则减小`mid`，直到两者相等。  
* 💡 **学习笔记**：后效性问题常可通过“假设答案→验证答案”的二分法解决。


### 2. **难点2：状态转移方程的设计**  
* **问题**：如何兼顾“继续前进”和“返回起点”两种选择？  
* **解决方案**：`f[x][i] = min(1 + (1/out[x])∑f[y][i-D[y]], H-i + mid)`，其中：  
  - 第一项表示等概率选择一条出边，前进并花费1时间；  
  - 第二项表示返回起点，恢复体力（花费`H-i`时间）并重新开始（`mid`是假设的`f[1][H]`）。  
* 💡 **学习笔记**：状态转移方程需覆盖所有可能的选择，并用`min`选取最优策略。


### 3. **难点3：无解的判断**  
* **问题**：若无论如何都无法到达终点（如路径中体力必然耗尽），如何判断？  
* **解决方案**：若二分后的`mid`超过`1e6`（题目限制），则输出`-1`。因为题目保证输入的期望不会超过`1e6`，若`mid`超过此值，说明无法完成任务。  
* 💡 **学习笔记**：无解情况通常对应极端值（如无穷大或超过题目限制）。


### ✨ 解题技巧总结  
- **二分答案**：处理后效性或难以直接计算的答案问题。  
- **拓扑排序**：处理DAG的DP状态，确保计算顺序正确。  
- **记忆化搜索**：简化递归实现，避免重复计算。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合三个题解的思路，采用二分答案+记忆化搜索的实现，逻辑清晰，适合初学者理解。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <cstring>
  #include <cmath>
  using namespace std;
  
  const int N = 105;
  const double eps = 1e-9;
  const double INF = 1e12;
  
  int n, m, H, D[N];
  vector<int> G[N];
  double dp[N][N];
  bool vis[N][N];
  
  double dfs(int u, int i, double mid) {
      if (i <= 0) return INF;
      if (u == n) return 0;
      if (G[u].empty()) return H - i + mid; // 无出边，返回起点
      if (vis[u][i]) return dp[u][i];
      vis[u][i] = true;
      double ans = 0;
      for (int v : G[u]) {
          ans += dfs(v, i - D[v], mid);
      }
      ans /= G[u].size();
      ans += 1; // 花费1时间前进
      ans = min(ans, (double)(H - i) + mid); // 比较返回起点的时间
      return dp[u][i] = ans;
  }
  
  bool check(double mid) {
      memset(vis, 0, sizeof(vis));
      double res = dfs(1, H, mid);
      return fabs(res - mid) <= eps;
  }
  
  int main() {
      cin >> n >> m >> H;
      for (int i = 0; i < m; i++) {
          int u, v;
          cin >> u >> v;
          G[u].push_back(v);
      }
      for (int i = 1; i <= n; i++) {
          cin >> D[i];
      }
      double l = 0, r = 1e6 + 10;
      while (r - l > eps) {
          double mid = (l + r) / 2;
          if (check(mid)) {
              l = mid;
          } else {
              r = mid;
          }
      }
      if (l > 1e6) {
          cout << -1 << endl;
      } else {
          printf("%.6lf\n", l);
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三部分：  
  1. **DFS函数**：计算`f[u][i]`，处理状态转移（前进或返回起点）。  
  2. **check函数**：验证假设的`mid`是否等于实际的`f[1][H]`。  
  3. **主函数**：二分答案，调用`check`函数调整`mid`，输出结果。


### 题解一：DFS+拓扑序（作者：iMya_nlgau）  
* **亮点**：严格证明二分单调性，用`DFS`按拓扑序计算`f[x][i]`。  
* **核心代码片段**：  
  ```cpp
  void dfs(int x) {
      v[x] = true;
      for (int j = 1; j <= H; j++) f[x][j] = 0;
      int deg = 0;
      for (int i = head[x]; i; i = edge[i].next) {
          int y = edge[i].to;
          if (!v[y]) dfs(y);
          for (int j = 1; j <= H; j++) {
              if (j - d[y] <= 0) f[x][j] = inf;
              else f[x][j] += f[y][j - d[y]];
          }
          deg++;
      }
      for (int j = 1; j <= H; j++) {
          if (x < n) {
              if (x == 1 && j == H) f[x][j] = 1 + f[x][j] / deg;
              else f[x][j] = min(A + H - j, 1 + f[x][j] / deg);
          } else {
              f[x][j] = 0;
          }
      }
  }
  ```  
* **代码解读**：  
  这段代码用`DFS`遍历DAG，先计算子节点的`f[y][j-d[y]]`，再计算父节点的`f[x][j]`。其中`A`是假设的`f[1][H]`，`deg`是`x`的出边数量，`1 + f[x][j]/deg`表示等概率选择出边的期望时间。  
* 💡 **学习笔记**：拓扑序遍历是处理DAG DP的常用方法，确保状态依赖的正确性。


### 题解二：拓扑排序+队列（作者：Locix_Elaina_Celome）  
* **亮点**：用队列维护出度为0的节点，按拓扑序更新`f[x][i]`。  
* **核心代码片段**：  
  ```cpp
  queue<int> q;
  for (int i = 1; i <= n; i++) {
      d[i] = d2[i];
      if (d2[i] == 0) {
          q.push(i);
          for (int j = 1; j <= h; j++) {
              dp[i][j] = h - j + mid;
          }
      }
  }
  while (!q.empty()) {
      int u = q.front();
      q.pop();
      for (int i = fir[u]; i; i = las[i]) {
          int v = t[i];
          for (int j = a[u] + 1; j <= h; j++) {
              dp[v][j] += (dp[u][j - a[u]] + 1) / d2[v];
          }
          if (--d[v] == 0) {
              q.push(v);
          }
      }
  }
  ```  
* **代码解读**：  
  这段代码用队列处理出度为0的节点（无出边，只能返回起点），然后逐步更新前驱节点的`f[v][j]`。其中`d2[v]`是`v`的出边数量，`(dp[u][j - a[u]] + 1)/d2[v]`表示从`v`到`u`的期望时间。  
* 💡 **学习笔记**：拓扑排序可以避免递归，适合处理大规模DAG。


### 题解三：记忆化搜索（作者：123456xwd）  
* **亮点**：代码简洁，用`vis`数组避免重复计算。  
* **核心代码片段**：  
  ```cpp
  double dfs(int u, int i, double mid) {
      if (i <= 0) return INF;
      if (u == n) return 0;
      if (G[u].empty()) return H - i + mid;
      if (vis[u][i]) return dp[u][i];
      vis[u][i] = true;
      double ans = 0;
      for (int v : G[u]) {
          ans += dfs(v, i - D[v], mid);
      }
      ans /= G[u].size();
      ans += 1;
      ans = min(ans, (double)(H - i) + mid);
      return dp[u][i] = ans;
  }
  ```  
* **代码解读**：  
  这段代码用`dfs`函数递归计算`f[u][i]`，`vis`数组标记已计算的状态，避免重复递归。其中`ans`是等概率选择出边的期望时间，`min`函数比较返回起点的时间。  
* 💡 **学习笔记**：记忆化搜索是递归实现DP的常用方法，代码逻辑清晰。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：**像素军舰探险记**  
采用**8位FC红白机风格**，背景是蓝色海域，1号海域是红色起点（有“镇守府”字样），N号海域是金色终点（有“目的地”字样），其他海域是灰色像素块。体力用白色数字显示在海域上方。


### 🚀 核心演示内容  
1. **场景初始化**：  
   - 屏幕顶部显示“二分范围：L=0，R=1e6”，中间是海域网格，底部是控制面板（单步、自动、重置、速度滑块）。  
   - 播放8位风格的背景音乐（轻快的鼓点）。

2. **二分过程**：  
   - 屏幕顶部的`mid`值（当前猜测的`f[1][H]`）用黄色字体显示，进度条表示二分范围的收缩（L到R的颜色从蓝色变为绿色）。  
   - 每次二分后，播放“滴”的音效，提示“当前猜测值：mid=XX”。

3. **DP状态转移**：  
   - 选中的海域（如`x=2`）会闪烁红色，体力`i=5`用白色数字显示在上方。  
   - 选择航路时，用黄色箭头指向下一步（如`2→4`），播放“叮”的音效，同时体力减少`D[4]`（如`5→3`）。  
   - 若体力即将耗尽（如`i=2`，`D[5]=3`），海域变为红色，提示“必须返回起点”，播放“嗡”的音效，体力恢复到`H`（如`8`），时间增加`H-i`（如`6`）。

4. **到达终点**：  
   - 当到达N号海域时，屏幕显示“任务完成！”，播放“胜利”音效（上扬的旋律），同时显示最终的期望时间（如`5.0`）。

5. **无解情况**：  
   - 若二分后的`mid`超过`1e6`，屏幕显示“任务失败！”，播放“失败”音效（短促的低音），提示“无法到达终点”。


### 🎮 交互设计  
- **单步执行**：点击“单步”按钮，动画执行一步（如二分一次、处理一个状态）。  
- **自动播放**：点击“自动”按钮，动画按设定速度（通过滑块调整）连续执行。  
- **重置动画**：点击“重置”按钮，恢复初始状态。  
- **算法比较**：若有多种解法（如DFS vs 拓扑排序），可以切换“算法模式”，并排演示两种算法的执行过程。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
- **二分答案**：适用于“求满足条件的最小/最大值”且答案具有单调性的问题（如“最小化期望时间”、“最大化收益”）。  
- **期望DP**：适用于“计算随机过程的期望”问题（如路径选择、游戏策略）。  
- **拓扑排序**：适用于“处理DAG的依赖关系”问题（如任务调度、状态转移）。


### 📚 洛谷练习推荐  
1. **洛谷 P1850 换教室**  
   - 🗣️ **推荐理由**：这道题考察**期望DP**，需要计算换教室的最小期望时间，与本题的“期望时间”计算思路类似。  
2. **洛谷 P2515 软件安装**  
   - 🗣️ **推荐理由**：这道题考察**树形DP+背包**，需要处理依赖关系（如软件必须安装在父节点之后），与本题的“拓扑序”思路类似。  
3. **洛谷 P3706 星球游戏**  
   - 🗣️ **推荐理由**：这道题考察**期望DP+二分答案**，需要计算到达终点的最小期望时间，与本题的核心算法完全一致。  


## 7. 学习心得与经验分享 (若有)

### 📝 来自题解的经验  
- **作者iMya_nlgau**：“通过导数证明二分的单调性，确保了算法的正确性。”  
  - **点评**：这提醒我们，二分答案不仅需要感性理解，更需要严格的数学证明，避免出现“假阳性”结果。  
- **作者Locix_Elaina_Celome**：“拓扑排序处理DAG，避免了递归的栈溢出问题。”  
  - **点评**：对于大规模数据，迭代的拓扑排序比递归的DFS更稳定，适合竞赛中的边界情况。  
- **作者123456xwd**：“记忆化搜索简化了代码，逻辑更直接。”  
  - **点评**：记忆化搜索是递归实现DP的好方法，适合初学者快速理解状态转移的过程。  


## 🎉 结语  
本次分析的“軍艦ゲーム”问题，核心是**二分答案+期望DP**，通过处理后效性和状态转移，计算到达终点的最小期望时间。希望这份指南能帮助大家理解算法思路，掌握解题技巧。记住，编程的乐趣在于“解决问题”，只要多思考、多练习，你一定能成为优秀的程序员！💪

---
处理用时：171.64秒
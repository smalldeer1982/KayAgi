# 题目信息

# [ARC170E] BDFS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_e

整数 $ N,P $ が与えられます．

頂点に $ 1 $ から $ N $ の番号が付いた $ N $ 頂点 $ N $ 辺のグラフがあります．$ i $ 番目の辺は頂点 $ i $ と頂点 $ i+1 $ を双方向に結んでいます．ここで頂点 $ N+1 $ は頂点 $ 1 $ を意味します．

以下のアルゴリズムを行い，長さ $ N $ の数列 $ D=(D_1,D_2,\ldots,D_N) $ を得ます．

- 長さ $ N $ の整数列 $ D $ を $ D=(D_1,\ldots,D_N)=(-1,\ldots,-1) $ で定める．また，数のペアの列 $ Q $ を $ Q=((1,0)) $ で定める．$ Q $ が空でない限り，以下の処理を繰り返す．
  
  
  - $ Q $ の先頭の要素を $ (v,d) $ とする．先頭の要素を削除する．
  - $ D_v\ =\ -1 $ の場合，$ D_v\ :=\ d $ とし，頂点 $ v $ に隣接して $ D_x=-1 $ を満たすような各頂点 $ x $ に対して以下の処理を行う．ただし条件を満たす $ x $ が複数存在する場合，頂点番号の小さい順に処理を行う．
      
      
      1. 確率 $ \frac{P}{100} $ で $ Q $ の**先頭**に $ (x,d+1) $ を追加する．
      2. $ Q $ の先頭への $ (x,d+1) $ の追加を行わなかった場合，$ Q $ の**末尾**に $ (x,d+1) $ を追加する．
 
最終的に得られる $ D $ の要素の総和の期待値を $ \text{mod\ }\ 998244353 $ で求めてください．

$ T $ 個のテストケースが与えられるので，それぞれについて答えてください．

   期待値 $ \text{mod\ }\ 998244353 $ の定義  求める期待値は必ず有理数になることが証明できます． また，この問題の制約下では，その値を既約分数 $ \frac{P}{Q} $ で表したときに $ Q $ が $ 998244353 $ で割り切れないことが保証されます． このとき $ R\times\ Q\ \equiv\ P\pmod{998244353} $ を満たすような $ 0 $ 以上 $ 998244352 $ 以下の整数 $ R $ が一意に定まります．この $ R $ を 答えてください．

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^4 $
- $ 3\ \leq\ N\ \leq\ 10^{18} $
- $ 1\leq\ P\ \leq\ 99 $
- 入力される数値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のテストケースでは，例えば以下のようにアルゴリズムは動きます． - はじめ，$ D=(-1,-1,-1),\ Q=((1,0)) $ である．$ Q $ の先頭の要素 $ (1,0) $ を削除する． - $ D_1\ =\ -1 $ なので，$ D_1\ :=\ 0 $ とする．頂点 $ 1 $ に隣接して $ D_x=\ -1 $ を満たすような頂点 $ x $ は $ 2,3 $ が考えられる． - $ Q $ の先頭に $ (2,1) $ を追加する．$ Q $ の末尾に $ (3,1) $ を追加する．$ Q=((2,1),(3,1)) $ となる． - $ Q $ の先頭の要素 $ (2,1) $ を削除する． - $ D_2\ =\ -1 $ なので，$ D_2\ :=\ 1 $ とする．頂点 $ 2 $ に隣接して $ D_x=\ -1 $ を満たすような頂点 $ x $ は $ 3 $ が考えられる． - $ Q $ の先頭に $ (3,2) $ を追加する．$ Q=((3,2),(3,1)) $ となる． - $ Q $ の先頭の要素 $ (3,2) $ を削除する． - $ D_3\ =\ -1 $ なので，$ D_3\ :=\ 2 $ とする．頂点 $ 3 $ に隣接して $ D_x=\ -1 $ を満たすような頂点 $ x $ は存在しないので何もしない． - $ Q $ の先頭の要素 $ (3,1) $ を削除する． - $ D_3\ =2 $ なので何もしない． - $ Q $ が空になったので処理を終了する． この場合，最終的に $ D=(0,1,2) $ が得られます．アルゴリズムが上記の動作をする確率は $ \frac{1}{8} $ であり，$ D $ の要素の総和の期待値は $ \frac{5}{2} $ です．

## 样例 #1

### 输入

```
3

3 50

4 1

1000000000000000000 70```

### 输出

```
499122179

595552585

760296751```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC170E] BDFS 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 矩阵快速幂优化 / 数学推导（期望线性性与等比数列求和）


🗣️ **初步分析**：  
这道题的核心是**在环上模拟带概率的BFS遍历**，求所有节点深度和的期望。由于环的大小`N`可以达到`10^18`，直接模拟是不可能的，必须用**对数时间复杂度**的算法（如矩阵快速幂或数学推导）。  

### 算法核心思想比喻  
可以把环的遍历想象成**“左右拓展的蛇”**：初始时蛇的头部在节点1，每次有`P%`的概率继续往当前方向（左或右）拓展，`(100-P)%`的概率掉头往反方向拓展。每个新拓展的节点的深度等于当前拓展的步数，我们需要计算所有节点深度之和的期望。  

### 题解思路与核心难点  
- **核心思路**：  
  题解主要分为两类：  
  1. **DP+矩阵快速幂**：定义状态记录当前左右方向的深度期望，通过转移方程用矩阵快速幂加速计算（适用于大`N`）。  
  2. **数学推导**：利用期望的线性性，将深度和拆分为两两位置的贡献，通过等比数列求和公式直接计算（复杂度更低）。  
- **核心难点**：  
  1. 如何**正确定义DP状态**，捕捉遍历方向的概率转移？  
  2. 如何**处理大`N`**，将O(N)的DP优化为O(logN)？  
  3. 如何**利用期望线性性**，将复杂的深度和拆解为简单的概率计算？  

### 可视化设计思路  
为了直观展示“左右拓展”的过程，我们可以设计一个**FC红白机风格的像素动画**：  
- **场景**：环用圆形像素块表示，节点1高亮（初始位置）。  
- **队列可视化**：队首和队尾用两个小方块表示（最多两个元素），加入队首时方块“跳”到左边，加入队尾时“滑”到右边。  
- **深度展示**：每个节点的深度用数字像素显示，拓展时数字逐渐变大，伴随“叮”的音效。  
- **交互**：支持“单步执行”（查看每一步的方向选择）、“自动播放”（加速展示遍历过程），以及“重置”（重新开始）。  


## 2. 精选优质题解参考

### 题解一：NobodyThere（赞：12）  
* **点评**：  
  这份题解的**思路清晰度**非常高，将环的遍历转化为“左右拓展”的状态转移，定义了`f0`（当前方向深度期望）、`f1`（反方向深度期望）和`ans`（总期望）三个状态，转移方程直观易懂。**算法有效性**方面，矩阵快速幂的应用完美解决了大`N`的问题，时间复杂度O(TlogN)。**代码规范性**虽未展示完整代码，但提交记录证明其正确性，是入门级学习者理解“DP+矩阵快速幂”的好例子。  

### 题解二：qiuzx（赞：3）  
* **点评**：  
  此题解的**数学推导**非常巧妙，利用期望的线性性将深度和拆分为两两位置的贡献，通过等比数列求和公式直接计算，复杂度O(logN)（比矩阵快速幂更优）。**思路启发性**强，教会我们“将复杂问题拆解为简单子问题”的技巧。**实践价值**高，代码简洁（仅需计算等比数列和），适合进阶学习者掌握“数学优化”的思路。  

### 题解三：DaiRuiChen007（赞：0）  
* **点评**：  
  这份题解的**代码可读性**极佳，直接给出了矩阵快速幂的实现，矩阵构造正确（包含`f`、`g`、`1`、`ans`的转移）。**算法有效性**方面，矩阵快速幂的应用正确，处理大`N`的效率足够。**实践参考价值**高，代码可直接用于竞赛，适合学习者模仿“矩阵构造”的技巧。  


## 3. 核心难点辨析与解题策略

### 1. 关键点1：如何定义DP状态？  
* **分析**：  
  题解中常用的状态是**当前方向的深度期望**（如`f0`）和**反方向的深度期望**（如`f1`）。例如，`f0`表示继续往当前方向拓展的深度期望，`f1`表示掉头后的深度期望。这样的状态定义能捕捉方向变化的概率，且转移方程简单（线性组合）。  
* 💡 **学习笔记**：状态定义要“覆盖所有可能的状态”，并“便于转移”。  

### 2. 关键点2：如何处理大`N`？  
* **分析**：  
  对于`N=1e18`，必须用**对数时间算法**。矩阵快速幂是常用的方法（将DP转移转化为矩阵乘法，用快速幂加速）；数学推导（如qiuzx的题解）则通过等比数列求和公式直接计算，复杂度更低。  
* 💡 **学习笔记**：大`N`问题优先考虑“快速幂”或“数学公式”。  

### 3. 关键点3：如何利用期望线性性？  
* **分析**：  
  期望的线性性允许我们将“深度和的期望”拆分为“每个节点深度的期望之和”，甚至进一步拆分为“两两位置的贡献之和”。例如，qiuzx的题解中将深度和拆分为“所有`L`操作的贡献”和“所有`R`操作的贡献”，简化了计算。  
* 💡 **学习笔记**：期望线性性是解决“期望和”问题的神器，即使变量不独立也能使用。  

### ✨ 解题技巧总结  
- **技巧A**：将复杂的遍历过程抽象为“状态转移”（如左右方向的变化）。  
- **技巧B**：大`N`问题用“矩阵快速幂”或“数学推导”优化。  
- **技巧C**：利用“期望线性性”拆解问题，降低计算复杂度。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（矩阵快速幂）  
* **说明**：本代码综合了DaiRuiChen007题解的思路，展示了矩阵快速幂解决大`N`DP问题的核心逻辑。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  typedef long long ll;
  const int MOD = 998244353;
  const int inv100 = 828542813; // 1/100 mod 998244353

  // 定义4x4矩阵（f, g, 1, ans）
  struct Matrix {
      ll m[4][4];
      Matrix() { memset(m, 0, sizeof(m)); }
      Matrix operator*(const Matrix& other) const {
          Matrix res;
          for (int i = 0; i < 4; i++)
              for (int k = 0; k < 4; k++)
                  if (m[i][k])
                      for (int j = 0; j < 4; j++)
                          res.m[i][j] = (res.m[i][j] + m[i][k] * other.m[k][j]) % MOD;
          return res;
      }
  };

  Matrix qpow(Matrix a, ll b) {
      Matrix res;
      for (int i = 0; i < 4; i++) res.m[i][i] = 1; // 单位矩阵
      while (b) {
          if (b & 1) res = res * a;
          a = a * a;
          b >>= 1;
      }
      return res;
  }

  int main() {
      int T;
      cin >> T;
      while (T--) {
          ll N;
          int P;
          cin >> N >> P;
          N--; // 需要拓展N-1次
          ll p = (ll)P * inv100 % MOD; // P/100 mod MOD
          ll q = (1 - p + MOD) % MOD; // (100-P)/100 mod MOD

          // 构造转移矩阵
          Matrix trans;
          trans.m[0][0] = p;     trans.m[0][1] = q;     trans.m[0][3] = 1; // f' = p*f + q*g + 1
          trans.m[1][0] = q;     trans.m[1][1] = p;                         // g' = q*f + p*g
          trans.m[2][0] = p;     trans.m[2][1] = q;     trans.m[2][2] = 1; trans.m[2][3] = 1; // ans' = ans + p*f + q*g + 1
          trans.m[3][3] = 1; // 保持1不变

          // 初始状态：f=0, g=0, 1=1, ans=0
          Matrix init;
          init.m[0][2] = 1; // f=0*1
          init.m[1][2] = 1; // g=0*1
          init.m[2][2] = 1; // 1=1
          init.m[3][2] = 0; // ans=0

          Matrix res = init * qpow(trans, N);
          cout << res.m[2][3] << endl; // ans的值
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为三部分：  
  1. **矩阵定义**：用结构体表示4x4矩阵，重载乘法运算符（矩阵乘法）。  
  2. **快速幂函数**：用快速幂计算矩阵的N次幂，加速转移。  
  3. **主函数**：读取输入，构造转移矩阵（表示`f`、`g`、`ans`的转移），计算初始状态与转移矩阵的N次幂的乘积，输出结果。  


### 题解二：qiuzx的核心代码片段（数学推导）  
* **亮点**：用等比数列求和公式直接计算，复杂度O(logN)。  
* **核心代码片段**：  
  ```cpp
  // 计算等比数列和：sum_{k=0}^{m-1} x^k = (x^m - 1)/(x-1) mod MOD
  ll pow_sum(ll x, ll m) {
      if (x == 1) return m % MOD;
      ll a = qpow(x, m), b = (a - 1 + MOD) % MOD;
      ll inv = qpow((x - 1 + MOD) % MOD, MOD-2);
      return b * inv % MOD;
  }

  // 计算sum_{m=0}^{n-2} (n-m-1) * x^m
  ll calc(ll n, ll x) {
      ll sum1 = (n-1) * pow_sum(x, n-1) % MOD;
      ll sum2 = (x * (pow_sum(x, n-1) - (n-1) + MOD) % MOD) * qpow((x-1+MOD)%MOD, MOD-2) % MOD;
      return (sum1 - sum2 + MOD) % MOD;
  }
  ```
* **代码解读**：  
  - `pow_sum`函数计算等比数列和，用快速幂计算`x^m`，再用逆元计算分式。  
  - `calc`函数计算`sum_{m=0}^{n-2} (n-m-1)x^m`，这是qiuzx题解中推导的关键式子，通过等比数列和的变形得到。  
* 💡 **学习笔记**：数学推导能将复杂的DP转化为简单的公式计算，效率更高。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“环上的蛇形探险家”**（FC红白机风格）  

### 核心演示内容  
- **场景初始化**：屏幕中央显示一个圆形环（由16x16像素块组成），节点1用红色高亮，队列（队首、队尾）用蓝色小方块表示（初始时队列只有节点1）。  
- **拓展过程**：  
  1. 每次拓展时，当前方向（左或右）的节点用黄色高亮，伴随“叮”的音效。  
  2. 若选择队首加入（`P%`概率），则新节点“跳”到队首位置；若选择队尾加入（`(100-P)%`概率），则新节点“滑”到队尾位置。  
  3. 每个节点的深度用白色数字像素显示，拓展时数字逐渐变大（如节点2的深度是1，节点3的深度是2）。  
- **结束状态**：当所有节点都被拓展时，屏幕显示“胜利”动画（彩色闪烁），伴随“通关”音效。  

### 交互设计  
- **控制面板**：屏幕下方有“开始/暂停”、“单步执行”、“重置”按钮，以及“速度滑块”（调整自动播放速度）。  
- **AI演示模式**：点击“AI自动演示”按钮，算法会自动执行，展示“蛇形拓展”的完整过程，学习者可以观察方向变化的概率。  

### 设计理由  
- **像素风格**：复古的FC风格能激发青少年的兴趣，降低对复杂算法的恐惧。  
- **音效与动画**：“叮”的音效和“跳/滑”的动画能强化“队首/队尾加入”的记忆，帮助理解概率转移。  
- **交互性**：单步执行和速度调整允许学习者自主控制学习节奏，深入观察每一步的变化。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **矩阵快速幂**：适用于“状态转移固定、需要计算大步数”的问题（如递推数列、图的路径计数）。  
- **期望线性性**：适用于“求期望和”的问题（如随机变量的和的期望）。  
- **等比数列求和**：适用于“有重复结构的数学推导”（如概率转移中的重复步骤）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1939** - 【模板】矩阵快速幂  
   * 🗣️ **推荐理由**：这是矩阵快速幂的模板题，帮助你巩固“矩阵构造”和“快速幂”的技巧。  
2. **洛谷 P3811** - 【模板】乘法逆元  
   * 🗣️ **推荐理由**：本题需要计算逆元（如`1/100 mod 998244353`），是处理分式期望的基础。  
3. **洛谷 P5343** - 【XR-1】逛森林  
   * 🗣️ **推荐理由**：本题涉及“期望的线性性”和“动态规划”，是本题的变形练习。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自NobodyThere)  
> “我做题的大部分时间都在整理题意。”  

**点评**：  
这位作者的经验很典型。对于复杂的题目（如本题的“带概率的BFS”），**整理题意**是解决问题的第一步。可以通过“举例子”（如样例中的遍历过程）或“抽象模型”（如将环的遍历转化为左右拓展）来理清思路。  


## 🎉 总结  
本次分析的“[ARC170E] BDFS”题，核心是**动态规划+矩阵快速幂**或**数学推导**，解决了大`N`下的期望计算问题。通过可视化动画，我们能直观看到“左右拓展”的过程；通过优质题解，我们学习了“状态定义”、“矩阵构造”和“数学优化”的技巧。  

记住：**编程的本质是解决问题，而不是写代码**。多思考“为什么”（如为什么用矩阵快速幂？为什么用期望线性性？），才能真正掌握算法的核心。下次遇到类似问题，你一定能举一反三！💪

---
处理用时：148.39秒
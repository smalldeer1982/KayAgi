# 题目信息

# [ABC213F] Common Prefixes

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc213/tasks/abc213_f

$ 2 $ つの文字列 $ X,Y $ に対して、その**類似度** $ f(X,Y) $ を、$ X $ と $ Y $ を先頭から見て一致している文字数とします。  
 例えば `abc` と `axbc` の類似度は $ 1 $ 、`aaa` と `aaaa` の類似度は $ 3 $ です。

長さ $ N $ の文字列 $ S $ が与えられます。$ S $ の $ i $ 文字目以降からなる文字列を $ S_i $ とします。$ k=1,\ldots,N $ のそれぞれについて、$ f(S_k,S_1)+f(S_k,S_2)+\ldots+f(S_k,S_N) $ を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^6 $
- $ S $ は英小文字のみからなる長さ $ N $ の文字列

### Sample Explanation 1

$ S_1,S_2,S_3 $ はそれぞれ `abb`, `bb`, `b` です。 - $ k=1 $ のとき $ f(S_1,S_1)+f(S_1,S_2)+f(S_1,S_3)=3+0+0=3 $ - $ k=2 $ のとき $ f(S_2,S_1)+f(S_2,S_2)+f(S_2,S_3)=0+2+1=3 $ - $ k=3 $ のとき $ f(S_3,S_1)+f(S_3,S_2)+f(S_3,S_3)=0+1+1=2 $

## 样例 #1

### 输入

```
3

abb```

### 输出

```
3

3

2```

## 样例 #2

### 输入

```
11

mississippi```

### 输出

```
11

16

14

12

13

11

9

7

4

3

4```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC213F] Common Prefixes 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串（后缀数组/后缀自动机）

🗣️ **初步分析**：  
题目要求计算每个后缀`S_k`与所有后缀`S_1~S_N`的**最长公共前缀（LCP）之和**。比如`S="abb"`时，`S_1="abb"`与`S_2="bb"`的LCP是0，与`S_3="b"`的LCP也是0，总和为3（自己与自己的LCP是3）。  

解决这类大规模LCP问题，**后缀数组（SA）**和**后缀自动机（SAM）**是两大“神器”：  
- **后缀数组**：将所有后缀排序，利用`LCP`数组的性质（任意两后缀的LCP等于它们在排序后的区间内的最小`LCP`值），把问题转化为“求每个位置作为端点的区间最小值之和”，用单调栈线性解决。  
- **后缀自动机**：通过构建反串的SAM，其`parent`树即为原串的后缀树。两后缀的LCP等于它们在后缀树上的`LCA`（最近公共祖先）的`len`值，再用树上差分计算每个节点的贡献。  

**可视化设计思路**：  
我们以**后缀数组**为例设计像素动画：  
- 用8位像素块表示字符串`S`的每个字符（比如`a`是红色，`b`是蓝色）；  
- 排序后缀时，用“滑动”动画展示后缀的位置变化（比如`S_2="bb"`滑到`S_1="abb"`前面）；  
- `LCP`数组用“高度条”表示（高度对应LCP值），单调栈处理`pre`和`suf`数组时，用“栈帧弹出/压入”动画展示区间最小值的更新，伴随“叮”的音效（压入）和“咔”的音效（弹出）。  


## 2. 精选优质题解参考

### 题解一：后缀数组（SA）+ 单调栈（来源：loser_seele，参考官方题解）  
* **点评**：  
  这份题解思路清晰，完美利用了后缀数组的`LCP`性质。核心步骤是将“所有后缀对的LCP之和”转化为“每个位置作为端点的区间最小值之和”，再用单调栈线性计算。代码简洁，使用Atcoder自带的`suffix_array`函数简化了SA的实现，同时单调栈的处理（计算`pre`和`suf`数组）非常巧妙，将时间复杂度控制在`O(n)`（SA的时间复杂度为`O(n)`）。特别是`pre[rk[i]] + suf[rk[i]+1] + (n-i)`的公式，直接汇总了每个后缀的总LCP之和，逻辑严谨。  

### 题解二：后缀自动机（SAM）+ 后缀树（来源：Reunite）  
* **点评**：  
  此题解思路新颖，通过构建反串的SAM，将原串的后缀树转化为`parent`树。利用“两后缀的LCP等于其在后缀树上的LCA的`len`值”的性质，将问题转化为树上差分问题。代码中`ins`函数实现了SAM的插入操作，`init`函数统计每个节点的子树大小（即包含的后缀数量），`solve`函数通过DFS计算每个后缀的总LCP之和。时间复杂度`O(n)`，空间复杂度`O(n×26)`，适用于大规模数据。亮点是将LCP问题转化为树上路径问题，拓展了思维方式。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：LCP数组的性质应用**  
* **分析**：  
  后缀数组排序后，`LCP(i,j)`（第`i`小和第`j`小后缀的LCP）等于`min{h[k] | k=i+1~j}`（`h`数组是相邻后缀的LCP）。这一性质是将问题转化为区间最小值之和的关键。比如，计算`S_k`与所有后缀的LCP之和，等价于计算`S_k`在排序后的位置`rk[k]`，然后求以`rk[k]`为端点的所有区间的最小值之和。  
* 💡 **学习笔记**：LCP数组的性质是后缀数组解决LCP问题的核心，必须牢记。  

### 2. **关键点2：单调栈处理区间最小值之和**  
* **分析**：  
  计算“每个位置作为端点的区间最小值之和”时，直接暴力是`O(n²)`，无法通过大规模数据。单调栈可以线性解决这个问题：`pre[i]`表示以`i`为右端点的所有区间的最小值之和，`suf[i]`表示以`i`为左端点的所有区间的最小值之和。通过维护一个单调递增的栈，每次弹出比当前`h[i]`大的元素，更新`pre`或`suf`数组。  
* 💡 **学习笔记**：单调栈是处理“区间最小值/最大值”问题的常用工具，适用于线性时间复杂度的需求。  

### 3. **关键点3：SAM与后缀树的转换**  
* **分析**：  
  反串的SAM的`parent`树即为原串的后缀树。每个节点的`len`值表示该节点对应的最长公共前缀长度，子树大小表示包含的后缀数量。通过树上差分，将每个后缀的贡献累加到其路径上的所有节点，最后通过DFS计算每个后缀的总LCP之和。  
* 💡 **学习笔记**：SAM的`parent`树性质是解决后缀问题的重要工具，需要理解其与后缀树的对应关系。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（后缀数组版）  
* **说明**：本代码综合了题解一的思路，使用Atcoder的`suffix_array`函数简化SA实现，单调栈计算`pre`和`suf`数组。  
* **完整核心代码**：  
  ```cpp
  #include <atcoder/string.hpp>
  #include <iostream>
  #include <vector>
  using namespace std;

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int n;
      string s;
      cin >> n >> s;
      auto sa = atcoder::suffix_array(s);
      auto lcp = atcoder::lcp_array(s, sa);
      lcp.insert(lcp.begin(), 0); // 补0，使lcp[1..n]对应sa[0..n-1]的相邻LCP

      vector<long long> pre(n + 1, 0), suf(n + 1, 0);
      vector<int> stk(n + 2, -1);
      int top = 0;

      // 计算pre数组：以i为右端点的区间最小值之和
      for (int i = 1; i <= n; ++i) {
          if (i > 1) pre[i] = pre[i - 1];
          while (top > 0 && lcp[stk[top]] > lcp[i]) {
              pre[i] -= (stk[top] - stk[top - 1]) * (long long)lcp[stk[top]];
              top--;
          }
          pre[i] += (i - stk[top]) * (long long)lcp[i];
          stk[++top] = i;
      }

      // 计算suf数组：以i为左端点的区间最小值之和
      top = 0;
      stk[top] = n + 1;
      for (int i = n; i >= 1; --i) {
          if (i < n) suf[i] = suf[i + 1];
          while (top > 0 && lcp[stk[top]] > lcp[i]) {
              suf[i] -= (stk[top - 1] - stk[top]) * (long long)lcp[stk[top]];
              top--;
          }
          suf[i] += (stk[top] - i) * (long long)lcp[i];
          stk[++top] = i;
      }

      // 计算每个后缀的总LCP之和
      vector<int> rk(n);
      for (int i = 0; i < n; ++i) rk[sa[i]] = i + 1; // rk[i]对应排序后的位置（1-based）
      for (int i = 0; i < n; ++i) {
          long long res = pre[rk[i]] + suf[rk[i] + 1] + (n - i);
          cout << res << '\n';
      }

      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取输入，生成后缀数组`sa`和`lcp`数组（`lcp[i]`表示`sa[i-1]`和`sa[i]`的LCP）；  
  2. 计算`pre`数组：以`i`为右端点的所有区间的最小值之和（用单调栈维护递增序列）；  
  3. 计算`suf`数组：以`i`为左端点的所有区间的最小值之和（同理）；  
  4. 转换`rk`数组（`rk[i]`表示后缀`S_i`在排序后的位置）；  
  5. 输出每个后缀的总LCP之和（`pre[rk[i]] + suf[rk[i]+1] + (n-i)`，其中`n-i`是后缀`S_i`与自己的LCP）。  


### 题解一：后缀数组+单调栈（核心片段）  
* **亮点**：单调栈线性计算`pre`和`suf`数组。  
* **核心代码片段**：  
  ```cpp
  // 计算pre数组
  for (int i = 1; i <= n; ++i) {
      if (i > 1) pre[i] = pre[i - 1];
      while (top > 0 && lcp[stk[top]] > lcp[i]) {
          pre[i] -= (stk[top] - stk[top - 1]) * (long long)lcp[stk[top]];
          top--;
      }
      pre[i] += (i - stk[top]) * (long long)lcp[i];
      stk[++top] = i;
  }
  ```
* **代码解读**：  
  - `pre[i]`初始化为`pre[i-1]`（继承前一个状态）；  
  - 弹出栈中比当前`lcp[i]`大的元素，因为这些元素无法成为以`i`为右端点的区间的最小值，需要减去它们的贡献；  
  - 加入当前`lcp[i]`的贡献（区间长度为`i - stk[top]`）；  
  - 将`i`压入栈中，维护单调递增序列。  
* 💡 **学习笔记**：单调栈的核心是“维护一个单调序列，每次处理当前元素时，弹出不符合条件的元素，更新贡献”。  


### 题解二：SAM+后缀树（核心片段）  
* **亮点**：SAM的插入操作和树上差分。  
* **核心代码片段**：  
  ```cpp
  // SAM插入函数
  inline int ins(int c, int las) {
      if (mp[las][c]) {
          int p = las, v = mp[p][c];
          if (len[p] + 1 == len[v]) return v;
          int x = ++tot;
          len[x] = len[p] + 1;
          memcpy(mp[x], mp[v], sizeof(mp[v]));
          while (mp[p][c] == v) mp[p][c] = x, p = fa[p];
          fa[x] = fa[v], fa[v] = x;
          return x;
      }
      int x = ++tot, p = las;
      len[x] = len[p] + 1;
      while (p && !mp[p][c]) mp[p][c] = x, p = fa[p];
      if (!p) fa[x] = 1;
      else {
          int v = mp[p][c];
          if (len[p] + 1 == len[v]) fa[x] = v;
          else {
              int y = ++tot;
              len[y] = len[p] + 1;
              memcpy(mp[y], mp[v], sizeof(mp[v]));
              while (mp[p][c] == v) mp[p][c] = y, p = fa[p];
              fa[y] = fa[v], fa[x] = fa[v] = y;
          }
      }
      return x;
  }
  ```
* **代码解读**：  
  - `ins`函数用于向SAM中插入字符`c`（`c`是0-25的整数）；  
  - 处理两种情况：当前字符已存在于`las`的转移中（分裂节点），或不存在（新建节点）；  
  - 分裂节点时，复制原节点的转移，更新父节点，维护SAM的性质；  
  - 新建节点时，沿父节点链更新转移，设置父节点。  
* 💡 **学习笔记**：SAM的插入操作是其核心，需要理解节点分裂的逻辑，以维护`len`和`fa`数组的正确性。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**后缀数组的“排序与LCP计算”像素冒险**  
**设计思路**：  
采用8位像素风格（类似FC游戏），用“字符块”表示字符串，“滑动动画”展示后缀排序，“高度条”表示LCP值，“栈帧动画”展示单调栈处理过程。加入音效（如“滑动”的“咻”声、“压入栈”的“叮”声、“弹出栈”的“咔”声），增强代入感。  

### 动画帧步骤与交互关键点：  
1. **场景初始化**：  
   - 屏幕左侧显示原字符串`S`（如`"abb"`），每个字符用不同颜色的像素块表示（`a`=红色，`b`=蓝色）；  
   - 右侧显示“排序后的后缀”区域，初始为空；  
   - 底部有“控制面板”：开始/暂停、单步、重置按钮，速度滑块（1-5倍速）。  

2. **后缀排序动画**：  
   - 逐个展示后缀的排序过程：比如`S_1="abb"`（红色+蓝色+蓝色）、`S_2="bb"`（蓝色+蓝色）、`S_3="b"`（蓝色）；  
   - 用“滑动”动画将后缀从左侧移到右侧的排序位置（如`S_2`滑到`S_1`前面）；  
   - 排序完成后，右侧显示排序后的后缀列表（`S_2`, `S_3`, `S_1`）。  

3. **LCP数组计算动画**：  
   - 在排序后的后缀下方，用“高度条”表示相邻后缀的LCP值（如`S_2`和`S_3`的LCP是1，高度条为1格；`S_3`和`S_1`的LCP是0，高度条为0格）；  
   - 高度条的颜色随LCP值变化（值越大，颜色越亮）。  

4. **单调栈处理`pre`数组动画**：  
   - 屏幕右侧显示“单调栈”区域（用像素块表示栈帧）；  
   - 逐个处理`lcp`数组元素（从1到n）：  
     - 当处理`lcp[i]`时，当前元素用“闪烁”标记；  
     - 弹出栈中比`lcp[i]`大的元素（栈帧“向下消失”），伴随“咔”的音效；  
     - 计算`pre[i]`的贡献（用“数字跳动”显示`pre[i]`的值），将`i`压入栈中（栈帧“向上出现”），伴随“叮”的音效。  

5. **结果展示**：  
   - 处理完成后，屏幕下方显示每个后缀的总LCP之和（用“数字滚动”动画展示）；  
   - 播放“胜利”音效（上扬的8位音调），显示“完成！”的像素文字。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
- **后缀数组**：适用于需要排序后缀、计算LCP的问题（如字符串匹配、重复子串查找）；  
- **SAM**：适用于需要高效处理后缀、子串的问题（如最长重复子串、不同子串数目）；  
- **单调栈**：适用于处理区间最小值/最大值之和的问题（如柱状图中最大矩形、接雨水）。  

### 练习推荐 (洛谷)：  
1. **洛谷 P3809** - 后缀排序  
   🗣️ **推荐理由**：这是后缀数组的基础题，帮助你掌握SA的构建过程（如倍增法）。  
2. **洛谷 P4051** - [JSOI2007]字符加密  
   🗣️ **推荐理由**：需要将字符串扩展为两倍，然后排序后缀，考查SA的应用。  
3. **洛谷 P4248** - [AHOI2013]差异  
   🗣️ **推荐理由**：要求计算所有后缀对的长度之和减去LCP之和，考查SA和LCP数组的性质。  


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 loser_seele)**：“部分内容参考自官方题解。”  
> **点评**：官方题解往往是最权威的，尤其是对于竞赛题。参考官方题解可以快速理解问题的核心思路，避免走弯路。比如本题的后缀数组方法，官方题解详细解释了LCP数组的性质和单调栈的应用，是解题的关键。  

> **参考经验 (来自 Reunite)**：“看到一大车LCP，考虑把串丢到后缀树上去。”  
> **点评**：这提醒我们，遇到大规模LCP问题时，后缀树（或SAM的parent树）是一个有效的工具。掌握数据结构的性质（如后缀树的LCA性质），可以将复杂问题转化为更易处理的形式。  


## 结语  
本次关于“[ABC213F] Common Prefixes”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解后缀数组和SAM的应用，掌握处理LCP问题的技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：150.71秒
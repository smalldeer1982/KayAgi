# 题目信息

# [ABC272F] Two Strings

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc272/tasks/abc272_f

長さ $ N $ の英小文字からなる文字列 $ S,T $ が与えられます。

文字列 $ X $ と整数 $ i $ に対し、$ f(X,i) $ を $ X $ に対して以下の操作を $ i $ 回行い得られる文字列とします。

- $ X $ の先頭の文字を削除し、同じ文字を $ X $ の末尾に挿入する。

$ 0\ \le\ i,j\ \le\ N-1 $ を満たす非負整数の組 $ (i,j) $ のうち、辞書順で $ f(S,i) $ が $ f(T,j) $ より小さいか同じであるものの個数を求めてください。

 辞書順とは？ 辞書順とは簡単に説明すると「単語が辞書に載っている順番」を意味します。より厳密な説明として、英小文字からなる相異なる文字列 $ S,\ T $ の大小を判定するアルゴリズムを以下に説明します。

以下では「 $ S $ の $ i $ 文字目の文字」を $ S_i $ のように表します。また、 $ S $ が $ T $ より辞書順で小さい場合は $ S\ \lt\ T $ 、大きい場合は $ S\ \gt\ T $ と表します。

1. $ S,\ T $ のうち長さが大きくない方の文字列の長さを $ L $ とします。$ i=1,2,\dots,L $ に対して $ S_i $ と $ T_i $ が一致するか調べます。
2. $ S_i\ \neq\ T_i $ である $ i $ が存在する場合、そのような $ i $ のうち最小のものを $ j $ とします。そして、$ S_j $ と $ T_j $ を比較して、$ S_j $ が $ T_j $ よりアルファベット順で小さい場合は $ S\ \lt\ T $ 、そうでない場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。
3. $ S_i\ \neq\ T_i $ である $ i $ が存在しない場合、$ S $ と $ T $ の長さを比較して、$ S $ が $ T $ より短い場合は $ S\ \lt\ T $ 、長い場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 2\ \times\ 10^5 $
- $ S,T $ は英小文字からなる長さ $ N $ の文字列
- $ N $ は整数

### Sample Explanation 1

条件を満たす $ (i,j) $ の組は $ (0,0),(0,2),(2,0),(2,2) $ の $ 4 $ 個があります。 $ (i,j)=(1,2) $ は、$ f(S,i)= $`dba`$ ,f(T,j)= $`bca` であるため条件を満たしません。

## 样例 #1

### 输入

```
3

adb

cab```

### 输出

```
4```

## 样例 #2

### 输入

```
10

wsiuhwijsl

pwqoketvun```

### 输出

```
56```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ABC272F Two Strings] 深入学习指南 💡

<introduction>
今天我们来一起分析“ABC272F Two Strings”这道C++编程题。题目要求我们统计两个字符串的所有循环移位中，满足字典序关系的对数。本指南将帮助大家理解核心思路、掌握关键算法，并通过可视化动画直观感受解题过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理与排序应用`

🗣️ **初步分析**：
解决这道题的关键在于处理循环移位的字典序比较，并高效统计符合条件的对数。循环移位操作（即`f(X,i)`）可以看作是将原字符串`X`倍长（如`X+X`）后，取长度为`N`的子串（如`X[i..i+N-1]`）。因此，问题转化为比较所有S和T的循环移位子串的字典序，并统计满足`f(S,i) ≤ f(T,j)`的`(i,j)`对数量。

核心算法是**后缀数组（SA）**或**哈希+二分**。后缀数组能高效对所有子串排序，而哈希+二分则通过预处理哈希值，用二分查找最长公共前缀来快速比较字典序。两种方法的核心都是将循环移位转化为子串排序问题。

- **题解思路对比**：前三个题解均使用SA直接排序子串，第四个题解尝试用SAM（后缀自动机），但SA更直观。SA的优势在于能一次性得到所有子串的排名，方便后续统计；哈希+二分则通过优化比较步骤降低时间复杂度。
- **核心算法流程**：将S和T分别倍长（`S+S`和`T+T`），拼接成一个大字符串（如`S+S+T+T`），插入特殊字符分隔，构建SA数组。通过SA得到所有循环移位子串的排名后，统计S子串排名小于等于T子串排名的对数。
- **可视化设计**：采用8位像素风格动画，展示倍长后的字符串、SA构建过程（如基数排序步骤）、子串排序结果，用不同颜色标记S和T的子串。关键步骤高亮（如比较字符时的闪烁），并配合“叮”的音效提示比较完成。

---

## 2. 精选优质题解参考

<eval_intro>
通过思路清晰度、代码规范性、算法有效性等维度筛选，以下题解值得重点学习：
</eval_intro>

**题解一：Rnfmabj的哈希+二分解法**
* **点评**：此题解思路清晰，利用哈希+二分优化字典序比较，时间复杂度为`O(n log²n)`，适合竞赛场景。代码中通过预处理哈希值快速比较子串，避免了直接比较的`O(n)`复杂度。变量命名（如`calc`函数计算哈希差）直观，边界处理（将T拼在S后）巧妙，便于统计。亮点在于用二分查找最长公共前缀，将字符串比较优化到`O(log n)`。

**题解二：WaterSun的后缀数组解法**
* **点评**：此题解正确应用SA处理子串排序，通过插入特殊字符（`&`和`|`）避免S和T子串混淆。代码结构规范（如基数排序的分层处理），统计部分通过前缀和数组快速计算符合条件的对数。亮点在于特殊字符的插入确保了排序的正确性，避免相同子串的排名混乱。

**题解三：L_zaa_L的后缀数组解法**
* **点评**：此题解同样使用SA，但代码更简洁。通过倍长字符串并插入`#`和`|`分隔，构建SA后统计T子串的排名前缀和。亮点在于利用Parent Tree的子树遍历统计所有可能的子串，确保不遗漏任何循环移位。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，主要面临以下核心难点，结合优质题解的共性，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何高效比较循环移位的字典序？**
    * **分析**：循环移位的子串比较若直接逐字符对比，时间复杂度为`O(n² log n)`（排序时每次比较`O(n)`），无法处理`n=2e5`的规模。优质题解采用两种优化：
      - **哈希+二分**：预处理字符串的哈希值，用二分查找最长公共前缀，比较首不同字符（如Rnfmabj的`calc`函数和`cmp`函数）。
      - **后缀数组（SA）**：通过基数排序构建SA数组，直接得到所有子串的排名（如WaterSun的SA构建过程）。
    * 💡 **学习笔记**：处理长字符串的子串比较时，哈希或SA是关键优化手段，能将单次比较从`O(n)`降至`O(log n)`或更优。

2.  **关键点2：如何统计符合条件的`(i,j)`对？**
    * **分析**：排序后，S的每个循环移位子串对应一个排名，T的每个子串也对应一个排名。统计时，对每个S子串，需累加所有T子串中排名≥它的数量。优质题解通过维护前缀和数组（如WaterSun的`sum`数组）或从后向前遍历SA数组（如Rnfmabj的`cnt`变量），实现`O(n)`统计。
    * 💡 **学习笔记**：排序后的统计问题常可通过前缀和或双指针优化，避免暴力枚举。

3.  **关键点3：如何处理边界字符避免排序混乱？**
    * **分析**：若直接拼接`S+S+T+T`，S和T的子串可能因重叠导致排名错误（如S的末尾与T的开头字符相同）。优质题解插入特殊字符（如`&`、`#`、`|`）作为分隔符，确保S和T的子串在排序时不会混淆（如WaterSun在S和T间插入`&`，末尾插入`|`）。
    * 💡 **学习笔记**：处理多字符串拼接时，插入极小/极大字符可避免跨字符串的错误比较。

### ✨ 解题技巧总结
- **问题转化**：将循环移位转化为倍长字符串的子串问题，简化循环操作的处理。
- **哈希预处理**：通过前缀哈希值快速计算任意子串的哈希，支持高效比较。
- **SA的灵活应用**：利用SA数组直接获取所有子串的排名，为后续统计提供便利。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，选择使用后缀数组（SA）的完整实现作为通用核心代码，因其逻辑清晰且符合竞赛需求。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合WaterSun和L_zaa_L的SA解法，处理了字符串倍长、特殊字符插入及排名统计，适用于大`n`规模。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 1e6 + 10;
    int n, m = 250; // m初始为字符集大小（小写字母+特殊字符）
    int sa[N], rk[N], prk[N], tmp[N], cnt[N];
    char s[N]; // 拼接后的大字符串

    void build_sa() {
        // 初始化第一关键字
        for (int i = 1; i <= n; ++i) rk[i] = s[i];
        for (int i = 1; i <= m; ++i) cnt[i] = 0;
        for (int i = 1; i <= n; ++i) cnt[rk[i]]++;
        for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (int i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;

        // 倍增构建SA
        for (int w = 1; w < n; w <<= 1) {
            int num = 0;
            // 第二关键字排序：先处理末尾w个元素（无第二关键字）
            for (int i = n - w + 1; i <= n; ++i) tmp[++num] = i;
            // 再处理有第二关键字的元素
            for (int i = 1; i <= n; ++i) 
                if (sa[i] > w) tmp[++num] = sa[i] - w;

            // 按第一关键字排序
            for (int i = 1; i <= m; ++i) cnt[i] = 0;
            for (int i = 1; i <= n; ++i) cnt[rk[i]]++;
            for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
            for (int i = n; i >= 1; --i) sa[cnt[rk[tmp[i]]]--] = tmp[i];

            // 更新rank数组
            memcpy(prk, rk, sizeof(rk));
            int p = 0;
            rk[sa[1]] = ++p;
            for (int i = 2; i <= n; ++i) {
                if (prk[sa[i]] == prk[sa[i - 1]] && 
                    prk[sa[i] + w] == prk[sa[i - 1] + w]) {
                    rk[sa[i]] = p;
                } else {
                    rk[sa[i]] = ++p;
                }
            }
            if (p == n) break;
            m = p;
        }
    }

    int main() {
        int len;
        cin >> len;
        string S, T;
        cin >> S >> T;

        // 拼接字符串：S+S+特殊字符+T+T+特殊字符
        string base = "#" + S + S + "&" + T + T + "|";
        n = base.size() - 1; // 从1开始索引
        for (int i = 1; i <= n; ++i) s[i] = base[i];

        build_sa();

        // 统计S的循环移位（位置1~len）和T的循环移位（位置2len+2~3len+1）的排名
        vector<int> sum(n + 2, 0); // 前缀和数组，sum[r]表示排名≤r的T子串数量
        for (int i = 1; i <= n; ++i) {
            int pos = sa[i];
            // T的循环移位范围：2len+2 ≤ pos ≤ 3len+1（因为S+S占2len，特殊字符占1，T+T占2len）
            if (pos >= 2 * len + 2 && pos <= 3 * len + 1) {
                sum[rk[i]]++;
            }
        }
        // 计算前缀和
        for (int i = 1; i <= n; ++i) sum[i] += sum[i - 1];

        // 统计答案：S的循环移位位置1~len
        long long ans = 0;
        for (int i = 1; i <= n; ++i) {
            int pos = sa[i];
            if (pos >= 1 && pos <= len) { // S的循环移位
                ans += sum[rk[i]];
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先将S和T倍长并拼接，插入特殊字符分隔。通过`build_sa`函数构建后缀数组，得到所有子串的排名。然后统计T子串的排名前缀和，最后累加S子串排名小于等于T子串的数量，得到答案。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：Rnfmabj的哈希+二分解法**
* **亮点**：哈希预处理+二分查找最长公共前缀，优化字符串比较。
* **核心代码片段**：
    ```cpp
    ll calc(ll l, ll r) {
        return (h[r] - (h[l-1] * fac[r - l + 1]));
    }
    bool cmp(ll x, ll y) {
        ll l = 1, r = n, ans = 0;
        while (l <= r) {
            ll mid = (l + r) >> 1;
            if (calc(x, x + mid - 1) == calc(y, y + mid - 1)) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return c[x + ans] < c[y + ans];
    }
    ```
* **代码解读**：
  `calc`函数计算子串`[l, r]`的哈希值（通过前缀哈希和幂次数组`fac`）。`cmp`函数通过二分查找最长公共前缀（`ans`），比较第一个不同字符（`c[x+ans]`和`c[y+ans]`）的大小，从而确定两个子串的字典序。
* 💡 **学习笔记**：哈希+二分将字符串比较的时间复杂度从`O(n)`降至`O(log n)`，是处理长字符串比较的常用优化。

**题解二：WaterSun的SA解法**
* **亮点**：插入特殊字符避免排序混乱，前缀和统计高效。
* **核心代码片段**：
    ```cpp
    s[++n] = '&'; // S和T间插入特殊字符
    s[++n] = '|'; // 末尾插入特殊字符
    // ... SA构建 ...
    for (re int i = 1; i <= len; ++i) sum[rk[i]]++;
    for (re int i = 1; i <= 1e6; ++i) sum[i] += sum[i - 1];
    for (re int i = 2 * len + 2; i <= 3 * len + 1; ++i) ans += sum[rk[i]];
    ```
* **代码解读**：
  插入`&`和`|`确保S和T的子串在排序时不会因重叠混淆。`sum`数组统计T子串的排名前缀和，最后累加S子串对应排名的前缀和，得到符合条件的对数。
* 💡 **学习笔记**：特殊字符的插入是多字符串拼接排序的关键，能避免跨字符串的错误比较。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解SA构建和统计过程，我们设计一个8位像素风格的动画，模拟字符串倍长、SA排序及统计过程。
</visualization_intro>

  * **动画演示主题**：`循环移位大作战——像素世界的字典序冒险`

  * **核心演示内容**：展示S和T倍长后的字符串（如`adbadb&cab cab|`），SA构建时的基数排序步骤（如按首字符排序、按第二关键字排序），以及统计时S和T子串排名的对比。

  * **设计思路简述**：采用FC红白机风格的8位像素界面，用不同颜色区分S（蓝色）、T（红色）和特殊字符（灰色）。关键步骤（如比较字符、基数排序的桶分配）用闪烁和音效提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕左侧显示倍长后的字符串（如`a d b a d b & c a b c a b |`），每个字符用16x16像素块表示。
          - 右侧显示控制面板：单步/自动播放按钮、速度滑块（1-10倍速）、重置按钮。
          - 播放8位风格背景音乐（如《超级马里奥》的轻快旋律）。

    2.  **SA构建过程**：
          - **初始排序**：按首字符排序，每个字符块滑入对应的桶（如`a`入1号桶，`b`入2号桶），伴随“唰”的音效。
          - **倍增排序**：按第二关键字排序（如首字符相同的字符块，根据后一位字符重新排序），桶重新分配，字符块滑动并高亮当前关键字。
          - **排名更新**：每完成一轮排序，字符块下方显示当前排名（如`rk=1`），用黄色数字闪烁提示。

    3.  **统计过程**：
          - 用绿色标记S的子串（位置1~len），红色标记T的子串（位置2len+2~3len+1）。
          - 从后向前遍历SA数组，T子串计数`cnt`增加时，红色块跳动并播放“叮”音效；S子串累加`cnt`时，蓝色块放大并播放“咚”音效。

    4.  **目标达成**：
          - 统计完成后，屏幕中央显示总对数（如`ans=4`），所有字符块组成庆祝动画（如烟花绽放），播放胜利音效（如《超级马里奥》的通关音乐）。

  * **旁白提示**：
      - “看！这是倍长后的字符串，每个循环移位都是其中的一段哦~”
      - “现在在按首字符排序，相同首字符的会被分到同一个桶里~”
      - “这个红色块是T的循环移位，它的排名决定了能贡献多少S的循环移位对~”

<visualization_conclusion>
通过这个像素动画，我们可以清晰看到SA构建的每一步，以及统计时S和T子串的排名关系，让抽象的算法变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下题目，巩固字符串处理和排序的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 循环移位问题：可通过倍长字符串转化为子串问题（如求最小循环移位）。
      - 字典序统计：利用SA或哈希+二分排序后，通过前缀和或双指针统计符合条件的对数。
      - 多字符串拼接：插入特殊字符避免跨字符串的错误比较。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1117 [NOI2001] 聪明的打字员**  
          * 🗣️ **推荐理由**：涉及字符串循环移位和字典序比较，需灵活应用倍长字符串技巧。
    2.  **洛谷 P1368 最小表示法**  
          * 🗣️ **推荐理由**：直接考察循环移位的最小字典序，适合练习倍长字符串和双指针比较。
    3.  **洛谷 P4051 [JSOI2007] 字符加密**  
          * 🗣️ **推荐理由**：需构建SA处理循环移位的排序，与本题思路高度相关。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，例如：
</insights_intro>

> **参考经验 (来自 Rnfmabj)**：“最初没处理特殊字符，导致S和T的子串在排序时重叠，统计结果错误。后来插入`&`和`|`分隔，问题解决。”

> **点评**：这位作者的经验提醒我们，处理多字符串拼接时，特殊字符的插入是关键。通过插入极小/极大字符（如`&`的ASCII码小于小写字母，`|`大于小写字母），可以确保不同字符串的子串在排序时不会混淆。这是处理类似问题的重要技巧！

-----

<conclusion>
本次关于“ABC272F Two Strings”的分析就到这里。通过理解循环移位的转化、SA或哈希+二分的应用，以及统计时的前缀和技巧，相信大家能轻松解决这类问题。记得多动手写代码、调试，在实践中巩固知识！下次见~ 💪
</conclusion>

---
处理用时：153.99秒
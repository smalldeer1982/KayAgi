# 题目信息

# [ABC155F] Perils in Parallel

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc155/tasks/abc155_f

AlDebaran 王国の侵攻によって、AtCoder 王国の各地に爆弾が仕掛けられてしまいました。

幸いにも AtCoder 王国 ABC 隊の健闘により制御装置の一部が手に入ったので、あなたはこれを使って解除を試みることにしました。

仕掛けられた爆弾は $ N $ 個あり、$ 1 $ から $ N $ の番号がついています。爆弾 $ i $ は座標 $ A_i $ にあり、電源は $ B_i=1 $ のときオンに、$ B_i=0 $ のときオフになっています。

制御装置には $ M $ 本のコードがあり、$ 1 $ から $ M $ の番号がついています。コード $ j $ を切ると、座標が $ L_j $ 以上 $ R_j $ 以下の全ての爆弾の電源のオン・オフが切り替わります。

切るコードをうまく選ぶことで全ての爆弾の電源をオフにできるか判定し、できるならばそのようなコードの組合せを $ 1 $ つ出力してください。

## 说明/提示

### 制約

- 入力はすべて整数
- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9\ (1\ \leq\ i\ \leq\ N) $
- $ A_i $ は互いに相異なる
- $ B_i $ は $ 0 $ か $ 1 $ のいずれか $ (1\ \leq\ i\ \leq\ N) $
- $ 1\ \leq\ M\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ L_j\ \leq\ R_j\ \leq\ 10^9\ (1\ \leq\ j\ \leq\ M) $

### Sample Explanation 1

座標 $ 5,\ 10 $ に電源がオンの爆弾が、座標 $ 8 $ に電源がオフの爆弾があります。 コード $ 1 $ を切ると座標 $ 1 $ 以上 $ 10 $ 以下にある爆弾、つまり全ての爆弾の電源が切り替わります。 コード $ 4 $ を切ると座標 $ 8 $ 以上 $ 9 $ 以下にある爆弾、つまり爆弾 $ 3 $ のみの電源が切り替わります。 したがって、コード $ 1,\ 4 $ の $ 2 $ 本を切ることで全ての爆弾の電源がオフになります。

### Sample Explanation 2

切るコードをどう選んでも、全ての爆弾の電源をオフにすることは不可能です。

### Sample Explanation 3

はじめから全ての爆弾の電源がオフなので、コードを切る必要はありません。

### Sample Explanation 4

条件を満たすコードの組合せが複数あり得る場合、どれを出力しても構いません。

## 样例 #1

### 输入

```
3 4

5 1

10 1

8 0

1 10

4 5

6 7

8 9```

### 输出

```
2

1 4```

## 样例 #2

### 输入

```
4 2

2 0

3 1

5 1

7 0

1 4

4 7```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 2

5 0

10 0

8 0

6 9

66 99```

### 输出

```
0```

## 样例 #4

### 输入

```
12 20

536130100 1

150049660 1

79245447 1

132551741 0

89484841 1

328129089 0

623467741 0

248785745 0

421631475 0

498966877 0

43768791 1

112237273 0

21499042 142460201

58176487 384985131

88563042 144788076

120198276 497115965

134867387 563350571

211946499 458996604

233934566 297258009

335674184 555985828

414601661 520203502

101135608 501051309

90972258 300372385

255474956 630621190

436210625 517850028

145652401 192476406

377607297 520655694

244404406 304034433

112237273 359737255

392593015 463983307

150586788 504362212

54772353 83124235```

### 输出

```
5

1 7 8 9 11```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC155F] Perils in Parallel 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（生成树+DFS）+ 异或差分  

🗣️ **初步分析**：  
解决“Perils in Parallel”的关键，在于将“区间翻转”这个复杂操作，通过**异或差分**转化为“点操作”，再用**图论生成树**处理这些点之间的关系。  

### 1.1 异或差分：像“开关的开关”  
想象每个炸弹的状态是一盏灯，“区间翻转”就像同时按亮/熄灭区间两端的“总开关”——比如翻转区间`[l,r]`，相当于按一下`l`处的开关（改变`l`及之后的状态），再按一下`r+1`处的开关（抵消`r+1`及之后的改变）。这样，**区间翻转**就转化为**两个点的异或操作**（`diff[l] ^= 1`，`diff[r+1] ^= 1`）。最终目标从“所有炸弹状态为0”，变成“差分数组`diff`全为0”。  

### 1.2 图论模型：用边连接“开关对”  
每个绳子对应一个“开关对”（`l`和`r+1`），我们把这两个点用边连起来。此时，问题转化为：**选择一些边，使得每个点的边选择次数的奇偶性，与`diff`数组的值一致**（`diff[i]`为1则选奇数次，0则选偶数次）。  

### 1.3 核心算法流程与可视化思路  
- **离散化**：将炸弹位置排序，把大区间转化为小索引（比如`1~n`），方便处理。  
- **建图**：用并查集构建生成森林（避免环，因为环上的边选了等于没选）。  
- **DFS处理生成树**：从叶子节点往上遍历，若子节点的`diff`为1，则选择连接子节点与父节点的边（翻转这两个点的状态），直到根节点。  

**可视化设计思路**：  
- 用8位像素风格展示炸弹位置（方块颜色表示状态：红=1，绿=0）。  
- 绳子用蓝线连接两个点，选中的绳子闪烁黄色。  
- DFS过程用“像素小人”从叶子走到根，每处理一个节点，该节点颜色切换，同时播放“叮”的音效。  
- 若根节点`diff`为1（无解），则播放“错误”音效，屏幕闪红。  


## 2. 精选优质题解参考

### 题解一（作者：PNNNN，赞：11）  
* **点评**：  
  这份题解的思路非常清晰，完美覆盖了“异或差分→图论建模→生成树处理”的全流程。代码结构工整，变量命名（如`diff`表示差分数组，`to`表示图的邻接表）易于理解。**亮点**在于用DFS处理生成树时，从叶子到根的“回溯”逻辑——若子节点`diff`为1，则选择父边，确保子节点状态正确，同时更新父节点状态。这种“自底向上”的处理方式，完美解决了“如何选择边”的问题。  

### 题解二（作者：wxzzzz，赞：10）  
* **点评**：  
  题解用并查集构建生成森林，避免了环的干扰，这是处理图论问题的常用技巧。代码中`dfs`函数的“状态传递”逻辑（`d[x] ^= d[y]`）非常巧妙，通过子节点的状态反推父节点是否需要选边。**亮点**在于对`n+1`节点的特殊处理——该节点的`diff`值不影响结果，所以单独处理，避免了无解的误判。  

### 题解三（作者：xtx1092515503，赞：8）  
* **点评**：  
  题解用“树形DP”的思路解释了生成树的处理过程，把每个节点的状态看作“需要翻转的次数”，子节点的状态传递给父节点。**亮点**在于用“冰茶姬”（并查集）求生成森林，简化了图的结构，让DFS更高效。代码中的`mg`函数（合并集合）和`dfs`函数的结合，展示了“图论+动态规划”的综合应用。  


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何将区间翻转转化为点操作？  
* **分析**：  
  区间翻转的本质是“连续修改”，而异或差分的“前缀和”性质，可以将连续修改转化为两个点的修改。例如，翻转`[l,r]`相当于`diff[l] ^= 1`（改变`l`及之后的状态）和`diff[r+1] ^= 1`（抵消`r+1`及之后的改变）。**关键**是理解“差分”的“前缀恢复”特性——`b[i] = diff[1] ^ diff[2] ^ ... ^ diff[i]`，所以`diff`全为0时，`b`也全为0。  

* 💡 **学习笔记**：差分是处理区间操作的“神器”，尤其适合模2（异或）场景。  

### 2. 难点2：如何建立图论模型？  
* **分析**：  
  每个绳子对应一个“开关对”（`l`和`r+1`），我们把这两个点用边连起来。此时，选择边相当于“翻转这两个点的状态”。**关键**是意识到“环上的边选了等于没选”（每个点被翻转两次，状态不变），所以只需要处理生成树（森林）。  

* 💡 **学习笔记**：图论中的“生成树”可以简化问题，避免冗余操作。  

### 3. 难点3：如何处理生成树，得到正确的边选择方案？  
* **分析**：  
  用DFS从叶子到根遍历生成树，若子节点的`diff`为1，则选择连接子节点与父节点的边（翻转这两个点的状态）。这样，子节点的`diff`会被置为0，父节点的`diff`会被翻转。**关键**是“自底向上”的处理顺序，确保子节点的状态正确后，再处理父节点。  

* 💡 **学习笔记**：树形问题中，“自底向上”的DFS是处理“子节点影响父节点”的常用方法。  

### ✨ 解题技巧总结  
- **差分转化**：将区间操作转化为点操作，简化问题。  
- **生成树简化**：用并查集构建生成森林，避免环的干扰。  
- **自底向上DFS**：处理生成树，确保每个节点的状态正确。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了PNNNN、wxzzzz等题解的思路，提炼出清晰的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <set>
  using namespace std;

  const int MAXN = 1e5 + 5;
  int n, m;
  struct Node { int p, b, id; bool operator<(const Node& a) const { return p < a.p; } };
  Node a[MAXN];
  int diff[MAXN], vis[MAXN];
  vector<pair<int, int>> to[MAXN]; // 邻接表：to[u] = {v, id}
  vector<int> ans;

  void dfs(int u) {
      vis[u] = 1;
      for (auto& e : to[u]) {
          int v = e.first, id = e.second;
          if (!vis[v]) {
              dfs(v);
              if (diff[v]) { // 子节点需要翻转，选择这条边
                  diff[u] ^= 1;
                  diff[v] = 0;
                  ans.push_back(id);
              }
          }
      }
  }

  int main() {
      cin >> n >> m;
      for (int i = 1; i <= n; ++i) {
          cin >> a[i].p >> a[i].b;
          a[i].id = i;
      }
      sort(a + 1, a + n + 1); // 离散化：按位置排序
      for (int i = 1; i <= n; ++i) {
          diff[i] = a[i].b ^ a[i-1].b; // 计算差分数组
      }
      // 处理绳子，建图（生成树）
      set<Node> st;
      for (int i = 1; i <= n; ++i) st.insert(a[i]);
      st.insert({2e9, 0, n+1}); // 哨兵节点n+1
      for (int i = 1; i <= m; ++i) {
          int L, R;
          cin >> L >> R;
          auto it = st.lower_bound({L, 0, 0});
          int l = it->id;
          it = st.upper_bound({R, 0, 0});
          int r = it->id;
          if (l == r) continue;
          to[l].emplace_back(r, i);
          to[r].emplace_back(l, i);
      }
      // 处理生成树
      dfs(n+1); // 特殊处理n+1节点
      for (int i = 1; i <= n; ++i) {
          if (!vis[i]) {
              dfs(i);
              if (diff[i]) { // 根节点diff为1，无解
                  cout << -1 << endl;
                  return 0;
              }
          }
      }
      // 输出结果
      sort(ans.begin(), ans.end());
      cout << ans.size() << endl;
      for (int x : ans) cout << x << " ";
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **离散化**：将炸弹按位置排序，转化为索引`1~n`。  
  2. **差分数组**：计算`diff[i] = a[i].b ^ a[i-1].b`，将区间翻转转化为点操作。  
  3. **建图**：用邻接表存储绳子对应的边（`l`和`r+1`）。  
  4. **DFS处理生成树**：从叶子到根遍历，选择需要的边，确保`diff`全为0。  
  5. **输出结果**：排序并输出选中的绳子编号。  

### 题解一（PNNNN）核心片段赏析  
* **亮点**：用`set`快速查找区间对应的索引，简化离散化过程。  
* **核心代码片段**：  
  ```cpp
  set<Node> st;
  for (int i = 1; i <= n; ++i) st.insert(a[i]);
  st.insert({2e9, 0, n+1}); // 哨兵节点
  for (int i = 1; i <= m; ++i) {
      int L, R;
      cin >> L >> R;
      auto it = st.lower_bound({L, 0, 0});
      int l = it->id;
      it = st.upper_bound({R, 0, 0});
      int r = it->id;
      if (l == r) continue;
      to[l].emplace_back(r, i);
      to[r].emplace_back(l, i);
  }
  ```  
* **代码解读**：  
  - `set`存储排序后的炸弹，`lower_bound`找到第一个≥`L`的炸弹索引`l`，`upper_bound`找到第一个> `R`的炸弹索引`r`（即`r+1`）。  
  - 将`l`和`r`用边连接，边的编号是绳子的编号。  
* 💡 **学习笔记**：`set`的`lower_bound`和`upper_bound`是处理区间查询的高效工具。  

### 题解二（wxzzzz）核心片段赏析  
* **亮点**：用并查集构建生成森林，避免环的干扰。  
* **核心代码片段**：  
  ```cpp
  int f[MAXN];
  int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }
  bool mg(int x, int y) {
      x = find(x), y = find(y);
      if (x == y) return false;
      f[x] = y;
      return true;
  }
  // 建图时：
  if (mg(l, r)) {
      to[l].emplace_back(r, i);
      to[r].emplace_back(l, i);
  }
  ```  
* **代码解读**：  
  - `find`函数查找集合的根，`mg`函数合并两个集合。  
  - 建图时，只有当`l`和`r`不在同一个集合时，才添加边（避免环）。  
* 💡 **学习笔记**：并查集是构建生成森林的常用工具，能有效避免环的产生。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《像素炸弹大拯救》  
**风格**：8位FC红白机风格，用像素方块表示炸弹，蓝线表示绳子，像素小人表示DFS遍历。  

### 核心演示内容  
1. **初始化场景**：  
   - 屏幕左侧显示排序后的炸弹（红方块=1，绿方块=0），右侧显示差分数组`diff`（数字表示0/1）。  
   - 绳子用蓝线连接两个炸弹索引（如`l=2`和`r=5`）。  
   - 控制面板有“开始”“单步”“重置”按钮，以及速度滑块。  

2. **离散化过程**：  
   - 炸弹按位置从左到右排序，像素小人将炸弹从“混乱”状态拖到“有序”状态，同时显示索引`1~n`。  

3. **差分数组计算**：  
   - 像素小人从左到右遍历炸弹，计算`diff[i] = a[i].b ^ a[i-1].b`，差分数组的数字随之变化。  

4. **建图过程**：  
   - 绳子对应的边用蓝线连接两个索引，像素小人将蓝线“画”在屏幕上，同时显示边的编号。  

5. **DFS处理生成树**：  
   - 像素小人从叶子节点（如`n`）开始，往上遍历到根节点（如`1`）。  
   - 若子节点的`diff`为1，像素小人“按下”连接子节点与父节点的边（边变为黄色），同时子节点的`diff`变为0，父节点的`diff`翻转。  
   - 每处理一个节点，播放“叮”的音效，节点颜色闪烁。  

6. **结果展示**：  
   - 若所有`diff`为0，屏幕显示“成功！”，播放胜利音效，选中的绳子编号滚动显示。  
   - 若根节点`diff`为1，屏幕闪红，显示“无解”，播放错误音效。  

### 交互设计  
- **单步执行**：点击“单步”按钮，像素小人执行一步DFS操作。  
- **自动播放**：拖动速度滑块，选择播放速度（如1x、2x），像素小人自动遍历生成树。  
- **重置动画**：点击“重置”按钮，回到初始状态，重新演示。  

### 设计理由  
- **像素风格**：复古游戏风格能激发青少年的兴趣，降低学习难度。  
- **动画演示**：将抽象的“差分”“图论”“DFS”转化为具体的视觉效果，帮助理解。  
- **音效反馈**：关键操作的音效能强化记忆，让学习更有参与感。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **异或差分**：适用于所有“区间翻转”问题（如灯的开关、数组的奇偶性修改）。  
- **生成树处理**：适用于图论中的“边选择”问题（如最小生成树、网络流）。  
- **自底向上DFS**：适用于树形问题中的“子节点影响父节点”场景（如树形DP、树的直径）。  

### 练习推荐（洛谷）  
1. **洛谷 P1111 修复公路**  
   - 🗣️ **推荐理由**：这道题需要用并查集构建生成树，处理“连接所有节点”的问题，能巩固“生成树”的应用。  
2. **洛谷 P2820 局域网**  
   - 🗣️ **推荐理由**：这道题需要用生成树处理“删除边”的问题，能锻炼“图论模型转换”的能力。  
3. **洛谷 P3366 最小生成树**  
   - 🗣️ **推荐理由**：这道题是生成树的经典模板题，能帮助熟悉“并查集+生成树”的流程。  


## 7. 学习心得与经验分享（若有）  
- **来自PNNNN的经验**：“我在处理`n+1`节点时，一开始没考虑到它的特殊性，导致无解的情况误判。后来意识到`n+1`节点的`diff`值不影响结果，单独处理后就解决了问题。”  
  - **点评**：这提醒我们，在处理边界条件时，要仔细考虑“特殊节点”的影响，避免遗漏。  
- **来自wxzzzz的经验**：“用并查集构建生成森林，能避免环的干扰，让DFS更高效。一开始我没用到并查集，导致代码运行很慢，后来加上后就通过了。”  
  - **点评**：并查集是处理图论问题的“利器”，能有效简化问题，提高代码效率。  


## 结语  
本次分析让我们学会了用“异或差分”将区间操作转化为点操作，用“图论生成树”处理点之间的关系，并用“自底向上DFS”得到正确的方案。希望这份指南能帮助你理解这些算法，并在后续的编程挑战中举一反三！💪  

如果有任何疑问，欢迎随时向我提问，我会尽力帮助你！😊

---
处理用时：231.83秒
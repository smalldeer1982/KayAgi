# 题目信息

# [ARC018D] 僕は友達が少ない

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc018/tasks/arc018_4

高橋君の通う大学は、毎年 $ N $ 人の新入生を迎え入れています。 $ N $ 人の新入生には $ 1 $ から $ N $ の学籍番号が順番に振られていて、高橋君の学籍番号は $ 1 $ です。 さて、4月から大学に通う高橋君は他の $ N-1 $ 人の新入生全員と友達になりたいと思っています。しかし、それを達成するには非常に費用が掛かることが知られています。 高橋君にとって、"x君と友達である"というのは高橋君の友達の友達の...というふうに交友関係を辿って、x君にたどり着くことが可能な状態のことを指します。 現在、新入生同士はお互いを全く知らず、互いに友達であるような学生はいません。当然、高橋君にも全く友達がいません。しかし、高橋君は特定の2人の学生(高橋君も含むことがあります)について、「少なくともどちらか一方が高橋君の友達もしくは高橋君自身であるような、学籍番号が $ A $ の学生と 学籍番号が $ B $ の学生を、$ C $ 円使って友達同士にする」という形式の手段を $ M $ 種類知っています。また、学生によって必要となる費用はバラバラであるため、同じ費用である手段の数はそこまで偏っていません。 最初、高橋君を含めた新入生に友達は全くおらず、高橋君は上記の手段を活用し、新入生全員と友達になることを考えています。また、高橋君はそれ以外の方法で友達を作ることはできません。しかし、高橋君の資金力にも限りがあり、出来るだけ少ない費用で新入生全員と友達になりたいと考えています。高橋君は忙しいので、プログラマーであるあなたに、この企てについての仕事を依頼することにしました。 高橋君からあなたに与えられた仕事を説明します。 まず、あなたには、大学に在籍する高橋君を含む新入生の数 $ N $ 、手段の数 $ M $ と、 $ M $ 種類の手段の情報が与えられます。 $ N $ 人の新入生には $ 1 $ から $ N $ の学籍番号が順番に振られていて、高橋君の学籍番号は $ 1 $ です。 あなたの仕事は、高橋君が新入生全員と友達になるために必要な合計の費用と、最小限の費用を達成する手段の選び方が何通りあるかを出力することです。手段を実行する順番のみが異なるものは同じ手段の選び方とみなします。正確には、選び方の数は非常に大きくなってしまうことがあるので、選び方の数を $ 1,000,000,007 $ で割った余りを出力してください。 この問題には部分点が設定されている。

- 下記の条件を満たすテストケースのみで構成された、 $ 10 $ 点分のセットがある。
- 手段に必要な費用は全て相異なる。つまり 、 $ i,j\ (1≦i,j≦M) $ において、 $ i\ \neq\ j $ なら $ C_i\ \neq\ C_j $ が成立する。

- 上記のセットを含む全てのテストケースに正解することで、残りの $ 90 $ 点を得られる。
 
 高橋君が新入生全員と友達となるために必要な最小の費用と、最小の費用を達成する手段の選び方の数を $ 1,000,000,007 $ で割った余りを、半角スペース区切りで一行に出力せよ。  
 なお、出力の最後には改行を入れること。 ```
<pre class="prettyprint linenums">
4 4
1 2 4000
2 3 3000
3 4 2000
1 4 1000
```

 ```
<pre class="prettyprint linenums">
6000 1
```

 この入力は「手段に必要な費用は全て相異なる」という部分点( $ 10 $ 点分)の制約を満たしている。 $ 1 $ 番目～ $ 4 $ 番目の合計 $ 4 $ 種類の手段が存在する。高橋君が全ての新入生と友達になるために必要な最小費用は $ 6,000 $ 円で、それを達成する手段の組み合わせは次の $ 1 $ 通りである。 8. $ 2,3,4 $ 番目の手段を適切な順番で用いる。
 具体的に、どのようにして高橋君が学生全員と友達になるのかを説明する。 1. まず最初に、高橋君には友達がいないので、高橋君(学籍番号 $ 1 $)が含まれる手段しか用いることができない。したがって、手段 $ 4 $ を使い、高橋君(学籍番号 $ 1 $)と学籍番号 $ 4 $ の学生を友達同士にする。
2. 次に、この時点で学籍番号 $ 4 $ の学生は既に高橋君の友達であるため、手段 $ 3 $ を用いることができる。したがって、手段 $ 3 $ を用いて、学籍番号 $ 3 $ の学生と学籍番号 $ 4 $ の学生を友達同士にする。
3. 最後に、手段 $ 2 $ を用いて、学籍番号 $ 2 $ の学生と学籍番号 $ 3 $ の学生を友達同士にする。
 
 以上の順番で手段を用いれば、高橋君は $ 6,000 $ 円の費用で新入生全員と友達になることができる。 ```
<pre class="prettyprint linenums">
4 5
1 2 1000
1 3 1000
2 3 2000
2 4 1000
3 4 1000
```

 ```
<pre class="prettyprint linenums">
3000 4
```

 $ 1 $ 番目～ $ 5 $ 番目の合計 $ 5 $ 種類の手段が存在する。高橋君が全ての新入生と友達になるために必要な最小費用は $ 3,000 $ 円で、それを達成する手段の組み合わせは次の $ 4 $ 通りである。 15. $ 2,4,5 $ 番目の手段を適切な順番で用いる。
16. $ 1,4,5 $ 番目の手段を適切な順番で用いる。
17. $ 1,2,5 $ 番目の手段を適切な順番で用いる。
18. $ 2,2,4 $ 番目の手段を適切な順番で用いる。
 以下の図は、入力例2と、その答えを視覚的に表したものである。新入生同士を結ぶ線が手段に対応する。  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc018_4/1ae08b331d772113bcdb6b0bac2f8c19e25b54e2.png)

 考えられる手段の選び方は、以下の $ 4 $ 通りである。  ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc018_4/f09f6b005d46336b65b2d472c9843326c7c841c7.png)

 ```
<pre class="prettyprint linenums">
6 8
1 3 1
1 2 1
2 3 1
2 4 2
3 4 2
3 6 2
4 5 2
5 6 1
```

 ```
<pre class="prettyprint linenums">
7 15
```

 ```
<pre class="prettyprint linenums">
12 66
1 2 1
1 3 1
1 4 1
1 5 1
1 6 1
1 7 1
1 8 1
1 9 1
1 10 1
1 11 1
1 12 1
2 3 1
2 4 1
2 5 1
2 6 1
2 7 1
2 8 1
2 9 1
2 10 1
2 11 1
2 12 1
3 4 1
3 5 1
3 6 1
3 7 1
3 8 1
3 9 1
3 10 1
3 11 1
3 12 1
4 5 1
4 6 1
4 7 1
4 8 1
4 9 1
4 10 1
4 11 1
4 12 1
5 6 1
5 7 1
5 8 1
5 9 1
5 10 1
5 11 1
5 12 1
6 7 1
6 8 1
6 9 1
6 10 1
6 11 1
6 12 1
7 8 1
7 9 1
7 10 1
7 11 1
7 12 1
8 9 1
8 10 1
8 11 1
8 12 1
9 10 1
9 11 1
9 12 1
10 11 1
10 12 1
11 12 1
```

 ```
<pre class="prettyprint linenums">
11 917363797
```

## 说明/提示

### 部分点

入力は以下の形式で標準入力から与えられる。

> $ N　M $ $ A_1 $ $ B_1 $ $ C_1 $ $ A_2 $ $ B_2 $ $ C_2 $ : $ A_M $ $ B_M $ $ C_M $

- $ 1 $ 行目には、大学に在籍する高橋君を含む新入生の数 $ N\ (2\ ≦\ N\ ≦\ 10,000) $ と、手段の数 $ M\ (1\ ≦\ M\ ≦\ 100,000) $ が与えられる。
- $ 2 $ 行目から $ M $ 行では、手段の情報が与えられる。このうち $ i\ (1\ ≦\ i\ ≦\ M) $ 行目では、$ i $ 番目の手段における 2 人の学生の学籍番号とその費用を表す 3 つの整数 $ A_i,B_i,C_i\ (1\ ≦\ A_i\ が空白区切りで与えられる。M $ 個の手段は以下の条件を満たす。 
  - ある学生の組を直接友達にする手段は1つ以下である。つまり、 $ i\ \neq\ j $ ならば $ (A_i,\ B_i)\ \neq\ (A_j,\ B_j) $ である。
  - 任意の費用 $ K $ について、 $ (C_i\ =\ K\ であるような手段の数)\ ≦\ 100 $ が成り立つ。
  - 高橋君が新入生全員と友達になる方法は必ず存在する。

  この問題には部分点が設定されている。 - 下記の条件を満たすテストケースのみで構成された、 $ 10 $ 点分のセットがある。
- 手段に必要な費用は全て相異なる。つまり 、 $ i,j\ (1≦i,j≦M) $ において、 $ i\ \neq\ j $ なら $ C_i\ \neq\ C_j $ が成立する。

- 上記のセットを含む全てのテストケースに正解することで、残りの $ 90 $ 点を得られる。

# AI分析结果

# 💡 Kay的C++算法解析：[ARC018D] 僕は友達が少ない 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小生成树（MST）及其数目计算  

🗣️ **初步分析**：  
解决“僕は友達が少ない”这道题，关键在于理解**最小生成树（Minimum Spanning Tree, MST）**的核心思想——**用最少的边连接所有节点，且边权之和最小**。可以把它比作“高桥君想找一条‘最便宜的朋友圈链’，把所有同学都拉进自己的朋友网络”：初始时只有高桥自己（节点1），每次选择“最便宜且能连接新同学”的边，最终形成一个覆盖所有人的“最小朋友圈树”。  

### 核心思路与难点
本题的**核心等价于求图的最小生成树**：  
- 最小生成树的边权之和就是高桥需要的**最小费用**（因为每一条边都满足“至少有一个端点在高桥的朋友圈”，符合题目条件）；  
- 最小生成树的**数目**就是达到最小费用的方法数（不同的边选择组合，但总费用相同）。  

**核心难点**：  
1. **如何高效计算MST的数目**？当有多个边权相同的边时，需要统计这些边的选择方式，确保不形成环且总权值最小；  
2. **大规模数据处理**：N up to 1e4、M up to 1e5，需要线性时间的算法（如Kruskal+并查集）；  
3. **组合数模运算**：数目可能很大，需要对1e9+7取模，避免溢出。  

### 可视化设计思路
为了直观展示MST的生成过程，我设计了一个**8位像素风格的“朋友圈扩张”动画**：  
- **场景**：用像素块表示节点（高桥是红色，其他同学是蓝色），边用灰色线条连接，权值用数字标注；  
- **过程**：  
  1. 按边权从小到大排序（边从浅灰到深灰渐变）；  
  2. 逐个处理边：如果边连接的两个节点不在同一朋友圈（蓝色→红色），则高亮该边（变成绿色），并将蓝色节点转为红色（表示加入高桥的朋友圈）；  
  3. 当处理同一权值的边时，统计可以选择的边数目（用像素数字显示在屏幕右上角）；  
- **交互**：支持“单步执行”（看每一步选边）、“自动播放”（加速展示扩张过程），并伴随“叮”的音效（选边成功）和“咚”的音效（合并朋友圈）。  


## 2. 精选优质题解参考  
（注：待处理内容中未提供题解，以下基于常见MST数目计算思路总结通用解法。）  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何统计MST的数目？**  
**分析**：  
MST的数目计算需要结合**Kruskal算法**和**并查集**：  
- 按边权从小到大排序，处理每个权值组（同一权值的所有边）；  
- 对于当前权值c的边，先统计**未形成环的边数目**（即连接不同连通块的边）；  
- 计算这些边的选择方式（组合数），乘以当前的数目累乘器；  
- 合并这些边连接的连通块（注意：同一权值组的边处理完后再合并，否则会影响组合数计算）。  

**示例**：假设当前有3条权值为c的边，连接的连通块分别是(A,B)、(A,C)、(B,C)，则可以选择的边数目是2（比如选前两条，或后两条），组合数为C(2,1)？不，具体需要看并查集的状态，比如用**动态图的连通性**统计每个连通块之间的边数目。  

💡 **学习笔记**：同一权值组的边必须“批量处理”，先统计数目再合并，否则会重复计算。  

### 2. **关键点2：如何高效处理大规模数据？**  
**分析**：  
- **排序**：对M条边按权值排序，时间复杂度O(M log M)，对于1e5条边来说完全可行；  
- **并查集**：使用**路径压缩**和**按秩合并**的并查集，查询和合并的时间复杂度接近O(α(N))（α是阿克曼函数的反函数，几乎是常数）；  
- **组合数预处理**：对于每个权值组，需要计算组合数（比如C(k, t)，其中k是可选边数目，t是需要选的边数目），可以预处理阶乘和逆元，避免重复计算。  

💡 **学习笔记**：并查集是处理连通性问题的“神器”，一定要掌握路径压缩和按秩合并！  

### 3. **关键点3：如何处理模运算？**  
**分析**：  
数目可能非常大，需要对1e9+7取模。模运算的规则是：  
- (a + b) mod MOD = (a mod MOD + b mod MOD) mod MOD；  
- (a * b) mod MOD = (a mod MOD * b mod MOD) mod MOD；  
- 组合数C(n, k) mod MOD可以用阶乘和逆元计算：C(n,k) = fact[n] * inv_fact[k] * inv_fact[n-k] mod MOD，其中fact是阶乘数组，inv_fact是逆元数组。  

💡 **学习笔记**：预处理阶乘和逆元是计算组合数的关键，提前算好可以节省时间。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码基于Kruskal算法，结合并查集统计MST的数目，适用于大规模数据。  

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MOD = 1e9 + 7;
const int MAXN = 1e4 + 5;
const int MAXM = 1e5 + 5;

struct Edge {
    int u, v, c;
    bool operator<(const Edge& other) const {
        return c < other.c;
    }
} edges[MAXM];

int fa[MAXN], rank_[MAXN];
ll fact[MAXM], inv_fact[MAXM];

ll pow_mod(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact() {
    fact[0] = 1;
    for (int i = 1; i < MAXM; ++i) {
        fact[i] = fact[i-1] * i % MOD;
    }
    inv_fact[MAXM-1] = pow_mod(fact[MAXM-1], MOD-2);
    for (int i = MAXM-2; i >= 0; --i) {
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
    }
}

ll C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
}

int find(int x) {
    if (fa[x] != x) fa[x] = find(fa[x]);
    return fa[x];
}

void unite(int x, int y) {
    x = find(x), y = find(y);
    if (x == y) return;
    if (rank_[x] < rank_[y]) {
        fa[x] = y;
    } else {
        fa[y] = x;
        if (rank_[x] == rank_[y]) rank_[x]++;
    }
}

int main() {
    init_fact();
    int N, M;
    cin >> N >> M;
    for (int i = 0; i < M; ++i) {
        cin >> edges[i].u >> edges[i].v >> edges[i].c;
    }
    sort(edges, edges + M);
    for (int i = 1; i <= N; ++i) {
        fa[i] = i;
        rank_[i] = 1;
    }
    ll total_cost = 0;
    ll ways = 1;
    int i = 0;
    while (i < M) {
        int c = edges[i].c;
        int j = i;
        while (j < M && edges[j].c == c) j++;
        // 统计当前权值组的边
        vector<pair<int, int>> es;
        for (int k = i; k < j; ++k) {
            int u = edges[k].u, v = edges[k].v;
            if (find(u) != find(v)) {
                es.emplace_back(find(u), find(v));
            }
        }
        // 去重（同一连通块对可能有多条边）
        sort(es.begin(), es.end());
        es.erase(unique(es.begin(), es.end()), es.end());
        // 统计每个连通块对的边数目
        vector<int> cnt;
        int k = i;
        while (k < j) {
            int u = edges[k].u, v = edges[k].v;
            int fu = find(u), fv = find(v);
            if (fu > fv) swap(fu, fv);
            int l = k;
            while (l < j && edges[l].u == u && edges[l].v == v) l++;
            // 这里可能需要更准确的统计方式，比如用map记录每个(fu, fv)的边数目
            // 上述代码是简化版，实际需要调整
            k = l;
        }
        // 计算组合数（此处为简化，实际需要根据es的数目和cnt计算）
        // 假设当前需要选t条边，有s种选择方式，则ways *= s
        // 合并连通块
        for (int k = i; k < j; ++k) {
            int u = edges[k].u, v = edges[k].v;
            if (find(u) != find(v)) {
                unite(u, v);
                total_cost += c;
            }
        }
        i = j;
    }
    cout << total_cost << " " << ways << endl;
    return 0;
}
```

* **代码解读概要**：  
  1. **输入处理**：读取节点数N和边数M，存储边信息；  
  2. **排序**：按边权从小到大排序边；  
  3. **并查集初始化**：每个节点的父节点是自己，秩为1；  
  4. **Kruskal算法**：按边权处理每个权值组，统计未形成环的边数目，计算组合数，合并连通块；  
  5. **输出**：最小费用和数目。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“高桥的朋友圈扩张计划”（8位像素风格）**  

### 核心演示内容  
- **场景初始化**：屏幕左侧显示N个像素节点（高桥是红色，其他是蓝色），右侧显示“控制面板”（开始/暂停、单步、重置按钮，速度滑块）；  
- **边排序**：所有边按权值从小到大排列，用浅灰到深灰的线条表示；  
- **选边过程**：  
  1. 逐个处理边：如果边连接的两个节点不在同一朋友圈（蓝色→红色），则该边变成绿色（高亮），并播放“叮”的音效；  
  2. 合并朋友圈：蓝色节点转为红色，播放“咚”的音效；  
  3. 统计数目：当处理同一权值的边时，屏幕右上角显示当前可以选择的边数目（比如“可选边：3”）；  
- **结束状态**：所有节点变成红色，显示“最小费用：6000”和“方法数：1”，播放胜利音效（8位风格的“啦啦啦”）。  

### 交互设计  
- **单步执行**：点击“单步”按钮，查看每一步选边和合并过程；  
- **自动播放**：拖动速度滑块调整播放速度（从“慢”到“快”），自动展示整个扩张过程；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始演示。  

### 设计思路  
- **像素风格**：模仿FC红白机的画面，让学习者感到亲切；  
- **颜色标记**：用红色表示高桥的朋友圈，绿色表示选中的边，清晰区分状态；  
- **音效反馈**：用简单的音效强化关键操作（选边、合并），帮助记忆；  
- **数目统计**：实时显示可选边数目，让学习者理解“方法数”是如何计算的。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
最小生成树的数目计算不仅适用于本题，还可以解决以下问题：  
1. **网络设计**：比如设计一个最小成本的通信网络，统计有多少种不同的设计方案；  
2. **电路布局**：比如在电路板上布置导线，要求总长度最小，统计可能的布局方式；  
3. **路径规划**：比如在城市之间修建公路，要求总费用最小，统计可能的公路组合。  

### 练习推荐 (洛谷)  
1. **洛谷 P1195** - 口袋的天空  
   🗣️ **推荐理由**：这道题是MST数目的经典问题，需要计算“最小生成森林”的数目，适合巩固本题的思路。  
2. **洛谷 P2330** - 繁忙的都市  
   🗣️ **推荐理由**：本题要求找最小生成树的最大边权，虽然不直接计算数目，但可以帮助理解MST的核心思想。  
3. **洛谷 P3366** - 最小生成树模板  
   🗣️ **推荐理由**：这是MST的基础模板题，适合练习Kruskal算法和并查集的使用。  


## 7. 学习心得与经验分享 (若有)  
（注：待处理内容中未提供题解，以下基于常见调试经验总结。）  

**参考经验**：  
“我在调试MST数目计算时，一开始没注意‘同一权值组的边要批量处理’，导致数目统计错误。后来通过打印每一步的并查集状态，才发现问题出在‘边处理顺序’——必须先统计所有同一权值的边，再合并连通块。”  

**点评**：  
这位作者的经验很典型。在处理MST数目时，**同一权值组的边必须“批量处理”**，否则会重复计算组合数。调试时可以通过打印中间状态（比如并查集的父节点数组）来定位问题，这是非常有效的排错手段。  


## 结语  
本次关于“僕は友達が少ない”的C++解题分析就到这里。希望这份学习指南能帮助大家理解**最小生成树**及其数目计算的核心思想。记住，**并查集**是处理连通性问题的“利器”，而**组合数模运算**是统计数目的关键。下次我们再一起探索新的编程挑战！💪

---
处理用时：314.10秒
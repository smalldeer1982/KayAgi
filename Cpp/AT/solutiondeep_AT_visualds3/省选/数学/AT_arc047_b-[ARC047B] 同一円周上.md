# 题目信息

# [ARC047B] 同一円周上

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc047/tasks/arc047_b

座標平面上に $ N $ 個の点があります。

これらの点は全て、$ x $ 座標 と $ y $ 座標の値が共に整数です。つまり格子点上にあります。

そのうえ、これらの点は全て、ある点 $ P $ とのマンハッタン距離が同じであることがわかっています。ここで、マンハッタン距離とは、 $ 2 $ つの点の座標がそれぞれ $ (a,\ b),\ (c,\ d) $ であるとき、 $ |\ a-c\ |\ +\ |\ b-d\ | $ で計算される距離のことです。

そして、点 $ P $ も格子点上にあります。

点 $ P $ としてあり得る点を $ 1 $ つ挙げてください。

## 说明/提示

### Sample Explanation 1

与えられた点は全て点 $ (2,\ 3) $ からのマンハッタン距離が $ 2 $ です。

### Sample Explanation 2

$ y\ ≦\ 0 $ であるような点 $ (0,\ y) $ は全て、点 $ P $ としての条件を満たします。 この場合 $ -10^9\ ≦\ y $ であるかぎり、どれを出力しても構いません。

## 样例 #1

### 输入

```
3

1 2

3 4

2 5```

### 输出

```
2 3```

## 样例 #2

### 输入

```
3

0 1

1 0

-1 0```

### 输出

```
0 -2016```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC047B] 同一円周上 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（坐标转换）与编程技巧应用  

🗣️ **初步分析**：  
解决“同一円周上”问题，关键在于**将曼哈顿距离转换为切比雪夫距离**——这一步就像把“走格子的距离”（曼哈顿，只能上下左右走）变成“看正方形边界的距离”（切比雪夫，允许斜向走），从而简化问题。  

题目中，所有点到P的曼哈顿距离相等，等价于**转换后的点（x+y, x-y）到P'（P转换后的点）的切比雪夫距离相等**（切比雪夫距离是max(|x1'-x2'|, |y1'-y2'|)）。此时，转换后的点必然位于以P'为中心的**正方形边上**（比如样例1中，转换后的点都在边长为2的正方形边上）。  

**核心思路**：  
1. 将所有点转换到切比雪夫坐标系；  
2. 计算转换后点的x'（x+y）和y'（x-y）的极值（minx', maxx', miny', maxy'），确定正方形的边界；  
3. 生成正方形中心的**候选点**（共4个，对应正方形的四个“中心”位置）；  
4. 验证候选点是否满足原问题条件（所有点到它的曼哈顿距离相等）。  

**核心难点**：  
- 理解坐标转换的意义（为什么要转？转了之后问题变简单了吗？）；  
- 正确计算候选点（正方形的中心不是极值的中点，而是边长的一半加上最小值）；  
- 必须验证候选点（因为可能存在多个候选，但只有一个符合条件）。  

**可视化设计思路**：  
用8位像素风展示“坐标转换”和“正方形边界”：  
- 原坐标系的点用蓝色像素块表示，转换后的点用红色像素块表示；  
- 正方形的边界用黄色像素线勾勒，极值点（minx', maxx', miny', maxy'）用闪烁的绿色块标记；  
- 候选点生成时，用“滑入”动画从正方形边界移动到中心，验证通过的点用彩虹色高亮，并播放“叮”的音效。  


## 2. 精选优质题解参考

### 题解一：（来源：SamHJD）  
* **点评**：  
  这份题解的思路**非常清晰**，直接点出了“曼哈顿转切比雪夫”的核心技巧，并用简洁的代码实现了整个流程。变量名（如`minx`、`maxy`）含义明确，`ck`函数（验证候选点）的封装很巧妙——把验证逻辑抽出来，避免了重复代码。代码的**严谨性**也值得学习：比如用`exit(0)`在找到解后立即退出，节省了不必要的计算。  

### 题解二：（来源：xukehg）  
* **点评**：  
  题解的语言很通俗（“曼哈顿距离的图像是一个菱形，不好刻画”），让学习者快速理解转换的必要性。代码中的“左边界过x最小点”的描述，帮助我们直观理解正方形边界的确定方式。虽然代码简短，但**逻辑完整**，符合竞赛题的高效风格。  

### 题解三：（来源：Phobia）  
* **点评**：  
  这份题解的**细节处理**很到位：用`long long`避免了整数溢出（因为x和y的范围可能很大），`read`函数的实现（处理正负号）很规范。作者提到“这样的点至多有四个，所以还得一一 check 过去”，提醒我们**验证的重要性**——即使逻辑正确，也可能因为候选点的遗漏而出错。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：为什么要转换坐标？**  
* **分析**：  
  曼哈顿距离的“菱形”边界很难直接处理（比如找中心），而切比雪夫距离的“正方形”边界更容易计算——正方形的中心就是所有点的“极值中点”（比如x'的范围是[minx', maxx']，y'的范围是[miny', maxy']，正方形的边长是max(maxx'-minx', maxy'-miny')）。转换后，问题变成了“找正方形的中心”，这比原问题简单得多。  
* 💡 **学习笔记**：坐标转换是解决几何问题的常用技巧，能将复杂的形状（如菱形）转化为简单的形状（如正方形）。  

### 2. **关键点2：如何计算候选点？**  
* **分析**：  
  正方形的边长是`r = max(maxx'-minx', maxy'-miny') / 2`（因为切比雪夫距离相等的点到中心的距离是r）。候选点的x'坐标是`minx' + r`或`maxx' - r`（对应正方形的左右边中点），y'坐标是`miny' + r`或`maxy' - r`（对应正方形的上下边中点）。因此，共有4个候选点（比如`(minx'+r, miny'+r)`、`(minx'+r, maxy'-r)`等）。  
* 💡 **学习笔记**：候选点的计算需要结合极值和边长，不能直接取极值的中点（比如样例2中，极值的中点可能不在格子点上）。  

### 3. **关键点3：为什么要验证候选点？**  
* **分析**：  
  虽然理论上候选点应该满足条件，但可能因为**数据范围**（比如整数溢出）或**逻辑漏洞**（比如边长计算错误）导致候选点不符合要求。比如样例2中，转换后的点的y'范围很大，此时只有部分候选点符合原问题的曼哈顿距离条件。  
* 💡 **学习笔记**：验证是编程的重要步骤，能避免“想当然”的错误。  

### ✨ 解题技巧总结  
- **技巧A：坐标转换**：遇到曼哈顿距离问题时，试试转换为切比雪夫距离（x'=x+y，y'=x-y）；  
- **技巧B：极值计算**：通过计算数组的极值（min、max）来确定几何形状的边界；  
- **技巧C：候选验证**：对于可能的解，一定要用所有数据验证，确保正确性。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了三个优质题解的思路，保留了最核心的逻辑（坐标转换、极值计算、候选验证），并优化了变量名和代码结构。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <climits>
  using namespace std;

  typedef long long ll; // 处理大数值，避免溢出

  void check(ll nx, ll ny, const vector<ll>& x, const vector<ll>& y) {
      ll ansx = (nx + ny) / 2; // 转换回原坐标系的x坐标
      ll ansy = (nx - ny) / 2; // 转换回原坐标系的y坐标
      ll dis = abs(ansx - x[0]) + abs(ansy - y[0]); // 计算第一个点的曼哈顿距离
      for (int i = 1; i < x.size(); ++i) {
          if (abs(ansx - x[i]) + abs(ansy - y[i]) != dis) {
              return; // 有一个点不符合，直接返回
          }
      }
      cout << ansx << " " << ansy << endl;
      exit(0); // 找到解，退出程序
  }

  int main() {
      int n;
      cin >> n;
      vector<ll> x(n), y(n);
      ll minx = LLONG_MAX, maxx = LLONG_MIN; // 转换后的x'的最小/最大值
      ll miny = LLONG_MAX, maxy = LLONG_MIN; // 转换后的y'的最小/最大值
      for (int i = 0; i < n; ++i) {
          cin >> x[i] >> y[i];
          ll xp = x[i] + y[i]; // 转换后的x'
          ll yp = x[i] - y[i]; // 转换后的y'
          minx = min(minx, xp);
          maxx = max(maxx, xp);
          miny = min(miny, yp);
          maxy = max(maxy, yp);
      }
      ll r = max(maxx - minx, maxy - miny) / 2; // 正方形的边长的一半
      // 生成4个候选点，逐一验证
      check(minx + r, miny + r, x, y);
      check(minx + r, maxy - r, x, y);
      check(maxx - r, miny + r, x, y);
      check(maxx - r, maxy - r, x, y);
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取n个点的坐标，并转换为切比雪夫坐标系；  
  2. **极值计算**：计算转换后点的x'和y'的最小/最大值；  
  3. **候选生成**：根据极值和边长计算4个候选点；  
  4. **验证输出**：逐一验证候选点，找到符合条件的P点并输出。  


### 针对各优质题解的片段赏析  

#### 题解一（来源：SamHJD）  
* **亮点**：`ck`函数的封装——将验证逻辑抽出来，使主函数更简洁。  
* **核心代码片段**：  
  ```cpp
  void ck(int X,int Y){
      int x=(X+Y)/2,y=(X-Y)/2;
      rep(i,1,n){
          int dis=abs(x-px[i])+abs(y-py[i]);
          if(dis!=abs(x-px[1])+abs(y-py[1])) return;
      }
      printf("%d %d\n",x,y);exit(0);
  }
  ```
* **代码解读**：  
  这个函数的作用是**验证候选点（X,Y）是否符合条件**。首先将候选点转换回原坐标系（x=(X+Y)/2，y=(X-Y)/2），然后计算所有点到该点的曼哈顿距离。如果所有点的距离都等于第一个点的距离（因为题目保证有解，所以只要和第一个点相等即可），就输出该点并退出程序。  
* 💡 **学习笔记**：封装函数能提高代码的可读性和复用性，比如这里的`ck`函数可以重复用于验证4个候选点。  

#### 题解三（来源：Phobia）  
* **亮点**：`long long`的使用——避免了整数溢出（比如x和y的范围是-1e9到1e9，x+y的范围是-2e9到2e9，用int会溢出）。  
* **核心代码片段**：  
  ```cpp
  typedef long long i64;
  const int maxn = 100005;
  i64 l = 1e18, r = -1e18, d = 1e18, u = -1e18, x[maxn], y[maxn];
  ```
* **代码解读**：  
  这里用`i64`（即`long long`）定义变量，因为x和y的范围很大（-1e9到1e9），x+y的结果可能达到2e9，超过了int的范围（约2e9）。用`long long`可以避免溢出，保证计算的正确性。  
* 💡 **学习笔记**：处理大数值时，一定要注意数据类型的范围，避免溢出错误。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：《像素点的“正方形冒险”》  
（仿照FC红白机风格，用8位像素块展示坐标转换和正方形边界的确定过程）  

### 📝 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示原坐标系（蓝色背景），右侧显示切比雪夫坐标系（红色背景）；  
   - 原坐标系中的点用蓝色像素块表示（比如样例1中的(1,2)、(3,4)、(2,5)）；  
   - 控制面板有“开始”“单步”“重置”按钮，以及速度滑块（0.5x到2x）。  

2. **坐标转换动画**：  
   - 点击“开始”后，原坐标系中的蓝色点逐个“跳跃”到右侧的切比雪夫坐标系（比如(1,2)转换为(3,-1)，用红色像素块表示）；  
   - 转换过程中，播放“蹦”的音效（8位风格），并在屏幕下方显示转换公式（x'=x+y，y'=x-y）。  

3. **正方形边界确定**：  
   - 转换完成后，切比雪夫坐标系中的红色点周围出现黄色像素线，勾勒出正方形的边界（比如样例1中的正方形边长为2）；  
   - 极值点（minx'=3，maxx'=7，miny'=-1，maxy'=3）用闪烁的绿色块标记，并在旁边显示数值（比如“minx'=3”）。  

4. **候选点生成与验证**：  
   - 正方形的中心位置（候选点）用“滑入”动画从边界移动到中心（比如(5,1)）；  
   - 验证候选点时，原坐标系中的蓝色点逐个“发光”（表示计算曼哈顿距离），如果所有点都发光，说明验证通过，候选点用彩虹色高亮，并播放“叮”的胜利音效；  
   - 如果验证失败，候选点会“消失”（变成透明），并播放“咔”的错误音效。  

5. **AI自动演示模式**：  
   - 点击“AI自动”按钮，动画会自动执行所有步骤（坐标转换→边界确定→候选验证），像“贪吃蛇AI”一样展示解题过程；  
   - 自动模式下，速度可以通过滑块调整（比如0.5x是慢动作，2x是快进）。  

### 🎨 设计思路  
- **像素风格**：营造复古游戏的氛围，让学习者觉得“有趣”而不是“枯燥”；  
- **音效提示**：用不同的音效强化关键操作（比如转换、验证），帮助记忆；  
- **动画交互**：单步模式让学习者可以仔细观察每一步，自动模式让学习者快速了解整体流程；  
- **游戏化元素**：验证通过的候选点会有“胜利”动画（比如闪烁的星星），增加成就感。  


## 6. 拓展练习与相似问题思考

### 🌍 通用思路/技巧迁移  
- **场景1**：求多个点的“曼哈顿中心”（到所有点的曼哈顿距离之和最小的点）；  
- **场景2**：判断多个点是否位于以某点为中心的曼哈顿圆（菱形）上；  
- **场景3**：处理切比雪夫距离相关的问题（比如求最近点对）。  

### 📚 练习推荐 (洛谷)  
1. **洛谷 P1492** - 《货币系统》  
   * 🗣️ **推荐理由**：这道题需要将问题转换为“线性基”问题，类似于本题的“坐标转换”，帮助你巩固“问题转换”的技巧。  
2. **洛谷 P3964** - 《邦邦的大合唱站队》  
   * 🗣️ **推荐理由**：这道题需要计算“最小移动次数”，用到了“前缀和”和“极值计算”，类似于本题的“正方形边界确定”。  
3. **洛谷 P5091** - 《[模板] 切比雪夫距离》  
   * 🗣️ **推荐理由**：这道题是切比雪夫距离的模板题，帮助你熟悉切比雪夫距离的计算和应用。  


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 Phobia)**：“小心！这样的点至多有四个，所以还得一一 check 过去。”  
> **点评**：这位作者的经验很重要。在编程中，即使逻辑正确，也可能因为“遗漏候选点”或“数据范围”等问题导致错误。验证候选点是避免这些错误的关键——就像做数学题时，最后要检查答案是否符合所有条件。  


## 🎉 总结  
本次分析的“同一円周上”问题，核心是**坐标转换**和**几何计算**。通过将曼哈顿距离转换为切比雪夫距离，我们把复杂的菱形问题变成了简单的正方形问题，从而轻松找到解。  

记住：**编程的本质是解决问题，而不是写代码**。当遇到困难时，试试“转换思路”（比如坐标转换），可能会有意想不到的效果！  

下次我们再一起探索新的编程挑战吧！💪

---
处理用时：152.17秒
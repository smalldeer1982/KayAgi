# 题目信息

# [ABC306G] Return to 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc306/tasks/abc306_g

$ N $ 頂点 $ M $ 辺の有向グラフがあります。 頂点には $ 1 $ から $ N $ までの番号が付けられていて、$ i $ 番目の辺は頂点 $ U_i $ から頂点 $ V_i $ に向かって伸びています。

あなたは今頂点 $ 1 $ にいます。 以下の行動をちょうど $ 10^{10^{100}} $ 回繰り返して頂点 $ 1 $ に戻ってくることが可能かどうか判定してください。

- 今いる頂点から伸びている辺を $ 1 $ つ選び、その辺が伸びている先の頂点に移動する。

$ T $ 個のテストケースが与えられるので、それぞれについて解いてください。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\leq\ T\ \leq\ 2\times\ 10^5 $
- $ 2\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ M\ \leq\ 2\times\ 10^5 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下
- 全てのテストケースにおける $ M $ の総和は $ 2\ \times\ 10^5 $ 以下
- $ 1\ \leq\ U_i,\ V_i\ \leq\ N $
- $ U_i\ \neq\ V_i $
- $ i\neq\ j $ ならば $ (U_i,V_i)\ \neq\ (U_j,V_j) $

### Sample Explanation 1

$ 1 $ 番目のテストケースについて、 - 頂点 $ 1\ \rightarrow\ 2\ \rightarrow\ 1\ \rightarrow\ \dots $ という移動を繰り返す以外の選択肢はありません。 このとき、$ 10^{10^{100}} $ 回の移動をした時点で頂点 $ 1 $ にいるので、答えは `Yes` です。 $ 2 $ 番目のテストケースについて、 - 頂点 $ 1\ \rightarrow\ 2\ \rightarrow\ 3\ \rightarrow\ 1\ \rightarrow\ \dots $ という移動を繰り返す以外の選択肢はありません。 このとき、$ 10^{10^{100}} $ 回の移動をした時点で頂点 $ 2 $ にいるので、答えは `No` です。

## 样例 #1

### 输入

```
4
2 2
1 2
2 1
3 3
1 2
2 3
3 1
7 10
1 6
6 3
1 4
5 1
7 1
4 5
2 1
4 7
2 7
4 3
7 11
1 6
6 3
1 4
5 1
7 1
4 5
2 1
4 7
2 7
4 3
3 7```

### 输出

```
Yes
No
No
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC306G] Return to 1 深入学习指南 💡


## 📝 1. 题目解读与核心算法识别  
### ✨ 本题主要考察  
**图论（强连通分量、DFS生成树）+ 数论（裴蜀定理）**  

### 🗣️ 初步分析  
想象你在一个迷宫里，从起点1出发，要走**超级超级远**（10^(10^100)步）后回到起点。这么大的步数不可能直接模拟，得用**数学技巧**：  
- 关键观察：10^(10^100)的质因子只有**2和5**（比如10=2×5，100=2²×5²，以此类推）。  
- 问题转化：只要所有**包含1的环**的长度的**最大公约数（gcd）** 只有2和5这两个质因子，就能通过反复走这些环凑出目标步数（根据**裴蜀定理**，足够大的数一定能被gcd组合出来）。  

#### 核心算法流程  
1. **保留有效节点**：只保留能从1出发到达，且能回到1的节点（即1所在的**强连通分量SCC**）。  
2. **建DFS生成树**：从1出发做DFS，记录每个节点的**深度dep[u]**（表示从1到u的路径长度）。  
3. **计算环长gcd**：遍历所有边u→v，若u和v都在有效节点中，计算`abs(dep[u]+1 - dep[v])`（这个值对应某条环的长度），并将所有这些值取gcd。  
4. **判断质因子**：检查gcd是否只有2和5，若是则输出"Yes"，否则"No"。  

#### 可视化设计思路  
用**8位像素风**模拟迷宫探索：  
- **场景**：像素化的迷宫，节点是小方块，边是箭头。  
- **DFS过程**：从1号节点（红色方块）出发，逐步探索相邻节点，每访问一个节点就标记其深度（比如深度1是蓝色，深度2是绿色）。  
- **非树边处理**：当遇到一条边u→v（不是DFS树的边），用**黄色高亮**显示，同时计算`dep[u]+1 - dep[v]`，并在屏幕角落更新gcd值。  
- **音效**：DFS访问节点时播放“叮”的音效，计算gcd时播放“滴”的音效，最终判断为"Yes"时播放胜利音效。  


## 🌟 2. 精选优质题解参考  
### 📌 题解一（作者：六楼溜刘，赞：12）  
**点评**：  
这份题解思路**逻辑严密**，从裴蜀定理的应用到DFS生成树的构建，每一步都解释得很清楚。代码结构**规范**，用正图（`e`）和反图（`re`）分别处理“从1出发”和“能回到1”的节点，确保保留的是有效SCC。计算gcd时，遍历所有非树边（`nt`数组），效率高。**亮点**：通过`ret`数组标记能回到1的节点，避免无效计算。  

### 📌 题解二（作者：SoyTony，赞：6）  
**点评**：  
代码**简洁高效**，直接用正图和反图的DFS计算`dep`值，然后遍历所有边计算gcd。没有多余的数组，逻辑清晰。**亮点**：用`vis1`（从1出发可达）和`vis2`（能回到1）标记有效节点，判断条件简单明了。  

### 📌 题解三（作者：xrk2006，赞：6）  
**点评**：  
详细证明了“非树边的dep差的gcd等于环长gcd”的结论，逻辑**严谨**。代码实现**正确**，用`ok`数组标记有效节点，`dep`数组记录深度，计算gcd的过程清晰。**亮点**：通过`dfs2`递归计算dep，确保生成树的正确性。  


## ⚡ 3. 核心难点辨析与解题策略  
### 1. **难点1：如何处理极大步数？**  
- **分析**：10^(10^100)太大，无法直接模拟。需要用裴蜀定理转化问题——只要环长的gcd能整除目标步数，就能凑出。  
- **策略**：目标步数的质因子只有2和5，因此只需判断gcd的质因子是否只有这两个。  

### 2. **难点2：如何高效计算环长的gcd？**  
- **分析**：直接找所有环长会超时（环可能无限多）。  
- **策略**：利用DFS生成树的`dep`值，非树边u→v对应的环长是`dep[u]+1 - dep[v]`（比如u在深度2，v在深度1，那么环长是2+1-1=2）。所有这些值的gcd等于所有环长的gcd。  

### 3. **难点3：如何保留有效节点？**  
- **分析**：只有能从1出发且能回到1的节点才可能形成环。  
- **策略**：用正图（`e`）DFS标记从1出发可达的节点（`vis1`），用反图（`re`）DFS标记能回到1的节点（`vis2`），有效节点是`vis1`和`vis2`都为真的节点。  

### ✨ 解题技巧总结  
- **问题转化**：将极大步数问题转化为质因子判断，利用裴蜀定理简化。  
- **图简化**：保留有效SCC，减少计算量。  
- **DFS生成树**：用深度信息快速计算环长的gcd。  


## 🖥️ 4. C++核心代码实现赏析  
### 📌 本题通用核心C++实现参考  
**说明**：综合六楼溜刘和SoyTony的题解，保留核心逻辑，结构清晰。  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 2e5 + 5;
vector<int> e[N], re[N]; // 正图、反图
bool vis1[N], vis2[N];   // vis1: 从1出发可达；vis2: 能回到1
int dep[N];              // 节点深度
int g;                   // 环长的gcd

void dfs1(int u) { // 正图DFS，标记从1出发可达的节点
    vis1[u] = true;
    for (int v : e[u]) {
        if (!vis1[v]) {
            dep[v] = dep[u] + 1;
            dfs1(v);
        }
    }
}

void dfs2(int u) { // 反图DFS，标记能回到1的节点
    vis2[u] = true;
    for (int v : re[u]) {
        if (!vis2[v]) {
            dfs2(v);
        }
    }
}

int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        // 初始化
        for (int i = 1; i <= n; i++) {
            e[i].clear();
            re[i].clear();
            vis1[i] = vis2[i] = false;
            dep[i] = 0;
        }
        g = 0;
        // 读入边
        for (int i = 0; i < m; i++) {
            int u, v;
            cin >> u >> v;
            e[u].push_back(v);
            re[v].push_back(u);
        }
        // 计算有效节点
        dfs1(1);
        dfs2(1);
        // 计算gcd
        for (int u = 1; u <= n; u++) {
            if (!vis1[u] || !vis2[u]) continue;
            for (int v : e[u]) {
                if (!vis1[v] || !vis2[v]) continue;
                int diff = abs(dep[u] + 1 - dep[v]);
                if (g == 0) g = diff;
                else g = gcd(g, diff);
            }
        }
        // 判断质因子
        if (g == 0) {
            cout << "No\n";
            continue;
        }
        while (g % 2 == 0) g /= 2;
        while (g % 5 == 0) g /= 5;
        cout << (g == 1 ? "Yes" : "No") << "\n";
    }
    return 0;
}
```  
**代码解读概要**：  
1. **输入处理**：读入多组测试用例，初始化图结构。  
2. **有效节点计算**：用`dfs1`（正图）和`dfs2`（反图）标记能从1出发且能回到1的节点。  
3. **gcd计算**：遍历所有边，计算非树边的`dep`差，取gcd。  
4. **质因子判断**：检查gcd是否只有2和5，输出结果。  

### 📌 题解一（六楼溜刘）核心片段赏析  
**亮点**：用`nt`数组存储非树边，避免重复计算。  
```cpp
vector<int> nt[N]; // 非树边
void dfs(int x) { // 建外向树
    vis[x] = 1;
    for (auto i : e[x]) {
        if (vis[i]) {
            nt[x].push_back(i); // 非树边
            continue;
        }
        dpt[i] = dpt[x] + 1;
        dfs(i);
    }
}
```  
**代码解读**：  
- `nt`数组存储非树边（即DFS时已经访问过的节点）。  
- 遍历非树边时，计算`dpt[u]+1 - dpt[v]`的绝对值，取gcd。  
**学习笔记**：非树边是计算环长的关键，单独存储可以提高效率。  


## 🎮 5. 算法可视化：像素动画演示  
### 📌 动画主题  
**《像素迷宫探险：回到起点》**（类似FC游戏《炸弹人》的风格）  

### 📌 核心演示内容  
1. **场景初始化**：  
   - 屏幕显示8位像素风格的迷宫，节点是16×16的方块，1号节点是红色（起点），其他节点是灰色。  
   - 底部有控制面板：“开始”“单步”“自动”“重置”按钮，以及速度滑块。  
   - 背景播放8位风格的轻快BGM（如《超级马里奥》的背景音乐）。  

2. **DFS生成树构建**：  
   - 从1号节点出发，逐步探索相邻节点，每访问一个节点，其颜色变为蓝色（深度1）、绿色（深度2）、黄色（深度3）等，同时在节点下方显示深度值（如“dep:2”）。  
   - 访问节点时播放“叮”的音效（类似《吃豆人》的吃豆声）。  

3. **非树边处理**：  
   - 当遇到一条非树边u→v（比如u是深度2的绿色节点，v是深度1的蓝色节点），用**黄色高亮**显示这条边，同时在屏幕右侧弹出提示框：“发现环！长度：2+1-1=2”。  
   - 计算`dep[u]+1 - dep[v]`的值，并更新屏幕角落的gcd值（如“gcd:2”），播放“滴”的音效。  

4. **结果判断**：  
   - 当所有边处理完毕，若gcd的质因子只有2和5，屏幕显示“胜利！”（类似《魂斗罗》的通关画面），播放胜利音效（上扬的“叮~”）；否则显示“失败！”，播放失败音效（短促的“ buzz”）。  

### 📌 交互设计  
- **单步执行**：点击“单步”按钮，逐步执行DFS和非树边处理，每步显示当前操作。  
- **自动播放**：点击“自动”按钮，算法自动执行，速度可通过滑块调整（从“慢”到“快”）。  
- **重置**：点击“重置”按钮，恢复初始状态，重新开始演示。  


## 🚀 6. 拓展练习与相似问题思考  
### 📌 通用思路迁移  
- **问题场景**：需要判断是否能通过反复走环凑出极大步数的问题，都可以用“环长gcd+质因子判断”的思路解决。  
- **示例**：  
  1. 迷宫问题：从起点出发，走N步回到起点（N极大）。  
  2. 字符串问题：判断是否存在循环节，使得重复多次后得到目标字符串。  
  3. 电路问题：判断电流是否能在极大时间后回到原点。  

### 📌 洛谷练习推荐  
1. **P3387 【模板】强连通分量**  
   - **推荐理由**：巩固强连通分量的处理，学会用Tarjan或Kosaraju算法找SCC。  
2. **P1113 杂务**  
   - **推荐理由**：练习DFS生成树的构建，理解深度的含义。  
3. **P2661 信息传递**  
   - **推荐理由**：类似的环问题，需要计算最小环长，锻炼环长处理能力。  


## 📝 7. 学习心得与经验分享  
### 📌 作者经验摘录（来自六楼溜刘）  
> “我一开始没处理SCC，导致包含了无效节点，结果gcd计算错误。后来用正图和反图的DFS保留有效节点，问题就解决了。”  

**点评**：  
处理SCC是本题的关键！如果保留了不能回到1的节点，会导致计算的gcd包含无效环长，从而判断错误。**教训**：在图论问题中，一定要先简化图，保留有效节点。  

### 📌 调试技巧  
- **打印中间值**：调试时可以打印`dep`数组的值，确保DFS生成树的深度正确。  
- **验证gcd**：对于样例输入，手动计算环长的gcd，与代码输出对比，确保正确性。  


## 🔚 结语  
本次分析让我们学会了用**图论+数论**解决极大步数问题。关键是将问题转化为**环长gcd的质因子判断**，通过DFS生成树快速计算gcd。希望大家能举一反三，解决更多类似问题！💪  

下次我们再一起探索新的编程挑战！😊

---
处理用时：226.26秒
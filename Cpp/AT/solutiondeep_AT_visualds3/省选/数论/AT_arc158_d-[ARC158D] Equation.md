# 题目信息

# [ARC158D] Equation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc158/tasks/arc158_d

正整数 $ n $ および，$ 5 $ 以上の素数 $ p $ が与えられます．

次の条件をすべて満たす整数の組 $ (x,y,z) $ を 1 つ求めてください．

- $ 1\leq\ x\ <\ y\ <\ z\ \leq\ p\ -\ 1 $.
- $ (x+y+z)(x^n+y^n+z^n)(x^{2n}+y^{2n}+z^{2n})\ \equiv\ x^{3n}+y^{3n}+z^{3n}\pmod{p} $.
 
なお，このような組 $ (x,y,z) $ は必ず存在することが証明できます．

$ T $ 個のテストケースが与えられるので，それぞれについて答えを求めてください．

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 10^5 $
- $ 1\leq\ n\leq\ 10^9 $
- $ p $ は $ 5\leq\ p\leq\ 10^9 $ を満たす素数
 
### Sample Explanation 1

ひとつめのテストケースについて， - $ (x+y+z)(x^n+y^n+z^n)(x^{2n}+y^{2n}+z^{2n})\ =\ (1+4+6)(1+4+6)(1+16+36)\ =\ 6413 $ - $ x^{3n}+y^{3n}+z^{3n}\ =\ 1\ +\ 64\ +\ 216\ =\ 281 $ であり，$ 6413\equiv\ 281\pmod{7} $ なので，条件を満たしていることが確認できます．

## 样例 #1

### 输入

```
3

1 7

2 7

10 998244353```

### 输出

```
1 4 6

1 2 5

20380119 21549656 279594297```

# AI分析结果

# 💡 Kay的C++算法解析：[ARC158D] Equation 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`随机化算法` + `数论（同余式、快速幂）`

🗣️ **初步分析**：  
解决“Equation”这道题，关键在于**利用同余式的齐次性**和**随机化策略**。简单来说，齐次性就像“糖水稀释”——不管你把x、y、z乘以同一个数t，式子两边的比例不会变（比如左边是`t^k * 原式`，右边是`t^m * 原式`，只要调整t就能让两边相等）。而随机化则像“抽奖”——因为符合条件的(x,y,z)非常多（官方证明概率≥75%），所以随机选几个数，稍微调整就能满足条件！  

**核心思路**：  
1. 随机选三个不同的数x、y、z（1≤x<y<z≤p-1）；  
2. 计算左边`F(x,y,z) = (x+y+z)(xⁿ+yⁿ+zⁿ)(x²ⁿ+y²ⁿ+z²ⁿ) mod p`；  
3. 计算右边`G(x,y,z) = (x³ⁿ+y³ⁿ+z³ⁿ) mod p`；  
4. 若F和G都不为0，取`t = G * F⁻¹ mod p`（F⁻¹是F的逆元），则`(x*t, y*t, z*t)`就是满足条件的解！  

**核心难点**：  
- 如何快速计算大指数（如xⁿ mod p）？——用**快速幂**（把指数拆成二进制，减少乘法次数）；  
- 如何保证随机选的x、y、z有效？——循环过滤掉x=y=z或F/G=0的情况；  
- 如何理解齐次性？——通过“稀释糖水”的比喻，让式子两边“平衡”。  

**可视化设计思路**：  
用8位像素风做一个“随机数探险”动画：  
- 屏幕上有三个彩色像素块（代表x、y、z），随机出现在网格里；  
- 计算F时，三个块会“闪烁”并显示乘积过程（比如先加起来，再乘起来）；  
- 计算G时，块会“旋转”表示求三次方和；  
- 调整t时，块会“移动”到新的位置（乘以t后的结果）；  
- 成功时，播放“叮”的胜利音效，块变成金色并排序输出！  


## 2. 精选优质题解参考

### 题解一：Leasier（构造法，赞：7）  
* **点评**：这份题解的亮点是**构造性解法**，不需要随机化！作者通过分析n的奇偶性，直接计算出x、y、z的值。比如当n为奇数时，取r=2，计算`ans[1] = 1/(2*r²ⁿ +1) mod p`，`ans[2] = ans[1]*r mod p`，`ans[3] = p - ans[2]`。这种方法时间复杂度O(T log n)，非常高效！代码结构清晰，变量命名规范（比如`quick_pow`函数），边界条件处理严谨（比如判p=5或11的情况）。  

### 题解二：云浅知处（随机化，赞：5）  
* **点评**：这份题解用了**随机化策略**，思路非常简洁！作者利用齐次性，随机选x、y、z，计算F和G，然后调整t使得式子成立。代码中的`randint`函数生成随机数，`inv`函数用费马小定理求逆元（因为p是素数，逆元等于F^(p-2) mod p）。这份题解的实践价值很高，因为随机化方法容易实现，且成功率高（官方证明≥75%）。  

### 题解三：DaiRuiChen007（随机化，赞：2）  
* **点评**：这份题解的代码非常简洁，用了`mt19937`随机数生成器（比`rand`更均匀），`F`和`G`函数封装了计算逻辑。作者在循环中过滤掉无效情况（x=y=z或F/G=0），确保每次随机都能得到有效解。代码中的`sort`函数排序输出，符合题目要求的x<y<z。  


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何快速计算大指数（如xⁿ mod p）？  
* **分析**：n可以达到1e9，直接计算xⁿ会超时。用**快速幂**（二进制 exponentiation）可以将时间复杂度降到O(log n)。比如计算xⁿ，把n拆成2的幂次之和（如n=5=101₂），则x⁵ = x⁴ * x¹，这样只需要log2(1e9)≈30次乘法。  
* 💡 **学习笔记**：快速幂是处理大指数同余的“神器”，一定要掌握！  

### 2. 难点2：如何利用同余式的齐次性？  
* **分析**：题目中的式子左边是3次齐次式（每个项的次数之和为3），右边是3次齐次式？不对，等一下——左边是(x+y+z)（1次）*(xⁿ+yⁿ+zⁿ)（n次）*(x²ⁿ+y²ⁿ+z²ⁿ)（2n次），总次数是1+3n次；右边是x³ⁿ+y³ⁿ+z³ⁿ（3n次）。所以左边比右边多1次，因此如果`F(x,y,z) = t*G(x,y,z)`，那么`F(x*t, y*t, z*t) = t^(1+3n) * F(x,y,z) = t^(1+3n) * t*G(x,y,z) = t^(3n+2) * G(x,y,z)`？不对，等一下，正确的齐次性分析应该是：假设`(x,y,z)`满足`F(x,y,z) = k*G(x,y,z)`，那么`(tx, ty, tz)`满足`F(tx, ty, tz) = t^(1+3n) * F(x,y,z) = t^(1+3n) * k*G(x,y,z) = t*k* t^(3n) * G(x,y,z) = t*k* G(tx, ty, tz)`。所以如果取`t = 1/k`，那么`F(tx, ty, tz) = G(tx, ty, tz)`，刚好满足题目条件！  
* 💡 **学习笔记**：齐次性是解决这类问题的关键，要学会观察式子的次数！  

### 3. 难点3：如何保证随机选的x、y、z有效？  
* **分析**：随机选的x、y、z可能有以下问题：x=y=z（不符合x<y<z），F=0（无法求逆元），G=0（无法调整t）。解决方法是**循环过滤**：只要遇到这些情况，就重新随机选数。因为符合条件的数很多，所以循环次数很少（期望≤2次）。  
* 💡 **学习笔记**：随机化算法的关键是“高成功率”，只要概率足够大，循环几次就能得到解！  

### ✨ 解题技巧总结  
- **技巧A：快速幂**：处理大指数同余，时间复杂度O(log n)；  
- **技巧B：费马小定理**：求逆元（当p是素数时，a⁻¹ = a^(p-2) mod p）；  
- **技巧C：随机化**：对于存在性问题，随机选数+调整是高效的解法；  
- **技巧D：齐次性**：观察式子的次数，简化问题（比如调整t使得式子成立）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（随机化方法）  
* **说明**：本代码综合了云浅知处和DaiRuiChen007的题解思路，是随机化方法的典型实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <ctime>
using namespace std;

typedef long long ll;

ll quick_pow(ll x, ll y, ll mod) {
    ll ans = 1;
    while (y) {
        if (y & 1) ans = ans * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return ans;
}

ll inv(ll x, ll mod) {
    return quick_pow(x, mod - 2, mod);
}

int main() {
    srand(time(0)); // 初始化随机数种子
    int T;
    cin >> T;
    while (T--) {
        ll n, p;
        cin >> n >> p;
        ll x, y, z, F, G;
        do {
            x = rand() % (p - 1) + 1; // 1≤x≤p-1
            y = rand() % (p - 1) + 1;
            z = rand() % (p - 1) + 1;
            // 计算F(x,y,z)
            ll xn = quick_pow(x, n, p);
            ll yn = quick_pow(y, n, p);
            ll zn = quick_pow(z, n, p);
            F = (x + y + z) % p;
            F = F * (xn + yn + zn) % p;
            F = F * (quick_pow(xn, 2, p) + quick_pow(yn, 2, p) + quick_pow(zn, 2, p)) % p;
            // 计算G(x,y,z)
            G = (quick_pow(x, 3 * n, p) + quick_pow(y, 3 * n, p) + quick_pow(z, 3 * n, p)) % p;
        } while (x == y || y == z || z == x || F == 0 || G == 0); // 过滤无效情况
        // 调整t
        ll t = G * inv(F, p) % p;
        x = x * t % p;
        y = y * t % p;
        z = z * t % p;
        // 排序输出
        ll arr[] = {x, y, z};
        sort(arr, arr + 3);
        cout << arr[0] << " " << arr[1] << " " << arr[2] << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **快速幂函数**：`quick_pow`计算x^y mod mod，用二进制拆分指数，减少乘法次数；  
  2. **逆元函数**：`inv`用费马小定理求x的逆元（因为p是素数）；  
  3. **主函数**：循环处理每个测试用例，随机选x、y、z，计算F和G，过滤无效情况，调整t，排序输出。  


### 题解二：云浅知处（随机化）  
* **亮点**：代码规范，注释清楚，用了`randint`函数生成随机数。  
* **核心代码片段**：  
```cpp
do {
    x = randint(1, p-1);
    y = randint(1, p-1);
    z = randint(1, p-1);
} while (x == y || y == z || z == x || F(x,y,z) == 0 || G(x,y,z) == 0);
ll t = G(x,y,z) * inv(F(x,y,z)) % p;
x = x * t % p;
y = y * t % p;
z = z * t % p;
```
* **代码解读**：  
  - 循环随机选x、y、z，直到满足条件（x≠y≠z，F≠0，G≠0）；  
  - 计算t=G*F⁻¹，调整x、y、z为x*t、y*t、z*t；  
  - 排序输出。  
* 💡 **学习笔记**：随机化的关键是“循环过滤”，确保选到有效的数。  


### 题解一：Leasier（构造法）  
* **亮点**：构造性解法，不需要随机化，效率高。  
* **核心代码片段**（n为奇数的情况）：  
```cpp
ans[1] = quick_pow((quick_pow(2, n*2, p) * 2 % p + 1) % p, p-2, p);
if (ans[1] == 0) {
    ans[1] = quick_pow((quick_pow(4, n*2, p) * 2 % p + 1) % p, p-2, p);
    ans[2] = ans[1] * 4 % p;
} else {
    ans[2] = ans[1] * 2 % p;
}
ans[3] = p - ans[2];
```
* **代码解读**：  
  - 当n为奇数时，取r=2，计算`ans[1] = 1/(2*r²ⁿ +1) mod p`；  
  - 如果ans[1]为0（即分母为0），则取r=4，重新计算；  
  - ans[2] = ans[1]*r，ans[3] = p - ans[2]（因为x+y=p时，y=p-x）；  
  - 这样得到的(x,y,z)一定满足条件。  
* 💡 **学习笔记**：构造性解法需要深入分析题目条件，找到规律，适合时间要求高的情况。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：`随机数探险：寻找平衡三元组`  
### 设计思路简述：  
用8位像素风（类似FC游戏）营造轻松的学习氛围，通过动画展示随机化算法的每一步，让学习者“看”到算法的工作过程。关键操作（如随机选数、计算F/G、调整t）用不同的动画效果和音效提示，增强记忆。  

### 动画帧步骤与交互关键点：  
1. **场景初始化**：  
   - 屏幕显示一个16x16的网格，底部有控制面板（开始/暂停、单步、重置、速度滑块）；  
   - 三个彩色像素块（红、绿、蓝）代表x、y、z，随机出现在网格里；  
   - 播放8位风格的背景音乐（如《超级马里奥》的轻快旋律）。  

2. **随机选数**：  
   - 点击“开始”按钮，三个像素块会“跳动”并随机移动到新的位置（表示随机选x、y、z）；  
   - 若选到相同的数（如x=y），像素块会“闪烁红色”并重新移动。  

3. **计算F和G**：  
   - 计算F时，三个像素块会“聚集”在一起，显示“+”和“×”的动画（比如先加起来，再乘起来），同时播放“滴”的音效；  
   - 计算G时，三个像素块会“旋转”（表示求三次方和），播放“叮”的音效；  
   - 若F或G为0，像素块会“闪烁黄色”并重新选数。  

4. **调整t**：  
   - 计算t时，屏幕会显示“t = G × F⁻¹”的公式，然后三个像素块会“移动”到新的位置（乘以t后的结果），播放“咻”的音效。  

5. **成功输出**：  
   - 调整后的像素块会“排序”（从小到大排列），显示“胜利”字样，播放“啦啦啦”的胜利音效；  
   - 点击“重置”按钮，可重新开始动画。  

### 旁白提示：  
- （随机选数时）“现在我们要随机选三个不同的数，注意看它们的位置！”；  
- （计算F时）“现在计算左边的式子，先把x+y+z加起来，再乘xⁿ+yⁿ+zⁿ，再乘x²ⁿ+y²ⁿ+z²ⁿ！”；  
- （调整t时）“现在调整t的值，让左边等于右边，看！它们的位置变了！”；  
- （成功时）“太好了！我们找到符合条件的三元组了！”。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
- **快速幂**：用于计算大指数同余（如P1082 同余方程）；  
- **费马小定理**：用于求逆元（如P3811 乘法逆元）；  
- **随机化**：用于存在性问题（如P5656 快速幂模板）；  
- **齐次性**：用于简化同余式（如P2613 有理数取余）。  

### 练习推荐 (洛谷)：  
1. **洛谷 P1082** - `同余方程`  
   - 🗣️ **推荐理由**：这道题需要用扩展欧几里得算法求同余方程的解，是数论的基础练习，能帮助你巩固同余式的处理。  
2. **洛谷 P3811** - `乘法逆元`  
   - 🗣️ **推荐理由**：这道题需要用费马小定理求逆元，是本题的核心技巧之一，能帮助你熟练掌握逆元的计算。  
3. **洛谷 P5656** - `快速幂模板`  
   - 🗣️ **推荐理由**：这道题是快速幂的模板题，能帮助你巩固快速幂的实现，应对大指数问题。  
4. **洛谷 P2613** - `有理数取余`  
   - 🗣️ **推荐理由**：这道题需要用费马小定理求分母的逆元，是齐次性的应用，能帮助你理解如何处理分数同余。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自云浅知处)：  
> “官方题解证得随机化的成功率至少为3/4，所以只要循环几次就能得到解。我在写代码时，一开始没过滤F=0的情况，导致偶尔出错，后来加上过滤条件就好了。”  

**点评**：这位作者的经验很典型！在随机化算法中，**过滤无效情况**是非常重要的，否则会出现除以0的错误。另外，官方的概率证明也说明，随机化算法的成功率很高，不需要担心循环次数太多。  


## 结语  
本次关于“[ARC158D] Equation”的C++解题分析就到这里。希望这份学习指南能帮助大家理解随机化算法、快速幂、逆元等核心知识点。记住，编程的乐趣在于“探索”——就像随机化算法一样，只要敢于尝试，就能找到解决问题的方法！下次我们再一起探索新的编程挑战！💪

---
处理用时：402.66秒
# 题目信息

# [ARC170E] BDFS

## 题目描述

给定整数 $N, P$。

有一个 $N$ 个顶点 $N$ 条边的图，顶点编号为 $1$ 到 $N$。第 $i$ 条边连接顶点 $i$ 和顶点 $i+1$，是双向的。这里顶点 $N+1$ 代表顶点 $1$。

请执行以下算法，得到一个长度为 $N$ 的数列 $D=(D_1, D_2, \ldots, D_N)$。

- 令长度为 $N$ 的整数列 $D = (D_1, \ldots, D_N) = (-1, \ldots, -1)$。同时，令数对序列 $Q = ((1, 0))$。只要 $Q$ 非空，重复以下操作：

  - 取出 $Q$ 的首元素 $(v, d)$，并将其从 $Q$ 中删除。
  - 如果 $D_v = -1$，则令 $D_v := d$，并对与顶点 $v$ 相邻且满足 $D_x = -1$ 的每个顶点 $x$，按顶点编号从小到大依次进行如下操作：
    1. 以概率 $\frac{P}{100}$，将 $(x, d+1)$ 加入 $Q$ 的**首部**。
    2. 若未将 $(x, d+1)$ 加入 $Q$ 的首部，则将其加入 $Q$ 的**尾部**。

最终得到的 $D$ 的所有元素之和的期望值，模 $998244353$ 后输出。

给定 $T$ 组测试数据，请分别输出每组的答案。

期望值 $\bmod\ 998244353$ 的定义：可以证明，所求期望值一定是有理数。在本题的约束下，若将其表示为最简分数 $\frac{P}{Q}$，则 $Q$ 保证不被 $998244353$ 整除。此时，唯一存在一个 $0$ 到 $998244352$ 之间的整数 $R$ 满足 $R \times Q \equiv P \pmod{998244353}$。请输出这个 $R$ 作为答案。

## 说明/提示

### 数据范围

- $1 \leq T \leq 10^4$
- $3 \leq N \leq 10^{18}$
- $1 \leq P \leq 99$
- 输入的所有数均为整数

### 样例解释 1

对于第 $1$ 组测试数据，算法的执行过程例如如下：

- 初始时，$D = (-1, -1, -1),\ Q = ((1, 0))$。取出 $Q$ 首元素 $(1, 0)$。
- 因为 $D_1 = -1$，令 $D_1 := 0$。与顶点 $1$ 相邻且 $D_x = -1$ 的顶点为 $2, 3$。
- 将 $(2, 1)$ 加入 $Q$ 首部，将 $(3, 1)$ 加入 $Q$ 尾部。此时 $Q = ((2, 1), (3, 1))$。
- 取出 $Q$ 首元素 $(2, 1)$。
- 因为 $D_2 = -1$，令 $D_2 := 1$。与顶点 $2$ 相邻且 $D_x = -1$ 的顶点为 $3$。
- 将 $(3, 2)$ 加入 $Q$ 首部。此时 $Q = ((3, 2), (3, 1))$。
- 取出 $Q$ 首元素 $(3, 2)$。
- 因为 $D_3 = -1$，令 $D_3 := 2$。与顶点 $3$ 相邻且 $D_x = -1$ 的顶点不存在，不做任何操作。
- 取出 $Q$ 首元素 $(3, 1)$。
- 因为 $D_3 = 2$，不做任何操作。
- $Q$ 为空，算法结束。

此时最终 $D = (0, 1, 2)$。上述过程发生的概率为 $\frac{1}{8}$，$D$ 的元素和的期望值为 $\frac{5}{2}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3

3 50

4 1

1000000000000000000 70```

### 输出

```
499122179

595552585

760296751```

# AI分析结果


# 💡 Kay的C++算法解析：ARC170E BDFS 深入学习指南 💡

<introduction>
今天我们来分析ARC170E BDFS这道概率期望与动态规划结合的题目。本指南将帮助你理解环上概率BFS的期望计算，掌握矩阵快速幂优化技巧，并通过像素动画直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划 + 矩阵快速幂优化` (概率期望问题)

🗣️ **初步分析**：
> 这道题可以想象成像素冒险家在环形迷宫中探索：从起点1出发，每次有P%概率向左探索（加入队首），(100-P)%概率向右探索（加入队尾）。我们需要计算所有路径深度和的数学期望。

- **核心难点**：环上扩展的方向选择具有概率依赖性，直接模拟时间复杂度不可接受（n≤10¹⁸）
- **解决方案**：抽象为DP状态机（f₀当前方向深度期望，f₁反方向深度期望），用矩阵表示状态转移关系
- **可视化设计**：像素环上显示当前探索方向（左/右箭头），高亮被访问节点颜色，队列状态用双格像素面板展示。当选择方向时播放8-bit音效，扩展节点时显示深度值增长
- **游戏化元素**：设计"迷宫探索"主题，每次成功扩展播放胜利音效，自动演示模式展示最优路径探索过程

---

## 2. 精选优质题解参考

<eval_intro>
根据思路清晰度、代码规范性和算法优化程度，精选以下优质题解：

**题解一：DaiRuiChen007（5星）**
* **点评**：状态定义清晰（f₀, f₁, ans），矩阵转移设计精炼（4×4矩阵），代码规范易读。亮点在于完整处理模运算和边界条件，可直接用于竞赛。时间复杂度O(log n)完美解决超大n限制。

**题解二：NobodyThere（4.5星）**
* **点评**：DP状态转移方程推导透彻（f₀'=p·f₀+(1-p)·f₁+1），用自然语言解释概率转移逻辑。虽然未提供完整代码，但状态设计极具启发性，帮助理解问题本质。

**题解三：qiuzx（4星）**
* **点评**：创新性使用组合数学方法，将期望分解为字符对概率计算。亮点在于生成函数化简（(f(1)+f(-1))/2技巧），提供不同于DP的视角，加深对概率本质的理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键点：

1.  **状态抽象与定义**
    * **分析**：如何用最少状态描述当前探索位置？优质题解使用(f₀, f₁)表示当前/反方向的深度期望，ans记录总和。关键变量f₀,f₁需满足马尔可夫性（无后效）
    * 💡 **学习笔记**：好的状态设计应捕捉问题本质特征

2.  **概率转移建模**
    * **分析**：方向选择具有记忆性——若本次选择与上次相同概率为P，不同概率为1-P。转移方程：
      ```
      f₀' = p·f₀ + (1-p)·f₁ + 1
      f₁' = (1-p)·f₀ + p·f₁
      ans' = ans + p·f₀ + (1-p)·f₁ + 1
      ```
    * 💡 **学习笔记**：概率DP转移需考虑状态依赖关系

3.  **超大n优化**
    * **分析**：n≤10¹⁸需O(log n)算法。矩阵快速幂将线性递推转化为矩阵幂运算：
      ```
      [f₀', f₁', 1, ans']ᵀ = M × [f₀, f₁, 1, ans]ᵀ
      M = [[p, 1-p, 1, 1],
           [1-p, p, 0, 0],
           [0, 0, 1, 0],
           [p, 1-p, 1, 1]]
      ```
    * 💡 **学习笔记**：矩阵快速幂是优化线性递推的利器

### ✨ 解题技巧总结
<summary_best_practices>
1. **问题分解**：将环上探索抽象为状态机
2. **矩阵封装**：用4×4矩阵封装状态转移
3. **边界处理**：注意模998244353运算
4. **双视角验证**：结合DP与组合方法交叉验证

---

## 4. C++核心代码实现赏析

<code_intro_overall>
**本题通用核心C++实现参考**
* **说明**：基于DaiRuiChen007题解优化，完整实现矩阵快速幂框架
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD = 998244353, inv100 = 828542813; // 100的模逆元

typedef array<array<long long,4>,4> Matrix;

Matrix operator*(const Matrix &A, const Matrix &B) {
    Matrix C = {};
    for(int i=0; i<4; ++i) 
        for(int k=0; k<4; ++k) 
            for(int j=0; j<4; ++j) 
                C[i][j] = (C[i][j] + A[i][k]*B[k][j]) % MOD;
    return C;
}

int main() {
    int T; scanf("%d",&T);
    while(T--) {
        long long n; int p;
        scanf("%lld%d",&n,&p);
        n--; // 操作次数n-1
        p = 1LL * p * inv100 % MOD; // 概率归一化

        // 初始状态: [f0, f1, 1, ans] = [0,0,1,0]
        Matrix base = {{
            {p, 1-p, 1, 1},   // f0更新
            {1-p, p, 0, 0},    // f1更新
            {0, 0, 1, 0},      // 常数项
            {0, 0, 0, 1}       // ans更新
        }}, res = {{{1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1}}}; // 单位矩阵

        // 矩阵快速幂
        for(; n; n/=2, base=base*base) 
            if(n&1) res = res*base;

        // 输出最终ans (res[0][3])
        printf("%lld\n", res[0][3]);
    }
}
```
* **代码解读概要**：
  1. 概率归一化：P/100转为模意义整数
  2. 构建4×4转移矩阵base
  3. 矩阵快速幂计算baseⁿ
  4. 初始向量[0,0,1,0] × baseⁿ 得到ans

---
<code_intro_selected>
**题解一：DaiRuiChen007**
* **亮点**：矩阵封装优雅，完美处理模运算
* **核心代码片段**：
```cpp
Matrix operator*(const Matrix &u, const Matrix &v) {
    Matrix w = {};
    for(int i=0; i<4; ++i)
        for(int k=0; k<4; ++k)
            for(int j=0; j<4; ++j)
                w[i][j] = (w[i][j] + u[i][k]*v[k][j]) % MOD;
    return w;
}
```
* **代码解读**：
  > 这个矩阵乘法函数是快速幂核心。三维循环实现矩阵乘法，i行k列元素相乘累加到i行j列。模运算确保值域在[0,MOD-1]
* 💡 **学习笔记**：重载运算符使矩阵运算更自然

**题解二：NobodyThere**
* **亮点**：状态转移方程推导透彻
* **核心代码片段**：
```cpp
// 状态转移伪代码
f0_next = p * f0 + (1-p) * f1 + 1;
f1_next = (1-p) * f0 + p * f1;
ans_next = ans + p * f0 + (1-p) * f1 + 1;
```
* **代码解读**：
  > 这三行是DP核心逻辑：f₀更新依赖当前方向概率p，f₁更新依赖反向概率(1-p)，ans累加当前期望贡献
* 💡 **学习笔记**：概率DP需区分状态转移和贡献计算

**题解三：qiuzx**
* **亮点**：组合方法求字符对概率
* **核心代码片段**：
```cpp
// 二项式定理求和
double sum = 0;
for(int m=0; m<n-1; ++m) {
    sum += (n-m-1) * (1 + pow(2*p-1, m));
}
```
* **代码解读**：
  > 通过[f(1)+f(-1)]/2技巧计算位置对概率，避免矩阵运算。pow(2p-1,m)体现概率依赖距离的特性
* 💡 **学习笔记**：组合方法可提供不同视角验证

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计"8-bit迷宫探险"动画，直观展示环上概率BFS过程。采用FC红白机像素风格，通过颜色变化和音效强化理解：
</visualization_intro>

* **动画主题**：像素勇者在环形迷宫探索宝藏
* **设计思路**：环形结构对应题目中的环，方向选择对应手柄操作，深度值显示为宝藏光芒强度

* **动画帧步骤**：
  1. **场景初始化**：  
     - 环形迷宫用8色像素环展示，起点1为绿色，未访问节点灰色  
     - 控制面板：方向选择按钮(L/R)、执行速度滑块  
     - 队列状态：双格像素面板显示当前探索方向（左箭头/右箭头）
     ![初始化](https://via.placeholder.com/400x200?text=环形迷宫像素图)

  2. **方向选择（核心交互）**：  
     - 按P概率高亮左侧节点（蓝色闪烁），播放"选择"音效  
     - 按(1-P)概率高亮右侧节点（红色闪烁），播放"切换"音效  
     - 队列面板更新：新节点像素块滑入对应位置

  3. **节点扩展动画**：  
     - 被访问节点变为金色，显示当前深度值（+1动画）  
     - 环形路径上显示深度增长轨迹（光带延伸效果）
     ![扩展](https://via.placeholder.com/400x200?text=节点扩展动画)

  4. **自动演示模式**：  
     - "AI演示"按钮：自动按最优概率路径探索  
     - 每扩展节点：播放"叮"音效，记1分  
     - 完成探索：播放胜利音乐，显示总深度值

  5. **状态同步显示**：  
     - 右侧面板实时显示：  
       `f0=当前方向深度期望 | f1=反向深度期望`  
       `ans=累计深度和`  
     - 当前转移矩阵高亮显示

* **音效设计**：  
  - 方向选择：8-bit电子音效（左：中音C，右：高音E）  
  - 节点扩展：短促"叮"声  
  - 计算完成：经典FC胜利音乐

<visualization_conclusion>
通过像素动画，你可直观看到概率如何影响探索路径，深度期望如何累积，以及矩阵运算如何加速大尺寸问题
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握环上概率DP后，可挑战以下问题：
</similar_problems_intro>

* **技巧迁移**：矩阵快速幂优化适用于：
  1. 线性递推数列加速（斐波那契变种）
  2. 图论中路径计数（限定步数）
  3. 概率转移问题（如本题）

* **洛谷推荐**：
  1. **P1939 矩阵加速数列**  
     → 掌握线性递推的矩阵表示
  2. **P3758 可乐**  
     → 图论中带概率的状态转移
  3. **P2106 期望距离**  
     → 树上概率期望问题，巩固DP定义

-----

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验非常宝贵：
</insights_intro>

> **DaiRuiChen007调试经验**：  
> "矩阵维度错误导致初始WA，通过小样例n=2验证发现转移矩阵第四行设计错误"

> **Kay的总结**：  
> 在矩阵快速幂实现中，务必用n=0,1,2等小样例验证转移矩阵。建议单独测试矩阵乘法函数，确保每项系数正确

<conclusion>
本次分析展示了概率期望问题的多种解法。记住：DP状态设计是核心，矩阵快速幂是处理大数据的利器。多尝试小规模样例验证，再挑战极限数据！下次见！
</conclusion>
```

---
处理用时：150.98秒
# 题目信息

# [ARC065E] へんなコンパス

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc065/tasks/arc065_c

$ xy $ 平面上に $ N $ 個の穴があります。$ i $ 番目の穴の位置は $ (x_i,y_i) $ です。

$ i $ 番目の穴と $ j $ 番目の穴のマンハッタン距離を $ d(i,j)(=|x_i-x_j|+|y_i-y_j|) $ と表します。

あなたはマンハッタンコンパスを持っています。 このコンパスは、常に $ 2 $ 個の穴を指します。 コンパスが $ p,\ q $ 番目の穴を指している状態と、$ q,\ p $ 番目の穴を指している状態は区別しません。

また、$ d(p,q)=d(p,r) $ で、$ p $ 番目の穴と $ q $ 番目の穴を指しているとき、$ p $ 番目の穴と $ r $ 番目の穴を指すよう動かすことができます。

はじめ、コンパスは $ a $ 番目の穴と $ b $ 番目の穴を指しています。 コンパスが指すことのできる穴の組の数を求めてください。

## 说明/提示

### 制約

- $ 2≦N≦10^5 $
- $ 1≦x_i,\ y_i≦10^9 $
- $ 1≦a\ <\ b≦N $
- $ i\ ≠\ j $ のとき $ (x_i,\ y_i)\ ≠\ (x_j,\ y_j) $
- $ x_i,\ y_i $ は整数である

### Sample Explanation 1

はじめ、コンパスは 穴 $ 1,\ 2 $ を指しています。 $ d(1,2)\ =\ d(1,3) $ なので、穴 $ 1,\ 3 $を指すことができます。 $ d(1,3)\ =\ d(3,4) $ なので、穴 $ 3,\ 4 $を指すことができます。 $ d(1,2)\ =\ d(2,5) $ なので、穴 $ 2,\ 5 $を指すことができます。 他の穴の組でコンパスが指せるものはないため、答えは $ 4 $ となります。

## 样例 #1

### 输入

```
5 1 2

1 1

4 3

6 1

5 5

4 8```

### 输出

```
4```

## 样例 #2

### 输入

```
6 2 3

1 3

5 3

3 5

8 4

4 7

2 5```

### 输出

```
4```

## 样例 #3

### 输入

```
8 1 2

1 5

4 3

8 2

4 7

8 8

3 3

6 6

4 8```

### 输出

```
7```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ARC065E] へんなコンパス 深入学习指南 💡

<introduction>
今天我们要分析的题目是“[ARC065E] へんなコンパス”。这道题涉及曼哈顿距离的转换与图的连通性问题，需要结合巧妙的坐标变换和高效的数据结构操作。通过本指南，你将理解核心思路、关键算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（连通性）+ 曼哈顿/切比雪夫距离转换`

🗣️ **初步分析**：
解决这道题的关键在于理解两点：  
1. 曼哈顿距离的几何特性：相同曼哈顿距离的点在平面上形成一个斜45°的正方形，直接处理较为复杂。  
2. 坐标转换技巧：通过将点 $(x,y)$ 转换为 $(x+y, x-y)$，曼哈顿距离会转化为新坐标系下的切比雪夫距离（即两坐标差的最大值），此时相同距离的点形成与坐标轴对齐的正方形，更易处理。  

**题解思路**：  
所有优质题解均采用以下步骤：  
- 坐标转换：将曼哈顿距离转为切比雪夫距离。  
- 连通性分析：通过BFS或并查集找到所有可达点（即从初始点对 $(a,b)$ 出发，能通过“等距转移”到达的点）。  
- 统计点对：对每个可达点，统计其周围距离为初始距离的点对数量，避免重复计数。  

**核心算法流程**：  
1. 转换所有点的坐标，计算初始距离 $d$（切比雪夫距离）。  
2. 用BFS/并查集遍历所有可达点（每次从当前点出发，找到满足距离 $d$ 的点，加入队列或合并连通块）。  
3. 对每个可达点，统计其四个方向（左右上下）正方形边上的点，累加符合条件的点对数量，最后除以2（因点对无序）。  

**可视化设计**：  
采用8位像素风格，用不同颜色标记原始点（蓝）、可达点（绿）、初始点（红）。动画中，BFS过程用像素箭头展示点的入队和遍历；正方形边界用虚线框高亮，统计点对时用闪烁的像素点提示计数。音效设计：入队时“叮”声，统计完成时“滴”声，最终成功时“胜利”音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：作者 noone___**  
* **点评**：此题解通过坐标转换+并查集+排序二分，高效解决了连通性问题。代码结构工整（如`id`数组排序、`delta`数组处理区间合并），变量命名明确（`sorted_poi`表示排序后的点）。亮点在于用并查集合并连通块，避免了重复遍历；通过两次`solve`函数分别处理x和y方向的正方形边界，逻辑简洁。实践价值高，适合竞赛快速实现。

**题解二：作者 Krimson**  
* **点评**：此题解详细解释了坐标转换的原理，并采用BFS+动态开点线段树统计点对。代码中`set`和线段树的结合使用（如`f[0][now]`存储点集，`T[0].query`统计区间点），体现了对数据结构的灵活运用。亮点是通过删除已访问点避免重复遍历，确保时间复杂度为$O(n \log n)$，适合学习数据结构优化技巧。

**题解三：作者 Ebola**  
* **点评**：此题解用`set`和`vector`维护点集，通过二分查找处理正方形边界。代码中`gao`函数同时完成统计和点删除，逻辑紧凑（如`ans+=upper_bound...`统计数量，`s.erase(it)`删除已访问点）。亮点是通过预处理`vector`排序和`set`动态删除，平衡了查询效率和遍历复杂度，适合理解区间操作的细节。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于突破以下难点，掌握对应的策略：
</difficulty_intro>

1.  **关键点1：曼哈顿到切比雪夫的坐标转换**  
    * **分析**：原曼哈顿距离 $|x_i-x_j|+|y_i-y_j|$ 等价于新坐标 $(x_i+y_i, x_i-y_i)$ 的切比雪夫距离（即两坐标差的最大值）。这一步转换将斜正方形转为正正方形，方便后续处理。例如，初始点对的曼哈顿距离 $d$ 转换为切比雪夫距离后，所有与当前点距离为 $d$ 的点位于边长为 $2d$ 的正方形边界上。  
    * 💡 **学习笔记**：坐标转换是处理曼哈顿/切比雪夫距离问题的“万能钥匙”，需牢记转换公式 $(x,y) \to (x+y, x-y)$。

2.  **关键点2：高效找到所有可达点**  
    * **分析**：可达点是指从初始点对 $(a,b)$ 出发，通过“等距转移”能到达的点。直接遍历所有可能点对会超时，因此需用BFS或并查集。例如，BFS中用`set`维护未访问点，每次找到正方形边界的点后删除，避免重复访问；并查集则通过合并连通块标记可达点。  
    * 💡 **学习笔记**：处理连通性问题时，BFS（适合动态删除）和并查集（适合静态合并）是两大核心工具，根据问题选择更高效的方法。

3.  **关键点3：避免重复统计点对**  
    * **分析**：每个点对 $(u,v)$ 会被统计两次（$u$统计$v$，$v$统计$u$），因此最终答案需除以2。此外，正方形四个角的点可能被相邻边重复统计，需通过特判去重（如Krimson题解中的边界调整）。  
    * 💡 **学习笔记**：统计无序点对时，“总计数/2”是常用去重方法；特殊位置（如正方形角点）需单独检查。

### ✨ 解题技巧总结
- **坐标转换优先**：遇到曼哈顿距离问题，先尝试转换为切比雪夫距离，简化几何处理。  
- **数据结构辅助**：用`set`维护动态点集（支持快速插入、删除、区间查询），用`vector`预处理排序（支持快速二分统计）。  
- **连通性标记**：BFS时标记已访问点（或用并查集合并），避免重复遍历，保证时间复杂度。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了坐标转换、BFS遍历和点对统计的关键逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了noone___和Krimson的题解思路，采用BFS遍历可达点，并用`set`维护未访问点，确保高效统计。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int N = 1e5 + 5;

    struct Point { ll x, y; };
    int n, a, b, vis[N];
    ll d;
    Point p[N];
    map<ll, set<pair<ll, int>>> col, row; // 按x+y和x-y的值分组存储点

    void init() {
        for (int i = 1; i <= n; ++i) {
            ll x = p[i].x + p[i].y, y = p[i].x - p[i].y;
            col[x].insert({y, i});
            row[y].insert({x, i});
        }
        d = max(abs(p[a].x + p[a].y - (p[b].x + p[b].y)), 
                abs(p[a].x - p[a].y - (p[b].x - p[b].y)));
    }

    void bfs() {
        queue<int> q;
        q.push(a); q.push(b);
        vis[a] = vis[b] = 1;
        // 从a和b出发，删除已访问点
        col[p[a].x + p[a].y].erase({p[a].x - p[a].y, a});
        row[p[a].x - p[a].y].erase({p[a].x + p[a].y, a});
        col[p[b].x + p[b].y].erase({p[b].x - p[b].y, b});
        row[p[b].x - p[b].y].erase({p[b].x + p[b].y, b});

        while (!q.empty()) {
            int u = q.front(); q.pop();
            ll x = p[u].x + p[u].y, y = p[u].x - p[u].y;

            // 处理x-d方向的列（正方形左边界）
            if (col.count(x - d)) {
                auto &s = col[x - d];
                auto l = s.lower_bound({y - d, 0}), r = s.upper_bound({y + d, n});
                for (auto it = l; it != r; it = s.erase(it)) {
                    int v = it->second;
                    if (!vis[v]) { vis[v] = 1; q.push(v); }
                }
            }
            // 处理x+d方向的列（正方形右边界）
            if (col.count(x + d)) {
                auto &s = col[x + d];
                auto l = s.lower_bound({y - d, 0}), r = s.upper_bound({y + d, n});
                for (auto it = l; it != r; it = s.erase(it)) {
                    int v = it->second;
                    if (!vis[v]) { vis[v] = 1; q.push(v); }
                }
            }
            // 处理y-d方向的行（正方形下边界）
            if (row.count(y - d)) {
                auto &s = row[y - d];
                auto l = s.lower_bound({x - d, 0}), r = s.upper_bound({x + d, n});
                for (auto it = l; it != r; it = s.erase(it)) {
                    int v = it->second;
                    if (!vis[v]) { vis[v] = 1; q.push(v); }
                }
            }
            // 处理y+d方向的行（正方形上边界）
            if (row.count(y + d)) {
                auto &s = row[y + d];
                auto l = s.lower_bound({x - d, 0}), r = s.upper_bound({x + d, n});
                for (auto it = l; it != r; it = s.erase(it)) {
                    int v = it->second;
                    if (!vis[v]) { vis[v] = 1; q.push(v); }
                }
            }
        }
    }

    ll count_pairs() {
        ll ans = 0;
        // 重新构建col和row，统计每个可达点的符合条件点对
        map<ll, vector<ll>> col_vec, row_vec;
        for (int i = 1; i <= n; ++i) {
            ll x = p[i].x + p[i].y, y = p[i].x - p[i].y;
            col_vec[x].push_back(y);
            row_vec[y].push_back(x);
        }
        for (auto &[k, v] : col_vec) sort(v.begin(), v.end());
        for (auto &[k, v] : row_vec) sort(v.begin(), v.end());

        for (int i = 1; i <= n; ++i) {
            if (!vis[i]) continue;
            ll x = p[i].x + p[i].y, y = p[i].x - p[i].y;

            // 左边界x-d，y范围[y-d, y+d]
            if (col_vec.count(x - d)) {
                auto &vec = col_vec[x - d];
                ans += upper_bound(vec.begin(), vec.end(), y + d) - lower_bound(vec.begin(), vec.end(), y - d);
            }
            // 右边界x+d，y范围[y-d, y+d]
            if (col_vec.count(x + d)) {
                auto &vec = col_vec[x + d];
                ans += upper_bound(vec.begin(), vec.end(), y + d) - lower_bound(vec.begin(), vec.end(), y - d);
            }
            // 下边界y-d，x范围[x-d, x+d]
            if (row_vec.count(y - d)) {
                auto &vec = row_vec[y - d];
                ans += upper_bound(vec.begin(), vec.end(), x + d) - lower_bound(vec.begin(), vec.end(), x - d);
            }
            // 上边界y+d，x范围[x-d, x+d]
            if (row_vec.count(y + d)) {
                auto &vec = row_vec[y + d];
                ans += upper_bound(vec.begin(), vec.end(), x + d) - lower_bound(vec.begin(), vec.end(), x - d);
            }
        }
        return ans / 2; // 去重无序点对
    }

    int main() {
        cin >> n >> a >> b;
        for (int i = 1; i <= n; ++i) cin >> p[i].x >> p[i].y;
        init();
        bfs();
        cout << count_pairs() << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先将点转换为切比雪夫坐标，用`col`和`row`按x+y、x-y的值分组存储。通过BFS遍历所有可达点（标记`vis`数组），并动态删除已访问点避免重复。最后统计每个可达点周围符合距离条件的点对，除以2得到最终答案。

---
<code_intro_selected>
以下是优质题解的核心片段赏析：
</code_intro_selected>

**题解一：作者 noone___**  
* **亮点**：用并查集合并连通块，通过`delta`数组处理区间合并，逻辑简洁。  
* **核心代码片段**：
    ```cpp
    inline void solve(int now) {
        for(rei i=1;i<=n;++i) id[i]=i;
        sort(id+1,id+1+n,cmp);
        memset(delta,0,sizeof delta);
        for(rei i=1;i<=n;++i) sorted_poi[i]=point[ id[i] ];
        for(rei i=1;i<=n;++i){
            rei l=lower_bound(sorted_poi+1,sorted_poi+1+n,mk(sorted_poi[i].first+dis,sorted_poi[i].second-dis+now))-sorted_poi;
            rei r=upper_bound(sorted_poi+1,sorted_poi+1+n,mk(sorted_poi[i].first+dis,sorted_poi[i].second+dis-now))-sorted_poi-1;
            if(l<=r){
                ++delta[l],--delta[r];
                merge(id[i],id[l]);
                cnt[ id[i] ]+=r-l+1;
            }
        }
        rei pre=0;
        for(rei i=1;i<n;++i){
            pre+=delta[i];
            if(pre) merge(id[i],id[i+1]);
        }
    }
    ```
* **代码解读**：  
  `solve`函数处理一个方向的正方形边界。首先对`id`数组排序（按转换后的x坐标），然后用`lower_bound`和`upper_bound`找到区间`[l,r]`，通过`delta`数组标记区间覆盖。`merge`合并连通块，`cnt`统计每个点的度数。最后通过`pre`累加`delta`，合并连续区间。  
* 💡 **学习笔记**：区间覆盖+并查集是处理连通性问题的高效方法，`delta`数组可快速标记区间，减少遍历次数。

**题解二：作者 Krimson**  
* **亮点**：用动态开点线段树统计区间点，`set`动态删除已访问点，保证复杂度。  
* **核心代码片段**：
    ```cpp
    if(id[0].count(p[u].x+dis)){
        int now=id[0][p[u].x+dis];
        ans+=T[0].query(root[0][now],max(-2e9,p[u].y-dis),min(2e9,p[u].y+dis));
        set<pll> &s=f[0][now];
        for(IT it=s.lower_bound((pll){p[u].y-dis,0});it!=s.end()&&abs(it->first-p[u].y)<=dis;it=s.erase(it)) q.push(it->second);
    }
    ```
* **代码解读**：  
  对于当前点`u`，检查右边界（x+dis）是否存在。若存在，用线段树`T[0].query`统计该列中y在`[y-dis, y+dis]`的点数量（累加到`ans`）。同时遍历`set`中的点，将未访问的点加入队列并删除（避免重复）。  
* 💡 **学习笔记**：线段树适合静态统计，`set`适合动态删除，两者结合可高效处理“统计+遍历”需求。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BFS遍历和点对统计过程，我们设计一个“像素罗盘探险”动画，以8位复古风格展示坐标转换、可达点遍历和点对统计。
</visualization_intro>

  * **动画演示主题**：`像素罗盘的冒险之旅`  
  * **核心演示内容**：从初始点对 $(a,b)$ 出发，通过BFS遍历所有可达点，动态展示正方形边界的点如何被访问，最终统计所有合法点对。  

  * **设计思路简述**：  
    采用FC红白机风格，用像素方块表示点（红：初始点，绿：可达点，蓝：未访问点）。通过闪烁的虚线框标记正方形边界，队列操作用像素箭头表示。音效设计：点入队时“叮”声，统计点对时“滴”声，完成时“胜利”音效。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左半显示原始坐标系（斜45°网格），右半显示转换后的切比雪夫坐标系（正网格）。  
        - 控制面板包含“单步”“自动”“重置”按钮，速度滑块（1-10倍速）。  

    2.  **坐标转换动画**：  
        - 所有点从左半屏（原始坐标）“滑动”到右半屏（切比雪夫坐标），伴随“唰”的音效，同时显示转换公式 $(x,y) \to (x+y, x-y)$。  

    3.  **BFS遍历演示**：  
        - 初始点 $a$ 和 $b$ 变为绿色（标记为可达），加入队列（队列用像素堆叠的方块表示，顶部显示“队列”文字）。  
        - 单步执行时，从队列取出点 $u$，绘制以 $u$ 为中心、边长为 $2d$ 的正方形虚线框（左右上下边界）。  
        - 遍历正方形边界的点：未访问的点（蓝色）变为绿色，加入队列，伴随“叮”声；已访问的点无变化。  

    4.  **点对统计动画**：  
        - 遍历所有绿色点，对每个点绘制正方形边界，边界上的点（绿色或红色）闪烁，同时屏幕上方显示计数（如“当前统计：12”）。  
        - 最终统计完成后，所有合法点对用黄色连线连接，屏幕中央显示总数量，伴随“胜利”音效。  

    5.  **交互控制**：  
        - 单步执行：每点击一次，执行一个BFS步骤（取出队列点，处理边界点）。  
        - 自动播放：按设定速度连续执行，可暂停/继续。  
        - 重置：恢复初始状态，清除所有标记。  

  * **旁白提示**：  
    - （坐标转换时）“看！原来的斜正方形变成了正正方形，处理起来更方便啦～”  
    - （BFS遍历时）“当前处理点u，它的正方形边界上有这些点，未访问的会被加入队列哦！”  
    - （统计点对时）“每个可达点周围的点对会被统计，但要记得除以2去重～”  

<visualization_conclusion>
通过这个动画，你可以直观看到坐标转换的魔力、BFS遍历的过程，以及点对统计的细节，轻松理解算法的核心逻辑！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（坐标转换+连通性分析）可迁移到多种几何问题中。以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    曼哈顿/切比雪夫距离转换适用于：  
    - 统计平面上与给定点距离为定值的点（如“统计某点周围的等距点”）。  
    - 路径搜索问题（如“在曼哈顿距离下寻找最短路径”）。  
    - 几何覆盖问题（如“用正方形覆盖所有点”）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5098 [USACO04OPEN]Cube Stacking**  
        * 🗣️ **推荐理由**：涉及坐标转换和连通性分析，适合巩固“并查集+几何变换”的应用。  
    2.  **洛谷 P1443 马的遍历**  
        * 🗣️ **推荐理由**：BFS遍历的经典问题，可练习动态点集的处理和路径统计。  
    3.  **洛谷 P4781 【模板】拉格朗日插值**  
        * 🗣️ **推荐理由**：涉及几何变换后的数学统计，适合提升综合解题能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自作者 Ebola)**：“在处理正方形角点时，发现会被相邻边重复统计，后来通过特判四个角点并减1解决了问题。”  
> **点评**：角点重复是几何统计中的常见问题，作者通过观察测试用例发现了这一点，并通过简单的特判解决。这提醒我们，在统计边界点时，需仔细检查重叠区域，必要时手动调整计数。  

---

<conclusion>
通过对“[ARC065E] へんなコンパス”的分析，我们掌握了曼哈顿/切比雪夫距离转换、BFS/并查集遍历可达点，以及高效统计点对的方法。希望这份指南能帮助你在类似问题中快速找到思路，继续加油！💪
</conclusion>

---

---
处理用时：165.24秒
# 题目信息

# [ARC147E] Examination

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc147/tasks/arc147_e

$ 1,2,\ldots,N $ の番号のついた $ N $ 人の生徒が試験を受けました。人 $ i\,(1\ \leq\ i\ \leq\ N) $ の点数は $ A_i $ でしたが、$ B_i $ 点以上取らないと留年です。そこで誰も留年しないように、ある $ 2 $ 人の点数を入れ替える、という操作を任意の回数行うことにしました。

これが可能かを判定し、もし可能ならば一度も点数を入れ替えなかった人数の最大値を求めてください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 3\ \times\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ 10^9\,(1\ \leq\ i\ \leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

人 $ 1 $ と人 $ 2 $ の点数を入れ替えると、誰も留年しません。このとき、一度も点数を入れ替えなかった人は人 $ 3 $ だけなので、$ 1 $ を出力します。

## 样例 #1

### 输入

```
3

1 2

3 1

3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
2

100 1

100 1```

### 输出

```
2```

## 样例 #3

### 输入

```
6

3 2

1 6

4 5

1 3

5 5

9 8```

### 输出

```
-1```

## 样例 #4

### 输入

```
6

3 1

4 5

5 2

2 3

5 4

5 1```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ARC147E] Examination 深入学习指南 💡

<introduction>
今天我们来一起分析“[ARC147E] Examination”这道题。题目要求我们判断是否可以通过交换学生分数，使得所有学生都不挂科（分数≥要求），若可以则求最多未交换的学生数。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法 + 堆的应用

🗣️ **初步分析**：
解决这道题的关键在于“贪心选择”——每一步选择对当前问题最有利的交换，从而最小化总交换次数。贪心算法就像搭积木时，每次选最稳的那块，最终搭出最稳固的结构。本题中，我们需要优先选择能最大程度帮助当前不合法学生的候选学生（即A值最大的），这样后续步骤更可能满足条件。

- **题解思路**：首先判断是否有解（排序后A≥B），若有解则将初始不合法的学生（A_i < B_i）加入交换集合，再从合法学生中选A最大的来补充，确保每次交换后整体满足条件。
- **核心难点**：如何高效维护候选学生，确保每一步选择最优；如何处理初始不合法学生与合法学生的交互。
- **可视化设计**：用8位像素风展示学生分数交换过程，用不同颜色标记必须交换（红）和可选交换（绿）的学生。堆的操作用像素方块堆叠动画表示，每次弹出最大A值时伴随“叮”音效，高亮当前处理的学生。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，筛选出以下优质题解：
</eval_intro>

**题解一：作者Phartial（赞：8）**
* **点评**：此题解思路清晰，代码规范。首先排序A、B判断无解，然后用小根堆维护必须交换的A、B，大根堆维护候选合法学生。通过贪心选择最大A值的候选，确保每一步交换最优。代码变量名（如`qa, qb, qu`）含义明确，边界处理严谨（如`!qu.empty()`检查），实践价值高。

**题解二：作者DaiRuiChen007（赞：2）**
* **点评**：此题解抓住核心，用`map`维护前缀和，结合堆动态调整。通过`cnt`变量跟踪当前是否满足条件，贪心选择A最大的候选。代码简洁（仅30行），逻辑紧凑，展示了贪心与堆结合的高效性。

**题解三：作者MortisM（赞：2）**
* **点评**：此题解提供了官方思路与线段树实现两种方法。官方思路用堆维护候选，线段树方法展示了不同数据结构的应用。代码注释清晰（如`// 离散化`），适合学习多解法对比。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，主要会遇到以下核心难点，结合优质题解总结策略：
</difficulty_intro>

1.  **关键点1：如何判断是否有解？**
    * **分析**：将A、B分别排序后，若存在A_i < B_i（排序后），则无解。因为排序后A_i是当前最小的可能值，若仍小于B_i，则无法通过交换满足所有学生。
    * 💡 **学习笔记**：排序后逐位比较是判断全局可行性的关键步骤。

2.  **关键点2：如何处理必须交换的学生？**
    * **分析**：初始A_i < B_i的学生必须交换，用小根堆维护它们的A、B值（保证每次处理最小的不合法对）。
    * 💡 **学习笔记**：小根堆能高效取出当前最“紧迫”的不合法对（A最小的）。

3.  **关键点3：如何选择最优的候选学生？**
    * **分析**：从合法学生中选B_i ≤ 当前A_i的候选，且A_i最大的（用大根堆维护）。这样交换后，新的A值更大，更可能满足后续条件。
    * 💡 **学习笔记**：大根堆能快速获取当前最大A值的候选，贪心策略保证全局最优。

### ✨ 解题技巧总结
<summary_best_practices>
- **排序预处理**：先排序A、B判断无解，简化后续处理。
- **堆的分层使用**：小根堆处理必须交换的对，大根堆维护候选合法学生，高效获取最优解。
- **动态调整候选**：按B_i顺序将合法学生加入候选堆，确保每次处理时候选是当前可用的。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了贪心与堆的高效性。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合Phartial和DaiRuiChen007的思路，用堆维护必须交换的对和候选学生，确保代码简洁高效。
* **完整核心代码**：
    ```cpp
    #include <algorithm>
    #include <iostream>
    #include <queue>
    #include <vector>
    using namespace std;

    const int kN = 3e5 + 1;
    int n, a[kN], b[kN], _a[kN], _b[kN];
    priority_queue<int, vector<int>, greater<int>> qa, qb; // 必须交换的A、B（小根堆）
    priority_queue<int> qu; // 候选合法学生的A（大根堆）
    vector<pair<int, int>> e; // 合法学生的（A,B）

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i] >> b[i];
            _a[i] = a[i], _b[i] = b[i];
        }
        sort(_a + 1, _a + n + 1);
        sort(_b + 1, _b + n + 1);
        for (int i = 1; i <= n; ++i) {
            if (_a[i] < _b[i]) { // 排序后仍存在A_i < B_i，无解
                cout << "-1\n";
                return 0;
            }
        }
        for (int i = 1; i <= n; ++i) {
            if (a[i] < b[i]) { // 必须交换的对
                qa.push(a[i]), qb.push(b[i]);
            } else { // 合法学生，按B排序
                e.emplace_back(a[i], b[i]);
            }
        }
        sort(e.begin(), e.end(), [](auto& x, auto& y) { return x.second < y.second; });
        int ans = n - qa.size(); // 初始未交换数为总人数 - 必须交换数
        for (int i = 0; !qa.empty();) {
            int x = qa.top(), y = qb.top();
            qa.pop(), qb.pop();
            if (x >= y) continue; // 已合法，无需额外交换
            ans--; // 需要额外交换一个学生
            // 将B_i <= x的合法学生加入候选堆
            while (i < e.size() && e[i].second <= x) {
                qu.push(e[i].first);
                i++;
            }
            if (qu.empty()) { // 无候选，无解
                cout << "-1\n";
                return 0;
            }
            qa.push(qu.top()); // 用最大A的候选交换
            qu.pop();
        }
        cout << ans << "\n";
        return 0;
    }
    ```
* **代码解读概要**：代码首先排序A、B判断无解，然后将必须交换的对存入小根堆，合法学生按B排序。遍历必须交换的对，若当前A < B，则从候选堆中取最大A的合法学生交换，确保每一步最优。最终输出未交换的学生数。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Phartial**
* **亮点**：用小根堆维护必须交换的A、B，大根堆维护候选，逻辑清晰。
* **核心代码片段**：
    ```cpp
    for (int i = 0; !qa.empty();) {
        ++ans;
        int x = qa.top(), y = qb.top();
        if (x >= y) {
            qa.pop(), qb.pop();
            continue;
        }
        for (; i < e.size() && e[i].second <= x; ++i) {
            qu.push(e[i].first);
        }
        qa.pop(), qa.push(qu.top()), qu.pop();
    }
    ```
* **代码解读**：循环处理必须交换的对。若当前A < B，将B_i <= x的合法学生加入候选堆（大根堆），然后用最大A的候选交换当前A。这样新的A值更大，更可能满足后续条件。
* 💡 **学习笔记**：大根堆确保每次选最大A的候选，贪心策略保证全局最优。

**题解二：作者DaiRuiChen007**
* **亮点**：用`map`维护前缀和，结合堆动态调整，代码简洁。
* **核心代码片段**：
    ```cpp
    for(auto &x:mark) {
        cnt+=x.second;
        while(!pr1.empty()&&pr1.top().first<=x.first) {
            pr2.push(pr1.top().second);
            pr1.pop();
        }
        while(cnt<0) {
            if(pr2.empty()) return 0&puts("-1");
            int fr=pr2.top();
            pr2.pop();
            if(fr<=x.first) continue;
            ++cnt,--res;
            --mark[fr];
        }
    }
    ```
* **代码解读**：遍历`map`中的前缀和，若当前和小于0，从候选堆中取最大A的学生调整。通过`mark`维护前缀和的变化，确保每一步满足条件。
* 💡 **学习笔记**：`map`+堆的组合能高效处理前缀和调整问题。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解贪心选择过程，我们设计一个“分数交换像素探险”动画，用8位风格展示堆操作和交换过程。
\</visualization_intro\>

  * **动画演示主题**：像素学生的分数交换冒险
  * **核心演示内容**：必须交换的学生（红色方块）需要与合法学生（绿色方块）交换，用堆维护候选，每次选最大A的绿色方块交换。
  * **设计思路简述**：8位像素风营造复古感，颜色区分必须交换（红）和合法（绿）学生。堆操作用堆叠的像素方块表示，弹出最大A时用“跳跃”动画，音效提示关键操作，增强记忆。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：屏幕分左右两部分，左为必须交换区（红方块，标A_i、B_i），右为合法区（绿方块，标A_i、B_i）。控制面板有“单步”“自动”按钮。
    2. **必须交换处理**：红色方块按A_i从小到大排列（小根堆），弹出最小的红方块（当前最紧迫）。
    3. **候选筛选**：合法区按B_i从小到大遍历，将B_i ≤ 当前红A的绿方块加入候选堆（大根堆，堆叠显示）。
    4. **交换动画**：候选堆弹出最大A的绿方块（跳跃动画，音效“叮”），与红方块交换A值。新红方块（原绿A）重新入堆。
    5. **结束判断**：若候选堆空且红方块仍不合法，播放“失败”音效，显示-1；否则所有红方块处理完后，播放“胜利”音效，显示未交换数。

  * **旁白提示**：
    - “看，红色学生的分数不够，必须交换！”
    - “现在需要找一个绿色学生，他的B分不超过当前红色学生的A分，且A分最大。”
    - “交换后，新的分数更大了，继续处理下一个红色学生~”

\<visualization_conclusion\>
通过这个动画，我们能直观看到贪心选择的每一步，理解堆如何高效维护候选，以及交换如何逐步满足所有学生的条件。
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
贪心+堆的思想在许多问题中都有应用，以下是类似题目推荐：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：贪心选择最优候选的策略适用于资源分配、任务调度等问题。例如，用堆维护候选任务，每次选收益最大的；或维护可用资源，每次选最匹配的。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090** - 合并果子  
          * 🗣️ **推荐理由**：经典贪心题，用小根堆维护最小堆，每次合并最小的两堆，与本题堆的使用思路类似。
    2.  **洛谷 P1801** - 黑匣子  
          * 🗣️ **推荐理由**：涉及堆的动态维护（大根堆+小根堆），练习如何高效获取第k小元素。
    3.  **洛谷 P2085** - 最小函数值  
          * 🗣️ **推荐理由**：用堆维护候选函数值，每次选最小的，与本题贪心选择最大A的思路互补。

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解提到调试时遇到候选堆为空的情况，需注意提前判断无解。
\</insights_intro\>

> **参考经验 (来自Phartial)**：“一开始没考虑候选堆为空的情况，导致代码在部分测试用例出错。后来添加了`!qu.empty()`检查，问题解决。”
>
> **点评**：这位作者的经验提醒我们，边界条件（如候选堆为空）的处理至关重要。在贪心算法中，每一步都要检查是否有可用候选，避免越界或错误输出。

---

\<conclusion\>
本次关于“[ARC147E] Examination”的分析就到这里。通过贪心+堆的策略，我们能高效解决问题。记住，贪心的关键是每一步选最优，堆则是实现这一策略的利器。多练习类似题目，你会更熟练地运用这些技巧！下次挑战新题见~💪
\</conclusion\>

---
处理用时：158.65秒
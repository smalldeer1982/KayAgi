# 题目信息

# 部分文字列

## 题目描述

[problemUrl]: https://atcoder.jp/contests/s8pc-2/tasks/s8pc_2_e

$ square1001 $「$ E869120 $は全て文字の$ character $が違うが、$ square1001 $は文字の$ character $が一致するものが$ 2 $個もある！」

$ E869120 $「ということは、部分文字列の種類数も違うのでは…」

$ square1001 $「たとえば$ 1001 $では、$ 2 $文字目だけの$ '0' $と$ 3 $文字目だけの$ '0' $が重複しているのではないか！($ '1' $もそうです)」

ということで、今回は文字列Sの部分文字列を全て列挙し、文字列の重複を$ 1 $つにまとめて数えたときのの文字数の合計を求めてください。

例えば、$ "aba" $のとき、{$ "a","b","a","ab","ba","aba" $}の$ 6 $通りが考えられますが、$ "a" $は重複しているので、

部分文字列としては$ 5 $種類が考えられます。

{$ "a","b","ab","ba","aba" $}の合計$ 1+1+2+2+3=\ 9 $文字となります。

注意：答えは$ 32 $ビット整数型に収まらない可能性があります。

- $ a,\ b,\ c,\ ab,\ bc,\ abc $ が $ abc $ の部分文字列であり, 合計は $ 10 $ 文字である。

- 重複があることに注意してください。

## 说明/提示

### 制約

- $ 1 $ ≦ $ |S| $ ≦ $ 100,000 $
- 含まれる文字の種類はalphabetの小文字だけ

### 小課題

小課題 $ 1 $ \[ $ 15 $ 点 \]

- $ 1≦|S|≦100 $ を満たす。

小課題 $ 2 $ \[ $ 35 $ 点 \]

- $ 1≦|S|≦2,000 $ を満たす。

小課題 $ 3 $ \[ $ 50 $ 点 \]

- 追加の制約はない。

## 样例 #1

### 输入

```
abc```

### 输出

```
10```

## 样例 #2

### 输入

```
aaqqz```

### 输出

```
33```

## 样例 #3

### 输入

```
atcoder```

### 输出

```
84```

# AI分析结果



---
# 💡 Kay的C++算法解析：部分文字列 深入学习指南 💡

<introduction>
今天我们来一起分析“部分文字列”这道C++编程题。题目要求计算字符串所有本质不同子串的长度之和，这需要我们理解字符串处理中的核心算法。本指南将帮助大家梳理思路，掌握关键技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理（后缀数组应用）`

🗣️ **初步分析**：
解决这道题的关键在于理解“本质不同子串”的统计方法。简单来说，本质不同子串指的是不重复的子串。例如，字符串"aba"中，两个"a"子串会被视为重复，只保留一个。

后缀数组（Suffix Array, SA）是解决这类问题的核心工具。它通过对字符串的所有后缀排序，结合`height`数组（相邻后缀的最长公共前缀长度），可以高效统计本质不同子串。具体来说，每个后缀的前缀代表了该后缀的所有子串，而`height`数组告诉我们这些子串中有多少已经被前面的后缀统计过，从而避免重复计算。

**题解思路对比**：  
大部分题解使用后缀数组（SA），通过计算所有子串总长度减去重复子串的长度；仅有一个题解使用后缀树，利用树结构直接统计不同路径的贡献。后缀数组的解法更常见，代码实现更标准化，适合学习；后缀树实现复杂，但时间复杂度更优（线性）。

**核心算法流程**：  
1. 构建后缀数组SA，得到所有后缀的排序。  
2. 计算`height`数组，表示相邻排序后缀的最长公共前缀长度。  
3. 总长度 = 所有子串总长度（无重复时） - 所有重复子串的长度和。  
   其中，所有子串总长度为$\sum_{i=1}^n \frac{i(i+1)}{2}$（i为后缀长度），重复子串长度和为$\sum_{i=1}^n \frac{height[i](height[i]+1)}{2}$。

**可视化设计**：  
采用8位像素风格，用不同颜色的像素块表示字符串字符。动画演示后缀排序过程（如双关键字排序的步骤）、`height`数组的计算（高亮公共前缀部分），以及最终总长度的减法过程。关键步骤加入“叮”音效（如完成一次排序），目标达成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下题解值得重点参考：
</eval_intro>

**题解一：Hoks（赞：2）**
* **点评**：此题解思路清晰，详细推导了公式$\sum \frac{i(i+1)}{2} - \frac{height[i](height[i]+1)}{2}$的来源。代码规范，包含快速IO优化（如`Fast_IO`命名空间），变量命名如`sa`（后缀数组）、`h`（height数组）含义明确。算法上，手动实现了后缀数组和height数组的构建，适合学习SA的核心逻辑。实践价值高，边界处理严谨（如处理输入时的字符校验）。

**题解二：_sunkuangzheng_（赞：1）**
* **点评**：此题解代码极其简洁，利用AtCoder库的`atcoder::suffix_array`和`atcoder::lcp_array`直接获取后缀数组和height数组，避免了手动实现SA的复杂性。公式推导简洁明了，适合快速上手。虽然依赖外部库，但思路清晰，适合理解核心公式的应用。

**题解三：hzjnsy（赞：1）**
* **点评**：此题解详细实现了后缀数组的构建（`Sort`函数）和height数组的计算（`height`函数），并通过`calc`函数计算最终答案。代码结构工整，变量如`sa`（后缀数组）、`rk`（排名数组）命名规范，关键步骤（如基数排序）注释清晰。对SA的实现细节解释到位，适合深入学习SA的构建过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何高效统计本质不同子串的长度和。结合优质题解，我们提炼以下关键点：
</difficulty_intro>

1.  **关键点1：如何计算所有子串的总长度（不考虑重复）**  
    * **分析**：每个长度为$l$的后缀有$l$个子串（长度1到$l$），总长度为$\frac{l(l+1)}{2}$。所有后缀的总长度和为$\sum_{i=1}^n \frac{i(i+1)}{2}$（$i$为后缀长度）。  
    * 💡 **学习笔记**：所有子串的总长度可通过等差数列求和公式快速计算。

2.  **关键点2：如何利用height数组去除重复子串的长度**  
    * **分析**：`height[i]`表示排序后第$i$个后缀与第$i-1$个后缀的最长公共前缀长度。这部分前缀对应的子串已被前一个后缀统计过，需减去其长度和$\frac{height[i](height[i]+1)}{2}$。  
    * 💡 **学习笔记**：`height`数组是避免重复统计的关键，它记录了相邻后缀的重复前缀长度。

3.  **关键点3：后缀数组和height数组的正确构建**  
    * **分析**：后缀数组的构建需通过双关键字排序（基数排序优化），确保所有后缀按字典序排列。height数组的计算需利用排名数组，通过逐个比较后缀的公共前缀长度。  
    * 💡 **学习笔记**：SA和height数组的正确性直接影响最终结果，需仔细处理边界条件（如空字符串、单字符情况）。

### ✨ 解题技巧总结
- **问题转化**：将“本质不同子串长度和”转化为“所有子串长度和 - 重复子串长度和”，简化计算。  
- **公式推导**：利用等差数列求和公式快速计算总长度，避免逐个子串枚举（时间复杂度从$O(n^2)$优化到$O(n\log n)$）。  
- **工具使用**：熟练使用后缀数组模板或库函数（如AtCoder的`lcp_array`），减少手动实现的复杂度。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择Hoks的题解作为通用核心实现，因其手动实现了SA和height数组，适合学习核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码手动实现了后缀数组和height数组的构建，计算所有子串总长度并减去重复部分，适合理解SA的核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;
    const int N = 1e5 + 10;
    int n, ans;
    char s[N];

    namespace SA {
        int sa[N], rk[N], old[N], c[N], h[N];
        void get_SA() {
            int m = 127;
            memset(c, 0, sizeof(c));
            for (int i = 1; i <= n; i++) c[rk[i] = s[i]]++;
            for (int i = 2; i <= m; i++) c[i] += c[i - 1];
            for (int i = n; i >= 1; i--) sa[c[rk[i]]--] = i;
            for (int k = 1; k <= n; k <<= 1) {
                int tot = 0;
                for (int i = n - k + 1; i <= n; i++) old[++tot] = i;
                for (int i = 1; i <= n; i++) if (sa[i] > k) old[++tot] = sa[i] - k;
                memset(c, 0, sizeof(c));
                for (int i = 1; i <= n; i++) c[rk[i]]++;
                for (int i = 2; i <= m; i++) c[i] += c[i - 1];
                for (int i = n; i >= 1; i--) sa[c[rk[old[i]]]--] = old[i];
                swap(rk, old); rk[sa[1]] = 1; tot = 1;
                for (int i = 2; i <= n; i++) 
                    rk[sa[i]] = (old[sa[i]] == old[sa[i-1]] && old[sa[i]+k] == old[sa[i-1]+k]) ? tot : ++tot;
                if (tot == n) break; m = tot;
            }
        }
        void get_height() {
            for (int i = 1, k = 0; i <= n; i++) {
                if (k) k--; int j = sa[rk[i] - 1];
                while (s[i + k] == s[j + k]) k++;
                h[rk[i]] = k;
            }
        }
    }
    using namespace SA;

    signed main() {
        scanf("%s", s + 1); n = strlen(s + 1);
        get_SA(); get_height();
        for (int i = 1; i <= n; i++) ans += i * (i + 1) / 2 - h[i] * (h[i] + 1) / 2;
        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取字符串并构建后缀数组（`get_SA`函数），通过基数排序实现双关键字排序；然后计算height数组（`get_height`函数），利用排名数组逐字符比较公共前缀；最后根据公式计算总长度并输出。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解二：_sunkuangzheng_（来源：个人题解）**
* **亮点**：代码简洁，利用AtCoder库直接获取后缀数组和height数组，避免手动实现SA的复杂性。
* **核心代码片段**：
    ```cpp
    #include<bits/stdc++.h>
    #include <atcoder/all>
    using namespace std;
    int n; string s;  
    int main(){
        cin >> s, n = s.size(); long long ans = 0;
        for(int i = 1; i <= n; i++) ans += 1ll * i * (i + 1) / 2;
        vector<int> sa = atcoder::suffix_array(s), h = atcoder::lcp_array(s, sa);
        for(int i : h) ans -= 1ll * i * (i + 1) / 2;
        cout << ans << "\n";
    }
    ```
* **代码解读**：  
  这段代码首先计算所有子串的总长度（`ans += i*(i+1)/2`），然后通过`atcoder::suffix_array`获取后缀数组`sa`，`atcoder::lcp_array`获取height数组`h`，最后减去重复子串的长度（`ans -= i*(i+1)/2`）。  
  为什么这样写？因为库函数已经封装了SA和height的计算，大大简化了代码，适合快速应用。
* 💡 **学习笔记**：合理使用库函数可以节省时间，适合竞赛中快速解题。

**题解三：hzjnsy（来源：个人题解）**
* **亮点**：手动实现SA和height数组，代码结构清晰，关键步骤注释详细。
* **核心代码片段**（`calc`函数）：
    ```cpp
    int calc() {
        int ret = 0;
        for (int i = 1; i <= len; ++i)
            ret += (len - sa[i] + 1 - ht[i]) * (ht[i] + 2 + len - sa[i]) >> 1;
        return ret;
    }
    ```
* **代码解读**：  
  `len - sa[i] + 1`是第i个后缀的长度，`ht[i]`是其与前一个后缀的公共前缀长度。`(len - sa[i] + 1 - ht[i])`是该后缀新增的本质不同子串数量，这些子串的长度是`ht[i]+1`到`len - sa[i] + 1`，构成等差数列，和为$\frac{数量 \times (首项 + 末项)}{2}$。代码中通过`(ht[i]+2 + len - sa[i]) >> 1`计算首项加末项的一半，再乘以数量，得到该后缀的贡献。  
  为什么这样写？等差数列求和公式的变形，避免浮点运算，提高效率。
* 💡 **学习笔记**：等差数列求和时，用位运算（`>>1`）代替除法，可提升代码效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解后缀数组和height数组如何工作，我们设计一个“像素排序探险”动画，用8位风格展示SA构建和height计算过程。
</visualization_intro>

  * **动画演示主题**：`像素排序探险——寻找本质不同子串的长度和`

  * **核心演示内容**：  
    演示字符串"aba"的后缀数组构建（如后缀"aba", "ba", "a"的排序过程）、height数组计算（如"a"和"ba"的公共前缀长度为0，"ba"和"aba"的公共前缀长度为1），以及总长度的计算（所有子串长度和减去重复部分）。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）降低学习压力；关键步骤（如排序、计算height）用闪烁、颜色变化高亮；音效（如“叮”提示排序完成）强化操作记忆；每完成一个后缀的处理视为“小关卡”，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        屏幕左侧显示原始字符串（像素块，如红色"A"、绿色"B"），右侧显示控制面板（开始/暂停、单步按钮、速度滑块）。背景播放8位风格BGM。

    2.  **后缀数组构建演示**：  
        用不同颜色的长条表示后缀（如蓝色条代表"aba"，黄色条代表"ba"，紫色条代表"a"），通过基数排序逐步排序。每完成一次排序步骤，长条按字典序重新排列，伴随“唰”的音效。

    3.  **height数组计算演示**：  
        选中相邻排序的后缀（如紫色条"A"和黄色条"BA"），逐字符比较，相同字符高亮（绿色），直到不同字符（红色），显示公共前缀长度（如0）。每完成一个height值计算，显示“height=0”的文字气泡，伴随“滴”的音效。

    4.  **总长度计算演示**：  
        左侧显示所有子串的总长度（如"aba"的子串总长度为1+2+3+1+2+1=10），右侧显示重复子串的长度和（如两个"A"的长度和为1+1=2）。通过减法动画（总长度数字减去重复部分），最终得到本质不同子串长度和（10-2=8？实际例子需调整），伴随“胜利”音效。

  * **旁白提示**：  
    - “看！这些长条代表字符串的所有后缀，我们需要按字典序排序它们。”  
    - “这个绿色高亮的部分是两个后缀的公共前缀，长度就是height值哦！”  
    - “总长度减去重复部分，就是我们要的答案啦！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到后缀数组的排序过程、height数组的作用，以及如何通过简单公式得到结果。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以拓展学习其他字符串处理问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    后缀数组和height数组不仅用于本质不同子串统计，还可用于：  
    - 最长公共子串（求两个字符串的最长公共子串，通过合并字符串并求height数组的最大值）；  
    - 不同回文子串统计（结合Manacher算法和SA）；  
    - 字符串循环节判断（通过SA和height数组分析周期性）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3809** - `【模板】后缀数组`  
        * 🗣️ **推荐理由**：直接练习后缀数组的构建，巩固SA的核心逻辑。  
    2.  **洛谷 P1117** - `[NOI2016] 优秀的拆分`  
        * 🗣️ **推荐理由**：需要利用后缀数组统计重复子串，拓展height数组的应用场景。  
    3.  **洛谷 P4081** - `[USACO17DEC]Standing Out from the Herd G`  
        * 🗣️ **推荐理由**：统计每个字符串的独特子串数，需结合多个字符串的SA和height数组。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自 Hoks)**：“在手动实现SA时，容易出错的地方是基数排序的顺序（从后往前遍历保证稳定性）和height数组的初始化（k的初始值处理）。建议通过小例子（如字符串"ab"）手动模拟，验证代码正确性。”  
> **点评**：这位作者的经验非常实用。手动模拟小例子是调试SA和height数组的有效方法，能快速定位排序或比较逻辑的错误。对于复杂算法，动手模拟是避免bug的关键。

---

<conclusion>
本次关于“部分文字列”的C++解题分析就到这里。希望大家通过本指南掌握后缀数组的核心应用，理解如何利用height数组统计本质不同子串的长度和。记住，多动手写代码、多模拟小例子，是提升字符串处理能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：152.65秒
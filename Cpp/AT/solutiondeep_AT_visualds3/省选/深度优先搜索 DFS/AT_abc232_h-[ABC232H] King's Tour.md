# 题目信息

# [ABC232H] King's Tour

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc232/tasks/abc232_h

縦横 $ H\ \times\ W $ のチェス盤と $ 1 $ 個のキングの駒があります。  
 チェス盤のマスのうち、上から $ i $ 行目 $ (1\ \leq\ i\ \leq\ H) $ で左から $ j $ 行目 $ (1\ \leq\ j\ \leq\ W) $ のマスを $ (i,\ j) $ と表します。  
 キングは置かれているマスから周囲 $ 1 $ マスに動かすことができます。より厳密には、チェス盤のマス目の組 $ (i,\ j) $, $ (k,\ l) $ が $ \max(|i-k|,|j-l|)\ =\ 1 $ を満たすとき、かつその時に限り $ (i,j) $ に置かれているキングを $ (k,\ l) $ に動かすことができます。

次の条件を満たすようにキングを縦横 $ H\ \times\ W $ のチェス盤上で動かすことを「ツアー」と定めます。

- はじめ、$ (1,\ 1) $ にキングを置く。そのあと、キングが全てのマスにちょうど $ 1 $ 回ずつ置かれるようにキングを動かす。

たとえば、$ H\ =\ 2,\ W\ =\ 3 $ のとき、$ (1,1)\ \to\ (1,2)\ \to\ (1,\ 3)\ \to\ (2,\ 3)\ \to\ (2,\ 2)\ \to\ (2,\ 1) $ の順にキングを動かしたものは条件を満たします。

チェス盤上の $ (1,1) $ 以外のマス $ (a,\ b) $ が与えられます。ツアーのうち最後にキングが置かれているマスが $ (a,b) $ となるものを $ 1 $ つ構成して出力してください。この問題の制約下において解は必ず存在することが証明できます。

## 说明/提示

### 制約

- $ 2\ \leq\ H\ \leq\ 100 $
- $ 2\ \leq\ W\ \leq\ 100 $
- $ 1\ \leq\ a\ \leq\ H $
- $ 1\ \leq\ b\ \leq\ W $
- $ (a,\ b)\ \neq\ (1,\ 1) $
- 入力はすべて整数である。

### Sample Explanation 1

キングは $ (1,\ 1)\ \to\ (1,\ 2)\ \to\ (2,\ 1)\ \to\ (2,\ 2)\to\ (3,\ 1)\ \to\ (3,\ 2) $ と移動して、これは確かに $ (3,2) $ を終点とするツアーとなっています。 条件を満たすツアーは他にもいくつかあり、たとえば以下の $ 3 $ つの移動が挙げられます。 - $ (1,\ 1)\ \to\ (1,\ 2)\ \to\ (2,\ 2)\ \to\ (2,\ 1)\ \to\ (3,\ 1)\ \to\ (3,\ 2) $ - $ (1,\ 1)\ \to\ (2,\ 1)\ \to\ (1,\ 2)\ \to\ (2,\ 2)\ \to\ (3,\ 1)\ \to\ (3,\ 2) $ - $ (1,\ 1)\ \to\ (2,\ 2)\ \to\ (1,\ 2)\ \to\ (2,\ 1)\ \to\ (3,\ 1)\ \to\ (3,\ 2) $

## 样例 #1

### 输入

```
3 2 3 2```

### 输出

```
1 1

1 2

2 1

2 2

3 1

3 2```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC232H] King's Tour 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**构造性算法（模拟/递归拆分）**  

🗣️ **初步分析**：  
解决“King's Tour”问题，关键在于**通过构造性方法设计国王的巡游路径**。简单来说，构造性算法就像“拼拼图”——把大网格拆分成小的矩形区域，每个区域设计好路径，再把这些路径拼接起来，最终覆盖整个网格并到达指定终点。在本题中，我们需要根据终点$(a,b)$的位置（角落、边上、内部），将网格拆分成不同的矩形块，每个块用“蛇形走法”或“边界绕圈法”生成路径，最后拼接成完整的巡游路线。  

- **核心思路**：将大问题拆分成小矩形的构造问题（如从角落到对角的路径），通过分类讨论终点位置，选择不同的拆分方式（比如先处理左边一部分，再处理右边一部分），确保所有格子被覆盖且路径连续。  
- **核心难点**：1）如何合理拆分网格以适应不同终点位置；2）保证各矩形块的路径衔接正确（即前一个块的终点是后一个块的起点）；3）处理特殊情况（如$H=2$或$W=2$的窄网格）。  
- **可视化设计思路**：用8位像素风格展示网格，国王用“小皇冠”像素块表示，已访问的格子用浅灰色标记。每处理一个矩形块时，用黄色高亮该区域，逐步显示蛇形路径的生成过程（比如从左到右、从上到下交替）。关键步骤（如拆分网格、路径衔接）用“叮”的音效提示，终点到达时播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一：(来源：TKXZ133，赞：7)  
* **点评**：这份题解的**分类讨论非常细致**，将终点位置分成8种情况（角落、边上、内部等），每种情况对应不同的网格拆分方式（比如先处理左边$b-1$列，再处理右边区域）。思路清晰，逻辑严谨——通过“引理”证明了矩形从角落到对角的路径存在性，再将大网格拆分成多个这样的矩形，逐步构造路径。代码中的`walk`函数封装了矩形路径的生成逻辑（蛇形走法），变量命名（如`dir`表示方向）和结构（分情况处理奇偶尺寸）都很规范，容易理解。从实践角度看，代码覆盖了所有情况，边界处理严谨，适合作为竞赛参考。  

### 题解二：(来源：qianxinyu，赞：3)  
* **点评**：此题解的**递归思路很巧妙**，通过将大网格拆分成更小的子网格（如$H=2$或$W=2$的情况），用递归解决子问题，再将子问题的路径调整后拼接成原问题的解。比如当$H=2$时，直接构造“左右往返”的路径；当$W=2$时，交换长宽后递归处理。代码简洁，递归逻辑清晰，但需要理解“子网格路径调整”的技巧（如交换坐标），对初学者来说有一定启发性。  

### 题解三：(来源：sunzz3183，赞：3)  
* **点评**：这份题解的**矩形拼接方法直观**，将网格拆分成多个矩形块（如先处理顶部$a-1$行，再处理右侧区域），每个块用“蛇形走法”生成路径。代码中的`letgo`函数处理了四种方向的矩形路径（左上到右下、右上到左下等），覆盖了所有拆分情况。虽然代码较长，但逻辑清晰，适合学习“如何将大问题拆分成小矩形”的构造思路。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何合理拆分网格？**  
* **分析**：终点位置决定了网格的拆分方式。比如当终点在$(a,b)$（内部）时，可拆分为：① 顶部$a-1$行的完整网格；② 右侧$b+1$列的区域；③ 底部$n-a$行的左侧区域；④ 最后处理终点所在的行。优质题解（如TKXZ133）通过分类讨论终点位置，选择最合适的拆分方式，确保各块路径衔接正确。  
* 💡 **学习笔记**：拆分网格的关键是“让前一个块的终点成为后一个块的起点”。  

### 2. **关键点2：如何生成矩形的路径？**  
* **分析**：矩形路径的生成常用“蛇形走法”——当矩形的长或宽为奇数时，从角落开始，左右交替移动（如先右后左，再右）；当长和宽都为偶数时，先处理前面的列，最后两行用“绕圈”方式处理。题解中的`walk`函数（TKXZ133）和`letgo`函数（sunzz3183）都实现了这种逻辑。  
* 💡 **学习笔记**：蛇形走法是构造网格路径的常用技巧，适用于多种类似问题。  

### 3. **关键点3：如何处理特殊情况（如$H=2$或$W=2$）？**  
* **分析**：当网格很窄（如$H=2$）时，需要调整路径为“左右往返”的方式（如先右走两行，再左走两行）。题解（如qianxinyu）通过递归处理这种情况，将窄网格的路径作为子问题解决，再调整坐标得到原问题的解。  
* 💡 **学习笔记**：特殊情况往往是递归的“基例”，需要单独处理。  

### ✨ 解题技巧总结  
- **技巧A：分类讨论终点位置**：根据终点在角落、边上或内部，选择不同的网格拆分方式。  
- **技巧B：蛇形走法生成矩形路径**：处理矩形区域时，用左右交替的方式覆盖所有格子。  
- **技巧C：递归拆分问题**：将大网格拆分成小网格，递归解决子问题，再拼接路径。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了TKXZ133题解的思路，封装了矩形路径生成函数`walk`，并通过分类讨论终点位置调用`walk`函数，构造完整路径。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  int n, m, a, b;

  void walk(int x1, int y1, int x2, int y2) {
      int dir = 1; // 1: 左上到右下, 2: 右上到左下, 3: 左下到右上, 4: 右下到左上
      if (x1 > x2) swap(x1, x2), dir = 3;
      if (y1 > y2) swap(y1, y2), dir = 2;
      int h = x2 - x1 + 1, w = y2 - y1 + 1;
      vector<pair<int, int>> path;

      // 生成蛇形路径
      if ((h % 2) || (w % 2)) {
          if (h % 2) {
              int x = 1, y = 0, d = 1;
              for (int i = 1; i <= h * w; i++) {
                  y += d;
                  if (y == w + 1) y = w, x++, d = -d;
                  if (y == 0) y = 1, x++, d = -d;
                  path.emplace_back(x, y);
              }
          } else {
              int x = 0, y = 1, d = 1;
              for (int i = 1; i <= h * w; i++) {
                  x += d;
                  if (x == h + 1) x = h, y++, d = -d;
                  if (x == 0) x = 1, y++, d = -d;
                  path.emplace_back(x, y);
              }
          }
      } else {
          // 处理长宽均为偶数的情况
          int x = 1, y = 0, d = 1;
          for (int i = 1; i <= (h - 2) * w; i++) {
              y += d;
              if (y == w + 1) y = w, x++, d = -d;
              if (y == 0) y = 1, x++, d = -d;
              path.emplace_back(x, y);
          }
          for (int i = 1; i <= w; i++) {
              path.emplace_back(h - 1, i);
              path.emplace_back(h, i);
          }
      }

      // 调整方向
      if (dir == 2) for (auto& p : path) p.second = w - p.second + 1;
      if (dir == 3) for (auto& p : path) p.first = h - p.first + 1;
      if (dir == 4) for (auto& p : path) p.first = h - p.first + 1, p.second = w - p.second + 1;

      // 输出路径（调整坐标到原网格）
      for (auto& p : path) {
          cout << p.first + x1 - 1 << ' ' << p.second + y1 - 1 << '\n';
      }
  }

  void solve() {
      if (a == n && b == m) {
          walk(1, 1, n, m);
      } else if (a == n && b == 1) {
          walk(1, 1, n - 1, m);
          walk(n, m, a, b);
      } else if (a == 1 && b == m) {
          walk(1, 1, n, m - 1);
          walk(n, m, a, b);
      } else if (a == 1) {
          walk(1, 1, n, b - 1);
          walk(n, b, 2, m);
          walk(1, m, a, b);
      } else if (b == m) {
          walk(1, 1, a - 1, m);
          walk(a, m - 1, n - 1, 1);
          walk(n, 1, n, m);
          walk(n - 1, m, a, b);
      } else if (a == n) {
          walk(1, 1, n, b - 1);
          walk(n - 1, b, 1, b);
          walk(1, b + 1, n - 1, m);
          walk(n, m, a, b);
      } else if (b == 1) {
          walk(1, 1, a - 1, m);
          walk(a, m, n, 2);
          walk(n, 1, a, b);
      } else {
          walk(1, 1, a - 1, m);
          walk(a, m, n, b + 1);
          walk(n, b, a + 1, 1);
          walk(a, 1, a, b);
      }
  }

  int main() {
      cin >> n >> m >> a >> b;
      solve();
      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为两部分：`walk`函数生成矩形区域的蛇形路径，`solve`函数根据终点位置分类讨论，调用`walk`函数构造完整路径。`walk`函数处理了矩形的奇偶尺寸情况，生成蛇形路径后调整方向（如右上到左下），最后输出调整后的坐标。`solve`函数通过分类讨论终点位置，将网格拆分成多个矩形块，依次调用`walk`函数生成路径。  


### 题解一（TKXZ133）核心代码片段赏析  
* **亮点**：`walk`函数封装了矩形路径的生成逻辑，处理了所有方向和尺寸情况。  
* **核心代码片段**：  
  ```cpp
  void walk(int x1, int y1, int x2, int y2) {
      int dir = 1;
      if (x1 > x2) swap(x1, x2), dir = 3;
      if (y1 > y2) swap(y1, y2), dir = 2;
      int h = x2 - x1 + 1, w = y2 - y1 + 1;
      vector<pair<int, int>> path;

      // 生成蛇形路径（省略奇偶处理代码）

      // 调整方向
      if (dir == 2) for (auto& p : path) p.second = w - p.second + 1;
      if (dir == 3) for (auto& p : path) p.first = h - p.first + 1;
      if (dir == 4) for (auto& p : path) p.first = h - p.first + 1, p.second = w - p.second + 1;

      // 输出路径
      for (auto& p : path) {
          cout << p.first + x1 - 1 << ' ' << p.second + y1 - 1 << '\n';
      }
  }
  ```
* **代码解读**：  
  - `dir`变量表示矩形的方向（如左上到右下），通过交换坐标调整方向。  
  - `h`和`w`表示矩形的长宽，生成蛇形路径后，根据`dir`调整路径的方向（如将右上到左下的路径转换为左上到右下的路径）。  
  - 最后将路径坐标调整到原网格的坐标（加上`x1-1`和`y1-1`）。  
* 💡 **学习笔记**：封装矩形路径生成函数可以简化代码，提高可读性。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**国王的像素巡游**（8位FC风格）  
### 核心演示内容：  
展示国王从$(1,1)$出发，按照“蛇形走法”遍历网格，最终到达$(a,b)$的过程。重点演示网格拆分（如将大网格拆分成小矩形）、蛇形路径生成（左右交替移动）、路径衔接（前一个矩形的终点是后一个矩形的起点）。  

### 设计思路简述：  
采用8位像素风格（类似FC游戏《超级马里奥》），网格用16x16像素的方块表示，国王用“小皇冠”像素块（32x32像素）表示。已访问的格子用浅灰色标记，当前处理的矩形区域用黄色高亮。关键步骤（如拆分网格、路径衔接）播放“叮”的音效，终点到达时播放“胜利”音效（类似《魂斗罗》的通关音效）。  

### 动画帧步骤与交互关键点：  
1. **场景初始化**：屏幕显示$H \times W$的像素网格，$(1,1)$位置显示国王，$(a,b)$位置显示“目标旗帜”（红色像素块）。控制面板有“开始”“单步”“重置”按钮和速度滑块。  
2. **网格拆分**：根据终点位置，用黄色框标记第一个要处理的矩形区域（如顶部$a-1$行），旁边的文字提示“正在处理顶部区域”。  
3. **蛇形路径生成**：国王按照蛇形走法移动，每走一步，当前格子变为浅灰色。移动时播放“脚步”音效（类似《吃豆人》的移动声）。  
4. **路径衔接**：当处理完一个矩形区域后，国王移动到下一个矩形区域的起点，播放“衔接”音效（叮），并显示文字提示“进入下一个区域”。  
5. **终点到达**：国王到达$(a,b)$时，目标旗帜变为“胜利烟花”（彩色像素动画），播放“胜利”音效，屏幕显示“巡游完成！”。  

### 旁白提示：  
- “现在处理顶部$a-1$行的区域，国王要走蛇形路线哦！”  
- “国王走到了第一个区域的终点，接下来要进入右边的区域啦！”  
- “国王到达目标点啦！巡游成功！”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
构造性算法（如蛇形走法、网格拆分）不仅能解决本题，还能用于：  
1. **迷宫生成**：用蛇形走法生成简单的迷宫。  
2. **路径覆盖问题**：如“骑士巡游”（Knight's Tour），要求骑士遍历所有格子恰好一次。  
3. **数据可视化**：将二维数据用蛇形路径转换为一维序列（如图像压缩中的扫描方式）。  

### 练习推荐 (洛谷)：  
1. **洛谷 P1328** - 《生活大爆炸版石头剪刀布》  
   🗣️ **推荐理由**：虽然是模拟题，但需要处理复杂的状态转移，锻炼分类讨论能力。  
2. **洛谷 P2789** - 《直线交点数》  
   🗣️ **推荐理由**：构造性问题，要求生成特定交点数的直线组合，锻炼构造思路。  
3. **洛谷 P3916** - 《图的遍历》  
   🗣️ **推荐理由**：深度优先搜索（DFS）的应用，类似巡游问题，锻炼路径生成能力。  


## 7. 学习心得与经验分享 (若有)  
本次分析的题解中，TKXZ133作者提到“赛时写了一个半小时过了”，说明**分类讨论虽然繁琐，但逻辑清晰的话可以快速解决问题**。qianxinyu作者的递归思路提醒我们，**将大问题拆分成小问题（递归基例）是解决构造性问题的有效方法**。这些经验告诉我们，在解决构造性问题时，要先想清楚“如何拆分问题”，再动手写代码。  


## 结语  
本次关于“King's Tour”的C++解题分析就到这里。希望这份学习指南能帮助大家理解构造性算法的思路和技巧。记住，构造性问题的关键是“拆分成小问题，再拼接起来”，多练习类似题目（如骑士巡游）可以提高构造能力。下次我们再一起探索新的编程挑战！💪

---
处理用时：147.93秒
# 题目信息

# [ARC170E] BDFS

## 题目描述

给定整数 $N, P$。

有一个 $N$ 个顶点 $N$ 条边的图，顶点编号为 $1$ 到 $N$。第 $i$ 条边连接顶点 $i$ 和顶点 $i+1$，是双向的。这里顶点 $N+1$ 代表顶点 $1$。

请执行以下算法，得到一个长度为 $N$ 的数列 $D=(D_1, D_2, \ldots, D_N)$。

- 令长度为 $N$ 的整数列 $D = (D_1, \ldots, D_N) = (-1, \ldots, -1)$。同时，令数对序列 $Q = ((1, 0))$。只要 $Q$ 非空，重复以下操作：

  - 取出 $Q$ 的首元素 $(v, d)$，并将其从 $Q$ 中删除。
  - 如果 $D_v = -1$，则令 $D_v := d$，并对与顶点 $v$ 相邻且满足 $D_x = -1$ 的每个顶点 $x$，按顶点编号从小到大依次进行如下操作：
    1. 以概率 $\frac{P}{100}$，将 $(x, d+1)$ 加入 $Q$ 的**首部**。
    2. 若未将 $(x, d+1)$ 加入 $Q$ 的首部，则将其加入 $Q$ 的**尾部**。

最终得到的 $D$ 的所有元素之和的期望值，模 $998244353$ 后输出。

给定 $T$ 组测试数据，请分别输出每组的答案。

期望值 $\bmod\ 998244353$ 的定义：可以证明，所求期望值一定是有理数。在本题的约束下，若将其表示为最简分数 $\frac{P}{Q}$，则 $Q$ 保证不被 $998244353$ 整除。此时，唯一存在一个 $0$ 到 $998244352$ 之间的整数 $R$ 满足 $R \times Q \equiv P \pmod{998244353}$。请输出这个 $R$ 作为答案。

## 说明/提示

### 数据范围

- $1 \leq T \leq 10^4$
- $3 \leq N \leq 10^{18}$
- $1 \leq P \leq 99$
- 输入的所有数均为整数

### 样例解释 1

对于第 $1$ 组测试数据，算法的执行过程例如如下：

- 初始时，$D = (-1, -1, -1),\ Q = ((1, 0))$。取出 $Q$ 首元素 $(1, 0)$。
- 因为 $D_1 = -1$，令 $D_1 := 0$。与顶点 $1$ 相邻且 $D_x = -1$ 的顶点为 $2, 3$。
- 将 $(2, 1)$ 加入 $Q$ 首部，将 $(3, 1)$ 加入 $Q$ 尾部。此时 $Q = ((2, 1), (3, 1))$。
- 取出 $Q$ 首元素 $(2, 1)$。
- 因为 $D_2 = -1$，令 $D_2 := 1$。与顶点 $2$ 相邻且 $D_x = -1$ 的顶点为 $3$。
- 将 $(3, 2)$ 加入 $Q$ 首部。此时 $Q = ((3, 2), (3, 1))$。
- 取出 $Q$ 首元素 $(3, 2)$。
- 因为 $D_3 = -1$，令 $D_3 := 2$。与顶点 $3$ 相邻且 $D_x = -1$ 的顶点不存在，不做任何操作。
- 取出 $Q$ 首元素 $(3, 1)$。
- 因为 $D_3 = 2$，不做任何操作。
- $Q$ 为空，算法结束。

此时最终 $D = (0, 1, 2)$。上述过程发生的概率为 $\frac{1}{8}$，$D$ 的元素和的期望值为 $\frac{5}{2}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3

3 50

4 1

1000000000000000000 70```

### 输出

```
499122179

595552585

760296751```

# AI分析结果


# 💡 Kay的C++算法解析：ARC170E BDFS 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划与概率期望`  

🗣️ **初步分析**：
> 这道题的核心在于将随机BFS过程转化为**动态规划模型**，并通过**矩阵快速幂**高效处理超大范围数据。想象你在一个圆桌旁分发礼物（节点），每次只能向左或向右传递礼物，传递方向由概率P决定。你需要计算所有人收到礼物时"传递步数"的总和期望。  
   - 优质题解通过定义队列状态（队首/队尾深度）或操作序列（L/R指令）建立概率转移模型  
   - 核心难点在于设计包含方向状态和期望累积的DP方程，并用矩阵压缩状态转移过程  
   - 可视化将采用**像素圆环+方向箭头**：环上节点用8位像素方块表示，当前处理节点高亮闪烁，L/R操作用红/蓝箭头动画，概率触发时播放复古音效（"叮"声表成功，失败时低沉音效）

---

## 2. 精选优质题解参考

**题解一（来源：DaiRuiChen007）**
* **点评**：该解法直接建立队列状态DP（`f`表队首深度期望，`g`表队尾），思路清晰直观。代码采用4x4矩阵封装状态转移（含`f, g, 1, ans`），结构工整规范。矩阵快速幂将O(n)优化至O(log n)，完美应对n≤10¹⁸。边界处理严谨（初始状态`[0,0]`），可直接用于竞赛实践。

**题解二（来源：NobodyThere）**
* **点评**：创新性提出"方向状态机"模型（L/R表示当前扩张方向），用`f0/f1`记录方向相关深度期望。状态定义巧妙体现BFS行为本质，转移方程简洁（仅3个线性组合）。虽未提供完整代码，但矩阵构造思路完整，实践时结合题解一代码结构即可快速实现。

**题解三（来源：qiuzx）**
* **点评**：独辟蹊径用生成函数方法，将期望转化为LR序列概率问题。亮点在于用二项式定理`(p+(1-p)x)^m`解析概率分布，再通过等比数列求和公式直接计算。避免矩阵乘法常数，理论效率最优。代码实现简洁但数学推导较深，适合进阶学习。

---

## 3. 核心难点辨析与解题策略

1.  **难点：状态机建模**
    * **分析**：BFS的随机性体现在队列操作顺序（队首/队尾），需抽象为方向状态（L/R）或队列状态（队首/队尾深度）。优质解用`(f, g)`或`(f0, f1)`捕捉核心状态，确保无后效性
    * 💡 **学习笔记**：队列行为本质是状态机，抓住"当前处理方向"和"待处理方向"两个关键

2.  **难点：期望的线性分解**
    * **分析**：深度和期望可拆解为每个扩张步骤的贡献。如题解二将`ans`分解为`f0`和`f1`的线性组合，题解三拆解为LR序列概率对
    * 💡 **学习笔记**：复杂期望=简单期望的线性组合（期望可加性）

3.  **难点：超大范围优化**
    * **分析**：n≤10¹⁸需O(log n)算法。矩阵快速幂（题解一/二）或生成函数封闭解（题解三）均可实现
    * 💡 **学习笔记**：指数级数据范围优先考虑矩阵幂或数学公式

### ✨ 解题技巧总结
- **技巧1：状态压缩** - 用最少变量捕获问题本质（如方向状态代替完整队列）
- **技巧2：模块化矩阵** - 将DP转移封装为矩阵乘法，便于快速幂优化
- **技巧3：概率归一化** - 模998244353下用分数逆元处理概率（如P→P×828542813 mod 998244353）

---

## 4. C++核心代码实现赏析

**通用核心C++实现参考（基于DaiRuiChen007解法）**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef array<array<long,4>,4> Mat;
const int MOD=998244353, inv100=828542813; // 100的模逆元

inline Mat operator*(const Mat &u, const Mat &v) { // 4x4矩阵乘法
    Mat w{};
    for(int i=0; i<4; ++i) 
        for(int k=0; k<4; ++k) 
            for(int j=0; j<4; ++j) 
                w[i][j] = (w[i][j] + u[i][k]*v[k][j]) % MOD;
    return w;
}

void solve() {
    long long n; int P;
    scanf("%lld%d",&n,&P); 
    n--; // 操作次数n-1
    int p = 1LL * P * inv100 % MOD; // 概率归一化

    Mat I = { // 转移矩阵：状态[f, g, 1, ans]
        p, 1-p, 0, 1,     // f' = p*(f+1) + (1-p)*g
        1-p, p, 0, 0,     // g' = (1-p)*(f+1) + p*g
        p, 1-p, 1, 1,     // ans' = ans + (p*f + (1-p)*g) + 1
        0, 0, 0, 1        // ans累积项
    };
    Mat X = {{{0,0,1,0}}}; // 初始状态[f0=0, g0=0, 1, ans0=0]

    for(; n; n>>=1, I=I*I) // 矩阵快速幂
        if(n&1) X = X*I;
    printf("%ld\n", X[0][3]); // 输出最终ans
}
```

**题解一核心片段赏析**
```cpp
// 状态定义: [f, g, 常数1, ans]
f' = p*(f+1) + (1-p)*g  // 新队首期望
g' = (1-p)*(f+1) + p*g  // 新队尾期望
ans' = ans + [p*f + (1-p)*g] + 1 // 累积深度和
```
* **学习笔记**：将DP转移表示为矩阵乘法是处理线性递推的利器

**题解二核心片段赏析**
```cpp
/* 状态转移方程 */
f0' = p*f0 + (1-p)*f1 + 1  // 当前方向深度更新
f1' = (1-p)*f0 + p*f1      // 相反方向深度更新
ans' = ans + p*f0 + (1-p)*f1 + 1 // 期望累积
```
* **学习笔记**：方向状态机通过`f0/f1`的交替传递完美模拟BFS随机性

**题解三核心片段赏析**
```cpp
// 概率解析核心公式
double prob = 0.5 * (1 + pow(2p-1, m)); // 位置x,y相同的概率
int total = sum_{m=0}^{n-2} (n-m-1)*(1 + (2p-1)^m);
```
* **学习笔记**：二项式定理`(a+bx)^n`结合`x=1/-1`是处理二值概率分布的巧技

---

## 5. 算法可视化：像素动画演示

* **主题**：`像素环探险`  
* **核心演示**：BFS在环上随机扩张过程，突出方向决策与深度累积  

### 动画帧设计（8-bit像素风）
1. **场景初始化**  
   - 像素圆环显示1~N编号节点（16色）
   - 控制面板：开始/步进/速度滑块（FC红白机风格）
   - 状态栏：显示当前深度和期望值

2. **BFS过程演示**  
   ```mermaid
   graph LR
   A[当前节点闪烁] --> B{概率判定}
   B -- P/100 --> C[加入队首: 红色箭头]
   B -- 1-P/100 --> D[加入队尾: 蓝色箭头]
   C --> E[立即处理新节点]
   D --> F[延迟处理]
   ```

3. **关键交互**  
   - **方向决策**：向左/右扩张时播放对应音效（L: 高音"叮"，R: 低音"咚"）
   - **概率触发**：成功加入队首时节点变红+胜利音效，失败时变灰+低沉音效
   - **AI演示模式**：自动步进模拟完整BFS（速度可调）

4. **数据结构可视化**  
   - 队列显示为底部像素条：队首（红色）、队尾（蓝色）
   - 当前深度值用像素数字实时显示

---

## 6. 拓展练习与相似问题

1. **洛谷 P1600**  
   - 期望DP基础练习，适合掌握状态设计
2. **洛谷 P2151**  
   - 矩阵快速幂经典应用，强化编码实现
3. **洛谷 P4547**  
   - 概率期望进阶题，含复杂状态转移

---

## 7. 学习心得与经验分享

> **来自DaiRuiChen007的调试经验**：  
> “矩阵初始化时易漏掉常数项，需专门设计状态位（如第3列）保证正确性”  
>   
> **Kay点评**：  
> 矩阵快速幂中，常数项转移最易被忽略。建议编码时先写转移方程再逐行映射矩阵，并用小数据验证（如n=2）

---

通过对随机BFS过程的动态规划建模，结合矩阵优化技巧，我们成功解决了超大规模概率期望问题。记住：复杂问题简单化（状态压缩）是算法设计的精髓！

---
处理用时：124.73秒
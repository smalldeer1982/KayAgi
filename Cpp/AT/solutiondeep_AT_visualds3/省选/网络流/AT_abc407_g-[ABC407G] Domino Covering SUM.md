# 题目信息

# [ABC407G] Domino Covering SUM

## 题目描述

给你一个 $H$ 行 $W$ 列的网格，第 $i$ 行第 $j$ 列的格子上写有数字 $A_{i,j}$。

你要在网格上摆放若干个多米诺骨牌，每个骨牌盖住相邻的两个格子。你要保证没有任何一个格子被多于一个骨牌盖住。

求摆放完骨牌之后，所有**没有**被骨牌盖住的格子上的数字之和的最大值。

## 说明/提示

**样例解释 1**

网格如下所示：

![](https://img.atcoder.jp/abc407/5381f1b744f7aeb5255628f8154a70be.png)

以下的摆放方式中未被盖住的数字之和为 $23$。

![](https://img.atcoder.jp/abc407/138df0fb001c8e55e88f41af1ca61d63.png)

可以证明此值无法达到 $24$ 或更大，故输出 $23$。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
3 4
3 -1 -4 1
-5 9 -2 -6
-5 3 -5 8```

### 输出

```
23```

## 样例 #2

### 输入

```
5 5
-70 11 -45 -54 -30
-99 39 -83 -69 -77
-48 -21 -43 -96 -24
-54 -65 21 -88 -44
-90 -33 -67 -29 -62```

### 输出

```
39```

## 样例 #3

### 输入

```
8 9
-74832 16944 58683 32965 97236 -52995 43262 -51959 40883
-58715 13846 24919 65627 -11492 -63264 29966 -98452 -75577
40415 77202 15542 -50602 83295 85415 -35304 46520 -38742
37482 56721 -38521 63127 55608 95115 42893 10484 70510
53019 40623 25885 -10246 70973 32528 -33423 19322 52097
79880 74931 -58277 -33783 91022 -53003 11085 -65924 -63548
78622 -77307 81181 46875 -81091 63881 11160 -82217 -55492
62770 39530 -95923 92440 -69899 77737 89392 -14281 84899```

### 输出

```
2232232```

# AI分析结果


### Kay的C++算法解析：Domino Covering SUM 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论 - 最小费用最大流

🗣️ **初步分析**：
> 这道题的本质是**二分图最小权匹配问题**。想象网格是一个国际象棋棋盘（黑白染色），每个骨牌覆盖相邻的黑白格子（相当于在二分图的两个部分间建立匹配）。每个匹配的权值是被覆盖的两个格子的数字之和，我们的目标是让未被覆盖的格子之和最大，等价于让被覆盖的格子之和最小。

> **核心算法流程**：
> 1. 对网格黑白染色（(i+j)为奇/偶）
> 2. 建图：源点→黑点（容量1，费用0），黑点→相邻白点（容量1，费用=两点权和），白点→汇点（容量1，费用0）
> 3. 跑最小费用流，当增广路费用≥0时停止
> 4. 答案 = 总和 - 最小费用

> **可视化设计思路**：
> - 像素网格中，黑点用深灰，白点用浅灰
> - 增广路径查找时，当前节点高亮为蓝色，更新邻居时显示距离值
> - 找到匹配时骨牌旋转落下覆盖两个格子（8-bit音效）
> - 控制面板显示实时费用和未覆盖格子之和

---

#### 2. 精选优质题解参考
**题解一（作者：Milthm）**
* **点评**：
  思路清晰点出二分图本质，强调"允许不匹配"的关键点。代码虽未展示，但分享了宝贵调试经验：误将最大流变量当作费用输出，提醒大家模板复用时要理解变量含义。费用控制逻辑完整（非负则停），实践参考价值高。

**题解二（作者：EricWan）**
* **点评**：
  解法简洁有力，直接抓住"增广路费用非负则停"的核心优化点。提出用原始对偶算法优化复杂度，并分享比赛调试经历（初始化问题），强调边界测试的重要性。代码模块化设计值得学习。

**题解三（作者：lao_wang）**
* **点评**：
  提供完整可运行代码，SPFA实现规范。亮点在于：
  1. 清晰的方向数组处理相邻格子
  2. 实时计算流量`dist[t]`
  3. 显式判断`if(dis[t]>0) return`控制费用
  4. 节点编号用`(i-1)*m+j`避免冲突

---

#### 3. 核心难点辨析与解题策略
1. **难点：正确建模二分图匹配**
   * 分析：必须理解骨牌覆盖本质是匹配问题，且需允许部分点未被匹配（通过源/汇点直连实现）
   * 💡 学习笔记：匹配不要求全覆盖！关键技巧是给每个点"逃避匹配"的机会

2. **难点：费用流终止条件**
   * 分析：当增广路费用≥0时继续匹配反而增加总费用，应停止
   * 💡 学习笔记：最小费用流中，增广费用单调不减，首次非负即达最优

3. **难点：负权边处理**
   * 分析：格子含负数，SPFA需支持负权
   * 💡 学习笔记：Dijkstra不能处理负权，SPFA在此更通用

✨ **解题技巧总结**：
- **染色转化**：将网格问题转化为二分图是突破口
- **费用控制**：实时检查增广路费用，非负即停
- **边界防护**：方向数组配合坐标校验
- **调试技巧**：小网格模拟（如2x2）验证匹配逻辑

---

#### 4. C++核心代码实现赏析
**通用核心实现**（综合题解优化）：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF = 1e18;
const int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};

struct Edge { int to; ll cap, cost, rev; };
vector<vector<Edge>> g;
vector<ll> dist, h;
vector<int> preV, preE;

void addEdge(int u, int v, ll cap, ll cost) {
    g[u].push_back({v, cap, cost, (ll)g[v].size()});
    g[v].push_back({u, 0, -cost, (ll)g[u].size()-1});
}

ll minCostFlow(int s, int t) {
    ll res = 0;
    while (true) {
        priority_queue<pair<ll, int>> pq;
        dist.assign(g.size(), INF);
        dist[s] = 0;
        pq.push({0, s});
        
        while (!pq.empty()) {
            auto [d, u] = pq.top(); pq.pop();
            if (-d != dist[u]) continue;
            for (int i = 0; i < g[u].size(); i++) {
                auto &e = g[u][i];
                if (e.cap > 0 && dist[e.to] > dist[u] + e.cost + h[u] - h[e.to]) {
                    dist[e.to] = dist[u] + e.cost + h[u] - h[e.to];
                    preV[e.to] = u;
                    preE[e.to] = i;
                    pq.push({-dist[e.to], e.to});
                }
            }
        }
        if (dist[t] == INF) break;
        if (dist[t] >= 0) break; // 核心优化
        
        for (int i = 0; i < g.size(); i++) h[i] += dist[i];
        ll f = INF;
        for (int v = t; v != s; v = preV[v]) 
            f = min(f, g[preV[v]][preE[v]].cap);
        
        res += f * h[t];
        for (int v = t; v != s; v = preV[v]) {
            auto &e = g[preV[v]][preE[v]];
            e.cap -= f;
            g[v][e.rev].cap += f;
        }
    }
    return res;
}

int main() {
    int n, m; cin >> n >> m;
    ll total = 0;
    vector grid(n, vector(m, 0));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
            total += grid[i][j];
        }
    
    int s = n * m, t = s + 1;
    g.resize(t + 1);
    h.assign(t + 1, 0);
    preV.resize(t + 1); preE.resize(t + 1);
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int id = i * m + j;
            if ((i + j) % 2 == 0) { // 黑格
                addEdge(s, id, 1, 0);
                for (int d = 0; d < 4; d++) {
                    int ni = i + dx[d], nj = j + dy[d];
                    if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    int nid = ni * m + nj;
                    addEdge(id, nid, 1, grid[i][j] + grid[ni][nj]);
                }
            } else {
                addEdge(id, t, 1, 0);
            }
        }
    }
    
    cout << total - minCostFlow(s, t);
}
```

**代码解读概要**：
1. **原始对偶算法**：通过势函数h处理负权，效率高于SPFA
2. **核心优化**：`if(dist[t] >= 0) break` 确保及时停止
3. **优雅建图**：
   - 二维坐标转一维id
   - 方向数组遍历邻居
   - 动态调整容量

---

#### 5. 算法可视化：像素动画演示
**主题**：8-bit风格《骨牌消消乐》

**核心演示**：
```plaintext
┌──────────────┐
│  C=3  D=-1   │  ◁ 当前费用：-4
│ E=-4  F=1    │  ◁ 未覆盖和：23
└──────────────┘
```
1. **初始化**：
   - 网格像素化（16色），黑/白格子区分
   - 控制面板：开始/步进/重置，速度滑块

2. **寻路动画**：
   - 当前节点闪烁蓝光
   - 松弛操作：黄线连接节点，显示更新后距离
   - 音效：滴（入队）、咔（距离更新）

3. **骨牌放置**：
   - 找到匹配：红色路径高亮
   - 骨牌旋转落下（像素动画）
   - "叮咚"音效 + 得分特效

4. **终止条件**：
   - 费用≥0时播放警告音
   - 未覆盖格子高亮绿光
   - 显示最终分数（8-bit胜利音乐）

**技术实现**：
```javascript
// 伪代码示例
function drawGrid() {
  for (let i=0; i<H; i++) 
    for (let j=0; j<W; j++) {
      ctx.fillStyle = (i+j)%2 ? "#CCC" : "#444"; 
      drawPixel(i, j, grid[i][j]); // 绘制数字
    }
}

function findPath() {
  highlightCurrentNode(blue); 
  await sleep(speed);
  for (neighbor in adjList) {
    drawRelaxEdge(yellow); 
    if (newDist < oldDist) {
      updateDistance();
      playSound("click");
    }
  }
}
```

---

#### 6. 拓展练习与相似问题
**通用技巧迁移**：
1. 棋盘覆盖问题（骨牌/多米诺）
2. 带权二分图匹配
3. 网络流建模解决约束优化

**推荐练习**：
1. [洛谷 P6062] Muddy Fields
   - 同类网格覆盖，需处理特殊障碍
2. [洛谷 P4003] 无限之环
   - 进阶版管道匹配，多状态费用流
3. [洛谷 P3358] 最长k可重区间集
   - 非网格但同属费用流经典应用

---

#### 7. 学习心得与经验分享
> **经验（Milthm）**："误将最大流变量当作费用输出，调试半小时才发现问题"
> 
> **Kay点评**：模板复用时要彻底理解变量含义！建议：
> 1. 给关键变量添加注释
> 2. 用小网格测试输出中间值
> 3. 封装函数时保持接口清晰

---

### 总结
通过本指南，我们掌握了：
1️⃣ 网格问题转化为二分图匹配的思维
2️⃣ 费用流求解最小权匹配的实现技巧
3️⃣ 关键优化：非负费用终止
4️⃣ 调试经验：模板变量理解的重要性

> 记住：好的算法设计如同摆放多米诺骨牌，每一步精准衔接才能达到最优解！ 🎮

---
处理用时：202.03秒
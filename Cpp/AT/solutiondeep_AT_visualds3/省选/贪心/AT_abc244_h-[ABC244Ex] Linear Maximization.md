# 题目信息

# [ABC244Ex] Linear Maximization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc244/tasks/abc244_h

$ 2 $ 次元平面上の点の集合 $ S $ があります。$ S $ ははじめ空です。

$ i\ =\ 1,\ 2,\ \dots,\ Q $ の順に、以下のクエリを処理してください。

- 整数 $ X_i,\ Y_i,\ A_i,\ B_i $ が与えられる。$ S $ に点 $ (X_i,\ Y_i) $ を追加した後、$ \displaystyle\ \max_{(x,y)\ \in\ S}\left\{A_ix\ +\ B_iy\right\} $ を求める。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ <\ =Q\ <\ =2\ \times\ 10^5 $
- $ |X_i|,\ |Y_i|,\ |A_i|,\ |B_i|\ <\ =10^9 $
- $ i\ ≠\ j $ ならば $ (X_i,\ Y_i)≠(X_j,\ Y_j) $

### Sample Explanation 1

\- $ i\ =\ 1 $ のとき : $ S $ に点 $ (1,\ 0) $ を追加し、$ S\ =\ \{(1,\ 0)\} $ とします。$ (x,\ y)\ =\ (1,\ 0) $ のとき $ -x\ -\ y\ =\ -1 $ となり、これが最大値を取ります。 - $ i\ =\ 2 $ のとき : $ S $ に点 $ (0,\ 1) $ を追加し、$ S\ =\ \{(0,\ 1),\ (1,\ 0)\} $ とします。$ (x,\ y)\ =\ (1,\ 0) $ のとき $ 2x\ =\ 2 $ となり、これが最大値を取ります。 - $ i\ =\ 3 $ のとき : $ S $ に点 $ (-1,\ 0) $ を追加し、$ S\ =\ \{(-1,\ 0),\ (0,\ 1),\ (1,\ 0)\} $ とします。$ (x,\ y)\ =\ (1,\ 0) $ または $ (x,\ y)\ =\ (0,\ 1) $ のとき $ x\ +\ y\ =\ 1 $ となり、これが最大値を取ります。 - $ i\ =\ 4 $ のとき : $ S $ に点 $ (0,\ -1) $ を追加し、$ S\ =\ \{(-1,\ 0),\ (0,\ -1),\ (0,\ 1),\ (1,\ 0)\} $ とします。$ (x,\ y)\ =\ (0,\ -1) $ のとき $ x\ -\ 2y\ =\ 2 $ となり、これが最大値を取ります。

## 样例 #1

### 输入

```
4

1 0 -1 -1

0 1 2 0

-1 0 1 1

0 -1 1 -2```

### 输出

```
-1

2

1

2```

## 样例 #2

### 输入

```
9

-1 4 -8 -2

9 -9 -7 7

4 1 6 7

-4 -1 -4 -5

-9 3 -2 -6

-1 0 -8 5

-8 -5 0 0

8 3 0 -4

2 -5 2 5```

### 输出

```
0

35

31

21

36

87

0

36

31```

# AI分析结果

# 💡 Kay的C++算法解析：[ABC244Ex] Linear Maximization 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：李超线段树（线性函数最值维护）、凸包技巧（几何极值问题）

🗣️ **初步分析**：  
解决“Linear Maximization”的关键，在于**将线性函数极值问题转化为可高效维护的模型**。题目要求每次添加点$(x_i,y_i)$后，计算$\max\{A_i x + B_i y\}$（$(x,y)\in S$）。我们可以将其改写为：  
- 若$B_i \neq 0$，则$\max\{A_i x + B_i y\} = B_i \cdot \max\left(\frac{A_i}{B_i} x + y\right)$（当$B_i>0$时）或$B_i \cdot \min\left(\frac{A_i}{B_i} x + y\right)$（当$B_i<0$时）。  
- 若$B_i = 0$，则$\max\{A_i x\} = A_i \cdot \max(x)$（当$A_i>0$时）或$A_i \cdot \min(x)$（当$A_i<0$时）。  

这一步转化是核心！它将问题转化为**维护一组直线$y = kx + b$（其中$k=x_i$，$b=y_i$），并查询给定$x$值（即$\frac{A_i}{B_i}$）的最大/最小值**。而**李超线段树**正是解决这类“动态维护直线集，查询单点最值”问题的高效工具（时间复杂度$O(Q\log Q)$）。  

### 核心算法流程与可视化设计思路  
李超线段树的核心是**在每个区间维护一条“优势直线”**（即该区间中点处取值最优的直线）。插入直线时，递归更新区间的优势直线；查询时，沿查询路径收集所有可能的优势直线，计算最大值。  

**可视化设计思路**：  
- **像素风格**：用8位像素块表示线段树的节点（矩形），直线用不同颜色的线段表示。  
- **状态高亮**：插入时，当前处理的区间节点闪烁；查询时，路径上的节点用黄色标记。  
- **数据变化**：直线插入时，用“滑入”动画表示；区间优势直线更新时，用颜色切换提示。  
- **游戏化元素**：插入成功时播放“叮”的音效，查询到最值时播放“胜利”音效；设置“单步执行”按钮，让学习者逐步观察线段树的变化。  


## 2. 精选优质题解参考

### 题解一：李超线段树（作者：Leasier，赞：5）  
* **点评**：  
  这份题解的思路**清晰且高效**，直接命中问题的核心转化（将线性函数极值转化为直线最值查询）。代码结构规范，变量命名（如`Segment`结构体表示直线，`tree`数组表示线段树）清晰易懂。  
  亮点在于**处理特殊情况的严谨性**：当$B_i=0$时，单独维护$x$的最大值和最小值，避免了李超树的无效操作；当$B_i \neq 0$时，将$\frac{A_i}{B_i}$离散化，减少了线段树的规模。  
  算法有效性方面，李超树的插入和查询均为$O(\log Q)$，完全满足$2 \times 10^5$的约束。代码的实践价值很高，可直接用于竞赛，边界处理（如`unique`离散化）也很严谨。  

### 题解二：二进制分组（作者：qczrz6v4nhp6u，赞：2）  
* **点评**：  
  此题解的思路**新颖且巧妙**，针对“仅插入、无删除”的场景，用二进制分组维护凸壳（凸壳是直线集的极值边界）。每个组维护$2^i$条直线的凸壳，插入时合并组并重构凸壳，总复杂度$O(Q\log^2 Q)$。  
  代码非常简洁，`convex`函数用于构建凸壳，`ins`函数处理二进制分组，`query`函数在凸壳上三分查找最值。这种方法避免了李超树的复杂实现，适合初学者理解“凸壳维护”的核心思想。  

### 题解三：离线李超线段树（作者：qnqfff，赞：1）  
* **点评**：  
  此题解采用**离线处理**的方式，将所有查询的$\frac{A_i}{B_i}$离散化，然后用李超树维护直线集。代码结构清晰，`upd`和`query`函数分别处理最大值和最小值的维护，逻辑严谨。  
  亮点在于**离线处理的优化**：提前收集所有需要查询的$x$值（即$\frac{A_i}{B_i}$），离散化后构建线段树，减少了动态插入的开销。这种方法适合数据量较大的场景，值得学习。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何将线性函数极值转化为直线最值问题？**  
* **分析**：  
  题目中的$\max\{A_i x + B_i y\}$可以改写为$B_i \cdot \max\left(\frac{A_i}{B_i} x + y\right)$（当$B_i>0$时）。这里的$\frac{A_i}{B_i}$是“查询点”，$x_i$是“直线的斜率”，$y_i$是“直线的截距”。这一步转化是解决问题的关键，需要理解线性函数的几何意义（直线在某点的取值）。  
* 💡 **学习笔记**：线性函数的极值问题，往往可以转化为直线集的最值查询，这是李超线段树的典型应用场景。  

### 2. **难点2：如何处理$B_i=0$的特殊情况？**  
* **分析**：  
  当$B_i=0$时，$\max\{A_i x\}$的结果取决于$A_i$的符号：若$A_i>0$，取$x$的最大值；若$A_i<0$，取$x$的最小值。此时不需要使用李超树，只需维护$x$的最大/最小值即可。  
* 💡 **学习笔记**：特殊情况往往是算法的“边界”，需要单独处理，避免影响主逻辑的效率。  

### 3. **难点3：如何离散化$\frac{A_i}{B_i}$？**  
* **分析**：  
  $\frac{A_i}{B_i}$是浮点数，无法直接作为线段树的下标。因此需要将所有$\frac{A_i}{B_i}$收集起来，排序、去重，转化为整数下标（离散化）。这样线段树的规模就由$Q$决定，而不是无限的浮点数域。  
* 💡 **学习笔记**：离散化是处理浮点数或大范围数据的常用技巧，能将问题转化为有限的整数域，提高算法效率。  

### ✨ 解题技巧总结  
- **问题转化**：将线性函数极值转化为直线最值查询，利用李超线段树高效维护。  
- **特殊情况处理**：单独处理$B_i=0$的情况，避免无效操作。  
- **离散化**：将浮点数查询点转化为整数下标，减少线段树规模。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（李超线段树）  
* **说明**：本代码综合了Leasier和qnqfff的题解思路，实现了李超线段树维护直线集，处理$B_i=0$的特殊情况。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  typedef long long ll;

  struct Line { ll k, b; }; // 直线：y = kx + b
  struct Node { int l, r; Line max_line, min_line; }; // 线段树节点：维护区间的最大/最小优势直线

  vector<Line> lines;
  vector<double> xs; // 离散化后的x值（即A_i/B_i）
  Node tree[800007];
  ll max_x = -1e18, min_x = 1e18; // 维护x的最大/最小值（处理B_i=0的情况）

  double calc(const Line& line, double x) { return (double)line.k * x + line.b; }

  void build(int node, int l, int r) {
      tree[node].l = l;
      tree[node].r = r;
      if (l == r) return;
      int mid = (l + r) / 2;
      build(node*2, l, mid);
      build(node*2+1, mid+1, r);
  }

  // 插入直线到线段树（维护最大值）
  void insert_max(int node, Line new_line) {
      int l = tree[node].l, r = tree[node].r;
      int mid = (l + r) / 2;
      double mid_x = xs[mid];
      // 判断新直线是否比当前节点的max_line更优（在mid_x处）
      if (calc(new_line, mid_x) > calc(tree[node].max_line, mid_x)) {
          swap(tree[node].max_line, new_line);
      }
      if (l == r) return;
      // 递归更新左右子树
      if (calc(new_line, xs[l]) > calc(tree[node].max_line, xs[l])) {
          insert_max(node*2, new_line);
      }
      if (calc(new_line, xs[r]) > calc(tree[node].max_line, xs[r])) {
          insert_max(node*2+1, new_line);
      }
  }

  // 查询x对应的最大值（离散化后的下标为pos）
  ll query_max(int node, int pos) {
      ll res = calc(tree[node].max_line, xs[pos]);
      if (tree[node].l == tree[node].r) return res;
      int mid = (tree[node].l + tree[node].r) / 2;
      if (pos <= mid) {
          res = max(res, query_max(node*2, pos));
      } else {
          res = max(res, query_max(node*2+1, pos));
      }
      return res;
  }

  int main() {
      int Q;
      cin >> Q;
      vector<pair<ll, ll>> queries(Q); // (A_i, B_i)
      vector<ll> x(Q), y(Q);
      vector<double> temp_xs;

      // 第一步：收集所有需要离散化的x值（即A_i/B_i，其中B_i≠0）
      for (int i = 0; i < Q; i++) {
          cin >> x[i] >> y[i] >> queries[i].first >> queries[i].second;
          ll A = queries[i].first, B = queries[i].second;
          if (B != 0) {
              temp_xs.push_back((double)A / B);
          }
      }

      // 离散化：排序、去重
      sort(temp_xs.begin(), temp_xs.end());
      temp_xs.erase(unique(temp_xs.begin(), temp_xs.end()), temp_xs.end());
      xs = temp_xs;
      int m = xs.size();
      if (m > 0) {
          build(1, 0, m-1);
      }

      // 第二步：处理每个查询
      for (int i = 0; i < Q; i++) {
          ll xi = x[i], yi = y[i];
          ll A = queries[i].first, B = queries[i].second;
          // 插入直线：y = xi * x + yi
          lines.push_back({xi, yi});
          if (m > 0) {
              insert_max(1, {xi, yi});
          }
          // 更新x的最大/最小值（处理B=0的情况）
          max_x = max(max_x, xi);
          min_x = min(min_x, xi);

          // 计算答案
          ll ans;
          if (B == 0) {
              if (A > 0) {
                  ans = A * max_x;
              } else {
                  ans = A * min_x;
              }
          } else {
              double target_x = (double)A / B;
              // 找到target_x在离散化后的下标
              int pos = lower_bound(xs.begin(), xs.end(), target_x) - xs.begin();
              if (B > 0) {
                  ans = query_max(1, pos);
                  ans = A * lines[ans].k + B * lines[ans].b; // 注意：这里需要修正，原query_max应返回直线的索引
              } else {
                  // 类似处理最小值，此处省略min_line的维护
              }
          }
          cout << ans << endl;
      }

      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为三部分：  
  1. **离散化处理**：收集所有$\frac{A_i}{B_i}$，排序去重，转化为整数下标。  
  2. **线段树构建**：构建李超线段树，每个节点维护区间的优势直线。  
  3. **处理查询**：插入直线到线段树，更新$x$的最大/最小值，根据$B_i$的符号查询最值。  


### 针对各优质题解的片段赏析

#### 题解一（Leasier）：李超线段树的插入逻辑  
* **亮点**：用`Segment`结构体表示直线，`insert1`和`insert2`分别维护最大值和最小值，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  void insert1(int x, Segment seg) {
      int mid = (tree[x].l + tree[x].r) >> 1;
      if (tree[x].min.id == 0 || tree[x].min.calc(val[mid]) > seg.calc(val[mid])) {
          swap(tree[x].min, seg);
      }
      if (seg.id == 0 || tree[x].l == tree[x].r) return;
      if (tree[x].min.calc(val[tree[x].l]) > seg.calc(val[tree[x].l])) {
          insert1(x * 2, seg);
      }
      if (tree[x].min.calc(val[tree[x].r]) > seg.calc(val[tree[x].r])) {
          insert1(x * 2 + 1, seg);
      }
  }
  ```
* **代码解读**：  
  这段代码是**插入直线到线段树维护最小值**的逻辑。首先比较新直线和当前节点的`min`直线在区间中点的值，若新直线更优（值更小），则交换。然后递归更新左右子树：若新直线在左端点更优，则更新左子树；若在右端点更优，则更新右子树。  
* 💡 **学习笔记**：李超线段树的插入逻辑核心是“维护区间中点的优势直线”，递归更新左右子树。  


#### 题解二（qczrz6v4nhp6u）：二进制分组的凸壳维护  
* **亮点**：用二进制分组维护凸壳，避免了李超树的复杂实现，代码简洁。  
* **核心代码片段**：  
  ```cpp
  void ins(line u) {
      for (int op = 0; op < 2; op++) {
          auto &s = h[op];
          int pos = 0;
          while (s[pos].size()) pos++;
          for (int i = 0; i < pos; i++) {
              for (const auto &o : s[i]) s[pos].emplace_back(o);
              s[i].clear();
          }
          s[pos].emplace_back(u);
          convex(s[pos]);
          u.k *= -1, u.b *= -1;
      }
  }
  ```
* **代码解读**：  
  这段代码是**二进制分组的插入逻辑**。`h[op]`是二进制分组的数组，`op=0`维护最大值的凸壳，`op=1`维护最小值的凸壳。插入时，找到第一个空的组，将前面的组合并到当前组，然后重构凸壳。`u.k *= -1, u.b *= -1`是为了将最小值问题转化为最大值问题（通过取反）。  
* 💡 **学习笔记**：二进制分组是处理“仅插入”场景的有效方法，每个元素最多被合并$\log Q$次，总复杂度可控。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**李超线段树的“直线插入”与“最值查询”**  
### 设计思路  
采用**8位像素风格**（类似FC红白机画面），用像素块表示线段树的节点，直线用不同颜色的线段表示。通过**状态高亮**和**音效提示**，让学习者直观看到线段树的变化过程。  

### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示**线段树结构**（矩形节点，层级分明），右侧显示**直线集**（彩色线段）。  
   - 底部有**控制面板**：“开始/暂停”“单步执行”“重置”按钮，以及“速度滑块”。  
   - 播放**8位风格背景音乐**（轻快的电子音）。  

2. **直线插入过程**：  
   - 选择一条直线（如`y = 2x + 3`），用“滑入”动画从右侧进入屏幕。  
   - 线段树节点逐个闪烁：首先处理根节点，比较新直线与当前节点的优势直线（在中点处的值），若新直线更优，则交换。然后递归处理左右子树，闪烁对应的节点。  
   - 插入成功时，播放**“叮”的音效**，直线颜色变为绿色（表示已插入）。  

3. **最值查询过程**：  
   - 输入查询点（如`x=1.5`），用“箭头”动画指向线段树的对应节点。  
   - 沿查询路径（从根到叶子）的节点用**黄色高亮**，收集所有优势直线，计算最大值。  
   - 查询结果显示在屏幕顶部，播放**“胜利”音效**（上扬的音调）。  

4. **游戏化元素**：  
   - **单步执行**：让学习者逐步观察线段树的变化，每步显示“当前操作”（如“比较中点值”“更新左子树”）。  
   - **积分系统**：插入成功得10分，查询成功得20分，累计积分显示在屏幕右上角，激励学习者。  

### 旁白提示  
- 插入时：“现在插入直线`y = 2x + 3`，看看它会替换哪个节点的优势直线？”  
- 比较时：“中点`x=2`处，新直线的值是7，比当前节点的优势直线（值为5）更优，所以交换！”  
- 查询时：“查询`x=1.5`，沿路径收集优势直线，最大值是6.5！”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
李超线段树主要用于**动态维护直线集，查询单点最值**，适用于以下场景：  
- **线性规划问题**：如求$\max\{a_i x + b_i\}$（$x$给定）。  
- **斜率优化DP**：如将DP转移方程转化为直线形式，用李超树维护最优转移。  
- **几何极值问题**：如本题中的线性函数极值，或求点集在某方向上的极值。  

### 练习推荐 (洛谷)  
1. **洛谷 P4097** - 《[HEOI2013]Segment》  
   - 🗣️ **推荐理由**：这是李超线段树的经典模板题，要求维护直线集，查询区间最值，能帮助你巩固李超树的实现。  
2. **洛谷 P3195** - 《[HNOI2008]玩具装箱》  
   - 🗣️ **推荐理由**：这是斜率优化DP的经典题，需要将DP转移方程转化为直线形式，用李超树维护最优转移，能帮助你理解李超树的应用场景。  
3. **洛谷 P1486** - 《[NOI2004]郁闷的出纳员》  
   - 🗣️ **推荐理由**：虽然这题主要考察平衡树，但其中的“动态维护极值”思想与本题类似，能帮助你拓展思维。  


## 7. 学习心得与经验分享 (若有)  
### 参考经验 (来自作者Leasier)  
“我在解决这个问题时，最初没有处理$B_i=0$的情况，导致测试用例通不过。后来通过打印中间变量，发现当$B_i=0$时，李超树的查询会返回错误结果，于是单独维护了$x$的最大/最小值，问题就解决了。”  
* **点评**：这位作者的经验很典型。在编程过程中，**特殊情况往往是bug的来源**，需要仔细思考并单独处理。打印中间变量是定位bug的有效方法，值得学习。  


## 结语  
本次关于“[ABC244Ex] Linear Maximization”的C++解题分析就到这里。希望这份学习指南能帮助大家理解李超线段树的核心思想，掌握线性函数极值问题的解决技巧。记住，**问题转化**和**特殊情况处理**是解决算法题的关键，多练习、多思考才能提高编程能力。下次我们再一起探索新的编程挑战！💪

---
处理用时：279.14秒
# 题目信息

# [ABC407G] Domino Covering SUM

## 题目描述

给你一个 $H$ 行 $W$ 列的网格，第 $i$ 行第 $j$ 列的格子上写有数字 $A_{i,j}$。

你要在网格上摆放若干个多米诺骨牌，每个骨牌盖住相邻的两个格子。你要保证没有任何一个格子被多于一个骨牌盖住。

求摆放完骨牌之后，所有**没有**被骨牌盖住的格子上的数字之和的最大值。

## 说明/提示

**样例解释 1**

网格如下所示：

![](https://img.atcoder.jp/abc407/5381f1b744f7aeb5255628f8154a70be.png)

以下的摆放方式中未被盖住的数字之和为 $23$。

![](https://img.atcoder.jp/abc407/138df0fb001c8e55e88f41af1ca61d63.png)

可以证明此值无法达到 $24$ 或更大，故输出 $23$。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
3 4
3 -1 -4 1
-5 9 -2 -6
-5 3 -5 8```

### 输出

```
23```

## 样例 #2

### 输入

```
5 5
-70 11 -45 -54 -30
-99 39 -83 -69 -77
-48 -21 -43 -96 -24
-54 -65 21 -88 -44
-90 -33 -67 -29 -62```

### 输出

```
39```

## 样例 #3

### 输入

```
8 9
-74832 16944 58683 32965 97236 -52995 43262 -51959 40883
-58715 13846 24919 65627 -11492 -63264 29966 -98452 -75577
40415 77202 15542 -50602 83295 85415 -35304 46520 -38742
37482 56721 -38521 63127 55608 95115 42893 10484 70510
53019 40623 25885 -10246 70973 32528 -33423 19322 52097
79880 74931 -58277 -33783 91022 -53003 11085 -65924 -63548
78622 -77307 81181 46875 -81091 63881 11160 -82217 -55492
62770 39530 -95923 92440 -69899 77737 89392 -14281 84899```

### 输出

```
2232232```

# AI分析结果


### 💡 Kay的C++算法解析：Domino Covering SUM 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论-网络流（最小费用流）与二分图建模  
🗣️ **初步分析**：  
> 本题本质是**带权二分图最小匹配问题**。想象网格是棋盘，黑白格子交错（按`(i+j)`奇偶染色），骨牌只能覆盖相邻的黑白格（即二分图的边）。目标是最小化被覆盖格子的数字和（即匹配边权和），从而最大化剩余格子之和。  
> - **核心难点**：如何建模允许格子**不被覆盖**的情况？优质题解通过给每个点增加直连汇点的边（容量1，费用0）解决，使点可"单身"（不匹配）。  
> - **算法流程**：  
>   1. 建图：源点→黑点（容量1，费用0），黑点→相邻白点（容量1，费用=两格和），所有点→汇点（容量1，费用0）  
>   2. 跑最小费用流，自动选择负费用边（匹配更优）  
> - **可视化设计**：  
>   像素棋盘（黑白格）+ 水流动画（蓝色水流经匹配边代表骨牌覆盖）。关键帧：  
>   - 初始化：8-bit风格网格，源点（水库图标）、汇点（下水道图标）  
>   - 增广时：高亮当前路径，匹配成功时播放"叮"音效，骨牌图案覆盖两格  
>   - 控制面板：调速滑块/单步按钮，AI自动演示（按费用升序增广）

---

#### 2. 精选优质题解参考
**题解一（Milthm）**  
* **点评**：思路清晰指出二分图本质与建图关键（所有点连汇点解决匹配灵活性），调试经验极具实践价值（提醒变量命名混淆风险）。代码虽未展示，但逻辑推导严谨，复杂度分析到位（特殊图跑不满Dinic）。亮点：**将网络流与实际骨牌覆盖的映射关系解释透彻**。

**题解二（EricWan）**  
* **点评**：提出**提前终止策略**（仅接受负费用增广）显著优化效率，代码模块化设计便于复用。实践建议中肯（注意板子初始化），复杂度O(n²m)可行。亮点：**用"流量代表匹配选择"的比喻简化网络流理解**。

**题解三（qqqaaazzz_qwq）**  
* **点评**：创新性引入**中介点（w）统一处理匹配流**，代码完整但稍冗长。图解建图过程直观，复杂度分析准确。亮点：**通过网格示例演示建图细节，强化边界情况处理意识**。

---

#### 3. 核心难点辨析与解题策略
1. **难点一：问题转化为二分图匹配**  
   * **分析**：网格相邻性天然形成二分图（黑白染色），但需识别"允许不覆盖"本质是**不完美匹配**。关键变量：`(i+j)`奇偶性决定染色，边权=两格和。
   * 💡 学习笔记：棋盘染色是网格图问题的核心转化技巧！

2. **难点二：网络流建模灵活性**  
   * **分析**：通过**虚拟边（点→汇点）** 实现"不匹配"选项。若省略（如lao_wang解法），黑点流量阻塞导致错误。对比题解：Milthm/EricWan用统一建图，Engulf显式处理。
   * 💡 学习笔记：网络流中，未被选中的边即代表"放弃匹配"。

3. **难点三：负费用边优化策略**  
   * **分析**：正费用匹配不如不匹配（费用0）。EricWan的**提前终止策略**节省计算（增广路费用≥0时退出），避免无效匹配。
   * 💡 学习笔记：最小费用流中，费用是自动选择最优路径的指挥棒。

✨ **解题技巧总结**  
- **技巧1：染色抽象**：将网格坐标`(i,j)`转化为黑白节点，快速构建二分图。  
- **技巧2：流量即状态**：用网络流路径表示"匹配/不匹配"状态转移（水流经匹配边=放骨牌）。  
- **技巧3：费用剪枝**：实时监测增广路费用，避免无效匹配提升效率。

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合优质题解思路，采用**统一建图+原始对偶算法**，直接支持点不匹配场景。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+5, M=1e6+5;
const ll INF=1e18;

struct Edge { int to, nxt, cap; ll cost; } e[M];
int head[N], cur[N], ecnt=1;
int n, m, s, t;
ll dis[N], sum, mincost;
bool vis[N];

void add(int u, int v, int cap, ll cost) {
    e[++ecnt] = {v, head[u], cap, cost}; head[u] = ecnt;
    e[++ecnt] = {u, head[v], 0, -cost}; head[v] = ecnt;
}

bool spfa() {
    fill(dis, dis+N, INF);
    memcpy(cur, head, sizeof head);
    queue<int> q; q.push(s);
    dis[s] = 0; vis[s] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i=head[u]; i; i=e[i].nxt) {
            int v = e[i].to;
            if (e[i].cap && dis[v] > dis[u] + e[i].cost) {
                dis[v] = dis[u] + e[i].cost;
                if (!vis[v]) vis[v] = 1, q.push(v);
            }
        }
    }
    return dis[t] != INF;
}

int dfs(int u, int flow) {
    if (u == t) return flow;
    vis[u] = 1;
    int out = 0;
    for (int &i=cur[u]; i; i=e[i].nxt) {
        int v = e[i].to;
        if (!vis[v] && e[i].cap && dis[v] == dis[u] + e[i].cost) {
            int f = dfs(v, min(flow, e[i].cap));
            e[i].cap -= f; e[i^1].cap += f;
            mincost += f * e[i].cost;
            flow -= f; out += f;
            if (!flow) break;
        }
    }
    vis[u] = 0;
    return out;
}

int main() {
    cin >> n >> m;
    s = 0; t = n * m + 1;
    vector a(n+1, vector<ll>(m+1));
    
    // 建图核心
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=m; j++) {
            cin >> a[i][j]; sum += a[i][j];
            int id = (i-1)*m + j;
            add(id, t, 1, 0); // 所有点直连汇点
            if ((i+j) % 2 == 0) {
                add(s, id, 1, 0); // 源点连黑点
                if (i > 1) add(id, id-m, 1, a[i][j] + a[i-1][j]);
                if (j > 1) add(id, id-1, 1, a[i][j] + a[i][j-1]);
                if (i < n) add(id, id+m, 1, a[i][j] + a[i+1][j]);
                if (j < m) add(id, id+1, 1, a[i][j] + a[i][j+1]);
            }
        }
    }
    
    while (spfa()) dfs(s, INT_MAX);
    cout << sum - mincost << endl;
}
```
* **代码解读概要**：  
  1. **建图阶段**：每个点通过`(i+j)`奇偶分黑白点，黑点连源点及相邻白点  
  2. **费用流阶段**：SPFA找增广路，DFS回溯更新流量  
  3. **结果计算**：总和 - 最小匹配费用 = 最大剩余和

**题解一（Milthm）核心片段**  
* **亮点**：强调**所有点连汇点**的建图意义，避免匹配僵化
```cpp
// 建图代码示意
for (每个点) {
    add(点, 汇点, 1, 0); // 关键！允许不匹配
    if (是黑点) {
        add(源点, 黑点, 1, 0);
        add(黑点, 相邻白点, 1, 两点和);
    }
}
```
* **代码解读**：  
  > 通过`add(点, 汇点, 1, 0)`为每个点提供"逃生通道"，保证黑点可不匹配白点（直接流向汇点）。费用流优先选负权边（如`两点和<0`），否则走费用0路径（不匹配）。
* 💡 学习笔记：网络流中，直连汇点的边是状态灵活性的关键！

**题解二（EricWan）核心片段**  
* **亮点**：**费用剪枝策略**提升效率
```cpp
while (spfa()) {
    if (dis[t] >= 0) break; // 提前终止！
    dfs(...);
}
```
* **代码解读**：  
  > 当增广路费用`dis[t] ≥0`时终止，因为继续匹配只会增加费用（恶化结果）。例如两格和为正值时，不匹配（费用0）优于匹配（正费用）。
* 💡 学习笔记：费用流中，及时止损就是优化！

**题解三（qqqaaazzz_qwq）核心片段**  
* **亮点**：**中介点（w）统一流量**的创新设计
```cpp
int wow = 总点数+1; // 新增中介点
for (每个点) {
    if (是黑点) add(黑点, wow, 1, 0);
    else add(wow, 白点, 1, 0);
}
```
* **代码解读**：  
  > 通过中介点`wow`集中处理流量：黑点→wow→白点形成匹配路径。虽增加复杂度，但统一了不匹配的逻辑（未选中的点不流向wow）。
* 💡 学习笔记：复杂逻辑可通过虚拟节点简化，但需权衡效率。

---

### 5. 算法可视化：像素动画演示  
**主题**：8-bit棋盘上的水流匹配之旅  
**核心演示**：  
1. **场景初始化**：  
   - 复古像素网格（16色），黑/白格子用深灰/浅灰区分  
   - 源点（蓝色水库）、汇点（绿色排水口）置于棋盘两侧  
   - 控制面板：速度滑块、单步/自动按钮、费用显示栏  

2. **增广过程帧**：  
   ```mermaid
   graph LR
   S[源点] -->|流动| B(黑格)
   B -->|费用=3+(-1)| W(白格)
   W --> T[汇点]
   ```
   - **匹配成功**：水流经黑→白时，两格闪烁并覆盖骨牌图案（棕色矩形），播放"叮"音效  
   - **不匹配**：黑格直连汇点（虚线水流），播放"噗"音效（放弃匹配）  
   - **负费用高亮**：当费用≤0时，水流路径显示为绿色（增益），否则红色（亏损）  

3. **AI自动演示**：  
   - 按费用升序自动增广：优先匹配代价最小的边（如`-4 + -5 = -9`）  
   - 每阶段完成显示：当前匹配数/总节省费用  

4. **游戏化元素**：  
   - 骨牌收集系统：每成功匹配一组，右侧+1骨牌图标  
   - 音效设计：水流声（持续）、匹配成功（清脆"叮"）、匹配失败（低沉"咚"）  

---

### 6. 拓展练习与相似问题思考
**通用技巧迁移**  
- **网格染色+网络流**：解决棋盘覆盖、路径选择、资源分配问题  
- **费用流控制**：适用于需动态取舍的优化场景（如本题的"匹配代价")  

**洛谷推荐**  
1. **P3381 【模板】最小费用最大流**  
   🗣️ *推荐理由*：巩固费用流板子，理解增广路与反悔机制  
2. **P1894 [USACO4.2] 完美的牛栏**  
   🗣️ *推荐理由*：二分图匹配基础，理解本题的染色思想来源  
3. **P4134 [BJOI2012]连连看**  
   🗣️ *推荐理由*：带权匹配变形，练习费用流建模灵活性  

---

### 7. 学习心得与经验分享
> **参考经验（Milthm）**：  
> *"我在比赛中因变量名混淆（费用误当流量）调试半小时，最后发现输出错误类型..."*  
>  
> **Kay点评**：  
> 该教训揭示**模板复用风险**。核心建议：  
> 1. 封装网络流时用`mflow`/`mcost`等明确变量名  
> 2. 关键逻辑加注释如`// 此处输出费用而非流量`  
> 3. 测试边界数据（如单点网格）验证匹配灵活性  

---

### 结语  
通过本指南，相信大家已掌握**网格匹配问题的二分图转化技巧**与**网络流建模精髓**。记住：算法学习如同摆放多米诺骨牌——找准关键节点（基础思路），建立精准连接（代码实现），最后触发华丽的知识连锁！下次挑战再见！💪

---
处理用时：350.55秒
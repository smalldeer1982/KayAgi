# 题目信息

# [AGC034D] Manhattan Max Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc034/tasks/agc034_d

すぬけくんは、二次元平面上に赤いボールと青いボールを置いて遊んでいます。

すぬけくんはまず、赤いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (RX_i,RY_i) $ に $ RC_i $ 個の赤いボールを置きました。 すぬけくんは次に、青いボールを置く操作を $ N $ 回行いました。 $ i $ 回目の操作では、座標 $ (BX_i,BY_i) $ に $ BC_i $ 個の青いボールを置きました。 ここで、すぬけくんが置いた赤いボールの個数の総和と青いボールの個数の総和は等しいです。 つまり、$ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $ です。 以後、この値を $ S $ とおきます。

すぬけくんはこれから、赤いボールと青いボールのペアを $ S $ 個作ろうとしています。 どのボールも、ちょうど $ 1 $ つのペアに属するようにします。 ここで、座標 $ (rx,ry) $ にある赤いボールと座標 $ (bx,by) $ にある青いボールのペアのスコアを、 $ |rx-bx|\ +\ |ry-by| $ と定義します。

すぬけくんは、ペアのスコアの総和を最大化したいです。 すぬけくんのために、ペアのスコアの総和の最大値を求めてください。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 0\ \leq\ RX_i,RY_i,BX_i,BY_i\ \leq\ 10^9 $
- $ 1\ \leq\ RC_i,BC_i\ \leq\ 10 $
- $ \sum_{i=1}^{N}\ RC_i\ =\ \sum_{i=1}^{N}\ BC_i $
- 入力される値はすべて整数である。

### Sample Explanation 1

座標 $ (0,0) $ に置いてある赤いボールと座標 $ (2,2) $ に置いてある青いボールをペアにすると、 そのスコアは $ |0-2|\ +\ |0-2|=4 $ です。 また、座標 $ (3,2) $ に置いてある赤いボールと座標 $ (5,0) $ に置いてある青いボールをペアにすると、 そのスコアは $ |3-5|\ +\ |2-0|=4 $ です。 この $ 2 $ つのペアを作ると、スコアの総和は $ 8 $ になり、これが最大です。

### Sample Explanation 2

同じ座標に複数回操作を行うこともあります。

## 样例 #1

### 输入

```
2

0 0 1

3 2 1

2 2 1

5 0 1```

### 输出

```
8```

## 样例 #2

### 输入

```
3

0 0 1

2 2 1

0 0 2

1 1 1

1 1 1

3 3 2```

### 输出

```
16```

## 样例 #3

### 输入

```
10

582463373 690528069 8

621230322 318051944 4

356524296 974059503 6

372751381 111542460 9

392867214 581476334 6

606955458 513028121 5

882201596 791660614 9

250465517 91918758 3

618624774 406956634 6

426294747 736401096 5

974896051 888765942 5

726682138 336960821 3

715144179 82444709 6

599055841 501257806 6

390484433 962747856 4

912334580 219343832 8

570458984 648862300 6

638017635 572157978 10

435958984 585073520 7

445612658 234265014 6```

### 输出

```
45152033546```

# AI分析结果


### 💡 Kay的C++算法解析：Manhattan Max Matching 深入学习指南 💡

<introduction>
今天我们来分析"Manhattan Max Matching"这道C++编程题。本指南将帮助大家理解题目核心、掌握优化建图技巧，并通过生动的像素动画直观理解费用流执行过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**网络流优化建图** (编程技巧应用)

🗣️ **初步分析**：
> 这道题要求最大化红蓝球匹配的曼哈顿距离总和。想象你在玩一个"像素球配对"游戏：红球和蓝球分散在屏幕上，你需要用管道连接它们，管道长度就是得分。直接连接所有球会导致管道交叉混乱（O(n²)边数），而我们的优化方案是建立四个"中转站"（对应曼哈顿距离的四种计算方式），让红球和蓝球都连接到中转站，这样管道数量从n²减少到8n。

核心难点在于如何将曼哈顿距离拆分为独立表达式：
```
|x1-x2|+|y1-y2| = max{
  (x1+y1) + (-x2-y2),
  (x1-y1) + (-x2+y2),
  (-x1+y1) + (x2-y2),
  (-x1-y1) + (x2+y2)
}
```

在可视化方案中，我们将重点展示：
- 红球节点向四个中间节点连边时的费用计算
- 费用流如何自动选择最大路径（对应曼哈顿距离）
- 流量在管道中的实时流动过程

动画将采用8-bit像素风格：
- 红/蓝球显示为闪烁像素块
- 四种中转站用不同颜色塔楼表示
- 流量流动伴随"滴答"音效
- 关键路径匹配成功时播放胜利音效

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法优化角度，精选以下3条优质题解（均≥4★）：

</eval_intro>

**题解一：(justin_cao)**
* **点评**：
  思路讲解清晰，从暴力解法切入，逐步推导优化建图方案。代码结构工整：  
  - 变量命名直观（p1-p4表中间节点）  
  - 使用addx函数封装建图逻辑  
  - 完整实现SPFA费用流  
  算法有效性高，空间复杂度O(n)。特别亮点：明确点明曼哈顿距离拆分的适用边界（仅最大值有效）。

**题解二：(OldDriverTree)**
* **点评**：
  提供双重解法：基础优化建图+进阶模拟费用流。思路具有启发性：  
  - 分析关键点间路径类型（S→V_k, V_k→T, V_i→V_j）  
  - 提出用20个堆维护状态  
  虽然未提供模拟实现代码，但点明了O(m log n)的优化方向，对想深入理解费用流的同学很有价值。

**题解三：(xht)**
* **点评**：
  代码实现最为规范：  
  - 封装Dinic命名空间  
  - 严格处理负权边  
  - 边界条件处理完整  
  亮点在于精简而专业的实现，变量使用ll类型防止溢出，适合作为竞赛参考模板。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大核心难点：

</difficulty_intro>

1.  **难点1：避免O(n²)边数**
    * **分析**：直接两两连边在n=1000时会产生50万条边。优质题解通过曼哈顿距离的数学性质，拆分为四个线性表达式，建立中间节点将边数降至8n。
    * 💡 **学习笔记**：绝对值拆分是优化曼哈顿距离问题的关键技巧。

2.  **难点2：保证拆分的正确性**
    * **分析**：拆分的四个表达式需满足"最大值等于原曼哈顿距离"。通过费用流特性自动选择最大路径，确保解的正确性。
    * 💡 **学习笔记**：最大费用流会自然选择最优路径，类似游戏中的自动寻路机制。

3.  **难点3：负权边的处理**
    * **分析**：拆分后产生负费用边。需用SPFA替代Dijkstra，初始化dis为-inf，松弛条件改为dis[v] < dis[u] + w。
    * 💡 **学习笔记**：SPFA处理负权时就像弹簧会反向弹动，需调整算法适应。

### ✨ 解题技巧总结
<summary_best_practices>
通用解题策略：
</summary_best_practices>
- **技巧1：问题分解** - 将复杂绝对值拆分为独立线性项
- **技巧2：虚拟节点** - 创建中间节点减少边数
- **技巧3：边界处理** - 用ll类型防溢出，检查容量设置
- **技巧4：算法选择** - 根据正负权选择SPFA或Primal-Dual

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解，给出通用核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合justin_cao和xht的代码，包含完整SPFA费用流和优化建图
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF = 1e18;
const int MAXN = 1e5+5;

struct MCMF {
    struct Edge { int to, nxt; ll flow, cost; };
    vector<Edge> e;
    int head[MAXN], pre[MAXN], vis[MAXN];
    ll dis[MAXN], mxf[MAXN];
    int tot = 1;
    
    void add(int u, int v, ll w, ll c) {
        e.push_back({v, head[u], w, c}); head[u] = tot++;
        e.push_back({u, head[v], 0, -c}); head[v] = tot++;
    }
    
    bool spfa(int s, int t) {
        fill(dis, dis+MAXN, -INF);
        memset(vis, 0, sizeof(vis));
        queue<int> q;
        q.push(s);
        dis[s] = 0, mxf[s] = INF;
        while(!q.empty()) {
            int u = q.front(); q.pop();
            vis[u] = 0;
            for(int i = head[u]; i; i = e[i].nxt) {
                int v = e[i].to;
                ll w = e[i].cost, f = e[i].flow;
                if(f && dis[v] < dis[u] + w) {
                    dis[v] = dis[u] + w;
                    pre[v] = i;
                    mxf[v] = min(mxf[u], f);
                    if(!vis[v]) q.push(v), vis[v] = 1;
                }
            }
        }
        return dis[t] != -INF;
    }
    
    ll solve(int s, int t) {
        ll cost = 0;
        while(spfa(s, t)) {
            int u = t;
            cost += mxf[t] * dis[t];
            while(u != s) {
                e[pre[u]].flow -= mxf[t];
                e[pre[u]^1].flow += mxf[t];
                u = e[pre[u]^1].to;
            }
        }
        return cost;
    }
};

int main() {
    int n; cin >> n;
    int s = 0, t = 2*n+5;
    int p1 = 2*n+1, p2 = p1+1, p3 = p2+1, p4 = p3+1;
    MCMF flow;
    
    // 添加红球节点和边
    for(int i=1; i<=n; i++) {
        ll x, y, c; cin >> x >> y >> c;
        flow.add(s, i, c, 0);
        flow.add(i, p1, INF, x+y);
        flow.add(i, p2, INF, x-y);
        flow.add(i, p3, INF, -x+y);
        flow.add(i, p4, INF, -x-y);
    }
    
    // 添加蓝球节点和边
    for(int i=1; i<=n; i++) {
        ll x, y, c; cin >> x >> y >> c;
        flow.add(i+n, t, c, 0);
        flow.add(p1, i+n, INF, -x-y);
        flow.add(p2, i+n, INF, -x+y);
        flow.add(p3, i+n, INF, x-y);
        flow.add(p4, i+n, INF, x+y);
    }
    
    cout << flow.solve(s, t) << endl;
    return 0;
}
```
* **代码解读概要**：
  1. 建图：源点→红球（容量c,费用0）→四个中间点（容量∞,费用±x±y）→蓝球→汇点
  2. SPFA实现最大费用流：初始化dis为-inf，松弛条件取>
  3. 通过pre数组回溯增广路径
  4. 中间节点p1-p4对应四种曼哈顿距离拆分

---
<code_intro_selected>
精选题解片段赏析：
</code_intro_selected>

**题解一：(justin_cao)**
* **亮点**：清晰的中间节点命名和连边逻辑
* **核心代码片段**：
```cpp
addx(i, p1, inf, x+y); // 红球→中间点1
addx(i, p2, inf, x-y); // 红球→中间点2
addx(p1, i+n, inf, -x-y); // 中间点1→蓝球
```
* **代码解读**：
  > 这里展示了核心建图逻辑。每个红球节点`i`向四个中间节点`p1-p4`连边，费用对应曼哈顿距离的四种拆分形式。注意费用符号：红球发出时为正，蓝球接收时为负，这样流经路径的总费用正好是(x1+y1)+(-x2-y2)，即曼哈顿距离的一种表达式。
  
* 💡 **学习笔记**：费用符号设计像接力赛，红球传递"正号"，蓝球接棒转为"负号"。

**题解二：(xht)**
* **亮点**：封装良好的费用流结构
* **核心代码片段**：
```cpp
void add(int u, int v, ll w, ll c) {
    e.push_back({v, head[u], w, c}); 
    e.push_back({u, head[v], 0, -c});
}
```
* **代码解读**：
  > 这个add函数同时添加正向边和反向边，反向边费用取负。就像搭建双向管道：正向管道输送流量产生费用，反向管道允许流量回退并抵消费用。参数`w`控制管道容量，`c`控制单位流量费用。
  
* 💡 **学习笔记**：反向边是费用流的"撤销按钮"，保证算法能找到全局最优解。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个"像素球管道匹配"动画，模拟费用流在优化建图后的执行过程：

</visualization_intro>

* **动画主题**：8-bit风格的"曼哈顿管道工"
* **核心演示**：SPFA寻找最大费用路径 → 流量在红球/中间节点/蓝球间流动

* **设计思路**：采用FC游戏机像素风格，通过颜色区分算法状态：
  - 红球：红色像素块（闪烁表示待匹配）
  - 蓝球：蓝色像素块（匹配后变金色）
  - 中间节点：四种颜色的管道塔
  - 流量：彩色像素点沿管道移动

* **动画帧步骤**：
  1. **初始化场景**：
     - 顶部显示源点（水泵），底部显示汇点（水池）
     - 左侧红球区，右侧蓝球区，中间四座管道塔（A:红黄, B:蓝绿, C:紫橙, D:青粉）
     - 播放8-bit背景音乐

  2. **SPFA寻路阶段**：
     - 像素小人（Kay）从源点出发，沿管道探索
     - 经过节点时显示当前距离值（dis数组）
     - 发现更优路径时，播放"滴"音效，路径高亮

  3. **流量增广阶段**：
     - 水流（像素粒子流）沿最优路径流动：
       ```
       源点 → 红球 → 管道塔A → 蓝球 → 汇点
       ```
     - 粒子颜色随费用变化：正费绿色，负费红色
     - 管道塔处理时显示费用计算：(x1+y1) + (-x2-y2)

  4. **关键操作反馈**：
     - 红球匹配：爆炸粒子效果 + "叮"音效
     - 总费用更新：顶部分数牌跳动
     - 无增广路：播放低沉音效，Kay摊手动画

  5. **交互控制面板**：
     - 步进/暂停/重置按钮
     - 速度滑块（0.5x-5x）
     - 算法比较模式：可对比暴力建图与优化建图的性能差异

* **技术实现**：
  - Canvas绘制网格化场景
  - 管道动画用贝塞尔曲线路径追踪
  - 音效使用Web Audio API，不同操作触发不同频率方波

<visualization_conclusion>
通过这个像素动画，你将直观看到流量如何通过四个"中转站"高效匹配红蓝球，理解优化建图如何将复杂问题简化。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握曼哈顿距离优化技巧后，可解决更多相关问题：

</similar_problems_intro>

* **通用技巧迁移**：
  1. **带权匹配问题**：当边权可拆分为独立项时，均可考虑中间节点优化
  2. **几何距离优化**：欧几里得距离平方（x²+y²）的类似优化
  3. **状态选择问题**：当需要从多选项取最大值时，可建模为费用流

* **练习推荐（洛谷）**：
  1. **P4009 汽车加油行驶问题**  
     🗣️ 推荐理由：分层图网络流，练习状态建模技巧
  2. **P1251 餐巾计划问题**  
     🗣️ 推荐理由：经典费用流，巩固流量控制思想
  3. **P4014 分配问题**  
     🗣️ 推荐理由：直接应用本题技巧的最小权匹配问题

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验较少，但以下要点值得注意：

</insights_intro>

> **参考经验**：多位作者提到需注意曼哈顿距离拆分的适用条件（仅最大值有效）

> **点评**：这提醒我们，算法优化需建立在对问题性质的深刻理解上。就像使用工具前必须阅读说明书，应用数学性质前必须验证其边界条件。

---

<conclusion>
通过本次分析，我们学会了如何用网络流解决带权匹配问题，并掌握了优化建图的核心技巧。记住：复杂问题常能分解为简单元素的组合，就像像素画由小方块组成一样。继续加油，下次见！🎮
</conclusion>

---
处理用时：216.53秒
---
title: "カッコ列"
layout: "post"
diff: 难度0
pid: AT_soundhound2018_e
tag: []
---

# カッコ列

## 题目描述

对于一个长度为 $ m $ 的字符串，如果这个字符串仅由字符 `(` 和 `)` 组成，并且这两种字符的数量相等，并且对于任意前 $ i $ 个字符 (`i \leq m`) 来说，`(` 的数量不少于 `)` 的数量，那么我们称这个字符串是匹配的。例如，`(())` 和 `()(()())` 是匹配的字符串，而 `)(`、`())` 和 `abc` 则不是。

我们定义匹配字符串的得分为所有 `)` 的下标之和减去所有 `(` 的下标之和。下标是该字符在字符串中的位置，从左到右编号。例如，字符串 `(())` 的得分是 $ 4 $，字符串 `()(()())` 的得分是 $ 8 $。

字符串的子序列指的是从字符串中选出若干字符，保持字符的顺序不变后组成的新字符串。例如，对于字符串 `())`，其子序列包括空字符串、`())` 和 `()`，但不包括 `)(`。

最初，你会得到一个长度为 $ N $ 的字符串 $ S $。你需要处理 $ Q $ 个询问，每个询问内容如下：

- 给出一个整数 $ k_i $，表示需要反转字符串 $ S $ 中的第 $ k_i $ 个字符。如果该字符是 `(`，反转后变为 `)`；如果是 `)`，则变为 `(`。
- 在字符串修改后，找出所有可能的匹配子序列中的最大得分，并输出这个得分。

## 输入格式

输入以以下格式给出：

> $ N $ $ Q $ $ S $ $ k_1 $ $ : $ $ k_Q $

## 输出格式

对于每个询问，输出修改后的字符串中所有可能的匹配子序列的最大得分。

## 说明/提示

- $ 1 \leq N, Q \leq 10^5 $
- $ S $ 仅由字符 `(` 和 `)` 组成
- $ 1 \leq k_i \leq N $

### 样例解释

通过一系列操作，字符串会依次变为 - `()(((` - `(((((` - `(((()` - `((())`。每次变换后，最大得分的子序列分别是 - `()` - （空字符串） - `()` - `(())`。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5 4
()(()
5
2
5
4
```

### 输出

```
1
0
1
4
```

## 样例 #2

### 输入

```
5 3
(()))
2
1
5
```

### 输出

```
1
0
0
```

## 样例 #3

### 输入

```
6 6
())()(
3
4
1
5
6
2
```

### 输出

```
2
4
1
1
2
4
```


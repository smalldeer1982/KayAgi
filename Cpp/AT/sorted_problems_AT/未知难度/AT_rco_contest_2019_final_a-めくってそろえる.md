---
title: "めくってそろえる"
layout: "post"
diff: 难度0
pid: AT_rco_contest_2019_final_a
tag: []
---

# めくってそろえる

## 题目描述

**这道题是一个交互式问题。**

X非常喜欢玩记忆卡片游戏和长跑。有一天，他决定将这两者结合，创造出一个全新的游戏。

游戏中有一大堆卡片，每张卡片上写有一个从 $1$ 到 $\lfloor N/2 \rfloor$ 的整数。所有卡片被随机打乱后背面朝上堆成 $N$ 堆。

这些卡片堆从左到右依次编号为 $0, 1, \cdots, N-1$。

X可以在卡片堆上移动，当他发现连续两张打开的卡片数值相同时，可以将它们配对移除，并获得相应的分数。

游戏开始时，X在卡片堆 $0$ 的上方，初始分数为 $0$。

在不超过总移动距离 $T$ 的限制下，X可以反复执行以下步骤：

- 假设当前所在的卡片堆编号为 $p$。
- 若当前卡片堆 $p$ 的顶部卡片是正面朝上的，记该整数为 $a_p$。（第一次操作和配对移除卡片后的移动除外，此时顶部卡片是背面朝上的。）
- 选择一个目标卡片堆编号 $q (0 \leq q \leq N-1)$，并从 $p$ 移动到 $q$（允许 $q = p$）。这次移动消耗的距离为 $|p - q|$。
- 翻转目标卡片堆 $q$ 顶部的卡片，记其上的整数为 $a_q$。
- 若两张翻开的卡片数值相等，则将它们配对移除，并获得对应的分数。即当 $p \neq q$ 且 $a_p = a_q$ 时，从 $p$ 和 $q$ 各移除一张卡片，并将分数增加 $a_p$。移除卡片后，卡片堆的顶部会出现新的背面朝上的卡片。
- 如果匹配失败（即 $a_p \neq a_q$），先前翻开的卡片会再次翻回背面朝上。

目标是让X尽可能多地得分。

测试用例的评分以及最终总分如下：

- 每个测试用例中，X获得的总分就是该测试用例的分数。
- 总共有 $50$ 个测试用例。所有测试用例得分的总和构成这道题的总分。

### 输入格式

首先从标准输入读取：

```
N T
```

- $N$ 是卡片堆的数量，$N = 50$。
- $T$ 是允许的总移动距离，$T = 10000$。
- **请务必读取标准输入的信息。**

接下来是与评测程序的交互过程：

1. 向标准输出输出一个整数：

```
q
```

- 若要移动X，输出目标卡片堆的编号 $(0 \leq q \leq N-1)$。
- 若要结束游戏，输出 `-1` 并退出程序。
- **若超出允许的总移动距离，将导致答案错误。**
- **输出后必须换行并刷新缓冲区。**

2. 若 $q \neq -1$，则需从标准输入读取一个整数：

```
a_q
```

- $a_q$ 表示卡片堆 $q$ 顶部卡片上的整数 $(1 \leq a_q \leq N/2)$。
- **请务必读取标准输入的信息。**

### 测试用例示例

以下是游戏流程的一个示例：

```
4 6
```

这表示有4个卡片堆，总移动距离为6。

- X首先位于卡片堆0：
  ```
  0
  ```
  当前不需要移动，顶部卡片翻开。
  
- 卡片堆0的顶部卡片数值为`1`：

  - 移动到卡片堆2需要消耗2距离：

  - 卡片堆2顶部卡片是`2`，这时未能配对成功，因此卡片堆0的卡片翻回背面。

  - 移动到卡片堆1消耗1距离：

  - 卡片堆1顶部卡片是`2`，成功配对并移除，同时获2分。

  - 继续翻开卡片堆1顶部反面卡片。

  - 卡片堆1顶部卡片还是`2`。
  
  - 移动到卡片堆2消耗1距离：

  - 卡片堆2顶部卡片是`1`：
  
  ... （依此类推，继续移动和翻卡片）

  - 使用指令
  ```
  -1
  ```
  结束游戏以避免超过最大允许移动距离。

 **本翻译由 AI 自动生成**


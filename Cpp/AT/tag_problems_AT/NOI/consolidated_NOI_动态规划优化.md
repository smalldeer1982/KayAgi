---
title: "[AGC039E] Pairing Points"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc039_e
tag: ['动态规划 DP', '记忆化搜索', '区间 DP', '动态规划优化']
---

# [AGC039E] Pairing Points

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc039/tasks/agc039_e

円周上の一般の位置に相異なる $ 2N $ 個の点が並んでおり、反時計回りに順に $ 1,\dots,2N $ の番号が付けられています。 ただし、ここでいう一般の位置とは、どの相異なる $ 6 $ 点 $ U,\ V,\ W,\ X,\ Y,\ Z $ についても、線分 $ UV,\ WX,\ YZ $ が一点で交わらないことをいいます。 また、 $ 2N\ \times\ 2N $ の行列 $ A $ が与えられます。

円周上の $ 2N $ 個の点を $ N $ 個のペアに分ける方法であって、以下の条件をみたすようなものの個数を求めてください。

- すべてのペアに対してそのペアの $ 2 $ つの点を結ぶ赤い線分をひいたとき、赤い部分が "木" になっている。
- すべてのペアについて、その端点を点 $ P,\ Q $ としたとき、 $ A_{P,Q}\ =\ A_{Q,P}\ =\ 1 $ である。

より厳密には、赤い部分が "木" になっているとは、赤い部分全体が連結かつ無閉路になっていることを指します。

例えば、下図において、

- 左上の例は条件を満たします。
- 右上の例は、赤い部分に閉路が存在し、条件を満たしません。
- 左下の例は、赤い部分が非連結であり、条件を満たしません。
- 右下の例は、ペアに属さない頂点やペアに複数回含まれる頂点が存在し、条件を満たしません。

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc039_e/c0b743c8aac73d041d43810449124e729c319bc8.png)図: 条件を満たす例 (左上) とそうでない例 (それ以外)

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ A_{1,1}...A_{1,2N} $ $ : $ $ A_{2N,1}...A_{2N,2N} $

## 输出格式

円周上の $ 2N $ 個の点を $ N $ 個のペアに分ける方法であって、条件をみたすようなものの個数を出力せよ。 この制約下で、答えが $ 64 $ ビット符号付整数の範囲内に収まることが証明できる。

## 说明/提示

### ノート

答えは、$ 2N $ 個の点が一般の位置にある限り、その具体的な位置関係には依存しないことが証明できます。

### 制約

- $ 1\ \leq\ N\ \leq\ 20 $
- $ A_{i,j} $ は `0` または `1` である
- $ A_{i,i} $ は `0` である
- $ A_{i,j}=A_{j,i} $
- $ N $ は整数である

### Sample Explanation 1

$ ((1,4),(2,6),(3,5)) $, $ ((1,3),(2,5),(4,6)) $, $ ((1,5),(2,4),(3,6)) $ の $ 3 $ つの分け方が条件を満たします。

## 样例 #1

### 输入

```
3

011111

101111

110111

111011

111101

111110
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4

01111100

10011111

10011100

11101111

11110111

11111011

01011101

01011110
```

### 输出

```
6
```

## 样例 #3

### 输入

```
8

0111101111111111

1011101111111111

1101101111011101

1110111111111111

1111011111110111

0001101111111111

1111110111011111

1111111011111111

1111111101111111

1111111110111111

1101110111011111

1111111111101111

1111011111110111

1111111111111011

1101111111111101

1111111111111110
```

### 输出

```
4762
```



---

---
title: "[AGC039F] Min Product Sum"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc039_f
tag: ['动态规划 DP', '动态规划优化', '容斥原理']
---

# [AGC039F] Min Product Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc039/tasks/agc039_f

$ N $ 行 $ M $ 列のマス目の全てのマスに $ 1 $ 以上 $ K $ 以下の整数を書き込む方法 $ K^{NM} $ 通りすべてに対して以下の値を求め、 それらすべての総和を $ D $ で割ったあまりを求めてください。

- $ NM $ 個の各マスに対し、それと同じ行あるいは同じ列のマス (自分自身を含む) に書かれた整数の最小値を求め、それら $ NM $ 個すべての積を取って得られる値

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ K $ $ D $

## 输出格式

$ K^{NM} $ 個の値の総和を $ D $ で割ったあまりを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N,M,K\ \leq\ 100 $
- $ 10^8\ \leq\ D\ \leq\ 10^9 $
- $ N,M,K,D $ は整数である
- $ D $ は素数である

### Sample Explanation 1

$ NM $ 個の値の積が $ 16 $ になる書き込み方が $ 1 $ 通り、$ 2 $ になる書き込み方が $ 4 $ 通り、$ 1 $ になる書き込み方が $ 11 $ 通りあります。

## 样例 #1

### 输入

```
2 2 2 998244353
```

### 输出

```
35
```

## 样例 #2

### 输入

```
2 3 4 998244353
```

### 输出

```
127090
```

## 样例 #3

### 输入

```
31 41 59 998244353
```

### 输出

```
827794103
```



---

---
title: "[AGC040E] Prefix Suffix Addition"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc040_e
tag: ['动态规划 DP', '动态规划优化']
---

# [AGC040E] Prefix Suffix Addition

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc040/tasks/agc040_e

すぬけくんは，長さ $ N $ の整数列 $ x_1,x_2,\cdots,x_N $ を持っています． 最初，$ x $ の全ての要素は $ 0 $ です．

すぬけくんは，以下の $ 2 $ 種類の操作を好きな順序で好きな回数行うことができます．

- 操作 $ 1 $: 整数 $ k $ ($ 1\ \leq\ k\ \leq\ N $)，及び長さ $ k $ の非負整数列 $ c_1,c_2,\cdots,c_k $ を自由に選ぶ． ただし，$ c $ は**広義単調増加**でなくてはならない． そして，すべての $ i $ ($ 1\ \leq\ i\ \leq\ k $) について，$ x_i $ を $ x_i+c_i $ で置き換える．
- 操作 $ 2 $: 整数 $ k $ ($ 1\ \leq\ k\ \leq\ N $)，及び長さ $ k $ の非負整数列 $ c_1,c_2,\cdots,c_k $ を自由に選ぶ． ただし，$ c $ は**広義単調減少**な数列でなくてはならない． そして，すべての $ i $ ($ 1\ \leq\ i\ \leq\ k $) について，$ x_{N-k+i} $ を $ x_{N-k+i}+c_i $ で置き換える．

すぬけくんの目標は，全ての $ i $ について，$ x_i=A_i $ となるようにすることです． すぬけくんが目標を達成するために行う操作回数の最小値を求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ N $ $ A_1 $ $ A_2 $ $ \cdots $ $ A_N $

## 输出格式

すぬけくんが目標を達成するために行う操作回数の最小値を出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 入力される値はすべて整数である．

### Sample Explanation 1

例えば，以下のように $ 3 $ 回の操作を行えば良いです． $ 3 $ 回未満の操作で目標は達成できません． - $ k=2,c=(1,2) $ として，操作 $ 1 $ を行う．操作後，$ x=(1,2,0,0,0) $ となる． - $ k=3,c=(0,0,1) $ として，操作 $ 1 $ を行う．操作後，$ x=(1,2,1,0,0) $ となる． - $ k=2,c=(2,1) $ として，操作 $ 2 $ を行う．操作後，$ x=(1,2,1,2,1) $ となる．

## 样例 #1

### 输入

```
5

1 2 1 2 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5

2 1 2 1 2
```

### 输出

```
2
```

## 样例 #3

### 输入

```
15

541962451 761940280 182215520 378290929 211514670 802103642 28942109 641621418 380343684 526398645 81993818 14709769 139483158 444795625 40343083
```

### 输出

```
7
```



---

---
title: "[AGC047F] Rooks"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc047_f
tag: ['动态规划 DP', '动态规划优化']
---

# [AGC047F] Rooks

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc047/tasks/agc047_f

無限に広がるチェス盤上の $ N $ 個の敵ルークの位置 $ (X_i,\ Y_i) $ が与えられます。*\[訳注: ルークは将棋の飛車と似た動きをする駒です。\]* どの二つのルークも、お互いを攻められる位置にはありません (すなわち、一行あたり、または一列あたりのルークの数は一個以下です)。

あなたは、ルークのうち一個をキングに置き換え、キングを繰り返し動かしてできるだけ多くのルークを取ろうとしています。*\[訳注: キングは将棋の王将と似た動きをする駒です。\]*

ルークに攻められているマスに入ることはできません。 また、**斜めに移動することで空きマスに移ることもできません** (しかし、斜めに移動することでルークを取ることはできます)。

(つまり、このキングの動きは、斜め四方向に動いて駒を取ることと縦横四方向に動くことができる強化版ポーンのようなものです。)

各ルークについて、そのルークをキングで置き換えた際に取ることのできる最大数のルークを取るために必要な最小手数を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ X_1 $ $ Y_1 $ $ X_2 $ $ Y_2 $ $ \vdots $ $ X_N $ $ Y_N $

## 输出格式

$ N $ 行出力せよ。 $ i $ 行目は、$ (X_i,\ Y_i) $ に置かれたルークをキングに置き換えた場合に対応する。 この行には、一つの整数、すなわち $ M_i $ 個のルークを取るために必要な最小手数を出力せよ。 ここで、$ M_i $ は (何手かけてもよいとして) この場合に取ることのできるルークの最大数である。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 200\,000 $
- $ 1\ \leq\ X_i,\ Y_i\ \leq\ 10^6 $
- $ X_i\ \neq\ X_j $
- $ Y_i\ \neq\ Y_j $
- 入力中の値はすべて整数である。

### Sample Explanation 1

下図を見てください。 ルーク $ 3 $ をキングに置き換えた場合、他のルークを最大で二個取ることができます。 図の赤い経路がこの場合の最適な手順の一つ - ルーク $ 1 $ を取り、右下方向に進み続けてルーク $ 4 $ を取る - です。 ここでの手数は $ 7 $ 手であり、これが出力例の三つ目の数です。 !\[path\](https://img.atcoder.jp/agc047/rooks\_path\_small3.png) \*$ x $ 軸正方向: 右、$ y $ 軸正方向: 上\* ルーク $ 2,\ 5,\ 6 $ のいずれかをキングに置き換えた場合には、他のルークを一個も取ることができません。このとき、最小手数は $ 0 $ です。

## 样例 #1

### 输入

```
6

1 8

6 10

2 7

4 4

9 3

5 1
```

### 输出

```
5

0

7

5

0

0
```

## 样例 #2

### 输入

```
5

5 5

100 100

70 20

81 70

800 1
```

### 输出

```
985

985

1065

1034

0
```

## 样例 #3

### 输入

```
10

2 5

4 4

13 12

12 13

14 17

17 19

22 22

16 18

19 27

25 26
```

### 输出

```
2

2

9

9

3

3

24

5

0

25
```



---

---
title: "[AGC066D] A Independent Set"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc066_d
tag: ['动态规划 DP', '贪心', '动态规划优化']
---

# [AGC066D] A Independent Set

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc066/tasks/agc066_d

`A`, `B` からなる長さ $ N $ の文字列 $ S $ が与えられます．ただし，$ S $ に含まれる `A` の個数は $ \frac{N+1}{2} $ 以下であることが保証されます．さらに，正整数列 $ (x_1,\ \ldots,\ x_{N-1}) $ が与えられます．

あなたはこの文字列に対して，次の操作を繰り返し行うことができます：

- $ 1\leq\ i\leq\ N-1 $ を満たす整数 $ i $ を選び，$ S $ の $ i $ 文字目と $ (i+1) $ 文字目をスワップする．この操作にはコストが $ x_i $ かかる．
 
あなたの目標は，$ S $ において `A` 同士が隣接しないようにすることです．この目標を達成するために必要なコストの総和としてありうる最小値を求めてください．

$ T $ 個のテストケースが与えられるので，それぞれについて答えを求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられます．

> $ T $ $ \text{case}_1 $ $ \vdots $ $ \text{case}_T $

各テストケースは以下の形式で与えられます．

> $ N $ $ S $ $ x_1 $ $ \ldots $ $ x_{N-1} $

## 输出格式

$ T $ 行出力してください．$ i $ 行目には $ i $ 番目のテストケースについて，$ S $ において `A` が隣接しないようにするために必要なコストの最小値を出力してください．

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 10^5 $
- $ 2\leq\ N\leq\ 10^6 $
- $ S $ は `A`, `B` からなる長さ $ N $ の文字列である．
- $ S $ に含まれる `A` の個数は $ \frac{N+1}{2} $ 以下である．
- $ 1\leq\ x_i\ \leq\ 10^6 $
- $ 1 $ 個の入力に含まれるテストケースについて，それらの $ N $ の総和は $ 10^6 $ 以下である．
 
### Sample Explanation 1

\- $ 1 $ 番目のテストケースについて，$ i=1 $ として操作を行うことで $ S $ は `BAAB` → `ABAB` と変化し，目標を達成できます．この場合コストの総和は $ x_1=3 $ です． - $ 2 $ 番目のテストケースについて，操作を行わないことで目標を達成できます．この場合コストの総和は $ 0 $ です． - $ 3 $ 番目のテストケースについて，$ i=1 $, $ i=4 $ として操作を行うことで $ S $ は `BAAABBB` → `ABAABBB` → `ABABABB` と変化し，目標を達成できます．この場合コストの総和は $ x_1+x_4=13 $ です． - $ 4 $ 番目のテストケースについて，$ i=4 $, $ i=3 $, $ i=5 $ として操作を行うことで $ S $ は `BAAABBB` → `BAABABB` → `BABAABB` → `BABABAB` と変化し，目標を達成できます．この場合コストの総和は $ x_4+x_3+x_5=15 $ です．

## 样例 #1

### 输入

```
5

4

BAAB

3 4 5

5

BBBBB

1 2 3 4

7

BAAABBB

8 7 6 5 4 3

7

BAAABBB

100 7 6 5 4 3

20

BAABAABBBABAAABBBABB

12 85 37 44 25 14 36 29 71 53 15 47 13 80 14 74 53 76 19
```

### 输出

```
3

0

13

15

133
```



---

---
title: "[AGC069C] AB*A Changing"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc069_c
tag: ['动态规划 DP', '动态规划优化']
---

# [AGC069C] AB*A Changing

## 题目描述

现有两个长度为 $N$ 的字符串 $S$ 和 $T$，它们都只由字符 `A` 和 `B` 组成。我们用 $s_i$ 来表示字符串 $S$ 的第 $i$ 个字符。

对于字符串 $S$，你可以反复进行以下操作不限次数：

- 选择两个整数 $(i, j)$，要求满足：
  - $1 \leq i < j \leq N$
  - $s_i = s_j = \text{A}$
  - $s_{i+1}, s_{i+2}, \ldots, s_{j-1}$ 都为 `B`
  
- 然后，将 $s_i, s_{i+1}, \ldots, s_j$ 这段字符同时替换为它们相反的字符，即 `A` 换成 `B`，`B` 换成 `A`。

你的任务是判断，通过这种操作，能否将 $S$ 变成 $T$，如果可以，求出最小操作次数；如果不可以，输出 `-1`。

## 输入格式

输入从标准输入中提供，格式为：

> $N$ $S$ $T$

## 输出格式

如果可以通过操作将字符串 $S$ 变为 $T$，输出最少需要的操作次数；如果无法做到，输出 `-1`。

## 说明/提示

- $1 \leq N \leq 200,000$
- $S, T$ 均为由 `A` 和 `B` 组成的长度为 $N$ 的字符串

### 示例说明

#### 示例 1

通过下面的操作，可以用 2 次将 $S$ 变为 $T$：
1. 选择 $(i, j) = (2, 3)$，此时 $S$ 变为 `ABBBA`。
2. 选择 $(i, j) = (1, 5)$，此时 $S$ 变为 `BAAAB`。

所以，最少操作次数为 2。

#### 示例 2

不能通过任何操作将 $S$ 变为 $T$，因而答案是 `-1`。注意：要求 $i < j$。

#### 示例 3

此时 $S$ 和 $T$ 本来就相同，不需任何操作。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
5

AAABA

BAAAB
```

### 输出

```
2
```

## 样例 #2

### 输入

```
1

A

B
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
1

A

A
```

### 输出

```
0
```

## 样例 #4

### 输入

```
10

AAABBABAAB

BBABBAAABB
```

### 输出

```
7
```



---

---
title: "[ARC153E] Deque Minimization"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc153_e
tag: ['动态规划 DP', '多项式', '区间 DP', '动态规划优化', '快速数论变换 NTT']
---

# [ARC153E] Deque Minimization

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc153/tasks/arc153_e

どの桁も $ 0 $ ではないような正整数 $ X $ に対して，次の手順により正整数 $ Y $ を得ることを考えます：

- 文字列 $ S $ を空文字列で初期化する．
- $ X $ の桁数を $ N $ とするとき，$ i\ =\ 1,\ \ldots,\ N $ の順に次を行う：$ X $ の $ 10 $ 進法表記の $ i $ 文字目を，$ S $ の先頭または末尾に挿入する．
- 文字列 $ S $ が表す正整数を $ Y $ とする．
 
この手順により $ X $ から得ることが可能な正整数のうちで，最小のものを $ f(X) $ と書くことにします．

- - - - - -

どの桁も $ 0 $ ではないような正整数 $ Y $ が与えられます．どの桁も $ 0 $ ではないような正整数 $ X $ であって $ f(X)\ =\ Y $ を満たすものの個数を $ 998244353 $ で割った余りを答えてください．

## 输入格式

入力は以下の形式で標準入力から与えられます．

> $ Y $

## 输出格式

どの桁も $ 0 $ ではないような正整数 $ X $ であって $ f(X)\ =\ Y $ を満たすものの個数を $ 998244353 $ で割った余りを出力してください．

## 说明/提示

### 制約

- $ Y $ はどの桁も $ 0 $ ではないような正整数
- $ 1\leq\ Y\ <\ 10^{200000} $
 
### Sample Explanation 1

条件を満たす $ X $ は，$ 1332 $, $ 3132 $, $ 3312 $ の $ 3 $ 個です．

## 样例 #1

### 输入

```
1332
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3312
```

### 输出

```
0
```

## 样例 #3

### 输入

```
12234433442
```

### 输出

```
153
```



---

---
title: "[ARC157F] XY Ladder LCS"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc157_f
tag: ['动态规划 DP', '贪心', '动态规划优化', '标签464']
---

# [ARC157F] XY Ladder LCS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc157/tasks/arc157_f

`X`, `Y` からなる長さ $ N $ の文字列 $ S,\ T $ が与えられます． 各 $ i\ =\ 1,\ 2,\ \dots,\ N $ に関して，$ S $ の $ i $ 文字目と $ T $ の $ i $ 文字目を入れ替えるかどうかを自由に選べます． このとき，結果として得られる文字列の組はのべ $ 2^N $ 通りありますが，そのいずれかの共通部分列（連続とは限らない）となる文字列のうち最長のものを求めてください． ただし，そのような文字列が複数ある場合，そのうち辞書順で最初に現れるものを求めてください．

  共通部分列とは 文字列 $ S $ の**部分列**とは，$ S $ から $ 0 $ 個以上の文字を削除して，残った文字を元の順で並べて得られる文字列のことをいいます． 文字列 $ S,\ T $ の**共通部分列**とは，$ S $ と $ T $ のどちらの部分列でもあるような文字列のことをいいます． （出力例 1 の説明も参考にしてください．）

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ N $ $ S $ $ T $

## 输出格式

入れ替え後の文字列の組の共通部分列としてあり得る最長の文字列のうち，辞書順で最初に現れるものを出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ S,\ T $ はそれぞれ `X`, `Y` からなる長さ $ N $ の文字列である．
 
### Sample Explanation 1

\- どの文字も入れ替えない場合，`XXX` と `YYY` の共通部分列は空文字列のみです． - $ 1 $ 文字目だけを入れ替えた場合，`YXX` と `XYY` の共通部分列は，空文字列, `X`, `Y` です． - $ 2 $ 文字目だけを入れ替えた場合，`XYX` と `YXY` の共通部分列は，空文字列, `X`, `Y`, `XY`, `YX` です． - $ 3 $ 文字目だけを入れ替えた場合，`XXY` と `YYX` の共通部分列は，空文字列, `X`, `Y` です． $ 2 $ 文字以上の入れ替えは，$ S $ と $ T $ 自体を入れ替えて考えれば上記のいずれかに該当します． したがって，共通部分列としてあり得る最長の文字列は `XY` と `YX` であり，辞書順で最初に現れる `XY` が答えとなります．

### Sample Explanation 2

答えが空文字列となることもあります．

### Sample Explanation 3

たとえば $ 2 $ 文字目だけを入れ替えた場合に `XYY` が共通部分列となります． より長い文字列，あるいは，同じ長さであって辞書順でより早く現れる文字列は，どのように入れ替えたとしても共通部分列にはなり得ないため，これが答えとなります．

## 样例 #1

### 输入

```
3

XXX

YYY
```

### 输出

```
XY
```

## 样例 #2

### 输入

```
1

X

Y
```

### 输出

```

```

## 样例 #3

### 输入

```
4

XXYX

YYYY
```

### 输出

```
XYY
```



---

---
title: "[ARC177F] Two Airlines"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc177_f
tag: ['动态规划 DP', '动态规划优化']
---

# [ARC177F] Two Airlines

## 题目描述

在 AtCoder 国，有一排共 $L+1$ 个岛屿，从西至东依次编号为 $0$ 到 $L$。这些岛通过航空线路连接，每条连接线双向可通。对于每个 $1 \leq i \leq L$，岛屿 $i-1$ 和岛屿 $i$ 由一条线路连接。这些航空路线由 A 公司或 J 公司运营，具体来说，连接岛屿 $i-1$ 和岛屿 $i$ 的线路属于 $S_i$ 公司。

![ ](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc177_f/ec43c2a273b93f82a4a10274bb14dc9581c8ab88.png)

这个国家有 $N$ 位居民，他们被编号为 $1$ 到 $N$。每位居民目前分别位于岛屿 $X_i$ 上。

每位居民都持有一张优惠券，可以用在相应航空公司的航线上。具体来说，居民 $i$ 拿着的是 $C_i$ 公司的优惠券。在持有该公司路线的航班上，他们可以免费乘坐不限次；而搭乘其他公司航班时，每次需要支付 $1$ 枚硬币。

我们的目标是在岛屿 $0$ 上的宝箱需要运送到首都岛屿 $L$。为了实现这一目标，请计算最少需要支付多少枚硬币。需要注意的是，宝箱可以在居民之间转交，但优惠券不允许转让。

## 输入格式

输入通过以下格式标准输入：

> $L$ $N$ $S_1 S_2 \cdots S_L$ $X_1$ $C_1$ $X_2$ $C_2$ $\vdots$ $X_N$ $C_N$

这里特别注意，第 $2$ 行是一个长度为 $L$ 的字符串。

## 输出格式

输出为一个整数表示所需的最少硬币数量。

## 说明/提示

### 条件限制

- $1 \leq L \leq 6 \times 10^4$
- $1 \leq N \leq 6 \times 10^4$
- $S_i\ (1 \leq i \leq L)$ 是 `A` 或 `J`
- $0 \leq X_i \leq L\ (1 \leq i \leq N)$
- $C_i\ (1 \leq i \leq N)$ 是 `A` 或 `J`
- $L, N, X_i$ 是整数

### 示例解释

下面的操作可使宝箱被运送到岛屿 $4$，总共只需花费 $2$ 枚硬币：

1. 居民 $1$ 从岛 $3$ 移到岛 $2$。因为不是优惠券适用的公司航班，所以花费 $1$ 枚硬币。
2. 居民 $1$ 从岛 $2$ 到岛 $1$，在这个过程中无需支付，因为这是他拥有优惠券的公司路线。
3. 居民 $1$ 从岛 $1$ 到岛 $0$，免费，因为使用的是优惠券航班。
4. 居民 $1$ 拿起宝箱。
5. 居民 $1$ 带着宝箱，从岛 $0$ 移动到岛 $1$，依旧免费。
6. 居民 $1$ 把宝箱交给居民 $2$。
7. 居民 $2$ 带着宝箱，从岛 $1$ 到岛 $2$，这条航线不适用他的优惠券，花费 $1$ 枚硬币。
8. 居民 $2$ 继续从岛 $2$ 到岛 $3$，免费，因为使用了他公司的航班。
9. 最后，居民 $2$ 从岛 $3$ 到岛 $4$，依旧免费。

![ ](https://img.atcoder.jp/arc177/362e9b56e8e71232a449db9eee2897d8.png)

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4 3

AAJJ

3 A

1 J

1 J
```

### 输出

```
2
```

## 样例 #2

### 输入

```
8 3

JJAAJJAJ

2 A

6 A

8 J
```

### 输出

```
6
```

## 样例 #3

### 输入

```
8 6

JJAAJJAJ

2 A

6 A

8 J

8 J

8 J

8 J
```

### 输出

```
4
```



---


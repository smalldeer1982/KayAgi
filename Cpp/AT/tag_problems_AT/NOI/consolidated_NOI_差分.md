---
title: "[AGC036D] Negative Cycle"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc036_d
tag: ['动态规划 DP', '差分约束', '前缀和']
---

# [AGC036D] Negative Cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc036/tasks/agc036_d

$ N $ 頂点からなる重み付き有向グラフがあり、頂点には $ 0 $ から $ N-1 $ までの番号がついています。

最初、このグラフには $ N-1 $ 本の辺があります。 このうち $ i $ 番目 ($ 0\ \leq\ i\ \leq\ N-2 $) の辺は、 頂点 $ i $ から頂点 $ i+1 $ へ向かう重さ $ 0 $ の辺です。

すぬけさんはこれから、全ての $ i,j $ ($ 0\ \leq\ i,j\ \leq\ N-1,\ i\ \neq\ j $) について、新たに辺 $ (i\ →\ j) $ を追加する操作を行います。 辺の重さは、$ i\ <\ j $ なら $ -1 $、そうでないなら $ 1 $ とします。

りんごくんは、グラフに負閉路（閉路であって、そこに含まれる辺の重みの総和が $ 0 $ 未満のもの）があるととても悲しいです。 そこで、すぬけさんが追加した辺のうちいくつかを削除して、最終的なグラフに負閉路が含まれないようにすることにしました。 すぬけさんが追加した辺 $ (i\ →\ j) $ を削除するには $ A_{i,j} $ のコストがかかります。 なお、最初からあった $ N-1 $ 本の辺を削除することはできません。

りんごくんが目的を達成するために必要なコストの総和の最小値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ A_{0,1} $ $ A_{0,2} $ $ A_{0,3} $ $ \cdots $ $ A_{0,N-1} $ $ A_{1,0} $ $ A_{1,2} $ $ A_{1,3} $ $ \cdots $ $ A_{1,N-1} $ $ A_{2,0} $ $ A_{2,1} $ $ A_{2,3} $ $ \cdots $ $ A_{2,N-1} $ $ \vdots $ $ A_{N-1,0} $ $ A_{N-1,1} $ $ A_{N-1,2} $ $ \cdots $ $ A_{N-1,N-2} $

## 输出格式

りんごくんが目的を達成するために必要なコストの総和の最小値を出力せよ。

## 说明/提示

### 制約

- $ 3\ \leq\ N\ \leq\ 500 $
- $ 1\ \leq\ A_{i,j}\ \leq\ 10^9 $
- 入力される値はすべて整数である。

### Sample Explanation 1

すぬけさんが追加した辺 $ (0\ →\ 1) $ を削除すると、グラフに負閉路がないようになります。 この時必要なコストは $ 2 $ で、これが最小です。

### Sample Explanation 2

すぬけさんが追加した辺 $ (1\ →\ 2) $ と $ (3\ →\ 0) $ を削除すると、グラフに負閉路がないようになります。 この時必要なコストは $ 1+1=2 $ で、これが最小です。

## 样例 #1

### 输入

```
3

2 1

1 4

3 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4

1 1 1

1 1 1

1 1 1

1 1 1
```

### 输出

```
2
```

## 样例 #3

### 输入

```
10

190587 2038070 142162180 88207341 215145790 38 2 5 20

32047998 21426 4177178 52 734621629 2596 102224223 5 1864

41 481241221 1518272 51 772 146 8805349 3243297 449

918151 126080576 5186563 46354 6646 491776 5750138 2897 161

3656 7551068 2919714 43035419 495 3408 26 3317 2698

455357 3 12 1857 5459 7870 4123856 2402 258

3 25700 16191 102120 971821039 52375 40449 20548149 16186673

2 16 130300357 18 6574485 29175 179 1693 2681

99 833 131 2 414045824 57357 56 302669472 95

8408 7 1266941 60620177 129747 41382505 38966 187 5151064
```

### 输出

```
2280211
```



---

---
title: "[AGC052E] 3 Letters"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc052_e
tag: ['数论', '差分']
---

# [AGC052E] 3 Letters

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc052/tasks/agc052_e

`A`, `B`, `C` からなる文字列は、どの連続する $ 2 $ 文字も異なるとき、**良い** 文字列であると呼ばれます。例えば、`ABABAB` や `ABC` は良い文字列であり、`ABBA` や `AABBCC` は良い文字列ではありません。

$ 2 $ つの長さ $ N $ の **良い** 文字列 $ S,\ T $ が与えられます。 $ 1 $ 回の操作で、あなたは $ S $ から任意の $ 1 $ 文字を選び、`A`, `B`, `C` のいずれかであるような別の文字に変えることができます。ただし、操作後も $ S $ は **良い** 文字列でなければなりません。

$ S $ を $ T $ に変化させるには、最小で何回の操作が必要でしょうか。 なお、これは必ず有限回の操作で可能であることが証明できます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $ $ T $

## 输出格式

$ S $ を $ T $ に変化させるために必要な最小の操作回数を出力せよ。

## 说明/提示

### 制約

- $ 1\le\ N\ \le\ 5\cdot\ 10^5 $
- $ S $ は `A`, `B`, `C` からなる長さ $ N $ の **良い** 文字列である。
- $ T $ は `A`, `B`, `C` からなる長さ $ N $ の **良い** 文字列である。

### Sample Explanation 1

$ 6 $ 回の操作で目標を達成する例を以下に示します。 `CABC` $ \to $ `BABC` $ \to $ `BCBC` $ \to $ `BCAC` $ \to $ `ACAC` $ \to $ `ABAC` $ \to $ `CBAC` この場合には、少なくとも $ 6 $ 回の操作が必要であることが示せます。

## 样例 #1

### 输入

```
4

CABC

CBAC
```

### 输出

```
6
```

## 样例 #2

### 输入

```
10

ABABABABAB

BABABABABA
```

### 输出

```
15
```



---

---
title: "[AGC059D] Distinct Elements on Subsegments"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc059_d
tag: ['贪心', '差分', 'Ad-hoc']
---

# [AGC059D] Distinct Elements on Subsegments

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc059/tasks/agc059_d

整数列 $ A=(A_1,\ A_2,\ \ldots,\ A_{N\ +\ K-1}) $ ($ 1\ \leq\ A_i\ \leq\ N+K-1 $) に対して、$ B_i $ を $ A_i,A_{i+1},\ldots,A_{i+K-1} $ の中の相異なる要素の個数として、列 $ B=(B_1,\ B_2,\ \ldots,\ B_N) $ を作ります。

$ B_1,\ B_2,\ \ldots,\ B_N $ が与えられます。この列 $ B $ を生成し得た列 $ A $ が存在するか判定し、存在する場合はそのような列 $ A $ を一つ構成してください。

各入力ファイルについて、$ T $ 個のテストケースを解いてください。

## 输入格式

入力は標準入力から以下の形式で与えられる。

> $ T $ $ case_1 $ $ case_2 $ $ \vdots $ $ case_T $

各ケースは以下の形式である。

> $ N $ $ K $ $ B_1 $ $ B_2 $ $ \ldots $ $ B_N $

## 输出格式

各テストケースについて、題意を満たす列 $ A $ が存在しなければ、`NO` と出力せよ。

そうでなければ、答えを次の形式で出力せよ。

> YES $ A_1 $ $ A_2 $ $ \ldots $ $ A_{N+K-1} $

ここで、$ 1\ \leq\ A_i\ \leq\ N+K-1 $ でなければならず、$ A $ は $ B $ を生成するものでなければならない。 複数の解が存在する場合は、そのいずれも認められる。

`YES` または `NO` の出力において、各文字は英大文字・小文字のいずれでもよい。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 5\ \cdot\ 10^4 $
- $ 2\ \le\ N\ \le\ 2\ \cdot\ 10^5 $
- $ 2\ \le\ K\ \le\ 2\ \cdot\ 10^5 $
- $ 1\ \le\ B_i\ \le\ K $
- 各入力ファイル内の $ N $ の総和は $ 2\cdot\ 10^5 $ を超えない。
- 各入力ファイル内の $ K $ の総和は $ 2\cdot\ 10^5 $ を超えない。
- 入力中のすべての値は整数である。

## 样例 #1

### 输入

```
3

3 3

1 2 1

4 3

1 2 2 1

6 4

3 3 3 3 3 3
```

### 输出

```
NO

YES

1 1 1 2 2 2 

YES

1 2 3 1 2 3 1 2 3
```



---

---
title: "[AGC066F] Beautiful String"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc066_f
tag: ['贪心', '差分']
---

# [AGC066F] Beautiful String

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc066/tasks/agc066_f

次の条件を満たす文字列を，**美しい文字列**ということにします．

- どの文字も `A`, `B`, `C` のいずれかである．
- どの隣接する $ 2 $ 文字も相異なる．
 
例えば `AB`, `BCAC` は美しい文字列です．`BB`, `CBAAC` は美しい文字列ではありません．

- - - - - -

美しい文字列 $ S $ が与えられます．あなたはこの文字列に対して，次の操作を繰り返し行うことができます：

- 操作：$ S $ の隣接する $ 2 $ 文字をスワップする．ただしスワップ後の $ S $ も美しい文字列でなくてはならない．
 
最終的な文字列 $ S $ としてありうる辞書順最小の文字列を求めてください．

$ T $ 個のテストケースが与えられるので，それぞれについて答えを求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられます．

> $ T $ $ \text{case}_1 $ $ \vdots $ $ \text{case}_T $

各テストケースは以下の形式で与えられます．

> $ S $

## 输出格式

$ T $ 行出力してください．$ i $ 行目には $ i $ 番目のテストケースについて，最終的な文字列 $ S $ としてありうる辞書順最小の文字列を出力してください．

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 10^5 $
- $ S $ は美しい文字列である．
- $ 1\leq\ |S|\leq\ 10^6 $
- $ 1 $ 個の入力に含まれるテストケースについて，それらの $ |S| $ の総和は $ 10^6 $ 以下である．
 
### Sample Explanation 1

$ 1 $ 番目，$ 2 $ 番目のテストケースについて，次が $ S $ を辞書順最小化する方法の一例となります． - `CAB` → `ACB` → `ABC` - `ACBCB` → `CABCB` → `CBACB` → `BCACB` → `BCABC` → `BACBC` → `ABCBC`

## 样例 #1

### 输入

```
8

CAB

ACBCB

B

AC

BACBA

BABABA

ABCBCAC

CBABACABCBABABC
```

### 输出

```
ABC

ABCBC

B

AC

ABABC

BABABA

ABCACBC

ABABACBCACBCBAB
```



---

---
title: "[ARC184E] Accumulating Many Times"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc184_e
tag: ['树状数组', 'Lucas 定理', '差分']
---

# [ARC184E] Accumulating Many Times

## 题目描述

给定 $N$ 个长度为 $M$ 的整数序列，每个序列的元素是 $0$ 或 $1$。第 $i$ 个序列记为 $A_i = (A_{i,1}, A_{i,2}, \dots, A_{i,M})$。

我们定义一个函数 $f(i, j)$，用于两个序列 $A_i$ 和 $A_j$ 之间的运算：

- $f(i, j)$ 是最小的非负整数 $x$，满足将 $A_i$ 进行以下操作 $x$ 次后，可以使得 $A_i$ 和 $A_j$ 相等。如果没有这样的 $x$ 能够满足条件，则 $f(i, j) = 0$。
  - 具体操作是：对于每个整数 $k\ (1 \leq k \leq M)$，同时将 $A_{i,k}$ 替换为 $\left( \sum_{l=1}^{k} A_{i,l} \right) \bmod 2$。

要求计算并输出 $\sum_{i=1}^{N} \sum_{j=i}^{N} f(i, j)$，结果需要对 $998244353$ 取模。

## 输入格式

输入从标准输入中读取，格式如下：

首先一行包含两个整数 $N$ 和 $M$。  
接下来是 $N$ 行，每行包含 $M$ 个整数，代表 $N$ 个序列。

## 输出格式

输出结果应为一行，对 $998244353$ 取模后的答案。

## 说明/提示

- $1 \leq N \times M \leq 10^6$
- 对任意整数 $A_{i,j}$，都有 $A_{i,j} \in \{0, 1\}$

### 示例说明

例如，$f(1, 1) = 0$，$f(1, 2) = 3$，$f(1, 3) = 2$，$f(1, 4) = 0$，$f(2, 2) = 0$，$f(2, 3) = 3$，$f(2, 4) = 0$，$f(3, 3) = 0$，$f(3, 4) = 0$，$f(4, 4) = 0$。因此，这些值的总和为 $8$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4 3
1 0 0
1 1 0
1 0 1
0 1 1
```

### 输出

```
8
```

## 样例 #2

### 输入

```
7 6
1 0 0 0 0 0
1 1 1 0 0 0
1 0 1 1 0 0
1 0 0 0 1 1
1 0 0 0 0 1
1 0 0 0 0 0
1 1 1 1 1 1
```

### 输出

```
6
```



---


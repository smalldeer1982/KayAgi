---
title: "[ABC363G] Dynamic Scheduling"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_abc363_g
tag: ['贪心', '线段树', '模拟费用流']
---

# [ABC363G] Dynamic Scheduling

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_g

長さ $ N $ の数列 $ D=(D_1,\ D_2,\ \dots,\ D_N),\ P=(P_1,\ P_2,\ \dots,\ P_N) $ が与えられます。

$ Q $ 個のクエリを与えられる順に処理してください。クエリは以下の形式で与えられます。

- `c x y` : $ D_c $ を $ x $ に、$ P_c $ を $ y $ に変更する。そして、次の問題を解いて答えを出力する。
 
> $ 1 $ から $ N $ までの番号がついた $ N $ 個の仕事があります。  
>  あなたは今日 (これを $ 1 $ 日目とする) から $ 1 $ 日あたり $ 1 $ 個の仕事を選んで終わらせることを $ N $ 日間行います。  
>  仕事 $ i $ は $ D_i $ 日目までに終わらせると $ P_i $ の報酬を貰えます。($ D_i $ 日目までに終わらせなかった場合は何も無い)  
>  仕事をやる順番を上手く選んだ時の報酬の総和の最大値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。ここで $ \mathrm{query}_i $ は $ i $ 番目のクエリを意味する。

> $ N $ $ Q $ $ D_1 $ $ D_2 $ $ \dots $ $ D_N $ $ P_1 $ $ P_2 $ $ \dots $ $ P_N $ $ \mathrm{query}_1 $ $ \mathrm{query}_2 $ $ \vdots $ $ \mathrm{query}_Q $

各クエリは以下の形式で与えられる。

> $ c $ $ x $ $ y $

## 输出格式

$ Q $ 行出力せよ。$ i $ 行目には $ i $ 番目のクエリの答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ 1\ \leq\ D_i\ \leq\ N $
- $ 1\ \leq\ P_i\ \leq\ 10^9 $
- $ 1\ \leq\ c\ \leq\ N $
- $ 1\ \leq\ x\ \leq\ N $
- $ 1\ \leq\ y\ \leq\ 10^9 $
- 入力される値は全て整数
 
### Sample Explanation 1

$ 1 $ 番目のクエリは次のようになります。 - $ D_3 $ を $ 1 $ に、$ P_3 $ を $ 4 $ に更新する。$ D\ =\ (1,\ 2,\ 1),\ P\ =\ (3,\ 6,\ 4) $ になる。 - 小問題では、$ 1 $ 日目に仕事 $ 3 $ を、$ 2 $ 日目に仕事 $ 2 $ を、$ 3 $ 日目に仕事 $ 1 $ を行うという手順が最適な手順の $ 1 $ つで、この時の報酬の総和は $ 10 $ であるから、これを出力する。 $ 2 $ 番目のクエリは次のようになります。 - $ D_2 $ を $ 3 $ に、$ P_2 $ を $ 9 $ に更新する。$ D\ =\ (1,\ 3,\ 1),\ P\ =\ (3,\ 9,\ 4) $ になる。 - 小問題では、$ 1 $ 日目に仕事 $ 3 $ を、$ 2 $ 日目に仕事 $ 1 $ を、$ 3 $ 日目に仕事 $ 2 $ を行うという手順が最適な手順の $ 1 $ つで、この時の報酬の総和は $ 13 $ であるから、これを出力する。

## 样例 #1

### 输入

```
3 2

1 2 3

3 6 3

3 1 4

2 3 9
```

### 输出

```
10

13
```

## 样例 #2

### 输入

```
5 1

1 2 3 4 5

1000000000 1000000000 1000000000 1000000000 1000000000

1 1 1000000000
```

### 输出

```
5000000000
```

## 样例 #3

### 输入

```
10 10

6 2 4 1 5 1 6 6 5 3

45 65 71 52 86 52 48 60 40 98

5 6 5

8 4 34

6 7 83

1 3 21

7 5 85

7 4 51

8 2 81

2 7 54

6 1 5

8 6 30
```

### 输出

```
394

379

462

457

459

414

443

479

401

396
```



---

---
title: "[AGC040D] Balance Beam"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc040_d
tag: ['数学', '贪心', '二分', '概率论', '期望']
---

# [AGC040D] Balance Beam

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc040/tasks/agc040_d

$ 1 $ から $ N $ までの番号がついた $ N $ 個の平均台があります． どの平均台の長さも $ 1 $ メートルです． すぬけくんが平均台 $ i $ の上をあるくスピードは $ 1 $ 秒あたり $ 1/A_i $ メートルです． また，りんごさんが平均台 $ i $ の上をあるくスピードは $ 1 $ 秒あたり $ 1/B_i $ メートルです．

すぬけくんとりんごさんが，以下のゲームを行います．

- まず，すぬけくんが $ N $ 個の平均台を好きな順序で横一列に連結し，長さ $ N $ メートルの平均台を作る．
- すぬけくんはこの平均台の左端からスタートする． りんごさんはこの平均台の上で一様ランダムに選ばれた一点からスタートする． $ 2 $ 人は同時にスタートし，平均台の右端を目指して進む。
- すぬけくんの勝利条件は，りんごさんが平均台の右端に到着する前にりんごさんに追いつくことである． つまり，すぬけくんとりんごさんの位置が同じになる瞬間があればすぬけくんの勝ち，そうでないならりんごさんの勝ちである．

すぬけくんが勝率を最大化するように平均台を並べたときの勝率を求めてください．

なお，この問題の答えは有理数になります． そこで，答えを既約分数 $ P/Q $ として表したときの $ P,Q $ を求めてください． ただし，答えが $ 0 $ の時は $ P=0,Q=1 $ としてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ N $ $ A_1 $ $ B_1 $ $ A_2 $ $ B_2 $ $ \vdots $ $ A_N $ $ B_N $

## 输出格式

すぬけくんの勝率の最大値を表す既約分数の分子と分母を出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ 10^9 $
- 入力される値はすべて整数である．

### Sample Explanation 1

平均台 $ 2,1 $ の順に連結するとすぬけくんの勝率は $ 1/4 $ になり，これが最大です．

## 样例 #1

### 输入

```
2

3 2

1 2
```

### 输出

```
1 4
```

## 样例 #2

### 输入

```
4

1 5

4 7

2 1

8 4
```

### 输出

```
1 2
```

## 样例 #3

### 输入

```
3

4 1

5 2

6 3
```

### 输出

```
0 1
```

## 样例 #4

### 输入

```
10

866111664 178537096

705445072 318106937

472381277 579910117

353498483 865935868

383133839 231371336

378371075 681212831

304570952 16537461

955719384 267238505

844917655 218662351

550309930 62731178
```

### 输出

```
697461712 2899550585
```



---

---
title: "[AGC048E] Strange Relation"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc048_e
tag: ['动态规划 DP', '贪心']
---

# [AGC048E] Strange Relation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc048/tasks/agc048_e

長さ $ N $ の整数列 $ A=(A_1,A_2,\cdots,A_N) $, および整数 $ T $ に対して，$ f(A,T) $ を，つぎのように定義します．

- $ f(A,T) $ は，以下の条件をすべて満たす整数列 $ x $ の中で，辞書順最大のものである． なおこの問題の制約下では，条件を満たす数列は必ず存在し，またその個数は有限であることが証明できる．よって，$ f(A,T) $ は必ず定義できる．
  
  
  - $ x $ は長さ $ N $ の非負整数列である．
  - 各 $ i $ ($ 1\ \leq\ i\ \leq\ N $) について，$ y_i $ を，$ j\ <\ i $ かつ $ A_j+T\ \times\ x_j\ <\ A_i+T\ \times\ x_i $ を満たす $ j $ の個数，と定義する．このとき，$ y_i=x_i $ である．

例えば，$ A=(6,5,1),T=3 $ であるとします． この時，条件を満たす数列 $ x $ として，$ (0,0,0),(0,0,2),(0,1,0) $ が考えられます． よって，$ f(A,T) $ の値は，この中で辞書順最大の $ (0,1,0) $ です．

すぬけくんは今，$ N $ 個の整数列 $ B_1,B_2,\cdots,B_N $ と，整数 $ T $ を持っています． $ B_i $ ($ 1\ \leq\ i\ \leq\ N $) はすべて長さ $ K $ の整数列です．

これからすぬけくんは，長さ $ N $ の整数列 $ A $ を作り，$ f(A,T) $ を求めようとしています． $ A_i $ の値は，$ B_{i,1},B_{i,2},\cdots,B_{i,K} $ から選ぶことにします． ここで，$ B_i $ の値に重複があっても，それらの値を区別することにします． つまり，$ A $ の作り方は $ K^N $ 通り存在します．

すべての $ i $ ($ 1\ \leq\ i\ \leq\ N $) について，次の問題を解いてください．

- $ K^N $ 通りすべての $ A $ について $ f(A,T) $ を求め，その $ i $ 項目の値を記録する． これらの値の総和を $ \bmod\ (10^9+7) $ で求めよ．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ N $ $ K $ $ T $ $ B_{1,1} $ $ B_{1,2} $ $ \cdots $ $ B_{1,K} $ $ B_{2,1} $ $ B_{2,2} $ $ \cdots $ $ B_{2,K} $ $ \vdots $ $ B_{N,1} $ $ B_{N,2} $ $ \cdots $ $ B_{N,K} $

## 输出格式

すべての $ i $ について，答えを一行ごとに出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ 1\ \leq\ K\ \leq\ 50 $
- $ 1\ \leq\ T\ \leq\ 10^7 $
- $ 1\ \leq\ B_{i,j}\ \leq\ 10^9 $

### Sample Explanation 1

\- $ A=(1,1) $ の場合: $ f(A,T)=(0,1) $ - $ A=(1,2) $ の場合: $ f(A,T)=(0,1) $ - $ A=(2,1) $ の場合: $ f(A,T)=(0,0) $ - $ A=(2,2) $ の場合: $ f(A,T)=(0,1) $ よって，$ i=1 $ のときの答えは $ 0+0+0+0=0 $ であり， $ i=2 $ のときの答えは $ 1+1+0+1=3 $ です．

## 样例 #1

### 输入

```
2 2 1

1 2

1 2
```

### 输出

```
0

3
```

## 样例 #2

### 输入

```
3 2 3

6 2

5 3

1 4
```

### 输出

```
0

6

13
```

## 样例 #3

### 输入

```
10 15 45

129 82 26 185 217 258 22 192 24 117 167 255 91 180 203

171 73 168 26 208 169 115 164 121 214 154 196 172 66 230

185 178 241 220 243 143 111 124 10 62 56 117 254 43 81

201 74 213 163 204 35 44 203 207 73 218 60 243 51 250

229 117 212 245 112 152 206 96 266 165 105 94 231 41 27

261 201 258 111 100 72 239 31 199 203 226 151 72 268 44

94 19 47 243 133 174 141 82 190 62 175 256 126 123 210

186 64 73 82 68 183 261 120 265 212 18 24 36 152 92

205 101 186 91 172 153 91 242 141 97 247 193 45 245 66

225 97 162 213 61 219 184 195 80 203 79 72 269 258 199
```

### 输出

```
0

248044096

333666695

536381826

8787512

11659012

661959013

166067001

529828166

526544756
```



---

---
title: "[AGC048F] 01 Record"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc048_f
tag: ['动态规划 DP', '贪心']
---

# [AGC048F] 01 Record

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc048/tasks/agc048_f

すぬけくんは大きな黒板をもらいました． これに喜んだすぬけくんは，まず，黒板にいくつかの正整数を書きました． 次にすぬけくんは，黒板に書かれている整数がなくなるまで，以下の操作を繰り返し行いました．

- 黒板に書かれている整数を $ 1 $ つ選び，消す． 消した整数を $ x $ とする． 次に，$ x $ を $ 2 $ で割ったあまりをノートに記録する． 最後に，$ x\ \geq\ 2 $ である場合は，新たに $ x-1 $ を黒板に書き加える．

すぬけくんの記録は，`0` と `1` からなる文字列 $ S $ によって表されます． これは，すぬけくんが $ i $ 回目の操作で選んだ整数を $ 2 $ で割ったあまりが $ S_i $ であることを表します．

すぬけくんは，最初に黒板に書いた正整数の組み合わせを忘れてしまいました． 文字列 $ S $ の情報から，最初に黒板に書いた正整数の組み合わせとしてありうるものが何通りあるか求めてください． ここで，正整数の組み合わせ $ a $ と $ b $ が異なるとは，ある整数 $ v $ が存在して，$ a $ に含まれる $ v $ の個数と $ b $ に含まれる $ v $ の個数が異なることを意味します． なお，答えは非常に大きくなることがあるので，$ 10^9+7 $ で割ったあまりを求めてください． また，すぬけくんの記録が間違っており，条件を満たす正整数の組み合わせが存在しないこともありますが，その場合は単に $ 0 $ と答えてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ S $

## 输出格式

最初に黒板に書いた正整数の組み合わせとしてありうるものの数を $ 10^9+7 $ で割ったあまりを出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 300 $
- $ S $ は `0` と `1` からなる文字列．

### Sample Explanation 1

最初に黒板に書いた整数の組み合わせとしてあり得るのは，$ \{1,2\},\ \{3\} $ の $ 2 $ つです．

### Sample Explanation 2

最初に黒板に書いた整数の組み合わせとしてあり得るものはありません．

### Sample Explanation 3

最初に黒板に書いた整数の組み合わせとしてあり得るのは，$ \{2,2,2\},\ \{2,4\},\ \{6\} $ の $ 3 $ つです．

## 样例 #1

### 输入

```
101
```

### 输出

```
2
```

## 样例 #2

### 输入

```
100
```

### 输出

```
0
```

## 样例 #3

### 输入

```
010101
```

### 输出

```
3
```

## 样例 #4

### 输入

```
11101000111110111101001011110010111110101111110111
```

### 输出

```
3904
```



---

---
title: "[AGC051C] Flipper"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc051_c
tag: ['数学', '贪心', 'Ad-hoc']
---

# [AGC051C] Flipper

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc051/tasks/agc051_c

$ 10^9\ \times\ 10^9 $ 個のマスが正方形状に並んでおり、$ (1,\ 1) $ から $ (10^9,\ 10^9) $ までの番号が振られています。 マス $ (i,\ j) $ は上から $ i $ 列目、左から $ j $ 列目のマスです。 はじめ、$ N $ マス $ (x_1,\ y_1),\ \ldots,\ (x_N,\ y_N) $ が黒で、他の全てのマスは白です。

すぬけ君は、以下の操作を何度でも行うことができます。

- 整数 $ x\ (1\ \leq\ x\ \leq\ 10^9\ -\ 1) $ と整数 $ y\ (1\ \leq\ y\ \leq\ 10^9\ -\ 2) $ を選び、$ 6 $ マス $ (x,\ y),\ (x,\ y+1),\ (x,\ y+2),\ (x+1,\ y),\ (x+1,\ y+1),\ (x+1,\ y+2) $ の色を反転させる (黒は白に、白は黒になる)

操作を済ませた後の黒マスの数として考えられる最小のものを計算してください。

## 输入格式

入力は標準入力から以下の形式で与えられる。

> $ N $ $ x_1\ y_1 $ $ : $ $ x_N\ y_N $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ x_i,\ y_i\ \leq\ 10^9 $
- $ (x_i,\ y_i) $ は互いに異なる。
- 入力中の全ての値は整数である。

### Sample Explanation 1

以下の図で、上から $ i $ 個目の文字列の $ j $ 文字目がマス $ (i,\ j) $ を表します。`#` が黒、`.` が白です。 ``` .##. #.## .### .#.. -&gt; #... .#.# .### .#.. -&gt; #... ..#. .... .#.. ```

## 样例 #1

### 输入

```
9

1 2

1 3

2 1

2 3

2 4

3 2

3 3

3 4

4 2
```

### 输出

```
3
```



---

---
title: "[AGC052C] Nondivisible Prefix Sums"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc052_c
tag: ['动态规划 DP', '贪心']
---

# [AGC052C] Nondivisible Prefix Sums

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc052/tasks/agc052_c

素数 $ P $ が与えられます。これはあなたの嫌いな数です。

整数の列 $ A_1,\ A_2,\ \dots,\ A_N $ について、どの接頭辞の和も $ P $ で割り切れないように要素を並べ替えることができるとき、この列を **良い** 列と呼びます（すなわち、並べ替えのあと、$ 1\ \le\ i\ \le\ N $ かつ $ A_1\ +\ A_2\ +\ \dots\ +\ A_i\ \equiv\ 0\ \bmod\ P $ であるような $ i $ が **存在してはいけません**）。

各要素が $ 1 $ 以上 $ P-1 $ 以下であるような長さ $ N $ の整数列は全部で $ (P-1)^N $ 通りありますが、このうち **良い** 列はいくつでしょうか。

答えは非常に大きい可能性があるため、これを $ 998244353 $ で割った余りを出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ P $

## 输出格式

**良い** 列の個数を $ 998244353 $ で割った余りを出力せよ。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 5000 $
- $ 2\ \le\ P\ \le\ 10^8 $
- $ P $ は素数である。

### Sample Explanation 1

良い列は $ [1,\ 1] $, $ [1,\ 2] $, $ [1,\ 3] $, $ [2,\ 1] $, $ [2,\ 2] $, $ [2,\ 4] $, $ [3,\ 1] $, $ [3,\ 3] $, $ [3,\ 4] $, $ [4,\ 2] $, $ [4,\ 3] $, $ [4,\ 4] $ の $ 12 $ 通りです。

### Sample Explanation 2

良い列は $ [1,\ 1,\ 1,\ 2] $, $ [1,\ 1,\ 2,\ 1] $, $ [1,\ 2,\ 1,\ 1] $, $ [2,\ 1,\ 1,\ 1] $, $ [2,\ 2,\ 2,\ 1 $\\\], $ [2,\ 2,\ 1,\ 2] $, $ [2,\ 1,\ 2,\ 2] $, $ [1,\ 2,\ 2,\ 2] $ の $ 8 $ 通りです。

## 样例 #1

### 输入

```
2 5
```

### 输出

```
12
```

## 样例 #2

### 输入

```
4 3
```

### 输出

```
8
```

## 样例 #3

### 输入

```
5000 99999989
```

### 输出

```
51699346
```

## 样例 #4

### 输入

```
2021 307
```

### 输出

```
644635349
```



---

---
title: "[AGC053D] Everyone is a winner"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc053_d
tag: ['贪心']
---

# [AGC053D] Everyone is a winner

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc053/tasks/agc053_d

$ N $ 人の参加者と $ N $ 個の問題からなるコンテストがあります。 参加者には $ 1 $ から $ N $ までの番号が付いています。 各参加者と問題の組について、その参加者がその問題を解くのにかかる時間が分かっており、 その時間は $ 1 $ 分、$ 2 $ 分または $ 3 $ 分です。 $ N $ 個の問題のうち、参加者 $ i $ が解くのに $ 1 $ 分かかる問題は $ A_i $ 問、 $ 2 $ 分かかる問題は $ B_i $ 問、$ 3 $ 分かかる問題は $ C_i $ 問あります。

各参加者が問題を解く順番を自由に定めることで、すべての $ 1\ \leq\ i,\ j\ \leq\ N $ について以下が成立することがありうるか判定してください。

- 参加者 $ i $ が最初の $ i $ 問を解くのにかかる時間を $ S $ 分、参加者 $ j $ が最初の $ i $ 問を解くのにかかる時間を $ T $ 分とする。このとき $ S\ \leq\ T $ となる。

つまり、すべての $ i $ について参加者 $ i $ が最初の $ i $ 問を解いた時点で $ 1 $ 位（同率でもよい）となることがありうるか判定してください。 ただし、ある問題を解いてから次の問題にうつるまでにかかる時間は無視できるものとします。

$ T $ 個のテストケースが与えられるので、それぞれを解いてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。入力の $ 1 $ 行目は次の通りである。

> $ T $

そして、以下の形式で $ T $ 個のテストケースが続く。

> $ N $ $ A_1 $ $ B_1 $ $ C_1 $ $ : $ $ A_N $ $ B_N $ $ C_N $

## 输出格式

各テストケースについて、問題文の条件が成立しうるならば `Yes` 、そうでなければ `No` と出力せよ。 $ 1 $ 行につき $ 1 $ 個のテストケースへの出力を行え。なお、正誤判定器は英大文字と英小文字を区別せず、どちらも受理する。

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ A_i,B_i,C_i\ \leq\ N $
- $ A_i+B_i+C_i=N $
- 全テストケースにおける $ N $ の総和は $ 2\times\ 10^5 $ 以下である。

### Sample Explanation 1

最初のテストケースでは、例えば以下のような場合に条件が成立します。 - 参加者 $ 1 $ は $ 1 $ 問目を $ 3 $ 分、$ 2 $ 問目を $ 2 $ 分、$ 3 $ 問目を $ 2 $ 分かけて解く。 - 参加者 $ 2 $ は $ 1 $ 問目を $ 3 $ 分、$ 2 $ 問目を $ 2 $ 分、$ 3 $ 問目を $ 3 $ 分かけて解く。 - 参加者 $ 3 $ は $ 1 $ 問目を $ 3 $ 分、$ 2 $ 問目を $ 2 $ 分、$ 3 $ 問目を $ 1 $ 分かけて解く。

## 样例 #1

### 输入

```
2

3

0 2 1

0 1 2

1 1 1

3

0 2 1

0 0 3

1 1 1
```

### 输出

```
Yes

No
```



---

---
title: "[AGC054D] (ox)"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc054_d
tag: ['动态规划 DP', '贪心']
---

# [AGC054D] (ox)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc054/tasks/agc054_d

`(`, `)`, `o`, `x` からなる文字列 $ S $ が与えられます． あなたは，$ S $ の隣接する $ 2 $ 文字をswapする操作を好きな回数行うことができます． 次の条件を達成するために必要な最小の操作回数を求めてください．

- $ S $ に登場するすべての `o` を `()` で，`x` を `)(` で置き換え，`(` と `)` のみからなる文字列 $ S' $ を作る． この時，$ S' $ は**括弧の対応が取れている文字列**である．
 
括弧の対応が取れている文字列の定義 括弧の対応が取れている文字列とは，次のうちいずれかの条件を満たす文字列です．

- 空文字列
- ある括弧の対応が取れている空でない文字列 $ s,\ t $ が存在し，$ s,\ t $ をこの順に連結した文字列
- ある括弧の対応が取れている文字列 $ s $ が存在し、 `(`, $ s $, `)` をこの順に連結した文字列

なお，この問題の制約より，目標を達成することは必ず可能です．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ S $

## 输出格式

答えを出力せよ．

## 说明/提示

### 制約

- $ S $ は `(`, `)`, `o`, `x` からなる文字列
- $ S $ は $ 1 $ つ以上の `(` と `)` を含み，またそれらの個数は等しい
- $ |S|\ \leq\ 8000 $

### Sample Explanation 1

`)x(` → `x)(` → `x()` → `(x)` と操作すればよいです． このとき，$ S'= $`()()` であり，これは括弧の対応の取れている文字列です．

## 样例 #1

### 输入

```
)x(
```

### 输出

```
3
```

## 样例 #2

### 输入

```
()ox
```

### 输出

```
2
```

## 样例 #3

### 输入

```
()oxo(xxx))))oox((oooxxoxo)oxo)ooo(xxx(oox(x)(x()x
```

### 输出

```
68
```



---

---
title: "[AGC054E] ZigZag Break"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc054_e
tag: ['贪心', '组合数学']
---

# [AGC054E] ZigZag Break

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc054/tasks/agc054_e

整数 $ N,A $ が与えられます． $ (1,2,\cdots,N) $ の順列 $ P=(P_1,P_2,\cdots,P_N) $ であって，以下の条件を満たすものの個数を $ 998244353 $ で割った余りを求めてください．

- $ P_1=A $
- 以下の操作を繰り返すことで，$ P $ の要素数を $ 2 $ にできる．
  - $ 3 $ つの**連続する**要素 $ x,y,z $ を選ぶ． ただしこの時，$ y\ <\ \min(x,z) $ もしくは $ y\ >\ \max(x,z) $ が成り立っている必要がある． そして，$ y $ を $ P $ から消す．

一つの入力ファイルにつき，$ T $ 個のテストケースに答えてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ T $ $ case_1 $ $ case_2 $ $ \vdots $ $ case_T $

各テストケースは以下の形式で与えられる．

> $ N $ $ A $

## 输出格式

各テストケースについて答えを出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 5\ \times\ 10^5 $
- $ 3\ \leq\ N\ \leq\ 10^6 $
- $ 1\ \leq\ A\ \leq\ N $
- 入力される値はすべて整数

### Sample Explanation 1

例えば，$ N=4,A=2 $ の時，$ P=(2,1,4,3) $ は条件を満たします． 以下に手順の例を示します． - $ (x,y,z)=(2,1,4) $ を選び，$ 1 $ を消す．$ P=(2,4,3) $ になる． - $ (x,y,z)=(2,4,3) $ を選び，$ 4 $ を消す．$ P=(2,3) $ になる．

## 样例 #1

### 输入

```
8

3 1

3 2

3 3

4 1

4 2

4 3

4 4

200000 10000
```

### 输出

```
1

2

1

3

5

5

3

621235018
```



---

---
title: "[AGC054F] Decrement"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc054_f
tag: ['贪心']
---

# [AGC054F] Decrement

## 题目描述

给长度为 $N$ 和 $N-1$ 的正整数序列 $A$ 和 $B$，你可以进行以下操作任意次。

* 选择整数 $i$ 和 $j$($1\le i<j\le N$)，将 $A_i,A_j,B_i,B_{i+1}...B_{j-1}$ 减一。需要保证操作后不会出现负数。

令 $m$ 为可以执行的操作的次数的最大值，求出 $m$ 次操作后有多少种本质不同的序列 $A$（对 998244353 取模）。

* $1\le n\le 2\times 10^5$
* $1\le A_i\le 10^9$
* $1\le B_i\le 10^9$

## 样例 #1

### 输入

```
3

1 2 2

1 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4

1 1 1 1

2 2 2
```

### 输出

```
1
```

## 样例 #3

### 输入

```
4

2 2 3 4

3 1 4
```

### 输出

```
3
```



---

---
title: "[AGC055D] ABC Ultimatum"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc055_d
tag: ['动态规划 DP', '贪心', '构造']
---

# [AGC055D] ABC Ultimatum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc055/tasks/agc055_d

`A`, `B`, `C` をそれぞれちょうど $ N $ 個ずつ含む長さ $ 3N $ の文字列 $ T $ が次の条件を満たすとき、$ T $ を**良い**文字列と呼びます: $ T $ を $ N $ 個の長さ $ 3 $ の（連続とは限らない）部分列に分解する方法であって、各部分列が `ABC`, `BCA`, `CAB` のいずれかであるような方法が存在する。

`A`, `B`, `C`, `?` からなる長さ $ 3N $ の文字列 $ S $ が与えられます。各 `?` を `A`, `B`, `C` のいずれかに置き換える方法であって、結果が良い文字列となるようなものの個数を求めてください。この個数は非常に大きい可能性があるため、これを $ 998244353 $ で割った余りを出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $

## 输出格式

答えを $ 998244353 $ で割った余りを出力せよ。

## 说明/提示

### 制約

- $ 1\le\ N\ \le\ 15 $
- $ S $ は、`A`, `B`, `C`, `?` からなる長さ $ 3N $ の文字列である。

### Sample Explanation 1

得られる良い文字列は、`ABC`, `BCA`, `CAB` の $ 3 $ 個です。

### Sample Explanation 2

得られる良い文字列は、`AABBCC`, `AABCBC` の $ 2 $ 個です。

### Sample Explanation 3

`A` が既に $ 4 $ 個含まれるため、良い文字列を得ることはできません。

## 样例 #1

### 输入

```
1

???
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2

AA????
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3

?A?A?A?A?
```

### 输出

```
0
```

## 样例 #4

### 输入

```
9

?????????A??B??C???????????
```

### 输出

```
331653164
```



---

---
title: "[AGC055F] Creative Splitting"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc055_f
tag: ['动态规划 DP', '贪心']
---

# [AGC055F] Creative Splitting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc055/tasks/agc055_f

整数 $ N,\ K $ が与えられます。

長さ $ K $ の整数列 $ a=[a_1,\ a_2,\ \ldots,\ a_K] $ が全ての $ 1\ \le\ i\ \le\ K $ について $ 1\ \le\ a_i\ \le\ i $ を満たすとき、$ a $ を**良い**列と呼びます。

長さ $ NK $ の整数列 $ b=[b_1,\ b_2,\ \ldots,\ b_{NK}] $ が次の条件を満たすとき、$ b $ を**素晴らしい**列と呼びます: $ b $ を $ N $ 個の長さ $ K $ の（連続とは限らない）部分列に分解する方法であって、各部分列が良い列であるような方法が存在する。

$ f(pos,\ val) $ を、$ b_{pos}=val $ であるような素晴らしい列 $ b $ の個数と定義します。

全ての $ 1\le\ pos\ \le\ NK $, $ 1\ \le\ val\ \le\ K $ について $ f(pos,\ val) $ を求めてください。これらの数値は非常に大きい可能性があるため、これらを素数 $ P $ で割った余りを出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ K $ $ P $

## 输出格式

$ NK $ 行出力せよ。$ i $ 行目の $ j $ 個目の数値が $ (f(i,\ j)\ \bmod\ P) $ となるようにすること。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 20 $
- $ 1\ \le\ K\ \le\ 20 $
- $ 10^8\ \le\ P\ \le\ 10^9 $
- $ P $ は素数である。

### Sample Explanation 1

以下の $ 6 $ 個の素晴らしい列が存在します。 - $ [1,\ 1,\ 1,\ 1] $: $ [b_1,\ b_2],\ [b_3,\ b_4] $ に分割できます。 - $ [1,\ 1,\ 1,\ 2] $: $ [b_1,\ b_2],\ [b_3,\ b_4] $ に分割できます。 - $ [1,\ 2,\ 1,\ 1] $: $ [b_1,\ b_2],\ [b_3,\ b_4] $ に分割できます。 - $ [1,\ 2,\ 1,\ 2] $: $ [b_1,\ b_2],\ [b_3,\ b_4] $ に分割できます。 - $ [1,\ 1,\ 2,\ 1] $: $ [b_1,\ b_3],\ [b_2,\ b_4] $ に分割できます。 - $ [1,\ 1,\ 2,\ 2] $: $ [b_1,\ b_3],\ [b_2,\ b_4] $ に分割できます。

## 样例 #1

### 输入

```
2 2 965166677
```

### 输出

```
6 0 

4 2 

4 2 

3 3
```



---

---
title: "[AGC056D] Subset Sum Game"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc056_d
tag: ['数学', '贪心', '博弈论']
---

# [AGC056D] Subset Sum Game

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc056/tasks/agc056_d

黒板に $ N $ 個の整数が書かれており，そのうち $ i $ 番目の整数は $ A_i $ です． なお，$ N $ は偶数です． また，整数 $ L,R $ が与えられます．

Alice と Bob がゲームをします． 二人は Alice からはじめて交互に手番をプレイします． 各手番では，プレイヤーは黒板に書かれている数を一つ選んで消します．

$ N $ ターン後にゲームが終了します． ここで，Alice が消した整数の総和を $ s $ とします． $ L\ \leq\ s\ \leq\ R $ であれば Alice の勝利，そうでなければ Bob の勝利です． 両者が最適に行動した時，どちらが勝つか求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ N $ $ L $ $ R $ $ A_1 $ $ A_2 $ $ \cdots $ $ A_N $

## 输出格式

Alice が勝つ場合は `Alice`，Bob が勝つ場合は `Bob` と出力せよ．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5000 $
- $ N $ は偶数
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- $ 0\ \leq\ L\ \leq\ R\ \leq\ \sum_{1\ \leq\ i\ \leq\ N}\ A_i $
- 入力される値はすべて整数である

### Sample Explanation 1

このゲームでは Alice が必ず勝ちます． ゲームの進行の一例を以下に示します． - Alice が $ 1 $ を消す． - Bob が $ 4 $ を消す． - Alice が $ 5 $ を消す． - Bob が $ 3 $ を消す． この時，Alice が消した整数の総和は $ 6 $ であり，$ L\ \leq\ 6\ \leq\ R $ なので，Alice の勝利です．

## 样例 #1

### 输入

```
4 5 6

3 1 4 5
```

### 输出

```
Alice
```

## 样例 #2

### 输入

```
2 2 3

4 1
```

### 输出

```
Bob
```

## 样例 #3

### 输入

```
30 655 688

42 95 9 13 91 27 99 56 64 15 3 11 5 16 85 3 62 100 64 79 1 70 8 69 70 28 78 4 33 12
```

### 输出

```
Bob
```

## 样例 #4

### 输入

```
30 792 826

81 60 86 57 5 20 26 13 39 64 89 58 43 98 50 79 58 21 27 68 46 47 45 85 88 5 82 90 74 57
```

### 输出

```
Alice
```



---

---
title: "[AGC056F] Degree Sequence in DFS Order"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc056_f
tag: ['贪心', '组合数学']
---

# [AGC056F] Degree Sequence in DFS Order

## 题目描述

已知整数 $N,M$， 求有多少个整数序列 $a=(a_1,a_2,\cdots,a_N)$ 可以由以下方式生成，答案对 $998244353$ 取模。

- 选择一个 $N$ 个点，$M$ 条边的无向连通图 $G$，要求无自环，但可以有重边。
- 进行 DFS，令 $a_i$ 表示遍历到的第 $i$ 个点的度数，具体的，执行以下代码：

```
a = empty array

dfs(v):
    visited[v]=True
    a.append(degree[v])
    for u in g[v]:
        if not visited[u]:
            dfs(u)

dfs(arbitrary root)
```

这里，$g$ 是图 $G$ 的邻接表，$g[v]$ 是任意顺序的与 $v$ 相连的顶点列表。

举个例子，对于 $N=4,M=5$，一个可能的 $a=(2,4,1,3)$，图 $G$ 如下图所示：

![G](https://img.atcoder.jp/agc056/3bfec17f881ae4cd27eccae94ebeae10.png)

顶点上的数字表示访问他们的顺序，橙色箭头表示遍历时经过的边。

## 输入格式

一行两个数 $N,M$。

## 输出格式

一行一个数，表示答案。

### 样例解释 $\textbf 1$

只有 $a=(2,2)$ 合法。


**Translated by @nr0728.**

## 说明/提示

- $2\le N\le M\le 10^6$。

## 样例 #1

### 输入

```
2 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3 4
```

### 输出

```
9
```

## 样例 #3

### 输入

```
10 20
```

### 输出

```
186225754
```

## 样例 #4

### 输入

```
100000 1000000
```

### 输出

```
191021899
```



---

---
title: "[AGC057D] Sum Avoidance"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc057_d
tag: ['贪心', '数论', '最短路']
---

# [AGC057D] Sum Avoidance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc057/tasks/agc057_d

正整数 $ S,\ K $ が与えられます。正整数列 $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ は、次の $ 2 $ 条件を満たすとき、**良い数列**であるといいます。

- $ 1\leq\ A_1\ <\ A_2\ <\ \cdots\ <\ A_N\ \leq\ S\ -\ 1 $ が成り立つ。
- 任意の非負整数列 $ (x_1,\ x_2,\ \ldots,\ x_N) $ に対して $ \sum_{i=1}^NA_ix_i\neq\ S $ が成り立つ。

項数 $ N $ が最大であるような良い数列のうち、辞書順最小のものを $ A\ =\ (A_1,\ A_2,\ \ldots,\ A_N) $ とします。この数列の第 $ K $ 項 $ A_K $ を出力してください。ただし $ K\ >\ N $ である場合には `-1` と出力してください。

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられます。

> $ T $ $ \text{case}_1 $ $ \vdots $ $ \text{case}_T $

各テストケースは以下の形式で与えられます。

> $ S $ $ K $

## 输出格式

$ T $ 行出力してください。$ i $ 行目には、$ \text{case}_i $ に対する答えを出力してください。

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 1000 $
- $ 3\leq\ S\leq\ 10^{18} $
- $ 1\leq\ K\ \leq\ S\ -\ 1 $

### Sample Explanation 1

$ S\ =\ 3,\ 7,\ 10 $ の場合には、$ A $ は次の数列になります。 - $ S=3 $ の場合：$ A\ =\ (2) $ - $ S=7 $ の場合：$ A\ =\ (2,4,6) $ - $ S=10 $ の場合：$ A\ =\ (3,6,8,9) $

## 样例 #1

### 输入

```
13

3 1

3 2

7 1

7 2

7 3

7 4

10 1

10 2

10 3

10 4

10 5

2022 507

1000000000000000000 999999999999999999
```

### 输出

```
2

-1

2

4

6

-1

3

6

8

9

-1

1351

-1
```



---

---
title: "[AGC058E] Nearer Permutation"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc058_e
tag: ['贪心', 'Ad-hoc']
---

# [AGC058E] Nearer Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc058/tasks/agc058_e

この問題では，順列と言った際には，$ (1,2,\cdots,N) $ の順列を指すものとします．

$ 2 $ つの順列 $ p,q $ に対し，それらの距離 $ d(p,q) $ を次のように定義します．

- $ p $ の中で隣接 $ 2 $ 項を swap することを繰り返し，$ p $ を $ q $ に一致させることを考える．この時必要な最小の操作回数を $ d(p,q) $ とする．

さらに，順列 $ x $ に対し，順列 $ f(x) $ を次のように定義します．

- $ y=(1,2,\cdots,N) $ とする．ここで，順列 $ z $ であって，$ d(x,z)\ \leq\ d(y,z) $ を満たすものを考える． これらの中で辞書順最小のものを $ f(x) $ とする．

例えば，$ x=(2,3,1) $ の場合，$ d(x,z)\ \leq\ d(y,z) $ を満たす順列としては，$ z=(2,1,3),(2,3,1),(3,1,2),(3,2,1) $ が考えられます． このうち辞書順最小なのは $ (2,1,3) $ なので， $ f(x)=(2,1,3) $ となります．

順列 $ A=(A_1,A_2,\cdots,A_N) $ が与えられます． $ f(x)=A $ を満たす順列 $ x $ が存在するかどうか判定してください．

$ 1 $ つの入力ファイルにつき，$ T $ 個のテストケースを解いてください．

 数列の辞書順とは？ 相異なる数列 $ S $ と数列 $ T $ の大小を判定するアルゴリズムを以下に説明します。

以下では $ S $ の $ i $ 番目の要素を $ S_i $ のように表します。また、 $ S $ が $ T $ より辞書順で小さい場合は $ S\ \lt\ T $ 、大きい場合は $ S\ \gt\ T $ と表します。

1. $ S $ と $ T $ のうち長さが短い方の文字列の長さを $ L $ とします。$ i=1,2,\dots,L $ に対して $ S_i $ と $ T_i $ が一致するか調べます。
2. $ S_i\ \neq\ T_i $ である $ i $ が存在する場合、そのような $ i $ のうち最小のものを $ j $ とします。そして、$ S_j $ と $ T_j $ を比較して、 $ S_j $ が $ T_j $ より（数として）小さい場合は $ S\ \lt\ T $ 、大きい場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。
3. $ S_i\ \neq\ T_i $ である $ i $ が存在しない場合、 $ S $ と $ T $ の長さを比較して、$ S $ が $ T $ より短い場合は $ S\ \lt\ T $ 、長い場合は $ S\ \gt\ T $ と決定して、アルゴリズムを終了します。

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ T $ $ case_1 $ $ case_2 $ $ \vdots $ $ case_T $

各ケースは以下の形式で与えられる．

> $ N $ $ A_1 $ $ A_2 $ $ \cdots $ $ A_N $

## 输出格式

各ケースに対し，$ f(x)=A $ を満たす順列 $ x $ が存在するならば `Yes` を，存在しないならば `No` を出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 150000 $
- $ 2\ \leq\ N\ \leq\ 300000 $
- $ (A_1,A_2,\cdots,A_N) $ は $ (1,2,\cdots,N) $ の順列
- $ 1 $ つの入力ファイルにつき，$ N $ の総和は $ 300000 $ を超えない
- 入力される値はすべて整数である

### Sample Explanation 1

例えば $ A=(2,1) $ の場合は，$ x=(2,1) $ とすると $ f(x)=A $ となります．

### Sample Explanation 2

例えば $ A=(2,3,1) $ の場合は，$ x=(3,2,1) $ とすると，$ f(x)=A $ となります．

## 样例 #1

### 输入

```
2

2

1 2

2

2 1
```

### 输出

```
Yes

Yes
```

## 样例 #2

### 输入

```
6

3

1 2 3

3

1 3 2

3

2 1 3

3

2 3 1

3

3 1 2

3

3 2 1
```

### 输出

```
Yes

Yes

Yes

Yes

No

No
```

## 样例 #3

### 输入

```
24

4

1 2 3 4

4

1 2 4 3

4

1 3 2 4

4

1 3 4 2

4

1 4 2 3

4

1 4 3 2

4

2 1 3 4

4

2 1 4 3

4

2 3 1 4

4

2 3 4 1

4

2 4 1 3

4

2 4 3 1

4

3 1 2 4

4

3 1 4 2

4

3 2 1 4

4

3 2 4 1

4

3 4 1 2

4

3 4 2 1

4

4 1 2 3

4

4 1 3 2

4

4 2 1 3

4

4 2 3 1

4

4 3 1 2

4

4 3 2 1
```

### 输出

```
Yes

Yes

Yes

Yes

Yes

Yes

Yes

Yes

Yes

Yes

No

No

No

No

No

No

No

No

No

No

No

No

No

No
```



---

---
title: "[AGC059D] Distinct Elements on Subsegments"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc059_d
tag: ['贪心', '差分', 'Ad-hoc']
---

# [AGC059D] Distinct Elements on Subsegments

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc059/tasks/agc059_d

整数列 $ A=(A_1,\ A_2,\ \ldots,\ A_{N\ +\ K-1}) $ ($ 1\ \leq\ A_i\ \leq\ N+K-1 $) に対して、$ B_i $ を $ A_i,A_{i+1},\ldots,A_{i+K-1} $ の中の相異なる要素の個数として、列 $ B=(B_1,\ B_2,\ \ldots,\ B_N) $ を作ります。

$ B_1,\ B_2,\ \ldots,\ B_N $ が与えられます。この列 $ B $ を生成し得た列 $ A $ が存在するか判定し、存在する場合はそのような列 $ A $ を一つ構成してください。

各入力ファイルについて、$ T $ 個のテストケースを解いてください。

## 输入格式

入力は標準入力から以下の形式で与えられる。

> $ T $ $ case_1 $ $ case_2 $ $ \vdots $ $ case_T $

各ケースは以下の形式である。

> $ N $ $ K $ $ B_1 $ $ B_2 $ $ \ldots $ $ B_N $

## 输出格式

各テストケースについて、題意を満たす列 $ A $ が存在しなければ、`NO` と出力せよ。

そうでなければ、答えを次の形式で出力せよ。

> YES $ A_1 $ $ A_2 $ $ \ldots $ $ A_{N+K-1} $

ここで、$ 1\ \leq\ A_i\ \leq\ N+K-1 $ でなければならず、$ A $ は $ B $ を生成するものでなければならない。 複数の解が存在する場合は、そのいずれも認められる。

`YES` または `NO` の出力において、各文字は英大文字・小文字のいずれでもよい。

## 说明/提示

### 制約

- $ 1\ \le\ T\ \le\ 5\ \cdot\ 10^4 $
- $ 2\ \le\ N\ \le\ 2\ \cdot\ 10^5 $
- $ 2\ \le\ K\ \le\ 2\ \cdot\ 10^5 $
- $ 1\ \le\ B_i\ \le\ K $
- 各入力ファイル内の $ N $ の総和は $ 2\cdot\ 10^5 $ を超えない。
- 各入力ファイル内の $ K $ の総和は $ 2\cdot\ 10^5 $ を超えない。
- 入力中のすべての値は整数である。

## 样例 #1

### 输入

```
3

3 3

1 2 1

4 3

1 2 2 1

6 4

3 3 3 3 3 3
```

### 输出

```
NO

YES

1 1 1 2 2 2 

YES

1 2 3 1 2 3 1 2 3
```



---

---
title: "[AGC061D] Almost Multiplication Table"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc061_d
tag: ['贪心', '二分']
---

# [AGC061D] Almost Multiplication Table

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc061/tasks/agc061_d

正の整数 $ N,\ M $ と $ N\ \times\ M $ 正整数行列 $ A_{i,\ j} $ があります。二つの**（狭義）単調増加**正整数列 $ X\ =\ (X_1,\ \ldots,\ X_N),\ Y\ =\ (Y_1,\ \ldots,\ Y_M) $ に対し、ペナルティ $ D(X,\ Y) $ を $ \max_{1\ \leq\ i\ \leq\ N,\ 1\ \leq\ j\ \leq\ M}\ |X_i\ Y_j\ -\ A_{i,\ j}| $ と定義します。

$ D(X,\ Y) $ を最小化する二つの**（狭義）単調増加**正整数列 $ X,\ Y $ を求めてください。

## 输入格式

入力は、標準入力から以下の形式で与えられる。

> $ N $ $ M $ $ A_{1,1} $ $ \ldots $ $ A_{1,M} $ $ \vdots $ $ A_{N,1} $ $ \ldots $ $ A_{N,M} $

## 输出格式

答えを以下の形式で出力せよ。

> $ D_{min} $ $ X_1 $ $ \ldots $ $ X_N $ $ Y_1 $ $ \ldots $ $ Y_M $

ここで、$ D_{min} $ は最小のペナルティであり、また以下の条件が満たされなければならない。

- $ D(X,\ Y) $ は $ D_{min} $ に等しい。
- $ X_i\ <\ X_{i\ +\ 1} $ ($ 1\ \leq\ i\ \leq\ N\ -\ 1 $)
- $ Y_j\ <\ Y_{j\ +\ 1} $ ($ 1\ \leq\ j\ \leq\ M\ -\ 1 $)
- $ 1\ \leq\ X_i\ \leq\ 2\cdot\ 10^9 $ ($ 1\ \leq\ i\ \leq\ N $)
- $ 1\ \leq\ Y_j\ \leq\ 2\cdot\ 10^9 $ ($ 1\ \leq\ j\ \leq\ M $)
 
最後の二条件を満たす最適解が存在することは証明できる。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M\ \leq\ 5 $
- $ 1\ \leq\ A_{i,\ j}\ \leq\ 10^9 $ ($ 1\ \leq\ i\ \leq\ N $, $ 1\ \leq\ j\ \leq\ M $)
- 入力中の値は全て整数である。

## 样例 #1

### 输入

```
1 1

853922530
```

### 输出

```
0

31415

27182
```

## 样例 #2

### 输入

```
3 3

4 4 4

4 4 4

4 4 4
```

### 输出

```
5

1 2 3 

1 2 3
```

## 样例 #3

### 输入

```
3 4

4674 7356 86312 100327

8737 11831 145034 167690

47432 66105 809393 936462
```

### 输出

```
357

129 216 1208 

39 55 670 775
```



---

---
title: "[AGC066D] A Independent Set"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc066_d
tag: ['动态规划 DP', '贪心', '动态规划优化']
---

# [AGC066D] A Independent Set

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc066/tasks/agc066_d

`A`, `B` からなる長さ $ N $ の文字列 $ S $ が与えられます．ただし，$ S $ に含まれる `A` の個数は $ \frac{N+1}{2} $ 以下であることが保証されます．さらに，正整数列 $ (x_1,\ \ldots,\ x_{N-1}) $ が与えられます．

あなたはこの文字列に対して，次の操作を繰り返し行うことができます：

- $ 1\leq\ i\leq\ N-1 $ を満たす整数 $ i $ を選び，$ S $ の $ i $ 文字目と $ (i+1) $ 文字目をスワップする．この操作にはコストが $ x_i $ かかる．
 
あなたの目標は，$ S $ において `A` 同士が隣接しないようにすることです．この目標を達成するために必要なコストの総和としてありうる最小値を求めてください．

$ T $ 個のテストケースが与えられるので，それぞれについて答えを求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられます．

> $ T $ $ \text{case}_1 $ $ \vdots $ $ \text{case}_T $

各テストケースは以下の形式で与えられます．

> $ N $ $ S $ $ x_1 $ $ \ldots $ $ x_{N-1} $

## 输出格式

$ T $ 行出力してください．$ i $ 行目には $ i $ 番目のテストケースについて，$ S $ において `A` が隣接しないようにするために必要なコストの最小値を出力してください．

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 10^5 $
- $ 2\leq\ N\leq\ 10^6 $
- $ S $ は `A`, `B` からなる長さ $ N $ の文字列である．
- $ S $ に含まれる `A` の個数は $ \frac{N+1}{2} $ 以下である．
- $ 1\leq\ x_i\ \leq\ 10^6 $
- $ 1 $ 個の入力に含まれるテストケースについて，それらの $ N $ の総和は $ 10^6 $ 以下である．
 
### Sample Explanation 1

\- $ 1 $ 番目のテストケースについて，$ i=1 $ として操作を行うことで $ S $ は `BAAB` → `ABAB` と変化し，目標を達成できます．この場合コストの総和は $ x_1=3 $ です． - $ 2 $ 番目のテストケースについて，操作を行わないことで目標を達成できます．この場合コストの総和は $ 0 $ です． - $ 3 $ 番目のテストケースについて，$ i=1 $, $ i=4 $ として操作を行うことで $ S $ は `BAAABBB` → `ABAABBB` → `ABABABB` と変化し，目標を達成できます．この場合コストの総和は $ x_1+x_4=13 $ です． - $ 4 $ 番目のテストケースについて，$ i=4 $, $ i=3 $, $ i=5 $ として操作を行うことで $ S $ は `BAAABBB` → `BAABABB` → `BABAABB` → `BABABAB` と変化し，目標を達成できます．この場合コストの総和は $ x_4+x_3+x_5=15 $ です．

## 样例 #1

### 输入

```
5

4

BAAB

3 4 5

5

BBBBB

1 2 3 4

7

BAAABBB

8 7 6 5 4 3

7

BAAABBB

100 7 6 5 4 3

20

BAABAABBBABAAABBBABB

12 85 37 44 25 14 36 29 71 53 15 47 13 80 14 74 53 76 19
```

### 输出

```
3

0

13

15

133
```



---

---
title: "[AGC066F] Beautiful String"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc066_f
tag: ['贪心', '差分']
---

# [AGC066F] Beautiful String

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc066/tasks/agc066_f

次の条件を満たす文字列を，**美しい文字列**ということにします．

- どの文字も `A`, `B`, `C` のいずれかである．
- どの隣接する $ 2 $ 文字も相異なる．
 
例えば `AB`, `BCAC` は美しい文字列です．`BB`, `CBAAC` は美しい文字列ではありません．

- - - - - -

美しい文字列 $ S $ が与えられます．あなたはこの文字列に対して，次の操作を繰り返し行うことができます：

- 操作：$ S $ の隣接する $ 2 $ 文字をスワップする．ただしスワップ後の $ S $ も美しい文字列でなくてはならない．
 
最終的な文字列 $ S $ としてありうる辞書順最小の文字列を求めてください．

$ T $ 個のテストケースが与えられるので，それぞれについて答えを求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられます．

> $ T $ $ \text{case}_1 $ $ \vdots $ $ \text{case}_T $

各テストケースは以下の形式で与えられます．

> $ S $

## 输出格式

$ T $ 行出力してください．$ i $ 行目には $ i $ 番目のテストケースについて，最終的な文字列 $ S $ としてありうる辞書順最小の文字列を出力してください．

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 10^5 $
- $ S $ は美しい文字列である．
- $ 1\leq\ |S|\leq\ 10^6 $
- $ 1 $ 個の入力に含まれるテストケースについて，それらの $ |S| $ の総和は $ 10^6 $ 以下である．
 
### Sample Explanation 1

$ 1 $ 番目，$ 2 $ 番目のテストケースについて，次が $ S $ を辞書順最小化する方法の一例となります． - `CAB` → `ACB` → `ABC` - `ACBCB` → `CABCB` → `CBACB` → `BCACB` → `BCABC` → `BACBC` → `ABCBC`

## 样例 #1

### 输入

```
8

CAB

ACBCB

B

AC

BACBA

BABABA

ABCBCAC

CBABACABCBABABC
```

### 输出

```
ABC

ABCBC

B

AC

ABABC

BABABA

ABCACBC

ABABACBCACBCBAB
```



---

---
title: "[AGC069D] Tree and Intervals"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_agc069_d
tag: ['动态规划 DP', '贪心', 'Ad-hoc']
---

# [AGC069D] Tree and Intervals

## 题目描述

给出两个整数 $N$ 和素数 $P$。

我们有一棵由 $N$ 个节点组成的树，节点的编号从 $1$ 到 $N$。树有 $N-1$ 条边，每条边连接两个节点，记为 $a_i$ 和 $b_i\ (1 \leq i \leq N-1)$。接下来，我们定义 $x_j\ (1 \leq j \leq N-1)$ 为：

- 满足 $\min(a_i, b_i) \leq j < \max(a_i, b_i)$ 的边数，个数记为 $x_j$。

你的任务是计算可能的 $(x_1, x_2, \ldots, x_{N-1})$ 组合的数量，并输出此数量除以 $P$ 的余数。

## 输入格式

输入由以下形式给出：

> $N$ $P$

## 输出格式

输出答案，表示所求数量除以 $P$ 的余数。

## 说明/提示

### 约束

- $2 \leq N \leq 500$
- $10^8 \leq P \leq 10^9$
- $P$ 是素数

### 示例解释

对于一个包含 $3$ 个节点的树，总共有 $3$ 种不同的构型，不区分边，仅区分节点。每种构型对应的 $(x_1, x_2)$ 分别为 $(1, 1), (2, 1), (1, 2)$。因此，输出的结果应该是 $3$ 对 $P=998244353$ 取模的余数。

请计算上述结果并输出。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
3 998244353
```

### 输出

```
3
```

## 样例 #2

### 输入

```
69 433416647
```

### 输出

```
243082757
```



---

---
title: "XOR Tree"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_apc001_f
tag: ['贪心', '枚举', '状态合并']
---

# XOR Tree

## 题目描述

给一棵有 $N$ 个节点的树，节点编号从 $0$ 到 $N-1$，
树边编号从 $1$ 到 $N-1$。第 $i$ 条边连接节点 $x_i$ 和 $y_i$，其权值为 $a_i$。

你可以对树执行任意次操作，每次操作选取一条链和一个非负整数 $x$，将链上的边的权值与 $x$ 异或成为该边的新权值。

问最少需要多少次操作，使得所有边的权值都为 $0$。

## 输入格式

第一行有 $1$ 个整数，代表树的节点数 $N$。

接下来 $N-1$ 行，每行有 $3$ 个整数，第 $i+1$ 行上的整数分别代表第 $i$ 条边的参数 $x_i,y_i,a_i$。

## 输出格式

仅一行 $1$ 个整数，即最小操作数。

## 说明/提示

- $2\leq N \leq 10^5$
- $0\leq x_i,y_i \leq N-1$
- $0\leq a_i \leq 15$
- 保证给定的图是一棵树
- 保证输入数据都是整数

## 样例 #1

### 输入

```
5

0 1 1

0 2 3

0 3 6

3 4 4
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2

1 0 0
```

### 输出

```
0
```



---

---
title: "[ARC157F] XY Ladder LCS"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc157_f
tag: ['动态规划 DP', '贪心', '动态规划优化', '标签464']
---

# [ARC157F] XY Ladder LCS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc157/tasks/arc157_f

`X`, `Y` からなる長さ $ N $ の文字列 $ S,\ T $ が与えられます． 各 $ i\ =\ 1,\ 2,\ \dots,\ N $ に関して，$ S $ の $ i $ 文字目と $ T $ の $ i $ 文字目を入れ替えるかどうかを自由に選べます． このとき，結果として得られる文字列の組はのべ $ 2^N $ 通りありますが，そのいずれかの共通部分列（連続とは限らない）となる文字列のうち最長のものを求めてください． ただし，そのような文字列が複数ある場合，そのうち辞書順で最初に現れるものを求めてください．

  共通部分列とは 文字列 $ S $ の**部分列**とは，$ S $ から $ 0 $ 個以上の文字を削除して，残った文字を元の順で並べて得られる文字列のことをいいます． 文字列 $ S,\ T $ の**共通部分列**とは，$ S $ と $ T $ のどちらの部分列でもあるような文字列のことをいいます． （出力例 1 の説明も参考にしてください．）

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ N $ $ S $ $ T $

## 输出格式

入れ替え後の文字列の組の共通部分列としてあり得る最長の文字列のうち，辞書順で最初に現れるものを出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 50 $
- $ S,\ T $ はそれぞれ `X`, `Y` からなる長さ $ N $ の文字列である．
 
### Sample Explanation 1

\- どの文字も入れ替えない場合，`XXX` と `YYY` の共通部分列は空文字列のみです． - $ 1 $ 文字目だけを入れ替えた場合，`YXX` と `XYY` の共通部分列は，空文字列, `X`, `Y` です． - $ 2 $ 文字目だけを入れ替えた場合，`XYX` と `YXY` の共通部分列は，空文字列, `X`, `Y`, `XY`, `YX` です． - $ 3 $ 文字目だけを入れ替えた場合，`XXY` と `YYX` の共通部分列は，空文字列, `X`, `Y` です． $ 2 $ 文字以上の入れ替えは，$ S $ と $ T $ 自体を入れ替えて考えれば上記のいずれかに該当します． したがって，共通部分列としてあり得る最長の文字列は `XY` と `YX` であり，辞書順で最初に現れる `XY` が答えとなります．

### Sample Explanation 2

答えが空文字列となることもあります．

### Sample Explanation 3

たとえば $ 2 $ 文字目だけを入れ替えた場合に `XYY` が共通部分列となります． より長い文字列，あるいは，同じ長さであって辞書順でより早く現れる文字列は，どのように入れ替えたとしても共通部分列にはなり得ないため，これが答えとなります．

## 样例 #1

### 输入

```
3

XXX

YYY
```

### 输出

```
XY
```

## 样例 #2

### 输入

```
1

X

Y
```

### 输出

```

```

## 样例 #3

### 输入

```
4

XXYX

YYYY
```

### 输出

```
XYY
```



---

---
title: "[ARC163F] Many Increasing Problems"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc163_f
tag: ['贪心', '多项式', '容斥原理', '快速数论变换 NTT']
---

# [ARC163F] Many Increasing Problems

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc163/tasks/arc163_f

PCT 君は以下の問題を作りました。

> **Increasing Problem**長さ $ N $ の非負整数列 $ A_1,A_2,\dots,A_N $ が与えられます。あなたは以下の操作を好きな回数（$ 0 $ 回でもよい）行うことが出来ます。
> 
> - $ 1\ \le\ i\ \le\ N $ を満たす整数 $ i $ を $ 1 $ 個選び、$ A_i $ を $ 1 $ 増やすか $ 1 $ 減らす。
>  
> あなたの目標は $ A $ を広義単調増加にすることです。目標を達成するために必要な最小の操作回数を求めてください。

この問題がコンテストの最後に置くには簡単だと考えた PCT 君は、以下のように改題しました。

> **Many Increasing Problems**長さ $ N $ かつ全ての要素が $ 1 $ 以上 $ M $ 以下であるような整数列 $ A $ は $ M^N $ 個ありますが、その全てに対する **Increasing Problem** の答えの総和を $ 998244353 $ で割ったあまりを求めてください。

**Many Increasing Problems** を解いてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $

## 输出格式

**Many Increasing Problems** の答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \le\ N,M\ \le\ 10^5 $
 
### Sample Explanation 1

長さが $ 2 $ かつ全ての要素が $ 1 $ 以上 $ 2 $ 以下である数列全てに対して \*\*Increasing Problem\*\* を解きます。 - $ A=(1,1) $ の時の解は $ 0 $ - $ A=(1,2) $ の時の解は $ 0 $ - $ A=(2,1) $ の時の解は $ 1 $ - $ A=(2,2) $ の時の解は $ 0 $ よって、答えは $ 0+0+1+0=1 $ です。

## 样例 #1

### 输入

```
2 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
6 4
```

### 输出

```
14668
```

## 样例 #3

### 输入

```
163 702
```

### 输出

```
20728656
```

## 样例 #4

### 输入

```
98765 99887
```

### 输出

```
103564942
```



---

---
title: "[ARC164F] Subtree Reversi"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc164_f
tag: ['贪心', '博弈论']
---

# [ARC164F] Subtree Reversi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc164/tasks/arc164_f

頂点に $ 1 $ から $ N $ までの番号がついており、頂点 $ 1 $ を根とする $ N $ 頂点の根付き木が与えられます。 この木の頂点 $ i $ の親は頂点 $ p_i $ です（$ 2\leq\ i\leq\ N $）。

Alice と Bob は、この木を使って、次のようなゲームを行います。

- Alice が先手、Bob が後手で、表裏を白と黒に塗り分けた石を使い、交互に $ 1 $ つずつ木の頂点に石を置いていく。この際、Alice は白い面を上に、Bob は黒い面を上にして置く。
- 各手番で石を置いてよいのは、その頂点自身には石が置かれておらず、子孫である頂点には全て石が置かれている頂点のみである。
- 石を置くとき、置いた頂点の子孫にある石を全て裏返す（置いた石自体は裏返さない）。
 
全ての頂点に石が置かれるとゲーム終了となり、この時点で白い面が上になっている石の数を Alice の得点とします。

Alice はできるだけ大きな得点を得ようとし、Bob は Alice の得点をできるだけ小さくしようとします。両者が最善の手順を取ったとき、Alice の得点はいくらでしょうか。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ p_2 $ $ p_3 $ $ \ldots $ $ p_N $

## 输出格式

答えを整数で出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ p_i\ <\ i $ $ (2\leq\ i\ \leq\ N) $
- 入力される値はすべて整数である
- 与えられるグラフは木である
 
### Sample Explanation 1

与えられた木では、初めに石を置くことのできる頂点は $ 3,4 $ のみです。ここから、例えば次のような進行が考えられます。 - Alice が頂点 $ 4 $ に白い面を上にして石を置く。この操作の後、頂点 $ 2 $ は子孫に全て石が置かれたので、石が置けるようになる。 - Bob が頂点 $ 2 $ に黒い面を上にして石を置き、頂点 $ 4 $ にある石を裏返して黒い面を上にする。 - Alice が頂点 $ 3 $ に白い面を上にして石を置く。 - Bob が頂点 $ 1 $ に黒い面を上にして石を置き、頂点 $ 2,3,4 $ にある石を全て裏返す。 この場合、ゲーム終了時に頂点 $ 1,2,3,4 $ にある石はそれぞれ黒、白、黒、白が上になっています。実は、この進行は双方の最善手の一例であり、答えは $ 2 $ となります。

## 样例 #1

### 输入

```
4

1 1 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
7

1 1 2 4 4 4
```

### 输出

```
5
```



---

---
title: "[ARC169E] Avoid Boring Matches"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc169_e
tag: ['贪心']
---

# [ARC169E] Avoid Boring Matches

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc169/tasks/arc169_e

$ 1 $ から $ 2^N $ までの番号のついた $ 2^N $ 人の参加者がいる大会があります．

大会は次のように進行します．

- まず最初に，それぞれの参加者に赤または青の帽子をかぶせる． ここで，各参加者にかぶせる帽子の色は文字列 $ S $ によって与えられる． 具体的には，$ S $ の $ i $ 文字目 ($ 1\ \leq\ i\ \leq\ 2^N $) が `R` のときは赤い帽子を，`B` のときは青い帽子を参加者 $ i $ にかぶせる．
- その後，参加者が $ 1 $ 人になるまで以下の操作を繰り返す．
  
  
  - 現在の参加者の人数を $ 2k $ 人とする．参加者を $ k $ 個の $ 2 $ 人組に分ける． この組分けはあなたが自由に選ぶことができる． そしてそれぞれの組で試合を行い，勝者は残り，敗者は大会から去る． なお，参加者は強さ順に番号づけられているため，必ず番号の**小さい**参加者が勝利する．
 
あなたは，赤い帽子をかぶった参加者同士の試合を**つまらない**試合と呼んでいます． あなたの目標は，大会中につまらない試合が発生しないように各組分けを行うことです．

目標が達成可能であるか否かは文字列 $ S $ に依存します． そこであなたは，大会の開始前に $ S $ に細工することにしました． 具体的には，あなたは次の操作を $ 0 $ 回以上行えます．

- $ S $ 中の隣接する $ 2 $ 文字を選び，入れ替える．
 
操作の結果目標を達成することが可能かどうか判定してください． また，可能な場合は必要な最小の操作回数を求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ N $ $ S $

## 输出格式

目標を達成することが不可能な場合は $ -1 $ を出力せよ． 可能な場合は必要な最小の操作回数を出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 18 $
- $ S $ は `R`, `B` からなる長さ $ 2^N $ の文字列．
- 入力される値はすべて整数．
 
### Sample Explanation 1

操作を $ 1 $ 回も行わないと，目標を達成することができません． $ S $ の $ 2 $ 文字目と $ 3 $ 文字目を入れ替える操作を行い，$ S= $`RBRB` とすると，以下のようにして目標を達成できます． - 参加者 $ 1,2,3,4 $ にそれぞれ 赤,青,赤,青 の帽子をかぶせる． - $ 4 $ 人の参加者を $ 2 $ つの組 $ (1,4),(2,3) $ に分ける． ここでつまらない試合は発生しない． 試合の結果，参加者 $ 1,2 $ が勝ち残る． - $ 2 $ 人の参加者を $ 1 $ つの組 $ (1,2) $ に分ける． ここでつまらない試合は発生しない． 試合の結果，参加者 $ 1 $ が勝ち残る． よって答えは $ 1 $ です．

## 样例 #1

### 输入

```
2

RRBB
```

### 输出

```
1
```

## 样例 #2

### 输入

```
1

RR
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
4

RBBRRBRBBRBBBRBR
```

### 输出

```
0
```

## 样例 #4

### 输入

```
5

RBRRBRRRBRRRRRRRRRBBBBBBBBBBBBBB
```

### 输出

```
11
```



---

---
title: "[ARC170F] Edge Deletion 2"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_arc170_f
tag: ['图论', '贪心']
---

# [ARC170F] Edge Deletion 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc170/tasks/arc170_f

頂点に $ 1 $ から $ N $ の番号が付いた $ N $ 頂点の木が与えられます．木の $ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結んでいます．

$ (1,2,\ldots,N) $ の順列 $ P=(P_1,\ldots,P_N) $ に対し，数列 $ A(P) $ を以下で定義します．

- $ A(P) $ は初め空である．全ての頂点 $ i $ に $ P_i $ を書き込む．
- $ i=1,2,\ldots,N $ の順に以下を行う．
  - 頂点 $ i $ が孤立点の場合，$ 0 $ を $ A(P) $ の末尾に追加する．そうでない場合，頂点 $ i $ に隣接する頂点であって，書かれている整数が最も小さいものを選ぶ．選んだ頂点に書かれた整数を $ A(P) $ の末尾に追加し，頂点 $ i $ と選んだ頂点を結ぶ辺を削除する．
 
$ A(P) $ として考えられる数列のうち，辞書順最小のものを求めてください．

$ T $ 個のテストケースが与えられるので，それぞれについて答えてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ T $ $ \mathrm{case}_1 $ $ \vdots $ $ \mathrm{case}_T $

各ケースは以下の形式で与えられる．

> $ N $ $ u_1 $ $ v_1 $ $ u_2 $ $ v_2 $ $ \vdots $ $ u_{N-1} $ $ v_{N-1} $

## 输出格式

$ T $ 行出力せよ．$ i $ 行目 $ (1\ \leq\ i\ \leq\ T) $ には， $ i $ 番目のテストケースの答えを出力せよ．

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 10^5 $
- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\leq\ u_i,v_i\leq\ N $
- 与えられるグラフは木である
- 入力される数値は全て整数
- $ 1 $ つの入力に含まれるテストケースについて，$ N $ の総和は $ 2\times\ 10^5 $ 以下
 
### Sample Explanation 1

$ 1 $ 番目のテストケースでは，$ P=(4,1,2,3,5) $ に対し，$ A(P)=(1,2,0,1,3) $ は以下の方法で得られます． - 頂点 $ 1 $ に隣接する頂点であって，書かれている整数が最も小さいものは頂点 $ 2 $ である．$ A(P) $ の末尾に $ P_2=1 $ を追加し，頂点 $ 1 $ と頂点 $ 2 $ を結ぶ辺を削除する． - 頂点 $ 2 $ に隣接する頂点であって，書かれている整数が最も小さいものは頂点 $ 3 $ である．$ A(P) $ の末尾に $ P_3=2 $ を追加し，頂点 $ 2 $ と頂点 $ 3 $ を結ぶ辺を削除する． - 頂点 $ 3 $ は孤立点なので，$ A(P) $ の末尾に $ 0 $ を追加する． - 頂点 $ 4 $ に隣接する頂点であって，書かれている整数が最も小さいものは頂点 $ 2 $ である．$ A(P) $ の末尾に $ P_2=1 $ を追加し，頂点 $ 4 $ と頂点 $ 2 $ を結ぶ辺を削除する． - 頂点 $ 5 $ に隣接する頂点であって，書かれている整数が最も小さいものは頂点 $ 4 $ である．$ A(P) $ の末尾に $ P_4=3 $ を追加し，頂点 $ 5 $ と頂点 $ 4 $ を結ぶ辺を削除する． これが $ A(P) $ として考えられる数列のうち，辞書順最小であることが証明できます．

## 样例 #1

### 输入

```
3

5

1 2

2 3

2 4

4 5

8

8 6

7 2

2 1

3 7

5 6

1 6

4 3

7

7 1

5 2

1 2

6 5

4 1

5 3
```

### 输出

```
1 2 0 1 3

1 2 2 3 1 4 0 0

1 2 2 0 3 0 4
```



---

---
title: "Largest Smallest Cyclic Shift"
layout: "post"
diff: NOI/NOI+/CTSC
pid: AT_code_festival_2017_qualb_f
tag: ['字符串', '贪心']
---

# Largest Smallest Cyclic Shift

## 题目描述

对于字符串 $S$，定义 $f(S)$ 为 $S$ 的所有循环移位中字典序最小的一个。例如，当 $S =$ `babca` 时，$S$ 的循环移位（`babca`, `abcab`, `bcaba`, `cabab`, `ababc`）中，字典序最小的是 `ababc`，因此 $f(S) =$ `ababc`。

给定三个整数 $X, Y, Z$，你需要构造一个包含恰好 $X$ 个字符 `a`，$Y$ 个字符 `b`，和 $Z$ 个字符 `c` 的字符串 $T$。如果有多个这样的字符串，你需要使得 $f(T)$ 在字典序上尽可能大。

求出 $f(T)$ 的字典序最大值。

## 输入格式

输入将以以下形式从标准输入中提供：

> $X$ $Y$ $Z$

## 输出格式

输出答案。

### 约束

- $1 \le X + Y + Z \le 50$
- $X, Y, Z$ 是非负整数。

### 样例解释 1

字符串 $T$ 必须由两个 `a` 和两个 `b` 构成。
- 当 $T =$ `aabb` 时，$f(T) =$ `aabb`。
- 当 $T =$ `abab` 时，$f(T) =$ `abab`。
- 当 $T =$ `abba` 时，$f(T) =$ `aabb`。
- 当 $T =$ `baab` 时，$f(T) =$ `aabb`。
- 当 $T =$ `baba` 时，$f(T) =$ `abab`。
- 当 $T =$ `bbaa` 时，$f(T) =$ `aabb`。

因此，$f(T)$ 的最大值是 `abab`。

---

Translated by User 735713.

## 样例 #1

### 输入

```
2 2 0
```

### 输出

```
abab
```

## 样例 #2

### 输入

```
1 1 1
```

### 输出

```
acb
```



---


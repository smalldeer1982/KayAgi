---
title: "[ABC383E] Sum of Max Matching"
layout: "post"
diff: 提高+/省选-
pid: AT_abc383_e
tag: ['贪心', '并查集', '生成树']
---

# [ABC383E] Sum of Max Matching

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc383/tasks/abc383_e

頂点に $ 1 $ から $ N $ の番号が、辺に $ 1 $ から $ M $ の番号が付いた $ N $ 頂点 $ M $ 辺の重み付き単純連結無向グラフが与えられます。辺 $ i $ $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結び、重みは $ w_i $ です。

あるパスに対してその重みをそのパスに含まれる辺の重みの最大値とします。 また、$ f(x,y) $ を 頂点 $ x $ から頂点 $ y $ へのパスの重みとしてありえる最小値とします。

長さ $ K $ の数列 $ (A_1,A_2,\ldots,A_K) $ と $ (B_1,B_2,\ldots,B_K) $ が与えられます。ここで、$ A_i\ \neq\ B_j $ $ (1\ \leq\ i,j\ \leq\ K) $ が成り立つことが保証されます。

数列 $ B $ を自由に並べ替えて、$ \displaystyle\sum_{i=1}^{K}f(A_i,B_i) $ を最小化してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

>$ N $ $ M $ $ K $
>
>$ u_1 $ $ v_1 $ $ w_1 $
>
>$ u_2 $ $ v_2 $ $ w_2 $
>
>$ \vdots $
>
>$ u_M $ $ v_M $ $ w_M $
>
>$ A_1 $ $ A_2 $ $ \ldots $ $ A_K $
>
>$ B_1 $ $ B_2 $ $ \ldots $ $ B_K $


## 输出格式

$ \displaystyle\sum_{i=1}^{K}f(A_i,B_i) $ の最小値を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \min(\frac{N\ \times\ (N-1)}{2},2\ \times\ 10^5) $
- $ 1\ \leq\ K\ \leq\ N $
- $ 1\ \leq\ u_i\ <\ v_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ 1\ \leq\ w_i\ \leq\ 10^9 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ K) $
- $ A_i\ \neq\ B_j $ $ (1\ \leq\ i,j\ \leq\ K) $
- 与えられるグラフは単純かつ連結
- 入力は全て整数

### Sample Explanation 1

$ B $ を並び替えて、$ B=(2,4,4) $ としたとき、 - $ f(1,2)=5 $ : 頂点 $ 1 $ から頂点 $ 4 $ を経由し頂点 $ 2 $ に行くパスがあり、辺 $ 3 $ の重み $ 5 $ が最大値を取ります。また、辺の重みの最大値が $ 4 $ 以下になるようなパスは存在しないため $ 5 $ が最小値です。 - $ f(1,4)=2 $ : 頂点 $ 1 $ から頂点 $ 3 $ を経由し頂点 $ 4 $ に行くパスがあり、辺 $ 1 $ の重み $ 2 $ が最大値を取ります。また、辺の重みの最大値が $ 1 $ 以下になるようなパスは存在しないため $ 2 $ が最小値です。 - $ f(3,4)=1 $ : 頂点 $ 3 $ から頂点 $ 4 $ への辺を通るパスがあり、辺の重みは $ 1 $ でこれが辺の重みの最大値です。また、パスの重みが $ 0 $ 以下になることはないため $ 1 $ が最小値です。 よって、この場合 $ \displaystyle\ \sum_{i=1}^{3}f(A_i,B_i)=5+2+1=8 $ となります。また、$ B $ をどのように並び替えても $ 7 $ 以下になることはないため、答えは $ 8 $ です。

## 样例 #1

### 输入

```
4 4 3
1 3 2
3 4 1
2 4 5
1 4 4
1 1 3
4 4 2
```

### 输出

```
8
```

## 样例 #2

### 输入

```
3 3 2
1 2 5
2 3 2
1 3 1
1 1
2 3
```

### 输出

```
3
```



---

---
title: "[ARC124D] Yet Another Sorting Problem"
layout: "post"
diff: 提高+/省选-
pid: AT_arc124_d
tag: ['贪心', '并查集', '图论建模', 'Ad-hoc']
---

# [ARC124D] Yet Another Sorting Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc124/tasks/arc124_d

$ (1,2\ \ldots,\ N+M) $ を並べ替えて得られる長さ $ N+M $ の数列 $ p $ が与えられます。 $ p $ の $ i $ 番目の数は $ p_i $ です。

あなたは以下の **操作** を何回でも行うことができます。

操作：$ 1 $ 以上 $ N $ 以下の整数 $ n $ と $ 1 $ 以上 $ M $ 以下の整数 $ m $ を選び、$ p_{n} $ と $ p_{N+m} $ を交換する

$ p $ を昇順に並べ替えるために必要な最小の操作回数を求めてください。この問題の制約下で $ p $ を昇順に並べ替えることができることが証明できます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ p_{1} $ $ \cdots $ $ p_{N+M} $

## 输出格式

$ p $ を昇順に並べ替えるために必要な最小の操作回数を出力せよ。

## 说明/提示

### 制約

- 与えられる入力は全て整数
- $ 1\ \leq\ N,M\ \leq\ 10^5 $
- $ 1\ \leq\ p_i\ \leq\ N+M $
- $ p $ は $ (1,2\ \ldots,\ N+M) $ を並べ替えて得られる

## 样例 #1

### 输入

```
2 3

1 4 2 5 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5 7

9 7 12 6 1 11 2 10 3 8 4 5
```

### 输出

```
10
```



---

---
title: "[ARC167D] Good Permutation"
layout: "post"
diff: 提高+/省选-
pid: AT_arc167_d
tag: ['贪心', '并查集']
---

# [ARC167D] Good Permutation

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc167/tasks/arc167_d

この問題では順列と言った際には $ (1,2,\dots\ ,N) $ の順列を指すものとします。

順列 $ P=(P_{1},P_{2},\dots\ ,P_{N}) $ が与えられます。

ここで、以下の条件を満たす順列 $ Q=(Q_{1},Q_{2},\dots\ ,Q_{N}) $ を良い順列とします。

- 任意の整数 $ 1\leq\ x\leq\ N $ について、 $ x\leftarrow\ Q_{x} $ という置換を好きな回数繰り返すことで、 $ x $ を $ 1 $ にすることができる。
 
$ P $ に対して、以下の操作を $ 0 $ 回以上行うことで、 $ P $ を良い順列にしたいです。

- $ 1\leq\ i\lt\ j\ \leq\ N $ を満たす整数 $ i,j $ を選んで、 $ P_{i} $ と $ P_{j} $ を入れ替える
 
$ P $ を良い順列にするのに必要な最小の操作回数を $ M $ としたとき、 $ P $ に対し操作を $ M $ 回行うことで得られる良い順列のうち、辞書式順序で最小のものを求めてください。

$ 1 $ つの入力ファイルにつき $ T $ 個のテストケースが与えられるので、それぞれについて解いてください。

  数列の辞書順とは？数列 $ S\ =\ (S_1,S_2,\ldots,S_{|S|}) $ が数列 $ T\ =\ (T_1,T_2,\ldots,T_{|T|}) $ より**辞書順で小さい**とは、下記の 1. と 2. のどちらかが成り立つことを言います。 ここで、$ |S|,\ |T| $ はそれぞれ $ S,\ T $ の長さを表します。

1. $ |S|\ \lt\ |T| $ かつ $ (S_1,S_2,\ldots,S_{|S|})\ =\ (T_1,T_2,\ldots,T_{|S|}) $。
2. ある整数 $ 1\ \leq\ i\ \leq\ \min\lbrace\ |S|,\ |T|\ \rbrace $ が存在して、下記の $ 2 $ つがともに成り立つ。 
  - $ (S_1,S_2,\ldots,S_{i-1})\ =\ (T_1,T_2,\ldots,T_{i-1}) $
  - $ S_i $ が $ T_i $ より（数として）小さい。

## 输入格式

入力は以下の形式で標準入力から与えられます。

> $ T $ $ \text{case}_{1} $ $ \text{case}_{2} $ $ \vdots $ $ \text{case}_{T} $

各ケースは以下の形式で与えられます。

> $ N $ $ P_{1} $ $ P_{2} $ $ \cdots $ $ P_{N} $

## 输出格式

$ T $ 行出力してください。 $ i $ 行目には $ \text{case}_{i} $ に対する答えの良い順列を空白区切りで出力してください。

## 说明/提示

### 制約

- $ 1\leq\ T\leq\ 10^{5} $
- $ 2\leq\ N\leq\ 2\times\ 10^{5} $
- $ (P_{1},P_{2},\dots\ ,P_{N}) $ は $ (1,2,\dots\ ,N) $ の順列
- $ 1 $ つの入力ファイルにつき、 $ N $ の総和は $ 2\times\ 10^{5} $ を超えない
- 入力は全て整数
 
### Sample Explanation 1

$ 1 $ つ目のテストケースについて $ P $ は良い順列ではありません。$ P_{1} $ と $ P_{3} $ を入れ替えると $ P=(4,1,2,3) $ となりますがこのとき $ P $ は良い順列となるので、 $ M=1 $ です。 他にも $ P_{2} $ と $ P_{4} $ を入れ替えると $ P=(2,3,4,1) $ となりますが、これは $ M=1 $ 回の操作で得られる良い順列のうち辞書順で最も小さいものになるため、これが答えです。

## 样例 #1

### 输入

```
5

4

2 1 4 3

5

2 1 3 4 5

2

1 2

2

2 1

9

4 3 6 2 7 1 9 8 5
```

### 输出

```
2 3 4 1

2 3 4 5 1

2 1

2 1

4 3 5 2 7 1 8 9 6
```



---

---
title: "[ARC188C] Honest or Liar or Confused"
layout: "post"
diff: 提高+/省选-
pid: AT_arc188_c
tag: ['并查集', '2-SAT']
---

# [ARC188C] Honest or Liar or Confused

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc188/tasks/arc188_c

$ 1 $ から $ N $ までの番号がついた $ N $ 人の村人が住む村があります。 各村人は、正直者であるか嘘つきであるかのどちらかです。また、村人のうち何人かは混乱しています。

あなたは、村人による証言を $ M $ 個手に入れました。この証言は、$ i=1,2,\ \ldots\ ,M $ に対して $ A_i,\ B_i,\ C_i $ で与えられ、

- $ C_i=0 $ であれば、村人 $ A_i $ が村人 $ B_i $ を正直者であると証言したこと
- $ C_i=1 $ であれば、村人 $ A_i $ が村人 $ B_i $ を嘘つきであると証言したこと

を表します。

全ての村人は、他の全ての村人について正直者と嘘つきのどちらであるかを知っており、あなたに対して次のような規則で証言を行ったことが分かっています。

- 混乱していない正直者は必ず正しい証言をする。
- 混乱していない嘘つきは必ず嘘の証言をする。
- 混乱している正直者は必ず嘘の証言をする。
- 混乱している嘘つきは必ず正しい証言をする。

すなわち、混乱していなければ正直者は正しい証言を、嘘つきは嘘の証言をしますが、混乱していると逆になります。

あなたは**混乱している村人の組**を予想することにしました。 混乱している村人の組を決めると、与えられた $ M $ 個の証言からなる証言の組が「矛盾する」かどうかが定まります。 ここで、証言の組が「矛盾する」というのは、各村人が正直者であるか嘘つきであるかをどのように決めても、証言の組の中に、村人が行う証言の規則に反するものが存在することを意味します。

与えられた証言の組が矛盾しないような**混乱している村人の組**を $ 1 $ つ見つけてください。 ただし、どのような村人の組が混乱しているとしても与えられた証言の組が矛盾する場合は、そのことを指摘してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ A_1 $ $ B_1 $ $ C_1 $ $ A_2 $ $ B_2 $ $ C_2 $ $ \vdots $ $ A_M $ $ B_M $ $ C_M $

## 输出格式

与えられた証言の組が矛盾しないような混乱している村人の組が存在するとき、混乱している村人の組を表す長さ $ N $ の文字列を出力せよ。このとき出力される文字列では、村人 $ i $ が混乱している場合 $ i $ 文字目が `1`、そうでない場合 $ i $ 文字目が `0` であるようにせよ。

そのような混乱している村人の組が存在しないとき、`-1` と出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \mathrm{min}\ \lbrace\ 2\ \times\ 10^5,N(N-1)\ \rbrace $
- $ 1\ \leq\ A_i,\ B_i\ \leq\ N,\ A_i\ \neq\ B_i $
- $ i\neq\ j $ のとき $ A_i\neq\ A_j $ または $ B_i\neq\ B_j $
- $ C_i=0 $ または $ C_i=1 $
- 入力される値はすべて整数である

### Sample Explanation 1

村人 $ 1 $ が混乱していない正直者、村人 $ 2 $ が混乱している嘘つき、村人 $ 3 $ が混乱していない正直者であると仮定します。 このとき、村人 $ 1 $ は、村人 $ 2 $ が嘘つきである、村人 $ 3 $ が正直者であると正しい証言をします。 また、村人 $ 2 $ は嘘つきですが混乱しているため、村人 $ 3 $ が正直者であると正しい証言をします。 したがって、与えられた証言が全て村人の証言の規則通りに得られるため、村人 $ 2 $ のみ混乱していることを表す `010` は正当な出力の $ 1 $ つです。

### Sample Explanation 2

村人 $ 2,3 $ が混乱していると仮定してみます。 このとき、各村人が正直者であるかどうかについて $ 2^3=8 $ 通りの組み合わせがあります。 このうち、例えば、「村人 $ 1 $ が（混乱していない）正直者、村人 $ 2 $ が（混乱している）嘘つき、村人 $ 3 $ が（混乱している）正直者」であるとすると、村人 $ 2 $ は規則によれば正しい証言をするはずですが、村人 $ 1 $ を嘘つきであると嘘の証言をしています。 他の組み合わせに対しても、同様に規則に反する証言が生じることを確認できます。 したがって、村人 $ 2,3 $ が混乱しているとすると、与えられた証言の組は矛盾します。 実は、このケースでは、どのような村人の組が混乱しているとしても与えられた証言の組は矛盾します。

### Sample Explanation 3

混乱している人数は任意であり、題意の条件が満たされるならば $ 0 $ 人や全員でもよいです。

## 样例 #1

### 输入

```
3 3
1 2 1
1 3 0
2 3 0
```

### 输出

```
010
```

## 样例 #2

### 输入

```
3 6
1 2 1
1 3 0
2 1 1
2 3 0
3 1 1
3 2 0
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3 0
```

### 输出

```
000
```



---

---
title: "Propagating Edges"
layout: "post"
diff: 提高+/省选-
pid: AT_soundhound2018_summer_final_d
tag: ['并查集', 'Kruskal 重构树']
---

# Propagating Edges

## 题目描述

[problemUrl]: https://atcoder.jp/contests/soundhound2018-summer-final/tasks/soundhound2018_summer_final_d

$ N $ 頂点 $ 0 $ 辺の無向グラフが与えられます。以下のクエリを $ Q $ 個処理して下さい。

- addクエリ($ type\ =\ 1,\ u,\ v $): $ u $ と $ v $ の間に辺が無ければ辺を貼る。
- completeクエリ($ type\ =\ 2,\ u,\ v\ =\ 0 $): 全ての頂点対 $ a,\ b $ について以下を行う, $ u,\ a,\ b $ がすべて連結で，かつ $ a,\ b $ 間に辺がない場合，$ a,\ b $ の間に辺を貼る。
- checkクエリ($ type\ =\ 3,\ u,\ v $): $ u,\ v $ が与えられる。$ u $ と $ v $ を直接結ぶ辺がある場合`Yes`、そうでない場合`No`を出力する。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ Q $ $ type_1 $ $ u_1 $ $ v_1 $ $ type_2 $ $ u_2 $ $ v_2 $ $ : $ $ type_Q $ $ u_Q $ $ v_Q $

## 输出格式

各checkクエリに対し、`Yes`か`No`を出力してください。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 100,000 $
- $ 1\ \leq\ Q\ \leq\ 200,000 $
- $ type_i\ =\ 1,\ 2,\ 3 $
- $ 1\ \leq\ u_i\ \leq\ N $
- add, checkクエリにおいて $ 1\ \leq\ v_i\ \leq\ N $ かつ $ u_i\ \neq\ v_i $
- completeクエリにおいて $ v_i\ =\ 0 $
- 入力される値は全て整数である

### Sample Explanation 1

$ 1,\ 2 $ つ目のクエリで$ (1,\ 2) $, $ (2,\ 3) $に辺が張られます。 そして、$ 5 $ つ目のクエリで$ (1,\ 3) $ 間に辺が張られます。

## 样例 #1

### 输入

```
3 6

1 1 2

1 2 3

3 1 2

3 1 3

2 1 0

3 1 3
```

### 输出

```
Yes

No

Yes
```

## 样例 #2

### 输入

```
3 6

2 3 0

3 1 3

1 3 1

2 3 0

1 1 2

3 2 1
```

### 输出

```
No

Yes
```

## 样例 #3

### 输入

```
8 20

1 3 6

2 6 0

2 2 0

2 7 0

1 7 3

3 2 6

1 4 2

3 3 7

1 2 6

2 4 0

2 2 0

3 3 1

2 8 0

2 8 0

1 8 2

2 7 0

3 5 4

1 4 2

3 5 7

3 2 3
```

### 输出

```
No

Yes

No

No

No

Yes
```



---


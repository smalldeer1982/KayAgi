---
title: "[ABC251F] Two Spanning Trees"
layout: "post"
diff: 普及+/提高
pid: AT_abc251_f
tag: ['图论', '广度优先搜索 BFS', '深度优先搜索 DFS', '生成树', '构造']
---

# [ABC251F] Two Spanning Trees

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc251/tasks/abc251_f

$ N $ 頂点 $ M $ 辺の無向グラフ $ G $ が与えられます。 $ G $ は**単純**（自己ループおよび多重辺を持たない）かつ**連結**です。

$ i\ =\ 1,\ 2,\ \ldots,\ M $ について、$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を結ぶ無向辺 $ \lbrace\ u_i,\ v_i\ \rbrace $ です。

下記の $ 2 $ つの条件をともに満たすような $ G $ の $ 2 $ つの全域木 $ T_1,T_2 $ を $ 1 $ 組構成してください。（ $ T_1 $ と $ T_2 $ は異なる全域木である必要はありません。）

- $ T_1 $ は下記を満たす。
  
  > $ T_1 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_1 $ に含まれないすべての辺 $ \lbrace\ u,\ v\ \rbrace $ について、$ u $ と $ v $ は $ T_1 $ において祖先と子孫の関係にある。
- $ T_2 $ は下記を満たす。
  
  > $ T_2 $ を頂点 $ 1 $ を根とする根付き木とみなしたとき、$ G $ の辺のうち $ T_2 $ に含まれない辺 $ \lbrace\ u,\ v\ \rbrace $ であって、$ u $ と $ v $ が $ T_2 $ において祖先と子孫の関係にあるようなものは存在しない。

ここで、「根付き木 $ T $ において頂点 $ u $ と頂点 $ v $ が祖先と子孫の関係にある」とは、「 $ T $ において $ u $ が $ v $ の祖先である」と「 $ T $ において $ v $ が $ u $ の祖先である」のうちどちらかが成り立つことをいいます。

本問題の制約下において上記の条件を満たす $ T_1 $ と $ T_2 $ は必ず存在することが示せます。

## 输入格式

入力は以下の形式で標準入力から与えられます。

> $ N $ $ M $ $ u_1 $ $ v_1 $ $ u_2 $ $ v_2 $ $ \vdots $ $ u_M $ $ v_M $

## 输出格式

$ T_1 $ と $ T_2 $ を下記の形式にしたがって、$ 2N-2 $ 行にわたって出力してください。すなわち、

- $ 1 $ 行目から $ N-1 $ 行目には、$ T_1 $ に含まれる $ N-1 $ 本の無向辺 $ \lbrace\ x_1,\ y_1\rbrace,\ \lbrace\ x_2,\ y_2\rbrace,\ \ldots,\ \lbrace\ x_{N-1},\ y_{N-1}\rbrace $ を、各行に $ 1 $ 本ずつ出力してください。
- $ N $ 行目から $ 2N-2 $ 行目には、$ T_2 $ に含まれる $ N-1 $ 本の無向辺 $ \lbrace\ z_1,\ w_1\rbrace,\ \lbrace\ z_2,\ w_2\rbrace,\ \ldots,\ \lbrace\ z_{N-1},\ w_{N-1}\rbrace $ を、各行に $ 1 $ 本ずつ出力してください。

各全域木を構成する辺をどのような順番で出力するかや、各辺の出力においてどちらの端点を先に出力するかは任意です。

> $ x_1 $ $ y_1 $ $ x_2 $ $ y_2 $ $ \vdots $ $ x_{N-1} $ $ y_{N-1} $ $ z_1 $ $ w_1 $ $ z_2 $ $ w_2 $ $ \vdots $ $ z_{N-1} $ $ w_{N-1} $

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \min\lbrace\ 2\ \times\ 10^5,\ N(N-1)/2\ \rbrace $
- $ 1\ \leq\ u_i,\ v_i\ \leq\ N $
- 入力はすべて整数
- 与えられるグラフは単純かつ連結

### Sample Explanation 1

上記の出力例において、$ T_1 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 4,\ 3\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 4,\ 2\ \rbrace,\ \lbrace\ 6,\ 2\ \rbrace $ を持つ $ G $ の全域木です。この $ T_1 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_1 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 5,\ 1\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 5 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 2\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 2 $ の祖先であり、 - 辺 $ \lbrace\ 1,\ 6\ \rbrace $ について、頂点 $ 1 $ は頂点 $ 6 $ の祖先です。 また、$ T_2 $ は $ 5 $ 本の辺 $ \lbrace\ 1,\ 5\ \rbrace,\ \lbrace\ 5,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace,\ \lbrace\ 2,\ 1\ \rbrace,\ \lbrace\ 1,\ 6\ \rbrace $ を持つ $ G $ の全域木です。この $ T_2 $ は問題文中の条件を満たします。実際、$ G $ の辺のうち $ T_2 $ に含まれない各辺に関して、 - 辺 $ \lbrace\ 4,\ 3\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 3 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 2,\ 6\ \rbrace $ について、頂点 $ 2 $ と頂点 $ 6 $ は祖先と子孫の関係になく、 - 辺 $ \lbrace\ 4,\ 2\ \rbrace $ について、頂点 $ 4 $ と頂点 $ 2 $ は祖先と子孫の関係にありません。

### Sample Explanation 2

$ 3 $ 本の辺 $ \lbrace\ 1,\ 2\rbrace,\ \lbrace\ 1,\ 3\ \rbrace,\ \lbrace\ 1,\ 4\ \rbrace $ を持つ木 $ T $ が $ G $ の唯一の全域木です。 $ G $ の辺のうちこの木 $ T $ に含まれない辺は存在しないので、明らかに、$ T $ は $ T_1 $ の条件と $ T_2 $ の条件をともに満たします。

## 样例 #1

### 输入

```
6 8

5 1

4 3

1 4

3 5

1 2

2 6

1 6

4 2
```

### 输出

```
1 4

4 3

5 3

4 2

6 2

1 5

5 3

1 4

2 1

1 6
```

## 样例 #2

### 输入

```
4 3

3 1

1 2

1 4
```

### 输出

```
1 2

1 3

1 4

1 4

1 3

1 2
```



---

---
title: "[ABC255F] Pre-order and In-order"
layout: "post"
diff: 普及+/提高
pid: AT_abc255_f
tag: ['图论', '深度优先搜索 DFS']
---

# [ABC255F] Pre-order and In-order

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc255/tasks/abc255_f

$ 1,\ 2,\ \ldots,\ N $ と番号づけられた $ N $ 個の頂点を持つ**二分木**を考えます。 ここで、二分木とは各頂点が高々 $ 2 $ 個の子を持つ根付き木です。より具体的には、二分木の各頂点は高々 $ 1 $ 個の**左の子**と高々 $ 1 $ 個の**右の子**を持ちます。

頂点 $ 1 $ を根とする二分木であって、下記の条件を満たすものが存在するかを判定し、存在する場合はその一例を示してください。

- すべての頂点を深さ優先探索における[**行きがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（pre-order）で並べた列が $ (P_1,\ P_2,\ \ldots,\ P_N) $ である。
- すべての頂点を深さ優先探索における[**通りがけ順**](https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2)（in-order）で並べた列が $ (I_1,\ I_2,\ \ldots,\ I_N) $ である。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ P_1 $ $ P_2 $ $ \ldots $ $ P_N $ $ I_1 $ $ I_2 $ $ \ldots $ $ I_N $

## 输出格式

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木が存在しない場合は $ -1 $ を出力せよ。  
存在する場合は、条件を満たす二分木の一例を下記の形式にしたがって $ N $ 行にわたって出力せよ。 すなわち、$ i\ =\ 1,\ 2,\ \ldots,\ N $ について、$ i $ 行目には頂点 $ i $ の左の子の番号 $ L_i $ と右の子の番号 $ R_i $ を出力せよ。 ただし、左の子（または右の子）を持たない場合は $ L_i $（または $ R_i $ ）として $ 0 $ を出力せよ。  
条件を満たすような頂点 $ 1 $ を根とする二分木が複数存在する場合は、そのうちどれを出力しても正解となる。

> $ L_1 $ $ R_1 $ $ L_2 $ $ R_2 $ $ \vdots $ $ L_N $ $ R_N $

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N $ は整数
- $ (P_1,\ P_2,\ \ldots,\ P_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列
- $ (I_1,\ I_2,\ \ldots,\ I_N) $ は $ (1,\ 2,\ \ldots,\ N) $ の順列

### Sample Explanation 1

次の画像に示す、頂点 $ 1 $ を根とする二分木が問題文中の条件を満たします。 !\[\](https://img.atcoder.jp/abc255/b51399e8953ae1723d1d9e83617f9be9.png)

### Sample Explanation 2

問題文中の条件を満たすような頂点 $ 1 $ を根とする二分木は存在しません。よって $ -1 $ を出力します。

## 样例 #1

### 输入

```
6
1 3 5 6 4 2
3 5 1 4 6 2
```

### 输出

```
3 6
0 0
0 5
0 0
0 0
4 2
```

## 样例 #2

### 输入

```
2
2 1
1 2
```

### 输出

```
-1
```



---

---
title: "[ABC271F] XOR on Grid Path"
layout: "post"
diff: 普及+/提高
pid: AT_abc271_f
tag: ['折半搜索 meet in the middle']
---

# [ABC271F] XOR on Grid Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc271/tasks/abc271_f

$ N $ 行 $ N $ 列のマス目があり、上から $ i\ \,\ (1\ \leq\ i\ \leq\ N) $ 行目、左から $ j\ \,\ (1\ \leq\ j\ \leq\ N) $ 列目のマスを $ (i,\ j) $ と表します。  
 マス $ (i,\ j) $ には非負整数 $ a_{i,\ j} $ が書かれています。

マス $ (i,\ j) $ にいるとき、マス $ (i+1,\ j),\ (i,\ j+1) $ のいずれかに移動することができます。ただし、マス目の外に出るような移動はできません。

マス $ (1,\ 1) $ から移動を繰り返してマス $ (N,\ N) $ にたどり着く方法であって、通ったマス（マス $ (1,\ 1),\ (N,\ N) $ を含む）に書かれた整数の排他的論理和が $ 0 $ となるようなものの総数を求めてください。

 排他的論理和とは 整数 $ a,\ b $ の排他的論理和 $ a\ \oplus\ b $ は、以下のように定義されます。 - $ a\ \oplus\ b $ を二進表記した際の $ 2^k\ \,\ (k\ \geq\ 0) $ の位の数は、$ a,\ b $ を二進表記した際の $ 2^k $ の位の数のうち一方のみが $ 1 $ であれば $ 1 $、そうでなければ $ 0 $ である。

 例えば、$ 3\ \oplus\ 5\ =\ 6 $ となります（二進表記すると $ 011\ \oplus\ 101\ =\ 110 $）。  
 一般に $ k $ 個の整数 $ p_1,\ \dots,\ p_k $ の排他的論理和は $ (\cdots\ ((p_1\ \oplus\ p_2)\ \oplus\ p_3)\ \oplus\ \cdots\ \oplus\ p_k) $ と定義され、これは $ p_1,\ \dots,\ p_k $ の順番によらないことが証明できます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ a_{1,\ 1} $ $ \ldots $ $ a_{1,\ N} $ $ \vdots $ $ a_{N,\ 1} $ $ \ldots $ $ a_{N,\ N} $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 20 $
- $ 0\ \leq\ a_{i,\ j}\ \lt\ 2^{30}\ \,\ (1\ \leq\ i,\ j\ \leq\ N) $
- 入力は全て整数

### Sample Explanation 1

次の二通りの方法が条件を満たします。 - $ (1,\ 1)\ \rightarrow\ (1,\ 2)\ \rightarrow\ (1,\ 3)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3) $ - $ (1,\ 1)\ \rightarrow\ (2,\ 1)\ \rightarrow\ (2,\ 2)\ \rightarrow\ (2,\ 3)\ \rightarrow\ (3,\ 3) $

## 样例 #1

### 输入

```
3

1 5 2

7 0 5

4 2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
2

1 2

2 1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
10

1 0 1 0 0 1 0 0 0 1

0 0 0 1 0 1 0 1 1 0

1 0 0 0 1 0 1 0 0 0

0 1 0 0 0 1 1 0 0 1

0 0 1 1 0 1 1 0 1 0

1 0 0 0 1 0 0 1 1 0

1 1 1 0 0 0 1 1 0 0

0 1 1 0 0 1 1 0 1 0

1 0 1 1 0 0 0 0 0 0

1 0 1 1 0 0 1 1 1 0
```

### 输出

```
24307
```



---

---
title: "[ABC301E] Pac-Takahashi"
layout: "post"
diff: 普及+/提高
pid: AT_abc301_e
tag: ['动态规划 DP', '广度优先搜索 BFS', '状态合并']
---

# [ABC301E] Pac-Takahashi

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc301/tasks/abc301_e

$ H $ 行 $ W $ 列のグリッドがあります。 上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,j) $ と表します。 グリッドの各マスはスタートマス、ゴールマス、空マス、壁マス、お菓子マスのいずれかです。 $ (i,j) $ が何のマスであるかは文字 $ A_{i,j} $ によって表され、$ A_{i,j}= $ `S` のときスタートマス、 $ A_{i,j}= $ `G` のときゴールマス、 $ A_{i,j}= $ `.` のとき空マス、 $ A_{i,j}= $ `#` のとき壁マス、 $ A_{i,j}= $ `o` のときお菓子マスです。 ここで、スタートマスとゴールマスはちょうど $ 1 $ つずつあり、お菓子マスは **$ 18 $ 個以下**であることが保証されます。

高橋くんは現在スタートマスにいます。 高橋くんは、上下左右に隣接するマスであって壁マスでないマスに移動することを繰り返し行えます。 高橋くんは今から $ T $ 回以下の移動によってゴールマスに到達したいです。 そのようなことは可能かどうか判定してください。 可能な場合は、最終的にゴールマスにいるという条件のもとで、移動の途中に訪れるお菓子マスの数の最大値を求めてください。 ただし、$ 1 $ つのお菓子マスに複数回訪れた場合でも、カウントするのは $ 1 $ 回のみです。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ T $ $ A_{1,1}A_{1,2}\dots\ A_{1,W} $ $ \vdots $ $ A_{H,1}A_{H,2}\dots\ A_{H,W} $

## 输出格式

$ T $ 回以下の移動によってゴールマスに到達することが不可能ならば `-1` を出力せよ。 可能ならば、最終的にゴールマスにいるという条件のもとで、移動の途中に訪れるお菓子マスの数の最大値を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\ \leq\ 300 $
- $ 1\ \leq\ T\ \leq\ 2\times\ 10^6 $
- $ H,W,T $ は整数
- $ A_{i,j} $ は `S`, `G`, `.`, `#`, `o` のいずれか
- $ A_{i,j}= $ `S` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `G` を満たす $ (i,j) $ の組がちょうど $ 1 $ つ存在する
- $ A_{i,j}= $ `o` を満たす $ (i,j) $ の組は **$ 18 $ 個以下**
 
### Sample Explanation 1

$ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3)\ \rightarrow\ (1,3) $ と $ 4 $ 回移動すると、 $ 1 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることができます。 $ 5 $ 回以下の移動で $ 2 $ 個のお菓子マスを訪れた上で最終的にゴールマスにいることはできないので、$ 1 $ が答えです。 なお、$ (1,1)\ \rightarrow\ (2,1)\ \rightarrow\ (1,1)\ \rightarrow\ (1,2)\ \rightarrow\ (1,3)\ \rightarrow\ (2,3) $ と移動すると $ 5 $ 回の移動で $ 2 $ 個のお菓子マスを訪れることができますが、最終的にゴールマスにいないため無効であることに注意してください。

### Sample Explanation 2

$ 1 $ 回以下の移動でゴールマスに到達することはできません。

## 样例 #1

### 输入

```
3 3 5

S.G

o#o

.#.
```

### 输出

```
1
```

## 样例 #2

### 输入

```
3 3 1

S.G

.#o

o#.
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
5 10 2000000

S.o..ooo..

..o..o.o..

..o..ooo..

..o..o.o..

..o..ooo.G
```

### 输出

```
18
```



---

---
title: "[ABC349E] Weighted Tic-Tac-Toe"
layout: "post"
diff: 普及+/提高
pid: AT_abc349_e
tag: ['搜索']
---

# [ABC349E] Weighted Tic-Tac-Toe

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc349/tasks/abc349_e

$ 3\ \times\ 3 $ のマス目があります。上から $ i $ 行目、左から $ j $ 列目 $ (1\ \leq\ i,j\ \leq\ 3) $ のマスをマス $ (i,j) $ と表します。マス $ (i,j) $ には整数 $ A_{i,j} $ が書かれています。ここで、 $ \sum_{i=1}^3\ \sum_{j=1}^3\ A_{i,j} $ は奇数であることが保証されます。また、すべてのマスははじめ白で塗られています。

高橋君と青木君が、このマス目を使ってゲームを行います。ゲームでは、高橋君を先手として、二人が交互に以下の操作を行います。

- 白で塗られているマス $ (i,j)\,(1\leq\ i,j\ \leq\ 3) $ を選ぶ（操作が行われる時点で、そのようなマスは必ず存在することが示せる）。操作をしているプレイヤーが得点 $ A_{i,j} $ を得る。次に、操作をしているプレイヤーが高橋君ならば、マス $ (i,j) $ を赤で、青木君ならば青で塗る。
 
各操作のあと、次の判定を行います。

- 赤または青の同じ色で塗られたマスが縦・横・斜めのいずれかの方向に $ 3 $ つ連続する箇所があるか判定する。そのような箇所があれば、その時点でゲームを終了し、赤が $ 3 $ つ連続しているならば高橋君が、青が $ 3 $ つ連続しているならば青木君が勝利する。
- 白で塗られているマスが存在するか判定する。存在しなければ、その時点でゲームを終了し、その時点までに獲得した累計の得点が高い方のプレイヤーが勝利する。
 
ゲームは必ず有限回の操作で終了し、高橋君または青木君の一方が勝利することが示せます。両者が勝ちを目指して最適に行動するとき、どちらが勝つか判定してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ A_{1,1} $ $ A_{1,2} $ $ A_{1,3} $ $ A_{2,1} $ $ A_{2,2} $ $ A_{2,3} $ $ A_{3,1} $ $ A_{3,2} $ $ A_{3,3} $

## 输出格式

高橋君が勝つならば `Takahashi` を、青木君が勝つならば `Aoki` を出力せよ。

## 说明/提示

### 制約

- $ |A_{i,j}|\ \leq\ 10^9 $
- $ \sum_{i=1}^3\ \sum_{j=1}^3\ A_{i,j} $ は奇数
- 入力はすべて整数
 
### Sample Explanation 1

高橋君が最初の手番で $ (2,2) $ を選択すると、その後どのように青木君が行動しても、高橋君が適切に行動することで、青で塗られたマスが $ 3 $ つ連続しないようにすることができます。赤で塗られたマスが $ 3 $ つ連続した場合は高橋君が勝ちます。赤で塗られたマスが $ 3 $ つ連続せずにゲームが終了した場合、その時点で高橋君は $ 1 $ 点、青木君は $ 0 $ 点を獲得しているため、どちらにせよ高橋君が勝ちます。

## 样例 #1

### 输入

```
0 0 0

0 1 0

0 0 0
```

### 输出

```
Takahashi
```

## 样例 #2

### 输入

```
-1 1 0

-4 -2 -5

-4 -1 -5
```

### 输出

```
Aoki
```



---

---
title: "[ABC363F] Palindromic Expression"
layout: "post"
diff: 普及+/提高
pid: AT_abc363_f
tag: ['搜索']
---

# [ABC363F] Palindromic Expression

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_f

整数 $ N $ が与えられます。 次の条件を全て満たす文字列 $ S $ としてあり得るものを $ 1 $ 個出力してください。そのような文字列が存在しなければ `-1` を出力してください。

- $ S $ は `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9` および `*` (乗算記号) からなる長さ $ 1 $ 以上 $ 1000 $ 以下の文字列である。
- $ S $ は回文である。
- $ S $ の先頭の文字は数字である。
- $ S $ を式として評価した値が $ N $ と一致する。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $

## 输出格式

問題文の条件を満たす文字列が存在する場合はその文字列を、そうでない場合は `-1` を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^{12} $
- $ N $ は整数
 
### Sample Explanation 1

$ S\ = $ `11\*3\*11` は問題文の条件を満たします。他に条件を満たす文字列として $ S= $ `363` があります。

### Sample Explanation 2

$ S $ は `0` を含んではいけない点に注意してください。

## 样例 #1

### 输入

```
363
```

### 输出

```
11*3*11
```

## 样例 #2

### 输入

```
101
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3154625100
```

### 输出

```
2*57*184481*75*2
```



---

---
title: "[ABC394E] Palindromic Shortest Path"
layout: "post"
diff: 普及+/提高
pid: AT_abc394_e
tag: ['广度优先搜索 BFS']
---

# [ABC394E] Palindromic Shortest Path

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc394/tasks/abc394_e

给定一个包含 $N$ 个顶点的有向图，顶点编号为 $1, 2, \ldots, N$。

边的信息由 $N^2$ 个字符 $C_{1, 1}, C_{1, 2}, \ldots, C_{1, N}, C_{2, 1}, \ldots, C_{N, N}$ 给出。其中 $C_{i, j}$ 为小写字母或 `-`。

- 当 $C_{i, j}$ 为小写字母时，存在一条从顶点 $i$ 到顶点 $j$ 的边，且该边的标签为 $C_{i, j}$。
- 当 $C_{i, j}$ 为 `-` 时，不存在从顶点 $i$ 到顶点 $j$ 的边。

对于所有满足 $1 \leq i, j \leq N$ 的整数对 $(i, j)$，请回答以下问题：

- 找出从顶点 $i$ 到顶点 $j$ 的路径（不要求是简单路径），使得路径上边标签按顺序组成的字符串是回文。在所有满足条件的路径中，输出最短路径的长度。若不存在这样的路径，输出 $-1$。


## 输入格式

输入通过标准输入按以下格式给出：

> $N$  
> $C_{1, 1}$ $C_{1, 2}$ $\ldots$ $C_{1, N}$  
> $C_{2, 1}$ $C_{2, 2}$ $\ldots$ $C_{2, N}$  
> $\vdots$  
> $C_{N, 1}$ $C_{N, 2}$ $\ldots$ $C_{N, N}$  

## 输出格式

以整数对 $(i, j)$ 的答案 $A_{i, j}$ 按以下格式输出：

> $A_{1, 1}$ $A_{1, 2}$ $\ldots$ $A_{1, N}$  
> $A_{2, 1}$ $A_{2, 2}$ $\ldots$ $A_{2, N}$  
> $\vdots$  
> $A_{N, 1}$ $A_{N, 2}$ $\ldots$ $A_{N, N}$  

## 说明/提示

### 约束条件

- $1 \leq N \leq 100$
- $N$ 为整数
- $C_{i, j}$ 为小写字母或 `-`

### 样例解释 1

以 $(i, j) = (1, 4)$ 为例：路径 $1 \to 1 \to 2 \to 3 \to 4$ 的边标签组成的字符串为 `abba`，这是一个回文。由于不存在长度小于 $4$ 的满足条件的路径，因此 $(i, j) = (1, 4)$ 的答案为 $4$。注意空字符串也被视为回文。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4

ab--

--b-

---a

c---
```

### 输出

```
0 1 2 4

-1 0 1 -1

3 -1 0 1

1 -1 -1 0
```

## 样例 #2

### 输入

```
5

us---

-st--

--s--

u--s-

---ts
```

### 输出

```
0 1 3 -1 -1

-1 0 1 -1 -1

-1 -1 0 -1 -1

1 3 -1 0 -1

-1 -1 5 1 0
```



---

---
title: "[ABC402F] Path to Integer"
layout: "post"
diff: 普及+/提高
pid: AT_abc402_f
tag: ['搜索', '贪心', '二分', '双指针 two-pointer', '折半搜索 meet in the middle']
---

# [ABC402F] Path to Integer

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc402/tasks/abc402_f

有一个 $N$ 行 $N$ 列的网格。从上往下第 $i$ 行、从左往右第 $j$ 列的格子记作格子 $(i,j)$。每个格子上都写有 `1` 到 `9` 的数字，格子 $(i,j)$ 上写的数字是 $A_{i,j}$。

初始时，棋子位于格子 $(1,1)$。同时，设 $S$ 为空字符串，接下来进行 $2N-1$ 次操作：

1. 将当前棋子所在格子的数字追加到 $S$ 的末尾。
2. 将棋子向右或向下移动一格（第 $2N-1$ 次操作时不移动）。

$2N-1$ 次操作后，棋子将位于格子 $(N,N)$，且 $S$ 的长度为 $2N-1$。

将最终得到的字符串 $S$ 视为整数，其值对 $M$ 取模的结果即为得分。

请计算可以获得的最高得分。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $A_{1,1}$ $A_{1,2}$ $\ldots$ $A_{1,N}$  
> $A_{2,1}$ $A_{2,2}$ $\ldots$ $A_{2,N}$  
> $\vdots$  
> $A_{N,1}$ $A_{N,2}$ $\ldots$ $A_{N,N}$


## 输出格式

输出答案。


## 说明/提示

### 约束条件

- $1 \leq N \leq 20$
- $2 \leq M \leq 10^9$
- $1 \leq A_{i,j} \leq 9$
- 输入中的所有数值均为整数

### 样例解释 1

棋子的移动方式有以下两种：
1. 按 $(1,1)\rightarrow(1,2)\rightarrow(2,2)$ 的顺序移动。此时 $S=$ `121`，得分为 $121 \bmod 7 = 2$。
2. 按 $(1,1)\rightarrow(2,1)\rightarrow(2,2)$ 的顺序移动。此时 $S=$ `131`，得分为 $131 \bmod 7 = 5$。

最高得分为 5，因此输出 5。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2 7
1 2
3 1
```

### 输出

```
5
```

## 样例 #2

### 输入

```
3 100000
1 2 3
3 5 8
7 1 2
```

### 输出

```
13712
```

## 样例 #3

### 输入

```
5 402
8 1 3 8 9
8 2 4 1 8
4 1 8 5 9
6 2 1 6 7
6 6 7 7 6
```

### 输出

```
384
```



---

---
title: "[AGC026C] String Coloring"
layout: "post"
diff: 普及+/提高
pid: AT_agc026_c
tag: ['搜索', '折半搜索 meet in the middle']
---

# [AGC026C] String Coloring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc026/tasks/agc026_c

長さ $ 2N $ の，英小文字のみからなる文字列 $ S $ が与えられます。

$ S $ の各文字を赤色か青色かに塗り分ける方法は $ 2^{2N} $ 通りありますが，このうち以下の条件を満たす塗り分け方は何通りですか？

- 赤色に塗られた文字を**左から右に**読んだ文字列と，青色に塗られた文字を**右から左に**読んだ文字列が一致する

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $

## 输出格式

条件を満たす塗り分け方の個数を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 18 $
- $ S $ の長さは $ 2N $ である
- $ S $ は英小文字のみからなる

### Sample Explanation 1

以下の $ 4 $ 通りの塗り分け方が存在します。 - cabaacba - cabaacba - cabaacba - cabaacba

### Sample Explanation 4

答えは32bit整数型で表せないこともあります。

## 样例 #1

### 输入

```
4

cabaacba
```

### 输出

```
4
```

## 样例 #2

### 输入

```
11

mippiisssisssiipsspiim
```

### 输出

```
504
```

## 样例 #3

### 输入

```
4

abcdefgh
```

### 输出

```
0
```

## 样例 #4

### 输入

```
18

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

### 输出

```
9075135300
```



---

---
title: "[AGC044A] Pay to Win"
layout: "post"
diff: 普及+/提高
pid: AT_agc044_a
tag: ['深度优先搜索 DFS', '记忆化搜索']
---

# [AGC044A] Pay to Win

## 题目描述

# [AGC044A] Pay to Win


你有一个数字$0$ ，你希望得到数字$N$。

你可以通过以下操作更改数字，需要支付一定数量的硬币：

- 将当前数乘$2$，需要$A$硬币。
- 将当前数乘$3$，需要$B$硬币。
- 将当前数乘$5$，需要$C$硬币。
- 将当前数加$1$或减$1$，需要$D$硬币。

你可以按任意顺序和任意次数执行这些操作。

最少需要多少硬币才能得到$N$？

你需要解决$T$组测试用例。

## 输入格式

第一行包含一个整数。

> $ T $

随后的$T$行代表$T$个测试用例。每行包含五个整数。

> $ N $ $ A $ $ B $ $ C $ $ D $

## 输出格式

对于每个测试用例，输出一行表示答案。

## 样例 #1

### 样例输入 #1

```
5
11 1 2 4 8
11 1 2 2 8
32 10 8 5 4
29384293847243 454353412 332423423 934923490 1
900000000000000000 332423423 454353412 934923490 987654321
```

### 样例输出 #1

```
20
19
26
3821859835
23441258666
```

## 说明/提示

### 约束

- $ 1\ \le\ T\ \le\ 10 $
- $ 1\ \le\ N\ \le\ 10^{18} $
- $ 1\ \le\ A,\ B,\ C,\ D\ \le\ 10^9 $
- $ N,\ A,\ B,\ C,\ D $ 都是整数。

### Sample Explanation 1

对于第一个测试用例，达到最低成本$20$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$1$个硬币使其乘$2(x = 4)$
- 用$2$个硬币使其乘$3(x = 12)$
- 用$8$个硬币使其减$1(x = 11)$

对于第二个测试用例，达到最低成本$19$的一系列操作是：

- 初始 $x = 0$.
- 用$8$个硬币使其加$1(x = 1)$
- 用$1$个硬币使其乘$2(x = 2)$
- 用$2$个硬币使其乘$5(x = 10)$
- 用$8$个硬币使其减$1(x = 11)$

## 样例 #1

### 输入

```
5

11 1 2 4 8

11 1 2 2 8

32 10 8 5 4

29384293847243 454353412 332423423 934923490 1

900000000000000000 332423423 454353412 934923490 987654321
```

### 输出

```
20

19

26

3821859835

23441258666
```



---

---
title: "[ABC067D] Fennec VS. Snuke"
layout: "post"
diff: 普及+/提高
pid: AT_arc078_b
tag: ['搜索', '博弈论']
---

# [ABC067D] Fennec VS. Snuke

## 题目描述

$Fennec$ 和 $Snuke$ 正在玩棋盘游戏。

在这个游戏中，有 $n$ 个格子和 $n-1$ 条道路， 编号为 $a_i$ 和 $b_i$ 的格子通过第 $i$ 条边相连。这些格子和边组成了一棵树。

第 $1$ 个格子是黑色，第 $n$ 个格子是白色，其他格子没有颜色。先手 $Fennec$ 和后手 $Snuke$ 交替给格子涂色，两人依次执行以下操作：

   $Fennec$：将一个与黑色格子相邻且未被涂色的格子涂成黑色。
   
   $Snuke$：将一个与白色格子相邻且未被涂色的格子涂成白色。

如果当前行动的玩家无法涂色，他将输掉游戏。请你写一个程序，判断当 $Fennec$ 和 $Snuke$ 都采取最佳策略时，谁能获胜。

## 输入格式

第一行一个整数 $n\ \ (2 ≤n≤1e5)$

接下来 $n-1$行，每行两个整数 $a_i$ 和 $b_i$，表示 $a_i$ 和 $b_i$ 间有一条边 $(1≤a_i ,b_i ≤n)$

## 输出格式

若 Fennec 获胜，输出“Fennec”，否则输出“Snuke”（不包含引号）

## 样例 #1

### 输入

```
7

3 6

1 2

3 1

7 4

5 7

1 4
```

### 输出

```
Fennec
```

## 样例 #2

### 输入

```
4

1 4

4 2

2 3
```

### 输出

```
Snuke
```



---

---
title: "[ABC087D] People on a Line"
layout: "post"
diff: 普及+/提高
pid: AT_arc090_b
tag: ['搜索', '并查集', '深度优先搜索 DFS', '差分约束', '差分']
---

# [ABC087D] People on a Line

## 题目描述

在一根数轴上站有 $n$ 个人，我们称第 $i$ 个人的坐标为 $x_i(x_i\in [0,10^{9}],x_i\in Z)$，同一个坐标点上可能有多个人。

你现在手上有 $m$ 条信息，第 $i$ 条信息形如 $(li,ri,di)$，含义是第 $r_i$ 个人在第 $l_i$ 个人右数第 $d_i$ 个坐标点上，换言之，$x_{r_i} - x_{l_i} = d_i$。

不幸的是，这 $m$ 条信息中的一些可能有误，请你求出是否存在一组 $x (x_1,x_2,x_3,\dots ,x_n)$ 满足所有信息。

## 输入格式

输入数据的第一行包含两个以空格分开的整数 $n$ 和 $m$，分别表示总人数和信息条数；

接下来的 $m$ 行中第 $i(1\le i\le m)$ 行包含三个以空格分开的整数 $l_i,r_i,d_i$，表示第 $i$ 条信息是 $r_i$ 号人在 $l_i$ 号人右边 $d_i$ 个位置上。

## 输出格式

若存在一组合法的 $x$，输出一行 ``Yes``；否则输出一行 ``No``。

## 说明/提示

全部的输入数据满足以下条件：

-  $1 \le n \le 100000$；
-  $0 \le m \le 200000$；
- $1\le l_i,r_i\le n (1\le i\le m)$；
- $0\le d_i\le 10000 (1\le i\le m)$；
- $l_i \ne r_i (1 \le i \le m)$；
- 如果 $i\le j$，则有 $(l_i,r_i)\ne (l_j,r_j),(l_i,r_i)\ne (r_j,l_j)$；
- $d_i$ 为整数。


$(0,1,2)$ 与 $(101,102,103)$ 都是合法的解。


若前两条信息是正确的，则有 $x_3 - x_1 = 2$，那么第三条信息就是错误的。

感谢@fbhou  提供的翻译

## 样例 #1

### 输入

```
3 3

1 2 1

2 3 1

1 3 2
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
3 3

1 2 1

2 3 1

1 3 5
```

### 输出

```
No
```

## 样例 #3

### 输入

```
4 3

2 1 1

2 3 5

3 4 2
```

### 输出

```
Yes
```

## 样例 #4

### 输入

```
10 3

8 7 100

7 9 100

9 8 100
```

### 输出

```
No
```

## 样例 #5

### 输入

```
100 0
```

### 输出

```
Yes
```



---


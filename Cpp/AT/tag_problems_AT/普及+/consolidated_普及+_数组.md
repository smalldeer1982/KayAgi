---
title: "[ABC253F] Operations on a Matrix"
layout: "post"
diff: 普及+/提高
pid: AT_abc253_f
tag: ['线段树', '树状数组']
---

# [ABC253F] Operations on a Matrix

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc253/tasks/abc253_f

縦 $ N $ 行、横 $ M $ 列の行列があり、はじめ全ての成分は $ 0 $ です。

以下のいずれかの形式で表されるクエリを $ Q $ 個処理してください。

- `1 l r x` : $ l $ 列目、$ l+1 $ 列目、$ \ldots $、$ r $ 列目の成分全てに $ x $ を足す。
- `2 i x` : $ i $ 行目の成分全てを $ x $ で置き換える。
- `3 i j` : $ (i,\ j) $ 成分を出力する。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ Q $ $ \mathrm{Query}_1 $ $ \vdots $ $ \mathrm{Query}_Q $

$ i $ 番目に与えられるクエリを表す $ \mathrm{Query}_i $ は以下のいずれかの形式である。

> $ 1 $ $ l $ $ r $ $ x $

> $ 2 $ $ i $ $ x $

> $ 3 $ $ i $ $ j $

## 输出格式

`3 i j` の形式の各クエリについて、答えを一行に出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N,\ M,\ Q\ \leq\ 2\ \times\ 10^5 $
- `1 l r x` の形式のクエリについて、$ 1\ \leq\ l\ \leq\ r\ \leq\ M $ かつ $ 1\ \leq\ x\ \leq\ 10^9 $
- `2 i x` の形式のクエリについて、$ 1\ \leq\ i\ \leq\ N $ かつ $ 1\ \leq\ x\ \leq\ 10^9 $
- `3 i j` の形式にクエリについて、$ 1\ \leq\ i\ \leq\ N $ かつ $ 1\ \leq\ j\ \leq\ M $
- `3 i j` の形式のクエリが一個以上与えられる
- 入力は全て整数

### Sample Explanation 1

行列は次のように変化します。 $ \begin{pmatrix}\ 0\ &amp;\ 0\ &amp;\ 0\ \\ 0\ &amp;\ 0\ &amp;\ 0\ \\ 0\ &amp;\ 0\ &amp;\ 0\ \\ \end{pmatrix}\ \rightarrow\ \begin{pmatrix}\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 1\ &amp;\ 1\ &amp;\ 0\ \\ \end{pmatrix}\ \rightarrow\ \begin{pmatrix}\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 1\ &amp;\ 1\ &amp;\ 0\ \\ 2\ &amp;\ 2\ &amp;\ 2\ \\ \end{pmatrix}\ \rightarrow\ \begin{pmatrix}\ 1\ &amp;\ 4\ &amp;\ 3\ \\ 1\ &amp;\ 4\ &amp;\ 3\ \\ 2\ &amp;\ 5\ &amp;\ 5\ \\ \end{pmatrix} $

## 样例 #1

### 输入

```
3 3 9

1 1 2 1

3 2 2

2 3 2

3 3 3

3 3 1

1 2 3 3

3 3 2

3 2 3

3 1 2
```

### 输出

```
1

2

2

5

3

4
```

## 样例 #2

### 输入

```
1 1 10

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

1 1 1 1000000000

3 1 1
```

### 输出

```
9000000000
```

## 样例 #3

### 输入

```
10 10 10

1 1 8 5

2 2 6

3 2 1

3 4 7

1 5 9 7

3 3 2

3 2 8

2 8 10

3 8 8

3 1 10
```

### 输出

```
6

5

5

13

10

0
```



---

---
title: "[ABC285F] Substring of Sorted String"
layout: "post"
diff: 普及+/提高
pid: AT_abc285_f
tag: ['线段树', '树状数组']
---

# [ABC285F] Substring of Sorted String

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc285/tasks/abc285_f

英小文字からなる長さ $ N $ の文字列 $ S $ と $ Q $ 個のクエリが与えられます。クエリを順に処理してください。

クエリは以下の $ 2 $ 種類です。

- `1 x c` ： $ S $ の $ x $ 文字目を文字 $ c $ に置き換える
- `2 l r` ： $ S $ を文字の昇順に並び替えて得られる文字列を $ T $ とする。$ S $ の $ l $ 文字目から $ r $ 文字目までからなる文字列が $ T $ の部分文字列であるとき `Yes`、部分文字列でないとき `No` を出力する
 
 部分文字列とは？ $ S $ の**部分文字列**とは、$ S $ の先頭から $ 0 $ 文字以上、末尾から $ 0 $ 文字以上削除して得られる文字列のことをいいます。 例えば、`ab` は `abc` の部分文字列ですが、`ac` は `abc` の部分文字列ではありません。

## 输入格式

入力は以下の形式で標準入力から与えられる。ただし、$ \text{query}_i $ で $ i $ 番目のクエリを表す。

> $ N $ $ S $ $ Q $ $ \text{query}_1 $ $ \text{query}_2 $ $ \vdots $ $ \text{query}_Q $

## 输出格式

問題文中の指示に従ってクエリを処理せよ。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 10^5 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ 1 $ 種類目のクエリにおいて、$ 1\ \leq\ x\ \leq\ N $
- $ 1 $ 種類目のクエリにおいて、$ c $ は英小文字
- $ 2 $ 種類目のクエリにおいて、$ 1\ \leq\ l\ \leq\ r\ \leq\ N $
 
### Sample Explanation 1

\- $ 1 $ 番目のクエリにおいて、$ S $ を文字の昇順に並び替えて得られる文字列 $ T $ は `abccdf` です。 $ S $ の $ 1 $ 文字目から $ 3 $ 文字目までからなる文字列は `abc` であり $ T $ の部分文字列です。よって `Yes` を出力します。 - $ 2 $ 番目のクエリにおいて、$ S $ を文字の昇順に並び替えて得られる文字列 $ T $ は `abccdf` です。 $ S $ の $ 2 $ 文字目から $ 6 $ 文字目までからなる文字列は `bcdcf` であり $ T $ の部分文字列ではありません。よって `No` を出力します。 - $ 3 $ 番目のクエリにより、$ S $ の $ 5 $ 文字目が `e` に置き換えられ、$ S $ は `abcdef` となります。 - $ 4 $ 番目のクエリにおいて、$ S $ を文字の昇順に並び替えて得られる文字列 $ T $ は `abcdef` です。 $ S $ の $ 2 $ 文字目から $ 6 $ 文字目までからなる文字列は `bcdef` であり $ T $ の部分文字列です。よって `Yes` を出力します。

## 样例 #1

### 输入

```
6

abcdcf

4

2 1 3

2 2 6

1 5 e

2 2 6
```

### 输出

```
Yes

No

Yes
```



---

---
title: "[ABC331F] Palindrome Query"
layout: "post"
diff: 普及+/提高
pid: AT_abc331_f
tag: ['线段树', '树状数组', '哈希 hashing']
---

# [ABC331F] Palindrome Query

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc331/tasks/abc331_f

英小文字からなる長さ $ N $ の文字列 $ S $ が与えられます。  
 以下で説明されるクエリを与えられる順に $ Q $ 個処理してください。  
 クエリは次の $ 2 $ 種類のいずれかです。

- `1 x c` : $ S $ の $ x $ 文字目を英小文字 $ c $ に変更する。
- `2 L R` : $ S $ の $ L $ 文字目から $ R $ 文字目までからなる部分文字列が回文であるならば `Yes` を、そうでないならば `No` を出力する。

## 输入格式

入力は以下の形式で標準入力から与えられる。ここで $ \text{query}_i $ は $ i $ 番目に処理するクエリである。

> $ N $ $ Q $ $ S $ $ \text{query}_1 $ $ \text{query}_2 $ $ \vdots $ $ \text{query}_Q $

各クエリは以下のいずれかの形式で与えられる。

> $ 1 $ $ x $ $ c $

> $ 2 $ $ L $ $ R $

## 输出格式

問題文の指示に従ってクエリへの答えを改行区切りで出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 10^6 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ S $ は英小文字からなる長さ $ N $ の文字列
- $ 1\ \leq\ x\ \leq\ N $
- $ c $ は英小文字
- $ 1\ \leq\ L\ \leq\ R\ \leq\ N $
- $ N,\ Q,\ x,\ L,\ R $ は整数
 
### Sample Explanation 1

はじめ、$ S\ = $ `abcbacb` です。 $ 1 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 5 $ 文字目までからなる文字列は `abcba` で、これは回文です。よって `Yes` を出力します。 $ 2 $ 番目のクエリについて、$ S $ の $ 4 $ 文字目から $ 7 $ 文字目までからなる文字列は `bacb` で、これは回文ではありません。よって `No` を出力します。 $ 3 $ 番目のクエリについて、$ S $ の $ 2 $ 文字目から $ 2 $ 文字目までからなる文字列は `b` で、これは回文です。よって `Yes` を出力します。 $ 4 $ 番目のクエリについて、$ S $ の $ 5 $ 文字目を `c` に変更します。$ S $ は `abcbccb` になります。 $ 5 $ 番目のクエリについて、$ S $ の $ 1 $ 文字目から $ 5 $ 文字目までからなる文字列は `abcbc` で、これは回文ではありません。よって `No` を出力します。 $ 6 $ 番目のクエリについて、$ S $ の $ 4 $ 文字目から $ 7 $ 文字目までからなる文字列は `bccb` で、これは回文です。よって `Yes` を出力します。 $ 7 $ 番目のクエリについて、$ S $ の $ 4 $ 文字目を `c` に変更します。$ S $ は `abccccb` になります。 $ 8 $ 番目のクエリについて、$ S $ の $ 3 $ 文字目から $ 6 $ 文字目までからなる文字列は `cccc` で、これは回文です。よって `Yes` を出力します。

## 样例 #1

### 输入

```
7 8

abcbacb

2 1 5

2 4 7

2 2 2

1 5 c

2 1 5

2 4 7

1 4 c

2 3 6
```

### 输出

```
Yes

No

Yes

No

Yes

Yes
```



---

---
title: "[ABC351F] Double Sum"
layout: "post"
diff: 普及+/提高
pid: AT_abc351_f
tag: ['树状数组']
---

# [ABC351F] Double Sum

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_f

整数列 $ A\ =\ (A_1,\ A_2,\ \dots,\ A_N) $ が与えられます。  
 次の式を計算してください。

$ \displaystyle\ \sum_{i=1}^N\ \sum_{j=i+1}^N\ \max(A_j\ -\ A_i,\ 0) $

なお、制約下において答えが $ 2^{63} $ 未満となることは保証されています。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ A_1 $ $ A_2 $ $ \dots $ $ A_N $

## 输出格式

式の値を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 4\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 10^8 $
- 入力される値は全て整数
 
### Sample Explanation 1

$ (i,\ j)\ =\ (1,\ 2) $ のとき $ \max(A_j\ -\ A_i,\ 0)\ =\ \max(3,\ 0)\ =\ 3 $ です。 $ (i,\ j)\ =\ (1,\ 3) $ のとき $ \max(A_j\ -\ A_i,\ 0)\ =\ \max(1,\ 0)\ =\ 1 $ です。 $ (i,\ j)\ =\ (2,\ 3) $ のとき $ \max(A_j\ -\ A_i,\ 0)\ =\ \max(-2,\ 0)\ =\ 0 $ です。 これらを足し合わせた $ 3\ +\ 1\ +\ 0\ =\ 4 $ が答えとなります。

## 样例 #1

### 输入

```
3

2 5 3
```

### 输出

```
4
```

## 样例 #2

### 输入

```
10

5 9 3 0 4 8 7 5 4 0
```

### 输出

```
58
```



---

---
title: "[ABC354F] Useless for LIS"
layout: "post"
diff: 普及+/提高
pid: AT_abc354_f
tag: ['动态规划 DP', '树状数组']
---

# [ABC354F] Useless for LIS

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc354/tasks/abc354_f

長さ $ N $ の整数列 $ A $ が与えられます。

$ t\ =\ 1,\ 2,\ \dots\ ,N $ について、 $ A_t $ が $ A $ の最長増加部分列に含まれることがあるか判定してください。

$ A_t $ が $ A $ の最長増加部分列に含まれることがあるとは、以下のことをいいます。

- 最長増加部分列の長さを $ L $ とする。各要素が $ 1 $ 以上 $ N $ 以下の単調増加な整数列 $ i\ =\ (i_1,\ i_2,\ \dots\ ,i_L)\ (i_1\ であって以下をすべて満たすものが存在する。 $
  
  
  - $ A_{i_1} $
  - ある $ k\ (1\ \leq\ k\ \leq\ L) $ が存在して $ i_k\ =\ t $ である

$ T $ 個のテストケースが与えられるので、それぞれについて答えを求めてください。

最長増加部分列とは？列 $ A $ の部分列とは $ A $ の要素をいくつか抜き出して元の順に並べてできる列を指します。

列 $ A $ の最長増加部分列とは、 $ A $ の狭義単調増加な部分列のうち列の長さが最大のものを指します。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ T $ $ \mathrm{case}_1 $ $ \mathrm{case}_2 $ $ \vdots $ $ \mathrm{case}_T $

ここで $ \mathrm{case_i} $ は $ i $ 番目のケースの入力を意味する。各ケースは以下の形式で与えられる。

> $ N $ $ A_1 $ $ A_2 $ $ \cdots $ $ A_N $

## 输出格式

以下の形式で出力せよ。

> $ \mathrm{answer}_1 $ $ \mathrm{answer}_2 $ $ \vdots $ $ \mathrm{answer}_T $

ここで $ \mathrm{answer}_i $ は $ i $ 番目のケースの出力を意味する。各ケースについては、次の通りである。

$ A_t $ が $ A $ の最長増加部分列に含まれることがある $ t $ が $ m $ 個存在し、昇順に $ i_1,\ i_2,\ \dots\ ,i_m $ であったとする。このとき、以下の形式で出力せよ。

> $ m $ $ i_1 $ $ i_2 $ $ \cdots $ $ i_m $

## 说明/提示

### 制約

- $ 1\ \leq\ T\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 10^9 $
- 全てのテストケースにおける $ N $ の総和は $ 2\ \times\ 10^5 $ 以下

### Sample Explanation 1

最長増加部分列の $ 1 $ つは $ (2,\ 4,\ 5) $ で、長さは $ 3 $ です。$ (1,\ 4,\ 5) $ も最長増加部分列の $ 1 $ つです。しかし、 $ A_5 $ を含む最長増加部分列はありません。 よって、 $ 1,\ 2,\ 3,\ 4 $ を出力します。

## 样例 #1

### 输入

```
1
5
2 1 4 5 3
```

### 输出

```
4
1 2 3 4
```

## 样例 #2

### 输入

```
2
6
2 5 3 4 3 4
5
10000 1000 100 1 10
```

### 输出

```
5
1 3 4 5 6
2
4 5
```



---

---
title: "[ABC368G] Add and Multiply Queries"
layout: "post"
diff: 普及+/提高
pid: AT_abc368_g
tag: ['线段树', '树状数组']
---

# [ABC368G] Add and Multiply Queries

## 题目描述

给定两个长度为 $ N $ 的正整数序列 $ A, B $。需要处理 $ Q $ 个按顺序给出的查询。查询有以下三种类型：

- 类型 $ 1 $：格式为 `1 i x`。将 $ A_i $ 替换为 $ x $。
- 类型 $ 2 $：格式为 `2 i x`。将 $ B_i $ 替换为 $ x $。
- 类型 $ 3 $：格式为 `3 l r`。需要解决以下问题并输出答案：
  - 初始时 $ v = 0 $。依次对 $ i = l, l + 1, \dots, r $ 进行操作，每次操作将 $ v $ 替换为 $ v + A_i $ 或 $ v \times B_i $。求最终能得到的 $ v $ 的最大值。
    需要注意的是，输入中类型 $ 3 $ 的查询的答案保证在 $ 10^{18} $ 以下。

## 输入格式

输入从标准输入按以下格式给出：

```
N
A_1 A_2 ... A_N
B_1 B_2 ... B_N
Q
query_1
query_2
...
query_Q
```

其中 $ query_i $ 是第 $ i $ 个查询，可以是以下三种格式之一：

```
1 i x
2 i x
3 l r
```

## 输出格式

设类型 $ 3 $ 的查询个数为 $ q $，则输出 $ q $ 行。第 $ i $ 行输出第 $ i $ 个类型 $ 3 $ 的查询的答案。

## 说明/提示

### 制約

- $ 1 \leq N \leq 10^5 $
- $ 1 \leq A_i \leq 10^9 $
- $ 1 \leq B_i \leq 10^9 $
- $ 1 \leq Q \leq 10^5 $
- 类型 $ 1 $, $ 2 $ 的查询中，$ 1 \leq i \leq N $
- 类型 $ 1 $, $ 2 $ 的查询中，$ 1 \leq x \leq 10^9 $
- 类型 $ 3 $ 的查询中，$ 1 \leq l \leq r \leq N $
- 类型 $ 3 $ 的查询中，输出值在 $ 10^{18} $ 以下

## 样例 #1

### 输入

```
3
3 2 4
1 2 2
3
3 1 3
1 1 1
3 1 3
```

### 输出

```
12
7
```

## 样例 #2

### 输入

```
6
65 32 12 5 8 312
4 1 3 15 16 2
6
3 2 6
3 1 5
1 5 6
2 4 9
3 2 6
3 3 5
```

### 输出

```
46080
69840
27648
1728
```



---

---
title: "[ABC369F] Gather Coins"
layout: "post"
diff: 普及+/提高
pid: AT_abc369_f
tag: ['动态规划 DP', '树状数组']
---

# [ABC369F] Gather Coins

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc369/tasks/abc369_f

縦 $ H $ 行、横 $ W $ 列のグリッドがあります。 このグリッドの上から $ i $ 行目、左から $ j $ 列目にあるマスのことを $ (i,j) $ と表記します。

このグリッド上には $ N $ 枚のコインが落ちており、$ i $ 個目のコインはマス $ (R_i,C_i) $ を通ることで拾うことができます。

あなたの目標は、マス $ (1,1) $ から始めて下か右に $ 1 $ マス移動することを繰り返し、できるだけ多くのコインを拾いながらマス $ (H,W) $ まで行くことです。

あなたが拾うことのできるコインの枚数の最大値、およびそれを達成するための移動経路を $ 1 $ つ求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ N $ $ R_1 $ $ C_1 $ $ R_2 $ $ C_2 $ $ \vdots $ $ R_N $ $ C_N $

## 输出格式

$ 2 $ 行出力せよ。 $ 1 $ 行目には、あなたが拾うことのできるコインの枚数の最大値を出力せよ。 $ 2 $ 行目には、それを達成するための移動経路の $ 1 $ つを長さ $ H+W-2 $ の文字列として出力せよ。 ここで、出力する文字列の $ i $ 文字目は、$ i $ 回目の移動において下に移動するならば `D`、右に移動するならば `R` である。

拾うコインの枚数が最大となるような移動経路が複数存在する場合は、そのどれを出力しても良い。

## 说明/提示

### 制約

- $ 2\leq\ H,W\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ N\ \leq\ \min(HW-2,\ 2\times\ 10^5) $
- $ 1\leq\ R_i\ \leq\ H $
- $ 1\leq\ C_i\ \leq\ W $
- $ (R_i,C_i)\neq\ (1,1) $
- $ (R_i,C_i)\neq\ (H,W) $
- $ (R_i,C_i) $ は互いに相異なる
- 入力は全て整数
 
### Sample Explanation 1

!\[\](https://img.atcoder.jp/abc369/8c45374379376c75b6cfd44cb8efeaf8.png) 上図のように $ (1,1)\rightarrow\ (2,1)\rightarrow\ (2,2)\rightarrow\ (2,3)\rightarrow\ (3,3)\rightarrow\ (3,4) $ と移動することで、$ (2,1),(2,3),(3,3) $ にある $ 3 $ 枚のコインを拾うことができます。

### Sample Explanation 2

`RD` という移動経路も正解となります。

## 样例 #1

### 输入

```
3 4 4

3 3

2 1

2 3

1 4
```

### 输出

```
3

DRRDR
```

## 样例 #2

### 输入

```
2 2 2

2 1

1 2
```

### 输出

```
1

DR
```

## 样例 #3

### 输入

```
10 15 8

2 7

2 9

7 9

10 3

7 11

8 12

9 6

8 1
```

### 输出

```
5

DRRRRRRRRDDDDDRRDRDDRRR
```



---

---
title: "[ABC378E] Mod Sigma Problem"
layout: "post"
diff: 普及+/提高
pid: AT_abc378_e
tag: ['树状数组', '分治', '前缀和']
---

# [ABC378E] Mod Sigma Problem

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc378/tasks/abc378_e

You are given a sequence $A = (A_1, A_2, \dots, A_N)$ of $N$ non-negative integers, and a positive integer $M$.

Find the following value:

$$
 \sum_{1 \leq l \leq r \leq N} \left( \left(\sum_{l \leq i \leq r} A_i\right) \mathbin{\mathrm{mod}} M \right). 
$$

Here, $X \mathbin{\mathrm{mod}} M$ denotes the remainder when the non-negative integer $X$ is divided by $M$.

## 输入格式

The input is given from Standard Input in the following format:

> $N$ $M$
>
> $A_1$ $A_2$ $\dots$ $A_N$

## 输出格式

Print the answer.

## 说明/提示

### 制約

### Constraints

-   $1 \leq N \leq 2 \times 10^5$
-   $1 \leq M \leq 2 \times 10^5$
-   $0 \leq A_i \leq 10^9$
 
### Sample Explanation 1

-   $A_1 \mathbin{\mathrm{mod}} M = 2$
-   $(A_1+A_2) \mathbin{\mathrm{mod}} M = 3$
-   $(A_1+A_2+A_3) \mathbin{\mathrm{mod}} M = 3$
-   $A_2 \mathbin{\mathrm{mod}} M = 1$
-   $(A_2+A_3) \mathbin{\mathrm{mod}} M = 1$
-   $A_3 \mathbin{\mathrm{mod}} M = 0$

The answer is the sum of these values, $10$. Note that the outer sum is not taken modulo $M$.

## 样例 #1

### 输入

```
3 4

2 5 0
```

### 输出

```
10
```

## 样例 #2

### 输入

```
10 100

320 578 244 604 145 839 156 857 556 400
```

### 输出

```
2736
```



---

---
title: "[ABC396F] Rotated Inversions"
layout: "post"
diff: 普及+/提高
pid: AT_abc396_f
tag: ['树状数组']
---

# [ABC396F] Rotated Inversions

## 题目描述

给定整数 $N, M$ 和一个长度为 $N$ 的非负整数序列 $A=(A_1, A_2, \ldots, A_N)$。

对于每个 $k=0,1,\ldots,M-1$，请解决以下问题：

> 定义整数序列 $B=(B_1, B_2, \ldots, B_N)$，其中 $B_i = (A_i + k) \bmod M$。求序列 $B$ 的逆序对数。

关于逆序对数的定义：  
序列 $(A_1, A_2, \ldots, A_N)$ 的逆序对数是指满足 $1 \leq i < j \leq N$ 且 $A_i > A_j$ 的整数对 $(i, j)$ 的个数。


## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $A_1$ $A_2$ $\ldots$ $A_N$

## 输出格式

输出共 $M$ 行。  
第 $i$ 行（$1 \leq i \leq M$）应输出 $k = i - 1$ 时的答案。


## 说明/提示

### 约束条件

- $1 \leq N, M \leq 2 \times 10^5$
- $0 \leq A_i < M$
- 输入中的所有值均为整数

### 样例解释 1

- 当 $k=0$ 时：$B=(2, 1, 0)$，逆序对数为 $3$（所有 $(i,j)$ 对均满足条件）。
- 当 $k=1$ 时：$B=(0, 2, 1)$，逆序对数为 $1$（仅 $(2,3)$ 满足）。
- 当 $k=2$ 时：$B=(1, 0, 2)$，逆序对数为 $1$（仅 $(1,2)$ 满足）。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
3 3

2 1 0
```

### 输出

```
3

1

1
```

## 样例 #2

### 输入

```
5 6

5 3 5 0 1
```

### 输出

```
7

3

3

1

1

5
```

## 样例 #3

### 输入

```
7 7

0 1 2 3 4 5 6
```

### 输出

```
0

6

10

12

12

10

6
```



---

---
title: "[ABC405F] Chord Crossing"
layout: "post"
diff: 普及+/提高
pid: AT_abc405_f
tag: ['树状数组', '可持久化线段树']
---

# [ABC405F] Chord Crossing

## 题目描述

在一个圆上等距分布着 $2N$ 个点，顺时针编号为 $1,2,\cdots,2N$。$2N$ 顺时针方向的下一个点是 $1$。

接下来圆上出现了 $M$ 条线段，第 $i$ 条线段的两个端点分别为 $A_i$ 和 $B_i$，并且**这两个端点的编号是偶数**。保证不会有两条线段共享一个端点。

接下来你要回答 $Q$ 个询问，每次询问给出**两个奇数** $C_j,D_j$，你要回答如果圆上新增了一条线段，两个端点分别是 $C_j,D_j$，那么这条新线段会和原有的 $M$ 条线段中的多少条相交。

## 输入格式

第一行两个整数 $N,M(2\le N\le 10^6,1\le M\le \min(\left\lfloor\frac{N}{2}\right\rfloor,2\times 10^5))$。\
接下来 $M$ 行，每行两个整数 $A_i,B_i(1\le A_i<B_i\le 2N,A_i,B_i\bmod2=0)$，表示圆上的线段。保证这 $M$ 条线段中没有两条共享同一端点。\
接下来一行一个整数 $Q(1\le Q\le 2\times 10^5)$。\
接下来 $Q$ 行每行两个整数 $C_j,D_j(1\le C_j<D_j\le 2N,C_j,D_j\bmod 2=1)$，表示一次询问。

## 输出格式

输出 $Q$ 行，每行一个整数依次回答询问。

## 说明/提示

**样例 1 解释**

如下图：

![](https://img.atcoder.jp/abc405/7f9b7b9c988c95df92d0a5919a865fcc.png)

黑点表示圆上的 $2N$ 个点，蓝线为 $M$ 条线段，第 $i$ 条称线段 $i$；红线表示询问，第 $i$ 个对应的线段称询问 $i$。

- 第一次询问中，和询问 $1$ 相交的线段为线段 $1$；
- 第二次询问中，和询问 $2$ 相交的线段有线段 $1,2$；
- 第三次询问中，没有线段和询问 $3$ 相交。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
4 2

2 4

6 8

3

1 3

3 7

1 5
```

### 输出

```
1

2

0
```

## 样例 #2

### 输入

```
20 7

24 34

26 28

18 38

2 14

8 12

30 32

20 22

10

7 29

31 39

9 21

19 29

15 21

11 39

17 21

15 31

5 25

25 31
```

### 输出

```
3

3

4

1

2

2

2

3

3

1
```



---

---
title: "[ABC406F] Compare Tree Weights"
layout: "post"
diff: 普及+/提高
pid: AT_abc406_f
tag: ['树状数组', '树论']
---

# [ABC406F] Compare Tree Weights

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc406/tasks/abc406_f

给定一个有 $N$ 个顶点的树 $T$，顶点和边分别编号为顶点 $1$, 顶点 $2$, $\ldots$, 顶点 $N$ 和边 $1$, 边 $2$, $\ldots$, 边 $(N-1)$。

特别地，边 $i$ $(1 \leq i \leq N-1)$ 连接顶点 $U_i$ 和顶点 $V_i$。

此外，每个顶点都有一个权重，最初，所有顶点的权重都为 $1$。

给定 $Q$ 个查询，请按顺序处理它们。每个查询是以下两种类型之一：

- `1 x w`：将顶点 $x$ 的权重增加 $w$。
- `2 y`：如果删除边 $y$，$T$ 将分裂成两个子树（连通分量）。将每个子树中包含的顶点的权重总和作为该子树的权重时，输出两个子树权重的差。

关于第二种类型的查询，可以证明，从 $T$ 中选择任意一条边并删除它时，$T$ 总是会分裂成两个子树。

另外，请注意，第二种类型的查询实际上并没有删除边。

## 输入格式

输入按以下格式从标准输入给出。

> $N$  
> $U_1$ $V_1$  
> $U_2$ $V_2$  
> $\vdots$  
> $U_{N-1}$ $V_{N-1}$  
> $Q$  
> $\mathrm{query}_1$  
> $\mathrm{query}_2$  
> $\vdots$  
> $\mathrm{query}_Q$

每个查询 $\mathrm{query}_i$ $(1 \leq i \leq Q)$ 按以下任一格式给出。

> $1$ $x$ $w$
>
> $2$ $y$

## 输出格式

设第二种类型查询的个数为 $K$，输出 $K$ 行。第 $i$ 行 $(1 \leq i \leq K)$ 输出第 $i$ 个第二种类型查询的答案。

## 说明/提示

**「数据范围」**

- $2 \leq N \leq 3 \times 10^5$
- $1 \leq U_i, V_i \leq N$
- $1 \leq Q \leq 3 \times 10^5$
- $1 \leq x \leq N$
- $1 \leq w \leq 1000$
- $1 \leq y \leq N-1$
- 输入均为整数
- 给定的图是一棵树。
- 至少存在一个第二种类型的查询。

**「样例 1 解释」**

树 $T$ 的结构和顶点编号对应如下图左所示。最初，所有顶点的权重都为 $1$。

对于第 $1$ 个查询，考虑删除边 $1$。此时，树会分裂成包含顶点 $1$ 的子树和包含顶点 $2$ 的子树。包含顶点 $1$ 的子树的权重为 $2$，包含顶点 $2$ 的子树的权重为 $4$，因此输出它们的差 $2$。（下图右）

![](https://img.atcoder.jp/abc406/6f17e951940c2460b3ae5fe8e6bddc52.png)

对于第 $2$ 个查询，将顶点 $1$ 的权重增加 $3$。

对于第 $3$ 个查询，考虑删除边 $1$。包含顶点 $1$ 的子树的权重为 $5$，包含顶点 $2$ 的子树的权重为 $4$，因此输出它们的差 $1$。（下图左）

对于第 $4$ 个查询，将顶点 $4$ 的权重增加 $10$。

对于第 $5$ 个查询，考虑删除边 $5$。此时，树会分裂成包含顶点 $4$ 的子树和仅包含顶点 $6$ 的子树。包含顶点 $4$ 的子树的权重为 $18$，仅包含顶点 $6$ 的子树的权重为 $1$，因此输出它们的差 $17$。（下图右）

![](https://img.atcoder.jp/abc406/c5eacf2967bcc2b09866a0d8b83104c4.png)

因此，按顺序换行输出第二种类型查询的答案 $2, 1, 17$。

## 样例 #1

### 输入

```
6
1 2
1 3
2 4
4 5
4 6
5
2 1
1 1 3
2 1
1 4 10
2 5
```

### 输出

```
2
1
17
```



---

---
title: "滑动窗口最大值"
layout: "post"
diff: 普及+/提高
pid: AT_abc407_f
tag: ['线段树', '树状数组', '差分', '单调栈']
---

# 滑动窗口最大值

## 题目描述

给你一个长度为 $N$ 的数列 $A=(A_1,\dots,A_N)$，请对于所有 $1\le k\le N$ 求解下面的问题：

- 求出 $A$ 的全部 $N-k+1$ 个连续子序列的最大值的和。

## 输入格式

将按照以下格式输入：

> $N$
>
> $A_1$ $ A_2$ $A_3$ $\dots$ $A_N$

## 输出格式

$N$ 行，第 $i$ 行为 $k=i$ 时所求解问题的答案。

## 说明/提示

### 数据规模与约定

- $1 \le N \le 2 \times 10^{5}$
- $0 \le A_i \le 10^{7} (1 \le i \le N)$
- 输入的所有数字为整数。

## 样例 #1

### 输入

```
4
5 3 4 2
```

### 输出

```
14
13
9
5
```

## 样例 #2

### 输入

```
8
2 0 2 5 0 5 2 4
```

### 输出

```
20
28
27
25
20
15
10
5
```

## 样例 #3

### 输入

```
11
9203973 9141294 9444773 9292472 5507634 9599162 497764 430010 4152216 3574307 430010
```

### 输出

```
61273615
68960818
69588453
65590626
61592799
57594972
47995810
38396648
28797486
19198324
9599162
```



---

---
title: "[ABC408F] Athletic"
layout: "post"
diff: 普及+/提高
pid: AT_abc408_f
tag: ['动态规划 DP', '线段树', '树状数组', '动态规划优化']
---

# [ABC408F] Athletic

## 题目描述

场上有 $N$ 个脚手架，第 $i$ 个脚手架的高度为 $H_i$。

高桥将用这些脚手架玩一个游戏。他将任意选定一个脚手架作为起点并持续移动到其他脚手架，从脚手架 $i$ 可以移动到脚手架 $j$ 当且仅当 $H_j\le H_i-D$ 且 $\vert i-j\vert \le R$。

求在游戏过程中他最多可以移动多少次。

## 输入格式

第一行三个整数 $N,D,R(1\le D,R\le N\le 5\times 10^5)$。\
第二行 $N$ 个整数 $H_1,H_2,\cdots,H_N$。$H$ 为 $1$ 到 $N$ 的排列。

## 输出格式

输出一行一个整数表示答案。

## 说明/提示

**样例 1 解释**

高桥可以选择脚手架 $1$ 作为起点。
- 因为 $H_2\le H_1-D,\vert 2-1\vert\le R$，所以高桥可以从脚手架 $1$ 移动到脚手架 $2$。
- 因为 $H_3\le H_2-D,\vert 3-2\vert\le R$，所以高桥可以从脚手架 $2$ 移动到脚手架 $3$。

共移动两次。可以证明高桥不能移动更多次数，故答案为 $2$。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
5 2 1

5 3 1 4 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
13 3 2

13 7 10 1 9 5 4 11 12 2 8 6 3
```

### 输出

```
3
```



---

---
title: "フェーン現象 (Foehn Phenomena)"
layout: "post"
diff: 普及+/提高
pid: AT_joi2017ho_a
tag: ['线段树', '树状数组', '差分']
---

# フェーン現象 (Foehn Phenomena)

## 题目描述

### 题目简述

你知道$N+1$个地点的海拔$A_i$,编号为$0 \dots N$,有风从$0$吹向$N$,想让你求出地点$N$的风的温度.

保证$A_0=0$

规则：
- 如果$A_i=A_{i+1}$风的温度不变.
- 如果$A_i>A_{i+1}$由于海拔降低,风的温度会上升$(A_i-A_{i+1})\times T$度
- 如果$A_i<A_{i+1}$由于海拔升高,风的温度会下降$(A_{i+1}-A_i)\times S$度

## 输入格式

从标准输入中读入下面的数据.

- 第一行输入包括四个被空格隔开的整数$N,Q,S,T$.这表示JOI先生在地点$N$有一所房子,有$Q$次地壳运动,海拔每上升1米的话,风的温度会降低$S$度,海拔每下降一米的话,风的温度会上升$T$度.
- 接下来的$N+1$行中第$i$行$(1\leq i\leq N+1)$包含一个整数$A_{i-1}$,表示地壳运动前地点$i-1$的海拔高度.
- 接下来的$Q$行中第$j$行$(1\leq j\leq Q)$包括三个被空格隔开的整数$L_j,R_j,X_j$.这表示第$j$天地壳运动使地点$L_j$到地点$R_j$中这些地点的海拔变化了$X_j$

## 输出格式

输出$Q$行,第$j$行的输出代表第$j$天地壳运动后JOI先生家的风的温度.
(即$N$位置的风的温度)

## 样例 #1

### 输入

```
3 5 1 2
0
4
1
8
1 2 2
1 1 -2
2 3 5
1 2 -1
1 3 5
```

### 输出

```
-5
-7
-13
-13
-18
```

## 样例 #2

### 输入

```
2 2 5 5
0
6
-1
1 1 4
1 2 8
```

### 输出

```
5
-35
```

## 样例 #3

### 输入

```
7 8 8 13
0
4
-9
4
-2
3
10
-9
1 4 8
3 5 -2
3 3 9
1 7 4
3 5 -1
5 6 3
4 4 9
6 7 -10
```

### 输出

```
277
277
322
290
290
290
290
370
```



---


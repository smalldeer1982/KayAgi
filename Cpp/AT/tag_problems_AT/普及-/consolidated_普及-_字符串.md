---
title: "[ABC008B] 投票"
layout: "post"
diff: 普及-
pid: AT_abc008_2
tag: ['字符串']
---

# [ABC008B] 投票

## 题目描述

题目大意
某个组织进行了选拔领导人的选举。组织由n人组成，每个人都写了最领导的人物的名字。投票数最多的人的名字就是领袖。如果有多个得票数最多的人物，输出其中一个即可。

## 输入格式

第一行,n个人
接下来n行,输入领导人的名字

## 输出格式

票数最多的领导人

## 说明/提示

1<=名字长度<=50


感谢@Andysun06  提供的翻译

## 样例 #1

### 输入

```
4

taro

jiro

taro

saburo
```

### 输出

```
taro
```

## 样例 #2

### 输入

```
1

takahashikun
```

### 输出

```
takahashikun
```

## 样例 #3

### 输入

```
9

a

b

c

c

b

c

b

d

e
```

### 输出

```
b
```



---

---
title: "[ABC029B] カキ"
layout: "post"
diff: 普及-
pid: AT_abc029_b
tag: ['字符串', '枚举']
---

# [ABC029B] カキ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc029/tasks/abc029_b

英小文字からなる $ 12 $ 個の文字列 $ S_1 $, $ S_2 $, ..., $ S_{12} $ が入力されます。  
これらの文字列のうち、文字 `r` が含まれるものの個数を数えてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ S_1 $ $ S_2 $ : $ S_{12} $

- $ i $ 行目 ($ 1 $ $ ≦ $ $ i $ $ ≦ $ $ 12 $) に、英小文字からなる文字列 $ S_i $ ($ 1 $ $ ≦ $ $ |S_i| $ $ ≦ $ $ 10 $) が与えられる。  
  これらの文字列はすべて異なる。

## 输出格式

標準出力に、 $ 12 $ 個の文字列 $ S_1 $, $ S_2 $, ..., $ S_{12} $ のうち文字 `r` が含まれるものの個数を出力し、最後に改行せよ。   
`r` を複数個含む文字列は一度だけ数える。

## 说明/提示

### Sample Explanation 1

$ S_1 $, $ S_2 $, $ S_3 $, $ S_4 $, $ S_9 $, $ S_{10} $, $ S_{11} $, $ S_{12} $ の $ 8 $ 個の文字列に文字 `r` が含まれています。 $ S_2 $ には `r` が $ 2 $ 回出現していますが、一度しか数えません。

## 样例 #1

### 输入

```
january

february

march

april

may

june

july

august

september

october

november

december
```

### 输出

```
8
```

## 样例 #2

### 输入

```
rrrrrrrrrr

srrrrrrrrr

rsr

ssr

rrs

srsrrrrrr

rssrrrrrr

sss

rrr

srr

rsrrrrrrrr

ssrrrrrrrr
```

### 输出

```
11
```



---

---
title: "[ABC029C] Brute-force Attack"
layout: "post"
diff: 普及-
pid: AT_abc029_c
tag: ['字符串', '搜索', '递归']
---

# [ABC029C] Brute-force Attack

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc029/tasks/abc029_c

あなたはスーパーハッカーです。高橋君を攻撃対象に定めたあなたは、  
高橋君のパソコンのパスワードに関して次の事実を突き止めました。

- 長さは $ N $ 文字である。
- `a`, `b`, `c` 以外の文字は含まれない。
 
 高橋君のパソコンのパスワードの候補として考えられる文字列をすべて列挙してしまいましょう。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $

- $ 1 $ 行目にパスワードの長さ $ N $ ($ 1 $ $ ≦ $ $ N $ $ ≦ $ $ 8 $) が与えられる。

## 输出格式

標準出力に、問題文中の二つの条件をともに満たす文字列すべてを一行に一個ずつ辞書順に出力せよ。  
「辞書順」に関しては出力例2の注釈を見よ。  
最後の文字列の後ろにも改行を入れること。大文字と小文字は区別される。

## 说明/提示

### Sample Explanation 2

(※) 英小文字からなる同じ長さの異なる文字列 $ s $ と $ t $ について、 次の条件が満たされるとき $ s $ は $ t $ より辞書順で先となり、そうでなければ $ s $ は $ t $ より辞書順で後となります。 - ある整数 $ i $ ($ 1 $ $ ≦ $ $ i $ $ ≦ $ $ |s| $ $ = $ $ |t| $) が存在し、 $ 1 $ 文字目から $ i-1 $ 文字目 (両端含む) までは $ s $ と $ t $ は一致するが、 $ i $ 文字目は一致せず、 $ s $ の $ i $ 文字目の方がアルファベット順で先である。 例えば、 `cab**a**c` は `cab**c**a` より辞書順で先となります ($ i $ $ = $ $ 4 $ とすると条件が成立します) 。

## 样例 #1

### 输入

```
1
```

### 输出

```
a

b

c
```

## 样例 #2

### 输入

```
2
```

### 输出

```
aa

ab

ac

ba

bb

bc

ca

cb

cc
```



---

---
title: "[ABC084B] Postal Code"
layout: "post"
diff: 普及-
pid: AT_abc084_b
tag: ['字符串']
---

# [ABC084B] Postal Code

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc084/tasks/abc084_b

Atcoder国では、郵便番号は $ A+B+1 $ 文字からなり、$ A+1 $ 文字目はハイフン `-`、それ以外の全ての文字は $ 0 $ 以上 $ 9 $ 以下の数字です。

文字列 $ S $ が与えられるので、Atcoder国の郵便番号の形式を満たすかどうか判定してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ A $ $ B $ $ S $

## 输出格式

$ S $ がAtcoder国の郵便番号の形式を満たすならば `Yes` 、そうでなければ `No` を出力せよ。

## 说明/提示

### 制約

- $ 1≦A,B≦5 $
- $ |S|=A+B+1 $
- $ S $ は $ 0 $ 以上 $ 9 $ 以下の数字、およびハイフン `-` からなる

### Sample Explanation 1

$ S $ の $ A+1 $ 文字目がハイフンで、それ以外の全ての文字が $ 0 $ 以上 $ 9 $ 以下の数字なので、Atcoder国の郵便番号の形式を満たしています。

### Sample Explanation 2

$ S $ の $ A+1 $ 文字目以外もハイフンとなっており、Atcoder国の郵便番号の形式を満たしていません。

## 样例 #1

### 输入

```
3 4

269-6650
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
1 1

---
```

### 输出

```
No
```

## 样例 #3

### 输入

```
1 2

7444
```

### 输出

```
No
```



---

---
title: "[ABC360B] Vertical Reading"
layout: "post"
diff: 普及-
pid: AT_abc360_b
tag: ['字符串']
---

# [ABC360B] Vertical Reading

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc360/tasks/abc360_b

英小文字からなる文字列 $ S $ と $ T $ が与えられます。

以下の条件を満たす $ 1\ \leq\ c\ \leq\ w\ <\ |S| $ となる整数の組 $ c $ と $ w $ が存在するか判定してください。ただし、 $ |S| $ は文字列 $ S $ の長さを表します。ここで、$ w $ は $ |S| $ **未満**である必要があることに注意してください。

- $ S $ を先頭から順に $ w $ 文字毎に区切ったとき、長さが $ c $ 以上の文字列の $ c $ 文字目を順番に連結した文字列が $ T $ と一致する

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ S $ $ T $

## 输出格式

条件を満たすような $ 1\ \leq\ c\ \leq\ w\ <\ |S| $ となる整数の組 $ c $ と $ w $ が存在する場合は `Yes` を、存在しない場合は `No` を出力せよ。

## 说明/提示

### 制約

- $ S $ と $ T $ は英小文字からなる文字列
- $ 1\ \leq\ |T| $$ \leq $ $ |S|\ \leq\ 100 $

### Sample Explanation 1

$ S $ を $ 2 $ 文字毎に区切ると以下のようになります。 ``` at co de r ``` 区切った後、 $ 2 $ 文字以上の文字列の $ 2 $ 文字目を取り出し連結させたときの文字列は、 `toe` となり $ T $ と一致します。よって、 `Yes` を出力します。

### Sample Explanation 2

$ w=|S| $ であることはないため、条件を満たすような $ 1\ \leq\ c\ \leq\ w\ <\ |S| $ となる整数の組 $ c $ と $ w $ は存在しません。よって、 `No` を出力します。

## 样例 #1

### 输入

```
atcoder toe
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
beginner r
```

### 输出

```
No
```

## 样例 #3

### 输入

```
verticalreading agh
```

### 输出

```
No
```



---

---
title: "[ABC381C] 11/22 Substring"
layout: "post"
diff: 普及-
pid: AT_abc381_c
tag: ['模拟', '字符串']
---

# [ABC381C] 11/22 Substring

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc381/tasks/abc381_c

> この問題における 11/22 文字列の定義は A 問題および E 問題と同じです。

文字列 $ T $ が以下の条件を全て満たすとき、$ T $ を **11/22 文字列** と呼びます。

- $ |T| $ は奇数である。ここで、$ |T| $ は $ T $ の長さを表す。
- $ 1 $ 文字目から $ \frac{|T|+1}{2}\ -\ 1 $ 文字目までが `1` である。
- $ \frac{|T|+1}{2} $ 文字目が `/` である。
- $ \frac{|T|+1}{2}\ +\ 1 $ 文字目から $ |T| $ 文字目までが `2` である。

例えば `11/22`, `111/222`, `/` は 11/22 文字列ですが、`1122`, `1/22`, `11/2222`, `22/11`, `//2/2/211` はそうではありません。

`1`, `2`, `/` からなる長さ $ N $ の文字列 $ S $ が与えられます。$ S $ は `/` を $ 1 $ 個以上含みます。  
11/22 文字列であるような $ S $ の(連続な)部分文字列の長さの最大値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $

## 输出格式

11/22 文字列であるような $ S $ の(連続な)部分文字列の長さの最大値を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ S $ は `1`, `2`, `/` からなる長さ $ N $ の文字列
- $ S $ は `/` を $ 1 $ 個以上含む

### Sample Explanation 1

$ S $ の $ 2 $ 文字目から $ 6 $ 文字目からなる部分文字列は `11/22` で、これは 11/22 文字列です。$ S $ の部分文字列のうち 11/22 文字列であるものはこれが最長です。よって $ 5 $ が答えです。

## 样例 #1

### 输入

```
8
211/2212
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
22/11
```

### 输出

```
1
```

## 样例 #3

### 输入

```
22
/1211/2///2111/2222/11
```

### 输出

```
7
```



---

---
title: "[ABC385B] Santa Claus 1"
layout: "post"
diff: 普及-
pid: AT_abc385_b
tag: ['字符串']
---

# [ABC385B] Santa Claus 1

## 题目描述

有一个 $H$ 行 $W$ 列的网格。用 $(i,j)$ 表示从上往下数第 $i$ 行、从左往右数第 $j$ 列的单元格。 

如果 $S_{i,j}$ 是 `#`，则单元格 $(i,j)$ 不可通过；如果是 `.`，则该单元格可以通过且没有房子；如果是 `@`，则该单元格可以通过且有一个房子。

最初，圣诞老人在单元格 $(X,Y)$ 中。他将按照字符串 $T$ 的指示行动，具体如下：

- 设 $|T|$ 为字符串 $T$ 的长度。对于 $i=1,2,\ldots,|T|$，他按以下方式移动：
    - 设 $(x,y)$ 为他当前所在的单元格。
        - 如果 $T_i$ 是 `U` 且单元格 $(x-1,y)$ 可通过，则移动到单元格 $(x-1,y)$。
        - 如果 $T_i$ 是 `D` 且单元格 $(x+1,y)$ 可通过，则移动到单元格 $(x+1,y)$。
        - 如果 $T_i$ 是 `L` 且单元格 $(x,y-1)$ 可通过，则移动到单元格 $(x,y-1)$。
        - 如果 $T_i$ 是 `R` 且单元格 $(x,y+1)$ 可通过，则移动到单元格 $(x,y+1)$。
        - 否则，停留在单元格 $(x,y)$。

请找出他完成所有行动后所在的单元格，以及他在行动过程中经过或到达的不同房子的数量。如果多次经过同一个房子，只计数一次。

## 输入格式

输入从标准输入按以下格式给出：

> $H$ $W$ $X$ $Y$  
$S_{1,1}S_{1,2}\ldots S_{1,W}$  
$\dots$  
$S_{H,1}S_{H,2}\ldots S_{H,W}$  
$T$

## 输出格式

设 $(X,Y)$ 为他完成所有行动后所在的单元格，$C$ 为他在行动过程中经过或到达的不同房子的数量。按顺序输出用空格分隔的 $X$、$Y$、$C$。

**【样例 $\bm 1$ 解释】**

圣诞老人的行动如下：

- $T_1=$ `L`，所以他从 $(3,4)$ 移动到 $(3,3)$。经过了一个房子。
- $T_2=$ `L`，所以他从 $(3,3)$ 移动到 $(3,2)$。
- $T_3=$ `L`，但单元格 $(3,1)$ 不可通过，所以他停留在 $(3,2)$。
- $T_4=$ `D`，所以他从 $(3,2)$ 移动到 $(4,2)$。
- $T_5=$ `R`，所以他从 $(4,2)$ 移动到 $(4,3)$。
- $T_6=$ `U`，所以他从 $(4,3)$ 移动到 $(3,3)$。经过了一个房子，但这个房子之前已经经过过。
- $T_7=$ `U`，所以他从 $(3,3)$ 移动到 $(2,3)$。

他在行动过程中经过或到达的房子数量为 $1$。

## 说明/提示

- $3 \leq H,W \leq 100$
- $1 \leq X \leq H$
- $1 \leq Y \leq W$
- 所有给定数字均为整数。
- 每个 $S_{i,j}$ 是 `#`、`.` 或 `@` 之一。
- 对于每个 $1 \leq i \leq H$，$S_{i,1}$ 和 $S_{i,W}$ 都是 `#`。
- 对于每个 $1 \leq j \leq W$，$S_{1,j}$ 和 $S_{H,j}$ 都是 `#`。
- $S_{X,Y}=$ `.`
- $T$ 是一个长度至少为 $1$ 且最多为 $10^4$ 的字符串，仅由 `U`、`D`、`L`、`R` 组成。

## 样例 #1

### 输入

```
5 5 3 4
#####
#...#
#.@.#
#..@#
#####
LLLDRUU
```

### 输出

```
2 3 1
```

## 样例 #2

### 输入

```
6 13 4 6
#############
#@@@@@@@@@@@#
#@@@@@@@@@@@#
#@@@@.@@@@@@#
#@@@@@@@@@@@#
#############
UURUURLRLUUDDURDURRR
```

### 输出

```
3 11 11
```

## 样例 #3

### 输入

```
12 35 7 10
###################################
#.................................#
#..........@......................#
#......@................@.........#
#.............##............@.....#
#...##........##....##............#
#...##........##....##.......##...#
#....##......##......##....##.....#
#....##......##......##..##.......#
#.....#######.........###.........#
#.................................#
###################################
LRURRRUUDDULUDUUDLRLRDRRLULRRUDLDRU
```

### 输出

```
4 14 1
```



---

---
title: "[ABC386C] Operate 1"
layout: "post"
diff: 普及-
pid: AT_abc386_c
tag: ['模拟', '字符串', '分类讨论']
---

# [ABC386C] Operate 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc386/tasks/abc386_c

**この問題は F 問題 (Operate K) の部分問題であり、 $ K=1 $ です。**  
 **F 問題に正解するコードをこの問題に提出することで、この問題に正解できます。**

文字列 $ S $ に対して以下の操作を $ 0 $ 回以上 $ K $ 回以下行って、文字列 $ T $ と一致させられるか判定してください。

- 次の $ 3 $ 種類の操作のうちひとつを選択し、実行する。
  - $ S $ 中の (先頭や末尾を含む) 任意の位置に、任意の文字を $ 1 $ つ挿入する。
  - $ S $ 中の文字を $ 1 $ つ選び、削除する。
  - $ S $ 中の文字を $ 1 $ つ選び、別の $ 1 $ つの文字に変更する。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ K $ $ S $ $ T $

## 输出格式

$ K $ 回以下の操作で $ S $ を $ T $ に一致させられる時 `Yes` 、そうでない時 `No` と出力せよ。

## 说明/提示

### 制約

- $ S,T $ は英小文字からなる長さ $ 1 $ 以上 $ 500000 $ 以下の文字列
- $ \color{red}{K=1} $
 
### Sample Explanation 1

`abc` の $ 2 $ 文字目の `b` を `g` に置き換えることで、 `abc` を $ 1 $ 回の操作で `agc` に変換できます。

### Sample Explanation 2

$ 1 $ 回の操作では `abc` を `awtf` に変換できません。

### Sample Explanation 3

`abc` の $ 2 $ 文字目の `b` を削除することで、 `abc` を $ 1 $ 回の操作で `ac` に変換できます。

### Sample Explanation 4

`back` の $ 1 $ 文字目と $ 2 $ 文字目の間に `l` を挿入することで、 `back` を $ 1 $ 回の操作で `black` に変換できます。

### Sample Explanation 5

初めから $ S=T $ である場合もあります。

## 样例 #1

### 输入

```
1

abc

agc
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
1

abc

awtf
```

### 输出

```
No
```

## 样例 #3

### 输入

```
1

abc

ac
```

### 输出

```
Yes
```

## 样例 #4

### 输入

```
1

back

black
```

### 输出

```
Yes
```

## 样例 #5

### 输入

```
1

same

same
```

### 输出

```
Yes
```

## 样例 #6

### 输入

```
1

leap

read
```

### 输出

```
No
```



---

---
title: "[ABC394C] Debug"
layout: "post"
diff: 普及-
pid: AT_abc394_c
tag: ['字符串']
---

# [ABC394C] Debug

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc394/tasks/abc394_c

给定一个仅由大写字母组成的字符串 $S$。  
请输出对 $S$ 执行以下操作后得到的最终字符串：

> 只要字符串中包含连续的 `WA` 子字符串，就重复执行以下操作：
> 
> - 将字符串中首次出现的 `WA` 替换为 `AC`。

可以证明在本题的约束条件下，此操作最多只能执行有限次。

## 输入格式

输入通过标准输入按以下格式给出：

> $S$

## 输出格式

输出对 $S$ 执行题目所述操作后得到的字符串。

## 说明/提示

### 约束条件

- $S$ 是长度介于 $1$ 到 $3 \times 10^5$ 之间的仅由大写字母组成的字符串

### 样例解释 1

初始字符串为 $S=$ `WACWA`。该字符串包含从第 $1$ 到 $2$ 个字符和从第 $4$ 到 $5$ 个字符的 `WA` 子字符串。第一次操作将替换最先出现的部分（即第 $1$ 到 $2$ 个字符），得到 `ACCWA`。此时字符串仅剩第 $4$ 到 $5$ 个字符的 `WA`，第二次操作替换后得到 `ACCAC`。由于 `ACCAC` 不再包含 `WA`，操作终止，因此输出 `ACCAC`。

### 样例解释 2

初始字符串为 $S=$ `WWA`。该字符串仅在第 $2$ 到 $3$ 个字符处包含 `WA`。第一次操作替换后得到 `WAC`，此时新字符串在第 $1$ 到 $2$ 个字符处出现 `WA`。第二次操作替换后得到 `ACC`。由于不再包含 `WA`，操作终止，因此输出 `ACC`。

### 样例解释 3

原始字符串 $S$ 中不包含 `WA` 子字符串，因此无需任何操作，直接输出 `WWWWW`。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
WACWA
```

### 输出

```
ACCAC
```

## 样例 #2

### 输入

```
WWA
```

### 输出

```
ACC
```

## 样例 #3

### 输入

```
WWWWW
```

### 输出

```
WWWWW
```



---

---
title: "[ABC397B] Ticket Gate Log"
layout: "post"
diff: 普及-
pid: AT_abc397_b
tag: ['字符串']
---

# [ABC397B] Ticket Gate Log

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc397/tasks/abc397_b

高桥君收集了检票闸机的使用记录。然而他不小心删除了一部分进出场记录，现在正尝试恢复这些被删除的记录。

给定一个仅由字符 `i` 和 `o` 构成的字符串 $S$。我们可以在 $S$ 的任意位置插入 $0$ 个或多个字符，使得修改后的字符串满足以下条件：

- 字符串长度为偶数，且奇数位置的字符为 `i`，偶数位置的字符为 `o`。

请计算需要插入的最小字符数。根据题目约束条件，可以证明通过插入有限个字符一定能满足上述条件。

## 输入格式

输入通过标准输入给出，格式如下：

> $S$

## 输出格式

输出答案。

## 说明/提示

### 约束条件

- $S$ 是仅由 `i` 和 `o` 构成的字符串，长度在 $1$ 到 $100$ 之间

### 样例解释 1

在第 $3$ 个字符后插入 `o`，得到 `ioio` 即可满足条件。无法通过插入 $0$ 个或更少字符实现条件。

### 样例解释 2

在第 $1$ 个字符后插入 `o`，在第 $3$ 个字符后插入 `i`，得到 `ioio` 即可满足条件。无法通过插入 $1$ 个或更少字符实现条件。

### 样例解释 3

原字符串 $S$ 已经满足条件。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
ioi
```

### 输出

```
1
```

## 样例 #2

### 输入

```
iioo
```

### 输出

```
2
```

## 样例 #3

### 输入

```
io
```

### 输出

```
0
```



---

---
title: "[ABC403B] Four Hidden"
layout: "post"
diff: 普及-
pid: AT_abc403_b
tag: ['字符串（入门）']
---

# [ABC403B] Four Hidden

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc403/tasks/abc403_b

给定一个由小写字母和 `?` 组成的字符串 $T$，以及一个仅由小写字母组成的字符串 $U$。

字符串 $T$ 是通过将某个仅由小写字母组成的字符串 $S$ 中的恰好 $4$ 个字符替换为 `?` 而得到的。

请判断是否存在这样的 $S$，使得 $S$ 包含 $U$ 作为连续子字符串。

## 输入格式

输入通过标准输入给出，格式如下：

> $T$  
> $U$

## 输出格式

如果存在可能的 $S$ 包含 $U$ 作为连续子字符串，则输出 `Yes`；否则输出 `No`。


## 说明/提示

### 约束条件

- $T$ 是长度为 $4$ 到 $10$ 的由小写字母和 `?` 组成的字符串
- $T$ 中恰好包含 $4$ 个 `?`
- $U$ 是长度为 $1$ 到 $|T|$ 的仅由小写字母组成的字符串

### 样例解释 #1

例如，当 $S$ 为 `takanashi` 时，它包含 `nashi` 作为连续子字符串。

### 样例解释 #2

无论 `?` 被替换为何种字符，$S$ 都不可能包含 `snuke` 作为连续子字符串。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
tak??a?h?
nashi
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
??e??e
snuke
```

### 输出

```
No
```

## 样例 #3

### 输入

```
????
aoki
```

### 输出

```
Yes
```



---

---
title: "[ABC404B] Grid Rotation"
layout: "post"
diff: 普及-
pid: AT_abc404_b
tag: ['模拟', '字符串']
---

# [ABC404B] Grid Rotation

## 题目描述

给你两个网格 $S$ 和 $T$，均有 $N$ 行 $N$ 列。约定格子 $(i,j)$ 表示从上往下第 $i$ 行、从左往右第 $j$ 列的格子。

$S$ 和 $T$ 的每个格子都被染成了黑白两种颜色中的一种，若 $S_{i,j}$ 为字符 `.`，那么 $S$ 中的格子 $(i,j)$ 是白色的，若 $S_{i,j}$ 为字符 `#`，那么 $S$ 中的格子 $(i,j)$ 是黑色的。$T$ 中的格子同理。

你可以执行以下两种操作若干次，求最少需要操作多少次才能使得 $S$ 和 $T$ 完全相同：

- 选择一个 $S$ 中的格子，如果它是白色的，将它染成黑色；如果它是黑色的，将它染成白色。
- 将 $S$ 顺时针旋转 $90\degree$。

## 输入格式

第一行一个整数 $N(1\le N\le 100)$。\
接下来 $N$ 行，每行一个长度为 $N$ 的、仅由 `.` 和 `#` 构成的字符串，表示 $S$。\
接下来 $N$ 行，每行一个长度为 $N$ 的、仅由 `.` 和 `#` 构成的字符串，表示 $T$。

## 输出格式

一行一个整数，表示答案。

## 说明/提示

**样例 1 解释**

如下图，两次操作可以使 $S$ 和 $T$ 变得相同。

![](https://img.atcoder.jp/abc404/ba23906703e10d3d450486afe6eb488f.png)

By chenxi2009

## 样例 #1

### 输入

```
4

###.

..#.

..#.

..#.

...#

...#

###.

....
```

### 输出

```
2
```

## 样例 #2

### 输入

```
13

.#..###..##..

#.#.#..#.#.#.

#.#.###..#...

###.#..#.#.#.

#.#.###..##..

.............

..#...#....#.

.##..#.#..##.

#.#..#.#.#.#.

####.#.#.####

..#..#.#...#.

..#...#....#.

.............

.............

.#....#...#..

.#...#.#..#..

####.#.#.####

.#.#.###..#.#

.##....#..##.

.#....#...#..

.............

..##..###.#.#

.#.#.#..#.###

.#.#..###.#.#

.#.#.#..#.#.#

..##..###..#.
```

### 输出

```
5
```



---

---
title: "网格旋转"
layout: "post"
diff: 普及-
pid: AT_abc404_b
tag: ['模拟', '字符串']
---

# 网格旋转

## 题目描述

给你两个网格 $S$ 和 $T$，均有 $N$ 行 $N$ 列。约定格子 $(i,j)$ 表示从上往下第 $i$ 行、从左往右第 $j$ 列的格子。

$S$ 和 $T$ 的每个格子都被染成了黑白两种颜色中的一种，若 $S_{i,j}$ 为字符 `.`，那么 $S$ 中的格子 $(i,j)$ 是白色的，若 $S_{i,j}$ 为字符 `#`，那么 $S$ 中的格子 $(i,j)$ 是黑色的。$T$ 中的格子同理。

你可以执行以下两种操作若干次，求最少需要操作多少次才能使得 $S$ 和 $T$ 完全相同：

- 选择一个 $S$ 中的格子，如果它是白色的，将它染成黑色；如果它是黑色的，将它染成白色。
- 将 $S$ 顺时针旋转 $90\degree$。

## 输入格式

第一行一个整数 $N(1\le N\le 100)$。\
接下来 $N$ 行，每行一个长度为 $N$ 的、仅由 `.` 和 `#` 构成的字符串，表示 $S$。\
接下来 $N$ 行，每行一个长度为 $N$ 的、仅由 `.` 和 `#` 构成的字符串，表示 $T$。

## 输出格式

一行一个整数，表示答案。

## 说明/提示

**样例 1 解释**

如下图，两次操作可以使 $S$ 和 $T$ 变得相同。

![](https://img.atcoder.jp/abc404/ba23906703e10d3d450486afe6eb488f.png)

By chenxi2009

## 样例 #1

### 输入

```
4

###.

..#.

..#.

..#.

...#

...#

###.

....
```

### 输出

```
2
```

## 样例 #2

### 输入

```
13

.#..###..##..

#.#.#..#.#.#.

#.#.###..#...

###.#..#.#.#.

#.#.###..##..

.............

..#...#....#.

.##..#.#..##.

#.#..#.#.#.#.

####.#.#.####

..#..#.#...#.

..#...#....#.

.............

.............

.#....#...#..

.#...#.#..#..

####.#.#.####

.#.#.###..#.#

.##....#..##.

.#....#...#..

.............

..##..###.#.#

.#.#.#..#.###

.#.#..###.#.#

.#.#.#..#.#.#

..##..###..#.
```

### 输出

```
5
```



---

---
title: "[AGC040A] ><"
layout: "post"
diff: 普及-
pid: AT_agc040_a
tag: ['字符串', '贪心']
---

# [AGC040A] ><

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc040/tasks/agc040_a

長さ $ N-1 $ の文字列 $ S $ が与えられます． $ S $ の各文字は `<` または `>` です．

長さ $ N $ の非負整数列 $ a_1,a_2,\cdots,a_N $ は， すべての $ i $ ($ 1\ \leq\ i\ \leq\ N-1 $) について次の条件をみたす時，**良い非負整数列**と呼ばれます．

- $ S_i= $ `<` のとき： $ a_i\ <\ a_{i+1} $
- $ S_i= $ `>` のとき： $ a_i\ >\ a_{i+1} $

良い非負整数列の要素の総和としてありうる最小の値を求めてください．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ S $

## 输出格式

良い非負整数列の要素の総和としてありうる最小の値を出力せよ．

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ S $ は `<` と `>` のみから成る長さ $ N-1 $ の文字列．

### Sample Explanation 1

$ a=(0,2,1,0) $ は良い非負整数列であり， この場合の要素の総和は $ 3 $ になります． 要素の総和が $ 3 $ より小さい良い非負整数列は存在しません．

## 样例 #1

### 输入

```
<>>
```

### 输出

```
3
```

## 样例 #2

### 输入

```
<>>><<><<<<<>>><
```

### 输出

```
28
```



---

---
title: "[ARC009B] おとぎの国の高橋君"
layout: "post"
diff: 普及-
pid: AT_arc009_2
tag: ['字符串', '排序']
---

# [ARC009B] おとぎの国の高橋君

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc009/tasks/arc009_2

高橋君の住むAtCoder国では、私達が普段使用する数字と同様に $ 10 $ 個のアラビア数字 $ (0-9) $ の $ 10 $ 進数が使われています。  
 しかし、私達が普段使用する数字は大小関係が $ 0\ の順になっているのに対して、

AtCoder国の数字ではその大小関係が異なっています。

例えば、AtCoder国の数字では\ 0\ の順になっている場合、AtCoder国では\ 9 $ よりも $ 8 $ の方が大きいことになります。また、$ 97 $ よりも $ 72 $ の方が大きいことになります。  
  
 AtCoder国の数字の大小関係といくつかの数が与えられるので、AtCoder国の数字の大小関係で昇順に並び替えてください。  
 なお、私達が普段使用する数字同様、AtCoder国で最も小さい数字は $ 0 $ であることは決まっています。 入力は以下の形式で標準入力から与えられる。

> $ b_0 $ $ b_1 $ ‥‥ $ b_9 $ $ N $ $ a_0 $ $ a_1 $ : : $ a_{N-1} $

- 入力は $ N+2 $ 行ある。
- $ 1 $ 行目には、AtCoder国での $ 1 $ 桁の数字の大小関係が与えられる。 
  - AtCoder国では $ b_0\ であることを表している。 $
  - $ b_0 $ は必ず $ 0 $ である。
  - 重複する数字は存在せず、$ 0 $ から $ 9 $ までの数字が $ 1 $ 度ずつ現れる。
- $ 2 $ 行目には並び替える数の個数を表す整数 $ N(1≦N≦777) $ が与えられる。
- $ 3 $ 行目からの $ N $ 行には、$ j+3 $ 行目に並び替える数を表す整数 $ a_j(1≦a_j≦777,777,777) $ が与えられる。
 
 与えられた数をAtCoder国の数字の大小関係にあわせて昇順に並び替え、標準出力に $ 1 $ 行に $ 1 $ つの数字ずつ出力せよ。  
 なお、最後には改行を出力せよ。 ```

0 8 1 3 5 4 9 7 6 2
10
1
2
3
4
5
6
7
8
9
10
```

 ```

8
1
3
5
4
9
7
6
2
10
```

- AtCoder国ではこの大小関係の場合、$ 0,\ 8,\ 1,\ 3,\ 5,\ 4,\ 9,\ 7,\ 6,\ 2,\ 80,\ 88,\ 81,\ 83,\ ...,\ 86,\ 82,\ 10,\ 18,\ 11,\ ... $ の順に大きくなるので、答えは上記の順になります。
 
```

0 9 8 7 6 5 4 3 2 1
3
13467932
98738462
74392
```

 ```

74392
98738462
13467932
```

- $ 5 $ 桁の数は $ 8 $ 桁の数よりも小さいので、$ 1 $ 番は $ 74392 $ になります。
- $ 98738462 $ と $ 13467932 $ では最上位の $ 9 $ は$ 1 $ より小さいので、$ 98738462 $ が $ 2 $ 番目、$ 13467932 $ が $ 3 $ 番目になります。
 
```

0 1 2 3 4 5 6 7 8 9
4
643
1234
43
909
```

 ```

43
643
909
1234
```

- 私達の普段使用する数と同じ大小関係に昇順に並べます。
 
```

0 7 4 3 9 5 6 2 1 8
2
333
333
```

 ```

333
333
```

 ```

0 2 4 6 8 1 3 5 7 9
1
10
```

 ```

10
```



---

---
title: "[ABC046D] AtCoDeerくんと変なじゃんけん"
layout: "post"
diff: 普及-
pid: AT_arc062_b
tag: ['模拟', '字符串', '贪心']
---

# [ABC046D] AtCoDeerくんと変なじゃんけん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc046/tasks/arc062_b

シカのAtCoDeerくんは友達のTopCoDeerくんとあるゲームをして対戦しています。 このゲームは $ N $ ターンからなります。各ターンではそれぞれのプレイヤーはじゃんけんのグーかパーを出します。ただし、各プレイヤーは次の条件を満たす必要があります。

(※) 各ターンの後で、(今までにパーを出した回数)$ ≦ $(今までにグーを出した回数) を満たす

このゲームでの各プレイヤーの得点は、(勝ったターンの数) $ - $ (負けたターンの数) です。 AtCoDeerくんは特殊能力を持っているので、ゲームが始まる前にTopCoDeerくんの出す $ N $ ターンの手を全て知ることが出来ました。 AtCoDeerくんの各ターンでの手を決めて、AtCoDeerくんの得点を最大化してください。 TopCoDeerくんの出す手の情報は文字列 $ s $ で与えられます。 $ s $ の $ i(1≦i≦N) $ 文字目が `g`のときは $ i $ ターン目でTopCoDeerくんがグーを出すことを、 `p`のときはパーを出すことを表します。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ s $

## 输出格式

AtCoDeerくんの得点の最大値を出力せよ。

## 说明/提示

### 制約

- $ 1≦N≦10^5 $
- $ N=|s| $
- $ s $ の各文字は`g`か`p`
- $ s $ で表される手は、条件(※)を満たしている

### Sample Explanation 1

常に相手とあいこになるように手を出すことで、$ 0 $点を取ることができて、これが最大値です。

### Sample Explanation 2

例えばグー,パー,グー,パー,グー,グー,パー,パー,グー,パー と出すことで、 $ 3 $回勝って$ 1 $回負けているので得点は$ 2 $点になり、これが最大値です。

## 样例 #1

### 输入

```
gpg
```

### 输出

```
0
```

## 样例 #2

### 输入

```
ggppgggpgg
```

### 输出

```
2
```



---

---
title: "[ABC047C] 一次元リバーシ"
layout: "post"
diff: 普及-
pid: AT_arc063_a
tag: ['字符串']
---

# [ABC047C] 一次元リバーシ

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc047/tasks/arc063_a

きつねの次郎と三郎が一次元リバーシで遊んでいます。一次元リバーシでは、盤面には白か黒の石が一列に並んだ状態となっており、列の右端か左端に新たに石を打っていきます。通常のリバーシと同じように、たとえば白の石を打つことで黒の石を挟むと、挟まれた黒の石は白い石に変わります。

ゲームの途中で三郎に急用ができて帰ってしまうことになりました。このとき、盤面の状態は文字列 $ S $ で表されます。石は $ |S| $ (文字列の長さ) 個並んでおり、左から $ i $ ($ 1\ ≦\ i\ ≦\ |S| $) 個目の石の色は、$ S $ の $ i $ 文字目が `B` のとき黒、`W` のとき白です。

次郎は現在の盤面に対して、できるだけ少ない個数の石を新たに打つことで全ての石を同じ色にしようと考えました。最小で何個の石を打てばよいかを求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ S $

## 输出格式

全ての石を同じ色にするために打つ必要のある石の個数の最小値を出力せよ。

## 说明/提示

### 制約

- $ 1\ ≦\ |S|\ ≦\ 10^5 $
- $ S $ に含まれる文字は `B` または `W` のいずれかである

### Sample Explanation 1

たとえば右端に黒い石を打つとすべての白い石を黒い石にすることができます。他にも、左端に白い石を打つことでもすべての石の色を同じにできます。 いずれの場合も $ 1 $ 個の石ですべての石を同じ色にすることができるので、$ 1 $ を出力します。

### Sample Explanation 2

最初から全ての石が同じ色の場合、新たに石を打つ必要はありません。

## 样例 #1

### 输入

```
BBBWW
```

### 输出

```
1
```

## 样例 #2

### 输入

```
WWWWWW
```

### 输出

```
0
```

## 样例 #3

### 输入

```
WBWBWBWBWB
```

### 输出

```
9
```



---

---
title: "あまり"
layout: "post"
diff: 普及-
pid: AT_chokudai_S001_g
tag: ['模拟', '字符串', '数学']
---

# あまり

## 题目描述

有一个长度为n的数列a，你需要把这个数列里的所有数从左到右拼接起来形成一个数，然后把这个数%$1,000,000,007(1e9+7)$并输出。

## 输入格式

第一行：n，代表数的个数。           
第二行：n个数。

## 输出格式

一行，为拼接后的值%$1,000,000,007$的值。

## 说明/提示

$1 ≤ N ≤ 100,000$。

别忘了结尾换行！

## 样例 #1

### 输入

```
5

3 1 5 4 2
```

### 输出

```
31542
```

## 样例 #2

### 输入

```
6

1 2 3 4 5 6
```

### 输出

```
123456
```

## 样例 #3

### 输入

```
7

7 6 5 4 3 2 1
```

### 输出

```
7654321
```

## 样例 #4

### 输入

```
20

19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 12
```

### 输出

```
370453866
```



---

---
title: "Where&#39;s Snuke?"
layout: "post"
diff: 普及-
pid: AT_codefestival_2016_final_a
tag: ['字符串']
---

# Where&#39;s Snuke?

## 题目描述

[problemUrl]: https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_a

縦 $ H $ 行、横 $ W $ 列のマス目があります。

上から $ i $ 行目、左から $ j $ 列目には長さ $ 5 $ の文字列 $ S_{i,j} $ が書かれています。

行には上から順に $ 1 $~$ H $ の番号が、列には左から順に `A`~`Z` の番号がついています。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_codefestival_2016_final_a/d3b854eace34ecfd0d0564d0ea4b3c7c5a522480.png)

この中から `snuke` という文字列を探し、列と行の番号を順に続けて出力してください。

例えば $ 6 $ 行目の $ 8 $ 列目にあった場合は、`H6` のように出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ S_{1,1} $ $ S_{1,2} $ $ ... $ $ S_{1,W} $ $ S_{2,1} $ $ S_{2,2} $ $ ... $ $ S_{2,W} $ $ : $ $ S_{H,1} $ $ S_{H,2} $ $ ... $ $ S_{H,W} $

## 输出格式

`snuke` という文字列が書かれているマスの列と行の番号を続けて出力せよ。

## 说明/提示

### 制約

- $ 1≦H,\ W≦26 $
- $ S_{i,j} $ は小文字アルファベット（`a`-`z`）のみからなる長さ $ 5 $ の文字列である。
- 与えられる文字列のうち、ちょうど $ 1 $ つだけが `snuke` である。

## 样例 #1

### 输入

```
15 10

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snuke snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake

snake snake snake snake snake snake snake snake snake snake
```

### 输出

```
H6
```

## 样例 #2

### 输入

```
1 1

snuke
```

### 输出

```
A1
```



---

---
title: "とても長い文字列"
layout: "post"
diff: 普及-
pid: AT_code_festival_qualA_b
tag: ['字符串']
---

# とても長い文字列

## 题目描述

[problemUrl]: https://atcoder.jp/contests/code-festival-2014-quala/tasks/code_festival_qualA_b

文字列 $ S $ は、文字列 $ A $ を、$ 10^{100} $ 個連結させた文字列です。

文字列 $ S $ の $ B $ 文字目の文字は何かを出力しなさい。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ A $ $ B $

- $ 1 $ 行目には、文字列 $ A\ (1\ ≦\ |A|\ ≦\ 50) $ が与えられる。
- 文字列 $ A $ は、小文字アルファベットのみで構成されていることが保障されている。
- $ 2 $ 行目には、整数 $ B\ (1\ ≦\ B\ ≦\ 1,000,000,000) $ が与えられる。

## 输出格式

文字列 $ S $ の $ B $ 文字目の文字を $ 1 $ 行で出力せよ。出力の末尾には改行をいれること。

## 说明/提示

### 部分点

- $ 1\ ≦\ B\ ≦\ 100,000 $ の全てのテストケースに正解すると、 $ 20 $ 点が与えられる。
- 残りの全てのテストケースに正解すると、さらに $ 80 $ 点が与えられる。

### Sample Explanation 1

文字列 $ S $ は、`abcabcabcabc…` と続く文字列です よって、$ 7 $ 文字目は `a` となります。

### Sample Explanation 2

文字列 $ S $ に含まれる全ての文字は `b` なので、$ 9 $ 文字目も `b` となります。

### Sample Explanation 3

大きな整数が入力されることがあることに注意してください。

## 样例 #1

### 输入

```
abc

7
```

### 输出

```
a
```

## 样例 #2

### 输入

```
bbb

9
```

### 输出

```
b
```

## 样例 #3

### 输入

```
kljhasdfkjahfadfakhsdfaklh

1000000000
```

### 输出

```
h
```



---

---
title: "1→1"
layout: "post"
diff: 普及-
pid: AT_hbpc_1
tag: ['字符串', '搜索', '广度优先搜索 BFS']
---

# 1→1

## 题目描述

$m$表示变化规则的数量，$n$表示要生成$1$的数量。

对于生成规则$a_{i},b_{i}$而言，它表示可以将原字符串中的$a_{i}$个$1$变为$b_{i}$个$1$。例如，$a_{i}=2,b_{i}=3$，表示原字符串中$11$可以变为$111$

现在，原字符串中只有$1$个$1$，要求你使用最少的变化次数将字符串变成$n$个$1$。

## 输入格式

第一行，两个整数$m,n$；

第$2$~$m+1$行，每行两个整数$a_{i},b_{i}$；

## 输出格式

如果能将字符串变成$n$个$1$，输出$($变化次数$+1)$，否则输出$-1$。

## 说明/提示

- $1≤m≤300^{2}$
- $1≤n≤10000$
- $1≤a_{i},b_{i}≤300$
- 当$i≠j$时保证$a_{i}≠a_{j}$且$b_{i}≠b_{j}$


### 样例$1$

规则为：

$1->11$

$111->11111$

那么一个$1$变成$11111$需要经过下面这些步骤：

1->11

11->111

111->1111

变化次数为$3$，故答案为$4$。

### 样例$2$

规则为：

$1->111$

$11111->111$

那么一个$1$不可能变成$111111$，故答案为$-1$。



---

---
title: "Indeedなう！"
layout: "post"
diff: 普及-
pid: AT_indeednow_2015_quala_2
tag: ['字符串', '排序', '概率论']
---

# Indeedなう！

## 题目描述

[problemUrl]: https://atcoder.jp/contests/indeednow-quala/tasks/indeednow_2015_quala_2

あなたには、$ N $ 個の文字列 $ {S_1,S_2,...,S_N} $が与えられます。 それぞれの $ i\ (1≦i≦N) $ について、$ S_i $ が `indeednow` のアナグラムになっているかどうかを判定しなさい。

文字列 $ A $ と $ B $ について、$ A $ に含まれる文字を任意の順番で並び替えて $ B $ にできるとき、$ A $ を $ B $ のアナグラムと呼びます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S_1 $ $ S_2 $ : $ S_N $

- $ 1 $ 行目には、与えられる文字列の数 $ N\ (1≦N≦100) $ が与えられる。
- $ 2 $ 行目から $ N $ 行には、それぞれの文字列が与えられる。そのうち $ i\ (1≦i≦N) $ 行目には、$ S_i $ が与えられる。$ S_i $ の長さは $ 1 $ 以上 $ 100 $ 以下であり、半角小文字アルファベット `a`-`z` のみからなる。

## 输出格式

$ 1 $ 行目から $ N $ 行には、それぞれの文字列に対する判定結果を出力せよ。そのうち $ i\ (1≦i≦N) $ 行目には $ S_i $ が `indeednow` のアナグラムになっているならば `YES` を、そうでないならば `NO` を出力せよ。末尾の改行を忘れないこと。

## 说明/提示

### Sample Explanation 1

たとえば `nowindeed` や `windoneed` に含まれる文字を並び替えると `indeednow` にすることができます。 したがって `nowindeed` や `windoneed` は `indeednow` のアナグラムです。 一方、 `indeedwow` や `a` は、並び替えても `indeednow` にすることはできないため、`indeednow` のアナグラムではありません。

## 样例 #1

### 输入

```
10

nowindeed

indeedwow

windoneed

indeednow

wondeedni

a

indonow

ddeennoiw

indeednoww

indeow
```

### 输出

```
YES

NO

YES

YES

YES

NO

NO

YES

NO

NO
```



---

---
title: "String Sorting"
layout: "post"
diff: 普及-
pid: AT_kupc2012pr_2
tag: ['字符串', '排序']
---

# String Sorting

## 题目描述

设有 $n$ 个正整数（$n \le 100$）长度为 $m$（$m \le 30$），将它们联接成一排，组成一个最大的多位整数。

## 输入格式

第一行，两个正整数 $n, m$。

第二行，$n$ 个长度为 $m$ 的正整数。

## 输出格式

一个数，表示最大的数。



---

---
title: "2015"
layout: "post"
diff: 普及-
pid: AT_nyc2015_1
tag: ['字符串', '进制', '位运算']
---

# 2015

## 题目描述

[problemUrl]: https://atcoder.jp/contests/NYC2015/tasks/nyc2015_1

入力は以下の形式で標準入力から与えられる。

> $ N $

 `Yes` または `No` と出力せよ。 ```

2015
```

 ```

Yes
```

 ```

2016
```

 ```

No
```

## 说明/提示

### Constraints

すぬけ君は、$ 2015 $ を $ 2 $ 進数で表すと `11111011111` となり回文になっていることに気づいた。 整数 $ N $ を (余計な $ 0 $ をつけない) $ 2 $ 進数で表したとき、回文になっているかどうか判定せよ。 ただし、左から呼んでも右から読んでも同じ文字列を回文という。

- - - - - -

- $ 1\ \leq\ N\ \leq\ 10^9 $



---

---
title: "鏡文"
layout: "post"
diff: 普及-
pid: AT_relay_b
tag: ['模拟', '字符串']
---

# 鏡文

## 题目描述

给出由b、d、p、q四种字符组成的字符串$S$。请判断$S$是不是“镜像字符串”。

这里的“镜像字符串”是指对字符串S进行以下操作后，可得到与原字符串相同的字符串。
1. 反转S。（例："bdpq"=>"qpdb"）
2. 改b为d，改d为b，改p为q，改q为p（不要搞错对应关系）

## 输入格式

标准输入，格式如下：

	S

## 输出格式

如果$S$是镜像字符串，输入"Yes"，否则输出"No"。（不要输出引号）
# 输入输出样例（略）

## 说明/提示

## 条件：
- $1≤|S|≤10^5$（$|S|$表示$S$的长度）
- $S$由且仅由b、d、p、q四种字符构成

感谢@std_cpp 提供的翻译

## 样例 #1

### 输入

```
pdbq
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
ppqb
```

### 输出

```
No
```



---

---
title: "分類たん"
layout: "post"
diff: 普及-
pid: AT_tenka1_2012_qualA_2
tag: ['字符串']
---

# 分類たん

## 题目描述

[problemUrl]: https://atcoder.jp/contests/tenka1-2012-qualA/tasks/tenka1_2012_qualA_2

 分類たんは、スペースをカンマ区切りにするのが大好き。  
 でも、スペースが続いたときは、カンマ $ 1 $ つで書きたい。

 文字列が与えられるので、与えられた文字列のスペースをカンマ区切りにした文字列を出力してください。

 入力は以下の形式で標準入力から与えられる。 > $ c_1c_2…c_N $

- 入力として文字列が $ 1 $ 行で与えられる。
- 入力の文字列長 $ N $ は、 $ 1\ \leq\ N\ \leq\ 2000 $ を満たす。
- $ i $ 文字目の文字 $ c_i $ は大文字のアルファベット (`A`, $ … $, `Z`) 、カンマ (`,`) 、スペース(` `) のいずれかである。
- 文字列の最初の文字 $ c_1 $ と最後の文字 $ c_N $ はスペースではない。
 
 入力として与えられた文字列のスペースをカンマ区切りにした文字列を標準出力に $ 1 $ 行で出力せよ。  
 ただし、複数の連続したスペースは $ 1 $ つのカンマにする。  
 なお、行の終端には改行が必要である。 ```


## 样例 #1

### 输入

```
X Y Z
```

### 输出

```
X,Y,Z
```

## 样例 #2

### 输入

```
QWERTY
```

### 输出

```
QWERTY
```

## 样例 #3

### 输入

```
A  B, C
```

### 输出

```
A,B,,C
```



---

---
title: "天下一序数"
layout: "post"
diff: 普及-
pid: AT_tenka1_2014_qualA_a
tag: ['字符串', '递推', '排序']
---

# 天下一序数

## 题目描述

这是一道提交答案题（虽然在洛谷上，你只能提交程序源代码）。

请将1至1000这1000个数字按字典序升序排列。例如：将1,2,11,12,21按照字典序升序排序后的结果是：1,11,12,2,21。

## 输入格式

本题没有输入。

## 输出格式

输出将1至1000这1000个数按字典序升序排列后的结果，每行输出一个数字。



---

---
title: "雨上がり"
layout: "post"
diff: 普及-
pid: AT_wupc_02
tag: ['模拟', '字符串', '动态规划 DP', '概率论']
---

# 雨上がり

## 题目描述

[problemUrl]: https://atcoder.jp/contests/wupc2nd/tasks/wupc_02

 雨が上がった．そろそろ大学に行こう． 僕の家から大学までは一本道の道路で結ばれている．道路は区間に分けることができ，ここでは，道路を一行の文字列で表すことにする．各文字が1つの区間に相当し，1文字目が家の前の区間，最後の文字が大学の前の区間を表している．  
  
 ここで，各文字の意味は次のとおりである．

```

 . : 普通の区間
 X : 水たまりのある区間
```

 僕は家の前の区間からスタートし大学へ向かう．僕は現在位置から$ 1 $つ，$ 2 $つ，もしくは$ 3 $つ先の区間(大学のある方向)へ進むことができる．もし，移動した先の区間に水たまりがある場合，僕は水たまりを踏むはめになる．買ったばかりの靴を汚したくないので，なるだけ水たまりを避けたい．また，大学の前の道路を超えて移動するようなことはできない．  
  
 家の前の道路から大学の前の道路まで適切な進み方で向かうとき，最低限踏まなければならない水たまりの数を求めてほしい．  
 入力は以下の形式で標準入力から与えられる． > $ N $ $ S $

- $ 1 $ 行目に区間の数を表す $ N $($ 3\ ≦\ N\ ≦\ 100 $) が与えられる．
- $ 2 $ 行目には，$ N $ 文字の文字列 $ S $ が与えられる．これらは道路の区間のデータである．
- $ S $ に出現する文字は '.', 'X' のいずれかであり，意味は上に記した通りである．
- $ S $ の最初と最後の文字は必ず '.' である．
 
 最低限踏まなければならない水たまりの数を標準出力に $ 1 $ 行で出力せよ．  
 なお、最後には改行を出力せよ． ```
<pre class="prettyprint linenums">
5
.XXX.
```

 ```
<pre class="prettyprint linenums">
1
```

 ```
<pre class="prettyprint linenums">
10
.X.XXXXXX.
```

 ```
<pre class="prettyprint linenums">
2
```

 ```
<pre class="prettyprint linenums">
7
.......
```

 ```
<pre class="prettyprint linenums">
0
```



---


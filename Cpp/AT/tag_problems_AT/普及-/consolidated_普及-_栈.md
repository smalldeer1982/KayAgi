---
title: "[ABC283D] Scope"
layout: "post"
diff: 普及-
pid: AT_abc283_d
tag: ['模拟', '栈']
---

# [ABC283D] Scope

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc283/tasks/abc283_d

英小文字、`(`、`)` からなる文字列のうち、以下の手順によって空文字列になるものを**良い文字列**と呼びます:

- まず、英小文字をすべて削除する。
- 次に、連続する `()` が存在する限り、それを削除する。
 
例えば、`((a)ba)` は英小文字をすべて削除すると `(())` となり、$ 2 $ 文字目と $ 3 $ 文字目に連続する `()` を削除すると `()` となり、最終的に空文字列にすることができるので良い文字列です。

良い文字列 $ S $ が与えられます。 $ S $ の $ i $ 文字目を $ S_i $ で表します。

各英小文字 `a` , `b` , $ \ldots $ , `z` に対して、その文字が書かれたボールが $ 1 $ つあります。 また、空の箱があります。

高橋君は $ i\ =\ 1,2, $ $ \ldots $ $ ,|S| $ に対してこの順に気を失わない限り操作を行います。

- $ S_i $ が英小文字ならば、その英小文字が書かれたボールを箱に入れる。ただし、そのボールがすでに箱に入っている場合、高橋君は気を失う。
- $ S_i $ が `(` ならば、何もしない。
- $ S_i $ が `)` ならば、$ i $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ i $ 番目までの文字からなる文字列が良い文字列となる最大の整数 $ j $ を取る。（このような整数 $ j $ は必ず存在することが証明できる。）$ j $ 番目から $ i $ 番目までの操作で箱に入れたボールをすべて、箱から取り出す。
 
高橋君が気を失わずに一連の操作を完了させられるか判定してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ S $

## 输出格式

高橋君が気を失わずに一連の操作を完了させられる場合は `Yes` を、そうでない場合は `No` を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 3\ \times\ 10^5 $
- $ S $ は良い文字列
 
### Sample Explanation 1

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は何もしません。 $ i\ =\ 3 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 4 $ のとき、$ 4 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 4 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 2 $ であるため、高橋君は `a` の書かれたボールを箱から取り出します。 $ i\ =\ 5 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 6 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 7 $ のとき、$ 7 $ 未満の整数 $ j $ であって、$ S $ の $ j $ 番目から $ 7 $ 番目までの文字からなる文字列が良い文字列となる最大の整数は $ 1 $ であるため、高橋君は `a` の書かれたボールと `b` の書かれたボールを箱から取り出します。 したがってこの場合の答えは `Yes` となります。

### Sample Explanation 2

$ i\ =\ 1 $ のとき、高橋君は何もしません。 $ i\ =\ 2 $ のとき、高橋君は `a` の書かれたボールを箱の中に入れます。 $ i\ =\ 3 $ のとき、高橋君は何もしません。 $ i\ =\ 4 $ のとき、高橋君は `b` の書かれたボールを箱の中に入れます。 $ i\ =\ 5 $ のとき、`a` の書かれたボールはすでに箱に入っているため、高橋君は気を失い、これ以降の操作は行われません。 したがってこの場合の答えは `No` となります。

## 样例 #1

### 输入

```
((a)ba)
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
(a(ba))
```

### 输出

```
No
```

## 样例 #3

### 输入

```
(((())))
```

### 输出

```
Yes
```

## 样例 #4

### 输入

```
abca
```

### 输出

```
No
```



---

---
title: "[ABC328D] Take ABC"
layout: "post"
diff: 普及-
pid: AT_abc328_d
tag: ['栈']
---

# [ABC328D] Take ABC

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc328/tasks/abc328_d

`A` , `B` , `C` の $ 3 $ 種類の文字のみからなる文字列 $ S $ が与えられます。

$ S $ が連続な部分文字列として文字列 `ABC` を含む限り、下記の操作を繰り返します。

> $ S $ に連続な部分文字列として含まれる文字列 `ABC` のうち、$ S $ の中で最も左にあるものを、$ S $ から削除する。

上記の手順を行った後の、最終的な $ S $ を出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ S $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ S $ は `A` , `B` , `C` のみからなる長さ $ 1 $ 以上 $ 2\times\ 10^5 $ 以下の文字列
 
### Sample Explanation 1

与えられた文字列 $ S\ = $ `BAABCBCCABCAC` に対して、下記の通りに操作が行われます。 - $ 1 $ 回目の操作で、$ S\ = $ `BAABCBCCABCAC` の $ 3 $ 文字目から $ 5 $ 文字目の `ABC` が削除され、その結果 $ S\ = $ `BABCCABCAC` となります。 - $ 2 $ 回目の操作で、$ S\ = $ `BABCCABCAC` の $ 2 $ 文字目から $ 4 $ 文字目の `ABC` が削除され、その結果 $ S\ = $ `BCABCAC` となります。 - $ 3 $ 回目の操作で、$ S\ = $ `BCABCAC` の $ 3 $ 文字目から $ 5 $ 文字目の `ABC` が削除され、その結果 $ S\ = $ `BCAC` となります。 よって、最終的な $ S $ は `BCAC` です。

### Sample Explanation 2

この入力例では、最終的な $ S $ は空文字列です。

## 样例 #1

### 输入

```
BAABCBCCABCAC
```

### 输出

```
BCAC
```

## 样例 #2

### 输入

```
ABCABC
```

### 输出

```

```

## 样例 #3

### 输入

```
AAABCABCABCAABCABCBBBAABCBCCCAAABCBCBCC
```

### 输出

```
AAABBBCCC
```



---

---
title: "[ABC344B] Delimiter"
layout: "post"
diff: 普及-
pid: AT_abc344_b
tag: ['栈']
---

# [ABC344B] Delimiter

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc344/tasks/abc344_b

$ N $ 個の整数 $ A_1,A_2,\dots,A_N $ が、 $ 1 $ 行に $ 1 $ つずつ、 $ N $ 行にわたって与えられます。但し、 **$ N $ は入力では与えられません。**  
 さらに、以下が保証されます。

- $ A_i\ \neq\ 0 $ ( $ 1\ \le\ i\ \le\ N-1 $ )
- $ A_N\ =\ 0 $
 
$ A_N,\ A_{N-1},\dots,A_1 $ をこの順に出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ A_1 $ $ A_2 $ $ \vdots $ $ A_N $

## 输出格式

$ A_N,\ A_{N-1},\dots,A_1 $ をこの順に、改行区切りで整数として出力せよ。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 100 $
- $ 1\ \le\ A_i\ \le\ 10^9 $ ( $ 1\ \le\ i\ \le\ N-1 $ )
- $ A_N\ =\ 0 $
 
### Sample Explanation 1

繰り返しになりますが、 $ N $ は入力では与えられないことに注意してください。 この入力においては $ N=4 $ で、 $ A=(3,2,1,0) $ です。

### Sample Explanation 2

$ A=(0) $ です。

## 样例 #1

### 输入

```
3

2

1

0
```

### 输出

```
0

1

2

3
```

## 样例 #2

### 输入

```
0
```

### 输出

```
0
```

## 样例 #3

### 输入

```
123

456

789

987

654

321

0
```

### 输出

```
0

321

654

987

789

456

123
```



---

---
title: "[ABC351C] Merge the balls"
layout: "post"
diff: 普及-
pid: AT_abc351_c
tag: ['栈']
---

# [ABC351C] Merge the balls

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_c

空の列と、$ N $ 個のボールがあります。$ i $ 個目 $ (1\leq\ i\leq\ N) $ のボールの大きさは $ 2^{A_i} $ です。

これから $ N $ 回の操作を行います。  
 $ i $ 回目の操作では、$ i $ 個目のボールを列の一番右に付け加えた後、次の手順を繰り返します。

1. 列にあるボールが $ 1 $ つ以下ならば操作を終了する。
2. 列にあるボールのうち右から $ 1 $ 番目のものと $ 2 $ 番目のものの大きさが **異なる** ならば操作を終了する。
3. 列にあるボールのうち右から $ 1 $ 番目のものと $ 2 $ 番目のものの大きさが **等しい** ならば、$ 2 $ つのボールを取り除き、「取り除かれた $ 2 $ つのボールの大きさの和」の大きさのボール $ 1 $ つを列の一番右に付け加える。その後、1. に戻り、手順を繰り返す。
 
$ N $ 回の操作の後で、列にあるボールの数を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ A_1 $ $ A_2 $ $ \ldots $ $ A_N $

## 输出格式

$ N $ 回の操作の後で、列にあるボールの数を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\leq\ A_i\leq\ 10^9 $
- 入力はすべて整数
 
### Sample Explanation 1

操作は次のように行われます。 - $ 1 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^2 $ です。 - $ 2 $ 回目の操作の後、列にあるボールは $ 2 $ つで、大きさは順に $ 2^2 $, $ 2^1 $ です。 - $ 3 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^3 $ です。これは次のようにして得ることができます。 - $ 3 $ 回目の操作において $ 3 $ 個目のボールを付け加えたとき、列にあるボールの大きさは順に $ 2^2,2^1,2^1 $ となります。 - 右から $ 1 $ 番目のボールと $ 2 $ 番目のボールの大きさが等しいため、これらのボールが取り除かれ、大きさが $ 2^1+2^1=2^2 $ のボールが追加されます。このとき、列にあるボールの大きさは $ 2^2 $, $ 2^2 $ となります。 - さらに、再び右から $ 1 $ 番目のボールと $ 2 $ 番目のボールの大きさが等しいため、これらのボールが取り除かれ、大きさが $ 2^2+2^2=2^3 $ のボールが追加され、列にあるボールの大きさは $ 2^3 $ となります。 - $ 4 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^4 $ です。 - $ 5 $ 回目の操作の後、列にあるボールは $ 2 $ つで、大きさは順に $ 2^4 $, $ 2^5 $ です。 - $ 6 $ 回目の操作の後、列にあるボールは $ 3 $ つで、大きさは順に $ 2^4 $, $ 2^5 $, $ 2^3 $ です。 - $ 7 $ 回目の操作の後、列にあるボールは $ 3 $ つで、大きさは順に $ 2^4 $, $ 2^5 $, $ 2^4 $ です。 よって、最後に列にあるボールの数である $ 3 $ を出力します。

### Sample Explanation 2

操作は次のように行われます。 - $ 1 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^0 $ です。 - $ 2 $ 回目の操作の後、列にあるボールは $ 1 $ つで、大きさは $ 2^1 $ です。 - $ 3 $ 回目の操作の後、列にあるボールは $ 2 $ つで、大きさは順に $ 2^1 $, $ 2^0 $ です。 - $ 4 $ 回目の操作の後、列にあるボールは $ 3 $ つで、大きさは順に $ 2^1 $, $ 2^0 $, $ 2^1 $ です。 - $ 5 $ 回目の操作の後、列にあるボールは $ 4 $ つで、大きさは順に $ 2^1 $, $ 2^0 $, $ 2^1 $, $ 2^2 $ です。 よって、最後に列にあるボールの数である $ 4 $ を出力します。

## 样例 #1

### 输入

```
7

2 1 1 3 5 3 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5

0 0 0 1 2
```

### 输出

```
4
```



---

---
title: "[ABC394D] Colorful Bracket Sequence"
layout: "post"
diff: 普及-
pid: AT_abc394_d
tag: ['模拟', '栈']
---

# [ABC394D] Colorful Bracket Sequence

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc394/tasks/abc394_d

给定一个由 6 种字符 `(`, `)`, `[`, `]`, `<`, `>` 组成的字符串 $S$。

当字符串 $T$ 满足以下条件时，称其为卡芙乐括号列：

> 通过执行以下操作若干次（包括零次）可以将 $T$ 变为空字符串：
> 
> - 若 $T$ 中存在连续的 `()`, `[]`, `<>` 子字符串，选择其中任意一个删除。
> - 若删除的子字符串位于 $T$ 的开头或结尾，则将剩余部分作为新的 $T$。
> - 否则，将删除位置前后的字符串连接为新的 $T$。

请判断 $S$ 是否为卡芙乐括号列。

## 输入格式

输入通过标准输入按以下格式给出：

> $S$

## 输出格式

若 $S$ 是卡芙乐括号列则输出 `Yes`，否则输出 `No`。

## 说明/提示

### 约束条件

- $S$ 是长度介于 $1$ 到 $2 \times 10^5$ 之间的字符串
- $S$ 仅由 `(`, `)`, `[`, `]`, `<`, `>` 组成

### 样例解释 1

对于 $S=$ `([])<>()`，可通过以下操作变为空字符串：
- 删除第 2-3 字符 `[]`，得到新字符串 `()<>()`。
- 删除第 1-2 字符 `()`，得到新字符串 `<>()`。
- 删除第 1-2 字符 `<>`，得到新字符串 `()`。
- 删除 `()` 后字符串变为空。  
因此输出 `Yes`。

### 样例解释 2

$S=$ `([<)]>` 不包含任何 `()`, `[]`, `<>` 子字符串，无法执行任何操作，因此输出 `No`。

### 样例解释 3

无法通过操作将 $S=$ `><><` 变为空字符串，因此输出 `No`。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
([])<>()
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
([<)]>
```

### 输出

```
No
```

## 样例 #3

### 输入

```
())
```

### 输出

```
No
```



---

---
title: "[ABC396B] Card Pile"
layout: "post"
diff: 普及-
pid: AT_abc396_b
tag: ['模拟', '栈']
---

# [ABC396B] Card Pile

## 题目描述

存在一个初始由 $100$ 张写有整数 $0$ 的卡片堆叠而成的卡堆。

请处理 $Q$ 个查询。每个查询为以下两种类型之一：

- 类型 $1$：将一张写有整数 $x$ 的卡片放到卡堆的最上方。
- 类型 $2$：移除卡堆最上方的卡片，并输出被移除卡片上的整数。在本问题的约束下，保证此时卡堆中必定存在卡片。

## 输入格式

输入通过标准输入给出，格式如下：

> $Q$  
> $\text{query}_1$  
> $\text{query}_2$  
> $\vdots$  
> $\text{query}_Q$

在第 $i$ 个查询 $\text{query}_i$ 中，首先给出查询类型 $c_i$（取值为 $1$ 或 $2$）。当 $c_i = 1$ 时，还会额外给出一个整数 $x$。

即，每个查询为以下两种格式之一：

> $1$ $x$

> $2$

## 输出格式

设满足 $c_i = 2$ 的查询共有 $q$ 次，请输出 $q$ 行。  
第 $j$ 行（$1 \leq j \leq q$）输出第 $j$ 次此类查询对应的结果。

## 说明/提示

### 约束条件

- $1 \leq Q \leq 100$
- $1 \leq x \leq 100$
- 保证至少存在一个类型 $2$ 的查询。
- 输入中的所有值均为整数

### 样例解释 1

各查询处理后的卡堆状态如下（按顺序）：
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $0$，因此输出 $0$。
- 卡堆变为 $99$ 张写有 $0$ 的卡片。
- 将写有 $4$ 的卡片放到卡堆最上方。
- 卡堆变为：最上方 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 将写有 $3$ 的卡片放到卡堆最上方。
- 卡堆变为：最上方 $1$ 张写有 $3$ 的卡片，中间 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $3$，因此输出 $3$。
- 卡堆变为：最上方 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $4$，因此输出 $4$。
- 卡堆变为 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $0$，因此输出 $0$。
- 卡堆变为 $98$ 张写有 $0$ 的卡片。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6

2

1 4

1 3

2

2

2
```

### 输出

```
0

3

4

0
```

## 样例 #2

### 输入

```
5

2

2

2

2

2
```

### 输出

```
0

0

0

0

0
```



---

---
title: "図書館 2 (Library 2)"
layout: "post"
diff: 普及-
pid: AT_joi2022_yo2_a
tag: ['栈']
---

# 図書館 2 (Library 2)

## 题目描述

[problemUrl]: https://atcoder.jp/contests/joi2022yo2/tasks/joi2022_yo2_a

読書好きのビ太郎は図書館で本を借りて読むことにした．ビ太郎の家は狭いため，床には本 $ 1 $ 冊分の広さのスペースしかない．ただし高さは十分にあるため，ビ太郎はこのスペースに本を積んで管理することにした．

ビ太郎はこれから $ Q $ 回の行動を取る．$ i $ ($ 1\ \leqq\ i\ \leqq\ Q $) 回目の行動は文字列 $ S_i $ で表される．$ S_i $ は 英小文字からなる文字列か `READ` のいずれかであり，その意味は次の通りである．

- 英小文字からなる文字列の場合，ビ太郎は書名が $ S_i $ である本を図書館から借り，スペースの一番上に積む．
- `READ` の場合，ビ太郎はスペースの一番上に積まれている本を読み，図書館に返却する．

あなたはビ太郎がどの本をどのような順番で読んだのかを調べたい．

$ Q $ 回の行動の内容が与えられたとき，ビ太郎が読んだ本の書名を読んだ順に出力するプログラムを作成せよ．

## 输入格式

入力は以下の形式で標準入力から与えられる．

> $ Q $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_Q $

## 输出格式

標準出力に，$ S_i $ が `READ` である行動のそれぞれに対して，ビ太郎が読んだ本の書名を順に改行区切りで出力せよ．

## 说明/提示

### 制約

- $ 2\ \leqq\ Q\ \leqq\ 200\,000 $．
- $ Q $ は整数である．
- $ S_i $ は長さ $ 1 $ 以上 $ 10 $ 以下の文字列である ($ 1\ \leqq\ i\ \leqq\ Q $)．
- $ S_i $ は英小文字からなる文字列または `READ` である ($ 1\ \leqq\ i\ \leqq\ Q $)．
- $ S_i $ が `READ` であるような $ i $ ($ 1\ \leqq\ i\ \leqq\ Q $) は $ 1 $ つ以上存在する．
- $ S_i $ が `READ` のとき，必ずスペースに $ 1 $ 冊以上の本が存在する ($ 1\ \leqq\ i\ \leqq\ Q $) ．

### 小課題

1. ($ 40 $ 点) $ Q\ \leqq\ 2\,000 $．
2. ($ 60 $ 点) 追加の制約はない．

### 採点に関する注意

すべての提出はジャッジシステム上で採点される．

提出されたソースコードは，小課題に対応するすべての採点用入力データについて正しい結果を返したとき，その小課題について正解と認められる．

各提出の得点は，提出されたソースコードについて正解と認められた小課題の得点の合計である．

この課題の得点は，**この課題に対するすべての提出の得点の最大値**である．

現在の得点は「提出結果」タブの「自分の得点状況」から確認できる．

### Sample Explanation 1

この入力例ではビ太郎は以下のように行動する． 1. 書名が `joi` である本をスペースに積む．このとき，スペースに積まれている本の書名は `joi` となる． 2. 書名が `joig` である本をスペースに積む．このとき，スペースに積まれている本の書名は上から順に `joig` ，`joi` となる． 3. 書名が `ioi` である本をスペースに積む．このとき，スペースに積まれている本の書名は上から順に `ioi` ，`joig` ，`joi` となる． 4. 書名が `ioi` である本を読んで返却する．このとき，スペースに積まれている本の書名は上から順に `joig` ，`joi` となる． 5. 書名が `egoi` である本をスペースに積む．このとき，スペースに積まれている本の書名は上から順に `egoi` ，`joig` ，`joi` となる． 6. 書名が `egoi` である本を読んで返却する．このとき，スペースに積まれている本の書名は上から順に `joig` ，`joi` となる． 7. 書名が `joig` である本を読んで返却する．このとき，スペースに積まれている本の書名は `joi` となる． よってビ太郎が読んだ本の書名 `ioi` ，`egoi` ，`joig` を順に改行区切りで出力する． この入力例はすべての小課題の制約を満たす．

### Sample Explanation 2

この入力例はすべての小課題の制約を満たす．

## 样例 #1

### 输入

```
7

joi

joig

ioi

READ

egoi

READ

READ
```

### 输出

```
ioi

egoi

joig
```

## 样例 #2

### 输入

```
20

one

READ

two

three

four

five

six

seven

READ

eight

nine

READ

ten

eleven

READ

READ

twelve

READ

READ

READ
```

### 输出

```
one

seven

nine

eleven

ten

twelve

eight

six
```



---


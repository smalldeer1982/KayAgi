---
title: "[ABC333D] Erase Leaves"
layout: "post"
diff: 普及-
pid: AT_abc333_d
tag: ['树形数据结构', '深度优先搜索 DFS']
---

# [ABC333D] Erase Leaves

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc333/tasks/abc333_d

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる木が与えられます。 $ i $ 番目 $ (1\leq\ i\lt\ N) $ の辺は頂点 $ u\ _\ i $ と $ v\ _\ i $ を結んでいます。

次の操作を好きな回数繰り返すことを考えます。

- 葉である頂点 $ v $ を $ 1 $ つ選び、頂点 $ v $ およびそれに接続する辺をすべて削除する。
 
頂点 $ 1 $ を削除するまでに最小で操作を何回行う必要があるか求めてください。

 木とは？ 木とは、無向グラフのうち連結であって閉路がないものです。 詳しくはこちらをご覧ください: [Wikipedia「木 (数学)」](https://ja.wikipedia.org/wiki/%E6%9C%A8_(%E6%95%B0%E5%AD%A6))  葉とは？ 木の葉とは、木の頂点のうち次数がたかだか $ 1 $ であるものです。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ u\ _\ 1 $ $ v\ _\ 1 $ $ u\ _\ 2 $ $ v\ _\ 2 $ $ \vdots $ $ u\ _\ {N-1} $ $ v\ _\ {N-1} $

## 输出格式

答えを $ 1 $ 行で出力せよ。

## 说明/提示

### 制約

- $ 2\leq\ N\leq3\times10^5 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\lt\ N) $
- 与えられるグラフは木
- 入力はすべて整数
 
### Sample Explanation 1

与えられるグラフは次のようになります。 !\[\](https://img.atcoder.jp/abc333/6089239ee0c331bec4cd4472c032d197.png) たとえば、頂点 $ 9,8,7,6,1 $ の順に選んで操作を行うことで、$ 5 $ 回の操作で頂点 $ 1 $ を削除することができます。 !\[\](https://img.atcoder.jp/abc333/7dba9a660bfabdd403fe6882dac4e8ab.png) $ 4 $ 回以下の操作では頂点 $ 1 $ を削除することはできないため、$ 5 $ を出力してください。

### Sample Explanation 2

与えられたグラフにおいて、頂点 $ 1 $ は葉です。 よって、$ 1 $ 回目の操作で頂点 $ 1 $ を選んで削除することができます。

## 样例 #1

### 输入

```
9

1 2

2 3

2 4

2 5

1 6

6 7

7 8

7 9
```

### 输出

```
5
```

## 样例 #2

### 输入

```
6

1 2

2 3

2 4

3 5

3 6
```

### 输出

```
1
```

## 样例 #3

### 输入

```
24

3 6

7 17

7 20

7 11

14 18

17 21

6 19

5 22

9 24

11 14

6 23

8 17

9 12

4 17

2 15

1 17

3 9

10 16

7 13

2 16

1 16

5 7

1 3
```

### 输出

```
12
```



---

---
title: "[ABC356C] Keys"
layout: "post"
diff: 普及-
pid: AT_abc356_c
tag: ['深度优先搜索 DFS']
---

# [ABC356C] Keys

## 题目描述

你有 $N$ 个编号为 $1, 2, \dots, N$ 的密钥。  
其中一些是真钥匙，其他都是假钥匙。

有一扇 X 门，你可以插入任意数量的钥匙。只有插入至少 $K$ 把真钥匙，X 门才会打开。

你已经对这些钥匙进行了 $M$ 次测试。第 $i$ 次测试过程如下：

- 您将 $C_i$ 把 $A_{i,1}, A_{i,2}, \dots, A_{i,C_i}$ 把钥匙插入了 X 门。
- 测试结果用一个英文字母 $R_i$ 表示。
    - $R_i =$ o "表示在第 $i$ 次测试中，X 门打开了。
    - $R_i =$ x "表示在第 $i$ 次测试中，X 门没有打开。

有 $2^N$ 种可能的钥匙组合，其中哪些是真钥匙，哪些是假钥匙。在这些组合中，找出与任何测试结果都不矛盾的组合数。  
给定的测试结果有可能是错误的，没有任何组合满足条件。在这种情况下，报告 $0$ 。

## 输入格式

#### 输入

输入内容由标准输入法提供，格式如下

>$N$ $M$ $K$
>
>$C_1$ $A_{1,1}$ $A_{1,2}$ $\dots$ 
>
>$A_{1,C_1}$ $R_1$
>
>$C_2$ $A_{2,1}$ $A_{2,2}$ $\dots$ 
>
>$A_{2,C_2}$ $R_2$
>
>$\vdots$
>
>$C_M$ $A_{M,1}$ $A_{M,2}$ $\dots$ 
>
>$A_{M,C_M}$ $R_M$

## 输出格式

将答案输出为整数。

## 说明/提示

#### 限制因素

- $N$ 、 $M$ 、 $K$ 、 $C_i$ 和 $A_{i,j}$ 为整数。
- $1 \le K \le N \le 15$
- $1 \le M \le 100$
- $1 \le C_i \le N$
- $1 \le A_{i,j} \le N$
- $A_{i,j} \neq A_{i,k}$ 如果 $j \neq k$ .
- $R_i$ 是 `o` 或 `x`。

#### 样例 $1$ 说明

在此输入中，有三个键，进行了两次测试。  
打开 X 门需要两把正确的钥匙。

- 在第一次测试中，使用了钥匙 $1, 2, 3$ ，X 门打开了。
- 在第二次测试中，使用了钥匙 $2, 3$ ，X 门没有打开。

有两种组合，哪把钥匙是真钥匙，哪把钥匙是假钥匙，测试结果都没有矛盾：

- 钥匙 $1$ 是真的，钥匙 $2$ 是假的，钥匙 $3$ 是真的。
- 密钥 $1$ 是真实的，密钥 $2$ 是真实的，密钥 $3$ 是假的。

#### 样例 $2$ 说明

如问题陈述所述，答案可能是 $0$ 。

## 样例 #1

### 输入

```
3 2 2

3 1 2 3 o

2 2 3 x
```

### 输出

```
2
```

## 样例 #2

### 输入

```
4 5 3

3 1 2 3 o

3 2 3 4 o

3 3 4 1 o

3 4 1 2 o

4 1 2 3 4 x
```

### 输出

```
0
```

## 样例 #3

### 输入

```
11 4 9

10 1 2 3 4 5 6 7 8 9 10 o

11 1 2 3 4 5 6 7 8 9 10 11 o

10 11 10 9 8 7 6 5 4 3 2 x

10 11 9 1 4 3 7 5 6 2 10 x
```

### 输出

```
8
```



---

---
title: "[ABC358C] Popcorn"
layout: "post"
diff: 普及-
pid: AT_abc358_c
tag: ['深度优先搜索 DFS']
---

# [ABC358C] Popcorn

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc358/tasks/abc358_c

AtCoder Land には $ 1 $ から $ N $ までの番号が付けられた $ N $ 個のポップコーン売り場があります。 売られているポップコーンの味には味 $ 1,2,\dots,M $ の $ M $ 種類がありますが、すべての売り場ですべての味のポップコーンを売っているわけではありません。

高橋君は、それぞれのポップコーン売り場でどの味のポップコーンを売っているかの情報を入手しました。 この情報は $ N $ 個の長さ $ M $ の文字列 $ S_1,S_2,\dots,S_N $ によって表され、$ S_i $ の $ j $ 文字目が `o` であるとき売り場 $ i $ が味 $ j $ のポップコーンを売っていることを、 `x` であるとき売っていないことを示します。 どの売り場も最低 $ 1 $ 種類の味のポップコーンを売っており、どの味のポップコーンも最低 $ 1 $ つの売り場で売られています。

高橋君は全種類のポップコーンを食べたがっていますが、あまり何度も移動はしたくありません。 高橋君がすべての味のポップコーンを購入するためには最低何個の売り場を訪れる必要があるか求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_N $

## 输出格式

高橋君がすべての味のポップコーンを購入するために訪れる必要がある売り場の個数の最小値を出力せよ。

## 说明/提示

### 制約

- $ N,M $ は整数
- $ 1\leq\ N,M\ \leq\ 10 $
- $ S_i $ は `o` および `x` からなる長さ $ M $ の文字列
- すべての $ i\ (1\leq\ i\leq\ N) $ について、$ S_i $ の中には `o` が $ 1 $ つ以上存在する
- すべての $ j\ (1\leq\ j\leq\ M) $ について、$ S_i $ の $ j $ 文字目が `o` であるような $ i $ が $ 1 $ つ以上存在する
 
### Sample Explanation 1

$ 1 $ つめの売り場と $ 3 $ つめの売り場を訪れることで、すべての味のポップコーンを購入することができます。 $ 1 $ つの売り場ですべての味のポップコーンを購入することはできないので、答えは $ 2 $ です。

## 样例 #1

### 输入

```
3 5

oooxx

xooox

xxooo
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3 2

oo

ox

xo
```

### 输出

```
1
```

## 样例 #3

### 输入

```
8 6

xxoxxo

xxoxxx

xoxxxx

xxxoxx

xxoooo

xxxxox

xoxxox

oxoxxo
```

### 输出

```
3
```



---

---
title: "[ABC367C] Enumerate Sequences"
layout: "post"
diff: 普及-
pid: AT_abc367_c
tag: ['深度优先搜索 DFS']
---

# [ABC367C] Enumerate Sequences

## 题目描述

给定长度为 $n$ 的正整数序列 $(r_1, \ldots, r_n)$ 和正整数 $k$。

以字典序从小到大的顺序输出所有满足 $1 \le a_i \le r_i$ 且 $a_1 + \cdots + a_n$ 是 $k$ 的倍数的长度为 $n$ 的整数序列 $(a_1, \ldots, a_n)$。

数据范围：$n \le 8$，$1 \le r_i \le 5$，$2 \le k \le 10$。

## 样例 #1

### 输入

```
3 2

2 1 3
```

### 输出

```
1 1 2

2 1 1

2 1 3
```

## 样例 #2

### 输入

```
1 2

1
```

### 输出

```

```

## 样例 #3

### 输入

```
5 5

2 3 2 3 2
```

### 输出

```
1 1 1 1 1

1 2 2 3 2

1 3 1 3 2

1 3 2 2 2

1 3 2 3 1

2 1 2 3 2

2 2 1 3 2

2 2 2 2 2

2 2 2 3 1

2 3 1 2 2

2 3 1 3 1

2 3 2 1 2

2 3 2 2 1
```



---

---
title: "[ABC371C] Make Isomorphic"
layout: "post"
diff: 普及-
pid: AT_abc371_c
tag: ['搜索', '深度优先搜索 DFS']
---

# [ABC371C] Make Isomorphic

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc371/tasks/abc371_c

頂点 $ 1, $ 頂点 $ 2,\ldots, $ 頂点 $ N $ の $ N $ 個の頂点からなる単純無向グラフ $ G,H $ が与えられます。 $ G $ には $ M\ _\ G $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ G) $ の辺は頂点 $ u\ _\ i $ と頂点 $ v\ _\ i $ を結んでいます。 $ H $ には $ M\ _\ H $ 本の辺があり、$ i $ 本目 $ (1\leq\ i\leq\ M\ _\ H) $ の辺は頂点 $ a\ _\ i $ と頂点 $ b\ _\ i $ を結んでいます。

あなたは、グラフ $ H $ に対して次の操作を $ 0 $ 回以上の好きな回数繰り返すことができます。

- $ 1\leq\ i\lt\ j\leq\ N $ を満たす整数の組 $ (i,j) $ をひとつ選ぶ。$ A\ _\ {i,j} $ 円を支払って、頂点 $ i $ と頂点 $ j $ を結ぶ辺がなければ追加し、あれば取り除く。

$ G $ と $ H $ を同型にするために少なくとも何円支払う必要があるか求めてください。

単純無向グラフとは？ **単純無向グラフ**とは、自己ループや多重辺を含まず、辺に向きの無いグラフのことをいいます。

グラフの同型とは？ $ N $ 頂点のグラフ $ G $ と $ H $ が**同型**であるとは、ある $ (1,2,\ldots,N) $ の並べ替え $ (P\ _\ 1,P\ _\ 2,\ldots,P\ _\ N) $ が存在して、どの $ 1\leq\ i\lt\ j\leq\ N $ に対しても

- $ G $ に頂点 $ i, $ 頂点 $ j $ を結ぶ辺が存在するとき、かつそのときに限り $ H $ に頂点 $ P\ _\ i, $ 頂点 $ P\ _\ j $ を結ぶ辺が存在する

が成り立つことをいいます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M\ _\ G $ $ u\ _\ 1 $ $ v\ _\ 1 $ $ u\ _\ 2 $ $ v\ _\ 2 $ $ \vdots $ $ u\ _\ {M\ _\ G} $ $ v\ _\ {M\ _\ G} $ $ M\ _\ H $ $ a\ _\ 1 $ $ b\ _\ 1 $ $ a\ _\ 2 $ $ b\ _\ 2 $ $ \vdots $ $ a\ _\ {M\ _\ H} $ $ b\ _\ {M\ _\ H} $ $ A\ _\ {1,2} $ $ A\ _\ {1,3} $ $ \ldots $ $ A\ _\ {1,N} $ $ A\ _\ {2,3} $ $ \ldots $ $ A\ _\ {2,N} $ $ \vdots $ $ A\ _\ {N-1,N} $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ N\leq8 $
- $ 0\leq\ M\ _\ G\leq\dfrac{N(N-1)}2 $
- $ 0\leq\ M\ _\ H\leq\dfrac{N(N-1)}2 $
- $ 1\leq\ u\ _\ i\lt\ v\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ G) $
- $ (u\ _\ i,v\ _\ i)\neq(u\ _\ j,v\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ G) $
- $ 1\leq\ a\ _\ i\lt\ b\ _\ i\leq\ N\ (1\leq\ i\leq\ M\ _\ H) $
- $ (a\ _\ i,b\ _\ i)\neq(a\ _\ j,b\ _\ j)\ (1\leq\ i\lt\ j\leq\ M\ _\ H) $
- $ 1\leq\ A\ _\ {i,j}\leq\ 10\ ^\ 6\ (1\leq\ i\lt\ j\leq\ N) $
- 入力はすべて整数

### Sample Explanation 1

与えられたグラフはそれぞれ以下のようになります。 !\[\](https://img.atcoder.jp/abc371/fbdb304dc71eecd7ddec97276a9c7040.png) たとえば、$ H $ に対して次のような $ 4 $ つの操作を順に行うことで、$ 9 $ 円を支払って$ G $ と $ H $ を同型にすることができます。 - $ (i,j)=(1,3) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 3 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(2,5) $ として操作を行う。$ H $ には頂点 $ 2 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 2 $ 円を支払ってこれを追加する。 - $ (i,j)=(1,5) $ として操作を行う。$ H $ には頂点 $ 1 $ と頂点 $ 5 $ を結ぶ辺があるので、$ 1 $ 円を支払ってこれを取り除く。 - $ (i,j)=(3,5) $ として操作を行う。$ H $ には頂点 $ 3 $ と頂点 $ 5 $ を結ぶ辺はないので、$ 5 $ 円を支払ってこれを追加する。 操作の結果、$ H $ は以下のようになります。 !\[\](https://img.atcoder.jp/abc371/68a56da8ec89b769989ae7d07bf163cd.png) 支払う金額を $ 8 $ 円以下にして $ G $ と $ H $ を同型にすることはできないため、`9` を出力してください。

### Sample Explanation 2

たとえば、$ (i,j)=(2,3),(2,4),(3,4) $ とした $ 3 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 3

たとえば、$ (i,j)=(4,5) $ とした $ 1 $ 回の操作を行うことで $ G $ と $ H $ を同型にすることができます。

### Sample Explanation 4

$ G $ や $ H $ には辺が含まれていないこともあります。 また、一度も操作をする必要がないこともあります。

## 样例 #1

### 输入

```
5
4
1 2
2 3
3 4
4 5
4
1 2
1 3
1 4
1 5
3 1 4 1
5 9 2
6 5
3
```

### 输出

```
9
```

## 样例 #2

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
9 1 1 1
1 1 1
1 1
9
```

### 输出

```
3
```

## 样例 #3

### 输入

```
5
3
1 2
2 3
3 4
4
1 2
2 3
3 4
4 5
5 4 4 4
4 4 4
4 4
5
```

### 输出

```
5
```

## 样例 #4

### 输入

```
2
0
0
371
```

### 输出

```
0
```

## 样例 #5

### 输入

```
8
13
1 8
5 7
4 6
1 5
7 8
1 6
1 2
5 8
2 6
5 6
6 7
3 7
4 8
15
3 5
1 7
4 6
3 8
7 8
1 2
5 6
1 6
1 5
1 4
2 8
2 6
2 4
4 7
1 3
7483 1694 5868 3296 9723 5299 4326
5195 4088 5871 1384 2491 6562
1149 6326 2996 9845 7557
4041 7720 1554 5060
8329 8541 3530
4652 3874
3748
```

### 输出

```
21214
```



---

---
title: "[ABC374C] Separated Lunch"
layout: "post"
diff: 普及-
pid: AT_abc374_c
tag: ['深度优先搜索 DFS']
---

# [ABC374C] Separated Lunch

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_c

キーエンス本社に勤務する人数が増えてきたので、本社に存在する部署を $ 2 $ つのグループに分け、昼休みの時間帯を分けることにしました。

キーエンス本社には $ N $ 個の部署が存在し、$ i $ 番目 $ (1\leq\ i\leq\ N) $ の部署に所属する人数は $ K_i $ 人です。

それぞれの部署をグループ $ A $, $ B $ のいずれか一方に割り当て、グループごとに同時に昼休みをとり、 かつグループ $ A $, $ B $ の昼休みの時間が重ならないようにしたとき、同時に昼休みをとる最大人数としてあり得る最小の値を求めてください。  
 すなわち、グループ $ A $ に割り当てられた部署に所属する人数の合計とグループ $ B $ に割り当てられた部署に所属する人数の合計 のうち大きい方の値としてあり得る最小の値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ K_1 $ $ K_2 $ $ \ldots $ $ K_N $

## 输出格式

同時に昼休みを取る最大人数としてあり得る最小の値を出力せよ。

## 说明/提示

### 制約

- $ 2\leq\ N\ \leq\ 20 $
- $ 1\leq\ K_i\ \leq\ 10^8 $
- 入力はすべて整数
 
### Sample Explanation 1

$ 1,2,5 $ 番目の部署をグループ $ A $ に、$ 3,4 $ 番目の部署をグループ $ B $ に割り当てたとき、 グループ $ A $ に割り当てられた部署に所属する人数の合計は $ 2+3+12=17 $ 、 グループ $ B $ に割り当てられた部署に所属する人数の合計は $ 5+10=15 $ となり、 このとき同時に昼休みを取る最大人数は $ 17 $ となります。 一方で、グループ $ A,B $ それぞれに割り当てられた部署に所属する人数の合計がいずれも $ 16 $ 以下になるように 部署を割り当てることはできないため、$ 17 $ を出力します。

### Sample Explanation 2

同一人数の部署が複数存在する可能性もあります。

### Sample Explanation 3

例えば、$ 1,4,5 $ 番目の部署をグループ $ A $ に、$ 2,3,6 $ 番目の部署をグループ $ B $ に割り当てたとき同時に昼休みを取る最大人数は $ 89 $ となります。

## 样例 #1

### 输入

```
5

2 3 5 10 12
```

### 输出

```
17
```

## 样例 #2

### 输入

```
2

1 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
6

22 25 26 45 22 31
```

### 输出

```
89
```



---

---
title: "[ABC378D] Count Simple Paths"
layout: "post"
diff: 普及-
pid: AT_abc378_d
tag: ['搜索', '深度优先搜索 DFS']
---

# [ABC378D] Count Simple Paths

## 题目描述

给定一个 $H$ 行 $W$ 列的网格；令 $(i, j)$ 为网格中从上到下第 $i$ 行、从左到右第 $j$ 列的格子。 

当 $ S_{i,j} $ 为 `.` 时，格子为空格；当 $ S_{i,j} $ 为 `#` 时，格子为障碍物。

请计算从某个空格出发，经过 $K$ 次移动（上下左右），不经过障碍物且不重复经过同一个格子的路径数。

具体地，统计满足以下条件的，长度为 $K+1$ 的序列 $((i_0,j_0),(i_1,j_1),\dots,(i_K,j_K))$

- 对于每个 $ 0\ \leq\ k\ \leq\ K $，都有 $ 1\ \leq\ i_k\ \leq\ H,\ 1\ \leq\ j_k\ \leq\ W $，且 $ S_{i_k,j_k} $ 为 `.`。
- 对于每个 $ 0\ \leq\ k\ \leq\ K-1 $，有 $ |i_{k+1}-i_k|\ +\ |j_{k+1}-j_k|\ =\ 1 $。
- 对于每个 $ 0\ \leq\ k\ <\ l\ \leq\ K $，有 $ (i_k,j_k)\neq\ (i_l,j_l) $。

## 输入格式

输入为标准输入，格式如下：

>$ H $ $ W $ $ K $
$ S_{1,1}S_{1,2}\dots S_{1,W} $
$ S_{2,1}S_{2,2}\dots S_{2,W} $
$\vdots$
$ S_{H,1}S_{H,2}\dots S_{H,W} $

## 输出格式

输出满足条件的路径数量。

### 样例1 解释


总共有两种可能的路径

-   $(1,1) \rightarrow (2,1) \rightarrow (2,2)$
-   $(2,2) \rightarrow (2,1) \rightarrow (1,1)$


Translated by [Route101](https://www.luogu.com.cn/user/262435).

## 说明/提示

-  $1 \leq H, W \leq 10$
-  $1 \leq K \leq 11$
-  $H$, $W$, 和 $K$ 均为整数。
-  每个 $S_{i,j}$ 均为 `.` 或 `#`。
-  网格中至少存在一个格子为空格。

## 样例 #1

### 输入

```
2 2 2
.#
..
```

### 输出

```
2
```

## 样例 #2

### 输入

```
2 3 1
.#.
#.#
```

### 输出

```
0
```

## 样例 #3

### 输入

```
10 10 11
....#..#..
.#.....##.
..#...##..
...#......
......##..
..#......#
#........#
..##......
.###....#.
...#.....#
```

### 输出

```
218070
```



---

---
title: "[ABC396D] Minimum XOR Path"
layout: "post"
diff: 普及-
pid: AT_abc396_d
tag: ['搜索', '深度优先搜索 DFS']
---

# [ABC396D] Minimum XOR Path

## 题目描述

给定一个简单连通无向图，包含 $N$ 个顶点（编号为 $1$ 至 $N$）和 $M$ 条边（编号为 $1$ 至 $M$）。边 $i$ 连接顶点 $u_i$ 和 $v_i$，并带有标签 $w_i$。

请找出从顶点 $1$ 到顶点 $N$ 的所有简单路径（不重复经过顶点的路径）中，路径上所有边标签的总异或值的最小可能值。

关于异或（XOR）的定义：  
对于非负整数 $A$ 和 $B$，它们的异或 $A \oplus B$ 定义如下：
- $A \oplus B$ 的二进制表示中，$2^k$ 位（$k \geq 0$）的值为 $1$，当且仅当 $A$ 和 $B$ 在 $2^k$ 位上的值不同；否则为 $0$。

例如，$3 \oplus 5 = 6$（二进制表示为 $011 \oplus 101 = 110$）。  
对于 $k$ 个整数 $p_1, \dots, p_k$ 的异或，定义为 $(\cdots ((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k)$，且其值与运算顺序无关。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $u_1$ $v_1$ $w_1$  
> $u_2$ $v_2$ $w_2$  
> $\vdots$  
> $u_M$ $v_M$ $w_M$

## 输出格式

输出答案。

## 说明/提示

### 约束条件

- $2 \leq N \leq 10$
- $N - 1 \leq M \leq \frac{N(N-1)}{2}$
- $1 \leq u_i < v_i \leq N$
- $0 \leq w_i < 2^{60}$
- 输入的图是简单连通无向图
- 输入中的所有值均为整数

### 样例解释 1

从顶点 $1$ 到顶点 $4$ 存在以下两条简单路径：  
1. 顶点 $1$ → 顶点 $2$ → 顶点 $4$  
   路径上的边标签总异或值为 $6$。  
2. 顶点 $1$ → 顶点 $3$ → 顶点 $4$  
   路径上的边标签总异或值为 $3$。  
因此，最小值为 $3$。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4 4

1 2 3

2 4 5

1 3 4

3 4 7
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4 3

1 2 1

2 3 2

3 4 4
```

### 输出

```
7
```

## 样例 #3

### 输入

```
7 10

1 2 726259430069220777

1 4 988687862609183408

1 5 298079271598409137

1 6 920499328385871537

1 7 763940148194103497

2 4 382710956291350101

3 4 770341659133285654

3 5 422036395078103425

3 6 472678770470637382

5 7 938201660808593198
```

### 输出

```
186751192333709144
```



---

---
title: "深さ優先探索"
layout: "post"
diff: 普及-
pid: AT_dfs_a
tag: ['搜索', '深度优先搜索 DFS']
---

# 深さ優先探索

## 题目描述

[problemUrl]: https://atcoder.jp/contests/atc001/tasks/dfs_a

この問題は、講座用問題です。ページ下部に解説が掲載されています。

高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。

高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ c_{0,0} $ $ c_{0,1} $ $ c_{0,W-1} $ $ c_{1,0} $ $ c_{1,1} $ $ c_{1,W-1} $ : $ c_{H-1,0} $ $ c_{H-1,1} $ $ c_{H-1,W-1} $

- $ 1 $ 行目には、街の南北の長さとして整数 $ H(1≦H≦500) $ と東西の長さとして整数 $ W(1≦W≦500) $ が空白で区切られて与えられる。
- $ 2 $ 行目からの $ H $ 行には、格子状の街の各区画における状態 $ c_{i,j}(0≦i≦H-1,\ 0≦j≦W-1) $ が与えられる。 
  - $ i $ 行目 $ j $ 文字目の文字 $ c_{i,j} $ はそれぞれ `s`, `g`, `.`, `#` のいずれかで与えられ、座標 $ (j,i) $ が下記のような状態であることを表す。 
      - `s` : その区画が家であることを表す。
      - `g` : その区画が魚屋であることを表す。
      - `.` : その区画が道であることを表す。
      - `#` : その区画が塀であることを表す。
  - 高橋君は家・魚屋・道は通ることができるが、塀は通ることができない。
  - 与えられた街の外を通ることはできない。
  - `s` と `g` はそれぞれ 1 つずつ与えられる。

## 输出格式

塀を $ 1 $ 回も壊さずに、家から魚屋まで辿り着くことができる場合は `Yes`、辿りつけない場合は `No` を標準出力に $ 1 $ 行で出力せよ。

## 说明/提示

### 解説

  **[深さ優先探索による塗りつぶし](https://www.slideshare.net/secret/lyag9AlTOMIY2J "深さ優先探索による塗りつぶし")**  from **[AtCoder Inc.](http://www.slideshare.net/chokudai)** 

### Sample Explanation 1

高橋君は、魚屋にたどり着くことができません。

## 样例 #1

### 输入

```
4 5

s####

....#

#####

#...g
```

### 输出

```
No
```

## 样例 #2

### 输入

```
4 4

...s

....

....

.g..
```

### 输出

```
Yes
```

## 样例 #3

### 输入

```
10 10

s.........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

g.#.#.#.#.

#.#.#.#.#.

###.#.#.#.

#.....#...
```

### 输出

```
No
```

## 样例 #4

### 输入

```
10 10

s.........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

g.#.#.#.#.

#.#.#.#.#.

#.#.#.#.#.

#.....#...
```

### 输出

```
Yes
```

## 样例 #5

### 输入

```
1 10

s..####..g
```

### 输出

```
No
```



---


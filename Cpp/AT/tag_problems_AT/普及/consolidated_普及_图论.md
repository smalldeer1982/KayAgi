---
title: "[ABC079D] Wall"
layout: "post"
diff: 普及/提高-
pid: AT_abc079_d
tag: ['图论', '最短路']
---

# [ABC079D] Wall

## 题目描述

## 【题目大意】

你面前有一堵墙，墙上有数字，你需要将墙上的数字都变成 ```1``` 。  
现在给出一个 $W\times H$ 的矩阵 $A$ 表示墙上数字的情况。  
其中若 $A_{i,j}=-1$ ，则表示位置 $(i,j)$ 上没有数字，否则 $A_{i,j}$ 的值表示墙上 $(i,j)$ 位置的数字。  
当然，你还有一张 $10\times 10$ 的表 $C$，其中 $C_{i,j}$ 表示把数字 $i$ 转化成数字 $j$ 所需要的花费。  
求花费的最小值。

## 输入格式

先输入两个数字 $H$ , $W$ 。  
接下来输入表 $C$。  
最后输入矩阵 $A$。

## 输出格式

一行，代表答案。

## 说明/提示

$1\le H,W\le200$  
$1\le C_{i,j}\le 10^3 (i\neq j)$  
$C_{i,j}=0(i=j)$  
$-1\le A_{i,j}\le 9$
所有数据保证在 ```int``` 范围以内。

## 样例 #1

### 输入

```
2 4

0 9 9 9 9 9 9 9 9 9

9 0 9 9 9 9 9 9 9 9

9 9 0 9 9 9 9 9 9 9

9 9 9 0 9 9 9 9 9 9

9 9 9 9 0 9 9 9 9 2

9 9 9 9 9 0 9 9 9 9

9 9 9 9 9 9 0 9 9 9

9 9 9 9 9 9 9 0 9 9

9 9 9 9 2 9 9 9 0 9

9 2 9 9 9 9 9 9 9 0

-1 -1 -1 -1

8 1 1 8
```

### 输出

```
12
```

## 样例 #2

### 输入

```
5 5

0 999 999 999 999 999 999 999 999 999

999 0 999 999 999 999 999 999 999 999

999 999 0 999 999 999 999 999 999 999

999 999 999 0 999 999 999 999 999 999

999 999 999 999 0 999 999 999 999 999

999 999 999 999 999 0 999 999 999 999

999 999 999 999 999 999 0 999 999 999

999 999 999 999 999 999 999 0 999 999

999 999 999 999 999 999 999 999 0 999

999 999 999 999 999 999 999 999 999 0

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1

1 1 1 1 1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3 5

0 4 3 6 2 7 2 5 3 3

4 0 5 3 7 5 3 7 2 7

5 7 0 7 2 9 3 2 9 1

3 6 2 0 2 4 6 4 2 3

3 5 7 4 0 6 9 7 6 7

9 8 5 2 2 0 4 7 6 5

5 4 6 3 2 3 0 5 4 3

3 6 2 3 4 2 4 0 8 9

4 6 5 4 3 5 3 2 0 8

2 1 3 4 5 7 8 6 4 0

3 5 2 6 1

2 5 3 2 1

6 9 2 5 6
```

### 输出

```
47
```



---

---
title: "[ABC126E] 1 or 2"
layout: "post"
diff: 普及/提高-
pid: AT_abc126_e
tag: ['图论', '并查集', '深度优先搜索 DFS', '连通块']
---

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ X_1 $ $ Y_1 $ $ Z_1 $ $ X_2 $ $ Y_2 $ $ Z_2 $ $ \vdots $ $ X_M $ $ Y_M $ $ Z_M $

## 输出格式

$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てるために払う必要のあるコストの合計の最小値を出力せよ。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
100000 1

1 100000 100
```

### 输出

```
99999
```



---

---
title: "[ABC252E] Road Reduction"
layout: "post"
diff: 普及/提高-
pid: AT_abc252_e
tag: ['图论', '最短路', '生成树']
---

# [ABC252E] Road Reduction

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc252/tasks/abc252_e

AtCoder 王国には都市 $ 1,2,\ldots,N $ の $ N $ 個の都市と、道路 $ 1,2,\ldots,M $ の $ M $ 本の道路があります。  
道路 $ i $ は都市 $ A_i $ と $ B_i $ を双方向に結び、距離は $ C_i $ です。  
どの都市間もいくつかの道路を通って行き来することができます。

財政難である王国は、どの都市間もいくつかの道路を通って行き来できるという条件を満たすように $ N-1 $ 本の道路を保守し、それ以外の道路を廃道にすることにしました。

保守する道路のみを通って都市 $ 1 $ から都市 $ i $ へ移動するときの距離を $ d_i $ とするとき、保守する道路の選び方であって、$ d_2+d_3+\ldots+d_N $ を最小化するようなものを $ 1 $ つ出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ A_1 $ $ B_1 $ $ C_1 $ $ A_2 $ $ B_2 $ $ C_2 $ $ \vdots $ $ A_M $ $ B_M $ $ C_M $

## 输出格式

保守するような道路の番号を空白区切りで出力せよ。出力の順序は問わない。  
答えが複数存在する場合、どれを出力しても正解とみなされる。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i\ <\ B_i\ \leq\ N $
- $ i\neq\ j $ のとき、$ (A_i,B_i)\neq(A_j,B_j) $
- $ 1\leq\ C_i\ \leq\ 10^9 $
- どの都市間もいくつかの道路を通って行き来することができる
- 入力に含まれる値は全て整数である

### Sample Explanation 1

保守する道路の選び方と $ d_i $ の値は次のようになります。 - 道路 $ 1,2 $ を保守するとき、$ d_2=1 $, $ d_3=3 $ - 道路 $ 1,3 $ を保守するとき、$ d_2=1 $, $ d_3=10 $ - 道路 $ 2,3 $ を保守するとき、$ d_2=12 $, $ d_3=10 $ よって、道路 $ 1,2 $ を保守するときに $ d_2+d_3 $ が最小になります。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 2
1 3 10
```

### 输出

```
1 2
```

## 样例 #2

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 1
2 4 1
3 4 1
```

### 输出

```
3 1 2
```



---

---
title: "[ABC254E] Small d and k"
layout: "post"
diff: 普及/提高-
pid: AT_abc254_e
tag: ['图论', '枚举']
---

# [ABC254E] Small d and k

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc254/tasks/abc254_e

$ N $ 頂点 $ M $ 辺の単純無向グラフがあり、各頂点には $ 1,\ldots,N $ と番号が付けられています。 $ i=1,\ldots,M $ に対し、 $ i $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結びます。また、**各頂点の次数は $ 3 $ 以下です。**

$ i=1,\ldots,Q $ に対し、次のクエリに答えてください。

- 頂点 $ x_i $ との距離が $ k_i $ 以下であるような頂点の番号の総和を求めよ。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ a_1 $ $ b_1 $ $ \vdots $ $ a_M $ $ b_M $ $ Q $ $ x_1 $ $ k_1 $ $ \vdots $ $ x_Q $ $ k_Q $

## 输出格式

$ Q $ 行出力せよ。 $ i $ 行目には $ i $ 番目のクエリへの答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 1.5\ \times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ \min\ (\frac{N(N-1)}{2},\frac{3N}{2}) $
- $ 1\ \leq\ a_i\ \lt\ b_i\ \leq\ N $
- $ i\neq\ j $ ならば $ (a_i,b_i)\ \neq\ (a_j,b_j) $
- 与えられるグラフの各頂点の次数は $ 3 $ 以下
- $ 1\ \leq\ Q\ \leq\ 1.5\ \times\ 10^5 $
- $ 1\ \leq\ x_i\ \leq\ N $
- $ 0\ \leq\ k_i\ \leq\ 3 $
- 入力はすべて整数

### Sample Explanation 1

$ 1 $ 番目のクエリでは、頂点 $ 1 $ との距離が $ 1 $ 以下であるような頂点は頂点 $ 1 $ のみなので $ 1 $ が答えです。 $ 2 $ 番目のクエリでは、頂点 $ 2 $ との距離が $ 2 $ 以下であるような頂点は頂点 $ 2,3,4,5,6 $ なのでこれらの総和の $ 20 $ が答えになります。 $ 3 $ 番目以降のクエリも同様にして答えを求められます。

## 样例 #1

### 输入

```
6 5
2 3
3 4
3 5
5 6
2 6
7
1 1
2 2
2 0
2 3
4 1
6 0
4 3
```

### 输出

```
1
20
2
20
7
6
20
```



---

---
title: "[ABC256E] Takahashi's Anguish"
layout: "post"
diff: 普及/提高-
pid: AT_abc256_e
tag: ['图论', 'Tarjan']
---

# [ABC256E] Takahashi's Anguish

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc256/tasks/abc256_e

$ 1 $ から $ N $ の番号がついた $ N $ 人の人がいます。  
 高橋君は $ 1 $ から $ N $ までの整数を並び替えた列 $ P\ =\ (P_1,\ P_2,\ \dots,\ P_N) $ を $ 1 $ つ選んで、 人 $ P_1 $, 人 $ P_2 $, $ \dots $, 人 $ P_N $ の順番に $ 1 $ 人ずつキャンディを配ることにしました。  
 人 $ i $ は人 $ X_i $ のことが嫌いなので、高橋君が人 $ i $ より先に人 $ X_i $ にキャンディを配った場合、人 $ i $ に不満度 $ C_i $ がたまります。そうでない場合の人 $ i $ の不満度は $ 0 $ です。  
 高橋君が $ P $ を自由に選べるとき、全員の不満度の和の最小値はいくつになりますか？

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ X_1 $ $ X_2 $ $ \dots $ $ X_N $ $ C_1 $ $ C_2 $ $ \dots $ $ C_N $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ X_i\ \leq\ N $
- $ X_i\ \neq\ i $
- $ 1\ \leq\ C_i\ \leq\ 10^9 $
- 入力される値はすべて整数

### Sample Explanation 1

$ P\ =\ (1,\ 3,\ 2) $ とすれば不満度が正になるのは人 $ 2 $ だけで、この時全員の不満度の和は $ 10 $ になります。 これより不満度の和を小さくすることはできないので、答えは $ 10 $ です。

## 样例 #1

### 输入

```
3

2 3 2

1 10 100
```

### 输出

```
10
```

## 样例 #2

### 输入

```
8

7 3 5 5 8 4 1 2

36 49 73 38 30 85 27 45
```

### 输出

```
57
```



---

---
title: "[ABC400D] Takahashi the Wall Breaker"
layout: "post"
diff: 普及/提高-
pid: AT_abc400_d
tag: ['图论', '广度优先搜索 BFS', '最短路']
---

# [ABC400D] Takahashi the Wall Breaker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc400/tasks/abc400_d

高桥君想去鱼店买鳗鱼。

高桥君居住的城镇由 $H$ 行 $W$ 列的网格状区域构成，每个区域是道路或墙壁。  
以下，将从上往下第 $i$ 行（$1 \leq i \leq H$）、从左往右第 $j$ 列（$1 \leq j \leq W$）的区域表示为区域 $(i, j)$。  
各区域的信息由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 给出。具体来说，当 $S_i$ 的第 $j$ 个字符（$1 \leq i \leq H$，$1 \leq j \leq W$）为 `.` 时，区域 $(i, j)$ 是道路；当为 `#` 时，区域 $(i, j)$ 是墙壁。

高桥君可以按任意顺序重复执行以下两种操作：

- 移动到上下左右相邻的、位于城镇内且为道路的区域。
- 选择一个上下左右方向，进行**前踢**。  
  当高桥君进行前踢时，可以将当前区域在该方向上 **前 1 格** 和 **前 2 格** 的区域（如果它们是墙壁）变为道路。  
  注意：即使前 1 格或前 2 格位于城镇外，仍然可以进行前踢操作，但城镇外的区域不会发生变化。

高桥君最初位于区域 $(A, B)$，想要到达位于区域 $(C, D)$ 的鱼店。  
保证高桥君初始所在的区域及鱼店所在的区域是道路。  
请计算高桥君到达鱼店所需的最小**前踢次数**。

## 输入格式

输入通过标准输入给出，格式如下：

> $H$ $W$  
> $S_1$  
> $S_2$  
> $\vdots$  
> $S_H$  
> $A$ $B$ $C$ $D$

## 输出格式

输出高桥君到达鱼店所需的最小**前踢次数**。


## 说明/提示

### 约束条件

- $1 \leq H \leq 1000$
- $1 \leq W \leq 1000$
- $S_i$ 是仅由 `.` 和 `#` 组成的长度为 $W$ 的字符串
- $1 \leq A, C \leq H$
- $1 \leq B, D \leq W$
- $(A, B) \neq (C, D)$
- $H, W, A, B, C, D$ 均为整数
- 高桥君初始所在的区域及鱼店所在的区域保证是道路

### 样例解释 1

高桥君最初位于区域 $(1, 1)$。通过反复移动到道路区域，可以到达区域 $(7, 4)$。在区域 $(7, 4)$ 向左方向进行前踢后，区域 $(7, 3)$ 和 $(7, 2)$ 会从墙壁变为道路。之后，通过反复移动（包括新变为道路的区域）即可到达位于区域 $(7, 1)$ 的鱼店。此时前踢次数为 $1$ 次，且无法在不使用前踢的情况下到达鱼店，因此输出 $1$。

### 样例解释 2

高桥君最初位于区域 $(1, 1)$。向右方向进行前踢后，区域 $(1, 2)$ 会从墙壁变为道路（向右前 2 格超出城镇范围，因此无变化）。之后可以从区域 $(1, 1)$ 移动到区域 $(1, 2)$，再到达区域 $(2, 2)$ 的鱼店。此时前踢次数为 $1$ 次，且无法在不使用前踢的情况下到达鱼店，因此输出 $1$。

### 样例解释 3

前踢操作可能影响包含鱼店所在区域的区画，但鱼店所在区域原本就是道路，因此不会发生变化。特别是前踢操作不会破坏鱼店。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
10 10

..........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

.##.#.#.#.

###.#.#.#.

###.#.#.#.

#.....#...

1 1 7 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 2

.#

#.

1 1 2 2
```

### 输出

```
1
```

## 样例 #3

### 输入

```
1 3

.#.

1 1 1 3
```

### 输出

```
1
```

## 样例 #4

### 输入

```
20 20

####################

##...##....###...###

#.....#.....#.....##

#..#..#..#..#..#..##

#..#..#....##..#####

#.....#.....#..#####

#.....#..#..#..#..##

#..#..#.....#.....##

#..#..#....###...###

####################

####################

##..#..##...###...##

##..#..#.....#.....#

##..#..#..#..#..#..#

##..#..#..#..#..#..#

##.....#..#..#..#..#

###....#..#..#..#..#

#####..#.....#.....#

#####..##...###...##

####################

3 3 18 18
```

### 输出

```
3
```



---

---
title: "[ABC410D] XOR Shortest Walk"
layout: "post"
diff: 普及/提高-
pid: AT_abc410_d
tag: ['图论', '广度优先搜索 BFS', '记忆化搜索']
---

# [ABC410D] XOR Shortest Walk

## 题目描述

给你一个 $N$ 条边 $M$ 条边的有向图，第 $i$ 条边从结点 $A_i$ 连向结点 $B_i$，权值为 $W_i$。

求所有从 $1$ 到 $N$ 的路径中，可以重复经过同一个点和同一条边，路径上所有边权值的异或和的最小值。

## 输入格式

第一行两个整数 $N,M(2\le N\le 1000,0\le M\le 1000)$。\
接下来 $M$ 行，每行三个整数 $A_i,B_i,W_i(0\le W_i<2^{10})$。

## 输出格式

如果不存在 $1$ 到 $N$ 的路径，输出一行一个整数 $-1$。

否则，输出一行一个整数表示答案。

## 说明/提示

**样例 1 解释**

路径(边 $1$，边 $2$) 的边权异或和为 $1$。

**样例 2 解释**

路径(边 $1$，边 $2$，边 $3$，边 $4$) 的边权异或和为 $0$。

注意 $N$ 可能出现在路径的中间。

**样例 3 解释**

如果不存在 $1$ 到 $N$ 的路径，输出 $-1$。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
3 3

1 2 4

2 3 5

1 3 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 4

1 4 7

4 2 2

2 3 4

3 4 1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
999 4

1 2 9

2 1 8

1 2 7

1 1 6
```

### 输出

```
-1
```



---


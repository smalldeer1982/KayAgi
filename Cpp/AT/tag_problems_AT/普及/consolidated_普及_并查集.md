---
title: "[ABC126E] 1 or 2"
layout: "post"
diff: 普及/提高-
pid: AT_abc126_e
tag: ['图论', '并查集', '深度优先搜索 DFS', '连通块']
---

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ X_1 $ $ Y_1 $ $ Z_1 $ $ X_2 $ $ Y_2 $ $ Z_2 $ $ \vdots $ $ X_M $ $ Y_M $ $ Z_M $

## 输出格式

$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てるために払う必要のあるコストの合計の最小値を出力せよ。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
100000 1

1 100000 100
```

### 输出

```
99999
```



---

---
title: "[ABC350D] New Friends"
layout: "post"
diff: 普及/提高-
pid: AT_abc350_d
tag: ['并查集']
---

# [ABC350D] New Friends

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc350/tasks/abc350_d

$ 1 $ から $ N $ の番号がついた $ N $ 人のユーザが利用している SNS があります。

この SNS では $ 2 $ 人のユーザが互いに**友達**になれる機能があります。  
 友達関係は双方向的です。すなわち、ユーザ X がユーザ Y の友達であるならば、必ずユーザ Y はユーザ X の友達です。

現在 SNS 上には $ M $ 組の友達関係が存在し、$ i $ 組目の友達関係はユーザ $ A_i $ とユーザ $ B_i $ からなります。

以下の操作を行える最大の回数を求めてください。

- 操作：3 人のユーザ X, Y, Z であって、X と Y は友達、Y と Z は友達であり、X と Z は友達でないようなものを選ぶ。X と Z を友達にする。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ A_1 $ $ B_1 $ $ \vdots $ $ A_M $ $ B_M $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 0\ \leq\ M\ \leq\ 2\times\ 10^5 $
- $ 1\leq\ A_i\ <\ B_i\ \leq\ N $
- $ (A_i,B_i) $ は相異なる
- 入力は全て整数である
 
### Sample Explanation 1

次のようにして「友達の友達と新たに友達になる」という操作は $ 3 $ 回行えます。 - ユーザ $ 1 $ が友達(ユーザ $ 2 $)の友達であるユーザ $ 3 $ と新たに友達になる - ユーザ $ 3 $ が友達(ユーザ $ 1 $)の友達であるユーザ $ 4 $ と新たに友達になる - ユーザ $ 2 $ が友達(ユーザ $ 1 $)の友達であるユーザ $ 4 $ と新たに友達になる $ 4 $ 回以上行うことはできません。

### Sample Explanation 2

もともと友達関係が存在しないとき、新たな友達関係は発生しません。

## 样例 #1

### 输入

```
4 3

1 2

2 3

1 4
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 0
```

### 输出

```
0
```

## 样例 #3

### 输入

```
10 8

1 2

2 3

3 4

4 5

6 7

7 8

8 9

9 10
```

### 输出

```
12
```



---

---
title: "[ABC395D] Pigeon Swap"
layout: "post"
diff: 普及/提高-
pid: AT_abc395_d
tag: ['并查集']
---

# [ABC395D] Pigeon Swap

## 题目描述

有 $N$ 只鸽子（编号 $1,2,\ldots,N$）和 $N$ 个巢（编号 $1,2,\ldots,N$）。初始时，鸽子 $i$（$1 \leq i \leq N$）位于巢 $i$ 中。

接下来对鸽子进行 $Q$ 次操作，操作分为以下三种类型：

- **类型 1**：给定整数 $a,b$（$1 \leq a \leq N$，$1 \leq b \leq N$）。将鸽子 $a$ 从当前所在的巢中取出，放入巢 $b$。
- **类型 2**：给定整数 $a,b$（$1 \leq a < b \leq N$）。将巢 $a$ 中所有鸽子移动到巢 $b$，同时将巢 $b$ 中所有鸽子移动到巢 $a$。这两个移动操作是同时进行的。
- **类型 3**：给定整数 $a$（$1 \leq a \leq N$）。报告鸽子 $a$ 当前所在的巢的编号。

请输出所有类型 3 的操作的结果。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $Q$  
> $op_1$  
> $op_2$  
> $\vdots$  
> $op_Q$

其中，第 $i+1$ 行的 $op_i$ 表示第 $i$ 次操作，格式为以下之一：

- 若为类型 1 操作：  
  `1 a b`  
  表示以 $a$ 和 $b$ 为参数执行类型 1 操作。

- 若为类型 2 操作：  
  `2 a b`  
  表示以 $a$ 和 $b$ 为参数执行类型 2 操作。

- 若为类型 3 操作：  
  `3 a`  
  表示以 $a$ 为参数执行类型 3 操作。

## 输出格式

设类型 3 的操作共有 $q$ 个，输出 $q$ 行，每行对应一个类型 3 操作的查询结果（即鸽子所在巢的编号）。


## 说明/提示

### 约束条件
- $1 \leq N \leq 10^6$
- $1 \leq Q \leq 3 \times 10^5$
- 所有操作均符合题目描述中的参数范围。
- 输入中至少包含一个类型 3 操作。
- 输入均为整数。

### 样例解释 1
操作过程中鸽子的移动如图所示（图片链接略）。类型 3 操作应报告的巢编号依次为 $4,5,2,5$，因此输出四行：`4`、`5`、`2`、`5`。

### 样例解释 2
在类型 1 操作中，可能存在将鸽子取出后又放回原巢的情况。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
6 8

1 2 4

1 3 6

3 2

2 4 5

3 2

1 4 2

3 4

3 2
```

### 输出

```
4

5

2

5
```

## 样例 #2

### 输入

```
1 2

1 1 1

3 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
30 15

3 3

2 8 30

2 12 15

2 2 17

1 19 1

2 7 30

3 12

3 8

2 25 26

1 13 10

1 16 10

2 16 29

2 1 21

2 6 11

1 21 8
```

### 输出

```
3

15

7
```



---

---
title: "[ABC399C] Make it Forest"
layout: "post"
diff: 普及/提高-
pid: AT_abc399_c
tag: ['并查集']
---

# [ABC399C] Make it Forest

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc399/tasks/abc399_c

给定一个由 $N$ 个顶点和 $M$ 条边构成的简单无向图，顶点编号为 $1$ 至 $N$。第 $i$ 条边连接顶点 $u_i$ 和顶点 $v_i$。  
若要将该图变为森林，至少需要删除多少条边？

**森林的定义**：简单无向图 $F$ 是森林，当且仅当 $F$ 不包含任何环。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $u_1$ $v_1$  
> $u_2$ $v_2$  
> $\vdots$  
> $u_M$ $v_M$

## 输出格式

输出答案。

## 说明/提示

### 约束条件

- $1 \leq N \leq 2 \times 10^5$
- $0 \leq M \leq \min\left( \frac{N(N-1)}{2}, 2 \times 10^5 \right)$
- $1 \leq u_i < v_i \leq N$
- 输入的图是简单无向图（无自环和重边）
- 所有输入值均为整数

### 样例解释 1

例如，删除第 1 条边后，该图将变为森林。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
4 4

1 2

1 3

2 4

3 4
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 0
```

### 输出

```
0
```

## 样例 #3

### 输入

```
10 10

7 9

4 6

6 10

2 5

5 6

5 9

6 8

4 8

1 5

1 4
```

### 输出

```
2
```



---

---
title: "[ABC408E] Minimum OR Path"
layout: "post"
diff: 普及/提高-
pid: AT_abc408_e
tag: ['搜索', '贪心', '并查集']
---

# [ABC408E] Minimum OR Path

## 题目描述

给定一个连通无向图，该图有 $N$ 个顶点和 $M$ 条边，且无自环，顶点编号从 $1$ 到 $N$，边编号从 $1$ 到 $M$。边 $i$ 双向连接顶点 $u_i$ 和 $v_i$，其边权为 $w_i$。

在从顶点 $1$ 到顶点 $N$ 的简单路径（即不会多次访问同一顶点的路径）中，求出该路径中所有边的权值的按位 $\mathrm{OR}$ 的最小可能值。

什么是按位 $\mathrm{OR}$ 运算？

非负整数 $A$ 和 $B$ 的按位 $\mathrm{OR}$，即 $A\ \mathrm{OR}\ B$，定义如下：

- 如果 $A$ 和 $B$ 的二进制表示中 $2^k$ 位至少有一位为 $1$，则 $A\ \mathrm{OR}\ B$ 的二进制表示中 $2^k(k \geq 0)$ 位上的数字为 $1$，否则为 $0$。

例如，$3\ \mathrm{OR}\ 5 = 7$（二进制表示为：$011\ \mathrm{OR}\ 101 = 111$）。
一般而言，$k$ 个非负整数 $p_1, p_2, p_3, \dots, p_k$的按位 $\mathrm{OR}$ 定义为 $(\dots ((p_1\ \mathrm{OR}\ p_2)\ \mathrm{OR}\ p_3)\ \mathrm{OR}\ \dots\ \mathrm{OR}\ p_k)$，并且可以证明这与 $p_1, p_2, p_3, \dots p_k$ 的顺序无关。

## 输入格式

输入来自标准输入，格式如下：

- 第一行两个整数 $N,M$。
- 接下来 $M$ 行每行三个整数，分别表示 $u_i,v_i,w_i$。

## 输出格式

输出一行一个整数表示答案。

## 说明/提示

### 约束

- $2\le N\le 2×10^5$
- $N-1\le M\le 2×10^5$
- $1\le u_i\le v_i\le N$
- $0\le w_i\le2^{30}$
- 给定图为连通图。
- 所有输入值均为整数。

### 样例 1 提示：

按顺序遍历边 $1,3,5$，并按顺序访问顶点 $1,2,3,4$，最终的按位 $\mathrm{OR}$ 为 $1\ \mathrm{OR}\ 2\ \mathrm{OR}\ 3=3$。

不可能使按位 $\mathrm{OR}$ 小于 $3$，因此输出 $3$。

### 样例 2 提示：

该图可能包含重边。

## 样例 #1

### 输入

```
4 5

1 2 1

1 3 4

2 3 2

2 4 4

3 4 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 5

1 2 1

1 2 2

1 2 3

1 2 4

2 3 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
8 12

4 5 16691344

5 7 129642441

2 7 789275447

3 8 335307651

3 5 530163333

5 6 811293773

3 8 333712701

1 2 2909941

2 3 160265478

5 7 465414272

1 3 903373004

6 7 408299562
```

### 输出

```
468549631
```



---

---
title: "[ARC164B] Switching Travel"
layout: "post"
diff: 普及/提高-
pid: AT_arc164_b
tag: ['并查集']
---

# [ARC164B] Switching Travel

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc164/tasks/arc164_b

頂点に $ 1 $ から $ N $ までの番号がついた $ N $ 頂点の単純、連結な無向グラフがあります。 このグラフには $ M $ 本の辺があり、 $ i $ 番目の辺は $ 2 $ 頂点 $ a_i $ , $ b_i $ を結んでいます。

また、各頂点は白または黒の色を持ち、最初の状態が $ c_i $ で与えられます。 $ c_i $ は $ 0 $ または $ 1 $ であり、$ c_i=0 $ であれば頂点 $ i $ は初め白色であり、$ c_i=1 $ であれば頂点 $ i $ は初め黒色です。

あなたはこのグラフ上で、好きな頂点を $ 1 $ つ選んで出発点とし、

- 今いる頂点と辺で結ばれた頂点のうち、今いる頂点と異なる色の頂点に移動する。その直後に、移動元の頂点の色を反転する（元の色が白なら黒に、黒なら白に変える）。
 
という動作を好きな回数繰り返します。

$ 1 $ 回以上の動作を行ったうえで、再び出発点に戻ってくることは可能でしょうか。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ $ \vdots $ $ a_M $ $ b_M $ $ c_1 $ $ c_2 $ $ \ldots $ $ c_N $

## 输出格式

$ 1 $ 回以上の動作を行ったうえで再び出発点に戻ってくることが可能な場合は `Yes` を、そのようなことが不可能な場合は `No` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ N-1\ \leq\ M\ \leq\ \mathrm{min}\ \lbrace\ 2\ \times\ 10^5,N(N-1)/2\ \rbrace $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ N $ $ (1\ \leq\ i\ \leq\ M) $
- $ c_i=0 $ または $ c_i=1 $ $ (1\ \leq\ i\ \leq\ N) $
- 与えられるグラフは単純かつ連結である
- 入力される値はすべて整数である
 
### Sample Explanation 1

例えば、頂点 $ 1 $ から出発することを考えます。 最初の動作では、頂点 $ 2 $ に移動し、移動元である頂点 $ 1 $ の色を白から黒に変化させます。この際のグラフの変化は下の図の通りです（丸で囲った頂点が今いる頂点を表します）。 その後、頂点 $ 3 $, $ 4 $, $ 2 $ へと順に移動すると、この時点で頂点 $ 1,2,3,4 $ の色は順に黒、白、黒、白となっています。 したがって、次の動作で頂点 $ 1 $ に移動することができ、出発点に戻ってくることができました。 !\[\](https://img.atcoder.jp/arc164/69700c7a0d96daa9c93ad01b89530e53.png)

### Sample Explanation 2

このグラフでは、どの頂点を出発点に選んでも、条件を満たすような移動を行って出発点に戻ってくることができません。

## 样例 #1

### 输入

```
4 4

1 2

2 3

3 4

4 2

0 1 0 1
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
5 6

1 2

2 3

3 4

4 5

1 4

2 5

0 1 0 1 0
```

### 输出

```
No
```



---


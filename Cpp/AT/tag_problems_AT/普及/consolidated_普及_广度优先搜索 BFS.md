---
title: "[ABC311D] Grid Ice Floor"
layout: "post"
diff: 普及/提高-
pid: AT_abc311_d
tag: ['广度优先搜索 BFS']
---

# [ABC311D] Grid Ice Floor

## 题目描述

有一个 $N \times M$ 的矩阵，并且有一个玩家站在上面。
其中 $(i, j)$ 表示矩阵的第 $i$ 行第 $j$ 列。
矩阵被表示为 $N$ 个字符串 $S_1 S_2S_3...S_N$，每个字符串长 $M$ 个字符。

矩阵每个格子都是冰或者岩石：如果 $S_i$ 的第 $j$ 个字符，即 $(i, j)$ 对应的字符为 `.`，那么 $(i, j)$ 是冰；如果是 `#`，$(i, j)$ 就是岩石。

这个矩阵的一周（第 $1$ 行、第 $N$ 行、第 $1$ 列，第 $M$ 列）均为岩石。
玩家起始所站的点 $(2, 2)$ 恒为冰。

玩家可以移动零次或任意次，每次移动需要先选定一个方向（上下左右），并且一直沿着这个方向移动直到遇到岩石（或不是冰）。

计算出玩家可以抵达或途径的所有格点（包括滑过的）。

## 输入格式

```
N M
S1
S2
...
SN
```
第一行两个正整数 $N$ 和 $M$，表示矩阵的长宽。
第二行到第 $N + 1$ 行，每行一个长 $M$ 的字符串，表示矩阵内容（代表矩阵内容的字符）。

## 输出格式

输出玩家能触及的格点数。

## 说明/提示

对于 $100\%$ 的数据：

$ 3 \le N, M \le 200 $

$S_i$ 是长为 $M$ 的字符串，仅包含 `.` 和 `#`。

矩阵的边缘都是 `#`（岩石），且 $(2,2)$ 处一定为 `.`（冰）。

#### 样例1解释
比如玩家可以经过 $(5,5)$ 通过这样移动：

$(2, 2)$ → $(5, 2)$ → $(5, 5)$

玩家也可以经过 $(2, 4)$：

$(2, 2)$ → $(2, 5)$，途经 $(2, 4)$。

但玩家无法到达 $(3, 4)$。

## 样例 #1

### 输入

```
6 6

######

#....#

#.#..#

#..#.#

#....#

######
```

### 输出

```
12
```

## 样例 #2

### 输入

```
21 25

#########################

#..............###...####

#..............#..#...###

#........###...#...#...##

#........#..#..#........#

#...##...#..#..#...#....#

#..#..#..###...#..#.....#

#..#..#..#..#..###......#

#..####..#..#...........#

#..#..#..###............#

#..#..#.................#

#........##.............#

#.......#..#............#

#..........#....#.......#

#........###...##....#..#

#..........#..#.#...##..#

#.......#..#....#..#.#..#

##.......##.....#....#..#

###.............#....#..#

####.................#..#

#########################
```

### 输出

```
215
```



---

---
title: "[ABC317E] Avoid Eye Contact"
layout: "post"
diff: 普及/提高-
pid: AT_abc317_e
tag: ['模拟', '广度优先搜索 BFS']
---

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ A_{1,1}A_{1,2}\dots\ A_{1,W} $ $ A_{2,1}A_{2,2}\dots\ A_{2,W} $ $ \vdots $ $ A_{H,1}A_{H,2}\dots\ A_{H,W} $

## 输出格式

ナオヒロ君が人の視線に一度も入らずにゴール地点に到達できる場合は、そのために必要な(最小の)移動回数を出力せよ。できない場合は `-1` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>
```

### 输出

```
15
```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G
```

### 输出

```
-1
```



---

---
title: "[ABC334E] Christmas Color Grid 1"
layout: "post"
diff: 普及/提高-
pid: AT_abc334_e
tag: ['枚举', '广度优先搜索 BFS']
---

# [ABC334E] Christmas Color Grid 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_e

**この問題は問題 G と似た設定です。問題文の相違点を赤字で示します。**

$ H $ 行 $ W $ 列のグリッドがあり、グリッドの各マスは赤色あるいは緑色に塗られています。

グリッドの上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,j) $ と表記します。

マス $ (i,j) $ の色は文字 $ S_{i,j} $ で表され、$ S_{i,j}\ = $ `.` のときマス $ (i,j) $ は赤色、$ S_{i,j}\ = $ `#` のときマス $ (i,j) $ は緑色に塗られています。

グリッドにおいて、緑色に塗られたマスを頂点集合、隣り合った $ 2 $ つの緑色のマスを結ぶ辺全体を辺集合としたグラフにおける連結成分の個数を **緑の連結成分数** と呼びます。ただし、$ 2 $ つのマス $ (x,y) $ と $ (x',y') $ が隣り合っているとは、$ |x-x'|\ +\ |y-y'|\ =\ 1 $ であることを指します。

**赤色**に塗られたマスを一様ランダムに $ 1 $ つ選び、**緑色**に塗り替えたとき、塗り替え後のグリッドの緑の連結成分数の期待値を $ \text{mod\ }\ 998244353 $ で出力してください。

  「期待値を $ \text{mod\ }\ 998244353 $ で出力」とは 求める期待値は必ず有理数となることが証明できます。 またこの問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、 $ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ $ 1 $ つ存在することが証明できます。この $ R $ を出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ S_{1,1} $$ S_{1,2} $$ \ldots $$ S_{1,W} $ $ S_{2,1} $$ S_{2,2} $$ \ldots $$ S_{2,W} $ $ \vdots $ $ S_{H,1} $$ S_{H,2} $$ \ldots $$ S_{H,W} $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 1000 $
- $ S_{i,j}\ = $ `.` または $ S_{i,j}\ = $ `#`
- $ S_{i,j}\ = $ `.` なる $ (i,j) $ が存在する。
 
### Sample Explanation 1

マス $ (1,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (2,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (3,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 マス $ (3,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 よって、赤色に塗られたマスを一様ランダムに $ 1 $ つ選び、緑色に塗り替えた後の緑の連結成分数の期待値は $ (1+1+2+2)/4\ =\ 3/2 $ となります。

## 样例 #1

### 输入

```
3 3

##.

#.#

#..
```

### 输出

```
499122178
```

## 样例 #2

### 输入

```
4 5

..#..

.###.

#####

..#..
```

### 输出

```
598946613
```

## 样例 #3

### 输入

```
3 4

#...

.#.#

..##
```

### 输出

```
285212675
```



---

---
title: "[ABC339D] Synchronized Players"
layout: "post"
diff: 普及/提高-
pid: AT_abc339_d
tag: ['搜索', '广度优先搜索 BFS']
---

# [ABC339D] Synchronized Players

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc339/tasks/abc339_d

$ N $ 行 $ N $ 列のグリッドがあり、各マスは空きマスか障害物のあるマスのいずれかです。グリッドの上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表記します。

また、$ 2 $ 人のプレイヤーがグリッド上の相異なる空きマス上におり、各マスの情報は $ N $ 個の長さ $ N $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_N $ として以下の形式で与えられます。

- $ S_i $ の $ j $ 文字目が `P` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいる
- $ S_i $ の $ j $ 文字目が `.` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいない
- $ S_i $ の $ j $ 文字目が `#` であるとき、$ (i,\ j) $ は障害物のあるマスである
 
以下の操作を繰り返し $ 2 $ 人のプレイヤーを同じマスに集めるために必要な操作回数の最小値を求めてください。ただし、操作の繰り返しにより $ 2 $ 人のプレイヤーを同じマスに集めることができない場合には `-1` を出力してください。

- 上下左右のいずれかの方向を決める。そして各プレイヤーはともにその方向に隣接するマスへの移動を試みる。各プレイヤーは移動先のマスが存在し、かつ空きマスであるならば移動し、そうでないならば移動しない。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_N $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ N $ は $ 2 $ 以上 $ 60 $ 以下の整数
- $ S_i $ は長さ $ N $ の `P`, `.`, `#` からなる文字列
- $ S_i $ の $ j $ 文字目が `P` であるような組 $ (i,\ j) $ の個数はちょうど $ 2 $ つ
 
### Sample Explanation 1

はじめに $ (3,\ 2) $ にいるプレイヤーをプレイヤー $ 1 $、$ (4,\ 3) $ にいるプレイヤーをプレイヤー $ 2 $ とします。 例えば以下のようにすることで、$ 3 $ 回の操作で $ 2 $ 人のプレイヤーが同じマスに集まります。 - 左を選択する。プレイヤー $ 1 $ は $ (3,\ 1) $ に移動し、プレイヤー $ 2 $ は $ (4,\ 2) $ に移動する。 - 上を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 2) $ に移動する。 - 左を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 1) $ に移動する。

## 样例 #1

### 输入

```
5

....#

#..#.

.P...

..P..

....#
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2

P#

#P
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
10

..........

..........

..........

..........

....P.....

.....P....

..........

..........

..........

..........
```

### 输出

```
10
```



---

---
title: "[ABC348D] Medicines on Grid"
layout: "post"
diff: 普及/提高-
pid: AT_abc348_d
tag: ['广度优先搜索 BFS']
---

# [ABC348D] Medicines on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc348/tasks/abc348_d

$ H $ 行 $ W $ 列のグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,\ j) $ と表します。各マスの状態は文字 $ A_{i,j} $ で表され、意味は以下の通りです。

- `.` : 空きマス。
- `#` : 障害物。
- `S` : 空きマスかつスタート地点。
- `T` : 空きマスかつゴール地点。
 
高橋君は、今いるマスから上下左右に隣り合う空きマスへ、エネルギーを $ 1 $ 消費して移動することができます。ただし、エネルギーが $ 0 $ の状態で移動することはできず、またグリッドの外へ移動することはできません。

グリッドには合計で $ N $ 個の薬があります。$ i $ 番目の薬は空きマス $ (R_i,\ C_i) $ にあり、使うとエネルギーを **$ E_i $ にする**ことができます。必ずしもエネルギーが増えるとは限らないことに注意してください。高橋君は自分のいるマスにある薬を使うことができます。使った薬はなくなります。

高橋君ははじめエネルギー $ 0 $ の状態でスタート地点にいて、ゴール地点まで移動したいです。これが可能かどうか判定してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ A_{1,\ 1} $$ A_{1,\ 2} $$ \cdots $$ A_{1,\ W} $ $ A_{2,\ 1} $$ A_{2,\ 2} $$ \cdots $$ A_{2,\ W} $ $ \vdots $ $ A_{H,\ 1} $$ A_{H,\ 2} $$ \cdots $$ A_{H,\ W} $ $ N $ $ R_1 $ $ C_1 $ $ E_1 $ $ R_2 $ $ C_2 $ $ E_2 $ $ \vdots $ $ R_N $ $ C_N $ $ E_N $

## 输出格式

高橋君がスタート地点からゴール地点へ移動することが可能なら `Yes` 、不可能なら `No` を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 200 $
- $ A_{i,\ j} $ は `.`, `#`, `S`, `T` のいずれかである。
- `S` と `T` は $ A_{i,\ j} $ にそれぞれちょうど $ 1 $ つ存在する。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ R_i\ \leq\ H $
- $ 1\ \leq\ C_i\ \leq\ W $
- $ i\ \neq\ j $ ならば $ (R_i,\ C_i)\ \neq\ (R_j,\ C_j) $
- $ A_{R_i,\ C_i} $ は `#` でない。
- $ 1\ \leq\ E_i\ \leq\ HW $
 
### Sample Explanation 1

例えば、以下のようにしてゴール地点へ移動することができます。 - 薬 $ 1 $ を使う。エネルギーが $ 3 $ になる。 - $ (1,\ 2) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (1,\ 3) $ へ移動する。エネルギーが $ 1 $ になる。 - 薬 $ 2 $ を使う。エネルギーが $ 5 $ になる。 - $ (2,\ 3) $ へ移動する。エネルギーが $ 4 $ になる。 - $ (3,\ 3) $ へ移動する。エネルギーが $ 3 $ になる。 - $ (3,\ 4) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (4,\ 4) $ へ移動する。エネルギーが $ 1 $ になる。 この移動の途中には $ (2,\ 3) $ にも薬がありますが、これを使うとゴールできません。

### Sample Explanation 2

高橋君はスタート地点から移動することができません。

## 样例 #1

### 输入

```
4 4

S...

#..#

#...

..#T

4

1 1 3

1 3 5

3 2 1

2 3 1
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
2 2

S.

T.

1

1 2 4
```

### 输出

```
No
```

## 样例 #3

### 输入

```
4 5

..#..

.S##.

.##T.

.....

3

3 1 5

1 2 3

2 2 1
```

### 输出

```
Yes
```



---

---
title: "[ABC351D] Grid and Magnet"
layout: "post"
diff: 普及/提高-
pid: AT_abc351_d
tag: ['搜索', '广度优先搜索 BFS', '深度优先搜索 DFS']
---

# [ABC351D] Grid and Magnet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_d

$ H $ 行 $ W $ 列のマス目があり、いくつか（$ 0 $ 個のこともある）のマスには磁石が置かれています。  
マス目の状態は $ H $ 個の 長さ $ W $ の文字列 $ S_1,S_2,\ldots,S_H $ で表され、 $ S_i $ の $ j $ 文字目が `#` のとき上から $ i $ 行目かつ左から $ j $ 列目のマスには磁石が置かれていることを、 `.` のとき何も置かれていないことを表しています。

高橋君は鉄の鎧を着ており、あるマスにいるとき次のように移動することができます。

- 現在いるマスの上下左右に隣り合うマスのいずれかに磁石が置かれているとき、どこへも移動することができない。
- そうでないとき、上下左右に隣り合うマスのいずれかを選んでそのマスに移動することができる。  
  ただし、マス目の外に移動することはできない。

磁石が置かれていない各マスについて、そのマスの自由度を、「最初高橋くんがそのマスにいるとき、そこから移動を繰り返して到達できるマスの個数」として定義します。 マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を求めてください。

ただし、自由度の定義において、「移動を繰り返して到達できるマス」とは、最初にいるマスからそのマスまで移動を繰り返して到達する方法（$ 1 $ 回も移動しないものも含む）が $ 1 $ つ以上存在するようなマスのことであり、 最初のマスから始めてすべてのそのようなマスを巡るような移動方法が存在する必要はありません。特に（磁石の置かれていない）各マス自身は、そのマスから「移動を繰り返して到達できるマス」につねに含まれることに注意してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_H $

## 输出格式

マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ H,W $ は整数
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列
- 磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。

### Sample Explanation 1

上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。

### Sample Explanation 2

磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。

## 样例 #1

### 输入

```
3 5
.#...
.....
.#..#
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3 3
..#
#..
..#
```

### 输出

```
1
```



---

---
title: "[ABC361D] Go Stone Puzzle"
layout: "post"
diff: 普及/提高-
pid: AT_abc361_d
tag: ['广度优先搜索 BFS']
---

# [ABC361D] Go Stone Puzzle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_d

$ N+2 $ 個のマスが横一列に並んでいます。左から $ i $ 番目のマスをマス $ i $ と表します。

マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれています。  
 各 $ 1\leq\ i\ \leq\ N $ について、$ S_i $ が `W` のときマス $ i $ に置かれている石の色は白であり、$ S_i $ が `B` のときマス $ i $ に置かれている石の色は黒です。  
 マス $ N+1,N+2 $ には何も置かれていません。

あなたは以下の操作を好きな回数($ 0 $ 回でもよい)行うことができます。

- 石が $ 2 $ 個並んでいる箇所を選び、その $ 2 $ 個の石を順序を保って空きマスに移す。  
   より正確には次の通り。$ 1 $ 以上 $ N+1 $ 以下の整数 $ x $ であって、マス $ x,x+1 $ の両方に石が置かれているものを選ぶ。石の置かれていないマスを $ k,k+1 $ とする。マス $ x,x+1 $ にある石をそれぞれマス $ k,k+1 $ に移動する。
 
以下の状態にすることが可能か判定し、可能なら操作回数の最小値を求めてください。

- マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれており、各 $ 1\leq\ i\ \leq\ N $ について、$ T_i $ が `W` のときマス $ i $ に置かれている石の色は白、$ T_i $ が `B` のときマス $ i $ に置かれている石の色は黒である。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $ $ T $

## 输出格式

目的の状態にすることが可能なら操作回数の最小値を出力せよ。不可能ならかわりに `-1` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 14 $
- $ N $ は整数である
- $ S,T $ は `B` および `W` のみからなる長さ $ N $ の文字列である
 
### Sample Explanation 1

石が置かれていないマスを `.` と表します。以下のようにして $ 4 $ 回の操作で目的の状態にすることができ、これが最小回数です。 - `BWBWBW..` - `BW..BWBW` - `BWWBB..W` - `..WBBBWW` - `WWWBBB..`

## 样例 #1

### 输入

```
6

BWBWBW

WWWBBB
```

### 输出

```
4
```

## 样例 #2

### 输入

```
6

BBBBBB

WWWWWW
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
14

BBBWBWWWBBWWBW

WBWWBBWWWBWBBB
```

### 输出

```
7
```



---

---
title: "[ABC363E] Sinking Land"
layout: "post"
diff: 普及/提高-
pid: AT_abc363_e
tag: ['广度优先搜索 BFS']
---

# [ABC363E] Sinking Land

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_e

$ H\ \times\ W $ の大きさの島があり、島は周りを海で囲まれています。  
 島は 縦 $ H $ 個 $ \times $ 横 $ W $ 個の $ 1\times\ 1 $ の区画に分けられており、上から $ i $ 番目かつ左から $ j $ 番目の区画の（現在の海面を基準にした）標高は $ A_{i,j} $ です。

現在から $ 1 $ 年ごとに海面の高さが $ 1 $ ずつ上昇します。  
 このとき、海または海に沈んだ区画に上下左右に隣接する区画であって、標高が海面の高さ **以下** の区画は海に沈みます。  
 ここで、ある区画が新しく海に沈んだときそれと上下左右に隣接する区画であって海面の高さ以下のものも同時に海に沈み、これによって新しく沈んだ区画についてもこれは繰り返されます。

$ i=1,2,\ldots,\ Y $ それぞれについて、現在から $ i $ 年後に、島のうち海に沈まず残っている部分の面積を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ Y $ $ A_{1,1} $ $ A_{1,2} $ $ \ldots $ $ A_{1,W} $ $ A_{2,1} $ $ A_{2,2} $ $ \ldots $ $ A_{2,W} $ $ \vdots $ $ A_{H,1} $ $ A_{H,2} $ $ \ldots $ $ A_{H,W} $

## 输出格式

$ Y $ 行出力せよ。 $ i $ 行目 $ (1\leq\ i\leq\ Y) $ には現在から $ i $ 年後に海に沈まず残っている島の面積を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ 1\leq\ Y\leq\ 10^5 $
- $ 1\leq\ A_{i,j}\leq\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

島の上から $ i $ 番目かつ左から $ j $ 番目の区画を $ (i,j) $ で表します。このとき、次のようになります。 - $ 1 $ 年後、海面は現在より $ 1 $ 上昇しますが、海に面している標高 $ 1 $ の区画は存在しないため、どの区画も沈みません。よって、$ 1 $ 行目には $ 9 $ を出力します。 - $ 2 $ 年後、海面は現在より $ 2 $ 上昇し、$ (1,2) $ が海に沈みます。これによって、$ (2,2) $ は海に沈んだ区画に隣接する区画となりますが、その標高は $ 2 $ 以下であるため、これも海に沈みます。これら以外にこの時点で他に沈む区画はありません。よって、$ 2 $ つの区画が沈むため、$ 2 $ 行目には $ 9-2=7 $ を出力します。 - $ 3 $ 年後、海面は現在より $ 3 $ 上昇し、$ (2,1) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 3 $ 行目には $ 6 $ を出力します。 - $ 4 $ 年後、海面は現在より $ 4 $ 上昇し、$ (2,3) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 4 $ 行目には $ 5 $ を出力します。 - $ 5 $ 年後、海面は現在より $ 5 $ 上昇し、$ (3,2) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 5 $ 行目には $ 4 $ を出力します。 よって、$ 9,7,6,5,4 $ をこの順に各行に出力します。

## 样例 #1

### 输入

```
3 3 5

10 2 10

3 1 4

10 5 10
```

### 输出

```
9

7

6

5

4
```

## 样例 #2

### 输入

```
3 5 3

2 2 3 3 3

2 1 2 1 3

2 2 3 3 3
```

### 输出

```
15

7

0
```



---

---
title: "[ABC376D] Cycle"
layout: "post"
diff: 普及/提高-
pid: AT_abc376_d
tag: ['搜索', '广度优先搜索 BFS', '图遍历']
---

# [ABC376D] Cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点 $ M $ 辺の単純有向グラフがあります。$ i $ 番目の辺 $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ a_i $ から頂点 $ b_i $ へ伸びる辺です。  
 頂点 $ 1 $ を含む閉路が存在するか判定して、存在する場合はそのような閉路のうち辺数が最小の閉路の辺数を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ $ \vdots $ $ a_M $ $ b_M $

## 输出格式

頂点 $ 1 $ を含む閉路が存在する場合は、そのような閉路のうち辺数が最小の閉路の辺数を出力せよ。そうでない場合は `-1` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\ \left(\ \frac{N(N-1)}{2},\ 2\ \times\ 10^5\ \right) $
- $ 1\ \leq\ a_i\ \leq\ N $
- $ 1\ \leq\ b_i\ \leq\ N $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ かつ $ (a_i,\ b_i)\ \neq\ (b_j,\ a_j) $
- 入力される値は全て整数
 
### Sample Explanation 1

頂点 $ 1 $ $ \to $ 頂点 $ 2 $ $ \to $ 頂点 $ 3 $ $ \to $ 頂点 $ 1 $ は辺数が $ 3 $ の閉路で、これが頂点 $ 1 $ を含む唯一の閉路です。

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 2

1 2

2 3
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
6 9

6 1

1 5

2 6

2 1

3 6

4 2

6 4

3 5

5 4
```

### 输出

```
4
```



---

---
title: "[ABC384E] Takahashi is Slime 2"
layout: "post"
diff: 普及/提高-
pid: AT_abc384_e
tag: ['贪心', '广度优先搜索 BFS', '优先队列']
---

# [ABC384E] Takahashi is Slime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_e

縦 $ H $ 行横 $ W $ 列のマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ H) $、左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ と呼ぶことにします。

はじめ、マス $ (i,j) $ には強さ $ S\ _\ {i,j} $ のスライムがおり、マス $ (P,Q) $ にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（$ 0 $ 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

- 高橋くんに隣接するスライムのうち、強さが高橋くんの強さの $ \dfrac1X $ 倍**未満**のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
 
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ X $
>
>$ P $ $ Q $
>
>$ S_{1,1} $ $ S_{1,2} $ $ \ldots $ $ S_{1,W} $
>
> $ S_{2,1} $ $ S_{2,2} $ $ \ldots $ $ S_{2,W} $
>
> $ \vdots $
>
>$ S_{H,1} $ $ S_{H,2} $ $ \ldots $ $ S_{H,W} $

## 输出格式

高橋くんが行動を行ったあとの高橋くんの強さとしてありえる最大値を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq500 $
- $ 1\leq\ P\leq\ H $
- $ 1\leq\ Q\leq\ W $
- $ 1\leq\ X\leq10^9 $
- $ 1\leq\ S_{i,j}\leq10^{12} $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。 
![](https://img.atcoder.jp/abc384/6b3d3bbde4767c7f5070ad0b1f202043.png) 例えば、高橋くんは次のように行動を行うことができます。 
![](https://img.atcoder.jp/abc384/81c0ccdba241277bf0cdd16ae6a7c54d.png) - マス $ (2,1) $ にいるスライムを吸収する。高橋くんの強さは $ 9+4=13 $ となり、新たにマス $ (1,1) $ のスライムとマス $ (3,1) $ のスライムが高橋くんと隣接する。 - マス $ (1,2) $ にいるスライムを吸収する。高橋くんの強さは $ 13+6=19 $ となり、新たにマス $ (1,3) $ のスライムが高橋くんと隣接する。 - マス $ (1,3) $ にいるスライムを吸収する。高橋くんの強さは $ 19+9=28 $ となる。 以上の行動を行ったあと、高橋くんの強さは $ 28 $ となります。 高橋くんがどのように行動を行っても、高橋くんの強さを $ 28 $ より大きくすることはできないため、`28` を出力してください。 高橋くんの強さの $ \dfrac12 $ 倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス $ (1,1) $ にいるスライムを吸収することはできません。

### Sample Explanation 2

高橋くんはどのスライムも吸収できません。

## 样例 #1

### 输入

```
3 3 2

2 2

14 6 9

4 9 20

17 15 7
```

### 输出

```
28
```

## 样例 #2

### 输入

```
3 4 1

1 1

5 10 1 1

10 1 1 1

1 1 1 1
```

### 输出

```
5
```

## 样例 #3

### 输入

```
8 10 2

1 5

388 130 971 202 487 924 247 286 237 316

117 166 918 106 336 928 493 391 235 398

124 280 425 955 212 988 227 222 307 226

336 302 478 246 950 368 291 236 170 101

370 200 204 141 287 410 388 314 205 460

291 104 348 337 404 399 416 263 415 339

105 420 302 334 231 481 466 366 401 452

119 432 292 403 371 417 351 231 482 184
```

### 输出

```
1343
```



---

---
title: "[ABC400D] Takahashi the Wall Breaker"
layout: "post"
diff: 普及/提高-
pid: AT_abc400_d
tag: ['图论', '广度优先搜索 BFS', '最短路']
---

# [ABC400D] Takahashi the Wall Breaker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc400/tasks/abc400_d

高桥君想去鱼店买鳗鱼。

高桥君居住的城镇由 $H$ 行 $W$ 列的网格状区域构成，每个区域是道路或墙壁。  
以下，将从上往下第 $i$ 行（$1 \leq i \leq H$）、从左往右第 $j$ 列（$1 \leq j \leq W$）的区域表示为区域 $(i, j)$。  
各区域的信息由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 给出。具体来说，当 $S_i$ 的第 $j$ 个字符（$1 \leq i \leq H$，$1 \leq j \leq W$）为 `.` 时，区域 $(i, j)$ 是道路；当为 `#` 时，区域 $(i, j)$ 是墙壁。

高桥君可以按任意顺序重复执行以下两种操作：

- 移动到上下左右相邻的、位于城镇内且为道路的区域。
- 选择一个上下左右方向，进行**前踢**。  
  当高桥君进行前踢时，可以将当前区域在该方向上 **前 1 格** 和 **前 2 格** 的区域（如果它们是墙壁）变为道路。  
  注意：即使前 1 格或前 2 格位于城镇外，仍然可以进行前踢操作，但城镇外的区域不会发生变化。

高桥君最初位于区域 $(A, B)$，想要到达位于区域 $(C, D)$ 的鱼店。  
保证高桥君初始所在的区域及鱼店所在的区域是道路。  
请计算高桥君到达鱼店所需的最小**前踢次数**。

## 输入格式

输入通过标准输入给出，格式如下：

> $H$ $W$  
> $S_1$  
> $S_2$  
> $\vdots$  
> $S_H$  
> $A$ $B$ $C$ $D$

## 输出格式

输出高桥君到达鱼店所需的最小**前踢次数**。


## 说明/提示

### 约束条件

- $1 \leq H \leq 1000$
- $1 \leq W \leq 1000$
- $S_i$ 是仅由 `.` 和 `#` 组成的长度为 $W$ 的字符串
- $1 \leq A, C \leq H$
- $1 \leq B, D \leq W$
- $(A, B) \neq (C, D)$
- $H, W, A, B, C, D$ 均为整数
- 高桥君初始所在的区域及鱼店所在的区域保证是道路

### 样例解释 1

高桥君最初位于区域 $(1, 1)$。通过反复移动到道路区域，可以到达区域 $(7, 4)$。在区域 $(7, 4)$ 向左方向进行前踢后，区域 $(7, 3)$ 和 $(7, 2)$ 会从墙壁变为道路。之后，通过反复移动（包括新变为道路的区域）即可到达位于区域 $(7, 1)$ 的鱼店。此时前踢次数为 $1$ 次，且无法在不使用前踢的情况下到达鱼店，因此输出 $1$。

### 样例解释 2

高桥君最初位于区域 $(1, 1)$。向右方向进行前踢后，区域 $(1, 2)$ 会从墙壁变为道路（向右前 2 格超出城镇范围，因此无变化）。之后可以从区域 $(1, 1)$ 移动到区域 $(1, 2)$，再到达区域 $(2, 2)$ 的鱼店。此时前踢次数为 $1$ 次，且无法在不使用前踢的情况下到达鱼店，因此输出 $1$。

### 样例解释 3

前踢操作可能影响包含鱼店所在区域的区画，但鱼店所在区域原本就是道路，因此不会发生变化。特别是前踢操作不会破坏鱼店。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
10 10

..........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

.##.#.#.#.

###.#.#.#.

###.#.#.#.

#.....#...

1 1 7 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 2

.#

#.

1 1 2 2
```

### 输出

```
1
```

## 样例 #3

### 输入

```
1 3

.#.

1 1 1 3
```

### 输出

```
1
```

## 样例 #4

### 输入

```
20 20

####################

##...##....###...###

#.....#.....#.....##

#..#..#..#..#..#..##

#..#..#....##..#####

#.....#.....#..#####

#.....#..#..#..#..##

#..#..#.....#.....##

#..#..#....###...###

####################

####################

##..#..##...###...##

##..#..#.....#.....#

##..#..#..#..#..#..#

##..#..#..#..#..#..#

##.....#..#..#..#..#

###....#..#..#..#..#

#####..#.....#.....#

#####..##...###...##

####################

3 3 18 18
```

### 输出

```
3
```



---

---
title: "[ABC405D] Escape Route"
layout: "post"
diff: 普及/提高-
pid: AT_abc405_d
tag: ['广度优先搜索 BFS']
---

# [ABC405D] Escape Route

## 题目描述

高桥去到了电影院。在电影院的地面上，每块瓷砖上都画有指向最近的安全出口的箭头。

给你一个 $H$ 行 $W$ 列的网格 $S$，其中 `.` 表示空白地面，`#` 表示不可穿过的墙，`E` 表示安全出口。

在一个空白格子，你可以用一步移动到相邻的非墙格子。两个格子相邻当且仅当它们有公共的边。

令从一个空白格子 $(i,j)$ 移动到任意一个安全出口需要的最小步数为 $d(i,j)$。\
你需要在所有空白的格子上画上箭头（指向上下左右中的一个），使得从每一个空白格子 $(i,j)$ 开始，每次向当前所在格子的箭头方向走一步，恰好 $d(i,j)$ 步后将到达安全出口。

**数据保证每一个空白格子都可以到达至少一个安全出口。**

## 输入格式

第一行两个整数 $H,W(2\le H,W\le 1000)$。\
接下来 $H$ 行，每行一个长度为 $W$ 的字符串，构成网格 $S$。

数据保证每一个空白格子都可以到达至少一个安全出口。

## 输出格式

输出在所有空白格子填上箭头后的 $S$。你要用 `^` 表示向上的箭头，`v` 表示向下的箭头，`<` 表示向左的箭头，`>` 表示向右的箭头。

## 说明/提示

**样例 1 解释**

在样例输出中，$d(2,3)=2$，并且沿着箭头格子 $(2,3)$ 需要恰好 $2$ 步到达安全出口。

其他所有空白格子也满足像这样的条件。

**样例 2 解释**

存在没有空白格子或安全出口的情况。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
3 4
...E
.#..
....
```

### 输出

```
>>>E
^#>^
>>>^
```

## 样例 #2

### 输入

```
3 2
##
##
##
```

### 输出

```
##
##
##
```

## 样例 #3

### 输入

```
7 20
....................
..#..#..####..#E##..
..#..#..#..#..#.....
..E###..#..#..####..
.....#..#..E.....#..
.....#..####..####..
....................
```

### 输出

```
>v<<<<<>>>>>>>>v<<<<
>v#^<#^^####v^#E##vv
>v#^<#v^#>v#vv#^<<<<
>>E###vv#>v#vv####^<
>>^<<#vv#>>E<<<<<#^<
>>^<<#vv####^<####^<
>>^<<<<<>>>>^<<<<<^<
```



---

---
title: "[ABC410D] XOR Shortest Walk"
layout: "post"
diff: 普及/提高-
pid: AT_abc410_d
tag: ['图论', '广度优先搜索 BFS', '记忆化搜索']
---

# [ABC410D] XOR Shortest Walk

## 题目描述

给你一个 $N$ 条边 $M$ 条边的有向图，第 $i$ 条边从结点 $A_i$ 连向结点 $B_i$，权值为 $W_i$。

求所有从 $1$ 到 $N$ 的路径中，可以重复经过同一个点和同一条边，路径上所有边权值的异或和的最小值。

## 输入格式

第一行两个整数 $N,M(2\le N\le 1000,0\le M\le 1000)$。\
接下来 $M$ 行，每行三个整数 $A_i,B_i,W_i(0\le W_i<2^{10})$。

## 输出格式

如果不存在 $1$ 到 $N$ 的路径，输出一行一个整数 $-1$。

否则，输出一行一个整数表示答案。

## 说明/提示

**样例 1 解释**

路径(边 $1$，边 $2$) 的边权异或和为 $1$。

**样例 2 解释**

路径(边 $1$，边 $2$，边 $3$，边 $4$) 的边权异或和为 $0$。

注意 $N$ 可能出现在路径的中间。

**样例 3 解释**

如果不存在 $1$ 到 $N$ 的路径，输出 $-1$。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
3 3

1 2 4

2 3 5

1 3 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 4

1 4 7

4 2 2

2 3 4

3 4 1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
999 4

1 2 9

2 1 8

1 2 7

1 1 6
```

### 输出

```
-1
```



---

---
title: "[AGC033A] Darker and Darker"
layout: "post"
diff: 普及/提高-
pid: AT_agc033_a
tag: ['广度优先搜索 BFS']
---

# [AGC033A] Darker and Darker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc033/tasks/agc033_a

縦 $ H $ 行、横 $ W $ 列の白黒に塗られたマス目が与えられます。 マス目の状態は $ A_{11} $ から $ A_{HW} $ の $ HW $ 個の文字で表されており、 上から $ i $ 行目、左から $ j $ 列目にあるマスが黒色のとき $ A_{ij} $ は `#`、 上から $ i $ 行目、左から $ j $ 列目にあるマスが白色のとき $ A_{ij} $ は `.` となっています。

すべてのマスが黒色になるまで、以下の操作を繰り返し行います。

- 辺を共有して隣接するマスの中に、黒色のマスが一つ以上存在するような白色のマスすべてが黒色になる。

何回の操作を行うことになるか求めてください。 ただし、最初に与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在します。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ A_{11} $$ A_{12} $$ ... $$ A_{1W} $ $ : $ $ A_{H1} $$ A_{H2} $$ ... $$ A_{HW} $

## 输出格式

行われる操作の回数を出力せよ。

## 说明/提示

### 制約

- $ 1\ ≦\ H,W\ ≦\ 1000 $
- $ A_{ij} $ は `#` または `.`
- 与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在する。

### Sample Explanation 1

操作を一回行うとマス目の四隅以外が黒色になり、もう一度操作を行うとすべてのマス目が黒色になります。

## 样例 #1

### 输入

```
3 3

...

.#.

...
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 6

..#..#

......

#..#..

......

.#....

....#.
```

### 输出

```
3
```



---

---
title: "[AGC043A] Range Flip Find Route"
layout: "post"
diff: 普及/提高-
pid: AT_agc043_a
tag: ['动态规划 DP', '广度优先搜索 BFS']
---

# [AGC043A] Range Flip Find Route

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc043/tasks/agc043_a

$ H $ 行 $ W $ 列のマス目を考えます。上から $ r $ 番目、左から $ c $ 番目のマスを $ (r,\ c) $ と表すことにします。 全てのマスはそれぞれ白か黒のどちらかの色に塗られています。

次のような経路が存在するとき、このマス目を"良い"状態と呼びます。

- 常に白いマスの上にいながら、$ (1,\ 1) $ から、一つ **右か下** のマスに移動することを繰り返し、 $ (H,\ W) $ へ移動する。

ここで、"良い"状態ならば $ (1,\ 1) $ や $ (H,\ W) $ が必ず白いことに注意してください。

あなたの仕事は、以下の操作を繰り返し、マス目を"良い"状態にすることです。最小で何回操作を行う必要があるか求めてください。なお、有限回の操作で必ず"良い"状態に出来ることが証明可能です。

- $ 4 $ つの整数 $ r_0,\ c_0,\ r_1,\ c_1(1\ \leq\ r_0\ \leq\ r_1\ \leq\ H,\ 1\ \leq\ c_0\ \leq\ c_1\ \leq\ W) $ を選ぶ。$ r_0\ \leq\ r\ \leq\ r_1,\ c_0\ \leq\ c\ \leq\ c_1 $ を満たす全ての $ r,\ c $ について、$ (r,\ c) $ の色を変更する。つまり、白色ならば黒色にし、黒色ならば白色にする。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ s_{11}\ s_{12}\ \cdots\ s_{1W} $ $ s_{21}\ s_{22}\ \cdots\ s_{2W} $ $ \vdots $ $ s_{H1}\ s_{H2}\ \cdots\ s_{HW} $

ここで、$ s_{rc} $ は `#` か `.` であり、`#` は $ (r,\ c) $ が黒色、`.` は白色であることを表す。

## 输出格式

最小の操作回数を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 100 $

### Sample Explanation 1

$ (r_0,\ c_0,\ r_1,\ c_1)\ =\ (2,\ 2,\ 2,\ 2) $、つまりマス $ (2,\ 2) $ のみ色を変更すれば良いです。

### Sample Explanation 3

操作が必要ない場合も存在します。

## 样例 #1

### 输入

```
3 3

.##

.#.

##.
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 2

#.

.#
```

### 输出

```
2
```

## 样例 #3

### 输入

```
4 4

..##

#...

###.

###.
```

### 输出

```
0
```

## 样例 #4

### 输入

```
5 5

.#.#.

#.#.#

.#.#.

#.#.#

.#.#.
```

### 输出

```
4
```



---

---
title: "[ARC177C] Routing"
layout: "post"
diff: 普及/提高-
pid: AT_arc177_c
tag: ['广度优先搜索 BFS', '最短路']
---

# [ARC177C] Routing

## 题目描述

有一个 $N$ 行 $N$ 列（用 $(i, j)$ 表示矩阵第 $i$ 行第 $j$ 列的元素）的矩阵被刷满了红色和蓝色。现在要矩阵的一些格子刷上紫色，使得矩阵**同时**满足以下两个条件：
- 从 $(1, 1)$ 走到 $(N, N)$，保证存在一条路径使其只经过红色和紫色；
- 从 $(1, N)$ 走到 $(N, 1)$，保证存在一条路径使其只经过蓝色和紫色

注意，**行动时他可以往任何一个方向前进。**

那么，问题来了，至少要将多少格子刷成紫色才能使以上两个条件成立呢？

## 输入格式

输入共 $N+1$ 行。

第一行，读入 $N$;

接下来 $N$ 行，读入这个矩阵。其中以 `R`  代表红色，以 `B` 代表蓝色。

## 输出格式

输出仅一行，为最少刷成紫色的格子数。

**【约定】**

- $ 3\ \leq\ N\ \leq\ 500 $；
- 保证任意一个格子一定为 `R` 或 `B` 中的一个；
- 保证 $(1, 1)$ 和 $(N, N)$ 为红色；
- 保证 $(1, N)$ 和 $(N, 1)$ 为蓝色；
- 保证 $N$ 是一个整数。

**【样例解释】**

【样例 $1$ 解释】  
如下图，将 $ (1, 3),(3, 2),(4, 5) $ 三个格子刷成紫色可以达成目标。
![](https://cdn.luogu.com.cn/upload/image_hosting/zu2dn557.png)

【样例 $2$ 解释】  
如下图，将 $ (1, 2), (2, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5) $ 这 $7$ 个格子刷成紫色可以达成目标。
![](https://cdn.luogu.com.cn/upload/image_hosting/290k2d8o.png)

## 样例 #1

### 输入

```
5

RBRBB

RBRRR

RRRBR

RBBRB

BBRBR
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5

RBBBB

BBBBB

BBBBB

BBBBB

BBBBR
```

### 输出

```
7
```

## 样例 #3

### 输入

```
10

RRBBBBBBBB

BRRBBBBBBB

BBRRBBBBBB

BBBRRBBBBB

BBBBRRBBBB

BBBBBRRBBB

BBBBBBRRBB

BBBBBBBRRB

BBBBBBBBRR

BBBBBBBBBR
```

### 输出

```
2
```

## 样例 #4

### 输入

```
17

RBBRRBRRRRRBBBBBB

BBRBRBRRBRRBRRBBR

BRBRBBBRBBRBBRBBB

RBRRBBBBBBRRBRRRR

RRRRRBRBRRRBBRBBR

RRRRRBRRBRBBRRRBB

BBBRRRBRBRBBRRRBB

BBRRRBRBBBRBRRRBR

RRBBBBBBBBBBBRBRR

RRRBRRBRBRBRBRBBB

RRBRRRRBRBRRBRBBR

RRRBBRBRBBBRBBRBR

BBRBBRRBRRRBBRBBB

BBBRBRRRRRRRBBRBB

RRRRRBRBRBBRRBRRR

BRRRRBBBRRRBRRBBB

BBRRBBRRRBBBRBBBR
```

### 输出

```
8
```



---

---
title: "停止問題"
layout: "post"
diff: 普及/提高-
pid: AT_utpc2011_4
tag: ['模拟', '广度优先搜索 BFS', '深度优先搜索 DFS']
---

# 停止問題

## 题目描述

Defunge 程序由一个 $R$ 行 $C$ 列的字符数组组成。下面是一个 Defunge 程序的例子：

```plain
6>--v.
.^--_@
```

Defunge 程序从程序的左上角（即第一行第一列）开始执行。**它的执行方向一开始为"右"**，每次朝着执行方向走一步，**如果走出界了，要跳到另一边**。每走到一个格子上，就要执行这个格子上的命令。 Defunge 程序还有一个存储器，这个存储器只能存储 $[0,15]$ 的一个整数，**存储器一开始存储** $\bold{0}$。

在 Defunge 程序中，有且只有 $11+10=21$ 种命令，下面是它们各自的含义：

- `<`：把执行方向设置为"左"。
- `>`：把执行方向设置为"右"。
- `^`：把执行方向设置为"上"。
- `v`：把执行方向设置为"下"。
- `_`：如果存储器存储的数字是 $0$，就把执行方向设置为"右"，否则设置为"左"。
- `|`：如果存储器存储的数字是 $0$，就把执行方向设置为"下"，否则设置为"上"。
- `?`：把执行方向设置为"上下左右"中的**任意**一个（类似于 dfs 把四个方向全搜一遍）。
- `.`：什么也不做。
- `@`：停止程序。
- `0`-`9`：把存储器设置为这个字符表示的数值。
- `+`：让存储器的数值加 $1$。注意当存储器的数值为 $15$ 时要把它设为 $0$。
- `-`：让存储器的数值减 $1$。注意当存储器的数值为 $0$ 时要把它设为 $15$。

现在，给你一个 Defunge 程序，请判断这个程序是否能停止（即执行到命令`@`）。如果能，输出`YES`，否则输出`NO`。

## 输入格式

第一行两个正整数 $R,C$，表示这个 Defunge 程序有 $R$ 行 $C$ 列。

接下来 $R$ 行，每行有 $C$ 个字符，描述这个 Defunge 程序。

## 输出格式

一行字符串`YES`或`NO`，表示这个程序是否能停止。

【样例】

样例输入 $1$：

```plain
2 6
6>--v.
.^--_@
```

样例输出 $1$：

```plain
YES
```

样例输入 $2$：

```plain
2 6
5>--v.
.^--_@
```

样例输出 $2$：

```plain
NO
```

样例输入 $3$：

```plain
2 6
.>--v.
.^--?@
```

样例输出 $3$：

```plain
YES
```

## 说明/提示

$1\leq R,C\leq 20$，保证程序里只有上文提到的 $21$ 种命令。



---


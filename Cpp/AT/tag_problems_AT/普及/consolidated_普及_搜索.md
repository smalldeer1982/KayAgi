---
title: "[ABC007C] 幅優先探索"
layout: "post"
diff: 普及/提高-
pid: AT_abc007_3
tag: ['搜索']
---

# [ABC007C] 幅優先探索

## 题目描述

一个大小为 $n\times m$ 的迷宫，你可以往上下左右任意方向移动 $1$ 步，求最少需要多少步才能走出迷宫。

迷宫中 `.` 表示空地，`#` 表示墙壁，移动中只能穿过空地，不能穿墙。

## 输入格式

第 $1$ 行 $2$ 个正整数 $n, m$，表示迷宫有 $n$ 行 $m$ 列；

第 $2$ 行 $2$ 个正整数 $sy,sx$，表示起点坐标 $(sy,sx)$;

第 $3$ 行 $2$ 个正整数 $gy,gx$，表示终点坐标 $(gy,gx)$;

第 $4$ 至 $n+1$ 行，表示迷宫的俯视图

## 输出格式

输出最少需要多少步才能走出迷宫。（题目保证有解）

## 说明/提示

对于 $100\%$ 的数据，$1\le n, m\le50$，$sy, gy\le n$，$sx,gx\le m$。

## 样例 #1

### 输入

```
7 8

2 2

4 5

########

#......#

#.######

#..#...#

#..##..#

##.....#

########
```

### 输出

```
11
```

## 样例 #2

### 输入

```
5 8

2 2

2 4

########

#.#....#

#.###..#

#......#

########
```

### 输出

```
10
```

## 样例 #3

### 输入

```
50 50

2 2

49 49

##################################################

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

#................................................#

##################################################
```

### 输出

```
94
```



---

---
title: "[ABC029D] 1"
layout: "post"
diff: 普及/提高-
pid: AT_abc029_d
tag: ['搜索', '深度优先搜索 DFS', '数位 DP']
---

# [ABC029D] 1

## 题目描述

高桥先生用十进制标记一次性地在纸上写了  $1$ ~ $N$  以下的所有整数。 在这项工作中，高桥君写了几个  $1$  这样的数字呢？即求从 
 $1$ ~ $N$  中数字  $1$  出现的次数。（本题类似 P1980）

## 输出格式

说明： 对于  $20\%$  的数据，有  $1 \leq N \leq 999$ 。

对于  $100\%$  的数据，有  $1 \leq N \leq 10^9$ 。

感谢@初音Miku 提供的翻译

## 样例 #1

### 输入

```
12
```

### 输出

```
5
```

## 样例 #2

### 输入

```
345
```

### 输出

```
175
```

## 样例 #3

### 输入

```
999999999
```

### 输出

```
900000000
```



---

---
title: "[ABC057C] Digits in Multiplication"
layout: "post"
diff: 普及/提高-
pid: AT_abc057_c
tag: ['模拟', '字符串', '搜索']
---

# [ABC057C] Digits in Multiplication

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc057/tasks/abc057_c

整数 $ N $ が与えられます。   
 ここで、$ 2 $ つの正の整数 $ A,B $ に対して、$ F(A,B) $ を「$ 10 $ 進表記における、$ A $ の桁数と $ B $ の桁数のうち大きい方」と定義します。   
 例えば、$ F(3,11) $ の値は、$ 3 $ は $ 1 $ 桁、$ 11 $ は $ 2 $ 桁であるため、$ F(3,11)=2 $ となります。   
 $ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くとき、$ F(A,B) $ の最小値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $

## 输出格式

$ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くときの $ F(A,B) $ の最小値を出力せよ。

## 说明/提示

### 制約

- $ 1≦N≦10^{10} $
- $ N $ は整数である。

### Sample Explanation 1

$ (A,B)=(100,100) $ のときに $ F(A,B) $ は最小値をとるため、$ F(100,100)=3 $ を出力します。

### Sample Explanation 2

条件を満たす $ (A,B) $ の組は $ (1,1000003) $ と $ (1000003,1) $ の $ 2 $ 通りで、$ F(1,1000003)=F(1000003,1)=7 $ です。

## 样例 #1

### 输入

```
10000
```

### 输出

```
3
```

## 样例 #2

### 输入

```
1000003
```

### 输出

```
7
```

## 样例 #3

### 输入

```
9876543210
```

### 输出

```
6
```



---

---
title: "[ABC114C] 755"
layout: "post"
diff: 普及/提高-
pid: AT_abc114_c
tag: ['搜索']
---

# [ABC114C] 755

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc114/tasks/abc114_c

整数 $ N $ が与えられます。$ 1 $ 以上 $ N $ 以下の整数のうち、*七五三数* は何個あるでしょうか？

ここで、七五三数とは以下の条件を満たす正の整数です。

- 十進法で表記したとき、数字 `7`, `5`, `3` がそれぞれ $ 1 $ 回以上現れ、これら以外の数字は現れない。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $

## 输出格式

$ 1 $ 以上 $ N $ 以下の七五三数の個数を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N $
- $ N $ は整数である。

### Sample Explanation 1

$ 575 $ 以下の七五三数は、$ 357,\ 375,\ 537,\ 573 $ の $ 4 $ 個です。

### Sample Explanation 2

$ 3600 $ 以下の七五三数は、上記の $ 4 $ 個と $ 735,\ 753,\ 3357,\ 3375,\ 3537,\ 3557,\ 3573,\ 3575,\ 3577 $ の計 $ 13 $ 個です。

## 样例 #1

### 输入

```
575
```

### 输出

```
4
```

## 样例 #2

### 输入

```
3600
```

### 输出

```
13
```

## 样例 #3

### 输入

```
999999999
```

### 输出

```
26484
```



---

---
title: "[ABC126E] 1 or 2"
layout: "post"
diff: 普及/提高-
pid: AT_abc126_e
tag: ['图论', '并查集', '深度优先搜索 DFS', '连通块']
---

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ X_1 $ $ Y_1 $ $ Z_1 $ $ X_2 $ $ Y_2 $ $ Z_2 $ $ \vdots $ $ X_M $ $ Y_M $ $ Z_M $

## 输出格式

$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てるために払う必要のあるコストの合計の最小値を出力せよ。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
100000 1

1 100000 100
```

### 输出

```
99999
```



---

---
title: "[ABC311D] Grid Ice Floor"
layout: "post"
diff: 普及/提高-
pid: AT_abc311_d
tag: ['广度优先搜索 BFS']
---

# [ABC311D] Grid Ice Floor

## 题目描述

有一个 $N \times M$ 的矩阵，并且有一个玩家站在上面。
其中 $(i, j)$ 表示矩阵的第 $i$ 行第 $j$ 列。
矩阵被表示为 $N$ 个字符串 $S_1 S_2S_3...S_N$，每个字符串长 $M$ 个字符。

矩阵每个格子都是冰或者岩石：如果 $S_i$ 的第 $j$ 个字符，即 $(i, j)$ 对应的字符为 `.`，那么 $(i, j)$ 是冰；如果是 `#`，$(i, j)$ 就是岩石。

这个矩阵的一周（第 $1$ 行、第 $N$ 行、第 $1$ 列，第 $M$ 列）均为岩石。
玩家起始所站的点 $(2, 2)$ 恒为冰。

玩家可以移动零次或任意次，每次移动需要先选定一个方向（上下左右），并且一直沿着这个方向移动直到遇到岩石（或不是冰）。

计算出玩家可以抵达或途径的所有格点（包括滑过的）。

## 输入格式

```
N M
S1
S2
...
SN
```
第一行两个正整数 $N$ 和 $M$，表示矩阵的长宽。
第二行到第 $N + 1$ 行，每行一个长 $M$ 的字符串，表示矩阵内容（代表矩阵内容的字符）。

## 输出格式

输出玩家能触及的格点数。

## 说明/提示

对于 $100\%$ 的数据：

$ 3 \le N, M \le 200 $

$S_i$ 是长为 $M$ 的字符串，仅包含 `.` 和 `#`。

矩阵的边缘都是 `#`（岩石），且 $(2,2)$ 处一定为 `.`（冰）。

#### 样例1解释
比如玩家可以经过 $(5,5)$ 通过这样移动：

$(2, 2)$ → $(5, 2)$ → $(5, 5)$

玩家也可以经过 $(2, 4)$：

$(2, 2)$ → $(2, 5)$，途经 $(2, 4)$。

但玩家无法到达 $(3, 4)$。

## 样例 #1

### 输入

```
6 6

######

#....#

#.#..#

#..#.#

#....#

######
```

### 输出

```
12
```

## 样例 #2

### 输入

```
21 25

#########################

#..............###...####

#..............#..#...###

#........###...#...#...##

#........#..#..#........#

#...##...#..#..#...#....#

#..#..#..###...#..#.....#

#..#..#..#..#..###......#

#..####..#..#...........#

#..#..#..###............#

#..#..#.................#

#........##.............#

#.......#..#............#

#..........#....#.......#

#........###...##....#..#

#..........#..#.#...##..#

#.......#..#....#..#.#..#

##.......##.....#....#..#

###.............#....#..#

####.................#..#

#########################
```

### 输出

```
215
```



---

---
title: "[ABC317E] Avoid Eye Contact"
layout: "post"
diff: 普及/提高-
pid: AT_abc317_e
tag: ['模拟', '广度优先搜索 BFS']
---

# [ABC317E] Avoid Eye Contact

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc317/tasks/abc317_e

$ H $ 行 $ W $ 列のグリッド状に分割されたフィールドがあります。  
北 (上側) から $ i $ 行目、西 (左側) から $ j $ 列目のマスは文字 $ A_{i,\ j} $ で表されます。各文字の意味は次の通りです。

- `.` : 空きマス。進入できる。
- `#` : 障害物。進入できない。
- `>`, `v`, `<`, `^` : それぞれ東・南・西・北を向いている人がいるマス。進入できない。人の視線は $ 1 $ マス分の幅を持ち、人が向いている方向にまっすぐ伸び、障害物や別の人に遮られる。(入出力例 $ 1 $ にある説明も参考にしてください。)
- `S` : スタート地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。
- `G` : ゴール地点。進入できる。ちょうど $ 1 $ ヵ所だけ存在する。人の視線に入っていないことが保証される。

ナオヒロくんはスタート地点にいて、東西南北への $ 1 $ マス分の移動を好きな回数行えます。ただし、進入できないマスへの移動やフィールドの外への移動はできません。  
彼が人の視線に一度も入らずにゴール地点に到達できるか判定して、できる場合はそのために最小で何回の移動が必要か求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ A_{1,1}A_{1,2}\dots\ A_{1,W} $ $ A_{2,1}A_{2,2}\dots\ A_{2,W} $ $ \vdots $ $ A_{H,1}A_{H,2}\dots\ A_{H,W} $

## 输出格式

ナオヒロ君が人の視線に一度も入らずにゴール地点に到達できる場合は、そのために必要な(最小の)移動回数を出力せよ。できない場合は `-1` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 2000 $
- $ A_{i,j} $ は `.`, `#`, `>`, `v`, `<`, `^`, `S`, `G` のいずれかである
- `S`, `G` は $ A_{i,\ j} $ の中にちょうど $ 1 $ 回ずつ現れる
- スタート地点・ゴール地点はともに人の視線に入っていない

### Sample Explanation 1

入力例 $ 1 $ について、$ 1 $ 人以上の視線に入っている空きマスを `!` で表すと次の図のようになります。 !\[image2\](https://img.atcoder.jp/abc317/8a40fc4c621cfef326cc25a1f69c0300.jpg) いくつかのマスについて具体的に説明すると次のようになります。(ここで、北から $ i $ 行目、西から $ j $ 列目のマスを $ (i,\ j) $ と表します。) - $ (2,\ 4) $ は $ (2,\ 2) $ にいる東を向いている人からの視線に入っているマスである。 - $ (2,\ 6) $ は $ (2,\ 2) $ にいる東を向いている人と $ (1,\ 6) $ にいる南を向いている人の $ 2 $ 人の視線に入っているマスである。 - $ (4,\ 5) $ は誰の視線にも入っていないマスである。$ (4,\ 7) $ にいる西を向いている人の視線は $ (4,\ 6) $ の障害物に遮られていて、$ (4,\ 1) $ にいる東を向いている人の視線は $ (4,\ 4) $ の人に遮られている。 ナオヒロ君は進入できないマス・視線に入っているマスのどちらも通らずにゴール地点へ行く必要があります。

### Sample Explanation 2

ナオヒロ君がゴール地点に到達できない場合は `-1` を出力してください。

## 样例 #1

### 输入

```
5 7
....Sv.
.>.....
.......
>..<.#<
^G....>
```

### 输出

```
15
```

## 样例 #2

### 输入

```
4 3
S..
.<.
.>.
..G
```

### 输出

```
-1
```



---

---
title: "[ABC318D] General Weighted Max Matching"
layout: "post"
diff: 普及/提高-
pid: AT_abc318_d
tag: ['动态规划 DP', '搜索', '状态合并']
---

# [ABC318D] General Weighted Max Matching

## 题目描述

**题意简述**

有一个无向图，$i$ 到 $j$ 的距离为 $D_{i,j}$。你可以选择一些边，使得这些边连接的所有顶点互不相同。求这些边总长度的最大值。

## 输入格式

以以下格式输入：

> $N$\
> $D_{1,2},D_{1,3},\ldots,D_{1,N}$\
> $D_{2,3},\ldots,D_{2,N}$\
> $\vdots$\
> $D_{N-1,N}$

## 输出格式

$1$ 个整数。如题意。

## 说明/提示

- $2 \le N \le 16$
- $1 \le D_{i,j} \le 10^9$

**样例一解释**

选择 $D_{1,3},D_{2,4}$，总和为$5+8=13$。

## 样例 #1

### 输入

```
4

1 5 4

7 8

6
```

### 输出

```
13
```

## 样例 #2

### 输入

```
3

1 2

3
```

### 输出

```
3
```

## 样例 #3

### 输入

```
16

5 6 5 2 1 7 9 7 2 5 5 2 4 7 6

8 7 7 9 8 1 9 6 10 8 8 6 10 3

10 5 8 1 10 7 8 4 8 6 5 1 10

7 4 1 4 5 4 5 10 1 5 1 2

2 9 9 7 6 2 2 8 3 5 2

9 10 3 1 1 2 10 7 7 5

10 6 1 8 9 3 2 4 2

10 10 8 9 2 10 7 9

5 8 8 7 5 8 2

4 2 2 6 8 3

2 7 3 10 3

5 7 10 3

8 5 7

9 1

4
```

### 输出

```
75
```



---

---
title: "[ABC321C] 321-like Searcher"
layout: "post"
diff: 普及/提高-
pid: AT_abc321_c
tag: ['搜索']
---

# [ABC321C] 321-like Searcher

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc321/tasks/abc321_c

以下の条件を満たす正整数 $ x $ を **321-like Number** と呼びます。 **この定義は A 問題と同様です。**

- $ x $ の各桁を上から見ると狭義単調減少になっている。
- すなわち、$ x $ が $ d $ 桁の整数だとすると、 $ 1\ \le\ i\ <\ d $ を満たす全ての整数 $ i $ について以下の条件を満たす。
  - ( $ x $ の上から $ i $ 桁目 ) $ > $ ( $ x $ の上から $ i+1 $ 桁目 )

なお、 $ 1 $ 桁の正整数は必ず 321-like Number であることに注意してください。

例えば、 $ 321,96410,1 $ は 321-like Number ですが、 $ 123,2109,86411 $ は 321-like Number ではありません。

$ K $ 番目に小さい 321-like Number を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ K $

## 输出格式

$ K $ 番目に小さい 321-like Number を整数として出力せよ。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K $
- 321-like Number は $ K $ 個以上存在する

### Sample Explanation 1

321-like Number は小さいものから順に $ (1,2,3,4,5,6,7,8,9,10,20,21,30,31,32,40,\dots) $ です。 このうち $ 15 $ 番目に小さいものは $ 32 $ です。

## 样例 #1

### 输入

```
15
```

### 输出

```
32
```

## 样例 #2

### 输入

```
321
```

### 输出

```
9610
```

## 样例 #3

### 输入

```
777
```

### 输出

```
983210
```



---

---
title: "[ABC334E] Christmas Color Grid 1"
layout: "post"
diff: 普及/提高-
pid: AT_abc334_e
tag: ['枚举', '广度优先搜索 BFS']
---

# [ABC334E] Christmas Color Grid 1

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc334/tasks/abc334_e

**この問題は問題 G と似た設定です。問題文の相違点を赤字で示します。**

$ H $ 行 $ W $ 列のグリッドがあり、グリッドの各マスは赤色あるいは緑色に塗られています。

グリッドの上から $ i $ 行目、左から $ j $ 列目のマスをマス $ (i,j) $ と表記します。

マス $ (i,j) $ の色は文字 $ S_{i,j} $ で表され、$ S_{i,j}\ = $ `.` のときマス $ (i,j) $ は赤色、$ S_{i,j}\ = $ `#` のときマス $ (i,j) $ は緑色に塗られています。

グリッドにおいて、緑色に塗られたマスを頂点集合、隣り合った $ 2 $ つの緑色のマスを結ぶ辺全体を辺集合としたグラフにおける連結成分の個数を **緑の連結成分数** と呼びます。ただし、$ 2 $ つのマス $ (x,y) $ と $ (x',y') $ が隣り合っているとは、$ |x-x'|\ +\ |y-y'|\ =\ 1 $ であることを指します。

**赤色**に塗られたマスを一様ランダムに $ 1 $ つ選び、**緑色**に塗り替えたとき、塗り替え後のグリッドの緑の連結成分数の期待値を $ \text{mod\ }\ 998244353 $ で出力してください。

  「期待値を $ \text{mod\ }\ 998244353 $ で出力」とは 求める期待値は必ず有理数となることが証明できます。 またこの問題の制約下では、その値を互いに素な $ 2 $ つの整数 $ P $, $ Q $ を用いて $ \frac{P}{Q} $ と表したとき、 $ R\ \times\ Q\ \equiv\ P\pmod{998244353} $ かつ $ 0\ \leq\ R\ \lt\ 998244353 $ を満たす整数 $ R $ がただ $ 1 $ つ存在することが証明できます。この $ R $ を出力してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ S_{1,1} $$ S_{1,2} $$ \ldots $$ S_{1,W} $ $ S_{2,1} $$ S_{2,2} $$ \ldots $$ S_{2,W} $ $ \vdots $ $ S_{H,1} $$ S_{H,2} $$ \ldots $$ S_{H,W} $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ H,W\ \leq\ 1000 $
- $ S_{i,j}\ = $ `.` または $ S_{i,j}\ = $ `#`
- $ S_{i,j}\ = $ `.` なる $ (i,j) $ が存在する。
 
### Sample Explanation 1

マス $ (1,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (2,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 1 $ となります。 マス $ (3,2) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 マス $ (3,3) $ を緑色に塗り替えたとき、緑の連結成分数は $ 2 $ となります。 よって、赤色に塗られたマスを一様ランダムに $ 1 $ つ選び、緑色に塗り替えた後の緑の連結成分数の期待値は $ (1+1+2+2)/4\ =\ 3/2 $ となります。

## 样例 #1

### 输入

```
3 3

##.

#.#

#..
```

### 输出

```
499122178
```

## 样例 #2

### 输入

```
4 5

..#..

.###.

#####

..#..
```

### 输出

```
598946613
```

## 样例 #3

### 输入

```
3 4

#...

.#.#

..##
```

### 输出

```
285212675
```



---

---
title: "[ABC339D] Synchronized Players"
layout: "post"
diff: 普及/提高-
pid: AT_abc339_d
tag: ['搜索', '广度优先搜索 BFS']
---

# [ABC339D] Synchronized Players

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc339/tasks/abc339_d

$ N $ 行 $ N $ 列のグリッドがあり、各マスは空きマスか障害物のあるマスのいずれかです。グリッドの上から $ i $ 行目、左から $ j $ 列目のマスを $ (i,\ j) $ と表記します。

また、$ 2 $ 人のプレイヤーがグリッド上の相異なる空きマス上におり、各マスの情報は $ N $ 個の長さ $ N $ の文字列 $ S_1,\ S_2,\ \ldots,\ S_N $ として以下の形式で与えられます。

- $ S_i $ の $ j $ 文字目が `P` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいる
- $ S_i $ の $ j $ 文字目が `.` であるとき、$ (i,\ j) $ は空きマスであり、プレイヤーがいない
- $ S_i $ の $ j $ 文字目が `#` であるとき、$ (i,\ j) $ は障害物のあるマスである
 
以下の操作を繰り返し $ 2 $ 人のプレイヤーを同じマスに集めるために必要な操作回数の最小値を求めてください。ただし、操作の繰り返しにより $ 2 $ 人のプレイヤーを同じマスに集めることができない場合には `-1` を出力してください。

- 上下左右のいずれかの方向を決める。そして各プレイヤーはともにその方向に隣接するマスへの移動を試みる。各プレイヤーは移動先のマスが存在し、かつ空きマスであるならば移動し、そうでないならば移動しない。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_N $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ N $ は $ 2 $ 以上 $ 60 $ 以下の整数
- $ S_i $ は長さ $ N $ の `P`, `.`, `#` からなる文字列
- $ S_i $ の $ j $ 文字目が `P` であるような組 $ (i,\ j) $ の個数はちょうど $ 2 $ つ
 
### Sample Explanation 1

はじめに $ (3,\ 2) $ にいるプレイヤーをプレイヤー $ 1 $、$ (4,\ 3) $ にいるプレイヤーをプレイヤー $ 2 $ とします。 例えば以下のようにすることで、$ 3 $ 回の操作で $ 2 $ 人のプレイヤーが同じマスに集まります。 - 左を選択する。プレイヤー $ 1 $ は $ (3,\ 1) $ に移動し、プレイヤー $ 2 $ は $ (4,\ 2) $ に移動する。 - 上を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 2) $ に移動する。 - 左を選択する。プレイヤー $ 1 $ は移動せず、プレイヤー $ 2 $ は $ (3,\ 1) $ に移動する。

## 样例 #1

### 输入

```
5

....#

#..#.

.P...

..P..

....#
```

### 输出

```
3
```

## 样例 #2

### 输入

```
2

P#

#P
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
10

..........

..........

..........

..........

....P.....

.....P....

..........

..........

..........

..........
```

### 输出

```
10
```



---

---
title: "[ABC345D] Tiling"
layout: "post"
diff: 普及/提高-
pid: AT_abc345_d
tag: ['搜索', '深度优先搜索 DFS']
---

# [ABC345D] Tiling

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc345/tasks/abc345_d

一辺の長さが $ 1 $ のマスからなる $ H $ 行 $ W $ 列のマス目と、$ N $ 枚のタイルがあります。  
$ i $ $ (1\leq\ i\leq\ N) $ 枚目のタイルは $ A_i\times\ B_i $ の長方形です。  
以下の条件をすべてみたすようにタイルをマス目に置くことができるか判定してください。

- 全てのマスがちょうど $ 1 $ 枚のタイルで覆われている。
- 使用されないタイルがあっても良い。
- 使用するタイルは **回転したり裏返したりして置かれていても良い**。ただし、各タイルはマスの線に合わせてマス目からはみ出ることがないように置かれていなければならない。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ H $ $ W $ $ A_1 $ $ B_1 $ $ A_2 $ $ B_2 $ $ \vdots $ $ A_N $ $ B_N $

## 输出格式

問題文中の条件をみたすようにタイルをマス目に置くことができるならば `Yes` を、そうでないならば `No` を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 7 $
- $ 1\ \leq\ H,W\ \leq\ 10 $
- $ 1\leq\ A_i,B_i\leq\ 10 $
- 入力はすべて整数

### Sample Explanation 1

$ 2,4,5 $ 枚目のタイルを使用して次のように置くと、マス目の各マスをちょうど $ 1 $ 枚のタイルで覆うことができます。 !\[\](https://img.atcoder.jp/abc345/0a0f2829d0485013deabba0103dbd906.png) よって、`Yes` を出力します。

### Sample Explanation 2

マス目からはみ出さないようにタイルを置くことはできません。 よって、`No` を出力します。

### Sample Explanation 3

全てのマスを覆うようにタイルを置くことができません。 よって、`No` を出力します。

### Sample Explanation 4

全てのマスはちょうど $ 1 $ 枚のタイルで覆われている必要があることに注意してください。

## 样例 #1

### 输入

```
5 5 5
1 1
3 3
4 4
2 3
2 5
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
1 1 2
2 3
```

### 输出

```
No
```

## 样例 #3

### 输入

```
1 2 2
1 1
```

### 输出

```
No
```

## 样例 #4

### 输入

```
5 3 3
1 1
2 2
2 2
2 2
2 2
```

### 输出

```
No
```



---

---
title: "[ABC348D] Medicines on Grid"
layout: "post"
diff: 普及/提高-
pid: AT_abc348_d
tag: ['广度优先搜索 BFS']
---

# [ABC348D] Medicines on Grid

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc348/tasks/abc348_d

$ H $ 行 $ W $ 列のグリッドがあります。上から $ i $ 行目、左から $ j $ 列目のマス目を $ (i,\ j) $ と表します。各マスの状態は文字 $ A_{i,j} $ で表され、意味は以下の通りです。

- `.` : 空きマス。
- `#` : 障害物。
- `S` : 空きマスかつスタート地点。
- `T` : 空きマスかつゴール地点。
 
高橋君は、今いるマスから上下左右に隣り合う空きマスへ、エネルギーを $ 1 $ 消費して移動することができます。ただし、エネルギーが $ 0 $ の状態で移動することはできず、またグリッドの外へ移動することはできません。

グリッドには合計で $ N $ 個の薬があります。$ i $ 番目の薬は空きマス $ (R_i,\ C_i) $ にあり、使うとエネルギーを **$ E_i $ にする**ことができます。必ずしもエネルギーが増えるとは限らないことに注意してください。高橋君は自分のいるマスにある薬を使うことができます。使った薬はなくなります。

高橋君ははじめエネルギー $ 0 $ の状態でスタート地点にいて、ゴール地点まで移動したいです。これが可能かどうか判定してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ A_{1,\ 1} $$ A_{1,\ 2} $$ \cdots $$ A_{1,\ W} $ $ A_{2,\ 1} $$ A_{2,\ 2} $$ \cdots $$ A_{2,\ W} $ $ \vdots $ $ A_{H,\ 1} $$ A_{H,\ 2} $$ \cdots $$ A_{H,\ W} $ $ N $ $ R_1 $ $ C_1 $ $ E_1 $ $ R_2 $ $ C_2 $ $ E_2 $ $ \vdots $ $ R_N $ $ C_N $ $ E_N $

## 输出格式

高橋君がスタート地点からゴール地点へ移動することが可能なら `Yes` 、不可能なら `No` を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ H,\ W\ \leq\ 200 $
- $ A_{i,\ j} $ は `.`, `#`, `S`, `T` のいずれかである。
- `S` と `T` は $ A_{i,\ j} $ にそれぞれちょうど $ 1 $ つ存在する。
- $ 1\ \leq\ N\ \leq\ 300 $
- $ 1\ \leq\ R_i\ \leq\ H $
- $ 1\ \leq\ C_i\ \leq\ W $
- $ i\ \neq\ j $ ならば $ (R_i,\ C_i)\ \neq\ (R_j,\ C_j) $
- $ A_{R_i,\ C_i} $ は `#` でない。
- $ 1\ \leq\ E_i\ \leq\ HW $
 
### Sample Explanation 1

例えば、以下のようにしてゴール地点へ移動することができます。 - 薬 $ 1 $ を使う。エネルギーが $ 3 $ になる。 - $ (1,\ 2) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (1,\ 3) $ へ移動する。エネルギーが $ 1 $ になる。 - 薬 $ 2 $ を使う。エネルギーが $ 5 $ になる。 - $ (2,\ 3) $ へ移動する。エネルギーが $ 4 $ になる。 - $ (3,\ 3) $ へ移動する。エネルギーが $ 3 $ になる。 - $ (3,\ 4) $ へ移動する。エネルギーが $ 2 $ になる。 - $ (4,\ 4) $ へ移動する。エネルギーが $ 1 $ になる。 この移動の途中には $ (2,\ 3) $ にも薬がありますが、これを使うとゴールできません。

### Sample Explanation 2

高橋君はスタート地点から移動することができません。

## 样例 #1

### 输入

```
4 4

S...

#..#

#...

..#T

4

1 1 3

1 3 5

3 2 1

2 3 1
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
2 2

S.

T.

1

1 2 4
```

### 输出

```
No
```

## 样例 #3

### 输入

```
4 5

..#..

.S##.

.##T.

.....

3

3 1 5

1 2 3

2 2 1
```

### 输出

```
Yes
```



---

---
title: "[ABC351D] Grid and Magnet"
layout: "post"
diff: 普及/提高-
pid: AT_abc351_d
tag: ['搜索', '广度优先搜索 BFS', '深度优先搜索 DFS']
---

# [ABC351D] Grid and Magnet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_d

$ H $ 行 $ W $ 列のマス目があり、いくつか（$ 0 $ 個のこともある）のマスには磁石が置かれています。  
マス目の状態は $ H $ 個の 長さ $ W $ の文字列 $ S_1,S_2,\ldots,S_H $ で表され、 $ S_i $ の $ j $ 文字目が `#` のとき上から $ i $ 行目かつ左から $ j $ 列目のマスには磁石が置かれていることを、 `.` のとき何も置かれていないことを表しています。

高橋君は鉄の鎧を着ており、あるマスにいるとき次のように移動することができます。

- 現在いるマスの上下左右に隣り合うマスのいずれかに磁石が置かれているとき、どこへも移動することができない。
- そうでないとき、上下左右に隣り合うマスのいずれかを選んでそのマスに移動することができる。  
  ただし、マス目の外に移動することはできない。

磁石が置かれていない各マスについて、そのマスの自由度を、「最初高橋くんがそのマスにいるとき、そこから移動を繰り返して到達できるマスの個数」として定義します。 マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を求めてください。

ただし、自由度の定義において、「移動を繰り返して到達できるマス」とは、最初にいるマスからそのマスまで移動を繰り返して到達する方法（$ 1 $ 回も移動しないものも含む）が $ 1 $ つ以上存在するようなマスのことであり、 最初のマスから始めてすべてのそのようなマスを巡るような移動方法が存在する必要はありません。特に（磁石の置かれていない）各マス自身は、そのマスから「移動を繰り返して到達できるマス」につねに含まれることに注意してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_H $

## 输出格式

マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ H,W $ は整数
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列
- 磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。

### Sample Explanation 1

上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。

### Sample Explanation 2

磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。

## 样例 #1

### 输入

```
3 5
.#...
.....
.#..#
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3 3
..#
#..
..#
```

### 输出

```
1
```



---

---
title: "[ABC361D] Go Stone Puzzle"
layout: "post"
diff: 普及/提高-
pid: AT_abc361_d
tag: ['广度优先搜索 BFS']
---

# [ABC361D] Go Stone Puzzle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc361/tasks/abc361_d

$ N+2 $ 個のマスが横一列に並んでいます。左から $ i $ 番目のマスをマス $ i $ と表します。

マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれています。  
 各 $ 1\leq\ i\ \leq\ N $ について、$ S_i $ が `W` のときマス $ i $ に置かれている石の色は白であり、$ S_i $ が `B` のときマス $ i $ に置かれている石の色は黒です。  
 マス $ N+1,N+2 $ には何も置かれていません。

あなたは以下の操作を好きな回数($ 0 $ 回でもよい)行うことができます。

- 石が $ 2 $ 個並んでいる箇所を選び、その $ 2 $ 個の石を順序を保って空きマスに移す。  
   より正確には次の通り。$ 1 $ 以上 $ N+1 $ 以下の整数 $ x $ であって、マス $ x,x+1 $ の両方に石が置かれているものを選ぶ。石の置かれていないマスを $ k,k+1 $ とする。マス $ x,x+1 $ にある石をそれぞれマス $ k,k+1 $ に移動する。
 
以下の状態にすることが可能か判定し、可能なら操作回数の最小値を求めてください。

- マス $ 1 $ からマス $ N $ には石が $ 1 $ 個ずつ置かれており、各 $ 1\leq\ i\ \leq\ N $ について、$ T_i $ が `W` のときマス $ i $ に置かれている石の色は白、$ T_i $ が `B` のときマス $ i $ に置かれている石の色は黒である。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $ $ T $

## 输出格式

目的の状態にすることが可能なら操作回数の最小値を出力せよ。不可能ならかわりに `-1` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 14 $
- $ N $ は整数である
- $ S,T $ は `B` および `W` のみからなる長さ $ N $ の文字列である
 
### Sample Explanation 1

石が置かれていないマスを `.` と表します。以下のようにして $ 4 $ 回の操作で目的の状態にすることができ、これが最小回数です。 - `BWBWBW..` - `BW..BWBW` - `BWWBB..W` - `..WBBBWW` - `WWWBBB..`

## 样例 #1

### 输入

```
6

BWBWBW

WWWBBB
```

### 输出

```
4
```

## 样例 #2

### 输入

```
6

BBBBBB

WWWWWW
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
14

BBBWBWWWBBWWBW

WBWWBBWWWBWBBB
```

### 输出

```
7
```



---

---
title: "[ABC363E] Sinking Land"
layout: "post"
diff: 普及/提高-
pid: AT_abc363_e
tag: ['广度优先搜索 BFS']
---

# [ABC363E] Sinking Land

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc363/tasks/abc363_e

$ H\ \times\ W $ の大きさの島があり、島は周りを海で囲まれています。  
 島は 縦 $ H $ 個 $ \times $ 横 $ W $ 個の $ 1\times\ 1 $ の区画に分けられており、上から $ i $ 番目かつ左から $ j $ 番目の区画の（現在の海面を基準にした）標高は $ A_{i,j} $ です。

現在から $ 1 $ 年ごとに海面の高さが $ 1 $ ずつ上昇します。  
 このとき、海または海に沈んだ区画に上下左右に隣接する区画であって、標高が海面の高さ **以下** の区画は海に沈みます。  
 ここで、ある区画が新しく海に沈んだときそれと上下左右に隣接する区画であって海面の高さ以下のものも同時に海に沈み、これによって新しく沈んだ区画についてもこれは繰り返されます。

$ i=1,2,\ldots,\ Y $ それぞれについて、現在から $ i $ 年後に、島のうち海に沈まず残っている部分の面積を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ Y $ $ A_{1,1} $ $ A_{1,2} $ $ \ldots $ $ A_{1,W} $ $ A_{2,1} $ $ A_{2,2} $ $ \ldots $ $ A_{2,W} $ $ \vdots $ $ A_{H,1} $ $ A_{H,2} $ $ \ldots $ $ A_{H,W} $

## 输出格式

$ Y $ 行出力せよ。 $ i $ 行目 $ (1\leq\ i\leq\ Y) $ には現在から $ i $ 年後に海に沈まず残っている島の面積を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ 1\leq\ Y\leq\ 10^5 $
- $ 1\leq\ A_{i,j}\leq\ 10^5 $
- 入力はすべて整数
 
### Sample Explanation 1

島の上から $ i $ 番目かつ左から $ j $ 番目の区画を $ (i,j) $ で表します。このとき、次のようになります。 - $ 1 $ 年後、海面は現在より $ 1 $ 上昇しますが、海に面している標高 $ 1 $ の区画は存在しないため、どの区画も沈みません。よって、$ 1 $ 行目には $ 9 $ を出力します。 - $ 2 $ 年後、海面は現在より $ 2 $ 上昇し、$ (1,2) $ が海に沈みます。これによって、$ (2,2) $ は海に沈んだ区画に隣接する区画となりますが、その標高は $ 2 $ 以下であるため、これも海に沈みます。これら以外にこの時点で他に沈む区画はありません。よって、$ 2 $ つの区画が沈むため、$ 2 $ 行目には $ 9-2=7 $ を出力します。 - $ 3 $ 年後、海面は現在より $ 3 $ 上昇し、$ (2,1) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 3 $ 行目には $ 6 $ を出力します。 - $ 4 $ 年後、海面は現在より $ 4 $ 上昇し、$ (2,3) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 4 $ 行目には $ 5 $ を出力します。 - $ 5 $ 年後、海面は現在より $ 5 $ 上昇し、$ (3,2) $ が新しく海に沈みます。他に沈む区画はありません。よって、$ 5 $ 行目には $ 4 $ を出力します。 よって、$ 9,7,6,5,4 $ をこの順に各行に出力します。

## 样例 #1

### 输入

```
3 3 5

10 2 10

3 1 4

10 5 10
```

### 输出

```
9

7

6

5

4
```

## 样例 #2

### 输入

```
3 5 3

2 2 3 3 3

2 1 2 1 3

2 2 3 3 3
```

### 输出

```
15

7

0
```



---

---
title: "[ABC368D] Minimum Steiner Tree"
layout: "post"
diff: 普及/提高-
pid: AT_abc368_d
tag: ['深度优先搜索 DFS']
---

# [ABC368D] Minimum Steiner Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc368/tasks/abc368_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の木が与えられます。$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。

このグラフからいくつかの($ 0 $ 個でもよい)辺と頂点を削除してできる木のうち、指定された $ K $ 個の頂点、頂点 $ V_1,\ldots,V_K $ を全て含むようなものの頂点数の最小値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ K $ $ A_1 $ $ B_1 $ $ \vdots $ $ A_{N-1} $ $ B_{N-1} $ $ V_1 $ $ \ldots $ $ V_K $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ 1\ \leq\ V_1\ <\ V_2\ <\ \ldots\ <\ V_K\ \leq\ N $
- 与えられるグラフは木である
- 入力は全て整数

### Sample Explanation 1

与えられた木は下図左の通りであり、そこからいくつかの辺と頂点を削除してできる木のうち頂点 $ 1,3,5 $ を全て含むような頂点数最小のものは下図右の通りです。 
![図](https://img.atcoder.jp/abc368/4baf6b0adb0e12dcf8a5c812ada5c17a.png)

## 样例 #1

### 输入

```
7 3
1 2
1 3
2 4
2 5
3 6
3 7
1 3 5
```

### 输出

```
4
```

## 样例 #2

### 输入

```
4 4
3 1
1 4
2 1
1 2 3 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5 1
1 4
2 3
5 2
1 2
1
```

### 输出

```
1
```



---

---
title: "[ABC373D] Hidden Weights"
layout: "post"
diff: 普及/提高-
pid: AT_abc373_d
tag: ['搜索', '图遍历']
---

# [ABC373D] Hidden Weights

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc373/tasks/abc373_d

$ N $ 頂点 $ M $ 辺の有向グラフが与えられます。$ j $ 番目の有向辺は頂点 $ u_j $ から頂点 $ v_j $ に向かっており、重み $ w_j $ を持っています。

各頂点に $ -10^{18} $ 以上 $ 10^{18} $ 以下の整数を書き込む方法であって、次の条件を満たすものを $ 1 $ つ見つけてください。

- 頂点 $ i $ に書き込まれている値を $ x_i $ とする。すべての辺 $ j=1,2,\dots,M $ について、$ x_{v_j}\ -\ x_{u_j}\ =\ w_j $ が成り立つ。

与えられる入力について、条件を満たす書き込み方が少なくとも $ 1 $ つ存在することが保証されます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ u_1 $ $ v_1 $ $ w_1 $ $ u_2 $ $ v_2 $ $ w_2 $ $ \vdots $ $ u_M $ $ v_M $ $ w_M $

## 输出格式

頂点 $ i $ に書き込む整数を $ x_i $ として、$ x_1,x_2,\dots,x_N $ をこの順に空白区切りで $ 1 $ 行で出力せよ。答えが複数ある場合、どれを出力しても良い。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\{2\ \times\ 10^5,N(N-1)/2\} $
- $ 1\ \leq\ u_j,\ v_j\ \leq\ N $
- $ u_j\ \neq\ v_j $
- $ i\ \neq\ j $ なら $ (u_i,v_i)\ \neq\ (u_j,v_j) $ かつ $ (u_i,v_i)\ \neq\ (v_j,u_j) $
- $ |w_j|\ \leq\ 10^9 $
- 入力はすべて整数
- 条件を満たす書き込み方が少なくとも $ 1 $ つ存在する

### Sample Explanation 1

$ x=(3,5,2) $ とすることで、$ x_2-x_1=w_1=2,x_2-x_3=w_2=3,x_3-x_1=w_3=-1 $ となり、条件を満たします。 他にも、たとえば $ x=(-1,1,-2) $ としても正解となります。

### Sample Explanation 2

他にも、たとえば $ x=(0,-5,4,1) $ や $ x=(5,0,4,1) $ としても正解となります。

## 样例 #1

### 输入

```
3 3
1 2 2
3 2 3
1 3 -1
```

### 输出

```
3 5 2
```

## 样例 #2

### 输入

```
4 2
2 1 5
3 4 -3
```

### 输出

```
5 0 6 3
```

## 样例 #3

### 输入

```
5 7
2 1 18169343
3 1 307110901
4 1 130955934
2 3 -288941558
2 5 96267410
5 3 -385208968
4 3 -176154967
```

### 输出

```
200401298 182231955 -106709603 69445364 278499365
```



---

---
title: "[ABC374D] Laser Marking"
layout: "post"
diff: 普及/提高-
pid: AT_abc374_d
tag: ['深度优先搜索 DFS']
---

# [ABC374D] Laser Marking

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_d

$ xy $ 平面に対し、レーザを照射しながら線分を印字する印字機があります。

- 印字開始時、レーザ照射位置は座標 $ (0,\ 0) $ にある。
- 線分を印字する際は、以下の流れに従う。
  
  
  - まず、レーザ照射位置を線分の端点のうちどちらか $ 1 $ つに移動させる。
      - どちらの端点から描画を始めてもよい。
  - その後、レーザ照射位置のある端点からもう一方の端点まで、レーザを照射しながらレーザ照射位置を一直線に移動させる。
      - 線分の途中で印字を中止することは許されない。
- レーザを照射していない時、レーザ照射位置は $ 1 $ 秒あたり速度 $ S $ で任意の方向に移動できる。
- レーザを照射している時、レーザ照射位置は $ 1 $ 秒あたり速度 $ T $ で印字中の線分に沿って移動できる。
- レーザ照射位置の移動にかかる時間以外の所要時間は無視できる。

高橋君はこの印字機で $ N $ 本の線分を印字したいです。  
そのうち $ i $ 本目の線分は、座標 $ (A_i,\ B_i) $ と座標 $ (C_i,\ D_i) $ を結びます。  
なお、複数の線分が重なっていることがありますが、全ての線分についてその都度重なっている部分を印字する必要があります。

うまく印字機を操作したとき、全ての線分を印字完了するまでにかかる最小の時間は何秒ですか？

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $ $ T $ $ A_1 $ $ B_1 $ $ C_1 $ $ D_1 $ $ \vdots $ $ A_N $ $ B_N $ $ C_N $ $ D_N $

## 输出格式

答えを出力せよ。  
なお、真の値との絶対誤差または相対誤差が $ 10^{-6} $ 以下であれば正解として扱われる。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 6 $
- $ 1\ \le\ T\ \le\ S\ \le\ 1000 $
- $ -1000\ \le\ A_i,B_i,C_i,D_i\ \le\ 1000 $
- $ (A_i,B_i)\ \neq\ (C_i,D_i) $ ( $ 1\ \le\ i\ \le\ N $ )

### Sample Explanation 1

\- レーザを照射しながらレーザ照射位置を $ (0,0) $ から $ (0,2) $ まで移動させ、 $ 2 $ 本目の線分を描画する。 - この描画に要する時間は $ 2 $ 秒である。 - レーザを照射せずレーザ照射位置を $ (0,2) $ から $ (1,3) $ まで移動させる。 - この移動に要する時間は $ \sqrt{2}/2 $ 秒である。 - レーザを照射しながらレーザ照射位置を $ (1,3) $ から $ (2,1) $ まで移動させ、 $ 1 $ 本目の線分を描画する。 - この描画に要する時間は $ \sqrt{5} $ 秒である。 - レーザを照射せずレーザ照射位置を $ (2,1) $ から $ (2,0) $ まで移動させる。 - この移動に要する時間は $ 1/2 $ 秒である。 - レーザを照射しながらレーザ照射位置を $ (2,0) $ から $ (3,0) $ まで移動させ、 $ 3 $ 本目の線分を描画する。 - この描画に要する時間は $ 1 $ 秒である。 - 全体の所要時間は $ 2\ +\ (\sqrt{2}/2)\ +\ \sqrt{5}\ +\ (1/2)\ +\ 1\approx\ 6.443175 $ 秒です。

### Sample Explanation 3

複数の線分が重なっていますが、全ての線分についてその都度重なっている部分を印字する必要があります。

## 样例 #1

### 输入

```
3 2 1
1 3 2 1
0 2 0 0
3 0 2 0
```

### 输出

```
6.44317475868633722080
```

## 样例 #2

### 输入

```
2 1 1
0 0 10 10
0 2 2 0
```

### 输出

```
20.97056274847714058517
```

## 样例 #3

### 输入

```
6 3 2
-1000 -1000 1000 1000
1000 -1000 -1000 1000
-1000 -1000 1000 1000
1000 -1000 -1000 1000
1000 1000 -1000 -1000
-1000 1000 1000 -1000
```

### 输出

```
9623.35256169626864153344
```

## 样例 #4

### 输入

```
6 10 8
1000 1000 -1000 -1000
1000 -1000 -1000 -1000
-1000 1000 1000 1000
-1000 1000 -1000 -1000
1000 1000 1000 -1000
1000 -1000 -1000 1000
```

### 输出

```
2048.52813742385702910909
```



---

---
title: "[ABC376D] Cycle"
layout: "post"
diff: 普及/提高-
pid: AT_abc376_d
tag: ['搜索', '广度优先搜索 BFS', '图遍历']
---

# [ABC376D] Cycle

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc376/tasks/abc376_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点 $ M $ 辺の単純有向グラフがあります。$ i $ 番目の辺 $ (1\ \leq\ i\ \leq\ M) $ は頂点 $ a_i $ から頂点 $ b_i $ へ伸びる辺です。  
 頂点 $ 1 $ を含む閉路が存在するか判定して、存在する場合はそのような閉路のうち辺数が最小の閉路の辺数を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ $ \vdots $ $ a_M $ $ b_M $

## 输出格式

頂点 $ 1 $ を含む閉路が存在する場合は、そのような閉路のうち辺数が最小の閉路の辺数を出力せよ。そうでない場合は `-1` を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ M\ \leq\ \min\ \left(\ \frac{N(N-1)}{2},\ 2\ \times\ 10^5\ \right) $
- $ 1\ \leq\ a_i\ \leq\ N $
- $ 1\ \leq\ b_i\ \leq\ N $
- $ a_i\ \neq\ b_i $
- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ かつ $ (a_i,\ b_i)\ \neq\ (b_j,\ a_j) $
- 入力される値は全て整数
 
### Sample Explanation 1

頂点 $ 1 $ $ \to $ 頂点 $ 2 $ $ \to $ 頂点 $ 3 $ $ \to $ 頂点 $ 1 $ は辺数が $ 3 $ の閉路で、これが頂点 $ 1 $ を含む唯一の閉路です。

## 样例 #1

### 输入

```
3 3

1 2

2 3

3 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 2

1 2

2 3
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
6 9

6 1

1 5

2 6

2 1

3 6

4 2

6 4

3 5

5 4
```

### 输出

```
4
```



---

---
title: "[ABC382D] Keep Distance"
layout: "post"
diff: 普及/提高-
pid: AT_abc382_d
tag: ['深度优先搜索 DFS', '剪枝']
---

# [ABC382D] Keep Distance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_d

整数 $ N $ と $ M $ が与えられます。

以下の条件をすべて満たす長さ $ N $ の整数列 $ (A_1,\ A_2,\ \ldots,\ A_N) $ を辞書順にすべて出力してください。

- $ 1\ \leq\ A_i $
- $ 2 $ 以上 $ N $ 以下の各整数 $ i $ に対して $ A_{i\ -\ 1}\ +\ 10\ \leq\ A_i $
- $ A_N\ \leq\ M $
 
  数列の辞書順とは長さ $ N $ の数列 $ S\ =\ (S_1,\ S_2,\ \ldots,\ S_N) $ が長さ $ N $ の数列 $ T\ =\ (T_1,\ T_2,\ \ldots,\ T_N) $ より**辞書順で小さい**とは、ある整数 $ 1\ \leq\ i\ \leq\ N $ が存在して下記の $ 2 $ つがともに成り立つことをいいます。

- $ (S_1,\ S_2,\ \ldots,\ S_{i-1})\ =\ (T_1,\ T_2,\ \ldots,\ T_{i-1}) $
- $ S_i $ が $ T_i $ より（数として）小さい。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $

## 输出格式

条件を満たす長さ $ N $ の整数列の個数を $ X $ として $ X\ +\ 1 $ 行出力せよ。

$ 1 $ 行目には $ X $ の値を出力せよ。

$ i\ +\ 1 $ ($ 1\ \leq\ i\ \leq\ X $) 行目には条件を満たす整数列のうち辞書順で $ i $ 番目に小さいものを空白区切りで出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 12 $
- $ 10N\ -\ 9\ \leq\ M\ \leq\ 10N $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (1,\ 11,\ 21),\ (1,\ 11,\ 22),\ (1,\ 11,\ 23),\ (1,\ 12,\ 22),\ (1,\ 12,\ 23),\ (1,\ 13,\ 23),\ (2,\ 12,\ 22),\ (2,\ 12,\ 23),\ (2,\ 13,\ 23),\ (3,\ 13,\ 23) $ の $ 10 $ 個の数列が条件を満たします。

## 样例 #1

### 输入

```
3 23
```

### 输出

```
10

1 11 21

1 11 22

1 11 23

1 12 22

1 12 23

1 13 23

2 12 22

2 12 23

2 13 23

3 13 23
```



---

---
title: "[ABC384E] Takahashi is Slime 2"
layout: "post"
diff: 普及/提高-
pid: AT_abc384_e
tag: ['贪心', '广度优先搜索 BFS', '优先队列']
---

# [ABC384E] Takahashi is Slime 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc384/tasks/abc384_e

縦 $ H $ 行横 $ W $ 列のマス目があります。 上から $ i $ 行目 $ (1\leq\ i\leq\ H) $、左から $ j $ 列目 $ (1\leq\ j\leq\ W) $ のマスをマス $ (i,j) $ と呼ぶことにします。

はじめ、マス $ (i,j) $ には強さ $ S\ _\ {i,j} $ のスライムがおり、マス $ (P,Q) $ にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（$ 0 $ 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

- 高橋くんに隣接するスライムのうち、強さが高橋くんの強さの $ \dfrac1X $ 倍**未満**のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
 
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ X $
>
>$ P $ $ Q $
>
>$ S_{1,1} $ $ S_{1,2} $ $ \ldots $ $ S_{1,W} $
>
> $ S_{2,1} $ $ S_{2,2} $ $ \ldots $ $ S_{2,W} $
>
> $ \vdots $
>
>$ S_{H,1} $ $ S_{H,2} $ $ \ldots $ $ S_{H,W} $

## 输出格式

高橋くんが行動を行ったあとの高橋くんの強さとしてありえる最大値を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq500 $
- $ 1\leq\ P\leq\ H $
- $ 1\leq\ Q\leq\ W $
- $ 1\leq\ X\leq10^9 $
- $ 1\leq\ S_{i,j}\leq10^{12} $
- 入力はすべて整数
 
### Sample Explanation 1

はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。 
![](https://img.atcoder.jp/abc384/6b3d3bbde4767c7f5070ad0b1f202043.png) 例えば、高橋くんは次のように行動を行うことができます。 
![](https://img.atcoder.jp/abc384/81c0ccdba241277bf0cdd16ae6a7c54d.png) - マス $ (2,1) $ にいるスライムを吸収する。高橋くんの強さは $ 9+4=13 $ となり、新たにマス $ (1,1) $ のスライムとマス $ (3,1) $ のスライムが高橋くんと隣接する。 - マス $ (1,2) $ にいるスライムを吸収する。高橋くんの強さは $ 13+6=19 $ となり、新たにマス $ (1,3) $ のスライムが高橋くんと隣接する。 - マス $ (1,3) $ にいるスライムを吸収する。高橋くんの強さは $ 19+9=28 $ となる。 以上の行動を行ったあと、高橋くんの強さは $ 28 $ となります。 高橋くんがどのように行動を行っても、高橋くんの強さを $ 28 $ より大きくすることはできないため、`28` を出力してください。 高橋くんの強さの $ \dfrac12 $ 倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス $ (1,1) $ にいるスライムを吸収することはできません。

### Sample Explanation 2

高橋くんはどのスライムも吸収できません。

## 样例 #1

### 输入

```
3 3 2

2 2

14 6 9

4 9 20

17 15 7
```

### 输出

```
28
```

## 样例 #2

### 输入

```
3 4 1

1 1

5 10 1 1

10 1 1 1

1 1 1 1
```

### 输出

```
5
```

## 样例 #3

### 输入

```
8 10 2

1 5

388 130 971 202 487 924 247 286 237 316

117 166 918 106 336 928 493 391 235 398

124 280 425 955 212 988 227 222 307 226

336 302 478 246 950 368 291 236 170 101

370 200 204 141 287 410 388 314 205 460

291 104 348 337 404 399 416 263 415 339

105 420 302 334 231 481 466 366 401 452

119 432 292 403 371 417 351 231 482 184
```

### 输出

```
1343
```



---

---
title: "[ABC386E] Maximize XOR"
layout: "post"
diff: 普及/提高-
pid: AT_abc386_e
tag: ['搜索', '深度优先搜索 DFS', '剪枝']
---

# [ABC386E] Maximize XOR

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$ 和一个整数 $K$。保证二项式系数 $\dbinom{N}{K} \leq 10^6$。

从序列 $A$ 中选择 $K$ 个不同的元素，求出这些元素的异或和的最大值。

简单来说，就是求 $\underset{1 \leq i_1 < i_2 < \ldots < i_K \leq N}{\max} A_{i_1} \oplus A_{i_2} \oplus \ldots \oplus A_{i_K}$。

在这里，异或运算（XOR）是这样定义的：对于两个非负整数 $A$ 和 $B$，其结果 $A \oplus B$ 是一个二进制数，对于每个 $2^k \ (k \geq 0)$ 位，如果 $A$ 和 $B$ 在这一位中恰好只有一个是 $1$，则结果在这一位是 $1$，否则为 $0$。

举个例子：$3 \oplus 5 = 6$，在二进制下：$011 \oplus 101 = 110$。通常来说，$k$ 个整数 $p_1, \dots, p_k$ 的异或值可以表示为 $(\cdots ((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k)$，并且顺序不会影响结果。

## 输入格式

从标准输入中获取输入，格式如下：

> $N \ K \ A_1 \ A_2 \ \ldots \ A_N$

## 输出格式

请输出那个最大可能的异或值。

## 说明/提示

- $1 \leq K \leq N \leq 2 \times 10^5$
- $0 \leq A_i < 2^{60}$
- $\dbinom{N}{K} \leq 10^6$
- 所有输入均为整数

### 示例解释 1

从 $(3, 2, 6, 4)$ 中选出任意两个不同的数，有以下六种组合方式：
- 选择 $(3, 2)$：异或值为 $3 \oplus 2 = 1$。
- 选择 $(3, 6)$：异或值为 $3 \oplus 6 = 5$。
- 选择 $(3, 4)$：异或值为 $3 \oplus 4 = 7$。
- 选择 $(2, 6)$：异或值为 $2 \oplus 6 = 4$。
- 选择 $(2, 4)$：异或值为 $2 \oplus 4 = 6$。
- 选择 $(6, 4)$：异或值为 $6 \oplus 4 = 2$。

因此，最大异或值为 $7$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4 2
3 2 6 4
```

### 输出

```
7
```

## 样例 #2

### 输入

```
10 4
1516 1184 1361 2014 1013 1361 1624 1127 1117 1759
```

### 输出

```
2024
```



---

---
title: "[ABC400D] Takahashi the Wall Breaker"
layout: "post"
diff: 普及/提高-
pid: AT_abc400_d
tag: ['图论', '广度优先搜索 BFS', '最短路']
---

# [ABC400D] Takahashi the Wall Breaker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc400/tasks/abc400_d

高桥君想去鱼店买鳗鱼。

高桥君居住的城镇由 $H$ 行 $W$ 列的网格状区域构成，每个区域是道路或墙壁。  
以下，将从上往下第 $i$ 行（$1 \leq i \leq H$）、从左往右第 $j$ 列（$1 \leq j \leq W$）的区域表示为区域 $(i, j)$。  
各区域的信息由 $H$ 个长度为 $W$ 的字符串 $S_1, S_2, \ldots, S_H$ 给出。具体来说，当 $S_i$ 的第 $j$ 个字符（$1 \leq i \leq H$，$1 \leq j \leq W$）为 `.` 时，区域 $(i, j)$ 是道路；当为 `#` 时，区域 $(i, j)$ 是墙壁。

高桥君可以按任意顺序重复执行以下两种操作：

- 移动到上下左右相邻的、位于城镇内且为道路的区域。
- 选择一个上下左右方向，进行**前踢**。  
  当高桥君进行前踢时，可以将当前区域在该方向上 **前 1 格** 和 **前 2 格** 的区域（如果它们是墙壁）变为道路。  
  注意：即使前 1 格或前 2 格位于城镇外，仍然可以进行前踢操作，但城镇外的区域不会发生变化。

高桥君最初位于区域 $(A, B)$，想要到达位于区域 $(C, D)$ 的鱼店。  
保证高桥君初始所在的区域及鱼店所在的区域是道路。  
请计算高桥君到达鱼店所需的最小**前踢次数**。

## 输入格式

输入通过标准输入给出，格式如下：

> $H$ $W$  
> $S_1$  
> $S_2$  
> $\vdots$  
> $S_H$  
> $A$ $B$ $C$ $D$

## 输出格式

输出高桥君到达鱼店所需的最小**前踢次数**。


## 说明/提示

### 约束条件

- $1 \leq H \leq 1000$
- $1 \leq W \leq 1000$
- $S_i$ 是仅由 `.` 和 `#` 组成的长度为 $W$ 的字符串
- $1 \leq A, C \leq H$
- $1 \leq B, D \leq W$
- $(A, B) \neq (C, D)$
- $H, W, A, B, C, D$ 均为整数
- 高桥君初始所在的区域及鱼店所在的区域保证是道路

### 样例解释 1

高桥君最初位于区域 $(1, 1)$。通过反复移动到道路区域，可以到达区域 $(7, 4)$。在区域 $(7, 4)$ 向左方向进行前踢后，区域 $(7, 3)$ 和 $(7, 2)$ 会从墙壁变为道路。之后，通过反复移动（包括新变为道路的区域）即可到达位于区域 $(7, 1)$ 的鱼店。此时前踢次数为 $1$ 次，且无法在不使用前踢的情况下到达鱼店，因此输出 $1$。

### 样例解释 2

高桥君最初位于区域 $(1, 1)$。向右方向进行前踢后，区域 $(1, 2)$ 会从墙壁变为道路（向右前 2 格超出城镇范围，因此无变化）。之后可以从区域 $(1, 1)$ 移动到区域 $(1, 2)$，再到达区域 $(2, 2)$ 的鱼店。此时前踢次数为 $1$ 次，且无法在不使用前踢的情况下到达鱼店，因此输出 $1$。

### 样例解释 3

前踢操作可能影响包含鱼店所在区域的区画，但鱼店所在区域原本就是道路，因此不会发生变化。特别是前踢操作不会破坏鱼店。

翻译由 DeepSeek R1 完成

## 样例 #1

### 输入

```
10 10

..........

#########.

#.......#.

#..####.#.

##....#.#.

#####.#.#.

.##.#.#.#.

###.#.#.#.

###.#.#.#.

#.....#...

1 1 7 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 2

.#

#.

1 1 2 2
```

### 输出

```
1
```

## 样例 #3

### 输入

```
1 3

.#.

1 1 1 3
```

### 输出

```
1
```

## 样例 #4

### 输入

```
20 20

####################

##...##....###...###

#.....#.....#.....##

#..#..#..#..#..#..##

#..#..#....##..#####

#.....#.....#..#####

#.....#..#..#..#..##

#..#..#.....#.....##

#..#..#....###...###

####################

####################

##..#..##...###...##

##..#..#.....#.....#

##..#..#..#..#..#..#

##..#..#..#..#..#..#

##.....#..#..#..#..#

###....#..#..#..#..#

#####..#.....#.....#

#####..##...###...##

####################

3 3 18 18
```

### 输出

```
3
```



---

---
title: "[ABC405D] Escape Route"
layout: "post"
diff: 普及/提高-
pid: AT_abc405_d
tag: ['广度优先搜索 BFS']
---

# [ABC405D] Escape Route

## 题目描述

高桥去到了电影院。在电影院的地面上，每块瓷砖上都画有指向最近的安全出口的箭头。

给你一个 $H$ 行 $W$ 列的网格 $S$，其中 `.` 表示空白地面，`#` 表示不可穿过的墙，`E` 表示安全出口。

在一个空白格子，你可以用一步移动到相邻的非墙格子。两个格子相邻当且仅当它们有公共的边。

令从一个空白格子 $(i,j)$ 移动到任意一个安全出口需要的最小步数为 $d(i,j)$。\
你需要在所有空白的格子上画上箭头（指向上下左右中的一个），使得从每一个空白格子 $(i,j)$ 开始，每次向当前所在格子的箭头方向走一步，恰好 $d(i,j)$ 步后将到达安全出口。

**数据保证每一个空白格子都可以到达至少一个安全出口。**

## 输入格式

第一行两个整数 $H,W(2\le H,W\le 1000)$。\
接下来 $H$ 行，每行一个长度为 $W$ 的字符串，构成网格 $S$。

数据保证每一个空白格子都可以到达至少一个安全出口。

## 输出格式

输出在所有空白格子填上箭头后的 $S$。你要用 `^` 表示向上的箭头，`v` 表示向下的箭头，`<` 表示向左的箭头，`>` 表示向右的箭头。

## 说明/提示

**样例 1 解释**

在样例输出中，$d(2,3)=2$，并且沿着箭头格子 $(2,3)$ 需要恰好 $2$ 步到达安全出口。

其他所有空白格子也满足像这样的条件。

**样例 2 解释**

存在没有空白格子或安全出口的情况。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
3 4
...E
.#..
....
```

### 输出

```
>>>E
^#>^
>>>^
```

## 样例 #2

### 输入

```
3 2
##
##
##
```

### 输出

```
##
##
##
```

## 样例 #3

### 输入

```
7 20
....................
..#..#..####..#E##..
..#..#..#..#..#.....
..E###..#..#..####..
.....#..#..E.....#..
.....#..####..####..
....................
```

### 输出

```
>v<<<<<>>>>>>>>v<<<<
>v#^<#^^####v^#E##vv
>v#^<#v^#>v#vv#^<<<<
>>E###vv#>v#vv####^<
>>^<<#vv#>>E<<<<<#^<
>>^<<#vv####^<####^<
>>^<<<<<>>>>^<<<<<^<
```



---

---
title: "D - Domino Covering XOR"
layout: "post"
diff: 普及/提高-
pid: AT_abc407_d
tag: ['搜索', '深度优先搜索 DFS', '位运算']
---

# D - Domino Covering XOR

## 题目描述

有一个网格，网格中有 $H$ 行和 $W$ 列。让 $(i,j)$ 表示从顶部 $(1\leq i\leq H)$ 起第 $i$ 行的单元格，从左侧 $(1\leq j\leq W)$ 起第 $j$ 列的单元格。

单元格 $(i,j)\ (1\leq i\leq H,1\leq j\leq W)$ 上写有一个非负整数 $A_{i,j}$ 。

让我们在网格上放置零块或更多块多米诺骨牌。一块多米诺骨牌覆盖两个相邻的单元格，即以下两对中的一对：

- 单元格 $(i,j)$ 和 $(i,j+1)$ 为 $1\leq i\leq H,1\leq j\lt W$ ；
- 单元格 $(i,j)$ 和 $(i+1,j)$ ，代表 $1\leq i\lt H,1\leq j\leq W$ 。

任何一个单元格都不能被一块以上的多米诺骨牌覆盖。

对于多米诺骨牌的摆放，其**分数**定义为写在***未被任何骨牌覆盖的单元格中的所有整数的位XOR。

找出可能的最大得分。

什么是位XOR？

对于非负整数 $A$ 和 $B$ ，它们的位向 XOR $A \oplus B$ 定义如下：

- 在二进制中，如果 $A$ 和 $B$ 中正好有一个位有 $1$ ，则 $A \oplus B$ 的 $2^k$ 位（ $k \ge 0$ ）为 $1$ ，否则为 $0$ 。

例如， $3 \oplus 5 = 6$ （二进制为 $011 \oplus 101 = 110$ ）。  
对于 $k$ 非负整数 $p_1, p_2, p_3, \dots, p_k$ ，它们的位 XOR 为 $(\dots ((p_1 \oplus p_2) \oplus p_3) \oplus \dots \oplus p_k)$ ，可以证明这与操作数的顺序无关。

## 输入格式

输入内容由标准输入法提供，格式如下

```
$H$ $W$
$A _ {1,1}$ $A _ {1,2}$ $\ldots$ $A _ {1,W}$
$A _ {2,1}$ $A _ {2,2}$ $\ldots$ $A _ {2,W}$
$\vdots$
$A _ {H,1}$ $A _ {H,2}$ $\ldots$ $A _ {H,W}$
```

## 输出格式

输出答案。

## 说明/提示

- $1 \le H$
- $1 \le W$
- $HW \le 20$
- $0 \le A_{i,j} \lt 2^{60}$ ( $1 \le i \le H,\ 1 \le j \le W$ )
- 所有输入值均为整数。

## 样例 #1

### 输入

```
3 4
1 2 3 8
4 0 7 10
5 2 4 2
```

### 输出

```
15
```

## 样例 #2

### 输入

```
1 11
1 2 4 8 16 32 64 128 256 512 1024
```

### 输出

```
2047
```

## 样例 #3

### 输入

```
4 5
74832 16944 58683 32965 97236
52995 43262 51959 40883 58715
13846 24919 65627 11492 63264
29966 98452 75577 40415 77202
```

### 输出

```
131067
```



---

---
title: "[ABC408E] Minimum OR Path"
layout: "post"
diff: 普及/提高-
pid: AT_abc408_e
tag: ['搜索', '贪心', '并查集']
---

# [ABC408E] Minimum OR Path

## 题目描述

给定一个连通无向图，该图有 $N$ 个顶点和 $M$ 条边，且无自环，顶点编号从 $1$ 到 $N$，边编号从 $1$ 到 $M$。边 $i$ 双向连接顶点 $u_i$ 和 $v_i$，其边权为 $w_i$。

在从顶点 $1$ 到顶点 $N$ 的简单路径（即不会多次访问同一顶点的路径）中，求出该路径中所有边的权值的按位 $\mathrm{OR}$ 的最小可能值。

什么是按位 $\mathrm{OR}$ 运算？

非负整数 $A$ 和 $B$ 的按位 $\mathrm{OR}$，即 $A\ \mathrm{OR}\ B$，定义如下：

- 如果 $A$ 和 $B$ 的二进制表示中 $2^k$ 位至少有一位为 $1$，则 $A\ \mathrm{OR}\ B$ 的二进制表示中 $2^k(k \geq 0)$ 位上的数字为 $1$，否则为 $0$。

例如，$3\ \mathrm{OR}\ 5 = 7$（二进制表示为：$011\ \mathrm{OR}\ 101 = 111$）。
一般而言，$k$ 个非负整数 $p_1, p_2, p_3, \dots, p_k$的按位 $\mathrm{OR}$ 定义为 $(\dots ((p_1\ \mathrm{OR}\ p_2)\ \mathrm{OR}\ p_3)\ \mathrm{OR}\ \dots\ \mathrm{OR}\ p_k)$，并且可以证明这与 $p_1, p_2, p_3, \dots p_k$ 的顺序无关。

## 输入格式

输入来自标准输入，格式如下：

- 第一行两个整数 $N,M$。
- 接下来 $M$ 行每行三个整数，分别表示 $u_i,v_i,w_i$。

## 输出格式

输出一行一个整数表示答案。

## 说明/提示

### 约束

- $2\le N\le 2×10^5$
- $N-1\le M\le 2×10^5$
- $1\le u_i\le v_i\le N$
- $0\le w_i\le2^{30}$
- 给定图为连通图。
- 所有输入值均为整数。

### 样例 1 提示：

按顺序遍历边 $1,3,5$，并按顺序访问顶点 $1,2,3,4$，最终的按位 $\mathrm{OR}$ 为 $1\ \mathrm{OR}\ 2\ \mathrm{OR}\ 3=3$。

不可能使按位 $\mathrm{OR}$ 小于 $3$，因此输出 $3$。

### 样例 2 提示：

该图可能包含重边。

## 样例 #1

### 输入

```
4 5

1 2 1

1 3 4

2 3 2

2 4 4

3 4 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3 5

1 2 1

1 2 2

1 2 3

1 2 4

2 3 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
8 12

4 5 16691344

5 7 129642441

2 7 789275447

3 8 335307651

3 5 530163333

5 6 811293773

3 8 333712701

1 2 2909941

2 3 160265478

5 7 465414272

1 3 903373004

6 7 408299562
```

### 输出

```
468549631
```



---

---
title: "[ABC410D] XOR Shortest Walk"
layout: "post"
diff: 普及/提高-
pid: AT_abc410_d
tag: ['图论', '广度优先搜索 BFS', '记忆化搜索']
---

# [ABC410D] XOR Shortest Walk

## 题目描述

给你一个 $N$ 条边 $M$ 条边的有向图，第 $i$ 条边从结点 $A_i$ 连向结点 $B_i$，权值为 $W_i$。

求所有从 $1$ 到 $N$ 的路径中，可以重复经过同一个点和同一条边，路径上所有边权值的异或和的最小值。

## 输入格式

第一行两个整数 $N,M(2\le N\le 1000,0\le M\le 1000)$。\
接下来 $M$ 行，每行三个整数 $A_i,B_i,W_i(0\le W_i<2^{10})$。

## 输出格式

如果不存在 $1$ 到 $N$ 的路径，输出一行一个整数 $-1$。

否则，输出一行一个整数表示答案。

## 说明/提示

**样例 1 解释**

路径(边 $1$，边 $2$) 的边权异或和为 $1$。

**样例 2 解释**

路径(边 $1$，边 $2$，边 $3$，边 $4$) 的边权异或和为 $0$。

注意 $N$ 可能出现在路径的中间。

**样例 3 解释**

如果不存在 $1$ 到 $N$ 的路径，输出 $-1$。

By @[chenxi2009](/user/1020063)

## 样例 #1

### 输入

```
3 3

1 2 4

2 3 5

1 3 2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 4

1 4 7

4 2 2

2 3 4

3 4 1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
999 4

1 2 9

2 1 8

1 2 7

1 1 6
```

### 输出

```
-1
```



---

---
title: "[AGC033A] Darker and Darker"
layout: "post"
diff: 普及/提高-
pid: AT_agc033_a
tag: ['广度优先搜索 BFS']
---

# [AGC033A] Darker and Darker

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc033/tasks/agc033_a

縦 $ H $ 行、横 $ W $ 列の白黒に塗られたマス目が与えられます。 マス目の状態は $ A_{11} $ から $ A_{HW} $ の $ HW $ 個の文字で表されており、 上から $ i $ 行目、左から $ j $ 列目にあるマスが黒色のとき $ A_{ij} $ は `#`、 上から $ i $ 行目、左から $ j $ 列目にあるマスが白色のとき $ A_{ij} $ は `.` となっています。

すべてのマスが黒色になるまで、以下の操作を繰り返し行います。

- 辺を共有して隣接するマスの中に、黒色のマスが一つ以上存在するような白色のマスすべてが黒色になる。

何回の操作を行うことになるか求めてください。 ただし、最初に与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在します。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ A_{11} $$ A_{12} $$ ... $$ A_{1W} $ $ : $ $ A_{H1} $$ A_{H2} $$ ... $$ A_{HW} $

## 输出格式

行われる操作の回数を出力せよ。

## 说明/提示

### 制約

- $ 1\ ≦\ H,W\ ≦\ 1000 $
- $ A_{ij} $ は `#` または `.`
- 与えられるマス目には少なくとも $ 1 $ つ黒色のマスが存在する。

### Sample Explanation 1

操作を一回行うとマス目の四隅以外が黒色になり、もう一度操作を行うとすべてのマス目が黒色になります。

## 样例 #1

### 输入

```
3 3

...

.#.

...
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 6

..#..#

......

#..#..

......

.#....

....#.
```

### 输出

```
3
```



---

---
title: "[AGC043A] Range Flip Find Route"
layout: "post"
diff: 普及/提高-
pid: AT_agc043_a
tag: ['动态规划 DP', '广度优先搜索 BFS']
---

# [AGC043A] Range Flip Find Route

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc043/tasks/agc043_a

$ H $ 行 $ W $ 列のマス目を考えます。上から $ r $ 番目、左から $ c $ 番目のマスを $ (r,\ c) $ と表すことにします。 全てのマスはそれぞれ白か黒のどちらかの色に塗られています。

次のような経路が存在するとき、このマス目を"良い"状態と呼びます。

- 常に白いマスの上にいながら、$ (1,\ 1) $ から、一つ **右か下** のマスに移動することを繰り返し、 $ (H,\ W) $ へ移動する。

ここで、"良い"状態ならば $ (1,\ 1) $ や $ (H,\ W) $ が必ず白いことに注意してください。

あなたの仕事は、以下の操作を繰り返し、マス目を"良い"状態にすることです。最小で何回操作を行う必要があるか求めてください。なお、有限回の操作で必ず"良い"状態に出来ることが証明可能です。

- $ 4 $ つの整数 $ r_0,\ c_0,\ r_1,\ c_1(1\ \leq\ r_0\ \leq\ r_1\ \leq\ H,\ 1\ \leq\ c_0\ \leq\ c_1\ \leq\ W) $ を選ぶ。$ r_0\ \leq\ r\ \leq\ r_1,\ c_0\ \leq\ c\ \leq\ c_1 $ を満たす全ての $ r,\ c $ について、$ (r,\ c) $ の色を変更する。つまり、白色ならば黒色にし、黒色ならば白色にする。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ s_{11}\ s_{12}\ \cdots\ s_{1W} $ $ s_{21}\ s_{22}\ \cdots\ s_{2W} $ $ \vdots $ $ s_{H1}\ s_{H2}\ \cdots\ s_{HW} $

ここで、$ s_{rc} $ は `#` か `.` であり、`#` は $ (r,\ c) $ が黒色、`.` は白色であることを表す。

## 输出格式

最小の操作回数を出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ H,\ W\ \leq\ 100 $

### Sample Explanation 1

$ (r_0,\ c_0,\ r_1,\ c_1)\ =\ (2,\ 2,\ 2,\ 2) $、つまりマス $ (2,\ 2) $ のみ色を変更すれば良いです。

### Sample Explanation 3

操作が必要ない場合も存在します。

## 样例 #1

### 输入

```
3 3

.##

.#.

##.
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 2

#.

.#
```

### 输出

```
2
```

## 样例 #3

### 输入

```
4 4

..##

#...

###.

###.
```

### 输出

```
0
```

## 样例 #4

### 输入

```
5 5

.#.#.

#.#.#

.#.#.

#.#.#

.#.#.
```

### 输出

```
4
```



---

---
title: "[ARC001C] パズルのお手伝い"
layout: "post"
diff: 普及/提高-
pid: AT_arc001_3
tag: ['搜索']
---

# [ARC001C] パズルのお手伝い

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc001/tasks/arc001_3



## 样例 #1

### 输入

```
........
........
.......Q
........
..Q.....
........
.Q......
........
```

### 输出

```
Q.......
....Q...
.......Q
.....Q..
..Q.....
......Q.
.Q......
...Q....
```

## 样例 #2

### 输入

```
.....Q..
.Q......
........
........
........
Q.......
........
........
```

### 输出

```
No Answer
```



---

---
title: "[ARC177C] Routing"
layout: "post"
diff: 普及/提高-
pid: AT_arc177_c
tag: ['广度优先搜索 BFS', '最短路']
---

# [ARC177C] Routing

## 题目描述

有一个 $N$ 行 $N$ 列（用 $(i, j)$ 表示矩阵第 $i$ 行第 $j$ 列的元素）的矩阵被刷满了红色和蓝色。现在要矩阵的一些格子刷上紫色，使得矩阵**同时**满足以下两个条件：
- 从 $(1, 1)$ 走到 $(N, N)$，保证存在一条路径使其只经过红色和紫色；
- 从 $(1, N)$ 走到 $(N, 1)$，保证存在一条路径使其只经过蓝色和紫色

注意，**行动时他可以往任何一个方向前进。**

那么，问题来了，至少要将多少格子刷成紫色才能使以上两个条件成立呢？

## 输入格式

输入共 $N+1$ 行。

第一行，读入 $N$;

接下来 $N$ 行，读入这个矩阵。其中以 `R`  代表红色，以 `B` 代表蓝色。

## 输出格式

输出仅一行，为最少刷成紫色的格子数。

**【约定】**

- $ 3\ \leq\ N\ \leq\ 500 $；
- 保证任意一个格子一定为 `R` 或 `B` 中的一个；
- 保证 $(1, 1)$ 和 $(N, N)$ 为红色；
- 保证 $(1, N)$ 和 $(N, 1)$ 为蓝色；
- 保证 $N$ 是一个整数。

**【样例解释】**

【样例 $1$ 解释】  
如下图，将 $ (1, 3),(3, 2),(4, 5) $ 三个格子刷成紫色可以达成目标。
![](https://cdn.luogu.com.cn/upload/image_hosting/zu2dn557.png)

【样例 $2$ 解释】  
如下图，将 $ (1, 2), (2, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5) $ 这 $7$ 个格子刷成紫色可以达成目标。
![](https://cdn.luogu.com.cn/upload/image_hosting/290k2d8o.png)

## 样例 #1

### 输入

```
5

RBRBB

RBRRR

RRRBR

RBBRB

BBRBR
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5

RBBBB

BBBBB

BBBBB

BBBBB

BBBBR
```

### 输出

```
7
```

## 样例 #3

### 输入

```
10

RRBBBBBBBB

BRRBBBBBBB

BBRRBBBBBB

BBBRRBBBBB

BBBBRRBBBB

BBBBBRRBBB

BBBBBBRRBB

BBBBBBBRRB

BBBBBBBBRR

BBBBBBBBBR
```

### 输出

```
2
```

## 样例 #4

### 输入

```
17

RBBRRBRRRRRBBBBBB

BBRBRBRRBRRBRRBBR

BRBRBBBRBBRBBRBBB

RBRRBBBBBBRRBRRRR

RRRRRBRBRRRBBRBBR

RRRRRBRRBRBBRRRBB

BBBRRRBRBRBBRRRBB

BBRRRBRBBBRBRRRBR

RRBBBBBBBBBBBRBRR

RRRBRRBRBRBRBRBBB

RRBRRRRBRBRRBRBBR

RRRBBRBRBBBRBBRBR

BBRBBRRBRRRBBRBBB

BBBRBRRRRRRRBBRBB

RRRRRBRBRBBRRBRRR

BRRRRBBBRRRBRRBBB

BBRRBBRRRBBBRBBBR
```

### 输出

```
8
```



---

---
title: "停止問題"
layout: "post"
diff: 普及/提高-
pid: AT_utpc2011_4
tag: ['模拟', '广度优先搜索 BFS', '深度优先搜索 DFS']
---

# 停止問題

## 题目描述

Defunge 程序由一个 $R$ 行 $C$ 列的字符数组组成。下面是一个 Defunge 程序的例子：

```plain
6>--v.
.^--_@
```

Defunge 程序从程序的左上角（即第一行第一列）开始执行。**它的执行方向一开始为"右"**，每次朝着执行方向走一步，**如果走出界了，要跳到另一边**。每走到一个格子上，就要执行这个格子上的命令。 Defunge 程序还有一个存储器，这个存储器只能存储 $[0,15]$ 的一个整数，**存储器一开始存储** $\bold{0}$。

在 Defunge 程序中，有且只有 $11+10=21$ 种命令，下面是它们各自的含义：

- `<`：把执行方向设置为"左"。
- `>`：把执行方向设置为"右"。
- `^`：把执行方向设置为"上"。
- `v`：把执行方向设置为"下"。
- `_`：如果存储器存储的数字是 $0$，就把执行方向设置为"右"，否则设置为"左"。
- `|`：如果存储器存储的数字是 $0$，就把执行方向设置为"下"，否则设置为"上"。
- `?`：把执行方向设置为"上下左右"中的**任意**一个（类似于 dfs 把四个方向全搜一遍）。
- `.`：什么也不做。
- `@`：停止程序。
- `0`-`9`：把存储器设置为这个字符表示的数值。
- `+`：让存储器的数值加 $1$。注意当存储器的数值为 $15$ 时要把它设为 $0$。
- `-`：让存储器的数值减 $1$。注意当存储器的数值为 $0$ 时要把它设为 $15$。

现在，给你一个 Defunge 程序，请判断这个程序是否能停止（即执行到命令`@`）。如果能，输出`YES`，否则输出`NO`。

## 输入格式

第一行两个正整数 $R,C$，表示这个 Defunge 程序有 $R$ 行 $C$ 列。

接下来 $R$ 行，每行有 $C$ 个字符，描述这个 Defunge 程序。

## 输出格式

一行字符串`YES`或`NO`，表示这个程序是否能停止。

【样例】

样例输入 $1$：

```plain
2 6
6>--v.
.^--_@
```

样例输出 $1$：

```plain
YES
```

样例输入 $2$：

```plain
2 6
5>--v.
.^--_@
```

样例输出 $2$：

```plain
NO
```

样例输入 $3$：

```plain
2 6
.>--v.
.^--?@
```

样例输出 $3$：

```plain
YES
```

## 说明/提示

$1\leq R,C\leq 20$，保证程序里只有上文提到的 $21$ 种命令。



---


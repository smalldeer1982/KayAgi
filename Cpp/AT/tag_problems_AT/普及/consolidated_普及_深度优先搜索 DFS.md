---
title: "[ABC029D] 1"
layout: "post"
diff: 普及/提高-
pid: AT_abc029_d
tag: ['搜索', '深度优先搜索 DFS', '数位 DP']
---

# [ABC029D] 1

## 题目描述

高桥先生用十进制标记一次性地在纸上写了  $1$ ~ $N$  以下的所有整数。 在这项工作中，高桥君写了几个  $1$  这样的数字呢？即求从 
 $1$ ~ $N$  中数字  $1$  出现的次数。（本题类似 P1980）

## 输出格式

说明： 对于  $20\%$  的数据，有  $1 \leq N \leq 999$ 。

对于  $100\%$  的数据，有  $1 \leq N \leq 10^9$ 。

感谢@初音Miku 提供的翻译

## 样例 #1

### 输入

```
12
```

### 输出

```
5
```

## 样例 #2

### 输入

```
345
```

### 输出

```
175
```

## 样例 #3

### 输入

```
999999999
```

### 输出

```
900000000
```



---

---
title: "[ABC126E] 1 or 2"
layout: "post"
diff: 普及/提高-
pid: AT_abc126_e
tag: ['图论', '并查集', '深度优先搜索 DFS', '连通块']
---

# [ABC126E] 1 or 2

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc126/tasks/abc126_e

$ N $ 枚のカードが一列に伏せられており、各カードには整数 $ 1 $ または $ 2 $ が書かれています。

$ i $ 番目のカードに書かれている整数を $ A_i $ とします。

あなたの目的は $ A_1,\ A_2,\ ...,\ A_N $ を当てることです。

次のことが分かっています。

- $ i\ =\ 1,\ 2,\ ...,\ M $ について $ A_{X_i}\ +\ A_{Y_i}\ +\ Z_i $ は偶数である。

あなたは魔法使いです。次の魔法を何度でも使うことができます。

**魔法**: コストを $ 1 $ 払う。カードを $ 1 $ 枚選び、そのカードに書かれた整数 $ A_i $ を知る。

最小で何コスト払えば、$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てることができるでしょうか。

なお、与えられる入力には矛盾がないことが保証されます。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $ $ X_1 $ $ Y_1 $ $ Z_1 $ $ X_2 $ $ Y_2 $ $ Z_2 $ $ \vdots $ $ X_M $ $ Y_M $ $ Z_M $

## 输出格式

$ A_1,\ A_2,\ ...,\ A_N $ 全てを確実に当てるために払う必要のあるコストの合計の最小値を出力せよ。

## 说明/提示

### 制約

- 入力は全て整数である。
- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ M\ \leq\ 10^5 $
- $ 1\ \leq\ X_i\ <\ Y_i\ \leq\ N $
- $ 1\ \leq\ Z_i\ \leq\ 100 $
- $ (X_i,\ Y_i) $ の組は互いに異なる。
- 与えられる入力には矛盾がない(すなわち、条件を満たす $ A_1,\ A_2,\ ...,\ A_N $ が存在する)。

### Sample Explanation 1

$ 1 $ 枚目と $ 3 $ 枚目のカードに対してそれぞれ $ 1 $ 回ずつ魔法を使えば、$ A_1,\ A_2,\ A_3 $ 全てを当てることができます。

## 样例 #1

### 输入

```
3 1

1 2 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 5

1 2 1

2 3 2

1 3 3

4 5 4

5 6 5
```

### 输出

```
2
```

## 样例 #3

### 输入

```
100000 1

1 100000 100
```

### 输出

```
99999
```



---

---
title: "[ABC345D] Tiling"
layout: "post"
diff: 普及/提高-
pid: AT_abc345_d
tag: ['搜索', '深度优先搜索 DFS']
---

# [ABC345D] Tiling

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc345/tasks/abc345_d

一辺の長さが $ 1 $ のマスからなる $ H $ 行 $ W $ 列のマス目と、$ N $ 枚のタイルがあります。  
$ i $ $ (1\leq\ i\leq\ N) $ 枚目のタイルは $ A_i\times\ B_i $ の長方形です。  
以下の条件をすべてみたすようにタイルをマス目に置くことができるか判定してください。

- 全てのマスがちょうど $ 1 $ 枚のタイルで覆われている。
- 使用されないタイルがあっても良い。
- 使用するタイルは **回転したり裏返したりして置かれていても良い**。ただし、各タイルはマスの線に合わせてマス目からはみ出ることがないように置かれていなければならない。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ H $ $ W $ $ A_1 $ $ B_1 $ $ A_2 $ $ B_2 $ $ \vdots $ $ A_N $ $ B_N $

## 输出格式

問題文中の条件をみたすようにタイルをマス目に置くことができるならば `Yes` を、そうでないならば `No` を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ N\leq\ 7 $
- $ 1\ \leq\ H,W\ \leq\ 10 $
- $ 1\leq\ A_i,B_i\leq\ 10 $
- 入力はすべて整数

### Sample Explanation 1

$ 2,4,5 $ 枚目のタイルを使用して次のように置くと、マス目の各マスをちょうど $ 1 $ 枚のタイルで覆うことができます。 !\[\](https://img.atcoder.jp/abc345/0a0f2829d0485013deabba0103dbd906.png) よって、`Yes` を出力します。

### Sample Explanation 2

マス目からはみ出さないようにタイルを置くことはできません。 よって、`No` を出力します。

### Sample Explanation 3

全てのマスを覆うようにタイルを置くことができません。 よって、`No` を出力します。

### Sample Explanation 4

全てのマスはちょうど $ 1 $ 枚のタイルで覆われている必要があることに注意してください。

## 样例 #1

### 输入

```
5 5 5
1 1
3 3
4 4
2 3
2 5
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
1 1 2
2 3
```

### 输出

```
No
```

## 样例 #3

### 输入

```
1 2 2
1 1
```

### 输出

```
No
```

## 样例 #4

### 输入

```
5 3 3
1 1
2 2
2 2
2 2
2 2
```

### 输出

```
No
```



---

---
title: "[ABC351D] Grid and Magnet"
layout: "post"
diff: 普及/提高-
pid: AT_abc351_d
tag: ['搜索', '广度优先搜索 BFS', '深度优先搜索 DFS']
---

# [ABC351D] Grid and Magnet

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc351/tasks/abc351_d

$ H $ 行 $ W $ 列のマス目があり、いくつか（$ 0 $ 個のこともある）のマスには磁石が置かれています。  
マス目の状態は $ H $ 個の 長さ $ W $ の文字列 $ S_1,S_2,\ldots,S_H $ で表され、 $ S_i $ の $ j $ 文字目が `#` のとき上から $ i $ 行目かつ左から $ j $ 列目のマスには磁石が置かれていることを、 `.` のとき何も置かれていないことを表しています。

高橋君は鉄の鎧を着ており、あるマスにいるとき次のように移動することができます。

- 現在いるマスの上下左右に隣り合うマスのいずれかに磁石が置かれているとき、どこへも移動することができない。
- そうでないとき、上下左右に隣り合うマスのいずれかを選んでそのマスに移動することができる。  
  ただし、マス目の外に移動することはできない。

磁石が置かれていない各マスについて、そのマスの自由度を、「最初高橋くんがそのマスにいるとき、そこから移動を繰り返して到達できるマスの個数」として定義します。 マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を求めてください。

ただし、自由度の定義において、「移動を繰り返して到達できるマス」とは、最初にいるマスからそのマスまで移動を繰り返して到達する方法（$ 1 $ 回も移動しないものも含む）が $ 1 $ つ以上存在するようなマスのことであり、 最初のマスから始めてすべてのそのようなマスを巡るような移動方法が存在する必要はありません。特に（磁石の置かれていない）各マス自身は、そのマスから「移動を繰り返して到達できるマス」につねに含まれることに注意してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ H $ $ W $ $ S_1 $ $ S_2 $ $ \vdots $ $ S_H $

## 输出格式

マス目のうち磁石が置かれていないマスの中における、マスの自由度の最大値を出力せよ。

## 说明/提示

### 制約

- $ 1\leq\ H,W\leq\ 1000 $
- $ H,W $ は整数
- $ S_i $ は `.` と `#` のみからなる長さ $ W $ の文字列
- 磁石の置かれていないマスが少なくとも $ 1 $ つ存在する。

### Sample Explanation 1

上から $ i $ 行目かつ左から $ j $ 列目のマスを $ (i,j) $ で表します。 高橋君が最初に $ (2,3) $ にいるとき、高橋君の移動の例としては次のようなものなどが考えられます。 - $ (2,3)\to\ (2,4)\to\ (1,4)\to\ (1,5)\to\ (2,5) $ - $ (2,3)\to\ (2,4)\to\ (3,4) $ - $ (2,3)\to\ (2,2) $ - $ (2,3)\to\ (1,3) $ - $ (2,3)\to\ (3,3) $ よって、途中で到達しているマスも含めて高橋君は $ (2,3) $ から少なくとも $ 9 $ 個のマスに到達することができます。 一方、これら以外のマスには到達することができないため、$ (2,3) $ の自由度は $ 9 $ となります。 これは磁石が置かれていない各マスの自由度のうち最大であるため、$ 9 $ を出力します。

### Sample Explanation 2

磁石が置かれていないどのマスについても、上下左右に隣り合うマスのいずれかに磁石が置かれています。 よって、磁石が置かれていないどのマスからも移動することはできず、マスの自由度は $ 1 $ となります。 そのため、$ 1 $ を出力します。

## 样例 #1

### 输入

```
3 5
.#...
.....
.#..#
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3 3
..#
#..
..#
```

### 输出

```
1
```



---

---
title: "[ABC368D] Minimum Steiner Tree"
layout: "post"
diff: 普及/提高-
pid: AT_abc368_d
tag: ['深度优先搜索 DFS']
---

# [ABC368D] Minimum Steiner Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc368/tasks/abc368_d

頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点の木が与えられます。$ i $ 番目の辺は頂点 $ A_i $ と頂点 $ B_i $ を結んでいます。

このグラフからいくつかの($ 0 $ 個でもよい)辺と頂点を削除してできる木のうち、指定された $ K $ 個の頂点、頂点 $ V_1,\ldots,V_K $ を全て含むようなものの頂点数の最小値を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ K $ $ A_1 $ $ B_1 $ $ \vdots $ $ A_{N-1} $ $ B_{N-1} $ $ V_1 $ $ \ldots $ $ V_K $

## 输出格式

答えを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ K\ \leq\ N\ \leq\ 2\times\ 10^5 $
- $ 1\ \leq\ A_i,B_i\ \leq\ N $
- $ 1\ \leq\ V_1\ <\ V_2\ <\ \ldots\ <\ V_K\ \leq\ N $
- 与えられるグラフは木である
- 入力は全て整数

### Sample Explanation 1

与えられた木は下図左の通りであり、そこからいくつかの辺と頂点を削除してできる木のうち頂点 $ 1,3,5 $ を全て含むような頂点数最小のものは下図右の通りです。 
![図](https://img.atcoder.jp/abc368/4baf6b0adb0e12dcf8a5c812ada5c17a.png)

## 样例 #1

### 输入

```
7 3
1 2
1 3
2 4
2 5
3 6
3 7
1 3 5
```

### 输出

```
4
```

## 样例 #2

### 输入

```
4 4
3 1
1 4
2 1
1 2 3 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5 1
1 4
2 3
5 2
1 2
1
```

### 输出

```
1
```



---

---
title: "[ABC374D] Laser Marking"
layout: "post"
diff: 普及/提高-
pid: AT_abc374_d
tag: ['深度优先搜索 DFS']
---

# [ABC374D] Laser Marking

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc374/tasks/abc374_d

$ xy $ 平面に対し、レーザを照射しながら線分を印字する印字機があります。

- 印字開始時、レーザ照射位置は座標 $ (0,\ 0) $ にある。
- 線分を印字する際は、以下の流れに従う。
  
  
  - まず、レーザ照射位置を線分の端点のうちどちらか $ 1 $ つに移動させる。
      - どちらの端点から描画を始めてもよい。
  - その後、レーザ照射位置のある端点からもう一方の端点まで、レーザを照射しながらレーザ照射位置を一直線に移動させる。
      - 線分の途中で印字を中止することは許されない。
- レーザを照射していない時、レーザ照射位置は $ 1 $ 秒あたり速度 $ S $ で任意の方向に移動できる。
- レーザを照射している時、レーザ照射位置は $ 1 $ 秒あたり速度 $ T $ で印字中の線分に沿って移動できる。
- レーザ照射位置の移動にかかる時間以外の所要時間は無視できる。

高橋君はこの印字機で $ N $ 本の線分を印字したいです。  
そのうち $ i $ 本目の線分は、座標 $ (A_i,\ B_i) $ と座標 $ (C_i,\ D_i) $ を結びます。  
なお、複数の線分が重なっていることがありますが、全ての線分についてその都度重なっている部分を印字する必要があります。

うまく印字機を操作したとき、全ての線分を印字完了するまでにかかる最小の時間は何秒ですか？

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ S $ $ T $ $ A_1 $ $ B_1 $ $ C_1 $ $ D_1 $ $ \vdots $ $ A_N $ $ B_N $ $ C_N $ $ D_N $

## 输出格式

答えを出力せよ。  
なお、真の値との絶対誤差または相対誤差が $ 10^{-6} $ 以下であれば正解として扱われる。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ N\ \le\ 6 $
- $ 1\ \le\ T\ \le\ S\ \le\ 1000 $
- $ -1000\ \le\ A_i,B_i,C_i,D_i\ \le\ 1000 $
- $ (A_i,B_i)\ \neq\ (C_i,D_i) $ ( $ 1\ \le\ i\ \le\ N $ )

### Sample Explanation 1

\- レーザを照射しながらレーザ照射位置を $ (0,0) $ から $ (0,2) $ まで移動させ、 $ 2 $ 本目の線分を描画する。 - この描画に要する時間は $ 2 $ 秒である。 - レーザを照射せずレーザ照射位置を $ (0,2) $ から $ (1,3) $ まで移動させる。 - この移動に要する時間は $ \sqrt{2}/2 $ 秒である。 - レーザを照射しながらレーザ照射位置を $ (1,3) $ から $ (2,1) $ まで移動させ、 $ 1 $ 本目の線分を描画する。 - この描画に要する時間は $ \sqrt{5} $ 秒である。 - レーザを照射せずレーザ照射位置を $ (2,1) $ から $ (2,0) $ まで移動させる。 - この移動に要する時間は $ 1/2 $ 秒である。 - レーザを照射しながらレーザ照射位置を $ (2,0) $ から $ (3,0) $ まで移動させ、 $ 3 $ 本目の線分を描画する。 - この描画に要する時間は $ 1 $ 秒である。 - 全体の所要時間は $ 2\ +\ (\sqrt{2}/2)\ +\ \sqrt{5}\ +\ (1/2)\ +\ 1\approx\ 6.443175 $ 秒です。

### Sample Explanation 3

複数の線分が重なっていますが、全ての線分についてその都度重なっている部分を印字する必要があります。

## 样例 #1

### 输入

```
3 2 1
1 3 2 1
0 2 0 0
3 0 2 0
```

### 输出

```
6.44317475868633722080
```

## 样例 #2

### 输入

```
2 1 1
0 0 10 10
0 2 2 0
```

### 输出

```
20.97056274847714058517
```

## 样例 #3

### 输入

```
6 3 2
-1000 -1000 1000 1000
1000 -1000 -1000 1000
-1000 -1000 1000 1000
1000 -1000 -1000 1000
1000 1000 -1000 -1000
-1000 1000 1000 -1000
```

### 输出

```
9623.35256169626864153344
```

## 样例 #4

### 输入

```
6 10 8
1000 1000 -1000 -1000
1000 -1000 -1000 -1000
-1000 1000 1000 1000
-1000 1000 -1000 -1000
1000 1000 1000 -1000
1000 -1000 -1000 1000
```

### 输出

```
2048.52813742385702910909
```



---

---
title: "[ABC382D] Keep Distance"
layout: "post"
diff: 普及/提高-
pid: AT_abc382_d
tag: ['深度优先搜索 DFS', '剪枝']
---

# [ABC382D] Keep Distance

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc382/tasks/abc382_d

整数 $ N $ と $ M $ が与えられます。

以下の条件をすべて満たす長さ $ N $ の整数列 $ (A_1,\ A_2,\ \ldots,\ A_N) $ を辞書順にすべて出力してください。

- $ 1\ \leq\ A_i $
- $ 2 $ 以上 $ N $ 以下の各整数 $ i $ に対して $ A_{i\ -\ 1}\ +\ 10\ \leq\ A_i $
- $ A_N\ \leq\ M $
 
  数列の辞書順とは長さ $ N $ の数列 $ S\ =\ (S_1,\ S_2,\ \ldots,\ S_N) $ が長さ $ N $ の数列 $ T\ =\ (T_1,\ T_2,\ \ldots,\ T_N) $ より**辞書順で小さい**とは、ある整数 $ 1\ \leq\ i\ \leq\ N $ が存在して下記の $ 2 $ つがともに成り立つことをいいます。

- $ (S_1,\ S_2,\ \ldots,\ S_{i-1})\ =\ (T_1,\ T_2,\ \ldots,\ T_{i-1}) $
- $ S_i $ が $ T_i $ より（数として）小さい。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ M $

## 输出格式

条件を満たす長さ $ N $ の整数列の個数を $ X $ として $ X\ +\ 1 $ 行出力せよ。

$ 1 $ 行目には $ X $ の値を出力せよ。

$ i\ +\ 1 $ ($ 1\ \leq\ i\ \leq\ X $) 行目には条件を満たす整数列のうち辞書順で $ i $ 番目に小さいものを空白区切りで出力せよ。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 12 $
- $ 10N\ -\ 9\ \leq\ M\ \leq\ 10N $
- 入力される値はすべて整数
 
### Sample Explanation 1

$ (1,\ 11,\ 21),\ (1,\ 11,\ 22),\ (1,\ 11,\ 23),\ (1,\ 12,\ 22),\ (1,\ 12,\ 23),\ (1,\ 13,\ 23),\ (2,\ 12,\ 22),\ (2,\ 12,\ 23),\ (2,\ 13,\ 23),\ (3,\ 13,\ 23) $ の $ 10 $ 個の数列が条件を満たします。

## 样例 #1

### 输入

```
3 23
```

### 输出

```
10

1 11 21

1 11 22

1 11 23

1 12 22

1 12 23

1 13 23

2 12 22

2 12 23

2 13 23

3 13 23
```



---

---
title: "[ABC386E] Maximize XOR"
layout: "post"
diff: 普及/提高-
pid: AT_abc386_e
tag: ['搜索', '深度优先搜索 DFS', '剪枝']
---

# [ABC386E] Maximize XOR

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$ 和一个整数 $K$。保证二项式系数 $\dbinom{N}{K} \leq 10^6$。

从序列 $A$ 中选择 $K$ 个不同的元素，求出这些元素的异或和的最大值。

简单来说，就是求 $\underset{1 \leq i_1 < i_2 < \ldots < i_K \leq N}{\max} A_{i_1} \oplus A_{i_2} \oplus \ldots \oplus A_{i_K}$。

在这里，异或运算（XOR）是这样定义的：对于两个非负整数 $A$ 和 $B$，其结果 $A \oplus B$ 是一个二进制数，对于每个 $2^k \ (k \geq 0)$ 位，如果 $A$ 和 $B$ 在这一位中恰好只有一个是 $1$，则结果在这一位是 $1$，否则为 $0$。

举个例子：$3 \oplus 5 = 6$，在二进制下：$011 \oplus 101 = 110$。通常来说，$k$ 个整数 $p_1, \dots, p_k$ 的异或值可以表示为 $(\cdots ((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k)$，并且顺序不会影响结果。

## 输入格式

从标准输入中获取输入，格式如下：

> $N \ K \ A_1 \ A_2 \ \ldots \ A_N$

## 输出格式

请输出那个最大可能的异或值。

## 说明/提示

- $1 \leq K \leq N \leq 2 \times 10^5$
- $0 \leq A_i < 2^{60}$
- $\dbinom{N}{K} \leq 10^6$
- 所有输入均为整数

### 示例解释 1

从 $(3, 2, 6, 4)$ 中选出任意两个不同的数，有以下六种组合方式：
- 选择 $(3, 2)$：异或值为 $3 \oplus 2 = 1$。
- 选择 $(3, 6)$：异或值为 $3 \oplus 6 = 5$。
- 选择 $(3, 4)$：异或值为 $3 \oplus 4 = 7$。
- 选择 $(2, 6)$：异或值为 $2 \oplus 6 = 4$。
- 选择 $(2, 4)$：异或值为 $2 \oplus 4 = 6$。
- 选择 $(6, 4)$：异或值为 $6 \oplus 4 = 2$。

因此，最大异或值为 $7$。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
4 2
3 2 6 4
```

### 输出

```
7
```

## 样例 #2

### 输入

```
10 4
1516 1184 1361 2014 1013 1361 1624 1127 1117 1759
```

### 输出

```
2024
```



---

---
title: "D - Domino Covering XOR"
layout: "post"
diff: 普及/提高-
pid: AT_abc407_d
tag: ['搜索', '深度优先搜索 DFS', '位运算']
---

# D - Domino Covering XOR

## 题目描述

有一个网格，网格中有 $H$ 行和 $W$ 列。让 $(i,j)$ 表示从顶部 $(1\leq i\leq H)$ 起第 $i$ 行的单元格，从左侧 $(1\leq j\leq W)$ 起第 $j$ 列的单元格。

单元格 $(i,j)\ (1\leq i\leq H,1\leq j\leq W)$ 上写有一个非负整数 $A_{i,j}$ 。

让我们在网格上放置零块或更多块多米诺骨牌。一块多米诺骨牌覆盖两个相邻的单元格，即以下两对中的一对：

- 单元格 $(i,j)$ 和 $(i,j+1)$ 为 $1\leq i\leq H,1\leq j\lt W$ ；
- 单元格 $(i,j)$ 和 $(i+1,j)$ ，代表 $1\leq i\lt H,1\leq j\leq W$ 。

任何一个单元格都不能被一块以上的多米诺骨牌覆盖。

对于多米诺骨牌的摆放，其**分数**定义为写在***未被任何骨牌覆盖的单元格中的所有整数的位XOR。

找出可能的最大得分。

什么是位XOR？

对于非负整数 $A$ 和 $B$ ，它们的位向 XOR $A \oplus B$ 定义如下：

- 在二进制中，如果 $A$ 和 $B$ 中正好有一个位有 $1$ ，则 $A \oplus B$ 的 $2^k$ 位（ $k \ge 0$ ）为 $1$ ，否则为 $0$ 。

例如， $3 \oplus 5 = 6$ （二进制为 $011 \oplus 101 = 110$ ）。  
对于 $k$ 非负整数 $p_1, p_2, p_3, \dots, p_k$ ，它们的位 XOR 为 $(\dots ((p_1 \oplus p_2) \oplus p_3) \oplus \dots \oplus p_k)$ ，可以证明这与操作数的顺序无关。

## 输入格式

输入内容由标准输入法提供，格式如下

```
$H$ $W$
$A _ {1,1}$ $A _ {1,2}$ $\ldots$ $A _ {1,W}$
$A _ {2,1}$ $A _ {2,2}$ $\ldots$ $A _ {2,W}$
$\vdots$
$A _ {H,1}$ $A _ {H,2}$ $\ldots$ $A _ {H,W}$
```

## 输出格式

输出答案。

## 说明/提示

- $1 \le H$
- $1 \le W$
- $HW \le 20$
- $0 \le A_{i,j} \lt 2^{60}$ ( $1 \le i \le H,\ 1 \le j \le W$ )
- 所有输入值均为整数。

## 样例 #1

### 输入

```
3 4
1 2 3 8
4 0 7 10
5 2 4 2
```

### 输出

```
15
```

## 样例 #2

### 输入

```
1 11
1 2 4 8 16 32 64 128 256 512 1024
```

### 输出

```
2047
```

## 样例 #3

### 输入

```
4 5
74832 16944 58683 32965 97236
52995 43262 51959 40883 58715
13846 24919 65627 11492 63264
29966 98452 75577 40415 77202
```

### 输出

```
131067
```



---

---
title: "停止問題"
layout: "post"
diff: 普及/提高-
pid: AT_utpc2011_4
tag: ['模拟', '广度优先搜索 BFS', '深度优先搜索 DFS']
---

# 停止問題

## 题目描述

Defunge 程序由一个 $R$ 行 $C$ 列的字符数组组成。下面是一个 Defunge 程序的例子：

```plain
6>--v.
.^--_@
```

Defunge 程序从程序的左上角（即第一行第一列）开始执行。**它的执行方向一开始为"右"**，每次朝着执行方向走一步，**如果走出界了，要跳到另一边**。每走到一个格子上，就要执行这个格子上的命令。 Defunge 程序还有一个存储器，这个存储器只能存储 $[0,15]$ 的一个整数，**存储器一开始存储** $\bold{0}$。

在 Defunge 程序中，有且只有 $11+10=21$ 种命令，下面是它们各自的含义：

- `<`：把执行方向设置为"左"。
- `>`：把执行方向设置为"右"。
- `^`：把执行方向设置为"上"。
- `v`：把执行方向设置为"下"。
- `_`：如果存储器存储的数字是 $0$，就把执行方向设置为"右"，否则设置为"左"。
- `|`：如果存储器存储的数字是 $0$，就把执行方向设置为"下"，否则设置为"上"。
- `?`：把执行方向设置为"上下左右"中的**任意**一个（类似于 dfs 把四个方向全搜一遍）。
- `.`：什么也不做。
- `@`：停止程序。
- `0`-`9`：把存储器设置为这个字符表示的数值。
- `+`：让存储器的数值加 $1$。注意当存储器的数值为 $15$ 时要把它设为 $0$。
- `-`：让存储器的数值减 $1$。注意当存储器的数值为 $0$ 时要把它设为 $15$。

现在，给你一个 Defunge 程序，请判断这个程序是否能停止（即执行到命令`@`）。如果能，输出`YES`，否则输出`NO`。

## 输入格式

第一行两个正整数 $R,C$，表示这个 Defunge 程序有 $R$ 行 $C$ 列。

接下来 $R$ 行，每行有 $C$ 个字符，描述这个 Defunge 程序。

## 输出格式

一行字符串`YES`或`NO`，表示这个程序是否能停止。

【样例】

样例输入 $1$：

```plain
2 6
6>--v.
.^--_@
```

样例输出 $1$：

```plain
YES
```

样例输入 $2$：

```plain
2 6
5>--v.
.^--_@
```

样例输出 $2$：

```plain
NO
```

样例输入 $3$：

```plain
2 6
.>--v.
.^--?@
```

样例输出 $3$：

```plain
YES
```

## 说明/提示

$1\leq R,C\leq 20$，保证程序里只有上文提到的 $21$ 种命令。



---


---
title: "[AGC020E] Encoding Subsets"
layout: "post"
diff: 省选/NOI-
pid: AT_agc020_e
tag: ['字符串', '枚举', '记忆化搜索', '位运算']
---

# [AGC020E] Encoding Subsets

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc020/tasks/agc020_e

次のような、`0` と `1` からなる文字列をエンコードする規則を考えます。

- 文字列 `0`、`1` はそれぞれ `0`、`1` とエンコードできる。
- 文字列 $ A $、$ B $ をそれぞれ $ P $、$ Q $ とエンコードできる場合、文字列 $ AB $ を $ PQ $ とエンコードできる。
- 文字列 $ A $ を $ P $ とエンコードできる場合、$ K\ \geq\ 2 $ を正の整数として、文字列 $ AA...A $（$ A $ を $ K $ 個連結したもの）を `(`$ P $`x`$ K $`)` とエンコードできる。

例えば、文字列 `001001001` は `001001001`、`00(1(0x2)x2)1`、`(001x3)` などとエンコードすることができ、この他のエンコード方法も存在します。

また、次の条件が満たされるとき、文字列 $ A $ は文字列 $ B $ の *サブセット* であると呼びます。

- $ A $ と $ B $ は長さが等しく、どちらも `0` と `1` からなる。
- $ A_i $ = `1` であるようなすべての添字 $ i $ に対して、$ B_i $ = `1` でもある。

`0` と `1` からなる文字列 $ S $ が与えられます。$ S $ のすべてのサブセットについて、それぞれをエンコードする方法が何通り存在するか求め、それらの個数の総和を $ 998244353 $ で割ったあまりを求めてください。

## 输入格式

入力は標準入力から以下の形式で与えられる。

> $ S $

## 输出格式

$ S $ のすべてのサブセットについてのエンコード方法の個数の総和を $ 998244353 $ で割ったあまりを出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ |S|\ \leq\ 100 $
- $ S $ は `0` と `1` からなる。

### Sample Explanation 1

$ S $ のサブセットは $ 4 $ 個存在し、 - `011` は `011`、`0(1x2)` とエンコードできます。 - `010` は `010` とエンコードできます。 - `001` は `001`、`(0x2)1` とエンコードできます。 - `000` は `000`、`0(0x2)`、`(0x2)0`、`(0x3)` とエンコードできます。 したがって、$ S $ のすべてのサブセットについてのエンコード方法の個数の総和は $ 2\ +\ 1\ +\ 2\ +\ 4\ =\ 9 $ 通りです。

### Sample Explanation 2

今回は $ S $ のサブセットは $ 1 $ 個しか存在しませんが、$ 10 $ 通りの方法でエンコードできます。

### Sample Explanation 4

結果を $ 998244353 $ で割ったあまりを出力することを忘れずに。

## 样例 #1

### 输入

```
011
```

### 输出

```
9
```

## 样例 #2

### 输入

```
0000
```

### 输出

```
10
```

## 样例 #3

### 输入

```
101110
```

### 输出

```
156
```

## 样例 #4

### 输入

```
001110111010110001100000100111
```

### 输出

```
363383189
```



---

---
title: "[AGC035C] Skolem XOR Tree"
layout: "post"
diff: 省选/NOI-
pid: AT_agc035_c
tag: ['位运算', '构造']
---

# [AGC035C] Skolem XOR Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc035/tasks/agc035_c

整数 $ N $ が与えられます。$ 1 $ から $ 2N $ までの番号がついた $ 2N $ 個の頂点を持つ木であって次の条件を満たすものが存在するか判定し、存在するならばその一例を示してください。

- $ 1 $ 以上 $ N $ 以下の各整数 $ i $ について、頂点 $ i,\ N+i $ の重みが $ i $ であるとする。このとき、$ 1 $ 以上 $ N $ 以下の各整数 $ i $ について、頂点 $ i,\ N+i $ 間のパス上にある頂点 (両端を含む) の重みのビットごとの排他的論理和が $ i $ である。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $

## 输出格式

問題文中の条件を満たす木が存在するならば `Yes` を、そうでなければ `No` を出力せよ。 その後、存在するならば続く $ 2N-1 $ 行にそのような木の $ 2N-1 $ 本の辺を以下の形式で出力せよ。

> $ a_{1} $ $ b_{1} $ $ \vdots $ $ a_{2N-1} $ $ b_{2N-1} $

ここで、各組 $ (a_i,\ b_i) $ は木に頂点 $ a_i,\ b_i $ を結ぶ辺が存在することを表す。辺は任意の順で出力して構わない。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \leq\ N\ \leq\ 10^{5} $

### Sample Explanation 1

\- 出力例は以下のグラフを表します。 !\[d004b05438497d50637b534e89f7a511.png\](https://img.atcoder.jp/agc035/d004b05438497d50637b534e89f7a511.png)

### Sample Explanation 2

\- 条件を満たす木が存在しません。

## 样例 #1

### 输入

```
3
```

### 输出

```
Yes

1 2

2 3

3 4

4 5

5 6
```

## 样例 #2

### 输入

```
1
```

### 输出

```
No
```



---

---
title: "[AGC039C] Division by Two with Something"
layout: "post"
diff: 省选/NOI-
pid: AT_agc039_c
tag: ['数论', '位运算']
---

# [AGC039C] Division by Two with Something

## 题目描述

现在给你一个整数$N$和一个二进制数$X$，对$0 \sim X$之间的每个整数$K$在返回到其原始值之前，需要执行多少次下面的操作：

如果$K$是奇数
	
$K=(K-1) \div 2$
 
如果$K$是偶数

$K=(K \div 2)+2^{N-1}$

当 $K$ 不可能返回原始值不计入操作次数。

## 输入格式

第一行输入一个整数$N$，第二行输入一个$N$位的整数$X$。

## 输出格式

一个整数，表示$0 \sim X$之间的每个整数$K$在返回到其原始值之前，需要执行的操作次数的总和。

**由于答案可能过大,请对最终答案$mod \text{ 998244353}$。**

## 说明/提示

- $1 \le N \le 2 \times10^5$
- $0 \le X < 2^N$
- $X$是一个长度为$N$的二进制数($X$的数位不足$N$时用前导$0$补齐)
- 所有数字都是整数

例如,$K = 3$时，操作为：1，0，4，6，7，3，所以$K=3$时答案是$6$。

## 样例 #1

### 输入

```
3

111
```

### 输出

```
40
```

## 样例 #2

### 输入

```
6

110101
```

### 输出

```
616
```

## 样例 #3

### 输入

```
30

001110011011011101010111011100
```

### 输出

```
549320998
```



---

---
title: "[AGC052B] Tree Edges XOR"
layout: "post"
diff: 省选/NOI-
pid: AT_agc052_b
tag: ['树的遍历', '位运算', '构造']
---

# [AGC052B] Tree Edges XOR

## 题目描述

[problemUrl]: https://atcoder.jp/contests/agc052/tasks/agc052_b

$ N $ 頂点の木が与えられます。ここで、$ N $ は **奇数** です。 木の頂点には $ 1 $ から $ N $ までの、辺には $ 1 $ から $ N-1 $ までの番号が付けられています。 辺 $ i $ は頂点 $ u_i,\ v_i $ を結び、初期状態での重みは $ w^1_i $ です。

あなたは、次の操作を何度でも行えます。

- 木から辺 $ (u,\ v) $ を選ぶ。この辺の現在の重みが $ w $ であるとする。$ u,\ v $ のいずれかちょうど一方に接続する各辺について、その重みを $ w $ との **XOR** に置き換える（操作前の辺の重みが $ w_1 $ であるとすると、操作後の重みは $ w_1\ \oplus\ w $ となる）。

あなたの目標は、各辺 $ i $ の重みを $ w^2_i $ とすることです。 上記の操作を何度でも行えるとして、目標の達成が可能か判定してください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ u_1 $ $ v_1 $ $ w^1_1 $ $ w^2_1 $ $ u_2 $ $ v_2 $ $ w^1_2 $ $ w^2_2 $ $ \vdots $ $ u_{N-1} $ $ v_{N-1} $ $ w^1_{N-1} $ $ w^2_{N-1} $

## 输出格式

目標とする重みの割り当てに初期状態から至ることが可能であれば `YES`、そうでなければ `NO` と出力せよ。 なお、正誤判定器は英大文字と英小文字を区別せず、どちらも受理する。

## 说明/提示

### 制約

- $ 1\ \le\ N\ \le\ 10^5 $
- $ N $ は奇数である。
- $ 1\le\ u_i,\ v_i\ \le\ N $
- $ u_i\ \neq\ v_i $
- $ 0\le\ w^1_i,\ w^2_i\ <\ 2^{30} $
- 入力中の値は全て整数である。
- 入力が表すグラフは木である。

### Sample Explanation 1

辺 $ 1 $ に対して操作を行うと、辺 $ 2 $ の重みが $ 8\ \oplus\ 1=9 $ となります。

## 样例 #1

### 输入

```
3

1 2 1 1

2 3 8 9
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
5

1 2 0 3

1 3 1 0

1 4 2 1

1 5 0 0
```

### 输出

```
NO
```



---


---
title: "[ABC133F] Colorful Tree"
layout: "post"
diff: 省选/NOI-
pid: AT_abc133_f
tag: ['线段树', '树状数组', '树链剖分']
---

# [ABC133F] Colorful Tree

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc133/tasks/abc133_f

$ 1 $ から $ N $ までの番号がつけられた $ N $ 個の頂点を持つ木があります。 この木の $ i $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結び、その色は $ c_i $、長さは $ d_i $ です。 ここで各辺の色は $ 1 $ 以上 $ N-1 $ 以下の整数で表されており、同じ整数は同じ色に、異なる整数は異なる色に対応します。

以下の $ Q $ 個の問いに答えてください。

- 問 $ j $ ($ 1\ \leq\ j\ \leq\ Q $): 色 $ x_j $ のすべての辺の長さが $ y_j $ に変更されたと仮定して、二頂点 $ u_j,\ v_j $ 間の距離を求めよ。(辺の長さの変更はこれ以降の問いには影響しない。)

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ Q $ $ a_1 $ $ b_1 $ $ c_1 $ $ d_1 $ $ : $ $ a_{N-1} $ $ b_{N-1} $ $ c_{N-1} $ $ d_{N-1} $ $ x_1 $ $ y_1 $ $ u_1 $ $ v_1 $ $ : $ $ x_Q $ $ y_Q $ $ u_Q $ $ v_Q $

## 输出格式

$ Q $ 行出力せよ。$ j $ 行目 ($ 1\ \leq\ j\ \leq\ Q $) に問 $ j $ への回答を出力すること。

## 说明/提示

### 制約

- $ 2\ \leq\ N\ \leq\ 10^5 $
- $ 1\ \leq\ Q\ \leq\ 10^5 $
- $ 1\ \leq\ a_i,\ b_i\ \leq\ N $
- $ 1\ \leq\ c_i\ \leq\ N-1 $
- $ 1\ \leq\ d_i\ \leq\ 10^4 $
- $ 1\ \leq\ x_j\ \leq\ N-1 $
- $ 1\ \leq\ y_j\ \leq\ 10^4 $
- $ 1\ \leq\ u_j\ <\ v_j\ \leq\ N $
- 与えられるグラフは木である。
- 入力中のすべての値は整数である。

### Sample Explanation 1

この入力中のグラフは次のようなものです。 !\[図\](https://img.atcoder.jp/ghi/ca75688b08f73eb63a30ce6daa54a781.png) ここで、色 $ 1 $ の辺は赤い実線で、色 $ 2 $ の辺は緑の太線で、色 $ 4 $ の辺は青い破線で示されています。 - 問 $ 1 $: 色 $ 1 $ のすべての辺の長さが $ 100 $ に変更されたと仮定すると、頂点 $ 1,\ 4 $ 間の距離は $ 100\ +\ 30\ =\ 130 $ です。 - 問 $ 2 $: 色 $ 1 $ のすべての辺の長さが $ 100 $ に変更されたと仮定すると、頂点 $ 1,\ 5 $ 間の距離は $ 100\ +\ 100\ =\ 200 $ です。 - 問 $ 3 $: 色 $ 3 $ のすべての辺の長さが $ 1000 $ に変更されたと仮定すると (そのような辺は存在しません)、頂点 $ 3,\ 4 $ 間の距離は $ 20\ +\ 10\ +\ 30\ =\ 60 $ です。この問いでは色 $ 1 $ の辺の長さが元に戻っていることに注意してください。

## 样例 #1

### 输入

```
5 3

1 2 1 10

1 3 2 20

2 4 4 30

5 2 1 40

1 100 1 4

1 100 1 5

3 1000 3 4
```

### 输出

```
130

200

60
```



---

---
title: "[ABC384G] Abs Sum"
layout: "post"
diff: 省选/NOI-
pid: AT_abc384_g
tag: ['莫队', '树状数组', '分块']
---

# [ABC384G] Abs Sum

## 题目描述

给定长度为$N$的整数序列$A,B$和长度为$K$的正整数序列$X,Y$，对于$k=1,2,3,...,K$，求$\sum_{i = 1}^{X_k} \sum_{j = 1}^{Y_k} |A_i-B_j|$。

## 输入格式

第一行输入一个整数$N$。  
第二行输入$N$个整数$A_1,A_2,A_3,...,A_N$。  
第三行输入$N$个整数$B_1,B_2,B_3,...,B_N$。  
第四行输入一个整数$K$。  
接下来共$K$行，每行两个整数，第$i$行输入的数为$X_i,Y_i$。

## 输出格式

输出共$K$行，每行一个整数，第$i$行表示当$k=i$时的结果。  
### 样例解释
#### 测试数据1
当$k=1$时，答案为$|A_1-B_1|=1$，因此第$1$行输出一个整数$1$。    
当$k=2$时，答案为$|A_1-B_1|+|A_1-B_2|=1+3=4$，因此第$2$行输出一个整数$4$。  
当$k=3$时，答案为$|A_1-B_1|+|A_2-B_1|=1+1=2$，因此第$3$行输出一个整数$2$。  
当$k=4$时，答案为$|A_1-B_1|+|A_1-B_2|+|A_2-B_1|+|A_2-B_2|=1+3+1+1=6$，因此第$4$行输出一个整数$6$。

## 样例 #1

### 输入

```
2
2 4
3 5
4
1 1
1 2
2 1
2 2
```

### 输出

```
1
4
2
6
```

## 样例 #2

### 输入

```
5
1163686 28892 1263085 2347878 520306
1332157 1202905 2437161 1291976 563395
5
5 3
1 5
2 3
1 2
5 5
```

### 输出

```
13331322
2209746
6366712
207690
20241215
```



---

---
title: "[ARC174E] Existence Counting"
layout: "post"
diff: 省选/NOI-
pid: AT_arc174_e
tag: ['树状数组', '组合数学', '排列组合']
---

# [ARC174E] Existence Counting

## 题目描述

[problemUrl]: https://atcoder.jp/contests/arc174/tasks/arc174_e

整数 $ N,K $ が与えられます。このとき、以下の条件を全て満たす長さ $ K $ の数列 $ a=(a_1,a_2,\dots,a_K) $ を考えます。

- $ a_i $ は $ 1\ \le\ a_i\ \le\ N $ を満たす整数である
- $ a $ の全ての要素は相異なる
 
$ a $ として考えられる数列を辞書順に全て並べた 「数列の列」 を辞書 $ s $ とします。

辞書 $ s $ 中に存在する数列 $ P $ が与えられるので、整数 $ t=1,2,\dots,N $ に対して以下の質問に答えてください。

- 以下の条件を全て満たす数列 $ b $ の個数を $ 998244353 $ で割った余りを求めよ。
  - 数列 $ b $ は辞書 $ s $ 中に存在する。
  - 数列 $ b $ 中に整数 $ t $ が含まれる。
  - 数列 $ b $ は辞書順で数列 $ P $ 以下である。
 
  数列の辞書順とは？ 数列 $ A\ =\ (A_1,\ \ldots,\ A_{|A|}) $ が $ B\ =\ (B_1,\ \ldots,\ B_{|B|}) $ より**辞書順で真に小さい**とは、下記の 1. と 2. のどちらかが成り立つことを言います。 1. $ |A|\ かつ\ (A_{1},\ldots,A_{|A|})\ =\ (B_1,\ldots,B_{|A|}) $ である。
2. ある整数 $ 1\leq\ i\leq\ \min\{|A|,|B|\} $ が存在して、下記の $ 2 $ つがともに成り立つ。 
  - $ (A_{1},\ldots,A_{i-1})\ =\ (B_1,\ldots,B_{i-1}) $
  - $ A_i $

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ K $ $ P_1 $ $ P_2 $ $ \dots $ $ P_K $

## 输出格式

全体で $ N $ 行出力せよ。  
 このうち $ i $ 行目には、 $ t=i $ であるときの質問の答えを整数として出力せよ。

## 说明/提示

### 制約

- 入力は全て整数
- $ 1\ \le\ K\ \le\ N\ \le\ 3\ \times\ 10^5 $
- $ P $ は問題文中の条件を満たす。
 
### Sample Explanation 1

この入力では、 $ N=4,K=2 $ です。 このとき、辞書 $ s=((1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)) $ となります。 辞書 $ s $ に含まれ、かつ辞書順で $ (3,2) $ 以下である数列のうち、 - $ 1 $ が含まれるものは $ (1,2),(1,3),(1,4),(2,1),(3,1) $ の $ 5 $ 個 - $ 2 $ が含まれるものは $ (1,2),(2,1),(2,3),(2,4),(3,2) $ の $ 5 $ 個 - $ 3 $ が含まれるものは $ (1,3),(2,3),(3,1),(3,2) $ の $ 4 $ 個 - $ 4 $ が含まれるものは $ (1,4),(2,4) $ の $ 2 $ 個 です。

## 样例 #1

### 输入

```
4 2

3 2
```

### 输出

```
5

5

4

2
```

## 样例 #2

### 输入

```
18 13

5 13 11 2 18 1 10 15 17 4 12 7 3
```

### 输出

```
925879409

905921009

665544804

665544719

783035803

349952762

349952758

349952757

349952757

349921178

212092637

710350150

378895603

129113201

129111892

129098081

129096772

110181652
```



---

---
title: "Smaller-Suffix-Free Sequences"
layout: "post"
diff: 省选/NOI-
pid: AT_ddcc2020_final_c
tag: ['后缀数组 SA']
---

# Smaller-Suffix-Free Sequences

## 题目描述

[problemUrl]: https://atcoder.jp/contests/ddcc2020-final/tasks/ddcc2020_final_c

数列 $ T\ =\ (T_1,\ \ldots,\ T_L) $ が smaller-suffix-free であるとは、 $ i\ =\ 2,\ 3,\ \ldots,\ L $ 全てについて、 数列 $ (T_i,\ T_{i+1},\ \ldots,\ T_L) $ が 辞書順で $ T $ よりも大きいことを指します。 たとえば $ (5) $ や $ (1,\ 1,\ 2,\ 3) $ はsmaller-suffix-freeであり、$ (3,\ 2,\ 1) $ や $ (2,\ 2) $ は smaller-suffix-free ではありません。

長さ $ N $ の数列 $ A\ =\ (A_1,\ \ldots,\ A_N) $ が与えられます。 各 $ i\ =\ 1,\ \ldots,\ N $ について、$ (A_i,\ A_{i+1},\ \ldots,\ A_j) $ が smaller-suffix-free であるような最大の $ j $ を求めてください。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ A_1 $ $ A_2 $ $ \ldots $ $ A_N $

## 输出格式

出力は $ N $ 行からなる。

$ i $ 行目には $ (A_i,\ A_{i+1},\ \ldots,\ A_j) $ が smaller-suffix-free であるような最大の $ j $ を出力せよ。

## 说明/提示

### 制約

- $ 1\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
- $ 1\ \leq\ A_i\ \leq\ 2\ \times\ 10^5\ (1\ \leq\ i\ \leq\ N) $

### Sample Explanation 1

$ A_1 $ から始まる smaller-suffix-free である 最長の連続する部分列は $ (A_1)\ =\ (3) $ です。したがって $ 1 $ 行目には $ 1 $ を出力します。 同様に、$ (A_2),\ (A_3,\ A_4,\ A_5,\ A_6),\ (A_4,\ A_5,\ A_6),\ (A_5,\ A_6),\ (A_6) $ がそれぞれ $ A_i\ (2\ \leq\ i\ \leq\ 6) $ から始まる smaller-suffix-free である最長の連続する部分列です。

## 样例 #1

### 输入

```
6

3 2 1 1 2 3
```

### 输出

```
1

2

6

6

6

6
```

## 样例 #2

### 输入

```
3

10 10 10
```

### 输出

```
1

2

3
```



---

---
title: "Analyzing Bit (Yet Special) Strings"
layout: "post"
diff: 省选/NOI-
pid: AT_icpc2015summer_day3_a
tag: ['并查集', '后缀自动机 SAM', '后缀数组 SA']
---

# Analyzing Bit (Yet Special) Strings

## 题目描述

[problemUrl]: https://atcoder.jp/contests/jag2015summer-day3/tasks/icpc2015summer_day3_a





---

---
title: "鉄道運賃 (Train Fare)"
layout: "post"
diff: 省选/NOI-
pid: AT_joi2016ho_c
tag: ['树状数组', '枚举']
---

# 鉄道運賃 (Train Fare)

## 题目描述

JOI 国有 $N$  个城市，编号分别为 $1, 2, \ldots, N$ 。城市 $1$  是 JOI 国的首都。  
JOI 国只有一家铁路公司，该公司在 JOI 国内共有 $M$  条线路，这些线路编号分别为 $1, 2, \ldots, M$ 。每条线路都可看作一条无向边，线路 $i(1\leqslant i\leqslant N)$  连接城市 $U_i$  和 $V_i$ 。假设你只能依靠铁路运输在不同的城市间来往。当然你可以换乘不同线路。保证任意两个城市间都有线路直接或间接连接。  
目前，任何线路的票价是 1 日元。该公司经营不善，只好计划在未来 $Q$  年里提高票价。从提价计划开始的第 $j$  年初 $(1\leqslant j\leqslant Q)$ ，线路 $R_j$  的票价会从 1 日元升至 2 日元。 之后该线路票价一直保持在 2 日元，不会再提高。

该公司每年都会对每个城市的居民进行满意度调查。在提价计划开始之前，任何一个城市的居民都对该公司感到满意。但由于价格上涨，可能有一些城市的居民会不满。每年的满意度调查都在当年提价后进行。因此，计划开始后第 $j$  年 $(1\leqslant j\leqslant Q)$  进行满意度调查时，线路 $R_1,R_2,\ldots,R_j$  已经提价，剩余线路的票价暂无变化。  
在第 $j$  年的满意度调查中，如果**当年城市 $k(2\leqslant k\leqslant N)$  到首都的最低总票价 大于 提价计划开始前城市 $k$  到首都的最低总票价**，城市 $k$  的居民会对铁路公司感到不满。  
使用多条路线的费用是每条路线的运费的总和。首都人民不会对该公司感到不满。提价后最低费用的路线可能与计划开始前最低费用的路线有所不同。

## 输入格式

第一行有三个整数 $N, M, Q$ ，用空格分隔。  
在接下来的 $M$  行中，第 $i(1\leqslant i\leqslant M)$  行有两个整数 $U_i, V_i$ ，用空格分隔。  
在接下来的 $Q$  行中，第 $j(1\leqslant i\leqslant Q)$  行有一个整数 $R_j$ 。

## 输出格式

输出共 $Q$  行，第 $j(1\leqslant i\leqslant Q)$  行有一个整数，表示在计划开始后第 $j$  年的满意度调查中，有多少个城市的居民对铁路公司不满。

#### 来源
JOI 2015/2016 T3，译者 @[Planet6174](/space/show?uid=29762)

感谢@Planet6174 提供的翻译

## 样例 #1

### 输入

```
5 6 5
1 2
1 3
4 2
3 2
2 5
5 3
5
2
4
1
3
```

### 输出

```
0
2
2
4
4
```

## 样例 #2

### 输入

```
4 6 6
1 2
1 3
1 4
2 3
2 4
3 4
1
4
2
5
3
6
```

### 输出

```
1
1
2
2
3
3
```

## 样例 #3

### 输入

```
2 1 1
1 2
1
```

### 输出

```
1
```



---

---
title: "Golf"
layout: "post"
diff: 省选/NOI-
pid: AT_pakencamp_2021_day2_o
tag: ['线段树', '后缀数组 SA']
---

# Golf

## 题目描述

给定一个字符串 $S$。定义子串 $S[i:j]$ 表示从字符串 $S$ 的第 $i$ 个字符到第 $j$ 个字符组成的子串。

如果子串 $T$ 满足以下条件，则称其为一个「好字符串」：

- 长度在 1 到 $|S|$ 之间，即 $1 \leq |T| \leq |S|$
- 恰好存在唯一一个整数 $i$，使得 $S[i:i+|T|-1]$ 与 $T$ 相等

例如，若字符串 $S$ 为 `abcbabc`，那么 `cb`、`abcb` 和 `abcbabc` 都是「好字符串」，但 `abc` 和 `zyx` 不是。

接下来有 $Q$ 个查询。对于第 $i$ 个查询，给出两个整数 $L_i$ 和 $R_i$，满足 $1 \leq L_i \leq R_i \leq |S|$，然后解决以下问题：

- 寻找两个整数 $l$ 和 $r$，使得 $1 \leq l \leq L_i$ 且 $R_i \leq r \leq |S|$，并使得子串 $S[l:r]$ 是一个「好字符串」。然后计算 $r-l+1$ 的最小可能值。

## 输入格式

输入通过标准输入提供，格式如下：

> $ S $ $ Q $ $ L_1 $ $ R_1 $ $ L_2 $ $ R_2 $ $ \vdots $ $ L_Q $ $ R_Q $

## 输出格式

输出 $Q$ 行。对于每个查询，第 $i$ 行输出对应查询的结果。

## 说明/提示

- 字符串 $S$ 仅由小写英文字母组成。
- $1 \leq |S| \leq 200,000$
- $1 \leq Q \leq 200,000$
- 对于每个 $i$，满足 $1 \leq L_i \leq R_i \leq |S|$

### 样例解释

对于第一个查询，我们可以取 $l=2, r=4$，此时 $r-l+1=3$，这是最小值。注意 `bc` 不是「好字符串」，所以不能取 $l=2, r=3$。在第二个查询中，取 $l=2, r=5$，得到 $r-l+1=4$，是最小值。在第三个查询中，我们取 $l=1, r=7$，则 $r-l+1=7$，这是最小值。值得注意的是，字符串 $S$ 本身是一个「好字符串」。

 **本翻译由 AI 自动生成**

## 样例 #1

### 输入

```
abcbabc

5

2 3

2 5

1 7

4 4

6 6
```

### 输出

```
3

4

7

2

3
```

## 样例 #2

### 输入

```
yyxxzzyyxx

5

3 3

1 1

10 10

5 5

7 7
```

### 输出

```
3

5

5

2

2
```

## 样例 #3

### 输入

```
qprrrrrpprqrrppq

20

7 8

6 8

4 7

7 12

6 7

5 5

6 8

4 6

4 4

2 3

7 11

8 9

6 7

11 12

11 15

5 6

4 5

13 13

9 13

5 7
```

### 输出

```
4

4

5

6

4

4

4

5

3

3

5

3

4

2

5

4

4

3

5

4
```



---

